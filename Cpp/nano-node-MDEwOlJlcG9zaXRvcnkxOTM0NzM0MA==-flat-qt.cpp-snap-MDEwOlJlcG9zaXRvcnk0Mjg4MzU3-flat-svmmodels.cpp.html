
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 1.2623985572587917%, Tokens: 9</h2>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-qt.cpp</h3>
            <pre><code>1  #include <nano/lib/config.hpp>
2  #include <nano/qt/qt.hpp>
3  #include <boost/foreach.hpp>
4  #include <boost/property_tree/json_parser.hpp>
5  #include <boost/property_tree/ptree.hpp>
6  #include <cmath>
7  #include <iomanip>
8  #include <sstream>
9  namespace
10  {
11  void show_line_error (QLineEdit & line)
12  {
13  	line.setStyleSheet ("QLineEdit { color: red }");
14  }
15  void show_line_ok (QLineEdit & line)
16  {
17  	line.setStyleSheet ("QLineEdit { color: black }");
18  }
19  void show_label_error (QLabel & label)
20  {
21  	label.setStyleSheet ("QLabel { color: red }");
22  }
23  void show_label_ok (QLabel & label)
24  {
25  	label.setStyleSheet ("QLabel { color: black }");
26  }
27  void show_button_error (QPushButton & button)
28  {
29  	button.setStyleSheet ("QPushButton { color: red }");
30  }
31  void show_button_ok (QPushButton & button)
32  {
33  	button.setStyleSheet ("QPushButton { color: black }");
34  }
35  void show_button_success (QPushButton & button)
36  {
37  	button.setStyleSheet ("QPushButton { color: blue }");
38  }
39  }
40  bool nano_qt::eventloop_processor::event (QEvent * event_a)
41  {
42  	debug_assert (dynamic_cast<nano_qt::eventloop_event *> (event_a) != nullptr);
43  	static_cast<nano_qt::eventloop_event *> (event_a)->action ();
44  	return true;
45  }
46  nano_qt::eventloop_event::eventloop_event (std::function<void ()> const & action_a) :
47  	QEvent (QEvent::Type::User),
48  	action (action_a)
49  {
50  }
51  nano_qt::self_pane::self_pane (nano_qt::wallet & wallet_a, nano::account const & account_a) :
52  	window (new QWidget),
53  	layout (new QVBoxLayout),
54  	self_layout (new QHBoxLayout),
55  	self_window (new QWidget),
56  	your_account_label (new QLabel ("Your Nano account:")),
57  	account_window (new QWidget),
58  	account_layout (new QHBoxLayout),
59  	account_text (new QLineEdit),
60  	copy_button (new QPushButton ("Copy")),
61  	balance_window (new QWidget),
62  	balance_layout (new QHBoxLayout),
63  	balance_label (new QLabel),
64  	wallet (wallet_a)
65  {
66  	your_account_label->setStyleSheet ("font-weight: bold;");
67  	std::string network = wallet.node.network_params.network.get_current_network_as_string ();
68  	if (!network.empty ())
69  	{
70  		network[0] = std::toupper (network[0]);
71  	}
72  	version = new QLabel (boost::str (boost::format ("%1% %2% network") % NANO_VERSION_STRING % network).c_str ());
73  	self_layout->addWidget (your_account_label);
74  	self_layout->addStretch ();
75  	self_layout->addWidget (version);
76  	self_layout->setContentsMargins (0, 0, 0, 0);
77  	self_window->setLayout (self_layout);
78  	account_text->setReadOnly (true);
79  	account_text->setStyleSheet ("QLineEdit{ background: #ddd; }");
80  	account_layout->addWidget (account_text, 9);
81  	account_layout->addWidget (copy_button, 1);
82  	account_layout->setContentsMargins (0, 0, 0, 0);
83  	account_window->setLayout (account_layout);
84  	layout->addWidget (self_window);
85  	layout->addWidget (account_window);
86  	balance_label->setStyleSheet ("font-weight: bold;");
87  	balance_layout->addWidget (balance_label);
88  	balance_layout->addStretch ();
89  	balance_layout->setContentsMargins (0, 0, 0, 0);
90  	balance_window->setLayout (balance_layout);
91  	layout->addWidget (balance_window);
92  	layout->setContentsMargins (5, 5, 5, 5);
93  	window->setLayout (layout);
94  	QObject::connect (copy_button, &QPushButton::clicked, [this] () {
95  		this->wallet.application.clipboard ()->setText (QString (this->wallet.account.to_account ().c_str ()));
96  		copy_button->setText ("Copied!");
97  		this->wallet.node.workers.add_timed_task (std::chrono::steady_clock::now () + std::chrono::seconds (2), [this] () {
98  			this->wallet.application.postEvent (&this->wallet.processor, new eventloop_event ([this] () {
99  				copy_button->setText ("Copy");
100  			}));
101  		});
102  	});
103  }
104  void nano_qt::self_pane::set_balance_text (std::pair<nano::uint128_t, nano::uint128_t> balance_a)
105  {
106  	auto final_text (std::string ("Balance: ") + wallet.format_balance (balance_a.first));
107  	if (!balance_a.second.is_zero ())
108  	{
109  		final_text += "\nReady to receive: " + wallet.format_balance (balance_a.second);
110  	}
111  	wallet.self.balance_label->setText (QString (final_text.c_str ()));
112  }
113  nano_qt::accounts::accounts (nano_qt::wallet & wallet_a) :
114  	wallet_balance_label (new QLabel),
115  	window (new QWidget),
116  	layout (new QVBoxLayout),
117  	model (new QStandardItemModel),
118  	view (new QTableView),
119  	use_account (new QPushButton ("Use account")),
120  	create_account (new QPushButton ("Create account")),
121  	import_wallet (new QPushButton ("Import wallet")),
122  	backup_seed (new QPushButton ("Copy wallet seed to clipboard")),
123  	separator (new QFrame),
124  	account_key_line (new QLineEdit),
125  	account_key_button (new QPushButton ("Import adhoc key")),
126  	back (new QPushButton ("Back")),
127  	wallet (wallet_a)
128  {
129  	separator->setFrameShape (QFrame::HLine);
130  	separator->setFrameShadow (QFrame::Sunken);
131  	model->setHorizontalHeaderItem (0, new QStandardItem ("Balance"));
132  	model->setHorizontalHeaderItem (1, new QStandardItem ("Account"));
133  	view->setEditTriggers (QAbstractItemView::NoEditTriggers);
134  	view->setModel (model);
135  	view->verticalHeader ()->hide ();
136  	view->setContextMenuPolicy (Qt::ContextMenuPolicy::CustomContextMenu);
137  	view->horizontalHeader ()->setStretchLastSection (true);
138  	layout->addWidget (wallet_balance_label);
139  	layout->addWidget (view);
140  	layout->addWidget (use_account);
141  	layout->addWidget (create_account);
142  	layout->addWidget (import_wallet);
143  	layout->addWidget (backup_seed);
144  	layout->addWidget (separator);
145  	layout->addWidget (account_key_line);
146  	layout->addWidget (account_key_button);
147  	layout->addWidget (back);
148  	window->setLayout (layout);
149  	QObject::connect (use_account, &QPushButton::released, [this] () {
150  		auto selection (view->selectionModel ()->selection ().indexes ());
151  		if (selection.size () == 1)
152  		{
153  			auto error (this->wallet.account.decode_account (model->item (selection[0].row (), 1)->text ().toStdString ()));
154  			(void)error;
155  			debug_assert (!error);
156  			this->wallet.refresh ();
157  		}
158  	});
159  	QObject::connect (account_key_button, &QPushButton::released, [this] () {
160  		QString key_text_wide (account_key_line->text ());
161  		std::string key_text (key_text_wide.toLocal8Bit ());
162  		nano::raw_key key;
163  		if (!key.decode_hex (key_text))
164  		{
165  			show_line_ok (*account_key_line);
166  			account_key_line->clear ();
167  			this->wallet.wallet_m->insert_adhoc (key);
168  			this->wallet.accounts.refresh ();
169  			this->wallet.accounts.refresh_wallet_balance ();
170  			this->wallet.history.refresh ();
171  		}
172  		else
173  		{
174  			show_line_error (*account_key_line);
175  		}
176  	});
177  	QObject::connect (back, &QPushButton::clicked, [this] () {
178  		this->wallet.pop_main_stack ();
179  	});
180  	QObject::connect (create_account, &QPushButton::released, [this] () {
181  		{
182  			auto transaction (this->wallet.wallet_m->wallets.tx_begin_write ());
183  			if (this->wallet.wallet_m->store.valid_password (transaction))
184  			{
185  				this->wallet.wallet_m->deterministic_insert (transaction);
186  				show_button_success (*create_account);
187  				create_account->setText ("New account was created");
188  				this->wallet.node.workers.add_timed_task (std::chrono::steady_clock::now () + std::chrono::seconds (5), [this] () {
189  					this->wallet.application.postEvent (&this->wallet.processor, new eventloop_event ([this] () {
190  						show_button_ok (*create_account);
191  						create_account->setText ("Create account");
192  					}));
193  				});
194  			}
195  			else
196  			{
197  				show_button_error (*create_account);
198  				create_account->setText ("Wallet is locked, unlock it to create account");
199  				this->wallet.node.workers.add_timed_task (std::chrono::steady_clock::now () + std::chrono::seconds (5), [this] () {
200  					this->wallet.application.postEvent (&this->wallet.processor, new eventloop_event ([this] () {
201  						show_button_ok (*create_account);
202  						create_account->setText ("Create account");
203  					}));
204  				});
205  			}
206  		}
207  		refresh ();
208  	});
209  	QObject::connect (import_wallet, &QPushButton::released, [this] () {
210  		this->wallet.push_main_stack (this->wallet.import.window);
211  	});
212  	QObject::connect (backup_seed, &QPushButton::released, [this] () {
213  		nano::raw_key seed;
214  		auto transaction (this->wallet.wallet_m->wallets.tx_begin_read ());
215  		if (this->wallet.wallet_m->store.valid_password (transaction))
216  		{
217  			this->wallet.wallet_m->store.seed (seed, transaction);
218  			this->wallet.application.clipboard ()->setText (QString (seed.to_string ().c_str ()));
219  			show_button_success (*backup_seed);
220  			backup_seed->setText ("Seed was copied to clipboard");
221  			this->wallet.node.workers.add_timed_task (std::chrono::steady_clock::now () + std::chrono::seconds (5), [this] () {
222  				this->wallet.application.postEvent (&this->wallet.processor, new eventloop_event ([this] () {
223  					show_button_ok (*backup_seed);
224  					backup_seed->setText ("Copy wallet seed to clipboard");
225  				}));
226  			});
227  		}
228  		else
229  		{
230  			this->wallet.application.clipboard ()->setText ("");
231  			show_button_error (*backup_seed);
232  			backup_seed->setText ("Wallet is locked, unlock it to enable the backup");
233  			this->wallet.node.workers.add_timed_task (std::chrono::steady_clock::now () + std::chrono::seconds (5), [this] () {
234  				this->wallet.application.postEvent (&this->wallet.processor, new eventloop_event ([this] () {
235  					show_button_ok (*backup_seed);
236  					backup_seed->setText ("Copy wallet seed to clipboard");
237  				}));
238  			});
239  		}
240  	});
241  	QObject::connect (account_key_line, &QLineEdit::textChanged, [this] (const QString & value) {
242  		auto pos = account_key_line->cursorPosition ();
243  		account_key_line->setText (value.trimmed ());
244  		account_key_line->setCursorPosition (pos);
245  	});
246  	refresh_wallet_balance ();
247  }
248  void nano_qt::accounts::refresh_wallet_balance ()
249  {
250  	auto transaction (this->wallet.wallet_m->wallets.tx_begin_read ());
251  	auto block_transaction (this->wallet.node.store.tx_begin_read ());
252  	nano::uint128_t balance (0);
253  	nano::uint128_t pending (0);
254  	for (auto i (this->wallet.wallet_m->store.begin (transaction)), j (this->wallet.wallet_m->store.end ()); i != j; ++i)
255  	{
256  		nano::public_key const & key (i->first);
257  		balance = balance + (this->wallet.node.ledger.account_balance (block_transaction, key));
258  		pending = pending + (this->wallet.node.ledger.account_receivable (block_transaction, key));
259  	}
260  	auto final_text (std::string ("Balance: ") + wallet.format_balance (balance));
261  	if (!pending.is_zero ())
262  	{
263  		final_text += "\nReady to receive: " + wallet.format_balance (pending);
264  	}
265  	wallet_balance_label->setText (QString (final_text.c_str ()));
266  	this->wallet.node.workers.add_timed_task (std::chrono::steady_clock::now () + std::chrono::seconds (60), [this] () {
267  		this->wallet.application.postEvent (&this->wallet.processor, new eventloop_event ([this] () {
268  			refresh_wallet_balance ();
269  		}));
270  	});
271  }
272  void nano_qt::accounts::refresh ()
273  {
274  	model->removeRows (0, model->rowCount ());
275  	auto transaction (wallet.wallet_m->wallets.tx_begin_read ());
276  	auto block_transaction (this->wallet.node.store.tx_begin_read ());
277  	QBrush brush;
278  	for (auto i (wallet.wallet_m->store.begin (transaction)), j (wallet.wallet_m->store.end ()); i != j; ++i)
279  	{
280  		nano::public_key key (i->first);
281  		auto balance_amount (wallet.node.ledger.account_balance (block_transaction, key));
282  		bool display (true);
283  		switch (wallet.wallet_m->store.key_type (i->second))
284  		{
285  			case nano::key_type::adhoc:
286  			{
287  				brush.setColor ("red");
288  				display = !balance_amount.is_zero ();
289  				break;
290  			}
291  			default:
292  			{
293  				brush.setColor ("black");
294  				break;
295  			}
296  		}
297  		if (display)
298  		{
299  			QList<QStandardItem *> items;
300  			std::string balance = wallet.format_balance (balance_amount);
301  			items.push_back (new QStandardItem (balance.c_str ()));
302  			auto account (new QStandardItem (QString (key.to_account ().c_str ())));
303  			account->setForeground (brush);
304  			items.push_back (account);
305  			model->appendRow (items);
306  		}
307  	}
308  }
309  nano_qt::import::import (nano_qt::wallet & wallet_a) :
310  	window (new QWidget),
311  	layout (new QVBoxLayout),
312  	seed_label (new QLabel ("Seed:")),
313  	seed (new QLineEdit),
314  	clear_label (new QLabel ("Modifying seed clears existing keys\nType 'clear keys' below to confirm:")),
315  	clear_line (new QLineEdit),
316  	import_seed (new QPushButton ("Import seed")),
317  	separator (new QFrame),
318  	filename_label (new QLabel ("Path to file:")),
319  	filename (new QLineEdit),
320  	password_label (new QLabel ("Password:")),
321  	password (new QLineEdit),
322  	perform (new QPushButton ("Import")),
323  	back (new QPushButton ("Back")),
324  	wallet (wallet_a)
325  {
326  	layout->addWidget (seed_label);
327  	layout->addWidget (seed);
328  	layout->addWidget (clear_label);
329  	layout->addWidget (clear_line);
330  	clear_line->setPlaceholderText ("clear keys");
331  	layout->addWidget (import_seed);
332  	layout->addWidget (separator);
333  	layout->addWidget (filename_label);
334  	layout->addWidget (filename);
335  	layout->addWidget (password_label);
336  	layout->addWidget (password);
337  	layout->addWidget (perform);
338  	layout->addStretch ();
339  	layout->addWidget (back);
340  	window->setLayout (layout);
341  	QObject::connect (perform, &QPushButton::released, [this] () {
342  		std::ifstream stream;
343  		stream.open (filename->text ().toStdString ().c_str ());
344  		if (!stream.fail ())
345  		{
346  			show_line_ok (*filename);
347  			std::stringstream contents;
348  			contents << stream.rdbuf ();
349  			if (!this->wallet.wallet_m->import (contents.str (), password->text ().toStdString ().c_str ()))
350  			{
351  				show_line_ok (*password);
352  				this->wallet.accounts.refresh ();
353  				password->clear ();
354  				filename->clear ();
355  			}
356  			else
357  			{
358  				show_line_error (*password);
359  			}
360  		}
361  		else
362  		{
363  			show_line_error (*filename);
364  		}
365  	});
366  	QObject::connect (back, &QPushButton::released, [this] () {
367  		this->wallet.pop_main_stack ();
368  	});
369  	QObject::connect (import_seed, &QPushButton::released, [this] () {
370  		if (clear_line->text ().toStdString () == "clear keys")
371  		{
372  			show_line_ok (*clear_line);
373  			nano::raw_key seed_l;
374  			if (!seed_l.decode_hex (seed->text ().toStdString ()))
375  			{
376  				bool successful (false);
377  				{
378  					auto transaction (this->wallet.wallet_m->wallets.tx_begin_write ());
379  					if (this->wallet.wallet_m->store.valid_password (transaction))
380  					{
381  						this->wallet.account = this->wallet.wallet_m->change_seed (transaction, seed_l);
382  						successful = true;
383  						if (this->wallet.node.bootstrap_initiator.in_progress ())
384  						{
385  							this->wallet.needs_deterministic_restore = true;
386  						}
387  					}
388  					else
389  					{
390  						show_line_error (*seed);
391  						show_button_error (*import_seed);
392  						import_seed->setText ("Wallet is locked, unlock it to enable the import");
393  						this->wallet.node.workers.add_timed_task (std::chrono::steady_clock::now () + std::chrono::seconds (10), [this] () {
394  							this->wallet.application.postEvent (&this->wallet.processor, new eventloop_event ([this] () {
395  								show_line_ok (*seed);
396  								show_button_ok (*import_seed);
397  								import_seed->setText ("Import seed");
398  							}));
399  						});
400  					}
401  				}
402  				if (successful)
403  				{
404  					seed->clear ();
405  					clear_line->clear ();
406  					show_line_ok (*seed);
407  					show_button_success (*import_seed);
408  					import_seed->setText ("Successful import of seed");
409  					this->wallet.refresh ();
410  					this->wallet.node.workers.add_timed_task (std::chrono::steady_clock::now () + std::chrono::seconds (5), [this] () {
411  						this->wallet.application.postEvent (&this->wallet.processor, new eventloop_event ([this] () {
412  							show_button_ok (*import_seed);
413  							import_seed->setText ("Import seed");
414  						}));
415  					});
416  				}
417  			}
418  			else
419  			{
420  				show_line_error (*seed);
421  				show_button_error (*import_seed);
422  				if (seed->text ().toStdString ().size () != 64)
423  				{
424  					import_seed->setText ("Incorrect seed, length must be 64");
425  				}
426  				else
427  				{
428  					import_seed->setText ("Incorrect seed. Only HEX characters allowed");
429  				}
430  				this->wallet.node.workers.add_timed_task (std::chrono::steady_clock::now () + std::chrono::seconds (5), [this] () {
431  					this->wallet.application.postEvent (&this->wallet.processor, new eventloop_event ([this] () {
432  						show_button_ok (*import_seed);
433  						import_seed->setText ("Import seed");
434  					}));
435  				});
436  			}
437  		}
438  		else
439  		{
440  			show_line_error (*clear_line);
441  			show_button_error (*import_seed);
442  			import_seed->setText ("Type words 'clear keys'");
443  			this->wallet.node.workers.add_timed_task (std::chrono::steady_clock::now () + std::chrono::seconds (5), [this] () {
444  				this->wallet.application.postEvent (&this->wallet.processor, new eventloop_event ([this] () {
445  					show_button_ok (*import_seed);
446  					import_seed->setText ("Import seed");
447  				}));
448  			});
449  		}
450  	});
451  	QObject::connect (seed, &QLineEdit::textChanged, [this] (const QString & value) {
452  		auto pos = seed->cursorPosition ();
453  		seed->setText (value.trimmed ());
454  		seed->setCursorPosition (pos);
455  	});
456  	QObject::connect (filename, &QLineEdit::textChanged, [this] (const QString & value) {
457  		auto pos = filename->cursorPosition ();
458  		filename->setText (value.trimmed ());
459  		filename->setCursorPosition (pos);
460  	});
461  }
462  nano_qt::history::history (nano::ledger & ledger_a, nano::account const & account_a, nano_qt::wallet & wallet_a) :
463  	window (new QWidget),
464  	layout (new QVBoxLayout),
465  	model (new QStandardItemModel),
466  	view (new QTableView),
467  	tx_window (new QWidget),
468  	tx_layout (new QHBoxLayout),
469  	tx_label (new QLabel ("Account history count:")),
470  	tx_count (new QSpinBox),
471  	ledger (ledger_a),
472  	account (account_a),
473  	wallet (wallet_a)
474  { &bsol;*
475  	tx_count->setRange (1, 256);
476  	tx_layout->addWidget (tx_label);
477  	tx_layout->addWidget (tx_count);
478  	tx_layout->setContentsMargins (0, 0, 0, 0);
479  	tx_window->setLayout (tx_layout);*/
480  	model->setHorizontalHeaderItem (0, new QStandardItem ("Type"));
481  	model->setHorizontalHeaderItem (1, new QStandardItem ("Account"));
482  	model->setHorizontalHeaderItem (2, new QStandardItem ("Amount"));
483  	model->setHorizontalHeaderItem (3, new QStandardItem ("Hash"));
484  	view->setModel (model);
485  	view->setEditTriggers (QAbstractItemView::NoEditTriggers);
486  	view->verticalHeader ()->hide ();
487  	view->horizontalHeader ()->setStretchLastSection (true);
488  	layout->addWidget (view);
489  	layout->setContentsMargins (0, 0, 0, 0);
490  	window->setLayout (layout);
491  	tx_count->setValue (32);
492  }
493  namespace
494  {
495  class short_text_visitor : public nano::block_visitor
496  {
497  public:
498  	short_text_visitor (nano::transaction const & transaction_a, nano::ledger & ledger_a) :
499  		transaction (transaction_a),
500  		ledger (ledger_a)
501  	{
502  	}
503  	void send_block (nano::send_block const & block_a)
504  	{
505  		type = "Send";
506  		account = block_a.hashables.destination;
507  		bool error_or_pruned (false);
508  		amount = ledger.amount_safe (transaction, block_a.hash (), error_or_pruned);
509  		if (error_or_pruned)
510  		{
511  			type = "Send (pruned)";
512  		}
513  	}
514  	void receive_block (nano::receive_block const & block_a)
515  	{
516  		type = "Receive";
517  		bool error_or_pruned (false);
518  		account = ledger.account_safe (transaction, block_a.hashables.source, error_or_pruned);
519  		amount = ledger.amount_safe (transaction, block_a.hash (), error_or_pruned);
520  		if (error_or_pruned)
521  		{
522  			type = "Receive (pruned)";
523  		}
524  	}
525  	void open_block (nano::open_block const & block_a)
526  	{
527  		type = "Receive";
528  		if (block_a.hashables.source != ledger.constants.genesis->account ())
529  		{
530  			bool error_or_pruned (false);
531  			account = ledger.account_safe (transaction, block_a.hashables.source, error_or_pruned);
532  			amount = ledger.amount_safe (transaction, block_a.hash (), error_or_pruned);
533  			if (error_or_pruned)
534  			{
535  				type = "Receive (pruned)";
536  			}
537  		}
538  		else
539  		{
540  			account = ledger.constants.genesis->account ();
541  			amount = nano::dev::constants.genesis_amount;
542  		}
543  	}
544  	void change_block (nano::change_block const & block_a)
545  	{
546  		type = "Change";
547  		amount = 0;
548  		account = block_a.hashables.representative;
549  	}
550  	void state_block (nano::state_block const & block_a)
551  	{
552  		auto balance (block_a.hashables.balance.number ());
553  		bool error_or_pruned (false);
554  		auto previous_balance (ledger.balance_safe (transaction, block_a.hashables.previous, error_or_pruned));
555  		if (error_or_pruned)
556  		{
557  			type = "Unknown (pruned)";
558  			amount = 0;
559  			account = block_a.hashables.account;
560  		}
561  		else if (balance < previous_balance)
562  		{
563  			type = "Send";
564  			amount = previous_balance - balance;
565  			account = block_a.hashables.link.as_account ();
566  		}
567  		else
568  		{
569  			if (block_a.hashables.link.is_zero ())
570  			{
571  				type = "Change";
572  				account = block_a.hashables.representative;
573  			}
574  			else if (balance == previous_balance && ledger.is_epoch_link (block_a.hashables.link))
575  			{
576  				type = "Epoch";
577  				account = ledger.epoch_signer (block_a.hashables.link);
578  			}
579  			else
580  			{
581  				type = "Receive";
582  				account = ledger.account_safe (transaction, block_a.hashables.link.as_block_hash (), error_or_pruned);
583  				if (error_or_pruned)
584  				{
585  					type = "Receive (pruned)";
586  				}
587  			}
588  			amount = balance - previous_balance;
589  		}
590  	}
591  	nano::transaction const & transaction;
592  	nano::ledger & ledger;
593  	std::string type;
594  	nano::uint128_t amount;
595  	nano::account account;
596  };
597  }
598  void nano_qt::history::refresh ()
599  {
600  	auto transaction (ledger.store.tx_begin_read ());
601  	model->removeRows (0, model->rowCount ());
602  	auto hash (ledger.latest (transaction, account));
603  	short_text_visitor visitor (transaction, ledger);
604  	for (auto i (0), n (tx_count->value ()); i < n && !hash.is_zero (); ++i)
605  	{
606  		QList<QStandardItem *> items;
607  		auto block (ledger.store.block.get (transaction, hash));
608  		if (block != nullptr)
609  		{
610  			block->visit (visitor);
611  			items.push_back (new QStandardItem (QString (visitor.type.c_str ())));
612  			items.push_back (new QStandardItem (QString (visitor.account.to_account ().c_str ())));
613  			auto balanceItem = new QStandardItem (QString (wallet.format_balance (visitor.amount).c_str ()));
614  			balanceItem->setData (Qt::AlignRight, Qt::TextAlignmentRole);
615  			items.push_back (balanceItem);
616  			items.push_back (new QStandardItem (QString (hash.to_string ().c_str ())));
617  			hash = block->previous ();
618  			model->appendRow (items);
619  		}
620  	}
621  }
622  nano_qt::block_viewer::block_viewer (nano_qt::wallet & wallet_a) :
623  	window (new QWidget),
624  	layout (new QVBoxLayout),
625  	hash_label (new QLabel ("Hash:")),
626  	hash (new QLineEdit),
627  	block_label (new QLabel ("Block:")),
628  	block (new QPlainTextEdit),
629  	successor_label (new QLabel ("Successor:")),
630  	successor (new QLineEdit),
631  	retrieve (new QPushButton ("Retrieve")),
632  	rebroadcast (new QPushButton ("Rebroadcast")),
633  	back (new QPushButton ("Back")),
634  	wallet (wallet_a)
635  {
636  	layout->addWidget (hash_label);
637  	layout->addWidget (hash);
638  	layout->addWidget (block_label);
639  	layout->addWidget (block);
640  	layout->addWidget (successor_label);
641  	layout->addWidget (successor);
642  	layout->addWidget (retrieve);
643  	layout->addWidget (rebroadcast);
644  	layout->addStretch ();
645  	layout->addWidget (back);
646  	window->setLayout (layout);
647  	QObject::connect (back, &QPushButton::released, [this] () {
648  		this->wallet.pop_main_stack ();
649  	});
650  	QObject::connect (retrieve, &QPushButton::released, [this] () {
651  		nano::block_hash hash_l;
652  		if (!hash_l.decode_hex (hash->text ().toStdString ()))
653  		{
654  			auto transaction (this->wallet.node.store.tx_begin_read ());
655  			auto block_l (this->wallet.node.store.block.get (transaction, hash_l));
656  			if (block_l != nullptr)
657  			{
658  				std::string contents;
659  				block_l->serialize_json (contents);
660  				block->setPlainText (contents.c_str ());
661  				auto successor_l (this->wallet.node.store.block.successor (transaction, hash_l));
662  				successor->setText (successor_l.to_string ().c_str ());
663  			}
664  			else
665  			{
666  				block->setPlainText ("Block not found");
667  			}
668  		}
669  		else
670  		{
671  			block->setPlainText ("Bad block hash");
672  		}
673  	});
674  	QObject::connect (rebroadcast, &QPushButton::released, [this] () {
675  		nano::block_hash block;
676  		auto error (block.decode_hex (hash->text ().toStdString ()));
677  		if (!error)
678  		{
679  			auto transaction (this->wallet.node.store.tx_begin_read ());
680  			if (this->wallet.node.store.block.exists (transaction, block))
681  			{
682  				rebroadcast->setEnabled (false);
683  				this->wallet.node.background ([this, block] () {
684  					rebroadcast_action (block);
685  				});
686  			}
687  		}
688  	});
689  	QObject::connect (hash, &QLineEdit::textChanged, [this] (const QString & value) {
690  		auto pos = hash->cursorPosition ();
691  		hash->setText (value.trimmed ());
692  		hash->setCursorPosition (pos);
693  	});
694  	rebroadcast->setToolTip ("Rebroadcast block into the network");
695  }
696  void nano_qt::block_viewer::rebroadcast_action (nano::block_hash const & hash_a)
697  {
698  	auto done (true);
699  	auto transaction (wallet.node.ledger.store.tx_begin_read ());
700  	auto block (wallet.node.store.block.get (transaction, hash_a));
701  	if (block != nullptr)
702  	{
703  		wallet.node.network.flood_block (block);
704  		auto successor (wallet.node.store.block.successor (transaction, hash_a));
705  		if (!successor.is_zero ())
706  		{
707  			done = false;
708  			wallet.node.workers.add_timed_task (std::chrono::steady_clock::now () + std::chrono::seconds (1), [this, successor] () {
709  				this->wallet.application.postEvent (&this->wallet.processor, new eventloop_event ([this, successor] () {
710  					rebroadcast_action (successor);
711  				}));
712  			});
713  		}
714  	}
715  	if (done)
716  	{
717  		rebroadcast->setEnabled (true);
718  	}
719  }
720  nano_qt::account_viewer::account_viewer (nano_qt::wallet & wallet_a) :
721  	window (new QWidget),
722  	layout (new QVBoxLayout),
723  	account_label (new QLabel ("Account:")),
724  	account_line (new QLineEdit),
725  	refresh (new QPushButton ("Refresh")),
726  	balance_window (new QWidget),
727  	balance_layout (new QHBoxLayout),
728  	balance_label (new QLabel),
729  	history (wallet_a.node.ledger, account, wallet_a),
730  	back (new QPushButton ("Back")),
731  	account (wallet_a.account),
732  	wallet (wallet_a)
733  {
734  	layout->addWidget (account_label);
735  	layout->addWidget (account_line);
736  	layout->addWidget (refresh);
737  	balance_layout->addWidget (balance_label);
738  	balance_layout->addStretch ();
739  	balance_layout->setContentsMargins (0, 0, 0, 0);
740  	balance_window->setLayout (balance_layout);
741  	layout->addWidget (balance_window);
742  	layout->addWidget (history.window);
743  	layout->addWidget (back);
744  	window->setLayout (layout);
745  	QObject::connect (back, &QPushButton::released, [this] () {
746  		this->wallet.pop_main_stack ();
747  	});
748  	QObject::connect (refresh, &QPushButton::released, [this] () {
749  		account.clear ();
750  		if (!account.decode_account (account_line->text ().toStdString ()))
751  		{
752  			show_line_ok (*account_line);
753  			this->history.refresh ();
754  			auto balance (this->wallet.node.balance_pending (account, false));
755  			auto final_text (std::string ("Balance (NANO): ") + wallet.format_balance (balance.first));
756  			if (!balance.second.is_zero ())
757  			{
758  				final_text += "\nReady to receive: " + wallet.format_balance (balance.second);
759  			}
760  			balance_label->setText (QString (final_text.c_str ()));
761  		}
762  		else
763  		{
764  			show_line_error (*account_line);
765  			balance_label->clear ();
766  		}
767  	});
768  	QObject::connect (account_line, &QLineEdit::textChanged, [this] (const QString & value) {
769  		auto pos = account_line->cursorPosition ();
770  		account_line->setText (value.trimmed ());
771  		account_line->setCursorPosition (pos);
772  	});
773  }
774  nano_qt::stats_viewer::stats_viewer (nano_qt::wallet & wallet_a) :
775  	window (new QWidget),
776  	layout (new QVBoxLayout),
777  	refresh (new QPushButton ("Refresh")),
778  	clear (new QPushButton ("Clear Statistics")),
779  	model (new QStandardItemModel),
780  	view (new QTableView),
781  	back (new QPushButton ("Back")),
782  	wallet (wallet_a)
783  {
784  	model->setHorizontalHeaderItem (0, new QStandardItem ("Last updated"));
785  	model->setHorizontalHeaderItem (1, new QStandardItem ("Type"));
786  	model->setHorizontalHeaderItem (2, new QStandardItem ("Detail"));
787  	model->setHorizontalHeaderItem (3, new QStandardItem ("Direction"));
788  	model->setHorizontalHeaderItem (4, new QStandardItem ("Value"));
789  	view->setModel (model);
790  	view->setEditTriggers (QAbstractItemView::NoEditTriggers);
791  	view->verticalHeader ()->hide ();
792  	view->horizontalHeader ()->setStretchLastSection (true);
793  	layout->setContentsMargins (0, 0, 0, 0);
794  	layout->addWidget (view);
795  	layout->addWidget (refresh);
796  	layout->addWidget (clear);
797  	layout->addWidget (back);
798  	window->setLayout (layout);
799  	QObject::connect (back, &QPushButton::released, [this] () {
800  		this->wallet.pop_main_stack ();
801  	});
802  	QObject::connect (refresh, &QPushButton::released, [this] () {
803  		refresh_stats ();
804  	});
805  	QObject::connect (clear, &QPushButton::released, [this] () {
806  		this->wallet.node.stats.clear ();
807  		refresh_stats ();
808  	});
809  	refresh_stats ();
810  }
811  void nano_qt::stats_viewer::refresh_stats ()
812  {
813  	model->removeRows (0, model->rowCount ());
814  	auto sink = wallet.node.stats.log_sink_json ();
815  	wallet.node.stats.log_counters (*sink);
816  	auto json = static_cast<boost::property_tree::ptree *> (sink->to_object ());
817  	if (json)
818  	{
819  		BOOST_FOREACH (boost::property_tree::ptree::value_type const & child, json->get_child ("entries"))
820  		{
821  			auto time = child.second.get<std::string> ("time");
822  			auto type = child.second.get<std::string> ("type");
823  			auto detail = child.second.get<std::string> ("detail");
824  			auto dir = child.second.get<std::string> ("dir");
825  			auto value = child.second.get<std::string> ("value", "0");
826  			if (detail == "all")
827  			{
828  				detail = "total";
829  			}
830  			if (type == "traffic_tcp")
831  			{
832  				std::vector<std::string> const units = { " bytes", " KB", " MB", " GB", " TB", " PB" };
833  				double bytes = std::stod (value);
834  				auto index = bytes == 0 ? 0 : std::min (units.size () - 1, static_cast<size_t> (std::floor (std::log2 (bytes) / 10)));
835  				std::string unit = units[index];
836  				bytes /= std::pow (1024, index);
837  				int precision = index < 2 ? 0 : 2;
838  				std::stringstream numstream;
839  				numstream << std::fixed << std::setprecision (precision) << bytes;
840  				value = numstream.str () + unit;
841  			}
842  			QList<QStandardItem *> items;
843  			items.push_back (new QStandardItem (QString (time.c_str ())));
844  			items.push_back (new QStandardItem (QString (type.c_str ())));
845  			items.push_back (new QStandardItem (QString (detail.c_str ())));
846  			items.push_back (new QStandardItem (QString (dir.c_str ())));
847  			items.push_back (new QStandardItem (QString (value.c_str ())));
848  			model->appendRow (items);
849  		}
850  	}
851  }
852  nano_qt::status::status (nano_qt::wallet & wallet_a) :
853  	wallet (wallet_a)
854  {
855  	wallet.status->setToolTip ("Wallet status, block count (blocks downloaded)");
856  	active.insert (nano_qt::status_types::nominal);
857  	set_text ();
858  }
859  void nano_qt::status::erase (nano_qt::status_types status_a)
860  {
861  	debug_assert (status_a != nano_qt::status_types::nominal);
862  	auto erased (active.erase (status_a));
863  	(void)erased;
864  	set_text ();
865  }
866  void nano_qt::status::insert (nano_qt::status_types status_a)
867  {
868  	debug_assert (status_a != nano_qt::status_types::nominal);
869  	active.insert (status_a);
870  	set_text ();
871  }
872  void nano_qt::status::set_text ()
873  {
874  	wallet.status->setText (text ().c_str ());
875  	wallet.status->setStyleSheet ((std::string ("QLabel {") + color () + "}").c_str ());
876  }
877  std::string nano_qt::status::text ()
878  {
879  	debug_assert (!active.empty ());
880  	std::string result;
881  	size_t unchecked (0);
882  	size_t cemented (0);
883  	std::string count_string;
884  	{
885  		auto size (wallet.wallet_m->wallets.node.ledger.cache.block_count.load ());
886  		unchecked = wallet.wallet_m->wallets.node.unchecked.count ();
887  		cemented = wallet.wallet_m->wallets.node.ledger.cache.cemented_count.load ();
888  		count_string = std::to_string (size);
889  	}
890  	switch (*active.begin ())
891  	{
892  		case nano_qt::status_types::disconnected:
893  			result = "Status: Disconnected";
894  			break;
895  		case nano_qt::status_types::working:
896  			result = "Status: Generating proof of work";
897  			break;
898  		case nano_qt::status_types::synchronizing:
899  			result = "Status: Synchronizing";
900  			break;
901  		case nano_qt::status_types::locked:
902  			result = "Status: Wallet locked";
903  			break;
904  		case nano_qt::status_types::vulnerable:
905  			result = "Status: Wallet password empty";
906  			break;
907  		case nano_qt::status_types::active:
908  			result = "Status: Wallet active";
909  			break;
910  		case nano_qt::status_types::nominal:
911  			result = "Status: Running";
912  			break;
913  		default:
914  			debug_assert (false);
915  			break;
916  	}
917  	result += ", Blocks: ";
918  	count_string += ", Unchecked: " + std::to_string (unchecked);
919  	count_string += ", Cemented: " + std::to_string (cemented);
920  	if (wallet.node.flags.enable_pruning)
921  	{
922  		count_string += ", Full: " + std::to_string (wallet.wallet_m->wallets.node.ledger.cache.block_count - wallet.wallet_m->wallets.node.ledger.cache.pruned_count);
923  		count_string += ", Pruned: " + std::to_string (wallet.wallet_m->wallets.node.ledger.cache.pruned_count);
924  	}
925  	result += count_string.c_str ();
926  	return result;
927  }
928  std::string nano_qt::status::color ()
929  {
930  	debug_assert (!active.empty ());
931  	std::string result;
932  	switch (*active.begin ())
933  	{
934  		case nano_qt::status_types::disconnected:
935  			result = "color: red";
936  			break;
937  		case nano_qt::status_types::working:
938  			result = "color: blue";
939  			break;
940  		case nano_qt::status_types::synchronizing:
941  			result = "color: blue";
942  			break;
943  		case nano_qt::status_types::locked:
944  			result = "color: orange";
945  			break;
946  		case nano_qt::status_types::vulnerable:
947  			result = "color: blue";
948  			break;
949  		case nano_qt::status_types::active:
950  			result = "color: black";
951  			break;
952  		case nano_qt::status_types::nominal:
953  			result = "color: black";
954  			break;
955  		default:
956  			debug_assert (false);
957  			break;
958  	}
959  	return result;
960  }
961  nano_qt::wallet::wallet (QApplication & application_a, nano_qt::eventloop_processor & processor_a, nano::node & node_a, std::shared_ptr<nano::wallet> const & wallet_a, nano::account & account_a) :
962  	rendering_ratio (nano::Mxrb_ratio),
963  	node (node_a),
964  	wallet_m (wallet_a),
965  	account (account_a),
966  	processor (processor_a),
967  	history (node.ledger, account, *this),
968  	accounts (*this),
969  	self (*this, account_a),
970  	settings (*this),
971  	advanced (*this),
972  	block_creation (*this),
973  	block_entry (*this),
974  	block_viewer (*this),
975  	account_viewer (*this),
976  	stats_viewer (*this),
977  	import (*this),
978  	application (application_a),
979  	status (new QLabel),
980  	main_stack (new QStackedWidget),
981  	client_window (new QWidget),
982  	client_layout (new QVBoxLayout),
983  	entry_window (new QWidget),
984  	entry_window_layout (new QVBoxLayout),
985  	separator (new QFrame),
986  	account_history_label (new QLabel ("Account history:")),
987  	send_blocks (new QPushButton ("Send")),
988  	settings_button (new QPushButton ("Settings")),
989  	accounts_button (new QPushButton ("Accounts")),
990  	show_advanced (new QPushButton ("Advanced")),
991  	send_blocks_window (new QWidget),
992  	send_blocks_layout (new QVBoxLayout),
993  	send_account_label (new QLabel ("Destination account:")),
994  	send_account (new QLineEdit),
995  	send_count_label (new QLabel ("Amount:")),
996  	send_count (new QLineEdit),
997  	send_blocks_send (new QPushButton ("Send")),
998  	send_blocks_back (new QPushButton ("Back")),
999  	active_status (*this),
1000  	needs_deterministic_restore (false)
1001  {
1002  	update_connected ();
1003  	empty_password ();
1004  	settings.update_locked (true, true);
1005  	send_blocks_layout->addWidget (send_account_label);
1006  	send_account->setPlaceholderText (node.network_params.ledger.zero_key.pub.to_account ().c_str ());
1007  	send_blocks_layout->addWidget (send_account);
1008  	send_blocks_layout->addWidget (send_count_label);
1009  	send_count->setPlaceholderText ("0");
1010  	send_blocks_layout->addWidget (send_count);
1011  	send_blocks_layout->addWidget (send_blocks_send);
1012  	send_blocks_layout->addStretch ();
1013  	send_blocks_layout->addWidget (send_blocks_back);
1014  	send_blocks_layout->setContentsMargins (0, 0, 0, 0);
1015  	send_blocks_window->setLayout (send_blocks_layout);
1016  	entry_window_layout->addWidget (account_history_label);
1017  	entry_window_layout->addWidget (history.window);
1018  	entry_window_layout->addWidget (send_blocks);
1019  	entry_window_layout->addWidget (settings_button);
1020  	entry_window_layout->addWidget (accounts_button);
1021  	entry_window_layout->addWidget (show_advanced);
1022  	entry_window_layout->setContentsMargins (0, 0, 0, 0);
1023  	entry_window_layout->setSpacing (5);
1024  	entry_window->setLayout (entry_window_layout);
1025  	main_stack->addWidget (entry_window);
1026  	status->setContentsMargins (5, 5, 5, 5);
1027  	status->setAlignment (Qt::AlignHCenter);
1028  	separator->setFrameShape (QFrame::HLine);
1029  	separator->setFrameShadow (QFrame::Sunken);
1030  	client_layout->addWidget (status);
1031  	client_layout->addWidget (self.window);
1032  	client_layout->addWidget (separator);
1033  	client_layout->addWidget (main_stack);
1034  	client_layout->setSpacing (0);
1035  	client_layout->setContentsMargins (0, 0, 0, 0);
1036  	client_window->setLayout (client_layout);
1037  	client_window->resize (620, 640);
1038  	client_window->setStyleSheet ("\
1039  		QLineEdit { padding: 3px; } \
1040  	");
1041  	QObject::connect (send_account, &QLineEdit::textChanged, [this] (const QString & value) {
1042  		auto pos = send_account->cursorPosition ();
1043  		send_account->setText (value.trimmed ());
1044  		send_account->setCursorPosition (pos);
1045  	});
1046  	QObject::connect (send_count, &QLineEdit::textChanged, [this] (const QString & value) {
1047  		auto pos = send_count->cursorPosition ();
1048  		send_count->setText (value.trimmed ());
1049  		send_count->setCursorPosition (pos);
1050  	});
1051  	refresh ();
1052  }
1053  void nano_qt::wallet::ongoing_refresh ()
1054  {
1055  	std::weak_ptr<nano_qt::wallet> wallet_w (shared_from_this ());
1056  	if (needs_balance_refresh)
1057  	{
1058  		needs_balance_refresh = false;
1059  		auto balance_l (node.balance_pending (account, false));
1060  		application.postEvent (&processor, new eventloop_event ([wallet_w, balance_l] () {
1061  			if (auto this_l = wallet_w.lock ())
1062  			{
1063  				this_l->self.set_balance_text (balance_l);
1064  			}
1065  		}));
1066  	}
1067  	application.postEvent (&processor, new eventloop_event ([wallet_w] () {
1068  		if (auto this_l = wallet_w.lock ())
1069  		{
1070  			this_l->active_status.set_text ();
1071  		}
1072  	}));
1073  	node.workers.add_timed_task (std::chrono::steady_clock::now () + std::chrono::seconds (5), [wallet_w] () {
1074  		if (auto wallet_l = wallet_w.lock ())
1075  		{
1076  			wallet_l->ongoing_refresh ();
1077  		}
1078  	});
1079  }
1080  void nano_qt::wallet::start ()
1081  {
1082  	ongoing_refresh ();
1083  	std::weak_ptr<nano_qt::wallet> this_w (shared_from_this ());
1084  	QObject::connect (settings_button, &QPushButton::released, [this_w] () {
1085  		if (auto this_l = this_w.lock ())
1086  		{
1087  			this_l->settings.activate ();
1088  		}
1089  	});
1090  	QObject::connect (accounts_button, &QPushButton::released, [this_w] () {
1091  		if (auto this_l = this_w.lock ())
1092  		{
1093  			this_l->push_main_stack (this_l->accounts.window);
1094  		}
1095  	});
1096  	QObject::connect (show_advanced, &QPushButton::released, [this_w] () {
1097  		if (auto this_l = this_w.lock ())
1098  		{
1099  			this_l->push_main_stack (this_l->advanced.window);
1100  		}
1101  	});
1102  	QObject::connect (send_blocks_send, &QPushButton::released, [this_w] () {
1103  		if (auto this_l = this_w.lock ())
1104  		{
1105  			show_line_ok (*this_l->send_count);
1106  			show_line_ok (*this_l->send_account);
1107  			nano::amount amount;
1108  			if (!amount.decode_dec (this_l->send_count->text ().toStdString (), this_l->rendering_ratio))
1109  			{
1110  				nano::uint128_t actual (amount.number ());
1111  				QString account_text (this_l->send_account->text ());
1112  				std::string account_text_narrow (account_text.toLocal8Bit ());
1113  				nano::account account_l;
1114  				auto parse_error (account_l.decode_account (account_text_narrow));
1115  				if (!parse_error)
1116  				{
1117  					auto balance (this_l->node.balance (this_l->account));
1118  					if (actual <= balance)
1119  					{
1120  						auto transaction (this_l->wallet_m->wallets.tx_begin_read ());
1121  						if (this_l->wallet_m->store.valid_password (transaction))
1122  						{
1123  							this_l->send_blocks_send->setEnabled (false);
1124  							this_l->node.background ([this_w, account_l, actual] () {
1125  								if (auto this_l = this_w.lock ())
1126  								{
1127  									this_l->wallet_m->send_async (this_l->account, account_l, actual, [this_w] (std::shared_ptr<nano::block> const & block_a) {
1128  										if (auto this_l = this_w.lock ())
1129  										{
1130  											auto succeeded (block_a != nullptr);
1131  											this_l->application.postEvent (&this_l->processor, new eventloop_event ([this_w, succeeded] () {
1132  												if (auto this_l = this_w.lock ())
1133  												{
1134  													this_l->send_blocks_send->setEnabled (true);
1135  													if (succeeded)
1136  													{
1137  														this_l->send_count->clear ();
1138  														this_l->send_account->clear ();
1139  														this_l->accounts.refresh ();
1140  													}
1141  													else
1142  													{
1143  														show_line_error (*this_l->send_count);
1144  													}
1145  												}
1146  											}));
1147  										}
1148  									});
1149  								}
1150  							});
1151  						}
1152  						else
1153  						{
1154  							show_button_error (*this_l->send_blocks_send);
1155  							this_l->send_blocks_send->setText ("Wallet is locked, unlock it to send");
1156  							this_l->node.workers.add_timed_task (std::chrono::steady_clock::now () + std::chrono::seconds (5), [this_w] () {
1157  								if (auto this_l = this_w.lock ())
1158  								{
1159  									this_l->application.postEvent (&this_l->processor, new eventloop_event ([this_w] () {
1160  										if (auto this_l = this_w.lock ())
1161  										{
1162  											show_button_ok (*this_l->send_blocks_send);
1163  											this_l->send_blocks_send->setText ("Send");
1164  										}
1165  									}));
1166  								}
1167  							});
1168  						}
1169  					}
1170  					else
1171  					{
1172  						show_line_error (*this_l->send_count);
1173  						show_button_error (*this_l->send_blocks_send);
1174  						this_l->send_blocks_send->setText ("Not enough balance");
1175  						this_l->node.workers.add_timed_task (std::chrono::steady_clock::now () + std::chrono::seconds (5), [this_w] () {
1176  							if (auto this_l = this_w.lock ())
1177  							{
1178  								this_l->application.postEvent (&this_l->processor, new eventloop_event ([this_w] () {
1179  									if (auto this_l = this_w.lock ())
1180  									{
1181  										show_button_ok (*this_l->send_blocks_send);
1182  										this_l->send_blocks_send->setText ("Send");
1183  									}
1184  								}));
1185  							}
1186  						});
1187  					}
1188  				}
1189  				else
1190  				{
1191  					show_line_error (*this_l->send_account);
1192  					show_button_error (*this_l->send_blocks_send);
1193  					this_l->send_blocks_send->setText ("Bad destination account");
1194  					this_l->node.workers.add_timed_task (std::chrono::steady_clock::now () + std::chrono::seconds (5), [this_w] () {
1195  						if (auto this_l = this_w.lock ())
1196  						{
1197  							this_l->application.postEvent (&this_l->processor, new eventloop_event ([this_w] () {
1198  								if (auto this_l = this_w.lock ())
1199  								{
1200  									show_button_ok (*this_l->send_blocks_send);
1201  									this_l->send_blocks_send->setText ("Send");
1202  								}
1203  							}));
1204  						}
1205  					});
1206  				}
1207  			}
1208  			else
1209  			{
1210  				show_line_error (*this_l->send_count);
1211  				show_button_error (*this_l->send_blocks_send);
1212  				this_l->send_blocks_send->setText ("Bad amount number");
1213  				this_l->node.workers.add_timed_task (std::chrono::steady_clock::now () + std::chrono::seconds (5), [this_w] () {
1214  					if (auto this_l = this_w.lock ())
1215  					{
1216  						this_l->application.postEvent (&this_l->processor, new eventloop_event ([this_w] () {
1217  							if (auto this_l = this_w.lock ())
1218  							{
1219  								show_button_ok (*this_l->send_blocks_send);
1220  								this_l->send_blocks_send->setText ("Send");
1221  							}
1222  						}));
1223  					}
1224  				});
1225  			}
1226  		}
1227  	});
1228  	QObject::connect (send_blocks_back, &QPushButton::released, [this_w] () {
1229  		if (auto this_l = this_w.lock ())
1230  		{
1231  			this_l->pop_main_stack ();
1232  		}
1233  	});
1234  	QObject::connect (send_blocks, &QPushButton::released, [this_w] () {
1235  		if (auto this_l = this_w.lock ())
1236  		{
1237  			this_l->push_main_stack (this_l->send_blocks_window);
1238  		}
1239  	});
1240  	node.observers.blocks.add ([this_w] (nano::election_status const & status_a, std::vector<nano::vote_with_weight_info> const & votes_a, nano::account const & account_a, nano::uint128_t const & amount_a, bool, bool) {
1241  		if (auto this_l = this_w.lock ())
1242  		{
1243  			this_l->application.postEvent (&this_l->processor, new eventloop_event ([this_w, status_a, account_a] () {
1244  				if (auto this_l = this_w.lock ())
1245  				{
1246  					if (this_l->wallet_m->exists (account_a))
1247  					{
1248  						this_l->accounts.refresh ();
1249  					}
1250  					if (account_a == this_l->account)
1251  					{
1252  						this_l->history.refresh ();
1253  					}
1254  				}
1255  			}));
1256  		}
1257  	});
1258  	node.observers.account_balance.add ([this_w] (nano::account const & account_a, bool is_pending) {
1259  		if (auto this_l = this_w.lock ())
1260  		{
1261  			this_l->needs_balance_refresh = this_l->needs_balance_refresh || account_a == this_l->account;
1262  		}
1263  	});
1264  	node.observers.wallet.add ([this_w] (bool active_a) {
1265  		if (auto this_l = this_w.lock ())
1266  		{
1267  			this_l->application.postEvent (&this_l->processor, new eventloop_event ([this_w, active_a] () {
1268  				if (auto this_l = this_w.lock ())
1269  				{
1270  					if (active_a)
1271  					{
1272  						this_l->active_status.insert (nano_qt::status_types::active);
1273  					}
1274  					else
1275  					{
1276  						this_l->active_status.erase (nano_qt::status_types::active);
1277  					}
1278  				}
1279  			}));
1280  		}
1281  	});
1282  	node.observers.endpoint.add ([this_w] (std::shared_ptr<nano::transport::channel> const &) {
1283  		if (auto this_l = this_w.lock ())
1284  		{
1285  			this_l->application.postEvent (&this_l->processor, new eventloop_event ([this_w] () {
1286  				if (auto this_l = this_w.lock ())
1287  				{
1288  					this_l->update_connected ();
1289  				}
1290  			}));
1291  		}
1292  	});
1293  	node.observers.disconnect.add ([this_w] () {
1294  		if (auto this_l = this_w.lock ())
1295  		{
1296  			this_l->application.postEvent (&this_l->processor, new eventloop_event ([this_w] () {
1297  				if (auto this_l = this_w.lock ())
1298  				{
1299  					this_l->update_connected ();
1300  				}
1301  			}));
1302  		}
1303  	});
1304  	node.bootstrap_initiator.add_observer ([this_w] (bool active_a) {
1305  		if (auto this_l = this_w.lock ())
1306  		{
1307  			this_l->application.postEvent (&this_l->processor, new eventloop_event ([this_w, active_a] () {
1308  				if (auto this_l = this_w.lock ())
1309  				{
1310  					if (active_a)
1311  					{
1312  						this_l->active_status.insert (nano_qt::status_types::synchronizing);
1313  					}
1314  					else
1315  					{
1316  						this_l->active_status.erase (nano_qt::status_types::synchronizing);
1317  						if (this_l->needs_deterministic_restore)
1318  						{
1319  							this_l->needs_deterministic_restore = false;
1320  							auto transaction (this_l->wallet_m->wallets.tx_begin_write ());
1321  							this_l->wallet_m->deterministic_restore (transaction);
1322  						}
1323  					}
1324  				}
1325  			}));
1326  		}
1327  	});
1328  	node.work.work_observers.add ([this_w] (bool working) {
1329  		if (auto this_l = this_w.lock ())
1330  		{
1331  			this_l->application.postEvent (&this_l->processor, new eventloop_event ([this_w, working] () {
1332  				if (auto this_l = this_w.lock ())
1333  				{
1334  					if (working)
1335  					{
1336  						this_l->active_status.insert (nano_qt::status_types::working);
1337  					}
1338  					else
1339  					{
1340  						this_l->active_status.erase (nano_qt::status_types::working);
1341  					}
1342  				}
1343  			}));
1344  		}
1345  	});
1346  	wallet_m->lock_observer = [this_w] (bool invalid, bool vulnerable) {
1347  		if (auto this_l = this_w.lock ())
1348  		{
1349  			this_l->application.postEvent (&this_l->processor, new eventloop_event ([this_w, invalid, vulnerable] () {
1350  				if (auto this_l = this_w.lock ())
1351  				{
1352  					this_l->settings.update_locked (invalid, vulnerable);
1353  				}
1354  			}));
1355  		}
1356  	};
1357  	settings_button->setToolTip ("Unlock wallet, set password, change representative");
1358  }
1359  void nano_qt::wallet::refresh ()
1360  {
1361  	{
1362  		auto transaction (wallet_m->wallets.tx_begin_read ());
1363  		debug_assert (wallet_m->store.exists (transaction, account));
1364  	}
1365  	self.account_text->setText (QString (account.to_account ().c_str ()));
1366  	needs_balance_refresh = true;
1367  	accounts.refresh ();
1368  	history.refresh ();
1369  	account_viewer.history.refresh ();
1370  	settings.refresh_representative ();
<span onclick='openModal()' class='match'>1371  }
1372  void nano_qt::wallet::update_connected ()
1373  {
1374  	if (node.network.empty ())
1375  	{
1376  		active_status.insert (nano_qt::status_types::disconnected);
1377  	}
1378  	else
1379  	{
1380  		active_status.erase (nano_qt::status_types::disconnected);
1381  	}
1382  }
</span>1383  void nano_qt::wallet::empty_password ()
1384  {
1385  	this->node.workers.add_timed_task (std::chrono::steady_clock::now () + std::chrono::seconds (3), [this] () {
1386  		auto transaction (wallet_m->wallets.tx_begin_write ());
1387  		wallet_m->enter_password (transaction, std::string (""));
1388  	});
1389  }
1390  void nano_qt::wallet::change_rendering_ratio (nano::uint128_t const & rendering_ratio_a)
1391  {
1392  	application.postEvent (&processor, new eventloop_event ([this, rendering_ratio_a] () {
1393  		this->rendering_ratio = rendering_ratio_a;
1394  		auto balance_l (this->node.balance_pending (account, false));
1395  		this->self.set_balance_text (balance_l);
1396  		this->refresh ();
1397  	}));
1398  }
1399  std::string nano_qt::wallet::format_balance (nano::uint128_t const & balance) const
1400  {
1401  	auto balance_str = nano::amount (balance).format_balance (rendering_ratio, 3, false);
1402  	auto unit = std::string ("nano");
1403  	if (rendering_ratio == nano::raw_ratio)
1404  	{
1405  		unit = std::string ("raw");
1406  	}
1407  	return balance_str + " " + unit;
1408  }
1409  void nano_qt::wallet::push_main_stack (QWidget * widget_a)
1410  {
1411  	main_stack->addWidget (widget_a);
1412  	main_stack->setCurrentIndex (main_stack->count () - 1);
1413  }
1414  void nano_qt::wallet::pop_main_stack ()
1415  {
1416  	main_stack->removeWidget (main_stack->currentWidget ());
1417  }
1418  nano_qt::settings::settings (nano_qt::wallet & wallet_a) :
1419  	window (new QWidget),
1420  	layout (new QVBoxLayout),
1421  	password (new QLineEdit),
1422  	lock_toggle (new QPushButton ("Unlock")),
1423  	sep1 (new QFrame),
1424  	new_password (new QLineEdit),
1425  	retype_password (new QLineEdit),
1426  	change (new QPushButton ("Set/Change password")),
1427  	sep2 (new QFrame),
1428  	representative (new QLabel ("Account representative:")),
1429  	current_representative (new QLabel),
1430  	new_representative (new QLineEdit),
1431  	change_rep (new QPushButton ("Change representative")),
1432  	back (new QPushButton ("Back")),
1433  	wallet (wallet_a)
1434  {
1435  	password->setPlaceholderText ("Password");
1436  	password->setEchoMode (QLineEdit::EchoMode::Password);
1437  	layout->addWidget (password);
1438  	layout->addWidget (lock_toggle);
1439  	sep1->setFrameShape (QFrame::HLine);
1440  	sep1->setFrameShadow (QFrame::Sunken);
1441  	layout->addWidget (sep1);
1442  	new_password->setEchoMode (QLineEdit::EchoMode::Password);
1443  	new_password->setPlaceholderText ("New password");
1444  	layout->addWidget (new_password);
1445  	retype_password->setEchoMode (QLineEdit::EchoMode::Password);
1446  	retype_password->setPlaceholderText ("Retype password");
1447  	layout->addWidget (retype_password);
1448  	layout->addWidget (change);
1449  	sep2->setFrameShape (QFrame::HLine);
1450  	sep2->setFrameShadow (QFrame::Sunken);
1451  	layout->addWidget (sep2);
1452  	layout->addWidget (representative);
1453  	current_representative->setTextInteractionFlags (Qt::TextSelectableByMouse);
1454  	layout->addWidget (current_representative);
1455  	new_representative->setPlaceholderText (wallet.node.network_params.ledger.zero_key.pub.to_account ().c_str ());
1456  	layout->addWidget (new_representative);
1457  	layout->addWidget (change_rep);
1458  	layout->addStretch ();
1459  	layout->addWidget (back);
1460  	window->setLayout (layout);
1461  	QObject::connect (change, &QPushButton::released, [this] () {
1462  		auto transaction (this->wallet.wallet_m->wallets.tx_begin_write ());
1463  		if (this->wallet.wallet_m->store.valid_password (transaction))
1464  		{
1465  			if (new_password->text ().isEmpty ())
1466  			{
1467  				new_password->clear ();
1468  				new_password->setPlaceholderText ("Empty Password - try again: New password");
1469  				retype_password->clear ();
1470  				retype_password->setPlaceholderText ("Empty Password - try again: Retype password");
1471  			}
1472  			else
1473  			{
1474  				if (new_password->text () == retype_password->text ())
1475  				{
1476  					this->wallet.wallet_m->store.rekey (transaction, std::string (new_password->text ().toLocal8Bit ()));
1477  					new_password->clear ();
1478  					retype_password->clear ();
1479  					retype_password->setPlaceholderText ("Retype password");
1480  					show_button_success (*change);
1481  					change->setText ("Password was changed");
1482  					this->wallet.node.logger.try_log ("Wallet password changed");
1483  					update_locked (false, false);
1484  					this->wallet.node.workers.add_timed_task (std::chrono::steady_clock::now () + std::chrono::seconds (5), [this] () {
1485  						this->wallet.application.postEvent (&this->wallet.processor, new eventloop_event ([this] () {
1486  							show_button_ok (*change);
1487  							change->setText ("Set/Change password");
1488  						}));
1489  					});
1490  				}
1491  				else
1492  				{
1493  					retype_password->clear ();
1494  					retype_password->setPlaceholderText ("Password mismatch");
1495  				}
1496  			}
1497  		}
1498  		else
1499  		{
1500  			show_button_error (*change);
1501  			change->setText ("Wallet is locked, unlock it");
1502  			this->wallet.node.workers.add_timed_task (std::chrono::steady_clock::now () + std::chrono::seconds (5), [this] () {
1503  				this->wallet.application.postEvent (&this->wallet.processor, new eventloop_event ([this] () {
1504  					show_button_ok (*change);
1505  					change->setText ("Set/Change password");
1506  				}));
1507  			});
1508  		}
1509  	});
1510  	QObject::connect (change_rep, &QPushButton::released, [this] () {
1511  		nano::account representative_l;
1512  		if (!representative_l.decode_account (new_representative->text ().toStdString ()))
1513  		{
1514  			auto transaction (this->wallet.wallet_m->wallets.tx_begin_read ());
1515  			if (this->wallet.wallet_m->store.valid_password (transaction))
1516  			{
1517  				change_rep->setEnabled (false);
1518  				{
1519  					auto transaction_l (this->wallet.wallet_m->wallets.tx_begin_write ());
1520  					this->wallet.wallet_m->store.representative_set (transaction_l, representative_l);
1521  				}
1522  				this->wallet.wallet_m->change_sync (this->wallet.account, representative_l);
1523  				change_rep->setEnabled (true);
1524  				show_button_success (*change_rep);
1525  				change_rep->setText ("Representative was changed");
1526  				current_representative->setText (QString (representative_l.to_account ().c_str ()));
1527  				new_representative->clear ();
1528  				this->wallet.node.workers.add_timed_task (std::chrono::steady_clock::now () + std::chrono::seconds (5), [this] () {
1529  					this->wallet.application.postEvent (&this->wallet.processor, new eventloop_event ([this] () {
1530  						show_button_ok (*change_rep);
1531  						change_rep->setText ("Change representative");
1532  					}));
1533  				});
1534  			}
1535  			else
1536  			{
1537  				show_button_error (*change_rep);
1538  				change_rep->setText ("Wallet is locked, unlock it");
1539  				this->wallet.node.workers.add_timed_task (std::chrono::steady_clock::now () + std::chrono::seconds (5), [this] () {
1540  					this->wallet.application.postEvent (&this->wallet.processor, new eventloop_event ([this] () {
1541  						show_button_ok (*change_rep);
1542  						change_rep->setText ("Change representative");
1543  					}));
1544  				});
1545  			}
1546  		}
1547  		else
1548  		{
1549  			show_line_error (*new_representative);
1550  			show_button_error (*change_rep);
1551  			change_rep->setText ("Invalid account");
1552  			this->wallet.node.workers.add_timed_task (std::chrono::steady_clock::now () + std::chrono::seconds (5), [this] () {
1553  				this->wallet.application.postEvent (&this->wallet.processor, new eventloop_event ([this] () {
1554  					show_line_ok (*new_representative);
1555  					show_button_ok (*change_rep);
1556  					change_rep->setText ("Change representative");
1557  				}));
1558  			});
1559  		}
1560  	});
1561  	QObject::connect (back, &QPushButton::released, [this] () {
1562  		debug_assert (this->wallet.main_stack->currentWidget () == window);
1563  		this->wallet.pop_main_stack ();
1564  	});
1565  	QObject::connect (lock_toggle, &QPushButton::released, [this] () {
1566  		auto transaction (this->wallet.wallet_m->wallets.tx_begin_write ());
1567  		if (this->wallet.wallet_m->store.valid_password (transaction))
1568  		{
1569  			nano::raw_key empty;
1570  			empty.clear ();
1571  			this->wallet.wallet_m->store.password.value_set (empty);
1572  			update_locked (true, true);
1573  			lock_toggle->setText ("Unlock");
1574  			this->wallet.node.logger.try_log ("Wallet locked");
1575  			password->setEnabled (1);
1576  		}
1577  		else
1578  		{
1579  			if (!this->wallet.wallet_m->enter_password (transaction, std::string (password->text ().toLocal8Bit ())))
1580  			{
1581  				password->clear ();
1582  				lock_toggle->setText ("Lock");
1583  				password->setDisabled (1);
1584  			}
1585  			else
1586  			{
1587  				show_line_error (*password);
1588  				show_button_error (*lock_toggle);
1589  				lock_toggle->setText ("Invalid password");
1590  				this->wallet.node.workers.add_timed_task (std::chrono::steady_clock::now () + std::chrono::seconds (5), [this] () {
1591  					this->wallet.application.postEvent (&this->wallet.processor, new eventloop_event ([this] () {
1592  						show_line_ok (*password);
1593  						show_button_ok (*lock_toggle);
1594  						auto transaction (this->wallet.wallet_m->wallets.tx_begin_write ());
1595  						if (!this->wallet.wallet_m->store.valid_password (transaction))
1596  						{
1597  							lock_toggle->setText ("Unlock");
1598  						}
1599  					}));
1600  				});
1601  			}
1602  		}
1603  	});
1604  	QObject::connect (new_representative, &QLineEdit::textChanged, [this] (const QString & value) {
1605  		auto pos = new_representative->cursorPosition ();
1606  		new_representative->setText (value.trimmed ());
1607  		new_representative->setCursorPosition (pos);
1608  	});
1609  	auto transaction (this->wallet.wallet_m->wallets.tx_begin_write ());
1610  	if (this->wallet.wallet_m->store.valid_password (transaction))
1611  	{
1612  		lock_toggle->setText ("Lock");
1613  		password->setDisabled (1);
1614  	}
1615  	representative->setToolTip ("In the infrequent case where the network needs to make a global decision,\nyour wallet software performs a balance-weighted vote to determine\nthe outcome. Since not everyone can remain online and perform this duty,\nyour wallet names a representative that can vote with, but cannot spend,\nyour balance.");
1616  	refresh_representative ();
1617  }
1618  void nano_qt::settings::refresh_representative ()
1619  {
1620  	auto transaction (this->wallet.wallet_m->wallets.node.store.tx_begin_read ());
1621  	nano::account_info info;
1622  	auto error (wallet.node.store.account.get (transaction, this->wallet.account, info));
1623  	if (!error)
1624  	{
1625  		current_representative->setText (QString (info.representative.to_account ().c_str ()));
1626  	}
1627  	else
1628  	{
1629  		auto wallet_transaction (this->wallet.wallet_m->wallets.tx_begin_read ());
1630  		current_representative->setText (this->wallet.wallet_m->store.representative (wallet_transaction).to_account ().c_str ());
1631  	}
1632  }
1633  void nano_qt::settings::activate ()
1634  {
1635  	this->wallet.push_main_stack (window);
1636  }
1637  void nano_qt::settings::update_locked (bool invalid, bool vulnerable)
1638  {
1639  	if (invalid)
1640  	{
1641  		this->wallet.active_status.insert (nano_qt::status_types::locked);
1642  	}
1643  	else
1644  	{
1645  		this->wallet.active_status.erase (nano_qt::status_types::locked);
1646  	}
1647  	if (vulnerable)
1648  	{
1649  		this->wallet.active_status.insert (nano_qt::status_types::vulnerable);
1650  	}
1651  	else
1652  	{
1653  		this->wallet.active_status.erase (nano_qt::status_types::vulnerable);
1654  	}
1655  }
1656  nano_qt::advanced_actions::advanced_actions (nano_qt::wallet & wallet_a) :
1657  	window (new QWidget),
1658  	layout (new QVBoxLayout),
1659  	show_ledger (new QPushButton ("Ledger")),
1660  	show_peers (new QPushButton ("Peers")),
1661  	search_for_receivables (new QPushButton ("Search for receivables")),
1662  	bootstrap (new QPushButton ("Initiate bootstrap")),
1663  	wallet_refresh (new QPushButton ("Refresh Wallet")),
1664  	create_block (new QPushButton ("Create Block")),
1665  	enter_block (new QPushButton ("Enter Block")),
1666  	block_viewer (new QPushButton ("Block Viewer")),
1667  	account_viewer (new QPushButton ("Account Viewer")),
1668  	stats_viewer (new QPushButton ("Node Statistics")),
1669  	scale_window (new QWidget),
1670  	scale_layout (new QHBoxLayout),
1671  	scale_label (new QLabel ("Scale:")),
1672  	ratio_group (new QButtonGroup),
1673  	nano_unit (new QRadioButton ("nano")),
1674  	raw_unit (new QRadioButton ("raw")),
1675  	back (new QPushButton ("Back")),
1676  	ledger_window (new QWidget),
1677  	ledger_layout (new QVBoxLayout),
1678  	ledger_model (new QStandardItemModel),
1679  	ledger_view (new QTableView),
1680  	ledger_refresh (new QPushButton ("Refresh")),
1681  	ledger_back (new QPushButton ("Back")),
1682  	peers_window (new QWidget),
1683  	peers_layout (new QVBoxLayout),
1684  	peers_model (new QStandardItemModel),
1685  	peers_view (new QTableView),
1686  	peer_summary_layout (new QHBoxLayout),
1687  	bootstrap_label (new QLabel ("IPV6:port \"::ffff:192.168.0.1:7075\"")),
1688  	peer_count_label (new QLabel ("")),
1689  	bootstrap_line (new QLineEdit),
1690  	peers_bootstrap (new QPushButton ("Initiate Bootstrap")),
1691  	peers_refresh (new QPushButton ("Refresh")),
1692  	peers_back (new QPushButton ("Back")),
1693  	wallet (wallet_a)
1694  {
1695  	ratio_group->addButton (nano_unit);
1696  	ratio_group->setId (nano_unit, ratio_group->buttons ().size () - 1);
1697  	ratio_group->addButton (raw_unit);
1698  	ratio_group->setId (raw_unit, ratio_group->buttons ().size () - 1);
1699  	scale_layout->addWidget (scale_label);
1700  	scale_layout->addWidget (nano_unit);
1701  	scale_layout->addWidget (raw_unit);
1702  	scale_window->setLayout (scale_layout);
1703  	ledger_model->setHorizontalHeaderItem (0, new QStandardItem ("Account"));
1704  	ledger_model->setHorizontalHeaderItem (1, new QStandardItem ("Balance"));
1705  	ledger_model->setHorizontalHeaderItem (2, new QStandardItem ("Block"));
1706  	ledger_view->setModel (ledger_model);
1707  	ledger_view->setEditTriggers (QAbstractItemView::NoEditTriggers);
1708  	ledger_view->verticalHeader ()->hide ();
1709  	ledger_view->horizontalHeader ()->setStretchLastSection (true);
1710  	ledger_layout->addWidget (ledger_view);
1711  	ledger_layout->addWidget (ledger_refresh);
1712  	ledger_layout->addWidget (ledger_back);
1713  	ledger_layout->setContentsMargins (0, 0, 0, 0);
1714  	ledger_window->setLayout (ledger_layout);
1715  	peers_model->setHorizontalHeaderItem (0, new QStandardItem ("IPv6 address:port"));
1716  	peers_model->setHorizontalHeaderItem (1, new QStandardItem ("Net version"));
1717  	peers_model->setHorizontalHeaderItem (2, new QStandardItem ("Node ID"));
1718  	peers_view->setEditTriggers (QAbstractItemView::NoEditTriggers);
1719  	peers_view->verticalHeader ()->hide ();
1720  	peers_view->setModel (peers_model);
1721  	peers_view->setColumnWidth (0, 220);
1722  	peers_view->setSortingEnabled (true);
1723  	peers_view->horizontalHeader ()->setStretchLastSection (true);
1724  	peers_layout->addWidget (peers_view);
1725  	peer_summary_layout->addWidget (bootstrap_label);
1726  	peer_summary_layout->addStretch ();
1727  	peer_summary_layout->addWidget (peer_count_label);
1728  	peers_layout->addLayout (peer_summary_layout);
1729  	peers_layout->addWidget (bootstrap_line);
1730  	peers_layout->addWidget (peers_bootstrap);
1731  	peers_layout->addWidget (peers_refresh);
1732  	peers_layout->addWidget (peers_back);
1733  	peers_layout->setContentsMargins (0, 0, 0, 0);
1734  	peers_window->setLayout (peers_layout);
1735  	layout->addWidget (show_ledger);
1736  	layout->addWidget (show_peers);
1737  	layout->addWidget (search_for_receivables);
1738  	layout->addWidget (bootstrap);
1739  	layout->addWidget (wallet_refresh);
1740  	layout->addWidget (create_block);
1741  	layout->addWidget (enter_block);
1742  	layout->addWidget (block_viewer);
1743  	layout->addWidget (account_viewer);
1744  	layout->addWidget (stats_viewer);
1745  	layout->addWidget (scale_window);
1746  	layout->addStretch ();
1747  	layout->addWidget (back);
1748  	window->setLayout (layout);
1749  	QObject::connect (nano_unit, &QRadioButton::toggled, [this] () {
1750  		if (nano_unit->isChecked ())
1751  		{
1752  			this->wallet.change_rendering_ratio (nano::Mxrb_ratio);
1753  			QSettings ().setValue (saved_ratio_key, ratio_group->id (nano_unit));
1754  		}
1755  	});
1756  	QObject::connect (raw_unit, &QRadioButton::toggled, [this] () {
1757  		if (raw_unit->isChecked ())
1758  		{
1759  			this->wallet.change_rendering_ratio (nano::raw_ratio);
1760  			QSettings ().setValue (saved_ratio_key, ratio_group->id (raw_unit));
1761  		}
1762  	});
1763  	auto selected_ratio_button = ratio_group->button (QSettings ().value (saved_ratio_key).toInt ());
1764  	if (selected_ratio_button == nullptr)
1765  	{
1766  		selected_ratio_button = nano_unit;
1767  	}
1768  	debug_assert (selected_ratio_button != nullptr);
1769  	selected_ratio_button->click ();
1770  	QSettings ().setValue (saved_ratio_key, ratio_group->id (selected_ratio_button));
1771  	QObject::connect (wallet_refresh, &QPushButton::released, [this] () {
1772  		this->wallet.accounts.refresh ();
1773  		this->wallet.accounts.refresh_wallet_balance ();
1774  	});
1775  	QObject::connect (show_peers, &QPushButton::released, [this] () {
1776  		refresh_peers ();
1777  		this->wallet.push_main_stack (peers_window);
1778  	});
1779  	QObject::connect (show_ledger, &QPushButton::released, [this] () {
1780  		this->wallet.push_main_stack (ledger_window);
1781  	});
1782  	QObject::connect (back, &QPushButton::released, [this] () {
1783  		this->wallet.pop_main_stack ();
1784  	});
1785  	QObject::connect (peers_back, &QPushButton::released, [this] () {
1786  		this->wallet.pop_main_stack ();
1787  	});
1788  	QObject::connect (peers_bootstrap, &QPushButton::released, [this] () {
1789  		nano::endpoint endpoint;
1790  		auto error (nano::parse_endpoint (bootstrap_line->text ().toStdString (), endpoint));
1791  		if (!error)
1792  		{
1793  			show_line_ok (*bootstrap_line);
1794  			bootstrap_line->clear ();
1795  			this->wallet.node.bootstrap_initiator.bootstrap (endpoint);
1796  		}
1797  		else
1798  		{
1799  			show_line_error (*bootstrap_line);
1800  		}
1801  	});
1802  	QObject::connect (peers_refresh, &QPushButton::released, [this] () {
1803  		refresh_peers ();
1804  	});
1805  	QObject::connect (ledger_refresh, &QPushButton::released, [this] () {
1806  		refresh_ledger ();
1807  	});
1808  	QObject::connect (ledger_back, &QPushButton::released, [this] () {
1809  		this->wallet.pop_main_stack ();
1810  	});
1811  	QObject::connect (search_for_receivables, &QPushButton::released, [this] () {
1812  		std::thread ([this] { this->wallet.wallet_m->search_receivable (this->wallet.wallet_m->wallets.tx_begin_read ()); }).detach ();
1813  	});
1814  	QObject::connect (bootstrap, &QPushButton::released, [this] () {
1815  		std::thread ([this] { this->wallet.node.bootstrap_initiator.bootstrap (); }).detach ();
1816  	});
1817  	QObject::connect (create_block, &QPushButton::released, [this] () {
1818  		this->wallet.push_main_stack (this->wallet.block_creation.window);
1819  	});
1820  	QObject::connect (enter_block, &QPushButton::released, [this] () {
1821  		this->wallet.push_main_stack (this->wallet.block_entry.window);
1822  	});
1823  	QObject::connect (block_viewer, &QPushButton::released, [this] () {
1824  		this->wallet.push_main_stack (this->wallet.block_viewer.window);
1825  	});
1826  	QObject::connect (account_viewer, &QPushButton::released, [this] () {
1827  		this->wallet.push_main_stack (this->wallet.account_viewer.window);
1828  	});
1829  	QObject::connect (stats_viewer, &QPushButton::released, [this] () {
1830  		this->wallet.push_main_stack (this->wallet.stats_viewer.window);
1831  		this->wallet.stats_viewer.refresh_stats ();
1832  	});
1833  	bootstrap->setToolTip ("Multi-connection bootstrap to random peers");
1834  	search_for_receivables->setToolTip ("Search for ready to be received blocks");
1835  	create_block->setToolTip ("Create block in JSON format");
1836  	enter_block->setToolTip ("Enter block in JSON format");
1837  }
1838  void nano_qt::advanced_actions::refresh_peers ()
1839  {
1840  	peers_model->removeRows (0, peers_model->rowCount ());
1841  	auto list (wallet.node.network.list (std::numeric_limits<size_t>::max ()));
1842  	std::sort (list.begin (), list.end (), [] (auto const & lhs, auto const & rhs) {
1843  		return lhs->get_endpoint () < rhs->get_endpoint ();
1844  	});
1845  	for (auto i (list.begin ()), n (list.end ()); i != n; ++i)
1846  	{
1847  		std::stringstream endpoint;
1848  		auto channel (*i);
1849  		endpoint << channel->to_string ();
1850  		QString qendpoint (endpoint.str ().c_str ());
1851  		QList<QStandardItem *> items;
1852  		items.push_back (new QStandardItem (qendpoint));
1853  		auto version = new QStandardItem ();
1854  		version->setData (QVariant (channel->get_network_version ()), Qt::DisplayRole);
1855  		items.push_back (version);
1856  		QString node_id ("");
1857  		auto node_id_l (channel->get_node_id_optional ());
1858  		if (node_id_l.is_initialized ())
1859  		{
1860  			node_id = node_id_l.get ().to_account ().c_str ();
1861  		}
1862  		items.push_back (new QStandardItem (node_id));
1863  		peers_model->appendRow (items);
1864  	}
1865  	peer_count_label->setText (QString ("%1 peers").arg (peers_model->rowCount ()));
1866  }
1867  void nano_qt::advanced_actions::refresh_ledger ()
1868  {
1869  	ledger_model->removeRows (0, ledger_model->rowCount ());
1870  	auto transaction (wallet.node.store.tx_begin_read ());
1871  	for (auto i (wallet.node.ledger.store.account.begin (transaction)), j (wallet.node.ledger.store.account.end ()); i != j; ++i)
1872  	{
1873  		QList<QStandardItem *> items;
1874  		items.push_back (new QStandardItem (QString (i->first.to_account ().c_str ())));
1875  		nano::account_info const & info (i->second);
1876  		std::string balance;
1877  		nano::amount (info.balance.number () / wallet.rendering_ratio).encode_dec (balance);
1878  		items.push_back (new QStandardItem (QString (balance.c_str ())));
1879  		std::string block_hash;
1880  		info.head.encode_hex (block_hash);
1881  		items.push_back (new QStandardItem (QString (block_hash.c_str ())));
1882  		ledger_model->appendRow (items);
1883  	}
1884  }
1885  void nano_qt::advanced_actions::refresh_stats ()
1886  {
1887  	wallet.stats_viewer.refresh_stats ();
1888  }
1889  nano_qt::block_entry::block_entry (nano_qt::wallet & wallet_a) :
1890  	window (new QWidget),
1891  	layout (new QVBoxLayout),
1892  	block (new QPlainTextEdit),
1893  	status (new QLabel),
1894  	process (new QPushButton ("Process")),
1895  	back (new QPushButton ("Back")),
1896  	wallet (wallet_a)
1897  {
1898  	layout->addWidget (block);
1899  	layout->addWidget (status);
1900  	layout->addWidget (process);
1901  	layout->addWidget (back);
1902  	window->setLayout (layout);
1903  	QObject::connect (process, &QPushButton::released, [this] () {
1904  		auto string (block->toPlainText ().toStdString ());
1905  		try
1906  		{
1907  			boost::property_tree::ptree tree;
1908  			std::stringstream istream (string);
1909  			boost::property_tree::read_json (istream, tree);
1910  			auto block_l (nano::deserialize_block_json (tree));
1911  			if (block_l != nullptr)
1912  			{
1913  				show_label_ok (*status);
1914  				this->status->setText ("");
1915  				if (!this->wallet.node.network_params.work.validate_entry (*block_l))
1916  				{
1917  					this->wallet.node.process_active (std::move (block_l));
1918  				}
1919  				else
1920  				{
1921  					show_label_error (*status);
1922  					this->status->setText ("Invalid work");
1923  				}
1924  			}
1925  			else
1926  			{
1927  				show_label_error (*status);
1928  				this->status->setText ("Unable to parse block");
1929  			}
1930  		}
1931  		catch (std::runtime_error const &)
1932  		{
1933  			show_label_error (*status);
1934  			this->status->setText ("Unable to parse block");
1935  		}
1936  	});
1937  	QObject::connect (back, &QPushButton::released, [this] () {
1938  		this->wallet.pop_main_stack ();
1939  	});
1940  }
1941  nano_qt::block_creation::block_creation (nano_qt::wallet & wallet_a) :
1942  	window (new QWidget),
1943  	layout (new QVBoxLayout),
1944  	group (new QButtonGroup),
1945  	button_layout (new QHBoxLayout),
1946  	send (new QRadioButton ("Send")),
1947  	receive (new QRadioButton ("Receive")),
1948  	change (new QRadioButton ("Change")),
1949  	open (new QRadioButton ("Open")),
1950  	account_label (new QLabel ("Account:")),
1951  	account (new QLineEdit),
1952  	source_label (new QLabel ("Source:")),
1953  	source (new QLineEdit),
1954  	amount_label (new QLabel ("Amount:")),
1955  	amount (new QLineEdit),
1956  	destination_label (new QLabel ("Destination:")),
1957  	destination (new QLineEdit),
1958  	representative_label (new QLabel ("Representative:")),
1959  	representative (new QLineEdit),
1960  	block (new QPlainTextEdit),
1961  	status (new QLabel),
1962  	create (new QPushButton ("Create")),
1963  	back (new QPushButton ("Back")),
1964  	wallet (wallet_a)
1965  {
1966  	group->addButton (send);
1967  	group->addButton (receive);
1968  	group->addButton (change);
1969  	group->addButton (open);
1970  	group->setId (send, 0);
1971  	group->setId (receive, 1);
1972  	group->setId (change, 2);
1973  	group->setId (open, 3);
1974  	button_layout->addWidget (send);
1975  	button_layout->addWidget (receive);
1976  	button_layout->addWidget (open);
1977  	button_layout->addWidget (change);
1978  	layout->addLayout (button_layout);
1979  	layout->addWidget (account_label);
1980  	layout->addWidget (account);
1981  	layout->addWidget (source_label);
1982  	layout->addWidget (source);
1983  	layout->addWidget (amount_label);
1984  	layout->addWidget (amount);
1985  	layout->addWidget (destination_label);
1986  	layout->addWidget (destination);
1987  	layout->addWidget (representative_label);
1988  	layout->addWidget (representative);
1989  	layout->addWidget (block);
1990  	layout->addWidget (status);
1991  	layout->addWidget (create);
1992  	layout->addWidget (back);
1993  	window->setLayout (layout);
1994  	QObject::connect (send, &QRadioButton::toggled, [this] (bool on) {
1995  		if (on)
1996  		{
1997  			deactivate_all ();
1998  			activate_send ();
1999  		}
2000  	});
2001  	QObject::connect (receive, &QRadioButton::toggled, [this] (bool on) {
2002  		if (on)
2003  		{
2004  			deactivate_all ();
2005  			activate_receive ();
2006  		}
2007  	});
2008  	QObject::connect (open, &QRadioButton::toggled, [this] (bool on) {
2009  		if (on)
2010  		{
2011  			deactivate_all ();
2012  			activate_open ();
2013  		}
2014  	});
2015  	QObject::connect (change, &QRadioButton::toggled, [this] (bool on) {
2016  		if (on)
2017  		{
2018  			deactivate_all ();
2019  			activate_change ();
2020  		}
2021  	});
2022  	QObject::connect (create, &QPushButton::released, [this] () {
2023  		switch (group->checkedId ())
2024  		{
2025  			case 0:
2026  				create_send ();
2027  				break;
2028  			case 1:
2029  				create_receive ();
2030  				break;
2031  			case 2:
2032  				create_change ();
2033  				break;
2034  			case 3:
2035  				create_open ();
2036  				break;
2037  			default:
2038  				debug_assert (false);
2039  				break;
2040  		}
2041  	});
2042  	QObject::connect (back, &QPushButton::released, [this] () {
2043  		this->wallet.pop_main_stack ();
2044  	});
2045  	QObject::connect (account, &QLineEdit::textChanged, [this] (const QString & value) {
2046  		auto pos = account->cursorPosition ();
2047  		account->setText (value.trimmed ());
2048  		account->setCursorPosition (pos);
2049  	});
2050  	QObject::connect (destination, &QLineEdit::textChanged, [this] (const QString & value) {
2051  		auto pos = destination->cursorPosition ();
2052  		destination->setText (value.trimmed ());
2053  		destination->setCursorPosition (pos);
2054  	});
2055  	QObject::connect (amount, &QLineEdit::textChanged, [this] (const QString & value) {
2056  		auto pos = amount->cursorPosition ();
2057  		amount->setText (value.trimmed ());
2058  		amount->setCursorPosition (pos);
2059  	});
2060  	QObject::connect (source, &QLineEdit::textChanged, [this] (const QString & value) {
2061  		auto pos = source->cursorPosition ();
2062  		source->setText (value.trimmed ());
2063  		source->setCursorPosition (pos);
2064  	});
2065  	QObject::connect (representative, &QLineEdit::textChanged, [this] (const QString & value) {
2066  		auto pos = representative->cursorPosition ();
2067  		representative->setText (value.trimmed ());
2068  		representative->setCursorPosition (pos);
2069  	});
2070  	send->click ();
2071  }
2072  void nano_qt::block_creation::deactivate_all ()
2073  {
2074  	account_label->hide ();
2075  	account->hide ();
2076  	source_label->hide ();
2077  	source->hide ();
2078  	amount_label->hide ();
2079  	amount->hide ();
2080  	destination_label->hide ();
2081  	destination->hide ();
2082  	representative_label->hide ();
2083  	representative->hide ();
2084  }
2085  void nano_qt::block_creation::activate_send ()
2086  {
2087  	account_label->show ();
2088  	account->show ();
2089  	amount_label->show ();
2090  	amount->show ();
2091  	destination_label->show ();
2092  	destination->show ();
2093  }
2094  void nano_qt::block_creation::activate_receive ()
2095  {
2096  	source_label->show ();
2097  	source->show ();
2098  }
2099  void nano_qt::block_creation::activate_open ()
2100  {
2101  	source_label->show ();
2102  	source->show ();
2103  	representative_label->show ();
2104  	representative->show ();
2105  }
2106  void nano_qt::block_creation::activate_change ()
2107  {
2108  	account_label->show ();
2109  	account->show ();
2110  	representative_label->show ();
2111  	representative->show ();
2112  }
2113  void nano_qt::block_creation::create_send ()
2114  {
2115  	nano::account account_l;
2116  	auto error (account_l.decode_account (account->text ().toStdString ()));
2117  	if (!error)
2118  	{
2119  		nano::amount amount_l;
2120  		error = amount_l.decode_dec (amount->text ().toStdString ());
2121  		if (!error)
2122  		{
2123  			nano::account destination_l;
2124  			error = destination_l.decode_account (destination->text ().toStdString ());
2125  			if (!error)
2126  			{
2127  				auto transaction (wallet.node.wallets.tx_begin_read ());
2128  				auto block_transaction (wallet.node.store.tx_begin_read ());
2129  				nano::raw_key key;
2130  				if (!wallet.wallet_m->store.fetch (transaction, account_l, key))
2131  				{
2132  					auto balance (wallet.node.ledger.account_balance (block_transaction, account_l));
2133  					if (amount_l.number () <= balance)
2134  					{
2135  						nano::account_info info;
2136  						auto error (wallet.node.store.account.get (block_transaction, account_l, info));
2137  						(void)error;
2138  						debug_assert (!error);
2139  						nano::state_block send (account_l, info.head, info.representative, balance - amount_l.number (), destination_l, key, account_l, 0);
2140  						nano::block_details details;
2141  						details.is_send = true;
2142  						details.epoch = info.epoch ();
2143  						auto const required_difficulty{ wallet.node.network_params.work.threshold (send.work_version (), details) };
2144  						if (wallet.node.work_generate_blocking (send, required_difficulty).is_initialized ())
2145  						{
2146  							std::string block_l;
2147  							send.serialize_json (block_l);
2148  							block->setPlainText (QString (block_l.c_str ()));
2149  							show_label_ok (*status);
2150  							status->setText ("Created block");
2151  						}
2152  						else
2153  						{
2154  							debug_assert (required_difficulty <= wallet.node.max_work_generate_difficulty (send.work_version ()));
2155  							show_label_error (*status);
2156  							if (wallet.node.work_generation_enabled ())
2157  							{
2158  								status->setText ("Work generation failure");
2159  							}
2160  							else
2161  							{
2162  								status->setText ("Work generation is disabled");
2163  							}
2164  						}
2165  					}
2166  					else
2167  					{
2168  						show_label_error (*status);
2169  						status->setText ("Insufficient balance");
2170  					}
2171  				}
2172  				else
2173  				{
2174  					show_label_error (*status);
2175  					status->setText ("Account is not in wallet");
2176  				}
2177  			}
2178  			else
2179  			{
2180  				show_label_error (*status);
2181  				status->setText ("Unable to decode destination");
2182  			}
2183  		}
2184  		else
2185  		{
2186  			show_label_error (*status);
2187  			status->setText ("Unable to decode amount");
2188  		}
2189  	}
2190  	else
2191  	{
2192  		show_label_error (*status);
2193  		status->setText ("Unable to decode account");
2194  	}
2195  }
2196  void nano_qt::block_creation::create_receive ()
2197  {
2198  	nano::block_hash source_l;
2199  	auto error (source_l.decode_hex (source->text ().toStdString ()));
2200  	if (!error)
2201  	{
2202  		auto transaction (wallet.node.wallets.tx_begin_read ());
2203  		auto block_transaction (wallet.node.store.tx_begin_read ());
2204  		auto block_l (wallet.node.store.block.get (block_transaction, source_l));
2205  		if (block_l != nullptr)
2206  		{
2207  			auto const & destination (wallet.node.ledger.block_destination (block_transaction, *block_l));
2208  			if (!destination.is_zero ())
2209  			{
2210  				nano::pending_key pending_key (destination, source_l);
2211  				nano::pending_info pending;
2212  				if (!wallet.node.store.pending.get (block_transaction, pending_key, pending))
2213  				{
2214  					nano::account_info info;
2215  					auto error (wallet.node.store.account.get (block_transaction, pending_key.account, info));
2216  					if (!error)
2217  					{
2218  						nano::raw_key key;
2219  						auto error (wallet.wallet_m->store.fetch (transaction, pending_key.account, key));
2220  						if (!error)
2221  						{
2222  							nano::state_block receive (pending_key.account, info.head, info.representative, info.balance.number () + pending.amount.number (), source_l, key, pending_key.account, 0);
2223  							nano::block_details details;
2224  							details.is_receive = true;
2225  							details.epoch = std::max (info.epoch (), pending.epoch);
2226  							auto required_difficulty{ wallet.node.network_params.work.threshold (receive.work_version (), details) };
2227  							if (wallet.node.work_generate_blocking (receive, required_difficulty).is_initialized ())
2228  							{
2229  								std::string block_l;
2230  								receive.serialize_json (block_l);
2231  								block->setPlainText (QString (block_l.c_str ()));
2232  								show_label_ok (*status);
2233  								status->setText ("Created block");
2234  							}
2235  							else
2236  							{
2237  								debug_assert (required_difficulty <= wallet.node.max_work_generate_difficulty (receive.work_version ()));
2238  								show_label_error (*status);
2239  								if (wallet.node.work_generation_enabled ())
2240  								{
2241  									status->setText ("Work generation failure");
2242  								}
2243  								else
2244  								{
2245  									status->setText ("Work generation is disabled");
2246  								}
2247  							}
2248  						}
2249  						else
2250  						{
2251  							show_label_error (*status);
2252  							status->setText ("Account is not in wallet");
2253  						}
2254  					}
2255  					else
2256  					{
2257  						show_label_error (*status);
2258  						status->setText ("Account not yet open");
2259  					}
2260  				}
2261  				else
2262  				{
2263  					show_label_error (*status);
2264  					status->setText ("Source block is not ready to be received");
2265  				}
2266  			}
2267  			else
2268  			{
2269  				show_label_error (*status);
2270  				status->setText ("Source is not a send block");
2271  			}
2272  		}
2273  		else
2274  		{
2275  			show_label_error (*status);
2276  			status->setText ("Source block not found");
2277  		}
2278  	}
2279  	else
2280  	{
2281  		show_label_error (*status);
2282  		status->setText ("Unable to decode source");
2283  	}
2284  }
2285  void nano_qt::block_creation::create_change ()
2286  {
2287  	nano::account account_l;
2288  	auto error (account_l.decode_account (account->text ().toStdString ()));
2289  	if (!error)
2290  	{
2291  		nano::account representative_l;
2292  		error = representative_l.decode_account (representative->text ().toStdString ());
2293  		if (!error)
2294  		{
2295  			auto transaction (wallet.node.wallets.tx_begin_read ());
2296  			auto block_transaction (wallet.node.store.tx_begin_read ());
2297  			nano::account_info info;
2298  			auto error (wallet.node.store.account.get (block_transaction, account_l, info));
2299  			if (!error)
2300  			{
2301  				nano::raw_key key;
2302  				auto error (wallet.wallet_m->store.fetch (transaction, account_l, key));
2303  				if (!error)
2304  				{
2305  					nano::state_block change (account_l, info.head, representative_l, info.balance, 0, key, account_l, 0);
2306  					nano::block_details details;
2307  					details.epoch = info.epoch ();
2308  					auto const required_difficulty{ wallet.node.network_params.work.threshold (change.work_version (), details) };
2309  					if (wallet.node.work_generate_blocking (change, required_difficulty).is_initialized ())
2310  					{
2311  						std::string block_l;
2312  						change.serialize_json (block_l);
2313  						block->setPlainText (QString (block_l.c_str ()));
2314  						show_label_ok (*status);
2315  						status->setText ("Created block");
2316  					}
2317  					else
2318  					{
2319  						debug_assert (required_difficulty <= wallet.node.max_work_generate_difficulty (change.work_version ()));
2320  						show_label_error (*status);
2321  						if (wallet.node.work_generation_enabled ())
2322  						{
2323  							status->setText ("Work generation failure");
2324  						}
2325  						else
2326  						{
2327  							status->setText ("Work generation is disabled");
2328  						}
2329  					}
2330  				}
2331  				else
2332  				{
2333  					show_label_error (*status);
2334  					status->setText ("Account is not in wallet");
2335  				}
2336  			}
2337  			else
2338  			{
2339  				show_label_error (*status);
2340  				status->setText ("Account not yet open");
2341  			}
2342  		}
2343  		else
2344  		{
2345  			show_label_error (*status);
2346  			status->setText ("Unable to decode representative");
2347  		}
2348  	}
2349  	else
2350  	{
2351  		show_label_error (*status);
2352  		status->setText ("Unable to decode account");
2353  	}
2354  }
2355  void nano_qt::block_creation::create_open ()
2356  {
2357  	nano::block_hash source_l;
2358  	auto error (source_l.decode_hex (source->text ().toStdString ()));
2359  	if (!error)
2360  	{
2361  		nano::account representative_l;
2362  		error = representative_l.decode_account (representative->text ().toStdString ());
2363  		if (!error)
2364  		{
2365  			auto transaction (wallet.node.wallets.tx_begin_read ());
2366  			auto block_transaction (wallet.node.store.tx_begin_read ());
2367  			auto block_l (wallet.node.store.block.get (block_transaction, source_l));
2368  			if (block_l != nullptr)
2369  			{
2370  				auto const & destination (wallet.node.ledger.block_destination (block_transaction, *block_l));
2371  				if (!destination.is_zero ())
2372  				{
2373  					nano::pending_key pending_key (destination, source_l);
2374  					nano::pending_info pending;
2375  					if (!wallet.node.store.pending.get (block_transaction, pending_key, pending))
2376  					{
2377  						nano::account_info info;
2378  						auto error (wallet.node.store.account.get (block_transaction, pending_key.account, info));
2379  						if (error)
2380  						{
2381  							nano::raw_key key;
2382  							auto error (wallet.wallet_m->store.fetch (transaction, pending_key.account, key));
2383  							if (!error)
2384  							{
2385  								nano::state_block open (pending_key.account, 0, representative_l, pending.amount, source_l, key, pending_key.account, 0);
2386  								nano::block_details details;
2387  								details.is_receive = true;
2388  								details.epoch = pending.epoch;
2389  								auto const required_difficulty{ wallet.node.network_params.work.threshold (open.work_version (), details) };
2390  								if (wallet.node.work_generate_blocking (open, required_difficulty).is_initialized ())
2391  								{
2392  									std::string block_l;
2393  									open.serialize_json (block_l);
2394  									block->setPlainText (QString (block_l.c_str ()));
2395  									show_label_ok (*status);
2396  									status->setText ("Created block");
2397  								}
2398  								else
2399  								{
2400  									debug_assert (required_difficulty <= wallet.node.max_work_generate_difficulty (open.work_version ()));
2401  									show_label_error (*status);
2402  									if (wallet.node.work_generation_enabled ())
2403  									{
2404  										status->setText ("Work generation failure");
2405  									}
2406  									else
2407  									{
2408  										status->setText ("Work generation is disabled");
2409  									}
2410  								}
2411  							}
2412  							else
2413  							{
2414  								show_label_error (*status);
2415  								status->setText ("Account is not in wallet");
2416  							}
2417  						}
2418  						else
2419  						{
2420  							show_label_error (*status);
2421  							status->setText ("Account already open");
2422  						}
2423  					}
2424  					else
2425  					{
2426  						show_label_error (*status);
2427  						status->setText ("Source block is not ready to be received");
2428  					}
2429  				}
2430  				else
2431  				{
2432  					show_label_error (*status);
2433  					status->setText ("Source is not a send block");
2434  				}
2435  			}
2436  			else
2437  			{
2438  				show_label_error (*status);
2439  				status->setText ("Source block not found");
2440  			}
2441  		}
2442  		else
2443  		{
2444  			show_label_error (*status);
2445  			status->setText ("Unable to decode representative");
2446  		}
2447  	}
2448  	else
2449  	{
2450  		show_label_error (*status);
2451  		status->setText ("Unable to decode source");
2452  	}
2453  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-svmmodels.cpp</h3>
            <pre><code>1  void TCrossValid::PrepareFolds(const int& Folds, TIntV& DIdV,
2          const int& Seed, TVec<TIntV>& DIdVFoldV) {
3      IAssert(Folds > 1);
4      IAssertR(DIdV.Len()/Folds > 1,
5          TStr::Fmt("To little documents per fold (%d/%d)", DIdV.Len(), Folds));
6      DIdVFoldV.Gen(Folds);
7      const int Len = DIdV.Len();
8      for (int FoldN = 0; FoldN < Folds; FoldN++)
9          DIdVFoldV[FoldN].Gen(Len/Folds, 0);
10      int DocN = 0;
11      TRnd Rnd(Seed); DIdV.Shuffle(Rnd);
12      while (DocN < Len) {
13          int FoldN = 0;
14          while (DocN < Len && FoldN < Folds) {
15              DIdVFoldV[FoldN].Add(DIdV[DocN]);
16              FoldN++; DocN++;
17          }
18      }
19      DIdV.Sort();
20      for (int FoldN = 0; FoldN < Folds; FoldN++) {
21          DIdVFoldV[FoldN].Sort();
22      }
23  }
24  void TCrossValid::PrepareSplit(const int& FoldN, const TVec<TIntV>& DIdVFoldV,
25                                 TIntV& TrainSubDIdV, TIntV& TestSubDIdV) {
26      TrainSubDIdV.Clr(); TestSubDIdV.Clr();
27      for (int n = 0; n < DIdVFoldV.Len(); n++) {
28          if (n == FoldN) {
29              TestSubDIdV.AddV(DIdVFoldV[n]);
30          } else {
31              TrainSubDIdV.AddV(DIdVFoldV[n]);
32          }
33      }
34      TrainSubDIdV.Sort(); TestSubDIdV.Sort();
35  }
36  void TCrossValid::PrepareSubDIdV(const TIntV& SubSet, const int& DataSetLen, TIntV& DIdV) {
37      if (SubSet.Empty()) {
38          DIdV.Gen(DataSetLen, 0);
39          for (int i = 0; i < DataSetLen; i++) DIdV.Add(i);
40      } else {
41          DIdV = SubSet;
42      }
43  }
44  bool TSparseTrainSet::IsReg=TSparseTrainSet::MkReg();
45  TSparseTrainSet::TSparseTrainSet(const TIntV& VecIdV, const int& _MaxDim, const TFltV& _ClsV,
46          const TFltV& _NormV, const TVec<TIntFltKdV>& _TrainV): TSVMTrainSet(ststSparse) {
47      if (VecIdV.Empty()) {
48          MaxDim = _MaxDim; ClsV = _ClsV;
49          NormV = _NormV; TrainV = _TrainV;
50      } else {
51          MaxDim = _MaxDim;
52          const int Vecs = VecIdV.Len();
53          ClsV.Gen(Vecs, 0); NormV.Gen(Vecs, 0); TrainV.Gen(Vecs, 0);
54          for (int VecN = 0; VecN < Vecs; VecN++) {
55              const int VecId = VecIdV[VecN];
56              ClsV.Add(_ClsV[VecId]);
57              NormV.Add(_NormV[VecId]);
58              TrainV.Add(_TrainV[VecId]);
59          }
60      }
61  }
62  void TSparseTrainSet::SaveTxt(const TStr& OutFNm) const {
63      PSOut SOut = TFOut::New(OutFNm);
64      for (int VecN = 0; VecN < TrainV.Len(); VecN++) {
65          const TIntFltKdV& AttrV = TrainV[VecN];
66          SOut->PutStr(TStr::Fmt("%f", GetVecParam(VecN)));
67          for (int a = 0; a < AttrV.Len(); a++) {
68              SOut->PutStr(TStr::Fmt(" %d:%f", AttrV[a].Key(), AttrV[a].Dat()));
69          }
70          SOut->PutLn();
71      }
72      SOut->Flush();
73  }
74  void TSparseTrainSet::SaveMatlab(const TStr& FName) const {
75      PSOut out = TFOut::New(FName);
76      int ColN = Len();
77      for (int ColId = 0; ColId < ColN; ColId++) {
78          const TIntFltKdV& Vec = TrainV[ColId];
79          for (int RowId = 0, RowN = Vec.Len(); RowId < RowN; RowId++) {
80              out->PutStr(TInt::GetStr(Vec[RowId].Key + 1) + TStr(" ") + TInt::GetStr(ColId + 1) + TStr(" "));
81              out->PutStr(TFlt::GetStr(Vec[RowId].Dat, 20, 18));
82              out->PutCh('\n');
83          }
84      }
85  }
86  double TSparseTrainSet::DotProduct(const int& VecId1, double* vec2, const int& n) const {
87      double Res = 0.0;
88      const TIntFltKdV& V1 = TrainV[VecId1];
89      for (int i = 0; i < V1.Len(); i++) {
90          const int key = V1[i].Key;
91          if (key < n) Res += V1[i].Dat * vec2[key];
92      }
93      return Res;
94  }
95  void TSparseTrainSet::AddVec(const int& VecId1, double* vec2,
96          const int& n, const double& K) const {
97      const TIntFltKdV& V1 = TrainV[VecId1];
98      for (int i = 0; i < V1.Len(); i++) {
99          Assert(V1[i].Key < n);
100          vec2[V1[i].Key] += K * V1[i].Dat;
101      }
102  }
103  int TSparseTrainSet::AddAttrV(const TIntFltKdV& AttrV,
104          const double& Cls, const bool& Normalize) {
105      double Norm = TLinAlg::Norm2(AttrV);
106      IAssertR(Norm >= 0.0, TStr::Fmt("%g (len = %d)", Norm, AttrV.Len()));
107      NormV.Add(Norm); TrainV.Add(AttrV); TrainV.Last().Pack(); ClsV.Add(Cls);
108      if (AttrV.Empty()) {
109          TrainV.Last().Add(TIntFltKd(1, 0.0));
110      } else {
111          MaxDim = TInt::GetMx(int(MaxDim), AttrV.Last().Key+1);
112          if (Normalize) { TLinAlg::Normalize(TrainV.Last()); }
113      }
114      return TrainV.Len()-1;
115  }
116  void TSparseTrainSet::Shuffle(TRnd& Rnd) {
117      const int Vals = TrainV.Len();
118      for (int ValN=0; ValN<Vals-1; ValN++) {
119          const int NewValN = ValN+Rnd.GetUniDevInt(Vals-ValN);
120          TrainV.Swap(ValN, NewValN);
121          ClsV.Swap(ValN, NewValN);
122          NormV.Swap(ValN, NewValN);
123      }
124  }
125  PSVMTrainSet TSparseTrainSet::LoadTxt(PSIn SIn, const bool& Normalize, const int& verbosity) {
126      TMem buffer;
127      TMem::LoadMem(SIn, buffer);
128      if (buffer[buffer.Len()-1] != '\n') buffer += '\n';  
129      int len = buffer.Len(), n = 0;
130      char ch, *s; int vecsP = 0, vecsM = 0, line = 0;
131      double cls; TIntFltKdV vec;
132      PSVMTrainSet docs = TSparseTrainSet::New();
133      if (len == 0) return docs;
134      ch = buffer[n++];
135      while (n < len) {
136          line++;
137          vec.Clr(false);
138          if (ch != '#') {
139              while (ch == ' ') ch = buffer[n++]; 
140              TChA clsChA;
141              while (ch != ' ' && ch != '\r' && ch != '\n') {
142                  clsChA += ch;
143                  ch = buffer[n++];
144              }
145              if (clsChA.Len() > 0) {
146                  cls = strtod(clsChA.CStr(), &s);
147                  int part = 0;
148                  TChA idChA, valChA;
149                  while (ch != '\r' && ch != '\n' && ch != '#') {
150                      if (part == 0 && ch == ' ') {
151                      } else if (part == 0 && ch != ' ') {
152                          part = 1;     
153                          Assert('0' <= ch && ch <= '9');
154                          idChA += ch;
155                      } else if (part == 1 && ch != ':') {
156                          Assert('0' <= ch && ch <= '9');
157                          idChA += ch;  
158                      } else if (part == 1 && ch == ':') {
159                          part = 2;     
160                      } else if (part == 2 && ch != ' ') {
161                          Assert(('0' <= ch && ch <= '9') || ch == '.');
162                          valChA += ch; 
163                      } else if (part == 2 && ch == ' ') {
164                          int id = strtol(idChA.CStr(), &s, 10);
165                          double val = strtod(valChA.CStr(), &s);
166                          vec.Add(TIntFltKd(id, val));
167                          idChA.Clr(); valChA.Clr();
168                          part = 0;
169                      } else {
170                          printf("error in %d, unexpected charater %c!\n", line, ch);
171                          Assert(false);
172                      }
173                      ch = buffer[n++];
174                      if (part == 2 && (ch == '\r' || ch == '\n' || ch == '#')) {
175                          int id = strtol(idChA.CStr(), &s, 10);
176                          double val = strtod(valChA.CStr(), &s);
177                          vec.Add(TIntFltKd(id, val));
178                          idChA.Clr(); valChA.Clr();
179                          part = 0;
180                      }
181                  } 
182                  if (part != 0) printf("unexpected end of line %d\n", line);
183                  Assert(part == 0); 
184                  docs->AddAttrV(vec, cls, Normalize);
185                  if (cls > 0) vecsP++;
186                  else vecsM++;
187                  if (verbosity > 0 && (vecsP + vecsM)%100 == 0) printf("%d\r", vecsP + vecsM);
188                  while (ch != '\n') ch = buffer[n++]; 
189              }
190          } else {
191              while (ch != '\n') ch = buffer[n++];
192          }
193          if (n < len) ch = buffer[n++];
194      }
195      printf("\n");
196      if (verbosity > 1)
197          printf("\ninput: %d = %d + %d vectors\n", vecsP + vecsM, vecsP, vecsM);
198      else if (verbosity > 0)
199          printf("\n");
200      return docs;
201  }
202  bool TDenseTrainSet::IsReg=TDenseTrainSet::MkReg();
203  TDenseTrainSet::TDenseTrainSet(const TIntV& VecIdV, const int& _MaxDim, const TFltV& _ClsV,
204          const TFltV& _NormV, const TVec<TFltV>& _TrainV): TSVMTrainSet(ststDense) {
205      if (VecIdV.Empty()) {
206          MaxDim = _MaxDim; ClsV = _ClsV;
207          NormV = _NormV; TrainV = _TrainV;
208      } else {
209          MaxDim = _MaxDim;
210          const int Vecs = VecIdV.Len();
211          ClsV.Gen(Vecs, 0); NormV.Gen(Vecs, 0); TrainV.Gen(Vecs, 0);
212          for (int VecN = 0; VecN < Vecs; VecN++) {
213              const int VecId = VecIdV[VecN];
214              ClsV.Add(_ClsV[VecId]);
215              NormV.Add(_NormV[VecId]);
216              TrainV.Add(_TrainV[VecId]);
217          }
218      }
219  }
220  PSVMTrainSet TDenseTrainSet::LoadFromSparse(PSVMTrainSet SparseSet) {
221      const int Vecs = SparseSet->Len();
222      const int Dims = SparseSet->Dim();
223      PSVMTrainSet DenseSet = TDenseTrainSet::New(Vecs);
224      TFltV AttrDenseV(Dims);
225      for (int VecN = 0; VecN < SparseSet->Len(); VecN++) {
226          const TIntFltKdV& AttrSparseV = SparseSet->GetAttrSparseV(VecN);
227          AttrDenseV.PutAll(0.0);
228          TLinAlg::AddVec(1.0, AttrSparseV, AttrDenseV);
229          DenseSet->AddAttrV(AttrDenseV, SparseSet->GetVecParam(VecN), false);
230      }
231      return DenseSet;
232  }
233  void TDenseTrainSet::SaveTxt(const TStr& OutFNm) const {
234      PSOut SOut = TFOut::New(OutFNm);
235      for (int VecN = 0; VecN < TrainV.Len(); VecN++) {
236          const TFltV& AttrV = TrainV[VecN];
237          SOut->PutStr(TStr::Fmt("%f", GetVecParam(VecN)));
238          for (int a = 0; a < AttrV.Len(); a++) {
239              SOut->PutStr(TStr::Fmt(" %d:%f", a+1, AttrV[a]()));
240          }
241          SOut->PutLn();
242      }
243      SOut->Flush();
244  }
245  int TDenseTrainSet::AddAttrV(const TFltV& AttrV, const double& Cls, const bool& Normalize) {
246      IAssert(!AttrV.Empty());
247      IAssert(MaxDim == 0 || AttrV.Len() == MaxDim);
248      MaxDim = AttrV.Len();
249      double Norm = TLinAlg::Norm2(AttrV); NormV.Add(Norm);
250      TrainV.Add(AttrV); TrainV.Last().Pack(); ClsV.Add(Cls);
251      if (Normalize) { TLinAlg::Normalize(TrainV.Last()); }
252      return TrainV.Len()-1;
253  }
254  double TDenseTrainSet::DotProduct(const int& VecId1, double* vec2, const int& n) const {
255      IAssert(n == MaxDim);
256      const TFltV& V1 = TrainV[VecId1];
257      double Res = V1[0]*vec2[0];
258      for (int i = 1; i < MaxDim; i++)
259          Res += V1[i]*vec2[i];
260      return Res;
261  }
262  void TDenseTrainSet::AddVec(const int& VecId1, double* vec2,
263                              const int& n, const double& K) const {
264      IAssert(n == MaxDim);
265      const TFltV& V1 = TrainV[VecId1];
266      for (int i = 0; i < MaxDim; i++)
267          vec2[i] += K*V1[i];
268  }
269  void TDenseTrainSet::Shuffle(TRnd& Rnd) {
270      const int Vals = TrainV.Len();
271      for (int ValN=0; ValN<Vals-1; ValN++) {
272          const int NewValN = ValN+Rnd.GetUniDevInt(Vals-ValN);
273          TrainV.Swap(ValN, NewValN);
274          ClsV.Swap(ValN, NewValN);
275          NormV.Swap(ValN, NewValN);
276      }
277  }
278  PSVMTrainSet TDenseTrainSet::ProjectLin(PSVMTrainSet Set,
279          const TFltVV& Basis, const bool& Normalize, const int& NewDim) {
280      IAssert(NewDim == -1 || (NewDim >= 0 && NewDim <= Basis.GetYDim()));
281      const int Dim = (NewDim == -1) ? Basis.GetYDim() : NewDim; 
282      const int Len = Basis.GetXDim();
283      TVec<TFltV> NewBasis(Dim);
284      for (int VecC = 0; VecC < Dim; VecC++) {
285          NewBasis[VecC].Gen(Len,0);
286          for (int i = 0; i < Len; i++) {
287              NewBasis[VecC].Add(Basis(i, VecC));
288          }
289      }
290      return ProjectLin(Set, NewBasis, Normalize);
291  }
292  PSVMTrainSet TDenseTrainSet::ProjectLin(PSVMTrainSet Set,
293          const TVec<TFltV>& Basis, const bool& Normalize, const int& NewDim) {
294      IAssert(NewDim == -1 || (NewDim >= 0 && NewDim <= Basis.Len()));
295      const int VecN = Set->Len(); 
296      const int Dim = (NewDim == -1) ? Basis.Len() : NewDim; 
297      PSVMTrainSet NewSet = TDenseTrainSet::New(VecN);
298      for (int VecC = 0; VecC < VecN; VecC++) {
299          if (VecC % 100 == 0) printf("%d\r", VecC);
300          TFltV Vec(Dim, 0);
301          for (int i = 0; i < Dim; i++) {
302              Vec.Add(Set->DotProduct(VecC, Basis[i]));
303          }
304          NewSet->AddAttrV(Vec, Set->GetVecParam(VecC), Normalize);
305      }
306      printf("\n");
307      return NewSet;
308  }
309  bool TBowTrainSet::IsReg=TBowTrainSet::MkReg();
310  TBowTrainSet::TBowTrainSet(const TIntV& VecIdV, const int& _MaxDim, const TIntV& _DIdV,
311          const TVec<PBowSpV>& _TrainV, const TFltV& _ClsV): TSVMTrainSet(ststBow) {
312      if (VecIdV.Empty()) {
313          MaxDim = _MaxDim; DIdV = _DIdV;
314          TrainV = _TrainV; ClsV = _ClsV;
315      } else {
316          MaxDim = _MaxDim;
317          const int Vecs = VecIdV.Len();
318          DIdV.Gen(Vecs, 0); TrainV.Gen(Vecs, 0); ClsV.Gen(Vecs, 0);
319          for (int VecN = 0; VecN < Vecs; VecN++) {
320              const int VecId = VecIdV[VecN];
321              DIdV.Add(_DIdV[VecId]);
322              TrainV.Add(_TrainV[VecId]);
323              ClsV.Add(_ClsV[VecId]);
324          }
325      }
326  }
327  void TBowTrainSet::SaveTxt(const TStr& OutFNm) const {
328      PSOut SOut = TFOut::New(OutFNm);
329      for (int VecN = 0; VecN < TrainV.Len(); VecN++) {
330          PBowSpV AttrV = TrainV[VecN];
331          SOut->PutStr(TStr::Fmt("%f", GetVecParam(VecN)));
332          for (int a = 0; a < AttrV->Len(); a++) {
333              SOut->PutStr(TStr::Fmt(" %d:%f", AttrV->GetWId(a), AttrV->GetWgt(a).Val));
334          }
335          SOut->PutLn();
336      }
337      SOut->Flush();
338  }
339  double TBowTrainSet::DotProduct(const int& VecId1, double* vec2, const int& n) const {
340      double res = 0.0;
341      TBowWIdWgtKd* vec1 = TrainV[VecId1]->BegI();
342      int len1 = TrainV[VecId1]->Len();
343      for (int i = 0; i < len1; i++) {
344          Assert(vec1[i].Key < n);
345          res += vec2[vec1[i].Key] * vec1[i].Dat;
346      }
347      return res;
348  }
349  void TBowTrainSet::AddVec(const int& VecId1, double* vec2,
350                            const int& n, const double& K) const {
351      TBowWIdWgtKd* vec1 = TrainV[VecId1]->BegI();
352      int len1 = TrainV[VecId1]->Len();
353      for (int i = 0; i < len1; i++) {
354          Assert(vec1[i].Key < n);
355          vec2[vec1[i].Key] += K * vec1[i].Dat;
356      }
357  }
358  void TBowTrainSet::AddVec(const int& VecId1, TFltV& vec2, const double& K) const {
359      PBowSpV vec1 = TrainV[VecId1]; int len1 = vec1->Len();
360      for (int i = 0; i < len1; i++) {
361          Assert(vec1->GetWId(i) < vec2.Len());
362          vec2[vec1->GetWId(i)] += K * vec1->GetWgt(i);
363      }
364  }
365  int TBowTrainSet::AddAttrV(const int& DId, PBowSpV SpVec, const double& Cls) {
366      DIdV.Add(DId); TrainV.Add(SpVec); ClsV.Add(Cls);
367      if (SpVec->GetWIds() > 0) {
368          int VecDim = SpVec->GetWId(SpVec->GetWIds()-1);
369          MaxDim = MaxDim > VecDim ? MaxDim() : VecDim + 1;
370      }
371      return TrainV.Len()-1;
372  }
373  void TBowTrainSet::Shuffle(TRnd& Rnd) {
374      const int Vals = TrainV.Len();
375      for (int ValN=0; ValN<Vals-1; ValN++) {
376          const int NewValN = ValN+Rnd.GetUniDevInt(Vals-ValN);
377          DIdV.Swap(ValN, NewValN);
378          TrainV.Swap(ValN, NewValN);
379          ClsV.Swap(ValN, NewValN);
380      }
381  }
382  bool TStringTrainSet::IsReg=TStringTrainSet::MkReg();
383  void TStringTrainSet::UpdateAlphN(const TIntV& Vec) {
384      for (int i = 0, l = Vec.Len(); i < l; i++)
385          AlphN = TInt::GetMx(AlphN, Vec[i]+1);
386      StrKer->UpdateAlphN(AlphN);
387  }
388  TStringTrainSet::TStringTrainSet(const TIntV& VecIdV, const TFltV& _ClsV,
389          const TFltV& _NormV, const TVec<TIntV>& _TrainV, PStrParser _Parser,
390          const int& _AlphN, PStringKernel _StrKer): TSVMTrainSet(ststString) {
391      if (VecIdV.Empty()) {
392          ClsV = _ClsV; NormV = _NormV; TrainV = _TrainV;
393          Parser = _Parser; AlphN = _AlphN; StrKer = _StrKer;
394      } else {
395          const int Vecs = VecIdV.Len();
396          ClsV.Gen(Vecs, 0); NormV.Gen(Vecs, 0); TrainV.Gen(Vecs, 0);
397          for (int VecN = 0; VecN < Vecs; VecN++) {
398              const int VecId = VecIdV[VecN];
399              ClsV.Add(_ClsV[VecId]);
400              NormV.Add(_NormV[VecId]);
401              TrainV.Add(_TrainV[VecId]);
402          }
403          Parser = _Parser; AlphN = _AlphN; StrKer = _StrKer;
404      }
405      printf("AlphN = [%d => %d]\n", _AlphN, AlphN.Val);
406  }
407  int TStringTrainSet::AddAttrV(const TStr& AttrV, const double& Cls) {
408      TIntV ParsedAttrV; Parser->ProcessDocStr(AttrV, ParsedAttrV);
409      return AddAttrV(ParsedAttrV, Cls);
410  }
411  int TStringTrainSet::AddAttrV(const TIntV& AttrV, const double& Cls) {
412      IAssert(!AttrV.Empty());
413      UpdateAlphN(AttrV);
414      const double Norm = StrKer->CalcKernel(AttrV, AttrV);
415      ClsV.Add(Cls); NormV.Add(Norm);
416      TrainV.Add(AttrV); TrainV.Last().Pack();
417      return TrainV.Len()-1;
418  }
419  double TStringTrainSet::DotProduct(const int& VecId1, const TStr& Vec2) const {
420      TIntV ParsedVec2; Parser->ProcessDocStr(Vec2, ParsedVec2);
421      return DotProduct(VecId1, ParsedVec2);
422  }
423  double TStringTrainSet::DotProduct(const int& VecId1, const TIntV& Vec2) const {
424      const double Norm = StrKer->CalcKernel(Vec2, Vec2);
425      return StrKer->CalcKernel(TrainV[VecId1],Vec2) / sqrt(NormV[VecId1]*Norm);
426  }
427  void TStringTrainSet::Shuffle(TRnd& Rnd) {
428      const int Vals = TrainV.Len();
429      for (int ValN=0; ValN<Vals-1; ValN++) {
430          const int NewValN = ValN+Rnd.GetUniDevInt(Vals-ValN);
431          TrainV.Swap(ValN, NewValN);
432          ClsV.Swap(ValN, NewValN);
433          NormV.Swap(ValN, NewValN);
434      }
435  }
436  TSimMatrixTrainSet::TSimMatrixTrainSet(const TIntV& VecIdV,
437          const TFltV& _ClsV, const TFltVV& _SimMatrix): TSVMTrainSet(ststSimMatrix) {
438      const int Vecs = VecIdV.Len();
439      SimMatrix.Gen(Vecs, Vecs); ClsV.Gen(Vecs, 0);
440      for (int i = 0; i < Vecs; i++) {
441          const int VecId1 = VecIdV[i];
442          ClsV.Add(_ClsV[VecId1]);
443          for (int j = 0; j < Vecs; j++) {
444              const int VecId2 = VecIdV[j];
445              SimMatrix(i, j) = _SimMatrix(VecId1, VecId2);
446          }
447      }
448  }
449  TSimMatrixTrainSet::TSimMatrixTrainSet(const TFltVV& _SimMatrix,
450          const TFltV& _ClsV): TSVMTrainSet(ststSimMatrix), SimMatrix(_SimMatrix) {
451      if (_ClsV.Empty()) {
452          ClsV.Gen(SimMatrix.GetXDim());
453          ClsV.PutAll(0.0);
454      } else {
455          ClsV = _ClsV;
456          Assert(ClsV.Len() == SimMatrix.GetXDim());
457      }
458  }
459  void TBowDocBs2TrainSet::MakeSpVec(PBowSpV BowVec, TIntFltKdV& SpVec) {
460      const int BowVecLen = BowVec->GetWIds(); SpVec.Gen(BowVecLen, 0);
461      for (int WgtC = 0, WgtN = BowVecLen; WgtC < WgtN; WgtC++) {
462          SpVec.Add(TIntFltKd(BowVec->GetWId(WgtC), BowVec->GetWgt(WgtC).Val));
463      }
464  }
465  PSVMTrainSet TBowDocBs2TrainSet::NewBowNoCat(
466          const TVec<PBowSpV>& BowSpV, const double& DefParam) {
467      int DocN = BowSpV.Len();
468      PSVMTrainSet docs = TBowTrainSet::New(DocN);
469      for (int DocC = 0; DocC < DocN; DocC++) {
470          docs->AddAttrV(DocC, BowSpV[DocC], DefParam);
471      }
472      return docs;
473  }
474  PSVMTrainSet TBowDocBs2TrainSet::NewBowNoCat(PBowDocWgtBs BowDocWgtBs,
475          const TIntV& DIdV, const double& DefParam) {
476      int DocN = DIdV.Len();
477      PSVMTrainSet docs = TBowTrainSet::New(DocN);
478      for (int DocC = 0; DocC < DocN; DocC++) {
479          int DId = DIdV[DocC];
480          PBowSpV SpV = BowDocWgtBs->GetSpV(DId);
481          docs->AddAttrV(DId, SpV, DefParam);
482      }
483      return docs;
484  }
485  PSVMTrainSet TBowDocBs2TrainSet::NewSparseNoCat(
486          const TVec<PBowSpV>& BowSpV, const double& DefParam) {
487      int DocN = BowSpV.Len();
488      PSVMTrainSet Set = TSparseTrainSet::New(DocN); TIntFltKdV SpVec;
489      for (int DocC = 0; DocC < DocN; DocC++) {
490          MakeSpVec(BowSpV[DocC], SpVec);
491          Set->AddAttrV(SpVec, DefParam, false);
492      }
493      return Set;
494  }
495  PSVMTrainSet TBowDocBs2TrainSet::NewSparseNoCat(PBowDocWgtBs BowDocWgtBs,
496          const TIntV& DIdV, const double& DefParam) {
497      int DocN=DIdV.Len();
498      PSVMTrainSet Set = TSparseTrainSet::New(DocN); TIntFltKdV SpVec;
499      for (int DocC = 0; DocC < DocN; DocC++) {
500          int DId = DIdV[DocC];
501          MakeSpVec(BowDocWgtBs->GetSpV(DId), SpVec);
502          Set->AddAttrV(SpVec, DefParam, false);
503      }
504      return Set;
505  }
506  PSVMTrainSet TBowDocBs2TrainSet::NewBowOneCat(const PBowDocBs& BowDocBs,
507          PBowDocWgtBs BowDocWgtBs, const int& CatId, const TIntV& DIdV) {
508      int DocN = DIdV.Len();
509      PSVMTrainSet docs = TBowTrainSet::New(DocN);
510      for (int DocC = 0; DocC < DocN; DocC++) {
511          int DId = DIdV[DocC];
512          if (BowDocBs->IsCatInDoc(DId, CatId)) {
513              PBowSpV SpV = BowDocWgtBs->GetSpV(DId);
514              docs->AddAttrV(DId, SpV, 1.0);
515          }
516      }
517      return docs;
518  }
519  PSVMTrainSet TBowDocBs2TrainSet::NewSparseOneCat(const PBowDocBs& BowDocBs,
520          PBowDocWgtBs BowDocWgtBs, const int& CatId, const TIntV& DIdV) {
521      int DocN=DIdV.Len();
522      PSVMTrainSet Set = TSparseTrainSet::New(DocN); TIntFltKdV SpVec;
523      for (int DocC = 0; DocC < DocN; DocC++) {
524          int DId = DIdV[DocC];
525          if (BowDocBs->IsCatInDoc(DId, CatId)) {
526              MakeSpVec(BowDocWgtBs->GetSpV(DId), SpVec);
527              Set->AddAttrV(SpVec, 1.0, false);
528          }
529      }
530      return Set;
531  }
532  PSVMTrainSet TBowDocBs2TrainSet::NewStringOneCat(const PBowDocBs& BowDocBs,
533          const int& CatId, const TIntV& DIdV, PStrParser Parser, PStringKernel StrKer) {
534      int DocN=DIdV.Len();
535      PSVMTrainSet Set = TStringTrainSet::New(Parser, StrKer, DocN); TIntFltKdV SpVec;
536      for (int DocC = 0; DocC < DocN; DocC++) {
537          int DId = DIdV[DocC];
538          if (BowDocBs->IsCatInDoc(DId, CatId)) {
539              TStr DocStr = BowDocBs->GetDocStr(DId);
540              Set->AddAttrV(DocStr, 1.0);
541          }
542      }
543      return Set;
544  }
545  PSVMTrainSet TBowDocBs2TrainSet::NewBowAllCat(const PBowDocBs& BowDocBs,
546          PBowDocWgtBs BowDocWgtBs, const int& CatId, const TIntV& DIdV,
547          const double& SampleNegP) {
548      int Docs = DIdV.Len();
549      TIntV PosDIdV, NegDIdV;
550      for (int DocN = 0; DocN < Docs; DocN++) {
551          const int DId = DIdV[DocN];
552          if(BowDocBs->IsCatInDoc(DId, CatId)) {
553              PosDIdV.Add(DId);
554          } else {
555              NegDIdV.Add(DId);
556          }
557      }
558      const int SampleSize = TFlt::Round(PosDIdV.Len() * SampleNegP);
559      if ((SampleSize > 0) && (NegDIdV.Len() > SampleSize)) {
560          TRnd Rnd(1); NegDIdV.Shuffle(Rnd); NegDIdV.Trunc(SampleSize);
561      }
562      PSVMTrainSet docs = TBowTrainSet::New(NegDIdV.Len() + PosDIdV.Len());
563      for (int PosDocN = 0; PosDocN < PosDIdV.Len(); PosDocN++) {
564          const int DId = PosDIdV[PosDocN]; docs->AddAttrV(DId, BowDocWgtBs->GetSpV(DId), 1.0); }
565      for (int NegDocN = 0; NegDocN < NegDIdV.Len(); NegDocN++) {
566          const int DId = NegDIdV[NegDocN]; docs->AddAttrV(DId, BowDocWgtBs->GetSpV(DId), -1.0); }
567      return docs;
568  }
569  PSVMTrainSet TBowDocBs2TrainSet::NewSparseAllCat(const PBowDocBs& BowDocBs,
570          PBowDocWgtBs BowDocWgtBs, const int& CatId, const TIntV& DIdV) {
571      int DocN = DIdV.Len();
572      PSVMTrainSet Set = TSparseTrainSet::New(DocN); TIntFltKdV SpVec;
573      for (int DocC = 0; DocC < DocN; DocC++) {
574          int DId = DIdV[DocC];
575          double param = BowDocBs->IsCatInDoc(DId, CatId) ? 1.0 : -1.0;
576          MakeSpVec(BowDocWgtBs->GetSpV(DId), SpVec);
577          Set->AddAttrV(SpVec, param, false);
578      }
579      return Set;
580  }
581  PSVMTrainSet TBowDocBs2TrainSet::NewStringAllCat(const PBowDocBs& BowDocBs,
582          const int& CatId, const TIntV& DIdV, PStrParser Parser, PStringKernel StrKer) {
583      int DocN = DIdV.Len();
584      PSVMTrainSet Set = TStringTrainSet::New(Parser, StrKer, DocN); TIntFltKdV SpVec;
585      for (int DocC = 0; DocC < DocN; DocC++) {
586          int DId = DIdV[DocC];
587          double DocParam = BowDocBs->IsCatInDoc(DId, CatId) ? 1.0 : -1.0;
588          TStr DocStr = BowDocBs->GetDocStr(DId);
589          Set->AddAttrV(DocStr, DocParam);
590      }
591      return Set;
592  }
593  PSVMTrainSet TBowDocBs2TrainSet::NewBowAllCatV(PBowDocWgtBs BowDocWgtBs,
594          const TIntV& AllDIdV, const TIntV& CatDIdV) {
595      int DocN = AllDIdV.Len();
596      PSVMTrainSet docs = TBowTrainSet::New(DocN);
597      for (int DocC = 0; DocC < DocN; DocC++) {
598          int DId = AllDIdV[DocC];
599          double param = CatDIdV.SearchBin(DId) == -1 ? -1.0 : 1.0;
600          PBowSpV SpV = BowDocWgtBs->GetSpV(DId);
601          docs->AddAttrV(DId, SpV, param);
602      }
603      return docs;
604  }
605  PSVMTrainSet TBowDocBs2TrainSet::NewSparseAllCatV(PBowDocWgtBs BowDocWgtBs,
606          const TIntV& AllDIdV, const TIntV& CatDIdV) {
607      int DocN = AllDIdV.Len();
608      PSVMTrainSet Set = TSparseTrainSet::New(DocN); TIntFltKdV SpVec;
609      for (int DocC = 0; DocC < DocN; DocC++) {
610          int DId = AllDIdV[DocC];
611          double param = CatDIdV.SearchBin(DId) == -1 ? -1.0 : 1.0;
612          MakeSpVec(BowDocWgtBs->GetSpV(DId), SpVec);
613          Set->AddAttrV(SpVec, param, false);
614      }
615      return Set;
616  }
617  PSVMTrainSet TBowDocBs2TrainSet::NewBowFromCat(const PBowDocBs& BowDocBs,
618          PBowDocWgtBs BowDocWgtBs, const TIntV& AllDIdV) {
619      Fail; return NULL;
620  }
621  PSVMTrainSet TBowDocBs2TrainSet::NewSparseFromCat(const PBowDocBs& BowDocBs,
622          PBowDocWgtBs BowDocWgtBs, const TIntV& AllDIdV) {
623      Fail; return NULL;
624  }
625  PSVMTrainSet TBowDocBs2TrainSet::NewBow(PBowDocPart BowDocPart) {
626      int Clusts = BowDocPart->GetClusts();
627      PSVMTrainSet Set = TBowTrainSet::New(Clusts);
628      for (int ClustN = 0; ClustN < Clusts; ClustN++) {
629          IAssert(BowDocPart->GetClust(ClustN)->IsConceptSpV());
630          Set->AddAttrV(ClustN, BowDocPart->GetClust(ClustN)->GetConceptSpV(), 1.0);
631      }
632      return Set;
633  }
634  PSVMTrainSet TBowDocBs2TrainSet::NewSparse(PBowDocPart BowDocPart) {
635      int Clusts = BowDocPart->GetClusts();
636      PSVMTrainSet Set = TSparseTrainSet::New(Clusts); TIntFltKdV SpVec;
637      for (int ClustN = 0; ClustN < Clusts; ClustN++) {
638          IAssert(BowDocPart->GetClust(ClustN)->IsConceptSpV());
639          MakeSpVec(BowDocPart->GetClust(ClustN)->GetConceptSpV(), SpVec);
640          Set->AddAttrV(SpVec, 1.0, false);
641      }
642      return Set;
643  }
644  PSVMModel TSVMModel::MakeModel(const bool& Linear,
645          const PKernel& ker, const PSVMTrainSet& TrainSet,
646          const TIntV& SubSet, const TSVMModelParam& ModelParam,
647          const TSVMLearnParam& LearnParam) {
648      PSVMModel Model = TSVMModel::New();
649      Model->Linear = Linear;
650      TIntV DIdV; int Len;
651      if (SubSet.Len() != 0) {
652          TSVMFactory::train(Model->AlphaV, Model->Thresh.Val, Linear, ker,
653              TSVMTrainSubSet::New(TrainSet(), SubSet), ModelParam, LearnParam);
654          DIdV = SubSet; Len = SubSet.Len();
655      } else {
656          TSVMFactory::train(Model->AlphaV, Model->Thresh.Val,
657              Linear, ker, TrainSet(), ModelParam, LearnParam);
658          Len = TrainSet->Len(); DIdV.Gen(Len);
659          for (int i = 0; i < Len; i++) { DIdV[i] = i; }
660      }
661      if (ModelParam.ModelType == smtClassifier) {
662          for (int i = 0; i < Len; i++) {
663              Model->AlphaV[i] = TrainSet->GetVecParam(DIdV[i]) * Model->AlphaV[i];
664          }
665      } else if (ModelParam.ModelType == smtRegression) {
666          IAssert(Model->AlphaV.Len() == 2*Len);
667          for (int i = 0; i < Len; i++) {
668              Model->AlphaV[i] = Model->AlphaV[i+Len] - Model->AlphaV[i];
669          }
670          Model->AlphaV.Trunc(Len);
671          Model->Thresh = -1.0 * Model->Thresh;
672      }
673      if (Linear) {
674          TrainSet->LinComb(DIdV, Model->AlphaV, Model->WgtV);
675      } else {
676          if (TrainSet->Type() != ststSimMatrix) {
677              TFltV NewAlphaV; TIntV VecIdV;
678              for (int VecN = 0; VecN < Len; VecN++) {
679                  if (TFlt::Abs(Model->AlphaV[VecN]) > EPSILON) {
680                      NewAlphaV.Add(Model->AlphaV[VecN]);
681                      VecIdV.Add(DIdV[VecN]);
682                  }
683              }
684              Model->AlphaV = NewAlphaV; 
685              Model->SupVecs = TrainSet->Clone(VecIdV);
686          } else {
687              TFltV NewAlphaV(TrainSet->Len()); NewAlphaV.PutAll(0.0);
688              for (int VecN = 0; VecN < Len; VecN++) {
689                  NewAlphaV[DIdV[VecN]] = Model->AlphaV[VecN];
690              }
691              Model->AlphaV = NewAlphaV; 
692              Model->SupVecs = TrainSet;
693          }
694          Model->Kernel = ker;
695      }
696      Model->AlphaV.Pack();
697      return Model;
698  }
699  TCfyRes TSVMModel::CrossValidation(const int& Folds, const int&Seed, const bool& Linear,
700          const PKernel& ker, const PSVMTrainSet& TrainSet, const TIntV& SubSet,
701          const TSVMModelParam& ModelParam, const TSVMLearnParam& LearnParam) {
702      TIntV DIdV; TCrossValid::PrepareSubDIdV(SubSet, TrainSet->Len(), DIdV);
703      TVec<TIntV> DIdVFoldV; TCrossValid::PrepareFolds(Folds, DIdV, Seed, DIdVFoldV);
704      TIntV TrainSubDIdV, TestSubDIdV; TCfyRes CfyRes;
705      double MarginSum = 0.0;
706      for (int FoldN = 0; FoldN < Folds; FoldN++) {
707          printf("%d.. ", FoldN);
708          TCrossValid::PrepareSplit(FoldN, DIdVFoldV, TrainSubDIdV, TestSubDIdV);
709          if (ModelParam.ModelType == smtOneClass) {
710              TIntV PosTrainSubDIdV;
711              for (int DIdN = 0; DIdN < TrainSubDIdV.Len(); DIdN++) {
712                  const int DId = TrainSubDIdV[DIdN];
713                  if (TrainSet->GetVecParam(DId) > 0.0) {
714                      PosTrainSubDIdV.Add(DId);
715                  }
716              }
717              TrainSubDIdV = PosTrainSubDIdV;
718          }
719          PSVMModel FoldModel = MakeModel(Linear, ker,
720              TrainSet, TrainSubDIdV, ModelParam, LearnParam);
721          TCfyRes FoldCfyRes = FoldModel->Test(TrainSet, TestSubDIdV);
722          MarginSum += FoldModel->GetMargin();
723          CfyRes.Add(FoldCfyRes);
724      } printf("\n");
725      CfyRes.Def();
726      CfyRes.AddStat("AvgMargin", MarginSum / Folds);
727      return CfyRes;
728  }
729  TSVMModel::TSVMModel(TSIn& SIn) {
730      AlphaV.Load(SIn);
731      Thresh.Load(SIn);
732      Linear.Load(SIn);
733      if (Linear) {
734          WgtV.Load(SIn);
735      } else {
736          SupVecs = TSVMTrainSet::Load(SIn);
737          Kernel = TKernel::Load(SIn);
738      }
<span onclick='openModal()' class='match'>739  }
740  void TSVMModel::Save(TSOut& SOut) {
741      AlphaV.Save(SOut);
742      Thresh.Save(SOut);
743      Linear.Save(SOut);
744      if (Linear) {
745          WgtV.Save(SOut);
746      } else {
747          SupVecs->Save(SOut);
748          Kernel->Save(SOut);
749      }
750  }
</span>751  double TSVMModel::GetRes(const TIntFltKdV& Vec) const {
752      double Result = Thresh;
753      if (Linear) {
754          Result += TLinAlg::DotProduct(WgtV, Vec);
755      } else {
756          IAssert(!SupVecs.Empty() && ! Kernel.Empty());
757          IAssert(SupVecs->Len() == AlphaV.Len());
758          const double Norm2 = TLinAlg::Norm2(Vec);
759          for (int i = 0; i < AlphaV.Len(); i++) {
760              Result += AlphaV[i] * Kernel->Calc(
761                  SupVecs->DotProduct(i, Vec),
762                  Norm2, SupVecs->GetNorm2(i));
763          }
764      }
765      return Result;
766  }
767  double TSVMModel::GetRes(const TFltV& Vec) const {
768      double Result = Thresh;
769      if (Linear) {
770          Result += TLinAlg::DotProduct(WgtV, Vec);
771      } else {
772          IAssert(!SupVecs.Empty() && ! Kernel.Empty());
773          IAssert(SupVecs->Len() == AlphaV.Len());
774          const double Norm2 = TLinAlg::Norm2(Vec);
775          for (int i = 0; i < AlphaV.Len(); i++) {
776              Result += AlphaV[i] * Kernel->Calc(
777                  SupVecs->DotProduct(i, Vec),
778                  Norm2, SupVecs->GetNorm2(i));
779          }
780      }
781      return Result;
782  }
783  double TSVMModel::GetRes(const TStr& Vec) const {
784      IAssert(!Linear); 
785      IAssert(!SupVecs.Empty() && ! Kernel.Empty());
786      IAssert(SupVecs->Len() == AlphaV.Len());
787      IAssert(SupVecs->Type() == ststString);
788      double Result = Thresh;
789      const double Norm2 = 1.0; 
790      for (int i = 0; i < AlphaV.Len(); i++) {
791          Result += AlphaV[i] * Kernel->Calc(
792              SupVecs->DotProduct(i, Vec),
793              Norm2, SupVecs->GetNorm2(i));
794      }
795      return Result;
796  }
797  double TSVMModel::GetRes(const TIntV& Vec) const {
798      IAssert(!Linear); 
799      IAssert(!SupVecs.Empty() && ! Kernel.Empty());
800      IAssert(SupVecs->Len() == AlphaV.Len());
801      IAssert(SupVecs->Type() == ststString);
802      double Result = Thresh;
803      const double Norm2 = 1.0; 
804      for (int i = 0; i < AlphaV.Len(); i++) {
805          Result += AlphaV[i] * Kernel->Calc(
806              SupVecs->DotProduct(i, Vec),
807              Norm2, SupVecs->GetNorm2(i));
808      }
809      return Result;
810  }
811  double TSVMModel::GetRes(PBowSpV Vec) const {
812      double Result = Thresh;
813      if (Linear) {
814          Result += TBowLinAlg::DotProduct(WgtV, Vec);
815      } else {
816          IAssert(!SupVecs.Empty() && ! Kernel.Empty());
817          IAssert(SupVecs->Len() == AlphaV.Len());
818          IAssert(SupVecs->Type() == ststBow);
819          const double Norm2 = TMath::Sqr(Vec->GetNorm());
820          for (int i = 0; i < AlphaV.Len(); i++) {
821              Result += AlphaV[i] * Kernel->Calc(
822                  SupVecs->DotProduct(i, Vec),
823                  Norm2, SupVecs->GetNorm2(i));
824          }
825      }
826      return Result;
827  }
828  double TSVMModel::GetRes(const int& VecId) const {
829      IAssert(!Linear); 
830      IAssert(!SupVecs.Empty() && ! Kernel.Empty());
831      IAssert(SupVecs->Len() == AlphaV.Len());
832      IAssert(0 <= VecId && VecId < AlphaV.Len());
833      IAssert(SupVecs->Type() == ststSimMatrix);
834      double Result = Thresh;
835      const double Norm2 = SupVecs->GetNorm2(VecId);
836      for (int i = 0; i < AlphaV.Len(); i++) {
837          Result += AlphaV[i] * Kernel->Calc(
838              SupVecs->DotProduct(i, VecId),
839              Norm2, SupVecs->GetNorm2(i));
840      }
841      return Result;
842  }
843  TCfyRes TSVMModel::Test(const PSVMTrainSet& TestSet, const TIntV& SubSet) const {
844      TIntV DIdV; TCrossValid::PrepareSubDIdV(SubSet, TestSet->Len(), DIdV);
845      int Len = DIdV.Len(); TCountCfyRes Result;
846      for (int DocC = 0; DocC < Len; DocC++) {
847          if (TestSet->Type() == ststSparse) {
848              Result.Add(GetRes(TestSet->GetAttrSparseV(DIdV[DocC])),
849                  TestSet->GetVecParam(DIdV[DocC]));
850          } else if (TestSet->Type() == ststDense) {
851              Result.Add(GetRes(TestSet->GetAttrDenseV(DIdV[DocC])),
852                  TestSet->GetVecParam(DIdV[DocC]));
853          } else if (TestSet->Type() == ststBow) {
854              Result.Add(GetRes(TestSet->GetAttrBowV(DIdV[DocC])),
855                  TestSet->GetVecParam(DIdV[DocC]));
856          } else if (TestSet->Type() == ststString) {
857              Result.Add(GetRes(TestSet->GetAttrStringV(DIdV[DocC])),
858                  TestSet->GetVecParam(DIdV[DocC]));
859          } else if (TestSet->Type() == ststSimMatrix) {
860              Result.Add(GetRes(DIdV[DocC]), TestSet->GetVecParam(DIdV[DocC]));
861          }
862      }
863      return Result.ToTCfyRes();
864  }
865  void TSVMModel::MakeProb(const PSVMTrainSet& TrainSet, const TIntV& SubSet) {
866      TIntV DIdV; TCrossValid::PrepareSubDIdV(SubSet, TrainSet->Len(), DIdV);
867      int Docs = DIdV.Len();
868      TFltIntKdV DistParamV(Docs, 0);
869      for (int DocC = 0; DocC < Docs; DocC++) {
870          double DistToHyperplane = 0.0;
871          if (TrainSet->Type() == ststSparse) {
872              DistToHyperplane = GetRes(TrainSet->GetAttrSparseV(DIdV[DocC]));
873          } else if (TrainSet->Type() == ststDense) {
874              DistToHyperplane = GetRes(TrainSet->GetAttrDenseV(DIdV[DocC]));
875          } else if (TrainSet->Type() == ststBow) {
876              DistToHyperplane = GetRes(TrainSet->GetAttrBowV(DIdV[DocC]));
877          } else if (TrainSet->Type() == ststString) {
878              DistToHyperplane = GetRes(TrainSet->GetAttrStringV(DIdV[DocC]));
879          } else if (TrainSet->Type() == ststSimMatrix) {
880              DistToHyperplane = GetRes(DIdV[DocC]);
881          }
882          DistParamV.Add(TFltIntKd(DistToHyperplane,
883              TFlt::Round(TrainSet->GetVecParam(DIdV[DocC]))));
884      }
885      Sigmoid = TSigmoid(DistParamV);
886      IsSigDef = true;
887  }
888  double TSVMModel::GetMargin() const {
889      if (IsLinear()) {
890          const double WgtNorm = TLinAlg::Norm(WgtV);
891          if (WgtNorm > 0.0) { return 1.0 / WgtNorm; }
892          else { return 0.0; }
893      } else {
894          double WgtNorm2 = 0.0;
895          for (int i = 0; i < AlphaV.Len(); i++) {
896              for (int j = 0; j < AlphaV.Len(); j++) {
897                  WgtNorm2 += AlphaV[i]*AlphaV[j] * Kernel->CalcSet(SupVecs, i, j);
898              }
899          }
900          if (WgtNorm2 > 0.0) { return 1.0 / sqrt(WgtNorm2); }
901          else { return 0.0; }
902      }
903  }
904  bool TBowSVMMd::IsReg=TBowSVMMd::MkReg();
905  TBowSVMMd::TBowSVMMd(TSIn& SIn): TBowMd(SIn) {
906      CatNm.Load(SIn);
907      Model = TSVMModel::Load(SIn);
908  }
909  void TBowSVMMd::Save(TSOut &SOut) {
910      TBowMd::Save(SOut);
911      CatNm.Save(SOut);
912      Model->Save(SOut);
913  }
914  void TBowSVMMd::GetLinComb(
915   const PBowDocBs& BowDocBs, TFltStrPrV& WgtStrPrV, double& Tsh) const {
916    IAssert(IsLinComb());
917    TFltV WgtV; Model->GetWgtV(WgtV);
918    for (int WordId=0; WordId<WgtV.Len(); WordId++){
919      if (WgtV[WordId]!=0.0){
920        if (BowDocBs.Empty()){
921          WgtStrPrV.Add(TFltStrPr(WgtV[WordId], TInt::GetStr(WordId)));
922        } else {
923          TStr Str=BowDocBs->GetWordStr(WordId);
924          WgtStrPrV.Add(TFltStrPr(WgtV[WordId], Str));
925        }
926      }
927    }
928    Tsh=Model->GetThresh();
929  }
930  PSVMTrainSet TBowSVMMd::PrepareClsTrainSet(PBowDocBs BowDocBs,
931          PBowDocWgtBs BowDocWgtBs, const TStr& CatNm, const TIntV& TrainDIdV,
932          const double& SampleNegP) {
933      IAssertR(BowDocBs->IsCatNm(CatNm), CatNm);
934      const int CId = BowDocBs->GetCId(CatNm);
935      return TBowDocBs2TrainSet::NewBowAllCat(BowDocBs,
936          BowDocWgtBs, CId, TrainDIdV, SampleNegP);
937  }
938  PSVMTrainSet TBowSVMMd::PrepareOneClassTrainSet(PBowDocBs BowDocBs,
939          PBowDocWgtBs BowDocWgtBs, const TStr& CatNm, const TIntV& TrainDIdV) {
940      IAssertR(BowDocBs->IsCatNm(CatNm), CatNm);
941      const int CId = BowDocBs->GetCId(CatNm);
942      return TBowDocBs2TrainSet::NewBowOneCat(BowDocBs, BowDocWgtBs, CId, TrainDIdV);
943  }
944  inline PSVMTrainSet TBowSVMMd::PrepareClsTrainSet(PBowDocBs BowDocBs,
945          PBowDocWgtBs BowDocWgtBs, const TIntV& AllDIdV, const TIntV& CatDIdV) {
946      return TBowDocBs2TrainSet::NewSparseAllCatV(BowDocWgtBs, AllDIdV, CatDIdV);
947  }
948  PBowSpV TBowSVMMd::GetKeywords(const PSVMTrainSet& TrainSet,
949          const PSVMModel& SVMModel, const int WdN,
950          const double& VecSign, const double& WgtSign, const bool& AvgOverSet) {
951      TFltV NormalV; SVMModel->GetWgtV(NormalV);
952      TIntFltKdV WIdWgtKdV;
953      TrainSet->GetKeywords(NormalV, WIdWgtKdV,
954          TIntV(), WdN, VecSign, WgtSign, AvgOverSet);
955      PBowSpV BowSpV = TBowSpV::New(-1, WIdWgtKdV.Len());
956      for (int WdN = 0; WdN < WIdWgtKdV.Len(); WdN++) {
957          BowSpV->AddWIdWgt(WIdWgtKdV[WdN].Key, WIdWgtKdV[WdN].Dat);
958      }
959      return BowSpV;
960  }
961  inline void TBowSVMMd::GetCfy(const PBowSpV& QueryBowSpV, TFltStrPrV& WgtCatNmPrV) {
962      WgtCatNmPrV = TFltStrPrV::GetV(TFltStrPr(Model->IsProb() ?
963          Model->GetProbCfy(QueryBowSpV) : Model->GetRes(QueryBowSpV), CatNm));
964  }
965  TCfyRes TBowSVMMd::Test(PBowMd BowMd, PBowDocBs BowDocBs,
966          PBowDocWgtBs BowDocWgtBs, const TIntV& DIdV, const TStr& CatNm) {
967      TCountCfyRes Result; TFltStrPrV ResV;
968      IAssertR(BowDocBs->IsCatNm(CatNm), CatNm);
969      const int CId = BowDocBs->GetCId(CatNm);
970      for (int VecC = 0, VecN = DIdV.Len(); VecC < VecN; VecC++) {
971          PBowSpV DocSpV = BowDocWgtBs->GetSpV(DIdV[VecC]);
972          ResV.Clr(); BowMd->GetCfy(DocSpV, ResV);
973          double PredCls = ResV.Len() > 0 ? ResV[0].Val1() : -1.0;
974          double TrueCls = BowDocBs->IsCatInDoc(DIdV[VecC], CId) ? 1.0 : -1.0;
975          Result.Add(PredCls, TrueCls);
976      }
977      return Result.ToTCfyRes();
978  }
979  void TBowSVMMd::SaveTxt(const TStr& FNm, const PBowDocBs& BowDocBs,
980          const PBowDocWgtBs& BowDocWgtBs) {
981      PSOut SOut = TFOut::New(FNm);
982      TIntV DIdV; BowDocBs->GetAllDIdV(DIdV);
983      TCfyRes Res = Test(this, BowDocBs, BowDocWgtBs, DIdV, this->GetCatNm());
984      Res.PrStat("Results on the training data", SOut);
985      SOut->PutLn();
986  }
987  PBowMd TBowSVMMd::NewClsLinear(const PBowDocBs& BowDocBs, PBowDocWgtBs BowDocWgtBs,
988          const TStr& CatNm, const TIntV& TrainDIdV, const double& C, const double& j,
989          const bool& ProbabilisticP, const TSVMLearnParam& LearnParam) {
990      PSVMTrainSet TrainSet = PrepareClsTrainSet(BowDocBs, BowDocWgtBs, CatNm, TrainDIdV);
991      PSVMModel Model = TSVMModel::NewClsLinear(TrainSet, C, j, TIntV(), LearnParam);
992      if (ProbabilisticP) Model->MakeProb(TrainSet);
993      return TBowSVMMd::New(BowDocBs, CatNm, Model);
994  }
995  PBowMd TBowSVMMd::NewClsLinear(const PBowDocBs& BowDocBs, PBowDocWgtBs BowDocWgtBs,
996          const TIntV& TrainDIdV, const TIntV& CatDIdV, const double& C, const double& j,
997          const bool& ProbabilisticP, const TSVMLearnParam& LearnParam) {
998      PSVMTrainSet TrainSet = PrepareClsTrainSet(BowDocBs, BowDocWgtBs, TrainDIdV, CatDIdV);
999      PSVMModel Model = TSVMModel::NewClsLinear(TrainSet, C, j, TIntV(), LearnParam);
1000      if (ProbabilisticP) Model->MakeProb(TrainSet);
1001      return TBowSVMMd::New(BowDocBs, "unknown", Model);
1002  }
1003  PBowMd TBowSVMMd::NewCls(const PKernel& ker, const PBowDocBs& BowDocBs,
1004          PBowDocWgtBs BowDocWgtBs, const TStr& CatNm, const TIntV& TrainDIdV,
1005          const double& C, const double& j, const bool& ProbabilisticP,
1006          const TSVMLearnParam& LearnParam) {
1007      PSVMTrainSet TrainSet = PrepareClsTrainSet(BowDocBs, BowDocWgtBs, CatNm, TrainDIdV);
1008      PSVMModel Model = TSVMModel::NewCls(TrainSet, ker, C, j, TIntV(), LearnParam);
1009      if (ProbabilisticP) Model->MakeProb(TrainSet);
1010      return TBowSVMMd::New(BowDocBs, CatNm, Model);
1011  }
1012  TCfyRes TBowSVMMd::CrossValidClsLinear(const int& Folds, const int&Seed,
1013          const PBowDocBs& BowDocBs, PBowDocWgtBs BowDocWgtBs, const TStr& CatNm,
1014          const TIntV& TrainDIdV, const double& C, const double& j,
1015          const TSVMLearnParam& LearnParam) {
1016      PSVMTrainSet TrainSet = PrepareClsTrainSet(BowDocBs, BowDocWgtBs, CatNm, TrainDIdV);
1017      return TSVMModel::CrossValidClsLinear(Folds, Seed, TrainSet, C, j, TIntV(), LearnParam);
1018  }
1019  TCfyRes TBowSVMMd::CrossValidClsLinear(const int& Folds, const int&Seed,
1020          const PBowDocBs& BowDocBs, PBowDocWgtBs BowDocWgtBs, const TIntV& TrainDIdV,
1021          const TIntV& CatDIdV, const double& C, const double& j,
1022          const TSVMLearnParam& LearnParam) {
1023      PSVMTrainSet TrainSet = PrepareClsTrainSet(BowDocBs, BowDocWgtBs, TrainDIdV, CatDIdV);
1024      return TSVMModel::CrossValidClsLinear(Folds, Seed, TrainSet, C, j, TIntV(), LearnParam);
1025  }
1026  TCfyRes TBowSVMMd::CrossValidCls(const int& Folds, const int&Seed,
1027          const PKernel& ker, const PBowDocBs& BowDocBs, PBowDocWgtBs BowDocWgtBs,
1028          const TStr& CatNm, const TIntV& TrainDIdV, const double& C,
1029          const double& j, const TSVMLearnParam& LearnParam) {
1030      PSVMTrainSet TrainSet = PrepareClsTrainSet(BowDocBs, BowDocWgtBs, CatNm, TrainDIdV);
1031      return TSVMModel::CrossValidCls(Folds, Seed, TrainSet, ker, C, j, TIntV(), LearnParam);
1032  }
1033  PBowMd TBowSVMMd::NewMultiClsLinear(const PBowDocBs& BowDocBs, PBowDocWgtBs BowDocWgtBs,
1034          const TIntV& TrainDIdV, const double& C, const double& j,
1035          const bool& SampleNegP, const TSVMLearnParam& LearnParam) {
1036      const int Cats = BowDocBs->GetCats(); TBowMdV BowMdV(Cats, 0);
1037      for (int CatN = 0; CatN < Cats; CatN++) {
1038          const TStr& CatNm = BowDocBs->GetCatNm(CatN);
1039          PSVMTrainSet TrainSet = PrepareClsTrainSet(BowDocBs,
1040              BowDocWgtBs, CatNm, TrainDIdV, (SampleNegP ? j : -1.0));
1041          printf("(%4d/ %4d (Docs: %9d\r) ", CatN+1, Cats, TrainSet->Len());
1042          PSVMModel Model = TSVMModel::NewClsLinear(
1043              TrainSet, C, j, TIntV(), LearnParam);
1044          Model->MakeProb(TrainSet);
1045          BowMdV.Add(TBowSVMMd::New(BowDocBs, CatNm, Model));
1046      } printf("\n");
1047      return new TBowMultiMd(BowDocBs, BowMdV);
1048  }
1049  TCfyRes TBowSVMMd::CrossValidMultiClsLinear(const int& Folds, const int& Seed,
1050          const PBowDocBs& BowDocBs, PBowDocWgtBs BowDocWgtBs, const double& C,
1051          const double& j, const bool& SampleNegP, const TSVMLearnParam& LearnParam) {
1052      TIntV AllDIdV; BowDocBs->GetAllDIdV(AllDIdV); AllDIdV.Sort();
1053      TIntPrV CIdDIdV; const int DIds = AllDIdV.Len();
1054      for (int DIdN = 0; DIdN < DIds; DIdN++) {
1055          const int DId = AllDIdV[DIdN];
1056          const int CIds = BowDocBs->GetDocCIds(DId);
1057          for (int CIdN = 0; CIdN < CIds; CIdN++) {
1058              const int CId = BowDocBs->GetDocCId(DId, CIdN);
1059              CIdDIdV.Add(TIntPr(CId, DId));
1060          }
1061      }
1062      CIdDIdV.Sort();
1063      TVec<TIntV> FoldV(Folds); int FoldN = 0;
1064      for (int CIdDIdN = 0; CIdDIdN < CIdDIdV.Len(); CIdDIdN++) {
1065          const int DId = CIdDIdV[CIdDIdN].Val2;
1066          FoldV[FoldN].Add(DId);
1067          FoldN++;
1068          if (FoldN >= Folds) { FoldN = 0; }
1069      }
1070      for (int FoldN = 0; FoldN < Folds; FoldN++) { FoldV[FoldN].Sort(); }
1071      const int Cats = BowDocBs->GetCats(); TBowMdV BowMdV(Cats, 0);
1072      TVec<TCountCfyRes> CatCfyResV(Cats);
1073      for (int FoldN = 0; FoldN < Folds; FoldN++) {
1074          printf("Fold %d ...\n", FoldN+1);
1075          TIntV TestDIdV = FoldV[FoldN];
1076          TIntV TrainDIdV; AllDIdV.Minus(TestDIdV, TrainDIdV);
1077          PBowMd FoldBowMd = TBowSVMMd::NewMultiClsLinear(BowDocBs,
1078              BowDocWgtBs, TrainDIdV, C, j, SampleNegP, LearnParam);
1079          for (int TestDIdN = 0; TestDIdN < TestDIdV.Len(); TestDIdN++) {
1080              const int TestDId = TestDIdV[TestDIdN];
1081              TFltStrPrV WgtCatNmV;
1082              FoldBowMd->GetCfy(BowDocWgtBs->GetSpV(TestDId), WgtCatNmV);
1083              TIntH PredCIdH;
1084              if (!WgtCatNmV.Empty()) {
1085                  PredCIdH.AddKey(BowDocBs->GetCId(WgtCatNmV[0].Val2)); }
1086              const int CIds = BowDocBs->GetDocCIds(TestDId);
1087              for (int CIdN = 0; CIdN < CIds; CIdN++) {
1088                  const int CId = BowDocBs->GetDocCId(TestDId, CIdN);
1089                  if (PredCIdH.IsKey(CId)) {
1090                      CatCfyResV[CId].Add(1.0, 1.0);
1091                      PredCIdH.DelKey(CId);
1092                  } else {
1093                      CatCfyResV[CId].Add(-1.0, 1.0);
1094                  }
1095              }
1096              if (!PredCIdH.Empty()) {
1097                  int KeyId = PredCIdH.FFirstKeyId();
1098                  while (PredCIdH.FNextKeyId(KeyId)) {
1099                      const int CId = PredCIdH.GetKey(KeyId);
1100                      CatCfyResV[CId].Add(1.0, -1.0);
1101                  }
1102              }
1103          }
1104      }
1105      return TCountCfyRes::ToMacroTCfyRes(CatCfyResV);
1106  }
1107  PBowMd TBowSVMMd::NewOneClassLinear(const PBowDocBs& BowDocBs,
1108          PBowDocWgtBs BowDocWgtBs, const TStr& CatNm, const TIntV& TrainDIdV,
1109          const double& nu, const TSVMLearnParam& LearnParam) {
1110      PSVMTrainSet TrainSet = PrepareOneClassTrainSet(BowDocBs, BowDocWgtBs, CatNm, TrainDIdV);
1111      PSVMModel Model = TSVMModel::NewOneClassLinear(TrainSet, nu, TIntV(), LearnParam);
1112      return TBowSVMMd::New(BowDocBs, CatNm, Model);
1113  }
1114  PBowMd TBowSVMMd::NewOneClass(const PKernel& ker, const PBowDocBs& BowDocBs,
1115          PBowDocWgtBs BowDocWgtBs, const TStr& CatNm, const TIntV& TrainDIdV,
1116          const double& nu, const TSVMLearnParam& LearnParam) {
1117      PSVMTrainSet TrainSet = PrepareOneClassTrainSet(BowDocBs, BowDocWgtBs, CatNm, TrainDIdV);
1118      PSVMModel Model = TSVMModel::NewOneClass(TrainSet, ker, nu, TIntV(), LearnParam);
1119      return TBowSVMMd::New(BowDocBs, CatNm, Model);
1120  }
1121  TCfyRes TBowSVMMd::CrossValidOneClassLinear(const int& Folds, const int&Seed,
1122          const PBowDocBs& BowDocBs, PBowDocWgtBs BowDocWgtBs, const TStr& CatNm,
1123          const TIntV& TrainDIdV, const double& nu, const TSVMLearnParam& LearnParam) {
1124      PSVMTrainSet TrainSet = PrepareClsTrainSet(BowDocBs, BowDocWgtBs, CatNm, TrainDIdV);
1125      return TSVMModel::CrossValidOneClassLinear(Folds, Seed, TrainSet, nu, TIntV(), LearnParam);
1126  }
1127  TCfyRes TBowSVMMd::CrossValidOneClass(const int& Folds, const int&Seed,
1128          const PKernel& ker, const PBowDocBs& BowDocBs, PBowDocWgtBs BowDocWgtBs,
1129          const TStr& CatNm, const TIntV& TrainDIdV, const double& nu,
1130          const TSVMLearnParam& LearnParam) {
1131      PSVMTrainSet TrainSet = PrepareClsTrainSet(BowDocBs, BowDocWgtBs, CatNm, TrainDIdV);
1132      return TSVMModel::CrossValidOneClass(Folds, Seed, TrainSet, ker, nu, TIntV(), LearnParam);
1133  }
1134  PBowSpV TBowSVMMd::GetKeywords(const PBowDocBs& BowDocBs, const TIntV& TrainDIdV,
1135          const TIntV& CatDIdV, const int WdN, const double& C, const double& j,
1136          const int& Time, const TBowWordWgtType& SvmWordWgtType, const double& VecSign,
1137          const double& WgtSign, const bool& AvgOverSet) {
1138      PBowDocWgtBs BowDocWgtBs = TBowDocWgtBs::New(BowDocBs, SvmWordWgtType);
1139      PSVMTrainSet TrainSet = PrepareClsTrainSet(BowDocBs, BowDocWgtBs, TrainDIdV, CatDIdV);
1140      PSVMModel Model = TSVMModel::NewClsLinear(TrainSet, C, j, TIntV(), TSVMLearnParam::Lin(Time));
1141      return GetKeywords(TrainSet, Model, WdN, VecSign, WgtSign, AvgOverSet);
1142  }
1143  PBowSpV TBowSVMMd::GetKeywords(const PBowDocBs& BowDocBs, PBowDocWgtBs BowDocWgtBs,
1144          const TIntV& TrainDIdV, const TIntV& CatDIdV, const int WdN, const double& C,
1145          const double& j, const int& Time, const double& VecSign, const double& WgtSign,
1146          const bool& AvgOverSet) {
1147      PSVMTrainSet TrainSet = PrepareClsTrainSet(BowDocBs, BowDocWgtBs, TrainDIdV, CatDIdV);
1148      PSVMModel Model = TSVMModel::NewClsLinear(TrainSet, C, j, TIntV(), TSVMLearnParam::Lin(Time));
1149      return GetKeywords(TrainSet, Model, WdN, VecSign, WgtSign, AvgOverSet);
1150  }
1151  PBowSpV TBowSVMMd::GetKeywords(const PBowDocBs& BowDocBs, const TIntV& TrainDIdV,
1152          const TStr& CatNm, const int WdN, const double& C, const double& j,
1153          const int& Time, const TBowWordWgtType& SvmWordWgtType, const double& VecSign,
1154          const double& WgtSign, const bool& AvgOverSet) {
1155      PBowDocWgtBs BowDocWgtBs = TBowDocWgtBs::New(BowDocBs, SvmWordWgtType);
1156      PSVMTrainSet TrainSet = PrepareClsTrainSet(BowDocBs, BowDocWgtBs, CatNm, TrainDIdV);
1157      PSVMModel Model = TSVMModel::NewClsLinear(TrainSet, C, j, TIntV(), TSVMLearnParam::Lin(Time));
1158      return GetKeywords(TrainSet, Model, WdN, VecSign, WgtSign, AvgOverSet);
1159  }
1160  PBowSpV TBowSVMMd::GetKeywords(const PBowDocBs& BowDocBs, PBowDocWgtBs BowDocWgtBs,
1161          const TIntV& TrainDIdV, const TStr& CatNm, const int WdN, const double& C,
1162          const double& j, const int& Time, const double& VecSign, const double& WgtSign,
1163          const bool& AvgOverSet) {
1164      PSVMTrainSet TrainSet = PrepareClsTrainSet(BowDocBs, BowDocWgtBs, CatNm, TrainDIdV);
1165      PSVMModel Model = TSVMModel::NewClsLinear(TrainSet, C, j, TIntV(), TSVMLearnParam::Lin(Time));
1166      return GetKeywords(TrainSet, Model, WdN, VecSign, WgtSign, AvgOverSet);
1167  }
1168  void TSVMTrainSetCsv::TFtrGen::AddWds(const TStr& Prefix,
1169          const PBowDocBs& BowDocBs, int& Offset) const {
1170      const int Vals = GetVals();
1171      for (int ValN = 0; ValN < Vals; ValN++) {
1172          const int WId = BowDocBs->AddWordStr(
1173              TStr::Fmt("%s-%s", Prefix.CStr(), GetVal(ValN).CStr()));
1174          IAssert(Offset == WId); Offset++;
1175      }
1176  }
1177  TStr TSVMTrainSetCsv::TFtrGenNumeric::Type = "NUM";
1178  double TSVMTrainSetCsv::TFtrGenNumeric::Trans(const double& Val) const {
1179          return MnVal != MxVal ? (double(Val) - MnVal) / (MxVal - MnVal) : 0.0;
1180  }
1181  double TSVMTrainSetCsv::TFtrGenNumeric::GetFlt(const TStr& Str) const {
1182      double Val = 0.0;
1183      if (!Str.IsFlt(Val)) {
1184          TExcept::Throw(TStr::Fmt("Number expected  but '%s' found!", Str.CStr())); }
1185      return Val;
1186  }
1187  void TSVMTrainSetCsv::TFtrGenNumeric::Update(const TStr& Val) {
1188      double Flt = GetFlt(Val);
1189      MnVal = TFlt::GetMn(MnVal, Flt);
1190      MxVal = TFlt::GetMx(MxVal, Flt);
1191  }
1192  void TSVMTrainSetCsv::TFtrGenNumeric::Add(
1193          const TStr& Val, TIntFltKdV& SpV, int& Offset) const {
1194      double Flt = GetFlt(Val);
1195      SpV.Add(TIntFltKd(Offset, Trans(Flt)));
1196      Offset++;
1197  }
1198  TStr TSVMTrainSetCsv::TFtrGenNominal::Type = "NOM";
1199  void TSVMTrainSetCsv::TFtrGenNominal::Update(const TStr& Val) {
1200      if (!Val.Empty()) { ValH.AddKey(Val); }
1201  }
1202  void TSVMTrainSetCsv::TFtrGenNominal::Add(
1203          const TStr& Val, TIntFltKdV& SpV, int& Offset) const {
1204      if (ValH.IsKey(Val)) {
1205          SpV.Add(TIntFltKd(Offset + ValH.GetKeyId(Val), 1.0));
1206      }
1207      Offset += ValH.Len();
1208  }
1209  TStr TSVMTrainSetCsv::TFtrGenToken::Type = "TOK";
1210  void TSVMTrainSetCsv::TFtrGenToken::GetTokenV(
1211          const TStr& Str, TStrV& TokenStrV) const {
1212      THtmlLx HtmlLx(TStrIn::New(Str));
1213      while (HtmlLx.Sym != hsyEof){
1214          if (HtmlLx.Sym == hsyStr){
1215              TStr TokenStr = HtmlLx.UcChA;
1216              if (SwSet.Empty() || !SwSet->IsIn(TokenStr)) {
1217                  if (!Stemmer.Empty()) {
1218                      TokenStr = Stemmer->GetStem(TokenStr); }
1219                  TokenStrV.Add(TokenStr);
1220              }
1221          }
1222          HtmlLx.GetSym();
1223      }
1224  }
1225  void TSVMTrainSetCsv::TFtrGenToken::Update(const TStr& Val) {
1226      TStrV TokenStrV; GetTokenV(Val, TokenStrV);
1227      for (int TokenStrN = 0; TokenStrN < TokenStrV.Len(); TokenStrN++) {
1228          const TStr& TokenStr = TokenStrV[TokenStrN];
1229          TokenH.AddDat(TokenStr)++;
1230      }
1231      Docs++;
1232  }
1233  void TSVMTrainSetCsv::TFtrGenToken::Add(
1234          const TStr& Val, TIntFltKdV& SpV, int& Offset) const {
1235      TStrV TokenStrV; GetTokenV(Val, TokenStrV);
1236      TIntH TokenFqH;
1237      for (int TokenStrN = 0; TokenStrN < TokenStrV.Len(); TokenStrN++) {
1238          const TStr& TokenStr = TokenStrV[TokenStrN];
1239          if (TokenH.IsKey(TokenStr)) {
1240              const int TokenId = TokenH.GetKeyId(TokenStr);
1241              TokenFqH.AddDat(TokenId)++;
1242          }
1243      }
1244      TIntFltKdV ValSpV(TokenFqH.Len(), 0);
1245      int KeyId = TokenFqH.FFirstKeyId();
1246      while (TokenFqH.FNextKeyId(KeyId)) {
1247          const int TokenId = TokenFqH.GetKey(KeyId);
1248          const int TokenFq = TokenFqH[KeyId];
1249          const int TokenDocFq = TokenH[TokenId];
1250          const double IDF = log(double(Docs) / double(TokenDocFq));
1251          ValSpV.Add(TIntFltKd(TokenId, double(TokenFq) * IDF));
1252      }
1253      ValSpV.Sort(); TLinAlg::NormalizeL1(ValSpV);
1254      for (int ValSpN = 0; ValSpN < ValSpV.Len(); ValSpN++) {
1255          const int Key = ValSpV[ValSpN].Key + Offset;
1256          const double Dat = ValSpV[ValSpN].Dat;
1257          SpV.Add(TIntFltKd(Key, Dat));
1258      }
1259      Offset += TokenH.Len();
1260  }
1261  TStr TSVMTrainSetCsv::TFtrGenSparseNumeric::Type = "SP-NUM";
1262  void TSVMTrainSetCsv::TFtrGenSparseNumeric::Split(
1263          const TStr& Str, int& Id, TStr& Val) const {
1264      if (!Str.IsChIn(':')) { TExcept::Throw("Wrong sparse numeric '" + Str + "'!"); }
1265      TStr IdStr; Str.SplitOnCh(IdStr, ':', Val);
1266      if (!IdStr.IsInt(Id)) { TExcept::Throw("Wrong sparse numeric '" + Str + "'!"); }
1267  }
1268  void TSVMTrainSetCsv::TFtrGenSparseNumeric::Update(const TStr& Str) {
1269      TStrV EltV; Str.SplitOnAllCh(';', EltV);
1270      for (int EltN = 0; EltN < EltV.Len(); EltN++) {
1271          int Id; TStr Val; Split(EltV[EltN], Id, Val);
1272          MxId = TInt::GetMx(Id, MxId);
1273          FtrGen.Update(Val);
1274      }
1275  }
1276  void TSVMTrainSetCsv::TFtrGenSparseNumeric::Add(
1277          const TStr& Str, TIntFltKdV& SpV, int& Offset) const {
1278      TStrV EltV; Str.SplitOnAllCh(';', EltV); TIntH UsedIdH;
1279      for (int EltN = 0; EltN < EltV.Len(); EltN++) {
1280          int Id; TStr Val; Split(EltV[EltN], Id, Val);
1281          EAssertR(!UsedIdH.IsKey(Id), "Field ID repeated in '" + Str + "'!");
1282          int TmpOffset = Offset + Id;
1283          FtrGen.Add(Val, SpV, TmpOffset);
1284          UsedIdH.AddKey(Id);
1285      }
1286      Offset += GetVals();
1287  }
1288  TStr TSVMTrainSetCsv::TFtrGenSparseNumeric::GetVal(const int& ValN) const {
1289      const int FtrGenId = ValN / FtrGen.GetVals();
1290      const int FtrGenValN = ValN % FtrGen.GetVals();
1291      return TStr::Fmt("SP-%d-%d-%s", FtrGenId,
1292          FtrGenValN, FtrGen.GetVal(FtrGenValN).CStr());
1293  }
1294  TStr TSVMTrainSetCsv::TFtrGenMultiNom::Type = "MULTI-NOM";
1295  void TSVMTrainSetCsv::TFtrGenMultiNom::Update(const TStr& Str) {
1296      TStrV EltV; Str.SplitOnAllCh(';', EltV);
1297      for (int EltN = 0; EltN < EltV.Len(); EltN++) {
1298          FtrGen.Update(EltV[EltN]);
1299      }
1300  }
1301  void TSVMTrainSetCsv::TFtrGenMultiNom::Add(
1302          const TStr& Str, TIntFltKdV& SpV, int& Offset) const {
1303      TStrV EltV; Str.SplitOnAllCh(';', EltV);
1304      for (int EltN = 0; EltN < EltV.Len(); EltN++) {
1305          int TmpOffset = Offset;
1306          FtrGen.Add(EltV[EltN], SpV, TmpOffset);
1307      }
1308      Offset += GetVals();
1309  }
1310  TStr TSVMTrainSetCsv::TFtrGenMultiNom::GetVal(const int& ValN) const {
1311      return TStr::Fmt("MULTI-%d-%s", ValN, FtrGen.GetVal(ValN).CStr());
1312  }
1313  void TSVMTrainSetCsv::TFtrGenMultiNom::GetValV(const TStr& Str, TStrV& ValV) const {
1314      TStrV EltV; Str.SplitOnAllCh(';', EltV); ValV.Clr();
1315      for (int EltN = 0; EltN < EltV.Len(); EltN++) {
1316          const TStr& Val = EltV[EltN];
1317          TStrV SubValV; FtrGen.GetValV(Val, SubValV);
1318          ValV.AddV(SubValV);
1319      }
1320  }
1321  PBowDocBs TSVMTrainSetCsv::LoadCsv(TStr& FNm, const int& ClassId,
1322          const TIntV& IgnoreIdV, const int& TrainLen) {
1323      THash<TInt, PFtrGen> FtrGenH;
1324      PFtrGen ClassFtrGen;
1325      PSIn SIn = TFIn::New(FNm);
1326      char SsCh = ' '; TStrV FldValV;
1327      TSs::LoadTxtFldV(ssfCommaSep, SIn, SsCh, FldValV, false);
1328      for (int FldValN = 0; FldValN < FldValV.Len(); FldValN++) {
1329          const TStr& FldVal = FldValV[FldValN];
1330          if (FldValN == ClassId) {
1331              if (FldVal == "NOM") {
1332                  ClassFtrGen = TFtrGenNominal::New();
1333              } else if (FldVal == "MULTI-NOM") {
1334                  ClassFtrGen = TFtrGenMultiNom::New();
1335              } else {
1336                  TExcept::Throw("Wrong class type '" + FldVal + "', should be NOM or MULTI-NOM!");
1337              }
1338          } else if (!IgnoreIdV.IsIn(FldValN)) {
1339              if (FldVal == TFtrGenNumeric::Type) {
1340                  FtrGenH.AddDat(FldValN, TFtrGenNumeric::New());
1341              } else if (FldVal == TFtrGenNominal::Type) {
1342                  FtrGenH.AddDat(FldValN, TFtrGenNominal::New());
1343              } else if (FldVal == TFtrGenToken::Type) {
1344                  FtrGenH.AddDat(FldValN, TFtrGenToken::New(
1345                      TSwSet::New(swstNone), TStemmer::New(stmtNone)));
1346              } else if (FldVal == TFtrGenSparseNumeric::Type) {
1347                  FtrGenH.AddDat(FldValN, TFtrGenSparseNumeric::New());
1348              } else if (FldVal == TFtrGenMultiNom::Type) {
1349                  FtrGenH.AddDat(FldValN, TFtrGenMultiNom::New());
1350              } else {
1351                  TExcept::Throw("Wrong type '" + FldVal + "'!");
1352              }
1353          }
1354      }
1355      const int Flds = FldValV.Len();
1356      int Recs = 0;
1357      while (!SIn->Eof()) {
1358          if (Recs == TrainLen) { break; }
1359          Recs++; printf("%7d\r", Recs);
1360          TSs::LoadTxtFldV(ssfCommaSep, SIn, SsCh, FldValV, false);
1361          EAssertR(FldValV.Len() == Flds,
1362              TStr::Fmt("Wrong number of fields in line %d! Found %d and expected %d!",
1363              Recs + 1, FldValV.Len(), Flds));
1364          try {
1365              for (int FldValN = 0; FldValN < FldValV.Len(); FldValN++) {
1366                  const TStr& FldVal = FldValV[FldValN];
1367                  if (FldValN == ClassId) {
1368                      ClassFtrGen->Update(FldVal);
1369                  } else if (FtrGenH.IsKey(FldValN)) {
1370                      PFtrGen FtrGen = FtrGenH.GetDat(FldValN);
1371                      FtrGen->Update(FldVal);
1372                  }
1373              }
1374          } catch (PExcept Ex) {
1375              TExcept::Throw(TStr::Fmt("Error in line %d: '%s'!",
1376                  Recs+1, Ex->GetMsgStr().CStr()));
1377          }
1378      }
1379      PBowDocBs BowDocBs = TBowDocBs::New();
1380      int WdsOffset = 0;
1381      for (int FtrGenId = 0; FtrGenId < FtrGenH.Len(); FtrGenId++) {
1382          PFtrGen FtrGen = FtrGenH[FtrGenId];
1383          TStr Prefix = FtrGenH.GetKey(FtrGenId).GetStr();
1384          FtrGen->AddWds(Prefix, BowDocBs, WdsOffset);
1385      }
1386      SIn = TFIn::New(FNm); SsCh = ' ';
1387      TSs::LoadTxtFldV(ssfCommaSep, SIn, SsCh, FldValV, false);
1388      Recs = 0;
1389      while (!SIn->Eof()){
1390          Recs++; printf("%7d\r", Recs);
1391          TSs::LoadTxtFldV(ssfCommaSep, SIn, SsCh, FldValV, false);
1392          EAssertR(FldValV.Len() == Flds,
1393              TStr::Fmt("Wrong number of fields in line %s! Found %d and expected %d!",
1394              Recs + 1, FldValV.Len(), Flds));
1395          TIntFltKdV FtrSpV; TStrV CatNmV; int Offset = 0;
1396          try {
1397              for (int FldValN = 0; FldValN < FldValV.Len(); FldValN++) {
1398                  const TStr& FldVal = FldValV[FldValN];
1399                  if (FldValN == ClassId) {
1400                      ClassFtrGen->GetValV(FldVal, CatNmV);
1401                  } else if (FtrGenH.IsKey(FldValN)) {
1402                      PFtrGen FtrGen = FtrGenH.GetDat(FldValN);
1403                      FtrGen->Add(FldVal, FtrSpV, Offset);
1404                  }
1405              }
1406          } catch (PExcept Ex) {
1407              TExcept::Throw(TStr::Fmt("Error in line %d: '%s'!",
1408                  Recs+1, Ex->GetMsgStr().CStr()));
1409          }
1410          const int WIds = FtrSpV.Len();
1411          TIntFltPrV WIdWgtPrV(WIds, 0);
1412          for (int WIdN = 0; WIdN < WIds; WIdN++) {
1413              WIdWgtPrV.Add(TIntFltPr(FtrSpV[WIdN].Key, FtrSpV[WIdN].Dat));
1414          }
1415          BowDocBs->AddDoc(TStr::Fmt("Line-%d", Recs), CatNmV, WIdWgtPrV);
1416      }
1417      return BowDocBs;
1418  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-qt.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-svmmodels.cpp</div>
                </div>
                <div class="column column_space"><pre><code>1371  }
1372  void nano_qt::wallet::update_connected ()
1373  {
1374  	if (node.network.empty ())
1375  	{
1376  		active_status.insert (nano_qt::status_types::disconnected);
1377  	}
1378  	else
1379  	{
1380  		active_status.erase (nano_qt::status_types::disconnected);
1381  	}
1382  }
</pre></code></div>
                <div class="column column_space"><pre><code>739  }
740  void TSVMModel::Save(TSOut& SOut) {
741      AlphaV.Save(SOut);
742      Thresh.Save(SOut);
743      Linear.Save(SOut);
744      if (Linear) {
745          WgtV.Save(SOut);
746      } else {
747          SupVecs->Save(SOut);
748          Kernel->Save(SOut);
749      }
750  }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    