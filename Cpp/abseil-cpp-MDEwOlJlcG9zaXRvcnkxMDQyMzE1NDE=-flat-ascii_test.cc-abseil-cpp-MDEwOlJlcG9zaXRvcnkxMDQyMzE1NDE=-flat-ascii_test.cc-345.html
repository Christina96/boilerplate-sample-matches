
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 22, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-ascii_test.cc</h3>
            <pre><code>1  #include &quot;absl/strings/ascii.h&quot;
2  #include &lt;algorithm&gt;
3  #include &lt;cctype&gt;
4  #include &lt;clocale&gt;
5  #include &lt;cstring&gt;
6  #include &lt;string&gt;
7  #include &quot;gtest/gtest.h&quot;
8  #include &quot;absl/base/macros.h&quot;
9  #include &quot;absl/base/port.h&quot;
10  namespace {
11  TEST(AsciiIsFoo, All) {
12    for (int i = 0; i &lt; 256; i++) {
13      const auto c = static_cast&lt;unsigned char&gt;(i);
14      if ((c &gt;= &#x27;a&#x27; &amp;&amp; c &lt;= &#x27;z&#x27;) || (c &gt;= &#x27;A&#x27; &amp;&amp; c &lt;= &#x27;Z&#x27;))
15        EXPECT_TRUE(absl::ascii_isalpha(c)) &lt;&lt; &quot;: failed on &quot; &lt;&lt; c;
16      else
17        EXPECT_TRUE(!absl::ascii_isalpha(c)) &lt;&lt; &quot;: failed on &quot; &lt;&lt; c;
18    }
19    for (int i = 0; i &lt; 256; i++) {
20      const auto c = static_cast&lt;unsigned char&gt;(i);
21      if ((c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;))
22        EXPECT_TRUE(absl::ascii_isdigit(c)) &lt;&lt; &quot;: failed on &quot; &lt;&lt; c;
23      else
24        EXPECT_TRUE(!absl::ascii_isdigit(c)) &lt;&lt; &quot;: failed on &quot; &lt;&lt; c;
25    }
26    for (int i = 0; i &lt; 256; i++) {
27      const auto c = static_cast&lt;unsigned char&gt;(i);
28      if (absl::ascii_isalpha(c) || absl::ascii_isdigit(c))
29        EXPECT_TRUE(absl::ascii_isalnum(c)) &lt;&lt; &quot;: failed on &quot; &lt;&lt; c;
30      else
31        EXPECT_TRUE(!absl::ascii_isalnum(c)) &lt;&lt; &quot;: failed on &quot; &lt;&lt; c;
32    }
33    for (int i = 0; i &lt; 256; i++) {
34      const auto c = static_cast&lt;unsigned char&gt;(i);
35      if (i != &#x27;\0&#x27; &amp;&amp; strchr(&quot; \r\n\t\v\f&quot;, i))
36        EXPECT_TRUE(absl::ascii_isspace(c)) &lt;&lt; &quot;: failed on &quot; &lt;&lt; c;
37      else
38        EXPECT_TRUE(!absl::ascii_isspace(c)) &lt;&lt; &quot;: failed on &quot; &lt;&lt; c;
39    }
40    for (int i = 0; i &lt; 256; i++) {
41      const auto c = static_cast&lt;unsigned char&gt;(i);
42      if (i &gt;= 32 &amp;&amp; i &lt; 127)
43        EXPECT_TRUE(absl::ascii_isprint(c)) &lt;&lt; &quot;: failed on &quot; &lt;&lt; c;
44      else
45        EXPECT_TRUE(!absl::ascii_isprint(c)) &lt;&lt; &quot;: failed on &quot; &lt;&lt; c;
46    }
47    for (int i = 0; i &lt; 256; i++) {
48      const auto c = static_cast&lt;unsigned char&gt;(i);
49      if (absl::ascii_isprint(c) &amp;&amp; !absl::ascii_isspace(c) &amp;&amp;
50          !absl::ascii_isalnum(c)) {
51        EXPECT_TRUE(absl::ascii_ispunct(c)) &lt;&lt; &quot;: failed on &quot; &lt;&lt; c;
52      } else {
53        EXPECT_TRUE(!absl::ascii_ispunct(c)) &lt;&lt; &quot;: failed on &quot; &lt;&lt; c;
54      }
55    }
56    for (int i = 0; i &lt; 256; i++) {
57      const auto c = static_cast&lt;unsigned char&gt;(i);
58      if (i == &#x27; &#x27; || i == &#x27;\t&#x27;)
59        EXPECT_TRUE(absl::ascii_isblank(c)) &lt;&lt; &quot;: failed on &quot; &lt;&lt; c;
60      else
61        EXPECT_TRUE(!absl::ascii_isblank(c)) &lt;&lt; &quot;: failed on &quot; &lt;&lt; c;
62    }
63    for (int i = 0; i &lt; 256; i++) {
64      const auto c = static_cast&lt;unsigned char&gt;(i);
65      if (i &lt; 32 || i == 127)
66        EXPECT_TRUE(absl::ascii_iscntrl(c)) &lt;&lt; &quot;: failed on &quot; &lt;&lt; c;
67      else
68        EXPECT_TRUE(!absl::ascii_iscntrl(c)) &lt;&lt; &quot;: failed on &quot; &lt;&lt; c;
69    }
70    for (int i = 0; i &lt; 256; i++) {
71      const auto c = static_cast&lt;unsigned char&gt;(i);
72      if (absl::ascii_isdigit(c) || (i &gt;= &#x27;A&#x27; &amp;&amp; i &lt;= &#x27;F&#x27;) ||
73          (i &gt;= &#x27;a&#x27; &amp;&amp; i &lt;= &#x27;f&#x27;)) {
74        EXPECT_TRUE(absl::ascii_isxdigit(c)) &lt;&lt; &quot;: failed on &quot; &lt;&lt; c;
75      } else {
76        EXPECT_TRUE(!absl::ascii_isxdigit(c)) &lt;&lt; &quot;: failed on &quot; &lt;&lt; c;
77      }
78    }
79    for (int i = 0; i &lt; 256; i++) {
80      const auto c = static_cast&lt;unsigned char&gt;(i);
81      if (i &gt; 32 &amp;&amp; i &lt; 127)
82        EXPECT_TRUE(absl::ascii_isgraph(c)) &lt;&lt; &quot;: failed on &quot; &lt;&lt; c;
83      else
84        EXPECT_TRUE(!absl::ascii_isgraph(c)) &lt;&lt; &quot;: failed on &quot; &lt;&lt; c;
85    }
86    for (int i = 0; i &lt; 256; i++) {
87      const auto c = static_cast&lt;unsigned char&gt;(i);
88      if (i &gt;= &#x27;A&#x27; &amp;&amp; i &lt;= &#x27;Z&#x27;)
89        EXPECT_TRUE(absl::ascii_isupper(c)) &lt;&lt; &quot;: failed on &quot; &lt;&lt; c;
90      else
91        EXPECT_TRUE(!absl::ascii_isupper(c)) &lt;&lt; &quot;: failed on &quot; &lt;&lt; c;
92    }
93    for (int i = 0; i &lt; 256; i++) {
94      const auto c = static_cast&lt;unsigned char&gt;(i);
95      if (i &gt;= &#x27;a&#x27; &amp;&amp; i &lt;= &#x27;z&#x27;)
96        EXPECT_TRUE(absl::ascii_islower(c)) &lt;&lt; &quot;: failed on &quot; &lt;&lt; c;
97      else
98        EXPECT_TRUE(!absl::ascii_islower(c)) &lt;&lt; &quot;: failed on &quot; &lt;&lt; c;
99    }
100    for (unsigned char c = 0; c &lt; 128; c++) {
101      EXPECT_TRUE(absl::ascii_isascii(c)) &lt;&lt; &quot;: failed on &quot; &lt;&lt; c;
102    }
103    for (int i = 128; i &lt; 256; i++) {
104      const auto c = static_cast&lt;unsigned char&gt;(i);
105      EXPECT_TRUE(!absl::ascii_isascii(c)) &lt;&lt; &quot;: failed on &quot; &lt;&lt; c;
106    }
107  }
108  TEST(AsciiIsFoo, SameAsIsFoo) {
109  #ifndef __ANDROID__
110    const char* old_locale = setlocale(LC_CTYPE, &quot;C&quot;);
111    ASSERT_TRUE(old_locale != nullptr);
112  #endif
113    for (int i = 0; i &lt; 256; i++) {
114      const auto c = static_cast&lt;unsigned char&gt;(i);
115      EXPECT_EQ(isalpha(c) != 0, absl::ascii_isalpha(c)) &lt;&lt; c;
116      EXPECT_EQ(isdigit(c) != 0, absl::ascii_isdigit(c)) &lt;&lt; c;
117      EXPECT_EQ(isalnum(c) != 0, absl::ascii_isalnum(c)) &lt;&lt; c;
118      EXPECT_EQ(isspace(c) != 0, absl::ascii_isspace(c)) &lt;&lt; c;
119      EXPECT_EQ(ispunct(c) != 0, absl::ascii_ispunct(c)) &lt;&lt; c;
120      EXPECT_EQ(isblank(c) != 0, absl::ascii_isblank(c)) &lt;&lt; c;
121      EXPECT_EQ(iscntrl(c) != 0, absl::ascii_iscntrl(c)) &lt;&lt; c;
122      EXPECT_EQ(isxdigit(c) != 0, absl::ascii_isxdigit(c)) &lt;&lt; c;
123      EXPECT_EQ(isprint(c) != 0, absl::ascii_isprint(c)) &lt;&lt; c;
124      EXPECT_EQ(isgraph(c) != 0, absl::ascii_isgraph(c)) &lt;&lt; c;
125      EXPECT_EQ(isupper(c) != 0, absl::ascii_isupper(c)) &lt;&lt; c;
126      EXPECT_EQ(islower(c) != 0, absl::ascii_islower(c)) &lt;&lt; c;
127      EXPECT_EQ(isascii(c) != 0, absl::ascii_isascii(c)) &lt;&lt; c;
128    }
129  #ifndef __ANDROID__
130    ASSERT_TRUE(setlocale(LC_CTYPE, old_locale));
131  #endif
132  }
133  TEST(AsciiToFoo, All) {
134  #ifndef __ANDROID__
135    const char* old_locale = setlocale(LC_CTYPE, &quot;C&quot;);
136    ASSERT_TRUE(old_locale != nullptr);
137  #endif
138    for (int i = 0; i &lt; 256; i++) {
139      const auto c = static_cast&lt;unsigned char&gt;(i);
140      if (absl::ascii_islower(c))
141        EXPECT_EQ(absl::ascii_toupper(c), &#x27;A&#x27; + (i - &#x27;a&#x27;)) &lt;&lt; c;
142      else
143        EXPECT_EQ(absl::ascii_toupper(c), static_cast&lt;char&gt;(i)) &lt;&lt; c;
144      if (absl::ascii_isupper(c))
145        EXPECT_EQ(absl::ascii_tolower(c), &#x27;a&#x27; + (i - &#x27;A&#x27;)) &lt;&lt; c;
146      else
147        EXPECT_EQ(absl::ascii_tolower(c), static_cast&lt;char&gt;(i)) &lt;&lt; c;
148      EXPECT_EQ(static_cast&lt;char&gt;(tolower(i)), absl::ascii_tolower(c)) &lt;&lt; c;
149      EXPECT_EQ(static_cast&lt;char&gt;(toupper(i)), absl::ascii_toupper(c)) &lt;&lt; c;
150    }
151  #ifndef __ANDROID__
152    ASSERT_TRUE(setlocale(LC_CTYPE, old_locale));
153  #endif
154  }
155  TEST(AsciiStrTo, Lower) {
156    const char buf[] = &quot;ABCDEF&quot;;
157    const std::string str(&quot;GHIJKL&quot;);
158    const std::string str2(&quot;MNOPQR&quot;);
159    const absl::string_view sp(str2);
160    std::string mutable_str(&quot;_`?@[{AMNOPQRSTUVWXYZ&quot;);
161    EXPECT_EQ(&quot;abcdef&quot;, absl::AsciiStrToLower(buf));
162    EXPECT_EQ(&quot;ghijkl&quot;, absl::AsciiStrToLower(str));
163    EXPECT_EQ(&quot;mnopqr&quot;, absl::AsciiStrToLower(sp));
164    absl::AsciiStrToLower(&amp;mutable_str);
165    EXPECT_EQ(&quot;_`?@[{amnopqrstuvwxyz&quot;, mutable_str);
166    char mutable_buf[] = &quot;Mutable&quot;;
167    std::transform(mutable_buf, mutable_buf + strlen(mutable_buf),
<span onclick='openModal()' class='match'>168                   mutable_buf, absl::ascii_tolower);
169    EXPECT_STREQ(&quot;mutable&quot;, mutable_buf);
170  }
171  TEST(AsciiStrTo, Upper) {
172    const char buf[] = &quot;abcdef&quot;;
</span>173    const std::string str(&quot;ghijkl&quot;);
174    const std::string str2(&quot;_`?@[{amnopqrstuvwxyz&quot;);
175    const absl::string_view sp(str2);
176    EXPECT_EQ(&quot;ABCDEF&quot;, absl::AsciiStrToUpper(buf));
177    EXPECT_EQ(&quot;GHIJKL&quot;, absl::AsciiStrToUpper(str));
178    EXPECT_EQ(&quot;_`?@[{AMNOPQRSTUVWXYZ&quot;, absl::AsciiStrToUpper(sp));
179    char mutable_buf[] = &quot;Mutable&quot;;
180    std::transform(mutable_buf, mutable_buf + strlen(mutable_buf),
181                   mutable_buf, absl::ascii_toupper);
182    EXPECT_STREQ(&quot;MUTABLE&quot;, mutable_buf);
183  }
184  TEST(StripLeadingAsciiWhitespace, FromStringView) {
185    EXPECT_EQ(absl::string_view{},
186              absl::StripLeadingAsciiWhitespace(absl::string_view{}));
187    EXPECT_EQ(&quot;foo&quot;, absl::StripLeadingAsciiWhitespace({&quot;foo&quot;}));
188    EXPECT_EQ(&quot;foo&quot;, absl::StripLeadingAsciiWhitespace({&quot;\t  \n\f\r\n\vfoo&quot;}));
189    EXPECT_EQ(&quot;foo foo\n &quot;,
190              absl::StripLeadingAsciiWhitespace({&quot;\t  \n\f\r\n\vfoo foo\n &quot;}));
191    EXPECT_EQ(absl::string_view{}, absl::StripLeadingAsciiWhitespace(
192                                       {&quot;\t  \n\f\r\v\n\t  \n\f\r\v\n&quot;}));
193  }
194  TEST(StripLeadingAsciiWhitespace, InPlace) {
195    std::string str;
196    absl::StripLeadingAsciiWhitespace(&amp;str);
197    EXPECT_EQ(&quot;&quot;, str);
198    str = &quot;foo&quot;;
199    absl::StripLeadingAsciiWhitespace(&amp;str);
200    EXPECT_EQ(&quot;foo&quot;, str);
201    str = &quot;\t  \n\f\r\n\vfoo&quot;;
202    absl::StripLeadingAsciiWhitespace(&amp;str);
203    EXPECT_EQ(&quot;foo&quot;, str);
204    str = &quot;\t  \n\f\r\n\vfoo foo\n &quot;;
205    absl::StripLeadingAsciiWhitespace(&amp;str);
206    EXPECT_EQ(&quot;foo foo\n &quot;, str);
207    str = &quot;\t  \n\f\r\v\n\t  \n\f\r\v\n&quot;;
208    absl::StripLeadingAsciiWhitespace(&amp;str);
209    EXPECT_EQ(absl::string_view{}, str);
210  }
211  TEST(StripTrailingAsciiWhitespace, FromStringView) {
212    EXPECT_EQ(absl::string_view{},
213              absl::StripTrailingAsciiWhitespace(absl::string_view{}));
214    EXPECT_EQ(&quot;foo&quot;, absl::StripTrailingAsciiWhitespace({&quot;foo&quot;}));
215    EXPECT_EQ(&quot;foo&quot;, absl::StripTrailingAsciiWhitespace({&quot;foo\t  \n\f\r\n\v&quot;}));
216    EXPECT_EQ(&quot; \nfoo foo&quot;,
217              absl::StripTrailingAsciiWhitespace({&quot; \nfoo foo\t  \n\f\r\n\v&quot;}));
218    EXPECT_EQ(absl::string_view{}, absl::StripTrailingAsciiWhitespace(
219                                       {&quot;\t  \n\f\r\v\n\t  \n\f\r\v\n&quot;}));
220  }
221  TEST(StripTrailingAsciiWhitespace, InPlace) {
222    std::string str;
223    absl::StripTrailingAsciiWhitespace(&amp;str);
224    EXPECT_EQ(&quot;&quot;, str);
225    str = &quot;foo&quot;;
226    absl::StripTrailingAsciiWhitespace(&amp;str);
227    EXPECT_EQ(&quot;foo&quot;, str);
228    str = &quot;foo\t  \n\f\r\n\v&quot;;
229    absl::StripTrailingAsciiWhitespace(&amp;str);
230    EXPECT_EQ(&quot;foo&quot;, str);
231    str = &quot; \nfoo foo\t  \n\f\r\n\v&quot;;
232    absl::StripTrailingAsciiWhitespace(&amp;str);
233    EXPECT_EQ(&quot; \nfoo foo&quot;, str);
234    str = &quot;\t  \n\f\r\v\n\t  \n\f\r\v\n&quot;;
235    absl::StripTrailingAsciiWhitespace(&amp;str);
236    EXPECT_EQ(absl::string_view{}, str);
237  }
238  TEST(StripAsciiWhitespace, FromStringView) {
239    EXPECT_EQ(absl::string_view{},
240              absl::StripAsciiWhitespace(absl::string_view{}));
241    EXPECT_EQ(&quot;foo&quot;, absl::StripAsciiWhitespace({&quot;foo&quot;}));
242    EXPECT_EQ(&quot;foo&quot;,
243              absl::StripAsciiWhitespace({&quot;\t  \n\f\r\n\vfoo\t  \n\f\r\n\v&quot;}));
244    EXPECT_EQ(&quot;foo foo&quot;, absl::StripAsciiWhitespace(
245                             {&quot;\t  \n\f\r\n\vfoo foo\t  \n\f\r\n\v&quot;}));
246    EXPECT_EQ(absl::string_view{},
247              absl::StripAsciiWhitespace({&quot;\t  \n\f\r\v\n\t  \n\f\r\v\n&quot;}));
248  }
249  TEST(StripAsciiWhitespace, InPlace) {
250    std::string str;
251    absl::StripAsciiWhitespace(&amp;str);
252    EXPECT_EQ(&quot;&quot;, str);
253    str = &quot;foo&quot;;
254    absl::StripAsciiWhitespace(&amp;str);
255    EXPECT_EQ(&quot;foo&quot;, str);
256    str = &quot;\t  \n\f\r\n\vfoo\t  \n\f\r\n\v&quot;;
257    absl::StripAsciiWhitespace(&amp;str);
258    EXPECT_EQ(&quot;foo&quot;, str);
259    str = &quot;\t  \n\f\r\n\vfoo foo\t  \n\f\r\n\v&quot;;
260    absl::StripAsciiWhitespace(&amp;str);
261    EXPECT_EQ(&quot;foo foo&quot;, str);
262    str = &quot;\t  \n\f\r\v\n\t  \n\f\r\v\n&quot;;
263    absl::StripAsciiWhitespace(&amp;str);
264    EXPECT_EQ(absl::string_view{}, str);
265  }
266  TEST(RemoveExtraAsciiWhitespace, InPlace) {
267    const char* inputs[] = {&quot;No extra space&quot;,
268                            &quot;  Leading whitespace&quot;,
269                            &quot;Trailing whitespace  &quot;,
270                            &quot;  Leading and trailing  &quot;,
271                            &quot; Whitespace \t  in\v   middle  &quot;,
272                            &quot;&#x27;Eeeeep!  \n Newlines!\n&quot;,
273                            &quot;nospaces&quot;,
274                            &quot;&quot;,
275                            &quot;\n\t a\t\n\nb \t\n&quot;};
276    const char* outputs[] = {
277        &quot;No extra space&quot;,
278        &quot;Leading whitespace&quot;,
279        &quot;Trailing whitespace&quot;,
280        &quot;Leading and trailing&quot;,
281        &quot;Whitespace in middle&quot;,
282        &quot;&#x27;Eeeeep! Newlines!&quot;,
283        &quot;nospaces&quot;,
284        &quot;&quot;,
285        &quot;a\nb&quot;,
286    };
287    const int NUM_TESTS = ABSL_ARRAYSIZE(inputs);
288    for (int i = 0; i &lt; NUM_TESTS; i++) {
289      std::string s(inputs[i]);
290      absl::RemoveExtraAsciiWhitespace(&amp;s);
291      EXPECT_EQ(outputs[i], s);
292    }
293  }
294  }  
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-ascii_test.cc</h3>
            <pre><code>1  #include &quot;absl/strings/ascii.h&quot;
2  #include &lt;algorithm&gt;
3  #include &lt;cctype&gt;
4  #include &lt;clocale&gt;
5  #include &lt;cstring&gt;
6  #include &lt;string&gt;
7  #include &quot;gtest/gtest.h&quot;
8  #include &quot;absl/base/macros.h&quot;
9  #include &quot;absl/base/port.h&quot;
10  namespace {
11  TEST(AsciiIsFoo, All) {
12    for (int i = 0; i &lt; 256; i++) {
13      const auto c = static_cast&lt;unsigned char&gt;(i);
14      if ((c &gt;= &#x27;a&#x27; &amp;&amp; c &lt;= &#x27;z&#x27;) || (c &gt;= &#x27;A&#x27; &amp;&amp; c &lt;= &#x27;Z&#x27;))
15        EXPECT_TRUE(absl::ascii_isalpha(c)) &lt;&lt; &quot;: failed on &quot; &lt;&lt; c;
16      else
17        EXPECT_TRUE(!absl::ascii_isalpha(c)) &lt;&lt; &quot;: failed on &quot; &lt;&lt; c;
18    }
19    for (int i = 0; i &lt; 256; i++) {
20      const auto c = static_cast&lt;unsigned char&gt;(i);
21      if ((c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;))
22        EXPECT_TRUE(absl::ascii_isdigit(c)) &lt;&lt; &quot;: failed on &quot; &lt;&lt; c;
23      else
24        EXPECT_TRUE(!absl::ascii_isdigit(c)) &lt;&lt; &quot;: failed on &quot; &lt;&lt; c;
25    }
26    for (int i = 0; i &lt; 256; i++) {
27      const auto c = static_cast&lt;unsigned char&gt;(i);
28      if (absl::ascii_isalpha(c) || absl::ascii_isdigit(c))
29        EXPECT_TRUE(absl::ascii_isalnum(c)) &lt;&lt; &quot;: failed on &quot; &lt;&lt; c;
30      else
31        EXPECT_TRUE(!absl::ascii_isalnum(c)) &lt;&lt; &quot;: failed on &quot; &lt;&lt; c;
32    }
33    for (int i = 0; i &lt; 256; i++) {
34      const auto c = static_cast&lt;unsigned char&gt;(i);
35      if (i != &#x27;\0&#x27; &amp;&amp; strchr(&quot; \r\n\t\v\f&quot;, i))
36        EXPECT_TRUE(absl::ascii_isspace(c)) &lt;&lt; &quot;: failed on &quot; &lt;&lt; c;
37      else
38        EXPECT_TRUE(!absl::ascii_isspace(c)) &lt;&lt; &quot;: failed on &quot; &lt;&lt; c;
39    }
40    for (int i = 0; i &lt; 256; i++) {
41      const auto c = static_cast&lt;unsigned char&gt;(i);
42      if (i &gt;= 32 &amp;&amp; i &lt; 127)
43        EXPECT_TRUE(absl::ascii_isprint(c)) &lt;&lt; &quot;: failed on &quot; &lt;&lt; c;
44      else
45        EXPECT_TRUE(!absl::ascii_isprint(c)) &lt;&lt; &quot;: failed on &quot; &lt;&lt; c;
46    }
47    for (int i = 0; i &lt; 256; i++) {
48      const auto c = static_cast&lt;unsigned char&gt;(i);
49      if (absl::ascii_isprint(c) &amp;&amp; !absl::ascii_isspace(c) &amp;&amp;
50          !absl::ascii_isalnum(c)) {
51        EXPECT_TRUE(absl::ascii_ispunct(c)) &lt;&lt; &quot;: failed on &quot; &lt;&lt; c;
52      } else {
53        EXPECT_TRUE(!absl::ascii_ispunct(c)) &lt;&lt; &quot;: failed on &quot; &lt;&lt; c;
54      }
55    }
56    for (int i = 0; i &lt; 256; i++) {
57      const auto c = static_cast&lt;unsigned char&gt;(i);
58      if (i == &#x27; &#x27; || i == &#x27;\t&#x27;)
59        EXPECT_TRUE(absl::ascii_isblank(c)) &lt;&lt; &quot;: failed on &quot; &lt;&lt; c;
60      else
61        EXPECT_TRUE(!absl::ascii_isblank(c)) &lt;&lt; &quot;: failed on &quot; &lt;&lt; c;
62    }
63    for (int i = 0; i &lt; 256; i++) {
64      const auto c = static_cast&lt;unsigned char&gt;(i);
65      if (i &lt; 32 || i == 127)
66        EXPECT_TRUE(absl::ascii_iscntrl(c)) &lt;&lt; &quot;: failed on &quot; &lt;&lt; c;
67      else
68        EXPECT_TRUE(!absl::ascii_iscntrl(c)) &lt;&lt; &quot;: failed on &quot; &lt;&lt; c;
69    }
70    for (int i = 0; i &lt; 256; i++) {
71      const auto c = static_cast&lt;unsigned char&gt;(i);
72      if (absl::ascii_isdigit(c) || (i &gt;= &#x27;A&#x27; &amp;&amp; i &lt;= &#x27;F&#x27;) ||
73          (i &gt;= &#x27;a&#x27; &amp;&amp; i &lt;= &#x27;f&#x27;)) {
74        EXPECT_TRUE(absl::ascii_isxdigit(c)) &lt;&lt; &quot;: failed on &quot; &lt;&lt; c;
75      } else {
76        EXPECT_TRUE(!absl::ascii_isxdigit(c)) &lt;&lt; &quot;: failed on &quot; &lt;&lt; c;
77      }
78    }
79    for (int i = 0; i &lt; 256; i++) {
80      const auto c = static_cast&lt;unsigned char&gt;(i);
81      if (i &gt; 32 &amp;&amp; i &lt; 127)
82        EXPECT_TRUE(absl::ascii_isgraph(c)) &lt;&lt; &quot;: failed on &quot; &lt;&lt; c;
83      else
84        EXPECT_TRUE(!absl::ascii_isgraph(c)) &lt;&lt; &quot;: failed on &quot; &lt;&lt; c;
85    }
86    for (int i = 0; i &lt; 256; i++) {
87      const auto c = static_cast&lt;unsigned char&gt;(i);
88      if (i &gt;= &#x27;A&#x27; &amp;&amp; i &lt;= &#x27;Z&#x27;)
89        EXPECT_TRUE(absl::ascii_isupper(c)) &lt;&lt; &quot;: failed on &quot; &lt;&lt; c;
90      else
91        EXPECT_TRUE(!absl::ascii_isupper(c)) &lt;&lt; &quot;: failed on &quot; &lt;&lt; c;
92    }
93    for (int i = 0; i &lt; 256; i++) {
94      const auto c = static_cast&lt;unsigned char&gt;(i);
95      if (i &gt;= &#x27;a&#x27; &amp;&amp; i &lt;= &#x27;z&#x27;)
96        EXPECT_TRUE(absl::ascii_islower(c)) &lt;&lt; &quot;: failed on &quot; &lt;&lt; c;
97      else
98        EXPECT_TRUE(!absl::ascii_islower(c)) &lt;&lt; &quot;: failed on &quot; &lt;&lt; c;
99    }
100    for (unsigned char c = 0; c &lt; 128; c++) {
101      EXPECT_TRUE(absl::ascii_isascii(c)) &lt;&lt; &quot;: failed on &quot; &lt;&lt; c;
102    }
103    for (int i = 128; i &lt; 256; i++) {
104      const auto c = static_cast&lt;unsigned char&gt;(i);
105      EXPECT_TRUE(!absl::ascii_isascii(c)) &lt;&lt; &quot;: failed on &quot; &lt;&lt; c;
106    }
107  }
108  TEST(AsciiIsFoo, SameAsIsFoo) {
109  #ifndef __ANDROID__
110    const char* old_locale = setlocale(LC_CTYPE, &quot;C&quot;);
111    ASSERT_TRUE(old_locale != nullptr);
112  #endif
113    for (int i = 0; i &lt; 256; i++) {
114      const auto c = static_cast&lt;unsigned char&gt;(i);
115      EXPECT_EQ(isalpha(c) != 0, absl::ascii_isalpha(c)) &lt;&lt; c;
116      EXPECT_EQ(isdigit(c) != 0, absl::ascii_isdigit(c)) &lt;&lt; c;
117      EXPECT_EQ(isalnum(c) != 0, absl::ascii_isalnum(c)) &lt;&lt; c;
118      EXPECT_EQ(isspace(c) != 0, absl::ascii_isspace(c)) &lt;&lt; c;
119      EXPECT_EQ(ispunct(c) != 0, absl::ascii_ispunct(c)) &lt;&lt; c;
120      EXPECT_EQ(isblank(c) != 0, absl::ascii_isblank(c)) &lt;&lt; c;
121      EXPECT_EQ(iscntrl(c) != 0, absl::ascii_iscntrl(c)) &lt;&lt; c;
122      EXPECT_EQ(isxdigit(c) != 0, absl::ascii_isxdigit(c)) &lt;&lt; c;
123      EXPECT_EQ(isprint(c) != 0, absl::ascii_isprint(c)) &lt;&lt; c;
124      EXPECT_EQ(isgraph(c) != 0, absl::ascii_isgraph(c)) &lt;&lt; c;
125      EXPECT_EQ(isupper(c) != 0, absl::ascii_isupper(c)) &lt;&lt; c;
126      EXPECT_EQ(islower(c) != 0, absl::ascii_islower(c)) &lt;&lt; c;
127      EXPECT_EQ(isascii(c) != 0, absl::ascii_isascii(c)) &lt;&lt; c;
128    }
129  #ifndef __ANDROID__
130    ASSERT_TRUE(setlocale(LC_CTYPE, old_locale));
131  #endif
132  }
133  TEST(AsciiToFoo, All) {
134  #ifndef __ANDROID__
135    const char* old_locale = setlocale(LC_CTYPE, &quot;C&quot;);
136    ASSERT_TRUE(old_locale != nullptr);
137  #endif
138    for (int i = 0; i &lt; 256; i++) {
139      const auto c = static_cast&lt;unsigned char&gt;(i);
140      if (absl::ascii_islower(c))
141        EXPECT_EQ(absl::ascii_toupper(c), &#x27;A&#x27; + (i - &#x27;a&#x27;)) &lt;&lt; c;
142      else
143        EXPECT_EQ(absl::ascii_toupper(c), static_cast&lt;char&gt;(i)) &lt;&lt; c;
144      if (absl::ascii_isupper(c))
145        EXPECT_EQ(absl::ascii_tolower(c), &#x27;a&#x27; + (i - &#x27;A&#x27;)) &lt;&lt; c;
146      else
147        EXPECT_EQ(absl::ascii_tolower(c), static_cast&lt;char&gt;(i)) &lt;&lt; c;
148      EXPECT_EQ(static_cast&lt;char&gt;(tolower(i)), absl::ascii_tolower(c)) &lt;&lt; c;
149      EXPECT_EQ(static_cast&lt;char&gt;(toupper(i)), absl::ascii_toupper(c)) &lt;&lt; c;
150    }
151  #ifndef __ANDROID__
152    ASSERT_TRUE(setlocale(LC_CTYPE, old_locale));
153  #endif
154  }
155  TEST(AsciiStrTo, Lower) {
156    const char buf[] = &quot;ABCDEF&quot;;
157    const std::string str(&quot;GHIJKL&quot;);
158    const std::string str2(&quot;MNOPQR&quot;);
159    const absl::string_view sp(str2);
160    std::string mutable_str(&quot;_`?@[{AMNOPQRSTUVWXYZ&quot;);
161    EXPECT_EQ(&quot;abcdef&quot;, absl::AsciiStrToLower(buf));
162    EXPECT_EQ(&quot;ghijkl&quot;, absl::AsciiStrToLower(str));
163    EXPECT_EQ(&quot;mnopqr&quot;, absl::AsciiStrToLower(sp));
164    absl::AsciiStrToLower(&amp;mutable_str);
165    EXPECT_EQ(&quot;_`?@[{amnopqrstuvwxyz&quot;, mutable_str);
166    char mutable_buf[] = &quot;Mutable&quot;;
167    std::transform(mutable_buf, mutable_buf + strlen(mutable_buf),
168                   mutable_buf, absl::ascii_tolower);
169    EXPECT_STREQ(&quot;mutable&quot;, mutable_buf);
170  }
171  TEST(AsciiStrTo, Upper) {
172    const char buf[] = &quot;abcdef&quot;;
173    const std::string str(&quot;ghijkl&quot;);
174    const std::string str2(&quot;_`?@[{amnopqrstuvwxyz&quot;);
175    const absl::string_view sp(str2);
176    EXPECT_EQ(&quot;ABCDEF&quot;, absl::AsciiStrToUpper(buf));
177    EXPECT_EQ(&quot;GHIJKL&quot;, absl::AsciiStrToUpper(str));
178    EXPECT_EQ(&quot;_`?@[{AMNOPQRSTUVWXYZ&quot;, absl::AsciiStrToUpper(sp));
179    char mutable_buf[] = &quot;Mutable&quot;;
180    std::transform(mutable_buf, mutable_buf + strlen(mutable_buf),
<span onclick='openModal()' class='match'>181                   mutable_buf, absl::ascii_toupper);
182    EXPECT_STREQ(&quot;MUTABLE&quot;, mutable_buf);
183  }
184  TEST(StripLeadingAsciiWhitespace, FromStringView) {
185    EXPECT_EQ(absl::string_view{},
</span>186              absl::StripLeadingAsciiWhitespace(absl::string_view{}));
187    EXPECT_EQ(&quot;foo&quot;, absl::StripLeadingAsciiWhitespace({&quot;foo&quot;}));
188    EXPECT_EQ(&quot;foo&quot;, absl::StripLeadingAsciiWhitespace({&quot;\t  \n\f\r\n\vfoo&quot;}));
189    EXPECT_EQ(&quot;foo foo\n &quot;,
190              absl::StripLeadingAsciiWhitespace({&quot;\t  \n\f\r\n\vfoo foo\n &quot;}));
191    EXPECT_EQ(absl::string_view{}, absl::StripLeadingAsciiWhitespace(
192                                       {&quot;\t  \n\f\r\v\n\t  \n\f\r\v\n&quot;}));
193  }
194  TEST(StripLeadingAsciiWhitespace, InPlace) {
195    std::string str;
196    absl::StripLeadingAsciiWhitespace(&amp;str);
197    EXPECT_EQ(&quot;&quot;, str);
198    str = &quot;foo&quot;;
199    absl::StripLeadingAsciiWhitespace(&amp;str);
200    EXPECT_EQ(&quot;foo&quot;, str);
201    str = &quot;\t  \n\f\r\n\vfoo&quot;;
202    absl::StripLeadingAsciiWhitespace(&amp;str);
203    EXPECT_EQ(&quot;foo&quot;, str);
204    str = &quot;\t  \n\f\r\n\vfoo foo\n &quot;;
205    absl::StripLeadingAsciiWhitespace(&amp;str);
206    EXPECT_EQ(&quot;foo foo\n &quot;, str);
207    str = &quot;\t  \n\f\r\v\n\t  \n\f\r\v\n&quot;;
208    absl::StripLeadingAsciiWhitespace(&amp;str);
209    EXPECT_EQ(absl::string_view{}, str);
210  }
211  TEST(StripTrailingAsciiWhitespace, FromStringView) {
212    EXPECT_EQ(absl::string_view{},
213              absl::StripTrailingAsciiWhitespace(absl::string_view{}));
214    EXPECT_EQ(&quot;foo&quot;, absl::StripTrailingAsciiWhitespace({&quot;foo&quot;}));
215    EXPECT_EQ(&quot;foo&quot;, absl::StripTrailingAsciiWhitespace({&quot;foo\t  \n\f\r\n\v&quot;}));
216    EXPECT_EQ(&quot; \nfoo foo&quot;,
217              absl::StripTrailingAsciiWhitespace({&quot; \nfoo foo\t  \n\f\r\n\v&quot;}));
218    EXPECT_EQ(absl::string_view{}, absl::StripTrailingAsciiWhitespace(
219                                       {&quot;\t  \n\f\r\v\n\t  \n\f\r\v\n&quot;}));
220  }
221  TEST(StripTrailingAsciiWhitespace, InPlace) {
222    std::string str;
223    absl::StripTrailingAsciiWhitespace(&amp;str);
224    EXPECT_EQ(&quot;&quot;, str);
225    str = &quot;foo&quot;;
226    absl::StripTrailingAsciiWhitespace(&amp;str);
227    EXPECT_EQ(&quot;foo&quot;, str);
228    str = &quot;foo\t  \n\f\r\n\v&quot;;
229    absl::StripTrailingAsciiWhitespace(&amp;str);
230    EXPECT_EQ(&quot;foo&quot;, str);
231    str = &quot; \nfoo foo\t  \n\f\r\n\v&quot;;
232    absl::StripTrailingAsciiWhitespace(&amp;str);
233    EXPECT_EQ(&quot; \nfoo foo&quot;, str);
234    str = &quot;\t  \n\f\r\v\n\t  \n\f\r\v\n&quot;;
235    absl::StripTrailingAsciiWhitespace(&amp;str);
236    EXPECT_EQ(absl::string_view{}, str);
237  }
238  TEST(StripAsciiWhitespace, FromStringView) {
239    EXPECT_EQ(absl::string_view{},
240              absl::StripAsciiWhitespace(absl::string_view{}));
241    EXPECT_EQ(&quot;foo&quot;, absl::StripAsciiWhitespace({&quot;foo&quot;}));
242    EXPECT_EQ(&quot;foo&quot;,
243              absl::StripAsciiWhitespace({&quot;\t  \n\f\r\n\vfoo\t  \n\f\r\n\v&quot;}));
244    EXPECT_EQ(&quot;foo foo&quot;, absl::StripAsciiWhitespace(
245                             {&quot;\t  \n\f\r\n\vfoo foo\t  \n\f\r\n\v&quot;}));
246    EXPECT_EQ(absl::string_view{},
247              absl::StripAsciiWhitespace({&quot;\t  \n\f\r\v\n\t  \n\f\r\v\n&quot;}));
248  }
249  TEST(StripAsciiWhitespace, InPlace) {
250    std::string str;
251    absl::StripAsciiWhitespace(&amp;str);
252    EXPECT_EQ(&quot;&quot;, str);
253    str = &quot;foo&quot;;
254    absl::StripAsciiWhitespace(&amp;str);
255    EXPECT_EQ(&quot;foo&quot;, str);
256    str = &quot;\t  \n\f\r\n\vfoo\t  \n\f\r\n\v&quot;;
257    absl::StripAsciiWhitespace(&amp;str);
258    EXPECT_EQ(&quot;foo&quot;, str);
259    str = &quot;\t  \n\f\r\n\vfoo foo\t  \n\f\r\n\v&quot;;
260    absl::StripAsciiWhitespace(&amp;str);
261    EXPECT_EQ(&quot;foo foo&quot;, str);
262    str = &quot;\t  \n\f\r\v\n\t  \n\f\r\v\n&quot;;
263    absl::StripAsciiWhitespace(&amp;str);
264    EXPECT_EQ(absl::string_view{}, str);
265  }
266  TEST(RemoveExtraAsciiWhitespace, InPlace) {
267    const char* inputs[] = {&quot;No extra space&quot;,
268                            &quot;  Leading whitespace&quot;,
269                            &quot;Trailing whitespace  &quot;,
270                            &quot;  Leading and trailing  &quot;,
271                            &quot; Whitespace \t  in\v   middle  &quot;,
272                            &quot;&#x27;Eeeeep!  \n Newlines!\n&quot;,
273                            &quot;nospaces&quot;,
274                            &quot;&quot;,
275                            &quot;\n\t a\t\n\nb \t\n&quot;};
276    const char* outputs[] = {
277        &quot;No extra space&quot;,
278        &quot;Leading whitespace&quot;,
279        &quot;Trailing whitespace&quot;,
280        &quot;Leading and trailing&quot;,
281        &quot;Whitespace in middle&quot;,
282        &quot;&#x27;Eeeeep! Newlines!&quot;,
283        &quot;nospaces&quot;,
284        &quot;&quot;,
285        &quot;a\nb&quot;,
286    };
287    const int NUM_TESTS = ABSL_ARRAYSIZE(inputs);
288    for (int i = 0; i &lt; NUM_TESTS; i++) {
289      std::string s(inputs[i]);
290      absl::RemoveExtraAsciiWhitespace(&amp;s);
291      EXPECT_EQ(outputs[i], s);
292    }
293  }
294  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-ascii_test.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-ascii_test.cc</div>
                </div>
                <div class="column column_space"><pre><code>168                   mutable_buf, absl::ascii_tolower);
169    EXPECT_STREQ(&quot;mutable&quot;, mutable_buf);
170  }
171  TEST(AsciiStrTo, Upper) {
172    const char buf[] = &quot;abcdef&quot;;
</pre></code></div>
                <div class="column column_space"><pre><code>181                   mutable_buf, absl::ascii_toupper);
182    EXPECT_STREQ(&quot;MUTABLE&quot;, mutable_buf);
183  }
184  TEST(StripLeadingAsciiWhitespace, FromStringView) {
185    EXPECT_EQ(absl::string_view{},
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    