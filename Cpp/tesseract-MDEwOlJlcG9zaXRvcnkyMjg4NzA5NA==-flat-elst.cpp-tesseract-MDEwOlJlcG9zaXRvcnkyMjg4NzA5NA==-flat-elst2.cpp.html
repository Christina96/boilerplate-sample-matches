
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 46, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-elst.cpp</h3>
            <pre><code>1  #include "elst.h"
2  #include <cstdlib>
3  namespace tesseract {
4  void ELIST::internal_clear( 
5      void (*zapper)(void *)) {
6    ELIST_LINK *ptr;
7    ELIST_LINK *next;
8    if (!empty()) {
9      ptr = last->next;     
10      last->next = nullptr; 
11      last = nullptr;       
12      while (ptr) {
13        next = ptr->next;
14        zapper(ptr);
15        ptr = next;
16      }
17    }
18  }
19  void ELIST::assign_to_sublist( 
20      ELIST_ITERATOR *start_it,  
21      ELIST_ITERATOR *end_it) {  
22    constexpr ERRCODE LIST_NOT_EMPTY("Destination list must be empty before extracting a sublist");
23    if (!empty()) {
24      LIST_NOT_EMPTY.error("ELIST.assign_to_sublist", ABORT);
25    }
26    last = start_it->extract_sublist(end_it);
27  }
28  void ELIST::sort(   
29      int comparator( 
30          const void *, const void *)) {
31    auto count = length();
32    if (count > 0) {
33      std::vector<ELIST_LINK *> base;
34      base.reserve(count);
35      ELIST_ITERATOR it(this);
36      for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
37        base.push_back(it.extract());
38      }
39      qsort(&base[0], count, sizeof(base[0]), comparator);
40      for (auto current : base) {
41        it.add_to_end(current);
42      }
43    }
44  }
45  ELIST_LINK *ELIST::add_sorted_and_find(int comparator(const void *, const void *), bool unique,
46                                         ELIST_LINK *new_link) {
47    if (last == nullptr || comparator(&last, &new_link) < 0) {
48      if (last == nullptr) {
49        new_link->next = new_link;
50      } else {
51        new_link->next = last->next;
52        last->next = new_link;
53      }
54      last = new_link;
55    } else {
56      ELIST_ITERATOR it(this);
57      for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
58        ELIST_LINK *link = it.data();
59        int compare = comparator(&link, &new_link);
60        if (compare > 0) {
61          break;
62        } else if (unique && compare == 0) {
63          return link;
64        }
65      }
66      if (it.cycled_list()) {
67        it.add_to_end(new_link);
68      } else {
69        it.add_before_then_move(new_link);
70      }
71    }
72    return new_link;
73  }
74  ELIST_LINK *ELIST_ITERATOR::forward() {
75  #ifndef NDEBUG
76    if (!list)
77      NO_LIST.error("ELIST_ITERATOR::forward", ABORT);
78  #endif
79    if (list->empty()) {
80      return nullptr;
81    }
82    if (current) { 
83      prev = current;
84      started_cycling = true;
85      current = current->next;
86    } else {
87      if (ex_current_was_cycle_pt) {
88        cycle_pt = next;
89      }
90      current = next;
91    }
92  #ifndef NDEBUG
93    if (!current)
94      NULL_DATA.error("ELIST_ITERATOR::forward", ABORT);
95  #endif
96    next = current->next;
97  #ifndef NDEBUG
98    if (!next) {
99      NULL_NEXT.error("ELIST_ITERATOR::forward", ABORT,
100                      "This is: %p  Current is: %p",
101                      static_cast<void *>(this),
102                      static_cast<void *>(current));
103    }
104  #endif
105    return current;
106  }
107  ELIST_LINK *ELIST_ITERATOR::data_relative( 
108      int8_t offset) {                       
109    ELIST_LINK *ptr;
110  #ifndef NDEBUG
111    if (!list)
112      NO_LIST.error("ELIST_ITERATOR::data_relative", ABORT);
113    if (list->empty())
114      EMPTY_LIST.error("ELIST_ITERATOR::data_relative", ABORT);
115    if (offset < -1)
116      BAD_PARAMETER.error("ELIST_ITERATOR::data_relative", ABORT, "offset < -l");
117  #endif
118    if (offset == -1) {
119      ptr = prev;
120    } else {
121      for (ptr = current ? current : prev; offset-- > 0; ptr = ptr->next) {
122        ;
123      }
124    }
125  #ifndef NDEBUG
126    if (!ptr)
127      NULL_DATA.error("ELIST_ITERATOR::data_relative", ABORT);
128  #endif
129    return ptr;
130  }
131  ELIST_LINK *ELIST_ITERATOR::move_to_last() {
132  #ifndef NDEBUG
133    if (!list)
134      NO_LIST.error("ELIST_ITERATOR::move_to_last", ABORT);
135  #endif
136    while (current != list->last) {
137      forward();
138    }
139    return current;
140  }
141  void ELIST_ITERATOR::exchange(  
142      ELIST_ITERATOR *other_it) { 
143    constexpr ERRCODE DONT_EXCHANGE_DELETED("Can't exchange deleted elements of lists");
144    ELIST_LINK *old_current;
145  #ifndef NDEBUG
146    if (!list)
147      NO_LIST.error("ELIST_ITERATOR::exchange", ABORT);
148    if (!other_it)
149      BAD_PARAMETER.error("ELIST_ITERATOR::exchange", ABORT, "other_it nullptr");
150    if (!(other_it->list))
151      NO_LIST.error("ELIST_ITERATOR::exchange", ABORT, "other_it");
152  #endif
153    if ((list->empty()) || (other_it->list->empty()) || (current == other_it->current)) {
154      return;
155    }
156    if (!current || !other_it->current) {
157      DONT_EXCHANGE_DELETED.error("ELIST_ITERATOR.exchange", ABORT);
158    }
159    if ((next == other_it->current) || (other_it->next == current)) {
160      if ((next == other_it->current) && (other_it->next == current)) {
<span onclick='openModal()' class='match'>161        prev = next = current;
162        other_it->prev = other_it->next = other_it->current;
163      } else { 
164        if (other_it->next == current) {
165          other_it->prev->next = current;
166          other_it->current->next = next;
167          current->next = other_it->current;
</span>168          other_it->next = other_it->current;
169          prev = current;
170        } else { 
171          prev->next = other_it->current;
172          current->next = other_it->next;
173          other_it->current->next = current;
174          next = current;
175          other_it->prev = other_it->current;
176        }
177      }
178    } else { 
179      prev->next = other_it->current;
180      current->next = other_it->next;
181      other_it->prev->next = current;
182      other_it->current->next = next;
183    }
184    if (list->last == current) {
185      list->last = other_it->current;
186    }
187    if (other_it->list->last == other_it->current) {
188      other_it->list->last = current;
189    }
190    if (current == cycle_pt) {
191      cycle_pt = other_it->cycle_pt;
192    }
193    if (other_it->current == other_it->cycle_pt) {
194      other_it->cycle_pt = cycle_pt;
195    }
196    old_current = current;
197    current = other_it->current;
198    other_it->current = old_current;
199  }
200  ELIST_LINK *ELIST_ITERATOR::extract_sublist( 
201      ELIST_ITERATOR *other_it) {              
202  #ifndef NDEBUG
203    constexpr ERRCODE BAD_EXTRACTION_PTS("Can't extract sublist from points on different lists");
204    constexpr ERRCODE DONT_EXTRACT_DELETED("Can't extract a sublist marked by deleted points");
205  #endif
206    constexpr ERRCODE BAD_SUBLIST("Can't find sublist end point in original list");
207    ELIST_ITERATOR temp_it = *this;
208    ELIST_LINK *end_of_new_list;
209  #ifndef NDEBUG
210    if (!other_it)
211      BAD_PARAMETER.error("ELIST_ITERATOR::extract_sublist", ABORT, "other_it nullptr");
212    if (!list)
213      NO_LIST.error("ELIST_ITERATOR::extract_sublist", ABORT);
214    if (list != other_it->list)
215      BAD_EXTRACTION_PTS.error("ELIST_ITERATOR.extract_sublist", ABORT);
216    if (list->empty())
217      EMPTY_LIST.error("ELIST_ITERATOR::extract_sublist", ABORT);
218    if (!current || !other_it->current)
219      DONT_EXTRACT_DELETED.error("ELIST_ITERATOR.extract_sublist", ABORT);
220  #endif
221    ex_current_was_last = other_it->ex_current_was_last = false;
222    ex_current_was_cycle_pt = false;
223    other_it->ex_current_was_cycle_pt = false;
224    temp_it.mark_cycle_pt();
225    do {                         
226      if (temp_it.cycled_list()) { 
227        BAD_SUBLIST.error("ELIST_ITERATOR.extract_sublist", ABORT);
228      }
229      if (temp_it.at_last()) {
230        list->last = prev;
231        ex_current_was_last = other_it->ex_current_was_last = true;
232      }
233      if (temp_it.current == cycle_pt) {
234        ex_current_was_cycle_pt = true;
235      }
236      if (temp_it.current == other_it->cycle_pt) {
237        other_it->ex_current_was_cycle_pt = true;
238      }
239      temp_it.forward();
240    } while (temp_it.prev != other_it->current);
241    other_it->current->next = current;
242    end_of_new_list = other_it->current;
243    if (prev == other_it->current) {
244      list->last = nullptr;
245      prev = current = next = nullptr;
246      other_it->prev = other_it->current = other_it->next = nullptr;
247    } else {
248      prev->next = other_it->next;
249      current = other_it->current = nullptr;
250      next = other_it->next;
251      other_it->prev = prev;
252    }
253    return end_of_new_list;
254  }
255  } 
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-elst2.cpp</h3>
            <pre><code>1  #include "elst2.h"
2  #include <cstdlib>
3  namespace tesseract {
4  void ELIST2::internal_clear( 
5      void (*zapper)(void *)) {
6    ELIST2_LINK *ptr;
7    ELIST2_LINK *next;
8    if (!empty()) {
9      ptr = last->next;     
10      last->next = nullptr; 
11      last = nullptr;       
12      while (ptr) {
13        next = ptr->next;
14        zapper(ptr);
15        ptr = next;
16      }
17    }
18  }
19  void ELIST2::assign_to_sublist( 
20      ELIST2_ITERATOR *start_it,  
21      ELIST2_ITERATOR *end_it) {  
22    constexpr ERRCODE LIST_NOT_EMPTY("Destination list must be empty before extracting a sublist");
23    if (!empty()) {
24      LIST_NOT_EMPTY.error("ELIST2.assign_to_sublist", ABORT);
25    }
26    last = start_it->extract_sublist(end_it);
27  }
28  void ELIST2::sort(  
29      int comparator( 
30          const void *, const void *)) {
31    auto count = length();
32    if (count > 0) {
33      std::vector<ELIST2_LINK *> base;
34      base.reserve(count);
35      ELIST2_ITERATOR it(this);
36      for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
37        base.push_back(it.extract());
38      }
39      qsort(&base[0], count, sizeof(base[0]), comparator);
40      for (auto current : base) {
41        it.add_to_end(current);
42      }
43    }
44  }
45  void ELIST2::add_sorted(int comparator(const void *, const void *), ELIST2_LINK *new_link) {
46    if (last == nullptr || comparator(&last, &new_link) < 0) {
47      if (last == nullptr) {
48        new_link->next = new_link;
49        new_link->prev = new_link;
50      } else {
51        new_link->next = last->next;
52        new_link->prev = last;
53        last->next = new_link;
54        new_link->next->prev = new_link;
55      }
56      last = new_link;
57    } else {
58      ELIST2_ITERATOR it(this);
59      for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
60        ELIST2_LINK *link = it.data();
61        if (comparator(&link, &new_link) > 0) {
62          break;
63        }
64      }
65      if (it.cycled_list()) {
66        it.add_to_end(new_link);
67      } else {
68        it.add_before_then_move(new_link);
69      }
70    }
71  }
72  ELIST2_LINK *ELIST2_ITERATOR::forward() {
73  #ifndef NDEBUG
74    if (!list)
75      NO_LIST.error("ELIST2_ITERATOR::forward", ABORT);
76  #endif
77    if (list->empty()) {
78      return nullptr;
79    }
80    if (current) { 
81      prev = current;
82      started_cycling = true;
83      current = current->next;
84    } else {
85      if (ex_current_was_cycle_pt) {
86        cycle_pt = next;
87      }
88      current = next;
89    }
90  #ifndef NDEBUG
91    if (!current)
92      NULL_DATA.error("ELIST2_ITERATOR::forward", ABORT);
93  #endif
94    next = current->next;
95  #ifndef NDEBUG
96    if (!next) {
97      NULL_NEXT.error("ELIST2_ITERATOR::forward", ABORT,
98                      "This is: %p  Current is: %p",
99                      static_cast<void *>(this),
100                      static_cast<void *>(current));
101    }
102  #endif
103    return current;
104  }
105  ELIST2_LINK *ELIST2_ITERATOR::backward() {
106  #ifndef NDEBUG
107    if (!list)
108      NO_LIST.error("ELIST2_ITERATOR::backward", ABORT);
109  #endif
110    if (list->empty()) {
111      return nullptr;
112    }
113    if (current) { 
114      next = current;
115      started_cycling = true;
116      current = current->prev;
117    } else {
118      if (ex_current_was_cycle_pt) {
119        cycle_pt = prev;
120      }
121      current = prev;
122    }
123  #ifndef NDEBUG
124    if (!current)
125      NULL_DATA.error("ELIST2_ITERATOR::backward", ABORT);
126    if (!prev) {
127      NULL_PREV.error("ELIST2_ITERATOR::backward", ABORT,
128                      "This is: %p  Current is: %p",
129                      static_cast<void *>(this),
130                      static_cast<void *>(current));
131    }
132  #endif
133    prev = current->prev;
134    return current;
135  }
136  ELIST2_LINK *ELIST2_ITERATOR::data_relative( 
137      int8_t offset) {                         
138    ELIST2_LINK *ptr;
139  #ifndef NDEBUG
140    if (!list)
141      NO_LIST.error("ELIST2_ITERATOR::data_relative", ABORT);
142    if (list->empty())
143      EMPTY_LIST.error("ELIST2_ITERATOR::data_relative", ABORT);
144  #endif
145    if (offset < 0) {
146      for (ptr = current ? current : next; offset++ < 0; ptr = ptr->prev) {
147        ;
148      }
149    } else {
150      for (ptr = current ? current : prev; offset-- > 0; ptr = ptr->next) {
151        ;
152      }
153    }
154  #ifndef NDEBUG
155    if (!ptr)
156      NULL_DATA.error("ELIST2_ITERATOR::data_relative", ABORT);
157  #endif
158    return ptr;
159  }
160  void ELIST2_ITERATOR::exchange(  
161      ELIST2_ITERATOR *other_it) { 
162    constexpr ERRCODE DONT_EXCHANGE_DELETED("Can't exchange deleted elements of lists");
163    ELIST2_LINK *old_current;
164  #ifndef NDEBUG
165    if (!list)
166      NO_LIST.error("ELIST2_ITERATOR::exchange", ABORT);
167    if (!other_it)
168      BAD_PARAMETER.error("ELIST2_ITERATOR::exchange", ABORT, "other_it nullptr");
169    if (!(other_it->list))
170      NO_LIST.error("ELIST2_ITERATOR::exchange", ABORT, "other_it");
171  #endif
172    if ((list->empty()) || (other_it->list->empty()) || (current == other_it->current)) {
173      return;
174    }
175    if (!current || !other_it->current) {
176      DONT_EXCHANGE_DELETED.error("ELIST2_ITERATOR.exchange", ABORT);
177    }
178    if ((next == other_it->current) || (other_it->next == current)) {
179      if ((next == other_it->current) && (other_it->next == current)) {
<span onclick='openModal()' class='match'>180        prev = next = current;
181        other_it->prev = other_it->next = other_it->current;
182      } else { 
183        if (other_it->next == current) {
184          other_it->prev->next = current;
185          other_it->current->next = next;
186          other_it->current->prev = current;
</span>187          current->next = other_it->current;
188          current->prev = other_it->prev;
189          next->prev = other_it->current;
190          other_it->next = other_it->current;
191          prev = current;
192        } else { 
193          prev->next = other_it->current;
194          current->next = other_it->next;
195          current->prev = other_it->current;
196          other_it->current->next = current;
197          other_it->current->prev = prev;
198          other_it->next->prev = current;
199          next = current;
200          other_it->prev = other_it->current;
201        }
202      }
203    } else { 
204      prev->next = other_it->current;
205      current->next = other_it->next;
206      current->prev = other_it->prev;
207      next->prev = other_it->current;
208      other_it->prev->next = current;
209      other_it->current->next = next;
210      other_it->current->prev = prev;
211      other_it->next->prev = current;
212    }
213    if (list->last == current) {
214      list->last = other_it->current;
215    }
216    if (other_it->list->last == other_it->current) {
217      other_it->list->last = current;
218    }
219    if (current == cycle_pt) {
220      cycle_pt = other_it->cycle_pt;
221    }
222    if (other_it->current == other_it->cycle_pt) {
223      other_it->cycle_pt = cycle_pt;
224    }
225    old_current = current;
226    current = other_it->current;
227    other_it->current = old_current;
228  }
229  ELIST2_LINK *ELIST2_ITERATOR::extract_sublist( 
230      ELIST2_ITERATOR *other_it) {               
231  #ifndef NDEBUG
232    constexpr ERRCODE BAD_EXTRACTION_PTS("Can't extract sublist from points on different lists");
233    constexpr ERRCODE DONT_EXTRACT_DELETED("Can't extract a sublist marked by deleted points");
234  #endif
235    constexpr ERRCODE BAD_SUBLIST("Can't find sublist end point in original list");
236    ELIST2_ITERATOR temp_it = *this;
237    ELIST2_LINK *end_of_new_list;
238  #ifndef NDEBUG
239    if (!other_it)
240      BAD_PARAMETER.error("ELIST2_ITERATOR::extract_sublist", ABORT, "other_it nullptr");
241    if (!list)
242      NO_LIST.error("ELIST2_ITERATOR::extract_sublist", ABORT);
243    if (list != other_it->list)
244      BAD_EXTRACTION_PTS.error("ELIST2_ITERATOR.extract_sublist", ABORT);
245    if (list->empty())
246      EMPTY_LIST.error("ELIST2_ITERATOR::extract_sublist", ABORT);
247    if (!current || !other_it->current)
248      DONT_EXTRACT_DELETED.error("ELIST2_ITERATOR.extract_sublist", ABORT);
249  #endif
250    ex_current_was_last = other_it->ex_current_was_last = false;
251    ex_current_was_cycle_pt = false;
252    other_it->ex_current_was_cycle_pt = false;
253    temp_it.mark_cycle_pt();
254    do {                         
255      if (temp_it.cycled_list()) { 
256        BAD_SUBLIST.error("ELIST2_ITERATOR.extract_sublist", ABORT);
257      }
258      if (temp_it.at_last()) {
259        list->last = prev;
260        ex_current_was_last = other_it->ex_current_was_last = true;
261      }
262      if (temp_it.current == cycle_pt) {
263        ex_current_was_cycle_pt = true;
264      }
265      if (temp_it.current == other_it->cycle_pt) {
266        other_it->ex_current_was_cycle_pt = true;
267      }
268      temp_it.forward();
269    }
270    while (temp_it.prev != other_it->current);
271    other_it->current->next = current;
272    current->prev = other_it->current;
273    end_of_new_list = other_it->current;
274    if (prev == other_it->current) {
275      list->last = nullptr;
276      prev = current = next = nullptr;
277      other_it->prev = other_it->current = other_it->next = nullptr;
278    } else {
279      prev->next = other_it->next;
280      other_it->next->prev = prev;
281      current = other_it->current = nullptr;
282      next = other_it->next;
283      other_it->prev = prev;
284    }
285    return end_of_new_list;
286  }
287  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-elst.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-elst2.cpp</div>
                </div>
                <div class="column column_space"><pre><code>161        prev = next = current;
162        other_it->prev = other_it->next = other_it->current;
163      } else { 
164        if (other_it->next == current) {
165          other_it->prev->next = current;
166          other_it->current->next = next;
167          current->next = other_it->current;
</pre></code></div>
                <div class="column column_space"><pre><code>180        prev = next = current;
181        other_it->prev = other_it->next = other_it->current;
182      } else { 
183        if (other_it->next == current) {
184          other_it->prev->next = current;
185          other_it->current->next = next;
186          other_it->current->prev = current;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    