
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 3.149606299212598%, Tokens: 9</h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-DockingManager.cpp</h3>
            <pre><code>1  #include <stdexcept>
2  #include "DockingManager.h"
3  #include "DockingSplitter.h"
4  #include "DockingCont.h"
5  #include "Gripper.h"
6  #include "Parameters.h"
7  using namespace std;
8  BOOL DockingManager::_isRegistered = FALSE;
9  static	HWND			hWndServer	= NULL;
10  static	HHOOK			gWinCallHook = NULL;
11  LRESULT CALLBACK focusWndProc(int nCode, WPARAM wParam, LPARAM lParam);
12  LRESULT CALLBACK focusWndProc(int nCode, WPARAM wParam, LPARAM lParam)
13  {
14  	if (nCode == HC_ACTION && hWndServer)
15  	{
16  		DockingManager *pDockingManager = (DockingManager *)::GetWindowLongPtr(hWndServer, GWLP_USERDATA);
17  		if (pDockingManager)
18  		{
19  			vector<DockingCont*> & vcontainer = pDockingManager->getContainerInfo();
20  			CWPSTRUCT * pCwp = (CWPSTRUCT*)lParam;
21  			if (pCwp->message == WM_KILLFOCUS)
22  			{
23  				for (int i = 0; i < DOCKCONT_MAX; ++i)
24  				{
25  					vcontainer[i]->SetActive(FALSE);	
26  				}
27  			}
28  			else if (pCwp->message == WM_SETFOCUS)
29  			{
30  				for (int i = 0; i < DOCKCONT_MAX; ++i)
31  				{
32  					vcontainer[i]->SetActive(IsChild(vcontainer[i]->getHSelf(), pCwp->hwnd));	
33  				}
34  			}
35  		}
36  	}
37  	return CallNextHookEx(gWinCallHook, nCode, wParam, lParam);
38  }
39  DockingManager::DockingManager()
40  {
41  	memset(_iContMap, -1, CONT_MAP_MAX * sizeof(int));
42  	_iContMap[0] = CONT_LEFT;
43  	_iContMap[1] = CONT_RIGHT;
44  	_iContMap[2] = CONT_TOP;
45  	_iContMap[3] = CONT_BOTTOM;
46  	for (int i = 0; i < DOCKCONT_MAX; ++i)
47  	{
48  		DockingCont *_pDockCont = new DockingCont;
49  		_vContainer.push_back(_pDockCont);
50  		DockingSplitter *_pSplitter = new DockingSplitter;
51  		_vSplitter.push_back(_pSplitter);
52  	}
53  }
54  DockingManager::~DockingManager()
55  {
56  	for (int i = 0; i < DOCKCONT_MAX; ++i)
57  	{
58  		delete _vSplitter[i];
59  	}
60  }
61  void DockingManager::init(HINSTANCE hInst, HWND hWnd, Window ** ppWin)
62  {
63  	Window::init(hInst, hWnd);
64  	if (!_isRegistered)
65  	{
66  		WNDCLASS clz{};
67  		clz.style = 0;
68  		clz.lpfnWndProc = staticWinProc;
69  		clz.cbClsExtra = 0;
70  		clz.cbWndExtra = 0;
71  		clz.hInstance = _hInst;
72  		clz.hIcon = NULL;
73  		clz.hCursor = ::LoadCursor(NULL, IDC_ARROW);
74  		clz.hbrBackground = NULL;
75  		clz.lpszMenuName = NULL;
76  		clz.lpszClassName = DSPC_CLASS_NAME;
77  		if (!::RegisterClass(&clz))
78  		{
79  			throw std::runtime_error("DockingManager::init : RegisterClass() function failed");
80  		}
81  		_isRegistered = TRUE;
82  	}
83  	_hSelf = ::CreateWindowEx(
84  					0,
85  					DSPC_CLASS_NAME,
86  					TEXT(""),
87  					WS_CHILD | WS_CLIPCHILDREN,
88  					CW_USEDEFAULT, CW_USEDEFAULT,
89  					CW_USEDEFAULT, CW_USEDEFAULT,
90  					_hParent,
91  					NULL,
92  					_hInst,
93  					(LPVOID)this);
94  	if (!_hSelf)
95  	{
96  		throw std::runtime_error("DockingManager::init : CreateWindowEx() function return null");
97  	}
98  	setClientWnd(ppWin);
99  	for (int iCont = 0; iCont < DOCKCONT_MAX; ++iCont)
100  	{
101  		_vContainer[iCont]->init(_hInst, _hSelf);
102  		_vContainer[iCont]->doDialog(false);
103  		::SetParent(_vContainer[iCont]->getHSelf(), _hParent);
104  		if ((iCont == CONT_TOP) || (iCont == CONT_BOTTOM))
105  			_vSplitter[iCont]->init(_hInst, _hParent, _hSelf, DMS_HORIZONTAL);
106  		else
107  			_vSplitter[iCont]->init(_hInst, _hParent, _hSelf, DMS_VERTICAL);
108  	}
109  	if (!hWndServer)
110  		hWndServer = _hSelf;
111  	CoInitialize(NULL);
112  	if (!gWinCallHook)	
113  		gWinCallHook = ::SetWindowsHookEx(WH_CALLWNDPROC, focusWndProc, hInst, GetCurrentThreadId());
114  	if (!gWinCallHook)
115  	{
116  		throw std::runtime_error("DockingManager::init : SetWindowsHookEx() function return null");
117  	}
118  	_dockData.hWnd = _hSelf;
119  	_isInitialized = TRUE;
120  }
121  void DockingManager::destroy()
122  {
123  	::DestroyWindow(_hSelf);
124  }
125  LRESULT CALLBACK DockingManager::staticWinProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
126  {
127  	DockingManager *pDockingManager = NULL;
128  	switch (message)
129  	{
130  		case WM_NCCREATE :
131  			pDockingManager = static_cast<DockingManager *>(reinterpret_cast<LPCREATESTRUCT>(lParam)->lpCreateParams);
132  			pDockingManager->_hSelf = hwnd;
133  			::SetWindowLongPtr(hwnd, GWLP_USERDATA, reinterpret_cast<LONG_PTR>(pDockingManager));
134  			return TRUE;
135  		default :
136  			pDockingManager = reinterpret_cast<DockingManager *>(::GetWindowLongPtr(hwnd, GWLP_USERDATA));
137  			if (!pDockingManager)
138  				return ::DefWindowProc(hwnd, message, wParam, lParam);
139  			return pDockingManager->runProc(hwnd, message, wParam, lParam);
140  	}
141  }
142  void DockingManager::updateContainerInfo(HWND hClient)
143  {
144  	for (size_t iCont = 0, len = _vContainer.size(); iCont < len; ++iCont)
145  	{
146  		if (_vContainer[iCont]->updateInfo(hClient) == TRUE)
147  		{
148  			break;
149  		}
150  	}
151  }
152  void DockingManager::showFloatingContainers(bool show)
153  {
154  	for (size_t i=0; i < _vContainer.size(); i++)
155  	{
156  		size_t iElementCnt = _vContainer[i]->getElementCnt();
157  		if (iElementCnt > 0)
158  		{
159  			if (0 < ::SendMessage(_vContainer[i]->getTabWnd(), TCM_GETITEMCOUNT, 0, 0)) 
160  				_vContainer[i]->display(show);
161  		}
162  	}
163  }
164  LRESULT DockingManager::runProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
165  {
166  	switch (message)
167  	{
168  		case WM_ERASEBKGND:
169  		{
170  			if (!NppDarkMode::isEnabled())
171  			{
172  				break;
173  			}
174  			RECT rc{};
175  			::GetClientRect(hwnd, &rc);
176  			::FillRect(reinterpret_cast<HDC>(wParam), &rc, NppDarkMode::getDarkerBackgroundBrush());
177  			return TRUE;
178  		}
179  		case WM_NCACTIVATE:
180  		{
181  			for (size_t iCont = DOCKCONT_MAX, len = _vContainer.size(); iCont < len; ++iCont)
182  			{
183  				::SendMessage(_vContainer[iCont]->getHSelf(), WM_NCACTIVATE, wParam, static_cast<LPARAM>(-1));
184  			}
185  			if (static_cast<int>(lParam) != -1)
186  			{
187  				::SendMessage(_hParent, WM_NCACTIVATE, wParam, static_cast<LPARAM>(-1));
188  			}
189  			break;
190  		}
191  		case WM_MOVE:
192  		case WM_SIZE:
193  		{
194  			resize();
195  			break;
196  		}
197  		case WM_DESTROY:
198  		{
199  			if (hWndServer == hwnd)
200  			{
201  				UnhookWindowsHookEx(gWinCallHook);
202  				gWinCallHook = NULL;
203  				hWndServer = NULL;
204  			}
205  			if (_hImageList != NULL)
206  			{
207  				::ImageList_Destroy(_hImageList);
208  			}
209  			for (int32_t i = static_cast<int32_t>(_vContainer.size()); i > 0; i--)
210  			{
211  				_vContainer[i-1]->destroy();
212  				delete _vContainer[i-1];
213  			}
214  			CoUninitialize();
215  			break;
216  		}
217  		case DMM_LBUTTONUP:	
218  		{
219  			if (::GetActiveWindow() != _hParent)
220  				break;
221  			for (int i = 0; i < DOCKCONT_MAX; ++i)
222  			{
223  				_vContainer[i]->SetActive(IsChild(_vContainer[i]->getHSelf(), ::GetFocus()));
224  			}
225  			return TRUE;
226  		}
227  		case DMM_MOVE:
228  		{
229  			Gripper *pGripper = new Gripper;
230  			pGripper->init(_hInst, _hParent);
231  			pGripper->startGrip(reinterpret_cast<DockingCont*>(lParam), this);
232  			break;
233  		}
234  		case DMM_MOVE_SPLITTER:
235  		{
236  			int offset = static_cast<int32_t>(wParam);
237  			for (int iCont = 0; iCont < DOCKCONT_MAX; ++iCont)
238  			{
239  				if (_vSplitter[iCont]->getHSelf() == reinterpret_cast<HWND>(lParam))
240  				{
241  					switch (iCont)
242  					{
243  						case CONT_TOP:
244  							_dockData.rcRegion[iCont].bottom -= offset;
245  							if (_dockData.rcRegion[iCont].bottom < 0)
246  							{
247  								_dockData.rcRegion[iCont].bottom = 0;
248  							}
249  							if ((_rcWork.bottom < (-SPLITTER_WIDTH)) && (offset < 0))
250  							{
251  								_dockData.rcRegion[iCont].bottom += offset;
252  							}
253  							break;
254  						case CONT_BOTTOM:
255  							_dockData.rcRegion[iCont].bottom   += offset;
256  							if (_dockData.rcRegion[iCont].bottom < 0)
257  							{
258  								_dockData.rcRegion[iCont].bottom   = 0;
259  							}
260  							if ((_rcWork.bottom < (-SPLITTER_WIDTH)) && (offset > 0))
261  							{
262  								_dockData.rcRegion[iCont].bottom -= offset;
263  							}
264  							break;
265  						case CONT_LEFT:
266  							_dockData.rcRegion[iCont].right    -= offset;
267  							if (_dockData.rcRegion[iCont].right < 0)
268  							{
269  								_dockData.rcRegion[iCont].right = 0;
270  							}
271  							if ((_rcWork.right < SPLITTER_WIDTH) && (offset < 0))
272  							{
273  								_dockData.rcRegion[iCont].right += offset;
274  							}
275  							break;
276  						case CONT_RIGHT:
277  							_dockData.rcRegion[iCont].right    += offset;
278  							if (_dockData.rcRegion[iCont].right < 0)
279  							{
280  								_dockData.rcRegion[iCont].right = 0;
281  							}
282  							if ((_rcWork.right < SPLITTER_WIDTH) && (offset > 0))
283  							{
284  								_dockData.rcRegion[iCont].right -= offset;
285  							}
286  							break;
287  					}
288  					resize();
289  					break;
290  				}
291  			}
292  			break;
293  		}
294  		case DMM_DOCK:
295  		case DMM_FLOAT:
296  		{
297  			toggleActiveTb(reinterpret_cast<DockingCont*>(lParam), message);
298  			return FALSE;
299  		}
300  		case DMM_CLOSE:
301  		{
302  			tTbData	TbData	= *(reinterpret_cast<DockingCont*>(lParam))->getDataOfActiveTb();
303  			LRESULT res = SendNotify(TbData.hClient, DMN_CLOSE);	
304  			return res;
305  		}
306  		case DMM_FLOATALL:
307  		{
308  			toggleVisTb(reinterpret_cast<DockingCont*>(lParam), DMM_FLOAT);
309  			return FALSE;
310  		}
311  		case DMM_DOCKALL:
312  		{
313  			toggleVisTb(reinterpret_cast<DockingCont*>(lParam), DMM_DOCK);
314  			return FALSE;
315  		}
316  		case DMM_GETIMAGELIST:
317  		{
318  			return reinterpret_cast<LPARAM>(_hImageList);
319  		}
320  		case DMM_GETICONPOS:
321  		{
322  			for (size_t uImageCnt = 0, len = _vImageList.size(); uImageCnt < len; ++uImageCnt)
323  			{
324  				if (reinterpret_cast<HWND>(lParam) == _vImageList[uImageCnt])
325  				{
326  					return uImageCnt;
327  				}
328  			}
329  			return -1;
330  		}
331  		default :
332  			break;
333  	}
334  	return ::DefWindowProc(_hSelf, message, wParam, lParam);
335  }
336  void DockingManager::resize()
337  {
338      reSizeTo(_rect);
339  }
340  void DockingManager::reSizeTo(RECT & rc)
341  {
342  	_rect = rc;
343  	_rcWork	= rc;
344  	if (_isInitialized == FALSE)
345  		return;
346  	_dockData.rcRegion[CONT_TOP].left      = rc.left;
347  	_dockData.rcRegion[CONT_TOP].top       = rc.top;
348  	_dockData.rcRegion[CONT_TOP].right     = rc.right-rc.left;
349  	_vSplitter[CONT_TOP]->display(false);
350  	if (_vContainer[CONT_TOP]->isVisible())
351  	{
352  		_rcWork.top		+= _dockData.rcRegion[CONT_TOP].bottom + SPLITTER_WIDTH;
353  		_rcWork.bottom	-= _dockData.rcRegion[CONT_TOP].bottom + SPLITTER_WIDTH;
354  		RECT	rc = {_dockData.rcRegion[CONT_TOP].left  ,
355  					  _dockData.rcRegion[CONT_TOP].top + _dockData.rcRegion[CONT_TOP].bottom,
356  					  _dockData.rcRegion[CONT_TOP].right ,
357  					  SPLITTER_WIDTH};
358  		_vSplitter[CONT_TOP]->reSizeTo(rc);
359  	}
360  	_dockData.rcRegion[CONT_BOTTOM].left   = rc.left;
361  	_dockData.rcRegion[CONT_BOTTOM].top    = rc.top + rc.bottom - _dockData.rcRegion[CONT_BOTTOM].bottom;
362  	_dockData.rcRegion[CONT_BOTTOM].right  = rc.right-rc.left;
363  	RECT		rcBottom	= _dockData.rcRegion[CONT_BOTTOM];
364  	_vSplitter[CONT_BOTTOM]->display(false);
365  	if (_vContainer[CONT_BOTTOM]->isVisible())
366  	{
367  		_rcWork.bottom	-= _dockData.rcRegion[CONT_BOTTOM].bottom + SPLITTER_WIDTH;
368  		if (_rcWork.bottom < rc.top)
369  		{
370  			rcBottom.top     = _rcWork.top + rc.top + SPLITTER_WIDTH;
371  			rcBottom.bottom += _rcWork.bottom - rc.top;
372  			_rcWork.bottom = rc.top;
373  		}
374  		if ((rcBottom.bottom + SPLITTER_WIDTH) < 0)
375  		{
376  			_rcWork.bottom = rc.bottom - _dockData.rcRegion[CONT_TOP].bottom;
377  		}
378  		RECT	rc = {rcBottom.left,
379  					  rcBottom.top - SPLITTER_WIDTH,
380  					  rcBottom.right,
381  					  SPLITTER_WIDTH};
382  		_vSplitter[CONT_BOTTOM]->reSizeTo(rc);
383  	}
384  	_dockData.rcRegion[CONT_LEFT].left     = rc.left;
385  	_dockData.rcRegion[CONT_LEFT].top      = _rcWork.top;
386  	_dockData.rcRegion[CONT_LEFT].bottom   = _rcWork.bottom;
387  	_vSplitter[CONT_LEFT]->display(false);
388  	if (_vContainer[CONT_LEFT]->isVisible())
389  	{
390  		_rcWork.left		+= _dockData.rcRegion[CONT_LEFT].right + SPLITTER_WIDTH;
391  		_rcWork.right	-= _dockData.rcRegion[CONT_LEFT].right + SPLITTER_WIDTH;
392  		RECT	rc = {_dockData.rcRegion[CONT_LEFT].right,
393  					  _dockData.rcRegion[CONT_LEFT].top,
394  					  SPLITTER_WIDTH,
395  					  _dockData.rcRegion[CONT_LEFT].bottom};
396  		_vSplitter[CONT_LEFT]->reSizeTo(rc);
397  	}
398  	_dockData.rcRegion[CONT_RIGHT].left    = rc.right - _dockData.rcRegion[CONT_RIGHT].right;
399  	_dockData.rcRegion[CONT_RIGHT].top     = _rcWork.top;
400  	_dockData.rcRegion[CONT_RIGHT].bottom  = _rcWork.bottom;
401  	RECT		rcRight		= _dockData.rcRegion[CONT_RIGHT];
402  	_vSplitter[CONT_RIGHT]->display(false);
403  	if (_vContainer[CONT_RIGHT]->isVisible())
404  	{
405  		_rcWork.right	-= _dockData.rcRegion[CONT_RIGHT].right + SPLITTER_WIDTH;
406  		if (_rcWork.right < 15)
407  		{
408  			rcRight.left    = _rcWork.left + 15 + SPLITTER_WIDTH;
409  			rcRight.right  += _rcWork.right - 15;
410  			_rcWork.right	= 15;
411  		}
412  		RECT	rc = {rcRight.left - SPLITTER_WIDTH,
413  					  rcRight.top,
414  					  SPLITTER_WIDTH,
415  					  rcRight.bottom};
416  		_vSplitter[CONT_RIGHT]->reSizeTo(rc);
417  	}
418  	if (_vContainer[CONT_BOTTOM]->isVisible())
419  	{
420  		::SetWindowPos(_vContainer[CONT_BOTTOM]->getHSelf(), NULL,
421  					   rcBottom.left  ,
422  					   rcBottom.top   ,
423  					   rcBottom.right ,
424  					   rcBottom.bottom,
425  					   SWP_NOZORDER);
426  		_vSplitter[CONT_BOTTOM]->display();
427  	}
428  	if (_vContainer[CONT_TOP]->isVisible())
429  	{
430  		::SetWindowPos(_vContainer[CONT_TOP]->getHSelf(), NULL,
431  					   _dockData.rcRegion[CONT_TOP].left  ,
432  					   _dockData.rcRegion[CONT_TOP].top   ,
433  					   _dockData.rcRegion[CONT_TOP].right ,
434  					   _dockData.rcRegion[CONT_TOP].bottom,
435  					   SWP_NOZORDER);
436  		_vSplitter[CONT_TOP]->display();
437  	}
438  	if (_vContainer[CONT_RIGHT]->isVisible())
439  	{
440  		::SetWindowPos(_vContainer[CONT_RIGHT]->getHSelf(), NULL,
441  					   rcRight.left  ,
442  					   rcRight.top   ,
443  					   rcRight.right ,
444  					   rcRight.bottom,
445  					   SWP_NOZORDER);
446  		_vSplitter[CONT_RIGHT]->display();
447  	}
448  	if (_vContainer[CONT_LEFT]->isVisible())
449  	{
450  		::SetWindowPos(_vContainer[CONT_LEFT]->getHSelf(), NULL,
451  					   _dockData.rcRegion[CONT_LEFT].left  ,
452  					   _dockData.rcRegion[CONT_LEFT].top   ,
453  					   _dockData.rcRegion[CONT_LEFT].right ,
454  					   _dockData.rcRegion[CONT_LEFT].bottom,
455  					   SWP_NOZORDER);
456  		_vSplitter[CONT_LEFT]->display();
457  	}
458  	(*_ppMainWindow)->reSizeTo(_rcWork);
459  }
460  void DockingManager::createDockableDlg(tTbData data, int iCont, bool isVisible)
461  {
462  	if ((data.uMask & DWS_ICONTAB) && data.hIconTab != NULL)
463  	{
464  		if (_hImageList == NULL)
465  		{
466  			int iconDpiDynamicalSize = NppParameters::getInstance()._dpiManager.scaleY(12) + 2;
467  			_hImageList = ::ImageList_Create(iconDpiDynamicalSize, iconDpiDynamicalSize, ILC_COLOR32 | ILC_MASK, 0, 0);
468  		}
469  		::ImageList_AddIcon(_hImageList, data.hIconTab);
470  		_vImageList.push_back(data.hClient);
471  	}
472  	if ((data.uMask & DWS_USEOWNDARKMODE) != DWS_USEOWNDARKMODE && NppDarkMode::isEnabledForPlugins())
473  	{
474  		NppDarkMode::autoSubclassAndThemePluginDockWindow(data.hClient);
475  	}
476  	RECT				rc			= {0,0,0,0};
477  	DockingCont*		pCont		= NULL;
478  	if (memcmp(&data.rcFloat, &rc, sizeof(RECT)) == 0)
479  	{
480  		::GetWindowRect(data.hClient, &data.rcFloat);
481  		if (iCont == -1)
482  		{
483  			isVisible = (::IsWindowVisible(data.hClient) == TRUE);
484  			if (data.uMask & DWS_DF_FLOATING)
485  			{
486  				pCont = new DockingCont;
487  				_vContainer.push_back(pCont);
488  				pCont->init(_hInst, _hSelf);
489  				pCont->doDialog(isVisible, true);
490  				data.iPrevCont = (data.uMask & 0x30000000) >> 28;
491  				iCont = static_cast<int32_t>(_vContainer.size()) - 1;
492  			}
493  			else
494  			{
495  				iCont = (data.uMask & 0x30000000) >> 28;
496  				data.iPrevCont = -1;
497  			}
498  		}
499  	}
500  	else if ((iCont >= DOCKCONT_MAX) || (data.iPrevCont >= DOCKCONT_MAX))
501  	{
502  		if (iCont >= DOCKCONT_MAX)
503  		{
504  			if (_iContMap[iCont] == -1)
505  			{
506  				pCont = new DockingCont;
507  				_vContainer.push_back(pCont);
508  				pCont->init(_hInst, _hSelf);
509  				pCont->doDialog(isVisible, true);
510  				_iContMap[iCont] = static_cast<int32_t>(_vContainer.size()) - 1;
511  			}
512  			iCont = _iContMap[iCont];
513  		}
514  		else
515  		{
516  			if (_iContMap[data.iPrevCont] == -1)
517  			{
518  				pCont = new DockingCont;
519  				_vContainer.push_back(pCont);
520  				pCont->init(_hInst, _hSelf);
521  				pCont->doDialog(false, true);
522  				pCont->reSizeToWH(data.rcFloat);
523  				_iContMap[data.iPrevCont] = static_cast<int32_t>(_vContainer.size()) - 1;
524  			}
525  			data.iPrevCont = _iContMap[data.iPrevCont];
526  		}
527  	}
528  	if (_vContainer.size() > static_cast<size_t>(iCont) && _vContainer[iCont] != nullptr)
529  	{
530  		_vContainer[iCont]->createToolbar(data);
531  		for (const auto& cont : _vContainer)
532  		{
533  			if (cont->isVisible() && cont != _vContainer[iCont])
534  			{
535  				::RedrawWindow(cont->getHSelf(), nullptr, nullptr, RDW_INVALIDATE);
536  			}
537  		}
538  	}
539  	if (iCont < DOCKCONT_MAX)
540  		SendNotify(data.hClient, MAKELONG(DMN_DOCK, iCont));
541  	else
542  		SendNotify(data.hClient, MAKELONG(DMN_FLOAT, iCont));
543  }
544  void DockingManager::setActiveTab(int iCont, int iItem)
545  {
546  	if ((iCont == -1) || (_iContMap[iCont] == -1))
547  		return;
548  	_vContainer[_iContMap[iCont]]->setActiveTb(iItem);
549  }
550  void DockingManager::showDockableDlg(HWND hDlg, BOOL view)
551  {
552  	for (size_t i = 0, len = _vContainer.size(); i < len; ++i)
553  	{
554  		tTbData *pTbData = _vContainer[i]->findToolbarByWnd(hDlg);
555  		if (pTbData != NULL)
556  		{
557  			_vContainer[i]->showToolbar(pTbData, view);
558  			return;
559  		}
560  	}
561  }
562  void DockingManager::showDockableDlg(TCHAR* pszName, BOOL view)
563  {
564  	for (size_t i = 0, len = _vContainer.size(); i < len; ++i)
565  	{
566  		tTbData *pTbData = _vContainer[i]->findToolbarByName(pszName);
567  		if (pTbData != NULL)
568  		{
569  			_vContainer[i]->showToolbar(pTbData, view);
570  			return;
571  		}
572  	}
573  }
574  LRESULT DockingManager::SendNotify(HWND hWnd, UINT message)
575  {
576  	NMHDR nmhdr{};
577  	nmhdr.code		= message;
578  	nmhdr.hwndFrom	= _hParent;
579  	nmhdr.idFrom	= ::GetDlgCtrlID(_hParent);
580  	::SendMessage(hWnd, WM_NOTIFY, nmhdr.idFrom, reinterpret_cast<LPARAM>(&nmhdr));
581  	return ::GetWindowLongPtr(hWnd, DWLP_MSGRESULT);
582  }
583  void DockingManager::setDockedContSize(int iCont, int iSize)
584  {
585  	if ((iCont == CONT_TOP) || (iCont == CONT_BOTTOM))
586  		_dockData.rcRegion[iCont].bottom = iSize;
587  	else if ((iCont == CONT_LEFT) || (iCont == CONT_RIGHT))
588  		_dockData.rcRegion[iCont].right = iSize;
589  	else
590  		return;
591  	resize();
592  }
593  int DockingManager::getDockedContSize(int iCont)
594  {
595  	if ((iCont == CONT_TOP) || (iCont == CONT_BOTTOM))
596  		return _dockData.rcRegion[iCont].bottom;
597  	else if ((iCont == CONT_LEFT) || (iCont == CONT_RIGHT))
598  		return _dockData.rcRegion[iCont].right;
599  	else
600  		return -1;
601  }
602  DockingCont* DockingManager::toggleActiveTb(DockingCont* pContSrc, UINT message, BOOL bNew, LPRECT prcFloat)
603  {
604  	tTbData			TbData		= *pContSrc->getDataOfActiveTb();
605  	int				iContSrc	= GetContainer(pContSrc);
606  	int				iContPrev	= TbData.iPrevCont;
607  	BOOL			isCont		= ContExists(iContPrev);
608  	DockingCont*	pContTgt	= NULL;
609  	if (prcFloat != NULL)
610  	{
611  		TbData.rcFloat = *prcFloat;
612  	}
613  	if ((isCont == FALSE) || (bNew == TRUE))
614  	{
615  		int	iContNew = FindEmptyContainer();
616  		if (iContNew == -1)
617  		{
618  			pContTgt = new DockingCont;
619  			pContTgt->init(_hInst, _hSelf);
620  			pContTgt->doDialog(true, true);
621  			if ((bNew == FALSE) || (!pContSrc->isFloating()))
622  				TbData.iPrevCont = iContSrc;
623  			pContTgt->createToolbar(TbData);
624  			_vContainer.push_back(pContTgt);
625  		}
626  		else
627  		{
628  			pContTgt = _vContainer[iContNew];
629  			if ((pContSrc->isFloating()) != (pContTgt->isFloating()))
630                  TbData.iPrevCont = iContSrc;
631  			pContTgt->createToolbar(TbData);
632  		}
633  	}
634  	else
635  	{
636  		pContTgt = _vContainer[iContPrev];
637  		TbData.iPrevCont = iContSrc;
638  		pContTgt->createToolbar(TbData);
639  	}
640  	SendNotify(TbData.hClient, MAKELONG(message==DMM_DOCK?DMN_DOCK:DMN_FLOAT, GetContainer(pContTgt)));
641  	_vContainer[iContSrc]->removeToolbar(TbData);
642  	return pContTgt;
643  }
644  DockingCont* DockingManager::toggleVisTb(DockingCont* pContSrc, UINT message, LPRECT prcFloat)
645  {
646  	vector<tTbData*>	vTbData		= pContSrc->getDataOfVisTb();
647  	tTbData*			pTbData		= pContSrc->getDataOfActiveTb();
648  	int					iContSrc	= GetContainer(pContSrc);
649  	int					iContPrev	= pTbData->iPrevCont;
650  	BOOL				isCont		= ContExists(iContPrev);
651  	DockingCont*		pContTgt	= NULL;
652  	pContSrc->doDialog(false);
653  	resize();
654  	for (size_t iTb = 0, len = vTbData.size(); iTb < len; ++iTb)
655  	{
656  		tTbData		TbData = *vTbData[iTb];
657  		if (prcFloat != NULL)
658  		{
659  			TbData.rcFloat = *prcFloat;
660  		}
661  		if (isCont == FALSE)
662  		{
663  			pContTgt = new DockingCont;
664  			pContTgt->init(_hInst, _hSelf);
665  			pContTgt->doDialog(true, true);
666  			TbData.iPrevCont = iContSrc;
667  			pContTgt->createToolbar(TbData);
668  			_vContainer.push_back(pContTgt);
669  			isCont	= TRUE;
670  			iContPrev = GetContainer(pContTgt);
671  		}
672  		else
673  		{
674  			pContTgt = _vContainer[iContPrev];
675  			TbData.iPrevCont = iContSrc;
676  			pContTgt->createToolbar(TbData);
677  		}
678  		SendNotify(TbData.hClient, MAKELONG(message==DMM_DOCK?DMN_DOCK:DMN_FLOAT, GetContainer(pContTgt)));
679  		_vContainer[iContSrc]->removeToolbar(TbData);
680  	}
681  	_vContainer[iContPrev]->setActiveTb(pTbData);
682  	return pContTgt;
683  }
684  void DockingManager::toggleActiveTb(DockingCont* pContSrc, DockingCont* pContTgt)
685  {
686  	tTbData		TbData		= *pContSrc->getDataOfActiveTb();
687  	toggleTb(pContSrc, pContTgt, TbData);
688  }
689  void DockingManager::toggleVisTb(DockingCont* pContSrc, DockingCont* pContTgt)
690  {
691  	vector<tTbData*>	vTbData		= pContSrc->getDataOfVisTb();
692  	tTbData*			pTbData		= pContSrc->getDataOfActiveTb();
693  	pContSrc->doDialog(false);
694  	resize();
695  	for (size_t iTb = 0, len = vTbData.size(); iTb < len; ++iTb)
696  	{
697  		tTbData		TbData = *vTbData[iTb];
698  		toggleTb(pContSrc, pContTgt, TbData);
699  	}
700  	pContTgt->setActiveTb(pTbData);
701  }
702  void DockingManager::toggleTb(DockingCont* pContSrc, DockingCont* pContTgt, tTbData TbData)
703  {
704  	int					iContSrc	= GetContainer(pContSrc);
705  	int					iContTgt	= GetContainer(pContTgt);
706  	if (((iContSrc <  DOCKCONT_MAX) && (iContTgt >= DOCKCONT_MAX)) ||
707  		((iContSrc >= DOCKCONT_MAX) && (iContTgt <  DOCKCONT_MAX)))
708  	{
709  		TbData.iPrevCont = iContSrc;
710  	}
711  	if (iContTgt < DOCKCONT_MAX)
712  		SendNotify(TbData.hClient, MAKELONG(DMN_DOCK, iContTgt));
713  	else
714  		SendNotify(TbData.hClient, MAKELONG(DMN_FLOAT, iContTgt));
715  	pContTgt->createToolbar(TbData);
716  	_vContainer[iContSrc]->removeToolbar(TbData);
<span onclick='openModal()' class='match'>717  }
718  BOOL DockingManager::ContExists(size_t iCont)
719  {
720  	BOOL	bRet = FALSE;
721  	if (iCont < _vContainer.size())
722  	{
723  		bRet = TRUE;
724  	}
725  	return bRet;
726  }
</span>727  int DockingManager::GetContainer(DockingCont* pCont)
728  {
729  	int iRet = -1;
730  	for (size_t iCont = 0, len = _vContainer.size(); iCont < len; ++iCont)
731  	{
732  		if (_vContainer[iCont] == pCont)
733  		{
734  			iRet = static_cast<int32_t>(iCont);
735  			break;
736  		}
737  	}
738  	return iRet;
739  }
740  int DockingManager::FindEmptyContainer()
741  {
742      int      iRetCont       = -1;
743      BOOL*    pPrevDockList  = (BOOL*) new BOOL[_vContainer.size()+1];
744      BOOL*    pArrayPos      = &pPrevDockList[1];
745      for (size_t iCont = 0, len = _vContainer.size()+1; iCont < len; ++iCont)
746      {
747          pPrevDockList[iCont] = FALSE;
748      }
749      for (size_t iCont = 0; iCont < DOCKCONT_MAX; ++iCont)
750      {
751          vector<tTbData*>    vTbData = _vContainer[iCont]->getDataOfAllTb();
752          for (size_t iTb = 0, len = vTbData.size(); iTb < len; ++iTb)
753          {
754              pArrayPos[vTbData[iTb]->iPrevCont] = TRUE;
755          }
756      }
757      for (size_t iCont = DOCKCONT_MAX, len = _vContainer.size(); iCont < len; ++iCont)
758      {
759          if (pArrayPos[iCont] == FALSE)
760          {
761              if (!_vContainer[iCont]->isVisible())
762              {
763  				iRetCont = static_cast<int32_t>(iCont);
764                  break;
765              }
766          }
767      }
768      delete [] pPrevDockList;
769      return iRetCont;
770  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-sock.cpp</h3>
            <pre><code>1  class TSockSys{
2  public:
3    static bool Active;
4    static HWND SockWndHnd;
5    static HWND DnsWndHnd;
6    static HWND ReportWndHnd;
7    static HWND TimerWndHnd;
8    static UINT SockMsgHnd;
9    static UINT SockErrMsgHnd;
10    static UINT DnsMsgHnd;
11    static UINT ReportMsgHnd;
12    static uint64 SockBytesRead;
13    static uint64 SockBytesWritten;
14    static THash<TInt, TUInt64> SockIdToHndH;
15    static THash<TUInt64, TInt> SockHndToIdH;
16    static THash<TUInt64, TInt> SockHndToEventIdH;
17    static TIntH SockTimerIdH;
18    static TUInt64H ActiveSockHndH;
19    static THash<TUInt64, PSockHost> HndToSockHostH;
20    static THash<TInt, PSockEvent> IdToSockEventH;
21    static TIntH ActiveSockEventIdH;
22    static THash<TInt, PReportEvent> IdToReportEventH;
23    static THash<TInt, ATimer> IdToTimerH;
24  public:
25    static TStr GetErrStr(const int ErrCd);
26    static LRESULT CALLBACK MainWndProc(
27     HWND WndHnd, UINT Msg, WPARAM wParam, LPARAM lParam);
28  public:
29    TSockSys();
30    ~TSockSys();
31    TSockSys& operator=(const TSockSys&){Fail; return *this;}
32    static HWND GetSockWndHnd(){IAssert(Active); return SockWndHnd;}
33    static HWND GetDnsWndHnd(){IAssert(Active); return DnsWndHnd;}
34    static HWND GetReportWndHnd(){IAssert(Active); return ReportWndHnd;}
35    static HWND GetTimerWndHnd(){IAssert(Active); return TimerWndHnd;}
36    static UINT GetSockMsgHnd(){IAssert(Active); return SockMsgHnd;}
37    static UINT GetSockErrMsgHnd(){IAssert(Active); return SockErrMsgHnd;}
38    static UINT GetDnsMsgHnd(){IAssert(Active); return DnsMsgHnd;}
39    static UINT GetReportMsgHnd(){IAssert(Active); return ReportMsgHnd;}
40    static int GetAllSockEventCdSet(){
41      return (FD_READ|FD_WRITE|FD_OOB|FD_ACCEPT|FD_CONNECT|FD_CLOSE);}
42    static uint64 GetSockBytesRead(){return SockBytesRead;}
43    static uint64 GetSockBytesWritten(){return SockBytesWritten;}
44    static void AddSock(
45     const int& SockId, const TSockHnd& SockHnd, const int& SockEventId);
46    static void DelSock(const int& SockId);
47    static bool IsSockId(const int& SockId){
48      IAssert(Active); return SockIdToHndH.IsKey(SockId);}
49    static bool IsSockHnd(const TSockHnd& SockHnd){
50      IAssert(Active); return SockHndToIdH.IsKey(SockHnd);}
51    static TSockHnd GetSockHnd(const int& SockId){
52      IAssert(Active); return TSockHnd(SockIdToHndH.GetDat(SockId));}
53    static TSockHnd GetSockId(const TSockHnd& SockHnd){
54      IAssert(Active); return SockHndToIdH.GetDat(SockHnd);}
55    static int GetSockEventId(const TSockHnd& SockHnd){
56      IAssert(Active); return SockHndToEventIdH.GetDat(SockHnd);}
57    static void AddSockTimer(const int& SockId, const int& MSecs){
58      UINT ErrCd=(UINT)SetTimer(GetSockWndHnd(), SockId, uint(MSecs), NULL);
59      ESAssert(ErrCd!=0);
60      SockTimerIdH.AddKey(SockId);}
61    static void DelIfSockTimer(const int& SockId){
62      KillTimer(GetSockWndHnd(), SockId);
63      SockTimerIdH.DelIfKey(SockId);}
64    static bool IsSockActive(const TSockHnd& SockHnd){
65      return ActiveSockHndH.IsKey(SockHnd);}
66    static void SetSockActive(const TSockHnd& SockHnd, const bool& Active){
67      IAssert(
68       (Active&&!IsSockActive(SockHnd))||
69       (!Active&&IsSockActive(SockHnd)));
70      if (Active){ActiveSockHndH.AddKey(SockHnd);}
71      else {ActiveSockHndH.DelKey(SockHnd);}}
72    static const int MxSockBfL;
73    static void AddSockHost(const TUInt64& SockHostHnd, const PSockHost& SockHost){
74      HndToSockHostH.AddDat(SockHostHnd, SockHost);}
75    static void DelSockHost(const TUInt64& SockHostHnd){
76      HndToSockHostH.DelKey(SockHostHnd);}
77    static bool IsSockHost(const TUInt64& SockHostHnd){
78      return HndToSockHostH.IsKey(SockHostHnd);}
79    static PSockHost GetSockHost(const TUInt64& SockHostHnd){
80      return HndToSockHostH.GetDat(SockHostHnd);}
81    static void AddSockEvent(const PSockEvent& SockEvent){
82      IAssert(!IsSockEvent(SockEvent));
83      IdToSockEventH.AddDat(SockEvent->GetSockEventId(), SockEvent);}
84    static void DelSockEvent(const PSockEvent& SockEvent){
85      IdToSockEventH.DelKey(SockEvent->GetSockEventId());}
86    static bool IsSockEvent(const int& SockEventId){
87      return IdToSockEventH.IsKey(TInt(SockEventId));}
88    static bool IsSockEvent(const PSockEvent& SockEvent){
89      return IdToSockEventH.IsKey(TInt(SockEvent->GetSockEventId()));}
90    static PSockEvent GetSockEvent(const int& SockEventId){
91      return IdToSockEventH.GetDat(SockEventId);}
92    static bool IsSockEventActive(const int& SockEventId){
93      return ActiveSockEventIdH.IsKey(SockEventId);}
94    static void SetSockEventActive(const int& SockEventId, const bool& Active){
95      IAssert(
96       (Active&&!IsSockEventActive(SockEventId))||
97       (!Active&&IsSockEventActive(SockEventId)));
98      if (Active){ActiveSockEventIdH.AddKey(SockEventId);}
99      else {ActiveSockEventIdH.DelKey(SockEventId);}}
100    static void AddReportEvent(const PReportEvent& ReportEvent){
101      IAssert(!IsReportEvent(ReportEvent));
102      IdToReportEventH.AddDat(TInt(ReportEvent->GetReportEventId()), ReportEvent);}
103    static void DelReportEvent(const PReportEvent& ReportEvent){
104      IdToReportEventH.DelKey(TInt(ReportEvent->GetReportEventId()));}
105    static bool IsReportEvent(const PReportEvent& ReportEvent){
106      return IdToReportEventH.IsKey(TInt(ReportEvent->GetReportEventId()));}
107    static PReportEvent GetReportEvent(const int& ReportEventId){
108      return IdToReportEventH.GetDat(ReportEventId);}
109    static void AddTimer(const ATimer& Timer){
110      IAssert(!IsTimer(Timer->GetTimerId()));
111      IdToTimerH.AddDat(TInt(Timer->GetTimerId()), Timer);}
112    static void DelTimer(const int& TimerId){
113      IdToTimerH.DelKey(TimerId);}
114    static bool IsTimer(const int& TimerId){
115      return IdToTimerH.IsKey(TimerId);}
116    static ATimer GetTimer(const int& TimerId){
117      return IdToTimerH.GetDat(TimerId);}
118    static void OnRead(const TSockHnd& SockHnd, const PSockEvent& SockEvent);
119    static void OnWrite(const TSockHnd& SockHnd, const PSockEvent& SockEvent);
120    static void OnOob(const TSockHnd& SockHnd, const PSockEvent& SockEvent);
121    static void OnAccept(const TSockHnd& SockHnd, const PSockEvent& SockEvent);
122    static void OnConnect(const TSockHnd& SockHnd, const PSockEvent& SockEvent);
123    static void OnClose(const TSockHnd& SockHnd, const PSockEvent& SockEvent);
124    static void OnTimeOut(const TSockHnd& SockHnd, const PSockEvent& SockEvent);
125    static void OnError(
126     const TSockHnd& SockHnd, const PSockEvent& SockEvent, const int& ErrCd);
127    static void OnGetHost(const PSockHost& SockHost);
128    static TStr GetStatusStr();
129  };
130  bool TSockSys::Active=false;
131  HWND TSockSys::SockWndHnd=0;
132  HWND TSockSys::DnsWndHnd=0;
133  HWND TSockSys::ReportWndHnd=0;
134  HWND TSockSys::TimerWndHnd=0;
135  UINT TSockSys::SockMsgHnd=0;
136  UINT TSockSys::SockErrMsgHnd=0;
137  UINT TSockSys::DnsMsgHnd=0;
138  UINT TSockSys::ReportMsgHnd=0;
139  uint64 TSockSys::SockBytesRead=0;
140  uint64 TSockSys::SockBytesWritten=0;
141  THash<TInt, TUInt64> TSockSys::SockIdToHndH;
142  THash<TUInt64, TInt> TSockSys::SockHndToIdH;
143  THash<TUInt64, TInt> TSockSys::SockHndToEventIdH;
144  TIntH TSockSys::SockTimerIdH;
145  TUInt64H TSockSys::ActiveSockHndH;
146  const int TSockSys::MxSockBfL=100*1024;
147  THash<TUInt64, PSockHost> TSockSys::HndToSockHostH;
148  THash<TInt, PSockEvent> TSockSys::IdToSockEventH;
149  TIntH TSockSys::ActiveSockEventIdH;
150  THash<TInt, PReportEvent> TSockSys::IdToReportEventH;
151  THash<TInt, ATimer> TSockSys::IdToTimerH;
152  TSockSys SockSys; 
153  TStr TSockSys::GetErrStr(const int ErrCd){
154    switch (ErrCd){
155      case WSASYSNOTREADY: return "Underlying network subsystem is not ready for network communication.";
156      case WSAVERNOTSUPPORTED: return "The version of Windows Sockets support requested is not provided by this particular Windows Sockets implementation.";
157      case WSAEPROCLIM: return "Limit on the number of tasks supported by the Windows Sockets implementation has been reached.";
158      case WSANOTINITIALISED: return "Windows Sockets not initialized.";
159      case WSAENETDOWN: return "The network subsystem has failed.";
160      case WSAEWOULDBLOCK: return "Resource temporarily unavailable (op. would block).";
161      case WSAEINPROGRESS: return "A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.";
162      case WSAEADDRINUSE: return "The specified address is already in use.";
163      case WSAEADDRNOTAVAIL: return "The specified address is not available from the local machine.";
164      case WSAEAFNOSUPPORT: return "Addresses in the specified family cannot be used with this socket.";
165      case WSAECONNREFUSED: return "The attempt to connect was forcefully rejected.";
166      case WSAENETUNREACH: return "The network cannot be reached from this host at this time.";
167      case WSAEFAULT: return "Bad parameter.";
168      case WSAEINVAL: return "The socket is already bound to an address.";
169      case WSAEISCONN: return "The socket is already connected.";
170      case WSAEMFILE: return "No more file descriptors are available.";
171      case WSAENOBUFS: return "No buffer space is available. The socket cannot be connected.";
172      case WSAENOTCONN: return "The socket is not connected.";
173      case WSAETIMEDOUT: return "Attempt to connect timed out without establishing a connection.";
174      case WSAECONNRESET: return "The connection was reset by the remote side.";
175      case WSAECONNABORTED: return "The connection was terminated due to a time-out or other failure.";
176      default: return TStr("Unknown socket error (code ")+TInt::GetStr(ErrCd)+TStr(").");
177    }
178  }
179  LRESULT CALLBACK TSockSys::MainWndProc(
180   HWND WndHnd, UINT MsgHnd, WPARAM wParam, LPARAM lParam){
181    if (MsgHnd==TSockSys::SockMsgHnd){
182      IAssert(WndHnd==GetSockWndHnd());
183      TSockHnd SockHnd=wParam;
184      if (IsSockHnd(SockHnd)){
185        int SockEventId=GetSockEventId(SockHnd);
186        PSockEvent SockEvent=GetSockEvent(SockEventId);
187        SetSockEventActive(SockEventId, true);
188        try {
189          int ErrCd=WSAGETSELECTERROR(lParam);
190          if (ErrCd==0){
191            int EventCd=WSAGETSELECTEVENT(lParam);
192            switch (EventCd){
193              case FD_READ: OnRead(SockHnd, SockEvent); break;
194              case FD_WRITE: OnWrite(SockHnd, SockEvent); break;
195              case FD_OOB: OnOob(SockHnd, SockEvent); break;
196              case FD_ACCEPT: OnAccept(SockHnd, SockEvent); break;
197              case FD_CONNECT: OnConnect(SockHnd, SockEvent); break;
198              case FD_CLOSE: OnClose(SockHnd, SockEvent); break;
199              default: Fail;
200            }
201          } else {
202            OnError(SockHnd, SockEvent, ErrCd);
203          }
204        } catch (...){
205          SaveToErrLog("Exception from 'switch (EventCd)'");
206        }
207        SetSockEventActive(SockEventId, false);
208      }
209    } else
210    if (MsgHnd==TSockSys::SockErrMsgHnd){
211      IAssert(WndHnd==GetSockWndHnd());
212      TSockHnd SockHnd=wParam;
213      if (IsSockHnd(SockHnd)){
214        int SockEventId=GetSockEventId(SockHnd);
215        PSockEvent SockEvent=GetSockEvent(SockEventId);
216        SetSockEventActive(SockEventId, true);
217        try {
218          int ErrCd=int(lParam);
219          OnError(SockHnd, SockEvent, ErrCd);
220        } catch (...){
221          SaveToErrLog("Exception from 'OnError(SockHnd, SockEvent, ErrCd)'");
222        }
223        SetSockEventActive(SockEventId, false);
224      }
225    } else
226    if (MsgHnd==WM_TIMER){
227      if (WndHnd==GetSockWndHnd()){
228        int SockId=int(wParam);
229        DelIfSockTimer(SockId);
230        if (IsSockId(SockId)){
231          TSockHnd SockHnd=GetSockHnd(SockId);
232          int SockEventId=GetSockEventId(SockHnd);
233          PSockEvent SockEvent=GetSockEvent(SockEventId);
234          SetSockEventActive(SockEventId, true);
235          try {
236            OnTimeOut(SockHnd, SockEvent);
237          } catch (...){
238            SaveToErrLog("Exception from OnTimeOut(SockHnd, SockEvent);");
239          }
240          SetSockEventActive(SockEventId, false);
241        }
242      } else
243      if (WndHnd==GetTimerWndHnd()){
244        int TimerId=int(wParam);
245        if (TSockSys::IsTimer(TimerId)){
246          PTimer Timer=TSockSys::GetTimer(TimerId)();
247          Timer->IncTicks();
248          try {
249            Timer->OnTimeOut();
250          } catch (...){
251            SaveToErrLog("Exception from Timer->OnTimeOut();");
252          }
253        }
254      } else {
255        Fail;
256      }
257    } else
258    if (MsgHnd==TSockSys::DnsMsgHnd){
259      IAssert(WndHnd==GetDnsWndHnd());
260      uint SockHostHnd=int(wParam);
261      if (TSockSys::IsSockHost(SockHostHnd)){
262        TSockHostStatus Status=TSockHost::GetStatus(WSAGETASYNCERROR(lParam));
263        PSockHost SockHost=TSockSys::GetSockHost(SockHostHnd);
264        SockHost->GetFromHostEnt(Status, (hostent*)SockHost->HostEntBf);
265        DelSockHost(SockHostHnd);
266        try {
267          OnGetHost(SockHost);
268        } catch (...){
269          SaveToErrLog("Exception from OnGetHost(SockHost);");
270        }
271      }
272    } else
273    if (MsgHnd==TSockSys::ReportMsgHnd){
274      IAssert(WndHnd==GetReportWndHnd());
275      int ReportEventId=int(lParam);
276      PReportEvent ReportEvent=TSockSys::GetReportEvent(ReportEventId);
277      try {
278        ReportEvent->OnReport();
279      } catch (...){
280        SaveToErrLog("Exception from ReportEvent->OnReport()");
281      }
282      TSockSys::DelReportEvent(ReportEvent);
283    } else {
284      return DefWindowProc(WndHnd, MsgHnd, wParam, lParam);
285    }
286    return 0;
287  }
288  TSockSys::TSockSys(){
289    IAssert(Active==false);
290    WNDCLASS WndClass;
291    WndClass.style=0;
292    WndClass.lpfnWndProc=MainWndProc;
293    WndClass.cbClsExtra=0;
294    WndClass.cbWndExtra=0;
295    FSAssert((WndClass.hInstance=GetModuleHandle(NULL))!=NULL);
296    WndClass.hIcon=NULL;
297    WndClass.hCursor=NULL;
298    WndClass.hbrBackground=NULL;
299    WndClass.lpszMenuName=NULL;
300    WndClass.lpszClassName="SockWndClass";
301    FSAssert(RegisterClass(&WndClass)!=0);
302    TSockSys::SockWndHnd=CreateWindow(
303     "SockWndClass", "Socket Window",
304     WS_OVERLAPPEDWINDOW, 0, 0, CW_USEDEFAULT, CW_USEDEFAULT, NULL, NULL,
305     GetModuleHandle(NULL), NULL);
306    FSAssert(TSockSys::SockWndHnd!=NULL);
307    TSockSys::DnsWndHnd=CreateWindow(
308     "SockWndClass", "Dns Window",
309     WS_OVERLAPPEDWINDOW, 0, 0, CW_USEDEFAULT, CW_USEDEFAULT, NULL, NULL,
310     GetModuleHandle(NULL), NULL);
311    FSAssert(TSockSys::DnsWndHnd!=NULL);
312    TSockSys::ReportWndHnd=CreateWindow(
313     "SockWndClass", "RepMsg Window",
314     WS_OVERLAPPEDWINDOW, 0, 0, CW_USEDEFAULT, CW_USEDEFAULT, NULL, NULL,
315     GetModuleHandle(NULL), NULL);
316    FSAssert(TSockSys::ReportWndHnd!=NULL);
317    TSockSys::TimerWndHnd=CreateWindow(
318     "SockWndClass", "Net Timer",
319     WS_OVERLAPPEDWINDOW, 0, 0, CW_USEDEFAULT, CW_USEDEFAULT, NULL, NULL,
320     GetModuleHandle(NULL), NULL);
321    FSAssert(TSockSys::TimerWndHnd!=NULL);
322    SockMsgHnd=RegisterWindowMessage("SockSys.SockMsg"); FSAssert(SockMsgHnd!=0);
323    SockErrMsgHnd=RegisterWindowMessage("SockSys.SockErrorMsg"); FSAssert(SockErrMsgHnd!=0);
324    DnsMsgHnd=RegisterWindowMessage("SockSys.DnsMsg"); FSAssert(DnsMsgHnd!=0);
325    ReportMsgHnd=RegisterWindowMessage("SockSys.RepMsg"); FSAssert(ReportMsgHnd!=0);
326    WORD Version=((WORD) (((BYTE) (2)) | (((WORD) ((BYTE) (0))) << 8)));
327    WSADATA WsaData;
328    int WsaErrCd=WSAStartup(Version, &WsaData);
329    FAssert(WsaErrCd==0, TSockSys::GetErrStr(WsaErrCd));
330    FAssert(
331     WsaData.wVersion==Version,
332     "Can not find appropriate version of WinSock DLL.");
333    Active=true;
334  }
335  TSockSys::~TSockSys(){
336    if (Active){
337      IAssert(ActiveSockHndH.Len()==0);
338      IAssert(ActiveSockEventIdH.Len()==0);
339      int WsaErrCd=WSACleanup();
340      FAssert(WsaErrCd==0, TSockSys::GetErrStr(WsaErrCd));
341      Active=false;
342    }
343  }
344  void TSockSys::AddSock(
345   const int& SockId, const TSockHnd& SockHnd, const int& SockEventId){
346    IAssert(Active);
347    SockIdToHndH.AddDat(SockId, SockHnd);
348    SockHndToIdH.AddDat(SockHnd, SockId);
349    SockHndToEventIdH.AddDat(SockHnd, SockEventId);
350  }
351  void TSockSys::DelSock(const int& SockId){
352    IAssert(Active);
353    TSockHnd SockHnd=TSockHnd(SockIdToHndH.GetDat(SockId));
354    IAssert(!IsSockActive(SockHnd));
355    SockIdToHndH.DelKey(SockId);
356    SockHndToIdH.DelKey(SockHnd);
357    SockHndToEventIdH.DelKey(SockHnd);
358    DelIfSockTimer(SockId);
359  }
360  void TSockSys::OnRead(const TSockHnd& SockHnd, const PSockEvent& SockEvent){
361    TMem Mem(MxSockBfL);
362    char* Bf=new char[MxSockBfL]; int BfL;
363    do {
364      BfL=recv(SockHnd, Bf, MxSockBfL, 0);
365      if (BfL!=SOCKET_ERROR){
366        Mem.AddBf(Bf, BfL); SockBytesRead+=BfL;}
367    } while ((BfL>0)&&(BfL!=SOCKET_ERROR));
368    delete[] Bf;
369    if (!SockEvent.Empty()){
370      PSIn SIn=Mem.GetSIn();
371      SockEvent->OnRead(int(GetSockId(SockHnd)), SIn);
372    }
373  }
374  void TSockSys::OnWrite(const TSockHnd& SockHnd, const PSockEvent& SockEvent){
375    if (!SockEvent.Empty()){
376      SockEvent->OnWrite(int(GetSockId(SockHnd)));}
377  }
378  void TSockSys::OnOob(const TSockHnd& SockHnd, const PSockEvent& SockEvent){
379    if (!SockEvent.Empty()){
380      SockEvent->OnOob(int(GetSockId(SockHnd)));}
381  }
382  void TSockSys::OnAccept(const TSockHnd& SockHnd, const PSockEvent& SockEvent){
383    PSock AccSock=TSock::Accept(SockHnd, SockEvent);
384    if (!SockEvent.Empty()){
385      SockEvent->OnAccept(AccSock->GetSockId(), AccSock);}
386  }
387  void TSockSys::OnConnect(const TSockHnd& SockHnd, const PSockEvent& SockEvent){
388    if (!SockEvent.Empty()){
389      SockEvent->OnConnect(int(GetSockId(SockHnd)));}
390  }
391  void TSockSys::OnClose(const TSockHnd& SockHnd, const PSockEvent& SockEvent){
392    if (!SockEvent.Empty()){
393      SockEvent->OnClose(int(GetSockId(SockHnd)));}
394  }
395  void TSockSys::OnTimeOut(const TSockHnd& SockHnd, const PSockEvent& SockEvent){
396    if (!SockEvent.Empty()){
397      SockEvent->OnTimeOut(int(GetSockId(SockHnd)));}
398  }
399  void TSockSys::OnError(
400   const TSockHnd& SockHnd, const PSockEvent& SockEvent, const int& ErrCd){
401    if (!SockEvent.Empty()){
402      SockEvent->OnError(int(GetSockId(SockHnd)), ErrCd, GetErrStr(ErrCd));}
403  }
404  void TSockSys::OnGetHost(const PSockHost& SockHost){
405    if (IsSockEvent(SockHost->GetSockEventId())){
406      PSockEvent SockEvent=SockHost->GetSockEvent();
407      if (!SockEvent.Empty()){
408        SockEvent->OnGetHost(SockHost);}
409    }
410  }
411  TStr TSockSys::GetStatusStr(){
412    TChA ChA;
413    ChA+="Sockets: "; ChA+=TInt::GetStr(SockIdToHndH.Len()); ChA+="\r\n";
414    ChA+="Host-Resolutions: "; ChA+=TInt::GetStr(HndToSockHostH.Len()); ChA+="\r\n";
415    ChA+="Socket-Events: "; ChA+=TInt::GetStr(IdToSockEventH.Len()); ChA+="\r\n";
416    ChA+="Report-Events: "; ChA+=TInt::GetStr(IdToReportEventH.Len()); ChA+="\r\n";
417    ChA+="Timers: "; ChA+=TInt::GetStr(IdToTimerH.Len()); ChA+="\r\n";
418    return ChA;
419  }
420  int TSockEvent::LastSockEventId=0;
421  TSockEvent::~TSockEvent(){
422    IAssert(!TSockSys::IsSockEventActive(SockEventId));
423  }
424  bool TSockEvent::IsReg(const PSockEvent& SockEvent){
425    return TSockSys::IsSockEvent(SockEvent);
426  }
427  void TSockEvent::Reg(const PSockEvent& SockEvent){
428    IAssert(!TSockSys::IsSockEvent(SockEvent));
429    TSockSys::AddSockEvent(SockEvent);
430  }
431  void TSockEvent::UnReg(const PSockEvent& SockEvent){
432    IAssert(TSockSys::IsSockEvent(SockEvent));
433    TSockSys::DelSockEvent(SockEvent);
434  }
435  void TSockHost::GetFromHostEnt(
436   const TSockHostStatus& _Status, const hostent* HostEnt){
437    if ((Status=_Status)==shsOk){
438      IAssert(HostEnt!=NULL);
439      IAssert(HostEnt->h_addrtype==AF_INET);
440      IAssert(HostEnt->h_length==4);
441      HostNmV.Add(TStr(HostEnt->h_name).GetLc());
442      int HostNmN=0;
443      while (HostEnt->h_aliases[HostNmN]!=NULL){
444        HostNmV.Add(TStr(HostEnt->h_aliases[HostNmN]).GetLc()); HostNmN++;}
445      int IpNumN=0;
446      while (HostEnt->h_addr_list[IpNumN]!=NULL){
447        TStr IpNum=
448         TInt::GetStr(uchar(HostEnt->h_addr_list[IpNumN][0]))+"."+
449         TInt::GetStr(uchar(HostEnt->h_addr_list[IpNumN][1]))+"."+
450         TInt::GetStr(uchar(HostEnt->h_addr_list[IpNumN][2]))+"."+
451         TInt::GetStr(uchar(HostEnt->h_addr_list[IpNumN][3]));
452        IpNumV.Add(IpNum); IpNumN++;
453      }
454    }
455  }
456  PSockEvent TSockHost::GetSockEvent() const {
457    return TSockSys::GetSockEvent(SockEventId);
458  }
459  bool TSockHost::IsIpNum(const TStr& HostNm){
460    int HostNmLen=HostNm.Len();
461    for (int ChN=0; ChN<HostNmLen; ChN++){
462      if (TCh::IsAlpha(HostNm[ChN])){return false;}}
463    return true;
464  }
465  TStr TSockHost::GetIpNum(const uint& IpNum){
466    TChA IpNumChA;
467    IpNumChA+=TUInt::GetStr(IpNum/0x1000000);
468    IpNumChA+='.'; IpNumChA+=TUInt::GetStr((IpNum/0x10000)%0x100);
469    IpNumChA+='.'; IpNumChA+=TUInt::GetStr((IpNum/0x100)%0x100);
470    IpNumChA+='.'; IpNumChA+=TUInt::GetStr(IpNum%0x100);
471    return IpNumChA;
472  }
473  PSockHost TSockHost::GetSyncSockHost(const TStr& HostNm){
474    hostent* HostEnt; TSockHostStatus Status(shsUndef);
475    if ((HostNm.Len()>0)&&(!IsIpNum(HostNm))){
476      HostEnt=gethostbyname(HostNm.CStr());
477      if (HostEnt==NULL){Status=GetStatus(WSAGetLastError());}
478      else {Status=shsOk;}
479    } else {
480      uint HostIpNum=inet_addr(HostNm.CStr());
481      if (HostIpNum==INADDR_NONE){
482        Status=shsError; HostEnt=NULL;
483      } else {
484        HostEnt=gethostbyaddr((char*)&HostIpNum, 4, AF_INET);
485        if (HostEnt==NULL){Status=GetStatus(WSAGetLastError());}
486        else {Status=shsOk;}
487      }
488    }
489    PSockHost SockHost=PSockHost(new TSockHost());
490    SockHost->GetFromHostEnt(Status, HostEnt);
491    return SockHost;
492  }
493  void TSockHost::GetAsyncSockHost(
494   const TStr& HostNm, const PSockEvent& SockEvent){
495    PSockHost SockHost=PSockHost(new TSockHost(SockEvent));
496    HANDLE SockHostHnd=0;
497    if ((HostNm.Len()>0)){
498      SockHostHnd=WSAAsyncGetHostByName(TSockSys::GetDnsWndHnd(),
499       TSockSys::GetDnsMsgHnd(), HostNm.CStr(),
500       SockHost->HostEntBf, MAXGETHOSTSTRUCT);
501    } else {
502      uint HostIpNum=inet_addr(HostNm.CStr());
503      if (HostIpNum==INADDR_NONE){
504        SockHostHnd=0;
505      } else {
506        SockHostHnd=WSAAsyncGetHostByAddr(TSockSys::GetDnsWndHnd(),
507         TSockSys::GetDnsMsgHnd(), (char*)&HostIpNum, 4, AF_INET,
508         SockHost->HostEntBf, MAXGETHOSTSTRUCT);
509      }
510    }
511    EAssertR(SockHostHnd!=0, TSockSys::GetErrStr(WSAGetLastError()));
512    if (SockHostHnd!=0){
513      TSockSys::AddSockHost(TUInt64(SockHostHnd), SockHost);
514    }
515  }
516  TSockHostStatus TSockHost::GetStatus(const int& ErrCd){
517    switch (ErrCd){
518      case 0: return shsOk;
519      case WSAHOST_NOT_FOUND: return shsHostNotFound;
520      case WSATRY_AGAIN: return shsTryAgain;
521      default: return shsError;
522    }
<span onclick='openModal()' class='match'>523  }
524  PSockHost TSockHost::GetLocalSockHost(){
525    PSockHost SockHost=TSockHost::GetSyncSockHost(LocalHostNm);
526    if (SockHost->IsOk()){
527      SockHost=TSockHost::GetSyncSockHost(SockHost->GetHostNm());}
528    return SockHost;
529  }
</span>530  const TStr TSockHost::LocalHostNm("localhost");
531  int TSock::LastSockId=0;
532  TSock::TSock(const PSockEvent& SockEvent):
533    SockId(++LastSockId), SockHnd(0),
534    SockEventId(SockEvent->GetSockEventId()){
535    SockHnd=socket(AF_INET, SOCK_STREAM, 0);
536    EAssertR(SockHnd!=INVALID_SOCKET, TSockSys::GetErrStr(WSAGetLastError()));
537    TSockSys::AddSock(SockId, SockHnd, SockEventId);
538    IAssert(TSockEvent::IsReg(SockEvent));
539  }
540  TSock::TSock(const TSockHnd& _SockHnd, const PSockEvent& SockEvent):
541    SockId(++LastSockId), SockHnd(_SockHnd),
542    SockEventId(SockEvent->GetSockEventId()){
543    TSockSys::AddSock(SockId, SockHnd, SockEventId);
544    IAssert(TSockEvent::IsReg(SockEvent));
545  }
546  TSock::~TSock(){
547    IAssert(!TSockSys::IsSockActive(SockHnd));
548    TSockSys::DelSock(SockId);
549    closesocket(SockHnd);
550  }
551  PSockEvent TSock::GetSockEvent() const {
552    return TSockSys::GetSockEvent(SockEventId);
553  }
554  void TSock::Listen(const int& PortN){
555    sockaddr_in SockAddr;
556    memset(&SockAddr, 0, sizeof(SockAddr));
557    SockAddr.sin_family=AF_INET;
558    SockAddr.sin_addr.s_addr=INADDR_ANY;
559    SockAddr.sin_port=htons(u_short(PortN));
560    EAssertR(
561     bind(SockHnd, (sockaddr*)&SockAddr, sizeof(SockAddr))==0,
562     TSockSys::GetErrStr(WSAGetLastError()));
563    EAssertR(
564     WSAAsyncSelect(SockHnd, TSockSys::GetSockWndHnd(),
565      TSockSys::GetSockMsgHnd(), TSockSys::GetAllSockEventCdSet())==0,
566     TSockSys::GetErrStr(WSAGetLastError()));
567    EAssertR(
568     listen(SockHnd, SOMAXCONN)==0,
569     TSockSys::GetErrStr(WSAGetLastError()));
570  }
571  int TSock::GetPortAndListen(const int& MnPortN){
572    int PortN=MnPortN-1;
573    int ErrCd=0;
574    forever {
575      PortN++;
576      sockaddr_in SockAddr;
577      memset(&SockAddr, 0, sizeof(SockAddr));
578      SockAddr.sin_family=AF_INET;
579      SockAddr.sin_addr.s_addr=INADDR_ANY;
580      SockAddr.sin_port=htons(u_short(PortN));
581      int OkCd=bind(SockHnd, (sockaddr*)&SockAddr, sizeof(SockAddr));
582      if (OkCd==SOCKET_ERROR){
583        ErrCd=WSAGetLastError();
584        if (ErrCd!=WSAEADDRINUSE){break;}
585      } else {
586        ErrCd=0; break;
587      }
588    }
589    EAssertR(ErrCd==0, TSockSys::GetErrStr(ErrCd));
590    EAssertR(
591     WSAAsyncSelect(SockHnd, TSockSys::GetSockWndHnd(),
592     TSockSys::GetSockMsgHnd(), TSockSys::GetAllSockEventCdSet())==0,
593     TSockSys::GetErrStr(WSAGetLastError()));
594    EAssertR(
595     listen(SockHnd, SOMAXCONN)==0,
596     TSockSys::GetErrStr(WSAGetLastError()));
597    return PortN;
598  }
599  void TSock::Connect(const PSockHost& SockHost, const int& PortN){
600    IAssert(SockHost->IsOk());
601    uint HostIpNum=inet_addr(SockHost->GetIpNum().CStr());
602    IAssert(HostIpNum!=INADDR_NONE);
603    sockaddr_in SockAddr;
604    memset(&SockAddr, 0, sizeof(SockAddr));
605    memcpy(&(SockAddr.sin_addr), &HostIpNum, sizeof(HostIpNum));
606    SockAddr.sin_family=AF_INET;
607    SockAddr.sin_port=htons(u_short(PortN));
608    EAssertR(
609     WSAAsyncSelect(SockHnd, TSockSys::GetSockWndHnd(),
610      TSockSys::GetSockMsgHnd(), TSockSys::GetAllSockEventCdSet())==0,
611     TSockSys::GetErrStr(WSAGetLastError()));
612    int ErrCd=connect(SockHnd, (sockaddr*)&SockAddr, sizeof(SockAddr));
613    EAssertR(
614     (ErrCd==SOCKET_ERROR)&&(WSAGetLastError()==WSAEWOULDBLOCK),
615     "Unsuccessful socket-connect.");
616  }
617  void TSock::Send(const PSIn& SIn, bool& Ok, int& ErrCd){
618    if (!SIn.Empty()){UnsentBf+=SIn;}
619    Ok=true; ErrCd=0;
620    int SentChs=0;
621    while (SentChs<UnsentBf.Len()){
622      int SendBfL=UnsentBf.Len()-SentChs;
623      if (SendBfL>TSockSys::MxSockBfL){SendBfL=TSockSys::MxSockBfL;}
624      int LSentChs=send(SockHnd, &UnsentBf[SentChs], SendBfL, 0);
625      if (LSentChs==SOCKET_ERROR){
626        ErrCd=WSAGetLastError();
627        Ok=(ErrCd==WSAEWOULDBLOCK);
628        break;
629      } else {
630        SentChs+=LSentChs;
631        TSockSys::SockBytesWritten+=LSentChs;
632      }
633    }
634    UnsentBf.Del(0, SentChs-1);
635  }
636  void TSock::Send(const PSIn& SIn){
637    bool Ok; int ErrCd; Send(SIn, Ok, ErrCd);
638    if (!Ok){
639     ESAssert(PostMessage(
640      TSockSys::GetSockWndHnd(), TSockSys::SockErrMsgHnd, SockHnd, ErrCd));
641    }
642  }
643  void TSock::SendSafe(const PSIn& SIn){
644    bool Ok; int ErrCd; Send(SIn, Ok, ErrCd);
645  }
646  TStr TSock::GetPeerIpNum() const {
647    sockaddr_in SockAddr;
648    memset(&SockAddr, 0, sizeof(SockAddr));
649    int NmLen=sizeof(sockaddr_in);
650    EAssertR(
651     getpeername(SockHnd, (sockaddr*)&SockAddr, &NmLen)==0,
652     TSockSys::GetErrStr(WSAGetLastError()));
653    TStr IpNum=
654     TInt::GetStr(SockAddr.sin_addr.s_net)+"."+
655     TInt::GetStr(SockAddr.sin_addr.s_host)+"."+
656     TInt::GetStr(SockAddr.sin_addr.s_lh)+"."+
657     TInt::GetStr(SockAddr.sin_addr.s_impno);
658    return IpNum;
659  }
660  TStr TSock::GetLocalIpNum() const {
661    sockaddr_in SockAddr;
662    memset(&SockAddr, 0, sizeof(SockAddr));
663    int NmLen=sizeof(sockaddr_in);
664    EAssertR(
665     getsockname(SockHnd, (sockaddr*)&SockAddr, &NmLen)==0,
666     TSockSys::GetErrStr(WSAGetLastError()));
667    TStr IpNum=
668     TInt::GetStr(SockAddr.sin_addr.s_net)+"."+
669     TInt::GetStr(SockAddr.sin_addr.s_host)+"."+
670     TInt::GetStr(SockAddr.sin_addr.s_lh)+"."+
671     TInt::GetStr(SockAddr.sin_addr.s_impno);
672    return IpNum;
673  }
674  void TSock::PutTimeOut(const int& MSecs){
675    TSockSys::AddSockTimer(SockId, MSecs);
676  }
677  void TSock::DelTimeOut(){
678    TSockSys::DelIfSockTimer(SockId);
679  }
680  PSock TSock::Accept(const TSockHnd& SockHnd, const PSockEvent& SockEvent){
681    sockaddr_in SockAddr;
682    int SockAddrLen=sizeof(SockAddr);
683    memset(&SockAddr, 0, sizeof(SockAddr));
684    TSockHnd AccSockHnd=accept(SockHnd, (sockaddr*)&SockAddr, &SockAddrLen);
685    EAssertR(
686     AccSockHnd!=INVALID_SOCKET,
687     TSockSys::GetErrStr(WSAGetLastError()));
688    PSock AccSock=PSock(new TSock(AccSockHnd, SockEvent));
689    EAssertR(
690     WSAAsyncSelect(AccSock->GetSockHnd(), TSockSys::GetSockWndHnd(),
691      TSockSys::GetSockMsgHnd(), TSockSys::GetAllSockEventCdSet())==0,
692     TSockSys::GetErrStr(WSAGetLastError()));
693    return AccSock;
694  }
695  TStr TSock::GetSockSysStatusStr(){
696    return TSockSys::GetStatusStr();
697  }
698  uint64 TSock::GetSockSysBytesRead(){
699    return TSockSys::SockBytesRead;
700  }
701  uint64 TSock::GetSockSysBytesWritten(){
702    return TSockSys::SockBytesWritten;
703  }
704  bool TSock::IsSockId(const int& SockId){
705    return TSockSys::IsSockId(SockId);
706  }
707  int TReportEvent::LastReportEventId=0;
708  void TReportEvent::SendReport(){
709    TSockSys::AddReportEvent(this);
710    ESAssert(PostMessage(
711     TSockSys::GetReportWndHnd(), TSockSys::GetReportMsgHnd(), 0, ReportEventId));
712  }
713  int TTTimer::LastTimerId=0;
714  TTTimer::TTTimer(const int& _TimeOut):
715    TimerId(++LastTimerId), TimerHnd(0), TimeOut(_TimeOut),
716    Ticks(0), StartTm(TSecTm::GetCurTm()){
717    IAssert(TimeOut>=0);
718    StartTimer(TimeOut);
719  }
720  TTTimer::~TTTimer(){
721    StopTimer();
722  }
723  void TTTimer::StartTimer(const int& _TimeOut){
724    IAssert((_TimeOut==-1)||(_TimeOut>=0));
725    if (_TimeOut!=-1){
726      TimeOut=_TimeOut;}
727    StopTimer();
728    if (TimeOut>0){
729      TimerHnd=uint(SetTimer(
730       TSockSys::GetTimerWndHnd(), UINT(TimerId), UINT(TimeOut), NULL));
731      ESAssert(TimerHnd!=0);
732      TSockSys::AddTimer(this);
733    }
734  }
735  void TTTimer::StopTimer(){
736    if (TimerHnd!=0){
737      ESAssert(KillTimer(TSockSys::GetTimerWndHnd(), TimerId));
738      TSockSys::DelTimer(TimerId);
739      TimerHnd=0;
740    }
741  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-DockingManager.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-sock.cpp</div>
                </div>
                <div class="column column_space"><pre><code>717  }
718  BOOL DockingManager::ContExists(size_t iCont)
719  {
720  	BOOL	bRet = FALSE;
721  	if (iCont < _vContainer.size())
722  	{
723  		bRet = TRUE;
724  	}
725  	return bRet;
726  }
</pre></code></div>
                <div class="column column_space"><pre><code>523  }
524  PSockHost TSockHost::GetLocalSockHost(){
525    PSockHost SockHost=TSockHost::GetSyncSockHost(LocalHostNm);
526    if (SockHost->IsOk()){
527      SockHost=TSockHost::GetSyncSockHost(SockHost->GetHostNm());}
528    return SockHost;
529  }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    