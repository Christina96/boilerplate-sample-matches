
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 17, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-cordz_info_test.cc</h3>
            <pre><code>1  #include "absl/strings/internal/cordz_info.h"
2  #include <vector>
3  #include "gmock/gmock.h"
4  #include "gtest/gtest.h"
5  #include "absl/base/config.h"
6  #include "absl/debugging/stacktrace.h"
7  #include "absl/debugging/symbolize.h"
8  #include "absl/strings/cordz_test_helpers.h"
9  #include "absl/strings/internal/cord_rep_flat.h"
10  #include "absl/strings/internal/cordz_handle.h"
11  #include "absl/strings/internal/cordz_statistics.h"
12  #include "absl/strings/internal/cordz_update_tracker.h"
13  #include "absl/strings/str_cat.h"
14  #include "absl/types/span.h"
15  namespace absl {
16  ABSL_NAMESPACE_BEGIN
17  namespace cord_internal {
18  namespace {
19  using ::testing::ElementsAre;
20  using ::testing::Eq;
21  using ::testing::HasSubstr;
22  using ::testing::Ne;
23  using ::testing::SizeIs;
24  auto constexpr kUnknownMethod = CordzUpdateTracker::kUnknown;
25  auto constexpr kTrackCordMethod = CordzUpdateTracker::kConstructorString;
26  auto constexpr kChildMethod = CordzUpdateTracker::kConstructorCord;
27  auto constexpr kUpdateMethod = CordzUpdateTracker::kAppendString;
28  std::vector<const CordzHandle*> DeleteQueue() {
29    return CordzHandle::DiagnosticsGetDeleteQueue();
30  }
31  std::string FormatStack(absl::Span<void* const> raw_stack) {
32    static constexpr size_t buf_size = 1 << 14;
<span onclick='openModal()' class='match'>33    std::unique_ptr<char[]> buf(new char[buf_size]);
34    std::string output;
</span>35    for (void* stackp : raw_stack) {
36      if (absl::Symbolize(stackp, buf.get(), buf_size)) {
37        absl::StrAppend(&output, "    ", buf.get(), "\n");
38      }
39    }
40    return output;
41  }
42  TEST(CordzInfoTest, TrackCord) {
43    TestCordData data;
44    CordzInfo::TrackCord(data.data, kTrackCordMethod);
45    CordzInfo* info = data.data.cordz_info();
46    ASSERT_THAT(info, Ne(nullptr));
47    EXPECT_FALSE(info->is_snapshot());
48    EXPECT_THAT(CordzInfo::Head(CordzSnapshot()), Eq(info));
49    EXPECT_THAT(info->GetCordRepForTesting(), Eq(data.rep.rep));
50    info->Untrack();
51  }
52  TEST(CordzInfoTest, MaybeTrackChildCordWithoutSampling) {
53    CordzSamplingIntervalHelper sample_none(99999);
54    TestCordData parent, child;
55    CordzInfo::MaybeTrackCord(child.data, parent.data, kTrackCordMethod);
56    EXPECT_THAT(child.data.cordz_info(), Eq(nullptr));
57  }
58  TEST(CordzInfoTest, MaybeTrackChildCordWithSampling) {
59    CordzSamplingIntervalHelper sample_all(1);
60    TestCordData parent, child;
61    CordzInfo::MaybeTrackCord(child.data, parent.data, kTrackCordMethod);
62    EXPECT_THAT(child.data.cordz_info(), Eq(nullptr));
63  }
64  TEST(CordzInfoTest, MaybeTrackChildCordWithoutSamplingParentSampled) {
65    CordzSamplingIntervalHelper sample_none(99999);
66    TestCordData parent, child;
67    CordzInfo::TrackCord(parent.data, kTrackCordMethod);
68    CordzInfo::MaybeTrackCord(child.data, parent.data, kTrackCordMethod);
69    CordzInfo* parent_info = parent.data.cordz_info();
70    CordzInfo* child_info = child.data.cordz_info();
71    ASSERT_THAT(child_info, Ne(nullptr));
72    EXPECT_THAT(child_info->GetCordRepForTesting(), Eq(child.rep.rep));
73    EXPECT_THAT(child_info->GetParentStack(), parent_info->GetStack());
74    parent_info->Untrack();
75    child_info->Untrack();
76  }
77  TEST(CordzInfoTest, MaybeTrackChildCordWithoutSamplingChildSampled) {
78    CordzSamplingIntervalHelper sample_none(99999);
79    TestCordData parent, child;
80    CordzInfo::TrackCord(child.data, kTrackCordMethod);
81    CordzInfo::MaybeTrackCord(child.data, parent.data, kTrackCordMethod);
82    EXPECT_THAT(child.data.cordz_info(), Eq(nullptr));
83  }
84  TEST(CordzInfoTest, MaybeTrackChildCordWithSamplingChildSampled) {
85    CordzSamplingIntervalHelper sample_all(1);
86    TestCordData parent, child;
87    CordzInfo::TrackCord(child.data, kTrackCordMethod);
88    CordzInfo::MaybeTrackCord(child.data, parent.data, kTrackCordMethod);
89    EXPECT_THAT(child.data.cordz_info(), Eq(nullptr));
90  }
91  TEST(CordzInfoTest, UntrackCord) {
92    TestCordData data;
93    CordzInfo::TrackCord(data.data, kTrackCordMethod);
94    CordzInfo* info = data.data.cordz_info();
95    info->Untrack();
96    EXPECT_THAT(DeleteQueue(), SizeIs(0u));
97  }
98  TEST(CordzInfoTest, UntrackCordWithSnapshot) {
99    TestCordData data;
100    CordzInfo::TrackCord(data.data, kTrackCordMethod);
101    CordzInfo* info = data.data.cordz_info();
102    CordzSnapshot snapshot;
103    info->Untrack();
104    EXPECT_THAT(CordzInfo::Head(CordzSnapshot()), Eq(nullptr));
105    EXPECT_THAT(info->GetCordRepForTesting(), Eq(data.rep.rep));
106    EXPECT_THAT(DeleteQueue(), ElementsAre(info, &snapshot));
107  }
108  TEST(CordzInfoTest, SetCordRep) {
109    TestCordData data;
110    CordzInfo::TrackCord(data.data, kTrackCordMethod);
111    CordzInfo* info = data.data.cordz_info();
112    TestCordRep rep;
113    info->Lock(CordzUpdateTracker::kAppendCord);
114    info->SetCordRep(rep.rep);
115    info->Unlock();
116    EXPECT_THAT(info->GetCordRepForTesting(), Eq(rep.rep));
117    info->Untrack();
118  }
119  TEST(CordzInfoTest, SetCordRepNullUntracksCordOnUnlock) {
120    TestCordData data;
121    CordzInfo::TrackCord(data.data, kTrackCordMethod);
122    CordzInfo* info = data.data.cordz_info();
123    info->Lock(CordzUpdateTracker::kAppendString);
124    info->SetCordRep(nullptr);
125    EXPECT_THAT(info->GetCordRepForTesting(), Eq(nullptr));
126    EXPECT_THAT(CordzInfo::Head(CordzSnapshot()), Eq(info));
127    info->Unlock();
128    EXPECT_THAT(CordzInfo::Head(CordzSnapshot()), Eq(nullptr));
129  }
130  TEST(CordzInfoTest, RefCordRep) {
131    TestCordData data;
132    CordzInfo::TrackCord(data.data, kTrackCordMethod);
133    CordzInfo* info = data.data.cordz_info();
134    size_t refcount = data.rep.rep->refcount.Get();
135    EXPECT_THAT(info->RefCordRep(), Eq(data.rep.rep));
136    EXPECT_THAT(data.rep.rep->refcount.Get(), Eq(refcount + 1));
137    CordRep::Unref(data.rep.rep);
138    info->Untrack();
139  }
140  #if GTEST_HAS_DEATH_TEST
141  TEST(CordzInfoTest, SetCordRepRequiresMutex) {
142    TestCordData data;
143    CordzInfo::TrackCord(data.data, kTrackCordMethod);
144    CordzInfo* info = data.data.cordz_info();
145    TestCordRep rep;
146    EXPECT_DEBUG_DEATH(info->SetCordRep(rep.rep), ".*");
147    info->Untrack();
148  }
149  #endif  
150  TEST(CordzInfoTest, TrackUntrackHeadFirstV2) {
151    CordzSnapshot snapshot;
152    EXPECT_THAT(CordzInfo::Head(snapshot), Eq(nullptr));
153    TestCordData data;
154    CordzInfo::TrackCord(data.data, kTrackCordMethod);
155    CordzInfo* info1 = data.data.cordz_info();
156    ASSERT_THAT(CordzInfo::Head(snapshot), Eq(info1));
157    EXPECT_THAT(info1->Next(snapshot), Eq(nullptr));
158    TestCordData data2;
159    CordzInfo::TrackCord(data2.data, kTrackCordMethod);
160    CordzInfo* info2 = data2.data.cordz_info();
161    ASSERT_THAT(CordzInfo::Head(snapshot), Eq(info2));
162    EXPECT_THAT(info2->Next(snapshot), Eq(info1));
163    EXPECT_THAT(info1->Next(snapshot), Eq(nullptr));
164    info2->Untrack();
165    ASSERT_THAT(CordzInfo::Head(snapshot), Eq(info1));
166    EXPECT_THAT(info1->Next(snapshot), Eq(nullptr));
167    info1->Untrack();
168    ASSERT_THAT(CordzInfo::Head(snapshot), Eq(nullptr));
169  }
170  TEST(CordzInfoTest, TrackUntrackTailFirstV2) {
171    CordzSnapshot snapshot;
172    EXPECT_THAT(CordzInfo::Head(snapshot), Eq(nullptr));
173    TestCordData data;
174    CordzInfo::TrackCord(data.data, kTrackCordMethod);
175    CordzInfo* info1 = data.data.cordz_info();
176    ASSERT_THAT(CordzInfo::Head(snapshot), Eq(info1));
177    EXPECT_THAT(info1->Next(snapshot), Eq(nullptr));
178    TestCordData data2;
179    CordzInfo::TrackCord(data2.data, kTrackCordMethod);
180    CordzInfo* info2 = data2.data.cordz_info();
181    ASSERT_THAT(CordzInfo::Head(snapshot), Eq(info2));
182    EXPECT_THAT(info2->Next(snapshot), Eq(info1));
183    EXPECT_THAT(info1->Next(snapshot), Eq(nullptr));
184    info1->Untrack();
185    ASSERT_THAT(CordzInfo::Head(snapshot), Eq(info2));
186    EXPECT_THAT(info2->Next(snapshot), Eq(nullptr));
187    info2->Untrack();
188    ASSERT_THAT(CordzInfo::Head(snapshot), Eq(nullptr));
189  }
190  TEST(CordzInfoTest, StackV2) {
191    TestCordData data;
192    static constexpr int kMaxStackDepth = 50;
193    CordzInfo::TrackCord(data.data, kTrackCordMethod);
194    CordzInfo* info = data.data.cordz_info();
195    std::vector<void*> local_stack;
196    local_stack.resize(kMaxStackDepth);
197    local_stack.resize(static_cast<size_t>(
198        absl::GetStackTrace(local_stack.data(), kMaxStackDepth,
199                            1)));
200    std::string got_stack = FormatStack(info->GetStack());
201    std::string expected_stack = FormatStack(local_stack);
202    EXPECT_THAT(got_stack, HasSubstr(expected_stack));
203    info->Untrack();
204  }
205  CordzInfo* TrackChildCord(InlineData& data, const InlineData& parent) {
206    CordzInfo::TrackCord(data, parent, kChildMethod);
207    return data.cordz_info();
208  }
209  CordzInfo* TrackParentCord(InlineData& data) {
210    CordzInfo::TrackCord(data, kTrackCordMethod);
211    return data.cordz_info();
212  }
213  TEST(CordzInfoTest, GetStatistics) {
214    TestCordData data;
215    CordzInfo* info = TrackParentCord(data.data);
216    CordzStatistics statistics = info->GetCordzStatistics();
217    EXPECT_THAT(statistics.size, Eq(data.rep.rep->length));
218    EXPECT_THAT(statistics.method, Eq(kTrackCordMethod));
219    EXPECT_THAT(statistics.parent_method, Eq(kUnknownMethod));
220    EXPECT_THAT(statistics.update_tracker.Value(kTrackCordMethod), Eq(1));
221    info->Untrack();
222  }
223  TEST(CordzInfoTest, LockCountsMethod) {
224    TestCordData data;
225    CordzInfo* info = TrackParentCord(data.data);
226    info->Lock(kUpdateMethod);
227    info->Unlock();
228    info->Lock(kUpdateMethod);
229    info->Unlock();
230    CordzStatistics statistics = info->GetCordzStatistics();
231    EXPECT_THAT(statistics.update_tracker.Value(kUpdateMethod), Eq(2));
232    info->Untrack();
233  }
234  TEST(CordzInfoTest, FromParent) {
235    TestCordData parent;
236    TestCordData child;
237    CordzInfo* info_parent = TrackParentCord(parent.data);
238    CordzInfo* info_child = TrackChildCord(child.data, parent.data);
239    std::string stack = FormatStack(info_parent->GetStack());
240    std::string parent_stack = FormatStack(info_child->GetParentStack());
241    EXPECT_THAT(stack, Eq(parent_stack));
242    CordzStatistics statistics = info_child->GetCordzStatistics();
243    EXPECT_THAT(statistics.size, Eq(child.rep.rep->length));
244    EXPECT_THAT(statistics.method, Eq(kChildMethod));
245    EXPECT_THAT(statistics.parent_method, Eq(kTrackCordMethod));
246    EXPECT_THAT(statistics.update_tracker.Value(kChildMethod), Eq(1));
247    info_parent->Untrack();
248    info_child->Untrack();
249  }
250  }  
251  }  
252  ABSL_NAMESPACE_END
253  }  
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-cordz_info_test.cc</h3>
            <pre><code>1  #include "absl/strings/internal/cordz_info.h"
2  #include <vector>
3  #include "gmock/gmock.h"
4  #include "gtest/gtest.h"
5  #include "absl/base/config.h"
6  #include "absl/debugging/stacktrace.h"
7  #include "absl/debugging/symbolize.h"
8  #include "absl/strings/cordz_test_helpers.h"
9  #include "absl/strings/internal/cord_rep_flat.h"
10  #include "absl/strings/internal/cordz_handle.h"
11  #include "absl/strings/internal/cordz_statistics.h"
12  #include "absl/strings/internal/cordz_update_tracker.h"
13  #include "absl/strings/str_cat.h"
14  #include "absl/types/span.h"
15  namespace absl {
16  ABSL_NAMESPACE_BEGIN
17  namespace cord_internal {
18  namespace {
19  using ::testing::ElementsAre;
20  using ::testing::Eq;
21  using ::testing::HasSubstr;
22  using ::testing::Ne;
23  using ::testing::SizeIs;
24  auto constexpr kUnknownMethod = CordzUpdateTracker::kUnknown;
25  auto constexpr kTrackCordMethod = CordzUpdateTracker::kConstructorString;
26  auto constexpr kChildMethod = CordzUpdateTracker::kConstructorCord;
27  auto constexpr kUpdateMethod = CordzUpdateTracker::kAppendString;
28  std::vector<const CordzHandle*> DeleteQueue() {
29    return CordzHandle::DiagnosticsGetDeleteQueue();
30  }
31  std::string FormatStack(absl::Span<void* const> raw_stack) {
32    static constexpr size_t buf_size = 1 << 14;
<span onclick='openModal()' class='match'>33    std::unique_ptr<char[]> buf(new char[buf_size]);
34    std::string output;
</span>35    for (void* stackp : raw_stack) {
36      if (absl::Symbolize(stackp, buf.get(), buf_size)) {
37        absl::StrAppend(&output, "    ", buf.get(), "\n");
38      }
39    }
40    return output;
41  }
42  TEST(CordzInfoTest, TrackCord) {
43    TestCordData data;
44    CordzInfo::TrackCord(data.data, kTrackCordMethod);
45    CordzInfo* info = data.data.cordz_info();
46    ASSERT_THAT(info, Ne(nullptr));
47    EXPECT_FALSE(info->is_snapshot());
48    EXPECT_THAT(CordzInfo::Head(CordzSnapshot()), Eq(info));
49    EXPECT_THAT(info->GetCordRepForTesting(), Eq(data.rep.rep));
50    info->Untrack();
51  }
52  TEST(CordzInfoTest, MaybeTrackChildCordWithoutSampling) {
53    CordzSamplingIntervalHelper sample_none(99999);
54    TestCordData parent, child;
55    CordzInfo::MaybeTrackCord(child.data, parent.data, kTrackCordMethod);
56    EXPECT_THAT(child.data.cordz_info(), Eq(nullptr));
57  }
58  TEST(CordzInfoTest, MaybeTrackChildCordWithSampling) {
59    CordzSamplingIntervalHelper sample_all(1);
60    TestCordData parent, child;
61    CordzInfo::MaybeTrackCord(child.data, parent.data, kTrackCordMethod);
62    EXPECT_THAT(child.data.cordz_info(), Eq(nullptr));
63  }
64  TEST(CordzInfoTest, MaybeTrackChildCordWithoutSamplingParentSampled) {
65    CordzSamplingIntervalHelper sample_none(99999);
66    TestCordData parent, child;
67    CordzInfo::TrackCord(parent.data, kTrackCordMethod);
68    CordzInfo::MaybeTrackCord(child.data, parent.data, kTrackCordMethod);
69    CordzInfo* parent_info = parent.data.cordz_info();
70    CordzInfo* child_info = child.data.cordz_info();
71    ASSERT_THAT(child_info, Ne(nullptr));
72    EXPECT_THAT(child_info->GetCordRepForTesting(), Eq(child.rep.rep));
73    EXPECT_THAT(child_info->GetParentStack(), parent_info->GetStack());
74    parent_info->Untrack();
75    child_info->Untrack();
76  }
77  TEST(CordzInfoTest, MaybeTrackChildCordWithoutSamplingChildSampled) {
78    CordzSamplingIntervalHelper sample_none(99999);
79    TestCordData parent, child;
80    CordzInfo::TrackCord(child.data, kTrackCordMethod);
81    CordzInfo::MaybeTrackCord(child.data, parent.data, kTrackCordMethod);
82    EXPECT_THAT(child.data.cordz_info(), Eq(nullptr));
83  }
84  TEST(CordzInfoTest, MaybeTrackChildCordWithSamplingChildSampled) {
85    CordzSamplingIntervalHelper sample_all(1);
86    TestCordData parent, child;
87    CordzInfo::TrackCord(child.data, kTrackCordMethod);
88    CordzInfo::MaybeTrackCord(child.data, parent.data, kTrackCordMethod);
89    EXPECT_THAT(child.data.cordz_info(), Eq(nullptr));
90  }
91  TEST(CordzInfoTest, UntrackCord) {
92    TestCordData data;
93    CordzInfo::TrackCord(data.data, kTrackCordMethod);
94    CordzInfo* info = data.data.cordz_info();
95    info->Untrack();
96    EXPECT_THAT(DeleteQueue(), SizeIs(0u));
97  }
98  TEST(CordzInfoTest, UntrackCordWithSnapshot) {
99    TestCordData data;
100    CordzInfo::TrackCord(data.data, kTrackCordMethod);
101    CordzInfo* info = data.data.cordz_info();
102    CordzSnapshot snapshot;
103    info->Untrack();
104    EXPECT_THAT(CordzInfo::Head(CordzSnapshot()), Eq(nullptr));
105    EXPECT_THAT(info->GetCordRepForTesting(), Eq(data.rep.rep));
106    EXPECT_THAT(DeleteQueue(), ElementsAre(info, &snapshot));
107  }
108  TEST(CordzInfoTest, SetCordRep) {
109    TestCordData data;
110    CordzInfo::TrackCord(data.data, kTrackCordMethod);
111    CordzInfo* info = data.data.cordz_info();
112    TestCordRep rep;
113    info->Lock(CordzUpdateTracker::kAppendCord);
114    info->SetCordRep(rep.rep);
115    info->Unlock();
116    EXPECT_THAT(info->GetCordRepForTesting(), Eq(rep.rep));
117    info->Untrack();
118  }
119  TEST(CordzInfoTest, SetCordRepNullUntracksCordOnUnlock) {
120    TestCordData data;
121    CordzInfo::TrackCord(data.data, kTrackCordMethod);
122    CordzInfo* info = data.data.cordz_info();
123    info->Lock(CordzUpdateTracker::kAppendString);
124    info->SetCordRep(nullptr);
125    EXPECT_THAT(info->GetCordRepForTesting(), Eq(nullptr));
126    EXPECT_THAT(CordzInfo::Head(CordzSnapshot()), Eq(info));
127    info->Unlock();
128    EXPECT_THAT(CordzInfo::Head(CordzSnapshot()), Eq(nullptr));
129  }
130  TEST(CordzInfoTest, RefCordRep) {
131    TestCordData data;
132    CordzInfo::TrackCord(data.data, kTrackCordMethod);
133    CordzInfo* info = data.data.cordz_info();
134    size_t refcount = data.rep.rep->refcount.Get();
135    EXPECT_THAT(info->RefCordRep(), Eq(data.rep.rep));
136    EXPECT_THAT(data.rep.rep->refcount.Get(), Eq(refcount + 1));
137    CordRep::Unref(data.rep.rep);
138    info->Untrack();
139  }
140  #if GTEST_HAS_DEATH_TEST
141  TEST(CordzInfoTest, SetCordRepRequiresMutex) {
142    TestCordData data;
143    CordzInfo::TrackCord(data.data, kTrackCordMethod);
144    CordzInfo* info = data.data.cordz_info();
145    TestCordRep rep;
146    EXPECT_DEBUG_DEATH(info->SetCordRep(rep.rep), ".*");
147    info->Untrack();
148  }
149  #endif  
150  TEST(CordzInfoTest, TrackUntrackHeadFirstV2) {
151    CordzSnapshot snapshot;
152    EXPECT_THAT(CordzInfo::Head(snapshot), Eq(nullptr));
153    TestCordData data;
154    CordzInfo::TrackCord(data.data, kTrackCordMethod);
155    CordzInfo* info1 = data.data.cordz_info();
156    ASSERT_THAT(CordzInfo::Head(snapshot), Eq(info1));
157    EXPECT_THAT(info1->Next(snapshot), Eq(nullptr));
158    TestCordData data2;
159    CordzInfo::TrackCord(data2.data, kTrackCordMethod);
160    CordzInfo* info2 = data2.data.cordz_info();
161    ASSERT_THAT(CordzInfo::Head(snapshot), Eq(info2));
162    EXPECT_THAT(info2->Next(snapshot), Eq(info1));
163    EXPECT_THAT(info1->Next(snapshot), Eq(nullptr));
164    info2->Untrack();
165    ASSERT_THAT(CordzInfo::Head(snapshot), Eq(info1));
166    EXPECT_THAT(info1->Next(snapshot), Eq(nullptr));
167    info1->Untrack();
168    ASSERT_THAT(CordzInfo::Head(snapshot), Eq(nullptr));
169  }
170  TEST(CordzInfoTest, TrackUntrackTailFirstV2) {
171    CordzSnapshot snapshot;
172    EXPECT_THAT(CordzInfo::Head(snapshot), Eq(nullptr));
173    TestCordData data;
174    CordzInfo::TrackCord(data.data, kTrackCordMethod);
175    CordzInfo* info1 = data.data.cordz_info();
176    ASSERT_THAT(CordzInfo::Head(snapshot), Eq(info1));
177    EXPECT_THAT(info1->Next(snapshot), Eq(nullptr));
178    TestCordData data2;
179    CordzInfo::TrackCord(data2.data, kTrackCordMethod);
180    CordzInfo* info2 = data2.data.cordz_info();
181    ASSERT_THAT(CordzInfo::Head(snapshot), Eq(info2));
182    EXPECT_THAT(info2->Next(snapshot), Eq(info1));
183    EXPECT_THAT(info1->Next(snapshot), Eq(nullptr));
184    info1->Untrack();
185    ASSERT_THAT(CordzInfo::Head(snapshot), Eq(info2));
186    EXPECT_THAT(info2->Next(snapshot), Eq(nullptr));
187    info2->Untrack();
188    ASSERT_THAT(CordzInfo::Head(snapshot), Eq(nullptr));
189  }
190  TEST(CordzInfoTest, StackV2) {
191    TestCordData data;
192    static constexpr int kMaxStackDepth = 50;
193    CordzInfo::TrackCord(data.data, kTrackCordMethod);
194    CordzInfo* info = data.data.cordz_info();
195    std::vector<void*> local_stack;
196    local_stack.resize(kMaxStackDepth);
197    local_stack.resize(static_cast<size_t>(
198        absl::GetStackTrace(local_stack.data(), kMaxStackDepth,
199                            1)));
200    std::string got_stack = FormatStack(info->GetStack());
201    std::string expected_stack = FormatStack(local_stack);
202    EXPECT_THAT(got_stack, HasSubstr(expected_stack));
203    info->Untrack();
204  }
205  CordzInfo* TrackChildCord(InlineData& data, const InlineData& parent) {
206    CordzInfo::TrackCord(data, parent, kChildMethod);
207    return data.cordz_info();
208  }
209  CordzInfo* TrackParentCord(InlineData& data) {
210    CordzInfo::TrackCord(data, kTrackCordMethod);
211    return data.cordz_info();
212  }
213  TEST(CordzInfoTest, GetStatistics) {
214    TestCordData data;
215    CordzInfo* info = TrackParentCord(data.data);
216    CordzStatistics statistics = info->GetCordzStatistics();
217    EXPECT_THAT(statistics.size, Eq(data.rep.rep->length));
218    EXPECT_THAT(statistics.method, Eq(kTrackCordMethod));
219    EXPECT_THAT(statistics.parent_method, Eq(kUnknownMethod));
220    EXPECT_THAT(statistics.update_tracker.Value(kTrackCordMethod), Eq(1));
221    info->Untrack();
222  }
223  TEST(CordzInfoTest, LockCountsMethod) {
224    TestCordData data;
225    CordzInfo* info = TrackParentCord(data.data);
226    info->Lock(kUpdateMethod);
227    info->Unlock();
228    info->Lock(kUpdateMethod);
229    info->Unlock();
230    CordzStatistics statistics = info->GetCordzStatistics();
231    EXPECT_THAT(statistics.update_tracker.Value(kUpdateMethod), Eq(2));
232    info->Untrack();
233  }
234  TEST(CordzInfoTest, FromParent) {
235    TestCordData parent;
236    TestCordData child;
237    CordzInfo* info_parent = TrackParentCord(parent.data);
238    CordzInfo* info_child = TrackChildCord(child.data, parent.data);
239    std::string stack = FormatStack(info_parent->GetStack());
240    std::string parent_stack = FormatStack(info_child->GetParentStack());
241    EXPECT_THAT(stack, Eq(parent_stack));
242    CordzStatistics statistics = info_child->GetCordzStatistics();
243    EXPECT_THAT(statistics.size, Eq(child.rep.rep->length));
244    EXPECT_THAT(statistics.method, Eq(kChildMethod));
245    EXPECT_THAT(statistics.parent_method, Eq(kTrackCordMethod));
246    EXPECT_THAT(statistics.update_tracker.Value(kChildMethod), Eq(1));
247    info_parent->Untrack();
248    info_child->Untrack();
249  }
250  }  
251  }  
252  ABSL_NAMESPACE_END
253  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-cordz_info_test.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-cordz_info_test.cc</div>
                </div>
                <div class="column column_space"><pre><code>33    std::unique_ptr<char[]> buf(new char[buf_size]);
34    std::string output;
</pre></code></div>
                <div class="column column_space"><pre><code>33    std::unique_ptr<char[]> buf(new char[buf_size]);
34    std::string output;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    