<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for FileHDF5.hpp & BaseTagFS.cpp</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for FileHDF5.hpp & BaseTagFS.cpp
      </h3>
      <h1 align="center">
        8.4%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>FileHDF5.hpp (14.851485%)<TH>BaseTagFS.cpp (5.905512%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match1309-0.html#0',2,'match1309-1.html#0',3)" NAME="0">(62-77)<TD><A HREF="javascript:ZweiFrames('match1309-0.html#0',2,'match1309-1.html#0',3)" NAME="0">(30-31)</A><TD ALIGN=center><FONT COLOR="#ff0000">15</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>FileHDF5.hpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
// Copyright (c) 2013, German Neuroinformatics Node (G-Node)
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted under the terms of the BSD License. See
// LICENSE file in the root of the Project.

#ifndef NIX_FILE_HDF5_H
#define NIX_FILE_HDF5_H

#include &lt;nix/base/IFile.hpp&gt;
#include &lt;nix/Version.hpp&gt;

#include &quot;h5x/H5Group.hpp&quot;

#include &lt;string&gt;
#include &lt;memory&gt;

#define HDF5_FF_VERSION nix::FormatVersion({1, 2, 0})

namespace nix {
namespace hdf5 {

/**
 * Class that represents a NIX file.
 */
class FileHDF5 : public H5Object, public base::IFile, public std::enable_shared_from_this&lt;FileHDF5&gt; {

private:

    /* groups representing different sections of the file */
    Compression compr;
    H5Group root, metadata, data;
    FileMode mode;
    FormatVersion file_format_version;

public:

    /**
     * Constructor that is used to open the file.
     *
     * @param name    The name of the file to open.
     * @param prefix  The prefix used for IDs.
     * @param mode    File open mode ReadOnly, ReadWrite or Overwrite.
     */
    FileHDF5(const std::string &amp;name, const FileMode mode = FileMode::ReadWrite, const Compression compression = Compression::Auto, OpenFlags flags = OpenFlags::None);

    //--------------------------------------------------
    // Methods concerning blocks
    //--------------------------------------------------

    bool flush();


    ndsize_t blockCount() const;


<A NAME="0"></A>    bool hasBlock(const std::string &amp;name_or_id) const;


<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match1309-1.html#0',3,'match1309-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>    std::shared_ptr&lt;base::IBlock&gt; getBlock(const std::string &amp;name_or_id) const;


    std::shared_ptr&lt;base::IBlock&gt; getBlock(ndsize_t index) const;


    std::shared_ptr&lt;base::IBlock&gt; createBlock(const std::string &amp;name, const std::string &amp;type);


    bool deleteBlock(const std::string &amp;name_or_id);

    //--------------------------------------------------
    // Methods concerning sections
    //--------------------------------------------------

    bool hasSection(const std::string &amp;name_or_id) const;</B></FONT>


    std::shared_ptr&lt;base::ISection&gt; getSection(const std::string &amp;name_or_id) const;


    std::shared_ptr&lt;base::ISection&gt; getSection(ndsize_t index) const;


    ndsize_t sectionCount() const;


    std::shared_ptr&lt;base::ISection&gt; createSection(const std::string &amp;name, const std::string &amp;type);


    bool deleteSection(const std::string &amp;name_or_id);

    //--------------------------------------------------
    // Methods for file attribute access.
    //--------------------------------------------------

    std::vector&lt;int&gt; version() const;


    std::string id() const;
    

    void forceId();

    
    std::string format() const;


    std::string location() const;


    time_t createdAt() const;


    time_t updatedAt() const;


    void setUpdatedAt();


    void forceUpdatedAt();


    void setCreatedAt();


    void forceCreatedAt(time_t t);


    void close();


    bool isOpen() const;


    FileMode fileMode() const;


    Compression compression() const;


    bool operator==(const FileHDF5 &amp;other) const;


    bool operator!=(const FileHDF5 &amp;other) const;


    virtual ~FileHDF5();

private:

    std::shared_ptr&lt;base::IFile&gt; file() const;

    // check for existence
    bool fileExists(const std::string &amp;name) const;


    void openRoot();


    bool checkHeader(FileMode mode, bool throw_error);


    void createHeader();
};


} // namespace hdf5
} // namespace nix

#endif // NIX_FILE_HDF5_H
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>BaseTagFS.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
// Copyright (c) 2013 - 2015, German Neuroinformatics Node (G-Node)
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted under the terms of the BSD License. See
// LICENSE file in the root of the Project.

#include &quot;BaseTagFS.hpp&quot;

#include &lt;nix/NDArray.hpp&gt;
#include &quot;DataArrayFS.hpp&quot;
#include &quot;BlockFS.hpp&quot;
#include &quot;FeatureFS.hpp&quot;

namespace bfs= boost::filesystem;

namespace nix {
namespace file {


BaseTagFS::BaseTagFS(const std::shared_ptr&lt;base::IFile&gt; &amp;file, const std::shared_ptr&lt;base::IBlock&gt; &amp;block,
                     const std::string &amp;loc)
    : EntityWithSourcesFS(file, block, loc)
{
    createSubFolders(file);
<A NAME="0"></A>}


<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1309-0.html#0',2,'match1309-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>BaseTagFS::BaseTagFS(const std::shared_ptr&lt;base::IFile&gt; &amp;file, const std::shared_ptr&lt;base::IBlock&gt; &amp;block,
                     const std::string &amp;loc, const std::string &amp;id, const std::string &amp;type, const std::string &amp;name)</B></FONT>
    : BaseTagFS(file, block, loc, id, type, name, util::getTime())
{
}


BaseTagFS::BaseTagFS(const std::shared_ptr&lt;base::IFile&gt; &amp;file, const std::shared_ptr&lt;base::IBlock&gt; &amp;block,
                     const std::string &amp;loc, const std::string &amp;id, const std::string &amp;type, const std::string &amp;name, time_t time)
    : EntityWithSourcesFS(file, block, loc, id, type, name, time)
{
    createSubFolders(file);
}


void BaseTagFS::createSubFolders(const std::shared_ptr&lt;base::IFile&gt; &amp;file) {
    bfs::path refs(&quot;references&quot;);
    bfs::path feats(&quot;features&quot;);
    bfs::path p(location());

    refs_group = Directory(p / refs, file-&gt;fileMode());
    feature_group = Directory(p / feats, file-&gt;fileMode());
}

//--------------------------------------------------
// Methods concerning references.
//--------------------------------------------------

bool BaseTagFS::hasReference(const std::string &amp;name_or_id) const {
    std::string id = block()-&gt;resolveEntityId({name_or_id, ObjectType::DataArray});
    return refs_group.hasObject(id);
}


ndsize_t BaseTagFS::referenceCount() const {
    return refs_group.subdirCount();
}


std::shared_ptr&lt;base::IDataArray&gt;  BaseTagFS::getReference(const std::string &amp;name_or_id) const {
    std::shared_ptr&lt;base::IDataArray&gt; da;

    std::string id = block()-&gt;resolveEntityId({name_or_id, ObjectType::DataArray});

    if (hasReference(id)) {
        boost::optional&lt;bfs::path&gt; path = refs_group.findByNameOrAttribute(&quot;name&quot;, name_or_id);
        if (path) {
            return std::make_shared&lt;DataArrayFS&gt;(file(), block(), path-&gt;string());
        }
    }
    return da;
}


std::shared_ptr&lt;base::IDataArray&gt;  BaseTagFS::getReference(ndsize_t index) const {
    bfs::path p = refs_group.sub_dir_by_index(index);
    return std::make_shared&lt;DataArrayFS&gt;(file(), block(), p.string());
}


void BaseTagFS::addReference(const std::string &amp;name_or_id) {
    if (!block()-&gt;hasEntity({name_or_id, ObjectType::DataArray}))
        throw std::runtime_error(&quot;BaseTagFS::addReference: DataArray not found in block!&quot;);

    auto target = std::dynamic_pointer_cast&lt;DataArrayFS&gt;(block()-&gt;getEntity({name_or_id, ObjectType::DataArray}));
    refs_group.createDirectoryLink(target-&gt;location(), target-&gt;id());
}


bool BaseTagFS::removeReference(const std::string &amp;name_or_id) {
    return refs_group.removeObjectByNameOrAttribute(&quot;name&quot;, name_or_id);
}


void BaseTagFS::references(const std::vector&lt;DataArray&gt; &amp;refs_new) {
     while (referenceCount() &gt; 0) {
        removeReference(getReference(0)-&gt;id());
    }

    for (const auto &amp;ref : refs_new) {
        addReference(ref.id());
    }
}

//--------------------------------------------------
// Methods concerning features.
//--------------------------------------------------

bool BaseTagFS::hasFeature(const std::string &amp;name_or_id) const {
    return getFeature(name_or_id) != nullptr;
}


ndsize_t BaseTagFS::featureCount() const {
    return feature_group.subdirCount();
}


std::shared_ptr&lt;base::IFeature&gt; BaseTagFS::getFeature(const std::string &amp;name_or_id) const {
    std::shared_ptr&lt;base::IFeature&gt; feature;
    boost::optional&lt;bfs::path&gt; p = feature_group.findByNameOrAttribute(&quot;name&quot;, name_or_id);
    if (p) {
        return std::make_shared&lt;FeatureFS&gt;(file(), block(), p-&gt;string());
    } else {
        for (ndsize_t i = 0; i &lt; feature_group.subdirCount(); i++) {
            bfs::path dir = feature_group.sub_dir_by_index(i);
            std::shared_ptr&lt;base::IFeature&gt; feat = std::make_shared&lt;FeatureFS&gt;(file(), block(), dir.string());
            std::shared_ptr&lt;base::IDataArray&gt; da = feat-&gt;data();
            if (da-&gt;name() == name_or_id || da-&gt;id() == name_or_id) {
                feature = std::make_shared&lt;FeatureFS&gt;(file(), block(), dir.string());
                break;
            }
        }
    }
    return feature;
}


std::shared_ptr&lt;base::IFeature&gt;  BaseTagFS::getFeature(ndsize_t index) const {
    bfs::path id = feature_group.sub_dir_by_index(index);
    return getFeature(id.filename().string());
}


std::shared_ptr&lt;base::IFeature&gt;  BaseTagFS::createFeature(const std::string &amp;name_or_id, LinkType link_type) {
    if(!block()-&gt;hasEntity({name_or_id, ObjectType::DataArray})) {
        throw std::runtime_error(&quot;DataArray not found in Block!&quot;);
    }
    std::string rep_id = util::createId();
    DataArray a = std::dynamic_pointer_cast&lt;base::IDataArray&gt;(block()-&gt;getEntity({name_or_id, ObjectType::DataArray}));
    return std::make_shared&lt;FeatureFS&gt;(file(), block(), feature_group.location(), rep_id, a, link_type);
}


bool BaseTagFS::deleteFeature(const std::string &amp;name_or_id) {
    return feature_group.removeObjectByNameOrAttribute(&quot;name&quot;, name_or_id);
}


BaseTagFS::~BaseTagFS() {}

} // ns nix::file
} // ns nix
</PRE>
</div>
  </div>
</body>
</html>
