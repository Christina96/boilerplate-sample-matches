
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 17.274472168905948%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-hysgen.cpp</h3>
            <pre><code>1  #include "stdafx.h"
2  #include "hysgen.h"
3  void THysgenUtil::DumpCmtyVV(const TStr OutFNm, TVec<TIntV>& CmtyVV, TIntStrH& NIDNmH) {
4    FILE* F = fopen(OutFNm.CStr(), "wt");
5    for (int c = 0; c < CmtyVV.Len(); c++) {
6      fprintf(F, "\n\n*** COMMUNITY #%d, Length=%d ***\n", c+1, CmtyVV[c].Len());
7      for (int u = 0; u < CmtyVV[c].Len(); u++) {
8        if (NIDNmH.IsKey(CmtyVV[c][u])){
9          fprintf(F, "%s\t", NIDNmH.GetDat(CmtyVV[c][u]).CStr());
10        }
11        else {
12          fprintf(F, "%d\t", (int) CmtyVV[c][u]);
13        }
14      }
15      fprintf(F, "\n");
16    }
17    fclose(F);
18  }
19  void THysgenUtil::DumpCmtyVH(const TStr OutFNm, TVec<TIntFltH>& CmtyVH, TIntStrH& NIDNmH, Criteria Crit) {
20    FILE* F = fopen(OutFNm.CStr(), "wt");
21    int UId;
22    for (int c = 0; c < CmtyVH.Len(); c++) {
23      fprintf(F, "\n\n*** COMMUNITY #%d, Length=%d ***\n", c+1, CmtyVH[c].Len());
24      TIntV SortedV;
25      if (Crit == Alphabetical) {
26        TIntStrH SortedCNames;
27        for (TIntFltH::TIter NI = CmtyVH[c].BegI(); NI < CmtyVH[c].EndI(); NI++) {
28          SortedCNames.AddDat(NI.GetKey(), NIDNmH.GetDat(NI.GetKey()));
29        }
30        SortedCNames.SortByDat();
31        for (TIntStrH::TIter NI = SortedCNames.BegI();
32             NI < SortedCNames.EndI(); NI++) {
33          SortedV.Add(NI.GetKey());
34        }
35      } else {
36        CmtyVH[c].SortByDat(false);
37        CmtyVH[c].GetKeyV(SortedV);
38      }
39      for (TIntV ::TIter NI = SortedV.BegI(); NI < SortedV.EndI(); NI++) {
40        UId = NI->Val;
41        if (NIDNmH.IsKey(UId)){
42          fprintf(F, "%s: ", NIDNmH.GetDat(UId).CStr());
43        }
44        else {
45          fprintf(F, "%d: ", UId);
46        }
47        fprintf(F, "%f,\t", (double) CmtyVH[c].GetDat(UId));
48      }
49      fprintf(F, "\n");
50    }
51    fclose(F);
52  }
53  PHGraph THysgenUtil::LoadEdgeList(const TStr& InFNm, TStrHash<TInt>& NodeNameH,
54                                    TSsFmt SsFmt) {
55    TSsParser Ss(InFNm, SsFmt);
56    PHGraph PG = THGraph::New();
57    THGraph& G = *PG;
58    TStrHash<TInt> StrSet(Mega(1), true);
59    int EIdCtr = 0;
60    int RedunEdgesCnt = 0; 
61    std::string Curr;
62    while (Ss.Next()) {
63      TIntSet NIdH;
64      NIdH.Gen(Ss.Len());
65      if (Ss.Len() == 0) { continue; }
66      Curr = Ss[0];
67      if (Curr.compare(0,1, "#") == 0) { continue; } 
68      for (int i = 0; i < Ss.Len(); i++){
69        int ENId = StrSet.AddKey(Ss[i]);
70        if (! G.IsNode(ENId)) { G.AddNode(ENId, Ss[i]); }
71        NIdH.AddKey(ENId);
72      }
73      if (G.AddEdge(NIdH,EIdCtr) >= 0) {
74        EIdCtr++;
75      } else {RedunEdgesCnt++; }
76    }
77    printf("\nNumber of redundant edges: %d:\n", RedunEdgesCnt);
78    NodeNameH = StrSet;
79    NodeNameH.Pack();
80    G.Defrag();
81    return PG;
82  }
83  template<class PHGraph>
84  double THysgenUtil::GetConductance(const PHGraph& Graph, const TIntSet& CmtyS,
85                                     const int N2Edges) {
86    TIntV NeiNV;
87    int Vol = 0,  Cut = 0;
88    double Phi = 0.0;
89    for (int i = 0; i < CmtyS.Len(); i++) {
90      if (! Graph->IsNode(CmtyS[i])) { continue; }
91      THGraph::TNodeI  NI = Graph->GetNI(CmtyS[i]);
92      NI.GetNbrNodes(NeiNV);
93      for (int nei = 0; nei < NeiNV.Len(); nei++) {
94        if (! CmtyS.IsKey(NeiNV[nei])) { Cut += 1; }
95      }
96      Vol += NI.Get2Edges();
97    }
98    int N2Edges2 = N2Edges * 2;
99    if (Vol != N2Edges2) {
100      if (N2Edges2 - Vol < Vol) { Phi = Cut / double (N2Edges2 - Vol); }
101      else if (Vol == 0) { Phi = 0.0; }
102      else { Phi = Cut / double(Vol); }
103    } else {
104      if (Vol == N2Edges2) { Phi = 1.0; }
105    }
106    return Phi;
107  }
108  template<class PHGraph>
109  void THysgenUtil::GetNbhCom(const PHGraph& Graph, const int NID, TIntSet& NBCmtyS) {
110    THGraph::TNodeI NI = Graph->GetNI(NID);
111    NBCmtyS.Gen(NI.GetNbrNodes() + 1);
112    NBCmtyS.AddKey(NID);
113    for (int e = 0; e < NI.GetNbrNodes(); e++) {
114      NBCmtyS.AddKey(NI.GetNbrNId(e));
115    }
116  }
117  template<class PHGraph>
118  void THysgenUtil::GetPhiNIdPrV(const PHGraph &G, TFltIntPrV &PhiNIdPrV, const int MinComSiz) {
119    PhiNIdPrV.Gen(G->GetNodes(), 0);
120    const int N2Edges = G->Get2Edges();
121    TExeTm RunTm;
122    for (THGraph::TNodeI NI = G->BegNI(); NI < G->EndNI(); NI++) {
123      TIntSet NBCmty(NI.GetNbrNodes() + 1);
124      double Phi;
125      if (NI.GetNbrNodes() < MinComSiz) { 
126        Phi = 1.0;
127      } else {
128        THysgenUtil::GetNbhCom<PHGraph>(G, NI.GetId(), NBCmty);
129        Phi = THysgenUtil::GetConductance(G, NBCmty, N2Edges);
130      }
131      PhiNIdPrV.Add(TFltIntPr(Phi, NI.GetId()));
132    }
133    PhiNIdPrV.Sort(true);
134    fflush(stdout);
135  }
136  void THysgenUtil::GetBinLocs(const int& DecNum, TIntV& LocsV, const TIntV& NodMapV) {
137    int MaxShift = ceil(TMath::Log2((double) DecNum+1));
138    int NumCopy = DecNum;
139    for (int j = 0; j < MaxShift; j++) {
140      if ( NumCopy / 2.0 != floor(NumCopy / 2.0) ) {
141        LocsV.Add(NodMapV[j]);
142      }
143      NumCopy = int(NumCopy / 2.0);
144    }
145  }
146  void THysgen::SetGraph(const PHGraph& GraphPt) {
147    HONEIdsV.Gen(GraphPt->GetNodes());
148    HONNIdsV.Gen(GraphPt->GetNodes());
149    HOKIDSV.Gen(GraphPt->GetNodes());
150    TIntV NIDV;
151    GraphPt->GetNIdV(NIDV);
152    NIdToIdx.Gen(NIDV.Len());
153    NIdToIdx.AddKeyV(NIDV);
154    G = TSnap::GetSubGraph(GraphPt, NIDV);
155    for (int nid = 0; nid < G->GetNodes(); nid++) {
156      IAssert(G->IsNode(nid));
157    }
158    PrNoCom = 1.0 / (double) G->GetNodes();
159    if (1.0 / PrNoCom > sqrt(TFlt::Mx)) { PrNoCom = 0.99 / sqrt(TFlt::Mx); } 
160    NegWgt = 1.0;
161  }
162  void THysgen::LoadComInit(const TStr& InFNm, TSsFmt SsFmt) {
163    TSsParser Ss(InFNm, SsFmt);
164    TVec<TStrFltH> ComsVH;
165    TStrSet NodsInFile(G->GetNodes());
166    std::string Curr;
167    printf("Loading community initializations from file ...\n");
168    while (Ss.Next()) {
169      if (Ss.Len() == 0) { continue; }
170      Curr = Ss[0];
171      if (Curr.compare(0,1, "#") == 0 || Curr.compare(0,1, "*") == 0) { continue; } 
172      TStrFltH CurComH;
173      for (int i = 0; i < Ss.Len(); i++){
174        Curr = Ss[i];
175        TStr NName; double SN;
176        int SepLoc = Curr.find_first_of(":");
177        if (SepLoc == -1) {
178          NName = Curr.c_str();
179          SN = InitVal;
180        } else {
181          NName = Curr.substr(0, SepLoc).c_str();
182          SN = strtod(Curr.substr(SepLoc + 2, 8).c_str(), NULL);
183        }
184        CurComH.AddDat(NName, SN);
185        NodsInFile.AddKey(NName);
186      }
187      ComsVH.Add(CurComH);
188    }
189    for (int c = 0; c < ComsVH.Len(); c++) {
190      for (THGraph::TNodeI NI = G->BegNI(); NI < G->EndNI(); NI++) {
191        AddNCom(NI.GetId(), c, InitNullS);
192        if (ComsVH[c].IsKey(NI.GetName())) {
193          AddNCom(NI.GetId(), c, ComsVH[c].GetDat(NI.GetName()));
194        }
195      }
196    }
197    printf("\n");
198    for (int c = 0; c < GetNumComs(); c++) {
199      printf("comm %d:\t\t", c);
200      for (THGraph::TNodeI NI = G->BegNI(); NI < G->EndNI(); NI++) {
201        if (GetNCom(NI.GetId(),c) > InitNullS) {
202          printf("%s,%0.2f\t",NI.GetName().CStr(), GetNCom(NI.GetId(),c));
203        }
204      }
205      printf("\n");
206    }
207    printf("\n Likelihood of the initial community memberships from the file is: %f\n", Likelihood());
208  }
209  void THysgen::ComInit(const int InitComs, const int MinComSiz, const double PerturbDens) {
210    IAssertR(InitVal>0.0 || InitNullS>0.0, "Error: At least one of -ic or -in "
211             "parameters should be set > 0. Cannot start without any initalization.");
212    S.Gen(G->GetNodes()); 
213    time_t InitTime = time(NULL);
214    printf("\n** Initializing the communities and the parameters is started...\n");
215    NumCIdNV.Gen(InitComs);
216    NumComs = InitComs;
217    if (InitNullS > 0.0) {
218      UniformComInit(InitComs);
219      InitTime = time(NULL);
220      InitEdgeProb();
221    }
222    if (InitNullS != InitVal) {
223      InitTime = time(NULL);
224      NeighborComInit(MinComSiz, InitNullS==0.0);
225      if (InitNullS==0.0) {
226        InitTime = time(NULL);
227        InitEdgeProb();
228      }
229    }
230    if (InitNullS != InitVal) {
231      RandomComPerturb(PerturbDens);
232    } else { RandomComPerturb(); }
233    printf("\n** Initializations finsihed [%lu sec]\n", time(NULL) - InitTime);
234  }
235  void THysgen::UniformComInit(const int InitComs) {
236    for (int c=0; c < NumComs; c++) {
237      for (THGraph::TNodeI NI = G->BegNI(); NI < G->EndNI(); NI++) {
238        AddNCom(NI.GetId(), c, InitNullS, true);
239      }
240    }
241  }
242  void THysgen::RandomComPerturb(double Density) {
243    if (Density <= 0.0) { return; }
244    for (int c=0; c < NumComs; c++) {
245      for (THGraph::TNodeI NI = G->BegNI(); NI < G->EndNI(); NI++) {
246        if (GetNCom(NI.GetId(), c) == 0) { continue; } 
247        if (Rnd.GetUniDev() < Density) { AddNCom(NI.GetId(), c, InitVal*Rnd.GetUniDev()); }
248      }
249    }
250  }
251  void THysgen::NeighborComInit(const int MinComSiz, const bool& IsInit) {
252    TFltIntPrV PhiNIdPrV;
253    THysgenUtil::GetPhiNIdPrV<PHGraph>(G, PhiNIdPrV, MinComSiz);
254    NeighborComInit(PhiNIdPrV, IsInit);
255  }
256  void THysgen::NeighborComInit(TFltIntPrV& PhiNIdPrV, const bool& IsInit) {
257    PhiNIdPrV.Sort(true);
258    TIntV NIdV;
259    TIntV EIdV;
260    THGraph::TNodeI NI;
261    THGraph::TEdgeI EI;
262    TIntSet InvalidNIDS(S.Len());
263    TIntV NumCIdNDefV(NumComs, 0);
264    int CurCID = 0;
265    for (int ui = 0; ui < PhiNIdPrV.Len(); ui++) {
266      if (PhiNIdPrV[ui].Val1 == 0.0) { 
267        continue;
268      }
269      int UID = PhiNIdPrV[ui].Val2;
270      fflush(stdout);
271      if (InvalidNIDS.IsKey(UID)) { continue; }
272      AddNCom(UID, CurCID, InitVal, IsInit);
273      InvalidNIDS.AddKey(UID);
274      NI = G->GetNI(UID);
275      fflush(stdout);
276      NI.GetNbrNodes(NIdV);
277      AddNCom(NIdV, CurCID, InitVal, IsInit);
278      NumCIdNDefV[CurCID] = NIdV.Len()+1;
279      InvalidNIDS.AddKeyV(NIdV);
280      CurCID++;
281      if (CurCID >= NumComs) { break; }
282      fflush(stdout);
283    }
284    if (NumComs > CurCID) {
285      printf("%d communities needed to fill randomly\n", NumComs - CurCID);
286    }
287    for (int c = 0; c < NumCIdNV.Len(); c++) {
288      if (NumCIdNDefV[c] == 0) {
289        printf("Empty communities remained after initialization. "
290               "Members are getting assigned randomly!!\n\n");
291        int ComSz = 10;
292        for (int u = 0; u < ComSz; u++) {
293          int UID = Rnd.GetUniDevInt(G->GetNodes());
294          AddNCom(UID, c, InitVal, IsInit);
295        }
296      }
297    }
298  }
299  void THysgen::InitEdgeProb(){
300    TInt NId;
301    TInt CIterKey;
302    ProbEdgCommHH.Gen(G->GetEdges());
303    ProbNotEdgH.Gen(G->GetEdges());
304    ProbEdgH.Gen(G->GetEdges());
305    ProbENoiseV.Gen(G->GetNodes(),1);
306    ProbENoiseV[0] = 1;
307    int DPMatSize = NumComs + (SNoise>0); 
308    AuxDPEdgVV.Gen(DPMatSize);
309    for (int i = 0; i < DPMatSize; i++) {
310      AuxDPEdgVV[i].Gen(DPMatSize);
311      for (int j = 0; j < DPMatSize; j++) {
312        AuxDPEdgVV[i][j] = 0.0;
313      }
314    }
315    for (THGraph::TEdgeI EI = G->BegEI(); EI < G->EndEI(); EI++) {
316      TIntV NumMmbrsInEdgV(NumComs);
317      TIntFltH ProdH(NumComs);
318      TIntV NeiNV;
319      EI.GetNodesV(NeiNV);
320      for (int n = 0; n < NeiNV.Len(); n++) {
321        NId = NeiNV[n];
322        for (TIntFltH::TIter SNI = S[NId].BegI(); SNI < S[NId].EndI(); SNI++) {
323          CIterKey = SNI.GetKey();
324          if (!ProdH.IsKey(CIterKey)) { ProdH.AddDat(CIterKey, 1.0); }
325          ProdH.AddDat(CIterKey, ProdH.GetDat(CIterKey)*SNI.GetDat());
326          NumMmbrsInEdgV[CIterKey] ++;
327        }
328      }
<span onclick='openModal()' class='match'>329      for (int CId = 0; CId < NumComs; CId++){
330        if (NumMmbrsInEdgV[CId] > 0 && NumMmbrsInEdgV[CId] < NeiNV.Len()) {
331          ProdH.DelKey(CId);
332        }
333      }
334      AddECom(EI.GetId(), ProdH);
335    }
</span>336    if (InitNullS > 0.0) { InitPrAllEdgesS(InitNullS, true);
337    } else { InitPrAllEdgesS(InitVal, false); }
338  }
339  void THysgen::UpdateUEdgesProb(const int& UId, const int& CId, const double& SUNew){
340    double SUOld = GetNCom(UId,CId);
341    TIntV EIdV;
342    TIntFltH ProbEH;
343    double PrECOld;
344    double PrECNew;
345    int EId;
346    G->GetNI(UId).GetEIDs(EIdV);
347    for (int e = 0; e < EIdV.Len(); e++) {
348      EId = EIdV[e];
349      if (SUOld < DBL_EPSILON) {
350        TIntV ENodesV;
351        G->GetEI(EId).GetNbrNodes(ENodesV);
352        PrECNew = SUNew;
353        for (int n = 0; n < ENodesV.Len(); n++) {
354          if (ENodesV[n] == UId) { continue; }
355          PrECNew *= GetNCom(ENodesV[n], CId);
356        }
357      } else {
358        PrECOld = GetECom(EId, CId);
359        PrECNew = PrECOld*SUNew/SUOld;
360      }
361      if (PrECNew > 0.0) {
362        AddECom(EId, CId, PrECNew);
363      } else {
364        DelECom(EId, CId);
365      }
366    }
367  }
368  void THysgen::InitPrAllEdgesS(const double& DefVal, const bool& IsEqualComms){
369    if (SumPrPsblEdgesPow_nVV.Len()==0) {
370      SumPrPsblEdgesPow_nVV.Gen(NumCIdNV.Len(), 0.0);
371    } else {
372      SumPrPsblEdgesPow_nVV.Clr();
373      SumPrPsblEdgesPow_nVV.Gen(NumCIdNV.Len(), 0.0);
374    }
375    TFlt SToN = 1.0;
376    for (int c=0; c<NumCIdNV.Len(); c++){
377      TFltV PsiV;
378      PsiV.Add(1.0);
379      SToN = 1.0;
380      for (int n=1; (n <= MinTayN && PsiV[n-1] > 0.0) || (n<=TayN && PsiV[n-1]>TayThresh) ; n++){ 
381        SToN *= DefVal;
382        PsiV.Add(pow(SToN+1.0, NumCIdNV[c]) - 1);
383      }
384      SumPrPsblEdgesPow_nVV.Add(PsiV);
385      if (IsEqualComms && NumCIdNV.Len()>1) {
386        for (int c=1; c<NumCIdNV.Len(); c++) {
387          TFltV PsiVCopy(SumPrPsblEdgesPow_nVV[0]);
388          SumPrPsblEdgesPow_nVV.Add(PsiVCopy);
389        }
390        printf("\n Done the same initialization for the rest of %d communities...\n",NumComs()-1);
391        break;
392      }
393    }
394  }
395  void THysgen::UpdatePrAllEdgesS(const int &UID, const int &CID, const double& SNNew){
396    TFltV PsiV(SumPrPsblEdgesPow_nVV[CID].Len());
397    UpdatePrAllEdgesS(PsiV, UID, CID, SNNew, true);
398  }
399  void THysgen::UpdatePrAllEdgesS(TFltV& PsiV, const int& UID, const int& CID, const double& SNNew, const bool IsApplyChange){
400    PsiV[0] = 1.0; 
401    double SNOld = GetNCom(UID,CID);
402    double SToNOld = 1.0, SToNNew = 1.0;
403    int nLast = 0;
404    for (int n=1; (n <= MinTayN && PsiV[n-1] > 0.0) ||
405                  (n <= TayN    && PsiV[n-1]>TayThresh); n++){
406      if (n >= PsiV.Len()) {
407        PsiV.Add(0.0);
408      }
409      SToNOld *= SNOld; SToNNew *= SNNew;
410      PsiV[n] = ((SToNNew+1.0)/(SToNOld+1.0)) *
411                                      (SumPrPsblEdgesPow_nVV[CID][n]-SToNOld) + SToNNew; 
412      nLast = n;
413    }
414    if (IsApplyChange) {
415      for (int n = 1; n <= nLast; n++) {
416        if (n >= SumPrPsblEdgesPow_nVV[CID].Len()) {
417          SumPrPsblEdgesPow_nVV[CID].Add(-1.0);
418        }
419        SumPrPsblEdgesPow_nVV[CID][n] = PsiV[n];
420      }
421      nLast++;
422      while (nLast < SumPrPsblEdgesPow_nVV[CID].Len()) {
423        SumPrPsblEdgesPow_nVV[CID][nLast] = 0.0;
424        nLast++;
425      }
426    }
427  }
428  double THysgen::PredictAllCEdgesS(const int &UID, const int &CID,
429                                    const bool IsLikelihood, const bool Verbose){
430    double SCoef = 1.0;
431    double LikCoef = 1.0;
432    double S_uc = GetNCom(UID,CID);
433    double SPowN = 1.0;
434    if (!IsLikelihood){
435      if (S_uc <= 0.0) { return SumPrPsblEdgesPow_nVV[CID][1]; }
436      else { SCoef = 1.0/S_uc; }
437    }
438    if (S_uc<=0.0 && IsLikelihood) { return 0.0; }
439    double Val = 0.0;
440    double Val_n;
441    if (Verbose) {
442      printf("### PredictAllCEdgesS for node %d and comm %d :\n", UID, CID);
443    }
444    for (int n=1; n<SumPrPsblEdgesPow_nVV[CID].Len() &&
445                  SumPrPsblEdgesPow_nVV[CID][n]>TayThresh; n++){
446      if (IsLikelihood) { LikCoef = -n; }
447      SPowN *= S_uc;
448      Val_n = SCoef * (SPowN/(1+SPowN)) * (SumPrPsblEdgesPow_nVV[CID][n] - SPowN) / LikCoef;
449      Val += Val_n;
450      if(Verbose){
451        printf("\t --- (n=%d): %f\n", n , Val_n);
452      }
453    }
454    return Val;
455  }
456  double THysgen::PredictAllCEdgesS(const int &UID, const int &CID, const double& SNNew,
457                                    const bool IsLikelihood, const bool Verbose){
458    IAssertR(IsLikelihood,"This Overload of function is only designed for computing the likelihood, not gradient!\n");
459    double SCoef = 1.0;
460    double LikCoef;
461    double SPowN = 1.0;
462    if (SNNew <= 0.0) { return 0.0; } 
463    double Val = 0.0;
464    double Val_n;
465    if (Verbose) {
466      printf("### PredictAllCEdgesS for node %d and comm %d :\n", UID, CID);
467    }
468    TFltV PsiV(SumPrPsblEdgesPow_nVV[CID].Len());
469    UpdatePrAllEdgesS(PsiV, UID, CID, SNNew, false);
470    for (int n=1; n<PsiV.Len() && PsiV[n]>TayThresh; n++){ 
471      LikCoef = -n;
472      SPowN *= SNNew;
473      Val_n = SCoef * (SPowN/(1.0+SPowN)) * (PsiV[n] - SPowN) / LikCoef;
474      Val += Val_n;
475      if(Verbose){
476        printf("\t --- (n=%d): %f\n", n , Val_n);
477      }
478    }
479    return Val;
480  }
481  double THysgen::PredictAllCEdgesS_direct(const int &UID, const int &CID,
482                                           const bool IsLikelihood, const bool Verbose) {
483    double Psi_c = 0.0;
484    double S_uc = GetNCom(UID,CID);
485    if (S_uc <= 0.0 && IsLikelihood) { return 0.0; }
486    TIntV CNodesV(S.Len(),0);
487    for (int nod=0; nod < S.Len(); nod++) {
488      if (GetNCom(nod, CID) > 0.0 || nod==UID) {CNodesV.Add(nod);}
489    }
490    TInt NPsbEdges = pow(2, CNodesV.Len());
491    for (int e=0; e<NPsbEdges; e++) {
492      TIntV ENodesV;
493      THysgenUtil::GetBinLocs(e, ENodesV, CNodesV);
494      if (!ENodesV.IsIn(UID) || ENodesV.Len() < 2) { continue; }
495      double ECProb = 1.0;
496      for (int i = 0; i < ENodesV.Len(); i++) {
497        if (Verbose) {
498          printf("%d, ", ENodesV[i]()); }
499        if (ENodesV[i] != UID) { ECProb *= GetNCom(ENodesV[i], CID); }
500      }
501      if (Verbose) {
502        printf(" --\t ECProb=%f, ", ECProb);
503      }
504      if (ECProb == 1.0 && S_uc == 1.0) { continue; }
505      if (!IsLikelihood) {
506        Psi_c += (ECProb / (1.0 - ECProb*S_uc));
507      } else {
508        Psi_c += log(1.0 - ECProb*S_uc);
509      }
510      if (Verbose) {
511        printf(" *Islikelihood=%d*, Psi_c=%f\n", IsLikelihood, Psi_c); }
512    }
513    return Psi_c;
514  }
515  void THysgen::UpdateProbNotEdgH(const int &EId, const double &PrECNew,
516                                const double &PrECOld) {
517    double PrENoise = GetENoiseProb(G->GetEI(EId).Len());
518    if (PrECNew>=0.0 && ProbNotEdgH.IsKey(EId) && ProbNotEdgH.GetDat(EId)()==-1.0)  {
519      TIntFltH& ProdH = ProbEdgCommHH.GetDat(EId); 
520      ProbEdgH.AddDat(EId, GetPrEPrecision(ProdH, AuxDPEdgVV, PrENoise));
521      if (1.0 - ProbEdgH.GetDat(EId) < 1.0) { 
522        ProbNotEdgH.AddDat(EId, 1.0 - ProbEdgH.GetDat(EId));
523      }
524      return;
525    }
526    double PrNotE;
527    if (PrECOld < 1.0){
528      PrNotE = ProbNotEdgH.GetDat(EId) * (1.0 - PrECNew) / (1.0 - PrECOld);
529    } else {
530      PrNotE = 1.0 - PrENoise;
531      for (TIntFltH::TIter HI = ProbEdgCommHH.GetDat(EId).BegI();
532           HI < ProbEdgCommHH.GetDat(EId).EndI(); HI++) {
533        PrNotE *= 1.0 - HI.GetDat();
534      }
535    }
536    ProbNotEdgH.AddDat(EId, PrNotE);
537    ProbEdgH.AddDat(EId, 1-PrNotE);
538    if (PrNotE >= 1.0) {
539      TIntFltH& ProdH = ProbEdgCommHH.GetDat(EId);
540      ProbEdgH.AddDat(EId, GetPrEPrecision(ProdH, AuxDPEdgVV, PrENoise));
541      ProbNotEdgH.AddDat(EId,-1.0);
542    }
543  }
544  double THysgen::DotProduct(const TIntFltH& UV, const TIntFltH& VV) {
545    double DP = 0.0;
546    for (TIntFltH::TIter HI = VV.BegI(); HI < VV.EndI(); HI++) {
547      if (UV.IsKey(HI.GetKey())) {
548        DP += UV.GetDat(HI.GetKey()) * HI.GetDat();
549      }
550    }
551    return DP;
552  }
553  void THysgen::SetCmtyVV(const TVec<TIntV>& CmtyVV) {
554    S.Gen(G->GetNodes());
555    NumCIdNV.Gen(CmtyVV.Len());
556    NumComs = CmtyVV.Len();
557    for (int c = 0; c < CmtyVV.Len(); c++) {
558      for (int u = 0; u < CmtyVV[c].Len(); u++) {
559        int UID = CmtyVV[c][u];
560        if (! NIdToIdx.IsKey(UID)) { continue; }
561        AddNCom(NIdToIdx.GetKeyId(UID), c, 1.0);
562      }
563    }
564  }
565  double THysgen::Likelihood() {
566    TExeTm ExeTm;
567    double L = 0.0;
568    for (int u = 0; u < S.Len(); u++) {
569      double LU = LikelihoodForRow(u);
570      L += LU;
571    }
572    return L ;
573  }
574  double THysgen::LikelihoodForRow(const int UID) {
575    return LikelihoodForRow(UID, S[UID]);
576  }
577  double THysgen::LikelihoodForRow(const int UID, const TIntFltH &SU) {
578    bool IsSUpdated = false;
579    if (S[UID].Len() != SU.Len()) {
580      IsSUpdated = true;
581    } else {
582      for (int CID = 0; CID < NumComs; CID++){
583        if (!S[UID].IsKey(CID) && !SU.IsKey(CID)) {continue;}
584        if ( (S[UID].IsKey(CID) && !SU.IsKey(CID)) ||
585            (!S[UID].IsKey(CID) && SU.IsKey(CID)) ||
586            abs(S[UID].GetDat(CID) - SU.GetDat(CID)) > DBL_MIN ) {
587          IsSUpdated = true;
588          break;
589        }
590      }
591    }
592    double L = 0.0;
593    const bool IsLikelihood = true;
594    THGraph::TNodeI NI = G->GetNI(UID);
595    TIntV EIdV; 
596    NI.GetEIDs(EIdV);
597    TFlt SumLgPrNotUEdges = 0.0; 
598    for (int e = 0; e < NI.GetDeg(); e++) {
599      int EId = EIdV[e];
600      TIntFltH PrENewCH;
601      if (HONNIdsV[UID].IsKey(EId)) { continue; }
602        L += log(GetPrE(EId, UID, SU, PrENewCH));
603        for (TIntFltH::TIter PrECI = PrENewCH.BegI(); PrECI < PrENewCH.EndI(); PrECI++){
604          SumLgPrNotUEdges += log(1.0 - PrECI.GetDat());
605        }
606    }
607    TFlt SumAllPsbl = 0.0;
608    for (TIntFltH::TIter UCI = SU.BegI(); UCI < SU.EndI(); UCI++) {
609      if (IsSUpdated) {
610        SumAllPsbl += PredictAllCEdgesS(UID, UCI.GetKey(), UCI.GetDat(), IsLikelihood);
611      } else {
612        SumAllPsbl += PredictAllCEdgesS(UID, UCI.GetKey(), IsLikelihood);
613      }
614    }
615    L += NegWgt * (SumAllPsbl - SumLgPrNotUEdges);
616    if (RegCoef > 0.0) {
617      L -= RegCoef * Sum(SU);
618    }
619    return L;
620  }
621  void THysgen::GradientForRow(const int UId, TIntFltH &GradNod) {
622    GradNod.Gen(GetNumComs());
623    THGraph::TNodeI NI = G->GetNI(UId);
624    int NDeg = NI.GetDeg();
625    TIntV EIdV; 
626    NI.GetEIDs(EIdV);
627    TIntFltH PredEH(NDeg);
628    TFltV PredECMinusUV(GetNumComs());
629    TFltV GradV(GetNumComs());
630    TIntV CIDV(GetNumComs());
631    TIntV NIdV;
632    TInt NId;
633    TInt EId;
634    for (int e = 0; e < NDeg; e++) {
635      EId = EIdV[e];
636      if (HONEIdsV[UId].IsKey(EId)) { continue; }
637      PredEH.AddDat(EId, GetPrE(EId)); 
638    }
639    for (int CId = 0; CId < NumComs; CId++) { 
640      double Val = 0.0;
641      for (int e = 0; e < NDeg; e++) {
642        EId = EIdV[e];
643        if (HONEIdsV[UId].IsKey(EId)) { continue; }
644        if (GetNCom(UId, CId) > 0.0) {
645          PredECMinusUV[CId] =
646            GetECom(EId, CId) / GetNCom(UId, CId); 
647        } else {
648          PredECMinusUV[CId] = 1.0;
649          G->GetEI(EId).GetNodesV(NIdV);
650          for (int m = 0; m < NIdV.Len(); m++) {
651            NId = NIdV[m];
652            if (NId != UId) { PredECMinusUV[CId] *= GetNCom(NId, CId); }
653          }
654        }
655        double PrENoise = GetENoiseProb(G->GetEI(EId).Len());
656        if (GetECom(EId, CId) >= 1.0 || (1.0 - GetECom(EId, CId) <= 0.0)) {
657          double PredENotCId = 1.0 - PrENoise;
658          for (int c2 = 0; c2 < NumComs; c2++) {
659            if (c2 == CId) { continue; }
660            PredENotCId *= 1.0 - GetECom(EId, c2);
661          }
662          Val += PredECMinusUV[CId] * PredENotCId / PredEH.GetDat(EId); 
663        }
664        else {
665          double PrNotENotC = (1.0 - PredEH.GetDat(EId)) / (1.0 - GetECom(EId, CId));
666          Val +=
667            PredECMinusUV[CId] * PrNotENotC / PredEH.GetDat(EId);
668        }
669        Val += NegWgt * (PredECMinusUV[CId] /
670          (1.0 - GetECom(EId, CId)));
671      }
672      Val -= NegWgt * PredictAllCEdgesS(UId, CId, false);
673      CIDV[CId] = CId;
674      GradV[CId] = Val;
675    }
676    for (int c = 0; c < GradV.Len(); c++) {
677      GradNod.AddDat(CIDV[c], GradV[CIDV[c]]);
678    }
679  }
680  void THysgen::GetCmtyVV(TVec<TIntFltH>& CmtyVH, TVec<TIntV>& CmtyVV, TVec<TFltV>& WckVV,
681                          const double Thres, const int MinSz) {
682    CmtyVH.Gen(NumComs, 0.0);
683    CmtyVV.Gen(NumComs, 0.0);
684    for (int CId = 0; CId < NumComs; CId++) {
685      TIntFltH NIDSucH(S.Len());
686      TIntV CmtyV;
687      for (int u = 0; u < S.Len(); u++) {
688        int NID = NIdToIdx[u];
689        if (GetNCom(u, CId) > Thres) {
690          NIDSucH.AddDat(NID, GetNCom(u, CId));
691        }
692      }
693      NIDSucH.SortByDat(false);
694      NIDSucH.GetKeyV(CmtyV);
695      if (CmtyV.Len() < MinSz) { continue; }
696      CmtyVH.Add(NIDSucH);
697      CmtyVV.Add(CmtyV);
698    }
699    if ( NumComs != CmtyVV.Len()) {
700      printf("Unsorted Community vector generated. %d communities are ommitted\n",
701             NumComs.Val - CmtyVV.Len());
702    }
703  }
704  void THysgen::GetCmtyVVUnSorted(TVec<TIntV>& CmtyVV) {
705    GetCmtyVVUnSorted(CmtyVV, sqrt(2.0 * (double) G->GetEdges() / G->GetNodes() / G->GetNodes()), 3);
706  }
707  void THysgen::GetCmtyVVUnSorted(TVec<TIntV>& CmtyVV, const double Thres, const int MinSz) {
708    CmtyVV.Gen(NumComs, 0.0);
709    for (int c = 0; c < NumComs; c++) {
710      TIntV CmtyV;
711      for (int u = 0; u < G->GetNodes(); u++) {
712        if (GetNCom(u, c) > Thres) { CmtyV.Add(NIdToIdx[u]); }
713      }
714      if (CmtyV.Len() >= MinSz) { CmtyVV.Add(CmtyV); }
715    }
716    if ( NumComs != CmtyVV.Len()) {
717      printf("*Sorted* Community vector generated. %d communities are ommitted\n",
718             NumComs.Val - CmtyVV.Len());
719    }
720  }
721  double THysgen::GetStepSizeByLineSearch(const int UID, const TIntFltH &DeltaH,
722                                          const double &stepSize,
723                                          const double &CtrlParam,
724                                          const double &ReductionRatio,
725                                          const int MaxIter) {
726    double StepSize = stepSize;
727    double NewVal;
728    bool ShouldReduce = true;
729    while (ShouldReduce) {
730      ShouldReduce = false;
731      for (TIntFltH::TIter CI = DeltaH.BegI(); CI < DeltaH.EndI(); CI++) {
732        int CID = CI.GetKey();
733        NewVal = GetNCom(UID, CID) + StepSize * CI.GetDat();
734        if ((NewVal < MinVal || NewVal > MaxVal)) {
735          StepSize *= ReductionRatio;
736          ShouldReduce = true;
737          break;
738        }
739      }
740    }
741    double InitLikelihood = LikelihoodForRow(UID);
742    double FinalLikelihood = 0.0;
743    TIntFltH SearchVecH;
744    for(int iter = 0; iter < MaxIter; iter++) {
745      TIntFltH NewVarH;
746      GetUpdatedNodP(NewVarH, SearchVecH, UID, DeltaH, StepSize);
747      FinalLikelihood = LikelihoodForRow(UID, NewVarH);
748      double DotProd = DotProduct(SearchVecH, SearchVecH);
749      if (FinalLikelihood < InitLikelihood + CtrlParam * StepSize * DotProd ||
750                                                      isinf(FinalLikelihood)) {
751        StepSize *= ReductionRatio;
752      } else {
753        break;
754      }
755      if (iter == MaxIter - 1 || DotProd < 0.00001) {
756        StepSize = 0.0;
757        break;
758      }
759    }
760    return StepSize;
761  }
762  int THysgen::MLEGradAscent(const double& Thres, const int& MaxIter, const TStr PlotNm,
763                             const double StepSize, const double StepCtrlParam, const double StepReductionRatio) {
764    int NegLikPermits = MaxIter/3;
765    int MaxIterLineSearch = 100;
766    time_t InitTime = time(NULL);
767    time_t InitIterTime;
768    TExeTm ExeTm, CheckTm;
769    int iter = 0; 
770    TIntFltPrV IterLV; 
771    THGraph::TNodeI UI; 
772    double PrevL = Likelihood(), CurL = 0.0, DiffL;
773    printf("\n0 iterations (iter/#nodes = 0) {[INITIAL] Likelihood: %.4e}\n",PrevL);
774    TIntV NIdxV(S.Len(), 0);  
775    for (int i = 0; i < S.Len(); i++) { NIdxV.Add(i); }
776    TIntFltH GradUH;
777    TFltV Last5;
778    double SumLast5 = 0;
779    while(iter < MaxIter) {
780      InitIterTime = time(NULL);
781      NIdxV.Shuffle(Rnd);
782      for (int ui = 0; ui < S.Len(); ui++, iter++) {
783        int u = NIdxV[ui];
784        GradientForRow(u, GradUH);
785        if (Norm2(GradUH) < 1e-4) { continue; }
786        TIntFltH GradAdjustedH;
787        TIntFltH SearchVecH;
788        NormalizeIfLarge(GradUH, GradAdjustedH);
789        bool IsAnyValidChange = RmvWeakDirections(u, GradAdjustedH);
790        if (! IsAnyValidChange) { continue; }
791        double LearnRate = GetStepSizeByLineSearch(u, GradAdjustedH, StepSize,
792                                                   StepCtrlParam,
793                                                   StepReductionRatio,
794                                                   MaxIterLineSearch);
795        if (LearnRate <= DBL_MIN) { continue; }
796        TIntFltH SNew;
797        GetUpdatedNodP(SNew, u, GradAdjustedH, LearnRate);
798        double NewSuc;
799        for (int CID = 0; CID < NumComs; CID++) {
800          if (! SNew.IsKey(CID)) {
801            NewSuc = 0.0;
802          } else {
803            NewSuc = SNew.GetDat(CID);
804          }
805          if (NewSuc < DBL_EPSILON) {
806            DelNCom(u, CID);
807          } else {
808            AddNCom(u, CID, NewSuc);
809          }
810        }
811        if (! PlotNm.Empty() && (iter + 1) % G->GetNodes() == 0) {
812          IterLV.Add(TIntFltPr(iter, Likelihood()));
813        }
814      }
815      CurL = Likelihood();
816      DiffL = CurL - PrevL;
817      PrevL = CurL;
818      double AdjDiffL = (abs(DiffL) < 1000.0) ? abs(DiffL) : 1000.0;
819      Last5.Add(AdjDiffL);
820      SumLast5 += AdjDiffL;
821      if (Last5.Len() > 5) {
822        SumLast5 -= Last5[0];
823        Last5.Del(0);
824      }
825      if (fabs(CurL) < 1e9) {
826        if (fabs(DiffL) < 1e9) {
827          printf("\r%d iterations (iter/#nodes = %d) {Likelihood: %.4f, Diff: %.4f} [%lu/%lu sec]\n",
828                 iter, iter/G->GetNodes(), CurL, DiffL, time(NULL) - InitIterTime, time(NULL) - InitTime);
829        } else {
830          printf("\r%d iterations (iter/#nodes = %d) {Likelihood: %.4f, Diff: %.4e} [%lu/%lu sec]\n",
831                 iter, iter/G->GetNodes(), CurL, DiffL, time(NULL) - InitIterTime, time(NULL) - InitTime);
832        }
833      } else {
834        if (fabs(DiffL) < 1e9) {
835          printf("\r%d iterations (iter/#nodes = %d) {Likelihood: %.4e, Diff: %.4f} [%lu/%lu sec]\n",
836                 iter, iter/G->GetNodes(), CurL, DiffL, time(NULL) - InitIterTime, time(NULL) - InitTime);
837        } else {
838          printf("\r%d iterations (iter/#nodes = %d) {Likelihood: %.4e, Diff: %.4e} [%lu/%lu sec]\n",
839                 iter, iter/G->GetNodes(), CurL, DiffL, time(NULL) - InitIterTime, time(NULL) - InitTime);
840        }
841      }
842      printf("\n");
843      fflush(stdout);
844      if (DiffL < 0.0) { 
845        if (NegLikPermits <= 0) { break; }
846        NegLikPermits --;
847      }
848      if (SumLast5/Last5.Len() <= Thres) {
849        printf("The average of last five differences < threshold. Iterations end...\n");
850        break;
851      }
852    }
853    printf("\n");
854    printf("MLE for Lambda completed with %d iterations(%s)\n", iter, ExeTm.GetTmStr());
855    if (! PlotNm.Empty()) {
856      TGnuPlot::PlotValV(IterLV, PlotNm + ".likelihood_Q");
857    }
858    return iter;
859  }
860  double THysgen::GetPrE(const int &EId, const int &UId, const TIntFltH &SUNewH,
861                         TIntFltH &PrEOutCH) {
862    double PrENoise = GetENoiseProb(G->GetEI(EId).Len());
863    double SUOld;
864    double SUNew;
865    double PrECOld;
866    double PrENew = 1.0 - PrENoise;
867    int SCId;
868    for (TIntFltH::TIter SCI = SUNewH.BegI(); SCI < SUNewH.EndI(); SCI++) {
869      SCId = SCI.GetKey();
870      SUNew = SCI.GetDat();
871      SUOld = GetNCom(UId, SCId);
872      if (SUOld < DBL_EPSILON) {
873        TIntV ENodesV;
874        G->GetEI(EId).GetNbrNodes(ENodesV);
875        double PrEC = SUNew;
876        for (int n = 0; n < ENodesV.Len(); n++) {
877          if (ENodesV[n] == UId) { continue; }
878          PrEC *= GetNCom(ENodesV[n], SCId);
879        }
880        PrEOutCH.AddDat(SCId, PrEC);
881      } else {
882        PrECOld = GetECom(EId, SCId);
883        PrEOutCH.AddDat(SCId, PrECOld * SUNew / SUOld);
884      }
885      PrENew *= 1.0 - PrEOutCH.GetDat(SCId);
886    }
887    if (PrENew < 1.0) { PrENew = 1.0 - PrENew; }
888    else {
889      PrENew = GetPrEPrecision(PrEOutCH, AuxDPEdgVV, PrENoise);
890    }
891    return PrENew;
892  }
893  double THysgen::GetPrEPrecision(const TIntFltH &ECH, TVec<TFltV> &DPMatVV,
894                                  const double PrENoise) {
895    int NumEC = ECH.Len();
896    TFltV ECV(NumEC);
897    ECH.GetDatV(ECV);
898    if (PrENoise > 0.0) { ECV.Add(PrENoise); NumEC++; }
899    for (int i=1; i<NumEC; i++) {
900      DPMatVV[i][NumEC-1] = 0;
901    }
902    DPMatVV[0][NumEC-1] = ECV[NumEC-1];
903    for (int j= NumEC - 2; j >= 0; j--) {
904      DPMatVV[0][j] = DPMatVV[0][j + 1] + ECV[j];
905    }
906    for (int i=1; i<NumEC; i++) {
907      for (int j=NumEC-1-i; j>=0; j--) {
908        DPMatVV[i][j] = ECV[j] * DPMatVV[i-1][j+1] + DPMatVV[i][j+1];
909      }
910    }
911    double prob = 0.0;
912    double SignCoef = 1.0;
913    for (int i=0; i<NumEC; i++) {
914      prob += SignCoef * DPMatVV[i][0];
915      SignCoef *= -1.0;
916    }
917    if (prob < DBL_MIN || prob >1) {
918      prob = DBL_MIN;
919    }
920    return prob;
921  }
922  void THysgen::GetUpdatedNodP(TIntFltH &SNew, const int &UID, const TIntFltH& GradUH,
923                          double &StepSize) {
924    TIntFltH SearchVecOut;
925    GetUpdatedNodP(SNew, SearchVecOut, UID, GradUH, StepSize);
926  }
927  void THysgen::GetUpdatedNodP(TIntFltH &SNew, TIntFltH& SearchVecOut, const int& UID,
928                               const TIntFltH& GradUH, double& StepSize) {
929    for (int CID = 0; CID < NumComs; CID++) {
930      if (GradUH.IsKey(CID)) {
931        double Change = StepSize * GradUH.GetDat(CID);
932        if (RegCoef>0.0 && GetNCom(UID, CID)>0.0) {
933          Change -= - RegCoef;
934        }
935        double NewSuc = GetNCom(UID, CID) + Change;
936        if (NewSuc < DBL_EPSILON) {
937          NewSuc = MinVal;
938        } else if (NewSuc >= MaxVal - TayThresh) {
939          NewSuc = MaxVal - TayThresh;
940        }
941        Change = NewSuc - GetNCom(UID, CID);
942        if (NewSuc >= DBL_EPSILON) {
943          SNew.AddDat(CID, NewSuc);
944        }
945        SearchVecOut.AddDat(CID, Change);
946      } else {
947        if (GetNCom(UID, CID) > 0.0) {
948          double NewSuc;
949          if (GetNCom(UID, CID) >= MaxVal - TayThresh) {
950            NewSuc = MaxVal - TayThresh;
951          } else {
952            NewSuc = GetNCom(UID, CID);
953          }
954          SNew.AddDat(CID, NewSuc);
955        }
956      }
957    }
958  }
959  bool THysgen::AcceptStepSA(const int &UID, const TIntFltH &SNew, const int &Iter,
960                        const int &MaxIter, const double &SAParamK) {
961    double T0 = 100.0;
962    double T = T0/((double)Iter+1.0);
963    double OldLikelihood = LikelihoodForRow(UID);
964    double NewLikelihood = LikelihoodForRow(UID, SNew);
965    double DeltaE = - (NewLikelihood-OldLikelihood);
966    double PrAccept = exp(-DeltaE/(SAParamK*T));
967    if (Rnd.GetUniDev() < PrAccept) { return true; }
968    return false;
969  }
970  bool THysgen::RmvWeakDirections(const int &UId, TIntFltH &GradH) {
971    bool IsEligible = false;
972    THashSet<TInt> BadDirH;
973    for (TIntFltH::TIter CI = GradH.BegI(); CI < GradH.EndI(); CI++) {
974      if ((GetNCom(UId, CI.GetKey()) < DBL_EPSILON && CI.GetDat() < DBL_EPSILON) ||
975            (1.0 - GetNCom(UId, CI.GetKey()) < DBL_EPSILON && CI.GetDat() > DBL_EPSILON)) {
976        BadDirH.AddKey(CI.GetKey());
977      } else {
978        IsEligible = true;
979      }
980    }
981    if (BadDirH.Len() > 0) {
982      for (THashSet<TInt>::TIter CId = BadDirH.BegI();
983           CId < BadDirH.EndI(); CId++) {
984        GradH.DelKey(CId.GetKey());
985      }
986    }
987    return IsEligible;
988  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-linalg.cpp</h3>
            <pre><code>1  void TSparseColMatrix::PMultiply(const TFltVV& B, int ColId, TFltV& Result) const {
2      Assert(B.GetRows() >= ColN && Result.Len() >= RowN);
3      int i, j; TFlt *ResV = Result.BegI();
4      for (i = 0; i < RowN; i++) ResV[i] = 0.0;
5      for (j = 0; j < ColN; j++) {
6          const TIntFltKdV& ColV = ColSpVV[j]; int len = ColV.Len();
7          for (i = 0; i < len; i++) {
8              ResV[ColV[i].Key] += ColV[i].Dat * B(j,ColId);
9          }
10      }
11  }
12  void TSparseColMatrix::PMultiply(const TFltV& Vec, TFltV& Result) const {
13      Assert(Vec.Len() >= ColN && Result.Len() >= RowN);
14      int i, j; TFlt *ResV = Result.BegI();
15      for (i = 0; i < RowN; i++) ResV[i] = 0.0;
16      for (j = 0; j < ColN; j++) {
17          const TIntFltKdV& ColV = ColSpVV[j]; int len = ColV.Len();
18          for (i = 0; i < len; i++) {
19              ResV[ColV[i].Key] += ColV[i].Dat * Vec[j];
20          }
21      }
22  }
23  void TSparseColMatrix::PMultiplyT(const TFltVV& B, int ColId, TFltV& Result) const {
24      Assert(B.GetRows() >= RowN && Result.Len() >= ColN);
25      int i, j, len; TFlt *ResV = Result.BegI();
26      for (j = 0; j < ColN; j++) {
27          const TIntFltKdV& ColV = ColSpVV[j];
28          len = ColV.Len(); ResV[j] = 0.0;
29          for (i = 0; i < len; i++) {
30              ResV[j] += ColV[i].Dat * B(ColV[i].Key, ColId);
31          }
32      }
33  }
34  void TSparseColMatrix::PMultiplyT(const TFltV& Vec, TFltV& Result) const {
35      Assert(Vec.Len() >= RowN && Result.Len() >= ColN);
36      int i, j, len; TFlt *VecV = Vec.BegI(), *ResV = Result.BegI();
37      for (j = 0; j < ColN; j++) {
38          const TIntFltKdV& ColV = ColSpVV[j];
39          len = ColV.Len(); ResV[j] = 0.0;
40          for (i = 0; i < len; i++) {
41              ResV[j] += ColV[i].Dat * VecV[ColV[i].Key];
42          }
43      }
44  }
45  TSparseRowMatrix::TSparseRowMatrix(const TStr& MatlabMatrixFNm) {
46     FILE *F = fopen(MatlabMatrixFNm.CStr(), "rt");  IAssert(F != NULL);
47     TVec<TTriple<TInt, TInt, TSFlt> > MtxV;
48     RowN = 0;  ColN = 0;
49     while (! feof(F)) {
50       int row=-1, col=-1; float val;
51       if (fscanf(F, "%d %d %f\n", &row, &col, &val) == 3) {
52         IAssert(row > 0 && col > 0);
53         MtxV.Add(TTriple<TInt, TInt, TSFlt>(row, col, val));
54         RowN = TMath::Mx(RowN, row);
55         ColN = TMath::Mx(ColN, col);
56       }
57     }
58     fclose(F);
59     MtxV.Sort();
60     RowSpVV.Gen(RowN);
61     int cnt = 0;
62     for (int row = 1; row <= RowN; row++) {
63       while (cnt < MtxV.Len() && MtxV[cnt].Val1 == row) {
64         RowSpVV[row-1].Add(TIntFltKd(MtxV[cnt].Val2-1, MtxV[cnt].Val3()));
65         cnt++;
66       }
67     }
68  }
69  void TSparseRowMatrix::PMultiplyT(const TFltVV& B, int ColId, TFltV& Result) const {
70      Assert(B.GetRows() >= RowN && Result.Len() >= ColN);
71      for (int i = 0; i < ColN; i++) Result[i] = 0.0;
72      for (int j = 0; j < RowN; j++) {
73          const TIntFltKdV& RowV = RowSpVV[j]; int len = RowV.Len();
74          for (int i = 0; i < len; i++) {
75              Result[RowV[i].Key] += RowV[i].Dat * B(j,ColId);
76          }
77      }
78  }
79  void TSparseRowMatrix::PMultiplyT(const TFltV& Vec, TFltV& Result) const {
80      Assert(Vec.Len() >= RowN && Result.Len() >= ColN);
81      for (int i = 0; i < ColN; i++) Result[i] = 0.0;
82      for (int j = 0; j < RowN; j++) {
83          const TIntFltKdV& RowV = RowSpVV[j]; int len = RowV.Len();
84          for (int i = 0; i < len; i++) {
85              Result[RowV[i].Key] += RowV[i].Dat * Vec[j];
86          }
87      }
88  }
89  void TSparseRowMatrix::PMultiply(const TFltVV& B, int ColId, TFltV& Result) const {
90      Assert(B.GetRows() >= ColN && Result.Len() >= RowN);
91      for (int j = 0; j < RowN; j++) {
92          const TIntFltKdV& RowV = RowSpVV[j];
93          int len = RowV.Len(); Result[j] = 0.0;
94          for (int i = 0; i < len; i++) {
95              Result[j] += RowV[i].Dat * B(RowV[i].Key, ColId);
96          }
97      }
98  }
99  void TSparseRowMatrix::PMultiply(const TFltV& Vec, TFltV& Result) const {
100      Assert(Vec.Len() >= ColN && Result.Len() >= RowN);
101      for (int j = 0; j < RowN; j++) {
102          const TIntFltKdV& RowV = RowSpVV[j];
103          int len = RowV.Len(); Result[j] = 0.0;
104          for (int i = 0; i < len; i++) {
105              Result[j] += RowV[i].Dat * Vec[RowV[i].Key];
106          }
107      }
108  }
109  TFullColMatrix::TFullColMatrix(const TStr& MatlabMatrixFNm): TMatrix() {
110      TLAMisc::LoadMatlabTFltVV(MatlabMatrixFNm, ColV);
111      RowN=ColV[0].Len(); ColN=ColV.Len();
112      for (int i = 0; i < ColN; i++) {
113          IAssertR(ColV[i].Len() == RowN, TStr::Fmt("%d != %d", ColV[i].Len(), RowN));
114      }
115  }
116  void TFullColMatrix::PMultiplyT(const TFltVV& B, int ColId, TFltV& Result) const {
117      Assert(B.GetRows() >= RowN && Result.Len() >= ColN);
118      for (int i = 0; i < ColN; i++) {
119          Result[i] = TLinAlg::DotProduct(B, ColId, ColV[i]);
120      }
121  }
122  void TFullColMatrix::PMultiplyT(const TFltV& Vec, TFltV& Result) const {
123      Assert(Vec.Len() >= RowN && Result.Len() >= ColN);
124      for (int i = 0; i < ColN; i++) {
125          Result[i] = TLinAlg::DotProduct(Vec, ColV[i]);
126      }
127  }
128  void TFullColMatrix::PMultiply(const TFltVV& B, int ColId, TFltV& Result) const {
129      Assert(B.GetRows() >= ColN && Result.Len() >= RowN);
130      for (int i = 0; i < RowN; i++) { Result[i] = 0.0; }
131      for (int i = 0; i < ColN; i++) {
132          TLinAlg::AddVec(B(i, ColId), ColV[i], Result, Result);
133      }
134  }
135  void TFullColMatrix::PMultiply(const TFltV& Vec, TFltV& Result) const {
136      Assert(Vec.Len() >= ColN && Result.Len() >= RowN);
137      for (int i = 0; i < RowN; i++) { Result[i] = 0.0; }
138      for (int i = 0; i < ColN; i++) {
139          TLinAlg::AddVec(Vec[i], ColV[i], Result, Result);
140      }
141  }
142  double TLinAlg::DotProduct(const TFltV& x, const TFltV& y) {
143      IAssertR(x.Len() == y.Len(), TStr::Fmt("%d != %d", x.Len(), y.Len()));
144      double result = 0.0; int Len = x.Len();
145      for (int i = 0; i < Len; i++)
146          result += x[i] * y[i];
147      return result;
148  }
149  double TLinAlg::DotProduct(const TFltVV& X, int ColIdX, const TFltVV& Y, int ColIdY) {
150      Assert(X.GetRows() == Y.GetRows());
151      double result = 0.0, len = X.GetRows();
152      for (int i = 0; i < len; i++)
153          result = result + X(i,ColIdX) * Y(i,ColIdY);
154      return result;
155  }
156  double TLinAlg::DotProduct(const TFltVV& X, int ColId, const TFltV& Vec) {
157      Assert(X.GetRows() == Vec.Len());
158      double result = 0.0; int Len = X.GetRows();
159      for (int i = 0; i < Len; i++)
160          result += X(i,ColId) * Vec[i];
161      return result;
162  }
163  double TLinAlg::DotProduct(const TIntFltKdV& x, const TIntFltKdV& y) {
164      const int xLen = x.Len(), yLen = y.Len();
165      double Res = 0.0; int i1 = 0, i2 = 0;
166      while (i1 < xLen && i2 < yLen) {
167          if (x[i1].Key < y[i2].Key) i1++;
168          else if (x[i1].Key > y[i2].Key) i2++;
169          else { Res += x[i1].Dat * y[i2].Dat;  i1++;  i2++; }
170      }
171      return Res;
172  }
173  double TLinAlg::DotProduct(const TFltV& x, const TIntFltKdV& y) {
174      double Res = 0.0; const int xLen = x.Len(), yLen = y.Len();
175      for (int i = 0; i < yLen; i++) {
176          const int key = y[i].Key;
177          if (key < xLen) Res += y[i].Dat * x[key];
178      }
179      return Res;
180  }
181  double TLinAlg::DotProduct(const TFltVV& X, int ColId, const TIntFltKdV& y) {
182      double Res = 0.0; const int n = X.GetRows(), yLen = y.Len();
183      for (int i = 0; i < yLen; i++) {
184          const int key = y[i].Key;
185          if (key < n) Res += y[i].Dat * X(key,ColId);
186      }
187      return Res;
188  }
189  void TLinAlg::LinComb(const double& p, const TFltV& x,
190          const double& q, const TFltV& y, TFltV& z) {
191      Assert(x.Len() == y.Len() && y.Len() == z.Len());
192      const int Len = x.Len();
193      for (int i = 0; i < Len; i++) {
194          z[i] = p * x[i] + q * y[i]; }
195  }
196  void TLinAlg::ConvexComb(const double& p, const TFltV& x, const TFltV& y, TFltV& z) {
197      AssertR(0.0 <= p && p <= 1.0, TFlt::GetStr(p));
198      LinComb(p, x, 1.0 - p, y, z);
199  }
200  void TLinAlg::AddVec(const double& k, const TFltV& x, const TFltV& y, TFltV& z) {
201      LinComb(k, x, 1.0, y, z);
202  }
203  void TLinAlg::AddVec(const double& k, const TIntFltKdV& x, const TFltV& y, TFltV& z) {
204      Assert(y.Len() == z.Len());
205      z = y; 
206      const int xLen = x.Len(), yLen = y.Len();
207      for (int i = 0; i < xLen; i++) {
208          const int ii = x[i].Key;
209          if (ii < yLen) {
210              z[ii] = k * x[i].Dat + y[ii];
211          }
212      }
213  }
214  void TLinAlg::AddVec(const double& k, const TIntFltKdV& x, TFltV& y) {
215      const int xLen = x.Len(), yLen = y.Len();
216      for (int i = 0; i < xLen; i++) {
217          const int ii = x[i].Key;
218          if (ii < yLen) {
219              y[ii] += k * x[i].Dat;
220          }
221      }
222  }
223  void TLinAlg::AddVec(double k, const TFltVV& X, int ColIdX, TFltVV& Y, int ColIdY){
224      Assert(X.GetRows() == Y.GetRows());
225      const int len = Y.GetRows();
226      for (int i = 0; i < len; i++) {
227          Y(i,ColIdY) = Y(i,ColIdY) + k * X(i, ColIdX);
228      }
229  }
230  void TLinAlg::AddVec(double k, const TFltVV& X, int ColId, TFltV& Result){
231      Assert(X.GetRows() == Result.Len());
232      const int len = Result.Len();
233      for (int i = 0; i < len; i++) {
234          Result[i] = Result[i] + k * X(i, ColId);
235      }
236  }
237  void TLinAlg::AddVec(const TIntFltKdV& x, const TIntFltKdV& y, TIntFltKdV& z) {
238  	TSparseOpsIntFlt::SparseMerge(x, y, z);
239  }
240  double TLinAlg::SumVec(const TFltV& x) {
241      const int len = x.Len();
242      double Res = 0.0;
243      for (int i = 0; i < len; i++) {
244          Res += x[i];
245      }
246      return Res;
247  }
248  double TLinAlg::SumVec(double k, const TFltV& x, const TFltV& y) {
249      Assert(x.Len() == y.Len());
250      const int len = x.Len();
251      double Res = 0.0;
252      for (int i = 0; i < len; i++) {
253          Res += k * x[i] + y[i];
254      }
255      return Res;
256  }
257  double TLinAlg::EuclDist2(const TFltV& x, const TFltV& y) {
258      Assert(x.Len() == y.Len());
259      const int len = x.Len();
260      double Res = 0.0;
261      for (int i = 0; i < len; i++) {
262          Res += TMath::Sqr(x[i] - y[i]);
263      }
264      return Res;
265  }
266  double TLinAlg::EuclDist2(const TFltPr& x, const TFltPr& y) {
267      return TMath::Sqr(x.Val1 - y.Val1) + TMath::Sqr(x.Val2 - y.Val2);
268  }
269  double TLinAlg::EuclDist(const TFltV& x, const TFltV& y) {
270      return sqrt(EuclDist2(x, y));
271  }
272  double TLinAlg::EuclDist(const TFltPr& x, const TFltPr& y) {
273      return sqrt(EuclDist2(x, y));
274  }
275  double TLinAlg::Norm2(const TFltV& x) {
276      return DotProduct(x, x);
277  }
278  double TLinAlg::Norm(const TFltV& x) {
279      return sqrt(Norm2(x));
280  }
281  void TLinAlg::Normalize(TFltV& x) {
282      const double xNorm = Norm(x);
283      if (xNorm > 0.0) { MultiplyScalar(1/xNorm, x, x); }
284  }
285  double TLinAlg::Norm2(const TIntFltKdV& x) {
286      double Result = 0;
287      for (int i = 0; i < x.Len(); i++) {
288          Result += TMath::Sqr(x[i].Dat);
289      }
290      return Result;
291  }
292  double TLinAlg::Norm(const TIntFltKdV& x) {
293      return sqrt(Norm2(x));
294  }
295  void TLinAlg::Normalize(TIntFltKdV& x) {
296      MultiplyScalar(1/Norm(x), x, x);
297  }
298  double TLinAlg::Norm2(const TFltVV& X, int ColId) {
299      return DotProduct(X, ColId, X, ColId);
300  }
301  double TLinAlg::Norm(const TFltVV& X, int ColId) {
302      return sqrt(Norm2(X, ColId));
303  }
304  double TLinAlg::NormL1(const TFltV& x) {
305      double norm = 0.0; const int Len = x.Len();
306      for (int i = 0; i < Len; i++)
307          norm += TFlt::Abs(x[i]);
308      return norm;
309  }
310  double TLinAlg::NormL1(double k, const TFltV& x, const TFltV& y) {
311      Assert(x.Len() == y.Len());
312      double norm = 0.0; const int len = x.Len();
313      for (int i = 0; i < len; i++) {
314          norm += TFlt::Abs(k * x[i] + y[i]);
315      }
316      return norm;
317  }
318  double TLinAlg::NormL1(const TIntFltKdV& x) {
319      double norm = 0.0; const int Len = x.Len();
320      for (int i = 0; i < Len; i++)
321          norm += TFlt::Abs(x[i].Dat);
322      return norm;
323  }
324  void TLinAlg::NormalizeL1(TFltV& x) {
325      const double xNorm = NormL1(x);
326      if (xNorm > 0.0) { MultiplyScalar(1/xNorm, x, x); }
327  }
328  void TLinAlg::NormalizeL1(TIntFltKdV& x) {
329      const double xNorm = NormL1(x);
330      if (xNorm > 0.0) { MultiplyScalar(1/xNorm, x, x); }
331  }
332  double TLinAlg::NormLinf(const TFltV& x) {
333      double norm = 0.0; const int Len = x.Len();
334      for (int i = 0; i < Len; i++)
335          norm = TFlt::GetMx(TFlt::Abs(x[i]), norm);
336      return norm;
337  }
338  double TLinAlg::NormLinf(const TIntFltKdV& x) {
339      double norm = 0.0; const int Len = x.Len();
340      for (int i = 0; i < Len; i++)
341          norm = TFlt::GetMx(TFlt::Abs(x[i].Dat), norm);
342      return norm;
343  }
344  void TLinAlg::NormalizeLinf(TFltV& x) {
345      const double xNormLinf = NormLinf(x);
346      if (xNormLinf > 0.0) { MultiplyScalar(1.0/xNormLinf, x, x); }
347  }
348  void TLinAlg::NormalizeLinf(TIntFltKdV& x) {
349      const double xNormLInf = NormLinf(x);
350      if (xNormLInf> 0.0) { MultiplyScalar(1.0/xNormLInf, x, x); }
351  }
352  void TLinAlg::MultiplyScalar(const double& k, const TFltV& x, TFltV& y) {
353      Assert(x.Len() == y.Len());
354      int Len = x.Len();
355      for (int i = 0; i < Len; i++)
356          y[i] = k * x[i];
357  }
358  void TLinAlg::MultiplyScalar(const double& k, const TIntFltKdV& x, TIntFltKdV& y) {
359      Assert(x.Len() == y.Len());
360      int Len = x.Len();
361      for (int i = 0; i < Len; i++)
362          y[i].Dat = k * x[i].Dat;
363  }
364  void TLinAlg::Multiply(const TFltVV& A, const TFltV& x, TFltV& y) {
365      Assert(A.GetCols() == x.Len() && A.GetRows() == y.Len());
366      int n = A.GetRows(), m = A.GetCols();
367      for (int i = 0; i < n; i++) {
368          y[i] = 0.0;
369          for (int j = 0; j < m; j++)
370              y[i] += A(i,j) * x[j];
371      }
372  }
373  void TLinAlg::Multiply(const TFltVV& A, const TFltV& x, TFltVV& C, int ColId) {
374      Assert(A.GetCols() == x.Len() && A.GetRows() == C.GetRows());
375      int n = A.GetRows(), m = A.GetCols();
376      for (int i = 0; i < n; i++) {
377          C(i,ColId) = 0.0;
378          for (int j = 0; j < m; j++)
379              C(i,ColId) += A(i,j) * x[j];
380      }
381  }
382  void TLinAlg::Multiply(const TFltVV& A, const TFltVV& B, int ColId, TFltV& y) {
383      Assert(A.GetCols() == B.GetRows() && A.GetRows() == y.Len());
384      int n = A.GetRows(), m = A.GetCols();
385      for (int i = 0; i < n; i++) {
386          y[i] = 0.0;
387          for (int j = 0; j < m; j++)
388              y[i] += A(i,j) * B(j,ColId);
389      }
390  }
391  void TLinAlg::Multiply(const TFltVV& A, const TFltVV& B, int ColIdB, TFltVV& C, int ColIdC){
392      Assert(A.GetCols() == B.GetRows() && A.GetRows() == C.GetRows());
393      int n = A.GetRows(), m = A.GetCols();
394      for (int i = 0; i < n; i++) {
395          C(i,ColIdC) = 0.0;
396          for (int j = 0; j < m; j++)
397              C(i,ColIdC) += A(i,j) * B(j,ColIdB);
398      }
399  }
400  void TLinAlg::MultiplyT(const TFltVV& A, const TFltV& x, TFltV& y) {
401      Assert(A.GetRows() == x.Len() && A.GetCols() == y.Len());
402      int n = A.GetCols(), m = A.GetRows();
403      for (int i = 0; i < n; i++) {
404          y[i] = 0.0;
405          for (int j = 0; j < m; j++)
406              y[i] += A(j,i) * x[j];
407      }
408  }
409  void TLinAlg::Multiply(const TFltVV& A, const TFltVV& B, TFltVV& C) {
410      Assert(A.GetRows() == C.GetRows() && B.GetCols() == C.GetCols() && A.GetCols() == B.GetRows());
411      int n = C.GetRows(), m = C.GetCols(), l = A.GetCols();
412      for (int i = 0; i < n; i++) {
413          for (int j = 0; j < m; j++) {
414              double sum = 0.0;
415              for (int k = 0; k < l; k++)
416                  sum += A(i,k)*B(k,j);
417              C(i,j) = sum;
418          }
419      }
420  }
421  void TLinAlg::Gemm(const double& Alpha, const TFltVV& A, const TFltVV& B, const double& Beta, 
422  		const TFltVV& C, TFltVV& D, const int& TransposeFlags) {
423  	bool tA = (TransposeFlags & GEMM_A_T) == GEMM_A_T;
424  	bool tB = (TransposeFlags & GEMM_B_T) == GEMM_B_T;
425  	bool tC = (TransposeFlags & GEMM_C_T) == GEMM_C_T;
426  	int a_i = tA ? A.GetRows() : A.GetCols();
427  	int a_j = tA ? A.GetCols() : A.GetRows();
428  	int b_i = tB ? A.GetRows() : A.GetCols();
429  	int b_j = tB ? A.GetCols() : A.GetRows();
430  	int c_i = tC ? A.GetRows() : A.GetCols();
431  	int c_j = tC ? A.GetCols() : A.GetRows();
432  	int d_i = D.GetCols();
433  	int d_j = D.GetRows();
434    bool Cnd = a_i == c_j && b_i == c_i && a_i == b_j && c_i == d_i && c_j == d_j;
435    if (!Cnd) {
436  	  Assert(Cnd);
437    }
438  	double Aij, Bij, Cij;
439  	for (int j = 0; j < a_j; j++) {
440  		for (int i = 0; i < a_i; i++) {
441  			double sum = 0;
442  			for (int k = 0; k < a_i; k++) {
443  				Aij = tA ? A.At(j, k) : A.At(k, j);
444  				Bij = tB ? B.At(k, i) : B.At(i, k);
445  				sum += Alpha * Aij * Bij;
446  			}
447  			Cij = tC ? C.At(i, j) : C.At(j, i);
448  			sum += Beta * Cij;
449  			D.At(i, j) = sum;
450  		}
451  	}
452  }
453  void TLinAlg::Transpose(const TFltVV& A, TFltVV& B) {
454  	Assert(B.GetRows() == A.GetCols() && B.GetCols() == A.GetRows());
455  	for (int i = 0; i < A.GetCols(); i++) {
456  		for (int j = 0; j < A.GetRows(); j++) {
457  			B.At(i, j) = A.At(j, i);
458  		}
459  	}
460  }
461  void TLinAlg::Inverse(const TFltVV& A, TFltVV& B, const TLinAlgInverseType& DecompType) {
462  	switch (DecompType) {
463  		case DECOMP_SVD:
464  			InverseSVD(A, B);
465  	}
466  }
467  void TLinAlg::InverseSVD(const TFltVV& M, TFltVV& B) {
468  	TFltVV U, V;
469  	TFltV E;
470  	TSvd SVD;
471  	U.Gen(M.GetRows(), M.GetRows());	
472  	V.Gen(M.GetCols(), M.GetCols());
473  	SVD.Svd(M, U, E, V);
474  	for (int i = 0; i < E.Len(); i++) {
475  		E[i] = 1 / E[i];
476  	}
477  	for (int i = 0; i < U.GetCols(); i++) {
478  		for (int j = 0; j < V.GetRows(); j++) {
479  			double sum = 0;
480  			for (int k = 0; k < U.GetCols(); k++) {
481  				sum += E[k] * V.At(i, k) * U.At(j, k);
482  			}
483  			B.At(i, j) = sum;
484  		}
485  	}	
486  }
487  void TLinAlg::GS(TVec<TFltV>& Q) {
488      IAssert(Q.Len() > 0);
489      int m = Q.Len(); 
490      for (int i = 0; i < m; i++) {
491          printf("%d\r",i);
492          for (int j = 0; j < i; j++) {
493              double r = TLinAlg::DotProduct(Q[i], Q[j]);
494              TLinAlg::AddVec(-r,Q[j],Q[i],Q[i]);
495          }
496          TLinAlg::Normalize(Q[i]);
497      }
498      printf("\n");
499  }
500  void TLinAlg::GS(TFltVV& Q) {
501      int m = Q.GetCols(), n = Q.GetRows();
502      for (int i = 0; i < m; i++) {
503          for (int j = 0; j < i; j++) {
504              double r = TLinAlg::DotProduct(Q, i, Q, j);
505              TLinAlg::AddVec(-r,Q,j,Q,i);
506          }
507          double nr = TLinAlg::Norm(Q,i);
508          for (int k = 0; k < n; k++)
509              Q(k,i) = Q(k,i) / nr;
510      }
511  }
512  void TLinAlg::Rotate(const double& OldX, const double& OldY, const double& Angle, double& NewX, double& NewY) {
513      NewX = OldX*cos(Angle) - OldY*sin(Angle);
514      NewY = OldX*sin(Angle) + OldY*cos(Angle);
515  }
516  void TLinAlg::AssertOrtogonality(const TVec<TFltV>& Vecs, const double& Threshold) {
517      int m = Vecs.Len();
518      for (int i = 0; i < m; i++) {
519          for (int j = 0; j < i; j++) {
520              double res = DotProduct(Vecs[i], Vecs[j]);
521              if (TFlt::Abs(res) > Threshold)
522                  printf("<%d,%d> = %.5f", i,j,res);
523          }
524          double norm = Norm2(Vecs[i]);
525          if (TFlt::Abs(norm-1) > Threshold)
526              printf("||%d|| = %.5f", i, norm);
527      }
528  }
529  void TLinAlg::AssertOrtogonality(const TFltVV& Vecs, const double& Threshold) {
530      int m = Vecs.GetCols();
531      for (int i = 0; i < m; i++) {
532          for (int j = 0; j < i; j++) {
533              double res = DotProduct(Vecs, i, Vecs, j);
534              if (TFlt::Abs(res) > Threshold)
535                  printf("<%d,%d> = %.5f", i, j, res);
536          }
537          double norm = Norm2(Vecs, i);
538          if (TFlt::Abs(norm-1) > Threshold)
539              printf("||%d|| = %.5f", i, norm);
540      }
541      printf("\n");
542  }
543  double TNumericalStuff::sqr(double a) {
544    return a == 0.0 ? 0.0 : a*a;
545  }
546  double TNumericalStuff::sign(double a, double b) {
547    return b >= 0.0 ? fabs(a) : -fabs(a);
548  }
549  void TNumericalStuff::nrerror(const TStr& error_text) {
550      printf("NR_ERROR: %s", error_text.CStr());
551      throw new TNSException(error_text);
552  }
553  double TNumericalStuff::pythag(double a, double b) {
554      double absa = fabs(a), absb = fabs(b);
555      if (absa > absb)
556          return absa*sqrt(1.0+sqr(absb/absa));
557      else
558          return (absb == 0.0 ? 0.0 : absb*sqrt(1.0+sqr(absa/absb)));
559  }
560  void TNumericalStuff::SymetricToTridiag(TFltVV& a, int n, TFltV& d, TFltV& e) {
561      int l,k,j,i;
562      double scale,hh,h,g,f;
563      for (i=n;i>=2;i--) {
564          l=i-1;
565          h=scale=0.0;
566          if (l > 1) {
567              for (k=1;k<=l;k++)
568                  scale += fabs(a(i-1,k-1).Val);
569              if (scale == 0.0) 
570                  e[i]=a(i-1,l-1);
571              else {
572                  for (k=1;k<=l;k++) {
573                      a(i-1,k-1) /= scale; 
574                      h += a(i-1,k-1)*a(i-1,k-1);
575                  }
576                  f=a(i-1,l-1);
577                  g=(f >= 0.0 ? -sqrt(h) : sqrt(h));
578                  IAssertR(_isnan(g) == 0, TFlt::GetStr(h));
579                  e[i]=scale*g;
580                  h -= f*g; 
581                  a(i-1,l-1)=f-g; 
582                  f=0.0;
583                  for (j=1;j<=l;j++) {
584                      a(j-1,i-1)=a(i-1,j-1)/h; 
585                      g=0.0; 
586                      for (k=1;k<=j;k++)
587                          g += a(j-1,k-1)*a(i-1,k-1);
588                      for (k=j+1;k<=l;k++)
589                          g += a(k-1,j-1)*a(i-1,k-1);
590                      e[j]=g/h; 
591                      f += e[j]*a(i-1,j-1);
592                  }
593                  hh=f/(h+h); 
594                  for (j=1;j<=l;j++) { 
595                      f=a(i-1,j-1);
596                      e[j]=g=e[j]-hh*f;
597                      for (k=1;k<=j;k++) { 
598                          a(j-1,k-1) -= (f*e[k]+g*a(i-1,k-1));
599                          Assert(_isnan(static_cast<double>(a(j-1,k-1))) == 0);
600                      }
601                  }
602              }
603          } else
604              e[i]=a(i-1,l-1);
605          d[i]=h;
606      }
607      d[1]=0.0;
608      e[1]=0.0;
609      for (i=1;i<=n;i++) { 
610          l=i-1;
611          if (d[i]) { 
612              for (j=1;j<=l;j++) {
613                  g=0.0;
614                  for (k=1;k<=l;k++) 
615                      g += a(i-1,k-1)*a(k-1,j-1);
616                  for (k=1;k<=l;k++) {
617                      a(k-1,j-1) -= g*a(k-1,i-1);
618                      Assert(_isnan(static_cast<double>(a(k-1,j-1))) == 0);
619                  }
620              }
621          }
622          d[i]=a(i-1,i-1); 
623          a(i-1,i-1)=1.0; 
624          for (j=1;j<=l;j++) a(j-1,i-1)=a(i-1,j-1)=0.0;
625      }
626  }
627  void TNumericalStuff::EigSymmetricTridiag(TFltV& d, TFltV& e, int n, TFltVV& z) {
628      int m,l,iter,i,k; 
629      double s,r,p,g,f,dd,c,b;
630      for (i=2;i<=n;i++) e[i-1]=e[i];
631      e[n]=0.0;
632      for (l=1;l<=n;l++) {
633          iter=0;
634          do {
635              for (m=l;m<=n-1;m++) {
636          dd=TFlt::Abs(d[m])+TFlt::Abs(d[m+1]);
637                  if ((double)(TFlt::Abs(e[m])+dd) == dd) break;
638              }
639              if (m != l) {
640                  if (iter++ == 60) nrerror("Too many iterations in EigSymmetricTridiag");
641                  g=(d[l+1]-d[l])/(2.0*e[l]);
642                  r=pythag(g,1.0);
643                  g=d[m]-d[l]+e[l]/(g+sign(r,g));
644                  s=c=1.0;
645                  p=0.0;
646                  for (i=m-1;i>=l;i--) {
647                      f=s*e[i];
648                      b=c*e[i];
649                      e[i+1]=(r=pythag(f,g));
650                      if (r == 0.0) {
651                          d[i+1] -= p;
652                          e[m]=0.0;
653                          break;
654                      }
655                      s=f/r;
656                      c=g/r;
657                      g=d[i+1]-p;
658                      r=(d[i]-g)*s+2.0*c*b;
659                      d[i+1]=g+(p=s*r);
660                      g=c*r-b;
661                      for (k=0;k<n;k++) {
662                          f=z(k,i);
663                          z(k,i)=s*z(k,i-1)+c*f;
664                          z(k,i-1)=c*z(k,i-1)-s*f;
665                      }
666                  }
667                  if (r == 0.0 && i >= l) continue;
668                  d[l] -= p;
669                  e[l]=g;
670                  e[m]=0.0;
671              }
672          } while (m != l);
673      }
674  }
675  void TNumericalStuff::CholeskyDecomposition(TFltVV& A, TFltV& p) {
676    Assert(A.GetRows() == A.GetCols());
677    int n = A.GetRows(); p.Reserve(n,n);
678    int i,j,k;
679    double sum;
680    for (i=1;i<=n;i++) {
681      for (j=i;j<=n;j++) {
682        for (sum=A(i-1,j-1),k=i-1;k>=1;k--) sum -= A(i-1,k-1)*A(j-1,k-1);
683        if (i == j) {
684          if (sum <= 0.0)
685            nrerror("choldc failed");
686          p[i-1]=sqrt(sum);
687        } else A(j-1,i-1)=sum/p[i-1];
688      }
689    }
690  }
691  void TNumericalStuff::CholeskySolve(const TFltVV& A, const TFltV& p, const TFltV& b, TFltV& x) {
692    IAssert(A.GetRows() == A.GetCols());
693    int n = A.GetRows(); x.Reserve(n,n);
694    int i,k;
695    double sum;
696    for (i=1;i<=n;i++) {
697      for (sum=b[i-1],k=i-1;k>=1;k--)
698        sum -= A(i-1,k-1)*x[k-1];
699      x[i-1]=sum/p[i-1];
700    }
701    for (i=n;i>=1;i--) {
702      for (sum=x[i-1],k=i+1;k<=n;k++)
703        sum -= A(k-1,i-1)*x[k-1];
704      x[i-1]=sum/p[i-1];
705    }
706  }
707  void TNumericalStuff::SolveSymetricSystem(TFltVV& A, const TFltV& b, TFltV& x) {
708    IAssert(A.GetRows() == A.GetCols());
709    TFltV p; CholeskyDecomposition(A, p);
710    CholeskySolve(A, p, b, x);
711  }
712  void TNumericalStuff::InverseSubstitute(TFltVV& A, const TFltV& p) {
713    IAssert(A.GetRows() == A.GetCols());
714    int n = A.GetRows(); TFltV x(n);
715      int i, j, k; double sum;
716      for (i = 0; i < n; i++) {
717          for (j = 0; j < i; j++) x[j] = 0.0;
718          x[i] = 1/p[i];
719          for (j = i+1; j < n; j++) {
720              for (sum = 0.0, k = i; k < j; k++)
721                  sum -= A(j,k) * x[k];
722              x[j] = sum / p[j];
723          }
724          for (j = n-1; j >= i; j--) {
725              for (sum = x[j], k = j+1; k < n; k++)
726                  sum -= A(k,j)*x[k];
727              x[j] = sum/p[j];
728          }
729          for (int j = i; j < n; j++) A(i,j) = x[j];
730      }
731  }
732  void TNumericalStuff::InverseSymetric(TFltVV& A) {
733      IAssert(A.GetRows() == A.GetCols());
734      TFltV p;
735      CholeskyDecomposition(A, p);
736      InverseSubstitute(A, p);
737  }
738  void TNumericalStuff::InverseTriagonal(TFltVV& A) {
739    IAssert(A.GetRows() == A.GetCols());
740    int n = A.GetRows(); TFltV x(n), p(n);
741      int i, j, k; double sum;
742      for (i = 0; i < n; i++) {
743          p[i] = A(i,i);
744          for (j = i+1; j < n; j++)
745              A(j,i) = A(i,j);
746      }
747      for (i = 0; i < n; i++) {
748          for (j = n-1; j > i; j--) x[j] = 0.0;
749          x[i] = 1/p[i];
750          for (j = i-1; j >= 0; j--) {
751              for (sum = 0.0, k = i; k > j; k--)
752                  sum -= A(k,j) * x[k];
753              x[j] = sum / p[j];
754          }
755          for (int j = 0; j <= i; j++) A(j,i) = x[j];
756      }
757  }
758  void TNumericalStuff::LUDecomposition(TFltVV& A, TIntV& indx, double& d) {
759    Assert(A.GetRows() == A.GetCols());
760    int n = A.GetRows(); indx.Reserve(n,n);
761      int i=0,imax=0,j=0,k=0;
762      double big,dum,sum,temp;
763      TFltV vv(n); 
764      d=1.0;       
765      for (i=1;i<=n;i++) {
766          big=0.0;
767          for (j=1;j<=n;j++)
768              if ((temp=TFlt::Abs(A(i-1,j-1))) > big) big=temp;
769          if (big == 0.0) nrerror("Singular matrix in routine LUDecomposition");
770          vv[i-1]=1.0/big;
771      }
772      for (j=1;j<=n;j++) {
773          for (i=1;i<j;i++) {
774              sum=A(i-1,j-1);
775              for (k=1;k<i;k++) sum -= A(i-1,k-1)*A(k-1,j-1);
776              A(i-1,j-1)=sum;
777          }
778          big=0.0; 
779          for (i=j;i<=n;i++) {
780              sum=A(i-1,j-1);
781              for (k=1;k<j;k++)
782                  sum -= A(i-1,k-1)*A(k-1,j-1);
783              A(i-1,j-1)=sum;
784              if ((dum=vv[i-1] * TFlt::Abs(sum)) >= big) {
785                  big=dum;
786                  imax=i;
787              }
788          }
789          if (j != imax) {
790              for (k=1;k<=n;k++) {
791                  dum=A(imax-1,k-1);
792              A(imax-1,k-1)=A(j-1,k-1); 
793              A(j-1,k-1)=dum;
794              }
795              d = -d;
796              vv[imax-1]=vv[j-1]; 
797          }
798          indx[j-1]=imax;
799          if (A(j-1,j-1) == 0.0) A(j-1,j-1)=1e-20;
800          if (j != n) {
801              dum=1.0/(A(j-1,j-1));
802              for (i=j+1;i<=n;i++) A(i-1,j-1) *= dum;
803          }
804      } 
805  }
806  void TNumericalStuff::LUSolve(const TFltVV& A, const TIntV& indx, TFltV& b) {
807    Assert(A.GetRows() == A.GetCols());
808    int n = A.GetRows();
809      int i,ii=0,ip,j;
810      double sum;
811      for (i=1;i<=n;i++) {
812          ip=indx[i-1];
813          sum=b[ip-1];
814          b[ip-1]=b[i-1];
815          if (ii)
816              for (j=ii;j<=i-1;j++) sum -= A(i-1,j-1)*b[j-1];
817          else if (sum) ii=i;b[i-1]=sum;
818      }
819      for (i=n;i>=1;i--) {
820          sum=b[i-1];
821          for (j=i+1;j<=n;j++) sum -= A(i-1,j-1)*b[j-1];
822          b[i-1]=sum/A(i-1,i-1);
823      }
824  }
825  void TNumericalStuff::SolveLinearSystem(TFltVV& A, const TFltV& b, TFltV& x) {
826      TIntV indx; double d;
827      LUDecomposition(A, indx, d);
828      x = b;
829      LUSolve(A, indx, x);
830  }
831  void TSparseSVD::MultiplyATA(const TMatrix& Matrix,
832          const TFltVV& Vec, int ColId, TFltV& Result) {
833      TFltV tmp(Matrix.GetRows());
834      Matrix.Multiply(Vec, ColId, tmp);
835      Matrix.MultiplyT(tmp, Result);
836  }
837  void TSparseSVD::MultiplyATA(const TMatrix& Matrix,
838          const TFltV& Vec, TFltV& Result) {
839      TFltV tmp(Matrix.GetRows());
840      Matrix.Multiply(Vec, tmp);
841      Matrix.MultiplyT(tmp, Result);
842  }
843  void TSparseSVD::OrtoIterSVD(const TMatrix& Matrix,
844          int NumSV, int IterN, TFltV& SgnValV) {
845      int i, j, k;
846      int N = Matrix.GetCols(), M = NumSV;
847      TFltVV Q(N, M);
848      TRnd rnd;
849      for (i = 0; i < N; i++) {
850          for (j = 0; j < M; j++)
851              Q(i,j) = rnd.GetUniDev();
852      }
853      TFltV tmp(N);
854      for (int IterC = 0; IterC < IterN; IterC++) {
855          printf("%d..", IterC);
856          TLinAlg::GS(Q);
857          for (int ColId = 0; ColId < M; ColId++) {
858              MultiplyATA(Matrix, Q, ColId, tmp);
859              for (k = 0; k < N; k++) Q(k,ColId) = tmp[k];
860          }
861      }
862      SgnValV.Reserve(NumSV,0);
863      for (i = 0; i < NumSV; i++)
864          SgnValV.Add(sqrt(TLinAlg::Norm(Q,i)));
865      TLinAlg::GS(Q);
866  }
867  void TSparseSVD::SimpleLanczos(const TMatrix& Matrix,
868          const int& NumEig, TFltV& EigValV,
869          const bool& DoLocalReortoP, const bool& SvdMatrixProductP) {
870      if (SvdMatrixProductP) {
871          IAssert(Matrix.GetRows() >= Matrix.GetCols());
872      } else {
873          IAssert(Matrix.GetRows() == Matrix.GetCols());
874      }
875      const int N = Matrix.GetCols(); 
876      TFltV r(N), v0(N), v1(N); 
877      TFltV alpha(NumEig, 0), beta(NumEig, 0); 
878      printf("Calculating %d eigen-values of %d x %d matrix\n", NumEig, N, N);
879      for (int i = 0; i < N; i++) {
880          r[i] = 1/sqrt((double)N); 
881          v0[i] = v1[i] = 0.0;
882      }
883      beta.Add(TLinAlg::Norm(r));
884      for (int j = 0; j < NumEig; j++) {
885          printf("%d\r", j+1);
886          v0 = v1;
887          TLinAlg::MultiplyScalar(1/beta[j], r, v1);
888          if (SvdMatrixProductP) {
889              MultiplyATA(Matrix, v1, r);
890          } else {
891              Matrix.Multiply(v1, r);
892          }
893          TLinAlg::AddVec(-beta[j], v0, r, r);
894          alpha.Add(TLinAlg::DotProduct(v1, r));
895          TLinAlg::AddVec(-alpha[j], v1, r, r);
896          if (DoLocalReortoP) { } 
897          beta.Add(TLinAlg::Norm(r));
898      }
899      printf("\n");
900      TFltV d(NumEig + 1), e(NumEig + 1);
901      d[1] = alpha[0]; d[0] = e[0] = e[1] = 0.0;
902      for (int i = 1; i < NumEig; i++) {
903          d[i+1] = alpha[i]; e[i+1] = beta[i]; }
904      TFltVV S(NumEig+1,NumEig+1); 
905      TLAMisc::FillIdentity(S); 
906      TNumericalStuff::EigSymmetricTridiag(d, e, NumEig, S); 
907      TFltKdV AllEigValV(NumEig, 0);
908      for (int i = 1; i <= NumEig; i++) {
909          const double ResidualNorm = TFlt::Abs(S(i-1, NumEig-1) * beta.Last());
910          if (ResidualNorm < 1e-5)
911              AllEigValV.Add(TFltKd(TFlt::Abs(d[i]), d[i]));
912      }
913      AllEigValV.Sort(false); EigValV.Gen(NumEig, 0);
914      for (int i = 0; i < AllEigValV.Len(); i++) {
915          if (i == 0 || (TFlt::Abs(AllEigValV[i].Dat/AllEigValV[i-1].Dat) < 0.9999))
916              EigValV.Add(AllEigValV[i].Dat);
917      }
918  }
919  void TSparseSVD::Lanczos(const TMatrix& Matrix, int NumEig,
920          int Iters, const TSpSVDReOrtoType& ReOrtoType,
921          TFltV& EigValV, TFltVV& EigVecVV, const bool& SvdMatrixProductP) {
922    if (SvdMatrixProductP) {
923      IAssert(Matrix.GetRows() >= Matrix.GetCols());
924    } else {
925      IAssert(Matrix.GetRows() == Matrix.GetCols());
926    }
927    IAssertR(NumEig <= Iters, TStr::Fmt("%d <= %d", NumEig, Iters));
928    int i, N = Matrix.GetCols(), K = 0; 
929    double t = 0.0, eps = 1e-6; 
930    TFltVV Q(N, Iters);
931    double tmp = 1/sqrt((double)N);
932    for (i = 0; i < N; i++) {
933      Q(i,0) = tmp;
934    }
935    TVec<TFltV> ConvgQV(Iters);
936    TIntV CountConvgV(Iters);
937    for (i = 0; i < Iters; i++) CountConvgV[i] = 0;
938    TFltV d(Iters+1), e(Iters+1);
939    TFltVV V(Iters, Iters);
940    TFltV z(N), bb(Iters), aa(Iters), y(N);
941    if (SvdMatrixProductP) {
942      MultiplyATA(Matrix, Q, 0, z);
943    } else {
944      Matrix.Multiply(Q, 0, z);
945    }
946    for (int j = 0; j < (Iters-1); j++) {
947      aa[j] = TLinAlg::DotProduct(Q, j, z);
948      TLinAlg::AddVec(-aa[j], Q, j, z);
949      if (j > 0) {
950        TLinAlg::AddVec(-bb[j-1], Q, j-1, z);
951        if (ReOrtoType == ssotSelective || ReOrtoType == ssotFull) {
952          for (i = 0; i <= j; i++) {
953            if ((ReOrtoType == ssotFull) ||
954              (bb[j-1] * TFlt::Abs(V(K-1, i)) < eps * t)) {
955              ConvgQV[i].Reserve(N,N); CountConvgV[i]++;
956              TFltV& vec = ConvgQV[i];
957              for (int k = 0; k < N; k++) {
958                vec[k] = 0.0;
959                for (int l = 0; l < K; l++) {
960                  vec[k] += Q(k,l) * V(l,i);
961                }
962              }
963              TLinAlg::AddVec(-TLinAlg::DotProduct(ConvgQV[i], z), ConvgQV[i], z ,z);
964            }
965          }
966        }
967      }
968      bb[j] = TLinAlg::Norm(z);
969      if (!(bb[j] > 1e-10)) {
970        printf("Rank of matrix is only %d\n", j+2);
971        printf("Last singular value is %g\n", bb[j].Val);
972        break;
973      }
974      for (i = 0; i < N; i++) {
975        Q(i, j+1) = z[i] / bb[j];
976      }
977      if (SvdMatrixProductP) {
978        MultiplyATA(Matrix, Q, j+1, z);
979      } else {
980        Matrix.Multiply(Q, j+1, z);
981      }
982      K = j + 2;
983      for (i = 1; i < K; i++) d[i] = aa[i-1];
984      d[K] = TLinAlg::DotProduct(Q, K-1, z);
985      e[1] = 0.0;
986      for (i = 2; i <= K; i++) e[i] = bb[i-2];
987      t = TFlt::GetMx(TFlt::Abs(d[1]) + TFlt::Abs(e[2]), TFlt::Abs(e[K]) + TFlt::Abs(d[K]));
988      for (i = 2; i < K; i++) {
989        t = TFlt::GetMx(t, TFlt::Abs(e[i]) + TFlt::Abs(d[i]) + TFlt::Abs(e[i+1]));
990      }
991      for (i = 0; i < K; i++) {
992        for (int k = 0; k < K; k++) {
993          V(i,k) = 0.0;
994        }
995        V(i,i) = 1.0;
996      }
997      TNumericalStuff::EigSymmetricTridiag(d, e, K, V);
998    }
999    TFltIntKdV sv(K);
1000    for (i = 0; i < K; i++) {
1001      sv[i].Key = TFlt::Abs(d[i+1]);
1002      sv[i].Dat = i;
1003    }
1004    sv.Sort(false);
1005    TFltV uu(Matrix.GetRows());
1006    const int FinalNumEig = TInt::GetMn(NumEig, K);
1007    EigValV.Reserve(FinalNumEig,0);
1008    EigVecVV.Gen(Matrix.GetCols(), FinalNumEig);
1009    for (i = 0; i < FinalNumEig; i++) {
1010      int ii = sv[i].Dat;
1011      double sigma = d[ii+1].Val;
1012      EigValV.Add(sigma);
1013      TLinAlg::Multiply(Q, V, ii, EigVecVV, i);
1014    }
1015  }
1016  void TSparseSVD::Lanczos2(const TMatrix& Matrix, int MaxNumEig,
1017      int MaxSecs, const TSpSVDReOrtoType& ReOrtoType,
1018      TFltV& EigValV, TFltVV& EigVecVV, const bool& SvdMatrixProductP) {
1019    if (SvdMatrixProductP) {
1020      IAssert(Matrix.GetRows() >= Matrix.GetCols());
1021    } else {
1022      IAssert(Matrix.GetRows() == Matrix.GetCols());
1023    }
1024    int i, N = Matrix.GetCols(), K = 0; 
1025    double t = 0.0, eps = 1e-6; 
1026    TFltVV Q(N, MaxNumEig);
1027    double tmp = 1/sqrt((double)N);
1028    for (i = 0; i < N; i++)
1029        Q(i,0) = tmp;
1030    TVec<TFltV> ConvgQV(MaxNumEig);
1031    TIntV CountConvgV(MaxNumEig);
1032    for (i = 0; i < MaxNumEig; i++) CountConvgV[i] = 0;
1033    TFltV d(MaxNumEig+1), e(MaxNumEig+1);
1034    TFltVV V(MaxNumEig, MaxNumEig);
1035    TFltV z(N), bb(MaxNumEig), aa(MaxNumEig), y(N);
1036    if (SvdMatrixProductP) {
1037        MultiplyATA(Matrix, Q, 0, z);
1038    } else {
1039        Matrix.Multiply(Q, 0, z);
1040    }
1041    TExeTm ExeTm;
1042    for (int j = 0; j < (MaxNumEig-1); j++) {
1043      printf("%d [%s]..\r",j+2, ExeTm.GetStr());
1044      if (ExeTm.GetSecs() > MaxSecs) { break; }
1045      aa[j] = TLinAlg::DotProduct(Q, j, z);
1046      TLinAlg::AddVec(-aa[j], Q, j, z);
1047      if (j > 0) {
1048          TLinAlg::AddVec(-bb[j-1], Q, j-1, z);
1049          if (ReOrtoType == ssotSelective || ReOrtoType == ssotFull) {
1050              for (i = 0; i <= j; i++) {
1051                  if ((ReOrtoType == ssotFull) ||
1052                      (bb[j-1] * TFlt::Abs(V(K-1, i)) < eps * t)) {
1053                      ConvgQV[i].Reserve(N,N); CountConvgV[i]++;
1054                      TFltV& vec = ConvgQV[i];
1055                      for (int k = 0; k < N; k++) {
1056                          vec[k] = 0.0;
1057                          for (int l = 0; l < K; l++)
1058                              vec[k] += Q(k,l) * V(l,i);
1059                      }
1060                      TLinAlg::AddVec(-TLinAlg::DotProduct(ConvgQV[i], z), ConvgQV[i], z ,z);
1061                  }
1062              }
1063          }
1064      }
1065      bb[j] = TLinAlg::Norm(z);
1066      if (!(bb[j] > 1e-10)) {
1067        printf("Rank of matrix is only %d\n", j+2);
1068        printf("Last singular value is %g\n", bb[j].Val);
1069        break;
1070      }
1071      for (i = 0; i < N; i++)
1072          Q(i, j+1) = z[i] / bb[j];
1073      if (SvdMatrixProductP) {
1074          MultiplyATA(Matrix, Q, j+1, z);
1075      } else {
1076          Matrix.Multiply(Q, j+1, z);
1077      }
1078      K = j + 2;
1079      for (i = 1; i < K; i++) d[i] = aa[i-1];
1080      d[K] = TLinAlg::DotProduct(Q, K-1, z);
1081      e[1] = 0.0;
1082      for (i = 2; i <= K; i++) e[i] = bb[i-2];
1083      t = TFlt::GetMx(TFlt::Abs(d[1]) + TFlt::Abs(e[2]), TFlt::Abs(e[K]) + TFlt::Abs(d[K]));
1084      for (i = 2; i < K; i++)
1085          t = TFlt::GetMx(t, TFlt::Abs(e[i]) + TFlt::Abs(d[i]) + TFlt::Abs(e[i+1]));
1086      for (i = 0; i < K; i++) {
1087          for (int k = 0; k < K; k++)
1088              V(i,k) = 0.0;
1089          V(i,i) = 1.0;
1090      }
1091      TNumericalStuff::EigSymmetricTridiag(d, e, K, V);
1092    }
1093    printf("... calc %d.", K);
1094    TFltIntKdV sv(K);
1095    for (i = 0; i < K; i++) {
1096      sv[i].Key = TFlt::Abs(d[i+1]);
1097      sv[i].Dat = i;
1098    }
1099    sv.Sort(false);
1100    TFltV uu(Matrix.GetRows());
1101    const int FinalNumEig = K; 
1102    EigValV.Reserve(FinalNumEig,0);
1103    EigVecVV.Gen(Matrix.GetCols(), FinalNumEig);
1104    for (i = 0; i < FinalNumEig; i++) {
1105      int ii = sv[i].Dat;
1106      double sigma = d[ii+1].Val;
1107      EigValV.Add(sigma);
1108      TLinAlg::Multiply(Q, V, ii, EigVecVV, i);
1109    }
1110    printf("  done\n");
1111  }
1112  void TSparseSVD::SimpleLanczosSVD(const TMatrix& Matrix,
1113          const int& CalcSV, TFltV& SngValV, const bool& DoLocalReorto) {
1114      SimpleLanczos(Matrix, CalcSV, SngValV, DoLocalReorto, true);
1115      for (int SngValN = 0; SngValN < SngValV.Len(); SngValN++) {
1116        if (SngValV[SngValN] < 0.0) {
1117          printf("bad sng val: %d %g\n", SngValN, SngValV[SngValN]());
1118          SngValV[SngValN] = 0;
1119        }
1120        SngValV[SngValN] = sqrt(SngValV[SngValN].Val);
1121      }
1122  }
1123  void TSparseSVD::LanczosSVD(const TMatrix& Matrix, int NumSV,
1124          int Iters, const TSpSVDReOrtoType& ReOrtoType,
1125          TFltV& SgnValV, TFltVV& LeftSgnVecVV, TFltVV& RightSgnVecVV) {
1126      Lanczos(Matrix, NumSV, Iters, ReOrtoType, SgnValV, RightSgnVecVV, true);
1127      const int FinalNumSV = SgnValV.Len();
1128      LeftSgnVecVV.Gen(Matrix.GetRows(), FinalNumSV);
1129      TFltV LeftSgnVecV(Matrix.GetRows());
1130      for (int i = 0; i < FinalNumSV; i++) {
1131          if (SgnValV[i].Val < 0.0) { SgnValV[i] = 0.0; }
1132          const double SgnVal = sqrt(SgnValV[i]);
1133          SgnValV[i] = SgnVal;
1134          Matrix.Multiply(RightSgnVecVV, i, LeftSgnVecV);
1135          for (int j = 0; j < LeftSgnVecV.Len(); j++) {
1136              LeftSgnVecVV(j,i) = LeftSgnVecV[j] / SgnVal; }
1137      }
1138  }
1139  void TSparseSVD::Project(const TIntFltKdV& Vec, const TFltVV& U, TFltV& ProjVec) {
1140      const int m = U.GetCols(); 
1141      ProjVec.Gen(m, 0);
1142      for (int j = 0; j < m; j++) {
1143          double x = 0.0;
1144          for (int i = 0; i < Vec.Len(); i++)
1145              x += U(Vec[i].Key, j) * Vec[i].Dat;
1146          ProjVec.Add(x);
1147      }
1148  }
1149  double TSigmoid::EvaluateFit(const TFltIntKdV& data, const double A, const double B)
1150  {
1151    double J = 0.0;
1152    for (int i = 0; i < data.Len(); i++)
1153    {
1154      double zi = data[i].Key; int yi = data[i].Dat;
1155      double e = exp(-A * zi + B);
1156      double denum = 1.0 + e;
1157      double prob = (yi > 0) ? (1.0 / denum) : (e / denum);
1158      J -= log(prob < 1e-20 ? 1e-20 : prob);
1159    }
1160    return J;
1161  }
1162  void TSigmoid::EvaluateFit(const TFltIntKdV& data, const double A, const double B, double& J, double& JA, double& JB)
1163  {
1164    J = 0.0; double sum_all_PyNeg = 0.0, sum_all_ziPyNeg = 0.0, sum_yNeg_zi = 0.0, sum_yNeg_1 = 0.0;
1165    for (int i = 0; i < data.Len(); i++)
1166    {
1167      double zi = data[i].Key; int yi = data[i].Dat;
1168      double e = exp(-A * zi + B);
1169      double denum = 1.0 + e;
1170      double prob = (yi > 0) ? (1.0 / denum) : (e / denum);
1171      J -= log(prob < 1e-20 ? 1e-20 : prob);
1172      sum_all_PyNeg += e / denum;
1173      sum_all_ziPyNeg += zi * e / denum;
1174      if (yi < 0) { sum_yNeg_zi += zi; sum_yNeg_1 += 1; }
1175    }
1176    JA = -sum_all_ziPyNeg +     sum_yNeg_zi;
1177    JB =  sum_all_PyNeg   -     sum_yNeg_1;
1178  }
1179  void TSigmoid::EvaluateFit(const TFltIntKdV& data, const double A, const double B, const double U,
1180                             const double V, const double lambda, double& J, double& JJ, double& JJJ)
1181  {
1182    J = 0.0; JJ = 0.0; JJJ = 0.0;
1183    for (int i = 0; i < data.Len(); i++)
1184    {
1185      double zi = data[i].Key; int yi = data[i].Dat;
1186      double e = exp(-A * zi + B);
1187      double denum = 1.0 + e;
1188      double prob = (yi > 0) ? (1.0 / denum) : (e / denum);
1189      J -= log(prob < 1e-20 ? 1e-20 : prob);
1190      double VU = V - U * zi;
1191      JJ += VU * (e / denum); if (yi < 0) JJ -= VU;
1192      JJJ += VU * VU * e / denum / denum;
1193    }
1194  }
1195  TSigmoid::TSigmoid(const TFltIntKdV& data) {
1196    double minProj = data[0].Key, maxProj = data[0].Key;
1197    {for (int i = 1; i < data.Len(); i++) {
1198      double zi = data[i].Key; if (zi < minProj) minProj = zi; if (zi > maxProj) maxProj = zi; }}
1199    A = 1.0; B = 0.5 * (minProj + maxProj);
1200    double bestJ = 0.0, bestA = 0.0, bestB = 0.0, lambda = 1.0;
1201    for (int nIter = 0; nIter < 50; nIter++)
1202    {
1203      double J, JA, JB; TSigmoid::EvaluateFit(data, A, B, J, JA, JB);
1204      if (nIter == 0 || J < bestJ) { bestJ = J; bestA = A; bestB = B; }
1205          double norm = TMath::Sqr(JA) + TMath::Sqr(JB);
1206      if (norm < 1e-10) break;
1207      const int cl = -1; 
1208      double Jc = TSigmoid::EvaluateFit(data, A + cl * lambda * JA / norm, B + cl * lambda * JB / norm);
1209      if (Jc > J) {
1210        while (lambda > 1e-5) {
1211          lambda = 0.5 * lambda;
1212          Jc = TSigmoid::EvaluateFit(data, A + cl * lambda * JA / norm, B + cl * lambda * JB / norm);
1213        } }
1214      else if (Jc < J) {
1215        while (lambda < 1e5) {
1216          double lambda2 = 2 * lambda;
1217          double Jc2 = TSigmoid::EvaluateFit(data, A + cl * lambda2 * JA / norm, B + cl * lambda2 * JB / norm);
1218          if (Jc2 > Jc) break;
1219          lambda = lambda2; Jc = Jc2; } }
1220      if (Jc >= J) break;
1221      A += cl * lambda * JA / norm; B += cl * lambda * JB / norm;
1222    }
1223    A = bestA; B = bestB;
1224  }
1225  void TLAMisc::SaveCsvTFltV(const TFltV& Vec, TSOut& SOut) {
1226      for (int ValN = 0; ValN < Vec.Len(); ValN++) {
1227          SOut.PutFlt(Vec[ValN]); SOut.PutCh(',');
1228      }
1229      SOut.PutLn();
1230  }
1231  void TLAMisc::SaveMatlabTFltIntKdV(const TIntFltKdV& SpV, const int& ColN, TSOut& SOut) {
1232      const int Len = SpV.Len();
1233      for (int ValN = 0; ValN < Len; ValN++) {
1234          SOut.PutStrLn(TStr::Fmt("%d %d %g", SpV[ValN].Key+1, ColN+1, SpV[ValN].Dat()));
1235      }
1236  }
1237  void TLAMisc::SaveMatlabTFltV(const TFltV& m, const TStr& FName) {
1238      PSOut out = TFOut::New(FName);
1239      const int RowN = m.Len();
1240      for (int RowId = 0; RowId < RowN; RowId++) {
1241          out->PutStr(TFlt::GetStr(m[RowId], 20, 18));
1242          out->PutCh('\n');
1243      }
1244      out->Flush();
1245  }
1246  void TLAMisc::SaveMatlabTIntV(const TIntV& m, const TStr& FName) {
1247      PSOut out = TFOut::New(FName);
1248      const int RowN = m.Len();
1249      for (int RowId = 0; RowId < RowN; RowId++) {
1250          out->PutInt(m[RowId]);
1251          out->PutCh('\n');
1252      }
1253      out->Flush();
1254  }
1255  void TLAMisc::SaveMatlabTFltVVCol(const TFltVV& m, int ColId, const TStr& FName) {
1256      PSOut out = TFOut::New(FName);
1257      const int RowN = m.GetRows();
1258      for (int RowId = 0; RowId < RowN; RowId++) {
1259          out->PutStr(TFlt::GetStr(m(RowId,ColId), 20, 18));
1260          out->PutCh('\n');
1261      }
1262      out->Flush();
1263  }
1264  void TLAMisc::SaveMatlabTFltVV(const TFltVV& m, const TStr& FName) {
1265      PSOut out = TFOut::New(FName);
1266      const int RowN = m.GetRows();
1267      const int ColN = m.GetCols();
1268      for (int RowId = 0; RowId < RowN; RowId++) {
1269          for (int ColId = 0; ColId < ColN; ColId++) {
1270              out->PutStr(TFlt::GetStr(m(RowId,ColId), 20, 18));
1271              out->PutCh(' ');
1272          }
1273          out->PutCh('\n');
1274      }
1275      out->Flush();
1276  }
1277  void TLAMisc::SaveMatlabTFltVVMjrSubMtrx(const TFltVV& m,
1278          int RowN, int ColN, const TStr& FName) {
1279      PSOut out = TFOut::New(FName);
1280      for (int RowId = 0; RowId < RowN; RowId++) {
1281          for (int ColId = 0; ColId < ColN; ColId++) {
1282              out->PutStr(TFlt::GetStr(m(RowId,ColId), 20, 18)); out->PutCh(' ');
1283          }
1284          out->PutCh('\n');
1285      }
1286      out->Flush();
1287  }
1288  void TLAMisc::LoadMatlabTFltVV(const TStr& FNm, TVec<TFltV>& ColV) {
1289      PSIn SIn = TFIn::New(FNm);
1290      TILx Lx(SIn, TFSet()|iloRetEoln|iloSigNum|iloExcept);
1291      int Row = 0, Col = 0; ColV.Clr();
1292      Lx.GetSym(syFlt, syEof, syEoln);
1293      while (Lx.Sym != syEof) {
1294          if (Lx.Sym == syFlt) {
1295              if (ColV.Len() > Col) {
1296                  IAssert(ColV[Col].Len() == Row);
1297                  ColV[Col].Add(Lx.Flt);
1298              } else {
1299                  IAssert(Row == 0);
1300                  ColV.Add(TFltV::GetV(Lx.Flt));
1301              }
1302              Col++;
1303          } else if (Lx.Sym == syEoln) {
1304              IAssert(Col == ColV.Len());
1305              Col = 0; Row++;
1306              if (Row%100 == 0) {
1307              }
1308          } else {
1309              Fail;
1310          }
1311          Lx.GetSym(syFlt, syEof, syEoln);
1312      }
1313      IAssert(Col == ColV.Len() || Col == 0);
1314  }
1315  void TLAMisc::LoadMatlabTFltVV(const TStr& FNm, TFltVV& MatrixVV) {
1316      TVec<TFltV> ColV; LoadMatlabTFltVV(FNm, ColV);
1317      if (ColV.Empty()) { MatrixVV.Clr(); return; }
1318      const int Rows = ColV[0].Len(), Cols = ColV.Len();
1319      MatrixVV.Gen(Rows, Cols);
1320      for (int RowN = 0; RowN < Rows; RowN++) {
1321          for (int ColN = 0; ColN < Cols; ColN++) {
1322              MatrixVV(RowN, ColN) = ColV[ColN][RowN];
1323          }
1324      }
1325  }
1326  void TLAMisc::PrintTFltV(const TFltV& Vec, const TStr& VecNm) {
1327      printf("%s = [", VecNm.CStr());
<span onclick='openModal()' class='match'>1328      for (int i = 0; i < Vec.Len(); i++) {
1329          printf("%.5f", Vec[i]());
1330  		if (i < Vec.Len() - 1) { printf(", "); }
1331      }
1332      printf("]\n");
1333  }
</span>1334  void TLAMisc::PrintTFltVV(const TFltVV& A, const TStr& MatrixNm) {
1335      printf("%s = [\n", MatrixNm.CStr());
1336  	for (int j = 0; j < A.GetRows(); j++) {
1337  		for (int i = 0; i < A.GetCols(); i++) {
1338  			printf("%f\t", A.At(i, j).Val);
1339  		}
1340  		printf("\n");
1341  	}
1342      printf("]\n");
1343  }
1344  void TLAMisc::PrintTIntV(const TIntV& Vec, const TStr& VecNm) {
1345      printf("%s = [", VecNm.CStr());
1346      for (int i = 0; i < Vec.Len(); i++) {
1347          printf("%d", Vec[i]());
1348          if (i < Vec.Len() - 1) printf(", ");
1349      }
1350      printf("]\n");
1351  }
1352  void TLAMisc::FillRnd(TFltV& Vec, TRnd& Rnd) {
1353      int Len = Vec.Len();
1354      for (int i = 0; i < Len; i++)
1355          Vec[i] = Rnd.GetNrmDev();
1356  }
1357  void TLAMisc::FillIdentity(TFltVV& M) {
1358      IAssert(M.GetRows() == M.GetCols());
1359      int Len = M.GetRows();
1360      for (int i = 0; i < Len; i++) {
1361          for (int j = 0; j < Len; j++) M(i,j) = 0.0;
1362          M(i,i) = 1.0;
1363      }
1364  }
1365  void TLAMisc::FillIdentity(TFltVV& M, const double& Elt) {
1366      IAssert(M.GetRows() == M.GetCols());
1367      int Len = M.GetRows();
1368      for (int i = 0; i < Len; i++) {
1369          for (int j = 0; j < Len; j++) M(i,j) = 0.0;
1370          M(i,i) = Elt;
1371      }
1372  }
1373  int TLAMisc::SumVec(const TIntV& Vec) {
1374      const int Len = Vec.Len();
1375      int res = 0;
1376      for (int i = 0; i < Len; i++)
1377          res += Vec[i];
1378      return res;
1379  }
1380  double TLAMisc::SumVec(const TFltV& Vec) {
1381      const int Len = Vec.Len();
1382      double res = 0.0;
1383      for (int i = 0; i < Len; i++)
1384          res += Vec[i];
1385      return res;
1386  }
1387  void TLAMisc::ToSpVec(const TFltV& Vec, TIntFltKdV& SpVec,
1388          const double& CutSumPrc) {
1389      IAssert(0.0 <= CutSumPrc && CutSumPrc <= 1.0);
1390      const int Elts = Vec.Len();
1391      double EltSum = 0.0;
1392      for (int EltN = 0; EltN < Elts; EltN++) {
1393          EltSum += TFlt::Abs(Vec[EltN]); }
1394      const double MnEltVal = CutSumPrc * EltSum;
1395      SpVec.Clr();
1396      for (int EltN = 0; EltN < Elts; EltN++) {
1397          if (TFlt::Abs(Vec[EltN]) > MnEltVal) {
1398              SpVec.Add(TIntFltKd(EltN, Vec[EltN]));
1399          }
1400      }
1401      SpVec.Pack();
1402  }
1403  void TLAMisc::ToVec(const TIntFltKdV& SpVec, TFltV& Vec, const int& VecLen) {
1404      Vec.Gen(VecLen); Vec.PutAll(0.0);
1405      int Elts = SpVec.Len();
1406      for (int EltN = 0; EltN < Elts; EltN++) {
1407          if (SpVec[EltN].Key < VecLen) {
1408              Vec[SpVec[EltN].Key] = SpVec[EltN].Dat;
1409          }
1410      }
1411  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-hysgen.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-linalg.cpp</div>
                </div>
                <div class="column column_space"><pre><code>329      for (int CId = 0; CId < NumComs; CId++){
330        if (NumMmbrsInEdgV[CId] > 0 && NumMmbrsInEdgV[CId] < NeiNV.Len()) {
331          ProdH.DelKey(CId);
332        }
333      }
334      AddECom(EI.GetId(), ProdH);
335    }
</pre></code></div>
                <div class="column column_space"><pre><code>1328      for (int i = 0; i < Vec.Len(); i++) {
1329          printf("%.5f", Vec[i]());
1330  		if (i < Vec.Len() - 1) { printf(", "); }
1331      }
1332      printf("]\n");
1333  }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    