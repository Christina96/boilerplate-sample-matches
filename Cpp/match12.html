<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for json.hpp &amp; xml.hpp</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for json.hpp &amp; xml.hpp
      </h3>
<h1 align="center">
        25.3%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>json.hpp (22.53194%)<th>xml.hpp (29.085457%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(640-709)<td><a href="#" name="0">(662-725)</a><td align="center"><font color="#ff0000">66</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(797-846)<td><a href="#" name="1">(775-823)</a><td align="center"><font color="#d40000">55</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(741-770)<td><a href="#" name="2">(725-765)</a><td align="center"><font color="#9e0000">41</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(556-573)<td><a href="#" name="3">(449-472)</a><td align="center"><font color="#410000">17</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(95-108)<td><a href="#" name="4">(92-105)</a><td align="center"><font color="#390000">15</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>json.hpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#ifndef CEREAL_ARCHIVES_JSON_HPP_
#define CEREAL_ARCHIVES_JSON_HPP_
#include &lt;cereal/cereal.hpp&gt;
#include &lt;cereal/details/util.hpp&gt;
namespace cereal
{
  struct RapidJSONException : Exception
  { RapidJSONException( const char * what_ ) : Exception( what_ ) {} };
}
#ifndef RAPIDJSON_ASSERT
#define RAPIDJSON_ASSERT(x) if(!(x)){ \
  throw ::cereal::RapidJSONException("rapidjson internal assertion failure: " #x); }
#endif 
#include &lt;cereal/external/rapidjson/prettywriter.h&gt;
#include &lt;cereal/external/rapidjson/genericstream.h&gt;
#include &lt;cereal/external/rapidjson/reader.h&gt;
#include &lt;cereal/external/rapidjson/document.h&gt;
#include &lt;cereal/external/base64.hpp&gt;
#include &lt;limits&gt;
#include &lt;sstream&gt;
#include &lt;stack&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
namespace cereal
{
  class JSONOutputArchive : public OutputArchive&lt;JSONOutputArchive&gt;
  {
    enum class NodeType { StartObject, InObject, StartArray, InArray };
<a name="4"></a>    typedef rapidjson::GenericWriteStream WriteStream;
    typedef rapidjson::PrettyWriter&lt;WriteStream&gt; JSONWriter;
<font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    public:
      class Options
      {
        public:
          static Options Default(){ return Options(); }
          static Options NoIndent(){ return Options( std::numeric_limits&lt;double&gt;::max_digits10, IndentChar::space, 0 ); }</b></font>
          enum class IndentChar : char
          {
            space = ' ',
            tab = '\t',
            newline = '\n',
            carriage_return = '\r'
          };
          explicit Options( int precision = std::numeric_limits&lt;double&gt;::max_digits10,
                            IndentChar indentChar = IndentChar::space,
                            unsigned int indentLength = 4 ) :
            itsPrecision( precision ),
            itsIndentChar( static_cast&lt;char&gt;(indentChar) ),
            itsIndentLength( indentLength ) { }
        private:
          friend class JSONOutputArchive;
          int itsPrecision;
          char itsIndentChar;
          unsigned int itsIndentLength;
      };
      JSONOutputArchive(std::ostream &amp; stream, Options const &amp; options = Options::Default() ) :
        OutputArchive&lt;JSONOutputArchive&gt;(this),
        itsWriteStream(stream),
        itsWriter(itsWriteStream, options.itsPrecision),
        itsNextName(nullptr)
      {
        itsWriter.SetIndent( options.itsIndentChar, options.itsIndentLength );
        itsNameCounter.push(0);
        itsNodeStack.push(NodeType::StartObject);
      }
      ~JSONOutputArchive()
      {
        itsWriter.EndObject();
      }
      void saveBinaryValue( const void * data, size_t size, const char * name = nullptr )
      {
        setNextName( name );
        writeName();
        auto base64string = base64::encode( reinterpret_cast&lt;const unsigned char *&gt;( data ), size );
        saveValue( base64string );
      };
      void startNode()
      {
        writeName();
        itsNodeStack.push(NodeType::StartObject);
        itsNameCounter.push(0);
      }
      void finishNode()
      {
        switch(itsNodeStack.top())
        {
          case NodeType::StartArray:
            itsWriter.StartArray();
          case NodeType::InArray:
            itsWriter.EndArray();
            break;
          case NodeType::StartObject:
            itsWriter.StartObject();
          case NodeType::InObject:
            itsWriter.EndObject();
            break;
        }
        itsNodeStack.pop();
        itsNameCounter.pop();
      }
      void setNextName( const char * name )
      {
        itsNextName = name;
      }
      void saveValue(bool b)                { itsWriter.Bool_(b);                                                         }
      void saveValue(int i)                 { itsWriter.Int(i);                                                          }
      void saveValue(unsigned u)            { itsWriter.Uint(u);                                                         }
      void saveValue(int64_t i64)           { itsWriter.Int64(i64);                                                      }
      void saveValue(uint64_t u64)          { itsWriter.Uint64(u64);                                                     }
      void saveValue(double d)              { itsWriter.Double(d);                                                       }
      void saveValue(std::string const &amp; s) { itsWriter.String(s.c_str(), static_cast&lt;rapidjson::SizeType&gt;( s.size() )); }
      void saveValue(char const * s)        { itsWriter.String(s);                                                       }
    private:
      template &lt;class T&gt; inline
      typename std::enable_if&lt;sizeof(T) == sizeof(std::int32_t) &amp;&amp; std::is_signed&lt;T&gt;::value, void&gt;::type
      saveLong(T l){ saveValue( static_cast&lt;std::int32_t&gt;( l ) ); }
      template &lt;class T&gt; inline
      typename std::enable_if&lt;sizeof(T) != sizeof(std::int32_t) &amp;&amp; std::is_signed&lt;T&gt;::value, void&gt;::type
      saveLong(T l){ saveValue( static_cast&lt;std::int64_t&gt;( l ) ); }
      template &lt;class T&gt; inline
      typename std::enable_if&lt;sizeof(T) == sizeof(std::uint32_t) &amp;&amp; !std::is_signed&lt;T&gt;::value, void&gt;::type
      saveLong(T lu){ saveValue( static_cast&lt;std::uint32_t&gt;( lu ) ); }
      template &lt;class T&gt; inline
      typename std::enable_if&lt;sizeof(T) != sizeof(std::uint32_t) &amp;&amp; !std::is_signed&lt;T&gt;::value, void&gt;::type
      saveLong(T lu){ saveValue( static_cast&lt;std::uint64_t&gt;( lu ) ); }
    public:
#ifdef _MSC_VER
      void saveValue( unsigned long lu ){ saveLong( lu ); };
#else       template &lt;class T&gt; inline
      typename std::enable_if&lt;std::is_same&lt;T, long&gt;::value &amp;&amp;
                              !std::is_same&lt;T, std::int32_t&gt;::value &amp;&amp;
                              !std::is_same&lt;T, std::int64_t&gt;::value, void&gt;::type
      saveValue( T t ){ saveLong( t ); }
      template &lt;class T&gt; inline
      typename std::enable_if&lt;std::is_same&lt;T, unsigned long&gt;::value &amp;&amp;
                              !std::is_same&lt;T, std::uint32_t&gt;::value &amp;&amp;
                              !std::is_same&lt;T, std::uint64_t&gt;::value, void&gt;::type
      saveValue( T t ){ saveLong( t ); }
#endif 
      template&lt;class T&gt; inline
      typename std::enable_if&lt;std::is_arithmetic&lt;T&gt;::value &amp;&amp;
                              !std::is_same&lt;T, long&gt;::value &amp;&amp;
                              !std::is_same&lt;T, unsigned long&gt;::value &amp;&amp;
                              !std::is_same&lt;T, std::int64_t&gt;::value &amp;&amp;
                              !std::is_same&lt;T, std::uint64_t&gt;::value &amp;&amp;
                              (sizeof(T) &gt;= sizeof(long double) || sizeof(T) &gt;= sizeof(long long)), void&gt;::type
      saveValue(T const &amp; t)
      {
        std::stringstream ss; ss.precision( std::numeric_limits&lt;long double&gt;::max_digits10 );
        ss &lt;&lt; t;
        saveValue( ss.str() );
      }
      void writeName()
      {
        NodeType const &amp; nodeType = itsNodeStack.top();
        if(nodeType == NodeType::StartArray)
        {
          itsWriter.StartArray();
          itsNodeStack.top() = NodeType::InArray;
        }
        else if(nodeType == NodeType::StartObject)
        {
          itsNodeStack.top() = NodeType::InObject;
          itsWriter.StartObject();
        }
        if(nodeType == NodeType::InArray) return;
        if(itsNextName == nullptr)
        {
          std::string name = "value" + std::to_string( itsNameCounter.top()++ ) + "\0";
          saveValue(name);
        }
        else
        {
          saveValue(itsNextName);
          itsNextName = nullptr;
        }
      }
      void makeArray()
      {
        itsNodeStack.top() = NodeType::StartArray;
      }
    private:
      WriteStream itsWriteStream;          //!&lt; Rapidjson write stream
      JSONWriter itsWriter;                //!&lt; Rapidjson writer
      char const * itsNextName;            //!&lt; The next name
      std::stack&lt;uint32_t&gt; itsNameCounter; //!&lt; Counter for creating unique names for unnamed nodes
      std::stack&lt;NodeType&gt; itsNodeStack;
  }; 
  class JSONInputArchive : public InputArchive&lt;JSONInputArchive&gt;
  {
    private:
      typedef rapidjson::GenericReadStream ReadStream;
      typedef rapidjson::GenericValue&lt;rapidjson::UTF8&lt;&gt;&gt; JSONValue;
      typedef JSONValue::ConstMemberIterator MemberIterator;
      typedef JSONValue::ConstValueIterator ValueIterator;
      typedef rapidjson::Document::GenericValue GenericValue;
    public:
      JSONInputArchive(std::istream &amp; stream) :
        InputArchive&lt;JSONInputArchive&gt;(this),
        itsNextName( nullptr ),
        itsReadStream(stream)
      {
        itsDocument.ParseStream&lt;0&gt;(itsReadStream);
        itsIteratorStack.emplace_back(itsDocument.MemberBegin(), itsDocument.MemberEnd());
      }
      void loadBinaryValue( void * data, size_t size, const char * name = nullptr )
      {
        itsNextName = name;
        std::string encoded;
        loadValue( encoded );
        auto decoded = base64::decode( encoded );
        if( size != decoded.size() )
          throw Exception("Decoded binary data size does not match specified size");
        std::memcpy( data, decoded.data(), decoded.size() );
        itsNextName = nullptr;
      };
    private:
      class Iterator
      {
        public:
          Iterator() : itsIndex( 0 ), itsType(Null_) {}
          Iterator(MemberIterator begin, MemberIterator end) :
            itsMemberItBegin(begin), itsMemberItEnd(end), itsIndex(0), itsType(Member)
          { }
          Iterator(ValueIterator begin, ValueIterator end) :
            itsValueItBegin(begin), itsValueItEnd(end), itsIndex(0), itsType(Value)
          { }
          Iterator &amp; operator++()
          {
            ++itsIndex;
            return *this;
          }
          GenericValue const &amp; value()
          {
            switch(itsType)
            {
              case Value : return itsValueItBegin[itsIndex];
              case Member: return itsMemberItBegin[itsIndex].value;
              default: throw cereal::Exception("Invalid Iterator Type!");
            }
          }
          const char * name() const
          {
            if( itsType == Member &amp;&amp; (itsMemberItBegin + itsIndex) != itsMemberItEnd )
              return itsMemberItBegin[itsIndex].name.GetString();
            else
              return nullptr;
          }
          inline void search( const char * searchName )
          {
            const auto len = std::strlen( searchName );
            size_t index = 0;
            for( auto it = itsMemberItBegin; it != itsMemberItEnd; ++it, ++index )
              if( std::strncmp( searchName, it-&gt;name.GetString(), len ) == 0 )
              {
                itsIndex = index;
                return;
              }
            throw Exception("JSON Parsing failed - provided NVP not found");
          }
        private:
          MemberIterator itsMemberItBegin, itsMemberItEnd; //!&lt; The member iterator (object)
          ValueIterator itsValueItBegin, itsValueItEnd;    //!&lt; The value iterator (array)
          size_t itsIndex;                                 //!&lt; The current index of this iterator
          enum Type {Value, Member, Null_} itsType;    //!&lt; Whether this holds values (array) or members (objects) or nothing
      };
      inline void search()
      {
        if( itsNextName )
        {
          auto const actualName = itsIteratorStack.back().name();
          if( !actualName || std::strcmp( itsNextName, actualName ) != 0 )
            itsIteratorStack.back().search( itsNextName );
        }
        itsNextName = nullptr;
      }
    public:
      void startNode()
      {
        search();
        if(itsIteratorStack.back().value().IsArray())
<a name="3"></a>          itsIteratorStack.emplace_back(itsIteratorStack.back().value().Begin(), itsIteratorStack.back().value().End());
        else
          itsIteratorStack.emplace_back(itsIteratorStack.back().value().MemberBegin(), itsIteratorStack.back().value().MemberEnd());
<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>      }
      void finishNode()
      {
        itsIteratorStack.pop_back();
        ++itsIteratorStack.back();
      }
      void setNextName( const char * name )
      {
        itsNextName = name;
      }
      template&lt;class T&gt; inline
      typename std::enable_if&lt;std::is_signed&lt;T&gt;::value &amp;&amp; sizeof(T) &lt; sizeof(int64_t), void&gt;::type</b></font>
      loadValue(T &amp; val)
      {
        search();
        val = itsIteratorStack.back().value().GetInt();
        ++itsIteratorStack.back();
      }
      template&lt;class T&gt; inline
      typename std::enable_if&lt;(std::is_unsigned&lt;T&gt;::value &amp;&amp; sizeof(T) &lt; sizeof(uint64_t)) &amp;&amp;
                              !std::is_same&lt;bool, T&gt;::value, void&gt;::type
      loadValue(T &amp; val)
      {
        search();
        val = itsIteratorStack.back().value().GetUint();
        ++itsIteratorStack.back();
      }
      void loadValue(bool &amp; val)        { search(); val = itsIteratorStack.back().value().GetBool_();   ++itsIteratorStack.back(); }
      void loadValue(int64_t &amp; val)     { search(); val = itsIteratorStack.back().value().GetInt64();  ++itsIteratorStack.back(); }
      void loadValue(uint64_t &amp; val)    { search(); val = itsIteratorStack.back().value().GetUint64(); ++itsIteratorStack.back(); }
      void loadValue(float &amp; val)       { search(); val = static_cast&lt;float&gt;(itsIteratorStack.back().value().GetDouble()); ++itsIteratorStack.back(); }
      void loadValue(double &amp; val)      { search(); val = itsIteratorStack.back().value().GetDouble(); ++itsIteratorStack.back(); }
      void loadValue(std::string &amp; val) { search(); val = itsIteratorStack.back().value().GetString(); ++itsIteratorStack.back(); }
    private:
      void stringToNumber( std::string const &amp; str, long long &amp; val ) { val = std::stoll( str ); }
      void stringToNumber( std::string const &amp; str, unsigned long long &amp; val ) { val = std::stoull( str ); }
      void stringToNumber( std::string const &amp; str, long double &amp; val ) { val = std::stold( str ); }
    public:
      template&lt;class T&gt; inline
      typename std::enable_if&lt;std::is_arithmetic&lt;T&gt;::value &amp;&amp;
                              !std::is_same&lt;T, long&gt;::value &amp;&amp;
                              !std::is_same&lt;T, unsigned long&gt;::value &amp;&amp;
                              !std::is_same&lt;T, std::int64_t&gt;::value &amp;&amp;
                              !std::is_same&lt;T, std::uint64_t&gt;::value &amp;&amp;
                              (sizeof(T) &gt;= sizeof(long double) || sizeof(T) &gt;= sizeof(long long)), void&gt;::type
      loadValue(T &amp; val)
      {
        std::string encoded;
        loadValue( encoded );
        stringToNumber( encoded, val );
      }
      void loadSize(size_type &amp; size)
      {
        size = (itsIteratorStack.rbegin() + 1)-&gt;value().Size();
      }
<a name="0"></a>      //! @}
    private:
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>      const char * itsNextName;               //!&lt; Next name set by NVP
      ReadStream itsReadStream;               //!&lt; Rapidjson write stream
      std::vector&lt;Iterator&gt; itsIteratorStack; //!&lt; 'Stack' of rapidJSON iterators
      rapidjson::Document itsDocument;        //!&lt; Rapidjson document
  };
  template &lt;class T&gt; inline
  void prologue( JSONOutputArchive &amp;, NameValuePair&lt;T&gt; const &amp; )
  { }
  template &lt;class T&gt; inline
  void prologue( JSONInputArchive &amp;, NameValuePair&lt;T&gt; const &amp; )
  { }
  template &lt;class T&gt; inline
  void epilogue( JSONOutputArchive &amp;, NameValuePair&lt;T&gt; const &amp; )
  { }
  template &lt;class T&gt; inline
  void epilogue( JSONInputArchive &amp;, NameValuePair&lt;T&gt; const &amp; )
  { }
  template &lt;class T&gt; inline
  void prologue( JSONOutputArchive &amp; ar, SizeTag&lt;T&gt; const &amp; )
  {
    ar.makeArray();
  }
  template &lt;class T&gt; inline
  void prologue( JSONInputArchive &amp;, SizeTag&lt;T&gt; const &amp; )
  { }
  template &lt;class T&gt; inline
  void epilogue( JSONOutputArchive &amp;, SizeTag&lt;T&gt; const &amp; )
  { }
  template &lt;class T&gt; inline
  void epilogue( JSONInputArchive &amp;, SizeTag&lt;T&gt; const &amp; )
  { }
  template &lt;class T&gt; inline
  typename std::enable_if&lt;!std::is_arithmetic&lt;T&gt;::value &amp;&amp;</b></font>
                          !traits::has_minimal_output_serialization&lt;T, JSONOutputArchive&gt;::value, void&gt;::type
  prologue( JSONOutputArchive &amp; ar, T const &amp; )
  {
    ar.startNode();
  }
  template &lt;class T&gt; inline
  typename std::enable_if&lt;!std::is_arithmetic&lt;T&gt;::value &amp;&amp;
                          !traits::has_minimal_input_serialization&lt;T, JSONOutputArchive&gt;::value, void&gt;::type
  prologue( JSONInputArchive &amp; ar, T const &amp; )
  {
    ar.startNode();
  }
  template &lt;class T&gt; inline
  typename std::enable_if&lt;!std::is_arithmetic&lt;T&gt;::value &amp;&amp;
                          !traits::has_minimal_output_serialization&lt;T, JSONOutputArchive&gt;::value, void&gt;::type
  epilogue( JSONOutputArchive &amp; ar, T const &amp; )
  {
    ar.finishNode();
  }
<a name="2"></a>  //! Epilogue for all other types other for JSON archives
  template &lt;class T&gt; inline
  typename std::enable_if&lt;!std::is_arithmetic&lt;T&gt;::value &amp;&amp;
<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>                          !traits::has_minimal_input_serialization&lt;T, JSONOutputArchive&gt;::value, void&gt;::type
  epilogue( JSONInputArchive &amp; ar, T const &amp; )
  {
    ar.finishNode();
  }
  template &lt;class T&gt; inline
  typename std::enable_if&lt;std::is_arithmetic&lt;T&gt;::value, void&gt;::type
  prologue( JSONOutputArchive &amp; ar, T const &amp; )
  {
    ar.writeName();
  }
  template &lt;class T&gt; inline
  typename std::enable_if&lt;std::is_arithmetic&lt;T&gt;::value, void&gt;::type
  prologue( JSONInputArchive &amp;, T const &amp; )
  { }
  template &lt;class T&gt; inline
  typename std::enable_if&lt;std::is_arithmetic&lt;T&gt;::value, void&gt;::type
  epilogue( JSONOutputArchive &amp;, T const &amp; )
  { }
  template &lt;class T&gt; inline</b></font>
  typename std::enable_if&lt;std::is_arithmetic&lt;T&gt;::value, void&gt;::type
  epilogue( JSONInputArchive &amp;, T const &amp; )
  { }
  template&lt;class CharT, class Traits, class Alloc&gt; inline
  void prologue(JSONOutputArchive &amp; ar, std::basic_string&lt;CharT, Traits, Alloc&gt; const &amp;)
  {
    ar.writeName();
  }
  template&lt;class CharT, class Traits, class Alloc&gt; inline
  void prologue(JSONInputArchive &amp;, std::basic_string&lt;CharT, Traits, Alloc&gt; const &amp;)
  { }
  template&lt;class CharT, class Traits, class Alloc&gt; inline
  void epilogue(JSONOutputArchive &amp;, std::basic_string&lt;CharT, Traits, Alloc&gt; const &amp;)
  { }
<a name="1"></a>  //! Epilogue for strings for JSON archives
  template&lt;class CharT, class Traits, class Alloc&gt; inline
  void epilogue(JSONInputArchive &amp;, std::basic_string&lt;CharT, Traits, Alloc&gt; const &amp;)
<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  { }
  template &lt;class T&gt; inline
  void save( JSONOutputArchive &amp; ar, NameValuePair&lt;T&gt; const &amp; t )
  {
    ar.setNextName( t.name );
    ar( t.value );
  }
  template &lt;class T&gt; inline
  void load( JSONInputArchive &amp; ar, NameValuePair&lt;T&gt; &amp; t )
  {
    ar.setNextName( t.name );
    ar( t.value );
  }
  template&lt;class T&gt; inline
  typename std::enable_if&lt;std::is_arithmetic&lt;T&gt;::value, void&gt;::type
  save(JSONOutputArchive &amp; ar, T const &amp; t)
  {
    ar.saveValue( t );
  }
  template&lt;class T&gt; inline
  typename std::enable_if&lt;std::is_arithmetic&lt;T&gt;::value, void&gt;::type
  load(JSONInputArchive &amp; ar, T &amp; t)
  {
    ar.loadValue( t );
  }
  template&lt;class CharT, class Traits, class Alloc&gt; inline
  void save(JSONOutputArchive &amp; ar, std::basic_string&lt;CharT, Traits, Alloc&gt; const &amp; str)
  {
    ar.saveValue( str );
  }
  template&lt;class CharT, class Traits, class Alloc&gt; inline
  void load(JSONInputArchive &amp; ar, std::basic_string&lt;CharT, Traits, Alloc&gt; &amp; str)
  {
    ar.loadValue( str );
  }</b></font>
  template &lt;class T&gt; inline
  void save( JSONOutputArchive &amp;, SizeTag&lt;T&gt; const &amp; )
  {
  }
  template &lt;class T&gt; inline
  void load( JSONInputArchive &amp; ar, SizeTag&lt;T&gt; &amp; st )
  {
    ar.loadSize( st.size );
  }
} 
CEREAL_REGISTER_ARCHIVE(cereal::JSONInputArchive)
CEREAL_REGISTER_ARCHIVE(cereal::JSONOutputArchive)
#endif </pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>xml.hpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#ifndef CEREAL_ARCHIVES_XML_HPP_
#define CEREAL_ARCHIVES_XML_HPP_
#include &lt;cereal/cereal.hpp&gt;
#include &lt;cereal/details/util.hpp&gt;
#include &lt;cereal/external/rapidxml/rapidxml.hpp&gt;
#include &lt;cereal/external/rapidxml/rapidxml_print.hpp&gt;
#include &lt;cereal/external/base64.hpp&gt;
#include &lt;sstream&gt;
#include &lt;stack&gt;
#include &lt;vector&gt;
#include &lt;limits&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;cmath&gt;
namespace cereal
{
  namespace xml_detail
  {
    #ifndef CEREAL_XML_STRING_VALUE
    #define CEREAL_XML_STRING_VALUE "cereal"
    #endif 
    static const char * CEREAL_XML_STRING = CEREAL_XML_STRING_VALUE;
  }
  class XMLOutputArchive : public OutputArchive&lt;XMLOutputArchive&gt;
  {
<font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    public:
      class Options
      {
        public:
          static Options Default(){ return Options(); }
          static Options NoIndent(){ return Options( std::numeric_limits&lt;double&gt;::max_digits10, false ); }</b></font>
          explicit Options( int precision = std::numeric_limits&lt;double&gt;::max_digits10,
                            bool indent = true,
                            bool outputType = false ) :
            itsPrecision( precision ),
            itsIndent( indent ),
            itsOutputType( outputType ) { }
        private:
          friend class XMLOutputArchive;
          int itsPrecision;
          bool itsIndent;
          bool itsOutputType;
      };
      XMLOutputArchive( std::ostream &amp; stream, Options const &amp; options = Options::Default() ) :
        OutputArchive&lt;XMLOutputArchive&gt;(this),
        itsStream(stream),
        itsOutputType( options.itsOutputType ),
        itsIndent( options.itsIndent )
      {
        auto node = itsXML.allocate_node( rapidxml::node_declaration );
        node-&gt;append_attribute( itsXML.allocate_attribute( "version", "1.0" ) );
        node-&gt;append_attribute( itsXML.allocate_attribute( "encoding", "utf-8" ) );
        itsXML.append_node( node );
        auto root = itsXML.allocate_node( rapidxml::node_element, xml_detail::CEREAL_XML_STRING );
        itsXML.append_node( root );
        itsNodes.emplace( root );
        itsStream &lt;&lt; std::boolalpha;
        itsStream.precision( options.itsPrecision );
        itsOS &lt;&lt; std::boolalpha;
        itsOS.precision( options.itsPrecision );
      }
      ~XMLOutputArchive()
      {
        const int flags = itsIndent ? 0x0 : rapidxml::print_no_indenting;
        rapidxml::print( itsStream, itsXML, flags );
        itsXML.clear();
      }
      void saveBinaryValue( const void * data, size_t size, const char * name = nullptr )
      {
        itsNodes.top().name = name;
        startNode();
        auto base64string = base64::encode( reinterpret_cast&lt;const unsigned char *&gt;( data ), size );
        saveValue( base64string );
        if( itsOutputType )
          itsNodes.top().node-&gt;append_attribute( itsXML.allocate_attribute( "type", "cereal binary data" ) );
        finishNode();
      };
      void startNode()
      {
        const auto nameString = itsNodes.top().getValueName();
        auto namePtr = itsXML.allocate_string( nameString.data(), nameString.size() );
        auto node = itsXML.allocate_node( rapidxml::node_element, namePtr, nullptr, nameString.size() );
        itsNodes.top().node-&gt;append_node( node );
        itsNodes.emplace( node );
      }
      void finishNode()
      {
        itsNodes.pop();
      }
      void setNextName( const char * name )
      {
        itsNodes.top().name = name;
      }
      template &lt;class T&gt; inline
      void saveValue( T const &amp; value )
      {
        itsOS.clear(); itsOS.seekp( 0, std::ios::beg );
        itsOS &lt;&lt; value &lt;&lt; std::ends;
        auto dataPtr = itsXML.allocate_string( itsOS.str().c_str() );
        itsNodes.top().node-&gt;append_node( itsXML.allocate_node( rapidxml::node_data, nullptr, dataPtr ) );
      }
      void saveValue( uint8_t const &amp; value )
      {
        saveValue( static_cast&lt;uint32_t&gt;( value ) );
      }
      void saveValue( int8_t const &amp; value )
      {
        saveValue( static_cast&lt;int32_t&gt;( value ) );
      }
      template &lt;class T&gt; inline
      void insertType()
      {
        if( !itsOutputType )
          return;
        const auto nameString = util::demangledName&lt;T&gt;();
        auto namePtr = itsXML.allocate_string( nameString.data(), nameString.size() );
        itsNodes.top().node-&gt;append_attribute( itsXML.allocate_attribute( "type", namePtr ) );
      }
      void appendAttribute( const char * name, const char * value )
      {
        auto namePtr =  itsXML.allocate_string( name );
        auto valuePtr = itsXML.allocate_string( value );
        itsNodes.top().node-&gt;append_attribute( itsXML.allocate_attribute( namePtr, valuePtr ) );
      }
    protected:
      struct NodeInfo
      {
        NodeInfo( rapidxml::xml_node&lt;&gt; * n = nullptr,
                  const char * nm = nullptr ) :
          node( n ),
          counter( 0 ),
          name( nm )
        { }
        rapidxml::xml_node&lt;&gt; * node; //!&lt; A pointer to this node
        size_t counter;              //!&lt; The counter for naming child nodes
        const char * name;           //!&lt; The name for the next child node
        std::string getValueName()
        {
          if( name )
          {
            auto n = name;
            name = nullptr;
            return {n};
          }
          else
            return "value" + std::to_string( counter++ ) + "\0";
        }
      }; 
    private:
      std::ostream &amp; itsStream;        //!&lt; The output stream
      rapidxml::xml_document&lt;&gt; itsXML; //!&lt; The XML document
      std::stack&lt;NodeInfo&gt; itsNodes;   //!&lt; A stack of nodes added to the document
      std::ostringstream itsOS;        //!&lt; Used to format strings internally
      bool itsOutputType;              //!&lt; Controls whether type information is printed
      bool itsIndent;                  //!&lt; Controls whether indenting is used
  }; 
  class XMLInputArchive : public InputArchive&lt;XMLInputArchive&gt;
  {
    public:
      XMLInputArchive( std::istream &amp; stream ) :
        InputArchive&lt;XMLInputArchive&gt;( this ),
        itsData( std::istreambuf_iterator&lt;char&gt;( stream ), std::istreambuf_iterator&lt;char&gt;() )
      {
        try
        {
          itsData.push_back('\0');           itsXML.parse&lt;rapidxml::parse_no_data_nodes | rapidxml::parse_declaration_node&gt;( reinterpret_cast&lt;char *&gt;( itsData.data() ) );
        }
        catch( rapidxml::parse_error const &amp; )
        {
          throw Exception("XML Parsing failed - likely due to invalid characters or invalid naming");
        }
        auto root = itsXML.first_node( xml_detail::CEREAL_XML_STRING );
        if( root == nullptr )
          throw Exception("Could not detect cereal root node - likely due to empty or invalid input");
        else
          itsNodes.emplace( root );
      }
      void loadBinaryValue( void * data, size_t size, const char * name = nullptr )
      {
        setNextName( name );
        startNode();
        std::string encoded;
        loadValue( encoded );
        auto decoded = base64::decode( encoded );
        if( size != decoded.size() )
          throw Exception("Decoded binary data size does not match specified size");
        std::memcpy( data, decoded.data(), decoded.size() );
        finishNode();
      };
      void startNode()
      {
        auto next = itsNodes.top().child;         auto const expectedName = itsNodes.top().name; 
        if( expectedName &amp;&amp; ( next == nullptr || std::strcmp( next-&gt;name(), expectedName ) != 0 ) )
        {
          next = itsNodes.top().search( expectedName );
          if( next == nullptr )
            throw Exception("XML Parsing failed - provided NVP not found");
<a name="3"></a>        }
        itsNodes.emplace( next );
<font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>      }
      void finishNode()
      {
        itsNodes.pop();
        itsNodes.top().advance();
        itsNodes.top().name = nullptr;
      }
      void setNextName( const char * name )
      {
        itsNodes.top().name = name;
      }
      template &lt;class T&gt; inline
      typename std::enable_if&lt;std::is_unsigned&lt;T&gt;::value &amp;&amp; std::is_same&lt;T, bool&gt;::value, void&gt;::type</b></font>
      loadValue( T &amp; value )
      {
        std::istringstream is( itsNodes.top().node-&gt;value() );
        is.setf( std::ios::boolalpha );
        is &gt;&gt; value;
      }
      template &lt;class T&gt; inline
      typename std::enable_if&lt;std::is_unsigned&lt;T&gt;::value &amp;&amp; !std::is_same&lt;T, bool&gt;::value &amp;&amp; sizeof(T) &lt; sizeof(long long), void&gt;::type
      loadValue( T &amp; value )
      {
        value = static_cast&lt;T&gt;( std::stoul( itsNodes.top().node-&gt;value() ) );
      }
      template &lt;class T&gt; inline
      typename std::enable_if&lt;std::is_unsigned&lt;T&gt;::value &amp;&amp; !std::is_same&lt;T, bool&gt;::value &amp;&amp; sizeof(T) &gt;= sizeof(long long), void&gt;::type
      loadValue( T &amp; value )
      {
        value = static_cast&lt;T&gt;( std::stoull( itsNodes.top().node-&gt;value() ) );
      }
      template &lt;class T&gt; inline
      typename std::enable_if&lt;std::is_signed&lt;T&gt;::value &amp;&amp; sizeof(T) &lt;= sizeof(int), void&gt;::type
      loadValue( T &amp; value )
      {
        value = static_cast&lt;T&gt;( std::stoi( itsNodes.top().node-&gt;value() ) );
      }
      template &lt;class T&gt; inline
      typename std::enable_if&lt;std::is_signed&lt;T&gt;::value &amp;&amp; (sizeof(T) &gt; sizeof(int)) &amp;&amp; (sizeof(T) &lt;= sizeof(long)), void&gt;::type
      loadValue( T &amp; value )
      {
        value = static_cast&lt;T&gt;( std::stol( itsNodes.top().node-&gt;value() ) );
      }
      template &lt;class T&gt; inline
      typename std::enable_if&lt;std::is_signed&lt;T&gt;::value &amp;&amp; (sizeof(T) &gt; sizeof(long)) &amp;&amp; (sizeof(T) &lt;= sizeof(long long)), void&gt;::type
      loadValue( T &amp; value )
      {
        value = static_cast&lt;T&gt;( std::stoll( itsNodes.top().node-&gt;value() ) );
      }
      void loadValue( float &amp; value )
      {
        try
        {
          value = std::stof( itsNodes.top().node-&gt;value() );
        }
        catch( std::out_of_range const &amp; )
        {
          std::istringstream is( itsNodes.top().node-&gt;value() );
          is &gt;&gt; value;
          if( std::fpclassify( value ) != FP_SUBNORMAL )
            throw;
        }
      }
      void loadValue( double &amp; value )
      {
        try
        {
          value = std::stod( itsNodes.top().node-&gt;value() );
        }
        catch( std::out_of_range const &amp; )
        {
          std::istringstream is( itsNodes.top().node-&gt;value() );
          is &gt;&gt; value;
          if( std::fpclassify( value ) != FP_SUBNORMAL )
            throw;
        }
      }
      void loadValue( long double &amp; value )
      {
        try
        {
          value = std::stold( itsNodes.top().node-&gt;value() );
        }
        catch( std::out_of_range const &amp; )
        {
          std::istringstream is( itsNodes.top().node-&gt;value() );
          is &gt;&gt; value;
          if( std::fpclassify( value ) != FP_SUBNORMAL )
            throw;
        }
      }
      template&lt;class CharT, class Traits, class Alloc&gt; inline
      void loadValue( std::basic_string&lt;CharT, Traits, Alloc&gt; &amp; str )
      {
        std::basic_istringstream&lt;CharT, Traits&gt; is( itsNodes.top().node-&gt;value() );
        str.assign( std::istreambuf_iterator&lt;CharT, Traits&gt;( is ),
                    std::istreambuf_iterator&lt;CharT, Traits&gt;() );
      }
      template &lt;class T&gt; inline
      void loadSize( T &amp; value )
      {
        value = getNumChildren( itsNodes.top().node );
      }
    protected:
      static size_t getNumChildren( rapidxml::xml_node&lt;&gt; * node )
      {
        size_t size = 0;
        node = node-&gt;first_node(); 
        while( node != nullptr )
        {
          ++size;
          node = node-&gt;next_sibling();
        }
        return size;
      }
      struct NodeInfo
      {
        NodeInfo( rapidxml::xml_node&lt;&gt; * n = nullptr ) :
          node( n ),
          child( n-&gt;first_node() ),
          size( XMLInputArchive::getNumChildren( n ) ),
          name( nullptr )
        { }
        void advance()
        {
          if( size &gt; 0 )
          {
            --size;
            child = child-&gt;next_sibling();
          }
        }
        rapidxml::xml_node&lt;&gt; * search( const char * searchName )
        {
          if( searchName )
          {
            size_t new_size = XMLInputArchive::getNumChildren( node );
            const size_t name_size = rapidxml::internal::measure( searchName );
            for( auto new_child = node-&gt;first_node(); new_child != nullptr; new_child = new_child-&gt;next_sibling() )
            {
              if( rapidxml::internal::compare( new_child-&gt;name(), new_child-&gt;name_size(), searchName, name_size, true ) )
              {
                size = new_size;
                child = new_child;
                return new_child;
              }
              --new_size;
            }
          }
          return nullptr;
        }
        rapidxml::xml_node&lt;&gt; * node;  //!&lt; A pointer to this node
        rapidxml::xml_node&lt;&gt; * child; //!&lt; A pointer to its current child
        size_t size;                  //!&lt; The remaining number of children for this node
        const char * name;            //!&lt; The NVP name for next next child node
      }; 
<a name="0"></a>      //! @}
    private:
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>      std::vector&lt;char&gt; itsData;       //!&lt; The raw data loaded
      rapidxml::xml_document&lt;&gt; itsXML; //!&lt; The XML document
      std::stack&lt;NodeInfo&gt; itsNodes;   //!&lt; A stack of nodes read from the document
  };
  template &lt;class T&gt; inline
  void prologue( XMLOutputArchive &amp;, NameValuePair&lt;T&gt; const &amp; )
  { }
  template &lt;class T&gt; inline
  void prologue( XMLInputArchive &amp;, NameValuePair&lt;T&gt; const &amp; )
  { }
  template &lt;class T&gt; inline
  void epilogue( XMLOutputArchive &amp;, NameValuePair&lt;T&gt; const &amp; )
  { }
  template &lt;class T&gt; inline
  void epilogue( XMLInputArchive &amp;, NameValuePair&lt;T&gt; const &amp; )
  { }
  template &lt;class T&gt; inline
  void prologue( XMLOutputArchive &amp; ar, SizeTag&lt;T&gt; const &amp; )
  {
    ar.appendAttribute( "size", "dynamic" );
  }
  template &lt;class T&gt; inline
  void prologue( XMLInputArchive &amp;, SizeTag&lt;T&gt; const &amp; )
  { }
  template &lt;class T&gt; inline
  void epilogue( XMLOutputArchive &amp;, SizeTag&lt;T&gt; const &amp; )
  { }
  template &lt;class T&gt; inline
  void epilogue( XMLInputArchive &amp;, SizeTag&lt;T&gt; const &amp; )
  { }
  template &lt;class T&gt; inline
  typename std::enable_if&lt;!traits::has_minimal_output_serialization&lt;T, XMLOutputArchive&gt;::value, void&gt;::type</b></font><font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>
  prologue( XMLOutputArchive &amp; ar, T const &amp; )
  {
    ar.startNode();
    ar.insertType&lt;T&gt;();
  }
  template &lt;class T&gt; inline
  typename std::enable_if&lt;!traits::has_minimal_input_serialization&lt;T, XMLInputArchive&gt;::value, void&gt;::type
  prologue( XMLInputArchive &amp; ar, T const &amp; )
  {
    ar.startNode();
  }
  template &lt;class T&gt; inline
  typename std::enable_if&lt;!traits::has_minimal_output_serialization&lt;T, XMLOutputArchive&gt;::value, void&gt;::type
  epilogue( XMLOutputArchive &amp; ar, T const &amp; )
  {
    ar.finishNode();
  }
  template &lt;class T&gt; inline
  typename std::enable_if&lt;!traits::has_minimal_input_serialization&lt;T, XMLInputArchive&gt;::value, void&gt;::type
  epilogue( XMLInputArchive &amp; ar, T const &amp; )
  {
    ar.finishNode();
  }
  template &lt;class T&gt; inline</b></font>
  void save( XMLOutputArchive &amp; ar, NameValuePair&lt;T&gt; const &amp; t )
  {
    ar.setNextName( t.name );
    ar( t.value );
  }
<a name="1"></a>  //! Loading NVP types from XML
  template &lt;class T&gt; inline
  void load( XMLInputArchive &amp; ar, NameValuePair&lt;T&gt; &amp; t )
<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  {
    ar.setNextName( t.name );
    ar( t.value );
  }
  template &lt;class T&gt; inline
  void save( XMLOutputArchive &amp;, SizeTag&lt;T&gt; const &amp; )
  { }
  template &lt;class T&gt; inline
  void load( XMLInputArchive &amp; ar, SizeTag&lt;T&gt; &amp; st )
  {
    ar.loadSize( st.size );
  }
  template&lt;class T&gt; inline
  typename std::enable_if&lt;std::is_arithmetic&lt;T&gt;::value, void&gt;::type
  save(XMLOutputArchive &amp; ar, T const &amp; t)
  {
    ar.saveValue( t );
  }
  template&lt;class T&gt; inline
  typename std::enable_if&lt;std::is_arithmetic&lt;T&gt;::value, void&gt;::type
  load(XMLInputArchive &amp; ar, T &amp; t)
  {
    ar.loadValue( t );
  }
  template&lt;class CharT, class Traits, class Alloc&gt; inline
  void save(XMLOutputArchive &amp; ar, std::basic_string&lt;CharT, Traits, Alloc&gt; const &amp; str)
  {
    ar.saveValue( str );
  }
  template&lt;class CharT, class Traits, class Alloc&gt; inline
  void load(XMLInputArchive &amp; ar, std::basic_string&lt;CharT, Traits, Alloc&gt; &amp; str)
  {
    ar.loadValue( str );
  }</b></font>
} 
CEREAL_REGISTER_ARCHIVE(cereal::XMLOutputArchive)
CEREAL_REGISTER_ARCHIVE(cereal::XMLInputArchive)
#endif </pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
