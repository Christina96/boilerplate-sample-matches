<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for json.hpp &amp; xml.hpp</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for json.hpp &amp; xml.hpp
      </h3>
<h1 align="center">
        25.3%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>json.hpp (22.53194%)<th>xml.hpp (29.085457%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(640-709)<td><a href="#" name="0">(662-725)</a><td align="center"><font color="#ff0000">66</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(797-846)<td><a href="#" name="1">(775-823)</a><td align="center"><font color="#d40000">55</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(741-770)<td><a href="#" name="2">(725-765)</a><td align="center"><font color="#9e0000">41</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(556-573)<td><a href="#" name="3">(449-472)</a><td align="center"><font color="#410000">17</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(95-108)<td><a href="#" name="4">(92-105)</a><td align="center"><font color="#390000">15</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>json.hpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifndef CEREAL_ARCHIVES_JSON_HPP_
2 #define CEREAL_ARCHIVES_JSON_HPP_
3 #include &lt;cereal/cereal.hpp&gt;
4 #include &lt;cereal/details/util.hpp&gt;
5 namespace cereal
6 {
7   struct RapidJSONException : Exception
8   { RapidJSONException( const char * what_ ) : Exception( what_ ) {} };
9 }
10 #ifndef RAPIDJSON_ASSERT
11 #define RAPIDJSON_ASSERT(x) if(!(x)){ \
12   throw ::cereal::RapidJSONException("rapidjson internal assertion failure: " #x); }
13 #endif 
14 #include &lt;cereal/external/rapidjson/prettywriter.h&gt;
15 #include &lt;cereal/external/rapidjson/genericstream.h&gt;
16 #include &lt;cereal/external/rapidjson/reader.h&gt;
17 #include &lt;cereal/external/rapidjson/document.h&gt;
18 #include &lt;cereal/external/base64.hpp&gt;
19 #include &lt;limits&gt;
20 #include &lt;sstream&gt;
21 #include &lt;stack&gt;
22 #include &lt;vector&gt;
23 #include &lt;string&gt;
24 namespace cereal
25 {
26   class JSONOutputArchive : public OutputArchive&lt;JSONOutputArchive&gt;
27   {
28     enum class NodeType { StartObject, InObject, StartArray, InArray };
29 <a name="4"></a>    typedef rapidjson::GenericWriteStream WriteStream;
30     typedef rapidjson::PrettyWriter&lt;WriteStream&gt; JSONWriter;
31 <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    public:
32       class Options
33       {
34         public:
35           static Options Default(){ return Options(); }
36           static Options NoIndent(){ return Options( std::numeric_limits&lt;double&gt;::max_digits10, IndentChar::space, 0 ); }</b></font>
37           enum class IndentChar : char
38           {
39             space = ' ',
40             tab = '\t',
41             newline = '\n',
42             carriage_return = '\r'
43           };
44           explicit Options( int precision = std::numeric_limits&lt;double&gt;::max_digits10,
45                             IndentChar indentChar = IndentChar::space,
46                             unsigned int indentLength = 4 ) :
47             itsPrecision( precision ),
48             itsIndentChar( static_cast&lt;char&gt;(indentChar) ),
49             itsIndentLength( indentLength ) { }
50         private:
51           friend class JSONOutputArchive;
52           int itsPrecision;
53           char itsIndentChar;
54           unsigned int itsIndentLength;
55       };
56       JSONOutputArchive(std::ostream &amp; stream, Options const &amp; options = Options::Default() ) :
57         OutputArchive&lt;JSONOutputArchive&gt;(this),
58         itsWriteStream(stream),
59         itsWriter(itsWriteStream, options.itsPrecision),
60         itsNextName(nullptr)
61       {
62         itsWriter.SetIndent( options.itsIndentChar, options.itsIndentLength );
63         itsNameCounter.push(0);
64         itsNodeStack.push(NodeType::StartObject);
65       }
66       ~JSONOutputArchive()
67       {
68         itsWriter.EndObject();
69       }
70       void saveBinaryValue( const void * data, size_t size, const char * name = nullptr )
71       {
72         setNextName( name );
73         writeName();
74         auto base64string = base64::encode( reinterpret_cast&lt;const unsigned char *&gt;( data ), size );
75         saveValue( base64string );
76       };
77       void startNode()
78       {
79         writeName();
80         itsNodeStack.push(NodeType::StartObject);
81         itsNameCounter.push(0);
82       }
83       void finishNode()
84       {
85         switch(itsNodeStack.top())
86         {
87           case NodeType::StartArray:
88             itsWriter.StartArray();
89           case NodeType::InArray:
90             itsWriter.EndArray();
91             break;
92           case NodeType::StartObject:
93             itsWriter.StartObject();
94           case NodeType::InObject:
95             itsWriter.EndObject();
96             break;
97         }
98         itsNodeStack.pop();
99         itsNameCounter.pop();
100       }
101       void setNextName( const char * name )
102       {
103         itsNextName = name;
104       }
105       void saveValue(bool b)                { itsWriter.Bool_(b);                                                         }
106       void saveValue(int i)                 { itsWriter.Int(i);                                                          }
107       void saveValue(unsigned u)            { itsWriter.Uint(u);                                                         }
108       void saveValue(int64_t i64)           { itsWriter.Int64(i64);                                                      }
109       void saveValue(uint64_t u64)          { itsWriter.Uint64(u64);                                                     }
110       void saveValue(double d)              { itsWriter.Double(d);                                                       }
111       void saveValue(std::string const &amp; s) { itsWriter.String(s.c_str(), static_cast&lt;rapidjson::SizeType&gt;( s.size() )); }
112       void saveValue(char const * s)        { itsWriter.String(s);                                                       }
113     private:
114       template &lt;class T&gt; inline
115       typename std::enable_if&lt;sizeof(T) == sizeof(std::int32_t) &amp;&amp; std::is_signed&lt;T&gt;::value, void&gt;::type
116       saveLong(T l){ saveValue( static_cast&lt;std::int32_t&gt;( l ) ); }
117       template &lt;class T&gt; inline
118       typename std::enable_if&lt;sizeof(T) != sizeof(std::int32_t) &amp;&amp; std::is_signed&lt;T&gt;::value, void&gt;::type
119       saveLong(T l){ saveValue( static_cast&lt;std::int64_t&gt;( l ) ); }
120       template &lt;class T&gt; inline
121       typename std::enable_if&lt;sizeof(T) == sizeof(std::uint32_t) &amp;&amp; !std::is_signed&lt;T&gt;::value, void&gt;::type
122       saveLong(T lu){ saveValue( static_cast&lt;std::uint32_t&gt;( lu ) ); }
123       template &lt;class T&gt; inline
124       typename std::enable_if&lt;sizeof(T) != sizeof(std::uint32_t) &amp;&amp; !std::is_signed&lt;T&gt;::value, void&gt;::type
125       saveLong(T lu){ saveValue( static_cast&lt;std::uint64_t&gt;( lu ) ); }
126     public:
127 #ifdef _MSC_VER
128       void saveValue( unsigned long lu ){ saveLong( lu ); };
129 #else       template &lt;class T&gt; inline
130       typename std::enable_if&lt;std::is_same&lt;T, long&gt;::value &amp;&amp;
131                               !std::is_same&lt;T, std::int32_t&gt;::value &amp;&amp;
132                               !std::is_same&lt;T, std::int64_t&gt;::value, void&gt;::type
133       saveValue( T t ){ saveLong( t ); }
134       template &lt;class T&gt; inline
135       typename std::enable_if&lt;std::is_same&lt;T, unsigned long&gt;::value &amp;&amp;
136                               !std::is_same&lt;T, std::uint32_t&gt;::value &amp;&amp;
137                               !std::is_same&lt;T, std::uint64_t&gt;::value, void&gt;::type
138       saveValue( T t ){ saveLong( t ); }
139 #endif 
140       template&lt;class T&gt; inline
141       typename std::enable_if&lt;std::is_arithmetic&lt;T&gt;::value &amp;&amp;
142                               !std::is_same&lt;T, long&gt;::value &amp;&amp;
143                               !std::is_same&lt;T, unsigned long&gt;::value &amp;&amp;
144                               !std::is_same&lt;T, std::int64_t&gt;::value &amp;&amp;
145                               !std::is_same&lt;T, std::uint64_t&gt;::value &amp;&amp;
146                               (sizeof(T) &gt;= sizeof(long double) || sizeof(T) &gt;= sizeof(long long)), void&gt;::type
147       saveValue(T const &amp; t)
148       {
149         std::stringstream ss; ss.precision( std::numeric_limits&lt;long double&gt;::max_digits10 );
150         ss &lt;&lt; t;
151         saveValue( ss.str() );
152       }
153       void writeName()
154       {
155         NodeType const &amp; nodeType = itsNodeStack.top();
156         if(nodeType == NodeType::StartArray)
157         {
158           itsWriter.StartArray();
159           itsNodeStack.top() = NodeType::InArray;
160         }
161         else if(nodeType == NodeType::StartObject)
162         {
163           itsNodeStack.top() = NodeType::InObject;
164           itsWriter.StartObject();
165         }
166         if(nodeType == NodeType::InArray) return;
167         if(itsNextName == nullptr)
168         {
169           std::string name = "value" + std::to_string( itsNameCounter.top()++ ) + "\0";
170           saveValue(name);
171         }
172         else
173         {
174           saveValue(itsNextName);
175           itsNextName = nullptr;
176         }
177       }
178       void makeArray()
179       {
180         itsNodeStack.top() = NodeType::StartArray;
181       }
182     private:
183       WriteStream itsWriteStream;          //!&lt; Rapidjson write stream
184       JSONWriter itsWriter;                //!&lt; Rapidjson writer
185       char const * itsNextName;            //!&lt; The next name
186       std::stack&lt;uint32_t&gt; itsNameCounter; //!&lt; Counter for creating unique names for unnamed nodes
187       std::stack&lt;NodeType&gt; itsNodeStack;
188   }; 
189   class JSONInputArchive : public InputArchive&lt;JSONInputArchive&gt;
190   {
191     private:
192       typedef rapidjson::GenericReadStream ReadStream;
193       typedef rapidjson::GenericValue&lt;rapidjson::UTF8&lt;&gt;&gt; JSONValue;
194       typedef JSONValue::ConstMemberIterator MemberIterator;
195       typedef JSONValue::ConstValueIterator ValueIterator;
196       typedef rapidjson::Document::GenericValue GenericValue;
197     public:
198       JSONInputArchive(std::istream &amp; stream) :
199         InputArchive&lt;JSONInputArchive&gt;(this),
200         itsNextName( nullptr ),
201         itsReadStream(stream)
202       {
203         itsDocument.ParseStream&lt;0&gt;(itsReadStream);
204         itsIteratorStack.emplace_back(itsDocument.MemberBegin(), itsDocument.MemberEnd());
205       }
206       void loadBinaryValue( void * data, size_t size, const char * name = nullptr )
207       {
208         itsNextName = name;
209         std::string encoded;
210         loadValue( encoded );
211         auto decoded = base64::decode( encoded );
212         if( size != decoded.size() )
213           throw Exception("Decoded binary data size does not match specified size");
214         std::memcpy( data, decoded.data(), decoded.size() );
215         itsNextName = nullptr;
216       };
217     private:
218       class Iterator
219       {
220         public:
221           Iterator() : itsIndex( 0 ), itsType(Null_) {}
222           Iterator(MemberIterator begin, MemberIterator end) :
223             itsMemberItBegin(begin), itsMemberItEnd(end), itsIndex(0), itsType(Member)
224           { }
225           Iterator(ValueIterator begin, ValueIterator end) :
226             itsValueItBegin(begin), itsValueItEnd(end), itsIndex(0), itsType(Value)
227           { }
228           Iterator &amp; operator++()
229           {
230             ++itsIndex;
231             return *this;
232           }
233           GenericValue const &amp; value()
234           {
235             switch(itsType)
236             {
237               case Value : return itsValueItBegin[itsIndex];
238               case Member: return itsMemberItBegin[itsIndex].value;
239               default: throw cereal::Exception("Invalid Iterator Type!");
240             }
241           }
242           const char * name() const
243           {
244             if( itsType == Member &amp;&amp; (itsMemberItBegin + itsIndex) != itsMemberItEnd )
245               return itsMemberItBegin[itsIndex].name.GetString();
246             else
247               return nullptr;
248           }
249           inline void search( const char * searchName )
250           {
251             const auto len = std::strlen( searchName );
252             size_t index = 0;
253             for( auto it = itsMemberItBegin; it != itsMemberItEnd; ++it, ++index )
254               if( std::strncmp( searchName, it-&gt;name.GetString(), len ) == 0 )
255               {
256                 itsIndex = index;
257                 return;
258               }
259             throw Exception("JSON Parsing failed - provided NVP not found");
260           }
261         private:
262           MemberIterator itsMemberItBegin, itsMemberItEnd; //!&lt; The member iterator (object)
263           ValueIterator itsValueItBegin, itsValueItEnd;    //!&lt; The value iterator (array)
264           size_t itsIndex;                                 //!&lt; The current index of this iterator
265           enum Type {Value, Member, Null_} itsType;    //!&lt; Whether this holds values (array) or members (objects) or nothing
266       };
267       inline void search()
268       {
269         if( itsNextName )
270         {
271           auto const actualName = itsIteratorStack.back().name();
272           if( !actualName || std::strcmp( itsNextName, actualName ) != 0 )
273             itsIteratorStack.back().search( itsNextName );
274         }
275         itsNextName = nullptr;
276       }
277     public:
278       void startNode()
279       {
280         search();
281         if(itsIteratorStack.back().value().IsArray())
282 <a name="3"></a>          itsIteratorStack.emplace_back(itsIteratorStack.back().value().Begin(), itsIteratorStack.back().value().End());
283         else
284           itsIteratorStack.emplace_back(itsIteratorStack.back().value().MemberBegin(), itsIteratorStack.back().value().MemberEnd());
285 <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>      }
286       void finishNode()
287       {
288         itsIteratorStack.pop_back();
289         ++itsIteratorStack.back();
290       }
291       void setNextName( const char * name )
292       {
293         itsNextName = name;
294       }
295       template&lt;class T&gt; inline
296       typename std::enable_if&lt;std::is_signed&lt;T&gt;::value &amp;&amp; sizeof(T) &lt; sizeof(int64_t), void&gt;::type</b></font>
297       loadValue(T &amp; val)
298       {
299         search();
300         val = itsIteratorStack.back().value().GetInt();
301         ++itsIteratorStack.back();
302       }
303       template&lt;class T&gt; inline
304       typename std::enable_if&lt;(std::is_unsigned&lt;T&gt;::value &amp;&amp; sizeof(T) &lt; sizeof(uint64_t)) &amp;&amp;
305                               !std::is_same&lt;bool, T&gt;::value, void&gt;::type
306       loadValue(T &amp; val)
307       {
308         search();
309         val = itsIteratorStack.back().value().GetUint();
310         ++itsIteratorStack.back();
311       }
312       void loadValue(bool &amp; val)        { search(); val = itsIteratorStack.back().value().GetBool_();   ++itsIteratorStack.back(); }
313       void loadValue(int64_t &amp; val)     { search(); val = itsIteratorStack.back().value().GetInt64();  ++itsIteratorStack.back(); }
314       void loadValue(uint64_t &amp; val)    { search(); val = itsIteratorStack.back().value().GetUint64(); ++itsIteratorStack.back(); }
315       void loadValue(float &amp; val)       { search(); val = static_cast&lt;float&gt;(itsIteratorStack.back().value().GetDouble()); ++itsIteratorStack.back(); }
316       void loadValue(double &amp; val)      { search(); val = itsIteratorStack.back().value().GetDouble(); ++itsIteratorStack.back(); }
317       void loadValue(std::string &amp; val) { search(); val = itsIteratorStack.back().value().GetString(); ++itsIteratorStack.back(); }
318     private:
319       void stringToNumber( std::string const &amp; str, long long &amp; val ) { val = std::stoll( str ); }
320       void stringToNumber( std::string const &amp; str, unsigned long long &amp; val ) { val = std::stoull( str ); }
321       void stringToNumber( std::string const &amp; str, long double &amp; val ) { val = std::stold( str ); }
322     public:
323       template&lt;class T&gt; inline
324       typename std::enable_if&lt;std::is_arithmetic&lt;T&gt;::value &amp;&amp;
325                               !std::is_same&lt;T, long&gt;::value &amp;&amp;
326                               !std::is_same&lt;T, unsigned long&gt;::value &amp;&amp;
327                               !std::is_same&lt;T, std::int64_t&gt;::value &amp;&amp;
328                               !std::is_same&lt;T, std::uint64_t&gt;::value &amp;&amp;
329                               (sizeof(T) &gt;= sizeof(long double) || sizeof(T) &gt;= sizeof(long long)), void&gt;::type
330       loadValue(T &amp; val)
331       {
332         std::string encoded;
333         loadValue( encoded );
334         stringToNumber( encoded, val );
335       }
336       void loadSize(size_type &amp; size)
337       {
338         size = (itsIteratorStack.rbegin() + 1)-&gt;value().Size();
339       }
340 <a name="0"></a>      //! @}
341     private:
342 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>      const char * itsNextName;               //!&lt; Next name set by NVP
343       ReadStream itsReadStream;               //!&lt; Rapidjson write stream
344       std::vector&lt;Iterator&gt; itsIteratorStack; //!&lt; 'Stack' of rapidJSON iterators
345       rapidjson::Document itsDocument;        //!&lt; Rapidjson document
346   };
347   template &lt;class T&gt; inline
348   void prologue( JSONOutputArchive &amp;, NameValuePair&lt;T&gt; const &amp; )
349   { }
350   template &lt;class T&gt; inline
351   void prologue( JSONInputArchive &amp;, NameValuePair&lt;T&gt; const &amp; )
352   { }
353   template &lt;class T&gt; inline
354   void epilogue( JSONOutputArchive &amp;, NameValuePair&lt;T&gt; const &amp; )
355   { }
356   template &lt;class T&gt; inline
357   void epilogue( JSONInputArchive &amp;, NameValuePair&lt;T&gt; const &amp; )
358   { }
359   template &lt;class T&gt; inline
360   void prologue( JSONOutputArchive &amp; ar, SizeTag&lt;T&gt; const &amp; )
361   {
362     ar.makeArray();
363   }
364   template &lt;class T&gt; inline
365   void prologue( JSONInputArchive &amp;, SizeTag&lt;T&gt; const &amp; )
366   { }
367   template &lt;class T&gt; inline
368   void epilogue( JSONOutputArchive &amp;, SizeTag&lt;T&gt; const &amp; )
369   { }
370   template &lt;class T&gt; inline
371   void epilogue( JSONInputArchive &amp;, SizeTag&lt;T&gt; const &amp; )
372   { }
373   template &lt;class T&gt; inline
374   typename std::enable_if&lt;!std::is_arithmetic&lt;T&gt;::value &amp;&amp;</b></font>
375                           !traits::has_minimal_output_serialization&lt;T, JSONOutputArchive&gt;::value, void&gt;::type
376   prologue( JSONOutputArchive &amp; ar, T const &amp; )
377   {
378     ar.startNode();
379   }
380   template &lt;class T&gt; inline
381   typename std::enable_if&lt;!std::is_arithmetic&lt;T&gt;::value &amp;&amp;
382                           !traits::has_minimal_input_serialization&lt;T, JSONOutputArchive&gt;::value, void&gt;::type
383   prologue( JSONInputArchive &amp; ar, T const &amp; )
384   {
385     ar.startNode();
386   }
387   template &lt;class T&gt; inline
388   typename std::enable_if&lt;!std::is_arithmetic&lt;T&gt;::value &amp;&amp;
389                           !traits::has_minimal_output_serialization&lt;T, JSONOutputArchive&gt;::value, void&gt;::type
390   epilogue( JSONOutputArchive &amp; ar, T const &amp; )
391   {
392     ar.finishNode();
393   }
394 <a name="2"></a>  //! Epilogue for all other types other for JSON archives
395   template &lt;class T&gt; inline
396   typename std::enable_if&lt;!std::is_arithmetic&lt;T&gt;::value &amp;&amp;
397 <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>                          !traits::has_minimal_input_serialization&lt;T, JSONOutputArchive&gt;::value, void&gt;::type
398   epilogue( JSONInputArchive &amp; ar, T const &amp; )
399   {
400     ar.finishNode();
401   }
402   template &lt;class T&gt; inline
403   typename std::enable_if&lt;std::is_arithmetic&lt;T&gt;::value, void&gt;::type
404   prologue( JSONOutputArchive &amp; ar, T const &amp; )
405   {
406     ar.writeName();
407   }
408   template &lt;class T&gt; inline
409   typename std::enable_if&lt;std::is_arithmetic&lt;T&gt;::value, void&gt;::type
410   prologue( JSONInputArchive &amp;, T const &amp; )
411   { }
412   template &lt;class T&gt; inline
413   typename std::enable_if&lt;std::is_arithmetic&lt;T&gt;::value, void&gt;::type
414   epilogue( JSONOutputArchive &amp;, T const &amp; )
415   { }
416   template &lt;class T&gt; inline</b></font>
417   typename std::enable_if&lt;std::is_arithmetic&lt;T&gt;::value, void&gt;::type
418   epilogue( JSONInputArchive &amp;, T const &amp; )
419   { }
420   template&lt;class CharT, class Traits, class Alloc&gt; inline
421   void prologue(JSONOutputArchive &amp; ar, std::basic_string&lt;CharT, Traits, Alloc&gt; const &amp;)
422   {
423     ar.writeName();
424   }
425   template&lt;class CharT, class Traits, class Alloc&gt; inline
426   void prologue(JSONInputArchive &amp;, std::basic_string&lt;CharT, Traits, Alloc&gt; const &amp;)
427   { }
428   template&lt;class CharT, class Traits, class Alloc&gt; inline
429   void epilogue(JSONOutputArchive &amp;, std::basic_string&lt;CharT, Traits, Alloc&gt; const &amp;)
430   { }
431 <a name="1"></a>  //! Epilogue for strings for JSON archives
432   template&lt;class CharT, class Traits, class Alloc&gt; inline
433   void epilogue(JSONInputArchive &amp;, std::basic_string&lt;CharT, Traits, Alloc&gt; const &amp;)
434 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  { }
435   template &lt;class T&gt; inline
436   void save( JSONOutputArchive &amp; ar, NameValuePair&lt;T&gt; const &amp; t )
437   {
438     ar.setNextName( t.name );
439     ar( t.value );
440   }
441   template &lt;class T&gt; inline
442   void load( JSONInputArchive &amp; ar, NameValuePair&lt;T&gt; &amp; t )
443   {
444     ar.setNextName( t.name );
445     ar( t.value );
446   }
447   template&lt;class T&gt; inline
448   typename std::enable_if&lt;std::is_arithmetic&lt;T&gt;::value, void&gt;::type
449   save(JSONOutputArchive &amp; ar, T const &amp; t)
450   {
451     ar.saveValue( t );
452   }
453   template&lt;class T&gt; inline
454   typename std::enable_if&lt;std::is_arithmetic&lt;T&gt;::value, void&gt;::type
455   load(JSONInputArchive &amp; ar, T &amp; t)
456   {
457     ar.loadValue( t );
458   }
459   template&lt;class CharT, class Traits, class Alloc&gt; inline
460   void save(JSONOutputArchive &amp; ar, std::basic_string&lt;CharT, Traits, Alloc&gt; const &amp; str)
461   {
462     ar.saveValue( str );
463   }
464   template&lt;class CharT, class Traits, class Alloc&gt; inline
465   void load(JSONInputArchive &amp; ar, std::basic_string&lt;CharT, Traits, Alloc&gt; &amp; str)
466   {
467     ar.loadValue( str );
468   }</b></font>
469   template &lt;class T&gt; inline
470   void save( JSONOutputArchive &amp;, SizeTag&lt;T&gt; const &amp; )
471   {
472   }
473   template &lt;class T&gt; inline
474   void load( JSONInputArchive &amp; ar, SizeTag&lt;T&gt; &amp; st )
475   {
476     ar.loadSize( st.size );
477   }
478 } 
479 CEREAL_REGISTER_ARCHIVE(cereal::JSONInputArchive)
480 CEREAL_REGISTER_ARCHIVE(cereal::JSONOutputArchive)
#endif </pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>xml.hpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifndef CEREAL_ARCHIVES_XML_HPP_
2 #define CEREAL_ARCHIVES_XML_HPP_
3 #include &lt;cereal/cereal.hpp&gt;
4 #include &lt;cereal/details/util.hpp&gt;
5 #include &lt;cereal/external/rapidxml/rapidxml.hpp&gt;
6 #include &lt;cereal/external/rapidxml/rapidxml_print.hpp&gt;
7 #include &lt;cereal/external/base64.hpp&gt;
8 #include &lt;sstream&gt;
9 #include &lt;stack&gt;
10 #include &lt;vector&gt;
11 #include &lt;limits&gt;
12 #include &lt;string&gt;
13 #include &lt;cstring&gt;
14 #include &lt;cmath&gt;
15 namespace cereal
16 {
17   namespace xml_detail
18   {
19     #ifndef CEREAL_XML_STRING_VALUE
20     #define CEREAL_XML_STRING_VALUE "cereal"
21     #endif 
22     static const char * CEREAL_XML_STRING = CEREAL_XML_STRING_VALUE;
23   }
24   class XMLOutputArchive : public OutputArchive&lt;XMLOutputArchive&gt;
25   {
26 <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    public:
27       class Options
28       {
29         public:
30           static Options Default(){ return Options(); }
31           static Options NoIndent(){ return Options( std::numeric_limits&lt;double&gt;::max_digits10, false ); }</b></font>
32           explicit Options( int precision = std::numeric_limits&lt;double&gt;::max_digits10,
33                             bool indent = true,
34                             bool outputType = false ) :
35             itsPrecision( precision ),
36             itsIndent( indent ),
37             itsOutputType( outputType ) { }
38         private:
39           friend class XMLOutputArchive;
40           int itsPrecision;
41           bool itsIndent;
42           bool itsOutputType;
43       };
44       XMLOutputArchive( std::ostream &amp; stream, Options const &amp; options = Options::Default() ) :
45         OutputArchive&lt;XMLOutputArchive&gt;(this),
46         itsStream(stream),
47         itsOutputType( options.itsOutputType ),
48         itsIndent( options.itsIndent )
49       {
50         auto node = itsXML.allocate_node( rapidxml::node_declaration );
51         node-&gt;append_attribute( itsXML.allocate_attribute( "version", "1.0" ) );
52         node-&gt;append_attribute( itsXML.allocate_attribute( "encoding", "utf-8" ) );
53         itsXML.append_node( node );
54         auto root = itsXML.allocate_node( rapidxml::node_element, xml_detail::CEREAL_XML_STRING );
55         itsXML.append_node( root );
56         itsNodes.emplace( root );
57         itsStream &lt;&lt; std::boolalpha;
58         itsStream.precision( options.itsPrecision );
59         itsOS &lt;&lt; std::boolalpha;
60         itsOS.precision( options.itsPrecision );
61       }
62       ~XMLOutputArchive()
63       {
64         const int flags = itsIndent ? 0x0 : rapidxml::print_no_indenting;
65         rapidxml::print( itsStream, itsXML, flags );
66         itsXML.clear();
67       }
68       void saveBinaryValue( const void * data, size_t size, const char * name = nullptr )
69       {
70         itsNodes.top().name = name;
71         startNode();
72         auto base64string = base64::encode( reinterpret_cast&lt;const unsigned char *&gt;( data ), size );
73         saveValue( base64string );
74         if( itsOutputType )
75           itsNodes.top().node-&gt;append_attribute( itsXML.allocate_attribute( "type", "cereal binary data" ) );
76         finishNode();
77       };
78       void startNode()
79       {
80         const auto nameString = itsNodes.top().getValueName();
81         auto namePtr = itsXML.allocate_string( nameString.data(), nameString.size() );
82         auto node = itsXML.allocate_node( rapidxml::node_element, namePtr, nullptr, nameString.size() );
83         itsNodes.top().node-&gt;append_node( node );
84         itsNodes.emplace( node );
85       }
86       void finishNode()
87       {
88         itsNodes.pop();
89       }
90       void setNextName( const char * name )
91       {
92         itsNodes.top().name = name;
93       }
94       template &lt;class T&gt; inline
95       void saveValue( T const &amp; value )
96       {
97         itsOS.clear(); itsOS.seekp( 0, std::ios::beg );
98         itsOS &lt;&lt; value &lt;&lt; std::ends;
99         auto dataPtr = itsXML.allocate_string( itsOS.str().c_str() );
100         itsNodes.top().node-&gt;append_node( itsXML.allocate_node( rapidxml::node_data, nullptr, dataPtr ) );
101       }
102       void saveValue( uint8_t const &amp; value )
103       {
104         saveValue( static_cast&lt;uint32_t&gt;( value ) );
105       }
106       void saveValue( int8_t const &amp; value )
107       {
108         saveValue( static_cast&lt;int32_t&gt;( value ) );
109       }
110       template &lt;class T&gt; inline
111       void insertType()
112       {
113         if( !itsOutputType )
114           return;
115         const auto nameString = util::demangledName&lt;T&gt;();
116         auto namePtr = itsXML.allocate_string( nameString.data(), nameString.size() );
117         itsNodes.top().node-&gt;append_attribute( itsXML.allocate_attribute( "type", namePtr ) );
118       }
119       void appendAttribute( const char * name, const char * value )
120       {
121         auto namePtr =  itsXML.allocate_string( name );
122         auto valuePtr = itsXML.allocate_string( value );
123         itsNodes.top().node-&gt;append_attribute( itsXML.allocate_attribute( namePtr, valuePtr ) );
124       }
125     protected:
126       struct NodeInfo
127       {
128         NodeInfo( rapidxml::xml_node&lt;&gt; * n = nullptr,
129                   const char * nm = nullptr ) :
130           node( n ),
131           counter( 0 ),
132           name( nm )
133         { }
134         rapidxml::xml_node&lt;&gt; * node; //!&lt; A pointer to this node
135         size_t counter;              //!&lt; The counter for naming child nodes
136         const char * name;           //!&lt; The name for the next child node
137         std::string getValueName()
138         {
139           if( name )
140           {
141             auto n = name;
142             name = nullptr;
143             return {n};
144           }
145           else
146             return "value" + std::to_string( counter++ ) + "\0";
147         }
148       }; 
149     private:
150       std::ostream &amp; itsStream;        //!&lt; The output stream
151       rapidxml::xml_document&lt;&gt; itsXML; //!&lt; The XML document
152       std::stack&lt;NodeInfo&gt; itsNodes;   //!&lt; A stack of nodes added to the document
153       std::ostringstream itsOS;        //!&lt; Used to format strings internally
154       bool itsOutputType;              //!&lt; Controls whether type information is printed
155       bool itsIndent;                  //!&lt; Controls whether indenting is used
156   }; 
157   class XMLInputArchive : public InputArchive&lt;XMLInputArchive&gt;
158   {
159     public:
160       XMLInputArchive( std::istream &amp; stream ) :
161         InputArchive&lt;XMLInputArchive&gt;( this ),
162         itsData( std::istreambuf_iterator&lt;char&gt;( stream ), std::istreambuf_iterator&lt;char&gt;() )
163       {
164         try
165         {
166           itsData.push_back('\0');           itsXML.parse&lt;rapidxml::parse_no_data_nodes | rapidxml::parse_declaration_node&gt;( reinterpret_cast&lt;char *&gt;( itsData.data() ) );
167         }
168         catch( rapidxml::parse_error const &amp; )
169         {
170           throw Exception("XML Parsing failed - likely due to invalid characters or invalid naming");
171         }
172         auto root = itsXML.first_node( xml_detail::CEREAL_XML_STRING );
173         if( root == nullptr )
174           throw Exception("Could not detect cereal root node - likely due to empty or invalid input");
175         else
176           itsNodes.emplace( root );
177       }
178       void loadBinaryValue( void * data, size_t size, const char * name = nullptr )
179       {
180         setNextName( name );
181         startNode();
182         std::string encoded;
183         loadValue( encoded );
184         auto decoded = base64::decode( encoded );
185         if( size != decoded.size() )
186           throw Exception("Decoded binary data size does not match specified size");
187         std::memcpy( data, decoded.data(), decoded.size() );
188         finishNode();
189       };
190       void startNode()
191       {
192         auto next = itsNodes.top().child;         auto const expectedName = itsNodes.top().name; 
193         if( expectedName &amp;&amp; ( next == nullptr || std::strcmp( next-&gt;name(), expectedName ) != 0 ) )
194         {
195           next = itsNodes.top().search( expectedName );
196           if( next == nullptr )
197             throw Exception("XML Parsing failed - provided NVP not found");
198 <a name="3"></a>        }
199         itsNodes.emplace( next );
200 <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>      }
201       void finishNode()
202       {
203         itsNodes.pop();
204         itsNodes.top().advance();
205         itsNodes.top().name = nullptr;
206       }
207       void setNextName( const char * name )
208       {
209         itsNodes.top().name = name;
210       }
211       template &lt;class T&gt; inline
212       typename std::enable_if&lt;std::is_unsigned&lt;T&gt;::value &amp;&amp; std::is_same&lt;T, bool&gt;::value, void&gt;::type</b></font>
213       loadValue( T &amp; value )
214       {
215         std::istringstream is( itsNodes.top().node-&gt;value() );
216         is.setf( std::ios::boolalpha );
217         is &gt;&gt; value;
218       }
219       template &lt;class T&gt; inline
220       typename std::enable_if&lt;std::is_unsigned&lt;T&gt;::value &amp;&amp; !std::is_same&lt;T, bool&gt;::value &amp;&amp; sizeof(T) &lt; sizeof(long long), void&gt;::type
221       loadValue( T &amp; value )
222       {
223         value = static_cast&lt;T&gt;( std::stoul( itsNodes.top().node-&gt;value() ) );
224       }
225       template &lt;class T&gt; inline
226       typename std::enable_if&lt;std::is_unsigned&lt;T&gt;::value &amp;&amp; !std::is_same&lt;T, bool&gt;::value &amp;&amp; sizeof(T) &gt;= sizeof(long long), void&gt;::type
227       loadValue( T &amp; value )
228       {
229         value = static_cast&lt;T&gt;( std::stoull( itsNodes.top().node-&gt;value() ) );
230       }
231       template &lt;class T&gt; inline
232       typename std::enable_if&lt;std::is_signed&lt;T&gt;::value &amp;&amp; sizeof(T) &lt;= sizeof(int), void&gt;::type
233       loadValue( T &amp; value )
234       {
235         value = static_cast&lt;T&gt;( std::stoi( itsNodes.top().node-&gt;value() ) );
236       }
237       template &lt;class T&gt; inline
238       typename std::enable_if&lt;std::is_signed&lt;T&gt;::value &amp;&amp; (sizeof(T) &gt; sizeof(int)) &amp;&amp; (sizeof(T) &lt;= sizeof(long)), void&gt;::type
239       loadValue( T &amp; value )
240       {
241         value = static_cast&lt;T&gt;( std::stol( itsNodes.top().node-&gt;value() ) );
242       }
243       template &lt;class T&gt; inline
244       typename std::enable_if&lt;std::is_signed&lt;T&gt;::value &amp;&amp; (sizeof(T) &gt; sizeof(long)) &amp;&amp; (sizeof(T) &lt;= sizeof(long long)), void&gt;::type
245       loadValue( T &amp; value )
246       {
247         value = static_cast&lt;T&gt;( std::stoll( itsNodes.top().node-&gt;value() ) );
248       }
249       void loadValue( float &amp; value )
250       {
251         try
252         {
253           value = std::stof( itsNodes.top().node-&gt;value() );
254         }
255         catch( std::out_of_range const &amp; )
256         {
257           std::istringstream is( itsNodes.top().node-&gt;value() );
258           is &gt;&gt; value;
259           if( std::fpclassify( value ) != FP_SUBNORMAL )
260             throw;
261         }
262       }
263       void loadValue( double &amp; value )
264       {
265         try
266         {
267           value = std::stod( itsNodes.top().node-&gt;value() );
268         }
269         catch( std::out_of_range const &amp; )
270         {
271           std::istringstream is( itsNodes.top().node-&gt;value() );
272           is &gt;&gt; value;
273           if( std::fpclassify( value ) != FP_SUBNORMAL )
274             throw;
275         }
276       }
277       void loadValue( long double &amp; value )
278       {
279         try
280         {
281           value = std::stold( itsNodes.top().node-&gt;value() );
282         }
283         catch( std::out_of_range const &amp; )
284         {
285           std::istringstream is( itsNodes.top().node-&gt;value() );
286           is &gt;&gt; value;
287           if( std::fpclassify( value ) != FP_SUBNORMAL )
288             throw;
289         }
290       }
291       template&lt;class CharT, class Traits, class Alloc&gt; inline
292       void loadValue( std::basic_string&lt;CharT, Traits, Alloc&gt; &amp; str )
293       {
294         std::basic_istringstream&lt;CharT, Traits&gt; is( itsNodes.top().node-&gt;value() );
295         str.assign( std::istreambuf_iterator&lt;CharT, Traits&gt;( is ),
296                     std::istreambuf_iterator&lt;CharT, Traits&gt;() );
297       }
298       template &lt;class T&gt; inline
299       void loadSize( T &amp; value )
300       {
301         value = getNumChildren( itsNodes.top().node );
302       }
303     protected:
304       static size_t getNumChildren( rapidxml::xml_node&lt;&gt; * node )
305       {
306         size_t size = 0;
307         node = node-&gt;first_node(); 
308         while( node != nullptr )
309         {
310           ++size;
311           node = node-&gt;next_sibling();
312         }
313         return size;
314       }
315       struct NodeInfo
316       {
317         NodeInfo( rapidxml::xml_node&lt;&gt; * n = nullptr ) :
318           node( n ),
319           child( n-&gt;first_node() ),
320           size( XMLInputArchive::getNumChildren( n ) ),
321           name( nullptr )
322         { }
323         void advance()
324         {
325           if( size &gt; 0 )
326           {
327             --size;
328             child = child-&gt;next_sibling();
329           }
330         }
331         rapidxml::xml_node&lt;&gt; * search( const char * searchName )
332         {
333           if( searchName )
334           {
335             size_t new_size = XMLInputArchive::getNumChildren( node );
336             const size_t name_size = rapidxml::internal::measure( searchName );
337             for( auto new_child = node-&gt;first_node(); new_child != nullptr; new_child = new_child-&gt;next_sibling() )
338             {
339               if( rapidxml::internal::compare( new_child-&gt;name(), new_child-&gt;name_size(), searchName, name_size, true ) )
340               {
341                 size = new_size;
342                 child = new_child;
343                 return new_child;
344               }
345               --new_size;
346             }
347           }
348           return nullptr;
349         }
350         rapidxml::xml_node&lt;&gt; * node;  //!&lt; A pointer to this node
351         rapidxml::xml_node&lt;&gt; * child; //!&lt; A pointer to its current child
352         size_t size;                  //!&lt; The remaining number of children for this node
353         const char * name;            //!&lt; The NVP name for next next child node
354       }; 
355 <a name="0"></a>      //! @}
356     private:
357 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>      std::vector&lt;char&gt; itsData;       //!&lt; The raw data loaded
358       rapidxml::xml_document&lt;&gt; itsXML; //!&lt; The XML document
359       std::stack&lt;NodeInfo&gt; itsNodes;   //!&lt; A stack of nodes read from the document
360   };
361   template &lt;class T&gt; inline
362   void prologue( XMLOutputArchive &amp;, NameValuePair&lt;T&gt; const &amp; )
363   { }
364   template &lt;class T&gt; inline
365   void prologue( XMLInputArchive &amp;, NameValuePair&lt;T&gt; const &amp; )
366   { }
367   template &lt;class T&gt; inline
368   void epilogue( XMLOutputArchive &amp;, NameValuePair&lt;T&gt; const &amp; )
369   { }
370   template &lt;class T&gt; inline
371   void epilogue( XMLInputArchive &amp;, NameValuePair&lt;T&gt; const &amp; )
372   { }
373   template &lt;class T&gt; inline
374   void prologue( XMLOutputArchive &amp; ar, SizeTag&lt;T&gt; const &amp; )
375   {
376     ar.appendAttribute( "size", "dynamic" );
377   }
378   template &lt;class T&gt; inline
379   void prologue( XMLInputArchive &amp;, SizeTag&lt;T&gt; const &amp; )
380   { }
381   template &lt;class T&gt; inline
382   void epilogue( XMLOutputArchive &amp;, SizeTag&lt;T&gt; const &amp; )
383   { }
384   template &lt;class T&gt; inline
385   void epilogue( XMLInputArchive &amp;, SizeTag&lt;T&gt; const &amp; )
386   { }
387   template &lt;class T&gt; inline
388   typename std::enable_if&lt;!traits::has_minimal_output_serialization&lt;T, XMLOutputArchive&gt;::value, void&gt;::type</b></font><font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>
389   prologue( XMLOutputArchive &amp; ar, T const &amp; )
390   {
391     ar.startNode();
392     ar.insertType&lt;T&gt;();
393   }
394   template &lt;class T&gt; inline
395   typename std::enable_if&lt;!traits::has_minimal_input_serialization&lt;T, XMLInputArchive&gt;::value, void&gt;::type
396   prologue( XMLInputArchive &amp; ar, T const &amp; )
397   {
398     ar.startNode();
399   }
400   template &lt;class T&gt; inline
401   typename std::enable_if&lt;!traits::has_minimal_output_serialization&lt;T, XMLOutputArchive&gt;::value, void&gt;::type
402   epilogue( XMLOutputArchive &amp; ar, T const &amp; )
403   {
404     ar.finishNode();
405   }
406   template &lt;class T&gt; inline
407   typename std::enable_if&lt;!traits::has_minimal_input_serialization&lt;T, XMLInputArchive&gt;::value, void&gt;::type
408   epilogue( XMLInputArchive &amp; ar, T const &amp; )
409   {
410     ar.finishNode();
411   }
412   template &lt;class T&gt; inline</b></font>
413   void save( XMLOutputArchive &amp; ar, NameValuePair&lt;T&gt; const &amp; t )
414   {
415     ar.setNextName( t.name );
416     ar( t.value );
417   }
418 <a name="1"></a>  //! Loading NVP types from XML
419   template &lt;class T&gt; inline
420   void load( XMLInputArchive &amp; ar, NameValuePair&lt;T&gt; &amp; t )
421 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  {
422     ar.setNextName( t.name );
423     ar( t.value );
424   }
425   template &lt;class T&gt; inline
426   void save( XMLOutputArchive &amp;, SizeTag&lt;T&gt; const &amp; )
427   { }
428   template &lt;class T&gt; inline
429   void load( XMLInputArchive &amp; ar, SizeTag&lt;T&gt; &amp; st )
430   {
431     ar.loadSize( st.size );
432   }
433   template&lt;class T&gt; inline
434   typename std::enable_if&lt;std::is_arithmetic&lt;T&gt;::value, void&gt;::type
435   save(XMLOutputArchive &amp; ar, T const &amp; t)
436   {
437     ar.saveValue( t );
438   }
439   template&lt;class T&gt; inline
440   typename std::enable_if&lt;std::is_arithmetic&lt;T&gt;::value, void&gt;::type
441   load(XMLInputArchive &amp; ar, T &amp; t)
442   {
443     ar.loadValue( t );
444   }
445   template&lt;class CharT, class Traits, class Alloc&gt; inline
446   void save(XMLOutputArchive &amp; ar, std::basic_string&lt;CharT, Traits, Alloc&gt; const &amp; str)
447   {
448     ar.saveValue( str );
449   }
450   template&lt;class CharT, class Traits, class Alloc&gt; inline
451   void load(XMLInputArchive &amp; ar, std::basic_string&lt;CharT, Traits, Alloc&gt; &amp; str)
452   {
453     ar.loadValue( str );
454   }</b></font>
455 } 
456 CEREAL_REGISTER_ARCHIVE(cereal::XMLOutputArchive)
457 CEREAL_REGISTER_ARCHIVE(cereal::XMLInputArchive)
#endif </pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
