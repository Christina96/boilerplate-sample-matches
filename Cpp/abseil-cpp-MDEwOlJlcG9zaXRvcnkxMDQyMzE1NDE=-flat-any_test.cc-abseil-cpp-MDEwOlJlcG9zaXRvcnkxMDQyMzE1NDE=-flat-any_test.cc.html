
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 15, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-any_test.cc</h3>
            <pre><code>1  #include "absl/types/any.h"
2  #if !defined(ABSL_USES_STD_ANY)
3  #include <initializer_list>
4  #include <type_traits>
5  #include <utility>
6  #include <vector>
7  #include "gtest/gtest.h"
8  #include "absl/base/config.h"
9  #include "absl/base/internal/exception_testing.h"
10  #include "absl/container/internal/test_instance_tracker.h"
11  #include "absl/log/log.h"
12  namespace {
13  using absl::test_internal::CopyableOnlyInstance;
14  using absl::test_internal::InstanceTracker;
15  template <typename T>
16  const T& AsConst(const T& t) {
17    return t;
18  }
19  struct MoveOnly {
20    MoveOnly() = default;
21    explicit MoveOnly(int value) : value(value) {}
22    MoveOnly(MoveOnly&&) = default;
23    MoveOnly& operator=(MoveOnly&&) = default;
24    int value = 0;
25  };
26  struct CopyOnly {
27    CopyOnly() = default;
28    explicit CopyOnly(int value) : value(value) {}
29    CopyOnly(CopyOnly&&) = delete;
30    CopyOnly& operator=(CopyOnly&&) = delete;
31    CopyOnly(const CopyOnly&) = default;
32    CopyOnly& operator=(const CopyOnly&) = default;
33    int value = 0;
34  };
35  struct MoveOnlyWithListConstructor {
36    MoveOnlyWithListConstructor() = default;
37    explicit MoveOnlyWithListConstructor(std::initializer_list<int> &bsol;*ilist*/,
38                                         int value)
39        : value(value) {}
40    MoveOnlyWithListConstructor(MoveOnlyWithListConstructor&&) = default;
41    MoveOnlyWithListConstructor& operator=(MoveOnlyWithListConstructor&&) =
42        default;
43    int value = 0;
44  };
45  struct IntMoveOnlyCopyOnly {
46    IntMoveOnlyCopyOnly(int value, MoveOnly &bsol;*move_only*/, CopyOnly &bsol;*copy_only*/)
47        : value(value) {}
48    int value;
49  };
50  struct ListMoveOnlyCopyOnly {
51    ListMoveOnlyCopyOnly(std::initializer_list<int> ilist, MoveOnly &bsol;*move_only*/,
52                         CopyOnly &bsol;*copy_only*/)
53        : values(ilist) {}
54    std::vector<int> values;
55  };
56  using FunctionType = void();
57  void FunctionToEmplace() {}
58  using ArrayType = int[2];
59  using DecayedArray = absl::decay_t<ArrayType>;
60  TEST(AnyTest, Noexcept) {
61    static_assert(std::is_nothrow_default_constructible<absl::any>(), "");
62    static_assert(std::is_nothrow_move_constructible<absl::any>(), "");
63    static_assert(std::is_nothrow_move_assignable<absl::any>(), "");
64    static_assert(noexcept(std::declval<absl::any&>().has_value()), "");
65    static_assert(noexcept(std::declval<absl::any&>().type()), "");
66    static_assert(noexcept(absl::any_cast<int>(std::declval<absl::any*>())), "");
67    static_assert(
68        noexcept(std::declval<absl::any&>().swap(std::declval<absl::any&>())),
69        "");
70    using std::swap;
71    static_assert(
72        noexcept(swap(std::declval<absl::any&>(), std::declval<absl::any&>())),
73        "");
74  }
75  TEST(AnyTest, HasValue) {
76    absl::any o;
77    EXPECT_FALSE(o.has_value());
78    o.emplace<int>();
79    EXPECT_TRUE(o.has_value());
80    o.reset();
81    EXPECT_FALSE(o.has_value());
82  }
83  TEST(AnyTest, Type) {
84    absl::any o;
85    EXPECT_EQ(typeid(void), o.type());
86    o.emplace<int>(5);
87    EXPECT_EQ(typeid(int), o.type());
88    o.emplace<float>(5.f);
89    EXPECT_EQ(typeid(float), o.type());
90    o.reset();
91    EXPECT_EQ(typeid(void), o.type());
92  }
93  TEST(AnyTest, EmptyPointerCast) {
94    {
95      absl::any o;
96      EXPECT_EQ(nullptr, absl::any_cast<int>(&o));
97      o.emplace<int>();
98      EXPECT_NE(nullptr, absl::any_cast<int>(&o));
99      o.reset();
100      EXPECT_EQ(nullptr, absl::any_cast<int>(&o));
101    }
102    {
103      absl::any o;
104      EXPECT_EQ(nullptr, absl::any_cast<int>(&AsConst(o)));
105      o.emplace<int>();
106      EXPECT_NE(nullptr, absl::any_cast<int>(&AsConst(o)));
107      o.reset();
108      EXPECT_EQ(nullptr, absl::any_cast<int>(&AsConst(o)));
109    }
110  }
111  TEST(AnyTest, InPlaceConstruction) {
112    const CopyOnly copy_only{};
113    absl::any o(absl::in_place_type_t<IntMoveOnlyCopyOnly>(), 5, MoveOnly(),
114                copy_only);
115    IntMoveOnlyCopyOnly& v = absl::any_cast<IntMoveOnlyCopyOnly&>(o);
116    EXPECT_EQ(5, v.value);
117  }
118  TEST(AnyTest, InPlaceConstructionVariableTemplate) {
119    const CopyOnly copy_only{};
120    absl::any o(absl::in_place_type<IntMoveOnlyCopyOnly>, 5, MoveOnly(),
121                copy_only);
122    auto& v = absl::any_cast<IntMoveOnlyCopyOnly&>(o);
123    EXPECT_EQ(5, v.value);
124  }
125  TEST(AnyTest, InPlaceConstructionWithCV) {
126    const CopyOnly copy_only{};
127    absl::any o(absl::in_place_type_t<const volatile IntMoveOnlyCopyOnly>(), 5,
128                MoveOnly(), copy_only);
129    IntMoveOnlyCopyOnly& v = absl::any_cast<IntMoveOnlyCopyOnly&>(o);
130    EXPECT_EQ(5, v.value);
131  }
132  TEST(AnyTest, InPlaceConstructionWithCVVariableTemplate) {
133    const CopyOnly copy_only{};
134    absl::any o(absl::in_place_type<const volatile IntMoveOnlyCopyOnly>, 5,
135                MoveOnly(), copy_only);
136    auto& v = absl::any_cast<IntMoveOnlyCopyOnly&>(o);
137    EXPECT_EQ(5, v.value);
138  }
139  TEST(AnyTest, InPlaceConstructionWithFunction) {
140    absl::any o(absl::in_place_type_t<FunctionType>(), FunctionToEmplace);
141    FunctionType*& construction_result = absl::any_cast<FunctionType*&>(o);
142    EXPECT_EQ(&FunctionToEmplace, construction_result);
143  }
144  TEST(AnyTest, InPlaceConstructionWithFunctionVariableTemplate) {
145    absl::any o(absl::in_place_type<FunctionType>, FunctionToEmplace);
146    auto& construction_result = absl::any_cast<FunctionType*&>(o);
147    EXPECT_EQ(&FunctionToEmplace, construction_result);
148  }
149  TEST(AnyTest, InPlaceConstructionWithArray) {
150    ArrayType ar = {5, 42};
151    absl::any o(absl::in_place_type_t<ArrayType>(), ar);
152    DecayedArray& construction_result = absl::any_cast<DecayedArray&>(o);
153    EXPECT_EQ(&ar[0], construction_result);
154  }
155  TEST(AnyTest, InPlaceConstructionWithArrayVariableTemplate) {
156    ArrayType ar = {5, 42};
157    absl::any o(absl::in_place_type<ArrayType>, ar);
158    auto& construction_result = absl::any_cast<DecayedArray&>(o);
159    EXPECT_EQ(&ar[0], construction_result);
160  }
161  TEST(AnyTest, InPlaceConstructionIlist) {
162    const CopyOnly copy_only{};
163    absl::any o(absl::in_place_type_t<ListMoveOnlyCopyOnly>(), {1, 2, 3, 4},
164                MoveOnly(), copy_only);
165    ListMoveOnlyCopyOnly& v = absl::any_cast<ListMoveOnlyCopyOnly&>(o);
166    std::vector<int> expected_values = {1, 2, 3, 4};
167    EXPECT_EQ(expected_values, v.values);
168  }
169  TEST(AnyTest, InPlaceConstructionIlistVariableTemplate) {
170    const CopyOnly copy_only{};
171    absl::any o(absl::in_place_type<ListMoveOnlyCopyOnly>, {1, 2, 3, 4},
172                MoveOnly(), copy_only);
173    auto& v = absl::any_cast<ListMoveOnlyCopyOnly&>(o);
174    std::vector<int> expected_values = {1, 2, 3, 4};
175    EXPECT_EQ(expected_values, v.values);
176  }
177  TEST(AnyTest, InPlaceConstructionIlistWithCV) {
178    const CopyOnly copy_only{};
179    absl::any o(absl::in_place_type_t<const volatile ListMoveOnlyCopyOnly>(),
180                {1, 2, 3, 4}, MoveOnly(), copy_only);
181    ListMoveOnlyCopyOnly& v = absl::any_cast<ListMoveOnlyCopyOnly&>(o);
182    std::vector<int> expected_values = {1, 2, 3, 4};
183    EXPECT_EQ(expected_values, v.values);
184  }
185  TEST(AnyTest, InPlaceConstructionIlistWithCVVariableTemplate) {
186    const CopyOnly copy_only{};
187    absl::any o(absl::in_place_type<const volatile ListMoveOnlyCopyOnly>,
188                {1, 2, 3, 4}, MoveOnly(), copy_only);
189    auto& v = absl::any_cast<ListMoveOnlyCopyOnly&>(o);
190    std::vector<int> expected_values = {1, 2, 3, 4};
191    EXPECT_EQ(expected_values, v.values);
192  }
193  TEST(AnyTest, InPlaceNoArgs) {
194    absl::any o(absl::in_place_type_t<int>{});
195    EXPECT_EQ(0, absl::any_cast<int&>(o));
196  }
197  TEST(AnyTest, InPlaceNoArgsVariableTemplate) {
198    absl::any o(absl::in_place_type<int>);
199    EXPECT_EQ(0, absl::any_cast<int&>(o));
200  }
201  template <typename Enabler, typename T, typename... Args>
202  struct CanEmplaceAnyImpl : std::false_type {};
203  template <typename T, typename... Args>
204  struct CanEmplaceAnyImpl<
205      absl::void_t<decltype(
206          std::declval<absl::any&>().emplace<T>(std::declval<Args>()...))>,
207      T, Args...> : std::true_type {};
208  template <typename T, typename... Args>
209  using CanEmplaceAny = CanEmplaceAnyImpl<void, T, Args...>;
210  TEST(AnyTest, Emplace) {
211    const CopyOnly copy_only{};
212    absl::any o;
213    EXPECT_TRUE((std::is_same<decltype(o.emplace<IntMoveOnlyCopyOnly>(
214                                  5, MoveOnly(), copy_only)),
215                              IntMoveOnlyCopyOnly&>::value));
216    IntMoveOnlyCopyOnly& emplace_result =
217        o.emplace<IntMoveOnlyCopyOnly>(5, MoveOnly(), copy_only);
218    EXPECT_EQ(5, emplace_result.value);
219    IntMoveOnlyCopyOnly& v = absl::any_cast<IntMoveOnlyCopyOnly&>(o);
220    EXPECT_EQ(5, v.value);
221    EXPECT_EQ(&emplace_result, &v);
222    static_assert(!CanEmplaceAny<int, int, int>::value, "");
223    static_assert(!CanEmplaceAny<MoveOnly, MoveOnly>::value, "");
224  }
225  TEST(AnyTest, EmplaceWithCV) {
226    const CopyOnly copy_only{};
227    absl::any o;
228    EXPECT_TRUE(
229        (std::is_same<decltype(o.emplace<const volatile IntMoveOnlyCopyOnly>(
230                          5, MoveOnly(), copy_only)),
231                      IntMoveOnlyCopyOnly&>::value));
232    IntMoveOnlyCopyOnly& emplace_result =
233        o.emplace<const volatile IntMoveOnlyCopyOnly>(5, MoveOnly(), copy_only);
234    EXPECT_EQ(5, emplace_result.value);
235    IntMoveOnlyCopyOnly& v = absl::any_cast<IntMoveOnlyCopyOnly&>(o);
236    EXPECT_EQ(5, v.value);
237    EXPECT_EQ(&emplace_result, &v);
238  }
239  TEST(AnyTest, EmplaceWithFunction) {
240    absl::any o;
241    EXPECT_TRUE(
242        (std::is_same<decltype(o.emplace<FunctionType>(FunctionToEmplace)),
243                      FunctionType*&>::value));
244    FunctionType*& emplace_result = o.emplace<FunctionType>(FunctionToEmplace);
245    EXPECT_EQ(&FunctionToEmplace, emplace_result);
246  }
247  TEST(AnyTest, EmplaceWithArray) {
248    absl::any o;
249    ArrayType ar = {5, 42};
250    EXPECT_TRUE(
251        (std::is_same<decltype(o.emplace<ArrayType>(ar)), DecayedArray&>::value));
252    DecayedArray& emplace_result = o.emplace<ArrayType>(ar);
253    EXPECT_EQ(&ar[0], emplace_result);
254  }
255  TEST(AnyTest, EmplaceIlist) {
256    const CopyOnly copy_only{};
257    absl::any o;
258    EXPECT_TRUE((std::is_same<decltype(o.emplace<ListMoveOnlyCopyOnly>(
259                                  {1, 2, 3, 4}, MoveOnly(), copy_only)),
260                              ListMoveOnlyCopyOnly&>::value));
261    ListMoveOnlyCopyOnly& emplace_result =
262        o.emplace<ListMoveOnlyCopyOnly>({1, 2, 3, 4}, MoveOnly(), copy_only);
263    ListMoveOnlyCopyOnly& v = absl::any_cast<ListMoveOnlyCopyOnly&>(o);
264    EXPECT_EQ(&v, &emplace_result);
265    std::vector<int> expected_values = {1, 2, 3, 4};
266    EXPECT_EQ(expected_values, v.values);
267    static_assert(!CanEmplaceAny<int, std::initializer_list<int>>::value, "");
268    static_assert(!CanEmplaceAny<MoveOnlyWithListConstructor,
269                                 std::initializer_list<int>, int>::value,
270                  "");
271  }
272  TEST(AnyTest, EmplaceIlistWithCV) {
273    const CopyOnly copy_only{};
274    absl::any o;
275    EXPECT_TRUE(
276        (std::is_same<decltype(o.emplace<const volatile ListMoveOnlyCopyOnly>(
277                          {1, 2, 3, 4}, MoveOnly(), copy_only)),
278                      ListMoveOnlyCopyOnly&>::value));
279    ListMoveOnlyCopyOnly& emplace_result =
280        o.emplace<const volatile ListMoveOnlyCopyOnly>({1, 2, 3, 4}, MoveOnly(),
281                                                       copy_only);
282    ListMoveOnlyCopyOnly& v = absl::any_cast<ListMoveOnlyCopyOnly&>(o);
283    EXPECT_EQ(&v, &emplace_result);
284    std::vector<int> expected_values = {1, 2, 3, 4};
285    EXPECT_EQ(expected_values, v.values);
286  }
287  TEST(AnyTest, EmplaceNoArgs) {
288    absl::any o;
289    o.emplace<int>();
290    EXPECT_EQ(0, absl::any_cast<int>(o));
291  }
292  TEST(AnyTest, ConversionConstruction) {
293    {
294      absl::any o = 5;
295      EXPECT_EQ(5, absl::any_cast<int>(o));
296    }
297    {
298      const CopyOnly copy_only(5);
299      absl::any o = copy_only;
300      EXPECT_EQ(5, absl::any_cast<CopyOnly&>(o).value);
301    }
302    static_assert(!std::is_convertible<MoveOnly, absl::any>::value, "");
303  }
304  TEST(AnyTest, ConversionAssignment) {
305    {
306      absl::any o;
307      o = 5;
308      EXPECT_EQ(5, absl::any_cast<int>(o));
309    }
310    {
311      const CopyOnly copy_only(5);
312      absl::any o;
313      o = copy_only;
314      EXPECT_EQ(5, absl::any_cast<CopyOnly&>(o).value);
315    }
316    static_assert(!std::is_assignable<MoveOnly, absl::any>::value, "");
317  }
318  #ifdef _MSC_VER
319  #pragma warning( push )
320  #pragma warning( disable : 4521)
321  #endif
322  struct WeirdConstructor42 {
323    explicit WeirdConstructor42(int value) : value(value) {}
324    WeirdConstructor42(const WeirdConstructor42& other) : value(other.value) {}
325    WeirdConstructor42(
326        WeirdConstructor42& &bsol;*other*/)  
327        : value(42) {}
328    int value;
329  };
330  #ifdef _MSC_VER
331  #pragma warning( pop )
332  #endif
333  TEST(AnyTest, WeirdConversionConstruction) {
334    {
335      const WeirdConstructor42 source(5);
336      absl::any o = source;  
337      EXPECT_EQ(5, absl::any_cast<WeirdConstructor42&>(o).value);
338    }
339    {
340      WeirdConstructor42 source(5);
341      absl::any o = source;  
342      EXPECT_EQ(42, absl::any_cast<WeirdConstructor42&>(o).value);
343    }
344  }
345  TEST(AnyTest, WeirdConversionAssignment) {
346    {
347      const WeirdConstructor42 source(5);
348      absl::any o;
349      o = source;  
350      EXPECT_EQ(5, absl::any_cast<WeirdConstructor42&>(o).value);
351    }
352    {
353      WeirdConstructor42 source(5);
354      absl::any o;
355      o = source;  
356      EXPECT_EQ(42, absl::any_cast<WeirdConstructor42&>(o).value);
357    }
358  }
359  struct Value {};
360  TEST(AnyTest, AnyCastValue) {
361    {
362      absl::any o;
363      o.emplace<int>(5);
364      EXPECT_EQ(5, absl::any_cast<int>(o));
365      EXPECT_EQ(5, absl::any_cast<int>(AsConst(o)));
366      static_assert(
367          std::is_same<decltype(absl::any_cast<Value>(o)), Value>::value, "");
368    }
369    {
370      absl::any o;
371      o.emplace<int>(5);
372      EXPECT_EQ(5, absl::any_cast<const int>(o));
373      EXPECT_EQ(5, absl::any_cast<const int>(AsConst(o)));
374      static_assert(std::is_same<decltype(absl::any_cast<const Value>(o)),
375                                 const Value>::value,
376                    "");
377    }
378  }
379  TEST(AnyTest, AnyCastReference) {
380    {
381      absl::any o;
382      o.emplace<int>(5);
383      EXPECT_EQ(5, absl::any_cast<int&>(o));
384      EXPECT_EQ(5, absl::any_cast<const int&>(AsConst(o)));
385      static_assert(
386          std::is_same<decltype(absl::any_cast<Value&>(o)), Value&>::value, "");
387    }
388    {
389      absl::any o;
390      o.emplace<int>(5);
391      EXPECT_EQ(5, absl::any_cast<const int>(o));
392      EXPECT_EQ(5, absl::any_cast<const int>(AsConst(o)));
393      static_assert(std::is_same<decltype(absl::any_cast<const Value&>(o)),
394                                 const Value&>::value,
395                    "");
396    }
397    {
398      absl::any o;
399      o.emplace<int>(5);
400      EXPECT_EQ(5, absl::any_cast<int&&>(std::move(o)));
401      static_assert(std::is_same<decltype(absl::any_cast<Value&&>(std::move(o))),
402                                 Value&&>::value,
403                    "");
404    }
405    {
406      absl::any o;
407      o.emplace<int>(5);
408      EXPECT_EQ(5, absl::any_cast<const int>(std::move(o)));
409      static_assert(
410          std::is_same<decltype(absl::any_cast<const Value&&>(std::move(o))),
411                       const Value&&>::value,
412          "");
413    }
414  }
415  TEST(AnyTest, AnyCastPointer) {
416    {
417      absl::any o;
418      EXPECT_EQ(nullptr, absl::any_cast<char>(&o));
419      o.emplace<int>(5);
420      EXPECT_EQ(nullptr, absl::any_cast<char>(&o));
421      o.emplace<char>('a');
422      EXPECT_EQ('a', *absl::any_cast<char>(&o));
423      static_assert(
424          std::is_same<decltype(absl::any_cast<Value>(&o)), Value*>::value, "");
425    }
426    {
427      absl::any o;
428      EXPECT_EQ(nullptr, absl::any_cast<const char>(&o));
429      o.emplace<int>(5);
430      EXPECT_EQ(nullptr, absl::any_cast<const char>(&o));
431      o.emplace<char>('a');
432      EXPECT_EQ('a', *absl::any_cast<const char>(&o));
433      static_assert(std::is_same<decltype(absl::any_cast<const Value>(&o)),
434                                 const Value*>::value,
435                    "");
436    }
437  }
438  TEST(AnyTest, MakeAny) {
439    const CopyOnly copy_only{};
440    auto o = absl::make_any<IntMoveOnlyCopyOnly>(5, MoveOnly(), copy_only);
441    static_assert(std::is_same<decltype(o), absl::any>::value, "");
442    EXPECT_EQ(5, absl::any_cast<IntMoveOnlyCopyOnly&>(o).value);
443  }
444  TEST(AnyTest, MakeAnyIList) {
445    const CopyOnly copy_only{};
446    auto o =
447        absl::make_any<ListMoveOnlyCopyOnly>({1, 2, 3}, MoveOnly(), copy_only);
448    static_assert(std::is_same<decltype(o), absl::any>::value, "");
449    ListMoveOnlyCopyOnly& v = absl::any_cast<ListMoveOnlyCopyOnly&>(o);
450    std::vector<int> expected_values = {1, 2, 3};
451    EXPECT_EQ(expected_values, v.values);
452  }
453  TEST(AnyTest, Copy) {
454    InstanceTracker tracker_raii;
455    {
456      absl::any o(absl::in_place_type<CopyableOnlyInstance>, 123);
457      CopyableOnlyInstance* f1 = absl::any_cast<CopyableOnlyInstance>(&o);
458      absl::any o2(o);
459      const CopyableOnlyInstance* f2 = absl::any_cast<CopyableOnlyInstance>(&o2);
460      EXPECT_EQ(123, f2->value());
461      EXPECT_NE(f1, f2);
462      absl::any o3;
463      o3 = o2;
464      const CopyableOnlyInstance* f3 = absl::any_cast<CopyableOnlyInstance>(&o3);
465      EXPECT_EQ(123, f3->value());
466      EXPECT_NE(f2, f3);
467      const absl::any o4(4);
468      absl::any o5 = o4;
469      EXPECT_EQ(4, absl::any_cast<int>(o4));
470      EXPECT_EQ(4, absl::any_cast<int>(o5));
471      absl::any o6 = std::move(o4);  
472      EXPECT_EQ(4, absl::any_cast<int>(o4));
473      EXPECT_EQ(4, absl::any_cast<int>(o6));
474    }
475  }
476  TEST(AnyTest, Move) {
477    InstanceTracker tracker_raii;
478    absl::any any1;
479    any1.emplace<CopyableOnlyInstance>(5);
480    absl::any any2 = any1;
481    EXPECT_EQ(5, absl::any_cast<CopyableOnlyInstance&>(any1).value());
482    EXPECT_EQ(5, absl::any_cast<CopyableOnlyInstance&>(any2).value());
483    EXPECT_EQ(1, tracker_raii.copies());
484    absl::any any3 = std::move(any2);
485    EXPECT_EQ(5, absl::any_cast<CopyableOnlyInstance&>(any3).value());
486    EXPECT_EQ(1, tracker_raii.copies());
487    absl::any any4;
488    any4 = std::move(any3);
489    EXPECT_EQ(5, absl::any_cast<CopyableOnlyInstance&>(any4).value());
490    EXPECT_EQ(1, tracker_raii.copies());
491    absl::any tmp4(4);
492    absl::any o4(std::move(tmp4));  
493    EXPECT_EQ(4, absl::any_cast<int>(o4));
494    o4 = *&o4;  
495    EXPECT_EQ(4, absl::any_cast<int>(o4));
496    EXPECT_TRUE(o4.has_value());
497    absl::any o5;
498    absl::any tmp5(5);
499    o5 = std::move(tmp5);  
500    EXPECT_EQ(5, absl::any_cast<int>(o5));
501  }
502  TEST(AnyTest, Reset) {
503    absl::any o;
504    o.emplace<int>();
505    o.reset();
506    EXPECT_FALSE(o.has_value());
507    o.emplace<char>();
508    EXPECT_TRUE(o.has_value());
509  }
510  TEST(AnyTest, ConversionConstructionCausesOneCopy) {
511    InstanceTracker tracker_raii;
512    CopyableOnlyInstance counter(5);
513    absl::any o(counter);
514    EXPECT_EQ(5, absl::any_cast<CopyableOnlyInstance&>(o).value());
515    EXPECT_EQ(1, tracker_raii.copies());
516  }
517  #if defined(ABSL_USES_STD_ANY)
518  #define ABSL_ANY_TEST_EXPECT_BAD_ANY_CAST(...)                      \
519    ABSL_BASE_INTERNAL_EXPECT_FAIL((__VA_ARGS__), absl::bad_any_cast, \
520                                   "")
521  #else
522  #define ABSL_ANY_TEST_EXPECT_BAD_ANY_CAST(...)                      \
523    ABSL_BASE_INTERNAL_EXPECT_FAIL((__VA_ARGS__), absl::bad_any_cast, \
524                                   "Bad any cast")
525  #endif  
526  TEST(AnyTest, ThrowBadAlloc) {
527    {
528      absl::any a;
529      ABSL_ANY_TEST_EXPECT_BAD_ANY_CAST(absl::any_cast<int&>(a));
530      ABSL_ANY_TEST_EXPECT_BAD_ANY_CAST(absl::any_cast<const int&>(a));
531      ABSL_ANY_TEST_EXPECT_BAD_ANY_CAST(absl::any_cast<int&&>(absl::any{}));
532      ABSL_ANY_TEST_EXPECT_BAD_ANY_CAST(absl::any_cast<const int&&>(absl::any{}));
533      ABSL_ANY_TEST_EXPECT_BAD_ANY_CAST(absl::any_cast<int>(a));
534      ABSL_ANY_TEST_EXPECT_BAD_ANY_CAST(absl::any_cast<const int>(a));
535      ABSL_ANY_TEST_EXPECT_BAD_ANY_CAST(absl::any_cast<int>(absl::any{}));
536      ABSL_ANY_TEST_EXPECT_BAD_ANY_CAST(absl::any_cast<const int>(absl::any{}));
537      ABSL_ANY_TEST_EXPECT_BAD_ANY_CAST(absl::any_cast<const int&>(AsConst(a)));
538      ABSL_ANY_TEST_EXPECT_BAD_ANY_CAST(absl::any_cast<int>(AsConst(a)));
539      ABSL_ANY_TEST_EXPECT_BAD_ANY_CAST(absl::any_cast<const int>(AsConst(a)));
540    }
541    {
542      absl::any a(absl::in_place_type<int>);
543      ABSL_ANY_TEST_EXPECT_BAD_ANY_CAST(absl::any_cast<float&>(a));
544      ABSL_ANY_TEST_EXPECT_BAD_ANY_CAST(absl::any_cast<const float&>(a));
545      ABSL_ANY_TEST_EXPECT_BAD_ANY_CAST(absl::any_cast<float&&>(absl::any{}));
546      ABSL_ANY_TEST_EXPECT_BAD_ANY_CAST(
547          absl::any_cast<const float&&>(absl::any{}));
548      ABSL_ANY_TEST_EXPECT_BAD_ANY_CAST(absl::any_cast<float>(a));
549      ABSL_ANY_TEST_EXPECT_BAD_ANY_CAST(absl::any_cast<const float>(a));
550      ABSL_ANY_TEST_EXPECT_BAD_ANY_CAST(absl::any_cast<float>(absl::any{}));
551      ABSL_ANY_TEST_EXPECT_BAD_ANY_CAST(absl::any_cast<const float>(absl::any{}));
552      ABSL_ANY_TEST_EXPECT_BAD_ANY_CAST(absl::any_cast<const float&>(AsConst(a)));
553      ABSL_ANY_TEST_EXPECT_BAD_ANY_CAST(absl::any_cast<float>(AsConst(a)));
554      ABSL_ANY_TEST_EXPECT_BAD_ANY_CAST(absl::any_cast<const float>(AsConst(a)));
555    }
556  }
557  class BadCopy {};
558  struct BadCopyable {
559    BadCopyable() = default;
560    BadCopyable(BadCopyable&&) = default;
561    BadCopyable(const BadCopyable&) {
562  #ifdef ABSL_HAVE_EXCEPTIONS
563      throw BadCopy();
564  #else
565      LOG(FATAL) << "Bad copy";
566  #endif
567    }
568  };
569  #define ABSL_ANY_TEST_EXPECT_BAD_COPY(...) \
570    ABSL_BASE_INTERNAL_EXPECT_FAIL((__VA_ARGS__), BadCopy, "Bad copy")
571  TEST(AnyTest, FailedCopy) {
572    {
573      const BadCopyable bad{};
574      ABSL_ANY_TEST_EXPECT_BAD_COPY(absl::any{bad});
575    }
576    {
577      absl::any src(absl::in_place_type<BadCopyable>);
578      ABSL_ANY_TEST_EXPECT_BAD_COPY(absl::any{src});
579    }
580    {
581      BadCopyable bad;
582      absl::any target;
583      ABSL_ANY_TEST_EXPECT_BAD_COPY(target = bad);
584    }
585    {
586      BadCopyable bad;
587      absl::any target(absl::in_place_type<BadCopyable>);
588      ABSL_ANY_TEST_EXPECT_BAD_COPY(target = bad);
589      EXPECT_TRUE(target.has_value());
590    }
591    {
592      absl::any src(absl::in_place_type<BadCopyable>);
593      absl::any target;
594      ABSL_ANY_TEST_EXPECT_BAD_COPY(target = src);
595      EXPECT_FALSE(target.has_value());
596    }
597    {
598      absl::any src(absl::in_place_type<BadCopyable>);
599      absl::any target(absl::in_place_type<BadCopyable>);
600      ABSL_ANY_TEST_EXPECT_BAD_COPY(target = src);
601      EXPECT_TRUE(target.has_value());
602    }
603  }
<span onclick='openModal()' class='match'>604  TEST(AnyTest, FailedEmplace) {
605    BadCopyable bad;
606    absl::any target;
607    ABSL_ANY_TEST_EXPECT_BAD_COPY(target.emplace<BadCopyable>(bad));
</span>608  }
609  #ifdef __GNUC__
610  TEST(AnyTest, DISABLED_FailedEmplaceInPlace) {
611  #else
612  TEST(AnyTest, FailedEmplaceInPlace) {
613  #endif
614    BadCopyable bad;
615    absl::any target(absl::in_place_type<int>);
616    ABSL_ANY_TEST_EXPECT_BAD_COPY(target.emplace<BadCopyable>(bad));
617    EXPECT_FALSE(target.has_value());
618  }
619  }  
620  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-any_test.cc</h3>
            <pre><code>1  #include "absl/types/any.h"
2  #if !defined(ABSL_USES_STD_ANY)
3  #include <initializer_list>
4  #include <type_traits>
5  #include <utility>
6  #include <vector>
7  #include "gtest/gtest.h"
8  #include "absl/base/config.h"
9  #include "absl/base/internal/exception_testing.h"
10  #include "absl/container/internal/test_instance_tracker.h"
11  #include "absl/log/log.h"
12  namespace {
13  using absl::test_internal::CopyableOnlyInstance;
14  using absl::test_internal::InstanceTracker;
15  template <typename T>
16  const T& AsConst(const T& t) {
17    return t;
18  }
19  struct MoveOnly {
20    MoveOnly() = default;
21    explicit MoveOnly(int value) : value(value) {}
22    MoveOnly(MoveOnly&&) = default;
23    MoveOnly& operator=(MoveOnly&&) = default;
24    int value = 0;
25  };
26  struct CopyOnly {
27    CopyOnly() = default;
28    explicit CopyOnly(int value) : value(value) {}
29    CopyOnly(CopyOnly&&) = delete;
30    CopyOnly& operator=(CopyOnly&&) = delete;
31    CopyOnly(const CopyOnly&) = default;
32    CopyOnly& operator=(const CopyOnly&) = default;
33    int value = 0;
34  };
35  struct MoveOnlyWithListConstructor {
36    MoveOnlyWithListConstructor() = default;
37    explicit MoveOnlyWithListConstructor(std::initializer_list<int> &bsol;*ilist*/,
38                                         int value)
39        : value(value) {}
40    MoveOnlyWithListConstructor(MoveOnlyWithListConstructor&&) = default;
41    MoveOnlyWithListConstructor& operator=(MoveOnlyWithListConstructor&&) =
42        default;
43    int value = 0;
44  };
45  struct IntMoveOnlyCopyOnly {
46    IntMoveOnlyCopyOnly(int value, MoveOnly &bsol;*move_only*/, CopyOnly &bsol;*copy_only*/)
47        : value(value) {}
48    int value;
49  };
50  struct ListMoveOnlyCopyOnly {
51    ListMoveOnlyCopyOnly(std::initializer_list<int> ilist, MoveOnly &bsol;*move_only*/,
52                         CopyOnly &bsol;*copy_only*/)
53        : values(ilist) {}
54    std::vector<int> values;
55  };
56  using FunctionType = void();
57  void FunctionToEmplace() {}
58  using ArrayType = int[2];
59  using DecayedArray = absl::decay_t<ArrayType>;
60  TEST(AnyTest, Noexcept) {
61    static_assert(std::is_nothrow_default_constructible<absl::any>(), "");
62    static_assert(std::is_nothrow_move_constructible<absl::any>(), "");
63    static_assert(std::is_nothrow_move_assignable<absl::any>(), "");
64    static_assert(noexcept(std::declval<absl::any&>().has_value()), "");
65    static_assert(noexcept(std::declval<absl::any&>().type()), "");
66    static_assert(noexcept(absl::any_cast<int>(std::declval<absl::any*>())), "");
67    static_assert(
68        noexcept(std::declval<absl::any&>().swap(std::declval<absl::any&>())),
69        "");
70    using std::swap;
71    static_assert(
72        noexcept(swap(std::declval<absl::any&>(), std::declval<absl::any&>())),
73        "");
74  }
75  TEST(AnyTest, HasValue) {
76    absl::any o;
77    EXPECT_FALSE(o.has_value());
78    o.emplace<int>();
79    EXPECT_TRUE(o.has_value());
80    o.reset();
81    EXPECT_FALSE(o.has_value());
82  }
83  TEST(AnyTest, Type) {
84    absl::any o;
85    EXPECT_EQ(typeid(void), o.type());
86    o.emplace<int>(5);
87    EXPECT_EQ(typeid(int), o.type());
88    o.emplace<float>(5.f);
89    EXPECT_EQ(typeid(float), o.type());
90    o.reset();
91    EXPECT_EQ(typeid(void), o.type());
92  }
93  TEST(AnyTest, EmptyPointerCast) {
94    {
95      absl::any o;
96      EXPECT_EQ(nullptr, absl::any_cast<int>(&o));
97      o.emplace<int>();
98      EXPECT_NE(nullptr, absl::any_cast<int>(&o));
99      o.reset();
100      EXPECT_EQ(nullptr, absl::any_cast<int>(&o));
101    }
102    {
103      absl::any o;
104      EXPECT_EQ(nullptr, absl::any_cast<int>(&AsConst(o)));
105      o.emplace<int>();
106      EXPECT_NE(nullptr, absl::any_cast<int>(&AsConst(o)));
107      o.reset();
108      EXPECT_EQ(nullptr, absl::any_cast<int>(&AsConst(o)));
109    }
110  }
111  TEST(AnyTest, InPlaceConstruction) {
112    const CopyOnly copy_only{};
113    absl::any o(absl::in_place_type_t<IntMoveOnlyCopyOnly>(), 5, MoveOnly(),
114                copy_only);
115    IntMoveOnlyCopyOnly& v = absl::any_cast<IntMoveOnlyCopyOnly&>(o);
116    EXPECT_EQ(5, v.value);
117  }
118  TEST(AnyTest, InPlaceConstructionVariableTemplate) {
119    const CopyOnly copy_only{};
120    absl::any o(absl::in_place_type<IntMoveOnlyCopyOnly>, 5, MoveOnly(),
121                copy_only);
122    auto& v = absl::any_cast<IntMoveOnlyCopyOnly&>(o);
123    EXPECT_EQ(5, v.value);
124  }
125  TEST(AnyTest, InPlaceConstructionWithCV) {
126    const CopyOnly copy_only{};
127    absl::any o(absl::in_place_type_t<const volatile IntMoveOnlyCopyOnly>(), 5,
128                MoveOnly(), copy_only);
129    IntMoveOnlyCopyOnly& v = absl::any_cast<IntMoveOnlyCopyOnly&>(o);
130    EXPECT_EQ(5, v.value);
131  }
132  TEST(AnyTest, InPlaceConstructionWithCVVariableTemplate) {
133    const CopyOnly copy_only{};
134    absl::any o(absl::in_place_type<const volatile IntMoveOnlyCopyOnly>, 5,
135                MoveOnly(), copy_only);
136    auto& v = absl::any_cast<IntMoveOnlyCopyOnly&>(o);
137    EXPECT_EQ(5, v.value);
138  }
139  TEST(AnyTest, InPlaceConstructionWithFunction) {
140    absl::any o(absl::in_place_type_t<FunctionType>(), FunctionToEmplace);
141    FunctionType*& construction_result = absl::any_cast<FunctionType*&>(o);
142    EXPECT_EQ(&FunctionToEmplace, construction_result);
143  }
144  TEST(AnyTest, InPlaceConstructionWithFunctionVariableTemplate) {
145    absl::any o(absl::in_place_type<FunctionType>, FunctionToEmplace);
146    auto& construction_result = absl::any_cast<FunctionType*&>(o);
147    EXPECT_EQ(&FunctionToEmplace, construction_result);
148  }
149  TEST(AnyTest, InPlaceConstructionWithArray) {
150    ArrayType ar = {5, 42};
151    absl::any o(absl::in_place_type_t<ArrayType>(), ar);
152    DecayedArray& construction_result = absl::any_cast<DecayedArray&>(o);
153    EXPECT_EQ(&ar[0], construction_result);
154  }
155  TEST(AnyTest, InPlaceConstructionWithArrayVariableTemplate) {
156    ArrayType ar = {5, 42};
157    absl::any o(absl::in_place_type<ArrayType>, ar);
158    auto& construction_result = absl::any_cast<DecayedArray&>(o);
159    EXPECT_EQ(&ar[0], construction_result);
160  }
161  TEST(AnyTest, InPlaceConstructionIlist) {
162    const CopyOnly copy_only{};
163    absl::any o(absl::in_place_type_t<ListMoveOnlyCopyOnly>(), {1, 2, 3, 4},
164                MoveOnly(), copy_only);
165    ListMoveOnlyCopyOnly& v = absl::any_cast<ListMoveOnlyCopyOnly&>(o);
166    std::vector<int> expected_values = {1, 2, 3, 4};
167    EXPECT_EQ(expected_values, v.values);
168  }
169  TEST(AnyTest, InPlaceConstructionIlistVariableTemplate) {
170    const CopyOnly copy_only{};
171    absl::any o(absl::in_place_type<ListMoveOnlyCopyOnly>, {1, 2, 3, 4},
172                MoveOnly(), copy_only);
173    auto& v = absl::any_cast<ListMoveOnlyCopyOnly&>(o);
174    std::vector<int> expected_values = {1, 2, 3, 4};
175    EXPECT_EQ(expected_values, v.values);
176  }
177  TEST(AnyTest, InPlaceConstructionIlistWithCV) {
178    const CopyOnly copy_only{};
179    absl::any o(absl::in_place_type_t<const volatile ListMoveOnlyCopyOnly>(),
180                {1, 2, 3, 4}, MoveOnly(), copy_only);
181    ListMoveOnlyCopyOnly& v = absl::any_cast<ListMoveOnlyCopyOnly&>(o);
182    std::vector<int> expected_values = {1, 2, 3, 4};
183    EXPECT_EQ(expected_values, v.values);
184  }
185  TEST(AnyTest, InPlaceConstructionIlistWithCVVariableTemplate) {
186    const CopyOnly copy_only{};
187    absl::any o(absl::in_place_type<const volatile ListMoveOnlyCopyOnly>,
188                {1, 2, 3, 4}, MoveOnly(), copy_only);
189    auto& v = absl::any_cast<ListMoveOnlyCopyOnly&>(o);
190    std::vector<int> expected_values = {1, 2, 3, 4};
191    EXPECT_EQ(expected_values, v.values);
192  }
193  TEST(AnyTest, InPlaceNoArgs) {
194    absl::any o(absl::in_place_type_t<int>{});
195    EXPECT_EQ(0, absl::any_cast<int&>(o));
196  }
197  TEST(AnyTest, InPlaceNoArgsVariableTemplate) {
198    absl::any o(absl::in_place_type<int>);
199    EXPECT_EQ(0, absl::any_cast<int&>(o));
200  }
201  template <typename Enabler, typename T, typename... Args>
202  struct CanEmplaceAnyImpl : std::false_type {};
203  template <typename T, typename... Args>
204  struct CanEmplaceAnyImpl<
205      absl::void_t<decltype(
206          std::declval<absl::any&>().emplace<T>(std::declval<Args>()...))>,
207      T, Args...> : std::true_type {};
208  template <typename T, typename... Args>
209  using CanEmplaceAny = CanEmplaceAnyImpl<void, T, Args...>;
210  TEST(AnyTest, Emplace) {
211    const CopyOnly copy_only{};
212    absl::any o;
213    EXPECT_TRUE((std::is_same<decltype(o.emplace<IntMoveOnlyCopyOnly>(
214                                  5, MoveOnly(), copy_only)),
215                              IntMoveOnlyCopyOnly&>::value));
216    IntMoveOnlyCopyOnly& emplace_result =
217        o.emplace<IntMoveOnlyCopyOnly>(5, MoveOnly(), copy_only);
218    EXPECT_EQ(5, emplace_result.value);
219    IntMoveOnlyCopyOnly& v = absl::any_cast<IntMoveOnlyCopyOnly&>(o);
220    EXPECT_EQ(5, v.value);
221    EXPECT_EQ(&emplace_result, &v);
222    static_assert(!CanEmplaceAny<int, int, int>::value, "");
223    static_assert(!CanEmplaceAny<MoveOnly, MoveOnly>::value, "");
224  }
225  TEST(AnyTest, EmplaceWithCV) {
226    const CopyOnly copy_only{};
227    absl::any o;
228    EXPECT_TRUE(
229        (std::is_same<decltype(o.emplace<const volatile IntMoveOnlyCopyOnly>(
230                          5, MoveOnly(), copy_only)),
231                      IntMoveOnlyCopyOnly&>::value));
232    IntMoveOnlyCopyOnly& emplace_result =
233        o.emplace<const volatile IntMoveOnlyCopyOnly>(5, MoveOnly(), copy_only);
234    EXPECT_EQ(5, emplace_result.value);
235    IntMoveOnlyCopyOnly& v = absl::any_cast<IntMoveOnlyCopyOnly&>(o);
236    EXPECT_EQ(5, v.value);
237    EXPECT_EQ(&emplace_result, &v);
238  }
239  TEST(AnyTest, EmplaceWithFunction) {
240    absl::any o;
241    EXPECT_TRUE(
242        (std::is_same<decltype(o.emplace<FunctionType>(FunctionToEmplace)),
243                      FunctionType*&>::value));
244    FunctionType*& emplace_result = o.emplace<FunctionType>(FunctionToEmplace);
245    EXPECT_EQ(&FunctionToEmplace, emplace_result);
246  }
247  TEST(AnyTest, EmplaceWithArray) {
248    absl::any o;
249    ArrayType ar = {5, 42};
250    EXPECT_TRUE(
251        (std::is_same<decltype(o.emplace<ArrayType>(ar)), DecayedArray&>::value));
252    DecayedArray& emplace_result = o.emplace<ArrayType>(ar);
253    EXPECT_EQ(&ar[0], emplace_result);
254  }
255  TEST(AnyTest, EmplaceIlist) {
256    const CopyOnly copy_only{};
257    absl::any o;
258    EXPECT_TRUE((std::is_same<decltype(o.emplace<ListMoveOnlyCopyOnly>(
259                                  {1, 2, 3, 4}, MoveOnly(), copy_only)),
260                              ListMoveOnlyCopyOnly&>::value));
261    ListMoveOnlyCopyOnly& emplace_result =
262        o.emplace<ListMoveOnlyCopyOnly>({1, 2, 3, 4}, MoveOnly(), copy_only);
263    ListMoveOnlyCopyOnly& v = absl::any_cast<ListMoveOnlyCopyOnly&>(o);
264    EXPECT_EQ(&v, &emplace_result);
265    std::vector<int> expected_values = {1, 2, 3, 4};
266    EXPECT_EQ(expected_values, v.values);
267    static_assert(!CanEmplaceAny<int, std::initializer_list<int>>::value, "");
268    static_assert(!CanEmplaceAny<MoveOnlyWithListConstructor,
269                                 std::initializer_list<int>, int>::value,
270                  "");
271  }
272  TEST(AnyTest, EmplaceIlistWithCV) {
273    const CopyOnly copy_only{};
274    absl::any o;
275    EXPECT_TRUE(
276        (std::is_same<decltype(o.emplace<const volatile ListMoveOnlyCopyOnly>(
277                          {1, 2, 3, 4}, MoveOnly(), copy_only)),
278                      ListMoveOnlyCopyOnly&>::value));
279    ListMoveOnlyCopyOnly& emplace_result =
280        o.emplace<const volatile ListMoveOnlyCopyOnly>({1, 2, 3, 4}, MoveOnly(),
281                                                       copy_only);
282    ListMoveOnlyCopyOnly& v = absl::any_cast<ListMoveOnlyCopyOnly&>(o);
283    EXPECT_EQ(&v, &emplace_result);
284    std::vector<int> expected_values = {1, 2, 3, 4};
285    EXPECT_EQ(expected_values, v.values);
286  }
287  TEST(AnyTest, EmplaceNoArgs) {
288    absl::any o;
289    o.emplace<int>();
290    EXPECT_EQ(0, absl::any_cast<int>(o));
291  }
292  TEST(AnyTest, ConversionConstruction) {
293    {
294      absl::any o = 5;
295      EXPECT_EQ(5, absl::any_cast<int>(o));
296    }
297    {
298      const CopyOnly copy_only(5);
299      absl::any o = copy_only;
300      EXPECT_EQ(5, absl::any_cast<CopyOnly&>(o).value);
301    }
302    static_assert(!std::is_convertible<MoveOnly, absl::any>::value, "");
303  }
304  TEST(AnyTest, ConversionAssignment) {
305    {
306      absl::any o;
307      o = 5;
308      EXPECT_EQ(5, absl::any_cast<int>(o));
309    }
310    {
311      const CopyOnly copy_only(5);
312      absl::any o;
313      o = copy_only;
314      EXPECT_EQ(5, absl::any_cast<CopyOnly&>(o).value);
315    }
316    static_assert(!std::is_assignable<MoveOnly, absl::any>::value, "");
317  }
318  #ifdef _MSC_VER
319  #pragma warning( push )
320  #pragma warning( disable : 4521)
321  #endif
322  struct WeirdConstructor42 {
323    explicit WeirdConstructor42(int value) : value(value) {}
324    WeirdConstructor42(const WeirdConstructor42& other) : value(other.value) {}
325    WeirdConstructor42(
326        WeirdConstructor42& &bsol;*other*/)  
327        : value(42) {}
328    int value;
329  };
330  #ifdef _MSC_VER
331  #pragma warning( pop )
332  #endif
333  TEST(AnyTest, WeirdConversionConstruction) {
334    {
335      const WeirdConstructor42 source(5);
336      absl::any o = source;  
337      EXPECT_EQ(5, absl::any_cast<WeirdConstructor42&>(o).value);
338    }
339    {
340      WeirdConstructor42 source(5);
341      absl::any o = source;  
342      EXPECT_EQ(42, absl::any_cast<WeirdConstructor42&>(o).value);
343    }
344  }
345  TEST(AnyTest, WeirdConversionAssignment) {
346    {
347      const WeirdConstructor42 source(5);
348      absl::any o;
349      o = source;  
350      EXPECT_EQ(5, absl::any_cast<WeirdConstructor42&>(o).value);
351    }
352    {
353      WeirdConstructor42 source(5);
354      absl::any o;
355      o = source;  
356      EXPECT_EQ(42, absl::any_cast<WeirdConstructor42&>(o).value);
357    }
358  }
359  struct Value {};
360  TEST(AnyTest, AnyCastValue) {
361    {
362      absl::any o;
363      o.emplace<int>(5);
364      EXPECT_EQ(5, absl::any_cast<int>(o));
365      EXPECT_EQ(5, absl::any_cast<int>(AsConst(o)));
366      static_assert(
367          std::is_same<decltype(absl::any_cast<Value>(o)), Value>::value, "");
368    }
369    {
370      absl::any o;
371      o.emplace<int>(5);
372      EXPECT_EQ(5, absl::any_cast<const int>(o));
373      EXPECT_EQ(5, absl::any_cast<const int>(AsConst(o)));
374      static_assert(std::is_same<decltype(absl::any_cast<const Value>(o)),
375                                 const Value>::value,
376                    "");
377    }
378  }
379  TEST(AnyTest, AnyCastReference) {
380    {
381      absl::any o;
382      o.emplace<int>(5);
383      EXPECT_EQ(5, absl::any_cast<int&>(o));
384      EXPECT_EQ(5, absl::any_cast<const int&>(AsConst(o)));
385      static_assert(
386          std::is_same<decltype(absl::any_cast<Value&>(o)), Value&>::value, "");
387    }
388    {
389      absl::any o;
390      o.emplace<int>(5);
391      EXPECT_EQ(5, absl::any_cast<const int>(o));
392      EXPECT_EQ(5, absl::any_cast<const int>(AsConst(o)));
393      static_assert(std::is_same<decltype(absl::any_cast<const Value&>(o)),
394                                 const Value&>::value,
395                    "");
396    }
397    {
398      absl::any o;
399      o.emplace<int>(5);
400      EXPECT_EQ(5, absl::any_cast<int&&>(std::move(o)));
401      static_assert(std::is_same<decltype(absl::any_cast<Value&&>(std::move(o))),
402                                 Value&&>::value,
403                    "");
404    }
405    {
406      absl::any o;
407      o.emplace<int>(5);
408      EXPECT_EQ(5, absl::any_cast<const int>(std::move(o)));
409      static_assert(
410          std::is_same<decltype(absl::any_cast<const Value&&>(std::move(o))),
411                       const Value&&>::value,
412          "");
413    }
414  }
415  TEST(AnyTest, AnyCastPointer) {
416    {
417      absl::any o;
418      EXPECT_EQ(nullptr, absl::any_cast<char>(&o));
419      o.emplace<int>(5);
420      EXPECT_EQ(nullptr, absl::any_cast<char>(&o));
421      o.emplace<char>('a');
422      EXPECT_EQ('a', *absl::any_cast<char>(&o));
423      static_assert(
424          std::is_same<decltype(absl::any_cast<Value>(&o)), Value*>::value, "");
425    }
426    {
427      absl::any o;
428      EXPECT_EQ(nullptr, absl::any_cast<const char>(&o));
429      o.emplace<int>(5);
430      EXPECT_EQ(nullptr, absl::any_cast<const char>(&o));
431      o.emplace<char>('a');
432      EXPECT_EQ('a', *absl::any_cast<const char>(&o));
433      static_assert(std::is_same<decltype(absl::any_cast<const Value>(&o)),
434                                 const Value*>::value,
435                    "");
436    }
437  }
438  TEST(AnyTest, MakeAny) {
439    const CopyOnly copy_only{};
440    auto o = absl::make_any<IntMoveOnlyCopyOnly>(5, MoveOnly(), copy_only);
441    static_assert(std::is_same<decltype(o), absl::any>::value, "");
442    EXPECT_EQ(5, absl::any_cast<IntMoveOnlyCopyOnly&>(o).value);
443  }
444  TEST(AnyTest, MakeAnyIList) {
445    const CopyOnly copy_only{};
446    auto o =
447        absl::make_any<ListMoveOnlyCopyOnly>({1, 2, 3}, MoveOnly(), copy_only);
448    static_assert(std::is_same<decltype(o), absl::any>::value, "");
449    ListMoveOnlyCopyOnly& v = absl::any_cast<ListMoveOnlyCopyOnly&>(o);
450    std::vector<int> expected_values = {1, 2, 3};
451    EXPECT_EQ(expected_values, v.values);
452  }
453  TEST(AnyTest, Copy) {
454    InstanceTracker tracker_raii;
455    {
456      absl::any o(absl::in_place_type<CopyableOnlyInstance>, 123);
457      CopyableOnlyInstance* f1 = absl::any_cast<CopyableOnlyInstance>(&o);
458      absl::any o2(o);
459      const CopyableOnlyInstance* f2 = absl::any_cast<CopyableOnlyInstance>(&o2);
460      EXPECT_EQ(123, f2->value());
461      EXPECT_NE(f1, f2);
462      absl::any o3;
463      o3 = o2;
464      const CopyableOnlyInstance* f3 = absl::any_cast<CopyableOnlyInstance>(&o3);
465      EXPECT_EQ(123, f3->value());
466      EXPECT_NE(f2, f3);
467      const absl::any o4(4);
468      absl::any o5 = o4;
469      EXPECT_EQ(4, absl::any_cast<int>(o4));
470      EXPECT_EQ(4, absl::any_cast<int>(o5));
471      absl::any o6 = std::move(o4);  
472      EXPECT_EQ(4, absl::any_cast<int>(o4));
473      EXPECT_EQ(4, absl::any_cast<int>(o6));
474    }
475  }
476  TEST(AnyTest, Move) {
477    InstanceTracker tracker_raii;
478    absl::any any1;
479    any1.emplace<CopyableOnlyInstance>(5);
480    absl::any any2 = any1;
481    EXPECT_EQ(5, absl::any_cast<CopyableOnlyInstance&>(any1).value());
482    EXPECT_EQ(5, absl::any_cast<CopyableOnlyInstance&>(any2).value());
483    EXPECT_EQ(1, tracker_raii.copies());
484    absl::any any3 = std::move(any2);
485    EXPECT_EQ(5, absl::any_cast<CopyableOnlyInstance&>(any3).value());
486    EXPECT_EQ(1, tracker_raii.copies());
487    absl::any any4;
488    any4 = std::move(any3);
489    EXPECT_EQ(5, absl::any_cast<CopyableOnlyInstance&>(any4).value());
490    EXPECT_EQ(1, tracker_raii.copies());
491    absl::any tmp4(4);
492    absl::any o4(std::move(tmp4));  
493    EXPECT_EQ(4, absl::any_cast<int>(o4));
494    o4 = *&o4;  
495    EXPECT_EQ(4, absl::any_cast<int>(o4));
496    EXPECT_TRUE(o4.has_value());
497    absl::any o5;
498    absl::any tmp5(5);
499    o5 = std::move(tmp5);  
500    EXPECT_EQ(5, absl::any_cast<int>(o5));
501  }
502  TEST(AnyTest, Reset) {
503    absl::any o;
504    o.emplace<int>();
505    o.reset();
506    EXPECT_FALSE(o.has_value());
507    o.emplace<char>();
508    EXPECT_TRUE(o.has_value());
509  }
510  TEST(AnyTest, ConversionConstructionCausesOneCopy) {
511    InstanceTracker tracker_raii;
512    CopyableOnlyInstance counter(5);
513    absl::any o(counter);
514    EXPECT_EQ(5, absl::any_cast<CopyableOnlyInstance&>(o).value());
515    EXPECT_EQ(1, tracker_raii.copies());
516  }
517  #if defined(ABSL_USES_STD_ANY)
518  #define ABSL_ANY_TEST_EXPECT_BAD_ANY_CAST(...)                      \
519    ABSL_BASE_INTERNAL_EXPECT_FAIL((__VA_ARGS__), absl::bad_any_cast, \
520                                   "")
521  #else
522  #define ABSL_ANY_TEST_EXPECT_BAD_ANY_CAST(...)                      \
523    ABSL_BASE_INTERNAL_EXPECT_FAIL((__VA_ARGS__), absl::bad_any_cast, \
524                                   "Bad any cast")
525  #endif  
526  TEST(AnyTest, ThrowBadAlloc) {
527    {
528      absl::any a;
529      ABSL_ANY_TEST_EXPECT_BAD_ANY_CAST(absl::any_cast<int&>(a));
530      ABSL_ANY_TEST_EXPECT_BAD_ANY_CAST(absl::any_cast<const int&>(a));
531      ABSL_ANY_TEST_EXPECT_BAD_ANY_CAST(absl::any_cast<int&&>(absl::any{}));
532      ABSL_ANY_TEST_EXPECT_BAD_ANY_CAST(absl::any_cast<const int&&>(absl::any{}));
533      ABSL_ANY_TEST_EXPECT_BAD_ANY_CAST(absl::any_cast<int>(a));
534      ABSL_ANY_TEST_EXPECT_BAD_ANY_CAST(absl::any_cast<const int>(a));
535      ABSL_ANY_TEST_EXPECT_BAD_ANY_CAST(absl::any_cast<int>(absl::any{}));
536      ABSL_ANY_TEST_EXPECT_BAD_ANY_CAST(absl::any_cast<const int>(absl::any{}));
537      ABSL_ANY_TEST_EXPECT_BAD_ANY_CAST(absl::any_cast<const int&>(AsConst(a)));
538      ABSL_ANY_TEST_EXPECT_BAD_ANY_CAST(absl::any_cast<int>(AsConst(a)));
539      ABSL_ANY_TEST_EXPECT_BAD_ANY_CAST(absl::any_cast<const int>(AsConst(a)));
540    }
541    {
542      absl::any a(absl::in_place_type<int>);
543      ABSL_ANY_TEST_EXPECT_BAD_ANY_CAST(absl::any_cast<float&>(a));
544      ABSL_ANY_TEST_EXPECT_BAD_ANY_CAST(absl::any_cast<const float&>(a));
545      ABSL_ANY_TEST_EXPECT_BAD_ANY_CAST(absl::any_cast<float&&>(absl::any{}));
546      ABSL_ANY_TEST_EXPECT_BAD_ANY_CAST(
547          absl::any_cast<const float&&>(absl::any{}));
548      ABSL_ANY_TEST_EXPECT_BAD_ANY_CAST(absl::any_cast<float>(a));
549      ABSL_ANY_TEST_EXPECT_BAD_ANY_CAST(absl::any_cast<const float>(a));
550      ABSL_ANY_TEST_EXPECT_BAD_ANY_CAST(absl::any_cast<float>(absl::any{}));
551      ABSL_ANY_TEST_EXPECT_BAD_ANY_CAST(absl::any_cast<const float>(absl::any{}));
552      ABSL_ANY_TEST_EXPECT_BAD_ANY_CAST(absl::any_cast<const float&>(AsConst(a)));
553      ABSL_ANY_TEST_EXPECT_BAD_ANY_CAST(absl::any_cast<float>(AsConst(a)));
554      ABSL_ANY_TEST_EXPECT_BAD_ANY_CAST(absl::any_cast<const float>(AsConst(a)));
555    }
556  }
557  class BadCopy {};
558  struct BadCopyable {
559    BadCopyable() = default;
560    BadCopyable(BadCopyable&&) = default;
561    BadCopyable(const BadCopyable&) {
562  #ifdef ABSL_HAVE_EXCEPTIONS
563      throw BadCopy();
564  #else
565      LOG(FATAL) << "Bad copy";
566  #endif
567    }
568  };
569  #define ABSL_ANY_TEST_EXPECT_BAD_COPY(...) \
570    ABSL_BASE_INTERNAL_EXPECT_FAIL((__VA_ARGS__), BadCopy, "Bad copy")
571  TEST(AnyTest, FailedCopy) {
572    {
573      const BadCopyable bad{};
574      ABSL_ANY_TEST_EXPECT_BAD_COPY(absl::any{bad});
575    }
576    {
577      absl::any src(absl::in_place_type<BadCopyable>);
578      ABSL_ANY_TEST_EXPECT_BAD_COPY(absl::any{src});
579    }
580    {
581      BadCopyable bad;
582      absl::any target;
583      ABSL_ANY_TEST_EXPECT_BAD_COPY(target = bad);
584    }
585    {
586      BadCopyable bad;
587      absl::any target(absl::in_place_type<BadCopyable>);
588      ABSL_ANY_TEST_EXPECT_BAD_COPY(target = bad);
589      EXPECT_TRUE(target.has_value());
590    }
591    {
592      absl::any src(absl::in_place_type<BadCopyable>);
593      absl::any target;
594      ABSL_ANY_TEST_EXPECT_BAD_COPY(target = src);
595      EXPECT_FALSE(target.has_value());
596    }
597    {
598      absl::any src(absl::in_place_type<BadCopyable>);
599      absl::any target(absl::in_place_type<BadCopyable>);
600      ABSL_ANY_TEST_EXPECT_BAD_COPY(target = src);
601      EXPECT_TRUE(target.has_value());
602    }
603  }
<span onclick='openModal()' class='match'>604  TEST(AnyTest, FailedEmplace) {
605    BadCopyable bad;
606    absl::any target;
607    ABSL_ANY_TEST_EXPECT_BAD_COPY(target.emplace<BadCopyable>(bad));
</span>608  }
609  #ifdef __GNUC__
610  TEST(AnyTest, DISABLED_FailedEmplaceInPlace) {
611  #else
612  TEST(AnyTest, FailedEmplaceInPlace) {
613  #endif
614    BadCopyable bad;
615    absl::any target(absl::in_place_type<int>);
616    ABSL_ANY_TEST_EXPECT_BAD_COPY(target.emplace<BadCopyable>(bad));
617    EXPECT_FALSE(target.has_value());
618  }
619  }  
620  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-any_test.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-any_test.cc</div>
                </div>
                <div class="column column_space"><pre><code>604  TEST(AnyTest, FailedEmplace) {
605    BadCopyable bad;
606    absl::any target;
607    ABSL_ANY_TEST_EXPECT_BAD_COPY(target.emplace<BadCopyable>(bad));
</pre></code></div>
                <div class="column column_space"><pre><code>604  TEST(AnyTest, FailedEmplace) {
605    BadCopyable bad;
606    absl::any target;
607    ABSL_ANY_TEST_EXPECT_BAD_COPY(target.emplace<BadCopyable>(bad));
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    