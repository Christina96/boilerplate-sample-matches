
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 33, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-localmotifcluster.cpp</h3>
            <pre><code>1  #include "localmotifcluster.h"
2  #include "stdafx.h"
3  MotifType ParseMotifType(const TStr& motif, const bool& IsDirected) {
4    TStr motif_lc = motif.GetLc();
5    if (IsDirected) {
6      if      (motif_lc == "m1")          { return M1; }
7      else if (motif_lc == "m2")          { return M2; }
8      else if (motif_lc == "m3")          { return M3; }
9      else if (motif_lc == "m4")          { return M4; }
10      else if (motif_lc == "m5")          { return M5; }
11      else if (motif_lc == "m6")          { return M6; }
12      else if (motif_lc == "m7")          { return M7; }
13      else if (motif_lc == "triad")          { return triad; }
14      else if (motif_lc == "cycle")          { return cycle; }
15      else if (motif_lc == "ffloop")          { return FFLoop; }
16      else if (motif_lc == "unide")          { return UniDE; }
17      else if (motif_lc == "bide")          { return BiDE; }
18      else if (motif_lc == "de")          { return DE; }
19      else if (motif_lc == "edge")          { return DE_any; }
20      else { 
21        TExcept::Throw("Unknown motif for directed graph!"); 
22      }
23    } else {
24      if      (motif_lc == "uedge")     { return UEdge; }
25      else if (motif_lc == "clique3")     { return clique3; }
26      else if (motif_lc == "clique4")     { return clique4; }
27      else if (motif_lc == "clique5")     { return clique5; }
28      else if (motif_lc == "clique6")     { return clique6; }
29      else if (motif_lc == "clique7")     { return clique7; }
30      else if (motif_lc == "clique8")     { return clique8; }
31      else if (motif_lc == "clique9")     { return clique9; }
32      else { TExcept::Throw("Unknown motif for undirected graph!"); }
33    }
34    TExcept::Throw("Inappropriate input!"); 
35    return UEdge;
36  }
37  void printMotifType(const MotifType& type) {
38    switch (type) {
39      case M1:      printf("M1\n"); break;
40      case M2:      printf("M2\n"); break;
41      case M3:      printf("M3\n"); break;
42      case M4:      printf("M4\n"); break;
43      case M5:      printf("M5\n"); break;
44      case M6:      printf("M6\n"); break;
45      case M7:      printf("M7\n"); break;
46      case triad:   printf("triad\n"); break;
47      case cycle:   printf("cycle\n"); break;
48      case FFLoop:  printf("FFLoop\n"); break;
49      case UniDE:   printf("UniDE\n"); break;
50      case BiDE:    printf("BiDE\n"); break;
51      case DE:      printf("DE\n"); break;
52      case DE_any:  printf("DE_any\n"); break;
53      case UEdge:       printf("UEdge\n"); break;
54      case clique3:     printf("clique3\n"); break;
55      case clique4:     printf("clique4\n"); break;
56      case clique5:     printf("clique5\n"); break;
57      case clique6:     printf("clique6\n"); break;
58      case clique7:     printf("clique7\n"); break;
59      case clique8:     printf("clique8\n"); break;
60      case clique9:     printf("clique9\n"); break;
61      default:
62        TExcept::Throw("Unknown motif type!");
63    }
64  }
65  int getCliqueSize(const MotifType& type) {
66    switch (type) {
67      case UEdge:       return 2;
68      case clique3:     return 3;
69      case clique4:     return 4;
70      case clique5:     return 5;
71      case clique6:     return 6;
72      case clique7:     return 7;
73      case clique8:     return 8;
74      case clique9:     return 9;
75      default: {
76        TExcept::Throw("Unknown motif for undirected graph!"); 
77        return -1;
78      }         
79    }
80  }
81  ProcessedGraph::ProcessedGraph(PUNGraph graph, MotifType mt){
82    Graph_org = graph;
83    assignWeights_undir(mt);
84  }
85  bool higherDeg(PUNGraph& G, TUNGraph::TNodeI& NI1, int nodeID2) {
86    TUNGraph::TNodeI NI2 = G->GetNI(nodeID2);
87    if (NI1.GetOutDeg() > NI2.GetOutDeg()) {
88      return true;
89    } else if (NI1.GetOutDeg() == NI2.GetOutDeg() && NI1.GetId() > nodeID2) {
90      return true;
91    } else {
92      return false;
93    }
94  }
95  bool higherDeg(PUNGraph& G, int nodeID1, int nodeID2) {
96    TUNGraph::TNodeI NI1 = G->GetNI(nodeID1);
97    return higherDeg(G, NI1, nodeID2);
98  }
99  void ProcessedGraph::countClique(PUNGraph& G, int KSize, TIntV& PrevNodes, int level) {
100    if (level >= KSize - 1) {
101      throw "exception!!";
102    }
103    if (level >= 1) {
104      for (TUNGraph::TEdgeI EI = G->BegEI(); EI < G->EndEI(); EI ++ ) {
105        int SrcNId = EI.GetSrcNId();
106        int DstNId = EI.GetDstNId();
107        Counts[SrcNId](DstNId)[level-1] ++;
108        Counts[DstNId](SrcNId)[level-1] ++;
109      }
110    }
111    for (TUNGraph::TNodeI NI = G->BegNI(); NI < G->EndNI(); NI ++ ) {
112      int NodeId = NI.GetId();
113      int degHere = NI.GetOutDeg();
114      for (int i = 0; i < level; i ++) {
115        Counts[PrevNodes[i]](NodeId)[level-1] += degHere;
116        Counts[NodeId](PrevNodes[i])[level-1] += degHere;
117      }
118      if (level == KSize - 2) {
119        continue;
120      }
121      PrevNodes[level] = NodeId;
122      TIntV neighborsID;
123      for (int e = 0; e < NI.GetOutDeg(); e++) {
124        int nbrID = NI.GetOutNId(e);
125        if (higherDeg(G, NodeId, nbrID)) {
126            neighborsID.Add(nbrID);
127        }
128      }
129      PUNGraph subGraph = TSnap::GetSubGraph(G, neighborsID);
130      int numEdges = subGraph->GetEdges();
131      for (int i = 0; i <= level; i ++) {
132        for (int j = i + 1; j <= level; j ++) {
133          Counts[PrevNodes[i]](PrevNodes[j])[level] += numEdges;
134          Counts[PrevNodes[j]](PrevNodes[i])[level] += numEdges;
135        }
136      }
137      countClique(subGraph, KSize, PrevNodes, level + 1);
138    }
139  }
140  void ProcessedGraph::assignWeights_undir(MotifType mt) {
141    Weights = WeightVH(Graph_org->GetMxNId());
142    Graph_trans = TSnap::ConvertGraph<PUNGraph>(Graph_org);
143    int KSize = getCliqueSize(mt);
144    if (KSize == 2) {
145      for (TUNGraph::TNodeI NI = Graph_org->BegNI(); NI < Graph_org->EndNI(); NI ++ ) {
146        int NodeId = NI.GetId();
147        for (int e = 0; e < NI.GetOutDeg(); e++) {
148          Weights[NodeId](NI.GetOutNId(e)) = 1;
149        }
150        Weights[NodeId](NodeId) = NI.GetOutDeg();
151      }
152      TotalVol = 2 * Graph_org->GetEdges();
153    } else { 
154      if (Counts.Len() == 0 || Counts.BegI()->Len() == 0 || Counts.BegI()->BegI()->Dat.Len() < KSize - 2) {
155        Counts = CountVH(Graph_org->GetMxNId());
156        for (TUNGraph::TNodeI NI = Graph_org->BegNI(); NI < Graph_org->EndNI(); NI ++ ) {
157          int NodeId = NI.GetId();
158          for (int e = 0; e < NI.GetOutDeg(); e++) {
159            Counts[NodeId](NI.GetOutNId(e)) = TIntV(KSize - 2);
160          }
161        }
162        TIntV PrevNodes(KSize - 2);
163        countClique(Graph_org, KSize, PrevNodes, 0);
164      }
165      TotalVol = 0;
166      for (TUNGraph::TNodeI NI = Graph_org->BegNI(); NI < Graph_org->EndNI(); NI ++ ) {
167        int NodeId = NI.GetId();
168        float deg_w = 0;
169        for (int e = 0; e < NI.GetOutDeg(); e++) {
170          int NbrId = NI.GetOutNId(e);
171          int MtfCntHere = Counts[NodeId](NbrId)[KSize-3];
172          if (MtfCntHere) {
173            Weights[NodeId](NbrId) = MtfCntHere;
<span onclick='openModal()' class='match'>174            deg_w += MtfCntHere;
175          } else {
176            Graph_trans->DelEdge(NodeId, NbrId);
177          }
178        }
179        Weights[NodeId](NodeId) = deg_w;
180        TotalVol += deg_w;
181      }
182    }
</span>183  }
184  ProcessedGraph::ProcessedGraph(PNGraph graph, MotifType mt){
185    Graph_org = TSnap::ConvertGraph<PUNGraph>(graph);
186    countDirTriadMotif(graph);
187    assignWeights_dir(mt);
188  }
189  int checkEdge(PNGraph& G, long nodeID, long nbrID) {
190    if (G->IsEdge(nodeID, nbrID)) {
191      if (G->IsEdge(nbrID, nodeID)) {
192        return 0;
193      } else {
194        return 1;
195      }
196    } else {
197      return 2;
198    }
199  }
200  int checkTriadMotif(PNGraph& G, long nodeID, long srcNId, long dstNId) {
201    int motifType = 0;
202    if (G->IsEdge(dstNId, srcNId)) {
203      switch (checkEdge(G, nodeID, dstNId)) {
204        case 0: {
205          switch (checkEdge(G, nodeID, srcNId)) {
206            case 0: {
207              motifType = 4;
208              break;
209            }
210            case 1: {
211              motifType = 3;
212              break;
213            }
214            case 2: {
215              motifType = 3;
216            }
217          }
218          break;
219        }
220        case 1: {
221          switch (checkEdge(G, nodeID, srcNId)) {
222            case 0: {
223              motifType = 3;
224              break;
225            }
226            case 1: {
227              motifType = 6;
228              break;
229            }
230            case 2: {
231              motifType = 2;
232            }
233          }
234          break;
235        }
236        case 2: {
237          switch (checkEdge(G, nodeID, srcNId)) {
238            case 0: {
239              motifType = 3;
240              break;
241            }
242            case 1: {
243              motifType = 2;
244              break;
245            }
246            case 2: {
247              motifType = 7;
248            }
249          }
250        }
251      }
252    } else {
253      switch (checkEdge(G, nodeID, dstNId)) {
254        case 0: {
255          switch (checkEdge(G, nodeID, srcNId)) {
256            case 0: {
257              motifType = 3;
258              break;
259            }
260            case 1: {
261              motifType = 2;
262              break;
263            }
264            case 2: {
265              motifType = 6;
266            }
267          }
268          break;
269        }
270        case 1: {
271          switch (checkEdge(G, nodeID, srcNId)) {
272            case 0: {
273              motifType = 7;
274              break;
275            }
276            case 1: {
277              motifType = 5;
278              break;
279            }
280            case 2: {
281              motifType = 5;
282            }
283          }
284          break;
285        }
286        case 2: {
287          switch (checkEdge(G, nodeID, srcNId)) {
288            case 0: {
289              motifType = 2;
290              break;
291            }
292            case 1: {
293              motifType = 1;
294              break;
295            }
296            case 2: {
297              motifType = 5;
298            }
299          }
300        }
301      }
302    }
303    return motifType;
304  }
305  bool higherDeg(PNGraph& G, TNGraph::TNodeI& NI1, int nodeID2) {
306    TNGraph::TNodeI NI2 = G->GetNI(nodeID2);
307    if (NI1.GetOutDeg() > NI2.GetOutDeg()) {
308      return true;
309    } else if (NI1.GetOutDeg() == NI2.GetOutDeg() && NI1.GetId() > nodeID2) {
310      return true;
311    } else {
312      return false;
313    }
314  }
315  bool higherDeg(PNGraph& G, int nodeID1, int nodeID2) {
316    TNGraph::TNodeI NI1 = G->GetNI(nodeID1);
317    return higherDeg(G, NI1, nodeID2);
318  }
319  void ProcessedGraph::countDirTriadMotif(PNGraph graph) {
320    int numBasicDirMtf = 9;
321    Counts = CountVH(Graph_org->GetMxNId());
322    for (TUNGraph::TNodeI NI = Graph_org->BegNI(); NI < Graph_org->EndNI(); NI ++ ) {
323      int NodeId = NI.GetId();
324      for (int e = 0; e < NI.GetOutDeg(); e++) {
325        Counts[NodeId](NI.GetOutNId(e)) = TIntV(numBasicDirMtf);
326      }
327    }
328    for (TNGraph::TNodeI NI = graph->BegNI(); NI < graph->EndNI(); NI ++ ) {
329      long nodeID = NI.GetId();
330      TIntV neighborsID;
331      for (long e = 0; e < NI.GetOutDeg(); e++) {
332        long nbrID = NI.GetOutNId(e);
333        if (higherDeg(graph, nodeID, nbrID)) {
334          neighborsID.Add(nbrID);
335          Counts[nodeID](nbrID)[0] ++;
336          Counts[nbrID](nodeID)[0] ++;
337        }
338      }
339      for (long e = 0; e < NI.GetInDeg(); e++) {
340        long nbrID = NI.GetInNId(e);
341        if (higherDeg(graph, nodeID, nbrID)) {
342          if (graph->IsEdge(nodeID, nbrID)) {
343            Counts[nodeID](nbrID)[0] --;
344            Counts[nbrID](nodeID)[0] --;
345            Counts[nodeID](nbrID)[1] ++;
346            Counts[nbrID](nodeID)[1] ++;
347          } else {
348            neighborsID.Add(nbrID);
349            Counts[nodeID](nbrID)[0] ++;
350            Counts[nbrID](nodeID)[0] ++;
351          }
352        }
353      }
354      PNGraph subGraph = TSnap::GetSubGraph(graph, neighborsID);
355      for (TNGraph::TEdgeI EI = subGraph->BegEI(); EI < subGraph->EndEI(); EI ++ ) { 
356        long srcNId = EI.GetSrcNId();
357        long dstNId = EI.GetDstNId();
358        int MotifNumber = 0;
359        if (srcNId > dstNId || !subGraph->IsEdge(dstNId, srcNId)) {
360          MotifNumber = checkTriadMotif(graph, nodeID, srcNId, dstNId);
361          MotifNumber ++;
362          Counts[nodeID](srcNId)[MotifNumber] ++;
363          Counts[srcNId](nodeID)[MotifNumber] ++;
364          Counts[nodeID](dstNId)[MotifNumber] ++;
365          Counts[dstNId](nodeID)[MotifNumber] ++;
366          Counts[srcNId](dstNId)[MotifNumber] ++;
367          Counts[dstNId](srcNId)[MotifNumber] ++;
368        }
369      }
370    }
371    return;
372  }
373  void ProcessedGraph::assignWeights_dir(MotifType mt) {
374    TIntV MtfInclude;
375    switch (mt) {
376      case UniDE :      {MtfInclude.Add(0); break;}
377      case BiDE :       MtfInclude.Add(1); break;
378      case DE :         MtfInclude.Add(0); MtfInclude.Add(1); MtfInclude.Add(1); break;
379      case DE_any :     MtfInclude.Add(0); MtfInclude.Add(1); break;
380      case M1 :         MtfInclude.Add(2); break;
381      case M2 :         MtfInclude.Add(3); break;
382      case M3 :         MtfInclude.Add(4); break;
383      case M4 :         MtfInclude.Add(5); break;
384      case M5 :         MtfInclude.Add(6); break;
385      case M6 :         MtfInclude.Add(7); break;
386      case M7 :         MtfInclude.Add(8); break;
387      case triad : {
388        MtfInclude.Add(2); 
389        MtfInclude.Add(3); 
390        MtfInclude.Add(4); 
391        MtfInclude.Add(5); 
392        MtfInclude.Add(6); 
393        MtfInclude.Add(7); 
394        MtfInclude.Add(8); 
395        break;
396      }
397      case cycle : {
398        MtfInclude.Add(2); 
399        MtfInclude.Add(3); 
400        MtfInclude.Add(4); 
401        MtfInclude.Add(5); 
402        MtfInclude.Add(5); 
403        break;
404      }
405      case FFLoop : {
406        MtfInclude.Add(6); 
407        MtfInclude.Add(7); 
408        MtfInclude.Add(7); 
409        MtfInclude.Add(8); 
410        MtfInclude.Add(8); 
411        break;
412      default:
413        TExcept::Throw("Unknown motif type!");
414      }    
415    }
416    Graph_trans = TSnap::ConvertGraph<PUNGraph>(Graph_org);
417    Weights = WeightVH(Graph_org->GetMxNId());
418    TotalVol = 0;
419    for (TUNGraph::TNodeI NI = Graph_org->BegNI(); NI < Graph_org->EndNI(); NI ++ ) {
420      int NodeId = NI.GetId();
421      float deg_w = 0;
422      for (int e = 0; e < NI.GetOutDeg(); e++) {
423        int NbrId = NI.GetOutNId(e);
424        TIntV& CountHere = Counts[NodeId](NbrId);
425        int WeightHere = 0;
426        for (int i = 0; i < MtfInclude.Len(); i ++) {
427          WeightHere += CountHere[MtfInclude[i]];
428        }
429        if (WeightHere) {
430          Weights[NodeId](NbrId) = WeightHere;
431          deg_w += WeightHere;
432        } else {
433          Graph_trans->DelEdge(NodeId, NbrId);
434        }
435      }
436      Weights[NodeId](NodeId) = deg_w;
437      TotalVol += deg_w;
438    }
439    return;
440  }
441  void ProcessedGraph::printCounts() {  
442    for (TUNGraph::TNodeI NI = Graph_org->BegNI(); NI < Graph_org->EndNI(); NI ++ ) {
443      int NodeId = NI.GetId();
444      for (int e = 0; e < NI.GetOutDeg(); e++) {
445        int NbrId = NI.GetOutNId(e);
446        TIntV& CountThisEdge = Counts[NodeId](NbrId);
447        printf("(%d, %d): ", NodeId, NbrId);
448        for (int i = 0; i < CountThisEdge.Len(); i ++) {
449          int output = CountThisEdge[i];
450          printf("%d ", output);
451        }
452        printf("\n");
453      }
454    }
455  }
456  void ProcessedGraph::printWeights() {  
457    for (TUNGraph::TNodeI NI = Graph_org->BegNI(); NI < Graph_org->EndNI(); NI ++ ) {
458      int NodeId = NI.GetId();
459      for (int e = 0; e < NI.GetOutDeg(); e++) {
460        int NbrId = NI.GetOutNId(e);
461        printf("(%d, %d): ", NodeId, NbrId);
462        if (Weights[NodeId].IsKey(NbrId)) {
463          float weight = Weights[NodeId](NbrId);
464          printf("%.2f ", weight);
465        } else {
466          printf("Not a key in Weights");
467        }
468        printf("\n");
469      }
470      float d_w = Weights[NodeId](NodeId);
471      printf("\td_w(%d) = %.2f.\n", NodeId, d_w);
472    }
473    printf("Total volume = %.2f. \n", TotalVol);
474    Graph_trans->Dump();
475  }
476  MAPPR::MAPPR() {
477    NumPushs = 0;
478    appr_norm = 0;
479    SizeGlobalMin = 0;
480    SizeFirstLocalMin = -1;
481  }
482  void MAPPR::computeAPPR(const ProcessedGraph& graph_p, const int SeedNodeId, float alpha, float eps) {
483    appr_vec.Clr();
484    THash<TInt, TFlt> residual;
485    NumPushs = 0;
486    appr_norm = 0;
487    const WeightVH& Weights = graph_p.getWeights();
488    if (Weights[SeedNodeId].GetDat(SeedNodeId) * eps >= 1) {
489      appr_vec(SeedNodeId) = 0;
490      return;
491    }
492    residual(SeedNodeId) = 1;
493    TSnapQueue<int> NodesWExcesRes;
494    NodesWExcesRes.Push(SeedNodeId);
495    while (!NodesWExcesRes.Empty()) {
496      NumPushs += 1;
497      int NodeId = NodesWExcesRes.Top();
498      NodesWExcesRes.Pop();
499      float deg_w = Weights[NodeId].GetDat(NodeId);
500      if (deg_w == 0) {
501        appr_vec(NodeId) += residual(NodeId);
502        appr_norm += residual(NodeId);
503        residual(NodeId) = 0;
504        continue;
505      }
506      float pushVal = residual(NodeId) - deg_w * eps / 2;
507      appr_vec(NodeId) += pushVal * (1-alpha);
508      appr_norm += pushVal * (1-alpha);
509      residual(NodeId) = deg_w * eps / 2;
510      pushVal *= alpha / deg_w;
511      TUNGraph::TNodeI NI = graph_p.getTransformedGraph()->GetNI(NodeId);
512      for (int i = 0; i < NI.GetOutDeg(); i ++) {
513        int NbrId = NI.GetOutNId(i);
514        float nbrValOld = residual(NbrId);
515        float nbrValNew = nbrValOld + pushVal * Weights[NodeId].GetDat(NbrId);
516        residual(NbrId) = nbrValNew;
517        if (nbrValOld <= eps * Weights[NbrId].GetDat(NbrId)  &&  nbrValNew > eps * Weights[NbrId].GetDat(NbrId)) {
518          NodesWExcesRes.Push(NbrId);
519        }
520      }
521    }
522    computeProfile(graph_p);
523  }
524  void MAPPR::computeProfile(const ProcessedGraph& graph_p) {
525    THash<TInt, TFlt> Quotient;
526    const WeightVH& Weights = graph_p.getWeights();
527    for (THash<TInt, TFlt>::TIter it = appr_vec.BegI(); it < appr_vec.EndI(); it++) {
528      int NodeId = it->Key;
529      Quotient(NodeId) = it->Dat / Weights[NodeId].GetDat(NodeId);
530    }
531    Quotient.SortByDat(false);
532    double vol = 0, cut = 0;
533    TIntSet IsIn;           
534    int VolSmall = 1;       
535    float TotalVol = graph_p.getTotalVolume();
536    for (THash<TInt, TFlt>::TIter it = Quotient.BegI(); it < Quotient.EndI(); it++) {
537      int NodeId = it->Key;
538      TUNGraph::TNodeI NI = graph_p.getTransformedGraph()->GetNI(NodeId);
539      const THash<TInt, TFlt>& WeightsHere = Weights[NodeId];
540      NodeInOrder.Add(NodeId);
541      IsIn.AddKey(NodeId);
542      vol += VolSmall * WeightsHere.GetDat(NodeId);
543      if (VolSmall == 1 && vol >= TotalVol / 2) {
544        vol = TotalVol - vol;
545        VolSmall = -1;
546      }
547      cut += WeightsHere.GetDat(NodeId);
548      for (long j = 0; j < NI.GetOutDeg(); j ++) {
549        long NbrId = NI.GetOutNId(j);
550        if (IsIn.IsKey(NbrId)) {
551          cut -= 2 * WeightsHere.GetDat(NbrId);
552        }
553      }
554      if (vol) {
555        MtfCondProfile.Add(cut / vol);
556      } else {
557        MtfCondProfile.Add(1);
558      }
559    }
560    findGlobalMin();
561    findFirstlocalMin();
562  }
563  bool MAPPR::isLocalMin(int idx, double thresh) {
564      if (idx <= 0 || idx >= MtfCondProfile.Len() - 1) {
565          return false;
566      }
567      if (MtfCondProfile[idx] >= MtfCondProfile[idx-1]) {
568          return false;
569      }
570      int idxRight = idx;
571      while (idxRight < MtfCondProfile.Len() - 1) {
572          idxRight ++;
573          if (MtfCondProfile[idxRight] > MtfCondProfile[idx] * thresh) {
574              return true;
575          } else if (MtfCondProfile[idxRight] <= MtfCondProfile[idx]) {
576              return false;
577          }
578      }
579      return false;
580  }
581  void MAPPR::findGlobalMin() {
582    double minCondVal = 2;
583    for (int i = 0; i < MtfCondProfile.Len(); i ++) {
584      if (MtfCondProfile[i] < minCondVal) {
585        SizeGlobalMin = i + 1;
586        minCondVal = MtfCondProfile[i];
587      }
588    } 
589  }
590  void MAPPR::findFirstlocalMin() {
591    SizeFirstLocalMin = 2;
592    while (SizeFirstLocalMin < MtfCondProfile.Len()) {
593      if (isLocalMin(SizeFirstLocalMin-1)) {
594        break;
595      }
596      SizeFirstLocalMin ++;
597    }
598    if (SizeFirstLocalMin >= MtfCondProfile.Len()) {   
599      if (SizeGlobalMin == 0) {
600        findGlobalMin();
601      }
602      SizeFirstLocalMin = SizeGlobalMin;
603    }
604  }
605  void MAPPR::sweepAPPR(int option) {
606    if (appr_vec.Len() == 0) {
607      TExcept::Throw("No APPR vector has been computed! Please first do MAPPR::computeAPPR(...)!");
608    }
609    if (option == 0) {  
610      if (SizeGlobalMin == 0) {
611        TExcept::Throw("A bug somewhere!");
612      }
613      sweepAPPR(SizeGlobalMin);
614    } else if (option == -1) {
615      if (SizeFirstLocalMin == -1) {
616        TExcept::Throw("A bug somewhere!");
617      }
618      sweepAPPR(SizeFirstLocalMin);
619    } else if (option > 0) {
620      Cluster.Clr();
621      for (int i = 0; i < option; i++) {
622        Cluster.Add(NodeInOrder[i]);
623      }
624    } else {
625      TExcept::Throw("Invalid input in option!");
626    }
627  }
628  void MAPPR::printAPPR() {
629    for (THash<TInt, TFlt>::TIter it = appr_vec.BegI(); it < appr_vec.EndI(); it++) {
630      int NodeId = it->Key;
631      float VecVal = it->Dat;
632      printf("%d : %.7f\n", NodeId, VecVal);
633    }
634    printf("Number of pushes: %d\n", NumPushs);
635    printf("L1-norm of APPR vector: %.7f\n", appr_norm);
636  }
637  void MAPPR::printProfile() {
638    if (NodeInOrder.Len() == 0) {
639      TExcept::Throw("No APPR vector has been computed! Please first do MAPPR::computeAPPR(...)!");
640    }
641    printf("Size\tNodeId\tConductance\n");
642    for (int i = 0; i < NodeInOrder.Len(); i ++) {
643      int NodeId = NodeInOrder[i];
644      float Cond = MtfCondProfile[i];
645      printf("%d\t%d\t%.7f\n", i+1, NodeId, Cond);
646      if (i == SizeGlobalMin - 1) {
647        printf("\tGlobal minimun!!!\n");
648      }
649      if (i == SizeFirstLocalMin - 1) {
650        printf("\tFirst local minimun!!!\n");
651      }
652    }
653  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-localmotifcluster.cpp</h3>
            <pre><code>1  #include "localmotifcluster.h"
2  #include "stdafx.h"
3  MotifType ParseMotifType(const TStr& motif, const bool& IsDirected) {
4    TStr motif_lc = motif.GetLc();
5    if (IsDirected) {
6      if      (motif_lc == "m1")          { return M1; }
7      else if (motif_lc == "m2")          { return M2; }
8      else if (motif_lc == "m3")          { return M3; }
9      else if (motif_lc == "m4")          { return M4; }
10      else if (motif_lc == "m5")          { return M5; }
11      else if (motif_lc == "m6")          { return M6; }
12      else if (motif_lc == "m7")          { return M7; }
13      else if (motif_lc == "triad")          { return triad; }
14      else if (motif_lc == "cycle")          { return cycle; }
15      else if (motif_lc == "ffloop")          { return FFLoop; }
16      else if (motif_lc == "unide")          { return UniDE; }
17      else if (motif_lc == "bide")          { return BiDE; }
18      else if (motif_lc == "de")          { return DE; }
19      else if (motif_lc == "edge")          { return DE_any; }
20      else { 
21        TExcept::Throw("Unknown motif for directed graph!"); 
22      }
23    } else {
24      if      (motif_lc == "uedge")     { return UEdge; }
25      else if (motif_lc == "clique3")     { return clique3; }
26      else if (motif_lc == "clique4")     { return clique4; }
27      else if (motif_lc == "clique5")     { return clique5; }
28      else if (motif_lc == "clique6")     { return clique6; }
29      else if (motif_lc == "clique7")     { return clique7; }
30      else if (motif_lc == "clique8")     { return clique8; }
31      else if (motif_lc == "clique9")     { return clique9; }
32      else { TExcept::Throw("Unknown motif for undirected graph!"); }
33    }
34    TExcept::Throw("Inappropriate input!"); 
35    return UEdge;
36  }
37  void printMotifType(const MotifType& type) {
38    switch (type) {
39      case M1:      printf("M1\n"); break;
40      case M2:      printf("M2\n"); break;
41      case M3:      printf("M3\n"); break;
42      case M4:      printf("M4\n"); break;
43      case M5:      printf("M5\n"); break;
44      case M6:      printf("M6\n"); break;
45      case M7:      printf("M7\n"); break;
46      case triad:   printf("triad\n"); break;
47      case cycle:   printf("cycle\n"); break;
48      case FFLoop:  printf("FFLoop\n"); break;
49      case UniDE:   printf("UniDE\n"); break;
50      case BiDE:    printf("BiDE\n"); break;
51      case DE:      printf("DE\n"); break;
52      case DE_any:  printf("DE_any\n"); break;
53      case UEdge:       printf("UEdge\n"); break;
54      case clique3:     printf("clique3\n"); break;
55      case clique4:     printf("clique4\n"); break;
56      case clique5:     printf("clique5\n"); break;
57      case clique6:     printf("clique6\n"); break;
58      case clique7:     printf("clique7\n"); break;
59      case clique8:     printf("clique8\n"); break;
60      case clique9:     printf("clique9\n"); break;
61      default:
62        TExcept::Throw("Unknown motif type!");
63    }
64  }
65  int getCliqueSize(const MotifType& type) {
66    switch (type) {
67      case UEdge:       return 2;
68      case clique3:     return 3;
69      case clique4:     return 4;
70      case clique5:     return 5;
71      case clique6:     return 6;
72      case clique7:     return 7;
73      case clique8:     return 8;
74      case clique9:     return 9;
75      default: {
76        TExcept::Throw("Unknown motif for undirected graph!"); 
77        return -1;
78      }         
79    }
80  }
81  ProcessedGraph::ProcessedGraph(PUNGraph graph, MotifType mt){
82    Graph_org = graph;
83    assignWeights_undir(mt);
84  }
85  bool higherDeg(PUNGraph& G, TUNGraph::TNodeI& NI1, int nodeID2) {
86    TUNGraph::TNodeI NI2 = G->GetNI(nodeID2);
87    if (NI1.GetOutDeg() > NI2.GetOutDeg()) {
88      return true;
89    } else if (NI1.GetOutDeg() == NI2.GetOutDeg() && NI1.GetId() > nodeID2) {
90      return true;
91    } else {
92      return false;
93    }
94  }
95  bool higherDeg(PUNGraph& G, int nodeID1, int nodeID2) {
96    TUNGraph::TNodeI NI1 = G->GetNI(nodeID1);
97    return higherDeg(G, NI1, nodeID2);
98  }
99  void ProcessedGraph::countClique(PUNGraph& G, int KSize, TIntV& PrevNodes, int level) {
100    if (level >= KSize - 1) {
101      throw "exception!!";
102    }
103    if (level >= 1) {
104      for (TUNGraph::TEdgeI EI = G->BegEI(); EI < G->EndEI(); EI ++ ) {
105        int SrcNId = EI.GetSrcNId();
106        int DstNId = EI.GetDstNId();
107        Counts[SrcNId](DstNId)[level-1] ++;
108        Counts[DstNId](SrcNId)[level-1] ++;
109      }
110    }
111    for (TUNGraph::TNodeI NI = G->BegNI(); NI < G->EndNI(); NI ++ ) {
112      int NodeId = NI.GetId();
113      int degHere = NI.GetOutDeg();
114      for (int i = 0; i < level; i ++) {
115        Counts[PrevNodes[i]](NodeId)[level-1] += degHere;
116        Counts[NodeId](PrevNodes[i])[level-1] += degHere;
117      }
118      if (level == KSize - 2) {
119        continue;
120      }
121      PrevNodes[level] = NodeId;
122      TIntV neighborsID;
123      for (int e = 0; e < NI.GetOutDeg(); e++) {
124        int nbrID = NI.GetOutNId(e);
125        if (higherDeg(G, NodeId, nbrID)) {
126            neighborsID.Add(nbrID);
127        }
128      }
129      PUNGraph subGraph = TSnap::GetSubGraph(G, neighborsID);
130      int numEdges = subGraph->GetEdges();
131      for (int i = 0; i <= level; i ++) {
132        for (int j = i + 1; j <= level; j ++) {
133          Counts[PrevNodes[i]](PrevNodes[j])[level] += numEdges;
134          Counts[PrevNodes[j]](PrevNodes[i])[level] += numEdges;
135        }
136      }
137      countClique(subGraph, KSize, PrevNodes, level + 1);
138    }
139  }
140  void ProcessedGraph::assignWeights_undir(MotifType mt) {
141    Weights = WeightVH(Graph_org->GetMxNId());
142    Graph_trans = TSnap::ConvertGraph<PUNGraph>(Graph_org);
143    int KSize = getCliqueSize(mt);
144    if (KSize == 2) {
145      for (TUNGraph::TNodeI NI = Graph_org->BegNI(); NI < Graph_org->EndNI(); NI ++ ) {
146        int NodeId = NI.GetId();
147        for (int e = 0; e < NI.GetOutDeg(); e++) {
148          Weights[NodeId](NI.GetOutNId(e)) = 1;
149        }
150        Weights[NodeId](NodeId) = NI.GetOutDeg();
151      }
152      TotalVol = 2 * Graph_org->GetEdges();
153    } else { 
154      if (Counts.Len() == 0 || Counts.BegI()->Len() == 0 || Counts.BegI()->BegI()->Dat.Len() < KSize - 2) {
155        Counts = CountVH(Graph_org->GetMxNId());
156        for (TUNGraph::TNodeI NI = Graph_org->BegNI(); NI < Graph_org->EndNI(); NI ++ ) {
157          int NodeId = NI.GetId();
158          for (int e = 0; e < NI.GetOutDeg(); e++) {
159            Counts[NodeId](NI.GetOutNId(e)) = TIntV(KSize - 2);
160          }
161        }
162        TIntV PrevNodes(KSize - 2);
163        countClique(Graph_org, KSize, PrevNodes, 0);
164      }
165      TotalVol = 0;
166      for (TUNGraph::TNodeI NI = Graph_org->BegNI(); NI < Graph_org->EndNI(); NI ++ ) {
167        int NodeId = NI.GetId();
168        float deg_w = 0;
169        for (int e = 0; e < NI.GetOutDeg(); e++) {
170          int NbrId = NI.GetOutNId(e);
171          int MtfCntHere = Counts[NodeId](NbrId)[KSize-3];
172          if (MtfCntHere) {
173            Weights[NodeId](NbrId) = MtfCntHere;
174            deg_w += MtfCntHere;
175          } else {
176            Graph_trans->DelEdge(NodeId, NbrId);
177          }
178        }
179        Weights[NodeId](NodeId) = deg_w;
180        TotalVol += deg_w;
181      }
182    }
183  }
184  ProcessedGraph::ProcessedGraph(PNGraph graph, MotifType mt){
185    Graph_org = TSnap::ConvertGraph<PUNGraph>(graph);
186    countDirTriadMotif(graph);
187    assignWeights_dir(mt);
188  }
189  int checkEdge(PNGraph& G, long nodeID, long nbrID) {
190    if (G->IsEdge(nodeID, nbrID)) {
191      if (G->IsEdge(nbrID, nodeID)) {
192        return 0;
193      } else {
194        return 1;
195      }
196    } else {
197      return 2;
198    }
199  }
200  int checkTriadMotif(PNGraph& G, long nodeID, long srcNId, long dstNId) {
201    int motifType = 0;
202    if (G->IsEdge(dstNId, srcNId)) {
203      switch (checkEdge(G, nodeID, dstNId)) {
204        case 0: {
205          switch (checkEdge(G, nodeID, srcNId)) {
206            case 0: {
207              motifType = 4;
208              break;
209            }
210            case 1: {
211              motifType = 3;
212              break;
213            }
214            case 2: {
215              motifType = 3;
216            }
217          }
218          break;
219        }
220        case 1: {
221          switch (checkEdge(G, nodeID, srcNId)) {
222            case 0: {
223              motifType = 3;
224              break;
225            }
226            case 1: {
227              motifType = 6;
228              break;
229            }
230            case 2: {
231              motifType = 2;
232            }
233          }
234          break;
235        }
236        case 2: {
237          switch (checkEdge(G, nodeID, srcNId)) {
238            case 0: {
239              motifType = 3;
240              break;
241            }
242            case 1: {
243              motifType = 2;
244              break;
245            }
246            case 2: {
247              motifType = 7;
248            }
249          }
250        }
251      }
252    } else {
253      switch (checkEdge(G, nodeID, dstNId)) {
254        case 0: {
255          switch (checkEdge(G, nodeID, srcNId)) {
256            case 0: {
257              motifType = 3;
258              break;
259            }
260            case 1: {
261              motifType = 2;
262              break;
263            }
264            case 2: {
265              motifType = 6;
266            }
267          }
268          break;
269        }
270        case 1: {
271          switch (checkEdge(G, nodeID, srcNId)) {
272            case 0: {
273              motifType = 7;
274              break;
275            }
276            case 1: {
277              motifType = 5;
278              break;
279            }
280            case 2: {
281              motifType = 5;
282            }
283          }
284          break;
285        }
286        case 2: {
287          switch (checkEdge(G, nodeID, srcNId)) {
288            case 0: {
289              motifType = 2;
290              break;
291            }
292            case 1: {
293              motifType = 1;
294              break;
295            }
296            case 2: {
297              motifType = 5;
298            }
299          }
300        }
301      }
302    }
303    return motifType;
304  }
305  bool higherDeg(PNGraph& G, TNGraph::TNodeI& NI1, int nodeID2) {
306    TNGraph::TNodeI NI2 = G->GetNI(nodeID2);
307    if (NI1.GetOutDeg() > NI2.GetOutDeg()) {
308      return true;
309    } else if (NI1.GetOutDeg() == NI2.GetOutDeg() && NI1.GetId() > nodeID2) {
310      return true;
311    } else {
312      return false;
313    }
314  }
315  bool higherDeg(PNGraph& G, int nodeID1, int nodeID2) {
316    TNGraph::TNodeI NI1 = G->GetNI(nodeID1);
317    return higherDeg(G, NI1, nodeID2);
318  }
319  void ProcessedGraph::countDirTriadMotif(PNGraph graph) {
320    int numBasicDirMtf = 9;
321    Counts = CountVH(Graph_org->GetMxNId());
322    for (TUNGraph::TNodeI NI = Graph_org->BegNI(); NI < Graph_org->EndNI(); NI ++ ) {
323      int NodeId = NI.GetId();
324      for (int e = 0; e < NI.GetOutDeg(); e++) {
325        Counts[NodeId](NI.GetOutNId(e)) = TIntV(numBasicDirMtf);
326      }
327    }
328    for (TNGraph::TNodeI NI = graph->BegNI(); NI < graph->EndNI(); NI ++ ) {
329      long nodeID = NI.GetId();
330      TIntV neighborsID;
331      for (long e = 0; e < NI.GetOutDeg(); e++) {
332        long nbrID = NI.GetOutNId(e);
333        if (higherDeg(graph, nodeID, nbrID)) {
334          neighborsID.Add(nbrID);
335          Counts[nodeID](nbrID)[0] ++;
336          Counts[nbrID](nodeID)[0] ++;
337        }
338      }
339      for (long e = 0; e < NI.GetInDeg(); e++) {
340        long nbrID = NI.GetInNId(e);
341        if (higherDeg(graph, nodeID, nbrID)) {
342          if (graph->IsEdge(nodeID, nbrID)) {
343            Counts[nodeID](nbrID)[0] --;
344            Counts[nbrID](nodeID)[0] --;
345            Counts[nodeID](nbrID)[1] ++;
346            Counts[nbrID](nodeID)[1] ++;
347          } else {
348            neighborsID.Add(nbrID);
349            Counts[nodeID](nbrID)[0] ++;
350            Counts[nbrID](nodeID)[0] ++;
351          }
352        }
353      }
354      PNGraph subGraph = TSnap::GetSubGraph(graph, neighborsID);
355      for (TNGraph::TEdgeI EI = subGraph->BegEI(); EI < subGraph->EndEI(); EI ++ ) { 
356        long srcNId = EI.GetSrcNId();
357        long dstNId = EI.GetDstNId();
358        int MotifNumber = 0;
359        if (srcNId > dstNId || !subGraph->IsEdge(dstNId, srcNId)) {
360          MotifNumber = checkTriadMotif(graph, nodeID, srcNId, dstNId);
361          MotifNumber ++;
362          Counts[nodeID](srcNId)[MotifNumber] ++;
363          Counts[srcNId](nodeID)[MotifNumber] ++;
364          Counts[nodeID](dstNId)[MotifNumber] ++;
365          Counts[dstNId](nodeID)[MotifNumber] ++;
366          Counts[srcNId](dstNId)[MotifNumber] ++;
367          Counts[dstNId](srcNId)[MotifNumber] ++;
368        }
369      }
370    }
371    return;
372  }
373  void ProcessedGraph::assignWeights_dir(MotifType mt) {
374    TIntV MtfInclude;
375    switch (mt) {
376      case UniDE :      {MtfInclude.Add(0); break;}
377      case BiDE :       MtfInclude.Add(1); break;
378      case DE :         MtfInclude.Add(0); MtfInclude.Add(1); MtfInclude.Add(1); break;
379      case DE_any :     MtfInclude.Add(0); MtfInclude.Add(1); break;
380      case M1 :         MtfInclude.Add(2); break;
381      case M2 :         MtfInclude.Add(3); break;
382      case M3 :         MtfInclude.Add(4); break;
383      case M4 :         MtfInclude.Add(5); break;
384      case M5 :         MtfInclude.Add(6); break;
385      case M6 :         MtfInclude.Add(7); break;
386      case M7 :         MtfInclude.Add(8); break;
387      case triad : {
388        MtfInclude.Add(2); 
389        MtfInclude.Add(3); 
390        MtfInclude.Add(4); 
391        MtfInclude.Add(5); 
392        MtfInclude.Add(6); 
393        MtfInclude.Add(7); 
394        MtfInclude.Add(8); 
395        break;
396      }
397      case cycle : {
398        MtfInclude.Add(2); 
399        MtfInclude.Add(3); 
400        MtfInclude.Add(4); 
401        MtfInclude.Add(5); 
402        MtfInclude.Add(5); 
403        break;
404      }
405      case FFLoop : {
406        MtfInclude.Add(6); 
407        MtfInclude.Add(7); 
408        MtfInclude.Add(7); 
409        MtfInclude.Add(8); 
410        MtfInclude.Add(8); 
411        break;
412      default:
413        TExcept::Throw("Unknown motif type!");
414      }    
415    }
416    Graph_trans = TSnap::ConvertGraph<PUNGraph>(Graph_org);
417    Weights = WeightVH(Graph_org->GetMxNId());
418    TotalVol = 0;
419    for (TUNGraph::TNodeI NI = Graph_org->BegNI(); NI < Graph_org->EndNI(); NI ++ ) {
420      int NodeId = NI.GetId();
421      float deg_w = 0;
422      for (int e = 0; e < NI.GetOutDeg(); e++) {
423        int NbrId = NI.GetOutNId(e);
424        TIntV& CountHere = Counts[NodeId](NbrId);
425        int WeightHere = 0;
426        for (int i = 0; i < MtfInclude.Len(); i ++) {
427          WeightHere += CountHere[MtfInclude[i]];
428        }
429        if (WeightHere) {
430          Weights[NodeId](NbrId) = WeightHere;
<span onclick='openModal()' class='match'>431          deg_w += WeightHere;
432        } else {
433          Graph_trans->DelEdge(NodeId, NbrId);
434        }
435      }
436      Weights[NodeId](NodeId) = deg_w;
437      TotalVol += deg_w;
438    }
439    return;
</span>440  }
441  void ProcessedGraph::printCounts() {  
442    for (TUNGraph::TNodeI NI = Graph_org->BegNI(); NI < Graph_org->EndNI(); NI ++ ) {
443      int NodeId = NI.GetId();
444      for (int e = 0; e < NI.GetOutDeg(); e++) {
445        int NbrId = NI.GetOutNId(e);
446        TIntV& CountThisEdge = Counts[NodeId](NbrId);
447        printf("(%d, %d): ", NodeId, NbrId);
448        for (int i = 0; i < CountThisEdge.Len(); i ++) {
449          int output = CountThisEdge[i];
450          printf("%d ", output);
451        }
452        printf("\n");
453      }
454    }
455  }
456  void ProcessedGraph::printWeights() {  
457    for (TUNGraph::TNodeI NI = Graph_org->BegNI(); NI < Graph_org->EndNI(); NI ++ ) {
458      int NodeId = NI.GetId();
459      for (int e = 0; e < NI.GetOutDeg(); e++) {
460        int NbrId = NI.GetOutNId(e);
461        printf("(%d, %d): ", NodeId, NbrId);
462        if (Weights[NodeId].IsKey(NbrId)) {
463          float weight = Weights[NodeId](NbrId);
464          printf("%.2f ", weight);
465        } else {
466          printf("Not a key in Weights");
467        }
468        printf("\n");
469      }
470      float d_w = Weights[NodeId](NodeId);
471      printf("\td_w(%d) = %.2f.\n", NodeId, d_w);
472    }
473    printf("Total volume = %.2f. \n", TotalVol);
474    Graph_trans->Dump();
475  }
476  MAPPR::MAPPR() {
477    NumPushs = 0;
478    appr_norm = 0;
479    SizeGlobalMin = 0;
480    SizeFirstLocalMin = -1;
481  }
482  void MAPPR::computeAPPR(const ProcessedGraph& graph_p, const int SeedNodeId, float alpha, float eps) {
483    appr_vec.Clr();
484    THash<TInt, TFlt> residual;
485    NumPushs = 0;
486    appr_norm = 0;
487    const WeightVH& Weights = graph_p.getWeights();
488    if (Weights[SeedNodeId].GetDat(SeedNodeId) * eps >= 1) {
489      appr_vec(SeedNodeId) = 0;
490      return;
491    }
492    residual(SeedNodeId) = 1;
493    TSnapQueue<int> NodesWExcesRes;
494    NodesWExcesRes.Push(SeedNodeId);
495    while (!NodesWExcesRes.Empty()) {
496      NumPushs += 1;
497      int NodeId = NodesWExcesRes.Top();
498      NodesWExcesRes.Pop();
499      float deg_w = Weights[NodeId].GetDat(NodeId);
500      if (deg_w == 0) {
501        appr_vec(NodeId) += residual(NodeId);
502        appr_norm += residual(NodeId);
503        residual(NodeId) = 0;
504        continue;
505      }
506      float pushVal = residual(NodeId) - deg_w * eps / 2;
507      appr_vec(NodeId) += pushVal * (1-alpha);
508      appr_norm += pushVal * (1-alpha);
509      residual(NodeId) = deg_w * eps / 2;
510      pushVal *= alpha / deg_w;
511      TUNGraph::TNodeI NI = graph_p.getTransformedGraph()->GetNI(NodeId);
512      for (int i = 0; i < NI.GetOutDeg(); i ++) {
513        int NbrId = NI.GetOutNId(i);
514        float nbrValOld = residual(NbrId);
515        float nbrValNew = nbrValOld + pushVal * Weights[NodeId].GetDat(NbrId);
516        residual(NbrId) = nbrValNew;
517        if (nbrValOld <= eps * Weights[NbrId].GetDat(NbrId)  &&  nbrValNew > eps * Weights[NbrId].GetDat(NbrId)) {
518          NodesWExcesRes.Push(NbrId);
519        }
520      }
521    }
522    computeProfile(graph_p);
523  }
524  void MAPPR::computeProfile(const ProcessedGraph& graph_p) {
525    THash<TInt, TFlt> Quotient;
526    const WeightVH& Weights = graph_p.getWeights();
527    for (THash<TInt, TFlt>::TIter it = appr_vec.BegI(); it < appr_vec.EndI(); it++) {
528      int NodeId = it->Key;
529      Quotient(NodeId) = it->Dat / Weights[NodeId].GetDat(NodeId);
530    }
531    Quotient.SortByDat(false);
532    double vol = 0, cut = 0;
533    TIntSet IsIn;           
534    int VolSmall = 1;       
535    float TotalVol = graph_p.getTotalVolume();
536    for (THash<TInt, TFlt>::TIter it = Quotient.BegI(); it < Quotient.EndI(); it++) {
537      int NodeId = it->Key;
538      TUNGraph::TNodeI NI = graph_p.getTransformedGraph()->GetNI(NodeId);
539      const THash<TInt, TFlt>& WeightsHere = Weights[NodeId];
540      NodeInOrder.Add(NodeId);
541      IsIn.AddKey(NodeId);
542      vol += VolSmall * WeightsHere.GetDat(NodeId);
543      if (VolSmall == 1 && vol >= TotalVol / 2) {
544        vol = TotalVol - vol;
545        VolSmall = -1;
546      }
547      cut += WeightsHere.GetDat(NodeId);
548      for (long j = 0; j < NI.GetOutDeg(); j ++) {
549        long NbrId = NI.GetOutNId(j);
550        if (IsIn.IsKey(NbrId)) {
551          cut -= 2 * WeightsHere.GetDat(NbrId);
552        }
553      }
554      if (vol) {
555        MtfCondProfile.Add(cut / vol);
556      } else {
557        MtfCondProfile.Add(1);
558      }
559    }
560    findGlobalMin();
561    findFirstlocalMin();
562  }
563  bool MAPPR::isLocalMin(int idx, double thresh) {
564      if (idx <= 0 || idx >= MtfCondProfile.Len() - 1) {
565          return false;
566      }
567      if (MtfCondProfile[idx] >= MtfCondProfile[idx-1]) {
568          return false;
569      }
570      int idxRight = idx;
571      while (idxRight < MtfCondProfile.Len() - 1) {
572          idxRight ++;
573          if (MtfCondProfile[idxRight] > MtfCondProfile[idx] * thresh) {
574              return true;
575          } else if (MtfCondProfile[idxRight] <= MtfCondProfile[idx]) {
576              return false;
577          }
578      }
579      return false;
580  }
581  void MAPPR::findGlobalMin() {
582    double minCondVal = 2;
583    for (int i = 0; i < MtfCondProfile.Len(); i ++) {
584      if (MtfCondProfile[i] < minCondVal) {
585        SizeGlobalMin = i + 1;
586        minCondVal = MtfCondProfile[i];
587      }
588    } 
589  }
590  void MAPPR::findFirstlocalMin() {
591    SizeFirstLocalMin = 2;
592    while (SizeFirstLocalMin < MtfCondProfile.Len()) {
593      if (isLocalMin(SizeFirstLocalMin-1)) {
594        break;
595      }
596      SizeFirstLocalMin ++;
597    }
598    if (SizeFirstLocalMin >= MtfCondProfile.Len()) {   
599      if (SizeGlobalMin == 0) {
600        findGlobalMin();
601      }
602      SizeFirstLocalMin = SizeGlobalMin;
603    }
604  }
605  void MAPPR::sweepAPPR(int option) {
606    if (appr_vec.Len() == 0) {
607      TExcept::Throw("No APPR vector has been computed! Please first do MAPPR::computeAPPR(...)!");
608    }
609    if (option == 0) {  
610      if (SizeGlobalMin == 0) {
611        TExcept::Throw("A bug somewhere!");
612      }
613      sweepAPPR(SizeGlobalMin);
614    } else if (option == -1) {
615      if (SizeFirstLocalMin == -1) {
616        TExcept::Throw("A bug somewhere!");
617      }
618      sweepAPPR(SizeFirstLocalMin);
619    } else if (option > 0) {
620      Cluster.Clr();
621      for (int i = 0; i < option; i++) {
622        Cluster.Add(NodeInOrder[i]);
623      }
624    } else {
625      TExcept::Throw("Invalid input in option!");
626    }
627  }
628  void MAPPR::printAPPR() {
629    for (THash<TInt, TFlt>::TIter it = appr_vec.BegI(); it < appr_vec.EndI(); it++) {
630      int NodeId = it->Key;
631      float VecVal = it->Dat;
632      printf("%d : %.7f\n", NodeId, VecVal);
633    }
634    printf("Number of pushes: %d\n", NumPushs);
635    printf("L1-norm of APPR vector: %.7f\n", appr_norm);
636  }
637  void MAPPR::printProfile() {
638    if (NodeInOrder.Len() == 0) {
639      TExcept::Throw("No APPR vector has been computed! Please first do MAPPR::computeAPPR(...)!");
640    }
641    printf("Size\tNodeId\tConductance\n");
642    for (int i = 0; i < NodeInOrder.Len(); i ++) {
643      int NodeId = NodeInOrder[i];
644      float Cond = MtfCondProfile[i];
645      printf("%d\t%d\t%.7f\n", i+1, NodeId, Cond);
646      if (i == SizeGlobalMin - 1) {
647        printf("\tGlobal minimun!!!\n");
648      }
649      if (i == SizeFirstLocalMin - 1) {
650        printf("\tFirst local minimun!!!\n");
651      }
652    }
653  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-localmotifcluster.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-localmotifcluster.cpp</div>
                </div>
                <div class="column column_space"><pre><code>174            deg_w += MtfCntHere;
175          } else {
176            Graph_trans->DelEdge(NodeId, NbrId);
177          }
178        }
179        Weights[NodeId](NodeId) = deg_w;
180        TotalVol += deg_w;
181      }
182    }
</pre></code></div>
                <div class="column column_space"><pre><code>431          deg_w += WeightHere;
432        } else {
433          Graph_trans->DelEdge(NodeId, NbrId);
434        }
435      }
436      Weights[NodeId](NodeId) = deg_w;
437      TotalVol += deg_w;
438    }
439    return;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    