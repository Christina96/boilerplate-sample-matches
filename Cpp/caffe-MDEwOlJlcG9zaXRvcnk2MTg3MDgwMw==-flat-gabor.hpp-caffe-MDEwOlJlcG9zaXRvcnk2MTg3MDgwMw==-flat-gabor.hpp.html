
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 17, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-gabor.hpp</h3>
            <pre><code>1  namespace caffe {
2  class KernelParameters {
3   public:
4    double r, g, b;
5    double lambda, sigma;
6    double omega, phi, theta;
7    KernelParameters()
8        : r(1), g(1), b(1), lambda(1), sigma(0.6), omega(M_PI), phi(0), theta(0) {
9    }
10    void generate(int kernelId, int numberOfKernels, int kernelSize) {
11      if ((numberOfKernels == 32) && (kernelSize == 5))
12        generateCifarLike(kernelId, kernelSize);
13      else if ((numberOfKernels == 64) && (kernelSize == 7))
14        generateGoogleNetLike(kernelId, kernelSize);
15      else if ((numberOfKernels == 64) && (kernelSize == 3))
16        generateVggLike(kernelId, kernelSize);
17      else if ((numberOfKernels == 96) && (kernelSize == 11))
18        generateAlexNetLike(kernelId, kernelSize);
19      else
20        LOG(FATAL) << "No predefined gabor filters for this topology.";
21    }
22    void generateCifarLike(int kernelId, int kernelSize) {
23      lambda = 0.5;
24      if (kernelId < 8) {
25        omega = M_PI * (kernelSize - 1) / 2 / 1;
26        theta = (kernelId % 8) * M_PI / 8;
27      } else if (kernelId < 14) {
28        omega = M_PI * (kernelSize - 1) / 2 / 2;
29        theta = ((kernelId - 2) % 6) * M_PI / 6 + M_PI / 12;
30      } else if (kernelId < 16) {
31        lambda = 0.5;
32        sigma = 0.75;
33        omega = M_PI * (kernelSize - 1) / 2 / 8;
34        phi = (kernelId % 2) * M_PI;
35        r = 1;
36        g = -1;
37        b = 1;
38      } else {
39        omega = M_PI * (kernelSize - 1) / 2 / 4;
40        theta = (kernelId % 4) * M_PI / 2 + M_PI / 4 + M_PI / 8;
41        phi = M_PI / 2;
42      }
43      if (kernelId >= 30) {
44        theta = (kernelId % 2) * M_PI / 2 + M_PI / 4 + M_PI / 8;
45        r = 1;
46        g = 1;
47        b = 0;
48      } else if (kernelId >= 28) {
49        theta = (kernelId % 2) * M_PI / 2 + M_PI / 4 - M_PI / 8;
50        r = -1;
51        g = 1;
52        b = -1;
53      } else if (kernelId >= 24) {
54        r = -1;
55        g = 1;
56        b = 1;
57      } else if (kernelId >= 20) {
58        r = 1;
59        g = 0;
60        b = -1;
61      }
62    }
63    void generateGoogleNetLike(int kernelId, int kernelSize) {
64      if (kernelId < 32) {
65        int rotation = kernelId / 8;
66        int frequency = kernelId % 8;
67        int phase = kernelId % 2;
68        lambda = 1 / (1 + frequency / 8.);
69        sigma = 0.4 + 0.2 * frequency / 8;
70        omega = M_PI * (kernelSize - 1) / 2 / (1 + frequency / 2.);
71        phi = phase * M_PI + M_PI * 12 / 32;
<span onclick='openModal()' class='match'>72        theta = rotation * M_PI / 4;
73      } else if (kernelId < 40) {
74        sigma = 0.45;
</span>75        lambda = 0.5;
76        omega = M_PI * (kernelSize - 1) / 2;
77        theta = (kernelId % 8) * M_PI / 8;
78        phi = M_PI;
79      } else if (kernelId < 46) {
80        int phase = (kernelId - 1) / 3;
81        int size = (kernelId - 1) % 3;
82        lambda = 1 / (1 + size / 2.);
83        sigma = 1. / (2.5 - size / 2.);
84        omega = M_PI / 4;
85        phi = phase * M_PI;
86        r = 0.25;
87        g = -1;
88        b = 1;
89      } else if (kernelId < 48) {
90        lambda = 2. / 3;
91        sigma = 1;
92        omega = M_PI * (kernelSize - 1) / 2 / 12;
93        theta = (kernelId % 8) * M_PI + M_PI / 8;
94        phi = M_PI / 2;
95        r = 1;
96        g = 0.1;
97        b = -0.5;
98      } else if (kernelId < 56) {
99        lambda = 2. / 3;
100        sigma = 1;
101        omega = M_PI * (kernelSize - 1) / 2 / 12;
102        theta = (kernelId % 8) * M_PI / 4 + M_PI / 32;
103        phi = M_PI / 2;
104        r = -0.5;
105        g = 0.1;
106        b = 1;
107      } else if (kernelId < 60) {
108        lambda = 1;
109        sigma = 1;
110        omega = M_PI * (kernelSize - 1) / 2 / 12;
111        theta = (kernelId % 8) * M_PI / 2 + M_PI / 8;
112        phi = M_PI / 2;
113        r = 0.25;
114        g = -1;
115        b = 1;
116      } else {
117        lambda = 2. / 3;
118        sigma = 1;
119        omega = M_PI * (kernelSize - 1) / 2 / 12;
120        theta = (kernelId % 8) * M_PI / 2 + M_PI / 8;
121        phi = M_PI / 2;
122        r = -1;
123        g = -1;
124        b = 1;
125      }
126    }
127    void generateVggLike(int kernelId, int kernelSize) {
128      generateGoogleNetLike(kernelId, kernelSize);
129      sigma = 1;
130    }
131    void generateAlexNetLike(int kernelId, int kernelSize) {
132      lambda = 1. / 3;
133      if (kernelId < 48) {
134        int rotation = kernelId / 8;
135        int frequency = kernelId % 8;
136        int phase = kernelId % 2;
137        lambda /= (1 + frequency / 8.);
138        sigma = 0.5 + 0.2 * frequency / 8;
139        omega = M_PI * (kernelSize - 1) / 2 / (1 + frequency / 2.);
140        phi = phase * M_PI + M_PI * 12 / 32;
141        theta = rotation * M_PI / 6;
142      } else if (kernelId < 56) {
143        int phase = kernelId / 4;
144        int size = kernelId % 4;
145        lambda /= (1 + size / 2.);
146        sigma = 1. / (2.5 - size / 2.);
147        omega = M_PI / 4;
148        phi = phase * M_PI;
149        r = 0.25;
150        g = -1;
151        b = 1;
152      } else if (kernelId < 60) {
153        lambda /= 1.5;
154        sigma = 0.75;
155        omega = M_PI * (kernelSize - 1) / 2 / 8;
156        theta = (kernelId % 4) * M_PI / 2 + M_PI / 8;
157        phi = M_PI / 2;
158        r = -1;
159        g = 1;
160        b = -0.5;
161      } else if (kernelId < 64) {
162        lambda /= 3;
163        sigma = 2;
164        omega = M_PI * (kernelSize - 1) / 2 / 8;
165        theta = (kernelId % 4) * M_PI / 2 + M_PI / 8;
166        phi = M_PI / 2;
167        r = 1;
168        g = -0.5;
169        b = -0.75;
170      } else if (kernelId < 72) {
171        lambda /= 1.5;
172        sigma = 0.75;
173        omega = M_PI * (kernelSize - 1) / 2 / 4;
174        theta = (kernelId % 8) * M_PI / 4 + M_PI / 32;
175        phi = M_PI / 2;
176        r = 1;
177        g = 0.1;
178        b = -0.75;
179      } else if (kernelId < 80) {
180        lambda /= 1.5;
181        sigma = 1;
182        omega = M_PI * (kernelSize - 1) / 2 / 12;
183        theta = (kernelId % 8) * M_PI / 4 + M_PI / 32;
184        phi = M_PI / 2;
185        r = -0.5;
186        g = 0.1;
187        b = 1;
188      } else if (kernelId < 88) {
189        lambda /= 2.5;
190        sigma = 1;
191        omega = M_PI * (kernelSize - 1) / 2 / 8;
192        theta = (kernelId % 8) * M_PI / 4 + M_PI / 32;
193        phi = M_PI / 2;
194        r = -1;
195        g = -1;
196        b = 1;
197      } else if (kernelId < 92) {
198        omega = M_PI * (kernelSize - 1) / 2 / 16;
199        theta = (kernelId % 4) * M_PI / 2 + M_PI / 16;
200        phi = M_PI / 2;
201      } else {
202        lambda /= 4;
203        sigma = 0.75;
204        omega = M_PI * (kernelSize - 1) / 2 / 4;
205        theta = (kernelId % 8) * M_PI / 4 + M_PI / 32;
206        phi = M_PI / 2;
207        r = -1;
208        g = -1;
209        b = 1;
210      }
211    }
212  };
213  template <typename Dtype> class KernelGenerator {
214   public:
215    KernelGenerator(int numberOfKernels, int kernelSize)
216        : numberOfKernels(numberOfKernels), kernelSize(kernelSize),
217          kernels(new Dtype[getNumberOfElements()]) {}
218    ~KernelGenerator() { delete[] kernels; }
219    void generate() {
220      for (int kernelId = 0; kernelId < numberOfKernels; kernelId++)
221        generateKernel(kernelId);
222    }
223    const Dtype *getKernelData() const { return kernels; }
224    int getSizeOfKernelData() const {
225      return getNumberOfElements();
226    }
227   private:
228    int numberOfKernels;
229    int kernelSize;
230    Dtype *kernels;
231    int getNumberOfElements() const {
232      return numberOfKernels * 3 * kernelSize * kernelSize;
233    }
234    void generateKernel(int kernelId) {
235      KernelParameters param;
236      param.generate(kernelId, numberOfKernels, kernelSize);
237      for (int ky = 0; ky < kernelSize; ky++)
238        for (int kx = 0; kx < kernelSize; kx++) {
239          double x = 2. * kx / (kernelSize - 1) - 1;
240          double y = 2. * ky / (kernelSize - 1) - 1;
241          double dis = exp(-(x * x + y * y) / (2 * param.sigma * param.sigma));
242          double arg = x * cos(param.theta) - y * sin(param.theta);
243          double per = cos(arg * param.omega + param.phi);
244          double val = param.lambda * dis * per;
245          kernels[kx + kernelSize * (ky + kernelSize * (0 + 3 * kernelId))] =
246              (Dtype)(param.r * val);
247          kernels[kx + kernelSize * (ky + kernelSize * (1 + 3 * kernelId))] =
248              (Dtype)(param.g * val);
249          kernels[kx + kernelSize * (ky + kernelSize * (2 + 3 * kernelId))] =
250              (Dtype)(param.b * val);
251        }
252    }
253  };
254  };  
</code></pre>
        </div>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-gabor.hpp</h3>
            <pre><code>1  namespace caffe {
2  class KernelParameters {
3   public:
4    double r, g, b;
5    double lambda, sigma;
6    double omega, phi, theta;
7    KernelParameters()
8        : r(1), g(1), b(1), lambda(1), sigma(0.6), omega(M_PI), phi(0), theta(0) {
9    }
10    void generate(int kernelId, int numberOfKernels, int kernelSize) {
11      if ((numberOfKernels == 32) && (kernelSize == 5))
12        generateCifarLike(kernelId, kernelSize);
13      else if ((numberOfKernels == 64) && (kernelSize == 7))
14        generateGoogleNetLike(kernelId, kernelSize);
15      else if ((numberOfKernels == 64) && (kernelSize == 3))
16        generateVggLike(kernelId, kernelSize);
17      else if ((numberOfKernels == 96) && (kernelSize == 11))
18        generateAlexNetLike(kernelId, kernelSize);
19      else
20        LOG(FATAL) << "No predefined gabor filters for this topology.";
21    }
22    void generateCifarLike(int kernelId, int kernelSize) {
23      lambda = 0.5;
24      if (kernelId < 8) {
25        omega = M_PI * (kernelSize - 1) / 2 / 1;
26        theta = (kernelId % 8) * M_PI / 8;
27      } else if (kernelId < 14) {
28        omega = M_PI * (kernelSize - 1) / 2 / 2;
29        theta = ((kernelId - 2) % 6) * M_PI / 6 + M_PI / 12;
30      } else if (kernelId < 16) {
31        lambda = 0.5;
32        sigma = 0.75;
33        omega = M_PI * (kernelSize - 1) / 2 / 8;
34        phi = (kernelId % 2) * M_PI;
35        r = 1;
36        g = -1;
37        b = 1;
38      } else {
39        omega = M_PI * (kernelSize - 1) / 2 / 4;
40        theta = (kernelId % 4) * M_PI / 2 + M_PI / 4 + M_PI / 8;
41        phi = M_PI / 2;
42      }
43      if (kernelId >= 30) {
44        theta = (kernelId % 2) * M_PI / 2 + M_PI / 4 + M_PI / 8;
45        r = 1;
46        g = 1;
47        b = 0;
48      } else if (kernelId >= 28) {
49        theta = (kernelId % 2) * M_PI / 2 + M_PI / 4 - M_PI / 8;
50        r = -1;
51        g = 1;
52        b = -1;
53      } else if (kernelId >= 24) {
54        r = -1;
55        g = 1;
56        b = 1;
57      } else if (kernelId >= 20) {
58        r = 1;
59        g = 0;
60        b = -1;
61      }
62    }
63    void generateGoogleNetLike(int kernelId, int kernelSize) {
64      if (kernelId < 32) {
65        int rotation = kernelId / 8;
66        int frequency = kernelId % 8;
67        int phase = kernelId % 2;
68        lambda = 1 / (1 + frequency / 8.);
69        sigma = 0.4 + 0.2 * frequency / 8;
70        omega = M_PI * (kernelSize - 1) / 2 / (1 + frequency / 2.);
71        phi = phase * M_PI + M_PI * 12 / 32;
72        theta = rotation * M_PI / 4;
73      } else if (kernelId < 40) {
74        sigma = 0.45;
75        lambda = 0.5;
76        omega = M_PI * (kernelSize - 1) / 2;
77        theta = (kernelId % 8) * M_PI / 8;
78        phi = M_PI;
79      } else if (kernelId < 46) {
80        int phase = (kernelId - 1) / 3;
81        int size = (kernelId - 1) % 3;
82        lambda = 1 / (1 + size / 2.);
83        sigma = 1. / (2.5 - size / 2.);
84        omega = M_PI / 4;
85        phi = phase * M_PI;
86        r = 0.25;
87        g = -1;
88        b = 1;
89      } else if (kernelId < 48) {
90        lambda = 2. / 3;
91        sigma = 1;
92        omega = M_PI * (kernelSize - 1) / 2 / 12;
93        theta = (kernelId % 8) * M_PI + M_PI / 8;
94        phi = M_PI / 2;
95        r = 1;
96        g = 0.1;
97        b = -0.5;
98      } else if (kernelId < 56) {
99        lambda = 2. / 3;
100        sigma = 1;
101        omega = M_PI * (kernelSize - 1) / 2 / 12;
102        theta = (kernelId % 8) * M_PI / 4 + M_PI / 32;
103        phi = M_PI / 2;
104        r = -0.5;
105        g = 0.1;
106        b = 1;
107      } else if (kernelId < 60) {
108        lambda = 1;
109        sigma = 1;
110        omega = M_PI * (kernelSize - 1) / 2 / 12;
111        theta = (kernelId % 8) * M_PI / 2 + M_PI / 8;
112        phi = M_PI / 2;
113        r = 0.25;
114        g = -1;
115        b = 1;
116      } else {
117        lambda = 2. / 3;
118        sigma = 1;
119        omega = M_PI * (kernelSize - 1) / 2 / 12;
120        theta = (kernelId % 8) * M_PI / 2 + M_PI / 8;
121        phi = M_PI / 2;
122        r = -1;
123        g = -1;
124        b = 1;
125      }
126    }
127    void generateVggLike(int kernelId, int kernelSize) {
128      generateGoogleNetLike(kernelId, kernelSize);
129      sigma = 1;
130    }
131    void generateAlexNetLike(int kernelId, int kernelSize) {
132      lambda = 1. / 3;
133      if (kernelId < 48) {
134        int rotation = kernelId / 8;
135        int frequency = kernelId % 8;
136        int phase = kernelId % 2;
137        lambda /= (1 + frequency / 8.);
138        sigma = 0.5 + 0.2 * frequency / 8;
139        omega = M_PI * (kernelSize - 1) / 2 / (1 + frequency / 2.);
140        phi = phase * M_PI + M_PI * 12 / 32;
<span onclick='openModal()' class='match'>141        theta = rotation * M_PI / 6;
142      } else if (kernelId < 56) {
143        int phase = kernelId / 4;
</span>144        int size = kernelId % 4;
145        lambda /= (1 + size / 2.);
146        sigma = 1. / (2.5 - size / 2.);
147        omega = M_PI / 4;
148        phi = phase * M_PI;
149        r = 0.25;
150        g = -1;
151        b = 1;
152      } else if (kernelId < 60) {
153        lambda /= 1.5;
154        sigma = 0.75;
155        omega = M_PI * (kernelSize - 1) / 2 / 8;
156        theta = (kernelId % 4) * M_PI / 2 + M_PI / 8;
157        phi = M_PI / 2;
158        r = -1;
159        g = 1;
160        b = -0.5;
161      } else if (kernelId < 64) {
162        lambda /= 3;
163        sigma = 2;
164        omega = M_PI * (kernelSize - 1) / 2 / 8;
165        theta = (kernelId % 4) * M_PI / 2 + M_PI / 8;
166        phi = M_PI / 2;
167        r = 1;
168        g = -0.5;
169        b = -0.75;
170      } else if (kernelId < 72) {
171        lambda /= 1.5;
172        sigma = 0.75;
173        omega = M_PI * (kernelSize - 1) / 2 / 4;
174        theta = (kernelId % 8) * M_PI / 4 + M_PI / 32;
175        phi = M_PI / 2;
176        r = 1;
177        g = 0.1;
178        b = -0.75;
179      } else if (kernelId < 80) {
180        lambda /= 1.5;
181        sigma = 1;
182        omega = M_PI * (kernelSize - 1) / 2 / 12;
183        theta = (kernelId % 8) * M_PI / 4 + M_PI / 32;
184        phi = M_PI / 2;
185        r = -0.5;
186        g = 0.1;
187        b = 1;
188      } else if (kernelId < 88) {
189        lambda /= 2.5;
190        sigma = 1;
191        omega = M_PI * (kernelSize - 1) / 2 / 8;
192        theta = (kernelId % 8) * M_PI / 4 + M_PI / 32;
193        phi = M_PI / 2;
194        r = -1;
195        g = -1;
196        b = 1;
197      } else if (kernelId < 92) {
198        omega = M_PI * (kernelSize - 1) / 2 / 16;
199        theta = (kernelId % 4) * M_PI / 2 + M_PI / 16;
200        phi = M_PI / 2;
201      } else {
202        lambda /= 4;
203        sigma = 0.75;
204        omega = M_PI * (kernelSize - 1) / 2 / 4;
205        theta = (kernelId % 8) * M_PI / 4 + M_PI / 32;
206        phi = M_PI / 2;
207        r = -1;
208        g = -1;
209        b = 1;
210      }
211    }
212  };
213  template <typename Dtype> class KernelGenerator {
214   public:
215    KernelGenerator(int numberOfKernels, int kernelSize)
216        : numberOfKernels(numberOfKernels), kernelSize(kernelSize),
217          kernels(new Dtype[getNumberOfElements()]) {}
218    ~KernelGenerator() { delete[] kernels; }
219    void generate() {
220      for (int kernelId = 0; kernelId < numberOfKernels; kernelId++)
221        generateKernel(kernelId);
222    }
223    const Dtype *getKernelData() const { return kernels; }
224    int getSizeOfKernelData() const {
225      return getNumberOfElements();
226    }
227   private:
228    int numberOfKernels;
229    int kernelSize;
230    Dtype *kernels;
231    int getNumberOfElements() const {
232      return numberOfKernels * 3 * kernelSize * kernelSize;
233    }
234    void generateKernel(int kernelId) {
235      KernelParameters param;
236      param.generate(kernelId, numberOfKernels, kernelSize);
237      for (int ky = 0; ky < kernelSize; ky++)
238        for (int kx = 0; kx < kernelSize; kx++) {
239          double x = 2. * kx / (kernelSize - 1) - 1;
240          double y = 2. * ky / (kernelSize - 1) - 1;
241          double dis = exp(-(x * x + y * y) / (2 * param.sigma * param.sigma));
242          double arg = x * cos(param.theta) - y * sin(param.theta);
243          double per = cos(arg * param.omega + param.phi);
244          double val = param.lambda * dis * per;
245          kernels[kx + kernelSize * (ky + kernelSize * (0 + 3 * kernelId))] =
246              (Dtype)(param.r * val);
247          kernels[kx + kernelSize * (ky + kernelSize * (1 + 3 * kernelId))] =
248              (Dtype)(param.g * val);
249          kernels[kx + kernelSize * (ky + kernelSize * (2 + 3 * kernelId))] =
250              (Dtype)(param.b * val);
251        }
252    }
253  };
254  };  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-gabor.hpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-gabor.hpp</div>
                </div>
                <div class="column column_space"><pre><code>72        theta = rotation * M_PI / 4;
73      } else if (kernelId < 40) {
74        sigma = 0.45;
</pre></code></div>
                <div class="column column_space"><pre><code>141        theta = rotation * M_PI / 6;
142      } else if (kernelId < 56) {
143        int phase = kernelId / 4;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    