<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for box2.hpp &amp; vec3.hpp</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for box2.hpp &amp; vec3.hpp
      </h3>
<h1 align="center">
        15.6%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>box2.hpp (25.0%)<th>vec3.hpp (11.406844%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(125-138)<td><a href="#" name="0">(216-227)</a><td align="center"><font color="#ff0000">16</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(50-67)<td><a href="#" name="1">(80-97)</a><td align="center"><font color="#df0000">14</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>box2.hpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#pragma once

#include &lt;gtl/gtl.hpp&gt;
#include &lt;gtl/vec2.hpp&gt;

namespace gtl {
    /*!
    \class box2 box2.hpp geometry/box2.hpp
    \brief Axis-Aligned 2D Bounding Box Class..
    \ingroup base

    This box class is used by many other classes.

    \sa box3
    */
    template &lt;typename Type&gt;
    class box2 {
    public:
        //! The default constructor makes an empty box.
        box2()
        {
            makeEmpty();
        }

        //!	Constructs a box with the given corners.
        box2(const vec2&lt;Type&gt;&amp; a_min, const vec2&lt;Type&gt;&amp; a_max)
            : m_min(a_min)
            , m_max(a_max)
        {
        }

        //! Reset the boundaries of the box with the given corners.
        void setBounds(const vec2&lt;Type&gt;&amp; a_min, const vec2&lt;Type&gt;&amp; a_max)
        {
            m_min = a_min;
            m_max = a_max;
        }

        //! Check if this has been marked as an empty box. \sa makeEmpty().
        bool isEmpty() const
        {
            return (m_max[0] &lt; m_min[0] || m_max[1] &lt; m_min[1]);
        }

        //! Marks this as an empty box.	\sa isEmpty().
        void makeEmpty()
<a name="1"></a>        {
            m_min = vec2&lt;Type&gt;::max();
            m_max = -vec2&lt;Type&gt;::max();
<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>        }

        //! Returns the lower left corner of the box. \sa getCenter(), getMax().
        const vec2&lt;Type&gt;&amp; getMin() const
        {
            return m_min;
        }

        //! Returns the upper right corner of the box. \sa getMin().
        const vec2&lt;Type&gt;&amp; getMax() const
        {
            return m_max;
        }

        //! Returns width and height of box.
        vec2&lt;Type&gt; getSize() const
        {
            return m_max - m_min;</b></font>
        }

        //! Returns the center point of the box.
        vec2&lt;Type&gt; getCenter() const
        {
            return vec2&lt;Type&gt;((m_max[0] + m_min[0]) * 0.5f,
                              (m_max[1] + m_min[1]) * 0.5f);
        }

        //! Extend the boundaries of the box by the given point.
        void extendBy(const vec2&lt;Type&gt;&amp; a_point)
        {
            if (isEmpty()) {
                setBounds(a_point, a_point);
            } else {
                if (a_point[0] &lt; m_min[0])
                    m_min[0] = a_point[0];
                if (a_point[1] &lt; m_min[1])
                    m_min[1] = a_point[1];

                if (a_point[0] &gt; m_max[0])
                    m_max[0] = a_point[0];
                if (a_point[1] &gt; m_max[1])
                    m_max[1] = a_point[1];
            }
        }

        //! Extend the boundaries of the box by the given \a a_box parameter.
        void extendBy(const box2&lt;Type&gt;&amp; a_box)
        {
            if (isEmpty()) {
                *this = a_box;
            } else {
                extendBy(a_box.getMin());
                extendBy(a_box.getMax());
            }
        }

        //! Give the surface of the box
        Type getSurface() const
        {
            const vec2&lt;Type&gt; size = m_max - m_min;
            return size[0] * size[1];
        }

        //! Check if \a a_point lies within the boundaries of this box.
        bool intersect(const vec2&lt;Type&gt;&amp; a_point) const
        {
            return !(a_point[0] &lt; m_min[0] || a_point[0] &gt; m_max[0] || a_point[1] &lt; m_min[1] || a_point[1] &gt; m_max[1]);
        }

        //! Check if the given box lies wholly or partly within the boundaries of this box.
        bool intersect(const box2&lt;Type&gt;&amp; a_box) const
        {
<a name="0"></a>            if ((m_max[0] &lt; a_box.m_min[0]) || (m_min[0] &gt; a_box.m_max[0]) || (m_max[1] &lt; a_box.m_min[1]) || (m_min[1] &gt; a_box.m_max[1])) {
                return false;
            }
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>            return true;
        }

        //! Check \a b1 and \a b2 for equality.
        friend bool operator==(const box2&lt;Type&gt;&amp; b1, const box2&lt;Type&gt;&amp; b2)
        {
            return b1.getMin() == b2.getMin() &amp;&amp; b1.getMax() == b2.getMax();
        }

        //! Check \a b1 and \a b2 for inequality.
        friend bool operator!=(const box2&lt;Type&gt;&amp; b1, const box2&lt;Type&gt;&amp; b2)
        {
            return !(b1 == b2);
        }</b></font>

    private:
        vec2&lt;Type&gt; m_min;
        vec2&lt;Type&gt; m_max;
    };

    typedef box2&lt;int&gt; box2i;
    typedef box2&lt;float&gt; box2f;
    typedef box2&lt;double&gt; box2d;
} // namespace gtl
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>vec3.hpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#pragma once

#include &lt;gtl/gtl.hpp&gt;

namespace gtl {
    /*!
    \class vec3 vec3.hpp geometry/vec3.hpp
    \brief 3 dimensional vector.
    \ingroup base

    This class is used by many other classes.

    \sa vec2
    */
    template &lt;typename Type&gt;
    struct vec3 {
        union {
            struct {
                Type x, y, z;
            };
            struct {
                Type r, g, b;
            };
            struct {
                Type u, v, w;
            };
            Type data[3];
        };

        //! The default constructor.The vector will be null.
        vec3()
            : x(0)
            , y(0)
            , z(0)
        {
        }

        //! Constructs an instance with initial values from \a v.
        vec3(const Type v[3])
            : x(v[0])
            , y(v[1])
            , z(v[2])
        {
        }

        //! Constructs an instance with the initial values from \a a_x, \a a_y and \a a_z.
        vec3(Type a_x, Type a_y, Type a_z)
            : x(a_x)
            , y(a_y)
            , z(a_z)
        {
        }

        //! Constructs an instance with initial values from \a a_vec.
        vec3(const vec3&lt;Type&gt;&amp; a_vec)
            : x(a_vec.x)
            , y(a_vec.y)
            , z(a_vec.z)
        {
        }

        //! Set new x, y and z values for the vector. Returns reference to self.
        vec3&lt;Type&gt;&amp; setValue(const Type v[3])
        {
            x = v[0];
            y = v[1];
            z = v[2];

            return *this;
        }

        //! Set new x, y and z values for the vector. Returns reference to self.
        vec3&lt;Type&gt;&amp; setValue(Type a_x, Type a_y, Type a_z)
        {
            x = a_x;
            y = a_y;
<a name="1"></a>            z = a_z;

            return *this;
<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>        }

        //! Returns a pointer to an array containing the coordinates of the vector.
        const Type* getValue() const
        {
            return data;
        }

        //! Calculates and returns the dot product of this vector with \a a_vec.
        Type dot(const vec3&lt;Type&gt;&amp; a_vec) const
        {
            return (x * a_vec.x + y * a_vec.y + z * a_vec.z);
        }

        //! Return length of vector.
        Type length() const
        {
            return (Type)std::sqrt(x * x + y * y + z * z);</b></font>
        }

        //! Return squared length of vector.
        Type sqrLength() const
        {
            return (x * x + y * y + z * z);
        }

        //! Normalize the vector to unit length. Return value is the original length of the vector before normalization.
        Type normalize()
        {
            const Type magnitude = length();

            if (magnitude &gt; 0)
                *this /= magnitude;

            return magnitude;
        }

        //! Returns the normalized unit vector form of this vector.
        vec3&lt;Type&gt; normalized() const
        {
            vec3&lt;Type&gt; v(*this);
            v.normalize();

            return v;
        }

        //! Returns the cross product of this vector with \a a_vec.
        vec3&lt;Type&gt; cross(const vec3&lt;Type&gt;&amp; a_vec) const
        {
            return vec3&lt;Type&gt;(y * a_vec.z - a_vec.y * z,
                              z * a_vec.x - a_vec.z * x,
                              x * a_vec.y - a_vec.x * y);
        }

        //! Negate the vector (i.e. point it in the opposite direction).
        void negate()
        {
            x = -x;
            y = -y;
            z = -z;
        }

        //! Return this vector reflected off the surface with the given normal \a N. N should be normalized.
        vec3&lt;Type&gt; reflect(const vec3&lt;Type&gt;&amp; N) const
        {
            const vec3&lt;Type&gt;&amp; I(*this);

            return I - 2 * N.dot(I) * N;
        }

        //! Refract this vector through a surface with the given normal \a N and ratio of indices of refraction \a eta.
        vec3&lt;Type&gt; refract(const vec3&lt;Type&gt;&amp; N, Type eta) const
        {
            const vec3&lt;Type&gt;&amp; I(*this);
            const Type k = 1.0 - eta * eta * (1.0 - N.dot(I) * N.dot(I));

            return (k &lt; 0.0) ? 0 : eta * I - (eta * N.dot(I) + std::sqrt(k)) * N;
        }

        //! Index operator. Returns modifiable x, y or z value.
        Type&amp; operator[](int i) { return reinterpret_cast&lt;Type*&gt;(this)[i]; }

        //! Index operator. Returns x, y or z value.
        const Type&amp; operator[](int i) const { return reinterpret_cast&lt;const Type*&gt;(this)[i]; }

        //! Multiply components of vector with value \a d. Returns reference to self.
        vec3&lt;Type&gt;&amp; operator*=(const Type d)
        {
            x *= d;
            y *= d;
            z *= d;

            return *this;
        }

        //! Divides components of vector with value \a d. Returns reference to self.
        vec3&lt;Type&gt;&amp; operator/=(const Type d)
        {
            *this *= (1.0f / d);

            return *this;
        }

        //! Multiply components of vector with value \a a_vec.
        vec3&lt;Type&gt;&amp; operator*=(const vec3&lt;Type&gt;&amp; a_vec)
        {
            x *= a_vec.x;
            y *= a_vec.y;
            z *= a_vec.z;

            return *this;
        }

        //! Adds this vector and vector \a a_vec. Returns reference to self.
        vec3&lt;Type&gt;&amp; operator+=(const vec3&lt;Type&gt;&amp; a_vec)
        {
            x += a_vec.x;
            y += a_vec.y;
            z += a_vec.z;

            return *this;
        }

        //! Subtracts vector \a a_vec from this vector. Returns reference to self.
        vec3&lt;Type&gt;&amp; operator-=(const vec3&lt;Type&gt;&amp; a_vec)
        {
            x -= a_vec.x;
            y -= a_vec.y;
            z -= a_vec.z;

            return *this;
        }

<a name="0"></a>        //! Non-destructive negation operator.
        vec3&lt;Type&gt; operator-() const
        {
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>            return vec3&lt;Type&gt;(-x, -y, -z);
        }

        friend vec3&lt;Type&gt; operator*(const vec3&lt;Type&gt;&amp; a_vec, const Type d)
        {
            return vec3&lt;Type&gt;(a_vec.x * d, a_vec.y * d, a_vec.z * d);
        }

        friend vec3&lt;Type&gt; operator*(const Type d, const vec3&lt;Type&gt;&amp; a_vec)
        {
            return a_vec * d;
        }</b></font>

        friend vec3&lt;Type&gt; operator/(const vec3&lt;Type&gt;&amp; a_vec, const Type d)
        {
            return vec3&lt;Type&gt;(a_vec.x / d, a_vec.y / d, a_vec.z / d);
        }

        friend vec3&lt;Type&gt; operator*(const vec3&lt;Type&gt;&amp; v1, const vec3&lt;Type&gt;&amp; v2)
        {
            return vec3&lt;Type&gt;(v1.x * v2.x, v1.y * v2.y, v1.z * v2.z);
        }

        friend inline vec3&lt;Type&gt; operator+(const vec3&lt;Type&gt;&amp; v1, const vec3&lt;Type&gt;&amp; v2)
        {
            return vec3&lt;Type&gt;(v1.x + v2.x, v1.y + v2.y, v1.z + v2.z);
        }

        friend inline vec3&lt;Type&gt; operator-(const vec3&lt;Type&gt;&amp; v1, const vec3&lt;Type&gt;&amp; v2)
        {
            return vec3&lt;Type&gt;(v1.x - v2.x, v1.y - v2.y, v1.z - v2.z);
        }

        //! Check the two given vector for equality.
        friend bool operator==(const vec3&lt;Type&gt;&amp; v1, const vec3&lt;Type&gt;&amp; v2)
        {
            return (v1.x == v2.x &amp;&amp; v1.y == v2.y &amp;&amp; v1.z == v2.z);
        }

        //! Check the two given vector for inequality.
        friend bool operator!=(const vec3&lt;Type&gt;&amp; v1, const vec3&lt;Type&gt;&amp; v2)
        {
            return !(v1 == v2);
        }

        //! Check for equality with given tolerance.
        bool equals(const vec3&lt;Type&gt;&amp; a_vec, const Type a_tolerance = 1E-2) const
        {
            return ((*this - a_vec).sqrLength() &lt;= a_tolerance * a_tolerance);
        }

        friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const vec3&lt;Type&gt;&amp; vect)
        {
            return os &lt;&lt; vect.x &lt;&lt; " " &lt;&lt; vect.y &lt;&lt; " " &lt;&lt; vect.z;
        }

        //! Largest representable vector
        static vec3&lt;Type&gt; max()
        {
            return vec3&lt;Type&gt;(std::numeric_limits&lt;Type&gt;::max(),
                              std::numeric_limits&lt;Type&gt;::max(),
                              std::numeric_limits&lt;Type&gt;::max());
        }
    };

    typedef vec3&lt;int&gt; vec3i;
    typedef vec3&lt;float&gt; vec3f;
    typedef vec3&lt;double&gt; vec3d;
} // namespace gtl
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
