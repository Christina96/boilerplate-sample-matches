<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for box2.hpp & vec3.hpp</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for box2.hpp & vec3.hpp
      </h3>
      <h1 align="center">
        15.6%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>box2.hpp (25.0%)<TH>vec3.hpp (11.406844%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match23-0.html#0',2,'match23-1.html#0',3)" NAME="0">(125-138)<TD><A HREF="javascript:ZweiFrames('match23-0.html#0',2,'match23-1.html#0',3)" NAME="0">(216-227)</A><TD ALIGN=center><FONT COLOR="#ff0000">16</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match23-0.html#1',2,'match23-1.html#1',3)" NAME="1">(50-67)<TD><A HREF="javascript:ZweiFrames('match23-0.html#1',2,'match23-1.html#1',3)" NAME="1">(80-97)</A><TD ALIGN=center><FONT COLOR="#df0000">14</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>box2.hpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
#pragma once

#include &lt;gtl/gtl.hpp&gt;
#include &lt;gtl/vec2.hpp&gt;

namespace gtl {
    /*!
    \class box2 box2.hpp geometry/box2.hpp
    \brief Axis-Aligned 2D Bounding Box Class..
    \ingroup base

    This box class is used by many other classes.

    \sa box3
    */
    template &lt;typename Type&gt;
    class box2 {
    public:
        //! The default constructor makes an empty box.
        box2()
        {
            makeEmpty();
        }

        //!	Constructs a box with the given corners.
        box2(const vec2&lt;Type&gt;&amp; a_min, const vec2&lt;Type&gt;&amp; a_max)
            : m_min(a_min)
            , m_max(a_max)
        {
        }

        //! Reset the boundaries of the box with the given corners.
        void setBounds(const vec2&lt;Type&gt;&amp; a_min, const vec2&lt;Type&gt;&amp; a_max)
        {
            m_min = a_min;
            m_max = a_max;
        }

        //! Check if this has been marked as an empty box. \sa makeEmpty().
        bool isEmpty() const
        {
            return (m_max[0] &lt; m_min[0] || m_max[1] &lt; m_min[1]);
        }

        //! Marks this as an empty box.	\sa isEmpty().
        void makeEmpty()
<A NAME="1"></A>        {
            m_min = vec2&lt;Type&gt;::max();
            m_max = -vec2&lt;Type&gt;::max();
<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match23-1.html#1',3,'match23-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>        }

        //! Returns the lower left corner of the box. \sa getCenter(), getMax().
        const vec2&lt;Type&gt;&amp; getMin() const
        {
            return m_min;
        }

        //! Returns the upper right corner of the box. \sa getMin().
        const vec2&lt;Type&gt;&amp; getMax() const
        {
            return m_max;
        }

        //! Returns width and height of box.
        vec2&lt;Type&gt; getSize() const
        {
            return m_max - m_min;</B></FONT>
        }

        //! Returns the center point of the box.
        vec2&lt;Type&gt; getCenter() const
        {
            return vec2&lt;Type&gt;((m_max[0] + m_min[0]) * 0.5f,
                              (m_max[1] + m_min[1]) * 0.5f);
        }

        //! Extend the boundaries of the box by the given point.
        void extendBy(const vec2&lt;Type&gt;&amp; a_point)
        {
            if (isEmpty()) {
                setBounds(a_point, a_point);
            } else {
                if (a_point[0] &lt; m_min[0])
                    m_min[0] = a_point[0];
                if (a_point[1] &lt; m_min[1])
                    m_min[1] = a_point[1];

                if (a_point[0] &gt; m_max[0])
                    m_max[0] = a_point[0];
                if (a_point[1] &gt; m_max[1])
                    m_max[1] = a_point[1];
            }
        }

        //! Extend the boundaries of the box by the given \a a_box parameter.
        void extendBy(const box2&lt;Type&gt;&amp; a_box)
        {
            if (isEmpty()) {
                *this = a_box;
            } else {
                extendBy(a_box.getMin());
                extendBy(a_box.getMax());
            }
        }

        //! Give the surface of the box
        Type getSurface() const
        {
            const vec2&lt;Type&gt; size = m_max - m_min;
            return size[0] * size[1];
        }

        //! Check if \a a_point lies within the boundaries of this box.
        bool intersect(const vec2&lt;Type&gt;&amp; a_point) const
        {
            return !(a_point[0] &lt; m_min[0] || a_point[0] &gt; m_max[0] || a_point[1] &lt; m_min[1] || a_point[1] &gt; m_max[1]);
        }

        //! Check if the given box lies wholly or partly within the boundaries of this box.
        bool intersect(const box2&lt;Type&gt;&amp; a_box) const
        {
<A NAME="0"></A>            if ((m_max[0] &lt; a_box.m_min[0]) || (m_min[0] &gt; a_box.m_max[0]) || (m_max[1] &lt; a_box.m_min[1]) || (m_min[1] &gt; a_box.m_max[1])) {
                return false;
            }
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match23-1.html#0',3,'match23-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>            return true;
        }

        //! Check \a b1 and \a b2 for equality.
        friend bool operator==(const box2&lt;Type&gt;&amp; b1, const box2&lt;Type&gt;&amp; b2)
        {
            return b1.getMin() == b2.getMin() &amp;&amp; b1.getMax() == b2.getMax();
        }

        //! Check \a b1 and \a b2 for inequality.
        friend bool operator!=(const box2&lt;Type&gt;&amp; b1, const box2&lt;Type&gt;&amp; b2)
        {
            return !(b1 == b2);
        }</B></FONT>

    private:
        vec2&lt;Type&gt; m_min;
        vec2&lt;Type&gt; m_max;
    };

    typedef box2&lt;int&gt; box2i;
    typedef box2&lt;float&gt; box2f;
    typedef box2&lt;double&gt; box2d;
} // namespace gtl
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>vec3.hpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
#pragma once

#include &lt;gtl/gtl.hpp&gt;

namespace gtl {
    /*!
    \class vec3 vec3.hpp geometry/vec3.hpp
    \brief 3 dimensional vector.
    \ingroup base

    This class is used by many other classes.

    \sa vec2
    */
    template &lt;typename Type&gt;
    struct vec3 {
        union {
            struct {
                Type x, y, z;
            };
            struct {
                Type r, g, b;
            };
            struct {
                Type u, v, w;
            };
            Type data[3];
        };

        //! The default constructor.The vector will be null.
        vec3()
            : x(0)
            , y(0)
            , z(0)
        {
        }

        //! Constructs an instance with initial values from \a v.
        vec3(const Type v[3])
            : x(v[0])
            , y(v[1])
            , z(v[2])
        {
        }

        //! Constructs an instance with the initial values from \a a_x, \a a_y and \a a_z.
        vec3(Type a_x, Type a_y, Type a_z)
            : x(a_x)
            , y(a_y)
            , z(a_z)
        {
        }

        //! Constructs an instance with initial values from \a a_vec.
        vec3(const vec3&lt;Type&gt;&amp; a_vec)
            : x(a_vec.x)
            , y(a_vec.y)
            , z(a_vec.z)
        {
        }

        //! Set new x, y and z values for the vector. Returns reference to self.
        vec3&lt;Type&gt;&amp; setValue(const Type v[3])
        {
            x = v[0];
            y = v[1];
            z = v[2];

            return *this;
        }

        //! Set new x, y and z values for the vector. Returns reference to self.
        vec3&lt;Type&gt;&amp; setValue(Type a_x, Type a_y, Type a_z)
        {
            x = a_x;
            y = a_y;
<A NAME="1"></A>            z = a_z;

            return *this;
<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match23-0.html#1',2,'match23-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>        }

        //! Returns a pointer to an array containing the coordinates of the vector.
        const Type* getValue() const
        {
            return data;
        }

        //! Calculates and returns the dot product of this vector with \a a_vec.
        Type dot(const vec3&lt;Type&gt;&amp; a_vec) const
        {
            return (x * a_vec.x + y * a_vec.y + z * a_vec.z);
        }

        //! Return length of vector.
        Type length() const
        {
            return (Type)std::sqrt(x * x + y * y + z * z);</B></FONT>
        }

        //! Return squared length of vector.
        Type sqrLength() const
        {
            return (x * x + y * y + z * z);
        }

        //! Normalize the vector to unit length. Return value is the original length of the vector before normalization.
        Type normalize()
        {
            const Type magnitude = length();

            if (magnitude &gt; 0)
                *this /= magnitude;

            return magnitude;
        }

        //! Returns the normalized unit vector form of this vector.
        vec3&lt;Type&gt; normalized() const
        {
            vec3&lt;Type&gt; v(*this);
            v.normalize();

            return v;
        }

        //! Returns the cross product of this vector with \a a_vec.
        vec3&lt;Type&gt; cross(const vec3&lt;Type&gt;&amp; a_vec) const
        {
            return vec3&lt;Type&gt;(y * a_vec.z - a_vec.y * z,
                              z * a_vec.x - a_vec.z * x,
                              x * a_vec.y - a_vec.x * y);
        }

        //! Negate the vector (i.e. point it in the opposite direction).
        void negate()
        {
            x = -x;
            y = -y;
            z = -z;
        }

        //! Return this vector reflected off the surface with the given normal \a N. N should be normalized.
        vec3&lt;Type&gt; reflect(const vec3&lt;Type&gt;&amp; N) const
        {
            const vec3&lt;Type&gt;&amp; I(*this);

            return I - 2 * N.dot(I) * N;
        }

        //! Refract this vector through a surface with the given normal \a N and ratio of indices of refraction \a eta.
        vec3&lt;Type&gt; refract(const vec3&lt;Type&gt;&amp; N, Type eta) const
        {
            const vec3&lt;Type&gt;&amp; I(*this);
            const Type k = 1.0 - eta * eta * (1.0 - N.dot(I) * N.dot(I));

            return (k &lt; 0.0) ? 0 : eta * I - (eta * N.dot(I) + std::sqrt(k)) * N;
        }

        //! Index operator. Returns modifiable x, y or z value.
        Type&amp; operator[](int i) { return reinterpret_cast&lt;Type*&gt;(this)[i]; }

        //! Index operator. Returns x, y or z value.
        const Type&amp; operator[](int i) const { return reinterpret_cast&lt;const Type*&gt;(this)[i]; }

        //! Multiply components of vector with value \a d. Returns reference to self.
        vec3&lt;Type&gt;&amp; operator*=(const Type d)
        {
            x *= d;
            y *= d;
            z *= d;

            return *this;
        }

        //! Divides components of vector with value \a d. Returns reference to self.
        vec3&lt;Type&gt;&amp; operator/=(const Type d)
        {
            *this *= (1.0f / d);

            return *this;
        }

        //! Multiply components of vector with value \a a_vec.
        vec3&lt;Type&gt;&amp; operator*=(const vec3&lt;Type&gt;&amp; a_vec)
        {
            x *= a_vec.x;
            y *= a_vec.y;
            z *= a_vec.z;

            return *this;
        }

        //! Adds this vector and vector \a a_vec. Returns reference to self.
        vec3&lt;Type&gt;&amp; operator+=(const vec3&lt;Type&gt;&amp; a_vec)
        {
            x += a_vec.x;
            y += a_vec.y;
            z += a_vec.z;

            return *this;
        }

        //! Subtracts vector \a a_vec from this vector. Returns reference to self.
        vec3&lt;Type&gt;&amp; operator-=(const vec3&lt;Type&gt;&amp; a_vec)
        {
            x -= a_vec.x;
            y -= a_vec.y;
            z -= a_vec.z;

            return *this;
        }

<A NAME="0"></A>        //! Non-destructive negation operator.
        vec3&lt;Type&gt; operator-() const
        {
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match23-0.html#0',2,'match23-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>            return vec3&lt;Type&gt;(-x, -y, -z);
        }

        friend vec3&lt;Type&gt; operator*(const vec3&lt;Type&gt;&amp; a_vec, const Type d)
        {
            return vec3&lt;Type&gt;(a_vec.x * d, a_vec.y * d, a_vec.z * d);
        }

        friend vec3&lt;Type&gt; operator*(const Type d, const vec3&lt;Type&gt;&amp; a_vec)
        {
            return a_vec * d;
        }</B></FONT>

        friend vec3&lt;Type&gt; operator/(const vec3&lt;Type&gt;&amp; a_vec, const Type d)
        {
            return vec3&lt;Type&gt;(a_vec.x / d, a_vec.y / d, a_vec.z / d);
        }

        friend vec3&lt;Type&gt; operator*(const vec3&lt;Type&gt;&amp; v1, const vec3&lt;Type&gt;&amp; v2)
        {
            return vec3&lt;Type&gt;(v1.x * v2.x, v1.y * v2.y, v1.z * v2.z);
        }

        friend inline vec3&lt;Type&gt; operator+(const vec3&lt;Type&gt;&amp; v1, const vec3&lt;Type&gt;&amp; v2)
        {
            return vec3&lt;Type&gt;(v1.x + v2.x, v1.y + v2.y, v1.z + v2.z);
        }

        friend inline vec3&lt;Type&gt; operator-(const vec3&lt;Type&gt;&amp; v1, const vec3&lt;Type&gt;&amp; v2)
        {
            return vec3&lt;Type&gt;(v1.x - v2.x, v1.y - v2.y, v1.z - v2.z);
        }

        //! Check the two given vector for equality.
        friend bool operator==(const vec3&lt;Type&gt;&amp; v1, const vec3&lt;Type&gt;&amp; v2)
        {
            return (v1.x == v2.x &amp;&amp; v1.y == v2.y &amp;&amp; v1.z == v2.z);
        }

        //! Check the two given vector for inequality.
        friend bool operator!=(const vec3&lt;Type&gt;&amp; v1, const vec3&lt;Type&gt;&amp; v2)
        {
            return !(v1 == v2);
        }

        //! Check for equality with given tolerance.
        bool equals(const vec3&lt;Type&gt;&amp; a_vec, const Type a_tolerance = 1E-2) const
        {
            return ((*this - a_vec).sqrLength() &lt;= a_tolerance * a_tolerance);
        }

        friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const vec3&lt;Type&gt;&amp; vect)
        {
            return os &lt;&lt; vect.x &lt;&lt; &quot; &quot; &lt;&lt; vect.y &lt;&lt; &quot; &quot; &lt;&lt; vect.z;
        }

        //! Largest representable vector
        static vec3&lt;Type&gt; max()
        {
            return vec3&lt;Type&gt;(std::numeric_limits&lt;Type&gt;::max(),
                              std::numeric_limits&lt;Type&gt;::max(),
                              std::numeric_limits&lt;Type&gt;::max());
        }
    };

    typedef vec3&lt;int&gt; vec3i;
    typedef vec3&lt;float&gt; vec3f;
    typedef vec3&lt;double&gt; vec3d;
} // namespace gtl
</PRE>
</div>
  </div>
</body>
</html>
