<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for box2.hpp &amp; vec3.hpp</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for box2.hpp &amp; vec3.hpp
      </h3>
<h1 align="center">
        15.6%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>box2.hpp (25.0%)<th>vec3.hpp (11.406844%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(125-138)<td><a href="#" name="0">(216-227)</a><td align="center"><font color="#ff0000">16</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(50-67)<td><a href="#" name="1">(80-97)</a><td align="center"><font color="#df0000">14</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>box2.hpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #pragma once
2 #include &lt;gtl/gtl.hpp&gt;
3 #include &lt;gtl/vec2.hpp&gt;
4 namespace gtl {
5     template &lt;typename Type&gt;
6     class box2 {
7     public:
8         box2()
9         {
10             makeEmpty();
11         }
12         box2(const vec2&lt;Type&gt;&amp; a_min, const vec2&lt;Type&gt;&amp; a_max)
13             : m_min(a_min)
14             , m_max(a_max)
15         {
16         }
17         void setBounds(const vec2&lt;Type&gt;&amp; a_min, const vec2&lt;Type&gt;&amp; a_max)
18         {
19             m_min = a_min;
20             m_max = a_max;
21         }
22         bool isEmpty() const
23         {
24             return (m_max[0] &lt; m_min[0] || m_max[1] &lt; m_min[1]);
25         }
26         void makeEmpty()
27 <a name="1"></a>        {
28             m_min = vec2&lt;Type&gt;::max();
29             m_max = -vec2&lt;Type&gt;::max();
30 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>        }
31         const vec2&lt;Type&gt;&amp; getMin() const
32         {
33             return m_min;
34         }
35         const vec2&lt;Type&gt;&amp; getMax() const
36         {
37             return m_max;
38         }
39         vec2&lt;Type&gt; getSize() const
40         {
41             return m_max - m_min;</b></font>
42         }
43         vec2&lt;Type&gt; getCenter() const
44         {
45             return vec2&lt;Type&gt;((m_max[0] + m_min[0]) * 0.5f,
46                               (m_max[1] + m_min[1]) * 0.5f);
47         }
48         void extendBy(const vec2&lt;Type&gt;&amp; a_point)
49         {
50             if (isEmpty()) {
51                 setBounds(a_point, a_point);
52             } else {
53                 if (a_point[0] &lt; m_min[0])
54                     m_min[0] = a_point[0];
55                 if (a_point[1] &lt; m_min[1])
56                     m_min[1] = a_point[1];
57                 if (a_point[0] &gt; m_max[0])
58                     m_max[0] = a_point[0];
59                 if (a_point[1] &gt; m_max[1])
60                     m_max[1] = a_point[1];
61             }
62         }
63         void extendBy(const box2&lt;Type&gt;&amp; a_box)
64         {
65             if (isEmpty()) {
66                 *this = a_box;
67             } else {
68                 extendBy(a_box.getMin());
69                 extendBy(a_box.getMax());
70             }
71         }
72         Type getSurface() const
73         {
74             const vec2&lt;Type&gt; size = m_max - m_min;
75             return size[0] * size[1];
76         }
77         bool intersect(const vec2&lt;Type&gt;&amp; a_point) const
78         {
79             return !(a_point[0] &lt; m_min[0] || a_point[0] &gt; m_max[0] || a_point[1] &lt; m_min[1] || a_point[1] &gt; m_max[1]);
80         }
81         bool intersect(const box2&lt;Type&gt;&amp; a_box) const
82         {
83 <a name="0"></a>            if ((m_max[0] &lt; a_box.m_min[0]) || (m_min[0] &gt; a_box.m_max[0]) || (m_max[1] &lt; a_box.m_min[1]) || (m_min[1] &gt; a_box.m_max[1])) {
84                 return false;
85             }
86 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>            return true;
87         }
88         friend bool operator==(const box2&lt;Type&gt;&amp; b1, const box2&lt;Type&gt;&amp; b2)
89         {
90             return b1.getMin() == b2.getMin() &amp;&amp; b1.getMax() == b2.getMax();
91         }
92         friend bool operator!=(const box2&lt;Type&gt;&amp; b1, const box2&lt;Type&gt;&amp; b2)
93         {
94             return !(b1 == b2);
95         }</b></font>
96     private:
97         vec2&lt;Type&gt; m_min;
98         vec2&lt;Type&gt; m_max;
99     };
100     typedef box2&lt;int&gt; box2i;
101     typedef box2&lt;float&gt; box2f;
102     typedef box2&lt;double&gt; box2d;
} </pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>vec3.hpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #pragma once
2 #include &lt;gtl/gtl.hpp&gt;
3 namespace gtl {
4     template &lt;typename Type&gt;
5     struct vec3 {
6         union {
7             struct {
8                 Type x, y, z;
9             };
10             struct {
11                 Type r, g, b;
12             };
13             struct {
14                 Type u, v, w;
15             };
16             Type data[3];
17         };
18         vec3()
19             : x(0)
20             , y(0)
21             , z(0)
22         {
23         }
24         vec3(const Type v[3])
25             : x(v[0])
26             , y(v[1])
27             , z(v[2])
28         {
29         }
30         vec3(Type a_x, Type a_y, Type a_z)
31             : x(a_x)
32             , y(a_y)
33             , z(a_z)
34         {
35         }
36         vec3(const vec3&lt;Type&gt;&amp; a_vec)
37             : x(a_vec.x)
38             , y(a_vec.y)
39             , z(a_vec.z)
40         {
41         }
42         vec3&lt;Type&gt;&amp; setValue(const Type v[3])
43         {
44             x = v[0];
45             y = v[1];
46             z = v[2];
47             return *this;
48         }
49         vec3&lt;Type&gt;&amp; setValue(Type a_x, Type a_y, Type a_z)
50         {
51             x = a_x;
52             y = a_y;
53 <a name="1"></a>            z = a_z;
54             return *this;
55 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>        }
56         const Type* getValue() const
57         {
58             return data;
59         }
60         Type dot(const vec3&lt;Type&gt;&amp; a_vec) const
61         {
62             return (x * a_vec.x + y * a_vec.y + z * a_vec.z);
63         }
64         Type length() const
65         {
66             return (Type)std::sqrt(x * x + y * y + z * z);</b></font>
67         }
68         Type sqrLength() const
69         {
70             return (x * x + y * y + z * z);
71         }
72         Type normalize()
73         {
74             const Type magnitude = length();
75             if (magnitude &gt; 0)
76                 *this /= magnitude;
77             return magnitude;
78         }
79         vec3&lt;Type&gt; normalized() const
80         {
81             vec3&lt;Type&gt; v(*this);
82             v.normalize();
83             return v;
84         }
85         vec3&lt;Type&gt; cross(const vec3&lt;Type&gt;&amp; a_vec) const
86         {
87             return vec3&lt;Type&gt;(y * a_vec.z - a_vec.y * z,
88                               z * a_vec.x - a_vec.z * x,
89                               x * a_vec.y - a_vec.x * y);
90         }
91         void negate()
92         {
93             x = -x;
94             y = -y;
95             z = -z;
96         }
97         vec3&lt;Type&gt; reflect(const vec3&lt;Type&gt;&amp; N) const
98         {
99             const vec3&lt;Type&gt;&amp; I(*this);
100             return I - 2 * N.dot(I) * N;
101         }
102         vec3&lt;Type&gt; refract(const vec3&lt;Type&gt;&amp; N, Type eta) const
103         {
104             const vec3&lt;Type&gt;&amp; I(*this);
105             const Type k = 1.0 - eta * eta * (1.0 - N.dot(I) * N.dot(I));
106             return (k &lt; 0.0) ? 0 : eta * I - (eta * N.dot(I) + std::sqrt(k)) * N;
107         }
108         Type&amp; operator[](int i) { return reinterpret_cast&lt;Type*&gt;(this)[i]; }
109         const Type&amp; operator[](int i) const { return reinterpret_cast&lt;const Type*&gt;(this)[i]; }
110         vec3&lt;Type&gt;&amp; operator*=(const Type d)
111         {
112             x *= d;
113             y *= d;
114             z *= d;
115             return *this;
116         }
117         vec3&lt;Type&gt;&amp; operator/=(const Type d)
118         {
119             *this *= (1.0f / d);
120             return *this;
121         }
122         vec3&lt;Type&gt;&amp; operator*=(const vec3&lt;Type&gt;&amp; a_vec)
123         {
124             x *= a_vec.x;
125             y *= a_vec.y;
126             z *= a_vec.z;
127             return *this;
128         }
129         vec3&lt;Type&gt;&amp; operator+=(const vec3&lt;Type&gt;&amp; a_vec)
130         {
131             x += a_vec.x;
132             y += a_vec.y;
133             z += a_vec.z;
134             return *this;
135         }
136         vec3&lt;Type&gt;&amp; operator-=(const vec3&lt;Type&gt;&amp; a_vec)
137         {
138             x -= a_vec.x;
139             y -= a_vec.y;
140             z -= a_vec.z;
141             return *this;
142         }
143 <a name="0"></a>        //! Non-destructive negation operator.
144         vec3&lt;Type&gt; operator-() const
145         {
146 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>            return vec3&lt;Type&gt;(-x, -y, -z);
147         }
148         friend vec3&lt;Type&gt; operator*(const vec3&lt;Type&gt;&amp; a_vec, const Type d)
149         {
150             return vec3&lt;Type&gt;(a_vec.x * d, a_vec.y * d, a_vec.z * d);
151         }
152         friend vec3&lt;Type&gt; operator*(const Type d, const vec3&lt;Type&gt;&amp; a_vec)
153         {
154             return a_vec * d;
155         }</b></font>
156         friend vec3&lt;Type&gt; operator/(const vec3&lt;Type&gt;&amp; a_vec, const Type d)
157         {
158             return vec3&lt;Type&gt;(a_vec.x / d, a_vec.y / d, a_vec.z / d);
159         }
160         friend vec3&lt;Type&gt; operator*(const vec3&lt;Type&gt;&amp; v1, const vec3&lt;Type&gt;&amp; v2)
161         {
162             return vec3&lt;Type&gt;(v1.x * v2.x, v1.y * v2.y, v1.z * v2.z);
163         }
164         friend inline vec3&lt;Type&gt; operator+(const vec3&lt;Type&gt;&amp; v1, const vec3&lt;Type&gt;&amp; v2)
165         {
166             return vec3&lt;Type&gt;(v1.x + v2.x, v1.y + v2.y, v1.z + v2.z);
167         }
168         friend inline vec3&lt;Type&gt; operator-(const vec3&lt;Type&gt;&amp; v1, const vec3&lt;Type&gt;&amp; v2)
169         {
170             return vec3&lt;Type&gt;(v1.x - v2.x, v1.y - v2.y, v1.z - v2.z);
171         }
172         friend bool operator==(const vec3&lt;Type&gt;&amp; v1, const vec3&lt;Type&gt;&amp; v2)
173         {
174             return (v1.x == v2.x &amp;&amp; v1.y == v2.y &amp;&amp; v1.z == v2.z);
175         }
176         friend bool operator!=(const vec3&lt;Type&gt;&amp; v1, const vec3&lt;Type&gt;&amp; v2)
177         {
178             return !(v1 == v2);
179         }
180         bool equals(const vec3&lt;Type&gt;&amp; a_vec, const Type a_tolerance = 1E-2) const
181         {
182             return ((*this - a_vec).sqrLength() &lt;= a_tolerance * a_tolerance);
183         }
184         friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const vec3&lt;Type&gt;&amp; vect)
185         {
186             return os &lt;&lt; vect.x &lt;&lt; " " &lt;&lt; vect.y &lt;&lt; " " &lt;&lt; vect.z;
187         }
188         static vec3&lt;Type&gt; max()
189         {
190             return vec3&lt;Type&gt;(std::numeric_limits&lt;Type&gt;::max(),
191                               std::numeric_limits&lt;Type&gt;::max(),
192                               std::numeric_limits&lt;Type&gt;::max());
193         }
194     };
195     typedef vec3&lt;int&gt; vec3i;
196     typedef vec3&lt;float&gt; vec3f;
197     typedef vec3&lt;double&gt; vec3d;
} </pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
