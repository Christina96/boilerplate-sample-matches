
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 7.449392712550608%, Tokens: 11</h2>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-mkl_pooling_layer.cpp</h3>
            <pre><code>1  #ifdef MKL2017_SUPPORTED
2  #include <algorithm>
3  #include <cfloat>
4  #include <vector>
5  #include "caffe/common.hpp"
6  #include "caffe/layer.hpp"
7  #include "caffe/layers/mkl_layers.hpp"
8  #include "caffe/syncedmem.hpp"
9  #include "caffe/util/math_functions.hpp"
10  #include "caffe/util/performance.hpp"
11  namespace caffe {
12  template <typename Dtype>
13  MKLPoolingLayer<Dtype>::~MKLPoolingLayer() {
14    dnnDelete<Dtype>(poolingFwd);
15    dnnDelete<Dtype>(poolingBwd);
16  }
17  template <typename Dtype>
18  void MKLPoolingLayer<Dtype>::Init(
19        const vector<Blob<Dtype>*>& bottom,
20        const vector<Blob<Dtype>*>& top) {
21    PoolingParameter pool_param = this->layer_param_.pooling_param();
22    channels_ = bottom[0]->channels();
23    height_ = bottom[0]->height();
24    width_ = bottom[0]->width();
25    num_ = bottom[0]->num();
26    if (pool_param.global_pooling()) {
27      CHECK(!(pool_param.has_kernel_size() ||
28        pool_param.has_kernel_h() || pool_param.has_kernel_w()))
29        << "With Global_pooling: true Filter size cannot specified";
30    } else {
31      CHECK(!pool_param.has_kernel_size() !=
32        !(pool_param.has_kernel_h() && pool_param.has_kernel_w()))
33        << "Filter size is kernel_size OR kernel_h and kernel_w; not both";
34      CHECK(pool_param.has_kernel_size() ||
35        (pool_param.has_kernel_h() && pool_param.has_kernel_w()))
36        << "For non-square filters both kernel_h and kernel_w are required.";
37    }
38    CHECK((!pool_param.has_pad() && pool_param.has_pad_h()
39        && pool_param.has_pad_w())
40        || (!pool_param.has_pad_h() && !pool_param.has_pad_w()))
41        << "pad is pad OR pad_h and pad_w are required.";
42    CHECK((!pool_param.has_stride() && pool_param.has_stride_h()
43        && pool_param.has_stride_w())
44        || (!pool_param.has_stride_h() && !pool_param.has_stride_w()))
45        << "Stride is stride OR stride_h and stride_w are required.";
46    global_pooling_ = pool_param.global_pooling();
47    if (global_pooling_) {
48      kernel_h_ = bottom[0]->height();
49      kernel_w_ = bottom[0]->width();
50    } else {
<span onclick='openModal()' class='match'>51      if (pool_param.has_kernel_size()) {
52        kernel_h_ = kernel_w_ = pool_param.kernel_size();
53      } else {
54        kernel_h_ = pool_param.kernel_h();
55        kernel_w_ = pool_param.kernel_w();
56      }
57    }
</span>58    CHECK_GT(kernel_h_, 0) << "Filter dimensions cannot be zero.";
59    CHECK_GT(kernel_w_, 0) << "Filter dimensions cannot be zero.";
60    if (!pool_param.has_pad_h()) {
61      pad_h_ = pad_w_ = pool_param.pad();
62    } else {
63      pad_h_ = pool_param.pad_h();
64      pad_w_ = pool_param.pad_w();
65    }
66    if (!pool_param.has_stride_h()) {
67      stride_h_ = stride_w_ = pool_param.stride();
68    } else {
69      stride_h_ = pool_param.stride_h();
70      stride_w_ = pool_param.stride_w();
71    }
72    if (global_pooling_) {
73      CHECK(pad_h_ == 0 && pad_w_ == 0 && stride_h_ == 1 && stride_w_ == 1)
74        << "With Global_pooling: true; only pad = 0 and stride = 1";
75    }
76    if (pad_h_ != 0 || pad_w_ != 0) {
77      CHECK(this->layer_param_.pooling_param().pool()
78          == PoolingParameter_PoolMethod_AVE
79          || this->layer_param_.pooling_param().pool()
80          == PoolingParameter_PoolMethod_MAX)
81          << "Padding implemented only for average and max pooling.";
82      CHECK_LT(pad_h_, kernel_h_);
83      CHECK_LT(pad_w_, kernel_w_);
84    }
85    pooled_height_ = static_cast<int>(ceil(static_cast<float>(
86        bottom[0]->height() + 2 * pad_h_ - kernel_h_) / stride_h_)) + 1;
87    pooled_width_ = static_cast<int>(ceil(static_cast<float>(
88        bottom[0]->width() + 2 * pad_w_ - kernel_w_) / stride_w_)) + 1;
89    bool force_exclude_padding_flag_ = false;
90    if (pad_h_ || pad_w_ || kernel_h_ == 1 || kernel_w_ == 1) {
91      if ((pooled_height_ - 1) * stride_h_ >= bottom[0]->height() + pad_h_) {
92        --pooled_height_;
93      }
94      if ((pooled_width_ - 1) * stride_w_ >= bottom[0]->width() + pad_w_) {
95        --pooled_width_;
96      }
97      CHECK_LT((pooled_height_ - 1) * stride_h_, bottom[0]->height() + pad_h_);
98      CHECK_LT((pooled_width_ - 1) * stride_w_, bottom[0]->width() + pad_w_);
99    }
100    else
101    {
102      force_exclude_padding_flag_ = true;
103    }
104    top[0]->Reshape(bottom[0]->num(), channels_, pooled_height_,
105        pooled_width_);
106    if (top.size() > 1) {
107      (reinterpret_cast<Blob<size_t>* > (top[1]) )->Reshape(bottom[0]->num(),
108              channels_, pooled_height_, pooled_width_);
109    }
110    if (top.size() == 1) {
111      max_idx_.Reshape(bottom[0]->num(), channels_, pooled_height_,
112              pooled_width_);
113    }
114    if (this->layer_param_.pooling_param().pool() ==
115        PoolingParameter_PoolMethod_STOCHASTIC) {
116      rand_idx_.Reshape(bottom[0]->num(), channels_, pooled_height_,
117        pooled_width_);
118    }
119    switch (this->layer_param_.pooling_param().pool()) {
120    case PoolingParameter_PoolMethod_MAX:
121      this->algorithm = dnnAlgorithmPoolingMax;
122      break;
123    case PoolingParameter_PoolMethod_AVE:
124      if (this->layer_param_.pooling_param().avg_include_pad()) {
125          this->algorithm = dnnAlgorithmPoolingAvgIncludePadding;
126      }
127      else {
128          this->algorithm = dnnAlgorithmPoolingAvgExcludePadding;
129      }
130      if (force_exclude_padding_flag_ == true)
131      {
132          this->algorithm = dnnAlgorithmPoolingAvgExcludePadding;
133      }
134      break;
135    case PoolingParameter_PoolMethod_STOCHASTIC:
136      NOT_IMPLEMENTED;
137      break;
138    default:
139      LOG(FATAL) << "Unknown pooling method.";
140    }
141    dim = 4;
142    src_sizes[0] = bottom[0]->width();
143    src_sizes[1] = bottom[0]->height();
144    src_sizes[2] = bottom[0]->channels();
145    src_sizes[3] = bottom[0]->num();
146    src_strides[0] = 1;
147    src_strides[1] = src_sizes[0];
148    src_strides[2] = src_sizes[0]*src_sizes[1];
149    src_strides[3] = src_sizes[0]*src_sizes[1]*src_sizes[2];
150    dst_sizes[0] = pooled_width_;
151    dst_sizes[1] = pooled_height_;
152    dst_sizes[2] = src_sizes[2];
153    dst_sizes[3] = src_sizes[3];
154    dst_strides[0] = 1;
155    dst_strides[1] = dst_sizes[0];
156    dst_strides[2] = dst_sizes[0]*dst_sizes[1];
157    dst_strides[3] = dst_sizes[0]*dst_sizes[1]*dst_sizes[2];
158    src_offset[0] = -pad_w_;
159    src_offset[1] = -pad_h_;
160    kernel_stride[0] = stride_w_;
161    kernel_stride[1] = stride_h_;
162    kernel_size[0] = kernel_w_;
163    kernel_size[1] = kernel_h_;
164    fwd_bottom_data->name = "fwd_bottom_data   @ " + this->layer_param_.name();
165    fwd_top_data->name =    "fwd_top_data      @ " + this->layer_param_.name();
166    bwd_top_diff->name =    "bwd_top_diff      @ " + this->layer_param_.name();
167    bwd_bottom_diff->name = "bwd_bottom_diff   @ " + this->layer_param_.name();
168    fwd_top_data   ->create_user_layout(dim, dst_sizes, dst_strides, false);
169    bwd_bottom_diff->create_user_layout(dim, src_sizes, src_strides, false);
170    bwd_top_diff   ->create_user_layout(dim, dst_sizes, dst_strides, false);
171    dnnDelete<Dtype>(poolingFwd);
172    dnnDelete<Dtype>(poolingBwd);
173  }
174  template <typename Dtype>
175  void MKLPoolingLayer<Dtype>::LayerSetUp(const vector<Blob<Dtype>*>& bottom,
176        const vector<Blob<Dtype>*>& top) {
177    Init(bottom, top);
178  }
179  template <typename Dtype>
180  void MKLPoolingLayer<Dtype>::Reshape(const vector<Blob<Dtype>*>& bottom,
181        const vector<Blob<Dtype>*>& top) {
182    CHECK_EQ(4, bottom[0]->num_axes()) << "Input must have 4 axes, "
183        << "corresponding to (num, channels, height, width)";
184    if (channels_ == bottom[0]->channels() &&
185        height_ == bottom[0]->height() &&
186        width_ == bottom[0]->width() &&
187        num_ == bottom[0]->num()) {
188      reshape = false;
189      return;
190    }
191    reshape = true;
192    Init(bottom, top);
193  }
194  template <typename Dtype>
195  void MKLPoolingLayer<Dtype>::Forward_cpu(const vector<Blob<Dtype>*>& bottom,
196        const vector<Blob<Dtype>*>& top) {
197    size_t* mask = NULL;  
198    const bool use_top_mask = top.size() > 1;
199    dnnError_t status;
200    void* pooling_res[dnnResourceNumber];
201    mask = (use_top_mask) ?
202        reinterpret_cast<size_t*>(top[1]->mutable_cpu_data()) :
203        (max_idx_.mutable_cpu_data());
204    pooling_res[dnnResourceWorkspace] = reinterpret_cast<void*>(mask);
205    void* bottom_data =
206      reinterpret_cast<void *>(const_cast<Dtype*>(bottom[0]->prv_data()));
207    if (NULL == bottom_data) {
208      bottom_data =
209        reinterpret_cast<void *>(const_cast<Dtype*>(bottom[0]->cpu_data()));
210      if (NULL == poolingFwd || reshape) {
211        fwd_bottom_data->create_user_layout(dim, src_sizes, src_strides, false);
212        status = dnnPoolingCreateForward<Dtype>(&poolingFwd, NULL,
213                this->algorithm, fwd_bottom_data->layout_usr,
214                kernel_size, kernel_stride, src_offset, dnnBorderZeros);
215        CHECK_EQ(status, E_SUCCESS);
216        status = dnnPoolingCreateBackward<Dtype>(&poolingBwd, NULL,
217                this->algorithm, fwd_bottom_data->layout_usr,
218                kernel_size, kernel_stride, src_offset, dnnBorderZeros);
219        CHECK_EQ(status, E_SUCCESS);
220      }
221    } else if (NULL == poolingFwd || reshape) {
222      CHECK_EQ((bottom[0]->get_prv_data_descriptor())->get_descr_type(),
223              PrvMemDescr::PRV_DESCR_MKL2017);
224      shared_ptr<MKLData<Dtype> > mem_descr
225        =  boost::static_pointer_cast<MKLData<Dtype> >
226              (bottom[0]->get_prv_data_descriptor());
227      CHECK(mem_descr != NULL);
228      DLOG(INFO) << "Using layout of " << mem_descr->name
229              << " as input layout for " << this->layer_param_.name();
230      fwd_bottom_data = mem_descr;
231      status = dnnPoolingCreateForward<Dtype>(&poolingFwd, NULL,
232              this->algorithm, fwd_bottom_data->layout_int, kernel_size,
233              kernel_stride, src_offset, dnnBorderZeros);
234      CHECK_EQ(status, E_SUCCESS);
235      fwd_top_data->create_internal_layout(poolingFwd, dnnResourceDst);
236      status = dnnPoolingCreateBackward<Dtype>(&poolingBwd, NULL,
237              this->algorithm, fwd_bottom_data->layout_int, kernel_size,
238              kernel_stride, src_offset, dnnBorderZeros);
239      CHECK_EQ(status, E_SUCCESS);
240      bwd_top_diff   ->create_internal_layout(poolingFwd, dnnResourceDst);
241      bwd_bottom_diff->create_internal_layout(poolingFwd, dnnResourceSrc);
242    }
243    pooling_res[dnnResourceSrc] = bottom_data;
244    if (fwd_top_data->conversion_needed()) {
245      top[0]->set_prv_data_descriptor(fwd_top_data);
246      pooling_res[dnnResourceDst] =
247              reinterpret_cast<void *>(top[0]->mutable_prv_data());
248    } else {
249      pooling_res[dnnResourceDst] =
250              reinterpret_cast<void *>(top[0]->mutable_cpu_data());
251      DLOG(INFO) << "Using cpu_data for top in DnnPooling.";
252    }
253    PERFORMANCE_EVENT_ID_INIT(perf_id_fw_, PERFORMANCE_MKL_NAME("FW"));
254    PERFORMANCE_MEASUREMENT_BEGIN();
255    status = dnnExecute<Dtype>(poolingFwd, pooling_res);
256    PERFORMANCE_MEASUREMENT_END_ID(perf_id_fw_);
257    CHECK_EQ(status, E_SUCCESS);
258  }
259  template <typename Dtype>
260  void MKLPoolingLayer<Dtype>::Backward_cpu(const vector<Blob<Dtype>*>& top,
261        const vector<bool>& propagate_down, const vector<Blob<Dtype>*>& bottom) {
262    if (!propagate_down[0]) {
263      return;
264    }
265    const size_t* mask = NULL;  
266    dnnError_t e;
267    void* pooling_res[dnnResourceNumber];
268    mask = (top.size() > 1) ?
269      reinterpret_cast<const size_t*>(top[1]->cpu_data()) :
270      (max_idx_.cpu_data());
271    pooling_res[dnnResourceWorkspace] =
272      reinterpret_cast<void *>(const_cast<size_t*>(mask));
273    pooling_res[dnnResourceDiffDst] = bwd_top_diff->get_converted_prv(top[0],
274            true);
275    if (bwd_bottom_diff->conversion_needed()) {
276      bottom[0]->set_prv_diff_descriptor(bwd_bottom_diff);
277      pooling_res[dnnResourceDiffSrc] = bottom[0]->mutable_prv_diff();
278    } else {
279      pooling_res[dnnResourceDiffSrc] = bottom[0]->mutable_cpu_diff();
280    }
281    caffe_set(bottom[0]->count(), Dtype(0),
282            reinterpret_cast<Dtype *>(pooling_res[dnnResourceDiffSrc]));
283    PERFORMANCE_EVENT_ID_INIT(perf_id_bw_, PERFORMANCE_MKL_NAME("BW"));
284    PERFORMANCE_MEASUREMENT_BEGIN();
285    e = dnnExecute<Dtype>(poolingBwd, pooling_res);
286    PERFORMANCE_MEASUREMENT_END_ID(perf_id_bw_);
287    CHECK_EQ(e, E_SUCCESS);
288  }
289  #ifdef CPU_ONLY
290  STUB_GPU(MKLPoolingLayer);
291  #else
292  template <typename Dtype>
293  void MKLPoolingLayer<Dtype>::Forward_gpu(const vector<Blob<Dtype>*>& bottom,
294      const vector<Blob<Dtype>*>& top) {NOT_IMPLEMENTED;}
295  template <typename Dtype>
296  void MKLPoolingLayer<Dtype>::Backward_gpu(const vector<Blob<Dtype>*>& top,
297      const vector<bool>& propagate_down, const vector<Blob<Dtype>*>& bottom)
298    {NOT_IMPLEMENTED;}
299  #endif
300  INSTANTIATE_CLASS(MKLPoolingLayer);
301  }  
302  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-WindowsDlg.cpp</h3>
            <pre><code>1  #include <functional>
2  #include <algorithm>
3  #include "WindowsDlg.h"
4  #include "WindowsDlgRc.h"
5  #include "DocTabView.h"
6  #include "EncodingMapper.h"
7  #include "localization.h"
8  using namespace std;
9  #ifndef _countof
10  #define _countof(x) (sizeof(x)/sizeof((x)[0]))
11  #endif
12  #ifndef LVS_EX_DOUBLEBUFFER
13  #define LVS_EX_DOUBLEBUFFER     0x00010000
14  #endif
15  #define WD_ROOTNODE					"WindowsDlg"
16  #define WD_CLMNNAME					"ColumnName"
17  #define WD_CLMNPATH					"ColumnPath"
18  #define WD_CLMNTYPE					"ColumnType"
19  #define WD_CLMNSIZE					"ColumnSize"
20  #define WD_NBDOCSTOTAL				"NbDocsTotal"
21  #define WD_MENUCOPYNAME				"MenuCopyName"
22  #define WD_MENUCOPYPATH				"MenuCopyPath"
23  static const TCHAR *readonlyString = TEXT(" [Read Only]");
24  const UINT WDN_NOTIFY = RegisterWindowMessage(TEXT("WDN_NOTIFY"));
25  struct NumericStringEquivalence
26  {
27  	int operator()(const TCHAR* s1, const TCHAR* s2) const
28  	{
29  		return numstrcmp(s1, s2);
30  	}
31  	static inline int numstrcmp_get(const TCHAR **str, int *length)
32  	{
33  		const TCHAR *p = *str;
34  		int value = 0;
35  		for (*length = 0; isdigit(*p); ++(*length))
36  			value = value * 10 + *p++ - '0';
37  		*str = p;
38  		return (value);
39  	}
40  	static int numstrcmp(const TCHAR *str1, const TCHAR *str2)
41  	{
42  		TCHAR *p1 = nullptr, *p2 = nullptr;
43  		int c1 = 0, c2 = 0, lcmp = 0;
44  		for (;;)
45  		{
46  			if (*str1 == 0 || *str2 == 0)
47  			{
48  				if (*str1 != *str2)
49  					lcmp = *str1 - *str2;
50  				break;
51  			}
52  			if (_istdigit(*str1) && _istdigit(*str2))
53  			{
54  				lcmp = wcstol(str1, &p1, 10) - wcstol(str2, &p2, 10);
55  				if ( lcmp == 0 )
56  					lcmp = static_cast<int32_t>((p2 - str2) - (p1 - str1));
57  				if ( lcmp != 0 )
58  					break;
59  				str1 = p1, str2 = p2;
60  			}
61  			else
62  			{
63  				if (_istascii(*str1) && _istupper(*str1))
64  					c1 = towlower(*str1);
65  				else
66  					c1 = *str1;
67  				if (_istascii(*str2) && _istupper(*str2))
68  					c2 = towlower(*str2);
69  				else
70  					c2 = *str2;
71  				lcmp = (c1 - c2);
72  				if (lcmp != 0)
73  					break;
74  				++str1, ++str2;
75  			}
76  		}
77  		return ( lcmp < 0 ) ? -1 : (lcmp > 0 ? 1 : 0);
78  	}
79  };
80  struct BufferEquivalent
81  {
82  	NumericStringEquivalence _strequiv{};
83  	DocTabView* _pTab = nullptr;
84  	int _iColumn = 0;
85  	bool _reverse = false;
86  	BufferEquivalent(DocTabView* pTab, int iColumn, bool reverse)
87  		: _pTab(pTab), _iColumn(iColumn), _reverse(reverse)
88  	{}
89  	bool operator()(int i1, int i2) const
90  	{
91  		if (i1 == i2) return false; 
92  		if (_reverse) std::swap(i1, i2);
93  		return compare(i1, i2);
94  	}
95  	bool compare(int i1, int i2) const
96  	{
97  		if (_iColumn >= 0 && _iColumn <= 3)
98  		{
99  			BufferID bid1 = _pTab->getBufferByIndex(i1);
100  			BufferID bid2 = _pTab->getBufferByIndex(i2);
101  			Buffer * b1 = MainFileManager.getBufferByID(bid1);
102  			Buffer * b2 = MainFileManager.getBufferByID(bid2);
103  			if (_iColumn == 0)
104  			{
105  				const TCHAR *s1 = b1->getFileName();
106  				const TCHAR *s2 = b2->getFileName();
107  				int result = _strequiv(s1, s2);
108  				if (result != 0) 
109  					return result < 0;
110  			}
111  			else if (_iColumn == 2)
112  			{
113  				NppParameters & nppParameters = NppParameters::getInstance();
114  				const TCHAR *s1;
115  				const TCHAR *s2;
116  				Lang *lang1 = nppParameters.getLangFromID(b1->getLangType());
117  				if (lang1)
118  				{
119  					s1 = lang1->getLangName();
120  				}
121  				else
122  					s1 = TEXT("");
123  				Lang *lang2 = nppParameters.getLangFromID(b2->getLangType());
124  				if (lang2)
125  				{
126  					s2 = lang2->getLangName();
127  				}
128  				else
129  					s2 = TEXT("");
130  				int result = _strequiv(s1, s2);
131  				if (result != 0) 
132  					return result < 0;
133  			}
134  			else if (_iColumn == 3)
135  			{
136  				auto t1 = b1->docLength();
137  				auto t2 = b2->docLength();
138  				if (t1 != t2) 
139  					return (t1 < t2);
140  			}
141  			const TCHAR *s1 = b1->getFullPathName();
142  			const TCHAR *s2 = b2->getFullPathName();
143  			return _strequiv(s1, s2) < 0;	
144  		}
145  		return false;
146  	}
147  };
148  BEGIN_WINDOW_MAP(WindowsDlgMap)
149  	BEGINROWS(WRCT_REST,0,RCMARGINS(8,8))
150  		BEGINCOLS(WRCT_REST,0,0)                       
151  			BEGINROWS(WRCT_REST,0,0)
152  				RCREST(IDC_WINDOWS_LIST)
153  			ENDGROUP()
154  			RCSPACE(12)
155  			BEGINROWS(WRCT_TOFIT,0,0)
156  			RCSPACE(12)
157  			RCTOFIT(IDOK)
158  			RCSPACE(-12)
159  			RCTOFIT(IDC_WINDOWS_SAVE)
160  			RCSPACE(-12)
161  			RCTOFIT(IDC_WINDOWS_CLOSE)
162  			RCSPACE(-12)
163  			RCTOFIT(IDC_WINDOWS_SORT)
164  			RCREST(-1)
165  			RCTOFIT(IDCANCEL)
166  			ENDGROUP()
167  		ENDGROUP()
168  	ENDGROUP()
169  END_WINDOW_MAP()
170  RECT WindowsDlg::_lastKnownLocation;
171  WindowsDlg::WindowsDlg() : MyBaseClass(WindowsDlgMap)
172  {
173  	_szMinButton = SIZEZERO;
174  	_szMinListCtrl = SIZEZERO;
175  }
176  void WindowsDlg::init(HINSTANCE hInst, HWND parent, DocTabView *pTab)
177  {
178  	MyBaseClass::init(hInst, parent);
179  	_pTab = pTab;
180  }
181  void WindowsDlg::init(HINSTANCE hInst, HWND parent)
182  {
183  	assert(!"Call other initialize method");
184  	MyBaseClass::init(hInst, parent);
185  	_pTab = NULL;
186  }
187  intptr_t CALLBACK WindowsDlg::run_dlgProc(UINT message, WPARAM wParam, LPARAM lParam)
188  {
189  	switch (message)
190  	{
191  		case WM_INITDIALOG :
192  		{
193  			NativeLangSpeaker *pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
194  			pNativeSpeaker->changeDlgLang(_hSelf, "Window");
195  			NppDarkMode::autoSubclassAndThemeChildControls(_hSelf);
196  			NppDarkMode::autoSubclassAndThemeWindowNotify(_hSelf);
197  			return MyBaseClass::run_dlgProc(message, wParam, lParam);
198  		}
199  		case WM_CTLCOLORDLG:
200  		case WM_CTLCOLORSTATIC:
201  		{
202  			return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
203  		}
204  		case WM_PRINTCLIENT:
205  		{
206  			if (NppDarkMode::isEnabled())
207  			{
208  				return TRUE;
209  			}
210  			break;
211  		}
212  		case NPPM_INTERNAL_REFRESHDARKMODE:
213  		{
214  			NppDarkMode::autoThemeChildControls(_hSelf);
215  			return TRUE;
216  		}
217  		case WM_COMMAND :
218  		{
219  			switch (wParam)
220  			{
221  				case IDOK:
222  				{
223  					activateCurrent();
224  					return TRUE;
225  				}
226  				case IDCANCEL:
227  				{
228  					::GetWindowRect(_hSelf, &_lastKnownLocation);
229  					EndDialog(_hSelf, IDCANCEL);
230  					return TRUE;
231  				}
232  				case IDC_WINDOWS_SAVE:
233  				{
234  					doSave();
235  					return TRUE;
236  				}
237  				case IDC_WINDOWS_CLOSE:
238  				{
239  					doClose();
240  					return TRUE;
241  				}
242  				case IDC_WINDOWS_SORT:
243  				{
244  					if (_currentColumn == -1)
245  					{
246  						_currentColumn = 0;
247  						_reverseSort = false;
248  						_lastSort = _currentColumn;
249  						updateColumnNames();
250  						doColumnSort();
251  					}
252  					doSortToTabs();
253  					doColumnSort();
254  					break;
255  				}
256  				default:
257  					if (HIWORD(wParam) == 0)
258  					{
259  						switch (LOWORD(wParam))
260  						{
261  						case IDM_WINDOW_COPY_NAME:
262  							putItemsToClipboard(false);
263  							break;
264  						case IDM_WINDOW_COPY_PATH:
265  							putItemsToClipboard(true);
266  							break;
267  						}
268  					}
269  					break;
270  			}
271  			break;
272  		}
273  		case WM_DESTROY:
274  		{
275  			return TRUE;
276  		}
277  		case WM_NOTIFY :
278  		{
279  			if (wParam == IDC_WINDOWS_LIST)
280  			{
281  				NMHDR* pNMHDR = reinterpret_cast<NMHDR*>(lParam);
282  				if (pNMHDR->code == LVN_GETDISPINFO)
283  				{
284  					NMLVDISPINFO *pLvdi = (NMLVDISPINFO *)pNMHDR;
285  					if (pLvdi->item.mask & LVIF_TEXT)
286  					{
287  						pLvdi->item.pszText[0] = 0;
288  						Buffer* buf = getBuffer(pLvdi->item.iItem);
289  						if (!buf)
290  							return FALSE;
291  						generic_string text;
292  						if (pLvdi->item.iSubItem == 0) 
293  						{
294  							text = buf->getFileName();
295  							if (buf->isDirty())
296  							{
297  								text += '*';
298  							}
299  							else if (buf->isReadOnly())
300  							{
301  								text += readonlyString;
302  							}
303  						}
304  						else if (pLvdi->item.iSubItem == 1) 
305  						{
306  							const TCHAR *fullName = buf->getFullPathName();
307  							const TCHAR *fileName = buf->getFileName();
308  							int len = lstrlen(fullName)-lstrlen(fileName);
309  							if (!len) {
310  								len = 1;
311  								fullName = TEXT("");
312  							}
313  							text.assign(fullName, len);
314  						}
315  						else if (pLvdi->item.iSubItem == 2) 
316  						{
317  							NppParameters& nppParameters = NppParameters::getInstance();
318  							Lang *lang = nppParameters.getLangFromID(buf->getLangType());
319  							if (NULL != lang)
320  							{
321  								text = lang->getLangName();
322  							}
323  						}
324  						else if (pLvdi->item.iSubItem == 3) 
325  						{
326  							size_t docSize = buf->docLength();
327  							string docSizeText = to_string(docSize);
328  							text = wstring(docSizeText.begin(), docSizeText.end());
329  						}
330  						if (static_cast<int>(text.length()) < pLvdi->item.cchTextMax)
331  						{
332  							wcscpy_s(pLvdi->item.pszText, text.length() + 1, text.c_str());
333  						}
334  					}
335  					return TRUE;
336  				}
337  				else if (pNMHDR->code == LVN_COLUMNCLICK) 
338  				{
339  					NMLISTVIEW *pNMLV = (NMLISTVIEW *)pNMHDR;
340  					if (pNMLV->iItem == -1)
341  					{
342  						_currentColumn = pNMLV->iSubItem;
<span onclick='openModal()' class='match'>343  						if (_lastSort == _currentColumn)
344  						{
345  							_reverseSort = true;
346  							_lastSort = -1;
347  						}
348  						else
349  						{
350  							_reverseSort = false;
351  							_lastSort = _currentColumn;
352  						}
353  						updateColumnNames();
354  						doColumnSort();
355  					}
</span>356  					return TRUE;
357  				}
358  				else if (pNMHDR->code == LVN_ITEMACTIVATE || pNMHDR->code == LVN_ITEMCHANGED || pNMHDR->code == LVN_ODSTATECHANGED)
359  				{
360  					updateButtonState();
361  					return TRUE;
362  				}
363  				else if (pNMHDR->code == NM_DBLCLK)
364  				{
365  					::PostMessage(_hSelf, WM_COMMAND, IDOK, 0);
366  					return TRUE;
367  				}
368  				else if (pNMHDR->code == LVN_KEYDOWN)
369  				{
370  					NMLVKEYDOWN *lvkd = (NMLVKEYDOWN *)pNMHDR;
371  					short ctrl = GetKeyState(VK_CONTROL);
372  					short alt = GetKeyState(VK_MENU);
373  					short shift = GetKeyState(VK_SHIFT);
374  					if (lvkd->wVKey == 'A' && ctrl<0 && alt>=0 && shift>=0)
375  					{
376  						for (int i=0, n=ListView_GetItemCount(_hList); i<n; ++i)
377  							ListView_SetItemState(_hList, i, LVIS_SELECTED, LVIS_SELECTED);
378  					}
379  					else if (lvkd->wVKey == 'C' && ctrl & 0x80)
380  					{
381  						if (ListView_GetSelectedCount(_hList) != 0)
382  							putItemsToClipboard(true);
383  					}
384  					return TRUE;
385  				}
386  			}
387  			break;
388  		}
389  		case WM_CONTEXTMENU:
390  			{
391  				if (!_listMenu.isCreated())
392  				{
393  					NativeLangSpeaker* pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
394  					const std::vector<MenuItemUnit> itemUnitArray
395  					{
396  						{IDM_WINDOW_COPY_NAME, pNativeSpeaker->getAttrNameStr(TEXT("Copy Name(s)"), WD_ROOTNODE, WD_MENUCOPYNAME)},
397  						{IDM_WINDOW_COPY_PATH, pNativeSpeaker->getAttrNameStr(TEXT("Copy Pathname(s)"), WD_ROOTNODE, WD_MENUCOPYPATH)}
398  					};
399  					_listMenu.create(_hSelf, itemUnitArray);
400  				}
401  				const bool enableMenu = ListView_GetSelectedCount(_hList) != 0;
402  				_listMenu.enableItem(IDM_WINDOW_COPY_NAME, enableMenu);
403  				_listMenu.enableItem(IDM_WINDOW_COPY_PATH, enableMenu);
404  				POINT p{};
405  				::GetCursorPos(&p);
406  				_listMenu.display(p);
407  			}
408  			return TRUE;
409  	}
410  	return MyBaseClass::run_dlgProc(message, wParam, lParam);
411  }
412  void WindowsDlg::doColumnSort()
413  {
414  	if (_currentColumn == -1)
415  		return;
416  	size_t i = 0;
417  	size_t n = _idxMap.size();
418  	vector<int> sortMap;
419  	sortMap.resize(n);
420  	for (; i < n; ++i)
421  		sortMap[_idxMap[i]] = ListView_GetItemState(_hList, i, LVIS_SELECTED);
422  	stable_sort(_idxMap.begin(), _idxMap.end(), BufferEquivalent(_pTab, _currentColumn, _reverseSort));
423  	for (i = 0; i < n; ++i)
424  		ListView_SetItemState(_hList, i, sortMap[_idxMap[i]] ? LVIS_SELECTED : 0, LVIS_SELECTED);
425  	::InvalidateRect(_hList, &_rc, FALSE);
426  	updateButtonState();
427  }
428  void WindowsDlg::updateButtonState()
429  {
430  	int nSelection = ListView_GetSelectedCount(_hList);
431  	if (nSelection == 0)
432  	{
433  		EnableWindow(GetDlgItem(_hSelf, IDOK), FALSE);
434  		EnableWindow(GetDlgItem(_hSelf, IDC_WINDOWS_SAVE), FALSE);
435  		EnableWindow(GetDlgItem(_hSelf, IDC_WINDOWS_CLOSE), FALSE);
436  	}
437  	else
438  	{
439  		EnableWindow(GetDlgItem(_hSelf, IDC_WINDOWS_SAVE), TRUE);
440  		EnableWindow(GetDlgItem(_hSelf, IDC_WINDOWS_CLOSE), TRUE);
441  		if (nSelection == 1)
442  			EnableWindow(GetDlgItem(_hSelf, IDOK), TRUE);
443  		else
444  			EnableWindow(GetDlgItem(_hSelf, IDOK), FALSE);
445  	}
446  	EnableWindow(GetDlgItem(_hSelf, IDC_WINDOWS_SORT), TRUE);
447  }
448  int WindowsDlg::doDialog()
449  {
450  	return static_cast<int>(DialogBoxParam(_hInst, MAKEINTRESOURCE(IDD_WINDOWS), _hParent, dlgProc, reinterpret_cast<LPARAM>(this)));
451  }
452  BOOL WindowsDlg::onInitDialog()
453  {
454  	_winMgr.InitToFitSizeFromCurrent(_hSelf);
455  	_szMinButton = RectToSize(_winMgr.GetRect(IDOK));
456  	_szMinListCtrl = RectToSize(_winMgr.GetRect(IDC_WINDOWS_LIST));
457  	_currentColumn = -1;
458  	_lastSort = -1;
459  	_reverseSort = false;
460  	_winMgr.CalcLayout(_hSelf);
461  	_winMgr.SetWindowPositions(_hSelf);
462  	getClientRect(_rc);
463  	_hList = ::GetDlgItem(_hSelf, IDC_WINDOWS_LIST);
464  	DWORD exStyle = ListView_GetExtendedListViewStyle(_hList);
465  	exStyle |= LVS_EX_HEADERDRAGDROP|LVS_EX_FULLROWSELECT|LVS_EX_DOUBLEBUFFER;
466  	ListView_SetExtendedListViewStyle(_hList, exStyle);
467  	COLORREF fgColor = (NppParameters::getInstance()).getCurrentDefaultFgColor();
468  	COLORREF bgColor = (NppParameters::getInstance()).getCurrentDefaultBgColor();
469  	ListView_SetBkColor(_hList, bgColor);
470  	ListView_SetTextBkColor(_hList, bgColor);
471  	ListView_SetTextColor(_hList, fgColor);
472  	RECT rc{};
473  	GetClientRect(_hList, &rc);
474  	LONG width = rc.right - rc.left;
475  	LVCOLUMN lvColumn{};
476  	lvColumn.mask = LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM | LVCF_FMT;
477  	lvColumn.fmt = LVCFMT_LEFT;
478  	generic_string columnText;
479  	NativeLangSpeaker *pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
480  	columnText = TEXT("⇵ ") + pNativeSpeaker->getAttrNameStr(TEXT("Name"), WD_ROOTNODE, WD_CLMNNAME);
481  	lvColumn.pszText = const_cast<TCHAR *>(columnText.c_str());
482  	lvColumn.cx = width / 4;
483  	SendMessage(_hList, LVM_INSERTCOLUMN, 0, LPARAM(&lvColumn));
484  	columnText = TEXT("⇵ ") + pNativeSpeaker->getAttrNameStr(TEXT("Path"), WD_ROOTNODE, WD_CLMNPATH);
485  	lvColumn.pszText = const_cast<TCHAR *>(columnText.c_str());
486  	lvColumn.cx = 300;
487  	SendMessage(_hList, LVM_INSERTCOLUMN, 1, LPARAM(&lvColumn));
488  	lvColumn.fmt = LVCFMT_CENTER;
489  	columnText = TEXT("⇵ ") + pNativeSpeaker->getAttrNameStr(TEXT("Type"), WD_ROOTNODE, WD_CLMNTYPE);
490  	lvColumn.pszText = const_cast<TCHAR *>(columnText.c_str());
491  	lvColumn.cx = 100;
492  	SendMessage(_hList, LVM_INSERTCOLUMN, 2, LPARAM(&lvColumn));
493  	columnText = TEXT("⇵ ") + pNativeSpeaker->getAttrNameStr(TEXT("Size"), WD_ROOTNODE, WD_CLMNSIZE);
494  	lvColumn.pszText = const_cast<TCHAR *>(columnText.c_str());
495  	lvColumn.cx = 100;
496  	SendMessage(_hList, LVM_INSERTCOLUMN, 3, LPARAM(&lvColumn));
497  	fitColumnsToSize();
498  	if (_lastKnownLocation.bottom > 0 && _lastKnownLocation.right > 0)
499  	{
500  		SetWindowPos(_hSelf, NULL, _lastKnownLocation.left, _lastKnownLocation.top,
501  			_lastKnownLocation.right-_lastKnownLocation.left, _lastKnownLocation.bottom-_lastKnownLocation.top, SWP_SHOWWINDOW);
502  	}
503  	else
504  	{
505  		goToCenter();
506  	}
507  	doRefresh(true);
508  	return TRUE;
509  }
510  void WindowsDlg::updateColumnNames()
511  {
512  	LVCOLUMN lvColumn{};
513  	lvColumn.mask = LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM | LVCF_FMT;
514  	lvColumn.fmt = LVCFMT_LEFT;
515  	generic_string columnText;
516  	NativeLangSpeaker *pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
517  	columnText = pNativeSpeaker->getAttrNameStr(TEXT("Name"), WD_ROOTNODE, WD_CLMNNAME);
518  	if (_currentColumn != 0)
519  	{
520  		columnText = TEXT("⇵ ") + columnText;
521  	}
522  	else if (_reverseSort)
523  	{
524  		columnText = TEXT("△ ") + columnText;
525  	}
526  	else
527  	{
528  		columnText = TEXT("▽ ") + columnText;
529  	}
530  	lvColumn.pszText = const_cast<TCHAR *>(columnText.c_str());
531  	lvColumn.cx = static_cast<int>(SendMessage(_hList, LVM_GETCOLUMNWIDTH, 0, 0));
532  	SendMessage(_hList, LVM_SETCOLUMN, 0, LPARAM(&lvColumn));
533  	columnText = pNativeSpeaker->getAttrNameStr(TEXT("Path"), WD_ROOTNODE, WD_CLMNPATH);
534  	if (_currentColumn != 1)
535  	{
536  		columnText = TEXT("⇵ ") + columnText;
537  	}
538  	else if (_reverseSort)
539  	{
540  		columnText = TEXT("△ ") + columnText;
541  	}
542  	else
543  	{
544  		columnText = TEXT("▽ ") + columnText;
545  	}
546  	lvColumn.pszText = const_cast<TCHAR *>(columnText.c_str());
547  	lvColumn.cx = static_cast<int>(SendMessage(_hList, LVM_GETCOLUMNWIDTH, 1, 0));
548  	SendMessage(_hList, LVM_SETCOLUMN, 1, LPARAM(&lvColumn));
549  	lvColumn.fmt = LVCFMT_CENTER;
550  	columnText = pNativeSpeaker->getAttrNameStr(TEXT("Type"), WD_ROOTNODE, WD_CLMNTYPE);
551  	if (_currentColumn != 2)
552  	{
553  		columnText = TEXT("⇵ ") + columnText;
554  	}
555  	else if (_reverseSort)
556  	{
557  		columnText = TEXT("△ ") + columnText;
558  	}
559  	else
560  	{
561  		columnText = TEXT("▽ ") + columnText;
562  	}
563  	lvColumn.pszText = const_cast<TCHAR *>(columnText.c_str());
564  	lvColumn.cx = static_cast<int>(SendMessage(_hList, LVM_GETCOLUMNWIDTH, 2, 0));
565  	SendMessage(_hList, LVM_SETCOLUMN, 2, LPARAM(&lvColumn));
566  	columnText = pNativeSpeaker->getAttrNameStr(TEXT("Size"), WD_ROOTNODE, WD_CLMNSIZE);
567  	if (_currentColumn != 3)
568  	{
569  		columnText = TEXT("⇵ ") + columnText;
570  	}
571  	else if (_reverseSort)
572  	{
573  		columnText = TEXT("△ ") + columnText;
574  	}
575  	else
576  	{
577  		columnText = TEXT("▽ ") + columnText;
578  	}
579  	lvColumn.pszText = const_cast<TCHAR *>(columnText.c_str());
580  	lvColumn.cx = static_cast<int>(SendMessage(_hList, LVM_GETCOLUMNWIDTH, 3, 0));
581  	SendMessage(_hList, LVM_SETCOLUMN, 3, LPARAM(&lvColumn));
582  }
583  void WindowsDlg::onSize(UINT nType, int cx, int cy)
584  {
585  	MyBaseClass::onSize(nType, cx, cy);
586  	fitColumnsToSize();
587  }
588  void WindowsDlg::onGetMinMaxInfo(MINMAXINFO* lpMMI)
589  {
590  	MyBaseClass::onGetMinMaxInfo(lpMMI);
591  }
592  LRESULT WindowsDlg::onWinMgr(WPARAM wp, LPARAM lp)
593  {
594  	NMWINMGR &nmw = *reinterpret_cast<NMWINMGR *>(lp);
595  	if (nmw.code==NMWINMGR::GET_SIZEINFO) {
596  		switch(wp)
597  		{
598  		case IDOK:
599  		case IDCANCEL:
600  		case IDC_WINDOWS_SAVE:
601  		case IDC_WINDOWS_CLOSE:
602  		case IDC_WINDOWS_SORT:
603  			nmw.sizeinfo.szMin = _szMinButton;
604  			nmw.processed = TRUE;
605  			return TRUE;
606  		case IDC_WINDOWS_LIST:
607  			nmw.sizeinfo.szMin = _szMinListCtrl;
608  			nmw.processed = TRUE;
609  			return TRUE;
610  		}
611  	}
612  	return MyBaseClass::onWinMgr(wp, lp);
613  }
614  void WindowsDlg::doRefresh(bool invalidate &bsol;*= false*/)
615  {
616  	if (_hSelf != NULL && isVisible())
617  	{
618  		if (_hList != NULL)
619  		{
620  			size_t count = (_pTab != NULL) ? _pTab->nbItem() : 0;
621  			size_t oldSize = _idxMap.size();
622  			if (!invalidate && count == oldSize)
623  				return;
624  			if (count != oldSize)
625  			{
626  				size_t lo = 0;
627  				_idxMap.resize(count);
628  				if (oldSize < count)
629  					lo = oldSize;
630  				for (size_t i = lo; i < count; ++i)
631  					_idxMap[i] = int(i);
632  			}
633  			LPARAM lp = invalidate ? LVSICF_NOSCROLL|LVSICF_NOINVALIDATEALL : LVSICF_NOSCROLL;
634  			::SendMessage(_hList, LVM_SETITEMCOUNT, count, lp);
635  			::InvalidateRect(_hList, &_rc, FALSE);
636  			resetSelection();
637  			updateButtonState();
638  			doCount();
639  		}
640  	}
641  }
642  void WindowsDlg::fitColumnsToSize()
643  {
644  	RECT rc{};
645  	if (GetClientRect(_hList, &rc))
646  	{
647  		int len = (rc.right - rc.left);
648  		len -= static_cast<int>(SendMessage(_hList, LVM_GETCOLUMNWIDTH, 0, 0));
649  		len -= static_cast<int>(SendMessage(_hList, LVM_GETCOLUMNWIDTH, 2, 0));
650  		len -= static_cast<int>(SendMessage(_hList, LVM_GETCOLUMNWIDTH, 3, 0));
651  		len -= GetSystemMetrics(SM_CXVSCROLL);
652  		len -= 1;
653  		SendMessage(_hList, LVM_SETCOLUMNWIDTH, 1, len);
654  	}
655  }
656  void WindowsDlg::resetSelection()
657  {
658  	assert(_pTab != nullptr);
659  	auto curSel = _pTab->getCurrentTabIndex();
660  	int pos = 0;
661  	for (vector<int>::iterator itr = _idxMap.begin(), end = _idxMap.end(); itr != end; ++itr, ++pos)
662  	{
663  		if (*itr == curSel)
664  		{
665  			ListView_SetItemState(_hList, pos, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
666  		}
667  		else
668  		{
669  			ListView_SetItemState(_hList, pos, 0, LVIS_SELECTED);
670  		}
671  	}
672  }
673  void WindowsDlg::doSave()
674  {
675  	NMWINDLG nmdlg{};
676  	nmdlg.type = WDT_SAVE;
677  	nmdlg.curSel = ListView_GetNextItem(_hList, -1, LVNI_SELECTED);
678  	nmdlg.hwndFrom = _hSelf;
679  	nmdlg.code = WDN_NOTIFY;
680  	nmdlg.nItems = ListView_GetSelectedCount(_hList);
681  	nmdlg.Items = new UINT[nmdlg.nItems];
682  	int i = -1;
683  	for (UINT j = 0; j < nmdlg.nItems; ++j)
684  	{
685  		i = ListView_GetNextItem(_hList, i, LVNI_SELECTED);
686  		if (i == -1) break;
687  		nmdlg.Items[j] = _idxMap[i];
688  	}
689  	SendMessage(_hParent, WDN_NOTIFY, 0, LPARAM(&nmdlg));
690  	delete[] nmdlg.Items;
691  	::InvalidateRect(_hList, &_rc, FALSE);
692  	ListView_RedrawItems(_hList, 0, ListView_GetSelectedCount(_hList));
693  }
694  void WindowsDlg::destroy()
695  {
696  	::GetWindowRect(_hSelf, &_lastKnownLocation);
697  	HWND hSelf = _hSelf;
698  	_hSelf = NULL;
699  	::DestroyWindow(hSelf);
700  }
701  void WindowsDlg::activateCurrent()
702  {
703  	if (ListView_GetSelectedCount(_hList) == 1)
704  	{
705  		NMWINDLG nmdlg{};
706  		nmdlg.type = WDT_ACTIVATE;
707  		nmdlg.curSel = _idxMap[ListView_GetNextItem(_hList, -1, LVNI_ALL|LVNI_SELECTED)];
708  		nmdlg.hwndFrom = _hSelf;
709  		nmdlg.code = WDN_NOTIFY;
710  		SendMessage(_hParent, WDN_NOTIFY, 0, LPARAM(&nmdlg));
711  		::GetWindowRect(_hSelf, &_lastKnownLocation);
712  		EndDialog(_hSelf, IDOK);
713  	}
714  }
715  void WindowsDlg::doClose()
716  {
717  	NMWINDLG nmdlg{};
718  	nmdlg.type = WDT_CLOSE;
719  	int index = ListView_GetNextItem(_hList, -1, LVNI_ALL|LVNI_SELECTED);
720  	if (index == -1) return;
721  	nmdlg.curSel = _idxMap[index];
722  	nmdlg.hwndFrom = _hSelf;
723  	nmdlg.code = WDN_NOTIFY;
724  	UINT n = nmdlg.nItems = ListView_GetSelectedCount(_hList);
725  	nmdlg.Items = new UINT[nmdlg.nItems];
726  	vector<int> key;
727  	key.resize(n, 0x7fffffff);
728  	int i = -1;
729  	for (UINT j = 0; j < n; ++j)
730  	{
731  		i = ListView_GetNextItem(_hList, i, LVNI_SELECTED);
732  		if (i == -1) break;
733  		ListView_SetItemState(_hList, i, 0, LVIS_SELECTED); 
734  		nmdlg.Items[j] = _idxMap[i];
735  		key[j] = i;
736  	}
737  	SendMessage(_hParent, WDN_NOTIFY, 0, LPARAM(&nmdlg));
738  	if (nmdlg.processed)
739  	{
740  		vector<int>::iterator kitr = key.begin();
741  		for (UINT i = 0; i < n; ++i, ++kitr)
742  		{
743  			if (nmdlg.Items[i] == ((UINT)-1))
744  			{
745  				int oldVal = _idxMap[*kitr];
746  				_idxMap[*kitr] = -1;
747  				for (vector<int>::iterator itr = _idxMap.begin(), end = _idxMap.end(); itr != end; ++itr)
748  					if (*itr > oldVal)
749  						--(*itr);
750  			}
751  		}
752  		_idxMap.erase(remove_if(_idxMap.begin(), _idxMap.end(), bind(equal_to<int>(), placeholders::_1, -1)), _idxMap.end());
753  	}
754  	delete[] nmdlg.Items;
755  	if (_idxMap.size() < 1)
756  		::SendMessage(_hSelf, WM_CLOSE, 0, 0);
757  	else if (_pTab->nbItem() != _idxMap.size())
758  		doRefresh(true);
759  	else
760  	{
761  		if (index == static_cast<int>(_idxMap.size()))
762  			index -= 1;
763  		if (index >= 0)
764  		{
765  			ListView_SetItemState(_hList, index, LVIS_SELECTED, LVIS_SELECTED);
766  			ListView_RedrawItems(_hList, 0, _idxMap.size() - 1);
767  		}
768  		ListView_SetItemCount(_hList, _idxMap.size());
769  	}
770  	doCount();
771  }
772  void WindowsDlg::doCount()
773  {
774  	NativeLangSpeaker* pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
775  	generic_string msg = pNativeSpeaker->getAttrNameStr(TEXT("Windows"), "Dialog", "Window", "title");
776  	msg += TEXT(" - ");
777  	msg += pNativeSpeaker->getAttrNameStr(TEXT("Total documents: "), WD_ROOTNODE, WD_NBDOCSTOTAL);
778  	msg += TEXT(" ");
779  	msg += to_wstring(_idxMap.size());
780  	SetWindowText(_hSelf,msg.c_str());
781  }
782  void WindowsDlg::doSort()
783  {
784  	if (_pTab == NULL)
785  		return;
786  	size_t count =  _pTab->nbItem();
787  	std::vector<UINT> items(count);
788  	auto currrentTabIndex = _pTab->getCurrentTabIndex();
789  	NMWINDLG nmdlg{};
790  	nmdlg.type = WDT_SORT;
791  	nmdlg.hwndFrom = _hSelf;
792  	nmdlg.curSel = currrentTabIndex;
793  	nmdlg.code = WDN_NOTIFY;
794  	nmdlg.nItems = static_cast<UINT>(count);
795  	nmdlg.Items = items.data();
796  	for (size_t i=0; i < count; ++i)
797  	{
798  		nmdlg.Items[i] = _idxMap[i];
799  	}
800  	SendMessage(_hParent, WDN_NOTIFY, 0, LPARAM(&nmdlg));
801  	if (nmdlg.processed)
802  	{
803  		_idxMap.clear();
804  		refreshMap();
805  	}
806  	__int64 newPosition = -1;
807  	std::vector<int>::iterator it = std::find(_idxMap.begin(), _idxMap.end(), currrentTabIndex);
808  	if (it != _idxMap.end())
809  	{
810  		newPosition = it - _idxMap.begin();
811  	}
812  	nmdlg.type = WDT_ACTIVATE;
813  	nmdlg.curSel = static_cast<UINT>(newPosition);
814  	nmdlg.hwndFrom = _hSelf;
815  	nmdlg.code = WDN_NOTIFY;	
816  	SendMessage(_hParent, WDN_NOTIFY, 0, LPARAM(&nmdlg));
817  }
818  void WindowsDlg::sort(int columnID, bool reverseSort)
819  {
820  	refreshMap();
821  	_currentColumn = columnID;
822  	_reverseSort = reverseSort;
823  	stable_sort(_idxMap.begin(), _idxMap.end(), BufferEquivalent(_pTab, _currentColumn, _reverseSort));
824  }
825  void WindowsDlg::sortFileNameASC()
826  {
827  	sort(0, false);
828  }
829  void WindowsDlg::sortFileNameDSC()
830  {
831  	sort(0, true);
832  }
833  void WindowsDlg::sortFilePathASC()
834  {
835  	sort(1, false);
836  }
837  void WindowsDlg::sortFilePathDSC()
838  {
839  	sort(1, true);
840  }
841  void WindowsDlg::sortFileTypeASC()
842  {
843  	sort(2, false);
844  }
845  void WindowsDlg::sortFileTypeDSC()
846  {
847  	sort(2, true);
848  }
849  void WindowsDlg::sortFileSizeASC()
850  {
851  	sort(3, false);
852  }
853  void WindowsDlg::sortFileSizeDSC()
854  {
855  	sort(3, true);
856  }
857  void WindowsDlg::refreshMap()
858  {
859  	size_t count = (_pTab != NULL) ? _pTab->nbItem() : 0;
860  	size_t oldSize = _idxMap.size();
861  	if (count == oldSize)
862  		return;
863  	if (count != oldSize)
864  	{
865  		size_t lo = 0;
866  		_idxMap.resize(count);
867  		if (oldSize < count)
868  			lo = oldSize;
869  		for (size_t i = lo; i < count; ++i)
870  			_idxMap[i] = int(i);
871  	}
872  }
873  void WindowsDlg::doSortToTabs()
874  {
875  	int curSel = ListView_GetNextItem(_hList, -1, LVNI_SELECTED);
876  	if (curSel == -1)
877  		curSel = 0;
878  	NMWINDLG nmdlg{};
879  	nmdlg.type = WDT_SORT;
880  	nmdlg.hwndFrom = _hSelf;
881  	nmdlg.curSel = _idxMap[curSel];
882  	nmdlg.code = WDN_NOTIFY;
883  	nmdlg.nItems = ListView_GetItemCount(_hList);
884  	nmdlg.Items = new UINT[nmdlg.nItems];
885  	int i = -1;
886  	for (UINT j = 0; j < nmdlg.nItems; ++j)
887  	{
888  		i = ListView_GetNextItem(_hList, i, LVNI_ALL);
889  		if (i == -1)
890  			break;
891  		nmdlg.Items[j] = _idxMap[i];
892  		if (i == curSel)
893  			nmdlg.curSel = j;
894  	}
895  	SendMessage(_hParent, WDN_NOTIFY, 0, LPARAM(&nmdlg));
896  	if (nmdlg.processed)
897  	{
898  		_idxMap.clear();
899  		doRefresh(true);
900  	}
901  	delete[] nmdlg.Items;
902  }
903  void WindowsDlg::putItemsToClipboard(bool isFullPath)
904  {
905  	std::vector<Buffer*> buffers;
906  	int i = -1;
907  	do
908  	{
909  		i = ListView_GetNextItem(_hList, i, LVNI_SELECTED);
910  		buffers.push_back(getBuffer(i));
911  	}
912  	while (i >= 0);
913  	buf2Clipborad(buffers, isFullPath, _hList);
914  }
915  Buffer* WindowsDlg::getBuffer(int index) const
916  {
917  	if (index < 0 || index >= static_cast<int>(_idxMap.size()))
918  		return nullptr;
919  	index = _idxMap[index];
920  	if (index < 0 || !_pTab || index >= static_cast<int>(_pTab->nbItem()))
921  		return nullptr;
922  	BufferID bufID = _pTab->getBufferByIndex(index);
923  	return MainFileManager.getBufferByID(bufID);
924  }
925  void WindowsMenu::init(HMENU hMainMenu)
926  {
927  	_hMenu = ::GetSubMenu(hMainMenu, MENUINDEX_WINDOW);
928  	_hMenuList = ::GetSubMenu(hMainMenu, MENUINDEX_LIST);
929  }
930  void WindowsMenu::initPopupMenu(HMENU hMenu, DocTabView* pTab)
931  {
932  	bool isDropListMenu = false;
933  	UINT firstId = 0;
934  	UINT limitId = 0;
935  	UINT menuPosId = 0;
936  	if (hMenu == _hMenu)
937  	{
938  		firstId = IDM_WINDOW_MRU_FIRST;
939  		limitId = IDM_WINDOW_MRU_LIMIT;
940  		menuPosId = IDM_WINDOW_WINDOWS;
941  	}
942  	else if (hMenu == _hMenuList)
943  	{
944  		isDropListMenu = true;
945  		if (_limitPrev < pTab->nbItem())
946  		{
947  			_limitPrev = static_cast<UINT>(pTab->nbItem());
948  		}
949  		firstId = IDM_DROPLIST_MRU_FIRST;
950  		limitId = IDM_DROPLIST_MRU_FIRST + _limitPrev - 1;
951  		menuPosId = IDM_DROPLIST_LIST;
952  	}
953  	if (firstId > 0 && limitId > 0 && menuPosId > 0)
954  	{
955  		auto curDoc = pTab->getCurrentTabIndex();
956  		size_t nMaxDoc = static_cast<size_t>(limitId) - firstId + 1;
957  		size_t nDoc = pTab->nbItem();
958  		nDoc = std::min<size_t>(nDoc, nMaxDoc);
959  		UINT id = firstId;
960  		UINT guard = firstId + static_cast<int32_t>(nDoc);
961  		size_t pos = 0;
962  		for (; id < guard; ++id, ++pos)
963  		{
964  			BufferID bufID = pTab->getBufferByIndex(pos);
965  			Buffer* buf = MainFileManager.getBufferByID(bufID);
966  			MENUITEMINFO mii{};
967  			mii.cbSize = sizeof(mii);
968  			mii.fMask = MIIM_STRING | MIIM_STATE | MIIM_ID;
969  			generic_string strBuffer(BuildMenuFileName(60, static_cast<int32_t>(pos), buf->getFileName(), !isDropListMenu));
970  			std::vector<TCHAR> vBuffer(strBuffer.begin(), strBuffer.end());
971  			vBuffer.push_back('\0');
972  			mii.dwTypeData = (&vBuffer[0]);
973  			mii.fState &= ~(MF_GRAYED | MF_DISABLED | MF_CHECKED);
974  			if (static_cast<int32_t>(pos) == curDoc)
975  			{
976  				mii.fState |= MF_CHECKED;
977  			}
978  			mii.wID = id;
979  			UINT state = GetMenuState(hMenu, id, MF_BYCOMMAND);
980  			if (state == static_cast<UINT>(-1))
981  			{
982  				InsertMenuItem(hMenu, menuPosId, TRUE, &mii);
983  				if (isDropListMenu)
984  				{
985  					DeleteMenu(hMenu, menuPosId, FALSE);
986  				}
987  			}
988  			else
989  			{
990  				SetMenuItemInfo(hMenu, id, FALSE, &mii);
991  			}
992  		}
993  		for (; id <= limitId; ++id)
994  		{
995  			DeleteMenu(hMenu, id, FALSE);
996  		}
997  		if (isDropListMenu)
998  		{
999  			_limitPrev = static_cast<UINT>(pTab->nbItem());
1000  		}
1001  	}
1002  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-mkl_pooling_layer.cpp</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-WindowsDlg.cpp</div>
                <div class="column column_space"><pre><code>51      if (pool_param.has_kernel_size()) {
52        kernel_h_ = kernel_w_ = pool_param.kernel_size();
53      } else {
54        kernel_h_ = pool_param.kernel_h();
55        kernel_w_ = pool_param.kernel_w();
56      }
57    }
</pre></code></div>
                <div class="column column_space"><pre><code>343  						if (_lastSort == _currentColumn)
344  						{
345  							_reverseSort = true;
346  							_lastSort = -1;
347  						}
348  						else
349  						{
350  							_reverseSort = false;
351  							_lastSort = _currentColumn;
352  						}
353  						updateColumnNames();
354  						doColumnSort();
355  					}
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    