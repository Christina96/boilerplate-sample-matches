
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 24, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-TestLexers.cxx</h3>
            <pre><code>1  #include <cassert>
2  #include <string>
3  #include <string_view>
4  #include <vector>
5  #include <map>
6  #include <optional>
7  #include <algorithm>
8  #include <iostream>
9  #include <sstream>
10  #include <fstream>
11  #include <iomanip>
12  #include <filesystem>
13  #include "ILexer.h"
14  #include "Lexilla.h"
15  #include "LexillaAccess.h"
16  #include "TestDocument.h"
17  namespace {
18  constexpr char MakeLowerCase(char c) noexcept {
19  	if (c >= 'A' && c <= 'Z') {
20  		return c - 'A' + 'a';
21  	} else {
22  		return c;
23  	}
24  }
25  [[maybe_unused]] void LowerCaseAZ(std::string &s) {
26  	std::transform(s.begin(), s.end(), s.begin(), MakeLowerCase);
27  }
28  int IntFromString(std::u32string_view s) noexcept {
29  	if (s.empty()) {
30  		return 0;
31  	}
32  	const bool negate = s.front() == '-';
33  	if (negate) {
34  		s.remove_prefix(1);
35  	}
36  	int value = 0;
37  	while (!s.empty()) {
38  		value = value * 10 + s.front() - '0';
39  		s.remove_prefix(1);
40  	}
41  	return negate ? -value : value;
42  }
43  bool PatternMatch(std::u32string_view pattern, std::u32string_view text) noexcept {
44  	if (pattern == text) {
45  		return true;
46  	} else if (pattern.empty()) {
47  		return false;
48  	} else if (pattern.front() == '\\') {
49  		pattern.remove_prefix(1);
50  		if (pattern.empty()) {
51  			return false;
52  		}
53  		if (text.empty()) {
54  			return false;
55  		}
56  		if (pattern.front() == text.front()) {
57  			pattern.remove_prefix(1);
58  			text.remove_prefix(1);
59  			return PatternMatch(pattern, text);
60  		}
61  		return false;
62  	} else if (pattern.front() == '*') {
63  		pattern.remove_prefix(1);
64  		if (!pattern.empty() && pattern.front() == '*') {
65  			pattern.remove_prefix(1);
66  			while (!text.empty()) {
67  				if (PatternMatch(pattern, text)) {
68  					return true;
69  				}
70  				text.remove_prefix(1);
71  			}
72  		} else {
73  			while (!text.empty()) {
74  				if (PatternMatch(pattern, text)) {
75  					return true;
76  				}
77  				if (text.front() == '/') {
78  					return false;
79  				}
80  				text.remove_prefix(1);
81  			}
82  		}
83  		assert(text.empty());
84  		return pattern.empty();
85  	} else if (text.empty()) {
86  		return false;
87  	} else if (pattern.front() == '?') {
88  		if (text.front() == '/') {
89  			return false;
90  		}
91  		pattern.remove_prefix(1);
92  		text.remove_prefix(1);
93  		return PatternMatch(pattern, text);
94  	} else if (pattern.front() == '[') {
95  		pattern.remove_prefix(1);
96  		if (pattern.empty()) {
97  			return false;
98  		}
99  		const bool positive = pattern.front() != '!';
100  		if (!positive) {
101  			pattern.remove_prefix(1);
102  			if (pattern.empty()) {
103  				return false;
104  			}
105  		}
106  		bool inSet = false;
107  		if (!pattern.empty() && pattern.front() == ']') {
108  			if (pattern.front() == text.front()) {
109  				inSet = true;
110  			}
111  			pattern.remove_prefix(1);
112  		}
113  		char32_t start = 0;
114  		while (!pattern.empty() && pattern.front() != ']') {
115  			if (pattern.front() == '-') {
116  				pattern.remove_prefix(1);
117  				if (!pattern.empty()) {
118  					const char32_t end = pattern.front();
119  					if ((text.front() >= start) && (text.front() <= end)) {
120  						inSet = true;
121  					}
122  				}
123  			} else if (pattern.front() == text.front()) {
124  				inSet = true;
125  			}
126  			if (!pattern.empty()) {
127  				start = pattern.front();
128  				pattern.remove_prefix(1);
129  			}
130  		}
131  		if (!pattern.empty()) {
132  			pattern.remove_prefix(1);
133  		}
134  		if (inSet != positive) {
135  			return false;
136  		}
137  		text.remove_prefix(1);
138  		return PatternMatch(pattern, text);
139  	} else if (pattern.front() == '{') {
140  		if (pattern.length() < 2) {
141  			return false;
142  		}
143  		const size_t endParen = pattern.find('}');
144  		if (endParen == std::u32string_view::npos) {
145  			return false;
146  		}
147  		std::u32string_view parenExpression = pattern.substr(1, endParen - 1);
148  		bool inSet = false;
149  		const size_t dotdot = parenExpression.find(U"..");
150  		if (dotdot != std::u32string_view::npos) {
151  			const std::u32string_view firstRange = parenExpression.substr(0, dotdot);
152  			const std::u32string_view lastRange = parenExpression.substr(dotdot+2);
153  			if (firstRange.empty() || lastRange.empty()) {
154  				return false;
155  			}
156  			const size_t endInteger = text.find_last_of(U"-0123456789");
157  			if (endInteger == std::u32string_view::npos) {
158  				return false;
159  			}
160  			const std::u32string_view intPart = text.substr(0, endInteger+1);
161  			const int first = IntFromString(firstRange);
162  			const int last = IntFromString(lastRange);
163  			const int value = IntFromString(intPart);
164  			if ((value >= first) && (value <= last)) {
165  				inSet = true;
166  				text.remove_prefix(intPart.length());
167  			}
168  		} else {
169  			size_t comma = parenExpression.find(',');
170  			for (;;) {
171  				const bool finalAlt = comma == std::u32string_view::npos;
172  				const std::u32string_view oneAlt = finalAlt ? parenExpression :
173  					parenExpression.substr(0, comma);
174  				if (oneAlt == text.substr(0, oneAlt.length())) {
175  					inSet = true;
176  					text.remove_prefix(oneAlt.length());
177  					break;
178  				}
179  				if (finalAlt) {
180  					break;
181  				}
182  				parenExpression.remove_prefix(oneAlt.length() + 1);
183  				comma = parenExpression.find(',');
184  			}
185  		}
186  		if (!inSet) {
187  			return false;
188  		}
189  		pattern.remove_prefix(endParen + 1);
190  		return PatternMatch(pattern, text);
191  	} else if (pattern.front() == text.front()) {
192  		pattern.remove_prefix(1);
193  		text.remove_prefix(1);
194  		return PatternMatch(pattern, text);
195  	}
196  	return false;
197  }
198  bool PathMatch(std::string pattern, std::string relPath) {
199  #if defined(_WIN32)
200  	std::replace(relPath.begin(), relPath.end(), '\\', '/');
201  #endif
202  #if defined(_WIN32) || defined(__APPLE__)
203  	LowerCaseAZ(pattern);
204  	LowerCaseAZ(relPath);
205  #endif
206  	const std::u32string patternU32 = UTF32FromUTF8(pattern);
207  	const std::u32string relPathU32 = UTF32FromUTF8(relPath);
208  	if (PatternMatch(patternU32, relPathU32)) {
209  		return true;
210  	}
211  	const size_t lastSlash = relPathU32.rfind('/');
212  	if (lastSlash == std::string::npos) {
213  		return false;
214  	}
215  	const std::u32string fileNameU32 = relPathU32.substr(lastSlash+1);
216  	return PatternMatch(patternU32, fileNameU32);
217  }
218  constexpr std::string_view suffixStyled = ".styled";
219  constexpr std::string_view suffixFolded = ".folded";
220  constexpr std::string_view lexerPrefix = "lexer.*";
221  constexpr std::string_view prefixIf = "if ";
222  constexpr std::string_view prefixMatch = "match ";
223  constexpr std::string_view prefixEqual = "= ";
224  constexpr std::string_view prefixComment = "#";
225  std::string ReadFile(std::filesystem::path path) {
226  	std::ifstream ifs(path, std::ios::binary);
227  	std::string content((std::istreambuf_iterator<char>(ifs)),
228  		(std::istreambuf_iterator<char>()));
229  	return content;
230  }
231  std::string MarkedDocument(const Scintilla::IDocument *pdoc) {
232  	assert(pdoc);
233  	std::ostringstream os(std::ios::binary);
234  	char prevStyle = -1;
235  	for (Sci_Position pos = 0; pos < pdoc->Length(); pos++) {
236  		const char styleNow = pdoc->StyleAt(pos);
237  		if (styleNow != prevStyle) {
238  			const unsigned char uStyleNow = styleNow;
239  			const unsigned int uiStyleNow = uStyleNow;
240  			os << "{" << uiStyleNow << "}";
241  			prevStyle = styleNow;
242  		}
243  		char ch = '\0';
244  		pdoc->GetCharRange(&ch, pos, 1);
245  		os << ch;
246  	}
247  	return os.str();
248  }
249  void PrintLevel(std::ostringstream &os, int level) {
250  	const int levelNow = level & 0xFFF;
251  	const int levelNext = level >> 16;
252  	const int levelFlags = (level >> 12) & 0xF;
253  	char foldSymbol = ' ';
254  	if (level & 0x2000)
255  		foldSymbol = '+';
256  	else if (levelNow > 0x400)
257  		foldSymbol = '|';
258  	os << std::hex << " " << levelFlags << " "
259  		<< std::setw(3) << levelNow << " "
260  		<< std::setw(3) << levelNext << " "
261  		<< foldSymbol << " ";
262  }
263  std::string FoldedDocument(const Scintilla::IDocument *pdoc) {
264  	assert(pdoc);
265  	std::ostringstream os(std::ios::binary);
266  	Sci_Position linePrev = -1;
267  	char ch = '\0';
268  	for (Sci_Position pos = 0; pos < pdoc->Length(); pos++) {
269  		const Sci_Position lineNow = pdoc->LineFromPosition(pos);
270  		if (linePrev < lineNow) {
271  			PrintLevel(os, pdoc->GetLevel(lineNow));
272  			linePrev = lineNow;
273  		}
274  		pdoc->GetCharRange(&ch, pos, 1);
275  		os << ch;
276  	}
277  	if (ch == '\n') {
278  		PrintLevel(os, pdoc->GetLevel(linePrev + 1));
279  	}
280  	return os.str();
281  }
282  std::pair<std::string, std::string> MarkedAndFoldedDocument(const Scintilla::IDocument *pdoc) {
283  	return { MarkedDocument(pdoc), FoldedDocument(pdoc) };
284  }
285  std::vector<std::string> StringSplit(const std::string_view &text, int separator) {
286  	std::vector<std::string> vs(text.empty() ? 0 : 1);
287  	for (std::string_view::const_iterator it = text.begin(); it != text.end(); ++it) {
288  		if (*it == separator) {
289  			vs.push_back(std::string());
290  		} else {
291  			vs.back() += *it;
292  		}
293  	}
294  	return vs;
295  }
296  constexpr bool IsSpaceOrTab(char ch) noexcept {
297  	return (ch == ' ') || (ch == '\t');
298  }
299  void PrintRanges(const std::vector<bool> &v) {
300  	std::cout << "    ";
301  	std::optional<size_t> startRange;
302  	for (size_t style = 0; style <= v.size(); style++) {
303  		if ((style < v.size()) && v.at(style)) {
304  			if (!startRange) {
305  				startRange = style;
306  			}
307  		} else if (startRange) {
308  			const size_t endRange = style - 1;
309  			std::cout << *startRange;
310  			if (*startRange != endRange) {
311  				std::cout << "-" << endRange;
312  			}
313  			std::cout << " ";
314  			startRange.reset();
315  		}
316  	}
317  	std::cout << "\n";
318  }
319  class PropertyMap {
320  	std::string Evaluate(std::string_view text) {
321  		if (text.find(' ') != std::string_view::npos) {
322  			if (text.starts_with(prefixEqual)) {
323  				const std::string_view sExpressions = text.substr(prefixEqual.length());
324  				std::vector<std::string> parts = StringSplit(sExpressions, ';');
325  				if (parts.size() > 1) {
326  					for (size_t part = 1; part < parts.size(); part++) {
327  						if (parts.at(part) != parts.at(0)) {
328  							return "0";
329  						}
330  					}
331  					return "1";
332  				}
333  			}
334  			return {};
335  		} else {
336  			std::optional<std::string> value = GetProperty(text);
337  			if (value) {
338  				return *value;
339  			}
340  			return {};
341  		}
342  	}
343  	std::string Expand(std::string withVars) {
344  		constexpr size_t maxVars = 100;
345  		size_t varStart = withVars.rfind("$(");
346  		for (size_t count = 0; (count < maxVars) && (varStart != std::string::npos); count++) {
347  			const size_t varEnd = withVars.find(')', varStart + 2);
348  			if (varEnd == std::string::npos) {
349  				break;
350  			}
351  			const std::string_view whole = withVars;
352  			const std::string_view var = whole.substr(varStart + 2, varEnd - (varStart + 2));
353  			const std::string val = Evaluate(var);
354  			withVars.erase(varStart, varEnd - varStart + 1);
355  			withVars.insert(varStart, val);
356  			varStart = withVars.rfind("$(");
357  		}
358  		return withVars;
359  	}
360  	std::vector<std::string> GetFilePatterns(const std::string &key) const {
361  		std::vector<std::string> exts;
362  		const size_t patternStart = key.find('*');
363  		if (patternStart == std::string::npos)
364  			return exts;
365  		const std::string patterns = key.substr(patternStart);
366  		for (const std::string &pat : StringSplit(patterns, ';')) {
367  			if (pat.starts_with("*.") && pat.length() > 2) {
368  				exts.push_back(pat.substr(1));
369  			} else {
370  				std::cout << "\n"
371  					  << "Ignoring bad file pattern '" << pat << "' in list " << patterns << "\n";
372  			}
373  		}
374  		return exts;
375  	}
376  	bool ProcessLine(std::string_view text, bool ifIsTrue) {
377  		if (!ifIsTrue && (text.empty() || IsSpaceOrTab(text.at(0)))) {
378  			return false;
379  		}
380  		ifIsTrue = true;
381  		if (text.starts_with(prefixIf)) {
382  			const std::string value = Expand(std::string(text.substr(prefixIf.length())));
383  			if (value == "0" || value == "") {
384  				ifIsTrue = false;
385  			}
386  		} else if (text.starts_with(prefixMatch)) {
387  			std::optional<std::string> fileNameExt = GetProperty("FileNameExt");
388  			if (fileNameExt) {
389  				std::string pattern(text.substr(prefixMatch.length()));
390  				while (!pattern.empty() && IsSpaceOrTab(pattern.back())) {
391  					pattern.pop_back();
392  				}
393  				ifIsTrue = PathMatch(pattern, *fileNameExt);
394  			} else {
395  				ifIsTrue = false;
396  			}
397  		} else {
398  			while (!text.empty() && IsSpaceOrTab(text.at(0))) {
399  				text.remove_prefix(1);
400  			}
401  			if (text.starts_with(prefixComment)) {
402  				return ifIsTrue;
403  			}
404  			const size_t positionEquals = text.find("=");
405  			if (positionEquals != std::string::npos) {
406  				const std::string key(text.substr(0, positionEquals));
407  				const std::string_view value = text.substr(positionEquals + 1);
408  				properties[key] = value;
409  			}
410  		}
411  		return ifIsTrue;
412  	}
413  public:
414  	using PropMap = std::map<std::string, std::string>;
415  	PropMap properties;
416  	void ReadFromFile(std::filesystem::path path) {
417  		bool ifIsTrue = true;
418  		std::ifstream ifs(path);
419  		std::string line;
420  		std::string logicalLine;
421  		while (std::getline(ifs, line)) {
422  			if (line.ends_with("\r")) {
423  				line.pop_back();
424  			}
425  			logicalLine += line;
426  			if (logicalLine.ends_with("\\")) {
427  				logicalLine.pop_back();
428  			} else {
429  				ifIsTrue = ProcessLine(logicalLine, ifIsTrue);
430  				logicalLine.clear();
431  			}
432  		}
433  	}
434  	std::optional<std::string> GetProperty(std::string_view key) const {
435  		const PropMap::const_iterator prop = properties.find(std::string(key));
436  		if (prop == properties.end())
437  			return std::nullopt;
438  		else
439  			return prop->second;
440  	}
441  	std::optional<std::string> GetPropertyForFile(std::string_view keyPrefix, std::string_view fileName) const {
442  		for (auto const &[key, val] : properties) {
443  			if (key.starts_with(keyPrefix)) {
444  				const std::string keySuffix = key.substr(keyPrefix.length());
445  				if (fileName.ends_with(keySuffix)) {
446  					return val;
447  				} else if (key.find(';') != std::string::npos) {
448  					for (const std::string &ext : GetFilePatterns(key)) {
449  						if (fileName.ends_with(ext)) {
450  							return val;
451  						}
452  					}
453  				}
454  			}
455  		}
456  		return std::nullopt;
457  	}
458  	std::optional<int> GetPropertyValue(std::string_view key) const {
459  		std::optional<std::string> value = GetProperty(key);
460  		try {
461  			if (value)
462  				return std::stoi(value->c_str());
463  		}
464  		catch (std::invalid_argument &) {
465  		}
466  		return {};
467  	}
468  };
469  size_t FirstLineDifferent(std::string_view a, std::string_view b) {
470  	size_t i = 0;
471  	while (i < std::min(a.size(), b.size()) && a.at(i) == b.at(i)) {
472  		i++;
473  	}
474  	return std::count(a.begin(), a.begin() + i, '\n');
475  }
476  bool CheckSame(std::string_view augmentedText, std::string_view augmentedTextNew, std::string_view item, std::string_view suffix, const std::filesystem::path &path) {
477  	if (augmentedTextNew == augmentedText) {
478  		return true;
479  	}
480  	const size_t lineNumber = FirstLineDifferent(augmentedText, augmentedTextNew) + 1;
481  	std::cout << "\n" << path.string() << ":" << lineNumber << ":";
482  	const std::string differenceType = augmentedText.empty() ? "new" : "different";
483  	std::cout << " has " << differenceType << " " << item << "\n\n";
484  	std::filesystem::path pathNew = path;
485  	pathNew += suffix;
486  	pathNew += ".new";
487  	std::ofstream ofs(pathNew, std::ios::binary);
488  	ofs << augmentedTextNew;
489  	return false;
490  }
491  int Substitute(std::string &s, const std::string &sFind, const std::string &sReplace) {
492  	int c = 0;
493  	const size_t lenFind = sFind.size();
494  	const size_t lenReplace = sReplace.size();
495  	size_t posFound = s.find(sFind);
496  	while (posFound != std::string::npos) {
497  		s.replace(posFound, lenFind, sReplace);
498  		posFound = s.find(sFind, posFound + lenReplace);
499  		c++;
500  	}
501  	return c;
502  }
503  int WindowsToUnix(std::string &s) {
504  	return Substitute(s, "\r\n", "\n");
505  }
506  int UnixToWindows(std::string &s) {
507  	return Substitute(s, "\n", "\r\n");
508  }
509  const std::string BOM = "\xEF\xBB\xBF";
510  void StyleLineByLine(TestDocument &doc, Scintilla::ILexer5 *plex) {
511  	assert(plex);
512  	Scintilla::IDocument *pdoc = &doc;
513  	const Sci_Position lines = doc.LineFromPosition(doc.Length());
514  	Sci_Position startLine = 0;
515  	for (Sci_Position line = 0; line <= lines; line++) {
516  		const Sci_Position endLine = doc.LineStart(line + 1);
517  		int styleStart = 0;
518  		if (startLine > 0)
519  			styleStart = doc.StyleAt(startLine - 1);
520  		plex->Lex(startLine, endLine - startLine, styleStart, pdoc);
521  		plex->Fold(startLine, endLine - startLine, styleStart, pdoc);
522  		startLine = endLine;
523  	}
524  }
525  bool TestCRLF(std::filesystem::path path, const std::string s, Scintilla::ILexer5 *plex, bool disablePerLineTests) {
526  	assert(plex);
527  	bool success = true;
528  	std::string text = s;
529  	WindowsToUnix(text);
530  	const bool originalIsUnix = text == s;
531  	std::string textUnix = text;
532  	UnixToWindows(text);
533  	TestDocument doc;
534  	doc.Set(text);
535  	Scintilla::IDocument *pdoc = &doc;
536  	assert(pdoc);
537  	plex->Lex(0, pdoc->Length(), 0, pdoc);
538  	plex->Fold(0, pdoc->Length(), 0, pdoc);
539  	const auto [styledText, foldedText] = MarkedAndFoldedDocument(pdoc);
540  	int prevStyle = -1;
541  	Sci_Position line = 1;
542  	for (Sci_Position pos = 0; pos < pdoc->Length(); pos++) {
543  		const int styleNow = pdoc->StyleAt(pos);
544  		char ch = '\0';
545  		pdoc->GetCharRange(&ch, pos, 1);
546  		if (ch == '\n') {
547  			if (styleNow != prevStyle) {
548  				std::cout << path.string() << ":" << line << ":" <<
549  					" different styles between \\r and \\n at " <<
550  					pos << ": " << prevStyle << ", " << styleNow << "\n";
551  				success = false;
552  			}
553  			line++;
554  		}
555  		prevStyle = styleNow;
556  	}
557  	TestDocument docUnix;
558  	docUnix.Set(textUnix);
559  	Scintilla::IDocument *pdocUnix = &docUnix;
560  	assert(pdocUnix);
561  	plex->Lex(0, pdocUnix->Length(), 0, pdocUnix);
562  	plex->Fold(0, pdocUnix->Length(), 0, pdocUnix);
563  	auto [styledTextUnix, foldedTextUnix] = MarkedAndFoldedDocument(pdocUnix);
564  	UnixToWindows(styledTextUnix);
565  	UnixToWindows(foldedTextUnix);
566  	if (styledText != styledTextUnix) {
567  		std::cout << "\n" << path.string() << ":1: has different styles with \\n versus \\r\\n line ends\n\n";
568  		success = false;
569  	}
570  	if (foldedText != foldedTextUnix) {
571  		std::cout << "\n" << path.string() << ":1: has different folds with \\n versus \\r\\n line ends\n\n";
572  		success = false;
573  	}
574  	if (!disablePerLineTests && !originalIsUnix) {
575  		StyleLineByLine(docUnix, plex);
576  		auto [styledTextNewPerLine, foldedTextNewPerLine] = MarkedAndFoldedDocument(pdocUnix);
577  		UnixToWindows(styledTextNewPerLine);
578  		UnixToWindows(foldedTextNewPerLine);
579  		if (!CheckSame(styledTextUnix, styledTextNewPerLine, "per-line styles \\n", suffixStyled, path)) {
580  			success = false;
581  		}
582  		if (!CheckSame(foldedTextUnix, foldedTextNewPerLine, "per-line folds \\n", suffixFolded, path)) {
583  			success = false;
584  		}
585  	}
586  	plex->Release();
587  	return success;
588  }
589  void TestILexer(Scintilla::ILexer5 *plex) {
590  	assert(plex);
591  	[[maybe_unused]] const int version = plex->Version();
592  	assert(version == Scintilla::lvRelease5);
593  	[[maybe_unused]] const char *language = plex->GetName();
594  	assert(language);
595  	[[maybe_unused]] const int ident = plex->GetIdentifier();
596  	assert(ident >= 0);
597  	[[maybe_unused]] const char *propertyNames = plex->PropertyNames();
598  	assert(propertyNames);
599  	[[maybe_unused]] const int propertyType = plex->PropertyType("unknown");
600  	assert(propertyType >= 0 && propertyType <= 2);
601  	[[maybe_unused]] const char *propertyDescription = plex->DescribeProperty("unknown");
602  	assert(propertyDescription);
603  	[[maybe_unused]] const Sci_Position invalidation = plex->PropertySet("unknown", "unknown");
604  	assert(invalidation == 0 || invalidation == -1);
605  	[[maybe_unused]] const char *wordListDescription = plex->DescribeWordListSets();
606  	assert(wordListDescription);
607  	[[maybe_unused]] const Sci_Position invalidationWordList = plex->WordListSet(9, "unknown");
608  	assert(invalidationWordList == 0 || invalidationWordList == -1);
609  	[[maybe_unused]] const int lineEndTypes = plex->LineEndTypesSupported();
610  	assert(lineEndTypes == 0 || lineEndTypes == 1);
611  	if (std::string_view bases = plex->GetSubStyleBases(); !bases.empty()) {
612  		while (!bases.empty()) {
613  			constexpr int newStyles = 3;
614  			const int base = bases.front();
615  			const int baseStyle = plex->AllocateSubStyles(base, newStyles);
616  			[[maybe_unused]] const int styleBack = plex->StyleFromSubStyle(baseStyle);
617  			assert(styleBack == base);
618  			plex->SetIdentifiers(baseStyle, "int nullptr");
619  			[[maybe_unused]] const int start = plex->SubStylesStart(base);
620  			assert(start == baseStyle);
621  			[[maybe_unused]] const int len = plex->SubStylesLength(base);
622  			assert(len == newStyles);
623  			bases.remove_prefix(1);
624  		}
625  		plex->FreeSubStyles();
626  	}
627  	[[maybe_unused]] const int primary = plex->PrimaryStyleFromStyle(2);
628  	assert(primary == 2);
629  	[[maybe_unused]] const int distance = plex->DistanceToSecondaryStyles();
630  	assert(distance >= 0);
631  	[[maybe_unused]] const char *propertyUnknownValue = plex->PropertyGet("unknown");
632  	const int styles = plex->NamedStyles();
633  	for (int style = 0; style < styles; style++) {
634  		[[maybe_unused]] const char *name = plex->NameOfStyle(style);
635  		assert(name);
636  		[[maybe_unused]] const char *tags = plex->TagsOfStyle(style);
637  		assert(tags);
638  		[[maybe_unused]] const char *description = plex->DescriptionOfStyle(style);
639  		assert(description);
640  	}
641  }
642  bool SetProperties(Scintilla::ILexer5 *plex, const std::string &language, const PropertyMap &propertyMap, std::filesystem::path path) {
643  	assert(plex);
644  	const std::string fileName = path.filename().string();
645  	if (std::string_view bases = plex->GetSubStyleBases(); !bases.empty()) {
646  		while (!bases.empty()) {
647  			const int baseStyle = bases.front();
648  			const std::string base = std::to_string(baseStyle);
649  			const std::string substylesForBase = "substyles." + language + "." + base;
650  			std::optional<std::string> substylesN = propertyMap.GetProperty(substylesForBase);
651  			if (substylesN) {
652  				const int substyles = atoi(substylesN->c_str());
653  				const int baseStyleNum = plex->AllocateSubStyles(baseStyle, substyles);
654  				for (int kw = 0; kw < substyles; kw++) {
655  					const std::string substyleWords = "substylewords." + base + "." + std::to_string(kw + 1) + ".*";
656  					const std::optional<std::string> keywordN = propertyMap.GetPropertyForFile(substyleWords, fileName);
657  					if (keywordN) {
658  						plex->SetIdentifiers(baseStyleNum + kw, keywordN->c_str());
659  					}
660  				}
661  			}
662  			bases.remove_prefix(1);
663  		}
664  	}
665  	for (int kw = 0; kw < 10; kw++) {
666  		std::string kwChoice("keywords");
667  		if (kw > 0) {
668  			kwChoice.push_back(static_cast<char>('1' + kw));
669  		}
670  		kwChoice.append(".*");
671  		std::optional<std::string> keywordN = propertyMap.GetPropertyForFile(kwChoice, fileName);
672  		if (keywordN) {
673  			const Sci_Position changedEmpty = plex->WordListSet(kw, "");
674  			if (changedEmpty != -1) {
675  				std::cout << path.string() << ":1: does not return -1 for null WordListSet(" << kw << ")\n";
676  				return false;
677  			}
678  			const Sci_Position changedAt = plex->WordListSet(kw, keywordN->c_str());
679  			if (keywordN->empty()) {
680  				if (changedAt != -1) {
681  					std::cout << path.string() << ":1: does not return -1 for WordListSet(" << kw << ") to same empty" << "\n";
682  					return false;
683  				}
684  			} else {
685  				if (changedAt == -1) {
686  					std::cout << path.string() << ":1: returns -1 for WordListSet(" << kw << ")\n";
687  					return false;
688  				}
689  			}
690  		}
691  	}
692  	for (auto const &[key, val] : propertyMap.properties) {
693  		if (key.starts_with("lexer.*")) {
694  		} else if (key.starts_with("keywords")) {
695  		} else if (key.starts_with("substyle")) {
696  		} else {
697  			plex->PropertySet(key.c_str(), val.c_str());
698  		}
699  	}
700  	return true;
701  }
702  bool TestFile(const std::filesystem::path &path, const PropertyMap &propertyMap) {
703  	std::optional<std::string> language = propertyMap.GetPropertyForFile(lexerPrefix, path.filename().string());
704  	if (!language) {
705  		std::cout << "\n" << path.string() << ":1: has no language\n\n";
706  		return false;
707  	}
708  	Scintilla::ILexer5 *plex = Lexilla::MakeLexer(*language);
709  	if (!plex) {
710  		std::cout << "\n" << path.string() << ":1: has no lexer for " << *language << "\n\n";
711  		return false;
712  	}
713  	TestILexer(plex);
714  	if (!SetProperties(plex, *language, propertyMap, path)) {
715  		return false;
716  	}
717  	std::string text = ReadFile(path);
718  	if (text.starts_with(BOM)) {
719  		text.erase(0, BOM.length());
720  	}
<span onclick='openModal()' class='match'>721  	std::filesystem::path pathStyled = path;
722  	pathStyled += suffixStyled;
723  	const std::string styledText = ReadFile(pathStyled);
724  	std::filesystem::path pathFolded = path;
</span>725  	pathFolded += suffixFolded;
726  	const std::string foldedText = ReadFile(pathFolded);
727  	const int repeatLex = propertyMap.GetPropertyValue("testlexers.repeat.lex").value_or(1);
728  	const int repeatFold = propertyMap.GetPropertyValue("testlexers.repeat.fold").value_or(1);
729  	TestDocument doc;
730  	doc.Set(text);
731  	Scintilla::IDocument *pdoc = &doc;
732  	assert(pdoc);
733  	for (int i = 0; i < repeatLex; i++) {
734  		plex->Lex(0, pdoc->Length(), 0, pdoc);
735  	}
736  	for (int i = 0; i < repeatFold; i++) {
737  		plex->Fold(0, pdoc->Length(), 0, pdoc);
738  	}
739  	bool success = true;
740  	const auto [styledTextNew, foldedTextNew] = MarkedAndFoldedDocument(pdoc);
741  	if (!CheckSame(styledText, styledTextNew, "styles", suffixStyled, path)) {
742  		success = false;
743  	}
744  	if (!CheckSame(foldedText, foldedTextNew, "folds", suffixFolded, path)) {
745  		success = false;
746  	}
747  	if (propertyMap.GetPropertyValue("testlexers.list.styles").value_or(0)) {
748  		std::vector<bool> used(0x100);
749  		for (Sci_Position pos = 0; pos < pdoc->Length(); pos++) {
750  			const unsigned char uchStyle = pdoc->StyleAt(pos);
751  			const unsigned style = uchStyle;
752  			used.at(style) = true;
753  		}
754  		PrintRanges(used);
755  	}
756  	const std::optional<int> perLineDisable = propertyMap.GetPropertyValue("testlexers.per.line.disable");
757  	const bool disablePerLineTests = perLineDisable.value_or(false);
758  	if (success && !disablePerLineTests) {
759  		doc.Set(text);
760  		StyleLineByLine(doc, plex);
761  		const auto [styledTextNewPerLine, foldedTextNewPerLine] = MarkedAndFoldedDocument(pdoc);
762  		success = success && CheckSame(styledText, styledTextNewPerLine, "per-line styles", suffixStyled, path);
763  		success = success && CheckSame(foldedText, foldedTextNewPerLine, "per-line folds", suffixFolded, path);
764  	}
765  	plex->Release();
766  	if (success) {
767  		Scintilla::ILexer5 *plexCRLF = Lexilla::MakeLexer(*language);
768  		SetProperties(plexCRLF, *language, propertyMap, path.filename().string());
769  		success = TestCRLF(path, text, plexCRLF, disablePerLineTests);
770  	}
771  	return success;
772  }
773  bool TestDirectory(std::filesystem::path directory, std::filesystem::path basePath) {
774  	bool success = true;
775  	for (auto &p : std::filesystem::directory_iterator(directory)) {
776  		if (!p.is_directory()) {
777  			const std::string extension = p.path().extension().string();
778  			if (extension != ".properties" && extension != suffixStyled && extension != ".new" &&
779  				extension != suffixFolded) {
780  				const std::filesystem::path relativePath = p.path().lexically_relative(basePath);
781  				std::cout << "Lexing " << relativePath.string() << '\n';
782  				PropertyMap properties;
783  				properties.properties["FileNameExt"] = p.path().filename().string();
784  				properties.ReadFromFile(directory / "SciTE.properties");
785  				if (!TestFile(p, properties)) {
786  					success = false;
787  				}
788  			}
789  		}
790  	}
791  	return success;
792  }
793  bool AccessLexilla(std::filesystem::path basePath) {
794  	if (!std::filesystem::exists(basePath)) {
795  		std::cout << "No examples at " << basePath.string() << "\n";
796  		return false;
797  	}
798  	bool success = true;
799  	for (auto &p : std::filesystem::recursive_directory_iterator(basePath)) {
800  		if (p.is_directory()) {
801  			if (!TestDirectory(p, basePath)) {
802  				success = false;
803  			}
804  		}
805  	}
806  	return success;
807  }
808  std::filesystem::path FindLexillaDirectory(std::filesystem::path startDirectory) {
809  	std::filesystem::path directory = startDirectory;
810  	while (!directory.empty()) {
811  		const std::filesystem::path parent = directory.parent_path();
812  		const std::filesystem::path localLexilla = directory / "lexilla";
813  		const std::filesystem::directory_entry entry(localLexilla);
814  		if (entry.is_directory()) {
815  			std::cout << "Found Lexilla at " << entry.path().string() << "\n";
816  			return localLexilla;
817  		}
818  		const std::filesystem::path localBin = directory / "bin";
819  		const std::filesystem::directory_entry entryBin(localBin);
820  		if (entryBin.is_directory()) {
821  			std::cout << "Found Lexilla at " << directory.string() << "\n";
822  			return directory;
823  		}
824  		if (parent == directory) {
825  			std::cout << "Reached root at " << directory.string() << "\n";
826  			return std::filesystem::path();
827  		}
828  		directory = parent;
829  	}
830  	return std::filesystem::path();
831  }
832  }
833  int main() {
834  	bool success = false;
835  	const std::filesystem::path baseDirectory = FindLexillaDirectory(std::filesystem::current_path());
836  	if (!baseDirectory.empty()) {
837  		const std::filesystem::path examplesDirectory = baseDirectory / "test" / "examples";
838  #if defined(LEXILLA_STATIC)
839  		success = AccessLexilla(examplesDirectory);
840  #else
841  		const std::filesystem::path sharedLibrary = baseDirectory / "bin" / LEXILLA_LIB;
842  		if (Lexilla::Load(sharedLibrary.string())) {
843  			success = AccessLexilla(examplesDirectory);
844  		} else {
845  			std::cout << "Failed to load " << sharedLibrary << "\n";
846  		}
847  #endif
848  	}
849  	return success ? 0 : 1;
850  }
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-TestLexers.cxx</h3>
            <pre><code>1  #include <cassert>
2  #include <string>
3  #include <string_view>
4  #include <vector>
5  #include <map>
6  #include <optional>
7  #include <algorithm>
8  #include <iostream>
9  #include <sstream>
10  #include <fstream>
11  #include <iomanip>
12  #include <filesystem>
13  #include "ILexer.h"
14  #include "Lexilla.h"
15  #include "LexillaAccess.h"
16  #include "TestDocument.h"
17  namespace {
18  constexpr char MakeLowerCase(char c) noexcept {
19  	if (c >= 'A' && c <= 'Z') {
20  		return c - 'A' + 'a';
21  	} else {
22  		return c;
23  	}
24  }
25  [[maybe_unused]] void LowerCaseAZ(std::string &s) {
26  	std::transform(s.begin(), s.end(), s.begin(), MakeLowerCase);
27  }
28  int IntFromString(std::u32string_view s) noexcept {
29  	if (s.empty()) {
30  		return 0;
31  	}
32  	const bool negate = s.front() == '-';
33  	if (negate) {
34  		s.remove_prefix(1);
35  	}
36  	int value = 0;
37  	while (!s.empty()) {
38  		value = value * 10 + s.front() - '0';
39  		s.remove_prefix(1);
40  	}
41  	return negate ? -value : value;
42  }
43  bool PatternMatch(std::u32string_view pattern, std::u32string_view text) noexcept {
44  	if (pattern == text) {
45  		return true;
46  	} else if (pattern.empty()) {
47  		return false;
48  	} else if (pattern.front() == '\\') {
49  		pattern.remove_prefix(1);
50  		if (pattern.empty()) {
51  			return false;
52  		}
53  		if (text.empty()) {
54  			return false;
55  		}
56  		if (pattern.front() == text.front()) {
57  			pattern.remove_prefix(1);
58  			text.remove_prefix(1);
59  			return PatternMatch(pattern, text);
60  		}
61  		return false;
62  	} else if (pattern.front() == '*') {
63  		pattern.remove_prefix(1);
64  		if (!pattern.empty() && pattern.front() == '*') {
65  			pattern.remove_prefix(1);
66  			while (!text.empty()) {
67  				if (PatternMatch(pattern, text)) {
68  					return true;
69  				}
70  				text.remove_prefix(1);
71  			}
72  		} else {
73  			while (!text.empty()) {
74  				if (PatternMatch(pattern, text)) {
75  					return true;
76  				}
77  				if (text.front() == '/') {
78  					return false;
79  				}
80  				text.remove_prefix(1);
81  			}
82  		}
83  		assert(text.empty());
84  		return pattern.empty();
85  	} else if (text.empty()) {
86  		return false;
87  	} else if (pattern.front() == '?') {
88  		if (text.front() == '/') {
89  			return false;
90  		}
91  		pattern.remove_prefix(1);
92  		text.remove_prefix(1);
93  		return PatternMatch(pattern, text);
94  	} else if (pattern.front() == '[') {
95  		pattern.remove_prefix(1);
96  		if (pattern.empty()) {
97  			return false;
98  		}
99  		const bool positive = pattern.front() != '!';
100  		if (!positive) {
101  			pattern.remove_prefix(1);
102  			if (pattern.empty()) {
103  				return false;
104  			}
105  		}
106  		bool inSet = false;
107  		if (!pattern.empty() && pattern.front() == ']') {
108  			if (pattern.front() == text.front()) {
109  				inSet = true;
110  			}
111  			pattern.remove_prefix(1);
112  		}
113  		char32_t start = 0;
114  		while (!pattern.empty() && pattern.front() != ']') {
115  			if (pattern.front() == '-') {
116  				pattern.remove_prefix(1);
117  				if (!pattern.empty()) {
118  					const char32_t end = pattern.front();
119  					if ((text.front() >= start) && (text.front() <= end)) {
120  						inSet = true;
121  					}
122  				}
123  			} else if (pattern.front() == text.front()) {
124  				inSet = true;
125  			}
126  			if (!pattern.empty()) {
127  				start = pattern.front();
128  				pattern.remove_prefix(1);
129  			}
130  		}
131  		if (!pattern.empty()) {
132  			pattern.remove_prefix(1);
133  		}
134  		if (inSet != positive) {
135  			return false;
136  		}
137  		text.remove_prefix(1);
138  		return PatternMatch(pattern, text);
139  	} else if (pattern.front() == '{') {
140  		if (pattern.length() < 2) {
141  			return false;
142  		}
143  		const size_t endParen = pattern.find('}');
144  		if (endParen == std::u32string_view::npos) {
145  			return false;
146  		}
147  		std::u32string_view parenExpression = pattern.substr(1, endParen - 1);
148  		bool inSet = false;
149  		const size_t dotdot = parenExpression.find(U"..");
150  		if (dotdot != std::u32string_view::npos) {
151  			const std::u32string_view firstRange = parenExpression.substr(0, dotdot);
152  			const std::u32string_view lastRange = parenExpression.substr(dotdot+2);
153  			if (firstRange.empty() || lastRange.empty()) {
154  				return false;
155  			}
156  			const size_t endInteger = text.find_last_of(U"-0123456789");
157  			if (endInteger == std::u32string_view::npos) {
158  				return false;
159  			}
160  			const std::u32string_view intPart = text.substr(0, endInteger+1);
161  			const int first = IntFromString(firstRange);
162  			const int last = IntFromString(lastRange);
163  			const int value = IntFromString(intPart);
164  			if ((value >= first) && (value <= last)) {
165  				inSet = true;
166  				text.remove_prefix(intPart.length());
167  			}
168  		} else {
169  			size_t comma = parenExpression.find(',');
170  			for (;;) {
171  				const bool finalAlt = comma == std::u32string_view::npos;
172  				const std::u32string_view oneAlt = finalAlt ? parenExpression :
173  					parenExpression.substr(0, comma);
174  				if (oneAlt == text.substr(0, oneAlt.length())) {
175  					inSet = true;
176  					text.remove_prefix(oneAlt.length());
177  					break;
178  				}
179  				if (finalAlt) {
180  					break;
181  				}
182  				parenExpression.remove_prefix(oneAlt.length() + 1);
183  				comma = parenExpression.find(',');
184  			}
185  		}
186  		if (!inSet) {
187  			return false;
188  		}
189  		pattern.remove_prefix(endParen + 1);
190  		return PatternMatch(pattern, text);
191  	} else if (pattern.front() == text.front()) {
192  		pattern.remove_prefix(1);
193  		text.remove_prefix(1);
194  		return PatternMatch(pattern, text);
195  	}
196  	return false;
197  }
198  bool PathMatch(std::string pattern, std::string relPath) {
199  #if defined(_WIN32)
200  	std::replace(relPath.begin(), relPath.end(), '\\', '/');
201  #endif
202  #if defined(_WIN32) || defined(__APPLE__)
203  	LowerCaseAZ(pattern);
204  	LowerCaseAZ(relPath);
205  #endif
206  	const std::u32string patternU32 = UTF32FromUTF8(pattern);
207  	const std::u32string relPathU32 = UTF32FromUTF8(relPath);
208  	if (PatternMatch(patternU32, relPathU32)) {
209  		return true;
210  	}
211  	const size_t lastSlash = relPathU32.rfind('/');
212  	if (lastSlash == std::string::npos) {
213  		return false;
214  	}
215  	const std::u32string fileNameU32 = relPathU32.substr(lastSlash+1);
216  	return PatternMatch(patternU32, fileNameU32);
217  }
218  constexpr std::string_view suffixStyled = ".styled";
219  constexpr std::string_view suffixFolded = ".folded";
220  constexpr std::string_view lexerPrefix = "lexer.*";
221  constexpr std::string_view prefixIf = "if ";
222  constexpr std::string_view prefixMatch = "match ";
223  constexpr std::string_view prefixEqual = "= ";
224  constexpr std::string_view prefixComment = "#";
225  std::string ReadFile(std::filesystem::path path) {
226  	std::ifstream ifs(path, std::ios::binary);
227  	std::string content((std::istreambuf_iterator<char>(ifs)),
228  		(std::istreambuf_iterator<char>()));
229  	return content;
230  }
231  std::string MarkedDocument(const Scintilla::IDocument *pdoc) {
232  	assert(pdoc);
233  	std::ostringstream os(std::ios::binary);
234  	char prevStyle = -1;
235  	for (Sci_Position pos = 0; pos < pdoc->Length(); pos++) {
236  		const char styleNow = pdoc->StyleAt(pos);
237  		if (styleNow != prevStyle) {
238  			const unsigned char uStyleNow = styleNow;
239  			const unsigned int uiStyleNow = uStyleNow;
240  			os << "{" << uiStyleNow << "}";
241  			prevStyle = styleNow;
242  		}
243  		char ch = '\0';
244  		pdoc->GetCharRange(&ch, pos, 1);
245  		os << ch;
246  	}
247  	return os.str();
248  }
249  void PrintLevel(std::ostringstream &os, int level) {
250  	const int levelNow = level & 0xFFF;
251  	const int levelNext = level >> 16;
252  	const int levelFlags = (level >> 12) & 0xF;
253  	char foldSymbol = ' ';
254  	if (level & 0x2000)
255  		foldSymbol = '+';
256  	else if (levelNow > 0x400)
257  		foldSymbol = '|';
258  	os << std::hex << " " << levelFlags << " "
259  		<< std::setw(3) << levelNow << " "
260  		<< std::setw(3) << levelNext << " "
261  		<< foldSymbol << " ";
262  }
263  std::string FoldedDocument(const Scintilla::IDocument *pdoc) {
264  	assert(pdoc);
265  	std::ostringstream os(std::ios::binary);
266  	Sci_Position linePrev = -1;
267  	char ch = '\0';
268  	for (Sci_Position pos = 0; pos < pdoc->Length(); pos++) {
269  		const Sci_Position lineNow = pdoc->LineFromPosition(pos);
270  		if (linePrev < lineNow) {
271  			PrintLevel(os, pdoc->GetLevel(lineNow));
272  			linePrev = lineNow;
273  		}
274  		pdoc->GetCharRange(&ch, pos, 1);
275  		os << ch;
276  	}
277  	if (ch == '\n') {
278  		PrintLevel(os, pdoc->GetLevel(linePrev + 1));
279  	}
280  	return os.str();
281  }
282  std::pair<std::string, std::string> MarkedAndFoldedDocument(const Scintilla::IDocument *pdoc) {
283  	return { MarkedDocument(pdoc), FoldedDocument(pdoc) };
284  }
285  std::vector<std::string> StringSplit(const std::string_view &text, int separator) {
286  	std::vector<std::string> vs(text.empty() ? 0 : 1);
287  	for (std::string_view::const_iterator it = text.begin(); it != text.end(); ++it) {
288  		if (*it == separator) {
289  			vs.push_back(std::string());
290  		} else {
291  			vs.back() += *it;
292  		}
293  	}
294  	return vs;
295  }
296  constexpr bool IsSpaceOrTab(char ch) noexcept {
297  	return (ch == ' ') || (ch == '\t');
298  }
299  void PrintRanges(const std::vector<bool> &v) {
300  	std::cout << "    ";
301  	std::optional<size_t> startRange;
302  	for (size_t style = 0; style <= v.size(); style++) {
303  		if ((style < v.size()) && v.at(style)) {
304  			if (!startRange) {
305  				startRange = style;
306  			}
307  		} else if (startRange) {
308  			const size_t endRange = style - 1;
309  			std::cout << *startRange;
310  			if (*startRange != endRange) {
311  				std::cout << "-" << endRange;
312  			}
313  			std::cout << " ";
314  			startRange.reset();
315  		}
316  	}
317  	std::cout << "\n";
318  }
319  class PropertyMap {
320  	std::string Evaluate(std::string_view text) {
321  		if (text.find(' ') != std::string_view::npos) {
322  			if (text.starts_with(prefixEqual)) {
323  				const std::string_view sExpressions = text.substr(prefixEqual.length());
324  				std::vector<std::string> parts = StringSplit(sExpressions, ';');
325  				if (parts.size() > 1) {
326  					for (size_t part = 1; part < parts.size(); part++) {
327  						if (parts.at(part) != parts.at(0)) {
328  							return "0";
329  						}
330  					}
331  					return "1";
332  				}
333  			}
334  			return {};
335  		} else {
336  			std::optional<std::string> value = GetProperty(text);
337  			if (value) {
338  				return *value;
339  			}
340  			return {};
341  		}
342  	}
343  	std::string Expand(std::string withVars) {
344  		constexpr size_t maxVars = 100;
345  		size_t varStart = withVars.rfind("$(");
346  		for (size_t count = 0; (count < maxVars) && (varStart != std::string::npos); count++) {
347  			const size_t varEnd = withVars.find(')', varStart + 2);
348  			if (varEnd == std::string::npos) {
349  				break;
350  			}
351  			const std::string_view whole = withVars;
352  			const std::string_view var = whole.substr(varStart + 2, varEnd - (varStart + 2));
353  			const std::string val = Evaluate(var);
354  			withVars.erase(varStart, varEnd - varStart + 1);
355  			withVars.insert(varStart, val);
356  			varStart = withVars.rfind("$(");
357  		}
358  		return withVars;
359  	}
360  	std::vector<std::string> GetFilePatterns(const std::string &key) const {
361  		std::vector<std::string> exts;
362  		const size_t patternStart = key.find('*');
363  		if (patternStart == std::string::npos)
364  			return exts;
365  		const std::string patterns = key.substr(patternStart);
366  		for (const std::string &pat : StringSplit(patterns, ';')) {
367  			if (pat.starts_with("*.") && pat.length() > 2) {
368  				exts.push_back(pat.substr(1));
369  			} else {
370  				std::cout << "\n"
371  					  << "Ignoring bad file pattern '" << pat << "' in list " << patterns << "\n";
372  			}
373  		}
374  		return exts;
375  	}
376  	bool ProcessLine(std::string_view text, bool ifIsTrue) {
377  		if (!ifIsTrue && (text.empty() || IsSpaceOrTab(text.at(0)))) {
378  			return false;
379  		}
380  		ifIsTrue = true;
381  		if (text.starts_with(prefixIf)) {
382  			const std::string value = Expand(std::string(text.substr(prefixIf.length())));
383  			if (value == "0" || value == "") {
384  				ifIsTrue = false;
385  			}
386  		} else if (text.starts_with(prefixMatch)) {
387  			std::optional<std::string> fileNameExt = GetProperty("FileNameExt");
388  			if (fileNameExt) {
389  				std::string pattern(text.substr(prefixMatch.length()));
390  				while (!pattern.empty() && IsSpaceOrTab(pattern.back())) {
391  					pattern.pop_back();
392  				}
393  				ifIsTrue = PathMatch(pattern, *fileNameExt);
394  			} else {
395  				ifIsTrue = false;
396  			}
397  		} else {
398  			while (!text.empty() && IsSpaceOrTab(text.at(0))) {
399  				text.remove_prefix(1);
400  			}
401  			if (text.starts_with(prefixComment)) {
402  				return ifIsTrue;
403  			}
404  			const size_t positionEquals = text.find("=");
405  			if (positionEquals != std::string::npos) {
406  				const std::string key(text.substr(0, positionEquals));
407  				const std::string_view value = text.substr(positionEquals + 1);
408  				properties[key] = value;
409  			}
410  		}
411  		return ifIsTrue;
412  	}
413  public:
414  	using PropMap = std::map<std::string, std::string>;
415  	PropMap properties;
416  	void ReadFromFile(std::filesystem::path path) {
417  		bool ifIsTrue = true;
418  		std::ifstream ifs(path);
419  		std::string line;
420  		std::string logicalLine;
421  		while (std::getline(ifs, line)) {
422  			if (line.ends_with("\r")) {
423  				line.pop_back();
424  			}
425  			logicalLine += line;
426  			if (logicalLine.ends_with("\\")) {
427  				logicalLine.pop_back();
428  			} else {
429  				ifIsTrue = ProcessLine(logicalLine, ifIsTrue);
430  				logicalLine.clear();
431  			}
432  		}
433  	}
434  	std::optional<std::string> GetProperty(std::string_view key) const {
435  		const PropMap::const_iterator prop = properties.find(std::string(key));
436  		if (prop == properties.end())
437  			return std::nullopt;
438  		else
439  			return prop->second;
440  	}
441  	std::optional<std::string> GetPropertyForFile(std::string_view keyPrefix, std::string_view fileName) const {
442  		for (auto const &[key, val] : properties) {
443  			if (key.starts_with(keyPrefix)) {
444  				const std::string keySuffix = key.substr(keyPrefix.length());
445  				if (fileName.ends_with(keySuffix)) {
446  					return val;
447  				} else if (key.find(';') != std::string::npos) {
448  					for (const std::string &ext : GetFilePatterns(key)) {
449  						if (fileName.ends_with(ext)) {
450  							return val;
451  						}
452  					}
453  				}
454  			}
455  		}
456  		return std::nullopt;
457  	}
458  	std::optional<int> GetPropertyValue(std::string_view key) const {
459  		std::optional<std::string> value = GetProperty(key);
460  		try {
461  			if (value)
462  				return std::stoi(value->c_str());
463  		}
464  		catch (std::invalid_argument &) {
465  		}
466  		return {};
467  	}
468  };
469  size_t FirstLineDifferent(std::string_view a, std::string_view b) {
470  	size_t i = 0;
471  	while (i < std::min(a.size(), b.size()) && a.at(i) == b.at(i)) {
472  		i++;
473  	}
474  	return std::count(a.begin(), a.begin() + i, '\n');
475  }
476  bool CheckSame(std::string_view augmentedText, std::string_view augmentedTextNew, std::string_view item, std::string_view suffix, const std::filesystem::path &path) {
477  	if (augmentedTextNew == augmentedText) {
478  		return true;
479  	}
480  	const size_t lineNumber = FirstLineDifferent(augmentedText, augmentedTextNew) + 1;
481  	std::cout << "\n" << path.string() << ":" << lineNumber << ":";
482  	const std::string differenceType = augmentedText.empty() ? "new" : "different";
483  	std::cout << " has " << differenceType << " " << item << "\n\n";
484  	std::filesystem::path pathNew = path;
485  	pathNew += suffix;
486  	pathNew += ".new";
487  	std::ofstream ofs(pathNew, std::ios::binary);
488  	ofs << augmentedTextNew;
489  	return false;
490  }
491  int Substitute(std::string &s, const std::string &sFind, const std::string &sReplace) {
492  	int c = 0;
493  	const size_t lenFind = sFind.size();
494  	const size_t lenReplace = sReplace.size();
495  	size_t posFound = s.find(sFind);
496  	while (posFound != std::string::npos) {
497  		s.replace(posFound, lenFind, sReplace);
498  		posFound = s.find(sFind, posFound + lenReplace);
499  		c++;
500  	}
501  	return c;
502  }
503  int WindowsToUnix(std::string &s) {
504  	return Substitute(s, "\r\n", "\n");
505  }
506  int UnixToWindows(std::string &s) {
507  	return Substitute(s, "\n", "\r\n");
508  }
509  const std::string BOM = "\xEF\xBB\xBF";
510  void StyleLineByLine(TestDocument &doc, Scintilla::ILexer5 *plex) {
511  	assert(plex);
512  	Scintilla::IDocument *pdoc = &doc;
513  	const Sci_Position lines = doc.LineFromPosition(doc.Length());
514  	Sci_Position startLine = 0;
515  	for (Sci_Position line = 0; line <= lines; line++) {
516  		const Sci_Position endLine = doc.LineStart(line + 1);
517  		int styleStart = 0;
518  		if (startLine > 0)
519  			styleStart = doc.StyleAt(startLine - 1);
520  		plex->Lex(startLine, endLine - startLine, styleStart, pdoc);
521  		plex->Fold(startLine, endLine - startLine, styleStart, pdoc);
522  		startLine = endLine;
523  	}
524  }
525  bool TestCRLF(std::filesystem::path path, const std::string s, Scintilla::ILexer5 *plex, bool disablePerLineTests) {
526  	assert(plex);
527  	bool success = true;
528  	std::string text = s;
529  	WindowsToUnix(text);
530  	const bool originalIsUnix = text == s;
531  	std::string textUnix = text;
532  	UnixToWindows(text);
533  	TestDocument doc;
534  	doc.Set(text);
535  	Scintilla::IDocument *pdoc = &doc;
536  	assert(pdoc);
537  	plex->Lex(0, pdoc->Length(), 0, pdoc);
538  	plex->Fold(0, pdoc->Length(), 0, pdoc);
539  	const auto [styledText, foldedText] = MarkedAndFoldedDocument(pdoc);
540  	int prevStyle = -1;
541  	Sci_Position line = 1;
542  	for (Sci_Position pos = 0; pos < pdoc->Length(); pos++) {
543  		const int styleNow = pdoc->StyleAt(pos);
544  		char ch = '\0';
545  		pdoc->GetCharRange(&ch, pos, 1);
546  		if (ch == '\n') {
547  			if (styleNow != prevStyle) {
548  				std::cout << path.string() << ":" << line << ":" <<
549  					" different styles between \\r and \\n at " <<
550  					pos << ": " << prevStyle << ", " << styleNow << "\n";
551  				success = false;
552  			}
553  			line++;
554  		}
555  		prevStyle = styleNow;
556  	}
557  	TestDocument docUnix;
558  	docUnix.Set(textUnix);
559  	Scintilla::IDocument *pdocUnix = &docUnix;
560  	assert(pdocUnix);
561  	plex->Lex(0, pdocUnix->Length(), 0, pdocUnix);
562  	plex->Fold(0, pdocUnix->Length(), 0, pdocUnix);
563  	auto [styledTextUnix, foldedTextUnix] = MarkedAndFoldedDocument(pdocUnix);
564  	UnixToWindows(styledTextUnix);
565  	UnixToWindows(foldedTextUnix);
566  	if (styledText != styledTextUnix) {
567  		std::cout << "\n" << path.string() << ":1: has different styles with \\n versus \\r\\n line ends\n\n";
568  		success = false;
569  	}
570  	if (foldedText != foldedTextUnix) {
571  		std::cout << "\n" << path.string() << ":1: has different folds with \\n versus \\r\\n line ends\n\n";
572  		success = false;
573  	}
574  	if (!disablePerLineTests && !originalIsUnix) {
575  		StyleLineByLine(docUnix, plex);
576  		auto [styledTextNewPerLine, foldedTextNewPerLine] = MarkedAndFoldedDocument(pdocUnix);
577  		UnixToWindows(styledTextNewPerLine);
578  		UnixToWindows(foldedTextNewPerLine);
579  		if (!CheckSame(styledTextUnix, styledTextNewPerLine, "per-line styles \\n", suffixStyled, path)) {
580  			success = false;
581  		}
582  		if (!CheckSame(foldedTextUnix, foldedTextNewPerLine, "per-line folds \\n", suffixFolded, path)) {
583  			success = false;
584  		}
585  	}
586  	plex->Release();
587  	return success;
588  }
589  void TestILexer(Scintilla::ILexer5 *plex) {
590  	assert(plex);
591  	[[maybe_unused]] const int version = plex->Version();
592  	assert(version == Scintilla::lvRelease5);
593  	[[maybe_unused]] const char *language = plex->GetName();
594  	assert(language);
595  	[[maybe_unused]] const int ident = plex->GetIdentifier();
596  	assert(ident >= 0);
597  	[[maybe_unused]] const char *propertyNames = plex->PropertyNames();
598  	assert(propertyNames);
599  	[[maybe_unused]] const int propertyType = plex->PropertyType("unknown");
600  	assert(propertyType >= 0 && propertyType <= 2);
601  	[[maybe_unused]] const char *propertyDescription = plex->DescribeProperty("unknown");
602  	assert(propertyDescription);
603  	[[maybe_unused]] const Sci_Position invalidation = plex->PropertySet("unknown", "unknown");
604  	assert(invalidation == 0 || invalidation == -1);
605  	[[maybe_unused]] const char *wordListDescription = plex->DescribeWordListSets();
606  	assert(wordListDescription);
607  	[[maybe_unused]] const Sci_Position invalidationWordList = plex->WordListSet(9, "unknown");
608  	assert(invalidationWordList == 0 || invalidationWordList == -1);
609  	[[maybe_unused]] const int lineEndTypes = plex->LineEndTypesSupported();
610  	assert(lineEndTypes == 0 || lineEndTypes == 1);
611  	if (std::string_view bases = plex->GetSubStyleBases(); !bases.empty()) {
612  		while (!bases.empty()) {
613  			constexpr int newStyles = 3;
614  			const int base = bases.front();
615  			const int baseStyle = plex->AllocateSubStyles(base, newStyles);
616  			[[maybe_unused]] const int styleBack = plex->StyleFromSubStyle(baseStyle);
617  			assert(styleBack == base);
618  			plex->SetIdentifiers(baseStyle, "int nullptr");
619  			[[maybe_unused]] const int start = plex->SubStylesStart(base);
620  			assert(start == baseStyle);
621  			[[maybe_unused]] const int len = plex->SubStylesLength(base);
622  			assert(len == newStyles);
623  			bases.remove_prefix(1);
624  		}
625  		plex->FreeSubStyles();
626  	}
627  	[[maybe_unused]] const int primary = plex->PrimaryStyleFromStyle(2);
628  	assert(primary == 2);
629  	[[maybe_unused]] const int distance = plex->DistanceToSecondaryStyles();
630  	assert(distance >= 0);
631  	[[maybe_unused]] const char *propertyUnknownValue = plex->PropertyGet("unknown");
632  	const int styles = plex->NamedStyles();
633  	for (int style = 0; style < styles; style++) {
634  		[[maybe_unused]] const char *name = plex->NameOfStyle(style);
635  		assert(name);
636  		[[maybe_unused]] const char *tags = plex->TagsOfStyle(style);
637  		assert(tags);
638  		[[maybe_unused]] const char *description = plex->DescriptionOfStyle(style);
639  		assert(description);
640  	}
641  }
642  bool SetProperties(Scintilla::ILexer5 *plex, const std::string &language, const PropertyMap &propertyMap, std::filesystem::path path) {
643  	assert(plex);
644  	const std::string fileName = path.filename().string();
645  	if (std::string_view bases = plex->GetSubStyleBases(); !bases.empty()) {
646  		while (!bases.empty()) {
647  			const int baseStyle = bases.front();
648  			const std::string base = std::to_string(baseStyle);
649  			const std::string substylesForBase = "substyles." + language + "." + base;
650  			std::optional<std::string> substylesN = propertyMap.GetProperty(substylesForBase);
651  			if (substylesN) {
652  				const int substyles = atoi(substylesN->c_str());
653  				const int baseStyleNum = plex->AllocateSubStyles(baseStyle, substyles);
654  				for (int kw = 0; kw < substyles; kw++) {
655  					const std::string substyleWords = "substylewords." + base + "." + std::to_string(kw + 1) + ".*";
656  					const std::optional<std::string> keywordN = propertyMap.GetPropertyForFile(substyleWords, fileName);
657  					if (keywordN) {
658  						plex->SetIdentifiers(baseStyleNum + kw, keywordN->c_str());
659  					}
660  				}
661  			}
662  			bases.remove_prefix(1);
663  		}
664  	}
665  	for (int kw = 0; kw < 10; kw++) {
666  		std::string kwChoice("keywords");
667  		if (kw > 0) {
668  			kwChoice.push_back(static_cast<char>('1' + kw));
669  		}
670  		kwChoice.append(".*");
671  		std::optional<std::string> keywordN = propertyMap.GetPropertyForFile(kwChoice, fileName);
672  		if (keywordN) {
673  			const Sci_Position changedEmpty = plex->WordListSet(kw, "");
674  			if (changedEmpty != -1) {
675  				std::cout << path.string() << ":1: does not return -1 for null WordListSet(" << kw << ")\n";
676  				return false;
677  			}
678  			const Sci_Position changedAt = plex->WordListSet(kw, keywordN->c_str());
679  			if (keywordN->empty()) {
680  				if (changedAt != -1) {
681  					std::cout << path.string() << ":1: does not return -1 for WordListSet(" << kw << ") to same empty" << "\n";
682  					return false;
683  				}
684  			} else {
685  				if (changedAt == -1) {
686  					std::cout << path.string() << ":1: returns -1 for WordListSet(" << kw << ")\n";
687  					return false;
688  				}
689  			}
690  		}
691  	}
692  	for (auto const &[key, val] : propertyMap.properties) {
693  		if (key.starts_with("lexer.*")) {
694  		} else if (key.starts_with("keywords")) {
695  		} else if (key.starts_with("substyle")) {
696  		} else {
697  			plex->PropertySet(key.c_str(), val.c_str());
698  		}
699  	}
700  	return true;
701  }
702  bool TestFile(const std::filesystem::path &path, const PropertyMap &propertyMap) {
703  	std::optional<std::string> language = propertyMap.GetPropertyForFile(lexerPrefix, path.filename().string());
704  	if (!language) {
705  		std::cout << "\n" << path.string() << ":1: has no language\n\n";
706  		return false;
707  	}
708  	Scintilla::ILexer5 *plex = Lexilla::MakeLexer(*language);
709  	if (!plex) {
710  		std::cout << "\n" << path.string() << ":1: has no lexer for " << *language << "\n\n";
711  		return false;
712  	}
713  	TestILexer(plex);
714  	if (!SetProperties(plex, *language, propertyMap, path)) {
715  		return false;
716  	}
717  	std::string text = ReadFile(path);
718  	if (text.starts_with(BOM)) {
719  		text.erase(0, BOM.length());
720  	}
721  	std::filesystem::path pathStyled = path;
722  	pathStyled += suffixStyled;
723  	const std::string styledText = ReadFile(pathStyled);
<span onclick='openModal()' class='match'>724  	std::filesystem::path pathFolded = path;
725  	pathFolded += suffixFolded;
726  	const std::string foldedText = ReadFile(pathFolded);
727  	const int repeatLex = propertyMap.GetPropertyValue("testlexers.repeat.lex").value_or(1);
</span>728  	const int repeatFold = propertyMap.GetPropertyValue("testlexers.repeat.fold").value_or(1);
729  	TestDocument doc;
730  	doc.Set(text);
731  	Scintilla::IDocument *pdoc = &doc;
732  	assert(pdoc);
733  	for (int i = 0; i < repeatLex; i++) {
734  		plex->Lex(0, pdoc->Length(), 0, pdoc);
735  	}
736  	for (int i = 0; i < repeatFold; i++) {
737  		plex->Fold(0, pdoc->Length(), 0, pdoc);
738  	}
739  	bool success = true;
740  	const auto [styledTextNew, foldedTextNew] = MarkedAndFoldedDocument(pdoc);
741  	if (!CheckSame(styledText, styledTextNew, "styles", suffixStyled, path)) {
742  		success = false;
743  	}
744  	if (!CheckSame(foldedText, foldedTextNew, "folds", suffixFolded, path)) {
745  		success = false;
746  	}
747  	if (propertyMap.GetPropertyValue("testlexers.list.styles").value_or(0)) {
748  		std::vector<bool> used(0x100);
749  		for (Sci_Position pos = 0; pos < pdoc->Length(); pos++) {
750  			const unsigned char uchStyle = pdoc->StyleAt(pos);
751  			const unsigned style = uchStyle;
752  			used.at(style) = true;
753  		}
754  		PrintRanges(used);
755  	}
756  	const std::optional<int> perLineDisable = propertyMap.GetPropertyValue("testlexers.per.line.disable");
757  	const bool disablePerLineTests = perLineDisable.value_or(false);
758  	if (success && !disablePerLineTests) {
759  		doc.Set(text);
760  		StyleLineByLine(doc, plex);
761  		const auto [styledTextNewPerLine, foldedTextNewPerLine] = MarkedAndFoldedDocument(pdoc);
762  		success = success && CheckSame(styledText, styledTextNewPerLine, "per-line styles", suffixStyled, path);
763  		success = success && CheckSame(foldedText, foldedTextNewPerLine, "per-line folds", suffixFolded, path);
764  	}
765  	plex->Release();
766  	if (success) {
767  		Scintilla::ILexer5 *plexCRLF = Lexilla::MakeLexer(*language);
768  		SetProperties(plexCRLF, *language, propertyMap, path.filename().string());
769  		success = TestCRLF(path, text, plexCRLF, disablePerLineTests);
770  	}
771  	return success;
772  }
773  bool TestDirectory(std::filesystem::path directory, std::filesystem::path basePath) {
774  	bool success = true;
775  	for (auto &p : std::filesystem::directory_iterator(directory)) {
776  		if (!p.is_directory()) {
777  			const std::string extension = p.path().extension().string();
778  			if (extension != ".properties" && extension != suffixStyled && extension != ".new" &&
779  				extension != suffixFolded) {
780  				const std::filesystem::path relativePath = p.path().lexically_relative(basePath);
781  				std::cout << "Lexing " << relativePath.string() << '\n';
782  				PropertyMap properties;
783  				properties.properties["FileNameExt"] = p.path().filename().string();
784  				properties.ReadFromFile(directory / "SciTE.properties");
785  				if (!TestFile(p, properties)) {
786  					success = false;
787  				}
788  			}
789  		}
790  	}
791  	return success;
792  }
793  bool AccessLexilla(std::filesystem::path basePath) {
794  	if (!std::filesystem::exists(basePath)) {
795  		std::cout << "No examples at " << basePath.string() << "\n";
796  		return false;
797  	}
798  	bool success = true;
799  	for (auto &p : std::filesystem::recursive_directory_iterator(basePath)) {
800  		if (p.is_directory()) {
801  			if (!TestDirectory(p, basePath)) {
802  				success = false;
803  			}
804  		}
805  	}
806  	return success;
807  }
808  std::filesystem::path FindLexillaDirectory(std::filesystem::path startDirectory) {
809  	std::filesystem::path directory = startDirectory;
810  	while (!directory.empty()) {
811  		const std::filesystem::path parent = directory.parent_path();
812  		const std::filesystem::path localLexilla = directory / "lexilla";
813  		const std::filesystem::directory_entry entry(localLexilla);
814  		if (entry.is_directory()) {
815  			std::cout << "Found Lexilla at " << entry.path().string() << "\n";
816  			return localLexilla;
817  		}
818  		const std::filesystem::path localBin = directory / "bin";
819  		const std::filesystem::directory_entry entryBin(localBin);
820  		if (entryBin.is_directory()) {
821  			std::cout << "Found Lexilla at " << directory.string() << "\n";
822  			return directory;
823  		}
824  		if (parent == directory) {
825  			std::cout << "Reached root at " << directory.string() << "\n";
826  			return std::filesystem::path();
827  		}
828  		directory = parent;
829  	}
830  	return std::filesystem::path();
831  }
832  }
833  int main() {
834  	bool success = false;
835  	const std::filesystem::path baseDirectory = FindLexillaDirectory(std::filesystem::current_path());
836  	if (!baseDirectory.empty()) {
837  		const std::filesystem::path examplesDirectory = baseDirectory / "test" / "examples";
838  #if defined(LEXILLA_STATIC)
839  		success = AccessLexilla(examplesDirectory);
840  #else
841  		const std::filesystem::path sharedLibrary = baseDirectory / "bin" / LEXILLA_LIB;
842  		if (Lexilla::Load(sharedLibrary.string())) {
843  			success = AccessLexilla(examplesDirectory);
844  		} else {
845  			std::cout << "Failed to load " << sharedLibrary << "\n";
846  		}
847  #endif
848  	}
849  	return success ? 0 : 1;
850  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-TestLexers.cxx</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-TestLexers.cxx</div>
                </div>
                <div class="column column_space"><pre><code>721  	std::filesystem::path pathStyled = path;
722  	pathStyled += suffixStyled;
723  	const std::string styledText = ReadFile(pathStyled);
724  	std::filesystem::path pathFolded = path;
</pre></code></div>
                <div class="column column_space"><pre><code>724  	std::filesystem::path pathFolded = path;
725  	pathFolded += suffixFolded;
726  	const std::string foldedText = ReadFile(pathFolded);
727  	const int repeatLex = propertyMap.GetPropertyValue("testlexers.repeat.lex").value_or(1);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    