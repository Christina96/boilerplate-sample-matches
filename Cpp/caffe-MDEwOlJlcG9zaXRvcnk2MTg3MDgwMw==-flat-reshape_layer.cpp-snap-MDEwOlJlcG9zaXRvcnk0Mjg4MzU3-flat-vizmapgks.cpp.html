
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 16.746739876458477%, Tokens: 14, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-reshape_layer.cpp</h3>
            <pre><code>1  #include <vector>
2  #include "caffe/layers/reshape_layer.hpp"
3  namespace caffe {
4  template <typename Dtype>
5  void ReshapeLayer<Dtype>::LayerSetUp(const vector<Blob<Dtype>*>& bottom,
6      const vector<Blob<Dtype>*>& top) {
7    CHECK_NE(top[0], bottom[0]) << this->type() << " Layer does not "
8        "allow in-place computation.";
9    const int ps = this->layer_param_.reshape_param().pixelshuffler();
10    if(ps == 1){
11      inferred_axis_ = -1;
12      copy_axes_.clear();
13      const BlobShape& top_blob_shape = this->layer_param_.reshape_param().shape();
14      const int top_num_axes = top_blob_shape.dim_size();
15      constant_count_ = 1;
16      for (int i = 0; i < top_num_axes; ++i) {
17        const int top_dim = top_blob_shape.dim(i);
18        if (top_dim == 0) {
19          copy_axes_.push_back(i);
20        } else if (top_dim == -1) {
21          CHECK_EQ(inferred_axis_, -1) << "new shape contains multiple "
22              << "-1 dims; at most a single (1) value of -1 may be specified";
23          inferred_axis_ = i;
24        } else {
25          constant_count_ *= top_dim;
26        }
27     }
28    }
29  }
30  template <typename Dtype>
31  void ReshapeLayer<Dtype>::Reshape(const vector<Blob<Dtype>*>& bottom,
32      const vector<Blob<Dtype>*>& top) {
33    const int ps = this->layer_param_.reshape_param().pixelshuffler();   
34    if (ps ==1 ){
35          const int input_start_axis = this->layer_param_.reshape_param().axis();
36          const int start_axis = (input_start_axis >= 0) ? input_start_axis :
37              bottom[0]->num_axes() + input_start_axis + 1;
38          CHECK_GE(start_axis, 0) << "axis " << input_start_axis << " out of range";
39          CHECK_LE(start_axis, bottom[0]->num_axes()) << "axis " << input_start_axis
40              << " out of range for " << bottom[0]->num_axes() << "-D input blob";
41          const int num_axes = this->layer_param_.reshape_param().num_axes();
42          CHECK_GE(num_axes, -1) << "num_axes must be >= 0, or -1 for all";
43          const int end_axis =
44              (num_axes == -1) ? bottom[0]->num_axes() : (start_axis + num_axes);
45          CHECK_LE(end_axis, bottom[0]->num_axes())
46              << "end_axis = axis + num_axes is out of range";
47          const int num_axes_replaced = end_axis - start_axis;
48          const int num_axes_retained = bottom[0]->num_axes() - num_axes_replaced;
49          const BlobShape& top_blob_shape = this->layer_param_.reshape_param().shape();
50          const int num_new_axes = top_blob_shape.dim_size();
51          vector<int> top_shape(num_axes_retained + num_new_axes);
52          int top_shape_index = 0;
53          for (int i = 0; i < start_axis; ++i) {
54            top_shape[top_shape_index++] = bottom[0]->shape(i);
55          }
56          for (int i = 0; i < num_new_axes; ++i) {
57            top_shape[top_shape_index++] = top_blob_shape.dim(i);
58          }
59          for (int i = end_axis; i < bottom[0]->num_axes(); ++i) {
60            top_shape[top_shape_index++] = bottom[0]->shape(i);
61          }
62          CHECK_EQ(top_shape_index, top_shape.size());
63          for (int i = 0; i < copy_axes_.size(); ++i) {
64            const int copy_axis_index = copy_axes_[i];
65            CHECK_GT(bottom[0]->num_axes(), start_axis + copy_axis_index)
66                << "new shape contains a 0, but there was no corresponding bottom axis "
67                << "to copy";
68            top_shape[start_axis + copy_axis_index] =
69                bottom[0]->shape(start_axis + copy_axis_index);
70          }
71          if (inferred_axis_ >= 0) {
72            int explicit_count = constant_count_;
73            explicit_count *= bottom[0]->count(0, start_axis);
74            explicit_count *= bottom[0]->count(end_axis);
75            for (int i = 0; i < copy_axes_.size(); ++i) {
76              const int copy_axis_index = copy_axes_[i];
77              explicit_count *= top_shape[start_axis + copy_axis_index];
78            }
79            CHECK_EQ(0, bottom[0]->count() % explicit_count) << "bottom count ("
80                << bottom[0]->count() << ") must be divisible by the product of "
81                << "the specified dimensions (" << explicit_count << ")";
82            const int inferred_dim = bottom[0]->count() / explicit_count;
83            top_shape[start_axis + inferred_axis_] = inferred_dim;
84          }
85          top[0]->Reshape(top_shape);
86          CHECK_EQ(top[0]->count(), bottom[0]->count())
87              << "output count must match input count";
88          top[0]->ShareData(*bottom[0]);
89          top[0]->ShareDiff(*bottom[0]);
90    }
91    else {
92      vector<int> bottom_shape = bottom[0]->shape();
93      const int bn = bottom_shape[0];
94      const int bc = bottom_shape[1];
95      const int bh = bottom_shape[2];
96      const int bw = bottom_shape[3];
97      vector<int> top_shape(4);
98      top_shape[0] = bn;
99      top_shape[1] = bc/(ps * ps);
100      top_shape[2] = bh * ps;
101      top_shape[3] = bw * ps;
102      top[0]->Reshape(top_shape);
103      CHECK_EQ(top[0]->count(), bottom[0]->count())
104              << "output count must match input count";
105    }
106  }
107  template <typename Dtype>
108  void ReshapeLayer<Dtype>::Forward_cpu(const vector<Blob<Dtype>*>& bottom,
109        const vector<Blob<Dtype>*>& top){
110    const int ps = this->layer_param_.reshape_param().pixelshuffler();
111    if( ps == 1){}
112    else{
113      vector<int> bottom_shape = bottom[0]->shape();
114      const int bn = bottom_shape[0];
115      const int bc = bottom_shape[1];
116      const int bh = bottom_shape[2];
117      const int bw = bottom_shape[3];
118      vector<int> top_shape = top[0]->shape();
119      const int tc = top_shape[1];
120      const int th = top_shape[2];
121      const int tw = top_shape[3];
122      int test_r1 = bc/tc;
123      const int r = th / bh;
124      int test_r2 = r * r;
125      CHECK_EQ( test_r1, test_r2) << "Pixelshuffler output is illegal";
126      const Dtype* bottom_data = bottom[0]->cpu_data();
127      Dtype* top_data = top[0]->mutable_cpu_data();
128      #ifdef _OPENMP
129          #if defined(_MSC_EXTENSIONS)
130              #pragma omp parallel for
131          #else
132              #pragma omp parallel for collapse(2)
133          #endif
134      #endif
135      for(int n = 0; n < bn; n++) {
136        for(int c = 0; c < bc; c++) {
137          for(int h = 0; h < bh; h++) {
138            for(int w = 0; w < bw; w++) {
139                int new_c = static_cast<int>(floor(c/(r*r)));
140                int new_h = h*r + (static_cast<int>(floor(c/r)))%r;
141                int new_w = w*r+ (c%(r*r))%r;
142                int top_index = n*(tc*th*tw)+ new_c*(th*tw)+ new_h*tw+ new_w;
143                int bottom_index = n*bc*bh*bw + c*(bh*bw) + h*bw + w;
144                top_data[top_index] = bottom_data[bottom_index];
145            }
146          }
147        }
148      }
149    }
150  }
151  template <typename Dtype>
152  void ReshapeLayer<Dtype>::Backward_cpu(const vector<Blob<Dtype>*>& top,
153        const vector<bool>& propagate_down, const vector<Blob<Dtype>*>& bottom){
154    const int ps = this->layer_param_.reshape_param().pixelshuffler();
155    if( ps == 1){}
156    else{
<span onclick='openModal()' class='match'>157      vector<int> top_shape = top[0]->shape();
158      const int tn = top_shape[0];    
159      const int tc = top_shape[1];
160      const int th = top_shape[2];
161      const int tw = top_shape[3];
162      vector<int> bottom_shape = bottom[0]->shape();
</span>163      const int bc = bottom_shape[1];
164      const int bh = bottom_shape[2];
165      const int bw = bottom_shape[3];
166      const int r = th / bh;
167      Dtype* bottom_diff = bottom[0]->mutable_cpu_diff();
168      const Dtype* top_diff = top[0]->cpu_diff();
169      #ifdef _OPENMP
170          #if defined(_MSC_EXTENSIONS)
171              #pragma omp parallel for
172          #else
173              #pragma omp parallel for collapse(2)
174          #endif
175      #endif
176      for(int n = 0; n < tn; n++) {
177        for(int c = 0; c < tc; c++) {
178          for(int h = 0; h < th; h++) {
179            for(int w = 0; w < tw; w++) {
180                int old_c = c*r*r + (h%r)*r + w%r;
181                int old_h = static_cast<int>(floor(h/r));
182                int old_w = static_cast<int>(floor(w/r));
183                int bottom_index = n*(bc*bh*bw)+ old_c*(bh*bw)+ old_h*bw+ old_w;
184                int top_index = n*(tc*th*tw)+ c*(th*tw)+ h*tw+ w;
185                bottom_diff[bottom_index] = top_diff[top_index];
186            }
187          }
188        }
189      }
190    }
191  }
192  INSTANTIATE_CLASS(ReshapeLayer);
193  REGISTER_LAYER_CLASS(Reshape);
194  }  
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-vizmapgks.cpp</h3>
            <pre><code>1  #include "vizmapgks.h"
2  #include <gkswf.h>
3  TGksColor TVizMapContext::ColorLandscapeAbove = TGksColor(54, 92, 120);
4  TGksColor TVizMapContext::ColorAddFirstLevel = TGksColor(9, 7, 6);
5  TGksColor TVizMapContext::ColorAddSecondLevel = TGksColor(18, 14, 12);
6  TGksColor TVizMapContext::ColorLegendGridColor = TGksColor(192, 255, 255, 255);
7  TGksColor TVizMapContext::ColorPointCross = TGksColor(255, 220, 0);
8  TGksColor TVizMapContext::ColorSelPointCross = TGksColor(255, 145, 145);
9  TGksColor TVizMapContext::ColorPointFont = TGksColor(255, 220, 0);
10  TGksColor TVizMapContext::ColorSelPointFont = TGksColor(255, 255, 30);
11  TGksColor TVizMapContext::ColorLink = TGksColor(100, 100, 255, 100);
12  TGksColor TVizMapContext::ColorKeyWdFont = TGksColor(240,240,255);
13  TGksColor TVizMapContext::ColorCatNmFont = TGksColor(255,240,255);
14  TGksColor TVizMapContext::ColorZoomRect = TGksColor(100, 0, 0, 0); 
15  TGksColor TVizMapContext::ColorMgGlass = TGksColor(50, 0, 0, 0);
16  TGksColor TVizMapContext::ColorMgGlassWnd = TGksColor(192, 255, 255, 255);
17  TGksColor TVizMapContext::ColorMgGlassWndFrm = TGksColor(100, 0, 0, 0); 
18  TGksColor TVizMapContext::ColorMgGlassWndShadow = TGksColor(50, 0, 0, 0);
19  int TVizMapContext::SizePointCross = 2;
20  int TVizMapContext::PointNmWidth = 100;
21  int TVizMapContext::PointNmMxLines = 3;
22  double TVizMapContext::PointNmFontScale = 20.0;
23  int TVizMapContext::MgGlassWindowWidth = 150;
24  int TVizMapContext::RndKeyWdN = 3000;
25  double TVizMapContext::RelRadius = 0.2;
26  int TVizMapContext::KeyWdCandidates = 10;
27  double TVizMapContext::RelMnRptDist = 0.1;
28  double TVizMapContext::RelSparsity = 0.05;
29  void TVizMapContext::LoadColor() {
30      LandscapeCatColorV.Clr();
31      LandscapeCatColorV.Add(TGksColor(43, 76, 115));
32      LandscapeCatColorV.Add(TGksColor(53, 46, 115));
33      LandscapeCatColorV.Add(TGksColor(33, 106, 115));
34      LandscapeCatColorV.Add(TGksColor(63, 80, 170));
35      LandscapeCatColorV.Add(TGksColor(61, 106, 200));
36      LandscapeCatColorV.Add(TGksColor(71, 106, 190));
37      LandscapeCatColorV.Add(TGksColor(51, 106, 210));
38      LandscapeCatColorV.Add(TGksColor(81, 106, 180));
39      LandscapeCatColorV.Add(TGksColor(43, 91, 125));
40      LandscapeCatColorV.Add(TGksColor(43, 91, 135));
41      LandscapeCatColorV.Add(TGksColor(43, 91, 145));
42      LandscapeCatColorV.Add(TGksColor(43, 91, 155));
43      LandscapeCatColorV.Add(TGksColor(43, 106, 125));
44      LandscapeCatColorV.Add(TGksColor(43, 106, 135));
45      LandscapeCatColorV.Add(TGksColor(43, 106, 145));
46      LandscapeCatColorV.Add(TGksColor(43, 106, 155));
47  }
48  void TVizMapContext::LoadCatFullNms() {
49      CatFullNmH.AddDat("1POL", "CURRENT NEWS - POLITICS");
50      CatFullNmH.AddDat("2ECO", "CURRENT NEWS - ECONOMICS");
51      CatFullNmH.AddDat("3SPO", "CURRENT NEWS - SPORT");
52      CatFullNmH.AddDat("4GEN", "CURRENT NEWS - GENERAL");
53      CatFullNmH.AddDat("6INS", "CURRENT NEWS - INSURANCE");
54      CatFullNmH.AddDat("7RSK", "CURRENT NEWS - RISK NEWS");
55      CatFullNmH.AddDat("8YDB", "TEMPORARY");
56      CatFullNmH.AddDat("9BNX", "TEMPORARY");
57      CatFullNmH.AddDat("ADS10", "CURRENT NEWS - ADVERTISING");
58      CatFullNmH.AddDat("BNW14", "CURRENT NEWS - BUSINESS NEWS");
59      CatFullNmH.AddDat("BRP11", "CURRENT NEWS - BRANDS");
60      CatFullNmH.AddDat("C11", "STRATEGY/PLANS");
61      CatFullNmH.AddDat("C12", "LEGAL/JUDICIAL");
62      CatFullNmH.AddDat("C13", "REGULATION/POLICY");
63      CatFullNmH.AddDat("C14", "SHARE LISTINGS");
64      CatFullNmH.AddDat("C15", "PERFORMANCE");
65      CatFullNmH.AddDat("C151", "ACCOUNTS/EARNINGS");
66      CatFullNmH.AddDat("C1511", "ANNUAL RESULTS");
67      CatFullNmH.AddDat("C152", "COMMENT/FORECASTS");
68      CatFullNmH.AddDat("C16", "INSOLVENCY/LIQUIDITY");
69      CatFullNmH.AddDat("C17", "FUNDING/CAPITAL");
70      CatFullNmH.AddDat("C171", "SHARE CAPITAL");
71      CatFullNmH.AddDat("C172", "BONDS/DEBT ISSUES");
72      CatFullNmH.AddDat("C173", "LOANS/CREDITS");
73      CatFullNmH.AddDat("C174", "CREDIT RATINGS");
74      CatFullNmH.AddDat("C18", "OWNERSHIP CHANGES");
75      CatFullNmH.AddDat("C181", "MERGERS/ACQUISITIONS");
76      CatFullNmH.AddDat("C182", "ASSET TRANSFERS");
77      CatFullNmH.AddDat("C183", "PRIVATISATIONS");
78      CatFullNmH.AddDat("C21", "PRODUCTION/SERVICES");
79      CatFullNmH.AddDat("C22", "NEW PRODUCTS/SERVICES");
80      CatFullNmH.AddDat("C23", "RESEARCH/DEVELOPMENT");
81      CatFullNmH.AddDat("C24", "CAPACITY/FACILITIES");
82      CatFullNmH.AddDat("C31", "MARKETS/MARKETING");
83      CatFullNmH.AddDat("C311", "DOMESTIC MARKETS");
84      CatFullNmH.AddDat("C312", "EXTERNAL MARKETS");
85      CatFullNmH.AddDat("C313", "MARKET SHARE");
86      CatFullNmH.AddDat("C32", "ADVERTISING/PROMOTION");
87      CatFullNmH.AddDat("C33", "CONTRACTS/ORDERS");
88      CatFullNmH.AddDat("C331", "DEFENCE CONTRACTS");
89      CatFullNmH.AddDat("C34", "MONOPOLIES/COMPETITION");
90      CatFullNmH.AddDat("C41", "MANAGEMENT");
91      CatFullNmH.AddDat("C411", "MANAGEMENT MOVES");
92      CatFullNmH.AddDat("C42", "LABOUR");
93      CatFullNmH.AddDat("CCAT", "CORPORATE/INDUSTRIAL");
94      CatFullNmH.AddDat("E11", "ECONOMIC PERFORMANCE");
95      CatFullNmH.AddDat("E12", "MONETARY/ECONOMIC");
96      CatFullNmH.AddDat("E121", "MONEY SUPPLY");
97      CatFullNmH.AddDat("E13", "INFLATION/PRICES");
98      CatFullNmH.AddDat("E131", "CONSUMER PRICES");
99      CatFullNmH.AddDat("E132", "WHOLESALE PRICES");
100      CatFullNmH.AddDat("E14", "CONSUMER FINANCE");
101      CatFullNmH.AddDat("E141", "PERSONAL INCOME");
102      CatFullNmH.AddDat("E142", "CONSUMER CREDIT");
103      CatFullNmH.AddDat("E143", "RETAIL SALES");
104      CatFullNmH.AddDat("E21", "GOVERNMENT FINANCE");
105      CatFullNmH.AddDat("E211", "EXPENDITURE/REVENUE");
106      CatFullNmH.AddDat("E212", "GOVERNMENT BORROWING");
107      CatFullNmH.AddDat("E31", "OUTPUT/CAPACITY");
108      CatFullNmH.AddDat("E311", "INDUSTRIAL PRODUCTION");
109      CatFullNmH.AddDat("E312", "CAPACITY UTILIZATION");
110      CatFullNmH.AddDat("E313", "INVENTORIES");
111      CatFullNmH.AddDat("E41", "EMPLOYMENT/LABOUR");
112      CatFullNmH.AddDat("E411", "UNEMPLOYMENT");
113      CatFullNmH.AddDat("E51", "TRADE/RESERVES");
114      CatFullNmH.AddDat("E511", "BALANCE OF PAYMENTS");
115      CatFullNmH.AddDat("E512", "MERCHANDISE TRADE");
116      CatFullNmH.AddDat("E513", "RESERVES");
117      CatFullNmH.AddDat("E61", "HOUSING STARTS");
118      CatFullNmH.AddDat("E71", "LEADING INDICATORS");
119      CatFullNmH.AddDat("ECAT", "ECONOMICS");
120      CatFullNmH.AddDat("ENT12", "CURRENT NEWS - ENTERTAINMENT");
121      CatFullNmH.AddDat("G11", "SOCIAL AFFAIRS");
122      CatFullNmH.AddDat("G111", "HEALTH/SAFETY");
123      CatFullNmH.AddDat("G112", "SOCIAL SECURITY");
124      CatFullNmH.AddDat("G113", "EDUCATION/RESEARCH");
125      CatFullNmH.AddDat("G12", "INTERNAL POLITICS");
126      CatFullNmH.AddDat("G13", "INTERNATIONAL RELATIONS");
127      CatFullNmH.AddDat("G131", "DEFENCE");
128      CatFullNmH.AddDat("G14", "ENVIRONMENT");
129      CatFullNmH.AddDat("G15", "EUROPEAN COMMUNITY");
130      CatFullNmH.AddDat("G151", "EC INTERNAL MARKET");
131      CatFullNmH.AddDat("G152", "EC CORPORATE POLICY");
132      CatFullNmH.AddDat("G153", "EC AGRICULTURE POLICY");
133      CatFullNmH.AddDat("G154", "EC MONETARY/ECONOMIC");
134      CatFullNmH.AddDat("G155", "EC INSTITUTIONS");
135      CatFullNmH.AddDat("G156", "EC ENVIRONMENT ISSUES");
136      CatFullNmH.AddDat("G157", "EC COMPETITION/SUBSIDY");
137      CatFullNmH.AddDat("G158", "EC EXTERNAL RELATIONS");
138      CatFullNmH.AddDat("G159", "EC GENERAL");
139      CatFullNmH.AddDat("GCAT", "GOVERNMENT/SOCIAL");
140      CatFullNmH.AddDat("GCRIM", "CRIME, LAW ENFORCEMENT");
141      CatFullNmH.AddDat("GDEF", "DEFENCE");
142      CatFullNmH.AddDat("GDIP", "INTERNATIONAL RELATIONS");
143      CatFullNmH.AddDat("GDIS", "DISASTERS AND ACCIDENTS");
144      CatFullNmH.AddDat("GEDU", "EDUCATION");
145      CatFullNmH.AddDat("GENT", "ARTS, CULTURE, ENTERTAINMENT");
146      CatFullNmH.AddDat("GENV", "ENVIRONMENT AND NATURAL WORLD");
147      CatFullNmH.AddDat("GFAS", "FASHION");
148      CatFullNmH.AddDat("GHEA", "HEALTH");
149      CatFullNmH.AddDat("GJOB", "LABOUR ISSUES");
150      CatFullNmH.AddDat("GMIL", "MILLENNIUM ISSUES");
151      CatFullNmH.AddDat("GOBIT", "OBITUARIES");
152      CatFullNmH.AddDat("GODD", "HUMAN INTEREST");
153      CatFullNmH.AddDat("GPOL", "DOMESTIC POLITICS");
154      CatFullNmH.AddDat("GPRO", "BIOGRAPHIES, PERSONALITIES, PEOPLE");
155      CatFullNmH.AddDat("GREL", "RELIGION");
156      CatFullNmH.AddDat("GSCI", "SCIENCE AND TECHNOLOGY");
157      CatFullNmH.AddDat("GSPO", "SPORTS");
158      CatFullNmH.AddDat("GTOUR", "TRAVEL AND TOURISM");
159      CatFullNmH.AddDat("GVIO", "WAR, CIVIL WAR");
160      CatFullNmH.AddDat("GVOTE", "ELECTIONS");
161      CatFullNmH.AddDat("GWEA", "WEATHER");
162      CatFullNmH.AddDat("GWELF", "WELFARE, SOCIAL SERVICES");
163      CatFullNmH.AddDat("M11", "EQUITY MARKETS");
164      CatFullNmH.AddDat("M12", "BOND MARKETS");
165      CatFullNmH.AddDat("M13", "MONEY MARKETS");
166      CatFullNmH.AddDat("M131", "INTERBANK MARKETS");
167      CatFullNmH.AddDat("M132", "FOREX MARKETS");
168      CatFullNmH.AddDat("M14", "COMMODITY MARKETS");
169      CatFullNmH.AddDat("M141", "SOFT COMMODITIES");
170      CatFullNmH.AddDat("M142", "METALS TRADING");
171      CatFullNmH.AddDat("M143", "ENERGY MARKETS");
172      CatFullNmH.AddDat("MCAT", "MARKETS");
173      CatFullNmH.AddDat("MEUR", "EURO CURRENCY");
174      CatFullNmH.AddDat("PRB13", "CURRENT NEWS - PRESS RELEASE WIRES");
175  }
176  TFltRect TVizMapContext::GetZoomRect() {
177      if (!ZoomS.Empty()) {
178          return ZoomS.Top();
179      } else {
180          return TFltRect(0.0, 0.0, 1.0, 1.0);
181      }
182  }
183  void TVizMapContext::RenderLandscapeBmp() {
184      if (SelLandscape.Empty()) return;
185      TFltRect ZoomRect = GetZoomRect();
186      const int MaxWidth = SelLandscape->GetXDim();
187      const int MaxHeight = SelLandscape->GetYDim();
188      const int Width = TFlt::Round(ZoomRect.GetXLen()*MaxWidth);
189      const int Height = TFlt::Round(ZoomRect.GetYLen()*MaxHeight);
190      const int LeftX = TFlt::Round(ZoomRect.GetMnX()*MaxWidth);
191      const int TopY = TFlt::Round(ZoomRect.GetMnY()*MaxHeight);
192      if (Width > 0 && Height > 0) {        
193          const TSFltVV& HeightVV = SelLandscape->HeightVV();
194              Assert(SelLandscape->GetLevels() == 2);
195              const double First = SelLandscape->GetLevel(0);
196              const double Second = SelLandscape->GetLevel(1);
197              LandscapeBmp = TGksBitmap::New(Width, Height, ColorLandscapeAbove);
198              for (int X = 0; X < Width; X++) {
199                  for (int Y = 0; Y < Height; Y++) {
200                      double Val = HeightVV(LeftX+X, TopY+Y);
201                      if (Val > Second) { Val = Second + 3*(Val - Second); }
202                      TGksColor PixelColor = ColorLandscapeAbove.Add(
203                          TFlt::Round(Val*34), TFlt::Round(Val*28), TFlt::Round(Val*24));
204                      if (Val > Second) { PixelColor = PixelColor.Add(ColorAddSecondLevel); } 
205                      if (Val > First) { PixelColor = PixelColor.Add(ColorAddFirstLevel); }
206                      LandscapeBmp->SetPixel(X, Y, PixelColor);
207                  }
208              }
209      } else {
210          LandscapeBmp = TGksBitmap::New(1, 1, ColorLandscapeAbove);
211      }
212  }
213  void TVizMapContext::ResetMgGlassSize() { 
214      TFltRect ZoomRect = GetZoomRect();
215      MgGlassSize = 0.2 * TFlt::GetMn(ZoomRect.GetXLen(), ZoomRect.GetYLen()); 
216  }
217  void TVizMapContext::ResetMgGlassKeyWd(const int& MgGlassKeyWds) {
218      MgGlassPoints = VizMapFrame->GenKeyWd(TFltV::GetV(MouseX, MouseY), 
219          MgGlassSize, MgGlassKeyWds, MgGlassKeyWdV, false, false);
220  }
221  void TVizMapContext::ResetKeyWd() {
222      TFltRect ZoomRect = GetZoomRect();
223      const double MnZoomRectSize = TFlt::GetMn(ZoomRect.GetXLen(), ZoomRect.GetYLen());
224      const double Radius = RelRadius * MnZoomRectSize; 
225      VizMapFrame->GenKeyWds(RndKeyWdN, Radius, KeyWdCandidates, 0, ZoomRect); 
226  }
227  void TVizMapContext::ResetNearPointN() {
228      double MnDist = TFlt::Mx;
229      NearPointN = -1;
230      int Points = VizMapFrame->GetPoints();
231      for (int PointN = 0; PointN < Points; PointN++) {
232          PVizMapPoint Point = VizMapFrame->GetPoint(PointN);
233          const double PointX = Point->GetPointX(), PointY = Point->GetPointY();
234          const double Dist = TMath::Sqr(PointX - MouseX) + 
235              TMath::Sqr(PointY - MouseY);
236          if (Dist < MnDist) { MnDist = Dist; NearPointN = PointN; }
237      }
238      if (TMath::Sqrt(MnDist) > 0.1) { NearPointN = -1; }
239  }
240  inline double TVizMapContext::GetMapCoord(const int& ScreenCoord, 
241          const int& ScreenLen, const double& MapMn, const double& MapLen) {
242      return MapMn + MapLen*(double(ScreenCoord)/double(ScreenLen));
243  }
244  inline int TVizMapContext::GetScreenCoord(const double& MapCoord, const double& MapMn, 
245          const double& MapLen, const int& ScreenLen) {
246      return TFlt::Round(ScreenLen * ((MapCoord - MapMn)/MapLen));
247  }
248  int TVizMapContext::GetEncoderClsid(const TStr& EncoderType, CLSID* pClsid) {
249      const int StrLen = EncoderType.Len() + 1;
250      WCHAR* format = new WCHAR[StrLen];
251      const int Res = MultiByteToWideChar(CP_ACP, 0, 
252          EncoderType.CStr(), StrLen, format, StrLen);
253      UINT  num = 0;          
254      UINT  size = 0;         
255      Gdiplus::ImageCodecInfo* pImageCodecInfo = NULL;
256      Gdiplus::GetImageEncodersSize(&num, &size);
257      if (size == 0) { return -1; } 
258      pImageCodecInfo = (Gdiplus::ImageCodecInfo*)(malloc(size));
259      if(pImageCodecInfo == NULL) { return -1; } 
260      Gdiplus::GetImageEncoders(num, size, pImageCodecInfo);
261      for(UINT j = 0; j < num; ++j) {
262          if (wcscmp(pImageCodecInfo[j].MimeType, format) == 0) {
263              *pClsid = pImageCodecInfo[j].Clsid;
264              free(pImageCodecInfo);
265              return j;  
266          }    
267      }
268      free(pImageCodecInfo);
269      return -1;  
270  }
271  void TVizMapContext::ResetFrame() {
272      if (VizMapFrame->GetLandscapes() > 0) {
273          SelLandscape = VizMapFrame->GetLandscape(0); 
274          RenderLandscapeBmp();
275      }
276      ResetKeyWd(); SelPointV.Clr();
277  }
278  TVizMapContext::TVizMapContext(PVizMap _VizMap): 
279          VizMap(_VizMap), VizMapFrameN(0),
280          VizMapFrame(_VizMap->GetFirst()), SelMode(vmsmZoom), 
281          MgGlassPoints(0), MouseInP(false), LeftButtonDownP(false), 
282          MgGlassSize(0.2), NearPointN(-1) { 
283      LoadColor();
284      LoadCatFullNms();
285      ResetFrame();
286  }
287  void TVizMapContext::SetVizMapFrame(const int& NewVizMapFrameN) {
288      VizMapFrameN = NewVizMapFrameN;
289      VizMapFrame = VizMap->GetVizMapFrame(VizMapFrameN);
290      ResetFrame();
291  }
292  void TVizMapContext::SaveVrml(const TStr& VrmlFNm, bool ShowPointNmP, bool ShowKeyWdP) {    
293      VizMapFrame->SaveVrml(VrmlFNm, SelLandscape, ShowPointNmP, !ShowPointNmP,  ShowKeyWdP);
294  }
295  void TVizMapContext::PaintEmpty(PGks Gks) {
296      Gks->SetBrush(TGksBrush::New(ColorLandscapeAbove));
297      Gks->FillRect(-1, -1, Gks->GetWidth()+1, Gks->GetHeight()+1);
298  }
299  void TVizMapContext::Paint(PGks Gks, const bool& ShowPointNmP, const int& PointFontSize,
300          const int& PointNmFontScale, const double& PointWgtThreshold, const int& CatId,
301          const bool& ShowCatNmP, const bool& ShowKeyWdP, const int& KeyWdFontSize, 
302          const bool& ShowMgGlassP, const int& LegendGridWidth, const int& LegendGridHeight) {
303      if (!SelLandscape.Empty()) { PaintLandscape(Gks); } 
304      else { PaintEmpty(Gks); }
305      PaintLegendGrid(Gks, LegendGridWidth, LegendGridHeight);
306      PaintLinks(Gks);
307      TVec<TFltRect> PointNmRectV;
308      if (ShowPointNmP) { 
309          PaintPoints(Gks, PointFontSize, PointNmFontScale, 
310              PointWgtThreshold, CatId, ShowMgGlassP, PointNmRectV); 
311      } else { 
312          PaintPoints(Gks, PointFontSize, PointNmFontScale, 
313              TFlt::Mx, CatId, ShowMgGlassP, PointNmRectV); 
314      }
315      if (ShowCatNmP && !SelLandscape.Empty()) { 
316          PaintCatNms(Gks, KeyWdFontSize, PointNmRectV); };
317      if (ShowKeyWdP) { PaintKeyWds(Gks, KeyWdFontSize, PointNmRectV); }
318      if (LeftButtonDownP) { PaintZoomRect(Gks); }
319      else if (MouseInP && ShowMgGlassP) { PaintMgGlass(Gks, KeyWdFontSize); }
320  }
321  void TVizMapContext::PaintLandscape(PGks Gks){
322      Gks->Bitmap(LandscapeBmp, -1, -1, Gks->GetWidth()+1, Gks->GetHeight()+1);
323  }
324  void TVizMapContext::PaintLegendGrid(PGks Gks, 
325          const int& LegendGridWidth, const int& LegendGridHeight) {
326      Gks->SetPen(TGksPen::New(ColorLegendGridColor));
327      for (int LineN = 1; LineN < LegendGridWidth; LineN++) {
328          const double RelativeWidth = double(LineN) / double(LegendGridWidth);
329          const int X = TFlt::Round(RelativeWidth * Gks->GetWidth());
330          Gks->Line(X, -1, X, Gks->GetHeight());
331      }
332      for (int LineN = 1; LineN < LegendGridHeight; LineN++) {
333          const double RelativeHeight = double(LineN) / double(LegendGridHeight);
334          const int Y = TFlt::Round(RelativeHeight * Gks->GetHeight());
335          Gks->Line(-1, Y, Gks->GetWidth(), Y);
336      }
337  }
338  void TVizMapContext::PaintLinks(PGks Gks) {
339      int Links = VizMapFrame->GetLinks();
340      TFltRect ZoomRect = GetZoomRect();
341      for (int LinkN = 0; LinkN < Links; LinkN++) {
342          PVizMapLink Link = VizMapFrame->GetLink(LinkN);
343          PVizMapPoint SrcPoint = VizMapFrame->GetPoint(Link->GetSrcPointN());
344          PVizMapPoint DstPoint = VizMapFrame->GetPoint(Link->GetDstPointN());
345          const double SrcPointX = SrcPoint->GetPointX(), SrcPointY = SrcPoint->GetPointY();
346          const double DstPointX = DstPoint->GetPointX(), DstPointY = DstPoint->GetPointY();
347          const int SrcX = GetScreenCoord(SrcPointX, ZoomRect.GetMnX(), 
348              ZoomRect.GetXLen(), Gks->GetWidth());
349          const int SrcY = GetScreenCoord(SrcPointY, ZoomRect.GetMnY(), 
350              ZoomRect.GetYLen(), Gks->GetHeight());
351          const int DstX = GetScreenCoord(DstPointX, ZoomRect.GetMnX(), 
352              ZoomRect.GetXLen(), Gks->GetWidth());
353          const int DstY = GetScreenCoord(DstPointY, ZoomRect.GetMnY(), 
354              ZoomRect.GetYLen(), Gks->GetHeight());
355          PaintArrow(Gks, SrcX, SrcY, DstX, DstY, 3);
356      }
357  }
358  void TVizMapContext::PaintArrow(PGks Gks, const int& SrcX, const int& SrcY, 
359          const int& DstX, const int& DstY, const int& Width) {
360      Gks->SetPen(TGksPen::New(ColorLink, gpmCopy, gpsSolid, Width));
361      Gks->Line(SrcX, SrcY, DstX, DstY);
<span onclick='openModal()' class='match'>362      TFltV DirectionV = TFltV::GetV(DstX - SrcX, DstY - SrcY); 
363      TLinAlg::Normalize(DirectionV);
364      const int HeadSize = TFlt::Round(2.5*Width); 
365      const double AngleRad = 0.75*TMath::Pi;
366      const int dX1 = TFlt::Round(HeadSize*DirectionV[0]);
367      const int dY1 = TFlt::Round(HeadSize*DirectionV[1]);
368      double dxx, dyy;
</span>369      TLinAlg::Rotate(DirectionV[0], DirectionV[1], AngleRad, dxx, dyy);
370      const int dX2 = TFlt::Round(HeadSize*dxx);
371      const int dY2 = TFlt::Round(HeadSize*dyy);
372      TLinAlg::Rotate(DirectionV[0], DirectionV[1], -AngleRad, dxx, dyy);
373      const int dX3 = TFlt::Round(HeadSize*dxx);
374      const int dY3 = TFlt::Round(HeadSize*dyy);
375      TGksSPointV HeadPointV(3, 0);
376      HeadPointV.Add(TGksSPoint(DstX, DstY));
377      HeadPointV.Add(TGksSPoint(DstX-dX1+dX2, DstY-dY1+dY2));
378      HeadPointV.Add(TGksSPoint(DstX-dX1+dX3, DstY-dY1+dY3)); 
379      Gks->SetBrush(TGksBrush::New(ColorLink));
380      Gks->Polygon(HeadPointV);
381  }
382  void TVizMapContext::PaintPoints(PGks Gks, const int& PointFontSize, 
383          const int& PointNmFontScale, const double& PointWgtThreshold, 
384          const int& CatId, const bool& ShowMgGlassP,
385          TVec<TFltRect>& PointNmRectV) {
386      int Points = VizMapFrame->GetPoints();
387      TFltRect ZoomRect = GetZoomRect();
388      for (int PointN = 0; PointN < Points; PointN++) {
389          PVizMapPoint Point = VizMapFrame->GetPoint(PointN);
390          bool IsSelPointP = SelPointV.IsInBin(PointN);
391          if (IsSelPointP || ((NearPointN == PointN) && !ShowMgGlassP)) { continue; }
392          const double PointX = Point->GetPointX(), PointY = Point->GetPointY();
393          if (ZoomRect.IsXYIn(PointX, PointY)) {
394              const int X = GetScreenCoord(PointX, ZoomRect.GetMnX(), 
395                  ZoomRect.GetXLen(), Gks->GetWidth());
396              const int Y = GetScreenCoord(PointY, ZoomRect.GetMnY(), 
397                  ZoomRect.GetYLen(), Gks->GetHeight());
398              bool IsCatP = Point->IsCatId(CatId);
399              if (Point->IsPointNm() && 
400                  ((Point->GetWgt() > PointWgtThreshold) || IsSelPointP)) {
401                  PointNmRectV.Add(PaintPointNm(Gks, Point, X, Y, 
402                      PointFontSize, PointNmFontScale, IsSelPointP, IsCatP));
403              } else {
404                  PaintPointCross(Gks, X, Y, IsSelPointP, IsCatP);
405              }
406          }
407      }
408      for (int SelPointN = 0; SelPointN < SelPointV.Len(); SelPointN++) {
409          const int PointN = SelPointV[SelPointN];
410          if ((NearPointN == PointN) && !ShowMgGlassP) { continue; }
411          PVizMapPoint Point = VizMapFrame->GetPoint(PointN);
412          const double PointX = Point->GetPointX(), PointY = Point->GetPointY();
413          if (ZoomRect.IsXYIn(PointX, PointY)) {
414              const int X = GetScreenCoord(PointX, ZoomRect.GetMnX(), 
415                  ZoomRect.GetXLen(), Gks->GetWidth());
416              const int Y = GetScreenCoord(PointY, ZoomRect.GetMnY(), 
417                  ZoomRect.GetYLen(), Gks->GetHeight());
418              bool IsCatP = Point->IsCatId(CatId);
419              if (Point->IsPointNm()) {
420                  PointNmRectV.Add(PaintPointNm(Gks, Point, X, Y, 
421                      PointFontSize, PointNmFontScale, true, IsCatP));
422              } else {
423                  PaintPointCross(Gks, X, Y, true, IsCatP);
424              }
425          }
426      }
427      if (!ShowMgGlassP && (NearPointN != -1)) {
428          PVizMapPoint Point = VizMapFrame->GetPoint(NearPointN);
429          const double PointX = Point->GetPointX(), PointY = Point->GetPointY();
430          if (ZoomRect.IsXYIn(PointX, PointY)) {
431              const int X = GetScreenCoord(PointX, ZoomRect.GetMnX(), 
432                  ZoomRect.GetXLen(), Gks->GetWidth());
433              const int Y = GetScreenCoord(PointY, ZoomRect.GetMnY(), 
434                  ZoomRect.GetYLen(), Gks->GetHeight());
435              bool IsCatP = Point->IsCatId(CatId);
436              bool IsSelPointP = SelPointV.IsInBin(NearPointN);
437              if (Point->IsPointNm()) {
438                  PointNmRectV.Add(PaintPointNm(Gks, Point, X, Y, 
439                      PointFontSize, PointNmFontScale, IsSelPointP, IsCatP));
440              } else {
441                  PaintPointCross(Gks, X, Y, IsSelPointP, IsCatP);
442              }
443          }
444      }
445  }
446  void TVizMapContext::PaintPointCross(PGks Gks, const int& X, 
447          const int& Y, const bool& SelPointP, const bool& IsCatP) {
448      Gks->SetPen(TGksPen::New(SelPointP ? ColorSelPointCross : ColorPointCross));
449      Gks->Line(X - SizePointCross, Y - SizePointCross, 
450                X + SizePointCross, Y + SizePointCross);
451      Gks->Line(X - SizePointCross, Y + SizePointCross, 
452                X + SizePointCross, Y - SizePointCross);
453      if (IsCatP) {
454          Gks->Line(X - SizePointCross + 1, Y - SizePointCross, 
455                    X + SizePointCross + 1, Y + SizePointCross);
456          Gks->Line(X - SizePointCross + 1, Y + SizePointCross, 
457                    X + SizePointCross + 1, Y - SizePointCross);
458      }
459  }
460  TFltRect TVizMapContext::PaintPointNm(PGks Gks, PVizMapPoint Point, const int& X, 
461          const int& Y, const int& PointFontSize, const int& PointNmFontScale, 
462          const bool& SelPointP, const bool& IsCatP) {
463      TStr PointNm = Point->GetPointNm(); 
464      PointNm.ChangeChAll('_', ' ');
465      if (PointNm.IsStrIn("[[")) {
466          const int StartPos = PointNm.SearchStr("[[");
467          PointNm = PointNm.Left(StartPos - 1);
468      }
469      TGksColor FontColor = SelPointP ? ColorSelPointFont : ColorPointFont;
470      const int FontSize = PointFontSize + TFlt::Round(Point->GetWgt()*PointNmFontScale);
471      Gks->SetFont(TGksFont::New("ARIAL", FontSize, FontColor));
472      TStr ScreenPointNm = Gks->BreakTxt(PointNm, " ", "", PointNmWidth, PointNmMxLines);
473      const int HalfTxtWidth = Gks->GetTxtWidth(ScreenPointNm) / 2;
474      const int HalfTxtHeight = Gks->GetTxtHeight(ScreenPointNm) / 2;
475      const int MnX = X - HalfTxtWidth;
476      int CurrY = Y - HalfTxtHeight;
477      TStrV LineV; ScreenPointNm.SplitOnAllCh('\n', LineV);
478      for (int LineN = 0; LineN < LineV.Len(); LineN++) {
479          const int HalfLineWidth = Gks->GetTxtWidth(LineV[LineN]) / 2;
480          const int LineHeight = Gks->GetTxtHeight(LineV[LineN]);
481          Gks->PutTxt(LineV[LineN], MnX + (HalfTxtWidth - HalfLineWidth), CurrY);
482          CurrY += LineHeight-3;
483      }
484      return TFltRect(X - HalfTxtWidth, Y - HalfTxtHeight,
485          X + HalfTxtWidth, Y + HalfTxtHeight - LineV.Len()*3);
486  }
487  void TVizMapContext::PaintCatNms(PGks Gks, const int& KeyWdFontSize, 
488          TVec<TFltRect>& PointNmRectV) {
489      TIntH CatH; TIntFltPrH CatPosH;
490      PBowDocBs BowDocBs = VizMapFrame->GetKeyWdBow();
491      const int Points = VizMapFrame->GetPoints();
492      for (int PointN = 0; PointN < Points; PointN++) {
493          PVizMapPoint Point = VizMapFrame->GetPoint(PointN);
494          const int DId = Point->GetDocId();
495          const int CIds = BowDocBs->GetDocCIds(DId);
496          for (int CIdN = 0; CIdN < CIds; CIdN++) {
497              const int CId = BowDocBs->GetDocCId(DId, CIdN);
498              CatH.AddDat(CId)++;
499              CatPosH.AddDat(CId).Val1 += Point->GetPointX();
500              CatPosH.AddDat(CId).Val2 += Point->GetPointY();
501          }
502      }
503      CatH.SortByDat(false); 
504      const int TopCats = Points > 100 ? 6 : 4; 
505      TFltRect ZoomRect = GetZoomRect();    
506      Gks->SetFont(TGksFont::New("ARIAL", KeyWdFontSize + 3, ColorCatNmFont));
507      TVec<TFltRect> CatNmRectV; TVec<TFltV> CatNmPosV;
508      const int MnSize = TInt::GetMn(Gks->GetWidth(), Gks->GetHeight());
509      const int MnDist = TFlt::Round(0.3 * double(MnSize));
510      int Cats = 0, CatKeyId = CatH.FFirstKeyId();
511      while (CatH.FNextKeyId(CatKeyId)) {
512          if (Cats == TopCats) { break; } 
513          if (double(CatH[CatKeyId]) / double(Points) < 0.05) { break; } 
514          const int CId = CatH.GetKey(CatKeyId);
515          TStr CatNm = BowDocBs->GetCatNm(CId);
516          if (CatFullNmH.IsKey(CatNm)) {
517              CatNm = CatFullNmH.GetDat(CatNm);
518          } else { continue; }
519          TFltPr CatPos = CatPosH.GetDat(CId);
520          const int CatCount = CatH.GetDat(CId); IAssert(CatCount > 0);
521          const double CatX = CatPos.Val1 / double(CatCount);
522          const double CatY = CatPos.Val2 / double(CatCount);
523          if (!ZoomRect.IsXYIn(CatX, CatY)) { continue; }
524          const int HalfTxtWidth = Gks->GetTxtWidth(CatNm) / 2;
525          const int HalfTxtHeight = Gks->GetTxtHeight(CatNm) / 2;
526          const int X = GetScreenCoord(CatX , ZoomRect.GetMnX(), 
527              ZoomRect.GetXLen(), Gks->GetWidth());
528          const int Y = GetScreenCoord(CatY, ZoomRect.GetMnY(), 
529              ZoomRect.GetYLen(), Gks->GetHeight());
530          int CatNmDist = MnSize; TFltV CatNmPos = TFltV::GetV(double(X), double(Y));
531          for (int CatNmPosN = 0; CatNmPosN < CatNmPosV.Len(); CatNmPosN++) {
532              const double Dist = TLinAlg::EuclDist(CatNmPosV[CatNmPosN], CatNmPos);
533              CatNmDist = TInt::GetMn(TFlt::Round(Dist), CatNmDist);
534          }
535          if (CatNmDist < MnDist) { continue; }
536          TFltRect CatNmRect(X - HalfTxtWidth, Y - HalfTxtHeight,
537              X + HalfTxtWidth, Y + HalfTxtHeight);
538          bool DoDraw = true; const int Rects = CatNmRectV.Len();
539          for (int RectN = 0; (RectN < Rects) && DoDraw; RectN++) {
540              DoDraw = !TFltRect::Intersection(CatNmRect, CatNmRectV[RectN]); }
541          if (!DoDraw) { continue; }
542          Gks->PutTxt(CatNm, X - HalfTxtWidth, Y - HalfTxtHeight); 
543          CatNmRectV.Add(CatNmRect); Cats++;
544          CatNmPosV.Add(CatNmPos);
545      }
546      PointNmRectV.AddV(CatNmRectV);
547  }
548  void TVizMapContext::PaintKeyWds(PGks Gks, const int& KeyWdFontSize, 
549          TVec<TFltRect>& PointNmRectV) {
550      Gks->SetFont(TGksFont::New("ARIAL", KeyWdFontSize, ColorKeyWdFont));
551      TFltRect ZoomRect = GetZoomRect();    
552      const double MnZoomRectSize = TFlt::GetMn(ZoomRect.GetXLen(), ZoomRect.GetYLen());
553      const double MnRptDist = RelMnRptDist * MnZoomRectSize;
554      const double Sparsity = RelSparsity * MnZoomRectSize;
555      TVizMapKeyWdV OkKeyWdV;
556      int KeyWds = VizMapFrame->GetKeyWds();
557      for (int KeyWdN = 0; KeyWdN < KeyWds; KeyWdN++) {
558          PVizMapKeyWd KeyWd = VizMapFrame->GetKeyWd(KeyWdN);
559          TStr KeyWdStr = KeyWd->GetKeyWdStr().GetLc();
560          const double KeyWdX = KeyWd->GetKeyWdX();
561          const double KeyWdY = KeyWd->GetKeyWdY();
562          if (ZoomRect.IsXYIn(KeyWdX, KeyWdY)) {
563              const int X = GetScreenCoord(KeyWdX, ZoomRect.GetMnX(), 
564                  ZoomRect.GetXLen(), Gks->GetWidth());
565              const int Y = GetScreenCoord(KeyWdY, ZoomRect.GetMnY(), 
566                  ZoomRect.GetYLen(), Gks->GetHeight());
567              const int HalfTxtWidth = Gks->GetTxtWidth(KeyWdStr) / 2;
568              const int HalfTxtHeight = Gks->GetTxtHeight(KeyWdStr) / 2;
569              TFltRect KeyWdRect(X - HalfTxtWidth, Y - HalfTxtHeight,
570                  X + HalfTxtWidth, Y + HalfTxtHeight);
571              bool DoDrawP = true; const int Rects = PointNmRectV.Len();
572              for (int RectN = 0; RectN < Rects; RectN++) {
573                  if (TFltRect::Intersection(KeyWdRect, PointNmRectV[RectN])) { 
574                      DoDrawP = false; break; }
575              }
576              if (!DoDrawP) { continue; } 
577              TFltV KeyWdCoodV = TFltV::GetV(KeyWdX, KeyWdY);
578              const int OkKeyWds = OkKeyWdV.Len(); bool KeyWdOkP = true;
579              for (int OkKeyWdN = 0; OkKeyWdN < OkKeyWds; OkKeyWdN++) {
580                  PVizMapKeyWd OkKeyWd = OkKeyWdV[OkKeyWdN];
581                  TStr OkKeyWdStr = OkKeyWd->GetKeyWdStr().GetLc();
582                  const double Dist = TLinAlg::EuclDist(KeyWdCoodV, OkKeyWd->GetCoordV());
583                  if (Dist < Sparsity) { KeyWdOkP = false; break; }
584                  if (OkKeyWdStr == KeyWdStr) {
585                      if (Dist < MnRptDist) { KeyWdOkP = false; break; }
586                  }
587              }
588              if (!KeyWdOkP) { continue; } 
589              Gks->PutTxt(KeyWdStr, X - HalfTxtWidth, Y - HalfTxtHeight); 
590              PointNmRectV.Add(KeyWdRect); OkKeyWdV.Add(KeyWd);
591          }
592      }
593  }
594  void TVizMapContext::PaintZoomRect(PGks Gks) {
595      Gks->SetPen(TGksPen::New(ColorZoomRect, gpmCopy, gpsSolid, 2));
596      Gks->FrameRect(DownX, DownY, ScreenX, ScreenY);
597  }
598  void TVizMapContext::PaintMgGlass(PGks Gks, const int& KeyWdFontSize) {
599      TFltRect ZoomRect = GetZoomRect();
600      int SizeX = TFlt::Round((MgGlassSize/ZoomRect.GetXLen()) * Gks->GetWidth());
601      int SizeY = TFlt::Round((MgGlassSize/ZoomRect.GetYLen()) * Gks->GetHeight());
602      Gks->SetBrush(TGksBrush::New(ColorMgGlass));
603      Gks->FillEllipse(ScreenX-SizeX, ScreenY-SizeY, ScreenX+SizeX, ScreenY+SizeY);
604      if (MgGlassKeyWdV.Len() > 0) {
605          Gks->SetFont(TGksFont::New("ARIAL", KeyWdFontSize, TGksColor::GetBlack(), TFSet()|gfsBold));
606          TStr KeyWdStr = Gks->BreakTxt(MgGlassKeyWdV, ", ", ",", MgGlassWindowWidth);       
607          TStr NearPointStr;
608          if (NearPointN != -1) {
609              PVizMapPoint NearPoint = VizMapFrame->GetPoint(NearPointN);
610              if (NearPoint->IsPointNm()) {
611                  TStr NearPointNm = NearPoint->GetPointNm();
612                  if (NearPointNm.IsStrIn("[[")) {
613                      const int StartPos = NearPointNm.SearchStr("[[");
614                      NearPointNm = NearPointNm.Left(StartPos - 1);
615                  }
616                  NearPointStr = Gks->BreakTxt(NearPointNm, 
617                      " ", "", MgGlassWindowWidth, 1);
618                  NearPointStr.DelChAll('\n');
619                  NearPointStr += "\n";
620              }
621          }
622          TStr DocCountStr = "#documents = " + MgGlassPoints.GetStr() + "\n";
623          KeyWdStr = NearPointStr + DocCountStr + KeyWdStr;
624          int WndWidth = Gks->GetTxtWidth(KeyWdStr) + 6;
625          int WndHeight = Gks->GetTxtHeight(KeyWdStr) + 6;
626          int PosX = ScreenX + 20, PosY = ScreenY + 20;
627          if (PosX + WndWidth > Gks->GetWidth()) {
628              PosX = ScreenX - 20 - WndWidth; }
629          if (PosY + WndHeight > Gks->GetHeight()) {
630              PosY = ScreenY - 20 - WndHeight; }
631          Gks->SetBrush(TGksBrush::New(ColorMgGlassWndShadow));
632          Gks->FillRect(PosX + 5, PosY + 5, 
633              PosX + WndWidth + 5, PosY + WndHeight + 5);
634          Gks->SetBrush(TGksBrush::New(ColorMgGlassWnd));
635          Gks->SetPen(TGksPen::New(ColorMgGlassWndFrm));
636          Gks->Rectangle(PosX, PosY, 
637              PosX + WndWidth, PosY + WndHeight);
638          Gks->PutTxt(KeyWdStr, PosX+3, PosY+3);
639      }
640  }
641  void TVizMapContext::Export(const TStr& FNm, const TStr& EncoderType, const int& Width, 
642          const int& Height, const bool& ShowPointNmP, const int& PointFontSize, 
643          const int& PointNmFontScale, const double& PointWgtThreshold, const bool& ShowCatNmP,
644          const bool& ShowKeyWdP, const int& KeyWdFontSize, const bool& ShowMgGlassP, 
645          const int& LegendGridWidth, const int& LegendGridHeight) {
646      Gdiplus::Bitmap* Bmp = new Gdiplus::Bitmap(Width, Height);
647      Gdiplus::Graphics* g = Gdiplus::Graphics::FromImage(Bmp);
648      PGks BmpGks = TWfGks::New();
649      HDC HdcHandle = g->GetHDC(); BmpGks->BeginPaint(HdcHandle);
650      Paint(BmpGks, ShowPointNmP, PointFontSize, PointNmFontScale,
651          PointWgtThreshold, -1, ShowCatNmP, ShowKeyWdP, KeyWdFontSize, ShowMgGlassP, 
652          LegendGridWidth, LegendGridHeight);
653      BmpGks->EndPaint(); g->ReleaseHDC(HdcHandle);
654      WCHAR* FNmWChar = new WCHAR[FNm.Len() + 1];
655      const int Res = MultiByteToWideChar(CP_ACP, 0, 
656          FNm.CStr(), FNm.Len() + 1, FNmWChar, FNm.Len() + 1);
657      CLSID pngClsid; GetEncoderClsid(EncoderType, &pngClsid);
658      Bmp->Save(FNmWChar, &pngClsid, NULL);
659      delete FNmWChar; delete Bmp; delete g;
660  }
661  bool TVizMapContext::MouseMove(const int& X, const int& Y, 
662          const int& Width, const int& Height, const int& MgGlassKeyWds) {
663      const int MoveDiff = TInt::Abs(X - ScreenX) + TInt::Abs(Y - ScreenY);
664      ScreenX = X; ScreenY = Y;
665      TFltRect ZoomRect = GetZoomRect();
666      MouseX = GetMapCoord(X, Width, ZoomRect.GetMnX(), ZoomRect.GetXLen());
667      MouseY = GetMapCoord(Y, Height, ZoomRect.GetMnY(), ZoomRect.GetYLen());
668      if (!LeftButtonDownP && (MoveDiff > 0)) { 
669          ResetMgGlassKeyWd(MgGlassKeyWds);
670          ResetNearPointN();
671      }
672      return (MoveDiff > 0);
673  }
674  void TVizMapContext::MouseLeftDown(const int& X, 
675          const int& Y, const int& Width, const int& Height) {
676      LeftButtonDownP = true;
677      DownX = X; DownY = Y;
678  }
679  void TVizMapContext::MouseLeftUp(const int& X, 
680          const int& Y, const int& Width, const int& Height) {
681      LeftButtonDownP = false;
682      TFltRect ZoomRect = GetZoomRect();
683      MouseX = GetMapCoord(X, Width, ZoomRect.GetMnX(), ZoomRect.GetXLen());
684      MouseY = GetMapCoord(Y, Height, ZoomRect.GetMnY(), ZoomRect.GetYLen());
685      if (TInt::Abs(DownX - X) > 10 && TInt::Abs(DownY - Y) > 10) {
686          const double StartX = GetMapCoord(DownX, Width, ZoomRect.GetMnX(), ZoomRect.GetXLen());
687          const double StartY = GetMapCoord(DownY, Height, ZoomRect.GetMnY(), ZoomRect.GetYLen());
688          if (IsZoomMode()) { 
689              ZoomIn(StartX, StartY, MouseX, MouseY); 
690          } else if (IsSelectMode()) {
691              Select(StartX, StartY, MouseX, MouseY);
692          }
693      } else {
694          SelectDoc(MouseX, MouseY);
695      }
696  }
697  void TVizMapContext::MouseWheel(const int& Degree, const int& MgGlassKeyWds) { 
698      MgGlassSize *= pow(TMath::E / 2, Degree); 
699      if (!LeftButtonDownP) { ResetMgGlassKeyWd(MgGlassKeyWds); }
700  }
701  void TVizMapContext::ZoomIn(const double& X1, const double& Y1, const double& X2, const double& Y2) { 
702      ZoomIn(TFltRect(TFlt::GetMn(X1, X2), TFlt::GetMn(Y1, Y2),
703                      TFlt::GetMx(X1, X2), TFlt::GetMx(Y1, Y2))); 
704  }
705  void TVizMapContext::ZoomIn(const TFltRect& ZoomInRect) { 
706      ZoomS.Push(ZoomInRect); 
707      RenderLandscapeBmp();
708      ResetMgGlassSize();
709      ResetKeyWd();
710  }
711  bool TVizMapContext::ZoomOut() { 
712      if (!ZoomS.Empty()) { 
713          ZoomS.Pop(); 
714          RenderLandscapeBmp(); 
715          ResetMgGlassSize();
716          ResetKeyWd();
717          return true;
718      } 
719      return false;
720  }
721  bool TVizMapContext::ZoomAll() { 
722      if (!ZoomS.Empty()) { 
723          ZoomS.Clr(); 
724          RenderLandscapeBmp(); 
725          ResetMgGlassSize();
726          ResetKeyWd();
727          return true;
728      }
729      return false;
730  }
731  void TVizMapContext::Select(const double& X1, const double& Y1, const double& X2, const double& Y2) {
732      Select(TFltRect(TFlt::GetMn(X1, X2), TFlt::GetMn(Y1, Y2),
733                      TFlt::GetMx(X1, X2), TFlt::GetMx(Y1, Y2)));
734  }
735  void TVizMapContext::Select(const TFltRect& SelRect) {
736      TIntV NewSelPointV; 
737      if (VizMapFrame->GetRectPointV(SelRect, NewSelPointV) > 0) {
738          SelPointV.Union(NewSelPointV);
739      }
740  }
741  void TVizMapContext::Select(const int& DocId) {
742      SelPointV.Clr();
743      int Points = VizMapFrame->GetPoints();
744      for (int PointN = 0; PointN < Points; PointN++) {
745          PVizMapPoint Point = VizMapFrame->GetPoint(PointN);
746          if (Point->IsDocId() && Point->GetDocId() == DocId) {
747              SelPointV.Add(PointN); break;
748          }
749      }
750      if (SelPointV.Empty()) {
751          const int Frames = VizMap->GetVizMapFrames();
752          for (int FrameN = 0; FrameN < Frames; FrameN++) {
753              if (FrameN == VizMapFrameN) { continue; }
754              PVizMapFrame OtherFrame = VizMap->GetVizMapFrame(FrameN);
755              int Points = OtherFrame->GetPoints();
756              for (int PointN = 0; PointN < Points; PointN++) {
757                  PVizMapPoint Point = OtherFrame->GetPoint(PointN);
758                  if (Point->IsDocId() && Point->GetDocId() == DocId) {
759                      SelPointV.Add(PointN); SetVizMapFrame(FrameN); break;
760                  }
761              }
762          }
763      }
764  }
765  void TVizMapContext::GetSelectDIdV(TIntV& DIdV) {
766      DIdV.Gen(SelPointV.Len(), 0);
767      const int SelPoints = SelPointV.Len();
768      for (int SelPointN = 0; SelPointN < SelPoints; SelPointN++) {
769          DIdV.Add(VizMapFrame->GetPoint(SelPointV[SelPointN])->GetDocId());
770      }
771  }
772  void TVizMapContext::UnselectAll() {
773      SelPointV.Clr();
774  }
775  void TVizMapContext::SelectDoc(const double& DocX, const double& DocY) {
776      const int PointN = VizMapFrame->GetPointN(TFltV::GetV(DocX, DocY), 1.5);
777      if (IsZoomMode()) { 
778          if (PointN != -1) { 
779              SelPointV = TIntV::GetV(PointN); 
780          } else { 
781              SelPointV.Clr(); 
782          }
783      } else if (IsSelectMode()) {
784          if (PointN != -1) { 
785              if (SelPointV.IsInBin(PointN)) {
786                  SelPointV.DelIfIn(PointN);
787              } else {
788                  SelPointV.AddSorted(PointN); 
789              }
790          }
791      }
792  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-reshape_layer.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-vizmapgks.cpp</div>
                </div>
                <div class="column column_space"><pre><code>157      vector<int> top_shape = top[0]->shape();
158      const int tn = top_shape[0];    
159      const int tc = top_shape[1];
160      const int th = top_shape[2];
161      const int tw = top_shape[3];
162      vector<int> bottom_shape = bottom[0]->shape();
</pre></code></div>
                <div class="column column_space"><pre><code>362      TFltV DirectionV = TFltV::GetV(DstX - SrcX, DstY - SrcY); 
363      TLinAlg::Normalize(DirectionV);
364      const int HeadSize = TFlt::Round(2.5*Width); 
365      const double AngleRad = 0.75*TMath::Pi;
366      const int dX1 = TFlt::Round(HeadSize*DirectionV[0]);
367      const int dY1 = TFlt::Round(HeadSize*DirectionV[1]);
368      double dxx, dyy;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    