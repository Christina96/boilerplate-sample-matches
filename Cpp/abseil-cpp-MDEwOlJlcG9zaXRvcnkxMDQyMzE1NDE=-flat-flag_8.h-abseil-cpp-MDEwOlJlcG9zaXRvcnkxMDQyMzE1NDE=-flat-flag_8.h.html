
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 23, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-flag_8.h</h3>
            <pre><code>1  #ifndef ABSL_FLAGS_INTERNAL_FLAG_H_
2  #define ABSL_FLAGS_INTERNAL_FLAG_H_
3  #include <stddef.h>
4  #include <stdint.h>
5  #include <atomic>
6  #include <cstring>
7  #include <memory>
8  #include <new>
9  #include <string>
10  #include <type_traits>
11  #include <typeinfo>
12  #include "absl/base/attributes.h"
13  #include "absl/base/call_once.h"
14  #include "absl/base/casts.h"
15  #include "absl/base/config.h"
16  #include "absl/base/optimization.h"
17  #include "absl/base/thread_annotations.h"
18  #include "absl/flags/commandlineflag.h"
19  #include "absl/flags/config.h"
20  #include "absl/flags/internal/commandlineflag.h"
21  #include "absl/flags/internal/registry.h"
22  #include "absl/flags/internal/sequence_lock.h"
23  #include "absl/flags/marshalling.h"
24  #include "absl/meta/type_traits.h"
25  #include "absl/strings/string_view.h"
26  #include "absl/synchronization/mutex.h"
27  #include "absl/utility/utility.h"
28  namespace absl {
29  ABSL_NAMESPACE_BEGIN
30  namespace flags_internal {
31  template <typename T>
32  class Flag;
33  }  
34  #if defined(_MSC_VER) && !defined(__clang__)
35  template <typename T>
36  class Flag;
37  #else
38  template <typename T>
39  using Flag = flags_internal::Flag<T>;
40  #endif
41  template <typename T>
42  ABSL_MUST_USE_RESULT T GetFlag(const absl::Flag<T>& flag);
43  template <typename T>
44  void SetFlag(absl::Flag<T>* flag, const T& v);
45  template <typename T, typename V>
46  void SetFlag(absl::Flag<T>* flag, const V& v);
47  template <typename U>
48  const CommandLineFlag& GetFlagReflectionHandle(const absl::Flag<U>& f);
49  namespace flags_internal {
50  enum class FlagOp {
51    kAlloc,
52    kDelete,
53    kCopy,
54    kCopyConstruct,
55    kSizeof,
56    kFastTypeId,
57    kRuntimeTypeId,
58    kParse,
59    kUnparse,
60    kValueOffset,
61  };
62  using FlagOpFn = void* (*)(FlagOp, const void*, void*, void*);
63  template <typename T>
64  void* FlagOps(FlagOp op, const void* v1, void* v2, void* v3);
65  inline void* Alloc(FlagOpFn op) {
66    return op(FlagOp::kAlloc, nullptr, nullptr, nullptr);
67  }
68  inline void Delete(FlagOpFn op, void* obj) {
69    op(FlagOp::kDelete, nullptr, obj, nullptr);
70  }
71  inline void Copy(FlagOpFn op, const void* src, void* dst) {
72    op(FlagOp::kCopy, src, dst, nullptr);
73  }
74  inline void CopyConstruct(FlagOpFn op, const void* src, void* dst) {
75    op(FlagOp::kCopyConstruct, src, dst, nullptr);
76  }
77  inline void* Clone(FlagOpFn op, const void* obj) {
78    void* res = flags_internal::Alloc(op);
79    flags_internal::CopyConstruct(op, obj, res);
80    return res;
81  }
82  inline bool Parse(FlagOpFn op, absl::string_view text, void* dst,
83                    std::string* error) {
84    return op(FlagOp::kParse, &text, dst, error) != nullptr;
85  }
86  inline std::string Unparse(FlagOpFn op, const void* val) {
87    std::string result;
88    op(FlagOp::kUnparse, val, &result, nullptr);
89    return result;
90  }
91  inline size_t Sizeof(FlagOpFn op) {
92    return static_cast<size_t>(reinterpret_cast<intptr_t>(
93        op(FlagOp::kSizeof, nullptr, nullptr, nullptr)));
94  }
95  inline FlagFastTypeId FastTypeId(FlagOpFn op) {
96    return reinterpret_cast<FlagFastTypeId>(
97        op(FlagOp::kFastTypeId, nullptr, nullptr, nullptr));
98  }
99  inline const std::type_info* RuntimeTypeId(FlagOpFn op) {
100    return reinterpret_cast<const std::type_info*>(
101        op(FlagOp::kRuntimeTypeId, nullptr, nullptr, nullptr));
102  }
103  inline ptrdiff_t ValueOffset(FlagOpFn op) {
104    return static_cast<ptrdiff_t>(reinterpret_cast<intptr_t>(
105        op(FlagOp::kValueOffset, nullptr, nullptr, nullptr)));
106  }
107  template <typename T>
108  inline const std::type_info* GenRuntimeTypeId() {
109  #ifdef ABSL_INTERNAL_HAS_RTTI
110    return &typeid(T);
111  #else
112    return nullptr;
113  #endif
114  }
115  using HelpGenFunc = std::string (*)();
116  template <size_t N>
117  struct FixedCharArray {
118    char value[N];
119    template <size_t... I>
120    static constexpr FixedCharArray<N> FromLiteralString(
121        absl::string_view str, absl::index_sequence<I...>) {
122      return (void)str, FixedCharArray<N>({{str[I]..., '\0'}});
123    }
124  };
125  template <typename Gen, size_t N = Gen::Value().size()>
126  constexpr FixedCharArray<N + 1> HelpStringAsArray(int) {
127    return FixedCharArray<N + 1>::FromLiteralString(
128        Gen::Value(), absl::make_index_sequence<N>{});
129  }
130  template <typename Gen>
131  constexpr std::false_type HelpStringAsArray(char) {
132    return std::false_type{};
133  }
134  union FlagHelpMsg {
135    constexpr explicit FlagHelpMsg(const char* help_msg) : literal(help_msg) {}
136    constexpr explicit FlagHelpMsg(HelpGenFunc help_gen) : gen_func(help_gen) {}
137    const char* literal;
138    HelpGenFunc gen_func;
139  };
140  enum class FlagHelpKind : uint8_t { kLiteral = 0, kGenFunc = 1 };
141  struct FlagHelpArg {
142    FlagHelpMsg source;
143    FlagHelpKind kind;
144  };
145  extern const char kStrippedFlagHelp[];
146  template <typename Gen, size_t N>
147  constexpr FlagHelpArg HelpArg(const FixedCharArray<N>& value) {
148    return {FlagHelpMsg(value.value), FlagHelpKind::kLiteral};
149  }
150  template <typename Gen>
151  constexpr FlagHelpArg HelpArg(std::false_type) {
152    return {FlagHelpMsg(&Gen::NonConst), FlagHelpKind::kGenFunc};
153  }
154  using FlagDfltGenFunc = void (*)(void*);
155  union FlagDefaultSrc {
156    constexpr explicit FlagDefaultSrc(FlagDfltGenFunc gen_func_arg)
157        : gen_func(gen_func_arg) {}
158  #define ABSL_FLAGS_INTERNAL_DFLT_FOR_TYPE(T, name) \
159    T name##_value;                                  \
160    constexpr explicit FlagDefaultSrc(T value) : name##_value(value) {}  
161    ABSL_FLAGS_INTERNAL_BUILTIN_TYPES(ABSL_FLAGS_INTERNAL_DFLT_FOR_TYPE)
162  #undef ABSL_FLAGS_INTERNAL_DFLT_FOR_TYPE
163    void* dynamic_value;
164    FlagDfltGenFunc gen_func;
165  };
166  enum class FlagDefaultKind : uint8_t {
167    kDynamicValue = 0,
168    kGenFunc = 1,
169    kOneWord = 2  
170  };
171  struct FlagDefaultArg {
172    FlagDefaultSrc source;
173    FlagDefaultKind kind;
174  };
175  struct EmptyBraces {};
176  template <typename T>
177  constexpr T InitDefaultValue(T t) {
178    return t;
179  }
180  template <typename T>
181  constexpr T InitDefaultValue(EmptyBraces) {
182    return T{};
183  }
184  template <typename ValueT, typename GenT,
185            typename std::enable_if<std::is_integral<ValueT>::value, int>::type =
186                ((void)GenT{}, 0)>
187  constexpr FlagDefaultArg DefaultArg(int) {
188    return {FlagDefaultSrc(GenT{}.value), FlagDefaultKind::kOneWord};
189  }
190  template <typename ValueT, typename GenT>
191  constexpr FlagDefaultArg DefaultArg(char) {
192    return {FlagDefaultSrc(&GenT::Gen), FlagDefaultKind::kGenFunc};
193  }
194  constexpr int64_t UninitializedFlagValue() {
195    return static_cast<int64_t>(0xababababababababll);
196  }
<span onclick='openModal()' class='match'>197  template <typename T>
198  using FlagUseValueAndInitBitStorage =
199      std::integral_constant<bool, std::is_trivially_copyable<T>::value &&
200                                       std::is_default_constructible<T>::value &&
</span>201                                       (sizeof(T) < 8)>;
202  template <typename T>
203  using FlagUseOneWordStorage =
204      std::integral_constant<bool, std::is_trivially_copyable<T>::value &&
205                                       (sizeof(T) <= 8)>;
206  template <class T>
207  using FlagUseSequenceLockStorage =
208      std::integral_constant<bool, std::is_trivially_copyable<T>::value &&
209                                       (sizeof(T) > 8)>;
210  enum class FlagValueStorageKind : uint8_t {
211    kValueAndInitBit = 0,
212    kOneWordAtomic = 1,
213    kSequenceLocked = 2,
214    kAlignedBuffer = 3,
215  };
216  template <typename T>
217  static constexpr FlagValueStorageKind StorageKind() {
218    return FlagUseValueAndInitBitStorage<T>::value
219               ? FlagValueStorageKind::kValueAndInitBit
220           : FlagUseOneWordStorage<T>::value
221               ? FlagValueStorageKind::kOneWordAtomic
222           : FlagUseSequenceLockStorage<T>::value
223               ? FlagValueStorageKind::kSequenceLocked
224               : FlagValueStorageKind::kAlignedBuffer;
225  }
226  struct FlagOneWordValue {
227    constexpr explicit FlagOneWordValue(int64_t v) : value(v) {}
228    std::atomic<int64_t> value;
229  };
230  template <typename T>
231  struct alignas(8) FlagValueAndInitBit {
232    T value;
233    uint8_t init;
234  };
235  template <typename T,
236            FlagValueStorageKind Kind = flags_internal::StorageKind<T>()>
237  struct FlagValue;
238  template <typename T>
239  struct FlagValue<T, FlagValueStorageKind::kValueAndInitBit> : FlagOneWordValue {
240    constexpr FlagValue() : FlagOneWordValue(0) {}
241    bool Get(const SequenceLock&, T& dst) const {
242      int64_t storage = value.load(std::memory_order_acquire);
243      if (ABSL_PREDICT_FALSE(storage == 0)) {
244        return false;
245      }
246      dst = absl::bit_cast<FlagValueAndInitBit<T>>(storage).value;
247      return true;
248    }
249  };
250  template <typename T>
251  struct FlagValue<T, FlagValueStorageKind::kOneWordAtomic> : FlagOneWordValue {
252    constexpr FlagValue() : FlagOneWordValue(UninitializedFlagValue()) {}
253    bool Get(const SequenceLock&, T& dst) const {
254      int64_t one_word_val = value.load(std::memory_order_acquire);
255      if (ABSL_PREDICT_FALSE(one_word_val == UninitializedFlagValue())) {
256        return false;
257      }
258      std::memcpy(&dst, static_cast<const void*>(&one_word_val), sizeof(T));
259      return true;
260    }
261  };
262  template <typename T>
263  struct FlagValue<T, FlagValueStorageKind::kSequenceLocked> {
264    bool Get(const SequenceLock& lock, T& dst) const {
265      return lock.TryRead(&dst, value_words, sizeof(T));
266    }
267    static constexpr int kNumWords =
268        flags_internal::AlignUp(sizeof(T), sizeof(uint64_t)) / sizeof(uint64_t);
269    alignas(T) alignas(
270        std::atomic<uint64_t>) std::atomic<uint64_t> value_words[kNumWords];
271  };
272  template <typename T>
273  struct FlagValue<T, FlagValueStorageKind::kAlignedBuffer> {
274    bool Get(const SequenceLock&, T&) const { return false; }
275    alignas(T) char value[sizeof(T)];
276  };
277  using FlagCallbackFunc = void (*)();
278  struct FlagCallback {
279    FlagCallbackFunc func;
280    absl::Mutex guard;  
281  };
282  struct DynValueDeleter {
283    explicit DynValueDeleter(FlagOpFn op_arg = nullptr);
284    void operator()(void* ptr) const;
285    FlagOpFn op;
286  };
287  class FlagState;
288  class FlagImpl final : public CommandLineFlag {
289   public:
290    constexpr FlagImpl(const char* name, const char* filename, FlagOpFn op,
291                       FlagHelpArg help, FlagValueStorageKind value_kind,
292                       FlagDefaultArg default_arg)
293        : name_(name),
294          filename_(filename),
295          op_(op),
296          help_(help.source),
297          help_source_kind_(static_cast<uint8_t>(help.kind)),
298          value_storage_kind_(static_cast<uint8_t>(value_kind)),
299          def_kind_(static_cast<uint8_t>(default_arg.kind)),
300          modified_(false),
301          on_command_line_(false),
302          callback_(nullptr),
303          default_value_(default_arg.source),
304          data_guard_{} {}
305    int64_t ReadOneWord() const ABSL_LOCKS_EXCLUDED(*DataGuard());
306    bool ReadOneBool() const ABSL_LOCKS_EXCLUDED(*DataGuard());
307    void Read(void* dst) const override ABSL_LOCKS_EXCLUDED(*DataGuard());
308    void Read(bool* value) const ABSL_LOCKS_EXCLUDED(*DataGuard()) {
309      *value = ReadOneBool();
310    }
311    template <typename T,
312              absl::enable_if_t<flags_internal::StorageKind<T>() ==
313                                    FlagValueStorageKind::kOneWordAtomic,
314                                int> = 0>
315    void Read(T* value) const ABSL_LOCKS_EXCLUDED(*DataGuard()) {
316      int64_t v = ReadOneWord();
317      std::memcpy(value, static_cast<const void*>(&v), sizeof(T));
318    }
319    template <typename T,
320              typename std::enable_if<flags_internal::StorageKind<T>() ==
321                                          FlagValueStorageKind::kValueAndInitBit,
322                                      int>::type = 0>
323    void Read(T* value) const ABSL_LOCKS_EXCLUDED(*DataGuard()) {
324      *value = absl::bit_cast<FlagValueAndInitBit<T>>(ReadOneWord()).value;
325    }
326    void Write(const void* src) ABSL_LOCKS_EXCLUDED(*DataGuard());
327    void SetCallback(const FlagCallbackFunc mutation_callback)
328        ABSL_LOCKS_EXCLUDED(*DataGuard());
329    void InvokeCallback() const ABSL_EXCLUSIVE_LOCKS_REQUIRED(*DataGuard());
330    void AssertValidType(FlagFastTypeId type_id,
331                         const std::type_info* (*gen_rtti)()) const;
332   private:
333    template <typename T>
334    friend class Flag;
335    friend class FlagState;
336    absl::Mutex* DataGuard() const
337        ABSL_LOCK_RETURNED(reinterpret_cast<absl::Mutex*>(data_guard_));
338    std::unique_ptr<void, DynValueDeleter> MakeInitValue() const
339        ABSL_EXCLUSIVE_LOCKS_REQUIRED(*DataGuard());
340    void Init();
341    template <typename StorageT>
342    StorageT* OffsetValue() const;
343    void* AlignedBufferValue() const;
344    std::atomic<uint64_t>* AtomicBufferValue() const;
345    std::atomic<int64_t>& OneWordValue() const;
346    std::unique_ptr<void, DynValueDeleter> TryParse(absl::string_view value,
347                                                    std::string& err) const
348        ABSL_EXCLUSIVE_LOCKS_REQUIRED(*DataGuard());
349    void StoreValue(const void* src) ABSL_EXCLUSIVE_LOCKS_REQUIRED(*DataGuard());
350    void ReadSequenceLockedData(void* dst) const
351        ABSL_LOCKS_EXCLUDED(*DataGuard());
352    FlagHelpKind HelpSourceKind() const {
353      return static_cast<FlagHelpKind>(help_source_kind_);
354    }
355    FlagValueStorageKind ValueStorageKind() const {
356      return static_cast<FlagValueStorageKind>(value_storage_kind_);
357    }
358    FlagDefaultKind DefaultKind() const
359        ABSL_EXCLUSIVE_LOCKS_REQUIRED(*DataGuard()) {
360      return static_cast<FlagDefaultKind>(def_kind_);
361    }
362    absl::string_view Name() const override;
363    std::string Filename() const override;
364    std::string Help() const override;
365    FlagFastTypeId TypeId() const override;
366    bool IsSpecifiedOnCommandLine() const override
367        ABSL_LOCKS_EXCLUDED(*DataGuard());
368    std::string DefaultValue() const override ABSL_LOCKS_EXCLUDED(*DataGuard());
369    std::string CurrentValue() const override ABSL_LOCKS_EXCLUDED(*DataGuard());
370    bool ValidateInputValue(absl::string_view value) const override
371        ABSL_LOCKS_EXCLUDED(*DataGuard());
372    void CheckDefaultValueParsingRoundtrip() const override
373        ABSL_LOCKS_EXCLUDED(*DataGuard());
374    int64_t ModificationCount() const ABSL_EXCLUSIVE_LOCKS_REQUIRED(*DataGuard());
375    std::unique_ptr<FlagStateInterface> SaveState() override
376        ABSL_LOCKS_EXCLUDED(*DataGuard());
377    bool RestoreState(const FlagState& flag_state)
378        ABSL_LOCKS_EXCLUDED(*DataGuard());
379    bool ParseFrom(absl::string_view value, FlagSettingMode set_mode,
380                   ValueSource source, std::string& error) override
381        ABSL_LOCKS_EXCLUDED(*DataGuard());
382    const char* const name_;
383    const char* const filename_;
384    const FlagOpFn op_;
385    const FlagHelpMsg help_;
386    const uint8_t help_source_kind_ : 1;
387    const uint8_t value_storage_kind_ : 2;
388    uint8_t : 0;  
389    uint8_t def_kind_ : 2;
390    bool modified_ : 1 ABSL_GUARDED_BY(*DataGuard());
391    bool on_command_line_ : 1 ABSL_GUARDED_BY(*DataGuard());
392    absl::once_flag init_control_;
393    flags_internal::SequenceLock seq_lock_;
394    FlagCallback* callback_ ABSL_GUARDED_BY(*DataGuard());
395    FlagDefaultSrc default_value_;
396    alignas(absl::Mutex) mutable char data_guard_[sizeof(absl::Mutex)];
397  };
398  template <typename T>
399  class Flag {
400   public:
401    constexpr Flag(const char* name, const char* filename, FlagHelpArg help,
402                   const FlagDefaultArg default_arg)
403        : impl_(name, filename, &FlagOps<T>, help,
404                flags_internal::StorageKind<T>(), default_arg),
405          value_() {}
406    absl::string_view Name() const { return impl_.Name(); }
407    std::string Filename() const { return impl_.Filename(); }
408    std::string Help() const { return impl_.Help(); }
409    bool IsSpecifiedOnCommandLine() const {
410      return impl_.IsSpecifiedOnCommandLine();
411    }
412    std::string DefaultValue() const { return impl_.DefaultValue(); }
413    std::string CurrentValue() const { return impl_.CurrentValue(); }
414   private:
415    template <typename, bool>
416    friend class FlagRegistrar;
417    friend class FlagImplPeer;
418    T Get() const {
419      union U {
420        T value;
421        U() {}
422        ~U() { value.~T(); }
423      };
424      U u;
425  #if !defined(NDEBUG)
426      impl_.AssertValidType(base_internal::FastTypeId<T>(), &GenRuntimeTypeId<T>);
427  #endif
428      if (ABSL_PREDICT_FALSE(!value_.Get(impl_.seq_lock_, u.value))) {
429        impl_.Read(&u.value);
430      }
431      return std::move(u.value);
432    }
433    void Set(const T& v) {
434      impl_.AssertValidType(base_internal::FastTypeId<T>(), &GenRuntimeTypeId<T>);
435      impl_.Write(&v);
436    }
437    const CommandLineFlag& Reflect() const { return impl_; }
438    FlagImpl impl_;
439    FlagValue<T> value_;
440  };
441  class FlagImplPeer {
442   public:
443    template <typename T, typename FlagType>
444    static T InvokeGet(const FlagType& flag) {
445      return flag.Get();
446    }
447    template <typename FlagType, typename T>
448    static void InvokeSet(FlagType& flag, const T& v) {
449      flag.Set(v);
450    }
451    template <typename FlagType>
452    static const CommandLineFlag& InvokeReflect(const FlagType& f) {
453      return f.Reflect();
454    }
455  };
456  template <typename T>
457  void* FlagOps(FlagOp op, const void* v1, void* v2, void* v3) {
458    switch (op) {
459      case FlagOp::kAlloc: {
460        std::allocator<T> alloc;
461        return std::allocator_traits<std::allocator<T>>::allocate(alloc, 1);
462      }
463      case FlagOp::kDelete: {
464        T* p = static_cast<T*>(v2);
465        p->~T();
466        std::allocator<T> alloc;
467        std::allocator_traits<std::allocator<T>>::deallocate(alloc, p, 1);
468        return nullptr;
469      }
470      case FlagOp::kCopy:
471        *static_cast<T*>(v2) = *static_cast<const T*>(v1);
472        return nullptr;
473      case FlagOp::kCopyConstruct:
474        new (v2) T(*static_cast<const T*>(v1));
475        return nullptr;
476      case FlagOp::kSizeof:
477        return reinterpret_cast<void*>(static_cast<uintptr_t>(sizeof(T)));
478      case FlagOp::kFastTypeId:
479        return const_cast<void*>(base_internal::FastTypeId<T>());
480      case FlagOp::kRuntimeTypeId:
481        return const_cast<std::type_info*>(GenRuntimeTypeId<T>());
482      case FlagOp::kParse: {
483        T temp(*static_cast<T*>(v2));
484        if (!absl::ParseFlag<T>(*static_cast<const absl::string_view*>(v1), &temp,
485                                static_cast<std::string*>(v3))) {
486          return nullptr;
487        }
488        *static_cast<T*>(v2) = std::move(temp);
489        return v2;
490      }
491      case FlagOp::kUnparse:
492        *static_cast<std::string*>(v2) =
493            absl::UnparseFlag<T>(*static_cast<const T*>(v1));
494        return nullptr;
495      case FlagOp::kValueOffset: {
496        size_t round_to = alignof(FlagValue<T>);
497        size_t offset =
498            (sizeof(FlagImpl) + round_to - 1) / round_to * round_to;
499        return reinterpret_cast<void*>(offset);
500      }
501    }
502    return nullptr;
503  }
504  struct FlagRegistrarEmpty {};
505  template <typename T, bool do_register>
506  class FlagRegistrar {
507   public:
508    explicit FlagRegistrar(Flag<T>& flag, const char* filename) : flag_(flag) {
509      if (do_register)
510        flags_internal::RegisterCommandLineFlag(flag_.impl_, filename);
511    }
512    FlagRegistrar OnUpdate(FlagCallbackFunc cb) && {
513      flag_.impl_.SetCallback(cb);
514      return *this;
515    }
516    operator FlagRegistrarEmpty() const { return {}; }  
517   private:
518    Flag<T>& flag_;  
519  };
520  }  
521  ABSL_NAMESPACE_END
522  }  
523  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-flag_8.h</h3>
            <pre><code>1  #ifndef ABSL_FLAGS_INTERNAL_FLAG_H_
2  #define ABSL_FLAGS_INTERNAL_FLAG_H_
3  #include <stddef.h>
4  #include <stdint.h>
5  #include <atomic>
6  #include <cstring>
7  #include <memory>
8  #include <new>
9  #include <string>
10  #include <type_traits>
11  #include <typeinfo>
12  #include "absl/base/attributes.h"
13  #include "absl/base/call_once.h"
14  #include "absl/base/casts.h"
15  #include "absl/base/config.h"
16  #include "absl/base/optimization.h"
17  #include "absl/base/thread_annotations.h"
18  #include "absl/flags/commandlineflag.h"
19  #include "absl/flags/config.h"
20  #include "absl/flags/internal/commandlineflag.h"
21  #include "absl/flags/internal/registry.h"
22  #include "absl/flags/internal/sequence_lock.h"
23  #include "absl/flags/marshalling.h"
24  #include "absl/meta/type_traits.h"
25  #include "absl/strings/string_view.h"
26  #include "absl/synchronization/mutex.h"
27  #include "absl/utility/utility.h"
28  namespace absl {
29  ABSL_NAMESPACE_BEGIN
30  namespace flags_internal {
31  template <typename T>
32  class Flag;
33  }  
34  #if defined(_MSC_VER) && !defined(__clang__)
35  template <typename T>
36  class Flag;
37  #else
38  template <typename T>
39  using Flag = flags_internal::Flag<T>;
40  #endif
41  template <typename T>
42  ABSL_MUST_USE_RESULT T GetFlag(const absl::Flag<T>& flag);
43  template <typename T>
44  void SetFlag(absl::Flag<T>* flag, const T& v);
45  template <typename T, typename V>
46  void SetFlag(absl::Flag<T>* flag, const V& v);
47  template <typename U>
48  const CommandLineFlag& GetFlagReflectionHandle(const absl::Flag<U>& f);
49  namespace flags_internal {
50  enum class FlagOp {
51    kAlloc,
52    kDelete,
53    kCopy,
54    kCopyConstruct,
55    kSizeof,
56    kFastTypeId,
57    kRuntimeTypeId,
58    kParse,
59    kUnparse,
60    kValueOffset,
61  };
62  using FlagOpFn = void* (*)(FlagOp, const void*, void*, void*);
63  template <typename T>
64  void* FlagOps(FlagOp op, const void* v1, void* v2, void* v3);
65  inline void* Alloc(FlagOpFn op) {
66    return op(FlagOp::kAlloc, nullptr, nullptr, nullptr);
67  }
68  inline void Delete(FlagOpFn op, void* obj) {
69    op(FlagOp::kDelete, nullptr, obj, nullptr);
70  }
71  inline void Copy(FlagOpFn op, const void* src, void* dst) {
72    op(FlagOp::kCopy, src, dst, nullptr);
73  }
74  inline void CopyConstruct(FlagOpFn op, const void* src, void* dst) {
75    op(FlagOp::kCopyConstruct, src, dst, nullptr);
76  }
77  inline void* Clone(FlagOpFn op, const void* obj) {
78    void* res = flags_internal::Alloc(op);
79    flags_internal::CopyConstruct(op, obj, res);
80    return res;
81  }
82  inline bool Parse(FlagOpFn op, absl::string_view text, void* dst,
83                    std::string* error) {
84    return op(FlagOp::kParse, &text, dst, error) != nullptr;
85  }
86  inline std::string Unparse(FlagOpFn op, const void* val) {
87    std::string result;
88    op(FlagOp::kUnparse, val, &result, nullptr);
89    return result;
90  }
91  inline size_t Sizeof(FlagOpFn op) {
92    return static_cast<size_t>(reinterpret_cast<intptr_t>(
93        op(FlagOp::kSizeof, nullptr, nullptr, nullptr)));
94  }
95  inline FlagFastTypeId FastTypeId(FlagOpFn op) {
96    return reinterpret_cast<FlagFastTypeId>(
97        op(FlagOp::kFastTypeId, nullptr, nullptr, nullptr));
98  }
99  inline const std::type_info* RuntimeTypeId(FlagOpFn op) {
100    return reinterpret_cast<const std::type_info*>(
101        op(FlagOp::kRuntimeTypeId, nullptr, nullptr, nullptr));
102  }
103  inline ptrdiff_t ValueOffset(FlagOpFn op) {
104    return static_cast<ptrdiff_t>(reinterpret_cast<intptr_t>(
105        op(FlagOp::kValueOffset, nullptr, nullptr, nullptr)));
106  }
107  template <typename T>
108  inline const std::type_info* GenRuntimeTypeId() {
109  #ifdef ABSL_INTERNAL_HAS_RTTI
110    return &typeid(T);
111  #else
112    return nullptr;
113  #endif
114  }
115  using HelpGenFunc = std::string (*)();
116  template <size_t N>
117  struct FixedCharArray {
118    char value[N];
119    template <size_t... I>
120    static constexpr FixedCharArray<N> FromLiteralString(
121        absl::string_view str, absl::index_sequence<I...>) {
122      return (void)str, FixedCharArray<N>({{str[I]..., '\0'}});
123    }
124  };
125  template <typename Gen, size_t N = Gen::Value().size()>
126  constexpr FixedCharArray<N + 1> HelpStringAsArray(int) {
127    return FixedCharArray<N + 1>::FromLiteralString(
128        Gen::Value(), absl::make_index_sequence<N>{});
129  }
130  template <typename Gen>
131  constexpr std::false_type HelpStringAsArray(char) {
132    return std::false_type{};
133  }
134  union FlagHelpMsg {
135    constexpr explicit FlagHelpMsg(const char* help_msg) : literal(help_msg) {}
136    constexpr explicit FlagHelpMsg(HelpGenFunc help_gen) : gen_func(help_gen) {}
137    const char* literal;
138    HelpGenFunc gen_func;
139  };
140  enum class FlagHelpKind : uint8_t { kLiteral = 0, kGenFunc = 1 };
141  struct FlagHelpArg {
142    FlagHelpMsg source;
143    FlagHelpKind kind;
144  };
145  extern const char kStrippedFlagHelp[];
146  template <typename Gen, size_t N>
147  constexpr FlagHelpArg HelpArg(const FixedCharArray<N>& value) {
148    return {FlagHelpMsg(value.value), FlagHelpKind::kLiteral};
149  }
150  template <typename Gen>
151  constexpr FlagHelpArg HelpArg(std::false_type) {
152    return {FlagHelpMsg(&Gen::NonConst), FlagHelpKind::kGenFunc};
153  }
154  using FlagDfltGenFunc = void (*)(void*);
155  union FlagDefaultSrc {
156    constexpr explicit FlagDefaultSrc(FlagDfltGenFunc gen_func_arg)
157        : gen_func(gen_func_arg) {}
158  #define ABSL_FLAGS_INTERNAL_DFLT_FOR_TYPE(T, name) \
159    T name##_value;                                  \
160    constexpr explicit FlagDefaultSrc(T value) : name##_value(value) {}  
161    ABSL_FLAGS_INTERNAL_BUILTIN_TYPES(ABSL_FLAGS_INTERNAL_DFLT_FOR_TYPE)
162  #undef ABSL_FLAGS_INTERNAL_DFLT_FOR_TYPE
163    void* dynamic_value;
164    FlagDfltGenFunc gen_func;
165  };
166  enum class FlagDefaultKind : uint8_t {
167    kDynamicValue = 0,
168    kGenFunc = 1,
169    kOneWord = 2  
170  };
171  struct FlagDefaultArg {
172    FlagDefaultSrc source;
173    FlagDefaultKind kind;
174  };
175  struct EmptyBraces {};
176  template <typename T>
177  constexpr T InitDefaultValue(T t) {
178    return t;
179  }
180  template <typename T>
181  constexpr T InitDefaultValue(EmptyBraces) {
182    return T{};
183  }
184  template <typename ValueT, typename GenT,
185            typename std::enable_if<std::is_integral<ValueT>::value, int>::type =
186                ((void)GenT{}, 0)>
187  constexpr FlagDefaultArg DefaultArg(int) {
188    return {FlagDefaultSrc(GenT{}.value), FlagDefaultKind::kOneWord};
189  }
190  template <typename ValueT, typename GenT>
191  constexpr FlagDefaultArg DefaultArg(char) {
192    return {FlagDefaultSrc(&GenT::Gen), FlagDefaultKind::kGenFunc};
193  }
194  constexpr int64_t UninitializedFlagValue() {
195    return static_cast<int64_t>(0xababababababababll);
196  }
<span onclick='openModal()' class='match'>197  template <typename T>
198  using FlagUseValueAndInitBitStorage =
199      std::integral_constant<bool, std::is_trivially_copyable<T>::value &&
200                                       std::is_default_constructible<T>::value &&
</span>201                                       (sizeof(T) < 8)>;
202  template <typename T>
203  using FlagUseOneWordStorage =
204      std::integral_constant<bool, std::is_trivially_copyable<T>::value &&
205                                       (sizeof(T) <= 8)>;
206  template <class T>
207  using FlagUseSequenceLockStorage =
208      std::integral_constant<bool, std::is_trivially_copyable<T>::value &&
209                                       (sizeof(T) > 8)>;
210  enum class FlagValueStorageKind : uint8_t {
211    kValueAndInitBit = 0,
212    kOneWordAtomic = 1,
213    kSequenceLocked = 2,
214    kAlignedBuffer = 3,
215  };
216  template <typename T>
217  static constexpr FlagValueStorageKind StorageKind() {
218    return FlagUseValueAndInitBitStorage<T>::value
219               ? FlagValueStorageKind::kValueAndInitBit
220           : FlagUseOneWordStorage<T>::value
221               ? FlagValueStorageKind::kOneWordAtomic
222           : FlagUseSequenceLockStorage<T>::value
223               ? FlagValueStorageKind::kSequenceLocked
224               : FlagValueStorageKind::kAlignedBuffer;
225  }
226  struct FlagOneWordValue {
227    constexpr explicit FlagOneWordValue(int64_t v) : value(v) {}
228    std::atomic<int64_t> value;
229  };
230  template <typename T>
231  struct alignas(8) FlagValueAndInitBit {
232    T value;
233    uint8_t init;
234  };
235  template <typename T,
236            FlagValueStorageKind Kind = flags_internal::StorageKind<T>()>
237  struct FlagValue;
238  template <typename T>
239  struct FlagValue<T, FlagValueStorageKind::kValueAndInitBit> : FlagOneWordValue {
240    constexpr FlagValue() : FlagOneWordValue(0) {}
241    bool Get(const SequenceLock&, T& dst) const {
242      int64_t storage = value.load(std::memory_order_acquire);
243      if (ABSL_PREDICT_FALSE(storage == 0)) {
244        return false;
245      }
246      dst = absl::bit_cast<FlagValueAndInitBit<T>>(storage).value;
247      return true;
248    }
249  };
250  template <typename T>
251  struct FlagValue<T, FlagValueStorageKind::kOneWordAtomic> : FlagOneWordValue {
252    constexpr FlagValue() : FlagOneWordValue(UninitializedFlagValue()) {}
253    bool Get(const SequenceLock&, T& dst) const {
254      int64_t one_word_val = value.load(std::memory_order_acquire);
255      if (ABSL_PREDICT_FALSE(one_word_val == UninitializedFlagValue())) {
256        return false;
257      }
258      std::memcpy(&dst, static_cast<const void*>(&one_word_val), sizeof(T));
259      return true;
260    }
261  };
262  template <typename T>
263  struct FlagValue<T, FlagValueStorageKind::kSequenceLocked> {
264    bool Get(const SequenceLock& lock, T& dst) const {
265      return lock.TryRead(&dst, value_words, sizeof(T));
266    }
267    static constexpr int kNumWords =
268        flags_internal::AlignUp(sizeof(T), sizeof(uint64_t)) / sizeof(uint64_t);
269    alignas(T) alignas(
270        std::atomic<uint64_t>) std::atomic<uint64_t> value_words[kNumWords];
271  };
272  template <typename T>
273  struct FlagValue<T, FlagValueStorageKind::kAlignedBuffer> {
274    bool Get(const SequenceLock&, T&) const { return false; }
275    alignas(T) char value[sizeof(T)];
276  };
277  using FlagCallbackFunc = void (*)();
278  struct FlagCallback {
279    FlagCallbackFunc func;
280    absl::Mutex guard;  
281  };
282  struct DynValueDeleter {
283    explicit DynValueDeleter(FlagOpFn op_arg = nullptr);
284    void operator()(void* ptr) const;
285    FlagOpFn op;
286  };
287  class FlagState;
288  class FlagImpl final : public CommandLineFlag {
289   public:
290    constexpr FlagImpl(const char* name, const char* filename, FlagOpFn op,
291                       FlagHelpArg help, FlagValueStorageKind value_kind,
292                       FlagDefaultArg default_arg)
293        : name_(name),
294          filename_(filename),
295          op_(op),
296          help_(help.source),
297          help_source_kind_(static_cast<uint8_t>(help.kind)),
298          value_storage_kind_(static_cast<uint8_t>(value_kind)),
299          def_kind_(static_cast<uint8_t>(default_arg.kind)),
300          modified_(false),
301          on_command_line_(false),
302          callback_(nullptr),
303          default_value_(default_arg.source),
304          data_guard_{} {}
305    int64_t ReadOneWord() const ABSL_LOCKS_EXCLUDED(*DataGuard());
306    bool ReadOneBool() const ABSL_LOCKS_EXCLUDED(*DataGuard());
307    void Read(void* dst) const override ABSL_LOCKS_EXCLUDED(*DataGuard());
308    void Read(bool* value) const ABSL_LOCKS_EXCLUDED(*DataGuard()) {
309      *value = ReadOneBool();
310    }
311    template <typename T,
312              absl::enable_if_t<flags_internal::StorageKind<T>() ==
313                                    FlagValueStorageKind::kOneWordAtomic,
314                                int> = 0>
315    void Read(T* value) const ABSL_LOCKS_EXCLUDED(*DataGuard()) {
316      int64_t v = ReadOneWord();
317      std::memcpy(value, static_cast<const void*>(&v), sizeof(T));
318    }
319    template <typename T,
320              typename std::enable_if<flags_internal::StorageKind<T>() ==
321                                          FlagValueStorageKind::kValueAndInitBit,
322                                      int>::type = 0>
323    void Read(T* value) const ABSL_LOCKS_EXCLUDED(*DataGuard()) {
324      *value = absl::bit_cast<FlagValueAndInitBit<T>>(ReadOneWord()).value;
325    }
326    void Write(const void* src) ABSL_LOCKS_EXCLUDED(*DataGuard());
327    void SetCallback(const FlagCallbackFunc mutation_callback)
328        ABSL_LOCKS_EXCLUDED(*DataGuard());
329    void InvokeCallback() const ABSL_EXCLUSIVE_LOCKS_REQUIRED(*DataGuard());
330    void AssertValidType(FlagFastTypeId type_id,
331                         const std::type_info* (*gen_rtti)()) const;
332   private:
333    template <typename T>
334    friend class Flag;
335    friend class FlagState;
336    absl::Mutex* DataGuard() const
337        ABSL_LOCK_RETURNED(reinterpret_cast<absl::Mutex*>(data_guard_));
338    std::unique_ptr<void, DynValueDeleter> MakeInitValue() const
339        ABSL_EXCLUSIVE_LOCKS_REQUIRED(*DataGuard());
340    void Init();
341    template <typename StorageT>
342    StorageT* OffsetValue() const;
343    void* AlignedBufferValue() const;
344    std::atomic<uint64_t>* AtomicBufferValue() const;
345    std::atomic<int64_t>& OneWordValue() const;
346    std::unique_ptr<void, DynValueDeleter> TryParse(absl::string_view value,
347                                                    std::string& err) const
348        ABSL_EXCLUSIVE_LOCKS_REQUIRED(*DataGuard());
349    void StoreValue(const void* src) ABSL_EXCLUSIVE_LOCKS_REQUIRED(*DataGuard());
350    void ReadSequenceLockedData(void* dst) const
351        ABSL_LOCKS_EXCLUDED(*DataGuard());
352    FlagHelpKind HelpSourceKind() const {
353      return static_cast<FlagHelpKind>(help_source_kind_);
354    }
355    FlagValueStorageKind ValueStorageKind() const {
356      return static_cast<FlagValueStorageKind>(value_storage_kind_);
357    }
358    FlagDefaultKind DefaultKind() const
359        ABSL_EXCLUSIVE_LOCKS_REQUIRED(*DataGuard()) {
360      return static_cast<FlagDefaultKind>(def_kind_);
361    }
362    absl::string_view Name() const override;
363    std::string Filename() const override;
364    std::string Help() const override;
365    FlagFastTypeId TypeId() const override;
366    bool IsSpecifiedOnCommandLine() const override
367        ABSL_LOCKS_EXCLUDED(*DataGuard());
368    std::string DefaultValue() const override ABSL_LOCKS_EXCLUDED(*DataGuard());
369    std::string CurrentValue() const override ABSL_LOCKS_EXCLUDED(*DataGuard());
370    bool ValidateInputValue(absl::string_view value) const override
371        ABSL_LOCKS_EXCLUDED(*DataGuard());
372    void CheckDefaultValueParsingRoundtrip() const override
373        ABSL_LOCKS_EXCLUDED(*DataGuard());
374    int64_t ModificationCount() const ABSL_EXCLUSIVE_LOCKS_REQUIRED(*DataGuard());
375    std::unique_ptr<FlagStateInterface> SaveState() override
376        ABSL_LOCKS_EXCLUDED(*DataGuard());
377    bool RestoreState(const FlagState& flag_state)
378        ABSL_LOCKS_EXCLUDED(*DataGuard());
379    bool ParseFrom(absl::string_view value, FlagSettingMode set_mode,
380                   ValueSource source, std::string& error) override
381        ABSL_LOCKS_EXCLUDED(*DataGuard());
382    const char* const name_;
383    const char* const filename_;
384    const FlagOpFn op_;
385    const FlagHelpMsg help_;
386    const uint8_t help_source_kind_ : 1;
387    const uint8_t value_storage_kind_ : 2;
388    uint8_t : 0;  
389    uint8_t def_kind_ : 2;
390    bool modified_ : 1 ABSL_GUARDED_BY(*DataGuard());
391    bool on_command_line_ : 1 ABSL_GUARDED_BY(*DataGuard());
392    absl::once_flag init_control_;
393    flags_internal::SequenceLock seq_lock_;
394    FlagCallback* callback_ ABSL_GUARDED_BY(*DataGuard());
395    FlagDefaultSrc default_value_;
396    alignas(absl::Mutex) mutable char data_guard_[sizeof(absl::Mutex)];
397  };
398  template <typename T>
399  class Flag {
400   public:
401    constexpr Flag(const char* name, const char* filename, FlagHelpArg help,
402                   const FlagDefaultArg default_arg)
403        : impl_(name, filename, &FlagOps<T>, help,
404                flags_internal::StorageKind<T>(), default_arg),
405          value_() {}
406    absl::string_view Name() const { return impl_.Name(); }
407    std::string Filename() const { return impl_.Filename(); }
408    std::string Help() const { return impl_.Help(); }
409    bool IsSpecifiedOnCommandLine() const {
410      return impl_.IsSpecifiedOnCommandLine();
411    }
412    std::string DefaultValue() const { return impl_.DefaultValue(); }
413    std::string CurrentValue() const { return impl_.CurrentValue(); }
414   private:
415    template <typename, bool>
416    friend class FlagRegistrar;
417    friend class FlagImplPeer;
418    T Get() const {
419      union U {
420        T value;
421        U() {}
422        ~U() { value.~T(); }
423      };
424      U u;
425  #if !defined(NDEBUG)
426      impl_.AssertValidType(base_internal::FastTypeId<T>(), &GenRuntimeTypeId<T>);
427  #endif
428      if (ABSL_PREDICT_FALSE(!value_.Get(impl_.seq_lock_, u.value))) {
429        impl_.Read(&u.value);
430      }
431      return std::move(u.value);
432    }
433    void Set(const T& v) {
434      impl_.AssertValidType(base_internal::FastTypeId<T>(), &GenRuntimeTypeId<T>);
435      impl_.Write(&v);
436    }
437    const CommandLineFlag& Reflect() const { return impl_; }
438    FlagImpl impl_;
439    FlagValue<T> value_;
440  };
441  class FlagImplPeer {
442   public:
443    template <typename T, typename FlagType>
444    static T InvokeGet(const FlagType& flag) {
445      return flag.Get();
446    }
447    template <typename FlagType, typename T>
448    static void InvokeSet(FlagType& flag, const T& v) {
449      flag.Set(v);
450    }
451    template <typename FlagType>
452    static const CommandLineFlag& InvokeReflect(const FlagType& f) {
453      return f.Reflect();
454    }
455  };
456  template <typename T>
457  void* FlagOps(FlagOp op, const void* v1, void* v2, void* v3) {
458    switch (op) {
459      case FlagOp::kAlloc: {
460        std::allocator<T> alloc;
461        return std::allocator_traits<std::allocator<T>>::allocate(alloc, 1);
462      }
463      case FlagOp::kDelete: {
464        T* p = static_cast<T*>(v2);
465        p->~T();
466        std::allocator<T> alloc;
467        std::allocator_traits<std::allocator<T>>::deallocate(alloc, p, 1);
468        return nullptr;
469      }
470      case FlagOp::kCopy:
471        *static_cast<T*>(v2) = *static_cast<const T*>(v1);
472        return nullptr;
473      case FlagOp::kCopyConstruct:
474        new (v2) T(*static_cast<const T*>(v1));
475        return nullptr;
476      case FlagOp::kSizeof:
477        return reinterpret_cast<void*>(static_cast<uintptr_t>(sizeof(T)));
478      case FlagOp::kFastTypeId:
479        return const_cast<void*>(base_internal::FastTypeId<T>());
480      case FlagOp::kRuntimeTypeId:
481        return const_cast<std::type_info*>(GenRuntimeTypeId<T>());
482      case FlagOp::kParse: {
483        T temp(*static_cast<T*>(v2));
484        if (!absl::ParseFlag<T>(*static_cast<const absl::string_view*>(v1), &temp,
485                                static_cast<std::string*>(v3))) {
486          return nullptr;
487        }
488        *static_cast<T*>(v2) = std::move(temp);
489        return v2;
490      }
491      case FlagOp::kUnparse:
492        *static_cast<std::string*>(v2) =
493            absl::UnparseFlag<T>(*static_cast<const T*>(v1));
494        return nullptr;
495      case FlagOp::kValueOffset: {
496        size_t round_to = alignof(FlagValue<T>);
497        size_t offset =
498            (sizeof(FlagImpl) + round_to - 1) / round_to * round_to;
499        return reinterpret_cast<void*>(offset);
500      }
501    }
502    return nullptr;
503  }
504  struct FlagRegistrarEmpty {};
505  template <typename T, bool do_register>
506  class FlagRegistrar {
507   public:
508    explicit FlagRegistrar(Flag<T>& flag, const char* filename) : flag_(flag) {
509      if (do_register)
510        flags_internal::RegisterCommandLineFlag(flag_.impl_, filename);
511    }
512    FlagRegistrar OnUpdate(FlagCallbackFunc cb) && {
513      flag_.impl_.SetCallback(cb);
514      return *this;
515    }
516    operator FlagRegistrarEmpty() const { return {}; }  
517   private:
518    Flag<T>& flag_;  
519  };
520  }  
521  ABSL_NAMESPACE_END
522  }  
523  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-flag_8.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-flag_8.h</div>
                </div>
                <div class="column column_space"><pre><code>197  template <typename T>
198  using FlagUseValueAndInitBitStorage =
199      std::integral_constant<bool, std::is_trivially_copyable<T>::value &&
200                                       std::is_default_constructible<T>::value &&
</pre></code></div>
                <div class="column column_space"><pre><code>197  template <typename T>
198  using FlagUseValueAndInitBitStorage =
199      std::integral_constant<bool, std::is_trivially_copyable<T>::value &&
200                                       std::is_default_constructible<T>::value &&
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    