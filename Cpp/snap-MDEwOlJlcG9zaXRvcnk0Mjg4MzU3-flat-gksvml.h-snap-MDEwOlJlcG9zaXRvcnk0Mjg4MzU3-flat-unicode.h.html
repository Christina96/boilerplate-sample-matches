
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 1.2187434334944316%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-gksvml.h</h3>
            <pre><code>1  #ifndef GksVml_h
2  #define GksVml_h
3  #include "gks.h"
4  class TVmlGks: public TGks {
5  private:
6    TStr OutFNm, Title;
7    mutable FILE *OutF;
8    TInt Width, Height;
9    PGksPen CurPen;
10    PGksBrush CurBrush;
11    PGksFont CurFont;
12  private:
13    void Flush() const { fflush(OutF);}
14    void PutHtmlHeader() const;
15    void PutHtmlFooter() const;
16  public:
17    TVmlGks() : OutF(NULL), OutFNm("gkssvg.html"), Width(1000), Height(1000) { PutHtmlHeader();}
18    TVmlGks(const TStr& OutFName, const TStr& _Title, const TInt& _Width, const TInt& _Height);
19    ~TVmlGks() {
20      if (OutF) { PutHtmlFooter(); fclose(OutF);}  OutF=NULL;}
21    static PGks New(const TStr& OutFName=TStr(), const TStr& Title=TStr(), const TInt& Width=0, const TInt& Height=0) {
22      return new TVmlGks(OutFName, Title, Width, Height);}
23    static TStr GetHtmlColor(const TGksColor& GksColor){
24      return TStr::Fmt("#%02x%02x%02x",
25       GksColor.GetRVal(), GksColor.GetGVal(), GksColor.GetBVal());}
26    int GetWidth() const { return Width;}
27    int GetHeight() const { return Height;}
28    void Clr() const { fclose(OutF);  OutF=NULL;  PutHtmlHeader();}
29    void Inv() const { Flush();}
30    void BeginPaint() const { }
31    void EndPaint() const { Flush();}
32    void SetPen(const PGksPen& Pen) { CurPen = Pen;}
33    PGksPen GetPen() { return CurPen;}
34    void SetBrush(const PGksBrush& Brush) { CurBrush = Brush;}
35    PGksBrush GetBrush() { return CurBrush;}
36    void SetFont(const PGksFont& Font) { CurFont = Font;}
<span onclick='openModal()' class='match'>37    PGksFont GetFont() { return CurFont;}
38    void PutPixel(const int& X, const int& Y, const TGksColor& GksColor) {
</span>39      fprintf(OutF, "<v:rect style=\"left:%d; top:%d; width:1; height:1;\" fillcolor=\"%s\" strokeweight=\"1px\" strokecolor=\"%s\" />\n",
40       X, Y, GetHtmlColor(GksColor).CStr(), GetHtmlColor(GksColor).CStr());
41    }
42    TGksColor GetPixel(const int& X, const int& Y){Fail; return TGksColor();}
43    void Line(const int& X1, const int& Y1, const int& X2, const int& Y2) {
44      TGksPenStyle Style = CurPen->GetStyle();
45      fprintf(OutF, "<v:line from=\"%d,%d\" to=\"%d,%d\" strokeweight=\"%d\" strokecolor=\"%s\"> ",
46       X1, Y1, X2, Y2, CurPen->GetWidth(), GetHtmlColor(CurPen->GetColor()).CStr());
47      switch(CurPen->GetStyle()) {
48        case gpsDash : fprintf(OutF, "<v:stroke dashstyle=\"dash\" /> </v:line>\n");  break;
49        case gpsDot : fprintf(OutF, "<v:stroke dashstyle=\"dot\" /> </v:line>\n");  break;
50        case gpsDashDot : fprintf(OutF, "<v:stroke dashstyle=\"dashdot\" /> </v:line>\n");  break;
51        case gpsDashDotDot : fprintf(OutF, "<v:stroke dashstyle=\"longdashdotdot\" /> </v:line>\n");  break;
52        default : fprintf(OutF, "<v:stroke dashstyle=\"solid\" /> </v:line>\n");  break;
53      };
54    }
55    void PolyLine(const TGksSPointV& PointV){
56      TGksPenStyle Style = CurPen->GetStyle();
57      fprintf(OutF, "<v:polyline points=\"%d,%d", PointV[0].X, PointV[0].Y);
58      for (int i = 1; i < PointV.Len(); i++) fprintf(OutF, ", %d,%d", PointV[i].X, PointV[i].Y);
59      fprintf(OutF, "\" strokecolor=\"%s\" strokeweight=\"%d\">",
60       GetHtmlColor(CurPen->GetColor()).CStr(), CurPen->GetWidth());
61      switch(CurPen->GetStyle()) {
62        case gpsDash : fprintf(OutF, "<v:stroke dashstyle=\"dash\" /> </v:line>\n");  break;
63        case gpsDot : fprintf(OutF, "<v:stroke dashstyle=\"dot\" /> </v:line>\n");  break;
64        case gpsDashDot : fprintf(OutF, "<v:stroke dashstyle=\"dashdot\" /> </v:line>\n");  break;
65        case gpsDashDotDot : fprintf(OutF, "<v:stroke dashstyle=\"longdashdotdot\" /> </v:line>\n");  break;
66        default : fprintf(OutF, "<v:stroke dashstyle=\"solid\" /> </v:polyline>\n");  break;
67      };
68    }
69    void Polygon(const TGksSPointV& PointV) { Fail;}
70    void PolyBezier(const TGksSPointV& PointV) { Fail;}
71    void FrameRect(const int& X1, const int& Y1, const int& X2, const int& Y2) {
72      TGksSPointV PointV(5, 0);
73      PointV.Add(TGksSPoint(X1, Y1)); PointV.Add(TGksSPoint(X1, Y2));
74      PointV.Add(TGksSPoint(X2, Y2)); PointV.Add(TGksSPoint(X2, Y1));
75      PointV.Add(TGksSPoint(X1, Y1));
76      PolyLine(PointV);
77    }
78    void FillRect(const int& X1, const int& Y1, const int& X2, const int& Y2) {
79      fprintf(OutF, "<v:rect style=\"left:%d; top:%d; width:%d; height:%d;\" fillcolor=\"%s\" strokeweight=\"1px\" strokecolor=\"%s\" />\n", X1, Y1, X2-X1, Y2-Y1, GetHtmlColor(CurBrush->GetColor()).CStr(), GetHtmlColor(CurBrush->GetColor()).CStr());
80    }
81    void Rectangle(const int& X1, const int& Y1, const int& X2, const int& Y2) {
82      fprintf(OutF, "<v:rect style=\"left:%d; top:%d; width:%d; height:%d;\" fillcolor=\"%s\" strokeweight=\"%d\" strokecolor=\"%s\" />\n", X1, Y1, X2-X1, Y2-Y1, GetHtmlColor(CurBrush->GetColor()).CStr(), CurPen->GetWidth(), GetHtmlColor(CurPen->GetColor()).CStr());
83    }
84    void RoundRect(const int& X1, const int& Y1, const int& X2, const int& Y2, const int& EWidth, const int& EHeight) {
85      fprintf(OutF, "<v:roundrect style=\"left:%d; top:%d; width:%d; height:%d;\" arcsize=\"%.4f\"", X1, Y1, X2-X1, Y2-Y1, double(EWidth)/double(TMath::Mx(X2-X1, Y2-Y1)));
86      fprintf(OutF, " fillcolor=\"%s\" strokecolor=\"%s\" strokeweight=\"%d\" />\n", GetHtmlColor(CurBrush->GetColor()).CStr(), GetHtmlColor(CurPen->GetColor()).CStr(), CurPen->GetWidth());
87    }
88    void Ellipse(const int& X1, const int& Y1, const int& X2, const int& Y2) {
89      fprintf(OutF, "<v:oval style=\"left:%d; top:%d; width:%d; height:%d;\"", X1, Y1, X2-X1, Y2-Y1);
90      fprintf(OutF, " fillcolor=\"%s\" strokecolor=\"%s\" strokeweight=\"%d\" />\n",
91       GetHtmlColor(CurBrush->GetColor()).CStr(), GetHtmlColor(CurPen->GetColor()).CStr(), CurPen->GetWidth());
92    }
93    void FillEllipse(const int& X1, const int& Y1, const int& X2, const int& Y2) { }
94    void Arc(
95     const int& X1, const int& Y1, const int& X2, const int& Y2,
96     const int& X3, const int& Y3, const int& X4, const int& Y4){
97      Fail;
98    }
99    void Bitmap(const PGksBitmap& Bmp, const int& X, const int& Y) { }
100    void Bitmap(const PGksBitmap& Bmp,
101        const int& X1, const int& Y1, const int& X2, const int& Y2) { }
102    int GetTxtWidth(const TStr& TxtStr) {
103      return 2*TxtStr.Len()*CurFont->GetSize()/3;
104    }
105    int GetTxtHeight(const TStr& TxtStr) {
106      return CurFont->GetSize()*2;
107    }
108    void PutTxt(const TStr& TxtStr, const int& X, const int& Y) {
109      fprintf(OutF, "<v:shape style='position: absolute; left: %d; top: %d; width: %d; height: %dpt'>", X-Width/100, Y-5, 100, CurFont->GetSize());
110      TStr NewStr = TxtStr;  NewStr.ChangeStrAll("\n", "<br>");
111      fprintf(OutF, "<v:textbox style=\"text-align:left; v-text-wrapping:true; ");
112      const TFSet FontS = CurFont->GetStyle();
113      if (FontS.In(gfsUnderline)) fprintf(OutF, "text-decoration: underline; "); 
114      else if (FontS.In(gfsStrikeOut)) fprintf(OutF, "text-decoration: line-through; ");
115      fprintf(OutF, "font: ");
116      if (FontS.In(gfsBold)) fprintf(OutF, "bold ");
117      if (FontS.In(gfsItalic)) fprintf(OutF, "italic ");
118      fprintf(OutF, "%dpt %s; color:%s;\">", CurFont->GetSize(), CurFont->GetNm().CStr(), GetHtmlColor(CurFont->GetColor()).CStr());
119      fprintf(OutF, " %s  </v:textbox> </v:shape>\n", NewStr.CStr());
120    }
121    void PutTxt(const TStr& TxtStr, const int& X, const int& Y, const TGksRect& ClipRect) {
122      fprintf(OutF, "<v:shape style='position: absolute; left: %d; top: %d; width: %d; height: %dpt'>", X, Y, ClipRect.GetXLen(), ClipRect.GetYLen());
123      TStr NewStr = TxtStr;  NewStr.ChangeStrAll("\n", "<br>");
124      fprintf(OutF, "<v:textbox style=\"text-align:left; v-text-wrapping:true; ");
125      const TFSet FontS = CurFont->GetStyle();
126      if (FontS.In(gfsUnderline)) fprintf(OutF, "text-decoration: underline; ");
127      else if (FontS.In(gfsStrikeOut)) fprintf(OutF, "text-decoration: line-through; ");
128      fprintf(OutF, "font: ");
129      if (FontS.In(gfsBold)) fprintf(OutF, "bold ");
130      if (FontS.In(gfsItalic)) fprintf(OutF, "italic ");
131      fprintf(OutF, "%dpt %s; color:%s;\">", CurFont->GetSize(), CurFont->GetNm().CStr(), GetHtmlColor(CurFont->GetColor()).CStr());
132      fprintf(OutF, " %s  </v:textbox> </v:shape>\n", NewStr.CStr());
133    }
134  };
135  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-unicode.h</h3>
            <pre><code>1  #include "bd.h"
2  #include <new>
3  typedef int TUniVecIdx;
4  typedef enum TUnicodeErrorHandling_
5  {
6  	uehIgnore = 0,  
7  	uehThrow = 1,   
8  	uehReplace = 2, 
9  	uehAbort = 3    
10  }
11  TUnicodeErrorHandling;
12  class TUnicodeException
13  {
14  public:
15  	TStr message;  
16  	size_t srcIdx; 
17  	int srcChar;   
18  	TUnicodeException(size_t srcIdx_, int srcChar_, const TStr& message_) :
19  		message(message_), srcIdx(srcIdx_), srcChar(srcChar_) { }
20  };
21  typedef enum TUniByteOrder_
22  {
23  	boMachineEndian = 0,
24  	boLittleEndian = 1,
25  	boBigEndian = 2
26  }
27  TUniByteOrder;
28  typedef enum TUtf16BomHandling_
29  {
30  	bomAllowed = 0,   
31  	bomRequired = 1,  
32  	bomIgnored = 2    
33  }
34  TUtf16BomHandling;
35  class TUniCodec
36  {
37  public:
38  	enum { DefaultReplacementChar = 0xfffd };
39  	int replacementChar;
40  	TUnicodeErrorHandling errorHandling;
41  	bool strict;
42  	bool skipBom;
43  	TUniCodec() : replacementChar(DefaultReplacementChar), errorHandling(uehIgnore), strict(false), skipBom(true)
44  	{
45  	}
46  	TUniCodec(TUnicodeErrorHandling errorHandling_, bool strict_, int replacementChar_, bool skipBom_) :
47  		replacementChar(replacementChar_), errorHandling(errorHandling_), strict(strict_), skipBom(skipBom_)
48  	{
49  	}
50  protected:
51  	enum {
52  #define DefineByte(b7, b6, b5, b4, b3, b2, b1, b0) _ ## b7 ## b6 ## b5 ## b4 ## _ ## b3 ## b2 ## b1 ## b0 = (b7 << 7) | (b6 << 6) | (b5 << 5) | (b4 << 4) | (b3 << 3) | (b2 << 2) | (b1 << 1) | b0
53  		DefineByte(1, 0, 0, 0, 0, 0, 0, 0),
54  		DefineByte(1, 1, 0, 0, 0, 0, 0, 0),
55  		DefineByte(1, 1, 1, 0, 0, 0, 0, 0),
56  		DefineByte(1, 1, 1, 1, 0, 0, 0, 0),
57  		DefineByte(1, 1, 1, 1, 1, 0, 0, 0),
58  		DefineByte(1, 1, 1, 1, 1, 1, 0, 0),
59  		DefineByte(1, 1, 1, 1, 1, 1, 1, 0),
60  		DefineByte(0, 0, 1, 1, 1, 1, 1, 1),
61  		DefineByte(0, 0, 0, 1, 1, 1, 1, 1),
62  		DefineByte(0, 0, 0, 0, 1, 1, 1, 1),
63  		DefineByte(0, 0, 0, 0, 0, 1, 1, 1),
64  		DefineByte(0, 0, 0, 0, 0, 0, 1, 1)
65  #undef DefineByte
66  	};
67  	typedef TUniVecIdx TVecIdx;
68  	friend class TUniCaseFolding;
69  	friend class TUnicode;
70  public:
71  	template<typename TSrcVec, typename TDestCh>
72  	size_t DecodeUtf8(
73  		const TSrcVec& src, size_t srcIdx, const size_t srcCount,
74  		TVec<TDestCh>& dest, const bool clrDest = true) const;
75  	template<typename TSrcVec, typename TDestCh>
76  	size_t DecodeUtf8(const TSrcVec& src, TVec<TDestCh>& dest, const bool clrDest = true) const { return DecodeUtf8(src, 0, src.Len(), dest, clrDest); }
77  	template<typename TSrcVec, typename TDestCh>
78  	size_t EncodeUtf8(
79  		const TSrcVec& src, size_t srcIdx, const size_t srcCount,
80  		TVec<TDestCh>& dest, const bool clrDest = true) const;
81  	template<typename TSrcVec, typename TDestCh>
82  	size_t EncodeUtf8(const TSrcVec& src, TVec<TDestCh>& dest, const bool clrDest = true) const { return EncodeUtf8(src, 0, src.Len(), dest, clrDest); }
83  	template<typename TSrcVec> TStr EncodeUtf8Str(const TSrcVec& src, size_t srcIdx, const size_t srcCount) const { TVec<char> temp; EncodeUtf8(src, srcIdx, srcCount, temp); TStr retVal = &(temp[0]); return retVal; }
84  	template<typename TSrcVec> TStr EncodeUtf8Str(const TSrcVec& src) const { TVec<char> temp; EncodeUtf8(src, temp); temp.Add(0); TStr retVal = &(temp[0]); return retVal; }
85  protected:
86  	enum {
87  		Utf16FirstSurrogate = 0xd800,
88  		Utf16SecondSurrogate = 0xdc00
89  	};
90  	static bool IsMachineLittleEndian();
91  public:
92  	template<typename TSrcVec, typename TDestCh>
93  	size_t DecodeUtf16FromBytes(
94  		const TSrcVec& src, size_t srcIdx, const size_t srcCount,
95  		TVec<TDestCh>& dest, const bool clrDest,
96  		const TUtf16BomHandling bomHandling = bomAllowed,
97  		const TUniByteOrder defaultByteOrder = boMachineEndian) const;
98  	template<typename TSrcVec, typename TDestCh>
99  	size_t DecodeUtf16FromWords(
100  		const TSrcVec& src, size_t srcIdx, const size_t srcCount,
101  		TVec<TDestCh>& dest, bool clrDest,
102  		const TUtf16BomHandling bomHandling = bomAllowed,
103  		const TUniByteOrder defaultByteOrder = boMachineEndian) const;
104  	template<typename TSrcVec, typename TDestCh>
105  	size_t EncodeUtf16ToWords(
106  		const TSrcVec& src, size_t srcIdx, const size_t srcCount,
107  		TVec<TDestCh>& dest, const bool clrDest, const bool insertBom,
108  		const TUniByteOrder destByteOrder = boMachineEndian) const;
109  	template<typename TSrcVec, typename TDestCh>
110  	size_t EncodeUtf16ToBytes(
111  		const TSrcVec& src, size_t srcIdx, const size_t srcCount,
112  		TVec<TDestCh>& dest, const bool clrDest, const bool insertBom,
113  		const TUniByteOrder destByteOrder = boMachineEndian) const;
114  protected:
115  	static uint GetRndUint(TRnd& rnd);
116  	static uint GetRndUint(TRnd& rnd, uint minVal, uint maxVal);
117  protected:
118  	void TestUtf8(bool decode, size_t expectedRetVal, bool expectedThrow, const TIntV& src, const TIntV& expectedDest, FILE *f);
119  	void TestDecodeUtf8(TRnd& rnd, const TStr& testCaseDesc);
120  public:
121  	void TestUtf8();
122  protected:
123  	void WordsToBytes(const TIntV& src, TIntV& dest);
124  	void TestUtf16(bool decode, size_t expectedRetVal, bool expectedThrow, const TIntV& src, const TIntV& expectedDest,
125  		const TUtf16BomHandling bomHandling, const TUniByteOrder defaultByteOrder, const bool insertBom,
126  		FILE *f);
127  	static inline int SwapBytes(int x) {
128  		return ((x >> 8) & 0xff) | ((x & 0xff) << 8); }
129  	void TestDecodeUtf16(TRnd& rnd, const TStr& testCaseDesc,
130  		const TUtf16BomHandling bomHandling,
131  		const TUniByteOrder defaultByteOrder,
132  		const bool insertBom);
133  public:
134  	void TestUtf16();
135  };
136  typedef THash<TInt, TIntV> TIntIntVH;
137  class TUniCaseFolding
138  {
139  protected:
140  	TIntH cfCommon, cfSimple, cfTurkic;
141  	TIntIntVH cfFull;
142  	template<typename TSrcDat, typename TDestDat>
143  	inline static void AppendVector(const TVec<TSrcDat>& src, TVec<TDestDat>& dest) {
144  		for (int i = 0; i < src.Len(); i++) dest.Add(src[i]); }
145  	friend class TUniChDb;
146  	typedef TUniVecIdx TVecIdx;
147  public:
148  	TUniCaseFolding() { }
149  	explicit TUniCaseFolding(TSIn& SIn) : cfCommon(SIn), cfSimple(SIn), cfTurkic(SIn), cfFull(SIn) { SIn.LoadCs(); }
150  	void Load(TSIn& SIn) { cfCommon.Load(SIn); cfSimple.Load(SIn); cfFull.Load(SIn); cfTurkic.Load(SIn); SIn.LoadCs(); }
151  	void Save(TSOut& SOut) const { cfCommon.Save(SOut); cfSimple.Save(SOut); cfFull.Save(SOut); cfTurkic.Save(SOut); SOut.SaveCs(); }
152  	void Clr() { cfCommon.Clr(); cfSimple.Clr(); cfFull.Clr(); cfTurkic.Clr(); }
153  	void LoadTxt(const TStr& fileName);
154  	template<typename TSrcVec, typename TDestCh>
155  	void Fold(const TSrcVec& src, size_t srcIdx, const size_t srcCount,
156  		TVec<TDestCh>& dest, const bool clrDest, const bool full, const bool turkic) const
157  	{
158  		for (const size_t srcEnd = srcIdx + srcCount; srcIdx < srcEnd; )
159  		{
160  			int c = src[TVecIdx(srcIdx)], i; srcIdx++;
161  			if (turkic && ((i = cfTurkic.GetKeyId(c)) >= 0)) { dest.Add(cfTurkic[i]); continue; }
162  			if (full && ((i = cfFull.GetKeyId(c)) >= 0)) { AppendVector(cfFull[i], dest); continue; }
163  			if ((! full) && ((i = cfSimple.GetKeyId(c)) >= 0)) { dest.Add(cfSimple[i]); continue; }
164  			i = cfCommon.GetKeyId(c); if (i >= 0) dest.Add(cfCommon[i]); else dest.Add(c);
165  		}
166  	}
167  	template<typename TSrcVec>
168  	void FoldInPlace(TSrcVec& src, size_t srcIdx, const size_t srcCount, const bool turkic) const
169  	{
170  		for (const size_t srcEnd = srcIdx + srcCount; srcIdx < srcEnd; srcIdx++)
171  		{
172  			int c = src[TVecIdx(srcIdx)], i;
173  			if (turkic && ((i = cfTurkic.GetKeyId(c)) >= 0)) { src[TVecIdx(srcIdx)] = cfTurkic[i]; continue; }
174  			if ((i = cfSimple.GetKeyId(c)) >= 0) { src[TVecIdx(srcIdx)] = cfSimple[i]; continue; }
175  			i = cfCommon.GetKeyId(c); if (i >= 0) src[TVecIdx(srcIdx)] = cfCommon[i];
176  		}
177  	}
178  protected:
179  	void Test(const TIntV& src, const TIntV& expectedDest, const bool full, const bool turkic, FILE *f);
180  public:
181  	void Test();
182  };
183  class TCodecBase;
184  typedef TPt<TCodecBase> PCodecBase;
185  typedef TVec<PCodecBase> TCodecBaseV;
186  class TCodecBase
187  {
188  protected:
189  	TCRef CRef;
190  	friend class TPt<TCodecBase>;
191  public:
192  	virtual ~TCodecBase() { }
193  	template<class TCodecImpl>
194  	static PCodecBase New(); &bsol;* {
195  		return new TCodecWrapper<TCodecImpl>(); } */
196  	virtual TStr GetName() const = 0;
197  	virtual void Test() const { }
198  	virtual size_t ToUnicode(const TIntV& src, size_t srcIdx, const size_t srcCount, TIntV& dest, const bool clrDest = true) const = 0;
199  	virtual size_t ToUnicode(const TStr& src, size_t srcIdx, const size_t srcCount, TIntV& dest, const bool clrDest = true) const = 0;
200  	size_t ToUnicode(const TIntV& src, TIntV& dest, const bool clrDest = true) const { return ToUnicode(src, 0, src.Len(), dest, clrDest); }
201  	size_t ToUnicode(const TStr& src, TIntV& dest, const bool clrDest = true) const { return ToUnicode(src, 0, src.Len(), dest, clrDest); }
202  	virtual size_t FromUnicode(const TIntV& src, size_t srcIdx, const size_t srcCount, TIntV& dest, const bool clrDest = true) const = 0;
203  	virtual size_t FromUnicode(const TIntV& src, size_t srcIdx, const size_t srcCount, TChA& dest, const bool clrDest = true) const = 0;
204  	virtual size_t FromUnicode(const TIntV& src, size_t srcIdx, const size_t srcCount, TStr& dest, const bool clrDest = true) const = 0;
205  	size_t FromUnicode(const TIntV& src, TIntV& dest, const bool clrDest = true) const { return FromUnicode(src, 0, src.Len(), dest, clrDest); }
206  	size_t FromUnicode(const TIntV& src, TChA& dest, const bool clrDest = true) const { return FromUnicode(src, 0, src.Len(), dest, clrDest); }
207  	size_t FromUnicode(const TIntV& src, TStr& dest, const bool clrDest = true) const { return FromUnicode(src, 0, src.Len(), dest, clrDest); }
208  };
209  template<class TCodecImpl_>
210  class TCodecWrapper : public TCodecBase
211  {
212  public:
213  	typedef TCodecImpl_ TCodecImpl;
214  	TCodecImpl impl;
215  public:
216  	virtual TStr GetName() const { return impl.GetName(); }
217  	virtual void Test() const { impl.Test(); }
218  	virtual size_t ToUnicode(const TIntV& src, size_t srcIdx, const size_t srcCount, TIntV& dest, const bool clrDest = true) const {
219  		return impl.ToUnicode(src, srcIdx, srcCount, dest, clrDest); }
220  	virtual size_t ToUnicode(const TStr& src, size_t srcIdx, const size_t srcCount, TIntV& dest, const bool clrDest = true) const {
221  		return impl.ToUnicode(src, srcIdx, srcCount, dest, clrDest); }
222  	virtual size_t FromUnicode(const TIntV& src, size_t srcIdx, const size_t srcCount, TIntV& dest, const bool clrDest = true) const {
223  		return impl.FromUnicode(src, srcIdx, srcCount, dest, clrDest); }
224  	virtual size_t FromUnicode(const TIntV& src, size_t srcIdx, const size_t srcCount, TChA& dest, const bool clrDest = true) const {
225  		return impl.FromUnicode(src, srcIdx, srcCount, dest, clrDest); }
226  	virtual size_t FromUnicode(const TIntV& src, size_t srcIdx, const size_t srcCount, TStr& dest, const bool clrDest = true) const {
227  		TChA buf; size_t retVal = impl.FromUnicode(src, srcIdx, srcCount, buf, false);
228  		if (clrDest) dest += buf.CStr(); else dest = buf.CStr();
229  		return retVal; }
230  };
231  template<class TCodecImpl>
232  PCodecBase TCodecBase::New() {
233    return new TCodecWrapper<TCodecImpl>();
234  }
235  template<class TVector_>
236  class TVecElt
237  {
238  };
239  template<class TDat>
240  class TVecElt<TVec<TDat> >
241  {
242  public:
243  	typedef TVec<TDat> TVector;
244  	typedef TDat TElement;
245  	static inline void Add(TVector& vector, const TElement& element) { vector.Add(element); }
246  };
247  template<>
248  class TVecElt<TChA>
249  {
250  public:
251  	typedef TChA TVector;
252  	typedef char TElement;
253  	static inline void Add(TVector& vector, const TElement& element) { vector += element; }
254  };
255  class TEncoding_ISO8859_1
256  {
257  public:
258  	static inline TStr GetName() { return "ISO-8859-1"; }
259  	static int ToUnicode(int c) { Assert(0 <= c && c <= 255); return c; }
260  	static int FromUnicode(int c) { if (0 <= c && c <= 255) return c; else return -1; }
261  };
262  class TEncoding_ISO8859_2 
263  {
264  public:
265  	static inline TStr GetName() { return "ISO-8859-2"; }
266  	static const int toUnicodeTable[6 * 16], fromUnicodeTable1[14 * 16], fromUnicodeTable2[2 * 16];
267  	static int ToUnicode(int c) { Assert(0 <= c && c <= 255);
268  		if (c < 0xa0) return c; else return toUnicodeTable[c - 0xa0]; }
269  	static int FromUnicode(int c) {
270  		if (0 <= c && c < 0xa0) return c;
271  		else if (0xa0 <= c && c < 0x180) return fromUnicodeTable1[c - 0xa0];
272  		else if (0x2c0 <= c && c < 0x2e0) return fromUnicodeTable2[c - 0x2c0];
273  		else return -1; }
274  };
275  class TEncoding_ISO8859_3
276  {
277  public:
278  	static inline TStr GetName() { return "ISO-8859-3"; }
279  	static const int toUnicodeTable[6 * 16], fromUnicodeTable1[14 * 16], fromUnicodeTable2[2];
280  	static int ToUnicode(int c) { Assert(0 <= c && c <= 255);
281  		if (c < 0xa0) return c; else return toUnicodeTable[c - 0xa0]; }
282  	static int FromUnicode(int c) {
283  		if (0 <= c && c < 0xa0) return c;
284  		else if (0xa0 <= c && c < 0x180) return fromUnicodeTable1[c - 0xa0];
285  		else if (0x2d8 <= c && c < 0x2da) return fromUnicodeTable2[c - 0x2d8];
286  		else return -1; }
287  };
288  class TEncoding_ISO8859_4
289  {
290  public:
291  	static inline TStr GetName() { return "ISO-8859-4"; }
292  	static const int toUnicodeTable[6 * 16], fromUnicodeTable1[14 * 16], fromUnicodeTable2[2 * 16];
293  	static int ToUnicode(int c) { Assert(0 <= c && c <= 255);
294  		if (c < 0xa0) return c; else return toUnicodeTable[c - 0xa0]; }
295  	static int FromUnicode(int c) {
296  		if (0 <= c && c < 0xa0) return c;
297  		else if (0xa0 <= c && c < 0x180) return fromUnicodeTable1[c - 0xa0];
298  		else if (0x2c0 <= c && c < 0x2e0) return fromUnicodeTable2[c - 0x2c0];
299  		else return -1; }
300  };
301  class TEncoding_YuAscii
302  {
303  public:
304  	static const int uniChars[10], yuAsciiChars[10];
305  	static inline TStr GetName() { return "YU-ASCII"; }
306  	static int ToUnicode(int c) { Assert(0 <= c && c <= 255);
307  		for (int i = 0; i < int(sizeof(yuAsciiChars) / sizeof(yuAsciiChars[0])); i++)
308  			if (c == yuAsciiChars[i]) return uniChars[i];
309  		return c; }
310  	static int FromUnicode(int c) {
311  		for (int i = 0; i < int(sizeof(uniChars) / sizeof(uniChars[0])); i++)
312  			if (c == uniChars[i]) return yuAsciiChars[i];
313  			else if(c == yuAsciiChars[i]) return -1;
314  		if (0 <= c && c <= 255) return c; else return -1; }
315  };
316  class TEncoding_CP437 
317  {
318  public:
319  	static inline TStr GetName() { return "CP437"; }
320  	static const int toUnicodeTable[8 * 16], fromUnicodeTable1[6 * 16], fromUnicodeTable2[4 * 16], fromUnicodeTable3[6 * 16], fromUnicodeTable4[11 * 16];
321  	static int ToUnicode(int c) { Assert(0 <= c && c <= 255);
322  		if (c < 0x80) return c; else return toUnicodeTable[c - 0x80]; }
323  	static int FromUnicode(int c) {
324  		if (0 <= c && c < 0x80) return c;
325  		else if (0xa0 <= c && c < 0x100) return fromUnicodeTable1[c - 0xa0];
326  		else if (0x390 <= c && c < 0x3d0) return fromUnicodeTable2[c - 0x390];
327  		else if (0x2210 <= c && c < 0x2270) return fromUnicodeTable3[c - 0x2210];
328  		else if (0x2500 <= c && c < 0x25b0) return fromUnicodeTable4[c - 0x2500];
329  		else if (c == 0x192) return 0x9f;
330  		else if (c == 0x207f) return 0xfc;
331  		else if (c == 0x20a7) return 0x9e;
332  		else if (c == 0x2310) return 0xa9;
333  		else if (c == 0x2320) return 0xf4;
334  		else if (c == 0x2321) return 0xf5;
335  		else return -1; }
336  };
337  class TEncoding_CP852 
338  {
339  public:
340  	static inline TStr GetName() { return "CP852"; }
341  	static const int toUnicodeTable[8 * 16], fromUnicodeTable1[14 * 16], fromUnicodeTable2[2 * 16], fromUnicodeTable3[11 * 16];
342  	static int ToUnicode(int c) { Assert(0 <= c && c <= 255);
343  		if (c < 0x80) return c; else return toUnicodeTable[c - 0x80]; }
344  	static int FromUnicode(int c) {
345  		if (0 <= c && c < 0x80) return c;
346  		else if (0xa0 <= c && c < 0x180) return fromUnicodeTable1[c - 0xa0];
347  		else if (0x2c0 <= c && c < 0x2e0) return fromUnicodeTable2[c - 0x2c0];
348  		else if (0x2500 <= c && c < 0x25b0) return fromUnicodeTable3[c - 0x2500];
349  		else return -1; }
350  };
351  class TEncoding_CP1250 
352  {
353  public:
354  	static inline TStr GetName() { return "CP1250"; }
355  	static const int toUnicodeTable[8 * 16], fromUnicodeTable1[14 * 16], fromUnicodeTable2[2 * 16], fromUnicodeTable3[3 * 16];
356  	static int ToUnicode(int c) { Assert(0 <= c && c <= 255);
357  		if (c < 0x80) return c; else return toUnicodeTable[c - 0x80]; }
358  	static int FromUnicode(int c) {
359  		if (0 <= c && c < 0x80) return c;
360  		else if (0xa0 <= c && c < 0x180) return fromUnicodeTable1[c - 0xa0];
361  		else if (0x2c0 <= c && c < 0x2e0) return fromUnicodeTable2[c - 0x2c0];
362  		else if (0x2010 <= c && c < 0x2040) return fromUnicodeTable3[c - 0x2010];
363  		else if (c == 0x20ac) return 0x80;
364  		else if (c == 0x2122) return 0x99;
365  		else return -1; }
366  };
367  template<class TEncoding_>
368  class T8BitCodec
369  {
370  protected:
371  	typedef TUniVecIdx TVecIdx;
372  public:
373  	typedef TEncoding_ TEncoding;
374  	TUnicodeErrorHandling errorHandling;
375  	int replacementChar;
376  	T8BitCodec() : errorHandling(uehIgnore), replacementChar(TUniCodec::DefaultReplacementChar) { }
377  	T8BitCodec(TUnicodeErrorHandling errorHandling_, int replacementChar_ = TUniCodec::DefaultReplacementChar) :
378  		errorHandling(errorHandling_), replacementChar(replacementChar_) { }
379  	static TStr GetName() { return TEncoding::GetName(); }
380  	void Test() const
381  	{
382  		int nDecoded = 0;
383  		for (int c = 0; c <= 255; c++) {
384  			int cu = TEncoding::ToUnicode(c); if (cu == -1) continue;
385  			nDecoded++;
386  			IAssert(0 <= cu && cu < 0x110000);
387  			int c2 = TEncoding::FromUnicode(cu);
388  			IAssert(c2 == c); }
389  		int nEncoded = 0;
390  		for (int cu = 0; cu < 0x110000; cu++) {
391  			int c = TEncoding::FromUnicode(cu); if (c == -1) continue;
392  			nEncoded++;
393  			IAssert(0 <= c && c <= 255);
394  			int cu2 = TEncoding::ToUnicode(c);
395  			IAssert(cu2 == cu); }
396  		IAssert(nDecoded == nEncoded);
397  	}
398  	template<typename TSrcVec, typename TDestCh>
399  	size_t ToUnicode(
400  		const TSrcVec& src, size_t srcIdx, const size_t srcCount,
401  		TVec<TDestCh>& dest, const bool clrDest = true) const
402  	{
403  		if (clrDest) dest.Clr();
404  		size_t toDo = srcCount;
405  		while (toDo-- > 0) {
406  			int chSrc = ((int) src[TVecIdx(srcIdx)]) & 0xff; srcIdx++;
407  			int chDest = TEncoding::ToUnicode(chSrc);
408  			dest.Add(chDest); }
409  		return srcCount;
410  	}
411  	template<typename TSrcVec, typename TDestCh>
412  	size_t ToUnicode(const TSrcVec& src, TVec<TDestCh>& dest, const bool clrDest = true) const { return ToUnicode(src, 0, src.Len(), dest, clrDest); }
413  	size_t ToUnicode(const TIntV& src, TIntV& dest, const bool clrDest = true) const { return ToUnicode(src, 0, src.Len(), dest, clrDest); }
414  	size_t ToUnicode(const TStr& src, TIntV& dest, const bool clrDest = true) const { return ToUnicode(src, 0, src.Len(), dest, clrDest); }
415  	template<typename TSrcVec, typename TDestVec>
416  	size_t FromUnicode(
417  		const TSrcVec& src, size_t srcIdx, const size_t srcCount,
418  		TDestVec& dest, const bool clrDest = true) const
419  	{
420  		typedef typename TVecElt<TDestVec>::TElement TDestCh;
421  		if (clrDest) dest.Clr();
422  		size_t toDo = srcCount, nEncoded = 0;
423  		while (toDo-- > 0) {
424  			int chSrc = (int) src[TVecIdx(srcIdx)]; srcIdx++;
425  			int chDest = TEncoding::FromUnicode(chSrc);
426  			if (chDest < 0) {
427  				switch (errorHandling) {
428  				case uehThrow: throw TUnicodeException(srcIdx - 1, chSrc, "Invalid character for encoding into " + GetName() + ".");
429  				case uehAbort: return nEncoded;
430  				case uehReplace: TVecElt<TDestVec>::Add(dest, TDestCh(replacementChar)); continue;
431  				case uehIgnore: continue;
432  				default: Fail; } }
433  			TVecElt<TDestVec>::Add(dest, TDestCh(chDest)); nEncoded++; }
434  		return nEncoded;
435  	}
436  	template<typename TSrcVec, typename TDestVec>
437  	size_t FromUnicode(const TSrcVec& src, TDestVec& dest, const bool clrDest = true) const { return FromUnicode(src, 0, src.Len(), dest, clrDest); }
438  	size_t UniToStr(const TIntV& src, size_t srcIdx, const size_t srcCount, TStr& dest, const bool clrDest = true) const {
439  		TChA buf; size_t retVal = FromUnicode(src, srcIdx, srcCount, buf, false);
440  		if (clrDest) dest += buf.CStr(); else dest = buf.CStr();
441  		return retVal; }
442  	size_t UniToStr(const TIntV& src, TStr& dest, const bool clrDest = true) const { return UniToStr(src, 0, src.Len(), dest, clrDest); }
443  };
444  typedef T8BitCodec<TEncoding_ISO8859_1> TCodec_ISO8859_1;
445  typedef T8BitCodec<TEncoding_ISO8859_2> TCodec_ISO8859_2;
446  typedef T8BitCodec<TEncoding_ISO8859_3> TCodec_ISO8859_3;
447  typedef T8BitCodec<TEncoding_ISO8859_4> TCodec_ISO8859_4;
448  typedef T8BitCodec<TEncoding_CP852> TCodec_CP852;
449  typedef T8BitCodec<TEncoding_CP437> TCodec_CP437;
450  typedef T8BitCodec<TEncoding_CP1250> TCodec_CP1250;
451  typedef T8BitCodec<TEncoding_YuAscii> TCodec_YuAscii;
452  typedef enum TUniChCategory_
453  {
454  #define DefineUniCat(cat, c) uc ## cat = (int(uchar(c)) & 0xff)
455  	DefineUniCat(Letter, 'L'),             
456  	DefineUniCat(Mark, 'M'),
457  	DefineUniCat(Number, 'N'),
458  	DefineUniCat(Punctuation, 'P'),
459  	DefineUniCat(Symbol, 'S'),
460  	DefineUniCat(Separator, 'Z'),
461  	DefineUniCat(Other, 'C')
462  #undef DefineUniCat
463  }
464  TUniChCategory;
465  typedef enum TUniChSubCategory_
466  {
467  #define DefineUniSubCat(cat, subCat, c) uc ## cat ## subCat = ((uc ## cat) << 8) | (int(uchar(c)) & 0xff)
468  	DefineUniSubCat(Letter, Uppercase, 'u'),            
469  	DefineUniSubCat(Letter, Lowercase, 'l'),
470  	DefineUniSubCat(Letter, Titlecase, 't'),
471  	DefineUniSubCat(Letter, Modifier, 'm'),
472  	DefineUniSubCat(Letter, Other, 'o'),
473  	DefineUniSubCat(Mark, Nonspacing, 'n'),
474  	DefineUniSubCat(Mark, SpacingCombining, 'c'),
475  	DefineUniSubCat(Mark, Enclosing, 'e'),
476  	DefineUniSubCat(Number, DecimalDigit, 'd'),
477  	DefineUniSubCat(Number, Letter, 'l'),
478  	DefineUniSubCat(Number, Other, 'o'),
479  	DefineUniSubCat(Punctuation, Connector, 'c'),
480  	DefineUniSubCat(Punctuation, Dash, 'd'),
481  	DefineUniSubCat(Punctuation, Open, 's'),
482  	DefineUniSubCat(Punctuation, Close, 'e'),
483  	DefineUniSubCat(Punctuation, InitialQuote, 'i'),
484  	DefineUniSubCat(Punctuation, FinalQuote, 'f'),
485  	DefineUniSubCat(Punctuation, Other, 'o'),
486  	DefineUniSubCat(Symbol, Math, 'm'),
487  	DefineUniSubCat(Symbol, Currency, 'c'),
488  	DefineUniSubCat(Symbol, Modifier, 'k'),
489  	DefineUniSubCat(Symbol, Other, 'o'),
490  	DefineUniSubCat(Separator, Space, 's'),
491  	DefineUniSubCat(Separator, Line, 'l'),
492  	DefineUniSubCat(Separator, Paragraph, 'p'),
493  	DefineUniSubCat(Other, Control, 'c'),
494  	DefineUniSubCat(Other, Format, 'f'),
495  	DefineUniSubCat(Other, Surrogate, 's'),
496  	DefineUniSubCat(Other, PrivateUse, 'o'),
497  	DefineUniSubCat(Other, NotAssigned, 'n')
498  }
499  TUniChSubCategory;
500  typedef enum TUniChFlags_
501  {
502  	ucfCompatibilityDecomposition = 1, 
503  	ucfCompositionExclusion = 1 << 1,       
504  	ucfWbFormat = 1 << 2,
505  	ucfWbKatakana = 1 << 3,
506  	ucfWbALetter = 1 << 4,
507  	ucfWbMidLetter = 1 << 5,
508  	ucfWbMidNum = 1 << 6,
509  	ucfWbNumeric = 1 << 7,
510  	ucfWbExtendNumLet = 1 << 8,
511  	ucfSbSep = 1 << 9,
512  	ucfSbFormat = 1 << 10,
513  	ucfSbSp = 1 << 11,
514  	ucfSbLower = 1 << 12,
515  	ucfSbUpper = 1 << 13,
516  	ucfSbOLetter = 1 << 14,
517  	ucfSbNumeric = 1 << 15,
518  	ucfSbATerm = 1 << 16,
519  	ucfSbSTerm = 1 << 17,
520  	ucfSbClose = 1 << 18,
521  	ucfSbMask = ucfSbSep | ucfSbFormat | ucfSbSp | ucfSbLower | ucfSbUpper | ucfSbOLetter | ucfSbNumeric | ucfSbATerm | ucfSbSTerm | ucfSbClose,
522  	ucfWbMask = ucfWbFormat | ucfWbKatakana | ucfWbALetter | ucfWbMidLetter | ucfWbMidNum | ucfWbNumeric | ucfWbExtendNumLet | ucfSbSep,
523  	ucfDcpAlphabetic = 1 << 19,
524  	ucfDcpDefaultIgnorableCodePoint = 1 << 20,
525  	ucfDcpLowercase = 1 << 21,
526  	ucfDcpGraphemeBase = 1 << 22,
527  	ucfDcpGraphemeExtend = 1 << 23,
528  	ucfDcpIdStart = 1 << 24,
529  	ucfDcpIdContinue = 1 << 25,
530  	ucfDcpMath = 1 << 26,
531  	ucfDcpUppercase = 1 << 27,
532  	ucfDcpXidStart = 1 << 28,
533  	ucfDcpXidContinue = 1 << 29,
534  	ucfDcpMask = ucfDcpAlphabetic | ucfDcpDefaultIgnorableCodePoint | ucfDcpLowercase | ucfDcpGraphemeBase | ucfDcpGraphemeExtend |
535  		ucfDcpIdStart | ucfDcpIdContinue | ucfDcpMath | ucfDcpUppercase | ucfDcpXidStart | ucfDcpXidContinue,
536  }
537  TUniChFlags;
538  typedef enum TUniChProperties_
539  {
540  	ucfPrAsciiHexDigit = 1,
541  	ucfPrBidiControl = 2,
542  	ucfPrDash = 4,
543  	ucfPrDeprecated = 8,
544  	ucfPrDiacritic = 0x10,
545  	ucfPrExtender = 0x20,
546  	ucfPrGraphemeLink = 0x40,
547  	ucfPrHexDigit = 0x80,
548  	ucfPrHyphen = 0x100,
549  	ucfPrIdeographic = 0x200,
550  	ucfPrJoinControl = 0x400,
551  	ucfPrLogicalOrderException = 0x800,
552  	ucfPrNoncharacterCodePoint = 0x1000,
553  	ucfPrPatternSyntax = 0x2000,
554  	ucfPrPatternWhiteSpace = 0x4000,
555  	ucfPrQuotationMark = 0x8000,
556  	ucfPrSoftDotted = 0x10000,
557  	ucfPrSTerm = 0x20000,
558  	ucfPrTerminalPunctuation = 0x40000,
559  	ucfPrVariationSelector = 0x80000,
560  	ucfPrWhiteSpace = 0x100000
561  }
562  TUniChProperties;
563  typedef enum TUniChPropertiesX_
564  {
565  	ucfPxOtherAlphabetic = 1,
566  	ucfPxOtherDefaultIgnorableCodePoint = 2,
567  	ucfPxOtherGraphemeExtend = 4,
568  	ucfPxOtherIdContinue = 8,
569  	ucfPxOtherIdStart = 0x10,
570  	ucfPxOtherLowercase = 0x20,
571  	ucfPxOtherMath = 0x40,
572  	ucfPxOtherUppercase = 0x80,
573  	ucfPxIdsBinaryOperator = 0x100,
574  	ucfPxIdsTrinaryOperator = 0x200,
575  	ucfPxRadical = 0x400,
576  	ucfPxUnifiedIdeograph = 0x800
577  }
578  TUniChPropertiesX;
579  class TUniChInfo
580  {
581  public:
582  	enum { 
583  		ccStarter = 0, 
584  		ccOverlaysAndInterior = 1,
585  		ccNuktas = 7,
586  		ccHiraganaKatakanaVoicingMarks = 8,
587  		ccViramas = 9,
588  		ccFixedPositionStart = 10, 
589  		ccFixedPositionEnd = 199, 
590  		ccBelowLeftAttached = 200,
591  		ccBelowAttached = 202,
592  		ccBelowRightAttached = 204,
593  		ccLeftAttached = 208, 
594  		ccRightAttached = 210,
595  		ccAboveLeftAttached = 212,
596  		ccAboveAttached = 214,
597  		ccAboveRightAttached = 216,
598  		ccBelowLeft = 218,
599  		ccBelow = 220,
600  		ccBelowRight = 222,
601  		ccLeft = 224, 
602  		ccRight = 226,
603  		ccAboveLeft = 228,
604  		ccAbove = 230,
605  		ccAboveRight = 232,
606  		ccDoubleBelow = 233,
607  		ccDoubleAbove = 234,
608  		ccBelowIotaSubscript = 240, 
609  		ccInvalid = 255 
610  	};
611  	char chCat, chSubCat; 
612  	uchar combClass; 
613  	TUniChCategory cat; 
614  	TUniChSubCategory subCat; 
615  	signed char script; 
616  	int simpleUpperCaseMapping, simpleLowerCaseMapping, simpleTitleCaseMapping; 
617  	int decompOffset; 
618  	int nameOffset; 
619  	int flags; 
620  	int properties; 
621  	int propertiesX; 
622  	ushort lineBreak; 
623  	static inline ushort GetLineBreakCode(char c1, char c2) { return ((static_cast<ushort>(static_cast<uchar>(c1)) & 0xff) << 8) | ((static_cast<ushort>(static_cast<uchar>(c2)) & 0xff)); }
624  	static const ushort LineBreak_Unknown, LineBreak_ComplexContext, LineBreak_Numeric, LineBreak_InfixNumeric, LineBreak_Quotation;
625  public:
626  	void InitAfterLoad() {
627  		cat = (TUniChCategory) chCat;
628  		subCat = (TUniChSubCategory) (((static_cast<int>(static_cast<uchar>(chCat)) & 0xff) << 8) | (static_cast<int>(static_cast<uchar>(chSubCat)) & 0xff)); }
629  	void SetCatAndSubCat(const TUniChSubCategory catAndSubCat) {
630  		cat = (TUniChCategory) ((int(catAndSubCat) >> 8) & 0xff);
631  		subCat = catAndSubCat;
632  		chCat = (char) cat; chSubCat = (char) (int(subCat) & 0xff); }
633  	friend class TUniChDb;
634  	static inline void LoadUShort(TSIn& SIn, ushort& u) { SIn.LoadBf(&u, sizeof(u)); }
635  	static inline void LoadSChar(TSIn& SIn, signed char& u) { SIn.LoadBf(&u, sizeof(u)); }
636  	static inline void SaveUShort(TSOut& SOut, ushort u) { SOut.SaveBf(&u, sizeof(u)); }
637  	static inline void SaveSChar(TSOut& SOut, signed char u) { SOut.SaveBf(&u, sizeof(u)); }
638  public:
639  	void Save(TSOut& SOut) const {
640  		SOut.Save(chCat); SOut.Save(chSubCat); SOut.Save(combClass); SaveSChar(SOut, script);
641  		SOut.Save(simpleUpperCaseMapping); SOut.Save(simpleLowerCaseMapping); SOut.Save(simpleTitleCaseMapping);
642  		SOut.Save(decompOffset); SOut.Save(nameOffset);
643  		SOut.Save(flags); SOut.Save(properties); SOut.Save(propertiesX); SaveUShort(SOut, lineBreak); }
644  	void Load(TSIn& SIn) {
645  		SIn.Load(chCat); SIn.Load(chSubCat); SIn.Load(combClass); LoadSChar(SIn, script);
646  		SIn.Load(simpleUpperCaseMapping); SIn.Load(simpleLowerCaseMapping); SIn.Load(simpleTitleCaseMapping);
647  		SIn.Load(decompOffset); SIn.Load(nameOffset);
648  		SIn.Load(flags); SIn.Load(properties); SIn.Load(propertiesX); LoadUShort(SIn, lineBreak); InitAfterLoad(); }
649  	explicit TUniChInfo(TSIn& SIn) { Load(SIn); }
650  	TUniChInfo() : chCat(char(ucOther)), chSubCat(char(ucOtherNotAssigned & 0xff)), combClass(ccInvalid),
651  		script(-1),simpleUpperCaseMapping(-1), simpleLowerCaseMapping(-1), simpleTitleCaseMapping(-1),
652  		decompOffset(-1), nameOffset(-1), flags(0), properties(0), propertiesX(0), lineBreak(LineBreak_Unknown) {
653  		InitAfterLoad(); }
654  	bool IsDcpFlag(const TUniChFlags flag) const { Assert((flag & ucfDcpMask) == flag); return (flags & flag) == flag; }
655  	void ClrDcpFlags() { flags = flags & ~ucfDcpMask; }
656  	void SetDcpFlag(const TUniChFlags flag) { Assert((flag & ucfDcpMask) == flag); flags |= flag; }
657  	bool IsAlphabetic() const { return IsDcpFlag(ucfDcpAlphabetic); }
658  	bool IsUppercase() const { return IsDcpFlag(ucfDcpUppercase); }
659  	bool IsLowercase() const { return IsDcpFlag(ucfDcpLowercase); }
660  	bool IsMath() const { return IsDcpFlag(ucfDcpMath); }
661  	bool IsDefaultIgnorable() const { return IsDcpFlag(ucfDcpDefaultIgnorableCodePoint); }
662  	bool IsGraphemeBase() const { return IsDcpFlag(ucfDcpGraphemeBase); }
663  	bool IsGraphemeExtend() const { return IsDcpFlag(ucfDcpGraphemeExtend); }
664  	bool IsIdStart() const { return IsDcpFlag(ucfDcpIdStart); }
665  	bool IsIdContinue() const { return IsDcpFlag(ucfDcpIdContinue); }
666  	bool IsXidStart() const { return IsDcpFlag(ucfDcpXidStart); }
667  	bool IsXidContinue() const { return IsDcpFlag(ucfDcpXidContinue); }
668  	bool IsProperty(const TUniChProperties flag) const { return (properties & flag) == flag; }
669  	void SetProperty(const TUniChProperties flag) { properties |= flag; }
670  	bool IsAsciiHexDigit() const { return IsProperty(ucfPrAsciiHexDigit); }
671  	bool IsBidiControl() const { return IsProperty(ucfPrBidiControl); }
672  	bool IsDash() const { return IsProperty(ucfPrDash); }
673  	bool IsDeprecated() const { return IsProperty(ucfPrDeprecated); }
674  	bool IsDiacritic() const { return IsProperty(ucfPrDiacritic); }
675  	bool IsExtender() const { return IsProperty(ucfPrExtender); }
676  	bool IsGraphemeLink() const { return IsProperty(ucfPrGraphemeLink); }
677  	bool IsHexDigit() const { return IsProperty(ucfPrHexDigit); }
678  	bool IsHyphen() const { return IsProperty(ucfPrHyphen); }
679  	bool IsIdeographic() const { return IsProperty(ucfPrIdeographic); }
680  	bool IsJoinControl() const { return IsProperty(ucfPrJoinControl); }
681  	bool IsLogicalOrderException() const { return IsProperty(ucfPrLogicalOrderException); }
682  	bool IsNoncharacter() const { return IsProperty(ucfPrNoncharacterCodePoint); }
683  	bool IsQuotationMark() const { return IsProperty(ucfPrQuotationMark); }
684  	bool IsSoftDotted() const { return IsProperty(ucfPrSoftDotted); }
685  	bool IsSTerminal() const { return IsProperty(ucfPrSTerm); }
686  	bool IsTerminalPunctuation() const { return IsProperty(ucfPrTerminalPunctuation); }
687  	bool IsVariationSelector() const { return IsProperty(ucfPrVariationSelector); }
688  	bool IsWhiteSpace() const { return IsProperty(ucfPrWhiteSpace); }
689  	bool IsPropertyX(const TUniChPropertiesX flag) const { return (propertiesX & flag) == flag; }
690  	void SetPropertyX(const TUniChPropertiesX flag) { propertiesX |= flag; }
691  	bool IsCompositionExclusion() const { return (flags & ucfCompositionExclusion) == ucfCompositionExclusion; }
692  	bool IsCompatibilityDecomposition() const { return (flags & ucfCompatibilityDecomposition) == ucfCompatibilityDecomposition; }
693  	bool IsWbFlag(const TUniChFlags flag) const { Assert((flag & ucfWbMask) == flag); return (flags & flag) == flag; }
694  	void ClrWbAndSbFlags() { flags = flags & ~(ucfWbMask | ucfSbMask); }
695  	void SetWbFlag(const TUniChFlags flag) { Assert((flag & ucfWbMask) == flag); flags |= flag; }
696  	int GetWbFlags() const { return flags & ucfWbMask; }
697  	bool IsWbFormat() const { return IsWbFlag(ucfWbFormat); }
698  	TStr GetWbFlagsStr() const { return GetWbFlagsStr(GetWbFlags()); }
699  	static TStr GetWbFlagsStr(const int flags) { return TStr("") + (flags & ucfWbALetter ? "A" : "") +
700  		(flags & ucfWbFormat ? "F" : "") + (flags & ucfWbKatakana ? "K" : "") + (flags & ucfWbMidLetter ? "M" : "") +
701  		(flags & ucfWbMidNum ? "m" : "") + (flags & ucfWbNumeric ? "N" : "") + (flags & ucfWbExtendNumLet ? "E" : ""); }
702  	bool IsSbFlag(const TUniChFlags flag) const { Assert((flag & ucfSbMask) == flag); return (flags & flag) == flag; }
703  	void SetSbFlag(const TUniChFlags flag) { Assert((flag & ucfSbMask) == flag); flags |= flag; }
704  	int GetSbFlags() const { return flags & ucfSbMask; }
705  	bool IsSbFormat() const { return IsSbFlag(ucfSbFormat); }
706  	TStr GetSbFlagsStr() const { return GetSbFlagsStr(GetSbFlags()); }
707  	static TStr GetSbFlagsStr(const int flags) { return TStr("") + (flags & ucfSbSep ? "S" : "") +
708  		(flags & ucfSbFormat ? "F" : "") + (flags & ucfSbSp ? "_" : "") + (flags & ucfSbLower ? "L" : "") +
709  		(flags & ucfSbUpper ? "U" : "") + (flags & ucfSbOLetter ? "O" : "") + (flags & ucfSbNumeric ? "N" : "") +
710  		(flags & ucfSbATerm ? "A" : "") + (flags & ucfSbSTerm ? "T" : "") + (flags & ucfSbClose ? "C" : ""); }
711  	bool IsSbSep() const { return (flags & ucfSbSep) == ucfSbSep; }
712  	bool IsGbExtend() const { return IsGraphemeExtend(); }
713  	bool IsCased() const { return IsUppercase() || IsLowercase() || (subCat == ucLetterTitlecase); }
714  	TUniChCategory GetCat() const { return (TUniChCategory) cat; }
715  	TUniChSubCategory GetSubCat() const { return (TUniChSubCategory) subCat; }
716  	bool IsCurrency() const { return subCat == ucSymbolCurrency; }
717  	bool IsPrivateUse() const { return subCat == ucOtherPrivateUse; }
718  	bool IsSurrogate() const { return subCat == ucOtherSurrogate; }
719  	inline static bool IsValidSubCat(const char chCat, const char chSubCat) {
720  		static const char s[] = "LuLlLtLmLoMnMcMeNdNlNoPcPdPsPePiPfPoSmScSkSoZsZlZpCcCfCsCoCn";
721  		for (const char *p = s; *p; p += 2)
722  			if (chCat == p[0] && chSubCat == p[1]) return true;
723  		return false; }
724  };
725  template<typename TItem_>
726  class TUniTrie
727  {
728  public:
729  	typedef TItem_ TItem;
730  protected:
731  	class TNode {
732  	public:
733  		TItem item;
734  		int child, sib;
735  		bool terminal;
736  		TNode() : child(-1), sib(-1), terminal(false) { }
737  		TNode(const TItem& item_, const int child_, const int sib_, const bool terminal_) : item(item_), child(child_), sib(sib_), terminal(terminal_) { }
738  	};
739  	typedef TVec<TNode> TNodeV;
740  	typedef TPair<TItem, TItem> TItemPr;
741  	typedef TTriple<TItem, TItem, TItem> TItemTr;
742  	typedef TUniVecIdx TVecIdx;
743  	THash<TItem, TVoid> singles; 
744  	THash<TItemPr, TVoid> pairs;
745  	THash<TItemTr, TInt> roots;
746  	TNodeV nodes;
747  public:
748  	TUniTrie() { }
749  	void Clr() { singles.Clr(); pairs.Clr(); roots.Clr(); nodes.Clr(); }
750  	bool Empty() const { return singles.Empty() && pairs.Empty() && roots.Empty(); }
751  	bool Has1Gram(const TItem& item) const { return singles.IsKey(item); }
752  	bool Has2Gram(const TItem& last, const TItem& butLast) const { return pairs.IsKey(TItemPr(last, butLast)); }
753  	int Get3GramRoot(const TItem& last, const TItem& butLast, const TItem& butButLast) const {
754  		int keyId = roots.GetKeyId(TItemTr(last, butLast, butButLast));
755  		if (keyId < 0) return 0; else return roots[keyId]; }
756  	int GetChild(const int parentIdx, const TItem& item) const {
757  		for (int childIdx = nodes[parentIdx].child; childIdx >= 0; ) {
758  			const TNode &node = nodes[childIdx];
759  			if (node.item == item) return childIdx;
760  			childIdx = node.sib; }
761  		return -1; }
762  	bool IsNodeTerminal(const int nodeIdx) const { return nodes[nodeIdx].terminal; }
763  	template<typename TSrcVec>
764  	void Add(const TSrcVec& src, const size_t srcIdx, const size_t srcCount)
765  	{
766  		IAssert(srcCount > 0);
767  		if (srcCount == 1) { singles.AddKey(TItem(src[TVecIdx(srcIdx)])); return; }
768  		if (srcCount == 2) { pairs.AddKey(TItemPr(TItem(src[TVecIdx(srcIdx + 1)]), TItem(src[TVecIdx(srcIdx)]))); return; }
769  		size_t srcLast = srcIdx + (srcCount - 1);
770  		TItemTr tr = TItemTr(TItem(src[TVecIdx(srcLast)]), TItem(src[TVecIdx(srcLast - 1)]), TItem(src[TVecIdx(srcLast - 2)]));
771  		int keyId = roots.GetKeyId(tr), curNodeIdx = -1;
772  		if (keyId >= 0) curNodeIdx = roots[keyId];
773  		else { curNodeIdx = nodes.Add(TNode(TItem(0), -1, -1, false)); roots.AddDat(tr, curNodeIdx); }
774  		if (srcCount > 3) for (size_t srcPos = srcLast - 3; ; )
775  		{
776  			const TItem curItem = src[TVecIdx(srcPos)];
777  			int childNodeIdx = nodes[curNodeIdx].child;
778  			while (childNodeIdx >= 0) {
779  				TNode &childNode = nodes[childNodeIdx];
780  				if (childNode.item == curItem) break;
781  				childNodeIdx = childNode.sib; }
782  			if (childNodeIdx < 0) {
783  				childNodeIdx = nodes.Add(TNode(curItem, -1, nodes[curNodeIdx].child, false));
784  				nodes[curNodeIdx].child = childNodeIdx; }
785  			curNodeIdx = childNodeIdx;
786  			if (srcPos == srcIdx) break; else srcPos--;
787  		}
788  		nodes[curNodeIdx].terminal = true;
789  	}
790  	template<typename TSrcVec>
791  	void Add(const TSrcVec& src) { Add(src, 0, (size_t) src.Len()); }
792  };
793  class TUniChDb
794  {
795  protected:
796  	void InitAfterLoad();
797  	typedef TUniVecIdx TVecIdx;
798  public:
799  	THash<TInt, TUniChInfo> h; 
800  	TStrPool charNames;
801  	TStrIntH scripts; 
802  	TIntV decompositions;
803  	THash<TIntPr, TInt> inverseDec;
804  	TUniCaseFolding caseFolding;
805  	TIntIntVH specialCasingLower, specialCasingUpper, specialCasingTitle;
806  	int scriptUnknown; 
807  	TUniChDb() : scriptUnknown(-1) { }
808  	explicit TUniChDb(TSIn& SIn) { Load(SIn); }
809  	void Clr() {
810  		h.Clr(); charNames.Clr(); decompositions.Clr(); inverseDec.Clr(); caseFolding.Clr();
811  		specialCasingLower.Clr(); specialCasingUpper.Clr(); specialCasingTitle.Clr();
812  		scripts.Clr(); }
813  	void Save(TSOut& SOut) const {
814  		h.Save(SOut); charNames.Save(SOut); decompositions.Save(SOut);
815  		inverseDec.Save(SOut); caseFolding.Save(SOut); scripts.Save(SOut);
816  		specialCasingLower.Save(SOut); specialCasingUpper.Save(SOut); specialCasingTitle.Save(SOut);
817  		SOut.SaveCs(); }
818  	void Load(TSIn& SIn) {
819  		h.Load(SIn); charNames.~TStrPool(); new (&charNames) TStrPool(SIn);
820  		decompositions.Load(SIn);
821  		inverseDec.Load(SIn); caseFolding.Load(SIn); scripts.Load(SIn);
822  		specialCasingLower.Load(SIn); specialCasingUpper.Load(SIn); specialCasingTitle.Load(SIn);
823  		SIn.LoadCs(); InitAfterLoad(); }
824  	void LoadBin(const TStr& fnBin) {
825  		PSIn SIn = TFIn::New(fnBin); Load(*SIn); }
826  	void Test(const TStr& basePath);
827  	static TStr GetCaseFoldingFn() { return "CaseFolding.txt"; }
828  	static TStr GetSpecialCasingFn() { return "SpecialCasing.txt"; }
829  	static TStr GetUnicodeDataFn() { return "UnicodeData.txt"; }
830  	static TStr GetCompositionExclusionsFn() { return "CompositionExclusions.txt"; }
831  	static TStr GetScriptsFn() { return "Scripts.txt"; }
832  	static TStr GetDerivedCorePropsFn() { return "DerivedCoreProperties.txt"; }
833  	static TStr GetLineBreakFn() { return "LineBreak.txt"; }
834  	static TStr GetPropListFn() { return "PropList.txt"; }
835  	static TStr GetAuxiliaryDir() { return "auxiliary"; }
836  	static TStr GetWordBreakTestFn() { return "WordBreakTest.txt"; }
837  	static TStr GetWordBreakPropertyFn() { return "WordBreakProperty.txt"; }
838  	static TStr GetSentenceBreakTestFn() { return "SentenceBreakTest.txt"; }
839  	static TStr GetSentenceBreakPropertyFn() { return "SentenceBreakProperty.txt"; }
840  	static TStr GetNormalizationTestFn() { return "NormalizationTest.txt"; }
841  	static TStr GetBinFn() { return "UniChDb.bin"; } 
842  	static TStr GetScriptNameUnknown() { return "Unknown"; }
843  	static TStr GetScriptNameKatakana() { return "Katakana"; }
844  	static TStr GetScriptNameHiragana() { return "Hiragana"; }
845  	const TStr& GetScriptName(const int scriptId) const { return scripts.GetKey(scriptId); }
846  	int GetScriptByName(const TStr& scriptName) const { return scripts.GetKeyId(scriptName); }
847  	int GetScript(const TUniChInfo& ci) const { int s = ci.script; if (s < 0) s = scriptUnknown; return s; }
848  	int GetScript(const int cp) const { int i = h.GetKeyId(cp); if (i < 0) return scriptUnknown; else return GetScript(h[i]); }
849  	const char *GetCharName(const int cp) const { int i = h.GetKeyId(cp); if (i < 0) return 0; int ofs = h[i].nameOffset; return ofs < 0 ? 0 : charNames.GetCStr(ofs); }
850  	TStr GetCharNameS(const int cp) const {
851  		const char *p = GetCharName(cp); if (p) return p;
852  		char buf[20]; sprintf(buf, "U+%04x", cp); return TStr(buf); }
853  	template<class TSrcVec> void PrintCharNames(FILE *f, const TSrcVec& src, size_t srcIdx, const size_t srcCount, const TStr& prefix) const {
854  		if (! f) f = stdout;
855  		for (const size_t srcEnd = srcIdx + srcCount; srcIdx < srcEnd; srcIdx++) {
856  			fprintf(f, "%s", prefix.CStr());
857  			int cp = src[TVecIdx(srcIdx)]; fprintf(f, (cp >= 0x10000 ? "U+%05x" : "U+%04x "), cp);
858  			fprintf(f, " %s\n", GetCharNameS(cp).CStr()); }}
859  	template<class TSrcVec> void PrintCharNames(FILE *f, const TSrcVec& src, const TStr& prefix) const { PrintCharNames(f, src, 0, src.Len(), prefix); }
860  	bool IsGetChInfo(const int cp, TUniChInfo& ChInfo) {
861  		int i = h.GetKeyId(cp);
862  		if (i < 0) return false; else { ChInfo=h[i]; return true; }}
863  	TUniChCategory GetCat(const int cp) const { int i = h.GetKeyId(cp); if (i < 0) return ucOther; else return h[i].cat; }
864  	TUniChSubCategory GetSubCat(const int cp) const { int i = h.GetKeyId(cp); if (i < 0) return ucOtherNotAssigned; else return h[i].subCat; }
865  	bool IsWbFlag(const int cp, const TUniChFlags flag) const { int i = h.GetKeyId(cp); if (i < 0) return false; else return h[i].IsWbFlag(flag); }
866  	int GetWbFlags(const int cp) const { int i = h.GetKeyId(cp); if (i < 0) return 0; else return h[i].GetWbFlags(); }
867  	bool IsSbFlag(const int cp, const TUniChFlags flag) const { int i = h.GetKeyId(cp); if (i < 0) return false; else return h[i].IsSbFlag(flag); }
868  	int GetSbFlags(const int cp) const { int i = h.GetKeyId(cp); if (i < 0) return 0; else return h[i].GetSbFlags(); }
869  #define ___UniFwd1(name) bool name(const int cp) const { int i = h.GetKeyId(cp); if (i < 0) return false; else return h[i].name(); }
870  #define ___UniFwd2(name1, name2) ___UniFwd1(name1) ___UniFwd1(name2)
871  #define ___UniFwd3(name1, name2, name3) ___UniFwd2(name1, name2) ___UniFwd1(name3)
872  #define ___UniFwd4(name1, name2, name3, name4) ___UniFwd3(name1, name2, name3) ___UniFwd1(name4)
873  #define ___UniFwd5(name1, name2, name3, name4, name5) ___UniFwd4(name1, name2, name3, name4) ___UniFwd1(name5)
874  #define DECLARE_FORWARDED_PROPERTY_METHODS \
875  	___UniFwd5(IsAsciiHexDigit, IsBidiControl, IsDash, IsDeprecated, IsDiacritic) \
876  	___UniFwd5(IsExtender, IsGraphemeLink, IsHexDigit, IsHyphen, IsIdeographic)  \
877  	___UniFwd5(IsJoinControl, IsLogicalOrderException, IsNoncharacter, IsQuotationMark, IsSoftDotted)  \
878  	___UniFwd4(IsSTerminal, IsTerminalPunctuation, IsVariationSelector, IsWhiteSpace)  \
879  	___UniFwd5(IsAlphabetic, IsUppercase, IsLowercase, IsMath, IsDefaultIgnorable)  \
880  	___UniFwd4(IsGraphemeBase, IsGraphemeExtend, IsIdStart, IsIdContinue)  \
881  	___UniFwd2(IsXidStart, IsXidContinue)  \
882  	___UniFwd3(IsCompositionExclusion, IsCompatibilityDecomposition, IsSbSep)  \
883  	___UniFwd1(IsGbExtend)  \
884  	___UniFwd2(IsCased, IsCurrency)
885  	DECLARE_FORWARDED_PROPERTY_METHODS
886  #undef ___UniFwd1
887  	bool IsPrivateUse(const int cp) const {
888  		int i = h.GetKeyId(cp); if (i >= 0) return h[i].IsPrivateUse();
889  		return (0xe000 <= cp && cp <= 0xf8ff) ||  
890  			(0xf0000 <= cp && cp <= 0xffffd) || (0x100000 <= cp && cp <= 0x10fffd); }
891  	bool IsSurrogate(const int cp) const {
892  		int i = h.GetKeyId(cp); if (i >= 0) return h[i].IsSurrogate();
893  		return 0xd800 <= cp && cp <= 0xdcff; }
894  	int GetCombiningClass(const int cp) const { int i = h.GetKeyId(cp); if (i < 0) return TUniChInfo::ccStarter; else return h[i].combClass; }
895  	enum {
896          HangulSBase = 0xAC00, HangulLBase = 0x1100, HangulVBase = 0x1161, HangulTBase = 0x11A7,
897          HangulLCount = 19, HangulVCount = 21, HangulTCount = 28,
898          HangulNCount = HangulVCount * HangulTCount,   
899          HangulSCount = HangulLCount * HangulNCount   
900  	};
901  protected:
902  	static bool IsWbIgnored(const TUniChInfo& ci) { return ci.IsGbExtend() || ci.IsWbFormat(); }
903  	bool IsWbIgnored(const int cp) const { int i = h.GetKeyId(cp); if (i < 0) return false; else return IsWbIgnored(h[i]); }
904  	template<typename TSrcVec> void WbFindCurOrNextNonIgnored(const TSrcVec& src, size_t& position, const size_t srcEnd) const {
905  		while (position < srcEnd && IsWbIgnored(src[TVecIdx(position)])) position++; }
906  	template<typename TSrcVec> void WbFindNextNonIgnored(const TSrcVec& src, size_t& position, const size_t srcEnd) const {
907  		if (position >= srcEnd) return;
908  		position++; while (position < srcEnd && IsWbIgnored(src[TVecIdx(position)])) position++; }
909  	template<typename TSrcVec> void WbFindNextNonIgnoredS(const TSrcVec& src, size_t& position, const size_t srcEnd) const {
910  		if (position >= srcEnd) return;
911  		if (IsSbSep(src[TVecIdx(position)])) { position++; return; }
912  		position++; while (position < srcEnd && IsWbIgnored(src[TVecIdx(position)])) position++; }
913  	template<typename TSrcVec> bool WbFindPrevNonIgnored(const TSrcVec& src, const size_t srcStart, size_t& position) const {
914  		if (position <= srcStart) return false;
915  		while (position > srcStart) {
916  			position--; if (! IsWbIgnored(src[TVecIdx(position)])) return true; }
917  		return false; }
918  	void TestWbFindNonIgnored(const TIntV& src) const;
919  	void TestWbFindNonIgnored() const;
920  public:
921  	template<typename TSrcVec>
922  	bool FindNextWordBoundary(const TSrcVec& src, const size_t srcIdx, const size_t srcCount, size_t &position) const;
923  	template<typename TSrcVec>
924  	void FindWordBoundaries(const TSrcVec& src, const size_t srcIdx, const size_t srcCount, TBoolV& dest) const;
925  protected:
926  	void TestFindNextWordOrSentenceBoundary(const TStr& basePath, bool sentence);
927  protected:
928  	TUniTrie<TInt> sbExTrie;
929  	template<typename TSrcVec>
930  	bool CanSentenceEndHere(const TSrcVec& src, const size_t srcIdx, const size_t position) const;
931  public:
932  	template<typename TSrcVec>
933  	bool FindNextSentenceBoundary(const TSrcVec& src, const size_t srcIdx, const size_t srcCount, size_t &position) const;
934  	template<typename TSrcVec>
935  	void FindSentenceBoundaries(const TSrcVec& src, const size_t srcIdx, const size_t srcCount, TBoolV& dest) const;
936  	void SbEx_Clr() { sbExTrie.Clr(); }
937  	template<class TSrcVec> void SbEx_Add(const TSrcVec& v) { sbExTrie.Add(v); }
938  	void SbEx_Add(const TStr& s) {
939            TIntV v; int n = s.Len(); v.Gen(n); for (int i = 0; i < n; i++) v[i] = int(uchar(s[i])); SbEx_Add(v); }
940  	void SbEx_AddUtf8(const TStr& s) { TUniCodec codec; TIntV v; codec.DecodeUtf8(s, v); SbEx_Add(v); }
941  	int SbEx_AddMulti(const TStr& words, const bool wordsAreUtf8 = true) { TStrV vec; words.SplitOnAllCh('|', vec);
942  		for (int i = 0; i < vec.Len(); i++) if (wordsAreUtf8) SbEx_AddUtf8(vec[i]); else SbEx_Add(vec[i]);
943  		return vec.Len(); }
944  	void SbEx_Set(const TUniTrie<TInt>& newTrie) { sbExTrie = newTrie; }
945  	int SbEx_SetStdEnglish() {
946  		static const TStr data = "Ms|Mrs|Mr|Rev|Dr|Prof|Gov|Sen|Rep|Gen|Brig|Col|Capt|Lieut|Lt|Sgt|Pvt|Cmdr|Adm|Corp|St|Mt|Ft|e.g|e. g.|i.e|i. e|ib|ibid|s.v|s. v|s.vv|s. vv";
947  		SbEx_Clr(); return SbEx_AddMulti(data, false); }
948  protected:
949  	template<typename TDestCh>
950  	void AddDecomposition(const int codePoint, TVec<TDestCh>& dest, const bool compatibility) const;
951  public:
952  	template<typename TSrcVec, typename TDestCh>
953  	void Decompose(const TSrcVec& src, size_t srcIdx, const size_t srcCount,
954  			TVec<TDestCh>& dest, bool compatibility, bool clrDest = true) const;
955  	template<typename TSrcVec, typename TDestCh>
956  	void Decompose(const TSrcVec& src, TVec<TDestCh>& dest, bool compatibility, bool clrDest = true) const {
957  		Decompose(src, 0, src.Len(), dest, compatibility, clrDest); }
958  	template<typename TSrcVec, typename TDestCh>
959  	void Compose(const TSrcVec& src, size_t srcIdx, const size_t srcCount,
960  			TVec<TDestCh>& dest, bool clrDest = true) const;
961  	template<typename TSrcVec, typename TDestCh>
962  	void Compose(const TSrcVec& src, TVec<TDestCh>& dest, bool clrDest = true) const {
963  		Compose(src, 0, src.Len(), dest, clrDest); }
964  	template<typename TSrcVec, typename TDestCh>
965  	void DecomposeAndCompose(const TSrcVec& src, size_t srcIdx, const size_t srcCount,
966  			TVec<TDestCh>& dest, bool compatibility, bool clrDest = true) const;
967  	template<typename TSrcVec, typename TDestCh>
968  	void DecomposeAndCompose(const TSrcVec& src, TVec<TDestCh>& dest, bool compatibility, bool clrDest = true) const {
969  		DecomposeAndCompose(src, 0, src.Len(), dest, compatibility, clrDest); }
970  	template<typename TSrcVec, typename TDestCh>
971  	size_t ExtractStarters(const TSrcVec& src, size_t srcIdx, const size_t srcCount,
972  			TVec<TDestCh>& dest, bool clrDest = true) const;
973  	template<typename TSrcVec, typename TDestCh>
974  	size_t ExtractStarters(const TSrcVec& src, TVec<TDestCh>& dest, bool clrDest = true) const {
975  		return ExtractStarters(src, 0, src.Len(), dest, clrDest); }
976  	template<typename TSrcVec>
977  	size_t ExtractStarters(TSrcVec& src) const {
978  		TIntV temp; size_t retVal = ExtractStarters(src, temp);
979  		src.Clr(); for (int i = 0; i < temp.Len(); i++) src.Add(temp[i]);
980  		return retVal; }
981  protected:
982  	void TestComposition(const TStr& basePath);
983  protected:
984  	void InitWordAndSentenceBoundaryFlags(const TStr& basePath);
985  	void InitScripts(const TStr& basePath);
986  	void InitLineBreaks(const TStr& basePath);
987  	void InitDerivedCoreProperties(const TStr& basePath);
988  	void InitPropList(const TStr& basePath);
989  	void InitSpecialCasing(const TStr& basePath);
990  	void LoadTxt_ProcessDecomposition(TUniChInfo& ci, TStr s);
991  public:
992  	void LoadTxt(const TStr& basePath);
993  	void SaveBin(const TStr& fnBinUcd);
994  public:
995  	typedef enum TCaseConversion_ { ccLower = 0, ccUpper = 1, ccTitle = 2, ccMax = 3 } TCaseConversion;
996  	template<typename TSrcVec, typename TDestCh> void GetCaseConverted(const TSrcVec& src, size_t srcIdx, const size_t srcCount, TVec<TDestCh>& dest, const bool clrDest, const TCaseConversion how, const bool turkic, const bool lithuanian) const;
997  	template<typename TSrcVec, typename TDestCh> void GetLowerCase(const TSrcVec& src, size_t srcIdx, const size_t srcCount, TVec<TDestCh>& dest, const bool clrDest = true, const bool turkic = false, const bool lithuanian = false) const { GetCaseConverted(src, srcIdx, srcCount, dest, clrDest, ccLower, turkic, lithuanian); }
998  	template<typename TSrcVec, typename TDestCh> void GetUpperCase(const TSrcVec& src, size_t srcIdx, const size_t srcCount, TVec<TDestCh>& dest, const bool clrDest = true, const bool turkic = false, const bool lithuanian = false) const { GetCaseConverted(src, srcIdx, srcCount, dest, clrDest, ccUpper, turkic, lithuanian); }
999  	template<typename TSrcVec, typename TDestCh> void GetTitleCase(const TSrcVec& src, size_t srcIdx, const size_t srcCount, TVec<TDestCh>& dest, const bool clrDest = true, const bool turkic = false, const bool lithuanian = false) const { GetCaseConverted(src, srcIdx, srcCount, dest, clrDest, ccTitle, turkic, lithuanian); }
1000  	template<typename TSrcVec, typename TDestCh> void GetLowerCase(const TSrcVec& src, TVec<TDestCh>& dest, const bool clrDest = true, const bool turkic = false, const bool lithuanian = false) const { GetLowerCase(src, 0, src.Len(), dest, clrDest, turkic, lithuanian); }
1001  	template<typename TSrcVec, typename TDestCh> void GetUpperCase(const TSrcVec& src, TVec<TDestCh>& dest, const bool clrDest = true, const bool turkic = false, const bool lithuanian = false) const { GetUpperCase(src, 0, src.Len(), dest, clrDest, turkic, lithuanian); }
1002  	template<typename TSrcVec, typename TDestCh> void GetTitleCase(const TSrcVec& src, TVec<TDestCh>& dest, const bool clrDest = true, const bool turkic = false, const bool lithuanian = false) const { GetTitleCase(src, 0, src.Len(), dest, clrDest, turkic, lithuanian); }
1003  	template<typename TSrcVec, typename TDestCh> void GetSimpleCaseConverted(const TSrcVec& src, size_t srcIdx, const size_t srcCount, TVec<TDestCh>& dest, const bool clrDest, const TCaseConversion how) const;
1004  	template<typename TSrcVec, typename TDestCh> void GetSimpleLowerCase(const TSrcVec& src, size_t srcIdx, const size_t srcCount, TVec<TDestCh>& dest, const bool clrDest = true) const { GetSimpleCaseConverted(src, srcIdx, srcCount, dest, clrDest, ccLower); }
1005  	template<typename TSrcVec, typename TDestCh> void GetSimpleUpperCase(const TSrcVec& src, size_t srcIdx, const size_t srcCount, TVec<TDestCh>& dest, const bool clrDest = true) const { GetSimpleCaseConverted(src, srcIdx, srcCount, dest, clrDest, ccUpper); }
1006  	template<typename TSrcVec, typename TDestCh> void GetSimpleTitleCase(const TSrcVec& src, size_t srcIdx, const size_t srcCount, TVec<TDestCh>& dest, const bool clrDest = true) const { GetSimpleCaseConverted(src, srcIdx, srcCount, dest, clrDest, ccTitle); }
1007  	template<typename TSrcVec, typename TDestCh> void GetSimpleLowerCase(const TSrcVec& src, TVec<TDestCh>& dest, const bool clrDest = true) const { GetSimpleLowerCase(src, 0, src.Len(), dest, clrDest); }
1008  	template<typename TSrcVec, typename TDestCh> void GetSimpleUpperCase(const TSrcVec& src, TVec<TDestCh>& dest, const bool clrDest = true) const { GetSimpleUpperCase(src, 0, src.Len(), dest, clrDest); }
1009  	template<typename TSrcVec, typename TDestCh> void GetSimpleTitleCase(const TSrcVec& src, TVec<TDestCh>& dest, const bool clrDest = true) const { GetSimpleTitleCase(src, 0, src.Len(), dest, clrDest); }
1010  	template<typename TSrcVec> void ToSimpleCaseConverted(TSrcVec& src, size_t srcIdx, const size_t srcCount, const TCaseConversion how) const;
1011  	template<typename TSrcVec> void ToSimpleUpperCase(TSrcVec& src, size_t srcIdx, const size_t srcCount) const { ToSimpleCaseConverted(src, srcIdx, srcCount, ccUpper); }
1012  	template<typename TSrcVec> void ToSimpleLowerCase(TSrcVec& src, size_t srcIdx, const size_t srcCount) const { ToSimpleCaseConverted(src, srcIdx, srcCount, ccLower); }
1013  	template<typename TSrcVec> void ToSimpleTitleCase(TSrcVec& src, size_t srcIdx, const size_t srcCount) const { ToSimpleCaseConverted(src, srcIdx, srcCount, ccTitle); }
1014  	template<typename TSrcVec> void ToSimpleUpperCase(TSrcVec& src) const { ToSimpleUpperCase(src, 0, src.Len()); }
1015  	template<typename TSrcVec> void ToSimpleLowerCase(TSrcVec& src) const { ToSimpleLowerCase(src, 0, src.Len()); }
1016  	template<typename TSrcVec> void ToSimpleTitleCase(TSrcVec& src) const { ToSimpleTitleCase(src, 0, src.Len()); }
1017  public:
1018  	friend class TUniCaseFolding;
1019  	template<typename TSrcVec, typename TDestCh>
1020  	void GetCaseFolded(const TSrcVec& src, size_t srcIdx, const size_t srcCount,
1021  		TVec<TDestCh>& dest, const bool clrDest, const bool full, const bool turkic = false) const { caseFolding.Fold(src, srcIdx, srcCount, dest, clrDest, full, turkic); }
1022  	template<typename TSrcVec, typename TDestCh>
1023  	void GetCaseFolded(const TSrcVec& src, TVec<TDestCh>& dest, const bool clrDest = true, const bool full = true, const bool turkic = false) const {
1024  		GetCaseFolded(src, 0, src.Len(), dest, clrDest, full, turkic); }
1025  	template<typename TSrcVec> void ToCaseFolded(TSrcVec& src, size_t srcIdx, const size_t srcCount, const bool turkic = false) const { caseFolding.FoldInPlace(src, srcIdx, srcCount, turkic); }
1026  	template<typename TSrcVec> void ToCaseFolded(TSrcVec& src, const bool turkic = false) const { ToCaseFolded(src, 0, src.Len(), turkic); }
1027  protected:
1028  	void TestCaseConversion(const TStr& source, const TStr& trueLc, const TStr& trueTc, const TStr& trueUc, bool turkic, bool lithuanian);
1029  	void TestCaseConversions();
1030  protected:
1031  	class TUcdFileReader
1032  	{
1033  	protected:
1034  		TChA buf;
1035  	public:
1036  		TChA comment; 
1037  	protected:
1038  		FILE *f;
1039  		int putBackCh;
1040  		int GetCh() {
1041  			if (putBackCh >= 0) { int c = putBackCh; putBackCh = EOF; return c; }
1042  			return fgetc(f); }
1043  		void PutBack(int c) { Assert(putBackCh == EOF); putBackCh = c; }
1044  		bool ReadNextLine() {
1045  			buf.Clr(); comment.Clr();
1046  			bool inComment = false, first = true;
1047  			while (true) {
1048  				int c = GetCh();
1049  				if (c == EOF) return ! first;
1050  				else if (c == 13) {
1051  					c = GetCh(); if (c != 10) PutBack(c);
1052  					return true; }
1053  				else if (c == 10) return true;
1054  				else if (c == '#') inComment = true;
1055  				if (! inComment) buf += char(c);
1056  				else comment += char(c); }
1057  				}
1058  	private:
1059  		TUcdFileReader& operator = (const TUcdFileReader& r) { Fail; return *((TUcdFileReader *) 0); }
1060  		TUcdFileReader(const TUcdFileReader& r) { Fail; }
1061  	public:
1062  		TUcdFileReader() : f(0) { }
1063  		TUcdFileReader(const TStr& fileName) : f(0), putBackCh(EOF) { Open(fileName); }
1064  		void Open(const TStr& fileName) { Close(); f = fopen(fileName.CStr(), "rt"); IAssertR(f, fileName); putBackCh = EOF; }
1065  		void Close() { putBackCh = EOF; if (f) { fclose(f); f = 0; }}
1066  		~TUcdFileReader() { Close(); }
1067  		bool GetNextLine(TStrV& dest) {
1068  			dest.Clr();
1069  			while (true) {
1070  				if (! ReadNextLine()) return false;
1071  				TStr line = buf; line.ToTrunc();
1072  				if (line.Len() <= 0) continue;
1073  				line.SplitOnAllCh(';', dest, false);
1074  				for (int i = 0; i < dest.Len(); i++) dest[i].ToTrunc();
1075  				return true; }}
1076  		static int ParseCodePoint(const TStr& s) {
1077  			int c; bool ok = s.IsHexInt(true, 0, 0x10ffff, c); IAssertR(ok, s); return c; }
1078  		static void ParseCodePointList(const TStr& s, TIntV& dest, bool ClrDestP = true) { 
1079  			if (ClrDestP) dest.Clr();
1080  			TStrV parts; s.SplitOnWs(parts);
1081  			for (int i = 0; i < parts.Len(); i++) {
1082  				int c; bool ok = parts[i].IsHexInt(true, 0, 0x10ffff, c); IAssertR(ok, s);
1083  				dest.Add(c); } }
1084  		static void ParseCodePointRange(const TStr& s, int& from, int &to) { 
1085  			int i = s.SearchStr(".."); if (i < 0) { from = ParseCodePoint(s); to = from; return; }
1086  			from = ParseCodePoint(s.GetSubStr(0, i - 1));
1087  			to = ParseCodePoint(s.GetSubStr(i + 2, s.Len() - 1)); }
1088  	};
1089  	class TSubcatHelper
1090  	{
1091  	public:
1092  		bool hasCat; TUniChSubCategory subCat;
1093  		TStrH invalidCatCodes;
1094  		TUniChDb &owner;
1095  		TSubcatHelper(TUniChDb &owner_) : owner(owner_) { }
1096  		void ProcessComment(TUniChDb::TUcdFileReader &reader)
1097  		{
1098  			hasCat = false; subCat = ucOtherNotAssigned;
1099  			if (reader.comment.Len() > 3)
1100  			{
1101  				IAssert(reader.comment[0] == '#');
1102  				IAssert(reader.comment[1] == ' ');
1103  				char chCat = reader.comment[2], chSubCat = reader.comment[3];
1104  				if (reader.comment.Len() > 4) IAssert(isspace(uchar(reader.comment[4])));
1105  				if (TUniChInfo::IsValidSubCat(chCat, chSubCat)) {
1106  					hasCat = true; subCat = (TUniChSubCategory) ((int(uchar(chCat)) << 8) | (int(uchar(chSubCat)))); }
1107  				else invalidCatCodes.AddKey(TStr(chCat) + TStr(chSubCat));
1108  			}
1109  		}
1110  		void SetCat(const int cp) {
1111  			int i = owner.h.GetKeyId(cp); IAssert(i >= 0);
1112  			IAssert(owner.h[i].subCat == ucOtherNotAssigned);
1113  			IAssert(hasCat);
1114  			owner.h[i].SetCatAndSubCat(subCat); }
1115  		void TestCat(const int cp) {
1116  			if (! hasCat) return;
1117  			int i = owner.h.GetKeyId(cp); IAssert(i >= 0);
1118  			IAssert(owner.h[i].subCat == subCat); }
1119  		~TSubcatHelper()
1120  		{
1121  			if (invalidCatCodes.IsKey("L&")) invalidCatCodes.DelKey("L&");
1122  			if (! invalidCatCodes.Empty()) {
1123  				printf("Invalid cat code(s) in the comments: ");
1124  				for (int i = invalidCatCodes.FFirstKeyId(); invalidCatCodes.FNextKeyId(i); )
1125  					printf(" \"%s\"", invalidCatCodes.GetKey(i).CStr());
1126  				printf("\n"); }
1127  		}
1128  	};
1129  };
1130  class TUnicode
1131  {
1132  public:
1133  	TUniCodec codec;
1134  	TUniChDb ucd;
1135  	TUnicode() { Init(); }
1136  	explicit TUnicode(const TStr& fnBinUcd) { ucd.LoadBin(fnBinUcd); Init(); }
1137  	void Init() { InitCodecs(); }
1138  	int DecodeUtf8(const TIntV& src, TIntV& dest) const { return (int) codec.DecodeUtf8(src, dest); }
1139  	int DecodeUtf8(const TStr& src, TIntV& dest) const { return (int) codec.DecodeUtf8(src, dest); }
1140  	int EncodeUtf8(const TIntV& src, TIntV& dest) const { return (int) codec.EncodeUtf8(src, dest); }
1141  	TStr EncodeUtf8Str(const TIntV& src) const { return codec.EncodeUtf8Str(src); }
1142  	static void EncodeUtf8(const uint& Ch, TChA& Dest);
1143  	static TStr EncodeUtf8(const uint& Ch);
1144  	int DecodeUtf16FromBytes(const TIntV& src, TIntV& dest,
1145  		const TUtf16BomHandling bomHandling = bomAllowed,
1146  		const TUniByteOrder defaultByteOrder = boMachineEndian) const {
1147  			return (int) codec.DecodeUtf16FromBytes(src, 0, src.Len(), dest, true, bomHandling, defaultByteOrder); }
1148  	int DecodeUtf16FromWords(const TIntV& src, TIntV& dest,
1149  		const TUtf16BomHandling bomHandling = bomAllowed,
1150  		const TUniByteOrder defaultByteOrder = boMachineEndian) const {
1151  			return (int) codec.DecodeUtf16FromWords(src, 0, src.Len(), dest, true, bomHandling, defaultByteOrder); }
1152  	int EncodeUtf16ToWords(const TIntV& src, TIntV& dest, const bool insertBom,
1153  		const TUniByteOrder destByteOrder = boMachineEndian) const {
1154  			return (int) codec.EncodeUtf16ToWords(src, 0, src.Len(), dest, true, insertBom, destByteOrder); }
1155  	int EncodeUtf16ToBytes(const TIntV& src, TIntV& dest, const bool insertBom,
1156  		const TUniByteOrder destByteOrder = boMachineEndian) const {
1157  			return (int) codec.EncodeUtf16ToBytes(src, 0, src.Len(), dest, true, insertBom, destByteOrder); }
1158  	T8BitCodec<TEncoding_ISO8859_1> iso8859_1;
1159  	T8BitCodec<TEncoding_ISO8859_2> iso8859_2;
1160  	T8BitCodec<TEncoding_ISO8859_3> iso8859_3;
1161  	T8BitCodec<TEncoding_ISO8859_4> iso8859_4;
1162  	T8BitCodec<TEncoding_YuAscii> yuAscii;
1163  	T8BitCodec<TEncoding_CP1250> cp1250;
1164  	T8BitCodec<TEncoding_CP852> cp852;
1165  	T8BitCodec<TEncoding_CP437> cp437;
1166  protected:
1167  	THash<TStr, PCodecBase> codecs;
1168  	static inline TStr NormalizeCodecName(const TStr& name) {
1169  		TStr s = name.GetLc(); s.ChangeStrAll("_", ""); s.ChangeStrAll("-", ""); return s; }
1170  public:
1171  	void RegisterCodec(const TStr& nameList, const PCodecBase& codec) {
1172  		TStrV names; nameList.SplitOnWs(names);
1173  		for (int i = 0; i < names.Len(); i++)
1174  			codecs.AddDat(NormalizeCodecName(names[i]), codec); }
1175  	void UnregisterCodec(const TStr& nameList) {
1176  		TStrV names; nameList.SplitOnWs(names);
1177  		for (int i = 0; i < names.Len(); i++)
1178  			codecs.DelKey(NormalizeCodecName(names[i])); }
1179  	void ClrCodecs() { codecs.Clr(); }
1180  	void InitCodecs();
1181  	PCodecBase GetCodec(const TStr& name) const {
1182  		TStr s = NormalizeCodecName(name);
1183  		PCodecBase p; if (! codecs.IsKeyGetDat(s, p)) p.Clr();
1184  		return p; }
1185  	void GetAllCodecs(TCodecBaseV& dest) const {
1186  		dest.Clr();
1187  		for (int i = codecs.FFirstKeyId(); codecs.FNextKeyId(i); ) {
1188  			PCodecBase codec = codecs[i]; bool found = false;
1189  			for (int j = 0; j < dest.Len(); j++) if (dest[j]() == codec()) { found = true; break; }
1190  			if (! found) dest.Add(codec); }}
1191  	bool FindNextWordBoundary(const TIntV& src, int &position) const {
1192  		if (position < 0) { position = 0; return true; }
1193  		size_t position_; bool retVal = ucd.FindNextWordBoundary(src, 0, src.Len(), position_); position = int(position_); return retVal; }
1194  	void FindWordBoundaries(const TIntV& src, TBoolV& dest) const { ucd.FindWordBoundaries(src, 0, src.Len(), dest); }
1195  	bool FindNextSentenceBoundary(const TIntV& src, int &position) const {
1196  		if (position < 0) { position = 0; return true; }
1197  		size_t position_; bool retVal = ucd.FindNextSentenceBoundary(src, 0, src.Len(), position_); position = int(position_); return retVal; }
1198  	void FindSentenceBoundaries(const TIntV& src, TBoolV& dest) const { ucd.FindSentenceBoundaries(src, 0, src.Len(), dest); }
1199  	void ClrSentenceBoundaryExceptions() { ucd.SbEx_Clr(); }
1200  	void UseEnglishSentenceBoundaryExceptions() { ucd.SbEx_SetStdEnglish(); }
1201  	void Decompose(const TIntV& src, TIntV& dest, bool compatibility) const { ucd.Decompose(src, dest, compatibility, true); }
1202  	void Compose(const TIntV& src, TIntV& dest) const { return ucd.Compose(src, dest, true); }
1203  	void DecomposeAndCompose(const TIntV& src, TIntV& dest, bool compatibility) const { return ucd.DecomposeAndCompose(src, dest, compatibility); }
1204  	int ExtractStarters(const TIntV& src, TIntV& dest) const { return (int) ucd.ExtractStarters(src, dest); }
1205  	int ExtractStarters(TIntV& src) const { return (int) ucd.ExtractStarters(src); }
1206  public:
1207  	typedef TUniChDb::TCaseConversion TCaseConversion;
1208  	void GetLowerCase(const TIntV& src, TIntV& dest) const { ucd.GetLowerCase(src, dest, true, false, false); }
1209  	void GetUpperCase(const TIntV& src, TIntV& dest) const { ucd.GetUpperCase(src, dest, true, false, false); }
1210  	void GetTitleCase(const TIntV& src, TIntV& dest) const { ucd.GetTitleCase(src, dest, true, false, false); }
1211  	void GetSimpleLowerCase(const TIntV& src, TIntV& dest) const { ucd.GetSimpleLowerCase(src, dest, true); }
1212  	void GetSimpleUpperCase(const TIntV& src, TIntV& dest) const { ucd.GetSimpleUpperCase(src, dest, true); }
1213  	void GetSimpleTitleCase(const TIntV& src, TIntV& dest) const { ucd.GetSimpleTitleCase(src, dest, true); }
1214  	void ToSimpleUpperCase(TIntV& src) const { ucd.ToSimpleUpperCase(src); }
1215  	void ToSimpleLowerCase(TIntV& src) const { ucd.ToSimpleLowerCase(src); }
1216  	void ToSimpleTitleCase(TIntV& src) const { ucd.ToSimpleTitleCase(src); }
1217  	void GetCaseFolded(const TIntV& src, TIntV& dest, const bool full = true) const { return ucd.GetCaseFolded(src, dest, true, full, false); }
1218  	void ToCaseFolded(TIntV& src) const { return ucd.ToCaseFolded(src, false); }
1219  	TStr GetUtf8CaseFolded(const TStr& s) const {
1220  		bool isAscii = true;
1221  		for (int i = 0, n = s.Len(); i < n; i++) if (uchar(s[i]) >= 128) { isAscii = false; break; }
1222  		if (isAscii) return s.GetLc();
1223  		TIntV src; DecodeUtf8(s, src);
1224  		TIntV dest; GetCaseFolded(src, dest);
1225  		return EncodeUtf8Str(dest); }
1226  #define ___UniFwd1(name) bool name(const int cp) const { return ucd.name(cp); }
1227  	DECLARE_FORWARDED_PROPERTY_METHODS
1228  #undef DECLARE_FORWARDED_PROPERTY_METHODS
1229  #undef __UniFwd1
1230  	___UniFwd2(IsPrivateUse, IsSurrogate)
1231  	TUniChCategory GetCat(const int cp) const { return ucd.GetCat(cp); }
<span onclick='openModal()' class='match'>1232  	TUniChSubCategory GetSubCat(const int cp) const { return ucd.GetSubCat(cp); }
1233  	const char *GetCharName(const int cp) const { return ucd.GetCharName(cp); }
</span>1234  	TStr GetCharNameS(const int cp) const { return ucd.GetCharNameS(cp); }
1235  };
1236  template<typename TSrcVec, typename TDestCh>
1237  size_t TUniCodec::DecodeUtf8(
1238  	const TSrcVec& src, size_t srcIdx, const size_t srcCount,
1239  	TVec<TDestCh>& dest, const bool clrDest) const
1240  {
1241  	size_t nDecoded = 0;
1242  	if (clrDest) dest.Clr();
1243  	const size_t origSrcIdx = srcIdx;
1244  	const size_t srcEnd = srcIdx + srcCount;
1245  	while (srcIdx < srcEnd)
1246  	{
1247  		const size_t charSrcIdx = srcIdx;
1248  		uint c = src[TVecIdx(srcIdx)] & 0xff; srcIdx++;
1249  		if ((c & _1000_0000) == 0) {
1250  			dest.Add(TDestCh(c)); nDecoded++; continue; }
1251  		else if ((c & _1100_0000) == _1000_0000) {
1252  			switch (errorHandling) {
1253  			case uehThrow: throw TUnicodeException(charSrcIdx, c, "Invalid character: 10xxxxxx.");
1254  			case uehAbort: return nDecoded;
1255  			case uehReplace: dest.Add(TDestCh(replacementChar)); continue;
1256  			case uehIgnore: continue;
1257  			default: Fail; } }
1258  		else
1259  		{
1260  			uint nMoreBytes = 0, nBits = 0, minVal = 0;
1261  			if ((c & _1110_0000) == _1100_0000) nMoreBytes = 1, nBits = 5, minVal = 0x80;
1262  			else if ((c & _1111_0000) == _1110_0000) nMoreBytes = 2, nBits = 4, minVal = 0x800;
1263  			else if ((c & _1111_1000) == _1111_0000) nMoreBytes = 3, nBits = 3, minVal = 0x10000;
1264  			else if ((c & _1111_1100) == _1111_1000) nMoreBytes = 4, nBits = 2, minVal = 0x200000;
1265  			else if ((c & _1111_1110) == _1111_1100) nMoreBytes = 5, nBits = 1, minVal = 0x4000000;
1266  			else {
1267  				if (strict)  {
1268  					switch (errorHandling) {
1269  					case uehThrow: throw TUnicodeException(charSrcIdx, c, "Invalid character: 1111111x.");
1270  					case uehAbort: return nDecoded;
1271  					case uehReplace: break; 
1272  					case uehIgnore: break; 
1273  					default: Fail; } }
1274  				nMoreBytes = 5; nBits = 2; minVal = 0x80000000u; }
1275  			uint cOut = c & ((1 << nBits) - 1); 
1276  			bool cancel = false;
1277  			for (uint i = 0; i < nMoreBytes && ! cancel; i++) {
1278  				if (! (srcIdx < srcEnd)) {
1279  					switch (errorHandling) {
1280  					case uehThrow: throw TUnicodeException(charSrcIdx, c, TInt::GetStr(nMoreBytes) + " more bytes expected, only " + TInt::GetStr(int(srcEnd - charSrcIdx - 1)) + " available.");
1281  					case uehAbort: return nDecoded;
1282  					case uehReplace: dest.Add(TDestCh(replacementChar)); cancel = true; continue;
1283  					case uehIgnore: cancel = true; continue;
1284  					default: Fail; } }
1285  				c = src[TVecIdx(srcIdx)] & 0xff; srcIdx++;
1286  				if ((c & _1100_0000) != _1000_0000) { 
1287  					switch (errorHandling) {
1288  					case uehThrow: throw TUnicodeException(charSrcIdx, c, "Byte " + TInt::GetStr(i) + " of " + TInt::GetStr(nMoreBytes) + " extra bytes should begin with 10xxxxxx.");
1289  					case uehAbort: return nDecoded;
1290  					case uehReplace: dest.Add(TDestCh(replacementChar)); srcIdx--; cancel = true; continue;
1291  					case uehIgnore: srcIdx--; cancel = true; continue;
1292  					default: Fail; } }
1293  				cOut <<= 6; cOut |= (c & _0011_1111); }
1294  			if (cancel) continue;
1295  			if (strict) {
1296  				bool err1 = (cOut < minVal);
1297  				bool err2 = (nMoreBytes > 3 || (nMoreBytes == 3 && cOut > 0x10ffff));
1298  				if (err1 || err2) switch (errorHandling) {
1299  					case uehThrow:
1300  						if (err1) throw TUnicodeException(charSrcIdx, c, "The codepoint 0x" + TInt::GetStr(cOut, "%08x") + " has been represented by too many bytes (" + TInt::GetStr(nMoreBytes + 1) + ").");
1301  						else if (err2) throw TUnicodeException(charSrcIdx, c, "Invalid multibyte sequence: it decodes into 0x" + TInt::GetStr(cOut, "%08x") + ", but only codepoints 0..0x10ffff are valid.");
1302  						else { Fail; break; }
1303  					case uehAbort: return nDecoded;
1304  					case uehReplace: dest.Add(TDestCh(replacementChar)); continue;
1305  					case uehIgnore: continue;
1306  					default: Fail; } }
1307  			if (! (skipBom && (cOut == 0xfffe || cOut == 0xfeff) && charSrcIdx == origSrcIdx)) {
1308  				dest.Add(cOut); nDecoded++; }
1309  		} 
1310  	} 
1311  	return nDecoded;
1312  }
1313  template<typename TSrcVec, typename TDestCh>
1314  size_t TUniCodec::EncodeUtf8(
1315  	const TSrcVec& src, size_t srcIdx, const size_t srcCount,
1316  	TVec<TDestCh>& dest, const bool clrDest) const
1317  {
1318  	size_t nEncoded = 0;
1319  	for (const size_t srcEnd = srcIdx + srcCount; srcIdx < srcEnd; srcIdx++)
1320  	{
1321  		uint c = uint(src[TVecIdx(srcIdx)]);
1322  		bool err = false;
1323  		if (strict && c > 0x10ffff) {
1324  			err = true;
1325  			switch (errorHandling) {
1326  			case uehThrow: throw TUnicodeException(srcIdx, c, "Invalid character (0x" + TInt::GetStr(c, "%x") + "; only characters in the range 0..0x10ffff are allowed).");
1327  			case uehAbort: return nEncoded;
1328  			case uehReplace: c = replacementChar; break;
1329  			case uehIgnore: continue;
1330  			default: Fail; } }
1331  		if (c < 0x80u)
1332  			dest.Add(TDestCh(c & 0xffu));
1333  		else if (c < 0x800u) {
1334  			dest.Add(TDestCh(_1100_0000 | ((c >> 6) & _0001_1111)));
1335  			dest.Add(TDestCh(_1000_0000 | (c & _0011_1111))); }
1336  		else if (c < 0x10000u) {
1337  			dest.Add(TDestCh(_1110_0000 | ((c >> 12) & _0000_1111)));
1338  			dest.Add(TDestCh(_1000_0000 | ((c >> 6) & _0011_1111)));
1339  			dest.Add(TDestCh(_1000_0000 | (c & _0011_1111))); }
1340  		else if (c < 0x200000u) {
1341  			dest.Add(TDestCh(_1111_0000 | ((c >> 18) & _0000_0111)));
1342  			dest.Add(TDestCh(_1000_0000 | ((c >> 12) & _0011_1111)));
1343  			dest.Add(TDestCh(_1000_0000 | ((c >> 6) & _0011_1111)));
1344  			dest.Add(TDestCh(_1000_0000 | (c & _0011_1111))); }
1345  		else if (c < 0x4000000u) {
1346  			dest.Add(TDestCh(_1111_1000 | ((c >> 24) & _0000_0011)));
1347  			dest.Add(TDestCh(_1000_0000 | ((c >> 18) & _0011_1111)));
1348  			dest.Add(TDestCh(_1000_0000 | ((c >> 12) & _0011_1111)));
1349  			dest.Add(TDestCh(_1000_0000 | ((c >> 6) & _0011_1111)));
1350  			dest.Add(TDestCh(_1000_0000 | (c & _0011_1111))); }
1351  		else {
1352  			dest.Add(TDestCh(_1111_1100 | ((c >> 30) & _0000_0011)));
1353  			dest.Add(TDestCh(_1000_0000 | ((c >> 24) & _0011_1111)));
1354  			dest.Add(TDestCh(_1000_0000 | ((c >> 18) & _0011_1111)));
1355  			dest.Add(TDestCh(_1000_0000 | ((c >> 12) & _0011_1111)));
1356  			dest.Add(TDestCh(_1000_0000 | ((c >> 6) & _0011_1111)));
1357  			dest.Add(TDestCh(_1000_0000 | (c & _0011_1111))); }
1358  		if (! err) nEncoded++;
1359  	}
1360  	return nEncoded;
1361  }
1362  template<typename TSrcVec, typename TDestCh>
1363  size_t TUniCodec::DecodeUtf16FromBytes(
1364  	const TSrcVec& src, size_t srcIdx, const size_t srcCount,
1365  	TVec<TDestCh>& dest, const bool clrDest,
1366  	const TUtf16BomHandling bomHandling,
1367  	const TUniByteOrder defaultByteOrder) const
1368  {
1369  	IAssert(srcCount % 2 == 0);
1370  	IAssert(bomHandling == bomAllowed || bomHandling == bomRequired || bomHandling == bomIgnored);
1371  	IAssert(defaultByteOrder == boMachineEndian || defaultByteOrder == boBigEndian || defaultByteOrder == boLittleEndian);
1372  	if (clrDest) dest.Clr();
1373  	size_t nDecoded = 0;
1374  	if (srcCount <= 0) return nDecoded;
1375  	const size_t origSrcIdx = srcIdx, srcEnd = srcIdx + srcCount;
1376  	bool littleEndian = false;
1377  	bool leDefault = (defaultByteOrder == boLittleEndian || (defaultByteOrder == boMachineEndian && IsMachineLittleEndian()));
1378  	if (bomHandling == bomIgnored) littleEndian = leDefault;
1379  	else if (bomHandling == bomAllowed || bomHandling == bomRequired)
1380  	{
1381  		int byte1 = uint(src[TVecIdx(srcIdx)]) & 0xff, byte2 = uint(src[TVecIdx(srcIdx + 1)]) & 0xff;
1382  		if (byte1 == 0xfe && byte2 == 0xff) { littleEndian = false; if (skipBom) srcIdx += 2; }
1383  		else if (byte1 == 0xff && byte2 == 0xfe) { littleEndian = true; if (skipBom) srcIdx += 2; }
1384  		else if (bomHandling == bomAllowed) littleEndian = leDefault;
1385  		else { 
1386  			switch (errorHandling) {
1387  			case uehThrow: throw TUnicodeException(srcIdx, byte1, "BOM expected at the beginning of the input vector (" + TInt::GetStr(byte1, "%02x") + " " + TInt::GetStr(byte2, "%02x") + " found instead).");
1388  			case uehAbort: case uehReplace: case uehIgnore: return size_t(-1);
1389  			default: Fail; } }
1390  	}
1391  	else Fail;
1392  	while (srcIdx < srcEnd)
1393  	{
1394  		const size_t charSrcIdx = srcIdx;
1395  		uint byte1 = uint(src[TVecIdx(srcIdx)]) & 0xff, byte2 = uint(src[TVecIdx(srcIdx + 1)]) & 0xff; srcIdx += 2;
1396  		uint c = littleEndian ? (byte1 | (byte2 << 8)) : (byte2 | (byte1 << 8));
1397  		if (Utf16FirstSurrogate <= c && c <= Utf16FirstSurrogate + 1023)
1398  		{
1399  			if (! (srcIdx + 2 <= srcEnd)) {
1400  				switch (errorHandling) {
1401  				case uehThrow: throw TUnicodeException(charSrcIdx, c, "The second character of a surrogate pair is missing.");
1402  				case uehAbort: return nDecoded;
1403  				case uehReplace: dest.Add(TDestCh(replacementChar)); continue;
1404  				case uehIgnore: continue;
1405  				default: Fail; } }
1406  			uint byte1 = uint(src[TVecIdx(srcIdx)]) & 0xff, byte2 = uint(src[TVecIdx(srcIdx + 1)]) & 0xff; srcIdx += 2;
1407  			uint c2 = littleEndian ? (byte1 | (byte2 << 8)) : (byte2 | (byte1 << 8));
1408  			if (c2 < Utf16SecondSurrogate || Utf16SecondSurrogate + 1023 < c2) {
1409  				switch (errorHandling) {
1410  				case uehThrow: throw TUnicodeException(charSrcIdx + 2, c2, "The second character of a surrogate pair should be in the range " + TInt::GetStr(Utf16SecondSurrogate, "%04x") + ".." + TInt::GetStr(Utf16SecondSurrogate + 1023, "%04x") + ", not " + TInt::GetStr(c2, "04x") + ".");
1411  				case uehAbort: return nDecoded;
1412  				case uehReplace: dest.Add(TDestCh(replacementChar)); srcIdx -= 2; continue;
1413  				case uehIgnore: srcIdx -= 2; continue;
1414  				default: Fail; } }
1415  			uint cc = ((c - Utf16FirstSurrogate) << 10) | (c2 - Utf16SecondSurrogate);
1416  			cc += 0x10000;
1417  			dest.Add(TDestCh(cc)); nDecoded++; continue;
1418  		}
1419  		else if (strict && Utf16SecondSurrogate <= c && c <= Utf16SecondSurrogate + 1023) {
1420  			switch (errorHandling) {
1421  			case uehThrow: throw TUnicodeException(charSrcIdx, c, "This 16-bit value should be used only as the second character of a surrogate pair.");
1422  			case uehAbort: return nDecoded;
1423  			case uehReplace: dest.Add(TDestCh(replacementChar)); continue;
1424  			case uehIgnore: continue;
1425  			default: Fail; } }
1426  		if (charSrcIdx == origSrcIdx && (c == 0xfffeu || c == 0xfeffu) && skipBom) continue;
1427  		dest.Add(TDestCh(c)); nDecoded++;
1428  	}
1429  	return nDecoded;
1430  }
1431  template<typename TSrcVec, typename TDestCh>
1432  size_t TUniCodec::DecodeUtf16FromWords(
1433  	const TSrcVec& src, size_t srcIdx, const size_t srcCount,
1434  	TVec<TDestCh>& dest, bool clrDest,
1435  	const TUtf16BomHandling bomHandling,
1436  	const TUniByteOrder defaultByteOrder) const
1437  {
1438  	IAssert(bomHandling == bomAllowed || bomHandling == bomRequired || bomHandling == bomIgnored);
1439  	IAssert(defaultByteOrder == boMachineEndian || defaultByteOrder == boBigEndian || defaultByteOrder == boLittleEndian);
1440  	if (clrDest) dest.Clr();
1441  	size_t nDecoded = 0;
1442  	if (srcCount <= 0) return nDecoded;
1443  	const size_t origSrcIdx = srcIdx, srcEnd = srcIdx + srcCount;
1444  	bool swap = false;
1445  	bool isMachineLe = IsMachineLittleEndian();
1446  	bool isDefaultLe = (defaultByteOrder == boLittleEndian || (defaultByteOrder == boMachineEndian && isMachineLe));
1447  	if (bomHandling == bomIgnored) swap = (isDefaultLe != isMachineLe);
1448  	else if (bomHandling == bomAllowed || bomHandling == bomRequired)
1449  	{
1450  		int c = uint(src[TVecIdx(srcIdx)]) & 0xffff;
1451  		if (c == 0xfeff) { swap = false; if (skipBom) srcIdx += 1; }
1452  		else if (c == 0xfffe) { swap = true; if (skipBom) srcIdx += 1; }
1453  		else if (bomHandling == bomAllowed) swap = (isMachineLe != isDefaultLe);
1454  		else { 
1455  			switch (errorHandling) {
1456  			case uehThrow: throw TUnicodeException(srcIdx, c, "BOM expected at the beginning of the input vector (" + TInt::GetStr(c, "%04x") + " found instead).");
1457  			case uehAbort: case uehReplace: case uehIgnore: return size_t(-1);
1458  			default: Fail; } }
1459  	}
1460  	else Fail;
1461  	while (srcIdx < srcEnd)
1462  	{
1463  		const size_t charSrcIdx = srcIdx;
1464  		uint c = uint(src[TVecIdx(srcIdx)]) & 0xffffu; srcIdx++;
1465  		if (swap) c = ((c >> 8) & 0xff) | ((c & 0xff) << 8);
1466  		if (Utf16FirstSurrogate <= c && c <= Utf16FirstSurrogate + 1023)
1467  		{
1468  			if (! (srcIdx < srcEnd)) {
1469  				switch (errorHandling) {
1470  				case uehThrow: throw TUnicodeException(charSrcIdx, c, "The second character of a surrogate pair is missing.");
1471  				case uehAbort: return nDecoded;
1472  				case uehReplace: dest.Add(TDestCh(replacementChar)); continue;
1473  				case uehIgnore: continue;
1474  				default: Fail; } }
1475  			uint c2 = uint(src[TVecIdx(srcIdx)]) & 0xffffu; srcIdx++;
1476  			if (swap) c2 = ((c2 >> 8) & 0xff) | ((c2 & 0xff) << 8);
1477  			if (c2 < Utf16SecondSurrogate || Utf16SecondSurrogate + 1023 < c2) {
1478  				switch (errorHandling) {
1479  				case uehThrow: throw TUnicodeException(charSrcIdx + 1, c2, "The second character of a surrogate pair should be in the range " + TInt::GetStr(Utf16SecondSurrogate, "%04x") + ".." + TInt::GetStr(Utf16SecondSurrogate + 1023, "%04x") + ", not " + TInt::GetStr(c2, "04x") + ".");
1480  				case uehAbort: return nDecoded;
1481  				case uehReplace: dest.Add(TDestCh(replacementChar)); srcIdx -= 1; continue;
1482  				case uehIgnore: srcIdx -= 1; continue;
1483  				default: Fail; } }
1484  			uint cc = ((c - Utf16FirstSurrogate) << 10) | (c2 - Utf16SecondSurrogate);
1485  			cc += 0x10000;
1486  			dest.Add(TDestCh(cc)); nDecoded++; continue;
1487  		}
1488  		else if (strict && Utf16SecondSurrogate <= c && c <= Utf16SecondSurrogate + 1023) {
1489  			switch (errorHandling) {
1490  			case uehThrow: throw TUnicodeException(charSrcIdx, c, "This 16-bit value should be used only as the second character of a surrogate pair.");
1491  			case uehAbort: return nDecoded;
1492  			case uehReplace: dest.Add(TDestCh(replacementChar)); continue;
1493  			case uehIgnore: continue;
1494  			default: Fail; } }
1495  		if (charSrcIdx == origSrcIdx && (c == 0xfffeu || c == 0xfeffu) && skipBom) continue;
1496  		dest.Add(TDestCh(c)); nDecoded++;
1497  	}
1498  	return nDecoded;
1499  }
1500  template<typename TSrcVec, typename TDestCh>
1501  size_t TUniCodec::EncodeUtf16ToWords(
1502  	const TSrcVec& src, size_t srcIdx, const size_t srcCount,
1503  	TVec<TDestCh>& dest, const bool clrDest, const bool insertBom,
1504  	const TUniByteOrder destByteOrder) const
1505  {
1506  	bool isMachineLe = IsMachineLittleEndian();
1507  	bool swap = (destByteOrder == boLittleEndian && ! isMachineLe) || (destByteOrder == boBigEndian && isMachineLe);
1508  	size_t nEncoded = 0, srcEnd = srcIdx + srcCount;
1509  	if (insertBom) { dest.Add(TDestCh(swap ? 0xfffeu : 0xfeffu)); nEncoded++; }
1510  	while (srcIdx < srcEnd)
1511  	{
1512  		uint c = uint(src[TVecIdx(srcIdx)]); srcIdx++;
1513  		if (! (c <= 0x10ffffu)) {
1514  			switch (errorHandling) {
1515  			case uehThrow: throw TUnicodeException(srcIdx - 1, c, "UTF-16 only supports characters in the range 0..10ffff (not " + TUInt::GetStr(c, "%08x") + ").");
1516  			case uehAbort: return nEncoded;
1517  			case uehReplace: dest.Add(TDestCh(swap ? SwapBytes(replacementChar) : replacementChar)); continue;
1518  			case uehIgnore: continue;
1519  			default: Fail; } }
1520  		if (Utf16FirstSurrogate <= c && c < Utf16FirstSurrogate + 1023) {
1521  			switch (errorHandling) {
1522  			case uehThrow: throw TUnicodeException(srcIdx - 1, c, "UTF-16 cannot encode " + TUInt::GetStr(c, "%04x") + " as it belongs to the first surrogate range (" + TUInt::GetStr(Utf16FirstSurrogate, "%04x") + ".." + TUInt::GetStr(Utf16FirstSurrogate + 1023, "%04x") + ").");
1523  			case uehAbort: return nEncoded;
1524  			case uehReplace: dest.Add(TDestCh(swap ? SwapBytes(replacementChar) : replacementChar)); continue;
1525  			case uehIgnore: continue;
1526  			default: Fail; } }
1527  		if (Utf16SecondSurrogate <= c && c < Utf16SecondSurrogate + 1023) {
1528  			switch (errorHandling) {
1529  			case uehThrow: throw TUnicodeException(srcIdx - 1, c, "The character " + TUInt::GetStr(c, "%04x") + " belongs to the second surrogate range (" + TUInt::GetStr(Utf16FirstSurrogate, "%04x") + ".." + TUInt::GetStr(Utf16FirstSurrogate + 1023, "%04x") + "), which is not allowed with strict == true.");
1530  			case uehAbort: return nEncoded;
1531  			case uehReplace: dest.Add(TDestCh(swap ? SwapBytes(replacementChar) : replacementChar)); continue;
1532  			case uehIgnore: continue;
1533  			default: Fail; } }
1534  		if (c <= 0xffffu) {
1535  			if (swap) c = ((c >> 8) & 0xff) | ((c & 0xff) << 8);
1536  			dest.Add(TDestCh(c)); nEncoded++; continue; }
1537  		c -= 0x10000u; IAssert(&bsol;*0 <= c &&*/ c <= 0xfffffu);
1538  		uint c1 = (c >> 10) & 1023, c2 = c & 1023;
1539  		c1 += Utf16FirstSurrogate; c2 += Utf16SecondSurrogate;
1540  		if (swap) {
1541  			c1 = ((c1 >> 8) & 0xff) | ((c1 & 0xff) << 8);
1542  			c2 = ((c2 >> 8) & 0xff) | ((c2 & 0xff) << 8); }
1543  		dest.Add(TDestCh(c1));
1544  		dest.Add(TDestCh(c2));
1545  		nEncoded++; continue;
1546  	}
1547  	return nEncoded;
1548  }
1549  template<typename TSrcVec, typename TDestCh>
1550  size_t TUniCodec::EncodeUtf16ToBytes(
1551  	const TSrcVec& src, size_t srcIdx, const size_t srcCount,
1552  	TVec<TDestCh>& dest, const bool clrDest, const bool insertBom,
1553  	const TUniByteOrder destByteOrder) const
1554  {
1555  	bool isDestLe = (destByteOrder == boLittleEndian || (destByteOrder == boMachineEndian && IsMachineLittleEndian()));
1556  	size_t nEncoded = 0, srcEnd = srcIdx + srcCount;
1557  	if (insertBom) { dest.Add(isDestLe ? 0xff : 0xfe); dest.Add(isDestLe ? 0xfe : 0xff); nEncoded++; }
1558  	while (srcIdx < srcEnd)
1559  	{
1560  		uint c = uint(src[TVecIdx(srcIdx)]); srcIdx++;
1561  		if (! (c <= 0x10ffffu)) {
1562  			switch (errorHandling) {
1563  			case uehThrow: throw TUnicodeException(srcIdx - 1, c, "UTF-16 only supports characters in the range 0..10ffff (not " + TUInt::GetStr(c, "%08x") + ").");
1564  			case uehAbort: return nEncoded;
1565  #define ___OutRepl if (isDestLe) { dest.Add(replacementChar & 0xff); dest.Add((replacementChar >> 8) & 0xff); } else { dest.Add((replacementChar >> 8) & 0xff); dest.Add(replacementChar & 0xff); }
1566  			case uehReplace: ___OutRepl; continue;
1567  			case uehIgnore: continue;
1568  			default: Fail; } }
1569  		if (Utf16FirstSurrogate <= c && c < Utf16FirstSurrogate + 1023) {
1570  			switch (errorHandling) {
1571  			case uehThrow: throw TUnicodeException(srcIdx - 1, c, "UTF-16 cannot encode " + TUInt::GetStr(c, "%04x") + " as it belongs to the first surrogate range (" + TUInt::GetStr(Utf16FirstSurrogate, "%04x") + ".." + TUInt::GetStr(Utf16FirstSurrogate + 1023, "%04x") + ").");
1572  			case uehAbort: return nEncoded;
1573  			case uehReplace: ___OutRepl; continue;
1574  			case uehIgnore: continue;
1575  			default: Fail; } }
1576  		if (Utf16SecondSurrogate <= c && c < Utf16SecondSurrogate + 1023) {
1577  			switch (errorHandling) {
1578  			case uehThrow: throw TUnicodeException(srcIdx - 1, c, "The character " + TUInt::GetStr(c, "%04x") + " belongs to the second surrogate range (" + TUInt::GetStr(Utf16FirstSurrogate, "%04x") + ".." + TUInt::GetStr(Utf16FirstSurrogate + 1023, "%04x") + "), which is not allowed with strict == true.");
1579  			case uehAbort: return nEncoded;
1580  			case uehReplace: ___OutRepl; continue;
1581  			case uehIgnore: continue;
1582  			default: Fail; } }
1583  #undef ___OutRepl
1584  		if (c <= 0xffffu) {
1585  			if (isDestLe) { dest.Add(c & 0xff); dest.Add((c >> 8) & 0xff); }
1586  			else { dest.Add((c >> 8) & 0xff); dest.Add(c & 0xff); }
1587  			nEncoded++; continue; }
1588  		c -= 0x10000u; IAssert(&bsol;*0 <= c &&*/ c <= 0xfffffu);
1589  		uint c1 = (c >> 10) & 1023, c2 = c & 1023;
1590  		c1 += Utf16FirstSurrogate; c2 += Utf16SecondSurrogate;
1591  		if (isDestLe) { dest.Add(c1 & 0xff); dest.Add((c1 >> 8) & 0xff); dest.Add(c2 & 0xff); dest.Add((c2 >> 8) & 0xff); }
1592  		else { dest.Add((c1 >> 8) & 0xff); dest.Add(c1 & 0xff); dest.Add((c2 >> 8) & 0xff); dest.Add(c2 & 0xff); }
1593  		nEncoded++; continue;
1594  	}
1595  	return nEncoded;
1596  }
1597  template<typename TSrcVec>
1598  bool TUniChDb::FindNextWordBoundary(const TSrcVec& src, const size_t srcIdx, const size_t srcCount, size_t &position) const
1599  {
1600  	if (position < srcIdx) { position = srcIdx; return true; }
1601  	const size_t srcEnd = srcIdx + srcCount;
1602  	if (position >= srcEnd) return false;
1603  	size_t origPos = position;
1604  	if (IsWbIgnored(src[TVecIdx(position)])) {
1605  		if (! WbFindPrevNonIgnored(src, srcIdx, position))
1606  			position = origPos;
1607  	}
1608  	size_t posPrev = position;
1609  	if (! WbFindPrevNonIgnored(src, srcIdx, posPrev)) posPrev = position;
1610  	if (position == origPos && position + 1 < srcEnd && IsSbSep(src[TVecIdx(position)]) && IsWbIgnored(src[TVecIdx(position + 1)])) { position += 1; return true; }
1611  	size_t posNext = position; WbFindNextNonIgnored(src, posNext, srcEnd);
1612  	size_t posNext2;
1613  	int cPrev = (posPrev < position ? (int) src[TVecIdx(posPrev)] : -1), cCur = (position < srcEnd ? (int) src[TVecIdx(position)] : -1);
1614  	int cNext = (position < posNext && posNext < srcEnd ? (int) src[TVecIdx(posNext)] : -1);
1615  	int wbfPrev = GetWbFlags(cPrev), wbfCur = GetWbFlags(cCur), wbfNext = GetWbFlags(cNext);
1616  	int cNext2, wbfNext2;
1617  	for ( ; position < srcEnd; posPrev = position, position = posNext, posNext = posNext2,
1618  							   cPrev = cCur, cCur = cNext, cNext = cNext2,
1619  							   wbfPrev = wbfCur, wbfCur = wbfNext, wbfNext = wbfNext2)
1620  	{
1621  		posNext2 = posNext; WbFindNextNonIgnored(src, posNext2, srcEnd);
1622  		cNext2 = (posNext < posNext2 && posNext2 < srcEnd ? (int) src[TVecIdx(posNext2)] : -1);
1623  		wbfNext2 = GetWbFlags(cNext2);
1624  #define TestCurNext(curFlag, nextFlag) if ((wbfCur & curFlag) == curFlag && (wbfNext & nextFlag) == nextFlag) continue
1625  #define TestCurNext2(curFlag, nextFlag, next2Flag) if ((wbfCur & curFlag) == curFlag && (wbfNext & nextFlag) == nextFlag && (wbfNext2 & next2Flag) == next2Flag) continue
1626  #define TestPrevCurNext(prevFlag, curFlag, nextFlag) if ((wbfPrev & prevFlag) == prevFlag && (wbfCur & curFlag) == curFlag && (wbfNext & nextFlag) == nextFlag) continue
1627  		if (cCur == 13 && cNext == 10) continue;
1628  		TestCurNext(ucfWbALetter, ucfWbALetter);
1629  		TestCurNext2(ucfWbALetter, ucfWbMidLetter, ucfWbALetter);
1630  		TestPrevCurNext(ucfWbALetter, ucfWbMidLetter, ucfWbALetter);
1631  		TestCurNext(ucfWbNumeric, ucfWbNumeric);
1632  		TestCurNext(ucfWbALetter, ucfWbNumeric);
1633  		TestCurNext(ucfWbNumeric, ucfWbALetter);
1634  		TestPrevCurNext(ucfWbNumeric, ucfWbMidNum, ucfWbNumeric);
1635  		TestCurNext2(ucfWbNumeric, ucfWbMidNum, ucfWbNumeric);
1636  		TestCurNext(ucfWbKatakana, ucfWbKatakana);
1637  		if ((wbfCur & (ucfWbALetter | ucfWbNumeric | ucfWbKatakana | ucfWbExtendNumLet)) != 0 &&
1638  			(wbfNext & ucfWbExtendNumLet) == ucfWbExtendNumLet) continue;
1639  		if ((wbfCur & ucfWbExtendNumLet) == ucfWbExtendNumLet &&
1640  			(wbfNext & (ucfWbALetter | ucfWbNumeric | ucfWbKatakana)) != 0) continue;
1641  		position = posNext; return true;
1642  #undef TestCurNext
1643  #undef TestCurNext2
1644  #undef TestPrevCurNext
1645  	}
1646  	IAssert(position == srcEnd);
1647  	return true;
1648  }
1649  template<typename TSrcVec>
1650  void TUniChDb::FindWordBoundaries(const TSrcVec& src, const size_t srcIdx, const size_t srcCount, TBoolV& dest) const
1651  {
1652  	if (size_t(dest.Len()) != srcCount + 1) dest.Gen(TVecIdx(srcCount + 1));
1653  	dest.PutAll(false);
1654  	size_t position = srcIdx;
1655  	dest[TVecIdx(position - srcIdx)] = true;
1656  	while (position < srcIdx + srcCount)
1657  	{
1658  		size_t oldPos = position;
1659  		FindNextWordBoundary(src, srcIdx, srcCount, position);
1660      if (oldPos >= position) {
1661  		  Assert(oldPos < position);
1662      }
1663      Assert(position <= srcIdx + srcCount);
1664  		dest[TVecIdx(position - srcIdx)] = true;
1665  	}
1666  	Assert(dest[TVecIdx(srcCount)]);
1667  }
1668  template<typename TSrcVec>
1669  bool TUniChDb::CanSentenceEndHere(const TSrcVec& src, const size_t srcIdx, const size_t position) const
1670  {
1671  	if (sbExTrie.Empty()) return true;
1672  	size_t pos = position;
1673  	if (! WbFindPrevNonIgnored(src, srcIdx, pos)) return true;
1674  	int c = (int) src[TVecIdx(pos)]; int sfb = GetSbFlags(c);
1675  	if ((c & ucfSbSep) == ucfSbSep) {
1676  		if (! WbFindPrevNonIgnored(src, srcIdx, pos)) return true;
1677  		c = (int) src[TVecIdx(pos)]; sfb = GetSbFlags(c); }
1678  	while ((sfb & ucfSbSp) == ucfSbSp) {
1679  		if (! WbFindPrevNonIgnored(src, srcIdx, pos)) return true;
1680  		c = (int) src[TVecIdx(pos)]; sfb = GetSbFlags(c); }
1681  	while ((sfb & ucfSbSp) == ucfSbSp) {
1682  		if (! WbFindPrevNonIgnored(src, srcIdx, pos)) return true;
1683  		c = (int) src[TVecIdx(pos)]; sfb = GetSbFlags(c); }
1684  	while ((sfb & (ucfSbATerm | ucfSbSTerm)) != 0) {
1685  		if (! WbFindPrevNonIgnored(src, srcIdx, pos)) return true;
1686  		c = (int) src[TVecIdx(pos)]; sfb = GetSbFlags(c); }
1687  	int cLast = c, cButLast = -1, cButButLast = -1, len = 1, node = -1;
1688  	while (true)
1689  	{
1690  		bool atEnd = (! WbFindPrevNonIgnored(src, srcIdx, pos));
1691  		c = (atEnd ? -1 : (int) src[TVecIdx(pos)]);
1692  		TUniChCategory cat = GetCat(c);
1693  		if (atEnd || ! (cat == ucLetter || cat == ucNumber || cat == ucSymbol)) {
1694  			if (len == 1) return ! sbExTrie.Has1Gram(cLast);
1695  			if (len == 2) return ! sbExTrie.Has2Gram(cLast, cButLast);
1696  			IAssert(len >= 3); IAssert(node >= 0);
1697  			if (sbExTrie.IsNodeTerminal(node)) return false;
1698  			if (atEnd) return true; }
1699  		if (len == 1) { cButLast = c; len++; }
1700  		else if (len == 2) { cButButLast = c; len++;
1701  			node = sbExTrie.Get3GramRoot(cLast, cButLast, cButButLast);
1702  			if (node < 0) return true; }
1703  		else {
1704  			node = sbExTrie.GetChild(node, c);
1705  			if (node < 0) return true; }
1706  	}
1707  }
1708  template<typename TSrcVec>
1709  bool TUniChDb::FindNextSentenceBoundary(const TSrcVec& src, const size_t srcIdx, const size_t srcCount, size_t &position) const
1710  {
1711  	if (position < srcIdx) { position = srcIdx; return true; }
1712  	const size_t srcEnd = srcIdx + srcCount;
1713  	if (position >= srcEnd) return false;
1714  	size_t origPos = position;
1715  	if (IsWbIgnored(src[TVecIdx(position)])) {
1716  		if (! WbFindPrevNonIgnored(src, srcIdx, position))
1717  			position = origPos;
1718  	}
1719  	size_t posPrev = position;
1720  	if (! WbFindPrevNonIgnored(src, srcIdx, posPrev)) posPrev = position;
1721  	if (position == origPos && position + 1 < srcEnd && IsSbSep(src[TVecIdx(position)]) && IsWbIgnored(src[TVecIdx(position + 1)])) { position += 1; return true; }
1722  	size_t posNext = position; WbFindNextNonIgnored(src, posNext, srcEnd);
1723  	size_t posNext2;
1724  	int cPrev = (posPrev < position ? (int) src[TVecIdx(posPrev)] : -1), cCur = (position < srcEnd ? (int) src[TVecIdx(position)] : -1);
1725  	int cNext = (position < posNext && posNext < srcEnd ? (int) src[TVecIdx(posNext)] : -1);
1726  	int sbfPrev = GetSbFlags(cPrev), sbfCur = GetSbFlags(cCur), sbfNext = GetSbFlags(cNext);
1727  	int cNext2, sbfNext2;
1728  	typedef enum { stInit, stATerm, stATermSp, stATermSep, stSTerm, stSTermSp, stSTermSep } TPeekBackState;
1729  	TPeekBackState backState;
1730  	{
1731  		size_t pos = position;
1732  		bool wasSep = false, wasSp = false, wasATerm = false, wasSTerm = false;
1733  		while (true)
1734  		{
1735  			if (! WbFindPrevNonIgnored(src, srcIdx, pos)) break;
1736  			int cp = (int) src[TVecIdx(pos)]; int sbf = GetSbFlags(cp);
1737  			if ((sbf & ucfSbSep) == ucfSbSep) {
1738  				wasSep = true;
1739  				if (! WbFindPrevNonIgnored(src, srcIdx, pos)) break;
1740  				cp = (int) src[TVecIdx(pos)]; sbf = GetSbFlags(cp); }
1741  			bool stop = false;
1742  			while ((sbf & ucfSbSp) == ucfSbSp) {
1743  				wasSp = true;
1744  				if (! WbFindPrevNonIgnored(src, srcIdx, pos)) { stop = true; break; }
1745  				cp = (int) src[TVecIdx(pos)]; sbf = GetSbFlags(cp); }
1746  			if (stop) break;
1747  			while ((sbf & ucfSbClose) == ucfSbClose) {
1748  				if (! WbFindPrevNonIgnored(src, srcIdx, pos)) { stop = true; break; }
1749  				cp = (int) src[TVecIdx(pos)]; sbf = GetSbFlags(cp); }
1750  			if (stop) break;
1751  			wasATerm = ((sbf & ucfSbATerm) == ucfSbATerm);
1752  			wasSTerm = ((sbf & ucfSbSTerm) == ucfSbSTerm);
1753  			break;
1754  		}
1755  		if (wasATerm) backState = (wasSep ? stATermSep : wasSp ? stATermSp : stATerm);
1756  		else if (wasSTerm) backState = (wasSep ? stSTermSep : wasSp ? stSTermSp : stSTerm);
1757  		else backState = stInit;
1758  	}
1759  	typedef enum { stUnknown, stLower, stNotLower } TPeekAheadState;
1760  	TPeekAheadState aheadState = stUnknown;
1761  	for ( ; position < srcEnd; posPrev = position, position = posNext, posNext = posNext2,
1762  							   cPrev = cCur, cCur = cNext, cNext = cNext2,
1763  							   sbfPrev = sbfCur, sbfCur = sbfNext, sbfNext = sbfNext2)
1764  	{
1765  		posNext2 = posNext; WbFindNextNonIgnored(src, posNext2, srcEnd);
1766  		cNext2 = (posNext < posNext2 && posNext2 < srcEnd ? (int) src[TVecIdx(posNext2)] : -1);
1767  		sbfNext2 = GetSbFlags(cNext2);
1768  #define TestCur(curFlag) ((sbfCur & ucfSb##curFlag) == ucfSb##curFlag)
1769  #define Trans(curFlag, newState) if (TestCur(curFlag)) { backState = st##newState; break; }
1770  		switch (backState) {
1771  			case stInit: Trans(ATerm, ATerm); Trans(STerm, STerm); break;
1772  			case stATerm: Trans(Sp, ATermSp); Trans(Sep, ATermSep); Trans(ATerm, ATerm); Trans(STerm, STerm); Trans(Close, ATerm); backState = stInit; break;
1773  			case stSTerm: Trans(Sp, STermSp); Trans(Sep, STermSep); Trans(ATerm, ATerm); Trans(STerm, STerm); Trans(Close, STerm); backState = stInit; break;
1774  			case stATermSp: Trans(Sp, ATermSp); Trans(Sep, ATermSep); Trans(ATerm, ATerm); Trans(STerm, STerm); backState = stInit; break;
1775  			case stSTermSp: Trans(Sp, STermSp); Trans(Sep, STermSep); Trans(ATerm, ATerm); Trans(STerm, STerm); backState = stInit; break;
1776  			case stATermSep: Trans(ATerm, ATerm); Trans(STerm, STerm); backState = stInit; break;
1777  			case stSTermSep: Trans(ATerm, ATerm); Trans(STerm, STerm); backState = stInit; break;
1778  			default: IAssert(false); }
1779  #undef Trans
1780  #undef TestCur
1781  #define IsPeekAheadSkippable(sbf) ((sbf & (ucfSbOLetter | ucfSbUpper | ucfSbLower | ucfSbSep | ucfSbSTerm | ucfSbATerm)) == 0)
1782  		if (! IsPeekAheadSkippable(sbfCur)) {
1783  			bool isLower = ((sbfCur & ucfSbLower) == ucfSbLower);
1784  			if (aheadState == stLower) IAssert(isLower);
1785  			else if (aheadState == stNotLower) IAssert(! isLower);
1786  			aheadState = stUnknown; }
1787  		if (aheadState == stUnknown)
1788  		{
1789  			size_t pos = posNext;
1790  			while (pos < srcEnd) {
1791  				int cp = (int) src[TVecIdx(pos)]; int sbf = GetSbFlags(cp);
1792  				if (! IsPeekAheadSkippable(sbf)) {
1793  					if ((sbf & ucfSbLower) == ucfSbLower) aheadState = stLower;
1794  					else aheadState = stNotLower;
1795  					break; }
1796  				WbFindNextNonIgnored(src, pos, srcEnd); }
1797  			if (! (pos < srcEnd)) aheadState = stNotLower;
1798  		}
1799  #undef IsPeekAheadSkippable
1800  #define TestCurNext(curFlag, nextFlag) if ((sbfCur & curFlag) == curFlag && (sbfNext & nextFlag) == nextFlag) continue
1801  #define TestCurNext2(curFlag, nextFlag, next2Flag) if ((sbfCur & curFlag) == curFlag && (sbfNext & nextFlag) == nextFlag && (sbfNext2 & next2Flag) == next2Flag) continue
1802  #define TestPrevCurNext(prevFlag, curFlag, nextFlag) if ((sbfPrev & prevFlag) == prevFlag && (sbfCur & curFlag) == curFlag && (sbfNext & nextFlag) == nextFlag) continue
1803  		if (cCur == 13 && cNext == 10) continue;
1804  		if ((sbfCur & ucfSbSep) == ucfSbSep) {
1805  			if (! CanSentenceEndHere(src, srcIdx, position)) continue;
1806  			position = posNext; return true; }
1807  		TestCurNext(ucfSbATerm, ucfSbNumeric); 
1808  		TestPrevCurNext(ucfSbUpper, ucfSbATerm, ucfSbUpper); 
1809  		if ((backState == stATerm || backState == stATermSp || backState == stSTerm || backState == stSTermSp) &&
1810  			(sbfNext & (ucfSbSTerm | ucfSbATerm)) != 0) continue;
1811  		if ((backState == stATerm || backState == stATermSp) && aheadState == stLower) continue;
1812  		if ((backState == stATerm || backState == stSTerm) && (sbfNext & (ucfSbClose | ucfSbSp | ucfSbSep)) != 0) continue;
1813  		if (backState == stATerm || backState == stATermSp || backState == stATermSep || backState == stSTerm || backState == stSTermSp || backState == stSTermSep) {
1814  			if ((sbfNext & (ucfSbSp | ucfSbSep)) != 0) continue; 
1815  			if (! CanSentenceEndHere(src, srcIdx, position)) continue;
1816  			position = posNext; return true; } 
1817  		continue;
1818  #undef TestCurNext
1819  #undef TestCurNext2
1820  #undef TestPrevCurNext
1821  	}
1822  	IAssert(position == srcEnd);
1823  	return true;
1824  }
1825  template<typename TSrcVec>
1826  void TUniChDb::FindSentenceBoundaries(const TSrcVec& src, const size_t srcIdx, const size_t srcCount, TBoolV& dest) const
1827  {
1828  	if (size_t(dest.Len()) != srcCount + 1) dest.Gen(TVecIdx(srcCount + 1));
1829  	dest.PutAll(false);
1830  	size_t position = srcIdx;
1831  	dest[TVecIdx(position - srcIdx)] = true;
1832  	while (position < srcIdx + srcCount)
1833  	{
1834  		size_t oldPos = position;
1835  		FindNextSentenceBoundary(src, srcIdx, srcCount, position);
1836      if (oldPos >= position) {
1837  		  Assert(oldPos < position);
1838      }
1839      Assert(position <= srcIdx + srcCount);
1840  		dest[TVecIdx(position - srcIdx)] = true;
1841  	}
1842  	Assert(dest[TVecIdx(srcCount)]);
1843  }
1844  template<typename TSrcVec, typename TDestCh>
1845  void TUniChDb::GetCaseConverted(const TSrcVec& src, size_t srcIdx, const size_t srcCount,
1846  								TVec<TDestCh>& dest, const bool clrDest,
1847  								const TUniChDb::TCaseConversion how,
1848  								const bool turkic, const bool lithuanian) const
1849  {
1850  	const TIntIntVH &specials = (how == ccUpper ? specialCasingUpper : how == ccLower ? specialCasingLower : how == ccTitle ? specialCasingTitle : *((TIntIntVH *) 0));
1851  	if (clrDest) dest.Clr();
1852  	enum {
1853  		GreekCapitalLetterSigma = 0x3a3,
1854  		GreekSmallLetterSigma = 0x3c3,
1855  		GreekSmallLetterFinalSigma = 0x3c2,
1856  		LatinCapitalLetterI = 0x49,
1857  		LatinCapitalLetterJ = 0x4a,
1858  		LatinCapitalLetterIWithOgonek = 0x12e,
1859  		LatinCapitalLetterIWithGrave = 0xcc,
1860  		LatinCapitalLetterIWithAcute = 0xcd,
1861  		LatinCapitalLetterIWithTilde = 0x128,
1862  		LatinCapitalLetterIWithDotAbove = 0x130,
1863  		LatinSmallLetterI = 0x69,
1864  		CombiningDotAbove = 0x307
1865  	};
1866  	bool seenCased = false, seenTwoCased = false; int cpFirstCased = -1;
1867  	size_t nextWordBoundary = srcIdx;
1868  	TBoolV wordBoundaries; bool wbsKnown = false;
1869  	for (const size_t origSrcIdx = srcIdx, srcEnd = srcIdx + srcCount; srcIdx < srcEnd; )
1870  	{
1871  		int cp = src[TVecIdx(srcIdx)]; srcIdx++;
1872  		TUniChDb::TCaseConversion howHere;
1873  		if (how != ccTitle) howHere = how;
1874  		else {
1875  			if (srcIdx - 1 == nextWordBoundary) { 
1876  				seenCased = false; seenTwoCased = false; cpFirstCased = -1;
1877  				size_t next = nextWordBoundary; FindNextWordBoundary(src, origSrcIdx, srcCount, next);
1878  				IAssert(next > nextWordBoundary); nextWordBoundary = next; }
1879  			bool isCased = IsCased(cp);
1880  			if (isCased && ! seenCased) { howHere = ccTitle; seenCased = true; cpFirstCased = cp; }
1881  			else { howHere = ccLower;
1882  				if (isCased && seenCased) seenTwoCased = true; }
1883  		}
1884  		if (cp == GreekCapitalLetterSigma && howHere == ccLower)
1885  		{
1886  			if (! wbsKnown) { FindWordBoundaries(src, origSrcIdx, srcCount, wordBoundaries); wbsKnown = true; }
1887  			size_t srcIdx2 = srcIdx; bool casedAfter = false;
1888  			if (how == ccTitle)
1889  				printf("!");
1890  			while (! wordBoundaries[TVecIdx(srcIdx2 - origSrcIdx)])
1891  			{
1892  				int cp2 = src[TVecIdx(srcIdx2)]; srcIdx2++;
1893  				if (IsCased(cp2)) { casedAfter = true; break; }
1894  			}
1895  			if (! casedAfter)
1896  			{
1897  				srcIdx2 = srcIdx - 1; bool casedBefore = false;
1898  				while (! wordBoundaries[TVecIdx(srcIdx2 - origSrcIdx)])
1899  				{
1900  					--srcIdx2; int cp2 = src[TVecIdx(srcIdx2)];
1901  					if (IsCased(cp2)) { casedBefore = true; break; }
1902  				}
1903  				if (casedBefore) {
1904  					dest.Add(GreekSmallLetterFinalSigma); Assert(howHere == ccLower); continue; }
1905  			}
1906  			dest.Add(GreekSmallLetterSigma); continue;
1907  		}
1908  		else if (lithuanian)
1909  		{
1910  			if (howHere == ccLower)
1911  			{
1912  				if (cp == LatinCapitalLetterI || cp == LatinCapitalLetterJ || cp == LatinCapitalLetterIWithOgonek)
1913  				{
1914  					bool moreAbove = false;
1915  					for (size_t srcIdx2 = srcIdx; srcIdx2 < srcEnd; )
1916  					{
1917  						const int cp2 = src[TVecIdx(srcIdx2)]; srcIdx2++;
1918  						const int cc2 = GetCombiningClass(cp2);
1919  						if (cc2 == TUniChInfo::ccStarter) break;
1920  						if (cc2 == TUniChInfo::ccAbove) { moreAbove = true; break; }
1921  					}
1922  					if (moreAbove)
1923  					{
1924  						if (cp == LatinCapitalLetterI) { dest.Add(0x69); dest.Add(0x307); continue; }
1925  						if (cp == LatinCapitalLetterJ) { dest.Add(0x6a); dest.Add(0x307); continue; }
1926  						if (cp == LatinCapitalLetterIWithOgonek) { dest.Add(0x12f); dest.Add(0x307); continue; }
1927  					}
1928  				}
1929  				else if (cp == LatinCapitalLetterIWithGrave) { dest.Add(0x69); dest.Add(0x307); dest.Add(0x300); continue; }
1930  				else if (cp == LatinCapitalLetterIWithAcute) { dest.Add(0x69); dest.Add(0x307); dest.Add(0x301); continue; }
1931  				else if (cp == LatinCapitalLetterIWithTilde) { dest.Add(0x69); dest.Add(0x307); dest.Add(0x303); continue; }
1932  			}
1933  			if (cp == CombiningDotAbove)
1934  			{
1935  				bool afterSoftDotted = false;
1936  				size_t srcIdx2 = srcIdx - 1; 
1937  				while (origSrcIdx < srcIdx2)
1938  				{
1939  					--srcIdx2; int cp2 = src[TVecIdx(srcIdx2)];
1940  					int cc2 = GetCombiningClass(cp2);
1941  					if (cc2 == TUniChInfo::ccAbove) break;
1942  					if (cc2 == TUniChInfo::ccStarter) {
1943  						afterSoftDotted = IsSoftDotted(cp2); break; }
1944  				}
1945  				if (afterSoftDotted)
1946  				{
1947  					Assert(lithuanian);
1948  					if (how == ccLower) { dest.Add(0x307); continue; }
1949  					if (how == ccUpper) continue;
1950  					Assert(how == ccTitle);
1951  					Assert(howHere == ccLower); 
1952  					if (seenCased && ! seenTwoCased) continue; 
1953  					dest.Add(0x307); continue;
1954  				}
1955  			}
1956  		}
1957  		else if (turkic) 
1958  		{
1959  			if (cp == LatinCapitalLetterIWithDotAbove) {
1960  				dest.Add(howHere == ccLower ? 0x69 : 0x130); continue; }
1961  			else if (cp == CombiningDotAbove)
1962  			{
1963  				bool afterI = false;
1964  				size_t srcIdx2 = srcIdx - 1; 
1965  				while (origSrcIdx < srcIdx2)
1966  				{
1967  					--srcIdx2; int cp2 = src[TVecIdx(srcIdx2)];
1968  					if (cp2 == LatinCapitalLetterI) { afterI = true; break; }
1969  					int cc2 = GetCombiningClass(cp2);
1970  					if (cc2 == TUniChInfo::ccAbove || cc2 == TUniChInfo::ccStarter) break;
1971  				}
1972  				if (afterI) {
1973  					if (how == ccTitle && seenCased && ! seenTwoCased) {
1974  						IAssert(cpFirstCased == LatinCapitalLetterI);
1975  						dest.Add(0x307); continue; }
1976  					if (howHere != ccLower) dest.Add(0x307);
1977  					continue; }
1978  			}
1979  			else if (cp == LatinCapitalLetterI)
1980  			{
1981  				bool beforeDot = false;
1982  				for (size_t srcIdx2 = srcIdx; srcIdx2 < srcEnd; )
1983  				{
1984  					const int cp2 = src[TVecIdx(srcIdx2)]; srcIdx2++;
1985  					if (cp2 == 0x307) { beforeDot = true; break; }
1986  					const int cc2 = GetCombiningClass(cp2);
1987  					if (cc2 == TUniChInfo::ccStarter || cc2 == TUniChInfo::ccAbove) break;
1988  				}
1989  				if (! beforeDot) {
1990  					dest.Add(howHere == ccLower ? 0x131 : 0x49); continue; }
1991  			}
1992  			else if (cp == LatinSmallLetterI)
1993  			{
1994  				dest.Add(howHere == ccLower ? 0x69 : 0x130); continue;
1995  			}
1996  		}
1997  		const TIntIntVH &specHere = (
1998  			howHere == how ? specials :
1999  			howHere == ccLower ? specialCasingLower :
2000  			howHere == ccTitle ? specialCasingTitle :
2001  			howHere == ccUpper ? specialCasingUpper : *((TIntIntVH *) 0));
2002  		int i = specHere.GetKeyId(cp);
2003  		if (i >= 0) { TUniCaseFolding::AppendVector(specHere[i], dest); continue; }
2004  		i = h.GetKeyId(cp);
2005  		if (i >= 0) {
2006  			const TUniChInfo &ci = h[i];
2007  			int cpNew = (
2008  				howHere == ccLower ? ci.simpleLowerCaseMapping :
2009  				howHere == ccUpper ? ci.simpleUpperCaseMapping :
2010  									 ci.simpleTitleCaseMapping);
2011  			if (cpNew < 0) cpNew = cp;
2012  			dest.Add(cpNew); continue; }
2013  		dest.Add(cp);
2014  	}
2015  }
2016  template<typename TSrcVec, typename TDestCh>
2017  void TUniChDb::GetSimpleCaseConverted(const TSrcVec& src, size_t srcIdx, const size_t srcCount,
2018  	TVec<TDestCh>& dest, const bool clrDest, const TCaseConversion how) const
2019  {
2020  	if (clrDest) dest.Clr();
2021  	bool seenCased = false; size_t nextWordBoundary = srcIdx;
2022  	for (const size_t origSrcIdx = srcIdx, srcEnd = srcIdx + srcCount; srcIdx < srcEnd; )
2023  	{
2024  		const int cp = src[TVecIdx(srcIdx)]; srcIdx++;
2025  		int i = h.GetKeyId(cp); if (i < 0) { dest.Add(cp); continue; }
2026  		const TUniChInfo &ci = h[i];
2027  		TUniChDb::TCaseConversion howHere;
2028  		if (how != ccTitle) howHere = how;
2029  		else {
2030  			if (srcIdx - 1 == nextWordBoundary) { 
2031  				seenCased = false;
2032  				size_t next = nextWordBoundary; FindNextWordBoundary(src, origSrcIdx, srcCount, next);
2033  				IAssert(next > nextWordBoundary); nextWordBoundary = next; }
2034  			bool isCased = IsCased(cp);
2035  			if (isCased && ! seenCased) { howHere = ccTitle; seenCased = true; }
2036  			else howHere = ccLower;
2037  		}
2038  		int cpNew = (howHere == ccTitle ? ci.simpleTitleCaseMapping : howHere == ccUpper ? ci.simpleUpperCaseMapping : ci.simpleLowerCaseMapping);
2039  		if (cpNew < 0) cpNew = cp;
2040  		dest.Add(cpNew);
2041  	}
2042  }
2043  template<typename TSrcVec>
2044  void TUniChDb::ToSimpleCaseConverted(TSrcVec& src, size_t srcIdx, const size_t srcCount, const TCaseConversion how) const
2045  {
2046  	bool seenCased = false; size_t nextWordBoundary = srcIdx;
2047  	for (const size_t origSrcIdx = srcIdx, srcEnd = srcIdx + srcCount; srcIdx < srcEnd; srcIdx++)
2048  	{
2049  		const int cp = src[TVecIdx(srcIdx)];
2050  		int i = h.GetKeyId(cp); if (i < 0) continue;
2051  		const TUniChInfo &ci = h[i];
2052  		TUniChDb::TCaseConversion howHere;
2053  		if (how != ccTitle) howHere = how;
2054  		else {
2055  			if (srcIdx == nextWordBoundary) { 
2056  				seenCased = false;
2057  				size_t next = nextWordBoundary; FindNextWordBoundary(src, origSrcIdx, srcCount, next);
2058  				IAssert(next > nextWordBoundary); nextWordBoundary = next; }
2059  			bool isCased = IsCased(cp);
2060  			if (isCased && ! seenCased) { howHere = ccTitle; seenCased = true; }
2061  			else howHere = ccLower;
2062  		}
2063  		int cpNew = (howHere == ccTitle ? ci.simpleTitleCaseMapping : howHere == ccUpper ? ci.simpleUpperCaseMapping : ci.simpleLowerCaseMapping);
2064  		if (cpNew >= 0) src[TVecIdx(srcIdx)] = cpNew;
2065  	}
2066  }
2067  template<typename TDestCh>
2068  void TUniChDb::AddDecomposition(const int codePoint, TVec<TDestCh>& dest, const bool compatibility) const
2069  {
2070  	if (HangulSBase <= codePoint && codePoint < HangulSBase + HangulSCount)
2071  	{
2072  		const int SIndex = codePoint - HangulSBase;
2073  		const int L = HangulLBase + SIndex / HangulNCount;
2074  		const int V = HangulVBase + (SIndex % HangulNCount) / HangulTCount;
2075  		const int T = HangulTBase + (SIndex % HangulTCount);
2076  		dest.Add(L); dest.Add(V);
2077  		if (T != HangulTBase) dest.Add(T);
2078  		return;
2079  	}
2080  	int i = h.GetKeyId(codePoint); if (i < 0) { dest.Add(codePoint); return; }
2081  	const TUniChInfo &ci = h[i];
2082  	int ofs = ci.decompOffset; if (ofs < 0) { dest.Add(codePoint); return; }
2083  	if ((! compatibility) && ci.IsCompatibilityDecomposition()) { dest.Add(codePoint); return; }
2084  	while (true) {
2085  		int cp = decompositions[ofs++]; if (cp < 0) return;
2086  		AddDecomposition(cp, dest, compatibility); }
2087  }
2088  template<typename TSrcVec, typename TDestCh>
2089  void TUniChDb::Decompose(const TSrcVec& src, size_t srcIdx, const size_t srcCount,
2090  		TVec<TDestCh>& dest, const bool compatibility, bool clrDest) const
2091  {
2092  	if (clrDest) dest.Clr();
2093  	const size_t destStart = dest.Len()&bsol;*, srcEnd = srcIdx + srcCount*/;
2094  	while (srcIdx < srcCount) {
2095  		AddDecomposition(src[TVecIdx(srcIdx)], dest, compatibility); srcIdx++; }
2096  	for (size_t destIdx = destStart, destEnd = dest.Len(); destIdx < destEnd; )
2097  	{
2098  		size_t j = destIdx;
2099  		int cp = dest[TVecIdx(destIdx)]; destIdx++;
2100  		int cpCls = GetCombiningClass(cp);
2101  		if (cpCls == TUniChInfo::ccStarter) continue;
2102  		while (destStart < j && GetCombiningClass(dest[TVecIdx(j - 1)]) > cpCls) {
2103  			dest[TVecIdx(j)] = dest[TVecIdx(j - 1)]; j--; }
2104  		dest[TVecIdx(j)] = cp;
2105  	}
2106  }
2107  template<typename TSrcVec, typename TDestCh>
2108  void TUniChDb::DecomposeAndCompose(const TSrcVec& src, size_t srcIdx, const size_t srcCount,
2109  		TVec<TDestCh>& dest, bool compatibility, bool clrDest) const
2110  {
2111  	if (clrDest) dest.Clr();
2112  	TIntV temp;
2113  	Decompose(src, srcIdx, srcCount, temp, compatibility);
2114  	Compose(temp, 0, temp.Len(), dest, clrDest);
2115  }
2116  template<typename TSrcVec, typename TDestCh>
2117  void TUniChDb::Compose(const TSrcVec& src, size_t srcIdx, const size_t srcCount,
2118  		TVec<TDestCh>& dest, bool clrDest) const
2119  {
2120  	if (clrDest) dest.Clr();
2121  	bool lastStarterKnown = false; 
2122  	size_t lastStarterPos = size_t(-1);  
2123  	int cpLastStarter = -1; 
2124  	const size_t srcEnd = srcIdx + srcCount;
2125  	int ccMax = -1; 
2126  	while (srcIdx < srcEnd)
2127  	{
2128  		const int cp = src[TVecIdx(srcIdx)]; srcIdx++;
2129  		const int cpClass = GetCombiningClass(cp);
2130  		if (lastStarterKnown && ccMax < cpClass)
2131  		{
2132  			int j = inverseDec.GetKeyId(TIntPr(cpLastStarter, cp));
2133  			int cpCombined = -1;
2134  			do {
2135  				if (j >= 0) { cpCombined = inverseDec[j]; break; }
2136  				const int LIndex = cpLastStarter - HangulLBase;
2137  				if (0 <= LIndex && LIndex < HangulLCount) {
2138  					const int VIndex = cp - HangulVBase;
2139  					if (0 <= VIndex && VIndex < HangulVCount) {
2140  						cpCombined = HangulSBase + (LIndex * HangulVCount + VIndex) * HangulTCount;
2141  						break; } }
2142  				const int SIndex = cpLastStarter - HangulSBase;
2143  				if (0 <= SIndex && SIndex < HangulSCount && (SIndex % HangulTCount) == 0)
2144  				{
2145  					const int TIndex = cp - HangulTBase;
2146  					if (0 <= TIndex && TIndex < HangulTCount) {
2147  						cpCombined = cpLastStarter + TIndex;
2148  						break; }
2149  				}
2150  			} while (false);
2151  			if (cpCombined >= 0) {
2152  				dest[TVecIdx(lastStarterPos)] = cpCombined;
2153  				Assert(GetCombiningClass(cpCombined) == TUniChInfo::ccStarter);
2154  				cpLastStarter = cpCombined; continue; }
2155  		}
2156  		if (cpClass == TUniChInfo::ccStarter) { 
2157  			lastStarterKnown = true; lastStarterPos = dest.Len(); cpLastStarter = cp; ccMax = cpClass - 1; }
2158  		else if (cpClass > ccMax) 
2159  			ccMax = cpClass;
2160  		dest.Add(cp);
2161  	}
2162  }
2163  template<typename TSrcVec, typename TDestCh>
2164  size_t TUniChDb::ExtractStarters(const TSrcVec& src, size_t srcIdx, const size_t srcCount,
2165  		TVec<TDestCh>& dest, bool clrDest) const
2166  {
2167  	if (clrDest) dest.Clr();
2168  	size_t retVal = 0;
2169  	for (const size_t srcEnd = srcIdx + srcCount; srcIdx < srcEnd; srcIdx++) {
2170  		const int cp = src[TVecIdx(srcIdx)];
2171  		if (GetCombiningClass(cp) == TUniChInfo::ccStarter)
2172  			{ dest.Add(cp); retVal++; } }
2173  	return retVal;
2174  }
2175  inline bool AlwaysFalse()
2176  {
2177  	int sum = 0;
2178  	for (int i = 0; i < 5; i++) sum += i;
2179  	return sum > 100;
2180  }
2181  inline bool AlwaysTrue()
2182  {
2183  	int sum = 0;
2184  	for (int i = 0; i < 5; i++) sum += i;
2185  	return sum < 100;
2186  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-gksvml.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-unicode.h</div>
                </div>
                <div class="column column_space"><pre><code>37    PGksFont GetFont() { return CurFont;}
38    void PutPixel(const int& X, const int& Y, const TGksColor& GksColor) {
</pre></code></div>
                <div class="column column_space"><pre><code>1232  	TUniChSubCategory GetSubCat(const int cp) const { return ucd.GetSubCat(cp); }
1233  	const char *GetCharName(const int cp) const { return ucd.GetCharName(cp); }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    