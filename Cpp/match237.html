<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for main_1.c &amp; Epd2wb.cpp</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for main_1.c &amp; Epd2wb.cpp
      </h3>
<h1 align="center">
        0.8%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>main_1.c (3.2876713%)<th>Epd2wb.cpp (0.4643963%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(476-487)<td><a href="#" name="0">(3100-3110)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>main_1.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;stdio.h&gt;
2 #include &lt;stdlib.h&gt;
3 #include &lt;string.h&gt;
4 #include &lt;signal.h&gt;
5 #include "defs.h"
6 #include "data.h"
7 #include "protos.h"
8 #include &lt;sys/timeb.h&gt;
9 BOOL ftime_ok = FALSE;  int get_ms()
10 {
11 	struct timeb timebuffer;
12 	ftime(&amp;timebuffer);
13 	if (timebuffer.millitm != 0)
14 		ftime_ok = TRUE;
15 	return (timebuffer.time * 1000) + timebuffer.millitm;
16 }
17 int main()
18 {
19 	int computer_side;
20 	char s[256];
21 	int m;
22 	printf("\n");
23 	printf("Tom Kerrigan's Simple Chess Program (TSCP)\n");
24 	printf("version 1.81, 2/5/03\n");
25 	printf("Copyright 1997 Tom Kerrigan\n");
26 	printf("\n");
27 	printf("\"help\" displays a list of commands.\n");
28 	printf("\n");
29 	init_hash();
30 	init_board();
31 	open_book();
32 	gen();
33 	computer_side = EMPTY;
34 	max_time = 1 &lt;&lt; 25;
35 	max_depth = 4;
36 	for (;;) {
37 		if (side == computer_side) {  			
38 			think(1);
39 			if (!pv[0][0].u) {
40 				printf("(no legal moves)\n");
41 				computer_side = EMPTY;
42 				continue;
43 			}
44 			printf("Computer's move: %s\n", move_str(pv[0][0].b));
45 			makemove(pv[0][0].b);
46 			ply = 0;
47 			gen();
48 			print_result();
49 			continue;
50 		}
51 		printf("tscp&gt; ");
52 		if (scanf("%s", s) == EOF)
53 			return 0;
54 		if (!strcmp(s, "on")) {
55 			computer_side = side;
56 			continue;
57 		}
58 		if (!strcmp(s, "off")) {
59 			computer_side = EMPTY;
60 			continue;
61 		}
62 		if (!strcmp(s, "st")) {
63 			scanf("%d", &amp;max_time);
64 			max_time *= 1000;
65 			max_depth = 32;
66 			continue;
67 		}
68 		if (!strcmp(s, "sd")) {
69 			scanf("%d", &amp;max_depth);
70 			max_time = 1 &lt;&lt; 25;
71 			continue;
72 		}
73 		if (!strcmp(s, "undo")) {
74 			if (!hply)
75 				continue;
76 			computer_side = EMPTY;
77 			takeback();
78 			ply = 0;
79 			gen();
80 			continue;
81 		}
82 		if (!strcmp(s, "new")) {
83 			computer_side = EMPTY;
84 			init_board();
85 			gen();
86 			continue;
87 		}
88 		if (!strcmp(s, "d")) {
89 			print_board();
90 			continue;
91 		}
92 		if (!strcmp(s, "bench")) {
93 			computer_side = EMPTY;
94 			bench();
95 			continue;
96 		}
97 		if (!strcmp(s, "bye")) {
98 			printf("Share and enjoy!\n");
99 			break;
100 		}
101 		if (!strcmp(s, "xboard")) {
102 			xboard();
103 			break;
104 		}
105 		if (!strcmp(s, "help")) {
106 			printf("on - computer plays for the side to move\n");
107 			printf("off - computer stops playing\n");
108 			printf("st n - search for n seconds per move\n");
109 			printf("sd n - search n ply per move\n");
110 			printf("undo - takes back a move\n");
111 			printf("new - starts a new game\n");
112 			printf("d - display the board\n");
113 			printf("bench - run the built-in benchmark\n");
114 			printf("bye - exit the program\n");
115 			printf("xboard - switch to XBoard mode\n");
116 			printf("Enter moves in coordinate notation, e.g., e2e4, e7e8Q\n");
117 			continue;
118 		}
119 		m = parse_move(s);
120 		if (m == -1 || !makemove(gen_dat[m].m.b))
121 			printf("Illegal move.\n");
122 		else {
123 			ply = 0;
124 			gen();
125 			print_result();
126 		}
127 	}
128 	close_book();
129 	return 0;
130 }
131 int parse_move(char *s)
132 {
133 	int from, to, i;
134 	if (s[0] &lt; 'a' || s[0] &gt; 'h' ||
135 			s[1] &lt; '0' || s[1] &gt; '9' ||
136 			s[2] &lt; 'a' || s[2] &gt; 'h' ||
137 			s[3] &lt; '0' || s[3] &gt; '9')
138 		return -1;
139 	from = s[0] - 'a';
140 	from += 8 * (8 - (s[1] - '0'));
141 	to = s[2] - 'a';
142 	to += 8 * (8 - (s[3] - '0'));
143 	for (i = 0; i &lt; first_move[1]; ++i)
144 		if (gen_dat[i].m.b.from == from &amp;&amp; gen_dat[i].m.b.to == to) {
145 			if (gen_dat[i].m.b.bits &amp; 32)
146 				switch (s[4]) {
147 					case 'N':
148 						return i;
149 					case 'B':
150 						return i + 1;
151 					case 'R':
152 						return i + 2;
153 					default:  						return i + 3;
154 				}
155 			return i;
156 		}
157 	return -1;
158 }
159 char *move_str(move_bytes m)
160 {
161 	static char str[6];
162 	char c;
163 	if (m.bits &amp; 32) {
164 		switch (m.promote) {
165 			case KNIGHT:
166 				c = 'n';
167 				break;
168 			case BISHOP:
169 				c = 'b';
170 				break;
171 			case ROOK:
172 				c = 'r';
173 				break;
174 			default:
175 				c = 'q';
176 				break;
177 		}
178 		sprintf(str, "%c%d%c%d%c",
179 				COL(m.from) + 'a',
180 				8 - ROW(m.from),
181 				COL(m.to) + 'a',
182 				8 - ROW(m.to),
183 				c);
184 	}
185 	else
186 		sprintf(str, "%c%d%c%d",
187 				COL(m.from) + 'a',
188 				8 - ROW(m.from),
189 				COL(m.to) + 'a',
190 				8 - ROW(m.to));
191 	return str;
192 }
193 void print_board()
194 {
195 	int i;
196 	printf("\n8 ");
197 	for (i = 0; i &lt; 64; ++i) {
198 		switch (color[i]) {
199 			case EMPTY:
200 				printf(" .");
201 				break;
202 			case LIGHT:
203 				printf(" %c", piece_char[piece[i]]);
204 				break;
205 			case DARK:
206 				printf(" %c", piece_char[piece[i]] + ('a' - 'A'));
207 				break;
208 		}
209 		if ((i + 1) % 8 == 0 &amp;&amp; i != 63)
210 			printf("\n%d ", 7 - ROW(i));
211 	}
212 	printf("\n\n   a b c d e f g h\n\n");
213 }
214 void xboard()
215 {
216 	int computer_side;
217 	char line[256], command[256];
218 	int m;
219 	int post = 0;
220 	signal(SIGINT, SIG_IGN);
221 	printf("\n");
222 	init_board();
223 	gen();
224 	computer_side = EMPTY;
225 	for (;;) {
226 		fflush(stdout);
227 		if (side == computer_side) {
228 			think(post);
229 			if (!pv[0][0].u) {
230 				computer_side = EMPTY;
231 				continue;
232 			}
233 			printf("move %s\n", move_str(pv[0][0].b));
234 			makemove(pv[0][0].b);
235 			ply = 0;
236 			gen();
237 			print_result();
238 			continue;
239 		}
240 		if (!fgets(line, 256, stdin))
241 			return;
242 		if (line[0] == '\n')
243 			continue;
244 		sscanf(line, "%s", command);
245 		if (!strcmp(command, "xboard"))
246 			continue;
247 		if (!strcmp(command, "new")) {
248 			init_board();
249 			gen();
250 			computer_side = DARK;
251 			continue;
252 		}
253 		if (!strcmp(command, "quit"))
254 			return;
255 		if (!strcmp(command, "force")) {
256 			computer_side = EMPTY;
257 			continue;
258 		}
259 		if (!strcmp(command, "white")) {
260 			side = LIGHT;
261 			xside = DARK;
262 			gen();
263 			computer_side = DARK;
264 			continue;
265 		}
266 		if (!strcmp(command, "black")) {
267 			side = DARK;
268 			xside = LIGHT;
269 			gen();
270 			computer_side = LIGHT;
271 			continue;
272 		}
273 		if (!strcmp(command, "st")) {
274 			sscanf(line, "st %d", &amp;max_time);
275 			max_time *= 1000;
276 			max_depth = 32;
277 			continue;
278 		}
279 		if (!strcmp(command, "sd")) {
280 			sscanf(line, "sd %d", &amp;max_depth);
281 			max_time = 1 &lt;&lt; 25;
282 			continue;
283 		}
284 		if (!strcmp(command, "time")) {
285 			sscanf(line, "time %d", &amp;max_time);
286 			max_time *= 10;
287 			max_time /= 30;
288 			max_depth = 32;
289 			continue;
290 		}
291 		if (!strcmp(command, "otim")) {
292 			continue;
293 		}
294 		if (!strcmp(command, "go")) {
295 			computer_side = side;
296 			continue;
297 		}
298 		if (!strcmp(command, "hint")) {
299 			think(0);
300 			if (!pv[0][0].u)
301 				continue;
302 			printf("Hint: %s\n", move_str(pv[0][0].b));
303 			continue;
304 		}
305 		if (!strcmp(command, "undo")) {
306 			if (!hply)
307 				continue;
308 			takeback();
309 			ply = 0;
310 			gen();
311 			continue;
312 		}
313 		if (!strcmp(command, "remove")) {
314 			if (hply &lt; 2)
315 				continue;
316 			takeback();
317 			takeback();
318 			ply = 0;
319 			gen();
320 			continue;
321 		}
322 		if (!strcmp(command, "post")) {
323 			post = 2;
324 			continue;
325 		}
326 		if (!strcmp(command, "nopost")) {
327 			post = 0;
328 			continue;
329 		}
330 		m = parse_move(line);
331 		if (m == -1 || !makemove(gen_dat[m].m.b))
332 			printf("Error (unknown command): %s\n", command);
333 		else {
334 			ply = 0;
335 			gen();
336 			print_result();
337 		}
338 	}
339 }
340 void print_result()
341 {
342 	int i;
343 	for (i = 0; i &lt; first_move[1]; ++i)
344 		if (makemove(gen_dat[i].m.b)) {
345 			takeback();
346 			break;
347 		}
348 	if (i == first_move[1]) {
349 		if (in_check(side)) {
350 			if (side == LIGHT)
351 				printf("0-1 {Black mates}\n");
352 			else
353 				printf("1-0 {White mates}\n");
354 		}
355 		else
356 			printf("1/2-1/2 {Stalemate}\n");
357 	}
358 	else if (reps() == 3)
359 		printf("1/2-1/2 {Draw by repetition}\n");
360 	else if (fifty &gt;= 100)
361 		printf("1/2-1/2 {Draw by fifty move rule}\n");
362 }
363 int bench_color[64] = {
364 	6, 1, 1, 6, 6, 1, 1, 6,
365 	1, 6, 6, 6, 6, 1, 1, 1,
366 	6, 1, 6, 1, 1, 6, 1, 6,
367 	6, 6, 6, 1, 6, 6, 0, 6,
368 	6, 6, 1, 0, 6, 6, 6, 6,
369 	6, 6, 0, 6, 6, 6, 0, 6,
370 	0, 0, 0, 6, 6, 0, 0, 0,
371 	0, 6, 0, 6, 0, 6, 0, 6
372 };
373 int bench_piece[64] = {
374 	6, 3, 2, 6, 6, 3, 5, 6,
375 	0, 6, 6, 6, 6, 0, 0, 0,
376 	6, 0, 6, 4, 0, 6, 1, 6,
377 	6, 6, 6, 1, 6, 6, 1, 6,
378 	6, 6, 0, 0, 6, 6, 6, 6,
379 	6, 6, 0, 6, 6, 6, 0, 6,
380 	0, 0, 4, 6, 6, 0, 2, 0,
381 	3, 6, 2, 6, 3, 6, 5, 6
382 };
383 void bench()
384 {
385 	int i;
386 	int t[3];
387 	double nps;
388 	close_book();
389 	for (i = 0; i &lt; 64; ++i) {
390 <a name="0"></a>		color[i] = bench_color[i];
391 		piece[i] = bench_piece[i];
392 	}
393 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	side = LIGHT;
394 	xside = DARK;
395 	castle = 0;
396 	ep = -1;
397 	fifty = 0;
398 	ply = 0;
399 	hply = 0;
400 	set_hash();
401 	print_board();
402 	max_time = 1 &lt;&lt; 25;
403 	max_depth = 5;
404 	for (i = 0; i &lt; 3; ++i) {</b></font>
405 		think(1);
406 		t[i] = get_ms() - start_time;
407 		printf("Time: %d ms\n", t[i]);
408 	}
409 	if (t[1] &lt; t[0])
410 		t[0] = t[1];
411 	if (t[2] &lt; t[0])
412 		t[0] = t[2];
413 	printf("\n");
414 	printf("Nodes: %d\n", nodes);
415 	printf("Best time: %d ms\n", t[0]);
416 	if (!ftime_ok) {
417 		printf("\n");
418 		printf("Your compiler's ftime() function is apparently only accurate\n");
419 		printf("to the second. Please change the get_ms() function in main.c\n");
420 		printf("to make it more accurate.\n");
421 		printf("\n");
422 		return;
423 	}
424 	if (t[0] == 0) {
425 		printf("(invalid)\n");
426 		return;
427 	}
428 	nps = (double)nodes / (double)t[0];
429 	nps *= 1000.0;
430 	printf("Nodes per second: %d (Score: %.3f)\n", (int)nps, (float)nps/243169.0);
431 	init_board();
432 	open_book();
433 	gen();
434 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>Epd2wb.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;iostream&gt;
2 #include &lt;ios&gt;
3 #include &lt;fstream&gt;
4 #include "epd2wb.h"
5 #include &lt;stdarg.h&gt;
6 #include &lt;stdio.h&gt;
7 #include &lt;ctype.h&gt;
8 #include &lt;signal.h&gt;
9 #include &lt;winbase.h&gt;
10 using namespace std;
11 #define	modeFEATURE_TIMEOUT		0
12 #define	modeFEATURE_NOTIMEOUT	1
13 #define	modeWAITING				2
14 #define	modeTESTING				3
15 #define uciDEBUG                0
16 typedef struct tagCHILDPROC {
17 	HANDLE hProcess;
18 	DWORD pid;
19 	HANDLE hTo;
20 	HANDLE hFrom;
21 }	CHILDPROC, * PCHILDPROC;
22 typedef	unsigned long	TM;
23 typedef struct tagSearchInfo {
24 	char		 aszLastPV[512];
25 	int			 cLastDepth;
26 	int			 cSolveDepth;
27 	int          cLastEval;
28 	unsigned int cSolveTime;
29 } SINFO;
30 #define	isolMAX		1800
31 #define	cbINPUT_BUF	4096
32 typedef char Str100[100];
33 typedef	struct	tagIVARS {
34 	HANDLE	heventStdinReady;		HANDLE	heventStdinAck;			HANDLE  heventStdinPing;    	char	aszEngine[256];			char    aszPath[256];       	char    aszLogFile[256];    	char    aszDBFile[256];     	char	aszSuite[256];			char    aszUCIFile[256];    	char	aszFen[256];			char	aszId[256];				char	aszAnswer[256];			char	aszAvoid[256];			char    aszOutput[cbINPUT_BUF]; 	Str100  aszFEN[isolMAX];		Str100  aszName[isolMAX];   	Str100  aszSol[isolMAX];    	Str100  UCIoption[100];     	Str100  UCIvalue[100];      	int     UCIoptionstate[100];	int UCIoptions;             	int	movStart;					int	plyFifty;					int	mode;						CHILDPROC	cp;					FILE *	pfI;					fstream LOGDatei;				fstream DBDatei;				int	cPing;						BOOL	fCorrectAnswer;			int cPosAbs;                	int cWaitAfterStart;        	int cPosCounter;            	int	cSolved;					int	cFailed;					int	cError;						int cIPTime;                	int cPlys;                  	int cScore;                 	int cMultiST;               	int	argsol[isolMAX];			SINFO apsInfo[isolMAX];     	char	aszInBuf[					cbINPUT_BUF];
35 	int	cSkip;						int	cLine;						BOOL	fError;					BOOL	fEngineStarted;			BOOL	fPing;					BOOL	fSetboard;				BOOL	fAnalyze;				BOOL	fColor;					BOOL    fPureProt1;         	BOOL	fUsermove;				BOOL	fDump;					BOOL	fUseSt;					BOOL    fUseUCI;            	BOOL    fUCI1;					BOOL    fInternalTime;      	BOOL	fFindInfo;				BOOL    fIgnoreDone;        	BOOL    fLogOn;             	BOOL    fLogOpen;				BOOL    fDBon;					BOOL    fWaitAfterStart;    	BOOL    fStopPly;           	BOOL    fStopScore;         	BOOL	fQuit;					BOOL    fStopAnalysis;      	TM	tmEnd;						TM	tmPerMove;					TM	tmFoundIn;					TM	tmWaitInit;					TM  tmWaitPos;					TM  tmStartPos;             	TM	tmStart;					PLANG	plang;					PLANG	plangEnglish;		}	IVARS;
36 IVARS	s_ivars;	
37 unsigned TmNow(void)
38 {
39 	return GetTickCount();
40 }
41 #define	cbLINE	80	
42 static char const s_aszModule[] = __FILE__;
43 void VWriteLogAndOutput()
44 {
45 	if (s_ivars.fLogOpen) {
46 		s_ivars.LOGDatei.write(s_ivars.aszOutput,strlen(s_ivars.aszOutput));
47 		s_ivars.LOGDatei.seekp(0,ios::end);
48 	}
49 	printf("%s",s_ivars.aszOutput);
50 }
51 int	CszVectorizeEpd(char * sz, char * rgsz[], int * pibSecond);
52 void VWriteEmpty()
53 {	
54 	strcpy(s_ivars.aszOutput,"\n");
55 	if (s_ivars.fLogOpen) {
56 		s_ivars.LOGDatei.write(s_ivars.aszOutput,strlen(s_ivars.aszOutput));
57 		s_ivars.LOGDatei.seekp(0,ios::end);
58 	}
59 	printf("%s",s_ivars.aszOutput);
60 }
61 #include &lt;ctype.h&gt;
62 void VCompact(char * szIn, char * szOut)
63 {
64 	for (; *szIn; szIn++)
65 		switch (*szIn) {
66 		case 'x':
67 		case '-':
68 		case '+':
69 		case '=':
70 		case ':':
71 		case '#':
72 		case '?':
73 		case '!':
74 			break;
75 		default:
76 			*szOut++ = *szIn;
77 			break;
78 		}
79 	*szOut = '\0';
80 }
81 #define	rnkNIL	-1				#define	filNIL	-1				#define	pcNIL	-1				
82 typedef	struct	tagSQ {
83 	int	rnk;
84 	int	fil;
85 }	SQ, * PSQ;
86 typedef	struct	tagMOV {
87 	SQ	sqFrom;						SQ	sqTo;						int	pcFrom;						int	pcTo;					}	MOV, * PMOV;
88 int PcFromCh(int ch, PLANG plang, BOOL fCaseSensitive)
89 {
90 	int	pc;
91 	for (pc = pcPAWN; pc &lt;= pcKING; pc++) {
92 		if (ch == plang-&gt;argbPc[pc])
93 			return pc;
94 		if ((!fCaseSensitive) &amp;&amp; (tolower(ch) == tolower(plang-&gt;argbPc[pc])))
95 			return pc;
96 	}
97 	return pcNIL;
98 }
99 int fGetAbsPos(char * sz)
100 {
101    FILE *epdfile;
102    int npos = 0, nslash = 0, ch;
103    epdfile = fopen(sz, "r");
104    do
105    {  ch = getc(epdfile);
106       if (ch == '/')
107          nslash++;
108       else
109       if ((ch == '\n' || ch == EOF) &amp;&amp; nslash &gt;= 7)
110       {  npos++;
111          nslash = 0;
112       }
113    }while(ch != EOF);
114    fclose(epdfile);
115    return npos;
116 }
117 void ReadUCIOptions(void)
118 {
119 	FILE *ucifile;
120 	char ch;
121 	char line[256];
122 	char ucioption[256];
123 	char * argsz[256];
124 	int pibsecond,i,j,k;
125 	long slen=0;
126 	bool found;
127 	ucifile=fopen(s_ivars.aszUCIFile,"r");
128 	do {
129 		ch=getc(ucifile);
130 		if ((ch == '\n') || (ch == EOF)) {
131 			line[slen]=0;
132 			slen=CszVectorizeEpd(line,argsz,&amp;pibsecond);
133 			if (!strcmp("option",argsz[0])) {
134 				strcpy(ucioption,argsz[1]);
135 				k=2;
136 				while (strcmp(argsz[k],"value")) {
137 					strcat(ucioption," ");
138 					strcat(ucioption,argsz[k]);
139 					k++;
140 				}
141 				i=0;
142 				found=false;
143 				while ((i&lt;s_ivars.UCIoptions) &amp;&amp; (!found)) {
144 					if (!strcmp(s_ivars.UCIoption[i],ucioption)) {
145 						found=true;
146 						sprintf(s_ivars.UCIvalue[i],"\0");
147 						for (j=k+1;j&lt;slen;j++) {
148 							if (j&gt;(k+1)) {
149 								strcat(s_ivars.UCIvalue[i]," ");
150 							}
151 							strcat(s_ivars.UCIvalue[i],argsz[j]);
152 						}
153 						s_ivars.UCIoptionstate[i]|=1;
154 					} else {
155 						i++;
156 					}
157 				}
158 				if (!found) {
159 					i=s_ivars.UCIoptions;
160 					strcpy(s_ivars.UCIoption[i],ucioption);
161 					strcpy(s_ivars.UCIvalue[i],"\0");
162 					for (j=k+1;j&lt;slen;j++) {
163 						if (j&gt;(k+1)) {
164 							strcat(s_ivars.UCIvalue[i]," ");
165 						}
166 						strcat(s_ivars.UCIvalue[i],argsz[j]);
167 					}
168 					s_ivars.UCIoptionstate[i]=1;
169 					s_ivars.UCIoptions++;
170 				}
171 			}
172 			slen=0;
173 		} else {
174 			line[slen]=ch;
175 			slen++;
176 		}
177 	} while(ch != EOF);
178 	fclose(ucifile);
179 }
180 BOOL FGetRnk(char * sz, int * prnk)
181 {
182 	if ((sz[0] &lt; '1') || (sz[0] &gt; '8'))
183 		return fFALSE;
184 	*prnk = sz[0] - '1';
185 	return fTRUE;
186 }
187 BOOL FGetFil(char * sz, int * pfil)
188 {
189 	if ((sz[0] &lt; 'a') || (sz[0] &gt; 'h'))
190 		return fFALSE;
191 	*pfil = sz[0] - 'a';
192 	return fTRUE;
193 }
194 BOOL FGetCoord(char * sz, PSQ psq)
195 {
196 	SQ	sq;			
197 	if (!FGetFil(sz, &amp;sq.fil))
198 		return fFALSE;
199 	if (!FGetRnk(sz + 1, &amp;sq.rnk))
200 		return fFALSE;
201 	*psq = sq;
202 	return fTRUE;
203 }
204 int IsqFromSq(PSQ psq)
205 {
206 	return psq-&gt;rnk * 8 + psq-&gt;fil;
207 }
208 BOOL FDecipher(PBD pbd, PLANG plang, char * szMov, PMOV pmov)
209 {
210 	if ((!strcmp(szMov, "OO")) || (!strcmp(szMov, "oo")) || (!strcmp(szMov, "00")))
211 		szMov = (pbd-&gt;coMove == coWHITE) ? "e1g1" : "e8g8";
212 	else if ((!strcmp(szMov, "OOO")) || (!strcmp(szMov, "ooo")) || (!strcmp(szMov, "000")))
213 		szMov = (pbd-&gt;coMove == coWHITE) ? "e1c1" : "e8c8";
214 	pmov-&gt;sqFrom.rnk = pmov-&gt;sqTo.rnk = rnkNIL;
215 	pmov-&gt;sqFrom.fil = pmov-&gt;sqTo.fil = filNIL;
216 	pmov-&gt;pcTo = pcNIL;
217 	if ((pbd-&gt;coMove==coBLACK) &amp;&amp; (strlen(szMov)&gt;=5) &amp;&amp; (isdigit(szMov[2])) &amp;&amp; (isdigit(szMov[4])))
218 	{
219 		if ((pmov-&gt;pcFrom = PcFromCh(*szMov, plang, fFALSE)) != pcNIL)				szMov++;
220 	}
221 	else
222 	{
223 		if ((pmov-&gt;pcFrom = PcFromCh(*szMov, plang, fTRUE)) != pcNIL)
224 			szMov++;
225 	}
226 	if (FGetCoord(szMov, &amp;pmov-&gt;sqFrom)) {
227 		szMov += 2;
228 		if (FGetCoord(szMov, &amp;pmov-&gt;sqTo)) {
229 			int	pcFrom;
230 			szMov += 2;
231 			pcFrom = pbd-&gt;argpcco[IsqFromSq(&amp;pmov-&gt;sqFrom)].pc;
232 			if (pcFrom == pcNIL)					return fFALSE;
233 			if ((pmov-&gt;pcFrom != pcNIL) &amp;&amp; (pcFrom != pmov-&gt;pcFrom))
234 				return fFALSE;
235 			pmov-&gt;pcFrom = pcFrom;
236 lblPromote:	if ((pmov-&gt;pcTo = PcFromCh(*szMov, plang, fFALSE)) != pcNIL) {
237 				szMov++;
238 				if ((pmov-&gt;pcFrom != pcNIL) &amp;&amp; (pmov-&gt;pcFrom != pcPAWN))
239 					return fFALSE;
240 				pmov-&gt;pcFrom = pcPAWN;
241 			}
242 			if (*szMov == '\0')
243 				return fTRUE;
244 		} else {
245 			pmov-&gt;sqTo = pmov-&gt;sqFrom;
246 			pmov-&gt;sqFrom.rnk = rnkNIL;
247 			pmov-&gt;sqFrom.fil = filNIL;
248 			if (pmov-&gt;pcFrom == pcNIL)
249 				pmov-&gt;pcFrom = pcPAWN;
250 			goto lblPromote;
251 		}
252 	} else if (FGetFil(szMov, &amp;pmov-&gt;sqFrom.fil)) {
253 		if (pmov-&gt;pcFrom == pcNIL)
254 			pmov-&gt;pcFrom = pcPAWN;
255 lblTo:	szMov++;
256 		if (FGetCoord(szMov, &amp;pmov-&gt;sqTo)) {
257 			szMov += 2;
258 			goto lblPromote;
259 		}
260 	} else if (FGetRnk(szMov, &amp;pmov-&gt;sqFrom.rnk)) {
261 		if ((pmov-&gt;pcFrom == pcNIL) || (pmov-&gt;pcFrom == pcPAWN))
262 			return fFALSE;
263 		goto lblTo;
264 	}
265 	return fFALSE;
266 }
267 BOOL FCompare(PMOV pmovTry, PMOV pmovAnswer)
268 {
269 	if (pmovTry-&gt;sqTo.rnk != pmovAnswer-&gt;sqTo.rnk)
270 		return fFALSE;
271 	if (pmovTry-&gt;sqTo.fil != pmovAnswer-&gt;sqTo.fil)
272 		return fFALSE;
273 	if (pmovTry-&gt;pcTo != pmovAnswer-&gt;pcTo)
274 		return fFALSE;
275 	if ((pmovTry-&gt;sqFrom.rnk != rnkNIL) &amp;&amp;
276 		(pmovAnswer-&gt;sqFrom.rnk != rnkNIL) &amp;&amp;
277 		(pmovTry-&gt;sqFrom.rnk != pmovAnswer-&gt;sqFrom.rnk))
278 		return fFALSE;
279 	if ((pmovTry-&gt;sqFrom.fil != filNIL) &amp;&amp;
280 		(pmovAnswer-&gt;sqFrom.fil != filNIL) &amp;&amp;
281 		(pmovTry-&gt;sqFrom.fil != pmovAnswer-&gt;sqFrom.fil))
282 		return fFALSE;
283 	if ((pmovTry-&gt;pcFrom != pcNIL) &amp;&amp; (pmovAnswer-&gt;pcFrom != pcNIL) &amp;&amp;
284 		(pmovTry-&gt;pcFrom != pmovAnswer-&gt;pcFrom))
285 		return fFALSE;
286 	return fTRUE;
287 }
288 BOOL FCheckAnswer(char * szFen, char * szTry, char * szAnswer,
289 	PLANG plangTry, PLANG plangAnswer)
290 {
291 	char	aszAnswer[32];
292 	char	aszTry[32];
293 	MOV	movTry;
294 	MOV	movAnswer;
295 	BD	bd;
296 	VCompact(szTry, aszTry);
297 	VCompact(szAnswer, aszAnswer);
298 	if ((plangTry == plangAnswer) &amp;&amp; (!strcmp(szAnswer, szTry)))
299 		return fTRUE;		if (!FFenToBd(szFen, &amp;bd))					return fFALSE;						if (!FDecipher(&amp;bd, plangTry, aszTry, &amp;movTry))
300 		return fFALSE;
301 	if (!FDecipher(&amp;bd, plangAnswer, aszAnswer, &amp;movAnswer))
302 		return fFALSE;
303 	if (FCompare(&amp;movTry, &amp;movAnswer))
304 		return fTRUE;
305 	return fFALSE;
306 }
307 void VAssertFailed(const char * szMod, int iLine)
308 {
309 	sprintf(s_ivars.aszOutput,"Assert Failed: %s+%d\n", szMod, iLine);
310 	VWriteLogAndOutput();
311 	exit(1);
312 }
313 #define	Assert(cond)		if (!(cond)) VAssertFailed(s_aszModule, __LINE__)
314 void VDisplayLastError(char * sz)
315 {
316 	int	len;
317 	char	aszBuf[512];
318 	DWORD	dw = GetLastError();
319 	if (!s_ivars.fQuit) {
320 		len = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,
321 			NULL, dw, LANG_NEUTRAL, aszBuf, sizeof(aszBuf), NULL);
322 		if (len &gt; 0) {
323 			fprintf(stderr, "%s: %s", sz, aszBuf);
324 			exit(1);
325 		}
326 		fprintf(stderr, "%s: error = %ld\n", sz, dw);
327 	}
328 	exit(1);
329 }
330 void DestroyChildProcess(PCHILDPROC pcp)
331 {
332 	CloseHandle(pcp-&gt;hTo);
333     if (pcp-&gt;hFrom)
334 		CloseHandle(pcp-&gt;hFrom);
335     CloseHandle(pcp-&gt;hProcess);
336 }
337 BOOL FStartProcess(PCHILDPROC pcp, char * szEngine, char * szPath)
338 {
339 	HANDLE	hChildStdinRd;
340 	HANDLE	hChildStdinWr;
341 	HANDLE	hChildStdoutRd;
342 	HANDLE	hChildStdoutWr;
343 	HANDLE	hChildStdinWrDup;
344 	HANDLE	hChildStdoutRdDup;
345 	PROCESS_INFORMATION	piProcInfo;
346 	STARTUPINFO	siStartInfo;
347 	SECURITY_ATTRIBUTES saAttr;
348 	char szEngineFull[256];
349 	saAttr.nLength = sizeof(SECURITY_ATTRIBUTES);
350 	saAttr.bInheritHandle = TRUE;
351 	saAttr.lpSecurityDescriptor = NULL;
352 	if (!CreatePipe(&amp;hChildStdoutRd, &amp;hChildStdoutWr, &amp;saAttr, 0))
353 		return fFALSE;
354 	if (!DuplicateHandle(GetCurrentProcess(), hChildStdoutRd,
355 		GetCurrentProcess(), &amp;hChildStdoutRdDup, 0,
356 		FALSE, DUPLICATE_SAME_ACCESS))
357 		return fFALSE;
358 	CloseHandle(hChildStdoutRd);
359 	if (!CreatePipe(&amp;hChildStdinRd, &amp;hChildStdinWr, &amp;saAttr, 0))
360 		return fFALSE;
361 	if (!DuplicateHandle(GetCurrentProcess(), hChildStdinWr,
362 		GetCurrentProcess(), &amp;hChildStdinWrDup, 0, FALSE,
363 		DUPLICATE_SAME_ACCESS))
364 		return fFALSE;
365 	CloseHandle(hChildStdinWr);
366 	siStartInfo.cb = sizeof(STARTUPINFO);
367 	siStartInfo.lpReserved = NULL;
368 	siStartInfo.lpDesktop = NULL;
369 	siStartInfo.lpTitle = NULL;
370 	siStartInfo.dwFlags = STARTF_USESTDHANDLES;
371 	siStartInfo.cbReserved2 = 0;
372 	siStartInfo.lpReserved2 = NULL;
373 	siStartInfo.hStdInput = hChildStdinRd;
374 	siStartInfo.hStdOutput = hChildStdoutWr;
375 	siStartInfo.hStdError = hChildStdoutWr;
376 	strcpy(szEngineFull,szPath);
377 	strcat(szEngineFull,szEngine);
378 	if (strlen(szPath)==0) szPath=NULL;
379 	if (!CreateProcess(NULL, szEngineFull, NULL, NULL, TRUE,
380 		DETACHED_PROCESS | CREATE_NEW_PROCESS_GROUP,
381 		NULL, szPath, &amp;siStartInfo, &amp;piProcInfo))
382 		return fFALSE;
383 	CloseHandle(hChildStdinRd);
384 	CloseHandle(hChildStdoutWr);
385 	pcp-&gt;hProcess = piProcInfo.hProcess;
386 	pcp-&gt;pid = piProcInfo.dwProcessId;
387 	pcp-&gt;hFrom = hChildStdoutRdDup;
388 	pcp-&gt;hTo = hChildStdinWrDup;
389 	return fTRUE;
390 }
391 #if	0
392 void VDumpRaw(char * rgb, int cb)
393 {
394 	int	ib;
395 	char aszAddText[20];
396 	sprintf(s_ivars.aszOutput,"RAW: ");
397 	for (ib = 0; ib &lt; cb; ib++) {
398 		if ((rgb[ib] &lt; ' ') || (rgb[ib] &gt; '~')) {
399 			sprintf(aszAddText,"&lt;%02Xh&gt;", rgb[ib]);
400 			strcat(s_ivars.aszOutput,aszAddText);
401 		}
402 		else
403 			strcat(s_ivars.aszOutput,rgb[ib]);
404 	}
405 	strcat(s_ivars.aszOutput,'\n');
406 	VWriteLogAndOutput();
407 }
408 #endif
409 DWORD WINAPI DwInput(void * pv)
410 {
411 	char	argb[cbINPUT_BUF];
412 	int	ib = 0;
413 	int	cb = 0;
414 	int	ibOut = 0;
415 	for (;;) {
416 		WaitForSingleObject(s_ivars.heventStdinAck, INFINITE);
417 		for (;;) {
418 			Assert(ib &lt;= cb);
419 			if (ib == cb) {						DWORD	dw;
420 				if (!ReadFile(s_ivars.cp.hFrom,
421 					argb, sizeof(argb), &amp;dw, NULL))
422 					VDisplayLastError("Can't read from engine");
423 				ib = 0;
424 				cb = dw;
425 				Assert(cb &lt;= sizeof(argb));
426 			} else if ((argb[ib] == '\r') || (argb[ib] == '\n')) {
427 				if ((cb&lt;(ib+7)) || (strncmp(&amp;argb[ib+2],"    ",4)))					{
428 					if ((++ib &lt; cb) &amp;&amp; (argb[ib] == '\n'))
429 						ib++;
430 					s_ivars.aszInBuf[ibOut] = '\0';
431 					ibOut = 0;
432 					if (s_ivars.fDump) {
433 						sprintf(s_ivars.aszOutput,"LineCut&gt; %s\n", s_ivars.aszInBuf);
434 						VWriteLogAndOutput();
435 					}
436 					SetEvent(s_ivars.heventStdinReady);
437 					break;
438 				}
439 				else														{
440 					ib+=6;
441 					s_ivars.aszInBuf[ibOut++]=argb[ib++];
442 				}
443 			} else
444 				s_ivars.aszInBuf[ibOut++] = argb[ib++];
445 		}
446 	}
447 	return 0;
448 }
449 void VSendToEngine(const char * szFmt, ...)
450 {
451 	char	aszBuf[2048];
452 	va_list	lpArgPtr;
453 	int	cb;
454 	DWORD	dw;
455 	va_start(lpArgPtr, szFmt);
456 	vsprintf(aszBuf, szFmt, lpArgPtr);
457 	cb = strlen(aszBuf);
458 	aszBuf[cb++] = '\n';
459 	aszBuf[cb] = '\0';
460 	if (s_ivars.fDump) {
461 		sprintf(s_ivars.aszOutput,"&lt;%s", aszBuf);
462 		VWriteLogAndOutput();
463 	}
464 	if (!WriteFile(s_ivars.cp.hTo, aszBuf, cb, &amp;dw, NULL))
465 		VDisplayLastError("Can't write to engine");
466 }
467 int	CszVectorizeEpd(char * sz, char * rgsz[], int * pibSecond)
468 {
469 	int	i;
470 	int	csz;
471 	for (csz = 0, i = 0; sz[i]; i++)
472 		if (sz[i] != ' ') {
473 			BOOL	fInQuote;
474 			if (sz[i] == '"') {
475 				fInQuote = fTRUE;
476 				i++;
477 			} else
478 				fInQuote = fFALSE;
479 			if (csz == 1)
480 				*pibSecond = i;
481 			rgsz[csz++] = sz + i;
482 			for (;; i++) {
483 				if ((sz[i] == ' ') &amp;&amp; (!fInQuote))
484 					break;
485 				if ((sz[i] == '"') &amp;&amp; (fInQuote))
486 					break;
487 				if (sz[i] == '\0')
488 					break;
489 			}
490 			if (sz[i] == '\0')
491 				break;
492 			sz[i] = '\0';
493 		}
494 	if (csz &lt;= 1)
495 		*pibSecond = i;
496 	return csz;
497 }
498 int	CszVectorizeCmd(char * sz, char * rgsz[], int * pibSecond)
499 {
500 	int	i;
501 	int	csz;
502 	for (csz = 0, i = 0; sz[i]; i++)
503 		if ((sz[i] != ' ') &amp;&amp; (sz[i] != '\t')) {
504 			BOOL	fInQuote;
505 			if (csz == 1)
506 				*pibSecond = i;
507 			rgsz[csz++] = sz + i;
508 			fInQuote = fFALSE;
509 			for (;; i++) {
510 				if (((sz[i] == ' ') || (sz[i] == '\t')) &amp;&amp; (!fInQuote))
511 					break;
512 				if (sz[i] == '"')
513 					fInQuote = !fInQuote;
514 				if (sz[i] == '\0')
515 					break;
516 			}
517 			if (sz[i] == '\0')
518 				break;
519 			sz[i] = '\0';
520 		}
521 	return csz;
522 }
523 void VStrip(char * sz)
524 {
525 	int	i;
526 	for (i = 0; sz[i]; i++)
527 		if (sz[i] == '\n') {
528 			sz[i] = '\0';
529 			break;
530 		}
531 }
532 void VPrepEngine(void)
533 {
534 	VSendToEngine("new");
535 	VSendToEngine("level 0 5 0");
536 	VSendToEngine("post");
537 	VSendToEngine("hard");
538 	VSendToEngine("easy");
539 }
540 typedef	struct	tagCMD {
541 	char * sz;
542 	BOOL (* pfn)(char * sz, char * rgsz[], int csz);
543 }	CMD, * PCMD;
544 BOOL FCmdBm(char * sz, char * rgsz[], int csz)
545 {
546 	int	ib;
547 	int	i;
548 	ib = 0;
549 	for (i = 1; i &lt; csz; i++)
550 		ib += sprintf(s_ivars.aszAnswer + ib, "%s", rgsz[i]) + 1;
551 	s_ivars.aszAnswer[ib] = '\0';
552 	return fTRUE;
553 }
554 BOOL FCmdAm(char * sz, char * rgsz[], int csz)
555 {
556 	int	ib;
557 	int	i;
558 	ib = 0;
559 	for (i = 1; i &lt; csz; i++)
560 		ib += sprintf(s_ivars.aszAvoid + ib, "%s", rgsz[i]) + 1;
561 	s_ivars.aszAvoid[ib] = '\0';
562 	return fTRUE;
563 }
564 BOOL FCmdId(char * sz, char * rgsz[], int csz)
565 {
566 	if (csz &lt; 2)
567 		return fTRUE;
568 	strcpy(s_ivars.aszId, rgsz[1]);
569 	return fTRUE;
570 }
571 BOOL FCmdFmvn(char * sz, char * rgsz[], int csz)
572 {
573 	if (csz &lt; 2)
574 		return fTRUE;
575 	s_ivars.movStart = atoi(rgsz[1]);
576 	if (s_ivars.movStart &lt; 1)
577 		s_ivars.movStart = 1;
578 	return fTRUE;
579 }
580 BOOL FCmdHmvc(char * sz, char * rgsz[], int csz)
581 {
582 	if (csz &lt; 2)
583 		return fTRUE;
584 	s_ivars.plyFifty = atoi(rgsz[1]);
585 	if (s_ivars.plyFifty &lt; 0)
586 		s_ivars.plyFifty = 0;
587 	return fTRUE;
588 }
589 CMD const c_argcmdEpd[] = {
590 	"bm",			FCmdBm,			"am",			FCmdAm,			"id",			FCmdId,			"fmvn",			FCmdFmvn,		"hmvc",			FCmdHmvc,		NULL,
591 };
592 void VKillTime(TM tmToWait)
593 {
594 	TM	tmEnd = TmNow() + tmToWait;
595 	for (;;) {
596 		if (WaitForSingleObject(s_ivars.heventStdinReady,
597 			tmEnd - TmNow()) == WAIT_TIMEOUT)
598 			break;
599 		SetEvent(s_ivars.heventStdinAck);
600 	}
601 }
602 void VSendMoveToEngine(char * szMov)
603 {
604 	if (s_ivars.fUsermove)
605 		VSendToEngine("usermove %s", szMov);
606 	else
607 		VSendToEngine(szMov);
608 }
609 BOOL FFenToBd(char * szFen, PBD pbd)
610 {
611 	int	isq;
612 	int	rnk;
613 	int	fil;
614 	int	co;
615 	for (isq = 0; isq &lt; csqMAX; isq++)
616 		pbd-&gt;argpcco[isq].co = coMAX;
617 	rnk = 7;
618 	fil = 0;
619 	for (;; szFen++)
620 		if (*szFen == ' ')
621 			break;
622 		else if (*szFen == '/') {
623 			rnk--;
624 			fil = 0;
625 		} else if ((*szFen &gt;= '1') &amp;&amp; (*szFen &lt;= '8'))
626 			fil += *szFen - '0';
627 		else if ((fil &gt; 7) || (rnk &lt; 0))
628 			return fFALSE;
629 		else {
630 			int	pc;
631 			for (pc = pcPAWN; pc &lt;= pcKING; pc++)
632 				if (s_ivars.plangEnglish-&gt;argbPc[pc] == *szFen) {
633 					co = coWHITE;
634 					break;
635 				}
636 			if (pc &gt; pcKING)
637 				for (pc = pcPAWN; pc &lt;= pcKING; pc++)
638 					if (s_ivars.plangEnglish-&gt;argbPc[pc] ==
639 						toupper(*szFen)) {
640 						co = coBLACK;
641 						break;
642 					}
643 			if (pc &gt; pcKING)
644 				return fFALSE;
645 			pbd-&gt;argpcco[rnk * 8 + fil].pc = pc;
646 			pbd-&gt;argpcco[rnk * 8 + fil].co = co;
647 			fil++;
648 		}
649 	switch (*++szFen) {
650 	case 'w':
651 		pbd-&gt;coMove = coWHITE;
652 		break;
653 	case 'b':
654 		pbd-&gt;coMove = coBLACK;
655 		break;
656 	default:
657 		return fFALSE;
658 	}
659 	return fTRUE;
660 }
661 BOOL FSendEdit(char * szFen)
662 {
663 	BD	bd;
664 	int	co;
665 	if (!FFenToBd(szFen, &amp;bd))
666 		return fFALSE;
667 	if (bd.coMove == coBLACK)
668 		VSendMoveToEngine("a2a3");
669 	VSendToEngine("edit");
670 	VSendToEngine("#");
671 	for (co = coWHITE; co &lt;= coBLACK; co++) {
672 		int	isq;
673 		for (isq = 0; isq &lt; csqMAX; isq++)
674 			if (bd.argpcco[isq].co == co) {
675 				char	asz[8];
676 				asz[0] = s_ivars.plangEnglish-&gt;argbPc[bd.argpcco[isq].pc];
677 				asz[1] = (isq % 8) + 'a';
678 				asz[2] = (isq / 8) + '1';
679 				asz[3] = '\0';
680 				VSendToEngine(asz);
681 			}
682 		VSendToEngine((co == coWHITE) ? "c" : ".");
683 	}
684 	return fTRUE;
685 }
686 BOOL FNextTest(void)
687 {
688 	char	aszBuf[256];
689 	char    aszAddText[15];
690 	int	i;
691 	int	cSpaces;
692 	int	coMove;
693 	for (;;) {
694 		if (fgets(aszBuf, sizeof(aszBuf), s_ivars.pfI) != aszBuf)
695 			return fFALSE;
696 		s_ivars.cLine++;
697 		VStrip(aszBuf);
698 		if (aszBuf[0] != '\0')
699 			break;
700 	}
701 	for (i = cSpaces = 0; aszBuf[i]; i++) {
702 		if (aszBuf[i] == ' ') {
703 			if (++cSpaces == 4)
704 				break;
705 			if (cSpaces == 1)
706 				if (aszBuf[i + 1] == 'w')
707 					coMove = coWHITE;
708 				else
709 					coMove = coBLACK;
710 		}
711 		s_ivars.aszFen[i] = aszBuf[i];
712 	}
713 	if (aszBuf[i] == '\0') {			sprintf(s_ivars.aszOutput,"Obviously bogus FEN, line %d\n", s_ivars.cLine);
714 		VWriteLogAndOutput();
715 		return fFALSE;
716 	}
717 	s_ivars.aszFen[i] = '\0';
718 	s_ivars.aszId[0] = '\0';
719 	s_ivars.aszAnswer[0] = '\0';
720 	s_ivars.aszAvoid[0] = '\0';
721 	s_ivars.movStart = 1;
722 	s_ivars.plyFifty = 0;
723 	s_ivars.apsInfo[s_ivars.cPosCounter].aszLastPV[0]='\0';
724 	s_ivars.apsInfo[s_ivars.cPosCounter].cLastDepth=0;
725 	s_ivars.apsInfo[s_ivars.cPosCounter].cSolveDepth=0;
726 	s_ivars.apsInfo[s_ivars.cPosCounter].cSolveTime=-1;
727 	for (;;) {
728 		char	aszCmd[256];
729 		int	j;
730 		char *	argsz[256];
731 		int	ibSecond;
732 		int	csz;
733 		while (aszBuf[i] == ' ')				i++;
734 		if (aszBuf[i] == '\0')					break;
735 		for (j = 0; aszBuf[i]; i++) {
736 			if (aszBuf[i] == ';') {
737 				i++;
738 				break;
739 			}
740 			aszCmd[j++] = aszBuf[i];
741 		}
742 		aszCmd[j] = '\0';
743 		csz = CszVectorizeEpd(aszCmd, argsz, &amp;ibSecond);
744 		if (csz)
745 			for (j = 0; c_argcmdEpd[j].sz != NULL; j++)
746 				if (!strcmp(c_argcmdEpd[j].sz, argsz[0])) {
747 					(*c_argcmdEpd[j].pfn)(aszBuf + ibSecond, argsz, csz);
748 					break;
749 				}
750 	}
751 	sprintf(s_ivars.aszFen + strlen(s_ivars.aszFen), " %d %d",
752 		s_ivars.plyFifty, s_ivars.movStart);
753 	s_ivars.fCorrectAnswer = fFALSE;
754 	s_ivars.tmFoundIn = -1;
755 	s_ivars.fError = fFALSE;
756 	strcpy(s_ivars.aszFEN[s_ivars.cPosCounter],s_ivars.aszFen);
757 	s_ivars.aszName[s_ivars.cPosCounter][0]=0;
758 	sprintf(s_ivars.aszOutput,"Nr:%5d (of %i)\n",s_ivars.cPosCounter+1,s_ivars.cPosAbs);
759 	VWriteLogAndOutput();
760 	strncpy(s_ivars.aszName[s_ivars.cPosCounter],s_ivars.aszId,99);
761 	strcat(s_ivars.aszName[s_ivars.cPosCounter],"\0");
762 	if (s_ivars.aszId[0] != '\0') {
763 		sprintf(s_ivars.aszOutput,"Id:  %s\n", s_ivars.aszId);
764 		VWriteLogAndOutput();
765 	}
766 	sprintf(s_ivars.aszOutput,"Fen: %s\n", s_ivars.aszFen);
767 	VWriteLogAndOutput();
768 	s_ivars.aszSol[s_ivars.cPosCounter][0]=0;
769 	if (s_ivars.aszAnswer[0] != '\0') {
770 		sprintf(s_ivars.aszOutput,"Bm: ");
771 		for (i = 0; s_ivars.aszAnswer[i] != '\0';) {
772 			sprintf(aszAddText," %s", s_ivars.aszAnswer + i);
773 			strcat(s_ivars.aszOutput,aszAddText);
774 			i += strlen(s_ivars.aszAnswer + i) + 1;
775 		}
776 		strcpy(s_ivars.aszSol[s_ivars.cPosCounter],s_ivars.aszOutput);
777 		strcat(s_ivars.aszOutput,"\n");
778 		VWriteLogAndOutput();
779 	}
780 	if (s_ivars.aszAvoid[0] != '\0') {
781 		sprintf(s_ivars.aszOutput,"Am: ");
782 		for (i = 0; s_ivars.aszAvoid[i] != '\0';) {
783 			sprintf(aszAddText," %s", s_ivars.aszAvoid + i);
784 			strcat(s_ivars.aszOutput,aszAddText);
785 			i += strlen(s_ivars.aszAvoid + i) + 1;
786 		}
787 		strcpy(s_ivars.aszSol[s_ivars.cPosCounter],s_ivars.aszOutput);
788 		strcat(s_ivars.aszOutput,"\n");
789 		VWriteLogAndOutput();
790 	}
791 	VWriteEmpty();
792 	s_ivars.fStopAnalysis=fFALSE; 	if ((s_ivars.fUseUCI) &amp;&amp; (!s_ivars.fUCI1)) {
793 		VSendToEngine("ucinewgame");
794 	} else {
795 		VSendToEngine("new");
796 	}
797 	if (s_ivars.fUseUCI) {
798 		VSendToEngine("isready");
799 		s_ivars.mode=modeWAITING;
800 	} else {
801 		if (s_ivars.fPing) {
802 			VSendToEngine("ping %d", ++s_ivars.cPing);
803 			s_ivars.mode = modeWAITING;
804 		} else {
805 			VKillTime(s_ivars.tmWaitPos/2);
806 			s_ivars.mode = modeTESTING;
807 		}
808 	}
809 	if (!s_ivars.fUseUCI) {
810 		if (!s_ivars.fAnalyze)
811 			VSendToEngine("level 0 10000 0");
812 		else
813 			VSendToEngine("level 0 5 0");
814 		VSendToEngine("post");
815 		VSendToEngine("hard");
816 		VSendToEngine("easy");
817 		VSendToEngine("force");
818 	}
819 	if (s_ivars.fUseUCI) {
820 		VSendToEngine("position fen %s", s_ivars.aszFen);
821 	}
822 	else {
823 		if (s_ivars.fSetboard) {
824 			VSendToEngine("setboard %s", s_ivars.aszFen);
825 			if ((s_ivars.fColor) &amp;&amp; (!s_ivars.fAnalyze))
826 				VSendToEngine((coMove == coWHITE) ? "black" : "white");
827 		} else if (!FSendEdit(s_ivars.aszFen)) {			s_ivars.fError = fTRUE;							return fTRUE;								}												else {												if ((s_ivars.fColor) &amp;&amp; (!s_ivars.fAnalyze)) 
828 				VSendToEngine((coMove == coWHITE) ? "black" : "white");
829 		}											}												if (s_ivars.fUseUCI) {
830 		VSendToEngine("isready");
831 		s_ivars.mode=modeWAITING;
832 	} else {
833 		if (s_ivars.fPing) {
834 			VSendToEngine("ping %d", ++s_ivars.cPing);
835 			s_ivars.mode = modeWAITING;
836 		} else {
837 			VKillTime(s_ivars.tmWaitPos/2);
838 			s_ivars.mode = modeTESTING;
839 		}
840 	}
841 	s_ivars.tmEnd = TmNow() + s_ivars.tmPerMove;
842 	s_ivars.tmStartPos = TmNow();
843 	if (s_ivars.fUseUCI) {
844 		VSendToEngine("go infinite");
845 	} else {
846 		if (s_ivars.fAnalyze)
847 			VSendToEngine("analyze");
848 		else {
849 			if (s_ivars.fUseSt) {
850 				VSendToEngine("st %d", s_ivars.tmPerMove / 1000);
851 				VSendToEngine("time %d", s_ivars.tmPerMove / 10 * s_ivars.cMultiST);
852 			} else {
853 				VSendToEngine("time 60000000");						VSendToEngine("otim 60000000");      			}
854 			if (s_ivars.fColor)
855 				VSendToEngine((coMove == coWHITE) ? "white" : "black");
856 			VSendToEngine("go");
857 		}
858 	}
859 	s_ivars.tmStart = TmNow();
860 	return fTRUE;
861 }
862 char const * c_argszNoYes[] = { "No", "Yes" };
863 BOOL FFeatureTimeout(void)
864 {
865 	int	i;
866 	sprintf(s_ivars.aszOutput,"\n");
867 	VWriteLogAndOutput();
868 	sprintf(s_ivars.aszOutput,"Engine:         %s\n", s_ivars.aszEngine);
869 	VWriteLogAndOutput();
870 	sprintf(s_ivars.aszOutput,"Suite:          %s\n", s_ivars.aszSuite);
871 	VWriteLogAndOutput();
872 	sprintf(s_ivars.aszOutput,"Positions:      %i\n", s_ivars.cPosAbs);
873 	VWriteLogAndOutput();
874 	sprintf(s_ivars.aszOutput,"Time per move:  %d second%s\n", s_ivars.tmPerMove / 1000,
875 		(s_ivars.tmPerMove / 1000 == 1) ? "" : "s");
876 	VWriteLogAndOutput();
877 	sprintf(s_ivars.aszOutput,"Language:       %s (%c%c%c%c%c%c)\n", s_ivars.plang-&gt;szLang,
878 		s_ivars.plang-&gt;argbPc[pcPAWN],
879 		s_ivars.plang-&gt;argbPc[pcKNIGHT],
880 		s_ivars.plang-&gt;argbPc[pcBISHOP],
881 		s_ivars.plang-&gt;argbPc[pcROOK],
882 		s_ivars.plang-&gt;argbPc[pcQUEEN],
883 		s_ivars.plang-&gt;argbPc[pcKING]);
884 	VWriteLogAndOutput();
885 	if (s_ivars.cSkip) {
886 		sprintf(s_ivars.aszOutput,"Analysis skip:  %d\n", s_ivars.cSkip);
887 		VWriteLogAndOutput();
888 	}
889 	sprintf(s_ivars.aszOutput,"Engine will use ...\n");
890 	VWriteLogAndOutput();
891 	if (!s_ivars.fUseUCI) {
892 		sprintf(s_ivars.aszOutput,"    \"analyze\":  %s\n", c_argszNoYes[s_ivars.fAnalyze]);
893 		VWriteLogAndOutput();
894 		sprintf(s_ivars.aszOutput,"    \"white\" &amp;\n");
895 		VWriteLogAndOutput();
896 		sprintf(s_ivars.aszOutput,"      \"black\":  %s\n", c_argszNoYes[s_ivars.fColor]);
897 		VWriteLogAndOutput();
898 		sprintf(s_ivars.aszOutput,"    \"ping\":     %s\n", c_argszNoYes[s_ivars.fPing]);
899 		VWriteLogAndOutput();
900 		sprintf(s_ivars.aszOutput,"    \"setboard\": %s\n", c_argszNoYes[s_ivars.fSetboard]);
901 		VWriteLogAndOutput();
902 		sprintf(s_ivars.aszOutput,"    \"usermove\": %s\n", c_argszNoYes[s_ivars.fUsermove]);
903 		VWriteLogAndOutput();
904 	} else {
905 		for (i=0;i&lt;s_ivars.UCIoptions;i++) {
906 			if (s_ivars.UCIoptionstate[i] &amp; 2) {
907 				sprintf(s_ivars.aszOutput,"setoption name %s value %s\n",s_ivars.UCIoption[i],s_ivars.UCIvalue[i]);
908 				if (!s_ivars.fFindInfo) {
909 					VSendToEngine(s_ivars.aszOutput);
910 				}
911 				VWriteLogAndOutput();
912 			}
913 		}
914 	}
915 	if (s_ivars.cIPTime) {
916 		if (s_ivars.cIPTime==1) 
917 			sprintf(s_ivars.aszOutput,"    \"time in\":  centiseconds\n");
918 		else if (s_ivars.cIPTime==2) sprintf(s_ivars.aszOutput,"    \"time in\":  seconds\n");
919 		else if (s_ivars.cIPTime==3) sprintf(s_ivars.aszOutput,"    \"time in\":  tenth of seconds\n");
920 		else sprintf(s_ivars.aszOutput,"    \"time in\":  milliseconds\n");
921 		VWriteLogAndOutput();
922 	}
923 	if ((!s_ivars.fPing) &amp;&amp; (!s_ivars.fUseSt)) {
924 		sprintf(s_ivars.aszOutput,"Test delay:     %d second%s\n", s_ivars.tmWaitInit / 1000,
925 			(s_ivars.tmWaitInit / 1000 == 1) ? "" : "s");
926 		VWriteLogAndOutput();
927 	}
928 	if (s_ivars.fUseSt) {
929 		sprintf(s_ivars.aszOutput,"Try \"st\":       %s\n", c_argszNoYes[s_ivars.fUseSt]);
930 		VWriteLogAndOutput();
931 	}
932 	if (s_ivars.fFindInfo)
933 		return fFALSE;
934 	VWriteEmpty();
935 	s_ivars.aszOutput[0]=0;
936 	for (i = 0; i &lt; cbLINE - 1; i++)
937 		strcat(s_ivars.aszOutput,"-");
938 	VWriteLogAndOutput();
939 	VWriteEmpty();
940 	VWriteEmpty();
941 	if (!s_ivars.fUseUCI) VPrepEngine();
942 	return FNextTest();
943 }
944 BOOL FBreakFeature(char * szCmd, char * szName, int * piValue)
945 {
946 	for (;;) {
947 		if ((*szCmd == '\0') || (*szCmd == '='))
948 			break;
949 		*szName++ = *szCmd++;
950 	}
951 	*szName = '\0';
952 	if (*szCmd++ != '=')
953 		return fFALSE;
954 	if (*szCmd == '"') {    		*piValue = 0;				return fTRUE;			}
955 	if (!isdigit(*szCmd))
956 		return fFALSE;
957 	*piValue = atoi(szCmd);
958 	return fTRUE;
959 }
960 BOOL FCmdFeature(char * sz, char * rgsz[], int csz)
961 {
962 	int	isz;
963 	DWORD i;
964 	for (isz = 1; isz &lt; csz; isz++) {
965 		char	aszName[256];
966 		int	iValue;
967 		if (!FBreakFeature(rgsz[isz], aszName, &amp;iValue))
968 			return fTRUE;			if ((!strcmp(aszName, "done")) &amp;&amp; (!s_ivars.fIgnoreDone)) {
969 			if (iValue == 0) {
970 				if (s_ivars.mode == modeFEATURE_TIMEOUT)
971 					s_ivars.mode = modeFEATURE_NOTIMEOUT;
972 			} else {
973 				if ((s_ivars.mode == modeFEATURE_NOTIMEOUT) ||
974 					(s_ivars.mode == modeFEATURE_TIMEOUT))
975 					if (!FFeatureTimeout())
976 						return fFALSE;
977 			}
978 		} else if (!strcmp(aszName, "ping"))
979 			s_ivars.fPing = (iValue) ? fTRUE : fFALSE;
980 		else if (!strcmp(aszName, "setboard"))
981 			s_ivars.fSetboard = (iValue) ? fTRUE : fFALSE;
982 		else if (!strcmp(aszName, "myname"))
983 		{
984 			for (i=1;i&lt;strlen(rgsz[isz]);i++)
985 			{
986 				if (rgsz[isz][i]=='"')
987 				{
988 					strcpy(s_ivars.aszEngine,&amp;rgsz[isz][i+1]);
989 					s_ivars.aszEngine[strlen(s_ivars.aszEngine)-1]=0;
990 					break;
991 				}
992 			}
993 		}
994 		else if (!strcmp(aszName, "analyze")) {
995 			s_ivars.fAnalyze = (iValue) ? fTRUE : fFALSE;
996 			if (s_ivars.fUseSt)						s_ivars.fAnalyze = fFALSE;
997 		} else if (!strcmp(aszName, "colors"))
998 			s_ivars.fColor = (iValue) ? fTRUE : fFALSE;
999 		else if (!strcmp(aszName, "usermove"))
1000 			s_ivars.fUsermove = (iValue) ? fTRUE : fFALSE;
1001 	}
1002 	return fTRUE;
1003 }
1004 BOOL FCmdUciId(char * sz, char * rgsz[], int csz)
1005 {
1006 	long i;
1007 	if (!strcmp("name",rgsz[1])) {
1008 		strcpy(s_ivars.aszEngine,"\0");
1009 		for (i=2;i&lt;csz;i++) {
1010 			if (i&gt;2) strcat(s_ivars.aszEngine," ");
1011 			strcat(s_ivars.aszEngine,rgsz[i]);
1012 		}
1013 	}
1014 	return fTRUE;
1015 }
1016 BOOL FCmdUciOk(char * sz, char * rgsz[], int csz)
1017 {
1018 	if (!FFeatureTimeout())
1019 		return fFALSE;
1020 	return fTRUE;
1021 }
1022 BOOL FCmdOption(char * sz, char * rgsz[], int csz)
1023 {
1024 	char UciOption[256];
1025 	int i,k;
1026 	bool found;
1027 	if (!strcmp("name",rgsz[1])) {
1028 		strcpy(UciOption,rgsz[2]);
1029 		k=3;
1030 		while (strcmp(rgsz[k],"type")) {
1031 			strcat(UciOption," ");
1032 			strcat(UciOption,rgsz[k]);
1033 			k++;
1034 		}
1035 		found=false;
1036 		for (i=0;i&lt;s_ivars.UCIoptions;i++)
1037 		{
1038 			if (!strcmp(UciOption,s_ivars.UCIoption[i])) {
1039 				found=true;
1040 				s_ivars.UCIoptionstate[i]|=2;
1041 			}
1042 		}
1043 		if (!found) {
1044 			strcpy(s_ivars.UCIoption[s_ivars.UCIoptions],UciOption);
1045 			found=false;
1046 			for (i=k;i&lt;csz;i++) {
1047 				if (!strcmp(rgsz[i],"default")) {
1048 					strcpy(s_ivars.UCIvalue[s_ivars.UCIoptions],rgsz[i+1]);
1049 					found=true;
1050 				}
1051 			}
1052 			s_ivars.UCIoptionstate[s_ivars.UCIoptions]=2;
1053 			if (found) s_ivars.UCIoptions++;
1054 		}
1055 	}
1056 	return fTRUE;
1057 }
1058 BOOL FCmdPong(char * sz, char * rgsz[], int csz)
1059 {
1060 	if (csz == 0)
1061 		return fTRUE;
1062 	if (atoi(rgsz[1]) == s_ivars.cPing) {
1063 		s_ivars.mode = modeTESTING;
1064 		s_ivars.tmStart = TmNow();
1065 		s_ivars.tmEnd = s_ivars.tmStart + s_ivars.tmPerMove;
1066 		SetEvent(s_ivars.heventStdinPing);
1067 	}
1068 	return fTRUE;
1069 }
1070 BOOL FCmdReadyOk(char * sz, char * rgsz[], int csz)
1071 {
1072 	s_ivars.mode = modeTESTING;
1073 	s_ivars.tmStart = TmNow();
1074 	s_ivars.tmEnd = s_ivars.tmStart + s_ivars.tmPerMove;
1075 	SetEvent(s_ivars.heventStdinPing);
1076 	return fTRUE;
1077 }
1078 void VAnalysisLine(char * rgsz[], int csz);
1079 void VEngineMoved(char * sz)
1080 {
1081 	char	asz[256];
1082 	char *	argsz[256];
1083 	int	ibSecond;
1084 	int	csz;
1085 	s_ivars.tmEnd = TmNow();
1086 	if (!s_ivars.fUseUCI) {
1087 		sprintf(asz, "-1 0 %lu 0 %s", (s_ivars.tmEnd - s_ivars.tmStart) / 10, sz);
1088 	} else {
1089 		sprintf(asz, "info time %lu nodes 0 score cp 0 depth -1 pv %s",(s_ivars.tmEnd - s_ivars.tmStart),sz);
1090 	}
1091 	csz = CszVectorizeCmd(asz, argsz, &amp;ibSecond);
1092 	VAnalysisLine(argsz, csz);
1093 }
1094 BOOL FCmdMove(char * sz, char * rgsz[], int csz)
1095 {
1096 	if (csz != 2)
1097 		return fTRUE;
1098 	if (s_ivars.mode != modeTESTING)
1099 		return fTRUE;
1100 	VEngineMoved(rgsz[1]);
1101 	return fTRUE;
1102 }
1103 BOOL FCmdTellusererror(char * sz, char * rgsz[], int csz)
1104 {
1105 	if (s_ivars.mode != modeTESTING)
1106 		return fTRUE;
1107 	s_ivars.fError = fTRUE;
1108 	return fTRUE;
1109 }
1110 CMD const c_argcmdEngine[] = {
1111 	"feature",			FCmdFeature,
1112 	"pong",				FCmdPong,
1113 	"move",				FCmdMove,
1114 	"tellusererror",	FCmdTellusererror,
1115 	"id",				FCmdUciId,
1116 	"option",			FCmdOption,
1117 	"uciok",            FCmdUciOk,
1118 	"readyok",			FCmdReadyOk,
1119 	NULL,
1120 };
1121 BOOL FIsInteger(char * sz, BOOL * pfNonBlankTrailer)
1122 {
1123 	if ((*sz == '-') || (*sz == '+'))
1124 		sz++;
1125 	if (sz[strlen(sz)-1]=='d')			sz[strlen(sz)-1]='\0';
1126 	if (sz[strlen(sz)-1]=='!')			sz[strlen(sz)-1]='\0';
1127 	if (sz[strlen(sz)-1]=='?')			sz[strlen(sz)-1]='\0';
1128 	if (!isdigit(*sz++))			return fFALSE;
1129 	while (isdigit(*sz))
1130 		sz++;
1131 	if (*sz != '\0') {				*pfNonBlankTrailer = fTRUE;
1132 		sz++;
1133 	} else
1134 		*pfNonBlankTrailer = fFALSE;
1135 	return (*sz == '\0');
1136 }
1137 BOOL FCorrectAnswer(char * sz)
1138 {
1139 	int	i;
1140 	while (isdigit(*sz))
1141 		sz++;
1142 	while (*sz == '.')
1143 		sz++;
1144 	if (*sz == '(')
1145 		sz++;								if (*sz == '+')
1146 		sz++;								if (*sz == '-')
1147 		sz++;								if ((strlen(sz)&gt;4) &amp;&amp; (sz[strlen(sz)-3]=='('))
1148 		sz[strlen(sz)-3]=0;					if ((strlen(sz)&gt;3) &amp;&amp; ((!strncmp(&amp;sz[strlen(sz)-2],"FH",2)) || (!strncmp(&amp;sz[strlen(sz)-2],"FL",2))))
1149 		sz[strlen(sz)-2]=0;					if (s_ivars.aszAnswer[0] != '\0') {
1150 		for (i = 0; s_ivars.aszAnswer[i] != '\0';) {
1151 			if (FCheckAnswer(s_ivars.aszFen, sz, s_ivars.aszAnswer + i,
1152 				s_ivars.plang, s_ivars.plangEnglish))
1153 				return fTRUE;
1154 			i += strlen(s_ivars.aszAnswer + i) + 1;
1155 		}
1156 		return fFALSE;
1157 	}
1158 	if (s_ivars.aszAvoid[0] != '\0') {
1159 		for (i = 0; s_ivars.aszAvoid[i] != '\0';) {
1160 			if (FCheckAnswer(s_ivars.aszFen, sz, s_ivars.aszAvoid + i,
1161 				s_ivars.plang, s_ivars.plangEnglish))
1162 				return fFALSE;
1163 			i += strlen(s_ivars.aszAvoid + i) + 1;
1164 		}
1165 		return fTRUE;
1166 	}
1167 	return fFALSE;
1168 }
1169 BOOL FIsMove(char * sz)
1170 {
1171 	if ((strlen(sz) == 4) &amp;&amp; (sz[0]=='[') &amp;&amp; (sz[3]==']'))
1172 		return fFALSE;								if (!strcmp(sz,"MAT")) return fFALSE;			if (!strcmp(sz,"EN")) return fFALSE;			if (!strcmp(sz,"COUPS")) return fFALSE;			if (!strcmp(sz,"MAT!")) return fFALSE;			if (!strncmp(sz,"a8a8",4)) return fFALSE;   	while (isdigit(*sz))
1173 		sz++;
1174 	while (*sz == '.')
1175 		sz++;
1176 	if (*sz == '(')
1177 		sz++;										if (*sz == ')')
1178 		sz++;										while (*sz == '+')
1179 		sz++;										while (*sz == '-')
1180 		sz++;										if ((*sz != '\0') &amp;&amp; (*sz != '/'))          		return fTRUE;
1181 	return fFALSE;
1182 }
1183 void VAnalysisLine(char * rgsz[], int csz)
1184 {
1185 	int		plyDepth;
1186 	int		valScore;
1187 	TM		tm;
1188 	long	nodes;
1189 	int		i;
1190 	char	aszResult[16],hstring[60];
1191 	char	uciline[1024];
1192 	int		cb;
1193 	int		cbStats;
1194 	BOOL	fTrailer;
1195 	int	cSkip;
1196 	if (!s_ivars.fUseUCI) {
1197 		if ((csz == 1) &amp;&amp; ((!strcmp(rgsz[0], "++")) ||
1198 			(!strcmp(rgsz[0], "--")))) {
1199 			sprintf(s_ivars.aszOutput,"%40s\n", rgsz[0]);
1200 			VWriteLogAndOutput();
1201 		}
1202 		strcpy(s_ivars.aszOutput,"Analysis tokens:");
1203 		hstring[0]=0;
1204 		if (s_ivars.fDump) {
1205 			for (i=0;i&lt;__min(csz,6);i++)
1206 			{
1207 				sprintf(hstring,"%d/%s ",i,rgsz[i]);
1208 				strcat(s_ivars.aszOutput,hstring);
1209 			}
1210 			strcat(s_ivars.aszOutput,"\n");
1211 			VWriteLogAndOutput();
1212 		}
1213 		if (csz &lt; 4)
1214 		{
1215 			if (s_ivars.fDump) {
1216 				strcpy(s_ivars.aszOutput,"Analysis: Not enough parameters\n");
1217 				VWriteLogAndOutput();
1218 			}
1219 			return;
1220 		}
1221 		for (i = 0; i &lt; 4; i++) {
1222 			BOOL	f;
1223 			if (!FIsInteger(rgsz[i], &amp;f))
1224 			{
1225 				if ((i==1) &amp;&amp; (!strncmp(rgsz[i],"Mat",3)))
1226 					f=false;
1227 				else 
1228 				{
1229 					if (s_ivars.fDump) {
1230 						sprintf(s_ivars.aszOutput,"Analysis: parameter %d is no integer !\n",i);
1231 						VWriteLogAndOutput();
1232 					}
1233 					return;
1234 				}
1235 			}
1236 			if (i == 0)
1237 				fTrailer = f;
1238 			else if (f)
1239 			{
1240 					if (s_ivars.fDump) {
1241 						sprintf(s_ivars.aszOutput,"Analysis: in the 4 first parameters is one no integer !\n",i);
1242 						VWriteLogAndOutput();
1243 					}
1244 				return;
1245 			}
1246 		}
1247 	} else {
1248 		if (!strcmp(rgsz[0],"info")) {
1249 			char ucidepth[50];
1250 			char uciscore[50];
1251 			char ucinodes[50];
1252 			char ucitime[50];
1253 			char ucipv[1024];
1254 			bool uciwrong,pvstarted;
1255 			int j;
1256 			strcpy(ucipv,"");
1257 			strcpy(ucidepth,"0");
1258 			strcpy(uciscore,"0");
1259 			strcpy(ucinodes,"0");
1260 			strcpy(ucitime,"0");
1261 			i=1;
1262 			uciwrong=false;
1263 			pvstarted=false;
1264 			while ((i&lt;csz) &amp;&amp; (!uciwrong )) {
1265 				if (!strcmp(rgsz[i],"pv")) {
1266 					pvstarted=true;
1267 				} else {
1268 					if (!strcmp(rgsz[i],"currmove")) {
1269 						uciwrong=true;
1270 					} else {
1271 						if (!strcmp(rgsz[i],"currmovenumber")) {
1272 							uciwrong=true;
1273 						} else {
1274 							if (!strcmp(rgsz[i],"currline")) {
1275 								uciwrong=true;
1276 							} else {
1277 								if (!strcmp(rgsz[i],"refutation")) {
1278 									uciwrong=true;
1279 								} else {
1280 									if (!strcmp(rgsz[i],"depth")) {
1281 										pvstarted=false;
1282 										strcpy(ucidepth,rgsz[i+1]);
1283 #if uciDEBUG
1284 										sprintf(s_ivars.aszOutput,"Depth: %s\n",ucidepth);
1285 										VWriteLogAndOutput();
1286 #endif
1287 										i++;
1288 									} else {
1289 										if (!strcmp(rgsz[i],"seldepth")) {
1290 											pvstarted=false;
1291 											i++;
1292 										} else {
1293 											if (!strcmp(rgsz[i],"time")) {
1294 												pvstarted=false;
1295 												strcpy(ucitime,rgsz[i+1]);
1296 												i++;
1297 #if uciDEBUG
1298 												sprintf(s_ivars.aszOutput,"Time: %s\n",ucitime);
1299 												VWriteLogAndOutput();
1300 #endif
1301 											} else {
1302 												if (!strcmp(rgsz[i],"nodes")) {
1303 													pvstarted=false;
1304 													strcpy(ucinodes,rgsz[i+1]);
1305 													i++;
1306 #if uciDEBUG
1307 													sprintf(s_ivars.aszOutput,"Nodes: %s\n",ucinodes);
1308 													VWriteLogAndOutput();
1309 #endif
1310 												} else {
1311 													if (!strcmp(rgsz[i],"multipv")) {
1312 														pvstarted=false;
1313 														i++;
1314 													} else {
1315 														if (!strcmp(rgsz[i],"score")) {
1316 															pvstarted=false;
1317 															if (!strcmp(rgsz[i+1],"mate")) {
1318 																j=atoi(rgsz[i+2]);
1319 																if (j&gt;0) {
1320 																	sprintf(uciscore,"%i",32767-(j*2));
1321 																} else {
1322 																	sprintf(uciscore,"%i",-32768+(j*2));
1323 																}
1324 															} else {
1325 																strcpy(uciscore,rgsz[i+2]);
1326 															}
1327 															i+=2;
1328 #if uciDEBUG
1329 															sprintf(s_ivars.aszOutput,"Score: %s\n",uciscore);
1330 															VWriteLogAndOutput();
1331 #endif
1332 														} else {
1333 															if (!strcmp(rgsz[i],"hashfull")) {
1334 																pvstarted=false;
1335 																i++;
1336 															} else {
1337 																if (!strcmp(rgsz[i],"nps")) {
1338 																	pvstarted=false;
1339 																	i++;
1340 																} else {
1341 																	if (!strcmp(rgsz[i],"tbhits")) {
1342 																		pvstarted=false;
1343 																		i++;
1344 																	} else {
1345 																		if (!strcmp(rgsz[i],"cpuload")) {
1346 																			pvstarted=false;
1347 																			i++;
1348 																		} else {
1349 																			if (!strcmp(rgsz[i],"string")) {
1350 																				uciwrong=true;
1351 																			} else {
1352 																				if (pvstarted) {
1353 																					if (strlen(ucipv)&gt;1) {
1354 																						strcat(ucipv," ");
1355 																					}
1356 																					strcat(ucipv,rgsz[i]);
1357 																				}
1358 																			}
1359 																		}
1360 																	}
1361 																}
1362 															}
1363 														}
1364 													}
1365 												}
1366 											}
1367 										}
1368 									}
1369 								}
1370 							}
1371 						}
1372 					}
1373 				}
1374 				i++;
1375 			}
1376 			if ((uciwrong) || (strlen(ucipv)&lt;2)) return;
1377 			sprintf(uciline,"%s %s %s %s %s",ucidepth,uciscore,ucitime,ucinodes,ucipv);
1378 #if uciDEBUG
1379 			strcpy(s_ivars.aszOutput,uciline);
1380 			strcat(s_ivars.aszOutput,"\n");
1381 			VWriteLogAndOutput();
1382 #endif
1383 			csz=CszVectorizeCmd(uciline,rgsz,&amp;i);
1384 		}
1385 		else {
1386 			return;
1387 		}
1388 	}
1389 	plyDepth = atoi(rgsz[0]);
1390 	cSkip = (plyDepth &lt; 0) ? 0 : s_ivars.cSkip;
1391 	valScore = atoi(rgsz[1]);
1392 	if (s_ivars.cIPTime != 4) tm = atol(rgsz[2]) * 10;
1393 	else tm = atol(rgsz[2]);
1394 	if (s_ivars.cIPTime == 3) tm *= 10;
1395 	else if (((fTrailer) || (s_ivars.cIPTime==2)) 
1396 		&amp;&amp; (s_ivars.cIPTime != 1) &amp;&amp; (s_ivars.cIPTime != 4))
1397 		tm *= 100;
1398 	if (s_ivars.fInternalTime) tm = TmNow() - s_ivars.tmStartPos;
1399 	if (tm &gt; s_ivars.tmPerMove) return;
1400 	nodes = atol(rgsz[3]);
1401 	for (i = 4 + cSkip;; i++)
1402 		if (i &gt;= csz) {
1403 			if (valScore == 49999)
1404 			{
1405 				s_ivars.fCorrectAnswer = fTRUE;
1406 				strcpy(aszResult,"yes");
1407 				if (s_ivars.tmFoundIn==-1)
1408 				{
1409 					s_ivars.tmFoundIn=tm;
1410 					s_ivars.apsInfo[s_ivars.cPosCounter].cSolveDepth=plyDepth;
1411 				}
1412 				break;
1413 			}
1414 lblWrong:	s_ivars.fCorrectAnswer = fFALSE;
1415 			strcpy(aszResult, "no");
1416 			s_ivars.tmFoundIn = -1;
1417 			break;
1418 		} else 
1419 			{
1420 				if (!strncmp(rgsz[i],"TBHits=",7)) i++;						if ((rgsz[i][0]=='(') &amp;&amp; (rgsz[i][strlen(rgsz[i])-1]==')')) i++;					if (rgsz[i][0]==',') i++;															if ((rgsz[i][0]=='(') &amp;&amp; (rgsz[i+1][strlen(rgsz[i+1])-1]==',')) i+=2; 				if ((rgsz[i][0]=='(') &amp;&amp; (rgsz[i+1][strlen(rgsz[i+1])-1]==')')) i+=2; 				if (FIsMove(rgsz[i])) {
1421 				if (!FCorrectAnswer(rgsz[i]))
1422 					goto lblWrong;
1423 				s_ivars.fCorrectAnswer = fTRUE;
1424 				strcpy(aszResult, "yes");
1425 				if (s_ivars.tmFoundIn == -1) {
1426 					s_ivars.tmFoundIn = tm;
1427 					s_ivars.apsInfo[s_ivars.cPosCounter].cSolveDepth=plyDepth;
1428 				}
1429 				if (s_ivars.fStopPly) {
1430 					if ((plyDepth-s_ivars.apsInfo[s_ivars.cPosCounter].cSolveDepth)&gt;=s_ivars.cPlys) {
1431 						s_ivars.fStopAnalysis=fTRUE;
1432 					}
1433 				}
1434 				if (s_ivars.fStopScore) {
1435 					if (valScore&gt;=s_ivars.cScore) {
1436 						s_ivars.fStopAnalysis=fTRUE;
1437 					}
1438 				}
1439 				break;
1440 			}
1441 		}
1442 	if (plyDepth &lt; 0)
1443 		cb = cbStats = sprintf(s_ivars.aszOutput,"%-3s ??? %9ld (moved)           ???",
1444 			aszResult, tm);
1445 	else {
1446 		if (s_ivars.fDump) {
1447 			cb = cbStats = sprintf(s_ivars.aszOutput,"%-3s %3d %9ld:%d %+8d %12ld",
1448 				aszResult, plyDepth, tm, TmNow() - s_ivars.tmStartPos,valScore, nodes);
1449 			s_ivars.apsInfo[s_ivars.cPosCounter].cLastDepth=plyDepth;
1450 			s_ivars.apsInfo[s_ivars.cPosCounter].cLastEval=valScore;
1451 			if (csz&gt;4+cSkip) s_ivars.apsInfo[s_ivars.cPosCounter].aszLastPV[0]='\0';
1452 		}
1453 		else
1454 		{
1455 			cb = cbStats = sprintf(s_ivars.aszOutput,"%-3s %3d %9ld %+8d %12ld",
1456 				aszResult, plyDepth, tm,valScore, nodes);
1457 			s_ivars.apsInfo[s_ivars.cPosCounter].cLastDepth=plyDepth;
1458 			s_ivars.apsInfo[s_ivars.cPosCounter].cLastEval=valScore;
1459 			if (csz&gt;4+cSkip) s_ivars.apsInfo[s_ivars.cPosCounter].aszLastPV[0]='\0';
1460 		}
1461 	}
1462 	for (i = 4 + cSkip; i &lt; csz; i++) {
1463 		int	cbCur = strlen(rgsz[i]) + 1;
1464 		if (strlen(s_ivars.apsInfo[s_ivars.cPosCounter].aszLastPV)+strlen(rgsz[i])+1&lt;512) {
1465 			strcat(s_ivars.apsInfo[s_ivars.cPosCounter].aszLastPV," ");
1466 			strcat(s_ivars.apsInfo[s_ivars.cPosCounter].aszLastPV,rgsz[i]);
1467 		}
1468 		if (cb + cbCur &gt; cbLINE - 1) {
1469 			VWriteLogAndOutput();
1470 			VWriteEmpty();
1471 			s_ivars.aszOutput[0]=0;
1472 			for (cb = 0; cb &lt; cbStats; cb++)
1473 				strcat(s_ivars.aszOutput," ");
1474 		}
1475 		strcat(s_ivars.aszOutput," ");
1476 		strcat(s_ivars.aszOutput,rgsz[i]);
1477 		cb += cbCur;
1478 	}
1479 	VWriteLogAndOutput();
1480 	VWriteEmpty();
1481 }
1482 #define	uHOUR_FROM_MILLI(tm)	(unsigned)((TM)(tm) / 3600000)
1483 #define	uMIN_FROM_MILLI(tm)		(unsigned)(((TM)(tm) / 60000) % 60)
1484 #define	uSEC_FROM_MILLI(tm)		(unsigned)(((TM)(tm) / 1000) % 60)
1485 #define	uMILLI_FROM_MILLI(tm)	(unsigned)((TM)(tm) % 1000)
1486 void VDumpResults(void)
1487 {
1488 	int	isolHi;
1489 	int i,j,k,r,cb,cbCur,csz;
1490 	unsigned int l;
1491 	DWORD dwa;
1492 	char aszAddText[20];
1493 	char * argsz[256];
1494 	sprintf (s_ivars.aszOutput,"Position results:\n\n");
1495 	VWriteLogAndOutput();
1496 	sprintf (s_ivars.aszOutput,"PosNr solved ply      time     last pv\n");
1497 	VWriteLogAndOutput();
1498 	sprintf(s_ivars.aszOutput,"----- ------ --- ------------- ");
1499 	for (cb=strlen(s_ivars.aszOutput);cb&lt;cbLINE - 1;cb++)
1500 		strcat(s_ivars.aszOutput,"-");
1501 	VWriteLogAndOutput();
1502 	VWriteEmpty();
1503 	for (i = 0; i &lt; s_ivars.cPosCounter;i++) {
1504 		if (s_ivars.apsInfo[i].cSolveTime&lt;=s_ivars.tmPerMove)
1505 			sprintf(s_ivars.aszOutput,"%5d    yes %3d [%02d:%02d:%02d,%02d] ",i+1,
1506 				s_ivars.apsInfo[i].cSolveDepth,
1507 				uHOUR_FROM_MILLI(s_ivars.apsInfo[i].cSolveTime),
1508 				uMIN_FROM_MILLI(s_ivars.apsInfo[i].cSolveTime),
1509 				uSEC_FROM_MILLI(s_ivars.apsInfo[i].cSolveTime),
1510 				uMILLI_FROM_MILLI(s_ivars.apsInfo[i].cSolveTime)/10);
1511 		else sprintf(s_ivars.aszOutput,"%5d     no     [--:--:--,--] ",i+1);
1512 		cb=strlen(s_ivars.aszOutput);
1513 		if (s_ivars.apsInfo[i].cLastDepth&gt;0) {
1514 			sprintf(aszAddText,"[%d] %+.2f ",s_ivars.apsInfo[i].cLastDepth,
1515 					(float) s_ivars.apsInfo[i].cLastEval/100.0);
1516 		}
1517 		else aszAddText[0]=0;
1518 		cbCur=strlen(aszAddText);
1519 		if (cbCur&gt;0) strcat(s_ivars.aszOutput,aszAddText);
1520 		csz=CszVectorizeCmd(s_ivars.apsInfo[i].aszLastPV,argsz,&amp;r);
1521 		for (j=0; j&lt;csz; j++) {
1522 			if (cb+cbCur+strlen(argsz[j])&lt;cbLINE) {
1523 				cbCur+=strlen(argsz[j])+1;
1524 				strcat(s_ivars.aszOutput,argsz[j]);
1525 				strcat(s_ivars.aszOutput," ");
1526 			}
1527 			else
1528 			{
1529 				VWriteLogAndOutput();
1530 				VWriteEmpty();
1531 				s_ivars.aszOutput[0]=0;
1532 				for (k=0; k&lt;cb; k++)
1533 					strcat(s_ivars.aszOutput," ");
1534 				strcat(s_ivars.aszOutput,argsz[j]);
1535 				strcat(s_ivars.aszOutput," ");
1536 				cbCur=strlen(argsz[j])+1;
1537 			}
1538 		}
1539 		VWriteLogAndOutput();
1540 		VWriteEmpty();
1541 	}
1542 	s_ivars.aszOutput[0]=0;
1543 	for (i = 0; i &lt; cbLINE - 1; i++)
1544 		strcat(s_ivars.aszOutput,"-");
1545 	VWriteLogAndOutput();
1546 	VWriteEmpty();
1547 	VWriteEmpty();
1548 	for (isolHi = isolMAX - 1; isolHi &gt;= 0; isolHi--)
1549 		if (s_ivars.argsol[isolHi])
1550 			break;
1551 	sprintf(s_ivars.aszOutput,"Results:\n\n");
1552 	VWriteLogAndOutput();
1553 	if (s_ivars.cSolved) {
1554 		if (isolHi &lt; 0) {
1555 			sprintf(s_ivars.aszOutput,"No problems solved in &lt; %d seconds\n", isolMAX);
1556 			VWriteLogAndOutput();
1557 		}
1558 		else {
1559 			int	cTotal = 0;
1560 			sprintf(s_ivars.aszOutput,"&lt;=Sec Solved Total  PosNr\n");
1561 			VWriteLogAndOutput();
1562 			strcpy(s_ivars.aszOutput,"----- ------ ------ ");
1563 			for (cb=strlen(s_ivars.aszOutput);cb&lt;cbLINE - 1;cb++)
1564 				strcat(s_ivars.aszOutput,"-");
1565 			VWriteLogAndOutput();
1566 			VWriteEmpty();
1567 			for (i = 0; i &lt;= isolHi; i++) {
1568 				if (s_ivars.argsol[i]) {
1569 					cTotal += s_ivars.argsol[i];
1570 					k=sprintf(s_ivars.aszOutput,"%5d %6d %6d", i + 1, s_ivars.argsol[i], cTotal);
1571 					cb=strlen(s_ivars.aszOutput);
1572 					cbCur=0;
1573 					for (j=0;j&lt;s_ivars.cPosCounter;j++) {
1574 						if (((s_ivars.apsInfo[j].cSolveTime&lt;=(TM)(i+1)*1000)
1575 							&amp;&amp; (s_ivars.apsInfo[j].cSolveTime&gt;(TM)i*1000)) 
1576 							|| ((i==0) &amp;&amp; (s_ivars.apsInfo[j].cSolveTime==0))) {
1577 							if (s_ivars.cPosCounter&lt;10) {
1578 								k=sprintf(aszAddText,"%2d",j+1);
1579 							}
1580 							else if (s_ivars.cPosCounter&lt;100) {
1581 								k=sprintf(aszAddText,"%3d",j+1);
1582 							}
1583 							else if (s_ivars.cPosCounter&lt;1000) {
1584 								k=sprintf(aszAddText,"%4d",j+1);
1585 							}
1586 							else k=sprintf(aszAddText,"%5d",j+1);
1587 							if (cb+cbCur+strlen(aszAddText)&lt;cbLINE) {
1588 								cbCur+=strlen(aszAddText);
1589 								strcat(s_ivars.aszOutput,aszAddText);
1590 							}
1591 							else {
1592 								VWriteLogAndOutput();
1593 								VWriteEmpty();
1594 								cbCur=strlen(aszAddText);
1595 								s_ivars.aszOutput[0]=0;
1596 								for (k=0;k&lt;cb;k++)
1597 									strcat(s_ivars.aszOutput," ");
1598 								strcat(s_ivars.aszOutput,aszAddText);
1599 							}
1600 						}
1601 					}
1602 					VWriteLogAndOutput();
1603 					VWriteEmpty();
1604 				}
1605 			}
1606 			strcpy(s_ivars.aszOutput,"Failure");
1607 			for (i=strlen(s_ivars.aszOutput);i&lt;cb;i++)
1608 				strcat(s_ivars.aszOutput," ");
1609 			cbCur=0;
1610 			for (i=0;i&lt;s_ivars.cPosCounter;i++) {
1611 				if (s_ivars.apsInfo[i].cSolveTime&gt;=s_ivars.tmPerMove) {
1612 					if (s_ivars.cPosCounter&lt;10) {
1613 						k=sprintf(aszAddText,"%2d",i+1);
1614 					}
1615 					else if (s_ivars.cPosCounter&lt;100) {
1616 						k=sprintf(aszAddText,"%3d",i+1);
1617 					}
1618 					else if (s_ivars.cPosCounter&lt;1000) {
1619 						k=sprintf(aszAddText,"%4d",i+1);
1620 					}
1621 					else k=sprintf(aszAddText,"%5d",i+1);
1622 					if (cb+cbCur+strlen(aszAddText)&lt;cbLINE) {
1623 						cbCur+=strlen(aszAddText);
1624 						strcat(s_ivars.aszOutput,aszAddText);
1625 					}
1626 					else {
1627 						VWriteLogAndOutput();
1628 						VWriteEmpty();
1629 						cbCur=strlen(aszAddText);
1630 						s_ivars.aszOutput[0]=0;
1631 						for (k=0;k&lt;cb;k++)
1632 							strcat(s_ivars.aszOutput," ");
1633 						strcat(s_ivars.aszOutput,aszAddText);
1634 					}
1635 				}
1636 			}
1637 			VWriteLogAndOutput();
1638 			VWriteEmpty();
1639 		}
1640 		VWriteEmpty();
1641 	}
1642 	sprintf(s_ivars.aszOutput,"%d problem%s solved.\n", s_ivars.cSolved,
1643 		(s_ivars.cSolved == 1) ? "" : "s");
1644 	VWriteLogAndOutput();
1645 	sprintf(s_ivars.aszOutput,"%d problem%s unsolved.\n", s_ivars.cFailed,
1646 		(s_ivars.cFailed == 1) ? "" : "s");
1647 	VWriteLogAndOutput();
1648 	if (s_ivars.cError) {
1649 		sprintf(s_ivars.aszOutput,"%d error%s found!\n",
1650 			s_ivars.cError, (s_ivars.cError == 1) ? "" : "s");
1651 		VWriteLogAndOutput();
1652 	}
1653 	VWriteEmpty();
1654 	if (s_ivars.fDBon)
1655 	{
1656 		FILE * OldFile;
1657 		char aszOutput[5000];
1658 		DWORD solvetime,solved;
1659 		solved=0;
1660 		solvetime=0;
1661 		dwa=GetFileAttributes(s_ivars.aszDBFile);
1662 		if (dwa==(DWORD)(-1))
1663 		{
1664 			s_ivars.DBDatei.open(s_ivars.aszDBFile,ios::trunc | ios::out | ios::in);
1665 			s_ivars.DBDatei.seekp(0,ios::beg);
1666 			sprintf(aszOutput,"\"%s\";;;;\"%s\";\n",s_ivars.aszSuite,s_ivars.aszEngine);
1667 			s_ivars.DBDatei.write(aszOutput,strlen(aszOutput));
1668 			s_ivars.DBDatei.seekp(0,ios::end);
1669 			strcpy(aszOutput,"\"Nr.\";\"Name\";\"FEN\";\"Keymove\";\"time\";\"depth\"\n");
1670 			s_ivars.DBDatei.write(aszOutput,strlen(aszOutput));
1671 			s_ivars.DBDatei.seekp(0,ios::end);
1672 			for (i = 0; i &lt; s_ivars.cPosCounter;i++) 
1673 			{
1674 				sprintf(aszOutput,"\"%i\";\"%s\";\"%s\";\"%s\";",i+1,s_ivars.aszName[i],s_ivars.aszFEN[i],s_ivars.aszSol[i]);
1675 				if (s_ivars.apsInfo[i].cSolveTime&lt;=s_ivars.tmPerMove)
1676 				{
1677 					solved++;
1678 					solvetime+=s_ivars.apsInfo[i].cSolveTime/1000;
1679 					sprintf(aszOutput,"%s\"%i\";\"%i\"\n",aszOutput,s_ivars.apsInfo[i].cSolveTime/1000,s_ivars.apsInfo[i].cSolveDepth);
1680 				}
1681 				else
1682 				{
1683 					solvetime+=s_ivars.tmPerMove/1000;
1684 					sprintf(aszOutput,"%s\"9999\";\"%i\"\n",aszOutput,s_ivars.apsInfo[i].cLastDepth);
1685 				}
1686 				s_ivars.DBDatei.write(aszOutput,strlen(aszOutput));
1687 				s_ivars.DBDatei.seekp(0,ios::end);
1688 			}
1689 			sprintf(aszOutput,";;;\"Solved:\";\"%i\";\n",solved);
1690 			s_ivars.DBDatei.write(aszOutput,strlen(aszOutput));
1691 			s_ivars.DBDatei.seekp(0,ios::end);
1692 			sprintf(aszOutput,";;;\"Solve-Time:\";\"%i\";\n",solvetime);
1693 			s_ivars.DBDatei.write(aszOutput,strlen(aszOutput));
1694 			s_ivars.DBDatei.seekp(0,ios::end);
1695 			s_ivars.DBDatei.close();
1696 		}
1697 		else
1698 		{
1699 			strcpy(aszOutput,s_ivars.aszDBFile);
1700 			strcat(aszOutput,".bak");
1701 			dwa=GetFileAttributes(aszOutput);
1702 			if (!(dwa==(DWORD)(-1)))
1703 			{
1704 				remove(aszOutput);
1705 			}
1706 			rename(s_ivars.aszDBFile,aszOutput);
1707 			if( (OldFile = fopen( aszOutput, "r" )) != NULL )
1708 			{
1709 				fgets(aszOutput,5000,OldFile);
1710 				j=0;
1711 				for (l=0;l&lt;strlen(aszOutput);l++) {
1712 					if (aszOutput[l]==';') {
1713 						j++;
1714 					}
1715 				}
1716 				if (j&gt;250) {
1717 					fclose(OldFile);
1718 					strcpy(aszOutput,s_ivars.aszDBFile);
1719 					strcat(aszOutput,".001");
1720 					dwa=GetFileAttributes(aszOutput);
1721 					if (!(dwa==(DWORD)(-1)))
1722 					{
1723 						remove(aszOutput);
1724 					}
1725 					rename(s_ivars.aszDBFile,aszOutput);
1726 					dwa=GetFileAttributes(s_ivars.aszDBFile);
1727 					if (dwa==(DWORD)(-1))
1728 					{
1729 						s_ivars.DBDatei.open(s_ivars.aszDBFile,ios::trunc | ios::out | ios::in);
1730 						s_ivars.DBDatei.seekp(0,ios::beg);
1731 						sprintf(aszOutput,"\"%s\";;;;\"%s\";\n",s_ivars.aszSuite,s_ivars.aszEngine);
1732 						s_ivars.DBDatei.write(aszOutput,strlen(aszOutput));
1733 						s_ivars.DBDatei.seekp(0,ios::end);
1734 						strcpy(aszOutput,"\"Nr.\";\"Name\";\"FEN\";\"Keymove\";\"time\";\"depth\"\n");
1735 						s_ivars.DBDatei.write(aszOutput,strlen(aszOutput));
1736 						s_ivars.DBDatei.seekp(0,ios::end);
1737 						for (i = 0; i &lt; s_ivars.cPosCounter;i++) 
1738 						{
1739 							sprintf(aszOutput,"\"%i\";\"%s\";\"%s\";\"%s\";",i+1,s_ivars.aszName[i],s_ivars.aszFEN[i],s_ivars.aszSol[i]);
1740 							if (s_ivars.apsInfo[i].cSolveTime&lt;=s_ivars.tmPerMove)
1741 							{
1742 								solved++;
1743 								solvetime+=s_ivars.apsInfo[i].cSolveTime/1000;
1744 								sprintf(aszOutput,"%s\"%i\";\"%i\"\n",aszOutput,s_ivars.apsInfo[i].cSolveTime/1000,s_ivars.apsInfo[i].cSolveDepth);
1745 							}
1746 							else
1747 							{
1748 								solvetime+=s_ivars.tmPerMove/1000;
1749 								sprintf(aszOutput,"%s\"9999\";\"%i\"\n",aszOutput,s_ivars.apsInfo[i].cLastDepth);
1750 							}
1751 							s_ivars.DBDatei.write(aszOutput,strlen(aszOutput));
1752 							s_ivars.DBDatei.seekp(0,ios::end);
1753 						}
1754 						sprintf(aszOutput,";;;\"Solved:\";\"%i\";\n",solved);
1755 						s_ivars.DBDatei.write(aszOutput,strlen(aszOutput));
1756 						s_ivars.DBDatei.seekp(0,ios::end);
1757 						sprintf(aszOutput,";;;\"Solve-Time:\";\"%i\";\n",solvetime);
1758 						s_ivars.DBDatei.write(aszOutput,strlen(aszOutput));
1759 						s_ivars.DBDatei.seekp(0,ios::end);
1760 						s_ivars.DBDatei.close();
1761 					}
1762 				} else {
1763 					VStrip(aszOutput);
1764 					sprintf(aszOutput,"%s;\"%s\";\n",aszOutput,s_ivars.aszEngine);
1765 					s_ivars.DBDatei.open(s_ivars.aszDBFile,ios::trunc | ios::out | ios::in);
1766 					s_ivars.DBDatei.seekp(0,ios::beg);
1767 					s_ivars.DBDatei.write(aszOutput,strlen(aszOutput));
1768 					s_ivars.DBDatei.seekp(0,ios::end);
1769 					fgets(aszOutput,5000,OldFile);
1770 					VStrip(aszOutput);
1771 					sprintf(aszOutput,"%s;\"time\";\"depth\"\n",aszOutput);
1772 					s_ivars.DBDatei.write(aszOutput,strlen(aszOutput));
1773 					s_ivars.DBDatei.seekp(0,ios::end);
1774 					for (i = 0; i &lt; s_ivars.cPosCounter;i++) 
1775 					{
1776 						fgets(aszOutput,5000,OldFile);
1777 						VStrip(aszOutput);
1778 						if (s_ivars.apsInfo[i].cSolveTime&lt;=s_ivars.tmPerMove)
1779 						{
1780 							solved++;
1781 							solvetime+=s_ivars.apsInfo[i].cSolveTime/1000;
1782 							sprintf(aszOutput,"%s;\"%i\";\"%i\"\n",aszOutput,s_ivars.apsInfo[i].cSolveTime/1000,s_ivars.apsInfo[i].cSolveDepth);
1783 						}
1784 						else
1785 						{
1786 							solvetime+=s_ivars.tmPerMove/1000;
1787 							sprintf(aszOutput,"%s;\"9999\";\"%i\"\n",aszOutput,s_ivars.apsInfo[i].cLastDepth);
1788 						}
1789 						s_ivars.DBDatei.write(aszOutput,strlen(aszOutput));
1790 						s_ivars.DBDatei.seekp(0,ios::end);
1791 					}
1792 					fgets(aszOutput,5000,OldFile);
1793 					VStrip(aszOutput);
1794 					sprintf(aszOutput,"%s;\"%i\";\n",aszOutput,solved);
1795 					s_ivars.DBDatei.write(aszOutput,strlen(aszOutput));
1796 					s_ivars.DBDatei.seekp(0,ios::end);
1797 					fgets(aszOutput,5000,OldFile);
1798 					VStrip(aszOutput);
1799 					sprintf(aszOutput,"%s;\"%i\";\n",aszOutput,solvetime);
1800 					s_ivars.DBDatei.write(aszOutput,strlen(aszOutput));
1801 					s_ivars.DBDatei.seekp(0,ios::end);
1802 					s_ivars.DBDatei.close();
1803 					fclose(OldFile);
1804 				}
1805 			}
1806 		}
1807 	}
1808 }
1809 BOOL FSummary(void)
1810 {
1811 	int	i;
1812 	char hilfe[80];
1813 	if (!s_ivars.fUseUCI) {
1814 		if (s_ivars.fAnalyze)
1815 			VSendToEngine("exit");
1816 		else 
1817 		{
1818 			VSendToEngine("?");
1819 		}
1820 		VSendToEngine("force");
1821 	} else {
1822 		VSendToEngine("stop");
1823 	}
1824 	sprintf(s_ivars.aszOutput,"\nResult:   ");
1825 	if (s_ivars.fError) {
1826 		strcat(s_ivars.aszOutput,"ERROR!!");
1827 		s_ivars.cError++;
1828 	} else if (s_ivars.fCorrectAnswer) {
1829 		strcat(s_ivars.aszOutput,"Success");
1830 		s_ivars.cSolved++;
1831 	} else {
1832 		strcat(s_ivars.aszOutput,"Failure");
1833 		s_ivars.cFailed++;
1834 	}
1835 	sprintf(hilfe,"   (%i of %i solved so far - %i",s_ivars.cSolved,s_ivars.cPosCounter+1,s_ivars.cSolved*100/(s_ivars.cPosCounter+1));
1836 	strcat(s_ivars.aszOutput,hilfe);
1837 	strcat(s_ivars.aszOutput,"%)");
1838 	VWriteLogAndOutput();
1839 	VWriteEmpty();
1840 	if (s_ivars.fCorrectAnswer) {
1841 		int	isol;
1842 		s_ivars.apsInfo[s_ivars.cPosCounter].cSolveTime=s_ivars.tmFoundIn;
1843 		sprintf(s_ivars.aszOutput,"Found in: %ld ms (%02d:%02d:%02d.%03d)\n",
1844 			s_ivars.tmFoundIn,
1845 			uHOUR_FROM_MILLI(s_ivars.tmFoundIn),
1846 			uMIN_FROM_MILLI(s_ivars.tmFoundIn),
1847 			uSEC_FROM_MILLI(s_ivars.tmFoundIn),
1848 			uMILLI_FROM_MILLI(s_ivars.tmFoundIn));
1849 		VWriteLogAndOutput();
1850 		isol = s_ivars.tmFoundIn / 1000;
1851 		if ((isol&gt;0) &amp;&amp; (s_ivars.tmFoundIn % 1000 == 0)) isol--;
1852 		if (isol &lt; isolMAX)
1853 			s_ivars.argsol[isol]++;
1854 	}
1855 	else s_ivars.apsInfo[s_ivars.cPosCounter].cSolveTime=s_ivars.tmPerMove+1;
1856 	s_ivars.cPosCounter++;
1857 	VWriteEmpty();
1858 	s_ivars.aszOutput[0]=0;
1859 	for (i = 0; i &lt; cbLINE - 1; i++)
1860 		strcat(s_ivars.aszOutput,"-");
1861 	VWriteLogAndOutput();
1862 	VWriteEmpty();
1863 	VWriteEmpty();
1864 	return FNextTest();
1865 }
1866 void VProcess(void)
1867 {
1868 	int	i;
1869 	sprintf(s_ivars.aszOutput,"\nEpd2Wb, Release 02/TM\n");
1870 	VWriteLogAndOutput();
1871 	sprintf(s_ivars.aszOutput,"original version by Bruce Moreland with some modifications by Thomas Mayer\n");
1872 	VWriteLogAndOutput();
1873 	sprintf(s_ivars.aszOutput,"epd2wb comes with ABSOLUTELY NO WARRANTY - released under GPL\n\n");
1874 	VWriteLogAndOutput();
1875 	if (s_ivars.fUseUCI==fFALSE) {
1876 		VSendToEngine("xboard");
1877 		if (!s_ivars.fPureProt1) VSendToEngine("protover 2");
1878 		s_ivars.mode = modeFEATURE_TIMEOUT;
1879 	} else {
1880 		VSendToEngine("uci");
1881 		s_ivars.mode = modeFEATURE_NOTIMEOUT;
1882 	}
1883 	s_ivars.tmEnd = TmNow() + 5000;
1884 	SetEvent(s_ivars.heventStdinAck);
1885 	for (;;) {
1886 		int	csz;
1887 		char	aszBuf[1024];
1888 		char	aszVec[1024];
1889 		char *	argsz[256];
1890 		int	ibSecond;
1891 		if (s_ivars.mode == modeFEATURE_TIMEOUT) {
1892 			TM	tm;
1893 			tm = TmNow();
1894 			if ((tm &gt;= s_ivars.tmEnd) ||
1895 				(WaitForSingleObject(s_ivars.heventStdinReady,
1896 				s_ivars.tmEnd - tm) == WAIT_TIMEOUT)) {
1897 				if (!FFeatureTimeout())
1898 					return;
1899 				continue;				}
1900 		} else if (s_ivars.mode == modeTESTING) {
1901 			TM	tm;
1902 			DWORD	dwTimeout;
1903 			tm = TmNow();
1904 			dwTimeout = (s_ivars.fUseSt) ?
1905 				INFINITE : s_ivars.tmEnd - tm;
1906 			if ((tm &gt;= s_ivars.tmEnd) || (s_ivars.fStopAnalysis) || 
1907 				(WaitForSingleObject(s_ivars.heventStdinReady,
1908 				dwTimeout) == WAIT_TIMEOUT)) {
1909 				if (!FSummary())
1910 					return;
1911 				continue;				}
1912 		} else
1913 			WaitForSingleObject(s_ivars.heventStdinReady, INFINITE);
1914 		strcpy(aszBuf, s_ivars.aszInBuf);
1915 		strcpy(aszVec, s_ivars.aszInBuf);
1916 		csz = CszVectorizeCmd(aszVec, argsz, &amp;ibSecond);
1917 		if (csz) {
1918 			if ((!s_ivars.fUseUCI) || (strcmp(argsz[0],"info"))) {
1919 				for (i = 0; c_argcmdEngine[i].sz != NULL; i++)
1920 					if (!strcmp(c_argcmdEngine[i].sz, argsz[0])) {
1921 						if (!(*c_argcmdEngine[i].pfn)(aszBuf + ibSecond,
1922 							argsz, csz))
1923 							return;
1924 						break;
1925 					}
1926 			}
1927 			if (s_ivars.mode == modeTESTING)
1928 				if (((csz == 3) &amp;&amp; (!strcmp(argsz[1], "..."))) &amp;&amp; (!s_ivars.fUseUCI)) {
1929 					VEngineMoved(argsz[2]); 
1930 				}
1931 				else {
1932 					if ((s_ivars.fUseUCI) &amp;&amp; (!strcmp(argsz[0],"bestmove"))) {
1933 						VEngineMoved(argsz[1]);
1934 					} else {
1935 						VAnalysisLine(argsz, csz);
1936 					}
1937 				}
1938 		}
1939 		SetEvent(s_ivars.heventStdinAck);
1940 	}
1941 }
1942 void ShutdownSignalHandler(int signr)
1943 {
1944 	s_ivars.fQuit = fTRUE;
1945 	if (s_ivars.fUseUCI) {
1946 		VSendToEngine("stop");
1947 	}
1948 	if (s_ivars.fEngineStarted)
1949 		VSendToEngine("quit");
1950     return;
1951 }
1952 LANG c_arglang[] = {
1953 	"Czech",		'P',	'J',	'S',	'V',	'D',	'K',
1954 	"Danish",		'B',	'S',	'L',	'T',	'D',	'K',
1955 	"Dutch",		'O',	'P',	'L',	'T',	'D',	'K',
1956 	"English",		'P',	'N',	'B',	'R',	'Q',	'K',
1957 	"Estonian",		'P',	'R',	'O',	'V',	'L',	'K',
1958 	"Finnish",		'P',	'R',	'L',	'T',	'D',	'K',
1959 	"French",		'P',	'C',	'F',	'T',	'D',	'R',
1960 	"German",		'B',	'S',	'L',	'T',	'D',	'K',
1961 	"Hungarian",	'G',	'H',	'F',	'B',	'V',	'K',
1962 	"Icelandic",	'P',	'R',	'B',	'H',	'D',	'K',
1963 	"Italian",		'P',	'C',	'A',	'T',	'D',	'R',
1964 	"Norwegian",	'B',	'S',	'L',	'T',	'D',	'K',
1965 	"Polish",		'P',	'S',	'G',	'W',	'H',	'K',
1966 	"Portuguese",	'P',	'C',	'B',	'T',	'D',	'R',
1967 	"Romanian",		'P',	'C',	'N',	'T',	'D',	'R',
1968 	"Spanish",		'P',	'C',	'A',	'T',	'D',	'R',
1969 	"Swedish",		'B',	'S',	'L',	'T',	'D',	'K',
1970 	NULL,
1971 };
1972 PLANG PlangFindLang(char * szLang)
1973 {
1974 	int	i;
1975 	for (i = 0; c_arglang[i].szLang != NULL; i++)
1976 		if (!strcmpi(c_arglang[i].szLang, szLang))
1977 			return &amp;c_arglang[i];
1978 	return NULL;
1979 }
1980 char * const c_aszUsage[] = {
1981 	"Usage: epd2wb &lt;engine&gt; &lt;EPD&gt; &lt;seconds&gt; [flags]",
1982 	"  -?      Usage",
1983 	"  -a      Turns usage of analyze on by default (Prot. 1 - engines with analyze)",
1984 	"  -b&lt;B&gt;   Name of the database file it should use - default=&lt;none&gt;",
1985 	"  -c&lt;E&gt;   For UCI-engines, the file sets the parameters",
1986 	"  -d      Dumps all input and output to the console",
1987 	"  -e&lt;S&gt;   waits &lt;S&gt; econds after starting the engine before sending the first\n          command to it",
1988 	"  -f&lt;F&gt;   Name of the logfile - else no logging !",
1989 	"  -g&lt;x&gt;   Specifies that the analysis should stop when the solution is correct\n          for &lt;x&gt; ply's",
1990 	"  -h&lt;y&gt;   Specifies that the analysis should stop when the solution is correct\n          and the score is above &lt;y&gt;",
1991 	"  -i      Outputs engine information then stops",
1992 	"  -j      Use UCI-1 commands ONLY !",
1993 	"  -l&lt;L&gt;   Choose analysis input language",
1994 	"  -n&lt;x&gt;   multiplys the time sent in st mode with x",
1995 	"  -o      Skip protover for pure wb-prot 1",
1996 	"  -p&lt;P&gt;   Path to the engine",
1997 	"  -s&lt;D&gt;   Skip D analysis fields",
1998 	"  -t      Uses Winboard \"st\" command to try to get old engines to work.",
1999 	"  -u      Turns usage of setboard on by default (even Prot. 1 engines are used\n          then with setboard",
2000 	"  -v&lt;T&gt;   Force to interpret time in c=centiseconds, s=seconds, t=tenthseconds,\n          m=milliseconds",
2001 	"  -w&lt;S&gt;   Protover 1 for initialization wait period (in seconds) default 4",
2002 	"  -x&lt;T&gt;   Protover 1 between test wait period (in seconds) default=1",
2003 	"  -y      Use internal time control instead what the engine sends",
2004 	"  -z      Ignore feature done=0 &amp; feature done=1",
2005 	NULL,
2006 };
2007 void VUsage(void)
2008 {
2009 	int	i;
2010 	for (i = 0; c_aszUsage[i] != NULL; i++)
2011 		fprintf(stderr, "%s\n", c_aszUsage[i]);
2012 	printf("\nLanguages:\n\n");
2013 	for (i = 0; c_arglang[i].szLang != NULL; i++) {
2014 		if ((i % 4 == 3) || (c_arglang[i + 1].szLang == NULL))
2015 			fprintf(stderr, "%s\n", c_arglang[i].szLang);
2016 		else
2017 			fprintf(stderr, "%-20s", c_arglang[i].szLang);
2018 	}
2019 	if (s_ivars.fEngineStarted)
2020 		VSendToEngine("quit");
2021 	exit(1);
2022 }
2023 int main(int argc, char * argv[])
2024 {
2025 	DWORD	dw;
2026 	int	iszArg;
2027 	int	isz,i;
2028 	char	aszLanguage[256];
2029     signal(SIGINT, ShutdownSignalHandler);              signal(SIGBREAK, ShutdownSignalHandler); 
2030     signal(SIGTERM, ShutdownSignalHandler);
2031 	s_ivars.fDump = fFALSE;
2032 	s_ivars.cSkip = 0;
2033 	s_ivars.fEngineStarted = fFALSE;
2034 	s_ivars.fPing = fFALSE;
2035 	s_ivars.fSetboard = fFALSE;
2036 	s_ivars.fAnalyze = fFALSE;
2037 	s_ivars.fColor = fTRUE;
2038 	s_ivars.fPureProt1 = fFALSE;
2039 	s_ivars.fInternalTime = fFALSE;
2040 	s_ivars.fUseUCI = fFALSE;
2041 	s_ivars.fUCI1 = fFALSE;
2042 	s_ivars.cPosCounter = 0;
2043 	s_ivars.cIPTime = 0;
2044 	s_ivars.aszEngine[0] = '\0';
2045 	s_ivars.aszPath[0] = '\0';
2046 	s_ivars.aszSuite[0] = '\0';
2047 	s_ivars.aszDBFile[0] = '\0';
2048 	s_ivars.aszUCIFile[0] = '\0';
2049 	s_ivars.fDBon = fFALSE;
2050 <a name="0"></a>	s_ivars.fUseSt = fFALSE;
2051 	s_ivars.tmWaitInit = 4000;			s_ivars.tmWaitPos = 1000;		<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	s_ivars.fFindInfo = fFALSE;
2052 	s_ivars.fLogOn = fFALSE;
2053 	s_ivars.fIgnoreDone = fFALSE;
2054 	s_ivars.fQuit = fFALSE;
2055 	s_ivars.fWaitAfterStart = fFALSE;
2056 	s_ivars.cMultiST=1;
2057 	s_ivars.fStopPly=fFALSE;
2058 	s_ivars.fStopScore=fFALSE;
2059 	s_ivars.fStopAnalysis=fFALSE;
2060 	strcpy(aszLanguage, "English");
2061 	for (isz = 1, iszArg = 0; isz &lt; argc; isz++) {</b></font>
2062 		char * sz = argv[isz];
2063 		switch (*sz++) {
2064 		case '/':
2065 		case '-':
2066 			switch (*sz++) {
2067 			case 'a':
2068 				s_ivars.fAnalyze = fTRUE;
2069 				break;
2070 			case 'u':
2071 				s_ivars.fSetboard = fTRUE;
2072 				break;
2073 			case 'd':
2074 				s_ivars.fDump = fTRUE;
2075 				break;
2076 			case 'i':
2077 				s_ivars.fFindInfo = fTRUE;
2078 				break;
2079 			case 'l':
2080 				if (*sz != '\0')
2081 					strcpy(aszLanguage, sz);
2082 				else if (isz + 1 == argc)
2083 					VUsage();
2084 				else if ((argv[++isz][0] != '-') &amp;&amp;
2085 					(argv[isz][0] != '/'))
2086 					strcpy(aszLanguage, argv[isz]);
2087 				else
2088 					VUsage();
2089 				break;
2090 			case 's':
2091 				if (*sz != '\0') {
2092 					if (!isdigit(*sz))
2093 						VUsage();
2094 					s_ivars.cSkip = atoi(sz);
2095 				} else if (isz + 1 == argc)
2096 					VUsage();
2097 				else if (isdigit(argv[++isz][0]))
2098 					s_ivars.cSkip = atoi(argv[isz]);
2099 				else
2100 					VUsage();
2101 				break;
2102 			case 't':
2103 				s_ivars.fUseSt = fTRUE;
2104 				break;
2105 			case 'w':
2106 				if (*sz != '\0') {
2107 					if (!isdigit(*sz))
2108 						VUsage();
2109 					s_ivars.tmWaitInit = atoi(sz) * 1000;
2110 				} else if (isz + 1 == argc)
2111 					VUsage();
2112 				else if (isdigit(argv[++isz][0]))
2113 					s_ivars.tmWaitInit = atoi(argv[isz]) * 1000;
2114 				else
2115 					VUsage();
2116 				break;
2117 			case 'e':
2118 				if (*sz != '\0') {
2119 					if (!isdigit(*sz))
2120 						VUsage();
2121 					s_ivars.fWaitAfterStart = fTRUE;
2122 					s_ivars.cWaitAfterStart = atoi(sz) * 1000;
2123 				} else if (isz + 1 == argc)
2124 					VUsage();
2125 				else if (isdigit(argv[++isz][0])) {
2126 					s_ivars.fWaitAfterStart = fTRUE;
2127 					s_ivars.cWaitAfterStart = atoi(argv[isz]) * 1000;
2128 				}
2129 				else
2130 					VUsage();
2131 				break;
2132 			case 'g':
2133 				if (*sz != '\0') {
2134 					if (!isdigit(*sz))
2135 						VUsage();
2136 					s_ivars.cPlys = atoi(sz);
2137 					if (s_ivars.cPlys&gt;0) {
2138 						s_ivars.fStopPly = fTRUE;
2139 					}
2140 				} else if (isz + 1 == argc)
2141 					VUsage();
2142 				else if (isdigit(argv[++isz][0])) {
2143 					s_ivars.cPlys = atoi(argv[isz]);
2144 					if (s_ivars.cPlys&gt;0) {
2145 						s_ivars.fStopPly = fTRUE;
2146 					}
2147 				}
2148 				else
2149 					VUsage();
2150 				break;
2151 			case 'h':
2152 				if (*sz != '\0') {
2153 					if (!isdigit(*sz))
2154 						VUsage();
2155 					s_ivars.cScore = atoi(sz);
2156 					if (s_ivars.cScore&gt;0) {
2157 						s_ivars.fStopScore = fTRUE;
2158 					}
2159 				} else if (isz + 1 == argc)
2160 					VUsage();
2161 				else if (isdigit(argv[++isz][0])) {
2162 					s_ivars.cScore = atoi(argv[isz]);
2163 					if (s_ivars.cScore&gt;0) {
2164 						s_ivars.fStopScore = fTRUE;
2165 					}
2166 				}
2167 				else
2168 					VUsage();
2169 				break;
2170 			case 'n':
2171 				if (*sz != '\0') {
2172 					if (!isdigit(*sz))
2173 						VUsage();
2174 					s_ivars.cMultiST = atoi(sz) * 1000;
2175 				} else if (isz + 1 == argc)
2176 					VUsage();
2177 				else if (isdigit(argv[++isz][0]))
2178 					s_ivars.cMultiST = atoi(argv[isz]) * 1000;
2179 				else
2180 					VUsage();
2181 				break;
2182 			case 'x':
2183 				if (*sz != '\0') {
2184 					if (!isdigit(*sz))
2185 						VUsage();
2186 					s_ivars.tmWaitPos = atoi(sz) * 1000;
2187 				} else if (isz + 1 == argc)
2188 					VUsage();
2189 				else if (isdigit(argv[++isz][0]))
2190 					s_ivars.tmWaitPos = atoi(argv[isz]) * 1000;
2191 				else
2192 					VUsage();
2193 				break;
2194 			case 'p':
2195 				if (*sz != '\0') {
2196 					strcpy(s_ivars.aszPath,sz);
2197 				}
2198 				else {
2199 					if (isz + 1 == argc) {
2200 						VUsage();
2201 					}
2202 					else {
2203 						if ((argv[++isz][0] != '-') &amp;&amp; (argv[isz][0] != '/')) {
2204 							strcpy(s_ivars.aszPath,argv[isz]);
2205 						}
2206 						else {
2207 							VUsage();
2208 						}
2209 					}
2210 				}
2211 				i=strlen(s_ivars.aszPath);
2212 				if ((s_ivars.aszPath[i]) != 92) {
2213 					s_ivars.aszPath[i]=92;
2214 					s_ivars.aszPath[i+1]=0;
2215 				}
2216 				break;
2217 			case 'c':
2218 				if (*sz != '\0') {
2219 					strcpy(s_ivars.aszUCIFile,sz);
2220 				}
2221 				else {
2222 					if (isz + 1 == argc) {
2223 						VUsage();
2224 					}
2225 					else {
2226 						if ((argv[++isz][0] != '-') &amp;&amp; (argv[isz][0] != '/')) {
2227 							strcpy(s_ivars.aszUCIFile,argv[isz]);
2228 						}
2229 						else {
2230 							VUsage();
2231 						}
2232 					}
2233 				}
2234 				s_ivars.fUseUCI=fTRUE;
2235 				s_ivars.UCIoptions=0;
2236 				s_ivars.cIPTime=4;
2237 				ReadUCIOptions();
2238 				break;
2239 			case 'f':
2240 				if (*sz != '\0') {
2241 					strcpy(s_ivars.aszLogFile,sz);
2242 				}
2243 				else {
2244 					if (isz + 1 == argc) {
2245 						VUsage();
2246 					}
2247 					else {
2248 						if ((argv[++isz][0] != '-') &amp;&amp; (argv[isz][0] != '/')) {
2249 							strcpy(s_ivars.aszLogFile,argv[isz]);
2250 						}
2251 						else {
2252 							VUsage();
2253 						}
2254 					}
2255 				}
2256 				s_ivars.fLogOn=fTRUE;
2257 				break;
2258 			case 'b':
2259 				if (*sz != '\0') {
2260 					strcpy(s_ivars.aszDBFile,sz);
2261 				}
2262 				else {
2263 					if (isz + 1 == argc) {
2264 						VUsage();
2265 					}
2266 					else {
2267 						if ((argv[++isz][0] != '-') &amp;&amp; (argv[isz][0] != '/')) {
2268 							strcpy(s_ivars.aszDBFile,argv[isz]);
2269 						}
2270 						else {
2271 							VUsage();
2272 						}
2273 					}
2274 				}
2275 				s_ivars.fDBon=fTRUE;
2276 				break;
2277 			case 'y':
2278 				s_ivars.fInternalTime = fTRUE;
2279 				break;
2280 			case 'j':
2281 				s_ivars.fUCI1 = fTRUE;
2282 				break;
2283 			case 'v':
2284 				if (*sz != '\0') {
2285 					if ((sz[1] != 'c') &amp;&amp; (sz[1] != 's') &amp;&amp; (sz[01] != 't') &amp;&amp; (sz[1] != 'm')) {
2286 						VUsage();
2287 						break;
2288 					}
2289 					if (sz[1]=='c') s_ivars.cIPTime=1;
2290 					else if (sz[1]=='s') s_ivars.cIPTime=2;
2291 					else if (sz[1]=='m') s_ivars.cIPTime=4;
2292 					else s_ivars.cIPTime=3;
2293 				} else if (isz + 1 == argc)
2294 					VUsage();
2295 				else {
2296 					isz++;
2297 					sz=argv[isz];
2298 					if ((sz[0] != 'c') &amp;&amp; (sz[0] != 's') &amp;&amp; (sz[0] != 't') &amp;&amp; (sz[0] != 'm')) {
2299 						VUsage();
2300 						break;
2301 					}
2302 					if (sz[0]=='c') s_ivars.cIPTime=1;
2303 					else if (sz[0]=='s') s_ivars.cIPTime=2;
2304 					else if (sz[0]=='m') s_ivars.cIPTime=4;
2305 					else s_ivars.cIPTime=3;
2306 				}
2307 				break;
2308 			case 'o':
2309 				s_ivars.fPureProt1=fTRUE;
2310 				break;
2311 			case 'z':
2312 				s_ivars.fIgnoreDone=fTRUE;
2313 				break;
2314 			default:
2315 				VUsage();
2316 			}
2317 			break;
2318 		default:
2319 			switch (iszArg++) {
2320 			case 0:
2321 				strcpy(s_ivars.aszEngine, argv[isz]);
2322 				break;
2323 			case 1:
2324 				if ((s_ivars.pfI = fopen(argv[isz], "r")) == NULL) {
2325 					perror(argv[isz]);
2326 					exit(1);
2327 				}
2328 				s_ivars.cPosAbs=fGetAbsPos(argv[isz]);
2329 				strcpy(s_ivars.aszSuite, argv[isz]);
2330 				break;
2331 			case 2:
2332 				s_ivars.tmPerMove = atoi(argv[isz]) * 1000;
2333 				break;
2334 			default:
2335 				VUsage();
2336 			}
2337 			break;
2338 		}
2339 	}
2340 	if (iszArg &lt; 3)
2341 		VUsage();
2342 	if ((s_ivars.plang = PlangFindLang(aszLanguage)) == NULL)
2343 		VUsage();
2344 	if (!FStartProcess(&amp;s_ivars.cp, s_ivars.aszEngine, s_ivars.aszPath))
2345 		VDisplayLastError("Can't start engine");
2346 	else s_ivars.fEngineStarted = fTRUE;
2347 	if (s_ivars.fUseSt)					s_ivars.tmWaitInit = 0;
2348 	if (s_ivars.fLogOn) {
2349 		s_ivars.LOGDatei.open(s_ivars.aszLogFile,ios::trunc | ios::out | ios::in);
2350 		s_ivars.LOGDatei.seekp(0,ios::beg);
2351 		s_ivars.fLogOpen=fTRUE;
2352 	}
2353 	s_ivars.plangEnglish = PlangFindLang("English");
2354 	Assert(s_ivars.plangEnglish != NULL);
2355 	s_ivars.heventStdinReady = CreateEvent(NULL, FALSE, FALSE, NULL);
2356 	s_ivars.heventStdinAck = CreateEvent(NULL, FALSE, FALSE, NULL);
2357 	s_ivars.heventStdinPing = CreateEvent(NULL, FALSE, FALSE, NULL);
2358 	CreateThread(NULL, 0, DwInput, NULL, 0, &amp;dw);
2359 	if (s_ivars.fWaitAfterStart) {
2360 		Sleep(s_ivars.cWaitAfterStart);
2361 	}
2362 	VProcess();
2363 	if (!s_ivars.fFindInfo)
2364 		VDumpResults();
2365 	VSendToEngine("quit");
2366 	s_ivars.fQuit = fTRUE;
2367 	VKillTime(2000);
2368 	if (s_ivars.fLogOpen) s_ivars.LOGDatei.close();
2369 //	DestroyChildProcess(&amp;s_ivars.cp);		return 1;
2370 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
