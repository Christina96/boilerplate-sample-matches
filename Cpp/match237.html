<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for main_1.c &amp; Epd2wb.cpp</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for main_1.c &amp; Epd2wb.cpp
      </h3>
<h1 align="center">
        0.8%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>main_1.c (3.2876713%)<th>Epd2wb.cpp (0.4643963%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(476-487)<td><a href="#" name="0">(3100-3110)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>main_1.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;signal.h&gt;
#include "defs.h"
#include "data.h"
#include "protos.h"
#include &lt;sys/timeb.h&gt;
BOOL ftime_ok = FALSE;  int get_ms()
{
	struct timeb timebuffer;
	ftime(&amp;timebuffer);
	if (timebuffer.millitm != 0)
		ftime_ok = TRUE;
	return (timebuffer.time * 1000) + timebuffer.millitm;
}
int main()
{
	int computer_side;
	char s[256];
	int m;
	printf("\n");
	printf("Tom Kerrigan's Simple Chess Program (TSCP)\n");
	printf("version 1.81, 2/5/03\n");
	printf("Copyright 1997 Tom Kerrigan\n");
	printf("\n");
	printf("\"help\" displays a list of commands.\n");
	printf("\n");
	init_hash();
	init_board();
	open_book();
	gen();
	computer_side = EMPTY;
	max_time = 1 &lt;&lt; 25;
	max_depth = 4;
	for (;;) {
		if (side == computer_side) {  			
			think(1);
			if (!pv[0][0].u) {
				printf("(no legal moves)\n");
				computer_side = EMPTY;
				continue;
			}
			printf("Computer's move: %s\n", move_str(pv[0][0].b));
			makemove(pv[0][0].b);
			ply = 0;
			gen();
			print_result();
			continue;
		}
		printf("tscp&gt; ");
		if (scanf("%s", s) == EOF)
			return 0;
		if (!strcmp(s, "on")) {
			computer_side = side;
			continue;
		}
		if (!strcmp(s, "off")) {
			computer_side = EMPTY;
			continue;
		}
		if (!strcmp(s, "st")) {
			scanf("%d", &amp;max_time);
			max_time *= 1000;
			max_depth = 32;
			continue;
		}
		if (!strcmp(s, "sd")) {
			scanf("%d", &amp;max_depth);
			max_time = 1 &lt;&lt; 25;
			continue;
		}
		if (!strcmp(s, "undo")) {
			if (!hply)
				continue;
			computer_side = EMPTY;
			takeback();
			ply = 0;
			gen();
			continue;
		}
		if (!strcmp(s, "new")) {
			computer_side = EMPTY;
			init_board();
			gen();
			continue;
		}
		if (!strcmp(s, "d")) {
			print_board();
			continue;
		}
		if (!strcmp(s, "bench")) {
			computer_side = EMPTY;
			bench();
			continue;
		}
		if (!strcmp(s, "bye")) {
			printf("Share and enjoy!\n");
			break;
		}
		if (!strcmp(s, "xboard")) {
			xboard();
			break;
		}
		if (!strcmp(s, "help")) {
			printf("on - computer plays for the side to move\n");
			printf("off - computer stops playing\n");
			printf("st n - search for n seconds per move\n");
			printf("sd n - search n ply per move\n");
			printf("undo - takes back a move\n");
			printf("new - starts a new game\n");
			printf("d - display the board\n");
			printf("bench - run the built-in benchmark\n");
			printf("bye - exit the program\n");
			printf("xboard - switch to XBoard mode\n");
			printf("Enter moves in coordinate notation, e.g., e2e4, e7e8Q\n");
			continue;
		}
		m = parse_move(s);
		if (m == -1 || !makemove(gen_dat[m].m.b))
			printf("Illegal move.\n");
		else {
			ply = 0;
			gen();
			print_result();
		}
	}
	close_book();
	return 0;
}
int parse_move(char *s)
{
	int from, to, i;
	if (s[0] &lt; 'a' || s[0] &gt; 'h' ||
			s[1] &lt; '0' || s[1] &gt; '9' ||
			s[2] &lt; 'a' || s[2] &gt; 'h' ||
			s[3] &lt; '0' || s[3] &gt; '9')
		return -1;
	from = s[0] - 'a';
	from += 8 * (8 - (s[1] - '0'));
	to = s[2] - 'a';
	to += 8 * (8 - (s[3] - '0'));
	for (i = 0; i &lt; first_move[1]; ++i)
		if (gen_dat[i].m.b.from == from &amp;&amp; gen_dat[i].m.b.to == to) {
			if (gen_dat[i].m.b.bits &amp; 32)
				switch (s[4]) {
					case 'N':
						return i;
					case 'B':
						return i + 1;
					case 'R':
						return i + 2;
					default:  						return i + 3;
				}
			return i;
		}
	return -1;
}
char *move_str(move_bytes m)
{
	static char str[6];
	char c;
	if (m.bits &amp; 32) {
		switch (m.promote) {
			case KNIGHT:
				c = 'n';
				break;
			case BISHOP:
				c = 'b';
				break;
			case ROOK:
				c = 'r';
				break;
			default:
				c = 'q';
				break;
		}
		sprintf(str, "%c%d%c%d%c",
				COL(m.from) + 'a',
				8 - ROW(m.from),
				COL(m.to) + 'a',
				8 - ROW(m.to),
				c);
	}
	else
		sprintf(str, "%c%d%c%d",
				COL(m.from) + 'a',
				8 - ROW(m.from),
				COL(m.to) + 'a',
				8 - ROW(m.to));
	return str;
}
void print_board()
{
	int i;
	printf("\n8 ");
	for (i = 0; i &lt; 64; ++i) {
		switch (color[i]) {
			case EMPTY:
				printf(" .");
				break;
			case LIGHT:
				printf(" %c", piece_char[piece[i]]);
				break;
			case DARK:
				printf(" %c", piece_char[piece[i]] + ('a' - 'A'));
				break;
		}
		if ((i + 1) % 8 == 0 &amp;&amp; i != 63)
			printf("\n%d ", 7 - ROW(i));
	}
	printf("\n\n   a b c d e f g h\n\n");
}
void xboard()
{
	int computer_side;
	char line[256], command[256];
	int m;
	int post = 0;
	signal(SIGINT, SIG_IGN);
	printf("\n");
	init_board();
	gen();
	computer_side = EMPTY;
	for (;;) {
		fflush(stdout);
		if (side == computer_side) {
			think(post);
			if (!pv[0][0].u) {
				computer_side = EMPTY;
				continue;
			}
			printf("move %s\n", move_str(pv[0][0].b));
			makemove(pv[0][0].b);
			ply = 0;
			gen();
			print_result();
			continue;
		}
		if (!fgets(line, 256, stdin))
			return;
		if (line[0] == '\n')
			continue;
		sscanf(line, "%s", command);
		if (!strcmp(command, "xboard"))
			continue;
		if (!strcmp(command, "new")) {
			init_board();
			gen();
			computer_side = DARK;
			continue;
		}
		if (!strcmp(command, "quit"))
			return;
		if (!strcmp(command, "force")) {
			computer_side = EMPTY;
			continue;
		}
		if (!strcmp(command, "white")) {
			side = LIGHT;
			xside = DARK;
			gen();
			computer_side = DARK;
			continue;
		}
		if (!strcmp(command, "black")) {
			side = DARK;
			xside = LIGHT;
			gen();
			computer_side = LIGHT;
			continue;
		}
		if (!strcmp(command, "st")) {
			sscanf(line, "st %d", &amp;max_time);
			max_time *= 1000;
			max_depth = 32;
			continue;
		}
		if (!strcmp(command, "sd")) {
			sscanf(line, "sd %d", &amp;max_depth);
			max_time = 1 &lt;&lt; 25;
			continue;
		}
		if (!strcmp(command, "time")) {
			sscanf(line, "time %d", &amp;max_time);
			max_time *= 10;
			max_time /= 30;
			max_depth = 32;
			continue;
		}
		if (!strcmp(command, "otim")) {
			continue;
		}
		if (!strcmp(command, "go")) {
			computer_side = side;
			continue;
		}
		if (!strcmp(command, "hint")) {
			think(0);
			if (!pv[0][0].u)
				continue;
			printf("Hint: %s\n", move_str(pv[0][0].b));
			continue;
		}
		if (!strcmp(command, "undo")) {
			if (!hply)
				continue;
			takeback();
			ply = 0;
			gen();
			continue;
		}
		if (!strcmp(command, "remove")) {
			if (hply &lt; 2)
				continue;
			takeback();
			takeback();
			ply = 0;
			gen();
			continue;
		}
		if (!strcmp(command, "post")) {
			post = 2;
			continue;
		}
		if (!strcmp(command, "nopost")) {
			post = 0;
			continue;
		}
		m = parse_move(line);
		if (m == -1 || !makemove(gen_dat[m].m.b))
			printf("Error (unknown command): %s\n", command);
		else {
			ply = 0;
			gen();
			print_result();
		}
	}
}
void print_result()
{
	int i;
	for (i = 0; i &lt; first_move[1]; ++i)
		if (makemove(gen_dat[i].m.b)) {
			takeback();
			break;
		}
	if (i == first_move[1]) {
		if (in_check(side)) {
			if (side == LIGHT)
				printf("0-1 {Black mates}\n");
			else
				printf("1-0 {White mates}\n");
		}
		else
			printf("1/2-1/2 {Stalemate}\n");
	}
	else if (reps() == 3)
		printf("1/2-1/2 {Draw by repetition}\n");
	else if (fifty &gt;= 100)
		printf("1/2-1/2 {Draw by fifty move rule}\n");
}
int bench_color[64] = {
	6, 1, 1, 6, 6, 1, 1, 6,
	1, 6, 6, 6, 6, 1, 1, 1,
	6, 1, 6, 1, 1, 6, 1, 6,
	6, 6, 6, 1, 6, 6, 0, 6,
	6, 6, 1, 0, 6, 6, 6, 6,
	6, 6, 0, 6, 6, 6, 0, 6,
	0, 0, 0, 6, 6, 0, 0, 0,
	0, 6, 0, 6, 0, 6, 0, 6
};
int bench_piece[64] = {
	6, 3, 2, 6, 6, 3, 5, 6,
	0, 6, 6, 6, 6, 0, 0, 0,
	6, 0, 6, 4, 0, 6, 1, 6,
	6, 6, 6, 1, 6, 6, 1, 6,
	6, 6, 0, 0, 6, 6, 6, 6,
	6, 6, 0, 6, 6, 6, 0, 6,
	0, 0, 4, 6, 6, 0, 2, 0,
	3, 6, 2, 6, 3, 6, 5, 6
};
void bench()
{
	int i;
	int t[3];
	double nps;
	close_book();
	for (i = 0; i &lt; 64; ++i) {
<a name="0"></a>		color[i] = bench_color[i];
		piece[i] = bench_piece[i];
	}
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	side = LIGHT;
	xside = DARK;
	castle = 0;
	ep = -1;
	fifty = 0;
	ply = 0;
	hply = 0;
	set_hash();
	print_board();
	max_time = 1 &lt;&lt; 25;
	max_depth = 5;
	for (i = 0; i &lt; 3; ++i) {</b></font>
		think(1);
		t[i] = get_ms() - start_time;
		printf("Time: %d ms\n", t[i]);
	}
	if (t[1] &lt; t[0])
		t[0] = t[1];
	if (t[2] &lt; t[0])
		t[0] = t[2];
	printf("\n");
	printf("Nodes: %d\n", nodes);
	printf("Best time: %d ms\n", t[0]);
	if (!ftime_ok) {
		printf("\n");
		printf("Your compiler's ftime() function is apparently only accurate\n");
		printf("to the second. Please change the get_ms() function in main.c\n");
		printf("to make it more accurate.\n");
		printf("\n");
		return;
	}
	if (t[0] == 0) {
		printf("(invalid)\n");
		return;
	}
	nps = (double)nodes / (double)t[0];
	nps *= 1000.0;
	printf("Nodes per second: %d (Score: %.3f)\n", (int)nps, (float)nps/243169.0);
	init_board();
	open_book();
	gen();
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>Epd2wb.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include &lt;iostream&gt;
#include &lt;ios&gt;
#include &lt;fstream&gt;
#include "epd2wb.h"
#include &lt;stdarg.h&gt;
#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;
#include &lt;signal.h&gt;
#include &lt;winbase.h&gt;
using namespace std;
#define	modeFEATURE_TIMEOUT		0
#define	modeFEATURE_NOTIMEOUT	1
#define	modeWAITING				2
#define	modeTESTING				3
#define uciDEBUG                0
typedef struct tagCHILDPROC {
	HANDLE hProcess;
	DWORD pid;
	HANDLE hTo;
	HANDLE hFrom;
}	CHILDPROC, * PCHILDPROC;
typedef	unsigned long	TM;
typedef struct tagSearchInfo {
	char		 aszLastPV[512];
	int			 cLastDepth;
	int			 cSolveDepth;
	int          cLastEval;
	unsigned int cSolveTime;
} SINFO;
#define	isolMAX		1800
#define	cbINPUT_BUF	4096
typedef char Str100[100];
typedef	struct	tagIVARS {
	HANDLE	heventStdinReady;		HANDLE	heventStdinAck;			HANDLE  heventStdinPing;    	char	aszEngine[256];			char    aszPath[256];       	char    aszLogFile[256];    	char    aszDBFile[256];     	char	aszSuite[256];			char    aszUCIFile[256];    	char	aszFen[256];			char	aszId[256];				char	aszAnswer[256];			char	aszAvoid[256];			char    aszOutput[cbINPUT_BUF]; 	Str100  aszFEN[isolMAX];		Str100  aszName[isolMAX];   	Str100  aszSol[isolMAX];    	Str100  UCIoption[100];     	Str100  UCIvalue[100];      	int     UCIoptionstate[100];	int UCIoptions;             	int	movStart;					int	plyFifty;					int	mode;						CHILDPROC	cp;					FILE *	pfI;					fstream LOGDatei;				fstream DBDatei;				int	cPing;						BOOL	fCorrectAnswer;			int cPosAbs;                	int cWaitAfterStart;        	int cPosCounter;            	int	cSolved;					int	cFailed;					int	cError;						int cIPTime;                	int cPlys;                  	int cScore;                 	int cMultiST;               	int	argsol[isolMAX];			SINFO apsInfo[isolMAX];     	char	aszInBuf[					cbINPUT_BUF];
	int	cSkip;						int	cLine;						BOOL	fError;					BOOL	fEngineStarted;			BOOL	fPing;					BOOL	fSetboard;				BOOL	fAnalyze;				BOOL	fColor;					BOOL    fPureProt1;         	BOOL	fUsermove;				BOOL	fDump;					BOOL	fUseSt;					BOOL    fUseUCI;            	BOOL    fUCI1;					BOOL    fInternalTime;      	BOOL	fFindInfo;				BOOL    fIgnoreDone;        	BOOL    fLogOn;             	BOOL    fLogOpen;				BOOL    fDBon;					BOOL    fWaitAfterStart;    	BOOL    fStopPly;           	BOOL    fStopScore;         	BOOL	fQuit;					BOOL    fStopAnalysis;      	TM	tmEnd;						TM	tmPerMove;					TM	tmFoundIn;					TM	tmWaitInit;					TM  tmWaitPos;					TM  tmStartPos;             	TM	tmStart;					PLANG	plang;					PLANG	plangEnglish;		}	IVARS;
IVARS	s_ivars;	
unsigned TmNow(void)
{
	return GetTickCount();
}
#define	cbLINE	80	
static char const s_aszModule[] = __FILE__;
void VWriteLogAndOutput()
{
	if (s_ivars.fLogOpen) {
		s_ivars.LOGDatei.write(s_ivars.aszOutput,strlen(s_ivars.aszOutput));
		s_ivars.LOGDatei.seekp(0,ios::end);
	}
	printf("%s",s_ivars.aszOutput);
}
int	CszVectorizeEpd(char * sz, char * rgsz[], int * pibSecond);
void VWriteEmpty()
{	
	strcpy(s_ivars.aszOutput,"\n");
	if (s_ivars.fLogOpen) {
		s_ivars.LOGDatei.write(s_ivars.aszOutput,strlen(s_ivars.aszOutput));
		s_ivars.LOGDatei.seekp(0,ios::end);
	}
	printf("%s",s_ivars.aszOutput);
}
#include &lt;ctype.h&gt;
void VCompact(char * szIn, char * szOut)
{
	for (; *szIn; szIn++)
		switch (*szIn) {
		case 'x':
		case '-':
		case '+':
		case '=':
		case ':':
		case '#':
		case '?':
		case '!':
			break;
		default:
			*szOut++ = *szIn;
			break;
		}
	*szOut = '\0';
}
#define	rnkNIL	-1				#define	filNIL	-1				#define	pcNIL	-1				
typedef	struct	tagSQ {
	int	rnk;
	int	fil;
}	SQ, * PSQ;
typedef	struct	tagMOV {
	SQ	sqFrom;						SQ	sqTo;						int	pcFrom;						int	pcTo;					}	MOV, * PMOV;
int PcFromCh(int ch, PLANG plang, BOOL fCaseSensitive)
{
	int	pc;
	for (pc = pcPAWN; pc &lt;= pcKING; pc++) {
		if (ch == plang-&gt;argbPc[pc])
			return pc;
		if ((!fCaseSensitive) &amp;&amp; (tolower(ch) == tolower(plang-&gt;argbPc[pc])))
			return pc;
	}
	return pcNIL;
}
int fGetAbsPos(char * sz)
{
   FILE *epdfile;
   int npos = 0, nslash = 0, ch;
   epdfile = fopen(sz, "r");
   do
   {  ch = getc(epdfile);
      if (ch == '/')
         nslash++;
      else
      if ((ch == '\n' || ch == EOF) &amp;&amp; nslash &gt;= 7)
      {  npos++;
         nslash = 0;
      }
   }while(ch != EOF);
   fclose(epdfile);
   return npos;
}
void ReadUCIOptions(void)
{
	FILE *ucifile;
	char ch;
	char line[256];
	char ucioption[256];
	char * argsz[256];
	int pibsecond,i,j,k;
	long slen=0;
	bool found;
	ucifile=fopen(s_ivars.aszUCIFile,"r");
	do {
		ch=getc(ucifile);
		if ((ch == '\n') || (ch == EOF)) {
			line[slen]=0;
			slen=CszVectorizeEpd(line,argsz,&amp;pibsecond);
			if (!strcmp("option",argsz[0])) {
				strcpy(ucioption,argsz[1]);
				k=2;
				while (strcmp(argsz[k],"value")) {
					strcat(ucioption," ");
					strcat(ucioption,argsz[k]);
					k++;
				}
				i=0;
				found=false;
				while ((i&lt;s_ivars.UCIoptions) &amp;&amp; (!found)) {
					if (!strcmp(s_ivars.UCIoption[i],ucioption)) {
						found=true;
						sprintf(s_ivars.UCIvalue[i],"\0");
						for (j=k+1;j&lt;slen;j++) {
							if (j&gt;(k+1)) {
								strcat(s_ivars.UCIvalue[i]," ");
							}
							strcat(s_ivars.UCIvalue[i],argsz[j]);
						}
						s_ivars.UCIoptionstate[i]|=1;
					} else {
						i++;
					}
				}
				if (!found) {
					i=s_ivars.UCIoptions;
					strcpy(s_ivars.UCIoption[i],ucioption);
					strcpy(s_ivars.UCIvalue[i],"\0");
					for (j=k+1;j&lt;slen;j++) {
						if (j&gt;(k+1)) {
							strcat(s_ivars.UCIvalue[i]," ");
						}
						strcat(s_ivars.UCIvalue[i],argsz[j]);
					}
					s_ivars.UCIoptionstate[i]=1;
					s_ivars.UCIoptions++;
				}
			}
			slen=0;
		} else {
			line[slen]=ch;
			slen++;
		}
	} while(ch != EOF);
	fclose(ucifile);
}
BOOL FGetRnk(char * sz, int * prnk)
{
	if ((sz[0] &lt; '1') || (sz[0] &gt; '8'))
		return fFALSE;
	*prnk = sz[0] - '1';
	return fTRUE;
}
BOOL FGetFil(char * sz, int * pfil)
{
	if ((sz[0] &lt; 'a') || (sz[0] &gt; 'h'))
		return fFALSE;
	*pfil = sz[0] - 'a';
	return fTRUE;
}
BOOL FGetCoord(char * sz, PSQ psq)
{
	SQ	sq;			
	if (!FGetFil(sz, &amp;sq.fil))
		return fFALSE;
	if (!FGetRnk(sz + 1, &amp;sq.rnk))
		return fFALSE;
	*psq = sq;
	return fTRUE;
}
int IsqFromSq(PSQ psq)
{
	return psq-&gt;rnk * 8 + psq-&gt;fil;
}
BOOL FDecipher(PBD pbd, PLANG plang, char * szMov, PMOV pmov)
{
	if ((!strcmp(szMov, "OO")) || (!strcmp(szMov, "oo")) || (!strcmp(szMov, "00")))
		szMov = (pbd-&gt;coMove == coWHITE) ? "e1g1" : "e8g8";
	else if ((!strcmp(szMov, "OOO")) || (!strcmp(szMov, "ooo")) || (!strcmp(szMov, "000")))
		szMov = (pbd-&gt;coMove == coWHITE) ? "e1c1" : "e8c8";
	pmov-&gt;sqFrom.rnk = pmov-&gt;sqTo.rnk = rnkNIL;
	pmov-&gt;sqFrom.fil = pmov-&gt;sqTo.fil = filNIL;
	pmov-&gt;pcTo = pcNIL;
	if ((pbd-&gt;coMove==coBLACK) &amp;&amp; (strlen(szMov)&gt;=5) &amp;&amp; (isdigit(szMov[2])) &amp;&amp; (isdigit(szMov[4])))
	{
		if ((pmov-&gt;pcFrom = PcFromCh(*szMov, plang, fFALSE)) != pcNIL)				szMov++;
	}
	else
	{
		if ((pmov-&gt;pcFrom = PcFromCh(*szMov, plang, fTRUE)) != pcNIL)
			szMov++;
	}
	if (FGetCoord(szMov, &amp;pmov-&gt;sqFrom)) {
		szMov += 2;
		if (FGetCoord(szMov, &amp;pmov-&gt;sqTo)) {
			int	pcFrom;
			szMov += 2;
			pcFrom = pbd-&gt;argpcco[IsqFromSq(&amp;pmov-&gt;sqFrom)].pc;
			if (pcFrom == pcNIL)					return fFALSE;
			if ((pmov-&gt;pcFrom != pcNIL) &amp;&amp; (pcFrom != pmov-&gt;pcFrom))
				return fFALSE;
			pmov-&gt;pcFrom = pcFrom;
lblPromote:	if ((pmov-&gt;pcTo = PcFromCh(*szMov, plang, fFALSE)) != pcNIL) {
				szMov++;
				if ((pmov-&gt;pcFrom != pcNIL) &amp;&amp; (pmov-&gt;pcFrom != pcPAWN))
					return fFALSE;
				pmov-&gt;pcFrom = pcPAWN;
			}
			if (*szMov == '\0')
				return fTRUE;
		} else {
			pmov-&gt;sqTo = pmov-&gt;sqFrom;
			pmov-&gt;sqFrom.rnk = rnkNIL;
			pmov-&gt;sqFrom.fil = filNIL;
			if (pmov-&gt;pcFrom == pcNIL)
				pmov-&gt;pcFrom = pcPAWN;
			goto lblPromote;
		}
	} else if (FGetFil(szMov, &amp;pmov-&gt;sqFrom.fil)) {
		if (pmov-&gt;pcFrom == pcNIL)
			pmov-&gt;pcFrom = pcPAWN;
lblTo:	szMov++;
		if (FGetCoord(szMov, &amp;pmov-&gt;sqTo)) {
			szMov += 2;
			goto lblPromote;
		}
	} else if (FGetRnk(szMov, &amp;pmov-&gt;sqFrom.rnk)) {
		if ((pmov-&gt;pcFrom == pcNIL) || (pmov-&gt;pcFrom == pcPAWN))
			return fFALSE;
		goto lblTo;
	}
	return fFALSE;
}
BOOL FCompare(PMOV pmovTry, PMOV pmovAnswer)
{
	if (pmovTry-&gt;sqTo.rnk != pmovAnswer-&gt;sqTo.rnk)
		return fFALSE;
	if (pmovTry-&gt;sqTo.fil != pmovAnswer-&gt;sqTo.fil)
		return fFALSE;
	if (pmovTry-&gt;pcTo != pmovAnswer-&gt;pcTo)
		return fFALSE;
	if ((pmovTry-&gt;sqFrom.rnk != rnkNIL) &amp;&amp;
		(pmovAnswer-&gt;sqFrom.rnk != rnkNIL) &amp;&amp;
		(pmovTry-&gt;sqFrom.rnk != pmovAnswer-&gt;sqFrom.rnk))
		return fFALSE;
	if ((pmovTry-&gt;sqFrom.fil != filNIL) &amp;&amp;
		(pmovAnswer-&gt;sqFrom.fil != filNIL) &amp;&amp;
		(pmovTry-&gt;sqFrom.fil != pmovAnswer-&gt;sqFrom.fil))
		return fFALSE;
	if ((pmovTry-&gt;pcFrom != pcNIL) &amp;&amp; (pmovAnswer-&gt;pcFrom != pcNIL) &amp;&amp;
		(pmovTry-&gt;pcFrom != pmovAnswer-&gt;pcFrom))
		return fFALSE;
	return fTRUE;
}
BOOL FCheckAnswer(char * szFen, char * szTry, char * szAnswer,
	PLANG plangTry, PLANG plangAnswer)
{
	char	aszAnswer[32];
	char	aszTry[32];
	MOV	movTry;
	MOV	movAnswer;
	BD	bd;
	VCompact(szTry, aszTry);
	VCompact(szAnswer, aszAnswer);
	if ((plangTry == plangAnswer) &amp;&amp; (!strcmp(szAnswer, szTry)))
		return fTRUE;		if (!FFenToBd(szFen, &amp;bd))					return fFALSE;						if (!FDecipher(&amp;bd, plangTry, aszTry, &amp;movTry))
		return fFALSE;
	if (!FDecipher(&amp;bd, plangAnswer, aszAnswer, &amp;movAnswer))
		return fFALSE;
	if (FCompare(&amp;movTry, &amp;movAnswer))
		return fTRUE;
	return fFALSE;
}
void VAssertFailed(const char * szMod, int iLine)
{
	sprintf(s_ivars.aszOutput,"Assert Failed: %s+%d\n", szMod, iLine);
	VWriteLogAndOutput();
	exit(1);
}
#define	Assert(cond)		if (!(cond)) VAssertFailed(s_aszModule, __LINE__)
void VDisplayLastError(char * sz)
{
	int	len;
	char	aszBuf[512];
	DWORD	dw = GetLastError();
	if (!s_ivars.fQuit) {
		len = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,
			NULL, dw, LANG_NEUTRAL, aszBuf, sizeof(aszBuf), NULL);
		if (len &gt; 0) {
			fprintf(stderr, "%s: %s", sz, aszBuf);
			exit(1);
		}
		fprintf(stderr, "%s: error = %ld\n", sz, dw);
	}
	exit(1);
}
void DestroyChildProcess(PCHILDPROC pcp)
{
	CloseHandle(pcp-&gt;hTo);
    if (pcp-&gt;hFrom)
		CloseHandle(pcp-&gt;hFrom);
    CloseHandle(pcp-&gt;hProcess);
}
BOOL FStartProcess(PCHILDPROC pcp, char * szEngine, char * szPath)
{
	HANDLE	hChildStdinRd;
	HANDLE	hChildStdinWr;
	HANDLE	hChildStdoutRd;
	HANDLE	hChildStdoutWr;
	HANDLE	hChildStdinWrDup;
	HANDLE	hChildStdoutRdDup;
	PROCESS_INFORMATION	piProcInfo;
	STARTUPINFO	siStartInfo;
	SECURITY_ATTRIBUTES saAttr;
	char szEngineFull[256];
	saAttr.nLength = sizeof(SECURITY_ATTRIBUTES);
	saAttr.bInheritHandle = TRUE;
	saAttr.lpSecurityDescriptor = NULL;
	if (!CreatePipe(&amp;hChildStdoutRd, &amp;hChildStdoutWr, &amp;saAttr, 0))
		return fFALSE;
	if (!DuplicateHandle(GetCurrentProcess(), hChildStdoutRd,
		GetCurrentProcess(), &amp;hChildStdoutRdDup, 0,
		FALSE, DUPLICATE_SAME_ACCESS))
		return fFALSE;
	CloseHandle(hChildStdoutRd);
	if (!CreatePipe(&amp;hChildStdinRd, &amp;hChildStdinWr, &amp;saAttr, 0))
		return fFALSE;
	if (!DuplicateHandle(GetCurrentProcess(), hChildStdinWr,
		GetCurrentProcess(), &amp;hChildStdinWrDup, 0, FALSE,
		DUPLICATE_SAME_ACCESS))
		return fFALSE;
	CloseHandle(hChildStdinWr);
	siStartInfo.cb = sizeof(STARTUPINFO);
	siStartInfo.lpReserved = NULL;
	siStartInfo.lpDesktop = NULL;
	siStartInfo.lpTitle = NULL;
	siStartInfo.dwFlags = STARTF_USESTDHANDLES;
	siStartInfo.cbReserved2 = 0;
	siStartInfo.lpReserved2 = NULL;
	siStartInfo.hStdInput = hChildStdinRd;
	siStartInfo.hStdOutput = hChildStdoutWr;
	siStartInfo.hStdError = hChildStdoutWr;
	strcpy(szEngineFull,szPath);
	strcat(szEngineFull,szEngine);
	if (strlen(szPath)==0) szPath=NULL;
	if (!CreateProcess(NULL, szEngineFull, NULL, NULL, TRUE,
		DETACHED_PROCESS | CREATE_NEW_PROCESS_GROUP,
		NULL, szPath, &amp;siStartInfo, &amp;piProcInfo))
		return fFALSE;
	CloseHandle(hChildStdinRd);
	CloseHandle(hChildStdoutWr);
	pcp-&gt;hProcess = piProcInfo.hProcess;
	pcp-&gt;pid = piProcInfo.dwProcessId;
	pcp-&gt;hFrom = hChildStdoutRdDup;
	pcp-&gt;hTo = hChildStdinWrDup;
	return fTRUE;
}
#if	0
void VDumpRaw(char * rgb, int cb)
{
	int	ib;
	char aszAddText[20];
	sprintf(s_ivars.aszOutput,"RAW: ");
	for (ib = 0; ib &lt; cb; ib++) {
		if ((rgb[ib] &lt; ' ') || (rgb[ib] &gt; '~')) {
			sprintf(aszAddText,"&lt;%02Xh&gt;", rgb[ib]);
			strcat(s_ivars.aszOutput,aszAddText);
		}
		else
			strcat(s_ivars.aszOutput,rgb[ib]);
	}
	strcat(s_ivars.aszOutput,'\n');
	VWriteLogAndOutput();
}
#endif
DWORD WINAPI DwInput(void * pv)
{
	char	argb[cbINPUT_BUF];
	int	ib = 0;
	int	cb = 0;
	int	ibOut = 0;
	for (;;) {
		WaitForSingleObject(s_ivars.heventStdinAck, INFINITE);
		for (;;) {
			Assert(ib &lt;= cb);
			if (ib == cb) {						DWORD	dw;
				if (!ReadFile(s_ivars.cp.hFrom,
					argb, sizeof(argb), &amp;dw, NULL))
					VDisplayLastError("Can't read from engine");
				ib = 0;
				cb = dw;
				Assert(cb &lt;= sizeof(argb));
			} else if ((argb[ib] == '\r') || (argb[ib] == '\n')) {
				if ((cb&lt;(ib+7)) || (strncmp(&amp;argb[ib+2],"    ",4)))					{
					if ((++ib &lt; cb) &amp;&amp; (argb[ib] == '\n'))
						ib++;
					s_ivars.aszInBuf[ibOut] = '\0';
					ibOut = 0;
					if (s_ivars.fDump) {
						sprintf(s_ivars.aszOutput,"LineCut&gt; %s\n", s_ivars.aszInBuf);
						VWriteLogAndOutput();
					}
					SetEvent(s_ivars.heventStdinReady);
					break;
				}
				else														{
					ib+=6;
					s_ivars.aszInBuf[ibOut++]=argb[ib++];
				}
			} else
				s_ivars.aszInBuf[ibOut++] = argb[ib++];
		}
	}
	return 0;
}
void VSendToEngine(const char * szFmt, ...)
{
	char	aszBuf[2048];
	va_list	lpArgPtr;
	int	cb;
	DWORD	dw;
	va_start(lpArgPtr, szFmt);
	vsprintf(aszBuf, szFmt, lpArgPtr);
	cb = strlen(aszBuf);
	aszBuf[cb++] = '\n';
	aszBuf[cb] = '\0';
	if (s_ivars.fDump) {
		sprintf(s_ivars.aszOutput,"&lt;%s", aszBuf);
		VWriteLogAndOutput();
	}
	if (!WriteFile(s_ivars.cp.hTo, aszBuf, cb, &amp;dw, NULL))
		VDisplayLastError("Can't write to engine");
}
int	CszVectorizeEpd(char * sz, char * rgsz[], int * pibSecond)
{
	int	i;
	int	csz;
	for (csz = 0, i = 0; sz[i]; i++)
		if (sz[i] != ' ') {
			BOOL	fInQuote;
			if (sz[i] == '"') {
				fInQuote = fTRUE;
				i++;
			} else
				fInQuote = fFALSE;
			if (csz == 1)
				*pibSecond = i;
			rgsz[csz++] = sz + i;
			for (;; i++) {
				if ((sz[i] == ' ') &amp;&amp; (!fInQuote))
					break;
				if ((sz[i] == '"') &amp;&amp; (fInQuote))
					break;
				if (sz[i] == '\0')
					break;
			}
			if (sz[i] == '\0')
				break;
			sz[i] = '\0';
		}
	if (csz &lt;= 1)
		*pibSecond = i;
	return csz;
}
int	CszVectorizeCmd(char * sz, char * rgsz[], int * pibSecond)
{
	int	i;
	int	csz;
	for (csz = 0, i = 0; sz[i]; i++)
		if ((sz[i] != ' ') &amp;&amp; (sz[i] != '\t')) {
			BOOL	fInQuote;
			if (csz == 1)
				*pibSecond = i;
			rgsz[csz++] = sz + i;
			fInQuote = fFALSE;
			for (;; i++) {
				if (((sz[i] == ' ') || (sz[i] == '\t')) &amp;&amp; (!fInQuote))
					break;
				if (sz[i] == '"')
					fInQuote = !fInQuote;
				if (sz[i] == '\0')
					break;
			}
			if (sz[i] == '\0')
				break;
			sz[i] = '\0';
		}
	return csz;
}
void VStrip(char * sz)
{
	int	i;
	for (i = 0; sz[i]; i++)
		if (sz[i] == '\n') {
			sz[i] = '\0';
			break;
		}
}
void VPrepEngine(void)
{
	VSendToEngine("new");
	VSendToEngine("level 0 5 0");
	VSendToEngine("post");
	VSendToEngine("hard");
	VSendToEngine("easy");
}
typedef	struct	tagCMD {
	char * sz;
	BOOL (* pfn)(char * sz, char * rgsz[], int csz);
}	CMD, * PCMD;
BOOL FCmdBm(char * sz, char * rgsz[], int csz)
{
	int	ib;
	int	i;
	ib = 0;
	for (i = 1; i &lt; csz; i++)
		ib += sprintf(s_ivars.aszAnswer + ib, "%s", rgsz[i]) + 1;
	s_ivars.aszAnswer[ib] = '\0';
	return fTRUE;
}
BOOL FCmdAm(char * sz, char * rgsz[], int csz)
{
	int	ib;
	int	i;
	ib = 0;
	for (i = 1; i &lt; csz; i++)
		ib += sprintf(s_ivars.aszAvoid + ib, "%s", rgsz[i]) + 1;
	s_ivars.aszAvoid[ib] = '\0';
	return fTRUE;
}
BOOL FCmdId(char * sz, char * rgsz[], int csz)
{
	if (csz &lt; 2)
		return fTRUE;
	strcpy(s_ivars.aszId, rgsz[1]);
	return fTRUE;
}
BOOL FCmdFmvn(char * sz, char * rgsz[], int csz)
{
	if (csz &lt; 2)
		return fTRUE;
	s_ivars.movStart = atoi(rgsz[1]);
	if (s_ivars.movStart &lt; 1)
		s_ivars.movStart = 1;
	return fTRUE;
}
BOOL FCmdHmvc(char * sz, char * rgsz[], int csz)
{
	if (csz &lt; 2)
		return fTRUE;
	s_ivars.plyFifty = atoi(rgsz[1]);
	if (s_ivars.plyFifty &lt; 0)
		s_ivars.plyFifty = 0;
	return fTRUE;
}
CMD const c_argcmdEpd[] = {
	"bm",			FCmdBm,			"am",			FCmdAm,			"id",			FCmdId,			"fmvn",			FCmdFmvn,		"hmvc",			FCmdHmvc,		NULL,
};
void VKillTime(TM tmToWait)
{
	TM	tmEnd = TmNow() + tmToWait;
	for (;;) {
		if (WaitForSingleObject(s_ivars.heventStdinReady,
			tmEnd - TmNow()) == WAIT_TIMEOUT)
			break;
		SetEvent(s_ivars.heventStdinAck);
	}
}
void VSendMoveToEngine(char * szMov)
{
	if (s_ivars.fUsermove)
		VSendToEngine("usermove %s", szMov);
	else
		VSendToEngine(szMov);
}
BOOL FFenToBd(char * szFen, PBD pbd)
{
	int	isq;
	int	rnk;
	int	fil;
	int	co;
	for (isq = 0; isq &lt; csqMAX; isq++)
		pbd-&gt;argpcco[isq].co = coMAX;
	rnk = 7;
	fil = 0;
	for (;; szFen++)
		if (*szFen == ' ')
			break;
		else if (*szFen == '/') {
			rnk--;
			fil = 0;
		} else if ((*szFen &gt;= '1') &amp;&amp; (*szFen &lt;= '8'))
			fil += *szFen - '0';
		else if ((fil &gt; 7) || (rnk &lt; 0))
			return fFALSE;
		else {
			int	pc;
			for (pc = pcPAWN; pc &lt;= pcKING; pc++)
				if (s_ivars.plangEnglish-&gt;argbPc[pc] == *szFen) {
					co = coWHITE;
					break;
				}
			if (pc &gt; pcKING)
				for (pc = pcPAWN; pc &lt;= pcKING; pc++)
					if (s_ivars.plangEnglish-&gt;argbPc[pc] ==
						toupper(*szFen)) {
						co = coBLACK;
						break;
					}
			if (pc &gt; pcKING)
				return fFALSE;
			pbd-&gt;argpcco[rnk * 8 + fil].pc = pc;
			pbd-&gt;argpcco[rnk * 8 + fil].co = co;
			fil++;
		}
	switch (*++szFen) {
	case 'w':
		pbd-&gt;coMove = coWHITE;
		break;
	case 'b':
		pbd-&gt;coMove = coBLACK;
		break;
	default:
		return fFALSE;
	}
	return fTRUE;
}
BOOL FSendEdit(char * szFen)
{
	BD	bd;
	int	co;
	if (!FFenToBd(szFen, &amp;bd))
		return fFALSE;
	if (bd.coMove == coBLACK)
		VSendMoveToEngine("a2a3");
	VSendToEngine("edit");
	VSendToEngine("#");
	for (co = coWHITE; co &lt;= coBLACK; co++) {
		int	isq;
		for (isq = 0; isq &lt; csqMAX; isq++)
			if (bd.argpcco[isq].co == co) {
				char	asz[8];
				asz[0] = s_ivars.plangEnglish-&gt;argbPc[bd.argpcco[isq].pc];
				asz[1] = (isq % 8) + 'a';
				asz[2] = (isq / 8) + '1';
				asz[3] = '\0';
				VSendToEngine(asz);
			}
		VSendToEngine((co == coWHITE) ? "c" : ".");
	}
	return fTRUE;
}
BOOL FNextTest(void)
{
	char	aszBuf[256];
	char    aszAddText[15];
	int	i;
	int	cSpaces;
	int	coMove;
	for (;;) {
		if (fgets(aszBuf, sizeof(aszBuf), s_ivars.pfI) != aszBuf)
			return fFALSE;
		s_ivars.cLine++;
		VStrip(aszBuf);
		if (aszBuf[0] != '\0')
			break;
	}
	for (i = cSpaces = 0; aszBuf[i]; i++) {
		if (aszBuf[i] == ' ') {
			if (++cSpaces == 4)
				break;
			if (cSpaces == 1)
				if (aszBuf[i + 1] == 'w')
					coMove = coWHITE;
				else
					coMove = coBLACK;
		}
		s_ivars.aszFen[i] = aszBuf[i];
	}
	if (aszBuf[i] == '\0') {			sprintf(s_ivars.aszOutput,"Obviously bogus FEN, line %d\n", s_ivars.cLine);
		VWriteLogAndOutput();
		return fFALSE;
	}
	s_ivars.aszFen[i] = '\0';
	s_ivars.aszId[0] = '\0';
	s_ivars.aszAnswer[0] = '\0';
	s_ivars.aszAvoid[0] = '\0';
	s_ivars.movStart = 1;
	s_ivars.plyFifty = 0;
	s_ivars.apsInfo[s_ivars.cPosCounter].aszLastPV[0]='\0';
	s_ivars.apsInfo[s_ivars.cPosCounter].cLastDepth=0;
	s_ivars.apsInfo[s_ivars.cPosCounter].cSolveDepth=0;
	s_ivars.apsInfo[s_ivars.cPosCounter].cSolveTime=-1;
	for (;;) {
		char	aszCmd[256];
		int	j;
		char *	argsz[256];
		int	ibSecond;
		int	csz;
		while (aszBuf[i] == ' ')				i++;
		if (aszBuf[i] == '\0')					break;
		for (j = 0; aszBuf[i]; i++) {
			if (aszBuf[i] == ';') {
				i++;
				break;
			}
			aszCmd[j++] = aszBuf[i];
		}
		aszCmd[j] = '\0';
		csz = CszVectorizeEpd(aszCmd, argsz, &amp;ibSecond);
		if (csz)
			for (j = 0; c_argcmdEpd[j].sz != NULL; j++)
				if (!strcmp(c_argcmdEpd[j].sz, argsz[0])) {
					(*c_argcmdEpd[j].pfn)(aszBuf + ibSecond, argsz, csz);
					break;
				}
	}
	sprintf(s_ivars.aszFen + strlen(s_ivars.aszFen), " %d %d",
		s_ivars.plyFifty, s_ivars.movStart);
	s_ivars.fCorrectAnswer = fFALSE;
	s_ivars.tmFoundIn = -1;
	s_ivars.fError = fFALSE;
	strcpy(s_ivars.aszFEN[s_ivars.cPosCounter],s_ivars.aszFen);
	s_ivars.aszName[s_ivars.cPosCounter][0]=0;
	sprintf(s_ivars.aszOutput,"Nr:%5d (of %i)\n",s_ivars.cPosCounter+1,s_ivars.cPosAbs);
	VWriteLogAndOutput();
	strncpy(s_ivars.aszName[s_ivars.cPosCounter],s_ivars.aszId,99);
	strcat(s_ivars.aszName[s_ivars.cPosCounter],"\0");
	if (s_ivars.aszId[0] != '\0') {
		sprintf(s_ivars.aszOutput,"Id:  %s\n", s_ivars.aszId);
		VWriteLogAndOutput();
	}
	sprintf(s_ivars.aszOutput,"Fen: %s\n", s_ivars.aszFen);
	VWriteLogAndOutput();
	s_ivars.aszSol[s_ivars.cPosCounter][0]=0;
	if (s_ivars.aszAnswer[0] != '\0') {
		sprintf(s_ivars.aszOutput,"Bm: ");
		for (i = 0; s_ivars.aszAnswer[i] != '\0';) {
			sprintf(aszAddText," %s", s_ivars.aszAnswer + i);
			strcat(s_ivars.aszOutput,aszAddText);
			i += strlen(s_ivars.aszAnswer + i) + 1;
		}
		strcpy(s_ivars.aszSol[s_ivars.cPosCounter],s_ivars.aszOutput);
		strcat(s_ivars.aszOutput,"\n");
		VWriteLogAndOutput();
	}
	if (s_ivars.aszAvoid[0] != '\0') {
		sprintf(s_ivars.aszOutput,"Am: ");
		for (i = 0; s_ivars.aszAvoid[i] != '\0';) {
			sprintf(aszAddText," %s", s_ivars.aszAvoid + i);
			strcat(s_ivars.aszOutput,aszAddText);
			i += strlen(s_ivars.aszAvoid + i) + 1;
		}
		strcpy(s_ivars.aszSol[s_ivars.cPosCounter],s_ivars.aszOutput);
		strcat(s_ivars.aszOutput,"\n");
		VWriteLogAndOutput();
	}
	VWriteEmpty();
	s_ivars.fStopAnalysis=fFALSE; 	if ((s_ivars.fUseUCI) &amp;&amp; (!s_ivars.fUCI1)) {
		VSendToEngine("ucinewgame");
	} else {
		VSendToEngine("new");
	}
	if (s_ivars.fUseUCI) {
		VSendToEngine("isready");
		s_ivars.mode=modeWAITING;
	} else {
		if (s_ivars.fPing) {
			VSendToEngine("ping %d", ++s_ivars.cPing);
			s_ivars.mode = modeWAITING;
		} else {
			VKillTime(s_ivars.tmWaitPos/2);
			s_ivars.mode = modeTESTING;
		}
	}
	if (!s_ivars.fUseUCI) {
		if (!s_ivars.fAnalyze)
			VSendToEngine("level 0 10000 0");
		else
			VSendToEngine("level 0 5 0");
		VSendToEngine("post");
		VSendToEngine("hard");
		VSendToEngine("easy");
		VSendToEngine("force");
	}
	if (s_ivars.fUseUCI) {
		VSendToEngine("position fen %s", s_ivars.aszFen);
	}
	else {
		if (s_ivars.fSetboard) {
			VSendToEngine("setboard %s", s_ivars.aszFen);
			if ((s_ivars.fColor) &amp;&amp; (!s_ivars.fAnalyze))
				VSendToEngine((coMove == coWHITE) ? "black" : "white");
		} else if (!FSendEdit(s_ivars.aszFen)) {			s_ivars.fError = fTRUE;							return fTRUE;								}												else {												if ((s_ivars.fColor) &amp;&amp; (!s_ivars.fAnalyze)) 
				VSendToEngine((coMove == coWHITE) ? "black" : "white");
		}											}												if (s_ivars.fUseUCI) {
		VSendToEngine("isready");
		s_ivars.mode=modeWAITING;
	} else {
		if (s_ivars.fPing) {
			VSendToEngine("ping %d", ++s_ivars.cPing);
			s_ivars.mode = modeWAITING;
		} else {
			VKillTime(s_ivars.tmWaitPos/2);
			s_ivars.mode = modeTESTING;
		}
	}
	s_ivars.tmEnd = TmNow() + s_ivars.tmPerMove;
	s_ivars.tmStartPos = TmNow();
	if (s_ivars.fUseUCI) {
		VSendToEngine("go infinite");
	} else {
		if (s_ivars.fAnalyze)
			VSendToEngine("analyze");
		else {
			if (s_ivars.fUseSt) {
				VSendToEngine("st %d", s_ivars.tmPerMove / 1000);
				VSendToEngine("time %d", s_ivars.tmPerMove / 10 * s_ivars.cMultiST);
			} else {
				VSendToEngine("time 60000000");						VSendToEngine("otim 60000000");      			}
			if (s_ivars.fColor)
				VSendToEngine((coMove == coWHITE) ? "white" : "black");
			VSendToEngine("go");
		}
	}
	s_ivars.tmStart = TmNow();
	return fTRUE;
}
char const * c_argszNoYes[] = { "No", "Yes" };
BOOL FFeatureTimeout(void)
{
	int	i;
	sprintf(s_ivars.aszOutput,"\n");
	VWriteLogAndOutput();
	sprintf(s_ivars.aszOutput,"Engine:         %s\n", s_ivars.aszEngine);
	VWriteLogAndOutput();
	sprintf(s_ivars.aszOutput,"Suite:          %s\n", s_ivars.aszSuite);
	VWriteLogAndOutput();
	sprintf(s_ivars.aszOutput,"Positions:      %i\n", s_ivars.cPosAbs);
	VWriteLogAndOutput();
	sprintf(s_ivars.aszOutput,"Time per move:  %d second%s\n", s_ivars.tmPerMove / 1000,
		(s_ivars.tmPerMove / 1000 == 1) ? "" : "s");
	VWriteLogAndOutput();
	sprintf(s_ivars.aszOutput,"Language:       %s (%c%c%c%c%c%c)\n", s_ivars.plang-&gt;szLang,
		s_ivars.plang-&gt;argbPc[pcPAWN],
		s_ivars.plang-&gt;argbPc[pcKNIGHT],
		s_ivars.plang-&gt;argbPc[pcBISHOP],
		s_ivars.plang-&gt;argbPc[pcROOK],
		s_ivars.plang-&gt;argbPc[pcQUEEN],
		s_ivars.plang-&gt;argbPc[pcKING]);
	VWriteLogAndOutput();
	if (s_ivars.cSkip) {
		sprintf(s_ivars.aszOutput,"Analysis skip:  %d\n", s_ivars.cSkip);
		VWriteLogAndOutput();
	}
	sprintf(s_ivars.aszOutput,"Engine will use ...\n");
	VWriteLogAndOutput();
	if (!s_ivars.fUseUCI) {
		sprintf(s_ivars.aszOutput,"    \"analyze\":  %s\n", c_argszNoYes[s_ivars.fAnalyze]);
		VWriteLogAndOutput();
		sprintf(s_ivars.aszOutput,"    \"white\" &amp;\n");
		VWriteLogAndOutput();
		sprintf(s_ivars.aszOutput,"      \"black\":  %s\n", c_argszNoYes[s_ivars.fColor]);
		VWriteLogAndOutput();
		sprintf(s_ivars.aszOutput,"    \"ping\":     %s\n", c_argszNoYes[s_ivars.fPing]);
		VWriteLogAndOutput();
		sprintf(s_ivars.aszOutput,"    \"setboard\": %s\n", c_argszNoYes[s_ivars.fSetboard]);
		VWriteLogAndOutput();
		sprintf(s_ivars.aszOutput,"    \"usermove\": %s\n", c_argszNoYes[s_ivars.fUsermove]);
		VWriteLogAndOutput();
	} else {
		for (i=0;i&lt;s_ivars.UCIoptions;i++) {
			if (s_ivars.UCIoptionstate[i] &amp; 2) {
				sprintf(s_ivars.aszOutput,"setoption name %s value %s\n",s_ivars.UCIoption[i],s_ivars.UCIvalue[i]);
				if (!s_ivars.fFindInfo) {
					VSendToEngine(s_ivars.aszOutput);
				}
				VWriteLogAndOutput();
			}
		}
	}
	if (s_ivars.cIPTime) {
		if (s_ivars.cIPTime==1) 
			sprintf(s_ivars.aszOutput,"    \"time in\":  centiseconds\n");
		else if (s_ivars.cIPTime==2) sprintf(s_ivars.aszOutput,"    \"time in\":  seconds\n");
		else if (s_ivars.cIPTime==3) sprintf(s_ivars.aszOutput,"    \"time in\":  tenth of seconds\n");
		else sprintf(s_ivars.aszOutput,"    \"time in\":  milliseconds\n");
		VWriteLogAndOutput();
	}
	if ((!s_ivars.fPing) &amp;&amp; (!s_ivars.fUseSt)) {
		sprintf(s_ivars.aszOutput,"Test delay:     %d second%s\n", s_ivars.tmWaitInit / 1000,
			(s_ivars.tmWaitInit / 1000 == 1) ? "" : "s");
		VWriteLogAndOutput();
	}
	if (s_ivars.fUseSt) {
		sprintf(s_ivars.aszOutput,"Try \"st\":       %s\n", c_argszNoYes[s_ivars.fUseSt]);
		VWriteLogAndOutput();
	}
	if (s_ivars.fFindInfo)
		return fFALSE;
	VWriteEmpty();
	s_ivars.aszOutput[0]=0;
	for (i = 0; i &lt; cbLINE - 1; i++)
		strcat(s_ivars.aszOutput,"-");
	VWriteLogAndOutput();
	VWriteEmpty();
	VWriteEmpty();
	if (!s_ivars.fUseUCI) VPrepEngine();
	return FNextTest();
}
BOOL FBreakFeature(char * szCmd, char * szName, int * piValue)
{
	for (;;) {
		if ((*szCmd == '\0') || (*szCmd == '='))
			break;
		*szName++ = *szCmd++;
	}
	*szName = '\0';
	if (*szCmd++ != '=')
		return fFALSE;
	if (*szCmd == '"') {    		*piValue = 0;				return fTRUE;			}
	if (!isdigit(*szCmd))
		return fFALSE;
	*piValue = atoi(szCmd);
	return fTRUE;
}
BOOL FCmdFeature(char * sz, char * rgsz[], int csz)
{
	int	isz;
	DWORD i;
	for (isz = 1; isz &lt; csz; isz++) {
		char	aszName[256];
		int	iValue;
		if (!FBreakFeature(rgsz[isz], aszName, &amp;iValue))
			return fTRUE;			if ((!strcmp(aszName, "done")) &amp;&amp; (!s_ivars.fIgnoreDone)) {
			if (iValue == 0) {
				if (s_ivars.mode == modeFEATURE_TIMEOUT)
					s_ivars.mode = modeFEATURE_NOTIMEOUT;
			} else {
				if ((s_ivars.mode == modeFEATURE_NOTIMEOUT) ||
					(s_ivars.mode == modeFEATURE_TIMEOUT))
					if (!FFeatureTimeout())
						return fFALSE;
			}
		} else if (!strcmp(aszName, "ping"))
			s_ivars.fPing = (iValue) ? fTRUE : fFALSE;
		else if (!strcmp(aszName, "setboard"))
			s_ivars.fSetboard = (iValue) ? fTRUE : fFALSE;
		else if (!strcmp(aszName, "myname"))
		{
			for (i=1;i&lt;strlen(rgsz[isz]);i++)
			{
				if (rgsz[isz][i]=='"')
				{
					strcpy(s_ivars.aszEngine,&amp;rgsz[isz][i+1]);
					s_ivars.aszEngine[strlen(s_ivars.aszEngine)-1]=0;
					break;
				}
			}
		}
		else if (!strcmp(aszName, "analyze")) {
			s_ivars.fAnalyze = (iValue) ? fTRUE : fFALSE;
			if (s_ivars.fUseSt)						s_ivars.fAnalyze = fFALSE;
		} else if (!strcmp(aszName, "colors"))
			s_ivars.fColor = (iValue) ? fTRUE : fFALSE;
		else if (!strcmp(aszName, "usermove"))
			s_ivars.fUsermove = (iValue) ? fTRUE : fFALSE;
	}
	return fTRUE;
}
BOOL FCmdUciId(char * sz, char * rgsz[], int csz)
{
	long i;
	if (!strcmp("name",rgsz[1])) {
		strcpy(s_ivars.aszEngine,"\0");
		for (i=2;i&lt;csz;i++) {
			if (i&gt;2) strcat(s_ivars.aszEngine," ");
			strcat(s_ivars.aszEngine,rgsz[i]);
		}
	}
	return fTRUE;
}
BOOL FCmdUciOk(char * sz, char * rgsz[], int csz)
{
	if (!FFeatureTimeout())
		return fFALSE;
	return fTRUE;
}
BOOL FCmdOption(char * sz, char * rgsz[], int csz)
{
	char UciOption[256];
	int i,k;
	bool found;
	if (!strcmp("name",rgsz[1])) {
		strcpy(UciOption,rgsz[2]);
		k=3;
		while (strcmp(rgsz[k],"type")) {
			strcat(UciOption," ");
			strcat(UciOption,rgsz[k]);
			k++;
		}
		found=false;
		for (i=0;i&lt;s_ivars.UCIoptions;i++)
		{
			if (!strcmp(UciOption,s_ivars.UCIoption[i])) {
				found=true;
				s_ivars.UCIoptionstate[i]|=2;
			}
		}
		if (!found) {
			strcpy(s_ivars.UCIoption[s_ivars.UCIoptions],UciOption);
			found=false;
			for (i=k;i&lt;csz;i++) {
				if (!strcmp(rgsz[i],"default")) {
					strcpy(s_ivars.UCIvalue[s_ivars.UCIoptions],rgsz[i+1]);
					found=true;
				}
			}
			s_ivars.UCIoptionstate[s_ivars.UCIoptions]=2;
			if (found) s_ivars.UCIoptions++;
		}
	}
	return fTRUE;
}
BOOL FCmdPong(char * sz, char * rgsz[], int csz)
{
	if (csz == 0)
		return fTRUE;
	if (atoi(rgsz[1]) == s_ivars.cPing) {
		s_ivars.mode = modeTESTING;
		s_ivars.tmStart = TmNow();
		s_ivars.tmEnd = s_ivars.tmStart + s_ivars.tmPerMove;
		SetEvent(s_ivars.heventStdinPing);
	}
	return fTRUE;
}
BOOL FCmdReadyOk(char * sz, char * rgsz[], int csz)
{
	s_ivars.mode = modeTESTING;
	s_ivars.tmStart = TmNow();
	s_ivars.tmEnd = s_ivars.tmStart + s_ivars.tmPerMove;
	SetEvent(s_ivars.heventStdinPing);
	return fTRUE;
}
void VAnalysisLine(char * rgsz[], int csz);
void VEngineMoved(char * sz)
{
	char	asz[256];
	char *	argsz[256];
	int	ibSecond;
	int	csz;
	s_ivars.tmEnd = TmNow();
	if (!s_ivars.fUseUCI) {
		sprintf(asz, "-1 0 %lu 0 %s", (s_ivars.tmEnd - s_ivars.tmStart) / 10, sz);
	} else {
		sprintf(asz, "info time %lu nodes 0 score cp 0 depth -1 pv %s",(s_ivars.tmEnd - s_ivars.tmStart),sz);
	}
	csz = CszVectorizeCmd(asz, argsz, &amp;ibSecond);
	VAnalysisLine(argsz, csz);
}
BOOL FCmdMove(char * sz, char * rgsz[], int csz)
{
	if (csz != 2)
		return fTRUE;
	if (s_ivars.mode != modeTESTING)
		return fTRUE;
	VEngineMoved(rgsz[1]);
	return fTRUE;
}
BOOL FCmdTellusererror(char * sz, char * rgsz[], int csz)
{
	if (s_ivars.mode != modeTESTING)
		return fTRUE;
	s_ivars.fError = fTRUE;
	return fTRUE;
}
CMD const c_argcmdEngine[] = {
	"feature",			FCmdFeature,
	"pong",				FCmdPong,
	"move",				FCmdMove,
	"tellusererror",	FCmdTellusererror,
	"id",				FCmdUciId,
	"option",			FCmdOption,
	"uciok",            FCmdUciOk,
	"readyok",			FCmdReadyOk,
	NULL,
};
BOOL FIsInteger(char * sz, BOOL * pfNonBlankTrailer)
{
	if ((*sz == '-') || (*sz == '+'))
		sz++;
	if (sz[strlen(sz)-1]=='d')			sz[strlen(sz)-1]='\0';
	if (sz[strlen(sz)-1]=='!')			sz[strlen(sz)-1]='\0';
	if (sz[strlen(sz)-1]=='?')			sz[strlen(sz)-1]='\0';
	if (!isdigit(*sz++))			return fFALSE;
	while (isdigit(*sz))
		sz++;
	if (*sz != '\0') {				*pfNonBlankTrailer = fTRUE;
		sz++;
	} else
		*pfNonBlankTrailer = fFALSE;
	return (*sz == '\0');
}
BOOL FCorrectAnswer(char * sz)
{
	int	i;
	while (isdigit(*sz))
		sz++;
	while (*sz == '.')
		sz++;
	if (*sz == '(')
		sz++;								if (*sz == '+')
		sz++;								if (*sz == '-')
		sz++;								if ((strlen(sz)&gt;4) &amp;&amp; (sz[strlen(sz)-3]=='('))
		sz[strlen(sz)-3]=0;					if ((strlen(sz)&gt;3) &amp;&amp; ((!strncmp(&amp;sz[strlen(sz)-2],"FH",2)) || (!strncmp(&amp;sz[strlen(sz)-2],"FL",2))))
		sz[strlen(sz)-2]=0;					if (s_ivars.aszAnswer[0] != '\0') {
		for (i = 0; s_ivars.aszAnswer[i] != '\0';) {
			if (FCheckAnswer(s_ivars.aszFen, sz, s_ivars.aszAnswer + i,
				s_ivars.plang, s_ivars.plangEnglish))
				return fTRUE;
			i += strlen(s_ivars.aszAnswer + i) + 1;
		}
		return fFALSE;
	}
	if (s_ivars.aszAvoid[0] != '\0') {
		for (i = 0; s_ivars.aszAvoid[i] != '\0';) {
			if (FCheckAnswer(s_ivars.aszFen, sz, s_ivars.aszAvoid + i,
				s_ivars.plang, s_ivars.plangEnglish))
				return fFALSE;
			i += strlen(s_ivars.aszAvoid + i) + 1;
		}
		return fTRUE;
	}
	return fFALSE;
}
BOOL FIsMove(char * sz)
{
	if ((strlen(sz) == 4) &amp;&amp; (sz[0]=='[') &amp;&amp; (sz[3]==']'))
		return fFALSE;								if (!strcmp(sz,"MAT")) return fFALSE;			if (!strcmp(sz,"EN")) return fFALSE;			if (!strcmp(sz,"COUPS")) return fFALSE;			if (!strcmp(sz,"MAT!")) return fFALSE;			if (!strncmp(sz,"a8a8",4)) return fFALSE;   	while (isdigit(*sz))
		sz++;
	while (*sz == '.')
		sz++;
	if (*sz == '(')
		sz++;										if (*sz == ')')
		sz++;										while (*sz == '+')
		sz++;										while (*sz == '-')
		sz++;										if ((*sz != '\0') &amp;&amp; (*sz != '/'))          		return fTRUE;
	return fFALSE;
}
void VAnalysisLine(char * rgsz[], int csz)
{
	int		plyDepth;
	int		valScore;
	TM		tm;
	long	nodes;
	int		i;
	char	aszResult[16],hstring[60];
	char	uciline[1024];
	int		cb;
	int		cbStats;
	BOOL	fTrailer;
	int	cSkip;
	if (!s_ivars.fUseUCI) {
		if ((csz == 1) &amp;&amp; ((!strcmp(rgsz[0], "++")) ||
			(!strcmp(rgsz[0], "--")))) {
			sprintf(s_ivars.aszOutput,"%40s\n", rgsz[0]);
			VWriteLogAndOutput();
		}
		strcpy(s_ivars.aszOutput,"Analysis tokens:");
		hstring[0]=0;
		if (s_ivars.fDump) {
			for (i=0;i&lt;__min(csz,6);i++)
			{
				sprintf(hstring,"%d/%s ",i,rgsz[i]);
				strcat(s_ivars.aszOutput,hstring);
			}
			strcat(s_ivars.aszOutput,"\n");
			VWriteLogAndOutput();
		}
		if (csz &lt; 4)
		{
			if (s_ivars.fDump) {
				strcpy(s_ivars.aszOutput,"Analysis: Not enough parameters\n");
				VWriteLogAndOutput();
			}
			return;
		}
		for (i = 0; i &lt; 4; i++) {
			BOOL	f;
			if (!FIsInteger(rgsz[i], &amp;f))
			{
				if ((i==1) &amp;&amp; (!strncmp(rgsz[i],"Mat",3)))
					f=false;
				else 
				{
					if (s_ivars.fDump) {
						sprintf(s_ivars.aszOutput,"Analysis: parameter %d is no integer !\n",i);
						VWriteLogAndOutput();
					}
					return;
				}
			}
			if (i == 0)
				fTrailer = f;
			else if (f)
			{
					if (s_ivars.fDump) {
						sprintf(s_ivars.aszOutput,"Analysis: in the 4 first parameters is one no integer !\n",i);
						VWriteLogAndOutput();
					}
				return;
			}
		}
	} else {
		if (!strcmp(rgsz[0],"info")) {
			char ucidepth[50];
			char uciscore[50];
			char ucinodes[50];
			char ucitime[50];
			char ucipv[1024];
			bool uciwrong,pvstarted;
			int j;
			strcpy(ucipv,"");
			strcpy(ucidepth,"0");
			strcpy(uciscore,"0");
			strcpy(ucinodes,"0");
			strcpy(ucitime,"0");
			i=1;
			uciwrong=false;
			pvstarted=false;
			while ((i&lt;csz) &amp;&amp; (!uciwrong )) {
				if (!strcmp(rgsz[i],"pv")) {
					pvstarted=true;
				} else {
					if (!strcmp(rgsz[i],"currmove")) {
						uciwrong=true;
					} else {
						if (!strcmp(rgsz[i],"currmovenumber")) {
							uciwrong=true;
						} else {
							if (!strcmp(rgsz[i],"currline")) {
								uciwrong=true;
							} else {
								if (!strcmp(rgsz[i],"refutation")) {
									uciwrong=true;
								} else {
									if (!strcmp(rgsz[i],"depth")) {
										pvstarted=false;
										strcpy(ucidepth,rgsz[i+1]);
#if uciDEBUG
										sprintf(s_ivars.aszOutput,"Depth: %s\n",ucidepth);
										VWriteLogAndOutput();
#endif
										i++;
									} else {
										if (!strcmp(rgsz[i],"seldepth")) {
											pvstarted=false;
											i++;
										} else {
											if (!strcmp(rgsz[i],"time")) {
												pvstarted=false;
												strcpy(ucitime,rgsz[i+1]);
												i++;
#if uciDEBUG
												sprintf(s_ivars.aszOutput,"Time: %s\n",ucitime);
												VWriteLogAndOutput();
#endif
											} else {
												if (!strcmp(rgsz[i],"nodes")) {
													pvstarted=false;
													strcpy(ucinodes,rgsz[i+1]);
													i++;
#if uciDEBUG
													sprintf(s_ivars.aszOutput,"Nodes: %s\n",ucinodes);
													VWriteLogAndOutput();
#endif
												} else {
													if (!strcmp(rgsz[i],"multipv")) {
														pvstarted=false;
														i++;
													} else {
														if (!strcmp(rgsz[i],"score")) {
															pvstarted=false;
															if (!strcmp(rgsz[i+1],"mate")) {
																j=atoi(rgsz[i+2]);
																if (j&gt;0) {
																	sprintf(uciscore,"%i",32767-(j*2));
																} else {
																	sprintf(uciscore,"%i",-32768+(j*2));
																}
															} else {
																strcpy(uciscore,rgsz[i+2]);
															}
															i+=2;
#if uciDEBUG
															sprintf(s_ivars.aszOutput,"Score: %s\n",uciscore);
															VWriteLogAndOutput();
#endif
														} else {
															if (!strcmp(rgsz[i],"hashfull")) {
																pvstarted=false;
																i++;
															} else {
																if (!strcmp(rgsz[i],"nps")) {
																	pvstarted=false;
																	i++;
																} else {
																	if (!strcmp(rgsz[i],"tbhits")) {
																		pvstarted=false;
																		i++;
																	} else {
																		if (!strcmp(rgsz[i],"cpuload")) {
																			pvstarted=false;
																			i++;
																		} else {
																			if (!strcmp(rgsz[i],"string")) {
																				uciwrong=true;
																			} else {
																				if (pvstarted) {
																					if (strlen(ucipv)&gt;1) {
																						strcat(ucipv," ");
																					}
																					strcat(ucipv,rgsz[i]);
																				}
																			}
																		}
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
				i++;
			}
			if ((uciwrong) || (strlen(ucipv)&lt;2)) return;
			sprintf(uciline,"%s %s %s %s %s",ucidepth,uciscore,ucitime,ucinodes,ucipv);
#if uciDEBUG
			strcpy(s_ivars.aszOutput,uciline);
			strcat(s_ivars.aszOutput,"\n");
			VWriteLogAndOutput();
#endif
			csz=CszVectorizeCmd(uciline,rgsz,&amp;i);
		}
		else {
			return;
		}
	}
	plyDepth = atoi(rgsz[0]);
	cSkip = (plyDepth &lt; 0) ? 0 : s_ivars.cSkip;
	valScore = atoi(rgsz[1]);
	if (s_ivars.cIPTime != 4) tm = atol(rgsz[2]) * 10;
	else tm = atol(rgsz[2]);
	if (s_ivars.cIPTime == 3) tm *= 10;
	else if (((fTrailer) || (s_ivars.cIPTime==2)) 
		&amp;&amp; (s_ivars.cIPTime != 1) &amp;&amp; (s_ivars.cIPTime != 4))
		tm *= 100;
	if (s_ivars.fInternalTime) tm = TmNow() - s_ivars.tmStartPos;
	if (tm &gt; s_ivars.tmPerMove) return;
	nodes = atol(rgsz[3]);
	for (i = 4 + cSkip;; i++)
		if (i &gt;= csz) {
			if (valScore == 49999)
			{
				s_ivars.fCorrectAnswer = fTRUE;
				strcpy(aszResult,"yes");
				if (s_ivars.tmFoundIn==-1)
				{
					s_ivars.tmFoundIn=tm;
					s_ivars.apsInfo[s_ivars.cPosCounter].cSolveDepth=plyDepth;
				}
				break;
			}
lblWrong:	s_ivars.fCorrectAnswer = fFALSE;
			strcpy(aszResult, "no");
			s_ivars.tmFoundIn = -1;
			break;
		} else 
			{
				if (!strncmp(rgsz[i],"TBHits=",7)) i++;						if ((rgsz[i][0]=='(') &amp;&amp; (rgsz[i][strlen(rgsz[i])-1]==')')) i++;					if (rgsz[i][0]==',') i++;															if ((rgsz[i][0]=='(') &amp;&amp; (rgsz[i+1][strlen(rgsz[i+1])-1]==',')) i+=2; 				if ((rgsz[i][0]=='(') &amp;&amp; (rgsz[i+1][strlen(rgsz[i+1])-1]==')')) i+=2; 				if (FIsMove(rgsz[i])) {
				if (!FCorrectAnswer(rgsz[i]))
					goto lblWrong;
				s_ivars.fCorrectAnswer = fTRUE;
				strcpy(aszResult, "yes");
				if (s_ivars.tmFoundIn == -1) {
					s_ivars.tmFoundIn = tm;
					s_ivars.apsInfo[s_ivars.cPosCounter].cSolveDepth=plyDepth;
				}
				if (s_ivars.fStopPly) {
					if ((plyDepth-s_ivars.apsInfo[s_ivars.cPosCounter].cSolveDepth)&gt;=s_ivars.cPlys) {
						s_ivars.fStopAnalysis=fTRUE;
					}
				}
				if (s_ivars.fStopScore) {
					if (valScore&gt;=s_ivars.cScore) {
						s_ivars.fStopAnalysis=fTRUE;
					}
				}
				break;
			}
		}
	if (plyDepth &lt; 0)
		cb = cbStats = sprintf(s_ivars.aszOutput,"%-3s ??? %9ld (moved)           ???",
			aszResult, tm);
	else {
		if (s_ivars.fDump) {
			cb = cbStats = sprintf(s_ivars.aszOutput,"%-3s %3d %9ld:%d %+8d %12ld",
				aszResult, plyDepth, tm, TmNow() - s_ivars.tmStartPos,valScore, nodes);
			s_ivars.apsInfo[s_ivars.cPosCounter].cLastDepth=plyDepth;
			s_ivars.apsInfo[s_ivars.cPosCounter].cLastEval=valScore;
			if (csz&gt;4+cSkip) s_ivars.apsInfo[s_ivars.cPosCounter].aszLastPV[0]='\0';
		}
		else
		{
			cb = cbStats = sprintf(s_ivars.aszOutput,"%-3s %3d %9ld %+8d %12ld",
				aszResult, plyDepth, tm,valScore, nodes);
			s_ivars.apsInfo[s_ivars.cPosCounter].cLastDepth=plyDepth;
			s_ivars.apsInfo[s_ivars.cPosCounter].cLastEval=valScore;
			if (csz&gt;4+cSkip) s_ivars.apsInfo[s_ivars.cPosCounter].aszLastPV[0]='\0';
		}
	}
	for (i = 4 + cSkip; i &lt; csz; i++) {
		int	cbCur = strlen(rgsz[i]) + 1;
		if (strlen(s_ivars.apsInfo[s_ivars.cPosCounter].aszLastPV)+strlen(rgsz[i])+1&lt;512) {
			strcat(s_ivars.apsInfo[s_ivars.cPosCounter].aszLastPV," ");
			strcat(s_ivars.apsInfo[s_ivars.cPosCounter].aszLastPV,rgsz[i]);
		}
		if (cb + cbCur &gt; cbLINE - 1) {
			VWriteLogAndOutput();
			VWriteEmpty();
			s_ivars.aszOutput[0]=0;
			for (cb = 0; cb &lt; cbStats; cb++)
				strcat(s_ivars.aszOutput," ");
		}
		strcat(s_ivars.aszOutput," ");
		strcat(s_ivars.aszOutput,rgsz[i]);
		cb += cbCur;
	}
	VWriteLogAndOutput();
	VWriteEmpty();
}
#define	uHOUR_FROM_MILLI(tm)	(unsigned)((TM)(tm) / 3600000)
#define	uMIN_FROM_MILLI(tm)		(unsigned)(((TM)(tm) / 60000) % 60)
#define	uSEC_FROM_MILLI(tm)		(unsigned)(((TM)(tm) / 1000) % 60)
#define	uMILLI_FROM_MILLI(tm)	(unsigned)((TM)(tm) % 1000)
void VDumpResults(void)
{
	int	isolHi;
	int i,j,k,r,cb,cbCur,csz;
	unsigned int l;
	DWORD dwa;
	char aszAddText[20];
	char * argsz[256];
	sprintf (s_ivars.aszOutput,"Position results:\n\n");
	VWriteLogAndOutput();
	sprintf (s_ivars.aszOutput,"PosNr solved ply      time     last pv\n");
	VWriteLogAndOutput();
	sprintf(s_ivars.aszOutput,"----- ------ --- ------------- ");
	for (cb=strlen(s_ivars.aszOutput);cb&lt;cbLINE - 1;cb++)
		strcat(s_ivars.aszOutput,"-");
	VWriteLogAndOutput();
	VWriteEmpty();
	for (i = 0; i &lt; s_ivars.cPosCounter;i++) {
		if (s_ivars.apsInfo[i].cSolveTime&lt;=s_ivars.tmPerMove)
			sprintf(s_ivars.aszOutput,"%5d    yes %3d [%02d:%02d:%02d,%02d] ",i+1,
				s_ivars.apsInfo[i].cSolveDepth,
				uHOUR_FROM_MILLI(s_ivars.apsInfo[i].cSolveTime),
				uMIN_FROM_MILLI(s_ivars.apsInfo[i].cSolveTime),
				uSEC_FROM_MILLI(s_ivars.apsInfo[i].cSolveTime),
				uMILLI_FROM_MILLI(s_ivars.apsInfo[i].cSolveTime)/10);
		else sprintf(s_ivars.aszOutput,"%5d     no     [--:--:--,--] ",i+1);
		cb=strlen(s_ivars.aszOutput);
		if (s_ivars.apsInfo[i].cLastDepth&gt;0) {
			sprintf(aszAddText,"[%d] %+.2f ",s_ivars.apsInfo[i].cLastDepth,
					(float) s_ivars.apsInfo[i].cLastEval/100.0);
		}
		else aszAddText[0]=0;
		cbCur=strlen(aszAddText);
		if (cbCur&gt;0) strcat(s_ivars.aszOutput,aszAddText);
		csz=CszVectorizeCmd(s_ivars.apsInfo[i].aszLastPV,argsz,&amp;r);
		for (j=0; j&lt;csz; j++) {
			if (cb+cbCur+strlen(argsz[j])&lt;cbLINE) {
				cbCur+=strlen(argsz[j])+1;
				strcat(s_ivars.aszOutput,argsz[j]);
				strcat(s_ivars.aszOutput," ");
			}
			else
			{
				VWriteLogAndOutput();
				VWriteEmpty();
				s_ivars.aszOutput[0]=0;
				for (k=0; k&lt;cb; k++)
					strcat(s_ivars.aszOutput," ");
				strcat(s_ivars.aszOutput,argsz[j]);
				strcat(s_ivars.aszOutput," ");
				cbCur=strlen(argsz[j])+1;
			}
		}
		VWriteLogAndOutput();
		VWriteEmpty();
	}
	s_ivars.aszOutput[0]=0;
	for (i = 0; i &lt; cbLINE - 1; i++)
		strcat(s_ivars.aszOutput,"-");
	VWriteLogAndOutput();
	VWriteEmpty();
	VWriteEmpty();
	for (isolHi = isolMAX - 1; isolHi &gt;= 0; isolHi--)
		if (s_ivars.argsol[isolHi])
			break;
	sprintf(s_ivars.aszOutput,"Results:\n\n");
	VWriteLogAndOutput();
	if (s_ivars.cSolved) {
		if (isolHi &lt; 0) {
			sprintf(s_ivars.aszOutput,"No problems solved in &lt; %d seconds\n", isolMAX);
			VWriteLogAndOutput();
		}
		else {
			int	cTotal = 0;
			sprintf(s_ivars.aszOutput,"&lt;=Sec Solved Total  PosNr\n");
			VWriteLogAndOutput();
			strcpy(s_ivars.aszOutput,"----- ------ ------ ");
			for (cb=strlen(s_ivars.aszOutput);cb&lt;cbLINE - 1;cb++)
				strcat(s_ivars.aszOutput,"-");
			VWriteLogAndOutput();
			VWriteEmpty();
			for (i = 0; i &lt;= isolHi; i++) {
				if (s_ivars.argsol[i]) {
					cTotal += s_ivars.argsol[i];
					k=sprintf(s_ivars.aszOutput,"%5d %6d %6d", i + 1, s_ivars.argsol[i], cTotal);
					cb=strlen(s_ivars.aszOutput);
					cbCur=0;
					for (j=0;j&lt;s_ivars.cPosCounter;j++) {
						if (((s_ivars.apsInfo[j].cSolveTime&lt;=(TM)(i+1)*1000)
							&amp;&amp; (s_ivars.apsInfo[j].cSolveTime&gt;(TM)i*1000)) 
							|| ((i==0) &amp;&amp; (s_ivars.apsInfo[j].cSolveTime==0))) {
							if (s_ivars.cPosCounter&lt;10) {
								k=sprintf(aszAddText,"%2d",j+1);
							}
							else if (s_ivars.cPosCounter&lt;100) {
								k=sprintf(aszAddText,"%3d",j+1);
							}
							else if (s_ivars.cPosCounter&lt;1000) {
								k=sprintf(aszAddText,"%4d",j+1);
							}
							else k=sprintf(aszAddText,"%5d",j+1);
							if (cb+cbCur+strlen(aszAddText)&lt;cbLINE) {
								cbCur+=strlen(aszAddText);
								strcat(s_ivars.aszOutput,aszAddText);
							}
							else {
								VWriteLogAndOutput();
								VWriteEmpty();
								cbCur=strlen(aszAddText);
								s_ivars.aszOutput[0]=0;
								for (k=0;k&lt;cb;k++)
									strcat(s_ivars.aszOutput," ");
								strcat(s_ivars.aszOutput,aszAddText);
							}
						}
					}
					VWriteLogAndOutput();
					VWriteEmpty();
				}
			}
			strcpy(s_ivars.aszOutput,"Failure");
			for (i=strlen(s_ivars.aszOutput);i&lt;cb;i++)
				strcat(s_ivars.aszOutput," ");
			cbCur=0;
			for (i=0;i&lt;s_ivars.cPosCounter;i++) {
				if (s_ivars.apsInfo[i].cSolveTime&gt;=s_ivars.tmPerMove) {
					if (s_ivars.cPosCounter&lt;10) {
						k=sprintf(aszAddText,"%2d",i+1);
					}
					else if (s_ivars.cPosCounter&lt;100) {
						k=sprintf(aszAddText,"%3d",i+1);
					}
					else if (s_ivars.cPosCounter&lt;1000) {
						k=sprintf(aszAddText,"%4d",i+1);
					}
					else k=sprintf(aszAddText,"%5d",i+1);
					if (cb+cbCur+strlen(aszAddText)&lt;cbLINE) {
						cbCur+=strlen(aszAddText);
						strcat(s_ivars.aszOutput,aszAddText);
					}
					else {
						VWriteLogAndOutput();
						VWriteEmpty();
						cbCur=strlen(aszAddText);
						s_ivars.aszOutput[0]=0;
						for (k=0;k&lt;cb;k++)
							strcat(s_ivars.aszOutput," ");
						strcat(s_ivars.aszOutput,aszAddText);
					}
				}
			}
			VWriteLogAndOutput();
			VWriteEmpty();
		}
		VWriteEmpty();
	}
	sprintf(s_ivars.aszOutput,"%d problem%s solved.\n", s_ivars.cSolved,
		(s_ivars.cSolved == 1) ? "" : "s");
	VWriteLogAndOutput();
	sprintf(s_ivars.aszOutput,"%d problem%s unsolved.\n", s_ivars.cFailed,
		(s_ivars.cFailed == 1) ? "" : "s");
	VWriteLogAndOutput();
	if (s_ivars.cError) {
		sprintf(s_ivars.aszOutput,"%d error%s found!\n",
			s_ivars.cError, (s_ivars.cError == 1) ? "" : "s");
		VWriteLogAndOutput();
	}
	VWriteEmpty();
	if (s_ivars.fDBon)
	{
		FILE * OldFile;
		char aszOutput[5000];
		DWORD solvetime,solved;
		solved=0;
		solvetime=0;
		dwa=GetFileAttributes(s_ivars.aszDBFile);
		if (dwa==(DWORD)(-1))
		{
			s_ivars.DBDatei.open(s_ivars.aszDBFile,ios::trunc | ios::out | ios::in);
			s_ivars.DBDatei.seekp(0,ios::beg);
			sprintf(aszOutput,"\"%s\";;;;\"%s\";\n",s_ivars.aszSuite,s_ivars.aszEngine);
			s_ivars.DBDatei.write(aszOutput,strlen(aszOutput));
			s_ivars.DBDatei.seekp(0,ios::end);
			strcpy(aszOutput,"\"Nr.\";\"Name\";\"FEN\";\"Keymove\";\"time\";\"depth\"\n");
			s_ivars.DBDatei.write(aszOutput,strlen(aszOutput));
			s_ivars.DBDatei.seekp(0,ios::end);
			for (i = 0; i &lt; s_ivars.cPosCounter;i++) 
			{
				sprintf(aszOutput,"\"%i\";\"%s\";\"%s\";\"%s\";",i+1,s_ivars.aszName[i],s_ivars.aszFEN[i],s_ivars.aszSol[i]);
				if (s_ivars.apsInfo[i].cSolveTime&lt;=s_ivars.tmPerMove)
				{
					solved++;
					solvetime+=s_ivars.apsInfo[i].cSolveTime/1000;
					sprintf(aszOutput,"%s\"%i\";\"%i\"\n",aszOutput,s_ivars.apsInfo[i].cSolveTime/1000,s_ivars.apsInfo[i].cSolveDepth);
				}
				else
				{
					solvetime+=s_ivars.tmPerMove/1000;
					sprintf(aszOutput,"%s\"9999\";\"%i\"\n",aszOutput,s_ivars.apsInfo[i].cLastDepth);
				}
				s_ivars.DBDatei.write(aszOutput,strlen(aszOutput));
				s_ivars.DBDatei.seekp(0,ios::end);
			}
			sprintf(aszOutput,";;;\"Solved:\";\"%i\";\n",solved);
			s_ivars.DBDatei.write(aszOutput,strlen(aszOutput));
			s_ivars.DBDatei.seekp(0,ios::end);
			sprintf(aszOutput,";;;\"Solve-Time:\";\"%i\";\n",solvetime);
			s_ivars.DBDatei.write(aszOutput,strlen(aszOutput));
			s_ivars.DBDatei.seekp(0,ios::end);
			s_ivars.DBDatei.close();
		}
		else
		{
			strcpy(aszOutput,s_ivars.aszDBFile);
			strcat(aszOutput,".bak");
			dwa=GetFileAttributes(aszOutput);
			if (!(dwa==(DWORD)(-1)))
			{
				remove(aszOutput);
			}
			rename(s_ivars.aszDBFile,aszOutput);
			if( (OldFile = fopen( aszOutput, "r" )) != NULL )
			{
				fgets(aszOutput,5000,OldFile);
				j=0;
				for (l=0;l&lt;strlen(aszOutput);l++) {
					if (aszOutput[l]==';') {
						j++;
					}
				}
				if (j&gt;250) {
					fclose(OldFile);
					strcpy(aszOutput,s_ivars.aszDBFile);
					strcat(aszOutput,".001");
					dwa=GetFileAttributes(aszOutput);
					if (!(dwa==(DWORD)(-1)))
					{
						remove(aszOutput);
					}
					rename(s_ivars.aszDBFile,aszOutput);
					dwa=GetFileAttributes(s_ivars.aszDBFile);
					if (dwa==(DWORD)(-1))
					{
						s_ivars.DBDatei.open(s_ivars.aszDBFile,ios::trunc | ios::out | ios::in);
						s_ivars.DBDatei.seekp(0,ios::beg);
						sprintf(aszOutput,"\"%s\";;;;\"%s\";\n",s_ivars.aszSuite,s_ivars.aszEngine);
						s_ivars.DBDatei.write(aszOutput,strlen(aszOutput));
						s_ivars.DBDatei.seekp(0,ios::end);
						strcpy(aszOutput,"\"Nr.\";\"Name\";\"FEN\";\"Keymove\";\"time\";\"depth\"\n");
						s_ivars.DBDatei.write(aszOutput,strlen(aszOutput));
						s_ivars.DBDatei.seekp(0,ios::end);
						for (i = 0; i &lt; s_ivars.cPosCounter;i++) 
						{
							sprintf(aszOutput,"\"%i\";\"%s\";\"%s\";\"%s\";",i+1,s_ivars.aszName[i],s_ivars.aszFEN[i],s_ivars.aszSol[i]);
							if (s_ivars.apsInfo[i].cSolveTime&lt;=s_ivars.tmPerMove)
							{
								solved++;
								solvetime+=s_ivars.apsInfo[i].cSolveTime/1000;
								sprintf(aszOutput,"%s\"%i\";\"%i\"\n",aszOutput,s_ivars.apsInfo[i].cSolveTime/1000,s_ivars.apsInfo[i].cSolveDepth);
							}
							else
							{
								solvetime+=s_ivars.tmPerMove/1000;
								sprintf(aszOutput,"%s\"9999\";\"%i\"\n",aszOutput,s_ivars.apsInfo[i].cLastDepth);
							}
							s_ivars.DBDatei.write(aszOutput,strlen(aszOutput));
							s_ivars.DBDatei.seekp(0,ios::end);
						}
						sprintf(aszOutput,";;;\"Solved:\";\"%i\";\n",solved);
						s_ivars.DBDatei.write(aszOutput,strlen(aszOutput));
						s_ivars.DBDatei.seekp(0,ios::end);
						sprintf(aszOutput,";;;\"Solve-Time:\";\"%i\";\n",solvetime);
						s_ivars.DBDatei.write(aszOutput,strlen(aszOutput));
						s_ivars.DBDatei.seekp(0,ios::end);
						s_ivars.DBDatei.close();
					}
				} else {
					VStrip(aszOutput);
					sprintf(aszOutput,"%s;\"%s\";\n",aszOutput,s_ivars.aszEngine);
					s_ivars.DBDatei.open(s_ivars.aszDBFile,ios::trunc | ios::out | ios::in);
					s_ivars.DBDatei.seekp(0,ios::beg);
					s_ivars.DBDatei.write(aszOutput,strlen(aszOutput));
					s_ivars.DBDatei.seekp(0,ios::end);
					fgets(aszOutput,5000,OldFile);
					VStrip(aszOutput);
					sprintf(aszOutput,"%s;\"time\";\"depth\"\n",aszOutput);
					s_ivars.DBDatei.write(aszOutput,strlen(aszOutput));
					s_ivars.DBDatei.seekp(0,ios::end);
					for (i = 0; i &lt; s_ivars.cPosCounter;i++) 
					{
						fgets(aszOutput,5000,OldFile);
						VStrip(aszOutput);
						if (s_ivars.apsInfo[i].cSolveTime&lt;=s_ivars.tmPerMove)
						{
							solved++;
							solvetime+=s_ivars.apsInfo[i].cSolveTime/1000;
							sprintf(aszOutput,"%s;\"%i\";\"%i\"\n",aszOutput,s_ivars.apsInfo[i].cSolveTime/1000,s_ivars.apsInfo[i].cSolveDepth);
						}
						else
						{
							solvetime+=s_ivars.tmPerMove/1000;
							sprintf(aszOutput,"%s;\"9999\";\"%i\"\n",aszOutput,s_ivars.apsInfo[i].cLastDepth);
						}
						s_ivars.DBDatei.write(aszOutput,strlen(aszOutput));
						s_ivars.DBDatei.seekp(0,ios::end);
					}
					fgets(aszOutput,5000,OldFile);
					VStrip(aszOutput);
					sprintf(aszOutput,"%s;\"%i\";\n",aszOutput,solved);
					s_ivars.DBDatei.write(aszOutput,strlen(aszOutput));
					s_ivars.DBDatei.seekp(0,ios::end);
					fgets(aszOutput,5000,OldFile);
					VStrip(aszOutput);
					sprintf(aszOutput,"%s;\"%i\";\n",aszOutput,solvetime);
					s_ivars.DBDatei.write(aszOutput,strlen(aszOutput));
					s_ivars.DBDatei.seekp(0,ios::end);
					s_ivars.DBDatei.close();
					fclose(OldFile);
				}
			}
		}
	}
}
BOOL FSummary(void)
{
	int	i;
	char hilfe[80];
	if (!s_ivars.fUseUCI) {
		if (s_ivars.fAnalyze)
			VSendToEngine("exit");
		else 
		{
			VSendToEngine("?");
		}
		VSendToEngine("force");
	} else {
		VSendToEngine("stop");
	}
	sprintf(s_ivars.aszOutput,"\nResult:   ");
	if (s_ivars.fError) {
		strcat(s_ivars.aszOutput,"ERROR!!");
		s_ivars.cError++;
	} else if (s_ivars.fCorrectAnswer) {
		strcat(s_ivars.aszOutput,"Success");
		s_ivars.cSolved++;
	} else {
		strcat(s_ivars.aszOutput,"Failure");
		s_ivars.cFailed++;
	}
	sprintf(hilfe,"   (%i of %i solved so far - %i",s_ivars.cSolved,s_ivars.cPosCounter+1,s_ivars.cSolved*100/(s_ivars.cPosCounter+1));
	strcat(s_ivars.aszOutput,hilfe);
	strcat(s_ivars.aszOutput,"%)");
	VWriteLogAndOutput();
	VWriteEmpty();
	if (s_ivars.fCorrectAnswer) {
		int	isol;
		s_ivars.apsInfo[s_ivars.cPosCounter].cSolveTime=s_ivars.tmFoundIn;
		sprintf(s_ivars.aszOutput,"Found in: %ld ms (%02d:%02d:%02d.%03d)\n",
			s_ivars.tmFoundIn,
			uHOUR_FROM_MILLI(s_ivars.tmFoundIn),
			uMIN_FROM_MILLI(s_ivars.tmFoundIn),
			uSEC_FROM_MILLI(s_ivars.tmFoundIn),
			uMILLI_FROM_MILLI(s_ivars.tmFoundIn));
		VWriteLogAndOutput();
		isol = s_ivars.tmFoundIn / 1000;
		if ((isol&gt;0) &amp;&amp; (s_ivars.tmFoundIn % 1000 == 0)) isol--;
		if (isol &lt; isolMAX)
			s_ivars.argsol[isol]++;
	}
	else s_ivars.apsInfo[s_ivars.cPosCounter].cSolveTime=s_ivars.tmPerMove+1;
	s_ivars.cPosCounter++;
	VWriteEmpty();
	s_ivars.aszOutput[0]=0;
	for (i = 0; i &lt; cbLINE - 1; i++)
		strcat(s_ivars.aszOutput,"-");
	VWriteLogAndOutput();
	VWriteEmpty();
	VWriteEmpty();
	return FNextTest();
}
void VProcess(void)
{
	int	i;
	sprintf(s_ivars.aszOutput,"\nEpd2Wb, Release 02/TM\n");
	VWriteLogAndOutput();
	sprintf(s_ivars.aszOutput,"original version by Bruce Moreland with some modifications by Thomas Mayer\n");
	VWriteLogAndOutput();
	sprintf(s_ivars.aszOutput,"epd2wb comes with ABSOLUTELY NO WARRANTY - released under GPL\n\n");
	VWriteLogAndOutput();
	if (s_ivars.fUseUCI==fFALSE) {
		VSendToEngine("xboard");
		if (!s_ivars.fPureProt1) VSendToEngine("protover 2");
		s_ivars.mode = modeFEATURE_TIMEOUT;
	} else {
		VSendToEngine("uci");
		s_ivars.mode = modeFEATURE_NOTIMEOUT;
	}
	s_ivars.tmEnd = TmNow() + 5000;
	SetEvent(s_ivars.heventStdinAck);
	for (;;) {
		int	csz;
		char	aszBuf[1024];
		char	aszVec[1024];
		char *	argsz[256];
		int	ibSecond;
		if (s_ivars.mode == modeFEATURE_TIMEOUT) {
			TM	tm;
			tm = TmNow();
			if ((tm &gt;= s_ivars.tmEnd) ||
				(WaitForSingleObject(s_ivars.heventStdinReady,
				s_ivars.tmEnd - tm) == WAIT_TIMEOUT)) {
				if (!FFeatureTimeout())
					return;
				continue;				}
		} else if (s_ivars.mode == modeTESTING) {
			TM	tm;
			DWORD	dwTimeout;
			tm = TmNow();
			dwTimeout = (s_ivars.fUseSt) ?
				INFINITE : s_ivars.tmEnd - tm;
			if ((tm &gt;= s_ivars.tmEnd) || (s_ivars.fStopAnalysis) || 
				(WaitForSingleObject(s_ivars.heventStdinReady,
				dwTimeout) == WAIT_TIMEOUT)) {
				if (!FSummary())
					return;
				continue;				}
		} else
			WaitForSingleObject(s_ivars.heventStdinReady, INFINITE);
		strcpy(aszBuf, s_ivars.aszInBuf);
		strcpy(aszVec, s_ivars.aszInBuf);
		csz = CszVectorizeCmd(aszVec, argsz, &amp;ibSecond);
		if (csz) {
			if ((!s_ivars.fUseUCI) || (strcmp(argsz[0],"info"))) {
				for (i = 0; c_argcmdEngine[i].sz != NULL; i++)
					if (!strcmp(c_argcmdEngine[i].sz, argsz[0])) {
						if (!(*c_argcmdEngine[i].pfn)(aszBuf + ibSecond,
							argsz, csz))
							return;
						break;
					}
			}
			if (s_ivars.mode == modeTESTING)
				if (((csz == 3) &amp;&amp; (!strcmp(argsz[1], "..."))) &amp;&amp; (!s_ivars.fUseUCI)) {
					VEngineMoved(argsz[2]); 
				}
				else {
					if ((s_ivars.fUseUCI) &amp;&amp; (!strcmp(argsz[0],"bestmove"))) {
						VEngineMoved(argsz[1]);
					} else {
						VAnalysisLine(argsz, csz);
					}
				}
		}
		SetEvent(s_ivars.heventStdinAck);
	}
}
void ShutdownSignalHandler(int signr)
{
	s_ivars.fQuit = fTRUE;
	if (s_ivars.fUseUCI) {
		VSendToEngine("stop");
	}
	if (s_ivars.fEngineStarted)
		VSendToEngine("quit");
    return;
}
LANG c_arglang[] = {
	"Czech",		'P',	'J',	'S',	'V',	'D',	'K',
	"Danish",		'B',	'S',	'L',	'T',	'D',	'K',
	"Dutch",		'O',	'P',	'L',	'T',	'D',	'K',
	"English",		'P',	'N',	'B',	'R',	'Q',	'K',
	"Estonian",		'P',	'R',	'O',	'V',	'L',	'K',
	"Finnish",		'P',	'R',	'L',	'T',	'D',	'K',
	"French",		'P',	'C',	'F',	'T',	'D',	'R',
	"German",		'B',	'S',	'L',	'T',	'D',	'K',
	"Hungarian",	'G',	'H',	'F',	'B',	'V',	'K',
	"Icelandic",	'P',	'R',	'B',	'H',	'D',	'K',
	"Italian",		'P',	'C',	'A',	'T',	'D',	'R',
	"Norwegian",	'B',	'S',	'L',	'T',	'D',	'K',
	"Polish",		'P',	'S',	'G',	'W',	'H',	'K',
	"Portuguese",	'P',	'C',	'B',	'T',	'D',	'R',
	"Romanian",		'P',	'C',	'N',	'T',	'D',	'R',
	"Spanish",		'P',	'C',	'A',	'T',	'D',	'R',
	"Swedish",		'B',	'S',	'L',	'T',	'D',	'K',
	NULL,
};
PLANG PlangFindLang(char * szLang)
{
	int	i;
	for (i = 0; c_arglang[i].szLang != NULL; i++)
		if (!strcmpi(c_arglang[i].szLang, szLang))
			return &amp;c_arglang[i];
	return NULL;
}
char * const c_aszUsage[] = {
	"Usage: epd2wb &lt;engine&gt; &lt;EPD&gt; &lt;seconds&gt; [flags]",
	"  -?      Usage",
	"  -a      Turns usage of analyze on by default (Prot. 1 - engines with analyze)",
	"  -b&lt;B&gt;   Name of the database file it should use - default=&lt;none&gt;",
	"  -c&lt;E&gt;   For UCI-engines, the file sets the parameters",
	"  -d      Dumps all input and output to the console",
	"  -e&lt;S&gt;   waits &lt;S&gt; econds after starting the engine before sending the first\n          command to it",
	"  -f&lt;F&gt;   Name of the logfile - else no logging !",
	"  -g&lt;x&gt;   Specifies that the analysis should stop when the solution is correct\n          for &lt;x&gt; ply's",
	"  -h&lt;y&gt;   Specifies that the analysis should stop when the solution is correct\n          and the score is above &lt;y&gt;",
	"  -i      Outputs engine information then stops",
	"  -j      Use UCI-1 commands ONLY !",
	"  -l&lt;L&gt;   Choose analysis input language",
	"  -n&lt;x&gt;   multiplys the time sent in st mode with x",
	"  -o      Skip protover for pure wb-prot 1",
	"  -p&lt;P&gt;   Path to the engine",
	"  -s&lt;D&gt;   Skip D analysis fields",
	"  -t      Uses Winboard \"st\" command to try to get old engines to work.",
	"  -u      Turns usage of setboard on by default (even Prot. 1 engines are used\n          then with setboard",
	"  -v&lt;T&gt;   Force to interpret time in c=centiseconds, s=seconds, t=tenthseconds,\n          m=milliseconds",
	"  -w&lt;S&gt;   Protover 1 for initialization wait period (in seconds) default 4",
	"  -x&lt;T&gt;   Protover 1 between test wait period (in seconds) default=1",
	"  -y      Use internal time control instead what the engine sends",
	"  -z      Ignore feature done=0 &amp; feature done=1",
	NULL,
};
void VUsage(void)
{
	int	i;
	for (i = 0; c_aszUsage[i] != NULL; i++)
		fprintf(stderr, "%s\n", c_aszUsage[i]);
	printf("\nLanguages:\n\n");
	for (i = 0; c_arglang[i].szLang != NULL; i++) {
		if ((i % 4 == 3) || (c_arglang[i + 1].szLang == NULL))
			fprintf(stderr, "%s\n", c_arglang[i].szLang);
		else
			fprintf(stderr, "%-20s", c_arglang[i].szLang);
	}
	if (s_ivars.fEngineStarted)
		VSendToEngine("quit");
	exit(1);
}
int main(int argc, char * argv[])
{
	DWORD	dw;
	int	iszArg;
	int	isz,i;
	char	aszLanguage[256];
    signal(SIGINT, ShutdownSignalHandler);              signal(SIGBREAK, ShutdownSignalHandler); 
    signal(SIGTERM, ShutdownSignalHandler);
	s_ivars.fDump = fFALSE;
	s_ivars.cSkip = 0;
	s_ivars.fEngineStarted = fFALSE;
	s_ivars.fPing = fFALSE;
	s_ivars.fSetboard = fFALSE;
	s_ivars.fAnalyze = fFALSE;
	s_ivars.fColor = fTRUE;
	s_ivars.fPureProt1 = fFALSE;
	s_ivars.fInternalTime = fFALSE;
	s_ivars.fUseUCI = fFALSE;
	s_ivars.fUCI1 = fFALSE;
	s_ivars.cPosCounter = 0;
	s_ivars.cIPTime = 0;
	s_ivars.aszEngine[0] = '\0';
	s_ivars.aszPath[0] = '\0';
	s_ivars.aszSuite[0] = '\0';
	s_ivars.aszDBFile[0] = '\0';
	s_ivars.aszUCIFile[0] = '\0';
	s_ivars.fDBon = fFALSE;
<a name="0"></a>	s_ivars.fUseSt = fFALSE;
	s_ivars.tmWaitInit = 4000;			s_ivars.tmWaitPos = 1000;		<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	s_ivars.fFindInfo = fFALSE;
	s_ivars.fLogOn = fFALSE;
	s_ivars.fIgnoreDone = fFALSE;
	s_ivars.fQuit = fFALSE;
	s_ivars.fWaitAfterStart = fFALSE;
	s_ivars.cMultiST=1;
	s_ivars.fStopPly=fFALSE;
	s_ivars.fStopScore=fFALSE;
	s_ivars.fStopAnalysis=fFALSE;
	strcpy(aszLanguage, "English");
	for (isz = 1, iszArg = 0; isz &lt; argc; isz++) {</b></font>
		char * sz = argv[isz];
		switch (*sz++) {
		case '/':
		case '-':
			switch (*sz++) {
			case 'a':
				s_ivars.fAnalyze = fTRUE;
				break;
			case 'u':
				s_ivars.fSetboard = fTRUE;
				break;
			case 'd':
				s_ivars.fDump = fTRUE;
				break;
			case 'i':
				s_ivars.fFindInfo = fTRUE;
				break;
			case 'l':
				if (*sz != '\0')
					strcpy(aszLanguage, sz);
				else if (isz + 1 == argc)
					VUsage();
				else if ((argv[++isz][0] != '-') &amp;&amp;
					(argv[isz][0] != '/'))
					strcpy(aszLanguage, argv[isz]);
				else
					VUsage();
				break;
			case 's':
				if (*sz != '\0') {
					if (!isdigit(*sz))
						VUsage();
					s_ivars.cSkip = atoi(sz);
				} else if (isz + 1 == argc)
					VUsage();
				else if (isdigit(argv[++isz][0]))
					s_ivars.cSkip = atoi(argv[isz]);
				else
					VUsage();
				break;
			case 't':
				s_ivars.fUseSt = fTRUE;
				break;
			case 'w':
				if (*sz != '\0') {
					if (!isdigit(*sz))
						VUsage();
					s_ivars.tmWaitInit = atoi(sz) * 1000;
				} else if (isz + 1 == argc)
					VUsage();
				else if (isdigit(argv[++isz][0]))
					s_ivars.tmWaitInit = atoi(argv[isz]) * 1000;
				else
					VUsage();
				break;
			case 'e':
				if (*sz != '\0') {
					if (!isdigit(*sz))
						VUsage();
					s_ivars.fWaitAfterStart = fTRUE;
					s_ivars.cWaitAfterStart = atoi(sz) * 1000;
				} else if (isz + 1 == argc)
					VUsage();
				else if (isdigit(argv[++isz][0])) {
					s_ivars.fWaitAfterStart = fTRUE;
					s_ivars.cWaitAfterStart = atoi(argv[isz]) * 1000;
				}
				else
					VUsage();
				break;
			case 'g':
				if (*sz != '\0') {
					if (!isdigit(*sz))
						VUsage();
					s_ivars.cPlys = atoi(sz);
					if (s_ivars.cPlys&gt;0) {
						s_ivars.fStopPly = fTRUE;
					}
				} else if (isz + 1 == argc)
					VUsage();
				else if (isdigit(argv[++isz][0])) {
					s_ivars.cPlys = atoi(argv[isz]);
					if (s_ivars.cPlys&gt;0) {
						s_ivars.fStopPly = fTRUE;
					}
				}
				else
					VUsage();
				break;
			case 'h':
				if (*sz != '\0') {
					if (!isdigit(*sz))
						VUsage();
					s_ivars.cScore = atoi(sz);
					if (s_ivars.cScore&gt;0) {
						s_ivars.fStopScore = fTRUE;
					}
				} else if (isz + 1 == argc)
					VUsage();
				else if (isdigit(argv[++isz][0])) {
					s_ivars.cScore = atoi(argv[isz]);
					if (s_ivars.cScore&gt;0) {
						s_ivars.fStopScore = fTRUE;
					}
				}
				else
					VUsage();
				break;
			case 'n':
				if (*sz != '\0') {
					if (!isdigit(*sz))
						VUsage();
					s_ivars.cMultiST = atoi(sz) * 1000;
				} else if (isz + 1 == argc)
					VUsage();
				else if (isdigit(argv[++isz][0]))
					s_ivars.cMultiST = atoi(argv[isz]) * 1000;
				else
					VUsage();
				break;
			case 'x':
				if (*sz != '\0') {
					if (!isdigit(*sz))
						VUsage();
					s_ivars.tmWaitPos = atoi(sz) * 1000;
				} else if (isz + 1 == argc)
					VUsage();
				else if (isdigit(argv[++isz][0]))
					s_ivars.tmWaitPos = atoi(argv[isz]) * 1000;
				else
					VUsage();
				break;
			case 'p':
				if (*sz != '\0') {
					strcpy(s_ivars.aszPath,sz);
				}
				else {
					if (isz + 1 == argc) {
						VUsage();
					}
					else {
						if ((argv[++isz][0] != '-') &amp;&amp; (argv[isz][0] != '/')) {
							strcpy(s_ivars.aszPath,argv[isz]);
						}
						else {
							VUsage();
						}
					}
				}
				i=strlen(s_ivars.aszPath);
				if ((s_ivars.aszPath[i]) != 92) {
					s_ivars.aszPath[i]=92;
					s_ivars.aszPath[i+1]=0;
				}
				break;
			case 'c':
				if (*sz != '\0') {
					strcpy(s_ivars.aszUCIFile,sz);
				}
				else {
					if (isz + 1 == argc) {
						VUsage();
					}
					else {
						if ((argv[++isz][0] != '-') &amp;&amp; (argv[isz][0] != '/')) {
							strcpy(s_ivars.aszUCIFile,argv[isz]);
						}
						else {
							VUsage();
						}
					}
				}
				s_ivars.fUseUCI=fTRUE;
				s_ivars.UCIoptions=0;
				s_ivars.cIPTime=4;
				ReadUCIOptions();
				break;
			case 'f':
				if (*sz != '\0') {
					strcpy(s_ivars.aszLogFile,sz);
				}
				else {
					if (isz + 1 == argc) {
						VUsage();
					}
					else {
						if ((argv[++isz][0] != '-') &amp;&amp; (argv[isz][0] != '/')) {
							strcpy(s_ivars.aszLogFile,argv[isz]);
						}
						else {
							VUsage();
						}
					}
				}
				s_ivars.fLogOn=fTRUE;
				break;
			case 'b':
				if (*sz != '\0') {
					strcpy(s_ivars.aszDBFile,sz);
				}
				else {
					if (isz + 1 == argc) {
						VUsage();
					}
					else {
						if ((argv[++isz][0] != '-') &amp;&amp; (argv[isz][0] != '/')) {
							strcpy(s_ivars.aszDBFile,argv[isz]);
						}
						else {
							VUsage();
						}
					}
				}
				s_ivars.fDBon=fTRUE;
				break;
			case 'y':
				s_ivars.fInternalTime = fTRUE;
				break;
			case 'j':
				s_ivars.fUCI1 = fTRUE;
				break;
			case 'v':
				if (*sz != '\0') {
					if ((sz[1] != 'c') &amp;&amp; (sz[1] != 's') &amp;&amp; (sz[01] != 't') &amp;&amp; (sz[1] != 'm')) {
						VUsage();
						break;
					}
					if (sz[1]=='c') s_ivars.cIPTime=1;
					else if (sz[1]=='s') s_ivars.cIPTime=2;
					else if (sz[1]=='m') s_ivars.cIPTime=4;
					else s_ivars.cIPTime=3;
				} else if (isz + 1 == argc)
					VUsage();
				else {
					isz++;
					sz=argv[isz];
					if ((sz[0] != 'c') &amp;&amp; (sz[0] != 's') &amp;&amp; (sz[0] != 't') &amp;&amp; (sz[0] != 'm')) {
						VUsage();
						break;
					}
					if (sz[0]=='c') s_ivars.cIPTime=1;
					else if (sz[0]=='s') s_ivars.cIPTime=2;
					else if (sz[0]=='m') s_ivars.cIPTime=4;
					else s_ivars.cIPTime=3;
				}
				break;
			case 'o':
				s_ivars.fPureProt1=fTRUE;
				break;
			case 'z':
				s_ivars.fIgnoreDone=fTRUE;
				break;
			default:
				VUsage();
			}
			break;
		default:
			switch (iszArg++) {
			case 0:
				strcpy(s_ivars.aszEngine, argv[isz]);
				break;
			case 1:
				if ((s_ivars.pfI = fopen(argv[isz], "r")) == NULL) {
					perror(argv[isz]);
					exit(1);
				}
				s_ivars.cPosAbs=fGetAbsPos(argv[isz]);
				strcpy(s_ivars.aszSuite, argv[isz]);
				break;
			case 2:
				s_ivars.tmPerMove = atoi(argv[isz]) * 1000;
				break;
			default:
				VUsage();
			}
			break;
		}
	}
	if (iszArg &lt; 3)
		VUsage();
	if ((s_ivars.plang = PlangFindLang(aszLanguage)) == NULL)
		VUsage();
	if (!FStartProcess(&amp;s_ivars.cp, s_ivars.aszEngine, s_ivars.aszPath))
		VDisplayLastError("Can't start engine");
	else s_ivars.fEngineStarted = fTRUE;
	if (s_ivars.fUseSt)					s_ivars.tmWaitInit = 0;
	if (s_ivars.fLogOn) {
		s_ivars.LOGDatei.open(s_ivars.aszLogFile,ios::trunc | ios::out | ios::in);
		s_ivars.LOGDatei.seekp(0,ios::beg);
		s_ivars.fLogOpen=fTRUE;
	}
	s_ivars.plangEnglish = PlangFindLang("English");
	Assert(s_ivars.plangEnglish != NULL);
	s_ivars.heventStdinReady = CreateEvent(NULL, FALSE, FALSE, NULL);
	s_ivars.heventStdinAck = CreateEvent(NULL, FALSE, FALSE, NULL);
	s_ivars.heventStdinPing = CreateEvent(NULL, FALSE, FALSE, NULL);
	CreateThread(NULL, 0, DwInput, NULL, 0, &amp;dw);
	if (s_ivars.fWaitAfterStart) {
		Sleep(s_ivars.cWaitAfterStart);
	}
	VProcess();
	if (!s_ivars.fFindInfo)
		VDumpResults();
	VSendToEngine("quit");
	s_ivars.fQuit = fTRUE;
	VKillTime(2000);
	if (s_ivars.fLogOpen) s_ivars.LOGDatei.close();
//	DestroyChildProcess(&amp;s_ivars.cp);		return 1;
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
