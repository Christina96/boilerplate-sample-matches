<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for layer.hpp &amp; im2col_layer.hpp</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for layer.hpp &amp; im2col_layer.hpp
      </h3>
<h1 align="center">
        10.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>layer.hpp (6.451613%)<th>im2col_layer.hpp (31.428572%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(191-208)<td><a href="#" name="0">(29-31)</a><td align="center"><font color="#ff0000">22</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>layer.hpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifndef CAFFE_LAYER_H_
2 #define CAFFE_LAYER_H_
3 #include &lt;algorithm&gt;
4 #include &lt;string&gt;
5 #include &lt;vector&gt;
6 #include "caffe/blob.hpp"
7 #include "caffe/common.hpp"
8 #include "caffe/layer_factory.hpp"
9 #include "caffe/proto/caffe.pb.h"
10 #include "caffe/util/math_functions.hpp"
11 namespace boost { class mutex; }
12 namespace caffe {
13 template &lt;typename Dtype&gt;
14 class Layer {
15  public:
16   explicit Layer(const LayerParameter&amp; param)
17     : layer_param_(param) {
18       phase_ = param.phase();
19       if (layer_param_.blobs_size() &gt; 0) {
20         blobs_.resize(layer_param_.blobs_size());
21         for (int i = 0; i &lt; layer_param_.blobs_size(); ++i) {
22           blobs_[i].reset(new Blob&lt;Dtype&gt;());
23           blobs_[i]-&gt;FromProto(layer_param_.blobs(i));
24         }
25       }
26     }
27   virtual ~Layer() {}
28   void SetUp(const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; bottom,
29       const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; top) {
30     CheckBlobCounts(bottom, top);
31     LayerSetUp(bottom, top);
32     Reshape(bottom, top);
33     SetLossWeights(top);
34   }
35   virtual void LayerSetUp(const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; bottom,
36       const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; top) {}
37   virtual void Reshape(const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; bottom,
38       const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; top) = 0;
39   inline Dtype Forward(const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; bottom,
40       const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; top);
41   inline void Backward(const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; top,
42       const vector&lt;bool&gt;&amp; propagate_down,
43       const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; bottom);
44   vector&lt;shared_ptr&lt;Blob&lt;Dtype&gt; &gt; &gt;&amp; blobs() {
45     return blobs_;
46   }
47   const LayerParameter&amp; layer_param() const { return layer_param_; }
48   virtual void ToProto(LayerParameter* param, bool write_diff = false);
49   inline Dtype loss(const int top_index) const {
50     return (loss_.size() &gt; top_index) ? loss_[top_index] : Dtype(0);
51   }
52   inline void set_loss(const int top_index, const Dtype value) {
53     if (loss_.size() &lt;= top_index) {
54       loss_.resize(top_index + 1, Dtype(0));
55     }
56     loss_[top_index] = value;
57   }
58 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  virtual inline const char* type() const { return ""; }
59   virtual inline int ExactNumBottomBlobs() const { return -1; }
60   virtual inline int MinBottomBlobs() const { return -1; }</b></font>
61   virtual inline int MaxBottomBlobs() const { return -1; }
62   virtual inline int ExactNumTopBlobs() const { return -1; }
63   virtual inline int MinTopBlobs() const { return -1; }
64   virtual inline int MaxTopBlobs() const { return -1; }
65   virtual inline bool EqualNumBottomTopBlobs() const { return false; }
66   virtual inline bool AutoTopBlobs() const { return false; }
67   virtual inline bool AllowForceBackward(const int bottom_index) const {
68     return true;
69   }
70   inline bool param_propagate_down(const int param_id) {
71     return (param_propagate_down_.size() &gt; param_id) ?
72         param_propagate_down_[param_id] : false;
73   }
74   inline void set_param_propagate_down(const int param_id, const bool value) {
75     if (param_propagate_down_.size() &lt;= param_id) {
76       param_propagate_down_.resize(param_id + 1, true);
77     }
78     param_propagate_down_[param_id] = value;
79   }
80  protected:
81   LayerParameter layer_param_;
82   Phase phase_;
83   vector&lt;shared_ptr&lt;Blob&lt;Dtype&gt; &gt; &gt; blobs_;
84   vector&lt;bool&gt; param_propagate_down_;
85   vector&lt;Dtype&gt; loss_;
86   virtual void Forward_cpu(const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; bottom,
87       const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; top) = 0;
88   virtual void Forward_gpu(const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; bottom,
89       const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; top) {
90     return Forward_cpu(bottom, top);
91   }
92   virtual void Backward_cpu(const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; top,
93       const vector&lt;bool&gt;&amp; propagate_down,
94       const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; bottom) = 0;
95   virtual void Backward_gpu(const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; top,
96       const vector&lt;bool&gt;&amp; propagate_down,
97       const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; bottom) {
98     Backward_cpu(top, propagate_down, bottom);
99   }
100   virtual void CheckBlobCounts(const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; bottom,
101                                const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; top) {
102     if (ExactNumBottomBlobs() &gt;= 0) {
103       CHECK_EQ(ExactNumBottomBlobs(), bottom.size())
104           &lt;&lt; type() &lt;&lt; " Layer takes " &lt;&lt; ExactNumBottomBlobs()
105           &lt;&lt; " bottom blob(s) as input.";
106     }
107     if (MinBottomBlobs() &gt;= 0) {
108       CHECK_LE(MinBottomBlobs(), bottom.size())
109           &lt;&lt; type() &lt;&lt; " Layer takes at least " &lt;&lt; MinBottomBlobs()
110           &lt;&lt; " bottom blob(s) as input.";
111     }
112     if (MaxBottomBlobs() &gt;= 0) {
113       CHECK_GE(MaxBottomBlobs(), bottom.size())
114           &lt;&lt; type() &lt;&lt; " Layer takes at most " &lt;&lt; MaxBottomBlobs()
115           &lt;&lt; " bottom blob(s) as input.";
116     }
117     if (ExactNumTopBlobs() &gt;= 0) {
118       CHECK_EQ(ExactNumTopBlobs(), top.size())
119           &lt;&lt; type() &lt;&lt; " Layer produces " &lt;&lt; ExactNumTopBlobs()
120           &lt;&lt; " top blob(s) as output.";
121     }
122     if (MinTopBlobs() &gt;= 0) {
123       CHECK_LE(MinTopBlobs(), top.size())
124           &lt;&lt; type() &lt;&lt; " Layer produces at least " &lt;&lt; MinTopBlobs()
125           &lt;&lt; " top blob(s) as output.";
126     }
127     if (MaxTopBlobs() &gt;= 0) {
128       CHECK_GE(MaxTopBlobs(), top.size())
129           &lt;&lt; type() &lt;&lt; " Layer produces at most " &lt;&lt; MaxTopBlobs()
130           &lt;&lt; " top blob(s) as output.";
131     }
132     if (EqualNumBottomTopBlobs()) {
133       CHECK_EQ(bottom.size(), top.size())
134           &lt;&lt; type() &lt;&lt; " Layer produces one top blob as output for each "
135           &lt;&lt; "bottom blob input.";
136     }
137   }
138   inline void SetLossWeights(const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; top) {
139     const int num_loss_weights = layer_param_.loss_weight_size();
140     if (num_loss_weights) {
141       CHECK_EQ(top.size(), num_loss_weights) &lt;&lt; "loss_weight must be "
142           "unspecified or specified once per top blob.";
143       for (int top_id = 0; top_id &lt; top.size(); ++top_id) {
144         const Dtype loss_weight = layer_param_.loss_weight(top_id);
145         if (loss_weight == Dtype(0)) { continue; }
146         this-&gt;set_loss(top_id, loss_weight);
147         const int count = top[top_id]-&gt;count();
148         Dtype* loss_multiplier = top[top_id]-&gt;mutable_cpu_diff();
149         caffe_set(count, loss_weight, loss_multiplier);
150       }
151     }
152   }
153  private:
154   DISABLE_COPY_AND_ASSIGN(Layer);
155 };  
156 template &lt;typename Dtype&gt;
157 inline Dtype Layer&lt;Dtype&gt;::Forward(const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; bottom,
158     const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; top) {
159   Dtype loss = 0;
160   Reshape(bottom, top);
161   switch (Caffe::mode()) {
162   case Caffe::CPU:
163     Forward_cpu(bottom, top);
164     for (int top_id = 0; top_id &lt; top.size(); ++top_id) {
165       if (!this-&gt;loss(top_id)) { continue; }
166       const int count = top[top_id]-&gt;count();
167       const Dtype* data = top[top_id]-&gt;cpu_data();
168       const Dtype* loss_weights = top[top_id]-&gt;cpu_diff();
169       loss += caffe_cpu_dot(count, data, loss_weights);
170     }
171     break;
172   case Caffe::GPU:
173     Forward_gpu(bottom, top);
174 #ifndef CPU_ONLY
175     for (int top_id = 0; top_id &lt; top.size(); ++top_id) {
176       if (!this-&gt;loss(top_id)) { continue; }
177       const int count = top[top_id]-&gt;count();
178       const Dtype* data = top[top_id]-&gt;gpu_data();
179       const Dtype* loss_weights = top[top_id]-&gt;gpu_diff();
180       Dtype blob_loss = 0;
181       caffe_gpu_dot(count, data, loss_weights, &amp;blob_loss);
182       loss += blob_loss;
183     }
184 #endif
185     break;
186   default:
187     LOG(FATAL) &lt;&lt; "Unknown caffe mode.";
188   }
189   return loss;
190 }
191 template &lt;typename Dtype&gt;
192 inline void Layer&lt;Dtype&gt;::Backward(const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; top,
193     const vector&lt;bool&gt;&amp; propagate_down,
194     const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; bottom) {
195   switch (Caffe::mode()) {
196   case Caffe::CPU:
197     Backward_cpu(top, propagate_down, bottom);
198     break;
199   case Caffe::GPU:
200     Backward_gpu(top, propagate_down, bottom);
201     break;
202   default:
203     LOG(FATAL) &lt;&lt; "Unknown caffe mode.";
204   }
205 }
206 template &lt;typename Dtype&gt;
207 void Layer&lt;Dtype&gt;::ToProto(LayerParameter* param, bool write_diff) {
208   param-&gt;Clear();
209   param-&gt;CopyFrom(layer_param_);
210   param-&gt;clear_blobs();
211   for (int i = 0; i &lt; blobs_.size(); ++i) {
212     blobs_[i]-&gt;ToProto(param-&gt;add_blobs(), write_diff);
213   }
214 }
215 }  
#endif  </pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>im2col_layer.hpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifndef CAFFE_IM2COL_LAYER_HPP_
2 #define CAFFE_IM2COL_LAYER_HPP_
3 #include &lt;vector&gt;
4 #include "caffe/blob.hpp"
5 #include "caffe/layer.hpp"
6 #include "caffe/proto/caffe.pb.h"
7 namespace caffe {
8 template &lt;typename Dtype&gt;
9 class Im2colLayer : public Layer&lt;Dtype&gt; {
10  public:
11   explicit Im2colLayer(const LayerParameter&amp; param)
12       : Layer&lt;Dtype&gt;(param) {}
13   virtual void LayerSetUp(const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; bottom,
14       const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; top);
15 <a name="0"></a>  virtual void Reshape(const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; bottom,
16       const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; top);
17 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  virtual inline const char* type() const { return "Im2col"; }
18   virtual inline int ExactNumBottomBlobs() const { return 1; }
19   virtual inline int ExactNumTopBlobs() const { return 1; }</b></font>
20  protected:
21   virtual void Forward_cpu(const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; bottom,
22       const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; top);
23   virtual void Forward_gpu(const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; bottom,
24       const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; top);
25   virtual void Backward_cpu(const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; top,
26       const vector&lt;bool&gt;&amp; propagate_down, const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; bottom);
27   virtual void Backward_gpu(const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; top,
28       const vector&lt;bool&gt;&amp; propagate_down, const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; bottom);
29   Blob&lt;int&gt; kernel_shape_;
30   Blob&lt;int&gt; stride_;
31   Blob&lt;int&gt; pad_;
32   Blob&lt;int&gt; dilation_;
33   int num_spatial_axes_;
34   int bottom_dim_;
35   int top_dim_;
36   int channel_axis_;
37   int num_;
38   int channels_;
39   bool force_nd_im2col_;
40 };
41 }  
#endif  </pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
