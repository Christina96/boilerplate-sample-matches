
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 21.40750105351875%, Tokens: 12, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-agmattr.cpp</h3>
            <pre><code>1  #include "stdafx.h"
2  #include "agmattr.h"
3  #include "Snap.h"
4  #include "agm.h"
5  void TCesna::RandomInit(const int InitComs) {
6    F.Gen(G->GetNodes());
7    SumFV.Gen(InitComs);
8    NumComs = InitComs;
9    for (int u = 0; u < F.Len(); u++) {
10      int Mem = G->GetNI(u).GetDeg();
11      if (Mem > 10) { Mem = 10; }
12      for (int c = 0; c < Mem; c++) {
13        int CID = Rnd.GetUniDevInt(InitComs);
14        AddCom(u, CID, Rnd.GetUniDev());
15      }
16    }
17    for (int c = 0; c < SumFV.Len(); c++) {
18      if (SumFV[c] == 0.0) {
19        int UID = Rnd.GetUniDevInt(G->GetNodes());
20        AddCom(UID, c, Rnd.GetUniDev());
21      }
22    }
23    InitW();
24  }
25  void TCesna::NeighborComInit(const int InitComs) {
26    TFltIntPrV NIdPhiV(F.Len(), 0);
27    TCesnaUtil::GetNIdPhiV<PUNGraph>(G, NIdPhiV);
28    NeighborComInit(NIdPhiV, InitComs);
29  }
30  void TCesna::NeighborComInit(TFltIntPrV& NIdPhiV, const int InitComs) {
31    NIdPhiV.Sort(true);
32    F.Gen(G->GetNodes());
33    SumFV.Gen(InitComs);
34    NumComs = InitComs;
35    TIntSet InvalidNIDS(F.Len());
36    TIntV ChosenNIDV(InitComs, 0); 
37    int CurCID = 0;
38    for (int ui = 0; ui < NIdPhiV.Len(); ui++) {
39      int UID = NIdPhiV[ui].Val2;
40      fflush(stdout);
41      if (InvalidNIDS.IsKey(UID)) { continue; }
42      ChosenNIDV.Add(UID); 
43      AddCom(UID, CurCID, 1.0);
<span onclick='openModal()' class='match'>44      TUNGraph::TNodeI NI = G->GetNI(UID);
45      fflush(stdout);
46      for (int e = 0; e < NI.GetDeg(); e++) {
47        AddCom(NI.GetNbrNId(e), CurCID, 1.0);
48      }
49      for (int e = 0; e < NI.GetDeg(); e++) {
</span>50        InvalidNIDS.AddKey(NI.GetNbrNId(e));
51      }
52      CurCID++;
53      fflush(stdout);
54      if (CurCID >= NumComs) { break;  }
55    }
56    if (NumComs > CurCID) {
57      printf("%d communities needed to fill randomly\n", NumComs - CurCID);
58    }
59    for (int c = 0; c < SumFV.Len(); c++) {
60      if (SumFV[c] == 0.0) {
61        int ComSz = 10;
62        for (int u = 0; u < ComSz; u++) {
63          int UID = Rnd.GetUniDevInt(G->GetNodes());
64          AddCom(UID, c, Rnd.GetUniDev());
65        }
66      }
67    }
68    InitW();
69  }
70  void TCesna::SetCmtyVV(const TVec<TIntV>& CmtyVV) {
71    F.Gen(G->GetNodes());
72    SumFV.Gen(CmtyVV.Len());
73    NumComs = CmtyVV.Len();
74    InitW();
75    for (int c = 0; c < CmtyVV.Len(); c++) {
76      for (int u = 0; u < CmtyVV[c].Len(); u++) {
77        int UID = CmtyVV[c][u];
78        if (! NIDToIdx.IsKey(UID)) { continue; }
79        AddCom(NIDToIdx.GetKeyId(UID), c, 1.0);
80      }
81    }
82  }
83  void TCesna::SetGraph(const PUNGraph& GraphPt, const THash<TInt, TIntV>& NIDAttrH) {
84    HOVIDSV.Gen(GraphPt->GetNodes());  
85    HOKIDSV.Gen(GraphPt->GetNodes());  
86    X.Gen(GraphPt->GetNodes());
87    TIntV NIDV;
88    GraphPt->GetNIdV(NIDV);
89    NIDToIdx.Gen(NIDV.Len());
90    NIDToIdx.AddKeyV(NIDV);
91    printf("rearrage nodes\n");
92    G = TSnap::GetSubGraph(GraphPt, NIDV, true);
93    for (int nid = 0; nid < G->GetNodes(); nid++) {
94      IAssert(G->IsNode(nid)); 
95    }
96    TSnap::DelSelfEdges(G);
97    PNoCom = 1.0 / (double) G->GetNodes();
98    DoParallel = false;
99    if (1.0 / PNoCom > sqrt(TFlt::Mx)) { PNoCom = 0.99 / sqrt(TFlt::Mx); } 
100    NegWgt = 1.0;
101    int NumAttr = 0;
102    for (int u = 0; u < NIDAttrH.Len(); u++) {
103      int UID = NIDAttrH.GetKey(u);
104      if (! NIDToIdx.IsKey(UID)) { continue; }
105      X[NIDToIdx.GetKeyId(UID)].Gen(NIDAttrH[u].Len());
106      for (int k = 0; k < NIDAttrH[u].Len(); k++) {
107        int KID = NIDAttrH[u][k];
108        IAssert (KID >= 0);
109        X[NIDToIdx.GetKeyId(UID)].AddKey(KID);
110        if (NumAttr < KID + 1) { NumAttr = KID + 1; } 
111      }
112    }
113    Attrs = NumAttr;
114    InitW();
115  }
116  double TCesna::Likelihood(const bool _DoParallel) { 
117    TExeTm ExeTm;
118    double L = 0.0;
119    if (_DoParallel) {
120    #pragma omp parallel for 
121      for (int u = 0; u < F.Len(); u++) {
122        double LU = LikelihoodForRow(u);
123        #pragma omp atomic
124          L += LU;
125      }
126    }
127    else {
128      for (int u = 0; u < F.Len(); u++) {
129        double LU = LikelihoodForRow(u);
130          L += LU;
131      }
132    }
133    return L;
134  }
135  double TCesna::LikelihoodForRow(const int UID) {
136    return LikelihoodForRow(UID, F[UID]);
137  }
138  double TCesna::LikelihoodForRow(const int UID, const TIntFltH& FU) {
139    double L = 0.0;
140    TFltV HOSumFV; 
141    if (HOVIDSV[UID].Len() > 0) {
142      HOSumFV.Gen(SumFV.Len());
143      for (int e = 0; e < HOVIDSV[UID].Len(); e++) {
144        for (int c = 0; c < SumFV.Len(); c++) {
145          HOSumFV[c] += GetCom(HOVIDSV[UID][e], c);
146        }
147      }
148    }
149    TUNGraph::TNodeI NI = G->GetNI(UID);
150    for (int e = 0; e < NI.GetDeg(); e++) {
151      int v = NI.GetNbrNId(e);
152      if (v == UID) { continue; }
153      if (HOVIDSV[UID].IsKey(v)) { continue; }
154      L += log (1.0 - Prediction(FU, F[v])) + NegWgt * DotProduct(FU, F[v]);
155    }
156    for (TIntFltH::TIter HI = FU.BegI(); HI < FU.EndI(); HI++) {
157      double HOSum = HOVIDSV[UID].Len() > 0?  HOSumFV[HI.GetKey()].Val: 0.0;
158      L -= NegWgt * (SumFV[HI.GetKey()] - HOSum - GetCom(UID, HI.GetKey())) * HI.GetDat();
159    }
160    if (RegCoef > 0.0) { 
161      L -= RegCoef * Sum(FU);
162    }
163    if (RegCoef < 0.0) { 
164      L += RegCoef * Norm2(FU);
165    }
166    L *= (1.0 - WeightAttr);
167    for (int k = 0; k < Attrs; k++) {
168      if (HOKIDSV[UID].IsKey(k)) { continue; }
169      L += WeightAttr * LikelihoodAttrKForRow(UID, k, FU);
170    }
171    return L;
172  }
173  double TCesna::LikelihoodAttrKForRow(const int UID, const int K, const TIntFltH& FU, const TFltV& WK) {
174    double Prob = PredictAttrK(FU, WK);
175    double L = 0.0;
176    if (GetAttr(UID, K)) { 
177      L = Prob == 0.0? -100.0: log(Prob);
178    } else {
179      L = Prob == 1.0? -100.0: log(1.0 - Prob);
180    }
181    return L;
182  }
183  void TCesna::GradientForRow(const int UID, TIntFltH& GradU, const TIntSet& CIDSet) {
184    GradU.Gen(CIDSet.Len());
185    TFltV HOSumFV; 
186    if (HOVIDSV[UID].Len() > 0) {
187      HOSumFV.Gen(SumFV.Len());
188      for (int e = 0; e < HOVIDSV[UID].Len(); e++) {
189        for (int c = 0; c < SumFV.Len(); c++) {
190          HOSumFV[c] += GetCom(HOVIDSV[UID][e], c);
191        }
192      }
193    }
194    TUNGraph::TNodeI NI = G->GetNI(UID);
195    int Deg = NI.GetDeg();
196    TFltV PredV(Deg), GradV(CIDSet.Len());
197    TIntV CIDV(CIDSet.Len());
198    for (int e = 0; e < Deg; e++) {
199      if (NI.GetNbrNId(e) == UID) { continue; }
200      if (HOVIDSV[UID].IsKey(NI.GetNbrNId(e))) { continue; }
201      PredV[e] = Prediction(UID, NI.GetNbrNId(e));
202    }
203    for (int c = 0; c < CIDSet.Len(); c++) {
204      int CID = CIDSet.GetKey(c);
205      double Val = 0.0;
206      for (int e = 0; e < Deg; e++) {
207        int VID = NI.GetNbrNId(e);
208        if (VID == UID) { continue; }
209        if (HOVIDSV[UID].IsKey(VID)) { continue; }
210        Val += PredV[e] * GetCom(VID, CID) / (1.0 - PredV[e]) + NegWgt * GetCom(VID, CID);
211      }
212      double HOSum = HOVIDSV[UID].Len() > 0?  HOSumFV[CID].Val: 0.0;
213      Val -= NegWgt * (SumFV[CID] - HOSum - GetCom(UID, CID));
214      CIDV[c] = CID;
215      GradV[c] = Val;
216    }
217    if (RegCoef > 0.0) { 
218      for (int c = 0; c < GradV.Len(); c++) {
219        GradV[c] -= RegCoef; 
220      }
221    }
222    if (RegCoef < 0.0) { 
223      for (int c = 0; c < GradV.Len(); c++) {
224        GradV[c] += 2 * RegCoef * GetCom(UID, CIDV[c]); 
225      }
226    }
227    for (int c = 0; c < GradV.Len(); c++) {
228      GradV[c] *= (1.0 - WeightAttr);
229    }
230    TFltV AttrPredV(Attrs);
231    for (int k = 0; k < Attrs; k++) {
232      if (HOKIDSV[UID].IsKey(k)) { continue; }
233      AttrPredV[k] = PredictAttrK(F[UID], W[k]);
234    }
235    for (int c = 0; c < GradV.Len(); c++) {
236      for (int k = 0; k < Attrs; k++) {
237        if (HOKIDSV[UID].IsKey(k)) { continue; }
238        GradV[c] += WeightAttr * (GetAttr(UID, k) - AttrPredV[k]) * GetW(CIDV[c], k);
239      }
240    }
241    for (int c = 0; c < GradV.Len(); c++) {
242      if (GetCom(UID, CIDV[c]) == 0.0 && GradV[c] < 0.0) { continue; }
243      if (fabs(GradV[c]) < 0.0001) { continue; }
244      GradU.AddDat(CIDV[c], GradV[c]);
245    }
246    for (int c = 0; c < GradU.Len(); c++) {
247      if (GradU[c] >= 10) { GradU[c] = 10; }
248      if (GradU[c] <= -10) { GradU[c] = -10; }
249      IAssert(GradU[c] >= -10);
250    }
251  }
252  void TCesna::GetCmtyVV(TVec<TIntV>& CmtyVV) {
253    TVec<TFltV> TmpV;
254    GetCmtyVV(CmtyVV, TmpV, sqrt(2.0 * (double) G->GetEdges() / G->GetNodes() / G->GetNodes()), 3);
255  }
256  void TCesna::GetCmtyVV(TVec<TIntV>& CmtyVV, TVec<TFltV>& Wck, const double Thres, const int MinSz) {
257    CmtyVV.Gen(NumComs, 0);
258    Wck.Gen(NumComs, 0);
259    TIntFltH CIDSumFH(NumComs);
260    for (int c = 0; c < SumFV.Len(); c++) {
261      CIDSumFH.AddDat(c, SumFV[c]);
262    }
263    CIDSumFH.SortByDat(false);
264    for (int c = 0; c < NumComs; c++) {
265      int CID = CIDSumFH.GetKey(c);
266      TIntFltH NIDFucH(F.Len() / 10);
267      TIntV CmtyV;
268      IAssert(SumFV[CID] == CIDSumFH.GetDat(CID));
269      if (SumFV[CID] < Thres) { continue; }
270      for (int u = 0; u < F.Len(); u++) {
271        int NID = NIDToIdx[u];
272        if (GetCom(u, CID) >= Thres) { NIDFucH.AddDat(NID, GetCom(u, CID)); }
273      }
274      NIDFucH.SortByDat(false);
275      NIDFucH.GetKeyV(CmtyV);
276      if (CmtyV.Len() < MinSz) { continue; }
277      CmtyVV.Add(CmtyV); 
278      TFltV WV(Attrs);
279      for (int k = 0; k < Attrs; k++) {
280        WV[k] = GetW(CID, k);
281      }
282      Wck.Add(WV);
283    }
284    if ( NumComs != CmtyVV.Len()) {
285      printf("Community vector generated. %d communities are ommitted\n", NumComs.Val - CmtyVV.Len());
286    }
287  }
288  void TCesna::GetCmtyVVUnSorted(TVec<TIntV>& CmtyVV) {
289    GetCmtyVVUnSorted(CmtyVV, sqrt(2.0 * (double) G->GetEdges() / G->GetNodes() / G->GetNodes()), 3);
290  }
291  void TCesna::GetCmtyVVUnSorted(TVec<TIntV>& CmtyVV, const double Thres, const int MinSz) {
292    CmtyVV.Gen(NumComs, 0);
293    for (int c = 0; c < NumComs; c++) {
294      TIntV CmtyV;
295      for (int u = 0; u < G->GetNodes(); u++) {
296        if (GetCom(u, c) > Thres) { CmtyV.Add(NIDToIdx[u]); }
297      }
298      if (CmtyV.Len() >= MinSz) { CmtyVV.Add(CmtyV); }
299    }
300    if ( NumComs != CmtyVV.Len()) {
301      printf("Community vector generated. %d communities are ommitted\n", NumComs.Val - CmtyVV.Len());
302    }
303  }
304  int TCesna::FindComs(const int NumThreads, const int MaxComs, const int MinComs, const int DivComs, const TStr OutFNm, const bool UseBIC, const double HOFrac, const double StepAlpha, const double StepBeta) {
305      double ComsGap = exp(TMath::Log((double) MaxComs / (double) MinComs) / (double) DivComs);
306      TIntV ComsV;
307      ComsV.Add(MinComs);
308      while (ComsV.Len() < DivComs) {
309        int NewComs = int(ComsV.Last() * ComsGap);
310        if (NewComs == ComsV.Last().Val) { NewComs++; }
311        ComsV.Add(NewComs);
312      }
313      if (ComsV.Last() < MaxComs) { ComsV.Add(MaxComs); }
314      return FindComs(ComsV, UseBIC, HOFrac, NumThreads, OutFNm, StepAlpha, StepBeta);
315  }
316  int TCesna::FindComs(TIntV& ComsV, const bool UseBIC, const double HOFrac, const int NumThreads, const TStr PlotLFNm, const double StepAlpha, const double StepBeta) {
317    if (ComsV.Len() == 0) {
318      int MaxComs = G->GetNodes() / 5;
319      ComsV.Add(2);
320      while(ComsV.Last() < MaxComs) { ComsV.Add(ComsV.Last() * 2); }
321    }
322    int MaxIterCV = 3;
323    TVec<TVec<TIntSet> > HoldOutSets(MaxIterCV), HoldOutSetsAttr(MaxIterCV);
324    TFltIntPrV NIdPhiV;
325    TCesnaUtil::GetNIdPhiV<PUNGraph>(G, NIdPhiV);
326    if (! UseBIC) { 
327      TIntV NIdV1, NIdV2;
328      G->GetNIdV(NIdV1);
329      G->GetNIdV(NIdV2);
330      for (int IterCV = 0; IterCV < MaxIterCV; IterCV++) {
331        TCesnaUtil::GenHoldOutPairs(G, HoldOutSets[IterCV], HOFrac, Rnd);
332        GenHoldOutAttr(HOFrac, HoldOutSetsAttr[IterCV]);
333      }
334    }
335    TFltV HOLV(ComsV.Len());
336    TIntFltPrV ComsLV;
337    for (int c = 0; c < ComsV.Len(); c++) {
338      const int Coms = ComsV[c];
339      if (! UseBIC) { 
340        for (int IterCV = 0; IterCV < MaxIterCV; IterCV++) {
341          HOVIDSV = HoldOutSets[IterCV];
342          HOKIDSV = HoldOutSetsAttr[IterCV];
343          NeighborComInit(NIdPhiV, Coms);
344          if (NumThreads == 1) {
345            MLEGradAscent(0.01, 100 * G->GetNodes(), "", StepAlpha, StepBeta);
346          } else {
347            MLEGradAscentParallel(0.01, 100, NumThreads, "", StepAlpha, StepBeta);
348          }
349          double HOL = LikelihoodHoldOut();
350          HOL = HOL < 0? HOL: TFlt::Mn;
351          HOLV[c] += HOL;
352        }
353      }
354      else {
355        HOVIDSV.Gen(G->GetNodes());
356        HOKIDSV.Gen(G->GetNodes());
357        if (NumThreads == 1) {
358          MLEGradAscent(0.005, 100 * G->GetNodes(), "", StepAlpha, StepBeta);
359          printf("likelihood: train:%f, attr:%f, hold:%f\n", Likelihood(), LikelihoodAttr(), LikelihoodHoldOut());
360        } else {
361          MLEGradAscentParallel(0.005, 100, NumThreads, "", StepAlpha, StepBeta);
362        }
363        double NumParams = (1.0 - WeightAttr) * Coms + WeightAttr * Coms * Attrs;
364        double Observations = (1.0 - WeightAttr) * G->GetNodes() * (G->GetNodes() - 1) / 2 + WeightAttr * G->GetNodes() * Attrs;
365        double BIC = 2 * Likelihood() - NumParams * log (Observations);
366        HOLV[c] = BIC;
367      }
368    }
369    int EstComs = 2;
370    double MaxL = TFlt::Mn;
371    if (UseBIC) {
372      printf("Number of communities vs likelihood (criterion: BIC)\n");
373    } else {
374      printf("Number of communities vs likelihood (criterion: Cross validation)\n");
375    }
376    for (int c = 0; c < ComsV.Len(); c++) {
377      ComsLV.Add(TIntFltPr(ComsV[c].Val, HOLV[c].Val));
378      printf("%d(%f)\t", ComsV[c].Val, HOLV[c].Val);
379      if (MaxL < HOLV[c]) {
380        MaxL = HOLV[c];
381        EstComs = ComsV[c];
382      }
383    }
384    printf("\n");
385    RandomInit(EstComs);
386    HOVIDSV.Gen(G->GetNodes());
387    HOKIDSV.Gen(G->GetNodes());
388    if (! PlotLFNm.Empty()) {
389      TGnuPlot::PlotValV(ComsLV, PlotLFNm, "hold-out likelihood", "communities", "likelihood");
390    }
391    return EstComs;
392  }
393  double TCesna::LikelihoodHoldOut() { 
394    double L = 0.0;
395    for (int u = 0; u < HOVIDSV.Len(); u++) {
396      for (int e = 0; e < HOVIDSV[u].Len(); e++) {
397        int VID = HOVIDSV[u][e];
398        if (VID == u) { continue; } 
399        double Pred = Prediction(u, VID);
400        if (G->IsEdge(u, VID)) {
401          L += log(1.0 - Pred);
402        }
403        else {
404          L += NegWgt * log(Pred);
405        }
406      } 
407    }
408    L *= (1.0 - WeightAttr);
409    for (int u = 0; u < HOKIDSV.Len(); u++) {
410      for (int e = 0; e < HOKIDSV[u].Len(); e++) {
411        IAssert(HOKIDSV[u][e] < Attrs);
412        L += WeightAttr * LikelihoodAttrKForRow(u, HOKIDSV[u][e]);
413      }
414    }
415    return L;
416  }
417  double TCesna::GetStepSizeByLineSearch(const int UID, const TIntFltH& DeltaV, const TIntFltH& GradV, const double& Alpha, const double& Beta, const int MaxIter) {
418    double StepSize = 1.0;
419    double InitLikelihood = LikelihoodForRow(UID);
420    TIntFltH NewVarV(DeltaV.Len());
421    for(int iter = 0; iter < MaxIter; iter++) {
422      for (int i = 0; i < DeltaV.Len(); i++){
423        int CID = DeltaV.GetKey(i);
424        double NewVal = GetCom(UID, CID) + StepSize * DeltaV.GetDat(CID);
425        if (NewVal < MinVal) { NewVal = MinVal; }
426        if (NewVal > MaxVal) { NewVal = MaxVal; }
427        NewVarV.AddDat(CID, NewVal);
428      }
429      if (LikelihoodForRow(UID, NewVarV) < InitLikelihood + Alpha * StepSize * DotProduct(GradV, DeltaV)) {
430        StepSize *= Beta;
431      } else {
432        break;
433      }
434      if (iter == MaxIter - 1) { 
435        StepSize = 0.0;
436        break;
437      }
438    }
439    return StepSize;
440  }
441  int TCesna::MLEGradAscent(const double& Thres, const int& MaxIter, const TStr PlotNm, const double StepAlpha, const double StepBeta) {
442    time_t InitTime = time(NULL);
443    TExeTm ExeTm, CheckTm;
444    int iter = 0, PrevIter = 0;
445    TIntFltPrV IterLV;
446    TUNGraph::TNodeI UI;
447    double PrevL = TFlt::Mn, CurL = 0.0;
448    TIntV NIdxV(F.Len(), 0);
449    for (int i = 0; i < F.Len(); i++) { NIdxV.Add(i); }
450    TIntFltH GradV;
451    TIntSet CIDSet(NumComs);
452    for (int c = 0; c < NumComs; c++) { CIDSet.AddKey(c); }
453    while(iter < MaxIter) {
454      NIdxV.Shuffle(Rnd);
455      for (int ui = 0; ui < F.Len(); ui++, iter++) {
456        int u = NIdxV[ui]; 
457        GradientForRow(u, GradV, CIDSet);
458        if (Norm2(GradV) < 1e-4) { continue; }
459        double LearnRate = GetStepSizeByLineSearch(u, GradV, GradV, StepAlpha, StepBeta);
460        if (LearnRate == 0.0) { continue; }
461        for (int ci = 0; ci < GradV.Len(); ci++) {
462          int CID = GradV.GetKey(ci);
463          double Change = LearnRate * GradV.GetDat(CID);
464          double NewFuc = GetCom(u, CID) + Change;
465          if (NewFuc <= 0.0) {
466            DelCom(u, CID);
467          } else {
468            AddCom(u, CID, NewFuc);
469          }
470        }
471        if (! PlotNm.Empty() && (iter + 1) % G->GetNodes() == 0) {
472          IterLV.Add(TIntFltPr(iter, Likelihood(false)));
473        }
474      }
475      for (int k = 0; k < Attrs; k++) {
476        TFltV GradWV(NumComs);
477        GradientForWK(GradWV, k);
478        if (TLinAlg::Norm2(GradWV) < 1e-4) { continue; }
479        double LearnRate = GetStepSizeByLineSearchForWK(k, GradWV, GradWV, StepAlpha, StepBeta);
480        if (LearnRate == 0.0) { continue; }
481        for (int c = 0; c < GradWV.Len(); c++){
482          W[k][c] += LearnRate * GradWV[c];
483          if (W[k][c] < MinValW) { W[k][c] = MinValW; }
484          if (W[k][c] > MaxValW) { W[k][c] = MaxValW; }
485        }
486      }
487      printf("\r%d iterations (%f) [%lu sec]", iter, CurL, time(NULL) - InitTime);
488      fflush(stdout);
489      if (iter - PrevIter >= 2 * G->GetNodes() && iter > 10000) {
490        PrevIter = iter;
491        CurL = Likelihood();
492        if (PrevL > TFlt::Mn && ! PlotNm.Empty()) {
493          printf("\r%d iterations, Likelihood: %f, Diff: %f", iter, CurL,  CurL - PrevL);
494        }
495        fflush(stdout);
496        if (CurL - PrevL <= Thres * fabs(PrevL)) { break; }
497        else { PrevL = CurL; }
498      }
499    }
500    printf("\n");
501    printf("MLE for Lambda completed with %d iterations(%s)\n", iter, ExeTm.GetTmStr());
502    if (! PlotNm.Empty()) {
503      TGnuPlot::PlotValV(IterLV, PlotNm + ".likelihood_Q");
504    }
505    return iter;
506  }
507  int TCesna::MLEGradAscentParallel(const double& Thres, const int& MaxIter, const int ChunkNum, const int ChunkSize, const TStr PlotNm, const double StepAlpha, const double StepBeta) {
508    time_t InitTime = time(NULL);
509    uint64 StartTm = TSecTm::GetCurTm().GetAbsSecs();
510    TExeTm ExeTm, CheckTm;
511    double PrevL = Likelihood(true);
512    TIntFltPrV IterLV;
513    int PrevIter = 0;
514    int iter = 0;
515    TIntV NIdxV(F.Len(), 0);
516    for (int i = 0; i < F.Len(); i++) { NIdxV.Add(i); }
517    TIntV NIDOPTV(F.Len()); 
518    NIDOPTV.PutAll(0);
519    TVec<TIntFltH> NewF(ChunkNum * ChunkSize);
520    TIntV NewNIDV(ChunkNum * ChunkSize);
521    for (iter = 0; iter < MaxIter; iter++) {
522      NIdxV.Clr(false);
523      for (int i = 0; i < F.Len(); i++) { 
524        if (NIDOPTV[i] == 0) {  NIdxV.Add(i); }
525      }
526      IAssert (NIdxV.Len() <= F.Len());
527      NIdxV.Shuffle(Rnd);
528  #pragma omp parallel for schedule(static, 1)
529      for (int TIdx = 0; TIdx < ChunkNum; TIdx++) {
530        TIntFltH GradV;
531        for (int ui = TIdx * ChunkSize; ui < (TIdx + 1) * ChunkSize; ui++) {
532          NewNIDV[ui] = -1;
533          if (ui >= NIdxV.Len()) { continue; }
534          int u = NIdxV[ui]; 
535          TUNGraph::TNodeI UI = G->GetNI(u);
536          TIntSet CIDSet(5 * UI.GetDeg());
537          TIntFltH CurFU = F[u];
538          for (int e = 0; e < UI.GetDeg(); e++) {
539            if (HOVIDSV[u].IsKey(UI.GetNbrNId(e))) { continue; }
540            TIntFltH& NbhCIDH = F[UI.GetNbrNId(e)];
541            for (TIntFltH::TIter CI = NbhCIDH.BegI(); CI < NbhCIDH.EndI(); CI++) {
542              CIDSet.AddKey(CI.GetKey());
543            }
544          }
545          if (CIDSet.Empty()) { 
546            CurFU.Clr();
547          }
548          else {
549            for (TIntFltH::TIter CI = CurFU.BegI(); CI < CurFU.EndI(); CI++) { 
550              if (! CIDSet.IsKey(CI.GetKey())) {
551                CurFU.DelIfKey(CI.GetKey());
552              }
553            }
554            GradientForRow(u, GradV, CIDSet);
555            if (Norm2(GradV) < 1e-4) { NIDOPTV[u] = 1; continue; }
556            double LearnRate = GetStepSizeByLineSearch(u, GradV, GradV, StepAlpha, StepBeta);
557            if (LearnRate == 0.0) { NewNIDV[ui] = -2; continue; }
558            for (int ci = 0; ci < GradV.Len(); ci++) {
559              int CID = GradV.GetKey(ci);
560              double Change = LearnRate * GradV.GetDat(CID);
561              double NewFuc = CurFU.IsKey(CID)? CurFU.GetDat(CID) + Change : Change;
562              if (NewFuc <= 0.0) {
563                CurFU.DelIfKey(CID);
564              } else {
565                CurFU.AddDat(CID) = NewFuc;
566              }
567            }
568            CurFU.Defrag();
569          }
570          NewF[ui] = CurFU;
571          NewNIDV[ui] = u;
572        }
573      }
574      int NumNoChangeGrad = 0;
575      int NumNoChangeStepSize = 0;
576      for (int ui = 0; ui < NewNIDV.Len(); ui++) {
577        int NewNID = NewNIDV[ui];
578        if (NewNID == -1) { NumNoChangeGrad++; continue; }
579        if (NewNID == -2) { NumNoChangeStepSize++; continue; }
580        for (TIntFltH::TIter CI = F[NewNID].BegI(); CI < F[NewNID].EndI(); CI++) {
581          SumFV[CI.GetKey()] -= CI.GetDat();
582        }
583      }
584  #pragma omp parallel for
585      for (int ui = 0; ui < NewNIDV.Len(); ui++) {
586        int NewNID = NewNIDV[ui];
587        if (NewNID < 0) { continue; }
588        F[NewNID] = NewF[ui];
589      }
590      for (int ui = 0; ui < NewNIDV.Len(); ui++) {
591        int NewNID = NewNIDV[ui];
592        if (NewNID < 0) { continue; }
593        for (TIntFltH::TIter CI = F[NewNID].BegI(); CI < F[NewNID].EndI(); CI++) {
594          SumFV[CI.GetKey()] += CI.GetDat();
595        }
596      }
597      for (int ui = 0; ui < NewNIDV.Len(); ui++) {
598        int NewNID = NewNIDV[ui];
599        if (NewNID < 0) { continue; }
600        TUNGraph::TNodeI UI = G->GetNI(NewNID);
601        NIDOPTV[NewNID] = 0;
602        for (int e = 0; e < UI.GetDeg(); e++) {
603          NIDOPTV[UI.GetNbrNId(e)] = 0;
604        }
605      }
606      int OPTCnt = 0;
607      for (int i = 0; i < NIDOPTV.Len(); i++) { if (NIDOPTV[i] == 1) { OPTCnt++; } }
608      if (! PlotNm.Empty()) {
609        printf("\r%d iterations [%s] %s secs", iter * ChunkSize * ChunkNum, ExeTm.GetTmStr(), TUInt64::GetStr(TSecTm::GetCurTm().GetAbsSecs()-StartTm).CStr());
610        if (PrevL > TFlt::Mn) { printf(" (%f) %d g %d s %d OPT", PrevL, NumNoChangeGrad, NumNoChangeStepSize, OPTCnt); }
611        fflush(stdout);
612      }
613      if (iter == 0 || (iter - PrevIter) * ChunkSize * ChunkNum >= G->GetNodes()) {
614    #pragma omp parallel for
615        for (int k = 0; k < Attrs; k++) {
616          TFltV GradWV(NumComs);
617          GradientForWK(GradWV, k);
618          if (TLinAlg::Norm2(GradWV) < 1e-4) { continue; }
619          double LearnRate = GetStepSizeByLineSearchForWK(k, GradWV, GradWV, StepAlpha, StepBeta);
620          if (LearnRate == 0.0) { continue; }
621          for (int c = 0; c < GradWV.Len(); c++){
622            W[k][c] += LearnRate * GradWV[c];
623            if (W[k][c] < MinValW) { W[k][c] = MinValW; }
624            if (W[k][c] > MaxValW) { W[k][c] = MaxValW; }
625          }
626        }
627        PrevIter = iter;
628        double CurL = Likelihood(true);
629        IterLV.Add(TIntFltPr(iter * ChunkSize * ChunkNum, CurL));
630        printf("\r%d iterations, Likelihood: %f, Diff: %f [%lu secs]", iter, CurL,  CurL - PrevL, time(NULL) - InitTime);
631         fflush(stdout);
632        if (CurL - PrevL <= Thres * fabs(PrevL)) { 
633          break;
634        }
635        else {
636          PrevL = CurL;
637        }
638      }
639    }
640    if (! PlotNm.Empty()) {
641      printf("\nMLE completed with %d iterations(%s secs)\n", iter, TUInt64::GetStr(TSecTm::GetCurTm().GetAbsSecs()-StartTm).CStr());
642      TGnuPlot::PlotValV(IterLV, PlotNm + ".likelihood_Q");
643    } else {
644      printf("\rMLE completed with %d iterations(%lu secs)", iter, time(NULL) - InitTime);
645      fflush(stdout);
646    }
647    return iter;
648  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-kronecker.cpp</h3>
            <pre><code>1  #include "stdafx.h"
2  #include "kronecker.h"
3  const double TKronMtx::NInf = -DBL_MAX;
4  TRnd TKronMtx::Rnd = TRnd(0);
5  TKronMtx::TKronMtx(const TFltV& SeedMatrix) : SeedMtx(SeedMatrix) {
6    MtxDim = (int) sqrt((double)SeedMatrix.Len());
7    IAssert(MtxDim*MtxDim == SeedMtx.Len());
8  }
9  void TKronMtx::SaveTxt(const TStr& OutFNm) const {
10    FILE *F = fopen(OutFNm.CStr(), "wt");
11    for (int i = 0; i < GetDim(); i++) {
12      for (int j = 0; j < GetDim(); j++) {
13        if (j > 0) fprintf(F, "\t");
14        fprintf(F, "%f", At(i,j)); }
15      fprintf(F, "\n");
16    }
17    fclose(F);
18  }
19  TKronMtx& TKronMtx::operator = (const TKronMtx& Kronecker) {
20    if (this != &Kronecker){
21      MtxDim=Kronecker.MtxDim;
22      SeedMtx=Kronecker.SeedMtx;
23    }
24    return *this;
25  }
26  bool TKronMtx::IsProbMtx() const {
27    for (int i = 0; i < Len(); i++) {
28      if (At(i) < 0.0 || At(i) > 1.0) return false;
29    }
30    return true;
31  }
32  void TKronMtx::SetRndMtx(const int& PrmMtxDim, const double& MinProb) {
33    MtxDim = PrmMtxDim;
34    SeedMtx.Gen(MtxDim*MtxDim);
35    for (int p = 0; p < SeedMtx.Len(); p++) {
36      do {
37        SeedMtx[p] = TKronMtx::Rnd.GetUniDev();
38      } while (SeedMtx[p] < MinProb);
39    }
40  }
41  void TKronMtx::SetEpsMtx(const double& Eps1, const double& Eps0, const int& Eps1Val, const int& Eps0Val) {
42    for (int i = 0; i < Len(); i++) {
43      double& Val = At(i);
44      if (Val == Eps1Val) Val = double(Eps1);
45      else if (Val == Eps0Val) Val = double(Eps0);
46    }
47  }
48  void TKronMtx::SetForEdges(const int& Nodes, const int& Edges) {
49    const int KronIter = GetKronIter(Nodes);
50    const double EZero = pow((double) Edges, 1.0/double(KronIter));
51    const double Factor = EZero / GetMtxSum();
52    for (int i = 0; i < Len(); i++) {
53      At(i) *= Factor;
54      if (At(i) > 1) { At(i) = 1; }
55    }
56  }
57  void TKronMtx::AddRndNoise(const double& SDev) {
58    Dump("before");
59    double NewVal;
60    int c =0;
61    for (int i = 0; i < Len(); i++) {
62      for(c = 0; ((NewVal = At(i)*Rnd.GetNrmDev(1, SDev, 0.8, 1.2)) < 0.01 || NewVal>0.99) && c <1000; c++) { }
63      if (c < 999) { At(i) = NewVal; } else { printf("XXXXX\n"); }
64    }
65    Dump("after");
66  }
67  TStr TKronMtx::GetMtxStr() const {
68    TChA ChA("[");
69    for (int i = 0; i < Len(); i++) {
70      ChA += TStr::Fmt("%g", At(i));
71      if ((i+1)%GetDim()==0 && (i+1<Len())) { ChA += "; "; }
72      else if (i+1<Len()) { ChA += ", "; }
73    }
74    ChA += "]";
75    return TStr(ChA);
76  }
77  void TKronMtx::ToOneMinusMtx() {
78    for (int i = 0; i < Len(); i++) {
79      IAssert(At(i) >= 0.0 && At(i) <= 1.0);
80      At(i) = 1.0 - At(i);
81    }
82  }
83  void TKronMtx::GetLLMtx(TKronMtx& LLMtx) {
84    LLMtx.GenMtx(MtxDim);
85    for (int i = 0; i < Len(); i++) {
86      if (At(i) != 0.0) { LLMtx.At(i) = log(At(i)); }
87      else { LLMtx.At(i) = NInf; }
88    }
89  }
90  void TKronMtx::GetProbMtx(TKronMtx& ProbMtx) {
91    ProbMtx.GenMtx(MtxDim);
92    for (int i = 0; i < Len(); i++) {
93      if (At(i) != NInf) { ProbMtx.At(i) = exp(At(i)); }
94      else { ProbMtx.At(i) = 0.0; }
95    }
96  }
97  void TKronMtx::Swap(TKronMtx& KronMtx) {
98    ::Swap(MtxDim, KronMtx.MtxDim);
99    SeedMtx.Swap(KronMtx.SeedMtx);
100  }
101  int TKronMtx::GetNodes(const int& NIter) const {
102    return (int) pow(double(GetDim()), double(NIter));
103  }
104  int TKronMtx::GetEdges(const int& NIter) const {
105    return (int) pow(double(GetMtxSum()), double(NIter));
106  }
107  int TKronMtx::GetKronIter(const int& Nodes) const {
108    return (int) ceil(log(double(Nodes)) / log(double(GetDim()))); 
109  }
110  int TKronMtx::GetNZeroK(const PNGraph& Graph) const {
111   return GetNodes(GetKronIter(Graph->GetNodes()));
112  }
113  double TKronMtx::GetEZero(const int& Edges, const int& KronIters) const {
114    return pow((double) Edges, 1.0/double(KronIters));
115  }
116  double TKronMtx::GetMtxSum() const {
117    double Sum = 0;
118    for (int i = 0; i < Len(); i++) {
119      Sum += At(i); }
120    return Sum;
121  }
122  double TKronMtx::GetRowSum(const int& RowId) const {
123    double Sum = 0;
124    for (int c = 0; c < GetDim(); c++) {
125      Sum += At(RowId, c); }
126    return Sum;
127  }
128  double TKronMtx::GetColSum(const int& ColId) const {
129    double Sum = 0;
130    for (int r = 0; r < GetDim(); r++) {
131      Sum += At(r, ColId); }
132    return Sum;
133  }
134  double TKronMtx::GetEdgeProb(int NId1, int NId2, const int& NKronIters) const {
135    double Prob = 1.0;
136    for (int level = 0; level < NKronIters; level++) {
137      Prob *= At(NId1 % MtxDim, NId2 % MtxDim);
138      if (Prob == 0.0) { return 0.0; }
139      NId1 /= MtxDim;  NId2 /= MtxDim;
140    }
141    return Prob;
142  }
143  double TKronMtx::GetNoEdgeProb(int NId1, int NId2, const int& NKronIters) const {
144    return 1.0 - GetEdgeProb(NId1, NId2, NKronIters);
145  }
146  double TKronMtx::GetEdgeLL(int NId1, int NId2, const int& NKronIters) const {
147    double LL = 0.0;
148    for (int level = 0; level < NKronIters; level++) {
149      const double& LLVal = At(NId1 % MtxDim, NId2 % MtxDim);
150      if (LLVal == NInf) return NInf;
151      LL += LLVal;
152      NId1 /= MtxDim;  NId2 /= MtxDim;
153    }
154    return LL;
155  }
156  double TKronMtx::GetNoEdgeLL(int NId1, int NId2, const int& NKronIters) const {
157    return log(1.0 - exp(GetEdgeLL(NId1, NId2, NKronIters)));
158  }
159  double TKronMtx::GetApxNoEdgeLL(int NId1, int NId2, const int& NKronIters) const {
160    const double EdgeLL = GetEdgeLL(NId1, NId2, NKronIters);
161    return -exp(EdgeLL) - 0.5*exp(2*EdgeLL);
162  }
163  bool TKronMtx::IsEdgePlace(int NId1, int NId2, const int& NKronIters, const double& ProbTresh) const {
164    double Prob = 1.0;
165    for (int level = 0; level < NKronIters; level++) {
166      Prob *= At(NId1 % MtxDim, NId2 % MtxDim);
167      if (ProbTresh > Prob) { return false; }
168      NId1 /= MtxDim;  NId2 /= MtxDim;
169    }
170    return true;
171  }
172  double TKronMtx::GetEdgeDLL(const int& ParamId, int NId1, int NId2, const int& NKronIters) const {
173    const int ThetaX = ParamId % GetDim();
174    const int ThetaY = ParamId / GetDim();
175    int ThetaCnt = 0;
176    for (int level = 0; level < NKronIters; level++) {
177      if ((NId1 % MtxDim) == ThetaX && (NId2 % MtxDim) == ThetaY) {
178        ThetaCnt++; }
179      NId1 /= MtxDim;  NId2 /= MtxDim;
180    }
181    return double(ThetaCnt) / exp(At(ParamId));
182  }
183  double TKronMtx::GetNoEdgeDLL(const int& ParamId, int NId1, int NId2, const int& NKronIters) const {
184    const int& ThetaX = ParamId % GetDim();
185    const int& ThetaY = ParamId / GetDim();
186    int ThetaCnt = 0;
187    double DLL = 0, LL = 0;
188    for (int level = 0; level < NKronIters; level++) {
189      const int X = NId1 % MtxDim;
190      const int Y = NId2 % MtxDim;
191      const double LVal = At(X, Y);
192      if (X == ThetaX && Y == ThetaY) {
193        if (ThetaCnt != 0) { DLL += LVal; }
194        ThetaCnt++;
195      } else { DLL += LVal; }
196      LL += LVal;
197      NId1 /= MtxDim;  NId2 /= MtxDim;
198    }
199    return -ThetaCnt*exp(DLL) / (1.0 - exp(LL));
200  }
201  double TKronMtx::GetApxNoEdgeDLL(const int& ParamId, int NId1, int NId2, const int& NKronIters) const {
202    const int& ThetaX = ParamId % GetDim();
203    const int& ThetaY = ParamId / GetDim();
204    int ThetaCnt = 0;
205    double DLL = 0;
206    for (int level = 0; level < NKronIters; level++) {
207      const int X = NId1 % MtxDim;
208      const int Y = NId2 % MtxDim;
209      const double LVal = At(X, Y); IAssert(LVal > NInf);
210      if (X == ThetaX && Y == ThetaY) {
211        if (ThetaCnt != 0) { DLL += LVal; }
212        ThetaCnt++;
213      } else { DLL += LVal; }
214      NId1 /= MtxDim;  NId2 /= MtxDim;
215    }
216    return -ThetaCnt*exp(DLL) - ThetaCnt*exp(At(ThetaX, ThetaY)+2*DLL);
217  }
218  uint TKronMtx::GetNodeSig(const double& OneProb) {
219    uint Sig = 0;
220    for (int i = 0; i < (int)(8*sizeof(uint)); i++) {
221      if (TKronMtx::Rnd.GetUniDev() < OneProb) {
222        Sig |= (1u<<i); }
223    }
224    return Sig;
225  }
226  double TKronMtx::GetEdgeProb(const uint& NId1Sig, const uint& NId2Sig, const int& NIter) const {
227    Assert(GetDim() == 2);
228    double Prob = 1.0;
229    for (int i = 0; i < NIter; i++) {
230      const uint Mask = (1u<<i);
231      const uint Bit1 = NId1Sig & Mask;
232      const uint Bit2 = NId2Sig & Mask;
233      Prob *= At(int(Bit1!=0), int(Bit2!=0));
234    }
235    return Prob;
236  }
237  PNGraph TKronMtx::GenThreshGraph(const double& Thresh) const {
238    PNGraph Graph = TNGraph::New();
239    for (int i = 0; i < GetDim(); i++) {
240      Graph->AddNode(i); }
241    for (int r = 0; r < GetDim(); r++) {
242      for (int c = 0; c < GetDim(); c++) {
243        if (At(r, c) >= Thresh) { Graph->AddEdge(r, c); }
244      }
245    }
246    return Graph;
247  }
248  PNGraph TKronMtx::GenRndGraph(const double& RndFact) const {
249    PNGraph Graph = TNGraph::New();
250    for (int i = 0; i < GetDim(); i++) {
251      Graph->AddNode(i); }
252    for (int r = 0; r < GetDim(); r++) {
253      for (int c = 0; c < GetDim(); c++) {
254        if (RndFact * At(r, c) >= TKronMtx::Rnd.GetUniDev()) { Graph->AddEdge(r, c); }
255      }
256    }
257    return Graph;
258  }
259  int TKronMtx::GetKronIter(const int& GNodes, const int& SeedMtxSz) {
260    return (int) ceil(log(double(GNodes)) / log(double(SeedMtxSz)));
261  }
262  PNGraph TKronMtx::GenKronecker(const TKronMtx& SeedMtx, const int& NIter, const bool& IsDir, const int& Seed) {
263    const TKronMtx& SeedGraph = SeedMtx;
264    const int NNodes = SeedGraph.GetNodes(NIter);
265    printf("  Kronecker: %d nodes, %s...\n", NNodes, IsDir ? "Directed":"UnDirected");
266    PNGraph Graph = TNGraph::New(NNodes, -1);
267    TExeTm ExeTm;
268    TRnd Rnd(Seed);
269    int edges = 0;
270    for (int node1 = 0; node1 < NNodes; node1++) {
271      Graph->AddNode(node1); }
272    if (IsDir) {
273      for (int node1 = 0; node1 < NNodes; node1++) {
274        for (int node2 = 0; node2 < NNodes; node2++) {
275          if (SeedGraph.IsEdgePlace(node1, node2, NIter, Rnd.GetUniDev())) {
276            Graph->AddEdge(node1, node2);
277            edges++;
278          }
279        }
280        if (node1 % 1000 == 0) printf("\r...%dk, %dk", node1/1000, edges/1000);
281      }
282    } else {
283      for (int node1 = 0; node1 < NNodes; node1++) {
284        for (int node2 = node1; node2 < NNodes; node2++) {
285          if (SeedGraph.IsEdgePlace(node1, node2, NIter, Rnd.GetUniDev())) {
286            Graph->AddEdge(node1, node2);
287            Graph->AddEdge(node2, node1);
288            edges++;
289          }
290        }
291        if (node1 % 1000 == 0) printf("\r...%dk, %dk", node1/1000, edges/1000);
292      }
293    }
294    printf("\r             %d edges [%s]\n", Graph->GetEdges(), ExeTm.GetTmStr());
295    return Graph;
296  }
297  PNGraph TKronMtx::GenFastKronecker(const TKronMtx& SeedMtx, const int& NIter, const bool& IsDir, const int& Seed) {
298    const TKronMtx& SeedGraph = SeedMtx;
299    const int MtxDim = SeedGraph.GetDim();
300    const double MtxSum = SeedGraph.GetMtxSum();
301    const int NNodes = SeedGraph.GetNodes(NIter);
302    const int NEdges = SeedGraph.GetEdges(NIter);
303    printf("  FastKronecker: %d nodes, %d edges, %s...\n", NNodes, NEdges, IsDir ? "Directed":"UnDirected");
304    PNGraph Graph = TNGraph::New(NNodes, -1);
305    TRnd Rnd(Seed);
306    TExeTm ExeTm;
307    TVec<TFltIntIntTr> ProbToRCPosV; 
308    double CumProb = 0.0;
309    for (int r = 0; r < MtxDim; r++) {
310      for (int c = 0; c < MtxDim; c++) {
311        const double Prob = SeedGraph.At(r, c);
312        if (Prob > 0.0) {
313          CumProb += Prob;
314          ProbToRCPosV.Add(TFltIntIntTr(CumProb/MtxSum, r, c));
315        }
316      }
317    }
318    for (int i = 0; i < NNodes; i++) {
319      Graph->AddNode(i); }
320    int Rng, Row, Col, Collision=0, n = 0;
321    for (int edges = 0; edges < NEdges; ) {
322      Rng=NNodes;  Row=0;  Col=0;
323      for (int iter = 0; iter < NIter; iter++) {
324        const double& Prob = Rnd.GetUniDev();
325        n = 0; while(Prob > ProbToRCPosV[n].Val1) { n++; }
326        const int MtxRow = ProbToRCPosV[n].Val2;
327        const int MtxCol = ProbToRCPosV[n].Val3;
328        Rng /= MtxDim;
329        Row += MtxRow * Rng;
330        Col += MtxCol * Rng;
331      }
332      if (! Graph->IsEdge(Row, Col)) { 
333        Graph->AddEdge(Row, Col);  edges++;
334        if (! IsDir) {
335          if (Row != Col) Graph->AddEdge(Col, Row);
336          edges++;
337        }
338      } else { Collision++; }
339    }
340    printf("             collisions: %d (%.4f)\n", Collision, Collision/(double)Graph->GetEdges());
341    return Graph;
342  }
343  PNGraph TKronMtx::GenFastKronecker(const TKronMtx& SeedMtx, const int& NIter, const int& Edges, const bool& IsDir, const int& Seed) {
344    const TKronMtx& SeedGraph = SeedMtx;
345    const int MtxDim = SeedGraph.GetDim();
346    const double MtxSum = SeedGraph.GetMtxSum();
347    const int NNodes = SeedGraph.GetNodes(NIter);
348    const int NEdges = Edges;
349    printf("  RMat Kronecker: %d nodes, %d edges, %s...\n", NNodes, NEdges, IsDir ? "Directed":"UnDirected");
350    PNGraph Graph = TNGraph::New(NNodes, -1);
351    TRnd Rnd(Seed);
352    TExeTm ExeTm;
353    TVec<TFltIntIntTr> ProbToRCPosV; 
354    double CumProb = 0.0;
355    for (int r = 0; r < MtxDim; r++) {
356      for (int c = 0; c < MtxDim; c++) {
357        const double Prob = SeedGraph.At(r, c);
358        if (Prob > 0.0) {
359          CumProb += Prob;
360          ProbToRCPosV.Add(TFltIntIntTr(CumProb/MtxSum, r, c));
361        }
362      }
363    }
364    for (int i = 0; i < NNodes; i++) {
365      Graph->AddNode(i); }
366    int Rng, Row, Col, Collision=0, n = 0;
367    for (int edges = 0; edges < NEdges; ) {
368      Rng=NNodes;  Row=0;  Col=0;
369      for (int iter = 0; iter < NIter; iter++) {
370        const double& Prob = Rnd.GetUniDev();
371        n = 0; while(Prob > ProbToRCPosV[n].Val1) { n++; }
372        const int MtxRow = ProbToRCPosV[n].Val2;
373        const int MtxCol = ProbToRCPosV[n].Val3;
374        Rng /= MtxDim;
375        Row += MtxRow * Rng;
376        Col += MtxCol * Rng;
377      }
378      if (! Graph->IsEdge(Row, Col)) { 
379        Graph->AddEdge(Row, Col);  edges++;
380        if (! IsDir) {
381          if (Row != Col) Graph->AddEdge(Col, Row);
382          edges++;
383        }
384      } else { Collision++; }
385    }
386    printf("             collisions: %d (%.4f)\n", Collision, Collision/(double)Graph->GetEdges());
387    return Graph;
388  }
389  PNGraph TKronMtx::GenDetKronecker(const TKronMtx& SeedMtx, const int& NIter, const bool& IsDir) {
390    const TKronMtx& SeedGraph = SeedMtx;
391    const int NNodes = SeedGraph.GetNodes(NIter);
392    printf("  Deterministic Kronecker: %d nodes, %s...\n", NNodes, IsDir ? "Directed":"UnDirected");
393    PNGraph Graph = TNGraph::New(NNodes, -1);
394    TExeTm ExeTm;
<span onclick='openModal()' class='match'>395    int edges = 0;
396    for (int node1 = 0; node1 < NNodes; node1++) { Graph->AddNode(node1); }
397    for (int node1 = 0; node1 < NNodes; node1++) {
</span>398      for (int node2 = 0; node2 < NNodes; node2++) {
399        if (SeedGraph.IsEdgePlace(node1, node2, NIter, Rnd.GetUniDev())) {
400          Graph->AddEdge(node1, node2);
401          edges++;
402        }
403      }
404      if (node1 % 1000 == 0) printf("\r...%dk, %dk", node1/1000, edges/1000);
405    }
406    return Graph;
407  }
408  void TKronMtx::PlotCmpGraphs(const TKronMtx& SeedMtx, const PNGraph& Graph, const TStr& FNmPref, const TStr& Desc) {
409    const int KronIters = SeedMtx.GetKronIter(Graph->GetNodes());
410    PNGraph KronG, WccG;
411    const bool FastGen = true;
412    if (FastGen) { KronG = TKronMtx::GenFastKronecker(SeedMtx, KronIters, true, 0); }
413    else { KronG = TKronMtx::GenKronecker(SeedMtx, KronIters, true, 0); }
414    TSnap::DelZeroDegNodes(KronG);
415    WccG = TSnap::GetMxWcc(KronG);
416    const TStr Desc1 = TStr::Fmt("%s", Desc.CStr());
417    TGStatVec GS(tmuNodes, TFSet() | gsdInDeg | gsdOutDeg | gsdWcc | gsdHops | gsdScc | gsdClustCf | gsdSngVec | gsdSngVal);
418    GS.Add(Graph, TSecTm(1), TStr::Fmt("GRAPH  G(%d, %d)", Graph->GetNodes(), Graph->GetEdges()));
419    GS.Add(KronG, TSecTm(2), TStr::Fmt("KRONECKER  K(%d, %d)", KronG->GetNodes(), KronG->GetEdges()));
420    GS.Add(WccG, TSecTm(3),  TStr::Fmt("KRONECKER  wccK(%d, %d)", WccG->GetNodes(), WccG->GetEdges()));
421    const TStr Style = "linewidth 1 pointtype 6 pointsize 1";
422    GS.ImposeDistr(gsdInDeg, FNmPref, Desc1, false, false, gpwLinesPoints, Style);
423    GS.ImposeDistr(gsdInDeg, FNmPref+"-B", Desc1, true, false, gpwLinesPoints, Style);
424    GS.ImposeDistr(gsdOutDeg, FNmPref, Desc1, false, false, gpwLinesPoints, Style);
425    GS.ImposeDistr(gsdOutDeg, FNmPref+"-B", Desc1, true, false, gpwLinesPoints, Style);
426    GS.ImposeDistr(gsdHops, FNmPref, Desc1, false, false, gpwLinesPoints, Style);
427    GS.ImposeDistr(gsdClustCf, FNmPref, Desc1, false, false, gpwLinesPoints, Style);
428    GS.ImposeDistr(gsdClustCf, FNmPref+"-B", Desc1, true, false, gpwLinesPoints, Style);
429    GS.ImposeDistr(gsdSngVal, FNmPref, Desc1, false, false, gpwLinesPoints, Style);
430    GS.ImposeDistr(gsdSngVal, FNmPref+"-B", Desc1, true, false, gpwLinesPoints, Style);
431    GS.ImposeDistr(gsdSngVec, FNmPref, Desc1, false, false, gpwLinesPoints, Style);
432    GS.ImposeDistr(gsdSngVec, FNmPref+"-B", Desc1, true, false, gpwLinesPoints, Style);
433    GS.ImposeDistr(gsdWcc, FNmPref, Desc1, false, false, gpwLinesPoints, Style);
434    GS.ImposeDistr(gsdWcc, FNmPref+"-B", Desc1, true, false, gpwLinesPoints, Style);
435    GS.ImposeDistr(gsdScc, FNmPref, Desc1, false, false, gpwLinesPoints, Style);
436    GS.ImposeDistr(gsdScc, FNmPref+"-B", Desc1, true, false, gpwLinesPoints, Style);
437  }
438  void TKronMtx::PlotCmpGraphs(const TKronMtx& SeedMtx1, const TKronMtx& SeedMtx2, const PNGraph& Graph, const TStr& FNmPref, const TStr& Desc) {
439    const int KronIters1 = SeedMtx1.GetKronIter(Graph->GetNodes());
440    const int KronIters2 = SeedMtx2.GetKronIter(Graph->GetNodes());
441    PNGraph KronG1, KronG2;
442    const bool FastGen = true;
443    if (FastGen) {
444      KronG1 = TKronMtx::GenFastKronecker(SeedMtx1, KronIters1, true, 0);
445      KronG2 = TKronMtx::GenFastKronecker(SeedMtx2, KronIters2, false, 0); } 
446    else {
447      KronG1 = TKronMtx::GenKronecker(SeedMtx1, KronIters1, true, 0);
448      KronG2 = TKronMtx::GenKronecker(SeedMtx2, KronIters2, true, 0);  }
449    TSnap::DelZeroDegNodes(KronG1);
450    TSnap::DelZeroDegNodes(KronG2);
451    const TStr Desc1 = TStr::Fmt("%s", Desc.CStr());
452    TGStatVec GS(tmuNodes, TFSet() | gsdInDeg | gsdOutDeg | gsdWcc | gsdScc | gsdHops | gsdClustCf | gsdSngVec | gsdSngVal | gsdTriadPart);
453    GS.Add(Graph, TSecTm(1), TStr::Fmt("GRAPH  G(%d, %d)", Graph->GetNodes(), Graph->GetEdges()));
454    GS.Add(KronG1, TSecTm(2), TStr::Fmt("KRONECKER1  K(%d, %d) %s", KronG1->GetNodes(), KronG1->GetEdges(), SeedMtx1.GetMtxStr().CStr()));
455    GS.Add(KronG2, TSecTm(3),  TStr::Fmt("KRONECKER2  K(%d, %d) %s", KronG2->GetNodes(), KronG2->GetEdges(), SeedMtx2.GetMtxStr().CStr()));
456    const TStr Style = "linewidth 1 pointtype 6 pointsize 1";
457    GS.ImposeDistr(gsdInDeg, FNmPref, Desc1, false, false, gpwLinesPoints, Style);
458    GS.ImposeDistr(gsdOutDeg, FNmPref, Desc1, false, false, gpwLinesPoints, Style);
459    GS.ImposeDistr(gsdHops, FNmPref, Desc1, false, false, gpwLinesPoints, Style);
460    GS.ImposeDistr(gsdClustCf, FNmPref, Desc1, false, false, gpwLinesPoints, Style);
461    GS.ImposeDistr(gsdSngVal, FNmPref, Desc1, false, false, gpwLinesPoints, Style);
462    GS.ImposeDistr(gsdSngVec, FNmPref, Desc1, false, false, gpwLinesPoints, Style);
463    GS.ImposeDistr(gsdWcc, FNmPref, Desc1, false, false, gpwLinesPoints, Style);
464    GS.ImposeDistr(gsdScc, FNmPref, Desc1, false, false, gpwLinesPoints, Style);
465    GS.ImposeDistr(gsdTriadPart, FNmPref, Desc1, false, false, gpwLinesPoints, Style);
466    GS.ImposeDistr(gsdInDeg, FNmPref+"-B", Desc1, true, false, gpwLinesPoints, Style);
467    GS.ImposeDistr(gsdOutDeg, FNmPref+"-B", Desc1, true, false, gpwLinesPoints, Style);
468    GS.ImposeDistr(gsdClustCf, FNmPref+"-B", Desc1, true, false, gpwLinesPoints, Style);
469    GS.ImposeDistr(gsdScc, FNmPref+"-B", Desc1, true, false, gpwLinesPoints, Style);
470    GS.ImposeDistr(gsdWcc, FNmPref+"-B", Desc1, true, false, gpwLinesPoints, Style);
471    GS.ImposeDistr(gsdSngVec, FNmPref+"-B", Desc1, true, false, gpwLinesPoints, Style);
472    GS.ImposeDistr(gsdSngVal, FNmPref+"-B", Desc1, true, false, gpwLinesPoints, Style);
473    GS.ImposeDistr(gsdTriadPart, FNmPref+"-B", Desc1, true, false, gpwLinesPoints, Style);
474  }
475  void TKronMtx::PlotCmpGraphs(const TVec<TKronMtx>& SeedMtxV, const PNGraph& Graph, const TStr& FNmPref, const TStr& Desc) {
476    const TStr Desc1 = TStr::Fmt("%s", Desc.CStr());
477    TGStatVec GS(tmuNodes, TFSet() | gsdInDeg | gsdOutDeg | gsdWcc | gsdScc | gsdHops | gsdClustCf | gsdSngVec | gsdSngVal);
478    GS.Add(Graph, TSecTm(1), TStr::Fmt("GRAPH  G(%d, %d)", Graph->GetNodes(), Graph->GetEdges()));
479    for (int m = 0; m < SeedMtxV.Len(); m++) {
480      const int KronIters = SeedMtxV[m].GetKronIter(Graph->GetNodes());
481      PNGraph KronG1 = TKronMtx::GenFastKronecker(SeedMtxV[m], KronIters, true, 0);
482      printf("*** K(%d, %d) n0=%d\n", KronG1->GetNodes(), KronG1->GetEdges(), SeedMtxV[m].GetDim());
483      TSnap::DelZeroDegNodes(KronG1);
484      printf(" del zero deg K(%d, %d) n0=%d\n", KronG1->GetNodes(), KronG1->GetEdges(), m);
485      GS.Add(KronG1, TSecTm(m+2), TStr::Fmt("K(%d, %d) n0^k=%d n0=%d", KronG1->GetNodes(), KronG1->GetEdges(), SeedMtxV[m].GetNZeroK(Graph), SeedMtxV[m].GetDim()));
486      const TStr Style = "linewidth 1 pointtype 6 pointsize 1";
487      GS.ImposeDistr(gsdInDeg, FNmPref, Desc1, false, false, gpwLines, Style);
488      GS.ImposeDistr(gsdInDeg, FNmPref+"-B", Desc1, true, false, gpwLines, Style);
489      GS.ImposeDistr(gsdOutDeg, FNmPref, Desc1, false, false, gpwLines, Style);
490      GS.ImposeDistr(gsdOutDeg, FNmPref+"-B", Desc1, true, false, gpwLines, Style);
491      GS.ImposeDistr(gsdHops, FNmPref, Desc1, false, false, gpwLines, Style);
492      GS.ImposeDistr(gsdClustCf, FNmPref, Desc1, false, false, gpwLines, Style);
493      GS.ImposeDistr(gsdClustCf, FNmPref+"-B", Desc1, true, false, gpwLines, Style);
494      GS.ImposeDistr(gsdSngVal, FNmPref, Desc1, false, false, gpwLines, Style);
495      GS.ImposeDistr(gsdSngVal, FNmPref+"-B", Desc1, true, false, gpwLines, Style);
496      GS.ImposeDistr(gsdSngVec, FNmPref, Desc1, false, false, gpwLines, Style);
497      GS.ImposeDistr(gsdSngVec, FNmPref+"-B", Desc1, true, false, gpwLines, Style);
498      GS.ImposeDistr(gsdWcc, FNmPref, Desc1, false, false, gpwLines, Style);
499      GS.ImposeDistr(gsdWcc, FNmPref+"-B", Desc1, true, false, gpwLines, Style);
500      GS.ImposeDistr(gsdScc, FNmPref, Desc1, false, false, gpwLines, Style);
501      GS.ImposeDistr(gsdScc, FNmPref+"-B", Desc1, true, false, gpwLines, Style);
502    }
503  }
504  void TKronMtx::KronMul(const TKronMtx& Left, const TKronMtx& Right, TKronMtx& Result) {
505    const int LDim = Left.GetDim();
506    const int RDim = Right.GetDim();
507    Result.GenMtx(LDim * RDim);
508    for (int r1 = 0; r1 < LDim; r1++) {
509      for (int c1 = 0; c1 < LDim; c1++) {
510        const double& Val = Left.At(r1, c1);
511        for (int r2 = 0; r2 < RDim; r2++) {
512          for (int c2 = 0; c2 < RDim; c2++) {
513            Result.At(r1*RDim+r2, c1*RDim+c2) = Val * Right.At(r2, c2);
514          }
515        }
516      }
517    }
518  }
519  void TKronMtx::KronSum(const TKronMtx& Left, const TKronMtx& Right, TKronMtx& Result) {
520    const int LDim = Left.GetDim();
521    const int RDim = Right.GetDim();
522    Result.GenMtx(LDim * RDim);
523    for (int r1 = 0; r1 < LDim; r1++) {
524      for (int c1 = 0; c1 < LDim; c1++) {
525        const double& Val = Left.At(r1, c1);
526        for (int r2 = 0; r2 < RDim; r2++) {
527          for (int c2 = 0; c2 < RDim; c2++) {
528            if (Val == NInf || Right.At(r2, c2) == NInf) {
529              Result.At(r1*RDim+r2, c1*RDim+c2) = NInf; }
530            else {
531              Result.At(r1*RDim+r2, c1*RDim+c2) = Val + Right.At(r2, c2); }
532          }
533        }
534      }
535    }
536  }
537  void TKronMtx::KronPwr(const TKronMtx& KronMtx, const int& NIter, TKronMtx& OutMtx) {
538    OutMtx = KronMtx;
539    TKronMtx NewOutMtx;
540    for (int iter = 0; iter < NIter; iter++) {
541      KronMul(OutMtx, KronMtx, NewOutMtx);
542      NewOutMtx.Swap(OutMtx);
543    }
544  }
545  void TKronMtx::Dump(const TStr& MtxNm, const bool& Sort) const {
546    if (! MtxNm.Empty()) printf("%s\n", MtxNm.CStr());
547    double Sum=0.0;
548    TFltV ValV = SeedMtx;
549    if (Sort) { ValV.Sort(false); }
550    for (int i = 0; i < ValV.Len(); i++) {
551      printf("  %10.4g", ValV[i]());
552      Sum += ValV[i];
553      if ((i+1) % GetDim() == 0) { printf("\n"); }
554    }
555    printf(" (sum:%.4f)\n", Sum);
556  }
557  double TKronMtx::GetAvgAbsErr(const TKronMtx& Kron1, const TKronMtx& Kron2) {
558    TFltV P1 = Kron1.GetMtx();
559    TFltV P2 = Kron2.GetMtx();
560    IAssert(P1.Len() == P2.Len());
561    P1.Sort();  P2.Sort();
562    double delta = 0.0;
563    for (int i = 0; i < P1.Len(); i++) {
564      delta += fabs(P1[i] - P2[i]);
565    }
566    return delta/P1.Len();
567  }
568  double TKronMtx::GetAvgFroErr(const TKronMtx& Kron1, const TKronMtx& Kron2) {
569    TFltV P1 = Kron1.GetMtx();
570    TFltV P2 = Kron2.GetMtx();
571    IAssert(P1.Len() == P2.Len());
572    P1.Sort();  P2.Sort();
573    double delta = 0.0;
574    for (int i = 0; i < P1.Len(); i++) {
575      delta += pow(P1[i] - P2[i], 2);
576    }
577    return sqrt(delta/P1.Len());
578  }
579  TKronMtx TKronMtx::GetMtx(TStr MatlabMtxStr) {
580    TStrV RowStrV, ColStrV;
581    MatlabMtxStr.ChangeChAll(',', ' ');
582    MatlabMtxStr.SplitOnAllCh(';', RowStrV);  IAssert(! RowStrV.Empty());
583    RowStrV[0].SplitOnWs(ColStrV);    IAssert(! ColStrV.Empty());
584    const int Rows = RowStrV.Len();
585    const int Cols = ColStrV.Len();
586    IAssert(Rows == Cols);
587    TKronMtx Mtx(Rows);
588    for (int r = 0; r < Rows; r++) {
589      RowStrV[r].SplitOnWs(ColStrV);
590      IAssert(ColStrV.Len() == Cols);
591      for (int c = 0; c < Cols; c++) {
592        Mtx.At(r, c) = (double) ColStrV[c].GetFlt(); }
593    }
594    return Mtx;
595  }
596  TKronMtx TKronMtx::GetRndMtx(const int& Dim, const double& MinProb) {
597    TKronMtx Mtx;
598    Mtx.SetRndMtx(Dim, MinProb);
599    return Mtx;
600  }
601  TKronMtx TKronMtx::GetInitMtx(const int& Dim, const int& Nodes, const int& Edges) {
602    const double MxParam = 0.8+TKronMtx::Rnd.GetUniDev()/5.0;
603    const double MnParam = 0.2-TKronMtx::Rnd.GetUniDev()/5.0;
604    const double Step = (MxParam-MnParam) / (Dim*Dim-1);
605    TFltV ParamV(Dim*Dim);
606    if (Dim == 1) { ParamV.PutAll(0.5); } 
607    else {
608      for (int p = 0; p < ParamV.Len(); p++) {
609        ParamV[p] = MxParam - p*Step; }
610    }
611    TKronMtx Mtx(ParamV);
612    Mtx.SetForEdges(Nodes, Edges);
613    return Mtx;
614  }
615  TKronMtx TKronMtx::GetInitMtx(const TStr& MtxStr, const int& Dim, const int& Nodes, const int& Edges) {
616    TKronMtx Mtx(Dim);
617    if (TCh::IsNum(MtxStr[0])) { Mtx = TKronMtx::GetMtx(MtxStr); }
618    else if (MtxStr[0] == 'r') { Mtx = TKronMtx::GetRndMtx(Dim, 0.1); }
619    else if (MtxStr[0] == 'a') {
620      const double Prob = TKronMtx::Rnd.GetUniDev();
621      if (Prob < 0.4) {
622        Mtx = TKronMtx::GetInitMtx(Dim, Nodes, Edges); }
623      else { 
624        const double Max = 0.9+TKronMtx::Rnd.GetUniDev()/10.0;
625        const double Min = 0.1-TKronMtx::Rnd.GetUniDev()/10.0;
626        const double Med = (Max-Min)/2.0;
627        Mtx.At(0,0)      = Max;       Mtx.At(0,Dim-1) = Med;
628        Mtx.At(Dim-1, 0) = Med;  Mtx.At(Dim-1, Dim-1) = Min;
629        for (int i = 1; i < Dim-1; i++) {
630          Mtx.At(i,i) = Max - double(i)*(Max-Min)/double(Dim-1);
631          Mtx.At(i, 0) = Mtx.At(0, i) = Max - double(i)*(Max-Med)/double(Dim-1);
632          Mtx.At(i, Dim-1) = Mtx.At(Dim-1, i) = Med - double(i)*(Med-Min)/double(Dim-1);
633        }
634        for (int i = 1; i < Dim-1; i++) {
635          for (int j = 1; j < Dim-1; j++) {
636            if (i >= j) { continue; }
637            Mtx.At(i,j) = Mtx.At(j,i) = Mtx.At(i,i) - (j-i)*(Mtx.At(i,i)-Mtx.At(i,Dim-1))/(Dim-i-1);
638          }
639        }
640        Mtx.AddRndNoise(0.1);
641      }
642    } else { FailR("Wrong mtx: matlab str, or random (r), or all (a)"); }
643    Mtx.SetForEdges(Nodes, Edges);
644    return Mtx;
645  }
646  TKronMtx TKronMtx::GetMtxFromNm(const TStr& MtxNm) {
647    if (MtxNm == "3chain") return TKronMtx::GetMtx("1 1 0; 1 1 1; 0 1 1");
648    else if (MtxNm == "4star") return TKronMtx::GetMtx("1 1 1 1; 1 1 0 0 ; 1 0 1 0; 1 0 0 1");
649    else if (MtxNm == "4chain") return TKronMtx::GetMtx("1 1 0 0; 1 1 1 0 ; 0 1 1 1; 0 0 1 1");
650    else if (MtxNm == "4square") return TKronMtx::GetMtx("1 1 0 1; 1 1 1 0 ; 0 1 1 1; 1 0 1 1");
651    else if (MtxNm == "5star") return TKronMtx::GetMtx("1 1 1 1 1; 1 1 0 0 0; 1 0 1 0 0; 1 0 0 1 0; 1 0 0 0 1");
652    else if (MtxNm == "6star") return TKronMtx::GetMtx("1 1 1 1 1 1; 1 1 0 0 0 0; 1 0 1 0 0 0; 1 0 0 1 0 0; 1 0 0 0 1 0; 1 0 0 0 0 1");
653    else if (MtxNm == "7star") return TKronMtx::GetMtx("1 1 1 1 1 1 1; 1 1 0 0 0 0 0; 1 0 1 0 0 0 0; 1 0 0 1 0 0 0; 1 0 0 0 1 0 0; 1 0 0 0 0 1 0; 1 0 0 0 0 0 1");
654    else if (MtxNm == "5burst") return TKronMtx::GetMtx("1 1 1 1 0; 1 1 0 0 0; 1 0 1 0 0; 1 0 0 1 1; 0 0 0 1 1");
655    else if (MtxNm == "7burst") return TKronMtx::GetMtx("1 0 0 1 0 0 0; 0 1 0 1 0 0 0; 0 0 1 1 0 0 0; 1 1 1 1 1 0 0; 0 0 0 1 1 1 1; 0 0 0 0 1 1 0; 0 0 0 0 1 0 1");
656    else if (MtxNm == "7cross") return TKronMtx::GetMtx("1 0 0 1 0 0 0; 0 1 0 1 0 0 0; 0 0 1 1 0 0 0; 1 1 1 1 1 0 0; 0 0 0 1 1 1 0; 0 0 0 0 1 1 1; 0 0 0 0 0 1 1");
657    FailR(TStr::Fmt("Unknow matrix: '%s'", MtxNm.CStr()).CStr());
658    return TKronMtx();
659  }
660  TKronMtx TKronMtx::LoadTxt(const TStr& MtxFNm) {
661    PSs Ss = TSs::LoadTxt(ssfTabSep, MtxFNm);
662    IAssertR(Ss->GetXLen() == Ss->GetYLen(), "Not a square matrix");
663    IAssert(Ss->GetYLen() == Ss->GetXLen());
664    TKronMtx Mtx(Ss->GetYLen());
665    for (int r = 0; r < Ss->GetYLen(); r++) {
666      for (int c = 0; c < Ss->GetXLen(); c++) {
667        Mtx.At(r, c) = (double) Ss->At(c, r).GetFlt(); }
668    }
669    return Mtx;
670  }
671  TKroneckerLL::TKroneckerLL(const PNGraph& GraphPt, const TFltV& ParamV, const double& PermPSwapNd): PermSwapNodeProb(PermPSwapNd) {
672    InitLL(GraphPt, TKronMtx(ParamV));
673  }
674  TKroneckerLL::TKroneckerLL(const PNGraph& GraphPt, const TKronMtx& ParamMtx, const double& PermPSwapNd) : PermSwapNodeProb(PermPSwapNd) {
675    InitLL(GraphPt, ParamMtx);
676  }
677  TKroneckerLL::TKroneckerLL(const PNGraph& GraphPt, const TKronMtx& ParamMtx, const TIntV& NodeIdPermV, const double& PermPSwapNd) : PermSwapNodeProb(PermPSwapNd) {
678    InitLL(GraphPt, ParamMtx);
679    NodePerm = NodeIdPermV;
680    SetIPerm(NodePerm);
681  }
682  PKroneckerLL TKroneckerLL::New(const PNGraph& GraphPt, const TKronMtx& ParamMtx, const double& PermPSwapNd) {
683    return new TKroneckerLL(GraphPt, ParamMtx, PermPSwapNd);
684  }
685  PKroneckerLL TKroneckerLL::New(const PNGraph& GraphPt, const TKronMtx& ParamMtx, const TIntV& NodeIdPermV, const double& PermPSwapNd) {
686    return new TKroneckerLL(GraphPt, ParamMtx, NodeIdPermV, PermPSwapNd);
687  }
688  void TKroneckerLL::SetPerm(const char& PermId) {
689    if (PermId == 'o') { SetOrderPerm(); }
690    else if (PermId == 'd') { SetDegPerm(); }
691    else if (PermId == 'r') { SetRndPerm(); }
692    else if (PermId == 'b') { SetBestDegPerm(); }
693    else FailR("Unknown permutation type (o,d,r)");
694  }
695  void TKroneckerLL::SetOrderPerm() {
696    NodePerm.Gen(Nodes, 0);
697    for (int i = 0; i < Graph->GetNodes(); i++) {
698      NodePerm.Add(i); }
699    SetIPerm(NodePerm);
700  }
701  void TKroneckerLL::SetRndPerm() {
702    NodePerm.Gen(Nodes, 0);
703    for (int i = 0; i < Graph->GetNodes(); i++) {
704      NodePerm.Add(i); }
705    NodePerm.Shuffle(TKronMtx::Rnd);
706    SetIPerm(NodePerm);
707  }
708  void TKroneckerLL::SetDegPerm() {
709    TIntPrV DegNIdV;
710    for (TNGraph::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++) {
711      DegNIdV.Add(TIntPr(NI.GetDeg(), NI.GetId()));
712    }
713    DegNIdV.Sort(false);
714    NodePerm.Gen(DegNIdV.Len(), 0);
715    for (int i = 0; i < DegNIdV.Len(); i++) {
716      NodePerm.Add(DegNIdV[i].Val2);
717    }
718    SetIPerm(NodePerm);
719  }
720  void TKroneckerLL::SetBestDegPerm() {
721    NodePerm.Gen(Nodes);
722    const int NZero = ProbMtx.GetDim();
723    TFltIntPrV DegV(Nodes), CDegV(Nodes);
724    TFltV Row(NZero);
725    TFltV Col(NZero);
726    for(int i = 0; i < NZero; i++) {
727  	  for(int j = 0; j < NZero; j++) {
728  		  Row[i] += ProbMtx.At(i, j);
729  		  Col[i] += ProbMtx.At(j, i);
730  	  }
731    }
732    for(int i = 0; i < Nodes; i++) {
733  	  TNGraph::TNodeI NodeI = Graph->GetNI(i);
734  	  int NId = i;
735  	  double RowP = 1.0, ColP = 1.0;
736  	  for(int j = 0; j < KronIters; j++) {
737  		  int Bit = NId % NZero;
738  		  RowP *= Row[Bit];		ColP *= Col[Bit];
739  		  NId /= NZero;
740  	  }
741  	  CDegV[i] = TFltIntPr(RowP + ColP, i);
742  	  DegV[i] = TFltIntPr(NodeI.GetDeg(), i);
743    }
744    DegV.Sort(false);		CDegV.Sort(false);
745    for(int i = 0; i < Nodes; i++) {
746  	  NodePerm[DegV[i].Val2] = CDegV[i].Val2;
747    }
748    SetIPerm(NodePerm);
749  }
750  void TKroneckerLL::SetIPerm(const TIntV& Perm) {
751  	InvertPerm.Gen(Perm.Len());
752  	for (int i = 0; i < Perm.Len(); i++) {
753  		InvertPerm[Perm[i]] = i;
754  	}
755  }
756  void TKroneckerLL::SetGraph(const PNGraph& GraphPt) {
757    Graph = GraphPt;
758    bool NodesOk = true;
759    for (int nid = 0; nid < Graph->GetNodes(); nid++) {
760      if (! Graph->IsNode(nid)) { NodesOk=false; break; } }
761    if (! NodesOk) {
762      TIntV NIdV;  GraphPt->GetNIdV(NIdV);
763      Graph = TSnap::GetSubGraph(GraphPt, NIdV, true);
764      for (int nid = 0; nid < Graph->GetNodes(); nid++) {
765        IAssert(Graph->IsNode(nid)); }
766    }
767    Nodes = Graph->GetNodes();
768    IAssert(LLMtx.GetDim() > 1 && LLMtx.Len() == ProbMtx.Len());
769    KronIters = (int) ceil(log(double(Nodes)) / log(double(ProbMtx.GetDim())));
770      GEdgeV.Gen(Graph->GetEdges(), 0);
771      for (TNGraph::TEdgeI EI = Graph->BegEI(); EI < Graph->EndEI(); EI++) {
772        if (EI.GetSrcNId() != EI.GetDstNId()) {
773          GEdgeV.Add(TIntTr(EI.GetSrcNId(), EI.GetDstNId(), -1));
774        }
775      }
776    RealNodes = Nodes;
777    RealEdges = Graph->GetEdges();
778    LEdgeV = TIntTrV();
779    LSelfEdge = 0;
780  }
781  void TKroneckerLL::AppendIsoNodes() {
782    Nodes = (int) pow((double)ProbMtx.GetDim(), KronIters);
783    for (int nid = Graph->GetNodes(); nid < Nodes; nid++) {
784  	  Graph->AddNode(nid);
785    }
786  }
787  void TKroneckerLL::RestoreGraph(const bool RestoreNodes) {
788  	int NId1, NId2;
789  	for (int e = 0; e < LEdgeV.Len(); e++) {
790      	NId1 = LEdgeV[e].Val1;  NId2 = LEdgeV[e].Val2;
791  		Graph->DelEdge(NId1, NId2);
792  	}
793  	if(LEdgeV.Len() - LSelfEdge)
794  		GEdgeV.Del(GEdgeV.Len() - LEdgeV.Len() + LSelfEdge, GEdgeV.Len() - 1);
795  	LEdgeV.Clr();
796  	LSelfEdge = 0;
797  	if(RestoreNodes) {
798  		for(int i = Graph->GetNodes()-1; i >= RealNodes; i--) {
799  			Graph->DelNode(i);
800  		}
801  	}
802  }
803  double TKroneckerLL::GetFullGraphLL() const {
804    double ElemCnt = 1;
805    const double dim = LLMtx.GetDim();
806    for (int i = 1; i < KronIters; i++) {
807      ElemCnt = dim*dim*ElemCnt + TMath::Power(dim, 2*i);
808    }
809    return ElemCnt * LLMtx.GetMtxSum();
810  }
811  double TKroneckerLL::GetFullRowLL(int RowId) const {
812    double RowLL = 0.0;
813    const int MtxDim = LLMtx.GetDim();
814    for (int level = 0; level < KronIters; level++) {
815      RowLL += LLMtx.GetRowSum(RowId % MtxDim);
816      RowId /= MtxDim;
817    }
818    return RowLL;
819  }
820  double TKroneckerLL::GetFullColLL(int ColId) const {
821    double ColLL = 0.0;
822    const int MtxDim = LLMtx.GetDim();
823    for (int level = 0; level < KronIters; level++) {
824      ColLL += LLMtx.GetColSum(ColId % MtxDim);
825      ColId /= MtxDim;
826    }
827    return ColLL;
828  }
829  double TKroneckerLL::GetEmptyGraphLL() const {
830    double LL = 0;
831    for (int NId1 = 0; NId1 < LLMtx.GetNodes(KronIters); NId1++) {
832      for (int NId2 = 0; NId2 < LLMtx.GetNodes(KronIters); NId2++) {
833        LL = LL + LLMtx.GetNoEdgeLL(NId1, NId2, KronIters);
834      }
835    }
836    return LL;
837  }
838  double TKroneckerLL::GetApxEmptyGraphLL() const {
839    double Sum=0.0, SumSq=0.0;
840    for (int i = 0; i < ProbMtx.Len(); i++) {
841      Sum += ProbMtx.At(i);
842      SumSq += TMath::Sqr(ProbMtx.At(i));
843    }
844    return -pow(Sum, KronIters) - 0.5*pow(SumSq, KronIters);
845  }
846  void TKroneckerLL::InitLL(const TFltV& ParamV) {
847    InitLL(TKronMtx(ParamV));
848  }
849  void TKroneckerLL::InitLL(const TKronMtx& ParamMtx) {
850    IAssert(ParamMtx.IsProbMtx());
851    ProbMtx = ParamMtx;
852    ProbMtx.GetLLMtx(LLMtx);
853    LogLike = TKronMtx::NInf;
854    if (GradV.Len() != ProbMtx.Len()) {
855      GradV.Gen(ProbMtx.Len()); }
856    GradV.PutAll(0.0);
857  }
858  void TKroneckerLL::InitLL(const PNGraph& GraphPt, const TKronMtx& ParamMtx) {
859    IAssert(ParamMtx.IsProbMtx());
860    ProbMtx = ParamMtx;
861    ProbMtx.GetLLMtx(LLMtx);
862    SetGraph(GraphPt);
863    LogLike = TKronMtx::NInf;
864    if (GradV.Len() != ProbMtx.Len()) {
865      GradV.Gen(ProbMtx.Len()); }
866    GradV.PutAll(0.0);
867  }
868  double TKroneckerLL::CalcGraphLL() {
869    LogLike = GetEmptyGraphLL(); 
870    for (int nid = 0; nid < Nodes; nid++) {
871      const TNGraph::TNodeI Node = Graph->GetNI(nid);
872      const int SrcNId = NodePerm[nid];
873      for (int e = 0; e < Node.GetOutDeg(); e++) {
874        const int DstNId = NodePerm[Node.GetOutNId(e)];
875        LogLike = LogLike - LLMtx.GetNoEdgeLL(SrcNId, DstNId, KronIters)
876          + LLMtx.GetEdgeLL(SrcNId, DstNId, KronIters);
877      }
878    }
879    return LogLike;
880  }
881  double TKroneckerLL::CalcApxGraphLL() {
882    LogLike = GetApxEmptyGraphLL(); 
883    for (int nid = 0; nid < Nodes; nid++) {
884      const TNGraph::TNodeI Node = Graph->GetNI(nid);
885      const int SrcNId = NodePerm[nid];
886      for (int e = 0; e < Node.GetOutDeg(); e++) {
887        const int DstNId = NodePerm[Node.GetOutNId(e)];
888        LogLike = LogLike - LLMtx.GetApxNoEdgeLL(SrcNId, DstNId, KronIters)
889          + LLMtx.GetEdgeLL(SrcNId, DstNId, KronIters);
890      }
891    }
892    return LogLike;
893  }
894  double TKroneckerLL::NodeLLDelta(const int& NId) const {
895    if (! Graph->IsNode(NId)) { return 0.0; } 
896    double Delta = 0.0;
897    const TNGraph::TNodeI Node = Graph->GetNI(NId);
898    const int SrcRow = NodePerm[NId];
899    for (int e = 0; e < Node.GetOutDeg(); e++) {
900      const int DstCol = NodePerm[Node.GetOutNId(e)];
901      Delta += - LLMtx.GetApxNoEdgeLL(SrcRow, DstCol, KronIters)
902        + LLMtx.GetEdgeLL(SrcRow, DstCol, KronIters);
903    }
904    const int SrcCol = NodePerm[NId];
905    for (int e = 0; e < Node.GetInDeg(); e++) {
906      const int DstRow = NodePerm[Node.GetInNId(e)];
907      Delta += - LLMtx.GetApxNoEdgeLL(DstRow, SrcCol, KronIters)
908        + LLMtx.GetEdgeLL(DstRow, SrcCol, KronIters);
909    }
910    if (Graph->IsEdge(NId, NId)) {
911      Delta += + LLMtx.GetApxNoEdgeLL(SrcRow, SrcCol, KronIters)
912        - LLMtx.GetEdgeLL(SrcRow, SrcCol, KronIters);
913      IAssert(SrcRow == SrcCol);
914    }
915    return Delta;
916  }
917  double TKroneckerLL::SwapNodesLL(const int& NId1, const int& NId2) {
918    LogLike = LogLike - NodeLLDelta(NId1) - NodeLLDelta(NId2);
919    const int PrevId1 = NodePerm[NId1], PrevId2 = NodePerm[NId2];
920    if (Graph->IsEdge(NId1, NId2)) {
921      LogLike += - LLMtx.GetApxNoEdgeLL(PrevId1, PrevId2, KronIters)
922        + LLMtx.GetEdgeLL(PrevId1, PrevId2, KronIters); }
923    if (Graph->IsEdge(NId2, NId1)) {
924      LogLike += - LLMtx.GetApxNoEdgeLL(PrevId2, PrevId1, KronIters)
925        + LLMtx.GetEdgeLL(PrevId2, PrevId1, KronIters); }
926    NodePerm.Swap(NId1, NId2);
927    InvertPerm.Swap(NodePerm[NId1], NodePerm[NId2]);
928    LogLike = LogLike + NodeLLDelta(NId1) + NodeLLDelta(NId2);
929    const int NewId1 = NodePerm[NId1], NewId2 = NodePerm[NId2];
930    if (Graph->IsEdge(NId1, NId2)) {
931      LogLike += + LLMtx.GetApxNoEdgeLL(NewId1, NewId2, KronIters)
932        - LLMtx.GetEdgeLL(NewId1, NewId2, KronIters); }
933    if (Graph->IsEdge(NId2, NId1)) {
934      LogLike += + LLMtx.GetApxNoEdgeLL(NewId2, NewId1, KronIters)
935        - LLMtx.GetEdgeLL(NewId2, NewId1, KronIters); }
936    return LogLike;
937  }
938  bool TKroneckerLL::SampleNextPerm(int& NId1, int& NId2) {
939    if (TKronMtx::Rnd.GetUniDev() < PermSwapNodeProb) {
940      NId1 = TKronMtx::Rnd.GetUniDevInt(Nodes);
941      NId2 = TKronMtx::Rnd.GetUniDevInt(Nodes);
942      while (NId2 == NId1) { NId2 = TKronMtx::Rnd.GetUniDevInt(Nodes); }
943    } else {
944      const int e = TKronMtx::Rnd.GetUniDevInt(GEdgeV.Len());
945      NId1 = GEdgeV[e].Val1;  NId2 = GEdgeV[e].Val2;
946    }
947    const double U = TKronMtx::Rnd.GetUniDev();
948    const double OldLL = LogLike;
949    const double NewLL = SwapNodesLL(NId1, NId2);
950    const double LogU = log(U);
951    if (LogU > NewLL - OldLL) { 
952      LogLike = OldLL;
953      NodePerm.Swap(NId2, NId1); 
954  	InvertPerm.Swap(NodePerm[NId2], NodePerm[NId1]); 
955      return false;
956    }
957    return true; 
958  }
959  double TKroneckerLL::GetEmptyGraphDLL(const int& ParamId) const {
960    double DLL = 0.0;
961    for (int NId1 = 0; NId1 < Nodes; NId1++) {
962      for (int NId2 = 0; NId2 < Nodes; NId2++) {
963        DLL += LLMtx.GetNoEdgeDLL(ParamId, NodePerm[NId1], NodePerm[NId2], KronIters);
964      }
965    }
966    return DLL;
967  }
968  double TKroneckerLL::GetApxEmptyGraphDLL(const int& ParamId) const {
969    double Sum=0.0, SumSq=0.0;
970    for (int i = 0; i < ProbMtx.Len(); i++) {
971      Sum += ProbMtx.At(i);
972      SumSq += TMath::Sqr(ProbMtx.At(i));
973    }
974    return -KronIters*pow(Sum, KronIters-1) - KronIters*pow(SumSq, KronIters-1)*ProbMtx.At(ParamId);
975  }
976  const TFltV& TKroneckerLL::CalcGraphDLL() {
977    for (int ParamId = 0; ParamId < LLMtx.Len(); ParamId++) {
978      double DLL = 0.0;
979      for (int NId1 = 0; NId1 < Nodes; NId1++) {
980        for (int NId2 = 0; NId2 < Nodes; NId2++) {
981          if (Graph->IsEdge(NId1, NId2)) {
982            DLL += LLMtx.GetEdgeDLL(ParamId, NodePerm[NId1], NodePerm[NId2], KronIters);
983          } else {
984            DLL += LLMtx.GetNoEdgeDLL(ParamId, NodePerm[NId1], NodePerm[NId2], KronIters);
985          }
986        }
987      }
988      GradV[ParamId] = DLL;
989    }
990    return GradV;
991  }
992  const TFltV& TKroneckerLL::CalcFullApxGraphDLL() {
993    for (int ParamId = 0; ParamId < LLMtx.Len(); ParamId++) {
994      double DLL = 0.0;
995      for (int NId1 = 0; NId1 < Nodes; NId1++) {
996        for (int NId2 = 0; NId2 < Nodes; NId2++) {
997          if (Graph->IsEdge(NId1, NId2)) {
998            DLL += LLMtx.GetEdgeDLL(ParamId, NodePerm[NId1], NodePerm[NId2], KronIters);
999          } else {
1000            DLL += LLMtx.GetApxNoEdgeDLL(ParamId, NodePerm[NId1], NodePerm[NId2], KronIters);
1001          }
1002        }
1003      }
1004      GradV[ParamId] = DLL;
1005    }
1006    return GradV;
1007  }
1008  const TFltV& TKroneckerLL::CalcApxGraphDLL() {
1009    for (int ParamId = 0; ParamId < LLMtx.Len(); ParamId++) {
1010      double DLL = GetApxEmptyGraphDLL(ParamId);
1011      for (int nid = 0; nid < Nodes; nid++) {
1012        const TNGraph::TNodeI Node = Graph->GetNI(nid);
1013        const int SrcNId = NodePerm[nid];
1014        for (int e = 0; e < Node.GetOutDeg(); e++) {
1015          const int DstNId = NodePerm[Node.GetOutNId(e)];
1016          DLL = DLL - LLMtx.GetApxNoEdgeDLL(ParamId, SrcNId, DstNId, KronIters)
1017            + LLMtx.GetEdgeDLL(ParamId, SrcNId, DstNId, KronIters);
1018        }
1019      }
1020      GradV[ParamId] = DLL;
1021    }
1022    return GradV;
1023  }
1024  double TKroneckerLL::NodeDLLDelta(const int ParamId, const int& NId) const {
1025    if (! Graph->IsNode(NId)) { return 0.0; } 
1026    double Delta = 0.0;
1027    const TNGraph::TNodeI Node = Graph->GetNI(NId);
1028    const int SrcRow = NodePerm[NId];
1029    for (int e = 0; e < Node.GetOutDeg(); e++) {
1030      const int DstCol = NodePerm[Node.GetOutNId(e)];
1031      Delta += - LLMtx.GetApxNoEdgeDLL(ParamId, SrcRow, DstCol, KronIters)
1032        + LLMtx.GetEdgeDLL(ParamId, SrcRow, DstCol, KronIters);
1033    }
1034    const int SrcCol = NodePerm[NId];
1035    for (int e = 0; e < Node.GetInDeg(); e++) {
1036      const int DstRow = NodePerm[Node.GetInNId(e)];
1037      Delta += - LLMtx.GetApxNoEdgeDLL(ParamId, DstRow, SrcCol, KronIters)
1038        + LLMtx.GetEdgeDLL(ParamId, DstRow, SrcCol, KronIters);
1039    }
1040    if (Graph->IsEdge(NId, NId)) {
1041      Delta += + LLMtx.GetApxNoEdgeDLL(ParamId, SrcRow, SrcCol, KronIters)
1042        - LLMtx.GetEdgeDLL(ParamId, SrcRow, SrcCol, KronIters);
1043      IAssert(SrcRow == SrcCol);
1044    }
1045    return Delta;
1046  }
1047  void TKroneckerLL::UpdateGraphDLL(const int& SwapNId1, const int& SwapNId2) {
1048    for (int ParamId = 0; ParamId < LLMtx.Len(); ParamId++) {
1049      NodePerm.Swap(SwapNId1, SwapNId2);
1050      TFlt& DLL = GradV[ParamId];
1051      DLL = DLL - NodeDLLDelta(ParamId, SwapNId1) - NodeDLLDelta(ParamId, SwapNId2);
1052      const int PrevId1 = NodePerm[SwapNId1], PrevId2 = NodePerm[SwapNId2];
1053      if (Graph->IsEdge(SwapNId1, SwapNId2)) {
1054        DLL += - LLMtx.GetApxNoEdgeDLL(ParamId, PrevId1, PrevId2, KronIters)
1055          + LLMtx.GetEdgeDLL(ParamId, PrevId1, PrevId2, KronIters); }
1056      if (Graph->IsEdge(SwapNId2, SwapNId1)) {
1057        DLL += - LLMtx.GetApxNoEdgeDLL(ParamId, PrevId2, PrevId1, KronIters)
1058          + LLMtx.GetEdgeDLL(ParamId, PrevId2, PrevId1, KronIters); }
1059      NodePerm.Swap(SwapNId1, SwapNId2);
1060      DLL = DLL + NodeDLLDelta(ParamId, SwapNId1) + NodeDLLDelta(ParamId, SwapNId2);
1061      const int NewId1 = NodePerm[SwapNId1], NewId2 = NodePerm[SwapNId2];
1062      if (Graph->IsEdge(SwapNId1, SwapNId2)) {
1063        DLL += + LLMtx.GetApxNoEdgeDLL(ParamId, NewId1, NewId2, KronIters)
1064          - LLMtx.GetEdgeDLL(ParamId, NewId1, NewId2, KronIters); }
1065      if (Graph->IsEdge(SwapNId2, SwapNId1)) {
1066        DLL += + LLMtx.GetApxNoEdgeDLL(ParamId, NewId2, NewId1, KronIters)
1067          - LLMtx.GetEdgeDLL(ParamId, NewId2, NewId1, KronIters); }
1068    }
1069  }
1070  void TKroneckerLL::SampleGradient(const int& WarmUp, const int& NSamples, double& AvgLL, TFltV& AvgGradV) {
1071    printf("SampleGradient: %s (%s warm-up):", TInt::GetMegaStr(NSamples).CStr(), TInt::GetMegaStr(WarmUp).CStr());
1072    int NId1=0, NId2=0, NAccept=0;
1073    TExeTm ExeTm1;
1074    if (WarmUp > 0) {
1075      CalcApxGraphLL();
1076      for (int s = 0; s < WarmUp; s++) { SampleNextPerm(NId1, NId2); }
1077      printf("  warm-up:%s,", ExeTm1.GetTmStr());  ExeTm1.Tick();
1078    }
1079    CalcApxGraphLL(); 
1080    CalcApxGraphDLL();
1081    AvgLL = 0;
1082    AvgGradV.Gen(LLMtx.Len());  AvgGradV.PutAll(0.0);
1083    printf("  sampl");
1084    for (int s = 0; s < NSamples; s++) {
1085      if (SampleNextPerm(NId1, NId2)) { 
1086        UpdateGraphDLL(NId1, NId2);  NAccept++; }
1087      for (int m = 0; m < LLMtx.Len(); m++) { AvgGradV[m] += GradV[m]; }
1088      AvgLL += GetLL();
1089    }
1090    printf("ing");
1091    AvgLL = AvgLL / double(NSamples);
1092    for (int m = 0; m < LLMtx.Len(); m++) {
1093      AvgGradV[m] = AvgGradV[m] / double(NSamples); }
1094    printf(":%s (%.0f/s), accept %.1f%%\n", ExeTm1.GetTmStr(), double(NSamples)/ExeTm1.GetSecs(),
1095      double(100*NAccept)/double(NSamples));
1096  }
1097  double TKroneckerLL::GradDescent(const int& NIter, const double& LrnRate, double MnStep, double MxStep, const int& WarmUp, const int& NSamples) {
1098    printf("\n----------------------------------------------------------------------\n");
1099    printf("Fitting graph on %d nodes, %d edges\n", Graph->GetNodes(), Graph->GetEdges());
1100    printf("Kron iters:  %d (== %d nodes)\n\n", KronIters(), ProbMtx.GetNodes(KronIters()));
1101    TExeTm IterTm, TotalTm;
1102    double OldLL=-1e10, CurLL=0;
1103    const double EZero = pow((double) Graph->GetEdges(), 1.0/double(KronIters));
1104    TFltV CurGradV, LearnRateV(GetParams()), LastStep(GetParams());
1105    LearnRateV.PutAll(LrnRate);
1106    TKronMtx NewProbMtx = ProbMtx;
1107    if(DebugMode) {  
1108  	  LLV.Gen(NIter, 0);
1109  	  MtxV.Gen(NIter, 0);
1110    }
1111    for (int Iter = 0; Iter < NIter; Iter++) {
1112      printf("%03d] ", Iter);
1113      SampleGradient(WarmUp, NSamples, CurLL, CurGradV);
1114      for (int p = 0; p < GetParams(); p++) {
1115        LearnRateV[p] *= 0.95;
1116        if (Iter < 1) {
1117          while (fabs(LearnRateV[p]*CurGradV[p]) > MxStep) { LearnRateV[p] *= 0.95; }
1118          while (fabs(LearnRateV[p]*CurGradV[p]) < 0.02) { LearnRateV[p] *= (1.0/0.95); } 
1119        } else {
1120          while (fabs(LearnRateV[p]*CurGradV[p]) > MxStep) { LearnRateV[p] *= 0.95; printf(".");}
1121          while (fabs(LearnRateV[p]*CurGradV[p]) < MnStep) { LearnRateV[p] *= (1.0/0.95); printf("*");}
1122          if (MxStep > 3*MnStep) { MxStep *= 0.95; }
1123        }
1124        NewProbMtx.At(p) = ProbMtx.At(p) + LearnRateV[p]*CurGradV[p];
1125        if (NewProbMtx.At(p) > 0.9999) { NewProbMtx.At(p)=0.9999; }
1126        if (NewProbMtx.At(p) < 0.0001) { NewProbMtx.At(p)=0.0001; }
1127      }
1128      printf("  trueE0: %.2f (%d),  estE0: %.2f (%d),  ERR: %f\n", EZero, Graph->GetEdges(),
1129        ProbMtx.GetMtxSum(), ProbMtx.GetEdges(KronIters), fabs(EZero-ProbMtx.GetMtxSum()));
1130      printf("  currLL: %.4f, deltaLL: %.4f\n", CurLL, CurLL-OldLL); 
1131      for (int p = 0; p < GetParams(); p++) {
1132        printf("    %d]  %f  <--  %f + %9f   Grad: %9.1f   Rate: %g\n", p, NewProbMtx.At(p),
1133          ProbMtx.At(p), (double)(LearnRateV[p]*CurGradV[p]), CurGradV[p](), LearnRateV[p]());
1134      }
1135      if (Iter+1 < NIter) { 
1136        ProbMtx = NewProbMtx;  ProbMtx.GetLLMtx(LLMtx); }
1137      OldLL=CurLL;
1138      printf("\n");  fflush(stdout);
1139  	if(DebugMode) {  
1140  		LLV.Add(CurLL);
1141  		MtxV.Add(NewProbMtx);
1142  	}
1143    }
1144    printf("TotalExeTm: %s %g\n", TotalTm.GetStr(), TotalTm.GetSecs());
1145    ProbMtx.Dump("FITTED PARAMS", false);
1146    return CurLL;
1147  }
1148  double TKroneckerLL::GradDescent2(const int& NIter, const double& LrnRate, double MnStep, double MxStep, const int& WarmUp, const int& NSamples) {
1149    printf("\n----------------------------------------------------------------------\n");
1150    printf("GradDescent2\n");
1151    printf("Fitting graph on %d nodes, %d edges\n", Graph->GetNodes(), Graph->GetEdges());
1152    printf("Skip moves that make likelihood smaller\n");
1153    printf("Kron iters:  %d (== %d nodes)\n\n", KronIters(), ProbMtx.GetNodes(KronIters()));
1154    TExeTm IterTm, TotalTm;
1155    double CurLL=0, NewLL=0;
1156    const double EZero = pow((double) Graph->GetEdges(), 1.0/double(KronIters));
1157    TFltV CurGradV, NewGradV, LearnRateV(GetParams()), LastStep(GetParams());
1158    LearnRateV.PutAll(LrnRate);
1159    TKronMtx NewProbMtx=ProbMtx, CurProbMtx=ProbMtx;
1160    bool GoodMove = false;
1161    for (int Iter = 0; Iter < NIter; Iter++) {
1162      printf("%03d] ", Iter);
1163      if (! GoodMove) { SampleGradient(WarmUp, NSamples, CurLL, CurGradV); }
1164      CurProbMtx = ProbMtx;
1165      for (int p = 0; p < GetParams(); p++) {
1166        while (fabs(LearnRateV[p]*CurGradV[p]) > MxStep) { LearnRateV[p] *= 0.95; printf(".");}
1167        while (fabs(LearnRateV[p]*CurGradV[p]) < MnStep) { LearnRateV[p] *= (1.0/0.95); printf("*");}
1168        NewProbMtx.At(p) = CurProbMtx.At(p) + LearnRateV[p]*CurGradV[p];
1169        if (NewProbMtx.At(p) > 0.9999) { NewProbMtx.At(p)=0.9999; }
1170        if (NewProbMtx.At(p) < 0.0001) { NewProbMtx.At(p)=0.0001; }
1171        LearnRateV[p] *= 0.95;
1172      }
1173      printf("  ");
1174      ProbMtx=NewProbMtx;  ProbMtx.GetLLMtx(LLMtx);
1175      SampleGradient(WarmUp, NSamples, NewLL, NewGradV);
1176      if (NewLL > CurLL) { 
1177        printf("== Good move:\n");
1178        printf("  trueE0: %.2f (%d),  estE0: %.2f (%d),  ERR: %f\n", EZero, Graph->GetEdges(),
1179          ProbMtx.GetMtxSum(), ProbMtx.GetEdges(KronIters), fabs(EZero-ProbMtx.GetMtxSum()));
1180        printf("  currLL: %.4f  deltaLL: %.4f\n", CurLL, NewLL-CurLL); 
1181        for (int p = 0; p < GetParams(); p++) {
1182          printf("    %d]  %f  <--  %f + %9f   Grad: %9.1f   Rate: %g\n", p, NewProbMtx.At(p),
1183            CurProbMtx.At(p), (double)(LearnRateV[p]*CurGradV[p]), CurGradV[p](), LearnRateV[p]()); }
1184        CurLL = NewLL;
1185        CurGradV = NewGradV;
1186        GoodMove = true;
1187      } else {
1188        printf("** BAD move:\n");
1189        printf("  *trueE0: %.2f (%d),  estE0: %.2f (%d),  ERR: %f\n", EZero, Graph->GetEdges(),
1190          ProbMtx.GetMtxSum(), ProbMtx.GetEdges(KronIters), fabs(EZero-ProbMtx.GetMtxSum()));
1191        printf("  *curLL:  %.4f  deltaLL: %.4f\n", CurLL, NewLL-CurLL); 
1192        for (int p = 0; p < GetParams(); p++) {
1193          printf("   b%d]  %f  <--  %f + %9f   Grad: %9.1f   Rate: %g\n", p, NewProbMtx.At(p),
1194            CurProbMtx.At(p), (double)(LearnRateV[p]*CurGradV[p]), CurGradV[p](), LearnRateV[p]()); }
1195        ProbMtx = CurProbMtx;  ProbMtx.GetLLMtx(LLMtx);
1196        GoodMove = false;
1197      }
1198      printf("\n");  fflush(stdout);
1199    }
1200    printf("TotalExeTm: %s %g\n", TotalTm.GetStr(), TotalTm.GetSecs());
1201    ProbMtx.Dump("FITTED PARAMS\n", false);
1202    return CurLL;
1203  }
1204  void TKroneckerLL::SetRandomEdges(const int& NEdges, const bool isDir) {
1205  	int count = 0, added = 0, collision = 0;
1206  	const int MtxDim = ProbMtx.GetDim();
1207  	const double MtxSum = ProbMtx.GetMtxSum();
1208  	TVec<TFltIntIntTr> ProbToRCPosV; 
1209  	double CumProb = 0.0;
1210  	for(int r = 0; r < MtxDim; r++) {
1211  		for(int c = 0; c < MtxDim; c++) {
1212  			const double Prob = ProbMtx.At(r, c);
1213  			if (Prob > 0.0) {
1214  				CumProb += Prob;
1215  				ProbToRCPosV.Add(TFltIntIntTr(CumProb/MtxSum, r, c));
1216  			}
1217  		}
1218  	}
1219  	int Rng, Row, Col, n, NId1, NId2;
1220  	while(added < NEdges) {
1221  		Rng = Nodes;	Row = 0;	Col = 0;
1222  		for (int iter = 0; iter < KronIters; iter++) {
1223  			const double& Prob = TKronMtx::Rnd.GetUniDev();
1224  			n = 0; while(Prob > ProbToRCPosV[n].Val1) { n++; }
1225  			const int MtxRow = ProbToRCPosV[n].Val2;
1226  			const int MtxCol = ProbToRCPosV[n].Val3;
1227  			Rng /= MtxDim;
1228  			Row += MtxRow * Rng;
1229  			Col += MtxCol * Rng;
1230  		}
1231  		count++;
1232  		NId1 = InvertPerm[Row];	NId2 = InvertPerm[Col];
1233  		if(EMType != kronEdgeMiss && IsObsEdge(NId1, NId2)) {
1234  			continue;
1235  		}
1236  		if (! Graph->IsEdge(NId1, NId2)) {
1237  			Graph->AddEdge(NId1, NId2);
1238  			if(NId1 != NId2)	{ GEdgeV.Add(TIntTr(NId1, NId2, LEdgeV.Len())); }
1239  			else { LSelfEdge++; }
1240  			LEdgeV.Add(TIntTr(NId1, NId2, GEdgeV.Len()-1));
1241  			added++;
1242  			if (! isDir) {
1243  				if (NId1 != NId2) {
1244  				   Graph->AddEdge(NId2, NId1);
1245  				   GEdgeV.Add(TIntTr(NId2, NId1, LEdgeV.Len()));
1246  				   LEdgeV.Add(TIntTr(NId2, NId1, GEdgeV.Len()-1));
1247  				   added++;
1248  				}
1249  			}
1250  		} else { collision ++; }
1251  	}
1252  }
1253  void TKroneckerLL::MetroGibbsSampleSetup(const int& WarmUp) {
1254  	double alpha = log(ProbMtx.GetMtxSum()) / log(double(ProbMtx.GetDim()));
1255  	int NId1 = 0, NId2 = 0;
1256  	int NMissing;
1257  	RestoreGraph(false);
1258  	if(EMType == kronEdgeMiss) {
1259  		CalcApxGraphLL();
1260  		for (int s = 0; s < WarmUp; s++)	SampleNextPerm(NId1, NId2);
1261  	}
1262  	if(EMType == kronFutureLink) {
1263  		NMissing = (int) (pow(ProbMtx.GetMtxSum(), KronIters) - pow(double(RealNodes), alpha));
1264  	} else if(EMType == kronEdgeMiss) {
1265  		NMissing = MissEdges;
1266  	} else {
1267  		NMissing = (int) (pow(ProbMtx.GetMtxSum(), KronIters) * (1.0 - pow(double(RealNodes) / double(Nodes), 2)));
1268  	}
1269  	NMissing = (NMissing < 1) ? 1 : NMissing;
1270  	SetRandomEdges(NMissing, true);
1271  	CalcApxGraphLL();
1272  	for (int s = 0; s < WarmUp; s++)	SampleNextPerm(NId1, NId2);
1273  }
1274  void TKroneckerLL::MetroGibbsSampleNext(const int& WarmUp, const bool DLLUpdate) {
1275  	int NId1 = 0, NId2 = 0, hit = 0, GId = 0;
1276  	TIntTr EdgeToRemove, NewEdge;
1277  	double RndAccept;
1278  	if(LEdgeV.Len()) {
1279  		for(int i = 0; i < WarmUp; i++) {
1280  			hit = TKronMtx::Rnd.GetUniDevInt(LEdgeV.Len());
1281  			NId1 = LEdgeV[hit].Val1;	NId2 = LEdgeV[hit].Val2;
1282  			GId = LEdgeV[hit].Val3;
1283  			SetRandomEdges(1, true);
1284  			NewEdge = LEdgeV.Last();
1285  			RndAccept = (1.0 - exp(LLMtx.GetEdgeLL(NewEdge.Val1, NewEdge.Val2, KronIters))) / (1.0 - exp(LLMtx.GetEdgeLL(NId1, NId2, KronIters)));
1286  			RndAccept = (RndAccept > 1.0) ? 1.0 : RndAccept;
1287  			if(TKronMtx::Rnd.GetUniDev() > RndAccept) { 
1288  				Graph->DelEdge(NewEdge.Val1, NewEdge.Val2);
1289  				if(NewEdge.Val1 != NewEdge.Val2) {	GEdgeV.DelLast();	}
1290  				else {	LSelfEdge--;	}
1291  				LEdgeV.DelLast();
1292  			} else {	
1293  				Graph->DelEdge(NId1, NId2);
1294  				LEdgeV[hit] = LEdgeV.Last();
1295  				LEdgeV.DelLast();
1296  				if(NId1 == NId2) {
1297  					LSelfEdge--;
1298  					if(NewEdge.Val1 != NewEdge.Val2) {
1299  						GEdgeV[GEdgeV.Len()-1].Val3 = hit;
1300  					}
1301  				} else {
1302  					IAssertR(GEdgeV.Last().Val3 >= 0, "Invalid indexing");
1303  					GEdgeV[GId] = GEdgeV.Last();
1304  					if(NewEdge.Val1 != NewEdge.Val2) {
1305  						GEdgeV[GId].Val3 = hit;
1306  					}
1307  					LEdgeV[GEdgeV[GId].Val3].Val3 = GId;
1308  					GEdgeV.DelLast();
1309  				}
1310        			LogLike += LLMtx.GetApxNoEdgeLL(EdgeToRemove.Val1, EdgeToRemove.Val2, KronIters) - LLMtx.GetEdgeLL(EdgeToRemove.Val1, EdgeToRemove.Val2, KronIters);
1311        			LogLike += -LLMtx.GetApxNoEdgeLL(NewEdge.Val1, NewEdge.Val2, KronIters) + LLMtx.GetEdgeLL(NewEdge.Val1, NewEdge.Val2, KronIters);
1312  				if(DLLUpdate) {
1313    					for (int p = 0; p < LLMtx.Len(); p++) {
1314  						GradV[p] += LLMtx.GetApxNoEdgeDLL(p, EdgeToRemove.Val1, EdgeToRemove.Val2, KronIters) - LLMtx.GetEdgeDLL(p, EdgeToRemove.Val1, EdgeToRemove.Val2, KronIters);
1315  						GradV[p] += -LLMtx.GetApxNoEdgeDLL(p, NewEdge.Val1, NewEdge.Val2, KronIters) + LLMtx.GetEdgeDLL(p, NewEdge.Val1, NewEdge.Val2, KronIters);
1316  					}
1317  				}
1318  			}
1319  		}
1320  	}
1321  	for (int s = 0; s < WarmUp; s++) {
1322  		if(SampleNextPerm(NId1, NId2)) {
1323  			if(DLLUpdate)	UpdateGraphDLL(NId1, NId2);
1324  		}
1325  	}
1326  }
1327  void TKroneckerLL::RunEStep(const int& GibbsWarmUp, const int& WarmUp, const int& NSamples, TFltV& LLV, TVec<TFltV>& DLLV) {
1328  	TExeTm ExeTm, TotalTm;
1329  	LLV.Gen(NSamples, 0);
1330  	DLLV.Gen(NSamples, 0);
1331  	ExeTm.Tick();
1332  	for(int i = 0; i < 2; i++)	MetroGibbsSampleSetup(WarmUp);
1333  	printf("  Warm-Up [%u] : %s\n", WarmUp, ExeTm.GetTmStr());
1334  	CalcApxGraphLL();
1335  	for(int i = 0; i < GibbsWarmUp; i++)	MetroGibbsSampleNext(10, false);
1336  	printf("  Gibbs Warm-Up [%u] : %s\n", GibbsWarmUp, ExeTm.GetTmStr());
1337  	ExeTm.Tick();
1338  	CalcApxGraphLL();
1339  	CalcApxGraphDLL();
1340  	for(int i = 0; i < NSamples; i++) {
1341  		MetroGibbsSampleNext(50, false);
1342  		LLV.Add(LogLike);
1343  		DLLV.Add(GradV);
1344  		int OnePercent = (i+1) % (NSamples / 10);
1345  		if(OnePercent == 0) {
1346  			int TenPercent = ((i+1) / (NSamples / 10)) * 10;
1347  			printf("  %3u%% done : %s\n", TenPercent, ExeTm.GetTmStr());
1348  		}
1349  	}
1350  }
1351  double TKroneckerLL::RunMStep(const TFltV& LLV, const TVec<TFltV>& DLLV, const int& GradIter, const double& LrnRate, double MnStep, double MxStep) {
1352  	TExeTm IterTm, TotalTm;
1353  	double OldLL=LogLike, CurLL=0;
1354  	const double alpha = log(double(RealEdges)) / log(double(RealNodes));
1355  	const double EZero = pow(double(ProbMtx.GetDim()), alpha);
1356  	TFltV CurGradV(GetParams()), LearnRateV(GetParams()), LastStep(GetParams());
1357  	LearnRateV.PutAll(LrnRate);
1358  	TKronMtx NewProbMtx = ProbMtx;
1359  	const int NSamples = LLV.Len();
1360  	const int ReCalcLen = NSamples / 10;
1361  	for (int s = 0; s < LLV.Len(); s++) {
1362  		CurLL += LLV[s];
1363  		for(int p = 0; p < GetParams(); p++) { CurGradV[p] += DLLV[s][p]; }
1364  	}
1365  	CurLL /= NSamples;
1366  	for(int p = 0; p < GetParams(); p++) { CurGradV[p] /= NSamples; }
1367  	double MaxLL = CurLL;
1368  	TKronMtx MaxProbMtx = ProbMtx;
1369  	TKronMtx OldProbMtx = ProbMtx;
1370  	for (int Iter = 0; Iter < GradIter; Iter++) {
1371  		printf("    %03d] ", Iter+1);
1372  		IterTm.Tick();
1373  		for (int p = 0; p < GetParams(); p++) {
1374  			if (Iter < 1) {
1375  				while (fabs(LearnRateV[p]*CurGradV[p]) > MxStep) { LearnRateV[p] *= 0.95; }
1376  				while (fabs(LearnRateV[p]*CurGradV[p]) < 5 * MnStep) { LearnRateV[p] *= (1.0/0.95); } 
1377  			} else {
1378  				while (fabs(LearnRateV[p]*CurGradV[p]) > MxStep) { LearnRateV[p] *= 0.95; printf(".");}
1379  				while (fabs(LearnRateV[p]*CurGradV[p]) < MnStep) { LearnRateV[p] *= (1.0/0.95); printf("*");}
1380  				if (MxStep > 3*MnStep) { MxStep *= 0.95; }
1381  			}
1382  			NewProbMtx.At(p) = ProbMtx.At(p) + LearnRateV[p]*CurGradV[p];
1383  			if (NewProbMtx.At(p) > 0.9999) { NewProbMtx.At(p)=0.9999; }
1384  			if (NewProbMtx.At(p) < 0.0001) { NewProbMtx.At(p)=0.0001; }
1385  			LearnRateV[p] *= 0.95;
1386  		}
1387  		printf("  trueE0: %.2f (%u from %u),  estE0: %.2f (%u from %u),  ERR: %f\n", EZero, RealEdges(), RealNodes(), ProbMtx.GetMtxSum(), Graph->GetEdges(), Graph->GetNodes(), fabs(EZero-ProbMtx.GetMtxSum()));
1388  		printf("      currLL: %.4f, deltaLL: %.4f\n", CurLL, CurLL-OldLL); 
1389  		for (int p = 0; p < GetParams(); p++) {
1390  			printf("      %d]  %f  <--  %f + %9f   Grad: %9.1f   Rate: %g\n", p, NewProbMtx.At(p),
1391  			ProbMtx.At(p), (double)(LearnRateV[p]*CurGradV[p]), CurGradV[p](), LearnRateV[p]());
1392  		}
1393  		OldLL=CurLL;
1394  		if(Iter == GradIter - 1) {
1395  			break;
1396  		}
1397  		CurLL = 0;
1398  		CurGradV.PutAll(0.0);
1399  		TFltV OneDLL;
1400  		CalcApxGraphLL();
1401  		CalcApxGraphDLL();
1402  		for(int s = 0; s < NSamples; s++) {
1403  			ProbMtx = OldProbMtx;  ProbMtx.GetLLMtx(LLMtx);
1404  			MetroGibbsSampleNext(10, true);
1405  			ProbMtx = NewProbMtx;  ProbMtx.GetLLMtx(LLMtx);
1406  			if(s % ReCalcLen == ReCalcLen/2) {
1407  				CurLL += CalcApxGraphLL();
1408  				OneDLL = CalcApxGraphDLL();
1409  			} else {
1410  				CurLL += LogLike;
1411  				OneDLL = GradV;
1412  			}
1413  			for(int p = 0; p < GetParams(); p++) {
1414  				CurGradV[p] += OneDLL[p];
1415  			}
1416  		}
1417  		CurLL /= NSamples;
1418  		if(MaxLL < CurLL) {
1419  			MaxLL = CurLL;	MaxProbMtx = ProbMtx;
1420  		}
1421  		printf("    Time: %s\n", IterTm.GetTmStr());
1422  		printf("\n");  fflush(stdout);
1423  	}
1424  	ProbMtx = MaxProbMtx;	ProbMtx.GetLLMtx(LLMtx);
1425  	printf("    FinalLL : %f,   TotalExeTm: %s\n", MaxLL, TotalTm.GetTmStr());
1426  	ProbMtx.Dump("    FITTED PARAMS", false);
1427  	return MaxLL;
1428  }
1429  void TKroneckerLL::RunKronEM(const int& EMIter, const int& GradIter, double LrnRate, double MnStep, double MxStep, const int& GibbsWarmUp, const int& WarmUp, const int& NSamples, const TKronEMType& Type, const int& NMissing) {
1430  	printf("\n----------------------------------------------------------------------\n");
1431  	printf("Fitting graph on %d nodes, %d edges\n", int(RealNodes), int(RealEdges));
1432  	printf("Kron iters:  %d (== %d nodes)\n\n", KronIters(), ProbMtx.GetNodes(KronIters()));
1433  	TFltV LLV(NSamples);
1434  	TVec<TFltV> DLLV(NSamples);
1435  	EMType = Type;
1436  	MissEdges = NMissing;
1437  	AppendIsoNodes();
1438  	SetRndPerm();
1439  	if(DebugMode) {
1440  		LLV.Gen(EMIter, 0);
1441  		MtxV.Gen(EMIter, 0);
1442  	}
1443  	for(int i = 0; i < EMIter; i++) {
1444  		printf("\n----------------------------------------------------------------------\n");
1445  		printf("%03d EM-iter] E-Step\n", i+1);
1446  		RunEStep(GibbsWarmUp, WarmUp, NSamples, LLV, DLLV);
1447  		printf("\n\n");
1448  		printf("%03d EM-iter] M-Step\n", i+1);
1449  		double CurLL = RunMStep(LLV, DLLV, GradIter, LrnRate, MnStep, MxStep);
1450  		printf("\n\n");
1451  		if(DebugMode) {
1452  			LLV.Add(CurLL);
1453  			MtxV.Add(ProbMtx);
1454  		}
1455  	}
1456  	RestoreGraph();
1457  }
1458  void GetMinMax(const TFltPrV& XYValV, double& Min, double& Max, const bool& ResetMinMax) {
1459    if (ResetMinMax) { Min = TFlt::Mx;  Max = TFlt::Mn; }
1460    for (int i = 0; i < XYValV.Len(); i++) {
1461      Min = TMath::Mn(Min, XYValV[i].Val2.Val);
1462      Max = TMath::Mx(Max, XYValV[i].Val2.Val);
1463    }
1464  }
1465  void PlotGrad(const TFltPrV& EstLLV, const TFltPrV& TrueLLV, const TVec<TFltPrV>& GradVV, const TFltPrV& AcceptV, const TStr& OutFNm, const TStr& Desc) {
1466    double Min, Max, Min1, Max1;
1467    { TGnuPlot GP("sLL-"+OutFNm, TStr::Fmt("Log-likelihood (avg 1k samples). %s", Desc.CStr()), true);
1468    GP.AddPlot(EstLLV, gpwLines, "Esimated LL", "linewidth 1");
1469    if (! TrueLLV.Empty()) { GP.AddPlot(TrueLLV, gpwLines, "TRUE LL", "linewidth 1"); }
1470    GP.SetXYLabel("Sample Index (time)", "Log-likelihood");
1471    GP.SavePng(); }
1472    { TGnuPlot GP("sAcc-"+OutFNm, TStr::Fmt("Pct. accepted rnd moves (over 1k samples). %s", Desc.CStr()), true);
1473    GP.AddPlot(AcceptV, gpwLines, "Pct accepted swaps", "linewidth 1");
1474    GP.SetXYLabel("Sample Index (time)", "Pct accept permutation swaps");
1475    GP.SavePng(); }
1476    TGnuPlot GPAll("sGradAll-"+OutFNm, TStr::Fmt("Gradient (avg 1k samples). %s", Desc.CStr()), true);
1477    GetMinMax(GradVV[0], Min1, Max1, true);
1478    for (int g = 0; g < GradVV.Len(); g++) {
1479      GPAll.AddPlot(GradVV[g], gpwLines, TStr::Fmt("param %d", g+1), "linewidth 1");
1480      GetMinMax(GradVV[g], Min1, Max1, false);
1481      TGnuPlot GP(TStr::Fmt("sGrad%02d-", g+1)+OutFNm, TStr::Fmt("Gradient (avg 1k samples). %s", Desc.CStr()), true);
1482      GP.AddPlot(GradVV[g], gpwLines, TStr::Fmt("param id %d", g+1), "linewidth 1");
1483      GetMinMax(GradVV[g], Min, Max, true);
1484      GP.SetYRange((int)floor(Min-1), (int)ceil(Max+1));
1485      GP.SetXYLabel("Sample Index (time)", "Gradient");
1486      GP.SavePng();
1487    }
1488    GPAll.SetYRange((int)floor(Min1-1), (int)ceil(Max1+1));
1489    GPAll.SetXYLabel("Sample Index (time)", "Gradient");
1490    GPAll.SavePng();
1491  }
1492  void PlotAutoCorrelation(const TFltV& ValV, const int& MaxK, const TStr& OutFNm, const TStr& Desc) {
1493    double Avg=0.0, Var=0.0;
1494    for (int i = 0; i < ValV.Len(); i++) { Avg += ValV[i]; }
1495    Avg /= (double) ValV.Len();
1496    for (int i = 0; i < ValV.Len(); i++) { Var += TMath::Sqr(ValV[i]-Avg); }
1497    TFltPrV ACorrV;
1498    for (int k = 0; k < TMath::Mn(ValV.Len(), MaxK); k++) {
1499      double corr = 0.0;
1500      for (int i = 0; i < ValV.Len() - k; i++) {
1501        corr += (ValV[i]-Avg)*(ValV[i+k]-Avg);
1502      }
1503      ACorrV.Add(TFltPr(k, corr/Var));
1504    }
1505    TGnuPlot GP("sAutoCorr-"+OutFNm, TStr::Fmt("AutoCorrelation (%d samples). %s", ValV.Len(), Desc.CStr()), true);
1506    GP.AddPlot(ACorrV, gpwLines, "", "linewidth 1");
1507    GP.SetXYLabel("Lag, k", "Autocorrelation, r_k");
1508    GP.SavePng();
1509  }
1510  TFltV TKroneckerLL::TestSamplePerm(const TStr& OutFNm, const int& WarmUp, const int& NSamples, const TKronMtx& TrueMtx, const bool& DoPlot) {
1511    printf("Sample permutations: %s (warm-up: %s)\n", TInt::GetMegaStr(NSamples).CStr(), TInt::GetMegaStr(WarmUp).CStr());
1512    int NId1=0, NId2=0, NAccept=0;
1513    TExeTm ExeTm;
1514    const int PlotLen = NSamples/1000+1;
1515    double TrueLL=-1, AvgLL=0.0;
1516    TFltV AvgGradV(GetParams());
1517    TFltPrV TrueLLV(PlotLen, 0); 
1518    TFltPrV EstLLV(PlotLen, 0);  
1519    TFltPrV AcceptV;             
1520    TFltV SampleLLV(NSamples, 0);
1521    TVec<TFltPrV> GradVV(GetParams());
1522    for (int g = 0; g < GetParams(); g++) {
1523      GradVV[g].Gen(PlotLen, 0); }
1524    if (! TrueMtx.Empty()) {
1525      TIntV PermV=NodePerm;  TKronMtx CurMtx=ProbMtx;  ProbMtx.Dump();
1526      InitLL(TrueMtx);  SetOrderPerm();  CalcApxGraphLL();  printf("TrueLL: %f\n", LogLike());
1527      TrueLL=LogLike;  InitLL(CurMtx); NodePerm=PermV;
1528    }
1529    CalcApxGraphLL();
1530    printf("LogLike at start:       %f\n", LogLike());
1531    if (WarmUp > 0) {
1532      EstLLV.Add(TFltPr(0, LogLike));
1533      if (TrueLL != -1) { TrueLLV.Add(TFltPr(0, TrueLL)); }
1534      for (int s = 0; s < WarmUp; s++) { SampleNextPerm(NId1, NId2); }
1535      printf("  warm-up:%s,", ExeTm.GetTmStr());  ExeTm.Tick();
1536    }
1537    printf("LogLike afterm warm-up: %f\n", LogLike());
1538    CalcApxGraphLL(); 
1539    CalcApxGraphDLL();
1540    EstLLV.Add(TFltPr(WarmUp, LogLike));
1541    if (TrueLL != -1) { TrueLLV.Add(TFltPr(WarmUp, TrueLL)); }
1542    printf("  recalculated:         %f\n", LogLike());
1543    printf("  sampling (average per 1000 samples)\n");
1544    TVec<TFltV> SamplVV(5);
1545    for (int s = 0; s < NSamples; s++) {
1546      if (SampleNextPerm(NId1, NId2)) { 
1547        UpdateGraphDLL(NId1, NId2);  NAccept++; }
1548      for (int m = 0; m < AvgGradV.Len(); m++) { AvgGradV[m] += GradV[m]; }
1549      AvgLL += GetLL();
1550      SampleLLV.Add(GetLL());
1551      if (s > 0 && s % 1000 == 0) {
1552        printf(".");
1553        for (int g = 0; g < AvgGradV.Len(); g++) {
1554          GradVV[g].Add(TFltPr(WarmUp+s, AvgGradV[g] / 1000.0)); }
1555        EstLLV.Add(TFltPr(WarmUp+s, AvgLL / 1000.0));
1556        if (TrueLL != -1) { TrueLLV.Add(TFltPr(WarmUp+s, TrueLL)); }
1557        AcceptV.Add(TFltPr(WarmUp+s, NAccept/1000.0));
1558        if (s % 100000 == 0 && DoPlot) {
1559          const TStr Desc = TStr::Fmt("P(NodeSwap)=%g. Nodes: %d, Edges: %d, Params: %d, WarmUp: %s, Samples: %s", PermSwapNodeProb(),
1560            Graph->GetNodes(), Graph->GetEdges(), GetParams(), TInt::GetMegaStr(WarmUp).CStr(), TInt::GetMegaStr(NSamples).CStr());
1561          PlotGrad(EstLLV, TrueLLV, GradVV, AcceptV, OutFNm, Desc);
1562          for (int n = 0; n < SamplVV.Len(); n++) {
1563            PlotAutoCorrelation(SamplVV[n], 1000, TStr::Fmt("%s-n%d", OutFNm.CStr(), n), Desc); }
1564          printf("  samples: %d, time: %s, samples/s: %.1f\n", s, ExeTm.GetTmStr(), double(s+1)/ExeTm.GetSecs());
1565        }
1566        AvgLL = 0;  AvgGradV.PutAll(0);  NAccept=0;
1567      }
1568    }
1569    if (DoPlot) {
1570      const TStr Desc = TStr::Fmt("P(NodeSwap)=%g. Nodes: %d, Edges: %d, Params: %d, WarmUp: %s, Samples: %s", PermSwapNodeProb(),
1571        Graph->GetNodes(), Graph->GetEdges(), GetParams(), TInt::GetMegaStr(WarmUp).CStr(), TInt::GetMegaStr(NSamples).CStr());
1572      PlotGrad(EstLLV, TrueLLV, GradVV, AcceptV, OutFNm, Desc);
1573      for (int n = 0; n < SamplVV.Len(); n++) {
1574        PlotAutoCorrelation(SamplVV[n], 1000, TStr::Fmt("%s-n%d", OutFNm.CStr(), n), Desc); }
1575    }
1576    return SampleLLV; 
1577  }
1578  void McMcGetAvgAvg(const TFltV& AvgJV, double& AvgAvg) {
1579    AvgAvg = 0.0;
1580    for (int j = 0; j < AvgJV.Len(); j++) {
1581      AvgAvg += AvgJV[j]; }
1582    AvgAvg /= AvgJV.Len();
1583  }
1584  void McMcGetAvgJ(const TVec<TFltV>& ChainLLV, TFltV& AvgJV) {
1585    for (int j = 0; j < ChainLLV.Len(); j++) {
1586      const TFltV& ChainV = ChainLLV[j];
1587      double Avg = 0;
1588      for (int i = 0; i < ChainV.Len(); i++) {
1589        Avg += ChainV[i];
1590      }
1591      AvgJV.Add(Avg/ChainV.Len());
1592    }
1593  }
1594  double TKroneckerLL::CalcChainR2(const TVec<TFltV>& ChainLLV) {
1595    const double J = ChainLLV.Len();
1596    const double K = ChainLLV[0].Len();
1597    TFltV AvgJV;    McMcGetAvgJ(ChainLLV, AvgJV);
1598    double AvgAvg;  McMcGetAvgAvg(AvgJV, AvgAvg);
1599    IAssert(AvgJV.Len() == ChainLLV.Len());
1600    double InChainVar=0, OutChainVar=0;
1601    for (int j = 0; j < AvgJV.Len(); j++) {
1602      OutChainVar += TMath::Sqr(AvgJV[j] - AvgAvg); }
1603    OutChainVar = OutChainVar * (K/double(J-1));
1604    printf("*** %g chains of len %g\n", J, K);
1605    printf("  ** between chain var: %f\n", OutChainVar);
1606    for (int j = 0; j < AvgJV.Len(); j++) {
1607      const TFltV& ChainV = ChainLLV[j];
1608      for (int k = 0; k < ChainV.Len(); k++) {
1609        InChainVar += TMath::Sqr(ChainV[k] - AvgJV[j]); }
1610    }
1611    InChainVar = InChainVar * 1.0/double(J*(K-1));
1612    printf("  ** within chain var: %f\n", InChainVar);
1613    const double PostVar = (K-1)/K * InChainVar + 1.0/K * OutChainVar;
1614    printf("  ** posterior var: %f\n", PostVar);
1615    const double ScaleRed = sqrt(PostVar/InChainVar);
1616    printf("  ** scale reduction (< 1.2): %f\n\n", ScaleRed);
1617    return ScaleRed;
1618  }
1619  void TKroneckerLL::ChainGelmapRubinPlot(const TVec<TFltV>& ChainLLV, const TStr& OutFNm, const TStr& Desc) {
1620    TFltPrV LenR2V; 
1621    TVec<TFltV> SmallLLV(ChainLLV.Len());
1622    const int K = ChainLLV[0].Len();
1623    const int Buckets=1000;
1624    const int BucketSz = K/Buckets;
1625    for (int b = 1; b < Buckets; b++) {
1626      const int End = TMath::Mn(BucketSz*b, K-1);
1627      for (int c = 0; c < ChainLLV.Len(); c++) {
1628        ChainLLV[c].GetSubValV(0, End, SmallLLV[c]); }
1629      LenR2V.Add(TFltPr(End, TKroneckerLL::CalcChainR2(SmallLLV)));
1630    }
1631    LenR2V.Add(TFltPr(K, TKroneckerLL::CalcChainR2(ChainLLV)));
1632    TGnuPlot::PlotValV(LenR2V, TStr::Fmt("gelman-%s", OutFNm.CStr()), TStr::Fmt("%s. %d chains of len %d. BucketSz: %d.",
1633      Desc.CStr(), ChainLLV.Len(), ChainLLV[0].Len(), BucketSz), "Chain length", "Potential scale reduction");
1634  }
1635  TFltQu TKroneckerLL::TestKronDescent(const bool& DoExact, const bool& TruePerm, double LearnRate, const int& WarmUp, const int& NSamples, const TKronMtx& TrueParam) {
1636    printf("Test gradient descent on a synthetic kronecker graphs:\n");
1637    if (DoExact) { printf("  -- Exact gradient calculations\n"); }
1638    else { printf("  -- Approximate gradient calculations\n"); }
1639    if (TruePerm) { printf("  -- No permutation sampling (use true permutation)\n"); }
1640    else { printf("  -- Sample permutations (start with degree permutation)\n"); }
1641    TExeTm IterTm;
1642    int Iter;
1643    double OldLL=0, MyLL=0, AvgAbsErr, AbsSumErr;
1644    TFltV MyGradV, SDevV;
1645    TFltV LearnRateV(GetParams());  LearnRateV.PutAll(LearnRate);
1646    if (TruePerm) {
1647      SetOrderPerm();
1648    }
1649    else {
1650      printf("DEGREE  PERMUTATION\n");  SetDegPerm();
1651    }
1652    for (Iter = 0; Iter < 100; Iter++) {
1653      if (TruePerm) {
1654        if (DoExact) { CalcGraphDLL();  CalcGraphLL(); } 
1655        else { CalcApxGraphDLL();  CalcApxGraphLL(); }   
1656        MyLL = LogLike;  MyGradV = GradV;
1657      } else {
1658        printf(".");
1659        SampleGradient(WarmUp, NSamples, MyLL, MyGradV);
1660      }
1661      printf("%d] LL: %g, ", Iter, MyLL);
1662      AvgAbsErr = TKronMtx::GetAvgAbsErr(ProbMtx, TrueParam);
1663      AbsSumErr = fabs(ProbMtx.GetMtxSum() - TrueParam.GetMtxSum());
1664      printf("  avgAbsErr: %.4f, absSumErr: %.4f, newLL: %.2f, deltaLL: %.2f\n", AvgAbsErr, AbsSumErr, MyLL, OldLL-MyLL);
1665      for (int p = 0; p < GetParams(); p++) {
1666        LearnRateV[p] *= 0.9;
1667        while (fabs(LearnRateV[p]*MyGradV[p]) > 0.1) { LearnRateV[p] *= 0.9; }
1668        while (fabs(LearnRateV[p]*MyGradV[p]) < 0.001) { LearnRateV[p] *= (1.0/0.9); }
1669        printf("    %d]  %f  <--  %f + %f    lrnRate:%g\n", p, ProbMtx.At(p) + LearnRateV[p]*MyGradV[p],
1670          ProbMtx.At(p), (double)(LearnRateV[p]*MyGradV[p]), LearnRateV[p]());
1671        ProbMtx.At(p) = ProbMtx.At(p) + LearnRateV[p]*MyGradV[p];
1672        if (ProbMtx.At(p) > 0.99) { ProbMtx.At(p)=0.99; }
1673        if (ProbMtx.At(p) < 0.01) { ProbMtx.At(p)=0.01; }
1674      }
1675      ProbMtx.GetLLMtx(LLMtx);  OldLL = MyLL;
1676      if (AvgAbsErr < 0.01) { printf("***CONVERGED!\n");  break; }
1677      printf("\n");  fflush(stdout);
1678    }
1679    TrueParam.Dump("True  Thetas", true);
1680    ProbMtx.Dump("Final Thetas", true);
1681    printf("  AvgAbsErr: %f\n  AbsSumErr: %f\n  Iterations: %d\n", AvgAbsErr, AbsSumErr, Iter);
1682    printf("Iteration run time: %s, sec: %g\n\n", IterTm.GetTmStr(), IterTm.GetSecs());
1683    return TFltQu(AvgAbsErr, AbsSumErr, Iter, IterTm.GetSecs());
1684  }
1685  void PlotTrueAndEst(const TStr& OutFNm, const TStr& Desc, const TStr& YLabel, const TFltPrV& EstV, const TFltPrV& TrueV) {
1686    TGnuPlot GP(OutFNm, Desc.CStr(), true);
1687    GP.AddPlot(EstV, gpwLinesPoints, YLabel, "linewidth 1 pointtype 6 pointsize 1");
1688    if (! TrueV.Empty()) { GP.AddPlot(TrueV, gpwLines, "TRUE"); }
1689    GP.SetXYLabel("Gradient descent iterations", YLabel);
1690    GP.SavePng();
1691  }
1692  void TKroneckerLL::GradDescentConvergence(const TStr& OutFNm, const TStr& Desc1, const bool& SamplePerm, const int& NIters,
1693   double LearnRate, const int& WarmUp, const int& NSamples, const int& AvgKGraphs, const TKronMtx& TrueParam) {
1694    TExeTm IterTm;
1695    int Iter;
1696    double OldLL=0, MyLL=0, AvgAbsErr=0, AbsSumErr=0;
1697    TFltV MyGradV, SDevV;
1698    TFltV LearnRateV(GetParams());  LearnRateV.PutAll(LearnRate);
1699    TFltPrV EZeroV, DiamV, Lambda1V, Lambda2V, AvgAbsErrV, AvgLLV;
1700    TFltPrV TrueEZeroV, TrueDiamV, TrueLambda1V, TrueLambda2V, TrueLLV;
1701    TFltV SngValV;  TSnap::GetSngVals(Graph, 2, SngValV);  SngValV.Sort(false);
1702    const double TrueEZero = pow((double) Graph->GetEdges(), 1.0/double(KronIters));
1703    const double TrueEffDiam = TSnap::GetAnfEffDiam(Graph, false, 10);
1704    const double TrueLambda1 = SngValV[0];
1705    const double TrueLambda2 = SngValV[1];
1706    if (! TrueParam.Empty()) {
1707      const TKronMtx CurParam = ProbMtx;  ProbMtx.Dump();
1708      InitLL(TrueParam);  SetOrderPerm();  CalcApxGraphLL(); printf("TrueLL: %f\n", LogLike());
1709      OldLL = LogLike;  InitLL(CurParam);
1710    }
1711    const double TrueLL = OldLL;
1712    if (! SamplePerm) { SetOrderPerm(); } else { SetDegPerm(); }
1713    for (Iter = 0; Iter < NIters; Iter++) {
1714      if (! SamplePerm) {
1715        CalcApxGraphDLL();  CalcApxGraphLL();   
1716        MyLL = LogLike;  MyGradV = GradV;
1717      } else {
1718        SampleGradient(WarmUp, NSamples, MyLL, MyGradV);
1719      }
1720      double SumDiam=0, SumSngVal1=0, SumSngVal2=0;
1721      for (int trial = 0; trial < AvgKGraphs; trial++) {
1722        PNGraph KronGraph = TKronMtx::GenFastKronecker(ProbMtx, KronIters, true, 0); 
1723        SngValV.Clr(true);  TSnap::GetSngVals(KronGraph, 2, SngValV);  SngValV.Sort(false);
1724        SumDiam += TSnap::GetAnfEffDiam(KronGraph, false, 10);
1725        SumSngVal1 += SngValV[0];  SumSngVal2 += SngValV[1];
1726      }
1727      AvgLLV.Add(TFltPr(Iter, MyLL));
1728      EZeroV.Add(TFltPr(Iter, ProbMtx.GetMtxSum()));
1729      DiamV.Add(TFltPr(Iter, SumDiam/double(AvgKGraphs)));
1730      Lambda1V.Add(TFltPr(Iter, SumSngVal1/double(AvgKGraphs)));
1731      Lambda2V.Add(TFltPr(Iter, SumSngVal2/double(AvgKGraphs)));
1732      TrueLLV.Add(TFltPr(Iter, TrueLL));
1733      TrueEZeroV.Add(TFltPr(Iter, TrueEZero));
1734      TrueDiamV.Add(TFltPr(Iter, TrueEffDiam));
1735      TrueLambda1V.Add(TFltPr(Iter, TrueLambda1));
1736      TrueLambda2V.Add(TFltPr(Iter, TrueLambda2));
1737      if (Iter % 10 == 0) {
1738        const TStr Desc = TStr::Fmt("%s. Iter: %d, G(%d, %d)  K(%d, %d)", Desc1.Empty()?OutFNm.CStr():Desc1.CStr(),
1739          Iter, Graph->GetNodes(), Graph->GetEdges(), ProbMtx.GetNodes(KronIters), ProbMtx.GetEdges(KronIters));
1740        PlotTrueAndEst("LL."+OutFNm, Desc, "Average LL", AvgLLV, TrueLLV);
1741        PlotTrueAndEst("E0."+OutFNm, Desc, "E0 (expected number of edges)", EZeroV, TrueEZeroV);
1742        PlotTrueAndEst("Diam."+OutFNm+"-Diam", Desc, "Effective diameter", DiamV, TrueDiamV);
1743        PlotTrueAndEst("Lambda1."+OutFNm, Desc, "Lambda 1", Lambda1V, TrueLambda1V);
1744        PlotTrueAndEst("Lambda2."+OutFNm, Desc, "Lambda 2", Lambda2V, TrueLambda2V);
1745        if (! TrueParam.Empty()) {
1746          PlotTrueAndEst("AbsErr."+OutFNm, Desc, "Average Absolute Error", AvgAbsErrV, TFltPrV()); }
1747      }
1748      if (! TrueParam.Empty()) {
1749        AvgAbsErr = TKronMtx::GetAvgAbsErr(ProbMtx, TrueParam);
1750        AvgAbsErrV.Add(TFltPr(Iter, AvgAbsErr));
1751      } else { AvgAbsErr = 1.0; }
1752      AbsSumErr = fabs(ProbMtx.GetMtxSum() - TrueEZero);
1753      for (int p = 0; p < GetParams(); p++) {
1754        LearnRateV[p] *= 0.99;
1755        while (fabs(LearnRateV[p]*MyGradV[p]) > 0.1) { LearnRateV[p] *= 0.99; printf(".");}
1756        while (fabs(LearnRateV[p]*MyGradV[p]) < 0.002) { LearnRateV[p] *= (1.0/0.95); printf("*");}
1757        printf("    %d]  %f  <--  %f + %9f   Grad: %9.1f,  Rate:%g\n", p, ProbMtx.At(p) + LearnRateV[p]*MyGradV[p],
1758          ProbMtx.At(p), (double)(LearnRateV[p]*MyGradV[p]), MyGradV[p](), LearnRateV[p]());
1759        ProbMtx.At(p) = ProbMtx.At(p) + LearnRateV[p]*MyGradV[p];
1760        if (ProbMtx.At(p) > 1.0) { ProbMtx.At(p)=1.0; }
1761        if (ProbMtx.At(p) < 0.001) { ProbMtx.At(p)=0.001; }
1762      }
1763      printf("%d] LL: %g, ", Iter, MyLL);
1764      printf("  avgAbsErr: %.4f, absSumErr: %.4f, newLL: %.2f, deltaLL: %.2f\n", AvgAbsErr, AbsSumErr, MyLL, OldLL-MyLL);
1765      if (AvgAbsErr < 0.001) { printf("***CONVERGED!\n");  break; }
1766      printf("\n");  fflush(stdout);
1767      ProbMtx.GetLLMtx(LLMtx);  OldLL = MyLL;
1768    }
1769    TrueParam.Dump("True  Thetas", true);
1770    ProbMtx.Dump("Final Thetas", true);
1771    printf("  AvgAbsErr: %f\n  AbsSumErr: %f\n  Iterations: %d\n", AvgAbsErr, AbsSumErr, Iter);
1772    printf("Iteration run time: %s, sec: %g\n\n", IterTm.GetTmStr(), IterTm.GetSecs());
1773  }
1774  void TKroneckerLL::TestBicCriterion(const TStr& OutFNm, const TStr& Desc1, const PNGraph& G, const int& GradIters,
1775   double LearnRate, const int& WarmUp, const int& NSamples, const int& TrueN0) {
1776    TFltPrV BicV, MdlV, LLV;
1777    const double rndGP = G->GetEdges()/TMath::Sqr(double(G->GetNodes()));
1778    const double RndGLL = G->GetEdges()*log(rndGP )+ (TMath::Sqr(double(G->GetNodes()))-G->GetEdges())*log(1-rndGP);
1779    LLV.Add(TFltPr(1, RndGLL));
1780    BicV.Add(TFltPr(1, -RndGLL + 0.5*TMath::Sqr(1)*log(TMath::Sqr(G->GetNodes()))));
1781    MdlV.Add(TFltPr(1, -RndGLL + 32*TMath::Sqr(1)+2*(log((double)1)+log((double)G->GetNodes()))));
1782    for (int NZero = 2; NZero < 10; NZero++) {
1783      const TKronMtx InitKronMtx = TKronMtx::GetInitMtx(NZero, G->GetNodes(), G->GetEdges());
1784      InitKronMtx.Dump("INIT PARAM", true);
1785      TKroneckerLL KronLL(G, InitKronMtx);
1786      KronLL.SetPerm('d'); 
1787      const double LastLL = KronLL.GradDescent(GradIters, LearnRate, 0.001, 0.01, WarmUp, NSamples);
1788      LLV.Add(TFltPr(NZero, LastLL));
1789      BicV.Add(TFltPr(NZero, -LastLL + 0.5*TMath::Sqr(NZero)*log(TMath::Sqr(G->GetNodes()))));
1790      MdlV.Add(TFltPr(NZero, -LastLL + 32*TMath::Sqr(NZero)+2*(log((double)NZero)+log((double)KronLL.GetKronIters()))));
1791      { TGnuPlot GP("LL-"+OutFNm, Desc1);
1792      GP.AddPlot(LLV, gpwLinesPoints, "Log-likelihood", "linewidth 1 pointtype 6 pointsize 2");
1793      GP.SetXYLabel("NZero", "Log-Likelihood");  GP.SavePng(); }
1794      { TGnuPlot GP("BIC-"+OutFNm, Desc1);
1795      GP.AddPlot(BicV, gpwLinesPoints, "BIC", "linewidth 1 pointtype 6 pointsize 2");
1796      GP.SetXYLabel("NZero", "BIC");  GP.SavePng(); }
1797      { TGnuPlot GP("MDL-"+OutFNm, Desc1);
1798      GP.AddPlot(MdlV, gpwLinesPoints, "MDL", "linewidth 1 pointtype 6 pointsize 2");
1799      GP.SetXYLabel("NZero", "MDL");  GP.SavePng(); }
1800    }
1801  }
1802  void TKroneckerLL::TestGradDescent(const int& KronIters, const int& KiloSamples, const TStr& Permutation) {
1803    const TStr OutFNm = TStr::Fmt("grad-%s%d-%dk", Permutation.CStr(), KronIters, KiloSamples);
1804    TKronMtx KronParam = TKronMtx::GetMtx("0.8 0.6; 0.6 0.4");
1805    PNGraph Graph  = TKronMtx::GenFastKronecker(KronParam, KronIters, true, 0);
1806    TKroneckerLL KronLL(Graph, KronParam);
1807    TVec<TFltV> GradVV(4), SDevVV(4);  TFltV XValV;
1808    int NId1 = 0, NId2 = 0, NAccept = 0;
1809    TVec<TMom> GradMomV(4);
1810    TExeTm ExeTm;
1811    if (Permutation == "r") KronLL.SetRndPerm();
1812    else if (Permutation == "d") KronLL.SetDegPerm();
1813    else if (Permutation == "o") KronLL.SetOrderPerm();
1814    else FailR("Unknown permutation (r,d,o)");
1815    KronLL.CalcApxGraphLL();
1816    KronLL.CalcApxGraphDLL();
1817    for (int s = 0; s < 1000*KiloSamples; s++) {
1818      if (KronLL.SampleNextPerm(NId1, NId2)) { 
1819        KronLL.UpdateGraphDLL(NId1, NId2);  NAccept++; }
1820      if (s > 50000) { 
1821        for (int m = 0; m < 4; m++) { GradVV[m].Add(KronLL.GradV[m]); }
1822        if ((s+1) % 1000 == 0) {
1823          printf(".");
1824          for (int m = 0; m < 4; m++) { GradVV[m].Add(KronLL.GradV[m]); }
1825          XValV.Add((s+1));
1826          if ((s+1) % 100000 == 0) {
1827            TGnuPlot GP(OutFNm, TStr::Fmt("Gradient vs. samples. %d nodes, %d edges", Graph->GetNodes(), Graph->GetEdges()), true);
1828            for (int g = 0; g < GradVV.Len(); g++) {
1829              GP.AddPlot(XValV, GradVV[g], gpwLines, TStr::Fmt("grad %d", g)); }
1830            GP.SetXYLabel("sample index","log Gradient");
1831            GP.SavePng();
1832          }
1833        }
1834      }
1835    }
1836    printf("\n");
1837    for (int m = 0; m < 4; m++) {
1838      GradMomV[m].Def();
1839      printf("grad %d: mean: %12f  sDev: %12f  median: %12f\n", m,
1840        GradMomV[m].GetMean(), GradMomV[m].GetSDev(), GradMomV[m].GetMedian());
1841    }
1842  }
1843  int TKronNoise::RemoveNodeNoise(PNGraph& Graph, const int& NNodes, const bool Random) {
1844  	IAssert(NNodes > 0 && NNodes < (Graph->GetNodes() / 2));
1845  	int i = 0;
1846  	TIntV ShufflePerm;
1847  	Graph->GetNIdV(ShufflePerm);
1848  	if(Random) {
1849  		ShufflePerm.Shuffle(TKronMtx::Rnd);
1850  		for(i = 0; i < NNodes; i++) {
1851  			Graph->DelNode(int(ShufflePerm[i]));
1852  		}
1853  	} else {
1854  		for(i = 0; i < NNodes; i++) {
1855  			Graph->DelNode(int(ShufflePerm[ShufflePerm.Len() - 1 - i]));
1856  		}
1857  	}
1858  	return Graph->GetNodes();
1859  }
1860  int TKronNoise::RemoveNodeNoise(PNGraph& Graph, const double& Rate, const bool Random) {
1861  	IAssert(Rate > 0 && Rate < 0.5);
1862  	return TKronNoise::RemoveNodeNoise(Graph, (int) floor(Rate * double(Graph->GetNodes())), Random);
1863  }
1864  int TKronNoise::FlipEdgeNoise(PNGraph& Graph, const int& NEdges, const bool Random) {
1865  	IAssert(NEdges > 0 && NEdges < Graph->GetEdges());
1866  	const int Nodes = Graph->GetNodes();
1867  	const int Edges = Graph->GetEdges();
1868  	int Src, Dst;
1869  	TIntV NIdV, TempV;
1870  	TIntPrV ToAdd, ToDel;
1871  	Graph->GetNIdV(NIdV);
1872  	ToAdd.Gen(NEdges / 2, 0);
1873  	for(int i = 0; i < NEdges / 2; i++) {
1874  		Src = NIdV[TKronMtx::Rnd.GetUniDevInt(Nodes)];
1875  		Dst = NIdV[TKronMtx::Rnd.GetUniDevInt(Nodes)];
1876  		if(Graph->IsEdge(Src, Dst)) {	i--;	continue;	}
1877  		ToAdd.Add(TIntPr(Src, Dst));
1878  	}
1879  	ToDel.Gen(Edges, 0);
1880  	for(TNGraph::TEdgeI EI = Graph->BegEI(); EI < Graph->EndEI(); EI++) {
1881  		ToDel.Add(TIntPr(EI.GetSrcNId(), EI.GetDstNId()));
1882  	}
1883  	ToDel.Shuffle(TKronMtx::Rnd);
1884  	for(int i = 0; i < NEdges / 2; i++) {
1885  		Graph->DelEdge(ToDel[i].Val1, ToDel[i].Val2);
1886  		Graph->AddEdge(ToAdd[i].Val1, ToAdd[i].Val2);
1887  	}
1888  	return Graph->GetEdges();
1889  }
1890  int TKronNoise::FlipEdgeNoise(PNGraph& Graph, const double& Rate, const bool Random) {
1891  	IAssert(Rate > 0 && Rate < 0.5);
1892  	return TKronNoise::FlipEdgeNoise(Graph, (int) floor(Rate * double(Graph->GetEdges())), Random);
1893  }
1894  int TKronNoise::RemoveEdgeNoise(PNGraph& Graph, const int& NEdges) {
1895  	IAssert(NEdges > 0 && NEdges < Graph->GetEdges());
1896  	TIntPrV ToDel;
1897  	ToDel.Gen(Graph->GetEdges(), 0);
1898  	for(TNGraph::TEdgeI EI = Graph->BegEI(); EI < Graph->EndEI(); EI++) {
1899  		if(EI.GetSrcNId() != EI.GetDstNId()) {
1900  			ToDel.Add(TIntPr(EI.GetSrcNId(), EI.GetDstNId()));
1901  		}
1902  	}
1903  	ToDel.Shuffle(TKronMtx::Rnd);
1904  	for(int i = 0; i < NEdges; i++) {
1905  		Graph->DelEdge(ToDel[i].Val1, ToDel[i].Val2);
1906  	}
1907  	return Graph->GetEdges();
1908  }
1909  int TKronNoise::RemoveEdgeNoise(PNGraph& Graph, const double& Rate) {
1910  	IAssert(Rate > 0 && Rate < 0.5);
1911  	return TKronNoise::RemoveEdgeNoise(Graph, (int) floor(Rate * double(Graph->GetEdges())));
1912  }
1913  void TKronMaxLL::SetPerm(const char& PermId) {
1914    if (PermId == 'o') KronLL.SetOrderPerm();
1915    else if (PermId == 'd') KronLL.SetDegPerm();
1916    else if (PermId == 'r') KronLL.SetRndPerm();
1917    else FailR("Unknown permutation type (o,d,r)");
1918  }
1919  void TKronMaxLL::RoundTheta(const TFltV& ThetaV, TFltV& NewThetaV) {
1920    NewThetaV.Gen(ThetaV.Len());
1921    for (int i = 0; i < ThetaV.Len(); i++) {
1922      NewThetaV[i] = TMath::Round(ThetaV[i], 3); }
1923  }
1924  void TKronMaxLL::RoundTheta(const TFltV& ThetaV, TKronMtx& Kronecker) {
1925    Kronecker.GenMtx((int)sqrt((double)ThetaV.Len()));
1926    for (int i = 0; i < ThetaV.Len(); i++) {
1927      Kronecker.At(i) = TMath::Round(ThetaV[i], 3); }
1928  }
1929  void TKronMaxLL::Test() {
1930    TKronMtx::PutRndSeed(1);
1931    TKronMtx KronParam = TKronMtx::GetMtx("0.8 0.7; 0.6 0.5");
1932    PNGraph Graph  = TKronMtx::GenFastKronecker(KronParam, 8, true, 1);
1933    TKronMaxLL KronMaxLL(Graph, TFltV::GetV(0.9, 0.7, 0.5, 0.3));
1934    KronMaxLL.SetPerm('d');
1935  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-agmattr.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-kronecker.cpp</div>
                </div>
                <div class="column column_space"><pre><code>44      TUNGraph::TNodeI NI = G->GetNI(UID);
45      fflush(stdout);
46      for (int e = 0; e < NI.GetDeg(); e++) {
47        AddCom(NI.GetNbrNId(e), CurCID, 1.0);
48      }
49      for (int e = 0; e < NI.GetDeg(); e++) {
</pre></code></div>
                <div class="column column_space"><pre><code>395    int edges = 0;
396    for (int node1 = 0; node1 < NNodes; node1++) { Graph->AddNode(node1); }
397    for (int node1 = 0; node1 < NNodes; node1++) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    