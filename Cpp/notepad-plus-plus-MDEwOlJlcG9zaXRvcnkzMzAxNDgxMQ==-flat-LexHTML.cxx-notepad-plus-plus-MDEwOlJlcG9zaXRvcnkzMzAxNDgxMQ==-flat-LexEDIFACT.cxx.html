
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 25, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexHTML.cxx</h3>
            <pre><code>1  #include <stdlib.h>
2  #include <string.h>
3  #include <stdio.h>
4  #include <stdarg.h>
5  #include <assert.h>
6  #include <ctype.h>
7  #include <string>
8  #include <string_view>
9  #include <map>
10  #include <set>
11  #include <functional>
12  #include "ILexer.h"
13  #include "Scintilla.h"
14  #include "SciLexer.h"
15  #include "WordList.h"
16  #include "LexAccessor.h"
17  #include "Accessor.h"
18  #include "StyleContext.h"
19  #include "CharacterSet.h"
20  #include "LexerModule.h"
21  #include "OptionSet.h"
22  #include "DefaultLexer.h"
23  using namespace Scintilla;
24  using namespace Lexilla;
25  namespace {
26  #define SCE_HA_JS (SCE_HJA_START - SCE_HJ_START)
27  #define SCE_HA_VBS (SCE_HBA_START - SCE_HB_START)
28  #define SCE_HA_PYTHON (SCE_HPA_START - SCE_HP_START)
29  enum script_type { eScriptNone = 0, eScriptJS, eScriptVBS, eScriptPython, eScriptPHP, eScriptXML, eScriptSGML, eScriptSGMLblock, eScriptComment };
30  enum script_mode { eHtml = 0, eNonHtmlScript, eNonHtmlPreProc, eNonHtmlScriptPreProc };
31  inline bool IsAWordChar(const int ch) {
32  	return (ch < 0x80) && (isalnum(ch) || ch == '.' || ch == '_');
33  }
34  inline bool IsAWordStart(const int ch) {
35  	return (ch < 0x80) && (isalnum(ch) || ch == '_');
36  }
37  inline bool IsOperator(int ch) {
38  	if (IsASCII(ch) && isalnum(ch))
39  		return false;
40  	if (ch == '%' || ch == '^' || ch == '&' || ch == '*' ||
41  	        ch == '(' || ch == ')' || ch == '-' || ch == '+' ||
42  	        ch == '=' || ch == '|' || ch == '{' || ch == '}' ||
43  	        ch == '[' || ch == ']' || ch == ':' || ch == ';' ||
44  	        ch == '<' || ch == '>' || ch == ',' || ch == '/' ||
45  	        ch == '?' || ch == '!' || ch == '.' || ch == '~')
46  		return true;
47  	return false;
48  }
49  void GetTextSegment(Accessor &styler, Sci_PositionU start, Sci_PositionU end, char *s, size_t len) {
50  	Sci_PositionU i = 0;
51  	for (; (i < end - start + 1) && (i < len-1); i++) {
52  		s[i] = MakeLowerCase(styler[start + i]);
53  	}
54  	s[i] = '\0';
55  }
56  std::string GetStringSegment(Accessor &styler, Sci_PositionU start, Sci_PositionU end) {
57  	std::string s;
58  	Sci_PositionU i = 0;
59  	for (; (i < end - start + 1); i++) {
60  		s.push_back(MakeLowerCase(styler[start + i]));
61  	}
62  	return s;
63  }
64  std::string GetNextWord(Accessor &styler, Sci_PositionU start) {
65  	std::string ret;
66  	Sci_PositionU i = 0;
67  	for (; i < 200; i++) {	
68  		const char ch = styler.SafeGetCharAt(start + i);
69  		if ((i == 0) && !IsAWordStart(ch))
70  			break;
71  		if ((i > 0) && !IsAWordChar(ch))
72  			break;
73  		ret.push_back(ch);
74  	}
75  	return ret;
76  }
77  script_type segIsScriptingIndicator(Accessor &styler, Sci_PositionU start, Sci_PositionU end, script_type prevValue) {
78  	char s[100];
79  	GetTextSegment(styler, start, end, s, sizeof(s));
80  	if (strstr(s, "vbs"))
81  		return eScriptVBS;
82  	if (strstr(s, "pyth"))
83  		return eScriptPython;
84  	if (strstr(s, "javas") || strstr(s, "ecmas") || strstr(s, "module") || strstr(s, "jscr"))
85  		return eScriptJS;
86  	if (strstr(s, "php"))
87  		return eScriptPHP;
88  	if (strstr(s, "xml")) {
89  		const char *xml = strstr(s, "xml");
90  		for (const char *t=s; t<xml; t++) {
91  			if (!IsASpace(*t)) {
92  				return prevValue;
93  			}
94  		}
95  		return eScriptXML;
96  	}
97  	return prevValue;
98  }
99  int PrintScriptingIndicatorOffset(Accessor &styler, Sci_PositionU start, Sci_PositionU end) {
100  	int iResult = 0;
101  	std::string s = GetStringSegment(styler, start, end);
102  	if (0 == strncmp(s.c_str(), "php", 3)) {
103  		iResult = 3;
104  	}
105  	return iResult;
106  }
107  script_type ScriptOfState(int state) {
108  	if ((state >= SCE_HP_START) && (state <= SCE_HP_IDENTIFIER)) {
109  		return eScriptPython;
110  	} else if ((state >= SCE_HB_START) && (state <= SCE_HB_STRINGEOL)) {
111  		return eScriptVBS;
112  	} else if ((state >= SCE_HJ_START) && (state <= SCE_HJ_REGEX)) {
113  		return eScriptJS;
114  	} else if ((state >= SCE_HPHP_DEFAULT) && (state <= SCE_HPHP_COMMENTLINE)) {
115  		return eScriptPHP;
116  	} else if ((state >= SCE_H_SGML_DEFAULT) && (state < SCE_H_SGML_BLOCK_DEFAULT)) {
117  		return eScriptSGML;
118  	} else if (state == SCE_H_SGML_BLOCK_DEFAULT) {
119  		return eScriptSGMLblock;
120  	} else {
121  		return eScriptNone;
122  	}
123  }
124  int statePrintForState(int state, script_mode inScriptType) {
125  	int StateToPrint = state;
126  	if (state >= SCE_HJ_START) {
127  		if ((state >= SCE_HP_START) && (state <= SCE_HP_IDENTIFIER)) {
128  			StateToPrint = state + ((inScriptType == eNonHtmlScript) ? 0 : SCE_HA_PYTHON);
129  		} else if ((state >= SCE_HB_START) && (state <= SCE_HB_STRINGEOL)) {
130  			StateToPrint = state + ((inScriptType == eNonHtmlScript) ? 0 : SCE_HA_VBS);
131  		} else if ((state >= SCE_HJ_START) && (state <= SCE_HJ_REGEX)) {
132  			StateToPrint = state + ((inScriptType == eNonHtmlScript) ? 0 : SCE_HA_JS);
133  		}
134  	}
135  	return StateToPrint;
136  }
137  int stateForPrintState(int StateToPrint) {
138  	int state;
139  	if ((StateToPrint >= SCE_HPA_START) && (StateToPrint <= SCE_HPA_IDENTIFIER)) {
140  		state = StateToPrint - SCE_HA_PYTHON;
141  	} else if ((StateToPrint >= SCE_HBA_START) && (StateToPrint <= SCE_HBA_STRINGEOL)) {
142  		state = StateToPrint - SCE_HA_VBS;
143  	} else if ((StateToPrint >= SCE_HJA_START) && (StateToPrint <= SCE_HJA_REGEX)) {
144  		state = StateToPrint - SCE_HA_JS;
145  	} else {
146  		state = StateToPrint;
147  	}
148  	return state;
149  }
150  constexpr bool IsNumberChar(char ch) noexcept {
151  	return IsADigit(ch) || ch == '.' || ch == '-' || ch == '#';
152  }
153  inline bool isStringState(int state) {
154  	bool bResult;
155  	switch (state) {
156  	case SCE_HJ_DOUBLESTRING:
157  	case SCE_HJ_SINGLESTRING:
158  	case SCE_HJA_DOUBLESTRING:
159  	case SCE_HJA_SINGLESTRING:
160  	case SCE_HB_STRING:
161  	case SCE_HBA_STRING:
162  	case SCE_HP_STRING:
163  	case SCE_HP_CHARACTER:
164  	case SCE_HP_TRIPLE:
165  	case SCE_HP_TRIPLEDOUBLE:
166  	case SCE_HPA_STRING:
167  	case SCE_HPA_CHARACTER:
168  	case SCE_HPA_TRIPLE:
169  	case SCE_HPA_TRIPLEDOUBLE:
170  	case SCE_HPHP_HSTRING:
171  	case SCE_HPHP_SIMPLESTRING:
172  	case SCE_HPHP_HSTRING_VARIABLE:
173  	case SCE_HPHP_COMPLEX_VARIABLE:
174  		bResult = true;
175  		break;
176  	default :
177  		bResult = false;
178  		break;
179  	}
180  	return bResult;
181  }
182  inline bool stateAllowsTermination(int state) {
183  	bool allowTermination = !isStringState(state);
184  	if (allowTermination) {
185  		switch (state) {
186  		case SCE_HB_COMMENTLINE:
187  		case SCE_HPHP_COMMENT:
188  		case SCE_HP_COMMENTLINE:
189  		case SCE_HPA_COMMENTLINE:
190  			allowTermination = false;
191  		}
192  	}
193  	return allowTermination;
194  }
195  inline bool isCommentASPState(int state) {
196  	bool bResult;
197  	switch (state) {
198  	case SCE_HJ_COMMENT:
199  	case SCE_HJ_COMMENTLINE:
200  	case SCE_HJ_COMMENTDOC:
201  	case SCE_HB_COMMENTLINE:
202  	case SCE_HP_COMMENTLINE:
203  	case SCE_HPHP_COMMENT:
204  	case SCE_HPHP_COMMENTLINE:
205  		bResult = true;
206  		break;
207  	default :
208  		bResult = false;
209  		break;
210  	}
211  	return bResult;
212  }
213  bool classifyAttribHTML(script_mode inScriptType, Sci_PositionU start, Sci_PositionU end, const WordList &keywords, Accessor &styler) {
214  	char chAttr = SCE_H_ATTRIBUTEUNKNOWN;
215  	bool isLanguageType = false;
216  	if (IsNumberChar(styler[start])) {
217  		chAttr = SCE_H_NUMBER;
218  	} else {
219  		const std::string s = GetStringSegment(styler, start, end);
220  		if (keywords.InList(s.c_str()))
221  			chAttr = SCE_H_ATTRIBUTE;
222  		if (inScriptType == eNonHtmlScript) {
223  			if (s == "type" || s == "language") {
224  				isLanguageType = true;
225  			}
226  		}
227  	}
228  	if ((chAttr == SCE_H_ATTRIBUTEUNKNOWN) && !keywords)
229  		chAttr = SCE_H_ATTRIBUTE;
230  	styler.ColourTo(end, chAttr);
231  	return isLanguageType;
232  }
233  bool isHTMLCustomElement(const std::string &tag) {
234  	if (tag.length() < 2 || !IsUpperOrLowerCase(tag[0])) {
235  		return false;
236  	}
237  	if (tag.find('-') == std::string::npos) {
238  		return false;
239  	}
240  	return true;
241  }
242  int classifyTagHTML(Sci_PositionU start, Sci_PositionU end,
243                             const WordList &keywords, Accessor &styler, bool &tagDontFold,
244                      bool caseSensitive, bool isXml, bool allowScripts,
245                      const std::set<std::string> &nonFoldingTags) {
246  	std::string tag;
247  	for (Sci_PositionU cPos = start; cPos <= end; cPos++) {
248  		const char ch = styler[cPos];
249  		if (IsASpace(ch)) {
250  			break;
251  		}
252  		if ((ch != '<') && (ch != '/')) {
253  			tag.push_back(caseSensitive ? ch : MakeLowerCase(ch));
254  		}
255  	}
256  	tagDontFold = (!isXml) && (nonFoldingTags.count(tag) > 0);
257  	char chAttr = SCE_H_TAGUNKNOWN;
258  	if (!tag.empty() && (tag[0] == '!')) {
259  		chAttr = SCE_H_SGML_DEFAULT;
260  	} else if (!keywords || keywords.InList(tag.c_str())) {
261  		chAttr = SCE_H_TAG;
262  	} else if (!isXml && isHTMLCustomElement(tag)) {
263  		chAttr = SCE_H_TAG;
264  	}
265  	if (chAttr != SCE_H_TAGUNKNOWN) {
266  		styler.ColourTo(end, chAttr);
267  	}
268  	if (chAttr == SCE_H_TAG) {
269  		if (allowScripts && (tag == "script")) {
270  			bool isSelfClose = false;
271  			for (Sci_PositionU cPos = end; cPos <= end + 200; cPos++) {
272  				const char ch = styler.SafeGetCharAt(cPos, '\0');
273  				if (ch == '\0' || ch == '>')
274  					break;
275  				else if (ch == '/' && styler.SafeGetCharAt(cPos + 1, '\0') == '>') {
276  					isSelfClose = true;
277  					break;
278  				}
279  			}
280  			if (!isSelfClose)
281  				chAttr = SCE_H_SCRIPT;
282  		} else if (!isXml && (tag == "comment")) {
283  			chAttr = SCE_H_COMMENT;
284  		}
285  	}
286  	return chAttr;
287  }
288  void classifyWordHTJS(Sci_PositionU start, Sci_PositionU end,
289                               const WordList &keywords, Accessor &styler, script_mode inScriptType) {
290  	char s[30 + 1];
291  	Sci_PositionU i = 0;
292  	for (; i < end - start + 1 && i < 30; i++) {
293  		s[i] = styler[start + i];
294  	}
295  	s[i] = '\0';
296  	char chAttr = SCE_HJ_WORD;
297  	const bool wordIsNumber = IsADigit(s[0]) || ((s[0] == '.') && IsADigit(s[1]));
298  	if (wordIsNumber) {
299  		chAttr = SCE_HJ_NUMBER;
300  	} else if (keywords.InList(s)) {
301  		chAttr = SCE_HJ_KEYWORD;
302  	}
303  	styler.ColourTo(end, statePrintForState(chAttr, inScriptType));
304  }
305  int classifyWordHTVB(Sci_PositionU start, Sci_PositionU end, const WordList &keywords, Accessor &styler, script_mode inScriptType) {
306  	char chAttr = SCE_HB_IDENTIFIER;
307  	const bool wordIsNumber = IsADigit(styler[start]) || (styler[start] == '.');
308  	if (wordIsNumber) {
309  		chAttr = SCE_HB_NUMBER;
310  	} else {
311  		std::string s = GetStringSegment(styler, start, end);
312  		if (keywords.InList(s.c_str())) {
313  			chAttr = SCE_HB_WORD;
314  			if (s == "rem")
315  				chAttr = SCE_HB_COMMENTLINE;
316  		}
317  	}
318  	styler.ColourTo(end, statePrintForState(chAttr, inScriptType));
319  	if (chAttr == SCE_HB_COMMENTLINE)
320  		return SCE_HB_COMMENTLINE;
321  	else
322  		return SCE_HB_DEFAULT;
323  }
324  void classifyWordHTPy(Sci_PositionU start, Sci_PositionU end, const WordList &keywords, Accessor &styler, std::string &prevWord, script_mode inScriptType, bool isMako) {
325  	const bool wordIsNumber = IsADigit(styler[start]);
326  	std::string s;
327  	for (Sci_PositionU i = 0; i < end - start + 1 && i < 30; i++) {
328  		s.push_back(styler[start + i]);
329  	}
330  	char chAttr = SCE_HP_IDENTIFIER;
331  	if (prevWord == "class")
332  		chAttr = SCE_HP_CLASSNAME;
333  	else if (prevWord == "def")
334  		chAttr = SCE_HP_DEFNAME;
335  	else if (wordIsNumber)
336  		chAttr = SCE_HP_NUMBER;
337  	else if (keywords.InList(s.c_str()))
338  		chAttr = SCE_HP_WORD;
339  	else if (isMako && (s == "block"))
340  		chAttr = SCE_HP_WORD;
341  	styler.ColourTo(end, statePrintForState(chAttr, inScriptType));
342  	prevWord = s;
343  }
344  void classifyWordHTPHP(Sci_PositionU start, Sci_PositionU end, const WordList &keywords, Accessor &styler) {
345  	char chAttr = SCE_HPHP_DEFAULT;
346  	const bool wordIsNumber = IsADigit(styler[start]) || (styler[start] == '.' && start+1 <= end && IsADigit(styler[start+1]));
347  	if (wordIsNumber) {
348  		chAttr = SCE_HPHP_NUMBER;
349  	} else {
350  		std::string s = GetStringSegment(styler, start, end);
351  		if (keywords.InList(s.c_str()))
352  			chAttr = SCE_HPHP_WORD;
353  	}
354  	styler.ColourTo(end, chAttr);
355  }
356  bool isWordHSGML(Sci_PositionU start, Sci_PositionU end, const WordList &keywords, Accessor &styler) {
357  	std::string s;
358  	for (Sci_PositionU i = 0; i < end - start + 1 && i < 30; i++) {
359  		s.push_back(styler[start + i]);
360  	}
361  	return keywords.InList(s.c_str());
362  }
363  bool isWordCdata(Sci_PositionU start, Sci_PositionU end, Accessor &styler) {
364  	std::string s;
365  	for (Sci_PositionU i = 0; i < end - start + 1 && i < 30; i++) {
366  		s.push_back(styler[start + i]);
367  	}
368  	return s == "[CDATA[";
369  }
370  int StateForScript(script_type scriptLanguage) {
371  	int Result;
372  	switch (scriptLanguage) {
373  	case eScriptVBS:
374  		Result = SCE_HB_START;
375  		break;
376  	case eScriptPython:
377  		Result = SCE_HP_START;
378  		break;
379  	case eScriptPHP:
380  		Result = SCE_HPHP_DEFAULT;
381  		break;
382  	case eScriptXML:
383  		Result = SCE_H_TAGUNKNOWN;
384  		break;
385  	case eScriptSGML:
386  		Result = SCE_H_SGML_DEFAULT;
387  		break;
388  	case eScriptComment:
389  		Result = SCE_H_COMMENT;
390  		break;
391  	default :
392  		Result = SCE_HJ_START;
393  		break;
394  	}
395  	return Result;
396  }
397  inline bool issgmlwordchar(int ch) {
398  	return !IsASCII(ch) ||
399  		(isalnum(ch) || ch == '.' || ch == '_' || ch == ':' || ch == '!' || ch == '#' || ch == '[');
400  }
401  inline bool IsPhpWordStart(int ch) {
402  	return (IsASCII(ch) && (isalpha(ch) || (ch == '_'))) || (ch >= 0x7f);
403  }
404  inline bool IsPhpWordChar(int ch) {
405  	return IsADigit(ch) || IsPhpWordStart(ch);
406  }
407  bool InTagState(int state) {
408  	return state == SCE_H_TAG || state == SCE_H_TAGUNKNOWN ||
409  	       state == SCE_H_SCRIPT ||
410  	       state == SCE_H_ATTRIBUTE || state == SCE_H_ATTRIBUTEUNKNOWN ||
411  	       state == SCE_H_NUMBER || state == SCE_H_OTHER ||
412  	       state == SCE_H_DOUBLESTRING || state == SCE_H_SINGLESTRING;
413  }
414  bool IsCommentState(const int state) {
415  	return state == SCE_H_COMMENT || state == SCE_H_SGML_COMMENT;
416  }
417  bool IsScriptCommentState(const int state) {
418  	return state == SCE_HJ_COMMENT || state == SCE_HJ_COMMENTLINE || state == SCE_HJA_COMMENT ||
419  		   state == SCE_HJA_COMMENTLINE || state == SCE_HB_COMMENTLINE || state == SCE_HBA_COMMENTLINE;
420  }
421  bool isLineEnd(int ch) {
422  	return ch == '\r' || ch == '\n';
423  }
424  bool isMakoBlockEnd(const int ch, const int chNext, const std::string &blockType) {
425  	if (blockType.empty()) {
426  		return ((ch == '%') && (chNext == '>'));
427  	} else if ((blockType == "inherit") ||
428  			   (blockType == "namespace") ||
429  			   (blockType == "include") ||
430  			   (blockType == "page")) {
431  		return ((ch == '/') && (chNext == '>'));
432  	} else if (blockType == "%") {
433  		if (ch == '/' && isLineEnd(chNext))
434  			return true;
435  		else
436  			return isLineEnd(ch);
437  	} else if (blockType == "{") {
438  		return ch == '}';
439  	} else {
440  		return (ch == '>');
441  	}
442  }
443  bool isDjangoBlockEnd(const int ch, const int chNext, const std::string &blockType) {
444  	if (blockType.empty()) {
445  		return false;
446  	} else if (blockType == "%") {
447  		return ((ch == '%') && (chNext == '}'));
448  	} else if (blockType == "{") {
449  		return ((ch == '}') && (chNext == '}'));
450  	} else {
451  		return false;
452  	}
453  }
454  class PhpNumberState {
455  	enum NumberBase { BASE_10 = 0, BASE_2, BASE_8, BASE_16 };
456  	static constexpr const char *const digitList[] = { "_0123456789", "_01", "_01234567", "_0123456789abcdefABCDEF" };
457  	NumberBase base = BASE_10;
458  	bool decimalPart = false;
459  	bool exponentPart = false;
460  	bool invalid = false;
461  	bool finished = false;
462  	bool leadingZero = false;
463  	bool invalidBase8 = false;
464  	bool betweenDigits = false;
465  	bool decimalChar = false;
466  	bool exponentChar = false;
467  public:
468  	inline bool isInvalid() { return invalid; }
469  	inline bool isFinished() { return finished; }
470  	bool init(int ch, int chPlus1, int chPlus2) {
471  		base = BASE_10;
472  		decimalPart = false;
473  		exponentPart = false;
474  		invalid = false;
475  		finished = false;
476  		leadingZero = false;
477  		invalidBase8 = false;
478  		betweenDigits = false;
479  		decimalChar = false;
480  		exponentChar = false;
481  		if (ch == '.' && strchr(digitList[BASE_10] + !betweenDigits, chPlus1) != nullptr) {
482  			decimalPart = true;
483  			betweenDigits = true;
484  		} else if (ch == '0' && (chPlus1 == 'b' || chPlus1 == 'B')) {
485  			base = BASE_2;
486  		} else if (ch == '0' && (chPlus1 == 'o' || chPlus1 == 'O')) {
487  			base = BASE_8;
488  		} else if (ch == '0' && (chPlus1 == 'x' || chPlus1 == 'X')) {
489  			base = BASE_16;
490  		} else if (strchr(digitList[BASE_10] + !betweenDigits, ch) != nullptr) {
491  			leadingZero = ch == '0';
492  			betweenDigits = true;
493  			check(chPlus1, chPlus2);
494  			if (finished && leadingZero) {
495  				base = BASE_10;
496  			}
497  		} else {
498  			return false;
499  		}
500  		return true;
501  	}
502  	bool check(int ch, int chPlus1) {
503  		if (strchr(digitList[base] + !betweenDigits, ch) != nullptr) {
504  			if (leadingZero) {
505  				invalidBase8 = invalidBase8 || strchr(digitList[BASE_8] + !betweenDigits, ch) == nullptr;
506  			}
507  			betweenDigits = ch != '_';
508  			decimalChar = false;
509  			exponentChar = false;
510  		} else if (ch == '_') {
511  			invalid = true;
512  			betweenDigits = false;
513  			decimalChar = false;
514  		} else if (base == BASE_10 && ch == '.' && (
515  					!(decimalPart || exponentPart) || strchr(digitList[BASE_10] + !betweenDigits, chPlus1) != nullptr)
516  			  ) {
517  			invalid = invalid || !betweenDigits || decimalPart || exponentPart;
518  			decimalPart = true;
519  			betweenDigits = false;
520  			decimalChar = true;
521  			exponentChar = false;
522  		} else if (base == BASE_10 && (ch == 'e' || ch == 'E')) {
523  			invalid = invalid || !(betweenDigits || decimalChar) || exponentPart;
524  			exponentPart = true;
525  			betweenDigits = false;
526  			decimalChar = false;
527  			exponentChar = true;
528  		} else if (base == BASE_10 && (ch == '-' || ch == '+') && exponentChar) {
529  			invalid = invalid || strchr(digitList[BASE_10] + !betweenDigits, chPlus1) == nullptr;
530  			betweenDigits = false;
531  			decimalChar = false;
532  		} else if (IsPhpWordChar(ch)) {
533  			invalid = true;
534  			betweenDigits = false;
535  			decimalChar = false;
536  			exponentChar = false;
537  		} else {
538  			invalid = invalid || !(betweenDigits || decimalChar);
539  			finished = true;
540  			if (base == BASE_10 && leadingZero && !decimalPart && !exponentPart) {
541  				base = BASE_8;
542  				invalid = invalid || invalidBase8;
543  			}
544  		}
545  		return finished;
546  	}
547  };
548  bool isPHPStringState(int state) {
549  	return
550  	    (state == SCE_HPHP_HSTRING) ||
551  	    (state == SCE_HPHP_SIMPLESTRING) ||
552  	    (state == SCE_HPHP_HSTRING_VARIABLE) ||
553  	    (state == SCE_HPHP_COMPLEX_VARIABLE);
554  }
555  Sci_Position FindPhpStringDelimiter(std::string &phpStringDelimiter, Sci_Position i, const Sci_Position lengthDoc, Accessor &styler, bool &isSimpleString) {
556  	Sci_Position j;
557  	const Sci_Position beginning = i - 1;
558  	bool isQuoted = false;
559  	while (i < lengthDoc && (styler[i] == ' ' || styler[i] == '\t'))
560  		i++;
561  	char ch = styler.SafeGetCharAt(i);
562  	const char chNext = styler.SafeGetCharAt(i + 1);
563  	phpStringDelimiter.clear();
564  	if (!IsPhpWordStart(ch)) {
565  		if ((ch == '\'' || ch == '\"') && IsPhpWordStart(chNext)) {
566  			isSimpleString = ch == '\'';
567  			isQuoted = true;
568  			i++;
569  			ch = chNext;
570  		} else {
571  			return beginning;
572  		}
573  	}
574  	phpStringDelimiter.push_back(ch);
575  	i++;
576  	for (j = i; j < lengthDoc && !isLineEnd(styler[j]); j++) {
577  		if (!IsPhpWordChar(styler[j]) && isQuoted) {
578  			if (((isSimpleString && styler[j] == '\'') || (!isSimpleString && styler[j] == '\"')) && isLineEnd(styler.SafeGetCharAt(j + 1))) {
579  				isQuoted = false;
580  				j++;
581  				break;
582  			} else {
583  				phpStringDelimiter.clear();
584  				return beginning;
585  			}
586  		}
587  		phpStringDelimiter.push_back(styler[j]);
588  	}
589  	if (isQuoted) {
590  		phpStringDelimiter.clear();
591  		return beginning;
592  	}
593  	return j - 1;
594  }
595  struct OptionsHTML {
596  	int aspDefaultLanguage = eScriptJS;
597  	bool caseSensitive = false;
598  	bool allowScripts = true;
599  	bool isMako = false;
600  	bool isDjango = false;
601  	bool fold = false;
602  	bool foldHTML = false;
603  	bool foldHTMLPreprocessor = true;
604  	bool foldCompact = true;
605  	bool foldComment = false;
606  	bool foldHeredoc = false;
607  	bool foldXmlAtTagOpen = false;
608  	OptionsHTML() noexcept {
609  	}
610  };
611  const char * const htmlWordListDesc[] = {
612  	"HTML elements and attributes",
613  	"JavaScript keywords",
614  	"VBScript keywords",
615  	"Python keywords",
616  	"PHP keywords",
617  	"SGML and DTD keywords",
618  	0,
619  };
620  const char * const phpscriptWordListDesc[] = {
621  	"", 
622  	"", 
623  	"", 
624  	"", 
625  	"PHP keywords",
626  	"", 
627  	0,
628  };
629  struct OptionSetHTML : public OptionSet<OptionsHTML> {
630  	OptionSetHTML(bool isPHPScript_) {
631  		DefineProperty("asp.default.language", &OptionsHTML::aspDefaultLanguage,
632  			"Script in ASP code is initially assumed to be in JavaScript. "
633  			"To change this to VBScript set asp.default.language to 2. Python is 3.");
634  		DefineProperty("html.tags.case.sensitive", &OptionsHTML::caseSensitive,
635  			"For XML and HTML, setting this property to 1 will make tags match in a case "
636  			"sensitive way which is the expected behaviour for XML and XHTML.");
637  		DefineProperty("lexer.xml.allow.scripts", &OptionsHTML::allowScripts,
638  			"Set to 0 to disable scripts in XML.");
639  		DefineProperty("lexer.html.mako", &OptionsHTML::isMako,
640  			"Set to 1 to enable the mako template language.");
641  		DefineProperty("lexer.html.django", &OptionsHTML::isDjango,
642  			"Set to 1 to enable the django template language.");
643  		DefineProperty("fold", &OptionsHTML::fold);
644  		DefineProperty("fold.html", &OptionsHTML::foldHTML,
645  			"Folding is turned on or off for HTML and XML files with this option. "
646  			"The fold option must also be on for folding to occur.");
647  		DefineProperty("fold.html.preprocessor", &OptionsHTML::foldHTMLPreprocessor,
648  			"Folding is turned on or off for scripts embedded in HTML files with this option. "
649  			"The default is on.");
650  		DefineProperty("fold.compact", &OptionsHTML::foldCompact);
651  		DefineProperty("fold.hypertext.comment", &OptionsHTML::foldComment,
652  			"Allow folding for comments in scripts embedded in HTML. "
653  			"The default is off.");
654  		DefineProperty("fold.hypertext.heredoc", &OptionsHTML::foldHeredoc,
655  			"Allow folding for heredocs in scripts embedded in HTML. "
656  			"The default is off.");
657  		DefineProperty("fold.xml.at.tag.open", &OptionsHTML::foldXmlAtTagOpen,
658  			"Enable folding for XML at the start of open tag. "
659  			"The default is off.");
660  		DefineWordListSets(isPHPScript_ ? phpscriptWordListDesc : htmlWordListDesc);
661  	}
662  };
663  LexicalClass lexicalClassesHTML[] = {
664  	0, "SCE_H_DEFAULT", "default", "Text",
665  	1, "SCE_H_TAG", "tag", "Tags",
666  	2, "SCE_H_ERRORTAGUNKNOWN", "error tag", "Unknown Tags",
667  	3, "SCE_H_ATTRIBUTE", "attribute", "Attributes",
668  	4, "SCE_H_ATTRIBUTEUNKNOWN", "error attribute", "Unknown Attributes",
669  	5, "SCE_H_NUMBER", "literal numeric", "Numbers",
670  	6, "SCE_H_DOUBLESTRING", "literal string", "Double quoted strings",
671  	7, "SCE_H_SINGLESTRING", "literal string", "Single quoted strings",
672  	8, "SCE_H_OTHER", "tag operator", "Other inside tag, including space and '='",
673  	9, "SCE_H_COMMENT", "comment", "Comment",
674  	10, "SCE_H_ENTITY", "literal", "Entities",
675  	11, "SCE_H_TAGEND", "tag", "XML style tag ends '/>'",
676  	12, "SCE_H_XMLSTART", "identifier", "XML identifier start '<?'",
677  	13, "SCE_H_XMLEND", "identifier", "XML identifier end '?>'",
678  	14, "SCE_H_SCRIPT", "error", "Internal state which should never be visible",
679  	15, "SCE_H_ASP", "preprocessor", "ASP <% ... %>",
680  	16, "SCE_H_ASPAT", "preprocessor", "ASP <% ... %>",
681  	17, "SCE_H_CDATA", "literal", "CDATA",
682  	18, "SCE_H_QUESTION", "preprocessor", "PHP",
683  	19, "SCE_H_VALUE", "literal string", "Unquoted values",
684  	20, "SCE_H_XCCOMMENT", "comment", "JSP Comment <%-- ... --%>",
685  	21, "SCE_H_SGML_DEFAULT", "default", "SGML tags <! ... >",
686  	22, "SCE_H_SGML_COMMAND", "preprocessor", "SGML command",
687  	23, "SCE_H_SGML_1ST_PARAM", "preprocessor", "SGML 1st param",
688  	24, "SCE_H_SGML_DOUBLESTRING", "literal string", "SGML double string",
689  	25, "SCE_H_SGML_SIMPLESTRING", "literal string", "SGML single string",
690  	26, "SCE_H_SGML_ERROR", "error", "SGML error",
691  	27, "SCE_H_SGML_SPECIAL", "literal", "SGML special (#XXXX type)",
692  	28, "SCE_H_SGML_ENTITY", "literal", "SGML entity",
693  	29, "SCE_H_SGML_COMMENT", "comment", "SGML comment",
694  	30, "SCE_H_SGML_1ST_PARAM_COMMENT", "error comment", "SGML first parameter - lexer internal. It is an error if any text is in this style.",
695  	31, "SCE_H_SGML_BLOCK_DEFAULT", "default", "SGML block",
696  	32, "", "predefined", "",
697  	33, "", "predefined", "",
698  	34, "", "predefined", "",
699  	35, "", "predefined", "",
700  	36, "", "predefined", "",
701  	37, "", "predefined", "",
702  	38, "", "predefined", "",
703  	39, "", "predefined", "",
704  	40, "SCE_HJ_START", "client javascript default", "JS Start - allows eol filled background to not start on same line as SCRIPT tag",
705  	41, "SCE_HJ_DEFAULT", "client javascript default", "JS Default",
706  	42, "SCE_HJ_COMMENT", "client javascript comment", "JS Comment",
707  	43, "SCE_HJ_COMMENTLINE", "client javascript comment line", "JS Line Comment",
708  	44, "SCE_HJ_COMMENTDOC", "client javascript comment documentation", "JS Doc comment",
709  	45, "SCE_HJ_NUMBER", "client javascript literal numeric", "JS Number",
710  	46, "SCE_HJ_WORD", "client javascript identifier", "JS Word",
711  	47, "SCE_HJ_KEYWORD", "client javascript keyword", "JS Keyword",
712  	48, "SCE_HJ_DOUBLESTRING", "client javascript literal string", "JS Double quoted string",
713  	49, "SCE_HJ_SINGLESTRING", "client javascript literal string", "JS Single quoted string",
714  	50, "SCE_HJ_SYMBOLS", "client javascript operator", "JS Symbols",
715  	51, "SCE_HJ_STRINGEOL", "client javascript error literal string", "JavaScript EOL",
716  	52, "SCE_HJ_REGEX", "client javascript literal regex", "JavaScript RegEx",
717  	53, "", "unused", "",
718  	54, "", "unused", "",
719  	55, "SCE_HJA_START", "server javascript default", "JS Start - allows eol filled background to not start on same line as SCRIPT tag",
720  	56, "SCE_HJA_DEFAULT", "server javascript default", "JS Default",
721  	57, "SCE_HJA_COMMENT", "server javascript comment", "JS Comment",
722  	58, "SCE_HJA_COMMENTLINE", "server javascript comment line", "JS Line Comment",
723  	59, "SCE_HJA_COMMENTDOC", "server javascript comment documentation", "JS Doc comment",
724  	60, "SCE_HJA_NUMBER", "server javascript literal numeric", "JS Number",
725  	61, "SCE_HJA_WORD", "server javascript identifier", "JS Word",
726  	62, "SCE_HJA_KEYWORD", "server javascript keyword", "JS Keyword",
727  	63, "SCE_HJA_DOUBLESTRING", "server javascript literal string", "JS Double quoted string",
728  	64, "SCE_HJA_SINGLESTRING", "server javascript literal string", "JS Single quoted string",
729  	65, "SCE_HJA_SYMBOLS", "server javascript operator", "JS Symbols",
730  	66, "SCE_HJA_STRINGEOL", "server javascript error literal string", "JavaScript EOL",
731  	67, "SCE_HJA_REGEX", "server javascript literal regex", "JavaScript RegEx",
732  	68, "", "unused", "",
733  	69, "", "unused", "",
734  	70, "SCE_HB_START", "client basic default", "Start",
735  	71, "SCE_HB_DEFAULT", "client basic default", "Default",
736  	72, "SCE_HB_COMMENTLINE", "client basic comment line", "Comment",
737  	73, "SCE_HB_NUMBER", "client basic literal numeric", "Number",
738  	74, "SCE_HB_WORD", "client basic keyword", "KeyWord",
739  	75, "SCE_HB_STRING", "client basic literal string", "String",
740  	76, "SCE_HB_IDENTIFIER", "client basic identifier", "Identifier",
741  	77, "SCE_HB_STRINGEOL", "client basic literal string", "Unterminated string",
742  	78, "", "unused", "",
743  	79, "", "unused", "",
744  	80, "SCE_HBA_START", "server basic default", "Start",
745  	81, "SCE_HBA_DEFAULT", "server basic default", "Default",
746  	82, "SCE_HBA_COMMENTLINE", "server basic comment line", "Comment",
747  	83, "SCE_HBA_NUMBER", "server basic literal numeric", "Number",
748  	84, "SCE_HBA_WORD", "server basic keyword", "KeyWord",
749  	85, "SCE_HBA_STRING", "server basic literal string", "String",
750  	86, "SCE_HBA_IDENTIFIER", "server basic identifier", "Identifier",
751  	87, "SCE_HBA_STRINGEOL", "server basic literal string", "Unterminated string",
752  	88, "", "unused", "",
753  	89, "", "unused", "",
754  	90, "SCE_HP_START", "client python default", "Embedded Python",
755  	91, "SCE_HP_DEFAULT", "client python default", "Embedded Python",
756  	92, "SCE_HP_COMMENTLINE", "client python comment line", "Comment",
757  	93, "SCE_HP_NUMBER", "client python literal numeric", "Number",
758  	94, "SCE_HP_STRING", "client python literal string", "String",
759  	95, "SCE_HP_CHARACTER", "client python literal string character", "Single quoted string",
760  	96, "SCE_HP_WORD", "client python keyword", "Keyword",
761  	97, "SCE_HP_TRIPLE", "client python literal string", "Triple quotes",
762  	98, "SCE_HP_TRIPLEDOUBLE", "client python literal string", "Triple double quotes",
763  	99, "SCE_HP_CLASSNAME", "client python identifier", "Class name definition",
764  	100, "SCE_HP_DEFNAME", "client python identifier", "Function or method name definition",
765  	101, "SCE_HP_OPERATOR", "client python operator", "Operators",
766  	102, "SCE_HP_IDENTIFIER", "client python identifier", "Identifiers",
767  	103, "", "unused", "",
768  	104, "SCE_HPHP_COMPLEX_VARIABLE", "server php identifier", "PHP complex variable",
769  	105, "SCE_HPA_START", "server python default", "ASP Python",
770  	106, "SCE_HPA_DEFAULT", "server python default", "ASP Python",
771  	107, "SCE_HPA_COMMENTLINE", "server python comment line", "Comment",
772  	108, "SCE_HPA_NUMBER", "server python literal numeric", "Number",
773  	109, "SCE_HPA_STRING", "server python literal string", "String",
774  	110, "SCE_HPA_CHARACTER", "server python literal string character", "Single quoted string",
775  	111, "SCE_HPA_WORD", "server python keyword", "Keyword",
776  	112, "SCE_HPA_TRIPLE", "server python literal string", "Triple quotes",
777  	113, "SCE_HPA_TRIPLEDOUBLE", "server python literal string", "Triple double quotes",
778  	114, "SCE_HPA_CLASSNAME", "server python identifier", "Class name definition",
779  	115, "SCE_HPA_DEFNAME", "server python identifier", "Function or method name definition",
780  	116, "SCE_HPA_OPERATOR", "server python operator", "Operators",
781  	117, "SCE_HPA_IDENTIFIER", "server python identifier", "Identifiers",
782  	118, "SCE_HPHP_DEFAULT", "server php default", "Default",
783  	119, "SCE_HPHP_HSTRING", "server php literal string", "Double quoted String",
784  	120, "SCE_HPHP_SIMPLESTRING", "server php literal string", "Single quoted string",
785  	121, "SCE_HPHP_WORD", "server php keyword", "Keyword",
786  	122, "SCE_HPHP_NUMBER", "server php literal numeric", "Number",
787  	123, "SCE_HPHP_VARIABLE", "server php identifier", "Variable",
788  	124, "SCE_HPHP_COMMENT", "server php comment", "Comment",
789  	125, "SCE_HPHP_COMMENTLINE", "server php comment line", "One line comment",
790  	126, "SCE_HPHP_HSTRING_VARIABLE", "server php literal string identifier", "PHP variable in double quoted string",
791  	127, "SCE_HPHP_OPERATOR", "server php operator", "PHP operator",
792  };
793  LexicalClass lexicalClassesXML[] = {
794  	0, "SCE_H_DEFAULT", "default", "Default",
795  	1, "SCE_H_TAG", "tag", "Tags",
796  	2, "SCE_H_TAGUNKNOWN", "error tag", "Unknown Tags",
797  	3, "SCE_H_ATTRIBUTE", "attribute", "Attributes",
798  	4, "SCE_H_ERRORATTRIBUTEUNKNOWN", "error attribute", "Unknown Attributes",
799  	5, "SCE_H_NUMBER", "literal numeric", "Numbers",
800  	6, "SCE_H_DOUBLESTRING", "literal string", "Double quoted strings",
801  	7, "SCE_H_SINGLESTRING", "literal string", "Single quoted strings",
802  	8, "SCE_H_OTHER", "tag operator", "Other inside tag, including space and '='",
803  	9, "SCE_H_COMMENT", "comment", "Comment",
804  	10, "SCE_H_ENTITY", "literal", "Entities",
805  	11, "SCE_H_TAGEND", "tag", "XML style tag ends '/>'",
806  	12, "SCE_H_XMLSTART", "identifier", "XML identifier start '<?'",
807  	13, "SCE_H_XMLEND", "identifier", "XML identifier end '?>'",
808  	14, "", "unused", "",
809  	15, "", "unused", "",
810  	16, "", "unused", "",
811  	17, "SCE_H_CDATA", "literal", "CDATA",
812  	18, "SCE_H_QUESTION", "preprocessor", "Question",
813  	19, "SCE_H_VALUE", "literal string", "Unquoted Value",
814  	20, "", "unused", "",
815  	21, "SCE_H_SGML_DEFAULT", "default", "SGML tags <! ... >",
816  	22, "SCE_H_SGML_COMMAND", "preprocessor", "SGML command",
817  	23, "SCE_H_SGML_1ST_PARAM", "preprocessor", "SGML 1st param",
818  	24, "SCE_H_SGML_DOUBLESTRING", "literal string", "SGML double string",
819  	25, "SCE_H_SGML_SIMPLESTRING", "literal string", "SGML single string",
820  	26, "SCE_H_SGML_ERROR", "error", "SGML error",
821  	27, "SCE_H_SGML_SPECIAL", "literal", "SGML special (#XXXX type)",
822  	28, "SCE_H_SGML_ENTITY", "literal", "SGML entity",
823  	29, "SCE_H_SGML_COMMENT", "comment", "SGML comment",
824  	30, "", "unused", "",
825  	31, "SCE_H_SGML_BLOCK_DEFAULT", "default", "SGML block",
826  };
827  const char *tagsThatDoNotFold[] = {
828  	"area",
829  	"base",
830  	"basefont",
831  	"br",
832  	"col",
833  	"command",
834  	"embed",
835  	"frame",
836  	"hr",
837  	"img",
838  	"input",
839  	"isindex",
840  	"keygen",
841  	"link",
842  	"meta",
843  	"param",
844  	"source",
845  	"track",
846  	"wbr"
847  };
848  }
849  class LexerHTML : public DefaultLexer {
850  	bool isXml;
851  	bool isPHPScript;
852  	WordList keywords;
853  	WordList keywords2;
854  	WordList keywords3;
855  	WordList keywords4;
856  	WordList keywords5;
857  	WordList keywords6; 
858  	OptionsHTML options;
859  	OptionSetHTML osHTML;
860  	std::set<std::string> nonFoldingTags;
861  public:
862  	explicit LexerHTML(bool isXml_, bool isPHPScript_) :
863  		DefaultLexer(
864  			isXml_ ? "xml" : (isPHPScript_ ? "phpscript" : "hypertext"),
865  			isXml_ ? SCLEX_XML : (isPHPScript_ ? SCLEX_PHPSCRIPT : SCLEX_HTML),
866  			isXml_ ?  lexicalClassesXML : lexicalClassesHTML,
867  			isXml_ ?  std::size(lexicalClassesXML) : std::size(lexicalClassesHTML)),
868  		isXml(isXml_),
869  		isPHPScript(isPHPScript_),
870  		osHTML(isPHPScript_),
871  		nonFoldingTags(std::begin(tagsThatDoNotFold), std::end(tagsThatDoNotFold)) {
872  	}
873  	~LexerHTML() override {
874  	}
875  	void SCI_METHOD Release() override {
876  		delete this;
877  	}
878  	const char *SCI_METHOD PropertyNames() override {
879  		return osHTML.PropertyNames();
880  	}
881  	int SCI_METHOD PropertyType(const char *name) override {
882  		return osHTML.PropertyType(name);
883  	}
884  	const char *SCI_METHOD DescribeProperty(const char *name) override {
885  		return osHTML.DescribeProperty(name);
886  	}
887  	Sci_Position SCI_METHOD PropertySet(const char *key, const char *val) override;
888  	const char * SCI_METHOD PropertyGet(const char *key) override {
889  		return osHTML.PropertyGet(key);
890  	}
891  	const char *SCI_METHOD DescribeWordListSets() override {
892  		return osHTML.DescribeWordListSets();
893  	}
894  	Sci_Position SCI_METHOD WordListSet(int n, const char *wl) override;
895  	void SCI_METHOD Lex(Sci_PositionU startPos, Sci_Position length, int initStyle, IDocument *pAccess) override;
896  	static ILexer5 *LexerFactoryHTML() {
897  		return new LexerHTML(false, false);
898  	}
899  	static ILexer5 *LexerFactoryXML() {
900  		return new LexerHTML(true, false);
901  	}
902  	static ILexer5 *LexerFactoryPHPScript() {
903  		return new LexerHTML(false, true);
904  	}
905  };
906  Sci_Position SCI_METHOD LexerHTML::PropertySet(const char *key, const char *val) {
907  	if (osHTML.PropertySet(&options, key, val)) {
908  		return 0;
909  	}
910  	return -1;
911  }
912  Sci_Position SCI_METHOD LexerHTML::WordListSet(int n, const char *wl) {
913  	WordList *wordListN = 0;
914  	switch (n) {
915  	case 0:
916  		wordListN = &keywords;
917  		break;
918  	case 1:
919  		wordListN = &keywords2;
920  		break;
921  	case 2:
922  		wordListN = &keywords3;
923  		break;
924  	case 3:
925  		wordListN = &keywords4;
926  		break;
927  	case 4:
928  		wordListN = &keywords5;
929  		break;
930  	case 5:
931  		wordListN = &keywords6;
932  		break;
933  	}
934  	Sci_Position firstModification = -1;
935  	if (wordListN) {
936  		if (wordListN->Set(wl)) {
937  			firstModification = 0;
938  		}
939  	}
940  	return firstModification;
941  }
942  void SCI_METHOD LexerHTML::Lex(Sci_PositionU startPos, Sci_Position length, int initStyle, IDocument *pAccess) {
943  	Accessor styler(pAccess, nullptr);
944  	if (isPHPScript && (startPos == 0)) {
945  		initStyle = SCE_HPHP_DEFAULT;
946  	}
947  	styler.StartAt(startPos);
948  	std::string prevWord;
949  	PhpNumberState phpNumber;
950  	std::string phpStringDelimiter;
951  	int StateToPrint = initStyle;
952  	int state = stateForPrintState(StateToPrint);
953  	std::string makoBlockType;
954  	int makoComment = 0;
955  	std::string djangoBlockType;
956  	if (InTagState(state)) {
957  		while ((startPos > 0) && (InTagState(styler.StyleAt(startPos - 1)))) {
958  			const Sci_Position backLineStart = styler.LineStart(styler.GetLine(startPos-1));
959  			length += startPos - backLineStart;
960  			startPos = backLineStart;
961  		}
962  		state = SCE_H_DEFAULT;
963  	}
964  	if (isPHPStringState(state)) {
965  		while (startPos > 0 && (isPHPStringState(state) || !isLineEnd(styler[startPos - 1]))) {
966  			startPos--;
967  			length++;
968  			state = styler.StyleAt(startPos);
969  		}
970  		if (startPos == 0)
971  			state = SCE_H_DEFAULT;
972  	}
973  	styler.StartAt(startPos);
974  	switch (state) {
975  		case SCE_H_QUESTION:
976  		case SCE_H_XMLSTART:
977  		case SCE_H_XMLEND:
978  		case SCE_H_ASP:
979  			state = SCE_H_DEFAULT;
980  			break;
981  	}
982  	Sci_Position lineCurrent = styler.GetLine(startPos);
983  	int lineState;
984  	if (lineCurrent > 0) {
985  		lineState = styler.GetLineState(lineCurrent-1);
986  	} else {
987  		lineState = eScriptJS << 8;
988  		lineState |= options.aspDefaultLanguage << 4;
989  	}
990  	script_mode inScriptType = static_cast<script_mode>((lineState >> 0) & 0x03); 
991  	bool tagOpened = (lineState >> 2) & 0x01; 
992  	bool tagClosing = (lineState >> 3) & 0x01; 
993  	bool tagDontFold = false; 
994  	script_type aspScript = static_cast<script_type>((lineState >> 4) & 0x0F); 
995  	script_type clientScript = static_cast<script_type>((lineState >> 8) & 0x0F); 
996  	int beforePreProc = (lineState >> 12) & 0xFF; 
997  	bool isLanguageType = (lineState >> 20) & 1; 
998  	script_type scriptLanguage = ScriptOfState(state);
999  	if (inScriptType == eNonHtmlScript && state == SCE_H_COMMENT) {
1000  		scriptLanguage = eScriptComment;
1001  	}
1002  	script_type beforeLanguage = ScriptOfState(beforePreProc);
1003  	const bool foldHTML = options.foldHTML;
1004  	const bool fold = foldHTML && options.fold;
1005  	const bool foldHTMLPreprocessor = foldHTML && options.foldHTMLPreprocessor;
1006  	const bool foldCompact = options.foldCompact;
1007  	const bool foldComment = fold && options.foldComment;
1008  	const bool foldHeredoc = fold && options.foldHeredoc;
1009  	const bool foldXmlAtTagOpen = isXml && fold && options.foldXmlAtTagOpen;
1010  	const bool caseSensitive = options.caseSensitive;
1011  	const bool allowScripts = options.allowScripts;
1012  	const bool isMako = options.isMako;
1013  	const bool isDjango = options.isDjango;
1014  	const CharacterSet setHTMLWord(CharacterSet::setAlphaNum, ".-_:!#", true);
1015  	const CharacterSet setTagContinue(CharacterSet::setAlphaNum, ".-_:!#[", true);
1016  	const CharacterSet setAttributeContinue(CharacterSet::setAlphaNum, ".-_:!#/", true);
1017  	const CharacterSet setOKBeforeJSRE(CharacterSet::setNone, "([{=,:;!%^&*|?~");
1018  	int levelPrev = styler.LevelAt(lineCurrent) & SC_FOLDLEVELNUMBERMASK;
1019  	int levelCurrent = levelPrev;
1020  	int visibleChars = 0;
1021  	int lineStartVisibleChars = 0;
1022  	int chPrev = ' ';
1023  	int ch = ' ';
1024  	int chPrevNonWhite = ' ';
1025  	if (scriptLanguage == eScriptJS && startPos > 0) {
1026  		Sci_Position back = startPos;
1027  		int style = 0;
1028  		while (--back) {
1029  			style = styler.StyleAt(back);
1030  			if (style < SCE_HJ_DEFAULT || style > SCE_HJ_COMMENTDOC)
1031  				break;
1032  		}
1033  		if (style == SCE_HJ_SYMBOLS) {
1034  			chPrevNonWhite = static_cast<unsigned char>(styler.SafeGetCharAt(back));
1035  		}
1036  	}
1037  	styler.StartSegment(startPos);
1038  	const Sci_Position lengthDoc = startPos + length;
1039  	for (Sci_Position i = startPos; i < lengthDoc; i++) {
1040  		const int chPrev2 = chPrev;
1041  		chPrev = ch;
1042  		if (!IsASpace(ch) && state != SCE_HJ_COMMENT &&
1043  			state != SCE_HJ_COMMENTLINE && state != SCE_HJ_COMMENTDOC)
1044  			chPrevNonWhite = ch;
1045  		ch = static_cast<unsigned char>(styler[i]);
1046  		int chNext = static_cast<unsigned char>(styler.SafeGetCharAt(i + 1));
1047  		const int chNext2 = static_cast<unsigned char>(styler.SafeGetCharAt(i + 2));
1048  		if (styler.IsLeadByte(static_cast<char>(ch))) {
1049  			chPrev = ' ';
1050  			i += 1;
1051  			continue;
1052  		}
1053  		if ((!IsASpace(ch) || !foldCompact) && fold)
1054  			visibleChars++;
1055  		if (!IsASpace(ch))
1056  			lineStartVisibleChars++;
1057  		StateToPrint = statePrintForState(state, inScriptType);
1058  		if (fold) {
1059  			switch (scriptLanguage) {
1060  			case eScriptJS:
1061  			case eScriptPHP:
1062  				if (!(state == SCE_HPHP_COMMENT || state == SCE_HPHP_COMMENTLINE) &&
1063  				    !(state == SCE_HJ_REGEX || state == SCE_HJ_COMMENT || state == SCE_HJ_COMMENTLINE || state == SCE_HJ_COMMENTDOC) &&
1064  				    !isStringState(state)) {
1065  					if (ch == '#') {
1066  						Sci_Position j = i + 1;
1067  						while ((j < lengthDoc) && IsASpaceOrTab(styler.SafeGetCharAt(j))) {
1068  							j++;
1069  						}
1070  						if (styler.Match(j, "region") || styler.Match(j, "if")) {
1071  							levelCurrent++;
1072  						} else if (styler.Match(j, "end")) {
1073  							levelCurrent--;
1074  						}
1075  					} else if ((ch == '{') || (ch == '}') || (foldComment && (ch == '/') && (chNext == '*'))) {
1076  						levelCurrent += (((ch == '{') || (ch == '/')) ? 1 : -1);
1077  					}
1078  				} else if (((state == SCE_HPHP_COMMENT) || (state == SCE_HJ_COMMENT || state == SCE_HJ_COMMENTDOC)) && foldComment && (ch == '*') && (chNext == '/')) {
1079  					levelCurrent--;
1080  				}
1081  				break;
1082  			case eScriptPython:
1083  				if (state != SCE_HP_COMMENTLINE && !isMako) {
1084  					if ((ch == ':') && ((chNext == '\n') || (chNext == '\r' && chNext2 == '\n'))) {
1085  						levelCurrent++;
1086  					} else if ((ch == '\n') && !((chNext == '\r') && (chNext2 == '\n')) && (chNext != '\n')) {
1087  						int Findlevel = (levelCurrent & ~SC_FOLDLEVELBASE) * 8;
1088  						for (Sci_Position j = 0; Findlevel > 0; j++) {
1089  							const char chTmp = styler.SafeGetCharAt(i + j + 1);
1090  							if (chTmp == '\t') {
1091  								Findlevel -= 8;
1092  							} else if (chTmp == ' ') {
1093  								Findlevel--;
1094  							} else {
1095  								break;
1096  							}
1097  						}
1098  						if (Findlevel > 0) {
1099  							levelCurrent -= Findlevel / 8;
1100  							if (Findlevel % 8)
1101  								levelCurrent--;
1102  						}
1103  					}
1104  				}
1105  				break;
1106  			default:
1107  				break;
1108  			}
1109  		}
1110  		if ((ch == '\r' && chNext != '\n') || (ch == '\n')) {
1111  			if (fold) {
1112  				int lev = levelPrev;
1113  				if (visibleChars == 0)
1114  					lev |= SC_FOLDLEVELWHITEFLAG;
1115  				if ((levelCurrent > levelPrev) && (visibleChars > 0))
1116  					lev |= SC_FOLDLEVELHEADERFLAG;
1117  				styler.SetLevel(lineCurrent, lev);
1118  				visibleChars = 0;
1119  				levelPrev = levelCurrent;
1120  			}
1121  			styler.SetLineState(lineCurrent,
1122  			                    ((inScriptType & 0x03) << 0) |
1123  			                    ((tagOpened ? 1 : 0) << 2) |
1124  			                    ((tagClosing ? 1 : 0) << 3) |
1125  			                    ((aspScript & 0x0F) << 4) |
1126  			                    ((clientScript & 0x0F) << 8) |
1127  			                    ((beforePreProc & 0xFF) << 12) |
1128  			                    ((isLanguageType ? 1 : 0) << 20));
1129  			lineCurrent++;
1130  			lineStartVisibleChars = 0;
1131  		}
1132  		if (isMako && ch == '#' && chNext == '#') {
1133  			makoComment = 1;
1134  			state = SCE_HP_COMMENTLINE;
1135  		}
1136  		else if (isMako && makoComment && (ch == '\r' || ch == '\n')) {
1137  			makoComment = 0;
1138  			styler.ColourTo(i - 1, StateToPrint);
1139  			if (scriptLanguage == eScriptPython) {
1140  				state = SCE_HP_DEFAULT;
1141  			} else {
1142  				state = SCE_H_DEFAULT;
1143  			}
1144  		}
1145  		if (((ch == '\r' && chNext != '\n') || (ch == '\n')) &&
1146  			(!isMako || (makoBlockType != "%"))) {
1147  		}
1148  		else if (isMako && makoComment) {
1149  		}
1150  		else if ((inScriptType == eNonHtmlScript) && (ch == '<') && (chNext == '/')) {
1151  			switch (state) {
1152  			case SCE_H_DOUBLESTRING:
1153  			case SCE_H_SINGLESTRING:
1154  			case SCE_HJ_COMMENT:
1155  			case SCE_HJ_COMMENTDOC:
1156  			case SCE_HB_COMMENTLINE:
1157  			case SCE_HBA_COMMENTLINE:
1158  			case SCE_HJ_DOUBLESTRING:
1159  			case SCE_HJ_SINGLESTRING:
1160  			case SCE_HJ_REGEX:
1161  			case SCE_HB_STRING:
1162  			case SCE_HBA_STRING:
1163  			case SCE_HP_STRING:
1164  			case SCE_HP_TRIPLE:
1165  			case SCE_HP_TRIPLEDOUBLE:
1166  			case SCE_HPHP_HSTRING:
1167  			case SCE_HPHP_SIMPLESTRING:
1168  			case SCE_HPHP_COMMENT:
1169  			case SCE_HPHP_COMMENTLINE:
1170  				break;
1171  			default :
1172  				if (const char *tag =
1173  						state == SCE_HJ_COMMENTLINE || isXml ? "script" :
1174  						state == SCE_H_COMMENT ? "comment" : 0) {
1175  					Sci_Position j = i + 2;
1176  					int chr;
1177  					do {
1178  						chr = static_cast<int>(*tag++);
1179  					} while (chr != 0 && chr == MakeLowerCase(styler.SafeGetCharAt(j++)));
1180  					if (chr != 0) break;
1181  				}
1182  				styler.ColourTo(i - 1, StateToPrint);
1183  				state = SCE_H_TAGUNKNOWN;
1184  				inScriptType = eHtml;
1185  				scriptLanguage = eScriptNone;
1186  				clientScript = eScriptJS;
1187  				isLanguageType = false;
1188  				i += 2;
1189  				visibleChars += 2;
1190  				tagClosing = true;
1191  				if (foldXmlAtTagOpen) {
1192  					levelCurrent--;
1193  				}
1194  				continue;
1195  			}
1196  		}
1197  		else if ((state != SCE_H_ASPAT) &&
1198  		         !isPHPStringState(state) &&
1199  		         (state != SCE_HPHP_COMMENT) &&
1200  		         (state != SCE_HPHP_COMMENTLINE) &&
1201  		         (ch == '<') &&
1202  		         (chNext == '?') &&
1203  				 !IsScriptCommentState(state)) {
1204   			beforeLanguage = scriptLanguage;
1205  			scriptLanguage = segIsScriptingIndicator(styler, i + 2, i + 6, isXml ? eScriptXML : eScriptPHP);
1206  			if ((scriptLanguage != eScriptPHP) && (isStringState(state) || (state==SCE_H_COMMENT))) continue;
1207  			styler.ColourTo(i - 1, StateToPrint);
1208  			beforePreProc = state;
1209  			i++;
1210  			visibleChars++;
1211  			i += PrintScriptingIndicatorOffset(styler, styler.GetStartSegment() + 2, i + 6);
1212  			if (scriptLanguage == eScriptXML)
1213  				styler.ColourTo(i, SCE_H_XMLSTART);
1214  			else
1215  				styler.ColourTo(i, SCE_H_QUESTION);
1216  			state = StateForScript(scriptLanguage);
1217  			if (inScriptType == eNonHtmlScript)
1218  				inScriptType = eNonHtmlScriptPreProc;
1219  			else
1220  				inScriptType = eNonHtmlPreProc;
1221  			if (foldHTMLPreprocessor && (scriptLanguage != eScriptXML)) {
1222  				levelCurrent++;
1223  			}
1224  			ch = static_cast<unsigned char>(styler.SafeGetCharAt(i));
1225  			continue;
1226  		}
1227  		else if (isMako && scriptLanguage == eScriptNone && ((ch == '<' && chNext == '%') ||
1228  															 (lineStartVisibleChars == 1 && ch == '%') ||
1229  															 (lineStartVisibleChars == 1 && ch == '/' && chNext == '%') ||
1230  															 (ch == '$' && chNext == '{') ||
1231  															 (ch == '<' && chNext == '/' && chNext2 == '%'))) {
1232  			if (ch == '%' || ch == '/')
1233  				makoBlockType = "%";
1234  			else if (ch == '$')
1235  				makoBlockType = "{";
1236  			else if (chNext == '/')
1237  				makoBlockType = GetNextWord(styler, i+3);
1238  			else
1239  				makoBlockType = GetNextWord(styler, i+2);
1240  			styler.ColourTo(i - 1, StateToPrint);
1241  			beforePreProc = state;
1242  			if (inScriptType == eNonHtmlScript)
1243  				inScriptType = eNonHtmlScriptPreProc;
1244  			else
1245  				inScriptType = eNonHtmlPreProc;
1246  			if (chNext == '/') {
1247  				i += 2;
1248  				visibleChars += 2;
1249  			} else if (ch != '%') {
1250  				i++;
1251  				visibleChars++;
1252  			}
1253  			state = SCE_HP_START;
1254  			scriptLanguage = eScriptPython;
1255  			styler.ColourTo(i, SCE_H_ASP);
1256  			if (ch != '%' && ch != '$' && ch != '/') {
1257  				i += makoBlockType.length();
1258  				visibleChars += static_cast<int>(makoBlockType.length());
1259  				if (keywords4.InList(makoBlockType.c_str()))
1260  					styler.ColourTo(i, SCE_HP_WORD);
1261  				else
1262  					styler.ColourTo(i, SCE_H_TAGUNKNOWN);
1263  			}
1264  			ch = static_cast<unsigned char>(styler.SafeGetCharAt(i));
1265  			continue;
1266  		}
1267  		else if (isDjango && state != SCE_H_COMMENT && (ch == '{' && chNext == '#')) {
1268  			styler.ColourTo(i - 1, StateToPrint);
1269  			beforePreProc = state;
1270  			beforeLanguage = scriptLanguage;
1271  			if (inScriptType == eNonHtmlScript)
1272  				inScriptType = eNonHtmlScriptPreProc;
1273  			else
1274  				inScriptType = eNonHtmlPreProc;
1275  			i += 1;
1276  			visibleChars += 1;
1277  			scriptLanguage = eScriptComment;
1278  			state = SCE_H_COMMENT;
1279  			styler.ColourTo(i, SCE_H_ASP);
1280  			ch = static_cast<unsigned char>(styler.SafeGetCharAt(i));
1281  			continue;
1282  		} else if (isDjango && state == SCE_H_COMMENT && (ch == '#' && chNext == '}')) {
1283  			styler.ColourTo(i - 1, StateToPrint);
1284  			i += 1;
1285  			visibleChars += 1;
1286  			styler.ColourTo(i, SCE_H_ASP);
1287  			state = beforePreProc;
1288  			if (inScriptType == eNonHtmlScriptPreProc)
1289  				inScriptType = eNonHtmlScript;
1290  			else
1291  				inScriptType = eHtml;
1292  			scriptLanguage = beforeLanguage;
1293  			continue;
1294  		}
1295  		else if (isDjango && scriptLanguage != eScriptPython && scriptLanguage != eScriptComment && (ch == '{' && (chNext == '%' ||  chNext == '{'))) {
1296  			if (chNext == '%')
1297  				djangoBlockType = "%";
1298  			else
1299  				djangoBlockType = "{";
1300  			styler.ColourTo(i - 1, StateToPrint);
1301  			beforePreProc = state;
1302  			if (inScriptType == eNonHtmlScript)
1303  				inScriptType = eNonHtmlScriptPreProc;
1304  			else
1305  				inScriptType = eNonHtmlPreProc;
1306  			i += 1;
1307  			visibleChars += 1;
1308  			state = SCE_HP_START;
1309  			beforeLanguage = scriptLanguage;
1310  			scriptLanguage = eScriptPython;
1311  			styler.ColourTo(i, SCE_H_ASP);
1312  			ch = static_cast<unsigned char>(styler.SafeGetCharAt(i));
1313  			continue;
1314  		}
1315  		else if (!isMako && !isDjango && !isCommentASPState(state) && (ch == '<') && (chNext == '%') && !isPHPStringState(state)) {
1316  			styler.ColourTo(i - 1, StateToPrint);
1317  			beforePreProc = state;
1318  			if (inScriptType == eNonHtmlScript)
1319  				inScriptType = eNonHtmlScriptPreProc;
1320  			else
1321  				inScriptType = eNonHtmlPreProc;
1322  			if (chNext2 == '@') {
1323  				i += 2; 
1324  				visibleChars += 2;
1325  				state = SCE_H_ASPAT;
1326  				scriptLanguage = eScriptVBS;
1327  			} else if ((chNext2 == '-') && (styler.SafeGetCharAt(i + 3) == '-')) {
1328  				styler.ColourTo(i + 3, SCE_H_ASP);
1329  				state = SCE_H_XCCOMMENT;
1330  				scriptLanguage = eScriptVBS;
1331  				continue;
1332  			} else {
1333  				if (chNext2 == '=') {
1334  					i += 2; 
1335  					visibleChars += 2;
1336  				} else {
1337  					i++; 
1338  					visibleChars++;
1339  				}
1340  				state = StateForScript(aspScript);
1341  				scriptLanguage = aspScript;
1342  			}
1343  			styler.ColourTo(i, SCE_H_ASP);
1344  			if (foldHTMLPreprocessor)
1345  				levelCurrent++;
1346  			ch = static_cast<unsigned char>(styler.SafeGetCharAt(i));
1347  			continue;
1348  		}
1349  		else if (((scriptLanguage == eScriptNone) || (scriptLanguage == eScriptXML)) &&
1350  				 (chPrev == '<') &&
1351  				 (ch == '!') &&
1352  				 (StateToPrint != SCE_H_CDATA) &&
1353  				 (!isStringState(StateToPrint)) &&
1354  				 (!IsCommentState(StateToPrint)) &&
1355  				 (!IsScriptCommentState(StateToPrint))) {
1356  			beforePreProc = state;
1357  			styler.ColourTo(i - 2, StateToPrint);
1358  			if ((chNext == '-') && (chNext2 == '-')) {
1359  				state = SCE_H_COMMENT; 
1360  				styler.ColourTo(i + 2, SCE_H_COMMENT);
1361  				i += 2; 
1362  			} else if (isWordCdata(i + 1, i + 7, styler)) {
1363  				state = SCE_H_CDATA;
1364  			} else {
1365  				styler.ColourTo(i, SCE_H_SGML_DEFAULT); 
1366  				scriptLanguage = eScriptSGML;
1367  				state = SCE_H_SGML_COMMAND; 
1368  			}
1369  			if (foldHTMLPreprocessor || state == SCE_H_COMMENT || state == SCE_H_CDATA)
1370  				levelCurrent++;
1371  			continue;
1372  		}
1373  		else if (isMako &&
1374  			     ((inScriptType == eNonHtmlPreProc) || (inScriptType == eNonHtmlScriptPreProc)) &&
1375  				 (scriptLanguage != eScriptNone) && stateAllowsTermination(state) &&
1376  				 isMakoBlockEnd(ch, chNext, makoBlockType)) {
1377  			if (state == SCE_H_ASPAT) {
1378  				aspScript = segIsScriptingIndicator(styler,
1379  				                                    styler.GetStartSegment(), i - 1, aspScript);
1380  			}
1381  			if (state == SCE_HP_WORD) {
1382  				classifyWordHTPy(styler.GetStartSegment(), i - 1, keywords4, styler, prevWord, inScriptType, isMako);
1383  			} else {
1384  				styler.ColourTo(i - 1, StateToPrint);
1385  			}
1386  			if ((makoBlockType != "%") && (makoBlockType != "{") && ch != '>') {
1387  				i++;
1388  				visibleChars++;
1389  		    }
1390  			else if ((makoBlockType == "%") && ch == '/') {
1391  				i++;
1392  				visibleChars++;
1393  			}
1394  			if ((makoBlockType != "%") || ch == '/') {
1395  				styler.ColourTo(i, SCE_H_ASP);
1396  			}
1397  			state = beforePreProc;
1398  			if (inScriptType == eNonHtmlScriptPreProc)
1399  				inScriptType = eNonHtmlScript;
1400  			else
1401  				inScriptType = eHtml;
1402  			scriptLanguage = eScriptNone;
1403  			continue;
1404  		}
1405  		else if (isDjango &&
1406  			     ((inScriptType == eNonHtmlPreProc) || (inScriptType == eNonHtmlScriptPreProc)) &&
1407  				 (scriptLanguage != eScriptNone) && stateAllowsTermination(state) &&
1408  				 isDjangoBlockEnd(ch, chNext, djangoBlockType)) {
1409  			if (state == SCE_H_ASPAT) {
1410  				aspScript = segIsScriptingIndicator(styler,
1411  				                                    styler.GetStartSegment(), i - 1, aspScript);
1412  			}
1413  			if (state == SCE_HP_WORD) {
1414  				classifyWordHTPy(styler.GetStartSegment(), i - 1, keywords4, styler, prevWord, inScriptType, isMako);
1415  			} else {
1416  				styler.ColourTo(i - 1, StateToPrint);
1417  			}
1418  			i += 1;
1419  			visibleChars += 1;
1420  			styler.ColourTo(i, SCE_H_ASP);
1421  			state = beforePreProc;
1422  			if (inScriptType == eNonHtmlScriptPreProc)
1423  				inScriptType = eNonHtmlScript;
1424  			else
1425  				inScriptType = eHtml;
1426  			scriptLanguage = beforeLanguage;
1427  			continue;
1428  		}
1429  		else if ((!isMako && !isDjango && ((inScriptType == eNonHtmlPreProc) || (inScriptType == eNonHtmlScriptPreProc)) &&
1430  				  (((scriptLanguage != eScriptNone) && stateAllowsTermination(state))) &&
1431  				  (((ch == '%') || (ch == '?')) && (chNext == '>'))) ||
1432  		         ((scriptLanguage == eScriptSGML) && (ch == '>') && (state != SCE_H_SGML_COMMENT))) {
1433  			if (state == SCE_H_ASPAT) {
1434  				aspScript = segIsScriptingIndicator(styler,
1435  				                                    styler.GetStartSegment(), i - 1, aspScript);
1436  			}
1437  			switch (state) {
1438  			case SCE_HJ_WORD:
1439  				classifyWordHTJS(styler.GetStartSegment(), i - 1, keywords2, styler, inScriptType);
1440  				break;
1441  			case SCE_HB_WORD:
1442  				classifyWordHTVB(styler.GetStartSegment(), i - 1, keywords3, styler, inScriptType);
1443  				break;
1444  			case SCE_HP_WORD:
1445  				classifyWordHTPy(styler.GetStartSegment(), i - 1, keywords4, styler, prevWord, inScriptType, isMako);
1446  				break;
1447  			case SCE_HPHP_WORD:
1448  				classifyWordHTPHP(styler.GetStartSegment(), i - 1, keywords5, styler);
1449  				break;
1450  			case SCE_H_XCCOMMENT:
1451  				styler.ColourTo(i - 1, state);
1452  				break;
1453  			default :
1454  				styler.ColourTo(i - 1, StateToPrint);
1455  				break;
1456  			}
1457  			if (scriptLanguage != eScriptSGML) {
1458  				i++;
1459  				visibleChars++;
1460  			}
1461  			if (ch == '%')
<span onclick='openModal()' class='match'>1462  				styler.ColourTo(i, SCE_H_ASP);
1463  			else if (scriptLanguage == eScriptXML)
1464  				styler.ColourTo(i, SCE_H_XMLEND);
1465  			else if (scriptLanguage == eScriptSGML)
</span>1466  				styler.ColourTo(i, SCE_H_SGML_DEFAULT);
1467  			else
1468  				styler.ColourTo(i, SCE_H_QUESTION);
1469  			state = beforePreProc;
1470  			if (inScriptType == eNonHtmlScriptPreProc)
1471  				inScriptType = eNonHtmlScript;
1472  			else
1473  				inScriptType = eHtml;
1474  			if (foldHTMLPreprocessor && (scriptLanguage != eScriptXML)) {
1475  				levelCurrent--;
1476  			}
1477  			scriptLanguage = beforeLanguage;
1478  			continue;
1479  		}
1480  		switch (state) {
1481  		case SCE_H_DEFAULT:
1482  			if (ch == '<') {
1483  				tagOpened = true;
1484  				tagClosing = (chNext == '/');
1485  				if (foldXmlAtTagOpen && !(chNext == '/' || chNext == '?' || chNext == '!' || chNext == '-' || chNext == '%')) {
1486  					levelCurrent++;
1487  				}
1488  				if (foldXmlAtTagOpen && chNext == '/') {
1489  					levelCurrent--;
1490  				}
1491  				styler.ColourTo(i - 1, StateToPrint);
1492  				if (chNext != '!')
1493  					state = SCE_H_TAGUNKNOWN;
1494  			} else if (ch == '&') {
1495  				styler.ColourTo(i - 1, SCE_H_DEFAULT);
1496  				state = SCE_H_ENTITY;
1497  			}
1498  			break;
1499  		case SCE_H_SGML_DEFAULT:
1500  		case SCE_H_SGML_BLOCK_DEFAULT:
1501  			if (ch == '\"') {
1502  				styler.ColourTo(i - 1, StateToPrint);
1503  				state = SCE_H_SGML_DOUBLESTRING;
1504  			} else if (ch == '\'') {
1505  				styler.ColourTo(i - 1, StateToPrint);
1506  				state = SCE_H_SGML_SIMPLESTRING;
1507  			} else if ((ch == '-') && (chPrev == '-')) {
1508  				if (static_cast<Sci_Position>(styler.GetStartSegment()) <= (i - 2)) {
1509  					styler.ColourTo(i - 2, StateToPrint);
1510  				}
1511  				state = SCE_H_SGML_COMMENT;
1512  			} else if (IsASCII(ch) && isalpha(ch) && (chPrev == '%')) {
1513  				styler.ColourTo(i - 2, StateToPrint);
1514  				state = SCE_H_SGML_ENTITY;
1515  			} else if (ch == '#') {
1516  				styler.ColourTo(i - 1, StateToPrint);
1517  				state = SCE_H_SGML_SPECIAL;
1518  			} else if (ch == '[') {
1519  				styler.ColourTo(i - 1, StateToPrint);
1520  				scriptLanguage = eScriptSGMLblock;
1521  				state = SCE_H_SGML_BLOCK_DEFAULT;
1522  			} else if (ch == ']') {
1523  				if (scriptLanguage == eScriptSGMLblock) {
1524  					styler.ColourTo(i, StateToPrint);
1525  					scriptLanguage = eScriptSGML;
1526  				} else {
1527  					styler.ColourTo(i - 1, StateToPrint);
1528  					styler.ColourTo(i, SCE_H_SGML_ERROR);
1529  				}
1530  				state = SCE_H_SGML_DEFAULT;
1531  			} else if (scriptLanguage == eScriptSGMLblock) {
1532  				if ((ch == '!') && (chPrev == '<')) {
1533  					styler.ColourTo(i - 2, StateToPrint);
1534  					styler.ColourTo(i, SCE_H_SGML_DEFAULT);
1535  					state = SCE_H_SGML_COMMAND;
1536  				} else if (ch == '>') {
1537  					styler.ColourTo(i - 1, StateToPrint);
1538  					styler.ColourTo(i, SCE_H_SGML_DEFAULT);
1539  				}
1540  			}
1541  			break;
1542  		case SCE_H_SGML_COMMAND:
1543  			if ((ch == '-') && (chPrev == '-')) {
1544  				styler.ColourTo(i - 2, StateToPrint);
1545  				state = SCE_H_SGML_COMMENT;
1546  			} else if (!issgmlwordchar(ch)) {
1547  				if (isWordHSGML(styler.GetStartSegment(), i - 1, keywords6, styler)) {
1548  					styler.ColourTo(i - 1, StateToPrint);
1549  					state = SCE_H_SGML_1ST_PARAM;
1550  				} else {
1551  					state = SCE_H_SGML_ERROR;
1552  				}
1553  			}
1554  			break;
1555  		case SCE_H_SGML_1ST_PARAM:
1556  			if ((ch == '-') && (chPrev == '-')) {
1557  				if (scriptLanguage == eScriptSGMLblock) {
1558  					styler.ColourTo(i - 2, SCE_H_SGML_BLOCK_DEFAULT);
1559  				} else {
1560  					styler.ColourTo(i - 2, SCE_H_SGML_DEFAULT);
1561  				}
1562  				state = SCE_H_SGML_1ST_PARAM_COMMENT;
1563  			} else if (issgmlwordchar(ch)) {
1564  				if (scriptLanguage == eScriptSGMLblock) {
1565  					styler.ColourTo(i - 1, SCE_H_SGML_BLOCK_DEFAULT);
1566  				} else {
1567  					styler.ColourTo(i - 1, SCE_H_SGML_DEFAULT);
1568  				}
1569  				int size = 1;
1570  				while (setHTMLWord.Contains(static_cast<unsigned char>(styler.SafeGetCharAt(i + size))))
1571  					size++;
1572  				styler.ColourTo(i + size - 1, StateToPrint);
1573  				i += size - 1;
1574  				visibleChars += size - 1;
1575  				ch = static_cast<unsigned char>(styler.SafeGetCharAt(i));
1576  				if (scriptLanguage == eScriptSGMLblock) {
1577  					state = SCE_H_SGML_BLOCK_DEFAULT;
1578  				} else {
1579  					state = SCE_H_SGML_DEFAULT;
1580  				}
1581  				continue;
1582  			}
1583  			break;
1584  		case SCE_H_SGML_ERROR:
1585  			if ((ch == '-') && (chPrev == '-')) {
1586  				styler.ColourTo(i - 2, StateToPrint);
1587  				state = SCE_H_SGML_COMMENT;
1588  			}
1589  			break;
1590  		case SCE_H_SGML_DOUBLESTRING:
1591  			if (ch == '\"') {
1592  				styler.ColourTo(i, StateToPrint);
1593  				state = SCE_H_SGML_DEFAULT;
1594  			}
1595  			break;
1596  		case SCE_H_SGML_SIMPLESTRING:
1597  			if (ch == '\'') {
1598  				styler.ColourTo(i, StateToPrint);
1599  				state = SCE_H_SGML_DEFAULT;
1600  			}
1601  			break;
1602  		case SCE_H_SGML_COMMENT:
1603  			if ((ch == '-') && (chPrev == '-')) {
1604  				styler.ColourTo(i, StateToPrint);
1605  				state = SCE_H_SGML_DEFAULT;
1606  			}
1607  			break;
1608  		case SCE_H_CDATA:
1609  			if ((chPrev2 == ']') && (chPrev == ']') && (ch == '>')) {
1610  				styler.ColourTo(i, StateToPrint);
1611  				state = SCE_H_DEFAULT;
1612  				levelCurrent--;
1613  			}
1614  			break;
1615  		case SCE_H_COMMENT:
1616  			if ((scriptLanguage != eScriptComment) && (chPrev2 == '-') && (chPrev == '-') && (ch == '>')) {
1617  				styler.ColourTo(i, StateToPrint);
1618  				state = SCE_H_DEFAULT;
1619  				levelCurrent--;
1620  			}
1621  			break;
1622  		case SCE_H_SGML_1ST_PARAM_COMMENT:
1623  			if ((ch == '-') && (chPrev == '-')) {
1624  				styler.ColourTo(i, SCE_H_SGML_COMMENT);
1625  				state = SCE_H_SGML_1ST_PARAM;
1626  			}
1627  			break;
1628  		case SCE_H_SGML_SPECIAL:
1629  			if (!(IsASCII(ch) && isupper(ch))) {
1630  				styler.ColourTo(i - 1, StateToPrint);
1631  				if (isalnum(ch)) {
1632  					state = SCE_H_SGML_ERROR;
1633  				} else {
1634  					state = SCE_H_SGML_DEFAULT;
1635  				}
1636  			}
1637  			break;
1638  		case SCE_H_SGML_ENTITY:
1639  			if (ch == ';') {
1640  				styler.ColourTo(i, StateToPrint);
1641  				state = SCE_H_SGML_DEFAULT;
1642  			} else if (!(IsASCII(ch) && isalnum(ch)) && ch != '-' && ch != '.') {
1643  				styler.ColourTo(i, SCE_H_SGML_ERROR);
1644  				state = SCE_H_SGML_DEFAULT;
1645  			}
1646  			break;
1647  		case SCE_H_ENTITY:
1648  			if (ch == ';') {
1649  				styler.ColourTo(i, StateToPrint);
1650  				state = SCE_H_DEFAULT;
1651  			}
1652  			if (ch != '#' && !(IsASCII(ch) && isalnum(ch))	
1653  				&& ch != '.' && ch != '-' && ch != '_' && ch != ':') { 
1654  				if (!IsASCII(ch))	
1655  					styler.ColourTo(i-1, SCE_H_TAGUNKNOWN);
1656  				else
1657  					styler.ColourTo(i, SCE_H_TAGUNKNOWN);
1658  				state = SCE_H_DEFAULT;
1659  			}
1660  			break;
1661  		case SCE_H_TAGUNKNOWN:
1662  			if (!setTagContinue.Contains(ch) && !((ch == '/') && (chPrev == '<'))) {
1663  				int eClass = classifyTagHTML(styler.GetStartSegment(),
1664  					i - 1, keywords, styler, tagDontFold, caseSensitive, isXml, allowScripts, nonFoldingTags);
1665  				if (eClass == SCE_H_SCRIPT || eClass == SCE_H_COMMENT) {
1666  					if (!tagClosing) {
1667  						inScriptType = eNonHtmlScript;
1668  						scriptLanguage = eClass == SCE_H_SCRIPT ? clientScript : eScriptComment;
1669  					} else {
1670  						scriptLanguage = eScriptNone;
1671  					}
1672  					isLanguageType = false;
1673  					eClass = SCE_H_TAG;
1674  				}
1675  				if (ch == '>') {
1676  					styler.ColourTo(i, eClass);
1677  					if (inScriptType == eNonHtmlScript) {
1678  						state = StateForScript(scriptLanguage);
1679  					} else {
1680  						state = SCE_H_DEFAULT;
1681  					}
1682  					tagOpened = false;
1683  					if (!(foldXmlAtTagOpen || tagDontFold)) {
1684  						if (tagClosing) {
1685  							levelCurrent--;
1686  						} else {
1687  							levelCurrent++;
1688  						}
1689  					}
1690  					tagClosing = false;
1691  				} else if (ch == '/' && chNext == '>') {
1692  					if (eClass == SCE_H_TAGUNKNOWN) {
1693  						styler.ColourTo(i + 1, SCE_H_TAGUNKNOWN);
1694  					} else {
1695  						styler.ColourTo(i - 1, StateToPrint);
1696  						styler.ColourTo(i + 1, SCE_H_TAGEND);
1697  					}
1698  					i++;
1699  					ch = chNext;
1700  					state = SCE_H_DEFAULT;
1701  					tagOpened = false;
1702  					if (foldXmlAtTagOpen) {
1703  						levelCurrent--;
1704  					}
1705  				} else {
1706  					if (eClass != SCE_H_TAGUNKNOWN) {
1707  						if (eClass == SCE_H_SGML_DEFAULT) {
1708  							state = SCE_H_SGML_DEFAULT;
1709  						} else {
1710  							state = SCE_H_OTHER;
1711  						}
1712  					}
1713  				}
1714  			}
1715  			break;
1716  		case SCE_H_ATTRIBUTE:
1717  			if (!setAttributeContinue.Contains(ch)) {
1718  				isLanguageType = classifyAttribHTML(inScriptType, styler.GetStartSegment(), i - 1, keywords, styler);
1719  				if (ch == '>') {
1720  					styler.ColourTo(i, SCE_H_TAG);
1721  					if (inScriptType == eNonHtmlScript) {
1722  						state = StateForScript(scriptLanguage);
1723  					} else {
1724  						state = SCE_H_DEFAULT;
1725  					}
1726  					tagOpened = false;
1727  					if (!(foldXmlAtTagOpen || tagDontFold)) {
1728  						if (tagClosing) {
1729  							levelCurrent--;
1730  						} else {
1731  							levelCurrent++;
1732  						}
1733  					}
1734  					tagClosing = false;
1735  				} else if (ch == '=') {
1736  					styler.ColourTo(i, SCE_H_OTHER);
1737  					state = SCE_H_VALUE;
1738  				} else {
1739  					state = SCE_H_OTHER;
1740  				}
1741  			}
1742  			break;
1743  		case SCE_H_OTHER:
1744  			if (ch == '>') {
1745  				styler.ColourTo(i - 1, StateToPrint);
1746  				styler.ColourTo(i, SCE_H_TAG);
1747  				if (inScriptType == eNonHtmlScript) {
1748  					state = StateForScript(scriptLanguage);
1749  				} else {
1750  					state = SCE_H_DEFAULT;
1751  				}
1752  				tagOpened = false;
1753  				if (!(foldXmlAtTagOpen || tagDontFold)) {
1754  					if (tagClosing) {
1755  						levelCurrent--;
1756  					} else {
1757  						levelCurrent++;
1758  					}
1759  				}
1760  				tagClosing = false;
1761  			} else if (ch == '\"') {
1762  				styler.ColourTo(i - 1, StateToPrint);
1763  				state = SCE_H_DOUBLESTRING;
1764  			} else if (ch == '\'') {
1765  				styler.ColourTo(i - 1, StateToPrint);
1766  				state = SCE_H_SINGLESTRING;
1767  			} else if (ch == '=') {
1768  				styler.ColourTo(i, StateToPrint);
1769  				state = SCE_H_VALUE;
1770  			} else if (ch == '/' && chNext == '>') {
1771  				styler.ColourTo(i - 1, StateToPrint);
1772  				styler.ColourTo(i + 1, SCE_H_TAGEND);
1773  				i++;
1774  				ch = chNext;
1775  				state = SCE_H_DEFAULT;
1776  				tagOpened = false;
1777  				if (foldXmlAtTagOpen) {
1778  					levelCurrent--;
1779  				}
1780  			} else if (ch == '?' && chNext == '>') {
1781  				styler.ColourTo(i - 1, StateToPrint);
1782  				styler.ColourTo(i + 1, SCE_H_XMLEND);
1783  				i++;
1784  				ch = chNext;
1785  				state = SCE_H_DEFAULT;
1786  			} else if (setHTMLWord.Contains(ch)) {
1787  				styler.ColourTo(i - 1, StateToPrint);
1788  				state = SCE_H_ATTRIBUTE;
1789  			}
1790  			break;
1791  		case SCE_H_DOUBLESTRING:
1792  			if (ch == '\"') {
1793  				if (isLanguageType) {
1794  					scriptLanguage = segIsScriptingIndicator(styler, styler.GetStartSegment(), i, scriptLanguage);
1795  					clientScript = scriptLanguage;
1796  					isLanguageType = false;
1797  				}
1798  				styler.ColourTo(i, SCE_H_DOUBLESTRING);
1799  				state = SCE_H_OTHER;
1800  			}
1801  			break;
1802  		case SCE_H_SINGLESTRING:
1803  			if (ch == '\'') {
1804  				if (isLanguageType) {
1805  					scriptLanguage = segIsScriptingIndicator(styler, styler.GetStartSegment(), i, scriptLanguage);
1806  					clientScript = scriptLanguage;
1807  					isLanguageType = false;
1808  				}
1809  				styler.ColourTo(i, SCE_H_SINGLESTRING);
1810  				state = SCE_H_OTHER;
1811  			}
1812  			break;
1813  		case SCE_H_VALUE:
1814  			if (!setHTMLWord.Contains(ch)) {
1815  				if (ch == '\"' && chPrev == '=') {
1816  					state = SCE_H_DOUBLESTRING;
1817  				} else if (ch == '\'' && chPrev == '=') {
1818  					state = SCE_H_SINGLESTRING;
1819  				} else {
1820  					if (IsNumberChar(styler[styler.GetStartSegment()])) {
1821  						styler.ColourTo(i - 1, SCE_H_NUMBER);
1822  					} else {
1823  						styler.ColourTo(i - 1, StateToPrint);
1824  					}
1825  					if (ch == '>') {
1826  						styler.ColourTo(i, SCE_H_TAG);
1827  						if (inScriptType == eNonHtmlScript) {
1828  							state = StateForScript(scriptLanguage);
1829  						} else {
1830  							state = SCE_H_DEFAULT;
1831  						}
1832  						tagOpened = false;
1833  						if (!tagDontFold) {
1834  							if (tagClosing) {
1835  								levelCurrent--;
1836  							} else {
1837  								levelCurrent++;
1838  							}
1839  						}
1840  						tagClosing = false;
1841  					} else {
1842  						state = SCE_H_OTHER;
1843  					}
1844  				}
1845  			}
1846  			break;
1847  		case SCE_HJ_DEFAULT:
1848  		case SCE_HJ_START:
1849  		case SCE_HJ_SYMBOLS:
1850  			if (IsAWordStart(ch)) {
1851  				styler.ColourTo(i - 1, StateToPrint);
1852  				state = SCE_HJ_WORD;
1853  			} else if (ch == '/' && chNext == '*') {
1854  				styler.ColourTo(i - 1, StateToPrint);
1855  				if (chNext2 == '*')
1856  					state = SCE_HJ_COMMENTDOC;
1857  				else
1858  					state = SCE_HJ_COMMENT;
1859  				if (chNext2 == '/') {
1860  					i++;
1861  				}
1862  			} else if (ch == '/' && chNext == '/') {
1863  				styler.ColourTo(i - 1, StateToPrint);
1864  				state = SCE_HJ_COMMENTLINE;
1865  			} else if (ch == '/' && setOKBeforeJSRE.Contains(chPrevNonWhite)) {
1866  				styler.ColourTo(i - 1, StateToPrint);
1867  				state = SCE_HJ_REGEX;
1868  			} else if (ch == '\"') {
1869  				styler.ColourTo(i - 1, StateToPrint);
1870  				state = SCE_HJ_DOUBLESTRING;
1871  			} else if (ch == '\'') {
1872  				styler.ColourTo(i - 1, StateToPrint);
1873  				state = SCE_HJ_SINGLESTRING;
1874  			} else if ((ch == '<') && (chNext == '!') && (chNext2 == '-') &&
1875  			           styler.SafeGetCharAt(i + 3) == '-') {
1876  				styler.ColourTo(i - 1, StateToPrint);
1877  				state = SCE_HJ_COMMENTLINE;
1878  			} else if ((ch == '-') && (chNext == '-') && (chNext2 == '>')) {
1879  				styler.ColourTo(i - 1, StateToPrint);
1880  				state = SCE_HJ_COMMENTLINE;
1881  				i += 2;
1882  			} else if (IsOperator(ch)) {
1883  				styler.ColourTo(i - 1, StateToPrint);
1884  				styler.ColourTo(i, statePrintForState(SCE_HJ_SYMBOLS, inScriptType));
1885  				state = SCE_HJ_DEFAULT;
1886  			} else if ((ch == ' ') || (ch == '\t')) {
1887  				if (state == SCE_HJ_START) {
1888  					styler.ColourTo(i - 1, StateToPrint);
1889  					state = SCE_HJ_DEFAULT;
1890  				}
1891  			}
1892  			break;
1893  		case SCE_HJ_WORD:
1894  			if (!IsAWordChar(ch)) {
1895  				classifyWordHTJS(styler.GetStartSegment(), i - 1, keywords2, styler, inScriptType);
1896  				state = SCE_HJ_DEFAULT;
1897  				if (ch == '/' && chNext == '*') {
1898  					if (chNext2 == '*')
1899  						state = SCE_HJ_COMMENTDOC;
1900  					else
1901  						state = SCE_HJ_COMMENT;
1902  				} else if (ch == '/' && chNext == '/') {
1903  					state = SCE_HJ_COMMENTLINE;
1904  				} else if (ch == '\"') {
1905  					state = SCE_HJ_DOUBLESTRING;
1906  				} else if (ch == '\'') {
1907  					state = SCE_HJ_SINGLESTRING;
1908  				} else if ((ch == '-') && (chNext == '-') && (chNext2 == '>')) {
1909  					styler.ColourTo(i - 1, StateToPrint);
1910  					state = SCE_HJ_COMMENTLINE;
1911  					i += 2;
1912  				} else if (IsOperator(ch)) {
1913  					styler.ColourTo(i, statePrintForState(SCE_HJ_SYMBOLS, inScriptType));
1914  					state = SCE_HJ_DEFAULT;
1915  				}
1916  			}
1917  			break;
1918  		case SCE_HJ_COMMENT:
1919  		case SCE_HJ_COMMENTDOC:
1920  			if (ch == '/' && chPrev == '*') {
1921  				styler.ColourTo(i, StateToPrint);
1922  				state = SCE_HJ_DEFAULT;
1923  				ch = ' ';
1924  			}
1925  			break;
1926  		case SCE_HJ_COMMENTLINE:
1927  			if (ch == '\r' || ch == '\n') {
1928  				styler.ColourTo(i - 1, statePrintForState(SCE_HJ_COMMENTLINE, inScriptType));
1929  				state = SCE_HJ_DEFAULT;
1930  				ch = ' ';
1931  			}
1932  			break;
1933  		case SCE_HJ_DOUBLESTRING:
1934  			if (ch == '\\') {
1935  				if (chNext == '\"' || chNext == '\'' || chNext == '\\') {
1936  					i++;
1937  				}
1938  			} else if (ch == '\"') {
1939  				styler.ColourTo(i, statePrintForState(SCE_HJ_DOUBLESTRING, inScriptType));
1940  				state = SCE_HJ_DEFAULT;
1941  			} else if (isLineEnd(ch)) {
1942  				styler.ColourTo(i - 1, StateToPrint);
1943  				state = SCE_HJ_STRINGEOL;
1944  			}
1945  			break;
1946  		case SCE_HJ_SINGLESTRING:
1947  			if (ch == '\\') {
1948  				if (chNext == '\"' || chNext == '\'' || chNext == '\\') {
1949  					i++;
1950  				}
1951  			} else if (ch == '\'') {
1952  				styler.ColourTo(i, statePrintForState(SCE_HJ_SINGLESTRING, inScriptType));
1953  				state = SCE_HJ_DEFAULT;
1954  			} else if (isLineEnd(ch)) {
1955  				styler.ColourTo(i - 1, StateToPrint);
1956  				if (chPrev != '\\' && (chPrev2 != '\\' || chPrev != '\r' || ch != '\n')) {
1957  					state = SCE_HJ_STRINGEOL;
1958  				}
1959  			}
1960  			break;
1961  		case SCE_HJ_STRINGEOL:
1962  			if (!isLineEnd(ch)) {
1963  				styler.ColourTo(i - 1, StateToPrint);
1964  				state = SCE_HJ_DEFAULT;
1965  			} else if (!isLineEnd(chNext)) {
1966  				styler.ColourTo(i, StateToPrint);
1967  				state = SCE_HJ_DEFAULT;
1968  			}
1969  			break;
1970  		case SCE_HJ_REGEX:
1971  			if (ch == '\r' || ch == '\n' || ch == '/') {
1972  				if (ch == '/') {
1973  					while (IsASCII(chNext) && islower(chNext)) {   
1974  						i++;
1975  						ch = chNext;
1976  						chNext = static_cast<unsigned char>(styler.SafeGetCharAt(i + 1));
1977  					}
1978  				}
1979  				styler.ColourTo(i, StateToPrint);
1980  				state = SCE_HJ_DEFAULT;
1981  			} else if (ch == '\\') {
1982  				if (chNext == '\\' || chNext == '/') {
1983  					i++;
1984  					ch = chNext;
1985  					chNext = static_cast<unsigned char>(styler.SafeGetCharAt(i + 1));
1986  				}
1987  			}
1988  			break;
1989  		case SCE_HB_DEFAULT:
1990  		case SCE_HB_START:
1991  			if (IsAWordStart(ch)) {
1992  				styler.ColourTo(i - 1, StateToPrint);
1993  				state = SCE_HB_WORD;
1994  			} else if (ch == '\'') {
1995  				styler.ColourTo(i - 1, StateToPrint);
1996  				state = SCE_HB_COMMENTLINE;
1997  			} else if (ch == '\"') {
1998  				styler.ColourTo(i - 1, StateToPrint);
1999  				state = SCE_HB_STRING;
2000  			} else if ((ch == '<') && (chNext == '!') && (chNext2 == '-') &&
2001  			           styler.SafeGetCharAt(i + 3) == '-') {
2002  				styler.ColourTo(i - 1, StateToPrint);
2003  				state = SCE_HB_COMMENTLINE;
2004  			} else if (IsOperator(ch)) {
2005  				styler.ColourTo(i - 1, StateToPrint);
2006  				styler.ColourTo(i, statePrintForState(SCE_HB_DEFAULT, inScriptType));
2007  				state = SCE_HB_DEFAULT;
2008  			} else if ((ch == ' ') || (ch == '\t')) {
2009  				if (state == SCE_HB_START) {
2010  					styler.ColourTo(i - 1, StateToPrint);
2011  					state = SCE_HB_DEFAULT;
2012  				}
2013  			}
2014  			break;
2015  		case SCE_HB_WORD:
2016  			if (!IsAWordChar(ch)) {
2017  				state = classifyWordHTVB(styler.GetStartSegment(), i - 1, keywords3, styler, inScriptType);
2018  				if (state == SCE_HB_DEFAULT) {
2019  					if (ch == '\"') {
2020  						state = SCE_HB_STRING;
2021  					} else if (ch == '\'') {
2022  						state = SCE_HB_COMMENTLINE;
2023  					} else if (IsOperator(ch)) {
2024  						styler.ColourTo(i, statePrintForState(SCE_HB_DEFAULT, inScriptType));
2025  						state = SCE_HB_DEFAULT;
2026  					}
2027  				}
2028  			}
2029  			break;
2030  		case SCE_HB_STRING:
2031  			if (ch == '\"') {
2032  				styler.ColourTo(i, StateToPrint);
2033  				state = SCE_HB_DEFAULT;
2034  			} else if (ch == '\r' || ch == '\n') {
2035  				styler.ColourTo(i - 1, StateToPrint);
2036  				state = SCE_HB_STRINGEOL;
2037  			}
2038  			break;
2039  		case SCE_HB_COMMENTLINE:
2040  			if (ch == '\r' || ch == '\n') {
2041  				styler.ColourTo(i - 1, StateToPrint);
2042  				state = SCE_HB_DEFAULT;
2043  			}
2044  			break;
2045  		case SCE_HB_STRINGEOL:
2046  			if (!isLineEnd(ch)) {
2047  				styler.ColourTo(i - 1, StateToPrint);
2048  				state = SCE_HB_DEFAULT;
2049  			} else if (!isLineEnd(chNext)) {
2050  				styler.ColourTo(i, StateToPrint);
2051  				state = SCE_HB_DEFAULT;
2052  			}
2053  			break;
2054  		case SCE_HP_DEFAULT:
2055  		case SCE_HP_START:
2056  			if (IsAWordStart(ch)) {
2057  				styler.ColourTo(i - 1, StateToPrint);
2058  				state = SCE_HP_WORD;
2059  			} else if ((ch == '<') && (chNext == '!') && (chNext2 == '-') &&
2060  			           styler.SafeGetCharAt(i + 3) == '-') {
2061  				styler.ColourTo(i - 1, StateToPrint);
2062  				state = SCE_HP_COMMENTLINE;
2063  			} else if (ch == '#') {
2064  				styler.ColourTo(i - 1, StateToPrint);
2065  				state = SCE_HP_COMMENTLINE;
2066  			} else if (ch == '\"') {
2067  				styler.ColourTo(i - 1, StateToPrint);
2068  				if (chNext == '\"' && chNext2 == '\"') {
2069  					i += 2;
2070  					state = SCE_HP_TRIPLEDOUBLE;
2071  					ch = ' ';
2072  					chPrev = ' ';
2073  					chNext = static_cast<unsigned char>(styler.SafeGetCharAt(i + 1));
2074  				} else {
2075  					state = SCE_HP_STRING;
2076  				}
2077  			} else if (ch == '\'') {
2078  				styler.ColourTo(i - 1, StateToPrint);
2079  				if (chNext == '\'' && chNext2 == '\'') {
2080  					i += 2;
2081  					state = SCE_HP_TRIPLE;
2082  					ch = ' ';
2083  					chPrev = ' ';
2084  					chNext = static_cast<unsigned char>(styler.SafeGetCharAt(i + 1));
2085  				} else {
2086  					state = SCE_HP_CHARACTER;
2087  				}
2088  			} else if (IsOperator(ch)) {
2089  				styler.ColourTo(i - 1, StateToPrint);
2090  				styler.ColourTo(i, statePrintForState(SCE_HP_OPERATOR, inScriptType));
2091  			} else if ((ch == ' ') || (ch == '\t')) {
2092  				if (state == SCE_HP_START) {
2093  					styler.ColourTo(i - 1, StateToPrint);
2094  					state = SCE_HP_DEFAULT;
2095  				}
2096  			}
2097  			break;
2098  		case SCE_HP_WORD:
2099  			if (!IsAWordChar(ch)) {
2100  				classifyWordHTPy(styler.GetStartSegment(), i - 1, keywords4, styler, prevWord, inScriptType, isMako);
2101  				state = SCE_HP_DEFAULT;
2102  				if (ch == '#') {
2103  					state = SCE_HP_COMMENTLINE;
2104  				} else if (ch == '\"') {
2105  					if (chNext == '\"' && chNext2 == '\"') {
2106  						i += 2;
2107  						state = SCE_HP_TRIPLEDOUBLE;
2108  						ch = ' ';
2109  						chPrev = ' ';
2110  						chNext = static_cast<unsigned char>(styler.SafeGetCharAt(i + 1));
2111  					} else {
2112  						state = SCE_HP_STRING;
2113  					}
2114  				} else if (ch == '\'') {
2115  					if (chNext == '\'' && chNext2 == '\'') {
2116  						i += 2;
2117  						state = SCE_HP_TRIPLE;
2118  						ch = ' ';
2119  						chPrev = ' ';
2120  						chNext = static_cast<unsigned char>(styler.SafeGetCharAt(i + 1));
2121  					} else {
2122  						state = SCE_HP_CHARACTER;
2123  					}
2124  				} else if (IsOperator(ch)) {
2125  					styler.ColourTo(i, statePrintForState(SCE_HP_OPERATOR, inScriptType));
2126  				}
2127  			}
2128  			break;
2129  		case SCE_HP_COMMENTLINE:
2130  			if (ch == '\r' || ch == '\n') {
2131  				styler.ColourTo(i - 1, StateToPrint);
2132  				state = SCE_HP_DEFAULT;
2133  			}
2134  			break;
2135  		case SCE_HP_STRING:
2136  			if (ch == '\\') {
2137  				if (chNext == '\"' || chNext == '\'' || chNext == '\\') {
2138  					i++;
2139  					ch = chNext;
2140  					chNext = static_cast<unsigned char>(styler.SafeGetCharAt(i + 1));
2141  				}
2142  			} else if (ch == '\"') {
2143  				styler.ColourTo(i, StateToPrint);
2144  				state = SCE_HP_DEFAULT;
2145  			}
2146  			break;
2147  		case SCE_HP_CHARACTER:
2148  			if (ch == '\\') {
2149  				if (chNext == '\"' || chNext == '\'' || chNext == '\\') {
2150  					i++;
2151  					ch = chNext;
2152  					chNext = static_cast<unsigned char>(styler.SafeGetCharAt(i + 1));
2153  				}
2154  			} else if (ch == '\'') {
2155  				styler.ColourTo(i, StateToPrint);
2156  				state = SCE_HP_DEFAULT;
2157  			}
2158  			break;
2159  		case SCE_HP_TRIPLE:
2160  			if (ch == '\'' && chPrev == '\'' && chPrev2 == '\'') {
2161  				styler.ColourTo(i, StateToPrint);
2162  				state = SCE_HP_DEFAULT;
2163  			}
2164  			break;
2165  		case SCE_HP_TRIPLEDOUBLE:
2166  			if (ch == '\"' && chPrev == '\"' && chPrev2 == '\"') {
2167  				styler.ColourTo(i, StateToPrint);
2168  				state = SCE_HP_DEFAULT;
2169  			}
2170  			break;
2171  		case SCE_HPHP_WORD:
2172  			if (!IsPhpWordChar(ch)) {
2173  				classifyWordHTPHP(styler.GetStartSegment(), i - 1, keywords5, styler);
2174  				if (ch == '/' && chNext == '*') {
2175  					i++;
2176  					state = SCE_HPHP_COMMENT;
2177  				} else if (ch == '/' && chNext == '/') {
2178  					i++;
2179  					state = SCE_HPHP_COMMENTLINE;
2180  				} else if (ch == '#' && chNext != '[') {
2181  					state = SCE_HPHP_COMMENTLINE;
2182  				} else if (ch == '\"') {
2183  					state = SCE_HPHP_HSTRING;
2184  					phpStringDelimiter = "\"";
2185  				} else if (styler.Match(i, "<<<")) {
2186  					bool isSimpleString = false;
2187  					i = FindPhpStringDelimiter(phpStringDelimiter, i + 3, lengthDoc, styler, isSimpleString);
2188  					if (!phpStringDelimiter.empty()) {
2189  						state = (isSimpleString ? SCE_HPHP_SIMPLESTRING : SCE_HPHP_HSTRING);
2190  						if (foldHeredoc) levelCurrent++;
2191  					}
2192  				} else if (ch == '\'') {
2193  					state = SCE_HPHP_SIMPLESTRING;
2194  					phpStringDelimiter = "\'";
2195  				} else if (ch == '$' && IsPhpWordStart(chNext)) {
2196  					state = SCE_HPHP_VARIABLE;
2197  				} else if (IsOperator(ch)) {
2198  					state = SCE_HPHP_OPERATOR;
2199  				} else {
2200  					state = SCE_HPHP_DEFAULT;
2201  				}
2202  			}
2203  			break;
2204  		case SCE_HPHP_NUMBER:
2205  			if (phpNumber.check(chNext, chNext2)) {
2206  				styler.ColourTo(i, phpNumber.isInvalid() ? SCE_HPHP_DEFAULT : SCE_HPHP_NUMBER);
2207  				state = SCE_HPHP_DEFAULT;
2208  			}
2209  			break;
2210  		case SCE_HPHP_VARIABLE:
2211  			if (!IsPhpWordChar(chNext)) {
2212  				styler.ColourTo(i, SCE_HPHP_VARIABLE);
2213  				state = SCE_HPHP_DEFAULT;
2214  			}
2215  			break;
2216  		case SCE_HPHP_COMMENT:
2217  			if (ch == '/' && chPrev == '*') {
2218  				styler.ColourTo(i, StateToPrint);
2219  				state = SCE_HPHP_DEFAULT;
2220  			}
2221  			break;
2222  		case SCE_HPHP_COMMENTLINE:
2223  			if (ch == '\r' || ch == '\n') {
2224  				styler.ColourTo(i - 1, StateToPrint);
2225  				state = SCE_HPHP_DEFAULT;
2226  			}
2227  			break;
2228  		case SCE_HPHP_HSTRING:
2229  			if (ch == '\\' && ((phpStringDelimiter == "\"") || chNext == '$' || chNext == '{')) {
2230  				i++;
2231  			} else if (((ch == '{' && chNext == '$') || (ch == '$' && chNext == '{'))
2232  				&& IsPhpWordStart(chNext2)) {
2233  				styler.ColourTo(i - 1, StateToPrint);
2234  				state = SCE_HPHP_COMPLEX_VARIABLE;
2235  			} else if (ch == '$' && IsPhpWordStart(chNext)) {
2236  				styler.ColourTo(i - 1, StateToPrint);
2237  				state = SCE_HPHP_HSTRING_VARIABLE;
2238  			} else if (styler.Match(i, phpStringDelimiter.c_str())) {
2239  				if (phpStringDelimiter == "\"") {
2240  					styler.ColourTo(i, StateToPrint);
2241  					state = SCE_HPHP_DEFAULT;
2242  				} else if (lineStartVisibleChars == 1) {
2243  					const int psdLength = static_cast<int>(phpStringDelimiter.length());
2244  					if (!IsPhpWordChar(styler.SafeGetCharAt(i + psdLength))) {
2245  						i += (((i + psdLength) < lengthDoc) ? psdLength : lengthDoc) - 1;
2246  						styler.ColourTo(i, StateToPrint);
2247  						state = SCE_HPHP_DEFAULT;
2248  						if (foldHeredoc) levelCurrent--;
2249  					}
2250  				}
2251  			}
2252  			break;
2253  		case SCE_HPHP_SIMPLESTRING:
2254  			if (phpStringDelimiter == "\'") {
2255  				if (ch == '\\') {
2256  					i++;
2257  				} else if (ch == '\'') {
2258  					styler.ColourTo(i, StateToPrint);
2259  					state = SCE_HPHP_DEFAULT;
2260  				}
2261  			} else if (lineStartVisibleChars == 1 && styler.Match(i, phpStringDelimiter.c_str())) {
2262  				const int psdLength = static_cast<int>(phpStringDelimiter.length());
2263  				if (!IsPhpWordChar(styler.SafeGetCharAt(i + psdLength))) {
2264  					i += (((i + psdLength) < lengthDoc) ? psdLength : lengthDoc) - 1;
2265  					styler.ColourTo(i, StateToPrint);
2266  					state = SCE_HPHP_DEFAULT;
2267  					if (foldHeredoc) levelCurrent--;
2268  				}
2269  			}
2270  			break;
2271  		case SCE_HPHP_HSTRING_VARIABLE:
2272  			if (!IsPhpWordChar(chNext)) {
2273  				styler.ColourTo(i, StateToPrint);
2274  				state = SCE_HPHP_HSTRING;
2275  			}
2276  			break;
2277  		case SCE_HPHP_COMPLEX_VARIABLE:
2278  			if (ch == '}') {
2279  				styler.ColourTo(i, StateToPrint);
2280  				state = SCE_HPHP_HSTRING;
2281  			}
2282  			break;
2283  		case SCE_HPHP_OPERATOR:
2284  		case SCE_HPHP_DEFAULT:
2285  			styler.ColourTo(i - 1, StateToPrint);
2286  			if (phpNumber.init(ch, chNext, chNext2)) {
2287  				if (phpNumber.isFinished()) {
2288  					styler.ColourTo(i, phpNumber.isInvalid() ? SCE_HPHP_DEFAULT : SCE_HPHP_NUMBER);
2289  					state = SCE_HPHP_DEFAULT;
2290  				} else {
2291  					state = SCE_HPHP_NUMBER;
2292  				}
2293  			} else if (IsAWordStart(ch)) {
2294  				state = SCE_HPHP_WORD;
2295  			} else if (ch == '/' && chNext == '*') {
2296  				i++;
2297  				state = SCE_HPHP_COMMENT;
2298  			} else if (ch == '/' && chNext == '/') {
2299  				i++;
2300  				state = SCE_HPHP_COMMENTLINE;
2301  			} else if (ch == '#' && chNext != '[') {
2302  				state = SCE_HPHP_COMMENTLINE;
2303  			} else if (ch == '\"') {
2304  				state = SCE_HPHP_HSTRING;
2305  				phpStringDelimiter = "\"";
2306  			} else if (styler.Match(i, "<<<")) {
2307  				bool isSimpleString = false;
2308  				i = FindPhpStringDelimiter(phpStringDelimiter, i + 3, lengthDoc, styler, isSimpleString);
2309  				if (!phpStringDelimiter.empty()) {
2310  					state = (isSimpleString ? SCE_HPHP_SIMPLESTRING : SCE_HPHP_HSTRING);
2311  					if (foldHeredoc) levelCurrent++;
2312  				}
2313  			} else if (ch == '\'') {
2314  				state = SCE_HPHP_SIMPLESTRING;
2315  				phpStringDelimiter = "\'";
2316  			} else if (ch == '$' && IsPhpWordStart(chNext)) {
2317  				state = SCE_HPHP_VARIABLE;
2318  			} else if (IsOperator(ch)) {
2319  				state = SCE_HPHP_OPERATOR;
2320  			} else if ((state == SCE_HPHP_OPERATOR) && (IsASpace(ch))) {
2321  				state = SCE_HPHP_DEFAULT;
2322  			}
2323  			break;
2324  		}
2325  		const bool nonEmptySegment = i >= static_cast<Sci_Position>(styler.GetStartSegment());
2326  		if (state == SCE_HB_DEFAULT) {    
2327  			if ((ch == '\"') && (nonEmptySegment)) {
2328  				state = SCE_HB_STRING;
2329  			} else if (ch == '\'') {
2330  				state = SCE_HB_COMMENTLINE;
2331  			} else if (IsAWordStart(ch)) {
2332  				state = SCE_HB_WORD;
2333  			} else if (IsOperator(ch)) {
2334  				styler.ColourTo(i, SCE_HB_DEFAULT);
2335  			}
2336  		} else if (state == SCE_HBA_DEFAULT) {    
2337  			if ((ch == '\"') && (nonEmptySegment)) {
2338  				state = SCE_HBA_STRING;
2339  			} else if (ch == '\'') {
2340  				state = SCE_HBA_COMMENTLINE;
2341  			} else if (IsAWordStart(ch)) {
2342  				state = SCE_HBA_WORD;
2343  			} else if (IsOperator(ch)) {
2344  				styler.ColourTo(i, SCE_HBA_DEFAULT);
2345  			}
2346  		} else if (state == SCE_HJ_DEFAULT) {    
2347  			if (ch == '/' && chNext == '*') {
2348  				if (styler.SafeGetCharAt(i + 2) == '*')
2349  					state = SCE_HJ_COMMENTDOC;
2350  				else
2351  					state = SCE_HJ_COMMENT;
2352  			} else if (ch == '/' && chNext == '/') {
2353  				state = SCE_HJ_COMMENTLINE;
2354  			} else if ((ch == '\"') && (nonEmptySegment)) {
2355  				state = SCE_HJ_DOUBLESTRING;
2356  			} else if ((ch == '\'') && (nonEmptySegment)) {
2357  				state = SCE_HJ_SINGLESTRING;
2358  			} else if (IsAWordStart(ch)) {
2359  				state = SCE_HJ_WORD;
2360  			} else if (IsOperator(ch)) {
2361  				styler.ColourTo(i, statePrintForState(SCE_HJ_SYMBOLS, inScriptType));
2362  			}
2363  		}
2364  	}
2365  	switch (state) {
2366  	case SCE_HJ_WORD:
2367  		classifyWordHTJS(styler.GetStartSegment(), lengthDoc - 1, keywords2, styler, inScriptType);
2368  		break;
2369  	case SCE_HB_WORD:
2370  		classifyWordHTVB(styler.GetStartSegment(), lengthDoc - 1, keywords3, styler, inScriptType);
2371  		break;
2372  	case SCE_HP_WORD:
2373  		classifyWordHTPy(styler.GetStartSegment(), lengthDoc - 1, keywords4, styler, prevWord, inScriptType, isMako);
2374  		break;
2375  	case SCE_HPHP_WORD:
2376  		classifyWordHTPHP(styler.GetStartSegment(), lengthDoc - 1, keywords5, styler);
2377  		break;
2378  	default:
2379  		StateToPrint = statePrintForState(state, inScriptType);
2380  		if (static_cast<Sci_Position>(styler.GetStartSegment()) < lengthDoc)
2381  			styler.ColourTo(lengthDoc - 1, StateToPrint);
2382  		break;
2383  	}
2384  	if (fold) {
2385  		const int flagsNext = styler.LevelAt(lineCurrent) & ~SC_FOLDLEVELNUMBERMASK;
2386  		styler.SetLevel(lineCurrent, levelPrev | flagsNext);
2387  	}
2388  	styler.Flush();
2389  }
2390  LexerModule lmHTML(SCLEX_HTML, LexerHTML::LexerFactoryHTML, "hypertext", htmlWordListDesc);
2391  LexerModule lmXML(SCLEX_XML, LexerHTML::LexerFactoryXML, "xml", htmlWordListDesc);
2392  LexerModule lmPHPSCRIPT(SCLEX_PHPSCRIPT, LexerHTML::LexerFactoryPHPScript, "phpscript", phpscriptWordListDesc);
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexEDIFACT.cxx</h3>
            <pre><code>1  #include <cstdlib>
2  #include <cassert>
3  #include <cstring>
4  #include <cctype>
5  #include <string>
6  #include <string_view>
7  #include "ILexer.h"
8  #include "Scintilla.h"
9  #include "SciLexer.h"
10  #include "LexAccessor.h"
11  #include "LexerModule.h"
12  #include "DefaultLexer.h"
13  using namespace Scintilla;
14  using namespace Lexilla;
15  class LexerEDIFACT : public DefaultLexer
16  {
17  public:
18  	LexerEDIFACT();
19  	virtual ~LexerEDIFACT() {} 
20  	static ILexer5 *Factory() {
21  		return new LexerEDIFACT;
22  	}
23  	int SCI_METHOD Version() const override
24  	{
25  		return lvRelease5;
26  	}
27  	void SCI_METHOD Release() override
28  	{
29  		delete this;
30  	}
31  	const char * SCI_METHOD PropertyNames() override
32  	{
33  		return "fold\nlexer.edifact.highlight.un.all";
34  	}
35  	int SCI_METHOD PropertyType(const char *) override
36  	{
37  		return SC_TYPE_BOOLEAN; 
38  	}
39  	const char * SCI_METHOD DescribeProperty(const char *name) override
40  	{
41  		if (!strcmp(name, "fold"))
42  			return "Whether to apply folding to document or not";
43  		if (!strcmp(name, "lexer.edifact.highlight.un.all"))
44  			return "Whether to apply UN* highlighting to all UN segments, or just to UNH";
45  		return NULL;
46  	}
47  	Sci_Position SCI_METHOD PropertySet(const char *key, const char *val) override
48  	{
49  		if (!strcmp(key, "fold"))
50  		{
51  			m_bFold = strcmp(val, "0") ? true : false;
52  			return 0;
53  		}
54  		if (!strcmp(key, "lexer.edifact.highlight.un.all"))	
55  		{
56  			m_bHighlightAllUN = strcmp(val, "0") ? true : false;
57  			return 0;
58  		}
59  		return -1;
60  	}
61  	const char * SCI_METHOD PropertyGet(const char *key) override
62  	{
63  		m_lastPropertyValue = "";
64  		if (!strcmp(key, "fold"))
65  		{
66  			m_lastPropertyValue = m_bFold ? "1" : "0";
67  		}
68  		if (!strcmp(key, "lexer.edifact.highlight.un.all"))	
69  		{
70  			m_lastPropertyValue = m_bHighlightAllUN ? "1" : "0";
71  		}
72  		return m_lastPropertyValue.c_str();
73  	}
74  	const char * SCI_METHOD DescribeWordListSets() override
75  	{
76  		return NULL;
77  	}
78  	Sci_Position SCI_METHOD WordListSet(int, const char *) override
79  	{
80  		return -1;
81  	}
82  	void SCI_METHOD Lex(Sci_PositionU startPos, Sci_Position length, int initStyle, IDocument *pAccess) override;
83  	void SCI_METHOD Fold(Sci_PositionU startPos, Sci_Position length, int initStyle, IDocument *pAccess) override;
84  	void * SCI_METHOD PrivateCall(int, void *) override
85  	{
86  		return NULL;
87  	}
88  protected:
89  	Sci_Position InitialiseFromUNA(IDocument *pAccess, Sci_PositionU MaxLength);
90  	Sci_Position FindPreviousEnd(IDocument *pAccess, Sci_Position startPos) const;
91  	Sci_Position ForwardPastWhitespace(IDocument *pAccess, Sci_Position startPos, Sci_Position MaxLength) const;
92  	int DetectSegmentHeader(char SegmentHeader[3]) const;
93  	bool m_bFold;
94  	bool m_bHighlightAllUN;
95  	char m_chComponent;
96  	char m_chData;
97  	char m_chDecimal;
98  	char m_chRelease;
99  	char m_chSegment;
100  	std::string m_lastPropertyValue;
101  };
102  LexerModule lmEDIFACT(SCLEX_EDIFACT, LexerEDIFACT::Factory, "edifact");
103  LexerEDIFACT::LexerEDIFACT() : DefaultLexer("edifact", SCLEX_EDIFACT)
104  {
105  	m_bFold = false;
106  	m_bHighlightAllUN = false;
107  	m_chComponent = ':';
108  	m_chData = '+';
109  	m_chDecimal = '.';
110  	m_chRelease = '?';
111  	m_chSegment = '\'';
112  }
113  void LexerEDIFACT::Lex(Sci_PositionU startPos, Sci_Position length, int, IDocument *pAccess)
114  {
115  	Sci_PositionU posFinish = startPos + length;
116  	InitialiseFromUNA(pAccess, posFinish);
117  	Sci_PositionU posCurrent = FindPreviousEnd(pAccess, startPos);
118  	if (posCurrent != 0)
119  		posCurrent++;
120  	LexAccessor styler (pAccess);
121  	pAccess->StartStyling(posCurrent);
122  	styler.StartSegment(posCurrent);
123  	Sci_Position posSegmentStart = -1;
124  	while ((posCurrent < posFinish) && (posSegmentStart == -1))
125  	{
126  		posCurrent = ForwardPastWhitespace(pAccess, posCurrent, posFinish);
127  		styler.ColourTo(posCurrent - 1, SCE_EDI_DEFAULT);
128  		if (posCurrent >= posFinish)
129  			break;
130  		char SegmentHeader[4] = { 0 };
131  		pAccess->GetCharRange(SegmentHeader, posCurrent, 3);
132  		int SegmentStyle = DetectSegmentHeader(SegmentHeader);
133  		if (SegmentStyle == SCE_EDI_BADSEGMENT)
134  			break;
135  		if (SegmentStyle == SCE_EDI_UNA)
136  		{
137  			posCurrent += 9;
138  			styler.ColourTo(posCurrent - 1, SCE_EDI_UNA); 
139  			continue;
140  		}
141  		posSegmentStart = posCurrent;
142  		posCurrent += 3;
143  		styler.ColourTo(posCurrent - 1, SegmentStyle); 
144  		for (char c; posCurrent < posFinish; posCurrent++)
145  		{
146  			pAccess->GetCharRange(&c, posCurrent, 1);
147  			if (c == m_chRelease) 
148  				posCurrent++;
149  			else if (c == m_chSegment) 
150  			{
151  				Sci_Position lineSegmentStart = pAccess->LineFromPosition(posSegmentStart);
152  				Sci_Position lineSegmentEnd = pAccess->LineFromPosition(posCurrent);
153  				if (lineSegmentStart == lineSegmentEnd)
154  					styler.ColourTo(posCurrent, SCE_EDI_SEGMENTEND);
155  				else
156  					styler.ColourTo(posCurrent, SCE_EDI_BADSEGMENT);
157  				posSegmentStart = -1;
158  				posCurrent++;
159  				break;
160  			}
161  			else if (c == m_chComponent) 
<span onclick='openModal()' class='match'>162  				styler.ColourTo(posCurrent, SCE_EDI_SEP_COMPOSITE);
163  			else if (c == m_chData) 
164  				styler.ColourTo(posCurrent, SCE_EDI_SEP_ELEMENT);
165  			else
166  				styler.ColourTo(posCurrent, SCE_EDI_DEFAULT);
</span>167  		}
168  	}
169  	styler.Flush();
170  	if (posSegmentStart == -1)
171  		return;
172  	pAccess->StartStyling(posSegmentStart);
173  	pAccess->SetStyleFor(posFinish - posSegmentStart, SCE_EDI_BADSEGMENT);
174  }
175  void LexerEDIFACT::Fold(Sci_PositionU startPos, Sci_Position length, int, IDocument *pAccess)
176  {
177  	if (!m_bFold)
178  		return;
179  	Sci_PositionU endPos = startPos + length;
180  	startPos = FindPreviousEnd(pAccess, startPos);
181  	char c;
182  	char SegmentHeader[4] = { 0 };
183  	bool AwaitingSegment = true;
184  	Sci_PositionU currLine = pAccess->LineFromPosition(startPos);
185  	int levelCurrentStyle = SC_FOLDLEVELBASE;
186  	if (currLine > 0)
187  		levelCurrentStyle = pAccess->GetLevel(currLine - 1); 
188  	int indentCurrent = levelCurrentStyle & SC_FOLDLEVELNUMBERMASK;
189  	int indentNext = indentCurrent;
190  	while (startPos < endPos)
191  	{
192  		pAccess->GetCharRange(&c, startPos, 1);
193  		switch (c)
194  		{
195  		case '\t':
196  		case '\r':
197  		case ' ':
198  			startPos++;
199  			continue;
200  		case '\n':
201  			currLine = pAccess->LineFromPosition(startPos);
202  			pAccess->SetLevel(currLine, levelCurrentStyle | indentCurrent);
203  			startPos++;
204  			levelCurrentStyle = SC_FOLDLEVELBASE;
205  			indentCurrent = indentNext;
206  			continue;
207  		}
208  		if (c == m_chRelease)
209  		{
210  			startPos += 2;
211  			continue;
212  		}
213  		if (c == m_chSegment)
214  		{
215  			AwaitingSegment = true;
216  			startPos++;
217  			continue;
218  		}
219  		if (!AwaitingSegment)
220  		{
221  			startPos++;
222  			continue;
223  		}
224  		pAccess->GetCharRange(SegmentHeader, startPos, 3);
225  		if (SegmentHeader[0] != 'U' || SegmentHeader[1] != 'N')
226  		{
227  			startPos++;
228  			continue;
229  		}
230  		AwaitingSegment = false;
231  		switch (SegmentHeader[2])
232  		{
233  		case 'H':
234  		case 'G':
235  			indentNext++;
236  			levelCurrentStyle = SC_FOLDLEVELBASE | SC_FOLDLEVELHEADERFLAG;
237  			break;
238  		case 'T':
239  		case 'E':
240  			if (indentNext > 0)
241  				indentNext--;
242  			break;
243  		}
244  		startPos += 3;
245  	}
246  }
247  Sci_Position LexerEDIFACT::InitialiseFromUNA(IDocument *pAccess, Sci_PositionU MaxLength)
248  {
249  	MaxLength -= 9; 
250  	Sci_PositionU startPos = 0;
251  	startPos += ForwardPastWhitespace(pAccess, 0, MaxLength);
252  	if (startPos < MaxLength)
253  	{
254  		char bufUNA[9];
255  		pAccess->GetCharRange(bufUNA, startPos, 9);
256  		if (!memcmp(bufUNA, "UNA", 3))
257  		{
258  			m_chComponent = bufUNA[3];
259  			m_chData = bufUNA[4];
260  			m_chDecimal = bufUNA[5];
261  			m_chRelease = bufUNA[6];
262  			m_chSegment = bufUNA[8];
263  			return 0; 
264  		}
265  	}
266  	m_chComponent = ':';
267  	m_chData = '+';
268  	m_chDecimal = '.';
269  	m_chRelease = '?';
270  	m_chSegment = '\'';
271  	return -1;
272  }
273  Sci_Position LexerEDIFACT::ForwardPastWhitespace(IDocument *pAccess, Sci_Position startPos, Sci_Position MaxLength) const
274  {
275  	char c;
276  	while (startPos < MaxLength)
277  	{
278  		pAccess->GetCharRange(&c, startPos, 1);
279  		switch (c)
280  		{
281  		case '\t':
282  		case '\r':
283  		case '\n':
284  		case ' ':
285  			break;
286  		default:
287  			return startPos;
288  		}
289  		startPos++;
290  	}
291  	return MaxLength;
292  }
293  int LexerEDIFACT::DetectSegmentHeader(char SegmentHeader[3]) const
294  {
295  	if (
296  		SegmentHeader[0] < 'A' || SegmentHeader[0] > 'Z' ||
297  		SegmentHeader[1] < 'A' || SegmentHeader[1] > 'Z' ||
298  		SegmentHeader[2] < 'A' || SegmentHeader[2] > 'Z')
299  		return SCE_EDI_BADSEGMENT;
300  	if (!memcmp(SegmentHeader, "UNA", 3))
301  		return SCE_EDI_UNA;
302  	if (m_bHighlightAllUN && !memcmp(SegmentHeader, "UN", 2))
303  		return SCE_EDI_UNH;
304  	else if (!memcmp(SegmentHeader, "UNH", 3))
305  		return SCE_EDI_UNH;
306  	else if (!memcmp(SegmentHeader, "UNG", 3))
307  		return SCE_EDI_UNH;
308  	return SCE_EDI_SEGMENTSTART;
309  }
310  Sci_Position LexerEDIFACT::FindPreviousEnd(IDocument *pAccess, Sci_Position startPos) const
311  {
312  	for (char c; startPos > 0; startPos--)
313  	{
314  		pAccess->GetCharRange(&c, startPos, 1);
315  		if (c == m_chSegment)
316  			return startPos;
317  	}
318  	return 0;
319  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexHTML.cxx</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexEDIFACT.cxx</div>
                </div>
                <div class="column column_space"><pre><code>1462  				styler.ColourTo(i, SCE_H_ASP);
1463  			else if (scriptLanguage == eScriptXML)
1464  				styler.ColourTo(i, SCE_H_XMLEND);
1465  			else if (scriptLanguage == eScriptSGML)
</pre></code></div>
                <div class="column column_space"><pre><code>162  				styler.ColourTo(posCurrent, SCE_EDI_SEP_COMPOSITE);
163  			else if (c == m_chData) 
164  				styler.ColourTo(posCurrent, SCE_EDI_SEP_ELEMENT);
165  			else
166  				styler.ColourTo(posCurrent, SCE_EDI_DEFAULT);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    