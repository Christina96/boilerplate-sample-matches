<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for test_concat_layer.cpp & test_accuracy_layer.cpp</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for test_concat_layer.cpp & test_accuracy_layer.cpp
      </h3>
      <h1 align="center">
        17.5%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>test_concat_layer.cpp (24.80315%)<TH>test_accuracy_layer.cpp (13.548388%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match2464-0.html#0',2,'match2464-1.html#0',3)" NAME="0">(68-82)<TD><A HREF="javascript:ZweiFrames('match2464-0.html#0',2,'match2464-1.html#0',3)" NAME="0">(94-113)</A><TD ALIGN=center><FONT COLOR="#ff0000">20</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match2464-0.html#1',2,'match2464-1.html#1',3)" NAME="1">(121-123)<TD><A HREF="javascript:ZweiFrames('match2464-0.html#1',2,'match2464-1.html#1',3)" NAME="1">(168-170)</A><TD ALIGN=center><FONT COLOR="#e50000">18</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match2464-0.html#2',2,'match2464-1.html#2',3)" NAME="2">(13-24)<TD><A HREF="javascript:ZweiFrames('match2464-0.html#2',2,'match2464-1.html#2',3)" NAME="2">(14-26)</A><TD ALIGN=center><FONT COLOR="#a50000">13</FONT>
<TR><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match2464-0.html#3',2,'match2464-1.html#3',3)" NAME="3">(43-53)<TD><A HREF="javascript:ZweiFrames('match2464-0.html#3',2,'match2464-1.html#3',3)" NAME="3">(56-67)</A><TD ALIGN=center><FONT COLOR="#990000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_concat_layer.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
#include &lt;vector&gt;

#include &quot;gtest/gtest.h&quot;

#include &quot;caffe/blob.hpp&quot;
#include &quot;caffe/common.hpp&quot;
#include &quot;caffe/filler.hpp&quot;
#include &quot;caffe/layers/concat_layer.hpp&quot;

<A NAME="2"></A>#include &quot;caffe/test/test_caffe_main.hpp&quot;
#include &quot;caffe/test/test_gradient_check_util.hpp&quot;

<FONT color="#980517"><A HREF="javascript:ZweiFrames('match2464-1.html#2',3,'match2464-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>namespace caffe {

template &lt;typename TypeParam&gt;
class ConcatLayerTest : public MultiDeviceTest&lt;TypeParam&gt; {
  typedef typename TypeParam::Dtype Dtype;

 protected:
  ConcatLayerTest()
      : blob_bottom_0_(new Blob&lt;Dtype&gt;(2, 3, 6, 5)),
        blob_bottom_1_(new Blob&lt;Dtype&gt;(2, 5, 6, 5)),
        blob_bottom_2_(new Blob&lt;Dtype&gt;(5, 3, 6, 5)),
        blob_top_(new Blob&lt;Dtype&gt;()) {}</B></FONT>
  virtual void SetUp() {
    // fill the values
    shared_ptr&lt;ConstantFiller&lt;Dtype&gt; &gt; filler;
    FillerParameter filler_param;
    filler_param.set_value(1.);
    filler.reset(new ConstantFiller&lt;Dtype&gt;(filler_param));
    filler-&gt;Fill(this-&gt;blob_bottom_0_);
    filler_param.set_value(2.);
    filler.reset(new ConstantFiller&lt;Dtype&gt;(filler_param));
    filler-&gt;Fill(this-&gt;blob_bottom_1_);
    filler_param.set_value(3.);
    filler.reset(new ConstantFiller&lt;Dtype&gt;(filler_param));
    filler-&gt;Fill(this-&gt;blob_bottom_2_);
    blob_bottom_vec_0_.push_back(blob_bottom_0_);
    blob_bottom_vec_0_.push_back(blob_bottom_1_);
<A NAME="3"></A>    blob_bottom_vec_1_.push_back(blob_bottom_0_);
    blob_bottom_vec_1_.push_back(blob_bottom_2_);
    blob_top_vec_.push_back(blob_top_);
<FONT color="#53858b"><A HREF="javascript:ZweiFrames('match2464-1.html#3',3,'match2464-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>  }

  virtual ~ConcatLayerTest() {
    delete blob_bottom_0_; delete blob_bottom_1_;
    delete blob_bottom_2_; delete blob_top_;
  }

  Blob&lt;Dtype&gt;* const blob_bottom_0_;
  Blob&lt;Dtype&gt;* const blob_bottom_1_;
  Blob&lt;Dtype&gt;* const blob_bottom_2_;
  Blob&lt;Dtype&gt;* const blob_top_;</B></FONT>
  vector&lt;Blob&lt;Dtype&gt;*&gt; blob_bottom_vec_0_, blob_bottom_vec_1_;
  vector&lt;Blob&lt;Dtype&gt;*&gt; blob_top_vec_;
};

TYPED_TEST_CASE(ConcatLayerTest, TestDtypesAndDevices);

TYPED_TEST(ConcatLayerTest, TestSetupNum) {
  typedef typename TypeParam::Dtype Dtype;
  LayerParameter layer_param;
  layer_param.mutable_concat_param()-&gt;set_axis(0);
  ConcatLayer&lt;Dtype&gt; layer(layer_param);
<A NAME="0"></A>  layer.SetUp(this-&gt;blob_bottom_vec_1_, this-&gt;blob_top_vec_);
  EXPECT_EQ(this-&gt;blob_top_-&gt;num(),
      this-&gt;blob_bottom_0_-&gt;num() + this-&gt;blob_bottom_2_-&gt;num());
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match2464-1.html#0',3,'match2464-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>  EXPECT_EQ(this-&gt;blob_top_-&gt;channels(), this-&gt;blob_bottom_0_-&gt;channels());
  EXPECT_EQ(this-&gt;blob_top_-&gt;height(), this-&gt;blob_bottom_0_-&gt;height());
  EXPECT_EQ(this-&gt;blob_top_-&gt;width(), this-&gt;blob_bottom_0_-&gt;width());
}

TYPED_TEST(ConcatLayerTest, TestSetupChannels) {
  typedef typename TypeParam::Dtype Dtype;
  LayerParameter layer_param;
  ConcatLayer&lt;Dtype&gt; layer(layer_param);
  layer.SetUp(this-&gt;blob_bottom_vec_0_, this-&gt;blob_top_vec_);
  EXPECT_EQ(this-&gt;blob_top_-&gt;num(), this-&gt;blob_bottom_0_-&gt;num());
  EXPECT_EQ(this-&gt;blob_top_-&gt;channels(),
      this-&gt;blob_bottom_0_-&gt;channels() + this-&gt;blob_bottom_1_-&gt;channels());
  EXPECT_EQ(this-&gt;blob_top_-&gt;height(), this-&gt;blob_bottom_0_-&gt;height());
  EXPECT_EQ(this-&gt;blob_top_-&gt;width(), this-&gt;blob_bottom_0_-&gt;width());</B></FONT>
}

TYPED_TEST(ConcatLayerTest, TestSetupChannelsNegativeIndexing) {
  typedef typename TypeParam::Dtype Dtype;
  LayerParameter layer_param;
  ConcatLayer&lt;Dtype&gt; layer(layer_param);
  // &quot;channels&quot; index is the third one from the end -- test negative indexing
  // by setting axis to -3 and checking that we get the same results as above in
  // TestSetupChannels.
  layer_param.mutable_concat_param()-&gt;set_axis(-3);
  layer.SetUp(this-&gt;blob_bottom_vec_0_, this-&gt;blob_top_vec_);
  EXPECT_EQ(this-&gt;blob_top_-&gt;num(), this-&gt;blob_bottom_0_-&gt;num());
  EXPECT_EQ(this-&gt;blob_top_-&gt;channels(),
      this-&gt;blob_bottom_0_-&gt;channels() + this-&gt;blob_bottom_1_-&gt;channels());
  EXPECT_EQ(this-&gt;blob_top_-&gt;height(), this-&gt;blob_bottom_0_-&gt;height());
  EXPECT_EQ(this-&gt;blob_top_-&gt;width(), this-&gt;blob_bottom_0_-&gt;width());
}

TYPED_TEST(ConcatLayerTest, TestForwardTrivial) {
  typedef typename TypeParam::Dtype Dtype;
  LayerParameter layer_param;
  ConcatLayer&lt;Dtype&gt; layer(layer_param);
  this-&gt;blob_bottom_vec_0_.resize(1);
  layer.SetUp(this-&gt;blob_bottom_vec_0_, this-&gt;blob_top_vec_);
  layer.Forward(this-&gt;blob_bottom_vec_0_, this-&gt;blob_top_vec_);
  for (int i = 0; i &lt; this-&gt;blob_bottom_0_-&gt;count(); ++i) {
    EXPECT_EQ(this-&gt;blob_bottom_0_-&gt;cpu_data()[i],
              this-&gt;blob_top_-&gt;cpu_data()[i]);
  }
}

TYPED_TEST(ConcatLayerTest, TestForwardNum) {
  typedef typename TypeParam::Dtype Dtype;
  LayerParameter layer_param;
  layer_param.mutable_concat_param()-&gt;set_axis(0);
<A NAME="1"></A>  ConcatLayer&lt;Dtype&gt; layer(layer_param);
  layer.SetUp(this-&gt;blob_bottom_vec_1_, this-&gt;blob_top_vec_);
  layer.Forward(this-&gt;blob_bottom_vec_1_, this-&gt;blob_top_vec_);
<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match2464-1.html#1',3,'match2464-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>  for (int n = 0; n &lt; this-&gt;blob_bottom_vec_1_[0]-&gt;num(); ++n) {
    for (int c = 0; c &lt; this-&gt;blob_top_-&gt;channels(); ++c) {
      for (int h = 0; h &lt; this-&gt;blob_top_-&gt;height(); ++h) {</B></FONT>
        for (int w = 0; w &lt; this-&gt;blob_top_-&gt;width(); ++w) {
          EXPECT_EQ(this-&gt;blob_top_-&gt;data_at(n, c, h, w),
              this-&gt;blob_bottom_vec_1_[0]-&gt;data_at(n, c, h, w));
        }
      }
    }
  }
  for (int n = 0; n &lt; this-&gt;blob_bottom_vec_1_[1]-&gt;num(); ++n) {
    for (int c = 0; c &lt; this-&gt;blob_top_-&gt;channels(); ++c) {
      for (int h = 0; h &lt; this-&gt;blob_top_-&gt;height(); ++h) {
        for (int w = 0; w &lt; this-&gt;blob_top_-&gt;width(); ++w) {
          EXPECT_EQ(this-&gt;blob_top_-&gt;data_at(n + 2, c, h, w),
              this-&gt;blob_bottom_vec_1_[1]-&gt;data_at(n, c, h, w));
        }
      }
    }
  }
}

TYPED_TEST(ConcatLayerTest, TestForwardChannels) {
  typedef typename TypeParam::Dtype Dtype;
  LayerParameter layer_param;
  ConcatLayer&lt;Dtype&gt; layer(layer_param);
  layer.SetUp(this-&gt;blob_bottom_vec_0_, this-&gt;blob_top_vec_);
  layer.Forward(this-&gt;blob_bottom_vec_0_, this-&gt;blob_top_vec_);
  for (int n = 0; n &lt; this-&gt;blob_top_-&gt;num(); ++n) {
    for (int c = 0; c &lt; this-&gt;blob_bottom_0_-&gt;channels(); ++c) {
      for (int h = 0; h &lt; this-&gt;blob_top_-&gt;height(); ++h) {
        for (int w = 0; w &lt; this-&gt;blob_top_-&gt;width(); ++w) {
          EXPECT_EQ(this-&gt;blob_top_-&gt;data_at(n, c, h, w),
              this-&gt;blob_bottom_vec_0_[0]-&gt;data_at(n, c, h, w));
        }
      }
    }
    for (int c = 0; c &lt; this-&gt;blob_bottom_1_-&gt;channels(); ++c) {
      for (int h = 0; h &lt; this-&gt;blob_top_-&gt;height(); ++h) {
        for (int w = 0; w &lt; this-&gt;blob_top_-&gt;width(); ++w) {
          EXPECT_EQ(this-&gt;blob_top_-&gt;data_at(n, c + 3, h, w),
              this-&gt;blob_bottom_vec_0_[1]-&gt;data_at(n, c, h, w));
        }
      }
    }
  }
}

TYPED_TEST(ConcatLayerTest, TestGradientTrivial) {
  typedef typename TypeParam::Dtype Dtype;
  LayerParameter layer_param;
  ConcatLayer&lt;Dtype&gt; layer(layer_param);
  GradientChecker&lt;Dtype&gt; checker(1e-2, 1e-2);
  this-&gt;blob_bottom_vec_0_.resize(1);
  checker.CheckGradientEltwise(&amp;layer, this-&gt;blob_bottom_vec_0_,
      this-&gt;blob_top_vec_);
}

TYPED_TEST(ConcatLayerTest, TestGradientNum) {
  typedef typename TypeParam::Dtype Dtype;
  LayerParameter layer_param;
  layer_param.mutable_concat_param()-&gt;set_axis(0);
  ConcatLayer&lt;Dtype&gt; layer(layer_param);
  GradientChecker&lt;Dtype&gt; checker(1e-2, 1e-2);
  checker.CheckGradient(&amp;layer, this-&gt;blob_bottom_vec_1_,
    this-&gt;blob_top_vec_);
}

TYPED_TEST(ConcatLayerTest, TestGradientChannels) {
  typedef typename TypeParam::Dtype Dtype;
  LayerParameter layer_param;
  ConcatLayer&lt;Dtype&gt; layer(layer_param);
  GradientChecker&lt;Dtype&gt; checker(1e-2, 1e-2);
  checker.CheckGradient(&amp;layer, this-&gt;blob_bottom_vec_0_,
    this-&gt;blob_top_vec_);
}

TYPED_TEST(ConcatLayerTest, TestGradientChannelsBottomOneOnly) {
  typedef typename TypeParam::Dtype Dtype;
  LayerParameter layer_param;
  ConcatLayer&lt;Dtype&gt; layer(layer_param);
  GradientChecker&lt;Dtype&gt; checker(1e-2, 1e-2);
  checker.CheckGradient(&amp;layer, this-&gt;blob_bottom_vec_0_,
    this-&gt;blob_top_vec_, 1);
}

}  // namespace caffe
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_accuracy_layer.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
#include &lt;cfloat&gt;
#include &lt;vector&gt;

#include &quot;gtest/gtest.h&quot;

#include &quot;caffe/blob.hpp&quot;
#include &quot;caffe/common.hpp&quot;
#include &quot;caffe/filler.hpp&quot;
#include &quot;caffe/layers/accuracy_layer.hpp&quot;
#include &quot;caffe/util/rng.hpp&quot;
<A NAME="2"></A>
#include &quot;caffe/test/test_caffe_main.hpp&quot;

<FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match2464-0.html#2',2,'match2464-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>namespace caffe {

template &lt;typename TypeParam&gt;
class AccuracyLayerTest : public MultiDeviceTest&lt;TypeParam&gt; {
  typedef typename TypeParam::Dtype Dtype;

 protected:
  AccuracyLayerTest()
      : blob_bottom_data_(new Blob&lt;Dtype&gt;()),
        blob_bottom_label_(new Blob&lt;Dtype&gt;()),
        blob_top_(new Blob&lt;Dtype&gt;()),
        blob_top_per_class_(new Blob&lt;Dtype&gt;()),
        top_k_(3) {</B></FONT>
    vector&lt;int&gt; shape(2);
    shape[0] = 100;
    shape[1] = 10;
    blob_bottom_data_-&gt;Reshape(shape);
    shape.resize(1);
    blob_bottom_label_-&gt;Reshape(shape);
    FillBottoms();

    blob_bottom_vec_.push_back(blob_bottom_data_);
    blob_bottom_vec_.push_back(blob_bottom_label_);
    blob_top_vec_.push_back(blob_top_);
    blob_top_per_class_vec_.push_back(blob_top_);
    blob_top_per_class_vec_.push_back(blob_top_per_class_);
  }

  virtual void FillBottoms() {
    // fill the probability values
    FillerParameter filler_param;
    GaussianFiller&lt;Dtype&gt; filler(filler_param);
    filler.Fill(this-&gt;blob_bottom_data_);

    const unsigned int prefetch_rng_seed = caffe_rng_rand();
    shared_ptr&lt;Caffe::RNG&gt; rng(new Caffe::RNG(prefetch_rng_seed));
    caffe::rng_t* prefetch_rng =
          static_cast&lt;caffe::rng_t*&gt;(rng-&gt;generator());
    Dtype* label_data = blob_bottom_label_-&gt;mutable_cpu_data();
<A NAME="3"></A>    for (int i = 0; i &lt; blob_bottom_label_-&gt;count(); ++i) {
      label_data[i] = (*prefetch_rng)() % 10;
    }
<FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match2464-0.html#3',2,'match2464-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>  }

  virtual ~AccuracyLayerTest() {
    delete blob_bottom_data_;
    delete blob_bottom_label_;
    delete blob_top_;
    delete blob_top_per_class_;
  }
  Blob&lt;Dtype&gt;* const blob_bottom_data_;
  Blob&lt;Dtype&gt;* const blob_bottom_label_;
  Blob&lt;Dtype&gt;* const blob_top_;
  Blob&lt;Dtype&gt;* const blob_top_per_class_;</B></FONT>
  vector&lt;Blob&lt;Dtype&gt;*&gt; blob_bottom_vec_;
  vector&lt;Blob&lt;Dtype&gt;*&gt; blob_top_vec_;
  vector&lt;Blob&lt;Dtype&gt;*&gt; blob_top_per_class_vec_;
  int top_k_;
};

TYPED_TEST_CASE(AccuracyLayerTest, TestDtypesAndDevices);

TYPED_TEST(AccuracyLayerTest, TestSetup) {
  typedef typename TypeParam::Dtype Dtype;
  LayerParameter layer_param;
  AccuracyLayer&lt;Dtype&gt; layer(layer_param);
  layer.SetUp(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
  EXPECT_EQ(this-&gt;blob_top_-&gt;num(), 1);
  EXPECT_EQ(this-&gt;blob_top_-&gt;channels(), 1);
  EXPECT_EQ(this-&gt;blob_top_-&gt;height(), 1);
  EXPECT_EQ(this-&gt;blob_top_-&gt;width(), 1);
}

TYPED_TEST(AccuracyLayerTest, TestSetupTopK) {
  typedef typename TypeParam::Dtype Dtype;
  LayerParameter layer_param;
  AccuracyParameter* accuracy_param =
<A NAME="0"></A>      layer_param.mutable_accuracy_param();
  accuracy_param-&gt;set_top_k(5);
  AccuracyLayer&lt;Dtype&gt; layer(layer_param);
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match2464-0.html#0',2,'match2464-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>  layer.SetUp(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
  EXPECT_EQ(this-&gt;blob_top_-&gt;num(), 1);
  EXPECT_EQ(this-&gt;blob_top_-&gt;channels(), 1);
  EXPECT_EQ(this-&gt;blob_top_-&gt;height(), 1);
  EXPECT_EQ(this-&gt;blob_top_-&gt;width(), 1);
}

TYPED_TEST(AccuracyLayerTest, TestSetupOutputPerClass) {
  typedef typename TypeParam::Dtype Dtype;
  LayerParameter layer_param;
  AccuracyLayer&lt;Dtype&gt; layer(layer_param);
  layer.SetUp(this-&gt;blob_bottom_vec_, this-&gt;blob_top_per_class_vec_);
  EXPECT_EQ(this-&gt;blob_top_-&gt;num(), 1);
  EXPECT_EQ(this-&gt;blob_top_-&gt;channels(), 1);
  EXPECT_EQ(this-&gt;blob_top_-&gt;height(), 1);
  EXPECT_EQ(this-&gt;blob_top_-&gt;width(), 1);
  EXPECT_EQ(this-&gt;blob_top_per_class_-&gt;num(), 10);
  EXPECT_EQ(this-&gt;blob_top_per_class_-&gt;channels(), 1);
  EXPECT_EQ(this-&gt;blob_top_per_class_-&gt;height(), 1);
  EXPECT_EQ(this-&gt;blob_top_per_class_-&gt;width(), 1);</B></FONT>
}

TYPED_TEST(AccuracyLayerTest, TestForward) {
  typedef typename TypeParam::Dtype Dtype;
  LayerParameter layer_param;
  AccuracyLayer&lt;Dtype&gt; layer(layer_param);
  layer.SetUp(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);

  // repeat the forward
  for (int iter = 0; iter &lt; 3; iter++) {
    layer.Forward(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);

    Dtype max_value;
    int max_id;
    int num_correct_labels = 0;
    for (int i = 0; i &lt; 100; ++i) {
      max_value = -FLT_MAX;
      max_id = 0;
      for (int j = 0; j &lt; 10; ++j) {
        if (this-&gt;blob_bottom_data_-&gt;data_at(i, j, 0, 0) &gt; max_value) {
          max_value = this-&gt;blob_bottom_data_-&gt;data_at(i, j, 0, 0);
          max_id = j;
        }
      }
      if (max_id == this-&gt;blob_bottom_label_-&gt;data_at(i, 0, 0, 0)) {
        ++num_correct_labels;
      }
    }
    EXPECT_NEAR(this-&gt;blob_top_-&gt;data_at(0, 0, 0, 0),
                num_correct_labels / Dtype(100.0), 1e-4);
  }
}

TYPED_TEST(AccuracyLayerTest, TestForwardWithSpatialAxes) {
  typedef typename TypeParam::Dtype Dtype;
  this-&gt;blob_bottom_data_-&gt;Reshape(2, 10, 4, 5);
  vector&lt;int&gt; label_shape(3);
  label_shape[0] = 2; label_shape[1] = 4; label_shape[2] = 5;
  this-&gt;blob_bottom_label_-&gt;Reshape(label_shape);
  this-&gt;FillBottoms();
  LayerParameter layer_param;
  layer_param.mutable_accuracy_param()-&gt;set_axis(1);
  AccuracyLayer&lt;Dtype&gt; layer(layer_param);
  layer.SetUp(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);

  // repeat the forward
  for (int iter = 0; iter &lt; 3; iter++) {
    layer.Forward(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);

    Dtype max_value;
    const int num_labels = this-&gt;blob_bottom_label_-&gt;count();
<A NAME="1"></A>    int max_id;
    int num_correct_labels = 0;
    vector&lt;int&gt; label_offset(3);
<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match2464-0.html#1',2,'match2464-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>    for (int n = 0; n &lt; this-&gt;blob_bottom_data_-&gt;num(); ++n) {
      for (int h = 0; h &lt; this-&gt;blob_bottom_data_-&gt;height(); ++h) {
        for (int w = 0; w &lt; this-&gt;blob_bottom_data_-&gt;width(); ++w) {</B></FONT>
          max_value = -FLT_MAX;
          max_id = 0;
          for (int c = 0; c &lt; this-&gt;blob_bottom_data_-&gt;channels(); ++c) {
            const Dtype pred_value =
                this-&gt;blob_bottom_data_-&gt;data_at(n, c, h, w);
            if (pred_value &gt; max_value) {
              max_value = pred_value;
              max_id = c;
            }
          }
          label_offset[0] = n; label_offset[1] = h; label_offset[2] = w;
          const int correct_label =
              static_cast&lt;int&gt;(this-&gt;blob_bottom_label_-&gt;data_at(label_offset));
          if (max_id == correct_label) {
            ++num_correct_labels;
          }
        }
      }
    }
    EXPECT_NEAR(this-&gt;blob_top_-&gt;data_at(0, 0, 0, 0),
                num_correct_labels / Dtype(num_labels), 1e-4);
  }
}

TYPED_TEST(AccuracyLayerTest, TestForwardIgnoreLabel) {
  typedef typename TypeParam::Dtype Dtype;
  LayerParameter layer_param;
  const Dtype kIgnoreLabelValue = -1;
  layer_param.mutable_accuracy_param()-&gt;set_ignore_label(kIgnoreLabelValue);
  AccuracyLayer&lt;Dtype&gt; layer(layer_param);
  // Manually set some labels to the ignore label value (-1).
  this-&gt;blob_bottom_label_-&gt;mutable_cpu_data()[2] = kIgnoreLabelValue;
  this-&gt;blob_bottom_label_-&gt;mutable_cpu_data()[5] = kIgnoreLabelValue;
  this-&gt;blob_bottom_label_-&gt;mutable_cpu_data()[32] = kIgnoreLabelValue;
  layer.SetUp(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);

  // repeat the forward
  for (int iter = 0; iter &lt; 3; iter++) {
    layer.Forward(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);

    Dtype max_value;
    int max_id;
    int num_correct_labels = 0;
    int count = 0;
    for (int i = 0; i &lt; 100; ++i) {
      if (kIgnoreLabelValue == this-&gt;blob_bottom_label_-&gt;data_at(i, 0, 0, 0)) {
        continue;
      }
      ++count;
      max_value = -FLT_MAX;
      max_id = 0;
      for (int j = 0; j &lt; 10; ++j) {
        if (this-&gt;blob_bottom_data_-&gt;data_at(i, j, 0, 0) &gt; max_value) {
          max_value = this-&gt;blob_bottom_data_-&gt;data_at(i, j, 0, 0);
          max_id = j;
        }
      }
      if (max_id == this-&gt;blob_bottom_label_-&gt;data_at(i, 0, 0, 0)) {
        ++num_correct_labels;
      }
    }
    EXPECT_EQ(count, 97);  // We set 3 out of 100 labels to kIgnoreLabelValue.
    EXPECT_NEAR(this-&gt;blob_top_-&gt;data_at(0, 0, 0, 0),
                num_correct_labels / Dtype(count), 1e-4);
  }
}

TYPED_TEST(AccuracyLayerTest, TestForwardTopK) {
  typedef typename TypeParam::Dtype Dtype;
  LayerParameter layer_param;
  AccuracyParameter* accuracy_param = layer_param.mutable_accuracy_param();
  accuracy_param-&gt;set_top_k(this-&gt;top_k_);
  AccuracyLayer&lt;Dtype&gt; layer(layer_param);
  layer.SetUp(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);

  // repeat the forward
  for (int iter = 0; iter &lt; 3; iter++) {
    layer.Forward(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);

    Dtype current_value;
    int current_rank;
    int num_correct_labels = 0;
    for (int i = 0; i &lt; 100; ++i) {
      for (int j = 0; j &lt; 10; ++j) {
        current_value = this-&gt;blob_bottom_data_-&gt;data_at(i, j, 0, 0);
        current_rank = 0;
        for (int k = 0; k &lt; 10; ++k) {
          if (this-&gt;blob_bottom_data_-&gt;data_at(i, k, 0, 0) &gt; current_value) {
            ++current_rank;
          }
        }
        if (current_rank &lt; this-&gt;top_k_ &amp;&amp;
            j == this-&gt;blob_bottom_label_-&gt;data_at(i, 0, 0, 0)) {
          ++num_correct_labels;
        }
      }
    }

    EXPECT_NEAR(this-&gt;blob_top_-&gt;data_at(0, 0, 0, 0),
                num_correct_labels / Dtype(100.0), 1e-4);
  }
}

TYPED_TEST(AccuracyLayerTest, TestForwardPerClass) {
  typedef typename TypeParam::Dtype Dtype;
  LayerParameter layer_param;
  AccuracyLayer&lt;Dtype&gt; layer(layer_param);
  layer.SetUp(this-&gt;blob_bottom_vec_, this-&gt;blob_top_per_class_vec_);
  // repeat the forward
  for (int iter = 0; iter &lt; 3; iter++) {
    layer.Forward(this-&gt;blob_bottom_vec_, this-&gt;blob_top_per_class_vec_);

    Dtype max_value;
    int max_id;
    int num_correct_labels = 0;
    const int num_class = this-&gt;blob_top_per_class_-&gt;num();
    vector&lt;int&gt; correct_per_class(num_class, 0);
    vector&lt;int&gt; num_per_class(num_class, 0);
    for (int i = 0; i &lt; 100; ++i) {
      max_value = -FLT_MAX;
      max_id = 0;
      for (int j = 0; j &lt; 10; ++j) {
        if (this-&gt;blob_bottom_data_-&gt;data_at(i, j, 0, 0) &gt; max_value) {
          max_value = this-&gt;blob_bottom_data_-&gt;data_at(i, j, 0, 0);
          max_id = j;
        }
      }
      ++num_per_class[this-&gt;blob_bottom_label_-&gt;data_at(i, 0, 0, 0)];
      if (max_id == this-&gt;blob_bottom_label_-&gt;data_at(i, 0, 0, 0)) {
        ++num_correct_labels;
        ++correct_per_class[max_id];
      }
    }
    EXPECT_NEAR(this-&gt;blob_top_-&gt;data_at(0, 0, 0, 0),
                num_correct_labels / 100.0, 1e-4);
    for (int i = 0; i &lt; num_class; ++i) {
      Dtype accuracy_per_class = (num_per_class[i] &gt; 0 ?
         static_cast&lt;Dtype&gt;(correct_per_class[i]) / num_per_class[i] : 0);
      EXPECT_NEAR(this-&gt;blob_top_per_class_-&gt;data_at(i, 0, 0, 0),
                  accuracy_per_class, 1e-4);
    }
  }
}


TYPED_TEST(AccuracyLayerTest, TestForwardPerClassWithIgnoreLabel) {
  typedef typename TypeParam::Dtype Dtype;
  LayerParameter layer_param;
  const Dtype kIgnoreLabelValue = -1;
  layer_param.mutable_accuracy_param()-&gt;set_ignore_label(kIgnoreLabelValue);
  AccuracyLayer&lt;Dtype&gt; layer(layer_param);
  // Manually set some labels to the ignore label value (-1).
  this-&gt;blob_bottom_label_-&gt;mutable_cpu_data()[2] = kIgnoreLabelValue;
  this-&gt;blob_bottom_label_-&gt;mutable_cpu_data()[5] = kIgnoreLabelValue;
  this-&gt;blob_bottom_label_-&gt;mutable_cpu_data()[32] = kIgnoreLabelValue;
  layer.SetUp(this-&gt;blob_bottom_vec_, this-&gt;blob_top_per_class_vec_);

  // repeat the forward
  for (int iter = 0; iter &lt; 3; iter++) {
    layer.Forward(this-&gt;blob_bottom_vec_, this-&gt;blob_top_per_class_vec_);

    Dtype max_value;
    int max_id;
    int num_correct_labels = 0;
    const int num_class = this-&gt;blob_top_per_class_-&gt;num();
    vector&lt;int&gt; correct_per_class(num_class, 0);
    vector&lt;int&gt; num_per_class(num_class, 0);
    int count = 0;
    for (int i = 0; i &lt; 100; ++i) {
      if (kIgnoreLabelValue == this-&gt;blob_bottom_label_-&gt;data_at(i, 0, 0, 0)) {
        continue;
      }
      ++count;
      max_value = -FLT_MAX;
      max_id = 0;
      for (int j = 0; j &lt; 10; ++j) {
        if (this-&gt;blob_bottom_data_-&gt;data_at(i, j, 0, 0) &gt; max_value) {
          max_value = this-&gt;blob_bottom_data_-&gt;data_at(i, j, 0, 0);
          max_id = j;
        }
      }
      ++num_per_class[this-&gt;blob_bottom_label_-&gt;data_at(i, 0, 0, 0)];
      if (max_id == this-&gt;blob_bottom_label_-&gt;data_at(i, 0, 0, 0)) {
        ++num_correct_labels;
        ++correct_per_class[max_id];
      }
    }
    EXPECT_EQ(count, 97);
    EXPECT_NEAR(this-&gt;blob_top_-&gt;data_at(0, 0, 0, 0),
                num_correct_labels / Dtype(count), 1e-4);
    for (int i = 0; i &lt; 10; ++i) {
      Dtype accuracy_per_class = (num_per_class[i] &gt; 0 ?
         static_cast&lt;Dtype&gt;(correct_per_class[i]) / num_per_class[i] : 0);
      EXPECT_NEAR(this-&gt;blob_top_per_class_-&gt;data_at(i, 0, 0, 0),
                  accuracy_per_class, 1e-4);
    }
  }
}

}  // namespace caffe
</PRE>
</div>
  </div>
</body>
</html>
