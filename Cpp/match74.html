<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for nanoflann.hpp &amp; benchmark_nanoflann_real.cpp</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for nanoflann.hpp &amp; benchmark_nanoflann_real.cpp
      </h3>
<h1 align="center">
        1.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>nanoflann.hpp (0.6703911%)<th>benchmark_nanoflann_real.cpp (8.450705%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(2332-2351)<td><a href="#" name="0">(57-71)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>nanoflann.hpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #pragma once
2 #include &lt;algorithm&gt;
3 #include &lt;array&gt;
4 #include &lt;cassert&gt;
5 #include &lt;cmath&gt;  #include &lt;cstdlib&gt;  #include &lt;functional&gt;
6 #include &lt;istream&gt;
7 #include &lt;limits&gt;  #include &lt;ostream&gt;
8 #include &lt;stdexcept&gt;
9 #include &lt;vector&gt;
10 #define NANOFLANN_VERSION 0x142
11 #if !defined(NOMINMAX) &amp;&amp; \
12     (defined(_WIN32) || defined(_WIN32_) || defined(WIN32) || defined(_WIN64))
13 #define NOMINMAX
14 #ifdef max
15 #undef max
16 #undef min
17 #endif
18 #endif
19 namespace nanoflann
20 {
21 template &lt;typename T&gt;
22 T pi_const()
23 {
24     return static_cast&lt;T&gt;(3.14159265358979323846);
25 }
26 template &lt;typename T, typename = int&gt;
27 struct has_resize : std::false_type
28 {
29 };
30 template &lt;typename T&gt;
31 struct has_resize&lt;T, decltype((void)std::declval&lt;T&gt;().resize(1), 0)&gt;
32     : std::true_type
33 {
34 };
35 template &lt;typename T, typename = int&gt;
36 struct has_assign : std::false_type
37 {
38 };
39 template &lt;typename T&gt;
40 struct has_assign&lt;T, decltype((void)std::declval&lt;T&gt;().assign(1, 0), 0)&gt;
41     : std::true_type
42 {
43 };
44 template &lt;typename Container&gt;
45 inline typename std::enable_if&lt;has_resize&lt;Container&gt;::value, void&gt;::type resize(
46     Container&amp; c, const size_t nElements)
47 {
48     c.resize(nElements);
49 }
50 template &lt;typename Container&gt;
51 inline typename std::enable_if&lt;!has_resize&lt;Container&gt;::value, void&gt;::type
52     resize(Container&amp; c, const size_t nElements)
53 {
54     if (nElements != c.size())
55         throw std::logic_error("Try to change the size of a std::array.");
56 }
57 template &lt;typename Container, typename T&gt;
58 inline typename std::enable_if&lt;has_assign&lt;Container&gt;::value, void&gt;::type assign(
59     Container&amp; c, const size_t nElements, const T&amp; value)
60 {
61     c.assign(nElements, value);
62 }
63 template &lt;typename Container, typename T&gt;
64 inline typename std::enable_if&lt;!has_assign&lt;Container&gt;::value, void&gt;::type
65     assign(Container&amp; c, const size_t nElements, const T&amp; value)
66 {
67     for (size_t i = 0; i &lt; nElements; i++) c[i] = value;
68 }
69 template &lt;
70     typename _DistanceType, typename _IndexType = size_t,
71     typename _CountType = size_t&gt;
72 class KNNResultSet
73 {
74    public:
75     using DistanceType = _DistanceType;
76     using IndexType    = _IndexType;
77     using CountType    = _CountType;
78    private:
79     IndexType*    indices;
80     DistanceType* dists;
81     CountType     capacity;
82     CountType     count;
83    public:
84     inline KNNResultSet(CountType capacity_)
85         : indices(0), dists(0), capacity(capacity_), count(0)
86     {
87     }
88     inline void init(IndexType* indices_, DistanceType* dists_)
89     {
90         indices = indices_;
91         dists   = dists_;
92         count   = 0;
93         if (capacity)
94             dists[capacity - 1] = (std::numeric_limits&lt;DistanceType&gt;::max)();
95     }
96     inline CountType size() const { return count; }
97     inline bool full() const { return count == capacity; }
98     inline bool addPoint(DistanceType dist, IndexType index)
99     {
100         CountType i;
101         for (i = count; i &gt; 0; --i)
102         {
103 #ifdef NANOFLANN_FIRST_MATCH              if ((dists[i - 1] &gt; dist) ||
104                 ((dist == dists[i - 1]) &amp;&amp; (indices[i - 1] &gt; index)))
105             {
106 #else
107             if (dists[i - 1] &gt; dist)
108             {
109 #endif
110                 if (i &lt; capacity)
111                 {
112                     dists[i]   = dists[i - 1];
113                     indices[i] = indices[i - 1];
114                 }
115             }
116             else
117                 break;
118         }
119         if (i &lt; capacity)
120         {
121             dists[i]   = dist;
122             indices[i] = index;
123         }
124         if (count &lt; capacity) count++;
125         return true;
126     }
127     inline DistanceType worstDist() const { return dists[capacity - 1]; }
128 };
129 struct IndexDist_Sorter
130 {
131     template &lt;typename PairType&gt;
132     inline bool operator()(const PairType&amp; p1, const PairType&amp; p2) const
133     {
134         return p1.second &lt; p2.second;
135     }
136 };
137 template &lt;typename _DistanceType, typename _IndexType = size_t&gt;
138 class RadiusResultSet
139 {
140    public:
141     using DistanceType = _DistanceType;
142     using IndexType    = _IndexType;
143    public:
144     const DistanceType radius;
145     std::vector&lt;std::pair&lt;IndexType, DistanceType&gt;&gt;&amp; m_indices_dists;
146     inline RadiusResultSet(
147         DistanceType                                     radius_,
148         std::vector&lt;std::pair&lt;IndexType, DistanceType&gt;&gt;&amp; indices_dists)
149         : radius(radius_), m_indices_dists(indices_dists)
150     {
151         init();
152     }
153     inline void init() { clear(); }
154     inline void clear() { m_indices_dists.clear(); }
155     inline size_t size() const { return m_indices_dists.size(); }
156     inline bool full() const { return true; }
157     inline bool addPoint(DistanceType dist, IndexType index)
158     {
159         if (dist &lt; radius)
160             m_indices_dists.push_back(std::make_pair(index, dist));
161         return true;
162     }
163     inline DistanceType worstDist() const { return radius; }
164     std::pair&lt;IndexType, DistanceType&gt; worst_item() const
165     {
166         if (m_indices_dists.empty())
167             throw std::runtime_error(
168                 "Cannot invoke RadiusResultSet::worst_item() on "
169                 "an empty list of results.");
170         using DistIt = typename std::vector&lt;
171             std::pair&lt;IndexType, DistanceType&gt;&gt;::const_iterator;
172         DistIt it = std::max_element(
173             m_indices_dists.begin(), m_indices_dists.end(), IndexDist_Sorter());
174         return *it;
175     }
176 };
177 template &lt;typename T&gt;
178 void save_value(std::ostream&amp; stream, const T&amp; value)
179 {
180     stream.write(reinterpret_cast&lt;const char*&gt;(&amp;value), sizeof(T));
181 }
182 template &lt;typename T&gt;
183 void save_value(std::ostream&amp; stream, const std::vector&lt;T&gt;&amp; value)
184 {
185     size_t size = value.size();
186     stream.write(reinterpret_cast&lt;const char*&gt;(&amp;size), sizeof(size_t));
187     stream.write(reinterpret_cast&lt;const char*&gt;(value.data()), sizeof(T) * size);
188 }
189 template &lt;typename T&gt;
190 void load_value(std::istream&amp; stream, T&amp; value)
191 {
192     stream.read(reinterpret_cast&lt;char*&gt;(&amp;value), sizeof(T));
193 }
194 template &lt;typename T&gt;
195 void load_value(std::istream&amp; stream, std::vector&lt;T&gt;&amp; value)
196 {
197     size_t size;
198     stream.read(reinterpret_cast&lt;char*&gt;(&amp;size), sizeof(size_t));
199     value.resize(size);
200     stream.read(reinterpret_cast&lt;char*&gt;(value.data()), sizeof(T) * size);
201 }
202 struct Metric
203 {
204 };
205 template &lt;
206     class T, class DataSource, typename _DistanceType = T,
207     typename AccessorType = uint32_t&gt;
208 struct L1_Adaptor
209 {
210     using ElementType  = T;
211     using DistanceType = _DistanceType;
212     const DataSource&amp; data_source;
213     L1_Adaptor(const DataSource&amp; _data_source) : data_source(_data_source) {}
214     inline DistanceType evalMetric(
215         const T* a, const AccessorType b_idx, size_t size,
216         DistanceType worst_dist = -1) const
217     {
218         DistanceType result    = DistanceType();
219         const T*     last      = a + size;
220         const T*     lastgroup = last - 3;
221         size_t       d         = 0;
222         while (a &lt; lastgroup)
223         {
224             const DistanceType diff0 =
225                 std::abs(a[0] - data_source.kdtree_get_pt(b_idx, d++));
226             const DistanceType diff1 =
227                 std::abs(a[1] - data_source.kdtree_get_pt(b_idx, d++));
228             const DistanceType diff2 =
229                 std::abs(a[2] - data_source.kdtree_get_pt(b_idx, d++));
230             const DistanceType diff3 =
231                 std::abs(a[3] - data_source.kdtree_get_pt(b_idx, d++));
232             result += diff0 + diff1 + diff2 + diff3;
233             a += 4;
234             if ((worst_dist &gt; 0) &amp;&amp; (result &gt; worst_dist)) { return result; }
235         }
236         while (a &lt; last)
237         { result += std::abs(*a++ - data_source.kdtree_get_pt(b_idx, d++)); }
238         return result;
239     }
240     template &lt;typename U, typename V&gt;
241     inline DistanceType accum_dist(const U a, const V b, const size_t) const
242     {
243         return std::abs(a - b);
244     }
245 };
246 template &lt;
247     class T, class DataSource, typename _DistanceType = T,
248     typename AccessorType = uint32_t&gt;
249 struct L2_Adaptor
250 {
251     using ElementType  = T;
252     using DistanceType = _DistanceType;
253     const DataSource&amp; data_source;
254     L2_Adaptor(const DataSource&amp; _data_source) : data_source(_data_source) {}
255     inline DistanceType evalMetric(
256         const T* a, const AccessorType b_idx, size_t size,
257         DistanceType worst_dist = -1) const
258     {
259         DistanceType result    = DistanceType();
260         const T*     last      = a + size;
261         const T*     lastgroup = last - 3;
262         size_t       d         = 0;
263         while (a &lt; lastgroup)
264         {
265             const DistanceType diff0 =
266                 a[0] - data_source.kdtree_get_pt(b_idx, d++);
267             const DistanceType diff1 =
268                 a[1] - data_source.kdtree_get_pt(b_idx, d++);
269             const DistanceType diff2 =
270                 a[2] - data_source.kdtree_get_pt(b_idx, d++);
271             const DistanceType diff3 =
272                 a[3] - data_source.kdtree_get_pt(b_idx, d++);
273             result +=
274                 diff0 * diff0 + diff1 * diff1 + diff2 * diff2 + diff3 * diff3;
275             a += 4;
276             if ((worst_dist &gt; 0) &amp;&amp; (result &gt; worst_dist)) { return result; }
277         }
278         while (a &lt; last)
279         {
280             const DistanceType diff0 =
281                 *a++ - data_source.kdtree_get_pt(b_idx, d++);
282             result += diff0 * diff0;
283         }
284         return result;
285     }
286     template &lt;typename U, typename V&gt;
287     inline DistanceType accum_dist(const U a, const V b, const size_t) const
288     {
289         return (a - b) * (a - b);
290     }
291 };
292 template &lt;
293     class T, class DataSource, typename _DistanceType = T,
294     typename AccessorType = uint32_t&gt;
295 struct L2_Simple_Adaptor
296 {
297     using ElementType  = T;
298     using DistanceType = _DistanceType;
299     const DataSource&amp; data_source;
300     L2_Simple_Adaptor(const DataSource&amp; _data_source)
301         : data_source(_data_source)
302     {
303     }
304     inline DistanceType evalMetric(
305         const T* a, const AccessorType b_idx, size_t size) const
306     {
307         DistanceType result = DistanceType();
308         for (size_t i = 0; i &lt; size; ++i)
309         {
310             const DistanceType diff =
311                 a[i] - data_source.kdtree_get_pt(b_idx, i);
312             result += diff * diff;
313         }
314         return result;
315     }
316     template &lt;typename U, typename V&gt;
317     inline DistanceType accum_dist(const U a, const V b, const size_t) const
318     {
319         return (a - b) * (a - b);
320     }
321 };
322 template &lt;
323     class T, class DataSource, typename _DistanceType = T,
324     typename AccessorType = uint32_t&gt;
325 struct SO2_Adaptor
326 {
327     using ElementType  = T;
328     using DistanceType = _DistanceType;
329     const DataSource&amp; data_source;
330     SO2_Adaptor(const DataSource&amp; _data_source) : data_source(_data_source) {}
331     inline DistanceType evalMetric(
332         const T* a, const AccessorType b_idx, size_t size) const
333     {
334         return accum_dist(
335             a[size - 1], data_source.kdtree_get_pt(b_idx, size - 1), size - 1);
336     }
337     template &lt;typename U, typename V&gt;
338     inline DistanceType accum_dist(const U a, const V b, const size_t) const
339     {
340         DistanceType result = DistanceType();
341         DistanceType PI     = pi_const&lt;DistanceType&gt;();
342         result              = b - a;
343         if (result &gt; PI)
344             result -= 2 * PI;
345         else if (result &lt; -PI)
346             result += 2 * PI;
347         return result;
348     }
349 };
350 template &lt;
351     class T, class DataSource, typename _DistanceType = T,
352     typename AccessorType = uint32_t&gt;
353 struct SO3_Adaptor
354 {
355     using ElementType  = T;
356     using DistanceType = _DistanceType;
357     L2_Simple_Adaptor&lt;T, DataSource, DistanceType, AccessorType&gt;
358         distance_L2_Simple;
359     SO3_Adaptor(const DataSource&amp; _data_source)
360         : distance_L2_Simple(_data_source)
361     {
362     }
363     inline DistanceType evalMetric(
364         const T* a, const AccessorType b_idx, size_t size) const
365     {
366         return distance_L2_Simple.evalMetric(a, b_idx, size);
367     }
368     template &lt;typename U, typename V&gt;
369     inline DistanceType accum_dist(const U a, const V b, const size_t idx) const
370     {
371         return distance_L2_Simple.accum_dist(a, b, idx);
372     }
373 };
374 struct metric_L1 : public Metric
375 {
376     template &lt;class T, class DataSource, typename AccessorType = uint32_t&gt;
377     struct traits
378     {
379         using distance_t = L1_Adaptor&lt;T, DataSource, T, AccessorType&gt;;
380     };
381 };
382 struct metric_L2 : public Metric
383 {
384     template &lt;class T, class DataSource, typename AccessorType = uint32_t&gt;
385     struct traits
386     {
387         using distance_t = L2_Adaptor&lt;T, DataSource, T, AccessorType&gt;;
388     };
389 };
390 struct metric_L2_Simple : public Metric
391 {
392     template &lt;class T, class DataSource, typename AccessorType = uint32_t&gt;
393     struct traits
394     {
395         using distance_t = L2_Simple_Adaptor&lt;T, DataSource, T, AccessorType&gt;;
396     };
397 };
398 struct metric_SO2 : public Metric
399 {
400     template &lt;class T, class DataSource, typename AccessorType = uint32_t&gt;
401     struct traits
402     {
403         using distance_t = SO2_Adaptor&lt;T, DataSource, T, AccessorType&gt;;
404     };
405 };
406 struct metric_SO3 : public Metric
407 {
408     template &lt;class T, class DataSource, typename AccessorType = uint32_t&gt;
409     struct traits
410     {
411         using distance_t = SO3_Adaptor&lt;T, DataSource, T, AccessorType&gt;;
412     };
413 };
414 struct KDTreeSingleIndexAdaptorParams
415 {
416     KDTreeSingleIndexAdaptorParams(size_t _leaf_max_size = 10)
417         : leaf_max_size(_leaf_max_size)
418     {
419     }
420     size_t leaf_max_size;
421 };
422 struct SearchParams
423 {
424     SearchParams(int checks_IGNORED_ = 32, float eps_ = 0, bool sorted_ = true)
425         : checks(checks_IGNORED_), eps(eps_), sorted(sorted_)
426     {
427     }
428     int checks;  //!&lt; Ignored parameter (Kept for compatibility with the FLANN
429     float eps;  //!&lt; search for eps-approximate neighbours (default: 0)
430     bool  sorted;  //!&lt; only for radius search, require neighbours sorted by
431 };
432 template &lt;typename T&gt;
433 inline T* allocate(size_t count = 1)
434 {
435     T* mem = static_cast&lt;T*&gt;(::malloc(sizeof(T) * count));
436     return mem;
437 }
438 const size_t WORDSIZE  = 16;
439 const size_t BLOCKSIZE = 8192;
440 class PooledAllocator
441 {
442     using Offset    = uint32_t;
443     using Size      = uint32_t;
444     using Dimension = int32_t;
445     Size  remaining;     void* base;     void* loc; 
446     void internal_init()
447     {
448         remaining    = 0;
449         base         = nullptr;
450         usedMemory   = 0;
451         wastedMemory = 0;
452     }
453    public:
454     Size usedMemory;
455     Size wastedMemory;
456     PooledAllocator() { internal_init(); }
457     ~PooledAllocator() { free_all(); }
458     void free_all()
459     {
460         while (base != nullptr)
461         {
462             void* prev =
463                 *(static_cast&lt;void**&gt;(base));             ::free(base);
464             base = prev;
465         }
466         internal_init();
467     }
468     void* malloc(const size_t req_size)
469     {
470         const Size size = (req_size + (WORDSIZE - 1)) &amp; ~(WORDSIZE - 1);
471         if (size &gt; remaining)
472         {
473             wastedMemory += remaining;
474             const Size blocksize =
475                 (size + sizeof(void*) + (WORDSIZE - 1) &gt; BLOCKSIZE)
476                     ? size + sizeof(void*) + (WORDSIZE - 1)
477                     : BLOCKSIZE;
478             void* m = ::malloc(blocksize);
479             if (!m)
480             {
481                 fprintf(stderr, "Failed to allocate memory.\n");
482                 throw std::bad_alloc();
483             }
484             static_cast&lt;void**&gt;(m)[0] = base;
485             base                      = m;
486             Size shift = 0;
487             remaining = blocksize - sizeof(void*) - shift;
488             loc       = (static_cast&lt;char*&gt;(m) + sizeof(void*) + shift);
489         }
490         void* rloc = loc;
491         loc        = static_cast&lt;char*&gt;(loc) + size;
492         remaining -= size;
493         usedMemory += size;
494         return rloc;
495     }
496     template &lt;typename T&gt;
497     T* allocate(const size_t count = 1)
498     {
499         T* mem = static_cast&lt;T*&gt;(this-&gt;malloc(sizeof(T) * count));
500         return mem;
501     }
502 };
503 template &lt;int32_t DIM, typename T&gt;
504 struct array_or_vector_selector
505 {
506     using container_t = std::array&lt;T, DIM&gt;;
507 };
508 template &lt;typename T&gt;
509 struct array_or_vector_selector&lt;-1, T&gt;
510 {
511     using container_t = std::vector&lt;T&gt;;
512 };
513 template &lt;
514     class Derived, typename Distance, class DatasetAdaptor, int32_t DIM = -1,
515     typename AccessorType = uint32_t&gt;
516 class KDTreeBaseClass
517 {
518    public:
519     void freeIndex(Derived&amp; obj)
520     {
521         obj.pool.free_all();
522         obj.root_node             = nullptr;
523         obj.m_size_at_index_build = 0;
524     }
525     using ElementType  = typename Distance::ElementType;
526     using DistanceType = typename Distance::DistanceType;
527     std::vector&lt;AccessorType&gt; vAcc;
528     using Offset    = typename decltype(vAcc)::size_type;
529     using Size      = typename decltype(vAcc)::size_type;
530     using Dimension = int32_t;
531     struct Node
532     {
533         union
534         {
535             struct leaf
536             {
537                 Offset left, right;  //!&lt; Indices of points in leaf node
538             } lr;
539             struct nonleaf
540             {
541                 Dimension    divfeat;  //!&lt; Dimension used for subdivision.
542                 DistanceType divlow,
543                     divhigh;  //!&lt; The values used for subdivision.
544             } sub;
545         } node_type;
546         Node *child1, *child2;
547     };
548     using NodePtr = Node*;
549     struct Interval
550     {
551         ElementType low, high;
552     };
553     NodePtr root_node;
554     Size m_leaf_max_size;
555     Size m_size;  //!&lt; Number of current points in the dataset
556     Size m_size_at_index_build;  //!&lt; Number of points in the dataset when the
557     Dimension dim;  //!&lt; Dimensionality of each data point
558     using BoundingBox =
559         typename array_or_vector_selector&lt;DIM, Interval&gt;::container_t;
560     using distance_vector_t =
561         typename array_or_vector_selector&lt;DIM, DistanceType&gt;::container_t;
562     BoundingBox root_bbox;
563     PooledAllocator pool;
564     Size size(const Derived&amp; obj) const { return obj.m_size; }
565     Size veclen(const Derived&amp; obj) { return DIM &gt; 0 ? DIM : obj.dim; }
566     inline ElementType dataset_get(
567         const Derived&amp; obj, AccessorType element, Dimension component) const
568     {
569         return obj.dataset.kdtree_get_pt(element, component);
570     }
571     Size usedMemory(Derived&amp; obj)
572     {
573         return obj.pool.usedMemory + obj.pool.wastedMemory +
574                obj.dataset.kdtree_get_point_count() *
575                    sizeof(AccessorType);      }
576     void computeMinMax(
577         const Derived&amp; obj, Offset ind, Size count, Dimension element,
578         ElementType&amp; min_elem, ElementType&amp; max_elem)
579     {
580         min_elem = dataset_get(obj, vAcc[ind], element);
581         max_elem = min_elem;
582         for (Offset i = 1; i &lt; count; ++i)
583         {
584             ElementType val = dataset_get(obj, vAcc[ind + i], element);
585             if (val &lt; min_elem) min_elem = val;
586             if (val &gt; max_elem) max_elem = val;
587         }
588     }
589     NodePtr divideTree(
590         Derived&amp; obj, const Offset left, const Offset right, BoundingBox&amp; bbox)
591     {
592         NodePtr node = obj.pool.template allocate&lt;Node&gt;();  
593         if ((right - left) &lt;= static_cast&lt;Offset&gt;(obj.m_leaf_max_size))
594         {
595             node-&gt;child1 = node-&gt;child2 = nullptr;             node-&gt;node_type.lr.left     = left;
596             node-&gt;node_type.lr.right    = right;
597             for (Dimension i = 0; i &lt; (DIM &gt; 0 ? DIM : obj.dim); ++i)
598             {
599                 bbox[i].low  = dataset_get(obj, obj.vAcc[left], i);
600                 bbox[i].high = dataset_get(obj, obj.vAcc[left], i);
601             }
602             for (Offset k = left + 1; k &lt; right; ++k)
603             {
604                 for (Dimension i = 0; i &lt; (DIM &gt; 0 ? DIM : obj.dim); ++i)
605                 {
606                     if (bbox[i].low &gt; dataset_get(obj, obj.vAcc[k], i))
607                         bbox[i].low = dataset_get(obj, obj.vAcc[k], i);
608                     if (bbox[i].high &lt; dataset_get(obj, obj.vAcc[k], i))
609                         bbox[i].high = dataset_get(obj, obj.vAcc[k], i);
610                 }
611             }
612         }
613         else
614         {
615             Offset       idx;
616             Dimension    cutfeat;
617             DistanceType cutval;
618             middleSplit_(obj, left, right - left, idx, cutfeat, cutval, bbox);
619             node-&gt;node_type.sub.divfeat = cutfeat;
620             BoundingBox left_bbox(bbox);
621             left_bbox[cutfeat].high = cutval;
622             node-&gt;child1 = divideTree(obj, left, left + idx, left_bbox);
623             BoundingBox right_bbox(bbox);
624             right_bbox[cutfeat].low = cutval;
625             node-&gt;child2 = divideTree(obj, left + idx, right, right_bbox);
626             node-&gt;node_type.sub.divlow  = left_bbox[cutfeat].high;
627             node-&gt;node_type.sub.divhigh = right_bbox[cutfeat].low;
628             for (Dimension i = 0; i &lt; (DIM &gt; 0 ? DIM : obj.dim); ++i)
629             {
630                 bbox[i].low  = std::min(left_bbox[i].low, right_bbox[i].low);
631                 bbox[i].high = std::max(left_bbox[i].high, right_bbox[i].high);
632             }
633         }
634         return node;
635     }
636     void middleSplit_(
637         Derived&amp; obj, Offset ind, Size count, Offset&amp; index, Dimension&amp; cutfeat,
638         DistanceType&amp; cutval, const BoundingBox&amp; bbox)
639     {
640         const auto  EPS      = static_cast&lt;DistanceType&gt;(0.00001);
641         ElementType max_span = bbox[0].high - bbox[0].low;
642         for (Dimension i = 1; i &lt; (DIM &gt; 0 ? DIM : obj.dim); ++i)
643         {
644             ElementType span = bbox[i].high - bbox[i].low;
645             if (span &gt; max_span) { max_span = span; }
646         }
647         ElementType max_spread = -1;
648         cutfeat                = 0;
649         for (Dimension i = 0; i &lt; (DIM &gt; 0 ? DIM : obj.dim); ++i)
650         {
651             ElementType span = bbox[i].high - bbox[i].low;
652             if (span &gt; (1 - EPS) * max_span)
653             {
654                 ElementType min_elem, max_elem;
655                 computeMinMax(obj, ind, count, i, min_elem, max_elem);
656                 ElementType spread = max_elem - min_elem;
657                 if (spread &gt; max_spread)
658                 {
659                     cutfeat    = i;
660                     max_spread = spread;
661                 }
662             }
663         }
664         DistanceType split_val = (bbox[cutfeat].low + bbox[cutfeat].high) / 2;
665         ElementType  min_elem, max_elem;
666         computeMinMax(obj, ind, count, cutfeat, min_elem, max_elem);
667         if (split_val &lt; min_elem)
668             cutval = min_elem;
669         else if (split_val &gt; max_elem)
670             cutval = max_elem;
671         else
672             cutval = split_val;
673         Offset lim1, lim2;
674         planeSplit(obj, ind, count, cutfeat, cutval, lim1, lim2);
675         if (lim1 &gt; count / 2)
676             index = lim1;
677         else if (lim2 &lt; count / 2)
678             index = lim2;
679         else
680             index = count / 2;
681     }
682     void planeSplit(
683         Derived&amp; obj, Offset ind, const Size count, Dimension cutfeat,
684         DistanceType&amp; cutval, Offset&amp; lim1, Offset&amp; lim2)
685     {
686         Offset left  = 0;
687         Offset right = count - 1;
688         for (;;)
689         {
690             while (left &lt;= right &amp;&amp;
691                    dataset_get(obj, vAcc[ind + left], cutfeat) &lt; cutval)
692                 ++left;
693             while (right &amp;&amp; left &lt;= right &amp;&amp;
694                    dataset_get(obj, vAcc[ind + right], cutfeat) &gt;= cutval)
695                 --right;
696             if (left &gt; right || !right)
697                 break;              std::swap(vAcc[ind + left], vAcc[ind + right]);
698             ++left;
699             --right;
700         }
701         lim1  = left;
702         right = count - 1;
703         for (;;)
704         {
705             while (left &lt;= right &amp;&amp;
706                    dataset_get(obj, vAcc[ind + left], cutfeat) &lt;= cutval)
707                 ++left;
708             while (right &amp;&amp; left &lt;= right &amp;&amp;
709                    dataset_get(obj, vAcc[ind + right], cutfeat) &gt; cutval)
710                 --right;
711             if (left &gt; right || !right)
712                 break;              std::swap(vAcc[ind + left], vAcc[ind + right]);
713             ++left;
714             --right;
715         }
716         lim2 = left;
717     }
718     DistanceType computeInitialDistances(
719         const Derived&amp; obj, const ElementType* vec,
720         distance_vector_t&amp; dists) const
721     {
722         assert(vec);
723         DistanceType distsq = DistanceType();
724         for (Dimension i = 0; i &lt; (DIM &gt; 0 ? DIM : obj.dim); ++i)
725         {
726             if (vec[i] &lt; obj.root_bbox[i].low)
727             {
728                 dists[i] =
729                     obj.distance.accum_dist(vec[i], obj.root_bbox[i].low, i);
730                 distsq += dists[i];
731             }
732             if (vec[i] &gt; obj.root_bbox[i].high)
733             {
734                 dists[i] =
735                     obj.distance.accum_dist(vec[i], obj.root_bbox[i].high, i);
736                 distsq += dists[i];
737             }
738         }
739         return distsq;
740     }
741     void save_tree(Derived&amp; obj, std::ostream&amp; stream, NodePtr tree)
742     {
743         save_value(stream, *tree);
744         if (tree-&gt;child1 != nullptr) { save_tree(obj, stream, tree-&gt;child1); }
745         if (tree-&gt;child2 != nullptr) { save_tree(obj, stream, tree-&gt;child2); }
746     }
747     void load_tree(Derived&amp; obj, std::istream&amp; stream, NodePtr&amp; tree)
748     {
749         tree = obj.pool.template allocate&lt;Node&gt;();
750         load_value(stream, *tree);
751         if (tree-&gt;child1 != nullptr) { load_tree(obj, stream, tree-&gt;child1); }
752         if (tree-&gt;child2 != nullptr) { load_tree(obj, stream, tree-&gt;child2); }
753     }
754     void saveIndex_(Derived&amp; obj, std::ostream&amp; stream)
755     {
756         save_value(stream, obj.m_size);
757         save_value(stream, obj.dim);
758         save_value(stream, obj.root_bbox);
759         save_value(stream, obj.m_leaf_max_size);
760         save_value(stream, obj.vAcc);
761         save_tree(obj, stream, obj.root_node);
762     }
763     void loadIndex_(Derived&amp; obj, std::istream&amp; stream)
764     {
765         load_value(stream, obj.m_size);
766         load_value(stream, obj.dim);
767         load_value(stream, obj.root_bbox);
768         load_value(stream, obj.m_leaf_max_size);
769         load_value(stream, obj.vAcc);
770         load_tree(obj, stream, obj.root_node);
771     }
772 };
773 template &lt;
774     typename Distance, class DatasetAdaptor, int32_t DIM = -1,
775     typename AccessorType = uint32_t&gt;
776 class KDTreeSingleIndexAdaptor
777     : public KDTreeBaseClass&lt;
778           KDTreeSingleIndexAdaptor&lt;Distance, DatasetAdaptor, DIM, AccessorType&gt;,
779           Distance, DatasetAdaptor, DIM, AccessorType&gt;
780 {
781    public:
782     KDTreeSingleIndexAdaptor(const KDTreeSingleIndexAdaptor&lt;
783                              Distance, DatasetAdaptor, DIM, AccessorType&gt;&amp;) =
784         delete;
785     const DatasetAdaptor&amp; dataset;  //!&lt; The source of our data
786     const KDTreeSingleIndexAdaptorParams index_params;
787     Distance distance;
788     using BaseClassRef = typename nanoflann::KDTreeBaseClass&lt;
789         nanoflann::KDTreeSingleIndexAdaptor&lt;
790             Distance, DatasetAdaptor, DIM, AccessorType&gt;,
791         Distance, DatasetAdaptor, DIM, AccessorType&gt;;
792     using Offset    = typename BaseClassRef::Offset;
793     using Size      = typename BaseClassRef::Size;
794     using Dimension = typename BaseClassRef::Dimension;
795     using ElementType  = typename BaseClassRef::ElementType;
796     using DistanceType = typename BaseClassRef::DistanceType;
797     using Node    = typename BaseClassRef::Node;
798     using NodePtr = Node*;
799     using Interval = typename BaseClassRef::Interval;
800     using BoundingBox = typename BaseClassRef::BoundingBox;
801     using distance_vector_t = typename BaseClassRef::distance_vector_t;
802     template &lt;class... Args&gt;
803     KDTreeSingleIndexAdaptor(
804         const Dimension dimensionality, const DatasetAdaptor&amp; inputData,
805         const KDTreeSingleIndexAdaptorParams&amp; params = {}, Args&amp;&amp;... args)
806         : dataset(inputData),
807           index_params(params),
808           distance(inputData, std::forward&lt;Args&gt;(args)...)
809     {
810         BaseClassRef::root_node             = nullptr;
811         BaseClassRef::m_size                = dataset.kdtree_get_point_count();
812         BaseClassRef::m_size_at_index_build = BaseClassRef::m_size;
813         BaseClassRef::dim                   = dimensionality;
814         if (DIM &gt; 0) BaseClassRef::dim = DIM;
815         BaseClassRef::m_leaf_max_size = params.leaf_max_size;
816         buildIndex();
817     }
818     void buildIndex()
819     {
820         BaseClassRef::m_size                = dataset.kdtree_get_point_count();
821         BaseClassRef::m_size_at_index_build = BaseClassRef::m_size;
822         init_vind();
823         this-&gt;freeIndex(*this);
824         BaseClassRef::m_size_at_index_build = BaseClassRef::m_size;
825         if (BaseClassRef::m_size == 0) return;
826         computeBoundingBox(BaseClassRef::root_bbox);
827         BaseClassRef::root_node = this-&gt;divideTree(
828             *this, 0, BaseClassRef::m_size,
829             BaseClassRef::root_bbox);      }
830     template &lt;typename RESULTSET&gt;
831     bool findNeighbors(
832         RESULTSET&amp; result, const ElementType* vec,
833         const SearchParams&amp; searchParams) const
834     {
835         assert(vec);
836         if (this-&gt;size(*this) == 0) return false;
837         if (!BaseClassRef::root_node)
838             throw std::runtime_error(
839                 "[nanoflann] findNeighbors() called before building the "
840                 "index.");
841         float epsError = 1 + searchParams.eps;
842         distance_vector_t
843              dists;          auto zero = static_cast&lt;decltype(result.worstDist())&gt;(0);
844         assign(
845             dists, (DIM &gt; 0 ? DIM : BaseClassRef::dim),
846             zero);          DistanceType distsq = this-&gt;computeInitialDistances(*this, vec, dists);
847         searchLevel(
848             result, vec, BaseClassRef::root_node, distsq, dists,
849             epsError);          return result.full();
850     }
851     Size knnSearch(
852         const ElementType* query_point, const Size num_closest,
853         AccessorType* out_indices, DistanceType* out_distances_sq,
854         const int     {
855         nanoflann::KNNResultSet&lt;DistanceType, AccessorType&gt; resultSet(
856             num_closest);
857         resultSet.init(out_indices, out_distances_sq);
858         this-&gt;findNeighbors(resultSet, query_point, nanoflann::SearchParams());
859         return resultSet.size();
860     }
861     Size radiusSearch(
862         const ElementType* query_point, const DistanceType&amp; radius,
863         std::vector&lt;std::pair&lt;AccessorType, DistanceType&gt;&gt;&amp; IndicesDists,
864         const SearchParams&amp;                                 searchParams) const
865     {
866         RadiusResultSet&lt;DistanceType, AccessorType&gt; resultSet(
867             radius, IndicesDists);
868         const Size nFound =
869             radiusSearchCustomCallback(query_point, resultSet, searchParams);
870         if (searchParams.sorted)
871             std::sort(
872                 IndicesDists.begin(), IndicesDists.end(), IndexDist_Sorter());
873         return nFound;
874     }
875     template &lt;class SEARCH_CALLBACK&gt;
876     Size radiusSearchCustomCallback(
877         const ElementType* query_point, SEARCH_CALLBACK&amp; resultSet,
878         const SearchParams&amp; searchParams = SearchParams()) const
879     {
880         this-&gt;findNeighbors(resultSet, query_point, searchParams);
881         return resultSet.size();
882     }
883    public:
884     void init_vind()
885     {
886         BaseClassRef::m_size = dataset.kdtree_get_point_count();
887         if (BaseClassRef::vAcc.size() != BaseClassRef::m_size)
888             BaseClassRef::vAcc.resize(BaseClassRef::m_size);
889         for (Size i = 0; i &lt; BaseClassRef::m_size; i++)
890             BaseClassRef::vAcc[i] = i;
891     }
892     void computeBoundingBox(BoundingBox&amp; bbox)
893     {
894         resize(bbox, (DIM &gt; 0 ? DIM : BaseClassRef::dim));
895         if (dataset.kdtree_get_bbox(bbox))
896         {
897         }
898         else
899         {
900             const Size N = dataset.kdtree_get_point_count();
901             if (!N)
902                 throw std::runtime_error(
903                     "[nanoflann] computeBoundingBox() called but "
904                     "no data points found.");
905             for (Dimension i = 0; i &lt; (DIM &gt; 0 ? DIM : BaseClassRef::dim); ++i)
906             {
907                 bbox[i].low = bbox[i].high =
908                     this-&gt;dataset_get(*this, BaseClassRef::vAcc[0], i);
909             }
910             for (Offset k = 1; k &lt; N; ++k)
911             {
912                 for (Dimension i = 0; i &lt; (DIM &gt; 0 ? DIM : BaseClassRef::dim);
913                      ++i)
914                 {
915                     if (this-&gt;dataset_get(*this, BaseClassRef::vAcc[k], i) &lt;
916                         bbox[i].low)
917                         bbox[i].low =
918                             this-&gt;dataset_get(*this, BaseClassRef::vAcc[k], i);
919                     if (this-&gt;dataset_get(*this, BaseClassRef::vAcc[k], i) &gt;
920                         bbox[i].high)
921                         bbox[i].high =
922                             this-&gt;dataset_get(*this, BaseClassRef::vAcc[k], i);
923                 }
924             }
925         }
926     }
927     template &lt;class RESULTSET&gt;
928     bool searchLevel(
929         RESULTSET&amp; result_set, const ElementType* vec, const NodePtr node,
930         DistanceType mindistsq, distance_vector_t&amp; dists,
931         const float epsError) const
932     {
933         if ((node-&gt;child1 == nullptr) &amp;&amp; (node-&gt;child2 == nullptr))
934         {
935             DistanceType worst_dist = result_set.worstDist();
936             for (Offset i = node-&gt;node_type.lr.left;
937                  i &lt; node-&gt;node_type.lr.right; ++i)
938             {
939                 const AccessorType accessor =
940                     BaseClassRef::vAcc[i];                  DistanceType dist = distance.evalMetric(
941                     vec, accessor, (DIM &gt; 0 ? DIM : BaseClassRef::dim));
942                 if (dist &lt; worst_dist)
943                 {
944                     if (!result_set.addPoint(dist, BaseClassRef::vAcc[i]))
945                     {
946                         return false;
947                     }
948                 }
949             }
950             return true;
951         }
952         Dimension    idx   = node-&gt;node_type.sub.divfeat;
953         ElementType  val   = vec[idx];
954         DistanceType diff1 = val - node-&gt;node_type.sub.divlow;
955         DistanceType diff2 = val - node-&gt;node_type.sub.divhigh;
956         NodePtr      bestChild;
957         NodePtr      otherChild;
958         DistanceType cut_dist;
959         if ((diff1 + diff2) &lt; 0)
960         {
961             bestChild  = node-&gt;child1;
962             otherChild = node-&gt;child2;
963             cut_dist =
964                 distance.accum_dist(val, node-&gt;node_type.sub.divhigh, idx);
965         }
966         else
967         {
968             bestChild  = node-&gt;child2;
969             otherChild = node-&gt;child1;
970             cut_dist =
971                 distance.accum_dist(val, node-&gt;node_type.sub.divlow, idx);
972         }
973         if (!searchLevel(
974                 result_set, vec, bestChild, mindistsq, dists, epsError))
975         {
976             return false;
977         }
978         DistanceType dst = dists[idx];
979         mindistsq        = mindistsq + cut_dist - dst;
980         dists[idx]       = cut_dist;
981         if (mindistsq * epsError &lt;= result_set.worstDist())
982         {
983             if (!searchLevel(
984                     result_set, vec, otherChild, mindistsq, dists, epsError))
985             {
986                 return false;
987             }
988         }
989         dists[idx] = dst;
990         return true;
991     }
992    public:
993     void saveIndex(std::ostream&amp; stream) { this-&gt;saveIndex_(*this, stream); }
994     void loadIndex(std::istream&amp; stream) { this-&gt;loadIndex_(*this, stream); }
995 };  
996 template &lt;
997     typename Distance, class DatasetAdaptor, int32_t DIM = -1,
998     typename AccessorType = uint32_t&gt;
999 class KDTreeSingleIndexDynamicAdaptor_
1000     : public KDTreeBaseClass&lt;
1001           KDTreeSingleIndexDynamicAdaptor_&lt;
1002               Distance, DatasetAdaptor, DIM, AccessorType&gt;,
1003           Distance, DatasetAdaptor, DIM, AccessorType&gt;
1004 {
1005    public:
1006     const DatasetAdaptor&amp; dataset;  //!&lt; The source of our data
1007     KDTreeSingleIndexAdaptorParams index_params;
1008     std::vector&lt;int&gt;&amp; treeIndex;
1009     Distance distance;
1010     using BaseClassRef = typename nanoflann::KDTreeBaseClass&lt;
1011         nanoflann::KDTreeSingleIndexDynamicAdaptor_&lt;
1012             Distance, DatasetAdaptor, DIM, AccessorType&gt;,
1013         Distance, DatasetAdaptor, DIM, AccessorType&gt;;
1014     using ElementType  = typename BaseClassRef::ElementType;
1015     using DistanceType = typename BaseClassRef::DistanceType;
1016     using Offset    = typename BaseClassRef::Offset;
1017     using Size      = typename BaseClassRef::Size;
1018     using Dimension = typename BaseClassRef::Dimension;
1019     using Node    = typename BaseClassRef::Node;
1020     using NodePtr = Node*;
1021     using Interval = typename BaseClassRef::Interval;
1022     using BoundingBox = typename BaseClassRef::BoundingBox;
1023     using distance_vector_t = typename BaseClassRef::distance_vector_t;
1024     KDTreeSingleIndexDynamicAdaptor_(
1025         const Dimension dimensionality, const DatasetAdaptor&amp; inputData,
1026         std::vector&lt;int&gt;&amp;                     treeIndex_,
1027         const KDTreeSingleIndexAdaptorParams&amp; params =
1028             KDTreeSingleIndexAdaptorParams())
1029         : dataset(inputData),
1030           index_params(params),
1031           treeIndex(treeIndex_),
1032           distance(inputData)
1033     {
1034         BaseClassRef::root_node             = nullptr;
1035         BaseClassRef::m_size                = 0;
1036         BaseClassRef::m_size_at_index_build = 0;
1037         BaseClassRef::dim                   = dimensionality;
1038         if (DIM &gt; 0) BaseClassRef::dim = DIM;
1039         BaseClassRef::m_leaf_max_size = params.leaf_max_size;
1040     }
1041     KDTreeSingleIndexDynamicAdaptor_(
1042         const KDTreeSingleIndexDynamicAdaptor_&amp; rhs) = default;
1043     KDTreeSingleIndexDynamicAdaptor_ operator=(
1044         const KDTreeSingleIndexDynamicAdaptor_&amp; rhs)
1045     {
1046         KDTreeSingleIndexDynamicAdaptor_ tmp(rhs);
1047         std::swap(BaseClassRef::vAcc, tmp.BaseClassRef::vAcc);
1048         std::swap(
1049             BaseClassRef::m_leaf_max_size, tmp.BaseClassRef::m_leaf_max_size);
1050         std::swap(index_params, tmp.index_params);
1051         std::swap(treeIndex, tmp.treeIndex);
1052         std::swap(BaseClassRef::m_size, tmp.BaseClassRef::m_size);
1053         std::swap(
1054             BaseClassRef::m_size_at_index_build,
1055             tmp.BaseClassRef::m_size_at_index_build);
1056         std::swap(BaseClassRef::root_node, tmp.BaseClassRef::root_node);
1057         std::swap(BaseClassRef::root_bbox, tmp.BaseClassRef::root_bbox);
1058         std::swap(BaseClassRef::pool, tmp.BaseClassRef::pool);
1059         return *this;
1060     }
1061     void buildIndex()
1062     {
1063         BaseClassRef::m_size = BaseClassRef::vAcc.size();
1064         this-&gt;freeIndex(*this);
1065         BaseClassRef::m_size_at_index_build = BaseClassRef::m_size;
1066         if (BaseClassRef::m_size == 0) return;
1067         computeBoundingBox(BaseClassRef::root_bbox);
1068         BaseClassRef::root_node = this-&gt;divideTree(
1069             *this, 0, BaseClassRef::m_size,
1070             BaseClassRef::root_bbox);      }
1071     template &lt;typename RESULTSET&gt;
1072     bool findNeighbors(
1073         RESULTSET&amp; result, const ElementType* vec,
1074         const SearchParams&amp; searchParams) const
1075     {
1076         assert(vec);
1077         if (this-&gt;size(*this) == 0) return false;
1078         if (!BaseClassRef::root_node) return false;
1079         float epsError = 1 + searchParams.eps;
1080         distance_vector_t dists;
1081         assign(
1082             dists, (DIM &gt; 0 ? DIM : BaseClassRef::dim),
1083             static_cast&lt;typename distance_vector_t::value_type&gt;(0));
1084         DistanceType distsq = this-&gt;computeInitialDistances(*this, vec, dists);
1085         searchLevel(
1086             result, vec, BaseClassRef::root_node, distsq, dists,
1087             epsError);          return result.full();
1088     }
1089     Size knnSearch(
1090         const ElementType* query_point, const Size num_closest,
1091         AccessorType* out_indices, DistanceType* out_distances_sq,
1092         const int     {
1093         nanoflann::KNNResultSet&lt;DistanceType, AccessorType&gt; resultSet(
1094             num_closest);
1095         resultSet.init(out_indices, out_distances_sq);
1096         this-&gt;findNeighbors(resultSet, query_point, nanoflann::SearchParams());
1097         return resultSet.size();
1098     }
1099     Size radiusSearch(
1100         const ElementType* query_point, const DistanceType&amp; radius,
1101         std::vector&lt;std::pair&lt;AccessorType, DistanceType&gt;&gt;&amp; IndicesDists,
1102         const SearchParams&amp;                                 searchParams) const
1103     {
1104         RadiusResultSet&lt;DistanceType, AccessorType&gt; resultSet(
1105             radius, IndicesDists);
1106         const size_t nFound =
1107             radiusSearchCustomCallback(query_point, resultSet, searchParams);
1108         if (searchParams.sorted)
1109             std::sort(
1110                 IndicesDists.begin(), IndicesDists.end(), IndexDist_Sorter());
1111         return nFound;
1112     }
1113     template &lt;class SEARCH_CALLBACK&gt;
1114     Size radiusSearchCustomCallback(
1115         const ElementType* query_point, SEARCH_CALLBACK&amp; resultSet,
1116         const SearchParams&amp; searchParams = SearchParams()) const
1117     {
1118         this-&gt;findNeighbors(resultSet, query_point, searchParams);
1119         return resultSet.size();
1120     }
1121    public:
1122     void computeBoundingBox(BoundingBox&amp; bbox)
1123     {
1124         resize(bbox, (DIM &gt; 0 ? DIM : BaseClassRef::dim));
1125         if (dataset.kdtree_get_bbox(bbox))
1126         {
1127         }
1128         else
1129         {
1130             const Size N = BaseClassRef::m_size;
1131             if (!N)
1132                 throw std::runtime_error(
1133                     "[nanoflann] computeBoundingBox() called but "
1134                     "no data points found.");
1135             for (Dimension i = 0; i &lt; (DIM &gt; 0 ? DIM : BaseClassRef::dim); ++i)
1136             {
1137                 bbox[i].low = bbox[i].high =
1138                     this-&gt;dataset_get(*this, BaseClassRef::vAcc[0], i);
1139             }
1140             for (Offset k = 1; k &lt; N; ++k)
1141             {
1142                 for (Dimension i = 0; i &lt; (DIM &gt; 0 ? DIM : BaseClassRef::dim);
1143                      ++i)
1144                 {
1145                     if (this-&gt;dataset_get(*this, BaseClassRef::vAcc[k], i) &lt;
1146                         bbox[i].low)
1147                         bbox[i].low =
1148                             this-&gt;dataset_get(*this, BaseClassRef::vAcc[k], i);
1149                     if (this-&gt;dataset_get(*this, BaseClassRef::vAcc[k], i) &gt;
1150                         bbox[i].high)
1151                         bbox[i].high =
1152                             this-&gt;dataset_get(*this, BaseClassRef::vAcc[k], i);
1153                 }
1154             }
1155         }
1156     }
1157     template &lt;class RESULTSET&gt;
1158     void searchLevel(
1159         RESULTSET&amp; result_set, const ElementType* vec, const NodePtr node,
1160         DistanceType mindistsq, distance_vector_t&amp; dists,
1161         const float epsError) const
1162     {
1163         if ((node-&gt;child1 == nullptr) &amp;&amp; (node-&gt;child2 == nullptr))
1164         {
1165             DistanceType worst_dist = result_set.worstDist();
1166             for (Offset i = node-&gt;node_type.lr.left;
1167                  i &lt; node-&gt;node_type.lr.right; ++i)
1168             {
1169                 const AccessorType index =
1170                     BaseClassRef::vAcc[i];                  if (treeIndex[index] == -1) continue;
1171                 DistanceType dist = distance.evalMetric(
1172                     vec, index, (DIM &gt; 0 ? DIM : BaseClassRef::dim));
1173                 if (dist &lt; worst_dist)
1174                 {
1175                     if (!result_set.addPoint(
1176                             static_cast&lt;typename RESULTSET::DistanceType&gt;(dist),
1177                             static_cast&lt;typename RESULTSET::IndexType&gt;(
1178                                 BaseClassRef::vAcc[i])))
1179                     {
1180                         return;                      }
1181                 }
1182             }
1183             return;
1184         }
1185         Dimension    idx   = node-&gt;node_type.sub.divfeat;
1186         ElementType  val   = vec[idx];
1187         DistanceType diff1 = val - node-&gt;node_type.sub.divlow;
1188         DistanceType diff2 = val - node-&gt;node_type.sub.divhigh;
1189         NodePtr      bestChild;
1190         NodePtr      otherChild;
1191         DistanceType cut_dist;
1192         if ((diff1 + diff2) &lt; 0)
1193         {
1194             bestChild  = node-&gt;child1;
1195             otherChild = node-&gt;child2;
1196             cut_dist =
1197                 distance.accum_dist(val, node-&gt;node_type.sub.divhigh, idx);
1198         }
1199         else
1200         {
1201             bestChild  = node-&gt;child2;
1202             otherChild = node-&gt;child1;
1203             cut_dist =
1204                 distance.accum_dist(val, node-&gt;node_type.sub.divlow, idx);
1205         }
1206         searchLevel(result_set, vec, bestChild, mindistsq, dists, epsError);
1207         DistanceType dst = dists[idx];
1208         mindistsq        = mindistsq + cut_dist - dst;
1209         dists[idx]       = cut_dist;
1210         if (mindistsq * epsError &lt;= result_set.worstDist())
1211         {
1212             searchLevel(
1213                 result_set, vec, otherChild, mindistsq, dists, epsError);
1214         }
1215         dists[idx] = dst;
1216     }
1217    public:
1218     void saveIndex(std::ostream&amp; stream) { this-&gt;saveIndex_(*this, stream); }
1219     void loadIndex(std::istream&amp; stream) { this-&gt;loadIndex_(*this, stream); }
1220 };
1221 template &lt;
1222     typename Distance, class DatasetAdaptor, int32_t DIM = -1,
1223     typename AccessorType = uint32_t&gt;
1224 class KDTreeSingleIndexDynamicAdaptor
1225 {
1226    public:
1227     using ElementType  = typename Distance::ElementType;
1228     using DistanceType = typename Distance::DistanceType;
1229     using Offset = typename KDTreeSingleIndexDynamicAdaptor_&lt;
1230         Distance, DatasetAdaptor, DIM&gt;::Offset;
1231     using Size = typename KDTreeSingleIndexDynamicAdaptor_&lt;
1232         Distance, DatasetAdaptor, DIM&gt;::Size;
1233     using Dimension = typename KDTreeSingleIndexDynamicAdaptor_&lt;
1234         Distance, DatasetAdaptor, DIM&gt;::Dimension;
1235    protected:
1236     Size m_leaf_max_size;
1237     Size treeCount;
1238     Size pointCount;
1239     const DatasetAdaptor&amp; dataset;  //!&lt; The source of our data
1240     std::vector&lt;int&gt;
1241         treeIndex;  //!&lt; treeIndex[idx] is the index of tree in which
1242     KDTreeSingleIndexAdaptorParams index_params;
1243     Dimension dim;  //!&lt; Dimensionality of each data point
1244     using index_container_t =
1245         KDTreeSingleIndexDynamicAdaptor_&lt;Distance, DatasetAdaptor, DIM&gt;;
1246     std::vector&lt;index_container_t&gt; index;
1247    public:
1248     const std::vector&lt;index_container_t&gt;&amp; getAllIndices() const
1249     {
1250         return index;
1251     }
1252    private:
1253     int First0Bit(AccessorType num)
1254     {
1255         int pos = 0;
1256         while (num &amp; 1)
1257         {
1258             num = num &gt;&gt; 1;
1259             pos++;
1260         }
1261         return pos;
1262     }
1263     void init()
1264     {
1265         using my_kd_tree_t =
1266             KDTreeSingleIndexDynamicAdaptor_&lt;Distance, DatasetAdaptor, DIM&gt;;
1267         std::vector&lt;my_kd_tree_t&gt; index_(
1268             treeCount,
1269         index = index_;
1270     }
1271    public:
1272     Distance distance;
1273     KDTreeSingleIndexDynamicAdaptor(
1274         const int dimensionality, const DatasetAdaptor&amp; inputData,
1275         const KDTreeSingleIndexAdaptorParams&amp; params =
1276             KDTreeSingleIndexAdaptorParams(),
1277         const size_t maximumPointCount = 1000000000U)
1278         : dataset(inputData), index_params(params), distance(inputData)
1279     {
1280         treeCount  = static_cast&lt;size_t&gt;(std::log2(maximumPointCount));
1281         pointCount = 0U;
1282         dim        = dimensionality;
1283         treeIndex.clear();
1284         if (DIM &gt; 0) dim = DIM;
1285         m_leaf_max_size = params.leaf_max_size;
1286         init();
1287         const size_t num_initial_points = dataset.kdtree_get_point_count();
1288         if (num_initial_points &gt; 0) { addPoints(0, num_initial_points - 1); }
1289     }
1290     KDTreeSingleIndexDynamicAdaptor(
1291         const KDTreeSingleIndexDynamicAdaptor&lt;
1292             Distance, DatasetAdaptor, DIM, AccessorType&gt;&amp;) = delete;
1293     void addPoints(AccessorType start, AccessorType end)
1294     {
1295         Size count = end - start + 1;
1296         treeIndex.resize(treeIndex.size() + count);
1297         for (AccessorType idx = start; idx &lt;= end; idx++)
1298         {
1299             int pos = First0Bit(pointCount);
1300             index[pos].vAcc.clear();
1301             treeIndex[pointCount] = pos;
1302             for (int i = 0; i &lt; pos; i++)
1303             {
1304                 for (int j = 0; j &lt; static_cast&lt;int&gt;(index[i].vAcc.size()); j++)
1305                 {
1306                     index[pos].vAcc.push_back(index[i].vAcc[j]);
1307                     if (treeIndex[index[i].vAcc[j]] != -1)
1308                         treeIndex[index[i].vAcc[j]] = pos;
1309                 }
1310                 index[i].vAcc.clear();
1311                 index[i].freeIndex(index[i]);
1312             }
1313             index[pos].vAcc.push_back(idx);
1314             index[pos].buildIndex();
1315             pointCount++;
1316         }
1317     }
1318     void removePoint(size_t idx)
1319     {
1320         if (idx &gt;= pointCount) return;
1321         treeIndex[idx] = -1;
1322     }
1323     template &lt;typename RESULTSET&gt;
1324     bool findNeighbors(
1325         RESULTSET&amp; result, const ElementType* vec,
1326         const SearchParams&amp; searchParams) const
1327     {
1328         for (size_t i = 0; i &lt; treeCount; i++)
1329         { index[i].findNeighbors(result, &amp;vec[0], searchParams); }
1330         return result.full();
1331     }
1332 };
1333 template &lt;
1334     class MatrixType, int32_t DIM = -1, class Distance = nanoflann::metric_L2,
1335     bool row_major = true&gt;
1336 struct KDTreeEigenMatrixAdaptor
1337 {
1338     using self_t =
1339         KDTreeEigenMatrixAdaptor&lt;MatrixType, DIM, Distance, row_major&gt;;
1340     using num_t     = typename MatrixType::Scalar;
1341     using IndexType = typename MatrixType::Index;
1342     using metric_t  = typename Distance::template traits&lt;
1343         num_t, self_t, IndexType&gt;::distance_t;
1344     using index_t = KDTreeSingleIndexAdaptor&lt;
1345         metric_t, self_t,
1346         row_major ? MatrixType::ColsAtCompileTime
1347                   : MatrixType::RowsAtCompileTime,
1348         IndexType&gt;;
1349     index_t* index;  //! The kd-tree index for the user to call its methods as
1350     using Offset    = typename index_t::Offset;
1351     using Size      = typename index_t::Size;
1352     using Dimension = typename index_t::Dimension;
1353     KDTreeEigenMatrixAdaptor(
1354         const Dimension                                 dimensionality,
1355         const std::reference_wrapper&lt;const MatrixType&gt;&amp; mat,
1356         const int                                       leaf_max_size = 10)
1357         : m_data_matrix(mat)
1358     {
1359         const auto dims = row_major ? mat.get().cols() : mat.get().rows();
1360         if (static_cast&lt;Dimension&gt;(dims) != dimensionality)
1361             throw std::runtime_error(
1362                 "Error: 'dimensionality' must match column count in data "
1363                 "matrix");
1364         if (DIM &gt; 0 &amp;&amp; static_cast&lt;int32_t&gt;(dims) != DIM)
1365             throw std::runtime_error(
1366                 "Data set dimensionality does not match the 'DIM' template "
1367                 "argument");
1368         index = new index_t(
1369             dims, *this             nanoflann::KDTreeSingleIndexAdaptorParams(leaf_max_size));
1370         index-&gt;buildIndex();
1371     }
1372    public:
1373     KDTreeEigenMatrixAdaptor(const self_t&amp;) = delete;
1374     ~KDTreeEigenMatrixAdaptor() { delete index; }
1375     const std::reference_wrapper&lt;const MatrixType&gt; m_data_matrix;
1376     inline void query(
1377         const num_t* query_point, const Size num_closest,
1378         IndexType* out_indices, num_t* out_distances_sq,
1379         const int     {
1380         nanoflann::KNNResultSet&lt;num_t, IndexType&gt; resultSet(num_closest);
1381         resultSet.init(out_indices, out_distances_sq);
1382         index-&gt;findNeighbors(resultSet, query_point, nanoflann::SearchParams());
1383     }
1384     const self_t&amp; derived() const { return *this; }
1385     self_t&amp;       derived() { return *this; }
1386     inline Size kdtree_get_point_count() const
1387     {
1388         if (row_major)
1389             return m_data_matrix.get().rows();
1390         else
1391             return m_data_matrix.get().cols();
1392     }
1393 <a name="0"></a>        inline num_t kdtree_get_pt(const IndexType idx, size_t dim) const
1394     {
1395 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>        if (row_major)
1396             return m_data_matrix.get().coeff(idx, IndexType(dim));
1397         else
1398             return m_data_matrix.get().coeff(IndexType(dim), idx);
1399     }
1400     template &lt;class BBOX&gt;
1401     {
1402         return false;
1403     }
1404 };  
1405 </div>
1406 <div style="flex-grow: 1;">
1407 <h3>
1408 <center>
1409 <span>benchmark_nanoflann_real.cpp</span>
1410 <span> - </span>
1411 <span></span>
1412 </center>
1413 </h3>
1414 <hr/>
<pre>
1 #include &lt;cstdlib&gt;
2 #include &lt;ctime&gt;
3 #include &lt;fstream&gt;
4 #include &lt;iostream&gt;
5 #include &lt;nanoflann.hpp&gt;
6 #include &lt;string&gt;
7 using namespace std;
8 using namespace nanoflann;
9 template &lt;typename T&gt; struct PointCloud {
10   struct Point {
11     T x, y, z;
12   };
13   std::vector&lt;Point&gt; pts;
14   inline size_t kdtree_get_point_count() const { return pts.size(); }
15 <a name="0"></a>  inline T kdtree_get_pt(const size_t idx, const size_t dim) const {
16     if (dim == 0)
17       return pts[idx].x;
18 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    else if (dim == 1)
19       return pts[idx].y;
20     else
21       return pts[idx].z;
22   }
23   template &lt;class BBOX&gt; bool kdtree_get_bbox(BBOX &amp;     return false;
24   }
25 };</b></font>
26 template &lt;typename T&gt;
27 PointCloud&lt;T&gt; scanPointCloud(unsigned int &amp;N, string file) {
28   ifstream read(file.c_str());
29   string temp;
30   getline(read, temp);
31   vector&lt;vector&lt;T&gt;&gt; cloud;
32   vector&lt;T&gt; tmp;
33   T x, y, z, d;
34   N = 0;
35   while (read &gt;&gt; x &gt;&gt; y &gt;&gt; z &gt;&gt; d) {
36     tmp.resize(3);
37     tmp[0] = x;
38     tmp[1] = y;
39     tmp[2] = z;
40     cloud.push_back(tmp);
41     N++;
42   }
43   PointCloud&lt;T&gt; point;
44   point.pts.resize(N);
45   for (unsigned int i = 0; i &lt; N; i++) {
46     point.pts[i].x = cloud[i][0];
47     point.pts[i].y = cloud[i][1];
48     point.pts[i].z = cloud[i][2];
49   }
50   return point;
51 }
52 template &lt;typename num_t&gt; void kdtree_demo(string &amp;path1, string &amp;path2) {
53   PointCloud&lt;num_t&gt; PcloudS, PcloudT;
54   unsigned int N;
55   PcloudS = scanPointCloud&lt;num_t&gt;(N, path1);
56   PcloudT = scanPointCloud&lt;num_t&gt;(N, path2);
57   vector&lt;double&gt; buildTime, queryTime;
58   unsigned int plotCount = 10;
59   for (unsigned int i = 1; i &lt;= plotCount; i++) {
60     unsigned int currSize = ((i * 1.0) / plotCount) * N;
61     std::cout &lt;&lt; currSize &lt;&lt; " ";
62     PointCloud&lt;num_t&gt; cloudS, cloudT;
63     cloudS.pts.resize(currSize);
64     cloudT.pts.resize(currSize);
65     for (unsigned int j = 0; j &lt; currSize; j++) {
66       cloudS.pts[j] = PcloudS.pts[j];
67       cloudT.pts[j] = PcloudT.pts[j];
68     }
69     clock_t begin = clock();
70     typedef KDTreeSingleIndexAdaptor&lt;
71         L2_Simple_Adaptor&lt;num_t, PointCloud&lt;num_t&gt;&gt;, PointCloud&lt;num_t&gt;,
72         3         &gt;
73         my_kd_tree_t;
74                        KDTreeSingleIndexAdaptorParams(10     index.buildIndex();
75     clock_t end = clock();
76     double elapsed_secs = double(end - begin) / CLOCKS_PER_SEC;
77     buildTime.push_back(elapsed_secs);
78     {
79       double elapsed_secs = 0;
80       for (unsigned int j = 0; j &lt; currSize; j++) {
81         num_t query_pt[3];
82         query_pt[0] = cloudT.pts[j].x;
83         query_pt[1] = cloudT.pts[j].y;
84         query_pt[2] = cloudT.pts[j].z;
85         size_t ret_index;
86         num_t out_dist_sqr;
87         const size_t num_results = 1;
88         KNNResultSet&lt;num_t&gt; resultSet(num_results);
89         resultSet.init(&amp;ret_index, &amp;out_dist_sqr);
90         clock_t begin = clock();
91         index.findNeighbors(resultSet, &amp;query_pt[0],
92                             nanoflann::SearchParams(10));
93         clock_t end = clock();
94         elapsed_secs += double(end - begin);
95       }
96       elapsed_secs /= CLOCKS_PER_SEC;
97       queryTime.push_back(elapsed_secs / currSize);
98     }
99   }
100   std::cout &lt;&lt; "\n";
101   for (unsigned int i = 0; i &lt; buildTime.size(); i++)
102     std::cout &lt;&lt; buildTime[i] &lt;&lt; " ";
103   std::cout &lt;&lt; "\n";
104   for (unsigned int i = 0; i &lt; queryTime.size(); i++)
105     std::cout &lt;&lt; queryTime[i] &lt;&lt; " ";
106   std::cout &lt;&lt; "\n";
107 }
108 int main(int argc, char **argv) {
109   if (argc != 3) {
110     cerr &lt;&lt; "**Running Instructions:**\n./benchmark_nanoflann_real dataFile1 "
111             "dataFile"
112          &lt;&lt; endl;
113     return 0;
114   }
115   string dataFile1(argv[1]);
116   string dataFile2(argv[2]);
117   kdtree_demo&lt;double&gt;(dataFile1, dataFile2);
118   return 0;
119 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
