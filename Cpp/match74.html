<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for nanoflann.hpp &amp; benchmark_nanoflann_real.cpp</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for nanoflann.hpp &amp; benchmark_nanoflann_real.cpp
      </h3>
<h1 align="center">
        1.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>nanoflann.hpp (0.6703911%)<th>benchmark_nanoflann_real.cpp (8.450705%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(2332-2351)<td><a href="#" name="0">(57-71)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>nanoflann.hpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#pragma once
#include &lt;algorithm&gt;
#include &lt;array&gt;
#include &lt;cassert&gt;
#include &lt;cmath&gt;  #include &lt;cstdlib&gt;  #include &lt;functional&gt;
#include &lt;istream&gt;
#include &lt;limits&gt;  #include &lt;ostream&gt;
#include &lt;stdexcept&gt;
#include &lt;vector&gt;
#define NANOFLANN_VERSION 0x142
#if !defined(NOMINMAX) &amp;&amp; \
    (defined(_WIN32) || defined(_WIN32_) || defined(WIN32) || defined(_WIN64))
#define NOMINMAX
#ifdef max
#undef max
#undef min
#endif
#endif
namespace nanoflann
{
template &lt;typename T&gt;
T pi_const()
{
    return static_cast&lt;T&gt;(3.14159265358979323846);
}
template &lt;typename T, typename = int&gt;
struct has_resize : std::false_type
{
};
template &lt;typename T&gt;
struct has_resize&lt;T, decltype((void)std::declval&lt;T&gt;().resize(1), 0)&gt;
    : std::true_type
{
};
template &lt;typename T, typename = int&gt;
struct has_assign : std::false_type
{
};
template &lt;typename T&gt;
struct has_assign&lt;T, decltype((void)std::declval&lt;T&gt;().assign(1, 0), 0)&gt;
    : std::true_type
{
};
template &lt;typename Container&gt;
inline typename std::enable_if&lt;has_resize&lt;Container&gt;::value, void&gt;::type resize(
    Container&amp; c, const size_t nElements)
{
    c.resize(nElements);
}
template &lt;typename Container&gt;
inline typename std::enable_if&lt;!has_resize&lt;Container&gt;::value, void&gt;::type
    resize(Container&amp; c, const size_t nElements)
{
    if (nElements != c.size())
        throw std::logic_error("Try to change the size of a std::array.");
}
template &lt;typename Container, typename T&gt;
inline typename std::enable_if&lt;has_assign&lt;Container&gt;::value, void&gt;::type assign(
    Container&amp; c, const size_t nElements, const T&amp; value)
{
    c.assign(nElements, value);
}
template &lt;typename Container, typename T&gt;
inline typename std::enable_if&lt;!has_assign&lt;Container&gt;::value, void&gt;::type
    assign(Container&amp; c, const size_t nElements, const T&amp; value)
{
    for (size_t i = 0; i &lt; nElements; i++) c[i] = value;
}
template &lt;
    typename _DistanceType, typename _IndexType = size_t,
    typename _CountType = size_t&gt;
class KNNResultSet
{
   public:
    using DistanceType = _DistanceType;
    using IndexType    = _IndexType;
    using CountType    = _CountType;
   private:
    IndexType*    indices;
    DistanceType* dists;
    CountType     capacity;
    CountType     count;
   public:
    inline KNNResultSet(CountType capacity_)
        : indices(0), dists(0), capacity(capacity_), count(0)
    {
    }
    inline void init(IndexType* indices_, DistanceType* dists_)
    {
        indices = indices_;
        dists   = dists_;
        count   = 0;
        if (capacity)
            dists[capacity - 1] = (std::numeric_limits&lt;DistanceType&gt;::max)();
    }
    inline CountType size() const { return count; }
    inline bool full() const { return count == capacity; }
    inline bool addPoint(DistanceType dist, IndexType index)
    {
        CountType i;
        for (i = count; i &gt; 0; --i)
        {
#ifdef NANOFLANN_FIRST_MATCH              if ((dists[i - 1] &gt; dist) ||
                ((dist == dists[i - 1]) &amp;&amp; (indices[i - 1] &gt; index)))
            {
#else
            if (dists[i - 1] &gt; dist)
            {
#endif
                if (i &lt; capacity)
                {
                    dists[i]   = dists[i - 1];
                    indices[i] = indices[i - 1];
                }
            }
            else
                break;
        }
        if (i &lt; capacity)
        {
            dists[i]   = dist;
            indices[i] = index;
        }
        if (count &lt; capacity) count++;
        return true;
    }
    inline DistanceType worstDist() const { return dists[capacity - 1]; }
};
struct IndexDist_Sorter
{
    template &lt;typename PairType&gt;
    inline bool operator()(const PairType&amp; p1, const PairType&amp; p2) const
    {
        return p1.second &lt; p2.second;
    }
};
template &lt;typename _DistanceType, typename _IndexType = size_t&gt;
class RadiusResultSet
{
   public:
    using DistanceType = _DistanceType;
    using IndexType    = _IndexType;
   public:
    const DistanceType radius;
    std::vector&lt;std::pair&lt;IndexType, DistanceType&gt;&gt;&amp; m_indices_dists;
    inline RadiusResultSet(
        DistanceType                                     radius_,
        std::vector&lt;std::pair&lt;IndexType, DistanceType&gt;&gt;&amp; indices_dists)
        : radius(radius_), m_indices_dists(indices_dists)
    {
        init();
    }
    inline void init() { clear(); }
    inline void clear() { m_indices_dists.clear(); }
    inline size_t size() const { return m_indices_dists.size(); }
    inline bool full() const { return true; }
    inline bool addPoint(DistanceType dist, IndexType index)
    {
        if (dist &lt; radius)
            m_indices_dists.push_back(std::make_pair(index, dist));
        return true;
    }
    inline DistanceType worstDist() const { return radius; }
    std::pair&lt;IndexType, DistanceType&gt; worst_item() const
    {
        if (m_indices_dists.empty())
            throw std::runtime_error(
                "Cannot invoke RadiusResultSet::worst_item() on "
                "an empty list of results.");
        using DistIt = typename std::vector&lt;
            std::pair&lt;IndexType, DistanceType&gt;&gt;::const_iterator;
        DistIt it = std::max_element(
            m_indices_dists.begin(), m_indices_dists.end(), IndexDist_Sorter());
        return *it;
    }
};
template &lt;typename T&gt;
void save_value(std::ostream&amp; stream, const T&amp; value)
{
    stream.write(reinterpret_cast&lt;const char*&gt;(&amp;value), sizeof(T));
}
template &lt;typename T&gt;
void save_value(std::ostream&amp; stream, const std::vector&lt;T&gt;&amp; value)
{
    size_t size = value.size();
    stream.write(reinterpret_cast&lt;const char*&gt;(&amp;size), sizeof(size_t));
    stream.write(reinterpret_cast&lt;const char*&gt;(value.data()), sizeof(T) * size);
}
template &lt;typename T&gt;
void load_value(std::istream&amp; stream, T&amp; value)
{
    stream.read(reinterpret_cast&lt;char*&gt;(&amp;value), sizeof(T));
}
template &lt;typename T&gt;
void load_value(std::istream&amp; stream, std::vector&lt;T&gt;&amp; value)
{
    size_t size;
    stream.read(reinterpret_cast&lt;char*&gt;(&amp;size), sizeof(size_t));
    value.resize(size);
    stream.read(reinterpret_cast&lt;char*&gt;(value.data()), sizeof(T) * size);
}
struct Metric
{
};
template &lt;
    class T, class DataSource, typename _DistanceType = T,
    typename AccessorType = uint32_t&gt;
struct L1_Adaptor
{
    using ElementType  = T;
    using DistanceType = _DistanceType;
    const DataSource&amp; data_source;
    L1_Adaptor(const DataSource&amp; _data_source) : data_source(_data_source) {}
    inline DistanceType evalMetric(
        const T* a, const AccessorType b_idx, size_t size,
        DistanceType worst_dist = -1) const
    {
        DistanceType result    = DistanceType();
        const T*     last      = a + size;
        const T*     lastgroup = last - 3;
        size_t       d         = 0;
        while (a &lt; lastgroup)
        {
            const DistanceType diff0 =
                std::abs(a[0] - data_source.kdtree_get_pt(b_idx, d++));
            const DistanceType diff1 =
                std::abs(a[1] - data_source.kdtree_get_pt(b_idx, d++));
            const DistanceType diff2 =
                std::abs(a[2] - data_source.kdtree_get_pt(b_idx, d++));
            const DistanceType diff3 =
                std::abs(a[3] - data_source.kdtree_get_pt(b_idx, d++));
            result += diff0 + diff1 + diff2 + diff3;
            a += 4;
            if ((worst_dist &gt; 0) &amp;&amp; (result &gt; worst_dist)) { return result; }
        }
        while (a &lt; last)
        { result += std::abs(*a++ - data_source.kdtree_get_pt(b_idx, d++)); }
        return result;
    }
    template &lt;typename U, typename V&gt;
    inline DistanceType accum_dist(const U a, const V b, const size_t) const
    {
        return std::abs(a - b);
    }
};
template &lt;
    class T, class DataSource, typename _DistanceType = T,
    typename AccessorType = uint32_t&gt;
struct L2_Adaptor
{
    using ElementType  = T;
    using DistanceType = _DistanceType;
    const DataSource&amp; data_source;
    L2_Adaptor(const DataSource&amp; _data_source) : data_source(_data_source) {}
    inline DistanceType evalMetric(
        const T* a, const AccessorType b_idx, size_t size,
        DistanceType worst_dist = -1) const
    {
        DistanceType result    = DistanceType();
        const T*     last      = a + size;
        const T*     lastgroup = last - 3;
        size_t       d         = 0;
        while (a &lt; lastgroup)
        {
            const DistanceType diff0 =
                a[0] - data_source.kdtree_get_pt(b_idx, d++);
            const DistanceType diff1 =
                a[1] - data_source.kdtree_get_pt(b_idx, d++);
            const DistanceType diff2 =
                a[2] - data_source.kdtree_get_pt(b_idx, d++);
            const DistanceType diff3 =
                a[3] - data_source.kdtree_get_pt(b_idx, d++);
            result +=
                diff0 * diff0 + diff1 * diff1 + diff2 * diff2 + diff3 * diff3;
            a += 4;
            if ((worst_dist &gt; 0) &amp;&amp; (result &gt; worst_dist)) { return result; }
        }
        while (a &lt; last)
        {
            const DistanceType diff0 =
                *a++ - data_source.kdtree_get_pt(b_idx, d++);
            result += diff0 * diff0;
        }
        return result;
    }
    template &lt;typename U, typename V&gt;
    inline DistanceType accum_dist(const U a, const V b, const size_t) const
    {
        return (a - b) * (a - b);
    }
};
template &lt;
    class T, class DataSource, typename _DistanceType = T,
    typename AccessorType = uint32_t&gt;
struct L2_Simple_Adaptor
{
    using ElementType  = T;
    using DistanceType = _DistanceType;
    const DataSource&amp; data_source;
    L2_Simple_Adaptor(const DataSource&amp; _data_source)
        : data_source(_data_source)
    {
    }
    inline DistanceType evalMetric(
        const T* a, const AccessorType b_idx, size_t size) const
    {
        DistanceType result = DistanceType();
        for (size_t i = 0; i &lt; size; ++i)
        {
            const DistanceType diff =
                a[i] - data_source.kdtree_get_pt(b_idx, i);
            result += diff * diff;
        }
        return result;
    }
    template &lt;typename U, typename V&gt;
    inline DistanceType accum_dist(const U a, const V b, const size_t) const
    {
        return (a - b) * (a - b);
    }
};
template &lt;
    class T, class DataSource, typename _DistanceType = T,
    typename AccessorType = uint32_t&gt;
struct SO2_Adaptor
{
    using ElementType  = T;
    using DistanceType = _DistanceType;
    const DataSource&amp; data_source;
    SO2_Adaptor(const DataSource&amp; _data_source) : data_source(_data_source) {}
    inline DistanceType evalMetric(
        const T* a, const AccessorType b_idx, size_t size) const
    {
        return accum_dist(
            a[size - 1], data_source.kdtree_get_pt(b_idx, size - 1), size - 1);
    }
    template &lt;typename U, typename V&gt;
    inline DistanceType accum_dist(const U a, const V b, const size_t) const
    {
        DistanceType result = DistanceType();
        DistanceType PI     = pi_const&lt;DistanceType&gt;();
        result              = b - a;
        if (result &gt; PI)
            result -= 2 * PI;
        else if (result &lt; -PI)
            result += 2 * PI;
        return result;
    }
};
template &lt;
    class T, class DataSource, typename _DistanceType = T,
    typename AccessorType = uint32_t&gt;
struct SO3_Adaptor
{
    using ElementType  = T;
    using DistanceType = _DistanceType;
    L2_Simple_Adaptor&lt;T, DataSource, DistanceType, AccessorType&gt;
        distance_L2_Simple;
    SO3_Adaptor(const DataSource&amp; _data_source)
        : distance_L2_Simple(_data_source)
    {
    }
    inline DistanceType evalMetric(
        const T* a, const AccessorType b_idx, size_t size) const
    {
        return distance_L2_Simple.evalMetric(a, b_idx, size);
    }
    template &lt;typename U, typename V&gt;
    inline DistanceType accum_dist(const U a, const V b, const size_t idx) const
    {
        return distance_L2_Simple.accum_dist(a, b, idx);
    }
};
struct metric_L1 : public Metric
{
    template &lt;class T, class DataSource, typename AccessorType = uint32_t&gt;
    struct traits
    {
        using distance_t = L1_Adaptor&lt;T, DataSource, T, AccessorType&gt;;
    };
};
struct metric_L2 : public Metric
{
    template &lt;class T, class DataSource, typename AccessorType = uint32_t&gt;
    struct traits
    {
        using distance_t = L2_Adaptor&lt;T, DataSource, T, AccessorType&gt;;
    };
};
struct metric_L2_Simple : public Metric
{
    template &lt;class T, class DataSource, typename AccessorType = uint32_t&gt;
    struct traits
    {
        using distance_t = L2_Simple_Adaptor&lt;T, DataSource, T, AccessorType&gt;;
    };
};
struct metric_SO2 : public Metric
{
    template &lt;class T, class DataSource, typename AccessorType = uint32_t&gt;
    struct traits
    {
        using distance_t = SO2_Adaptor&lt;T, DataSource, T, AccessorType&gt;;
    };
};
struct metric_SO3 : public Metric
{
    template &lt;class T, class DataSource, typename AccessorType = uint32_t&gt;
    struct traits
    {
        using distance_t = SO3_Adaptor&lt;T, DataSource, T, AccessorType&gt;;
    };
};
struct KDTreeSingleIndexAdaptorParams
{
    KDTreeSingleIndexAdaptorParams(size_t _leaf_max_size = 10)
        : leaf_max_size(_leaf_max_size)
    {
    }
    size_t leaf_max_size;
};
struct SearchParams
{
    SearchParams(int checks_IGNORED_ = 32, float eps_ = 0, bool sorted_ = true)
        : checks(checks_IGNORED_), eps(eps_), sorted(sorted_)
    {
    }
    int checks;  //!&lt; Ignored parameter (Kept for compatibility with the FLANN
    float eps;  //!&lt; search for eps-approximate neighbours (default: 0)
    bool  sorted;  //!&lt; only for radius search, require neighbours sorted by
};
template &lt;typename T&gt;
inline T* allocate(size_t count = 1)
{
    T* mem = static_cast&lt;T*&gt;(::malloc(sizeof(T) * count));
    return mem;
}
const size_t WORDSIZE  = 16;
const size_t BLOCKSIZE = 8192;
class PooledAllocator
{
    using Offset    = uint32_t;
    using Size      = uint32_t;
    using Dimension = int32_t;
    Size  remaining;     void* base;     void* loc; 
    void internal_init()
    {
        remaining    = 0;
        base         = nullptr;
        usedMemory   = 0;
        wastedMemory = 0;
    }
   public:
    Size usedMemory;
    Size wastedMemory;
    PooledAllocator() { internal_init(); }
    ~PooledAllocator() { free_all(); }
    void free_all()
    {
        while (base != nullptr)
        {
            void* prev =
                *(static_cast&lt;void**&gt;(base));             ::free(base);
            base = prev;
        }
        internal_init();
    }
    void* malloc(const size_t req_size)
    {
        const Size size = (req_size + (WORDSIZE - 1)) &amp; ~(WORDSIZE - 1);
        if (size &gt; remaining)
        {
            wastedMemory += remaining;
            const Size blocksize =
                (size + sizeof(void*) + (WORDSIZE - 1) &gt; BLOCKSIZE)
                    ? size + sizeof(void*) + (WORDSIZE - 1)
                    : BLOCKSIZE;
            void* m = ::malloc(blocksize);
            if (!m)
            {
                fprintf(stderr, "Failed to allocate memory.\n");
                throw std::bad_alloc();
            }
            static_cast&lt;void**&gt;(m)[0] = base;
            base                      = m;
            Size shift = 0;
            remaining = blocksize - sizeof(void*) - shift;
            loc       = (static_cast&lt;char*&gt;(m) + sizeof(void*) + shift);
        }
        void* rloc = loc;
        loc        = static_cast&lt;char*&gt;(loc) + size;
        remaining -= size;
        usedMemory += size;
        return rloc;
    }
    template &lt;typename T&gt;
    T* allocate(const size_t count = 1)
    {
        T* mem = static_cast&lt;T*&gt;(this-&gt;malloc(sizeof(T) * count));
        return mem;
    }
};
template &lt;int32_t DIM, typename T&gt;
struct array_or_vector_selector
{
    using container_t = std::array&lt;T, DIM&gt;;
};
template &lt;typename T&gt;
struct array_or_vector_selector&lt;-1, T&gt;
{
    using container_t = std::vector&lt;T&gt;;
};
template &lt;
    class Derived, typename Distance, class DatasetAdaptor, int32_t DIM = -1,
    typename AccessorType = uint32_t&gt;
class KDTreeBaseClass
{
   public:
    void freeIndex(Derived&amp; obj)
    {
        obj.pool.free_all();
        obj.root_node             = nullptr;
        obj.m_size_at_index_build = 0;
    }
    using ElementType  = typename Distance::ElementType;
    using DistanceType = typename Distance::DistanceType;
    std::vector&lt;AccessorType&gt; vAcc;
    using Offset    = typename decltype(vAcc)::size_type;
    using Size      = typename decltype(vAcc)::size_type;
    using Dimension = int32_t;
    struct Node
    {
        union
        {
            struct leaf
            {
                Offset left, right;  //!&lt; Indices of points in leaf node
            } lr;
            struct nonleaf
            {
                Dimension    divfeat;  //!&lt; Dimension used for subdivision.
                DistanceType divlow,
                    divhigh;  //!&lt; The values used for subdivision.
            } sub;
        } node_type;
        Node *child1, *child2;
    };
    using NodePtr = Node*;
    struct Interval
    {
        ElementType low, high;
    };
    NodePtr root_node;
    Size m_leaf_max_size;
    Size m_size;  //!&lt; Number of current points in the dataset
    Size m_size_at_index_build;  //!&lt; Number of points in the dataset when the
    Dimension dim;  //!&lt; Dimensionality of each data point
    using BoundingBox =
        typename array_or_vector_selector&lt;DIM, Interval&gt;::container_t;
    using distance_vector_t =
        typename array_or_vector_selector&lt;DIM, DistanceType&gt;::container_t;
    BoundingBox root_bbox;
    PooledAllocator pool;
    Size size(const Derived&amp; obj) const { return obj.m_size; }
    Size veclen(const Derived&amp; obj) { return DIM &gt; 0 ? DIM : obj.dim; }
    inline ElementType dataset_get(
        const Derived&amp; obj, AccessorType element, Dimension component) const
    {
        return obj.dataset.kdtree_get_pt(element, component);
    }
    Size usedMemory(Derived&amp; obj)
    {
        return obj.pool.usedMemory + obj.pool.wastedMemory +
               obj.dataset.kdtree_get_point_count() *
                   sizeof(AccessorType);      }
    void computeMinMax(
        const Derived&amp; obj, Offset ind, Size count, Dimension element,
        ElementType&amp; min_elem, ElementType&amp; max_elem)
    {
        min_elem = dataset_get(obj, vAcc[ind], element);
        max_elem = min_elem;
        for (Offset i = 1; i &lt; count; ++i)
        {
            ElementType val = dataset_get(obj, vAcc[ind + i], element);
            if (val &lt; min_elem) min_elem = val;
            if (val &gt; max_elem) max_elem = val;
        }
    }
    NodePtr divideTree(
        Derived&amp; obj, const Offset left, const Offset right, BoundingBox&amp; bbox)
    {
        NodePtr node = obj.pool.template allocate&lt;Node&gt;();  
        if ((right - left) &lt;= static_cast&lt;Offset&gt;(obj.m_leaf_max_size))
        {
            node-&gt;child1 = node-&gt;child2 = nullptr;             node-&gt;node_type.lr.left     = left;
            node-&gt;node_type.lr.right    = right;
            for (Dimension i = 0; i &lt; (DIM &gt; 0 ? DIM : obj.dim); ++i)
            {
                bbox[i].low  = dataset_get(obj, obj.vAcc[left], i);
                bbox[i].high = dataset_get(obj, obj.vAcc[left], i);
            }
            for (Offset k = left + 1; k &lt; right; ++k)
            {
                for (Dimension i = 0; i &lt; (DIM &gt; 0 ? DIM : obj.dim); ++i)
                {
                    if (bbox[i].low &gt; dataset_get(obj, obj.vAcc[k], i))
                        bbox[i].low = dataset_get(obj, obj.vAcc[k], i);
                    if (bbox[i].high &lt; dataset_get(obj, obj.vAcc[k], i))
                        bbox[i].high = dataset_get(obj, obj.vAcc[k], i);
                }
            }
        }
        else
        {
            Offset       idx;
            Dimension    cutfeat;
            DistanceType cutval;
            middleSplit_(obj, left, right - left, idx, cutfeat, cutval, bbox);
            node-&gt;node_type.sub.divfeat = cutfeat;
            BoundingBox left_bbox(bbox);
            left_bbox[cutfeat].high = cutval;
            node-&gt;child1 = divideTree(obj, left, left + idx, left_bbox);
            BoundingBox right_bbox(bbox);
            right_bbox[cutfeat].low = cutval;
            node-&gt;child2 = divideTree(obj, left + idx, right, right_bbox);
            node-&gt;node_type.sub.divlow  = left_bbox[cutfeat].high;
            node-&gt;node_type.sub.divhigh = right_bbox[cutfeat].low;
            for (Dimension i = 0; i &lt; (DIM &gt; 0 ? DIM : obj.dim); ++i)
            {
                bbox[i].low  = std::min(left_bbox[i].low, right_bbox[i].low);
                bbox[i].high = std::max(left_bbox[i].high, right_bbox[i].high);
            }
        }
        return node;
    }
    void middleSplit_(
        Derived&amp; obj, Offset ind, Size count, Offset&amp; index, Dimension&amp; cutfeat,
        DistanceType&amp; cutval, const BoundingBox&amp; bbox)
    {
        const auto  EPS      = static_cast&lt;DistanceType&gt;(0.00001);
        ElementType max_span = bbox[0].high - bbox[0].low;
        for (Dimension i = 1; i &lt; (DIM &gt; 0 ? DIM : obj.dim); ++i)
        {
            ElementType span = bbox[i].high - bbox[i].low;
            if (span &gt; max_span) { max_span = span; }
        }
        ElementType max_spread = -1;
        cutfeat                = 0;
        for (Dimension i = 0; i &lt; (DIM &gt; 0 ? DIM : obj.dim); ++i)
        {
            ElementType span = bbox[i].high - bbox[i].low;
            if (span &gt; (1 - EPS) * max_span)
            {
                ElementType min_elem, max_elem;
                computeMinMax(obj, ind, count, i, min_elem, max_elem);
                ElementType spread = max_elem - min_elem;
                if (spread &gt; max_spread)
                {
                    cutfeat    = i;
                    max_spread = spread;
                }
            }
        }
        DistanceType split_val = (bbox[cutfeat].low + bbox[cutfeat].high) / 2;
        ElementType  min_elem, max_elem;
        computeMinMax(obj, ind, count, cutfeat, min_elem, max_elem);
        if (split_val &lt; min_elem)
            cutval = min_elem;
        else if (split_val &gt; max_elem)
            cutval = max_elem;
        else
            cutval = split_val;
        Offset lim1, lim2;
        planeSplit(obj, ind, count, cutfeat, cutval, lim1, lim2);
        if (lim1 &gt; count / 2)
            index = lim1;
        else if (lim2 &lt; count / 2)
            index = lim2;
        else
            index = count / 2;
    }
    void planeSplit(
        Derived&amp; obj, Offset ind, const Size count, Dimension cutfeat,
        DistanceType&amp; cutval, Offset&amp; lim1, Offset&amp; lim2)
    {
        Offset left  = 0;
        Offset right = count - 1;
        for (;;)
        {
            while (left &lt;= right &amp;&amp;
                   dataset_get(obj, vAcc[ind + left], cutfeat) &lt; cutval)
                ++left;
            while (right &amp;&amp; left &lt;= right &amp;&amp;
                   dataset_get(obj, vAcc[ind + right], cutfeat) &gt;= cutval)
                --right;
            if (left &gt; right || !right)
                break;              std::swap(vAcc[ind + left], vAcc[ind + right]);
            ++left;
            --right;
        }
        lim1  = left;
        right = count - 1;
        for (;;)
        {
            while (left &lt;= right &amp;&amp;
                   dataset_get(obj, vAcc[ind + left], cutfeat) &lt;= cutval)
                ++left;
            while (right &amp;&amp; left &lt;= right &amp;&amp;
                   dataset_get(obj, vAcc[ind + right], cutfeat) &gt; cutval)
                --right;
            if (left &gt; right || !right)
                break;              std::swap(vAcc[ind + left], vAcc[ind + right]);
            ++left;
            --right;
        }
        lim2 = left;
    }
    DistanceType computeInitialDistances(
        const Derived&amp; obj, const ElementType* vec,
        distance_vector_t&amp; dists) const
    {
        assert(vec);
        DistanceType distsq = DistanceType();
        for (Dimension i = 0; i &lt; (DIM &gt; 0 ? DIM : obj.dim); ++i)
        {
            if (vec[i] &lt; obj.root_bbox[i].low)
            {
                dists[i] =
                    obj.distance.accum_dist(vec[i], obj.root_bbox[i].low, i);
                distsq += dists[i];
            }
            if (vec[i] &gt; obj.root_bbox[i].high)
            {
                dists[i] =
                    obj.distance.accum_dist(vec[i], obj.root_bbox[i].high, i);
                distsq += dists[i];
            }
        }
        return distsq;
    }
    void save_tree(Derived&amp; obj, std::ostream&amp; stream, NodePtr tree)
    {
        save_value(stream, *tree);
        if (tree-&gt;child1 != nullptr) { save_tree(obj, stream, tree-&gt;child1); }
        if (tree-&gt;child2 != nullptr) { save_tree(obj, stream, tree-&gt;child2); }
    }
    void load_tree(Derived&amp; obj, std::istream&amp; stream, NodePtr&amp; tree)
    {
        tree = obj.pool.template allocate&lt;Node&gt;();
        load_value(stream, *tree);
        if (tree-&gt;child1 != nullptr) { load_tree(obj, stream, tree-&gt;child1); }
        if (tree-&gt;child2 != nullptr) { load_tree(obj, stream, tree-&gt;child2); }
    }
    void saveIndex_(Derived&amp; obj, std::ostream&amp; stream)
    {
        save_value(stream, obj.m_size);
        save_value(stream, obj.dim);
        save_value(stream, obj.root_bbox);
        save_value(stream, obj.m_leaf_max_size);
        save_value(stream, obj.vAcc);
        save_tree(obj, stream, obj.root_node);
    }
    void loadIndex_(Derived&amp; obj, std::istream&amp; stream)
    {
        load_value(stream, obj.m_size);
        load_value(stream, obj.dim);
        load_value(stream, obj.root_bbox);
        load_value(stream, obj.m_leaf_max_size);
        load_value(stream, obj.vAcc);
        load_tree(obj, stream, obj.root_node);
    }
};
template &lt;
    typename Distance, class DatasetAdaptor, int32_t DIM = -1,
    typename AccessorType = uint32_t&gt;
class KDTreeSingleIndexAdaptor
    : public KDTreeBaseClass&lt;
          KDTreeSingleIndexAdaptor&lt;Distance, DatasetAdaptor, DIM, AccessorType&gt;,
          Distance, DatasetAdaptor, DIM, AccessorType&gt;
{
   public:
    KDTreeSingleIndexAdaptor(const KDTreeSingleIndexAdaptor&lt;
                             Distance, DatasetAdaptor, DIM, AccessorType&gt;&amp;) =
        delete;
    const DatasetAdaptor&amp; dataset;  //!&lt; The source of our data
    const KDTreeSingleIndexAdaptorParams index_params;
    Distance distance;
    using BaseClassRef = typename nanoflann::KDTreeBaseClass&lt;
        nanoflann::KDTreeSingleIndexAdaptor&lt;
            Distance, DatasetAdaptor, DIM, AccessorType&gt;,
        Distance, DatasetAdaptor, DIM, AccessorType&gt;;
    using Offset    = typename BaseClassRef::Offset;
    using Size      = typename BaseClassRef::Size;
    using Dimension = typename BaseClassRef::Dimension;
    using ElementType  = typename BaseClassRef::ElementType;
    using DistanceType = typename BaseClassRef::DistanceType;
    using Node    = typename BaseClassRef::Node;
    using NodePtr = Node*;
    using Interval = typename BaseClassRef::Interval;
    using BoundingBox = typename BaseClassRef::BoundingBox;
    using distance_vector_t = typename BaseClassRef::distance_vector_t;
    template &lt;class... Args&gt;
    KDTreeSingleIndexAdaptor(
        const Dimension dimensionality, const DatasetAdaptor&amp; inputData,
        const KDTreeSingleIndexAdaptorParams&amp; params = {}, Args&amp;&amp;... args)
        : dataset(inputData),
          index_params(params),
          distance(inputData, std::forward&lt;Args&gt;(args)...)
    {
        BaseClassRef::root_node             = nullptr;
        BaseClassRef::m_size                = dataset.kdtree_get_point_count();
        BaseClassRef::m_size_at_index_build = BaseClassRef::m_size;
        BaseClassRef::dim                   = dimensionality;
        if (DIM &gt; 0) BaseClassRef::dim = DIM;
        BaseClassRef::m_leaf_max_size = params.leaf_max_size;
        buildIndex();
    }
    void buildIndex()
    {
        BaseClassRef::m_size                = dataset.kdtree_get_point_count();
        BaseClassRef::m_size_at_index_build = BaseClassRef::m_size;
        init_vind();
        this-&gt;freeIndex(*this);
        BaseClassRef::m_size_at_index_build = BaseClassRef::m_size;
        if (BaseClassRef::m_size == 0) return;
        computeBoundingBox(BaseClassRef::root_bbox);
        BaseClassRef::root_node = this-&gt;divideTree(
            *this, 0, BaseClassRef::m_size,
            BaseClassRef::root_bbox);      }
    template &lt;typename RESULTSET&gt;
    bool findNeighbors(
        RESULTSET&amp; result, const ElementType* vec,
        const SearchParams&amp; searchParams) const
    {
        assert(vec);
        if (this-&gt;size(*this) == 0) return false;
        if (!BaseClassRef::root_node)
            throw std::runtime_error(
                "[nanoflann] findNeighbors() called before building the "
                "index.");
        float epsError = 1 + searchParams.eps;
        distance_vector_t
             dists;          auto zero = static_cast&lt;decltype(result.worstDist())&gt;(0);
        assign(
            dists, (DIM &gt; 0 ? DIM : BaseClassRef::dim),
            zero);          DistanceType distsq = this-&gt;computeInitialDistances(*this, vec, dists);
        searchLevel(
            result, vec, BaseClassRef::root_node, distsq, dists,
            epsError);          return result.full();
    }
    Size knnSearch(
        const ElementType* query_point, const Size num_closest,
        AccessorType* out_indices, DistanceType* out_distances_sq,
        const int     {
        nanoflann::KNNResultSet&lt;DistanceType, AccessorType&gt; resultSet(
            num_closest);
        resultSet.init(out_indices, out_distances_sq);
        this-&gt;findNeighbors(resultSet, query_point, nanoflann::SearchParams());
        return resultSet.size();
    }
    Size radiusSearch(
        const ElementType* query_point, const DistanceType&amp; radius,
        std::vector&lt;std::pair&lt;AccessorType, DistanceType&gt;&gt;&amp; IndicesDists,
        const SearchParams&amp;                                 searchParams) const
    {
        RadiusResultSet&lt;DistanceType, AccessorType&gt; resultSet(
            radius, IndicesDists);
        const Size nFound =
            radiusSearchCustomCallback(query_point, resultSet, searchParams);
        if (searchParams.sorted)
            std::sort(
                IndicesDists.begin(), IndicesDists.end(), IndexDist_Sorter());
        return nFound;
    }
    template &lt;class SEARCH_CALLBACK&gt;
    Size radiusSearchCustomCallback(
        const ElementType* query_point, SEARCH_CALLBACK&amp; resultSet,
        const SearchParams&amp; searchParams = SearchParams()) const
    {
        this-&gt;findNeighbors(resultSet, query_point, searchParams);
        return resultSet.size();
    }
   public:
    void init_vind()
    {
        BaseClassRef::m_size = dataset.kdtree_get_point_count();
        if (BaseClassRef::vAcc.size() != BaseClassRef::m_size)
            BaseClassRef::vAcc.resize(BaseClassRef::m_size);
        for (Size i = 0; i &lt; BaseClassRef::m_size; i++)
            BaseClassRef::vAcc[i] = i;
    }
    void computeBoundingBox(BoundingBox&amp; bbox)
    {
        resize(bbox, (DIM &gt; 0 ? DIM : BaseClassRef::dim));
        if (dataset.kdtree_get_bbox(bbox))
        {
        }
        else
        {
            const Size N = dataset.kdtree_get_point_count();
            if (!N)
                throw std::runtime_error(
                    "[nanoflann] computeBoundingBox() called but "
                    "no data points found.");
            for (Dimension i = 0; i &lt; (DIM &gt; 0 ? DIM : BaseClassRef::dim); ++i)
            {
                bbox[i].low = bbox[i].high =
                    this-&gt;dataset_get(*this, BaseClassRef::vAcc[0], i);
            }
            for (Offset k = 1; k &lt; N; ++k)
            {
                for (Dimension i = 0; i &lt; (DIM &gt; 0 ? DIM : BaseClassRef::dim);
                     ++i)
                {
                    if (this-&gt;dataset_get(*this, BaseClassRef::vAcc[k], i) &lt;
                        bbox[i].low)
                        bbox[i].low =
                            this-&gt;dataset_get(*this, BaseClassRef::vAcc[k], i);
                    if (this-&gt;dataset_get(*this, BaseClassRef::vAcc[k], i) &gt;
                        bbox[i].high)
                        bbox[i].high =
                            this-&gt;dataset_get(*this, BaseClassRef::vAcc[k], i);
                }
            }
        }
    }
    template &lt;class RESULTSET&gt;
    bool searchLevel(
        RESULTSET&amp; result_set, const ElementType* vec, const NodePtr node,
        DistanceType mindistsq, distance_vector_t&amp; dists,
        const float epsError) const
    {
        if ((node-&gt;child1 == nullptr) &amp;&amp; (node-&gt;child2 == nullptr))
        {
            DistanceType worst_dist = result_set.worstDist();
            for (Offset i = node-&gt;node_type.lr.left;
                 i &lt; node-&gt;node_type.lr.right; ++i)
            {
                const AccessorType accessor =
                    BaseClassRef::vAcc[i];                  DistanceType dist = distance.evalMetric(
                    vec, accessor, (DIM &gt; 0 ? DIM : BaseClassRef::dim));
                if (dist &lt; worst_dist)
                {
                    if (!result_set.addPoint(dist, BaseClassRef::vAcc[i]))
                    {
                        return false;
                    }
                }
            }
            return true;
        }
        Dimension    idx   = node-&gt;node_type.sub.divfeat;
        ElementType  val   = vec[idx];
        DistanceType diff1 = val - node-&gt;node_type.sub.divlow;
        DistanceType diff2 = val - node-&gt;node_type.sub.divhigh;
        NodePtr      bestChild;
        NodePtr      otherChild;
        DistanceType cut_dist;
        if ((diff1 + diff2) &lt; 0)
        {
            bestChild  = node-&gt;child1;
            otherChild = node-&gt;child2;
            cut_dist =
                distance.accum_dist(val, node-&gt;node_type.sub.divhigh, idx);
        }
        else
        {
            bestChild  = node-&gt;child2;
            otherChild = node-&gt;child1;
            cut_dist =
                distance.accum_dist(val, node-&gt;node_type.sub.divlow, idx);
        }
        if (!searchLevel(
                result_set, vec, bestChild, mindistsq, dists, epsError))
        {
            return false;
        }
        DistanceType dst = dists[idx];
        mindistsq        = mindistsq + cut_dist - dst;
        dists[idx]       = cut_dist;
        if (mindistsq * epsError &lt;= result_set.worstDist())
        {
            if (!searchLevel(
                    result_set, vec, otherChild, mindistsq, dists, epsError))
            {
                return false;
            }
        }
        dists[idx] = dst;
        return true;
    }
   public:
    void saveIndex(std::ostream&amp; stream) { this-&gt;saveIndex_(*this, stream); }
    void loadIndex(std::istream&amp; stream) { this-&gt;loadIndex_(*this, stream); }
};  
template &lt;
    typename Distance, class DatasetAdaptor, int32_t DIM = -1,
    typename AccessorType = uint32_t&gt;
class KDTreeSingleIndexDynamicAdaptor_
    : public KDTreeBaseClass&lt;
          KDTreeSingleIndexDynamicAdaptor_&lt;
              Distance, DatasetAdaptor, DIM, AccessorType&gt;,
          Distance, DatasetAdaptor, DIM, AccessorType&gt;
{
   public:
    const DatasetAdaptor&amp; dataset;  //!&lt; The source of our data
    KDTreeSingleIndexAdaptorParams index_params;
    std::vector&lt;int&gt;&amp; treeIndex;
    Distance distance;
    using BaseClassRef = typename nanoflann::KDTreeBaseClass&lt;
        nanoflann::KDTreeSingleIndexDynamicAdaptor_&lt;
            Distance, DatasetAdaptor, DIM, AccessorType&gt;,
        Distance, DatasetAdaptor, DIM, AccessorType&gt;;
    using ElementType  = typename BaseClassRef::ElementType;
    using DistanceType = typename BaseClassRef::DistanceType;
    using Offset    = typename BaseClassRef::Offset;
    using Size      = typename BaseClassRef::Size;
    using Dimension = typename BaseClassRef::Dimension;
    using Node    = typename BaseClassRef::Node;
    using NodePtr = Node*;
    using Interval = typename BaseClassRef::Interval;
    using BoundingBox = typename BaseClassRef::BoundingBox;
    using distance_vector_t = typename BaseClassRef::distance_vector_t;
    KDTreeSingleIndexDynamicAdaptor_(
        const Dimension dimensionality, const DatasetAdaptor&amp; inputData,
        std::vector&lt;int&gt;&amp;                     treeIndex_,
        const KDTreeSingleIndexAdaptorParams&amp; params =
            KDTreeSingleIndexAdaptorParams())
        : dataset(inputData),
          index_params(params),
          treeIndex(treeIndex_),
          distance(inputData)
    {
        BaseClassRef::root_node             = nullptr;
        BaseClassRef::m_size                = 0;
        BaseClassRef::m_size_at_index_build = 0;
        BaseClassRef::dim                   = dimensionality;
        if (DIM &gt; 0) BaseClassRef::dim = DIM;
        BaseClassRef::m_leaf_max_size = params.leaf_max_size;
    }
    KDTreeSingleIndexDynamicAdaptor_(
        const KDTreeSingleIndexDynamicAdaptor_&amp; rhs) = default;
    KDTreeSingleIndexDynamicAdaptor_ operator=(
        const KDTreeSingleIndexDynamicAdaptor_&amp; rhs)
    {
        KDTreeSingleIndexDynamicAdaptor_ tmp(rhs);
        std::swap(BaseClassRef::vAcc, tmp.BaseClassRef::vAcc);
        std::swap(
            BaseClassRef::m_leaf_max_size, tmp.BaseClassRef::m_leaf_max_size);
        std::swap(index_params, tmp.index_params);
        std::swap(treeIndex, tmp.treeIndex);
        std::swap(BaseClassRef::m_size, tmp.BaseClassRef::m_size);
        std::swap(
            BaseClassRef::m_size_at_index_build,
            tmp.BaseClassRef::m_size_at_index_build);
        std::swap(BaseClassRef::root_node, tmp.BaseClassRef::root_node);
        std::swap(BaseClassRef::root_bbox, tmp.BaseClassRef::root_bbox);
        std::swap(BaseClassRef::pool, tmp.BaseClassRef::pool);
        return *this;
    }
    void buildIndex()
    {
        BaseClassRef::m_size = BaseClassRef::vAcc.size();
        this-&gt;freeIndex(*this);
        BaseClassRef::m_size_at_index_build = BaseClassRef::m_size;
        if (BaseClassRef::m_size == 0) return;
        computeBoundingBox(BaseClassRef::root_bbox);
        BaseClassRef::root_node = this-&gt;divideTree(
            *this, 0, BaseClassRef::m_size,
            BaseClassRef::root_bbox);      }
    template &lt;typename RESULTSET&gt;
    bool findNeighbors(
        RESULTSET&amp; result, const ElementType* vec,
        const SearchParams&amp; searchParams) const
    {
        assert(vec);
        if (this-&gt;size(*this) == 0) return false;
        if (!BaseClassRef::root_node) return false;
        float epsError = 1 + searchParams.eps;
        distance_vector_t dists;
        assign(
            dists, (DIM &gt; 0 ? DIM : BaseClassRef::dim),
            static_cast&lt;typename distance_vector_t::value_type&gt;(0));
        DistanceType distsq = this-&gt;computeInitialDistances(*this, vec, dists);
        searchLevel(
            result, vec, BaseClassRef::root_node, distsq, dists,
            epsError);          return result.full();
    }
    Size knnSearch(
        const ElementType* query_point, const Size num_closest,
        AccessorType* out_indices, DistanceType* out_distances_sq,
        const int     {
        nanoflann::KNNResultSet&lt;DistanceType, AccessorType&gt; resultSet(
            num_closest);
        resultSet.init(out_indices, out_distances_sq);
        this-&gt;findNeighbors(resultSet, query_point, nanoflann::SearchParams());
        return resultSet.size();
    }
    Size radiusSearch(
        const ElementType* query_point, const DistanceType&amp; radius,
        std::vector&lt;std::pair&lt;AccessorType, DistanceType&gt;&gt;&amp; IndicesDists,
        const SearchParams&amp;                                 searchParams) const
    {
        RadiusResultSet&lt;DistanceType, AccessorType&gt; resultSet(
            radius, IndicesDists);
        const size_t nFound =
            radiusSearchCustomCallback(query_point, resultSet, searchParams);
        if (searchParams.sorted)
            std::sort(
                IndicesDists.begin(), IndicesDists.end(), IndexDist_Sorter());
        return nFound;
    }
    template &lt;class SEARCH_CALLBACK&gt;
    Size radiusSearchCustomCallback(
        const ElementType* query_point, SEARCH_CALLBACK&amp; resultSet,
        const SearchParams&amp; searchParams = SearchParams()) const
    {
        this-&gt;findNeighbors(resultSet, query_point, searchParams);
        return resultSet.size();
    }
   public:
    void computeBoundingBox(BoundingBox&amp; bbox)
    {
        resize(bbox, (DIM &gt; 0 ? DIM : BaseClassRef::dim));
        if (dataset.kdtree_get_bbox(bbox))
        {
        }
        else
        {
            const Size N = BaseClassRef::m_size;
            if (!N)
                throw std::runtime_error(
                    "[nanoflann] computeBoundingBox() called but "
                    "no data points found.");
            for (Dimension i = 0; i &lt; (DIM &gt; 0 ? DIM : BaseClassRef::dim); ++i)
            {
                bbox[i].low = bbox[i].high =
                    this-&gt;dataset_get(*this, BaseClassRef::vAcc[0], i);
            }
            for (Offset k = 1; k &lt; N; ++k)
            {
                for (Dimension i = 0; i &lt; (DIM &gt; 0 ? DIM : BaseClassRef::dim);
                     ++i)
                {
                    if (this-&gt;dataset_get(*this, BaseClassRef::vAcc[k], i) &lt;
                        bbox[i].low)
                        bbox[i].low =
                            this-&gt;dataset_get(*this, BaseClassRef::vAcc[k], i);
                    if (this-&gt;dataset_get(*this, BaseClassRef::vAcc[k], i) &gt;
                        bbox[i].high)
                        bbox[i].high =
                            this-&gt;dataset_get(*this, BaseClassRef::vAcc[k], i);
                }
            }
        }
    }
    template &lt;class RESULTSET&gt;
    void searchLevel(
        RESULTSET&amp; result_set, const ElementType* vec, const NodePtr node,
        DistanceType mindistsq, distance_vector_t&amp; dists,
        const float epsError) const
    {
        if ((node-&gt;child1 == nullptr) &amp;&amp; (node-&gt;child2 == nullptr))
        {
            DistanceType worst_dist = result_set.worstDist();
            for (Offset i = node-&gt;node_type.lr.left;
                 i &lt; node-&gt;node_type.lr.right; ++i)
            {
                const AccessorType index =
                    BaseClassRef::vAcc[i];                  if (treeIndex[index] == -1) continue;
                DistanceType dist = distance.evalMetric(
                    vec, index, (DIM &gt; 0 ? DIM : BaseClassRef::dim));
                if (dist &lt; worst_dist)
                {
                    if (!result_set.addPoint(
                            static_cast&lt;typename RESULTSET::DistanceType&gt;(dist),
                            static_cast&lt;typename RESULTSET::IndexType&gt;(
                                BaseClassRef::vAcc[i])))
                    {
                        return;                      }
                }
            }
            return;
        }
        Dimension    idx   = node-&gt;node_type.sub.divfeat;
        ElementType  val   = vec[idx];
        DistanceType diff1 = val - node-&gt;node_type.sub.divlow;
        DistanceType diff2 = val - node-&gt;node_type.sub.divhigh;
        NodePtr      bestChild;
        NodePtr      otherChild;
        DistanceType cut_dist;
        if ((diff1 + diff2) &lt; 0)
        {
            bestChild  = node-&gt;child1;
            otherChild = node-&gt;child2;
            cut_dist =
                distance.accum_dist(val, node-&gt;node_type.sub.divhigh, idx);
        }
        else
        {
            bestChild  = node-&gt;child2;
            otherChild = node-&gt;child1;
            cut_dist =
                distance.accum_dist(val, node-&gt;node_type.sub.divlow, idx);
        }
        searchLevel(result_set, vec, bestChild, mindistsq, dists, epsError);
        DistanceType dst = dists[idx];
        mindistsq        = mindistsq + cut_dist - dst;
        dists[idx]       = cut_dist;
        if (mindistsq * epsError &lt;= result_set.worstDist())
        {
            searchLevel(
                result_set, vec, otherChild, mindistsq, dists, epsError);
        }
        dists[idx] = dst;
    }
   public:
    void saveIndex(std::ostream&amp; stream) { this-&gt;saveIndex_(*this, stream); }
    void loadIndex(std::istream&amp; stream) { this-&gt;loadIndex_(*this, stream); }
};
template &lt;
    typename Distance, class DatasetAdaptor, int32_t DIM = -1,
    typename AccessorType = uint32_t&gt;
class KDTreeSingleIndexDynamicAdaptor
{
   public:
    using ElementType  = typename Distance::ElementType;
    using DistanceType = typename Distance::DistanceType;
    using Offset = typename KDTreeSingleIndexDynamicAdaptor_&lt;
        Distance, DatasetAdaptor, DIM&gt;::Offset;
    using Size = typename KDTreeSingleIndexDynamicAdaptor_&lt;
        Distance, DatasetAdaptor, DIM&gt;::Size;
    using Dimension = typename KDTreeSingleIndexDynamicAdaptor_&lt;
        Distance, DatasetAdaptor, DIM&gt;::Dimension;
   protected:
    Size m_leaf_max_size;
    Size treeCount;
    Size pointCount;
    const DatasetAdaptor&amp; dataset;  //!&lt; The source of our data
    std::vector&lt;int&gt;
        treeIndex;  //!&lt; treeIndex[idx] is the index of tree in which
    KDTreeSingleIndexAdaptorParams index_params;
    Dimension dim;  //!&lt; Dimensionality of each data point
    using index_container_t =
        KDTreeSingleIndexDynamicAdaptor_&lt;Distance, DatasetAdaptor, DIM&gt;;
    std::vector&lt;index_container_t&gt; index;
   public:
    const std::vector&lt;index_container_t&gt;&amp; getAllIndices() const
    {
        return index;
    }
   private:
    int First0Bit(AccessorType num)
    {
        int pos = 0;
        while (num &amp; 1)
        {
            num = num &gt;&gt; 1;
            pos++;
        }
        return pos;
    }
    void init()
    {
        using my_kd_tree_t =
            KDTreeSingleIndexDynamicAdaptor_&lt;Distance, DatasetAdaptor, DIM&gt;;
        std::vector&lt;my_kd_tree_t&gt; index_(
            treeCount,
        index = index_;
    }
   public:
    Distance distance;
    KDTreeSingleIndexDynamicAdaptor(
        const int dimensionality, const DatasetAdaptor&amp; inputData,
        const KDTreeSingleIndexAdaptorParams&amp; params =
            KDTreeSingleIndexAdaptorParams(),
        const size_t maximumPointCount = 1000000000U)
        : dataset(inputData), index_params(params), distance(inputData)
    {
        treeCount  = static_cast&lt;size_t&gt;(std::log2(maximumPointCount));
        pointCount = 0U;
        dim        = dimensionality;
        treeIndex.clear();
        if (DIM &gt; 0) dim = DIM;
        m_leaf_max_size = params.leaf_max_size;
        init();
        const size_t num_initial_points = dataset.kdtree_get_point_count();
        if (num_initial_points &gt; 0) { addPoints(0, num_initial_points - 1); }
    }
    KDTreeSingleIndexDynamicAdaptor(
        const KDTreeSingleIndexDynamicAdaptor&lt;
            Distance, DatasetAdaptor, DIM, AccessorType&gt;&amp;) = delete;
    void addPoints(AccessorType start, AccessorType end)
    {
        Size count = end - start + 1;
        treeIndex.resize(treeIndex.size() + count);
        for (AccessorType idx = start; idx &lt;= end; idx++)
        {
            int pos = First0Bit(pointCount);
            index[pos].vAcc.clear();
            treeIndex[pointCount] = pos;
            for (int i = 0; i &lt; pos; i++)
            {
                for (int j = 0; j &lt; static_cast&lt;int&gt;(index[i].vAcc.size()); j++)
                {
                    index[pos].vAcc.push_back(index[i].vAcc[j]);
                    if (treeIndex[index[i].vAcc[j]] != -1)
                        treeIndex[index[i].vAcc[j]] = pos;
                }
                index[i].vAcc.clear();
                index[i].freeIndex(index[i]);
            }
            index[pos].vAcc.push_back(idx);
            index[pos].buildIndex();
            pointCount++;
        }
    }
    void removePoint(size_t idx)
    {
        if (idx &gt;= pointCount) return;
        treeIndex[idx] = -1;
    }
    template &lt;typename RESULTSET&gt;
    bool findNeighbors(
        RESULTSET&amp; result, const ElementType* vec,
        const SearchParams&amp; searchParams) const
    {
        for (size_t i = 0; i &lt; treeCount; i++)
        { index[i].findNeighbors(result, &amp;vec[0], searchParams); }
        return result.full();
    }
};
template &lt;
    class MatrixType, int32_t DIM = -1, class Distance = nanoflann::metric_L2,
    bool row_major = true&gt;
struct KDTreeEigenMatrixAdaptor
{
    using self_t =
        KDTreeEigenMatrixAdaptor&lt;MatrixType, DIM, Distance, row_major&gt;;
    using num_t     = typename MatrixType::Scalar;
    using IndexType = typename MatrixType::Index;
    using metric_t  = typename Distance::template traits&lt;
        num_t, self_t, IndexType&gt;::distance_t;
    using index_t = KDTreeSingleIndexAdaptor&lt;
        metric_t, self_t,
        row_major ? MatrixType::ColsAtCompileTime
                  : MatrixType::RowsAtCompileTime,
        IndexType&gt;;
    index_t* index;  //! The kd-tree index for the user to call its methods as
    using Offset    = typename index_t::Offset;
    using Size      = typename index_t::Size;
    using Dimension = typename index_t::Dimension;
    KDTreeEigenMatrixAdaptor(
        const Dimension                                 dimensionality,
        const std::reference_wrapper&lt;const MatrixType&gt;&amp; mat,
        const int                                       leaf_max_size = 10)
        : m_data_matrix(mat)
    {
        const auto dims = row_major ? mat.get().cols() : mat.get().rows();
        if (static_cast&lt;Dimension&gt;(dims) != dimensionality)
            throw std::runtime_error(
                "Error: 'dimensionality' must match column count in data "
                "matrix");
        if (DIM &gt; 0 &amp;&amp; static_cast&lt;int32_t&gt;(dims) != DIM)
            throw std::runtime_error(
                "Data set dimensionality does not match the 'DIM' template "
                "argument");
        index = new index_t(
            dims, *this             nanoflann::KDTreeSingleIndexAdaptorParams(leaf_max_size));
        index-&gt;buildIndex();
    }
   public:
    KDTreeEigenMatrixAdaptor(const self_t&amp;) = delete;
    ~KDTreeEigenMatrixAdaptor() { delete index; }
    const std::reference_wrapper&lt;const MatrixType&gt; m_data_matrix;
    inline void query(
        const num_t* query_point, const Size num_closest,
        IndexType* out_indices, num_t* out_distances_sq,
        const int     {
        nanoflann::KNNResultSet&lt;num_t, IndexType&gt; resultSet(num_closest);
        resultSet.init(out_indices, out_distances_sq);
        index-&gt;findNeighbors(resultSet, query_point, nanoflann::SearchParams());
    }
    const self_t&amp; derived() const { return *this; }
    self_t&amp;       derived() { return *this; }
    inline Size kdtree_get_point_count() const
    {
        if (row_major)
            return m_data_matrix.get().rows();
        else
            return m_data_matrix.get().cols();
    }
<a name="0"></a>        inline num_t kdtree_get_pt(const IndexType idx, size_t dim) const
    {
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>        if (row_major)
            return m_data_matrix.get().coeff(idx, IndexType(dim));
        else
            return m_data_matrix.get().coeff(IndexType(dim), idx);
    }
    template &lt;class BBOX&gt;
    {
        return false;
    }
};  
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>benchmark_nanoflann_real.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include &lt;cstdlib&gt;
#include &lt;ctime&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;nanoflann.hpp&gt;
#include &lt;string&gt;
using namespace std;
using namespace nanoflann;
template &lt;typename T&gt; struct PointCloud {
  struct Point {
    T x, y, z;
  };
  std::vector&lt;Point&gt; pts;
  inline size_t kdtree_get_point_count() const { return pts.size(); }
<a name="0"></a>  inline T kdtree_get_pt(const size_t idx, const size_t dim) const {
    if (dim == 0)
      return pts[idx].x;
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    else if (dim == 1)
      return pts[idx].y;
    else
      return pts[idx].z;
  }
  template &lt;class BBOX&gt; bool kdtree_get_bbox(BBOX &amp;     return false;
  }
};</b></font>
template &lt;typename T&gt;
PointCloud&lt;T&gt; scanPointCloud(unsigned int &amp;N, string file) {
  ifstream read(file.c_str());
  string temp;
  getline(read, temp);
  vector&lt;vector&lt;T&gt;&gt; cloud;
  vector&lt;T&gt; tmp;
  T x, y, z, d;
  N = 0;
  while (read &gt;&gt; x &gt;&gt; y &gt;&gt; z &gt;&gt; d) {
    tmp.resize(3);
    tmp[0] = x;
    tmp[1] = y;
    tmp[2] = z;
    cloud.push_back(tmp);
    N++;
  }
  PointCloud&lt;T&gt; point;
  point.pts.resize(N);
  for (unsigned int i = 0; i &lt; N; i++) {
    point.pts[i].x = cloud[i][0];
    point.pts[i].y = cloud[i][1];
    point.pts[i].z = cloud[i][2];
  }
  return point;
}
template &lt;typename num_t&gt; void kdtree_demo(string &amp;path1, string &amp;path2) {
  PointCloud&lt;num_t&gt; PcloudS, PcloudT;
  unsigned int N;
  PcloudS = scanPointCloud&lt;num_t&gt;(N, path1);
  PcloudT = scanPointCloud&lt;num_t&gt;(N, path2);
  vector&lt;double&gt; buildTime, queryTime;
  unsigned int plotCount = 10;
  for (unsigned int i = 1; i &lt;= plotCount; i++) {
    unsigned int currSize = ((i * 1.0) / plotCount) * N;
    std::cout &lt;&lt; currSize &lt;&lt; " ";
    PointCloud&lt;num_t&gt; cloudS, cloudT;
    cloudS.pts.resize(currSize);
    cloudT.pts.resize(currSize);
    for (unsigned int j = 0; j &lt; currSize; j++) {
      cloudS.pts[j] = PcloudS.pts[j];
      cloudT.pts[j] = PcloudT.pts[j];
    }
    clock_t begin = clock();
    typedef KDTreeSingleIndexAdaptor&lt;
        L2_Simple_Adaptor&lt;num_t, PointCloud&lt;num_t&gt;&gt;, PointCloud&lt;num_t&gt;,
        3         &gt;
        my_kd_tree_t;
                       KDTreeSingleIndexAdaptorParams(10     index.buildIndex();
    clock_t end = clock();
    double elapsed_secs = double(end - begin) / CLOCKS_PER_SEC;
    buildTime.push_back(elapsed_secs);
    {
      double elapsed_secs = 0;
      for (unsigned int j = 0; j &lt; currSize; j++) {
        num_t query_pt[3];
        query_pt[0] = cloudT.pts[j].x;
        query_pt[1] = cloudT.pts[j].y;
        query_pt[2] = cloudT.pts[j].z;
        size_t ret_index;
        num_t out_dist_sqr;
        const size_t num_results = 1;
        KNNResultSet&lt;num_t&gt; resultSet(num_results);
        resultSet.init(&amp;ret_index, &amp;out_dist_sqr);
        clock_t begin = clock();
        index.findNeighbors(resultSet, &amp;query_pt[0],
                            nanoflann::SearchParams(10));
        clock_t end = clock();
        elapsed_secs += double(end - begin);
      }
      elapsed_secs /= CLOCKS_PER_SEC;
      queryTime.push_back(elapsed_secs / currSize);
    }
  }
  std::cout &lt;&lt; "\n";
  for (unsigned int i = 0; i &lt; buildTime.size(); i++)
    std::cout &lt;&lt; buildTime[i] &lt;&lt; " ";
  std::cout &lt;&lt; "\n";
  for (unsigned int i = 0; i &lt; queryTime.size(); i++)
    std::cout &lt;&lt; queryTime[i] &lt;&lt; " ";
  std::cout &lt;&lt; "\n";
}
int main(int argc, char **argv) {
  if (argc != 3) {
    cerr &lt;&lt; "**Running Instructions:**\n./benchmark_nanoflann_real dataFile1 "
            "dataFile"
         &lt;&lt; endl;
    return 0;
  }
  string dataFile1(argv[1]);
  string dataFile2(argv[2]);
  kdtree_demo&lt;double&gt;(dataFile1, dataFile2);
  return 0;
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
