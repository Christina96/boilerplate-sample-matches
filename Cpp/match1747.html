<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for ibex_Interval.cpp & ibex_ExprSimplify.cpp</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for ibex_Interval.cpp & ibex_ExprSimplify.cpp
      </h3>
      <h1 align="center">
        2.3%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>ibex_Interval.cpp (4.0%)<TH>ibex_ExprSimplify.cpp (1.6703786%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match1747-0.html#0',2,'match1747-1.html#0',3)" NAME="0">(268-280)<TD><A HREF="javascript:ZweiFrames('match1747-0.html#0',2,'match1747-1.html#0',3)" NAME="0">(384-387)</A><TD ALIGN=center><FONT COLOR="#ff0000">15</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>ibex_Interval.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* ============================================================================
 * I B E X - Interval definition
 * ============================================================================
 * Copyright   : IMT Atlantique (FRANCE)
 * License     : This program can be distributed under the terms of the GNU LGPL.
 *               See the file COPYING.LESSER.
 *
 * Author(s)   : Gilles Chabert
 * Created     : Dec 05, 2011
 * Last update : Oct 30, 2019
 * ---------------------------------------------------------------------------- */

#include &quot;ibex_Interval.h&quot;
#include &lt;float.h&gt;
#include &lt;cassert&gt;

namespace ibex {



#define INF_DIV(n,d) ((Interval(n)/Interval(d)).lb())
#define SUP_DIV(n,d) ((Interval(n)/Interval(d)).ub())

#define INF_MUL(x,y) ((Interval(x)*Interval(y)).lb())
#define SUP_MUL(x,y) ((Interval(x)*Interval(y)).ub())

void div2(const Interval&amp; num, const Interval&amp; div, Interval&amp; out1, Interval&amp; out2) {

	if (num.is_empty() || div.is_empty()) {
		out1.set_empty();
		out2.set_empty();
		return;
	}

	const double&amp; a(num.lb());
	const double&amp; b(num.ub());
	const double&amp; c(div.lb());
	const double&amp; d(div.ub());

	// notice : we do not consider 0/0=0 but 0/0=emptyset
	if (c==0 &amp;&amp; d==0) {
		out1.set_empty();
		out2.set_empty();
		return;
	}

	if (a==0 &amp;&amp; b==0) {
		out1 = num;
		out2.set_empty();
		return;
	}

	if (c&gt;0 || d&lt;0) {
		out1 = num/div;
		out2.set_empty();
		return;
	}

	if (b&lt;=0 &amp;&amp; d==0) {
		if (c==NEG_INFINITY)
			out1 = Interval::pos_reals();
		else
			out1 = Interval(INF_DIV(b,c), POS_INFINITY);
		out2.set_empty();
		return;
	}

	if (b&lt;=0 &amp;&amp; c&lt;0 &amp;&amp; d&gt;0) {
		if (b==0 || (c==NEG_INFINITY &amp;&amp; d==POS_INFINITY)) {
			out1 = Interval::all_reals();
			out2.set_empty();
			return;
		} else {
			out1 = Interval(NEG_INFINITY, d==POS_INFINITY? 0 : SUP_DIV(b,d));
			out2 = Interval(c==NEG_INFINITY? 0 : INF_DIV(b,c), POS_INFINITY);
			return;
		}
	}

	if (b&lt;=0 &amp;&amp; c==0) {
		if (d==POS_INFINITY)
			out1 = Interval::neg_reals();
		else
			out1 = Interval(NEG_INFINITY, SUP_DIV(b,d));
		out2.set_empty();
		return;
	}

	if (a&gt;=0 &amp;&amp; d==0) {
		if (c==NEG_INFINITY)
			out1 = Interval::neg_reals();
		else
			out1 = Interval(NEG_INFINITY, SUP_DIV(a,c));
		out2.set_empty();
		return;
	}

	if (a&gt;=0 &amp;&amp; c&lt;0 &amp;&amp; d&gt;0) {
		if (a==0 || (c==NEG_INFINITY &amp;&amp; d==POS_INFINITY)) {
			out1 = Interval::all_reals();
			out2.set_empty();
			return;
		} else {
			out1 = Interval(NEG_INFINITY, c==NEG_INFINITY? 0 : SUP_DIV(a,c));
			out2 = Interval(d==POS_INFINITY? 0 : INF_DIV(a,d), POS_INFINITY);
			return;
		}

	}

	if (a&gt;=0 &amp;&amp; c==0) {
		if (d==POS_INFINITY)
			out1 = Interval::pos_reals();
		else
			out1 = Interval(INF_DIV(a,d), POS_INFINITY);
		out2.set_empty();
		return;
	}

	out1 = Interval::all_reals();
	out2.set_empty();
}

bool Interval::div2_inter(const Interval&amp; num, const Interval&amp; div, Interval&amp; out2) {
	// warning: we may have &amp;num==this
	Interval out1,_out2;
	div2(num,div,out1,_out2);
	out1 &amp;= *this;
	if (out1.is_empty()) {
		*this &amp;= _out2;
		out2.set_empty();
		return !this-&gt;is_empty();
	} else {
		out2 = *this &amp; _out2;
		*this = out1;
		return true;
	}
}

Interval saw(const Interval&amp; x) {
	double u = round(x.ub());
	double l = round(x.lb());

	assert(l&lt;=u);

	if (l&lt;u) return Interval(-1,1);
	else {
		fpu_round_up();
		double du  = x.ub()-u;
		double dl  = l-x.lb();

		return Interval(-dl,du);
	}
}

bool bwd_saw(const Interval&amp; y_, Interval&amp; x) {

	if (y_.is_empty()) {
		x.set_empty();
		return false;
	}

	if (y_.lb()==0 &amp;&amp; y_.ub()==0) {
		// a very very frequent case,
		// handled separately just for efficiency
		// note: the interval [ceil(x.lb()),floor(x.ub())] can be empty (reversed bounds)
		return !(x &amp;= Interval(std::ceil(x.lb()),std::floor(x.ub()))).is_empty();
	}

	assert(sizeof(double)==8); // |mantissa|=53
	// 2^51 is a rough bound. Troubles start when |x|~2^53
	// that is, when we start jumping integers in the
	// double representation. In this case, no contraction
	// can be expected unless x is degenerated
	// or y is empty.
	// And we actually requires 2^51 and not 2^52 because we
	// need below to have midpoints between integers representable.
	if (x.mag()&gt;=std::pow(2,52)) {
		if (x.is_degenerated() &amp;&amp; !y_.contains(0)) {
			x.set_empty();
			return false;
		} else
			return true;
	}

	double l = round(x.lb());
	double u = round(x.ub());

	double half=1/2.0; // nice: 1/2 is exactly representable.

	Interval y = y_ &amp; Interval(-half,half);

	fpu_round_up();

	double xl;

	if (x.lb() &gt; l+y.ub()) { // l+y.ub() rounded upward
		xl = -(-(l+1)        // l+1=the next integer, no rounding should occur (see above)
		       - y.lb());    // note: (l+1)+y.lb() cannot be less than (l+1)-0.5, which is representable
		assert(xl&gt;=x.lb());  // hence xl&gt;=x.lb()
	} else {
		xl = -(-l - y.lb()); // l+y.lb() rounded downward
	}

	double xu;

	if (x.ub() &lt; -(-u-y.lb())) { // u+y.lb() rounded downward
		xu = (u-1)          // the previous integer, no rounding should occur (see above)
		     + y.ub();      // note: (u-1)+y.ub() cannot exceed (u-1)+0.5, which is representable
		assert(xu&lt;=x.ub()); // hence xu&lt;=x.ub()
	} else {
		xu = u + y.ub();
	}

	// note: [xl,xu] can be empty if xl&gt;xu.
	return !(x &amp;= Interval(xl,xu)).is_empty();
}

double Interval::delta(const Interval&amp; x) const {
	if (is_empty()) return 0;
	if (x.is_empty()) return diam();

	// ** warning **
	// checking if *this or x is infinite by
	// testing if the lower/upper bounds are -oo/+oo
	// is not enough because diam() may return +oo even
	// with finite bounds (e.g, very large intervals like [-DBL_MAX,DBL_MAX]).
    // (&quot;almost-unboundedness&quot;)

	volatile double d=diam();
	volatile double dx=x.diam();
	// furthermore, if these variables are not declared volatile
	// conditions like d==POS_INFINITY are evaluated
	// to FALSE for intervals like [-DBL_MAX,DBL_MAX] (with -O3 option)
	// while the returned expression (d-dx) evaluates to +oo (instead of 0).

	if (d==POS_INFINITY) {
		//cout &lt;&lt; &quot;d=&quot; &lt;&lt; d &lt;&lt; &quot; dx=&quot; &lt;&lt; dx &lt;&lt; endl;
		if (dx==POS_INFINITY) {
			double left=(x.lb()==NEG_INFINITY? 0 : x.lb()-lb());
			double right=(x.ub()==POS_INFINITY? 0 : ub()-x.ub());
			//cout &lt;&lt; &quot;left=&quot; &lt;&lt; left &lt;&lt; &quot; right=&quot; &lt;&lt; right &lt;&lt; endl;
			return left+right;
		} else
			return POS_INFINITY;
	}
	else return d-dx;
}

double Interval::ratiodelta(const Interval&amp; x) const {
	double d=delta(x);
	if (d==POS_INFINITY) return 1;
	double D=diam();
	return (D==0 || D==POS_INFINITY) ? 0.0 : (d/D); // if this.diam()=infinity here, necessarily d=0
}

std::pair&lt;Interval,Interval&gt; Interval::bisect(double ratio) const {

	assert(is_bisectable());
	assert(ratio&gt;0 &amp;&amp; ratio&lt;1);

	Interval left,right;

	if (lb()==NEG_INFINITY) {
<A NAME="0"></A>		if (ub()==POS_INFINITY) {
			left = Interval(NEG_INFINITY,0);
			right = Interval(0,POS_INFINITY);
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match1747-1.html#0',3,'match1747-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>		}
		else {
			left = Interval(NEG_INFINITY,-DBL_MAX);
			right = Interval(-DBL_MAX,ub());
		}
	}

	else if (ub()==POS_INFINITY) {
		left = Interval(lb(),DBL_MAX);
		right = Interval(DBL_MAX,POS_INFINITY);
	}

	else {</B></FONT>
		double point;
		if (ratio==0.5)
			point = mid();
		else {
			point = lb()+ratio*diam();

			// watch dog. note that since *this is
			// bisectable, we have next_float(left.lb()) &lt; ub()
			if (point &gt;= ub()) point=next_float(lb());
			assert(point&lt;ub());
		}
		left = Interval(lb(), point);
		right = Interval(point, ub());
	}

	return std::pair&lt;Interval,Interval&gt;(left,right);
}

int Interval::complementary(Interval&amp; c1, Interval&amp; c2, bool compactness) const {
	if (is_empty() || (compactness &amp;&amp; is_degenerated())) { // x.is_empty() should not happen if called from compl()
		c1=Interval::all_reals();
		c2=Interval::empty_set();
		return 1;
	}
	else {
		if (lb()&gt;NEG_INFINITY) {
			c1=Interval(NEG_INFINITY,lb());
			if (ub()&lt;POS_INFINITY) {
				c2=Interval(ub(),POS_INFINITY);
				return 2;
			} else {
				c2=Interval::empty_set();
				return 1;
			}
		} else if (ub()&lt;POS_INFINITY) {
			c1=Interval(ub(),POS_INFINITY);
			c2=Interval::empty_set();
			return 1;
		} else {
			c1=c2=Interval::empty_set();
			return 0;
		}
	}
}

int Interval::diff(const Interval&amp; y, Interval&amp; c1, Interval&amp; c2, bool compactness) const {
	const Interval&amp; x=*this;

	if (compactness &amp;&amp; x.is_degenerated()) { // specific treatment to avoid overestimation of complementary
		// the following test allows to return EMPTY when x is a bound of y (e.g., x=0 and y=0 or y=[0,1])
		if (x.is_empty() || y.contains(x.lb())) {
			c1.set_empty();
			c2.set_empty();
			return 0;
		} else {
			c1=x;
			c2.set_empty();
			return 1;
		}
	}

	y.complementary(c1, c2, compactness);
	c1 &amp;= x;
	int res=2;
	if (c1.is_degenerated()) { c1=Interval::empty_set(); res--; }
	c2 &amp;= x;
	if (c2.is_degenerated()) { c2=Interval::empty_set(); res--; }

	if (c1.is_empty()) {
		c1=c2;
		c2=Interval::empty_set();
	}
	return res;
}


} // end namespace
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>ibex_ExprSimplify.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
//============================================================================
//                                  I B E X
// File        : ibex_ExprSimplify.cpp
// Author      : Gilles Chabert
// Copyright   : IMT Atlantique (France)
// License     : See the LICENSE file
// Created     : May 19, 2016
// Last update : Jul 18, 2019
//============================================================================

#include &quot;ibex_ExprSimplify.h&quot;
#include &quot;ibex_Expr.h&quot;
#include &quot;ibex_ExprSubNodes.h&quot;
#include &quot;ibex_NodeMap.h&quot;

using namespace std;

#define CLONE_VEC vector&lt;pair&lt;DoubleIndex, const ExprNode*&gt; &gt;

namespace ibex {

namespace {

bool is_cst(const ExprNode&amp; e) {
	const ExprConstant* c=dynamic_cast&lt;const ExprConstant*&gt;(&amp;e);
	return c!=NULL &amp;&amp; !c-&gt;is_mutable();
}

bool is_mul(const ExprNode&amp; e) {
	return dynamic_cast&lt;const ExprMul*&gt;(&amp;e)!=NULL;
}

bool is_add(const ExprNode&amp; e) {
	return dynamic_cast&lt;const ExprAdd*&gt;(&amp;e)!=NULL;
}

bool is_sub(const ExprNode&amp; e) {
	return dynamic_cast&lt;const ExprSub*&gt;(&amp;e)!=NULL;
}

const ExprNode&amp; left(const ExprNode&amp; e) {
	const ExprBinaryOp* b=dynamic_cast&lt;const ExprBinaryOp*&gt;(&amp;e);
	assert(b);
	return b-&gt;left;
}

const ExprNode&amp; right(const ExprNode&amp; e) {
	const ExprBinaryOp* b=dynamic_cast&lt;const ExprBinaryOp*&gt;(&amp;e);
	assert(b);
	return b-&gt;right;
}

const Domain&amp; to_cst(const ExprNode&amp; e) {
	const ExprConstant* c=dynamic_cast&lt;const ExprConstant*&gt;(&amp;e);
	assert(c);
	return c-&gt;get();
}

bool is_identity(const ExprNode&amp; e) {
	if (is_cst(e)) {
		// we could be more incremental than creating the whole domain first
		// but it requires to determine if an element is diagonal/off-diagonal.
		const Domain&amp; d = to_cst(e);
		switch(d.dim.type()) {
		case Dim::SCALAR:     return d.i()==Interval::one();
		case Dim::ROW_VECTOR:
		case Dim::COL_VECTOR: return false;
		default:              return d.m()==Matrix::eye(d.dim.nb_rows());
		}
	} else {
		return false;
	}
}

/*
 * This function checks if an expression is a &quot;selection&quot; vector,
 * e.g., (0,0,1,0,0,0).
 * If yes, returns the index selected (in the example:2).
 * Otherwise, returns -1.
 */
int is_selection(const ExprNode&amp; e) {
	if (is_cst(e)) {
		const Domain&amp; d = to_cst(e);
		switch(d.dim.type()) {
		case Dim::SCALAR:
			return -1;
		case Dim::ROW_VECTOR:
		case Dim::COL_VECTOR:
		{
			int index=-1;
			for (int j=0; j&lt;d.dim.vec_size(); j++) {
				const Interval&amp; dij=d[j].i();
				if (dij.lb()!=0 || dij.ub()!=0) {
					if (index&gt;=0 || // more than one 0 in this row
							dij.lb()!=1 || dij.ub()!=1) //
						return -1;
					else
						index=j;
				}
			}
			return index;
		}
		default:
			return -1;
		}
	} else {
		return -1;
	}
}

} // end anonymous namespace

const ExprNode&amp; ExprSimplify::simplify(const ExprNode&amp; e) {
	ExprSubNodes old_nodes(e);

	idx = DoubleIndex::all(e.dim);
	e.accept_visitor(*this);
	const ExprNode&amp; result = get(e,idx);

	// If a node does not appear in the final expression
	// AND is not a node of the original expression, it has to be freed.
	//
	// Note: we cannot free copies of constant nodes as we &quot;fold&quot; them
	// because a constant node may be pointed to by another node than
	// the current father (we have DAG, not a tree). Ex: assuming the
	// node &quot;1&quot; is the same in both subexpressions:
	//           (1*2)+(x+1)
	// we must not delete &quot;1&quot; when copying (1*2).


	ExprSubNodes new_nodes(result);

	NodeMap&lt;bool&gt; all_nodes;

	for (IBEX_NODE_MAP(CLONE_VEC*)::const_iterator it=idx_clones.begin();
			it!=idx_clones.end(); it++) {
		for (CLONE_VEC::const_iterator it2=it-&gt;second-&gt;begin(); it2!=it-&gt;second-&gt;end(); it2++) {
			if (!all_nodes.found(*it2-&gt;second))
				all_nodes.insert(*it2-&gt;second,true);
		}
		delete it-&gt;second;
	}

	/** auto-cleanup................ */
	for (int i=0; i&lt;old_nodes.size(); i++) {
		if (!all_nodes.found(old_nodes[i]))
			all_nodes.insert(old_nodes[i],true);
	}
	/*...............................*/

	for (IBEX_NODE_MAP(bool)::const_iterator it=all_nodes.begin(); it!=all_nodes.end(); it++) {
		if (/* auto-cleanup, so remove this ----&gt; !old_nodes.found(*it-&gt;first) &amp;&amp; */
			!dynamic_cast&lt;const ExprSymbol*&gt;(it-&gt;first) &amp;&amp;
			!new_nodes.found(*it-&gt;first) &amp;&amp;
			!lock.found(*it-&gt;first)) {
			delete it-&gt;first;
		} else {
			// the list of fathers has to be recalculated.
//			((ExprNode*) it-&gt;first)-&gt;fathers.clear();
//			((ExprNode*) it-&gt;first)-&gt;fathers.resize(0);
		}
	}

	// NOTE: the list of fathers must also be recalculated
	// for old nodes alive !!
	// and this is not as simple as the next commented loop
	// as the old nodes may have fathers &quot;alive&quot;
	// that do not belong to the new nodes.


//	for (int i=0; i&lt;new_nodes.size(); i++) {
//		if (dynamic_cast&lt;const ExprNAryOp*&gt;(&amp;new_nodes[i])) {
//			const ExprNAryOp&amp; nary=(const ExprNAryOp&amp;) new_nodes[i];
//			for (int j=0; j&lt;nary.nb_args; j++)
//				((ExprNode&amp;) nary.args[j]).fathers.add(nary);
//		} else if (dynamic_cast&lt;const ExprBinaryOp*&gt;(&amp;new_nodes[i])) {
//			const ExprBinaryOp&amp; b=(const ExprBinaryOp&amp;) new_nodes[i];
//			((ExprNode&amp;) b.left).fathers.add(b);
//			((ExprNode&amp;) b.right).fathers.add(b);
//		} else if (dynamic_cast&lt;const ExprUnaryOp*&gt;(&amp;new_nodes[i])) {
//			const ExprUnaryOp&amp; u=(const ExprUnaryOp&amp;) new_nodes[i];
//			((ExprNode&amp;) u.expr).fathers.add(u);
//		} else if (dynamic_cast&lt;const ExprIndex*&gt;(&amp;new_nodes[i])) {
//			const ExprIndex&amp; index=(const ExprIndex&amp;) new_nodes[i];
//			((ExprNode&amp;) index.expr).fathers.add(index);
//		}
//	}

	idx_clones.clean();
	return result;
}

void ExprSimplify::insert(const ExprNode&amp; e, const ExprNode&amp; e2) {
	// first time we access to node e:
	if (!idx_clones.found(e)) {
		idx_clones.insert(e,new CLONE_VEC());
	}
	idx_clones[e]-&gt;push_back(pair&lt;DoubleIndex,const ExprNode*&gt;(idx,&amp;e2));
}

const ExprNode&amp; ExprSimplify::get(const ExprNode&amp; e, const DoubleIndex&amp; idx2) {
	assert(e.dim==idx2.dim);
	// first time we access to node e:
	if (!idx_clones.found(e)) {
		idx_clones.insert(e,new CLONE_VEC());
	}

	CLONE_VEC&amp; v=*(idx_clones[e]);
	unsigned int i=0;
	while (i&lt;v.size() &amp;&amp; v[i].first!=idx2)
		i++;
	if (i==v.size()) { // idx2 not found in the clone list
		DoubleIndex old_idx=idx;
		idx=idx2;
		e.accept_visitor(*this);
		idx=old_idx;
		assert(v.back().first==idx2);
	}

	return *v[i].second;
}

void ExprSimplify::visit(const ExprVector&amp; e) {

	vector&lt;const ExprNode*&gt; res;
	unsigned int i=0;
	bool all_cst=true;
	bool all_same=true;

	if (e.row_vector()) {
		int c=0;
		while (c&lt;=idx.last_col()) {
			int n=e.arg(i).dim.nb_cols();
			int first_col=idx.first_col()-c;
			if (first_col&lt;n) { // can be negative
				int last_col=idx.last_col()-c;
				DoubleIndex e_idx=DoubleIndex(e.arg(i).dim,
						idx.first_row(), idx.last_row(),
						first_col&lt;0? 0 : first_col, last_col&gt;=n? n-1 : last_col);
				res.push_back(&amp;get(e.arg(i),e_idx));
				all_cst &amp;= is_cst(*res.back());
				all_same &amp;= (res.back()==&amp;e.arg(i));
			}
			c+=n;
			assert(((int) i)&lt;e.nb_args);
			i++;
		}
	} else {
		int r=0;
		while (r&lt;=idx.last_row()) {
			int n=e.arg(i).dim.nb_rows();
			int first_row=idx.first_row()-r;
			if (first_row&lt;n) { // can be negative
				int last_row=idx.last_row()-r;
				DoubleIndex e_idx=DoubleIndex(e.arg(i).dim,
						first_row&lt;0? 0 : first_row, last_row&gt;=n? n-1 : last_row,
						idx.first_col(), idx.last_col());
				res.push_back(&amp;get(e.arg(i),e_idx));
				all_cst &amp;= is_cst(*res.back());
				all_same &amp;= (res.back()==&amp;e.arg(i));
			}
			r+=n;
			assert(((int) i)&lt;e.nb_args);
			i++;
		}
	}

	if (res.size()==1)
		insert(e, *res.back());
	else if (all_cst) {
		Array&lt;const Domain&gt; arg_cst(res.size());
		for (i=0; i&lt;res.size(); i++)
			arg_cst.set_ref(i, to_cst(*res[i]));
		insert(e, ExprConstant::new_(Domain(arg_cst, e.row_vector())));
	} else if (((int) res.size())==e.nb_args &amp;&amp; all_same) {
		insert(e, e);
	} else
		insert(e, ExprVector::new_(res,e.orient));
}

void ExprSimplify::visit(const ExprIndex&amp; e) {

	const ExprNode&amp; expr=get(e.expr,e.index[idx]);

	insert(e, expr);
}

void ExprSimplify::visit(const ExprSymbol&amp; x) {
	if (idx.all())
		insert(x,x);
	else
		insert(x,x[idx]);
}

void ExprSimplify::visit(const ExprConstant&amp; c) {
	if (idx.all())
		insert(c,c);
	else
		if (c.is_mutable())
			insert(c,c[idx]); // no simplification allowed
		else
			insert(c,ExprConstant::new_(c.get()[idx]));
}

void ExprSimplify::visit_add_sub(const ExprBinaryOp&amp; e, bool sign) {

	const ExprNode&amp; l=get(e.left, idx);
	const ExprNode&amp; r=get(e.right, idx);

	// We try now to simplify addition/subtraction in cascade.
	// For example, (1+x)-(2-y) will become (3+(x-y)).
	// ==========================================================
	// Analyse the left subexpression
	// ==========================================================
	const ExprNode*   el;   // the non-const part on the left side (NULL if none)
	bool lsign;             // the sign of the latter
	const ExprConstant* cl; // the const part on the left side (NULL if none)

	if (is_cst(l)) {
		el=NULL;
		cl=dynamic_cast&lt;const ExprConstant*&gt;(&amp;l);
		lsign=true;
	}
	else if ((is_add(l) || is_sub(l)) &amp;&amp; is_cst(right(l))) {
		el=&amp;left(l);
		// cst always on the right (see why below)
		cl=dynamic_cast&lt;const ExprConstant*&gt;(&amp;(right(l)));
		lsign=is_add(l);
	}
	else {
		el=&amp;l;
		cl=NULL;
		lsign=true; // (ignored)
	}
	// ==========================================================

	// ==========================================================
	// Analyse the right subexpression
	// ==========================================================
	const ExprNode*   er;
	bool rsign;
	const ExprConstant* cr;

	if (is_cst(r)) {
		er=NULL;
		cr=dynamic_cast&lt;const ExprConstant*&gt;(&amp;r);
		rsign=sign;
	}
	else if ((is_add(r) || is_sub(r)) &amp;&amp; is_cst(right(r))) {
		er=&amp;left(r);
		cr=dynamic_cast&lt;const ExprConstant*&gt;(&amp;(right(r))); // cst always on the right (see why below)
		rsign = (sign &amp;&amp; is_add(r)) || (!sign &amp;&amp; is_sub(r));
	}
	else {
		er=&amp;r;
		cr=NULL;
		rsign=true; // ignore
	}

	// ==========================================================
	// Calculate the global constant in the current expression
	// ==========================================================
	const ExprConstant* cfinal; // NULL if none or =O

	// cst_sign allows to keep the objects cl/cr
	// when one of them is NULL.
	// Ex: if we have (x-1)+y, we produce
	///   (x+y)-(1) --&gt; constant &quot;1&quot; preserved (final_sign==false)
	// instead of
	//    (x+y)+(-1) --&gt; new constant &quot;-1&quot;.
	bool cst_sign=true;

	if (cl) {
		if (cr) {
			if (cr-&gt;is_zero())      { cfinal=cl; cst_sign=lsign; }
			else if (cl-&gt;is_zero()) { cfinal=cr; cst_sign=rsign; }
			else
				if (lsign)
					if (rsign)        cfinal=&amp;ExprConstant::new_(cl-&gt;get()+cr-&gt;get());
					else              cfinal=&amp;ExprConstant::new_(cl-&gt;get()-cr-&gt;get());
<A NAME="0"></A>				else
					if (rsign)        cfinal=&amp;ExprConstant::new_(cr-&gt;get()-cl-&gt;get());
					else              cfinal=&amp;ExprConstant::new_(-cl-&gt;get()-cr-&gt;get());
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1747-0.html#0',2,'match1747-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>		} else                      { cfinal=cl; cst_sign=lsign; }
	}
	else if (cr)                    { cfinal=cr; cst_sign=rsign; }
	else {</B></FONT>
		// no constants at all ----&gt; no simplification
		if ((&amp;l == &amp;e.left) &amp;&amp; (&amp;r == &amp;e.right)) { // nothing changed
			insert(e, e);
		} else if (sign)
			insert(e, l+r);
		else
			insert(e,l-r);
		return;
	}

	if (cfinal-&gt;is_zero() &amp;&amp; cfinal!=cr &amp;&amp; cfinal!=cl) { // may happen, ex: (1+x)+(-1+x)
		delete cfinal;  // because results from a call to &quot;ExprConstant::new_&quot;
		cfinal=NULL;
	}


	// ==========================================================
	// Calculate the global non-const part in the current expression
	// ==========================================================
	const ExprNode* efinal;
	bool expr_sign=true;

	if (el)
		if (er)
			if (sign) efinal=&amp;(*el+*er);
			else      efinal=&amp;(*el-*er);
		else          efinal=el;
	else if (er)    { efinal=er; expr_sign=sign; }
	else              efinal=NULL;

	// ==========================================================
	// Generate the final expression
	// ==========================================================
	if (!cfinal || cfinal-&gt;is_zero()) {
		if (!efinal) { // happens in these cases: 0+0 or 0-0
			if (!cfinal) {
				Domain d(e.dim.index_dim(idx)); d.clear();
				insert(e,ExprConstant::new_(d));
			} else
				insert(e,*cfinal);
		}
		else if (expr_sign) insert(e,*efinal);
		else insert(e,-(*efinal));
	} else {
		if (!efinal)
			if (cst_sign) insert(e,*cfinal);
			else
				// we have two options here.
				//
				// 1- keep a reference to the constant object
				// (better if it is big in memory):
				//
				//insert(e,-(*cfinal));
				//
				// 2- precompute the opposite value:
				// (note: no memory leak because cfinal==cl or cr)
				insert(e,ExprConstant::new_(-(cfinal-&gt;get())));
		else
			// always put the constant on the right side
			// for further constant factorization
			if (expr_sign)
				if (cst_sign) insert(e,(*efinal)+(*cfinal));
				else          insert(e,(*efinal)-(*cfinal));
			else
				// note: the next expression is better than
				// (*cfinal)-(*efinal) in order to keep
				// the &quot;constant on the right&quot; idiom

				if (cst_sign)
					insert(e,(-*efinal)+(*cfinal));
					//insert(e,(*cfinal)-(*efinal));

				// note: the next expression is better than
		        // (-(*efinal + *cfinal)) in order to keep
		        // the &quot;constant on the right&quot; idiom
				else
					insert(e,(-*efinal)-(*cfinal));
					//insert(e,-(*efinal + *cfinal));
	}
}

void ExprSimplify::visit(const ExprAdd&amp; e) {

	visit_add_sub(e,true);
}

void ExprSimplify::visit(const ExprSub&amp; e) {

	visit_add_sub(e,false);
}

void ExprSimplify::visit(const ExprMul&amp; e) {

	DoubleIndex l_idx;
	DoubleIndex r_idx;

	if (e.left.dim.is_scalar()) {
		l_idx=DoubleIndex::all(e.left.dim);
		r_idx=idx;
	} else {
		l_idx=DoubleIndex::rows(e.left.dim,idx.first_row(),idx.last_row());
		r_idx=DoubleIndex::cols(e.right.dim,idx.first_col(),idx.last_col());
	}

	const ExprNode&amp; l=get(e.left, l_idx);
	const ExprNode&amp; r=get(e.right, r_idx);
	int index;

	if (is_identity(l) || (is_cst(r) &amp;&amp; to_cst(r).is_zero()))
		insert(e, r);
	else if (is_identity(r) || (is_cst(l) &amp;&amp; to_cst(l).is_zero()))
		insert(e, l);
	else if ((index=is_selection(l))!=-1) {
		const ExprNode&amp; r2=get(e.right, r_idx[DoubleIndex::one_row(r.dim,index)]);
		insert(e, r2);
	}
	else if ((index=is_selection(r))!=-1) {
		const ExprNode&amp; l2=get(e.left, l_idx[DoubleIndex::one_col(l.dim,index)]);
		insert(e, l2);
	}
	else if (is_cst(l)) {
		if (is_cst(r))
			insert(e, ExprConstant::new_(to_cst(l)*to_cst(r)));
		else if (is_mul(r) &amp;&amp; is_cst(left(r)))
			// note: l and left(r) and right(r) may not be scalar.
			insert(e, ExprConstant::new_(to_cst(l)*to_cst(left(r)))*(right(r)));
		else if ((&amp;l == &amp;e.left) &amp;&amp; (&amp;r == &amp;e.right)) { // nothing changed
			insert(e, e);
		} else
			insert(e, l*r);
	}
	else if (is_mul(l) &amp;&amp; is_cst(left(l))) {
		if (is_cst(r) &amp;&amp; r.dim.is_scalar())
			// note: left(l) and right(l) may not be scalar.
			insert(e, ExprConstant::new_(to_cst(r)*to_cst(left(l)))*(right(l)));
		else if (is_mul(r) &amp;&amp; is_cst(left(r)) &amp;&amp; left(r).dim.is_scalar())
			// note: left(l), right(l), right(r) may not be scalar.
			insert(e, ExprConstant::new_(to_cst(left(r))*to_cst(left(l)))*(right(l)*right(r)));
		else
			// always put the constant on the left side
			// (to apply the previous cases upstream)
			insert(e, left(l)*(right(l)*r));
	}
	else {
		if (is_cst(r) &amp;&amp; r.dim.is_scalar())
		// always put the constant on the left side for further constant factorization
			insert(e, r*l);
		else if (is_mul(r) &amp;&amp; is_cst(left(r)) &amp;&amp; left(r).dim.is_scalar())
			insert(e, left(r)*(l*right(r)));
		else if ((&amp;l == &amp;e.left) &amp;&amp; (&amp;r == &amp;e.right)) { // nothing changed
			insert(e, e);
		} else
			insert(e, l*r);
	}
}

void ExprSimplify::visit(const ExprDiv&amp; e) {

	const ExprNode&amp; l=get(e.left, idx);
	const ExprNode&amp; r=get(e.right, idx);

	if (is_cst(l) &amp;&amp; to_cst(l).is_zero())
		insert(e, l);
	else if (is_identity(r))
		insert(e, l);
	else if (is_cst(l) &amp;&amp; is_cst(r))
		insert(e, ExprConstant::new_(to_cst(l)/to_cst(r)));
	else if ((&amp;l == &amp;e.left) &amp;&amp; (&amp;r == &amp;e.right)) { // nothing changed
		insert(e, e);
	} else
		insert(e, l/r);
}

//typedef const ExprNode&amp; (*func)(const ExprNode&amp;);
//void ExprSimplify::nary_copy(const ExprNaryOp&amp; e, func f) {
//	if (&amp;e.expr == &amp;EXPR)  // nothing changed
//		clone.insert(e,&amp;e);
//	else
//		clone.insert(e, &amp;(f(EXPR)));
//}


void ExprSimplify::binary(const ExprBinaryOp&amp; e,
		//Domain (*fcst)(const Domain&amp;, const Domain&amp;), //
		std::function&lt;Domain(const Domain&amp;, const Domain&amp;)&gt; fcst,
		std::function&lt;const ExprNode&amp;(const ExprNode&amp;, const ExprNode&amp;)&gt; fctr,
		bool index_distributive) {

	if (index_distributive) {
		const ExprNode&amp; l=get(e.left, idx);
		const ExprNode&amp; r=get(e.right, idx);

		if (is_cst(l) &amp;&amp; is_cst(r))
			insert(e, ExprConstant::new_(fcst(to_cst(l),to_cst(r))));
		else if ((&amp;l == &amp;e.left) &amp;&amp; (&amp;r == &amp;e.right)) { // nothing changed
			insert(e, e);
		} else
			insert(e, fctr(l,r));
	} else {
		if (is_cst(e.left) &amp;&amp; is_cst(e.right))
			insert(e, ExprConstant::new_(fcst(to_cst(e.left),to_cst(e.right))[idx]));
		else {
			if (idx.all())
				insert(e, e);
			else
				insert(e, e[idx]);
		}
	}
}

void ExprSimplify::unary(const ExprUnaryOp&amp; e,
		std::function&lt;Domain(const Domain&amp;)&gt; fcst,
		std::function&lt;const ExprNode&amp;(const ExprNode&amp;)&gt; fctr, bool index_distributive) {
	if (index_distributive) {
		const ExprNode&amp; expr=get(e.expr, idx);

		if (is_cst(expr))
			/* evaluate the constant expression on-the-fly */
			insert(e, ExprConstant::new_(fcst(to_cst(expr))));
		else if (&amp;e.expr == &amp;expr) { // if nothing changed
			insert(e, e);
		} else
			insert(e, fctr(expr));
	} else {
		const ExprNode&amp; expr=get(e.expr, DoubleIndex::all(e.expr.dim));
		if (is_cst(expr))
			/* evaluate the constant expression on-the-fly */
			insert(e, ExprConstant::new_(fcst(to_cst(expr))[idx]));
		else {
			if (idx.all()) // if nothing changed
				insert(e, fctr(expr));
			else
				insert(e, fctr(expr)[idx]);
		}
	}
}

// Implemented by Soonho
void ExprSimplify::visit(const ExprChi&amp; e) {
	const ExprNode&amp; arg0=get(e.args[0], idx);
	if (is_cst(arg0)) {
		assert(arg0.dim.is_scalar());
		const Interval&amp; c = to_cst(arg0).i();
		if (c.lb() &gt; 0) {
			// if c &gt; 0, chi(c, arg1, arg2) reduces to arg1
			const ExprNode&amp; arg1=get(e.args[1], idx);
			insert(e, arg1);
			return;
		} else if (c.ub() &lt;= 0) {
			// if c &lt;= 0, chi(c, arg1, arg2) reduces to arg2
			const ExprNode&amp; arg2=get(e.args[2], idx);
			insert(e, arg2);
			return;
		}
	} else {
		insert(e, e);
	}
}

void ExprSimplify::visit(const ExprApply&amp; e) {
	not_implemented(&quot;Simplify with Apply&quot;);
}

void ExprSimplify::visit(const ExprPower&amp; e) {
	unary(  e,
			[&amp;e](const Domain&amp; d)-&gt;Domain            { return pow(d,e.expon); },
			[&amp;e](const ExprNode&amp; x)-&gt;const ExprNode&amp; { return ExprPower::new_(x,e.expon); },
			false
	);
}

void ExprSimplify::visit(const ExprGenericBinaryOp&amp; e) {
	binary( e,
			e.eval,
			[&amp;e](const ExprNode&amp; x,const ExprNode&amp; y)-&gt;const ExprNode&amp; { return ExprGenericBinaryOp::new_(e.name,x,y);},
			false);
}

// Note: I don't understand why I have to do these casts.
// The compiler should directly convert arguments to
//      std::function&lt;Domain(const Domain&amp;)&gt;
// or
//      std::function&lt;Domain(const Domain&amp;, const Domain&amp;)&gt;
typedef Domain (*_domain_una_op)(const Domain&amp;);
typedef Domain (*_domain_bin_op)(const Domain&amp;,const Domain&amp;);

void ExprSimplify::visit(const ExprMax&amp; e)   { binary(e, (_domain_bin_op) max,      ExprMax::new_,true); }
void ExprSimplify::visit(const ExprMin&amp; e)   { binary(e, (_domain_bin_op) min,      ExprMin::new_,true); }
void ExprSimplify::visit(const ExprAtan2&amp; e) { binary(e, (_domain_bin_op) atan2,    ExprAtan2::new_,false); }
void ExprSimplify::visit(const ExprMinus&amp; e) { unary(e,  (_domain_una_op) operator-,ExprMinus::new_,true); }

void ExprSimplify::visit(const ExprTrans&amp; e) {
	const ExprNode&amp; expr=get(e.expr, idx.transpose());

	if (is_cst(expr))
		/* evaluate the constant expression on-the-fly */
		insert(e, ExprConstant::new_(transpose(to_cst(expr))));
	else if (expr.dim.is_scalar())
		insert(e,expr);
	else if (&amp;e.expr == &amp;expr) { // if nothing changed
		insert(e, e);
	} else
		insert(e, ExprTrans::new_(expr));
}

void ExprSimplify::visit(const ExprGenericUnaryOp&amp; e) {
	unary(e, e.eval,
			[&amp;e](const ExprNode&amp; x)-&gt;const ExprNode&amp; { return ExprGenericUnaryOp::new_(e.name,x);},
			false);
}

void ExprSimplify::visit(const ExprSign&amp; e)  { unary(e, (_domain_una_op) sign, ExprSign::new_, true);  }
void ExprSimplify::visit(const ExprAbs&amp; e)   { unary(e, (_domain_una_op) abs,  ExprAbs::new_,  true);  }
void ExprSimplify::visit(const ExprSqr&amp; e)   { unary(e, (_domain_una_op) sqr,  ExprSqr::new_,  false); }
void ExprSimplify::visit(const ExprSqrt&amp; e)  { unary(e, (_domain_una_op) sqrt, ExprSqrt::new_, false); }
void ExprSimplify::visit(const ExprExp&amp; e)   { unary(e, (_domain_una_op) exp,  ExprExp::new_,  false); }
void ExprSimplify::visit(const ExprLog&amp; e)   { unary(e, (_domain_una_op) log,  ExprLog::new_,  false); }
void ExprSimplify::visit(const ExprCos&amp; e)   { unary(e, (_domain_una_op) cos,  ExprCos::new_,  false); }
void ExprSimplify::visit(const ExprSin&amp; e)   { unary(e, (_domain_una_op) sin,  ExprSin::new_,  false); }
void ExprSimplify::visit(const ExprTan&amp; e)   { unary(e, (_domain_una_op) tan,  ExprTan::new_,  false); }
void ExprSimplify::visit(const ExprCosh&amp; e)  { unary(e, (_domain_una_op) cosh, ExprCosh::new_, false); }
void ExprSimplify::visit(const ExprSinh&amp; e)  { unary(e, (_domain_una_op) sinh, ExprSinh::new_, false); }
void ExprSimplify::visit(const ExprTanh&amp; e)  { unary(e, (_domain_una_op) tanh, ExprTanh::new_, false); }
void ExprSimplify::visit(const ExprAcos&amp; e)  { unary(e, (_domain_una_op) acos, ExprAcos::new_, false); }
void ExprSimplify::visit(const ExprAsin&amp; e)  { unary(e, (_domain_una_op) asin, ExprAsin::new_, false); }
void ExprSimplify::visit(const ExprAtan&amp; e)  { unary(e, (_domain_una_op) atan, ExprAtan::new_, false); }
void ExprSimplify::visit(const ExprAcosh&amp; e) { unary(e, (_domain_una_op) acosh,ExprAcosh::new_,false); }
void ExprSimplify::visit(const ExprAsinh&amp; e) { unary(e, (_domain_una_op) asinh,ExprAsinh::new_,false); }
void ExprSimplify::visit(const ExprAtanh&amp; e) { unary(e, (_domain_una_op) atanh,ExprAtanh::new_,false); }
void ExprSimplify::visit(const ExprFloor&amp; e) { unary(e, (_domain_una_op) floor,ExprFloor::new_,false); }
void ExprSimplify::visit(const ExprCeil&amp; e)  { unary(e, (_domain_una_op) ceil, ExprCeil::new_, false); }
void ExprSimplify::visit(const ExprSaw&amp; e)   { unary(e, (_domain_una_op) saw,  ExprSaw::new_, false);  }

} /* namespace ibex */
</PRE>
</div>
  </div>
</body>
</html>
