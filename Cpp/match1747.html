<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for ibex_Interval.cpp &amp; ibex_ExprSimplify.cpp</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for ibex_Interval.cpp &amp; ibex_ExprSimplify.cpp
      </h3>
<h1 align="center">
        2.3%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>ibex_Interval.cpp (4.0%)<th>ibex_ExprSimplify.cpp (1.6703786%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(268-280)<td><a href="#" name="0">(384-387)</a><td align="center"><font color="#ff0000">15</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>ibex_Interval.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "ibex_Interval.h"
2 #include &lt;float.h&gt;
3 #include &lt;cassert&gt;
4 namespace ibex {
5 #define INF_DIV(n,d) ((Interval(n)/Interval(d)).lb())
6 #define SUP_DIV(n,d) ((Interval(n)/Interval(d)).ub())
7 #define INF_MUL(x,y) ((Interval(x)*Interval(y)).lb())
8 #define SUP_MUL(x,y) ((Interval(x)*Interval(y)).ub())
9 void div2(const Interval&amp; num, const Interval&amp; div, Interval&amp; out1, Interval&amp; out2) {
10 	if (num.is_empty() || div.is_empty()) {
11 		out1.set_empty();
12 		out2.set_empty();
13 		return;
14 	}
15 	const double&amp; a(num.lb());
16 	const double&amp; b(num.ub());
17 	const double&amp; c(div.lb());
18 	const double&amp; d(div.ub());
19 	if (c==0 &amp;&amp; d==0) {
20 		out1.set_empty();
21 		out2.set_empty();
22 		return;
23 	}
24 	if (a==0 &amp;&amp; b==0) {
25 		out1 = num;
26 		out2.set_empty();
27 		return;
28 	}
29 	if (c&gt;0 || d&lt;0) {
30 		out1 = num/div;
31 		out2.set_empty();
32 		return;
33 	}
34 	if (b&lt;=0 &amp;&amp; d==0) {
35 		if (c==NEG_INFINITY)
36 			out1 = Interval::pos_reals();
37 		else
38 			out1 = Interval(INF_DIV(b,c), POS_INFINITY);
39 		out2.set_empty();
40 		return;
41 	}
42 	if (b&lt;=0 &amp;&amp; c&lt;0 &amp;&amp; d&gt;0) {
43 		if (b==0 || (c==NEG_INFINITY &amp;&amp; d==POS_INFINITY)) {
44 			out1 = Interval::all_reals();
45 			out2.set_empty();
46 			return;
47 		} else {
48 			out1 = Interval(NEG_INFINITY, d==POS_INFINITY? 0 : SUP_DIV(b,d));
49 			out2 = Interval(c==NEG_INFINITY? 0 : INF_DIV(b,c), POS_INFINITY);
50 			return;
51 		}
52 	}
53 	if (b&lt;=0 &amp;&amp; c==0) {
54 		if (d==POS_INFINITY)
55 			out1 = Interval::neg_reals();
56 		else
57 			out1 = Interval(NEG_INFINITY, SUP_DIV(b,d));
58 		out2.set_empty();
59 		return;
60 	}
61 	if (a&gt;=0 &amp;&amp; d==0) {
62 		if (c==NEG_INFINITY)
63 			out1 = Interval::neg_reals();
64 		else
65 			out1 = Interval(NEG_INFINITY, SUP_DIV(a,c));
66 		out2.set_empty();
67 		return;
68 	}
69 	if (a&gt;=0 &amp;&amp; c&lt;0 &amp;&amp; d&gt;0) {
70 		if (a==0 || (c==NEG_INFINITY &amp;&amp; d==POS_INFINITY)) {
71 			out1 = Interval::all_reals();
72 			out2.set_empty();
73 			return;
74 		} else {
75 			out1 = Interval(NEG_INFINITY, c==NEG_INFINITY? 0 : SUP_DIV(a,c));
76 			out2 = Interval(d==POS_INFINITY? 0 : INF_DIV(a,d), POS_INFINITY);
77 			return;
78 		}
79 	}
80 	if (a&gt;=0 &amp;&amp; c==0) {
81 		if (d==POS_INFINITY)
82 			out1 = Interval::pos_reals();
83 		else
84 			out1 = Interval(INF_DIV(a,d), POS_INFINITY);
85 		out2.set_empty();
86 		return;
87 	}
88 	out1 = Interval::all_reals();
89 	out2.set_empty();
90 }
91 bool Interval::div2_inter(const Interval&amp; num, const Interval&amp; div, Interval&amp; out2) {
92 	Interval out1,_out2;
93 	div2(num,div,out1,_out2);
94 	out1 &amp;= *this;
95 	if (out1.is_empty()) {
96 		*this &amp;= _out2;
97 		out2.set_empty();
98 		return !this-&gt;is_empty();
99 	} else {
100 		out2 = *this &amp; _out2;
101 		*this = out1;
102 		return true;
103 	}
104 }
105 Interval saw(const Interval&amp; x) {
106 	double u = round(x.ub());
107 	double l = round(x.lb());
108 	assert(l&lt;=u);
109 	if (l&lt;u) return Interval(-1,1);
110 	else {
111 		fpu_round_up();
112 		double du  = x.ub()-u;
113 		double dl  = l-x.lb();
114 		return Interval(-dl,du);
115 	}
116 }
117 bool bwd_saw(const Interval&amp; y_, Interval&amp; x) {
118 	if (y_.is_empty()) {
119 		x.set_empty();
120 		return false;
121 	}
122 	if (y_.lb()==0 &amp;&amp; y_.ub()==0) {
123 		return !(x &amp;= Interval(std::ceil(x.lb()),std::floor(x.ub()))).is_empty();
124 	}
125 	assert(sizeof(double)==8); 	if (x.mag()&gt;=std::pow(2,52)) {
126 		if (x.is_degenerated() &amp;&amp; !y_.contains(0)) {
127 			x.set_empty();
128 			return false;
129 		} else
130 			return true;
131 	}
132 	double l = round(x.lb());
133 	double u = round(x.ub());
134 	double half=1/2.0; 
135 	Interval y = y_ &amp; Interval(-half,half);
136 	fpu_round_up();
137 	double xl;
138 	if (x.lb() &gt; l+y.ub()) { 		xl = -(-(l+1)        		       - y.lb());    		assert(xl&gt;=x.lb());  	} else {
139 		xl = -(-l - y.lb()); 	}
140 	double xu;
141 	if (x.ub() &lt; -(-u-y.lb())) { 		xu = (u-1)          		     + y.ub();      		assert(xu&lt;=x.ub()); 	} else {
142 		xu = u + y.ub();
143 	}
144 	return !(x &amp;= Interval(xl,xu)).is_empty();
145 }
146 double Interval::delta(const Interval&amp; x) const {
147 	if (is_empty()) return 0;
148 	if (x.is_empty()) return diam();
149 	volatile double d=diam();
150 	volatile double dx=x.diam();
151 	if (d==POS_INFINITY) {
152 		if (dx==POS_INFINITY) {
153 			double left=(x.lb()==NEG_INFINITY? 0 : x.lb()-lb());
154 			double right=(x.ub()==POS_INFINITY? 0 : ub()-x.ub());
155 			return left+right;
156 		} else
157 			return POS_INFINITY;
158 	}
159 	else return d-dx;
160 }
161 double Interval::ratiodelta(const Interval&amp; x) const {
162 	double d=delta(x);
163 	if (d==POS_INFINITY) return 1;
164 	double D=diam();
165 	return (D==0 || D==POS_INFINITY) ? 0.0 : (d/D); }
166 std::pair&lt;Interval,Interval&gt; Interval::bisect(double ratio) const {
167 	assert(is_bisectable());
168 	assert(ratio&gt;0 &amp;&amp; ratio&lt;1);
169 	Interval left,right;
170 	if (lb()==NEG_INFINITY) {
171 <a name="0"></a>		if (ub()==POS_INFINITY) {
172 			left = Interval(NEG_INFINITY,0);
173 			right = Interval(0,POS_INFINITY);
174 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>		}
175 		else {
176 			left = Interval(NEG_INFINITY,-DBL_MAX);
177 			right = Interval(-DBL_MAX,ub());
178 		}
179 	}
180 	else if (ub()==POS_INFINITY) {
181 		left = Interval(lb(),DBL_MAX);
182 		right = Interval(DBL_MAX,POS_INFINITY);
183 	}
184 	else {</b></font>
185 		double point;
186 		if (ratio==0.5)
187 			point = mid();
188 		else {
189 			point = lb()+ratio*diam();
190 			if (point &gt;= ub()) point=next_float(lb());
191 			assert(point&lt;ub());
192 		}
193 		left = Interval(lb(), point);
194 		right = Interval(point, ub());
195 	}
196 	return std::pair&lt;Interval,Interval&gt;(left,right);
197 }
198 int Interval::complementary(Interval&amp; c1, Interval&amp; c2, bool compactness) const {
199 	if (is_empty() || (compactness &amp;&amp; is_degenerated())) { 		c1=Interval::all_reals();
200 		c2=Interval::empty_set();
201 		return 1;
202 	}
203 	else {
204 		if (lb()&gt;NEG_INFINITY) {
205 			c1=Interval(NEG_INFINITY,lb());
206 			if (ub()&lt;POS_INFINITY) {
207 				c2=Interval(ub(),POS_INFINITY);
208 				return 2;
209 			} else {
210 				c2=Interval::empty_set();
211 				return 1;
212 			}
213 		} else if (ub()&lt;POS_INFINITY) {
214 			c1=Interval(ub(),POS_INFINITY);
215 			c2=Interval::empty_set();
216 			return 1;
217 		} else {
218 			c1=c2=Interval::empty_set();
219 			return 0;
220 		}
221 	}
222 }
223 int Interval::diff(const Interval&amp; y, Interval&amp; c1, Interval&amp; c2, bool compactness) const {
224 	const Interval&amp; x=*this;
225 	if (compactness &amp;&amp; x.is_degenerated()) { 		if (x.is_empty() || y.contains(x.lb())) {
226 			c1.set_empty();
227 			c2.set_empty();
228 			return 0;
229 		} else {
230 			c1=x;
231 			c2.set_empty();
232 			return 1;
233 		}
234 	}
235 	y.complementary(c1, c2, compactness);
236 	c1 &amp;= x;
237 	int res=2;
238 	if (c1.is_degenerated()) { c1=Interval::empty_set(); res--; }
239 	c2 &amp;= x;
240 	if (c2.is_degenerated()) { c2=Interval::empty_set(); res--; }
241 	if (c1.is_empty()) {
242 		c1=c2;
243 		c2=Interval::empty_set();
244 	}
245 	return res;
246 }
} </pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>ibex_ExprSimplify.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "ibex_ExprSimplify.h"
2 #include "ibex_Expr.h"
3 #include "ibex_ExprSubNodes.h"
4 #include "ibex_NodeMap.h"
5 using namespace std;
6 #define CLONE_VEC vector&lt;pair&lt;DoubleIndex, const ExprNode*&gt; &gt;
7 namespace ibex {
8 namespace {
9 bool is_cst(const ExprNode&amp; e) {
10 	const ExprConstant* c=dynamic_cast&lt;const ExprConstant*&gt;(&amp;e);
11 	return c!=NULL &amp;&amp; !c-&gt;is_mutable();
12 }
13 bool is_mul(const ExprNode&amp; e) {
14 	return dynamic_cast&lt;const ExprMul*&gt;(&amp;e)!=NULL;
15 }
16 bool is_add(const ExprNode&amp; e) {
17 	return dynamic_cast&lt;const ExprAdd*&gt;(&amp;e)!=NULL;
18 }
19 bool is_sub(const ExprNode&amp; e) {
20 	return dynamic_cast&lt;const ExprSub*&gt;(&amp;e)!=NULL;
21 }
22 const ExprNode&amp; left(const ExprNode&amp; e) {
23 	const ExprBinaryOp* b=dynamic_cast&lt;const ExprBinaryOp*&gt;(&amp;e);
24 	assert(b);
25 	return b-&gt;left;
26 }
27 const ExprNode&amp; right(const ExprNode&amp; e) {
28 	const ExprBinaryOp* b=dynamic_cast&lt;const ExprBinaryOp*&gt;(&amp;e);
29 	assert(b);
30 	return b-&gt;right;
31 }
32 const Domain&amp; to_cst(const ExprNode&amp; e) {
33 	const ExprConstant* c=dynamic_cast&lt;const ExprConstant*&gt;(&amp;e);
34 	assert(c);
35 	return c-&gt;get();
36 }
37 bool is_identity(const ExprNode&amp; e) {
38 	if (is_cst(e)) {
39 		const Domain&amp; d = to_cst(e);
40 		switch(d.dim.type()) {
41 		case Dim::SCALAR:     return d.i()==Interval::one();
42 		case Dim::ROW_VECTOR:
43 		case Dim::COL_VECTOR: return false;
44 		default:              return d.m()==Matrix::eye(d.dim.nb_rows());
45 		}
46 	} else {
47 		return false;
48 	}
49 }
50 int is_selection(const ExprNode&amp; e) {
51 	if (is_cst(e)) {
52 		const Domain&amp; d = to_cst(e);
53 		switch(d.dim.type()) {
54 		case Dim::SCALAR:
55 			return -1;
56 		case Dim::ROW_VECTOR:
57 		case Dim::COL_VECTOR:
58 		{
59 			int index=-1;
60 			for (int j=0; j&lt;d.dim.vec_size(); j++) {
61 				const Interval&amp; dij=d[j].i();
62 				if (dij.lb()!=0 || dij.ub()!=0) {
63 					if (index&gt;=0 || 							dij.lb()!=1 || dij.ub()!=1) //
64 						return -1;
65 					else
66 						index=j;
67 				}
68 			}
69 			return index;
70 		}
71 		default:
72 			return -1;
73 		}
74 	} else {
75 		return -1;
76 	}
77 }
78 } 
79 const ExprNode&amp; ExprSimplify::simplify(const ExprNode&amp; e) {
80 	ExprSubNodes old_nodes(e);
81 	idx = DoubleIndex::all(e.dim);
82 	e.accept_visitor(*this);
83 	const ExprNode&amp; result = get(e,idx);
84 	ExprSubNodes new_nodes(result);
85 	NodeMap&lt;bool&gt; all_nodes;
86 	for (IBEX_NODE_MAP(CLONE_VEC*)::const_iterator it=idx_clones.begin();
87 			it!=idx_clones.end(); it++) {
88 		for (CLONE_VEC::const_iterator it2=it-&gt;second-&gt;begin(); it2!=it-&gt;second-&gt;end(); it2++) {
89 			if (!all_nodes.found(*it2-&gt;second))
90 				all_nodes.insert(*it2-&gt;second,true);
91 		}
92 		delete it-&gt;second;
93 	}
94 	for (int i=0; i&lt;old_nodes.size(); i++) {
95 		if (!all_nodes.found(old_nodes[i]))
96 			all_nodes.insert(old_nodes[i],true);
97 	}
98 	for (IBEX_NODE_MAP(bool)::const_iterator it=all_nodes.begin(); it!=all_nodes.end(); it++) {
99 		if (			!dynamic_cast&lt;const ExprSymbol*&gt;(it-&gt;first) &amp;&amp;
100 			!new_nodes.found(*it-&gt;first) &amp;&amp;
101 			!lock.found(*it-&gt;first)) {
102 			delete it-&gt;first;
103 		} else {
104 		}
105 	}
106 	idx_clones.clean();
107 	return result;
108 }
109 void ExprSimplify::insert(const ExprNode&amp; e, const ExprNode&amp; e2) {
110 	if (!idx_clones.found(e)) {
111 		idx_clones.insert(e,new CLONE_VEC());
112 	}
113 	idx_clones[e]-&gt;push_back(pair&lt;DoubleIndex,const ExprNode*&gt;(idx,&amp;e2));
114 }
115 const ExprNode&amp; ExprSimplify::get(const ExprNode&amp; e, const DoubleIndex&amp; idx2) {
116 	assert(e.dim==idx2.dim);
117 	if (!idx_clones.found(e)) {
118 		idx_clones.insert(e,new CLONE_VEC());
119 	}
120 	CLONE_VEC&amp; v=*(idx_clones[e]);
121 	unsigned int i=0;
122 	while (i&lt;v.size() &amp;&amp; v[i].first!=idx2)
123 		i++;
124 	if (i==v.size()) { 		DoubleIndex old_idx=idx;
125 		idx=idx2;
126 		e.accept_visitor(*this);
127 		idx=old_idx;
128 		assert(v.back().first==idx2);
129 	}
130 	return *v[i].second;
131 }
132 void ExprSimplify::visit(const ExprVector&amp; e) {
133 	vector&lt;const ExprNode*&gt; res;
134 	unsigned int i=0;
135 	bool all_cst=true;
136 	bool all_same=true;
137 	if (e.row_vector()) {
138 		int c=0;
139 		while (c&lt;=idx.last_col()) {
140 			int n=e.arg(i).dim.nb_cols();
141 			int first_col=idx.first_col()-c;
142 			if (first_col&lt;n) { 				int last_col=idx.last_col()-c;
143 				DoubleIndex e_idx=DoubleIndex(e.arg(i).dim,
144 						idx.first_row(), idx.last_row(),
145 						first_col&lt;0? 0 : first_col, last_col&gt;=n? n-1 : last_col);
146 				res.push_back(&amp;get(e.arg(i),e_idx));
147 				all_cst &amp;= is_cst(*res.back());
148 				all_same &amp;= (res.back()==&amp;e.arg(i));
149 			}
150 			c+=n;
151 			assert(((int) i)&lt;e.nb_args);
152 			i++;
153 		}
154 	} else {
155 		int r=0;
156 		while (r&lt;=idx.last_row()) {
157 			int n=e.arg(i).dim.nb_rows();
158 			int first_row=idx.first_row()-r;
159 			if (first_row&lt;n) { 				int last_row=idx.last_row()-r;
160 				DoubleIndex e_idx=DoubleIndex(e.arg(i).dim,
161 						first_row&lt;0? 0 : first_row, last_row&gt;=n? n-1 : last_row,
162 						idx.first_col(), idx.last_col());
163 				res.push_back(&amp;get(e.arg(i),e_idx));
164 				all_cst &amp;= is_cst(*res.back());
165 				all_same &amp;= (res.back()==&amp;e.arg(i));
166 			}
167 			r+=n;
168 			assert(((int) i)&lt;e.nb_args);
169 			i++;
170 		}
171 	}
172 	if (res.size()==1)
173 		insert(e, *res.back());
174 	else if (all_cst) {
175 		Array&lt;const Domain&gt; arg_cst(res.size());
176 		for (i=0; i&lt;res.size(); i++)
177 			arg_cst.set_ref(i, to_cst(*res[i]));
178 		insert(e, ExprConstant::new_(Domain(arg_cst, e.row_vector())));
179 	} else if (((int) res.size())==e.nb_args &amp;&amp; all_same) {
180 		insert(e, e);
181 	} else
182 		insert(e, ExprVector::new_(res,e.orient));
183 }
184 void ExprSimplify::visit(const ExprIndex&amp; e) {
185 	const ExprNode&amp; expr=get(e.expr,e.index[idx]);
186 	insert(e, expr);
187 }
188 void ExprSimplify::visit(const ExprSymbol&amp; x) {
189 	if (idx.all())
190 		insert(x,x);
191 	else
192 		insert(x,x[idx]);
193 }
194 void ExprSimplify::visit(const ExprConstant&amp; c) {
195 	if (idx.all())
196 		insert(c,c);
197 	else
198 		if (c.is_mutable())
199 			insert(c,c[idx]); 		else
200 			insert(c,ExprConstant::new_(c.get()[idx]));
201 }
202 void ExprSimplify::visit_add_sub(const ExprBinaryOp&amp; e, bool sign) {
203 	const ExprNode&amp; l=get(e.left, idx);
204 	const ExprNode&amp; r=get(e.right, idx);
205 	const ExprNode*   el;   	bool lsign;             	const ExprConstant* cl; 
206 	if (is_cst(l)) {
207 		el=NULL;
208 		cl=dynamic_cast&lt;const ExprConstant*&gt;(&amp;l);
209 		lsign=true;
210 	}
211 	else if ((is_add(l) || is_sub(l)) &amp;&amp; is_cst(right(l))) {
212 		el=&amp;left(l);
213 		cl=dynamic_cast&lt;const ExprConstant*&gt;(&amp;(right(l)));
214 		lsign=is_add(l);
215 	}
216 	else {
217 		el=&amp;l;
218 		cl=NULL;
219 		lsign=true; 	}
220 	const ExprNode*   er;
221 	bool rsign;
222 	const ExprConstant* cr;
223 	if (is_cst(r)) {
224 		er=NULL;
225 		cr=dynamic_cast&lt;const ExprConstant*&gt;(&amp;r);
226 		rsign=sign;
227 	}
228 	else if ((is_add(r) || is_sub(r)) &amp;&amp; is_cst(right(r))) {
229 		er=&amp;left(r);
230 		cr=dynamic_cast&lt;const ExprConstant*&gt;(&amp;(right(r))); 		rsign = (sign &amp;&amp; is_add(r)) || (!sign &amp;&amp; is_sub(r));
231 	}
232 	else {
233 		er=&amp;r;
234 		cr=NULL;
235 		rsign=true; 	}
236 	const ExprConstant* cfinal; 
237 	bool cst_sign=true;
238 	if (cl) {
239 		if (cr) {
240 			if (cr-&gt;is_zero())      { cfinal=cl; cst_sign=lsign; }
241 			else if (cl-&gt;is_zero()) { cfinal=cr; cst_sign=rsign; }
242 			else
243 				if (lsign)
244 					if (rsign)        cfinal=&amp;ExprConstant::new_(cl-&gt;get()+cr-&gt;get());
245 					else              cfinal=&amp;ExprConstant::new_(cl-&gt;get()-cr-&gt;get());
246 <a name="0"></a>				else
247 					if (rsign)        cfinal=&amp;ExprConstant::new_(cr-&gt;get()-cl-&gt;get());
248 					else              cfinal=&amp;ExprConstant::new_(-cl-&gt;get()-cr-&gt;get());
249 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>		} else                      { cfinal=cl; cst_sign=lsign; }
250 	}
251 	else if (cr)                    { cfinal=cr; cst_sign=rsign; }
252 	else {</b></font>
253 		if ((&amp;l == &amp;e.left) &amp;&amp; (&amp;r == &amp;e.right)) { 			insert(e, e);
254 		} else if (sign)
255 			insert(e, l+r);
256 		else
257 			insert(e,l-r);
258 		return;
259 	}
260 	if (cfinal-&gt;is_zero() &amp;&amp; cfinal!=cr &amp;&amp; cfinal!=cl) { 		delete cfinal;  		cfinal=NULL;
261 	}
262 	const ExprNode* efinal;
263 	bool expr_sign=true;
264 	if (el)
265 		if (er)
266 			if (sign) efinal=&amp;(*el+*er);
267 			else      efinal=&amp;(*el-*er);
268 		else          efinal=el;
269 	else if (er)    { efinal=er; expr_sign=sign; }
270 	else              efinal=NULL;
271 	if (!cfinal || cfinal-&gt;is_zero()) {
272 		if (!efinal) { 			if (!cfinal) {
273 				Domain d(e.dim.index_dim(idx)); d.clear();
274 				insert(e,ExprConstant::new_(d));
275 			} else
276 				insert(e,*cfinal);
277 		}
278 		else if (expr_sign) insert(e,*efinal);
279 		else insert(e,-(*efinal));
280 	} else {
281 		if (!efinal)
282 			if (cst_sign) insert(e,*cfinal);
283 			else
284 				insert(e,ExprConstant::new_(-(cfinal-&gt;get())));
285 		else
286 			if (expr_sign)
287 				if (cst_sign) insert(e,(*efinal)+(*cfinal));
288 				else          insert(e,(*efinal)-(*cfinal));
289 			else
290 				if (cst_sign)
291 					insert(e,(-*efinal)+(*cfinal));
292 				else
293 					insert(e,(-*efinal)-(*cfinal));
294 	}
295 }
296 void ExprSimplify::visit(const ExprAdd&amp; e) {
297 	visit_add_sub(e,true);
298 }
299 void ExprSimplify::visit(const ExprSub&amp; e) {
300 	visit_add_sub(e,false);
301 }
302 void ExprSimplify::visit(const ExprMul&amp; e) {
303 	DoubleIndex l_idx;
304 	DoubleIndex r_idx;
305 	if (e.left.dim.is_scalar()) {
306 		l_idx=DoubleIndex::all(e.left.dim);
307 		r_idx=idx;
308 	} else {
309 		l_idx=DoubleIndex::rows(e.left.dim,idx.first_row(),idx.last_row());
310 		r_idx=DoubleIndex::cols(e.right.dim,idx.first_col(),idx.last_col());
311 	}
312 	const ExprNode&amp; l=get(e.left, l_idx);
313 	const ExprNode&amp; r=get(e.right, r_idx);
314 	int index;
315 	if (is_identity(l) || (is_cst(r) &amp;&amp; to_cst(r).is_zero()))
316 		insert(e, r);
317 	else if (is_identity(r) || (is_cst(l) &amp;&amp; to_cst(l).is_zero()))
318 		insert(e, l);
319 	else if ((index=is_selection(l))!=-1) {
320 		const ExprNode&amp; r2=get(e.right, r_idx[DoubleIndex::one_row(r.dim,index)]);
321 		insert(e, r2);
322 	}
323 	else if ((index=is_selection(r))!=-1) {
324 		const ExprNode&amp; l2=get(e.left, l_idx[DoubleIndex::one_col(l.dim,index)]);
325 		insert(e, l2);
326 	}
327 	else if (is_cst(l)) {
328 		if (is_cst(r))
329 			insert(e, ExprConstant::new_(to_cst(l)*to_cst(r)));
330 		else if (is_mul(r) &amp;&amp; is_cst(left(r)))
331 			insert(e, ExprConstant::new_(to_cst(l)*to_cst(left(r)))*(right(r)));
332 		else if ((&amp;l == &amp;e.left) &amp;&amp; (&amp;r == &amp;e.right)) { 			insert(e, e);
333 		} else
334 			insert(e, l*r);
335 	}
336 	else if (is_mul(l) &amp;&amp; is_cst(left(l))) {
337 		if (is_cst(r) &amp;&amp; r.dim.is_scalar())
338 			insert(e, ExprConstant::new_(to_cst(r)*to_cst(left(l)))*(right(l)));
339 		else if (is_mul(r) &amp;&amp; is_cst(left(r)) &amp;&amp; left(r).dim.is_scalar())
340 			insert(e, ExprConstant::new_(to_cst(left(r))*to_cst(left(l)))*(right(l)*right(r)));
341 		else
342 			insert(e, left(l)*(right(l)*r));
343 	}
344 	else {
345 		if (is_cst(r) &amp;&amp; r.dim.is_scalar())
346 			insert(e, r*l);
347 		else if (is_mul(r) &amp;&amp; is_cst(left(r)) &amp;&amp; left(r).dim.is_scalar())
348 			insert(e, left(r)*(l*right(r)));
349 		else if ((&amp;l == &amp;e.left) &amp;&amp; (&amp;r == &amp;e.right)) { 			insert(e, e);
350 		} else
351 			insert(e, l*r);
352 	}
353 }
354 void ExprSimplify::visit(const ExprDiv&amp; e) {
355 	const ExprNode&amp; l=get(e.left, idx);
356 	const ExprNode&amp; r=get(e.right, idx);
357 	if (is_cst(l) &amp;&amp; to_cst(l).is_zero())
358 		insert(e, l);
359 	else if (is_identity(r))
360 		insert(e, l);
361 	else if (is_cst(l) &amp;&amp; is_cst(r))
362 		insert(e, ExprConstant::new_(to_cst(l)/to_cst(r)));
363 	else if ((&amp;l == &amp;e.left) &amp;&amp; (&amp;r == &amp;e.right)) { 		insert(e, e);
364 	} else
365 		insert(e, l/r);
366 }
367 //	if (&amp;e.expr == &amp;EXPR)  
368 void ExprSimplify::binary(const ExprBinaryOp&amp; e,
369 		std::function&lt;Domain(const Domain&amp;, const Domain&amp;)&gt; fcst,
370 		std::function&lt;const ExprNode&amp;(const ExprNode&amp;, const ExprNode&amp;)&gt; fctr,
371 		bool index_distributive) {
372 	if (index_distributive) {
373 		const ExprNode&amp; l=get(e.left, idx);
374 		const ExprNode&amp; r=get(e.right, idx);
375 		if (is_cst(l) &amp;&amp; is_cst(r))
376 			insert(e, ExprConstant::new_(fcst(to_cst(l),to_cst(r))));
377 		else if ((&amp;l == &amp;e.left) &amp;&amp; (&amp;r == &amp;e.right)) { 			insert(e, e);
378 		} else
379 			insert(e, fctr(l,r));
380 	} else {
381 		if (is_cst(e.left) &amp;&amp; is_cst(e.right))
382 			insert(e, ExprConstant::new_(fcst(to_cst(e.left),to_cst(e.right))[idx]));
383 		else {
384 			if (idx.all())
385 				insert(e, e);
386 			else
387 				insert(e, e[idx]);
388 		}
389 	}
390 }
391 void ExprSimplify::unary(const ExprUnaryOp&amp; e,
392 		std::function&lt;Domain(const Domain&amp;)&gt; fcst,
393 		std::function&lt;const ExprNode&amp;(const ExprNode&amp;)&gt; fctr, bool index_distributive) {
394 	if (index_distributive) {
395 		const ExprNode&amp; expr=get(e.expr, idx);
396 		if (is_cst(expr))
397 			insert(e, ExprConstant::new_(fcst(to_cst(expr))));
398 		else if (&amp;e.expr == &amp;expr) { 			insert(e, e);
399 		} else
400 			insert(e, fctr(expr));
401 	} else {
402 		const ExprNode&amp; expr=get(e.expr, DoubleIndex::all(e.expr.dim));
403 		if (is_cst(expr))
404 			insert(e, ExprConstant::new_(fcst(to_cst(expr))[idx]));
405 		else {
406 			if (idx.all()) 				insert(e, fctr(expr));
407 			else
408 				insert(e, fctr(expr)[idx]);
409 		}
410 	}
411 }
412 void ExprSimplify::visit(const ExprChi&amp; e) {
413 	const ExprNode&amp; arg0=get(e.args[0], idx);
414 	if (is_cst(arg0)) {
415 		assert(arg0.dim.is_scalar());
416 		const Interval&amp; c = to_cst(arg0).i();
417 		if (c.lb() &gt; 0) {
418 			const ExprNode&amp; arg1=get(e.args[1], idx);
419 			insert(e, arg1);
420 			return;
421 		} else if (c.ub() &lt;= 0) {
422 			const ExprNode&amp; arg2=get(e.args[2], idx);
423 			insert(e, arg2);
424 			return;
425 		}
426 	} else {
427 		insert(e, e);
428 	}
429 }
430 void ExprSimplify::visit(const ExprApply&amp; e) {
431 	not_implemented("Simplify with Apply");
432 }
433 void ExprSimplify::visit(const ExprPower&amp; e) {
434 	unary(  e,
435 			[&amp;e](const Domain&amp; d)-&gt;Domain            { return pow(d,e.expon); },
436 			[&amp;e](const ExprNode&amp; x)-&gt;const ExprNode&amp; { return ExprPower::new_(x,e.expon); },
437 			false
438 	);
439 }
440 void ExprSimplify::visit(const ExprGenericBinaryOp&amp; e) {
441 	binary( e,
442 			e.eval,
443 			[&amp;e](const ExprNode&amp; x,const ExprNode&amp; y)-&gt;const ExprNode&amp; { return ExprGenericBinaryOp::new_(e.name,x,y);},
444 			false);
445 }
446 typedef Domain (*_domain_una_op)(const Domain&amp;);
447 typedef Domain (*_domain_bin_op)(const Domain&amp;,const Domain&amp;);
448 void ExprSimplify::visit(const ExprMax&amp; e)   { binary(e, (_domain_bin_op) max,      ExprMax::new_,true); }
449 void ExprSimplify::visit(const ExprMin&amp; e)   { binary(e, (_domain_bin_op) min,      ExprMin::new_,true); }
450 void ExprSimplify::visit(const ExprAtan2&amp; e) { binary(e, (_domain_bin_op) atan2,    ExprAtan2::new_,false); }
451 void ExprSimplify::visit(const ExprMinus&amp; e) { unary(e,  (_domain_una_op) operator-,ExprMinus::new_,true); }
452 void ExprSimplify::visit(const ExprTrans&amp; e) {
453 	const ExprNode&amp; expr=get(e.expr, idx.transpose());
454 	if (is_cst(expr))
455 		insert(e, ExprConstant::new_(transpose(to_cst(expr))));
456 	else if (expr.dim.is_scalar())
457 		insert(e,expr);
458 	else if (&amp;e.expr == &amp;expr) { 		insert(e, e);
459 	} else
460 		insert(e, ExprTrans::new_(expr));
461 }
462 void ExprSimplify::visit(const ExprGenericUnaryOp&amp; e) {
463 	unary(e, e.eval,
464 			[&amp;e](const ExprNode&amp; x)-&gt;const ExprNode&amp; { return ExprGenericUnaryOp::new_(e.name,x);},
465 			false);
466 }
467 void ExprSimplify::visit(const ExprSign&amp; e)  { unary(e, (_domain_una_op) sign, ExprSign::new_, true);  }
468 void ExprSimplify::visit(const ExprAbs&amp; e)   { unary(e, (_domain_una_op) abs,  ExprAbs::new_,  true);  }
469 void ExprSimplify::visit(const ExprSqr&amp; e)   { unary(e, (_domain_una_op) sqr,  ExprSqr::new_,  false); }
470 void ExprSimplify::visit(const ExprSqrt&amp; e)  { unary(e, (_domain_una_op) sqrt, ExprSqrt::new_, false); }
471 void ExprSimplify::visit(const ExprExp&amp; e)   { unary(e, (_domain_una_op) exp,  ExprExp::new_,  false); }
472 void ExprSimplify::visit(const ExprLog&amp; e)   { unary(e, (_domain_una_op) log,  ExprLog::new_,  false); }
473 void ExprSimplify::visit(const ExprCos&amp; e)   { unary(e, (_domain_una_op) cos,  ExprCos::new_,  false); }
474 void ExprSimplify::visit(const ExprSin&amp; e)   { unary(e, (_domain_una_op) sin,  ExprSin::new_,  false); }
475 void ExprSimplify::visit(const ExprTan&amp; e)   { unary(e, (_domain_una_op) tan,  ExprTan::new_,  false); }
476 void ExprSimplify::visit(const ExprCosh&amp; e)  { unary(e, (_domain_una_op) cosh, ExprCosh::new_, false); }
477 void ExprSimplify::visit(const ExprSinh&amp; e)  { unary(e, (_domain_una_op) sinh, ExprSinh::new_, false); }
478 void ExprSimplify::visit(const ExprTanh&amp; e)  { unary(e, (_domain_una_op) tanh, ExprTanh::new_, false); }
479 void ExprSimplify::visit(const ExprAcos&amp; e)  { unary(e, (_domain_una_op) acos, ExprAcos::new_, false); }
480 void ExprSimplify::visit(const ExprAsin&amp; e)  { unary(e, (_domain_una_op) asin, ExprAsin::new_, false); }
481 void ExprSimplify::visit(const ExprAtan&amp; e)  { unary(e, (_domain_una_op) atan, ExprAtan::new_, false); }
482 void ExprSimplify::visit(const ExprAcosh&amp; e) { unary(e, (_domain_una_op) acosh,ExprAcosh::new_,false); }
483 void ExprSimplify::visit(const ExprAsinh&amp; e) { unary(e, (_domain_una_op) asinh,ExprAsinh::new_,false); }
484 void ExprSimplify::visit(const ExprAtanh&amp; e) { unary(e, (_domain_una_op) atanh,ExprAtanh::new_,false); }
485 void ExprSimplify::visit(const ExprFloor&amp; e) { unary(e, (_domain_una_op) floor,ExprFloor::new_,false); }
486 void ExprSimplify::visit(const ExprCeil&amp; e)  { unary(e, (_domain_una_op) ceil, ExprCeil::new_, false); }
487 void ExprSimplify::visit(const ExprSaw&amp; e)   { unary(e, (_domain_una_op) saw,  ExprSaw::new_, false);  }
} </pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
