<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for ibex_CovManifold.cpp &amp; ibex_Cov.cpp</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for ibex_CovManifold.cpp &amp; ibex_Cov.cpp
      </h3>
<h1 align="center">
        18.0%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>ibex_CovManifold.cpp (13.707865%)<th>ibex_Cov.cpp (26.293104%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(93-103)<td><a href="#" name="0">(42-52)</a><td align="center"><font color="#ff0000">18</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(18-24)<td><a href="#" name="1">(19-25)</a><td align="center"><font color="#e20000">16</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(340-348)<td><a href="#" name="2">(83-88)</a><td align="center"><font color="#c60000">14</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(40-47)<td><a href="#" name="3">(34-41)</a><td align="center"><font color="#b80000">13</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>ibex_CovManifold.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "ibex_CovManifold.h"
2 #include &lt;sstream&gt;
3 #include &lt;algorithm&gt;
4 <a name="1"></a>
5 using namespace std;
6 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>namespace ibex {
7 const unsigned int CovManifold::FORMAT_VERSION = 1;
8 const unsigned int CovManifold::subformat_level = 4;
9 const unsigned int CovManifold::subformat_number = 0;</b></font>
10 CovManifold::CovManifold(size_t n, size_t m, size_t nb_ineq, BoundaryType boundary_type) :
11 		CovIBUList(n, INNER_AND_OUTER_PT), data(new Data()), own_data(true) {
12 	data-&gt;_manifold_nb_eq = m;
13 	data-&gt;_manifold_nb_ineq = nb_ineq;
14 	data-&gt;_manifold_boundary_type =  boundary_type;
15 	if (n&gt;0) { 		if (m==0)
16 			data-&gt;_manifold_solution_varset.push_back(VarSet(n,BitSet::all(n),false)); <a name="3"></a>		else if (m==n)
17 			data-&gt;_manifold_solution_varset.push_back(VarSet(n,BitSet::empty(n),false)); 	}
18 <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
19 CovManifold::CovManifold(const char* filename) : CovManifold(0,0,0 	stack&lt;unsigned int&gt; format_id;
20 	stack&lt;unsigned int&gt; format_version;
21 	ifstream* f = CovManifold::read(filename, *this, format_id, format_version);
22 	f-&gt;close();
23 	delete f;</b></font>
24 }
25 CovManifold::CovManifold(const Cov&amp; cov, bool copy) : CovIBUList(cov, copy) {
26 	const CovManifold* covManifold = dynamic_cast&lt;const CovManifold*&gt;(&amp;cov);
27 	if (covManifold) {
28 		if (copy) {
29 			data = new Data(*covManifold-&gt;data); 			own_data = true;
30 		} else {
31 			data = covManifold-&gt;data;
32 			own_data = false;
33 		}
34 	} else {
35 		data = new Data();
36 		data-&gt;_manifold_nb_eq = 0;
37 		data-&gt;_manifold_nb_ineq = 0;
38 		data-&gt;_manifold_boundary_type = EQU_ONLY; 		for (size_t i=0; i&lt;size(); i++) {
39 			switch(CovIBUList::status(i)) {
40 			case CovIBUList::INNER :
41 				data-&gt;_manifold_status.push_back(CovManifold::SOLUTION);
42 				data-&gt;_manifold_solution.push_back(i);
43 				if (data-&gt;_manifold_solution_varset.empty())
44 					data-&gt;_manifold_solution_varset.push_back(VarSet(n,BitSet::all(n),false)); 				break;
45 			case CovIBUList::BOUNDARY :
46 			case CovIBUList::UNKNOWN :
47 				data-&gt;_manifold_status.push_back(CovManifold::UNKNOWN);
48 				data-&gt;_manifold_unknown.push_back(i);
49 				break;
50 			default :
51 				assert(false);
52 			}
53 <a name="0"></a>		}
54 		own_data = true;
55 	}
56 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
57 void CovManifold::save(const char* filename) const {
58 	stack&lt;unsigned int&gt; format_id;
59 	stack&lt;unsigned int&gt; format_version;
60 	ofstream* of=CovManifold::write(filename, *this, format_id, format_version);
61 	of-&gt;close();
62 	delete of;
63 }
64 CovManifold::~CovManifold() {</b></font>
65 	if (own_data) {
66 		delete data;
67 	}
68 }
69 void CovManifold::add(const IntervalVector&amp; x) {
70 	add_unknown(x);
71 }
72 void CovManifold::add_inner(const IntervalVector&amp; x) {
73 	if (nb_eq()&gt;0)
74 		ibex_error("[CovManifold] inner boxes not allowed with equalities");
75 	CovIBUList::add_inner(x);
76 	data-&gt;_manifold_solution.push_back(size()-1);
77 	data-&gt;_manifold_status.push_back(SOLUTION);
78 }
79 void CovManifold::add_boundary(const IntervalVector&amp; x) {
80 	if (nb_eq()&gt;0 &amp;&amp; nb_eq()&lt;n)
81 		ibex_error("[CovManifold]: a boundary box for an under-constrained system requires \"VarSet\" structure (parameters/variables)");
82 	add_boundary(x,data-&gt;_manifold_solution_varset[0]);
83 }
84 void CovManifold::add_boundary(const IntervalVector&amp; x, const VarSet&amp; varset) {
85 	switch (boundary_type()) {
86 	case EQU_ONLY  : CovIBUList::add_unknown(x); break;
87 	case FULL_RANK : CovIBUList::add_unknown(x); break;
88 	case HALF_BALL : CovIBUList::add_boundary(x); break;
89 	default        : assert(false);
90 	}
91 	data-&gt;_manifold_status.push_back(BOUNDARY);
92 	data-&gt;_manifold_boundary.push_back(size()-1);
93 	if (nb_eq()&gt;0 &amp;&amp; nb_eq()&lt;n) 		data-&gt;_manifold_boundary_varset.push_back(varset);
94 }
95 void CovManifold::add_unknown(const IntervalVector&amp; x) {
96 	CovIBUList::add_unknown(x);
97 	data-&gt;_manifold_unknown.push_back(size()-1);
98 	data-&gt;_manifold_status.push_back(UNKNOWN);
99 }
100 void CovManifold::add_solution(const IntervalVector&amp; existence, const IntervalVector&amp; unicity) {
101 	if (nb_eq() &lt; n)
102 		ibex_error("[CovManifold]: a solution of under-constrained system requires \"VarSet\" structure (parameters/variables)");
103 	add_solution(existence, unicity, data-&gt;_manifold_solution_varset[0]);
104 }
105 void CovManifold::add_solution(const IntervalVector&amp; existence, const IntervalVector&amp; unicity, const VarSet&amp; varset) {
106 	if (nb_eq()==0)
107 		ibex_error("[CovManifold]: solution boxes not allowed without equalities");
108 	CovIBUList::add_boundary(existence);
109 	data-&gt;_manifold_solution.push_back(size()-1);
110 	data-&gt;_manifold_unicity.push_back(unicity);
111 	data-&gt;_manifold_status.push_back(SOLUTION);
112 	if (nb_eq()&lt;n) 		data-&gt;_manifold_solution_varset.push_back(varset);
113 }
114 ostream&amp; operator&lt;&lt;(ostream&amp; os, const CovManifold&amp; manif) {
115 	for (size_t i=0; i&lt;manif.nb_solution(); i++) {
116 		os &lt;&lt; " solution n°" &lt;&lt; (i+1) &lt;&lt; " = " &lt;&lt; manif.solution(i) &lt;&lt; endl;
117 	}
118 	for (size_t i=0; i&lt;manif.nb_boundary(); i++) {
119 		os &lt;&lt; " boundary n°" &lt;&lt; (i+1) &lt;&lt; " = " &lt;&lt; manif.boundary(i) &lt;&lt; endl;
120 	}
121 	for (size_t i=0; i&lt;manif.nb_unknown(); i++) {
122 		os &lt;&lt; " unknown n°" &lt;&lt; (i+1) &lt;&lt; " = " &lt;&lt; manif.unknown(i) &lt;&lt; endl;
123 	}
124 	return os;
125 }
126 VarSet CovManifold::read_varset(ifstream&amp; f, size_t n, size_t m) {
127 	BitSet params(n);
128 	for (unsigned int j=0; j&lt;n-m; j++) {
129 		unsigned int v=read_pos_int(f);
130 		if (v&gt;n) {
131 			ibex_error("[CovManifold]: bad input file (bad parameter index)");
132 		}
133 		params.add(v); 	}
134 	return VarSet(n,params,false);
135 }
136 void CovManifold::write_varset(ofstream&amp; f, const VarSet&amp; varset) {
137 	for (int i=0; i&lt;varset.nb_param; i++)
138 		write_pos_int(f, varset.param(i));
139 }
140 ifstream* CovManifold::read(const char* filename, CovManifold&amp; cov, std::stack&lt;unsigned int&gt;&amp; format_id, std::stack&lt;unsigned int&gt;&amp; format_version) {
141 	ifstream* f = CovIBUList::read(filename, cov, format_id, format_version);
142 	size_t nb_solution, nb_boundary;
143 	if (format_id.empty() || format_id.top()!=subformat_number || format_version.top()!=FORMAT_VERSION) {
144 		(size_t&amp;) cov.data-&gt;_manifold_nb_eq = 0;
145 		(size_t&amp;) cov.data-&gt;_manifold_nb_ineq = 0;
146 		nb_solution = 0;
147 		nb_boundary = 0;
148 	}
149 	else {
150 		format_id.pop();
151 		format_version.pop();
152 		(size_t&amp;) cov.data-&gt;_manifold_nb_eq = read_pos_int(*f);
153 		(size_t&amp;) cov.data-&gt;_manifold_nb_ineq = read_pos_int(*f);
154 		unsigned int _boundary_type = read_pos_int(*f);
155 		switch (_boundary_type) {
156 		case 0: (BoundaryType&amp;) cov.data-&gt;_manifold_boundary_type = EQU_ONLY; break;
157 		case 1: (BoundaryType&amp;) cov.data-&gt;_manifold_boundary_type = FULL_RANK; break;
158 		case 2: (BoundaryType&amp;) cov.data-&gt;_manifold_boundary_type = HALF_BALL; break;
159 		default: ibex_error("[CovManifold]: unknown boundary type identifier.");
160 		}
161 		if (cov.nb_eq()&gt;0) {
162 			nb_solution = read_pos_int(*f);
163 			if (nb_solution &gt; cov.CovIBUList::nb_boundary())
164 				ibex_error("[CovManifold]: number of solutions &gt; number of CovIBUList boundary boxes (m&gt;0)");
165 			if (cov.nb_inner()&gt;0)
166 				ibex_error("[CovManifold]: the file should not contain 'solutions' in addition to inner boxes (m=0)");
167 			for (size_t i=0; i&lt;nb_solution; i++) {
168 				uint32_t j=read_pos_int(*f);
169 				if (!cov.data-&gt;_manifold_solution.empty()) { 					if (j&lt;cov.data-&gt;_manifold_solution.back())
170 						ibex_error("[CovManifold]: indices of solutions are not in increasing order.");
171 					if (j==cov.data-&gt;_manifold_solution.back())
172 						ibex_error("[CovManifold]: duplicated index of solution.");
173 				}
174 				cov.data-&gt;_manifold_solution.push_back(j);
175 				if (cov.nb_eq() &lt; cov.n)
176 					cov.data-&gt;_manifold_solution_varset.push_back(read_varset(*f, cov.n, cov.nb_eq()));
177 				cov.data-&gt;_manifold_unicity.push_back(read_box(*f, cov.n));
178 			}
179 		}
180 		nb_boundary = read_pos_int(*f);
181 		if (cov.boundary_type() != HALF_BALL &amp;&amp; nb_boundary &gt; cov.CovIBUList::nb_unknown())
182 			ibex_error("[CovManifold]: number of (uncertified) boundary boxes &gt; number of CovIBUList unknown boxes");
183 		if (cov.boundary_type() == HALF_BALL &amp;&amp; nb_boundary &gt; cov.CovIBUList::nb_boundary())
184 			ibex_error("[CovManifold]: number of boundary boxes &gt; number of CovIBUList boundary boxes");
185 		for (size_t i=0; i&lt;nb_boundary; i++) {
186 			uint32_t j=read_pos_int(*f);
187 			if (!cov.data-&gt;_manifold_boundary.empty()) { 				if (j&lt;cov.data-&gt;_manifold_boundary.back())
188 					ibex_error("[CovManifold]: indices of boundary boxes are not in increasing order.");
189 				if (j==cov.data-&gt;_manifold_boundary.back())
190 					ibex_error("[CovManifold]: duplicated index of boundary box.");
191 			}
192 			cov.data-&gt;_manifold_boundary.push_back(j);
193 			if (cov.nb_eq()&gt;0 &amp;&amp; cov.nb_eq() &lt; cov.n)
194 				cov.data-&gt;_manifold_boundary_varset.push_back(read_varset(*f, cov.n, cov.nb_eq()));
195 		}
196 	}
197 	if (cov.nb_eq()==0) {
198 		nb_solution = cov.CovIUList::nb_inner();
199 		for (size_t i=0; i&lt;cov.CovIUList::nb_inner(); i++) {
200 			cov.data-&gt;_manifold_solution.push_back(cov.CovIUList::data-&gt;_IU_inner[i]);
201 		}
202 	}
203 	vector&lt;size_t&gt;::const_iterator it_sol=cov.data-&gt;_manifold_solution.begin();
204 	vector&lt;size_t&gt;::const_iterator it_bnd=cov.data-&gt;_manifold_boundary.begin();
205 	for (size_t i=0; i&lt;cov.size(); i++) {
206 		if (it_sol!=cov.data-&gt;_manifold_solution.end() &amp;&amp; i==*it_sol) {
207 			if (cov.nb_eq()&gt;0 &amp;&amp; !cov.CovIBUList::is_boundary(i))
208 				ibex_error("[CovManifold]: a solution box must be a CovIBUList boundary box (if m&gt;0).");
209 			cov.data-&gt;_manifold_status.push_back(CovManifold::SOLUTION);
210 			++it_sol;
211 		} else if (it_bnd!=cov.data-&gt;_manifold_boundary.end() &amp;&amp; i==*it_bnd) {
212 			if (cov.boundary_type() != HALF_BALL &amp;&amp; !cov.CovIBUList::is_unknown(i))
213 				ibex_error("[CovManifold]: a (uncertified) boundary box must be a CovIBUList unknown box.");
214 			if (cov.boundary_type() == HALF_BALL &amp;&amp; !cov.CovIBUList::is_boundary(i))
215 				ibex_error("[CovManifold]: a boundary box must be a CovIBUList boundary box.");
216 			cov.data-&gt;_manifold_status.push_back(CovManifold::BOUNDARY);
217 			++it_bnd;
218 		} else {
219 			switch(cov.CovIBUList::status(i)) {
220 			case CovIBUList::BOUNDARY :
221 				cov.data-&gt;_manifold_unknown.push_back(i);
222 				cov.data-&gt;_manifold_status.push_back(CovManifold::UNKNOWN);
223 				break;
224 			case CovIBUList::UNKNOWN :
225 				cov.data-&gt;_manifold_unknown.push_back(i);
226 				cov.data-&gt;_manifold_status.push_back(CovManifold::UNKNOWN);
227 				break;
228 			default :
229 				assert(false);
230 			}
231 		}
232 	}
233 	if (it_sol!=cov.data-&gt;_manifold_solution.end()) ibex_error("[CovManifold]: invalid solution box index.");
234 	if (it_bnd!=cov.data-&gt;_manifold_boundary.end()) ibex_error("[CovManifold]: invalid boundary box index.");
235 	if (cov.n&gt;0 &amp;&amp; cov.nb_eq()==0)
236 		cov.data-&gt;_manifold_solution_varset.push_back(VarSet(cov.n,BitSet::all(cov.n),false)); <a name="2"></a>	else if (cov.n&gt;0 &amp;&amp; cov.nb_eq()==cov.n)
237 		cov.data-&gt;_manifold_solution_varset.push_back(VarSet(cov.n,BitSet::empty(cov.n),false)); 
238 <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	return f;
239 }
240 ofstream* CovManifold::write(const char* filename, const CovManifold&amp; cov, std::stack&lt;unsigned int&gt;&amp; format_id, std::stack&lt;unsigned int&gt;&amp; format_version) {
241 	format_id.push(subformat_number);
242 	format_version.push(FORMAT_VERSION);
243 	ofstream* f = CovIBUList::write(filename, cov, format_id, format_version);</b></font>
244 	write_pos_int(*f, cov.nb_eq());
245 	write_pos_int(*f, cov.nb_ineq());
246 	switch(cov.boundary_type()) {
247 	case INNER_PT  : write_pos_int(*f, 0); break;
248 	case FULL_RANK : write_pos_int(*f, 1); break;
249 	case HALF_BALL : write_pos_int(*f, 2); break;
250 	default        : assert(false);
251 	}
252 	if (cov.nb_eq()&gt;0) {
253 		write_pos_int(*f, cov.nb_solution());
254 		std::vector&lt;VarSet&gt;::const_iterator it_varset=cov.data-&gt;_manifold_solution_varset.begin();
255 		std::vector&lt;IntervalVector&gt;::const_iterator it_unicity=cov.data-&gt;_manifold_unicity.begin();
256 		for (vector&lt;size_t&gt;::const_iterator it=cov.data-&gt;_manifold_solution.begin(); it!=cov.data-&gt;_manifold_solution.end(); ++it) {
257 			assert(*it&lt;numeric_limits&lt;uint32_t&gt;::max());
258 			write_pos_int(*f, (uint32_t) *it);
259 			if (cov.nb_eq() &lt; cov.n) {
260 				write_varset(*f, *it_varset);
261 				++it_varset;
262 			}
263 			write_box(*f, *it_unicity);
264 			++it_unicity;
265 		}
266 	}
267 	write_pos_int(*f, cov.nb_boundary());
268 	std::vector&lt;VarSet&gt;::const_iterator it_varset=cov.data-&gt;_manifold_boundary_varset.begin();
269 	for (vector&lt;size_t&gt;::const_iterator it=cov.data-&gt;_manifold_boundary.begin(); it!=cov.data-&gt;_manifold_boundary.end(); ++it) {
270 		assert(*it&lt;numeric_limits&lt;uint32_t&gt;::max());
271 		write_pos_int(*f, (uint32_t) *it);
272 		if (cov.nb_eq()&gt;0 &amp;&amp; cov.nb_eq() &lt; cov.n) {
273 			write_varset(*f, *it_varset);
274 			++it_varset;
275 		}
276 	}
277 	return f;
278 }
279 void CovManifold::format(stringstream&amp; ss, const string&amp; title, std::stack&lt;unsigned int&gt;&amp; format_id, std::stack&lt;unsigned int&gt;&amp; format_version) {
280 	format_id.push(subformat_number);
281 	format_version.push(FORMAT_VERSION);
282 	CovIBUList::format(ss, title, format_id, format_version);
283 	ss
284 	&lt;&lt; space &lt;&lt; " - 1 integer:     the number m of equalities\n"
285 	&lt;&lt; space &lt;&lt; " - 1 integer:     the number of inequalities\n"
286 	&lt;&lt; space &lt;&lt; " - 1 integer:     the type of boundary boxes:\n"
287 	&lt;&lt; space &lt;&lt; "                  - 0=only equalities are certified.\n"
288 	&lt;&lt; space &lt;&lt; "                  - 1=equalities are certified and the \n"
289 	&lt;&lt; space &lt;&lt; "                    gradients of all active constraints\n"
290 	&lt;&lt; space &lt;&lt; "                    are linearly independent.\n"
291 	&lt;&lt; space &lt;&lt; "                  - 2=the intersection of the manifold and\n"
292 	&lt;&lt; space &lt;&lt; "                    the box is homeomorphic to a hall-ball\n"
293 	&lt;&lt; space &lt;&lt; "                    of R^n.\n"
294 	&lt;&lt; space &lt;&lt; " +----[if m&gt;0]----\n"
295 	&lt;&lt; space &lt;&lt; " | - 1 integer:   the number Ns of solution boxes (&lt;= Nb)\n"
296 	&lt;&lt; space &lt;&lt; " | - Ns solutions:each solution is the following sequence:\n"
297 	&lt;&lt; "|    CovManifold    |" &lt;&lt;
298 	            " |                - 1 integer: the index of the solution\n"
299 	&lt;&lt; space &lt;&lt; " |                  (belongs to CovIBUList boundar boxes);\n"
300 	&lt;&lt; space &lt;&lt; " |                - [if m&lt;n] n-m integers: the indices of\n"
301 	&lt;&lt; space &lt;&lt; " |                  parameters in the parametric proofs\n"
302 	&lt;&lt; space &lt;&lt; " |                - 2*n real values: the unicity box in the\n"
303 	&lt;&lt; space &lt;&lt; " |                  proof (lb(x1), ub(x1),..., ub(xn))\n"
304 	&lt;&lt; space &lt;&lt; " +----------------\n"
305 	&lt;&lt; space &lt;&lt; " - 1 integer:     the number Nbb of boundary boxes\n"
306 	&lt;&lt; space &lt;&lt; " - Nbb times      the following sequence:\n"
307 	&lt;&lt; space &lt;&lt; "                  - 1 integer: the index of the boundary \n"
308 	&lt;&lt; space &lt;&lt; "                    box (belongs to CovIBUList boundary or \n"
309 	&lt;&lt; space &lt;&lt; "                    unknown boxes)\n"
310 	&lt;&lt; space &lt;&lt; "                  - [if m&gt;0 and m&lt;n]: \n"
311 	&lt;&lt; space &lt;&lt; "                    n-m integers: the indices of parameters\n"
312 	&lt;&lt; space &lt;&lt; "                    in the parametric proofs\n"
313 	&lt;&lt; separator;
314 }
315 string CovManifold::format() {
316 	stringstream ss;
317 	stack&lt;unsigned int&gt; format_id;
318 	stack&lt;unsigned int&gt; format_version;
319 	format(ss, "CovManifold", format_id, format_version);
320 	return ss.str();
321 }
322 } 
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>ibex_Cov.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "ibex_Cov.h"
2 #include &lt;sstream&gt;
3 #include &lt;cassert&gt;
4 #include &lt;string.h&gt;
5 <a name="1"></a>
6 using namespace std;
7 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>namespace ibex {
8 const unsigned int  Cov::FORMAT_VERSION = 1;
9 const unsigned int Cov::subformat_level = 0;
10 const unsigned int Cov::subformat_number = 0;</b></font>
11 const size_t Cov::SIGNATURE_LENGTH = 20;
12 const char* Cov::SIGNATURE = "IBEX COVERING FILE ";
13 const string Cov::separator = "+-------------------+-----------------------------------------------------------\n";
14 const string Cov::space     = "|                   |";
15 <a name="3"></a>
16 Cov::Cov(size_t n) : n(n) {
17 <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
18 Cov::Cov(const char* filename) : n(0 	stack&lt;unsigned int&gt; format_id;
19 	stack&lt;unsigned int&gt; format_version;
20 <a name="0"></a>	ifstream* f = Cov::read(filename, *this, format_id, format_version);
21 	f-&gt;close();
22 	delete f;</b></font>
23 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
24 void Cov::save(const char* filename) const {
25 	stack&lt;unsigned int&gt; format_id;
26 	stack&lt;unsigned int&gt; format_version;
27 	ofstream* of=Cov::write(filename, *this, format_id, format_version);
28 	of-&gt;close();
29 	delete of;
30 }
31 Cov::~Cov() {</b></font>
32 }
33 ifstream* Cov::read(const char* filename, Cov&amp; cov, stack&lt;unsigned int&gt;&amp; format_id, std::stack&lt;unsigned int&gt;&amp; format_version) {
34 	ifstream* f = new ifstream();
35 	f-&gt;open(filename, ios::in | ios::binary);
36 	if (f-&gt;fail()) ibex_error("[Cov]: cannot open input file.\n");
37 	read_signature(*f);
38 	read_format_seq(*f, format_id, format_version);
39 	if (format_version.top()&gt;FORMAT_VERSION) {
40 		ibex_error("[Cov] unsupported format version");
41 	}
42 	if (format_id.top()!=subformat_number || format_version.top()!=FORMAT_VERSION)
43 		return f;
44 	else {
45 		format_id.pop();
46 		format_version.pop();
47 	}
48 	size_t _n = read_pos_int(*f);
49 <a name="2"></a>
50 	(size_t&amp;) cov.n = _n;
51 <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	return f;
52 }
53 ofstream* Cov::write(const char* filename, const Cov&amp; cov, std::stack&lt;unsigned int&gt;&amp; format_id, std::stack&lt;unsigned int&gt;&amp; format_version) {
54 	ofstream* f = new ofstream();</b></font>
55 	f-&gt;open(filename, ios::out | ios::binary);
56 	if (f-&gt;fail())
57 		ibex_error("[Cov]: cannot create output file.\n");
58 	write_signature(*f);
59 	format_id.push(subformat_number);
60 	format_version.push(FORMAT_VERSION);
61 	write_format_seq(*f, format_id, format_version);
62 	write_pos_int(*f, cov.n);
63 	return f;
64 }
65 void Cov::read_signature(ifstream&amp; f) {
66 	char* sig=new char[SIGNATURE_LENGTH];
67 	f.read(sig, SIGNATURE_LENGTH*sizeof(char));
68 	if (f.eof()) ibex_error("[manifold]: unexpected end of file.");
69 	if (strcmp(sig,SIGNATURE)!=0)
70 	ibex_error("[Cov]: not an Ibex \"cover\" file.");
71 	delete[] sig;
72 }
73 void Cov::read_format_seq(std::ifstream&amp; f, stack&lt;unsigned int&gt;&amp; format_id, std::stack&lt;unsigned int&gt;&amp; format_version) {
74 	size_t format_level = read_pos_int(f);
75 	assert(format_id.empty());
76 	assert(format_version.empty());
77 	list&lt;unsigned int&gt; tmp;
78 	for (size_t i=0; i&lt;=format_level; i++)
79 		tmp.push_front(read_pos_int(f));
80 	for (list&lt;unsigned int&gt;::const_iterator it=tmp.begin(); it!=tmp.end(); ++it)
81 		format_id.push(*it);
82 	tmp.clear();
83 	for (size_t i=0; i&lt;=format_level; i++)
84 		tmp.push_front(read_pos_int(f));
85 	for (list&lt;unsigned int&gt;::const_iterator it=tmp.begin(); it!=tmp.end(); ++it)
86 		format_version.push(*it);
87 }
88 unsigned int Cov::read_pos_int(ifstream&amp; f) {
89 	uint32_t x;
90 	f.read((char*) &amp;x, sizeof(x)); //f &gt;&gt; x;
91 	if (f.eof()) ibex_error("[Cov]: unexpected end of file.");
92 	return x;
93 }
94 double Cov::read_double(ifstream&amp; f) {
95 	double x;
96 	f.read((char*) &amp;x, sizeof(x)); //f &gt;&gt; x;
97 	if (f.eof()) ibex_error("[Cov]: unexpected end of file.");
98 	return x;
99 }
100 void Cov::write_signature(ofstream&amp; f) {
101 	f.write(SIGNATURE, SIGNATURE_LENGTH*sizeof(char));
102 }
103 void Cov::write_format_seq(std::ofstream&amp; f, std::stack&lt;unsigned int&gt;&amp; format_id, std::stack&lt;unsigned int&gt;&amp; format_version) {
104 	write_pos_int(f, format_id.size()-1); 
105 	assert(format_version.size()==format_id.size());
106 	while (!format_id.empty()) {
107 		write_pos_int(f, format_id.top());
108 		format_id.pop();
109 	}
110 	while (!format_version.empty()) {
111 		write_pos_int(f, format_version.top());
112 		format_version.pop();
113 	}
114 }
115 void Cov::write_pos_int(ofstream&amp; f, uint32_t x) {
116 	f.write((char*) &amp;x, sizeof(uint32_t));
117 }
118 void Cov::write_double(ofstream&amp; f, double x) {
119 	f.write((char*) &amp;x, sizeof(x));
120 }
121 void Cov::format(stringstream&amp; ss, const string&amp; title, stack&lt;unsigned int&gt;&amp; format_id, std::stack&lt;unsigned int&gt;&amp; format_version) {
122 	format_id.push(subformat_number);
123 	format_version.push(FORMAT_VERSION);
124 	ss
125 	&lt;&lt; "\n"
126 	&lt;&lt; "+-------------------------------------------------------------------------------\n"
127 	&lt;&lt; "|                          " &lt;&lt; title &lt;&lt; " file format\n"
128 	"|\n"
129 	"| Note:\n"
130 	"| - integer values are unsigned 32 bits integer (uint32_t)\n"
131 	"| - real values are 64 bits double\n"
132 	"| - all indices start from 0.\n"
133 	&lt;&lt; separator
134 	&lt;&lt; space &lt;&lt; " - the signature: the null-terminated sequence of " &lt;&lt; SIGNATURE_LENGTH &lt;&lt;  "\n"
135 	&lt;&lt; space &lt;&lt;	"                  characters \"" &lt;&lt; SIGNATURE &lt;&lt; "\"\n"
136 	&lt;&lt; "|        Cov        |" &lt;&lt;
137 	"                  (mind the space at the end)\n"
138 	&lt;&lt; space &lt;&lt; " - 1 integer:     the format level L (=" &lt;&lt; format_id.size()-1 &lt;&lt; " in the case of\n"
139 	&lt;&lt; space &lt;&lt; "                  " &lt;&lt; title &lt;&lt; ")\n"
140 	&lt;&lt; space &lt;&lt; " - L+1 integers:  the format identifying sequence:\n"
141 	&lt;&lt; space &lt;&lt; "                      ";
142 	while (!format_id.empty()) {
143 		ss &lt;&lt; format_id.top();
144 		format_id.pop();
145 		if (!format_id.empty()) ss &lt;&lt; ' ';
146 	}
147 	ss
148 	&lt;&lt; "\n"
149 	&lt;&lt; space &lt;&lt; "                  (in the case of " &lt;&lt; title &lt;&lt; ")\n"
150 	&lt;&lt; space &lt;&lt; " - L+1 integers:  the format version sequence:\n"
151 	&lt;&lt; space &lt;&lt; "                      ";
152 	while (!format_version.empty()) {
153 		ss &lt;&lt; format_version.top();
154 		format_version.pop();
155 		if (!format_version.empty()) ss &lt;&lt; ' ';
156 	}
157 	ss
158 	&lt;&lt; "\n"
159 	&lt;&lt; space &lt;&lt; "                  (in the case of " &lt;&lt; title &lt;&lt; ")\n"
160 	&lt;&lt; space &lt;&lt; " - 1 integer:     the dimension n of boxes (# of variables)\n"
161 	&lt;&lt; separator;
162 }
163 string Cov::format() {
164 	stringstream ss;
165 	stack&lt;unsigned int&gt; format_id;
166 	stack&lt;unsigned int&gt; format_version;
167 	format(ss, "COV", format_id, format_version);
168 	return ss.str();
169 }
} </pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
