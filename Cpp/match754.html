<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for ibex_CovManifold.cpp & ibex_Cov.cpp</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for ibex_CovManifold.cpp & ibex_Cov.cpp
      </h3>
      <h1 align="center">
        18.0%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>ibex_CovManifold.cpp (13.707865%)<TH>ibex_Cov.cpp (26.293104%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match754-0.html#0',2,'match754-1.html#0',3)" NAME="0">(93-103)<TD><A HREF="javascript:ZweiFrames('match754-0.html#0',2,'match754-1.html#0',3)" NAME="0">(42-52)</A><TD ALIGN=center><FONT COLOR="#ff0000">18</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match754-0.html#1',2,'match754-1.html#1',3)" NAME="1">(18-24)<TD><A HREF="javascript:ZweiFrames('match754-0.html#1',2,'match754-1.html#1',3)" NAME="1">(19-25)</A><TD ALIGN=center><FONT COLOR="#e20000">16</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match754-0.html#2',2,'match754-1.html#2',3)" NAME="2">(340-348)<TD><A HREF="javascript:ZweiFrames('match754-0.html#2',2,'match754-1.html#2',3)" NAME="2">(83-88)</A><TD ALIGN=center><FONT COLOR="#c60000">14</FONT>
<TR><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match754-0.html#3',2,'match754-1.html#3',3)" NAME="3">(40-47)<TD><A HREF="javascript:ZweiFrames('match754-0.html#3',2,'match754-1.html#3',3)" NAME="3">(34-41)</A><TD ALIGN=center><FONT COLOR="#b80000">13</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>ibex_CovManifold.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
//============================================================================
//                                  I B E X
// File        : ibex_CovManifold.cpp
// Author      : Gilles Chabert
// Copyright   : IMT Atlantique (France)
// License     : See the LICENSE file
// Created     : Nov 08, 2018
// Last update : Feb 28, 2019
//============================================================================

#include &quot;ibex_CovManifold.h&quot;

#include &lt;sstream&gt;
#include &lt;algorithm&gt;
<A NAME="1"></A>
using namespace std;

<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match754-1.html#1',3,'match754-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>namespace ibex {

const unsigned int CovManifold::FORMAT_VERSION = 1;

const unsigned int CovManifold::subformat_level = 4;

const unsigned int CovManifold::subformat_number = 0;</B></FONT>

CovManifold::CovManifold(size_t n, size_t m, size_t nb_ineq, BoundaryType boundary_type) :
		CovIBUList(n, INNER_AND_OUTER_PT), data(new Data()), own_data(true) {

	data-&gt;_manifold_nb_eq = m;
	data-&gt;_manifold_nb_ineq = nb_ineq;
	data-&gt;_manifold_boundary_type =  boundary_type;

	if (n&gt;0) { // if well initialized
		// create once for all varset structure for variables and parameters
		if (m==0)
			data-&gt;_manifold_solution_varset.push_back(VarSet(n,BitSet::all(n),false)); // all parameters
<A NAME="3"></A>		else if (m==n)
			data-&gt;_manifold_solution_varset.push_back(VarSet(n,BitSet::empty(n),false)); // no parameter
	}
<FONT color="#53858b"><A HREF="javascript:ZweiFrames('match754-1.html#3',3,'match754-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>}

CovManifold::CovManifold(const char* filename) : CovManifold(0,0,0 /* tmp */, EQU_ONLY /* by default */) {
	stack&lt;unsigned int&gt; format_id;
	stack&lt;unsigned int&gt; format_version;
	ifstream* f = CovManifold::read(filename, *this, format_id, format_version);
	f-&gt;close();
	delete f;</B></FONT>
}

CovManifold::CovManifold(const Cov&amp; cov, bool copy) : CovIBUList(cov, copy) {
	const CovManifold* covManifold = dynamic_cast&lt;const CovManifold*&gt;(&amp;cov);

	if (covManifold) {
		if (copy) {
			data = new Data(*covManifold-&gt;data); // implicit constructor is fine
//			data-&gt;_manifold_nb_eq= covManifold-&gt;data-&gt;_manifold_nb_eq;
//			data-&gt;_manifold_nb_ineq= covManifold-&gt;data-&gt;_manifold_nb_ineq;
//			data-&gt;_manifold_boundary_type= covManifold-&gt;data-&gt;_manifold_boundary_type;
//			data-&gt;_manifold_status= covManifold-&gt;data-&gt;_manifold_status;
//			data-&gt;_manifold_solution= covManifold-&gt;data-&gt;_manifold_solution;
//			data-&gt;_manifold_boundary= covManifold-&gt;data-&gt;_manifold_boundary;
//			data-&gt;_manifold_unknown= covManifold-&gt;data-&gt;_manifold_unknown;
//			data-&gt;_manifold_unicity= covManifold-&gt;data-&gt;_manifold_unicity;
			own_data = true;
		} else {
			data = covManifold-&gt;data;
			own_data = false;
		}
	} else {
		data = new Data();
		data-&gt;_manifold_nb_eq = 0;
		data-&gt;_manifold_nb_ineq = 0;
		data-&gt;_manifold_boundary_type = EQU_ONLY; /* by default */
		for (size_t i=0; i&lt;size(); i++) {
			switch(CovIBUList::status(i)) {
			case CovIBUList::INNER :
				data-&gt;_manifold_status.push_back(CovManifold::SOLUTION);
				data-&gt;_manifold_solution.push_back(i);
				if (data-&gt;_manifold_solution_varset.empty())
					data-&gt;_manifold_solution_varset.push_back(VarSet(n,BitSet::all(n),false)); // all parameters
				break;
			case CovIBUList::BOUNDARY :
			case CovIBUList::UNKNOWN :
				data-&gt;_manifold_status.push_back(CovManifold::UNKNOWN);
				data-&gt;_manifold_unknown.push_back(i);
				break;
			default :
				assert(false);
			}
<A NAME="0"></A>		}
		own_data = true;
	}
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match754-1.html#0',3,'match754-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>}

void CovManifold::save(const char* filename) const {
	stack&lt;unsigned int&gt; format_id;
	stack&lt;unsigned int&gt; format_version;
	ofstream* of=CovManifold::write(filename, *this, format_id, format_version);
	of-&gt;close();
	delete of;
}

CovManifold::~CovManifold() {</B></FONT>
	if (own_data) {
		delete data;
	}
}

void CovManifold::add(const IntervalVector&amp; x) {
	add_unknown(x);
}

void CovManifold::add_inner(const IntervalVector&amp; x) {
	if (nb_eq()&gt;0)
		ibex_error(&quot;[CovManifold] inner boxes not allowed with equalities&quot;);
	CovIBUList::add_inner(x);
	data-&gt;_manifold_solution.push_back(size()-1);
	data-&gt;_manifold_status.push_back(SOLUTION);
}

void CovManifold::add_boundary(const IntervalVector&amp; x) {
	if (nb_eq()&gt;0 &amp;&amp; nb_eq()&lt;n)
		ibex_error(&quot;[CovManifold]: a boundary box for an under-constrained system requires \&quot;VarSet\&quot; structure (parameters/variables)&quot;);

	add_boundary(x,data-&gt;_manifold_solution_varset[0]);
}

void CovManifold::add_boundary(const IntervalVector&amp; x, const VarSet&amp; varset) {
	switch (boundary_type()) {
	case EQU_ONLY  : CovIBUList::add_unknown(x); break;
	case FULL_RANK : CovIBUList::add_unknown(x); break;
	case HALF_BALL : CovIBUList::add_boundary(x); break;
	default        : assert(false);
	}

	data-&gt;_manifold_status.push_back(BOUNDARY);
	data-&gt;_manifold_boundary.push_back(size()-1);

	if (nb_eq()&gt;0 &amp;&amp; nb_eq()&lt;n) // useless otherwise
		data-&gt;_manifold_boundary_varset.push_back(varset);
}

void CovManifold::add_unknown(const IntervalVector&amp; x) {
	CovIBUList::add_unknown(x);
	data-&gt;_manifold_unknown.push_back(size()-1);
	data-&gt;_manifold_status.push_back(UNKNOWN);
}

void CovManifold::add_solution(const IntervalVector&amp; existence, const IntervalVector&amp; unicity) {
	if (nb_eq() &lt; n)
		ibex_error(&quot;[CovManifold]: a solution of under-constrained system requires \&quot;VarSet\&quot; structure (parameters/variables)&quot;);

	add_solution(existence, unicity, data-&gt;_manifold_solution_varset[0]);
}

void CovManifold::add_solution(const IntervalVector&amp; existence, const IntervalVector&amp; unicity, const VarSet&amp; varset) {
	if (nb_eq()==0)
		ibex_error(&quot;[CovManifold]: solution boxes not allowed without equalities&quot;);

	CovIBUList::add_boundary(existence);
	data-&gt;_manifold_solution.push_back(size()-1);
	data-&gt;_manifold_unicity.push_back(unicity);
	data-&gt;_manifold_status.push_back(SOLUTION);

	if (nb_eq()&lt;n) // useless otherwise
		data-&gt;_manifold_solution_varset.push_back(varset);
}

ostream&amp; operator&lt;&lt;(ostream&amp; os, const CovManifold&amp; manif) {

	for (size_t i=0; i&lt;manif.nb_solution(); i++) {
		os &lt;&lt; &quot; solution n°&quot; &lt;&lt; (i+1) &lt;&lt; &quot; = &quot; &lt;&lt; manif.solution(i) &lt;&lt; endl;
	}

	for (size_t i=0; i&lt;manif.nb_boundary(); i++) {
		os &lt;&lt; &quot; boundary n°&quot; &lt;&lt; (i+1) &lt;&lt; &quot; = &quot; &lt;&lt; manif.boundary(i) &lt;&lt; endl;
	}

	for (size_t i=0; i&lt;manif.nb_unknown(); i++) {
		os &lt;&lt; &quot; unknown n°&quot; &lt;&lt; (i+1) &lt;&lt; &quot; = &quot; &lt;&lt; manif.unknown(i) &lt;&lt; endl;
	}

	return os;
}

VarSet CovManifold::read_varset(ifstream&amp; f, size_t n, size_t m) {

	BitSet params(n);

	for (unsigned int j=0; j&lt;n-m; j++) {
		unsigned int v=read_pos_int(f);
		if (v&gt;n) {
			ibex_error(&quot;[CovManifold]: bad input file (bad parameter index)&quot;);
		}
		params.add(v); // index starting from 1 in the raw format
	}

	return VarSet(n,params,false);
}

void CovManifold::write_varset(ofstream&amp; f, const VarSet&amp; varset) {
	for (int i=0; i&lt;varset.nb_param; i++)
		write_pos_int(f, varset.param(i));
}

ifstream* CovManifold::read(const char* filename, CovManifold&amp; cov, std::stack&lt;unsigned int&gt;&amp; format_id, std::stack&lt;unsigned int&gt;&amp; format_version) {

	ifstream* f = CovIBUList::read(filename, cov, format_id, format_version);

	size_t nb_solution, nb_boundary;

	if (format_id.empty() || format_id.top()!=subformat_number || format_version.top()!=FORMAT_VERSION) {
		(size_t&amp;) cov.data-&gt;_manifold_nb_eq = 0;
		(size_t&amp;) cov.data-&gt;_manifold_nb_ineq = 0;
		nb_solution = 0;
		nb_boundary = 0;
	}
	else {
		format_id.pop();
		format_version.pop();
		(size_t&amp;) cov.data-&gt;_manifold_nb_eq = read_pos_int(*f);
		(size_t&amp;) cov.data-&gt;_manifold_nb_ineq = read_pos_int(*f);

		unsigned int _boundary_type = read_pos_int(*f);
		switch (_boundary_type) {
		case 0: (BoundaryType&amp;) cov.data-&gt;_manifold_boundary_type = EQU_ONLY; break;
		case 1: (BoundaryType&amp;) cov.data-&gt;_manifold_boundary_type = FULL_RANK; break;
		case 2: (BoundaryType&amp;) cov.data-&gt;_manifold_boundary_type = HALF_BALL; break;
		default: ibex_error(&quot;[CovManifold]: unknown boundary type identifier.&quot;);
		}

		if (cov.nb_eq()&gt;0) {
			nb_solution = read_pos_int(*f);
			if (nb_solution &gt; cov.CovIBUList::nb_boundary())
				ibex_error(&quot;[CovManifold]: number of solutions &gt; number of CovIBUList boundary boxes (m&gt;0)&quot;);

			// note: in principle, with some constraints like x=0 we could have
			// inner boxes. But this would create confusion. The solver only
			// produces inner boxes in the case m=0 anyway.
			if (cov.nb_inner()&gt;0)
				ibex_error(&quot;[CovManifold]: the file should not contain 'solutions' in addition to inner boxes (m=0)&quot;);

			for (size_t i=0; i&lt;nb_solution; i++) {
				uint32_t j=read_pos_int(*f);
				if (!cov.data-&gt;_manifold_solution.empty()) { // check ordering
					if (j&lt;cov.data-&gt;_manifold_solution.back())
						ibex_error(&quot;[CovManifold]: indices of solutions are not in increasing order.&quot;);
					if (j==cov.data-&gt;_manifold_solution.back())
						ibex_error(&quot;[CovManifold]: duplicated index of solution.&quot;);
				}
				cov.data-&gt;_manifold_solution.push_back(j);

				if (cov.nb_eq() &lt; cov.n)
					cov.data-&gt;_manifold_solution_varset.push_back(read_varset(*f, cov.n, cov.nb_eq()));

				cov.data-&gt;_manifold_unicity.push_back(read_box(*f, cov.n));
			}
		}

		nb_boundary = read_pos_int(*f);

		// (check redundant with below)
		if (cov.boundary_type() != HALF_BALL &amp;&amp; nb_boundary &gt; cov.CovIBUList::nb_unknown())
			ibex_error(&quot;[CovManifold]: number of (uncertified) boundary boxes &gt; number of CovIBUList unknown boxes&quot;);

		// (check redundant with below)
		if (cov.boundary_type() == HALF_BALL &amp;&amp; nb_boundary &gt; cov.CovIBUList::nb_boundary())
			ibex_error(&quot;[CovManifold]: number of boundary boxes &gt; number of CovIBUList boundary boxes&quot;);

		for (size_t i=0; i&lt;nb_boundary; i++) {
			uint32_t j=read_pos_int(*f);
			if (!cov.data-&gt;_manifold_boundary.empty()) { // check ordering
				if (j&lt;cov.data-&gt;_manifold_boundary.back())
					ibex_error(&quot;[CovManifold]: indices of boundary boxes are not in increasing order.&quot;);
				if (j==cov.data-&gt;_manifold_boundary.back())
					ibex_error(&quot;[CovManifold]: duplicated index of boundary box.&quot;);
			}
			cov.data-&gt;_manifold_boundary.push_back(j);

			if (cov.nb_eq()&gt;0 &amp;&amp; cov.nb_eq() &lt; cov.n)
				cov.data-&gt;_manifold_boundary_varset.push_back(read_varset(*f, cov.n, cov.nb_eq()));
		}
	}

	if (cov.nb_eq()==0) {
		// comes from either a CovManifold with no equality or a CovManifold
		// loaded from a CovIBUList file (or lesser).
		nb_solution = cov.CovIUList::nb_inner();
		for (size_t i=0; i&lt;cov.CovIUList::nb_inner(); i++) {
			cov.data-&gt;_manifold_solution.push_back(cov.CovIUList::data-&gt;_IU_inner[i]);
		}
	}

	// iterator of solution boxes
	vector&lt;size_t&gt;::const_iterator it_sol=cov.data-&gt;_manifold_solution.begin();
	// iterator of boundary boxes
	vector&lt;size_t&gt;::const_iterator it_bnd=cov.data-&gt;_manifold_boundary.begin();

	for (size_t i=0; i&lt;cov.size(); i++) {
		if (it_sol!=cov.data-&gt;_manifold_solution.end() &amp;&amp; i==*it_sol) {
			if (cov.nb_eq()&gt;0 &amp;&amp; !cov.CovIBUList::is_boundary(i))
				ibex_error(&quot;[CovManifold]: a solution box must be a CovIBUList boundary box (if m&gt;0).&quot;);
			cov.data-&gt;_manifold_status.push_back(CovManifold::SOLUTION);
			++it_sol;
		} else if (it_bnd!=cov.data-&gt;_manifold_boundary.end() &amp;&amp; i==*it_bnd) {
			if (cov.boundary_type() != HALF_BALL &amp;&amp; !cov.CovIBUList::is_unknown(i))
				ibex_error(&quot;[CovManifold]: a (uncertified) boundary box must be a CovIBUList unknown box.&quot;);
			if (cov.boundary_type() == HALF_BALL &amp;&amp; !cov.CovIBUList::is_boundary(i))
				ibex_error(&quot;[CovManifold]: a boundary box must be a CovIBUList boundary box.&quot;);
			cov.data-&gt;_manifold_status.push_back(CovManifold::BOUNDARY);
			++it_bnd;
		} else {
			switch(cov.CovIBUList::status(i)) {
			case CovIBUList::BOUNDARY :
				// This case typically happens in the case of FULL_RANK
				// when a IBU boundary box meets a singularity of the inequality.
				cov.data-&gt;_manifold_unknown.push_back(i);
				cov.data-&gt;_manifold_status.push_back(CovManifold::UNKNOWN);
				break;
			case CovIBUList::UNKNOWN :
				cov.data-&gt;_manifold_unknown.push_back(i);
				cov.data-&gt;_manifold_status.push_back(CovManifold::UNKNOWN);
				break;
			default :
				assert(false);
			}
		}
	}

	if (it_sol!=cov.data-&gt;_manifold_solution.end()) ibex_error(&quot;[CovManifold]: invalid solution box index.&quot;);

	if (it_bnd!=cov.data-&gt;_manifold_boundary.end()) ibex_error(&quot;[CovManifold]: invalid boundary box index.&quot;);

	// create once for all varset structure for variables and parameters
	if (cov.n&gt;0 &amp;&amp; cov.nb_eq()==0)
		cov.data-&gt;_manifold_solution_varset.push_back(VarSet(cov.n,BitSet::all(cov.n),false)); // all parameters
<A NAME="2"></A>	else if (cov.n&gt;0 &amp;&amp; cov.nb_eq()==cov.n)
		cov.data-&gt;_manifold_solution_varset.push_back(VarSet(cov.n,BitSet::empty(cov.n),false)); // no parameter

<FONT color="#980517"><A HREF="javascript:ZweiFrames('match754-1.html#2',3,'match754-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	return f;
}

ofstream* CovManifold::write(const char* filename, const CovManifold&amp; cov, std::stack&lt;unsigned int&gt;&amp; format_id, std::stack&lt;unsigned int&gt;&amp; format_version) {

	format_id.push(subformat_number);
	format_version.push(FORMAT_VERSION);

	ofstream* f = CovIBUList::write(filename, cov, format_id, format_version);</B></FONT>

	write_pos_int(*f, cov.nb_eq());
	write_pos_int(*f, cov.nb_ineq());

	switch(cov.boundary_type()) {
	case INNER_PT  : write_pos_int(*f, 0); break;
	case FULL_RANK : write_pos_int(*f, 1); break;
	case HALF_BALL : write_pos_int(*f, 2); break;
	default        : assert(false);
	}

	if (cov.nb_eq()&gt;0) {
		write_pos_int(*f, cov.nb_solution());
		std::vector&lt;VarSet&gt;::const_iterator it_varset=cov.data-&gt;_manifold_solution_varset.begin();
		std::vector&lt;IntervalVector&gt;::const_iterator it_unicity=cov.data-&gt;_manifold_unicity.begin();

		for (vector&lt;size_t&gt;::const_iterator it=cov.data-&gt;_manifold_solution.begin(); it!=cov.data-&gt;_manifold_solution.end(); ++it) {
			assert(*it&lt;numeric_limits&lt;uint32_t&gt;::max());
			write_pos_int(*f, (uint32_t) *it);
			if (cov.nb_eq() &lt; cov.n) {
				write_varset(*f, *it_varset);
				++it_varset;
			}
			write_box(*f, *it_unicity);
			++it_unicity;
		}
	}

	write_pos_int(*f, cov.nb_boundary());
	std::vector&lt;VarSet&gt;::const_iterator it_varset=cov.data-&gt;_manifold_boundary_varset.begin();

	for (vector&lt;size_t&gt;::const_iterator it=cov.data-&gt;_manifold_boundary.begin(); it!=cov.data-&gt;_manifold_boundary.end(); ++it) {
		assert(*it&lt;numeric_limits&lt;uint32_t&gt;::max());
		write_pos_int(*f, (uint32_t) *it);

		if (cov.nb_eq()&gt;0 &amp;&amp; cov.nb_eq() &lt; cov.n) {
			write_varset(*f, *it_varset);
			++it_varset;
		}
	}

	return f;
}

void CovManifold::format(stringstream&amp; ss, const string&amp; title, std::stack&lt;unsigned int&gt;&amp; format_id, std::stack&lt;unsigned int&gt;&amp; format_version) {
	format_id.push(subformat_number);
	format_version.push(FORMAT_VERSION);

	CovIBUList::format(ss, title, format_id, format_version);

	ss
	&lt;&lt; space &lt;&lt; &quot; - 1 integer:     the number m of equalities\n&quot;
	&lt;&lt; space &lt;&lt; &quot; - 1 integer:     the number of inequalities\n&quot;
	&lt;&lt; space &lt;&lt; &quot; - 1 integer:     the type of boundary boxes:\n&quot;
	&lt;&lt; space &lt;&lt; &quot;                  - 0=only equalities are certified.\n&quot;
	&lt;&lt; space &lt;&lt; &quot;                  - 1=equalities are certified and the \n&quot;
	&lt;&lt; space &lt;&lt; &quot;                    gradients of all active constraints\n&quot;
	&lt;&lt; space &lt;&lt; &quot;                    are linearly independent.\n&quot;
	&lt;&lt; space &lt;&lt; &quot;                  - 2=the intersection of the manifold and\n&quot;
	&lt;&lt; space &lt;&lt; &quot;                    the box is homeomorphic to a hall-ball\n&quot;
	&lt;&lt; space &lt;&lt; &quot;                    of R^n.\n&quot;
	&lt;&lt; space &lt;&lt; &quot; +----[if m&gt;0]----\n&quot;
	&lt;&lt; space &lt;&lt; &quot; | - 1 integer:   the number Ns of solution boxes (&lt;= Nb)\n&quot;
	&lt;&lt; space &lt;&lt; &quot; | - Ns solutions:each solution is the following sequence:\n&quot;
	&lt;&lt; &quot;|    CovManifold    |&quot; &lt;&lt;
	            &quot; |                - 1 integer: the index of the solution\n&quot;
	&lt;&lt; space &lt;&lt; &quot; |                  (belongs to CovIBUList boundar boxes);\n&quot;
	&lt;&lt; space &lt;&lt; &quot; |                - [if m&lt;n] n-m integers: the indices of\n&quot;
	&lt;&lt; space &lt;&lt; &quot; |                  parameters in the parametric proofs\n&quot;
	&lt;&lt; space &lt;&lt; &quot; |                - 2*n real values: the unicity box in the\n&quot;
	&lt;&lt; space &lt;&lt; &quot; |                  proof (lb(x1), ub(x1),..., ub(xn))\n&quot;
	&lt;&lt; space &lt;&lt; &quot; +----------------\n&quot;
	&lt;&lt; space &lt;&lt; &quot; - 1 integer:     the number Nbb of boundary boxes\n&quot;
	&lt;&lt; space &lt;&lt; &quot; - Nbb times      the following sequence:\n&quot;
	&lt;&lt; space &lt;&lt; &quot;                  - 1 integer: the index of the boundary \n&quot;
	&lt;&lt; space &lt;&lt; &quot;                    box (belongs to CovIBUList boundary or \n&quot;
	&lt;&lt; space &lt;&lt; &quot;                    unknown boxes)\n&quot;
	&lt;&lt; space &lt;&lt; &quot;                  - [if m&gt;0 and m&lt;n]: \n&quot;
	&lt;&lt; space &lt;&lt; &quot;                    n-m integers: the indices of parameters\n&quot;
	&lt;&lt; space &lt;&lt; &quot;                    in the parametric proofs\n&quot;
	&lt;&lt; separator;
}

string CovManifold::format() {
	stringstream ss;
	stack&lt;unsigned int&gt; format_id;
	stack&lt;unsigned int&gt; format_version;
	format(ss, &quot;CovManifold&quot;, format_id, format_version);
	return ss.str();
}


} // end namespace

</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>ibex_Cov.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
//============================================================================
//                                  I B E X
// File        : ibex_Cov.cpp
// Author      : Gilles Chabert
// Copyright   : IMT Atlantique (France)
// License     : See the LICENSE file
// Created     : Nov 07, 2018
// Last update : Dec 24, 2018
//============================================================================

#include &quot;ibex_Cov.h&quot;

#include &lt;sstream&gt;
#include &lt;cassert&gt;
#include &lt;string.h&gt;
<A NAME="1"></A>
using namespace std;

<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match754-0.html#1',2,'match754-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>namespace ibex {

const unsigned int  Cov::FORMAT_VERSION = 1;

const unsigned int Cov::subformat_level = 0;

const unsigned int Cov::subformat_number = 0;</B></FONT>

const size_t Cov::SIGNATURE_LENGTH = 20;
const char* Cov::SIGNATURE = &quot;IBEX COVERING FILE &quot;;
const string Cov::separator = &quot;+-------------------+-----------------------------------------------------------\n&quot;;
const string Cov::space     = &quot;|                   |&quot;;
<A NAME="3"></A>
Cov::Cov(size_t n) : n(n) {

<FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match754-0.html#3',2,'match754-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

Cov::Cov(const char* filename) : n(0 /* tmp */) {
	stack&lt;unsigned int&gt; format_id;
	stack&lt;unsigned int&gt; format_version;
<A NAME="0"></A>	ifstream* f = Cov::read(filename, *this, format_id, format_version);
	f-&gt;close();
	delete f;</B></FONT>
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match754-0.html#0',2,'match754-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

void Cov::save(const char* filename) const {
	stack&lt;unsigned int&gt; format_id;
	stack&lt;unsigned int&gt; format_version;
	ofstream* of=Cov::write(filename, *this, format_id, format_version);
	of-&gt;close();
	delete of;
}

Cov::~Cov() {</B></FONT>

}

ifstream* Cov::read(const char* filename, Cov&amp; cov, stack&lt;unsigned int&gt;&amp; format_id, std::stack&lt;unsigned int&gt;&amp; format_version) {

	ifstream* f = new ifstream();

	f-&gt;open(filename, ios::in | ios::binary);

	if (f-&gt;fail()) ibex_error(&quot;[Cov]: cannot open input file.\n&quot;);

	read_signature(*f);

	read_format_seq(*f, format_id, format_version);

	if (format_version.top()&gt;FORMAT_VERSION) {
		ibex_error(&quot;[Cov] unsupported format version&quot;);
	}

	if (format_id.top()!=subformat_number || format_version.top()!=FORMAT_VERSION)
		return f;
	else {
		format_id.pop();
		format_version.pop();
	}

	size_t _n = read_pos_int(*f);
<A NAME="2"></A>
	(size_t&amp;) cov.n = _n;

<FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match754-0.html#2',2,'match754-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	return f;
}

ofstream* Cov::write(const char* filename, const Cov&amp; cov, std::stack&lt;unsigned int&gt;&amp; format_id, std::stack&lt;unsigned int&gt;&amp; format_version) {

	ofstream* f = new ofstream();</B></FONT>

	f-&gt;open(filename, ios::out | ios::binary);

	if (f-&gt;fail())
		ibex_error(&quot;[Cov]: cannot create output file.\n&quot;);

	write_signature(*f);

	format_id.push(subformat_number);
	format_version.push(FORMAT_VERSION);

	write_format_seq(*f, format_id, format_version);

	write_pos_int(*f, cov.n);

	return f;
}

void Cov::read_signature(ifstream&amp; f) {
	char* sig=new char[SIGNATURE_LENGTH];
	f.read(sig, SIGNATURE_LENGTH*sizeof(char));
	if (f.eof()) ibex_error(&quot;[manifold]: unexpected end of file.&quot;);
	if (strcmp(sig,SIGNATURE)!=0)
	ibex_error(&quot;[Cov]: not an Ibex \&quot;cover\&quot; file.&quot;);
	delete[] sig;
}

void Cov::read_format_seq(std::ifstream&amp; f, stack&lt;unsigned int&gt;&amp; format_id, std::stack&lt;unsigned int&gt;&amp; format_version) {
	size_t format_level = read_pos_int(f);

	assert(format_id.empty());
	assert(format_version.empty());

	list&lt;unsigned int&gt; tmp;
	for (size_t i=0; i&lt;=format_level; i++)
		tmp.push_front(read_pos_int(f));

	for (list&lt;unsigned int&gt;::const_iterator it=tmp.begin(); it!=tmp.end(); ++it)
		format_id.push(*it);

	tmp.clear();
	for (size_t i=0; i&lt;=format_level; i++)
		tmp.push_front(read_pos_int(f));

	for (list&lt;unsigned int&gt;::const_iterator it=tmp.begin(); it!=tmp.end(); ++it)
		format_version.push(*it);
}

unsigned int Cov::read_pos_int(ifstream&amp; f) {
	uint32_t x;
	f.read((char*) &amp;x, sizeof(x)); //f &gt;&gt; x;
	if (f.eof()) ibex_error(&quot;[Cov]: unexpected end of file.&quot;);
	return x;
}

double Cov::read_double(ifstream&amp; f) {
	double x;
	f.read((char*) &amp;x, sizeof(x)); //f &gt;&gt; x;
	if (f.eof()) ibex_error(&quot;[Cov]: unexpected end of file.&quot;);
	return x;
}

void Cov::write_signature(ofstream&amp; f) {
	f.write(SIGNATURE, SIGNATURE_LENGTH*sizeof(char));
}

void Cov::write_format_seq(std::ofstream&amp; f, std::stack&lt;unsigned int&gt;&amp; format_id, std::stack&lt;unsigned int&gt;&amp; format_version) {
	write_pos_int(f, format_id.size()-1); // level = size-1 (starts from 0)

	assert(format_version.size()==format_id.size());

	while (!format_id.empty()) {
		write_pos_int(f, format_id.top());
		format_id.pop();
	}

	while (!format_version.empty()) {
		write_pos_int(f, format_version.top());
		format_version.pop();
	}
}

void Cov::write_pos_int(ofstream&amp; f, uint32_t x) {
	f.write((char*) &amp;x, sizeof(uint32_t));
}

void Cov::write_double(ofstream&amp; f, double x) {
	f.write((char*) &amp;x, sizeof(x));
}

void Cov::format(stringstream&amp; ss, const string&amp; title, stack&lt;unsigned int&gt;&amp; format_id, std::stack&lt;unsigned int&gt;&amp; format_version) {

	format_id.push(subformat_number);
	format_version.push(FORMAT_VERSION);

	ss
	&lt;&lt; &quot;\n&quot;
	&lt;&lt; &quot;+-------------------------------------------------------------------------------\n&quot;
	&lt;&lt; &quot;|                          &quot; &lt;&lt; title &lt;&lt; &quot; file format\n&quot;
	&quot;|\n&quot;
	//			&quot;The &quot; &lt;&lt; title &lt;&lt; &quot; text format (obtained with --txt) is described below.\n&quot;
	//			&quot;The &quot; &lt;&lt; title &lt;&lt; &quot; binary format (.cov) is exactly the same except that:\n&quot;
	//			&quot;  - all separating characters (space, line return) are removed except\n&quot;
	//			&quot;    those inside the signature (line 1 in text format)\n&quot;
	&quot;| Note:\n&quot;
	&quot;| - integer values are unsigned 32 bits integer (uint32_t)\n&quot;
	&quot;| - real values are 64 bits double\n&quot;
	&quot;| - all indices start from 0.\n&quot;
	&lt;&lt; separator
	&lt;&lt; space &lt;&lt; &quot; - the signature: the null-terminated sequence of &quot; &lt;&lt; SIGNATURE_LENGTH &lt;&lt;  &quot;\n&quot;
	&lt;&lt; space &lt;&lt;	&quot;                  characters \&quot;&quot; &lt;&lt; SIGNATURE &lt;&lt; &quot;\&quot;\n&quot;
	&lt;&lt; &quot;|        Cov        |&quot; &lt;&lt;
	&quot;                  (mind the space at the end)\n&quot;
	&lt;&lt; space &lt;&lt; &quot; - 1 integer:     the format level L (=&quot; &lt;&lt; format_id.size()-1 &lt;&lt; &quot; in the case of\n&quot;
	&lt;&lt; space &lt;&lt; &quot;                  &quot; &lt;&lt; title &lt;&lt; &quot;)\n&quot;
	&lt;&lt; space &lt;&lt; &quot; - L+1 integers:  the format identifying sequence:\n&quot;
	&lt;&lt; space &lt;&lt; &quot;                      &quot;;
	while (!format_id.empty()) {
		ss &lt;&lt; format_id.top();
		format_id.pop();
		if (!format_id.empty()) ss &lt;&lt; ' ';
	}
	ss
	&lt;&lt; &quot;\n&quot;
	&lt;&lt; space &lt;&lt; &quot;                  (in the case of &quot; &lt;&lt; title &lt;&lt; &quot;)\n&quot;
	&lt;&lt; space &lt;&lt; &quot; - L+1 integers:  the format version sequence:\n&quot;
	&lt;&lt; space &lt;&lt; &quot;                      &quot;;
	while (!format_version.empty()) {
		ss &lt;&lt; format_version.top();
		format_version.pop();
		if (!format_version.empty()) ss &lt;&lt; ' ';
	}
	ss
	&lt;&lt; &quot;\n&quot;
	&lt;&lt; space &lt;&lt; &quot;                  (in the case of &quot; &lt;&lt; title &lt;&lt; &quot;)\n&quot;
	&lt;&lt; space &lt;&lt; &quot; - 1 integer:     the dimension n of boxes (# of variables)\n&quot;
	&lt;&lt; separator;
}

string Cov::format() {
	stringstream ss;
	stack&lt;unsigned int&gt; format_id;
	stack&lt;unsigned int&gt; format_version;
	format(ss, &quot;COV&quot;, format_id, format_version);
	return ss.str();
}

} /* namespace ibex */
</PRE>
</div>
  </div>
</body>
</html>
