
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 7.860262008733625%, Tokens: 9</h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-ligature_table.cpp</h3>
            <pre><code>1  #include "ligature_table.h"
2  #include <tesseract/unichar.h>
3  #include "pango_font_info.h"
4  #include "tlog.h"
5  #include "unicharset.h"
6  #include "unicode/errorcode.h" 
7  #include "unicode/normlzr.h"   
8  #include "unicode/unistr.h"    
9  #include "unicode/utypes.h"    
10  #include <utility>
11  namespace tesseract {
12  static std::string EncodeAsUTF8(const char32 ch32) {
13    UNICHAR uni_ch(ch32);
14    return std::string(uni_ch.utf8(), uni_ch.utf8_len());
15  }
16  const int kMinLigature = 0xfb00;
17  const int kMaxLigature = 0xfb17; 
18  std::unique_ptr<LigatureTable> LigatureTable::instance_;
19  LigatureTable *LigatureTable::Get() {
20    if (instance_ == nullptr) {
21      instance_.reset(new LigatureTable());
22      instance_->Init();
23    }
24    return instance_.get();
25  }
26  LigatureTable::LigatureTable()
27      : min_lig_length_(0), max_lig_length_(0), min_norm_length_(0), max_norm_length_(0) {}
28  void LigatureTable::Init() {
29    if (norm_to_lig_table_.empty()) {
30      for (char32 lig = kMinLigature; lig <= kMaxLigature; ++lig) {
31        std::string lig8 = EncodeAsUTF8(lig);
32        icu::UnicodeString unicode_lig8(static_cast<UChar32>(lig));
33        icu::UnicodeString normed8_result;
34        icu::ErrorCode status;
35        icu::Normalizer::normalize(unicode_lig8, UNORM_NFC, 0, normed8_result, status);
36        std::string normed8;
37        normed8_result.toUTF8String(normed8);
38        int lig_length = lig8.length();
<span onclick='openModal()' class='match'>39        int norm_length = normed8.size();
40        if (normed8 != lig8 && lig_length > 1 && norm_length > 1) {
41          norm_to_lig_table_[normed8] = lig8;
42          lig_to_norm_table_[lig8] = normed8;
43          if (min_lig_length_ == 0 || lig_length < min_lig_length_) {
44            min_lig_length_ = lig_length;
45          }
</span>46          if (lig_length > max_lig_length_) {
47            max_lig_length_ = lig_length;
48          }
49          if (min_norm_length_ == 0 || norm_length < min_norm_length_) {
50            min_norm_length_ = norm_length;
51          }
52          if (norm_length > max_norm_length_) {
53            max_norm_length_ = norm_length;
54          }
55        }
56      }
57      for (int i = 0; UNICHARSET::kCustomLigatures[i][0] != nullptr; ++i) {
58        norm_to_lig_table_[UNICHARSET::kCustomLigatures[i][0]] = UNICHARSET::kCustomLigatures[i][1];
59        int norm_length = strlen(UNICHARSET::kCustomLigatures[i][0]);
60        if (min_norm_length_ == 0 || norm_length < min_norm_length_) {
61          min_norm_length_ = norm_length;
62        }
63        if (norm_length > max_norm_length_) {
64          max_norm_length_ = norm_length;
65        }
66        lig_to_norm_table_[UNICHARSET::kCustomLigatures[i][1]] = UNICHARSET::kCustomLigatures[i][0];
67      }
68    }
69  }
70  std::string LigatureTable::RemoveLigatures(const std::string &str) const {
71    std::string result;
72    UNICHAR::const_iterator it_begin = UNICHAR::begin(str.c_str(), str.length());
73    UNICHAR::const_iterator it_end = UNICHAR::end(str.c_str(), str.length());
74    char tmp[5];
75    int len;
76    for (UNICHAR::const_iterator it = it_begin; it != it_end; ++it) {
77      len = it.get_utf8(tmp);
78      tmp[len] = '\0';
79      auto lig_it = lig_to_norm_table_.find(tmp);
80      if (lig_it != lig_to_norm_table_.end()) {
81        result += lig_it->second;
82      } else {
83        result += tmp;
84      }
85    }
86    return result;
87  }
88  std::string LigatureTable::RemoveCustomLigatures(const std::string &str) const {
89    std::string result;
90    UNICHAR::const_iterator it_begin = UNICHAR::begin(str.c_str(), str.length());
91    UNICHAR::const_iterator it_end = UNICHAR::end(str.c_str(), str.length());
92    char tmp[5];
93    int len;
94    int norm_ind;
95    for (UNICHAR::const_iterator it = it_begin; it != it_end; ++it) {
96      len = it.get_utf8(tmp);
97      tmp[len] = '\0';
98      norm_ind = -1;
99      for (int i = 0; UNICHARSET::kCustomLigatures[i][0] != nullptr && norm_ind < 0; ++i) {
100        if (!strcmp(tmp, UNICHARSET::kCustomLigatures[i][1])) {
101          norm_ind = i;
102        }
103      }
104      if (norm_ind >= 0) {
105        result += UNICHARSET::kCustomLigatures[norm_ind][0];
106      } else {
107        result += tmp;
108      }
109    }
110    return result;
111  }
112  std::string LigatureTable::AddLigatures(const std::string &str, const PangoFontInfo *font) const {
113    std::string result;
114    int len = str.size();
115    int step = 0;
116    int i = 0;
117    for (i = 0; i < len - min_norm_length_ + 1; i += step) {
118      step = 0;
119      for (int liglen = max_norm_length_; liglen >= min_norm_length_; --liglen) {
120        if (i + liglen <= len) {
121          std::string lig_cand = str.substr(i, liglen);
122          auto it = norm_to_lig_table_.find(lig_cand);
123          if (it != norm_to_lig_table_.end()) {
124            tlog(3, "Considering %s -> %s\n", lig_cand.c_str(), it->second.c_str());
125            if (font) {
126              if (!font->CanRenderString(it->second.data(), it->second.length())) {
127                continue; 
128              }
129            }
130            step = liglen;
131            result += it->second;
132            tlog(2, "Substituted %s -> %s\n", lig_cand.c_str(), it->second.c_str());
133            break;
134          }
135        }
136      }
137      if (step == 0) {
138        result += str[i];
139        step = 1;
140      }
141    }
142    result += str.substr(i, len - i);
143    return result;
144  }
145  } 
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-fa.cpp</h3>
            <pre><code>1  #include "fa.h"
2  PFaTrans TFaTrans::LoadCustomXml(const PXmlTok& XmlTok){
3    IAssert(XmlTok->IsTag("Trans"));
4    TStr MsgNm=XmlTok->GetArgVal("Msg");
5    TStr DstStateNm=XmlTok->GetArgVal("DstState");
6    TStr ScriptStr;
7    if (XmlTok->IsSubTag("Script")){
8      ScriptStr=XmlTok->GetTagTok("Script")->GetTokStr(false);}
9    PFaTrans Trans=TFaTrans::New(MsgNm, DstStateNm, ScriptStr);
10    return Trans;
11  }
12  void TFaTrans::_ChangeStateNm(const TStr& OldStateNm, const TStr& NewStateNm){
13    if (SrcStateNm==OldStateNm){SrcStateNm=NewStateNm;}
14    if (DstStateNm==OldStateNm){DstStateNm=NewStateNm;}
15  }
16  PFaState TFaState::LoadCustomXml(const PXmlTok& XmlTok){
17    IAssert(XmlTok->IsTag("State"));
18    TStr Nm=XmlTok->GetArgVal("Nm");
19    TStr ScriptStr;
20    if (XmlTok->IsSubTag("Script")){
21      ScriptStr=XmlTok->GetTagTok("Script")->GetTokStr(false);}
22    TXmlTokV TransTokV; XmlTok->GetTagTokV("Trans", TransTokV);
23    TFaTransV TransV;
24    for (int TransN=0; TransN<TransTokV.Len(); TransN++){
25      PFaTrans Trans=TFaTrans::LoadCustomXml(TransTokV[TransN]);
26      TransV.Add(Trans);
27    }
28    PFaState State=TFaState::New(Nm, ScriptStr);
29    for (int TransN=0; TransN<TransV.Len(); TransN++){
30      State->AddTrans(TransV[TransN]);}
31    return State;
32  }
33  void TFaState::_ChangeStateNm(const TStr& OldStateNm, const TStr& NewStateNm){
34    if (Nm==OldStateNm){Nm=NewStateNm;}
35    for (int TransN=0; TransN<FaTransV.Len(); TransN++){
36      FaTransV[TransN]->_ChangeStateNm(OldStateNm, NewStateNm);}
37  }
38  bool TFaState::IsTransTo(const TStr& StateNm) const {
39    for (int TransN=0; TransN<FaTransV.Len(); TransN++){
40      if (FaTransV[TransN]->GetDstStateNm()==StateNm){return true;}
41    }
42    return false;
43  }
44  void TFaState::DelTrans(const PFaTrans& Trans){
45    for (int TransN=FaTransV.Len()-1; TransN>=0; TransN--){
46      if (FaTransV[TransN]()==Trans()){
47        FaTransV.Del(TransN);}
48    }
49  }
50  void TFaState::DelTransIfDstState(const TStr& DstStateNm){
51    for (int TransN=FaTransV.Len()-1; TransN>=0; TransN--){
52      if (FaTransV[TransN]->GetDstStateNm()==DstStateNm){
53        FaTransV.Del(TransN);}
54    }
55  }
56  TStr TFaDef::GetNewStateNm() const {
57    int StateN=0;
58    while (IsState(TInt::GetStr(StateN, "State%d"))){StateN++;}
59    return TInt::GetStr(StateN, "State%d");
60  }
61  void TFaDef::ChangeStateNm(const TStr& OldStateNm, const TStr& NewStateNm){
62    if (OldStateNm==NewStateNm){return;}
63    PFaState State=GetState(OldStateNm);
64    IAssert(!IsState(NewStateNm));
65    IAssert(State()!=GetStartState()());
66    IAssert(State()!=GetEndState()());
67    TFaStateV StateV; GetStateV(StateV);
68    for (int StateN=0; StateN<StateV.Len(); StateN++){
69      StateV[StateN]->_ChangeStateNm(OldStateNm, NewStateNm);}
70    for (int TransN=0; TransN<GlobalTransV.Len(); TransN++){
71      GlobalTransV[TransN]->_ChangeStateNm(OldStateNm, NewStateNm);}
72    NmToFaStateH.DelKey(OldStateNm);
73    NmToFaStateH.AddDat(State->GetNm(), State);
74  }
75  void TFaDef::DelState(const TStr& StateNm){
76    IAssert(StateNm!=GetStartState()->GetNm());
77    IAssert(StateNm!=GetEndState()->GetNm());
78    PFaState State=GetState(StateNm);
79    TFaStateV StateV; GetStateV(StateV);
80    for (int StateN=0; StateN<StateV.Len(); StateN++){
81      StateV[StateN]->DelTransIfDstState(StateNm);}
82    for (int TransN=GlobalTransV.Len()-1; TransN>=0; TransN--){
83      PFaTrans Trans=GlobalTransV[TransN];
84      if ((Trans->GetSrcStateNm()==StateNm)||(Trans->GetDstStateNm()==StateNm)){
85        GlobalTransV.Del(TransN);}
86    }
87    NmToFaStateH.DelKey(StateNm);
88  }
89  TStr TFaDef::GetStateNmAtXY(const double& X, const double& Y) const {
90    TFaStateV StateV; GetStateV(StateV);
91    for (int StateN=StateV.Len()-1; StateN>=0; StateN--){
92      if (StateV[StateN]->GetRect().IsXYIn(X, Y)){
93        return StateV[StateN]->GetNm();}
94    }
95    return "";
96  }
97  void TFaDef::DelTrans(const PFaTrans& Trans){
98    TFaStateV StateV; GetStateV(StateV);
99    for (int StateN=0; StateN<StateV.Len(); StateN++){
100      StateV[StateN]->DelTrans(Trans);}
101    for (int TransN=GlobalTransV.Len()-1; TransN>=0; TransN--){
102      if (GlobalTransV[TransN]()==Trans()){
103        GlobalTransV.Del(TransN);}
104    }
105  }
106  PFaTrans TFaDef::GetTransAtXY(const double& X, const double& Y) const {
107    TFaStateV StateV; GetStateV(StateV);
108    for (int StateN=0; StateN<StateV.Len(); StateN++){
109      PFaState SrcFaState=StateV[StateN];
110      for (int TransN=0; TransN<SrcFaState->GetTranss(); TransN++){
111        PFaTrans FaTrans=SrcFaState->GetTrans(TransN);
112        if (FaTrans->GetRect().IsXYIn(X, Y)){return FaTrans;}
113      }
114    }
115    return NULL;
116  }
117  const TStr TFaDef::FaDefVerStr="Automaton Definition / 09.03.2004";
118  const TStr TFaDef::DfFNm="Automaton.Xml";
119  const TStr TFaDef::FExt=".Xml";
120  PFaDef TFaDef::LoadBin(const TStr& FNm){
121    PSIn SIn=TFIn::New(FNm);
122    char* VerCStr;
123    SIn->Load(VerCStr, FaDefVerStr.Len(), FaDefVerStr.Len());
124    if (FaDefVerStr!=VerCStr){
125      TExcept::Throw("Invalid version of Faulation Definition file.");}
126    return TFaDef::Load(*SIn);
127  }
128  void TFaDef::SaveBin(const TStr& FNm) const {
129    PSOut SOut=TFOut::New(FNm);
130    SOut->Save(FaDefVerStr.CStr(), FaDefVerStr.Len());
131    Save(*SOut);
132  }
133  PFaDef TFaDef::LoadXml(const TStr& FNm){
134    PFaDef FaDef=TFaDef::New();
135    XLoadFromFile(FNm, "FaDef", *FaDef);
136    return FaDef;
137  }
138  void TFaDef::SaveXml(const TStr& FNm){
139    PSOut SOut=TFOut::New(FNm);
140    SaveXml(*SOut, "FaDef");
141  }
142  PFaDef TFaDef::LoadCustomXml(const TStr& FNm){
143    PFaDef FaDef=TFaDef::New();
144    PXmlDoc XmlDoc=TXmlDoc::LoadTxt(FNm);
145    TXmlTokV GlobalTransTokV;
146    XmlDoc->GetTagTokV("FinAut|Trans", GlobalTransTokV);
147    for (int TransN=0; TransN<GlobalTransTokV.Len(); TransN++){
148      PFaTrans Trans=TFaTrans::LoadCustomXml(GlobalTransTokV[TransN]);
149      FaDef->AddGlobalTrans(Trans);
150    }
151    TXmlTokV StateTokV; XmlDoc->GetTagTokV("FinAut|State", StateTokV);
152    for (int StateN=0; StateN<StateTokV.Len(); StateN++){
153      PFaState State=TFaState::LoadCustomXml(StateTokV[StateN]);
154      FaDef->AddState(State);
155    }
156    TStr StartStateNm=XmlDoc->GetTagVal("StartState", false);
157    FaDef->PutStartState(FaDef->GetState(StartStateNm));
158    TStr EndStateNm=XmlDoc->GetTagVal("EndState", false);
159    FaDef->PutEndState(FaDef->GetState(EndStateNm));
160    return FaDef;
161  }
162  void TFaExpEnv::PutVarVal(const TStr& VarNm, const PExpVal& ExpVal){
163    VarNmToValH.AddDat(VarNm.GetUc(), ExpVal);
164  }
165  PExpVal TFaExpEnv::GetVarVal(const TStr& VarNm, bool& IsVar){
166    int VarNmToValP;
167    if (VarNmToValH.IsKey(VarNm.GetUc(), VarNmToValP)){
168      IsVar=true; return VarNmToValH[VarNmToValP];
169    } else {
170      printf("Variable '%s' does not exist\n", VarNm.CStr());
171      IsVar=false; return TExpVal::GetUndefExpVal();
172    }
173  }
174  PExpVal TFaExpEnv::GetFuncVal(
175   const TStr& FuncNm, const TExpValV& ArgValV, bool& IsFunc){
176    IsFunc=true; PExpVal ExpVal=TExpVal::GetUndefExpVal();
177    if (TExpEnv::IsFuncOk("Assign", efatStrAny, FuncNm, ArgValV)){
178      TStr VarNm=ArgValV[0]->GetStrVal();
179      PutVarVal(VarNm, ArgValV[1]);
180    } else
181    if (TExpEnv::IsFuncOk("OnProb", efatFlt, FuncNm, ArgValV)){
182      double RqPrb=ArgValV[0]->GetFltVal();
183      double Prb=GetVarVal("_Prb")->GetFltVal();
184      double PrbUsed=GetVarVal("_PrbUsed")->GetFltVal();
185      bool Ok=(PrbUsed<=Prb)&&(Prb<PrbUsed+RqPrb);
186      PutVarVal("_PrbUsed", TExpVal::New(PrbUsed+RqPrb));
187      ExpVal=TExpVal::New(double(Ok)); IsFunc=true;
188    } else
189    if (TExpEnv::IsFuncOk("AfterTime", efatFlt, FuncNm, ArgValV)){
190      double MxSecs=ArgValV[0]->GetFltVal();
191      TSecTm StartStateTm=FaExe->GetActStateStartTm();
192      bool Ok=TSecTm::GetDSecs(StartStateTm, TSecTm::GetCurTm())>MxSecs;
193      ExpVal=TExpVal::New(double(Ok)); IsFunc=true;
194    } else
195    if (TExpEnv::IsFuncOk("SendMsg", efatStr, FuncNm, ArgValV)){
196      TStr MsgNm=ArgValV[0]->GetStrVal();
197      PFaMsg Msg=TFaMsg::New(MsgNm);
198      FaExe->PushMsg(Msg);
199    } else
200    if (TExpEnv::IsFuncOk("SaveMsgArg", efatStrFlt, FuncNm, ArgValV)){
201      TStr VarNm=ArgValV[0]->GetStrVal();
202      int ArgN=ArgValV[1]->GetFltValAsInt()-1;
203      PFaMsg Msg=FaExe->GetLastMsg();
204      if ((!Msg.Empty())&&(0<=ArgN)&&(ArgN<Msg->GetArgs())){
205        TStr MsgArgValStr=Msg->GetArgVal(ArgN);
206        PExpVal ExpVal=TExpVal::New(MsgArgValStr);
207        PutVarVal(VarNm, ExpVal);
208        printf("Assign '%s'='%s'\n", VarNm.CStr(), MsgArgValStr.CStr());
209      }
210    } else
211    if (TExpEnv::IsFuncOk("SaveMsgArg", efatStr, FuncNm, ArgValV)){
212      TStr VarNm=ArgValV[0]->GetStrVal();
213      int ArgN=0;
214      PFaMsg Msg=FaExe->GetLastMsg();
215      if ((!Msg.Empty())&&(0<=ArgN)&&(ArgN<Msg->GetArgs())){
216        TStr MsgArgValStr=Msg->GetArgVal(ArgN);
217        PExpVal ExpVal=TExpVal::New(MsgArgValStr);
218        PutVarVal(VarNm, ExpVal);
219        printf("Assign '%s'='%s'\n", VarNm.CStr(), MsgArgValStr.CStr());
220      }
221    } else
222    if (TExpEnv::IsFuncOk("PlayIntro", efatStr, FuncNm, ArgValV)){
223      TStr CallNumStr=ArgValV[0]->GetStrVal();
224      printf(".....Playing Intro for '%s'.....\n", CallNumStr.CStr());
225    } else
226    if (TExpEnv::IsFuncOk("PlayCm", efatStrStr, FuncNm, ArgValV)){
227      TStr CallNumStr=ArgValV[0]->GetStrVal();
228      TStr CmNm=ArgValV[1]->GetStrVal();
229      printf(".....Playing Command '%s' for '%s'.....\n",
230       CmNm.CStr(), CallNumStr.CStr());
231    } else {
232      printf("Bad env. function call %s/%d\n", FuncNm.CStr(), ArgValV.Len());
233      IsFunc=false;
234    }
235    return ExpVal;
236  }
237  PExpVal TFaExe::EvalExpStr(const TStr& ExpStr){
238    bool Ok; TStr MsgStr; bool DbgP; TStr DbgStr; PExpVal ExpVal;
239    PExp Exp=TExp::LoadTxt(ExpStr, Ok, MsgStr);
240    if (Ok){
241      ExpVal=Exp->Eval(Ok, MsgStr, DbgP, DbgStr, ExpEnv);
242      if (!Ok){Notify->OnNotify(ntErr, MsgStr);}
243    } else {
244      Notify->OnNotify(ntErr, MsgStr);
245      ExpVal=TExpVal::GetUndefExpVal();
246    }
247    return ExpVal;
248  }
249  TFaExe::TFaExe(const PFaDef& _FaDef, const PNotify& _Notify):
250    FaDef(_FaDef), Notify(_Notify),
251    ActState(FaDef->GetStartState()), ActTrans(),
252    ActStateStartTm(TSecTm::GetCurTm()), MsgQ(),
253    ExpEnv(TFaExpEnv::New(this)),
254    LastMsg(){
255    Notify->OnNotify(ntInfo, TStr("Starting at state: ")+ActState->GetNm());
256    if (!ActState->GetScriptStr().Empty()){
257      EvalExpStr(ActState->GetScriptStr());
258    }
259  }
260  TFaExe::~TFaExe(){
261    Notify->OnNotify(ntInfo, TStr("Terminating at state: ")+ActState->GetNm());
262  }
263  void TFaExe::ExeStep(){
264    double Prb=ExpEnv->GetRnd().GetUniDev();
265    ExpEnv->PutVarVal("_Prb", TExpVal::New(Prb));
266    ExpEnv->PutVarVal("_PrbUsed", TExpVal::New(0));
267    TFaTransV EmptyTransV; TFaTransV CondTransV;
268    for (int TransN=0; TransN<ActState->GetTranss(); TransN++){
269      PFaTrans Trans=ActState->GetTrans(TransN);
270      if (Trans->GetCondStr().GetTrunc().Empty()){EmptyTransV.Add(Trans);}
271      else {CondTransV.Add(Trans);}
272    }
273    PFaState NewActState; ActTrans=NULL;
274    for (int CondTransN=0; CondTransN<CondTransV.Len(); CondTransN++){
275      PFaTrans CondTrans=CondTransV[CondTransN];
<span onclick='openModal()' class='match'>276      PExpVal ExpVal=EvalExpStr(CondTrans->GetCondStr());
277      if (ExpVal->GetFltVal()!=0){
278        ActTrans=CondTrans;
279        TStr NewActStateNm=CondTransV[CondTransN]->GetDstStateNm();
280        if (FaDef->IsState(NewActStateNm)){
281          NewActState=FaDef->GetState(NewActStateNm);
282        } else {
</span>283          Notify->OnNotify(ntErr, TStr("Invalid state name (")+NewActStateNm+")");
284        }
285        break;
286      }
287    }
288    if (NewActState.Empty()){
289      if (EmptyTransV.Len()>0){
290        ActTrans=EmptyTransV[0];
291        TStr NewActStateNm=ActTrans->GetDstStateNm();
292        if (FaDef->IsState(NewActStateNm)){
293          NewActState=FaDef->GetState(NewActStateNm);
294        } else {
295          Notify->OnNotify(ntErr, TStr("Invalid state name (")+NewActStateNm+")");
296        }
297      }
298    }
299    TStr OldStateNm=ActState->GetNm();
300    if (!NewActState.Empty()){
301      ActState=NewActState; ActStateStartTm=TSecTm::GetCurTm();
302      if (!ActState->GetScriptStr().Empty()){
303        EvalExpStr(ActState->GetScriptStr());
304      }
305      TStr NewStateNm=ActState->GetNm();
306      Notify->OnNotify(ntInfo, TStr("Transition: ")+OldStateNm+" -> "+NewStateNm);
307    }
308  }
309  void TFaExe::SendMsg(const PFaMsg& Msg){
310    if (!Msg.Empty()){
311      MsgQ.Push(Msg);}
312    while ((ActState()!=FaDef->GetEndState()())&&(!MsgQ.Empty())){
313      if (!MsgQ.Empty()){
314        LastMsg=MsgQ.Top(); MsgQ.Pop();
315        printf("Msg: '%s'\n", LastMsg->GetNm()());
316        PFaTrans Trans;/&bsol;**=FaDef->GetTrans(State, LastMsg);
317        if (!Trans.Empty()){
318          if (!Trans->GetScriptStr().Empty()){
319            bool Ok; TStr MsgStr;
320            TExp::LoadAndEvalExpL(Trans->GetScriptStr(), Ok, MsgStr, ExpEnv);
321          }
322          ActState=FaDef->GetState(Trans->GetDstStateNm());
323          if (!ActState->GetScriptStr().Empty()){
324            bool Ok; TStr MsgStr;
325            TExp::LoadAndEvalExpL(ActState->GetScriptStr(), Ok, MsgStr, ExpEnv);
326          }
327        } else {
328          printf("No transition for Msg: '%s'\n", LastMsg->GetNm()());
329        }
330      }
331      printf("State: '%s'\n", ActState->GetNm().CStr());
332    }
333  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-ligature_table.cpp</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-fa.cpp</div>
                <div class="column column_space"><pre><code>39        int norm_length = normed8.size();
40        if (normed8 != lig8 && lig_length > 1 && norm_length > 1) {
41          norm_to_lig_table_[normed8] = lig8;
42          lig_to_norm_table_[lig8] = normed8;
43          if (min_lig_length_ == 0 || lig_length < min_lig_length_) {
44            min_lig_length_ = lig_length;
45          }
</pre></code></div>
                <div class="column column_space"><pre><code>276      PExpVal ExpVal=EvalExpStr(CondTrans->GetCondStr());
277      if (ExpVal->GetFltVal()!=0){
278        ActTrans=CondTrans;
279        TStr NewActStateNm=CondTransV[CondTransN]->GetDstStateNm();
280        if (FaDef->IsState(NewActStateNm)){
281          NewActState=FaDef->GetState(NewActStateNm);
282        } else {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    