
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 17, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-json.cpp</h3>
            <pre><code>1  TJsonVal::TJsonVal(TSIn&amp; SIn):
2    JsonValType((TJsonValType)(TInt(SIn).Val)), Bool(SIn), 
3    Num(SIn), Str(SIn), ValV(SIn), KeyValH(SIn) { }
4  void TJsonVal::Save(TSOut&amp; SOut) const {
5    TInt((int)JsonValType).Save(SOut);
6    Bool.Save(SOut); Num.Save(SOut);
7    Str.Save(SOut); ValV.Save(SOut);
8    KeyValH.Save(SOut);
9  }
10  TStr TJsonVal::SaveStr() { 
11    return GetStrFromVal(this); 
12  }
13  bool TJsonVal::operator==(const TJsonVal&amp; JsonVal) const {
14    return JsonValType == JsonVal.JsonValType &amp;&amp;
15      Bool == JsonVal.Bool &amp;&amp;
16      Num == JsonVal.Num &amp;&amp;
17      Str == JsonVal.Str &amp;&amp;
18      ValV == JsonVal.ValV &amp;&amp; 
19      KeyValH == JsonVal.KeyValH;    
20  }
21  bool TJsonVal::operator!=(const TJsonVal&amp; JsonVal) const {
22    return !(*this == JsonVal);
23  }
24  void TJsonVal::AddToObj(const PJsonVal&amp; Val) {
25  	EAssert(Val-&gt;IsObj());
26  	int KeyId = Val-&gt;KeyValH.FFirstKeyId();
27  	while (Val-&gt;KeyValH.FNextKeyId(KeyId)) {
28  		AddToObj(Val-&gt;KeyValH.GetKey(KeyId), Val-&gt;KeyValH[KeyId]);
29  	}
30  }
31  PJsonVal TJsonVal::NewArr(const TJsonValV&amp; ValV) {
32  	PJsonVal Val = TJsonVal::NewArr();
33  	for (int ValN = 0; ValN &lt; ValV.Len(); ValN++) {
34  		Val-&gt;AddToArr(ValV[ValN]);
35  	}
36  	return Val;
37  }
38  PJsonVal TJsonVal::NewArr(const TIntV&amp; IntV) {
39  	PJsonVal Val = TJsonVal::NewArr();
40  	for (int IntN = 0; IntN &lt; IntV.Len(); IntN++) {
41  		Val-&gt;AddToArr(TJsonVal::NewNum((double)IntV[IntN]));
42  	}
43  	return Val;
44  }
45  PJsonVal TJsonVal::NewArr(const TFltV&amp; FltV) {
46  	PJsonVal Val = TJsonVal::NewArr();
47  	for (int FltN = 0; FltN &lt; FltV.Len(); FltN++) {
48  		Val-&gt;AddToArr(TJsonVal::NewNum(FltV[FltN]));
49  	}
50  	return Val;
51  }
52  PJsonVal TJsonVal::NewArr(const TStrV&amp; StrV) {
53  	PJsonVal Val = TJsonVal::NewArr();
54  	for (int StrN = 0; StrN &lt; StrV.Len(); StrN++) {
55  		Val-&gt;AddToArr(TJsonVal::NewStr(StrV[StrN]));
56  	}
57  	return Val;
58  }
59  PJsonVal TJsonVal::NewArr(const TFltPr&amp; FltPr) {
60    PJsonVal Val = TJsonVal::NewArr();
61    Val-&gt;AddToArr(TJsonVal::NewNum(FltPr.Val1));
62    Val-&gt;AddToArr(TJsonVal::NewNum(FltPr.Val2));
63    return Val;
64  }
65  PJsonVal TJsonVal::GetObjKey(const TStr&amp; Key) const {
66    EAssert(IsObj());
<span onclick='openModal()' class='match'>67    EAssert(IsObjKey(Key)); 
68    return KeyValH.GetDat(Key);
69  }
70  PJsonVal TJsonVal::GetObjKey(const char *Key) const {
</span>71    EAssert(IsObj());
72    EAssert(IsObjKey(Key));
73    return KeyValH.GetDat(Key);
74  }
75  bool TJsonVal::GetObjBool(const TStr&amp; Key, const bool&amp; DefBool) const { 
76    EAssert(IsObj());
77    return (IsObjKey(Key)) ? KeyValH.GetDat(Key)-&gt;GetBool() : DefBool;
78  }
79  bool TJsonVal::GetObjBool(const char *Key, const bool&amp; DefBool) const { 
80    EAssert(IsObj());
81    return (IsObjKey(Key)) ? KeyValH.GetDat(Key)-&gt;GetBool() : DefBool;
82  }
83  double TJsonVal::GetObjNum(const TStr&amp; Key, const double&amp; DefNum) const { 
84    EAssert(IsObj());
85    return (IsObjKey(Key)) ? KeyValH.GetDat(Key)-&gt;GetNum() : DefNum;
86  } 
87  double TJsonVal::GetObjNum(const char *Key, const double&amp; DefNum) const { 
88    EAssert(IsObj());
89    return (IsObjKey(Key)) ? KeyValH.GetDat(Key)-&gt;GetNum() : DefNum;
90  }
91  TStr TJsonVal::GetObjStr(const TStr&amp; Key, const TStr&amp; DefStr) const { 
92    EAssert(IsObj());
93    return (IsObjKey(Key)) ? KeyValH.GetDat(Key)-&gt;GetStr() : DefStr;
94  }
95  TStr TJsonVal::GetObjStr(const char *Key, const TStr&amp; DefStr) const { 
96    EAssert(IsObj());
97    return (IsObjKey(Key)) ? KeyValH.GetDat(Key)-&gt;GetStr() : DefStr;
98  }
99  PJsonVal TJsonVal::GetValFromLx(TILx&amp; Lx){
100    static TFSet ValExpect=TFSet()|syIdStr|syFlt|syQStr|syLBracket|syLBrace|syRBracket;
101    PJsonVal Val=TJsonVal::New();
102    if ((Lx.Sym==syIdStr)&amp;&amp;(Lx.Str==&quot;null&quot;)){
103      Val-&gt;PutNull(); Lx.GetSym();
104    } else if ((Lx.Sym==syIdStr)&amp;&amp;(Lx.Str==&quot;true&quot;)){
105      Val-&gt;PutBool(true); Lx.GetSym();
106    } else if ((Lx.Sym==syIdStr)&amp;&amp;(Lx.Str==&quot;false&quot;)){
107      Val-&gt;PutBool(false); Lx.GetSym();
108    } else if (Lx.Sym==syFlt){
109      Val-&gt;PutNum(Lx.Flt); Lx.GetSym();
110    } else if (Lx.Sym==syQStr){
111      Val-&gt;PutStr(Lx.Str); Lx.GetSym();
112    } else if (Lx.Sym==syLBracket){
113      Val-&gt;PutArr(); Lx.GetSym(ValExpect); 
114      if (Lx.Sym!=syRBracket){
115        forever{
116          PJsonVal SubVal=TJsonVal::GetValFromLx(Lx);
117          Val-&gt;AddToArr(SubVal);
118          if (Lx.Sym==syComma){Lx.GetSym(ValExpect);} 
119          else if (Lx.Sym==syRBracket){break;} 
120          else {TExcept::Throw(&quot;JSON Array not properly formed.&quot;);}
121        }
122      }
123      Lx.GetSym();
124    } else if (Lx.Sym==syLBrace){
125      Val-&gt;PutObj(); Lx.GetSym(TFSet()|syRBrace|syQStr);
126      if (Lx.Sym!=syRBrace){
127        forever{
128          TStr SubKey=Lx.Str; 
129          Lx.GetSym(syColon); 
130          Lx.GetSym(ValExpect);
131          PJsonVal SubVal=TJsonVal::GetValFromLx(Lx);
132          Val-&gt;AddToObj(SubKey, SubVal);
133          if (Lx.Sym==syComma){Lx.GetSym(TFSet()|syQStr);} 
134          else if (Lx.Sym==syRBrace){break;} 
135          else {TExcept::Throw(&quot;JSON Object not properly formed.&quot;);}
136        }
137      }
138      Lx.GetSym();
139    } else {
140      TExcept::Throw(&quot;Unexpected JSON symbol.&quot;);
141    }
142    return Val;
143  }
144  PJsonVal TJsonVal::GetValFromSIn(const PSIn&amp; SIn){
145    TILx Lx(SIn, TFSet()|iloCmtAlw|iloCsSens|iloExcept|iloSigNum);
146    PJsonVal Val;
147    TStr MsgStr=&quot;Ok&quot;;
148    try {
149      Lx.GetSym(TFSet()|syLBracket|syLBrace);
150      Val=GetValFromLx(Lx);
151    }
152    catch (PExcept Except){
153      MsgStr=Except-&gt;GetMsgStr();
154      Val=TJsonVal::New();
155    }
156    return Val;
157  }
158  PJsonVal TJsonVal::GetValFromStr(const TStr&amp; JsonStr){
159    PSIn SIn=TStrIn::New(JsonStr);
160    return GetValFromSIn(SIn);
161  }
162  void TJsonVal::AddEscapeChAFromStr(const TStr&amp; Str, TChA&amp; ChA){
163  	if (TUnicodeDef::IsDef()) {
164  		TIntV UStr; TUnicodeDef::GetDef()-&gt;DecodeUtf8(Str, UStr);
165  		for (int ChN = 0; ChN &lt; UStr.Len(); ChN++) {
166  			const int UCh = UStr[ChN];
167  			if (UCh &lt; 0x80) {
168  				const char Ch = (char)UCh;
169  				switch (Ch) {
170  					case &#x27;&quot;&#x27; : ChA.AddCh(&#x27;\\&#x27;); ChA.AddCh(&#x27;&quot;&#x27;); break;
171  					case &#x27;\\&#x27; : ChA.AddCh(&#x27;\\&#x27;); ChA.AddCh(&#x27;\\&#x27;); break;
172  					case &#x27;/&#x27; : ChA.AddCh(&#x27;\\&#x27;); ChA.AddCh(&#x27;/&#x27;); break;
173  					case &#x27;\b&#x27; : ChA.AddCh(&#x27;\\&#x27;); ChA.AddCh(&#x27;b&#x27;); break;
174  					case &#x27;\f&#x27; : ChA.AddCh(&#x27;\\&#x27;); ChA.AddCh(&#x27;f&#x27;); break;
175  					case &#x27;\n&#x27; : ChA.AddCh(&#x27;\\&#x27;); ChA.AddCh(&#x27;n&#x27;); break;
176  					case &#x27;\r&#x27; : ChA.AddCh(&#x27;\\&#x27;); ChA.AddCh(&#x27;r&#x27;); break;
177  					case &#x27;\t&#x27; : ChA.AddCh(&#x27;\\&#x27;); ChA.AddCh(&#x27;t&#x27;); break;
178  					default :
179  						ChA.AddCh(Ch);
180  				}
181  			} else {
182  				ChA += &quot;\\u&quot;;
183  				ChA += TStr::Fmt(&quot;%04x&quot;, UCh);
184  			}
185  		}
186  	} else {
187  		for (int ChN = 0; ChN &lt; Str.Len(); ChN++) {
188  			const char Ch = Str[ChN];
189  			if ((Ch &amp; 0x80) == 0) {
190  				switch (Ch) {
191  					case &#x27;&quot;&#x27; : ChA.AddCh(&#x27;\\&#x27;); ChA.AddCh(&#x27;&quot;&#x27;); break;
192  					case &#x27;\\&#x27; : ChA.AddCh(&#x27;\\&#x27;); ChA.AddCh(&#x27;\\&#x27;); break;
193  					case &#x27;/&#x27; : ChA.AddCh(&#x27;\\&#x27;); ChA.AddCh(&#x27;/&#x27;); break;
194  					case &#x27;\b&#x27; : ChA.AddCh(&#x27;\\&#x27;); ChA.AddCh(&#x27;b&#x27;); break;
195  					case &#x27;\f&#x27; : ChA.AddCh(&#x27;\\&#x27;); ChA.AddCh(&#x27;f&#x27;); break;
196  					case &#x27;\n&#x27; : ChA.AddCh(&#x27;\\&#x27;); ChA.AddCh(&#x27;n&#x27;); break;
197  					case &#x27;\r&#x27; : ChA.AddCh(&#x27;\\&#x27;); ChA.AddCh(&#x27;r&#x27;); break;
198  					case &#x27;\t&#x27; : ChA.AddCh(&#x27;\\&#x27;); ChA.AddCh(&#x27;t&#x27;); break;
199  					default : ChA.AddCh(Ch);
200  				}
201  			} else {
202  				ChA += &quot;\\u&quot;;
203  				ChA += TStr::Fmt(&quot;%02x&quot;, (int)Ch);
204  			}
205  		}
206  	}
207  }
208  void TJsonVal::AddQChAFromStr(const TStr&amp; Str, TChA&amp; ChA){
209    ChA+=&quot;\&quot;&quot;;
210    AddEscapeChAFromStr(Str, ChA);
211    ChA+=&quot;\&quot;&quot;;
212  }
213  void TJsonVal::GetChAFromVal(const PJsonVal&amp; Val, TChA&amp; ChA){
214    switch (Val-&gt;GetJsonValType()){
215      case jvtNull: 
216        ChA+=&quot;null&quot;; break;
217      case jvtBool:
218        if (Val-&gt;GetBool()){ChA+=&quot;true&quot;;} else {ChA+=&quot;false&quot;;} break;
219      case jvtNum: 
220        ChA+=TStr::Fmt(&quot;%f&quot;, Val-&gt;GetNum()); break;
221      case jvtStr:
222        AddQChAFromStr(Val-&gt;GetStr(), ChA); break;
223      case jvtArr:
224        ChA+=&quot;[&quot;;
225        for (int ArrValN=0; ArrValN&lt;Val-&gt;GetArrVals(); ArrValN++){
226          if (ArrValN&gt;0){ChA+=&quot;, &quot;;}
227          GetChAFromVal(Val-&gt;GetArrVal(ArrValN), ChA);
228        }
229        ChA+=&quot;]&quot;; 
230        break;
231      case jvtObj:
232        ChA+=&quot;{&quot;;
233        for (int ObjKeyN=0; ObjKeyN&lt;Val-&gt;GetObjKeys(); ObjKeyN++){
234          if (ObjKeyN&gt;0){ChA+=&quot;, &quot;;}
235          TStr ObjKey; PJsonVal ObjVal; Val-&gt;GetObjKeyVal(ObjKeyN, ObjKey, ObjVal);
236          AddQChAFromStr(ObjKey, ChA);
237          ChA+=&quot;:&quot;;
238          GetChAFromVal(ObjVal, ChA);
239        }
240        ChA+=&quot;}&quot;; 
241        break;
242  	default: TExcept::Throw(&quot;Error parsing json&quot;);
243    }
244  }
245  TStr TJsonVal::GetStrFromVal(const PJsonVal&amp; Val){
246    TChA ChA;
247    GetChAFromVal(Val, ChA);
248    return ChA;
249  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-json.cpp</h3>
            <pre><code>1  TJsonVal::TJsonVal(TSIn&amp; SIn):
2    JsonValType((TJsonValType)(TInt(SIn).Val)), Bool(SIn), 
3    Num(SIn), Str(SIn), ValV(SIn), KeyValH(SIn) { }
4  void TJsonVal::Save(TSOut&amp; SOut) const {
5    TInt((int)JsonValType).Save(SOut);
6    Bool.Save(SOut); Num.Save(SOut);
7    Str.Save(SOut); ValV.Save(SOut);
8    KeyValH.Save(SOut);
9  }
10  TStr TJsonVal::SaveStr() { 
11    return GetStrFromVal(this); 
12  }
13  bool TJsonVal::operator==(const TJsonVal&amp; JsonVal) const {
14    return JsonValType == JsonVal.JsonValType &amp;&amp;
15      Bool == JsonVal.Bool &amp;&amp;
16      Num == JsonVal.Num &amp;&amp;
17      Str == JsonVal.Str &amp;&amp;
18      ValV == JsonVal.ValV &amp;&amp; 
19      KeyValH == JsonVal.KeyValH;    
20  }
21  bool TJsonVal::operator!=(const TJsonVal&amp; JsonVal) const {
22    return !(*this == JsonVal);
23  }
24  void TJsonVal::AddToObj(const PJsonVal&amp; Val) {
25  	EAssert(Val-&gt;IsObj());
26  	int KeyId = Val-&gt;KeyValH.FFirstKeyId();
27  	while (Val-&gt;KeyValH.FNextKeyId(KeyId)) {
28  		AddToObj(Val-&gt;KeyValH.GetKey(KeyId), Val-&gt;KeyValH[KeyId]);
29  	}
30  }
31  PJsonVal TJsonVal::NewArr(const TJsonValV&amp; ValV) {
32  	PJsonVal Val = TJsonVal::NewArr();
33  	for (int ValN = 0; ValN &lt; ValV.Len(); ValN++) {
34  		Val-&gt;AddToArr(ValV[ValN]);
35  	}
36  	return Val;
37  }
38  PJsonVal TJsonVal::NewArr(const TIntV&amp; IntV) {
39  	PJsonVal Val = TJsonVal::NewArr();
40  	for (int IntN = 0; IntN &lt; IntV.Len(); IntN++) {
41  		Val-&gt;AddToArr(TJsonVal::NewNum((double)IntV[IntN]));
42  	}
43  	return Val;
44  }
45  PJsonVal TJsonVal::NewArr(const TFltV&amp; FltV) {
46  	PJsonVal Val = TJsonVal::NewArr();
47  	for (int FltN = 0; FltN &lt; FltV.Len(); FltN++) {
48  		Val-&gt;AddToArr(TJsonVal::NewNum(FltV[FltN]));
49  	}
50  	return Val;
51  }
52  PJsonVal TJsonVal::NewArr(const TStrV&amp; StrV) {
53  	PJsonVal Val = TJsonVal::NewArr();
54  	for (int StrN = 0; StrN &lt; StrV.Len(); StrN++) {
55  		Val-&gt;AddToArr(TJsonVal::NewStr(StrV[StrN]));
56  	}
57  	return Val;
58  }
59  PJsonVal TJsonVal::NewArr(const TFltPr&amp; FltPr) {
60    PJsonVal Val = TJsonVal::NewArr();
61    Val-&gt;AddToArr(TJsonVal::NewNum(FltPr.Val1));
62    Val-&gt;AddToArr(TJsonVal::NewNum(FltPr.Val2));
63    return Val;
64  }
65  PJsonVal TJsonVal::GetObjKey(const TStr&amp; Key) const {
66    EAssert(IsObj());
67    EAssert(IsObjKey(Key)); 
68    return KeyValH.GetDat(Key);
69  }
70  PJsonVal TJsonVal::GetObjKey(const char *Key) const {
71    EAssert(IsObj());
<span onclick='openModal()' class='match'>72    EAssert(IsObjKey(Key));
73    return KeyValH.GetDat(Key);
74  }
75  bool TJsonVal::GetObjBool(const TStr&amp; Key, const bool&amp; DefBool) const { 
</span>76    EAssert(IsObj());
77    return (IsObjKey(Key)) ? KeyValH.GetDat(Key)-&gt;GetBool() : DefBool;
78  }
79  bool TJsonVal::GetObjBool(const char *Key, const bool&amp; DefBool) const { 
80    EAssert(IsObj());
81    return (IsObjKey(Key)) ? KeyValH.GetDat(Key)-&gt;GetBool() : DefBool;
82  }
83  double TJsonVal::GetObjNum(const TStr&amp; Key, const double&amp; DefNum) const { 
84    EAssert(IsObj());
85    return (IsObjKey(Key)) ? KeyValH.GetDat(Key)-&gt;GetNum() : DefNum;
86  } 
87  double TJsonVal::GetObjNum(const char *Key, const double&amp; DefNum) const { 
88    EAssert(IsObj());
89    return (IsObjKey(Key)) ? KeyValH.GetDat(Key)-&gt;GetNum() : DefNum;
90  }
91  TStr TJsonVal::GetObjStr(const TStr&amp; Key, const TStr&amp; DefStr) const { 
92    EAssert(IsObj());
93    return (IsObjKey(Key)) ? KeyValH.GetDat(Key)-&gt;GetStr() : DefStr;
94  }
95  TStr TJsonVal::GetObjStr(const char *Key, const TStr&amp; DefStr) const { 
96    EAssert(IsObj());
97    return (IsObjKey(Key)) ? KeyValH.GetDat(Key)-&gt;GetStr() : DefStr;
98  }
99  PJsonVal TJsonVal::GetValFromLx(TILx&amp; Lx){
100    static TFSet ValExpect=TFSet()|syIdStr|syFlt|syQStr|syLBracket|syLBrace|syRBracket;
101    PJsonVal Val=TJsonVal::New();
102    if ((Lx.Sym==syIdStr)&amp;&amp;(Lx.Str==&quot;null&quot;)){
103      Val-&gt;PutNull(); Lx.GetSym();
104    } else if ((Lx.Sym==syIdStr)&amp;&amp;(Lx.Str==&quot;true&quot;)){
105      Val-&gt;PutBool(true); Lx.GetSym();
106    } else if ((Lx.Sym==syIdStr)&amp;&amp;(Lx.Str==&quot;false&quot;)){
107      Val-&gt;PutBool(false); Lx.GetSym();
108    } else if (Lx.Sym==syFlt){
109      Val-&gt;PutNum(Lx.Flt); Lx.GetSym();
110    } else if (Lx.Sym==syQStr){
111      Val-&gt;PutStr(Lx.Str); Lx.GetSym();
112    } else if (Lx.Sym==syLBracket){
113      Val-&gt;PutArr(); Lx.GetSym(ValExpect); 
114      if (Lx.Sym!=syRBracket){
115        forever{
116          PJsonVal SubVal=TJsonVal::GetValFromLx(Lx);
117          Val-&gt;AddToArr(SubVal);
118          if (Lx.Sym==syComma){Lx.GetSym(ValExpect);} 
119          else if (Lx.Sym==syRBracket){break;} 
120          else {TExcept::Throw(&quot;JSON Array not properly formed.&quot;);}
121        }
122      }
123      Lx.GetSym();
124    } else if (Lx.Sym==syLBrace){
125      Val-&gt;PutObj(); Lx.GetSym(TFSet()|syRBrace|syQStr);
126      if (Lx.Sym!=syRBrace){
127        forever{
128          TStr SubKey=Lx.Str; 
129          Lx.GetSym(syColon); 
130          Lx.GetSym(ValExpect);
131          PJsonVal SubVal=TJsonVal::GetValFromLx(Lx);
132          Val-&gt;AddToObj(SubKey, SubVal);
133          if (Lx.Sym==syComma){Lx.GetSym(TFSet()|syQStr);} 
134          else if (Lx.Sym==syRBrace){break;} 
135          else {TExcept::Throw(&quot;JSON Object not properly formed.&quot;);}
136        }
137      }
138      Lx.GetSym();
139    } else {
140      TExcept::Throw(&quot;Unexpected JSON symbol.&quot;);
141    }
142    return Val;
143  }
144  PJsonVal TJsonVal::GetValFromSIn(const PSIn&amp; SIn){
145    TILx Lx(SIn, TFSet()|iloCmtAlw|iloCsSens|iloExcept|iloSigNum);
146    PJsonVal Val;
147    TStr MsgStr=&quot;Ok&quot;;
148    try {
149      Lx.GetSym(TFSet()|syLBracket|syLBrace);
150      Val=GetValFromLx(Lx);
151    }
152    catch (PExcept Except){
153      MsgStr=Except-&gt;GetMsgStr();
154      Val=TJsonVal::New();
155    }
156    return Val;
157  }
158  PJsonVal TJsonVal::GetValFromStr(const TStr&amp; JsonStr){
159    PSIn SIn=TStrIn::New(JsonStr);
160    return GetValFromSIn(SIn);
161  }
162  void TJsonVal::AddEscapeChAFromStr(const TStr&amp; Str, TChA&amp; ChA){
163  	if (TUnicodeDef::IsDef()) {
164  		TIntV UStr; TUnicodeDef::GetDef()-&gt;DecodeUtf8(Str, UStr);
165  		for (int ChN = 0; ChN &lt; UStr.Len(); ChN++) {
166  			const int UCh = UStr[ChN];
167  			if (UCh &lt; 0x80) {
168  				const char Ch = (char)UCh;
169  				switch (Ch) {
170  					case &#x27;&quot;&#x27; : ChA.AddCh(&#x27;\\&#x27;); ChA.AddCh(&#x27;&quot;&#x27;); break;
171  					case &#x27;\\&#x27; : ChA.AddCh(&#x27;\\&#x27;); ChA.AddCh(&#x27;\\&#x27;); break;
172  					case &#x27;/&#x27; : ChA.AddCh(&#x27;\\&#x27;); ChA.AddCh(&#x27;/&#x27;); break;
173  					case &#x27;\b&#x27; : ChA.AddCh(&#x27;\\&#x27;); ChA.AddCh(&#x27;b&#x27;); break;
174  					case &#x27;\f&#x27; : ChA.AddCh(&#x27;\\&#x27;); ChA.AddCh(&#x27;f&#x27;); break;
175  					case &#x27;\n&#x27; : ChA.AddCh(&#x27;\\&#x27;); ChA.AddCh(&#x27;n&#x27;); break;
176  					case &#x27;\r&#x27; : ChA.AddCh(&#x27;\\&#x27;); ChA.AddCh(&#x27;r&#x27;); break;
177  					case &#x27;\t&#x27; : ChA.AddCh(&#x27;\\&#x27;); ChA.AddCh(&#x27;t&#x27;); break;
178  					default :
179  						ChA.AddCh(Ch);
180  				}
181  			} else {
182  				ChA += &quot;\\u&quot;;
183  				ChA += TStr::Fmt(&quot;%04x&quot;, UCh);
184  			}
185  		}
186  	} else {
187  		for (int ChN = 0; ChN &lt; Str.Len(); ChN++) {
188  			const char Ch = Str[ChN];
189  			if ((Ch &amp; 0x80) == 0) {
190  				switch (Ch) {
191  					case &#x27;&quot;&#x27; : ChA.AddCh(&#x27;\\&#x27;); ChA.AddCh(&#x27;&quot;&#x27;); break;
192  					case &#x27;\\&#x27; : ChA.AddCh(&#x27;\\&#x27;); ChA.AddCh(&#x27;\\&#x27;); break;
193  					case &#x27;/&#x27; : ChA.AddCh(&#x27;\\&#x27;); ChA.AddCh(&#x27;/&#x27;); break;
194  					case &#x27;\b&#x27; : ChA.AddCh(&#x27;\\&#x27;); ChA.AddCh(&#x27;b&#x27;); break;
195  					case &#x27;\f&#x27; : ChA.AddCh(&#x27;\\&#x27;); ChA.AddCh(&#x27;f&#x27;); break;
196  					case &#x27;\n&#x27; : ChA.AddCh(&#x27;\\&#x27;); ChA.AddCh(&#x27;n&#x27;); break;
197  					case &#x27;\r&#x27; : ChA.AddCh(&#x27;\\&#x27;); ChA.AddCh(&#x27;r&#x27;); break;
198  					case &#x27;\t&#x27; : ChA.AddCh(&#x27;\\&#x27;); ChA.AddCh(&#x27;t&#x27;); break;
199  					default : ChA.AddCh(Ch);
200  				}
201  			} else {
202  				ChA += &quot;\\u&quot;;
203  				ChA += TStr::Fmt(&quot;%02x&quot;, (int)Ch);
204  			}
205  		}
206  	}
207  }
208  void TJsonVal::AddQChAFromStr(const TStr&amp; Str, TChA&amp; ChA){
209    ChA+=&quot;\&quot;&quot;;
210    AddEscapeChAFromStr(Str, ChA);
211    ChA+=&quot;\&quot;&quot;;
212  }
213  void TJsonVal::GetChAFromVal(const PJsonVal&amp; Val, TChA&amp; ChA){
214    switch (Val-&gt;GetJsonValType()){
215      case jvtNull: 
216        ChA+=&quot;null&quot;; break;
217      case jvtBool:
218        if (Val-&gt;GetBool()){ChA+=&quot;true&quot;;} else {ChA+=&quot;false&quot;;} break;
219      case jvtNum: 
220        ChA+=TStr::Fmt(&quot;%f&quot;, Val-&gt;GetNum()); break;
221      case jvtStr:
222        AddQChAFromStr(Val-&gt;GetStr(), ChA); break;
223      case jvtArr:
224        ChA+=&quot;[&quot;;
225        for (int ArrValN=0; ArrValN&lt;Val-&gt;GetArrVals(); ArrValN++){
226          if (ArrValN&gt;0){ChA+=&quot;, &quot;;}
227          GetChAFromVal(Val-&gt;GetArrVal(ArrValN), ChA);
228        }
229        ChA+=&quot;]&quot;; 
230        break;
231      case jvtObj:
232        ChA+=&quot;{&quot;;
233        for (int ObjKeyN=0; ObjKeyN&lt;Val-&gt;GetObjKeys(); ObjKeyN++){
234          if (ObjKeyN&gt;0){ChA+=&quot;, &quot;;}
235          TStr ObjKey; PJsonVal ObjVal; Val-&gt;GetObjKeyVal(ObjKeyN, ObjKey, ObjVal);
236          AddQChAFromStr(ObjKey, ChA);
237          ChA+=&quot;:&quot;;
238          GetChAFromVal(ObjVal, ChA);
239        }
240        ChA+=&quot;}&quot;; 
241        break;
242  	default: TExcept::Throw(&quot;Error parsing json&quot;);
243    }
244  }
245  TStr TJsonVal::GetStrFromVal(const PJsonVal&amp; Val){
246    TChA ChA;
247    GetChAFromVal(Val, ChA);
248    return ChA;
249  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-json.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-json.cpp</div>
                </div>
                <div class="column column_space"><pre><code>67    EAssert(IsObjKey(Key)); 
68    return KeyValH.GetDat(Key);
69  }
70  PJsonVal TJsonVal::GetObjKey(const char *Key) const {
</pre></code></div>
                <div class="column column_space"><pre><code>72    EAssert(IsObjKey(Key));
73    return KeyValH.GetDat(Key);
74  }
75  bool TJsonVal::GetObjBool(const TStr&amp; Key, const bool&amp; DefBool) const { 
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    