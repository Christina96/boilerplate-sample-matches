
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 15, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-resultiterator_test.cc</h3>
            <pre><code>1  #include <allheaders.h>
2  #include <tesseract/baseapi.h>
3  #include <tesseract/resultiterator.h>
4  #include <string>
5  #include "scrollview.h"
6  #include "include_gunit.h"
7  #include "log.h" 
8  namespace tesseract {
9  class ResultIteratorTest : public testing::Test {
10  protected:
11    std::string TestDataNameToPath(const std::string &name) {
12      return file::JoinPath(TESTING_DIR, name);
13    }
14    std::string TessdataPath() {
15      return file::JoinPath(TESSDATA_DIR, "");
16    }
17    std::string OutputNameToPath(const std::string &name) {
18      file::MakeTmpdir();
19      return file::JoinPath(FLAGS_test_tmpdir, name);
20    }
21    ResultIteratorTest() {
22      src_pix_ = nullptr;
23    }
24    ~ResultIteratorTest() override = default;
25    void SetImage(const char *filename) {
26      src_pix_ = pixRead(TestDataNameToPath(filename).c_str());
27      api_.Init(TessdataPath().c_str(), "eng", tesseract::OEM_TESSERACT_ONLY);
28      api_.SetPageSegMode(tesseract::PSM_AUTO);
29      api_.SetImage(src_pix_);
30      src_pix_.destroy();
31      src_pix_ = api_.GetInputImage();
32    }
33    void VerifyRebuild(int max_diff, PageIteratorLevel level, PageIterator *it) {
34      it->Begin();
35      int width = pixGetWidth(src_pix_);
36      int height = pixGetHeight(src_pix_);
37      int depth = pixGetDepth(src_pix_);
38      Image pix = pixCreate(width, height, depth);
39      EXPECT_TRUE(depth == 1 || depth == 8);
40      if (depth == 8) {
41        pixSetAll(pix);
42      }
43      do {
44        int left, top, right, bottom;
45        PageIteratorLevel im_level = level;
46        if (!it->BoundingBox(level, &left, &top, &right, &bottom)) {
47          im_level = tesseract::RIL_BLOCK;
48          EXPECT_TRUE(it->BoundingBox(im_level, &left, &top, &right, &bottom));
49        }
50        LOG(INFO) << "BBox: [L:" << left << ", T:" << top << ", R:" << right << ", B:" << bottom
51                  << "]"
52                  << "\n";
53        Image block_pix;
54        if (depth == 1) {
55          block_pix = it->GetBinaryImage(im_level);
56          pixRasterop(pix, left, top, right - left, bottom - top, PIX_SRC ^ PIX_DST, block_pix, 0, 0);
57        } else {
58          block_pix = it->GetImage(im_level, 2, src_pix_, &left, &top);
59          pixRasterop(pix, left, top, pixGetWidth(block_pix), pixGetHeight(block_pix),
60                      PIX_SRC & PIX_DST, block_pix, 0, 0);
61        }
62        CHECK(block_pix != nullptr);
63        block_pix.destroy();
64      } while (it->Next(level));
65      pixRasterop(pix, 0, 0, width, height, PIX_SRC ^ PIX_DST, src_pix_, 0, 0);
66      if (depth == 8) {
67        Image binary_pix = pixThresholdToBinary(pix, 128);
68        pix.destroy();
69        pixInvert(binary_pix, binary_pix);
70        pix = binary_pix;
71      }
72      l_int32 pixcount;
73      pixCountPixels(pix, &pixcount, nullptr);
74      if (pixcount > max_diff) {
75        std::string outfile = OutputNameToPath("failedxor.png");
76        LOG(INFO) << "outfile = " << outfile << "\n";
77        pixWrite(outfile.c_str(), pix, IFF_PNG);
78      }
79      pix.destroy();
80      LOG(INFO) << "At level " << level << ": pix diff = " << pixcount << "\n";
81      EXPECT_LE(pixcount, max_diff);
82    }
83    void VerifyIteratorText(const std::string &truth, PageIteratorLevel level, ResultIterator *it) {
84      LOG(INFO) << "Text Test Level " << level << "\n";
85      it->Begin();
86      std::string result;
87      do {
88        char *text = it->GetUTF8Text(level);
89        result += text;
90        delete[] text;
91        if ((level == tesseract::RIL_WORD || level == tesseract::RIL_SYMBOL) &&
92            it->IsAtFinalElement(tesseract::RIL_WORD, level)) {
93          if (it->IsAtFinalElement(tesseract::RIL_TEXTLINE, level)) {
94            result += '\n';
95          } else {
96            result += ' ';
97          }
98          if (it->IsAtFinalElement(tesseract::RIL_PARA, level) &&
99              !(it->IsAtFinalElement(tesseract::RIL_BLOCK, level))) {
100            result += '\n';
101          }
102        }
103      } while (it->Next(level));
104      EXPECT_STREQ(truth.c_str(), result.c_str()) << "Rebuild failed at Text Level " << level;
105    }
106    void VerifyRebuilds(int block_limit, int para_limit, int line_limit, int word_limit,
107                        int symbol_limit, PageIterator *it, PageIteratorLevel maxlevel=tesseract::RIL_SYMBOL) {
108      VerifyRebuild(block_limit, tesseract::RIL_BLOCK, it);
109      VerifyRebuild(para_limit, tesseract::RIL_PARA, it);
110      VerifyRebuild(line_limit, tesseract::RIL_TEXTLINE, it);
111      VerifyRebuild(word_limit, tesseract::RIL_WORD, it);
112      if (maxlevel == tesseract::RIL_SYMBOL) {
113        VerifyRebuild(symbol_limit, maxlevel, it);
114      }
115    }
116    void VerifyAllText(const std::string &truth, ResultIterator *it) {
117      VerifyIteratorText(truth, tesseract::RIL_BLOCK, it);
118      VerifyIteratorText(truth, tesseract::RIL_PARA, it);
119      VerifyIteratorText(truth, tesseract::RIL_TEXTLINE, it);
120      VerifyIteratorText(truth, tesseract::RIL_WORD, it);
121      VerifyIteratorText(truth, tesseract::RIL_SYMBOL, it);
122    }
123    void ExpectTextlineReadingOrder(bool in_ltr_context, const StrongScriptDirection *word_dirs,
124                                    int num_words, int *expected_reading_order,
125                                    int num_reading_order_entries) const {
126      std::vector<StrongScriptDirection> gv_word_dirs;
127      for (int i = 0; i < num_words; i++) {
128        gv_word_dirs.push_back(word_dirs[i]);
129      }
130      std::vector<int> calculated_order;
131      ResultIterator::CalculateTextlineOrder(in_ltr_context, gv_word_dirs, &calculated_order);
132      std::vector<int> correct_order(expected_reading_order,
133                                     expected_reading_order + num_reading_order_entries);
134      EXPECT_EQ(correct_order, calculated_order);
135    }
136    void VerifySaneTextlineOrder(bool in_ltr_context, const StrongScriptDirection *word_dirs,
137                                 int num_words) const {
138      std::vector<StrongScriptDirection> gv_word_dirs;
139      for (int i = 0; i < num_words; i++) {
140        gv_word_dirs.push_back(word_dirs[i]);
141      }
142      std::vector<int> output;
143      ResultIterator::CalculateTextlineOrder(in_ltr_context, gv_word_dirs, &output);
144      ASSERT_GE(output.size(), num_words);
145      std::vector<int> output_copy(output);
146      std::sort(output_copy.begin(), output_copy.end());
147      bool sane = true;
148      unsigned j = 0;
149      while (j < output_copy.size() && output_copy[j] < 0) {
150        j++;
151      }
152      for (int i = 0; i < num_words; i++, j++) {
153        if (output_copy[j] != i) {
154          sane = false;
155          break;
156        }
157      }
158      if (j != output_copy.size()) {
159        sane = false;
160      }
161      if (!sane) {
162        std::vector<int> empty;
163        EXPECT_EQ(output, empty) << " permutation of 0.." << num_words - 1 << " not found in "
164                                 << (in_ltr_context ? "ltr" : "rtl") << " context.";
165      }
166    }
<span onclick='openModal()' class='match'>167    Image src_pix_; 
168    std::string ocr_text_;
169    tesseract::TessBaseAPI api_;
170  };
171  TEST_F(ResultIteratorTest, EasyTest) {
</span>172    SetImage("phototest.tif");
173    PageIterator *p_it = api_.AnalyseLayout();
174    EXPECT_FALSE(p_it == nullptr);
175    EXPECT_TRUE(p_it->IsAtBeginningOf(tesseract::RIL_BLOCK));
176    EXPECT_FALSE(p_it->Next(tesseract::RIL_BLOCK));
177    EXPECT_FALSE(p_it->IsAtBeginningOf(tesseract::RIL_BLOCK));
178    LOG(INFO) << "Verifying image rebuilds 1 (pageiterator)"
179              << "\n";
180    VerifyRebuilds(10, 10, 0, 0, 0, p_it);
181    delete p_it;
182    char *result = api_.GetUTF8Text();
183    ocr_text_ = result;
184    delete[] result;
185    ResultIterator *r_it = api_.GetIterator();
186    LOG(INFO) << "Verifying image rebuilds 2a (resultiterator)"
187              << "\n";
188    VerifyRebuilds(8, 8, 0, 0, 40, r_it, tesseract::RIL_WORD);
189    LOG(INFO) << "Verifying text rebuilds 1 (resultiterator)"
190              << "\n";
191    VerifyAllText(ocr_text_, r_it);
192    LOG(INFO) << "Verifying image rebuilds 2b (resultiterator)"
193              << "\n";
194    VerifyRebuilds(8, 8, 0, 0, 40, r_it, tesseract::RIL_WORD);
195    r_it->Begin();
196    int x1, y1, x2, y2;
197    r_it->Baseline(tesseract::RIL_TEXTLINE, &x1, &y1, &x2, &y2);
198    LOG(INFO) << "Baseline ("
199       << x1 << ',' << y1 << ")->(" << x2 << ',' << y2 << ")\n";
200    EXPECT_GE(x2, x1 + 400);
201    int x3 = 200 - x1;
202    int y3 = 116 - y1;
203    x2 -= x1;
204    y2 -= y1;
205    int product = x2 * y3 - x3 * y2;
206    EXPECT_LE(abs(product), x2);
207    do {
208      float confidence = r_it->Confidence(tesseract::RIL_WORD);
209  #ifndef DISABLED_LEGACY_ENGINE
210      int pointsize, font_id;
211      bool bold, italic, underlined, monospace, serif, smallcaps;
212      const char *font = r_it->WordFontAttributes(&bold, &italic, &underlined, &monospace, &serif,
213                                                  &smallcaps, &pointsize, &font_id);
214      EXPECT_GE(confidence, 80.0f);
215  #endif
216      char *word_str = r_it->GetUTF8Text(tesseract::RIL_WORD);
217  #ifdef DISABLED_LEGACY_ENGINE
218      LOG(INFO) << "Word " << word_str << ", conf " << confidence << "\n";
219  #else
220      LOG(INFO) << "Word " << word_str << " in font " << font
221        << ", id " << font_id << ", size " << pointsize
222        << ", conf " << confidence << "\n";
223  #endif 
224      delete[] word_str;
225  #ifndef DISABLED_LEGACY_ENGINE
226      EXPECT_FALSE(bold);
227      EXPECT_FALSE(italic);
228      EXPECT_FALSE(underlined);
229      EXPECT_FALSE(monospace);
230      EXPECT_FALSE(serif);
231      EXPECT_GE(pointsize, 11.16 - 1.50);
232      EXPECT_LE(pointsize, 11.16 + 1.50);
233  #endif 
234    } while (r_it->Next(tesseract::RIL_WORD));
235    delete r_it;
236  }
237  TEST_F(ResultIteratorTest, ComplexTest) {
238    SetImage("8087_054.3B.tif");
239    PageIterator *it = api_.AnalyseLayout();
240    EXPECT_FALSE(it == nullptr);
241    VerifyRebuilds(2073, 2073, 2080, 2081, 2090, it);
242    delete it;
243  }
244  TEST_F(ResultIteratorTest, GreyTest) {
245    SetImage("8087_054.3G.tif");
246    PageIterator *it = api_.AnalyseLayout();
247    EXPECT_FALSE(it == nullptr);
248    VerifyRebuilds(600, 600, 600, 600, 600, it);
249    delete it;
250  }
251  TEST_F(ResultIteratorTest, SmallCapDropCapTest) {
252  #ifdef DISABLED_LEGACY_ENGINE
253    GTEST_SKIP();
254  #else
255    SetImage("8071_093.3B.tif");
256    char *result = api_.GetUTF8Text();
257    delete[] result;
258    ResultIterator *r_it = api_.GetIterator();
259    int found_dropcaps = 0;
260    int found_smallcaps = 0;
261    int false_positives = 0;
262    do {
263      bool bold, italic, underlined, monospace, serif, smallcaps;
264      int pointsize, font_id;
265      r_it->WordFontAttributes(&bold, &italic, &underlined, &monospace, &serif, &smallcaps,
266                               &pointsize, &font_id);
267      char *word_str = r_it->GetUTF8Text(tesseract::RIL_WORD);
268      if (word_str != nullptr) {
269        LOG(INFO) << "Word " << word_str
270          << " is " << (smallcaps ? "SMALLCAPS" : "Normal") << "\n";
271        if (r_it->SymbolIsDropcap()) {
272          ++found_dropcaps;
273        }
274        if (strcmp(word_str, "SHE") == 0 || strcmp(word_str, "MOPED") == 0 ||
275            strcmp(word_str, "RALPH") == 0 || strcmp(word_str, "KINNEY") == 0 || 
276            strcmp(word_str, "BENNETT") == 0) {
277          EXPECT_TRUE(smallcaps) << word_str;
278          ++found_smallcaps;
279        } else {
280          if (smallcaps) {
281            ++false_positives;
282          }
283        }
284        ResultIterator s_it(*r_it);
285        while (s_it.Next(tesseract::RIL_SYMBOL) && !s_it.IsAtBeginningOf(tesseract::RIL_WORD)) {
286          if (s_it.SymbolIsDropcap()) {
287            char *sym_str = s_it.GetUTF8Text(tesseract::RIL_SYMBOL);
288            LOG(ERROR) << "Symbol " << sym_str << " of word " << word_str << " is dropcap";
289            delete[] sym_str;
290          }
291          EXPECT_FALSE(s_it.SymbolIsDropcap());
292        }
293        delete[] word_str;
294      }
295    } while (r_it->Next(tesseract::RIL_WORD));
296    delete r_it;
297    EXPECT_EQ(1, found_dropcaps);
298    EXPECT_GE(4, found_smallcaps);
299    EXPECT_LE(false_positives, 3);
300  #endif 
301  }
302  #if 0
303  TEST_F(ResultIteratorTest, SubSuperTest) {
304    SetImage("0146_281.3B.tif");
305    char* result = api_.GetUTF8Text();
306    delete [] result;
307    ResultIterator* r_it = api_.GetIterator();
308    const char kAllowedSupers[] = "O0123456789-";
309    int found_subs = 0;
310    int found_supers = 0;
311    int found_normal = 0;
312    do {
313      if (r_it->SymbolIsSubscript()) {
314        ++found_subs;
315      } else if (r_it->SymbolIsSuperscript()) {
316        result = r_it->GetUTF8Text(tesseract::RIL_SYMBOL);
317        if (strchr(kAllowedSupers, result[0]) == nullptr) {
318          char* word = r_it->GetUTF8Text(tesseract::RIL_WORD);
319          LOG(ERROR) << "Char " << result << " in word " << word << " is unexpected super!";
320          delete [] word;
321          EXPECT_TRUE(strchr(kAllowedSupers, result[0]) != nullptr);
322        }
323        delete [] result;
324        ++found_supers;
325      } else {
326        ++found_normal;
327      }
328    } while (r_it->Next(tesseract::RIL_SYMBOL));
329    delete r_it;
330    LOG(INFO) << "Subs = " << found_subs << ", supers= " << found_supers
331      << ", normal = " << found_normal << "\n";
332    EXPECT_GE(found_subs, 25);
333    EXPECT_GE(found_supers, 25);
334    EXPECT_GE(found_normal, 1350);
335  }
336  #endif
337  static const StrongScriptDirection dL = DIR_LEFT_TO_RIGHT;
338  static const StrongScriptDirection dR = DIR_RIGHT_TO_LEFT;
339  static const StrongScriptDirection dN = DIR_NEUTRAL;
340  TEST_F(ResultIteratorTest, DualStartTextlineOrderTest) {
341    const StrongScriptDirection word_dirs[] = {dL, dL, dN, dL, dN, dR, dR, dR};
342    int reading_order_rtl_context[] = {7, 6, 5, 4, ResultIterator::kMinorRunStart,
343                                       0, 1, 2, 3, ResultIterator::kMinorRunEnd};
344    int reading_order_ltr_context[] = {
345        0, 1, 2, 3, 4, ResultIterator::kMinorRunStart, 7, 6, 5, ResultIterator::kMinorRunEnd};
346    ExpectTextlineReadingOrder(true, word_dirs, countof(word_dirs), reading_order_ltr_context,
347                               countof(reading_order_ltr_context));
348    ExpectTextlineReadingOrder(false, word_dirs, countof(word_dirs), reading_order_rtl_context,
349                               countof(reading_order_rtl_context));
350  }
351  TEST_F(ResultIteratorTest, LeftwardTextlineOrderTest) {
352    const StrongScriptDirection word_dirs[] = {dL, dL, dN, dL, dN, dN, dL, dL};
353    int reading_order_ltr_context[] = {0, 1, 2, 3, 4, 5, 6, 7};
354    int reading_order_rtl_context[] = {ResultIterator::kMinorRunStart, 0, 1, 2, 3, 4, 5, 6, 7,
355                                       ResultIterator::kMinorRunEnd};
356    ExpectTextlineReadingOrder(true, word_dirs, countof(word_dirs), reading_order_ltr_context,
357                               countof(reading_order_ltr_context));
358    ExpectTextlineReadingOrder(false, word_dirs, countof(word_dirs), reading_order_rtl_context,
359                               countof(reading_order_rtl_context));
360  }
361  TEST_F(ResultIteratorTest, RightwardTextlineOrderTest) {
362    const StrongScriptDirection word_dirs[] = {dR, dR, dN, dR, dN, dN, dR, dR};
363    int reading_order_rtl_context[] = {7, 6, 5, 4, 3, 2, 1, 0};
364    ExpectTextlineReadingOrder(false, word_dirs, countof(word_dirs), reading_order_rtl_context,
365                               countof(reading_order_rtl_context));
366  }
367  TEST_F(ResultIteratorTest, TextlineOrderSanityCheck) {
368    const int kNumWords(7);
369    const int kNumCombos = 1 << (2 * kNumWords); 
370    StrongScriptDirection word_dirs[kNumWords];
371    for (int i = 0; i < kNumCombos; i++) {
372      int tmp = i;
373      for (auto &word_dir : word_dirs) {
374        word_dir = static_cast<StrongScriptDirection>(tmp % 4);
375        tmp = tmp / 4;
376      }
377      VerifySaneTextlineOrder(true, word_dirs, kNumWords);
378      VerifySaneTextlineOrder(false, word_dirs, kNumWords);
379    }
380  }
381  TEST_F(ResultIteratorTest, DISABLED_NonNullChoicesTest) {
382    SetImage("5318c4b679264.jpg");
383    char *result = api_.GetUTF8Text();
384    delete[] result;
385    ResultIterator *r_it = api_.GetIterator();
386    do {
387      char *word_str = r_it->GetUTF8Text(tesseract::RIL_WORD);
388      if (word_str != nullptr) {
389        LOG(INFO) << "Word " << word_str << ":\n";
390        ResultIterator s_it = *r_it;
391        do {
392          tesseract::ChoiceIterator c_it(s_it);
393          do {
394            const char *char_str = c_it.GetUTF8Text();
395            if (char_str == nullptr) {
396              LOG(INFO) << "Null char choice"
397                        << "\n";
398            } else {
399              LOG(INFO) << "Char choice " << char_str << "\n";
400            }
401            CHECK(char_str != nullptr);
402          } while (c_it.Next());
403        } while (!s_it.IsAtFinalElement(tesseract::RIL_WORD, tesseract::RIL_SYMBOL) &&
404                 s_it.Next(tesseract::RIL_SYMBOL));
405        delete[] word_str;
406      }
407    } while (r_it->Next(tesseract::RIL_WORD));
408    delete r_it;
409  }
410  TEST_F(ResultIteratorTest, NonNullConfidencesTest) {
411    SetImage("trainingitalline.tif");
412    api_.SetPageSegMode(tesseract::PSM_SINGLE_BLOCK);
413    char *result = api_.GetUTF8Text();
414    delete[] result;
415    ResultIterator *r_it = api_.GetIterator();
416    do {
417      char *word_str = r_it->GetUTF8Text(tesseract::RIL_WORD);
418      if (word_str != nullptr) {
419        EXPECT_FALSE(r_it->Empty(tesseract::RIL_WORD));
420        EXPECT_FALSE(r_it->Empty(tesseract::RIL_SYMBOL));
421        ResultIterator s_it = *r_it;
422        do {
423          const char *char_str = s_it.GetUTF8Text(tesseract::RIL_SYMBOL);
424          CHECK(char_str != nullptr);
425          float confidence = s_it.Confidence(tesseract::RIL_SYMBOL);
426          LOG(INFO) << "Char " << char_str << " has confidence " << confidence << "\n";
427          delete[] char_str;
428        } while (!s_it.IsAtFinalElement(tesseract::RIL_WORD, tesseract::RIL_SYMBOL) &&
429                 s_it.Next(tesseract::RIL_SYMBOL));
430        delete[] word_str;
431      } else {
432        LOG(INFO) << "Empty word found"
433                  << "\n";
434      }
435    } while (r_it->Next(tesseract::RIL_WORD));
436    delete r_it;
437  }
438  } 
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-layout_test.cc</h3>
            <pre><code>1  #include <string>
2  #include <utility>
3  #include "include_gunit.h"
4  #include <allheaders.h>
5  #include <tesseract/baseapi.h>
6  #include <tesseract/resultiterator.h>
7  #include "coutln.h"
8  #include "log.h" 
9  #include "mutableiterator.h"
10  #include "ocrblock.h" 
11  #include "pageres.h"
12  #include "polyblk.h"
13  #include "stepblob.h"
14  namespace tesseract {
15  static const char *kPolyBlockNames[] = {
16      "Unknown",
17      "Flowing Text",
18      "Heading Text",
19      "Pullout Text",
20      "Equation",
21      "Inline Equation",
22      "Table",
23      "Vertical Text",
24      "Caption Text",
25      "Flowing Image",
26      "Heading Image",
27      "Pullout Image",
28      "Horizontal Line",
29      "Vertical Line",
30      "Noise",
31      "" 
32  };
33  const char *kStrings8087_054[] = {"dat", "Dalmatian", "", "DAMAGED DURING", "margarine,", nullptr};
34  const PolyBlockType kBlocks8087_054[] = {PT_HEADING_TEXT, PT_FLOWING_TEXT, PT_PULLOUT_IMAGE,
35                                           PT_CAPTION_TEXT, PT_FLOWING_TEXT};
36  class LayoutTest : public testing::Test {
37  protected:
38    std::string TestDataNameToPath(const std::string &name) {
39      return file::JoinPath(TESTING_DIR, "/" + name);
40    }
41    std::string TessdataPath() {
42      return file::JoinPath(TESSDATA_DIR, "");
43    }
44    LayoutTest() {
45      src_pix_ = nullptr;
46    }
47    ~LayoutTest() override {
48      src_pix_.destroy();
49    }
50    void SetImage(const char *filename, const char *lang) {
51      src_pix_.destroy();
52      src_pix_ = pixRead(TestDataNameToPath(filename).c_str());
53      api_.Init(TessdataPath().c_str(), lang, tesseract::OEM_TESSERACT_ONLY);
54      api_.SetPageSegMode(tesseract::PSM_AUTO);
55      api_.SetImage(src_pix_);
56    }
57    void VerifyBlockTextOrder(const char *strings[], const PolyBlockType *blocks,
58                              ResultIterator *it) {
59      it->Begin();
60      int string_index = 0;
61      int block_index = 0;
62      do {
63        char *block_text = it->GetUTF8Text(tesseract::RIL_BLOCK);
64        if (block_text != nullptr && it->BlockType() == blocks[string_index] &&
65            strstr(block_text, strings[string_index]) != nullptr) {
66          LOG(INFO) << "Found string " << strings[string_index] << " in block " << block_index
67                    << " of type " << kPolyBlockNames[blocks[string_index]] << "\n";
68          ++string_index;
69        } else if (it->BlockType() == blocks[string_index] && block_text == nullptr &&
70                   strings[string_index][0] == '\0') {
71          LOG(INFO) << "Found block of type " << kPolyBlockNames[blocks[string_index]] << " at block "
72                    << block_index << "\n";
73          ++string_index;
74        } else {
75          LOG(INFO) << "No match found in block with text:\n" << block_text;
76        }
77        delete[] block_text;
78        ++block_index;
79        if (strings[string_index] == nullptr) {
80          break;
81        }
82      } while (it->Next(tesseract::RIL_BLOCK));
83      EXPECT_TRUE(strings[string_index] == nullptr);
84    }
85    void VerifyRoughBlockOrder(bool right_to_left, ResultIterator *it) {
86      int prev_left = 0;
87      int prev_right = 0;
88      int prev_bottom = 0;
89      it->Begin();
90      do {
91        int left, top, right, bottom;
92        if (it->BoundingBox(tesseract::RIL_BLOCK, &left, &top, &right, &bottom) &&
93            PTIsTextType(it->BlockType()) && right - left > 800 && bottom - top > 200) {
94          if (prev_right > prev_left) {
95            if (std::min(right, prev_right) > std::max(left, prev_left)) {
96              EXPECT_GE(top, prev_bottom) << "Overlapping block should be below";
97            } else if (top < prev_bottom) {
98              if (right_to_left) {
99                EXPECT_GE(prev_left, right) << "Block should be to the left";
100              } else {
101                EXPECT_GE(left, prev_right) << "Block should be to the right";
102              }
103            }
104          }
105          prev_left = left;
106          prev_right = right;
107          prev_bottom = bottom;
108        }
109      } while (it->Next(tesseract::RIL_BLOCK));
110    }
111    void VerifyTotalContainment(int winding_target, MutableIterator *it) {
112      it->Begin();
113      do {
114        int left, top, right, bottom;
115        if (it->BoundingBox(tesseract::RIL_BLOCK, &left, &top, &right, &bottom) &&
116            PTIsTextType(it->BlockType()) && right - left > 800 && bottom - top > 200) {
117          const PAGE_RES_IT *pr_it = it->PageResIt();
118          POLY_BLOCK *pb = pr_it->block()->block->pdblk.poly_block();
119          CHECK(pb != nullptr);
120          FCOORD skew = pr_it->block()->block->skew();
121          EXPECT_GT(skew.x(), 0.0f);
122          EXPECT_GT(skew.y(), 0.0f);
123          MutableIterator word_it = *it;
124          do {
125            const PAGE_RES_IT *w_it = word_it.PageResIt();
126            C_BLOB_IT b_it(w_it->word()->word->cblob_list());
127            for (b_it.mark_cycle_pt(); !b_it.cycled_list(); b_it.forward()) {
128              C_BLOB *blob = b_it.data();
129              C_OUTLINE_IT ol_it(blob->out_list());
130              for (ol_it.mark_cycle_pt(); !ol_it.cycled_list(); ol_it.forward()) {
131                C_OUTLINE *ol = ol_it.data();
132                TBOX box = ol->bounding_box();
133                ICOORD middle((box.left() + box.right()) / 2, (box.top() + box.bottom()) / 2);
134                EXPECT_EQ(winding_target, pb->winding_number(middle));
135              }
136            }
137          } while (word_it.Next(tesseract::RIL_WORD) &&
138                   !word_it.IsAtBeginningOf(tesseract::RIL_BLOCK));
139        }
140      } while (it->Next(tesseract::RIL_BLOCK));
141    }
<span onclick='openModal()' class='match'>142    Image src_pix_;
143    std::string ocr_text_;
144    tesseract::TessBaseAPI api_;
145  };
146  TEST_F(LayoutTest, ArraySizeTest) {
</span>147    int size = 0;
148    for (size = 0; kPolyBlockNames[size][0] != '\0'; ++size) {
149      ;
150    }
151    EXPECT_EQ(size, PT_COUNT);
152  }
153  TEST_F(LayoutTest, UNLV8087_054) {
154    SetImage("8087_054.3B.tif", "eng");
155    EXPECT_EQ(api_.Recognize(nullptr), 0);
156    tesseract::ResultIterator *it = api_.GetIterator();
157    VerifyBlockTextOrder(kStrings8087_054, kBlocks8087_054, it);
158    delete it;
159  }
160  TEST_F(LayoutTest, HebrewOrderingAndSkew) {
161    SetImage("hebrew.png", "eng");
162    EXPECT_EQ(api_.Recognize(nullptr), 0);
163    tesseract::MutableIterator *it = api_.GetMutableIterator();
164    VerifyRoughBlockOrder(false, it);
165    VerifyTotalContainment(1, it);
166    delete it;
167    SetImage("hebrew.png", "heb");
168    EXPECT_EQ(api_.Recognize(nullptr), 0);
169    it = api_.GetMutableIterator();
170    VerifyRoughBlockOrder(true, it);
171    VerifyTotalContainment(-1, it);
172    delete it;
173  }
174  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-resultiterator_test.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-layout_test.cc</div>
                </div>
                <div class="column column_space"><pre><code>167    Image src_pix_; 
168    std::string ocr_text_;
169    tesseract::TessBaseAPI api_;
170  };
171  TEST_F(ResultIteratorTest, EasyTest) {
</pre></code></div>
                <div class="column column_space"><pre><code>142    Image src_pix_;
143    std::string ocr_text_;
144    tesseract::TessBaseAPI api_;
145  };
146  TEST_F(LayoutTest, ArraySizeTest) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    