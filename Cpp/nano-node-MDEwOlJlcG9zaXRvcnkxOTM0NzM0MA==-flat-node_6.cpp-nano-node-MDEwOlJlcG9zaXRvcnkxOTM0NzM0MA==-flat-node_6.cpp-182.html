
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 21, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-node_6.cpp</h3>
            <pre><code>1  #include &lt;nano/crypto_lib/random_pool.hpp&gt;
2  #include &lt;nano/lib/threading.hpp&gt;
3  #include &lt;nano/node/election.hpp&gt;
4  #include &lt;nano/node/scheduler/buckets.hpp&gt;
5  #include &lt;nano/node/scheduler/component.hpp&gt;
6  #include &lt;nano/node/transport/inproc.hpp&gt;
7  #include &lt;nano/node/unchecked_map.hpp&gt;
8  #include &lt;nano/test_common/network.hpp&gt;
9  #include &lt;nano/test_common/system.hpp&gt;
10  #include &lt;nano/test_common/testutil.hpp&gt;
11  #include &lt;gtest/gtest.h&gt;
12  #include &lt;boost/format.hpp&gt;
13  #include &lt;boost/unordered_set.hpp&gt;
14  #include &lt;numeric&gt;
15  #include &lt;random&gt;
16  using namespace std::chrono_literals;
17  size_t manually_count_pruned_blocks (nano::store &amp; store)
18  {
19  	size_t count = 0;
20  	auto transaction = store.tx_begin_read ();
21  	auto i = store.pruned.begin (transaction);
22  	for (; i != store.pruned.end (); ++i)
23  	{
24  		++count;
25  	}
26  	return count;
27  }
28  TEST (system, generate_mass_activity)
29  {
30  	nano::test::system system;
31  	nano::node_config node_config = system.default_config ();
32  	node_config.enable_voting = false; 
33  	auto node = system.add_node (node_config);
34  	system.wallet (0)-&gt;insert_adhoc (nano::dev::genesis_key.prv);
<span onclick='openModal()' class='match'>35  	uint32_t count (20);
36  	system.generate_mass_activity (count, *system.nodes[0]);
37  	auto transaction (system.nodes[0]-&gt;store.tx_begin_read ());
</span>38  	for (auto i (system.nodes[0]-&gt;store.account.begin (transaction)), n (system.nodes[0]-&gt;store.account.end ()); i != n; ++i)
39  	{
40  	}
41  }
42  TEST (system, generate_mass_activity_long)
43  {
44  	nano::test::system system;
45  	nano::node_config node_config = system.default_config ();
46  	node_config.enable_voting = false; 
47  	auto node = system.add_node (node_config);
48  	nano::thread_runner runner (system.io_ctx, system.nodes[0]-&gt;config.io_threads);
49  	system.wallet (0)-&gt;insert_adhoc (nano::dev::genesis_key.prv);
50  	uint32_t count (1000000);
51  	auto count_env_var = std::getenv (&quot;SLOW_TEST_SYSTEM_GENERATE_MASS_ACTIVITY_LONG_COUNT&quot;);
52  	if (count_env_var)
53  	{
54  		count = boost::lexical_cast&lt;uint32_t&gt; (count_env_var);
55  		std::cout &lt;&lt; &quot;count override due to env variable set, count=&quot; &lt;&lt; count &lt;&lt; std::endl;
56  	}
57  	system.generate_mass_activity (count, *system.nodes[0]);
58  	auto transaction (system.nodes[0]-&gt;store.tx_begin_read ());
59  	for (auto i (system.nodes[0]-&gt;store.account.begin (transaction)), n (system.nodes[0]-&gt;store.account.end ()); i != n; ++i)
60  	{
61  	}
62  	system.stop ();
63  	runner.join ();
64  }
65  TEST (system, receive_while_synchronizing)
66  {
67  	std::vector&lt;boost::thread&gt; threads;
68  	{
69  		nano::test::system system;
70  		nano::node_config node_config = system.default_config ();
71  		node_config.enable_voting = false; 
72  		auto node = system.add_node (node_config);
73  		nano::thread_runner runner (system.io_ctx, system.nodes[0]-&gt;config.io_threads);
74  		system.wallet (0)-&gt;insert_adhoc (nano::dev::genesis_key.prv);
75  		uint32_t count (1000);
76  		system.generate_mass_activity (count, *system.nodes[0]);
77  		nano::keypair key;
78  		auto node1 (std::make_shared&lt;nano::node&gt; (system.io_ctx, system.get_available_port (), nano::unique_path (), system.logging, system.work));
79  		ASSERT_FALSE (node1-&gt;init_error ());
80  		auto wallet (node1-&gt;wallets.create (1));
81  		wallet-&gt;insert_adhoc (nano::dev::genesis_key.prv); 
82  		ASSERT_EQ (key.pub, wallet-&gt;insert_adhoc (key.prv));
83  		node1-&gt;start ();
84  		system.nodes.push_back (node1);
85  		ASSERT_NE (nullptr, nano::test::establish_tcp (system, *node1, node-&gt;network.endpoint ()));
86  		node1-&gt;workers.add_timed_task (std::chrono::steady_clock::now () + std::chrono::milliseconds (200), ([&amp;system, &amp;key] () {
87  			auto hash (system.wallet (0)-&gt;send_sync (nano::dev::genesis_key.pub, key.pub, system.nodes[0]-&gt;config.receive_minimum.number ()));
88  			auto transaction (system.nodes[0]-&gt;store.tx_begin_read ());
89  			auto block (system.nodes[0]-&gt;store.block.get (transaction, hash));
90  			std::string block_text;
91  			block-&gt;serialize_json (block_text);
92  		}));
93  		ASSERT_TIMELY (10s, !node1-&gt;balance (key.pub).is_zero ());
94  		node1-&gt;stop ();
95  		system.stop ();
96  		runner.join ();
97  	}
98  	for (auto i (threads.begin ()), n (threads.end ()); i != n; ++i)
99  	{
100  		i-&gt;join ();
101  	}
102  }
103  TEST (ledger, deep_account_compute)
104  {
105  	nano::logger_mt logger;
106  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
107  	ASSERT_FALSE (store-&gt;init_error ());
108  	nano::stats stats;
109  	nano::ledger ledger (*store, stats, nano::dev::constants);
110  	auto transaction (store-&gt;tx_begin_write ());
111  	store-&gt;initialize (transaction, ledger.cache, ledger.constants);
112  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits&lt;unsigned&gt;::max () };
113  	nano::keypair key;
114  	auto balance (nano::dev::constants.genesis_amount - 1);
115  	nano::block_builder builder;
116  	auto send = builder
117  				.send ()
118  				.previous (nano::dev::genesis-&gt;hash ())
119  				.destination (key.pub)
120  				.balance (balance)
121  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
122  				.work (*pool.generate (nano::dev::genesis-&gt;hash ()))
123  				.build ();
124  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send).code);
125  	auto open = builder
126  				.open ()
127  				.source (send-&gt;hash ())
128  				.representative (nano::dev::genesis_key.pub)
129  				.account (key.pub)
130  				.sign (key.prv, key.pub)
131  				.work (*pool.generate (key.pub))
132  				.build ();
133  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *open).code);
134  	auto sprevious (send-&gt;hash ());
135  	auto rprevious (open-&gt;hash ());
136  	for (auto i (0), n (100000); i != n; ++i)
137  	{
138  		balance -= 1;
139  		auto send = builder
140  					.send ()
141  					.previous (sprevious)
142  					.destination (key.pub)
143  					.balance (balance)
144  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
145  					.work (*pool.generate (sprevious))
146  					.build ();
147  		ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send).code);
148  		sprevious = send-&gt;hash ();
149  		auto receive = builder
150  					   .receive ()
151  					   .previous (rprevious)
152  					   .source (send-&gt;hash ())
153  					   .sign (key.prv, key.pub)
154  					   .work (*pool.generate (rprevious))
155  					   .build ();
156  		ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *receive).code);
157  		rprevious = receive-&gt;hash ();
158  		if (i % 100 == 0)
159  		{
160  			std::cerr &lt;&lt; i &lt;&lt; &#x27; &#x27;;
161  		}
162  		ledger.account (transaction, sprevious);
163  		ledger.balance (transaction, rprevious);
164  	}
165  }
166  TEST (wallet, multithreaded_send_async)
167  {
168  	std::vector&lt;boost::thread&gt; threads;
169  	{
170  		nano::test::system system (1);
171  		nano::keypair key;
172  		auto wallet_l (system.wallet (0));
173  		wallet_l-&gt;insert_adhoc (nano::dev::genesis_key.prv);
174  		wallet_l-&gt;insert_adhoc (key.prv);
175  		int num_of_threads = 20;
176  		int num_of_sends = 1000;
177  		for (auto i (0); i &lt; num_of_threads; ++i)
178  		{
179  			threads.push_back (boost::thread ([wallet_l, &amp;key, num_of_threads, num_of_sends] () {
180  				for (auto i (0); i &lt; num_of_sends; ++i)
181  				{
182  					wallet_l-&gt;send_async (nano::dev::genesis_key.pub, key.pub, 1000, [] (std::shared_ptr&lt;nano::block&gt; const &amp; block_a) {
183  						ASSERT_FALSE (block_a == nullptr);
184  						ASSERT_FALSE (block_a-&gt;hash ().is_zero ());
185  					});
186  				}
187  			}));
188  		}
189  		ASSERT_TIMELY (1000s, system.nodes[0]-&gt;balance (nano::dev::genesis_key.pub) == (nano::dev::constants.genesis_amount - num_of_threads * num_of_sends * 1000));
190  	}
191  	for (auto i (threads.begin ()), n (threads.end ()); i != n; ++i)
192  	{
193  		i-&gt;join ();
194  	}
195  }
196  TEST (store, load)
197  {
198  	nano::test::system system (1);
199  	std::vector&lt;boost::thread&gt; threads;
200  	for (auto i (0); i &lt; 100; ++i)
201  	{
202  		threads.push_back (boost::thread ([&amp;system] () {
203  			for (auto i (0); i != 1000; ++i)
204  			{
205  				auto transaction (system.nodes[0]-&gt;store.tx_begin_write ());
206  				for (auto j (0); j != 10; ++j)
207  				{
208  					nano::account account;
209  					nano::random_pool::generate_block (account.bytes.data (), account.bytes.size ());
210  					system.nodes[0]-&gt;store.confirmation_height.put (transaction, account, { 0, nano::block_hash (0) });
211  					system.nodes[0]-&gt;store.account.put (transaction, account, nano::account_info ());
212  				}
213  			}
214  		}));
215  	}
216  	for (auto &amp; i : threads)
217  	{
218  		i.join ();
219  	}
220  }
221  namespace nano
222  {
223  TEST (node, fork_storm)
224  {
225  	static const auto node_count (23);
226  	nano::node_flags flags;
227  	flags.disable_max_peers_per_ip = true;
228  	nano::test::system system (node_count, nano::transport::transport_type::tcp, flags);
229  	system.wallet (0)-&gt;insert_adhoc (nano::dev::genesis_key.prv);
230  	auto previous (system.nodes[0]-&gt;latest (nano::dev::genesis_key.pub));
231  	auto balance (system.nodes[0]-&gt;balance (nano::dev::genesis_key.pub));
232  	ASSERT_FALSE (previous.is_zero ());
233  	nano::block_builder builder;
234  	for (auto node_j : system.nodes)
235  	{
236  		balance -= 1;
237  		nano::keypair key;
238  		auto send = builder
239  					.send ()
240  					.previous (previous)
241  					.destination (key.pub)
242  					.balance (balance)
243  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
244  					.work (0)
245  					.build ();
246  		node_j-&gt;work_generate_blocking (*send);
247  		previous = send-&gt;hash ();
248  		for (auto node_i : system.nodes)
249  		{
250  			auto send_result (node_i-&gt;process (*send));
251  			ASSERT_EQ (nano::process_result::progress, send_result.code);
252  			nano::keypair rep;
253  			auto open = builder
254  						.open ()
255  						.source (previous)
256  						.representative (rep.pub)
257  						.account (key.pub)
258  						.sign (key.prv, key.pub)
259  						.work (0)
260  						.build_shared ();
261  			node_i-&gt;work_generate_blocking (*open);
262  			auto open_result (node_i-&gt;process (*open));
263  			ASSERT_EQ (nano::process_result::progress, open_result.code);
264  			auto transaction (node_i-&gt;store.tx_begin_read ());
265  			node_i-&gt;network.flood_block (open);
266  		}
267  	}
268  	auto again (true);
269  	int iteration (0);
270  	auto old_empty (0);
271  	auto old_single (0);
272  	auto stall_count (0);
273  	while (again)
274  	{
275  		auto empty = 0;
276  		auto single = 0;
277  		std::for_each (system.nodes.begin (), system.nodes.end (), [&amp;] (std::shared_ptr&lt;nano::node&gt; const &amp; node_a) {
278  			if (node_a-&gt;active.empty ())
279  			{
280  				++empty;
281  			}
282  			else
283  			{
284  				nano::unique_lock&lt;nano::mutex&gt; lock{ node_a-&gt;active.mutex };
285  				auto election = node_a-&gt;active.roots.begin ()-&gt;election;
286  				lock.unlock ();
287  				if (election-&gt;votes ().size () == 1)
288  				{
289  					++single;
290  				}
291  			}
292  		});
293  		ASSERT_NO_ERROR (system.poll ());
294  		if (old_empty == empty &amp;&amp; old_single == single)
295  		{
296  			static const auto stall_tolerance (100000);
297  			++stall_count;
298  			ASSERT_LE (stall_count, stall_tolerance) &lt;&lt; &quot;Stall deteceted. These values were both expected to eventually reach 0 but have remained unchanged for &quot; &lt;&lt; stall_tolerance &lt;&lt; &quot; iterations. Empty: &quot; &lt;&lt; empty &lt;&lt; &quot; single: &quot; &lt;&lt; single &lt;&lt; std::endl;
299  		}
300  		else
301  		{
302  			stall_count = 0;
303  			old_empty = empty;
304  			old_single = single;
305  		}
306  		again = (empty != 0) || (single != 0);
307  		++iteration;
308  	}
309  	ASSERT_TRUE (true);
310  }
311  } 
312  namespace
313  {
314  size_t heard_count (std::vector&lt;uint8_t&gt; const &amp; nodes)
315  {
316  	auto result (0);
317  	for (auto i (nodes.begin ()), n (nodes.end ()); i != n; ++i)
318  	{
319  		switch (*i)
320  		{
321  			case 0:
322  				break;
323  			case 1:
324  				++result;
325  				break;
326  			case 2:
327  				++result;
328  				break;
329  		}
330  	}
331  	return result;
332  }
333  }
334  TEST (broadcast, world_broadcast_simulate)
335  {
336  	auto node_count (10000);
337  	std::vector&lt;uint8_t&gt; nodes;
338  	nodes.resize (node_count, 0);
339  	nodes[0] = 1;
340  	auto any_changed (true);
341  	auto message_count (0);
342  	while (any_changed)
343  	{
344  		any_changed = false;
345  		for (auto i (nodes.begin ()), n (nodes.end ()); i != n; ++i)
346  		{
347  			switch (*i)
348  			{
349  				case 0:
350  					break;
351  				case 1:
352  					for (auto j (nodes.begin ()), m (nodes.end ()); j != m; ++j)
353  					{
354  						++message_count;
355  						switch (*j)
356  						{
357  							case 0:
358  								*j = 1;
359  								any_changed = true;
360  								break;
361  							case 1:
362  								break;
363  							case 2:
364  								break;
365  						}
366  					}
367  					*i = 2;
368  					any_changed = true;
369  					break;
370  				case 2:
371  					break;
372  				default:
373  					ASSERT_FALSE (true);
374  					break;
375  			}
376  		}
377  	}
378  	auto count (heard_count (nodes));
379  	(void)count;
380  }
381  TEST (broadcast, sqrt_broadcast_simulate)
382  {
383  	auto node_count (10000);
384  	auto broadcast_count (std::ceil (std::sqrt (node_count)));
385  	std::vector&lt;uint8_t&gt; nodes;
386  	nodes.resize (node_count, 0);
387  	nodes[0] = 1;
388  	auto any_changed (true);
389  	uint64_t message_count (0);
390  	while (any_changed)
391  	{
392  		any_changed = false;
393  		for (auto i (nodes.begin ()), n (nodes.end ()); i != n; ++i)
394  		{
395  			switch (*i)
396  			{
397  				case 0:
398  					break;
399  				case 1:
400  					for (auto j (0); j != broadcast_count; ++j)
401  					{
402  						++message_count;
403  						auto entry (nano::random_pool::generate_word32 (0, node_count - 1));
404  						switch (nodes[entry])
405  						{
406  							case 0:
407  								nodes[entry] = 1;
408  								any_changed = true;
409  								break;
410  							case 1:
411  								break;
412  							case 2:
413  								break;
414  						}
415  					}
416  					*i = 2;
417  					any_changed = true;
418  					break;
419  				case 2:
420  					break;
421  				default:
422  					ASSERT_FALSE (true);
423  					break;
424  			}
425  		}
426  	}
427  	auto count (heard_count (nodes));
428  	(void)count;
429  }
430  TEST (peer_container, random_set)
431  {
432  	nano::test::system system (1);
433  	auto old (std::chrono::steady_clock::now ());
434  	auto current (std::chrono::steady_clock::now ());
435  	for (auto i (0); i &lt; 10000; ++i)
436  	{
437  		auto list (system.nodes[0]-&gt;network.random_set (15));
438  	}
439  	auto end (std::chrono::steady_clock::now ());
440  	(void)end;
441  	auto old_ms (std::chrono::duration_cast&lt;std::chrono::milliseconds&gt; (current - old));
442  	(void)old_ms;
443  	auto new_ms (std::chrono::duration_cast&lt;std::chrono::milliseconds&gt; (end - current));
444  	(void)new_ms;
445  }
446  TEST (store, unchecked_load)
447  {
448  	nano::test::system system{ 1 };
449  	auto &amp; node = *system.nodes[0];
450  	nano::block_builder builder;
451  	std::shared_ptr&lt;nano::block&gt; block = builder
452  										 .send ()
453  										 .previous (0)
454  										 .destination (0)
455  										 .balance (0)
456  										 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
457  										 .work (0)
458  										 .build_shared ();
459  	constexpr auto num_unchecked = 1&#x27;000&#x27;000;
460  	for (auto i (0); i &lt; num_unchecked; ++i)
461  	{
462  		node.unchecked.put (i, block);
463  	}
464  	ASSERT_TIMELY (8000s, num_unchecked == node.unchecked.count ());
465  }
466  TEST (store, vote_load)
467  {
468  	nano::test::system system{ 1 };
469  	auto &amp; node = *system.nodes[0];
470  	for (auto i = 0u; i &lt; 1000000u; ++i)
471  	{
472  		auto vote = std::make_shared&lt;nano::vote&gt; (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, i, 0, std::vector&lt;nano::block_hash&gt;{ i });
473  		node.vote_processor.vote (vote, std::make_shared&lt;nano::transport::inproc::channel&gt; (node, node));
474  	}
475  }
476  TEST (store, pruned_load)
477  {
478  	nano::logger_mt logger;
479  	auto path (nano::unique_path ());
480  	constexpr auto num_pruned = 2000000;
481  	auto const expected_result = num_pruned / 2;
482  	constexpr auto batch_size = 20;
483  	boost::unordered_set&lt;nano::block_hash&gt; hashes;
484  	{
485  		auto store = nano::make_store (logger, path, nano::dev::constants);
486  		ASSERT_FALSE (store-&gt;init_error ());
487  		for (auto i (0); i &lt; num_pruned / batch_size; ++i)
488  		{
489  			{
490  				auto transaction (store-&gt;tx_begin_write ());
491  				for (auto k (0); k &lt; batch_size; ++k)
492  				{
493  					nano::block_hash random_hash;
494  					nano::random_pool::generate_block (random_hash.bytes.data (), random_hash.bytes.size ());
495  					store-&gt;pruned.put (transaction, random_hash);
496  					hashes.insert (random_hash);
497  				}
498  			}
499  			{
500  				auto transaction (store-&gt;tx_begin_write ());
501  				for (auto k (0); !hashes.empty () &amp;&amp; k &lt; batch_size / 2; ++k)
502  				{
503  					auto hash (hashes.begin ());
504  					store-&gt;pruned.del (transaction, *hash);
505  					hashes.erase (hash);
506  				}
507  			}
508  		}
509  		ASSERT_EQ (expected_result, manually_count_pruned_blocks (*store));
510  	}
511  	{
512  		auto store = nano::make_store (logger, path, nano::dev::constants);
513  		ASSERT_FALSE (store-&gt;init_error ());
514  		ASSERT_EQ (expected_result, manually_count_pruned_blocks (*store));
515  	}
516  }
517  TEST (wallets, rep_scan)
518  {
519  	nano::test::system system (1);
520  	auto &amp; node (*system.nodes[0]);
521  	auto wallet (system.wallet (0));
522  	{
523  		auto transaction (node.wallets.tx_begin_write ());
524  		for (auto i (0); i &lt; 10000; ++i)
525  		{
526  			wallet-&gt;deterministic_insert (transaction);
527  		}
528  	}
529  	auto begin (std::chrono::steady_clock::now ());
530  	node.wallets.foreach_representative ([] (nano::public_key const &amp; pub_a, nano::raw_key const &amp; prv_a) {
531  	});
532  	ASSERT_LT (std::chrono::steady_clock::now () - begin, std::chrono::milliseconds (5));
533  }
534  TEST (node, mass_vote_by_hash)
535  {
536  	nano::test::system system (1);
537  	system.wallet (0)-&gt;insert_adhoc (nano::dev::genesis_key.prv);
538  	nano::block_hash previous (nano::dev::genesis-&gt;hash ());
539  	nano::keypair key;
540  	std::vector&lt;std::shared_ptr&lt;nano::state_block&gt;&gt; blocks;
541  	nano::block_builder builder;
542  	for (auto i (0); i &lt; 10000; ++i)
543  	{
544  		auto block = builder
545  					 .state ()
546  					 .account (nano::dev::genesis_key.pub)
547  					 .previous (previous)
548  					 .representative (nano::dev::genesis_key.pub)
549  					 .balance (nano::dev::constants.genesis_amount - (i + 1) * nano::Gxrb_ratio)
550  					 .link (key.pub)
551  					 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
552  					 .work (*system.work.generate (previous))
553  					 .build_shared ();
554  		previous = block-&gt;hash ();
555  		blocks.push_back (block);
556  	}
557  	for (auto i (blocks.begin ()), n (blocks.end ()); i != n; ++i)
558  	{
559  		system.nodes[0]-&gt;block_processor.add (*i);
560  	}
561  }
562  namespace nano
563  {
564  TEST (confirmation_height, many_accounts_single_confirmation)
565  {
566  	nano::test::system system;
567  	nano::node_config node_config = system.default_config ();
568  	node_config.online_weight_minimum = 100;
569  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
570  	auto node = system.add_node (node_config);
571  	system.wallet (0)-&gt;insert_adhoc (nano::dev::genesis_key.prv);
572  	node-&gt;confirmation_height_processor.batch_write_size = 500;
573  	auto const num_accounts = nano::confirmation_height::unbounded_cutoff * 2 + 50;
574  	nano::keypair last_keypair = nano::dev::genesis_key;
575  	nano::block_builder builder;
576  	auto last_open_hash = node-&gt;latest (nano::dev::genesis_key.pub);
577  	{
578  		auto transaction = node-&gt;store.tx_begin_write ();
579  		for (auto i = num_accounts - 1; i &gt; 0; --i)
580  		{
581  			nano::keypair key;
582  			system.wallet (0)-&gt;insert_adhoc (key.prv);
583  			auto send = builder
584  						.send ()
585  						.previous (last_open_hash)
586  						.destination (key.pub)
587  						.balance (node-&gt;online_reps.delta ())
588  						.sign (last_keypair.prv, last_keypair.pub)
589  						.work (*system.work.generate (last_open_hash))
590  						.build ();
591  			ASSERT_EQ (nano::process_result::progress, node-&gt;ledger.process (transaction, *send).code);
592  			auto open = builder
593  						.open ()
594  						.source (send-&gt;hash ())
595  						.representative (last_keypair.pub)
596  						.account (key.pub)
597  						.sign (key.prv, key.pub)
598  						.work (*system.work.generate (key.pub))
599  						.build ();
600  			ASSERT_EQ (nano::process_result::progress, node-&gt;ledger.process (transaction, *open).code);
601  			last_open_hash = open-&gt;hash ();
602  			last_keypair = key;
603  		}
604  	}
605  	{
606  		auto block = node-&gt;block (last_open_hash);
607  		ASSERT_NE (nullptr, block);
608  		node-&gt;scheduler.buckets.manual (block);
609  		std::shared_ptr&lt;nano::election&gt; election;
610  		ASSERT_TIMELY (10s, (election = node-&gt;active.election (block-&gt;qualified_root ())) != nullptr);
611  		election-&gt;force_confirm ();
612  	}
613  	ASSERT_TIMELY (120s, node-&gt;ledger.block_confirmed (node-&gt;store.tx_begin_read (), last_open_hash));
614  	auto transaction = node-&gt;store.tx_begin_read ();
615  	for (auto i (node-&gt;store.account.begin (transaction)), n (node-&gt;store.account.end ()); i != n; ++i)
616  	{
617  		auto &amp; account = i-&gt;first;
618  		auto &amp; account_info = i-&gt;second;
619  		auto count = (account != last_keypair.pub) ? 2 : 1;
620  		nano::confirmation_height_info confirmation_height_info;
621  		ASSERT_FALSE (node-&gt;store.confirmation_height.get (transaction, account, confirmation_height_info));
622  		ASSERT_EQ (count, confirmation_height_info.height);
623  		ASSERT_EQ (count, account_info.block_count);
624  	}
625  	size_t cemented_count = 0;
626  	for (auto i (node-&gt;ledger.store.confirmation_height.begin (transaction)), n (node-&gt;ledger.store.confirmation_height.end ()); i != n; ++i)
627  	{
628  		cemented_count += i-&gt;second.height;
629  	}
630  	ASSERT_EQ (cemented_count, node-&gt;ledger.cache.cemented_count);
631  	ASSERT_EQ (node-&gt;ledger.stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed, nano::stat::dir::in), num_accounts * 2 - 2);
632  	ASSERT_EQ (node-&gt;ledger.stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed_bounded, nano::stat::dir::in), num_accounts * 2 - 2);
633  	ASSERT_EQ (node-&gt;ledger.stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed_unbounded, nano::stat::dir::in), 0);
634  	ASSERT_TIMELY (40s, (node-&gt;ledger.cache.cemented_count - 1) == node-&gt;stats.count (nano::stat::type::confirmation_observer, nano::stat::detail::all, nano::stat::dir::out));
635  	ASSERT_TIMELY (10s, node-&gt;active.election_winner_details_size () == 0);
636  }
637  TEST (confirmation_height, many_accounts_many_confirmations)
638  {
639  	nano::test::system system;
640  	nano::node_config node_config = system.default_config ();
641  	node_config.online_weight_minimum = 100;
642  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
643  	auto node = system.add_node (node_config);
644  	system.wallet (0)-&gt;insert_adhoc (nano::dev::genesis_key.prv);
645  	node-&gt;confirmation_height_processor.batch_write_size = 500;
646  	auto const num_accounts = nano::confirmation_height::unbounded_cutoff * 2 + 50;
647  	auto latest_genesis = node-&gt;latest (nano::dev::genesis_key.pub);
648  	nano::block_builder builder;
649  	std::vector&lt;std::shared_ptr&lt;nano::open_block&gt;&gt; open_blocks;
650  	{
651  		auto transaction = node-&gt;store.tx_begin_write ();
652  		for (auto i = num_accounts - 1; i &gt; 0; --i)
653  		{
654  			nano::keypair key;
655  			system.wallet (0)-&gt;insert_adhoc (key.prv);
656  			auto send = builder
657  						.send ()
658  						.previous (latest_genesis)
659  						.destination (key.pub)
660  						.balance (node-&gt;online_reps.delta ())
661  						.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
662  						.work (*system.work.generate (latest_genesis))
663  						.build ();
664  			ASSERT_EQ (nano::process_result::progress, node-&gt;ledger.process (transaction, *send).code);
665  			auto open = builder
666  						.open ()
667  						.source (send-&gt;hash ())
668  						.representative (nano::dev::genesis_key.pub)
669  						.account (key.pub)
670  						.sign (key.prv, key.pub)
671  						.work (*system.work.generate (key.pub))
672  						.build_shared ();
673  			ASSERT_EQ (nano::process_result::progress, node-&gt;ledger.process (transaction, *open).code);
674  			open_blocks.push_back (std::move (open));
675  			latest_genesis = send-&gt;hash ();
676  		}
677  	}
678  	for (auto &amp; open_block : open_blocks)
679  	{
680  		node-&gt;scheduler.buckets.manual (open_block);
681  		std::shared_ptr&lt;nano::election&gt; election;
682  		ASSERT_TIMELY (10s, (election = node-&gt;active.election (open_block-&gt;qualified_root ())) != nullptr);
683  		election-&gt;force_confirm ();
684  	}
685  	auto const num_blocks_to_confirm = (num_accounts - 1) * 2;
686  	ASSERT_TIMELY (1500s, node-&gt;stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed, nano::stat::dir::in) == num_blocks_to_confirm);
687  	auto num_confirmed_bounded = node-&gt;ledger.stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed_bounded, nano::stat::dir::in);
688  	ASSERT_GE (num_confirmed_bounded, nano::confirmation_height::unbounded_cutoff);
689  	ASSERT_EQ (node-&gt;ledger.stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed_unbounded, nano::stat::dir::in), num_blocks_to_confirm - num_confirmed_bounded);
690  	ASSERT_TIMELY (60s, (node-&gt;ledger.cache.cemented_count - 1) == node-&gt;stats.count (nano::stat::type::confirmation_observer, nano::stat::detail::all, nano::stat::dir::out));
691  	auto transaction = node-&gt;store.tx_begin_read ();
692  	size_t cemented_count = 0;
693  	for (auto i (node-&gt;ledger.store.confirmation_height.begin (transaction)), n (node-&gt;ledger.store.confirmation_height.end ()); i != n; ++i)
694  	{
695  		cemented_count += i-&gt;second.height;
696  	}
697  	ASSERT_EQ (num_blocks_to_confirm + 1, cemented_count);
698  	ASSERT_EQ (cemented_count, node-&gt;ledger.cache.cemented_count);
699  	ASSERT_TIMELY (20s, (node-&gt;ledger.cache.cemented_count - 1) == node-&gt;stats.count (nano::stat::type::confirmation_observer, nano::stat::detail::all, nano::stat::dir::out));
700  	ASSERT_TIMELY (10s, node-&gt;active.election_winner_details_size () == 0);
701  }
702  TEST (confirmation_height, long_chains)
703  {
704  	nano::test::system system;
705  	nano::node_config node_config = system.default_config ();
706  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
707  	auto node = system.add_node (node_config);
708  	nano::keypair key1;
709  	system.wallet (0)-&gt;insert_adhoc (nano::dev::genesis_key.prv);
710  	nano::block_hash latest (node-&gt;latest (nano::dev::genesis_key.pub));
711  	system.wallet (0)-&gt;insert_adhoc (key1.prv);
712  	node-&gt;confirmation_height_processor.batch_write_size = 500;
713  	auto const num_blocks = nano::confirmation_height::unbounded_cutoff * 2 + 50;
714  	nano::block_builder builder;
715  	auto send = builder
716  				.send ()
717  				.previous (latest)
718  				.destination (key1.pub)
719  				.balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio + num_blocks + 1)
720  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
721  				.work (*system.work.generate (latest))
722  				.build ();
723  	auto open = builder
724  				.open ()
725  				.source (send-&gt;hash ())
726  				.representative (nano::dev::genesis-&gt;account ())
727  				.account (key1.pub)
728  				.sign (key1.prv, key1.pub)
729  				.work (*system.work.generate (key1.pub))
730  				.build ();
731  	{
732  		auto transaction = node-&gt;store.tx_begin_write ();
733  		ASSERT_EQ (nano::process_result::progress, node-&gt;ledger.process (transaction, *send).code);
734  		ASSERT_EQ (nano::process_result::progress, node-&gt;ledger.process (transaction, *open).code);
735  	}
736  	auto previous_genesis_chain_hash = send-&gt;hash ();
737  	auto previous_destination_chain_hash = open-&gt;hash ();
738  	{
739  		auto transaction = node-&gt;store.tx_begin_write ();
740  		for (auto i = num_blocks - 1; i &gt; 0; --i)
741  		{
742  			auto send = builder
743  						.send ()
744  						.previous (previous_genesis_chain_hash)
745  						.destination (key1.pub)
746  						.balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio + i + 1)
747  						.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
748  						.work (*system.work.generate (previous_genesis_chain_hash))
749  						.build ();
750  			ASSERT_EQ (nano::process_result::progress, node-&gt;ledger.process (transaction, *send).code);
751  			auto receive = builder
752  						   .receive ()
753  						   .previous (previous_destination_chain_hash)
754  						   .source (send-&gt;hash ())
755  						   .sign (key1.prv, key1.pub)
756  						   .work (*system.work.generate (previous_destination_chain_hash))
757  						   .build ();
758  			ASSERT_EQ (nano::process_result::progress, node-&gt;ledger.process (transaction, *receive).code);
759  			previous_genesis_chain_hash = send-&gt;hash ();
760  			previous_destination_chain_hash = receive-&gt;hash ();
761  		}
762  	}
763  	auto send1 = builder
764  				 .send ()
765  				 .previous (previous_destination_chain_hash)
766  				 .destination (nano::dev::genesis_key.pub)
767  				 .balance (nano::Gxrb_ratio - 2)
768  				 .sign (key1.prv, key1.pub)
769  				 .work (*system.work.generate (previous_destination_chain_hash))
770  				 .build ();
771  	auto receive1 = builder
772  					.state ()
773  					.account (nano::dev::genesis_key.pub)
774  					.previous (previous_genesis_chain_hash)
775  					.representative (nano::dev::genesis-&gt;account ())
776  					.balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio + 1)
777  					.link (send1-&gt;hash ())
778  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
779  					.work (*system.work.generate (previous_genesis_chain_hash))
780  					.build_shared ();
781  	nano::keypair key2;
782  	auto send2 = builder
783  				 .state ()
784  				 .account (nano::dev::genesis-&gt;account ())
785  				 .previous (receive1-&gt;hash ())
786  				 .representative (nano::dev::genesis-&gt;account ())
787  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
788  				 .link (key2.pub)
789  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
790  				 .work (*system.work.generate (receive1-&gt;hash ()))
791  				 .build ();
792  	{
793  		auto transaction = node-&gt;store.tx_begin_write ();
794  		ASSERT_EQ (nano::process_result::progress, node-&gt;ledger.process (transaction, *send1).code);
795  		ASSERT_EQ (nano::process_result::progress, node-&gt;ledger.process (transaction, *receive1).code);
796  		ASSERT_EQ (nano::process_result::progress, node-&gt;ledger.process (transaction, *send2).code);
797  	}
798  	{
799  		node-&gt;scheduler.buckets.manual (receive1);
800  		std::shared_ptr&lt;nano::election&gt; election;
801  		ASSERT_TIMELY (10s, (election = node-&gt;active.election (receive1-&gt;qualified_root ())) != nullptr);
802  		election-&gt;force_confirm ();
803  	}
804  	ASSERT_TIMELY (30s, node-&gt;ledger.block_confirmed (node-&gt;store.tx_begin_read (), receive1-&gt;hash ()));
805  	auto transaction (node-&gt;store.tx_begin_read ());
806  	auto info = node-&gt;ledger.account_info (transaction, nano::dev::genesis_key.pub);
807  	ASSERT_TRUE (info);
808  	nano::confirmation_height_info confirmation_height_info;
809  	ASSERT_FALSE (node-&gt;store.confirmation_height.get (transaction, nano::dev::genesis_key.pub, confirmation_height_info));
810  	ASSERT_EQ (num_blocks + 2, confirmation_height_info.height);
811  	ASSERT_EQ (num_blocks + 3, info-&gt;block_count); 
812  	info = node-&gt;ledger.account_info (transaction, key1.pub);
813  	ASSERT_TRUE (info);
814  	ASSERT_FALSE (node-&gt;store.confirmation_height.get (transaction, key1.pub, confirmation_height_info));
815  	ASSERT_EQ (num_blocks + 1, confirmation_height_info.height);
816  	ASSERT_EQ (num_blocks + 1, info-&gt;block_count);
817  	size_t cemented_count = 0;
818  	for (auto i (node-&gt;ledger.store.confirmation_height.begin (transaction)), n (node-&gt;ledger.store.confirmation_height.end ()); i != n; ++i)
819  	{
820  		cemented_count += i-&gt;second.height;
821  	}
822  	ASSERT_EQ (cemented_count, node-&gt;ledger.cache.cemented_count);
823  	ASSERT_EQ (node-&gt;ledger.stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed, nano::stat::dir::in), num_blocks * 2 + 2);
824  	ASSERT_EQ (node-&gt;ledger.stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed_bounded, nano::stat::dir::in), num_blocks * 2 + 2);
825  	ASSERT_EQ (node-&gt;ledger.stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed_unbounded, nano::stat::dir::in), 0);
826  	ASSERT_TIMELY (40s, (node-&gt;ledger.cache.cemented_count - 1) == node-&gt;stats.count (nano::stat::type::confirmation_observer, nano::stat::detail::all, nano::stat::dir::out));
827  	ASSERT_TIMELY (10s, node-&gt;active.election_winner_details_size () == 0);
828  }
829  TEST (confirmation_height, dynamic_algorithm)
830  {
831  	nano::test::system system;
832  	nano::node_config node_config = system.default_config ();
833  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
834  	auto node = system.add_node (node_config);
835  	nano::keypair key;
836  	system.wallet (0)-&gt;insert_adhoc (nano::dev::genesis_key.prv);
837  	auto const num_blocks = nano::confirmation_height::unbounded_cutoff;
838  	auto latest_genesis = nano::dev::genesis;
839  	std::vector&lt;std::shared_ptr&lt;nano::state_block&gt;&gt; state_blocks;
840  	nano::block_builder builder;
841  	for (auto i = 0; i &lt; num_blocks; ++i)
842  	{
843  		auto send = builder
844  					.state ()
845  					.account (nano::dev::genesis_key.pub)
846  					.previous (latest_genesis-&gt;hash ())
847  					.representative (nano::dev::genesis_key.pub)
848  					.balance (nano::dev::constants.genesis_amount - i - 1)
849  					.link (key.pub)
850  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
851  					.work (*system.work.generate (latest_genesis-&gt;hash ()))
852  					.build_shared ();
853  		latest_genesis = send;
854  		state_blocks.push_back (send);
855  	}
856  	{
857  		auto transaction = node-&gt;store.tx_begin_write ();
858  		for (auto const &amp; block : state_blocks)
859  		{
860  			ASSERT_EQ (nano::process_result::progress, node-&gt;ledger.process (transaction, *block).code);
861  		}
862  	}
863  	node-&gt;confirmation_height_processor.add (state_blocks.front ());
864  	ASSERT_TIMELY (20s, node-&gt;ledger.cache.cemented_count == 2);
865  	node-&gt;confirmation_height_processor.add (latest_genesis);
866  	ASSERT_TIMELY (20s, node-&gt;ledger.cache.cemented_count == num_blocks + 1);
867  	ASSERT_EQ (node-&gt;ledger.stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed, nano::stat::dir::in), num_blocks);
868  	ASSERT_EQ (node-&gt;ledger.stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed_bounded, nano::stat::dir::in), 1);
869  	ASSERT_EQ (node-&gt;ledger.stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed_unbounded, nano::stat::dir::in), num_blocks - 1);
870  	ASSERT_TIMELY (10s, node-&gt;active.election_winner_details_size () == 0);
871  }
872  TEST (confirmation_height, dynamic_algorithm_no_transition_while_pending)
873  {
874  	for (auto _ = 0; _ &lt; 3; ++_)
875  	{
876  		nano::test::system system;
877  		nano::node_config node_config = system.default_config ();
878  		node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
879  		nano::node_flags node_flags;
880  		node_flags.force_use_write_database_queue = true;
881  		auto node = system.add_node (node_config, node_flags);
882  		nano::keypair key;
883  		system.wallet (0)-&gt;insert_adhoc (nano::dev::genesis_key.prv);
884  		auto latest_genesis = node-&gt;latest (nano::dev::genesis_key.pub);
885  		std::vector&lt;std::shared_ptr&lt;nano::state_block&gt;&gt; state_blocks;
886  		auto const num_blocks = nano::confirmation_height::unbounded_cutoff - 2;
887  		auto add_block_to_genesis_chain = [&amp;] (nano::write_transaction &amp; transaction) {
888  			static int num = 0;
889  			nano::block_builder builder;
890  			auto send = builder
891  						.state ()
892  						.account (nano::dev::genesis_key.pub)
893  						.previous (latest_genesis)
894  						.representative (nano::dev::genesis_key.pub)
895  						.balance (nano::dev::constants.genesis_amount - num - 1)
896  						.link (key.pub)
897  						.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
898  						.work (*system.work.generate (latest_genesis))
899  						.build_shared ();
900  			latest_genesis = send-&gt;hash ();
901  			state_blocks.push_back (send);
902  			ASSERT_EQ (nano::process_result::progress, node-&gt;ledger.process (transaction, *send).code);
903  			++num;
904  		};
905  		for (auto i = 0; i &lt; num_blocks; ++i)
906  		{
907  			auto transaction = node-&gt;store.tx_begin_write ();
908  			add_block_to_genesis_chain (transaction);
909  		}
910  		{
911  			auto write_guard = node-&gt;write_database_queue.wait (nano::writer::testing);
912  			node-&gt;confirmation_height_processor.add (state_blocks.back ());
913  			nano::timer&lt;&gt; timer;
914  			timer.start ();
915  			while (node-&gt;confirmation_height_processor.current ().is_zero ())
916  			{
917  				ASSERT_LT (timer.since_start (), 2s);
918  			}
919  			node-&gt;confirmation_height_processor.pause ();
920  			timer.restart ();
921  			ASSERT_TIMELY (10s, node-&gt;confirmation_height_processor.unbounded_processor.pending_writes_size != 0);
922  			{
923  				auto transaction = node-&gt;store.tx_begin_write ();
924  				add_block_to_genesis_chain (transaction);
925  				add_block_to_genesis_chain (transaction);
926  			}
927  			node-&gt;confirmation_height_processor.add (state_blocks.front ());
928  			node-&gt;confirmation_height_processor.unpause ();
929  		}
930  		ASSERT_TIMELY (10s, node-&gt;ledger.cache.cemented_count == num_blocks + 1);
931  		ASSERT_EQ (node-&gt;ledger.stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed, nano::stat::dir::in), num_blocks);
932  		ASSERT_EQ (node-&gt;ledger.stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed_bounded, nano::stat::dir::in), 0);
933  		ASSERT_EQ (node-&gt;ledger.stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed_unbounded, nano::stat::dir::in), num_blocks);
934  		ASSERT_TIMELY (10s, node-&gt;active.election_winner_details_size () == 0);
935  	}
936  }
937  TEST (confirmation_height, many_accounts_send_receive_self)
938  {
939  	nano::test::system system;
940  	nano::node_config node_config = system.default_config ();
941  	node_config.online_weight_minimum = 100;
942  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
943  	node_config.active_elections_size = 400000;
944  	nano::node_flags node_flags;
945  	node_flags.confirmation_height_processor_mode = nano::confirmation_height_mode::unbounded;
946  	auto node = system.add_node (node_config);
947  	system.wallet (0)-&gt;insert_adhoc (nano::dev::genesis_key.prv);
948  #ifndef NDEBUG
949  	auto const num_accounts = 10000;
950  #else
951  	auto const num_accounts = 100000;
952  #endif
953  	auto latest_genesis = node-&gt;latest (nano::dev::genesis_key.pub);
954  	std::vector&lt;nano::keypair&gt; keys;
955  	nano::block_builder builder;
956  	std::vector&lt;std::shared_ptr&lt;nano::open_block&gt;&gt; open_blocks;
957  	{
958  		auto transaction = node-&gt;store.tx_begin_write ();
959  		for (auto i = 0; i &lt; num_accounts; ++i)
960  		{
961  			nano::keypair key;
962  			keys.emplace_back (key);
963  			auto send = builder
964  						.send ()
965  						.previous (latest_genesis)
966  						.destination (key.pub)
967  						.balance (nano::dev::constants.genesis_amount - 1 - i)
968  						.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
969  						.work (*system.work.generate (latest_genesis))
970  						.build ();
971  			ASSERT_EQ (nano::process_result::progress, node-&gt;ledger.process (transaction, *send).code);
972  			auto open = builder
973  						.open ()
974  						.source (send-&gt;hash ())
975  						.representative (nano::dev::genesis_key.pub)
976  						.account (key.pub)
977  						.sign (key.prv, key.pub)
978  						.work (*system.work.generate (key.pub))
979  						.build_shared ();
980  			ASSERT_EQ (nano::process_result::progress, node-&gt;ledger.process (transaction, *open).code);
981  			open_blocks.push_back (std::move (open));
982  			latest_genesis = send-&gt;hash ();
983  		}
984  	}
985  	for (auto &amp; open_block : open_blocks)
986  	{
987  		node-&gt;block_confirm (open_block);
988  		std::shared_ptr&lt;nano::election&gt; election;
989  		ASSERT_TIMELY (10s, (election = node-&gt;active.election (open_block-&gt;qualified_root ())) != nullptr);
990  		election-&gt;force_confirm ();
991  	}
992  	system.deadline_set (100s);
993  	auto num_blocks_to_confirm = num_accounts * 2;
994  	while (node-&gt;stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed, nano::stat::dir::in) != num_blocks_to_confirm)
995  	{
996  		ASSERT_NO_ERROR (system.poll ());
997  	}
998  	std::vector&lt;std::shared_ptr&lt;nano::send_block&gt;&gt; send_blocks;
999  	std::vector&lt;std::shared_ptr&lt;nano::receive_block&gt;&gt; receive_blocks;
1000  	for (int i = 0; i &lt; open_blocks.size (); ++i)
1001  	{
1002  		auto open_block = open_blocks[i];
1003  		auto &amp; keypair = keys[i];
1004  		send_blocks.emplace_back (builder
1005  								  .send ()
1006  								  .previous (open_block-&gt;hash ())
1007  								  .destination (keypair.pub)
1008  								  .balance (1)
1009  								  .sign (keypair.prv, keypair.pub)
1010  								  .work (*system.work.generate (open_block-&gt;hash ()))
1011  								  .build_shared ());
1012  		receive_blocks.emplace_back (builder
1013  									 .receive ()
1014  									 .previous (send_blocks.back ()-&gt;hash ())
1015  									 .source (send_blocks.back ()-&gt;hash ())
1016  									 .sign (keypair.prv, keypair.pub)
1017  									 .work (*system.work.generate (send_blocks.back ()-&gt;hash ()))
1018  									 .build_shared ());
1019  	}
1020  	for (int i = 0; i &lt; open_blocks.size (); ++i)
1021  	{
1022  		node-&gt;process_active (send_blocks[i]);
1023  		node-&gt;process_active (receive_blocks[i]);
1024  	}
1025  	system.deadline_set (300s);
1026  	num_blocks_to_confirm = num_accounts * 4;
1027  	while (node-&gt;stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed, nano::stat::dir::in) != num_blocks_to_confirm)
1028  	{
1029  		ASSERT_NO_ERROR (system.poll ());
1030  	}
1031  	system.deadline_set (200s);
1032  	while ((node-&gt;ledger.cache.cemented_count - 1) != node-&gt;stats.count (nano::stat::type::confirmation_observer, nano::stat::detail::all, nano::stat::dir::out))
1033  	{
1034  		ASSERT_NO_ERROR (system.poll ());
1035  	}
1036  	auto transaction = node-&gt;store.tx_begin_read ();
1037  	size_t cemented_count = 0;
1038  	for (auto i (node-&gt;ledger.store.confirmation_height.begin (transaction)), n (node-&gt;ledger.store.confirmation_height.end ()); i != n; ++i)
1039  	{
1040  		cemented_count += i-&gt;second.height;
1041  	}
1042  	ASSERT_EQ (num_blocks_to_confirm + 1, cemented_count);
1043  	ASSERT_EQ (cemented_count, node-&gt;ledger.cache.cemented_count);
1044  	system.deadline_set (60s);
1045  	while ((node-&gt;ledger.cache.cemented_count - 1) != node-&gt;stats.count (nano::stat::type::confirmation_observer, nano::stat::detail::all, nano::stat::dir::out))
1046  	{
1047  		ASSERT_NO_ERROR (system.poll ());
1048  	}
1049  	system.deadline_set (60s);
1050  	while (node-&gt;active.election_winner_details_size () &gt; 0)
1051  	{
1052  		ASSERT_NO_ERROR (system.poll ());
1053  	}
1054  }
1055  TEST (confirmation_height, many_accounts_send_receive_self_no_elections)
1056  {
1057  	if (nano::rocksdb_config::using_rocksdb_in_tests ())
1058  	{
1059  		return;
1060  	}
1061  	nano::logger_mt logger;
1062  	nano::logging logging;
1063  	auto path (nano::unique_path ());
1064  	auto store = nano::make_store (logger, path, nano::dev::constants);
1065  	ASSERT_TRUE (!store-&gt;init_error ());
1066  	nano::stats stats;
1067  	nano::ledger ledger (*store, stats, nano::dev::constants);
1068  	nano::write_database_queue write_database_queue (false);
1069  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits&lt;unsigned&gt;::max () };
1070  	std::atomic&lt;bool&gt; stopped{ false };
1071  	boost::latch initialized_latch{ 0 };
1072  	nano::block_hash block_hash_being_processed{ 0 };
1073  	nano::confirmation_height_processor confirmation_height_processor{ ledger, write_database_queue, 10ms, logging, logger, initialized_latch, confirmation_height_mode::automatic };
1074  	auto const num_accounts = 100000;
1075  	auto latest_genesis = nano::dev::genesis-&gt;hash ();
1076  	std::vector&lt;nano::keypair&gt; keys;
1077  	std::vector&lt;std::shared_ptr&lt;nano::open_block&gt;&gt; open_blocks;
1078  	nano::block_builder builder;
1079  	nano::test::system system;
1080  	{
1081  		auto transaction (store-&gt;tx_begin_write ());
1082  		store-&gt;initialize (transaction, ledger.cache, ledger.constants);
1083  		for (auto i = 0; i &lt; num_accounts; ++i)
1084  		{
1085  			nano::keypair key;
1086  			keys.emplace_back (key);
1087  			auto send = builder
1088  						.send ()
1089  						.previous (latest_genesis)
1090  						.destination (key.pub)
1091  						.balance (nano::dev::constants.genesis_amount - 1 - i)
1092  						.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1093  						.work (*pool.generate (latest_genesis))
1094  						.build ();
1095  			ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send).code);
1096  			auto open = builder
1097  						.open ()
1098  						.source (send-&gt;hash ())
1099  						.representative (nano::dev::genesis_key.pub)
1100  						.account (key.pub)
1101  						.sign (key.prv, key.pub)
1102  						.work (*pool.generate (key.pub))
1103  						.build_shared ();
1104  			ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *open).code);
1105  			open_blocks.push_back (std::move (open));
1106  			latest_genesis = send-&gt;hash ();
1107  		}
1108  	}
1109  	for (auto &amp; open_block : open_blocks)
1110  	{
1111  		confirmation_height_processor.add (open_block);
1112  	}
1113  	system.deadline_set (1000s);
1114  	auto num_blocks_to_confirm = num_accounts * 2;
1115  	while (stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed, nano::stat::dir::in) != num_blocks_to_confirm)
1116  	{
1117  		ASSERT_NO_ERROR (system.poll ());
1118  	}
1119  	std::vector&lt;std::shared_ptr&lt;nano::send_block&gt;&gt; send_blocks;
1120  	std::vector&lt;std::shared_ptr&lt;nano::receive_block&gt;&gt; receive_blocks;
1121  	{
1122  		auto transaction (store-&gt;tx_begin_write ());
1123  		for (int i = 0; i &lt; open_blocks.size (); ++i)
1124  		{
1125  			auto open_block = open_blocks[i];
1126  			auto &amp; keypair = keys[i];
1127  			send_blocks.emplace_back (builder
1128  									  .send ()
1129  									  .previous (open_block-&gt;hash ())
1130  									  .destination (keypair.pub)
1131  									  .balance (1)
1132  									  .sign (keypair.prv, keypair.pub)
1133  									  .work (*system.work.generate (open_block-&gt;hash ()))
1134  									  .build_shared ());
1135  			receive_blocks.emplace_back (builder
1136  										 .receive ()
1137  										 .previous (send_blocks.back ()-&gt;hash ())
1138  										 .source (send_blocks.back ()-&gt;hash ())
1139  										 .sign (keypair.prv, keypair.pub)
1140  										 .work (*system.work.generate (send_blocks.back ()-&gt;hash ()))
1141  										 .build_shared ());
1142  			ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send_blocks.back ()).code);
1143  			ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *receive_blocks.back ()).code);
1144  		}
1145  	}
1146  	std::random_device rd;
1147  	std::mt19937 g (rd ());
1148  	std::shuffle (send_blocks.begin (), send_blocks.end (), g);
1149  	std::mt19937 g1 (rd ());
1150  	std::shuffle (receive_blocks.begin (), receive_blocks.end (), g1);
1151  	for (int i = 0; i &lt; open_blocks.size (); ++i)
1152  	{
1153  		confirmation_height_processor.add (send_blocks[i]);
1154  		confirmation_height_processor.add (receive_blocks[i]);
1155  	}
1156  	system.deadline_set (1000s);
1157  	num_blocks_to_confirm = num_accounts * 4;
1158  	while (stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed, nano::stat::dir::in) != num_blocks_to_confirm)
1159  	{
1160  		ASSERT_NO_ERROR (system.poll ());
1161  	}
1162  	while (!confirmation_height_processor.current ().is_zero ())
1163  	{
1164  		ASSERT_NO_ERROR (system.poll ());
1165  	}
1166  	auto transaction = store-&gt;tx_begin_read ();
1167  	size_t cemented_count = 0;
1168  	for (auto i (store-&gt;confirmation_height.begin (transaction)), n (store-&gt;confirmation_height.end ()); i != n; ++i)
1169  	{
1170  		cemented_count += i-&gt;second.height;
1171  	}
1172  	ASSERT_EQ (num_blocks_to_confirm + 1, cemented_count);
1173  	ASSERT_EQ (cemented_count, ledger.cache.cemented_count);
1174  }
1175  }
1176  namespace
1177  {
1178  class data
1179  {
1180  public:
1181  	std::atomic&lt;bool&gt; awaiting_cache{ false };
1182  	std::atomic&lt;bool&gt; keep_requesting_metrics{ true };
1183  	std::shared_ptr&lt;nano::node&gt; node;
1184  	std::chrono::system_clock::time_point orig_time;
1185  	std::atomic_flag orig_time_set = ATOMIC_FLAG_INIT;
1186  };
1187  class shared_data
1188  {
1189  public:
1190  	nano::test::counted_completion write_completion{ 0 };
1191  	std::atomic&lt;bool&gt; done{ false };
1192  };
1193  template &lt;typename T&gt;
1194  void callback_process (shared_data &amp; shared_data_a, data &amp; data, T &amp; all_node_data_a, std::chrono::system_clock::time_point last_updated)
1195  {
1196  	if (!data.orig_time_set.test_and_set ())
1197  	{
1198  		data.orig_time = last_updated;
1199  	}
1200  	if (data.awaiting_cache &amp;&amp; data.orig_time != last_updated)
1201  	{
1202  		data.keep_requesting_metrics = false;
1203  	}
1204  	if (data.orig_time != last_updated)
1205  	{
1206  		data.awaiting_cache = true;
1207  		data.orig_time = last_updated;
1208  	}
1209  	shared_data_a.write_completion.increment ();
1210  };
1211  }
1212  TEST (telemetry, ongoing_requests)
1213  {
1214  	nano::test::system system;
1215  	nano::node_flags node_flags;
1216  	auto node_client = system.add_node (node_flags);
1217  	auto node_server = system.add_node (node_flags);
1218  	nano::test::wait_peer_connections (system);
1219  	ASSERT_EQ (0, node_client-&gt;telemetry.size ());
1220  	ASSERT_EQ (0, node_server-&gt;telemetry.size ());
1221  	ASSERT_EQ (0, node_client-&gt;stats.count (nano::stat::type::bootstrap, nano::stat::detail::telemetry_ack, nano::stat::dir::in));
1222  	ASSERT_EQ (0, node_client-&gt;stats.count (nano::stat::type::bootstrap, nano::stat::detail::telemetry_req, nano::stat::dir::out));
1223  	ASSERT_TIMELY (20s, node_client-&gt;stats.count (nano::stat::type::message, nano::stat::detail::telemetry_ack, nano::stat::dir::in) == 1 &amp;&amp; node_server-&gt;stats.count (nano::stat::type::message, nano::stat::detail::telemetry_ack, nano::stat::dir::in) == 1);
1224  	auto time = std::chrono::steady_clock::now ();
1225  	ASSERT_TIMELY (10s, std::chrono::steady_clock::now () &gt;= (time + nano::dev::network_params.network.telemetry_cache_cutoff + 1s));
1226  	ASSERT_EQ (2, node_client-&gt;stats.count (nano::stat::type::message, nano::stat::detail::telemetry_ack, nano::stat::dir::in));
1227  	ASSERT_EQ (2, node_client-&gt;stats.count (nano::stat::type::message, nano::stat::detail::telemetry_req, nano::stat::dir::in));
1228  	ASSERT_EQ (2, node_client-&gt;stats.count (nano::stat::type::message, nano::stat::detail::telemetry_req, nano::stat::dir::out));
1229  	ASSERT_EQ (2, node_server-&gt;stats.count (nano::stat::type::message, nano::stat::detail::telemetry_ack, nano::stat::dir::in));
1230  	ASSERT_EQ (2, node_server-&gt;stats.count (nano::stat::type::message, nano::stat::detail::telemetry_req, nano::stat::dir::in));
1231  	ASSERT_EQ (2, node_server-&gt;stats.count (nano::stat::type::message, nano::stat::detail::telemetry_req, nano::stat::dir::out));
1232  }
1233  namespace nano
1234  {
1235  namespace transport
1236  {
1237  	TEST (telemetry, simultaneous_requests)
1238  	{
1239  		nano::test::system system;
1240  		nano::node_flags node_flags;
1241  		auto const num_nodes = 4;
1242  		for (int i = 0; i &lt; num_nodes; ++i)
1243  		{
1244  			system.add_node (node_flags);
1245  		}
1246  		nano::test::wait_peer_connections (system);
1247  		std::vector&lt;std::thread&gt; threads;
1248  		auto const num_threads = 4;
1249  		std::array&lt;data, num_nodes&gt; node_data{};
1250  		for (auto i = 0; i &lt; num_nodes; ++i)
1251  		{
1252  			node_data[i].node = system.nodes[i];
1253  		}
1254  		shared_data shared_data;
1255  		for (int i = 0; i &lt; num_threads; ++i)
1256  		{
1257  			threads.emplace_back ([&amp;node_data, &amp;shared_data] () {
1258  				while (std::any_of (node_data.cbegin (), node_data.cend (), [] (auto const &amp; data) { return data.keep_requesting_metrics.load (); }))
1259  				{
1260  					for (auto &amp; data : node_data)
1261  					{
1262  						if (data.keep_requesting_metrics)
1263  						{
1264  							shared_data.write_completion.increment_required_count ();
1265  							auto peer = data.node-&gt;network.tcp_channels.channels[0].channel;
1266  							auto maybe_telemetry = data.node-&gt;telemetry.get_telemetry (peer-&gt;get_endpoint ());
1267  							if (maybe_telemetry)
1268  							{
1269  								callback_process (shared_data, data, node_data, maybe_telemetry-&gt;timestamp);
1270  							}
1271  						}
1272  						std::this_thread::sleep_for (1ms);
1273  					}
1274  				}
1275  				shared_data.write_completion.await_count_for (20s);
1276  				shared_data.done = true;
1277  			});
1278  		}
1279  		ASSERT_TIMELY (30s, shared_data.done);
1280  		ASSERT_TRUE (std::all_of (node_data.begin (), node_data.end (), [] (auto const &amp; data) { return !data.keep_requesting_metrics; }));
1281  		for (auto &amp; thread : threads)
1282  		{
1283  			thread.join ();
1284  		}
1285  	}
1286  }
1287  }
1288  TEST (telemetry, under_load)
1289  {
1290  	nano::test::system system;
1291  	nano::node_config node_config = system.default_config ();
1292  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
1293  	nano::node_flags node_flags;
1294  	auto node = system.add_node (node_config, node_flags);
1295  	node_config.peering_port = system.get_available_port ();
1296  	auto node1 = system.add_node (node_config, node_flags);
1297  	nano::keypair key;
1298  	nano::keypair key1;
1299  	system.wallet (0)-&gt;insert_adhoc (nano::dev::genesis_key.prv);
1300  	system.wallet (0)-&gt;insert_adhoc (key.prv);
1301  	auto latest_genesis = node-&gt;latest (nano::dev::genesis_key.pub);
1302  	auto num_blocks = 150000;
1303  	nano::block_builder builder;
1304  	auto send = builder
1305  				.state ()
1306  				.account (nano::dev::genesis_key.pub)
1307  				.previous (latest_genesis)
1308  				.representative (nano::dev::genesis_key.pub)
1309  				.balance (nano::dev::constants.genesis_amount - num_blocks)
1310  				.link (key.pub)
1311  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1312  				.work (*system.work.generate (latest_genesis))
1313  				.build_shared ();
1314  	node-&gt;process_active (send);
1315  	latest_genesis = send-&gt;hash ();
1316  	auto open = builder
1317  				.state ()
1318  				.account (key.pub)
1319  				.previous (0)
1320  				.representative (key.pub)
1321  				.balance (num_blocks)
1322  				.link (send-&gt;hash ())
1323  				.sign (key.prv, key.pub)
1324  				.work (*system.work.generate (key.pub))
1325  				.build_shared ();
1326  	node-&gt;process_active (open);
1327  	auto latest_key = open-&gt;hash ();
1328  	auto thread_func = [key1, &amp;system, node, num_blocks] (nano::keypair const &amp; keypair, nano::block_hash const &amp; latest, nano::uint128_t const initial_amount) {
1329  		auto latest_l = latest;
1330  		nano::block_builder builder;
1331  		for (int i = 0; i &lt; num_blocks; ++i)
1332  		{
1333  			auto send = builder
1334  						.state ()
1335  						.account (keypair.pub)
1336  						.previous (latest_l)
1337  						.representative (keypair.pub)
1338  						.balance (initial_amount - i - 1)
1339  						.link (key1.pub)
1340  						.sign (keypair.prv, keypair.pub)
1341  						.work (*system.work.generate (latest_l))
1342  						.build_shared ();
1343  			latest_l = send-&gt;hash ();
1344  			node-&gt;process_active (send);
1345  		}
1346  	};
1347  	std::thread thread1 (thread_func, nano::dev::genesis_key, latest_genesis, nano::dev::constants.genesis_amount - num_blocks);
1348  	std::thread thread2 (thread_func, key, latest_key, num_blocks);
1349  	ASSERT_TIMELY (200s, node1-&gt;ledger.cache.block_count == num_blocks * 2 + 3);
1350  	thread1.join ();
1351  	thread2.join ();
1352  	for (auto const &amp; node : system.nodes)
1353  	{
1354  		ASSERT_EQ (0, node-&gt;stats.count (nano::stat::type::telemetry, nano::stat::detail::failed_send_telemetry_req));
1355  		ASSERT_EQ (0, node-&gt;stats.count (nano::stat::type::telemetry, nano::stat::detail::request_within_protection_cache_zone));
1356  		ASSERT_EQ (0, node-&gt;stats.count (nano::stat::type::telemetry, nano::stat::detail::unsolicited_telemetry_ack));
1357  		ASSERT_EQ (0, node-&gt;stats.count (nano::stat::type::telemetry, nano::stat::detail::no_response_received));
1358  	}
1359  }
1360  TEST (telemetry, cache_read_and_timeout)
1361  {
1362  	nano::test::system system;
1363  	nano::node_flags node_flags;
1364  	node_flags.disable_ongoing_telemetry_requests = true;
1365  	auto node_client = system.add_node (node_flags);
1366  	auto node_server = system.add_node (node_flags);
1367  	nano::test::wait_peer_connections (system);
1368  	std::optional&lt;nano::telemetry_data&gt; telemetry_data;
1369  	auto channel = node_client-&gt;network.find_node_id (node_server-&gt;get_node_id ());
1370  	ASSERT_NE (channel, nullptr);
1371  	node_client-&gt;telemetry.trigger ();
1372  	ASSERT_TIMELY (5s, telemetry_data = node_client-&gt;telemetry.get_telemetry (channel-&gt;get_endpoint ()));
1373  	auto responses = node_client-&gt;telemetry.get_all_telemetries ();
1374  	ASSERT_TRUE (!responses.empty ());
1375  	ASSERT_EQ (telemetry_data, responses.begin ()-&gt;second);
1376  	ASSERT_EQ (1, node_client-&gt;stats.count (nano::stat::type::message, nano::stat::detail::telemetry_ack, nano::stat::dir::in));
1377  	ASSERT_EQ (0, node_client-&gt;stats.count (nano::stat::type::message, nano::stat::detail::telemetry_req, nano::stat::dir::in));
1378  	ASSERT_EQ (1, node_client-&gt;stats.count (nano::stat::type::message, nano::stat::detail::telemetry_req, nano::stat::dir::out));
1379  	ASSERT_EQ (0, node_server-&gt;stats.count (nano::stat::type::message, nano::stat::detail::telemetry_ack, nano::stat::dir::in));
1380  	ASSERT_EQ (1, node_server-&gt;stats.count (nano::stat::type::message, nano::stat::detail::telemetry_req, nano::stat::dir::in));
1381  	ASSERT_EQ (0, node_server-&gt;stats.count (nano::stat::type::message, nano::stat::detail::telemetry_req, nano::stat::dir::out));
1382  	ASSERT_TIMELY (5s, node_client-&gt;telemetry.get_all_telemetries ().empty ());
1383  	responses = node_client-&gt;telemetry.get_all_telemetries ();
1384  	ASSERT_TRUE (responses.empty ());
1385  	node_client-&gt;telemetry.trigger ();
1386  	ASSERT_TIMELY (5s, telemetry_data = node_client-&gt;telemetry.get_telemetry (channel-&gt;get_endpoint ()));
1387  	responses = node_client-&gt;telemetry.get_all_telemetries ();
1388  	ASSERT_TRUE (!responses.empty ());
1389  	ASSERT_EQ (telemetry_data, responses.begin ()-&gt;second);
1390  	ASSERT_EQ (2, node_client-&gt;stats.count (nano::stat::type::message, nano::stat::detail::telemetry_ack, nano::stat::dir::in));
1391  	ASSERT_EQ (0, node_client-&gt;stats.count (nano::stat::type::message, nano::stat::detail::telemetry_req, nano::stat::dir::in));
1392  	ASSERT_EQ (2, node_client-&gt;stats.count (nano::stat::type::message, nano::stat::detail::telemetry_req, nano::stat::dir::out));
1393  	ASSERT_EQ (0, node_server-&gt;stats.count (nano::stat::type::message, nano::stat::detail::telemetry_ack, nano::stat::dir::in));
1394  	ASSERT_EQ (2, node_server-&gt;stats.count (nano::stat::type::message, nano::stat::detail::telemetry_req, nano::stat::dir::in));
1395  	ASSERT_EQ (0, node_server-&gt;stats.count (nano::stat::type::message, nano::stat::detail::telemetry_req, nano::stat::dir::out));
1396  }
1397  TEST (telemetry, many_nodes)
1398  {
1399  	nano::test::system system;
1400  	nano::node_flags node_flags;
1401  	node_flags.disable_request_loop = true;
1402  	auto const num_nodes = nano::memory_intensive_instrumentation () ? 4 : 10;
1403  	for (auto i = 0; i &lt; num_nodes; ++i)
1404  	{
1405  		nano::node_config node_config = system.default_config ();
1406  		node_config.bandwidth_limit = 100000 + i;
1407  		auto node = std::make_shared&lt;nano::node&gt; (system.io_ctx, nano::unique_path (), node_config, system.work, node_flags);
1408  		node-&gt;start ();
1409  		system.nodes.push_back (node);
1410  	}
1411  	for (auto const &amp; node : system.nodes)
1412  	{
1413  		for (auto const &amp; other_node : system.nodes)
1414  		{
1415  			if (node != other_node)
1416  			{
1417  				node-&gt;network.merge_peer (other_node-&gt;network.endpoint ());
1418  			}
1419  		}
1420  	}
1421  	nano::test::wait_peer_connections (system);
1422  	nano::keypair key;
1423  	nano::block_builder builder;
1424  	auto send = builder
1425  				.state ()
1426  				.account (nano::dev::genesis_key.pub)
1427  				.previous (nano::dev::genesis-&gt;hash ())
1428  				.representative (nano::dev::genesis_key.pub)
1429  				.balance (nano::dev::constants.genesis_amount - nano::Mxrb_ratio)
1430  				.link (key.pub)
1431  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1432  				.work (*system.work.generate (nano::dev::genesis-&gt;hash ()))
1433  				.build ();
1434  	for (auto node : system.nodes)
1435  	{
1436  		auto transaction (node-&gt;store.tx_begin_write ());
1437  		ASSERT_EQ (nano::process_result::progress, node-&gt;ledger.process (transaction, *send).code);
1438  	}
1439  	auto node_client = system.nodes.front ();
1440  	std::vector&lt;nano::telemetry_data&gt; telemetry_datas;
1441  	auto peers = node_client-&gt;network.list (num_nodes - 1);
1442  	ASSERT_EQ (peers.size (), num_nodes - 1);
1443  	for (auto const &amp; peer : peers)
1444  	{
1445  		std::optional&lt;nano::telemetry_data&gt; telemetry_data;
1446  		ASSERT_TIMELY (5s, telemetry_data = node_client-&gt;telemetry.get_telemetry (peer-&gt;get_endpoint ()));
1447  		telemetry_datas.push_back (*telemetry_data);
1448  	}
1449  	ASSERT_EQ (telemetry_datas.size (), num_nodes - 1);
1450  	for (auto &amp; data : telemetry_datas)
1451  	{
1452  		ASSERT_EQ (data.unchecked_count, 0);
1453  		ASSERT_EQ (data.cemented_count, 1);
1454  		ASSERT_LE (data.peer_count, 9U);
1455  		ASSERT_EQ (data.account_count, 1);
1456  		ASSERT_TRUE (data.block_count == 2);
1457  		ASSERT_EQ (data.protocol_version, nano::dev::network_params.network.protocol_version);
1458  		ASSERT_GE (data.bandwidth_cap, 100000);
1459  		ASSERT_LT (data.bandwidth_cap, 100000 + system.nodes.size ());
1460  		ASSERT_EQ (data.major_version, nano::get_major_node_version ());
1461  		ASSERT_EQ (data.minor_version, nano::get_minor_node_version ());
1462  		ASSERT_EQ (data.patch_version, nano::get_patch_node_version ());
1463  		ASSERT_EQ (data.pre_release_version, nano::get_pre_release_node_version ());
1464  		ASSERT_EQ (data.maker, 0);
1465  		ASSERT_LT (data.uptime, 100);
1466  		ASSERT_EQ (data.genesis_block, nano::dev::genesis-&gt;hash ());
1467  		ASSERT_LE (data.timestamp, std::chrono::system_clock::now ());
1468  		ASSERT_EQ (data.active_difficulty, system.nodes.front ()-&gt;default_difficulty (nano::work_version::work_1));
1469  	}
1470  	auto bandwidth_cap = telemetry_datas.front ().bandwidth_cap;
1471  	telemetry_datas.erase (telemetry_datas.begin ());
1472  	auto all_bandwidth_limits_same = std::all_of (telemetry_datas.begin (), telemetry_datas.end (), [bandwidth_cap] (auto &amp; telemetry_data) {
1473  		return telemetry_data.bandwidth_cap == bandwidth_cap;
1474  	});
1475  	ASSERT_FALSE (all_bandwidth_limits_same);
1476  }
1477  TEST (signature_checker, mass_boundary_checks)
1478  {
1479  	std::vector&lt;size_t&gt; sizes{ 0, 1 };
1480  	auto add_boundary = [&amp;sizes] (size_t boundary) {
1481  		sizes.insert (sizes.end (), { boundary - 1, boundary, boundary + 1 });
1482  	};
1483  	for (auto i = 1; i &lt;= 10; ++i)
1484  	{
1485  		add_boundary (nano::signature_checker::batch_size * i);
1486  	}
1487  	nano::block_builder builder;
1488  	for (auto num_threads = 0; num_threads &lt; 5; ++num_threads)
1489  	{
1490  		nano::signature_checker checker (num_threads);
1491  		auto max_size = *(sizes.end () - 1);
1492  		std::vector&lt;nano::uint256_union&gt; hashes;
1493  		hashes.reserve (max_size);
1494  		std::vector&lt;unsigned char const *&gt; messages;
1495  		messages.reserve (max_size);
1496  		std::vector&lt;size_t&gt; lengths;
1497  		lengths.reserve (max_size);
1498  		std::vector&lt;unsigned char const *&gt; pub_keys;
1499  		pub_keys.reserve (max_size);
1500  		std::vector&lt;unsigned char const *&gt; signatures;
1501  		signatures.reserve (max_size);
1502  		nano::keypair key;
1503  		auto block = builder
1504  					 .state ()
1505  					 .account (key.pub)
1506  					 .previous (0)
1507  					 .representative (key.pub)
1508  					 .balance (0)
1509  					 .link (0)
1510  					 .sign (key.prv, key.pub)
1511  					 .work (0)
1512  					 .build ();
1513  		size_t last_size = 0;
1514  		for (auto size : sizes)
1515  		{
1516  			auto extra_size = size - last_size;
1517  			std::vector&lt;int&gt; verifications;
1518  			verifications.resize (size);
1519  			for (auto i (0); i &lt; extra_size; ++i)
1520  			{
1521  				hashes.push_back (block-&gt;hash ());
1522  				messages.push_back (hashes.back ().bytes.data ());
1523  				lengths.push_back (sizeof (decltype (hashes)::value_type));
1524  				pub_keys.push_back (block-&gt;hashables.account.bytes.data ());
1525  				signatures.push_back (block-&gt;signature.bytes.data ());
1526  			}
1527  			nano::signature_check_set check = { size, messages.data (), lengths.data (), pub_keys.data (), signatures.data (), verifications.data () };
1528  			checker.verify (check);
1529  			bool all_valid = std::all_of (verifications.cbegin (), verifications.cend (), [] (auto verification) { return verification == 1; });
1530  			ASSERT_TRUE (all_valid);
1531  			last_size = size;
1532  		}
1533  	}
1534  }
1535  TEST (node, mass_epoch_upgrader)
1536  {
1537  	auto perform_test = [] (size_t const batch_size) {
1538  		unsigned threads = 5;
1539  		size_t total_accounts = 2500;
1540  #ifndef NDEBUG
1541  		total_accounts /= 5;
1542  #endif
1543  		struct info
1544  		{
1545  			nano::keypair key;
1546  			nano::block_hash pending_hash;
1547  		};
1548  		std::vector&lt;info&gt; opened (total_accounts / 2);
1549  		std::vector&lt;info&gt; unopened (total_accounts / 2);
1550  		nano::test::system system;
1551  		nano::node_config node_config = system.default_config ();
1552  		node_config.work_threads = 4;
1553  		auto &amp; node = *system.add_node (node_config);
1554  		auto balance = node.balance (nano::dev::genesis_key.pub);
1555  		auto latest = node.latest (nano::dev::genesis_key.pub);
1556  		nano::uint128_t amount = 1;
1557  		std::array&lt;std::vector&lt;info&gt; *, 2&gt; all{ &amp;opened, &amp;unopened };
1558  		for (auto &amp; accounts : all)
1559  		{
1560  			for (auto &amp; info : *accounts)
1561  			{
1562  				balance -= amount;
1563  				nano::state_block_builder builder;
1564  				std::error_code ec;
1565  				auto block = builder
1566  							 .account (nano::dev::genesis_key.pub)
1567  							 .previous (latest)
1568  							 .balance (balance)
1569  							 .link (info.key.pub)
1570  							 .representative (nano::dev::genesis_key.pub)
1571  							 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1572  							 .work (*node.work_generate_blocking (latest, node_config.network_params.work.threshold (nano::work_version::work_1, nano::block_details (nano::epoch::epoch_0, false, false, false))))
1573  							 .build (ec);
1574  				ASSERT_FALSE (ec);
1575  				ASSERT_NE (nullptr, block);
1576  				ASSERT_EQ (nano::process_result::progress, node.process (*block).code);
1577  				latest = block-&gt;hash ();
1578  				info.pending_hash = block-&gt;hash ();
1579  			}
1580  		}
1581  		ASSERT_EQ (1 + total_accounts, node.ledger.cache.block_count);
1582  		ASSERT_EQ (1, node.ledger.cache.account_count);
1583  		for (auto const &amp; info : opened)
1584  		{
1585  			nano::state_block_builder builder;
1586  			std::error_code ec;
1587  			auto block = builder
1588  						 .account (info.key.pub)
1589  						 .previous (0)
1590  						 .balance (amount)
1591  						 .link (info.pending_hash)
1592  						 .representative (info.key.pub)
1593  						 .sign (info.key.prv, info.key.pub)
1594  						 .work (*node.work_generate_blocking (info.key.pub, node_config.network_params.work.threshold (nano::work_version::work_1, nano::block_details (nano::epoch::epoch_0, false, false, false))))
1595  						 .build (ec);
1596  			ASSERT_FALSE (ec);
1597  			ASSERT_NE (nullptr, block);
1598  			ASSERT_EQ (nano::process_result::progress, node.process (*block).code);
1599  		}
1600  		ASSERT_EQ (1 + total_accounts + opened.size (), node.ledger.cache.block_count);
1601  		ASSERT_EQ (1 + opened.size (), node.ledger.cache.account_count);
1602  		nano::keypair epoch_signer (nano::dev::genesis_key);
1603  		auto const block_count_before = node.ledger.cache.block_count.load ();
1604  		auto const total_to_upgrade = 1 + total_accounts;
1605  		std::cout &lt;&lt; &quot;Mass upgrading &quot; &lt;&lt; total_to_upgrade &lt;&lt; &quot; accounts&quot; &lt;&lt; std::endl;
1606  		while (node.ledger.cache.block_count != block_count_before + total_to_upgrade)
1607  		{
1608  			auto const pre_upgrade = node.ledger.cache.block_count.load ();
1609  			auto upgrade_count = std::min&lt;size_t&gt; (batch_size, block_count_before + total_to_upgrade - pre_upgrade);
1610  			ASSERT_FALSE (node.epoch_upgrader.start (epoch_signer.prv, nano::epoch::epoch_1, upgrade_count, threads));
1611  			ASSERT_TRUE (node.epoch_upgrader.start (epoch_signer.prv, nano::epoch::epoch_1, upgrade_count, threads));
1612  			system.deadline_set (60s);
1613  			while (node.ledger.cache.block_count != pre_upgrade + upgrade_count)
1614  			{
1615  				ASSERT_NO_ERROR (system.poll ());
1616  				std::this_thread::sleep_for (200ms);
1617  				std::cout &lt;&lt; node.ledger.cache.block_count - block_count_before &lt;&lt; &quot; / &quot; &lt;&lt; total_to_upgrade &lt;&lt; std::endl;
1618  			}
1619  			std::this_thread::sleep_for (50ms);
1620  		}
1621  		auto expected_blocks = block_count_before + total_accounts + 1;
1622  		ASSERT_EQ (expected_blocks, node.ledger.cache.block_count);
1623  		{
1624  			auto transaction (node.store.tx_begin_read ());
1625  			size_t block_count_sum = 0;
1626  			for (auto i (node.store.account.begin (transaction)); i != node.store.account.end (); ++i)
1627  			{
1628  				nano::account_info info (i-&gt;second);
1629  				ASSERT_EQ (info.epoch (), nano::epoch::epoch_1);
1630  				block_count_sum += info.block_count;
1631  			}
1632  			ASSERT_EQ (expected_blocks, block_count_sum);
1633  		}
1634  	};
1635  	perform_test (42);
1636  	perform_test (std::numeric_limits&lt;size_t&gt;::max ());
1637  }
1638  namespace nano
1639  {
1640  TEST (node, mass_block_new)
1641  {
1642  	nano::test::system system;
1643  	nano::node_config node_config = system.default_config ();
1644  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
1645  	auto &amp; node = *system.add_node (node_config);
1646  	node.network_params.network.aec_loop_interval_ms = 500;
1647  #ifndef NDEBUG
1648  	auto const num_blocks = 5000;
1649  #else
1650  	auto const num_blocks = 50000;
1651  #endif
1652  	std::cout &lt;&lt; num_blocks &lt;&lt; &quot; x4 blocks&quot; &lt;&lt; std::endl;
1653  	system.upgrade_genesis_epoch (node, nano::epoch::epoch_1);
1654  	system.upgrade_genesis_epoch (node, nano::epoch::epoch_2);
1655  	auto next_block_count = num_blocks + 3;
1656  	auto process_all = [&amp;] (std::vector&lt;std::shared_ptr&lt;nano::state_block&gt;&gt; const &amp; blocks_a) {
1657  		for (auto const &amp; block : blocks_a)
1658  		{
1659  			node.process_active (block);
1660  		}
1661  		ASSERT_TIMELY (200s, node.ledger.cache.block_count == next_block_count);
1662  		next_block_count += num_blocks;
1663  		node.block_processor.flush ();
1664  		{
1665  			nano::lock_guard&lt;nano::mutex&gt; guard{ node.active.mutex };
1666  			node.active.roots.clear ();
1667  			node.active.blocks.clear ();
1668  		}
1669  	};
1670  	nano::keypair key;
1671  	std::vector&lt;nano::keypair&gt; keys (num_blocks);
1672  	nano::state_block_builder builder;
1673  	std::vector&lt;std::shared_ptr&lt;nano::state_block&gt;&gt; send_blocks;
1674  	auto send_threshold (nano::dev::network_params.work.threshold (nano::work_version::work_1, nano::block_details (nano::epoch::epoch_2, true, false, false)));
1675  	auto latest_genesis = node.latest (nano::dev::genesis_key.pub);
1676  	for (auto i = 0; i &lt; num_blocks; ++i)
1677  	{
1678  		auto send = builder.make_block ()
1679  					.account (nano::dev::genesis_key.pub)
1680  					.previous (latest_genesis)
1681  					.balance (nano::dev::constants.genesis_amount - i - 1)
1682  					.representative (nano::dev::genesis_key.pub)
1683  					.link (keys[i].pub)
1684  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1685  					.work (*system.work.generate (nano::work_version::work_1, latest_genesis, send_threshold))
1686  					.build ();
1687  		latest_genesis = send-&gt;hash ();
1688  		send_blocks.push_back (std::move (send));
1689  	}
1690  	std::cout &lt;&lt; &quot;Send blocks built, start processing&quot; &lt;&lt; std::endl;
1691  	nano::timer&lt;&gt; timer;
1692  	timer.start ();
1693  	process_all (send_blocks);
1694  	std::cout &lt;&lt; &quot;Send blocks time: &quot; &lt;&lt; timer.stop ().count () &lt;&lt; &quot; &quot; &lt;&lt; timer.unit () &lt;&lt; &quot;\n\n&quot;;
1695  	std::vector&lt;std::shared_ptr&lt;nano::state_block&gt;&gt; open_blocks;
1696  	auto receive_threshold (nano::dev::network_params.work.threshold (nano::work_version::work_1, nano::block_details (nano::epoch::epoch_2, false, true, false)));
1697  	for (auto i = 0; i &lt; num_blocks; ++i)
1698  	{
1699  		auto const &amp; key = keys[i];
1700  		auto open = builder.make_block ()
1701  					.account (key.pub)
1702  					.previous (0)
1703  					.balance (1)
1704  					.representative (key.pub)
1705  					.link (send_blocks[i]-&gt;hash ())
1706  					.sign (key.prv, key.pub)
1707  					.work (*system.work.generate (nano::work_version::work_1, key.pub, receive_threshold))
1708  					.build ();
1709  		open_blocks.push_back (std::move (open));
1710  	}
1711  	std::cout &lt;&lt; &quot;Open blocks built, start processing&quot; &lt;&lt; std::endl;
1712  	timer.restart ();
1713  	process_all (open_blocks);
1714  	std::cout &lt;&lt; &quot;Open blocks time: &quot; &lt;&lt; timer.stop ().count () &lt;&lt; &quot; &quot; &lt;&lt; timer.unit () &lt;&lt; &quot;\n\n&quot;;
1715  	std::vector&lt;std::shared_ptr&lt;nano::state_block&gt;&gt; send_blocks2;
1716  	for (auto i = 0; i &lt; num_blocks; ++i)
1717  	{
1718  		auto const &amp; key = keys[i];
1719  		auto const &amp; latest = open_blocks[i];
1720  		auto send2 = builder.make_block ()
1721  					 .account (key.pub)
1722  					 .previous (latest-&gt;hash ())
1723  					 .balance (0)
1724  					 .representative (key.pub)
1725  					 .link (key.pub)
1726  					 .sign (key.prv, key.pub)
1727  					 .work (*system.work.generate (nano::work_version::work_1, latest-&gt;hash (), send_threshold))
1728  					 .build ();
1729  		send_blocks2.push_back (std::move (send2));
1730  	}
1731  	std::cout &lt;&lt; &quot;Send2 blocks built, start processing&quot; &lt;&lt; std::endl;
1732  	timer.restart ();
1733  	process_all (send_blocks2);
1734  	std::cout &lt;&lt; &quot;Send2 blocks time: &quot; &lt;&lt; timer.stop ().count () &lt;&lt; &quot; &quot; &lt;&lt; timer.unit () &lt;&lt; &quot;\n\n&quot;;
1735  	std::vector&lt;std::shared_ptr&lt;nano::state_block&gt;&gt; receive_blocks;
1736  	for (auto i = 0; i &lt; num_blocks; ++i)
1737  	{
1738  		auto const &amp; key = keys[i];
1739  		auto const &amp; latest = send_blocks2[i];
1740  		auto send2 = builder.make_block ()
1741  					 .account (key.pub)
1742  					 .previous (latest-&gt;hash ())
1743  					 .balance (1)
1744  					 .representative (key.pub)
1745  					 .link (latest-&gt;hash ())
1746  					 .sign (key.prv, key.pub)
1747  					 .work (*system.work.generate (nano::work_version::work_1, latest-&gt;hash (), receive_threshold))
1748  					 .build ();
1749  		receive_blocks.push_back (std::move (send2));
1750  	}
1751  	std::cout &lt;&lt; &quot;Receive blocks built, start processing&quot; &lt;&lt; std::endl;
1752  	timer.restart ();
1753  	process_all (receive_blocks);
1754  	std::cout &lt;&lt; &quot;Receive blocks time: &quot; &lt;&lt; timer.stop ().count () &lt;&lt; &quot; &quot; &lt;&lt; timer.unit () &lt;&lt; &quot;\n\n&quot;;
1755  }
1756  TEST (node, aggressive_flooding)
1757  {
1758  	nano::test::system system;
1759  	nano::node_flags node_flags;
1760  	node_flags.disable_request_loop = true;
1761  	node_flags.disable_bootstrap_bulk_push_client = true;
1762  	node_flags.disable_bootstrap_bulk_pull_server = true;
1763  	node_flags.disable_bootstrap_listener = true;
1764  	node_flags.disable_lazy_bootstrap = true;
1765  	node_flags.disable_legacy_bootstrap = true;
1766  	node_flags.disable_wallet_bootstrap = true;
1767  	node_flags.disable_ascending_bootstrap = true;
1768  	auto &amp; node1 (*system.add_node (node_flags));
1769  	auto &amp; wallet1 (*system.wallet (0));
1770  	wallet1.insert_adhoc (nano::dev::genesis_key.prv);
1771  	std::vector&lt;std::pair&lt;std::shared_ptr&lt;nano::node&gt;, std::shared_ptr&lt;nano::wallet&gt;&gt;&gt; nodes_wallets;
1772  	nodes_wallets.resize (!nano::memory_intensive_instrumentation () ? 5 : 3);
1773  	std::generate (nodes_wallets.begin (), nodes_wallets.end (), [&amp;system, node_flags] () {
1774  		nano::node_config node_config = system.default_config ();
1775  		auto node (system.add_node (node_config, node_flags));
1776  		return std::make_pair (node, system.wallet (system.nodes.size () - 1));
1777  	});
1778  	ASSERT_TIMELY (5s, node1.network.size () == nodes_wallets.size ());
1779  	ASSERT_LT (node1.network.fanout (), nodes_wallets.size ());
1780  	ASSERT_TIMELY (10s, std::all_of (nodes_wallets.begin (), nodes_wallets.end (), [] (auto const &amp; node_wallet) { return node_wallet.first-&gt;rep_crawler.principal_representatives ().size () != 0; }));
1781  	auto large_amount = (nano::dev::constants.genesis_amount / 2) / nodes_wallets.size ();
1782  	std::vector&lt;std::shared_ptr&lt;nano::block&gt;&gt; genesis_blocks;
1783  	for (auto &amp; node_wallet : nodes_wallets)
1784  	{
1785  		nano::keypair keypair;
1786  		node_wallet.second-&gt;store.representative_set (node_wallet.first-&gt;wallets.tx_begin_write (), keypair.pub);
1787  		node_wallet.second-&gt;insert_adhoc (keypair.prv);
1788  		auto block (wallet1.send_action (nano::dev::genesis_key.pub, keypair.pub, large_amount));
1789  		ASSERT_NE (nullptr, block);
1790  		genesis_blocks.push_back (block);
1791  	}
1792  	for (auto &amp; node_wallet : nodes_wallets)
1793  	{
1794  		for (auto const &amp; block : genesis_blocks)
1795  		{
1796  			auto process_result (node_wallet.first-&gt;process (*block));
1797  			ASSERT_TRUE (nano::process_result::progress == process_result.code || nano::process_result::old == process_result.code);
1798  		}
1799  		ASSERT_EQ (node1.latest (nano::dev::genesis_key.pub), node_wallet.first-&gt;latest (nano::dev::genesis_key.pub));
1800  		ASSERT_EQ (genesis_blocks.back ()-&gt;hash (), node_wallet.first-&gt;latest (nano::dev::genesis_key.pub));
1801  		nano::test::start_elections (system, *node_wallet.first, { genesis_blocks.back () }, true);
1802  	}
1803  	nano::test::start_elections (system, node1, { genesis_blocks.back () }, true);
1804  	auto all_received = [&amp;nodes_wallets] () {
1805  		return std::all_of (nodes_wallets.begin (), nodes_wallets.end (), [] (auto const &amp; node_wallet) {
1806  			auto local_representative (node_wallet.second-&gt;store.representative (node_wallet.first-&gt;wallets.tx_begin_read ()));
1807  			return node_wallet.first-&gt;ledger.account_balance (node_wallet.first-&gt;store.tx_begin_read (), local_representative) &gt; 0;
1808  		});
1809  	};
1810  	ASSERT_TIMELY (!nano::slow_instrumentation () ? 10s : 40s, all_received ());
1811  	ASSERT_TIMELY (!nano::slow_instrumentation () ? 10s : 40s, node1.ledger.cache.block_count == 1 + 2 * nodes_wallets.size ());
1812  	ASSERT_TIMELY (!nano::slow_instrumentation () ? 10s : 40s, node1.rep_crawler.principal_representatives ().size () == nodes_wallets.size ());
1813  	nano::state_block_builder builder;
1814  	std::shared_ptr&lt;nano::state_block&gt; block{};
1815  	{
1816  		auto transaction (node1.store.tx_begin_read ());
1817  		block = builder.make_block ()
1818  				.account (nano::dev::genesis_key.pub)
1819  				.representative (nano::dev::genesis_key.pub)
1820  				.previous (node1.ledger.latest (transaction, nano::dev::genesis_key.pub))
1821  				.balance (node1.ledger.account_balance (transaction, nano::dev::genesis_key.pub) - 1)
1822  				.link (nano::dev::genesis_key.pub)
1823  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1824  				.work (*node1.work_generate_blocking (node1.ledger.latest (transaction, nano::dev::genesis_key.pub)))
1825  				.build ();
1826  	}
1827  	ASSERT_EQ (nano::process_result::progress, node1.process_local (block).value ().code);
1828  	auto all_have_block = [&amp;nodes_wallets] (nano::block_hash const &amp; hash_a) {
1829  		return std::all_of (nodes_wallets.begin (), nodes_wallets.end (), [hash = hash_a] (auto const &amp; node_wallet) {
1830  			return node_wallet.first-&gt;block (hash) != nullptr;
1831  		});
1832  	};
1833  	ASSERT_TIMELY (!nano::slow_instrumentation () ? 5s : 25s, all_have_block (block-&gt;hash ()));
1834  	auto wallet_block = wallet1.send_sync (nano::dev::genesis_key.pub, nano::dev::genesis_key.pub, 10);
1835  	ASSERT_TIMELY (!nano::slow_instrumentation () ? 5s : 25s, all_have_block (wallet_block));
1836  	ASSERT_EQ (1 + 2 * nodes_wallets.size () + 2, node1.ledger.cache.block_count);
1837  }
1838  TEST (node, send_single_many_peers)
1839  {
1840  	nano::test::system system (nano::memory_intensive_instrumentation () ? 4 : 10);
1841  	nano::keypair key2;
1842  	system.wallet (0)-&gt;insert_adhoc (nano::dev::genesis_key.prv);
1843  	system.wallet (1)-&gt;insert_adhoc (key2.prv);
1844  	ASSERT_NE (nullptr, system.wallet (0)-&gt;send_action (nano::dev::genesis_key.pub, key2.pub, system.nodes[0]-&gt;config.receive_minimum.number ()));
1845  	ASSERT_EQ (std::numeric_limits&lt;nano::uint128_t&gt;::max () - system.nodes[0]-&gt;config.receive_minimum.number (), system.nodes[0]-&gt;balance (nano::dev::genesis_key.pub));
1846  	ASSERT_TRUE (system.nodes[0]-&gt;balance (key2.pub).is_zero ());
1847  	ASSERT_TIMELY (3.5min, std::all_of (system.nodes.begin (), system.nodes.end (), [&amp;] (std::shared_ptr&lt;nano::node&gt; const &amp; node_a) { return !node_a-&gt;balance (key2.pub).is_zero (); }));
1848  	system.stop ();
1849  	for (auto node : system.nodes)
1850  	{
1851  		ASSERT_TRUE (node-&gt;stopped);
1852  	}
1853  }
1854  }
1855  TEST (node, wallet_create_block_confirm_conflicts)
1856  {
1857  	for (int i = 0; i &lt; 5; ++i)
1858  	{
1859  		nano::test::system system;
1860  		nano::block_builder builder;
1861  		nano::node_config node_config (system.get_available_port (), system.logging);
1862  		node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
1863  		auto node = system.add_node (node_config);
1864  		auto const num_blocks = 10000;
1865  		auto latest = nano::dev::genesis-&gt;hash ();
1866  		nano::keypair key1;
1867  		{
1868  			auto transaction = node-&gt;store.tx_begin_write ();
1869  			for (auto i = num_blocks - 1; i &gt; 0; --i)
1870  			{
1871  				auto send = builder
1872  							.send ()
1873  							.previous (latest)
1874  							.destination (key1.pub)
1875  							.balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio + i + 1)
1876  							.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1877  							.work (*system.work.generate (latest))
1878  							.build ();
1879  				ASSERT_EQ (nano::process_result::progress, node-&gt;ledger.process (transaction, *send).code);
1880  				latest = send-&gt;hash ();
1881  			}
1882  		}
1883  		std::atomic&lt;bool&gt; done{ false };
1884  		std::thread t ([node, &amp;done] () {
1885  			while (!done)
1886  			{
1887  				node-&gt;wallets.create (nano::random_wallet_id ());
1888  			}
1889  		});
1890  		{
1891  			auto block = node-&gt;store.block.get (node-&gt;store.tx_begin_read (), latest);
1892  			node-&gt;scheduler.buckets.manual (block);
1893  			std::shared_ptr&lt;nano::election&gt; election;
1894  			ASSERT_TIMELY (10s, (election = node-&gt;active.election (block-&gt;qualified_root ())) != nullptr);
1895  			election-&gt;force_confirm ();
1896  		}
1897  		ASSERT_TIMELY (120s, node-&gt;ledger.block_confirmed (node-&gt;store.tx_begin_read (), latest) &amp;&amp; node-&gt;confirmation_height_processor.current () == 0);
1898  		done = true;
1899  		t.join ();
1900  	}
1901  }
1902  namespace nano
1903  {
1904  TEST (system, block_sequence)
1905  {
1906  	size_t const block_count = 400;
1907  	size_t const pr_count = 4;
1908  	size_t const listeners_per_pr = 0;
1909  	nano::test::system system;
1910  	std::vector&lt;nano::keypair&gt; reps;
1911  	for (auto i = 0; i &lt; pr_count; ++i)
1912  	{
1913  		reps.push_back (nano::keypair{});
1914  	}
1915  	system.ledger_initialization_set (reps, nano::Gxrb_ratio);
1916  	system.deadline_set (3600s);
1917  	nano::node_config config;
1918  	config.peering_port = system.get_available_port ();
1919  	config.enable_voting = true;
1920  	config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
1921  	nano::node_flags flags;
1922  	flags.disable_max_peers_per_ip = true;
1923  	flags.disable_ongoing_bootstrap = true;
1924  	auto root = system.add_node (config, flags);
1925  	auto wallet = root-&gt;wallets.items.begin ()-&gt;second;
1926  	wallet-&gt;insert_adhoc (nano::dev::genesis_key.prv);
1927  	for (auto rep : reps)
1928  	{
1929  		system.wallet (0);
1930  		config.peering_port = system.get_available_port ();
1931  		auto pr = system.add_node (config, flags, nano::transport::transport_type::tcp, rep);
1932  		for (auto j = 0; j &lt; listeners_per_pr; ++j)
1933  		{
1934  			config.peering_port = system.get_available_port ();
1935  			system.add_node (config, flags);
1936  		}
1937  		std::cerr &lt;&lt; rep.pub.to_account () &lt;&lt; &#x27; &#x27; &lt;&lt; pr-&gt;wallets.items.begin ()-&gt;second-&gt;exists (rep.pub) &lt;&lt; pr-&gt;weight (rep.pub) &lt;&lt; &#x27; &#x27; &lt;&lt; &#x27;\n&#x27;;
1938  	}
1939  	while (std::any_of (system.nodes.begin (), system.nodes.end (), [] (std::shared_ptr&lt;nano::node&gt; const &amp; node) {
1940  		return node-&gt;rep_crawler.representative_count () &lt; 3;
1941  	}))
1942  	{
1943  		system.poll ();
1944  	}
1945  	for (auto &amp; node : system.nodes)
1946  	{
1947  		std::cerr &lt;&lt; std::to_string (node-&gt;network.port) &lt;&lt; &quot;: &quot;;
1948  		auto prs = node-&gt;rep_crawler.principal_representatives ();
1949  		for (auto pr : prs)
1950  		{
1951  			std::cerr &lt;&lt; pr.account.to_account () &lt;&lt; &#x27; &#x27;;
1952  		}
1953  		std::cerr &lt;&lt; &#x27;\n&#x27;;
1954  	}
1955  	nano::keypair key;
1956  	auto start = std::chrono::system_clock::now ();
1957  	std::deque&lt;std::shared_ptr&lt;nano::block&gt;&gt; blocks;
1958  	for (auto i = 0; i &lt; block_count; ++i)
1959  	{
1960  		if ((i % 1000) == 0)
1961  		{
1962  			std::cerr &lt;&lt; &quot;Block: &quot; &lt;&lt; std::to_string (i) &lt;&lt; &quot; ms: &quot; &lt;&lt; std::to_string (std::chrono::duration_cast&lt;std::chrono::milliseconds&gt; (std::chrono::system_clock::now () - start).count ()) &lt;&lt; &quot;\n&quot;;
1963  		}
1964  		auto block = wallet-&gt;send_action (nano::dev::genesis_key.pub, key.pub, 1);
1965  		debug_assert (block != nullptr);
1966  		blocks.push_back (block);
1967  	}
1968  	auto done = false;
1969  	std::chrono::system_clock::time_point last;
1970  	auto interval = 1000ms;
1971  	while (!done)
1972  	{
1973  		if (std::chrono::system_clock::now () - last &gt; interval)
1974  		{
1975  			std::string message;
1976  			for (auto i : system.nodes)
1977  			{
1978  				message += boost::str (boost::format (&quot;N:%1% b:%2% c:%3% a:%4% s:%5% p:%6%\n&quot;) % std::to_string (i-&gt;network.port) % std::to_string (i-&gt;ledger.cache.block_count) % std::to_string (i-&gt;ledger.cache.cemented_count) % std::to_string (i-&gt;active.size ()) % std::to_string (i-&gt;scheduler.buckets.size ()) % std::to_string (i-&gt;network.size ()));
1979  				nano::lock_guard&lt;nano::mutex&gt; lock{ i-&gt;active.mutex };
1980  				for (auto const &amp; j : i-&gt;active.roots)
1981  				{
1982  					auto election = j.election;
1983  					if (election-&gt;confirmation_request_count &gt; 10)
1984  					{
1985  						message += boost::str (boost::format (&quot;\t r:%1% i:%2%\n&quot;) % j.root.to_string () % std::to_string (election-&gt;confirmation_request_count));
1986  						for (auto const &amp; k : election-&gt;votes ())
1987  						{
1988  							message += boost::str (boost::format (&quot;\t\t r:%1% t:%2%\n&quot;) % k.first.to_account () % std::to_string (k.second.timestamp));
1989  						}
1990  					}
1991  				}
1992  			}
1993  			std::cerr &lt;&lt; message &lt;&lt; std::endl;
1994  			last = std::chrono::system_clock::now ();
1995  		}
1996  		done = std::all_of (system.nodes.begin (), system.nodes.end (), [&amp;blocks] (std::shared_ptr&lt;nano::node&gt; node) { return node-&gt;block_confirmed (blocks.back ()-&gt;hash ()); });
1997  		system.poll ();
1998  	}
1999  }
2000  } 
</code></pre>
        </div>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-node_6.cpp</h3>
            <pre><code>1  #include &lt;nano/crypto_lib/random_pool.hpp&gt;
2  #include &lt;nano/lib/threading.hpp&gt;
3  #include &lt;nano/node/election.hpp&gt;
4  #include &lt;nano/node/scheduler/buckets.hpp&gt;
5  #include &lt;nano/node/scheduler/component.hpp&gt;
6  #include &lt;nano/node/transport/inproc.hpp&gt;
7  #include &lt;nano/node/unchecked_map.hpp&gt;
8  #include &lt;nano/test_common/network.hpp&gt;
9  #include &lt;nano/test_common/system.hpp&gt;
10  #include &lt;nano/test_common/testutil.hpp&gt;
11  #include &lt;gtest/gtest.h&gt;
12  #include &lt;boost/format.hpp&gt;
13  #include &lt;boost/unordered_set.hpp&gt;
14  #include &lt;numeric&gt;
15  #include &lt;random&gt;
16  using namespace std::chrono_literals;
17  size_t manually_count_pruned_blocks (nano::store &amp; store)
18  {
19  	size_t count = 0;
20  	auto transaction = store.tx_begin_read ();
21  	auto i = store.pruned.begin (transaction);
22  	for (; i != store.pruned.end (); ++i)
23  	{
24  		++count;
25  	}
26  	return count;
27  }
28  TEST (system, generate_mass_activity)
29  {
30  	nano::test::system system;
31  	nano::node_config node_config = system.default_config ();
32  	node_config.enable_voting = false; 
33  	auto node = system.add_node (node_config);
34  	system.wallet (0)-&gt;insert_adhoc (nano::dev::genesis_key.prv);
35  	uint32_t count (20);
36  	system.generate_mass_activity (count, *system.nodes[0]);
37  	auto transaction (system.nodes[0]-&gt;store.tx_begin_read ());
38  	for (auto i (system.nodes[0]-&gt;store.account.begin (transaction)), n (system.nodes[0]-&gt;store.account.end ()); i != n; ++i)
39  	{
40  	}
41  }
42  TEST (system, generate_mass_activity_long)
43  {
44  	nano::test::system system;
45  	nano::node_config node_config = system.default_config ();
46  	node_config.enable_voting = false; 
47  	auto node = system.add_node (node_config);
48  	nano::thread_runner runner (system.io_ctx, system.nodes[0]-&gt;config.io_threads);
49  	system.wallet (0)-&gt;insert_adhoc (nano::dev::genesis_key.prv);
50  	uint32_t count (1000000);
51  	auto count_env_var = std::getenv (&quot;SLOW_TEST_SYSTEM_GENERATE_MASS_ACTIVITY_LONG_COUNT&quot;);
52  	if (count_env_var)
53  	{
54  		count = boost::lexical_cast&lt;uint32_t&gt; (count_env_var);
55  		std::cout &lt;&lt; &quot;count override due to env variable set, count=&quot; &lt;&lt; count &lt;&lt; std::endl;
56  	}
57  	system.generate_mass_activity (count, *system.nodes[0]);
58  	auto transaction (system.nodes[0]-&gt;store.tx_begin_read ());
59  	for (auto i (system.nodes[0]-&gt;store.account.begin (transaction)), n (system.nodes[0]-&gt;store.account.end ()); i != n; ++i)
60  	{
61  	}
62  	system.stop ();
63  	runner.join ();
64  }
65  TEST (system, receive_while_synchronizing)
66  {
67  	std::vector&lt;boost::thread&gt; threads;
68  	{
69  		nano::test::system system;
70  		nano::node_config node_config = system.default_config ();
71  		node_config.enable_voting = false; 
72  		auto node = system.add_node (node_config);
73  		nano::thread_runner runner (system.io_ctx, system.nodes[0]-&gt;config.io_threads);
74  		system.wallet (0)-&gt;insert_adhoc (nano::dev::genesis_key.prv);
<span onclick='openModal()' class='match'>75  		uint32_t count (1000);
76  		system.generate_mass_activity (count, *system.nodes[0]);
77  		nano::keypair key;
</span>78  		auto node1 (std::make_shared&lt;nano::node&gt; (system.io_ctx, system.get_available_port (), nano::unique_path (), system.logging, system.work));
79  		ASSERT_FALSE (node1-&gt;init_error ());
80  		auto wallet (node1-&gt;wallets.create (1));
81  		wallet-&gt;insert_adhoc (nano::dev::genesis_key.prv); 
82  		ASSERT_EQ (key.pub, wallet-&gt;insert_adhoc (key.prv));
83  		node1-&gt;start ();
84  		system.nodes.push_back (node1);
85  		ASSERT_NE (nullptr, nano::test::establish_tcp (system, *node1, node-&gt;network.endpoint ()));
86  		node1-&gt;workers.add_timed_task (std::chrono::steady_clock::now () + std::chrono::milliseconds (200), ([&amp;system, &amp;key] () {
87  			auto hash (system.wallet (0)-&gt;send_sync (nano::dev::genesis_key.pub, key.pub, system.nodes[0]-&gt;config.receive_minimum.number ()));
88  			auto transaction (system.nodes[0]-&gt;store.tx_begin_read ());
89  			auto block (system.nodes[0]-&gt;store.block.get (transaction, hash));
90  			std::string block_text;
91  			block-&gt;serialize_json (block_text);
92  		}));
93  		ASSERT_TIMELY (10s, !node1-&gt;balance (key.pub).is_zero ());
94  		node1-&gt;stop ();
95  		system.stop ();
96  		runner.join ();
97  	}
98  	for (auto i (threads.begin ()), n (threads.end ()); i != n; ++i)
99  	{
100  		i-&gt;join ();
101  	}
102  }
103  TEST (ledger, deep_account_compute)
104  {
105  	nano::logger_mt logger;
106  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
107  	ASSERT_FALSE (store-&gt;init_error ());
108  	nano::stats stats;
109  	nano::ledger ledger (*store, stats, nano::dev::constants);
110  	auto transaction (store-&gt;tx_begin_write ());
111  	store-&gt;initialize (transaction, ledger.cache, ledger.constants);
112  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits&lt;unsigned&gt;::max () };
113  	nano::keypair key;
114  	auto balance (nano::dev::constants.genesis_amount - 1);
115  	nano::block_builder builder;
116  	auto send = builder
117  				.send ()
118  				.previous (nano::dev::genesis-&gt;hash ())
119  				.destination (key.pub)
120  				.balance (balance)
121  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
122  				.work (*pool.generate (nano::dev::genesis-&gt;hash ()))
123  				.build ();
124  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send).code);
125  	auto open = builder
126  				.open ()
127  				.source (send-&gt;hash ())
128  				.representative (nano::dev::genesis_key.pub)
129  				.account (key.pub)
130  				.sign (key.prv, key.pub)
131  				.work (*pool.generate (key.pub))
132  				.build ();
133  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *open).code);
134  	auto sprevious (send-&gt;hash ());
135  	auto rprevious (open-&gt;hash ());
136  	for (auto i (0), n (100000); i != n; ++i)
137  	{
138  		balance -= 1;
139  		auto send = builder
140  					.send ()
141  					.previous (sprevious)
142  					.destination (key.pub)
143  					.balance (balance)
144  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
145  					.work (*pool.generate (sprevious))
146  					.build ();
147  		ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send).code);
148  		sprevious = send-&gt;hash ();
149  		auto receive = builder
150  					   .receive ()
151  					   .previous (rprevious)
152  					   .source (send-&gt;hash ())
153  					   .sign (key.prv, key.pub)
154  					   .work (*pool.generate (rprevious))
155  					   .build ();
156  		ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *receive).code);
157  		rprevious = receive-&gt;hash ();
158  		if (i % 100 == 0)
159  		{
160  			std::cerr &lt;&lt; i &lt;&lt; &#x27; &#x27;;
161  		}
162  		ledger.account (transaction, sprevious);
163  		ledger.balance (transaction, rprevious);
164  	}
165  }
166  TEST (wallet, multithreaded_send_async)
167  {
168  	std::vector&lt;boost::thread&gt; threads;
169  	{
170  		nano::test::system system (1);
171  		nano::keypair key;
172  		auto wallet_l (system.wallet (0));
173  		wallet_l-&gt;insert_adhoc (nano::dev::genesis_key.prv);
174  		wallet_l-&gt;insert_adhoc (key.prv);
175  		int num_of_threads = 20;
176  		int num_of_sends = 1000;
177  		for (auto i (0); i &lt; num_of_threads; ++i)
178  		{
179  			threads.push_back (boost::thread ([wallet_l, &amp;key, num_of_threads, num_of_sends] () {
180  				for (auto i (0); i &lt; num_of_sends; ++i)
181  				{
182  					wallet_l-&gt;send_async (nano::dev::genesis_key.pub, key.pub, 1000, [] (std::shared_ptr&lt;nano::block&gt; const &amp; block_a) {
183  						ASSERT_FALSE (block_a == nullptr);
184  						ASSERT_FALSE (block_a-&gt;hash ().is_zero ());
185  					});
186  				}
187  			}));
188  		}
189  		ASSERT_TIMELY (1000s, system.nodes[0]-&gt;balance (nano::dev::genesis_key.pub) == (nano::dev::constants.genesis_amount - num_of_threads * num_of_sends * 1000));
190  	}
191  	for (auto i (threads.begin ()), n (threads.end ()); i != n; ++i)
192  	{
193  		i-&gt;join ();
194  	}
195  }
196  TEST (store, load)
197  {
198  	nano::test::system system (1);
199  	std::vector&lt;boost::thread&gt; threads;
200  	for (auto i (0); i &lt; 100; ++i)
201  	{
202  		threads.push_back (boost::thread ([&amp;system] () {
203  			for (auto i (0); i != 1000; ++i)
204  			{
205  				auto transaction (system.nodes[0]-&gt;store.tx_begin_write ());
206  				for (auto j (0); j != 10; ++j)
207  				{
208  					nano::account account;
209  					nano::random_pool::generate_block (account.bytes.data (), account.bytes.size ());
210  					system.nodes[0]-&gt;store.confirmation_height.put (transaction, account, { 0, nano::block_hash (0) });
211  					system.nodes[0]-&gt;store.account.put (transaction, account, nano::account_info ());
212  				}
213  			}
214  		}));
215  	}
216  	for (auto &amp; i : threads)
217  	{
218  		i.join ();
219  	}
220  }
221  namespace nano
222  {
223  TEST (node, fork_storm)
224  {
225  	static const auto node_count (23);
226  	nano::node_flags flags;
227  	flags.disable_max_peers_per_ip = true;
228  	nano::test::system system (node_count, nano::transport::transport_type::tcp, flags);
229  	system.wallet (0)-&gt;insert_adhoc (nano::dev::genesis_key.prv);
230  	auto previous (system.nodes[0]-&gt;latest (nano::dev::genesis_key.pub));
231  	auto balance (system.nodes[0]-&gt;balance (nano::dev::genesis_key.pub));
232  	ASSERT_FALSE (previous.is_zero ());
233  	nano::block_builder builder;
234  	for (auto node_j : system.nodes)
235  	{
236  		balance -= 1;
237  		nano::keypair key;
238  		auto send = builder
239  					.send ()
240  					.previous (previous)
241  					.destination (key.pub)
242  					.balance (balance)
243  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
244  					.work (0)
245  					.build ();
246  		node_j-&gt;work_generate_blocking (*send);
247  		previous = send-&gt;hash ();
248  		for (auto node_i : system.nodes)
249  		{
250  			auto send_result (node_i-&gt;process (*send));
251  			ASSERT_EQ (nano::process_result::progress, send_result.code);
252  			nano::keypair rep;
253  			auto open = builder
254  						.open ()
255  						.source (previous)
256  						.representative (rep.pub)
257  						.account (key.pub)
258  						.sign (key.prv, key.pub)
259  						.work (0)
260  						.build_shared ();
261  			node_i-&gt;work_generate_blocking (*open);
262  			auto open_result (node_i-&gt;process (*open));
263  			ASSERT_EQ (nano::process_result::progress, open_result.code);
264  			auto transaction (node_i-&gt;store.tx_begin_read ());
265  			node_i-&gt;network.flood_block (open);
266  		}
267  	}
268  	auto again (true);
269  	int iteration (0);
270  	auto old_empty (0);
271  	auto old_single (0);
272  	auto stall_count (0);
273  	while (again)
274  	{
275  		auto empty = 0;
276  		auto single = 0;
277  		std::for_each (system.nodes.begin (), system.nodes.end (), [&amp;] (std::shared_ptr&lt;nano::node&gt; const &amp; node_a) {
278  			if (node_a-&gt;active.empty ())
279  			{
280  				++empty;
281  			}
282  			else
283  			{
284  				nano::unique_lock&lt;nano::mutex&gt; lock{ node_a-&gt;active.mutex };
285  				auto election = node_a-&gt;active.roots.begin ()-&gt;election;
286  				lock.unlock ();
287  				if (election-&gt;votes ().size () == 1)
288  				{
289  					++single;
290  				}
291  			}
292  		});
293  		ASSERT_NO_ERROR (system.poll ());
294  		if (old_empty == empty &amp;&amp; old_single == single)
295  		{
296  			static const auto stall_tolerance (100000);
297  			++stall_count;
298  			ASSERT_LE (stall_count, stall_tolerance) &lt;&lt; &quot;Stall deteceted. These values were both expected to eventually reach 0 but have remained unchanged for &quot; &lt;&lt; stall_tolerance &lt;&lt; &quot; iterations. Empty: &quot; &lt;&lt; empty &lt;&lt; &quot; single: &quot; &lt;&lt; single &lt;&lt; std::endl;
299  		}
300  		else
301  		{
302  			stall_count = 0;
303  			old_empty = empty;
304  			old_single = single;
305  		}
306  		again = (empty != 0) || (single != 0);
307  		++iteration;
308  	}
309  	ASSERT_TRUE (true);
310  }
311  } 
312  namespace
313  {
314  size_t heard_count (std::vector&lt;uint8_t&gt; const &amp; nodes)
315  {
316  	auto result (0);
317  	for (auto i (nodes.begin ()), n (nodes.end ()); i != n; ++i)
318  	{
319  		switch (*i)
320  		{
321  			case 0:
322  				break;
323  			case 1:
324  				++result;
325  				break;
326  			case 2:
327  				++result;
328  				break;
329  		}
330  	}
331  	return result;
332  }
333  }
334  TEST (broadcast, world_broadcast_simulate)
335  {
336  	auto node_count (10000);
337  	std::vector&lt;uint8_t&gt; nodes;
338  	nodes.resize (node_count, 0);
339  	nodes[0] = 1;
340  	auto any_changed (true);
341  	auto message_count (0);
342  	while (any_changed)
343  	{
344  		any_changed = false;
345  		for (auto i (nodes.begin ()), n (nodes.end ()); i != n; ++i)
346  		{
347  			switch (*i)
348  			{
349  				case 0:
350  					break;
351  				case 1:
352  					for (auto j (nodes.begin ()), m (nodes.end ()); j != m; ++j)
353  					{
354  						++message_count;
355  						switch (*j)
356  						{
357  							case 0:
358  								*j = 1;
359  								any_changed = true;
360  								break;
361  							case 1:
362  								break;
363  							case 2:
364  								break;
365  						}
366  					}
367  					*i = 2;
368  					any_changed = true;
369  					break;
370  				case 2:
371  					break;
372  				default:
373  					ASSERT_FALSE (true);
374  					break;
375  			}
376  		}
377  	}
378  	auto count (heard_count (nodes));
379  	(void)count;
380  }
381  TEST (broadcast, sqrt_broadcast_simulate)
382  {
383  	auto node_count (10000);
384  	auto broadcast_count (std::ceil (std::sqrt (node_count)));
385  	std::vector&lt;uint8_t&gt; nodes;
386  	nodes.resize (node_count, 0);
387  	nodes[0] = 1;
388  	auto any_changed (true);
389  	uint64_t message_count (0);
390  	while (any_changed)
391  	{
392  		any_changed = false;
393  		for (auto i (nodes.begin ()), n (nodes.end ()); i != n; ++i)
394  		{
395  			switch (*i)
396  			{
397  				case 0:
398  					break;
399  				case 1:
400  					for (auto j (0); j != broadcast_count; ++j)
401  					{
402  						++message_count;
403  						auto entry (nano::random_pool::generate_word32 (0, node_count - 1));
404  						switch (nodes[entry])
405  						{
406  							case 0:
407  								nodes[entry] = 1;
408  								any_changed = true;
409  								break;
410  							case 1:
411  								break;
412  							case 2:
413  								break;
414  						}
415  					}
416  					*i = 2;
417  					any_changed = true;
418  					break;
419  				case 2:
420  					break;
421  				default:
422  					ASSERT_FALSE (true);
423  					break;
424  			}
425  		}
426  	}
427  	auto count (heard_count (nodes));
428  	(void)count;
429  }
430  TEST (peer_container, random_set)
431  {
432  	nano::test::system system (1);
433  	auto old (std::chrono::steady_clock::now ());
434  	auto current (std::chrono::steady_clock::now ());
435  	for (auto i (0); i &lt; 10000; ++i)
436  	{
437  		auto list (system.nodes[0]-&gt;network.random_set (15));
438  	}
439  	auto end (std::chrono::steady_clock::now ());
440  	(void)end;
441  	auto old_ms (std::chrono::duration_cast&lt;std::chrono::milliseconds&gt; (current - old));
442  	(void)old_ms;
443  	auto new_ms (std::chrono::duration_cast&lt;std::chrono::milliseconds&gt; (end - current));
444  	(void)new_ms;
445  }
446  TEST (store, unchecked_load)
447  {
448  	nano::test::system system{ 1 };
449  	auto &amp; node = *system.nodes[0];
450  	nano::block_builder builder;
451  	std::shared_ptr&lt;nano::block&gt; block = builder
452  										 .send ()
453  										 .previous (0)
454  										 .destination (0)
455  										 .balance (0)
456  										 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
457  										 .work (0)
458  										 .build_shared ();
459  	constexpr auto num_unchecked = 1&#x27;000&#x27;000;
460  	for (auto i (0); i &lt; num_unchecked; ++i)
461  	{
462  		node.unchecked.put (i, block);
463  	}
464  	ASSERT_TIMELY (8000s, num_unchecked == node.unchecked.count ());
465  }
466  TEST (store, vote_load)
467  {
468  	nano::test::system system{ 1 };
469  	auto &amp; node = *system.nodes[0];
470  	for (auto i = 0u; i &lt; 1000000u; ++i)
471  	{
472  		auto vote = std::make_shared&lt;nano::vote&gt; (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, i, 0, std::vector&lt;nano::block_hash&gt;{ i });
473  		node.vote_processor.vote (vote, std::make_shared&lt;nano::transport::inproc::channel&gt; (node, node));
474  	}
475  }
476  TEST (store, pruned_load)
477  {
478  	nano::logger_mt logger;
479  	auto path (nano::unique_path ());
480  	constexpr auto num_pruned = 2000000;
481  	auto const expected_result = num_pruned / 2;
482  	constexpr auto batch_size = 20;
483  	boost::unordered_set&lt;nano::block_hash&gt; hashes;
484  	{
485  		auto store = nano::make_store (logger, path, nano::dev::constants);
486  		ASSERT_FALSE (store-&gt;init_error ());
487  		for (auto i (0); i &lt; num_pruned / batch_size; ++i)
488  		{
489  			{
490  				auto transaction (store-&gt;tx_begin_write ());
491  				for (auto k (0); k &lt; batch_size; ++k)
492  				{
493  					nano::block_hash random_hash;
494  					nano::random_pool::generate_block (random_hash.bytes.data (), random_hash.bytes.size ());
495  					store-&gt;pruned.put (transaction, random_hash);
496  					hashes.insert (random_hash);
497  				}
498  			}
499  			{
500  				auto transaction (store-&gt;tx_begin_write ());
501  				for (auto k (0); !hashes.empty () &amp;&amp; k &lt; batch_size / 2; ++k)
502  				{
503  					auto hash (hashes.begin ());
504  					store-&gt;pruned.del (transaction, *hash);
505  					hashes.erase (hash);
506  				}
507  			}
508  		}
509  		ASSERT_EQ (expected_result, manually_count_pruned_blocks (*store));
510  	}
511  	{
512  		auto store = nano::make_store (logger, path, nano::dev::constants);
513  		ASSERT_FALSE (store-&gt;init_error ());
514  		ASSERT_EQ (expected_result, manually_count_pruned_blocks (*store));
515  	}
516  }
517  TEST (wallets, rep_scan)
518  {
519  	nano::test::system system (1);
520  	auto &amp; node (*system.nodes[0]);
521  	auto wallet (system.wallet (0));
522  	{
523  		auto transaction (node.wallets.tx_begin_write ());
524  		for (auto i (0); i &lt; 10000; ++i)
525  		{
526  			wallet-&gt;deterministic_insert (transaction);
527  		}
528  	}
529  	auto begin (std::chrono::steady_clock::now ());
530  	node.wallets.foreach_representative ([] (nano::public_key const &amp; pub_a, nano::raw_key const &amp; prv_a) {
531  	});
532  	ASSERT_LT (std::chrono::steady_clock::now () - begin, std::chrono::milliseconds (5));
533  }
534  TEST (node, mass_vote_by_hash)
535  {
536  	nano::test::system system (1);
537  	system.wallet (0)-&gt;insert_adhoc (nano::dev::genesis_key.prv);
538  	nano::block_hash previous (nano::dev::genesis-&gt;hash ());
539  	nano::keypair key;
540  	std::vector&lt;std::shared_ptr&lt;nano::state_block&gt;&gt; blocks;
541  	nano::block_builder builder;
542  	for (auto i (0); i &lt; 10000; ++i)
543  	{
544  		auto block = builder
545  					 .state ()
546  					 .account (nano::dev::genesis_key.pub)
547  					 .previous (previous)
548  					 .representative (nano::dev::genesis_key.pub)
549  					 .balance (nano::dev::constants.genesis_amount - (i + 1) * nano::Gxrb_ratio)
550  					 .link (key.pub)
551  					 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
552  					 .work (*system.work.generate (previous))
553  					 .build_shared ();
554  		previous = block-&gt;hash ();
555  		blocks.push_back (block);
556  	}
557  	for (auto i (blocks.begin ()), n (blocks.end ()); i != n; ++i)
558  	{
559  		system.nodes[0]-&gt;block_processor.add (*i);
560  	}
561  }
562  namespace nano
563  {
564  TEST (confirmation_height, many_accounts_single_confirmation)
565  {
566  	nano::test::system system;
567  	nano::node_config node_config = system.default_config ();
568  	node_config.online_weight_minimum = 100;
569  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
570  	auto node = system.add_node (node_config);
571  	system.wallet (0)-&gt;insert_adhoc (nano::dev::genesis_key.prv);
572  	node-&gt;confirmation_height_processor.batch_write_size = 500;
573  	auto const num_accounts = nano::confirmation_height::unbounded_cutoff * 2 + 50;
574  	nano::keypair last_keypair = nano::dev::genesis_key;
575  	nano::block_builder builder;
576  	auto last_open_hash = node-&gt;latest (nano::dev::genesis_key.pub);
577  	{
578  		auto transaction = node-&gt;store.tx_begin_write ();
579  		for (auto i = num_accounts - 1; i &gt; 0; --i)
580  		{
581  			nano::keypair key;
582  			system.wallet (0)-&gt;insert_adhoc (key.prv);
583  			auto send = builder
584  						.send ()
585  						.previous (last_open_hash)
586  						.destination (key.pub)
587  						.balance (node-&gt;online_reps.delta ())
588  						.sign (last_keypair.prv, last_keypair.pub)
589  						.work (*system.work.generate (last_open_hash))
590  						.build ();
591  			ASSERT_EQ (nano::process_result::progress, node-&gt;ledger.process (transaction, *send).code);
592  			auto open = builder
593  						.open ()
594  						.source (send-&gt;hash ())
595  						.representative (last_keypair.pub)
596  						.account (key.pub)
597  						.sign (key.prv, key.pub)
598  						.work (*system.work.generate (key.pub))
599  						.build ();
600  			ASSERT_EQ (nano::process_result::progress, node-&gt;ledger.process (transaction, *open).code);
601  			last_open_hash = open-&gt;hash ();
602  			last_keypair = key;
603  		}
604  	}
605  	{
606  		auto block = node-&gt;block (last_open_hash);
607  		ASSERT_NE (nullptr, block);
608  		node-&gt;scheduler.buckets.manual (block);
609  		std::shared_ptr&lt;nano::election&gt; election;
610  		ASSERT_TIMELY (10s, (election = node-&gt;active.election (block-&gt;qualified_root ())) != nullptr);
611  		election-&gt;force_confirm ();
612  	}
613  	ASSERT_TIMELY (120s, node-&gt;ledger.block_confirmed (node-&gt;store.tx_begin_read (), last_open_hash));
614  	auto transaction = node-&gt;store.tx_begin_read ();
615  	for (auto i (node-&gt;store.account.begin (transaction)), n (node-&gt;store.account.end ()); i != n; ++i)
616  	{
617  		auto &amp; account = i-&gt;first;
618  		auto &amp; account_info = i-&gt;second;
619  		auto count = (account != last_keypair.pub) ? 2 : 1;
620  		nano::confirmation_height_info confirmation_height_info;
621  		ASSERT_FALSE (node-&gt;store.confirmation_height.get (transaction, account, confirmation_height_info));
622  		ASSERT_EQ (count, confirmation_height_info.height);
623  		ASSERT_EQ (count, account_info.block_count);
624  	}
625  	size_t cemented_count = 0;
626  	for (auto i (node-&gt;ledger.store.confirmation_height.begin (transaction)), n (node-&gt;ledger.store.confirmation_height.end ()); i != n; ++i)
627  	{
628  		cemented_count += i-&gt;second.height;
629  	}
630  	ASSERT_EQ (cemented_count, node-&gt;ledger.cache.cemented_count);
631  	ASSERT_EQ (node-&gt;ledger.stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed, nano::stat::dir::in), num_accounts * 2 - 2);
632  	ASSERT_EQ (node-&gt;ledger.stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed_bounded, nano::stat::dir::in), num_accounts * 2 - 2);
633  	ASSERT_EQ (node-&gt;ledger.stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed_unbounded, nano::stat::dir::in), 0);
634  	ASSERT_TIMELY (40s, (node-&gt;ledger.cache.cemented_count - 1) == node-&gt;stats.count (nano::stat::type::confirmation_observer, nano::stat::detail::all, nano::stat::dir::out));
635  	ASSERT_TIMELY (10s, node-&gt;active.election_winner_details_size () == 0);
636  }
637  TEST (confirmation_height, many_accounts_many_confirmations)
638  {
639  	nano::test::system system;
640  	nano::node_config node_config = system.default_config ();
641  	node_config.online_weight_minimum = 100;
642  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
643  	auto node = system.add_node (node_config);
644  	system.wallet (0)-&gt;insert_adhoc (nano::dev::genesis_key.prv);
645  	node-&gt;confirmation_height_processor.batch_write_size = 500;
646  	auto const num_accounts = nano::confirmation_height::unbounded_cutoff * 2 + 50;
647  	auto latest_genesis = node-&gt;latest (nano::dev::genesis_key.pub);
648  	nano::block_builder builder;
649  	std::vector&lt;std::shared_ptr&lt;nano::open_block&gt;&gt; open_blocks;
650  	{
651  		auto transaction = node-&gt;store.tx_begin_write ();
652  		for (auto i = num_accounts - 1; i &gt; 0; --i)
653  		{
654  			nano::keypair key;
655  			system.wallet (0)-&gt;insert_adhoc (key.prv);
656  			auto send = builder
657  						.send ()
658  						.previous (latest_genesis)
659  						.destination (key.pub)
660  						.balance (node-&gt;online_reps.delta ())
661  						.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
662  						.work (*system.work.generate (latest_genesis))
663  						.build ();
664  			ASSERT_EQ (nano::process_result::progress, node-&gt;ledger.process (transaction, *send).code);
665  			auto open = builder
666  						.open ()
667  						.source (send-&gt;hash ())
668  						.representative (nano::dev::genesis_key.pub)
669  						.account (key.pub)
670  						.sign (key.prv, key.pub)
671  						.work (*system.work.generate (key.pub))
672  						.build_shared ();
673  			ASSERT_EQ (nano::process_result::progress, node-&gt;ledger.process (transaction, *open).code);
674  			open_blocks.push_back (std::move (open));
675  			latest_genesis = send-&gt;hash ();
676  		}
677  	}
678  	for (auto &amp; open_block : open_blocks)
679  	{
680  		node-&gt;scheduler.buckets.manual (open_block);
681  		std::shared_ptr&lt;nano::election&gt; election;
682  		ASSERT_TIMELY (10s, (election = node-&gt;active.election (open_block-&gt;qualified_root ())) != nullptr);
683  		election-&gt;force_confirm ();
684  	}
685  	auto const num_blocks_to_confirm = (num_accounts - 1) * 2;
686  	ASSERT_TIMELY (1500s, node-&gt;stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed, nano::stat::dir::in) == num_blocks_to_confirm);
687  	auto num_confirmed_bounded = node-&gt;ledger.stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed_bounded, nano::stat::dir::in);
688  	ASSERT_GE (num_confirmed_bounded, nano::confirmation_height::unbounded_cutoff);
689  	ASSERT_EQ (node-&gt;ledger.stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed_unbounded, nano::stat::dir::in), num_blocks_to_confirm - num_confirmed_bounded);
690  	ASSERT_TIMELY (60s, (node-&gt;ledger.cache.cemented_count - 1) == node-&gt;stats.count (nano::stat::type::confirmation_observer, nano::stat::detail::all, nano::stat::dir::out));
691  	auto transaction = node-&gt;store.tx_begin_read ();
692  	size_t cemented_count = 0;
693  	for (auto i (node-&gt;ledger.store.confirmation_height.begin (transaction)), n (node-&gt;ledger.store.confirmation_height.end ()); i != n; ++i)
694  	{
695  		cemented_count += i-&gt;second.height;
696  	}
697  	ASSERT_EQ (num_blocks_to_confirm + 1, cemented_count);
698  	ASSERT_EQ (cemented_count, node-&gt;ledger.cache.cemented_count);
699  	ASSERT_TIMELY (20s, (node-&gt;ledger.cache.cemented_count - 1) == node-&gt;stats.count (nano::stat::type::confirmation_observer, nano::stat::detail::all, nano::stat::dir::out));
700  	ASSERT_TIMELY (10s, node-&gt;active.election_winner_details_size () == 0);
701  }
702  TEST (confirmation_height, long_chains)
703  {
704  	nano::test::system system;
705  	nano::node_config node_config = system.default_config ();
706  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
707  	auto node = system.add_node (node_config);
708  	nano::keypair key1;
709  	system.wallet (0)-&gt;insert_adhoc (nano::dev::genesis_key.prv);
710  	nano::block_hash latest (node-&gt;latest (nano::dev::genesis_key.pub));
711  	system.wallet (0)-&gt;insert_adhoc (key1.prv);
712  	node-&gt;confirmation_height_processor.batch_write_size = 500;
713  	auto const num_blocks = nano::confirmation_height::unbounded_cutoff * 2 + 50;
714  	nano::block_builder builder;
715  	auto send = builder
716  				.send ()
717  				.previous (latest)
718  				.destination (key1.pub)
719  				.balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio + num_blocks + 1)
720  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
721  				.work (*system.work.generate (latest))
722  				.build ();
723  	auto open = builder
724  				.open ()
725  				.source (send-&gt;hash ())
726  				.representative (nano::dev::genesis-&gt;account ())
727  				.account (key1.pub)
728  				.sign (key1.prv, key1.pub)
729  				.work (*system.work.generate (key1.pub))
730  				.build ();
731  	{
732  		auto transaction = node-&gt;store.tx_begin_write ();
733  		ASSERT_EQ (nano::process_result::progress, node-&gt;ledger.process (transaction, *send).code);
734  		ASSERT_EQ (nano::process_result::progress, node-&gt;ledger.process (transaction, *open).code);
735  	}
736  	auto previous_genesis_chain_hash = send-&gt;hash ();
737  	auto previous_destination_chain_hash = open-&gt;hash ();
738  	{
739  		auto transaction = node-&gt;store.tx_begin_write ();
740  		for (auto i = num_blocks - 1; i &gt; 0; --i)
741  		{
742  			auto send = builder
743  						.send ()
744  						.previous (previous_genesis_chain_hash)
745  						.destination (key1.pub)
746  						.balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio + i + 1)
747  						.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
748  						.work (*system.work.generate (previous_genesis_chain_hash))
749  						.build ();
750  			ASSERT_EQ (nano::process_result::progress, node-&gt;ledger.process (transaction, *send).code);
751  			auto receive = builder
752  						   .receive ()
753  						   .previous (previous_destination_chain_hash)
754  						   .source (send-&gt;hash ())
755  						   .sign (key1.prv, key1.pub)
756  						   .work (*system.work.generate (previous_destination_chain_hash))
757  						   .build ();
758  			ASSERT_EQ (nano::process_result::progress, node-&gt;ledger.process (transaction, *receive).code);
759  			previous_genesis_chain_hash = send-&gt;hash ();
760  			previous_destination_chain_hash = receive-&gt;hash ();
761  		}
762  	}
763  	auto send1 = builder
764  				 .send ()
765  				 .previous (previous_destination_chain_hash)
766  				 .destination (nano::dev::genesis_key.pub)
767  				 .balance (nano::Gxrb_ratio - 2)
768  				 .sign (key1.prv, key1.pub)
769  				 .work (*system.work.generate (previous_destination_chain_hash))
770  				 .build ();
771  	auto receive1 = builder
772  					.state ()
773  					.account (nano::dev::genesis_key.pub)
774  					.previous (previous_genesis_chain_hash)
775  					.representative (nano::dev::genesis-&gt;account ())
776  					.balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio + 1)
777  					.link (send1-&gt;hash ())
778  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
779  					.work (*system.work.generate (previous_genesis_chain_hash))
780  					.build_shared ();
781  	nano::keypair key2;
782  	auto send2 = builder
783  				 .state ()
784  				 .account (nano::dev::genesis-&gt;account ())
785  				 .previous (receive1-&gt;hash ())
786  				 .representative (nano::dev::genesis-&gt;account ())
787  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
788  				 .link (key2.pub)
789  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
790  				 .work (*system.work.generate (receive1-&gt;hash ()))
791  				 .build ();
792  	{
793  		auto transaction = node-&gt;store.tx_begin_write ();
794  		ASSERT_EQ (nano::process_result::progress, node-&gt;ledger.process (transaction, *send1).code);
795  		ASSERT_EQ (nano::process_result::progress, node-&gt;ledger.process (transaction, *receive1).code);
796  		ASSERT_EQ (nano::process_result::progress, node-&gt;ledger.process (transaction, *send2).code);
797  	}
798  	{
799  		node-&gt;scheduler.buckets.manual (receive1);
800  		std::shared_ptr&lt;nano::election&gt; election;
801  		ASSERT_TIMELY (10s, (election = node-&gt;active.election (receive1-&gt;qualified_root ())) != nullptr);
802  		election-&gt;force_confirm ();
803  	}
804  	ASSERT_TIMELY (30s, node-&gt;ledger.block_confirmed (node-&gt;store.tx_begin_read (), receive1-&gt;hash ()));
805  	auto transaction (node-&gt;store.tx_begin_read ());
806  	auto info = node-&gt;ledger.account_info (transaction, nano::dev::genesis_key.pub);
807  	ASSERT_TRUE (info);
808  	nano::confirmation_height_info confirmation_height_info;
809  	ASSERT_FALSE (node-&gt;store.confirmation_height.get (transaction, nano::dev::genesis_key.pub, confirmation_height_info));
810  	ASSERT_EQ (num_blocks + 2, confirmation_height_info.height);
811  	ASSERT_EQ (num_blocks + 3, info-&gt;block_count); 
812  	info = node-&gt;ledger.account_info (transaction, key1.pub);
813  	ASSERT_TRUE (info);
814  	ASSERT_FALSE (node-&gt;store.confirmation_height.get (transaction, key1.pub, confirmation_height_info));
815  	ASSERT_EQ (num_blocks + 1, confirmation_height_info.height);
816  	ASSERT_EQ (num_blocks + 1, info-&gt;block_count);
817  	size_t cemented_count = 0;
818  	for (auto i (node-&gt;ledger.store.confirmation_height.begin (transaction)), n (node-&gt;ledger.store.confirmation_height.end ()); i != n; ++i)
819  	{
820  		cemented_count += i-&gt;second.height;
821  	}
822  	ASSERT_EQ (cemented_count, node-&gt;ledger.cache.cemented_count);
823  	ASSERT_EQ (node-&gt;ledger.stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed, nano::stat::dir::in), num_blocks * 2 + 2);
824  	ASSERT_EQ (node-&gt;ledger.stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed_bounded, nano::stat::dir::in), num_blocks * 2 + 2);
825  	ASSERT_EQ (node-&gt;ledger.stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed_unbounded, nano::stat::dir::in), 0);
826  	ASSERT_TIMELY (40s, (node-&gt;ledger.cache.cemented_count - 1) == node-&gt;stats.count (nano::stat::type::confirmation_observer, nano::stat::detail::all, nano::stat::dir::out));
827  	ASSERT_TIMELY (10s, node-&gt;active.election_winner_details_size () == 0);
828  }
829  TEST (confirmation_height, dynamic_algorithm)
830  {
831  	nano::test::system system;
832  	nano::node_config node_config = system.default_config ();
833  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
834  	auto node = system.add_node (node_config);
835  	nano::keypair key;
836  	system.wallet (0)-&gt;insert_adhoc (nano::dev::genesis_key.prv);
837  	auto const num_blocks = nano::confirmation_height::unbounded_cutoff;
838  	auto latest_genesis = nano::dev::genesis;
839  	std::vector&lt;std::shared_ptr&lt;nano::state_block&gt;&gt; state_blocks;
840  	nano::block_builder builder;
841  	for (auto i = 0; i &lt; num_blocks; ++i)
842  	{
843  		auto send = builder
844  					.state ()
845  					.account (nano::dev::genesis_key.pub)
846  					.previous (latest_genesis-&gt;hash ())
847  					.representative (nano::dev::genesis_key.pub)
848  					.balance (nano::dev::constants.genesis_amount - i - 1)
849  					.link (key.pub)
850  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
851  					.work (*system.work.generate (latest_genesis-&gt;hash ()))
852  					.build_shared ();
853  		latest_genesis = send;
854  		state_blocks.push_back (send);
855  	}
856  	{
857  		auto transaction = node-&gt;store.tx_begin_write ();
858  		for (auto const &amp; block : state_blocks)
859  		{
860  			ASSERT_EQ (nano::process_result::progress, node-&gt;ledger.process (transaction, *block).code);
861  		}
862  	}
863  	node-&gt;confirmation_height_processor.add (state_blocks.front ());
864  	ASSERT_TIMELY (20s, node-&gt;ledger.cache.cemented_count == 2);
865  	node-&gt;confirmation_height_processor.add (latest_genesis);
866  	ASSERT_TIMELY (20s, node-&gt;ledger.cache.cemented_count == num_blocks + 1);
867  	ASSERT_EQ (node-&gt;ledger.stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed, nano::stat::dir::in), num_blocks);
868  	ASSERT_EQ (node-&gt;ledger.stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed_bounded, nano::stat::dir::in), 1);
869  	ASSERT_EQ (node-&gt;ledger.stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed_unbounded, nano::stat::dir::in), num_blocks - 1);
870  	ASSERT_TIMELY (10s, node-&gt;active.election_winner_details_size () == 0);
871  }
872  TEST (confirmation_height, dynamic_algorithm_no_transition_while_pending)
873  {
874  	for (auto _ = 0; _ &lt; 3; ++_)
875  	{
876  		nano::test::system system;
877  		nano::node_config node_config = system.default_config ();
878  		node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
879  		nano::node_flags node_flags;
880  		node_flags.force_use_write_database_queue = true;
881  		auto node = system.add_node (node_config, node_flags);
882  		nano::keypair key;
883  		system.wallet (0)-&gt;insert_adhoc (nano::dev::genesis_key.prv);
884  		auto latest_genesis = node-&gt;latest (nano::dev::genesis_key.pub);
885  		std::vector&lt;std::shared_ptr&lt;nano::state_block&gt;&gt; state_blocks;
886  		auto const num_blocks = nano::confirmation_height::unbounded_cutoff - 2;
887  		auto add_block_to_genesis_chain = [&amp;] (nano::write_transaction &amp; transaction) {
888  			static int num = 0;
889  			nano::block_builder builder;
890  			auto send = builder
891  						.state ()
892  						.account (nano::dev::genesis_key.pub)
893  						.previous (latest_genesis)
894  						.representative (nano::dev::genesis_key.pub)
895  						.balance (nano::dev::constants.genesis_amount - num - 1)
896  						.link (key.pub)
897  						.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
898  						.work (*system.work.generate (latest_genesis))
899  						.build_shared ();
900  			latest_genesis = send-&gt;hash ();
901  			state_blocks.push_back (send);
902  			ASSERT_EQ (nano::process_result::progress, node-&gt;ledger.process (transaction, *send).code);
903  			++num;
904  		};
905  		for (auto i = 0; i &lt; num_blocks; ++i)
906  		{
907  			auto transaction = node-&gt;store.tx_begin_write ();
908  			add_block_to_genesis_chain (transaction);
909  		}
910  		{
911  			auto write_guard = node-&gt;write_database_queue.wait (nano::writer::testing);
912  			node-&gt;confirmation_height_processor.add (state_blocks.back ());
913  			nano::timer&lt;&gt; timer;
914  			timer.start ();
915  			while (node-&gt;confirmation_height_processor.current ().is_zero ())
916  			{
917  				ASSERT_LT (timer.since_start (), 2s);
918  			}
919  			node-&gt;confirmation_height_processor.pause ();
920  			timer.restart ();
921  			ASSERT_TIMELY (10s, node-&gt;confirmation_height_processor.unbounded_processor.pending_writes_size != 0);
922  			{
923  				auto transaction = node-&gt;store.tx_begin_write ();
924  				add_block_to_genesis_chain (transaction);
925  				add_block_to_genesis_chain (transaction);
926  			}
927  			node-&gt;confirmation_height_processor.add (state_blocks.front ());
928  			node-&gt;confirmation_height_processor.unpause ();
929  		}
930  		ASSERT_TIMELY (10s, node-&gt;ledger.cache.cemented_count == num_blocks + 1);
931  		ASSERT_EQ (node-&gt;ledger.stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed, nano::stat::dir::in), num_blocks);
932  		ASSERT_EQ (node-&gt;ledger.stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed_bounded, nano::stat::dir::in), 0);
933  		ASSERT_EQ (node-&gt;ledger.stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed_unbounded, nano::stat::dir::in), num_blocks);
934  		ASSERT_TIMELY (10s, node-&gt;active.election_winner_details_size () == 0);
935  	}
936  }
937  TEST (confirmation_height, many_accounts_send_receive_self)
938  {
939  	nano::test::system system;
940  	nano::node_config node_config = system.default_config ();
941  	node_config.online_weight_minimum = 100;
942  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
943  	node_config.active_elections_size = 400000;
944  	nano::node_flags node_flags;
945  	node_flags.confirmation_height_processor_mode = nano::confirmation_height_mode::unbounded;
946  	auto node = system.add_node (node_config);
947  	system.wallet (0)-&gt;insert_adhoc (nano::dev::genesis_key.prv);
948  #ifndef NDEBUG
949  	auto const num_accounts = 10000;
950  #else
951  	auto const num_accounts = 100000;
952  #endif
953  	auto latest_genesis = node-&gt;latest (nano::dev::genesis_key.pub);
954  	std::vector&lt;nano::keypair&gt; keys;
955  	nano::block_builder builder;
956  	std::vector&lt;std::shared_ptr&lt;nano::open_block&gt;&gt; open_blocks;
957  	{
958  		auto transaction = node-&gt;store.tx_begin_write ();
959  		for (auto i = 0; i &lt; num_accounts; ++i)
960  		{
961  			nano::keypair key;
962  			keys.emplace_back (key);
963  			auto send = builder
964  						.send ()
965  						.previous (latest_genesis)
966  						.destination (key.pub)
967  						.balance (nano::dev::constants.genesis_amount - 1 - i)
968  						.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
969  						.work (*system.work.generate (latest_genesis))
970  						.build ();
971  			ASSERT_EQ (nano::process_result::progress, node-&gt;ledger.process (transaction, *send).code);
972  			auto open = builder
973  						.open ()
974  						.source (send-&gt;hash ())
975  						.representative (nano::dev::genesis_key.pub)
976  						.account (key.pub)
977  						.sign (key.prv, key.pub)
978  						.work (*system.work.generate (key.pub))
979  						.build_shared ();
980  			ASSERT_EQ (nano::process_result::progress, node-&gt;ledger.process (transaction, *open).code);
981  			open_blocks.push_back (std::move (open));
982  			latest_genesis = send-&gt;hash ();
983  		}
984  	}
985  	for (auto &amp; open_block : open_blocks)
986  	{
987  		node-&gt;block_confirm (open_block);
988  		std::shared_ptr&lt;nano::election&gt; election;
989  		ASSERT_TIMELY (10s, (election = node-&gt;active.election (open_block-&gt;qualified_root ())) != nullptr);
990  		election-&gt;force_confirm ();
991  	}
992  	system.deadline_set (100s);
993  	auto num_blocks_to_confirm = num_accounts * 2;
994  	while (node-&gt;stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed, nano::stat::dir::in) != num_blocks_to_confirm)
995  	{
996  		ASSERT_NO_ERROR (system.poll ());
997  	}
998  	std::vector&lt;std::shared_ptr&lt;nano::send_block&gt;&gt; send_blocks;
999  	std::vector&lt;std::shared_ptr&lt;nano::receive_block&gt;&gt; receive_blocks;
1000  	for (int i = 0; i &lt; open_blocks.size (); ++i)
1001  	{
1002  		auto open_block = open_blocks[i];
1003  		auto &amp; keypair = keys[i];
1004  		send_blocks.emplace_back (builder
1005  								  .send ()
1006  								  .previous (open_block-&gt;hash ())
1007  								  .destination (keypair.pub)
1008  								  .balance (1)
1009  								  .sign (keypair.prv, keypair.pub)
1010  								  .work (*system.work.generate (open_block-&gt;hash ()))
1011  								  .build_shared ());
1012  		receive_blocks.emplace_back (builder
1013  									 .receive ()
1014  									 .previous (send_blocks.back ()-&gt;hash ())
1015  									 .source (send_blocks.back ()-&gt;hash ())
1016  									 .sign (keypair.prv, keypair.pub)
1017  									 .work (*system.work.generate (send_blocks.back ()-&gt;hash ()))
1018  									 .build_shared ());
1019  	}
1020  	for (int i = 0; i &lt; open_blocks.size (); ++i)
1021  	{
1022  		node-&gt;process_active (send_blocks[i]);
1023  		node-&gt;process_active (receive_blocks[i]);
1024  	}
1025  	system.deadline_set (300s);
1026  	num_blocks_to_confirm = num_accounts * 4;
1027  	while (node-&gt;stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed, nano::stat::dir::in) != num_blocks_to_confirm)
1028  	{
1029  		ASSERT_NO_ERROR (system.poll ());
1030  	}
1031  	system.deadline_set (200s);
1032  	while ((node-&gt;ledger.cache.cemented_count - 1) != node-&gt;stats.count (nano::stat::type::confirmation_observer, nano::stat::detail::all, nano::stat::dir::out))
1033  	{
1034  		ASSERT_NO_ERROR (system.poll ());
1035  	}
1036  	auto transaction = node-&gt;store.tx_begin_read ();
1037  	size_t cemented_count = 0;
1038  	for (auto i (node-&gt;ledger.store.confirmation_height.begin (transaction)), n (node-&gt;ledger.store.confirmation_height.end ()); i != n; ++i)
1039  	{
1040  		cemented_count += i-&gt;second.height;
1041  	}
1042  	ASSERT_EQ (num_blocks_to_confirm + 1, cemented_count);
1043  	ASSERT_EQ (cemented_count, node-&gt;ledger.cache.cemented_count);
1044  	system.deadline_set (60s);
1045  	while ((node-&gt;ledger.cache.cemented_count - 1) != node-&gt;stats.count (nano::stat::type::confirmation_observer, nano::stat::detail::all, nano::stat::dir::out))
1046  	{
1047  		ASSERT_NO_ERROR (system.poll ());
1048  	}
1049  	system.deadline_set (60s);
1050  	while (node-&gt;active.election_winner_details_size () &gt; 0)
1051  	{
1052  		ASSERT_NO_ERROR (system.poll ());
1053  	}
1054  }
1055  TEST (confirmation_height, many_accounts_send_receive_self_no_elections)
1056  {
1057  	if (nano::rocksdb_config::using_rocksdb_in_tests ())
1058  	{
1059  		return;
1060  	}
1061  	nano::logger_mt logger;
1062  	nano::logging logging;
1063  	auto path (nano::unique_path ());
1064  	auto store = nano::make_store (logger, path, nano::dev::constants);
1065  	ASSERT_TRUE (!store-&gt;init_error ());
1066  	nano::stats stats;
1067  	nano::ledger ledger (*store, stats, nano::dev::constants);
1068  	nano::write_database_queue write_database_queue (false);
1069  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits&lt;unsigned&gt;::max () };
1070  	std::atomic&lt;bool&gt; stopped{ false };
1071  	boost::latch initialized_latch{ 0 };
1072  	nano::block_hash block_hash_being_processed{ 0 };
1073  	nano::confirmation_height_processor confirmation_height_processor{ ledger, write_database_queue, 10ms, logging, logger, initialized_latch, confirmation_height_mode::automatic };
1074  	auto const num_accounts = 100000;
1075  	auto latest_genesis = nano::dev::genesis-&gt;hash ();
1076  	std::vector&lt;nano::keypair&gt; keys;
1077  	std::vector&lt;std::shared_ptr&lt;nano::open_block&gt;&gt; open_blocks;
1078  	nano::block_builder builder;
1079  	nano::test::system system;
1080  	{
1081  		auto transaction (store-&gt;tx_begin_write ());
1082  		store-&gt;initialize (transaction, ledger.cache, ledger.constants);
1083  		for (auto i = 0; i &lt; num_accounts; ++i)
1084  		{
1085  			nano::keypair key;
1086  			keys.emplace_back (key);
1087  			auto send = builder
1088  						.send ()
1089  						.previous (latest_genesis)
1090  						.destination (key.pub)
1091  						.balance (nano::dev::constants.genesis_amount - 1 - i)
1092  						.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1093  						.work (*pool.generate (latest_genesis))
1094  						.build ();
1095  			ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send).code);
1096  			auto open = builder
1097  						.open ()
1098  						.source (send-&gt;hash ())
1099  						.representative (nano::dev::genesis_key.pub)
1100  						.account (key.pub)
1101  						.sign (key.prv, key.pub)
1102  						.work (*pool.generate (key.pub))
1103  						.build_shared ();
1104  			ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *open).code);
1105  			open_blocks.push_back (std::move (open));
1106  			latest_genesis = send-&gt;hash ();
1107  		}
1108  	}
1109  	for (auto &amp; open_block : open_blocks)
1110  	{
1111  		confirmation_height_processor.add (open_block);
1112  	}
1113  	system.deadline_set (1000s);
1114  	auto num_blocks_to_confirm = num_accounts * 2;
1115  	while (stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed, nano::stat::dir::in) != num_blocks_to_confirm)
1116  	{
1117  		ASSERT_NO_ERROR (system.poll ());
1118  	}
1119  	std::vector&lt;std::shared_ptr&lt;nano::send_block&gt;&gt; send_blocks;
1120  	std::vector&lt;std::shared_ptr&lt;nano::receive_block&gt;&gt; receive_blocks;
1121  	{
1122  		auto transaction (store-&gt;tx_begin_write ());
1123  		for (int i = 0; i &lt; open_blocks.size (); ++i)
1124  		{
1125  			auto open_block = open_blocks[i];
1126  			auto &amp; keypair = keys[i];
1127  			send_blocks.emplace_back (builder
1128  									  .send ()
1129  									  .previous (open_block-&gt;hash ())
1130  									  .destination (keypair.pub)
1131  									  .balance (1)
1132  									  .sign (keypair.prv, keypair.pub)
1133  									  .work (*system.work.generate (open_block-&gt;hash ()))
1134  									  .build_shared ());
1135  			receive_blocks.emplace_back (builder
1136  										 .receive ()
1137  										 .previous (send_blocks.back ()-&gt;hash ())
1138  										 .source (send_blocks.back ()-&gt;hash ())
1139  										 .sign (keypair.prv, keypair.pub)
1140  										 .work (*system.work.generate (send_blocks.back ()-&gt;hash ()))
1141  										 .build_shared ());
1142  			ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send_blocks.back ()).code);
1143  			ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *receive_blocks.back ()).code);
1144  		}
1145  	}
1146  	std::random_device rd;
1147  	std::mt19937 g (rd ());
1148  	std::shuffle (send_blocks.begin (), send_blocks.end (), g);
1149  	std::mt19937 g1 (rd ());
1150  	std::shuffle (receive_blocks.begin (), receive_blocks.end (), g1);
1151  	for (int i = 0; i &lt; open_blocks.size (); ++i)
1152  	{
1153  		confirmation_height_processor.add (send_blocks[i]);
1154  		confirmation_height_processor.add (receive_blocks[i]);
1155  	}
1156  	system.deadline_set (1000s);
1157  	num_blocks_to_confirm = num_accounts * 4;
1158  	while (stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed, nano::stat::dir::in) != num_blocks_to_confirm)
1159  	{
1160  		ASSERT_NO_ERROR (system.poll ());
1161  	}
1162  	while (!confirmation_height_processor.current ().is_zero ())
1163  	{
1164  		ASSERT_NO_ERROR (system.poll ());
1165  	}
1166  	auto transaction = store-&gt;tx_begin_read ();
1167  	size_t cemented_count = 0;
1168  	for (auto i (store-&gt;confirmation_height.begin (transaction)), n (store-&gt;confirmation_height.end ()); i != n; ++i)
1169  	{
1170  		cemented_count += i-&gt;second.height;
1171  	}
1172  	ASSERT_EQ (num_blocks_to_confirm + 1, cemented_count);
1173  	ASSERT_EQ (cemented_count, ledger.cache.cemented_count);
1174  }
1175  }
1176  namespace
1177  {
1178  class data
1179  {
1180  public:
1181  	std::atomic&lt;bool&gt; awaiting_cache{ false };
1182  	std::atomic&lt;bool&gt; keep_requesting_metrics{ true };
1183  	std::shared_ptr&lt;nano::node&gt; node;
1184  	std::chrono::system_clock::time_point orig_time;
1185  	std::atomic_flag orig_time_set = ATOMIC_FLAG_INIT;
1186  };
1187  class shared_data
1188  {
1189  public:
1190  	nano::test::counted_completion write_completion{ 0 };
1191  	std::atomic&lt;bool&gt; done{ false };
1192  };
1193  template &lt;typename T&gt;
1194  void callback_process (shared_data &amp; shared_data_a, data &amp; data, T &amp; all_node_data_a, std::chrono::system_clock::time_point last_updated)
1195  {
1196  	if (!data.orig_time_set.test_and_set ())
1197  	{
1198  		data.orig_time = last_updated;
1199  	}
1200  	if (data.awaiting_cache &amp;&amp; data.orig_time != last_updated)
1201  	{
1202  		data.keep_requesting_metrics = false;
1203  	}
1204  	if (data.orig_time != last_updated)
1205  	{
1206  		data.awaiting_cache = true;
1207  		data.orig_time = last_updated;
1208  	}
1209  	shared_data_a.write_completion.increment ();
1210  };
1211  }
1212  TEST (telemetry, ongoing_requests)
1213  {
1214  	nano::test::system system;
1215  	nano::node_flags node_flags;
1216  	auto node_client = system.add_node (node_flags);
1217  	auto node_server = system.add_node (node_flags);
1218  	nano::test::wait_peer_connections (system);
1219  	ASSERT_EQ (0, node_client-&gt;telemetry.size ());
1220  	ASSERT_EQ (0, node_server-&gt;telemetry.size ());
1221  	ASSERT_EQ (0, node_client-&gt;stats.count (nano::stat::type::bootstrap, nano::stat::detail::telemetry_ack, nano::stat::dir::in));
1222  	ASSERT_EQ (0, node_client-&gt;stats.count (nano::stat::type::bootstrap, nano::stat::detail::telemetry_req, nano::stat::dir::out));
1223  	ASSERT_TIMELY (20s, node_client-&gt;stats.count (nano::stat::type::message, nano::stat::detail::telemetry_ack, nano::stat::dir::in) == 1 &amp;&amp; node_server-&gt;stats.count (nano::stat::type::message, nano::stat::detail::telemetry_ack, nano::stat::dir::in) == 1);
1224  	auto time = std::chrono::steady_clock::now ();
1225  	ASSERT_TIMELY (10s, std::chrono::steady_clock::now () &gt;= (time + nano::dev::network_params.network.telemetry_cache_cutoff + 1s));
1226  	ASSERT_EQ (2, node_client-&gt;stats.count (nano::stat::type::message, nano::stat::detail::telemetry_ack, nano::stat::dir::in));
1227  	ASSERT_EQ (2, node_client-&gt;stats.count (nano::stat::type::message, nano::stat::detail::telemetry_req, nano::stat::dir::in));
1228  	ASSERT_EQ (2, node_client-&gt;stats.count (nano::stat::type::message, nano::stat::detail::telemetry_req, nano::stat::dir::out));
1229  	ASSERT_EQ (2, node_server-&gt;stats.count (nano::stat::type::message, nano::stat::detail::telemetry_ack, nano::stat::dir::in));
1230  	ASSERT_EQ (2, node_server-&gt;stats.count (nano::stat::type::message, nano::stat::detail::telemetry_req, nano::stat::dir::in));
1231  	ASSERT_EQ (2, node_server-&gt;stats.count (nano::stat::type::message, nano::stat::detail::telemetry_req, nano::stat::dir::out));
1232  }
1233  namespace nano
1234  {
1235  namespace transport
1236  {
1237  	TEST (telemetry, simultaneous_requests)
1238  	{
1239  		nano::test::system system;
1240  		nano::node_flags node_flags;
1241  		auto const num_nodes = 4;
1242  		for (int i = 0; i &lt; num_nodes; ++i)
1243  		{
1244  			system.add_node (node_flags);
1245  		}
1246  		nano::test::wait_peer_connections (system);
1247  		std::vector&lt;std::thread&gt; threads;
1248  		auto const num_threads = 4;
1249  		std::array&lt;data, num_nodes&gt; node_data{};
1250  		for (auto i = 0; i &lt; num_nodes; ++i)
1251  		{
1252  			node_data[i].node = system.nodes[i];
1253  		}
1254  		shared_data shared_data;
1255  		for (int i = 0; i &lt; num_threads; ++i)
1256  		{
1257  			threads.emplace_back ([&amp;node_data, &amp;shared_data] () {
1258  				while (std::any_of (node_data.cbegin (), node_data.cend (), [] (auto const &amp; data) { return data.keep_requesting_metrics.load (); }))
1259  				{
1260  					for (auto &amp; data : node_data)
1261  					{
1262  						if (data.keep_requesting_metrics)
1263  						{
1264  							shared_data.write_completion.increment_required_count ();
1265  							auto peer = data.node-&gt;network.tcp_channels.channels[0].channel;
1266  							auto maybe_telemetry = data.node-&gt;telemetry.get_telemetry (peer-&gt;get_endpoint ());
1267  							if (maybe_telemetry)
1268  							{
1269  								callback_process (shared_data, data, node_data, maybe_telemetry-&gt;timestamp);
1270  							}
1271  						}
1272  						std::this_thread::sleep_for (1ms);
1273  					}
1274  				}
1275  				shared_data.write_completion.await_count_for (20s);
1276  				shared_data.done = true;
1277  			});
1278  		}
1279  		ASSERT_TIMELY (30s, shared_data.done);
1280  		ASSERT_TRUE (std::all_of (node_data.begin (), node_data.end (), [] (auto const &amp; data) { return !data.keep_requesting_metrics; }));
1281  		for (auto &amp; thread : threads)
1282  		{
1283  			thread.join ();
1284  		}
1285  	}
1286  }
1287  }
1288  TEST (telemetry, under_load)
1289  {
1290  	nano::test::system system;
1291  	nano::node_config node_config = system.default_config ();
1292  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
1293  	nano::node_flags node_flags;
1294  	auto node = system.add_node (node_config, node_flags);
1295  	node_config.peering_port = system.get_available_port ();
1296  	auto node1 = system.add_node (node_config, node_flags);
1297  	nano::keypair key;
1298  	nano::keypair key1;
1299  	system.wallet (0)-&gt;insert_adhoc (nano::dev::genesis_key.prv);
1300  	system.wallet (0)-&gt;insert_adhoc (key.prv);
1301  	auto latest_genesis = node-&gt;latest (nano::dev::genesis_key.pub);
1302  	auto num_blocks = 150000;
1303  	nano::block_builder builder;
1304  	auto send = builder
1305  				.state ()
1306  				.account (nano::dev::genesis_key.pub)
1307  				.previous (latest_genesis)
1308  				.representative (nano::dev::genesis_key.pub)
1309  				.balance (nano::dev::constants.genesis_amount - num_blocks)
1310  				.link (key.pub)
1311  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1312  				.work (*system.work.generate (latest_genesis))
1313  				.build_shared ();
1314  	node-&gt;process_active (send);
1315  	latest_genesis = send-&gt;hash ();
1316  	auto open = builder
1317  				.state ()
1318  				.account (key.pub)
1319  				.previous (0)
1320  				.representative (key.pub)
1321  				.balance (num_blocks)
1322  				.link (send-&gt;hash ())
1323  				.sign (key.prv, key.pub)
1324  				.work (*system.work.generate (key.pub))
1325  				.build_shared ();
1326  	node-&gt;process_active (open);
1327  	auto latest_key = open-&gt;hash ();
1328  	auto thread_func = [key1, &amp;system, node, num_blocks] (nano::keypair const &amp; keypair, nano::block_hash const &amp; latest, nano::uint128_t const initial_amount) {
1329  		auto latest_l = latest;
1330  		nano::block_builder builder;
1331  		for (int i = 0; i &lt; num_blocks; ++i)
1332  		{
1333  			auto send = builder
1334  						.state ()
1335  						.account (keypair.pub)
1336  						.previous (latest_l)
1337  						.representative (keypair.pub)
1338  						.balance (initial_amount - i - 1)
1339  						.link (key1.pub)
1340  						.sign (keypair.prv, keypair.pub)
1341  						.work (*system.work.generate (latest_l))
1342  						.build_shared ();
1343  			latest_l = send-&gt;hash ();
1344  			node-&gt;process_active (send);
1345  		}
1346  	};
1347  	std::thread thread1 (thread_func, nano::dev::genesis_key, latest_genesis, nano::dev::constants.genesis_amount - num_blocks);
1348  	std::thread thread2 (thread_func, key, latest_key, num_blocks);
1349  	ASSERT_TIMELY (200s, node1-&gt;ledger.cache.block_count == num_blocks * 2 + 3);
1350  	thread1.join ();
1351  	thread2.join ();
1352  	for (auto const &amp; node : system.nodes)
1353  	{
1354  		ASSERT_EQ (0, node-&gt;stats.count (nano::stat::type::telemetry, nano::stat::detail::failed_send_telemetry_req));
1355  		ASSERT_EQ (0, node-&gt;stats.count (nano::stat::type::telemetry, nano::stat::detail::request_within_protection_cache_zone));
1356  		ASSERT_EQ (0, node-&gt;stats.count (nano::stat::type::telemetry, nano::stat::detail::unsolicited_telemetry_ack));
1357  		ASSERT_EQ (0, node-&gt;stats.count (nano::stat::type::telemetry, nano::stat::detail::no_response_received));
1358  	}
1359  }
1360  TEST (telemetry, cache_read_and_timeout)
1361  {
1362  	nano::test::system system;
1363  	nano::node_flags node_flags;
1364  	node_flags.disable_ongoing_telemetry_requests = true;
1365  	auto node_client = system.add_node (node_flags);
1366  	auto node_server = system.add_node (node_flags);
1367  	nano::test::wait_peer_connections (system);
1368  	std::optional&lt;nano::telemetry_data&gt; telemetry_data;
1369  	auto channel = node_client-&gt;network.find_node_id (node_server-&gt;get_node_id ());
1370  	ASSERT_NE (channel, nullptr);
1371  	node_client-&gt;telemetry.trigger ();
1372  	ASSERT_TIMELY (5s, telemetry_data = node_client-&gt;telemetry.get_telemetry (channel-&gt;get_endpoint ()));
1373  	auto responses = node_client-&gt;telemetry.get_all_telemetries ();
1374  	ASSERT_TRUE (!responses.empty ());
1375  	ASSERT_EQ (telemetry_data, responses.begin ()-&gt;second);
1376  	ASSERT_EQ (1, node_client-&gt;stats.count (nano::stat::type::message, nano::stat::detail::telemetry_ack, nano::stat::dir::in));
1377  	ASSERT_EQ (0, node_client-&gt;stats.count (nano::stat::type::message, nano::stat::detail::telemetry_req, nano::stat::dir::in));
1378  	ASSERT_EQ (1, node_client-&gt;stats.count (nano::stat::type::message, nano::stat::detail::telemetry_req, nano::stat::dir::out));
1379  	ASSERT_EQ (0, node_server-&gt;stats.count (nano::stat::type::message, nano::stat::detail::telemetry_ack, nano::stat::dir::in));
1380  	ASSERT_EQ (1, node_server-&gt;stats.count (nano::stat::type::message, nano::stat::detail::telemetry_req, nano::stat::dir::in));
1381  	ASSERT_EQ (0, node_server-&gt;stats.count (nano::stat::type::message, nano::stat::detail::telemetry_req, nano::stat::dir::out));
1382  	ASSERT_TIMELY (5s, node_client-&gt;telemetry.get_all_telemetries ().empty ());
1383  	responses = node_client-&gt;telemetry.get_all_telemetries ();
1384  	ASSERT_TRUE (responses.empty ());
1385  	node_client-&gt;telemetry.trigger ();
1386  	ASSERT_TIMELY (5s, telemetry_data = node_client-&gt;telemetry.get_telemetry (channel-&gt;get_endpoint ()));
1387  	responses = node_client-&gt;telemetry.get_all_telemetries ();
1388  	ASSERT_TRUE (!responses.empty ());
1389  	ASSERT_EQ (telemetry_data, responses.begin ()-&gt;second);
1390  	ASSERT_EQ (2, node_client-&gt;stats.count (nano::stat::type::message, nano::stat::detail::telemetry_ack, nano::stat::dir::in));
1391  	ASSERT_EQ (0, node_client-&gt;stats.count (nano::stat::type::message, nano::stat::detail::telemetry_req, nano::stat::dir::in));
1392  	ASSERT_EQ (2, node_client-&gt;stats.count (nano::stat::type::message, nano::stat::detail::telemetry_req, nano::stat::dir::out));
1393  	ASSERT_EQ (0, node_server-&gt;stats.count (nano::stat::type::message, nano::stat::detail::telemetry_ack, nano::stat::dir::in));
1394  	ASSERT_EQ (2, node_server-&gt;stats.count (nano::stat::type::message, nano::stat::detail::telemetry_req, nano::stat::dir::in));
1395  	ASSERT_EQ (0, node_server-&gt;stats.count (nano::stat::type::message, nano::stat::detail::telemetry_req, nano::stat::dir::out));
1396  }
1397  TEST (telemetry, many_nodes)
1398  {
1399  	nano::test::system system;
1400  	nano::node_flags node_flags;
1401  	node_flags.disable_request_loop = true;
1402  	auto const num_nodes = nano::memory_intensive_instrumentation () ? 4 : 10;
1403  	for (auto i = 0; i &lt; num_nodes; ++i)
1404  	{
1405  		nano::node_config node_config = system.default_config ();
1406  		node_config.bandwidth_limit = 100000 + i;
1407  		auto node = std::make_shared&lt;nano::node&gt; (system.io_ctx, nano::unique_path (), node_config, system.work, node_flags);
1408  		node-&gt;start ();
1409  		system.nodes.push_back (node);
1410  	}
1411  	for (auto const &amp; node : system.nodes)
1412  	{
1413  		for (auto const &amp; other_node : system.nodes)
1414  		{
1415  			if (node != other_node)
1416  			{
1417  				node-&gt;network.merge_peer (other_node-&gt;network.endpoint ());
1418  			}
1419  		}
1420  	}
1421  	nano::test::wait_peer_connections (system);
1422  	nano::keypair key;
1423  	nano::block_builder builder;
1424  	auto send = builder
1425  				.state ()
1426  				.account (nano::dev::genesis_key.pub)
1427  				.previous (nano::dev::genesis-&gt;hash ())
1428  				.representative (nano::dev::genesis_key.pub)
1429  				.balance (nano::dev::constants.genesis_amount - nano::Mxrb_ratio)
1430  				.link (key.pub)
1431  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1432  				.work (*system.work.generate (nano::dev::genesis-&gt;hash ()))
1433  				.build ();
1434  	for (auto node : system.nodes)
1435  	{
1436  		auto transaction (node-&gt;store.tx_begin_write ());
1437  		ASSERT_EQ (nano::process_result::progress, node-&gt;ledger.process (transaction, *send).code);
1438  	}
1439  	auto node_client = system.nodes.front ();
1440  	std::vector&lt;nano::telemetry_data&gt; telemetry_datas;
1441  	auto peers = node_client-&gt;network.list (num_nodes - 1);
1442  	ASSERT_EQ (peers.size (), num_nodes - 1);
1443  	for (auto const &amp; peer : peers)
1444  	{
1445  		std::optional&lt;nano::telemetry_data&gt; telemetry_data;
1446  		ASSERT_TIMELY (5s, telemetry_data = node_client-&gt;telemetry.get_telemetry (peer-&gt;get_endpoint ()));
1447  		telemetry_datas.push_back (*telemetry_data);
1448  	}
1449  	ASSERT_EQ (telemetry_datas.size (), num_nodes - 1);
1450  	for (auto &amp; data : telemetry_datas)
1451  	{
1452  		ASSERT_EQ (data.unchecked_count, 0);
1453  		ASSERT_EQ (data.cemented_count, 1);
1454  		ASSERT_LE (data.peer_count, 9U);
1455  		ASSERT_EQ (data.account_count, 1);
1456  		ASSERT_TRUE (data.block_count == 2);
1457  		ASSERT_EQ (data.protocol_version, nano::dev::network_params.network.protocol_version);
1458  		ASSERT_GE (data.bandwidth_cap, 100000);
1459  		ASSERT_LT (data.bandwidth_cap, 100000 + system.nodes.size ());
1460  		ASSERT_EQ (data.major_version, nano::get_major_node_version ());
1461  		ASSERT_EQ (data.minor_version, nano::get_minor_node_version ());
1462  		ASSERT_EQ (data.patch_version, nano::get_patch_node_version ());
1463  		ASSERT_EQ (data.pre_release_version, nano::get_pre_release_node_version ());
1464  		ASSERT_EQ (data.maker, 0);
1465  		ASSERT_LT (data.uptime, 100);
1466  		ASSERT_EQ (data.genesis_block, nano::dev::genesis-&gt;hash ());
1467  		ASSERT_LE (data.timestamp, std::chrono::system_clock::now ());
1468  		ASSERT_EQ (data.active_difficulty, system.nodes.front ()-&gt;default_difficulty (nano::work_version::work_1));
1469  	}
1470  	auto bandwidth_cap = telemetry_datas.front ().bandwidth_cap;
1471  	telemetry_datas.erase (telemetry_datas.begin ());
1472  	auto all_bandwidth_limits_same = std::all_of (telemetry_datas.begin (), telemetry_datas.end (), [bandwidth_cap] (auto &amp; telemetry_data) {
1473  		return telemetry_data.bandwidth_cap == bandwidth_cap;
1474  	});
1475  	ASSERT_FALSE (all_bandwidth_limits_same);
1476  }
1477  TEST (signature_checker, mass_boundary_checks)
1478  {
1479  	std::vector&lt;size_t&gt; sizes{ 0, 1 };
1480  	auto add_boundary = [&amp;sizes] (size_t boundary) {
1481  		sizes.insert (sizes.end (), { boundary - 1, boundary, boundary + 1 });
1482  	};
1483  	for (auto i = 1; i &lt;= 10; ++i)
1484  	{
1485  		add_boundary (nano::signature_checker::batch_size * i);
1486  	}
1487  	nano::block_builder builder;
1488  	for (auto num_threads = 0; num_threads &lt; 5; ++num_threads)
1489  	{
1490  		nano::signature_checker checker (num_threads);
1491  		auto max_size = *(sizes.end () - 1);
1492  		std::vector&lt;nano::uint256_union&gt; hashes;
1493  		hashes.reserve (max_size);
1494  		std::vector&lt;unsigned char const *&gt; messages;
1495  		messages.reserve (max_size);
1496  		std::vector&lt;size_t&gt; lengths;
1497  		lengths.reserve (max_size);
1498  		std::vector&lt;unsigned char const *&gt; pub_keys;
1499  		pub_keys.reserve (max_size);
1500  		std::vector&lt;unsigned char const *&gt; signatures;
1501  		signatures.reserve (max_size);
1502  		nano::keypair key;
1503  		auto block = builder
1504  					 .state ()
1505  					 .account (key.pub)
1506  					 .previous (0)
1507  					 .representative (key.pub)
1508  					 .balance (0)
1509  					 .link (0)
1510  					 .sign (key.prv, key.pub)
1511  					 .work (0)
1512  					 .build ();
1513  		size_t last_size = 0;
1514  		for (auto size : sizes)
1515  		{
1516  			auto extra_size = size - last_size;
1517  			std::vector&lt;int&gt; verifications;
1518  			verifications.resize (size);
1519  			for (auto i (0); i &lt; extra_size; ++i)
1520  			{
1521  				hashes.push_back (block-&gt;hash ());
1522  				messages.push_back (hashes.back ().bytes.data ());
1523  				lengths.push_back (sizeof (decltype (hashes)::value_type));
1524  				pub_keys.push_back (block-&gt;hashables.account.bytes.data ());
1525  				signatures.push_back (block-&gt;signature.bytes.data ());
1526  			}
1527  			nano::signature_check_set check = { size, messages.data (), lengths.data (), pub_keys.data (), signatures.data (), verifications.data () };
1528  			checker.verify (check);
1529  			bool all_valid = std::all_of (verifications.cbegin (), verifications.cend (), [] (auto verification) { return verification == 1; });
1530  			ASSERT_TRUE (all_valid);
1531  			last_size = size;
1532  		}
1533  	}
1534  }
1535  TEST (node, mass_epoch_upgrader)
1536  {
1537  	auto perform_test = [] (size_t const batch_size) {
1538  		unsigned threads = 5;
1539  		size_t total_accounts = 2500;
1540  #ifndef NDEBUG
1541  		total_accounts /= 5;
1542  #endif
1543  		struct info
1544  		{
1545  			nano::keypair key;
1546  			nano::block_hash pending_hash;
1547  		};
1548  		std::vector&lt;info&gt; opened (total_accounts / 2);
1549  		std::vector&lt;info&gt; unopened (total_accounts / 2);
1550  		nano::test::system system;
1551  		nano::node_config node_config = system.default_config ();
1552  		node_config.work_threads = 4;
1553  		auto &amp; node = *system.add_node (node_config);
1554  		auto balance = node.balance (nano::dev::genesis_key.pub);
1555  		auto latest = node.latest (nano::dev::genesis_key.pub);
1556  		nano::uint128_t amount = 1;
1557  		std::array&lt;std::vector&lt;info&gt; *, 2&gt; all{ &amp;opened, &amp;unopened };
1558  		for (auto &amp; accounts : all)
1559  		{
1560  			for (auto &amp; info : *accounts)
1561  			{
1562  				balance -= amount;
1563  				nano::state_block_builder builder;
1564  				std::error_code ec;
1565  				auto block = builder
1566  							 .account (nano::dev::genesis_key.pub)
1567  							 .previous (latest)
1568  							 .balance (balance)
1569  							 .link (info.key.pub)
1570  							 .representative (nano::dev::genesis_key.pub)
1571  							 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1572  							 .work (*node.work_generate_blocking (latest, node_config.network_params.work.threshold (nano::work_version::work_1, nano::block_details (nano::epoch::epoch_0, false, false, false))))
1573  							 .build (ec);
1574  				ASSERT_FALSE (ec);
1575  				ASSERT_NE (nullptr, block);
1576  				ASSERT_EQ (nano::process_result::progress, node.process (*block).code);
1577  				latest = block-&gt;hash ();
1578  				info.pending_hash = block-&gt;hash ();
1579  			}
1580  		}
1581  		ASSERT_EQ (1 + total_accounts, node.ledger.cache.block_count);
1582  		ASSERT_EQ (1, node.ledger.cache.account_count);
1583  		for (auto const &amp; info : opened)
1584  		{
1585  			nano::state_block_builder builder;
1586  			std::error_code ec;
1587  			auto block = builder
1588  						 .account (info.key.pub)
1589  						 .previous (0)
1590  						 .balance (amount)
1591  						 .link (info.pending_hash)
1592  						 .representative (info.key.pub)
1593  						 .sign (info.key.prv, info.key.pub)
1594  						 .work (*node.work_generate_blocking (info.key.pub, node_config.network_params.work.threshold (nano::work_version::work_1, nano::block_details (nano::epoch::epoch_0, false, false, false))))
1595  						 .build (ec);
1596  			ASSERT_FALSE (ec);
1597  			ASSERT_NE (nullptr, block);
1598  			ASSERT_EQ (nano::process_result::progress, node.process (*block).code);
1599  		}
1600  		ASSERT_EQ (1 + total_accounts + opened.size (), node.ledger.cache.block_count);
1601  		ASSERT_EQ (1 + opened.size (), node.ledger.cache.account_count);
1602  		nano::keypair epoch_signer (nano::dev::genesis_key);
1603  		auto const block_count_before = node.ledger.cache.block_count.load ();
1604  		auto const total_to_upgrade = 1 + total_accounts;
1605  		std::cout &lt;&lt; &quot;Mass upgrading &quot; &lt;&lt; total_to_upgrade &lt;&lt; &quot; accounts&quot; &lt;&lt; std::endl;
1606  		while (node.ledger.cache.block_count != block_count_before + total_to_upgrade)
1607  		{
1608  			auto const pre_upgrade = node.ledger.cache.block_count.load ();
1609  			auto upgrade_count = std::min&lt;size_t&gt; (batch_size, block_count_before + total_to_upgrade - pre_upgrade);
1610  			ASSERT_FALSE (node.epoch_upgrader.start (epoch_signer.prv, nano::epoch::epoch_1, upgrade_count, threads));
1611  			ASSERT_TRUE (node.epoch_upgrader.start (epoch_signer.prv, nano::epoch::epoch_1, upgrade_count, threads));
1612  			system.deadline_set (60s);
1613  			while (node.ledger.cache.block_count != pre_upgrade + upgrade_count)
1614  			{
1615  				ASSERT_NO_ERROR (system.poll ());
1616  				std::this_thread::sleep_for (200ms);
1617  				std::cout &lt;&lt; node.ledger.cache.block_count - block_count_before &lt;&lt; &quot; / &quot; &lt;&lt; total_to_upgrade &lt;&lt; std::endl;
1618  			}
1619  			std::this_thread::sleep_for (50ms);
1620  		}
1621  		auto expected_blocks = block_count_before + total_accounts + 1;
1622  		ASSERT_EQ (expected_blocks, node.ledger.cache.block_count);
1623  		{
1624  			auto transaction (node.store.tx_begin_read ());
1625  			size_t block_count_sum = 0;
1626  			for (auto i (node.store.account.begin (transaction)); i != node.store.account.end (); ++i)
1627  			{
1628  				nano::account_info info (i-&gt;second);
1629  				ASSERT_EQ (info.epoch (), nano::epoch::epoch_1);
1630  				block_count_sum += info.block_count;
1631  			}
1632  			ASSERT_EQ (expected_blocks, block_count_sum);
1633  		}
1634  	};
1635  	perform_test (42);
1636  	perform_test (std::numeric_limits&lt;size_t&gt;::max ());
1637  }
1638  namespace nano
1639  {
1640  TEST (node, mass_block_new)
1641  {
1642  	nano::test::system system;
1643  	nano::node_config node_config = system.default_config ();
1644  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
1645  	auto &amp; node = *system.add_node (node_config);
1646  	node.network_params.network.aec_loop_interval_ms = 500;
1647  #ifndef NDEBUG
1648  	auto const num_blocks = 5000;
1649  #else
1650  	auto const num_blocks = 50000;
1651  #endif
1652  	std::cout &lt;&lt; num_blocks &lt;&lt; &quot; x4 blocks&quot; &lt;&lt; std::endl;
1653  	system.upgrade_genesis_epoch (node, nano::epoch::epoch_1);
1654  	system.upgrade_genesis_epoch (node, nano::epoch::epoch_2);
1655  	auto next_block_count = num_blocks + 3;
1656  	auto process_all = [&amp;] (std::vector&lt;std::shared_ptr&lt;nano::state_block&gt;&gt; const &amp; blocks_a) {
1657  		for (auto const &amp; block : blocks_a)
1658  		{
1659  			node.process_active (block);
1660  		}
1661  		ASSERT_TIMELY (200s, node.ledger.cache.block_count == next_block_count);
1662  		next_block_count += num_blocks;
1663  		node.block_processor.flush ();
1664  		{
1665  			nano::lock_guard&lt;nano::mutex&gt; guard{ node.active.mutex };
1666  			node.active.roots.clear ();
1667  			node.active.blocks.clear ();
1668  		}
1669  	};
1670  	nano::keypair key;
1671  	std::vector&lt;nano::keypair&gt; keys (num_blocks);
1672  	nano::state_block_builder builder;
1673  	std::vector&lt;std::shared_ptr&lt;nano::state_block&gt;&gt; send_blocks;
1674  	auto send_threshold (nano::dev::network_params.work.threshold (nano::work_version::work_1, nano::block_details (nano::epoch::epoch_2, true, false, false)));
1675  	auto latest_genesis = node.latest (nano::dev::genesis_key.pub);
1676  	for (auto i = 0; i &lt; num_blocks; ++i)
1677  	{
1678  		auto send = builder.make_block ()
1679  					.account (nano::dev::genesis_key.pub)
1680  					.previous (latest_genesis)
1681  					.balance (nano::dev::constants.genesis_amount - i - 1)
1682  					.representative (nano::dev::genesis_key.pub)
1683  					.link (keys[i].pub)
1684  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1685  					.work (*system.work.generate (nano::work_version::work_1, latest_genesis, send_threshold))
1686  					.build ();
1687  		latest_genesis = send-&gt;hash ();
1688  		send_blocks.push_back (std::move (send));
1689  	}
1690  	std::cout &lt;&lt; &quot;Send blocks built, start processing&quot; &lt;&lt; std::endl;
1691  	nano::timer&lt;&gt; timer;
1692  	timer.start ();
1693  	process_all (send_blocks);
1694  	std::cout &lt;&lt; &quot;Send blocks time: &quot; &lt;&lt; timer.stop ().count () &lt;&lt; &quot; &quot; &lt;&lt; timer.unit () &lt;&lt; &quot;\n\n&quot;;
1695  	std::vector&lt;std::shared_ptr&lt;nano::state_block&gt;&gt; open_blocks;
1696  	auto receive_threshold (nano::dev::network_params.work.threshold (nano::work_version::work_1, nano::block_details (nano::epoch::epoch_2, false, true, false)));
1697  	for (auto i = 0; i &lt; num_blocks; ++i)
1698  	{
1699  		auto const &amp; key = keys[i];
1700  		auto open = builder.make_block ()
1701  					.account (key.pub)
1702  					.previous (0)
1703  					.balance (1)
1704  					.representative (key.pub)
1705  					.link (send_blocks[i]-&gt;hash ())
1706  					.sign (key.prv, key.pub)
1707  					.work (*system.work.generate (nano::work_version::work_1, key.pub, receive_threshold))
1708  					.build ();
1709  		open_blocks.push_back (std::move (open));
1710  	}
1711  	std::cout &lt;&lt; &quot;Open blocks built, start processing&quot; &lt;&lt; std::endl;
1712  	timer.restart ();
1713  	process_all (open_blocks);
1714  	std::cout &lt;&lt; &quot;Open blocks time: &quot; &lt;&lt; timer.stop ().count () &lt;&lt; &quot; &quot; &lt;&lt; timer.unit () &lt;&lt; &quot;\n\n&quot;;
1715  	std::vector&lt;std::shared_ptr&lt;nano::state_block&gt;&gt; send_blocks2;
1716  	for (auto i = 0; i &lt; num_blocks; ++i)
1717  	{
1718  		auto const &amp; key = keys[i];
1719  		auto const &amp; latest = open_blocks[i];
1720  		auto send2 = builder.make_block ()
1721  					 .account (key.pub)
1722  					 .previous (latest-&gt;hash ())
1723  					 .balance (0)
1724  					 .representative (key.pub)
1725  					 .link (key.pub)
1726  					 .sign (key.prv, key.pub)
1727  					 .work (*system.work.generate (nano::work_version::work_1, latest-&gt;hash (), send_threshold))
1728  					 .build ();
1729  		send_blocks2.push_back (std::move (send2));
1730  	}
1731  	std::cout &lt;&lt; &quot;Send2 blocks built, start processing&quot; &lt;&lt; std::endl;
1732  	timer.restart ();
1733  	process_all (send_blocks2);
1734  	std::cout &lt;&lt; &quot;Send2 blocks time: &quot; &lt;&lt; timer.stop ().count () &lt;&lt; &quot; &quot; &lt;&lt; timer.unit () &lt;&lt; &quot;\n\n&quot;;
1735  	std::vector&lt;std::shared_ptr&lt;nano::state_block&gt;&gt; receive_blocks;
1736  	for (auto i = 0; i &lt; num_blocks; ++i)
1737  	{
1738  		auto const &amp; key = keys[i];
1739  		auto const &amp; latest = send_blocks2[i];
1740  		auto send2 = builder.make_block ()
1741  					 .account (key.pub)
1742  					 .previous (latest-&gt;hash ())
1743  					 .balance (1)
1744  					 .representative (key.pub)
1745  					 .link (latest-&gt;hash ())
1746  					 .sign (key.prv, key.pub)
1747  					 .work (*system.work.generate (nano::work_version::work_1, latest-&gt;hash (), receive_threshold))
1748  					 .build ();
1749  		receive_blocks.push_back (std::move (send2));
1750  	}
1751  	std::cout &lt;&lt; &quot;Receive blocks built, start processing&quot; &lt;&lt; std::endl;
1752  	timer.restart ();
1753  	process_all (receive_blocks);
1754  	std::cout &lt;&lt; &quot;Receive blocks time: &quot; &lt;&lt; timer.stop ().count () &lt;&lt; &quot; &quot; &lt;&lt; timer.unit () &lt;&lt; &quot;\n\n&quot;;
1755  }
1756  TEST (node, aggressive_flooding)
1757  {
1758  	nano::test::system system;
1759  	nano::node_flags node_flags;
1760  	node_flags.disable_request_loop = true;
1761  	node_flags.disable_bootstrap_bulk_push_client = true;
1762  	node_flags.disable_bootstrap_bulk_pull_server = true;
1763  	node_flags.disable_bootstrap_listener = true;
1764  	node_flags.disable_lazy_bootstrap = true;
1765  	node_flags.disable_legacy_bootstrap = true;
1766  	node_flags.disable_wallet_bootstrap = true;
1767  	node_flags.disable_ascending_bootstrap = true;
1768  	auto &amp; node1 (*system.add_node (node_flags));
1769  	auto &amp; wallet1 (*system.wallet (0));
1770  	wallet1.insert_adhoc (nano::dev::genesis_key.prv);
1771  	std::vector&lt;std::pair&lt;std::shared_ptr&lt;nano::node&gt;, std::shared_ptr&lt;nano::wallet&gt;&gt;&gt; nodes_wallets;
1772  	nodes_wallets.resize (!nano::memory_intensive_instrumentation () ? 5 : 3);
1773  	std::generate (nodes_wallets.begin (), nodes_wallets.end (), [&amp;system, node_flags] () {
1774  		nano::node_config node_config = system.default_config ();
1775  		auto node (system.add_node (node_config, node_flags));
1776  		return std::make_pair (node, system.wallet (system.nodes.size () - 1));
1777  	});
1778  	ASSERT_TIMELY (5s, node1.network.size () == nodes_wallets.size ());
1779  	ASSERT_LT (node1.network.fanout (), nodes_wallets.size ());
1780  	ASSERT_TIMELY (10s, std::all_of (nodes_wallets.begin (), nodes_wallets.end (), [] (auto const &amp; node_wallet) { return node_wallet.first-&gt;rep_crawler.principal_representatives ().size () != 0; }));
1781  	auto large_amount = (nano::dev::constants.genesis_amount / 2) / nodes_wallets.size ();
1782  	std::vector&lt;std::shared_ptr&lt;nano::block&gt;&gt; genesis_blocks;
1783  	for (auto &amp; node_wallet : nodes_wallets)
1784  	{
1785  		nano::keypair keypair;
1786  		node_wallet.second-&gt;store.representative_set (node_wallet.first-&gt;wallets.tx_begin_write (), keypair.pub);
1787  		node_wallet.second-&gt;insert_adhoc (keypair.prv);
1788  		auto block (wallet1.send_action (nano::dev::genesis_key.pub, keypair.pub, large_amount));
1789  		ASSERT_NE (nullptr, block);
1790  		genesis_blocks.push_back (block);
1791  	}
1792  	for (auto &amp; node_wallet : nodes_wallets)
1793  	{
1794  		for (auto const &amp; block : genesis_blocks)
1795  		{
1796  			auto process_result (node_wallet.first-&gt;process (*block));
1797  			ASSERT_TRUE (nano::process_result::progress == process_result.code || nano::process_result::old == process_result.code);
1798  		}
1799  		ASSERT_EQ (node1.latest (nano::dev::genesis_key.pub), node_wallet.first-&gt;latest (nano::dev::genesis_key.pub));
1800  		ASSERT_EQ (genesis_blocks.back ()-&gt;hash (), node_wallet.first-&gt;latest (nano::dev::genesis_key.pub));
1801  		nano::test::start_elections (system, *node_wallet.first, { genesis_blocks.back () }, true);
1802  	}
1803  	nano::test::start_elections (system, node1, { genesis_blocks.back () }, true);
1804  	auto all_received = [&amp;nodes_wallets] () {
1805  		return std::all_of (nodes_wallets.begin (), nodes_wallets.end (), [] (auto const &amp; node_wallet) {
1806  			auto local_representative (node_wallet.second-&gt;store.representative (node_wallet.first-&gt;wallets.tx_begin_read ()));
1807  			return node_wallet.first-&gt;ledger.account_balance (node_wallet.first-&gt;store.tx_begin_read (), local_representative) &gt; 0;
1808  		});
1809  	};
1810  	ASSERT_TIMELY (!nano::slow_instrumentation () ? 10s : 40s, all_received ());
1811  	ASSERT_TIMELY (!nano::slow_instrumentation () ? 10s : 40s, node1.ledger.cache.block_count == 1 + 2 * nodes_wallets.size ());
1812  	ASSERT_TIMELY (!nano::slow_instrumentation () ? 10s : 40s, node1.rep_crawler.principal_representatives ().size () == nodes_wallets.size ());
1813  	nano::state_block_builder builder;
1814  	std::shared_ptr&lt;nano::state_block&gt; block{};
1815  	{
1816  		auto transaction (node1.store.tx_begin_read ());
1817  		block = builder.make_block ()
1818  				.account (nano::dev::genesis_key.pub)
1819  				.representative (nano::dev::genesis_key.pub)
1820  				.previous (node1.ledger.latest (transaction, nano::dev::genesis_key.pub))
1821  				.balance (node1.ledger.account_balance (transaction, nano::dev::genesis_key.pub) - 1)
1822  				.link (nano::dev::genesis_key.pub)
1823  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1824  				.work (*node1.work_generate_blocking (node1.ledger.latest (transaction, nano::dev::genesis_key.pub)))
1825  				.build ();
1826  	}
1827  	ASSERT_EQ (nano::process_result::progress, node1.process_local (block).value ().code);
1828  	auto all_have_block = [&amp;nodes_wallets] (nano::block_hash const &amp; hash_a) {
1829  		return std::all_of (nodes_wallets.begin (), nodes_wallets.end (), [hash = hash_a] (auto const &amp; node_wallet) {
1830  			return node_wallet.first-&gt;block (hash) != nullptr;
1831  		});
1832  	};
1833  	ASSERT_TIMELY (!nano::slow_instrumentation () ? 5s : 25s, all_have_block (block-&gt;hash ()));
1834  	auto wallet_block = wallet1.send_sync (nano::dev::genesis_key.pub, nano::dev::genesis_key.pub, 10);
1835  	ASSERT_TIMELY (!nano::slow_instrumentation () ? 5s : 25s, all_have_block (wallet_block));
1836  	ASSERT_EQ (1 + 2 * nodes_wallets.size () + 2, node1.ledger.cache.block_count);
1837  }
1838  TEST (node, send_single_many_peers)
1839  {
1840  	nano::test::system system (nano::memory_intensive_instrumentation () ? 4 : 10);
1841  	nano::keypair key2;
1842  	system.wallet (0)-&gt;insert_adhoc (nano::dev::genesis_key.prv);
1843  	system.wallet (1)-&gt;insert_adhoc (key2.prv);
1844  	ASSERT_NE (nullptr, system.wallet (0)-&gt;send_action (nano::dev::genesis_key.pub, key2.pub, system.nodes[0]-&gt;config.receive_minimum.number ()));
1845  	ASSERT_EQ (std::numeric_limits&lt;nano::uint128_t&gt;::max () - system.nodes[0]-&gt;config.receive_minimum.number (), system.nodes[0]-&gt;balance (nano::dev::genesis_key.pub));
1846  	ASSERT_TRUE (system.nodes[0]-&gt;balance (key2.pub).is_zero ());
1847  	ASSERT_TIMELY (3.5min, std::all_of (system.nodes.begin (), system.nodes.end (), [&amp;] (std::shared_ptr&lt;nano::node&gt; const &amp; node_a) { return !node_a-&gt;balance (key2.pub).is_zero (); }));
1848  	system.stop ();
1849  	for (auto node : system.nodes)
1850  	{
1851  		ASSERT_TRUE (node-&gt;stopped);
1852  	}
1853  }
1854  }
1855  TEST (node, wallet_create_block_confirm_conflicts)
1856  {
1857  	for (int i = 0; i &lt; 5; ++i)
1858  	{
1859  		nano::test::system system;
1860  		nano::block_builder builder;
1861  		nano::node_config node_config (system.get_available_port (), system.logging);
1862  		node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
1863  		auto node = system.add_node (node_config);
1864  		auto const num_blocks = 10000;
1865  		auto latest = nano::dev::genesis-&gt;hash ();
1866  		nano::keypair key1;
1867  		{
1868  			auto transaction = node-&gt;store.tx_begin_write ();
1869  			for (auto i = num_blocks - 1; i &gt; 0; --i)
1870  			{
1871  				auto send = builder
1872  							.send ()
1873  							.previous (latest)
1874  							.destination (key1.pub)
1875  							.balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio + i + 1)
1876  							.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1877  							.work (*system.work.generate (latest))
1878  							.build ();
1879  				ASSERT_EQ (nano::process_result::progress, node-&gt;ledger.process (transaction, *send).code);
1880  				latest = send-&gt;hash ();
1881  			}
1882  		}
1883  		std::atomic&lt;bool&gt; done{ false };
1884  		std::thread t ([node, &amp;done] () {
1885  			while (!done)
1886  			{
1887  				node-&gt;wallets.create (nano::random_wallet_id ());
1888  			}
1889  		});
1890  		{
1891  			auto block = node-&gt;store.block.get (node-&gt;store.tx_begin_read (), latest);
1892  			node-&gt;scheduler.buckets.manual (block);
1893  			std::shared_ptr&lt;nano::election&gt; election;
1894  			ASSERT_TIMELY (10s, (election = node-&gt;active.election (block-&gt;qualified_root ())) != nullptr);
1895  			election-&gt;force_confirm ();
1896  		}
1897  		ASSERT_TIMELY (120s, node-&gt;ledger.block_confirmed (node-&gt;store.tx_begin_read (), latest) &amp;&amp; node-&gt;confirmation_height_processor.current () == 0);
1898  		done = true;
1899  		t.join ();
1900  	}
1901  }
1902  namespace nano
1903  {
1904  TEST (system, block_sequence)
1905  {
1906  	size_t const block_count = 400;
1907  	size_t const pr_count = 4;
1908  	size_t const listeners_per_pr = 0;
1909  	nano::test::system system;
1910  	std::vector&lt;nano::keypair&gt; reps;
1911  	for (auto i = 0; i &lt; pr_count; ++i)
1912  	{
1913  		reps.push_back (nano::keypair{});
1914  	}
1915  	system.ledger_initialization_set (reps, nano::Gxrb_ratio);
1916  	system.deadline_set (3600s);
1917  	nano::node_config config;
1918  	config.peering_port = system.get_available_port ();
1919  	config.enable_voting = true;
1920  	config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
1921  	nano::node_flags flags;
1922  	flags.disable_max_peers_per_ip = true;
1923  	flags.disable_ongoing_bootstrap = true;
1924  	auto root = system.add_node (config, flags);
1925  	auto wallet = root-&gt;wallets.items.begin ()-&gt;second;
1926  	wallet-&gt;insert_adhoc (nano::dev::genesis_key.prv);
1927  	for (auto rep : reps)
1928  	{
1929  		system.wallet (0);
1930  		config.peering_port = system.get_available_port ();
1931  		auto pr = system.add_node (config, flags, nano::transport::transport_type::tcp, rep);
1932  		for (auto j = 0; j &lt; listeners_per_pr; ++j)
1933  		{
1934  			config.peering_port = system.get_available_port ();
1935  			system.add_node (config, flags);
1936  		}
1937  		std::cerr &lt;&lt; rep.pub.to_account () &lt;&lt; &#x27; &#x27; &lt;&lt; pr-&gt;wallets.items.begin ()-&gt;second-&gt;exists (rep.pub) &lt;&lt; pr-&gt;weight (rep.pub) &lt;&lt; &#x27; &#x27; &lt;&lt; &#x27;\n&#x27;;
1938  	}
1939  	while (std::any_of (system.nodes.begin (), system.nodes.end (), [] (std::shared_ptr&lt;nano::node&gt; const &amp; node) {
1940  		return node-&gt;rep_crawler.representative_count () &lt; 3;
1941  	}))
1942  	{
1943  		system.poll ();
1944  	}
1945  	for (auto &amp; node : system.nodes)
1946  	{
1947  		std::cerr &lt;&lt; std::to_string (node-&gt;network.port) &lt;&lt; &quot;: &quot;;
1948  		auto prs = node-&gt;rep_crawler.principal_representatives ();
1949  		for (auto pr : prs)
1950  		{
1951  			std::cerr &lt;&lt; pr.account.to_account () &lt;&lt; &#x27; &#x27;;
1952  		}
1953  		std::cerr &lt;&lt; &#x27;\n&#x27;;
1954  	}
1955  	nano::keypair key;
1956  	auto start = std::chrono::system_clock::now ();
1957  	std::deque&lt;std::shared_ptr&lt;nano::block&gt;&gt; blocks;
1958  	for (auto i = 0; i &lt; block_count; ++i)
1959  	{
1960  		if ((i % 1000) == 0)
1961  		{
1962  			std::cerr &lt;&lt; &quot;Block: &quot; &lt;&lt; std::to_string (i) &lt;&lt; &quot; ms: &quot; &lt;&lt; std::to_string (std::chrono::duration_cast&lt;std::chrono::milliseconds&gt; (std::chrono::system_clock::now () - start).count ()) &lt;&lt; &quot;\n&quot;;
1963  		}
1964  		auto block = wallet-&gt;send_action (nano::dev::genesis_key.pub, key.pub, 1);
1965  		debug_assert (block != nullptr);
1966  		blocks.push_back (block);
1967  	}
1968  	auto done = false;
1969  	std::chrono::system_clock::time_point last;
1970  	auto interval = 1000ms;
1971  	while (!done)
1972  	{
1973  		if (std::chrono::system_clock::now () - last &gt; interval)
1974  		{
1975  			std::string message;
1976  			for (auto i : system.nodes)
1977  			{
1978  				message += boost::str (boost::format (&quot;N:%1% b:%2% c:%3% a:%4% s:%5% p:%6%\n&quot;) % std::to_string (i-&gt;network.port) % std::to_string (i-&gt;ledger.cache.block_count) % std::to_string (i-&gt;ledger.cache.cemented_count) % std::to_string (i-&gt;active.size ()) % std::to_string (i-&gt;scheduler.buckets.size ()) % std::to_string (i-&gt;network.size ()));
1979  				nano::lock_guard&lt;nano::mutex&gt; lock{ i-&gt;active.mutex };
1980  				for (auto const &amp; j : i-&gt;active.roots)
1981  				{
1982  					auto election = j.election;
1983  					if (election-&gt;confirmation_request_count &gt; 10)
1984  					{
1985  						message += boost::str (boost::format (&quot;\t r:%1% i:%2%\n&quot;) % j.root.to_string () % std::to_string (election-&gt;confirmation_request_count));
1986  						for (auto const &amp; k : election-&gt;votes ())
1987  						{
1988  							message += boost::str (boost::format (&quot;\t\t r:%1% t:%2%\n&quot;) % k.first.to_account () % std::to_string (k.second.timestamp));
1989  						}
1990  					}
1991  				}
1992  			}
1993  			std::cerr &lt;&lt; message &lt;&lt; std::endl;
1994  			last = std::chrono::system_clock::now ();
1995  		}
1996  		done = std::all_of (system.nodes.begin (), system.nodes.end (), [&amp;blocks] (std::shared_ptr&lt;nano::node&gt; node) { return node-&gt;block_confirmed (blocks.back ()-&gt;hash ()); });
1997  		system.poll ();
1998  	}
1999  }
2000  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-node_6.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-node_6.cpp</div>
                </div>
                <div class="column column_space"><pre><code>35  	uint32_t count (20);
36  	system.generate_mass_activity (count, *system.nodes[0]);
37  	auto transaction (system.nodes[0]-&gt;store.tx_begin_read ());
</pre></code></div>
                <div class="column column_space"><pre><code>75  		uint32_t count (1000);
76  		system.generate_mass_activity (count, *system.nodes[0]);
77  		nano::keypair key;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    