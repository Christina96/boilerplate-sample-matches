
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 6.415552855407047%, Tokens: 9</h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-control.cpp</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #  include "config_auto.h"
3  #endif
4  #include <cctype>
5  #include <cmath>
6  #include <cstdint> 
7  #include <cstdio>  
8  #include <ctime>   
9  #include "control.h"
10  #ifndef DISABLED_LEGACY_ENGINE
11  #  include "docqual.h"
12  #  include "drawfx.h"
13  #  include "fixspace.h"
14  #endif
15  #include <tesseract/ocrclass.h>
16  #include "lstmrecognizer.h"
17  #include "output.h"
18  #include "pageres.h" 
19  #ifndef DISABLED_LEGACY_ENGINE
20  #  include "reject.h"
21  #endif
22  #include "sorthelper.h"
23  #include "tesseractclass.h"
24  #include "tessvars.h"
25  #include "werdit.h"
26  const char *const kBackUpConfigFile = "tempconfigdata.config";
27  #ifndef DISABLED_LEGACY_ENGINE
28  const double kMinRefitXHeightFraction = 0.5;
29  #endif 
30  namespace tesseract {
31  void Tesseract::recog_pseudo_word(PAGE_RES *page_res, TBOX &selection_box) {
32    PAGE_RES_IT *it = make_pseudo_word(page_res, selection_box);
33    if (it != nullptr) {
34      recog_interactive(it);
35      it->DeleteCurrentWord();
36      delete it;
37    }
38  }
39  bool Tesseract::recog_interactive(PAGE_RES_IT *pr_it) {
40    WordData word_data(*pr_it);
41    SetupWordPassN(2, &word_data);
42    if (lstm_recognizer_ == nullptr) {
43  #ifndef DISABLED_LEGACY_ENGINE
44      classify_word_and_language(2, pr_it, &word_data);
45  #endif 
46    } else {
47      classify_word_and_language(1, pr_it, &word_data);
48    }
49  #ifndef DISABLED_LEGACY_ENGINE
50    if (tessedit_debug_quality_metrics) {
51      int16_t char_qual;
52      int16_t good_char_qual;
53      WERD_RES *word_res = pr_it->word();
54      word_char_quality(word_res, &char_qual, &good_char_qual);
55      tprintf(
56          "\n%d chars;  word_blob_quality: %d;  outline_errs: %d; "
57          "char_quality: %d; good_char_quality: %d\n",
58          word_res->reject_map.length(), word_blob_quality(word_res), word_outline_errs(word_res),
59          char_qual, good_char_qual);
60    }
61  #endif 
62    return true;
63  }
64  bool Tesseract::ProcessTargetWord(const TBOX &word_box, const TBOX &target_word_box,
65                                    const char *word_config, int pass) {
66    if (word_config != nullptr) {
67      if (word_box.major_overlap(target_word_box)) {
68        if (backup_config_file_ == nullptr) {
69          backup_config_file_ = kBackUpConfigFile;
70          FILE *config_fp = fopen(backup_config_file_, "wb");
71          if (config_fp == nullptr) {
72            tprintf("Error, failed to open file \"%s\"\n", backup_config_file_);
73          } else {
74            ParamUtils::PrintParams(config_fp, params());
75            fclose(config_fp);
76          }
77          ParamUtils::ReadParamsFile(word_config, SET_PARAM_CONSTRAINT_DEBUG_ONLY, params());
78        }
79      } else {
80        if (backup_config_file_ != nullptr) {
81          ParamUtils::ReadParamsFile(backup_config_file_, SET_PARAM_CONSTRAINT_DEBUG_ONLY, params());
82          backup_config_file_ = nullptr;
83        }
84      }
85    } else if (pass > 1 && !word_box.major_overlap(target_word_box)) {
86      return false;
87    }
88    return true;
89  }
90  void Tesseract::SetupAllWordsPassN(int pass_n, const TBOX *target_word_box, const char *word_config,
91                                     PAGE_RES *page_res, std::vector<WordData> *words) {
92    PAGE_RES_IT page_res_it(page_res);
93    for (page_res_it.restart_page(); page_res_it.word() != nullptr; page_res_it.forward()) {
94      if (target_word_box == nullptr || ProcessTargetWord(page_res_it.word()->word->bounding_box(),
95                                                          *target_word_box, word_config, 1)) {
96        words->push_back(WordData(page_res_it));
97      }
98    }
99    for (unsigned w = 0; w < words->size(); ++w) {
100      SetupWordPassN(pass_n, &(*words)[w]);
101      if (w > 0) {
102        (*words)[w].prev_word = &(*words)[w - 1];
103      }
104    }
105  }
106  void Tesseract::SetupWordPassN(int pass_n, WordData *word) {
107    if (pass_n == 1 || !word->word->done) {
108      if (pass_n == 1) {
109        word->word->SetupForRecognition(unicharset, this, BestPix(), tessedit_ocr_engine_mode,
110                                        nullptr, classify_bln_numeric_mode, textord_use_cjk_fp_model,
111                                        poly_allow_detailed_fx, word->row, word->block);
112      } else if (pass_n == 2) {
113        word->word->caps_height = 0.0;
114        if (word->word->x_height == 0.0f) {
115          word->word->x_height = word->row->x_height();
116        }
117      }
118      word->lang_words.truncate(0);
119      for (unsigned s = 0; s <= sub_langs_.size(); ++s) {
120        Tesseract *lang_t = s < sub_langs_.size() ? sub_langs_[s] : this;
121        auto *word_res = new WERD_RES;
122        word_res->InitForRetryRecognition(*word->word);
123        word->lang_words.push_back(word_res);
124        if (pass_n == 1 || lang_t->tessedit_ocr_engine_mode != OEM_LSTM_ONLY) {
125          word_res->SetupForRecognition(
126              lang_t->unicharset, lang_t, BestPix(), lang_t->tessedit_ocr_engine_mode, nullptr,
127              lang_t->classify_bln_numeric_mode, lang_t->textord_use_cjk_fp_model,
128              lang_t->poly_allow_detailed_fx, word->row, word->block);
129        }
130      }
131    }
132  }
133  bool Tesseract::RecogAllWordsPassN(int pass_n, ETEXT_DESC *monitor, PAGE_RES_IT *pr_it,
134                                     std::vector<WordData> *words) {
135    pr_it->restart_page();
136    for (unsigned w = 0; w < words->size(); ++w) {
137      WordData *word = &(*words)[w];
138      if (w > 0) {
139        word->prev_word = &(*words)[w - 1];
140      }
141      if (monitor != nullptr) {
142        monitor->ocr_alive = true;
143        if (pass_n == 1) {
144          monitor->progress = 70 * w / words->size();
145        } else {
146          monitor->progress = 70 + 30 * w / words->size();
147        }
148        if (monitor->progress_callback2 != nullptr) {
149          TBOX box = pr_it->word()->word->bounding_box();
150          (*monitor->progress_callback2)(monitor, box.left(), box.right(), box.top(), box.bottom());
151        }
152        if (monitor->deadline_exceeded() ||
153            (monitor->cancel != nullptr && (*monitor->cancel)(monitor->cancel_this, words->size()))) {
154          for (; w < words->size(); ++w) {
155            (*words)[w].word->SetupFake(unicharset);
156          }
157          return false;
158        }
159      }
160      if (word->word->tess_failed) {
161        unsigned s;
162        for (s = 0; s < word->lang_words.size() && word->lang_words[s]->tess_failed; ++s) {
163        }
164        if (s > word->lang_words.size()) {
165          continue;
166        }
167      }
168      while (pr_it->word() != nullptr && pr_it->word() != word->word) {
169        pr_it->forward();
170      }
171      ASSERT_HOST(pr_it->word() != nullptr);
172      bool make_next_word_fuzzy = false;
173  #ifndef DISABLED_LEGACY_ENGINE
174      if (!AnyLSTMLang() && ReassignDiacritics(pass_n, pr_it, &make_next_word_fuzzy)) {
175        SetupWordPassN(pass_n, word);
176      }
177  #endif 
178      classify_word_and_language(pass_n, pr_it, word);
179      if (tessedit_dump_choices || debug_noise_removal) {
180        tprintf("Pass%d: %s [%s]\n", pass_n, word->word->best_choice->unichar_string().c_str(),
181                word->word->best_choice->debug_string().c_str());
182      }
183      pr_it->forward();
184      if (make_next_word_fuzzy && pr_it->word() != nullptr) {
185        pr_it->MakeCurrentWordFuzzy();
186      }
187    }
188    return true;
189  }
190  bool Tesseract::recog_all_words(PAGE_RES *page_res, ETEXT_DESC *monitor,
191                                  const TBOX *target_word_box, const char *word_config,
192                                  int dopasses) {
193    PAGE_RES_IT page_res_it(page_res);
194    if (tessedit_minimal_rej_pass1) {
195      tessedit_test_adaption.set_value(true);
196      tessedit_minimal_rejection.set_value(true);
197    }
198    if (dopasses == 0 || dopasses == 1) {
199      page_res_it.restart_page();
200  #ifndef DISABLED_LEGACY_ENGINE
201      if (AdaptiveClassifierIsFull()) {
202        SwitchAdaptiveClassifier();
203      } else if (!AdaptiveClassifierIsEmpty()) {
204        StartBackupAdaptiveClassifier();
205      }
206      for (auto &lang : sub_langs_) {
207        if (lang->AdaptiveClassifierIsFull()) {
208          lang->SwitchAdaptiveClassifier();
209        } else if (!lang->AdaptiveClassifierIsEmpty()) {
210          lang->StartBackupAdaptiveClassifier();
211        }
212      }
213  #endif 
214      std::vector<WordData> words;
215      SetupAllWordsPassN(1, target_word_box, word_config, page_res, &words);
216  #ifndef DISABLED_LEGACY_ENGINE
217      if (tessedit_parallelize) {
218        PrerecAllWordsPar(words);
219      }
220  #endif 
221      stats_.word_count = words.size();
222      stats_.dict_words = 0;
223      stats_.doc_blob_quality = 0;
224      stats_.doc_outline_errs = 0;
225      stats_.doc_char_quality = 0;
226      stats_.good_char_count = 0;
227      stats_.doc_good_char_quality = 0;
228      most_recently_used_ = this;
229      if (!RecogAllWordsPassN(1, monitor, &page_res_it, &words)) {
230        return false;
231      }
232      for (page_res_it.restart_page(); page_res_it.word() != nullptr; page_res_it.forward()) {
233        if (page_res_it.word()->word->flag(W_REP_CHAR)) {
234          fix_rep_char(&page_res_it);
235          continue;
236        }
237        if (page_res_it.word()->best_choice->permuter() == USER_DAWG_PERM) {
238          ++(stats_.dict_words);
239        }
240        if (page_res_it.word()->blamer_bundle != nullptr &&
241            page_res_it.word()->blamer_bundle->misadaption_debug().length() > 0) {
242          page_res->misadaption_log.push_back(page_res_it.word()->blamer_bundle->misadaption_debug());
243        }
244      }
245    }
246    if (dopasses == 1) {
247      return true;
248    }
249  #ifndef DISABLED_LEGACY_ENGINE
250    if (tessedit_tess_adaption_mode != 0x0 && !tessedit_test_adaption && AnyTessLang()) {
251      page_res_it.restart_page();
252      std::vector<WordData> words;
253      SetupAllWordsPassN(2, target_word_box, word_config, page_res, &words);
254      if (tessedit_parallelize) {
255        PrerecAllWordsPar(words);
256      }
257      most_recently_used_ = this;
258      if (!RecogAllWordsPassN(2, monitor, &page_res_it, &words)) {
259        return false;
260      }
261    }
262    if (AnyTessLang() && !AnyLSTMLang()) {
263      if (!tessedit_test_adaption && tessedit_fix_fuzzy_spaces && !tessedit_word_for_word &&
264          !right_to_left()) {
265        fix_fuzzy_spaces(monitor, stats_.word_count, page_res);
266      }
267      if (tessedit_enable_dict_correction) {
268        dictionary_correction_pass(page_res);
269      }
270      if (tessedit_enable_bigram_correction) {
271        bigram_correction_pass(page_res);
272      }
273      rejection_passes(page_res, monitor, target_word_box, word_config);
274      font_recognition_pass(page_res);
275      blamer_pass(page_res);
276      script_pos_pass(page_res);
277    }
278  #endif 
279  #ifndef DISABLED_LEGACY_ENGINE
280    if ((dopasses == 0 || dopasses == 2) && (monitor || tessedit_write_unlv)) {
281      output_pass(page_res_it, target_word_box);
282    }
283  #endif 
284    const auto pageseg_mode = static_cast<PageSegMode>(static_cast<int>(tessedit_pageseg_mode));
285    textord_.CleanupSingleRowResult(pageseg_mode, page_res);
286    for (page_res_it.restart_page(); page_res_it.word() != nullptr; page_res_it.forward()) {
287      const WERD_RES *word = page_res_it.word();
288      const POLY_BLOCK *pb = page_res_it.block()->block != nullptr
289                                 ? page_res_it.block()->block->pdblk.poly_block()
290                                 : nullptr;
291      if (word->best_choice == nullptr || word->best_choice->empty() ||
292          (word->best_choice->IsAllSpaces() && (pb == nullptr || pb->IsText()))) {
293        page_res_it.DeleteCurrentWord();
294      }
295    }
296    if (monitor != nullptr) {
297      monitor->progress = 100;
298    }
299    return true;
300  }
301  #ifndef DISABLED_LEGACY_ENGINE
302  void Tesseract::bigram_correction_pass(PAGE_RES *page_res) {
303    PAGE_RES_IT word_it(page_res);
304    WERD_RES *w_prev = nullptr;
305    WERD_RES *w = word_it.word();
306    while (true) {
307      w_prev = w;
308      while (word_it.forward() != nullptr && (!word_it.word() || word_it.word()->part_of_combo)) {
309      }
310      if (!word_it.word()) {
311        break;
312      }
313      w = word_it.word();
314      if (!w || !w_prev || w->uch_set != w_prev->uch_set) {
315        continue;
316      }
317      if (w_prev->word->flag(W_REP_CHAR) || w->word->flag(W_REP_CHAR)) {
318        if (tessedit_bigram_debug) {
319          tprintf("Skipping because one of the words is W_REP_CHAR\n");
320        }
321        continue;
322      }
323      std::vector<WERD_CHOICE *> overrides_word1;
324      std::vector<WERD_CHOICE *> overrides_word2;
325      const auto orig_w1_str = w_prev->best_choice->unichar_string();
326      const auto orig_w2_str = w->best_choice->unichar_string();
327      WERD_CHOICE prev_best(w->uch_set);
328      {
329        int w1start, w1end;
330        w_prev->best_choice->GetNonSuperscriptSpan(&w1start, &w1end);
331        prev_best = w_prev->best_choice->shallow_copy(w1start, w1end);
332      }
333      WERD_CHOICE this_best(w->uch_set);
334      {
335        int w2start, w2end;
336        w->best_choice->GetNonSuperscriptSpan(&w2start, &w2end);
337        this_best = w->best_choice->shallow_copy(w2start, w2end);
338      }
339      if (w->tesseract->getDict().valid_bigram(prev_best, this_best)) {
340        if (tessedit_bigram_debug) {
341          tprintf("Top choice \"%s %s\" verified by bigram model.\n", orig_w1_str.c_str(),
342                  orig_w2_str.c_str());
343        }
344        continue;
345      }
346      if (tessedit_bigram_debug > 2) {
347        tprintf("Examining alt choices for \"%s %s\".\n", orig_w1_str.c_str(), orig_w2_str.c_str());
348      }
349      if (tessedit_bigram_debug > 1) {
350        if (!w_prev->best_choices.singleton()) {
351          w_prev->PrintBestChoices();
352        }
353        if (!w->best_choices.singleton()) {
354          w->PrintBestChoices();
355        }
356      }
357      float best_rating = 0.0;
358      int best_idx = 0;
359      WERD_CHOICE_IT prev_it(&w_prev->best_choices);
360      for (prev_it.mark_cycle_pt(); !prev_it.cycled_list(); prev_it.forward()) {
361        WERD_CHOICE *p1 = prev_it.data();
362        WERD_CHOICE strip1(w->uch_set);
363        {
364          int p1start, p1end;
365          p1->GetNonSuperscriptSpan(&p1start, &p1end);
366          strip1 = p1->shallow_copy(p1start, p1end);
367        }
368        WERD_CHOICE_IT w_it(&w->best_choices);
369        for (w_it.mark_cycle_pt(); !w_it.cycled_list(); w_it.forward()) {
370          WERD_CHOICE *p2 = w_it.data();
371          WERD_CHOICE strip2(w->uch_set);
372          {
373            int p2start, p2end;
374            p2->GetNonSuperscriptSpan(&p2start, &p2end);
375            strip2 = p2->shallow_copy(p2start, p2end);
376          }
377          if (w->tesseract->getDict().valid_bigram(strip1, strip2)) {
378            overrides_word1.push_back(p1);
379            overrides_word2.push_back(p2);
380            if (overrides_word1.size() == 1 || p1->rating() + p2->rating() < best_rating) {
381              best_rating = p1->rating() + p2->rating();
382              best_idx = overrides_word1.size() - 1;
383            }
384          }
385        }
386      }
387      if (!overrides_word1.empty()) {
388        if (EqualIgnoringCaseAndTerminalPunct(*w_prev->best_choice, *overrides_word1[best_idx]) &&
389            EqualIgnoringCaseAndTerminalPunct(*w->best_choice, *overrides_word2[best_idx])) {
390          if (tessedit_bigram_debug > 1) {
391            tprintf(
392                "Top choice \"%s %s\" verified (sans case) by bigram "
393                "model.\n",
394                orig_w1_str.c_str(), orig_w2_str.c_str());
395          }
396          continue;
397        }
398        const auto new_w1_str = overrides_word1[best_idx]->unichar_string();
399        const auto new_w2_str = overrides_word2[best_idx]->unichar_string();
400        if (new_w1_str != orig_w1_str) {
401          w_prev->ReplaceBestChoice(overrides_word1[best_idx]);
402        }
403        if (new_w2_str != orig_w2_str) {
404          w->ReplaceBestChoice(overrides_word2[best_idx]);
405        }
406        if (tessedit_bigram_debug > 0) {
407          std::string choices_description;
408          int num_bigram_choices = overrides_word1.size() * overrides_word2.size();
409          if (num_bigram_choices == 1) {
410            choices_description = "This was the unique bigram choice.";
411          } else {
412            if (tessedit_bigram_debug > 1) {
413              std::string bigrams_list;
414              const int kMaxChoicesToPrint = 20;
415              for (unsigned i = 0; i < overrides_word1.size() && i < kMaxChoicesToPrint; i++) {
416                if (i > 0) {
417                  bigrams_list += ", ";
418                }
419                WERD_CHOICE *p1 = overrides_word1[i];
420                WERD_CHOICE *p2 = overrides_word2[i];
421                bigrams_list += p1->unichar_string() + " " + p2->unichar_string();
422              }
423              choices_description = "There were many choices: {";
424              choices_description += bigrams_list;
425              choices_description += "}";
426            } else {
427              choices_description += "There were " + std::to_string(num_bigram_choices);
428              choices_description += " compatible bigrams.";
429            }
430          }
431          tprintf("Replaced \"%s %s\" with \"%s %s\" with bigram model. %s\n", orig_w1_str.c_str(),
432                  orig_w2_str.c_str(), new_w1_str.c_str(), new_w2_str.c_str(),
433                  choices_description.c_str());
434        }
435      }
436    }
437  }
438  void Tesseract::rejection_passes(PAGE_RES *page_res, ETEXT_DESC *monitor,
439                                   const TBOX *target_word_box, const char *word_config) {
440    PAGE_RES_IT page_res_it(page_res);
441    int word_index = 0;
442    while (!tessedit_test_adaption && page_res_it.word() != nullptr) {
443      WERD_RES *word = page_res_it.word();
444      word_index++;
445      if (monitor != nullptr) {
446        monitor->ocr_alive = true;
447        monitor->progress = 95 + 5 * word_index / stats_.word_count;
448      }
449      if (word->rebuild_word == nullptr) {
450        page_res_it.forward();
451        continue;
452      }
453      check_debug_pt(word, 70);
454      if (target_word_box &&
455          !ProcessTargetWord(word->word->bounding_box(), *target_word_box, word_config, 4)) {
456        page_res_it.forward();
457        continue;
458      }
459      page_res_it.rej_stat_word();
460      const int chars_in_word = word->reject_map.length();
461      const int rejects_in_word = word->reject_map.reject_count();
462      const int blob_quality = word_blob_quality(word);
463      stats_.doc_blob_quality += blob_quality;
464      const int outline_errs = word_outline_errs(word);
465      stats_.doc_outline_errs += outline_errs;
466      int16_t all_char_quality;
467      int16_t accepted_all_char_quality;
468      word_char_quality(word, &all_char_quality, &accepted_all_char_quality);
469      stats_.doc_char_quality += all_char_quality;
470      const uint8_t permuter_type = word->best_choice->permuter();
471      if ((permuter_type == SYSTEM_DAWG_PERM) || (permuter_type == FREQ_DAWG_PERM) ||
472          (permuter_type == USER_DAWG_PERM)) {
473        stats_.good_char_count += chars_in_word - rejects_in_word;
474        stats_.doc_good_char_quality += accepted_all_char_quality;
475      }
476      check_debug_pt(word, 80);
477      if (tessedit_reject_bad_qual_wds && (blob_quality == 0) && (outline_errs >= chars_in_word)) {
478        word->reject_map.rej_word_bad_quality();
479      }
480      check_debug_pt(word, 90);
481      page_res_it.forward();
482    }
483    if (tessedit_debug_quality_metrics) {
484      tprintf(
485          "QUALITY: num_chs= %d  num_rejs= %d %5.3f blob_qual= %d %5.3f"
486          " outline_errs= %d %5.3f char_qual= %d %5.3f good_ch_qual= %d %5.3f\n",
487          page_res->char_count, page_res->rej_count,
488          page_res->rej_count / static_cast<float>(page_res->char_count), stats_.doc_blob_quality,
489          stats_.doc_blob_quality / static_cast<float>(page_res->char_count), stats_.doc_outline_errs,
490          stats_.doc_outline_errs / static_cast<float>(page_res->char_count), stats_.doc_char_quality,
491          stats_.doc_char_quality / static_cast<float>(page_res->char_count),
492          stats_.doc_good_char_quality,
493          (stats_.good_char_count > 0)
494              ? (stats_.doc_good_char_quality / static_cast<float>(stats_.good_char_count))
495              : 0.0);
496    }
497    bool good_quality_doc =
498        ((page_res->rej_count / static_cast<float>(page_res->char_count)) <= quality_rej_pc) &&
499        (stats_.doc_blob_quality / static_cast<float>(page_res->char_count) >= quality_blob_pc) &&
500        (stats_.doc_outline_errs / static_cast<float>(page_res->char_count) <= quality_outline_pc) &&
501        (stats_.doc_char_quality / static_cast<float>(page_res->char_count) >= quality_char_pc);
502    if (!tessedit_test_adaption) {
503      quality_based_rejection(page_res_it, good_quality_doc);
504    }
505  }
506  #endif 
507  void Tesseract::blamer_pass(PAGE_RES *page_res) {
508    if (!wordrec_run_blamer) {
509      return;
510    }
511    PAGE_RES_IT page_res_it(page_res);
512    for (page_res_it.restart_page(); page_res_it.word() != nullptr; page_res_it.forward()) {
513      WERD_RES *word = page_res_it.word();
514      BlamerBundle::LastChanceBlame(wordrec_debug_blamer, word);
515      page_res->blame_reasons[word->blamer_bundle->incorrect_result_reason()]++;
516    }
517    tprintf("Blame reasons:\n");
518    for (int bl = 0; bl < IRR_NUM_REASONS; ++bl) {
519      tprintf("%s %d\n", BlamerBundle::IncorrectReasonName(static_cast<IncorrectResultReason>(bl)),
520              page_res->blame_reasons[bl]);
521    }
522    if (page_res->misadaption_log.size() > 0) {
523      tprintf("Misadaption log:\n");
524      for (auto &log : page_res->misadaption_log) {
525        tprintf("%s\n", log.c_str());
526      }
527    }
528  }
529  void Tesseract::script_pos_pass(PAGE_RES *page_res) {
530    PAGE_RES_IT page_res_it(page_res);
531    for (page_res_it.restart_page(); page_res_it.word() != nullptr; page_res_it.forward()) {
532      WERD_RES *word = page_res_it.word();
533      if (word->word->flag(W_REP_CHAR)) {
534        page_res_it.forward();
535        continue;
536      }
537      const float x_height = page_res_it.block()->block->x_height();
538      float word_x_height = word->x_height;
539      if (word_x_height < word->best_choice->min_x_height() ||
540          word_x_height > word->best_choice->max_x_height()) {
541        word_x_height =
542            (word->best_choice->min_x_height() + word->best_choice->max_x_height()) / 2.0f;
543      }
544      const double small_cap_xheight = x_height * kXHeightCapRatio;
545      const double small_cap_delta = (x_height - small_cap_xheight) / 2.0;
546      if (word->uch_set->script_has_xheight() &&
547          small_cap_xheight - small_cap_delta <= word_x_height &&
548          word_x_height <= small_cap_xheight + small_cap_delta) {
549        int num_upper = 0;
550        int num_lower = 0;
551        for (unsigned i = 0; i < word->best_choice->length(); ++i) {
552          if (word->uch_set->get_isupper(word->best_choice->unichar_id(i))) {
553            ++num_upper;
554          } else if (word->uch_set->get_islower(word->best_choice->unichar_id(i))) {
555            ++num_lower;
556          }
557        }
558        if (num_upper > 0 && num_lower == 0) {
559          word->small_caps = true;
560        }
561      }
562      word->SetScriptPositions();
563    }
564  }
565  static void WordGap(const PointerVector<WERD_RES> &words, unsigned index, int *right, int *next_left) {
566    *right = -INT32_MAX;
567    *next_left = INT32_MAX;
568    if (index < words.size()) {
569      *right = words[index]->word->bounding_box().right();
570      if (index + 1 < words.size()) {
571        *next_left = words[index + 1]->word->bounding_box().left();
572      }
573    }
574  }
575  static void EvaluateWordSpan(const PointerVector<WERD_RES> &words, unsigned first_index, unsigned end_index,
576                               float *rating, float *certainty, bool *bad, bool *valid_permuter) {
577    if (end_index <= first_index) {
578      *bad = true;
579      *valid_permuter = false;
580    }
581    for (unsigned index = first_index; index < end_index && index < words.size(); ++index) {
582      WERD_CHOICE *choice = words[index]->best_choice;
583      if (choice == nullptr) {
584        *bad = true;
585      } else {
586        *rating += choice->rating();
587        *certainty = std::min(*certainty, choice->certainty());
588        if (!Dict::valid_word_permuter(choice->permuter(), false)) {
589          *valid_permuter = false;
590        }
591      }
592    }
593  }
594  static int SelectBestWords(double rating_ratio, double certainty_margin, bool debug,
595                             PointerVector<WERD_RES> *new_words,
596                             PointerVector<WERD_RES> *best_words) {
597    std::vector<WERD_RES *> out_words;
598    unsigned b = 0, n = 0;
599    int num_best = 0, num_new = 0;
600    while (b < best_words->size() || n < new_words->size()) {
601      auto start_b = b, start_n = n;
602      while (b < best_words->size() || n < new_words->size()) {
603        int b_right = -INT32_MAX;
604        int next_b_left = INT32_MAX;
605        WordGap(*best_words, b, &b_right, &next_b_left);
606        int n_right = -INT32_MAX;
607        int next_n_left = INT32_MAX;
608        WordGap(*new_words, n, &n_right, &next_n_left);
609        if (std::max(b_right, n_right) < std::min(next_b_left, next_n_left)) {
610          break;
611        }
612        if ((b_right < n_right && b < best_words->size()) || n == new_words->size()) {
613          ++b;
614        } else {
615          ++n;
616        }
617      }
618      float b_rating = 0.0f, n_rating = 0.0f;
619      float b_certainty = 0.0f, n_certainty = 0.0f;
620      bool b_bad = false, n_bad = false;
<span onclick='openModal()' class='match'>621      bool b_valid_permuter = true, n_valid_permuter = true;
622      const int end_b = b < best_words->size() ? b + 1 : b;
623      const int end_n = n < new_words->size() ? n + 1 : n;
</span>624      EvaluateWordSpan(*best_words, start_b, end_b, &b_rating, &b_certainty, &b_bad,
625                       &b_valid_permuter);
626      EvaluateWordSpan(*new_words, start_n, end_n, &n_rating, &n_certainty, &n_bad,
627                       &n_valid_permuter);
628      bool new_better = false;
629      if (!n_bad && (b_bad || (n_certainty > b_certainty && n_rating < b_rating) ||
630                     (!b_valid_permuter && n_valid_permuter && n_rating < b_rating * rating_ratio &&
631                      n_certainty > b_certainty - certainty_margin))) {
632        for (int i = start_n; i < end_n; ++i) {
633          out_words.push_back((*new_words)[i]);
634          (*new_words)[i] = nullptr;
635          ++num_new;
636        }
637        new_better = true;
638      } else if (!b_bad) {
639        for (int i = start_b; i < end_b; ++i) {
640          out_words.push_back((*best_words)[i]);
641          (*best_words)[i] = nullptr;
642          ++num_best;
643        }
644      }
645      if (debug) {
646        tprintf(
647            "%d new words %s than %d old words: r: %g v %g c: %g v %g"
648            " valid dict: %d v %d\n",
649            end_n - start_n, new_better ? "better" : "worse", end_b - start_b, n_rating, b_rating,
650            n_certainty, b_certainty, n_valid_permuter, b_valid_permuter);
651      }
652      b = end_b;
653      n = end_n;
654    }
655    best_words->clear();
656    for (auto &out_word : out_words) {
657      best_words->push_back(out_word);
658    }
659    return num_new - num_best;
660  }
661  int Tesseract::RetryWithLanguage(const WordData &word_data, WordRecognizer recognizer, bool debug,
662                                   WERD_RES **in_word, PointerVector<WERD_RES> *best_words) {
663    if (debug) {
664      tprintf("Trying word using lang %s, oem %d\n", lang.c_str(),
665              static_cast<int>(tessedit_ocr_engine_mode));
666    }
667    PointerVector<WERD_RES> new_words;
668    (this->*recognizer)(word_data, in_word, &new_words);
669    if (new_words.empty()) {
670      new_words.push_back(*in_word);
671      *in_word = nullptr;
672    }
673    if (debug) {
674      for (unsigned i = 0; i < new_words.size(); ++i) {
675        new_words[i]->DebugTopChoice("Lang result");
676      }
677    }
678    return SelectBestWords(classify_max_rating_ratio, classify_max_certainty_margin, debug,
679                           &new_words, best_words);
680  }
681  static bool WordsAcceptable(const PointerVector<WERD_RES> &words) {
682    for (unsigned w = 0; w < words.size(); ++w) {
683      if (words[w]->tess_failed || !words[w]->tess_accepted) {
684        return false;
685      }
686    }
687    return true;
688  }
689  #ifndef DISABLED_LEGACY_ENGINE
690  bool Tesseract::ReassignDiacritics(int pass, PAGE_RES_IT *pr_it, bool *make_next_word_fuzzy) {
691    *make_next_word_fuzzy = false;
692    WERD *real_word = pr_it->word()->word;
693    if (real_word->rej_cblob_list()->empty() || real_word->cblob_list()->empty() ||
694        real_word->rej_cblob_list()->length() > noise_maxperword) {
695      return false;
696    }
697    real_word->rej_cblob_list()->sort(&C_BLOB::SortByXMiddle);
698    std::vector<C_OUTLINE *> outlines;
699    real_word->GetNoiseOutlines(&outlines);
700    std::vector<bool> word_wanted;
701    std::vector<bool> overlapped_any_blob;
702    std::vector<C_BLOB *> target_blobs;
703    AssignDiacriticsToOverlappingBlobs(outlines, pass, real_word, pr_it, &word_wanted,
704                                       &overlapped_any_blob, &target_blobs);
705    std::vector<bool> wanted;
706    std::vector<C_BLOB *> wanted_blobs;
707    std::vector<C_OUTLINE *> wanted_outlines;
708    int num_overlapped = 0;
709    int num_overlapped_used = 0;
710    for (unsigned i = 0; i < overlapped_any_blob.size(); ++i) {
711      if (overlapped_any_blob[i]) {
712        ++num_overlapped;
713        if (word_wanted[i]) {
714          ++num_overlapped_used;
715        }
716        wanted.push_back(word_wanted[i]);
717        wanted_blobs.push_back(target_blobs[i]);
718        wanted_outlines.push_back(outlines[i]);
719        outlines[i] = nullptr;
720      }
721    }
722    real_word->AddSelectedOutlines(wanted, wanted_blobs, wanted_outlines, nullptr);
723    AssignDiacriticsToNewBlobs(outlines, pass, real_word, pr_it, &word_wanted, &target_blobs);
724    int non_overlapped = 0;
725    int non_overlapped_used = 0;
726    for (unsigned i = 0; i < word_wanted.size(); ++i) {
727      if (word_wanted[i]) {
728        ++non_overlapped_used;
729      }
730      if (outlines[i] != nullptr) {
731        ++non_overlapped_used;
732      }
733    }
734    if (debug_noise_removal) {
735      tprintf("Used %d/%d overlapped %d/%d non-overlaped diacritics on word:", num_overlapped_used,
736              num_overlapped, non_overlapped_used, non_overlapped);
737      real_word->bounding_box().print();
738    }
739    if (real_word->AddSelectedOutlines(word_wanted, target_blobs, outlines, make_next_word_fuzzy)) {
740      pr_it->MakeCurrentWordFuzzy();
741    }
742    return num_overlapped_used != 0 || non_overlapped_used != 0;
743  }
744  void Tesseract::AssignDiacriticsToOverlappingBlobs(const std::vector<C_OUTLINE *> &outlines,
745                                                     int pass, WERD *real_word, PAGE_RES_IT *pr_it,
746                                                     std::vector<bool> *word_wanted,
747                                                     std::vector<bool> *overlapped_any_blob,
748                                                     std::vector<C_BLOB *> *target_blobs) {
749    std::vector<bool> blob_wanted;
750    word_wanted->clear();
751    word_wanted->resize(outlines.size());
752    overlapped_any_blob->clear();
753    overlapped_any_blob->resize(outlines.size());
754    target_blobs->clear();
755    target_blobs->resize(outlines.size());
756    C_BLOB_IT blob_it(real_word->cblob_list());
757    for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
758      C_BLOB *blob = blob_it.data();
759      const TBOX blob_box = blob->bounding_box();
760      blob_wanted.clear();
761      blob_wanted.resize(outlines.size());
762      int num_blob_outlines = 0;
763      for (unsigned i = 0; i < outlines.size(); ++i) {
764        if (blob_box.major_x_overlap(outlines[i]->bounding_box()) && !(*word_wanted)[i]) {
765          blob_wanted[i] = true;
766          (*overlapped_any_blob)[i] = true;
767          ++num_blob_outlines;
768        }
769      }
770      if (debug_noise_removal) {
771        tprintf("%d noise outlines overlap blob at:", num_blob_outlines);
772        blob_box.print();
773      }
774      if (0 < num_blob_outlines && num_blob_outlines < noise_maxperblob) {
775        if (SelectGoodDiacriticOutlines(pass, noise_cert_basechar, pr_it, blob, outlines,
776                                        num_blob_outlines, &blob_wanted)) {
777          for (unsigned i = 0; i < blob_wanted.size(); ++i) {
778            if (blob_wanted[i]) {
779              (*word_wanted)[i] = true;
780              (*target_blobs)[i] = blob;
781            }
782          }
783        }
784      }
785    }
786  }
787  void Tesseract::AssignDiacriticsToNewBlobs(const std::vector<C_OUTLINE *> &outlines, int pass,
788                                             WERD *real_word, PAGE_RES_IT *pr_it,
789                                             std::vector<bool> *word_wanted,
790                                             std::vector<C_BLOB *> *target_blobs) {
791    std::vector<bool> blob_wanted;
792    word_wanted->clear();
793    word_wanted->resize(outlines.size());
794    target_blobs->clear();
795    target_blobs->resize(outlines.size());
796    for (unsigned i = 0; i < outlines.size(); ++i) {
797      if (outlines[i] == nullptr) {
798        continue;
799      }
800      blob_wanted.clear();
801      blob_wanted.resize(outlines.size());
802      int num_blob_outlines = 0;
803      TBOX total_ol_box(outlines[i]->bounding_box());
804      while (i < outlines.size() && outlines[i] != nullptr) {
805        blob_wanted[i] = true;
806        total_ol_box += outlines[i]->bounding_box();
807        ++i;
808        ++num_blob_outlines;
809      }
810      C_BLOB_IT blob_it(real_word->cblob_list());
811      while (!blob_it.at_last() &&
812             blob_it.data_relative(1)->bounding_box().left() <= total_ol_box.left()) {
813        blob_it.forward();
814      }
815      if (debug_noise_removal) {
816        tprintf("Num blobless outlines = %d\n", num_blob_outlines);
817      }
818      C_BLOB *left_blob = blob_it.data();
819      TBOX left_box = left_blob->bounding_box();
820      C_BLOB *right_blob = blob_it.at_last() ? nullptr : blob_it.data_relative(1);
821      if ((left_box.x_overlap(total_ol_box) || right_blob == nullptr ||
822           !right_blob->bounding_box().x_overlap(total_ol_box)) &&
823          SelectGoodDiacriticOutlines(pass, noise_cert_disjoint, pr_it, left_blob, outlines,
824                                      num_blob_outlines, &blob_wanted)) {
825        if (debug_noise_removal) {
826          tprintf("Added to left blob\n");
827        }
828        for (unsigned j = 0; j < blob_wanted.size(); ++j) {
829          if (blob_wanted[j]) {
830            (*word_wanted)[j] = true;
831            (*target_blobs)[j] = left_blob;
832          }
833        }
834      } else if (right_blob != nullptr &&
835                 (!left_box.x_overlap(total_ol_box) ||
836                  right_blob->bounding_box().x_overlap(total_ol_box)) &&
837                 SelectGoodDiacriticOutlines(pass, noise_cert_disjoint, pr_it, right_blob, outlines,
838                                             num_blob_outlines, &blob_wanted)) {
839        if (debug_noise_removal) {
840          tprintf("Added to right blob\n");
841        }
842        for (unsigned j = 0; j < blob_wanted.size(); ++j) {
843          if (blob_wanted[j]) {
844            (*word_wanted)[j] = true;
845            (*target_blobs)[j] = right_blob;
846          }
847        }
848      } else if (SelectGoodDiacriticOutlines(pass, noise_cert_punc, pr_it, nullptr, outlines,
849                                             num_blob_outlines, &blob_wanted)) {
850        if (debug_noise_removal) {
851          tprintf("Fitted between blobs\n");
852        }
853        for (unsigned j = 0; j < blob_wanted.size(); ++j) {
854          if (blob_wanted[j]) {
855            (*word_wanted)[j] = true;
856            (*target_blobs)[j] = nullptr;
857          }
858        }
859      }
860    }
861  }
862  bool Tesseract::SelectGoodDiacriticOutlines(int pass, float certainty_threshold, PAGE_RES_IT *pr_it,
863                                              C_BLOB *blob,
864                                              const std::vector<C_OUTLINE *> &outlines,
865                                              int num_outlines, std::vector<bool> *ok_outlines) {
866    std::string best_str;
867    float target_cert = certainty_threshold;
868    if (blob != nullptr) {
869      float target_c2;
870      target_cert = ClassifyBlobAsWord(pass, pr_it, blob, best_str, &target_c2);
871      if (debug_noise_removal) {
872        tprintf("No Noise blob classified as %s=%g(%g) at:", best_str.c_str(), target_cert,
873                target_c2);
874        blob->bounding_box().print();
875      }
876      target_cert -= (target_cert - certainty_threshold) * noise_cert_factor;
877    }
878    std::vector<bool> test_outlines = *ok_outlines;
879    std::string all_str;
880    std::vector<bool> best_outlines = *ok_outlines;
881    float best_cert = ClassifyBlobPlusOutlines(test_outlines, outlines, pass, pr_it, blob, all_str);
882    if (debug_noise_removal) {
883      TBOX ol_box;
884      for (unsigned i = 0; i < test_outlines.size(); ++i) {
885        if (test_outlines[i]) {
886          ol_box += outlines[i]->bounding_box();
887        }
888      }
889      tprintf("All Noise blob classified as %s=%g, delta=%g at:", all_str.c_str(), best_cert,
890              best_cert - target_cert);
891      ol_box.print();
892    }
893    int best_index = 0; 
894    while (num_outlines > 1 && best_index >= 0 &&
895           (blob == nullptr || best_cert < target_cert || blob != nullptr)) {
896      best_index = -1;
897      for (unsigned i = 0; i < outlines.size(); ++i) {
898        if (test_outlines[i]) {
899          test_outlines[i] = false;
900          std::string str;
901          float cert = ClassifyBlobPlusOutlines(test_outlines, outlines, pass, pr_it, blob, str);
902          if (debug_noise_removal) {
903            TBOX ol_box;
904            for (unsigned j = 0; j < outlines.size(); ++j) {
905              if (test_outlines[j]) {
906                ol_box += outlines[j]->bounding_box();
907              }
908              tprintf("%c", test_outlines[j] ? 'T' : 'F');
909            }
910            tprintf(" blob classified as %s=%g, delta=%g) at:", str.c_str(), cert,
911                    cert - target_cert);
912            ol_box.print();
913          }
914          if (cert > best_cert) {
915            best_cert = cert;
916            best_index = i;
917            best_outlines = test_outlines;
918          }
919          test_outlines[i] = true;
920        }
921      }
922      if (best_index >= 0) {
923        test_outlines[best_index] = false;
924        --num_outlines;
925      }
926    }
927    if (best_cert >= target_cert) {
928      *ok_outlines = best_outlines;
929      if (debug_noise_removal) {
930        tprintf("%s noise combination ", blob ? "Adding" : "New");
931        for (auto &&best_outline : best_outlines) {
932          tprintf("%c", best_outline ? 'T' : 'F');
933        }
934        tprintf(" yields certainty %g, beating target of %g\n", best_cert, target_cert);
935      }
936      return true;
937    }
938    return false;
939  }
940  float Tesseract::ClassifyBlobPlusOutlines(const std::vector<bool> &ok_outlines,
941                                            const std::vector<C_OUTLINE *> &outlines, int pass_n,
942                                            PAGE_RES_IT *pr_it, C_BLOB *blob, std::string &best_str) {
943    C_OUTLINE_IT ol_it;
944    C_OUTLINE *first_to_keep = nullptr;
945    C_BLOB *local_blob = nullptr;
946    if (blob != nullptr) {
947      ol_it.set_to_list(blob->out_list());
948      first_to_keep = ol_it.data();
949    }
950    for (unsigned i = 0; i < ok_outlines.size(); ++i) {
951      if (ok_outlines[i]) {
952        if (blob == nullptr) {
953          local_blob = new C_BLOB(outlines[i]);
954          blob = local_blob;
955          ol_it.set_to_list(blob->out_list());
956        } else {
957          ol_it.add_before_stay_put(outlines[i]);
958        }
959      }
960    }
961    float c2;
962    float cert = ClassifyBlobAsWord(pass_n, pr_it, blob, best_str, &c2);
963    ol_it.move_to_first();
964    if (first_to_keep == nullptr) {
965      for (; !ol_it.empty(); ol_it.forward()) {
966        ol_it.extract();
967      }
968      delete local_blob;
969      cert = -c2;
970    } else {
971      for (; ol_it.data() != first_to_keep; ol_it.forward()) {
972        ol_it.extract();
973      }
974    }
975    return cert;
976  }
977  float Tesseract::ClassifyBlobAsWord(int pass_n, PAGE_RES_IT *pr_it, C_BLOB *blob, std::string &best_str,
978                                      float *c2) {
979    WERD *real_word = pr_it->word()->word;
980    WERD *word = real_word->ConstructFromSingleBlob(real_word->flag(W_BOL), real_word->flag(W_EOL),
981                                                    C_BLOB::deep_copy(blob));
982    WERD_RES *word_res = pr_it->InsertSimpleCloneWord(*pr_it->word(), word);
983    PAGE_RES_IT it(pr_it->page_res);
984    while (it.word() != word_res && it.word() != nullptr) {
985      it.forward();
986    }
987    ASSERT_HOST(it.word() == word_res);
988    WordData wd(it);
989    SetupWordPassN(1, &wd);
990    classify_word_and_language(pass_n, &it, &wd);
991    if (debug_noise_removal) {
992      if (wd.word->raw_choice != nullptr) {
993        tprintf("word xheight=%g, row=%g, range=[%g,%g]\n", word_res->x_height, wd.row->x_height(),
994                wd.word->raw_choice->min_x_height(), wd.word->raw_choice->max_x_height());
995      } else {
996        tprintf("Got word with null raw choice xheight=%g, row=%g\n", word_res->x_height,
997                wd.row->x_height());
998      }
999    }
1000    float cert = 0.0f;
1001    if (wd.word->raw_choice != nullptr) { 
1002      cert = wd.word->raw_choice->certainty();
1003      float rat = wd.word->raw_choice->rating();
1004      *c2 = rat > 0.0f ? cert * cert / rat : 0.0f;
1005      best_str = wd.word->raw_choice->unichar_string();
1006    } else {
1007      *c2 = 0.0f;
1008      best_str.clear();
1009    }
1010    it.DeleteCurrentWord();
1011    pr_it->ResetWordIterator();
1012    return cert;
1013  }
1014  #endif 
1015  void Tesseract::classify_word_and_language(int pass_n, PAGE_RES_IT *pr_it, WordData *word_data) {
1016  #ifdef DISABLED_LEGACY_ENGINE
1017    WordRecognizer recognizer = &Tesseract::classify_word_pass1;
1018  #else
1019    WordRecognizer recognizer =
1020        pass_n == 1 ? &Tesseract::classify_word_pass1 : &Tesseract::classify_word_pass2;
1021  #endif 
1022    PointerVector<WERD_RES> best_words;
1023    const WERD_RES *word = word_data->word;
1024    clock_t start_t = clock();
1025    const bool debug = classify_debug_level > 0 || multilang_debug_level > 0;
1026    if (debug) {
1027      tprintf("%s word with lang %s at:", word->done ? "Already done" : "Processing",
1028              most_recently_used_->lang.c_str());
1029      word->word->bounding_box().print();
1030    }
1031    if (word->done) {
1032      if (!word->tess_failed) {
1033        most_recently_used_ = word->tesseract;
1034      }
1035      return;
1036    }
1037    auto sub = sub_langs_.size();
1038    if (most_recently_used_ != this) {
1039      for (sub = 0; sub < sub_langs_.size() && most_recently_used_ != sub_langs_[sub]; ++sub) {
1040      }
1041    }
1042    most_recently_used_->RetryWithLanguage(*word_data, recognizer, debug, &word_data->lang_words[sub],
1043                                           &best_words);
1044    Tesseract *best_lang_tess = most_recently_used_;
1045    if (!WordsAcceptable(best_words)) {
1046      if (most_recently_used_ != this &&
1047          this->RetryWithLanguage(*word_data, recognizer, debug,
1048                                  &word_data->lang_words[sub_langs_.size()], &best_words) > 0) {
1049        best_lang_tess = this;
1050      }
1051      for (unsigned i = 0; !WordsAcceptable(best_words) && i < sub_langs_.size(); ++i) {
1052        if (most_recently_used_ != sub_langs_[i] &&
1053            sub_langs_[i]->RetryWithLanguage(*word_data, recognizer, debug, &word_data->lang_words[i],
1054                                             &best_words) > 0) {
1055          best_lang_tess = sub_langs_[i];
1056        }
1057      }
1058    }
1059    most_recently_used_ = best_lang_tess;
1060    if (!best_words.empty()) {
1061      if (best_words.size() == 1 && !best_words[0]->combination) {
1062        word_data->word->ConsumeWordResults(best_words[0]);
1063      } else {
1064        word_data->word = best_words.back();
1065        pr_it->ReplaceCurrentWord(&best_words);
1066      }
1067      ASSERT_HOST(word_data->word->box_word != nullptr);
1068    } else {
1069      tprintf("no best words!!\n");
1070    }
1071    clock_t ocr_t = clock();
1072    if (tessedit_timing_debug) {
1073      tprintf("%s (ocr took %.2f sec)\n", word_data->word->best_choice->unichar_string().c_str(),
1074              static_cast<double>(ocr_t - start_t) / CLOCKS_PER_SEC);
1075    }
1076  }
1077  void Tesseract::classify_word_pass1(const WordData &word_data, WERD_RES **in_word,
1078                                      PointerVector<WERD_RES> *out_words) {
1079    ROW *row = word_data.row;
1080    BLOCK *block = word_data.block;
1081    prev_word_best_choice_ =
1082        word_data.prev_word != nullptr ? word_data.prev_word->word->best_choice : nullptr;
1083  #ifdef DISABLED_LEGACY_ENGINE
1084    if (tessedit_ocr_engine_mode == OEM_LSTM_ONLY) {
1085  #else
1086    if (tessedit_ocr_engine_mode == OEM_LSTM_ONLY ||
1087        tessedit_ocr_engine_mode == OEM_TESSERACT_LSTM_COMBINED) {
1088  #endif 
1089      if (!(*in_word)->odd_size || tessedit_ocr_engine_mode == OEM_LSTM_ONLY) {
1090        LSTMRecognizeWord(*block, row, *in_word, out_words);
1091        if (!out_words->empty()) {
1092          return; 
1093        }
1094      }
1095      if (tessedit_ocr_engine_mode == OEM_LSTM_ONLY) {
1096        (*in_word)->SetupFake(lstm_recognizer_->GetUnicharset());
1097        return;
1098      }
1099  #ifndef DISABLED_LEGACY_ENGINE
1100      (*in_word)->SetupForRecognition(unicharset, this, BestPix(), OEM_TESSERACT_ONLY, nullptr,
1101                                      classify_bln_numeric_mode, textord_use_cjk_fp_model,
1102                                      poly_allow_detailed_fx, row, block);
1103  #endif 
1104    }
1105  #ifndef DISABLED_LEGACY_ENGINE
1106    WERD_RES *word = *in_word;
1107    match_word_pass_n(1, word, row, block);
1108    if (!word->tess_failed && !word->word->flag(W_REP_CHAR)) {
1109      word->tess_would_adapt = AdaptableWord(word);
1110      bool adapt_ok = word_adaptable(word, tessedit_tess_adaption_mode);
1111      if (adapt_ok) {
1112        word->BestChoiceToCorrectText();
1113        LearnWord(nullptr, word);
1114        if (word->blamer_bundle != nullptr) {
1115          word->blamer_bundle->SetMisAdaptionDebug(word->best_choice, wordrec_debug_blamer);
1116        }
1117      }
1118      if (tessedit_enable_doc_dict && !word->IsAmbiguous()) {
1119        tess_add_doc_word(word->best_choice);
1120      }
1121    }
1122  #endif 
1123  }
1124  void Tesseract::ReportXhtFixResult(bool accept_new_word, float new_x_ht, WERD_RES *word,
1125                                     WERD_RES *new_word) {
1126    tprintf("New XHT Match:%s = %s ", word->best_choice->unichar_string().c_str(),
1127            word->best_choice->debug_string().c_str());
1128    word->reject_map.print(debug_fp);
1129    tprintf(" -> %s = %s ", new_word->best_choice->unichar_string().c_str(),
1130            new_word->best_choice->debug_string().c_str());
1131    new_word->reject_map.print(debug_fp);
1132    tprintf(" %s->%s %s %s\n", word->guessed_x_ht ? "GUESS" : "CERT",
1133            new_word->guessed_x_ht ? "GUESS" : "CERT", new_x_ht > 0.1 ? "STILL DOUBT" : "OK",
1134            accept_new_word ? "ACCEPTED" : "");
1135  }
1136  #ifndef DISABLED_LEGACY_ENGINE
1137  bool Tesseract::TrainedXheightFix(WERD_RES *word, BLOCK *block, ROW *row) {
1138    int original_misfits = CountMisfitTops(word);
1139    if (original_misfits == 0) {
1140      return false;
1141    }
1142    float baseline_shift = 0.0f;
1143    float new_x_ht = ComputeCompatibleXheight(word, &baseline_shift);
1144    if (baseline_shift != 0.0f) {
1145      if (!TestNewNormalization(original_misfits, baseline_shift, word->x_height, word, block, row)) {
1146        return false;
1147      }
1148      original_misfits = CountMisfitTops(word);
1149      if (original_misfits > 0) {
1150        float new_baseline_shift;
1151        new_x_ht = ComputeCompatibleXheight(word, &new_baseline_shift);
1152        if (new_x_ht >= kMinRefitXHeightFraction * word->x_height) {
1153          TestNewNormalization(original_misfits, baseline_shift, new_x_ht, word, block, row);
1154        }
1155      }
1156      return true;
1157    } else if (new_x_ht >= kMinRefitXHeightFraction * word->x_height) {
1158      return TestNewNormalization(original_misfits, 0.0f, new_x_ht, word, block, row);
1159    } else {
1160      return false;
1161    }
1162  }
1163  bool Tesseract::TestNewNormalization(int original_misfits, float baseline_shift, float new_x_ht,
1164                                       WERD_RES *word, BLOCK *block, ROW *row) {
1165    bool accept_new_x_ht = false;
1166    WERD_RES new_x_ht_word(word->word);
1167    if (word->blamer_bundle != nullptr) {
1168      new_x_ht_word.blamer_bundle = new BlamerBundle();
1169      new_x_ht_word.blamer_bundle->CopyTruth(*(word->blamer_bundle));
1170    }
1171    new_x_ht_word.x_height = new_x_ht;
1172    new_x_ht_word.baseline_shift = baseline_shift;
1173    new_x_ht_word.caps_height = 0.0;
1174    new_x_ht_word.SetupForRecognition(unicharset, this, BestPix(), tessedit_ocr_engine_mode, nullptr,
1175                                      classify_bln_numeric_mode, textord_use_cjk_fp_model,
1176                                      poly_allow_detailed_fx, row, block);
1177    match_word_pass_n(2, &new_x_ht_word, row, block);
1178    if (!new_x_ht_word.tess_failed) {
1179      int new_misfits = CountMisfitTops(&new_x_ht_word);
1180      if (debug_x_ht_level >= 1) {
1181        tprintf("Old misfits=%d with x-height %f, new=%d with x-height %f\n", original_misfits,
1182                word->x_height, new_misfits, new_x_ht);
1183        tprintf("Old rating= %f, certainty=%f, new=%f, %f\n", word->best_choice->rating(),
1184                word->best_choice->certainty(), new_x_ht_word.best_choice->rating(),
1185                new_x_ht_word.best_choice->certainty());
1186      }
1187      accept_new_x_ht = new_misfits < original_misfits &&
1188                        (new_x_ht_word.best_choice->certainty() > word->best_choice->certainty() ||
1189                         new_x_ht_word.best_choice->rating() < word->best_choice->rating());
1190      if (debug_x_ht_level >= 1) {
1191        ReportXhtFixResult(accept_new_x_ht, new_x_ht, word, &new_x_ht_word);
1192      }
1193    }
1194    if (accept_new_x_ht) {
1195      word->ConsumeWordResults(&new_x_ht_word);
1196      return true;
1197    }
1198    return false;
1199  }
1200  #endif 
1201  void Tesseract::classify_word_pass2(const WordData &word_data, WERD_RES **in_word,
1202                                      PointerVector<WERD_RES> *out_words) {
1203    if (tessedit_ocr_engine_mode == OEM_LSTM_ONLY) {
1204      return;
1205    }
1206  #ifndef DISABLED_LEGACY_ENGINE
1207    ROW *row = word_data.row;
1208    BLOCK *block = word_data.block;
1209    WERD_RES *word = *in_word;
1210    prev_word_best_choice_ =
1211        word_data.prev_word != nullptr ? word_data.prev_word->word->best_choice : nullptr;
1212    check_debug_pt(word, 30);
1213    if (!word->done) {
1214      word->caps_height = 0.0;
1215      if (word->x_height == 0.0f) {
1216        word->x_height = row->x_height();
1217      }
1218      match_word_pass_n(2, word, row, block);
1219      check_debug_pt(word, 40);
1220    }
1221    SubAndSuperscriptFix(word);
1222    if (!word->tess_failed && !word->word->flag(W_REP_CHAR)) {
1223      if (unicharset.top_bottom_useful() && unicharset.script_has_xheight() &&
1224          block->classify_rotation().y() == 0.0f) {
1225        TrainedXheightFix(word, block, row);
1226      }
1227    }
1228  #  ifndef GRAPHICS_DISABLED
1229    if (tessedit_display_outwords) {
1230      if (fx_win == nullptr) {
1231        create_fx_win();
1232      }
1233      clear_fx_win();
1234      word->rebuild_word->plot(fx_win);
1235      TBOX wbox = word->rebuild_word->bounding_box();
1236      fx_win->ZoomToRectangle(wbox.left(), wbox.top(), wbox.right(), wbox.bottom());
1237      ScrollView::Update();
1238    }
1239  #  endif
1240    check_debug_pt(word, 50);
1241  #endif 
1242  }
1243  #ifndef DISABLED_LEGACY_ENGINE
1244  void Tesseract::match_word_pass_n(int pass_n, WERD_RES *word, ROW *row, BLOCK *block) {
1245    if (word->tess_failed) {
1246      return;
1247    }
1248    tess_segment_pass_n(pass_n, word);
1249    if (!word->tess_failed) {
1250      if (!word->word->flag(W_REP_CHAR)) {
1251        word->fix_quotes();
1252        if (tessedit_fix_hyphens) {
1253          word->fix_hyphens();
1254        }
1255        if (static_cast<unsigned>(word->best_choice->length()) != word->box_word->length()) {
1256          tprintf(
1257              "POST FIX_QUOTES FAIL String:\"%s\"; Strlen=%d;"
1258              " #Blobs=%u\n",
1259              word->best_choice->debug_string().c_str(), word->best_choice->length(),
1260              word->box_word->length());
1261        }
1262        word->tess_accepted = tess_acceptable_word(word);
1263        make_reject_map(word, row, pass_n);
1264      }
1265    }
1266    set_word_fonts(word);
1267    ASSERT_HOST(word->raw_choice != nullptr);
1268  }
1269  #endif 
1270  static BLOB_CHOICE *FindBestMatchingChoice(UNICHAR_ID char_id, WERD_RES *word_res) {
1271    BLOB_CHOICE *best_choice = nullptr;
1272    for (unsigned i = 0; i < word_res->best_choice->length(); ++i) {
1273      BLOB_CHOICE *choice = FindMatchingChoice(char_id, word_res->GetBlobChoices(i));
1274      if (choice != nullptr) {
1275        if (best_choice == nullptr || choice->rating() < best_choice->rating()) {
1276          best_choice = choice;
1277        }
1278      }
1279    }
1280    return best_choice;
1281  }
1282  static void CorrectRepcharChoices(BLOB_CHOICE *blob_choice, WERD_RES *word_res) {
1283    WERD_CHOICE *word = word_res->best_choice;
1284    for (unsigned i = 0; i < word_res->best_choice->length(); ++i) {
1285      BLOB_CHOICE *choice =
1286          FindMatchingChoice(blob_choice->unichar_id(), word_res->GetBlobChoices(i));
1287      if (choice == nullptr) {
1288        BLOB_CHOICE_IT choice_it(word_res->GetBlobChoices(i));
1289        choice_it.add_before_stay_put(new BLOB_CHOICE(*blob_choice));
1290      }
1291    }
1292    for (unsigned i = 0; i < word->length(); ++i) {
1293      if (word->unichar_id(i) != blob_choice->unichar_id()) {
1294        word->set_unichar_id(blob_choice->unichar_id(), i);
1295      }
1296    }
1297  }
1298  void Tesseract::fix_rep_char(PAGE_RES_IT *page_res_it) {
1299    WERD_RES *word_res = page_res_it->word();
1300    const WERD_CHOICE &word = *(word_res->best_choice);
1301    SortHelper<UNICHAR_ID> rep_ch(word.length());
1302    for (unsigned i = 0; i < word.length(); ++i) {
1303      rep_ch.Add(word.unichar_id(i), 1);
1304    }
1305    UNICHAR_ID maxch_id = INVALID_UNICHAR_ID; 
1306    int max_count = rep_ch.MaxCount(&maxch_id);
1307    BLOB_CHOICE *best_choice = FindBestMatchingChoice(maxch_id, word_res);
1308    if (best_choice == nullptr) {
1309      tprintf("Failed to find a choice for %s, occurring %d times\n",
1310              word_res->uch_set->debug_str(maxch_id).c_str(), max_count);
1311      return;
1312    }
1313    word_res->done = true;
1314    CorrectRepcharChoices(best_choice, word_res);
1315    word_res->reject_map.initialise(word.length());
1316  }
1317  ACCEPTABLE_WERD_TYPE Tesseract::acceptable_word_string(const UNICHARSET &char_set, const char *s,
1318                                                         const char *lengths) {
1319    int i = 0;
1320    int offset = 0;
1321    int leading_punct_count;
1322    int upper_count = 0;
1323    int hyphen_pos = -1;
1324    ACCEPTABLE_WERD_TYPE word_type = AC_UNACCEPTABLE;
1325    if (strlen(lengths) > 20) {
1326      return word_type;
1327    }
1328    if (s[offset] != '\0' && chs_leading_punct.contains(s[offset])) {
1329      offset += lengths[i++];
1330    }
1331    leading_punct_count = i;
1332    while (s[offset] != '\0' && char_set.get_isupper(s + offset, lengths[i])) {
1333      offset += lengths[i++];
1334      upper_count++;
1335    }
1336    if (upper_count > 1) {
1337      word_type = AC_UPPER_CASE;
1338    } else {
1339      while (s[offset] != '\0' && char_set.get_islower(s + offset, lengths[i])) {
1340        offset += lengths[i++];
1341      }
1342      if (i - leading_punct_count < quality_min_initial_alphas_reqd) {
1343        goto not_a_word;
1344      }
1345      if (lengths[i] == 1 && s[offset] == '-') {
1346        hyphen_pos = i;
1347        offset += lengths[i++];
1348        if (s[offset] != '\0') {
1349          while ((s[offset] != '\0') && char_set.get_islower(s + offset, lengths[i])) {
1350            offset += lengths[i++];
1351          }
1352          if (i < hyphen_pos + 3) {
1353            goto not_a_word;
1354          }
1355        }
1356      } else {
1357        if (lengths[i] == 1 && (s[offset] == '\'') && lengths[i + 1] == 1 &&
1358            (s[offset + lengths[i]] == 's')) {
1359          offset += lengths[i++];
1360          offset += lengths[i++];
1361        }
1362      }
1363      if (upper_count > 0) {
1364        word_type = AC_INITIAL_CAP;
1365      } else {
1366        word_type = AC_LOWER_CASE;
1367      }
1368    }
1369    if (lengths[i] == 1 && s[offset] != '\0' && chs_trailing_punct1.contains(s[offset])) {
1370      offset += lengths[i++];
1371    }
1372    if (lengths[i] == 1 && s[offset] != '\0' && i > 0 && s[offset - lengths[i - 1]] != s[offset] &&
1373        chs_trailing_punct2.contains(s[offset])) {
1374      offset += lengths[i++];
1375    }
1376    if (s[offset] != '\0') {
1377      word_type = AC_UNACCEPTABLE;
1378    }
1379  not_a_word:
1380    if (word_type == AC_UNACCEPTABLE) {
1381      i = 0;
1382      offset = 0;
1383      if (s[0] != '\0' && char_set.get_isupper(s, lengths[0])) {
1384        word_type = AC_UC_ABBREV;
1385        while (s[offset] != '\0' && char_set.get_isupper(s + offset, lengths[i]) &&
1386               lengths[i + 1] == 1 && s[offset + lengths[i]] == '.') {
1387          offset += lengths[i++];
1388          offset += lengths[i++];
1389        }
1390      } else if (s[0] != '\0' && char_set.get_islower(s, lengths[0])) {
1391        word_type = AC_LC_ABBREV;
1392        while (s[offset] != '\0' && char_set.get_islower(s + offset, lengths[i]) &&
1393               lengths[i + 1] == 1 && s[offset + lengths[i]] == '.') {
1394          offset += lengths[i++];
1395          offset += lengths[i++];
1396        }
1397      }
1398      if (s[offset] != '\0') {
1399        word_type = AC_UNACCEPTABLE;
1400      }
1401    }
1402    return word_type;
1403  }
1404  bool Tesseract::check_debug_pt(WERD_RES *word, int location) {
1405    bool show_map_detail = false;
1406    int16_t i;
1407    if (!test_pt) {
1408      return false;
1409    }
1410    tessedit_rejection_debug.set_value(false);
1411    debug_x_ht_level.set_value(0);
1412    if (word->word->bounding_box().contains(FCOORD(test_pt_x, test_pt_y))) {
1413      if (location < 0) {
1414        return true; 
1415      }
1416      tessedit_rejection_debug.set_value(true);
1417      debug_x_ht_level.set_value(2);
1418      tprintf("\n\nTESTWD::");
1419      switch (location) {
1420        case 0:
1421          tprintf("classify_word_pass1 start\n");
1422          word->word->print();
1423          break;
1424        case 10:
1425          tprintf("make_reject_map: initial map");
1426          break;
1427        case 20:
1428          tprintf("make_reject_map: after NN");
1429          break;
1430        case 30:
1431          tprintf("classify_word_pass2 - START");
1432          break;
1433        case 40:
1434          tprintf("classify_word_pass2 - Pre Xht");
1435          break;
1436        case 50:
1437          tprintf("classify_word_pass2 - END");
1438          show_map_detail = true;
1439          break;
1440        case 60:
1441          tprintf("fixspace");
1442          break;
1443        case 70:
1444          tprintf("MM pass START");
1445          break;
1446        case 80:
1447          tprintf("MM pass END");
1448          break;
1449        case 90:
1450          tprintf("After Poor quality rejection");
1451          break;
1452        case 100:
1453          tprintf("unrej_good_quality_words - START");
1454          break;
1455        case 110:
1456          tprintf("unrej_good_quality_words - END");
1457          break;
1458        case 120:
1459          tprintf("Write results pass");
1460          show_map_detail = true;
1461          break;
1462      }
1463      if (word->best_choice != nullptr) {
1464        tprintf(" \"%s\" ", word->best_choice->unichar_string().c_str());
1465        word->reject_map.print(debug_fp);
1466        tprintf("\n");
1467        if (show_map_detail) {
1468          tprintf("\"%s\"\n", word->best_choice->unichar_string().c_str());
1469          for (i = 0; word->best_choice->unichar_string()[i] != '\0'; i++) {
1470            tprintf("**** \"%c\" ****\n", word->best_choice->unichar_string()[i]);
1471            word->reject_map[i].full_print(debug_fp);
1472          }
1473        }
1474      } else {
1475        tprintf("null best choice\n");
1476      }
1477      tprintf("Tess Accepted: %s\n", word->tess_accepted ? "TRUE" : "FALSE");
1478      tprintf("Done flag: %s\n\n", word->done ? "TRUE" : "FALSE");
1479      return true;
1480    } else {
1481      return false;
1482    }
1483  }
1484  #ifndef DISABLED_LEGACY_ENGINE
1485  static void find_modal_font( 
1486      STATS *fonts,            
1487      int16_t *font_out,       
1488      int8_t *font_count       
1489  ) {
1490    int16_t font;  
1491    int32_t count; 
1492    if (fonts->get_total() > 0) {
1493      font = static_cast<int16_t>(fonts->mode());
1494      *font_out = font;
1495      count = fonts->pile_count(font);
1496      *font_count = count < INT8_MAX ? count : INT8_MAX;
1497      fonts->add(font, -*font_count);
1498    } else {
1499      *font_out = -1;
1500      *font_count = 0;
1501    }
1502  }
1503  #endif 
1504  void Tesseract::set_word_fonts(WERD_RES *word) {
1505    if (word->chopped_word == nullptr) {
1506      return;
1507    }
1508    ASSERT_HOST(word->best_choice != nullptr);
1509  #ifndef DISABLED_LEGACY_ENGINE
1510    const int fontinfo_size = fontinfo_table_.size();
1511    if (fontinfo_size == 0) {
1512      return;
1513    }
1514    if (tessedit_font_id > 0) {
1515      if (tessedit_font_id >= fontinfo_size) {
1516        tprintf("Error, invalid font ID provided: must be below %d.\n"
1517                "Falling back to font auto-detection.\n", fontinfo_size);
1518      } else {
1519        word->fontinfo = &fontinfo_table_.at(tessedit_font_id);
1520        word->fontinfo2 = nullptr;
1521        word->fontinfo_id_count = INT8_MAX;
1522        word->fontinfo_id2_count = 0;
1523        return;
1524      }
1525    }
1526    std::vector<int> font_total_score(fontinfo_size);
1527    if (tessedit_debug_fonts) {
1528      tprintf("Examining fonts in %s\n", word->best_choice->debug_string().c_str());
1529    }
1530    for (unsigned b = 0; b < word->best_choice->length(); ++b) {
1531      const BLOB_CHOICE *choice = word->GetBlobChoice(b);
1532      if (choice == nullptr) {
1533        continue;
1534      }
1535      auto &fonts = choice->fonts();
1536      for (auto &f : fonts) {
1537        const int fontinfo_id = f.fontinfo_id;
1538        if (0 <= fontinfo_id && fontinfo_id < fontinfo_size) {
1539          font_total_score[fontinfo_id] += f.score;
1540        }
1541      }
1542    }
1543    int score1 = 0, score2 = 0;
1544    int16_t font_id1 = -1, font_id2 = -1;
1545    for (int f = 0; f < fontinfo_size; ++f) {
1546      if (tessedit_debug_fonts && font_total_score[f] > 0) {
1547        tprintf("Font %s, total score = %d\n", fontinfo_table_.at(f).name, font_total_score[f]);
1548      }
1549      if (font_total_score[f] > score1) {
1550        score2 = score1;
1551        font_id2 = font_id1;
1552        score1 = font_total_score[f];
1553        font_id1 = f;
1554      } else if (font_total_score[f] > score2) {
1555        score2 = font_total_score[f];
1556        font_id2 = f;
1557      }
1558    }
1559    word->fontinfo = font_id1 >= 0 ? &fontinfo_table_.at(font_id1) : nullptr;
1560    word->fontinfo2 = font_id2 >= 0 ? &fontinfo_table_.at(font_id2) : nullptr;
1561    word->fontinfo_id_count = ClipToRange<int>(score1 / UINT16_MAX, 1, INT8_MAX);
1562    word->fontinfo_id2_count = ClipToRange<int>(score2 / UINT16_MAX, 0, INT8_MAX);
1563    if (score1 > 0) {
1564      const FontInfo fi = fontinfo_table_.at(font_id1);
1565      if (tessedit_debug_fonts) {
1566        if (word->fontinfo_id2_count > 0 && font_id2 >= 0) {
1567          tprintf("Word modal font=%s, score=%d, 2nd choice %s/%d\n", fi.name,
1568                  word->fontinfo_id_count, fontinfo_table_.at(font_id2).name,
1569                  word->fontinfo_id2_count);
1570        } else {
1571          tprintf("Word modal font=%s, score=%d. No 2nd choice\n", fi.name, word->fontinfo_id_count);
1572        }
1573      }
1574    }
1575  #endif 
1576  }
1577  #ifndef DISABLED_LEGACY_ENGINE
1578  void Tesseract::font_recognition_pass(PAGE_RES *page_res) {
1579    PAGE_RES_IT page_res_it(page_res);
1580    WERD_RES *word;                       
1581    STATS doc_fonts(0, font_table_size_ - 1); 
1582    for (page_res_it.restart_page(); page_res_it.word() != nullptr; page_res_it.forward()) {
1583      word = page_res_it.word();
1584      if (word->fontinfo != nullptr) {
1585        doc_fonts.add(word->fontinfo->universal_id, word->fontinfo_id_count);
1586      }
1587      if (word->fontinfo2 != nullptr) {
1588        doc_fonts.add(word->fontinfo2->universal_id, word->fontinfo_id2_count);
1589      }
1590    }
1591    int16_t doc_font;      
1592    int8_t doc_font_count; 
1593    find_modal_font(&doc_fonts, &doc_font, &doc_font_count);
1594    if (doc_font_count == 0) {
1595      return;
1596    }
1597    const FontInfo *modal_font = nullptr;
1598    for (page_res_it.restart_page(); page_res_it.word() != nullptr; page_res_it.forward()) {
1599      word = page_res_it.word();
1600      if (word->fontinfo != nullptr && word->fontinfo->universal_id == doc_font) {
1601        modal_font = word->fontinfo;
1602        break;
1603      }
1604      if (word->fontinfo2 != nullptr && word->fontinfo2->universal_id == doc_font) {
1605        modal_font = word->fontinfo2;
1606        break;
1607      }
1608    }
1609    ASSERT_HOST(modal_font != nullptr);
1610    for (page_res_it.restart_page(); page_res_it.word() != nullptr; page_res_it.forward()) {
1611      word = page_res_it.word();
1612      const int length = word->best_choice->length();
1613      const int count = word->fontinfo_id_count;
1614      if (!(count == length || (length > 3 && count >= length * 3 / 4))) {
1615        word->fontinfo = modal_font;
1616        word->fontinfo_id_count = 1;
1617      }
1618    }
1619  }
1620  #endif 
1621  void Tesseract::dictionary_correction_pass(PAGE_RES *page_res) {
1622    PAGE_RES_IT word_it(page_res);
1623    for (WERD_RES *word = word_it.word(); word != nullptr; word = word_it.forward()) {
1624      if (word->best_choices.singleton()) {
1625        continue; 
1626      }
1627      const WERD_CHOICE *best = word->best_choice;
1628      if (word->tesseract->getDict().valid_word(*best) != 0) {
1629        continue; 
1630      }
1631      WERD_CHOICE_IT choice_it(&word->best_choices);
1632      for (choice_it.mark_cycle_pt(); !choice_it.cycled_list(); choice_it.forward()) {
1633        WERD_CHOICE *alternate = choice_it.data();
1634        if (word->tesseract->getDict().valid_word(*alternate)) {
1635          if (tessedit_bigram_debug) {
1636            tprintf("Dictionary correction replaces best choice '%s' with '%s'\n",
1637                    best->unichar_string().c_str(), alternate->unichar_string().c_str());
1638          }
1639          word->ReplaceBestChoice(alternate);
1640          break;
1641        }
1642      }
1643    }
1644  }
1645  } 
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-btalarms.cpp</h3>
            <pre><code>1  #include "btalarms.h"
2  PBtaDevDefBs TBtaDevDefBs::LoadTxt(const TStr& FNm){
3    PBtaDevDefBs DevDefBs=TBtaDevDefBs::New();
4    printf("Loading Device Definitions from '%s' ...\n", FNm.CStr());
5    PSIn SIn=TFIn::New(FNm);
6    char SsCh=' '; TStrV FldNmV;
7    TSs::LoadTxtFldV(ssfTabSep, SIn, SsCh, FldNmV, false, false);
8    int IpNum_FldN=FldNmV.SearchForw("IP");
9    int Node_FldN=FldNmV.SearchForw("Node");
10    int Zone_FldN=FldNmV.SearchForw("Zone");
11    int Loc_FldN=FldNmV.SearchForw("Location");
12    int Proj_FldN=FldNmV.SearchForw("Project");
13    int Type_FldN=FldNmV.SearchForw("Type");
14    TStrV FldValV; int Recs=0;
15    while (!SIn->Eof()){
16      Recs++; printf("  %d\r", Recs);
17      TSs::LoadTxtFldV(ssfTabSep, SIn, SsCh, FldValV, false, false);
18      IAssert(FldNmV.Len()==FldValV.Len());
19      TStr IpNumNm=FldValV[IpNum_FldN].GetTrunc();
20      TStr NodeNm=FldValV[Node_FldN].GetTrunc();
21      TStr ZoneNm=FldValV[Zone_FldN].GetTrunc();
22      TStr LocNm=FldValV[Loc_FldN].GetTrunc();
23      TStr ProjNm=FldValV[Proj_FldN].GetTrunc();
24      TStr TypeNm=FldValV[Type_FldN].GetTrunc();
25      int IpNumId=-1; int NodeId=-1; int ZoneId=-1;
26      int LocId=-1; int ProjId=-1; int TypeId=-1;
27      if (!IpNumNm.Empty()){IpNumId=DevDefBs->AddIpNumNm(IpNumNm);}
28      if (!NodeNm.Empty()){NodeId=DevDefBs->AddNodeNm(NodeNm);}
29      if (!ZoneNm.Empty()){ZoneId=DevDefBs->AddZoneNm(ZoneNm);}
30      if (!LocNm.Empty()){LocId=DevDefBs->AddLocNm(LocNm);}
31      if (!ProjNm.Empty()){ProjId=DevDefBs->AddProjNm(ProjNm);}
32      if (!TypeNm.Empty()){TypeId=DevDefBs->AddTypeNm(TypeNm);}
33      PBtaDevDef DevDef=
34       TBtaDevDef::New(IpNumId, NodeId, ZoneId, LocId, ProjId, TypeId);
35      if (!DevDefBs->IsDevDef(DevDef)){
36        DevDefBs->AddDevDef(DevDef);
37      } else {
38        printf("  Duplicate [%s]\n", IpNumNm.CStr());
39      }
40    }
41    printf("\nDone.\n");
42    return DevDefBs;
43  }
44  TStr TBtaEventDat::GetNodeId() const {
45      return IsFld("NODE") ? GetFld("NODE") : "&nbsp;";
46  }
47  TStr TBtaEventDat::GetComponentId() const {
48      return IsFld("COMPONENTID") ? GetFld("COMPONENTID") : "&nbsp;";
49  }
50  TStr TBtaEventDat::GetFirstTm() const {
51      return IsFld("FIRSTOCCURRENCE") ? GetFld("FIRSTOCCURRENCE") : "&nbsp;";
52  }
53  TStr TBtaEventDat::GetLastTm() const {
54      return IsFld("LASTOCCURRENCE") ? GetFld("LASTOCCURRENCE") : "&nbsp;";
55  }
56  TStr TBtaEventDat::GetSeverity() const {
57      return IsFld("SEVERITY") ? GetFld("SEVERITY") : "&nbsp;";
58  }
59  TStr TBtaEventDat::GetSummary() const {
60      return IsFld("SUMMARY") ? GetFld("SUMMARY") : "&nbsp;";
61  }
62  TStr TBtaEventDat::GetIR() const {
63      return IsFld("IR") ? GetFld("IR") : "&nbsp;";
64  }
65  TBtaEvent::TBtaEvent() {}
66  TBtaEvent::TBtaEvent(const int& _IpNumId, const int& _ProjId, const int& _Severity,
67      const uint64& _FirstTmMSecs, const uint64& _LastTmMSecs, const int& _CaseId, 
68      const int& _BtaEventDatPt): 
69          IpNumId(_IpNumId), ProjId(_ProjId), Severity(_Severity), FirstTmMSecs(_FirstTmMSecs), 
70          LastTmMSecs(_LastTmMSecs), CaseId(_CaseId), BtaEventDatPt(_BtaEventDatPt) { }
71  TBtaEvent::TBtaEvent(TSIn& SIn): 
72      IpNumId(SIn), 
73      ProjId(SIn), 
74      Severity(SIn), 
75      FirstTmMSecs(SIn), 
76      LastTmMSecs(SIn), 
77      CaseId(SIn), 
78      BtaEventDatPt(SIn) { }
79  void TBtaEvent::Save(TSOut& SOut) const { 
80    IpNumId.Save(SOut); 
81    ProjId.Save(SOut); 
82    Severity.Save(SOut);
83    FirstTmMSecs.Save(SOut); 
84    LastTmMSecs.Save(SOut); 
85    CaseId.Save(SOut); 
86    BtaEventDatPt.Save(SOut); 
87  }
88  void TBtaEventBs::LoadValidColumnH() {
89      ValidColumnH.AddKey("IDENTIFIER");
90      ValidColumnH.AddKey("SERIAL");
91      ValidColumnH.AddKey("NODEALIAS");
92      ValidColumnH.AddKey("ALERTKEY");
93      ValidColumnH.AddKey("SEVERITY");
94      ValidColumnH.AddKey("SUMMARY");
95      ValidColumnH.AddKey("FIRSTOCCURRENCE");
96      ValidColumnH.AddKey("LASTOCCURRENCE");
97      ValidColumnH.AddKey("TALLY");
98      ValidColumnH.AddKey("PROJECT");
99      ValidColumnH.AddKey("CLASS");
100      ValidColumnH.AddKey("IP");
101      ValidColumnH.AddKey("SERVERSERIAL");
102      ValidColumnH.AddKey("IR");
103      ValidColumnH.AddKey("NODE");
104      ValidColumnH.AddKey("ALERTGROUP");
105      ValidColumnH.AddKey("MANAGER");
106      ValidColumnH.AddKey("AGENT");
107      ValidColumnH.AddKey("SUPPRESS");
108      ValidColumnH.AddKey("BUSINESSCRITICALITY");
109      ValidColumnH.AddKey("COMPONENTID");
110      ValidColumnH.AddKey("ALERTITEM");
111      ValidColumnH.AddKey("STATECHANGE");
112      ValidColumnH.AddKey("LOCATION");
113      ValidColumnH.AddKey("OWNERUID");
114      ValidColumnH.AddKey("ACKNOWLEDGED");
115      ValidColumnH.AddKey("ZONE");
116      ValidColumnH.AddKey("SERVERNAME");
117      ValidColumnH.AddKey("HELP");
118  }
119  void TBtaEventBs::LoadLastEventId() {
120      LastEventId = -1;
121      {TStr CountDumpSqlStr = "select count(id) from dump_buffer;";
122      if (!Query->ExeSql(CountDumpSqlStr)) { TExcept::Throw(Query->GetMsgStr()); }
123      POdbcTb CountDumpTb = TOdbcTb::New(Query);
124      EAssert(CountDumpTb->GetCols() == 1 && CountDumpTb->GetRows() == 1);
125      const int CountDump = CountDumpTb->GetRowVal(0, 0).GetInt();
126      if (CountDump > 0) { 
127          TStr MaxIdDumpSqlStr = "select max(id) from dump_buffer;";
128          if (!Query->ExeSql(MaxIdDumpSqlStr)) { TExcept::Throw(Query->GetMsgStr()); }
129          POdbcTb MaxIdDumpTb = TOdbcTb::New(Query);
130          EAssert(CountDumpTb->GetCols() == 1 && CountDumpTb->GetRows() == 1);
131          const int MaxIdDump = MaxIdDumpTb->GetRowVal(0, 0).GetInt();
132          LastEventId = TInt::GetMx(LastEventId, MaxIdDump);
133      }}
134      {TStr CountAlarmsSqlStr = "select count(id) from alarms;";
135      if (!Query->ExeSql(CountAlarmsSqlStr)) { TExcept::Throw(Query->GetMsgStr()); }
136      POdbcTb CountAlarmsTb = TOdbcTb::New(Query);
137      EAssert(CountAlarmsTb->GetCols() == 1 && CountAlarmsTb->GetRows() == 1);
138      const int CountAlarms = CountAlarmsTb->GetRowVal(0, 0).GetInt();
139      if (CountAlarms > 0) { 
140          TStr MaxIdAlarmsSqlStr = "select max(id) from alarms;";
141          if (!Query->ExeSql(MaxIdAlarmsSqlStr)) { TExcept::Throw(Query->GetMsgStr()); }
142          POdbcTb MaxIdAlarmsTb = TOdbcTb::New(Query);
143          EAssert(MaxIdAlarmsTb->GetCols() == 1 && MaxIdAlarmsTb->GetRows() == 1);
144          const int MaxIdAlarms = MaxIdAlarmsTb->GetRowVal(0, 0).GetInt();
145          LastEventId = TInt::GetMx(LastEventId, MaxIdAlarms);
146      }}
147      printf("LastEventId = %d\n", LastEventId.Val);
148  }
149  void TBtaEventBs::ParseBtaEventDat(const TBtaEventDat& EventDat, 
150          const int& BtaEventDatPt, TBtaEvent& Event) {
151      const TStrStrH FldNmValH = EventDat.GetFldNmToValH();
152      TStr IpNumNm = FldNmValH.IsKey("IP") ? FldNmValH.GetDat("IP") : "";
153      TStr FirstOccTmStr = FldNmValH.IsKey("FIRSTOCCURRENCE") ? FldNmValH.GetDat("FIRSTOCCURRENCE") : "";
154      TStr LastOccTmStr = FldNmValH.IsKey("LASTOCCURRENCE") ? FldNmValH.GetDat("LASTOCCURRENCE") : "";
155      TStr ProjNm = FldNmValH.IsKey("PROJECT") ? FldNmValH.GetDat("PROJECT") : "";
156      TStr SeverityStr = FldNmValH.IsKey("SEVERITY") ? FldNmValH.GetDat("SEVERITY") : "";
157      TStr CaseNm = FldNmValH.IsKey("IR") ? FldNmValH.GetDat("IR") : "";
158      uint64 FirstOccTmMSecs = 0;
159      try {
160          TTm FirstOccTm = TTm::GetTmFromWebLogDateTimeStr(FirstOccTmStr);
161          EAssert(FirstOccTm.IsDef());
162          FirstOccTmMSecs = TTm::GetMSecsFromTm(FirstOccTm);
163      } catch (...) { }
164      uint64 LastOccTmMSecs = 0;
165      try {
166          TTm LastOccTm = TTm::GetTmFromWebLogDateTimeStr(LastOccTmStr);
167          EAssert(LastOccTm.IsDef());
168          LastOccTmMSecs = TTm::GetMSecsFromTm(LastOccTm);
169      } catch (...) { }
170      const int IpNumId = DevDefBs->IsIpNumId(IpNumNm) ? DevDefBs->GetIpNumId(IpNumNm) : -1;
171      const int ProjId = DevDefBs->IsProjId(ProjNm) ? DevDefBs->GetProjId(ProjNm) : -1;
172      const int Severity = SeverityStr.IsInt() ? SeverityStr.GetInt() : -1;
173      const int CaseId = CaseNm.Empty() ? -1 : AddCase(CaseNm);
174      Event = TBtaEvent(IpNumId, ProjId, Severity,
175          FirstOccTmMSecs, LastOccTmMSecs, CaseId, BtaEventDatPt);
176  }
177  int TBtaEventBs::StoreEventDat(const TBtaEventDat& EventDat, const TStr& TableNm) {
178      const int EventId = GetNextEventId();
179      TChA ColumnNmChA, ColumnValChA;
180      const TStrStrH& FldNmToValH = EventDat.GetFldNmToValH();
181      int KeyId = FldNmToValH.FFirstKeyId();
182      while (FldNmToValH.FNextKeyId(KeyId)) {
183          const TStr& FldNm = FldNmToValH.GetKey(KeyId);
184          const TStr& FldVal = FldNmToValH[KeyId];
185          if (IsValidColumn(FldNm)) { 
186              if (!ColumnNmChA.Empty()) { 
187                  ColumnNmChA += ", "; 
188                  ColumnValChA += ", ";
189              }
190              ColumnNmChA += FldNm;
191              ColumnValChA += '"'; 
192              ColumnValChA += TOdbcQuery::GetSqlStr(FldVal); 
193              ColumnValChA += '"'; 
194          }
195      }
196      TStr InsertSqlStr = TStr::Fmt("INSERT INTO %s (Id, %s) VALUES (%d, %s);",
197          TableNm.CStr(), ColumnNmChA.CStr(), EventId, ColumnValChA.CStr());
198      if (!Query->ExeSql(InsertSqlStr)) { TExcept::Throw(Query->GetMsgStr()); }
199      return EventId;
200  }
201  bool TBtaEventBs::GetEventDat(const int& EventDatPt, 
202          const TStr& TableNm, TBtaEventDat& EventDat) const {
203      TStr SelectSqlStr = TStr::Fmt(
204          "SELECT * FROM %s WHERE id=%d LIMIT 1;", TableNm.CStr(), EventDatPt);
205      if (!Query->ExeSql(SelectSqlStr)) { TExcept::Throw(Query->GetMsgStr()); }
206      POdbcTb Table = TOdbcTb::New(Query);
207      EAssertR(Table->IsOk(), Table->GetMsgStr());
208      EventDat.Clr();
209      if (Table->GetRows() > 0) {
210          for (int ColN = 0; ColN < Table->GetCols(); ColN++) {
211              TStr ColNm = Table->GetColNm(ColN).GetUc();
212              TStr RowVal = Table->GetRowVal(0, ColN);
213              if (!RowVal.Empty()) { EventDat.AddFld(ColNm, RowVal); }
214          }
215      }
216      return (Table->GetRows() > 0);
217  }
218  int TBtaEventBs::AddCase(const TStr& CaseNm) {
219      const int CaseId = CaseNmFqH.AddKey(CaseNm);
220      CaseNmFqH[CaseId]++;
221      return CaseId;
222  }
223  TBtaEventBs::TBtaEventBs(const PBtaDevDefBs& _DevDefBs, 
224          const POdbcDb& _OdbcDb, const int& ExpEvents) { 
225      DevDefBs = _DevDefBs; 
226      if (ExpEvents > 0) { EventV.Gen(ExpEvents, 0); }
227      OdbcDb = _OdbcDb; Query = TOdbcQuery::New(OdbcDb);
228      LoadValidColumnH(); LoadLastEventId();
229  }
230  TBtaEventBs::TBtaEventBs(TSIn& SIn, const POdbcDb& _OdbcDb) {
231      printf("Loading events ... ");
232      DevDefBs = PBtaDevDefBs(SIn); printf("(1)"); 
233      EventV.Load(SIn); printf("(2)");
234      CaseNmFqH.Load(SIn); printf("(3)\n");
235      OdbcDb = _OdbcDb; Query = TOdbcQuery::New(OdbcDb);
236      LoadValidColumnH(); LoadLastEventId();
237  }
238  void TBtaEventBs::Save(TSOut& SOut) const {
239      DevDefBs.Save(SOut); 
240      EventV.Save(SOut); 
241      CaseNmFqH.Save(SOut);
242  }
243  void TBtaEventBs::GetEventDat(const int& EventDatPt, TBtaEventDat& EventDat) const {
244      const bool DumpBufferP = GetEventDat(EventDatPt, "dump_buffer", EventDat);
245      if (!DumpBufferP) { GetEventDat(EventDatPt, "alarms", EventDat); }    
246  }
247  int TBtaEventBs::GetNextEvent(const int& StartEventN, const int& IpNumId) {
248      int EventN = StartEventN; const int Events = EventV.Len();
249      while (EventN < Events) {
250          if (EventV[EventN].GetIpNumId() == IpNumId) { return EventN; }
251          EventN++;
252      }
253      return -1;
254  }
255  void TBtaEventBs::GetMostActiveProjs(const int64& TimeWnd, 
256          const int& EventWnd, const int& MnSeverity, TIntKdV& ProjIdFqV) {
257      TIntH ProjEventsH;
258      const int64 NowTmMSec = GetLastEvent().GetFirstTmMSecs();
259      const int Events = GetEvents(); int ProcEventN = 0;
260      for (int EventN = Events - 1; EventN >= 0; EventN--) {
261          const TBtaEvent& Event = GetEvent(EventN);
262          const int IpNumId = Event.GetIpNumId();
263          const int ProjId = Event.GetProjId();
264          const int64 EventTmMSec = Event.GetFirstTmMSecs();
265          if (EventTmMSec < NowTmMSec) { 
266              const int64 TmMSecDiff = NowTmMSec - EventTmMSec;
267              if (TmMSecDiff > TimeWnd) { break; }
268          }
269          if (IpNumId == -1 || ProjId == -1) { continue; }
270          if (Event.GetSeverity() < MnSeverity) { continue; }
271          if (ProcEventN > EventWnd) { break; }
272          ProjEventsH.AddDat(ProjId)++;
273          ProcEventN++;
274      }
275      ProjEventsH.SortByDat(false); ProjIdFqV.Clr();
276      int KeyId = ProjEventsH.FFirstKeyId();
277      while (ProjEventsH.FNextKeyId(KeyId)) {
278          const int ProjId = ProjEventsH.GetKey(KeyId);
279          const int Events = ProjEventsH[KeyId];
280          ProjIdFqV.Add(TIntKd(ProjId, Events));
281      }
282  }
283  int TBtaEventBs::AddBtEvent(const TBtaEventDat& EventDat, const bool& BatchP) {
284      const int BtaEventDatPt = StoreEventDat(EventDat, BatchP ? "alarms" : "dump_buffer");
285      TBtaEvent Event; ParseBtaEventDat(EventDat, BtaEventDatPt, Event);
286      return AddEvent(Event);
287  }
288  void TBtaEventBs::AddNewBuffer(TIntV& EventIdV) {
289      EventIdV.Clr();
290      forever {
291          TStr SelectSqlStr = TStr::Fmt("SELECT * FROM new_buffer LIMIT 100;");
292          if (!Query->ExeSql(SelectSqlStr)) { TExcept::Throw(Query->GetMsgStr()); }
293          POdbcTb Table = TOdbcTb::New(Query);
294          EAssertR(Table->IsOk(), Table->GetMsgStr());
295          const int Rows = Table->GetRows();
296          const int Cols = Table->GetCols();
297          if (Rows == 0) { break; }
298          for (int RowN = 0; RowN < Rows; RowN++) {
299              TStr BufferId;
300              TBtaEventDat EventDat;       
301              for (int ColN = 0; ColN < Table->GetCols(); ColN++) {
302                  TStr ColNm = Table->GetColNm(ColN).GetUc();
303                  TStr RowVal = Table->GetRowVal(RowN, ColN);
304                  if (ColNm == "ID") { BufferId = RowVal; } 
305                  else if (!RowVal.Empty()) { EventDat.AddFld(ColNm, RowVal); }
306              }
307              EventIdV.Add(AddBtEvent(EventDat, false));
308              TStr DeleteSqlStr = "DELETE FROM new_buffer WHERE id=" + BufferId + ";";
309              if (!Query->ExeSql(DeleteSqlStr)) { TExcept::Throw(Query->GetMsgStr()); }
310          }
311      }
312  }
313  void TBtaEventBs::SaveDumpBuffer() {
314      TStr InsertSqlStr = "INSERT INTO alarms SELECT * FROM dump_buffer;";
315      if (!Query->ExeSql(InsertSqlStr)) { TExcept::Throw(Query->GetMsgStr()); }
316      TStr TruncateSqlStr = "TRUNCATE TABLE dump_buffer;";
317      if (!Query->ExeSql(TruncateSqlStr)) { TExcept::Throw(Query->GetMsgStr()); }
318  }
319  void TBtaEventBs::RescueDumpBuffer(TIntV& EventIdV) {
320      TStr SqlStr = "SELECT * FROM dump_buffer;";
321      if (!Query->ExeSql(SqlStr)) { TExcept::Throw(Query->GetMsgStr()); }
322      POdbcTb Table = TOdbcTb::New(Query);
323      EAssertR(Table->IsOk(), Table->GetMsgStr());
324      const int Rows = Table->GetRows();
325      const int Cols = Table->GetCols();
326      printf("Found %d non-archived alarms from previous run.\n", Rows);
327      EventIdV.Clr();
328      for (int RowN = 0; RowN < Rows; RowN++) {
329          TStr EventDatIdStr;
330          TBtaEventDat EventDat;       
331          for (int ColN = 0; ColN < Table->GetCols(); ColN++) {
332              TStr ColNm = Table->GetColNm(ColN).GetUc();
333              TStr RowVal = Table->GetRowVal(RowN, ColN);
334              if (ColNm == "ID") { EventDatIdStr = RowVal; } 
335              else if (!RowVal.Empty()) { EventDat.AddFld(ColNm, RowVal); }
336          }
337          EAssertR(EventDatIdStr.IsInt(), EventDatIdStr);
338          TBtaEvent Event; 
339          ParseBtaEventDat(EventDat, EventDatIdStr.GetInt(), Event);
340          EventIdV.Add(AddEvent(Event));
341      }
342  }
343  PBtaEventBs TBtaEventBs::LoadBtTxt(const PBtaDevDefBs& DevDefBs, const TStr& TxtFNm, 
344          const POdbcDb& OdbcDb, const int& ExpEvents, const int& Offset) { 
345      printf("Loading BTAlarms-Data from '%s'...\n", TxtFNm.CStr());
346      PBtaEventBs EventBs = TBtaEventBs::New(DevDefBs, OdbcDb, ExpEvents);
347      PSIn SIn = TFIn::New(TxtFNm); char SsCh=' ';
348      TStrV FldNmV; TSs::LoadTxtFldV(ssfTabSep, SIn, SsCh, FldNmV, false, false);
349      TStrV FldValV; int Recs = 0;
350      while (!SIn->Eof() && (EventBs->GetEvents() != ExpEvents)){
351          Recs++; if (Recs%1000 == 0){printf("  %d / %d\r", EventBs->GetEvents(), Recs);}
352          TSs::LoadTxtFldV(ssfTabSep, SIn, SsCh, FldValV, false, false);
353          IAssert(FldNmV.Len() == FldValV.Len());
354          if (Offset > Recs) { continue; }
355          TBtaEventDat EventDat;
356          for (int FldN = 0; FldN < FldValV.Len(); FldN++) {
357              if (!FldValV[FldN].Empty()) { 
358                  EventDat.AddFld(FldNmV[FldN], FldValV[FldN]); }
359          }
360          EventBs->AddBtEvent(EventDat, true);
361      }
362      printf("  %d / %d \nDone.\n", EventBs->GetEvents(), Recs);
363      return EventBs;
364  }
365  PBtaEventBs TBtaEventBs::LoadBankTxt(const PBtaDevDefBs& DevDefBs, 
366          const TStr& InFPath, const POdbcDb& OdbcDb, const int& ExpEvents) {
367      const int ProjId = DevDefBs->AddProjNm("default");
368      PBtaEventBs EventBs = TBtaEventBs::New(DevDefBs, OdbcDb, ExpEvents);
369      TFFile FFile(InFPath, "", false); 
370      TStr InFNm; int FileCount = 1;
371      while (FFile.Next(InFNm)) {
372          printf("(%d) Loading %s ...\n", FileCount, InFNm.CStr()); FileCount++;
373          TFIn FIn(InFNm); int Events = 0;
374          TStr LnStr, Rest1, Rest2;
375          while (FIn.GetNextLn(LnStr)) {
376              if (LnStr.IsWs()) { continue; }
377              if (Events % 1000 == 0) { printf("%d\r", Events); }
378              LnStr.ChangeStr("  ", " ");
379              TStr MonthStr; LnStr.SplitOnCh(MonthStr, ' ', Rest1);
380              TStr DayStr; Rest1.SplitOnCh(DayStr, ' ', Rest2);
381              TStr TimeStr; Rest2.SplitOnCh(TimeStr, ' ', Rest1);
382              TStr DeviceNm; Rest1.SplitOnCh(DeviceNm, ' ', Rest2);
383              TStr EventTxt = Rest2;
384              const int Year = 2007;
385              const int Month = TTmInfo::GetMonthN(MonthStr);
386              if (Month == -1) { printf("MonthStr: %s\n", MonthStr.CStr()); continue; }
387              if (!DayStr.IsInt()) { printf("DayStr: %s\n", DayStr.CStr()); continue; }
388              const int Day = DayStr.GetInt();
389              if (Day < 0 || Day > 31) { printf("Day: %d\n", Day); continue; }
390              TStrV TimePartV; TimeStr.SplitOnAllCh(':', TimePartV);
391              if (TimePartV.Len() != 3) { printf("TimePartV.Len: %d\n", TimePartV.Len()); continue; };
392              if (!TimePartV[0].IsInt()) { printf("TimePartV[0]: %s\n", TimePartV[0].CStr()); continue; }
393              if (!TimePartV[1].IsInt()) { printf("TimePartV[1]: %s\n", TimePartV[1].CStr()); continue; }
394              if (!TimePartV[2].IsInt()) { printf("TimePartV[2]: %s\n", TimePartV[2].CStr()); continue; }
395              const int Hour = TimePartV[0].GetInt();
396              const int Minute = TimePartV[1].GetInt();
397              const int Second = TimePartV[2].GetInt();
398              if (Hour < 0 || Hour > 23) { printf("Hour: %d\n", Hour); continue; }
399              if (Minute < 0 || Minute > 59) { printf("Minute: %d\n", Minute); continue; }
400              if (Second < 0 || Second > 59) { printf("Second: %d\n", Second); continue; }
401              TTm EventTime(Year, Month, Day, -1, Hour, Minute, Second);
402              if (!DevDefBs->IsIpNumId(DeviceNm)) { DevDefBs->AddIpNumNm(DeviceNm); }
403              const int IpNumId = DevDefBs->GetIpNumId(DeviceNm);
404              const int Severity = 3;
405              TBtaEventDat EventDat; 
406              EventDat.AddFld("FIRSTOCCURRENCE", EventTime.GetWebLogDateTimeStr());
407              EventDat.AddFld("LASTOCCURRENCE", EventTime.GetWebLogDateTimeStr());
408              EventDat.AddFld("SEVERITY", TInt(Severity).GetStr());
409              EventDat.AddFld("SUMMARY", EventTxt);
410              const int BtaEventDatPt = EventBs->StoreEventDat(EventDat, "alarms");
411              TBtaEvent Event(IpNumId, ProjId, Severity, TTm::GetMSecsFromTm(EventTime), 
412                  TTm::GetMSecsFromTm(EventTime), -1, BtaEventDatPt);
413              EventBs->AddEvent(Event); Events++;
414          }
415          printf("%d\n", Events);
416      }
417      printf("All Events: %d\n", EventBs->GetEvents());
418      return EventBs;
419  }
420  int TBtaCorrBs::SumFqV(const TIntH& IdFqH) const {
421      int Sum = 0, KeyId = IdFqH.FFirstKeyId();
422      while (IdFqH.FNextKeyId(KeyId)) { Sum += IdFqH[KeyId]; }
423      return Sum;
424  }
425  int TBtaCorrBs::CountEvents(const TIntV& EventV, const int& MxEventId) const {
426      int Events = 0;
427      for (int EventN = 0; EventN < EventV.Len(); EventN++) {
428          if (EventV[EventN] <= MxEventId) { Events++; }
429      }
430      return Events;
431  }
432  int TBtaCorrBs::CountEvents(const TIntPrV& EventPrV, const int& MxEventId) const {
433      int Events = 0;
434      for (int EventPrN = 0; EventPrN < EventPrV.Len(); EventPrN++) {
435          const TIntPr& Pr = EventPrV[EventPrN];
436          if (Pr.Val1 <= MxEventId && Pr.Val2 <= MxEventId) { Events++; }
437      }
438      return Events;
439  }
440  TBtaCorrBs::TBtaCorrBs(const int& _MnSeverity, const int& _MxEvents, 
441          const int& _MxEventWnd, const int64& _MxTmMSecWnd) {
442      MnSeverity = _MnSeverity; MxEvents = _MxEvents;
443      MxEventWnd = _MxEventWnd; MxTmMSecWnd = _MxTmMSecWnd;
444      RecentEventV.Gen(MxEventWnd);
445      RecentEventV.PutAll(-1);
446      NextEventN = 0;
447  }
448  TBtaCorrBs::TBtaCorrBs(TSIn& SIn) {
449      printf("Loading Correlation Parameters ... ");
450      MnSeverity.Load(SIn); printf("<1>"); 
451      MxEvents.Load(SIn); printf("<2>"); 
452      MxEventWnd.Load(SIn); printf("<3>"); 
453      MxTmMSecWnd.Load(SIn); printf("<4>\n"); 
454      printf("Loading Alarm Counts ... ");
455      IpNumIdEvents.Load(SIn); printf("<1>"); 
456      ProjIdEvents.Load(SIn); printf("<2>");
457      IpNumIdToEventVH.Load(SIn); printf("<3>"); 
458      ProjIdToEventVH.Load(SIn); printf("<4>\n");
459      printf("Loading Alarm Pair Counts ... ");
460      IpNumIdPrEvents.Load(SIn); printf("<1>"); 
461      ProjIdPrEvents.Load(SIn); printf("<2>\n");
462      printf("Loading Alarm Correlations ... ");
463      IpNumIdPrToEventPrVH.Load(SIn); printf("<1>"); 
464      ProjIdPrToEventPrVH.Load(SIn); printf("<2>"); 
465      IpNumIdToCorrIpNumIdFqHH.Load(SIn); printf("<3>"); 
466      ProjIdToCorrProjIdFqHH.Load(SIn); printf("<4>\n"); 
467      printf("Loading Alarm Backward Correlations ... ");
468      CorrIpNumIdToIpNumIdFqHH.Load(SIn); printf("<1>"); 
469      CorrProjIdToProjIdFqHH.Load(SIn); printf("<2>\n"); 
470      printf("Loading Mappings ... ");
471      IpNumIdToProjIdH.Load(SIn); printf("<1>"); 
472      ProjIdToIpNumIdVH.Load(SIn); printf("<2>"); 
473      CaseIdToEventIdVH.Load(SIn); printf("<3>\n"); 
474      printf("Loading Recent Alarms ... ");
475      NextEventN.Load(SIn); printf("<1>"); 
476      RecentEventV.Load(SIn); printf("<2>\n");        
477  }
478  void TBtaCorrBs::Save(TSOut& SOut) const {
479      MnSeverity.Save(SOut);  
480      MxEvents.Save(SOut);  
481      MxEventWnd.Save(SOut);  
482      MxTmMSecWnd.Save(SOut);  
483      IpNumIdEvents.Save(SOut);  
484      ProjIdEvents.Save(SOut); 
485      IpNumIdToEventVH.Save(SOut);  
486      ProjIdToEventVH.Save(SOut); 
487      IpNumIdPrEvents.Save(SOut);  
488      ProjIdPrEvents.Save(SOut);  
489      IpNumIdPrToEventPrVH.Save(SOut);  
490      ProjIdPrToEventPrVH.Save(SOut);  
491      IpNumIdToCorrIpNumIdFqHH.Save(SOut);  
492      ProjIdToCorrProjIdFqHH.Save(SOut);  
493      CorrIpNumIdToIpNumIdFqHH.Save(SOut);  
494      CorrProjIdToProjIdFqHH.Save(SOut);  
495      IpNumIdToProjIdH.Save(SOut);  
496      ProjIdToIpNumIdVH.Save(SOut);  
497      CaseIdToEventIdVH.Save(SOut);  
498      NextEventN.Save(SOut);  
499      RecentEventV.Save(SOut);  
500  }
501  void TBtaCorrBs::AddEventBs(const PBtaEventBs& BtaEventBs) {
502      printf("Processing events ...\n");
503      int Events = BtaEventBs->GetEvents(), Skiped = 0; int64 MemUsed = 0;
504      int MxEventN = (MxEvents == -1) ? Events : TInt::GetMn(MxEvents, Events);
505      for (int EventN = 0; EventN < MxEventN; EventN++){
506          if (EventN % 100000 == 0) {
507              const TBtaEvent& Event = BtaEventBs->GetEvent(EventN);
508              TStr TmStr = Event.GetFirstTm().GetWebLogDateTimeStr();
509              printf("%dk / %dk (Dev: %dk, Corr: %dk, Date: %s)\n", 
510                  EventN/1000, MxEventN/1000, IpNumIdEvents/1000, 
511                  IpNumIdPrEvents/1000, TmStr.CStr());
512          }
513          if (EventN % 1000000 == 0) {
514              printf("  IpNumIdToEventVH     : %5dk : %sB\n", IpNumIdToEventVH.Len()/1000, 
515                  TUInt64::GetMegaStr(IpNumIdToEventVH.GetMemUsed()).CStr());
516              printf("  ProjIdToEventVH      : %6d : %sB\n", ProjIdToEventVH.Len(), 
517                  TUInt64::GetMegaStr(ProjIdToEventVH.GetMemUsed()).CStr());
518              printf("  IpNumIdToProjIdH     : %5dk : %sB\n", IpNumIdToProjIdH.Len()/1000, 
519                  TUInt64::GetMegaStr(IpNumIdToProjIdH.GetMemUsed()).CStr());
520              printf("  ProjIdToIpNumIdVH    : %6d : %sB\n", ProjIdToIpNumIdVH.Len(), 
521                  TUInt64::GetMegaStr(ProjIdToIpNumIdVH.GetMemUsed()).CStr());
522              printf("  IpNumIdPrToEventPrVH : %5dk : %sB\n", IpNumIdPrToEventPrVH.Len()/1000, 
523                  TUInt64::GetMegaStr(IpNumIdPrToEventPrVH.GetMemUsed()).CStr());
524              printf("  ProjIdPrToEventPrVH  : %6d : %sB\n", ProjIdPrToEventPrVH.Len(), 
525                  TUInt64::GetMegaStr(ProjIdPrToEventPrVH.GetMemUsed()).CStr());
526          }
527          const TBtaAddEventRes Res = AddEvent(BtaEventBs, EventN);
528          if (Res == baerUnknowIpNum || Res == baerUnknowProjId) { Skiped++; }
529      }
530      const TBtaEvent& Event = BtaEventBs->GetEvent(MxEventN - 1);
531      TStr TmStr = Event.GetFirstTm().GetWebLogDateTimeStr();
532      printf("%dk / %dk (Dev: %dk, Corr: %dk, Date: %s)\n", 
533          MxEventN/1000, MxEventN/1000, IpNumIdEvents/1000, 
534          IpNumIdPrEvents/1000, TmStr.CStr());
535      printf("  IpNumIdToEventVH     : %5dk : %sB\n", IpNumIdToEventVH.Len()/1000, 
536          TUInt64::GetMegaStr(IpNumIdToEventVH.GetMemUsed()).CStr());
537      printf("  ProjIdToEventVH      : %6d : %sB\n", ProjIdToEventVH.Len(), 
538          TUInt64::GetMegaStr(ProjIdToEventVH.GetMemUsed()).CStr());
539      printf("  IpNumIdToProjIdH     : %5dk : %sB\n", IpNumIdToProjIdH.Len()/1000, 
540          TUInt64::GetMegaStr(IpNumIdToProjIdH.GetMemUsed()).CStr());
541      printf("  ProjIdToIpNumIdVH    : %6d : %sB\n", ProjIdToIpNumIdVH.Len(), 
542          TUInt64::GetMegaStr(ProjIdToIpNumIdVH.GetMemUsed()).CStr());
543      printf("  IpNumIdPrToEventPrVH : %5dk : %sB\n", IpNumIdPrToEventPrVH.Len()/1000, 
544          TUInt64::GetMegaStr(IpNumIdPrToEventPrVH.GetMemUsed()).CStr());
545      printf("  ProjIdPrToEventPrVH  : %6d : %sB\n", ProjIdPrToEventPrVH.Len(), 
546          TUInt64::GetMegaStr(ProjIdPrToEventPrVH.GetMemUsed()).CStr());
547      printf("\nDone.\n");
548  }
549  TBtaCorrBs::TBtaAddEventRes TBtaCorrBs::AddEvent(
550          const PBtaEventBs& BtaEventBs, const int& EventN) {
551      const TBtaEvent& Event = BtaEventBs->GetEvent(EventN);
552      const int IpNumId = Event.GetIpNumId();
553      const int ProjId = Event.GetProjId();
554      const uint64 TmMSec = Event.GetFirstTmMSecs();
555      if (IpNumId == -1) { return baerUnknowIpNum; }
556      if (ProjId == -1) { return baerUnknowProjId; }
557      const int Severity = Event.GetSeverity();
558      if (Severity < MnSeverity) { return baerLowSeverity; }
559      IpNumIdToEventVH.AddDat(IpNumId).Add(EventN); IpNumIdEvents++;
560      ProjIdToEventVH.AddDat(ProjId).Add(EventN); ProjIdEvents++;
561      IpNumIdToProjIdH.AddDat(IpNumId) = ProjId;
562      ProjIdToIpNumIdVH.AddDat(ProjId).AddMerged(IpNumId);
563      const int CaseId = Event.GetCaseId();
564      if (CaseId != -1) { CaseIdToEventIdVH.AddDat(CaseId).Add(EventN); }
565      const int RecentEvents = RecentEventV.Len();
566      for (int RecentEventN = 0; RecentEventN < RecentEvents; RecentEventN++) {
567          const int CorrEventN = RecentEventV[RecentEventN];
568          if (CorrEventN == -1) { continue; }
569          const TBtaEvent& CorrEvent = BtaEventBs->GetEvent(CorrEventN); 
570          const uint64 CorrTmMSec = CorrEvent.GetFirstTmMSecs();
571          if (MxTmMSecWnd > 0) { 
572              if ((TmMSec > CorrTmMSec) && ((TmMSec - CorrTmMSec) >  MxTmMSecWnd)) { continue; }
573              if ((TmMSec < CorrTmMSec) && ((CorrTmMSec - TmMSec) >  MxTmMSecWnd)) { continue; }
574          }        
575          const int CorrIpNumId = CorrEvent.GetIpNumId();
576          const int CorrProjId = CorrEvent.GetProjId();
577          IAssertR((IpNumId != -1) && (CorrIpNumId != -1), TStr::Fmt("(%d,%d)", IpNumId, CorrIpNumId));
578          IAssertR((ProjId != -1) && (CorrProjId != -1), TStr::Fmt("(%d,%d)", ProjId, CorrProjId));
579          IAssert(CorrEvent.GetSeverity() >= MnSeverity);
580          if (TmMSec < CorrTmMSec) { 
581              TIntPrV& EventPrV = IpNumIdPrToEventPrVH.AddDat(TIntPr(IpNumId, CorrIpNumId));
582              EventPrV.Add(TIntPr(EventN, CorrEventN)); IpNumIdPrEvents++;
583              IpNumIdToCorrIpNumIdFqHH.AddDat(IpNumId).AddDat(CorrIpNumId)++;
584              CorrIpNumIdToIpNumIdFqHH.AddDat(CorrIpNumId).AddDat(IpNumId)++;
585          } else {
586              TIntPrV& EventPrV = IpNumIdPrToEventPrVH.AddDat(TIntPr(CorrIpNumId, IpNumId));
587              EventPrV.Add(TIntPr(CorrEventN, EventN)); IpNumIdPrEvents++;
588              IpNumIdToCorrIpNumIdFqHH.AddDat(CorrIpNumId).AddDat(IpNumId)++;
589              CorrIpNumIdToIpNumIdFqHH.AddDat(IpNumId).AddDat(CorrIpNumId)++;
590          }
591          if (ProjId != CorrProjId) {
592              if (TmMSec < CorrTmMSec) { 
593                  TIntPrV& EventPrV = ProjIdPrToEventPrVH.AddDat(TIntPr(ProjId, CorrProjId));
594                  EventPrV.Add(TIntPr(EventN, CorrEventN)); ProjIdPrEvents++;
595                  ProjIdToCorrProjIdFqHH.AddDat(ProjId).AddDat(CorrProjId)++;
596                  CorrProjIdToProjIdFqHH.AddDat(CorrProjId).AddDat(ProjId)++;
597              } else {
598                  TIntPrV& EventPrV = ProjIdPrToEventPrVH.AddDat(TIntPr(CorrProjId, ProjId));
599                  EventPrV.Add(TIntPr(CorrEventN, EventN)); ProjIdPrEvents++;
600                  ProjIdToCorrProjIdFqHH.AddDat(CorrProjId).AddDat(ProjId)++;
601                  CorrProjIdToProjIdFqHH.AddDat(ProjId).AddDat(CorrProjId)++;
602              }
603          }
604      }
605      RecentEventV[NextEventN] = EventN;
606      NextEventN++; NextEventN = NextEventN % RecentEvents;
607      return baerOk;
608  }
609  TStr TBtaCorrBs::GetErrorMsgStr(const TBtaCorrBs::TBtaAddEventRes& ErrorCode) const {
610      if (ErrorCode == TBtaCorrBs::baerLowSeverity) { return "To low severity!"; }
611      if (ErrorCode == TBtaCorrBs::baerUnknowIpNum) { return "Unknown IpNum!"; }
612      if (ErrorCode == TBtaCorrBs::baerUnknowProjId) { return "Unknown ProjId!"; }
613      if (ErrorCode == TBtaCorrBs::baerOk) { return "Event OK!"; }
614      return "Unknown error when adding event to CorrBs!";
615  }
616  double TBtaCorrBs::ProbIpNumId(const int& IpNumId) const {
617      const int IpNumIds = IpNumIdToEventVH.Len();
618      const int IpNumIdFq = IpNumIdToEventVH.IsKey(IpNumId) ?
619          IpNumIdToEventVH.GetDat(IpNumId).Len() : 0;
620      return double(IpNumIdFq + 1) / double(IpNumIdEvents + IpNumIds);
621  }
622  double TBtaCorrBs::ProbIpNumIdAndCorrIpNumId(const int& IpNumId, const int& CorrIpNumId) const {
623      TIntPr IpNumPr(IpNumId, CorrIpNumId), RevIpNumPr(CorrIpNumId, IpNumId);
624      const int IpNumIdPrFq = IpNumIdPrToEventPrVH.IsKey(IpNumPr) ?
625          IpNumIdPrToEventPrVH.GetDat(IpNumPr).Len() : 0; 
626      const int RevIpNumIdPrFq = IpNumIdPrToEventPrVH.IsKey(RevIpNumPr) ? 
627          IpNumIdPrToEventPrVH.GetDat(RevIpNumPr).Len() : 0; 
628      const int IpNumIds = IpNumIdToEventVH.Len();
629      const int AllIpNumIdPrs = IpNumIds*IpNumIds;
630      const double Prior = 1.0;
631      return (double(IpNumIdPrFq + RevIpNumIdPrFq) + Prior) / 
632          double(IpNumIdPrEvents + AllIpNumIdPrs);
633  }
634  double TBtaCorrBs::ProbCorrIpNumIdGivenIpNumId(const int& IpNumId, const int& CorrIpNumId) const {
635      const int IpNumIdFq = IpNumIdToEventVH.GetDat(IpNumId).Len();
636      const int CorrIpNumIdFq = IpNumIdToEventVH.GetDat(CorrIpNumId).Len();
637      if (CorrIpNumIdFq / IpNumIdFq > 10) { return 0.0; }
638      TIntPr IpNumPr(IpNumId, CorrIpNumId);
639      const int IpNumIdPrFq = IpNumIdPrToEventPrVH.GetDat(IpNumPr).Len(); 
640      const int AllIpNumIdPrs = SumFqV(IpNumIdToCorrIpNumIdFqHH.GetDat(IpNumId));
641      const int IpNumIds = IpNumIdToEventVH.Len();
642      return (double(IpNumIdPrFq) + 1.0) / double(AllIpNumIdPrs + IpNumIds);
643  }
644  double TBtaCorrBs::GetIpNumMxCorrIpNumProb(const int& IpNumId) const {
645      double MxCorrProb = 0.0;
646      const TIntH& CorrIdFqH = GetIpNumCorrIpNumH(IpNumId);
647      int CorrIdKeyId = CorrIdFqH.FFirstKeyId();
648      while (CorrIdFqH.FNextKeyId(CorrIdKeyId)) {
649          const int CorrIpNumId = CorrIdFqH.GetKey(CorrIdKeyId);
650          if (IsCorrIpNumId(CorrIpNumId)) {
651              const double CorrProb = ProbCorrIpNumIdGivenIpNumId(IpNumId, CorrIpNumId);
652              MxCorrProb = TFlt::GetMx(CorrProb, MxCorrProb);
653          }
654      }
655      return MxCorrProb;
656  }
657  double TBtaCorrBs::ProbIpNumId(const int& IpNumId, const int& MxEventId) const {
658      const int IpNumIds = IpNumIdToEventVH.Len();
659      const int IpNumIdFq = IpNumIdToEventVH.IsKey(IpNumId) ?
660          CountEvents(IpNumIdToEventVH.GetDat(IpNumId), MxEventId) : 0;
661      return double(IpNumIdFq + 1) / double((MxEventId + 1) + IpNumIds);
662  }
663  double TBtaCorrBs::ProbIpNumIdAndCorrIpNumId(const int& IpNumId, 
664          const int& CorrIpNumId, const int& MxEventId) const {
665      TIntPr IpNumPr(IpNumId, CorrIpNumId), RevIpNumPr(CorrIpNumId, IpNumId);
666      const int IpNumIdPrFq = IpNumIdPrToEventPrVH.IsKey(IpNumPr) ? 
667          CountEvents(IpNumIdPrToEventPrVH.GetDat(IpNumPr), MxEventId) : 0; 
668      const int RevIpNumIdPrFq = IpNumIdPrToEventPrVH.IsKey(RevIpNumPr) ?
669          CountEvents(IpNumIdPrToEventPrVH.GetDat(RevIpNumPr), MxEventId) : 0; 
670      const int IpNumIds = IpNumIdToEventVH.Len();
671      const int AllIpNumIdPrs = IpNumIds*IpNumIds;
672      const double Prior = 1.0;
673      return (double(IpNumIdPrFq + RevIpNumIdPrFq) + Prior) / 
674          double(IpNumIdPrEvents + AllIpNumIdPrs);
675  }
676  double TBtaCorrBs::ProbCorrIpNumIdGivenIpNumId(const int& IpNumId, 
677          const int& CorrIpNumId, const int& MxEventId) const {
678      const int AllIpNumIdPrs = SumFqV(IpNumIdToCorrIpNumIdFqHH.GetDat(IpNumId));
<span onclick='openModal()' class='match'>679      const int IpNumIds = IpNumIdToEventVH.Len();
680      const int IpNumIdFq = IpNumIdToEventVH.IsKey(IpNumId) ?
681          CountEvents(IpNumIdToEventVH.GetDat(IpNumId), MxEventId) : 0;
682      const int CorrIpNumIdFq = IpNumIdToEventVH.IsKey(CorrIpNumId) ?
</span>683          CountEvents(IpNumIdToEventVH.GetDat(CorrIpNumId), MxEventId) : 0;
684      if ((IpNumIdFq == 0) || (CorrIpNumIdFq / IpNumIdFq > 10)) {
685          return 1.0 / double(AllIpNumIdPrs + IpNumIds);
686      } else {
687          TIntPr IpNumPr(IpNumId, CorrIpNumId);
688          const int IpNumIdPrFq = IpNumIdPrToEventPrVH.IsKey(IpNumPr) ?
689              CountEvents(IpNumIdPrToEventPrVH.GetDat(IpNumPr), MxEventId) : 0; 
690          return (double(IpNumIdPrFq) + 1.0) / double(AllIpNumIdPrs + IpNumIds);
691      }
692  }
693  double TBtaCorrBs::GetProjCorrProjProb(const int& ProjId, const int& CorrProjId) const {
694      const int CorrFq = ProjIdPrToEventPrVH.GetDat(TIntPr(ProjId, CorrProjId)).Len();
695      const double ForwardProb = double(CorrFq) / double(GetProjCorrProjFqs(ProjId));
696      const double BackwardProb = double(CorrFq) / double(GetCorrProjProjFqs(CorrProjId));
697      return ForwardProb * BackwardProb;
698  }
699  double TBtaCorrBs::GetProjMxCorrProjProb(const int& ProjId) const {
700      double MxCorrProb = 0.0;
701      const TIntH& CorrIdFqH = GetProjCorrProjH(ProjId);
702      int CorrIdKeyId = CorrIdFqH.FFirstKeyId();
703      while (CorrIdFqH.FNextKeyId(CorrIdKeyId)) {
704          const int CorrProjId = CorrIdFqH.GetKey(CorrIdKeyId);
705          if (IsCorrProjId(CorrProjId)) {
706              const double CorrProb = GetProjCorrProjProb(ProjId, CorrProjId);
707              MxCorrProb = TFlt::GetMx(CorrProb, MxCorrProb);
708          }
709      }
710      return MxCorrProb;
711  }
712  void TBtaCorrBs::GetIpNumCorrDevices(const int& IpNumId, const bool& SameProjP, 
713          const int& MxItems, TIntFltKdV& CorrIpNumIdProbV) const {
714      CorrIpNumIdProbV.Clr();
715      if (!IsIpNumId(IpNumId) || !IsIpNumProj(IpNumId)) { return; }
716      const int IpNumProjId = GetIpNumProjId(IpNumId);
717      double MxCorrProb = 0.0;
718      TVec<TIntBoolPr> CorrIpNumIdForwardV;
719      {const TIntH& ForwardCorrIdFqH = GetIpNumCorrIpNumH(IpNumId);
720      int ForwardCorrIdKeyId = ForwardCorrIdFqH.FFirstKeyId();
721      while (ForwardCorrIdFqH.FNextKeyId(ForwardCorrIdKeyId)) {
722          const int CorrIpNumId = ForwardCorrIdFqH.GetKey(ForwardCorrIdKeyId);
723          CorrIpNumIdForwardV.Add(TIntBoolPr(CorrIpNumId, true));
724      }}
725      {const TIntH& BackwardCorrIdFqH = GetCorrIpNumIpNumH(IpNumId);
726      int BackwardCorrIdKeyId = BackwardCorrIdFqH.FFirstKeyId();
727      while (BackwardCorrIdFqH.FNextKeyId(BackwardCorrIdKeyId)) {
728          const int CorrIpNumId = BackwardCorrIdFqH.GetKey(BackwardCorrIdKeyId);
729          CorrIpNumIdForwardV.Add(TIntBoolPr(CorrIpNumId, false));
730      }}
731      TVec<TFltIntBoolPrKd> CorrProbIpNumIdV;
732      for (int CorrIpNumIdN = 0; CorrIpNumIdN < CorrIpNumIdForwardV.Len(); CorrIpNumIdN++) {
733          const int CorrIpNumId = CorrIpNumIdForwardV[CorrIpNumIdN].Val1;
734          const bool ForwardP = CorrIpNumIdForwardV[CorrIpNumIdN].Val2;
735          if (IpNumId == CorrIpNumId) { continue; }
736          if (IsCorrIpNumId(CorrIpNumId) && IsIpNumProj(CorrIpNumId)) {
737              const int CorrIpNumProjId = GetIpNumProjId(CorrIpNumId);            
738              if (SameProjP && (IpNumProjId != CorrIpNumProjId)) { continue; }
739              if (!SameProjP && (IpNumProjId == CorrIpNumProjId)) { continue; }
740              const double CorrProb = ForwardP ? 
741                  ProbCorrIpNumIdGivenIpNumId(IpNumId, CorrIpNumId) :
742                  ProbCorrIpNumIdGivenIpNumId(CorrIpNumId, IpNumId);
743              if (CorrProb > 0.0) { 
744                  CorrProbIpNumIdV.Add(TFltIntBoolPrKd(
745                      CorrProb, TIntBoolPr(CorrIpNumId, ForwardP))); 
746              }
747              MxCorrProb = TFlt::GetMx(CorrProb, MxCorrProb);
748          }
749      }
750      CorrProbIpNumIdV.Sort(false);
751      const int Items = TInt::GetMn(CorrProbIpNumIdV.Len(), MxItems);
752      CorrIpNumIdProbV.Gen(Items, 0);
753      for (int ItemN = 0; ItemN < Items; ItemN++) {
754          const double CorrProb = CorrProbIpNumIdV[ItemN].Key;
755          const int CorrIpNumId = CorrProbIpNumIdV[ItemN].Dat.Val1;
756          const bool ForwardP = CorrProbIpNumIdV[ItemN].Dat.Val2;
757          if ((MxCorrProb / CorrProb) < 10.0) {
758              CorrIpNumIdProbV.Add(TIntFltKd(CorrIpNumId, 
759                  ForwardP ? CorrProb : -CorrProb));
760          }
761      }
762  }
763  void TBtaCorrBs::GetProjCorrDevices(const int& ProjId, 
764          const int& MxItems, TIntPrFltKdV& CorrIpNumIdPrProbV) const {
765      CorrIpNumIdPrProbV.Clr();
766      if (!IsProjIpNums(ProjId)) { return; }
767      double MxCorrProb = 0.0;
768      TFltIntIntTrV CorrProbIpNumPrV;
769      const TIntV& IpNumIdV = GetProjIpNumV(ProjId);
770      for (int IpNumIdN = 0; IpNumIdN < IpNumIdV.Len(); IpNumIdN++) {
771          const int IpNumId = IpNumIdV[IpNumIdN];
772          const TIntH& CorrIpFqH = GetIpNumCorrIpNumH(IpNumId);
773          int CorrIpKeyId = CorrIpFqH.FFirstKeyId(), CorrIpNums = 0;
774          while (CorrIpFqH.FNextKeyId(CorrIpKeyId)) {
775              const int CorrIpNumId = CorrIpFqH.GetKey(CorrIpKeyId);
776              if (IpNumId == CorrIpNumId) { continue; }
777              if (IsCorrIpNumId(CorrIpNumId) && IsIpNumProj(CorrIpNumId)) {
778                  const int CorrIpNumProjId = GetIpNumProjId(CorrIpNumId);            
779                  if (ProjId != CorrIpNumProjId) { continue; }
780                  const double CorrProb = 
781                      ProbCorrIpNumIdGivenIpNumId(IpNumId, CorrIpNumId);
782                  if (CorrProb > 0.0) { 
783                      CorrProbIpNumPrV.Add(TFltIntIntTr(
784                          CorrProb, IpNumId, CorrIpNumId)); 
785                  }
786                  MxCorrProb = TFlt::GetMx(CorrProb, MxCorrProb);
787                  CorrIpNums++;
788              }
789          }
790          printf("%d/%d [%5d / %5d]\r", IpNumIdN, IpNumIdV.Len(), CorrIpNums, CorrIpFqH.Len());
791      }
792      CorrProbIpNumPrV.Sort(false);
793      const int Items = TInt::GetMn(CorrProbIpNumPrV.Len(), MxItems);
794      CorrIpNumIdPrProbV.Gen(Items, 0);
795      for (int ItemN = 0; ItemN < Items; ItemN++) {
796          const double CorrProb = CorrProbIpNumPrV[ItemN].Val1;
797          const int IpNumId = CorrProbIpNumPrV[ItemN].Val2;
798          const int CorrIpNumId = CorrProbIpNumPrV[ItemN].Val3;
799          if ((MxCorrProb / CorrProb) < 10.0) {
800              CorrIpNumIdPrProbV.Add(TIntPrFltKd(
801                  TIntPr(IpNumId, CorrIpNumId), CorrProb));
802          }
803      }
804  }
805  void TBtaCorrBs::GetNextIpNumIdProb(const int& LastEventN, const int& ProjId,
806          const PBtaEventBs& BtaEventBs, const int& MxEventWnd, 
807          const int64& MxTmMSecWnd, TIntFltH& IpNumIdProbH) const {
808      IpNumIdProbH.Clr();
809      TBtaEventV EventWndV;
810      int EventWndN = LastEventN;
811      while (EventWndN >= 0) {
812          const TBtaEvent& Event = BtaEventBs->GetEvent(EventWndN); EventWndN--; 
813          if ((Event.GetIpNumId() == -1) || (Event.GetProjId() == -1)){ continue; }
814          if (Event.GetProjId() != ProjId) { continue; }
815          if (!EventWndV.Empty()) {
816              const int CountDiff = LastEventN - EventWndN;
817              const int64 TmMSecDiff = Event.GetFirstTmMSecs() - EventWndV[0].GetFirstTmMSecs();
818              if ((MxEventWnd > 0) && (CountDiff > MxEventWnd)) { break; }
819              if ((MxTmMSecWnd > 0) && (TmMSecDiff > MxTmMSecWnd)) { break; }
820          }
821          EventWndV.Add(Event);
822      }
823      if (EventWndV.Empty()) { return; } 
824      EventWndV.Reverse();
825      PBtaDevDefBs BtaDevDefBs = BtaEventBs->GetDevDefBs();
826      TIntH CandIpNumIdH;
827      for (int IpNumId = 0; IpNumId < BtaDevDefBs->GetIpNums(); IpNumId++) {
828          if (!IsIpNumProj(IpNumId)) { continue; };
829          if (GetIpNumProjId(IpNumId) != ProjId) { continue; };
830          for (int EventWndN = 0; EventWndN < EventWndV.Len(); EventWndN++) {
831              const int PrevIpNumId = EventWndV[EventWndN].GetIpNumId();
832              if (IsIpNumIdPrCorr(PrevIpNumId, IpNumId)) {
833                  CandIpNumIdH.AddDat(IpNumId) += 
834                      GetIpNumCorrIpNumPrEventV(PrevIpNumId, IpNumId).Len();
835              }
836          }
837      }
838      if (CandIpNumIdH.Empty()) { return; } 
839      TIntPrIntH WndIpNumPrH;
840      for (int FirstEventWndN = 0; FirstEventWndN < EventWndV.Len(); FirstEventWndN++) {
841          for (int SecondEventWndN = FirstEventWndN+1; SecondEventWndN < EventWndV.Len(); SecondEventWndN++) {
842              TBtaEvent FirstEvent = EventWndV[FirstEventWndN];
843              TBtaEvent SecondEvent = EventWndV[SecondEventWndN];
844              TIntPr WndIpNumIdPr(FirstEvent.GetIpNumId(), SecondEvent.GetIpNumId());
845              if (!WndIpNumPrH.IsKey(WndIpNumIdPr)) {
846                  WndIpNumPrH.AddDat(WndIpNumIdPr)++;
847              }
848          }
849      }
850      int CandKeyId = CandIpNumIdH.FFirstKeyId();
851      const int IpNumIds = IpNumIdToEventVH.Len();
852      const double IpNumIdPrs = double(IpNumIds*(IpNumIds - 1) / 2);
853      const double IpNumIdTrs = double(IpNumIds*(IpNumIds - 1)*(IpNumIds - 2) / 6);
854      while (CandIpNumIdH.FNextKeyId(CandKeyId)) {
855          const int CandIpNumId = CandIpNumIdH.GetKey(CandKeyId);
856          double CandProb = 0.0;
857          int WndKeyId = WndIpNumPrH.FFirstKeyId();
858          while (WndIpNumPrH.FNextKeyId(WndKeyId)) {
859              const int FirstIpNumId = WndIpNumPrH.GetKey(WndKeyId).Val1;
860              const int SecondIpNumId = WndIpNumPrH.GetKey(WndKeyId).Val2;
861              IAssertR(FirstIpNumId != -1, TInt::GetStr(FirstIpNumId));
862              IAssertR(SecondIpNumId != -1, TInt::GetStr(SecondIpNumId));
863              const double FirstSecondProb = ProbIpNumIdAndCorrIpNumId(
864                  FirstIpNumId, SecondIpNumId, LastEventN);
865              const double FirstCandProb = ProbIpNumIdAndCorrIpNumId(
866                  FirstIpNumId, CandIpNumId, LastEventN);
867              const double SecondCandProb = ProbIpNumIdAndCorrIpNumId(
868                  SecondIpNumId, CandIpNumId, LastEventN);
869              const double Prob = FirstSecondProb*FirstCandProb*SecondCandProb;
870              CandProb += Prob;
871          }
872          IpNumIdProbH.AddDat(CandIpNumId, CandProb);
873      }   
874  }
875  void TBtaCorrBs::GetListOfFutureIpNums(const PBtaEventBs& BtaEventBs, 
876          const int& LastEventN, const int& MxEventWnd, const int64& MxTmMSecWnd, 
877          TIntH& FutureIpNumH) const {
878      const int MxEvents = TInt::GetMn(BtaEventBs->GetEvents(), LastEventN + MxEventWnd + 1);
879      const uint64 FirstTmMSec = BtaEventBs->GetEvent(LastEventN+1).GetFirstTmMSecs();
880      int EventWndN = LastEventN+1;
881      while (EventWndN < MxEvents) {
882          const TBtaEvent& Event = BtaEventBs->GetEvent(EventWndN); EventWndN++; 
883          if ((Event.GetIpNumId() == -1) || (Event.GetProjId() == -1)){ continue; }
884          const int CountDiff = EventWndN - LastEventN - 1;
885          const int64 TmMSecDiff = Event.GetFirstTmMSecs() - FirstTmMSec;
886          if ((MxEventWnd > 0) && (CountDiff > MxEventWnd)) { break; }
887          if ((MxTmMSecWnd > 0) && (TmMSecDiff > MxTmMSecWnd)) { break; }
888          FutureIpNumH.AddDat(Event.GetIpNumId())++;
889      }    
890  }
891  void TBtaCorrBs::GetPredStat(const PBtaEventBs& BtaEventBs, const int& MxEvents, 
892          const int& MxEventWnd, const int64& MxTmMSecWnd, const int& MxEvalWnd) const {
893      const int TopRank = 100; TMomV TopMomV(TopRank), TimeMomV(TopRank);
894      for (int RankN = 0; RankN < TopRank; RankN++) {
895          TopMomV[RankN] = TMom::New(); TimeMomV[RankN] = TMom::New(); }
896      TRnd Rnd(1);
897      for (int EventIdN = 0; EventIdN < MxEvents; EventIdN++) {
898          printf("%d / %d\r", EventIdN+1, MxEvents);
899          const int EventId = Rnd.GetUniDevInt(BtaEventBs->GetEvents() - MxEvalWnd);
900          const TBtaEvent& Event = BtaEventBs->GetEvent(EventId);
901          TIntFltH IpNumIdProbH;
902          GetNextIpNumIdProb(EventId, Event.GetProjId(),
903              BtaEventBs, MxEventWnd, MxTmMSecWnd, IpNumIdProbH);
904          if (!IpNumIdProbH.Empty()) {
905              TFltIntPrV ProbIpNumIdV;
906              IpNumIdProbH.GetDatKeyPrV(ProbIpNumIdV);
907              ProbIpNumIdV.Sort(false);
908              TIntH FutureIpNumH;
909              GetListOfFutureIpNums(BtaEventBs, EventId+1, MxEvalWnd, -1, FutureIpNumH);
910              TFltV RankCountV(TopRank); RankCountV.PutAll(0.0); double SumTime = 0.0;
911              for (int RankN = 0; RankN < TopRank; RankN++) {
912                  if (RankN >= ProbIpNumIdV.Len()) { break; }
913                  const int RankIpNumId = ProbIpNumIdV[RankN].Val2;
914                  if (FutureIpNumH.IsKey(RankIpNumId)) {
915                      for (int RestRankN = RankN; RestRankN < TopRank; RestRankN++) {
916                          RankCountV[RestRankN] += 1.0; }
917                  }
918                  TopMomV[RankN]->Add(RankCountV[RankN]);
919                  const int NextEventId = BtaEventBs->GetNextEvent(EventId+1, RankIpNumId);
920                  if (NextEventId != -1) {
921                      const TBtaEvent& NextEvent = BtaEventBs->GetEvent(NextEventId);
922                      const uint64 TimeDiffMSec = NextEvent.GetFirstTmMSecs() - Event.GetFirstTmMSecs();
923                      const int TimeDiffSec = int(TimeDiffMSec / uint64(1000));
924                      SumTime += double(TimeDiffSec);
925                  }
926                  TimeMomV[RankN]->Add(SumTime / double(RankN + 1));
927              }
928          }
929      }
930      TFOut RankFOut(TFile::GetUniqueFNm("PredRes.txt")); 
931      for (int RankN = 0; RankN < TopRank; RankN++) {
932          TopMomV[RankN]->Def(); TimeMomV[RankN]->Def();
933          RankFOut.PutStrLn(TStr::Fmt("%3d: Prec: %3.5f +/- %2.5f    Time: %5.5f +/- %3.5f",
934              RankN + 1, TopMomV[RankN]->GetMean(), TopMomV[RankN]->GetSDev(),    
935              TimeMomV[RankN]->GetMean(), TimeMomV[RankN]->GetSDev()));
936      }
937      printf("\n");
938  }
939  void TBtaCorrBs::EventRootCauseProb(const PBtaEventBs& BtaEventBs, 
940          const int& EventId, const int& RootCouseEventWnd, 
941          const int64& RootCouseTimeWnd, TIntFltKdV& EventIdScoreV) const {
942      TBtaEvent Event = BtaEventBs->GetEvent(EventId);
943      const int IpNumId = Event.GetIpNumId();
944      const int ProjId = Event.GetProjId();
945      const int64 TmMSec = Event.GetFirstTmMSecs();
946      TFltIntPrV ProbEventIdV;
947      int ProcEventN = 0, CurrEventId = EventId;
948      while (CurrEventId > 0) {
949          CurrEventId--; 
950          TBtaEvent CurrEvent = BtaEventBs->GetEvent(CurrEventId);
951          const int CurrIpNumId = CurrEvent.GetIpNumId();
952          const int CurrProjId = CurrEvent.GetProjId();
953          const int64 TmMSecDiff = TmMSec - CurrEvent.GetFirstTmMSecs();
954          if (TmMSecDiff > RootCouseTimeWnd) { break; }
955          if (CurrIpNumId == -1 || CurrProjId == -1) { continue; }
956          if (ProjId != CurrProjId) { continue; }
957          if (CurrEvent.GetSeverity() < 3) { continue; }
958          if (!IsIpNumIdPrCorr(CurrIpNumId, IpNumId)) { continue; }
959          if (ProcEventN > RootCouseEventWnd) { break; }
960          ProcEventN++;
961          const double CorrProb = ProbCorrIpNumIdGivenIpNumId(CurrIpNumId, IpNumId, true);
962          ProbEventIdV.Add(TFltIntPr(CorrProb, CurrEventId));
963      }
964      ProbEventIdV.Sort(false); 
965      const int MxEvents = 5;
966      const int ProbEventIds = TInt::GetMn(ProbEventIdV.Len(), MxEvents);
967      EventIdScoreV.Clr(); double OldProb = 0.0;
968      for (int ProbEventIdN = 0; ProbEventIdN < ProbEventIds; ProbEventIdN++) {
969          const int ProbEventId = ProbEventIdV[ProbEventIdN].Val2;
970          const double Prob = ProbEventIdV[ProbEventIdN].Val1;
971          if (Prob < OldProb / 3) { break; } OldProb = Prob;
972          EventIdScoreV.Add(TIntFltKd(ProbEventId, Prob));
973      }
974  }
975  void TBtaCorrBs::EventRootCauseText(const PBtaEventBs& BtaEventBs, 
976          const int& EventId,const int& RootCouseEventWnd, 
977          const int64& RootCouseTimeWnd, TIntFltKdV& EventIdScoreV) const {
978      TBtaEvent Event = BtaEventBs->GetEvent(EventId);
979      TBtaEventDat EventDat; BtaEventBs->GetEventDat(Event.GetBlobPt(), EventDat);
980      const int IpNumId = Event.GetIpNumId();
981      const int ProjId = Event.GetProjId();
982      const int64 TmMSec = Event.GetFirstTmMSecs();
983      PBowDocBs BowDocBs = TBowDocBs::New();
984      const int FirstDId = BowDocBs->AddHtmlDoc(
985          TInt::GetStr(EventId), TStrV(), EventDat.GetSummary());
986      IAssert(FirstDId == 0); int ProcEventN = 0, CurrEventId = EventId;
987      while (CurrEventId > 0) {
988          CurrEventId--; 
989          TBtaEvent CurrEvent = BtaEventBs->GetEvent(CurrEventId);
990          const int CurrIpNumId = CurrEvent.GetIpNumId();
991          const int CurrProjId = CurrEvent.GetProjId();
992          const int64 TmMSecDiff = TmMSec - CurrEvent.GetFirstTmMSecs();
993          if (TmMSecDiff > RootCouseTimeWnd) { break; }
994          if (CurrIpNumId == -1 || CurrProjId == -1) { continue; }
995          if (ProjId != CurrProjId) { continue; }
996          if (CurrEvent.GetSeverity() < 3) { continue; }
997          if (ProcEventN > RootCouseEventWnd) { break; }
998          ProcEventN++;
999          TBtaEventDat CurrEventDat; BtaEventBs->GetEventDat(CurrEvent.GetBlobPt(), CurrEventDat);
1000          BowDocBs->AddHtmlDoc(TInt::GetStr(CurrEventId), TStrV(), CurrEventDat.GetSummary());
1001      }
1002      TIntFltIntTrV HeaderSimEventIdV;
1003      PBowSim BowSim = TBowSim::New(bstCos);
1004      TStr EventSummary = EventDat.GetSummary(), HeaderStr = "";
1005      if (EventSummary.SearchCh(':') > 0) {
1006          HeaderStr = EventSummary.GetSubStr(0, EventSummary.SearchCh(':')-1); 
1007      }
1008      for (int DId = 0; DId < BowDocBs->GetDocs(); DId++) {
1009          if (DId == FirstDId) { continue; }
1010          const int CurrEventId = BowDocBs->GetDocNm(DId).GetInt();
1011          TBtaEvent CurrEvent = BtaEventBs->GetEvent(CurrEventId);
1012          TStr CurrEventSummary = EventDat.GetSummary(), CurrHeaderStr = "";
1013          const int ColonPos = EventSummary.SearchCh(':');
1014          if (ColonPos > 0) { CurrHeaderStr = CurrEventSummary.GetSubStr(0, ColonPos-1); }
1015          TIntFltIntTr HeaderSimEventId;
1016          HeaderSimEventId.Val1 = (HeaderStr == CurrHeaderStr) ? 1 : 0;
1017          HeaderSimEventId.Val2 = BowSim->GetSim(
1018              BowDocBs->GetDocSpV(FirstDId), BowDocBs->GetDocSpV(DId));
1019          HeaderSimEventId.Val3 = CurrEventId;
1020          HeaderSimEventIdV.Add(HeaderSimEventId);
1021      }
1022      HeaderSimEventIdV.Sort(false); 
1023      const int MxEvents = 5;
1024      const int HeaderSimEventIds = TInt::GetMn(HeaderSimEventIdV.Len(), MxEvents);
1025      EventIdScoreV.Clr(); double OldSim = 0.0;
1026      for (int HeaderSimEventIdN = 0; HeaderSimEventIdN < HeaderSimEventIds; HeaderSimEventIdN++) {
1027          const int HeaderSimEventId = HeaderSimEventIdV[HeaderSimEventIdN].Val3;
1028          const double Sim = HeaderSimEventIdV[HeaderSimEventIdN].Val2;
1029          if (Sim < 0.001) { break; }
1030          if (Sim < OldSim / 3) { break; } OldSim = Sim;
1031          EventIdScoreV.Add(TIntFltKd(HeaderSimEventId, Sim));
1032      }
1033  }
1034  void TBtaCorrBs::EventRootCause(const PBtaEventBs& BtaEventBs, const int& EventId, 
1035          const int& RootCouseEventWnd, const int64& RootCouseTimeWnd,
1036          TIntFltKdV& EventIdScoreV, TStrV& CorrTypeV) const {
1037      TIntFltKdV EventIdProbV;
1038      EventRootCauseProb(BtaEventBs, EventId, 
1039          RootCouseEventWnd, RootCouseTimeWnd, EventIdProbV);
1040      TIntFltKdV EventIdSimV; 
1041      EventRootCauseText(BtaEventBs, EventId,
1042          RootCouseEventWnd, RootCouseTimeWnd, EventIdSimV);
1043      TIntFltH EventIdScoreH; TIntStrH EventIdTypeH;
1044      for (int EventIdProbN = 0; EventIdProbN < EventIdProbV.Len(); EventIdProbN++) {
1045          const int ProbEventId = EventIdProbV[EventIdProbN].Key;
1046          const double Prob = EventIdProbV[EventIdProbN].Dat;
1047          const double MxProb = EventIdProbV[0].Dat;
1048          const double Score = Prob / MxProb;
1049          EventIdScoreH.AddDat(ProbEventId, Score);
1050          EventIdTypeH.AddDat(ProbEventId, "Prob");
1051      }
1052      for (int EventIdSimN = 0; EventIdSimN < EventIdSimV.Len(); EventIdSimN++) {
1053          const int SimEventId = EventIdSimV[EventIdSimN].Key;
1054          const double Sim = EventIdSimV[EventIdSimN].Dat;
1055          const double MxSim = EventIdSimV[0].Dat;
1056          const double Score = Sim / MxSim;
1057          if (EventIdScoreH.IsKey(SimEventId)) {
1058              const double OldScore = EventIdScoreH.GetDat(SimEventId);
1059              EventIdScoreH.GetDat(SimEventId) = TFlt::GetMx(OldScore, Score);
1060              EventIdTypeH.GetDat(SimEventId) = "Text";
1061          } else {
1062              EventIdScoreH.AddDat(SimEventId, Score);
1063              EventIdTypeH.AddDat(SimEventId, "Text");
1064          }
1065      }
1066      TFltIntKdV ScoreEventIdV;
1067      int EventKeyId = EventIdScoreH.FFirstKeyId();
1068      while (EventIdScoreH.FNextKeyId(EventKeyId)) {
1069          const int EventId = EventIdScoreH.GetKey(EventKeyId);
1070          const double Score = EventIdScoreH[EventKeyId];
1071          ScoreEventIdV.Add(TFltIntKd(Score, EventId));
1072      }
1073      ScoreEventIdV.Sort(false);
1074      GetSwitchedKdV<TFlt, TInt>(ScoreEventIdV, EventIdScoreV);
1075      CorrTypeV.Gen(EventIdScoreV.Len(), 0);
1076      for (int EventIdN = 0; EventIdN < EventIdScoreV.Len(); EventIdN++) {
1077          CorrTypeV.Add(EventIdTypeH.GetDat(EventIdScoreV[EventIdN].Key));
1078      }
1079  }
1080  void TBtaCorrBs::GetRootCauseStat(const PBtaEventBs& BtaEventBs, 
1081          const int& MxEvents, const int& MnSeverity, const int& RootCouseEventWnd, 
1082          const int64& RootCouseTimeWnd, const bool& PropP, const bool& TextP, 
1083          TIntV& AllScoresCountV, TIntV& ProbScoresCountV, TIntV& TextScoresCountV, 
1084          int& AllEvents) const {
1085      const int MxCount = 10;
1086      AllScoresCountV.Gen(MxCount); 
1087      ProbScoresCountV.Gen(MxCount);  
1088      TextScoresCountV.Gen(MxCount);  
1089      AllEvents = 0;
1090      TTmStopWatch AllSw, ProbSw, TextSw;
1091      int EventN = BtaEventBs->GetEvents();
1092      while (EventN > 0) {
1093          EventN--;
1094          const int Events = BtaEventBs->GetEvents() - EventN;
1095          if (Events % 100 == 0) { printf("%d\r", Events ); }
1096          if (Events >= MxEvents) { break; }
1097          const int EventSeverity = BtaEventBs->GetEvent(EventN).GetSeverity();
1098          if (EventSeverity < MnSeverity) { continue; }
1099          TIntFltKdV EventIdScoreV; TStrV CorrTypeV;
1100          if (PropP && TextP) {
1101              AllSw.Start();
1102              EventRootCause(BtaEventBs, EventN, RootCouseEventWnd, 
1103                  RootCouseTimeWnd, EventIdScoreV, CorrTypeV);
1104              AllSw.Stop();
1105          } else if (PropP) {
1106              ProbSw.Start();
1107              EventRootCauseProb(BtaEventBs, EventN, RootCouseEventWnd, 
1108                  RootCouseTimeWnd, EventIdScoreV);
1109              ProbSw.Stop();
1110              CorrTypeV.Gen(EventIdScoreV.Len());
1111              CorrTypeV.PutAll("Prob");
1112          } else if (TextP) {
1113              TextSw.Start();
1114              EventRootCauseText(BtaEventBs, EventN, RootCouseEventWnd, 
1115                  RootCouseTimeWnd, EventIdScoreV);
1116              TextSw.Stop();
1117              CorrTypeV.Gen(EventIdScoreV.Len());
1118              CorrTypeV.PutAll("Text");
1119          }
1120          const int AllCount = EventIdScoreV.Len();
1121          const int ProbCount = CorrTypeV.Count("Prob");
1122          const int TextCount = CorrTypeV.Count("Text");
1123          AllScoresCountV[TInt::GetMn(AllCount, MxCount-1)]++;
1124          ProbScoresCountV[TInt::GetMn(ProbCount, MxCount-1)]++;
1125          TextScoresCountV[TInt::GetMn(TextCount, MxCount-1)]++;
1126          AllEvents++;
1127      }
1128      printf("RootCauseStatTm: [a:%.2fs, p:%.2fs, t:%.2fs]\n", 
1129          AllSw.GetSec(), ProbSw.GetSec(), TextSw.GetSec());
1130  }
1131  void TBtaCorrBs::GetStat(const PBtaEventBs& BtaEventBs) const {
1132      TIntH SeverityH;
1133      TStrIntVH CaseIdEventVH;
1134      int CaseIds = 0;
1135      for (int EventN = 0; EventN < BtaEventBs->GetEvents(); EventN++) {
1136          const TBtaEvent& Event = BtaEventBs->GetEvent(EventN);
1137          if (EventN % 10000 == 0) { 
1138              printf("%10d / %d\r", EventN, BtaEventBs->GetEvents()); }
1139          if (Event.GetSeverity() != -1) {
1140              const int Severity = Event.GetSeverity();
1141              SeverityH.AddDat(Severity)++;
1142          }
1143          if (Event.GetCaseId() != -1) {
1144              TStr CaseNm = BtaEventBs->GetCase(Event.GetCaseId());
1145              CaseIdEventVH.AddDat(CaseNm).Add(EventN);
1146              CaseIds++;
1147          }
1148      } printf("\n");
1149      TIntPrV SeverityFqV; 
1150      SeverityH.GetKeyDatPrV(SeverityFqV);
1151      SeverityFqV.Sort();
1152      printf("Severity:\n");
1153      for (int SeverityN = 0; SeverityN < SeverityFqV.Len(); SeverityN++) {
1154          printf("  %d: %d\n", SeverityFqV[SeverityN].Val1.Val,
1155              SeverityFqV[SeverityN].Val2.Val);
1156      }
1157      printf("CaseIds: All=%d, Unique=%d\n", CaseIds, CaseIdEventVH.Len());
1158      PMom SeqDiff = TMom::New(), TmDiff = TMom::New(), CaseFq = TMom::New();
1159      int CaseIdKeyId = CaseIdEventVH.FFirstKeyId();
1160      while (CaseIdEventVH.FNextKeyId(CaseIdKeyId)) {
1161          const TIntV& EventV = CaseIdEventVH[CaseIdKeyId];
1162          for (int EventN = 1; EventN < EventV.Len(); EventN++) {
1163              const int EventId = EventV[EventN-1];
1164              const int CorrEventId = EventV[EventN];
1165              SeqDiff->Add(CorrEventId - EventId);
1166              const TBtaEvent& Event = BtaEventBs->GetEvent(EventId);
1167              const TBtaEvent& CorrEvent = BtaEventBs->GetEvent(CorrEventId);
1168              const uint64 TmDiffMSec = TTm::GetDiffMSecs(
1169                  Event.GetFirstTm(), CorrEvent.GetFirstTm());
1170              TmDiff->Add(int(TmDiffMSec/uint64(1000)));
1171          }
1172          CaseFq->Add(EventV.Len());
1173      }
1174      SeqDiff->Def(); TmDiff->Def(); CaseFq->Def();
1175      printf(" FQ: %.2f +/- %.2f [Min:%.0f Med:%.0f Max:%.0f]\n:", CaseFq->GetMean(), 
1176          CaseFq->GetSDev(), CaseFq->GetMn(), CaseFq->GetMedian(), CaseFq->GetMx());
1177      printf(" SD: %.2f +/- %.2f [Min:%.0f Med:%.0f Max:%.0f]\n:", SeqDiff->GetMean(), 
1178          SeqDiff->GetSDev(), SeqDiff->GetMn(), SeqDiff->GetMedian(), SeqDiff->GetMx());
1179      printf(" TD: %.2f +/- %.2f [Min:%.0f Med:%.0f Max:%.0f]\n:", TmDiff->GetMean(), 
1180          TmDiff->GetSDev(), TmDiff->GetMn(), TmDiff->GetMedian(), TmDiff->GetMx());
1181  }
1182  void TBtaLongProj::GetCountV(const TTm& StartDate, const TTm& BreakDate, 
1183          const TTm& EndDate, TIntH& IpNumIdH, TFltV& OldV, TFltV& NewV) const {
1184      IpNumIdH.Clr(); 
1185      {int DayKeyId = DayToIpNumIdFqVH.FFirstKeyId();
1186      while (DayToIpNumIdFqVH.FNextKeyId(DayKeyId)) {
1187          const TIntPrV& IpNumIdFqV = DayToIpNumIdFqVH[DayKeyId];
1188          for (int IpNumN = 0; IpNumN < IpNumIdFqV.Len(); IpNumN++) {
1189              IpNumIdH.AddKey(IpNumIdFqV[IpNumN].Val1);
1190          }
1191      }}
1192      const int IpNums = IpNumIdH.Len();
1193      OldV.Gen(IpNums); OldV.PutAll(1.0);   
1194      NewV.Gen(IpNums); NewV.PutAll(1.0);
1195      int OldTotalCount = IpNums, NewTotalCount = IpNums;
1196      {int DayKeyId = DayToIpNumIdFqVH.FFirstKeyId();
1197      while (DayToIpNumIdFqVH.FNextKeyId(DayKeyId)) {
1198          const int DateInt = DayToIpNumIdFqVH.GetKey(DayKeyId);
1199          TTm Date = TTm::GetTmFromDateTimeInt(DateInt);
1200          if (Date < StartDate || Date > EndDate) { continue; }
1201          const TIntPrV& IpNumIdFqV = DayToIpNumIdFqVH[DayKeyId];
1202          for (int IpNumN = 0; IpNumN < IpNumIdFqV.Len(); IpNumN++) {
1203              const int IpNumId = IpNumIdH.GetKeyId(IpNumIdFqV[IpNumN].Val1);
1204              const int IpNumFq = IpNumIdFqV[IpNumN].Val2;
1205              if (Date < BreakDate) { OldV[IpNumId] += double(IpNumFq); OldTotalCount++; }
1206              else { NewV[IpNumId] += double(IpNumFq); NewTotalCount++; }
1207          }
1208      }}
1209      int OldDayDiff = TTm::GetDiffDays(StartDate, BreakDate);
1210      int NewDayDiff = TTm::GetDiffDays(BreakDate, EndDate);
1211      IAssert(OldDayDiff > 0 && NewDayDiff > 0);
1212      double NormFact = double(NewDayDiff) / double(OldDayDiff);
1213      if (OldTotalCount > 0 && NewTotalCount > 0) {
1214          TLinAlg::MultiplyScalar(NormFact, OldV, OldV);
1215      } else {
1216          OldV.Clr(); NewV.Clr();
1217      }
1218  }
1219  void TBtaLongProj::AddEvent(const uint64& DateMSecs, const int& IpNumId) { 
1220      const int DateInt = TTm::GetDateIntFromTm(TTm::GetTmFromMSecs(DateMSecs));
1221      DayToIpNumIdFqHH.AddDat(DateInt).AddDat(IpNumId)++;
1222  }
1223  void TBtaLongProj::Def() {
1224      int DayKeyId = DayToIpNumIdFqHH.FFirstKeyId();
1225      while (DayToIpNumIdFqHH.FNextKeyId(DayKeyId)) {
1226          const int DayInt = DayToIpNumIdFqHH.GetKey(DayKeyId);
1227          TIntPrV& IpNumIdFqV = DayToIpNumIdFqVH.AddDat(DayInt);
1228          DayToIpNumIdFqHH[DayKeyId].GetKeyDatPrV(IpNumIdFqV);
1229          DayToIpNumIdFqHH[DayKeyId].Clr();
1230      }
1231      DayToIpNumIdFqHH.Clr();
1232  }
1233  void TBtaLongProj::Count(const TTm& StartDate, const TTm& BreakDate, 
1234          const TTm& EndDate, int& BeforeCount, int& AfterCount) const {
1235      BeforeCount = 0; AfterCount = 0;
1236      int DayKeyId = DayToIpNumIdFqVH.FFirstKeyId();
1237      while (DayToIpNumIdFqVH.FNextKeyId(DayKeyId)) {
1238          const int DateInt = DayToIpNumIdFqVH.GetKey(DayKeyId);
1239          TTm Date = TTm::GetTmFromDateTimeInt(DateInt);
1240          if (Date < StartDate || Date > EndDate) { continue; }
1241          int DayEvents = 0;
1242          const TIntPrV& IpNumIdFqV = DayToIpNumIdFqVH[DayKeyId];
1243          for (int IpNumIdN = 0; IpNumIdN < IpNumIdFqV.Len(); IpNumIdN++) {
1244              DayEvents += IpNumIdFqV[IpNumIdN].Val2; }
1245          if (Date < BreakDate) { BeforeCount += DayEvents; }
1246          else { AfterCount += DayEvents; }
1247      }
1248  }
1249  double TBtaLongProj::ChiSquare(const TTm& StartDate, 
1250          const TTm& BreakDate, const TTm& EndDate) const { 
1251      TIntH IpNumIdH; TFltV OldV, NewV; 
1252      GetCountV(StartDate, BreakDate, EndDate, IpNumIdH, OldV, NewV);
1253      if (OldV.Empty() || NewV.Empty()) { return 1.0; }
1254      double Val, Prb; TStatTest::ChiSquareOne(NewV, OldV, Val, Prb);
1255      return Prb;
1256  }
1257  bool TBtaLongProj::IsTrendPos(const TTm& StartDate, 
1258          const TTm& BreakDate, const TTm& EndDate) const {
1259      const double NormFact = GetNormFact(StartDate, BreakDate, EndDate);
1260      int BeforeCount, AfterCount; 
1261      Count(StartDate, BreakDate, EndDate, BeforeCount, AfterCount);
1262      const bool IsTrendPosP = ((NormFact * double(BeforeCount)) < AfterCount);
1263      return IsTrendPosP;
1264  }
1265  void TBtaLongProj::GetIpNumWgtV(const TTm& StartDate, const TTm& BreakDate, 
1266          const TTm& EndDate, TIntFltKdV& IpNumIdWgtV) const {
1267      TIntH IpNumIdH; TFltV OldV, NewV; 
1268      GetCountV(StartDate, BreakDate, EndDate, IpNumIdH, OldV, NewV);
1269      if (OldV.Empty() || NewV.Empty()) { IpNumIdWgtV.Clr(); return; }
1270      IAssert(OldV.Len() == NewV.Len());
1271      const int IpNumIds = OldV.Len(); TFltIntKdV IpNumWgtIdV;
1272      for (int IpNumIdN = 0; IpNumIdN < IpNumIds; IpNumIdN++){
1273          IAssert(OldV[IpNumIdN] > 0);
1274          const int IpNumId = IpNumIdH.GetKey(IpNumIdN);
1275          const double BinDiff = NewV[IpNumIdN] - OldV[IpNumIdN];
1276          const double ChiSquareVal = TMath::Sqr(BinDiff) / OldV[IpNumIdN];
1277          IpNumWgtIdV.Add(TFltIntKd(ChiSquareVal, IpNumId));
1278      }
1279      IpNumWgtIdV.Sort(false);
1280      GetSwitchedKdV<TFlt, TInt>(IpNumWgtIdV, IpNumIdWgtV);
1281  }
1282  double TBtaLongProj::GetNormFact(const TTm& StartDate, 
1283          const TTm& BreakDate, const TTm& EndDate) {
1284      int OldDayDiff = TTm::GetDiffDays(StartDate, BreakDate);
1285      int NewDayDiff = TTm::GetDiffDays(BreakDate, EndDate);
1286      IAssert(OldDayDiff > 0 && NewDayDiff > 0);
1287      return double(NewDayDiff) / double(OldDayDiff);;
1288  }
1289  TBtaLongBs::TBtaLongBs(const PBtaEventBs& BtaEventBs, 
1290          const PBtaCorrBs& BtaCorrBs, const int& MnSeverity) {
1291      printf("Trends over projects ...\n");
1292      const int Events = BtaEventBs->GetEvents(); int Skiped = 0;
1293      for (int EventN = 0; EventN < Events; EventN++) {
1294          const TBtaEvent& Event = BtaEventBs->GetEvent(EventN);
1295          if (EventN % 10000 == 0) { printf("%10d / %d [%d]\r", EventN, Events, Events-Skiped); }
1296          const int ProjId = Event.GetProjId();
1297          const int IpNumId = Event.GetIpNumId();
1298          if ((ProjId != -1) && (IpNumId != -1) && 
1299                  BtaCorrBs->IsIpNumId(IpNumId) &&
1300                  Event.GetSeverity() >= MnSeverity) {
1301              const uint64 DateMSecs = TTm::GetMSecsFromTm(Event.GetFirstTm());
1302              if (!ProjIdToProfileH.IsKey(ProjId)) {
1303                  ProjIdToProfileH.AddDat(ProjId, TBtaLongProj::New()); }
1304              ProjIdToProfileH.GetDat(ProjId)->AddEvent(DateMSecs, IpNumId);
1305          } else { 
1306              Skiped++; 
1307          }
1308      } printf("\n");
1309      printf("Summarizing ...");
1310      int ProjKeyId = ProjIdToProfileH.FFirstKeyId();
1311      while (ProjIdToProfileH.FNextKeyId(ProjKeyId)) {
1312          ProjIdToProfileH[ProjKeyId]->Def();
1313      }
1314      printf("\nDone\n");
1315  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-control.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-btalarms.cpp</div>
                </div>
                <div class="column column_space"><pre><code>621      bool b_valid_permuter = true, n_valid_permuter = true;
622      const int end_b = b < best_words->size() ? b + 1 : b;
623      const int end_n = n < new_words->size() ? n + 1 : n;
</pre></code></div>
                <div class="column column_space"><pre><code>679      const int IpNumIds = IpNumIdToEventVH.Len();
680      const int IpNumIdFq = IpNumIdToEventVH.IsKey(IpNumId) ?
681          CountEvents(IpNumIdToEventVH.GetDat(IpNumId), MxEventId) : 0;
682      const int CorrIpNumIdFq = IpNumIdToEventVH.IsKey(CorrIpNumId) ?
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    