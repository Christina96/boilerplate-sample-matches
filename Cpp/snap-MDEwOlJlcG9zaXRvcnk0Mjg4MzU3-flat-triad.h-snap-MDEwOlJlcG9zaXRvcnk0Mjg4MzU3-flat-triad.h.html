
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 43, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-triad.h</h3>
            <pre><code>1  #ifndef TRIAD_H
2  #define TRIAD_H
3  namespace TSnap {
4  template <class PGraph> double GetClustCf(const PGraph& Graph, int SampleNodes=-1);
5  template <class PGraph> double GetClustCf(const PGraph& Graph, TFltPrV& DegToCCfV, int SampleNodes=-1);
6  template <class PGraph> double GetClustCf(const PGraph& Graph, TFltPrV& DegToCCfV, int64& ClosedTriads, int64& OpenTriads, int SampleNodes=-1);
7  template <class PGraph> double GetClustCfAll(const PGraph& Graph, TFltPrV& DegToCCfV, int64& ClosedTriadsX, int64& OpenTriadsX, int SampleNodes=-1);
8  template <class PGraph> double GetNodeClustCf(const PGraph& Graph, const int& NId);
9  template <class PGraph> void GetNodeClustCf(const PGraph& Graph, TIntFltH& NIdCCfH);
10  template <class PGraph> int64 GetTriads(const PGraph& Graph, int SampleNodes=-1);
11  template <class PGraph> int64 GetTriads(const PGraph& Graph, int64& ClosedTriadsX, int64& OpenTriadsX, int SampleNodes);
12  template <class PGraph> int64 GetTriadsAll(const PGraph& Graph, int64& ClosedTriadsX, int64& OpenTriadsX, int SampleNodes=-1);
13  template <class PGraph> void GetTriads(const PGraph& Graph, TIntTrV& NIdCOTriadV, int SampleNodes=-1);
14  template <class PGraph> int GetTriadEdges(const PGraph& Graph, int SampleEdges=-1);
15  template <class PGraph> int GetNodeTriads(const PGraph& Graph, const int& NId);
16  template <class PGraph> int GetNodeTriads(const PGraph& Graph, const int& NId, int& ClosedNTriadsX, int& OpenNTriadsX);
17  template <class PGraph> int GetNodeTriadsAll(const PGraph& Graph, const int& NId, int& ClosedNTriadsX, int& OpenNTriadsX);
18  template <class PGraph>
19  int GetNodeTriads(const PGraph& Graph, const int& NId, const TIntSet& GroupSet, int& InGroupEdgesX, int& InOutGroupEdgesX, int& OutGroupEdgesX);
20  template <class PGraph> void GetTriadParticip(const PGraph& Graph, TIntPrV& TriadCntV);
21  template<class PGraph> int GetCmnNbrs(const PGraph& Graph, const int& NId1, const int& NId2);
22  template<class PGraph> int GetCmnNbrs(const PGraph& Graph, const int& NId1, const int& NId2, TIntV& NbrV);
23  template<class PGraph> int GetLen2Paths(const PGraph& Graph, const int& NId1, const int& NId2);
24  template<class PGraph> int GetLen2Paths(const PGraph& Graph, const int& NId1, const int& NId2, TIntV& NbrV);
25  template<class PGraph> int64 GetTriangleCnt(const PGraph& Graph);
26  template<class PGraph> void MergeNbrs(TIntV& NeighbourV, const typename PGraph::TObj::TNodeI& NI);
27  template <class PGraph> void GetUniqueNbrV(const PGraph& Graph, const int& NId, TIntV& NbrV);
28  int GetCommon(TIntV& A, TIntV& B);
29  template <class PGraph> double GetClustCf(const PGraph& Graph, int SampleNodes) {
30    TIntTrV NIdCOTriadV;
31    GetTriads(Graph, NIdCOTriadV, SampleNodes);
32    if (NIdCOTriadV.Empty()) { return 0.0; }
33    double SumCcf = 0.0;
34    for (int i = 0; i < NIdCOTriadV.Len(); i++) {
35      const double OpenCnt = NIdCOTriadV[i].Val2()+NIdCOTriadV[i].Val3();
36      if (OpenCnt > 0) {
37        SumCcf += NIdCOTriadV[i].Val2() / OpenCnt; }
38    }
39    IAssert(SumCcf>=0);
40    return SumCcf / double(NIdCOTriadV.Len());
41  }
42  template <class PGraph> double GetClustCf(const PGraph& Graph, TFltPrV& DegToCCfV, int SampleNodes) {
43    TIntTrV NIdCOTriadV;
44    GetTriads(Graph, NIdCOTriadV, SampleNodes);
45    if (NIdCOTriadV.Empty()) {
46      DegToCCfV.Clr(false);
47      return 0.0;
48    }
49    THash<TInt, TFltPr> DegSumCnt;
50    double SumCcf = 0.0;
51    for (int i = 0; i < NIdCOTriadV.Len(); i++) {
52      const int D = NIdCOTriadV[i].Val2()+NIdCOTriadV[i].Val3();
53      const double Ccf = D!=0 ? NIdCOTriadV[i].Val2() / double(D) : 0.0;
54      TFltPr& SumCnt = DegSumCnt.AddDat(Graph->GetNI(NIdCOTriadV[i].Val1).GetDeg());
55      SumCnt.Val1 += Ccf;
56      SumCnt.Val2 += 1;
57      SumCcf += Ccf;
58    }
59    DegToCCfV.Gen(DegSumCnt.Len(), 0);
60    for (int d = 0; d  < DegSumCnt.Len(); d++) {
61      DegToCCfV.Add(TFltPr(DegSumCnt.GetKey(d).Val, double(DegSumCnt[d].Val1()/DegSumCnt[d].Val2())));
62    }
63    DegToCCfV.Sort();
64    return SumCcf / double(NIdCOTriadV.Len());
65  }
66  template <class PGraph>
67  double GetClustCf(const PGraph& Graph, TFltPrV& DegToCCfV, int64& ClosedTriads, int64& OpenTriads, int SampleNodes) {
68    TIntTrV NIdCOTriadV;
69    GetTriads(Graph, NIdCOTriadV, SampleNodes);
70    if (NIdCOTriadV.Empty()) {
71      DegToCCfV.Clr(false);
72      ClosedTriads = 0;
73      OpenTriads = 0;
74      return 0.0;
75    }
76    THash<TInt, TFltPr> DegSumCnt;
77    double SumCcf = 0.0;
78    int64 closedTriads = 0;
79    int64 openTriads = 0;
80    for (int i = 0; i < NIdCOTriadV.Len(); i++) {
81      const int D = NIdCOTriadV[i].Val2()+NIdCOTriadV[i].Val3();
82      const double Ccf = D!=0 ? NIdCOTriadV[i].Val2() / double(D) : 0.0;
83      closedTriads += NIdCOTriadV[i].Val2;
84      openTriads += NIdCOTriadV[i].Val3;
85      TFltPr& SumCnt = DegSumCnt.AddDat(Graph->GetNI(NIdCOTriadV[i].Val1).GetDeg());
86      SumCnt.Val1 += Ccf;
<span onclick='openModal()' class='match'>87      SumCnt.Val2 += 1;
88      SumCcf += Ccf;
89    }
90    DegToCCfV.Gen(DegSumCnt.Len(), 0);
91    for (int d = 0; d  < DegSumCnt.Len(); d++) {
92      DegToCCfV.Add(TFltPr(DegSumCnt.GetKey(d).Val, DegSumCnt[d].Val1()/DegSumCnt[d].Val2()));
</span>93    }
94    ClosedTriads = closedTriads/int64(3); 
95    OpenTriads = openTriads;
96    DegToCCfV.Sort();
97    return SumCcf / double(NIdCOTriadV.Len());
98  }
99  template <class PGraph>
100  double GetClustCfAll(const PGraph& Graph, TFltPrV& DegToCCfV, int64& ClosedTriads, int64& OpenTriads, int SampleNodes) {
101    return GetClustCf(Graph, DegToCCfV, ClosedTriads, OpenTriads, SampleNodes);
102  }
103  template <class PGraph>
104  double GetNodeClustCf(const PGraph& Graph, const int& NId) {
105    int Open, Closed;
106    GetNodeTriads(Graph, NId, Open, Closed);
107    return (Open+Closed)==0 ? 0 : double(Open)/double(Open+Closed);
108  }
109  template <class PGraph>
110  void GetNodeClustCf(const PGraph& Graph, TIntFltH& NIdCCfH) {
111    TIntTrV NIdCOTriadV;
112    GetTriads(Graph, NIdCOTriadV);
113    NIdCCfH.Clr(false);
114    for (int i = 0; i < NIdCOTriadV.Len(); i++) {
115      const int D = NIdCOTriadV[i].Val2()+NIdCOTriadV[i].Val3();
116      const double CCf = D!=0 ? NIdCOTriadV[i].Val2() / double(D) : 0.0;
117      NIdCCfH.AddDat(NIdCOTriadV[i].Val1, CCf);
118    }
119  }
120  template <class PGraph>
121  int64 GetTriads(const PGraph& Graph, int SampleNodes) {
122    int64 OpenTriads, ClosedTriads;
123    return GetTriads(Graph, ClosedTriads, OpenTriads, SampleNodes);
124  }
125  template <class PGraph>
126  int64 GetTriads(const PGraph& Graph, int64& ClosedTriads, int64& OpenTriads, int SampleNodes) {
127    TIntTrV NIdCOTriadV;
128    GetTriads(Graph, NIdCOTriadV, SampleNodes);
129    uint64 closedTriads = 0;
130    uint64 openTriads = 0;
131    for (int i = 0; i < NIdCOTriadV.Len(); i++) {
132      closedTriads += NIdCOTriadV[i].Val2;
133      openTriads += NIdCOTriadV[i].Val3;
134    }
135    ClosedTriads = int64(closedTriads/3); 
136    OpenTriads = int64(openTriads);
137    return ClosedTriads;
138  }
139  template <class PGraph>
140  int64 GetTriadsAll(const PGraph& Graph, int64& ClosedTriads, int64& OpenTriads, int SampleNodes) {
141    return GetTriads(Graph, ClosedTriads, OpenTriads, SampleNodes);
142  }
143  template <class PGraph>
144  void GetTriads_v0(const PGraph& Graph, TIntTrV& NIdCOTriadV, int SampleNodes) {
145    const bool IsDir = Graph->HasFlag(gfDirected);
146    TIntSet NbrH;
147    TIntV NIdV;
148    TRnd Rnd(0);
149    Graph->GetNIdV(NIdV);
150    NIdV.Shuffle(Rnd);
151    if (SampleNodes == -1) {
152      SampleNodes = Graph->GetNodes(); }
153    NIdCOTriadV.Clr(false);
154    NIdCOTriadV.Reserve(SampleNodes);
155    for (int node = 0; node < SampleNodes; node++) {
156      typename PGraph::TObj::TNodeI NI = Graph->GetNI(NIdV[node]);
157      if (NI.GetDeg() < 2) {
158        NIdCOTriadV.Add(TIntTr(NI.GetId(), 0, 0)); 
159        continue;
160      }
161      NbrH.Clr(false);
162      for (int e = 0; e < NI.GetOutDeg(); e++) {
163        if (NI.GetOutNId(e) != NI.GetId()) {
164          NbrH.AddKey(NI.GetOutNId(e)); }
165      }
166      if (IsDir) {
167        for (int e = 0; e < NI.GetInDeg(); e++) {
168          if (NI.GetInNId(e) != NI.GetId()) {
169            NbrH.AddKey(NI.GetInNId(e)); }
170        }
171      }
172      int OpenCnt=0, CloseCnt=0;
173      for (int srcNbr = 0; srcNbr < NbrH.Len(); srcNbr++) {
174        const typename PGraph::TObj::TNodeI SrcNode = Graph->GetNI(NbrH.GetKey(srcNbr));
175        for (int dstNbr = srcNbr+1; dstNbr < NbrH.Len(); dstNbr++) {
176          const int dstNId = NbrH.GetKey(dstNbr);
177          if (SrcNode.IsNbrNId(dstNId)) { CloseCnt++; } 
178          else { OpenCnt++; }
179        }
180      }
181      IAssert(2*(OpenCnt+CloseCnt) == NbrH.Len()*(NbrH.Len()-1));
182      NIdCOTriadV.Add(TIntTr(NI.GetId(), CloseCnt, OpenCnt));
183    }
184  }
185  template <class PGraph>
186  void GetTriads(const PGraph& Graph, TIntTrV& NIdCOTriadV, int SampleNodes) {
187    const bool IsDir = Graph->HasFlag(gfDirected);
188    TIntSet NbrH;
189    TIntV NIdV;
190    TRnd Rnd(1);
191    int NNodes;
192    TIntV Nbrs;
193    int NId;
194    int64 hcount;
195    hcount = 0;
196    NNodes = Graph->GetNodes();
197    Graph->GetNIdV(NIdV);
198    NIdV.Shuffle(Rnd);
199    if (SampleNodes == -1) {
200      SampleNodes = NNodes;
201    }
202    int MxId = -1;
203    for (int i = 0; i < NNodes; i++) {
204      if (NIdV[i] > MxId) {
205        MxId = NIdV[i];
206      }
207    }
208    TVec<TIntV> NbrV(MxId + 1);
209    if (IsDir) {
210      for (int node = 0; node < NNodes; node++) {
211        int NId = NIdV[node];
212        NbrV[NId] = TIntV();
213        GetUniqueNbrV(Graph, NId, NbrV[NId]);
214      }
215    } else {
216      for (int node = 0; node < NNodes; node++) {
217        int NId = NIdV[node];
218        typename PGraph::TObj::TNodeI NI = Graph->GetNI(NId);
219        NbrV[NId] = TIntV();
220        NbrV[NId].Reserve(NI.GetOutDeg());
221        NbrV[NId].Reduce(0);
222        for (int i = 0; i < NI.GetOutDeg(); i++) {
223          NbrV[NId].Add(NI.GetOutNId(i));
224        }
225      }
226    }
227    NIdCOTriadV.Clr(false);
228    NIdCOTriadV.Reserve(SampleNodes);
229    for (int node = 0; node < SampleNodes; node++) {
230      typename PGraph::TObj::TNodeI NI = Graph->GetNI(NIdV[node]);
231      int NLen;
232      NId = NI.GetId();
233      hcount++;
234      if (NI.GetDeg() < 2) {
235        NIdCOTriadV.Add(TIntTr(NId, 0, 0)); 
236        continue;
237      }
238      Nbrs = NbrV[NId];
239      NLen = Nbrs.Len();
240      int OpenCnt1 = 0, CloseCnt1 = 0;
241      for (int srcNbr = 0; srcNbr < NLen; srcNbr++) {
242        int Count = GetCommon(NbrV[NbrV[NId][srcNbr]],Nbrs);
243        CloseCnt1 += Count;
244      }
245      CloseCnt1 /= 2;
246      OpenCnt1 = (NLen*(NLen-1))/2 - CloseCnt1;
247      NIdCOTriadV.Add(TIntTr(NId, CloseCnt1, OpenCnt1));
248    }
249  }
250  #if 0
251  template<class PGraph>
252  int64 CountTriangles(const PGraph& Graph) {
253    THash<TInt, TInt> H;
254    TIntV MapV;
255    int ind = 0;
256    for (typename PGraph::TObj::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++)   {
257      H.AddDat(NI.GetId(), ind);
258      MapV.Add(NI.GetId());
259      ind += 1;
260    }
261    TVec<TIntV> HigherDegNbrV(ind);
262  #ifdef USE_OPENMP
263  #pragma omp parallel for schedule(dynamic)
264  #endif
265    for (int i = 0; i < ind; i++) {
266      typename PGraph::TObj::TNodeI NI = Graph->GetNI(MapV[i]);
267      TIntV NbrV;
268      MergeNbrs<PGraph>(NbrV, NI);
269      TIntV V;
270      for (int j = 0; j < NbrV.Len(); j++) {
271        TInt Vert = NbrV[j];
272        TInt Deg = Graph->GetNI(Vert).GetDeg();
273        if (Deg > NI.GetDeg() ||
274           (Deg == NI.GetDeg() && Vert > NI.GetId())) {
275          V.Add(Vert);
276        }
277      }
278      HigherDegNbrV[i] = V;
279    }
280    int64 cnt = 0;
281  #ifdef USE_OPENMP
282  #pragma omp parallel for schedule(dynamic) reduction(+:cnt)
283  #endif
284    for (int i = 0; i < HigherDegNbrV.Len(); i++) {
285      for (int j = 0; j < HigherDegNbrV[i].Len(); j++) {
286        TInt NbrInd = H.GetDat(HigherDegNbrV[i][j]);
287        int64 num = GetCommon(HigherDegNbrV[i], HigherDegNbrV[NbrInd]);
288        cnt += num;
289      }
290    }
291    return cnt;
292  }
293  #endif
294  template<class PGraph>
295  int64 GetTriangleCnt(const PGraph& Graph) {
296    const int NNodes = Graph->GetNodes();
297    TIntV MapV(NNodes);
298    TVec<typename PGraph::TObj::TNodeI> NV(NNodes);
299    NV.Reduce(0);
300    int MxId = -1;
301    int ind = 0;
302    for (typename PGraph::TObj::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++)   {
303      NV.Add(NI);
304      int Id = NI.GetId();
305      if (Id > MxId) {
306        MxId = Id;
307      }
308      MapV[ind] = Id;
309      ind++;
310    }
311    TIntV IndV(MxId+1);
312    for (int j = 0; j < NNodes; j++) {
313      IndV[MapV[j]] = j;
314    }
315    ind = MapV.Len();
316    TVec<TIntV> HigherDegNbrV(ind);
317    for (int i = 0; i < ind; i++) {
318      HigherDegNbrV[i] = TVec<TInt>();
319      HigherDegNbrV[i].Reserve(NV[i].GetDeg());
320      HigherDegNbrV[i].Reduce(0);
321    }
322  #ifdef USE_OPENMP
323  #pragma omp parallel for schedule(dynamic)
324  #endif
325    for (int i = 0; i < ind; i++) {
326      typename PGraph::TObj::TNodeI NI = NV[i];
327      MergeNbrs<PGraph>(HigherDegNbrV[i], NI);
328      int k = 0;
329      for (int j = 0; j < HigherDegNbrV[i].Len(); j++) {
330        TInt Vert = HigherDegNbrV[i][j];
331        TInt Deg = NV[IndV[Vert]].GetDeg();
332        if (Deg > NI.GetDeg() ||
333           (Deg == NI.GetDeg() && Vert > NI.GetId())) {
334          HigherDegNbrV[i][k] = Vert;
335          k++;
336        }
337      }
338      HigherDegNbrV[i].Reduce(k);
339    }
340    int64 cnt = 0;
341  #ifdef USE_OPENMP
342  #pragma omp parallel for schedule(dynamic) reduction(+:cnt)
343  #endif
344    for (int i = 0; i < HigherDegNbrV.Len(); i++) {
345      for (int j = 0; j < HigherDegNbrV[i].Len(); j++) {
346        TInt NbrInd = IndV[HigherDegNbrV[i][j]];
347        int64 num = GetCommon(HigherDegNbrV[i], HigherDegNbrV[NbrInd]);
348        cnt += num;
349      }
350    }
351    return cnt;
352  }
353  template<class PGraph>
354  void MergeNbrs(TIntV& NeighbourV, const typename PGraph::TObj::TNodeI& NI) {
355    int j = 0;
356    int k = 0;
357    int prev = -1;
358    int indeg = NI.GetInDeg();
359    int outdeg = NI.GetOutDeg();
360    if (indeg > 0  &&  outdeg > 0) {
361      int v1 = NI.GetInNId(j);
362      int v2 = NI.GetOutNId(k);
363      while (1) {
364        if (v1 <= v2) {
365          if (prev != v1) {
366            NeighbourV.Add(v1);
367            prev = v1;
368          }
369          j += 1;
370          if (j >= indeg) {
371            break;
372          }
373          v1 = NI.GetInNId(j);
374        } else {
375          if (prev != v2) {
376            NeighbourV.Add(v2);
377            prev = v2;
378          }
379          k += 1;
380          if (k >= outdeg) {
381            break;
382          }
383          v2 = NI.GetOutNId(k);
384        }
385      }
386    }
387    while (j < indeg) {
388      int v = NI.GetInNId(j);
389      if (prev != v) {
390        NeighbourV.Add(v);
391        prev = v;
392      }
393      j += 1;
394    }
395    while (k < outdeg) {
396      int v = NI.GetOutNId(k);
397      if (prev != v) {
398        NeighbourV.Add(v);
399        prev = v;
400      }
401      k += 1;
402    }
403  }
404  template <class PGraph>
405  int GetTriadEdges(const PGraph& Graph, int SampleEdges) {
406    const bool IsDir = Graph->HasFlag(gfDirected);
407    TIntSet NbrH;
408    int TriadEdges = 0;
409    for(typename PGraph::TObj::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++) {
410      NbrH.Clr(false);
411      for (int e = 0; e < NI.GetOutDeg(); e++) {
412        if (NI.GetOutNId(e) != NI.GetId()) {
413          NbrH.AddKey(NI.GetOutNId(e)); }
414      }
415      if (IsDir) {
416        for (int e = 0; e < NI.GetInDeg(); e++) {
417          if (NI.GetInNId(e) != NI.GetId()) {
418            NbrH.AddKey(NI.GetInNId(e)); }
419        }
420      }
421      for (int e = 0; e < NI.GetOutDeg(); e++) {
422        if (!IsDir && NI.GetId()<NI.GetOutNId(e)) { continue; } 
423        const typename PGraph::TObj::TNodeI SrcNode = Graph->GetNI(NI.GetOutNId(e));
424        bool Triad=false;
425        for (int e1 = 0; e1 < SrcNode.GetOutDeg(); e1++) {
426          if (NbrH.IsKey(SrcNode.GetOutNId(e1))) { Triad=true; break; }
427        }
428        if (IsDir && ! Triad) {
429          for (int e1 = 0; e1 < SrcNode.GetInDeg(); e1++) {
430            if (NbrH.IsKey(SrcNode.GetInNId(e1))) { Triad=true; break; }
431          }
432        }
433        if (Triad) { TriadEdges++; }
434      }
435    }
436    return TriadEdges;
437  }
438  template <class PGraph>
439  int GetNodeTriads(const PGraph& Graph, const int& NId) {
440    int ClosedTriads=0, OpenTriads=0;
441    return GetNodeTriads(Graph, NId, ClosedTriads, OpenTriads);
442  }
443  template <class PGraph>
444  int GetNodeTriads(const PGraph& Graph, const int& NId, int& ClosedTriads, int& OpenTriads) {
445    const typename PGraph::TObj::TNodeI NI = Graph->GetNI(NId);
446    ClosedTriads=0;  OpenTriads=0;
447    if (NI.GetDeg() < 2) { return 0; }
448    TIntSet NbrSet(NI.GetDeg());
449    for (int e = 0; e < NI.GetOutDeg(); e++) {
450      if (NI.GetOutNId(e) != NI.GetId()) { 
451        NbrSet.AddKey(NI.GetOutNId(e)); }
452    }
453    if (Graph->HasFlag(gfDirected)) {
454      for (int e = 0; e < NI.GetInDeg(); e++) {
455        if (NI.GetInNId(e) != NI.GetId()) { 
456          NbrSet.AddKey(NI.GetInNId(e)); }
457      }
458    }
459    for (int srcNbr = 0; srcNbr < NbrSet.Len(); srcNbr++) {
460      const typename PGraph::TObj::TNodeI SrcNode = Graph->GetNI(NbrSet.GetKey(srcNbr));
461      for (int dstNbr = srcNbr+1; dstNbr < NbrSet.Len(); dstNbr++) {
462        const int dstNId = NbrSet.GetKey(dstNbr);
463        if (SrcNode.IsNbrNId(dstNId)) { ClosedTriads++; }
464        else { OpenTriads++; }
465      }
466    }
467    return ClosedTriads;
468  }
469  template <class PGraph>
470  int GetNodeTriadsAll(const PGraph& Graph, const int& NId, int& ClosedTriads, int& OpenTriads) {
471    return GetNodeTriads(Graph, NId, ClosedTriads, OpenTriads);
472  }
473  template <class PGraph>
474  int GetNodeTriads(const PGraph& Graph, const int& NId, const TIntSet& GroupSet, int& InGroupEdges, int& InOutGroupEdges, int& OutGroupEdges) {
475    const typename PGraph::TObj::TNodeI NI = Graph->GetNI(NId);
476    const bool IsDir = Graph->HasFlag(gfDirected);
477    InGroupEdges=0;  InOutGroupEdges=0;  OutGroupEdges=0;
478    if (NI.GetDeg() < 2) { return 0; }
479    TIntSet NbrSet(NI.GetDeg());
480    for (int e = 0; e < NI.GetOutDeg(); e++) {
481      if (NI.GetOutNId(e) != NI.GetId()) { 
482        NbrSet.AddKey(NI.GetOutNId(e)); }
483    }
484    if (IsDir) {
485      for (int e = 0; e < NI.GetInDeg(); e++) {
486        if (NI.GetInNId(e) != NI.GetId()) {
487          NbrSet.AddKey(NI.GetInNId(e)); }
488      }
489    }
490    for (int srcNbr = 0; srcNbr < NbrSet.Len(); srcNbr++) {
491      const int NbrId = NbrSet.GetKey(srcNbr);
492      const bool NbrIn = GroupSet.IsKey(NbrId);
493      const typename PGraph::TObj::TNodeI SrcNode = Graph->GetNI(NbrId);
494      for (int dstNbr = srcNbr+1; dstNbr < NbrSet.Len(); dstNbr++) {
495        const int DstNId = NbrSet.GetKey(dstNbr);
496        if (SrcNode.IsNbrNId(DstNId)) { 
497          bool DstIn = GroupSet.IsKey(DstNId);
498          if (NbrIn && DstIn) { InGroupEdges++; }
499          else if (NbrIn || DstIn) { InOutGroupEdges++; }
500          else { OutGroupEdges++; }
501        }
502      }
503    }
504    return InGroupEdges;
505  }
506  template <class PGraph>
507  void GetTriadParticip(const PGraph& Graph, TIntPrV& TriadCntV) {
508    TIntH TriadCntH;
509    for (typename PGraph::TObj::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++) {
510      const int Triads = GetNodeTriads(Graph, NI.GetId());
511      TriadCntH.AddDat(Triads) += 1;
512    }
513    TriadCntH.GetKeyDatPrV(TriadCntV);
514    TriadCntV.Sort();
515  }
516  template<class PGraph>
517  int GetCmnNbrs(const PGraph& Graph, const int& NId1, const int& NId2) {
518    TIntV NbrV;
519    return GetCmnNbrs(Graph, NId1, NId2, NbrV);
520  }
521  template<class PGraph>
522  int GetCmnNbrs(const PGraph& Graph, const int& NId1, const int& NId2, TIntV& NbrV) {
523    if (! Graph->IsNode(NId1) || ! Graph->IsNode(NId2)) { NbrV.Clr(false); return 0; }
524    typename PGraph::TObj::TNodeI NI1 = Graph->GetNI(NId1);
525    typename PGraph::TObj::TNodeI NI2 = Graph->GetNI(NId2);
526    NbrV.Clr(false);
527    NbrV.Reserve(TMath::Mn(NI1.GetDeg(), NI2.GetDeg()));
528    TIntSet NSet1(NI1.GetDeg()), NSet2(NI2.GetDeg());
529    for (int i = 0; i < NI1.GetDeg(); i++) {
530      const int nid = NI1.GetNbrNId(i);
531      if (nid!=NId1 && nid!=NId2) {
532        NSet1.AddKey(nid); }
533    }
534    for (int i = 0; i < NI2.GetDeg(); i++) {
535      const int nid = NI2.GetNbrNId(i);
536      if (NSet1.IsKey(nid)) {
537        NSet2.AddKey(nid);
538      }
539    }
540    NSet2.GetKeyV(NbrV);
541    return NbrV.Len();
542  }
543  template<>
544  inline int GetCmnNbrs<PUNGraph>(const PUNGraph& Graph, const int& NId1, const int& NId2, TIntV& NbrV) {
545    if (! Graph->IsNode(NId1) || ! Graph->IsNode(NId2)) { NbrV.Clr(false); return 0; }
546    const TUNGraph::TNodeI NI1 = Graph->GetNI(NId1);
547    const TUNGraph::TNodeI NI2 = Graph->GetNI(NId2);
548    int i=0, j=0;
549    NbrV.Clr(false);
550    NbrV.Reserve(TMath::Mn(NI1.GetDeg(), NI2.GetDeg()));
551    while (i < NI1.GetDeg() && j < NI2.GetDeg()) {
552      const int nid = NI1.GetNbrNId(i);
553      while (j < NI2.GetDeg() && NI2.GetNbrNId(j) < nid) { j++; }
554      if (j < NI2.GetDeg() && nid==NI2.GetNbrNId(j) && nid!=NId1 && nid!=NId2) {
555        IAssert(NbrV.Empty() || NbrV.Last() < nid);
556        NbrV.Add(nid);
557        j++;
558      }
559      i++;
560    }
561    return NbrV.Len();
562  }
563  template<class PGraph>
564  int GetLen2Paths(const PGraph& Graph, const int& NId1, const int& NId2) {
565    TIntV NbrV;
566    return GetLen2Paths(Graph, NId1, NId2, NbrV);
567  }
568  template<class PGraph>
569  int GetLen2Paths(const PGraph& Graph, const int& NId1, const int& NId2, TIntV& NbrV) {
570    const typename PGraph::TObj::TNodeI NI = Graph->GetNI(NId1);
571    NbrV.Clr(false);
572    NbrV.Reserve(NI.GetOutDeg());
573    for (int e = 0; e < NI.GetOutDeg(); e++) {
574      const typename PGraph::TObj::TNodeI MidNI = Graph->GetNI(NI.GetOutNId(e));
575      if (MidNI.IsOutNId(NId2)) {
576        NbrV.Add(MidNI.GetId());
577      }
578    }
579    return NbrV.Len();
580  }
581  template <class PGraph>
582  void GetUniqueNbrV(const PGraph& Graph, const int& NId, TIntV& NbrV) {
583    typename PGraph::TObj::TNodeI NI = Graph->GetNI(NId);
584    NbrV.Reserve(NI.GetDeg());
585    NbrV.Reduce(0);
586    int j = 0;
587    int k = 0;
588    int Prev = -1;
589    int InDeg = NI.GetInDeg();
590    int OutDeg = NI.GetOutDeg();
591    if (InDeg > 0  &&  OutDeg > 0) {
592      int v1 = NI.GetInNId(j);
593      int v2 = NI.GetOutNId(k);
594      while (1) {
595        if (v1 <= v2) {
596          if (Prev != v1) {
597            if (v1 != NId) {
598              NbrV.Add(v1);
599              Prev = v1;
600            }
601          }
602          j += 1;
603          if (j >= InDeg) {
604            break;
605          }
606          v1 = NI.GetInNId(j);
607        } else {
608          if (Prev != v2) {
609            if (v2 != NId) {
610              NbrV.Add(v2);
611            }
612            Prev = v2;
613          }
614          k += 1;
615          if (k >= OutDeg) {
616            break;
617          }
618          v2 = NI.GetOutNId(k);
619        }
620      }
621    }
622    while (j < InDeg) {
623      int v = NI.GetInNId(j);
624      if (Prev != v) {
625        if (v != NId) {
626          NbrV.Add(v);
627        }
628        Prev = v;
629      }
630      j += 1;
631    }
632    while (k < OutDeg) {
633      int v = NI.GetOutNId(k);
634      if (Prev != v) {
635        if (v != NId) {
636          NbrV.Add(v);
637        }
638        Prev = v;
639      }
640      k += 1;
641    }
642  }
643  }; 
644  template <class PGraph>
645  class TNetConstraint {
646  public:
647    PGraph Graph;
648    THash<TIntPr, TFlt> NodePrCH; 
649  public:
650    TNetConstraint(const PGraph& GraphPt, const bool& CalcaAll=true);
651    int Len() const { return NodePrCH.Len(); }
652    double GetC(const int& ConstraintN) const { return NodePrCH[ConstraintN]; }
653    TIntPr GetNodePr(const int& ConstraintN) const { return NodePrCH.GetKey(ConstraintN); }
654    double GetEdgeC(const int& NId1, const int& NId2) const;
655    double GetNodeC(const int& NId) const;
656    void AddConstraint(const int& NId1, const int& NId2);
657    void CalcConstraints();
658    void CalcConstraints(const int& NId);
659    void Dump() const;
660    static void Test();
661  };
662  template <class PGraph>
663  TNetConstraint<PGraph>::TNetConstraint(const PGraph& GraphPt, const bool& CalcaAll) : Graph(GraphPt) {
664    CAssert(! HasGraphFlag(typename PGraph::TObj, gfMultiGraph)); 
665    if (CalcaAll) {
666      CalcConstraints();
667    }
668  }
669  template <class PGraph>
670  double TNetConstraint<PGraph>::GetEdgeC(const int& NId1, const int& NId2) const {
671    if (NodePrCH.IsKey(TIntPr(NId1, NId2))) {
672      return NodePrCH.GetDat(TIntPr(NId1, NId2)); }
673    else {
674      return 0.0; }
675  }
676  template <class PGraph>
677  double TNetConstraint<PGraph>::GetNodeC(const int& NId) const {
678    typename PGraph::TObj::TNodeI NI1 = Graph->GetNI(NId);
679    if (NI1.GetOutDeg() == 0) { return 0.0; }
680    int KeyId = -1;
681    for (int k = 0; k<NI1.GetOutDeg(); k++) {
682      KeyId = NodePrCH.GetKeyId(TIntPr(NI1.GetId(), NI1.GetOutNId(k)));
683      if (KeyId > -1) { break; }
684    }
685    if (KeyId < 0) { return 0.0; }
686    double Constraint = NodePrCH[KeyId];
687    for (int i = KeyId-1; i >-1 && NodePrCH.GetKey(i).Val1()==NId; i--) {
688      Constraint += NodePrCH[i];
689    }
690    for (int i = KeyId+1; i < NodePrCH.Len() && NodePrCH.GetKey(i).Val1()==NId; i++) {
691      Constraint += NodePrCH[i];
692    }
693    return Constraint;
694  }
695  template <class PGraph>
696  void TNetConstraint<PGraph>::AddConstraint(const int& NId1, const int& NId2) {
697    if (NId1==NId2 || NodePrCH.IsKey(TIntPr(NId1, NId2))) {
698      return;
699    }
700    typename PGraph::TObj::TNodeI NI1 = Graph->GetNI(NId1);
701    double Constraint = 0.0;
702    if (NI1.IsOutNId(NId2)) { 
703      Constraint += 1.0/(double) NI1.GetOutDeg();
704    }
705    const double SrcC = 1.0/(double) NI1.GetOutDeg();
706    for (int e = 0; e < NI1.GetOutDeg(); e++) {
707      const int MidNId = NI1.GetOutNId(e);
708      if (MidNId == NId1 || MidNId == NId2) { continue; }
709      const typename PGraph::TObj::TNodeI MidNI = Graph->GetNI(MidNId);
710      if (MidNI.IsOutNId(NId2)) {
711        Constraint += SrcC * (1.0/(double)MidNI.GetOutDeg());
712      }
713    }
714    if (Constraint==0) { return; }
715    Constraint = TMath::Sqr(Constraint);
716    NodePrCH.AddDat(TIntPr(NId1, NId2), Constraint);
717  }
718  template <class PGraph>
719  void TNetConstraint<PGraph>::CalcConstraints() {
720    for (typename PGraph::TObj::TEdgeI EI = Graph->BegEI(); EI < Graph->EndEI(); EI++) {
721      AddConstraint(EI.GetSrcNId(), EI.GetDstNId());
722      AddConstraint(EI.GetDstNId(), EI.GetSrcNId());
723    }
724    for (typename PGraph::TObj::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++) {
725      for (int i = 0; i < NI.GetDeg();  i++) {
726        const int NId1 = NI.GetNbrNId(i);
727        for (int j = 0; j < NI.GetDeg();  j++) {
728          const int NId2 = NI.GetNbrNId(j);
729          AddConstraint(NId1, NId2);
730        }
731      }
732    }
733    NodePrCH.SortByKey();
734  }
735  template <class PGraph>
736  void TNetConstraint<PGraph>::CalcConstraints(const int& NId) {
737    typename PGraph::TObj::TNodeI StartNI = Graph->GetNI(NId);
738    TIntSet SeenSet;
739    for (int e = 0; e < StartNI.GetOutDeg(); e++) {
740      typename PGraph::TObj::TNodeI MidNI = Graph->GetNI(StartNI.GetOutNId(e));
741      AddConstraint(NId, MidNI.GetId());
742      for (int i = 0; i < MidNI.GetOutDeg();  i++) {
743        const int EndNId = MidNI.GetOutNId(i);
744        if (! SeenSet.IsKey(EndNId)) {
745          AddConstraint(NId, EndNId);
746          SeenSet.AddKey(EndNId);
747        }
748      }
749    }
750  }
751  template <class PGraph>
752  void TNetConstraint<PGraph>::Dump() const {
753    printf("Edge network constraint: (%d, %d)\n", Graph->GetNodes(), Graph->GetEdges());
754    for (int e = 0; e < NodePrCH.Len(); e++) {
755      printf("  %4d %4d  :  %f\n", NodePrCH.GetKey(e).Val1(), NodePrCH.GetKey(e).Val2(), NodePrCH[e].Val);
756    }
757    printf("\n");
758  }
759  template <class PGraph>
760  void TNetConstraint<PGraph>::Test() {
761    PUNGraph G = TUNGraph::New();
762    G->AddNode(0); G->AddNode(1); G->AddNode(2); G->AddNode(3);
763    G->AddNode(4); G->AddNode(5); G->AddNode(6);
764    G->AddEdge(0,1); G->AddEdge(0,2); G->AddEdge(0,3); G->AddEdge(0,4); G->AddEdge(0,5); G->AddEdge(0,6);
765    G->AddEdge(1,2); G->AddEdge(1,5);  G->AddEdge(1,6);
766    G->AddEdge(2,4);
767    TNetConstraint<PUNGraph> NetConstraint(G, true);
768    NetConstraint.Dump();
769    printf("middle node network constraint: %f\n", NetConstraint.GetNodeC(0));
770  }
771  #endif 
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-triad.h</h3>
            <pre><code>1  #ifndef TRIAD_H
2  #define TRIAD_H
3  namespace TSnap {
4  template <class PGraph> double GetClustCf(const PGraph& Graph, int SampleNodes=-1);
5  template <class PGraph> double GetClustCf(const PGraph& Graph, TFltPrV& DegToCCfV, int SampleNodes=-1);
6  template <class PGraph> double GetClustCf(const PGraph& Graph, TFltPrV& DegToCCfV, int64& ClosedTriads, int64& OpenTriads, int SampleNodes=-1);
7  template <class PGraph> double GetClustCfAll(const PGraph& Graph, TFltPrV& DegToCCfV, int64& ClosedTriadsX, int64& OpenTriadsX, int SampleNodes=-1);
8  template <class PGraph> double GetNodeClustCf(const PGraph& Graph, const int& NId);
9  template <class PGraph> void GetNodeClustCf(const PGraph& Graph, TIntFltH& NIdCCfH);
10  template <class PGraph> int64 GetTriads(const PGraph& Graph, int SampleNodes=-1);
11  template <class PGraph> int64 GetTriads(const PGraph& Graph, int64& ClosedTriadsX, int64& OpenTriadsX, int SampleNodes);
12  template <class PGraph> int64 GetTriadsAll(const PGraph& Graph, int64& ClosedTriadsX, int64& OpenTriadsX, int SampleNodes=-1);
13  template <class PGraph> void GetTriads(const PGraph& Graph, TIntTrV& NIdCOTriadV, int SampleNodes=-1);
14  template <class PGraph> int GetTriadEdges(const PGraph& Graph, int SampleEdges=-1);
15  template <class PGraph> int GetNodeTriads(const PGraph& Graph, const int& NId);
16  template <class PGraph> int GetNodeTriads(const PGraph& Graph, const int& NId, int& ClosedNTriadsX, int& OpenNTriadsX);
17  template <class PGraph> int GetNodeTriadsAll(const PGraph& Graph, const int& NId, int& ClosedNTriadsX, int& OpenNTriadsX);
18  template <class PGraph>
19  int GetNodeTriads(const PGraph& Graph, const int& NId, const TIntSet& GroupSet, int& InGroupEdgesX, int& InOutGroupEdgesX, int& OutGroupEdgesX);
20  template <class PGraph> void GetTriadParticip(const PGraph& Graph, TIntPrV& TriadCntV);
21  template<class PGraph> int GetCmnNbrs(const PGraph& Graph, const int& NId1, const int& NId2);
22  template<class PGraph> int GetCmnNbrs(const PGraph& Graph, const int& NId1, const int& NId2, TIntV& NbrV);
23  template<class PGraph> int GetLen2Paths(const PGraph& Graph, const int& NId1, const int& NId2);
24  template<class PGraph> int GetLen2Paths(const PGraph& Graph, const int& NId1, const int& NId2, TIntV& NbrV);
25  template<class PGraph> int64 GetTriangleCnt(const PGraph& Graph);
26  template<class PGraph> void MergeNbrs(TIntV& NeighbourV, const typename PGraph::TObj::TNodeI& NI);
27  template <class PGraph> void GetUniqueNbrV(const PGraph& Graph, const int& NId, TIntV& NbrV);
28  int GetCommon(TIntV& A, TIntV& B);
29  template <class PGraph> double GetClustCf(const PGraph& Graph, int SampleNodes) {
30    TIntTrV NIdCOTriadV;
31    GetTriads(Graph, NIdCOTriadV, SampleNodes);
32    if (NIdCOTriadV.Empty()) { return 0.0; }
33    double SumCcf = 0.0;
34    for (int i = 0; i < NIdCOTriadV.Len(); i++) {
35      const double OpenCnt = NIdCOTriadV[i].Val2()+NIdCOTriadV[i].Val3();
36      if (OpenCnt > 0) {
37        SumCcf += NIdCOTriadV[i].Val2() / OpenCnt; }
38    }
39    IAssert(SumCcf>=0);
40    return SumCcf / double(NIdCOTriadV.Len());
41  }
42  template <class PGraph> double GetClustCf(const PGraph& Graph, TFltPrV& DegToCCfV, int SampleNodes) {
43    TIntTrV NIdCOTriadV;
44    GetTriads(Graph, NIdCOTriadV, SampleNodes);
45    if (NIdCOTriadV.Empty()) {
46      DegToCCfV.Clr(false);
47      return 0.0;
48    }
49    THash<TInt, TFltPr> DegSumCnt;
50    double SumCcf = 0.0;
51    for (int i = 0; i < NIdCOTriadV.Len(); i++) {
52      const int D = NIdCOTriadV[i].Val2()+NIdCOTriadV[i].Val3();
53      const double Ccf = D!=0 ? NIdCOTriadV[i].Val2() / double(D) : 0.0;
54      TFltPr& SumCnt = DegSumCnt.AddDat(Graph->GetNI(NIdCOTriadV[i].Val1).GetDeg());
55      SumCnt.Val1 += Ccf;
<span onclick='openModal()' class='match'>56      SumCnt.Val2 += 1;
57      SumCcf += Ccf;
58    }
59    DegToCCfV.Gen(DegSumCnt.Len(), 0);
60    for (int d = 0; d  < DegSumCnt.Len(); d++) {
61      DegToCCfV.Add(TFltPr(DegSumCnt.GetKey(d).Val, double(DegSumCnt[d].Val1()/DegSumCnt[d].Val2())));
</span>62    }
63    DegToCCfV.Sort();
64    return SumCcf / double(NIdCOTriadV.Len());
65  }
66  template <class PGraph>
67  double GetClustCf(const PGraph& Graph, TFltPrV& DegToCCfV, int64& ClosedTriads, int64& OpenTriads, int SampleNodes) {
68    TIntTrV NIdCOTriadV;
69    GetTriads(Graph, NIdCOTriadV, SampleNodes);
70    if (NIdCOTriadV.Empty()) {
71      DegToCCfV.Clr(false);
72      ClosedTriads = 0;
73      OpenTriads = 0;
74      return 0.0;
75    }
76    THash<TInt, TFltPr> DegSumCnt;
77    double SumCcf = 0.0;
78    int64 closedTriads = 0;
79    int64 openTriads = 0;
80    for (int i = 0; i < NIdCOTriadV.Len(); i++) {
81      const int D = NIdCOTriadV[i].Val2()+NIdCOTriadV[i].Val3();
82      const double Ccf = D!=0 ? NIdCOTriadV[i].Val2() / double(D) : 0.0;
83      closedTriads += NIdCOTriadV[i].Val2;
84      openTriads += NIdCOTriadV[i].Val3;
85      TFltPr& SumCnt = DegSumCnt.AddDat(Graph->GetNI(NIdCOTriadV[i].Val1).GetDeg());
86      SumCnt.Val1 += Ccf;
87      SumCnt.Val2 += 1;
88      SumCcf += Ccf;
89    }
90    DegToCCfV.Gen(DegSumCnt.Len(), 0);
91    for (int d = 0; d  < DegSumCnt.Len(); d++) {
92      DegToCCfV.Add(TFltPr(DegSumCnt.GetKey(d).Val, DegSumCnt[d].Val1()/DegSumCnt[d].Val2()));
93    }
94    ClosedTriads = closedTriads/int64(3); 
95    OpenTriads = openTriads;
96    DegToCCfV.Sort();
97    return SumCcf / double(NIdCOTriadV.Len());
98  }
99  template <class PGraph>
100  double GetClustCfAll(const PGraph& Graph, TFltPrV& DegToCCfV, int64& ClosedTriads, int64& OpenTriads, int SampleNodes) {
101    return GetClustCf(Graph, DegToCCfV, ClosedTriads, OpenTriads, SampleNodes);
102  }
103  template <class PGraph>
104  double GetNodeClustCf(const PGraph& Graph, const int& NId) {
105    int Open, Closed;
106    GetNodeTriads(Graph, NId, Open, Closed);
107    return (Open+Closed)==0 ? 0 : double(Open)/double(Open+Closed);
108  }
109  template <class PGraph>
110  void GetNodeClustCf(const PGraph& Graph, TIntFltH& NIdCCfH) {
111    TIntTrV NIdCOTriadV;
112    GetTriads(Graph, NIdCOTriadV);
113    NIdCCfH.Clr(false);
114    for (int i = 0; i < NIdCOTriadV.Len(); i++) {
115      const int D = NIdCOTriadV[i].Val2()+NIdCOTriadV[i].Val3();
116      const double CCf = D!=0 ? NIdCOTriadV[i].Val2() / double(D) : 0.0;
117      NIdCCfH.AddDat(NIdCOTriadV[i].Val1, CCf);
118    }
119  }
120  template <class PGraph>
121  int64 GetTriads(const PGraph& Graph, int SampleNodes) {
122    int64 OpenTriads, ClosedTriads;
123    return GetTriads(Graph, ClosedTriads, OpenTriads, SampleNodes);
124  }
125  template <class PGraph>
126  int64 GetTriads(const PGraph& Graph, int64& ClosedTriads, int64& OpenTriads, int SampleNodes) {
127    TIntTrV NIdCOTriadV;
128    GetTriads(Graph, NIdCOTriadV, SampleNodes);
129    uint64 closedTriads = 0;
130    uint64 openTriads = 0;
131    for (int i = 0; i < NIdCOTriadV.Len(); i++) {
132      closedTriads += NIdCOTriadV[i].Val2;
133      openTriads += NIdCOTriadV[i].Val3;
134    }
135    ClosedTriads = int64(closedTriads/3); 
136    OpenTriads = int64(openTriads);
137    return ClosedTriads;
138  }
139  template <class PGraph>
140  int64 GetTriadsAll(const PGraph& Graph, int64& ClosedTriads, int64& OpenTriads, int SampleNodes) {
141    return GetTriads(Graph, ClosedTriads, OpenTriads, SampleNodes);
142  }
143  template <class PGraph>
144  void GetTriads_v0(const PGraph& Graph, TIntTrV& NIdCOTriadV, int SampleNodes) {
145    const bool IsDir = Graph->HasFlag(gfDirected);
146    TIntSet NbrH;
147    TIntV NIdV;
148    TRnd Rnd(0);
149    Graph->GetNIdV(NIdV);
150    NIdV.Shuffle(Rnd);
151    if (SampleNodes == -1) {
152      SampleNodes = Graph->GetNodes(); }
153    NIdCOTriadV.Clr(false);
154    NIdCOTriadV.Reserve(SampleNodes);
155    for (int node = 0; node < SampleNodes; node++) {
156      typename PGraph::TObj::TNodeI NI = Graph->GetNI(NIdV[node]);
157      if (NI.GetDeg() < 2) {
158        NIdCOTriadV.Add(TIntTr(NI.GetId(), 0, 0)); 
159        continue;
160      }
161      NbrH.Clr(false);
162      for (int e = 0; e < NI.GetOutDeg(); e++) {
163        if (NI.GetOutNId(e) != NI.GetId()) {
164          NbrH.AddKey(NI.GetOutNId(e)); }
165      }
166      if (IsDir) {
167        for (int e = 0; e < NI.GetInDeg(); e++) {
168          if (NI.GetInNId(e) != NI.GetId()) {
169            NbrH.AddKey(NI.GetInNId(e)); }
170        }
171      }
172      int OpenCnt=0, CloseCnt=0;
173      for (int srcNbr = 0; srcNbr < NbrH.Len(); srcNbr++) {
174        const typename PGraph::TObj::TNodeI SrcNode = Graph->GetNI(NbrH.GetKey(srcNbr));
175        for (int dstNbr = srcNbr+1; dstNbr < NbrH.Len(); dstNbr++) {
176          const int dstNId = NbrH.GetKey(dstNbr);
177          if (SrcNode.IsNbrNId(dstNId)) { CloseCnt++; } 
178          else { OpenCnt++; }
179        }
180      }
181      IAssert(2*(OpenCnt+CloseCnt) == NbrH.Len()*(NbrH.Len()-1));
182      NIdCOTriadV.Add(TIntTr(NI.GetId(), CloseCnt, OpenCnt));
183    }
184  }
185  template <class PGraph>
186  void GetTriads(const PGraph& Graph, TIntTrV& NIdCOTriadV, int SampleNodes) {
187    const bool IsDir = Graph->HasFlag(gfDirected);
188    TIntSet NbrH;
189    TIntV NIdV;
190    TRnd Rnd(1);
191    int NNodes;
192    TIntV Nbrs;
193    int NId;
194    int64 hcount;
195    hcount = 0;
196    NNodes = Graph->GetNodes();
197    Graph->GetNIdV(NIdV);
198    NIdV.Shuffle(Rnd);
199    if (SampleNodes == -1) {
200      SampleNodes = NNodes;
201    }
202    int MxId = -1;
203    for (int i = 0; i < NNodes; i++) {
204      if (NIdV[i] > MxId) {
205        MxId = NIdV[i];
206      }
207    }
208    TVec<TIntV> NbrV(MxId + 1);
209    if (IsDir) {
210      for (int node = 0; node < NNodes; node++) {
211        int NId = NIdV[node];
212        NbrV[NId] = TIntV();
213        GetUniqueNbrV(Graph, NId, NbrV[NId]);
214      }
215    } else {
216      for (int node = 0; node < NNodes; node++) {
217        int NId = NIdV[node];
218        typename PGraph::TObj::TNodeI NI = Graph->GetNI(NId);
219        NbrV[NId] = TIntV();
220        NbrV[NId].Reserve(NI.GetOutDeg());
221        NbrV[NId].Reduce(0);
222        for (int i = 0; i < NI.GetOutDeg(); i++) {
223          NbrV[NId].Add(NI.GetOutNId(i));
224        }
225      }
226    }
227    NIdCOTriadV.Clr(false);
228    NIdCOTriadV.Reserve(SampleNodes);
229    for (int node = 0; node < SampleNodes; node++) {
230      typename PGraph::TObj::TNodeI NI = Graph->GetNI(NIdV[node]);
231      int NLen;
232      NId = NI.GetId();
233      hcount++;
234      if (NI.GetDeg() < 2) {
235        NIdCOTriadV.Add(TIntTr(NId, 0, 0)); 
236        continue;
237      }
238      Nbrs = NbrV[NId];
239      NLen = Nbrs.Len();
240      int OpenCnt1 = 0, CloseCnt1 = 0;
241      for (int srcNbr = 0; srcNbr < NLen; srcNbr++) {
242        int Count = GetCommon(NbrV[NbrV[NId][srcNbr]],Nbrs);
243        CloseCnt1 += Count;
244      }
245      CloseCnt1 /= 2;
246      OpenCnt1 = (NLen*(NLen-1))/2 - CloseCnt1;
247      NIdCOTriadV.Add(TIntTr(NId, CloseCnt1, OpenCnt1));
248    }
249  }
250  #if 0
251  template<class PGraph>
252  int64 CountTriangles(const PGraph& Graph) {
253    THash<TInt, TInt> H;
254    TIntV MapV;
255    int ind = 0;
256    for (typename PGraph::TObj::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++)   {
257      H.AddDat(NI.GetId(), ind);
258      MapV.Add(NI.GetId());
259      ind += 1;
260    }
261    TVec<TIntV> HigherDegNbrV(ind);
262  #ifdef USE_OPENMP
263  #pragma omp parallel for schedule(dynamic)
264  #endif
265    for (int i = 0; i < ind; i++) {
266      typename PGraph::TObj::TNodeI NI = Graph->GetNI(MapV[i]);
267      TIntV NbrV;
268      MergeNbrs<PGraph>(NbrV, NI);
269      TIntV V;
270      for (int j = 0; j < NbrV.Len(); j++) {
271        TInt Vert = NbrV[j];
272        TInt Deg = Graph->GetNI(Vert).GetDeg();
273        if (Deg > NI.GetDeg() ||
274           (Deg == NI.GetDeg() && Vert > NI.GetId())) {
275          V.Add(Vert);
276        }
277      }
278      HigherDegNbrV[i] = V;
279    }
280    int64 cnt = 0;
281  #ifdef USE_OPENMP
282  #pragma omp parallel for schedule(dynamic) reduction(+:cnt)
283  #endif
284    for (int i = 0; i < HigherDegNbrV.Len(); i++) {
285      for (int j = 0; j < HigherDegNbrV[i].Len(); j++) {
286        TInt NbrInd = H.GetDat(HigherDegNbrV[i][j]);
287        int64 num = GetCommon(HigherDegNbrV[i], HigherDegNbrV[NbrInd]);
288        cnt += num;
289      }
290    }
291    return cnt;
292  }
293  #endif
294  template<class PGraph>
295  int64 GetTriangleCnt(const PGraph& Graph) {
296    const int NNodes = Graph->GetNodes();
297    TIntV MapV(NNodes);
298    TVec<typename PGraph::TObj::TNodeI> NV(NNodes);
299    NV.Reduce(0);
300    int MxId = -1;
301    int ind = 0;
302    for (typename PGraph::TObj::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++)   {
303      NV.Add(NI);
304      int Id = NI.GetId();
305      if (Id > MxId) {
306        MxId = Id;
307      }
308      MapV[ind] = Id;
309      ind++;
310    }
311    TIntV IndV(MxId+1);
312    for (int j = 0; j < NNodes; j++) {
313      IndV[MapV[j]] = j;
314    }
315    ind = MapV.Len();
316    TVec<TIntV> HigherDegNbrV(ind);
317    for (int i = 0; i < ind; i++) {
318      HigherDegNbrV[i] = TVec<TInt>();
319      HigherDegNbrV[i].Reserve(NV[i].GetDeg());
320      HigherDegNbrV[i].Reduce(0);
321    }
322  #ifdef USE_OPENMP
323  #pragma omp parallel for schedule(dynamic)
324  #endif
325    for (int i = 0; i < ind; i++) {
326      typename PGraph::TObj::TNodeI NI = NV[i];
327      MergeNbrs<PGraph>(HigherDegNbrV[i], NI);
328      int k = 0;
329      for (int j = 0; j < HigherDegNbrV[i].Len(); j++) {
330        TInt Vert = HigherDegNbrV[i][j];
331        TInt Deg = NV[IndV[Vert]].GetDeg();
332        if (Deg > NI.GetDeg() ||
333           (Deg == NI.GetDeg() && Vert > NI.GetId())) {
334          HigherDegNbrV[i][k] = Vert;
335          k++;
336        }
337      }
338      HigherDegNbrV[i].Reduce(k);
339    }
340    int64 cnt = 0;
341  #ifdef USE_OPENMP
342  #pragma omp parallel for schedule(dynamic) reduction(+:cnt)
343  #endif
344    for (int i = 0; i < HigherDegNbrV.Len(); i++) {
345      for (int j = 0; j < HigherDegNbrV[i].Len(); j++) {
346        TInt NbrInd = IndV[HigherDegNbrV[i][j]];
347        int64 num = GetCommon(HigherDegNbrV[i], HigherDegNbrV[NbrInd]);
348        cnt += num;
349      }
350    }
351    return cnt;
352  }
353  template<class PGraph>
354  void MergeNbrs(TIntV& NeighbourV, const typename PGraph::TObj::TNodeI& NI) {
355    int j = 0;
356    int k = 0;
357    int prev = -1;
358    int indeg = NI.GetInDeg();
359    int outdeg = NI.GetOutDeg();
360    if (indeg > 0  &&  outdeg > 0) {
361      int v1 = NI.GetInNId(j);
362      int v2 = NI.GetOutNId(k);
363      while (1) {
364        if (v1 <= v2) {
365          if (prev != v1) {
366            NeighbourV.Add(v1);
367            prev = v1;
368          }
369          j += 1;
370          if (j >= indeg) {
371            break;
372          }
373          v1 = NI.GetInNId(j);
374        } else {
375          if (prev != v2) {
376            NeighbourV.Add(v2);
377            prev = v2;
378          }
379          k += 1;
380          if (k >= outdeg) {
381            break;
382          }
383          v2 = NI.GetOutNId(k);
384        }
385      }
386    }
387    while (j < indeg) {
388      int v = NI.GetInNId(j);
389      if (prev != v) {
390        NeighbourV.Add(v);
391        prev = v;
392      }
393      j += 1;
394    }
395    while (k < outdeg) {
396      int v = NI.GetOutNId(k);
397      if (prev != v) {
398        NeighbourV.Add(v);
399        prev = v;
400      }
401      k += 1;
402    }
403  }
404  template <class PGraph>
405  int GetTriadEdges(const PGraph& Graph, int SampleEdges) {
406    const bool IsDir = Graph->HasFlag(gfDirected);
407    TIntSet NbrH;
408    int TriadEdges = 0;
409    for(typename PGraph::TObj::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++) {
410      NbrH.Clr(false);
411      for (int e = 0; e < NI.GetOutDeg(); e++) {
412        if (NI.GetOutNId(e) != NI.GetId()) {
413          NbrH.AddKey(NI.GetOutNId(e)); }
414      }
415      if (IsDir) {
416        for (int e = 0; e < NI.GetInDeg(); e++) {
417          if (NI.GetInNId(e) != NI.GetId()) {
418            NbrH.AddKey(NI.GetInNId(e)); }
419        }
420      }
421      for (int e = 0; e < NI.GetOutDeg(); e++) {
422        if (!IsDir && NI.GetId()<NI.GetOutNId(e)) { continue; } 
423        const typename PGraph::TObj::TNodeI SrcNode = Graph->GetNI(NI.GetOutNId(e));
424        bool Triad=false;
425        for (int e1 = 0; e1 < SrcNode.GetOutDeg(); e1++) {
426          if (NbrH.IsKey(SrcNode.GetOutNId(e1))) { Triad=true; break; }
427        }
428        if (IsDir && ! Triad) {
429          for (int e1 = 0; e1 < SrcNode.GetInDeg(); e1++) {
430            if (NbrH.IsKey(SrcNode.GetInNId(e1))) { Triad=true; break; }
431          }
432        }
433        if (Triad) { TriadEdges++; }
434      }
435    }
436    return TriadEdges;
437  }
438  template <class PGraph>
439  int GetNodeTriads(const PGraph& Graph, const int& NId) {
440    int ClosedTriads=0, OpenTriads=0;
441    return GetNodeTriads(Graph, NId, ClosedTriads, OpenTriads);
442  }
443  template <class PGraph>
444  int GetNodeTriads(const PGraph& Graph, const int& NId, int& ClosedTriads, int& OpenTriads) {
445    const typename PGraph::TObj::TNodeI NI = Graph->GetNI(NId);
446    ClosedTriads=0;  OpenTriads=0;
447    if (NI.GetDeg() < 2) { return 0; }
448    TIntSet NbrSet(NI.GetDeg());
449    for (int e = 0; e < NI.GetOutDeg(); e++) {
450      if (NI.GetOutNId(e) != NI.GetId()) { 
451        NbrSet.AddKey(NI.GetOutNId(e)); }
452    }
453    if (Graph->HasFlag(gfDirected)) {
454      for (int e = 0; e < NI.GetInDeg(); e++) {
455        if (NI.GetInNId(e) != NI.GetId()) { 
456          NbrSet.AddKey(NI.GetInNId(e)); }
457      }
458    }
459    for (int srcNbr = 0; srcNbr < NbrSet.Len(); srcNbr++) {
460      const typename PGraph::TObj::TNodeI SrcNode = Graph->GetNI(NbrSet.GetKey(srcNbr));
461      for (int dstNbr = srcNbr+1; dstNbr < NbrSet.Len(); dstNbr++) {
462        const int dstNId = NbrSet.GetKey(dstNbr);
463        if (SrcNode.IsNbrNId(dstNId)) { ClosedTriads++; }
464        else { OpenTriads++; }
465      }
466    }
467    return ClosedTriads;
468  }
469  template <class PGraph>
470  int GetNodeTriadsAll(const PGraph& Graph, const int& NId, int& ClosedTriads, int& OpenTriads) {
471    return GetNodeTriads(Graph, NId, ClosedTriads, OpenTriads);
472  }
473  template <class PGraph>
474  int GetNodeTriads(const PGraph& Graph, const int& NId, const TIntSet& GroupSet, int& InGroupEdges, int& InOutGroupEdges, int& OutGroupEdges) {
475    const typename PGraph::TObj::TNodeI NI = Graph->GetNI(NId);
476    const bool IsDir = Graph->HasFlag(gfDirected);
477    InGroupEdges=0;  InOutGroupEdges=0;  OutGroupEdges=0;
478    if (NI.GetDeg() < 2) { return 0; }
479    TIntSet NbrSet(NI.GetDeg());
480    for (int e = 0; e < NI.GetOutDeg(); e++) {
481      if (NI.GetOutNId(e) != NI.GetId()) { 
482        NbrSet.AddKey(NI.GetOutNId(e)); }
483    }
484    if (IsDir) {
485      for (int e = 0; e < NI.GetInDeg(); e++) {
486        if (NI.GetInNId(e) != NI.GetId()) {
487          NbrSet.AddKey(NI.GetInNId(e)); }
488      }
489    }
490    for (int srcNbr = 0; srcNbr < NbrSet.Len(); srcNbr++) {
491      const int NbrId = NbrSet.GetKey(srcNbr);
492      const bool NbrIn = GroupSet.IsKey(NbrId);
493      const typename PGraph::TObj::TNodeI SrcNode = Graph->GetNI(NbrId);
494      for (int dstNbr = srcNbr+1; dstNbr < NbrSet.Len(); dstNbr++) {
495        const int DstNId = NbrSet.GetKey(dstNbr);
496        if (SrcNode.IsNbrNId(DstNId)) { 
497          bool DstIn = GroupSet.IsKey(DstNId);
498          if (NbrIn && DstIn) { InGroupEdges++; }
499          else if (NbrIn || DstIn) { InOutGroupEdges++; }
500          else { OutGroupEdges++; }
501        }
502      }
503    }
504    return InGroupEdges;
505  }
506  template <class PGraph>
507  void GetTriadParticip(const PGraph& Graph, TIntPrV& TriadCntV) {
508    TIntH TriadCntH;
509    for (typename PGraph::TObj::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++) {
510      const int Triads = GetNodeTriads(Graph, NI.GetId());
511      TriadCntH.AddDat(Triads) += 1;
512    }
513    TriadCntH.GetKeyDatPrV(TriadCntV);
514    TriadCntV.Sort();
515  }
516  template<class PGraph>
517  int GetCmnNbrs(const PGraph& Graph, const int& NId1, const int& NId2) {
518    TIntV NbrV;
519    return GetCmnNbrs(Graph, NId1, NId2, NbrV);
520  }
521  template<class PGraph>
522  int GetCmnNbrs(const PGraph& Graph, const int& NId1, const int& NId2, TIntV& NbrV) {
523    if (! Graph->IsNode(NId1) || ! Graph->IsNode(NId2)) { NbrV.Clr(false); return 0; }
524    typename PGraph::TObj::TNodeI NI1 = Graph->GetNI(NId1);
525    typename PGraph::TObj::TNodeI NI2 = Graph->GetNI(NId2);
526    NbrV.Clr(false);
527    NbrV.Reserve(TMath::Mn(NI1.GetDeg(), NI2.GetDeg()));
528    TIntSet NSet1(NI1.GetDeg()), NSet2(NI2.GetDeg());
529    for (int i = 0; i < NI1.GetDeg(); i++) {
530      const int nid = NI1.GetNbrNId(i);
531      if (nid!=NId1 && nid!=NId2) {
532        NSet1.AddKey(nid); }
533    }
534    for (int i = 0; i < NI2.GetDeg(); i++) {
535      const int nid = NI2.GetNbrNId(i);
536      if (NSet1.IsKey(nid)) {
537        NSet2.AddKey(nid);
538      }
539    }
540    NSet2.GetKeyV(NbrV);
541    return NbrV.Len();
542  }
543  template<>
544  inline int GetCmnNbrs<PUNGraph>(const PUNGraph& Graph, const int& NId1, const int& NId2, TIntV& NbrV) {
545    if (! Graph->IsNode(NId1) || ! Graph->IsNode(NId2)) { NbrV.Clr(false); return 0; }
546    const TUNGraph::TNodeI NI1 = Graph->GetNI(NId1);
547    const TUNGraph::TNodeI NI2 = Graph->GetNI(NId2);
548    int i=0, j=0;
549    NbrV.Clr(false);
550    NbrV.Reserve(TMath::Mn(NI1.GetDeg(), NI2.GetDeg()));
551    while (i < NI1.GetDeg() && j < NI2.GetDeg()) {
552      const int nid = NI1.GetNbrNId(i);
553      while (j < NI2.GetDeg() && NI2.GetNbrNId(j) < nid) { j++; }
554      if (j < NI2.GetDeg() && nid==NI2.GetNbrNId(j) && nid!=NId1 && nid!=NId2) {
555        IAssert(NbrV.Empty() || NbrV.Last() < nid);
556        NbrV.Add(nid);
557        j++;
558      }
559      i++;
560    }
561    return NbrV.Len();
562  }
563  template<class PGraph>
564  int GetLen2Paths(const PGraph& Graph, const int& NId1, const int& NId2) {
565    TIntV NbrV;
566    return GetLen2Paths(Graph, NId1, NId2, NbrV);
567  }
568  template<class PGraph>
569  int GetLen2Paths(const PGraph& Graph, const int& NId1, const int& NId2, TIntV& NbrV) {
570    const typename PGraph::TObj::TNodeI NI = Graph->GetNI(NId1);
571    NbrV.Clr(false);
572    NbrV.Reserve(NI.GetOutDeg());
573    for (int e = 0; e < NI.GetOutDeg(); e++) {
574      const typename PGraph::TObj::TNodeI MidNI = Graph->GetNI(NI.GetOutNId(e));
575      if (MidNI.IsOutNId(NId2)) {
576        NbrV.Add(MidNI.GetId());
577      }
578    }
579    return NbrV.Len();
580  }
581  template <class PGraph>
582  void GetUniqueNbrV(const PGraph& Graph, const int& NId, TIntV& NbrV) {
583    typename PGraph::TObj::TNodeI NI = Graph->GetNI(NId);
584    NbrV.Reserve(NI.GetDeg());
585    NbrV.Reduce(0);
586    int j = 0;
587    int k = 0;
588    int Prev = -1;
589    int InDeg = NI.GetInDeg();
590    int OutDeg = NI.GetOutDeg();
591    if (InDeg > 0  &&  OutDeg > 0) {
592      int v1 = NI.GetInNId(j);
593      int v2 = NI.GetOutNId(k);
594      while (1) {
595        if (v1 <= v2) {
596          if (Prev != v1) {
597            if (v1 != NId) {
598              NbrV.Add(v1);
599              Prev = v1;
600            }
601          }
602          j += 1;
603          if (j >= InDeg) {
604            break;
605          }
606          v1 = NI.GetInNId(j);
607        } else {
608          if (Prev != v2) {
609            if (v2 != NId) {
610              NbrV.Add(v2);
611            }
612            Prev = v2;
613          }
614          k += 1;
615          if (k >= OutDeg) {
616            break;
617          }
618          v2 = NI.GetOutNId(k);
619        }
620      }
621    }
622    while (j < InDeg) {
623      int v = NI.GetInNId(j);
624      if (Prev != v) {
625        if (v != NId) {
626          NbrV.Add(v);
627        }
628        Prev = v;
629      }
630      j += 1;
631    }
632    while (k < OutDeg) {
633      int v = NI.GetOutNId(k);
634      if (Prev != v) {
635        if (v != NId) {
636          NbrV.Add(v);
637        }
638        Prev = v;
639      }
640      k += 1;
641    }
642  }
643  }; 
644  template <class PGraph>
645  class TNetConstraint {
646  public:
647    PGraph Graph;
648    THash<TIntPr, TFlt> NodePrCH; 
649  public:
650    TNetConstraint(const PGraph& GraphPt, const bool& CalcaAll=true);
651    int Len() const { return NodePrCH.Len(); }
652    double GetC(const int& ConstraintN) const { return NodePrCH[ConstraintN]; }
653    TIntPr GetNodePr(const int& ConstraintN) const { return NodePrCH.GetKey(ConstraintN); }
654    double GetEdgeC(const int& NId1, const int& NId2) const;
655    double GetNodeC(const int& NId) const;
656    void AddConstraint(const int& NId1, const int& NId2);
657    void CalcConstraints();
658    void CalcConstraints(const int& NId);
659    void Dump() const;
660    static void Test();
661  };
662  template <class PGraph>
663  TNetConstraint<PGraph>::TNetConstraint(const PGraph& GraphPt, const bool& CalcaAll) : Graph(GraphPt) {
664    CAssert(! HasGraphFlag(typename PGraph::TObj, gfMultiGraph)); 
665    if (CalcaAll) {
666      CalcConstraints();
667    }
668  }
669  template <class PGraph>
670  double TNetConstraint<PGraph>::GetEdgeC(const int& NId1, const int& NId2) const {
671    if (NodePrCH.IsKey(TIntPr(NId1, NId2))) {
672      return NodePrCH.GetDat(TIntPr(NId1, NId2)); }
673    else {
674      return 0.0; }
675  }
676  template <class PGraph>
677  double TNetConstraint<PGraph>::GetNodeC(const int& NId) const {
678    typename PGraph::TObj::TNodeI NI1 = Graph->GetNI(NId);
679    if (NI1.GetOutDeg() == 0) { return 0.0; }
680    int KeyId = -1;
681    for (int k = 0; k<NI1.GetOutDeg(); k++) {
682      KeyId = NodePrCH.GetKeyId(TIntPr(NI1.GetId(), NI1.GetOutNId(k)));
683      if (KeyId > -1) { break; }
684    }
685    if (KeyId < 0) { return 0.0; }
686    double Constraint = NodePrCH[KeyId];
687    for (int i = KeyId-1; i >-1 && NodePrCH.GetKey(i).Val1()==NId; i--) {
688      Constraint += NodePrCH[i];
689    }
690    for (int i = KeyId+1; i < NodePrCH.Len() && NodePrCH.GetKey(i).Val1()==NId; i++) {
691      Constraint += NodePrCH[i];
692    }
693    return Constraint;
694  }
695  template <class PGraph>
696  void TNetConstraint<PGraph>::AddConstraint(const int& NId1, const int& NId2) {
697    if (NId1==NId2 || NodePrCH.IsKey(TIntPr(NId1, NId2))) {
698      return;
699    }
700    typename PGraph::TObj::TNodeI NI1 = Graph->GetNI(NId1);
701    double Constraint = 0.0;
702    if (NI1.IsOutNId(NId2)) { 
703      Constraint += 1.0/(double) NI1.GetOutDeg();
704    }
705    const double SrcC = 1.0/(double) NI1.GetOutDeg();
706    for (int e = 0; e < NI1.GetOutDeg(); e++) {
707      const int MidNId = NI1.GetOutNId(e);
708      if (MidNId == NId1 || MidNId == NId2) { continue; }
709      const typename PGraph::TObj::TNodeI MidNI = Graph->GetNI(MidNId);
710      if (MidNI.IsOutNId(NId2)) {
711        Constraint += SrcC * (1.0/(double)MidNI.GetOutDeg());
712      }
713    }
714    if (Constraint==0) { return; }
715    Constraint = TMath::Sqr(Constraint);
716    NodePrCH.AddDat(TIntPr(NId1, NId2), Constraint);
717  }
718  template <class PGraph>
719  void TNetConstraint<PGraph>::CalcConstraints() {
720    for (typename PGraph::TObj::TEdgeI EI = Graph->BegEI(); EI < Graph->EndEI(); EI++) {
721      AddConstraint(EI.GetSrcNId(), EI.GetDstNId());
722      AddConstraint(EI.GetDstNId(), EI.GetSrcNId());
723    }
724    for (typename PGraph::TObj::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++) {
725      for (int i = 0; i < NI.GetDeg();  i++) {
726        const int NId1 = NI.GetNbrNId(i);
727        for (int j = 0; j < NI.GetDeg();  j++) {
728          const int NId2 = NI.GetNbrNId(j);
729          AddConstraint(NId1, NId2);
730        }
731      }
732    }
733    NodePrCH.SortByKey();
734  }
735  template <class PGraph>
736  void TNetConstraint<PGraph>::CalcConstraints(const int& NId) {
737    typename PGraph::TObj::TNodeI StartNI = Graph->GetNI(NId);
738    TIntSet SeenSet;
739    for (int e = 0; e < StartNI.GetOutDeg(); e++) {
740      typename PGraph::TObj::TNodeI MidNI = Graph->GetNI(StartNI.GetOutNId(e));
741      AddConstraint(NId, MidNI.GetId());
742      for (int i = 0; i < MidNI.GetOutDeg();  i++) {
743        const int EndNId = MidNI.GetOutNId(i);
744        if (! SeenSet.IsKey(EndNId)) {
745          AddConstraint(NId, EndNId);
746          SeenSet.AddKey(EndNId);
747        }
748      }
749    }
750  }
751  template <class PGraph>
752  void TNetConstraint<PGraph>::Dump() const {
753    printf("Edge network constraint: (%d, %d)\n", Graph->GetNodes(), Graph->GetEdges());
754    for (int e = 0; e < NodePrCH.Len(); e++) {
755      printf("  %4d %4d  :  %f\n", NodePrCH.GetKey(e).Val1(), NodePrCH.GetKey(e).Val2(), NodePrCH[e].Val);
756    }
757    printf("\n");
758  }
759  template <class PGraph>
760  void TNetConstraint<PGraph>::Test() {
761    PUNGraph G = TUNGraph::New();
762    G->AddNode(0); G->AddNode(1); G->AddNode(2); G->AddNode(3);
763    G->AddNode(4); G->AddNode(5); G->AddNode(6);
764    G->AddEdge(0,1); G->AddEdge(0,2); G->AddEdge(0,3); G->AddEdge(0,4); G->AddEdge(0,5); G->AddEdge(0,6);
765    G->AddEdge(1,2); G->AddEdge(1,5);  G->AddEdge(1,6);
766    G->AddEdge(2,4);
767    TNetConstraint<PUNGraph> NetConstraint(G, true);
768    NetConstraint.Dump();
769    printf("middle node network constraint: %f\n", NetConstraint.GetNodeC(0));
770  }
771  #endif 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-triad.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-triad.h</div>
                </div>
                <div class="column column_space"><pre><code>87      SumCnt.Val2 += 1;
88      SumCcf += Ccf;
89    }
90    DegToCCfV.Gen(DegSumCnt.Len(), 0);
91    for (int d = 0; d  < DegSumCnt.Len(); d++) {
92      DegToCCfV.Add(TFltPr(DegSumCnt.GetKey(d).Val, DegSumCnt[d].Val1()/DegSumCnt[d].Val2()));
</pre></code></div>
                <div class="column column_space"><pre><code>56      SumCnt.Val2 += 1;
57      SumCcf += Ccf;
58    }
59    DegToCCfV.Gen(DegSumCnt.Len(), 0);
60    for (int d = 0; d  < DegSumCnt.Len(); d++) {
61      DegToCCfV.Add(TFltPr(DegSumCnt.GetKey(d).Val, double(DegSumCnt[d].Val1()/DegSumCnt[d].Val2())));
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    