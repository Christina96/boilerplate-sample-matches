
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 5.935613682092555%, Tokens: 12</h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-sir.cpp</h3>
            <pre><code>1  #include "stdafx.h"
2  #include "sir.h"
3  void TEpidemModel::RunModel(const TFltV& StartValV, const double& StartT, const double& StopT, const int& NSteps, TVec<TFltV>& OutValV) {
4    TFltV ValV(StartValV), dydx(StartValV.Len()), ValV2(StartValV.Len());
5    OutValV.Clr(false);
6    for (int v = 0; v < StartValV.Len(); v++) {
7      OutValV.Add();
8      OutValV[v].Clr(false);
9      OutValV[v].Add(StartValV[v]);
10    }
11    const double h = (StopT-StartT) / NSteps;
12    double x = StartT;
13    for (int k = 0; k < NSteps; k++) {
14      GetDerivs(x, ValV, dydx);
15      RungeKutta(ValV, dydx, x, h, ValV2);
16      for (int v = 0; v < ValV2.Len(); v++) {
17        double X = ValV2[v];
18        if (X < 0 || _isnan(X) || !_finite(X)) { X = 0; }
19        OutValV[v].Add(X);
20      }
21      ValV = ValV2;
22      x += h;
23    }
24  }
25  void TEpidemModel::RunModel10(const TFltV& StartValV, const double& StartT, const double& StopT, const int& NSteps, TVec<TFltV>& OutValV) {
26    TFltV ValV(StartValV), dydx(StartValV.Len()), ValV2(StartValV.Len());
27    OutValV.Clr(false);
28    for (int v = 0; v < StartValV.Len(); v++) {
29      OutValV.Add();
30      OutValV[v].Clr(false);
31      OutValV[v].Add(StartValV[v]);
32    }
33    const double h = (StopT-StartT) / (10*NSteps);
34    double x = StartT;
35    for (int k = 0; k < 10*NSteps; k++) {
36      GetDerivs(x, ValV, dydx);
37      RungeKutta(ValV, dydx, x, h, ValV2);
38      if (k % 10 == 0) {
39        for (int v = 0; v < ValV2.Len(); v++) {
40          OutValV[v].Add(ValV2[v]); }
41      }
42      ValV = ValV2;
43      x += h;
44    }
45  }
46  void TEpidemModel::RunEuler(const TFltV& StartValV, const double& StartT, const double& StopT, const int& NSteps, TVec<TFltV>& OutValV) {
47    const double h = (StopT-StartT) / NSteps;
48    TFltV ValV(StartValV), dydx(StartValV.Len()), ValV2(StartValV.Len());
49    for (int v = 0; v < StartValV.Len(); v++) {
50      OutValV.Add();
51      OutValV[v].Clr(false);
52      OutValV[v].Add(StartValV[v]);
53    }
54    OutValV.Add(); 
55    OutValV.Last().Add(StartT);
56    for (double x = StartT; x <= StopT; x += h) {
57      GetDerivs(x, ValV, dydx);
58      for (int v = 0; v < ValV.Len(); v++) {
59        ValV[v] += h*dydx[v];
60        OutValV[v].Add(ValV[v]);
61      }
62      OutValV.Last().Add(x+h);
63    }
64    for (int v = 1; v < OutValV.Len(); v++) {
65      IAssert(OutValV[v].Len()==OutValV[v-1].Len());
66    }
67  }
68  void TEpidemModel::RungeKutta(const TFltV& y, const TFltV& dydx, double x, double h, TFltV& SirOutV) {
69    const int n = y.Len();
70    IAssert(y.Len() == n && dydx.Len() == n);
71    TFltV dym(n), dyt(n), yt(n);
72    int i;
73    double hh=h*0.5;
74    double h6=h/6.0;
75    double xh=x+hh;
76    for (i=0; i < n; i++) {
77      yt[i]=y[i]+hh*dydx[i];
78    }
79    GetDerivs(xh, yt, dyt);
80    for (i=0; i<n; i++) {
81      yt[i]=y[i]+hh*dyt[i];
82    }
83    GetDerivs(xh,yt,dym);
84    for (i=0; i<n; i++) {
85  	  yt[i]=y[i]+h*dym[i];
86  	  dym[i] += dyt[i];
87    }
88    GetDerivs(x+h,yt,dyt);
89    SirOutV.Clr(false);  
90    for (i=0; i<n; i++) {
91      SirOutV.Add(y[i]+h6 * (dydx[i]+dyt[i]+2.0*dym[i]));
92    }
93  }
94  double TEpidemModel::GetErr(const TFltV& TrueV, const TFltV& SimV, const int& SimT0) { 
95    if (SimV.Empty() || TrueV.Empty()) { return -1.0; }
96    double Err = 0.0;
97    double S=0;
98    for (int t=0; t < TrueV.Len(); t++) {
99      if (t-SimT0 >= 0) { S = SimV[t-SimT0]; } else { S = 0; }
100      Err += TMath::Sqr(TrueV[t]-S);
101    }
102    if (Err <= 0) { Err = TFlt::Mx; }
103    return Err;
104  }
105  void TEpidemModel::Plot(const TFltV& TrueV, const TStr& Label1, const TFltV& SimV, const TStr& Label2, const TStr& OutFNm, const TStr& Desc, const TStr& XLabel, const TStr& YLabel) {
106    TGnuPlot GP(OutFNm, Desc);
107    GP.AddPlot(TrueV, gpwLinesPoints, Label1);
108    GP.AddPlot(SimV, gpwLinesPoints, Label2);
109    GP.SetXYLabel(XLabel, YLabel);
110    GP.SavePng();
111  }
112  void TEpidemModel::LoadTxt(const TStr& InFNm, const int& ColId, TFltV& ValV) {
113    ValV.Clr();
114    if (! TFile::Exists(InFNm)) { 
115      printf("*** %s not found!\n", InFNm.CStr());
116      return; 
117    }
118    TSsParser Ss(InFNm, ssfTabSep);
119    while (Ss.Next()) {
120      ValV.Add(Ss.GetFlt(ColId));
121    }
122  }
123  TSirModel::TSirModel(double NZero, TFltTr NZeroP, double IZero, TFltTr IZeroP, double _Beta, TFltTr BetaP, double _Gamma, TFltTr GammaP, int TZero, TFltTr TZeroP, TStr InFNm, int ColId) :
124   N0(NZero), I0(IZero), Beta(_Beta), Gamma(_Gamma), T0(TZero) { 
125    ParamMnMnRngV.Add(NZeroP);
126    ParamMnMnRngV.Add(IZeroP);
127    ParamMnMnRngV.Add(BetaP);
128    ParamMnMnRngV.Add(GammaP);
129    ParamMnMnRngV.Add(TZeroP);
130    TEpidemModel::LoadTxt(InFNm, ColId, TrueInfectV); 
131  }
132  void TSirModel::GetParam(TFltV& ParamV) const { 
133    ParamV.Clr(false); 
134    ParamV.Add(N0);
135    ParamV.Add(I0);
136    ParamV.Add(Beta); 
137    ParamV.Add(Gamma); 
138    ParamV.Add(T0);
139  }
140  void TSirModel::SetParam(const TFltV& ParamV) { 
141    N0 = ParamV[0];
142    I0 = ParamV[1];
143    Beta = ParamV[2]; 
144    Gamma = ParamV[3]; 
145    T0 = int(ParamV[4]); 
146  }
147  void TSirModel::SetPeakT0() {
148    double Max =0;
149    int Peak=0;
150    for (int i = 0; i < TrueInfectV.Len(); i++) {
151      if (TrueInfectV[i] > Max) { 
152        Max=TrueInfectV[i]; 
153        Peak=i;
154      }
155    }
156    T0 = int(0.9*Peak);
157    ParamMnMnRngV[4].Val1 = Peak - 0.5*abs(Peak); 
158    ParamMnMnRngV[4].Val2 = Peak + 0.5*abs(Peak); 
159    printf("Set peak T0 = %d (%g -- %g)\n", Peak, ParamMnMnRngV[4].Val1, ParamMnMnRngV[4].Val2);
160  }
161  void TSirModel::GetDerivs(const double& T, const TFltV& SirValV, TFltV& dxdyV) {
162    dxdyV[0] = -Beta*SirValV[0]*SirValV[1];
163    dxdyV[1] = Beta*SirValV[0]*SirValV[1] - Gamma*SirValV[1];
164  }
165  double TSirModel::GetErr() const { 
166    return TEpidemModel::GetErr(TrueInfectV, OutValV[1], T0);
167  }
168  double TSirModel::RunCalcErr(const TFltV& ParamV) {
169    SetParam(ParamV);
170    const int EndT = TrueInfectV.Len() - T0 + 2;
171    RunModel(TFltV::GetV(N0-I0, I0), 0, EndT, EndT, OutValV);
172    return GetErr();
<span onclick='openModal()' class='match'>173  }
174  void TSirModel::GetParamRange(TFltTrV& ParamMnMxStepV) const {
175    ParamMnMxStepV = ParamMnMnRngV; 
176  }
177  void TSirModel::GetParamNmV(TStrV& ParamNmV) const {
178    ParamNmV = TStrV::GetV("Beta", "Gamma");
179  }
180  void TSirModel::Plot(const TStr& OutFNm, TStr Desc) const {
</span>181    if (OutValV.Empty()) { printf("EMPTY()");  return; }
182    TFltV V2;
183    for (int t=0; t < TrueInfectV.Len(); t++) {
184      if (t-T0 >= 0) { V2.Add(OutValV[1][t-T0]); } else { V2.Add(0); }
185    }
186    TEpidemModel::Plot(TrueInfectV, "TRUE", V2, "SIR model", OutFNm, Desc+" "+GetStr(), "Time", "Number of infected nodes");
187  }
188  void TSirModel::TestEurlerVsRk() {
189  }
190  TSir2Model::TSir2Model(double _N0M, TFltTr N0MP, double _I0M, TFltTr I0MP, double _N0B, TFltTr N0BP, double _I0B, TFltTr I0BP, 
191    int _T0, TFltTr T0P, double _BetaM, TFltTr BetaMP, double _GammaM, TFltTr GammaMP, double _BetaB, TFltTr BetaBP, double _GammaB, TFltTr GammaBP, 
192    double _BetaMB, TFltTr BetaMBP, double _BetaBM, TFltTr BetaBMP, TStr InFNm, int ColId1, int ColId2) : N0M(_N0M), I0M(_I0M), N0B(_N0B), I0B(_I0B), T0(_T0), BetaM(_BetaM), 
193    GammaM(_GammaM), BetaB(_BetaB), GammaB(_GammaB), BetaMB(_BetaMB), BetaBM(_BetaBM) { 
194    ParamMnMnRngV.Add(N0MP);
195    ParamMnMnRngV.Add(I0MP);
196    ParamMnMnRngV.Add(N0BP);
197    ParamMnMnRngV.Add(I0BP);
198    ParamMnMnRngV.Add(T0P);
199    ParamMnMnRngV.Add(BetaMP);
200    ParamMnMnRngV.Add(GammaMP);
201    ParamMnMnRngV.Add(BetaBP);
202    ParamMnMnRngV.Add(GammaBP);
203    ParamMnMnRngV.Add(BetaMBP);
204    ParamMnMnRngV.Add(BetaBMP);
205    if (InFNm.Len()>0 && TFile::Exists(InFNm)) {
206      TEpidemModel::LoadTxt(InFNm, ColId1, MediaV); 
207      TEpidemModel::LoadTxt(InFNm, ColId2, BlogV); 
208    }
209  }
210  void TSir2Model::GetParam(TFltV& ParamV) const { 
211    ParamV.Clr(false); 
212    ParamV.Add(N0M);
213    ParamV.Add(I0M);
214    ParamV.Add(N0B);
215    ParamV.Add(I0B);
216    ParamV.Add(T0);
217    ParamV.Add(BetaM);
218    ParamV.Add(GammaM);
219    ParamV.Add(BetaB);
220    ParamV.Add(GammaB);
221    ParamV.Add(BetaMB);
222    ParamV.Add(BetaBM);
223  }
224  void TSir2Model::SetParam(const TFltV& ParamV) { 
225    N0M = ParamV[0];
226    I0M = ParamV[1];
227    N0B = ParamV[2];
228    I0B = ParamV[3];
229    T0 = (int) ParamV[4];
230    BetaM = ParamV[5];
231    GammaM = ParamV[6];
232    BetaB = ParamV[7];
233    GammaB = ParamV[8];
234    BetaMB = ParamV[9];
235    BetaBM = ParamV[10];
236  }
237  TStr TSir2Model::GetStr() const { 
238    return TStr::Fmt("N0:%g %g  I0:%g %g  T0:%d  Beta:%g %g  Gamma:%g %g M-B:%g B-M:%g Err: %.2f", 
239      N0M, N0B, I0M, I0B, T0, BetaM, BetaB, GammaM, GammaB, BetaMB, BetaBM, GetErr()); 
240  }
241  void TSir2Model::SetPeakT0() {
242    double Max1=0, Max2=0;
243    int Peak1=0, Peak2=0;
244    for (int i = 0; i < MediaV.Len(); i++) {
245      if (MediaV[i] > Max1) { 
246        Max1 = MediaV[i]; Peak1 = i; }
247    }
248    for (int i = 0; i < BlogV.Len(); i++) {
249      if (BlogV[i] > Max2) { 
250        Max2 = BlogV[i]; Peak2 = i; }
251    }
252    int Peak = TMath::Mn(Peak1, Peak2);
253    T0 = int(0.9*Peak);
254    ParamMnMnRngV[4].Val1 = Peak - 0.5*Peak; 
255    ParamMnMnRngV[4].Val2 = TMath::Mx(Peak1, Peak2) + 0.5*TMath::Mx(Peak1, Peak2); 
256    printf("Set peak T0 = %d (%g -- %g) p1:%d p2:%d\n", 
257      Peak, ParamMnMnRngV[4].Val1, ParamMnMnRngV[4].Val2, Peak1, Peak2);
258  }
259  void TSir2Model::SetMediaBlogV(const TFltPrV& _MediaV, const TFltPrV& _BlogV) {
260    IAssert(_MediaV.Len() == _BlogV.Len());
261    MediaV.Clr(false);  BlogV.Clr(false);
262    for (int i = 0; i < _MediaV.Len(); i++) {
263      MediaV.Add(_MediaV[i].Val2);
264      BlogV.Add(_BlogV[i].Val2);
265    }
266  }
267  void TSir2Model::GetDerivs(const double& T, const TFltV& SirValV, TFltV& dxdyV) {
268    const TFlt& SM = SirValV[0];
269    const TFlt& SB = SirValV[1];
270    const TFlt& IM = SirValV[2];
271    const TFlt& IB = SirValV[3];
272    dxdyV[0] = -BetaM*IM*SM - BetaBM*IB*SM;
273    dxdyV[1] = -BetaB*IB*SB - BetaMB*IM*SB;
274    dxdyV[2] = BetaM*IM*SM + BetaBM*IB*SM - GammaM*IM;
275    dxdyV[3] = BetaB*IB*SB + BetaMB*IM*SB - GammaB*IB;
276  }
277  double TSir2Model::GetErr() const { 
278    return TEpidemModel::GetErr(MediaV, OutValV[2], T0) + TEpidemModel::GetErr(BlogV, OutValV[3], T0);
279  }
280  double TSir2Model::RunCalcErr(const TFltV& ParamV) {
281    SetParam(ParamV);
282    const int EndT = BlogV.Len() - T0 + 2;
283    RunModel(TFltV::GetV(N0M-I0M, N0B-I0B, I0M, I0B), 0, EndT, EndT, OutValV);
284    return GetErr();
285  }
286  void TSir2Model::GetParamRange(TFltTrV& ParamMnMxStepV) const {
287    ParamMnMxStepV = ParamMnMnRngV; 
288  }
289  void TSir2Model::GetParamNmV(TStrV& ParamNmV) const {
290    TStr("N0_media,I0_media,N0_blogs,I0_blogs,T0,BetaM,GammaM,BetaB,GammaB,BetaMB,BetaBM").SplitOnAllCh(',', ParamNmV);
291  }
292  void TSir2Model::Plot(const TStr& OutFNm, TStr Desc) const {
293    if (OutValV.Empty()) { printf("EMPTY()");  return; }
294    TFltV MV, BV;
295    const TFltV& SMediaV = OutValV[2];
296    for (int t=0; t < MediaV.Len(); t++) {
297      if (t-T0 >= 0) { MV.Add(SMediaV[t-T0]); } else { MV.Add(0); }
298    }
299    const TFltV& SBlogV = OutValV[3];
300    for (int t=0; t < BlogV.Len(); t++) {
301      if (t-T0 >= 0) { BV.Add(SBlogV[t-T0]); } else { BV.Add(0); }
302    }
303    TGnuPlot GP(OutFNm, Desc+" "+GetStr());
304    GP.AddPlot(MediaV, gpwLines, "TRUE MEDIA");
305    GP.AddPlot(MV, gpwLinesPoints, "SIM MEDIA");
306    GP.AddPlot(BlogV, gpwLines, "TRUE BLOGS");
307    GP.AddPlot(BV, gpwLinesPoints, "SIM BLOGS");
308    GP.SetXYLabel("Time [hours]", "Number of infected nodes");
309    GP.SavePng();
310  }
311  TSirSR2Model::TSirSR2Model(double _N0M, TFltTr N0MP, double _I0M, TFltTr I0MP, double _N0B, TFltTr N0BP, double _I0B, TFltTr I0BP, 
312   int _T0, TFltTr T0P, double _BetaM, TFltTr BetaMP, double _GammaM, TFltTr GammaMP, double _BetaB, TFltTr BetaBP, 
313   double _GammaB, TFltTr GammaBP, double _BetaMB, TFltTr BetaMBP, double _BetaBM, TFltTr BetaBMP, 
314   double _DeltaM, TFltTr DeltaMP, double _DeltaB, TFltTr DeltaBP, TStr InFNm, int ColId1, int ColId2) :  N0M(_N0M), I0M(_I0M), N0B(_N0B), 
315   I0B(_I0B), T0(_T0), BetaM(_BetaM), GammaM(_GammaM), BetaB(_BetaB), GammaB(_GammaB), BetaMB(_BetaMB), BetaBM(_BetaBM),
316   DeltaM(_DeltaM), DeltaB(DeltaB) { 
317    ParamMnMnRngV.Add(N0MP);
318    ParamMnMnRngV.Add(I0MP);
319    ParamMnMnRngV.Add(N0BP);
320    ParamMnMnRngV.Add(I0BP);
321    ParamMnMnRngV.Add(T0P);
322    ParamMnMnRngV.Add(BetaMP);
323    ParamMnMnRngV.Add(GammaMP);
324    ParamMnMnRngV.Add(BetaBP);
325    ParamMnMnRngV.Add(GammaBP);
326    ParamMnMnRngV.Add(BetaMBP);
327    ParamMnMnRngV.Add(BetaBMP);
328    ParamMnMnRngV.Add(DeltaMP);
329    ParamMnMnRngV.Add(DeltaBP);
330    if (InFNm.Len()>0 && TFile::Exists(InFNm)) {
331      TEpidemModel::LoadTxt(InFNm, ColId1, MediaV); 
332      TEpidemModel::LoadTxt(InFNm, ColId2, BlogV); 
333    }
334  }
335  void TSirSR2Model::GetParam(TFltV& ParamV) const { 
336    ParamV.Clr(false); 
337    ParamV.Add(N0M);
338    ParamV.Add(I0M);
339    ParamV.Add(N0B);
340    ParamV.Add(I0B);
341    ParamV.Add(T0);
342    ParamV.Add(BetaM);
343    ParamV.Add(GammaM);
344    ParamV.Add(BetaB);
345    ParamV.Add(GammaB);
346    ParamV.Add(BetaMB);
347    ParamV.Add(BetaBM);
348    ParamV.Add(DeltaM);
349    ParamV.Add(DeltaB);
350  }
351  void TSirSR2Model::SetParam(const TFltV& ParamV) { 
352    N0M = ParamV[0];
353    I0M = ParamV[1];
354    N0B = ParamV[2];
355    I0B = ParamV[3];
356    T0 = (int) ParamV[4];
357    BetaM = ParamV[5];
358    GammaM = ParamV[6];
359    BetaB = ParamV[7];
360    GammaB = ParamV[8];
361    BetaMB = ParamV[9];
362    BetaBM = ParamV[10];
363    DeltaM = ParamV[11];
364    DeltaB = ParamV[12];
365  }
366  TStr TSirSR2Model::GetStr() const { 
367    return TStr::Fmt("N0:%g %g  I0:%g %g  T0:%d  Beta:%g %g  Gamma:%g %g M-B:%g B-M:%g  Delta:%g %g    ERR: %.2f", 
368      N0M, N0B, I0M, I0B, T0, BetaM, BetaB, GammaM, GammaB, BetaMB, BetaBM, DeltaM, DeltaB, GetErr()); 
369  }
370  void TSirSR2Model::SetPeakT0() {
371    double Max1=0, Max2=0;
372    int Peak1=0, Peak2=0;
373    for (int i = 0; i < MediaV.Len(); i++) {
374      if (MediaV[i] > Max1) { 
375        Max1 = MediaV[i]; Peak1 = i; }
376    }
377    for (int i = 0; i < BlogV.Len(); i++) {
378      if (BlogV[i] > Max2) { 
379        Max2 = BlogV[i]; Peak2 = i; }
380    }
381    int Peak = TMath::Mn(Peak1, Peak2);
382    T0 = int(0.9*Peak);
383    ParamMnMnRngV[4].Val1 = Peak - 0.5*Peak; 
384    ParamMnMnRngV[4].Val2 = TMath::Mx(Peak1, Peak2) + 0.5*TMath::Mx(Peak1, Peak2); 
385    printf("Set peak T0 = %d (%g -- %g) p1:%d p2:%d\n", 
386      Peak, ParamMnMnRngV[4].Val1, ParamMnMnRngV[4].Val2, Peak1, Peak2);
387  }
388  void TSirSR2Model::SetMediaBlogV(const TFltPrV& _MediaV, const TFltPrV& _BlogV) {
389    IAssert(_MediaV.Len() == _BlogV.Len());
390    MediaV.Clr(false);  BlogV.Clr(false);
391    for (int i = 0; i < _MediaV.Len(); i++) {
392      MediaV.Add(_MediaV[i].Val2);
393      BlogV.Add(_BlogV[i].Val2);
394    }
395  }
396  void TSirSR2Model::GetDerivs(const double& T, const TFltV& SirValV, TFltV& dxdyV) {
397    const TFlt& SM = SirValV[0];
398    const TFlt& SB = SirValV[1];
399    const TFlt& IM = SirValV[2];
400    const TFlt& IB = SirValV[3];
401    dxdyV[0] = -BetaM*IM*SM - BetaBM*IB*SM - DeltaM*SM;
402    dxdyV[1] = -BetaB*IB*SB - BetaMB*IM*SB - DeltaB*SB;
403    dxdyV[2] = BetaM*IM*SM + BetaBM*IB*SM - GammaM*IM;
404    dxdyV[3] = BetaB*IB*SB + BetaMB*IM*SB - GammaB*IB;
405  }
406  double TSirSR2Model::GetErr() const { 
407    return TEpidemModel::GetErr(MediaV, OutValV[2], T0) + TEpidemModel::GetErr(BlogV, OutValV[3], T0);
408  }
409  double TSirSR2Model::RunCalcErr(const TFltV& ParamV) {
410    SetParam(ParamV);
411    const int EndT = BlogV.Len() - T0 + 2;
412    RunModel(TFltV::GetV(N0M-I0M, N0B-I0B, I0M, I0B), 0, EndT, EndT, OutValV);
413    return GetErr();
414  }
415  void TSirSR2Model::GetParamRange(TFltTrV& ParamMnMxStepV) const {
416    ParamMnMxStepV = ParamMnMnRngV; 
417  }
418  void TSirSR2Model::GetParamNmV(TStrV& ParamNmV) const {
419    TStr("N0_media,I0_media,N0_blogs,I0_blogs,T0,BetaM,GammaM,BetaB,GammaB,BetaMB,BetaBM,DeltaM,DeltaB").SplitOnAllCh(',', ParamNmV);
420  }
421  void TSirSR2Model::Plot(const TStr& OutFNm, TStr Desc) const {
422    if (OutValV.Empty()) { printf("EMPTY()");  return; }
423    TFltV MV, BV;
424    const TFltV& SMediaV = OutValV[2];
425    for (int t=0; t < MediaV.Len(); t++) {
426      if (t-T0 >= 0) { MV.Add(SMediaV[t-T0]); } else { MV.Add(0); }
427    }
428    const TFltV& SBlogV = OutValV[3];
429    for (int t=0; t < BlogV.Len(); t++) {
430      if (t-T0 >= 0) { BV.Add(SBlogV[t-T0]); } else { BV.Add(0); }
431    }
432    TGnuPlot GP(OutFNm, Desc+" "+GetStr());
433    GP.AddPlot(MediaV, gpwLines, "TRUE MEDIA");
434    GP.AddPlot(MV, gpwLinesPoints, "SIM MEDIA");
435    GP.AddPlot(BlogV, gpwLines, "TRUE BLOGS");
436    GP.AddPlot(BV, gpwLinesPoints, "SIM BLOGS");
437    GP.SetXYLabel("Time [hours]", "Number of infected nodes");
438    GP.SavePng();
439  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-bowbs.h</h3>
            <pre><code>1  ClassHdTP(TBowDocBs, PBowDocBs);
2  ClassTP(TBowKWordSet, PBowKWordSet)
3  private:
4    TStr Nm;
5    THash<TStr, TFlt> WStrToWWgtH;
6  public:
7    TBowKWordSet(const TStr& _Nm=""): Nm(_Nm), WStrToWWgtH(){}
8    static PBowKWordSet New(const TStr& Nm=""){return new TBowKWordSet(Nm);}
9    TBowKWordSet(const TBowKWordSet& BowKWordSet):
10      Nm(BowKWordSet.Nm), WStrToWWgtH(BowKWordSet.WStrToWWgtH){}
11    TBowKWordSet(TSIn& SIn): Nm(SIn), WStrToWWgtH(SIn){}
12    static PBowKWordSet Load(TSIn& SIn){return new TBowKWordSet(SIn);}
13    void Save(TSOut& SOut) const {Nm.Save(SOut); WStrToWWgtH.Save(SOut);}
14    TBowKWordSet& operator=(const TBowKWordSet& BowKWordSet){
15      Nm=BowKWordSet.Nm; WStrToWWgtH=BowKWordSet.WStrToWWgtH; return *this;}
16    void PutNm(const TStr& _Nm){Nm=_Nm;}
17    TStr GetNm() const {return Nm;}
18    void AddKWord(const TStr& KWordStr, const double& KWordWgt){
19      WStrToWWgtH.AddDat(KWordStr, KWordWgt);}
20    int GetKWords() const {return WStrToWWgtH.Len();}
21    bool IsKWordStr(const TStr& KWordStr) const {return WStrToWWgtH.IsKey(KWordStr);}
22    int GetKWordN(const TStr& KWordStr) const {return WStrToWWgtH.GetKeyId(KWordStr);}
23    TStr GetKWordStr(const int& KWordN) const {return WStrToWWgtH.GetKey(KWordN);}
24    double GetKWordWgt(const int& KWordN) const {return WStrToWWgtH[KWordN];}
25    void GetWordStrV(TStrV& WordStrV) const;
26    TStr GetKWordsStr() const;
27    void SortByStr();
28    void SortByWgt();
29    PBowKWordSet GetTopKWords(const int& MxKWords, const double& WgtSumPrc) const;
30    void SaveTxt(const PSOut& SOut) const;
31    void SaveTxt(const TStr& FNm) const {
32      PSOut SOut=TFOut::New(FNm); SaveTxt(SOut);}
33    void SaveXml(const PSOut& SOut) const;
34    void SaveXml(const TStr& FNm) const {
35      PSOut SOut=TFOut::New(FNm); SaveXml(SOut);}
36    void SaveBin(const PSOut& SOut) const {
37      Save(*SOut);}
38    void SaveBin(const TStr& FNm) const {
39      PSOut SOut=TFOut::New(FNm); SaveBin(SOut);}
40  };
41  ClassTP(TBowKWordBs, PBowKWordBs)
42  private:
43    THash<TStr, PBowKWordSet> SetNmToSetH;
44  public:
45    TBowKWordBs(): SetNmToSetH(){}
46    static PBowKWordBs New(){return new TBowKWordBs();}
47    TBowKWordBs(const TBowKWordBs& BowKWordBs):
48      SetNmToSetH(BowKWordBs.SetNmToSetH){}
49    TBowKWordBs(TSIn& SIn): SetNmToSetH(SIn){}
50    static PBowKWordBs Load(TSIn& SIn){return new TBowKWordBs(SIn);}
51    void Save(TSOut& SOut) const {SetNmToSetH.Save(SOut);}
52    TBowKWordBs& operator=(const TBowKWordBs& BowKWordBs){
53      SetNmToSetH=BowKWordBs.SetNmToSetH; return *this;}
54    void AddKWordSet(const TStr& KWordSetNm, const PBowKWordSet& KWordSet){
55      SetNmToSetH.AddDat(KWordSetNm, KWordSet);}
56    void AddKWordSet(const PBowKWordSet& KWordSet){
57      SetNmToSetH.AddDat(KWordSet->GetNm(), KWordSet);}
58    int GetKWordSets() const {return SetNmToSetH.Len();}
59    bool IsKWordSset(const TStr& KWordSetNm) const {return SetNmToSetH.IsKey(KWordSetNm);}
60    PBowKWordSet GetKWordSet(const int& KWordSetN) const {return SetNmToSetH[KWordSetN];}
61    PBowKWordSet GetKWordSet(const TStr& KWordSetNm) const {return SetNmToSetH.GetDat(KWordSetNm);}
62    void SaveTxt(const PSOut& SOut) const;
63    void SaveTxt(const TStr& FNm) const {
64      PSOut SOut=TFOut::New(FNm); SaveTxt(SOut);}
65    void SaveXml(const PSOut& SOut) const;
66    void SaveXml(const TStr& FNm) const {
67      PSOut SOut=TFOut::New(FNm); SaveXml(SOut);}
68    static PBowKWordBs LoadBin(const TStr& FNm){
69      TFIn SIn(FNm); return Load(SIn);}
70    void SaveBin(const PSOut& SOut) const {
71      Save(*SOut);}
72    void SaveBin(const TStr& FNm) const {
73      PSOut SOut=TFOut::New(FNm); SaveBin(SOut);}
74  };
75  typedef TIntSFltKd TBowWIdWgtKd;
76  typedef TBowWIdWgtKd* PBowWIdWgtKd;
77  typedef TVec<TBowWIdWgtKd> TBowWIdWgtKdV;
78  typedef TVec<TBowWIdWgtKdV> TBowWIdWgtKdVV;
79  ClassTPV(TBowSpV, PBowSpV, TBowSpVV)
80  private:
81    TInt DId;
82    TFlt Norm;
83    TBowWIdWgtKdV WIdWgtKdV;
84    UndefCopyAssign(TBowSpV);
85  public:
86    TBowSpV(const int& _DId=-1, const int& ExpWIds=0):
87      DId(_DId), Norm(-1), WIdWgtKdV(ExpWIds, 0){}
88    static PBowSpV New(const int& DId=-1, const int& ExpWIds=0){
89      return PBowSpV(new TBowSpV(DId, ExpWIds));}
90    TBowSpV(const int& DId, const TFltV& FullVec, const double& Eps=1e-14);
91    static PBowSpV New(const int& DId, const TFltV& FullVec,
92      const double& Eps=1e-14) { return PBowSpV(new TBowSpV(DId, FullVec, Eps));}
93    TBowSpV(const int& DId, const TIntFltKdV& SpV);
94    static PBowSpV New(const int& DId, const TIntFltKdV& SpV) {
95      return PBowSpV(new TBowSpV(DId, SpV));}
96    TBowSpV(TSIn& SIn):
97      DId(SIn), Norm(SIn), WIdWgtKdV(SIn){}
98    static PBowSpV Load(TSIn& SIn){return new TBowSpV(SIn);}
99    void Save(TSOut& SOut) const {
100      DId.Save(SOut); Norm.Save(SOut); WIdWgtKdV.Save(SOut);}
101    void Clr(){DId=-1; WIdWgtKdV.Clr();}
102    void GenMx(const int& MxWIds){WIdWgtKdV.Gen(MxWIds, 0);}
103    void Sort(){WIdWgtKdV.Sort();}
104    void Trunc(){WIdWgtKdV.Trunc();}
105    int Len() const {return WIdWgtKdV.Len();}
106    int Reserved() const {return WIdWgtKdV.Reserved();}
107    void PutDId(const int& _DId){DId=_DId;}
108    int GetDId() const {return DId;}
109    bool IsDId() const {return DId!=-1;}
110    PBowWIdWgtKd BegI() const {return WIdWgtKdV.BegI();}
111    PBowWIdWgtKd EndI() const {return WIdWgtKdV.EndI();}
112    PBowWIdWgtKd GetI(const int& ValN) const {return WIdWgtKdV.GetI(ValN);}
113    void AssignNorm(const double& _Norm){Norm=_Norm;}
114    void PutUnitNorm();
115    double GetNorm();
116    void AddWIdWgt(const int& WId, const double& Wgt){
117      WIdWgtKdV.Add(TBowWIdWgtKd(WId, (sdouble)Wgt));}
118    int GetWIds() const {return WIdWgtKdV.Len();}
119    int GetWIdN(const int& WId) const {return WIdWgtKdV.SearchForw(TBowWIdWgtKd(WId));}
120    bool IsWId(const int& WId) const {return WIdWgtKdV.SearchForw(TBowWIdWgtKd(WId))!=-1;}
121    int GetWId(const int& WIdN) const {return WIdWgtKdV[WIdN].Key;}
122    TSFlt& GetWgt(const int& WIdN){return WIdWgtKdV[WIdN].Dat;}
123    void GetWIdWgt(const int& WIdN, int& WId, double& Wgt) const {
124      const TBowWIdWgtKd& WIdWgtKd=WIdWgtKdV[WIdN];
125      WId=WIdWgtKd.Key; Wgt=WIdWgtKd.Dat;}
126    void GetWordStrWgtPrV(const PBowDocBs& BowDocBs,
127     const int& TopWords, const double& TopWordsWgtPrc,
128     TStrFltPrV& WordStrWgtPrV) const;
129    PBowKWordSet GetKWordSet(const PBowDocBs& BowDocBs) const;
130    int GetLastWId() const { return WIdWgtKdV.Last().Key; }
131    void GetIntFltKdV(TIntFltKdV& SpV) const;
132    void CutLowWgtWords(const double& CutWordWgtSumPrc);
133    TStr GetStr(const PBowDocBs& BowDocBs,
134     const int& TopWords=-1, const double& TopWordsWgtPrc=1, const TStr& SepStr=" ",
135     const bool& ShowWeightsP=true, const bool& KeepUndelineP=true) const;
136    void SaveTxt(const PSOut& SOut, const PBowDocBs& BowDocBs,
137     const int& TopWords=-1, const double& TopWordsWgtPrc=1,
138     const char& SepCh=' ') const;
139    void SaveXml(const PSOut& SOut, const PBowDocBs& BowDocBs) const;
140  };
141  ClassTP(TBowSimMtx, PBowSimMtx)
142  private:
143    TIntV MtxDIdV;
144    TIntPrFltH DIdPrToSimH;
145  public:
146    TBowSimMtx(): MtxDIdV(), DIdPrToSimH(){}
147    static PBowSimMtx New(){return new TBowSimMtx();}
148    TBowSimMtx(TSIn& SIn): MtxDIdV(SIn), DIdPrToSimH(SIn){}
149    static PBowSimMtx Load(TSIn& SIn){return new TBowSimMtx(SIn);}
150    void Save(TSOut& SOut) const {MtxDIdV.Save(SOut); DIdPrToSimH.Save(SOut);}
151    TBowSimMtx& operator=(const TBowSimMtx&){Fail; return *this;}
152    int GetDocs() const {return MtxDIdV.Len();}
153    int GetMtxDId(const int& MtxDIdN) const {return MtxDIdV[MtxDIdN];}
154    void GetDIdV(TIntV& _MtxDIdV) const {_MtxDIdV=MtxDIdV;}
155    double GetSim(const int& DId1, const int& DId2) const;
156    static PBowSimMtx LoadTxt(const TStr& FNm);
157  };
158  typedef enum {bstUndef, bstBlock, bstEucl, bstCos, bstMtx} TBowSimType;
159  ClassTP(TBowSim, PBowSim)
160  private:
161    TInt SimType; 
162    PBowSimMtx SimMtx;
163  public:
164    TBowSim(const TBowSimType& _Type=bstUndef, const PBowSimMtx& _SimMtx=NULL):
165      SimType(_Type), SimMtx(_SimMtx){}
166    static PBowSim New(const TBowSimType& SimType, const PBowSimMtx& SimMtx=NULL){
167      return new TBowSim(SimType, SimMtx);}
168    TBowSim(TSIn& SIn): SimType(SIn), SimMtx(SIn){}
169    static PBowSim Load(TSIn& SIn){return new TBowSim(SIn);}
170    void Save(TSOut& SOut) const {SimType.Save(SOut); SimMtx.Save(SOut);}
171    TBowSim& operator=(const TBowSim&){Fail; return *this;}
172    TBowSimType GetSimType() const {return TBowSimType(int(SimType));}
173    double GetSim(const int& DId1, const int& DId2) const;
174    double GetSim(const PBowSpV& SpV1, const PBowSpV& SpV2) const;
175    double GetSim(const TBowSpVV& SpVV1, const TBowSpVV& SpVV2) const;
176    static double GetBlockSim(const PBowSpV& SpV1, const PBowSpV& SpV2);
177    static double GetEuclSim(const PBowSpV& SpV1, const PBowSpV& SpV2);
178    static double GetCosSim(const PBowSpV& SpV1, const PBowSpV& SpV2);
179    static double GetCosSim(const PBowSpV& SpV1, const PBowSpV& SpV2,
180     TFltIntPrV& WgtWIdPrV);
181    static TBowSimType GetSimType(const TStr& Nm);
182  };
183  typedef enum {bwwtUndef,
184    bwwtEq, 
185    bwwtNrmEq, 
186    bwwtBin, 
187    bwwtNrmBin, 
188    bwwtNrm01, 
189    bwwtNrmTFIDF, 
190    bwwtLogDFNrmTFIDF, 
191    bwwtNrmTFICF, 
192    bwwtPreCalc, 
193    bwwtSvm 
194  } TBowWordWgtType;
195  ClassTP(TBowDocWgtBs, PBowDocWgtBs)
196  private:
197    TInt Sig; 
198    TInt BowDocBsSig; 
199    TInt WordWgtType;
200    TFlt CutWordWgtSumPrc;
201    TInt MnWordFq;
202    TIntV DIdV;
203    TFltV WordFqV;
204    TBowSpVV DocSpVV;
205  public:
206    TBowDocWgtBs(const int& _BowDocBsSig):
207      Sig(TSecTm::GetCurTm().GetAbsSecs()), BowDocBsSig(_BowDocBsSig),
208      WordWgtType(), CutWordWgtSumPrc(), MnWordFq(),
209      DIdV(), WordFqV(), DocSpVV(){}
210    static PBowDocWgtBs New(const int& BowDocBsSig){
211      return PBowDocWgtBs(new TBowDocWgtBs(BowDocBsSig));}
212    static PBowDocWgtBs New(
213     const PBowDocBs& BowDocBs, const TBowWordWgtType& _WordWgtType,
214     const double& _CutWordWgtSumPrc=0, const int& _MnWordFq=0,
215     const TIntV& _DIdV=TIntV(), const TIntV& BaseDIdV=TIntV(),
216     const PNotify& Notify=TNotify::NullNotify);
217    static PBowDocWgtBs New(const TVec<PBowSpV>& BowSpVV);
218    static PBowDocWgtBs NewPreCalcWgt(const PBowDocBs& BowDocBs,
219     const TFltV& WordWgtV, const bool& PutUniteNorm = false,
220     const double& _CutWordWgtSumPrc=0, const int& _MnWordFq=0,
221     const TIntV& _DIdV=TIntV());
222    static PBowDocWgtBs NewSvmWgt(
223     const PBowDocBs& BowDocBs,
224     const PBowDocWgtBs& BowDocWgtBs,
225     const TIntV& _TrainDIdV = TIntV(),
226     const double& SvmCostParam = 1.0,
227     const int& MxTimePerCat = 60,
228     const bool& NegFeaturesP = false,
229     const TIntV& _DIdV = TIntV(),
230     const bool& PutUniteNormP = false,
231     const double& _CutWordWgtSumPrc = 0.0,
232     const int& _MnWordFq = 0);
233    static PBowDocWgtBs NewBinSvmWgt(
234     const PBowDocBs& BowDocBs,
235     const PBowDocWgtBs& BowDocWgtBs,
236     const TStr& CatNm,
237     const TIntV& TrainDIdV = TIntV(),
238     const double& SvmCostParam = 1.0,
239     const double& SvmUnbalanceParam = 1.0,
240     const double& MnWgt = 0.0,
241     const bool& NegFeaturesP = false,
242     const bool& PutUniteNormP = true,
243     const bool& AvgNormalP = true,
244     const TIntV& _DIdV = TIntV(),
245     const double& _CutWordWgtSumPrc = 0.0,
246     const int& _MnWordFq = 0);
247    TBowDocWgtBs(TSIn& SIn):
248      Sig(SIn), BowDocBsSig(SIn),
249      WordWgtType(SIn), CutWordWgtSumPrc(SIn), MnWordFq(SIn),
250      DIdV(SIn), WordFqV(SIn), DocSpVV(SIn){}
251    static PBowDocWgtBs Load(TSIn& SIn){return new TBowDocWgtBs(SIn);}
252    void Save(TSOut& SOut) const {
253      Sig.Save(SOut); BowDocBsSig.Save(SOut);
254      WordWgtType.Save(SOut); CutWordWgtSumPrc.Save(SOut); MnWordFq.Save(SOut);
255      DIdV.Save(SOut); WordFqV.Save(SOut); DocSpVV.Save(SOut);}
256    TBowDocWgtBs& operator=(const TBowDocWgtBs& BowDocWgtBs){
257      Sig=BowDocWgtBs.Sig;
258      BowDocBsSig=BowDocWgtBs.BowDocBsSig;
259      WordWgtType=BowDocWgtBs.WordWgtType;
260      CutWordWgtSumPrc=BowDocWgtBs.CutWordWgtSumPrc;
261      MnWordFq=BowDocWgtBs.MnWordFq;
262      DIdV=BowDocWgtBs.DIdV;
263      WordFqV=BowDocWgtBs.WordFqV;
264      DocSpVV=BowDocWgtBs.DocSpVV;
265      return *this;}
266    PBowDocWgtBs GetSubSet(const TIntV& IdSubSet){
267      PBowDocWgtBs BowDocWgtBs=TBowDocWgtBs::New(BowDocBsSig);
268      *BowDocWgtBs=*this;
269      BowDocWgtBs->DIdV=IdSubSet;
270      return BowDocWgtBs;}
271    int GetSig() const {return Sig;}
272    int GetBowDocBsSig() const {return BowDocBsSig;}
273    TBowWordWgtType GetWordWgtType() const {
274      return TBowWordWgtType(int(WordWgtType));}
275    static TBowWordWgtType GetWordWgtTypeFromStr(const TStr& Nm);
276    double GetCutWordWgtSumPrc() const {return CutWordWgtSumPrc;}
277    int GetMnWordFq() const {return MnWordFq;}
278    int GetDocs() const {return DIdV.Len();}
279    int GetDId(const int& DIdN) const {return DIdV[DIdN];}
280    PBowSpV GetSpV(const int& DId) const {return DocSpVV[DId];}
<span onclick='openModal()' class='match'>281    void SetSpV(const int& DId, PBowSpV DocSpV) { DocSpVV[DId] = DocSpV; } 
282    void GetDIdV(TIntV& _DIdV) const {_DIdV=DIdV;}
283    void SetDIdV(const TIntV& _DIdV){DIdV=_DIdV;}
284    const TBowSpVV& GetDocSpVV() const { return DocSpVV; }
</span>285    int GetWords() const {return WordFqV.Len();}
286    double GetWordFq(const int& WId) const {return WordFqV[WId];}
287    void GetSimDIdV(
288     const PBowSpV& RefBowSpV, const PBowSim& BowSim,
289     TFltIntKdV& SimDIdKdV, const bool& RefBowSpVInclude=false) const;
290    void SaveTxtSimDIdV(
291     const PSOut& SOut, const PBowDocBs& BowDocBs,
292     const PBowSpV& RefBowSpV, const TFltIntKdV& SimDIdKdV,
293     const int& TopHits=-1, const double& MnSim=0, const int& TopDocWords=-1,
294     const char& SepCh=' ') const;
295    void SaveXmlSimDIdV(
296     const PSOut& SOut, const PBowDocBs& BowDocBs,
297     const PBowSpV& RefBowSpV, const TFltIntKdV& SimDIdKdV,
298     const int& TopHits=-1, const double& MnSim=0) const;
299    void SaveTxtStat(
300     const TStr& StatFNm, const PBowDocBs& BowDocBs,
301     const bool& SaveWordsP=true, const bool& SaveCatsP=true,
302     const bool& SaveDocsP=true) const;
303    static const TStr BowDocWgtBsFExt;
304    static PBowDocWgtBs LoadBin(const TStr& FNm){
305      TFIn SIn(FNm); return Load(SIn);}
306    void SaveBin(const TStr& FNm) const {
307      TFOut SOut(FNm); Save(SOut);}
308  };
309  class TBowWordDesc{
310  public:
311    TInt Fq;
312    TFlt MnVal;
313    TFlt MxVal;
314  public:
315    TBowWordDesc():
316      Fq(0), MnVal(0), MxVal(0){}
317    TBowWordDesc(const int& _Fq, const double& _MnVal, const double& _MxVal):
318      Fq(_Fq), MnVal(_MnVal), MxVal(_MxVal){}
319    TBowWordDesc(TSIn& SIn):
320      Fq(SIn), MnVal(SIn), MxVal(SIn){}
321    void Save(TSOut& SOut) const {
322      Fq.Save(SOut); MnVal.Save(SOut); MxVal.Save(SOut);}
323    TBowWordDesc& operator=(const TBowWordDesc& BowWordDesc){
324      Fq=BowWordDesc.Fq; MnVal=BowWordDesc.MnVal; MxVal=BowWordDesc.MxVal;
325      return *this;}
326    bool operator==(const TBowWordDesc& BowWordDesc) const {
327      return Fq==BowWordDesc.Fq;}
328    bool operator<(const TBowWordDesc& BowWordDesc) const {
329      return Fq<BowWordDesc.Fq;}
330  };
331  typedef TPair<TBowWordDesc, TStr> TBowWordDescStrPr;
332  typedef TVec<TBowWordDescStrPr> TBowWordDescStrPrV;
333  ClassTP(TBowDocBs, PBowDocBs)
334  private:
335    TInt Sig; 
336    PNGramBs NGramBs; 
337    PSwSet SwSet; 
338    PStemmer Stemmer; 
339    TStrStrH DocNmToDescStrH; 
340    THash<TStr, TBowWordDesc> WordStrToDescH; 
341    TStrIntH CatNmToFqH; 
342    TBowSpVV DocSpVV; 
343    TStrV DocStrV; 
344    TVec<TIntV> DocCIdVV; 
345    TIntV TrainDIdV; 
346    TIntV TestDIdV; 
347  public:
348    TBowDocBs():
349      Sig(TSecTm::GetCurTm().GetAbsSecs()),
350      NGramBs(), SwSet(), Stemmer(),
351      DocNmToDescStrH(), WordStrToDescH(), CatNmToFqH(),
352      DocSpVV(), DocStrV(), DocCIdVV(),
353      TrainDIdV(), TestDIdV(){}
354    static PBowDocBs New(){return new TBowDocBs();}
355    static PBowDocBs New(
356     const PSwSet& SwSet, const PStemmer& Stemmer, const PNGramBs& NGramBs);
357    TBowDocBs(TSIn& SIn):
358      Sig(SIn),
359      NGramBs(SIn), SwSet(SIn), Stemmer(SIn),
360      DocNmToDescStrH(SIn), WordStrToDescH(SIn), CatNmToFqH(SIn),
361      DocSpVV(SIn), DocStrV(SIn), DocCIdVV(SIn),
362      TrainDIdV(SIn), TestDIdV(SIn){}
363    static PBowDocBs Load(TSIn& SIn){return new TBowDocBs(SIn);}
364    void Save(TSOut& SOut) const {
365      Sig.Save(SOut);
366      NGramBs.Save(SOut); SwSet.Save(SOut); Stemmer.Save(SOut);
367      DocNmToDescStrH.Save(SOut); WordStrToDescH.Save(SOut); CatNmToFqH.Save(SOut);
368      DocSpVV.Save(SOut); DocStrV.Save(SOut); DocCIdVV.Save(SOut);
369      TrainDIdV.Save(SOut); TestDIdV.Save(SOut);}
370    TBowDocBs& operator=(const TBowDocBs& BowDocBs){
371      Sig=BowDocBs.Sig;
372      NGramBs=BowDocBs.NGramBs;
373      SwSet=BowDocBs.SwSet;
374      Stemmer=BowDocBs.Stemmer;
375      DocNmToDescStrH=BowDocBs.DocNmToDescStrH;
376      WordStrToDescH=BowDocBs.WordStrToDescH;
377      CatNmToFqH=BowDocBs.CatNmToFqH;
378      DocSpVV=BowDocBs.DocSpVV;
379      DocStrV=BowDocBs.DocStrV;
380      DocCIdVV=BowDocBs.DocCIdVV;
381      TrainDIdV=BowDocBs.TrainDIdV;
382      TestDIdV=BowDocBs.TestDIdV;
383      return *this;}
384    void AddDocs(const PBowDocBs& BowDocBs);
385    void AssertOk() const;
386    int GetSig() const {return Sig;}
387    void PutNGramBs(const PNGramBs& _NGramBs){NGramBs=_NGramBs;}
388    PNGramBs GetNGramBs() const {return NGramBs;}
389    void PutSwSet(const PSwSet& _SwSet){SwSet=_SwSet;}
390    PSwSet GetSwSet() const {return SwSet;}
391    void PutStemmer(const PStemmer& _Stemmer){Stemmer=_Stemmer;}
392    PStemmer GetStemmer() const {return Stemmer;}
393    int GetWords() const {return WordStrToDescH.Len();}
394    int AddWordStr(const TStr& WordStr){return WordStrToDescH.AddKey(WordStr);}
395    bool IsWordStr(const TStr& WordStr) const {
396      return WordStrToDescH.IsKey(WordStr);}
397    bool IsWordStr(const TStr& WordStr, int& WId) const {
398      return WordStrToDescH.IsKey(WordStr, WId);}
399    bool IsWId(const int& WId) const {
400      return WordStrToDescH.IsKeyId(WId);}
401    int GetWId(const TStr& WordStr) const {
402      return WordStrToDescH.GetKeyId(WordStr);}
403    TStr GetWordStr(const int& WId) const {
404      return WordStrToDescH.GetKey(WId);}
405    double GetWordMnVal(const int& WId) const {
406      return WordStrToDescH[WId].MnVal;}
407    double GetWordMxVal(const int& WId) const {
408      return WordStrToDescH[WId].MxVal;}
409    void PutWordFq(const int& WId, const int& Fq){
410      WordStrToDescH[WId].Fq=Fq;}
411    int GetWordFq(const int& WId) const {
412      return WordStrToDescH[WId].Fq;}
413    void GetWordStrVFromHtml(const TStr& HtmlStr, TStrV& WordStrV) const;
414    int AddDoc(const TStr& DocNm,
415     const TStrV& CatNmV, const TIntFltPrV& WIdWgtPrV);
416    int AddDoc(const TStr& DocNm,
417     const TStrV& CatNmV, const TStrV& WordStrV, const TStr& DocStr=TStr());
418    int AddDoc(const TStr& DocNm,
419     const TStr& CatNm, const TStrV& WordStrV, const TStr& DocStr=TStr()){
420      TStrV CatNmV; CatNmV.Add(CatNm);
421      return AddDoc(DocNm, CatNmV, WordStrV, DocStr);}
422    int AddHtmlDoc(const TStr& DocNm, const TStrV& CatNmV,
423     const TStr& HtmlDocStr, const bool& SaveDocP=false);
424    int GetDocs() const {return DocSpVV.Len();}
425    PBowSpV GetDocSpV(const int& DId) const {return DocSpVV[DId];}
426    void PutDocStr(const int& DId, const TStr& DocStr){DocStrV[DId]=DocStr; }
427    TStr GetDocStr(const int& DId) const {return DocStrV[DId];}
428    bool IsDocNm(const TStr& DocNm) const {
429      return DocNmToDescStrH.IsKey(DocNm);}
430    bool IsDocNm(const TStr& DocNm, int& DId) const {
431      DId=DocNmToDescStrH.GetKeyId(DocNm); return DId!=-1;}
432    TStr GetDocNm(const int& DId) const {
433      if (DocNmToDescStrH.Empty()){return TInt::GetStr(DId);}
434      else {return DocNmToDescStrH.GetKey(DId);}}
435    bool IsDId(const int& DId) const {
436      return (0<=DId)&&(DId<DocSpVV.Len());}
437    int GetDId(const TStr& DocNm) const {
438      return DocNmToDescStrH.GetKeyId(DocNm);}
439    void GetAllDIdV(TIntV& DIdV) const;
440    int GetDocWIds(const int& DId) const {
441      return DocSpVV[DId]->GetWIds();}
442    void GetDocWIdFq(
443     const int& DId, const int& DocWIdN, int& WId, double& WordFq) const {
444      DocSpVV[DId]->GetWIdWgt(DocWIdN, WId, WordFq);}
445    int GetDocWIdN(const int& DId, const int& DocWId) const {
446      return DocSpVV[DId]->GetWId(DocWId);}
447    int GetDocWId(const int& DId, const int& DocWIdN) const {
448      return DocSpVV[DId]->GetWId(DocWIdN);}
449    void PutDocWFq(const int& DId, const int& DocWIdN, double& WordFq){
450      DocSpVV[DId]->GetWgt(DocWIdN)=sdouble(WordFq);}
451    double GetDocWFq(const int& DId, const int& DocWIdN) const {
452      return DocSpVV[DId]->GetWgt(DocWIdN);}
453    bool IsDocWordStr(const int& DId, const TStr& WordStr) const;
454    int GetDocCIds(const int& DId) const {
455      return DocCIdVV.Empty() ? 0 : DocCIdVV[DId].Len();}
456    int GetDocCId(const int& DId, const int& DocCIdN) const {
457      return DocCIdVV[DId][DocCIdN];}
458    bool IsCatInDoc(const int& DId, const int& CId) const {
459      return DocCIdVV[DId].IsIn(CId);}
460    void PutDocDescStr(const int& DId, const TStr& DocDescStr){
461      DocNmToDescStrH[DId]=DocDescStr;}
462    TStr GetDocDescStr(const int& DId) const {
463      return DocNmToDescStrH[DId];}
464    void PutDateStr(const int& DId, const TStr& DateStr){
465      PutDocDescStr(DId, DateStr);}
466    TStr GetDateStr(const int& DId) const {
467      return GetDocDescStr(DId);}
468    bool IsCats() const {return GetCats()>0;}
469    int GetCats() const {return CatNmToFqH.Len();}
470    bool IsCatNm(const TStr& CatNm) const {
471      return CatNmToFqH.IsKey(CatNm);}
472    bool IsCatNm(const TStr& CatNm, int& CId) const {
473      return CatNmToFqH.IsKey(CatNm, CId);}
474    bool IsCId(const int& CId) const {
475      return CatNmToFqH.IsKeyId(CId);}
476    int GetCId(const TStr& CatNm) const {
477      return CatNmToFqH.GetKeyId(CatNm);}
478    TStr GetCatNm(const int& CId) const {
479      return CatNmToFqH.GetKey(CId);}
480    int GetCatFq(const int& CId) const {
481      return CatNmToFqH[CId];}
482    void GetTopCatV(const int& TopCats, TIntStrPrV& FqCatNmPrV) const;
483    void AddDocCId(const int& DId, const int& CId){
484      CatNmToFqH[CId]++; DocCIdVV[DId].AddUnique(CId);}
485    int AddCatNm(const TStr& CatNm){
486      return CatNmToFqH.AddKey(CatNm);}
487    void PutTrainDIdV(const TIntV& DIdV){TrainDIdV=DIdV;}
488    void PutTestDIdV(const TIntV& DIdV){TestDIdV=DIdV;}
489    void PutTrainDocNmV(const TStrV& DocNmV){
490      TrainDIdV.Gen(DocNmV.Len(), 0);
491      for (int DocNmN=0; DocNmN<DocNmV.Len(); DocNmN++){
492        TrainDIdV.Add(GetDId(DocNmV[DocNmN]));}}
493    void PutTestDocNmV(const TStrV& DocNmV){
494      TestDIdV.Gen(DocNmV.Len(), 0);
495      for (int DocNmN=0; DocNmN<DocNmV.Len(); DocNmN++){
496        TestDIdV.Add(GetDId(DocNmV[DocNmN]));}}
497    void AddTrainDId(const int& DId){TrainDIdV.Add(DId);}
498    int GetTrainDocs() const {return TrainDIdV.Len();}
499    int GetTrainDId(const int& DIdN) const {return TrainDIdV[DIdN];}
500    void GetTrainDIdV(TIntV& _TrainDIdV){_TrainDIdV=TrainDIdV;}
501    void AddTestDId(const int& DId){TestDIdV.Add(DId);}
502    int GetTestDocs() const {return TestDIdV.Len();}
503    int GetTestDId(const int& DIdN) const {return TestDIdV[DIdN];}
504    void GetTestDIdV(TIntV& _TestDIdV){_TestDIdV=TestDIdV;}
505    void SetHOTrainTestDIdV(const double& TestDocsPrc, TRnd& Rnd);
506    void SetCVTrainTestDIdV(const int& Folds, const int& FoldN, TRnd& Rnd);
507    void GetAbsSampleDIdV(const int& Docs, TRnd& Rnd, TIntV& DIdV) const {
508      GetAllDIdV(DIdV); DIdV.Shuffle(Rnd); DIdV.Trunc(Docs);}
509    void GetRelSampleDIdV(const double& DocsPrc, TRnd& Rnd, TIntV& DIdV) const {
510      IAssert((0<=DocsPrc)&&(DocsPrc<=1));
511      int Docs=int(DocsPrc*GetDocs()); GetAbsSampleDIdV(Docs, Rnd, DIdV);}
512    PBowDocBs GetLimWordRelFqDocBs(
513     const double& MnWordFqPrc, const double& MxWordFqPrc) const;
514    PBowDocBs GetLimWordAbsFqDocBs(const int& MnWordFq) const;
515    PBowDocBs GetSubDocSet(const TIntV& DIdV) const;
516    PBowDocBs GetInvDocBs() const;
517    PBowSpV GetSpVFromHtmlStr(
518     const TStr& HtmlStr, const PBowDocWgtBs& BowDocWgtBs=NULL) const;
519    PBowSpV GetSpVFromHtmlFile(
520     const TStr& HtmlFNm, const PBowDocWgtBs& BowDocWgtBs=NULL) const;
521    PBowSpV GetSpVFromWIdWgtPrV(
522     const TIntFltPrV& WIdWgtPrV, const PBowDocWgtBs& BowDocWgtBs=NULL) const;
523    void SaveTxtStat(const TStr& StatFNm, const bool& SaveWordsP=true,
524     const bool& SaveCatsP=true, const bool& SaveDocsP=true) const;
525    static const TStr BowDocBsFExt;
526    static PBowDocBs LoadBin(const TStr& FNm){
527      TFIn SIn(FNm); return Load(SIn);}
528    void SaveBin(const TStr& FNm) const {
529      TFOut SOut(FNm); Save(SOut);}
530    friend class TBowFl;
531  };
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-sir.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-bowbs.h</div>
                </div>
                <div class="column column_space"><pre><code>173  }
174  void TSirModel::GetParamRange(TFltTrV& ParamMnMxStepV) const {
175    ParamMnMxStepV = ParamMnMnRngV; 
176  }
177  void TSirModel::GetParamNmV(TStrV& ParamNmV) const {
178    ParamNmV = TStrV::GetV("Beta", "Gamma");
179  }
180  void TSirModel::Plot(const TStr& OutFNm, TStr Desc) const {
</pre></code></div>
                <div class="column column_space"><pre><code>281    void SetSpV(const int& DId, PBowSpV DocSpV) { DocSpVV[DId] = DocSpV; } 
282    void GetDIdV(TIntV& _DIdV) const {_DIdV=DIdV;}
283    void SetDIdV(const TIntV& _DIdV){DIdV=_DIdV;}
284    const TBowSpVV& GetDocSpVV() const { return DocSpVV; }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    