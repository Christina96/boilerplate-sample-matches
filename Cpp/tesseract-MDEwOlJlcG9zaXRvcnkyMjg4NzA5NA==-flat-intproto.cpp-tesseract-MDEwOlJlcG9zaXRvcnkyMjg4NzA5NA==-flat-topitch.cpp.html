
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 12.222222222222221%, Tokens: 11</h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-intproto.cpp</h3>
            <pre><code>1  #define _USE_MATH_DEFINES 
2  #ifdef HAVE_CONFIG_H
3  #  include "config_auto.h"
4  #endif
5  #include "intproto.h"
6  #include "classify.h"
7  #include "fontinfo.h"
8  #include "mfoutline.h"
9  #include "picofeat.h"
10  #include "points.h"
11  #include "shapetable.h"
12  #ifndef GRAPHICS_DISABLED
13  #include "svmnode.h"
14  #endif
15  #include "helpers.h"
16  #include <algorithm>
17  #include <cassert>
18  #include <cmath> 
19  #include <cstdio>
20  namespace tesseract {
21  #define PROTO_PRUNER_SCALE (4.0)
22  #define INT_DESCENDER (0.0 * INT_CHAR_NORM_RANGE)
23  #define INT_BASELINE (0.25 * INT_CHAR_NORM_RANGE)
24  #define INT_XHEIGHT (0.75 * INT_CHAR_NORM_RANGE)
25  #define INT_CAPHEIGHT (1.0 * INT_CHAR_NORM_RANGE)
26  #define INT_XCENTER (0.5 * INT_CHAR_NORM_RANGE)
27  #define INT_YCENTER (0.5 * INT_CHAR_NORM_RANGE)
28  #define INT_XRADIUS (0.2 * INT_CHAR_NORM_RANGE)
29  #define INT_YRADIUS (0.2 * INT_CHAR_NORM_RANGE)
30  #define INT_MIN_X 0
31  #define INT_MIN_Y 0
32  #define INT_MAX_X INT_CHAR_NORM_RANGE
33  #define INT_MAX_Y INT_CHAR_NORM_RANGE
34  #define HV_TOLERANCE (0.0025) &bsol;* approx 0.9 degrees */
35  typedef enum { StartSwitch, EndSwitch, LastSwitch } SWITCH_TYPE;
36  #define MAX_NUM_SWITCHES 3
37  struct FILL_SWITCH {
38    SWITCH_TYPE Type;
39    int8_t X, Y;
40    int16_t YInit;
41    int16_t Delta;
42  };
43  struct TABLE_FILLER {
44    uint8_t NextSwitch;
45    uint8_t AngleStart, AngleEnd;
46    int8_t X;
47    int16_t YStart, YEnd;
48    int16_t StartDelta, EndDelta;
49    FILL_SWITCH Switch[MAX_NUM_SWITCHES];
50  };
51  struct FILL_SPEC {
52    int8_t X;
53    int8_t YStart, YEnd;
54    uint8_t AngleStart, AngleEnd;
55  };
56  #define OLD_MAX_NUM_CONFIGS 32
57  #define OLD_WERDS_PER_CONFIG_VEC ((OLD_MAX_NUM_CONFIGS + BITS_PER_WERD - 1) / BITS_PER_WERD)
58  #define CircularIncrement(i, r) (((i) < (r)-1) ? ((i)++) : ((i) = 0))
59  #define MapParam(P, O, N) (std::floor(((P) + (O)) * (N)))
60  float BucketStart(int Bucket, float Offset, int NumBuckets);
61  float BucketEnd(int Bucket, float Offset, int NumBuckets);
62  void DoFill(FILL_SPEC *FillSpec, CLASS_PRUNER_STRUCT *Pruner, uint32_t ClassMask,
63              uint32_t ClassCount, uint32_t WordIndex);
64  bool FillerDone(TABLE_FILLER *Filler);
65  void FillPPCircularBits(uint32_t ParamTable[NUM_PP_BUCKETS][WERDS_PER_PP_VECTOR], int Bit,
66                          float Center, float Spread, bool debug);
67  void FillPPLinearBits(uint32_t ParamTable[NUM_PP_BUCKETS][WERDS_PER_PP_VECTOR], int Bit,
68                        float Center, float Spread, bool debug);
69  void GetCPPadsForLevel(int Level, float *EndPad, float *SidePad, float *AnglePad);
70  ScrollView::Color GetMatchColorFor(float Evidence);
71  void GetNextFill(TABLE_FILLER *Filler, FILL_SPEC *Fill);
72  void InitTableFiller(float EndPad, float SidePad, float AnglePad, PROTO_STRUCT *Proto,
73                       TABLE_FILLER *Filler);
74  #ifndef GRAPHICS_DISABLED
75  void RenderIntFeature(ScrollView *window, const INT_FEATURE_STRUCT *Feature,
76                        ScrollView::Color color);
77  void RenderIntProto(ScrollView *window, INT_CLASS_STRUCT *Class, PROTO_ID ProtoId, ScrollView::Color color);
78  #endif 
79  #ifndef GRAPHICS_DISABLED
80  static ScrollView *IntMatchWindow = nullptr;
81  static ScrollView *FeatureDisplayWindow = nullptr;
82  static ScrollView *ProtoDisplayWindow = nullptr;
83  #endif
84  static INT_VAR(classify_num_cp_levels, 3, "Number of Class Pruner Levels");
85  static double_VAR(classify_cp_angle_pad_loose, 45.0, "Class Pruner Angle Pad Loose");
86  static double_VAR(classify_cp_angle_pad_medium, 20.0, "Class Pruner Angle Pad Medium");
87  static double_VAR(classify_cp_angle_pad_tight, 10.0, "CLass Pruner Angle Pad Tight");
88  static double_VAR(classify_cp_end_pad_loose, 0.5, "Class Pruner End Pad Loose");
89  static double_VAR(classify_cp_end_pad_medium, 0.5, "Class Pruner End Pad Medium");
90  static double_VAR(classify_cp_end_pad_tight, 0.5, "Class Pruner End Pad Tight");
91  static double_VAR(classify_cp_side_pad_loose, 2.5, "Class Pruner Side Pad Loose");
92  static double_VAR(classify_cp_side_pad_medium, 1.2, "Class Pruner Side Pad Medium");
93  static double_VAR(classify_cp_side_pad_tight, 0.6, "Class Pruner Side Pad Tight");
94  static double_VAR(classify_pp_angle_pad, 45.0, "Proto Pruner Angle Pad");
95  static double_VAR(classify_pp_end_pad, 0.5, "Proto Prune End Pad");
96  static double_VAR(classify_pp_side_pad, 2.5, "Proto Pruner Side Pad");
97  static int TruncateParam(float Param, int Min, int Max) {
98    int result;
99    if (Param < Min) {
100      result = Min;
101    } else if (Param > Max) {
102      result = Max;
103    } else {
104      result = static_cast<int>(std::floor(Param));
105    }
106    return result;
107  }
108  INT_FEATURE_STRUCT::INT_FEATURE_STRUCT(const FCOORD &pos, uint8_t theta)
109      : X(ClipToRange<int16_t>(static_cast<int16_t>(pos.x() + 0.5), 0, 255))
110      , Y(ClipToRange<int16_t>(static_cast<int16_t>(pos.y() + 0.5), 0, 255))
111      , Theta(theta)
112      , CP_misses(0) {}
113  INT_FEATURE_STRUCT::INT_FEATURE_STRUCT(int x, int y, int theta)
114      : X(static_cast<uint8_t>(ClipToRange<int>(x, 0, UINT8_MAX)))
115      , Y(static_cast<uint8_t>(ClipToRange<int>(y, 0, UINT8_MAX)))
116      , Theta(static_cast<uint8_t>(ClipToRange<int>(theta, 0, UINT8_MAX)))
117      , CP_misses(0) {}
118  void AddIntClass(INT_TEMPLATES_STRUCT *Templates, CLASS_ID ClassId, INT_CLASS_STRUCT *Class) {
119    int Pruner;
120    assert(LegalClassId(ClassId));
121    if (static_cast<unsigned>(ClassId) != Templates->NumClasses) {
122      fprintf(stderr,
123              "Please make sure that classes are added to templates"
124              " in increasing order of ClassIds\n");
125      exit(1);
126    }
127    ClassForClassId(Templates, ClassId) = Class;
128    Templates->NumClasses++;
129    if (Templates->NumClasses > MaxNumClassesIn(Templates)) {
130      Pruner = Templates->NumClassPruners++;
131      Templates->ClassPruners[Pruner] = new CLASS_PRUNER_STRUCT;
132      memset(Templates->ClassPruners[Pruner], 0, sizeof(CLASS_PRUNER_STRUCT));
133    }
134  } &bsol;* AddIntClass */
135  int AddIntConfig(INT_CLASS_STRUCT *Class) {
136    int Index;
137    assert(Class->NumConfigs < MAX_NUM_CONFIGS);
138    Index = Class->NumConfigs++;
139    Class->ConfigLengths[Index] = 0;
140    return Index;
141  } &bsol;* AddIntConfig */
142  int AddIntProto(INT_CLASS_STRUCT *Class) {
143    if (Class->NumProtos >= MAX_NUM_PROTOS) {
144      return (NO_PROTO);
145    }
146    int Index = Class->NumProtos++;
147    if (Class->NumProtos > MaxNumIntProtosIn(Class)) {
148      int ProtoSetId = Class->NumProtoSets++;
149      auto ProtoSet = new PROTO_SET_STRUCT;
150      Class->ProtoSets[ProtoSetId] = ProtoSet;
151      memset(ProtoSet, 0, sizeof(*ProtoSet));
152      Class->ProtoLengths.resize(MaxNumIntProtosIn(Class));
153    }
154    Class->ProtoLengths[Index] = 0;
155    auto Proto = ProtoForProtoId(Class, Index);
156    for (uint32_t *Word = Proto->Configs; Word < Proto->Configs + WERDS_PER_CONFIG_VEC; *Word++ = 0) {
157    }
158    return (Index);
159  }
160  void AddProtoToClassPruner(PROTO_STRUCT *Proto, CLASS_ID ClassId, INT_TEMPLATES_STRUCT *Templates)
161  #define MAX_LEVEL 2
162  {
163    CLASS_PRUNER_STRUCT *Pruner;
164    uint32_t ClassMask;
165    uint32_t ClassCount;
166    uint32_t WordIndex;
167    int Level;
168    float EndPad, SidePad, AnglePad;
169    TABLE_FILLER TableFiller;
170    FILL_SPEC FillSpec;
171    Pruner = CPrunerFor(Templates, ClassId);
172    WordIndex = CPrunerWordIndexFor(ClassId);
173    ClassMask = CPrunerMaskFor(MAX_LEVEL, ClassId);
174    for (Level = classify_num_cp_levels - 1; Level >= 0; Level--) {
175      GetCPPadsForLevel(Level, &EndPad, &SidePad, &AnglePad);
176      ClassCount = CPrunerMaskFor(Level, ClassId);
177      InitTableFiller(EndPad, SidePad, AnglePad, Proto, &TableFiller);
178      while (!FillerDone(&TableFiller)) {
179        GetNextFill(&TableFiller, &FillSpec);
180        DoFill(&FillSpec, Pruner, ClassMask, ClassCount, WordIndex);
181      }
182    }
183  } &bsol;* AddProtoToClassPruner */
184  void AddProtoToProtoPruner(PROTO_STRUCT *Proto, int ProtoId, INT_CLASS_STRUCT *Class, bool debug) {
185    float X, Y, Length;
186    float Pad;
187    if (ProtoId >= Class->NumProtos) {
188      tprintf("AddProtoToProtoPruner:assert failed: %d < %d", ProtoId, Class->NumProtos);
189    }
190    assert(ProtoId < Class->NumProtos);
191    int Index = IndexForProto(ProtoId);
192    auto ProtoSet = Class->ProtoSets[SetForProto(ProtoId)];
193    float Angle = Proto->Angle;
194  #ifndef _WIN32
195    assert(!std::isnan(Angle));
196  #endif
197    FillPPCircularBits(ProtoSet->ProtoPruner[PRUNER_ANGLE], Index, Angle + ANGLE_SHIFT,
198                       classify_pp_angle_pad / 360.0, debug);
199    Angle *= 2.0 * M_PI;
200    Length = Proto->Length;
201    X = Proto->X + X_SHIFT;
202    Pad = std::max(fabs(std::cos(Angle)) * (Length / 2.0 + classify_pp_end_pad * GetPicoFeatureLength()),
203                   fabs(std::sin(Angle)) * (classify_pp_side_pad * GetPicoFeatureLength()));
204    FillPPLinearBits(ProtoSet->ProtoPruner[PRUNER_X], Index, X, Pad, debug);
205    Y = Proto->Y + Y_SHIFT;
206    Pad = std::max(fabs(std::sin(Angle)) * (Length / 2.0 + classify_pp_end_pad * GetPicoFeatureLength()),
207                   fabs(std::cos(Angle)) * (classify_pp_side_pad * GetPicoFeatureLength()));
208    FillPPLinearBits(ProtoSet->ProtoPruner[PRUNER_Y], Index, Y, Pad, debug);
209  } &bsol;* AddProtoToProtoPruner */
210  uint8_t Bucket8For(float param, float offset, int num_buckets) {
211    int bucket = IntCastRounded(MapParam(param, offset, num_buckets));
212    return static_cast<uint8_t>(ClipToRange<int>(bucket, 0, num_buckets - 1));
213  }
214  uint16_t Bucket16For(float param, float offset, int num_buckets) {
215    int bucket = IntCastRounded(MapParam(param, offset, num_buckets));
216    return static_cast<uint16_t>(ClipToRange<int>(bucket, 0, num_buckets - 1));
217  }
218  uint8_t CircBucketFor(float param, float offset, int num_buckets) {
219    int bucket = IntCastRounded(MapParam(param, offset, num_buckets));
220    return static_cast<uint8_t>(Modulo(bucket, num_buckets));
221  } &bsol;* CircBucketFor */
222  #ifndef GRAPHICS_DISABLED
223  void UpdateMatchDisplay() {
224    if (IntMatchWindow != nullptr) {
225      IntMatchWindow->Update();
226    }
227  } &bsol;* ClearMatchDisplay */
228  #endif
229  void ConvertConfig(BIT_VECTOR Config, int ConfigId, INT_CLASS_STRUCT *Class) {
230    int ProtoId;
231    INT_PROTO_STRUCT *Proto;
232    int TotalLength;
233    for (ProtoId = 0, TotalLength = 0; ProtoId < Class->NumProtos; ProtoId++) {
234      if (test_bit(Config, ProtoId)) {
235        Proto = ProtoForProtoId(Class, ProtoId);
236        SET_BIT(Proto->Configs, ConfigId);
237        TotalLength += Class->ProtoLengths[ProtoId];
238      }
239    }
240    Class->ConfigLengths[ConfigId] = TotalLength;
241  } &bsol;* ConvertConfig */
242  void Classify::ConvertProto(PROTO_STRUCT *Proto, int ProtoId, INT_CLASS_STRUCT *Class) {
243    assert(ProtoId < Class->NumProtos);
244    INT_PROTO_STRUCT *P = ProtoForProtoId(Class, ProtoId);
245    float Param = Proto->A * 128;
246    P->A = TruncateParam(Param, -128, 127);
247    Param = -Proto->B * 256;
248    P->B = TruncateParam(Param, 0, 255);
249    Param = Proto->C * 128;
250    P->C = TruncateParam(Param, -128, 127);
251    Param = Proto->Angle * 256;
252    if (Param < 0 || Param >= 256) {
253      P->Angle = 0;
254    } else {
255      P->Angle = static_cast<uint8_t>(Param);
256    }
257    Param = (Proto->Length / GetPicoFeatureLength()) + 0.5;
258    Class->ProtoLengths[ProtoId] = TruncateParam(Param, 1, 255);
259    if (classify_learning_debug_level >= 2) {
260      tprintf("Converted ffeat to (A=%d,B=%d,C=%d,L=%d)", P->A, P->B, P->C,
261              Class->ProtoLengths[ProtoId]);
262    }
263  } &bsol;* ConvertProto */
264  INT_TEMPLATES_STRUCT *Classify::CreateIntTemplates(CLASSES FloatProtos,
265                                             const UNICHARSET &target_unicharset) {
266    CLASS_TYPE FClass;
267    INT_CLASS_STRUCT *IClass;
268    int ProtoId;
269    int ConfigId;
270    auto IntTemplates = new INT_TEMPLATES_STRUCT;
271    for (unsigned ClassId = 0; ClassId < target_unicharset.size(); ClassId++) {
272      FClass = &(FloatProtos[ClassId]);
273      if (FClass->NumProtos == 0 && FClass->NumConfigs == 0 &&
274          strcmp(target_unicharset.id_to_unichar(ClassId), " ") != 0) {
275        tprintf("Warning: no protos/configs for %s in CreateIntTemplates()\n",
276                target_unicharset.id_to_unichar(ClassId));
277      }
278      assert(UnusedClassIdIn(IntTemplates, ClassId));
279      IClass = new INT_CLASS_STRUCT(FClass->NumProtos, FClass->NumConfigs);
280      unsigned fs_size = FClass->font_set.size();
281      FontSet fs;
282      fs.reserve(fs_size);
283      for (unsigned i = 0; i < fs_size; ++i) {
284        fs.push_back(FClass->font_set[i]);
285      }
286      IClass->font_set_id = this->fontset_table_.push_back(fs);
287      AddIntClass(IntTemplates, ClassId, IClass);
288      for (ProtoId = 0; ProtoId < FClass->NumProtos; ProtoId++) {
289        AddIntProto(IClass);
290        ConvertProto(ProtoIn(FClass, ProtoId), ProtoId, IClass);
291        AddProtoToProtoPruner(ProtoIn(FClass, ProtoId), ProtoId, IClass,
292                              classify_learning_debug_level >= 2);
293        AddProtoToClassPruner(ProtoIn(FClass, ProtoId), ClassId, IntTemplates);
294      }
295      for (ConfigId = 0; ConfigId < FClass->NumConfigs; ConfigId++) {
296        AddIntConfig(IClass);
297        ConvertConfig(FClass->Configurations[ConfigId], ConfigId, IClass);
298      }
299    }
300    return (IntTemplates);
301  } &bsol;* CreateIntTemplates */
302  #ifndef GRAPHICS_DISABLED
303  void DisplayIntFeature(const INT_FEATURE_STRUCT *Feature, float Evidence) {
304    ScrollView::Color color = GetMatchColorFor(Evidence);
305    RenderIntFeature(IntMatchWindow, Feature, color);
306    if (FeatureDisplayWindow) {
307      RenderIntFeature(FeatureDisplayWindow, Feature, color);
308    }
309  } &bsol;* DisplayIntFeature */
310  void DisplayIntProto(INT_CLASS_STRUCT *Class, PROTO_ID ProtoId, float Evidence) {
311    ScrollView::Color color = GetMatchColorFor(Evidence);
312    RenderIntProto(IntMatchWindow, Class, ProtoId, color);
313    if (ProtoDisplayWindow) {
314      RenderIntProto(ProtoDisplayWindow, Class, ProtoId, color);
315    }
316  } &bsol;* DisplayIntProto */
317  #endif
318  INT_CLASS_STRUCT::INT_CLASS_STRUCT(int MaxNumProtos, int MaxNumConfigs) :
319    NumProtos(0),
320    NumProtoSets((MaxNumProtos + PROTOS_PER_PROTO_SET - 1) / PROTOS_PER_PROTO_SET),
321    NumConfigs(0),
322    ProtoLengths(MaxNumIntProtosIn(this))
323  {
324    assert(MaxNumConfigs <= MAX_NUM_CONFIGS);
325    assert(NumProtoSets <= MAX_NUM_PROTO_SETS);
326    for (int i = 0; i < NumProtoSets; i++) {
327      auto ProtoSet = new PROTO_SET_STRUCT;
328      memset(ProtoSet, 0, sizeof(*ProtoSet));
329      ProtoSets[i] = ProtoSet;
330    }
331    memset(ConfigLengths, 0, sizeof(ConfigLengths));
332  }
333  INT_CLASS_STRUCT::~INT_CLASS_STRUCT() {
334    for (int i = 0; i < NumProtoSets; i++) {
335      delete ProtoSets[i];
336    }
337  }
338  INT_TEMPLATES_STRUCT::INT_TEMPLATES_STRUCT() {
339    NumClasses = 0;
340    NumClassPruners = 0;
341    for (int i = 0; i < MAX_NUM_CLASSES; i++) {
342      ClassForClassId(this, i) = nullptr;
343    }
344  }
345  INT_TEMPLATES_STRUCT::~INT_TEMPLATES_STRUCT() {
346    for (unsigned i = 0; i < NumClasses; i++) {
347      delete Class[i];
348    }
349    for (unsigned i = 0; i < NumClassPruners; i++) {
350      delete ClassPruners[i];
351    }
352  }
353  INT_TEMPLATES_STRUCT *Classify::ReadIntTemplates(TFile *fp) {
354    int j, w, x, y, z;
355    INT_TEMPLATES_STRUCT *Templates;
356    CLASS_PRUNER_STRUCT *Pruner;
357    INT_CLASS_STRUCT *Class;
358    int b, bit_number, last_cp_bit_number, new_b, new_i, new_w;
359    CLASS_ID class_id, max_class_id;
360    std::vector<CLASS_ID> ClassIdFor(MAX_NUM_CLASSES);
361    std::vector<CLASS_PRUNER_STRUCT *> TempClassPruner(MAX_NUM_CLASS_PRUNERS);
362    uint32_t SetBitsForMask =          
363        (1 << NUM_BITS_PER_CLASS) - 1; 
364    uint32_t Mask, NewMask, ClassBits;
365    unsigned MaxNumConfigs = MAX_NUM_CONFIGS;
366    unsigned WerdsPerConfigVec = WERDS_PER_CONFIG_VEC;
367    Templates = new INT_TEMPLATES_STRUCT;
368    uint32_t unicharset_size;
369    if (fp->FReadEndian(&unicharset_size, sizeof(unicharset_size), 1) != 1) {
370      tprintf("Bad read of inttemp!\n");
371    }
372    int32_t version_id = 0;
373    if (fp->FReadEndian(&version_id, sizeof(version_id), 1) != 1 ||
374        fp->FReadEndian(&Templates->NumClassPruners, sizeof(Templates->NumClassPruners), 1) != 1) {
375      tprintf("Bad read of inttemp!\n");
376    }
377    if (version_id < 0) {
378      version_id = -version_id;
379      if (fp->FReadEndian(&Templates->NumClasses, sizeof(Templates->NumClasses), 1) != 1) {
380        tprintf("Bad read of inttemp!\n");
381      }
382    } else {
383      Templates->NumClasses = version_id;
384    }
385    if (version_id < 3) {
386      MaxNumConfigs = OLD_MAX_NUM_CONFIGS;
387      WerdsPerConfigVec = OLD_WERDS_PER_CONFIG_VEC;
388    }
389    if (version_id < 2) {
390      std::vector<int16_t> IndexFor(MAX_NUM_CLASSES);
391      if (fp->FReadEndian(&IndexFor[0], sizeof(IndexFor[0]), unicharset_size) != unicharset_size) {
392        tprintf("Bad read of inttemp!\n");
393      }
394      if (fp->FReadEndian(&ClassIdFor[0], sizeof(ClassIdFor[0]), Templates->NumClasses) !=
395          Templates->NumClasses) {
396        tprintf("Bad read of inttemp!\n");
397      }
398    }
399    const unsigned kNumBuckets = NUM_CP_BUCKETS * NUM_CP_BUCKETS * NUM_CP_BUCKETS * WERDS_PER_CP_VECTOR;
400    for (unsigned i = 0; i < Templates->NumClassPruners; i++) {
401      Pruner = new CLASS_PRUNER_STRUCT;
402      if (fp->FReadEndian(Pruner, sizeof(Pruner->p[0][0][0][0]), kNumBuckets) != kNumBuckets) {
403        tprintf("Bad read of inttemp!\n");
404      }
405      if (version_id < 2) {
406        TempClassPruner[i] = Pruner;
407      } else {
408        Templates->ClassPruners[i] = Pruner;
409      }
410    }
411    if (version_id < 2) {
412      max_class_id = 0;
413      for (unsigned i = 0; i < Templates->NumClasses; i++) {
414        if (ClassIdFor[i] > max_class_id) {
415          max_class_id = ClassIdFor[i];
416        }
417      }
418      for (int i = 0; i <= CPrunerIdFor(max_class_id); i++) {
419        Templates->ClassPruners[i] = new CLASS_PRUNER_STRUCT;
420        memset(Templates->ClassPruners[i], 0, sizeof(CLASS_PRUNER_STRUCT));
421      }
422      last_cp_bit_number = NUM_BITS_PER_CLASS * Templates->NumClasses - 1;
423      for (unsigned i = 0; i < Templates->NumClassPruners; i++) {
424        for (x = 0; x < NUM_CP_BUCKETS; x++) {
425          for (y = 0; y < NUM_CP_BUCKETS; y++) {
426            for (z = 0; z < NUM_CP_BUCKETS; z++) {
427              for (w = 0; w < WERDS_PER_CP_VECTOR; w++) {
428                if (TempClassPruner[i]->p[x][y][z][w] == 0) {
429                  continue;
430                }
431                for (b = 0; b < BITS_PER_WERD; b += NUM_BITS_PER_CLASS) {
432                  bit_number = i * BITS_PER_CP_VECTOR + w * BITS_PER_WERD + b;
433                  if (bit_number > last_cp_bit_number) {
434                    break; 
435                  }
436                  class_id = ClassIdFor[bit_number / NUM_BITS_PER_CLASS];
437                  Mask = SetBitsForMask << b;
438                  ClassBits = TempClassPruner[i]->p[x][y][z][w] & Mask;
439                  new_i = CPrunerIdFor(class_id);
440                  new_w = CPrunerWordIndexFor(class_id);
441                  new_b = CPrunerBitIndexFor(class_id) * NUM_BITS_PER_CLASS;
442                  if (new_b > b) {
443                    ClassBits <<= (new_b - b);
444                  } else {
445                    ClassBits >>= (b - new_b);
446                  }
447                  NewMask = SetBitsForMask << new_b;
448                  Templates->ClassPruners[new_i]->p[x][y][z][new_w] &= ~NewMask;
449                  Templates->ClassPruners[new_i]->p[x][y][z][new_w] |= ClassBits;
450                }
451              }
452            }
453          }
454        }
455      }
456      for (unsigned i = 0; i < Templates->NumClassPruners; i++) {
457        delete TempClassPruner[i];
458      }
459    }
460    for (unsigned i = 0; i < Templates->NumClasses; i++) {
461      Class = new INT_CLASS_STRUCT;
462      if (fp->FReadEndian(&Class->NumProtos, sizeof(Class->NumProtos), 1) != 1 ||
463          fp->FRead(&Class->NumProtoSets, sizeof(Class->NumProtoSets), 1) != 1 ||
464          fp->FRead(&Class->NumConfigs, sizeof(Class->NumConfigs), 1) != 1) {
465        tprintf("Bad read of inttemp!\n");
466      }
467      if (version_id == 0) {
468        for (j = 0; j < 5; ++j) {
469          int32_t junk;
470          if (fp->FRead(&junk, sizeof(junk), 1) != 1) {
471            tprintf("Bad read of inttemp!\n");
472          }
473        }
474      }
475      unsigned num_configs = version_id < 4 ? MaxNumConfigs : Class->NumConfigs;
476      ASSERT_HOST(num_configs <= MaxNumConfigs);
477      if (fp->FReadEndian(Class->ConfigLengths, sizeof(uint16_t), num_configs) != num_configs) {
478        tprintf("Bad read of inttemp!\n");
479      }
480      if (version_id < 2) {
481        ClassForClassId(Templates, ClassIdFor[i]) = Class;
482      } else {
483        ClassForClassId(Templates, i) = Class;
484      }
485      Class->ProtoLengths.clear();
486      if (MaxNumIntProtosIn(Class) > 0) {
487        Class->ProtoLengths.resize(MaxNumIntProtosIn(Class));
488        if (fp->FRead(&Class->ProtoLengths[0], sizeof(uint8_t), MaxNumIntProtosIn(Class)) !=
489            MaxNumIntProtosIn(Class)) {
490          tprintf("Bad read of inttemp!\n");
491        }
492      }
493      for (j = 0; j < Class->NumProtoSets; j++) {
494        auto ProtoSet = new PROTO_SET_STRUCT;
495        unsigned num_buckets = NUM_PP_PARAMS * NUM_PP_BUCKETS * WERDS_PER_PP_VECTOR;
496        if (fp->FReadEndian(&ProtoSet->ProtoPruner, sizeof(ProtoSet->ProtoPruner[0][0][0]),
497                            num_buckets) != num_buckets) {
498          tprintf("Bad read of inttemp!\n");
499        }
500        for (x = 0; x < PROTOS_PER_PROTO_SET; x++) {
501          if (fp->FRead(&ProtoSet->Protos[x].A, sizeof(ProtoSet->Protos[x].A), 1) != 1 ||
502              fp->FRead(&ProtoSet->Protos[x].B, sizeof(ProtoSet->Protos[x].B), 1) != 1 ||
503              fp->FRead(&ProtoSet->Protos[x].C, sizeof(ProtoSet->Protos[x].C), 1) != 1 ||
504              fp->FRead(&ProtoSet->Protos[x].Angle, sizeof(ProtoSet->Protos[x].Angle), 1) != 1) {
505            tprintf("Bad read of inttemp!\n");
506          }
507          if (fp->FReadEndian(&ProtoSet->Protos[x].Configs, sizeof(ProtoSet->Protos[x].Configs[0]),
508                              WerdsPerConfigVec) != WerdsPerConfigVec) {
509            tprintf("Bad read of inttemp!\n");
510          }
511        }
512        Class->ProtoSets[j] = ProtoSet;
513      }
514      if (version_id < 4) {
515        Class->font_set_id = -1;
516      } else {
517        fp->FReadEndian(&Class->font_set_id, sizeof(Class->font_set_id), 1);
518      }
519    }
520    if (version_id < 2) {
521      assert(UnusedClassIdIn(Templates, 0));
522      ClassForClassId(Templates, 0) = new INT_CLASS_STRUCT(1, 1);
523      ClassForClassId(Templates, 0)->font_set_id = -1;
524      Templates->NumClasses++;
525      for (unsigned i = 0; i < MAX_NUM_CLASSES; i++) {
526        if (i < Templates->NumClasses) {
527          if (ClassForClassId(Templates, i) == nullptr) {
528            fprintf(stderr, "Non-contiguous class ids in inttemp\n");
529            exit(1);
530          }
531        } else {
532          if (ClassForClassId(Templates, i) != nullptr) {
533            fprintf(stderr, "Class id %u exceeds NumClassesIn (Templates) %u\n", i,
534                    Templates->NumClasses);
535            exit(1);
536          }
537        }
538      }
539    }
540    if (version_id >= 4) {
541      using namespace std::placeholders; 
542      this->fontinfo_table_.read(fp, std::bind(read_info, _1, _2));
543      if (version_id >= 5) {
544        this->fontinfo_table_.read(fp, std::bind(read_spacing_info, _1, _2));
545      }
546      this->fontset_table_.read(fp, [](auto *f, auto *fs) { return f->DeSerialize(*fs); } );
547    }
548    return (Templates);
549  } &bsol;* ReadIntTemplates */
550  #ifndef GRAPHICS_DISABLED
551  void Classify::ShowMatchDisplay() {
552    InitIntMatchWindowIfReqd();
553    if (ProtoDisplayWindow) {
554      ProtoDisplayWindow->Clear();
555    }
556    if (FeatureDisplayWindow) {
557      FeatureDisplayWindow->Clear();
558    }
559    ClearFeatureSpaceWindow(static_cast<NORM_METHOD>(static_cast<int>(classify_norm_method)),
560                            IntMatchWindow);
561    IntMatchWindow->ZoomToRectangle(INT_MIN_X, INT_MIN_Y, INT_MAX_X, INT_MAX_Y);
562    if (ProtoDisplayWindow) {
563      ProtoDisplayWindow->ZoomToRectangle(INT_MIN_X, INT_MIN_Y, INT_MAX_X, INT_MAX_Y);
564    }
565    if (FeatureDisplayWindow) {
566      FeatureDisplayWindow->ZoomToRectangle(INT_MIN_X, INT_MIN_Y, INT_MAX_X, INT_MAX_Y);
567    }
568  } &bsol;* ShowMatchDisplay */
569  void ClearFeatureSpaceWindow(NORM_METHOD norm_method, ScrollView *window) {
570    window->Clear();
571    window->Pen(ScrollView::GREY);
572    window->Rectangle(0, 0, INT_MAX_X, INT_MAX_Y);
573    if (norm_method == baseline) {
574      window->SetCursor(0, INT_DESCENDER);
575      window->DrawTo(INT_MAX_X, INT_DESCENDER);
576      window->SetCursor(0, INT_BASELINE);
577      window->DrawTo(INT_MAX_X, INT_BASELINE);
578      window->SetCursor(0, INT_XHEIGHT);
579      window->DrawTo(INT_MAX_X, INT_XHEIGHT);
580      window->SetCursor(0, INT_CAPHEIGHT);
581      window->DrawTo(INT_MAX_X, INT_CAPHEIGHT);
582    } else {
583      window->Rectangle(INT_XCENTER - INT_XRADIUS, INT_YCENTER - INT_YRADIUS,
584                        INT_XCENTER + INT_XRADIUS, INT_YCENTER + INT_YRADIUS);
585    }
586  }
587  #endif
588  void Classify::WriteIntTemplates(FILE *File, INT_TEMPLATES_STRUCT *Templates,
589                                   const UNICHARSET &target_unicharset) {
590    INT_CLASS_STRUCT *Class;
591    uint32_t unicharset_size = target_unicharset.size();
592    int version_id = -5; 
593    if (Templates->NumClasses != unicharset_size) {
594      tprintf(
595          "Warning: executing WriteIntTemplates() with %d classes in"
596          " Templates, while target_unicharset size is %" PRIu32 "\n",
597          Templates->NumClasses, unicharset_size);
598    }
599    fwrite(&unicharset_size, sizeof(unicharset_size), 1, File);
600    fwrite(&version_id, sizeof(version_id), 1, File);
601    fwrite(&Templates->NumClassPruners, sizeof(Templates->NumClassPruners), 1, File);
602    fwrite(&Templates->NumClasses, sizeof(Templates->NumClasses), 1, File);
603    for (unsigned i = 0; i < Templates->NumClassPruners; i++) {
604      fwrite(Templates->ClassPruners[i], sizeof(CLASS_PRUNER_STRUCT), 1, File);
605    }
606    for (unsigned i = 0; i < Templates->NumClasses; i++) {
607      Class = Templates->Class[i];
608      fwrite(&Class->NumProtos, sizeof(Class->NumProtos), 1, File);
609      fwrite(&Class->NumProtoSets, sizeof(Class->NumProtoSets), 1, File);
610      ASSERT_HOST(Class->NumConfigs == this->fontset_table_.at(Class->font_set_id).size());
611      fwrite(&Class->NumConfigs, sizeof(Class->NumConfigs), 1, File);
612      for (int j = 0; j < Class->NumConfigs; ++j) {
613        fwrite(&Class->ConfigLengths[j], sizeof(uint16_t), 1, File);
614      }
615      if (MaxNumIntProtosIn(Class) > 0) {
616        fwrite(&Class->ProtoLengths[0], sizeof(uint8_t), MaxNumIntProtosIn(Class), File);
617      }
618      for (int j = 0; j < Class->NumProtoSets; j++) {
619        fwrite(Class->ProtoSets[j], sizeof(PROTO_SET_STRUCT), 1, File);
620      }
621      fwrite(&Class->font_set_id, sizeof(int), 1, File);
622    }
623    using namespace std::placeholders; 
624    this->fontinfo_table_.write(File, std::bind(write_info, _1, _2));
625    this->fontinfo_table_.write(File, std::bind(write_spacing_info, _1, _2));
626    this->fontset_table_.write(File, std::bind(write_set, _1, _2));
627  } &bsol;* WriteIntTemplates */
628  float BucketStart(int Bucket, float Offset, int NumBuckets) {
629    return static_cast<float>(Bucket) / NumBuckets - Offset;
630  } &bsol;* BucketStart */
631  float BucketEnd(int Bucket, float Offset, int NumBuckets) {
632    return static_cast<float>(Bucket + 1) / NumBuckets - Offset;
633  } &bsol;* BucketEnd */
634  void DoFill(FILL_SPEC *FillSpec, CLASS_PRUNER_STRUCT *Pruner, uint32_t ClassMask,
635              uint32_t ClassCount, uint32_t WordIndex) {
636    int X, Y, Angle;
637    uint32_t OldWord;
638    X = FillSpec->X;
639    if (X < 0) {
640      X = 0;
641    }
642    if (X >= NUM_CP_BUCKETS) {
643      X = NUM_CP_BUCKETS - 1;
644    }
645    if (FillSpec->YStart < 0) {
646      FillSpec->YStart = 0;
647    }
648    if (FillSpec->YEnd >= NUM_CP_BUCKETS) {
649      FillSpec->YEnd = NUM_CP_BUCKETS - 1;
650    }
651    for (Y = FillSpec->YStart; Y <= FillSpec->YEnd; Y++) {
652      for (Angle = FillSpec->AngleStart;; CircularIncrement(Angle, NUM_CP_BUCKETS)) {
653        OldWord = Pruner->p[X][Y][Angle][WordIndex];
654        if (ClassCount > (OldWord & ClassMask)) {
655          OldWord &= ~ClassMask;
656          OldWord |= ClassCount;
657          Pruner->p[X][Y][Angle][WordIndex] = OldWord;
658        }
659        if (Angle == FillSpec->AngleEnd) {
660          break;
661        }
662      }
663    }
664  } &bsol;* DoFill */
665  bool FillerDone(TABLE_FILLER *Filler) {
666    FILL_SWITCH *Next;
667    Next = &(Filler->Switch[Filler->NextSwitch]);
668    return Filler->X > Next->X && Next->Type == LastSwitch;
669  } &bsol;* FillerDone */
670  void FillPPCircularBits(uint32_t ParamTable[NUM_PP_BUCKETS][WERDS_PER_PP_VECTOR], int Bit,
671                          float Center, float Spread, bool debug) {
672    int i, FirstBucket, LastBucket;
673    if (Spread > 0.5) {
674      Spread = 0.5;
675    }
676    FirstBucket = static_cast<int>(std::floor((Center - Spread) * NUM_PP_BUCKETS));
677    if (FirstBucket < 0) {
678      FirstBucket += NUM_PP_BUCKETS;
679    }
680    LastBucket = static_cast<int>(std::floor((Center + Spread) * NUM_PP_BUCKETS));
681    if (LastBucket >= NUM_PP_BUCKETS) {
682      LastBucket -= NUM_PP_BUCKETS;
683    }
684    if (debug) {
685      tprintf("Circular fill from %d to %d", FirstBucket, LastBucket);
686    }
687    for (i = FirstBucket; true; CircularIncrement(i, NUM_PP_BUCKETS)) {
688      SET_BIT(ParamTable[i], Bit);
689      if (i == LastBucket) {
690        break;
691      }
692    }
693  } &bsol;* FillPPCircularBits */
694  void FillPPLinearBits(uint32_t ParamTable[NUM_PP_BUCKETS][WERDS_PER_PP_VECTOR], int Bit,
695                        float Center, float Spread, bool debug) {
696    int i, FirstBucket, LastBucket;
697    FirstBucket = static_cast<int>(std::floor((Center - Spread) * NUM_PP_BUCKETS));
698    if (FirstBucket < 0) {
699      FirstBucket = 0;
700    }
701    LastBucket = static_cast<int>(std::floor((Center + Spread) * NUM_PP_BUCKETS));
702    if (LastBucket >= NUM_PP_BUCKETS) {
703      LastBucket = NUM_PP_BUCKETS - 1;
704    }
705    if (debug) {
706      tprintf("Linear fill from %d to %d", FirstBucket, LastBucket);
707    }
708    for (i = FirstBucket; i <= LastBucket; i++) {
709      SET_BIT(ParamTable[i], Bit);
710    }
711  } &bsol;* FillPPLinearBits */
712  #ifndef GRAPHICS_DISABLED
713  CLASS_ID Classify::GetClassToDebug(const char *Prompt, bool *adaptive_on, bool *pretrained_on,
714                                     int *shape_id) {
715    tprintf("%s\n", Prompt);
716    SVEventType ev_type;
717    int unichar_id = INVALID_UNICHAR_ID;
718    do {
719      auto ev = IntMatchWindow->AwaitEvent(SVET_ANY);
720      ev_type = ev->type;
721      if (ev_type == SVET_POPUP) {
722        if (ev->command_id == IDA_SHAPE_INDEX) {
723          if (shape_table_ != nullptr) {
724            *shape_id = atoi(ev->parameter);
725            *adaptive_on = false;
726            *pretrained_on = true;
727            if (*shape_id >= 0 && static_cast<unsigned>(*shape_id) < shape_table_->NumShapes()) {
728              int font_id;
729              shape_table_->GetFirstUnicharAndFont(*shape_id, &unichar_id, &font_id);
730              tprintf("Shape %d, first unichar=%d, font=%d\n", *shape_id, unichar_id, font_id);
731              return unichar_id;
732            }
733            tprintf("Shape index '%s' not found in shape table\n", ev->parameter);
734          } else {
735            tprintf("No shape table loaded!\n");
736          }
737        } else {
738          if (unicharset.contains_unichar(ev->parameter)) {
739            unichar_id = unicharset.unichar_to_id(ev->parameter);
740            if (ev->command_id == IDA_ADAPTIVE) {
741              *adaptive_on = true;
742              *pretrained_on = false;
743              *shape_id = -1;
744            } else if (ev->command_id == IDA_STATIC) {
745              *adaptive_on = false;
746              *pretrained_on = true;
747            } else {
748              *adaptive_on = true;
749              *pretrained_on = true;
750            }
751            if (ev->command_id == IDA_ADAPTIVE || shape_table_ == nullptr) {
752              *shape_id = -1;
753              return unichar_id;
754            }
755            for (unsigned s = 0; s < shape_table_->NumShapes(); ++s) {
756              if (shape_table_->GetShape(s).ContainsUnichar(unichar_id)) {
757                tprintf("%s\n", shape_table_->DebugStr(s).c_str());
758              }
759            }
760          } else {
761            tprintf("Char class '%s' not found in unicharset", ev->parameter);
762          }
763        }
764      }
765    } while (ev_type != SVET_CLICK);
766    return 0;
767  } &bsol;* GetClassToDebug */
768  #endif
769  void GetCPPadsForLevel(int Level, float *EndPad, float *SidePad, float *AnglePad) {
770    switch (Level) {
771      case 0:
772        *EndPad = classify_cp_end_pad_loose * GetPicoFeatureLength();
773        *SidePad = classify_cp_side_pad_loose * GetPicoFeatureLength();
774        *AnglePad = classify_cp_angle_pad_loose / 360.0;
775        break;
776      case 1:
777        *EndPad = classify_cp_end_pad_medium * GetPicoFeatureLength();
778        *SidePad = classify_cp_side_pad_medium * GetPicoFeatureLength();
779        *AnglePad = classify_cp_angle_pad_medium / 360.0;
780        break;
781      case 2:
782        *EndPad = classify_cp_end_pad_tight * GetPicoFeatureLength();
783        *SidePad = classify_cp_side_pad_tight * GetPicoFeatureLength();
784        *AnglePad = classify_cp_angle_pad_tight / 360.0;
785        break;
786      default:
787        *EndPad = classify_cp_end_pad_tight * GetPicoFeatureLength();
788        *SidePad = classify_cp_side_pad_tight * GetPicoFeatureLength();
789        *AnglePad = classify_cp_angle_pad_tight / 360.0;
790        break;
791    }
792    if (*AnglePad > 0.5) {
793      *AnglePad = 0.5;
794    }
795  } &bsol;* GetCPPadsForLevel */
796  ScrollView::Color GetMatchColorFor(float Evidence) {
797    assert(Evidence >= 0.0);
798    assert(Evidence <= 1.0);
799    if (Evidence >= 0.90) {
800      return ScrollView::WHITE;
801    } else if (Evidence >= 0.75) {
802      return ScrollView::GREEN;
803    } else if (Evidence >= 0.50) {
804      return ScrollView::RED;
805    } else {
806      return ScrollView::BLUE;
807    }
808  } &bsol;* GetMatchColorFor */
809  void GetNextFill(TABLE_FILLER *Filler, FILL_SPEC *Fill) {
810    FILL_SWITCH *Next;
811    Fill->AngleStart = Filler->AngleStart;
812    Fill->AngleEnd = Filler->AngleEnd;
813    Fill->X = Filler->X;
814    Fill->YStart = Filler->YStart >> 8;
815    Fill->YEnd = Filler->YEnd >> 8;
816    Next = &(Filler->Switch[Filler->NextSwitch]);
817    while (Filler->X >= Next->X) {
818      Fill->X = Filler->X = Next->X;
819      if (Next->Type == StartSwitch) {
820        Fill->YStart = Next->Y;
821        Filler->StartDelta = Next->Delta;
822        Filler->YStart = Next->YInit;
823      } else if (Next->Type == EndSwitch) {
824        Fill->YEnd = Next->Y;
825        Filler->EndDelta = Next->Delta;
826        Filler->YEnd = Next->YInit;
827      } else { &bsol;* Type must be LastSwitch */
828        break;
829      }
830      Filler->NextSwitch++;
831      Next = &(Filler->Switch[Filler->NextSwitch]);
832    }
833    Filler->X++;
834    Filler->YStart += Filler->StartDelta;
835    Filler->YEnd += Filler->EndDelta;
836  } &bsol;* GetNextFill */
837  void InitTableFiller(float EndPad, float SidePad, float AnglePad, PROTO_STRUCT *Proto, TABLE_FILLER *Filler)
838  #define XS X_SHIFT
839  #define YS Y_SHIFT
840  #define AS ANGLE_SHIFT
841  #define NB NUM_CP_BUCKETS
842  {
<span onclick='openModal()' class='match'>843    float Angle;
844    float X, Y, HalfLength;
845    float Cos, Sin;
846    float XAdjust, YAdjust;
847    FPOINT Start, Switch1, Switch2, End;
848    int S1 = 0;
849    int S2 = 1;
850    Angle = Proto->Angle;
851    X = Proto->X;
852    Y = Proto->Y;
</span>853    HalfLength = Proto->Length / 2.0;
854    Filler->AngleStart = CircBucketFor(Angle - AnglePad, AS, NB);
855    Filler->AngleEnd = CircBucketFor(Angle + AnglePad, AS, NB);
856    Filler->NextSwitch = 0;
857    if (fabs(Angle - 0.0) < HV_TOLERANCE || fabs(Angle - 0.5) < HV_TOLERANCE) {
858      Filler->X = Bucket8For(X - HalfLength - EndPad, XS, NB);
859      Filler->YStart = Bucket16For(Y - SidePad, YS, NB * 256);
860      Filler->YEnd = Bucket16For(Y + SidePad, YS, NB * 256);
861      Filler->StartDelta = 0;
862      Filler->EndDelta = 0;
863      Filler->Switch[0].Type = LastSwitch;
864      Filler->Switch[0].X = Bucket8For(X + HalfLength + EndPad, XS, NB);
865    } else if (fabs(Angle - 0.25) < HV_TOLERANCE || fabs(Angle - 0.75) < HV_TOLERANCE) {
866      Filler->X = Bucket8For(X - SidePad, XS, NB);
867      Filler->YStart = Bucket16For(Y - HalfLength - EndPad, YS, NB * 256);
868      Filler->YEnd = Bucket16For(Y + HalfLength + EndPad, YS, NB * 256);
869      Filler->StartDelta = 0;
870      Filler->EndDelta = 0;
871      Filler->Switch[0].Type = LastSwitch;
872      Filler->Switch[0].X = Bucket8For(X + SidePad, XS, NB);
873    } else {
874      if ((Angle > 0.0 && Angle < 0.25) || (Angle > 0.5 && Angle < 0.75)) {
875        Angle *= 2.0 * M_PI;
876        Cos = fabs(std::cos(Angle));
877        Sin = fabs(std::sin(Angle));
878        Start.x = X - (HalfLength + EndPad) * Cos - SidePad * Sin;
879        Start.y = Y - (HalfLength + EndPad) * Sin + SidePad * Cos;
880        End.x = 2.0 * X - Start.x;
881        End.y = 2.0 * Y - Start.y;
882        Switch1.x = X - (HalfLength + EndPad) * Cos + SidePad * Sin;
883        Switch1.y = Y - (HalfLength + EndPad) * Sin - SidePad * Cos;
884        Switch2.x = 2.0 * X - Switch1.x;
885        Switch2.y = 2.0 * Y - Switch1.y;
886        if (Switch1.x > Switch2.x) {
887          S1 = 1;
888          S2 = 0;
889        }
890        Filler->X = Bucket8For(Start.x, XS, NB);
891        Filler->StartDelta = -static_cast<int16_t>((Cos / Sin) * 256);
892        Filler->EndDelta = static_cast<int16_t>((Sin / Cos) * 256);
893        XAdjust = BucketEnd(Filler->X, XS, NB) - Start.x;
894        YAdjust = XAdjust * Cos / Sin;
895        Filler->YStart = Bucket16For(Start.y - YAdjust, YS, NB * 256);
896        YAdjust = XAdjust * Sin / Cos;
897        Filler->YEnd = Bucket16For(Start.y + YAdjust, YS, NB * 256);
898        Filler->Switch[S1].Type = StartSwitch;
899        Filler->Switch[S1].X = Bucket8For(Switch1.x, XS, NB);
900        Filler->Switch[S1].Y = Bucket8For(Switch1.y, YS, NB);
901        XAdjust = Switch1.x - BucketStart(Filler->Switch[S1].X, XS, NB);
902        YAdjust = XAdjust * Sin / Cos;
903        Filler->Switch[S1].YInit = Bucket16For(Switch1.y - YAdjust, YS, NB * 256);
904        Filler->Switch[S1].Delta = Filler->EndDelta;
905        Filler->Switch[S2].Type = EndSwitch;
906        Filler->Switch[S2].X = Bucket8For(Switch2.x, XS, NB);
907        Filler->Switch[S2].Y = Bucket8For(Switch2.y, YS, NB);
908        XAdjust = Switch2.x - BucketStart(Filler->Switch[S2].X, XS, NB);
909        YAdjust = XAdjust * Cos / Sin;
910        Filler->Switch[S2].YInit = Bucket16For(Switch2.y + YAdjust, YS, NB * 256);
911        Filler->Switch[S2].Delta = Filler->StartDelta;
912        Filler->Switch[2].Type = LastSwitch;
913        Filler->Switch[2].X = Bucket8For(End.x, XS, NB);
914      } else {
915        Angle *= 2.0 * M_PI;
916        Cos = fabs(std::cos(Angle));
917        Sin = fabs(std::sin(Angle));
918        Start.x = X - (HalfLength + EndPad) * Cos - SidePad * Sin;
919        Start.y = Y + (HalfLength + EndPad) * Sin - SidePad * Cos;
920        End.x = 2.0 * X - Start.x;
921        End.y = 2.0 * Y - Start.y;
922        Switch1.x = X - (HalfLength + EndPad) * Cos + SidePad * Sin;
923        Switch1.y = Y + (HalfLength + EndPad) * Sin + SidePad * Cos;
924        Switch2.x = 2.0 * X - Switch1.x;
925        Switch2.y = 2.0 * Y - Switch1.y;
926        if (Switch1.x > Switch2.x) {
927          S1 = 1;
928          S2 = 0;
929        }
930        Filler->X = Bucket8For(Start.x, XS, NB);
931        Filler->StartDelta = static_cast<int16_t>(
932            ClipToRange<int>(-IntCastRounded((Sin / Cos) * 256), INT16_MIN, INT16_MAX));
933        Filler->EndDelta = static_cast<int16_t>(
934            ClipToRange<int>(IntCastRounded((Cos / Sin) * 256), INT16_MIN, INT16_MAX));
935        XAdjust = BucketEnd(Filler->X, XS, NB) - Start.x;
936        YAdjust = XAdjust * Sin / Cos;
937        Filler->YStart = Bucket16For(Start.y - YAdjust, YS, NB * 256);
938        YAdjust = XAdjust * Cos / Sin;
939        Filler->YEnd = Bucket16For(Start.y + YAdjust, YS, NB * 256);
940        Filler->Switch[S1].Type = EndSwitch;
941        Filler->Switch[S1].X = Bucket8For(Switch1.x, XS, NB);
942        Filler->Switch[S1].Y = Bucket8For(Switch1.y, YS, NB);
943        XAdjust = Switch1.x - BucketStart(Filler->Switch[S1].X, XS, NB);
944        YAdjust = XAdjust * Sin / Cos;
945        Filler->Switch[S1].YInit = Bucket16For(Switch1.y + YAdjust, YS, NB * 256);
946        Filler->Switch[S1].Delta = Filler->StartDelta;
947        Filler->Switch[S2].Type = StartSwitch;
948        Filler->Switch[S2].X = Bucket8For(Switch2.x, XS, NB);
949        Filler->Switch[S2].Y = Bucket8For(Switch2.y, YS, NB);
950        XAdjust = Switch2.x - BucketStart(Filler->Switch[S2].X, XS, NB);
951        YAdjust = XAdjust * Cos / Sin;
952        Filler->Switch[S2].YInit = Bucket16For(Switch2.y - YAdjust, YS, NB * 256);
953        Filler->Switch[S2].Delta = Filler->EndDelta;
954        Filler->Switch[2].Type = LastSwitch;
955        Filler->Switch[2].X = Bucket8For(End.x, XS, NB);
956      }
957    }
958  } &bsol;* InitTableFiller */
959  #ifndef GRAPHICS_DISABLED
960  void RenderIntFeature(ScrollView *window, const INT_FEATURE_STRUCT *Feature,
961                        ScrollView::Color color) {
962    float X, Y, Dx, Dy, Length;
963    window->Pen(color);
964    assert(Feature != nullptr);
965    assert(color != 0);
966    X = Feature->X;
967    Y = Feature->Y;
968    Length = GetPicoFeatureLength() * 0.7 * INT_CHAR_NORM_RANGE;
969    Dx = (Length / 2.0) * cos((Feature->Theta / 256.0) * 2.0 * M_PI - M_PI);
970    Dy = (Length / 2.0) * sin((Feature->Theta / 256.0) * 2.0 * M_PI - M_PI);
971    window->SetCursor(X, Y);
972    window->DrawTo(X + Dx, Y + Dy);
973  } &bsol;* RenderIntFeature */
974  void RenderIntProto(ScrollView *window, INT_CLASS_STRUCT *Class, PROTO_ID ProtoId,
975                      ScrollView::Color color) {
976    INT_PROTO_STRUCT *Proto;
977    int ProtoSetIndex;
978    int ProtoWordIndex;
979    float Length;
980    int Xmin, Xmax, Ymin, Ymax;
981    float X, Y, Dx, Dy;
982    uint32_t ProtoMask;
983    int Bucket;
984    assert(ProtoId >= 0);
985    assert(Class != nullptr);
986    assert(ProtoId < Class->NumProtos);
987    assert(color != 0);
988    window->Pen(color);
989    auto ProtoSet = Class->ProtoSets[SetForProto(ProtoId)];
990    ProtoSetIndex = IndexForProto(ProtoId);
991    Proto = &(ProtoSet->Protos[ProtoSetIndex]);
992    Length = (Class->ProtoLengths[ProtoId] * GetPicoFeatureLength() * INT_CHAR_NORM_RANGE);
993    ProtoMask = PPrunerMaskFor(ProtoId);
994    ProtoWordIndex = PPrunerWordIndexFor(ProtoId);
995    Xmin = Ymin = NUM_PP_BUCKETS;
996    Xmax = Ymax = 0;
997    for (Bucket = 0; Bucket < NUM_PP_BUCKETS; Bucket++) {
998      if (ProtoMask & ProtoSet->ProtoPruner[PRUNER_X][Bucket][ProtoWordIndex]) {
999        UpdateRange(Bucket, &Xmin, &Xmax);
1000      }
1001      if (ProtoMask & ProtoSet->ProtoPruner[PRUNER_Y][Bucket][ProtoWordIndex]) {
1002        UpdateRange(Bucket, &Ymin, &Ymax);
1003      }
1004    }
1005    X = (Xmin + Xmax + 1) / 2.0 * PROTO_PRUNER_SCALE;
1006    Y = (Ymin + Ymax + 1) / 2.0 * PROTO_PRUNER_SCALE;
1007    Dx = (Length / 2.0) * cos((Proto->Angle / 256.0) * 2.0 * M_PI - M_PI);
1008    Dy = (Length / 2.0) * sin((Proto->Angle / 256.0) * 2.0 * M_PI - M_PI);
1009    window->SetCursor(X - Dx, Y - Dy);
1010    window->DrawTo(X + Dx, Y + Dy);
1011  } &bsol;* RenderIntProto */
1012  #endif
1013  #ifndef GRAPHICS_DISABLED
1014  void InitIntMatchWindowIfReqd() {
1015    if (IntMatchWindow == nullptr) {
1016      IntMatchWindow = CreateFeatureSpaceWindow("IntMatchWindow", 50, 200);
1017      auto *popup_menu = new SVMenuNode();
1018      popup_menu->AddChild("Debug Adapted classes", IDA_ADAPTIVE, "x", "Class to debug");
1019      popup_menu->AddChild("Debug Static classes", IDA_STATIC, "x", "Class to debug");
1020      popup_menu->AddChild("Debug Both", IDA_BOTH, "x", "Class to debug");
1021      popup_menu->AddChild("Debug Shape Index", IDA_SHAPE_INDEX, "0", "Index to debug");
1022      popup_menu->BuildMenu(IntMatchWindow, false);
1023    }
1024  }
1025  void InitProtoDisplayWindowIfReqd() {
1026    if (ProtoDisplayWindow == nullptr) {
1027      ProtoDisplayWindow = CreateFeatureSpaceWindow("ProtoDisplayWindow", 550, 200);
1028    }
1029  }
1030  void InitFeatureDisplayWindowIfReqd() {
1031    if (FeatureDisplayWindow == nullptr) {
1032      FeatureDisplayWindow = CreateFeatureSpaceWindow("FeatureDisplayWindow", 50, 700);
1033    }
1034  }
1035  ScrollView *CreateFeatureSpaceWindow(const char *name, int xpos, int ypos) {
1036    return new ScrollView(name, xpos, ypos, 520, 520, 260, 260, true);
1037  }
1038  #endif 
1039  } 
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-topitch.cpp</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #  include "config_auto.h"
3  #endif
4  #include "topitch.h"
5  #include "blobbox.h"
6  #include "drawtord.h"
7  #include "makerow.h"
8  #include "pithsync.h"
9  #include "pitsync1.h"
10  #include "statistc.h"
11  #include "tovars.h"
12  #include "wordseg.h"
13  #include "helpers.h"
14  #include <memory>
15  namespace tesseract {
16  static BOOL_VAR(textord_all_prop, false, "All doc is proportial text");
17  BOOL_VAR(textord_debug_pitch_test, false, "Debug on fixed pitch test");
18  static BOOL_VAR(textord_disable_pitch_test, false, "Turn off dp fixed pitch algorithm");
19  BOOL_VAR(textord_fast_pitch_test, false, "Do even faster pitch algorithm");
20  BOOL_VAR(textord_debug_pitch_metric, false, "Write full metric stuff");
21  BOOL_VAR(textord_show_row_cuts, false, "Draw row-level cuts");
22  BOOL_VAR(textord_show_page_cuts, false, "Draw page-level cuts");
23  BOOL_VAR(textord_blockndoc_fixed, false, "Attempt whole doc/block fixed pitch");
24  double_VAR(textord_projection_scale, 0.200, "Ding rate for mid-cuts");
25  double_VAR(textord_balance_factor, 1.0, "Ding rate for unbalanced char cells");
26  #define BLOCK_STATS_CLUSTERS 10
27  #define MAX_ALLOWED_PITCH 100 
28  static int sort_floats(const void *arg1, const void *arg2) {
29    float diff = *reinterpret_cast<const float *>(arg1) - *reinterpret_cast<const float *>(arg2);
30    if (diff > 0) {
31      return 1;
32    } else if (diff < 0) {
33      return -1;
34    } else {
35      return 0;
36    }
37  }
38  void compute_fixed_pitch(ICOORD page_tr,             
39                           TO_BLOCK_LIST *port_blocks, 
40                           float gradient,             
41                           FCOORD rotation,            
42                           bool testing_on) {          
43    TO_BLOCK_IT block_it;                              
44    TO_BLOCK *block;                                   
45    TO_ROW *row;                                       
46    int block_index;                                   
47    int row_index;                                     
48  #ifndef GRAPHICS_DISABLED
49    if (textord_show_initial_words && testing_on) {
50      if (to_win == nullptr) {
51        create_to_win(page_tr);
52      }
53    }
54  #endif
55    block_it.set_to_list(port_blocks);
56    block_index = 1;
57    for (block_it.mark_cycle_pt(); !block_it.cycled_list(); block_it.forward()) {
58      block = block_it.data();
59      compute_block_pitch(block, rotation, block_index, testing_on);
60      block_index++;
61    }
62    if (!try_doc_fixed(page_tr, port_blocks, gradient)) {
63      block_index = 1;
64      for (block_it.mark_cycle_pt(); !block_it.cycled_list(); block_it.forward()) {
65        block = block_it.data();
66        if (!try_block_fixed(block, block_index)) {
67          try_rows_fixed(block, block_index, testing_on);
68        }
69        block_index++;
70      }
71    }
72    block_index = 1;
73    for (block_it.mark_cycle_pt(); !block_it.cycled_list(); block_it.forward()) {
74      block = block_it.data();
75      POLY_BLOCK *pb = block->block->pdblk.poly_block();
76      if (pb != nullptr && !pb->IsText()) {
77        continue; 
78      }
79      TO_ROW_IT row_it(block->get_rows());
80      row_index = 1;
81      for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
82        row = row_it.data();
83        fix_row_pitch(row, block, port_blocks, row_index, block_index);
84        row_index++;
85      }
86      block_index++;
87    }
88  #ifndef GRAPHICS_DISABLED
89    if (textord_show_initial_words && testing_on) {
90      ScrollView::Update();
91    }
92  #endif
93  }
94  void fix_row_pitch(TO_ROW *bad_row,        
95                     TO_BLOCK *bad_block,    
96                     TO_BLOCK_LIST *blocks,  
97                     int32_t row_target,     
98                     int32_t block_target) { 
99    int16_t mid_cuts;
100    int block_votes;               
<span onclick='openModal()' class='match'>101    int like_votes;                
102    int other_votes;               
103    int block_index;               
104    int row_index;                 
105    int maxwidth;                  
106    TO_BLOCK_IT block_it = blocks; 
107    TO_BLOCK *block;               
108    TO_ROW *row;                   
109    float sp_sd;                   
110    STATS block_stats;             
111    STATS like_stats;              
112    block_votes = like_votes = other_votes = 0;
113    maxwidth = static_cast<int32_t>(ceil(bad_row->xheight * textord_words_maxspace));
</span>114    if (bad_row->pitch_decision != PITCH_DEF_FIXED && bad_row->pitch_decision != PITCH_DEF_PROP) {
115      block_stats.set_range(0, maxwidth - 1);
116      like_stats.set_range(0, maxwidth - 1);
117      block_index = 1;
118      for (block_it.mark_cycle_pt(); !block_it.cycled_list(); block_it.forward()) {
119        block = block_it.data();
120        POLY_BLOCK *pb = block->block->pdblk.poly_block();
121        if (pb != nullptr && !pb->IsText()) {
122          continue; 
123        }
124        row_index = 1;
125        TO_ROW_IT row_it(block->get_rows());
126        for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
127          row = row_it.data();
128          if ((bad_row->all_caps &&
129               row->xheight + row->ascrise <
130                   (bad_row->xheight + bad_row->ascrise) * (1 + textord_pitch_rowsimilarity) &&
131               row->xheight + row->ascrise >
132                   (bad_row->xheight + bad_row->ascrise) * (1 - textord_pitch_rowsimilarity)) ||
133              (!bad_row->all_caps &&
134               row->xheight < bad_row->xheight * (1 + textord_pitch_rowsimilarity) &&
135               row->xheight > bad_row->xheight * (1 - textord_pitch_rowsimilarity))) {
136            if (block_index == block_target) {
137              if (row->pitch_decision == PITCH_DEF_FIXED) {
138                block_votes += textord_words_veto_power;
139                block_stats.add(static_cast<int32_t>(row->fixed_pitch), textord_words_veto_power);
140              } else if (row->pitch_decision == PITCH_MAYBE_FIXED ||
141                         row->pitch_decision == PITCH_CORR_FIXED) {
142                block_votes++;
143                block_stats.add(static_cast<int32_t>(row->fixed_pitch), 1);
144              } else if (row->pitch_decision == PITCH_DEF_PROP) {
145                block_votes -= textord_words_veto_power;
146              } else if (row->pitch_decision == PITCH_MAYBE_PROP ||
147                         row->pitch_decision == PITCH_CORR_PROP) {
148                block_votes--;
149              }
150            } else {
151              if (row->pitch_decision == PITCH_DEF_FIXED) {
152                like_votes += textord_words_veto_power;
153                like_stats.add(static_cast<int32_t>(row->fixed_pitch), textord_words_veto_power);
154              } else if (row->pitch_decision == PITCH_MAYBE_FIXED ||
155                         row->pitch_decision == PITCH_CORR_FIXED) {
156                like_votes++;
157                like_stats.add(static_cast<int32_t>(row->fixed_pitch), 1);
158              } else if (row->pitch_decision == PITCH_DEF_PROP) {
159                like_votes -= textord_words_veto_power;
160              } else if (row->pitch_decision == PITCH_MAYBE_PROP ||
161                         row->pitch_decision == PITCH_CORR_PROP) {
162                like_votes--;
163              }
164            }
165          } else {
166            if (row->pitch_decision == PITCH_DEF_FIXED) {
167              other_votes += textord_words_veto_power;
168            } else if (row->pitch_decision == PITCH_MAYBE_FIXED ||
169                       row->pitch_decision == PITCH_CORR_FIXED) {
170              other_votes++;
171            } else if (row->pitch_decision == PITCH_DEF_PROP) {
172              other_votes -= textord_words_veto_power;
173            } else if (row->pitch_decision == PITCH_MAYBE_PROP ||
174                       row->pitch_decision == PITCH_CORR_PROP) {
175              other_votes--;
176            }
177          }
178          row_index++;
179        }
180        block_index++;
181      }
182      if (block_votes > textord_words_veto_power) {
183        bad_row->fixed_pitch = block_stats.ile(0.5);
184        bad_row->pitch_decision = PITCH_CORR_FIXED;
185      } else if (block_votes <= textord_words_veto_power && like_votes > 0) {
186        bad_row->fixed_pitch = like_stats.ile(0.5);
187        bad_row->pitch_decision = PITCH_CORR_FIXED;
188      } else {
189        bad_row->pitch_decision = PITCH_CORR_PROP;
190        if (block_votes == 0 && like_votes == 0 && other_votes > 0 &&
191            (textord_debug_pitch_test || textord_debug_pitch_metric)) {
192          tprintf(
193              "Warning:row %d of block %d set prop with no like rows against "
194              "trend\n",
195              row_target, block_target);
196        }
197      }
198    }
199    if (textord_debug_pitch_metric) {
200      tprintf(":b_votes=%d:l_votes=%d:o_votes=%d", block_votes, like_votes, other_votes);
201      tprintf("x=%g:asc=%g\n", bad_row->xheight, bad_row->ascrise);
202    }
203    if (bad_row->pitch_decision == PITCH_CORR_FIXED) {
204      if (bad_row->fixed_pitch < textord_min_xheight) {
205        if (block_votes > 0) {
206          bad_row->fixed_pitch = block_stats.ile(0.5);
207        } else if (block_votes == 0 && like_votes > 0) {
208          bad_row->fixed_pitch = like_stats.ile(0.5);
209        } else {
210          tprintf("Warning:guessing pitch as xheight on row %d, block %d\n", row_target,
211                  block_target);
212          bad_row->fixed_pitch = bad_row->xheight;
213        }
214      }
215      if (bad_row->fixed_pitch < textord_min_xheight) {
216        bad_row->fixed_pitch = (float)textord_min_xheight;
217      }
218      bad_row->kern_size = bad_row->fixed_pitch / 4;
219      bad_row->min_space = static_cast<int32_t>(bad_row->fixed_pitch * 0.6);
220      bad_row->max_nonspace = static_cast<int32_t>(bad_row->fixed_pitch * 0.4);
221      bad_row->space_threshold = (bad_row->min_space + bad_row->max_nonspace) / 2;
222      bad_row->space_size = bad_row->fixed_pitch;
223      if (bad_row->char_cells.empty() && !bad_row->blob_list()->empty()) {
224        tune_row_pitch(bad_row, &bad_row->projection, bad_row->projection_left,
225                       bad_row->projection_right,
226                       (bad_row->fixed_pitch + bad_row->max_nonspace * 3) / 4, bad_row->fixed_pitch,
227                       sp_sd, mid_cuts, &bad_row->char_cells, false);
228      }
229    } else if (bad_row->pitch_decision == PITCH_CORR_PROP ||
230               bad_row->pitch_decision == PITCH_DEF_PROP) {
231      bad_row->fixed_pitch = 0.0f;
232      bad_row->char_cells.clear();
233    }
234  }
235  void compute_block_pitch(TO_BLOCK *block,     
236                           FCOORD rotation,     
237                           int32_t block_index, 
238                           bool testing_on) {   
239    TBOX block_box;                             
240    block_box = block->block->pdblk.bounding_box();
241    if (testing_on && textord_debug_pitch_test) {
242      tprintf("Block %d at (%d,%d)->(%d,%d)\n", block_index, block_box.left(), block_box.bottom(),
243              block_box.right(), block_box.top());
244    }
245    block->min_space = static_cast<int32_t>(floor(block->xheight * textord_words_default_minspace));
246    block->max_nonspace = static_cast<int32_t>(ceil(block->xheight * textord_words_default_nonspace));
247    block->fixed_pitch = 0.0f;
248    block->space_size = static_cast<float>(block->min_space);
249    block->kern_size = static_cast<float>(block->max_nonspace);
250    block->pr_nonsp = block->xheight * words_default_prop_nonspace;
251    block->pr_space = block->pr_nonsp * textord_spacesize_ratioprop;
252    if (!block->get_rows()->empty()) {
253      ASSERT_HOST(block->xheight > 0);
254      find_repeated_chars(block, textord_show_initial_words && testing_on);
255  #ifndef GRAPHICS_DISABLED
256      if (textord_show_initial_words && testing_on) {
257        ScrollView::Update();
258      }
259  #endif
260      compute_rows_pitch(block, block_index, textord_debug_pitch_test && testing_on);
261    }
262  }
263  bool compute_rows_pitch( 
264      TO_BLOCK *block,     
265      int32_t block_index, 
266      bool testing_on      
267  ) {
268    int32_t maxwidth;   
269    TO_ROW *row;        
270    int32_t row_index;  
271    float lower, upper; 
272    TO_ROW_IT row_it = block->get_rows();
273    row_index = 1;
274    for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
275      row = row_it.data();
276      ASSERT_HOST(row->xheight > 0);
277      row->compute_vertical_projection();
278      maxwidth = static_cast<int32_t>(ceil(row->xheight * textord_words_maxspace));
279      if (row_pitch_stats(row, maxwidth, testing_on) &&
280          find_row_pitch(row, maxwidth, textord_dotmatrix_gap + 1, block, block_index, row_index,
281                         testing_on)) {
282        if (row->fixed_pitch == 0) {
283          lower = row->pr_nonsp;
284          upper = row->pr_space;
285          row->space_size = upper;
286          row->kern_size = lower;
287        }
288      } else {
289        row->fixed_pitch = 0.0f; 
290        row->pitch_decision = PITCH_DUNNO;
291      }
292      row_index++;
293    }
294    return false;
295  }
296  bool try_doc_fixed(             
297      ICOORD page_tr,             
298      TO_BLOCK_LIST *port_blocks, 
299      float gradient              
300  ) {
301    int16_t master_x; 
302    int16_t pitch;    
303    int x;            
304    int prop_blocks;  
305    int fixed_blocks;
306    int total_row_count; 
307    TO_BLOCK_IT block_it = port_blocks;
308    TO_BLOCK *block;         
309    TO_ROW *row;             
310    int16_t projection_left; 
311    int16_t projection_right;
312    int16_t row_left; 
313    int16_t row_right;
314    float master_y;     
315    float shift_factor; 
316    float final_pitch;  
317    float row_y;        
318    STATS projection;   
319    STATS pitches(0, MAX_ALLOWED_PITCH - 1);
320    float sp_sd;      
321    int16_t mid_cuts; 
322    float pitch_sd;   
323    if (!textord_blockndoc_fixed ||
324        block_it.empty() || block_it.data()->get_rows()->empty()) {
325      return false;
326    }
327    shift_factor = gradient / (gradient * gradient + 1);
328    TO_ROW_IT row_it(block_it.data()->get_rows());
329    master_x = row_it.data()->projection_left;
330    master_y = row_it.data()->baseline.y(master_x);
331    projection_left = INT16_MAX;
332    projection_right = -INT16_MAX;
333    prop_blocks = 0;
334    fixed_blocks = 0;
335    total_row_count = 0;
336    for (block_it.mark_cycle_pt(); !block_it.cycled_list(); block_it.forward()) {
337      block = block_it.data();
338      row_it.set_to_list(block->get_rows());
339      for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
340        row = row_it.data();
341        total_row_count++;
342        if (row->fixed_pitch > 0) {
343          pitches.add(static_cast<int32_t>(row->fixed_pitch), 1);
344        }
345        row_y = row->baseline.y(master_x);
346        row_left = static_cast<int16_t>(row->projection_left - shift_factor * (master_y - row_y));
347        row_right = static_cast<int16_t>(row->projection_right - shift_factor * (master_y - row_y));
348        if (row_left < projection_left) {
349          projection_left = row_left;
350        }
351        if (row_right > projection_right) {
352          projection_right = row_right;
353        }
354      }
355    }
356    if (pitches.get_total() == 0) {
357      return false;
358    }
359    projection.set_range(projection_left, projection_right - 1);
360    for (block_it.mark_cycle_pt(); !block_it.cycled_list(); block_it.forward()) {
361      block = block_it.data();
362      row_it.set_to_list(block->get_rows());
363      for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
364        row = row_it.data();
365        row_y = row->baseline.y(master_x);
366        row_left = static_cast<int16_t>(row->projection_left - shift_factor * (master_y - row_y));
367        for (x = row->projection_left; x < row->projection_right; x++, row_left++) {
368          projection.add(row_left, row->projection.pile_count(x));
369        }
370      }
371    }
372    row_it.set_to_list(block_it.data()->get_rows());
373    row = row_it.data();
374  #ifndef GRAPHICS_DISABLED
375    if (textord_show_page_cuts && to_win != nullptr) {
376      projection.plot(to_win, projection_left, row->intercept(), 1.0f, -1.0f, ScrollView::CORAL);
377    }
378  #endif
379    final_pitch = pitches.ile(0.5);
380    pitch = static_cast<int16_t>(final_pitch);
381    pitch_sd = tune_row_pitch(row, &projection, projection_left, projection_right, pitch * 0.75,
382                              final_pitch, sp_sd, mid_cuts, &row->char_cells, false);
383    if (textord_debug_pitch_metric) {
384      tprintf(
385          "try_doc:props=%d:fixed=%d:pitch=%d:final_pitch=%g:pitch_sd=%g:sp_sd=%"
386          "g:sd/trc=%g:sd/p=%g:sd/trc/p=%g\n",
387          prop_blocks, fixed_blocks, pitch, final_pitch, pitch_sd, sp_sd, pitch_sd / total_row_count,
388          pitch_sd / pitch, pitch_sd / total_row_count / pitch);
389    }
390  #ifndef GRAPHICS_DISABLED
391    if (textord_show_page_cuts && to_win != nullptr) {
392      float row_shift;              
393      ICOORDELT_LIST *master_cells; 
394      master_cells = &row->char_cells;
395      for (block_it.mark_cycle_pt(); !block_it.cycled_list(); block_it.forward()) {
396        block = block_it.data();
397        row_it.set_to_list(block->get_rows());
398        for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
399          row = row_it.data();
400          row_y = row->baseline.y(master_x);
401          row_shift = shift_factor * (master_y - row_y);
402          plot_row_cells(to_win, ScrollView::GOLDENROD, row, row_shift, master_cells);
403        }
404      }
405    }
406  #endif
407    row->char_cells.clear();
408    return false;
409  }
410  bool try_block_fixed(   
411      TO_BLOCK *block,    
412      int32_t block_index 
413  ) {
414    return false;
415  }
416  bool try_rows_fixed(     
417      TO_BLOCK *block,     
418      int32_t block_index, 
419      bool testing_on      
420  ) {
421    TO_ROW *row;           
422    int32_t row_index;     
423    int32_t def_fixed = 0; 
424    int32_t def_prop = 0;
425    int32_t maybe_fixed = 0;
426    int32_t maybe_prop = 0;
427    int32_t dunno = 0;
428    int32_t corr_fixed = 0;
429    int32_t corr_prop = 0;
430    float lower, upper; 
431    TO_ROW_IT row_it = block->get_rows();
432    row_index = 1;
433    for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
434      row = row_it.data();
435      ASSERT_HOST(row->xheight > 0);
436      if (row->fixed_pitch > 0 && fixed_pitch_row(row, block->block, block_index)) {
437        if (row->fixed_pitch == 0) {
438          lower = row->pr_nonsp;
439          upper = row->pr_space;
440          row->space_size = upper;
441          row->kern_size = lower;
442        }
443      }
444      row_index++;
445    }
446    count_block_votes(block, def_fixed, def_prop, maybe_fixed, maybe_prop, corr_fixed, corr_prop,
447                      dunno);
448    if (testing_on &&
449        (textord_debug_pitch_test || textord_blocksall_prop || textord_blocksall_fixed)) {
450      tprintf("Initially:");
451      print_block_counts(block, block_index);
452    }
453    if (def_fixed > def_prop * textord_words_veto_power) {
454      block->pitch_decision = PITCH_DEF_FIXED;
455    } else if (def_prop > def_fixed * textord_words_veto_power) {
456      block->pitch_decision = PITCH_DEF_PROP;
457    } else if (def_fixed > 0 || def_prop > 0) {
458      block->pitch_decision = PITCH_DUNNO;
459    } else if (maybe_fixed > maybe_prop * textord_words_veto_power) {
460      block->pitch_decision = PITCH_MAYBE_FIXED;
461    } else if (maybe_prop > maybe_fixed * textord_words_veto_power) {
462      block->pitch_decision = PITCH_MAYBE_PROP;
463    } else {
464      block->pitch_decision = PITCH_DUNNO;
465    }
466    return false;
467  }
468  void print_block_counts( 
469      TO_BLOCK *block,     
470      int32_t block_index  
471  ) {
472    int32_t def_fixed = 0; 
473    int32_t def_prop = 0;
474    int32_t maybe_fixed = 0;
475    int32_t maybe_prop = 0;
476    int32_t dunno = 0;
477    int32_t corr_fixed = 0;
478    int32_t corr_prop = 0;
479    count_block_votes(block, def_fixed, def_prop, maybe_fixed, maybe_prop, corr_fixed, corr_prop,
480                      dunno);
481    tprintf("Block %d has (%d,%d,%d)", block_index, def_fixed, maybe_fixed, corr_fixed);
482    if (textord_blocksall_prop && (def_fixed || maybe_fixed || corr_fixed)) {
483      tprintf(" (Wrongly)");
484    }
485    tprintf(" fixed, (%d,%d,%d)", def_prop, maybe_prop, corr_prop);
486    if (textord_blocksall_fixed && (def_prop || maybe_prop || corr_prop)) {
487      tprintf(" (Wrongly)");
488    }
489    tprintf(" prop, %d dunno\n", dunno);
490  }
491  void count_block_votes( 
492      TO_BLOCK *block,    
493      int32_t &def_fixed, 
494      int32_t &def_prop, int32_t &maybe_fixed, int32_t &maybe_prop, int32_t &corr_fixed,
495      int32_t &corr_prop, int32_t &dunno) {
496    TO_ROW *row; 
497    TO_ROW_IT row_it = block->get_rows();
498    for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
499      row = row_it.data();
500      switch (row->pitch_decision) {
501        case PITCH_DUNNO:
502          dunno++;
503          break;
504        case PITCH_DEF_PROP:
505          def_prop++;
506          break;
507        case PITCH_MAYBE_PROP:
508          maybe_prop++;
509          break;
510        case PITCH_DEF_FIXED:
511          def_fixed++;
512          break;
513        case PITCH_MAYBE_FIXED:
514          maybe_fixed++;
515          break;
516        case PITCH_CORR_PROP:
517          corr_prop++;
518          break;
519        case PITCH_CORR_FIXED:
520          corr_fixed++;
521          break;
522      }
523    }
524  }
525  bool row_pitch_stats( 
526      TO_ROW *row,      
527      int32_t maxwidth, 
528      bool testing_on   
529  ) {
530    BLOBNBOX *blob;        
531    int gap_index;         
532    int32_t prev_x;        
533    int32_t cluster_count; 
534    int32_t prev_count;    
535    int32_t smooth_factor; 
536    TBOX blob_box;         
537    float lower, upper;    
538    float gaps[BLOCK_STATS_CLUSTERS];
539    BLOBNBOX_IT blob_it = row->blob_list();
540    STATS gap_stats(0, maxwidth - 1);
541    STATS cluster_stats[BLOCK_STATS_CLUSTERS + 1];
542    smooth_factor = static_cast<int32_t>(row->xheight * textord_wordstats_smooth_factor + 1.5);
543    if (!blob_it.empty()) {
544      prev_x = blob_it.data()->bounding_box().right();
545      blob_it.forward();
546      while (!blob_it.at_first()) {
547        blob = blob_it.data();
548        if (!blob->joined_to_prev()) {
549          blob_box = blob->bounding_box();
550          if (blob_box.left() - prev_x < maxwidth) {
551            gap_stats.add(blob_box.left() - prev_x, 1);
552          }
553          prev_x = blob_box.right();
554        }
555        blob_it.forward();
556      }
557    }
558    if (gap_stats.get_total() == 0) {
559      return false;
560    }
561    cluster_count = 0;
562    lower = row->xheight * words_initial_lower;
563    upper = row->xheight * words_initial_upper;
564    gap_stats.smooth(smooth_factor);
565    do {
566      prev_count = cluster_count;
567      cluster_count = gap_stats.cluster(lower, upper, textord_spacesize_ratioprop,
568                                        BLOCK_STATS_CLUSTERS, cluster_stats);
569    } while (cluster_count > prev_count && cluster_count < BLOCK_STATS_CLUSTERS);
570    if (cluster_count < 1) {
571      return false;
572    }
573    for (gap_index = 0; gap_index < cluster_count; gap_index++) {
574      gaps[gap_index] = cluster_stats[gap_index + 1].ile(0.5);
575    }
576    if (testing_on) {
577      tprintf("cluster_count=%d:", cluster_count);
578      for (gap_index = 0; gap_index < cluster_count; gap_index++) {
579        tprintf(" %g(%d)", gaps[gap_index], cluster_stats[gap_index + 1].get_total());
580      }
581      tprintf("\n");
582    }
583    qsort(gaps, cluster_count, sizeof(float), sort_floats);
584    lower = row->xheight * words_default_prop_nonspace;
585    upper = row->xheight * textord_words_min_minspace;
586    for (gap_index = 0; gap_index < cluster_count && gaps[gap_index] < lower; gap_index++) {
587      ;
588    }
589    if (gap_index == 0) {
590      if (testing_on) {
591        tprintf("No clusters below nonspace threshold!!\n");
592      }
593      if (cluster_count > 1) {
594        row->pr_nonsp = gaps[0];
595        row->pr_space = gaps[1];
596      } else {
597        row->pr_nonsp = lower;
598        row->pr_space = gaps[0];
599      }
600    } else {
601      row->pr_nonsp = gaps[gap_index - 1];
602      while (gap_index < cluster_count && gaps[gap_index] < upper) {
603        gap_index++;
604      }
605      if (gap_index == cluster_count) {
606        if (testing_on) {
607          tprintf("No clusters above nonspace threshold!!\n");
608        }
609        row->pr_space = lower * textord_spacesize_ratioprop;
610      } else {
611        row->pr_space = gaps[gap_index];
612      }
613    }
614    upper = row->xheight * words_default_fixed_space;
615    for (gap_index = 0; gap_index < cluster_count && gaps[gap_index] < upper; gap_index++) {
616      ;
617    }
618    if (gap_index == 0) {
619      if (testing_on) {
620        tprintf("No clusters below space threshold!!\n");
621      }
622      row->fp_nonsp = upper;
623      row->fp_space = gaps[0];
624    } else {
625      row->fp_nonsp = gaps[gap_index - 1];
626      if (gap_index == cluster_count) {
627        if (testing_on) {
628          tprintf("No clusters above space threshold!!\n");
629        }
630        row->fp_space = row->xheight;
631      } else {
632        row->fp_space = gaps[gap_index];
633      }
634    }
635    if (testing_on) {
636      tprintf(
637          "Initial estimates:pr_nonsp=%g, pr_space=%g, fp_nonsp=%g, "
638          "fp_space=%g\n",
639          row->pr_nonsp, row->pr_space, row->fp_nonsp, row->fp_space);
640    }
641    return true; 
642  }
643  bool find_row_pitch(     
644      TO_ROW *row,         
645      int32_t maxwidth,    
646      int32_t dm_gap,      
647      TO_BLOCK *block,     
648      int32_t block_index, 
649      int32_t row_index,   
650      bool testing_on      
651  ) {
652    bool used_dm_model; 
653    float min_space;    
654    float non_space;    
655    float gap_iqr;      
656    float pitch_iqr;
657    float dm_gap_iqr; 
658    float dm_pitch_iqr;
659    float dm_pitch;      
660    float pitch;         
661    float initial_pitch; 
662    STATS gap_stats(0, maxwidth - 1);
663    STATS pitch_stats(0, maxwidth - 1);
664    row->fixed_pitch = 0.0f;
665    initial_pitch = row->fp_space;
666    if (initial_pitch > row->xheight * (1 + words_default_fixed_limit)) {
667      initial_pitch = row->xheight; 
668    }
669    non_space = row->fp_nonsp;
670    if (non_space > initial_pitch) {
671      non_space = initial_pitch;
672    }
673    min_space = (initial_pitch + non_space) / 2;
674    if (!count_pitch_stats(row, &gap_stats, &pitch_stats, initial_pitch, min_space, true, false,
675                           dm_gap)) {
676      dm_gap_iqr = 0.0001f;
677      dm_pitch_iqr = maxwidth * 2.0f;
678      dm_pitch = initial_pitch;
679    } else {
680      dm_gap_iqr = gap_stats.ile(0.75) - gap_stats.ile(0.25);
681      dm_pitch_iqr = pitch_stats.ile(0.75) - pitch_stats.ile(0.25);
682      dm_pitch = pitch_stats.ile(0.5);
683    }
684    gap_stats.clear();
685    pitch_stats.clear();
686    if (!count_pitch_stats(row, &gap_stats, &pitch_stats, initial_pitch, min_space, true, false, 0)) {
687      gap_iqr = 0.0001f;
688      pitch_iqr = maxwidth * 3.0f;
689    } else {
690      gap_iqr = gap_stats.ile(0.75) - gap_stats.ile(0.25);
691      pitch_iqr = pitch_stats.ile(0.75) - pitch_stats.ile(0.25);
692      if (testing_on) {
693        tprintf(
694            "First fp iteration:initial_pitch=%g, gap_iqr=%g, pitch_iqr=%g, "
695            "pitch=%g\n",
696            initial_pitch, gap_iqr, pitch_iqr, pitch_stats.ile(0.5));
697      }
698      initial_pitch = pitch_stats.ile(0.5);
699      if (min_space > initial_pitch && count_pitch_stats(row, &gap_stats, &pitch_stats, initial_pitch,
700                                                         initial_pitch, true, false, 0)) {
701        min_space = initial_pitch;
702        gap_iqr = gap_stats.ile(0.75) - gap_stats.ile(0.25);
703        pitch_iqr = pitch_stats.ile(0.75) - pitch_stats.ile(0.25);
704        if (testing_on) {
705          tprintf(
706              "Revised fp iteration:initial_pitch=%g, gap_iqr=%g, pitch_iqr=%g, "
707              "pitch=%g\n",
708              initial_pitch, gap_iqr, pitch_iqr, pitch_stats.ile(0.5));
709        }
710        initial_pitch = pitch_stats.ile(0.5);
711      }
712    }
713    if (textord_debug_pitch_metric) {
714      tprintf("Blk=%d:Row=%d:%c:p_iqr=%g:g_iqr=%g:dm_p_iqr=%g:dm_g_iqr=%g:%c:", block_index,
715              row_index, 'X', pitch_iqr, gap_iqr, dm_pitch_iqr, dm_gap_iqr,
716              pitch_iqr > maxwidth && dm_pitch_iqr > maxwidth
717                  ? 'D'
718                  : (pitch_iqr * dm_gap_iqr <= dm_pitch_iqr * gap_iqr ? 'S' : 'M'));
719    }
720    if (pitch_iqr > maxwidth && dm_pitch_iqr > maxwidth) {
721      row->pitch_decision = PITCH_DUNNO;
722      if (textord_debug_pitch_metric) {
723        tprintf("\n");
724      }
725      return false; 
726    }
727    if (pitch_iqr * dm_gap_iqr <= dm_pitch_iqr * gap_iqr) {
728      if (testing_on) {
729        tprintf(
730            "Choosing non dm version:pitch_iqr=%g, gap_iqr=%g, dm_pitch_iqr=%g, "
731            "dm_gap_iqr=%g\n",
732            pitch_iqr, gap_iqr, dm_pitch_iqr, dm_gap_iqr);
733      }
734      gap_iqr = gap_stats.ile(0.75) - gap_stats.ile(0.25);
735      pitch_iqr = pitch_stats.ile(0.75) - pitch_stats.ile(0.25);
736      pitch = pitch_stats.ile(0.5);
737      used_dm_model = false;
738    } else {
739      if (testing_on) {
740        tprintf(
741            "Choosing dm version:pitch_iqr=%g, gap_iqr=%g, dm_pitch_iqr=%g, "
742            "dm_gap_iqr=%g\n",
743            pitch_iqr, gap_iqr, dm_pitch_iqr, dm_gap_iqr);
744      }
745      gap_iqr = dm_gap_iqr;
746      pitch_iqr = dm_pitch_iqr;
747      pitch = dm_pitch;
748      used_dm_model = true;
749    }
750    if (textord_debug_pitch_metric) {
751      tprintf("rev_p_iqr=%g:rev_g_iqr=%g:pitch=%g:", pitch_iqr, gap_iqr, pitch);
752      tprintf("p_iqr/g=%g:p_iqr/x=%g:iqr_res=%c:", pitch_iqr / gap_iqr, pitch_iqr / block->xheight,
753              pitch_iqr < gap_iqr * textord_fpiqr_ratio &&
754                      pitch_iqr < block->xheight * textord_max_pitch_iqr &&
755                      pitch < block->xheight * textord_words_default_maxspace
756                  ? 'F'
757                  : 'P');
758    }
759    if (pitch_iqr < gap_iqr * textord_fpiqr_ratio &&
760        pitch_iqr < block->xheight * textord_max_pitch_iqr &&
761        pitch < block->xheight * textord_words_default_maxspace) {
762      row->pitch_decision = PITCH_MAYBE_FIXED;
763    } else {
764      row->pitch_decision = PITCH_MAYBE_PROP;
765    }
766    row->fixed_pitch = pitch;
767    row->kern_size = gap_stats.ile(0.5);
768    row->min_space = static_cast<int32_t>(row->fixed_pitch + non_space) / 2;
769    if (row->min_space > row->fixed_pitch) {
770      row->min_space = static_cast<int32_t>(row->fixed_pitch);
771    }
772    row->max_nonspace = row->min_space;
773    row->space_size = row->fixed_pitch;
774    row->space_threshold = (row->max_nonspace + row->min_space) / 2;
775    row->used_dm_model = used_dm_model;
776    return true;
777  }
778  bool fixed_pitch_row(TO_ROW *row, 
779                       BLOCK *block,
780                       int32_t block_index 
781  ) {
782    const char *res_string; 
783    int16_t mid_cuts;       
784    float non_space;        
785    float pitch_sd;         
786    float sp_sd = 0.0f;     
787    non_space = row->fp_nonsp;
788    if (non_space > row->fixed_pitch) {
789      non_space = row->fixed_pitch;
790    }
791    POLY_BLOCK *pb = block != nullptr ? block->pdblk.poly_block() : nullptr;
792    if (textord_all_prop || (pb != nullptr && !pb->IsText())) {
793      pitch_sd = textord_words_def_prop * row->fixed_pitch;
794      row->pitch_decision = PITCH_DEF_PROP;
795    } else {
796      pitch_sd = tune_row_pitch(row, &row->projection, row->projection_left, row->projection_right,
797                                (row->fixed_pitch + non_space * 3) / 4, row->fixed_pitch, sp_sd,
798                                mid_cuts, &row->char_cells, block_index == textord_debug_block);
799      if (pitch_sd < textord_words_pitchsd_threshold * row->fixed_pitch &&
800          ((pitsync_linear_version & 3) < 3 ||
801           ((pitsync_linear_version & 3) >= 3 &&
802            (row->used_dm_model || sp_sd > 20 || (pitch_sd == 0 && sp_sd > 10))))) {
803        if (pitch_sd < textord_words_def_fixed * row->fixed_pitch && !row->all_caps &&
804            ((pitsync_linear_version & 3) < 3 || sp_sd > 20)) {
805          row->pitch_decision = PITCH_DEF_FIXED;
806        } else {
807          row->pitch_decision = PITCH_MAYBE_FIXED;
808        }
809      } else if ((pitsync_linear_version & 3) < 3 || sp_sd > 20 || mid_cuts > 0 ||
810                 pitch_sd >= textord_words_pitchsd_threshold * row->fixed_pitch) {
811        if (pitch_sd < textord_words_def_prop * row->fixed_pitch) {
812          row->pitch_decision = PITCH_MAYBE_PROP;
813        } else {
814          row->pitch_decision = PITCH_DEF_PROP;
815        }
816      } else {
817        row->pitch_decision = PITCH_DUNNO;
818      }
819    }
820    if (textord_debug_pitch_metric) {
821      res_string = "??";
822      switch (row->pitch_decision) {
823        case PITCH_DEF_PROP:
824          res_string = "DP";
825          break;
826        case PITCH_MAYBE_PROP:
827          res_string = "MP";
828          break;
829        case PITCH_DEF_FIXED:
830          res_string = "DF";
831          break;
832        case PITCH_MAYBE_FIXED:
833          res_string = "MF";
834          break;
835        default:
836          res_string = "??";
837      }
838      tprintf(":sd/p=%g:occ=%g:init_res=%s\n", pitch_sd / row->fixed_pitch, sp_sd, res_string);
839    }
840    return true;
841  }
842  bool count_pitch_stats(  
843      TO_ROW *row,         
844      STATS *gap_stats,    
845      STATS *pitch_stats,  
846      float initial_pitch, 
847      float min_space,     
848      bool ignore_outsize, 
849      bool split_outsize,  
850      int32_t dm_gap       
851  ) {
852    bool prev_valid; 
853    BLOBNBOX *blob;  
854    BLOBNBOX_IT blob_it = row->blob_list();
855    int32_t prev_right;  
856    int32_t prev_centre; 
857    int32_t x_centre;    
858    int32_t blob_width;  
859    int32_t width_units; 
860    float width;         
861    TBOX blob_box;       
862    TBOX joined_box;     
863    gap_stats->clear();
864    pitch_stats->clear();
865    if (blob_it.empty()) {
866      return false;
867    }
868    prev_valid = false;
869    prev_centre = 0;
870    prev_right = 0; 
871    joined_box = blob_it.data()->bounding_box();
872    do {
873      blob_it.forward();
874      blob = blob_it.data();
875      if (!blob->joined_to_prev()) {
876        blob_box = blob->bounding_box();
877        if ((blob_box.left() - joined_box.right() < dm_gap && !blob_it.at_first()) ||
878            blob->cblob() == nullptr) {
879          joined_box += blob_box; 
880        } else {
881          blob_width = joined_box.width();
882          if (split_outsize) {
883            width_units =
884                static_cast<int32_t>(floor(static_cast<float>(blob_width) / initial_pitch + 0.5));
885            if (width_units < 1) {
886              width_units = 1;
887            }
888            width_units--;
889          } else if (ignore_outsize) {
890            width = static_cast<float>(blob_width) / initial_pitch;
891            width_units =
892                width < 1 + words_default_fixed_limit && width > 1 - words_default_fixed_limit ? 0
893                                                                                               : -1;
894          } else {
895            width_units = 0; 
896          }
897          x_centre = static_cast<int32_t>(joined_box.left() +
898                                          (blob_width - width_units * initial_pitch) / 2);
899          if (prev_valid && width_units >= 0) {
900            gap_stats->add(joined_box.left() - prev_right, 1);
901            pitch_stats->add(x_centre - prev_centre, 1);
902          }
903          prev_centre = static_cast<int32_t>(x_centre + width_units * initial_pitch);
904          prev_right = joined_box.right();
905          prev_valid = blob_box.left() - joined_box.right() < min_space;
906          prev_valid = prev_valid && width_units >= 0;
907          joined_box = blob_box;
908        }
909      }
910    } while (!blob_it.at_first());
911    return gap_stats->get_total() >= 3;
912  }
913  float tune_row_pitch(           
914      TO_ROW *row,                
915      STATS *projection,          
916      int16_t projection_left,    
917      int16_t projection_right,   
918      float space_size,           
919      float &initial_pitch,       
920      float &best_sp_sd,          
921      int16_t &best_mid_cuts,     
922      ICOORDELT_LIST *best_cells, 
923      bool testing_on             
924  ) {
925    int pitch_delta;           
926    int16_t mid_cuts;          
927    float pitch_sd;            
928    float best_sd;             
929    float best_pitch;          
930    float initial_sd;          
931    float sp_sd;               
932    ICOORDELT_LIST test_cells; 
933    ICOORDELT_IT best_it;      
934    if (textord_fast_pitch_test) {
935      return tune_row_pitch2(row, projection, projection_left, projection_right, space_size,
936                             initial_pitch, best_sp_sd,
937                             best_mid_cuts, best_cells, testing_on);
938    }
939    if (textord_disable_pitch_test) {
940      best_sp_sd = initial_pitch;
941      return initial_pitch;
942    }
943    initial_sd = compute_pitch_sd(row, projection, projection_left, projection_right, space_size,
944                                  initial_pitch, best_sp_sd, best_mid_cuts, best_cells, testing_on);
945    best_sd = initial_sd;
946    best_pitch = initial_pitch;
947    if (testing_on) {
948      tprintf("tune_row_pitch:start pitch=%g, sd=%g\n", best_pitch, best_sd);
949    }
950    for (pitch_delta = 1; pitch_delta <= textord_pitch_range; pitch_delta++) {
951      pitch_sd =
952          compute_pitch_sd(row, projection, projection_left, projection_right, space_size,
953                           initial_pitch + pitch_delta, sp_sd, mid_cuts, &test_cells, testing_on);
954      if (testing_on) {
955        tprintf("testing pitch at %g, sd=%g\n", initial_pitch + pitch_delta, pitch_sd);
956      }
957      if (pitch_sd < best_sd) {
958        best_sd = pitch_sd;
959        best_mid_cuts = mid_cuts;
960        best_sp_sd = sp_sd;
961        best_pitch = initial_pitch + pitch_delta;
962        best_cells->clear();
963        best_it.set_to_list(best_cells);
964        best_it.add_list_after(&test_cells);
965      } else {
966        test_cells.clear();
967      }
968      if (pitch_sd > initial_sd) {
969        break; 
970      }
971    }
972    for (pitch_delta = 1; pitch_delta <= textord_pitch_range; pitch_delta++) {
973      pitch_sd =
974          compute_pitch_sd(row, projection, projection_left, projection_right, space_size,
975                           initial_pitch - pitch_delta, sp_sd, mid_cuts, &test_cells, testing_on);
976      if (testing_on) {
977        tprintf("testing pitch at %g, sd=%g\n", initial_pitch - pitch_delta, pitch_sd);
978      }
979      if (pitch_sd < best_sd) {
980        best_sd = pitch_sd;
981        best_mid_cuts = mid_cuts;
982        best_sp_sd = sp_sd;
983        best_pitch = initial_pitch - pitch_delta;
984        best_cells->clear();
985        best_it.set_to_list(best_cells);
986        best_it.add_list_after(&test_cells);
987      } else {
988        test_cells.clear();
989      }
990      if (pitch_sd > initial_sd) {
991        break;
992      }
993    }
994    initial_pitch = best_pitch;
995    if (textord_debug_pitch_metric) {
996      print_pitch_sd(row, projection, projection_left, projection_right, space_size, best_pitch);
997    }
998    return best_sd;
999  }
1000  float tune_row_pitch2(          
1001      TO_ROW *row,                
1002      STATS *projection,          
1003      int16_t projection_left,    
1004      int16_t projection_right,   
1005      float space_size,           
1006      float &initial_pitch,       
1007      float &best_sp_sd,          
1008      int16_t &best_mid_cuts,     
1009      ICOORDELT_LIST *best_cells, 
1010      bool testing_on             
1011  ) {
1012    int pitch_delta;    
1013    int16_t pixel;      
1014    int16_t best_pixel; 
1015    int16_t best_delta; 
1016    int16_t best_pitch; 
1017    int16_t start;      
1018    int16_t end;        
1019    int32_t best_count; 
1020    float best_sd;      
1021    best_sp_sd = initial_pitch;
1022    best_pitch = static_cast<int>(initial_pitch);
1023    if (textord_disable_pitch_test || best_pitch <= textord_pitch_range) {
1024      return initial_pitch;
1025    }
1026    std::unique_ptr<STATS[]> sum_proj(new STATS[textord_pitch_range * 2 + 1]); 
1027    for (pitch_delta = -textord_pitch_range; pitch_delta <= textord_pitch_range; pitch_delta++) {
1028      sum_proj[textord_pitch_range + pitch_delta].set_range(0, best_pitch + pitch_delta);
1029    }
1030    for (pixel = projection_left; pixel <= projection_right; pixel++) {
1031      for (pitch_delta = -textord_pitch_range; pitch_delta <= textord_pitch_range; pitch_delta++) {
1032        sum_proj[textord_pitch_range + pitch_delta].add(
1033            (pixel - projection_left) % (best_pitch + pitch_delta), projection->pile_count(pixel));
1034      }
1035    }
1036    best_count = sum_proj[textord_pitch_range].pile_count(0);
1037    best_delta = 0;
1038    best_pixel = 0;
1039    for (pitch_delta = -textord_pitch_range; pitch_delta <= textord_pitch_range; pitch_delta++) {
1040      for (pixel = 0; pixel < best_pitch + pitch_delta; pixel++) {
1041        if (sum_proj[textord_pitch_range + pitch_delta].pile_count(pixel) < best_count) {
1042          best_count = sum_proj[textord_pitch_range + pitch_delta].pile_count(pixel);
1043          best_delta = pitch_delta;
1044          best_pixel = pixel;
1045        }
1046      }
1047    }
1048    if (testing_on) {
1049      tprintf("tune_row_pitch:start pitch=%g, best_delta=%d, count=%d\n", initial_pitch, best_delta,
1050              best_count);
1051    }
1052    best_pitch += best_delta;
1053    initial_pitch = best_pitch;
1054    best_count++;
1055    best_count += best_count;
1056    for (start = best_pixel - 2;
1057         start > best_pixel - best_pitch &&
1058         sum_proj[textord_pitch_range + best_delta].pile_count(start % best_pitch) <= best_count;
1059         start--) {
1060      ;
1061    }
1062    for (end = best_pixel + 2;
1063         end < best_pixel + best_pitch &&
1064         sum_proj[textord_pitch_range + best_delta].pile_count(end % best_pitch) <= best_count;
1065         end++) {
1066      ;
1067    }
1068    best_sd = compute_pitch_sd(row, projection, projection_left, projection_right, space_size,
1069                               initial_pitch, best_sp_sd, best_mid_cuts, best_cells, testing_on,
1070                               start, end);
1071    if (testing_on) {
1072      tprintf("tune_row_pitch:output pitch=%g, sd=%g\n", initial_pitch, best_sd);
1073    }
1074    if (textord_debug_pitch_metric) {
1075      print_pitch_sd(row, projection, projection_left, projection_right, space_size, initial_pitch);
1076    }
1077    return best_sd;
1078  }
1079  float compute_pitch_sd(        
1080      TO_ROW *row,               
1081      STATS *projection,         
1082      int16_t projection_left,   
1083      int16_t projection_right,  
1084      float space_size,          
1085      float initial_pitch,       
1086      float &sp_sd,              
1087      int16_t &mid_cuts,         
1088      ICOORDELT_LIST *row_cells, 
1089      bool testing_on,           
1090      int16_t start,             
1091      int16_t end                
1092  ) {
1093    int16_t occupation; 
1094    BLOBNBOX_IT blob_it = row->blob_list();
1095    BLOBNBOX_IT start_it;  
1096    BLOBNBOX_IT plot_it;   
1097    int16_t blob_count;    
1098    TBOX blob_box;         
1099    TBOX prev_box;         
1100    int32_t prev_right;    
1101    int scale_factor;      
1102    int32_t sp_count;      
1103    FPSEGPT_LIST seg_list; 
1104    FPSEGPT_IT seg_it;     
1105    int16_t segpos;        
1106    int16_t cellpos;       
1107    ICOORDELT_IT cell_it = row_cells;
1108    ICOORDELT *cell;     
1109    double sqsum;        
1110    double spsum;        
1111    double sp_var;       
1112    double word_sync;    
1113    int32_t total_count; 
1114    if ((pitsync_linear_version & 3) > 1) {
1115      word_sync = compute_pitch_sd2(row, projection, projection_left, projection_right, initial_pitch,
1116                                    occupation, mid_cuts, row_cells, testing_on, start, end);
1117      sp_sd = occupation;
1118      return word_sync;
1119    }
1120    mid_cuts = 0;
1121    cellpos = 0;
1122    total_count = 0;
1123    sqsum = 0;
1124    sp_count = 0;
1125    spsum = 0;
1126    prev_right = -1;
1127    if (blob_it.empty()) {
1128      return space_size * 10;
1129    }
1130  #ifndef GRAPHICS_DISABLED
1131    if (testing_on && to_win != nullptr) {
1132      blob_box = blob_it.data()->bounding_box();
1133      projection->plot(to_win, projection_left, row->intercept(), 1.0f, -1.0f, ScrollView::CORAL);
1134    }
1135  #endif
1136    start_it = blob_it;
1137    blob_count = 0;
1138    blob_box = box_next(&blob_it); 
1139    blob_it.mark_cycle_pt();
1140    do {
1141      for (; blob_count > 0; blob_count--) {
1142        box_next(&start_it);
1143      }
1144      do {
1145        prev_box = blob_box;
1146        blob_count++;
1147        blob_box = box_next(&blob_it);
1148      } while (!blob_it.cycled_list() && blob_box.left() - prev_box.right() < space_size);
1149      plot_it = start_it;
1150      if (pitsync_linear_version & 3) {
1151        word_sync = check_pitch_sync2(&start_it, blob_count, static_cast<int16_t>(initial_pitch), 2,
1152                                      projection, projection_left, projection_right,
1153                                      row->xheight * textord_projection_scale, occupation, &seg_list,
1154                                      start, end);
1155      } else {
1156        word_sync = check_pitch_sync(&start_it, blob_count, static_cast<int16_t>(initial_pitch), 2,
1157                                     projection, &seg_list);
1158      }
1159      if (testing_on) {
1160        tprintf("Word ending at (%d,%d), len=%d, sync rating=%g, ", prev_box.right(), prev_box.top(),
1161                seg_list.length() - 1, word_sync);
1162        seg_it.set_to_list(&seg_list);
1163        for (seg_it.mark_cycle_pt(); !seg_it.cycled_list(); seg_it.forward()) {
1164          if (seg_it.data()->faked) {
1165            tprintf("(F)");
1166          }
1167          tprintf("%d, ", seg_it.data()->position());
1168        }
1169        tprintf("\n");
1170      }
1171  #ifndef GRAPHICS_DISABLED
1172      if (textord_show_fixed_cuts && blob_count > 0 && to_win != nullptr) {
1173        plot_fp_cells2(to_win, ScrollView::GOLDENROD, row, &seg_list);
1174      }
1175  #endif
1176      seg_it.set_to_list(&seg_list);
1177      if (prev_right >= 0) {
1178        sp_var = seg_it.data()->position() - prev_right;
1179        sp_var -= floor(sp_var / initial_pitch + 0.5) * initial_pitch;
1180        sp_var *= sp_var;
1181        spsum += sp_var;
1182        sp_count++;
1183      }
1184      for (seg_it.mark_cycle_pt(); !seg_it.cycled_list(); seg_it.forward()) {
1185        segpos = seg_it.data()->position();
1186        if (cell_it.empty() || segpos > cellpos + initial_pitch / 2) {
1187          while (!cell_it.empty() && segpos > cellpos + initial_pitch * 3 / 2) {
1188            cell = new ICOORDELT(cellpos + static_cast<int16_t>(initial_pitch), 0);
1189            cell_it.add_after_then_move(cell);
1190            cellpos += static_cast<int16_t>(initial_pitch);
1191          }
1192          cell = new ICOORDELT(segpos, 0);
1193          cell_it.add_after_then_move(cell);
1194          cellpos = segpos;
1195        } else if (segpos > cellpos - initial_pitch / 2) {
1196          cell = cell_it.data();
1197          cell->set_x((cellpos + segpos) / 2);
1198          cellpos = cell->x();
1199        }
1200      }
1201      seg_it.move_to_last();
1202      prev_right = seg_it.data()->position();
1203      if (textord_pitch_scalebigwords) {
1204        scale_factor = (seg_list.length() - 2) / 2;
1205        if (scale_factor < 1) {
1206          scale_factor = 1;
1207        }
1208      } else {
1209        scale_factor = 1;
1210      }
1211      sqsum += word_sync * scale_factor;
1212      total_count += (seg_list.length() - 1) * scale_factor;
1213      seg_list.clear();
1214    } while (!blob_it.cycled_list());
1215    sp_sd = sp_count > 0 ? sqrt(spsum / sp_count) : 0;
1216    return total_count > 0 ? sqrt(sqsum / total_count) : space_size * 10;
1217  }
1218  float compute_pitch_sd2(       
1219      TO_ROW *row,               
1220      STATS *projection,         
1221      int16_t projection_left,   
1222      int16_t projection_right,  
1223      float initial_pitch,       
1224      int16_t &occupation,       
1225      int16_t &mid_cuts,         
1226      ICOORDELT_LIST *row_cells, 
1227      bool testing_on,           
1228      int16_t start,             
1229      int16_t end                
1230  ) {
1231    BLOBNBOX_IT blob_it = row->blob_list();
1232    BLOBNBOX_IT plot_it;
1233    int16_t blob_count;    
1234    TBOX blob_box;         
1235    FPSEGPT_LIST seg_list; 
1236    FPSEGPT_IT seg_it;     
1237    int16_t segpos;        
1238    ICOORDELT_IT cell_it = row_cells;
1239    ICOORDELT *cell;  
1240    double word_sync; 
1241    mid_cuts = 0;
1242    if (blob_it.empty()) {
1243      occupation = 0;
1244      return initial_pitch * 10;
1245    }
1246  #ifndef GRAPHICS_DISABLED
1247    if (testing_on && to_win != nullptr) {
1248      projection->plot(to_win, projection_left, row->intercept(), 1.0f, -1.0f, ScrollView::CORAL);
1249    }
1250  #endif
1251    blob_count = 0;
1252    blob_it.mark_cycle_pt();
1253    do {
1254      blob_box = box_next(&blob_it);
1255      blob_count++;
1256    } while (!blob_it.cycled_list());
1257    plot_it = blob_it;
1258    word_sync = check_pitch_sync2(
1259        &blob_it, blob_count, static_cast<int16_t>(initial_pitch), 2, projection, projection_left,
1260        projection_right, row->xheight * textord_projection_scale, occupation, &seg_list, start, end);
1261    if (testing_on) {
1262      tprintf("Row ending at (%d,%d), len=%d, sync rating=%g, ", blob_box.right(), blob_box.top(),
1263              seg_list.length() - 1, word_sync);
1264      seg_it.set_to_list(&seg_list);
1265      for (seg_it.mark_cycle_pt(); !seg_it.cycled_list(); seg_it.forward()) {
1266        if (seg_it.data()->faked) {
1267          tprintf("(F)");
1268        }
1269        tprintf("%d, ", seg_it.data()->position());
1270      }
1271      tprintf("\n");
1272    }
1273  #ifndef GRAPHICS_DISABLED
1274    if (textord_show_fixed_cuts && blob_count > 0 && to_win != nullptr) {
1275      plot_fp_cells2(to_win, ScrollView::GOLDENROD, row, &seg_list);
1276    }
1277  #endif
1278    seg_it.set_to_list(&seg_list);
1279    for (seg_it.mark_cycle_pt(); !seg_it.cycled_list(); seg_it.forward()) {
1280      segpos = seg_it.data()->position();
1281      cell = new ICOORDELT(segpos, 0);
1282      cell_it.add_after_then_move(cell);
1283      if (seg_it.at_last()) {
1284        mid_cuts = seg_it.data()->cheap_cuts();
1285      }
1286    }
1287    seg_list.clear();
1288    return occupation > 0 ? sqrt(word_sync / occupation) : initial_pitch * 10;
1289  }
1290  void print_pitch_sd(         
1291      TO_ROW *row,             
1292      STATS *projection,       
1293      int16_t projection_left, 
1294      int16_t projection_right, float space_size,
1295      float initial_pitch 
1296  ) {
1297    const char *res2;   
1298    int16_t occupation; 
1299    float sp_sd;        
1300    BLOBNBOX_IT blob_it = row->blob_list();
1301    BLOBNBOX_IT start_it;     
1302    BLOBNBOX_IT row_start;    
1303    int16_t blob_count;       
1304    int16_t total_blob_count; 
1305    TBOX blob_box;            
1306    TBOX prev_box;            
1307    int32_t prev_right;       
1308    int scale_factor;         
1309    int32_t sp_count;         
1310    FPSEGPT_LIST seg_list;    
1311    FPSEGPT_IT seg_it;        
1312    double sqsum;             
1313    double spsum;             
1314    double sp_var;            
1315    double word_sync;         
1316    double total_count;       
1317    if (blob_it.empty()) {
1318      return;
1319    }
1320    row_start = blob_it;
1321    total_blob_count = 0;
1322    total_count = 0;
1323    sqsum = 0;
1324    sp_count = 0;
1325    spsum = 0;
1326    prev_right = -1;
1327    blob_it = row_start;
1328    start_it = blob_it;
1329    blob_count = 0;
1330    blob_box = box_next(&blob_it); 
1331    blob_it.mark_cycle_pt();
1332    do {
1333      for (; blob_count > 0; blob_count--) {
1334        box_next(&start_it);
1335      }
1336      do {
1337        prev_box = blob_box;
1338        blob_count++;
1339        blob_box = box_next(&blob_it);
1340      } while (!blob_it.cycled_list() && blob_box.left() - prev_box.right() < space_size);
1341      word_sync = check_pitch_sync2(
1342          &start_it, blob_count, static_cast<int16_t>(initial_pitch), 2, projection, projection_left,
1343          projection_right, row->xheight * textord_projection_scale, occupation, &seg_list, 0, 0);
1344      total_blob_count += blob_count;
1345      seg_it.set_to_list(&seg_list);
1346      if (prev_right >= 0) {
1347        sp_var = seg_it.data()->position() - prev_right;
1348        sp_var -= floor(sp_var / initial_pitch + 0.5) * initial_pitch;
1349        sp_var *= sp_var;
1350        spsum += sp_var;
1351        sp_count++;
1352      }
1353      seg_it.move_to_last();
1354      prev_right = seg_it.data()->position();
1355      if (textord_pitch_scalebigwords) {
1356        scale_factor = (seg_list.length() - 2) / 2;
1357        if (scale_factor < 1) {
1358          scale_factor = 1;
1359        }
1360      } else {
1361        scale_factor = 1;
1362      }
1363      sqsum += word_sync * scale_factor;
1364      total_count += (seg_list.length() - 1) * scale_factor;
1365      seg_list.clear();
1366    } while (!blob_it.cycled_list());
1367    sp_sd = sp_count > 0 ? sqrt(spsum / sp_count) : 0;
1368    word_sync = total_count > 0 ? sqrt(sqsum / total_count) : space_size * 10;
1369    tprintf("new_sd=%g:sd/p=%g:new_sp_sd=%g:res=%c:", word_sync, word_sync / initial_pitch, sp_sd,
1370            word_sync < textord_words_pitchsd_threshold * initial_pitch ? 'F' : 'P');
1371    start_it = row_start;
1372    blob_it = row_start;
1373    word_sync =
1374        check_pitch_sync2(&blob_it, total_blob_count, static_cast<int16_t>(initial_pitch), 2,
1375                          projection, projection_left, projection_right,
1376                          row->xheight * textord_projection_scale, occupation, &seg_list, 0, 0);
1377    if (occupation > 1) {
1378      word_sync /= occupation;
1379    }
1380    word_sync = sqrt(word_sync);
1381  #ifndef GRAPHICS_DISABLED
1382    if (textord_show_row_cuts && to_win != nullptr) {
1383      plot_fp_cells2(to_win, ScrollView::CORAL, row, &seg_list);
1384    }
1385  #endif
1386    seg_list.clear();
1387    if (word_sync < textord_words_pitchsd_threshold * initial_pitch) {
1388      if (word_sync < textord_words_def_fixed * initial_pitch && !row->all_caps) {
1389        res2 = "DF";
1390      } else {
1391        res2 = "MF";
1392      }
1393    } else {
1394      res2 = word_sync < textord_words_def_prop * initial_pitch ? "MP" : "DP";
1395    }
1396    tprintf(
1397        "row_sd=%g:sd/p=%g:res=%c:N=%d:res2=%s,init pitch=%g, row_pitch=%g, "
1398        "all_caps=%d\n",
1399        word_sync, word_sync / initial_pitch,
1400        word_sync < textord_words_pitchsd_threshold * initial_pitch ? 'F' : 'P', occupation, res2,
1401        initial_pitch, row->fixed_pitch, row->all_caps);
1402  }
1403  void find_repeated_chars(TO_BLOCK *block,   
1404                           bool testing_on) { 
1405    POLY_BLOCK *pb = block->block->pdblk.poly_block();
1406    if (pb != nullptr && !pb->IsText()) {
1407      return; 
1408    }
1409    TO_ROW *row;
1410    BLOBNBOX_IT box_it;
1411    BLOBNBOX_IT search_it; 
1412    WERD *word;            
1413    TBOX word_box;         
1414    int blobcount, repeated_set;
1415    TO_ROW_IT row_it = block->get_rows();
1416    if (row_it.empty()) {
1417      return; 
1418    }
1419    for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
1420      row = row_it.data();
1421      box_it.set_to_list(row->blob_list());
1422      if (box_it.empty()) {
1423        continue; 
1424      }
1425      if (!row->rep_chars_marked()) {
1426        mark_repeated_chars(row);
1427      }
1428      if (row->num_repeated_sets() == 0) {
1429        continue; 
1430      }
1431      WERD_IT word_it(&row->rep_words);
1432      do {
1433        if (box_it.data()->repeated_set() != 0 && !box_it.data()->joined_to_prev()) {
1434          blobcount = 1;
1435          repeated_set = box_it.data()->repeated_set();
1436          search_it = box_it;
1437          search_it.forward();
1438          while (!search_it.at_first() && search_it.data()->repeated_set() == repeated_set) {
1439            blobcount++;
1440            search_it.forward();
1441          }
1442          word = make_real_word(&box_it, blobcount, box_it.at_first(), 1);
1443          if (!box_it.empty() && box_it.data()->joined_to_prev()) {
1444            tprintf("Bad box joined to prev at");
1445            box_it.data()->bounding_box().print();
1446            tprintf("After repeated word:");
1447            word->bounding_box().print();
1448          }
1449          ASSERT_HOST(box_it.empty() || !box_it.data()->joined_to_prev());
1450          word->set_flag(W_REP_CHAR, true);
1451          word->set_flag(W_DONT_CHOP, true);
1452          word_it.add_after_then_move(word);
1453        } else {
1454          box_it.forward();
1455        }
1456      } while (!box_it.at_first());
1457    }
1458  }
1459  #ifndef GRAPHICS_DISABLED
1460  void plot_fp_word(   
1461      TO_BLOCK *block, 
1462      float pitch,     
1463      float nonspace   
1464  ) {
1465    TO_ROW *row; 
1466    TO_ROW_IT row_it = block->get_rows();
1467    for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
1468      row = row_it.data();
1469      row->min_space = static_cast<int32_t>((pitch + nonspace) / 2);
1470      row->max_nonspace = row->min_space;
1471      row->space_threshold = row->min_space;
1472      plot_word_decisions(to_win, static_cast<int16_t>(pitch), row);
1473    }
1474  }
1475  #endif
1476  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-intproto.cpp</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-topitch.cpp</div>
                <div class="column column_space"><pre><code>843    float Angle;
844    float X, Y, HalfLength;
845    float Cos, Sin;
846    float XAdjust, YAdjust;
847    FPOINT Start, Switch1, Switch2, End;
848    int S1 = 0;
849    int S2 = 1;
850    Angle = Proto->Angle;
851    X = Proto->X;
852    Y = Proto->Y;
</pre></code></div>
                <div class="column column_space"><pre><code>101    int like_votes;                
102    int other_votes;               
103    int block_index;               
104    int row_index;                 
105    int maxwidth;                  
106    TO_BLOCK_IT block_it = blocks; 
107    TO_BLOCK *block;               
108    TO_ROW *row;                   
109    float sp_sd;                   
110    STATS block_stats;             
111    STATS like_stats;              
112    block_votes = like_votes = other_votes = 0;
113    maxwidth = static_cast<int32_t>(ceil(bad_row->xheight * textord_words_maxspace));
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    