
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 39, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-w32_regex_traits.hpp</h3>
            <pre><code>1  #ifndef BOOST_W32_REGEX_TRAITS_HPP_INCLUDED
2  #define BOOST_W32_REGEX_TRAITS_HPP_INCLUDED
3  #ifndef BOOST_REGEX_NO_WIN32_LOCALE
4  #include &lt;boost/regex/pattern_except.hpp&gt;
5  #include &lt;boost/regex/v5/regex_traits_defaults.hpp&gt;
6  #ifdef BOOST_HAS_THREADS
7  #include &lt;mutex&gt;
8  #endif
9  #include &lt;boost/regex/v5/primary_transform.hpp&gt;
10  #include &lt;boost/regex/v5/object_cache.hpp&gt;
11  #if defined(_MSC_VER) &amp;&amp; !defined(_WIN32_WCE) &amp;&amp; !defined(UNDER_CE)
12  #pragma comment(lib, &quot;user32.lib&quot;)
13  #endif
14  #ifdef BOOST_REGEX_MSVC
15  #pragma warning(push)
16  #pragma warning(disable:4786)
17  #if BOOST_REGEX_MSVC &lt; 1910
18  #pragma warning(disable:4800)
19  #endif
20  #endif
21  #ifndef BASETYPES
22  #ifndef NO_STRICT
23  #ifndef STRICT
24  #define STRICT 1
25  #endif
26  #endif
27  #if defined(STRICT)
28  #define BOOST_RE_DETAIL_DECLARE_HANDLE(x) struct x##__; typedef struct x##__ *x
29  #else
30  #define BOOST_RE_DETAIL_DECLARE_HANDLE(x) typedef void* x
31  #endif
32  extern &quot;C&quot; {
33     BOOST_RE_DETAIL_DECLARE_HANDLE(HINSTANCE);
34     typedef HINSTANCE HMODULE;
35  }
36  #endif
37  namespace boost{ 
38  template &lt;class charT&gt;
39  class w32_regex_traits;
40  namespace BOOST_REGEX_DETAIL_NS{
41  typedef unsigned long lcid_type;        
42  typedef std::shared_ptr&lt;void&gt; cat_type; 
43  lcid_type  w32_get_default_locale();
44  bool  w32_is_lower(char, lcid_type);
45  #ifndef BOOST_NO_WREGEX
46  bool  w32_is_lower(wchar_t, lcid_type);
47  #endif
48  bool  w32_is_upper(char, lcid_type);
49  #ifndef BOOST_NO_WREGEX
50  bool  w32_is_upper(wchar_t, lcid_type);
51  #endif
52  cat_type  w32_cat_open(const std::string&amp; name);
53  std::string  w32_cat_get(const cat_type&amp; cat, lcid_type state_id, int i, const std::string&amp; def);
54  #ifndef BOOST_NO_WREGEX
55  std::wstring  w32_cat_get(const cat_type&amp; cat, lcid_type state_id, int i, const std::wstring&amp; def);
56  #endif
57  std::string  w32_transform(lcid_type state_id, const char* p1, const char* p2);
58  #ifndef BOOST_NO_WREGEX
59  std::wstring  w32_transform(lcid_type state_id, const wchar_t* p1, const wchar_t* p2);
60  #endif
61  char  w32_tolower(char c, lcid_type);
62  #ifndef BOOST_NO_WREGEX
63  wchar_t  w32_tolower(wchar_t c, lcid_type);
64  #endif
65  char  w32_toupper(char c, lcid_type);
66  #ifndef BOOST_NO_WREGEX
67  wchar_t  w32_toupper(wchar_t c, lcid_type);
68  #endif
69  bool  w32_is(lcid_type, std::uint32_t mask, char c);
70  #ifndef BOOST_NO_WREGEX
71  bool  w32_is(lcid_type, std::uint32_t mask, wchar_t c);
72  #endif
73  #ifndef BASETYPES
74  #if !defined(__LP64__)
75  using dword = unsigned long;
76  #else
77  using DWORD = unsigned int;
78  #endif
79  using word = unsigned short;
80  using lctype = dword;
81  static constexpr dword ct_ctype1 = 0x00000001;
82  static constexpr dword c1_upper = 0x0001;      
83  static constexpr dword c1_lower = 0x0002;      
84  static constexpr dword c1_digit = 0x0004;      
85  static constexpr dword c1_space = 0x0008;      
86  static constexpr dword c1_punct = 0x0010;      
87  static constexpr dword c1_cntrl = 0x0020;      
88  static constexpr dword c1_blank = 0x0040;      
89  static constexpr dword c1_xdigit = 0x0080;      
90  static constexpr dword c1_alpha = 0x0100;      
91  static constexpr dword c1_defined = 0x0200;      
92  static constexpr unsigned int cp_acp = 0;
93  static constexpr dword lcmap_lowercase = 0x00000100;
94  static constexpr dword lcmap_uppercase = 0x00000200;
95  static constexpr dword lcmap_sortkey = 0x00000400;  
96  static constexpr lctype locale_idefaultansicodepage = 0x00001004;
97  # ifdef UNDER_CE
98  #  ifndef WINAPI
99  #   ifndef _WIN32_WCE_EMULATION
100  #    define BOOST_RE_STDCALL __cdecl     
101  #   else
102  #    define BOOST_RE_STDCALL __stdcall
103  #   endif
104  #  endif
105  # else
106  #  if defined(_M_IX86) || defined(__i386__)
107  #   define BOOST_RE_STDCALL __stdcall
108  #  else
109  #   define BOOST_RE_STDCALL
110  #  endif
111  # endif
112  #if defined (WIN32_PLATFORM_PSPC)
113  #define BOOST_RE_IMPORT __declspec( dllimport )
114  #elif defined (_WIN32_WCE)
115  #define BOOST_RE_IMPORT
116  #else
117  #define BOOST_RE_IMPORT __declspec( dllimport )
118  #endif
119  extern &quot;C&quot; {
120     BOOST_RE_IMPORT int BOOST_RE_STDCALL FreeLibrary(HMODULE hLibModule);
121     BOOST_RE_IMPORT int BOOST_RE_STDCALL LCMapStringA(lcid_type Locale, dword dwMapFlags, const char* lpSrcStr, int cchSrc, char* lpDestStr, int cchDest);
122     BOOST_RE_IMPORT int BOOST_RE_STDCALL LCMapStringW(lcid_type Locale, dword dwMapFlags, const wchar_t* lpSrcStr, int cchSrc, wchar_t* lpDestStr, int cchDest);
123     BOOST_RE_IMPORT int BOOST_RE_STDCALL MultiByteToWideChar(unsigned int CodePage, dword dwFlags, const char* lpMultiByteStr, int cbMultiByte, wchar_t* lpWideCharStr, int cchWideChar);
124     BOOST_RE_IMPORT int BOOST_RE_STDCALL LCMapStringW(lcid_type Locale, dword dwMapFlags, const wchar_t* lpSrcStr, int cchSrc, wchar_t* lpDestStr, int cchDest);
125     BOOST_RE_IMPORT int BOOST_RE_STDCALL WideCharToMultiByte(unsigned int CodePage, dword dwFlags, const wchar_t* lpWideCharStr, int cchWideChar, char* lpMultiByteStr, int cbMultiByte, const char* lpDefaultChar, int* lpUsedDefaultChar);
126     BOOST_RE_IMPORT int BOOST_RE_STDCALL GetStringTypeExA(lcid_type Locale, dword dwInfoType, const char* lpSrcStr, int cchSrc, word* lpCharType);
127     BOOST_RE_IMPORT int BOOST_RE_STDCALL GetStringTypeExW(lcid_type Locale, dword dwInfoType, const wchar_t* lpSrcStr, int cchSrc, word* lpCharType);
128     BOOST_RE_IMPORT lcid_type BOOST_RE_STDCALL GetUserDefaultLCID();
129     BOOST_RE_IMPORT int BOOST_RE_STDCALL GetStringTypeExA(lcid_type Locale, dword dwInfoType, const char* lpSrcStr, int cchSrc, word* lpCharType);
130     BOOST_RE_IMPORT int BOOST_RE_STDCALL GetStringTypeExW(lcid_type Locale, dword dwInfoType, const wchar_t* lpSrcStr, int cchSrc, word* lpCharType);
131     BOOST_RE_IMPORT HMODULE BOOST_RE_STDCALL LoadLibraryA(const char* lpLibFileName);
132     BOOST_RE_IMPORT HMODULE BOOST_RE_STDCALL LoadLibraryW(const wchar_t* lpLibFileName);
133     BOOST_RE_IMPORT int BOOST_RE_STDCALL LoadStringW(HINSTANCE hInstance, unsigned int uID, wchar_t* lpBuffer, int cchBufferMax);
134     BOOST_RE_IMPORT int BOOST_RE_STDCALL LoadStringA(HINSTANCE hInstance, unsigned int uID, char* lpBuffer, int cchBufferMax);
135     BOOST_RE_IMPORT int BOOST_RE_STDCALL GetLocaleInfoW(lcid_type Locale, lctype LCType, wchar_t* lpLCData, int cchData);
136  }
137  #else
138  using dword = DWORD;
139  using word = WORD;
140  using lctype = LCTYPE;
141  static constexpr dword ct_ctype1 = 0x00000001;
142  static constexpr dword c1_upper = 0x0001;      
143  static constexpr dword c1_lower = 0x0002;      
144  static constexpr dword c1_digit = 0x0004;      
145  static constexpr dword c1_space = 0x0008;      
146  static constexpr dword c1_punct = 0x0010;      
147  static constexpr dword c1_cntrl = 0x0020;      
148  static constexpr dword c1_blank = 0x0040;      
149  static constexpr dword c1_xdigit = 0x0080;      
150  static constexpr dword c1_alpha = 0x0100;      
151  static constexpr dword c1_defined = 0x0200;      
152  static constexpr unsigned int cp_acp = 0;
153  static constexpr dword lcmap_lowercase = 0x00000100;
154  static constexpr dword lcmap_uppercase = 0x00000200;
155  static constexpr dword lcmap_sortkey = 0x00000400;  
156  static constexpr lctype locale_idefaultansicodepage = 0x00001004;
157  using ::FreeLibrary;
158  using ::LCMapStringA;
159  using ::LCMapStringW;
160  using ::MultiByteToWideChar;
161  using ::LCMapStringW;
162  using ::WideCharToMultiByte;
163  using ::GetStringTypeExA;
164  using ::GetStringTypeExW;
165  using ::GetUserDefaultLCID;
166  using ::GetStringTypeExA;
167  using ::GetStringTypeExW;
168  using ::LoadLibraryA;
169  using ::LoadLibraryW;
170  using ::LoadStringW;
171  using ::LoadStringA;
172  using ::GetLocaleInfoW;
173  #endif
174  template &lt;class charT&gt;
175  struct w32_regex_traits_base
176  {
177     w32_regex_traits_base(lcid_type l)
178     { imbue(l); }
179     lcid_type imbue(lcid_type l);
180     lcid_type m_locale;
181  };
182  template &lt;class charT&gt;
183  inline lcid_type w32_regex_traits_base&lt;charT&gt;::imbue(lcid_type l)
184  {
185     lcid_type result(m_locale);
186     m_locale = l;
187     return result;
188  }
189  template &lt;class charT&gt;
190  class w32_regex_traits_char_layer : public w32_regex_traits_base&lt;charT&gt;
191  {
192     typedef std::basic_string&lt;charT&gt; string_type;
193     typedef std::map&lt;charT, regex_constants::syntax_type&gt; map_type;
194     typedef typename map_type::const_iterator map_iterator_type;
195  public:
196     w32_regex_traits_char_layer(const lcid_type l);
197     regex_constants::syntax_type syntax_type(charT c)const
198     {
199        map_iterator_type i = m_char_map.find(c);
200        return ((i == m_char_map.end()) ? 0 : i-&gt;second);
201     }
202     regex_constants::escape_syntax_type escape_syntax_type(charT c) const
203     {
204        map_iterator_type i = m_char_map.find(c);
205        if(i == m_char_map.end())
206        {
207           if(::boost::BOOST_REGEX_DETAIL_NS::w32_is_lower(c, this-&gt;m_locale)) return regex_constants::escape_type_class;
208           if(::boost::BOOST_REGEX_DETAIL_NS::w32_is_upper(c, this-&gt;m_locale)) return regex_constants::escape_type_not_class;
209           return 0;
210        }
211        return i-&gt;second;
212     }
213     charT tolower(charT c)const
214     {
215        return ::boost::BOOST_REGEX_DETAIL_NS::w32_tolower(c, this-&gt;m_locale);
216     }
217     bool isctype(std::uint32_t mask, charT c)const
218     {
219        return ::boost::BOOST_REGEX_DETAIL_NS::w32_is(this-&gt;m_locale, mask, c);
220     }
221  private:
222     string_type get_default_message(regex_constants::syntax_type);
223     map_type m_char_map;
224  };
225  template &lt;class charT&gt;
226  w32_regex_traits_char_layer&lt;charT&gt;::w32_regex_traits_char_layer(::boost::BOOST_REGEX_DETAIL_NS::lcid_type l) 
227     : w32_regex_traits_base&lt;charT&gt;(l)
228  {
229     cat_type cat;
230     std::string cat_name(w32_regex_traits&lt;charT&gt;::get_catalog_name());
231     if(cat_name.size())
232     {
233        cat = ::boost::BOOST_REGEX_DETAIL_NS::w32_cat_open(cat_name);
234        if(!cat)
235        {
236           std::string m(&quot;Unable to open message catalog: &quot;);
237           std::runtime_error err(m + cat_name);
238           boost::BOOST_REGEX_DETAIL_NS::raise_runtime_error(err);
239        }
240     }
241     if(cat)
242     {
243        for(regex_constants::syntax_type i = 1; i &lt; regex_constants::syntax_max; ++i)
244        {
245           string_type mss = ::boost::BOOST_REGEX_DETAIL_NS::w32_cat_get(cat, this-&gt;m_locale, i, get_default_message(i));
246           for(typename string_type::size_type j = 0; j &lt; mss.size(); ++j)
247           {
248              this-&gt;m_char_map[mss[j]] = i;
249           }
250        }
251     }
252     else
253     {
254        for(regex_constants::syntax_type i = 1; i &lt; regex_constants::syntax_max; ++i)
255        {
256           const char* ptr = get_default_syntax(i);
257           while(ptr &amp;&amp; *ptr)
258           {
259              this-&gt;m_char_map[static_cast&lt;charT&gt;(*ptr)] = i;
260              ++ptr;
261           }
262        }
263     }
264  }
265  template &lt;class charT&gt;
266  typename w32_regex_traits_char_layer&lt;charT&gt;::string_type 
267     w32_regex_traits_char_layer&lt;charT&gt;::get_default_message(regex_constants::syntax_type i)
268  {
269     const char* ptr = get_default_syntax(i);
270     string_type result;
271     while(ptr &amp;&amp; *ptr)
272     {
273        result.append(1, static_cast&lt;charT&gt;(*ptr));
274        ++ptr;
275     }
276     return result;
277  }
278  template &lt;&gt;
279  class w32_regex_traits_char_layer&lt;char&gt; : public w32_regex_traits_base&lt;char&gt;
280  {
281     typedef std::string string_type;
282  public:
283     w32_regex_traits_char_layer(::boost::BOOST_REGEX_DETAIL_NS::lcid_type l)
284     : w32_regex_traits_base&lt;char&gt;(l)
285     {
286        init&lt;char&gt;();
287     }
288     regex_constants::syntax_type syntax_type(char c)const
289     {
290        return m_char_map[static_cast&lt;unsigned char&gt;(c)];
291     }
292     regex_constants::escape_syntax_type escape_syntax_type(char c) const
293     {
294        return m_char_map[static_cast&lt;unsigned char&gt;(c)];
295     }
296     char tolower(char c)const
297     {
298        return m_lower_map[static_cast&lt;unsigned char&gt;(c)];
299     }
300     bool isctype(std::uint32_t mask, char c)const
301     {
302        return m_type_map[static_cast&lt;unsigned char&gt;(c)] &amp; mask;
303     }
304  private:
305     regex_constants::syntax_type m_char_map[1u &lt;&lt; CHAR_BIT];
306     char m_lower_map[1u &lt;&lt; CHAR_BIT];
307     std::uint16_t m_type_map[1u &lt;&lt; CHAR_BIT];
308     template &lt;class U&gt;
309     void init();
310  };
311  template &lt;class charT&gt;
312  class w32_regex_traits_implementation : public w32_regex_traits_char_layer&lt;charT&gt;
313  {
314  public:
315     typedef typename w32_regex_traits&lt;charT&gt;::char_class_type char_class_type;
316     static const char_class_type mask_word = 0x0400; 
317     static const char_class_type mask_unicode = 0x0800; 
318     static const char_class_type mask_horizontal = 0x1000; 
319     static const char_class_type mask_vertical = 0x2000; 
320     static const char_class_type mask_base = 0x3ff;  
321     typedef std::basic_string&lt;charT&gt; string_type;
322     typedef charT char_type;
323     w32_regex_traits_implementation(::boost::BOOST_REGEX_DETAIL_NS::lcid_type l);
324     std::string error_string(regex_constants::error_type n) const
325     {
326        if(!m_error_strings.empty())
327        {
328           std::map&lt;int, std::string&gt;::const_iterator p = m_error_strings.find(n);
329           return (p == m_error_strings.end()) ? std::string(get_default_error_string(n)) : p-&gt;second;
330        }
331        return get_default_error_string(n);
332     }
333     char_class_type lookup_classname(const charT* p1, const charT* p2) const
334     {
335        char_class_type result = lookup_classname_imp(p1, p2);
336        if(result == 0)
337        {
338           typedef typename string_type::size_type size_type;
339           string_type temp(p1, p2);
340           for(size_type i = 0; i &lt; temp.size(); ++i)
341              temp[i] = this-&gt;tolower(temp[i]);
342           result = lookup_classname_imp(&amp;*temp.begin(), &amp;*temp.begin() + temp.size());
343        }
344        return result;
345     }
346     string_type lookup_collatename(const charT* p1, const charT* p2) const;
347     string_type transform_primary(const charT* p1, const charT* p2) const;
348     string_type transform(const charT* p1, const charT* p2) const
349     {
350        return ::boost::BOOST_REGEX_DETAIL_NS::w32_transform(this-&gt;m_locale, p1, p2);
351     }
352  private:
353     std::map&lt;int, std::string&gt;     m_error_strings;   
354     std::map&lt;string_type, char_class_type&gt;  m_custom_class_names; 
355     std::map&lt;string_type, string_type&gt;      m_custom_collate_names; 
356     unsigned                       m_collate_type;    
357     charT                          m_collate_delim;   
358     char_class_type lookup_classname_imp(const charT* p1, const charT* p2) const;
359  };
360  template &lt;class charT&gt;
361  typename w32_regex_traits_implementation&lt;charT&gt;::string_type 
362     w32_regex_traits_implementation&lt;charT&gt;::transform_primary(const charT* p1, const charT* p2) const
363  {
364     string_type result;
365     switch(m_collate_type)
366     {
367     case sort_C:
368     case sort_unknown:
369        {
370           result.assign(p1, p2);
371           typedef typename string_type::size_type size_type;
372           for(size_type i = 0; i &lt; result.size(); ++i)
373              result[i] = this-&gt;tolower(result[i]);
374           result = this-&gt;transform(&amp;*result.begin(), &amp;*result.begin() + result.size());
375           break;
376        }
377     case sort_fixed:
378        {
379           result.assign(this-&gt;transform(p1, p2));
380           result.erase(this-&gt;m_collate_delim);
381           break;
382        }
383     case sort_delim:
384           result.assign(this-&gt;transform(p1, p2));
385           std::size_t i;
386           for(i = 0; i &lt; result.size(); ++i)
387           {
388              if(result[i] == m_collate_delim)
389                 break;
390           }
391           result.erase(i);
392           break;
393     }
394     if(result.empty())
395        result = string_type(1, charT(0));
396     return result;
397  }
398  template &lt;class charT&gt;
399  typename w32_regex_traits_implementation&lt;charT&gt;::string_type 
400     w32_regex_traits_implementation&lt;charT&gt;::lookup_collatename(const charT* p1, const charT* p2) const
401  {
402     typedef typename std::map&lt;string_type, string_type&gt;::const_iterator iter_type;
403     if(m_custom_collate_names.size())
404     {
405        iter_type pos = m_custom_collate_names.find(string_type(p1, p2));
406        if(pos != m_custom_collate_names.end())
407           return pos-&gt;second;
408     }
409     std::string name(p1, p2);
410     name = lookup_default_collate_name(name);
411     if(name.size())
412        return string_type(name.begin(), name.end());
413     if(p2 - p1 == 1)
414        return string_type(1, *p1);
415     return string_type();
416  }
417  template &lt;class charT&gt;
418  w32_regex_traits_implementation&lt;charT&gt;::w32_regex_traits_implementation(::boost::BOOST_REGEX_DETAIL_NS::lcid_type l)
419  : w32_regex_traits_char_layer&lt;charT&gt;(l)
420  {
421     cat_type cat;
422     std::string cat_name(w32_regex_traits&lt;charT&gt;::get_catalog_name());
423     if(cat_name.size())
424     {
425        cat = ::boost::BOOST_REGEX_DETAIL_NS::w32_cat_open(cat_name);
426        if(!cat)
427        {
428           std::string m(&quot;Unable to open message catalog: &quot;);
429           std::runtime_error err(m + cat_name);
430           boost::BOOST_REGEX_DETAIL_NS::raise_runtime_error(err);
431        }
432     }
433     if(cat)
434     {
435        for(boost::regex_constants::error_type i = static_cast&lt;boost::regex_constants::error_type&gt;(0); 
436           i &lt;= boost::regex_constants::error_unknown; 
437           i = static_cast&lt;boost::regex_constants::error_type&gt;(i + 1))
438        {
439           const char* p = get_default_error_string(i);
440           string_type default_message;
441           while(*p)
442           {
443              default_message.append(1, static_cast&lt;charT&gt;(*p));
444              ++p;
445           }
446           string_type s = ::boost::BOOST_REGEX_DETAIL_NS::w32_cat_get(cat, this-&gt;m_locale, i+200, default_message);
447           std::string result;
448           for(std::string::size_type j = 0; j &lt; s.size(); ++j)
449           {
450              result.append(1, static_cast&lt;char&gt;(s[j]));
451           }
452           m_error_strings[i] = result;
453        }
454        static const char_class_type masks[14] = 
455        {
456           0x0104u, 
457           0x0100u, 
458           0x0020u, 
459           0x0004u, 
460           (~(0x0020u|0x0008u) &amp; 0x01ffu) | 0x0400u, 
461           0x0002u, 
462           (~0x0020u &amp; 0x01ffu) | 0x0400, 
463           0x0010u, 
464           0x0008u, 
465           0x0001u, 
466           0x0080u, 
467           0x0040u, 
468           w32_regex_traits_implementation&lt;charT&gt;::mask_word,
469           w32_regex_traits_implementation&lt;charT&gt;::mask_unicode,
470        };
471        static const string_type null_string;
472        for(unsigned int j = 0; j &lt;= 13; ++j)
473        {
474           string_type s(::boost::BOOST_REGEX_DETAIL_NS::w32_cat_get(cat, this-&gt;m_locale, j+300, null_string));
475           if(s.size())
476              this-&gt;m_custom_class_names[s] = masks[j];
477        }
478     }
479     m_collate_type = BOOST_REGEX_DETAIL_NS::find_sort_syntax(this, &amp;m_collate_delim);
480  }
481  template &lt;class charT&gt;
482  typename w32_regex_traits_implementation&lt;charT&gt;::char_class_type 
483     w32_regex_traits_implementation&lt;charT&gt;::lookup_classname_imp(const charT* p1, const charT* p2) const
484  {
485     static const char_class_type masks[22] = 
486     {
487        0,
488        0x0104u, 
489        0x0100u, 
490        0x0040u, 
491        0x0020u, 
492        0x0004u, 
493        0x0004u, 
494        (~(0x0020u|0x0008u|0x0040) &amp; 0x01ffu) | 0x0400u, 
495        w32_regex_traits_implementation&lt;charT&gt;::mask_horizontal, 
496        0x0002u, 
497        0x0002u, 
498        (~0x0020u &amp; 0x01ffu) | 0x0400, 
499        0x0010u, 
500        0x0008u, 
501        0x0008u, 
502        0x0001u, 
503        w32_regex_traits_implementation&lt;charT&gt;::mask_unicode,
504        0x0001u, 
505        w32_regex_traits_implementation&lt;charT&gt;::mask_vertical, 
506        0x0104u | w32_regex_traits_implementation&lt;charT&gt;::mask_word, 
507        0x0104u | w32_regex_traits_implementation&lt;charT&gt;::mask_word, 
508        0x0080u, 
509     };
510     if(m_custom_class_names.size())
511     {
512        typedef typename std::map&lt;std::basic_string&lt;charT&gt;, char_class_type&gt;::const_iterator map_iter;
513        map_iter pos = m_custom_class_names.find(string_type(p1, p2));
514        if(pos != m_custom_class_names.end())
515           return pos-&gt;second;
516     }
517     std::size_t state_id = 1u + (std::size_t)BOOST_REGEX_DETAIL_NS::get_default_class_id(p1, p2);
518     if(state_id &lt; sizeof(masks) / sizeof(masks[0]))
519        return masks[state_id];
520     return masks[0];
521  }
522  template &lt;class charT&gt;
523  std::shared_ptr&lt;const w32_regex_traits_implementation&lt;charT&gt; &gt; create_w32_regex_traits(::boost::BOOST_REGEX_DETAIL_NS::lcid_type l)
524  {
525     return boost::object_cache&lt; ::boost::BOOST_REGEX_DETAIL_NS::lcid_type, w32_regex_traits_implementation&lt;charT&gt; &gt;::get(l, 5);
526  }
527  } 
528  template &lt;class charT&gt;
529  class w32_regex_traits
530  {
531  public:
532     typedef charT                         char_type;
533     typedef std::size_t                   size_type;
534     typedef std::basic_string&lt;char_type&gt;  string_type;
535     typedef ::boost::BOOST_REGEX_DETAIL_NS::lcid_type locale_type;
536     typedef std::uint_least32_t         char_class_type;
537     struct boost_extensions_tag{};
538     w32_regex_traits()
539        : m_pimpl(BOOST_REGEX_DETAIL_NS::create_w32_regex_traits&lt;charT&gt;(::boost::BOOST_REGEX_DETAIL_NS::w32_get_default_locale()))
540     { }
541     static size_type length(const char_type* p)
542     {
543        return std::char_traits&lt;charT&gt;::length(p);
544     }
545     regex_constants::syntax_type syntax_type(charT c)const
546     {
547        return m_pimpl-&gt;syntax_type(c);
548     }
549     regex_constants::escape_syntax_type escape_syntax_type(charT c) const
550     {
551        return m_pimpl-&gt;escape_syntax_type(c);
552     }
553     charT translate(charT c) const
554     {
555        return c;
556     }
557     charT translate_nocase(charT c) const
558     {
559        return this-&gt;m_pimpl-&gt;tolower(c);
560     }
561     charT translate(charT c, bool icase) const
562     {
563        return icase ? this-&gt;m_pimpl-&gt;tolower(c) : c;
564     }
565     charT tolower(charT c) const
566     {
567        return this-&gt;m_pimpl-&gt;tolower(c);
568     }
569     charT toupper(charT c) const
570     {
571        return ::boost::BOOST_REGEX_DETAIL_NS::w32_toupper(c, this-&gt;m_pimpl-&gt;m_locale);
572     }
573     string_type transform(const charT* p1, const charT* p2) const
574     {
575        return ::boost::BOOST_REGEX_DETAIL_NS::w32_transform(this-&gt;m_pimpl-&gt;m_locale, p1, p2);
576     }
577     string_type transform_primary(const charT* p1, const charT* p2) const
578     {
579        return m_pimpl-&gt;transform_primary(p1, p2);
580     }
581     char_class_type lookup_classname(const charT* p1, const charT* p2) const
582     {
583        return m_pimpl-&gt;lookup_classname(p1, p2);
584     }
585     string_type lookup_collatename(const charT* p1, const charT* p2) const
586     {
587        return m_pimpl-&gt;lookup_collatename(p1, p2);
588     }
589     bool isctype(charT c, char_class_type f) const
590     {
591        if((f &amp; BOOST_REGEX_DETAIL_NS::w32_regex_traits_implementation&lt;charT&gt;::mask_base) 
592           &amp;&amp; (this-&gt;m_pimpl-&gt;isctype(f &amp; BOOST_REGEX_DETAIL_NS::w32_regex_traits_implementation&lt;charT&gt;::mask_base, c)))
593           return true;
594        else if((f &amp; BOOST_REGEX_DETAIL_NS::w32_regex_traits_implementation&lt;charT&gt;::mask_unicode) &amp;&amp; BOOST_REGEX_DETAIL_NS::is_extended(c))
595           return true;
596        else if((f &amp; BOOST_REGEX_DETAIL_NS::w32_regex_traits_implementation&lt;charT&gt;::mask_word) &amp;&amp; (c == &#x27;_&#x27;))
597           return true;
598        else if((f &amp; BOOST_REGEX_DETAIL_NS::w32_regex_traits_implementation&lt;charT&gt;::mask_vertical)
599           &amp;&amp; (::boost::BOOST_REGEX_DETAIL_NS::is_separator(c) || (c == &#x27;\v&#x27;)))
600           return true;
601        else if((f &amp; BOOST_REGEX_DETAIL_NS::w32_regex_traits_implementation&lt;charT&gt;::mask_horizontal) 
602           &amp;&amp; this-&gt;isctype(c, 0x0008u) &amp;&amp; !this-&gt;isctype(c, BOOST_REGEX_DETAIL_NS::w32_regex_traits_implementation&lt;charT&gt;::mask_vertical))
603           return true;
604        return false;
605     }
606     std::intmax_t toi(const charT*&amp; p1, const charT* p2, int radix)const
607     {
608        return ::boost::BOOST_REGEX_DETAIL_NS::global_toi(p1, p2, radix, *this);
609     }
610     int value(charT c, int radix)const
611     {
612        int result = (int)::boost::BOOST_REGEX_DETAIL_NS::global_value(c);
613        return result &lt; radix ? result : -1;
614     }
615     locale_type imbue(locale_type l)
616     {
617        ::boost::BOOST_REGEX_DETAIL_NS::lcid_type result(getloc());
618        m_pimpl = BOOST_REGEX_DETAIL_NS::create_w32_regex_traits&lt;charT&gt;(l);
619        return result;
620     }
621     locale_type getloc()const
622     {
623        return m_pimpl-&gt;m_locale;
624     }
625     std::string error_string(regex_constants::error_type n) const
626     {
627        return m_pimpl-&gt;error_string(n);
628     }
629     static std::string catalog_name(const std::string&amp; name);
630     static std::string get_catalog_name();
631  private:
632     std::shared_ptr&lt;const BOOST_REGEX_DETAIL_NS::w32_regex_traits_implementation&lt;charT&gt; &gt; m_pimpl;
633     static std::string&amp; get_catalog_name_inst();
634  #ifdef BOOST_HAS_THREADS
635     static std::mutex&amp; get_mutex_inst();
636  #endif
637  };
638  template &lt;class charT&gt;
639  std::string w32_regex_traits&lt;charT&gt;::catalog_name(const std::string&amp; name)
640  {
641  #ifdef BOOST_HAS_THREADS
642     std::lock_guard&lt;std::mutex&gt; lk(get_mutex_inst());
643  #endif
644     std::string result(get_catalog_name_inst());
645     get_catalog_name_inst() = name;
646     return result;
647  }
648  template &lt;class charT&gt;
649  std::string&amp; w32_regex_traits&lt;charT&gt;::get_catalog_name_inst()
650  {
651     static std::string s_name;
652     return s_name;
653  }
654  template &lt;class charT&gt;
655  std::string w32_regex_traits&lt;charT&gt;::get_catalog_name()
656  {
657  #ifdef BOOST_HAS_THREADS
658     std::lock_guard&lt;std::mutex&gt; lk(get_mutex_inst());
659  #endif
660     std::string result(get_catalog_name_inst());
661     return result;
662  }
663  #ifdef BOOST_HAS_THREADS
664  template &lt;class charT&gt;
665  std::mutex&amp; w32_regex_traits&lt;charT&gt;::get_mutex_inst()
666  {
667     static std::mutex s_mutex;
668     return s_mutex;
669  }
670  #endif
671  namespace BOOST_REGEX_DETAIL_NS {
672  #ifdef BOOST_NO_ANSI_APIS
673     inline unsigned int get_code_page_for_locale_id(lcid_type idx)
674     {
675        wchar_t code_page_string[7];
676        if (boost::BOOST_REGEX_DETAIL_NS::GetLocaleInfoW(idx, locale_idefaultansicodepage, code_page_string, 7) == 0)
677           return 0;
678        return static_cast&lt;unsigned int&gt;(_wtol(code_page_string));
679  }
680  #endif
681     template &lt;class U&gt;
682     inline void w32_regex_traits_char_layer&lt;char&gt;::init()
683     {
684        std::memset(m_char_map, 0, sizeof(m_char_map));
685        cat_type cat;
686        std::string cat_name(w32_regex_traits&lt;char&gt;::get_catalog_name());
687        if (cat_name.size())
688        {
689           cat = ::boost::BOOST_REGEX_DETAIL_NS::w32_cat_open(cat_name);
690           if (!cat)
691           {
692              std::string m(&quot;Unable to open message catalog: &quot;);
693              std::runtime_error err(m + cat_name);
694              ::boost::BOOST_REGEX_DETAIL_NS::raise_runtime_error(err);
695           }
696        }
697        if (cat)
698        {
699           for (regex_constants::syntax_type i = 1; i &lt; regex_constants::syntax_max; ++i)
700           {
701              string_type mss = ::boost::BOOST_REGEX_DETAIL_NS::w32_cat_get(cat, this-&gt;m_locale, i, get_default_syntax(i));
702              for (string_type::size_type j = 0; j &lt; mss.size(); ++j)
703              {
704                 m_char_map[static_cast&lt;unsigned char&gt;(mss[j])] = i;
705              }
706           }
707        }
708        else
709        {
710           for (regex_constants::syntax_type i = 1; i &lt; regex_constants::syntax_max; ++i)
711           {
712              const char* ptr = get_default_syntax(i);
713              while (ptr &amp;&amp; *ptr)
714              {
<span onclick='openModal()' class='match'>715                 m_char_map[static_cast&lt;unsigned char&gt;(*ptr)] = i;
716                 ++ptr;
717              }
718           }
719        }
720        unsigned char i = &#x27;A&#x27;;
721        do
722        {
723           if (m_char_map[i] == 0)
724           {
725              if (::boost::BOOST_REGEX_DETAIL_NS::w32_is(this-&gt;m_locale, 0x0002u, (char)i))
</span>726                 m_char_map[i] = regex_constants::escape_type_class;
727              else if (::boost::BOOST_REGEX_DETAIL_NS::w32_is(this-&gt;m_locale, 0x0001u, (char)i))
728                 m_char_map[i] = regex_constants::escape_type_not_class;
729           }
730        } while (0xFF != i++);
731        char char_map[1 &lt;&lt; CHAR_BIT];
732        for (int ii = 0; ii &lt; (1 &lt;&lt; CHAR_BIT); ++ii)
733           char_map[ii] = static_cast&lt;char&gt;(ii);
734  #ifndef BOOST_NO_ANSI_APIS
735        int r = boost::BOOST_REGEX_DETAIL_NS::LCMapStringA(this-&gt;m_locale, lcmap_lowercase, char_map, 1 &lt;&lt; CHAR_BIT, this-&gt;m_lower_map, 1 &lt;&lt; CHAR_BIT);
736        BOOST_REGEX_ASSERT(r != 0);
737  #else
738        unsigned int code_page = get_code_page_for_locale_id(this-&gt;m_locale);
739        BOOST_REGEX_ASSERT(code_page != 0);
740        wchar_t wide_char_map[1 &lt;&lt; CHAR_BIT];
741        int conv_r = boost::BOOST_REGEX_DETAIL_NS::MultiByteToWideChar(code_page, 0, char_map, 1 &lt;&lt; CHAR_BIT, wide_char_map, 1 &lt;&lt; CHAR_BIT);
742        BOOST_REGEX_ASSERT(conv_r != 0);
743        wchar_t wide_lower_map[1 &lt;&lt; CHAR_BIT];
744        int r = boost::BOOST_REGEX_DETAIL_NS::LCMapStringW(this-&gt;m_locale, lcmap_lowercase, wide_char_map, 1 &lt;&lt; CHAR_BIT, wide_lower_map, 1 &lt;&lt; CHAR_BIT);
745        BOOST_REGEX_ASSERT(r != 0);
746        conv_r = boost::BOOST_REGEX_DETAIL_NS::WideCharToMultiByte(code_page, 0, wide_lower_map, r, this-&gt;m_lower_map, 1 &lt;&lt; CHAR_BIT, NULL, NULL);
747        BOOST_REGEX_ASSERT(conv_r != 0);
748  #endif
749        if (r &lt; (1 &lt;&lt; CHAR_BIT))
750        {
751           for (int jj = r; jj &lt; (1 &lt;&lt; CHAR_BIT); ++jj)
752              this-&gt;m_lower_map[jj] = static_cast&lt;char&gt;(jj);
753        }
754  #ifndef BOOST_NO_ANSI_APIS
755        r = boost::BOOST_REGEX_DETAIL_NS::GetStringTypeExA(this-&gt;m_locale, ct_ctype1, char_map, 1 &lt;&lt; CHAR_BIT, this-&gt;m_type_map);
756  #else
757        r = boost::BOOST_REGEX_DETAIL_NS::GetStringTypeExW(this-&gt;m_locale, ct_ctype1, wide_char_map, 1 &lt;&lt; CHAR_BIT, this-&gt;m_type_map);
758  #endif
759        BOOST_REGEX_ASSERT(0 != r);
760     }
761     inline lcid_type  w32_get_default_locale()
762     {
763        return boost::BOOST_REGEX_DETAIL_NS::GetUserDefaultLCID();
764     }
765     inline bool  w32_is_lower(char c, lcid_type idx)
766     {
767  #ifndef BOOST_NO_ANSI_APIS
768        word mask;
769        if (boost::BOOST_REGEX_DETAIL_NS::GetStringTypeExA(idx, ct_ctype1, &amp;c, 1, &amp;mask) &amp;&amp; (mask &amp; c1_lower))
770           return true;
771        return false;
772  #else
773        unsigned int code_page = get_code_page_for_locale_id(idx);
774        if (code_page == 0)
775           return false;
776        wchar_t wide_c;
777        if (boost::BOOST_REGEX_DETAIL_NS::MultiByteToWideChar(code_page, 0, &amp;c, 1, &amp;wide_c, 1) == 0)
778           return false;
779        word mask;
780        if (boost::BOOST_REGEX_DETAIL_NS::GetStringTypeExW(idx, ct_ctype1, &amp;wide_c, 1, &amp;mask) &amp;&amp; (mask &amp; c1_lower))
781           return true;
782        return false;
783  #endif
784     }
785     inline bool  w32_is_lower(wchar_t c, lcid_type idx)
786     {
787        word mask;
788        if (boost::BOOST_REGEX_DETAIL_NS::GetStringTypeExW(idx, ct_ctype1, &amp;c, 1, &amp;mask) &amp;&amp; (mask &amp; c1_lower))
789           return true;
790        return false;
791     }
792     inline bool  w32_is_upper(char c, lcid_type idx)
793     {
794  #ifndef BOOST_NO_ANSI_APIS
795        word mask;
796        if (boost::BOOST_REGEX_DETAIL_NS::GetStringTypeExA(idx, ct_ctype1, &amp;c, 1, &amp;mask) &amp;&amp; (mask &amp; c1_upper))
797           return true;
798        return false;
799  #else
800        unsigned int code_page = get_code_page_for_locale_id(idx);
801        if (code_page == 0)
802           return false;
803        wchar_t wide_c;
804        if (boost::BOOST_REGEX_DETAIL_NS::MultiByteToWideChar(code_page, 0, &amp;c, 1, &amp;wide_c, 1) == 0)
805           return false;
806        word mask;
807        if (boost::BOOST_REGEX_DETAIL_NS::GetStringTypeExW(idx, ct_ctype1, &amp;wide_c, 1, &amp;mask) &amp;&amp; (mask &amp; c1_upper))
808           return true;
809        return false;
810  #endif
811     }
812     inline bool  w32_is_upper(wchar_t c, lcid_type idx)
813     {
814        word mask;
815        if (boost::BOOST_REGEX_DETAIL_NS::GetStringTypeExW(idx, ct_ctype1, &amp;c, 1, &amp;mask) &amp;&amp; (mask &amp; c1_upper))
816           return true;
817        return false;
818     }
819     inline void free_module(void* mod)
820     {
821        boost::BOOST_REGEX_DETAIL_NS::FreeLibrary(static_cast&lt;HMODULE&gt;(mod));
822     }
823     inline cat_type  w32_cat_open(const std::string&amp; name)
824     {
825  #ifndef BOOST_NO_ANSI_APIS
826        cat_type result(boost::BOOST_REGEX_DETAIL_NS::LoadLibraryA(name.c_str()), &amp;free_module);
827        return result;
828  #else
829        wchar_t* wide_name = (wchar_t*)_alloca((name.size() + 1) * sizeof(wchar_t));
830        if (boost::BOOST_REGEX_DETAIL_NS::MultiByteToWideChar(cp_acp, 0, name.c_str(), (int)name.size(), wide_name, (int)(name.size() + 1)) == 0)
831           return cat_type();
832        cat_type result(boost::BOOST_REGEX_DETAIL_NS::LoadLibraryW(wide_name), &amp;free_module);
833        return result;
834  #endif
835     }
836     inline std::string  w32_cat_get(const cat_type&amp; cat, lcid_type, int i, const std::string&amp; def)
837     {
838  #ifndef BOOST_NO_ANSI_APIS
839        char buf[256];
840        if (0 == boost::BOOST_REGEX_DETAIL_NS::LoadStringA(
841           static_cast&lt;HMODULE&gt;(cat.get()),
842           i,
843           buf,
844           256
845        ))
846        {
847           return def;
848        }
849  #else
850        wchar_t wbuf[256];
851        int r = boost::BOOST_REGEX_DETAIL_NS::LoadStringW(
852           static_cast&lt;HMODULE&gt;(cat.get()),
853           i,
854           wbuf,
855           256
856        );
857        if (r == 0)
858           return def;
859        int buf_size = 1 + boost::BOOST_REGEX_DETAIL_NS::WideCharToMultiByte(cp_acp, 0, wbuf, r, NULL, 0, NULL, NULL);
860        char* buf = (char*)_alloca(buf_size);
861        if (boost::BOOST_REGEX_DETAIL_NS::WideCharToMultiByte(cp_acp, 0, wbuf, r, buf, buf_size, NULL, NULL) == 0)
862           return def; 
863  #endif
864        return std::string(buf);
865     }
866  #ifndef BOOST_NO_WREGEX
867     inline std::wstring  w32_cat_get(const cat_type&amp; cat, lcid_type, int i, const std::wstring&amp; def)
868     {
869        wchar_t buf[256];
870        if (0 == boost::BOOST_REGEX_DETAIL_NS::LoadStringW(static_cast&lt;HMODULE&gt;(cat.get()), i, buf, 256))
871        {
872           return def;
873        }
874        return std::wstring(buf);
875     }
876  #endif
877     inline std::string  w32_transform(lcid_type idx, const char* p1, const char* p2)
878     {
879  #ifndef BOOST_NO_ANSI_APIS
880        int bytes = boost::BOOST_REGEX_DETAIL_NS::LCMapStringA(
881           idx,       
882           lcmap_sortkey,  
883           p1,  
884           static_cast&lt;int&gt;(p2 - p1),        
885           0,  
886           0        
887        );
888        if (!bytes)
889           return std::string(p1, p2);
890        std::string result(++bytes, &#x27;\0&#x27;);
891        bytes = boost::BOOST_REGEX_DETAIL_NS::LCMapStringA(
892           idx,       
893           lcmap_sortkey,  
894           p1,  
895           static_cast&lt;int&gt;(p2 - p1),        
896           &amp;*result.begin(),  
897           bytes        
898        );
899  #else
900        unsigned int code_page = get_code_page_for_locale_id(idx);
901        if (code_page == 0)
902           return std::string(p1, p2);
903        int src_len = static_cast&lt;int&gt;(p2 - p1);
904        wchar_t* wide_p1 = (wchar_t*)_alloca((src_len + 1) * 2);
905        if (boost::BOOST_REGEX_DETAIL_NS::MultiByteToWideChar(code_page, 0, p1, src_len, wide_p1, src_len + 1) == 0)
906           return std::string(p1, p2);
907        int bytes = boost::BOOST_REGEX_DETAIL_NS::LCMapStringW(
908           idx,       
909           lcmap_sortkey,  
910           wide_p1,  
911           src_len,        
912           0,  
913           0        
914        );
915        if (!bytes)
916           return std::string(p1, p2);
917        std::string result(++bytes, &#x27;\0&#x27;);
918        bytes = boost::BOOST_REGEX_DETAIL_NS::LCMapStringW(
919           idx,       
920           lcmap_sortkey,  
921           wide_p1,  
922           src_len,        
923           (wchar_t*) &amp; *result.begin(),  
924           bytes        
925        );
926  #endif
927        if (bytes &gt; static_cast&lt;int&gt;(result.size()))
928           return std::string(p1, p2);
929        while (result.size() &amp;&amp; result[result.size() - 1] == &#x27;\0&#x27;)
930        {
931           result.erase(result.size() - 1);
932        }
933        return result;
934     }
935  #ifndef BOOST_NO_WREGEX
936     inline std::wstring  w32_transform(lcid_type idx, const wchar_t* p1, const wchar_t* p2)
937     {
938        int bytes = boost::BOOST_REGEX_DETAIL_NS::LCMapStringW(
939           idx,       
940           lcmap_sortkey,  
941           p1,  
942           static_cast&lt;int&gt;(p2 - p1),        
943           0,  
944           0        
945        );
946        if (!bytes)
947           return std::wstring(p1, p2);
948        std::string result(++bytes, &#x27;\0&#x27;);
949        bytes = boost::BOOST_REGEX_DETAIL_NS::LCMapStringW(
950           idx,       
951           lcmap_sortkey,  
952           p1,  
953           static_cast&lt;int&gt;(p2 - p1),        
954           reinterpret_cast&lt;wchar_t*&gt;(&amp;*result.begin()),  
955           bytes        
956        );
957        if (bytes &gt; static_cast&lt;int&gt;(result.size()))
958           return std::wstring(p1, p2);
959        while (result.size() &amp;&amp; result[result.size() - 1] == L&#x27;\0&#x27;)
960        {
961           result.erase(result.size() - 1);
962        }
963        std::wstring r2;
964        for (std::string::size_type i = 0; i &lt; result.size(); ++i)
965           r2.append(1, static_cast&lt;wchar_t&gt;(static_cast&lt;unsigned char&gt;(result[i])));
966        return r2;
967     }
968  #endif
969     inline char  w32_tolower(char c, lcid_type idx)
970     {
971        char result[2];
972  #ifndef BOOST_NO_ANSI_APIS
973        int b = boost::BOOST_REGEX_DETAIL_NS::LCMapStringA(
974           idx,       
975           lcmap_lowercase,  
976           &amp;c,  
977           1,        
978           result,  
979           1);        
980        if (b == 0)
981           return c;
982  #else
983        unsigned int code_page = get_code_page_for_locale_id(idx);
984        if (code_page == 0)
985           return c;
986        wchar_t wide_c;
987        if (boost::BOOST_REGEX_DETAIL_NS::MultiByteToWideChar(code_page, 0, &amp;c, 1, &amp;wide_c, 1) == 0)
988           return c;
989        wchar_t  wide_result;
990        int b = boost::BOOST_REGEX_DETAIL_NS::LCMapStringW(
991           idx,       
992           lcmap_lowercase,  
993           &amp;wide_c,  
994           1,        
995           &amp;wide_result,  
996           1);        
997        if (b == 0)
998           return c;
999        if (boost::BOOST_REGEX_DETAIL_NS::WideCharToMultiByte(code_page, 0, &amp;wide_result, 1, result, 2, NULL, NULL) == 0)
1000           return c;  
1001  #endif
1002        return result[0];
1003     }
1004  #ifndef BOOST_NO_WREGEX
1005     inline wchar_t  w32_tolower(wchar_t c, lcid_type idx)
1006     {
1007        wchar_t result[2];
1008        int b = boost::BOOST_REGEX_DETAIL_NS::LCMapStringW(
1009           idx,       
1010           lcmap_lowercase,  
1011           &amp;c,  
1012           1,        
1013           result,  
1014           1);        
1015        if (b == 0)
1016           return c;
1017        return result[0];
1018     }
1019  #endif
1020     inline char  w32_toupper(char c, lcid_type idx)
1021     {
1022        char result[2];
1023  #ifndef BOOST_NO_ANSI_APIS
1024        int b = boost::BOOST_REGEX_DETAIL_NS::LCMapStringA(
1025           idx,       
1026           lcmap_uppercase,  
1027           &amp;c,  
1028           1,        
1029           result,  
1030           1);        
1031        if (b == 0)
1032           return c;
1033  #else
1034        unsigned int code_page = get_code_page_for_locale_id(idx);
1035        if (code_page == 0)
1036           return c;
1037        wchar_t wide_c;
1038        if (boost::BOOST_REGEX_DETAIL_NS::MultiByteToWideChar(code_page, 0, &amp;c, 1, &amp;wide_c, 1) == 0)
1039           return c;
1040        wchar_t wide_result;
1041        int b = boost::BOOST_REGEX_DETAIL_NS::LCMapStringW(
1042           idx,       
1043           lcmap_uppercase,  
1044           &amp;wide_c,  
1045           1,        
1046           &amp;wide_result,  
1047           1);        
1048        if (b == 0)
1049           return c;
1050        if (boost::BOOST_REGEX_DETAIL_NS::WideCharToMultiByte(code_page, 0, &amp;wide_result, 1, result, 2, NULL, NULL) == 0)
1051           return c;  
1052  #endif
1053        return result[0];
1054     }
1055  #ifndef BOOST_NO_WREGEX
1056     inline wchar_t  w32_toupper(wchar_t c, lcid_type idx)
1057     {
1058        wchar_t result[2];
1059        int b = boost::BOOST_REGEX_DETAIL_NS::LCMapStringW(
1060           idx,       
1061           lcmap_uppercase,  
1062           &amp;c,  
1063           1,        
1064           result,  
1065           1);        
1066        if (b == 0)
1067           return c;
1068        return result[0];
1069     }
1070  #endif
1071     inline bool  w32_is(lcid_type idx, std::uint32_t m, char c)
1072     {
1073        word mask;
1074  #ifndef BOOST_NO_ANSI_APIS
1075        if (boost::BOOST_REGEX_DETAIL_NS::GetStringTypeExA(idx, ct_ctype1, &amp;c, 1, &amp;mask) &amp;&amp; (mask &amp; m &amp; w32_regex_traits_implementation&lt;char&gt;::mask_base))
1076           return true;
1077  #else
1078        unsigned int code_page = get_code_page_for_locale_id(idx);
1079        if (code_page == 0)
1080           return false;
1081        wchar_t wide_c;
1082        if (boost::BOOST_REGEX_DETAIL_NS::MultiByteToWideChar(code_page, 0, &amp;c, 1, &amp;wide_c, 1) == 0)
1083           return false;
1084        if (boost::BOOST_REGEX_DETAIL_NS::GetStringTypeExW(idx, ct_ctype1, &amp;wide_c, 1, &amp;mask) &amp;&amp; (mask &amp; m &amp; w32_regex_traits_implementation&lt;char&gt;::mask_base))
1085           return true;
1086  #endif
1087        if ((m &amp; w32_regex_traits_implementation&lt;char&gt;::mask_word) &amp;&amp; (c == &#x27;_&#x27;))
1088           return true;
1089        return false;
1090     }
1091  #ifndef BOOST_NO_WREGEX
1092     inline bool  w32_is(lcid_type idx, std::uint32_t m, wchar_t c)
1093     {
1094        word mask;
1095        if (boost::BOOST_REGEX_DETAIL_NS::GetStringTypeExW(idx, ct_ctype1, &amp;c, 1, &amp;mask) &amp;&amp; (mask &amp; m &amp; w32_regex_traits_implementation&lt;wchar_t&gt;::mask_base))
1096           return true;
1097        if ((m &amp; w32_regex_traits_implementation&lt;wchar_t&gt;::mask_word) &amp;&amp; (c == &#x27;_&#x27;))
1098           return true;
1099        if ((m &amp; w32_regex_traits_implementation&lt;wchar_t&gt;::mask_unicode) &amp;&amp; (c &gt; 0xff))
1100           return true;
1101        return false;
1102     }
1103  #endif
1104  } 
1105  } 
1106  #ifdef BOOST_REGEX_MSVC
1107  #pragma warning(pop)
1108  #endif
1109  #endif 
1110  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-cpp_regex_traits.hpp</h3>
            <pre><code>1  #ifndef BOOST_CPP_REGEX_TRAITS_HPP_INCLUDED
2  #define BOOST_CPP_REGEX_TRAITS_HPP_INCLUDED
3  #include &lt;boost/regex/config.hpp&gt;
4  #include &lt;cstdint&gt;
5  #include &lt;locale&gt;
6  #include &lt;type_traits&gt;
7  #include &lt;boost/regex/pattern_except.hpp&gt;
8  #include &lt;boost/regex/v5/regex_traits_defaults.hpp&gt;
9  #ifdef BOOST_HAS_THREADS
10  #include &lt;mutex&gt;
11  #endif
12  #include &lt;boost/regex/v5/primary_transform.hpp&gt;
13  #include &lt;boost/regex/v5/object_cache.hpp&gt;
14  #include &lt;climits&gt;
15  #include &lt;ios&gt;
16  #include &lt;istream&gt;
17  #ifdef BOOST_REGEX_MSVC
18  #pragma warning(push)
19  #pragma warning(disable:4786 4251)
20  #endif
21  namespace boost{ 
22  template &lt;class charT&gt;
23  class cpp_regex_traits;
24  namespace BOOST_REGEX_DETAIL_NS{
25  template &lt;class charT,
26            class traits = ::std::char_traits&lt;charT&gt; &gt;
27  class parser_buf : public ::std::basic_streambuf&lt;charT, traits&gt;
28  {
29     typedef ::std::basic_streambuf&lt;charT, traits&gt; base_type;
30     typedef typename base_type::int_type int_type;
31     typedef typename base_type::char_type char_type;
32     typedef typename base_type::pos_type pos_type;
33     typedef ::std::streamsize streamsize;
34     typedef typename base_type::off_type off_type;
35  public:
36     parser_buf() : base_type() { setbuf(0, 0); }
37     const charT* getnext() { return this-&gt;gptr(); }
38  protected:
39     std::basic_streambuf&lt;charT, traits&gt;* setbuf(char_type* s, streamsize n) override;
40     typename parser_buf&lt;charT, traits&gt;::pos_type seekpos(pos_type sp, ::std::ios_base::openmode which) override;
41     typename parser_buf&lt;charT, traits&gt;::pos_type seekoff(off_type off, ::std::ios_base::seekdir way, ::std::ios_base::openmode which) override;
42  private:
43     parser_buf&amp; operator=(const parser_buf&amp;);
44     parser_buf(const parser_buf&amp;);
45  };
46  template&lt;class charT, class traits&gt;
47  std::basic_streambuf&lt;charT, traits&gt;*
48  parser_buf&lt;charT, traits&gt;::setbuf(char_type* s, streamsize n)
49  {
50     this-&gt;setg(s, s, s + n);
51     return this;
52  }
53  template&lt;class charT, class traits&gt;
54  typename parser_buf&lt;charT, traits&gt;::pos_type
55  parser_buf&lt;charT, traits&gt;::seekoff(off_type off, ::std::ios_base::seekdir way, ::std::ios_base::openmode which)
56  {
57     if(which &amp; ::std::ios_base::out)
58        return pos_type(off_type(-1));
59     std::ptrdiff_t size = this-&gt;egptr() - this-&gt;eback();
60     std::ptrdiff_t pos = this-&gt;gptr() - this-&gt;eback();
61     charT* g = this-&gt;eback();
62     switch(static_cast&lt;std::intmax_t&gt;(way))
63     {
64     case ::std::ios_base::beg:
65        if((off &lt; 0) || (off &gt; size))
66           return pos_type(off_type(-1));
67        else
68           this-&gt;setg(g, g + off, g + size);
69        break;
70     case ::std::ios_base::end:
71        if((off &lt; 0) || (off &gt; size))
72           return pos_type(off_type(-1));
73        else
74           this-&gt;setg(g, g + size - off, g + size);
75        break;
76     case ::std::ios_base::cur:
77     {
78        std::ptrdiff_t newpos = static_cast&lt;std::ptrdiff_t&gt;(pos + off);
79        if((newpos &lt; 0) || (newpos &gt; size))
80           return pos_type(off_type(-1));
81        else
82           this-&gt;setg(g, g + newpos, g + size);
83        break;
84     }
85     default: ;
86     }
87  #ifdef BOOST_REGEX_MSVC
88  #pragma warning(push)
89  #pragma warning(disable:4244)
90  #endif
91     return static_cast&lt;pos_type&gt;(this-&gt;gptr() - this-&gt;eback());
92  #ifdef BOOST_REGEX_MSVC
93  #pragma warning(pop)
94  #endif
95  }
96  template&lt;class charT, class traits&gt;
97  typename parser_buf&lt;charT, traits&gt;::pos_type
98  parser_buf&lt;charT, traits&gt;::seekpos(pos_type sp, ::std::ios_base::openmode which)
99  {
100     if(which &amp; ::std::ios_base::out)
101        return pos_type(off_type(-1));
102     off_type size = static_cast&lt;off_type&gt;(this-&gt;egptr() - this-&gt;eback());
103     charT* g = this-&gt;eback();
104     if(off_type(sp) &lt;= size)
105     {
106        this-&gt;setg(g, g + off_type(sp), g + size);
107     }
108     return pos_type(off_type(-1));
109  }
110  template &lt;class charT&gt;
111  struct cpp_regex_traits_base
112  {
113     cpp_regex_traits_base(const std::locale&amp; l)
114     { (void)imbue(l); }
115     std::locale imbue(const std::locale&amp; l);
116     std::locale m_locale;
117     std::ctype&lt;charT&gt; const* m_pctype;
118     std::messages&lt;charT&gt; const* m_pmessages;
119     std::collate&lt;charT&gt; const* m_pcollate;
120     bool operator&lt;(const cpp_regex_traits_base&amp; b)const
121     {
122        if(m_pctype == b.m_pctype)
123        {
124           if(m_pmessages == b.m_pmessages)
125           {
126              return m_pcollate &lt; b.m_pcollate;
127           }
128           return m_pmessages &lt; b.m_pmessages;
129        }
130        return m_pctype &lt; b.m_pctype;
131     }
132     bool operator==(const cpp_regex_traits_base&amp; b)const
133     {
134        return (m_pctype == b.m_pctype) 
135           &amp;&amp; (m_pmessages == b.m_pmessages) 
136           &amp;&amp; (m_pcollate == b.m_pcollate);
137     }
138  };
139  template &lt;class charT&gt;
140  std::locale cpp_regex_traits_base&lt;charT&gt;::imbue(const std::locale&amp; l)
141  {
142     std::locale result(m_locale);
143     m_locale = l;
144     m_pctype = &amp;std::use_facet&lt;std::ctype&lt;charT&gt;&gt;(l);
145     m_pmessages = std::has_facet&lt;std::messages&lt;charT&gt; &gt;(l) ? &amp;std::use_facet&lt;std::messages&lt;charT&gt; &gt;(l) : 0;
146     m_pcollate = &amp;std::use_facet&lt;std::collate&lt;charT&gt; &gt;(l);
147     return result;
148  }
149  template &lt;class charT&gt;
150  class cpp_regex_traits_char_layer : public cpp_regex_traits_base&lt;charT&gt;
151  {
152     typedef std::basic_string&lt;charT&gt; string_type;
153     typedef std::map&lt;charT, regex_constants::syntax_type&gt; map_type;
154     typedef typename map_type::const_iterator map_iterator_type;
155  public:
156     cpp_regex_traits_char_layer(const std::locale&amp; l)
157        : cpp_regex_traits_base&lt;charT&gt;(l)
158     {
159        init();
160     }
161     cpp_regex_traits_char_layer(const cpp_regex_traits_base&lt;charT&gt;&amp; b)
162        : cpp_regex_traits_base&lt;charT&gt;(b)
163     {
164        init();
165     }
166     void init();
167     regex_constants::syntax_type syntax_type(charT c)const
168     {
169        map_iterator_type i = m_char_map.find(c);
170        return ((i == m_char_map.end()) ? 0 : i-&gt;second);
171     }
172     regex_constants::escape_syntax_type escape_syntax_type(charT c) const
173     {
174        map_iterator_type i = m_char_map.find(c);
175        if(i == m_char_map.end())
176        {
177           if(this-&gt;m_pctype-&gt;is(std::ctype_base::lower, c)) return regex_constants::escape_type_class;
178           if(this-&gt;m_pctype-&gt;is(std::ctype_base::upper, c)) return regex_constants::escape_type_not_class;
179           return 0;
180        }
181        return i-&gt;second;
182     }
183  private:
184     string_type get_default_message(regex_constants::syntax_type);
185     map_type m_char_map;
186  };
187  template &lt;class charT&gt;
188  void cpp_regex_traits_char_layer&lt;charT&gt;::init()
189  {
190  #ifndef __IBMCPP__
191     typename std::messages&lt;charT&gt;::catalog cat = static_cast&lt;std::messages&lt;char&gt;::catalog&gt;(-1);
192  #else
193     typename std::messages&lt;charT&gt;::catalog cat = reinterpret_cast&lt;std::messages&lt;char&gt;::catalog&gt;(-1);
194  #endif
195     std::string cat_name(cpp_regex_traits&lt;charT&gt;::get_catalog_name());
196     if((!cat_name.empty()) &amp;&amp; (this-&gt;m_pmessages != 0))
197     {
198        cat = this-&gt;m_pmessages-&gt;open(
199           cat_name, 
200           this-&gt;m_locale);
201        if((int)cat &lt; 0)
202        {
203           std::string m(&quot;Unable to open message catalog: &quot;);
204           std::runtime_error err(m + cat_name);
205           boost::BOOST_REGEX_DETAIL_NS::raise_runtime_error(err);
206        }
207     }
208     if((int)cat &gt;= 0)
209     {
210  #ifndef BOOST_NO_EXCEPTIONS
211        try{
212  #endif
213           for(regex_constants::syntax_type i = 1; i &lt; regex_constants::syntax_max; ++i)
214           {
215              string_type mss = this-&gt;m_pmessages-&gt;get(cat, 0, i, get_default_message(i));
216              for(typename string_type::size_type j = 0; j &lt; mss.size(); ++j)
217              {
218                 m_char_map[mss[j]] = i;
219              }
220           }
221           this-&gt;m_pmessages-&gt;close(cat);
222  #ifndef BOOST_NO_EXCEPTIONS
223        }
224        catch(...)
225        {
226           if(this-&gt;m_pmessages)
227              this-&gt;m_pmessages-&gt;close(cat);
228           throw;
229        }
230  #endif
231     }
232     else
233     {
234        for(regex_constants::syntax_type i = 1; i &lt; regex_constants::syntax_max; ++i)
235        {
236           const char* ptr = get_default_syntax(i);
237           while(ptr &amp;&amp; *ptr)
238           {
239              m_char_map[this-&gt;m_pctype-&gt;widen(*ptr)] = i;
240              ++ptr;
241           }
242        }
243     }
244  }
245  template &lt;class charT&gt;
246  typename cpp_regex_traits_char_layer&lt;charT&gt;::string_type 
247     cpp_regex_traits_char_layer&lt;charT&gt;::get_default_message(regex_constants::syntax_type i)
248  {
249     const char* ptr = get_default_syntax(i);
250     string_type result;
251     while(ptr &amp;&amp; *ptr)
252     {
253        result.append(1, this-&gt;m_pctype-&gt;widen(*ptr));
254        ++ptr;
255     }
256     return result;
257  }
258  template &lt;&gt;
259  class cpp_regex_traits_char_layer&lt;char&gt; : public cpp_regex_traits_base&lt;char&gt;
260  {
261     typedef std::string string_type;
262  public:
263     cpp_regex_traits_char_layer(const std::locale&amp; l)
264     : cpp_regex_traits_base&lt;char&gt;(l)
265     {
266        init();
267     }
268     cpp_regex_traits_char_layer(const cpp_regex_traits_base&lt;char&gt;&amp; l)
269     : cpp_regex_traits_base&lt;char&gt;(l)
270     {
271        init();
272     }
273     regex_constants::syntax_type syntax_type(char c)const
274     {
275        return m_char_map[static_cast&lt;unsigned char&gt;(c)];
276     }
277     regex_constants::escape_syntax_type escape_syntax_type(char c) const
278     {
279        return m_char_map[static_cast&lt;unsigned char&gt;(c)];
280     }
281  private:
282     regex_constants::syntax_type m_char_map[1u &lt;&lt; CHAR_BIT];
283     void init();
284  };
285  template &lt;class charT&gt;
286  class cpp_regex_traits_implementation : public cpp_regex_traits_char_layer&lt;charT&gt;
287  {
288  public:
289     typedef typename cpp_regex_traits&lt;charT&gt;::char_class_type      char_class_type;
290     typedef typename std::ctype&lt;charT&gt;::mask                       native_mask_type;
291     typedef typename std::make_unsigned&lt;native_mask_type&gt;::type    unsigned_native_mask_type;
292     static const char_class_type mask_blank = 1u &lt;&lt; 24;
293     static const char_class_type mask_word = 1u &lt;&lt; 25;
294     static const char_class_type mask_unicode = 1u &lt;&lt; 26;
295     static const char_class_type mask_horizontal = 1u &lt;&lt; 27;
296     static const char_class_type mask_vertical = 1u &lt;&lt; 28;
297     typedef std::basic_string&lt;charT&gt; string_type;
298     typedef charT char_type;
299     cpp_regex_traits_implementation(const std::locale&amp; l)
300        : cpp_regex_traits_char_layer&lt;charT&gt;(l)
301     {
302        init();
303     }
304     cpp_regex_traits_implementation(const cpp_regex_traits_base&lt;charT&gt;&amp; l)
305        : cpp_regex_traits_char_layer&lt;charT&gt;(l)
306     {
307        init();
308     }
309     std::string error_string(regex_constants::error_type n) const
310     {
311        if(!m_error_strings.empty())
312        {
313           std::map&lt;int, std::string&gt;::const_iterator p = m_error_strings.find(n);
314           return (p == m_error_strings.end()) ? std::string(get_default_error_string(n)) : p-&gt;second;
315        }
316        return get_default_error_string(n);
317     }
318     char_class_type lookup_classname(const charT* p1, const charT* p2) const
319     {
320        char_class_type result = lookup_classname_imp(p1, p2);
321        if(result == 0)
322        {
323           string_type temp(p1, p2);
324           this-&gt;m_pctype-&gt;tolower(&amp;*temp.begin(), &amp;*temp.begin() + temp.size());
325           result = lookup_classname_imp(&amp;*temp.begin(), &amp;*temp.begin() + temp.size());
326        }
327        return result;
328     }
329     string_type lookup_collatename(const charT* p1, const charT* p2) const;
330     string_type transform_primary(const charT* p1, const charT* p2) const;
331     string_type transform(const charT* p1, const charT* p2) const;
332  private:
333     std::map&lt;int, std::string&gt;     m_error_strings;   
334     std::map&lt;string_type, char_class_type&gt;  m_custom_class_names; 
335     std::map&lt;string_type, string_type&gt;      m_custom_collate_names; 
336     unsigned                       m_collate_type;    
337     charT                          m_collate_delim;   
338     char_class_type lookup_classname_imp(const charT* p1, const charT* p2) const;
339     void init();
340  };
341  template &lt;class charT&gt;
342  typename cpp_regex_traits_implementation&lt;charT&gt;::char_class_type const cpp_regex_traits_implementation&lt;charT&gt;::mask_blank;
343  template &lt;class charT&gt;
344  typename cpp_regex_traits_implementation&lt;charT&gt;::char_class_type const cpp_regex_traits_implementation&lt;charT&gt;::mask_word;
345  template &lt;class charT&gt;
346  typename cpp_regex_traits_implementation&lt;charT&gt;::char_class_type const cpp_regex_traits_implementation&lt;charT&gt;::mask_unicode;
347  template &lt;class charT&gt;
348  typename cpp_regex_traits_implementation&lt;charT&gt;::char_class_type const cpp_regex_traits_implementation&lt;charT&gt;::mask_vertical;
349  template &lt;class charT&gt;
350  typename cpp_regex_traits_implementation&lt;charT&gt;::char_class_type const cpp_regex_traits_implementation&lt;charT&gt;::mask_horizontal;
351  template &lt;class charT&gt;
352  typename cpp_regex_traits_implementation&lt;charT&gt;::string_type 
353     cpp_regex_traits_implementation&lt;charT&gt;::transform_primary(const charT* p1, const charT* p2) const
354  {
355     BOOST_REGEX_ASSERT(*p2 == 0);
356     string_type result;
357  #if defined(_CPPLIB_VER)
358     if(*p1 == 0)
359     {
360        return string_type(1, charT(0));
361     }
362  #endif
363  #ifndef BOOST_NO_EXCEPTIONS
364     try{
365  #endif
366        switch(m_collate_type)
367        {
368        case sort_C:
369        case sort_unknown:
370           {
371              result.assign(p1, p2);
372              this-&gt;m_pctype-&gt;tolower(&amp;*result.begin(), &amp;*result.begin() + result.size());
373              result = this-&gt;m_pcollate-&gt;transform(&amp;*result.begin(), &amp;*result.begin() + result.size());
374              break;
375           }
376        case sort_fixed:
377           {
378              result.assign(this-&gt;m_pcollate-&gt;transform(p1, p2));
379              result.erase(this-&gt;m_collate_delim);
380              break;
381           }
382        case sort_delim:
383              result.assign(this-&gt;m_pcollate-&gt;transform(p1, p2));
384              std::size_t i;
385              for(i = 0; i &lt; result.size(); ++i)
386              {
387                 if(result[i] == m_collate_delim)
388                    break;
389              }
390              result.erase(i);
391              break;
392        }
393  #ifndef BOOST_NO_EXCEPTIONS
394     }catch(...){}
395  #endif
396     while((!result.empty()) &amp;&amp; (charT(0) == *result.rbegin()))
397        result.erase(result.size() - 1);
398     if(result.empty())
399     {
400        result = string_type(1, charT(0));
401     }
402     return result;
403  }
404  template &lt;class charT&gt;
405  typename cpp_regex_traits_implementation&lt;charT&gt;::string_type 
406     cpp_regex_traits_implementation&lt;charT&gt;::transform(const charT* p1, const charT* p2) const
407  {
408     BOOST_REGEX_ASSERT(*p2 == 0);
409     string_type result, result2;
410  #if defined(_CPPLIB_VER)
411     if(*p1 == 0)
412     {
413        return result;
414     }
415  #endif
416  #ifndef BOOST_NO_EXCEPTIONS
417     try{
418  #endif
419        result = this-&gt;m_pcollate-&gt;transform(p1, p2);
420        while((!result.empty()) &amp;&amp; (charT(0) == *result.rbegin()))
421           result.erase(result.size() - 1);
422        typedef typename std::make_unsigned&lt;charT&gt;::type uchar_type;
423        result2.reserve(result.size() * 2 + 2);
424        for(unsigned i = 0; i &lt; result.size(); ++i)
425        {
426           if(static_cast&lt;uchar_type&gt;(result[i]) == (std::numeric_limits&lt;uchar_type&gt;::max)())
427           {
428              result2.append(1, charT((std::numeric_limits&lt;uchar_type&gt;::max)())).append(1, charT(&#x27;b&#x27;));
429           }
430           else
431           {
432              result2.append(1, static_cast&lt;charT&gt;(1 + static_cast&lt;uchar_type&gt;(result[i]))).append(1, charT(&#x27;b&#x27;) - 1);
433           }
434        }
435        BOOST_REGEX_ASSERT(std::find(result2.begin(), result2.end(), charT(0)) == result2.end());
436  #ifndef BOOST_NO_EXCEPTIONS
437     }
438     catch(...)
439     {
440     }
441  #endif
442     return result2;
443  }
444  template &lt;class charT&gt;
445  typename cpp_regex_traits_implementation&lt;charT&gt;::string_type 
446     cpp_regex_traits_implementation&lt;charT&gt;::lookup_collatename(const charT* p1, const charT* p2) const
447  {
448     typedef typename std::map&lt;string_type, string_type&gt;::const_iterator iter_type;
449     if(!m_custom_collate_names.empty())
450     {
451        iter_type pos = m_custom_collate_names.find(string_type(p1, p2));
452        if(pos != m_custom_collate_names.end())
453           return pos-&gt;second;
454     }
455     std::string name(p1, p2);
456     name = lookup_default_collate_name(name);
457     if(!name.empty())
458        return string_type(name.begin(), name.end());
459     if(p2 - p1 == 1)
460        return string_type(1, *p1);
461     return string_type();
462  }
463  template &lt;class charT&gt;
464  void cpp_regex_traits_implementation&lt;charT&gt;::init()
465  {
466  #ifndef __IBMCPP__
467     typename std::messages&lt;charT&gt;::catalog cat = static_cast&lt;std::messages&lt;char&gt;::catalog&gt;(-1);
468  #else
469     typename std::messages&lt;charT&gt;::catalog cat = reinterpret_cast&lt;std::messages&lt;char&gt;::catalog&gt;(-1);
470  #endif
471     std::string cat_name(cpp_regex_traits&lt;charT&gt;::get_catalog_name());
472     if((!cat_name.empty()) &amp;&amp; (this-&gt;m_pmessages != 0))
473     {
474        cat = this-&gt;m_pmessages-&gt;open(
475           cat_name, 
476           this-&gt;m_locale);
477        if((int)cat &lt; 0)
478        {
479           std::string m(&quot;Unable to open message catalog: &quot;);
480           std::runtime_error err(m + cat_name);
481           boost::BOOST_REGEX_DETAIL_NS::raise_runtime_error(err);
482        }
483     }
484     if((int)cat &gt;= 0)
485     {
486        for(boost::regex_constants::error_type i = static_cast&lt;boost::regex_constants::error_type&gt;(0); 
487           i &lt;= boost::regex_constants::error_unknown; 
488           i = static_cast&lt;boost::regex_constants::error_type&gt;(i + 1))
489        {
490           const char* p = get_default_error_string(i);
491           string_type default_message;
492           while(*p)
493           {
494              default_message.append(1, this-&gt;m_pctype-&gt;widen(*p));
495              ++p;
496           }
497           string_type s = this-&gt;m_pmessages-&gt;get(cat, 0, i+200, default_message);
498           std::string result;
499           for(std::string::size_type j = 0; j &lt; s.size(); ++j)
500           {
501              result.append(1, this-&gt;m_pctype-&gt;narrow(s[j], 0));
502           }
503           m_error_strings[i] = result;
504        }
505        static const char_class_type masks[16] = 
506        {
507           static_cast&lt;unsigned_native_mask_type&gt;(std::ctype&lt;charT&gt;::alnum),
508           static_cast&lt;unsigned_native_mask_type&gt;(std::ctype&lt;charT&gt;::alpha),
509           static_cast&lt;unsigned_native_mask_type&gt;(std::ctype&lt;charT&gt;::cntrl),
510           static_cast&lt;unsigned_native_mask_type&gt;(std::ctype&lt;charT&gt;::digit),
511           static_cast&lt;unsigned_native_mask_type&gt;(std::ctype&lt;charT&gt;::graph),
512           cpp_regex_traits_implementation&lt;charT&gt;::mask_horizontal,
513           static_cast&lt;unsigned_native_mask_type&gt;(std::ctype&lt;charT&gt;::lower),
514           static_cast&lt;unsigned_native_mask_type&gt;(std::ctype&lt;charT&gt;::print),
515           static_cast&lt;unsigned_native_mask_type&gt;(std::ctype&lt;charT&gt;::punct),
516           static_cast&lt;unsigned_native_mask_type&gt;(std::ctype&lt;charT&gt;::space),
517           static_cast&lt;unsigned_native_mask_type&gt;(std::ctype&lt;charT&gt;::upper),
518           cpp_regex_traits_implementation&lt;charT&gt;::mask_vertical,
519           static_cast&lt;unsigned_native_mask_type&gt;(std::ctype&lt;charT&gt;::xdigit),
520           cpp_regex_traits_implementation&lt;charT&gt;::mask_blank,
521           cpp_regex_traits_implementation&lt;charT&gt;::mask_word,
522           cpp_regex_traits_implementation&lt;charT&gt;::mask_unicode,
523        };
524        static const string_type null_string;
525        for(unsigned int j = 0; j &lt;= 13; ++j)
526        {
527           string_type s(this-&gt;m_pmessages-&gt;get(cat, 0, j+300, null_string));
528           if(!s.empty())
529              this-&gt;m_custom_class_names[s] = masks[j];
530        }
531     }
532     m_collate_type = BOOST_REGEX_DETAIL_NS::find_sort_syntax(this, &amp;m_collate_delim);
533  }
534  template &lt;class charT&gt;
535  typename cpp_regex_traits_implementation&lt;charT&gt;::char_class_type 
536     cpp_regex_traits_implementation&lt;charT&gt;::lookup_classname_imp(const charT* p1, const charT* p2) const
537  {
538     static const char_class_type masks[22] = 
539     {
540        0,
541        static_cast&lt;unsigned_native_mask_type&gt;(std::ctype&lt;char&gt;::alnum),
542        static_cast&lt;unsigned_native_mask_type&gt;(std::ctype&lt;char&gt;::alpha),
543        cpp_regex_traits_implementation&lt;charT&gt;::mask_blank,
544        static_cast&lt;unsigned_native_mask_type&gt;(std::ctype&lt;char&gt;::cntrl),
545        static_cast&lt;unsigned_native_mask_type&gt;(std::ctype&lt;char&gt;::digit),
546        static_cast&lt;unsigned_native_mask_type&gt;(std::ctype&lt;char&gt;::digit),
547        static_cast&lt;unsigned_native_mask_type&gt;(std::ctype&lt;char&gt;::graph),
548        cpp_regex_traits_implementation&lt;charT&gt;::mask_horizontal,
549        static_cast&lt;unsigned_native_mask_type&gt;(std::ctype&lt;char&gt;::lower),
550        static_cast&lt;unsigned_native_mask_type&gt;(std::ctype&lt;char&gt;::lower),
551        static_cast&lt;unsigned_native_mask_type&gt;(std::ctype&lt;char&gt;::print),
552        static_cast&lt;unsigned_native_mask_type&gt;(std::ctype&lt;char&gt;::punct),
553        static_cast&lt;unsigned_native_mask_type&gt;(std::ctype&lt;char&gt;::space),
554        static_cast&lt;unsigned_native_mask_type&gt;(std::ctype&lt;char&gt;::space),
555        static_cast&lt;unsigned_native_mask_type&gt;(std::ctype&lt;char&gt;::upper),
556        cpp_regex_traits_implementation&lt;charT&gt;::mask_unicode,
557        static_cast&lt;unsigned_native_mask_type&gt;(std::ctype&lt;char&gt;::upper),
558        cpp_regex_traits_implementation&lt;charT&gt;::mask_vertical,
559        static_cast&lt;unsigned_native_mask_type&gt;(std::ctype&lt;char&gt;::alnum) | cpp_regex_traits_implementation&lt;charT&gt;::mask_word, 
560        static_cast&lt;unsigned_native_mask_type&gt;(std::ctype&lt;char&gt;::alnum) | cpp_regex_traits_implementation&lt;charT&gt;::mask_word, 
561        static_cast&lt;unsigned_native_mask_type&gt;(std::ctype&lt;char&gt;::xdigit),
562     };
563     if(!m_custom_class_names.empty())
564     {
565        typedef typename std::map&lt;std::basic_string&lt;charT&gt;, char_class_type&gt;::const_iterator map_iter;
566        map_iter pos = m_custom_class_names.find(string_type(p1, p2));
567        if(pos != m_custom_class_names.end())
568           return pos-&gt;second;
569     }
570     std::size_t state_id = 1 + BOOST_REGEX_DETAIL_NS::get_default_class_id(p1, p2);
571     BOOST_REGEX_ASSERT(state_id &lt; sizeof(masks) / sizeof(masks[0]));
572     return masks[state_id];
573  }
574  template &lt;class charT&gt;
575  inline std::shared_ptr&lt;const cpp_regex_traits_implementation&lt;charT&gt; &gt; create_cpp_regex_traits(const std::locale&amp; l)
576  {
577     cpp_regex_traits_base&lt;charT&gt; key(l);
578     return ::boost::object_cache&lt;cpp_regex_traits_base&lt;charT&gt;, cpp_regex_traits_implementation&lt;charT&gt; &gt;::get(key, 5);
579  }
580  } 
581  template &lt;class charT&gt;
582  class cpp_regex_traits
583  {
584  private:
585     typedef std::ctype&lt;charT&gt;            ctype_type;
586  public:
587     typedef charT                        char_type;
588     typedef std::size_t                  size_type;
589     typedef std::basic_string&lt;char_type&gt; string_type;
590     typedef std::locale                  locale_type;
591     typedef std::uint_least32_t          char_class_type;
592     struct boost_extensions_tag{};
593     cpp_regex_traits()
594        : m_pimpl(BOOST_REGEX_DETAIL_NS::create_cpp_regex_traits&lt;charT&gt;(std::locale()))
595     { }
596     static size_type length(const char_type* p)
597     {
598        return std::char_traits&lt;charT&gt;::length(p);
599     }
600     regex_constants::syntax_type syntax_type(charT c)const
601     {
602        return m_pimpl-&gt;syntax_type(c);
603     }
604     regex_constants::escape_syntax_type escape_syntax_type(charT c) const
605     {
606        return m_pimpl-&gt;escape_syntax_type(c);
607     }
608     charT translate(charT c) const
609     {
610        return c;
611     }
612     charT translate_nocase(charT c) const
613     {
614        return m_pimpl-&gt;m_pctype-&gt;tolower(c);
615     }
616     charT translate(charT c, bool icase) const
617     {
618        return icase ? m_pimpl-&gt;m_pctype-&gt;tolower(c) : c;
619     }
620     charT tolower(charT c) const
621     {
622        return m_pimpl-&gt;m_pctype-&gt;tolower(c);
623     }
624     charT toupper(charT c) const
625     {
626        return m_pimpl-&gt;m_pctype-&gt;toupper(c);
627     }
628     string_type transform(const charT* p1, const charT* p2) const
629     {
630        return m_pimpl-&gt;transform(p1, p2);
631     }
632     string_type transform_primary(const charT* p1, const charT* p2) const
633     {
634        return m_pimpl-&gt;transform_primary(p1, p2);
635     }
636     char_class_type lookup_classname(const charT* p1, const charT* p2) const
637     {
638        return m_pimpl-&gt;lookup_classname(p1, p2);
639     }
640     string_type lookup_collatename(const charT* p1, const charT* p2) const
641     {
642        return m_pimpl-&gt;lookup_collatename(p1, p2);
643     }
644     bool isctype(charT c, char_class_type f) const
645     {
646        typedef typename std::ctype&lt;charT&gt;::mask ctype_mask;
647        static const ctype_mask mask_base = 
648           static_cast&lt;ctype_mask&gt;(
649              std::ctype&lt;charT&gt;::alnum 
650              | std::ctype&lt;charT&gt;::alpha
651              | std::ctype&lt;charT&gt;::cntrl
652              | std::ctype&lt;charT&gt;::digit
653              | std::ctype&lt;charT&gt;::graph
654              | std::ctype&lt;charT&gt;::lower
655              | std::ctype&lt;charT&gt;::print
656              | std::ctype&lt;charT&gt;::punct
657              | std::ctype&lt;charT&gt;::space
658              | std::ctype&lt;charT&gt;::upper
659              | std::ctype&lt;charT&gt;::xdigit);
660        if((f &amp; mask_base) 
661           &amp;&amp; (m_pimpl-&gt;m_pctype-&gt;is(
662              static_cast&lt;ctype_mask&gt;(f &amp; mask_base), c)))
663           return true;
664        else if((f &amp; BOOST_REGEX_DETAIL_NS::cpp_regex_traits_implementation&lt;charT&gt;::mask_unicode) &amp;&amp; BOOST_REGEX_DETAIL_NS::is_extended(c))
665           return true;
666        else if((f &amp; BOOST_REGEX_DETAIL_NS::cpp_regex_traits_implementation&lt;charT&gt;::mask_word) &amp;&amp; (c == &#x27;_&#x27;))
667           return true;
668        else if((f &amp; BOOST_REGEX_DETAIL_NS::cpp_regex_traits_implementation&lt;charT&gt;::mask_blank) 
669           &amp;&amp; m_pimpl-&gt;m_pctype-&gt;is(std::ctype&lt;charT&gt;::space, c)
670           &amp;&amp; !BOOST_REGEX_DETAIL_NS::is_separator(c))
671           return true;
672        else if((f &amp; BOOST_REGEX_DETAIL_NS::cpp_regex_traits_implementation&lt;charT&gt;::mask_vertical) 
673           &amp;&amp; (::boost::BOOST_REGEX_DETAIL_NS::is_separator(c) || (c == &#x27;\v&#x27;)))
674           return true;
675        else if((f &amp; BOOST_REGEX_DETAIL_NS::cpp_regex_traits_implementation&lt;charT&gt;::mask_horizontal) 
676           &amp;&amp; this-&gt;isctype(c, std::ctype&lt;charT&gt;::space) &amp;&amp; !this-&gt;isctype(c, BOOST_REGEX_DETAIL_NS::cpp_regex_traits_implementation&lt;charT&gt;::mask_vertical))
677           return true;
678  #ifdef __CYGWIN__
679        else if((f &amp; std::ctype&lt;charT&gt;::xdigit) == std::ctype&lt;charT&gt;::xdigit)
680        {
681           if((c &gt;= &#x27;a&#x27;) &amp;&amp; (c &lt;= &#x27;f&#x27;))
682              return true;
683           if((c &gt;= &#x27;A&#x27;) &amp;&amp; (c &lt;= &#x27;F&#x27;))
684              return true;
685        }
686  #endif
687        return false;
688     }
689     std::intmax_t toi(const charT*&amp; p1, const charT* p2, int radix)const;
690     int value(charT c, int radix)const
691     {
692        const charT* pc = &amp;c;
693        return (int)toi(pc, pc + 1, radix);
694     }
695     locale_type imbue(locale_type l)
696     {
697        std::locale result(getloc());
698        m_pimpl = BOOST_REGEX_DETAIL_NS::create_cpp_regex_traits&lt;charT&gt;(l);
699        return result;
700     }
701     locale_type getloc()const
702     {
703        return m_pimpl-&gt;m_locale;
704     }
705     std::string error_string(regex_constants::error_type n) const
706     {
707        return m_pimpl-&gt;error_string(n);
708     }
709     static std::string catalog_name(const std::string&amp; name);
710     static std::string get_catalog_name();
711  private:
712     std::shared_ptr&lt;const BOOST_REGEX_DETAIL_NS::cpp_regex_traits_implementation&lt;charT&gt; &gt; m_pimpl;
713     static std::string&amp; get_catalog_name_inst();
714  #ifdef BOOST_HAS_THREADS
715     static std::mutex&amp; get_mutex_inst();
716  #endif
717  };
718  template &lt;class charT&gt;
719  std::intmax_t cpp_regex_traits&lt;charT&gt;::toi(const charT*&amp; first, const charT* last, int radix)const
720  {
721     BOOST_REGEX_DETAIL_NS::parser_buf&lt;charT&gt;   sbuf;            
722     std::basic_istream&lt;charT&gt;      is(&amp;sbuf);       
723     last = std::find(first, last, std::use_facet&lt;std::numpunct&lt;charT&gt;&gt;(is.getloc()).thousands_sep());
724     sbuf.pubsetbuf(const_cast&lt;charT*&gt;(static_cast&lt;const charT*&gt;(first)), static_cast&lt;std::streamsize&gt;(last-first));
725     is.clear();
726     if(std::abs(radix) == 16) is &gt;&gt; std::hex;
727     else if(std::abs(radix) == 8) is &gt;&gt; std::oct;
728     else is &gt;&gt; std::dec;
729     std::intmax_t val;
730     if(is &gt;&gt; val)
731     {
732        first = first + ((last - first) - sbuf.in_avail());
733        return val;
734     }
735     else
736        return -1;
737  }
738  template &lt;class charT&gt;
739  std::string cpp_regex_traits&lt;charT&gt;::catalog_name(const std::string&amp; name)
740  {
741  #ifdef BOOST_HAS_THREADS
742     std::lock_guard&lt;std::mutex&gt; lk(get_mutex_inst());
743  #endif
744     std::string result(get_catalog_name_inst());
745     get_catalog_name_inst() = name;
746     return result;
747  }
748  template &lt;class charT&gt;
749  std::string&amp; cpp_regex_traits&lt;charT&gt;::get_catalog_name_inst()
750  {
751     static std::string s_name;
752     return s_name;
753  }
754  template &lt;class charT&gt;
755  std::string cpp_regex_traits&lt;charT&gt;::get_catalog_name()
756  {
757  #ifdef BOOST_HAS_THREADS
758     std::lock_guard&lt;std::mutex&gt; lk(get_mutex_inst());
759  #endif
760     std::string result(get_catalog_name_inst());
761     return result;
762  }
763  #ifdef BOOST_HAS_THREADS
764  template &lt;class charT&gt;
765  std::mutex&amp; cpp_regex_traits&lt;charT&gt;::get_mutex_inst()
766  {
767     static std::mutex s_mutex;
768     return s_mutex;
769  }
770  #endif
771  namespace BOOST_REGEX_DETAIL_NS {
772     inline void cpp_regex_traits_char_layer&lt;char&gt;::init()
773     {
774        std::memset(m_char_map, 0, sizeof(m_char_map));
775  #ifndef __IBMCPP__
776        std::messages&lt;char&gt;::catalog cat = static_cast&lt;std::messages&lt;char&gt;::catalog&gt;(-1);
777  #else
778        std::messages&lt;char&gt;::catalog cat = reinterpret_cast&lt;std::messages&lt;char&gt;::catalog&gt;(-1);
779  #endif
780        std::string cat_name(cpp_regex_traits&lt;char&gt;::get_catalog_name());
781        if ((!cat_name.empty()) &amp;&amp; (m_pmessages != 0))
782        {
783           cat = this-&gt;m_pmessages-&gt;open(
784              cat_name,
785              this-&gt;m_locale);
786           if ((int)cat &lt; 0)
787           {
788              std::string m(&quot;Unable to open message catalog: &quot;);
789              std::runtime_error err(m + cat_name);
790              boost::BOOST_REGEX_DETAIL_NS::raise_runtime_error(err);
791           }
792        }
793        if ((int)cat &gt;= 0)
794        {
795  #ifndef BOOST_NO_EXCEPTIONS
796           try {
797  #endif
798              for (regex_constants::syntax_type i = 1; i &lt; regex_constants::syntax_max; ++i)
799              {
800                 string_type mss = this-&gt;m_pmessages-&gt;get(cat, 0, i, get_default_syntax(i));
801                 for (string_type::size_type j = 0; j &lt; mss.size(); ++j)
802                 {
803                    m_char_map[static_cast&lt;unsigned char&gt;(mss[j])] = i;
804                 }
805              }
806              this-&gt;m_pmessages-&gt;close(cat);
807  #ifndef BOOST_NO_EXCEPTIONS
808           }
809           catch (...)
810           {
811              this-&gt;m_pmessages-&gt;close(cat);
812              throw;
813           }
814  #endif
815        }
816        else
817        {
818           for (regex_constants::syntax_type j = 1; j &lt; regex_constants::syntax_max; ++j)
819           {
820              const char* ptr = get_default_syntax(j);
821              while (ptr &amp;&amp; *ptr)
822              {
<span onclick='openModal()' class='match'>823                 m_char_map[static_cast&lt;unsigned char&gt;(*ptr)] = j;
824                 ++ptr;
825              }
826           }
827        }
828        unsigned char i = &#x27;A&#x27;;
829        do
830        {
831           if (m_char_map[i] == 0)
832           {
833              if (this-&gt;m_pctype-&gt;is(std::ctype_base::lower, i))
</span>834                 m_char_map[i] = regex_constants::escape_type_class;
835              else if (this-&gt;m_pctype-&gt;is(std::ctype_base::upper, i))
836                 m_char_map[i] = regex_constants::escape_type_not_class;
837           }
838        } while (0xFF != i++);
839     }
840  } 
841  } 
842  #ifdef BOOST_REGEX_MSVC
843  #pragma warning(pop)
844  #endif
845  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-w32_regex_traits.hpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-cpp_regex_traits.hpp</div>
                </div>
                <div class="column column_space"><pre><code>715                 m_char_map[static_cast&lt;unsigned char&gt;(*ptr)] = i;
716                 ++ptr;
717              }
718           }
719        }
720        unsigned char i = &#x27;A&#x27;;
721        do
722        {
723           if (m_char_map[i] == 0)
724           {
725              if (::boost::BOOST_REGEX_DETAIL_NS::w32_is(this-&gt;m_locale, 0x0002u, (char)i))
</pre></code></div>
                <div class="column column_space"><pre><code>823                 m_char_map[static_cast&lt;unsigned char&gt;(*ptr)] = j;
824                 ++ptr;
825              }
826           }
827        }
828        unsigned char i = &#x27;A&#x27;;
829        do
830        {
831           if (m_char_map[i] == 0)
832           {
833              if (this-&gt;m_pctype-&gt;is(std::ctype_base::lower, i))
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    