<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for types_1.h &amp; Chess.cpp</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for types_1.h &amp; Chess.cpp
      </h3>
<h1 align="center">
        1.8%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>types_1.h (10.227273%)<th>Chess.cpp (1.039261%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(183-202)<td><a href="#" name="0">(1310-1322)</a><td align="center"><font color="#ff0000">23</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(229-253)<td><a href="#" name="1">(1870-1888)</a><td align="center"><font color="#900000">13</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>types_1.h</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifndef TYPES_H_INCLUDED
2 #define TYPES_H_INCLUDED
3 #include &lt;cassert&gt;
4 #include &lt;cctype&gt;
5 #include &lt;climits&gt;
6 #include &lt;cstdint&gt;
7 #include &lt;cstdlib&gt;
8 #if defined(_MSC_VER)
9 #pragma warning(disable: 4127) #pragma warning(disable: 4146) #pragma warning(disable: 4800) #endif
10 #define unlikely(x) (x) 
11 #if defined(_WIN64) &amp;&amp; !defined(IS_64BIT)
12 #  include &lt;intrin.h&gt; #  define IS_64BIT
13 #  define USE_BSFQ
14 #endif
15 #if defined(USE_POPCNT) &amp;&amp; defined(_MSC_VER) &amp;&amp; defined(__INTEL_COMPILER)
16 #  include &lt;nmmintrin.h&gt; #endif
17 #if defined(USE_PEXT)
18 #  include &lt;immintrin.h&gt; #else
19 #  define _pext_u64(b, m) (0)
20 #endif
21 #  if !defined(NO_PREFETCH) &amp;&amp; (defined(__INTEL_COMPILER) || defined(_MSC_VER))
22 #   include &lt;xmmintrin.h&gt; #  endif
23 #define CACHE_LINE_SIZE 64
24 #if defined(_MSC_VER) || defined(__INTEL_COMPILER)
25 #  define CACHE_LINE_ALIGNMENT __declspec(align(CACHE_LINE_SIZE))
26 #else
27 #  define CACHE_LINE_ALIGNMENT  __attribute__ ((aligned(CACHE_LINE_SIZE)))
28 #endif
29 #ifdef _MSC_VER
30 #  define FORCE_INLINE  __forceinline
31 #elif defined(__GNUC__)
32 #  define FORCE_INLINE  inline __attribute__((always_inline))
33 #else
34 #  define FORCE_INLINE  inline
35 #endif
36 #ifdef USE_POPCNT
37 const bool HasPopCnt = true;
38 #else
39 const bool HasPopCnt = false;
40 #endif
41 #ifdef USE_PEXT
42 const bool HasPext = true;
43 #else
44 const bool HasPext = false;
45 #endif
46 #ifdef IS_64BIT
47 const bool Is64Bit = true;
48 #else
49 const bool Is64Bit = false;
50 #endif
51 typedef uint64_t Key;
52 typedef uint64_t Bitboard;
53 const int MAX_MOVES      = 256;
54 const int MAX_PLY        = 120;
55 const int MAX_PLY_PLUS_6 = MAX_PLY + 6;
56 enum Move {
57   MOVE_NONE,
58   MOVE_NULL = 65
59 };
60 enum MoveType {
61   NORMAL,
62   PROMOTION = 1 &lt;&lt; 14,
63   ENPASSANT = 2 &lt;&lt; 14,
64   CASTLING  = 3 &lt;&lt; 14
65 };
66 enum Color {
67   WHITE, BLACK, NO_COLOR, COLOR_NB = 2
68 };
69 enum CastlingSide {
70   KING_SIDE, QUEEN_SIDE, CASTLING_SIDE_NB = 2
71 };
72 enum CastlingRight {    NO_CASTLING,
73   WHITE_OO,
74   WHITE_OOO   = WHITE_OO &lt;&lt; 1,
75   BLACK_OO    = WHITE_OO &lt;&lt; 2,
76   BLACK_OOO   = WHITE_OO &lt;&lt; 3,
77   ANY_CASTLING = WHITE_OO | WHITE_OOO | BLACK_OO | BLACK_OOO,
78   CASTLING_RIGHT_NB = 16
79 };
80 template&lt;Color C, CastlingSide S&gt; struct MakeCastling {
81   static const CastlingRight
82   right = C == WHITE ? S == QUEEN_SIDE ? WHITE_OOO : WHITE_OO
83                      : S == QUEEN_SIDE ? BLACK_OOO : BLACK_OO;
84 };
85 enum Phase {
86   PHASE_ENDGAME,
87   PHASE_MIDGAME = 128,
88   MG = 0, EG = 1, PHASE_NB = 2
89 };
90 enum ScaleFactor {
91   SCALE_FACTOR_DRAW    = 0,
92   SCALE_FACTOR_ONEPAWN = 48,
93   SCALE_FACTOR_NORMAL  = 64,
94   SCALE_FACTOR_MAX     = 128,
95   SCALE_FACTOR_NONE    = 255
96 };
97 enum Bound {
98   BOUND_NONE,
99   BOUND_UPPER,
100   BOUND_LOWER,
101   BOUND_EXACT = BOUND_UPPER | BOUND_LOWER
102 <a name="0"></a>};
103 enum Value : int {
104 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  VALUE_ZERO      = 0,
105   VALUE_DRAW      = 0,
106   VALUE_KNOWN_WIN = 10000,
107   VALUE_MATE      = 32000,
108   VALUE_INFINITE  = 32001,
109   VALUE_NONE      = 32002,
110   VALUE_MATE_IN_MAX_PLY  =  VALUE_MATE - MAX_PLY,
111   VALUE_MATED_IN_MAX_PLY = -VALUE_MATE + MAX_PLY,
112   Mg = 0, Eg = 1,
113   PawnValueMg   = 198,   PawnValueEg   = 258,
114   KnightValueMg = 817,   KnightValueEg = 846,
115   BishopValueMg = 836,   BishopValueEg = 857,
116   RookValueMg   = 1270,  RookValueEg   = 1278,
117   QueenValueMg  = 2521,  QueenValueEg  = 2558,
118   MidgameLimit  = 15581, EndgameLimit  = 3998
119 };</b></font>
120 enum PieceType {
121   NO_PIECE_TYPE, PAWN, KNIGHT, BISHOP, ROOK, QUEEN, KING,
122   ALL_PIECES = 0,
123   PIECE_TYPE_NB = 8
124 };
125 enum Piece {
126   NO_PIECE,
127   W_PAWN = 1, W_KNIGHT, W_BISHOP, W_ROOK, W_QUEEN, W_KING,
128   B_PAWN = 9, B_KNIGHT, B_BISHOP, B_ROOK, B_QUEEN, B_KING,
129   PIECE_NB = 16
130 };
131 enum Depth {
132   ONE_PLY = 2,
133   DEPTH_ZERO          =  0 * ONE_PLY,
134   DEPTH_QS_CHECKS     =  0 * ONE_PLY,
135   DEPTH_QS_NO_CHECKS  = -1 * ONE_PLY,
136   DEPTH_QS_RECAPTURES = -5 * ONE_PLY,
137 <a name="1"></a>  DEPTH_NONE = -127 * ONE_PLY
138 };
139 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>enum Square {
140   SQ_A1, SQ_B1, SQ_C1, SQ_D1, SQ_E1, SQ_F1, SQ_G1, SQ_H1,
141   SQ_A2, SQ_B2, SQ_C2, SQ_D2, SQ_E2, SQ_F2, SQ_G2, SQ_H2,
142   SQ_A3, SQ_B3, SQ_C3, SQ_D3, SQ_E3, SQ_F3, SQ_G3, SQ_H3,
143   SQ_A4, SQ_B4, SQ_C4, SQ_D4, SQ_E4, SQ_F4, SQ_G4, SQ_H4,
144   SQ_A5, SQ_B5, SQ_C5, SQ_D5, SQ_E5, SQ_F5, SQ_G5, SQ_H5,
145   SQ_A6, SQ_B6, SQ_C6, SQ_D6, SQ_E6, SQ_F6, SQ_G6, SQ_H6,
146   SQ_A7, SQ_B7, SQ_C7, SQ_D7, SQ_E7, SQ_F7, SQ_G7, SQ_H7,
147   SQ_A8, SQ_B8, SQ_C8, SQ_D8, SQ_E8, SQ_F8, SQ_G8, SQ_H8,
148   SQ_NONE,
149   SQUARE_NB = 64,
150   DELTA_N =  8,
151   DELTA_E =  1,
152   DELTA_S = -8,
153   DELTA_W = -1,
154   DELTA_NN = DELTA_N + DELTA_N,
155   DELTA_NE = DELTA_N + DELTA_E,
156   DELTA_SE = DELTA_S + DELTA_E,
157   DELTA_SS = DELTA_S + DELTA_S,
158   DELTA_SW = DELTA_S + DELTA_W,
159   DELTA_NW = DELTA_N + DELTA_W
160 };</b></font>
161 enum File {
162   FILE_A, FILE_B, FILE_C, FILE_D, FILE_E, FILE_F, FILE_G, FILE_H, FILE_NB
163 };
164 enum Rank {
165   RANK_1, RANK_2, RANK_3, RANK_4, RANK_5, RANK_6, RANK_7, RANK_8, RANK_NB
166 };
167 enum Score : int { SCORE_ZERO };
168 typedef union {
169   uint32_t full;
170   struct { int16_t eg, mg; } half;
171 } ScoreView;
172 inline Score make_score(int mg, int eg) {
173   ScoreView v;
174   v.half.mg = (int16_t)(mg - (uint16_t(eg) &gt;&gt; 15));
175   v.half.eg = (int16_t)eg;
176   return Score(v.full);
177 }
178 inline Value mg_value(Score s) {
179   ScoreView v;
180   v.full = s;
181   return Value(v.half.mg + (uint16_t(v.half.eg) &gt;&gt; 15));
182 }
183 inline Value eg_value(Score s) {
184   ScoreView v;
185   v.full = s;
186   return Value(v.half.eg);
187 }
188 #define ENABLE_BASE_OPERATORS_ON(T)                                         \
189 inline T operator+(const T d1, const T d2) { return T(int(d1) + int(d2)); } \
190 inline T operator-(const T d1, const T d2) { return T(int(d1) - int(d2)); } \
191 inline T operator*(int i, const T d) { return T(i * int(d)); }              \
192 inline T operator*(const T d, int i) { return T(int(d) * i); }              \
193 inline T operator-(const T d) { return T(-int(d)); }                        \
194 inline T&amp; operator+=(T&amp; d1, const T d2) { return d1 = d1 + d2; }            \
195 inline T&amp; operator-=(T&amp; d1, const T d2) { return d1 = d1 - d2; }            \
196 inline T&amp; operator*=(T&amp; d, int i) { return d = T(int(d) * i); }
197 ENABLE_BASE_OPERATORS_ON(Score)
198 #define ENABLE_FULL_OPERATORS_ON(T)                                         \
199 ENABLE_BASE_OPERATORS_ON(T)                                                 \
200 inline T&amp; operator++(T&amp; d) { return d = T(int(d) + 1); }                    \
201 inline T&amp; operator--(T&amp; d) { return d = T(int(d) - 1); }                    \
202 inline T operator/(const T d, int i) { return T(int(d) / i); }              \
203 inline T&amp; operator/=(T&amp; d, int i) { return d = T(int(d) / i); }
204 ENABLE_FULL_OPERATORS_ON(Value)
205 ENABLE_FULL_OPERATORS_ON(PieceType)
206 ENABLE_FULL_OPERATORS_ON(Piece)
207 ENABLE_FULL_OPERATORS_ON(Color)
208 ENABLE_FULL_OPERATORS_ON(Depth)
209 ENABLE_FULL_OPERATORS_ON(Square)
210 ENABLE_FULL_OPERATORS_ON(File)
211 ENABLE_FULL_OPERATORS_ON(Rank)
212 #undef ENABLE_FULL_OPERATORS_ON
213 #undef ENABLE_BASE_OPERATORS_ON
214 inline Value operator+(Value v, int i) { return Value(int(v) + i); }
215 inline Value operator-(Value v, int i) { return Value(int(v) - i); }
216 inline Value&amp; operator+=(Value&amp; v, int i) { return v = v + i; }
217 inline Value&amp; operator-=(Value&amp; v, int i) { return v = v - i; }
218 inline Score operator*(Score s1, Score s2);
219 inline Score operator/(Score s, int i) {
220   return make_score(mg_value(s) / i, eg_value(s) / i);
221 }
222 extern Value PieceValue[PHASE_NB][PIECE_NB];
223 struct ExtMove {
224   Move move;
225   Value value;
226 };
227 inline bool operator&lt;(const ExtMove&amp; f, const ExtMove&amp; s) {
228   return f.value &lt; s.value;
229 }
230 inline Color operator~(Color c) {
231   return Color(c ^ BLACK);
232 }
233 inline Square operator~(Square s) {
234   return Square(s ^ SQ_A8); }
235 inline CastlingRight operator|(Color c, CastlingSide s) {
236   return CastlingRight(WHITE_OO &lt;&lt; ((s == QUEEN_SIDE) + 2 * c));
237 }
238 inline Value mate_in(int ply) {
239   return VALUE_MATE - ply;
240 }
241 inline Value mated_in(int ply) {
242   return -VALUE_MATE + ply;
243 }
244 inline Square make_square(File f, Rank r) {
245   return Square((r &lt;&lt; 3) | f);
246 }
247 inline Piece make_piece(Color c, PieceType pt) {
248   return Piece((c &lt;&lt; 3) | pt);
249 }
250 inline PieceType type_of(Piece pc)  {
251   return PieceType(pc &amp; 7);
252 }
253 inline Color color_of(Piece pc) {
254   assert(pc != NO_PIECE);
255   return Color(pc &gt;&gt; 3);
256 }
257 inline bool is_ok(Square s) {
258   return s &gt;= SQ_A1 &amp;&amp; s &lt;= SQ_H8;
259 }
260 inline File file_of(Square s) {
261   return File(s &amp; 7);
262 }
263 inline Rank rank_of(Square s) {
264   return Rank(s &gt;&gt; 3);
265 }
266 inline Square relative_square(Color c, Square s) {
267   return Square(s ^ (c * 56));
268 }
269 inline Rank relative_rank(Color c, Rank r) {
270   return Rank(r ^ (c * 7));
271 }
272 inline Rank relative_rank(Color c, Square s) {
273   return relative_rank(c, rank_of(s));
274 }
275 inline bool opposite_colors(Square s1, Square s2) {
276   int s = int(s1) ^ int(s2);
277   return ((s &gt;&gt; 3) ^ s) &amp; 1;
278 }
279 inline char to_char(File f, bool tolower = true) {
280   return char(f - FILE_A + (tolower ? 'a' : 'A'));
281 }
282 inline char to_char(Rank r) {
283   return char(r - RANK_1 + '1');
284 }
285 inline Square pawn_push(Color c) {
286   return c == WHITE ? DELTA_N : DELTA_S;
287 }
288 inline Square from_sq(Move m) {
289   return Square((m &gt;&gt; 6) &amp; 0x3F);
290 }
291 inline Square to_sq(Move m) {
292   return Square(m &amp; 0x3F);
293 }
294 inline MoveType type_of(Move m) {
295   return MoveType(m &amp; (3 &lt;&lt; 14));
296 }
297 inline PieceType promotion_type(Move m) {
298   return PieceType(((m &gt;&gt; 12) &amp; 3) + 2);
299 }
300 inline Move make_move(Square from, Square to) {
301   return Move(to | (from &lt;&lt; 6));
302 }
303 template&lt;MoveType T&gt;
304 inline Move make(Square from, Square to, PieceType pt = KNIGHT) {
305   return Move(to | (from &lt;&lt; 6) | T | ((pt - KNIGHT) &lt;&lt; 12));
306 }
307 inline bool is_ok(Move m) {
308   return from_sq(m) != to_sq(m); }
309 #include &lt;string&gt;
310 inline const std::string to_string(Square s) {
311   return { to_char(file_of(s)), to_char(rank_of(s)) };
312 }
#endif </pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>Chess.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "BuildInfo.h"
2 #define WEB_URL "http://chess.johnbyrd.org"
3 const unsigned int MAX_FILES = 8;
4 const unsigned int NUM_PIECES = 13;
5 const unsigned int HIGHEST_FILE = MAX_FILES - 1;
6 const unsigned int MAX_SQUARES = MAX_FILES * MAX_FILES;
7 const unsigned int HASH_TABLE_SIZE = 128 * 1024 * 1024;
8 const unsigned int MAX_COMMAND_LENGTH = 64 * 256;
9 const unsigned int DEFAULT_SEARCH_DEPTH = 6; //-V112
10 const unsigned int DEFAULT_MOVES_SIZE = 2 &lt;&lt; 6;
11 #include &lt;time.h&gt;
12 #include &lt;string&gt;
13 #include &lt;iostream&gt;
14 #include &lt;vector&gt;
15 #include &lt;array&gt;
16 #include &lt;algorithm&gt;
17 #include &lt;sstream&gt;
18 #include &lt;unordered_map&gt;
19 #include &lt;thread&gt;
20 #include &lt;mutex&gt;
21 #include &lt;memory&gt;
22 #include &lt;chrono&gt;
23 #include &lt;climits&gt;
24 #include &lt;ratio&gt;
25 #include &lt;atomic&gt;
26 #include &lt;random&gt;
27 const int BIG_NUMBER = 1000000;
28 using namespace std;
29 void Die( const string &amp;s );
30 typedef bool Color;
31 const Color BLACK = false;
32 const Color WHITE = true;
33 class Object
34 {
35 };
36 enum PieceType
37 {
38     NONE = 0,
39     PAWN,
40     KNIGHT,
41     BISHOP,
42     ROOK,
43     QUEEN,
44     KING
45 };
46 const int NONE_VALUE = 0;
47 const int PAWN_VALUE = 100;
48 const int KNIGHT_VALUE = 325;
49 const int BISHOP_VALUE = 325;
50 const int ROOK_VALUE = 500;
51 const int QUEEN_VALUE = 975;
52 const int CHECKMATE_VALUE = 990000; const int KING_VALUE = 1000000;
53 const int DRAW_SCORE = 0;
54 class PieceInitializer;
55 class Board;
56 class Move;
57 class Moves;
58 class Square;
59 class Interface;
60 class Position;
61 #define INTERFACE_FUNCTION_PARAMS const string &amp;sParams
62 #define INTERFACE_FUNCTION_NO_PARAMS const string &amp;
63 #define INTERFACE_FUNCTION_RETURN_TYPE void
64 #define INTERFACE_PROTOTYPE( FunctionName )  INTERFACE_FUNCTION_RETURN_TYPE FunctionName ( INTERFACE_FUNCTION_PARAMS )
65 #define INTERFACE_PROTOTYPE_NO_PARAMS( FunctionName )  INTERFACE_FUNCTION_RETURN_TYPE FunctionName ( INTERFACE_FUNCTION_NO_PARAMS )
66 #define INTERFACE_FUNCTION_TYPE( Variable ) INTERFACE_FUNCTION_RETURN_TYPE ( Interface::* Variable )( INTERFACE_FUNCTION_PARAMS )
67 #define INTERFACE_FUNCTION_TYPE_NO_PARAMS( Variable ) INTERFACE_FUNCTION_RETURN_TYPE ( Interface::* Variable )( INTERFACE_FUNCTION_NO_PARAMS )
68 #define INTERFACE_FUNCTION_ABSTRACT_TYPE (*( INTERFACE_FUNCTION_RETURN_TYPE )())
69 typedef INTERFACE_FUNCTION_RETURN_TYPE( Interface::*InterfaceFunctionType )(
70     INTERFACE_FUNCTION_PARAMS );
71 typedef std::array&lt;int, MAX_SQUARES&gt; PieceSquareRawTableType;
72 PieceSquareRawTableType psrtDefault =
73 {
74     0,  0,  0,  0,  0,  0,  0,  0,
75     0,  0,  0,  0,  0,  0,  0,  0,
76     0,  0,  0,  0,  0,  0,  0,  0,
77     0,  0,  0,  0,  0,  0,  0,  0,
78     0,  0,  0,  0,  0,  0,  0,  0,
79     0,  0,  0,  0,  0,  0,  0,  0,
80     0,  0,  0,  0,  0,  0,  0,  0,
81     0,  0,  0,  0,  0,  0,  0,  0
82 };
83 PieceSquareRawTableType psrtKnight =
84 {
85     -40, -30, -30, -30, -30, -30, -30, -40,
86     -40, -20,   0,   0,   0,   0, -20, -40,
87     -30,   0,   5,  10,  10,   5,   0, -50,
88     -30,  10,  15,  30,  30,  15,  10, -30,
89     -30,  10,  15,  30,  30,  15,  10, -30,
90     -30,   0,  10,  15,  15,  10,   0, -50,
91     -40, -20,   0,   0,   0,   0, -20, -40,
92     -40, -30, -30, -30, -30, -30, -30, -40
93 };
94 PieceSquareRawTableType psrtWhitePawnEarly =
95 {
96     0,   0,   0,   0,   0,   0,   0,   0,
97     5,   5,  10, -20, -20,  10,   5,   5,
98     5,  -5, -10,   0,   0, -10,  -5,   5,
99     0,   0,   0,  20,  20,   0,   0,   0,
100     20, 20,  30,  40,  40,  30,  30,  20,
101     40, 50,  60,  80,  80,  60,  50,  40,
102     60, 70,  80, 100, 100,  80,  70,  60,
103     0,   0,   0,   0,   0,   0,   0,   0
104 };
105 PieceSquareRawTableType psrtWhitePawnLate =
106 {
107     0,    0,   0,   0,   0,   0,   0,   0,
108     5,    5,  10, -20, -20,  10,   5,   5,
109     5,   -5,  -5,   0,   0,  -5,  -5,   5,
110     0,    0,  20,  40,  40,  20,   0,   0,
111     30,  30,  30,  50,  50,  50,  50,  50,
112     70,  70,  70,  70,  70,  70,  70,  70,
113     100,100, 100, 100, 100, 100, 100, 100,
114     0,    0,   0,   0,   0,   0,   0,   0
115 };
116 PieceSquareRawTableType psrtBishop =
117 {
118     -20, -10, -10, -10, -10, -10, -10, -20,
119     -10,   0,   0,   0,   0,   0,   0, -10,
120     -10,   0,   5,  10,  10,   5,   0, -10,
121     -10,   5,   5,  10,  10,   5,   5, -10,
122     -10,   5,   5,  10,  10,   5,   5, -10,
123     -10,   0,   5,  10,  10,   5,   0, -10,
124     -10,   0,   0,   0,   0,   0,   0, -10,
125     -20, -10, -10, -10, -10, -10, -10, -20
126 };
127 PieceSquareRawTableType psrtRook =
128 {
129     0,   0,  0, 20, 20, 20,  0,  0
130     -5,  0,  0,  0,  0,  0,  0, -5,
131     -5,  0,  0,  0,  0,  0,  0, -5,
132     -5,  0,  0,  0,  0,  0,  0, -5,
133     -5,  0,  0,  0,  0,  0,  0, -5,
134     -5,  0,  0,  0,  0,  0,  0, -5,
135     20, 20, 20, 20, 20, 20, 20, 20,
136     -5,  0,  0,  0,  0,  0,  0,  0
137 };
138 PieceSquareRawTableType psrtWhiteKingEarly =
139 {
140     0, 0, 70,0, 0, 0,70, 0,
141     0, 0, 0, 0, 0, 0, 0, 0,
142     0, 0, 0, 0, 0, 0, 0, 0,
143     0, 0, 0, 0, 0, 0, 0, 0,
144     0, 0, 0, 0, 0, 0, 0, 0,
145     0, 0, 0, 0, 0, 0, 0, 0,
146     0, 0, 0, 0, 0, 0, 0, 0,
147     0, 0, 0, 0, 0, 0, 0, 0
148 };
149 PieceSquareRawTableType psrtWhiteKingLate =
150 {
151     -50, -40, -30, -30, -30, -30, -40, -50,
152     -30, -20, -10,   0,   0, -10, -20, -30,
153     -30, -10,  30,  40,  40,  30, -10, -30,
154     -30, -10,  40,  60,  60,  40, -10, -30,
155     -30, -10,  40,  60,  60,  40, -10, -30,
156     -30, -10,  30,  40,  40,  30, -10, -30,
157     -30, -30,   0,   0,   0,   0, -30, -30,
158     -50, -30, -30, -30, -30, -30, -30, -50
159 };
160 class PieceSquareTableBase : public Object
161 {
162 public:
163     PieceSquareTableBase()
164     {
165         for ( unsigned int i = 0; i &lt; MAX_SQUARES; i++ )
166             m_SourceTable[ i ] = 0;
167     }
168     PieceSquareTableBase( const PieceSquareRawTableType &amp;table )
169     {
170         m_SourceTable = table;
171     }
172     virtual void InvertColor()
173     {
174         PieceSquareRawTableType temp;
175         temp = m_SourceTable;
176         for ( unsigned int i = 0; i &lt; MAX_FILES; i++ )
177             for ( unsigned int j = 0; j &lt; MAX_FILES; j++ )
178             {
179                 m_SourceTable[ i + j * MAX_FILES ] =
180                     temp[ i + ( ( MAX_FILES - 1 ) - j ) * MAX_FILES];
181             }
182     }
183     virtual int Get( unsigned int index ) const
184     {
185         return m_SourceTable[ ( size_t ) index ];
186     }
187     PieceSquareRawTableType m_SourceTable;
188 };
189 const int MAX_PIECE_SQUARE_INTERPOLATIONS = 64;
190 class PieceSquareTableInterpolating : PieceSquareTableBase
191 {
192 public:
193     PieceSquareTableInterpolating() :
194         m_nCurrentTable( 0 ),
195         m_fPhase( 0.0f )
196     {
197     }
198     void Append( const PieceSquareRawTableType &amp;table,
199                  const float fInterpolationFactor = 0.0f )
200     {
201         PieceSquareTableBase baseTable( table );
202         m_SourceTables.push_back( baseTable );
203         m_Phases.push_back( fInterpolationFactor );
204     }
205     PieceSquareTableInterpolating( const PieceSquareRawTableType &amp;table,
206                                    const float fInterpolationFactor = 0.0f ) :
207         m_nCurrentTable( 0 ),
208         m_fPhase( 0.0f )
209     {
210         Append( table, fInterpolationFactor );
211     }
212     virtual void InvertColor()
213     {
214         for ( auto &amp;table : m_InterpolatedTables )
215             table.InvertColor();
216     }
217     virtual int Get( unsigned int index, const float fPhase = 0.0f ) const
218     {
219         size_t nSize = m_InterpolatedTables.size();
220         if ( m_InterpolatedTables.size() == 1 )
221             return m_InterpolatedTables[0].Get( index );
222         float fTable = fPhase * ( float )m_InterpolatedTables.size();
223         int nTable = ( int )fTable;
224         if ( nTable &gt;= ( int )nSize )
225             nTable = ( int )nSize - 1;
226         if ( nTable &lt; 0 )
227             nTable = 0;
228         return m_InterpolatedTables[nTable].Get( index );
229     }
230     virtual void CalculateInterpolations()
231     {
232         switch ( m_SourceTables.size() )
233         {
234         case 1:
235             m_nCurrentTable = 0;
236             m_InterpolatedTables.push_back( m_SourceTables[0] );
237             break;
238         case 2:
239             for ( unsigned int i = 0; i &lt; MAX_PIECE_SQUARE_INTERPOLATIONS; i++ )
240             {
241                 m_nCurrentTable = 0;
242                 PieceSquareRawTableType pstInterpolated;
243                 for ( unsigned int sq = 0; sq &lt; MAX_SQUARES; sq++ )
244                 {
245                     float fScale;
246                     fScale = ( float )i / ( float )MAX_PIECE_SQUARE_INTERPOLATIONS;
247                     pstInterpolated[sq] = ( int ) (
248                                               ( 1.0f - fScale ) * m_SourceTables[0].Get( sq ) +
249                                               fScale * m_SourceTables[1].Get( sq ) );
250                 }
251                 PieceSquareTableBase tableBase( pstInterpolated );
252                 m_InterpolatedTables.push_back( tableBase );
253             }
254             break;
255         default:
256             Die( "Unsupported number of interpolated table sources!" );
257         }
258     }
259 protected:
260     typedef vector&lt; PieceSquareTableBase &gt; TablesType;
261     typedef vector&lt; float &gt; PhaseType;
262     TablesType m_InterpolatedTables;
263     TablesType m_SourceTables;
264     PhaseType m_Phases;
265     unsigned int m_nCurrentTable;
266     float m_fPhase;
267 };
268 typedef PieceSquareTableInterpolating PieceSquareTable;
269 class PieceSquareTableInitializer : Object
270 {
271 public:
272     PieceSquareTableInitializer()
273     {
274         Initialize();
275     }
276     void Initialize();
277 };
278 class Clock : Object
279 {
280 public:
281     typedef chrono::system_clock NativeClockType;
282     typedef NativeClockType::duration NativeClockDurationType;
283     typedef NativeClockType::time_point NativeTimePointType;
284     typedef int64_t ChessTickType;
285     typedef chrono::duration&lt;ChessTickType, milli&gt; Duration;
286     Clock()
287     {
288         Reset();
289     }
290     void Reset()
291     {
292         m_Start = m_Clock.now();
293     }
294     ChessTickType Get() const
295     {
296         NativeTimePointType timeNow;
297         timeNow = m_Clock.now();
298         Duration dur;
299         dur = chrono::duration_cast&lt;Duration&gt; ( timeNow - m_Start );
300         return dur.count();
301     }
302     void Start()
303     {
304         Reset();
305     }
306     void Test()
307     {
308         for ( int t = 0; t &lt; 100; t++ )
309         {
310             chrono::milliseconds delay( 500 );
311             this_thread::sleep_for( delay );
312             cout &lt;&lt; "Duration is now: " &lt;&lt; Get() &lt;&lt; endl;
313         }
314     }
315 protected:
316     NativeClockType m_Clock;
317     NativeTimePointType m_Start;
318     bool m_bIsRunning;
319 };
320 class Piece : Object
321 {
322     friend class PieceInitializer;
323 public:
324     Piece()
325     {
326         m_Color = BLACK;
327         m_PieceType = NONE;
328         m_pOtherColor = NULL;
329         m_PieceSquareTable = psrtDefault;
330     }
331     Piece( Color color )
332     {
333         m_Color = color;
334         m_PieceType = NONE;
335         m_pOtherColor = NULL;
336         m_PieceSquareTable = psrtDefault;
337     }
338     virtual int PieceValue() const = 0;
339     virtual int Index() const
340     {
341         return m_nIndex;
342     };
343     virtual void SetIndex( int i )
344     {
345         m_nIndex = i;
346     };
347     virtual Moves GenerateMoves( const Square &amp;source,
348                                  const Position &amp;pos ) const = 0;
349     virtual bool IsDifferent( const Square &amp;dest, const Board &amp;board ) const;
350     virtual bool IsDifferentOrEmpty( const Square &amp;dest,
351                                      const Board &amp;board ) const;
352     void SetOtherColor( Piece &amp;otherPiece )
353     {
354         m_pOtherColor = &amp;otherPiece;
355     }
356     Piece *InvertColor()
357     {
358         return m_pOtherColor;
359     }
360     char Letter() const
361     {
362         if ( m_Color == BLACK )
363             return m_Letter;
364         return ( char ) toupper( m_Letter );
365     }
366     Color GetColor() const
367     {
368         return m_Color;
369     }
370     void SetColor( Color val )
371     {
372         m_Color = val;
373     }
374     PieceType Type() const
375     {
376         return m_PieceType;
377     }
378     const PieceSquareTable &amp;GetPieceSquareTable() const
379     {
380         return m_PieceSquareTable;
381     }
382     void SetPieceSquareTable( const PieceSquareTable &amp;val )
383     {
384         m_PieceSquareTable = val;
385     }
386 protected:
387     char    m_Letter;
388     Color   m_Color;
389     Piece   *m_pOtherColor;
390     PieceType m_PieceType;
391     int     m_nIndex;
392     PieceSquareTable m_PieceSquareTable;
393 };
394 class NoPiece : public Piece
395 {
396 public:
397     NoPiece()
398     {
399         m_Letter = '.';
400         m_PieceType = NONE;
401         m_pOtherColor = this;
402     }
403     int PieceValue() const
404     {
405         return NONE_VALUE;
406     }
407     Moves GenerateMoves( const Square &amp;source, const Position &amp;pos ) const;
408 };
409 class Pawn : public Piece
410 {
411 public:
412     Pawn( Color color ) : Piece( color )
413     {
414         m_PieceType = PAWN;
415         m_Letter = 'p';
416     }
417     int PieceValue() const
418     {
419         return PAWN_VALUE;
420     }
421     Moves GenerateMoves( const Square &amp;source, const Position &amp;pos ) const;
422     void AddEnPassantMove( Move &amp;m, const Square &amp;dest, Moves &amp;moves ) const;
423     virtual void AddAndPromote( Moves &amp;moves, Move &amp;m,
424                                 const bool bIsPromote ) const;
425 };
426 class Bishop : public Piece
427 {
428 public:
429     Bishop( Color color ) : Piece( color )
430     {
431         m_Letter = 'b';
432         m_PieceType = BISHOP;
433     }
434     int PieceValue() const
435     {
436         return BISHOP_VALUE;
437     }
438     Moves GenerateMoves( const Square &amp;source, const Position &amp;pos ) const;
439 };
440 class Knight : public Piece
441 {
442 public:
443     Knight( Color color ) : Piece( color )
444     {
445         m_Letter = 'n';
446         m_PieceType = KNIGHT;
447     }
448     int PieceValue() const
449     {
450         return KNIGHT_VALUE;
451     }
452     Moves GenerateMoves( const Square &amp;source, const Position &amp;pos ) const;
453 };
454 class Rook : public Piece
455 {
456 public:
457     Rook( Color color ) : Piece( color )
458     {
459         m_Letter = 'r';
460         m_PieceType = ROOK;
461     }
462     int PieceValue() const
463     {
464         return ROOK_VALUE;
465     }
466     Moves GenerateMoves( const Square &amp;source, const Position &amp;pos ) const;
467 };
468 class Queen : public Piece
469 {
470 public:
471     Queen( Color color ) : Piece( color )
472     {
473         m_Letter = 'q';
474         m_PieceType = QUEEN;
475     }
476     int PieceValue() const
477     {
478         return QUEEN_VALUE;
479     }
480     Moves GenerateMoves( const Square &amp;source, const Position &amp;pos ) const;
481 };
482 class King : public Piece
483 {
484 public:
485     King( Color color ) : Piece( color )
486     {
487         m_Letter = 'k';
488         m_PieceType = KING;
489     }
490     int PieceValue() const
491     {
492         return KING_VALUE;
493     }
494     Moves GenerateCastlingMoves( const Square &amp;source, const Position &amp;pos ) const;
495     Moves GenerateMoves( const Square &amp;source, const Position &amp;pos ) const;
496 private:
497     King();
498 };
499 Pawn WhitePawn( WHITE ), BlackPawn( BLACK );        //-V601
500 Knight WhiteKnight( WHITE ), BlackKnight( BLACK );   //-V601
501 Bishop WhiteBishop( WHITE ), BlackBishop( BLACK );   //-V601
502 Rook WhiteRook( WHITE ), BlackRook( BLACK );        //-V601
503 Queen WhiteQueen( WHITE ), BlackQueen( BLACK );     //-V601
504 King WhiteKing( WHITE ), BlackKing( BLACK );        //-V601
505 void PieceSquareTableInitializer::Initialize()
506 {
507     PieceSquareTable pstWhitePawn, pstBlackPawn, pstWhiteKnight, pstBlackKnight;
508     PieceSquareTable pstWhiteBishop, pstBlackBishop, pstWhiteRook, pstBlackRook;
509     PieceSquareTable pstWhiteQueen, pstBlackQueen, pstWhiteKing, pstBlackKing;
510     pstWhitePawn = PieceSquareTable();
511     pstWhitePawn.Append( psrtWhitePawnEarly , 0.0f );
512     pstWhitePawn.Append( psrtWhitePawnLate, 1.0f );
513     pstWhitePawn.CalculateInterpolations();
514     pstBlackPawn = pstWhitePawn;
515     pstBlackPawn.InvertColor();
516     pstWhiteBishop = PieceSquareTable( psrtBishop );
517     pstWhiteBishop.CalculateInterpolations();
518     pstBlackBishop = pstWhiteBishop;
519     pstBlackBishop.InvertColor();
520     pstWhiteKnight = PieceSquareTable( psrtKnight );
521     pstWhiteKnight.CalculateInterpolations();
522     pstBlackKnight = pstWhiteKnight;
523     pstBlackKnight.InvertColor();
524     pstWhiteRook = PieceSquareTable( psrtRook );
525     pstWhiteRook.CalculateInterpolations();
526     pstBlackRook = pstWhiteRook;
527     pstBlackRook.InvertColor();
528     pstWhiteQueen = PieceSquareTable( psrtDefault );
529     pstWhiteQueen.CalculateInterpolations();
530     pstBlackQueen = pstWhiteQueen;
531     pstBlackQueen.InvertColor();
532     pstWhiteKing = PieceSquareTable();
533     pstWhiteKing.Append( psrtWhiteKingEarly, 0.0f );
534     pstWhiteKing.Append( psrtWhiteKingLate, 1.0f );
535     pstWhiteKing.CalculateInterpolations();
536     pstBlackKing = pstWhiteKing;
537     pstBlackKing.InvertColor();
538     WhitePawn.SetPieceSquareTable( pstWhitePawn );
539     BlackPawn.SetPieceSquareTable( pstBlackPawn );
540     WhiteBishop.SetPieceSquareTable( pstWhiteBishop );
541     BlackBishop.SetPieceSquareTable( pstBlackBishop );
542     WhiteKnight.SetPieceSquareTable( pstWhiteKnight );
543     BlackKnight.SetPieceSquareTable( pstBlackKnight );
544     WhiteRook.SetPieceSquareTable( pstWhiteRook );
545     BlackRook.SetPieceSquareTable( pstBlackRook );
546     WhiteQueen.SetPieceSquareTable( pstWhiteQueen );
547     BlackQueen.SetPieceSquareTable( pstBlackQueen );
548     WhiteKing.SetPieceSquareTable( pstWhiteKing );
549     BlackKing.SetPieceSquareTable( pstBlackKing );
550 }
551 NoPiece None;
552 const Piece **AllPieces;
553 const int AllPiecesSize = 12;
554 class BoardBase : public Object
555 {
556 public:
557     BoardBase()
558     {
559         Initialize();
560     }
561     virtual const Piece *Set( int index, const Piece *piece )
562     {
563         return ( m_Piece[ index ] = piece );
564     }
565     virtual const Piece *Get( int index ) const
566     {
567         return ( m_Piece[ index ] );
568     }
569     virtual void Initialize()
570     {
571         for ( unsigned int i = 0; i &lt; MAX_SQUARES; i++ )
572             Set( i, &amp;None );
573     }
574     virtual const Piece *Set( int i, int j, const Piece *piece )
575     {
576         return ( Set( i + ( j &lt;&lt; 3 ), piece ) );
577     }
578     const Piece *Get( int i, int j ) const
579     {
580         return Get( i + ( j &lt;&lt; 3 ) );
581     }
582     const Piece *Set( const Square &amp;s, const Piece *piece );
583     const Piece *Get( const Square &amp;s ) const;
584     void Setup()
585     {
586         Initialize();
587         for ( unsigned int i = 0 ; i &lt; MAX_FILES; i ++ )
588         {
589             Set( i, 1, &amp;WhitePawn );
590             Set( i, 6, &amp;BlackPawn );
591         }
592         Set( 0, 0, &amp;WhiteRook );
593         Set( 7, 0, &amp;WhiteRook );
594         Set( 0, 7, &amp;BlackRook );
595         Set( 7, 7, &amp;BlackRook );
596         Set( 1, 0, &amp;WhiteKnight );
597         Set( 6, 0, &amp;WhiteKnight );
598         Set( 1, 7, &amp;BlackKnight );
599         Set( 6, 7, &amp;BlackKnight );
600         Set( 2, 0, &amp;WhiteBishop );
601         Set( 5, 0, &amp;WhiteBishop );
602         Set( 2, 7, &amp;BlackBishop );
603         Set( 5, 7, &amp;BlackBishop );
604         Set( 3, 0, &amp;WhiteQueen );
605         Set( 4, 0, &amp;WhiteKing );  //-V112
606         Set( 3, 7, &amp;BlackQueen );
607         Set( 4, 7, &amp;BlackKing );  //-V112
608     }
609     void Flip()
610     {
611         const Piece *pTemp;
612         for ( unsigned int j = 0 ; j &lt; ( MAX_FILES / 2 ); j++ )
613             for ( unsigned int i = 0; i &lt; MAX_FILES; i++ )
614             {
615                 pTemp = Get( i, j );
616                 Set( i, j, Get( HIGHEST_FILE - i, HIGHEST_FILE - j ) );
617                 Set( HIGHEST_FILE - i, HIGHEST_FILE - j, pTemp );
618             }
619     }
620     bool IsEmpty( const Square &amp;square ) const;
621     void Dump() const
622     {
623         for ( unsigned int j = ( MAX_FILES - 1 ); j &lt; MAX_FILES; j-- ) //-V621
624         {
625             for ( unsigned int i = 0; i &lt; MAX_FILES; i++ )
626                 cout &lt;&lt; Get( i, j )-&gt;Letter();
627             cout &lt;&lt; endl;
628         }
629     }
630     void Test()
631     {
632         Setup();
633         Dump();
634         Flip();
635         Dump();
636         Flip();
637         Dump();
638     }
639 protected:
640     const Piece *m_Piece[ MAX_FILES *MAX_FILES ];
641 };
642 typedef uint64_t HashValue;
643 HashValue s_PiecePositionHash[ MAX_SQUARES ][ NUM_PIECES ];
644 HashValue s_PieceColorHash[ 2 ];
645 class BoardHashing : public BoardBase
646 {
647     typedef BoardBase super;
648 public:
649     BoardHashing() : BoardBase(), m_Hash( 0 )
650     {
651         Initialize();
652     }
653     virtual void Initialize() override
654     {
655         m_Hash = 0;
656         super::Initialize();
657     }
658     virtual const Piece *Set( int index, const Piece *piece ) override
659     {
660         const Piece *curPiece = Get( index );
661         if ( curPiece != &amp;None )
662             m_Hash ^= s_PiecePositionHash[ index ][ curPiece-&gt;Index() ];
663         if ( piece != &amp;None )
664             m_Hash ^= s_PiecePositionHash[ index ][ piece-&gt;Index() ];
665         return super::Set( index, piece );
666     }
667     virtual const Piece *Set( int i, int j, const Piece *piece ) override
668     {
669         return super::Set( i, j, piece );
670     }
671     HashValue GetHash() const
672     {
673         return m_Hash;
674     }
675     HashValue m_Hash;
676 };
677 class BoardPieceSquare : public BoardHashing
678 {
679 public:
680     virtual int GetPieceSquareValue( int index, const float fPhase ) const
681     {
682         return Get( index )-&gt;
683                GetPieceSquareTable().Get( index, fPhase );
684     }
685     virtual int GetPieceSquareValue( const Square &amp;s, const float fPhase ) const;
686 };
687 class Board : public BoardPieceSquare {};
688 class HashInitializer
689 {
690 public:
691     HashInitializer()
692     {
693         mt19937_64 mt;
694         for ( unsigned int i = 0; i &lt; MAX_SQUARES; i++ )
695             for ( unsigned int j = 0; j &lt; NUM_PIECES; j++ )
696                 s_PiecePositionHash[ i ][ j ] = mt();
697         for ( unsigned int i = 0; i &lt; 2; i++ )
698             s_PieceColorHash[ i ] = mt();
699     }
700 };
701 class Square : public Object
702 {
703 public:
704     Square()
705     {
706         i = j = 0;
707     }
708     Square( int rank, int file )
709     {
710         i = rank;
711         j = file;
712     }
713     Square( const string &amp;s )
714     {
715         i = s.at( 0 ) - 'a';
716         j = s.at( 1 ) - '1';
717     }
718     bool IsOnBoard() const
719     {
720         return ( ( ( i &amp; ~7 ) == 0 ) &amp;&amp; ( ( j &amp; ~7 ) == 0 ) );
721     }
722     unsigned int ToIndex() const
723     {
724         return ( i + j * 8 );
725     }
726     int I() const
727     {
728         return i;
729     }
730     void I( int val )
731     {
732         i = val;
733     }
734     int J() const
735     {
736         return j;
737     }
738     void J( int val )
739     {
740         j = val;
741     }
742     void Set( int ip, int jp )
743     {
744         i = ip;
745         j = jp;
746     }
747     operator string() const
748     {
749         string s;
750         if ( IsOnBoard() )
751         {
752             s = ( char )( 'a' + i );
753             s += ( char )( '1' + j );
754         }
755         else
756             s = "-";
757         return s;
758     }
759     void Dump() const
760     {
761         if ( IsOnBoard() )
762         {
763             cout &lt;&lt; ( char )( 'a' + i );
764             cout &lt;&lt; ( char )( '1' + j );
765         }
766         else
767             cout &lt;&lt; "??";
768     }
769     Square Change( int ip, int jp )
770     {
771         i += ip;
772         j += jp;
773         return *this;
774     }
775     Square Change( const Square &amp;s )
776     {
777         i += s.i;
778         j += s.j;
779         return *this;
780     }
781     Square Add( int ip, int jp ) const
782     {
783         Square s( i + ip, j + jp );
784         return s;
785     }
786     Square Add( const Square &amp;s ) const
787     {
788         Square s1( i + s.I(), j + s.I() );
789         return s1;
790     }
791     bool operator== ( const Square &amp;right ) const
792     {
793         return ( ( i == right.i ) &amp;&amp; ( j == right.j ) );
794     }
795     int ManhattanDistanceTo( const Square &amp;other ) const
796     {
797         return abs( i - other.i ) + abs( j - other.j );
798     }
799 protected:
800     int i;     int j; };
801 Square A1( 0, 0 ), A2( 0, 1 ), A3( 0, 2 ), A4( 0, 3 ), A5( 0, 4 ), //-V112
802        A6( 0, 5 ), A7( 0, 6 ), A8( 0, 7 );
803 Square B1( 1, 0 ), B2( 1, 1 ), B3( 1, 2 ), B4( 1, 3 ), B5( 1, 4 ), //-V112
804        B6( 1, 5 ), B7( 1, 6 ), B8( 1, 7 );
805 Square C1( 2, 0 ), C2( 2, 1 ), C3( 2, 2 ), C4( 2, 3 ), C5( 2, 4 ), //-V112
806        C6( 2, 5 ), C7( 2, 6 ), C8( 2, 7 );
807 Square D1( 3, 0 ), D2( 3, 1 ), D3( 3, 2 ), D4( 3, 3 ), D5( 3, 4 ), //-V112
808        D6( 3, 5 ), D7( 3, 6 ), D8( 3, 7 );
809 Square E1( 4, 0 ), E2( 4, 1 ), E3( 4, 2 ), E4( 4, 3 ), E5( 4, 4 ), //-V112
810        E6( 4, 5 ), E7( 4, 6 ), E8( 4, 7 ); //-V112
811 Square F1( 5, 0 ), F2( 5, 1 ), F3( 5, 2 ), F4( 5, 3 ), F5( 5, 4 ), //-V112
812        F6( 5, 5 ), F7( 5, 6 ), F8( 5, 7 );
813 Square G1( 6, 0 ), G2( 6, 1 ), G3( 6, 2 ), G4( 6, 3 ), G5( 6, 4 ), //-V112
814        G6( 6, 5 ), G7( 6, 6 ), G8( 6, 7 );
815 Square H1( 7, 0 ), H2( 7, 1 ), H3( 7, 2 ), H4( 7, 3 ), H5( 7, 4 ), //-V112
816        H6( 7, 5 ), H7( 7, 6 ), H8( 7, 7 );
817 int BoardPieceSquare::GetPieceSquareValue( const Square &amp;s,
818         const float fPhase ) const
819 {
820     return GetPieceSquareValue( s.ToIndex(), fPhase );
821 }
822 class Move : Object
823 {
824 public:
825     Move()
826     {
827         m_Piece = &amp;None;
828         m_PromoteTo = &amp;None;
829         m_Score = 0;
830     }
831     Move( Piece *piece )
832     {
833         m_Piece = piece;
834         m_PromoteTo = &amp;None;
835         m_Score = 0;
836     }
837     Move( const Piece *piece, const Square &amp;source, const Square &amp;dest )
838     {
839         m_Piece = piece;
840         m_PromoteTo = &amp;None;
841         m_Source = source;
842         m_Dest = dest;
843         m_Score = 0;
844     }
845     Move( string sMove, Color color )
846     {
847         size_t moveLength = sMove.length();
848         m_PromoteTo = &amp;None;
849         if ( moveLength != 4 &amp;&amp; moveLength != 5 ) //-V112
850             Die( "Got an incoming Move string that had a weird length " );
851         m_Piece = &amp;None;
852         m_Source.I( sMove[0] - 'a' );
853         m_Source.J( sMove[1] - '1' );
854         m_Dest.I( sMove[2] - 'a' );
855         m_Dest.J( sMove[3] - '1' );
856         if ( moveLength == 5 )
857         {
858             char cPromote = ( char ) tolower( ( int ) sMove[ 4 ] );
859             switch ( cPromote )
860             {
861             case 'q' :
862                 m_PromoteTo = ( color == WHITE ) ? &amp;WhiteQueen : &amp;BlackQueen;
863                 break;
864             case 'n' :
865                 m_PromoteTo = ( color == WHITE ) ? &amp;WhiteKnight : &amp;BlackKnight;
866                 break;
867             case 'b' :
868                 m_PromoteTo = ( color == WHITE ) ? &amp;WhiteBishop : &amp;BlackBishop;
869                 break;
870             case 'r' :
871                 m_PromoteTo = ( color == WHITE ) ? &amp;WhiteRook : &amp;BlackRook;
872                 break;
873             default:
874                 break;
875             }
876         }
877     }
878     const Piece *GetPiece() const
879     {
880         return m_Piece;
881     }
882     void SetPiece( const Piece *val )
883     {
884         m_Piece = val;
885     }
886     const Piece *GetPromoteTo() const
887     {
888         return m_PromoteTo;
889     }
890     void SetPromoteTo( const Piece *val )
891     {
892         m_PromoteTo = val;
893         m_Score += val-&gt;PieceValue() ;
894     }
895     Square Source() const
896     {
897         return m_Source;
898     }
899     void Source( const Square &amp;val )
900     {
901         m_Source = val;
902     }
903     Square Dest() const
904     {
905         return m_Dest;
906     }
907     void Dest( const Square &amp;val )
908     {
909         m_Dest = val;
910     }
911     void Dump() const
912     {
913         if ( m_Piece == &amp;None )
914         {
915             cout &lt;&lt; "NoMove";
916             return;
917         }
918         cout &lt;&lt; m_Piece-&gt;Letter();
919         m_Source.Dump();
920         m_Dest.Dump();
921         if ( m_PromoteTo != &amp;None )
922             cout &lt;&lt; tolower( m_PromoteTo-&gt;Letter() );
923     }
924     operator string() const
925     {
926         if ( m_Piece == &amp;None )
927             return ( string ) "null";
928         if ( m_PromoteTo != &amp;None )
929         {
930             string s;
931             s.append( m_Source );
932             s.append( m_Dest );
933             s.push_back( ( char ) tolower( m_PromoteTo-&gt;Letter() ) );
934             return s;
935         }
936         return ( string ) m_Source + ( string ) m_Dest;
937     }
938     string TextWithPiece()
939     {
940         string letter;
941         stringstream ss;
942         ss &lt;&lt; m_Piece-&gt;Letter();
943         ss &gt;&gt; letter;
944         return ( letter ) + ( string ) m_Source + ( string ) m_Dest;
945     }
946     bool operator== ( const Move &amp;right )
947     {
948         return ( ( m_Piece == right.m_Piece ) &amp;&amp;
949                  ( m_Source == right.m_Source ) &amp;&amp;
950                  ( m_Dest == right.m_Dest ) &amp;&amp;
951                  ( m_PromoteTo == right.m_PromoteTo ) );
952     }
953     int Score() const
954     {
955         return m_Score;
956     }
957     void Score( int val )
958     {
959         m_Score = val;
960     }
961 protected:
962     const Piece *m_Piece;
963     Square m_Source, m_Dest;
964     int m_Score;
965     const Piece *m_PromoteTo;
966 };
967 bool operator == ( const Move &amp;left, const Move &amp;right )
968 {
969     if ( ( left.Source() == right.Source() ) &amp;&amp;
970             ( left.Dest() == right.Dest() ) &amp;&amp;
971             ( left.GetPiece() == right.GetPiece() ) &amp;&amp;
972             ( left.GetPromoteTo() == right.GetPromoteTo() ) )
973         return true;
974     return false;
975 }
976 bool operator != ( const Move &amp;left, const Move &amp;right )
977 {
978     return !( left == right );
979 }
980 bool operator&lt; ( const Move &amp;left, const Move &amp;right )
981 {
982     int leftscore = left.Score();
983     int rightscore = right.Score();
984     if ( ( leftscore != 0 ) &amp;&amp; ( leftscore == rightscore ) )
985     {
986         if ( left.GetPiece()-&gt;PieceValue() &lt; right.GetPiece()-&gt;PieceValue() )
987             return true;
988         return false;
989     }
990     if ( leftscore &gt; rightscore )
991         return true;
992     return false;
993 }
994 Move NullMove;
995 class PieceInitializer : Object
996 {
997 public:
998     PieceInitializer()
999     {
1000         WhitePawn.SetOtherColor( BlackPawn );
1001         BlackPawn.SetOtherColor( WhitePawn );
1002         WhiteKnight.SetOtherColor( BlackKnight );
1003         BlackKnight.SetOtherColor( WhiteKnight );
1004         WhiteBishop.SetOtherColor( BlackBishop );
1005         BlackBishop.SetOtherColor( WhiteBishop );
1006         WhiteRook.SetOtherColor( BlackRook );
1007         BlackRook.SetOtherColor( WhiteRook );
1008         WhiteQueen.SetOtherColor( BlackQueen );
1009         BlackQueen.SetOtherColor( WhiteQueen );
1010         WhiteKing.SetOtherColor( BlackKing );
1011         BlackKing.SetOtherColor( WhiteKing );
1012         None.SetOtherColor( None );  //-V678
1013         NullMove.Source( Square( -99, -99 ) );
1014         NullMove.Dest( Square( -99, -99 ) );
1015         None.SetIndex( 0 );
1016         WhitePawn.SetIndex( 1 );
1017         BlackPawn.SetIndex( 2 );
1018         WhiteKnight.SetIndex( 3 );
1019         BlackKnight.SetIndex( 4 ); //-V112
1020         WhiteBishop.SetIndex( 5 );
1021         BlackBishop.SetIndex( 6 );
1022         WhiteRook.SetIndex( 7 );
1023         BlackRook.SetIndex( 8 );
1024         WhiteQueen.SetIndex( 9 );
1025         BlackQueen.SetIndex( 10 );
1026         WhiteKing.SetIndex( 11 );
1027         BlackKing.SetIndex( 12 );
1028 <a name="0"></a>
1029         int p = 0;
1030         m_AllPieces[p++] = &amp;WhitePawn;
1031 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>        m_AllPieces[p++] = &amp;BlackPawn;
1032         m_AllPieces[p++] = &amp;WhiteKnight;
1033         m_AllPieces[p++] = &amp;BlackKnight;
1034         m_AllPieces[p++] = &amp;WhiteBishop;
1035         m_AllPieces[p++] = &amp;BlackBishop;
1036         m_AllPieces[p++] = &amp;WhiteRook;
1037         m_AllPieces[p++] = &amp;BlackRook;
1038         m_AllPieces[p++] = &amp;WhiteQueen;
1039         m_AllPieces[p++] = &amp;BlackQueen;
1040         m_AllPieces[p++] = &amp;WhiteKing;
1041         m_AllPieces[p++] = &amp;BlackKing;
1042         AllPieces = m_AllPieces;
1043     }</b></font>
1044     const Piece *m_AllPieces[AllPiecesSize];
1045 };
1046 class Moves : Object
1047 {
1048 public:
1049     Moves()
1050     {
1051         Initialize();
1052     }
1053     void Initialize()
1054     {
1055         m_Moves.clear();
1056     }
1057     void Add( const Move &amp;move )
1058     {
1059         m_Moves.push_back( move );
1060     }
1061     bool Bump( const Move &amp;bump )
1062     {
1063         MovesInternalType::iterator it;
1064         it = m_Moves.begin();
1065         while ( it != m_Moves.end() )
1066         {
1067             if ( *it == bump )
1068             {
1069                 Move tmp;
1070                 tmp = * ( m_Moves.begin() );
1071                 * ( m_Moves.begin() ) = *it;
1072                 *it = tmp;
1073                 return true;
1074             }
1075             ++it;
1076         }
1077         return false;
1078     }
1079     size_t Count() const
1080     {
1081         return m_Moves.size();
1082     }
1083     Move &amp;GetLast()
1084     {
1085         return m_Moves.at( m_Moves.size() - 1 );
1086     }
1087     void Make( const Move &amp;move )
1088     {
1089         m_Moves.push_back( move );
1090     }
1091     void Unmake()
1092     {
1093         m_Moves.pop_back();
1094     }
1095     Moves operator+ ( const Moves &amp;otherMoves )
1096     {
1097         m_Moves.insert( m_Moves.end(),
1098                         otherMoves.m_Moves.begin(),
1099                         otherMoves.m_Moves.end() );
1100         return *this;
1101     }
1102     void Append( const Moves &amp;&amp;otherMoves )
1103     {
1104         m_Moves.insert( m_Moves.end(),
1105                         otherMoves.m_Moves.begin(),
1106                         otherMoves.m_Moves.end() );
1107     }
1108     void Sort()
1109     {
1110         sort( m_Moves.begin(), m_Moves.end() );
1111     }
1112     Move Random()
1113     {
1114         if ( m_Moves.size() == 0 )
1115             return NullMove;
1116         return m_Moves.at( rand() % m_Moves.size() );
1117     }
1118     Move GetFirst() const
1119     {
1120         return m_Moves.front();
1121     }
1122     bool IsEmpty() const
1123     {
1124         return m_Moves.empty();
1125     }
1126     void Clear()
1127     {
1128         m_Moves.clear();
1129     }
1130     void Dump()
1131     {
1132         for ( auto move : m_Moves )
1133         {
1134             move.Dump();
1135             cout &lt;&lt; " ";
1136         }
1137     }
1138     operator string() const
1139     {
1140         string s;
1141         for ( auto move : m_Moves )
1142         {
1143             s += ( string ) move;
1144             s += " ";
1145         }
1146         return s;
1147     }
1148     bool TryAttack( const Move &amp;m, const Board &amp;board, int id, int jd )
1149     {
1150         Move myMove = m;
1151         myMove.Dest( Square( id + myMove.Source().I(), jd + myMove.Source().J() ) );
1152         if ( myMove.Dest().IsOnBoard() )
1153         {
1154             if ( myMove.GetPiece()-&gt;IsDifferent( myMove.Dest(), board ) )
1155             {
1156                 myMove.Score( board.Get( myMove.Dest() )-&gt;PieceValue() );
1157                 Add( myMove );
1158                 return true;
1159             }
1160             else if ( board.IsEmpty( myMove.Dest() ) )
1161             {
1162                 myMove.Score( None.PieceValue() );
1163                 Add( myMove );
1164                 return true;
1165             }
1166         }
1167         return false;
1168     }
1169     unsigned int TryRayAttack( const Move &amp;m, const Board &amp;board, int id, int jd )
1170     {
1171         int nAttacks = 0;
1172         Square sAttacked;
1173         int i = id;
1174         int j = jd;
1175         while ( TryAttack( m, board, i, j ) )
1176         {
1177             sAttacked.Set( m.Source().I() + i, m.Source().J() + j );
1178             if ( board.Get( sAttacked ) != &amp;None )
1179                 break;   
1180             i += id;
1181             j += jd;
1182             nAttacks++;
1183         }
1184         return nAttacks;
1185     }
1186     typedef vector&lt;Move&gt; MovesInternalType;
1187     typedef MovesInternalType::iterator iterator;
1188     typedef MovesInternalType::const_iterator const_iterator;
1189     iterator begin()
1190     {
1191         return m_Moves.begin();
1192     }
1193     const_iterator begin() const
1194     {
1195         return m_Moves.begin();
1196     }
1197     iterator end()
1198     {
1199         return m_Moves.end();
1200     }
1201     const_iterator end() const
1202     {
1203         return m_Moves.end();
1204     }
1205 protected:
1206     MovesInternalType m_Moves;
1207 };
1208 class Position;
1209 class PositionHasher : Object
1210 {
1211 public:
1212     PositionHasher( const Position &amp;pPos ) :
1213         m_Hash( 0 )
1214     {
1215         m_pPosition = &amp;pPos;
1216     }
1217     HashValue GetHash() const;
1218 protected:
1219     HashValue m_Hash;
1220     const Position *m_pPosition;
1221 private:
1222     PositionHasher();
1223 };
1224 enum HashEntryType
1225 {
1226     HET_NONE = 0x0,
1227     HET_PRINCIPAL_VARIATION = 0x1,
1228     HET_CUT_NODE = 0x2,
1229     HET_ALL_NODE = 0x4,
1230 };
1231 class PositionHashEntry : public Object
1232 {
1233 public :
1234     HashEntryType m_TypeBits;
1235     HashValue m_Hash;
1236     Move m_BestMove;
1237     int m_Depth;
1238     int m_Ply;
1239     int m_Score;
1240     PositionHashEntry() :
1241         m_Hash( 0 ),
1242         m_BestMove( 0 ),
1243         m_Depth( 0 ),
1244         m_Ply( 0 ),
1245         m_Score( 0 )
1246     {
1247         m_TypeBits = HET_NONE;
1248     }
1249 };
1250 class PositionHashTable;
1251 PositionHashTable *s_pPositionHashTable = nullptr;
1252 class PositionHashTable : public Object
1253 {
1254 public:
1255     PositionHashTable() :
1256         m_pEntries( nullptr ),
1257         m_SizeBytes( 0 ), m_SizeEntries( 0 ), m_SizeBytesMask( 0 ),
1258         m_CacheLookups( 0 ), m_CacheMisses( 0 ), m_CacheHits( 0 ),
1259         m_nEntriesInUse( 0 )
1260     {
1261         SetSize( HASH_TABLE_SIZE );
1262     }
1263     virtual ~PositionHashTable()
1264     {
1265         if ( m_SizeBytes )
1266             delete m_pEntries;
1267     }
1268     virtual void Purge()
1269     {
1270         delete m_pEntries;
1271         SetSize( m_SizeBytes );
1272     }
1273     virtual void Insert( const PositionHashEntry &amp;entry )
1274     {
1275         size_t loc = entry.m_Hash % m_SizeEntries;
1276         PositionHashEntry *pHE = m_pEntries + loc;
1277         if ( pHE-&gt;m_TypeBits == HET_NONE )
1278             m_nEntriesInUse++;
1279         if ( pHE-&gt;m_Hash == entry.m_Hash )
1280         {
1281             if ( pHE-&gt;m_Depth &gt; entry.m_Depth )
1282                 return;
1283         }
1284         m_pEntries[ loc ] = entry;
1285     }
1286     virtual const PositionHashEntry *LookUp( const HashValue &amp;val )
1287     {
1288         m_CacheLookups++;
1289         size_t loc = val % m_SizeEntries;
1290         PositionHashEntry *pEntry = m_pEntries + loc;
1291         if ( val == pEntry-&gt;m_Hash )
1292         {
1293             m_CacheHits++;
1294             return pEntry;
1295         }
1296         m_CacheMisses++;
1297         return nullptr;
1298     }
1299     virtual size_t GetSize() const
1300     {
1301         return m_SizeBytes;
1302     }
1303     virtual void SetSize( size_t size )
1304     {
1305         if ( size == 0 )
1306             Die( "Size of hash table can't be zero" );
1307         size--;
1308         size |= size &gt;&gt; 1;
1309         size |= size &gt;&gt; 2;
1310         size |= size &gt;&gt; 4;
1311         size |= size &gt;&gt; 8;
1312         size |= size &gt;&gt; 16;
1313         size++;
1314         m_SizeBytes = size;
1315         m_SizeBytesMask = size - 1;
1316         m_SizeEntries = m_SizeBytes / sizeof( PositionHashEntry );
1317         m_pEntries = new PositionHashEntry[ m_SizeEntries ];
1318     }
1319     virtual unsigned int GetHashFull()
1320     {
1321         return ( unsigned int )( 1000 * m_nEntriesInUse / m_SizeEntries );
1322     }
1323     PositionHashEntry *m_pEntries;
1324     size_t m_SizeBytes, m_SizeEntries, m_SizeBytesMask;
1325     uint64_t m_CacheLookups, m_CacheMisses, m_CacheHits;
1326     uint64_t m_nEntriesInUse;
1327 };
1328 class HashTableInitializer : public Object
1329 {
1330 public :
1331     HashTableInitializer()
1332     {
1333         s_pPositionHashTable = new PositionHashTable;
1334     }
1335     virtual ~HashTableInitializer()
1336     {
1337         delete s_pPositionHashTable;
1338         s_pPositionHashTable = nullptr;
1339     }
1340 };
1341 const float fPhaseMaterial[AllPiecesSize] =
1342 {
1343     0.0f,
1344     1.5f,
1345     1.5f,
1346     0.5f,     0.5f,
1347     2.0f,
1348     0.0f
1349 };
1350 static float s_fMaximumMaterial;
1351 class Material : Object
1352 {
1353     friend class Position;
1354 protected:
1355     void Initialize()
1356     {
1357         m_fPhase = 0.0f;
1358         for ( int i = 0; i &lt; AllPiecesSize; i++ )
1359             m_nCount[i] = 0;
1360     }
1361     void UpdateFrom( const Position &amp;pos );
1362     void CalculateMaximumMaterial()
1363     {
1364         s_fMaximumMaterial = GetMaterial();
1365     }
1366     void CaptureMaterial( const Piece *pPiece )
1367     {
1368         for ( int i = 0; i &lt; AllPiecesSize; i++ )
1369         {
1370             if ( AllPieces[i] == pPiece )
1371             {
1372                 m_nCount[i]--;
1373                 m_fPhase = 0.0f;
1374                 return;
1375             }
1376         }
1377         Die( "Could not find piece to capture!" );
1378     }
1379     float GetMaterial()
1380     {
1381         float fMaterial = 0.0f;
1382         for ( int i = 0; i &lt; AllPiecesSize; i++ )
1383             fMaterial += m_nCount[i] * fPhaseMaterial[i];
1384         return fMaterial;
1385     }
1386     float GetPhase()
1387     {
1388         if ( m_fPhase == 0.0f )
1389         {
1390             m_fPhase = 1.0f - ( GetMaterial() / s_fMaximumMaterial );
1391             if ( m_fPhase &gt; 1.0f )
1392                 m_fPhase = 1.0f;
1393             if ( m_fPhase &lt; 0.0f )
1394                 m_fPhase = 0.0f;
1395         }
1396         return m_fPhase;
1397     }
1398 protected:
1399     unsigned int m_nCount[ AllPiecesSize ];
1400     float m_fPhase;
1401 };
1402 class Position : Object
1403 {
1404     friend class PositionHasher;
1405     friend class King;
1406     friend class Material;
1407 public:
1408     Position()
1409     {
1410         Initialize();
1411     }
1412     Position( bool colorToMove )
1413     {
1414         Initialize();
1415         SetColorToMove( colorToMove );
1416     }
1417     Position( const string &amp;sFEN )
1418     {
1419         Initialize();
1420         SetFEN( sFEN );
1421     }
1422     Position( const Position &amp;position, const Move &amp;move )
1423     {
1424         CopyFrom( position );
1425         Square source = move.Source();
1426         DevirginizeRooks( source );
1427         const Piece *pPiece = GetBoard().Get( source );
1428         DevirginizeKing( pPiece );
1429         if ( &amp;move == &amp;NullMove )
1430         {
1431             SetColorToMove( !GetColorToMove() );
1432             return;
1433         }
1434         if ( pPiece == &amp;None )
1435         {
1436             stringstream ss;
1437             ss &lt;&lt; "Illegal move: no piece found at source location for move ";
1438             ss &lt;&lt; ( string ) move;
1439             Die( ss.str() );
1440         }
1441         if ( move.GetPromoteTo() == &amp;None )
1442             MovePiece( position, move );
1443         else
1444             PromotePiece( position, move );
1445         m_Board.Set( move.Source().I(), move.Source().J(), &amp;None );
1446         SetColorToMove( !GetColorToMove() );
1447         PushHashInHistory();
1448 <a name="1"></a>    }
1449     void Initialize()
1450 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    {
1451         SetColorToMove( WHITE );
1452         m_nPly = 0;
1453         m_nMaterialScore = 0;
1454         m_bVirginH8 =
1455             m_bVirginA8 =
1456                 m_bVirginH1 =
1457                     m_bVirginA1 =
1458                         m_bVirginBlackKing =
1459                             m_bVirginWhiteKing = true;
1460         m_nPlySinceCaptureOrPawnMove = 1;
1461         m_sEnPassant.Set( -1, -1 );
1462         m_Moves.Clear();
1463         m_Board.Initialize();
1464         m_Material.Initialize();
1465         m_bIsCheckDetermined = false;
1466         m_bIsCheck = false;
1467         m_PreviousPositions.clear();
1468     }</b></font>
1469     int GetColorBias() const
1470     {
1471         return ( m_ColorToMove == WHITE ? 1 : -1 );
1472     }
1473     PositionHashTable *GetHashTable() const
1474     {
1475         return s_pPositionHashTable;
1476     }
1477     const PositionHashEntry *LookUp() const
1478     {
1479         PositionHashTable *pHT = GetHashTable();
1480         PositionHasher ph( *this );
1481         return pHT-&gt;LookUp( ph.GetHash() );
1482     }
1483     void Insert( PositionHashEntry &amp;pos )
1484     {
1485         PositionHashTable *pHT = GetHashTable();
1486         PositionHasher ph( *this );
1487         pos.m_Hash = ph.GetHash();
1488         pHT-&gt;Insert( pos );
1489     }
1490     void HandleEnPassant( const Move &amp;move, const Position &amp;position,
1491                           Square &amp;captureSquare )
1492     {
1493         int pawnMoveDistance;
1494         pawnMoveDistance = move.Dest().J() - move.Source().J();
1495         if ( abs( pawnMoveDistance ) &gt; 1 )
1496         {
1497             pawnMoveDistance = pawnMoveDistance &gt;&gt; 1;
1498             Square enPassant( move.Source().I(), move.Source().J() + pawnMoveDistance );
1499             m_sEnPassant = enPassant;
1500         }
1501         else if ( move.Dest() == position.m_sEnPassant )
1502         {
1503             int d = position.GetColorToMove() ? -1 : 1;
1504             captureSquare = Square( move.Dest().I(), move.Dest().J() + d );
1505             CaptureMaterial( position, captureSquare );
1506             m_Board.Set( captureSquare.I(), captureSquare.J(), &amp;None );
1507         }
1508         else
1509         {
1510             CaptureMaterial( position, captureSquare );
1511         }
1512     }
1513     void HandleCastling( const Move &amp;move )
1514     {
1515         if ( abs( move.Source().I() - move.Dest().I() ) == 2 )
1516         {
1517             int rookISource = 0, rookIDest = 3, rookJ;
1518             rookJ = move.Source().J();
1519             if ( move.Dest().I() == 6 )
1520             {
1521                 rookISource = 7;
1522                 rookIDest = 5;
1523             }
1524             const Rook *pRook = dynamic_cast&lt;const Rook *&gt;( m_Board.Get( rookISource,
1525                                 rookJ ) );
1526             if ( pRook == nullptr )
1527             {
1528                 stringstream ss;
1529                 ss &lt;&lt; "Couldn't find rook during castling: ";
1530                 ss &lt;&lt; GetFEN();
1531                 Die( ss.str() );
1532             }
1533             m_Board.Set( rookIDest, rookJ, pRook );
1534             m_Board.Set( rookISource, rookJ, &amp;None );
1535             Square rookSource( rookISource, rookJ );
1536             DevirginizeRooks( rookSource );
1537         }
1538     }
1539     void PushHashInHistory()
1540     {
1541         PositionHasher ph( *this );
1542         m_PreviousPositions.push_back( ph.GetHash() );
1543     }
1544     void PopHashFromHistory()
1545     {
1546         m_PreviousPositions.pop_back();
1547     }
1548     unsigned int CountHashesInHistory( const HashValue &amp;theHash ) const
1549     {
1550         unsigned int count = 0;
1551         for ( auto previous : m_PreviousPositions )
1552         {
1553             if ( previous == theHash )
1554                 count++;
1555         }
1556         return count;
1557     }
1558     void CopyFrom( const Position &amp;position )
1559     {
1560         m_Board = position.m_Board;
1561         m_ColorToMove = position.m_ColorToMove;
1562         m_Material = position.m_Material;
1563         m_nMaterialScore = position.m_nMaterialScore;
1564         m_PreviousPositions = position.m_PreviousPositions;
1565         m_nPly = position.m_nPly + 1;
1566         m_sEnPassant = Square( -1, -1 );
1567         m_nPlySinceCaptureOrPawnMove = position.m_nPlySinceCaptureOrPawnMove + 1;
1568         m_bVirginH1 = position.m_bVirginH1;
1569         m_bVirginA1 = position.m_bVirginA1;
1570         m_bVirginH8 = position.m_bVirginH8;
1571         m_bVirginA8 = position.m_bVirginA8;
1572         m_bVirginBlackKing = position.m_bVirginBlackKing;
1573         m_bVirginWhiteKing = position.m_bVirginWhiteKing;
1574         m_bIsCheckDetermined = false;
1575         m_bIsCheck = false;
1576     }
1577     void MovePiece( const Position &amp;position, const Move &amp;move )
1578     {
1579         const Piece *pSource = m_Board.Get( move.Source() );
1580         const PieceType sourceType = pSource-&gt;Type();
1581         Square captureSquare = move.Dest();
1582         if ( sourceType == PAWN )
1583         {
1584             m_nPlySinceCaptureOrPawnMove = 1;
1585             HandleEnPassant( move, position, captureSquare );
1586         }
1587         else
1588             CaptureMaterial( position, captureSquare );
1589         m_Board.Set( move.Dest().I(), move.Dest().J(),
1590                      pSource );
1591         if ( sourceType == KING )
1592             HandleCastling( move );
1593     }
1594     void PromotePiece( const Position &amp;position, const Move &amp;move )
1595     {
1596         m_nMaterialScore = position.GetScore() +
1597                            ( move.GetPromoteTo()-&gt;PieceValue() +
1598                              m_Board.Get( move.Dest() )-&gt;PieceValue() ) *
1599                            GetColorBias();
1600         m_Board.Set( move.Dest().I(), move.Dest().J(),
1601                      move.GetPromoteTo() );
1602     }
1603     void DevirginizeKing( const Piece *pPiece )
1604     {
1605         if ( pPiece == &amp;WhiteKing )
1606             m_bVirginWhiteKing = false;
1607         if ( pPiece == &amp;BlackKing )
1608             m_bVirginBlackKing = false;
1609     }
1610     void DevirginizeRooks( Square &amp;source )
1611     {
1612         if ( source == A1 )
1613             m_bVirginA1 = false;
1614         if ( source == A8 )
1615             m_bVirginA8 = false;
1616         if ( source == H1 )
1617             m_bVirginH1 = false;
1618         if ( source == H8 )
1619             m_bVirginH8 = false;
1620     }
1621     void CaptureMaterial( const Position &amp;position, const Square &amp;captureSquare )
1622     {
1623         const Piece *pCaptured = m_Board.Get( captureSquare );
1624         m_nMaterialScore = position.GetScore() +
1625                            pCaptured-&gt;PieceValue() * GetColorBias();
1626         if ( pCaptured != &amp;None )
1627         {
1628             m_Material.CaptureMaterial( pCaptured );
1629             m_nPlySinceCaptureOrPawnMove = 1;
1630         }
1631         if ( captureSquare == A1 )
1632             m_bVirginA1 = false;
1633         if ( captureSquare == A8 )
1634             m_bVirginA8 = false;
1635         if ( captureSquare == H1 )
1636             m_bVirginH1 = false;
1637         if ( captureSquare == H8 )
1638             m_bVirginH8 = false;
1639     }
1640     void GenerateMoves()
1641     {
1642         const Piece *pPiece;
1643         for ( unsigned int j = 0; j &lt; MAX_FILES; j++ )
1644             for ( unsigned int i = 0; i &lt; MAX_FILES; i++ )
1645             {
1646                 pPiece = m_Board.Get( i, j );
1647                 if ( ( pPiece != &amp;None ) &amp;&amp; ( pPiece-&gt;GetColor() == m_ColorToMove ) )
1648                     m_Moves.Append( pPiece-&gt;GenerateMoves( Square( i, j ), *this ) );
1649             }
1650         m_Moves.Sort();
1651     }
1652     unsigned int GetPlySinceCaptureOrPawnMove() const
1653     {
1654         return m_nPlySinceCaptureOrPawnMove;
1655     }
1656     const Moves &amp;GetMoves()
1657     {
1658         if ( m_Moves.IsEmpty() )
1659             GenerateMoves();
1660         return m_Moves;
1661     }
1662     const Moves &amp;GetCaptures()
1663     {
1664         if ( m_Captures.IsEmpty() )
1665         {
1666             if ( m_Moves.IsEmpty() )
1667                 GenerateMoves();
1668             for ( auto &amp;move : m_Moves )
1669             {
1670                 if ( move.Score() &gt; 0 )
1671                     m_Captures.Add( move );
1672                 else
1673                     break;
1674             }
1675         }
1676         return m_Captures;
1677     }
1678     size_t CountMoves()
1679     {
1680         GetMoves();
1681         return m_Moves.Count();
1682     }
1683     bool CanKingBeCapturedNow()
1684     {
1685         Moves moves = GetMoves();
1686         if ( !moves.IsEmpty() )
1687         {
1688             Move bestMove = moves.GetFirst();
1689             if ( bestMove.Score() &gt;= KING_VALUE )
1690                 return true;
1691         }
1692         return false;
1693     }
1694     bool IsCheck()
1695     {
1696         if ( m_bIsCheckDetermined )
1697             return m_bIsCheck;
1698         Position tempPos( *this, NullMove );
1699         m_bIsCheck = tempPos.CanKingBeCapturedNow();
1700         m_bIsCheckDetermined = true;
1701         return m_bIsCheck;
1702     }
1703     bool IsStalemate()
1704     {
1705         if ( IsCheck() )
1706             return false;
1707         Moves moves = GetMoves();
1708         for ( auto move : moves )
1709         {
1710             Position nextPos( *this, move );
1711             if ( nextPos.CanKingBeCapturedNow() == false )
1712             {
1713                 return false;
1714             }
1715         }
1716         return true;
1717     }
1718     const Board &amp;GetBoard() const
1719     {
1720         return m_Board;
1721     }
1722     void SetBoard( const Board &amp;val )
1723     {
1724         m_Board = val;
1725     }
1726     void Setup()
1727     {
1728         Initialize();
1729         m_Board.Setup();
1730         m_ColorToMove = WHITE;
1731         m_Material.UpdateFrom( *this );
1732         m_Material.CalculateMaximumMaterial();
1733     }
1734     void Dump() const
1735     {
1736         m_Board.Dump();
1737         cout &lt;&lt; "FEN: " &lt;&lt; GetFEN() &lt;&lt; endl;
1738         stringstream ss;
1739         ss &lt;&lt; "Ply: " &lt;&lt; m_nPly &lt;&lt; endl;
1740         cout &lt;&lt; endl;
1741         cout &lt;&lt; "Ply: ";
1742         cout &lt;&lt; m_nPly;
1743         cout &lt;&lt; endl;
1744     }
1745     int SetFEN( const string &amp;sFEN )
1746     {
1747         Initialize();
1748         stringstream ss;
1749         ss.str( sFEN );
1750         string sBoard, sToMove, sVirgins, sEnPassant;
1751         int nMoves;
1752         ss &gt;&gt; sBoard &gt;&gt; sToMove &gt;&gt; sVirgins &gt;&gt; sEnPassant &gt;&gt; m_nPly &gt;&gt; nMoves;
1753         int j = MAX_FILES - 1;
1754         int i = 0;
1755         char c;
1756         stringstream ssBoard( sBoard );
1757         while ( ssBoard &gt;&gt; c )
1758         {
1759             switch ( c )
1760             {
1761             case '1' :
1762             case '2' :
1763             case '3' :
1764             case '4' :
1765             case '5' :
1766             case '6' :
1767             case '7' :
1768             case '8' :
1769                 i += c - '0';
1770                 break;
1771             case 'r' :
1772                 m_Board.Set( i++, j, &amp;BlackRook );
1773                 break;
1774             case 'n' :
1775                 m_Board.Set( i++, j, &amp;BlackKnight );
1776                 break;
1777             case 'b' :
1778                 m_Board.Set( i++, j, &amp;BlackBishop );
1779                 break;
1780             case 'q' :
1781                 m_Board.Set( i++, j, &amp;BlackQueen );
1782                 break;
1783             case 'k' :
1784                 m_Board.Set( i++, j, &amp;BlackKing );
1785                 break;
1786             case 'p' :
1787                 m_Board.Set( i++, j, &amp;BlackPawn );
1788                 break;
1789             case 'R' :
1790                 m_Board.Set( i++, j, &amp;WhiteRook );
1791                 break;
1792             case 'N' :
1793                 m_Board.Set( i++, j, &amp;WhiteKnight );
1794                 break;
1795             case 'B' :
1796                 m_Board.Set( i++, j, &amp;WhiteBishop );
1797                 break;
1798             case 'Q' :
1799                 m_Board.Set( i++, j, &amp;WhiteQueen );
1800                 break;
1801             case 'K' :
1802                 m_Board.Set( i++, j, &amp;WhiteKing );
1803                 break;
1804             case 'P' :
1805                 m_Board.Set( i++, j, &amp;WhitePawn );
1806                 break;
1807             case '/' :
1808                 i = 0;
1809                 j--;
1810                 break;
1811             default :
1812                 cerr &lt;&lt; "Unknown character in FEN board position";
1813                 break;
1814             }
1815         }
1816         SetColorToMove( sToMove == "w" ? WHITE : BLACK );
1817         stringstream ssVirgins( sVirgins );
1818         m_bVirginH1 =
1819             m_bVirginA1 =
1820                 m_bVirginH8 =
1821                     m_bVirginA8 =
1822                         m_bVirginBlackKing =
1823                             m_bVirginWhiteKing = false;
1824         while ( ssVirgins &gt;&gt; c )
1825         {
1826             switch ( c )
1827             {
1828             case '-' :
1829                 break;
1830             case 'K':
1831                 m_bVirginH1 = true;
1832                 break;
1833             case 'Q':
1834                 m_bVirginA1 = true;
1835                 break;
1836             case 'k':
1837                 m_bVirginH8 = true;
1838                 break;
1839             case 'q':
1840                 m_bVirginA8 = true;
1841                 break;
1842             }
1843         }
1844         if ( sEnPassant != "-" )
1845         {
1846             Square s( sEnPassant );
1847             m_sEnPassant = s;
1848         }
1849         m_nPly = ( nMoves - 1 ) * 2 + ( m_ColorToMove ? 0 : 1 );
1850         UpdateScore();
1851         return 0;
1852     }
1853     void UpdateScore();
1854     string GetFEN() const
1855     {
1856         string s;
1857         const Piece *pPiece;
1858         int nSpaces = 0;
1859         for ( unsigned int jj = 1; jj &lt;= MAX_FILES; jj++ )
1860         {
1861             unsigned int j = MAX_FILES - jj;
1862             for ( unsigned int i = 0; i &lt; MAX_FILES; i++ )
1863             {
1864                 pPiece = m_Board.Get( i, j );
1865                 if ( ( pPiece != &amp;None ) &amp;&amp; ( nSpaces &gt; 0 ) )
1866                 {
1867                     s += ( char ) nSpaces + '0';
1868                     nSpaces = 0;
1869                 }
1870                 if ( pPiece != &amp;None )
1871                     s += pPiece-&gt;Letter();
1872                 else
1873                     nSpaces++;
1874             }
1875             if ( nSpaces &gt; 0 )
1876                 s += ( char ) nSpaces + '0';
1877             nSpaces = 0;
1878             if ( j != 0 )
1879                 s += '/';
1880         }
1881         if ( GetColorToMove() == WHITE )
1882             s += " w ";
1883         else
1884             s += " b ";
1885         if ( !( m_bVirginH1 || m_bVirginA1 || m_bVirginH8 || m_bVirginA8 ) )
1886             s += "-";
1887         else
1888         {
1889             if ( m_bVirginH1 )
1890                 s += "K";
1891             if ( m_bVirginA1 )
1892                 s += "Q";
1893             if ( m_bVirginH8 )
1894                 s += "k";
1895             if ( m_bVirginA8 )
1896                 s += "q";
1897         }
1898         stringstream ss;
1899         ss &lt;&lt; " ";
1900         ss &lt;&lt; ( string ) m_sEnPassant;
1901         ss &lt;&lt; " ";
1902         ss &lt;&lt; m_nPly;
1903         ss &lt;&lt; " ";
1904         ss &lt;&lt; m_nPly / 2 + 1;
1905         s += ss.str();
1906         return s;
1907     }
1908     operator string()
1909     {
1910         return GetFEN();
1911     }
1912     Color GetColorToMove() const
1913     {
1914         return m_ColorToMove;
1915     }
1916     void SetColorToMove( Color val )
1917     {
1918         m_ColorToMove = val;
1919     }
1920     int GetScore() const
1921     {
1922         return m_nMaterialScore;
1923     }
1924     void SetScore( int val )
1925     {
1926         m_nMaterialScore = val;
1927     }
1928     unsigned int GetPly() const
1929     {
1930         return m_nPly;
1931     }
1932     void SetPly( int val )
1933     {
1934         m_nPly = val;
1935     }
1936     Square EnPassant() const
1937     {
1938         return m_sEnPassant;
1939     }
1940     void EnPassant( const Square &amp;val )
1941     {
1942         m_sEnPassant = val;
1943     }
1944     HashValue GetHash()
1945     {
1946         if ( m_PreviousPositions.size() == 0 )
1947         {
1948             PushHashInHistory();
1949         }
1950         return *( m_PreviousPositions.end() - 1 );
1951     }
1952     float GetPhase()
1953     {
1954         return m_Material.GetPhase();
1955     }
1956 protected:
1957     Board   m_Board;
1958     Color   m_ColorToMove;
1959     Material m_Material;
1960     unsigned int    m_nPly;
1961     int m_nMaterialScore;
1962     unsigned int m_nPlySinceCaptureOrPawnMove;
1963     bool m_bVirginH1, m_bVirginA1, m_bVirginH8, m_bVirginA8;
1964     bool m_bVirginWhiteKing, m_bVirginBlackKing;
1965     Square m_sEnPassant;
1966     Moves m_Moves;
1967     Moves m_Captures;
1968     bool m_bIsCheckDetermined;
1969     bool m_bIsCheck;
1970     typedef std::vector&lt; HashValue &gt; PreviousPositionType;
1971     PreviousPositionType m_PreviousPositions;
1972 };
1973 void Material::UpdateFrom( const Position &amp;pos )
1974 {
1975     Initialize();
1976     Board board = pos.GetBoard();
1977     for ( unsigned int square = 0; square &lt; MAX_SQUARES; square++ )
1978     {
1979         const Piece *pPiece = board.Get( square );
1980         for ( int p = 0; p &lt; AllPiecesSize; p++ )
1981         {
1982             if ( pPiece == &amp;None )
1983                 continue;
1984             if ( pPiece == AllPieces[p] )
1985             {
1986                 m_nCount[p]++;
1987                 break;
1988             }
1989         }
1990     }
1991 }
1992 HashValue PositionHasher::GetHash() const
1993 {
1994     return ( m_pPosition-&gt;m_Board.GetHash() ^
1995              s_PieceColorHash[( int ) m_pPosition-&gt;m_ColorToMove ]
1996            );
1997 }
1998 class EvaluatorBase : public Object
1999 {
2000 public:
2001     virtual int Evaluate( Position &amp;pos ) const = 0;
2002 protected:
2003     virtual int Bias( const Position &amp;pos, int nResult ) const
2004     {
2005         return ( pos.GetColorToMove() == WHITE ? nResult : -nResult );
2006     }
2007 };
2008 class EvaluatorSlowMaterial : public EvaluatorBase
2009 {
2010 public:
2011     virtual int Evaluate( Position &amp;pos ) const
2012     {
2013         Board board = pos.GetBoard();
2014         const Piece *piece;
2015         int nScore = 0;
2016         for ( unsigned int i = 0; i &lt; MAX_SQUARES; i++ )
2017         {
2018             piece = board.Get( i );
2019             if ( piece != &amp;None )
2020             {
2021                 nScore += ( piece-&gt;PieceValue() *
2022                             ( ( piece-&gt;GetColor() == WHITE ) ? 1 : -1 ) );
2023             }
2024         }
2025         return Bias( pos, nScore );
2026     }
2027 };
2028 class EvaluatorPieceSquare : public EvaluatorBase
2029 {
2030 public:
2031     virtual int Evaluate( Position &amp;pos ) const
2032     {
2033         Board board = pos.GetBoard();
2034         const Piece *piece;
2035         int nScore = 0;
2036         for ( unsigned int i = 0; i &lt; MAX_SQUARES; i++ )
2037         {
2038             piece = board.Get( i );
2039             if ( piece != &amp;None )
2040             {
2041                 nScore += ( board.GetPieceSquareValue( i, pos.GetPhase() ) *
2042                             ( ( piece-&gt;GetColor() == WHITE ) ? 1 : -1 ) );
2043             }
2044         }
2045         return Bias( pos, nScore );
2046     }
2047 };
2048 class EvaluatorMaterial : public EvaluatorSlowMaterial
2049 {
2050 public:
2051     virtual int Evaluate( Position &amp;pos ) const
2052     {
2053         return Bias( pos, pos.GetScore() );
2054     }
2055 };
2056 class EvaluatorMopUp : public EvaluatorBase
2057 {
2058     unsigned int whiteKing = 99, blackKing = 99;
2059     int dist = 0;
2060     virtual int Evaluate( Position &amp;pos ) const
2061     {
2062         const float fTurnOnAt = 0.9f;
2063         if ( pos.GetPhase() &lt; fTurnOnAt )
2064             return 0;
2065         Square localWhiteKing, localBlackKing;
2066         for ( unsigned int i = 0; i &lt; MAX_FILES; i++ )
2067         {
2068             for ( unsigned int j = 0; j &lt; MAX_FILES; j++ )
2069             {
2070                 Square cur( i, j );
2071                 const Piece *pPiece = pos.GetBoard().Get( cur );
2072                 if ( pPiece == &amp;WhiteKing )
2073                     localWhiteKing = cur;
2074                 if ( pPiece == &amp;BlackKing )
2075                     localBlackKing = cur;
2076             }
2077         }
2078         return Bias( pos, ( 6 - localWhiteKing.ManhattanDistanceTo(
2079                                 localBlackKing ) ) * 100 );
2080     }
2081 };
2082 class EvaluatorWeighted : public EvaluatorBase
2083 {
2084 public:
2085     virtual int Evaluate( Position &amp;pos ) const
2086     {
2087         if ( m_Evaluators.empty() )
2088             Die( "No evaluators have been defined" );
2089         WeightsType::const_iterator weightIter;
2090         weightIter = m_Weights.begin();
2091         int nScore = 0;
2092         for ( EvaluatorsType::const_iterator iter = m_Evaluators.begin();
2093                 iter != m_Evaluators.end();
2094                 ++iter )
2095         {
2096             nScore += ( int )( ( *iter )-&gt;Evaluate( pos ) * ( *weightIter ) );
2097             ++weightIter;
2098         }
2099         return nScore;
2100     }
2101     void Add( EvaluatorBase &amp;eval, float weight = 1.0f )
2102     {
2103         m_Evaluators.push_back( &amp;eval );
2104         m_Weights.push_back( weight );
2105     }
2106 protected:
2107     typedef vector&lt;float&gt; WeightsType;
2108     typedef vector&lt;EvaluatorBase *&gt; EvaluatorsType;
2109     WeightsType m_Weights;
2110     EvaluatorsType m_Evaluators;
2111 };
2112 class EvaluatorSimpleMobility : public EvaluatorBase
2113 {
2114     virtual int Evaluate( Position &amp;pos ) const
2115     {
2116         return ( int ) pos.CountMoves() ;
2117     }
2118 };
2119 class EvaluatorStandard : public EvaluatorWeighted
2120 {
2121 public:
2122     EvaluatorStandard()
2123     {
2124         m_Weighted.Add( m_Material );
2125         m_Weighted.Add( m_SimpleMobility, 0.1f );
2126         m_Weighted.Add( m_PieceSquareEvaluator, 0.8f );
2127     }
2128     virtual int Evaluate( Position &amp;pos ) const
2129     {
2130         return m_Weighted.Evaluate( pos );
2131     }
2132     EvaluatorMaterial m_Material;
2133     EvaluatorSimpleMobility m_SimpleMobility;
2134     EvaluatorPieceSquare m_PieceSquareEvaluator;
2135     EvaluatorMopUp m_MopUp;
2136     EvaluatorWeighted m_Weighted;
2137 };
2138 typedef EvaluatorStandard Evaluator;
2139 void Position::UpdateScore()
2140 {
2141     EvaluatorSlowMaterial slow;
2142     SetScore( slow.Evaluate( *this ) );
2143     m_Material.UpdateFrom( *this );
2144 }
2145 class DirectorBase : Object
2146 {
2147 protected:
2148     Interface *m_pInterface;
2149     friend class Interface;
2150 public:
2151     DirectorBase()
2152     {
2153         Initialize();
2154     }
2155     void SetInterface( Interface &amp;interface )
2156     {
2157         m_pInterface = &amp;interface;
2158     }
2159     virtual unsigned int GetDepth() const
2160     {
2161         return m_nDepth;
2162     }
2163     virtual unsigned int GetNodes() const
2164     {
2165         return m_nNodes;
2166     }
2167     virtual void Initialize()
2168     {
2169         m_SearchMoves.Clear();
2170         m_bPonder = false;
2171         m_WhiteTime = m_BlackTime = m_WhiteInc = m_BlackInc = 0;
2172         m_nMovesToGo =
2173             m_nNodes = m_nMateInMoves = m_nMoveTime = 0;
2174         m_nDepth = 0;
2175         m_bInfinite = false;
2176         m_SearchStopTime = 0;
2177         m_SearchEmergencyStopTime = 0;
2178     }
2179     virtual void Action()
2180     {
2181         m_SearchStopTime = 0;
2182         m_SearchEmergencyStopTime = 0;
2183     }
2184     virtual void Cut()
2185     {
2186         m_SearchStopTime = 0;
2187         m_SearchEmergencyStopTime = 0;
2188     }
2189     virtual void CalculateSearchStopTime(
2190         const Clock::ChessTickType         const int         const int         const Position &amp;rootPosition,
2191         const Moves &amp;     )
2192     {
2193         int ply = rootPosition.GetPly();
2194         Color sideToMove = rootPosition.GetColorToMove();
2195         Clock::ChessTickType timeLeft, themTimeLeft;
2196         if ( sideToMove == WHITE )
2197         {
2198             timeLeft = m_WhiteTime;
2199             themTimeLeft = m_BlackTime;
2200         }
2201         else
2202         {
2203             timeLeft = m_BlackTime;
2204             themTimeLeft = m_WhiteTime;
2205         }
2206         int movesUntilTimeControl;
2207         if ( m_nMovesToGo != 0 )
2208             movesUntilTimeControl = m_nMovesToGo;
2209         else
2210             movesUntilTimeControl = 25;
2211         float factor;
2212         factor =  2.0f - fabs( ( float )ply - 17.0f ) / 5.0f ;
2213         if ( factor &gt; 2.0f )
2214             factor = 2.0f;
2215         if ( factor &lt; 1.0f )
2216             factor = 1.0f;
2217         m_SearchStopTime = timeLeft / movesUntilTimeControl;
2218         float fSearchStopTime = ( float )m_SearchStopTime;
2219         fSearchStopTime *= factor;
2220         fSearchStopTime = fSearchStopTime * ( timeLeft * timeLeft ) /
2221                           ( themTimeLeft * themTimeLeft );
2222         m_SearchStopTime = ( Clock::ChessTickType )fSearchStopTime;
2223         m_SearchEmergencyStopTime = timeLeft / 2;
2224     }
2225     void Notify( const string &amp;s );
2226     virtual bool ShouldCut(
2227         const Clock::ChessTickType currentTime,
2228         const int nScore,
2229         const unsigned int nDepthSearched,
2230         const Position &amp;rootPosition,
2231         const Moves &amp;mPrincipalVariation
2232     )
2233     {
2234         if ( nDepthSearched &gt;= 100 )
2235             return true;
2236         if ( m_nDepth != 0 )
2237             return ( nDepthSearched &gt;= m_nDepth );
2238         if ( m_nMoveTime != 0 )
2239             return ( currentTime &gt;= m_nMoveTime );
2240         if ( m_bInfinite )
2241             return false;
2242         if ( m_SearchStopTime == 0 )
2243             CalculateSearchStopTime( currentTime, nScore, nDepthSearched,
2244                                      rootPosition, mPrincipalVariation );
2245         return ( currentTime &gt;= m_SearchStopTime );
2246     }
2247     virtual bool ShouldCutEmergency( const Clock::ChessTickType currentTime )
2248     {
2249         if ( m_SearchEmergencyStopTime == 0 )
2250             return false;
2251         return ( currentTime &gt; m_SearchEmergencyStopTime );
2252     }
2253 protected:
2254     Moves m_SearchMoves;
2255     bool m_bPonder;
2256     Clock::ChessTickType m_WhiteTime, m_BlackTime, m_WhiteInc, m_BlackInc;
2257     unsigned int m_nMovesToGo;
2258     unsigned int m_nDepth;
2259     unsigned int m_nNodes;
2260     unsigned int m_nMateInMoves;
2261     unsigned int m_nMoveTime;
2262     bool m_bInfinite;
2263     Clock::ChessTickType m_SearchStopTime;
2264     Clock::ChessTickType m_SearchEmergencyStopTime;
2265 };
2266 typedef DirectorBase Director;
2267 class SearcherBase : Object
2268 {
2269 public:
2270     SearcherBase( Interface &amp;interface ) :
2271         m_nNodesSearched( 0 )
2272     {
2273         m_bTerminated = true;
2274         m_pInterface = &amp;interface;
2275         m_Director.SetInterface( interface );
2276     }
2277     ~SearcherBase()
2278     {
2279         Stop();
2280     }
2281     bool IsRunning() const
2282     {
2283         return !m_bTerminated;
2284     }
2285     virtual void Start( const Position &amp;pos )
2286     {
2287         m_Root = pos;
2288         m_nNodesSearched = 0;
2289         m_Clock.Reset();
2290         m_Clock.Start();
2291     }
2292     virtual void Stop()
2293     {
2294     }
2295     virtual void SetDirector( const Director &amp;director )
2296     {
2297         m_Director = director;
2298         m_Director.SetInterface( *m_pInterface );
2299     }
2300     virtual int Evaluate( Position &amp;pos )
2301     {
2302         return m_Evaluator.Evaluate( pos );
2303     }
2304 protected:
2305     void Notify( const string &amp;s ) const;
2306     void Instruct( const string &amp;s ) const;
2307     void Bestmove( const string &amp;s ) const;
2308     void SearchComplete()
2309     {
2310         if ( m_Result.Count() &gt; 0 )
2311         {
2312             stringstream ss;
2313             ss.str( "" );
2314             ss &lt;&lt; ( string )m_Result.GetFirst();
2315             Bestmove( ss.str() );
2316         }
2317         m_bTerminated = true;
2318     }
2319     virtual int Search() = 0;
2320     uint64_t m_nNodesSearched;
2321     mutex m_Lock;
2322     atomic_bool m_bTerminated;
2323     Interface *m_pInterface;
2324     thread m_Thread;
2325     Evaluator m_Evaluator;
2326     Director m_Director;
2327     Clock m_Clock;
2328     Moves m_Result;
2329     int m_Score;
2330     SearcherBase() {};
2331     Position m_Root;
2332 };
2333 class SearcherReporting : public SearcherBase
2334 {
2335 public:
2336     SearcherReporting( Interface &amp;interface ) :
2337         SearcherBase( interface )
2338     {
2339         m_tLastReport = m_Clock.Get();
2340     };
2341     virtual void Report( const Position &amp;pos )
2342     {
2343         Clock::ChessTickType tMilliSinceStart = m_Clock.Get();
2344         if ( abs( tMilliSinceStart - m_tLastReport ) &lt; 1000 )
2345             return;
2346         if ( tMilliSinceStart == 0 )
2347             return;
2348         m_tLastReport = tMilliSinceStart;
2349         uint64_t nodesPerSec = m_nNodesSearched * 1000 / tMilliSinceStart;
2350         int hashFull = pos.GetHashTable()-&gt;GetHashFull();
2351         stringstream ss;
2352         ss &lt;&lt; "info time " &lt;&lt; tMilliSinceStart
2353            &lt;&lt; " nodes " &lt;&lt; m_nNodesSearched
2354            &lt;&lt; " nps " &lt;&lt; nodesPerSec
2355            &lt;&lt; " hashfull " &lt;&lt; hashFull ;
2356         Instruct( ss.str() );
2357     }
2358     Clock::ChessTickType m_tLastReport;
2359 };
2360 class SearcherThreaded : public SearcherReporting
2361 {
2362 public:
2363     typedef SearcherReporting super;
2364     typedef lock_guard&lt;mutex&gt; SearchLockType;
2365     SearcherThreaded( Interface &amp;interface ) :
2366         SearcherReporting( interface )
2367     { }
2368     virtual ~SearcherThreaded()
2369     {
2370         Stop();
2371     }
2372     virtual void Start( const Position &amp;pos )
2373     {
2374         Stop();
2375         super::Start( pos );
2376         SearchLockType guard( m_Lock );
2377         if ( m_bTerminated == false )
2378             return;
2379         m_Result.Clear();
2380         m_bTerminated = false;
2381         m_Director.Action();
2382         m_Thread = thread( &amp;SearcherThreaded::Search, this );
2383     }
2384     virtual void Stop()
2385     {
2386         SearchLockType guard( m_Lock );
2387         bool bCanJoin = m_Thread.joinable();
2388         m_bTerminated = true;
2389         if ( bCanJoin )
2390             m_Thread.join();
2391         m_Director.Cut();
2392     }
2393 protected:
2394     virtual int Search()
2395     {
2396         m_Director.Action();
2397         int nCurrentDepth = 0;
2398         while ( !m_bTerminated )
2399         {
2400             nCurrentDepth++;
2401             Moves PV;
2402             if ( ( nCurrentDepth &gt; 1 ) &amp;&amp;
2403                     m_Director.ShouldCut( m_Clock.Get(),
2404                                           m_Score,
2405                                           nCurrentDepth,
2406                                           m_Root,
2407                                           PV
2408                                         ) )
2409             {
2410                 m_bTerminated = true;
2411                 break;
2412             }
2413             m_Score = InternalSearch( -BIG_NUMBER, BIG_NUMBER,
2414                                       nCurrentDepth, m_Root, PV );
2415             if ( m_Director.ShouldCutEmergency( m_Clock.Get() ) == false )
2416             {
2417                 m_Result = PV;
2418                 ReportCurrentPrincipalVariation( nCurrentDepth, PV );
2419             }
2420             if ( m_bTerminated )
2421                 break;
2422         }
2423         SearchComplete();
2424         return m_Score;
2425     }
2426     void ReportCurrentPrincipalVariation( unsigned int nCurrentDepth,
2427                                           const Moves &amp;PV )
2428     {
2429         stringstream ss;
2430         ss &lt;&lt; "info depth " &lt;&lt; nCurrentDepth;
2431         ss &lt;&lt; " pv " &lt;&lt; ( string )PV;
2432         ss &lt;&lt; " score ";
2433         int absScore;
2434         absScore = abs( m_Score );
2435         if ( absScore &gt; CHECKMATE_VALUE )
2436         {
2437             int mate = ( 1 + KING_VALUE - absScore ) / 2;
2438             if ( m_Score &lt; 0 )
2439                 mate = -mate;
2440             ss &lt;&lt; "mate " &lt;&lt; mate;
2441         }
2442         else
2443             ss &lt;&lt; "cp " &lt;&lt; m_Score;
2444         Instruct( ss.str() );
2445     }
2446     virtual int InternalSearch( int alpha, int beta, int depthleft,
2447                                 Position &amp;pos, Moves &amp;pv ) = 0;
2448 protected:
2449     SearcherThreaded();
2450 };
2451 class SearcherPrincipalVariation : public SearcherThreaded
2452 {
2453     typedef SearcherThreaded super;
2454 public:
2455     SearcherPrincipalVariation( Interface &amp;interface ) :
2456         super( interface )
2457     { }
2458 protected:
2459     virtual int InternalSearch( int, int, int depth,
2460                                 Position &amp;pos, Moves &amp;pv )
2461     {
2462         return SearchPrincipalVariation( -BIG_NUMBER, BIG_NUMBER, depth, pos, pv );
2463     }
2464     {
2465         myMoves = pos.GetMoves();
2466         if ( myMoves.IsEmpty() )
2467             Die( "No moves could be generated!" );
2468     }
2469     int m_nSearchExtension;
2470     virtual void ExtendSearchDepth( )
2471     {
2472         m_nSearchExtension = 1;
2473     }
2474     virtual void ReduceSearchDepth( )
2475     {
2476         m_nSearchExtension = -1;
2477     }
2478     virtual void ResetSearchDepth()
2479     {
2480         m_nSearchExtension = 0;
2481     }
2482     virtual void FilterCheckResolvingMoves( Moves &amp;myMoves, Position &amp;pos )
2483     {
2484         Moves checkResolvingMoves;
2485         Moves::iterator it = myMoves.begin();
2486         while ( it != myMoves.end() )
2487         {
2488             Position tempPos( pos, *it );
2489             if ( !tempPos.CanKingBeCapturedNow() )
2490                 checkResolvingMoves.Add( *it );
2491             ++it;
2492         }
2493         myMoves = checkResolvingMoves;
2494     }
2495     bool IsEndOfGame( int &amp;score, Position &amp;pos, Moves &amp;myMoves )
2496     {
2497         if ( IsDrawByRepetition( pos, score ) )
2498             return true;
2499         if ( pos.GetPlySinceCaptureOrPawnMove() &gt;= 100 )
2500         {
2501             score = DRAW_SCORE;
2502             return true;
2503         }
2504         if ( pos.CanKingBeCapturedNow() )
2505         {
2506             score = KING_VALUE;
2507             return true;
2508         }
2509         if ( pos.IsStalemate() )
2510         {
2511             score = DRAW_SCORE;
2512             return true;
2513         }
2514         if ( pos.IsCheck() )
2515         {
2516             ExtendSearchDepth();
2517             FilterCheckResolvingMoves( myMoves, pos );
2518             if ( myMoves.Count() == 0 )
2519             {
2520                 score = -KING_VALUE;
2521                 return true;
2522             }
2523         }
2524         return false;
2525     }
2526     bool IsDrawByRepetition( Position &amp;pos, int &amp;score )
2527     {
2528         if ( pos.CountHashesInHistory( pos.GetHash() ) &gt;= 3 )
2529         {
2530             score = DRAW_SCORE;
2531             return true;
2532         }
2533         return false;
2534     }
2535     int AttenuateForMate( int score )
2536     {
2537         if ( abs( score ) &gt; CHECKMATE_VALUE )
2538         {
2539             int attenuate = ( score &gt; 0 ) ? -1 : 1;
2540             score += attenuate;
2541         }
2542         return score;
2543     }
2544     {
2545         if ( depth &lt;= 0 )
2546         {
2547             Report( pos );
2548             score = Evaluate( pos );
2549             return true;
2550         }
2551         return false;
2552     }
2553     virtual int SearchNode( int beta, int alpha, int depth, Position &amp;nextPos,
2554                             Moves &amp;currentPV )
2555     {
2556         return -SearchPrincipalVariation( -beta, -alpha, depth - 1, nextPos,
2557                                           currentPV );
2558     }
2559     {
2560         return false;
2561     }
2562     {}
2563     virtual void CheckWhetherToEmergencyStop()
2564     {
2565         if ( m_Director.ShouldCutEmergency( m_Clock.Get() ) )
2566             m_bTerminated = true;
2567     }
2568     virtual int SearchPrincipalVariation( int alpha, int beta, int depth,
2569                                           Position &amp;pos, Moves &amp;pv )
2570     {
2571         int score = 0;
2572         Move bestMove = NullMove;
2573         Moves bestPV, currentPV, myMoves;
2574         m_nNodesSearched++;
2575         ResetSearchDepth();
2576         if ( IsDrawByRepetition( pos, score ) )
2577             return score;
2578         if ( CheckPreviousSearchResults( score, pos, bestMove, pv, alpha, beta,
2579                                          depth ) )
2580             return score;
2581         if ( IsFrontier( score, pos, alpha, beta, depth ) )
2582             return score;
2583         GetMoves( myMoves, pos, depth );
2584         if ( bestMove != NullMove )
2585         {
2586             if ( myMoves.Bump( bestMove ) == false )
2587             {
2588             }
2589         }
2590         if ( IsEndOfGame( score, pos, myMoves ) )
2591         {
2592             CacheNodeType( HET_PRINCIPAL_VARIATION, pos, score, depth, NullMove );
2593             return score;
2594         }
2595         bool bFirstSearch = true;
2596         bool bAlphaExceeded = false;
2597         for ( auto &amp;move : myMoves )
2598         {
2599             currentPV = pv;
2600             currentPV.Make( move );
2601             Position nextPos( pos, move );
2602             score = SearchNode( beta, alpha, depth + m_nSearchExtension, nextPos,
2603                                 currentPV );
2604             score = AttenuateForMate( score );
2605             if ( bFirstSearch )
2606             {
2607                 bestPV = currentPV;
2608                 bestMove = move;
2609                 bFirstSearch = false;
2610             }
2611             if ( score &gt;= beta )
2612             {
2613                 pv = bestPV;
2614                 CacheNodeType( HET_CUT_NODE, pos, score, depth, move );
2615                 return beta;               }
2616             if ( score &gt; alpha )
2617             {
2618                 bAlphaExceeded = true;
2619                 alpha = score;                 bestPV = currentPV;
2620                 bestMove = move;
2621             }
2622             CheckWhetherToEmergencyStop();
2623             if ( m_bTerminated )
2624                 break;
2625         }
2626         if ( bAlphaExceeded )
2627             CacheNodeType( HET_PRINCIPAL_VARIATION, pos, score, depth, bestMove );
2628         else
2629             CacheNodeType( HET_ALL_NODE, pos, score, depth, bestMove );
2630         pv = bestPV;
2631         return alpha;
2632     }
2633 };
2634 class SearcherQuiescence : public SearcherPrincipalVariation
2635 {
2636     typedef SearcherPrincipalVariation super;
2637 public:
2638     SearcherQuiescence( Interface &amp;interface ) :
2639         super( interface )
2640     { }
2641     virtual bool IsFrontier( int &amp;score, Position &amp;pos, int &amp;alpha, int beta,
2642                              int depth )
2643     {
2644         if ( depth &lt;= 0 )
2645         {
2646             score = Evaluate( pos );
2647             if ( score &gt;= beta )
2648             {
2649                 score = beta;
2650                 return true;
2651             }
2652             if ( alpha &lt; score )
2653                 alpha = score;
2654             Report( pos );
2655             Moves captures = pos.GetCaptures();
2656             if ( captures.IsEmpty() )
2657             {
2658                 return true;
2659             }
2660             return false;
2661         }
2662         Report( pos );
2663         return false;
2664     }
2665     virtual void GetMoves( Moves &amp;myMoves, Position &amp;pos, const int depth )
2666     {
2667         if ( depth &gt; 0 )
2668         {
2669             myMoves = pos.GetMoves();
2670             if ( myMoves.IsEmpty() )
2671                 Die( "No moves could be generated!" );
2672         }
2673         else
2674         {
2675             myMoves = pos.GetCaptures();
2676             if ( myMoves.IsEmpty() )
2677                 Die( "No captures could be generated!" );
2678         }
2679     }
2680 };
2681 class SearcherCaching : public SearcherQuiescence
2682 {
2683 public:
2684     typedef SearcherQuiescence super;
2685     SearcherCaching( Interface &amp;interface ) :
2686         super( interface )
2687     { }
2688 protected:
2689     virtual void CacheNodeType( const HashEntryType &amp;het, Position &amp;pos,
2690                                 const int score, const int depth,
2691                                 const Move &amp;move )
2692     {
2693         PositionHashEntry phe;
2694         phe.m_Depth = depth;
2695         phe.m_BestMove = move;
2696         phe.m_TypeBits = het;
2697         phe.m_Score = score;
2698         PositionHasher ph( pos );
2699         phe.m_Hash = ph.GetHash();
2700         s_pPositionHashTable-&gt;Insert( phe );
2701     }
2702     virtual bool CheckTranspositionTable( Move &amp;bestMove,
2703                                           int &amp;nSearchResult,
2704                                           const Position &amp;pos, const int alpha,
2705                                           const int beta, const int depth )
2706     {
2707         const PositionHashEntry *pEntry = pos.LookUp();
2708         bestMove = NullMove;
2709         if ( pEntry )
2710         {
2711             if ( pEntry-&gt;m_Depth &gt;= depth )
2712             {
2713                 switch ( pEntry-&gt;m_TypeBits )
2714                 {
2715                 case HET_PRINCIPAL_VARIATION:
2716                     bestMove = pEntry-&gt;m_BestMove;
2717                     nSearchResult = pEntry-&gt;m_Score;
2718                     return true;
2719                 case HET_ALL_NODE:
2720                     if ( pEntry-&gt;m_Score &lt;= alpha )
2721                     {
2722                         bestMove = pEntry-&gt;m_BestMove;
2723                         nSearchResult = pEntry-&gt;m_Score;
2724                         return true;
2725                     }
2726                     break;
2727                 case HET_CUT_NODE:
2728                     if ( pEntry-&gt;m_Score &gt;= beta )
2729                     {
2730                         bestMove = pEntry-&gt;m_BestMove;
2731                         nSearchResult = beta;
2732                         return true;
2733                     }
2734                     break;
2735                 default:
2736                     Die( "Unknown PositionHashEntry type; hash table corruption?" );
2737                 };
2738             };
2739             bestMove = pEntry-&gt;m_BestMove;
2740         }
2741         return false;
2742     }
2743     virtual bool CheckPreviousSearchResults( int &amp;score, Position &amp;pos,
2744             Move &amp;bestMove, Moves &amp;pv, int &amp;alpha, int &amp;beta, const int depth )
2745     {
2746         int nSearchResult;
2747         bool bFound = CheckTranspositionTable( bestMove, nSearchResult, pos, alpha,
2748                                                beta, depth );
2749         if ( bFound )
2750         {
2751             pv.Add( bestMove );
2752             score = nSearchResult;
2753             return true;
2754         }
2755         return false;
2756     }
2757 };
2758 typedef SearcherCaching Searcher;
2759 const Piece *BoardBase::Set( const Square &amp;s, const Piece *piece )
2760 {
2761     return Set( s.I(), s.J(), piece );
2762 }
2763 const Piece *BoardBase::Get( const Square &amp;s ) const
2764 {
2765     return Get( s.I(), s.J() );
2766 }
2767 bool BoardBase::IsEmpty( const Square &amp;square ) const
2768 {
2769     return ( Get( square.I(), square.J() ) == &amp;None );
2770 }
2771 bool Piece::IsDifferent( const Square &amp;dest, const Board &amp;board ) const
2772 {
2773     const Piece *piece = board.Get( dest );
2774     if ( piece == &amp;None )
2775         return false;
2776     return ( m_Color != piece-&gt;GetColor() );
2777 }
2778 bool Piece::IsDifferentOrEmpty( const Square &amp;dest, const Board &amp;board ) const
2779 {
2780     const Piece *piece = board.Get( dest );
2781     if ( piece == &amp;None )
2782         return true;
2783     return ( m_Color != piece-&gt;GetColor() );
2784 }
2785 {
2786     Moves moves;
2787     return moves;
2788 }
2789 void Pawn::AddAndPromote( Moves &amp;moves, Move &amp;m, const bool bIsPromote ) const
2790 {
2791     if ( bIsPromote )
2792     {
2793         Color color = m.GetPiece()-&gt;GetColor();
2794         if ( color == WHITE )
2795         {
2796             Move m1;
2797             m1 = m;
2798             m1.SetPromoteTo( &amp;WhiteQueen );
2799             moves.Add( m1 );
2800             m1 = m;
2801             m1.SetPromoteTo( &amp;WhiteKnight );
2802             moves.Add( m1 );
2803             m1 = m;
2804             m1.SetPromoteTo( &amp;WhiteBishop );
2805             moves.Add( m1 );
2806             m1 = m;
2807             m1.SetPromoteTo( &amp;WhiteRook );
2808             moves.Add( m1 );
2809         }
2810         else
2811         {
2812             Move m1;
2813             m1 = m;
2814             m1.SetPromoteTo( &amp;BlackQueen );
2815             moves.Add( m1 );
2816             m1 = m;
2817             m1.SetPromoteTo( &amp;BlackKnight );
2818             moves.Add( m1 );
2819             m1 = m;
2820             m1.SetPromoteTo( &amp;BlackBishop );
2821             moves.Add( m1 );
2822             m1 = m;
2823             m1.SetPromoteTo( &amp;BlackRook );
2824             moves.Add( m1 );
2825         }
2826     }
2827     else
2828         moves.Add( m );
2829 }
2830 void Pawn::AddEnPassantMove( Move &amp;m, const Square &amp;dest, Moves &amp;moves ) const
2831 {
2832     Pawn *pPawn;
2833     pPawn = GetColor() ? &amp;WhitePawn :&amp;BlackPawn;
2834     m.Dest( dest );
2835     m.Score( pPawn-&gt;PieceValue() );
2836     AddAndPromote( moves, m, false );
2837 }
2838 Moves Pawn::GenerateMoves( const Square &amp;source, const Position &amp;pos ) const
2839 {
2840     Moves moves;
2841     Square dest = source;
2842     Color movingColor = GetColor();
2843     const Board &amp;board = pos.GetBoard();
2844     int sourceJ;
2845     sourceJ = source.J();
2846     const int d = m_Color ? 1 : -1;
2847     const bool bIsPromote = ( ( sourceJ == 1 ) &amp;&amp; ( movingColor == BLACK ) ) ||
2848                             ( ( sourceJ == 6 ) &amp;&amp; ( movingColor == WHITE ) );
2849     Move m( this, source, source );
2850     dest.Change( 0, d );
2851     m.Dest( dest );
2852     if ( dest.IsOnBoard() &amp;&amp; board.IsEmpty( m.Dest() ) )
2853     {
2854         AddAndPromote( moves, m, bIsPromote );
2855         if ( ( ( sourceJ == 1 ) &amp;&amp; ( movingColor == WHITE ) ) ||
2856                 ( ( sourceJ == 6 ) &amp;&amp; ( movingColor == BLACK ) ) )
2857         {
2858             dest.Change( 0, d );
2859             m.Dest( dest );
2860             if ( board.IsEmpty( m.Dest() ) )
2861                 AddAndPromote( moves, m, bIsPromote );
2862         }
2863     }
2864     dest = source.Add( -1, d );
2865     if ( dest.IsOnBoard() &amp;&amp; IsDifferent( dest, board ) )
2866     {
2867         m.Dest( dest );
2868         m.Score( board.Get( dest )-&gt;PieceValue() );
2869         AddAndPromote( moves, m, bIsPromote );
2870     }
2871     dest = source.Add( 1, d );
2872     if ( dest.IsOnBoard() &amp;&amp; IsDifferent( dest, board ) )
2873     {
2874         m.Dest( dest );
2875         m.Score( board.Get( dest )-&gt;PieceValue() );
2876         AddAndPromote( moves, m, bIsPromote );
2877     }
2878     Square enPassant = pos.EnPassant();
2879     if ( enPassant.IsOnBoard() )
2880     {
2881         dest = source.Add( -1, d );
2882         if ( dest == enPassant )
2883             AddEnPassantMove( m, dest, moves );
2884         dest = source.Add( 1, d );
2885         if ( dest == enPassant )
2886             AddEnPassantMove( m, dest, moves );
2887     }
2888     return moves;
2889 }
2890 Moves Knight::GenerateMoves( const Square &amp;source, const Position &amp;pos ) const
2891 {
2892     Move m( this, source, source );
2893     Moves moves;
2894     const Board &amp;board = pos.GetBoard();
2895     moves.TryAttack( m, board, 1, 2 );
2896     moves.TryAttack( m, board, -1, 2 );
2897     moves.TryAttack( m, board, 1, -2 );
2898     moves.TryAttack( m, board, -1, -2 );
2899     moves.TryAttack( m, board, 2, 1 );
2900     moves.TryAttack( m, board, -2, 1 );
2901     moves.TryAttack( m, board, 2, -1 );
2902     moves.TryAttack( m, board, -2, -1 );
2903     return moves;
2904 }
2905 Moves Bishop::GenerateMoves( const Square &amp;source, const Position &amp;pos ) const
2906 {
2907     Moves moves;
2908     Move m( this, source, source );
2909     const Board &amp;board = pos.GetBoard();
2910     moves.TryRayAttack( m, board, 1, 1 );
2911     moves.TryRayAttack( m, board, 1, -1 );
2912     moves.TryRayAttack( m, board, -1, 1 );
2913     moves.TryRayAttack( m, board, -1, -1 );
2914     return moves;
2915 }
2916 Moves Rook::GenerateMoves( const Square &amp;source, const Position &amp;pos ) const
2917 {
2918     Moves moves;
2919     Move m( this, source, source );
2920     const Board &amp;board = pos.GetBoard();
2921     moves.TryRayAttack( m, board, 0, 1 );
2922     moves.TryRayAttack( m, board, 0, -1 );
2923     moves.TryRayAttack( m, board, -1, 0 );
2924     moves.TryRayAttack( m, board, 1, 0 );
2925     return moves;
2926 }
2927 Moves King::GenerateCastlingMoves( const Square &amp;source,
2928                                    const Position &amp;pos ) const
2929 {
2930     Moves moves;
2931     Board board = pos.GetBoard();
2932     if ( pos.GetColorToMove() == WHITE )
2933     {
2934         if ( pos.m_bVirginWhiteKing )
2935         {
2936             if ( pos.m_bVirginA1 &amp;&amp;
2937                     ( board.Get( A1 ) == &amp;WhiteRook ) &amp;&amp;
2938                     ( board.Get( B1 ) == &amp;None ) &amp;&amp;
2939                     ( board.Get( C1 ) == &amp;None ) &amp;&amp;
2940                     ( board.Get( D1 ) == &amp;None )
2941                )
2942             {
2943                 Position nextPos( pos, NullMove );
2944                 nextPos.m_bVirginBlackKing = false;
2945                 nextPos.m_bVirginWhiteKing = false;
2946                 Moves responses = nextPos.GetMoves();
2947                 bool bCanCastle = true;
2948                 for ( auto response : responses )
2949                 {
2950                     if ( ( response.Dest() == C1 ) ||
2951                             ( response.Dest() == D1 ) ||
2952                             ( response.Dest() == E1 ) )
2953                     {
2954                         bCanCastle = false;
2955                         break;
2956                     }
2957                 }
2958                 if ( bCanCastle ) {
2959                     Move m( this, source, C1 );
2960                     moves.Add( m );
2961                 }
2962             }
2963             if ( pos.m_bVirginH1 &amp;&amp;
2964                     ( board.Get( F1 ) == &amp;None ) &amp;&amp;
2965                     ( board.Get( G1 ) == &amp;None ) &amp;&amp;
2966                     ( board.Get( H1 ) == &amp;WhiteRook )
2967                )
2968             {
2969                 Position nextPos( pos, NullMove );
2970                 nextPos.m_bVirginBlackKing = false;
2971                 nextPos.m_bVirginWhiteKing = false;
2972                 Moves responses = nextPos.GetMoves();
2973                 bool bCanCastle = true;
2974                 for ( auto response : responses )
2975                 {
2976                     if ( ( response.Dest() == E1 ) ||
2977                             ( response.Dest() == F1 ) ||
2978                             ( response.Dest() == G1 ) )
2979                     {
2980                         bCanCastle = false;
2981                         break;
2982                     }
2983                 }
2984                 if ( bCanCastle ) {
2985                     Move m( this, source, G1 );
2986                     moves.Add( m );
2987                 }
2988             }
2989         }     }
2990     else
2991     {
2992         if ( pos.m_bVirginBlackKing )
2993         {
2994             if ( pos.m_bVirginA8 &amp;&amp;
2995                     ( board.Get( A8 ) == &amp;BlackRook ) &amp;&amp;
2996                     ( board.Get( B8 ) == &amp;None ) &amp;&amp;
2997                     ( board.Get( C8 ) == &amp;None ) &amp;&amp;
2998                     ( board.Get( D8 ) == &amp;None )
2999                )
3000             {
3001                 Position nextPos( pos, NullMove );
3002                 nextPos.m_bVirginBlackKing = false;
3003                 nextPos.m_bVirginWhiteKing = false;
3004                 Moves responses = nextPos.GetMoves();
3005                 bool bCanCastle = true;
3006                 for ( auto response : responses )
3007                 {
3008                     if ( ( response.Dest() == C8 ) ||
3009                             ( response.Dest() == D8 ) ||
3010                             ( response.Dest() == E8 ) )
3011                     {
3012                         bCanCastle = false;
3013                         break;
3014                     }
3015                 }
3016                 if ( bCanCastle ) {
3017                     Move m( this, source, C8 );
3018                     moves.Add( m );
3019                 }
3020             }
3021             if ( pos.m_bVirginH8 &amp;&amp;
3022                     ( board.Get( F8 ) == &amp;None ) &amp;&amp;
3023                     ( board.Get( G8 ) == &amp;None ) &amp;&amp;
3024                     ( board.Get( H8 ) == &amp;BlackRook )
3025                )
3026             {
3027                 Position nextPos( pos, NullMove );
3028                 nextPos.m_bVirginBlackKing = false;
3029                 nextPos.m_bVirginWhiteKing = false;
3030                 Moves responses = nextPos.GetMoves();
3031                 bool bCanCastle = true;
3032                 for ( auto response : responses )
3033                 {
3034                     if ( ( response.Dest() == E8 ) ||
3035                             ( response.Dest() == F8 ) ||
3036                             ( response.Dest() == G8 ) )
3037                     {
3038                         bCanCastle = false;
3039                         break;
3040                     }
3041                 }
3042                 if ( bCanCastle ) {
3043                     Move m( this, source, G8 );
3044                     moves.Add( m );
3045                 }
3046             }
3047         }     }
3048     return moves;
3049 }
3050 Moves King::GenerateMoves( const Square &amp;source, const Position &amp;pos ) const
3051 {
3052     Move m( this, source, source );
3053     Moves moves;
3054     const Board &amp;board = pos.GetBoard();
3055     moves = GenerateCastlingMoves( source, pos );
3056     moves.TryAttack( m, board, 1, 0 );
3057     moves.TryAttack( m, board, -1, 0 );
3058     moves.TryAttack( m, board, 0, 1 );
3059     moves.TryAttack( m, board, 0, -1 );
3060     moves.TryAttack( m, board, 1, 1 );
3061     moves.TryAttack( m, board, -1, 1 );
3062     moves.TryAttack( m, board, 1, -1 );
3063     moves.TryAttack( m, board, -1, -1 );
3064     return moves;
3065 }
3066 Moves Queen::GenerateMoves( const Square &amp;source, const Position &amp;pos ) const
3067 {
3068     Moves moves;
3069     Move m( this, source, source );
3070     const Board &amp;board = pos.GetBoard();
3071     moves.TryRayAttack( m, board, 1, 1 );
3072     moves.TryRayAttack( m, board, 1, -1 );
3073     moves.TryRayAttack( m, board, -1, 1 );
3074     moves.TryRayAttack( m, board, -1, -1 );
3075     moves.TryRayAttack( m, board, 0, 1 );
3076     moves.TryRayAttack( m, board, 0, -1 );
3077     moves.TryRayAttack( m, board, -1, 0 );
3078     moves.TryRayAttack( m, board, 1, 0 );
3079     return moves;
3080 }
3081 class Game : Object
3082 {
3083 public:
3084     void New()
3085     {
3086         m_Position.Setup();
3087     }
3088     Position *GetPosition()
3089     {
3090         return &amp;m_Position;
3091     }
3092     void SetPosition( Position &amp;pos )
3093     {
3094         m_Position = pos;
3095     }
3096 protected:
3097     friend class Interface;
3098     Position m_Position;
3099 };
3100 class Interface;
3101 Interface *s_pDefaultInterface = NULL;
3102 class Interface : Object
3103 {
3104 public:
3105     enum ProtocolType
3106     {
3107         PROTOCOL_XBOARD,
3108         PROTOCOL_UCI
3109     };
3110     Interface( istream *in = &amp;cin, ostream *out = &amp;cout ) :
3111         m_In( in ),
3112         m_Out( out ),
3113         m_Protocol( PROTOCOL_UCI ),
3114         m_Protover( 1 ),
3115         m_bShowThinking( false ),
3116         m_bPonder( false ),
3117         m_bLogInputToFile( false ),
3118         m_pGame( new Game ),
3119         m_bIsRunning( true )
3120     {
3121         m_pSearcher = shared_ptr&lt;Searcher&gt; ( new Searcher( *this ) );
3122         s_pDefaultInterface = this;
3123     }
3124     ~Interface()
3125     {
3126     }
3127     void LogLineToFile( const string &amp;line )
3128     {
3129 #ifdef WIN32
3130         const char *sFileName = "c:\\temp\\superpawn.log";
3131         string outLine = line;
3132         outLine.append( "\n" );
3133         FILE *fp;
3134         fopen_s( &amp;fp, sFileName, "a" );
3135         fwrite( line.c_str(), sizeof( char ), outLine.length(), fp );
3136         fclose( fp );
3137 #endif
3138     }
3139     ostream *GetOut() const
3140     {
3141         return m_Out;
3142     }
3143     void SetOut( ostream *val )
3144     {
3145         m_Out = val;
3146     }
3147     istream *GetIn() const
3148     {
3149         return m_In;
3150     }
3151     void SetIn( istream *val )
3152     {
3153         m_In = val;
3154     }
3155     void AnnounceSelf()
3156     {
3157         {
3158             stringstream ss;
3159             ss &lt;&lt; "Superpawn " &lt;&lt; BUILD_BRANCH &lt;&lt; " number " &lt;&lt; BUILD_NUMBER &lt;&lt;
3160                ", build ID " &lt;&lt; BUILD_ID;
3161             Notify( ss.str() );
3162         }
3163         {
3164             stringstream ss;
3165             ss &lt;&lt; "Superpawn built on " &lt;&lt; __DATE__ &lt;&lt; " " &lt;&lt; __TIME__;
3166             Notify( ss.str() );
3167         }
3168         {
3169             stringstream ss;
3170             ss &lt;&lt; "For more info: " &lt;&lt; WEB_URL;
3171             Notify( ss.str() );
3172         }
3173     }
3174     void Run()
3175     {
3176         m_Out-&gt;setf( ios::unitbuf );
3177         string sInputLine;
3178         RegisterAll();
3179         AnnounceSelf();
3180         while ( m_bIsRunning )
3181         {
3182             getline( *m_In, sInputLine );
3183             if ( m_bLogInputToFile )
3184                 LogLineToFile( sInputLine );
3185             LockGuardType guard( m_Lock );
3186             Execute( sInputLine );
3187         }
3188     }
3189     typedef lock_guard&lt;mutex&gt; LockGuardType;
3190     mutex &amp;GetLock()
3191     {
3192         return m_Lock;
3193     }
3194     INTERFACE_PROTOTYPE( Notify )
3195     {
3196         switch ( m_Protocol )
3197         {
3198         case PROTOCOL_XBOARD:
3199             ( *m_Out ) &lt;&lt; "# " &lt;&lt; sParams &lt;&lt; endl;
3200             break;
3201         default:
3202         case PROTOCOL_UCI:
3203             ( *m_Out ) &lt;&lt; "info string " &lt;&lt; sParams &lt;&lt; endl;
3204             break;
3205         }
3206     }
3207     INTERFACE_PROTOTYPE( Instruct )
3208     {
3209         ( *m_Out ) &lt;&lt; sParams &lt;&lt; endl;
3210     }
3211     INTERFACE_PROTOTYPE( Bestmove )
3212     {
3213         stringstream ss;
3214         ss &lt;&lt; "bestmove " &lt;&lt; sParams;
3215         Instruct( ss.str() );
3216     }
3217 protected:
3218     void RegisterCommand( const string &amp;sCommand,
3219                           INTERFACE_FUNCTION_TYPE( pfnCommand ) )
3220     {
3221         m_CommandMap[ sCommand ] = pfnCommand;
3222     };
3223     void RegisterAll()
3224     {
3225         RegisterCommand( "uci",     &amp;Interface::UCI );
3226         RegisterCommand( "quit",    &amp;Interface::Quit );
3227         RegisterCommand( "testone", &amp;Interface::TestOne );
3228         RegisterCommand( "test",  &amp;Interface::Test );
3229     }
3230     INTERFACE_PROTOTYPE( UCI )
3231     {
3232         RegisterUCI( sParams );
3233         Instruct( "id name Superpawn" );
3234         Instruct( "id author John Byrd" );
3235         Instruct( "option name Hash type spin default 128 min 1 max 2048" );
3236         Instruct( "option name UCI_EngineAbout type string default " WEB_URL );
3237         string none;
3238         New( none );
3239         Instruct( "uciok" );
3240     }
3241     INTERFACE_PROTOTYPE_NO_PARAMS( RegisterUCI )
3242     {
3243         m_Protocol = PROTOCOL_UCI;
3244         RegisterCommand( "debug",       &amp;Interface::DebugUCI );
3245         RegisterCommand( "isready",     &amp;Interface::IsReady );
3246         RegisterCommand( "setoption",   &amp;Interface::SetOption );
3247         RegisterCommand( "ucinewgame",  &amp;Interface::New );
3248         RegisterCommand( "position",    &amp;Interface::UCIPosition );
3249         RegisterCommand( "go",          &amp;Interface::UCIGo );
3250         RegisterCommand( "stop",        &amp;Interface::Stop );
3251         RegisterCommand( "ponderhit",   &amp;Interface::Ponderhit );
3252     }
3253     INTERFACE_PROTOTYPE_NO_PARAMS( DebugUCI )
3254     {
3255         Notify( "DebugUCI not yet implemented" );
3256     }
3257     INTERFACE_PROTOTYPE_NO_PARAMS( IsReady )
3258     {
3259         Instruct( "readyok" );
3260     }
3261     INTERFACE_PROTOTYPE( SetOption )
3262     {
3263         stringstream ss( sParams );
3264         string sParam, sName;
3265         size_t nValue = 1;
3266         while ( ss &gt;&gt; sParam )
3267         {
3268             if ( sParam == "name" )
3269                 ss &gt;&gt; sName;
3270             else if ( sParam == "value" )
3271                 ss &gt;&gt; nValue;
3272             else
3273             {
3274                 stringstream sfail;
3275                 sfail &lt;&lt; "Unrecognized SetOption parameter: " &lt;&lt; sParam;
3276                 Notify( sfail.str() );
3277             }
3278         }
3279         if ( !sName.empty() )
3280         {
3281             if ( sName == "Hash" )
3282                 s_pPositionHashTable-&gt;SetSize( nValue * 1024 * 1024 );
3283         }
3284         else
3285             Notify( "SetOption: Could not find name of the option to set" );
3286     }
3287     INTERFACE_PROTOTYPE( TestOne )
3288     {
3289         UCIPosition( sParams );
3290         UCIGo( "wtime 30000 btime 30000 winc 0 binc 0 movestogo 1" );
3291         do {
3292             chrono::milliseconds delay( 500 );
3293             this_thread::sleep_for( delay );
3294         } while ( m_pSearcher-&gt;IsRunning() );
3295     }
3296     INTERFACE_PROTOTYPE_NO_PARAMS( Test )
3297     {
3298         TestOne( "startpos moves d2d4 c7c6 e2e4 f7f6 b1c3 e7e5 d4e5 f6e5 d1h5 e8e7 h5e5 e7f7 f1c4 "
3299                  "d7d5 e4d5 f8d6 d5c6 f7g6 c4d3 g6f7 d3c4 f7g6 c4d3 g6f7" );
3300         TestOne( "startpos moves c2c4 g8f6 g1f3 e7e6 b1c3 f8b4 a2a3 b4c3 d2c3 e8g8 c1g5 "
3301                  "d7d5 g5f6 g7f6 c4d5 e6d5 d1b3 b7b6 e1c1 c8e6 b3c2 b8d7 e2e3 d7e5 e3e4 d8d6 f1e2 "
3302                  "a8d8 f3e1 e5c6 e4d5 e6d5 e2d3 d6f4 d1d2 f4h6 f2f4 b6b5 d3b5 h6f4 h1f1 f4g5 b5c6 "
3303                  "d5c6 c2d1 c6b5 f1f2 c7c5 e1f3 g5e3 d1e1 e3e1 f3e1 d8d2 c1d2 f8d8 d2c2 c5c4 f2d2 "
3304                  "d8e8 e1f3 b5c6 f3d4 c6a4 c2b1 a4b3 d4b3 c4b3 b1c1 e8e1 d2d1 e1e2 d1d8 g8g7 d8d2 "
3305                  "e2e1 d2d1 e1e2 d1g1 f6f5 c1b1 g7f6 b1c1 f6e5 h2h3 a7a5 c1b1 f5f4 a3a4 e2e4 b1c1 "
3306                  "e4a4 g1e1 a4e4 c1d2 e4e1 d2e1 a5a4 e1d2 e5e4 h3h4 h7h5 c3c4 e4d4 c4c5 d4c5 d2c3 "
3307                  "c5b5 c3d2 b5b4 d2d3 a4a3 b2a3 b4a3 d3e4 b3b2 e4f4 b2b1q f4f3 b1f1 f3g3 f1f5 g3h2 "
3308                  "f5f2 h2h3 f2e3 h3h2 e3f2 h2h3 f2f4 g2g3 f4f2 g3g4 f2f3 h3h2 f3g4 h2h1 a3a4 h1h2 "
3309                  "a4a3 h2h1 a3a2 h1h2 a2b2 h2h1 b2a2 h1h2 a2a1 h2h1 a1b2 h1h2 b2b3 h2h1" );
3310         TestOne( "startpos moves e2e4 d7d5 e4d5 d8d5 c2c4 d5e4 f1e2 e4g2 e2f3 g2g6 d1b3 "
3311                  "g6a6 c4c5 e7e5 f3e2 a6a5 b3d5 b8c6 b2b4 a5b4 e2h5 g7g6 h5f3 b4d4 d5d4 c6d4 f3d1 "
3312                  "f8c5 c1b2 g8f6 g1f3 d4f3 d1f3 c5d4 b2d4 e5d4 h1g1 e8g8 g1g5 h7h6 g5c5 f8e8 e1d1 "
3313                  "c8g4 f3g4 f6g4 d1c2 g4f2 c5c4 d4d3 c2b3 a8c8 c4f4 f2e4 b3c4 c8d8 f4h4 g6g5 h4h3 "
3314                  "e8e6 a2a4 e6c6 c4b3 c6a6 b3a3" );
3315     }
3316     INTERFACE_PROTOTYPE( UCIGo )
3317     {
3318         stringstream ss( sParams );
3319         string sParam;
3320         Director director;
3321         while ( ss &gt;&gt; sParam )
3322         {
3323             if ( sParam == "depth" )
3324             {
3325                 int depth;
3326                 ss &gt;&gt; depth;
3327                 director.m_nDepth = depth;
3328                 continue;
3329             }
3330             else if ( sParam == "wtime" )
3331             {
3332                 int wtime;
3333                 ss &gt;&gt; wtime;
3334                 director.m_WhiteTime = wtime;
3335                 continue;
3336             }
3337             else if ( sParam == "btime" )
3338             {
3339                 int btime;
3340                 ss &gt;&gt; btime;
3341                 director.m_BlackTime = btime;
3342                 continue;
3343             }
3344             else if ( sParam == "winc" )
3345             {
3346                 int winc;
3347                 ss &gt;&gt; winc;
3348                 director.m_WhiteInc = winc;
3349                 continue;
3350             }
3351             else if ( sParam == "binc" )
3352             {
3353                 int binc;
3354                 ss &gt;&gt; binc;
3355                 director.m_BlackInc = binc;
3356                 continue;
3357             }
3358             else if ( sParam == "movestogo" )
3359             {
3360                 unsigned int movestogo;
3361                 ss &gt;&gt; movestogo;
3362                 director.m_nMovesToGo = movestogo;
3363                 continue;
3364             }
3365             else if ( sParam == "nodes" )
3366             {
3367                 unsigned int nodes;
3368                 ss &gt;&gt; nodes;
3369                 director.m_nNodes = nodes;
3370                 continue;
3371             }
3372             else if ( sParam == "mate" )
3373             {
3374                 unsigned int mate;
3375                 ss &gt;&gt; mate;
3376                 director.m_nMateInMoves = mate;
3377                 continue;
3378             }
3379             else if ( sParam == "movetime" )
3380             {
3381                 unsigned int movetime;
3382                 ss &gt;&gt; movetime;
3383                 director.m_nMoveTime = movetime;
3384                 continue;
3385             }
3386             else if ( sParam == "infinite" )
3387             {
3388                 director.m_bInfinite = true;
3389                 continue;
3390             }
3391             else
3392             {
3393                 stringstream ssfail;
3394                 ssfail &lt;&lt; "Unknown go parameter: ";
3395                 ssfail &lt;&lt; sParam;
3396                 Notify( ssfail.str() );
3397                 break;
3398             }
3399         };
3400         s_pPositionHashTable-&gt;Purge();
3401         m_pSearcher-&gt;SetDirector( director );
3402         m_pSearcher-&gt;Start( * ( m_pGame-&gt;GetPosition() ) );
3403     }
3404     INTERFACE_PROTOTYPE( UCIPosition )
3405     {
3406         stringstream ss( sParams );
3407         string sType;
3408         while ( ss &gt;&gt; sType )
3409         {
3410             if ( sType == "fen" )
3411             {
3412                 string sArg, sFen;
3413                 const int fenArgs = 6;
3414                 for ( int t = 0; t &lt; fenArgs; t++ )
3415                 {
3416                     ss &gt;&gt; sArg;
3417                     if ( t != 0 )
3418                         sFen.append( " " );
3419                     sFen.append( sArg );
3420                 }
3421                 Position pos;
3422                 pos.SetFEN( sFen );
3423                 m_pGame-&gt;SetPosition( pos );
3424                 Notify( "New position: " );
3425                 Notify( sFen );
3426             }
3427             if ( sType == "startpos" )
3428                 m_pGame-&gt;New();
3429             if ( sType == "moves" )
3430             {
3431                 string sMove;
3432                 while ( ss &gt;&gt; sMove )
3433                 {
3434                     Position *pLast = m_pGame-&gt;GetPosition();
3435                     Move nextMove( sMove, pLast-&gt;GetColorToMove() );
3436                     Position nextPos( *pLast, nextMove );
3437                     m_pGame-&gt;SetPosition( nextPos );
3438                 }
3439             }
3440         }
3441     }
3442     INTERFACE_PROTOTYPE_NO_PARAMS( New )
3443     {
3444         m_pGame-&gt;New();
3445     }
3446     INTERFACE_PROTOTYPE_NO_PARAMS( Stop )
3447     {
3448         m_pSearcher-&gt;Stop();
3449     }
3450     INTERFACE_PROTOTYPE_NO_PARAMS( Ponderhit )
3451     {
3452         Notify( "Ponderhit not yet implemented" );
3453     }
3454     INTERFACE_PROTOTYPE_NO_PARAMS( Quit )
3455     {
3456         Notify( "Engine exiting" );
3457         m_pSearcher-&gt;Stop();
3458         m_bIsRunning = false;
3459     }
3460     int TimeToSeconds( const string &amp;sTime )
3461     {
3462         size_t nColon = 0;
3463         int nMinutes = 0, nSeconds = 0;
3464         nColon = sTime.find( ':' );
3465         if ( nColon == string::npos )
3466         {
3467             stringstream ss;
3468             ss.str( sTime );
3469             ss &gt;&gt; nMinutes;
3470         }
3471         else
3472         {
3473             stringstream sMin, sSec;
3474             sMin.str( sTime.substr( 0, nColon ) );
3475             sSec.str( sTime.substr( nColon + 1 ) );
3476             sMin &gt;&gt; nMinutes;
3477             sSec &gt;&gt; nSeconds;
3478         }
3479         return ( nMinutes * 60 + nSeconds );
3480     }
3481     void Execute( const string &amp;sCommand )
3482     {
3483         string sParams, sVerb;
3484         stringstream ss;
3485         ss.str( sCommand );
3486         ss &gt;&gt; sVerb;
3487         if ( sVerb.length() &lt; sCommand.length() )
3488             sParams = sCommand.substr( sVerb.length() + 1, MAX_COMMAND_LENGTH );
3489         InterfaceFunctionType ic = m_CommandMap[ sVerb ];
3490         if ( ic )
3491             ( this-&gt;*ic )( sParams );
3492         else
3493         {
3494             stringstream unk;
3495             unk &lt;&lt; "Unknown command: " &lt;&lt; sCommand ;
3496             Notify( unk.str() );
3497         }
3498     }
3499 protected:
3500     istream *m_In;
3501     ostream *m_Out;
3502     mutex m_Lock;
3503     Moves m_PrincipalVariation;
3504     ProtocolType m_Protocol;
3505     int m_Protover;
3506     bool m_bShowThinking;
3507     bool m_bPonder;
3508     bool m_bLogInputToFile;
3509     shared_ptr&lt;Game&gt; m_pGame;
3510     shared_ptr&lt;Searcher&gt; m_pSearcher;
3511     bool m_bIsRunning;
3512 protected:
3513     unordered_map&lt;string, InterfaceFunctionType&gt; m_CommandMap;
3514 };
3515 void Die( const string &amp;s )
3516 {
3517     bool bAbortOnDie = true;
3518     if ( s_pDefaultInterface )
3519         s_pDefaultInterface-&gt;Notify( s );
3520     if ( bAbortOnDie )
3521         abort();
3522 }
3523 void DirectorBase::Notify( const string &amp;s )
3524 {
3525     m_pInterface-&gt;Notify( s );
3526 }
3527 void SearcherBase::Notify( const string &amp;s ) const
3528 {
3529     m_pInterface-&gt;Notify( s );
3530 }
3531 void SearcherBase::Instruct( const string &amp;s ) const
3532 {
3533     m_pInterface-&gt;Instruct( s );
3534 }
3535 void SearcherBase::Bestmove( const string &amp;s ) const
3536 {
3537     m_pInterface-&gt;Bestmove( s );
3538 }
3539 int main( int , char ** )
3540 {
3541     Clock c;
3542     PieceInitializer pieceInitializer;
3543     PieceSquareTableInitializer pieceSquareTableInitializer;
3544     HashInitializer hashInitializer;
3545     HashTableInitializer hashTableInitializer;
3546     Interface i;
3547     i.Run();
3548     return 0;
3549 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
