<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for unsynchronizedlyricsframe.cpp &amp; chapterframe.cpp</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for unsynchronizedlyricsframe.cpp &amp; chapterframe.cpp
      </h3>
<h1 align="center">
        11.5%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>unsynchronizedlyricsframe.cpp (16.556292%)<th>chapterframe.cpp (8.896797%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(125-144)<td><a href="#" name="0">(223-243)</a><td align="center"><font color="#ff0000">25</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>unsynchronizedlyricsframe.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include "unsynchronizedlyricsframe.h"
#include &lt;tbytevectorlist.h&gt;
#include &lt;id3v2tag.h&gt;
#include &lt;tdebug.h&gt;
#include &lt;tpropertymap.h&gt;
using namespace TagLib;
using namespace ID3v2;
class UnsynchronizedLyricsFrame::UnsynchronizedLyricsFramePrivate
{
public:
  UnsynchronizedLyricsFramePrivate() : textEncoding(String::Latin1) {}
  String::Type textEncoding;
  ByteVector language;
  String description;
  String text;
};
UnsynchronizedLyricsFrame::UnsynchronizedLyricsFrame(String::Type encoding) :
  Frame("USLT"),
  d(new UnsynchronizedLyricsFramePrivate())
{
  d-&gt;textEncoding = encoding;
}
UnsynchronizedLyricsFrame::UnsynchronizedLyricsFrame(const ByteVector &amp;data) :
  Frame(data),
  d(new UnsynchronizedLyricsFramePrivate())
{
  setData(data);
}
UnsynchronizedLyricsFrame::~UnsynchronizedLyricsFrame()
{
  delete d;
}
String UnsynchronizedLyricsFrame::toString() const
{
  return d-&gt;text;
}
ByteVector UnsynchronizedLyricsFrame::language() const
{
  return d-&gt;language;
}
String UnsynchronizedLyricsFrame::description() const
{
  return d-&gt;description;
}
String UnsynchronizedLyricsFrame::text() const
{
  return d-&gt;text;
}
void UnsynchronizedLyricsFrame::setLanguage(const ByteVector &amp;languageEncoding)
{
  d-&gt;language = languageEncoding.mid(0, 3);
}
void UnsynchronizedLyricsFrame::setDescription(const String &amp;s)
{
  d-&gt;description = s;
}
void UnsynchronizedLyricsFrame::setText(const String &amp;s)
{
  d-&gt;text = s;
}
String::Type UnsynchronizedLyricsFrame::textEncoding() const
{
  return d-&gt;textEncoding;
}
void UnsynchronizedLyricsFrame::setTextEncoding(String::Type encoding)
{
  d-&gt;textEncoding = encoding;
}
PropertyMap UnsynchronizedLyricsFrame::asProperties() const
{
  PropertyMap map;
  String key = description().upper();
  if(key.isEmpty() || key == "LYRICS")
<a name="0"></a>    map.insert("LYRICS", text());
  else
    map.insert("LYRICS:" + key, text());
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  return map;
}
UnsynchronizedLyricsFrame *UnsynchronizedLyricsFrame::findByDescription(const ID3v2::Tag *tag, const String &amp;d) {
  ID3v2::FrameList lyrics = tag-&gt;frameList("USLT");
  for(ID3v2::FrameList::ConstIterator it = lyrics.begin(); it != lyrics.end(); ++it){
    UnsynchronizedLyricsFrame *frame = dynamic_cast&lt;UnsynchronizedLyricsFrame *&gt;(*it);
    if(frame &amp;&amp; frame-&gt;description() == d)
      return frame;
  }
  return 0;
}
void UnsynchronizedLyricsFrame::parseFields(const ByteVector &amp;data)
{</b></font>
  if(data.size() &lt; 5) {
    debug("An unsynchronized lyrics frame must contain at least 5 bytes.");
    return;
  }
  d-&gt;textEncoding = String::Type(data[0]);
  d-&gt;language = data.mid(1, 3);
  int byteAlign
    = d-&gt;textEncoding == String::Latin1 || d-&gt;textEncoding == String::UTF8 ? 1 : 2;
  ByteVectorList l =
    ByteVectorList::split(data.mid(4), textDelimiter(d-&gt;textEncoding), byteAlign, 2);
  if(l.size() == 2) {
    if(d-&gt;textEncoding == String::Latin1) {
      d-&gt;description = Tag::latin1StringHandler()-&gt;parse(l.front());
      d-&gt;text = Tag::latin1StringHandler()-&gt;parse(l.back());
    } else {
      d-&gt;description = String(l.front(), d-&gt;textEncoding);
      d-&gt;text = String(l.back(), d-&gt;textEncoding);
    }
  }
}
ByteVector UnsynchronizedLyricsFrame::renderFields() const
{
  StringList sl;
  sl.append(d-&gt;description);
  sl.append(d-&gt;text);
  const String::Type encoding = checkTextEncoding(sl, d-&gt;textEncoding);
  ByteVector v;
  v.append(char(encoding));
  v.append(d-&gt;language.size() == 3 ? d-&gt;language : "XXX");
  v.append(d-&gt;description.data(encoding));
  v.append(textDelimiter(encoding));
  v.append(d-&gt;text.data(encoding));
  return v;
}
UnsynchronizedLyricsFrame::UnsynchronizedLyricsFrame(const ByteVector &amp;data, Header *h) :
  Frame(h),
  d(new UnsynchronizedLyricsFramePrivate())
{
  parseFields(fieldData(data));
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>chapterframe.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include &lt;tbytevectorlist.h&gt;
#include &lt;tpropertymap.h&gt;
#include &lt;tdebug.h&gt;
#include &lt;stdio.h&gt;
#include "chapterframe.h"
using namespace TagLib;
using namespace ID3v2;
class ChapterFrame::ChapterFramePrivate
{
public:
  ChapterFramePrivate() :
    tagHeader(0),
    startTime(0),
    endTime(0),
    startOffset(0),
    endOffset(0)
  {
    embeddedFrameList.setAutoDelete(true);
  }
  const ID3v2::Header *tagHeader;
  ByteVector elementID;
  unsigned int startTime;
  unsigned int endTime;
  unsigned int startOffset;
  unsigned int endOffset;
  FrameListMap embeddedFrameListMap;
  FrameList embeddedFrameList;
};
ChapterFrame::ChapterFrame(const ID3v2::Header *tagHeader, const ByteVector &amp;data) :
  ID3v2::Frame(data),
  d(new ChapterFramePrivate())
{
  d-&gt;tagHeader = tagHeader;
  setData(data);
}
ChapterFrame::ChapterFrame(const ByteVector &amp;elementID,
                           unsigned int startTime, unsigned int endTime,
                           unsigned int startOffset, unsigned int endOffset,
                           const FrameList &amp;embeddedFrames) :
  ID3v2::Frame("CHAP"),
  d(new ChapterFramePrivate())
{
  setElementID(elementID);
  d-&gt;startTime = startTime;
  d-&gt;endTime = endTime;
  d-&gt;startOffset = startOffset;
  d-&gt;endOffset = endOffset;
  for(FrameList::ConstIterator it = embeddedFrames.begin();
      it != embeddedFrames.end(); ++it)
    addEmbeddedFrame(*it);
}
ChapterFrame::~ChapterFrame()
{
  delete d;
}
ByteVector ChapterFrame::elementID() const
{
  return d-&gt;elementID;
}
unsigned int ChapterFrame::startTime() const
{
  return d-&gt;startTime;
}
unsigned int ChapterFrame::endTime() const
{
  return d-&gt;endTime;
}
unsigned int ChapterFrame::startOffset() const
{
  return d-&gt;startOffset;
}
unsigned int ChapterFrame::endOffset() const
{
  return d-&gt;endOffset;
}
void ChapterFrame::setElementID(const ByteVector &amp;eID)
{
  d-&gt;elementID = eID;
  if(d-&gt;elementID.endsWith(char(0)))
    d-&gt;elementID = d-&gt;elementID.mid(0, d-&gt;elementID.size() - 1);
}
void ChapterFrame::setStartTime(const unsigned int &amp;sT)
{
  d-&gt;startTime = sT;
}
void ChapterFrame::setEndTime(const unsigned int &amp;eT)
{
  d-&gt;endTime = eT;
}
void ChapterFrame::setStartOffset(const unsigned int &amp;sO)
{
  d-&gt;startOffset = sO;
}
void ChapterFrame::setEndOffset(const unsigned int &amp;eO)
{
  d-&gt;endOffset = eO;
}
const FrameListMap &amp;ChapterFrame::embeddedFrameListMap() const
{
  return d-&gt;embeddedFrameListMap;
}
const FrameList &amp;ChapterFrame::embeddedFrameList() const
{
  return d-&gt;embeddedFrameList;
}
const FrameList &amp;ChapterFrame::embeddedFrameList(const ByteVector &amp;frameID) const
{
  return d-&gt;embeddedFrameListMap[frameID];
}
void ChapterFrame::addEmbeddedFrame(Frame *frame)
{
  d-&gt;embeddedFrameList.append(frame);
  d-&gt;embeddedFrameListMap[frame-&gt;frameID()].append(frame);
}
void ChapterFrame::removeEmbeddedFrame(Frame *frame, bool del)
{
  FrameList::Iterator it = d-&gt;embeddedFrameList.find(frame);
  d-&gt;embeddedFrameList.erase(it);
  it = d-&gt;embeddedFrameListMap[frame-&gt;frameID()].find(frame);
  d-&gt;embeddedFrameListMap[frame-&gt;frameID()].erase(it);
  if(del)
    delete frame;
}
void ChapterFrame::removeEmbeddedFrames(const ByteVector &amp;id)
{
  FrameList l = d-&gt;embeddedFrameListMap[id];
  for(FrameList::ConstIterator it = l.begin(); it != l.end(); ++it)
    removeEmbeddedFrame(*it, true);
}
String ChapterFrame::toString() const
{
  String s = String(d-&gt;elementID) +
             ": start time: " + String::number(d-&gt;startTime) +
             ", end time: " + String::number(d-&gt;endTime);
  if(d-&gt;startOffset != 0xFFFFFFFF)
    s += ", start offset: " + String::number(d-&gt;startOffset);
  if(d-&gt;endOffset != 0xFFFFFFFF)
    s += ", end offset: " + String::number(d-&gt;endOffset);
  if(!d-&gt;embeddedFrameList.isEmpty()) {
    StringList frameIDs;
    for(FrameList::ConstIterator it = d-&gt;embeddedFrameList.begin();
        it != d-&gt;embeddedFrameList.end(); ++it)
      frameIDs.append((*it)-&gt;frameID());
    s += ", sub-frames: [ " + frameIDs.toString(", ") + " ]";
  }
  return s;
}
PropertyMap ChapterFrame::asProperties() const
{
  PropertyMap map;
<a name="0"></a>
  map.unsupportedData().append(frameID() + String("/") + d-&gt;elementID);
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  return map;
}
ChapterFrame *ChapterFrame::findByElementID(const ID3v2::Tag *tag, const ByteVector &amp;eID) {
  ID3v2::FrameList comments = tag-&gt;frameList("CHAP");
  for(ID3v2::FrameList::ConstIterator it = comments.begin();
      it != comments.end();
      ++it)
  {
    ChapterFrame *frame = dynamic_cast&lt;ChapterFrame *&gt;(*it);
    if(frame &amp;&amp; frame-&gt;elementID() == eID)
      return frame;
  }
  return 0;
}
void ChapterFrame::parseFields(const ByteVector &amp;data)
{</b></font>
  unsigned int size = data.size();
  if(size &lt; 18) {
    debug("A CHAP frame must contain at least 18 bytes (1 byte element ID "
          "terminated by null and 4x4 bytes for start and end time and offset).");
    return;
  }
  int pos = 0;
  unsigned int embPos = 0;
  d-&gt;elementID = readStringField(data, String::Latin1, &amp;pos).data(String::Latin1);
  d-&gt;startTime = data.toUInt(pos, true);
  pos += 4;
  d-&gt;endTime = data.toUInt(pos, true);
  pos += 4;
  d-&gt;startOffset = data.toUInt(pos, true);
  pos += 4;
  d-&gt;endOffset = data.toUInt(pos, true);
  pos += 4;
  size -= pos;
  if(size &lt; header()-&gt;size())
    return;
  while(embPos &lt; size - header()-&gt;size()) {
    Frame *frame = FrameFactory::instance()-&gt;createFrame(data.mid(pos + embPos), d-&gt;tagHeader);
    if(!frame)
      return;
    if(frame-&gt;size() &lt;= 0) {
      delete frame;
      return;
    }
    embPos += frame-&gt;size() + header()-&gt;size();
    addEmbeddedFrame(frame);
  }
}
ByteVector ChapterFrame::renderFields() const
{
  ByteVector data;
  data.append(d-&gt;elementID);
  data.append('\0');
  data.append(ByteVector::fromUInt(d-&gt;startTime, true));
  data.append(ByteVector::fromUInt(d-&gt;endTime, true));
  data.append(ByteVector::fromUInt(d-&gt;startOffset, true));
  data.append(ByteVector::fromUInt(d-&gt;endOffset, true));
  FrameList l = d-&gt;embeddedFrameList;
  for(FrameList::ConstIterator it = l.begin(); it != l.end(); ++it)
    data.append((*it)-&gt;render());
  return data;
}
ChapterFrame::ChapterFrame(const ID3v2::Header *tagHeader, const ByteVector &amp;data, Header *h) :
  Frame(h),
  d(new ChapterFramePrivate())
{
  d-&gt;tagHeader = tagHeader;
  parseFields(fieldData(data));
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
