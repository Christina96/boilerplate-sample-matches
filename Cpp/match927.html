<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for unsynchronizedlyricsframe.cpp &amp; chapterframe.cpp</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for unsynchronizedlyricsframe.cpp &amp; chapterframe.cpp
      </h3>
<h1 align="center">
        11.5%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>unsynchronizedlyricsframe.cpp (16.556292%)<th>chapterframe.cpp (8.896797%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(125-144)<td><a href="#" name="0">(223-243)</a><td align="center"><font color="#ff0000">25</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>unsynchronizedlyricsframe.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "unsynchronizedlyricsframe.h"
2 #include &lt;tbytevectorlist.h&gt;
3 #include &lt;id3v2tag.h&gt;
4 #include &lt;tdebug.h&gt;
5 #include &lt;tpropertymap.h&gt;
6 using namespace TagLib;
7 using namespace ID3v2;
8 class UnsynchronizedLyricsFrame::UnsynchronizedLyricsFramePrivate
9 {
10 public:
11   UnsynchronizedLyricsFramePrivate() : textEncoding(String::Latin1) {}
12   String::Type textEncoding;
13   ByteVector language;
14   String description;
15   String text;
16 };
17 UnsynchronizedLyricsFrame::UnsynchronizedLyricsFrame(String::Type encoding) :
18   Frame("USLT"),
19   d(new UnsynchronizedLyricsFramePrivate())
20 {
21   d-&gt;textEncoding = encoding;
22 }
23 UnsynchronizedLyricsFrame::UnsynchronizedLyricsFrame(const ByteVector &amp;data) :
24   Frame(data),
25   d(new UnsynchronizedLyricsFramePrivate())
26 {
27   setData(data);
28 }
29 UnsynchronizedLyricsFrame::~UnsynchronizedLyricsFrame()
30 {
31   delete d;
32 }
33 String UnsynchronizedLyricsFrame::toString() const
34 {
35   return d-&gt;text;
36 }
37 ByteVector UnsynchronizedLyricsFrame::language() const
38 {
39   return d-&gt;language;
40 }
41 String UnsynchronizedLyricsFrame::description() const
42 {
43   return d-&gt;description;
44 }
45 String UnsynchronizedLyricsFrame::text() const
46 {
47   return d-&gt;text;
48 }
49 void UnsynchronizedLyricsFrame::setLanguage(const ByteVector &amp;languageEncoding)
50 {
51   d-&gt;language = languageEncoding.mid(0, 3);
52 }
53 void UnsynchronizedLyricsFrame::setDescription(const String &amp;s)
54 {
55   d-&gt;description = s;
56 }
57 void UnsynchronizedLyricsFrame::setText(const String &amp;s)
58 {
59   d-&gt;text = s;
60 }
61 String::Type UnsynchronizedLyricsFrame::textEncoding() const
62 {
63   return d-&gt;textEncoding;
64 }
65 void UnsynchronizedLyricsFrame::setTextEncoding(String::Type encoding)
66 {
67   d-&gt;textEncoding = encoding;
68 }
69 PropertyMap UnsynchronizedLyricsFrame::asProperties() const
70 {
71   PropertyMap map;
72   String key = description().upper();
73   if(key.isEmpty() || key == "LYRICS")
74 <a name="0"></a>    map.insert("LYRICS", text());
75   else
76     map.insert("LYRICS:" + key, text());
77 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  return map;
78 }
79 UnsynchronizedLyricsFrame *UnsynchronizedLyricsFrame::findByDescription(const ID3v2::Tag *tag, const String &amp;d) {
80   ID3v2::FrameList lyrics = tag-&gt;frameList("USLT");
81   for(ID3v2::FrameList::ConstIterator it = lyrics.begin(); it != lyrics.end(); ++it){
82     UnsynchronizedLyricsFrame *frame = dynamic_cast&lt;UnsynchronizedLyricsFrame *&gt;(*it);
83     if(frame &amp;&amp; frame-&gt;description() == d)
84       return frame;
85   }
86   return 0;
87 }
88 void UnsynchronizedLyricsFrame::parseFields(const ByteVector &amp;data)
89 {</b></font>
90   if(data.size() &lt; 5) {
91     debug("An unsynchronized lyrics frame must contain at least 5 bytes.");
92     return;
93   }
94   d-&gt;textEncoding = String::Type(data[0]);
95   d-&gt;language = data.mid(1, 3);
96   int byteAlign
97     = d-&gt;textEncoding == String::Latin1 || d-&gt;textEncoding == String::UTF8 ? 1 : 2;
98   ByteVectorList l =
99     ByteVectorList::split(data.mid(4), textDelimiter(d-&gt;textEncoding), byteAlign, 2);
100   if(l.size() == 2) {
101     if(d-&gt;textEncoding == String::Latin1) {
102       d-&gt;description = Tag::latin1StringHandler()-&gt;parse(l.front());
103       d-&gt;text = Tag::latin1StringHandler()-&gt;parse(l.back());
104     } else {
105       d-&gt;description = String(l.front(), d-&gt;textEncoding);
106       d-&gt;text = String(l.back(), d-&gt;textEncoding);
107     }
108   }
109 }
110 ByteVector UnsynchronizedLyricsFrame::renderFields() const
111 {
112   StringList sl;
113   sl.append(d-&gt;description);
114   sl.append(d-&gt;text);
115   const String::Type encoding = checkTextEncoding(sl, d-&gt;textEncoding);
116   ByteVector v;
117   v.append(char(encoding));
118   v.append(d-&gt;language.size() == 3 ? d-&gt;language : "XXX");
119   v.append(d-&gt;description.data(encoding));
120   v.append(textDelimiter(encoding));
121   v.append(d-&gt;text.data(encoding));
122   return v;
123 }
124 UnsynchronizedLyricsFrame::UnsynchronizedLyricsFrame(const ByteVector &amp;data, Header *h) :
125   Frame(h),
126   d(new UnsynchronizedLyricsFramePrivate())
127 {
128   parseFields(fieldData(data));
129 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>chapterframe.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;tbytevectorlist.h&gt;
2 #include &lt;tpropertymap.h&gt;
3 #include &lt;tdebug.h&gt;
4 #include &lt;stdio.h&gt;
5 #include "chapterframe.h"
6 using namespace TagLib;
7 using namespace ID3v2;
8 class ChapterFrame::ChapterFramePrivate
9 {
10 public:
11   ChapterFramePrivate() :
12     tagHeader(0),
13     startTime(0),
14     endTime(0),
15     startOffset(0),
16     endOffset(0)
17   {
18     embeddedFrameList.setAutoDelete(true);
19   }
20   const ID3v2::Header *tagHeader;
21   ByteVector elementID;
22   unsigned int startTime;
23   unsigned int endTime;
24   unsigned int startOffset;
25   unsigned int endOffset;
26   FrameListMap embeddedFrameListMap;
27   FrameList embeddedFrameList;
28 };
29 ChapterFrame::ChapterFrame(const ID3v2::Header *tagHeader, const ByteVector &amp;data) :
30   ID3v2::Frame(data),
31   d(new ChapterFramePrivate())
32 {
33   d-&gt;tagHeader = tagHeader;
34   setData(data);
35 }
36 ChapterFrame::ChapterFrame(const ByteVector &amp;elementID,
37                            unsigned int startTime, unsigned int endTime,
38                            unsigned int startOffset, unsigned int endOffset,
39                            const FrameList &amp;embeddedFrames) :
40   ID3v2::Frame("CHAP"),
41   d(new ChapterFramePrivate())
42 {
43   setElementID(elementID);
44   d-&gt;startTime = startTime;
45   d-&gt;endTime = endTime;
46   d-&gt;startOffset = startOffset;
47   d-&gt;endOffset = endOffset;
48   for(FrameList::ConstIterator it = embeddedFrames.begin();
49       it != embeddedFrames.end(); ++it)
50     addEmbeddedFrame(*it);
51 }
52 ChapterFrame::~ChapterFrame()
53 {
54   delete d;
55 }
56 ByteVector ChapterFrame::elementID() const
57 {
58   return d-&gt;elementID;
59 }
60 unsigned int ChapterFrame::startTime() const
61 {
62   return d-&gt;startTime;
63 }
64 unsigned int ChapterFrame::endTime() const
65 {
66   return d-&gt;endTime;
67 }
68 unsigned int ChapterFrame::startOffset() const
69 {
70   return d-&gt;startOffset;
71 }
72 unsigned int ChapterFrame::endOffset() const
73 {
74   return d-&gt;endOffset;
75 }
76 void ChapterFrame::setElementID(const ByteVector &amp;eID)
77 {
78   d-&gt;elementID = eID;
79   if(d-&gt;elementID.endsWith(char(0)))
80     d-&gt;elementID = d-&gt;elementID.mid(0, d-&gt;elementID.size() - 1);
81 }
82 void ChapterFrame::setStartTime(const unsigned int &amp;sT)
83 {
84   d-&gt;startTime = sT;
85 }
86 void ChapterFrame::setEndTime(const unsigned int &amp;eT)
87 {
88   d-&gt;endTime = eT;
89 }
90 void ChapterFrame::setStartOffset(const unsigned int &amp;sO)
91 {
92   d-&gt;startOffset = sO;
93 }
94 void ChapterFrame::setEndOffset(const unsigned int &amp;eO)
95 {
96   d-&gt;endOffset = eO;
97 }
98 const FrameListMap &amp;ChapterFrame::embeddedFrameListMap() const
99 {
100   return d-&gt;embeddedFrameListMap;
101 }
102 const FrameList &amp;ChapterFrame::embeddedFrameList() const
103 {
104   return d-&gt;embeddedFrameList;
105 }
106 const FrameList &amp;ChapterFrame::embeddedFrameList(const ByteVector &amp;frameID) const
107 {
108   return d-&gt;embeddedFrameListMap[frameID];
109 }
110 void ChapterFrame::addEmbeddedFrame(Frame *frame)
111 {
112   d-&gt;embeddedFrameList.append(frame);
113   d-&gt;embeddedFrameListMap[frame-&gt;frameID()].append(frame);
114 }
115 void ChapterFrame::removeEmbeddedFrame(Frame *frame, bool del)
116 {
117   FrameList::Iterator it = d-&gt;embeddedFrameList.find(frame);
118   d-&gt;embeddedFrameList.erase(it);
119   it = d-&gt;embeddedFrameListMap[frame-&gt;frameID()].find(frame);
120   d-&gt;embeddedFrameListMap[frame-&gt;frameID()].erase(it);
121   if(del)
122     delete frame;
123 }
124 void ChapterFrame::removeEmbeddedFrames(const ByteVector &amp;id)
125 {
126   FrameList l = d-&gt;embeddedFrameListMap[id];
127   for(FrameList::ConstIterator it = l.begin(); it != l.end(); ++it)
128     removeEmbeddedFrame(*it, true);
129 }
130 String ChapterFrame::toString() const
131 {
132   String s = String(d-&gt;elementID) +
133              ": start time: " + String::number(d-&gt;startTime) +
134              ", end time: " + String::number(d-&gt;endTime);
135   if(d-&gt;startOffset != 0xFFFFFFFF)
136     s += ", start offset: " + String::number(d-&gt;startOffset);
137   if(d-&gt;endOffset != 0xFFFFFFFF)
138     s += ", end offset: " + String::number(d-&gt;endOffset);
139   if(!d-&gt;embeddedFrameList.isEmpty()) {
140     StringList frameIDs;
141     for(FrameList::ConstIterator it = d-&gt;embeddedFrameList.begin();
142         it != d-&gt;embeddedFrameList.end(); ++it)
143       frameIDs.append((*it)-&gt;frameID());
144     s += ", sub-frames: [ " + frameIDs.toString(", ") + " ]";
145   }
146   return s;
147 }
148 PropertyMap ChapterFrame::asProperties() const
149 {
150   PropertyMap map;
151 <a name="0"></a>
152   map.unsupportedData().append(frameID() + String("/") + d-&gt;elementID);
153 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  return map;
154 }
155 ChapterFrame *ChapterFrame::findByElementID(const ID3v2::Tag *tag, const ByteVector &amp;eID) {
156   ID3v2::FrameList comments = tag-&gt;frameList("CHAP");
157   for(ID3v2::FrameList::ConstIterator it = comments.begin();
158       it != comments.end();
159       ++it)
160   {
161     ChapterFrame *frame = dynamic_cast&lt;ChapterFrame *&gt;(*it);
162     if(frame &amp;&amp; frame-&gt;elementID() == eID)
163       return frame;
164   }
165   return 0;
166 }
167 void ChapterFrame::parseFields(const ByteVector &amp;data)
168 {</b></font>
169   unsigned int size = data.size();
170   if(size &lt; 18) {
171     debug("A CHAP frame must contain at least 18 bytes (1 byte element ID "
172           "terminated by null and 4x4 bytes for start and end time and offset).");
173     return;
174   }
175   int pos = 0;
176   unsigned int embPos = 0;
177   d-&gt;elementID = readStringField(data, String::Latin1, &amp;pos).data(String::Latin1);
178   d-&gt;startTime = data.toUInt(pos, true);
179   pos += 4;
180   d-&gt;endTime = data.toUInt(pos, true);
181   pos += 4;
182   d-&gt;startOffset = data.toUInt(pos, true);
183   pos += 4;
184   d-&gt;endOffset = data.toUInt(pos, true);
185   pos += 4;
186   size -= pos;
187   if(size &lt; header()-&gt;size())
188     return;
189   while(embPos &lt; size - header()-&gt;size()) {
190     Frame *frame = FrameFactory::instance()-&gt;createFrame(data.mid(pos + embPos), d-&gt;tagHeader);
191     if(!frame)
192       return;
193     if(frame-&gt;size() &lt;= 0) {
194       delete frame;
195       return;
196     }
197     embPos += frame-&gt;size() + header()-&gt;size();
198     addEmbeddedFrame(frame);
199   }
200 }
201 ByteVector ChapterFrame::renderFields() const
202 {
203   ByteVector data;
204   data.append(d-&gt;elementID);
205   data.append('\0');
206   data.append(ByteVector::fromUInt(d-&gt;startTime, true));
207   data.append(ByteVector::fromUInt(d-&gt;endTime, true));
208   data.append(ByteVector::fromUInt(d-&gt;startOffset, true));
209   data.append(ByteVector::fromUInt(d-&gt;endOffset, true));
210   FrameList l = d-&gt;embeddedFrameList;
211   for(FrameList::ConstIterator it = l.begin(); it != l.end(); ++it)
212     data.append((*it)-&gt;render());
213   return data;
214 }
215 ChapterFrame::ChapterFrame(const ID3v2::Header *tagHeader, const ByteVector &amp;data, Header *h) :
216   Frame(h),
217   d(new ChapterFramePrivate())
218 {
219   d-&gt;tagHeader = tagHeader;
220   parseFields(fieldData(data));
221 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
