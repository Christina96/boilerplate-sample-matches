<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for unsynchronizedlyricsframe.cpp & chapterframe.cpp</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for unsynchronizedlyricsframe.cpp & chapterframe.cpp
      </h3>
      <h1 align="center">
        11.5%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>unsynchronizedlyricsframe.cpp (16.556292%)<TH>chapterframe.cpp (8.896797%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match927-0.html#0',2,'match927-1.html#0',3)" NAME="0">(125-144)<TD><A HREF="javascript:ZweiFrames('match927-0.html#0',2,'match927-1.html#0',3)" NAME="0">(223-243)</A><TD ALIGN=center><FONT COLOR="#ff0000">25</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>unsynchronizedlyricsframe.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/***************************************************************************
    copyright            : (C) 2002 - 2008 by Scott Wheeler
    email                : wheeler@kde.org

    copyright            : (C) 2006 by Urs Fleisch
    email                : ufleisch@users.sourceforge.net
 ***************************************************************************/

/***************************************************************************
 *   This library is free software; you can redistribute it and/or modify  *
 *   it  under the terms of the GNU Lesser General Public License version  *
 *   2.1 as published by the Free Software Foundation.                     *
 *                                                                         *
 *   This library is distributed in the hope that it will be useful, but   *
 *   WITHOUT ANY WARRANTY; without even the implied warranty of            *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU     *
 *   Lesser General Public License for more details.                       *
 *                                                                         *
 *   You should have received a copy of the GNU Lesser General Public      *
 *   License along with this library; if not, write to the Free Software   *
 *   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA         *
 *   02110-1301  USA                                                       *
 *                                                                         *
 *   Alternatively, this file is available under the Mozilla Public        *
 *   License Version 1.1.  You may obtain a copy of the License at         *
 *   http://www.mozilla.org/MPL/                                           *
 ***************************************************************************/

#include &quot;unsynchronizedlyricsframe.h&quot;
#include &lt;tbytevectorlist.h&gt;
#include &lt;id3v2tag.h&gt;
#include &lt;tdebug.h&gt;
#include &lt;tpropertymap.h&gt;

using namespace TagLib;
using namespace ID3v2;

class UnsynchronizedLyricsFrame::UnsynchronizedLyricsFramePrivate
{
public:
  UnsynchronizedLyricsFramePrivate() : textEncoding(String::Latin1) {}
  String::Type textEncoding;
  ByteVector language;
  String description;
  String text;
};

////////////////////////////////////////////////////////////////////////////////
// public members
////////////////////////////////////////////////////////////////////////////////

UnsynchronizedLyricsFrame::UnsynchronizedLyricsFrame(String::Type encoding) :
  Frame(&quot;USLT&quot;),
  d(new UnsynchronizedLyricsFramePrivate())
{
  d-&gt;textEncoding = encoding;
}

UnsynchronizedLyricsFrame::UnsynchronizedLyricsFrame(const ByteVector &amp;data) :
  Frame(data),
  d(new UnsynchronizedLyricsFramePrivate())
{
  setData(data);
}

UnsynchronizedLyricsFrame::~UnsynchronizedLyricsFrame()
{
  delete d;
}

String UnsynchronizedLyricsFrame::toString() const
{
  return d-&gt;text;
}

ByteVector UnsynchronizedLyricsFrame::language() const
{
  return d-&gt;language;
}

String UnsynchronizedLyricsFrame::description() const
{
  return d-&gt;description;
}

String UnsynchronizedLyricsFrame::text() const
{
  return d-&gt;text;
}

void UnsynchronizedLyricsFrame::setLanguage(const ByteVector &amp;languageEncoding)
{
  d-&gt;language = languageEncoding.mid(0, 3);
}

void UnsynchronizedLyricsFrame::setDescription(const String &amp;s)
{
  d-&gt;description = s;
}

void UnsynchronizedLyricsFrame::setText(const String &amp;s)
{
  d-&gt;text = s;
}


String::Type UnsynchronizedLyricsFrame::textEncoding() const
{
  return d-&gt;textEncoding;
}

void UnsynchronizedLyricsFrame::setTextEncoding(String::Type encoding)
{
  d-&gt;textEncoding = encoding;
}

PropertyMap UnsynchronizedLyricsFrame::asProperties() const
{
  PropertyMap map;
  String key = description().upper();
  if(key.isEmpty() || key == &quot;LYRICS&quot;)
<A NAME="0"></A>    map.insert(&quot;LYRICS&quot;, text());
  else
    map.insert(&quot;LYRICS:&quot; + key, text());
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match927-1.html#0',3,'match927-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>  return map;
}

UnsynchronizedLyricsFrame *UnsynchronizedLyricsFrame::findByDescription(const ID3v2::Tag *tag, const String &amp;d) // static
{
  ID3v2::FrameList lyrics = tag-&gt;frameList(&quot;USLT&quot;);

  for(ID3v2::FrameList::ConstIterator it = lyrics.begin(); it != lyrics.end(); ++it){
    UnsynchronizedLyricsFrame *frame = dynamic_cast&lt;UnsynchronizedLyricsFrame *&gt;(*it);
    if(frame &amp;&amp; frame-&gt;description() == d)
      return frame;
  }
  return 0;
}
////////////////////////////////////////////////////////////////////////////////
// protected members
////////////////////////////////////////////////////////////////////////////////

void UnsynchronizedLyricsFrame::parseFields(const ByteVector &amp;data)
{</B></FONT>
  if(data.size() &lt; 5) {
    debug(&quot;An unsynchronized lyrics frame must contain at least 5 bytes.&quot;);
    return;
  }

  d-&gt;textEncoding = String::Type(data[0]);
  d-&gt;language = data.mid(1, 3);

  int byteAlign
    = d-&gt;textEncoding == String::Latin1 || d-&gt;textEncoding == String::UTF8 ? 1 : 2;

  ByteVectorList l =
    ByteVectorList::split(data.mid(4), textDelimiter(d-&gt;textEncoding), byteAlign, 2);

  if(l.size() == 2) {
    if(d-&gt;textEncoding == String::Latin1) {
      d-&gt;description = Tag::latin1StringHandler()-&gt;parse(l.front());
      d-&gt;text = Tag::latin1StringHandler()-&gt;parse(l.back());
    } else {
      d-&gt;description = String(l.front(), d-&gt;textEncoding);
      d-&gt;text = String(l.back(), d-&gt;textEncoding);
    }
  }
}

ByteVector UnsynchronizedLyricsFrame::renderFields() const
{
  StringList sl;
  sl.append(d-&gt;description);
  sl.append(d-&gt;text);

  const String::Type encoding = checkTextEncoding(sl, d-&gt;textEncoding);

  ByteVector v;

  v.append(char(encoding));
  v.append(d-&gt;language.size() == 3 ? d-&gt;language : &quot;XXX&quot;);
  v.append(d-&gt;description.data(encoding));
  v.append(textDelimiter(encoding));
  v.append(d-&gt;text.data(encoding));

  return v;
}

////////////////////////////////////////////////////////////////////////////////
// private members
////////////////////////////////////////////////////////////////////////////////

UnsynchronizedLyricsFrame::UnsynchronizedLyricsFrame(const ByteVector &amp;data, Header *h) :
  Frame(h),
  d(new UnsynchronizedLyricsFramePrivate())
{
  parseFields(fieldData(data));
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>chapterframe.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/***************************************************************************
    copyright            : (C) 2013 by Lukas Krejci
    email                : krejclu6@fel.cvut.cz
 ***************************************************************************/

/***************************************************************************
 *   This library is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU Lesser General Public License version   *
 *   2.1 as published by the Free Software Foundation.                     *
 *                                                                         *
 *   This library is distributed in the hope that it will be useful, but   *
 *   WITHOUT ANY WARRANTY; without even the implied warranty of            *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU     *
 *   Lesser General Public License for more details.                       *
 *                                                                         *
 *   You should have received a copy of the GNU Lesser General Public      *
 *   License along with this library; if not, write to the Free Software   *
 *   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA         *
 *   02110-1301  USA                                                       *
 *                                                                         *
 *   Alternatively, this file is available under the Mozilla Public        *
 *   License Version 1.1.  You may obtain a copy of the License at         *
 *   http://www.mozilla.org/MPL/                                           *
 ***************************************************************************/

#include &lt;tbytevectorlist.h&gt;
#include &lt;tpropertymap.h&gt;
#include &lt;tdebug.h&gt;
#include &lt;stdio.h&gt;

#include &quot;chapterframe.h&quot;

using namespace TagLib;
using namespace ID3v2;

class ChapterFrame::ChapterFramePrivate
{
public:
  ChapterFramePrivate() :
    tagHeader(0),
    startTime(0),
    endTime(0),
    startOffset(0),
    endOffset(0)
  {
    embeddedFrameList.setAutoDelete(true);
  }

  const ID3v2::Header *tagHeader;
  ByteVector elementID;
  unsigned int startTime;
  unsigned int endTime;
  unsigned int startOffset;
  unsigned int endOffset;
  FrameListMap embeddedFrameListMap;
  FrameList embeddedFrameList;
};

////////////////////////////////////////////////////////////////////////////////
// public methods
////////////////////////////////////////////////////////////////////////////////

ChapterFrame::ChapterFrame(const ID3v2::Header *tagHeader, const ByteVector &amp;data) :
  ID3v2::Frame(data),
  d(new ChapterFramePrivate())
{
  d-&gt;tagHeader = tagHeader;
  setData(data);
}

ChapterFrame::ChapterFrame(const ByteVector &amp;elementID,
                           unsigned int startTime, unsigned int endTime,
                           unsigned int startOffset, unsigned int endOffset,
                           const FrameList &amp;embeddedFrames) :
  ID3v2::Frame(&quot;CHAP&quot;),
  d(new ChapterFramePrivate())
{
  // setElementID has a workaround for a previously silly API where you had to
  // specifically include the null byte.

  setElementID(elementID);

  d-&gt;startTime = startTime;
  d-&gt;endTime = endTime;
  d-&gt;startOffset = startOffset;
  d-&gt;endOffset = endOffset;

  for(FrameList::ConstIterator it = embeddedFrames.begin();
      it != embeddedFrames.end(); ++it)
    addEmbeddedFrame(*it);
}

ChapterFrame::~ChapterFrame()
{
  delete d;
}

ByteVector ChapterFrame::elementID() const
{
  return d-&gt;elementID;
}

unsigned int ChapterFrame::startTime() const
{
  return d-&gt;startTime;
}

unsigned int ChapterFrame::endTime() const
{
  return d-&gt;endTime;
}

unsigned int ChapterFrame::startOffset() const
{
  return d-&gt;startOffset;
}

unsigned int ChapterFrame::endOffset() const
{
  return d-&gt;endOffset;
}

void ChapterFrame::setElementID(const ByteVector &amp;eID)
{
  d-&gt;elementID = eID;

  if(d-&gt;elementID.endsWith(char(0)))
    d-&gt;elementID = d-&gt;elementID.mid(0, d-&gt;elementID.size() - 1);
}

void ChapterFrame::setStartTime(const unsigned int &amp;sT)
{
  d-&gt;startTime = sT;
}

void ChapterFrame::setEndTime(const unsigned int &amp;eT)
{
  d-&gt;endTime = eT;
}

void ChapterFrame::setStartOffset(const unsigned int &amp;sO)
{
  d-&gt;startOffset = sO;
}

void ChapterFrame::setEndOffset(const unsigned int &amp;eO)
{
  d-&gt;endOffset = eO;
}

const FrameListMap &amp;ChapterFrame::embeddedFrameListMap() const
{
  return d-&gt;embeddedFrameListMap;
}

const FrameList &amp;ChapterFrame::embeddedFrameList() const
{
  return d-&gt;embeddedFrameList;
}

const FrameList &amp;ChapterFrame::embeddedFrameList(const ByteVector &amp;frameID) const
{
  return d-&gt;embeddedFrameListMap[frameID];
}

void ChapterFrame::addEmbeddedFrame(Frame *frame)
{
  d-&gt;embeddedFrameList.append(frame);
  d-&gt;embeddedFrameListMap[frame-&gt;frameID()].append(frame);
}

void ChapterFrame::removeEmbeddedFrame(Frame *frame, bool del)
{
  // remove the frame from the frame list
  FrameList::Iterator it = d-&gt;embeddedFrameList.find(frame);
  d-&gt;embeddedFrameList.erase(it);

  // ...and from the frame list map
  it = d-&gt;embeddedFrameListMap[frame-&gt;frameID()].find(frame);
  d-&gt;embeddedFrameListMap[frame-&gt;frameID()].erase(it);

  // ...and delete as desired
  if(del)
    delete frame;
}

void ChapterFrame::removeEmbeddedFrames(const ByteVector &amp;id)
{
  FrameList l = d-&gt;embeddedFrameListMap[id];
  for(FrameList::ConstIterator it = l.begin(); it != l.end(); ++it)
    removeEmbeddedFrame(*it, true);
}

String ChapterFrame::toString() const
{
  String s = String(d-&gt;elementID) +
             &quot;: start time: &quot; + String::number(d-&gt;startTime) +
             &quot;, end time: &quot; + String::number(d-&gt;endTime);

  if(d-&gt;startOffset != 0xFFFFFFFF)
    s += &quot;, start offset: &quot; + String::number(d-&gt;startOffset);

  if(d-&gt;endOffset != 0xFFFFFFFF)
    s += &quot;, end offset: &quot; + String::number(d-&gt;endOffset);

  if(!d-&gt;embeddedFrameList.isEmpty()) {
    StringList frameIDs;
    for(FrameList::ConstIterator it = d-&gt;embeddedFrameList.begin();
        it != d-&gt;embeddedFrameList.end(); ++it)
      frameIDs.append((*it)-&gt;frameID());
    s += &quot;, sub-frames: [ &quot; + frameIDs.toString(&quot;, &quot;) + &quot; ]&quot;;
  }

  return s;
}

PropertyMap ChapterFrame::asProperties() const
{
  PropertyMap map;
<A NAME="0"></A>
  map.unsupportedData().append(frameID() + String(&quot;/&quot;) + d-&gt;elementID);

<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match927-0.html#0',2,'match927-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>  return map;
}

ChapterFrame *ChapterFrame::findByElementID(const ID3v2::Tag *tag, const ByteVector &amp;eID) // static
{
  ID3v2::FrameList comments = tag-&gt;frameList(&quot;CHAP&quot;);

  for(ID3v2::FrameList::ConstIterator it = comments.begin();
      it != comments.end();
      ++it)
  {
    ChapterFrame *frame = dynamic_cast&lt;ChapterFrame *&gt;(*it);
    if(frame &amp;&amp; frame-&gt;elementID() == eID)
      return frame;
  }

  return 0;
}

void ChapterFrame::parseFields(const ByteVector &amp;data)
{</B></FONT>
  unsigned int size = data.size();
  if(size &lt; 18) {
    debug(&quot;A CHAP frame must contain at least 18 bytes (1 byte element ID &quot;
          &quot;terminated by null and 4x4 bytes for start and end time and offset).&quot;);
    return;
  }

  int pos = 0;
  unsigned int embPos = 0;
  d-&gt;elementID = readStringField(data, String::Latin1, &amp;pos).data(String::Latin1);
  d-&gt;startTime = data.toUInt(pos, true);
  pos += 4;
  d-&gt;endTime = data.toUInt(pos, true);
  pos += 4;
  d-&gt;startOffset = data.toUInt(pos, true);
  pos += 4;
  d-&gt;endOffset = data.toUInt(pos, true);
  pos += 4;
  size -= pos;

  // Embedded frames are optional

  if(size &lt; header()-&gt;size())
    return;

  while(embPos &lt; size - header()-&gt;size()) {
    Frame *frame = FrameFactory::instance()-&gt;createFrame(data.mid(pos + embPos), d-&gt;tagHeader);

    if(!frame)
      return;

    // Checks to make sure that frame parsed correctly.
    if(frame-&gt;size() &lt;= 0) {
      delete frame;
      return;
    }

    embPos += frame-&gt;size() + header()-&gt;size();
    addEmbeddedFrame(frame);
  }
}

ByteVector ChapterFrame::renderFields() const
{
  ByteVector data;

  data.append(d-&gt;elementID);
  data.append('\0');
  data.append(ByteVector::fromUInt(d-&gt;startTime, true));
  data.append(ByteVector::fromUInt(d-&gt;endTime, true));
  data.append(ByteVector::fromUInt(d-&gt;startOffset, true));
  data.append(ByteVector::fromUInt(d-&gt;endOffset, true));
  FrameList l = d-&gt;embeddedFrameList;
  for(FrameList::ConstIterator it = l.begin(); it != l.end(); ++it)
    data.append((*it)-&gt;render());

  return data;
}

ChapterFrame::ChapterFrame(const ID3v2::Header *tagHeader, const ByteVector &amp;data, Header *h) :
  Frame(h),
  d(new ChapterFramePrivate())
{
  d-&gt;tagHeader = tagHeader;
  parseFields(fieldData(data));
}
</PRE>
</div>
  </div>
</body>
</html>
