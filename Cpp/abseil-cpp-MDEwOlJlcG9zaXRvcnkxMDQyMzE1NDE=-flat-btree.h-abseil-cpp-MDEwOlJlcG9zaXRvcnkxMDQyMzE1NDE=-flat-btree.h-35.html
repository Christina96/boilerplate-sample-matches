
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 17, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-btree.h</h3>
            <pre><code>1  #ifndef ABSL_CONTAINER_INTERNAL_BTREE_H_
2  #define ABSL_CONTAINER_INTERNAL_BTREE_H_
3  #include &lt;algorithm&gt;
4  #include &lt;cassert&gt;
5  #include &lt;cstddef&gt;
6  #include &lt;cstdint&gt;
7  #include &lt;cstring&gt;
8  #include &lt;functional&gt;
9  #include &lt;iterator&gt;
10  #include &lt;limits&gt;
11  #include &lt;new&gt;
12  #include &lt;string&gt;
13  #include &lt;type_traits&gt;
14  #include &lt;utility&gt;
15  #include &quot;absl/base/internal/raw_logging.h&quot;
16  #include &quot;absl/base/macros.h&quot;
17  #include &quot;absl/container/internal/common.h&quot;
18  #include &quot;absl/container/internal/common_policy_traits.h&quot;
19  #include &quot;absl/container/internal/compressed_tuple.h&quot;
20  #include &quot;absl/container/internal/container_memory.h&quot;
21  #include &quot;absl/container/internal/layout.h&quot;
22  #include &quot;absl/memory/memory.h&quot;
23  #include &quot;absl/meta/type_traits.h&quot;
24  #include &quot;absl/strings/cord.h&quot;
25  #include &quot;absl/strings/string_view.h&quot;
26  #include &quot;absl/types/compare.h&quot;
27  #include &quot;absl/utility/utility.h&quot;
28  namespace absl {
29  ABSL_NAMESPACE_BEGIN
30  namespace container_internal {
31  #ifdef ABSL_BTREE_ENABLE_GENERATIONS
32  #error ABSL_BTREE_ENABLE_GENERATIONS cannot be directly set
33  #elif defined(ABSL_HAVE_ADDRESS_SANITIZER) || \
34      defined(ABSL_HAVE_MEMORY_SANITIZER)
35  #define ABSL_BTREE_ENABLE_GENERATIONS
36  #endif
37  #ifdef ABSL_BTREE_ENABLE_GENERATIONS
38  constexpr bool BtreeGenerationsEnabled() { return true; }
39  #else
40  constexpr bool BtreeGenerationsEnabled() { return false; }
41  #endif
42  template &lt;typename Compare, typename T, typename U&gt;
43  using compare_result_t = absl::result_of_t&lt;const Compare(const T &amp;, const U &amp;)&gt;;
44  template &lt;typename Compare, typename T&gt;
45  using btree_is_key_compare_to =
46      std::is_convertible&lt;compare_result_t&lt;Compare, T, T&gt;, absl::weak_ordering&gt;;
47  struct StringBtreeDefaultLess {
48    using is_transparent = void;
49    StringBtreeDefaultLess() = default;
50    StringBtreeDefaultLess(std::less&lt;std::string&gt;) {}        
51    StringBtreeDefaultLess(std::less&lt;absl::string_view&gt;) {}  
52    explicit operator std::less&lt;std::string&gt;() const { return {}; }
53    explicit operator std::less&lt;absl::string_view&gt;() const { return {}; }
54    explicit operator std::less&lt;absl::Cord&gt;() const { return {}; }
55    absl::weak_ordering operator()(absl::string_view lhs,
56                                   absl::string_view rhs) const {
57      return compare_internal::compare_result_as_ordering(lhs.compare(rhs));
58    }
59    StringBtreeDefaultLess(std::less&lt;absl::Cord&gt;) {}  
60    absl::weak_ordering operator()(const absl::Cord &amp;lhs,
61                                   const absl::Cord &amp;rhs) const {
62      return compare_internal::compare_result_as_ordering(lhs.Compare(rhs));
63    }
64    absl::weak_ordering operator()(const absl::Cord &amp;lhs,
65                                   absl::string_view rhs) const {
66      return compare_internal::compare_result_as_ordering(lhs.Compare(rhs));
67    }
68    absl::weak_ordering operator()(absl::string_view lhs,
69                                   const absl::Cord &amp;rhs) const {
70      return compare_internal::compare_result_as_ordering(-rhs.Compare(lhs));
71    }
72  };
73  struct StringBtreeDefaultGreater {
74    using is_transparent = void;
75    StringBtreeDefaultGreater() = default;
76    StringBtreeDefaultGreater(std::greater&lt;std::string&gt;) {}        
77    StringBtreeDefaultGreater(std::greater&lt;absl::string_view&gt;) {}  
78    explicit operator std::greater&lt;std::string&gt;() const { return {}; }
79    explicit operator std::greater&lt;absl::string_view&gt;() const { return {}; }
80    explicit operator std::greater&lt;absl::Cord&gt;() const { return {}; }
81    absl::weak_ordering operator()(absl::string_view lhs,
82                                   absl::string_view rhs) const {
83      return compare_internal::compare_result_as_ordering(rhs.compare(lhs));
84    }
85    StringBtreeDefaultGreater(std::greater&lt;absl::Cord&gt;) {}  
86    absl::weak_ordering operator()(const absl::Cord &amp;lhs,
87                                   const absl::Cord &amp;rhs) const {
88      return compare_internal::compare_result_as_ordering(rhs.Compare(lhs));
89    }
90    absl::weak_ordering operator()(const absl::Cord &amp;lhs,
91                                   absl::string_view rhs) const {
92      return compare_internal::compare_result_as_ordering(-lhs.Compare(rhs));
93    }
94    absl::weak_ordering operator()(absl::string_view lhs,
95                                   const absl::Cord &amp;rhs) const {
96      return compare_internal::compare_result_as_ordering(rhs.Compare(lhs));
97    }
98  };
99  template &lt;typename Compare, bool is_class = std::is_class&lt;Compare&gt;::value&gt;
100  struct checked_compare_base : Compare {
101    using Compare::Compare;
102    explicit checked_compare_base(Compare c) : Compare(std::move(c)) {}
103    const Compare &amp;comp() const { return *this; }
104  };
105  template &lt;typename Compare&gt;
106  struct checked_compare_base&lt;Compare, false&gt; {
107    explicit checked_compare_base(Compare c) : compare(std::move(c)) {}
108    const Compare &amp;comp() const { return compare; }
109    Compare compare;
110  };
111  struct BtreeTestOnlyCheckedCompareOptOutBase {};
112  template &lt;typename Compare, typename Key&gt;
113  struct key_compare_adapter {
114    struct checked_compare : checked_compare_base&lt;Compare&gt; {
115     private:
116      using Base = typename checked_compare::checked_compare_base;
117      using Base::comp;
118      bool is_self_equivalent(const Key &amp;k) const {
119        return comp()(k, k) == 0;
120      }
121      template &lt;typename T&gt;
122      bool is_self_equivalent(const T &amp;) const {
123        return true;
124      }
125     public:
126      using Base::Base;
127      checked_compare(Compare comp) : Base(std::move(comp)) {}  
128      explicit operator Compare() const { return comp(); }
129      template &lt;typename T, typename U,
130                absl::enable_if_t&lt;
131                    std::is_same&lt;bool, compare_result_t&lt;Compare, T, U&gt;&gt;::value,
132                    int&gt; = 0&gt;
133      bool operator()(const T &amp;lhs, const U &amp;rhs) const {
134        assert(is_self_equivalent(lhs));
135        assert(is_self_equivalent(rhs));
136        const bool lhs_comp_rhs = comp()(lhs, rhs);
137        assert(!lhs_comp_rhs || !comp()(rhs, lhs));
138        return lhs_comp_rhs;
139      }
140      template &lt;
141          typename T, typename U,
142          absl::enable_if_t&lt;std::is_convertible&lt;compare_result_t&lt;Compare, T, U&gt;,
143                                                absl::weak_ordering&gt;::value,
144                            int&gt; = 0&gt;
145      absl::weak_ordering operator()(const T &amp;lhs, const U &amp;rhs) const {
146        assert(is_self_equivalent(lhs));
147        assert(is_self_equivalent(rhs));
148        const absl::weak_ordering lhs_comp_rhs = comp()(lhs, rhs);
149  #ifndef NDEBUG
150        const absl::weak_ordering rhs_comp_lhs = comp()(rhs, lhs);
151        if (lhs_comp_rhs &gt; 0) {
152          assert(rhs_comp_lhs &lt; 0 &amp;&amp; &quot;lhs_comp_rhs &gt; 0 -&gt; rhs_comp_lhs &lt; 0&quot;);
153        } else if (lhs_comp_rhs == 0) {
154          assert(rhs_comp_lhs == 0 &amp;&amp; &quot;lhs_comp_rhs == 0 -&gt; rhs_comp_lhs == 0&quot;);
155        } else {
156          assert(rhs_comp_lhs &gt; 0 &amp;&amp; &quot;lhs_comp_rhs &lt; 0 -&gt; rhs_comp_lhs &gt; 0&quot;);
157        }
158  #endif
159        return lhs_comp_rhs;
160      }
161    };
162    using type = absl::conditional_t&lt;
163        std::is_base_of&lt;BtreeTestOnlyCheckedCompareOptOutBase, Compare&gt;::value,
164        Compare, checked_compare&gt;;
165  };
166  template &lt;&gt;
167  struct key_compare_adapter&lt;std::less&lt;std::string&gt;, std::string&gt; {
168    using type = StringBtreeDefaultLess;
169  };
170  template &lt;&gt;
171  struct key_compare_adapter&lt;std::greater&lt;std::string&gt;, std::string&gt; {
172    using type = StringBtreeDefaultGreater;
173  };
174  template &lt;&gt;
175  struct key_compare_adapter&lt;std::less&lt;absl::string_view&gt;, absl::string_view&gt; {
176    using type = StringBtreeDefaultLess;
177  };
178  template &lt;&gt;
179  struct key_compare_adapter&lt;std::greater&lt;absl::string_view&gt;, absl::string_view&gt; {
180    using type = StringBtreeDefaultGreater;
181  };
182  template &lt;&gt;
183  struct key_compare_adapter&lt;std::less&lt;absl::Cord&gt;, absl::Cord&gt; {
184    using type = StringBtreeDefaultLess;
185  };
186  template &lt;&gt;
187  struct key_compare_adapter&lt;std::greater&lt;absl::Cord&gt;, absl::Cord&gt; {
188    using type = StringBtreeDefaultGreater;
189  };
190  template &lt;typename T, typename = void&gt;
191  struct has_linear_node_search_preference : std::false_type {};
192  template &lt;typename T, typename = void&gt;
193  struct prefers_linear_node_search : std::false_type {};
194  template &lt;typename T&gt;
195  struct has_linear_node_search_preference&lt;
196      T, absl::void_t&lt;typename T::absl_btree_prefer_linear_node_search&gt;&gt;
197      : std::true_type {};
198  template &lt;typename T&gt;
199  struct prefers_linear_node_search&lt;
200      T, absl::void_t&lt;typename T::absl_btree_prefer_linear_node_search&gt;&gt;
201      : T::absl_btree_prefer_linear_node_search {};
202  template &lt;typename Compare, typename Key&gt;
203  constexpr bool compare_has_valid_result_type() {
204    using compare_result_type = compare_result_t&lt;Compare, Key, Key&gt;;
205    return std::is_same&lt;compare_result_type, bool&gt;::value ||
206           std::is_convertible&lt;compare_result_type, absl::weak_ordering&gt;::value;
207  }
208  template &lt;typename original_key_compare, typename value_type&gt;
209  class map_value_compare {
210    template &lt;typename Params&gt;
211    friend class btree;
212   protected:
213    explicit map_value_compare(original_key_compare c) : comp(std::move(c)) {}
214    original_key_compare comp;  
215   public:
216    auto operator()(const value_type &amp;lhs, const value_type &amp;rhs) const
217        -&gt; decltype(comp(lhs.first, rhs.first)) {
218      return comp(lhs.first, rhs.first);
219    }
220  };
221  template &lt;typename Key, typename Compare, typename Alloc, int TargetNodeSize,
222            bool IsMulti, bool IsMap, typename SlotPolicy&gt;
223  struct common_params : common_policy_traits&lt;SlotPolicy&gt; {
224    using original_key_compare = Compare;
225    using key_compare =
226        absl::conditional_t&lt;!compare_has_valid_result_type&lt;Compare, Key&gt;(),
227                            Compare,
228                            typename key_compare_adapter&lt;Compare, Key&gt;::type&gt;;
229    static constexpr bool kIsKeyCompareStringAdapted =
230        std::is_same&lt;key_compare, StringBtreeDefaultLess&gt;::value ||
231        std::is_same&lt;key_compare, StringBtreeDefaultGreater&gt;::value;
232    static constexpr bool kIsKeyCompareTransparent =
233        IsTransparent&lt;original_key_compare&gt;::value || kIsKeyCompareStringAdapted;
234    using is_key_compare_to = btree_is_key_compare_to&lt;key_compare, Key&gt;;
235    using allocator_type = Alloc;
236    using key_type = Key;
237    using size_type = size_t;
238    using difference_type = ptrdiff_t;
239    using slot_policy = SlotPolicy;
240    using slot_type = typename slot_policy::slot_type;
241    using value_type = typename slot_policy::value_type;
242    using init_type = typename slot_policy::mutable_value_type;
243    using pointer = value_type *;
244    using const_pointer = const value_type *;
245    using reference = value_type &amp;;
246    using const_reference = const value_type &amp;;
247    using value_compare =
248        absl::conditional_t&lt;IsMap,
249                            map_value_compare&lt;original_key_compare, value_type&gt;,
250                            original_key_compare&gt;;
251    using is_map_container = std::integral_constant&lt;bool, IsMap&gt;;
252    template &lt;typename LookupKey&gt;
253    constexpr static bool can_have_multiple_equivalent_keys() {
254      return IsMulti || (IsTransparent&lt;key_compare&gt;::value &amp;&amp;
255                         !std::is_same&lt;LookupKey, Key&gt;::value &amp;&amp;
256                         !kIsKeyCompareStringAdapted);
257    }
258    enum {
259      kTargetNodeSize = TargetNodeSize,
260      kNodeSlotSpace = TargetNodeSize - &amp;bsol;*minimum overhead=*/(sizeof(void *) + 4),
261    };
262    using node_count_type =
263        absl::conditional_t&lt;(kNodeSlotSpace / sizeof(slot_type) &gt;
264                             (std::numeric_limits&lt;uint8_t&gt;::max)()),
265                            uint16_t, uint8_t&gt;;  
266  };
267  template &lt;typename Compare&gt;
268  struct upper_bound_adapter {
269    explicit upper_bound_adapter(const Compare &amp;c) : comp(c) {}
270    template &lt;typename K1, typename K2&gt;
271    bool operator()(const K1 &amp;a, const K2 &amp;b) const {
272      return !compare_internal::compare_result_as_less_than(comp(b, a));
273    }
274   private:
275    Compare comp;
276  };
277  enum class MatchKind : uint8_t { kEq, kNe };
278  template &lt;typename V, bool IsCompareTo&gt;
279  struct SearchResult {
280    V value;
281    MatchKind match;
282    static constexpr bool HasMatch() { return true; }
283    bool IsEq() const { return match == MatchKind::kEq; }
284  };
285  template &lt;typename V&gt;
286  struct SearchResult&lt;V, false&gt; {
287    SearchResult() {}
288    explicit SearchResult(V v) : value(v) {}
289    SearchResult(V v, MatchKind &amp;bsol;*match*/) : value(v) {}
290    V value;
291    static constexpr bool HasMatch() { return false; }
292    static constexpr bool IsEq() { return false; }
293  };
294  template &lt;typename Params&gt;
295  class btree_node {
296    using is_key_compare_to = typename Params::is_key_compare_to;
297    using field_type = typename Params::node_count_type;
298    using allocator_type = typename Params::allocator_type;
299    using slot_type = typename Params::slot_type;
300    using original_key_compare = typename Params::original_key_compare;
301   public:
302    using params_type = Params;
303    using key_type = typename Params::key_type;
304    using value_type = typename Params::value_type;
305    using pointer = typename Params::pointer;
306    using const_pointer = typename Params::const_pointer;
307    using reference = typename Params::reference;
308    using const_reference = typename Params::const_reference;
309    using key_compare = typename Params::key_compare;
310    using size_type = typename Params::size_type;
311    using difference_type = typename Params::difference_type;
312    using use_linear_search = std::integral_constant&lt;
313        bool, has_linear_node_search_preference&lt;original_key_compare&gt;::value
314                  ? prefers_linear_node_search&lt;original_key_compare&gt;::value
315              : has_linear_node_search_preference&lt;key_type&gt;::value
316                  ? prefers_linear_node_search&lt;key_type&gt;::value
317                  : std::is_arithmetic&lt;key_type&gt;::value &amp;&amp;
318                        (std::is_same&lt;std::less&lt;key_type&gt;,
319                                      original_key_compare&gt;::value ||
320                         std::is_same&lt;std::greater&lt;key_type&gt;,
321                                      original_key_compare&gt;::value)&gt;;
322    ~btree_node() = default;
323    btree_node(btree_node const &amp;) = delete;
324    btree_node &amp;operator=(btree_node const &amp;) = delete;
325    constexpr static size_type Alignment() {
326      static_assert(LeafLayout(1).Alignment() == InternalLayout().Alignment(),
327                    &quot;Alignment of all nodes must be equal.&quot;);
328      return InternalLayout().Alignment();
329    }
330   protected:
331    btree_node() = default;
332   private:
333    using layout_type =
334        absl::container_internal::Layout&lt;btree_node *, uint32_t, field_type,
335                                         slot_type, btree_node *&gt;;
336    constexpr static size_type SizeWithNSlots(size_type n) {
337      return layout_type(
338                  1,
339                  BtreeGenerationsEnabled() ? 1 : 0,
340                  4,
341                  n,
342                  0)
343          .AllocSize();
344    }
345    constexpr static size_type MinimumOverhead() {
346      return SizeWithNSlots(1) - sizeof(slot_type);
347    }
348    constexpr static size_type NodeTargetSlots(const size_type begin,
349                                               const size_type end) {
350      return begin == end ? begin
351             : SizeWithNSlots((begin + end) / 2 + 1) &gt;
352                     params_type::kTargetNodeSize
353                 ? NodeTargetSlots(begin, (begin + end) / 2)
354                 : NodeTargetSlots((begin + end) / 2 + 1, end);
355    }
356    constexpr static size_type kTargetNodeSize = params_type::kTargetNodeSize;
357    constexpr static size_type kNodeTargetSlots =
358        NodeTargetSlots(0, kTargetNodeSize);
359    constexpr static size_type kMinNodeSlots = 4;
360    constexpr static size_type kNodeSlots =
361        kNodeTargetSlots &gt;= kMinNodeSlots ? kNodeTargetSlots : kMinNodeSlots;
362    constexpr static field_type kInternalNodeMaxCount = 0;
363    constexpr static layout_type Layout(const size_type slot_count,
364                                        const size_type child_count) {
365      return layout_type(
366           1,
367           BtreeGenerationsEnabled() ? 1 : 0,
368           4,
369           slot_count,
370           child_count);
371    }
372    constexpr static layout_type LeafLayout(
373        const size_type slot_count = kNodeSlots) {
374      return Layout(slot_count, 0);
375    }
376    constexpr static layout_type InternalLayout() {
377      return Layout(kNodeSlots, kNodeSlots + 1);
378    }
379    constexpr static size_type LeafSize(const size_type slot_count = kNodeSlots) {
380      return LeafLayout(slot_count).AllocSize();
381    }
382    constexpr static size_type InternalSize() {
383      return InternalLayout().AllocSize();
384    }
385    template &lt;size_type N&gt;
386    inline typename layout_type::template ElementType&lt;N&gt; *GetField() {
387      assert(N &lt; 4 || is_internal());
388      return InternalLayout().template Pointer&lt;N&gt;(reinterpret_cast&lt;char *&gt;(this));
389    }
390    template &lt;size_type N&gt;
391    inline const typename layout_type::template ElementType&lt;N&gt; *GetField() const {
392      assert(N &lt; 4 || is_internal());
393      return InternalLayout().template Pointer&lt;N&gt;(
394          reinterpret_cast&lt;const char *&gt;(this));
395    }
396    void set_parent(btree_node *p) { *GetField&lt;0&gt;() = p; }
397    field_type &amp;mutable_finish() { return GetField&lt;2&gt;()[2]; }
398    slot_type *slot(size_type i) { return &amp;GetField&lt;3&gt;()[i]; }
399    slot_type *start_slot() { return slot(start()); }
400    slot_type *finish_slot() { return slot(finish()); }
401    const slot_type *slot(size_type i) const { return &amp;GetField&lt;3&gt;()[i]; }
402    void set_position(field_type v) { GetField&lt;2&gt;()[0] = v; }
403    void set_start(field_type v) { GetField&lt;2&gt;()[1] = v; }
404    void set_finish(field_type v) { GetField&lt;2&gt;()[2] = v; }
405    void set_max_count(field_type v) { GetField&lt;2&gt;()[3] = v; }
406   public:
407    bool is_leaf() const { return GetField&lt;2&gt;()[3] != kInternalNodeMaxCount; }
408    bool is_internal() const { return !is_leaf(); }
409    field_type position() const { return GetField&lt;2&gt;()[0]; }
410    field_type start() const {
411      assert(GetField&lt;2&gt;()[1] == 0);
412      return 0;
413    }
414    field_type finish() const { return GetField&lt;2&gt;()[2]; }
415    field_type count() const {
416      assert(finish() &gt;= start());
417      return finish() - start();
418    }
419    field_type max_count() const {
420      const field_type max_count = GetField&lt;2&gt;()[3];
421      return max_count == field_type{kInternalNodeMaxCount}
422                 ? field_type{kNodeSlots}
423                 : max_count;
424    }
425    btree_node *parent() const { return *GetField&lt;0&gt;(); }
426    bool is_root() const { return parent()-&gt;is_leaf(); }
427    void make_root() {
428      assert(parent()-&gt;is_root());
429      set_generation(parent()-&gt;generation());
430      set_parent(parent()-&gt;parent());
431    }
432    uint32_t *get_root_generation() const {
433      assert(BtreeGenerationsEnabled());
434      const btree_node *curr = this;
435      for (; !curr-&gt;is_root(); curr = curr-&gt;parent()) continue;
436      return const_cast&lt;uint32_t *&gt;(&amp;curr-&gt;GetField&lt;1&gt;()[0]);
437    }
438    uint32_t generation() const {
439      return BtreeGenerationsEnabled() ? *get_root_generation() : 0;
440    }
441    void set_generation(uint32_t generation) {
442      if (BtreeGenerationsEnabled()) GetField&lt;1&gt;()[0] = generation;
443    }
444    void next_generation() {
445      if (BtreeGenerationsEnabled()) ++*get_root_generation();
446    }
447    const key_type &amp;key(size_type i) const { return params_type::key(slot(i)); }
448    reference value(size_type i) { return params_type::element(slot(i)); }
449    const_reference value(size_type i) const {
450      return params_type::element(slot(i));
451    }
452    btree_node *child(field_type i) const { return GetField&lt;4&gt;()[i]; }
453    btree_node *start_child() const { return child(start()); }
454    btree_node *&amp;mutable_child(field_type i) { return GetField&lt;4&gt;()[i]; }
455    void clear_child(field_type i) {
456      absl::container_internal::SanitizerPoisonObject(&amp;mutable_child(i));
457    }
458    void set_child_noupdate_position(field_type i, btree_node *c) {
459      absl::container_internal::SanitizerUnpoisonObject(&amp;mutable_child(i));
460      mutable_child(i) = c;
461    }
462    void set_child(field_type i, btree_node *c) {
463      set_child_noupdate_position(i, c);
464      c-&gt;set_position(i);
465    }
466    void init_child(field_type i, btree_node *c) {
467      set_child(i, c);
468      c-&gt;set_parent(this);
469    }
470    template &lt;typename K&gt;
471    SearchResult&lt;size_type, is_key_compare_to::value&gt; lower_bound(
472        const K &amp;k, const key_compare &amp;comp) const {
473      return use_linear_search::value ? linear_search(k, comp)
474                                      : binary_search(k, comp);
475    }
476    template &lt;typename K&gt;
477    size_type upper_bound(const K &amp;k, const key_compare &amp;comp) const {
478      auto upper_compare = upper_bound_adapter&lt;key_compare&gt;(comp);
479      return use_linear_search::value ? linear_search(k, upper_compare).value
480                                      : binary_search(k, upper_compare).value;
481    }
482    template &lt;typename K, typename Compare&gt;
483    SearchResult&lt;size_type, btree_is_key_compare_to&lt;Compare, key_type&gt;::value&gt;
484    linear_search(const K &amp;k, const Compare &amp;comp) const {
485      return linear_search_impl(k, start(), finish(), comp,
486                                btree_is_key_compare_to&lt;Compare, key_type&gt;());
487    }
488    template &lt;typename K, typename Compare&gt;
489    SearchResult&lt;size_type, btree_is_key_compare_to&lt;Compare, key_type&gt;::value&gt;
490    binary_search(const K &amp;k, const Compare &amp;comp) const {
491      return binary_search_impl(k, start(), finish(), comp,
492                                btree_is_key_compare_to&lt;Compare, key_type&gt;());
493    }
494    template &lt;typename K, typename Compare&gt;
495    SearchResult&lt;size_type, false&gt; linear_search_impl(
496        const K &amp;k, size_type s, const size_type e, const Compare &amp;comp,
497        std::false_type &amp;bsol;* IsCompareTo */) const {
498      while (s &lt; e) {
499        if (!comp(key(s), k)) {
500          break;
501        }
502        ++s;
503      }
504      return SearchResult&lt;size_type, false&gt;{s};
505    }
506    template &lt;typename K, typename Compare&gt;
507    SearchResult&lt;size_type, true&gt; linear_search_impl(
508        const K &amp;k, size_type s, const size_type e, const Compare &amp;comp,
509        std::true_type &amp;bsol;* IsCompareTo */) const {
510      while (s &lt; e) {
511        const absl::weak_ordering c = comp(key(s), k);
512        if (c == 0) {
513          return {s, MatchKind::kEq};
514        } else if (c &gt; 0) {
515          break;
516        }
517        ++s;
518      }
519      return {s, MatchKind::kNe};
520    }
521    template &lt;typename K, typename Compare&gt;
522    SearchResult&lt;size_type, false&gt; binary_search_impl(
523        const K &amp;k, size_type s, size_type e, const Compare &amp;comp,
524        std::false_type &amp;bsol;* IsCompareTo */) const {
525      while (s != e) {
526        const size_type mid = (s + e) &gt;&gt; 1;
527        if (comp(key(mid), k)) {
528          s = mid + 1;
529        } else {
530          e = mid;
531        }
532      }
533      return SearchResult&lt;size_type, false&gt;{s};
534    }
535    template &lt;typename K, typename CompareTo&gt;
536    SearchResult&lt;size_type, true&gt; binary_search_impl(
537        const K &amp;k, size_type s, size_type e, const CompareTo &amp;comp,
538        std::true_type &amp;bsol;* IsCompareTo */) const {
539      if (params_type::template can_have_multiple_equivalent_keys&lt;K&gt;()) {
540        MatchKind exact_match = MatchKind::kNe;
541        while (s != e) {
542          const size_type mid = (s + e) &gt;&gt; 1;
543          const absl::weak_ordering c = comp(key(mid), k);
544          if (c &lt; 0) {
545            s = mid + 1;
546          } else {
547            e = mid;
548            if (c == 0) {
549              exact_match = MatchKind::kEq;
550            }
551          }
552        }
553        return {s, exact_match};
554      } else {  
555        while (s != e) {
556          const size_type mid = (s + e) &gt;&gt; 1;
557          const absl::weak_ordering c = comp(key(mid), k);
558          if (c &lt; 0) {
559            s = mid + 1;
560          } else if (c &gt; 0) {
561            e = mid;
562          } else {
563            return {mid, MatchKind::kEq};
564          }
565        }
566        return {s, MatchKind::kNe};
567      }
568    }
569    template &lt;typename Compare&gt;
570    bool is_ordered_correctly(field_type i, const Compare &amp;comp) const {
571      if (std::is_base_of&lt;BtreeTestOnlyCheckedCompareOptOutBase,
572                          Compare&gt;::value ||
573          params_type::kIsKeyCompareStringAdapted) {
574        return true;
575      }
576      const auto compare = [&amp;](field_type a, field_type b) {
577        const absl::weak_ordering cmp =
578            compare_internal::do_three_way_comparison(comp, key(a), key(b));
579        return cmp &lt; 0 ? -1 : cmp &gt; 0 ? 1 : 0;
580      };
581      int cmp = -1;
582      constexpr bool kCanHaveEquivKeys =
583          params_type::template can_have_multiple_equivalent_keys&lt;key_type&gt;();
584      for (field_type j = start(); j &lt; finish(); ++j) {
585        if (j == i) {
586          if (cmp &gt; 0) return false;
587          continue;
588        }
589        int new_cmp = compare(j, i);
590        if (new_cmp &lt; cmp || (!kCanHaveEquivKeys &amp;&amp; new_cmp == 0)) return false;
591        cmp = new_cmp;
592      }
593      return true;
594    }
595    template &lt;typename... Args&gt;
596    void emplace_value(field_type i, allocator_type *alloc, Args &amp;&amp;...args);
597    void remove_values(field_type i, field_type to_erase, allocator_type *alloc);
598    void rebalance_right_to_left(field_type to_move, btree_node *right,
599                                 allocator_type *alloc);
600    void rebalance_left_to_right(field_type to_move, btree_node *right,
601                                 allocator_type *alloc);
602    void split(int insert_position, btree_node *dest, allocator_type *alloc);
603    void merge(btree_node *src, allocator_type *alloc);
604    void init_leaf(field_type position, field_type max_count,
605                   btree_node *parent) {
606      set_generation(0);
607      set_parent(parent);
608      set_position(position);
609      set_start(0);
610      set_finish(0);
611      set_max_count(max_count);
612      absl::container_internal::SanitizerPoisonMemoryRegion(
613          start_slot(), max_count * sizeof(slot_type));
614    }
615    void init_internal(field_type position, btree_node *parent) {
616      init_leaf(position, kNodeSlots, parent);
617      set_max_count(kInternalNodeMaxCount);
618      absl::container_internal::SanitizerPoisonMemoryRegion(
619          &amp;mutable_child(start()), (kNodeSlots + 1) * sizeof(btree_node *));
620    }
621    static void deallocate(const size_type size, btree_node *node,
622                           allocator_type *alloc) {
623      absl::container_internal::SanitizerUnpoisonMemoryRegion(node, size);
624      absl::container_internal::Deallocate&lt;Alignment()&gt;(alloc, node, size);
625    }
626    static void clear_and_delete(btree_node *node, allocator_type *alloc);
627   private:
628    template &lt;typename... Args&gt;
629    void value_init(const field_type i, allocator_type *alloc, Args &amp;&amp;...args) {
630      next_generation();
631      absl::container_internal::SanitizerUnpoisonObject(slot(i));
632      params_type::construct(alloc, slot(i), std::forward&lt;Args&gt;(args)...);
633    }
634    void value_destroy(const field_type i, allocator_type *alloc) {
635      next_generation();
636      params_type::destroy(alloc, slot(i));
637      absl::container_internal::SanitizerPoisonObject(slot(i));
638    }
639    void value_destroy_n(const field_type i, const field_type n,
640                         allocator_type *alloc) {
641      next_generation();
642      for (slot_type *s = slot(i), *end = slot(i + n); s != end; ++s) {
643        params_type::destroy(alloc, s);
644        absl::container_internal::SanitizerPoisonObject(s);
645      }
646    }
647    static void transfer(slot_type *dest, slot_type *src, allocator_type *alloc) {
648      absl::container_internal::SanitizerUnpoisonObject(dest);
649      params_type::transfer(alloc, dest, src);
650      absl::container_internal::SanitizerPoisonObject(src);
651    }
652    void transfer(const size_type dest_i, const size_type src_i,
653                  btree_node *src_node, allocator_type *alloc) {
654      next_generation();
655      transfer(slot(dest_i), src_node-&gt;slot(src_i), alloc);
656    }
657    void transfer_n(const size_type n, const size_type dest_i,
658                    const size_type src_i, btree_node *src_node,
659                    allocator_type *alloc) {
660      next_generation();
661      for (slot_type *src = src_node-&gt;slot(src_i), *end = src + n,
662                     *dest = slot(dest_i);
663           src != end; ++src, ++dest) {
664        transfer(dest, src, alloc);
665      }
666    }
667    void transfer_n_backward(const size_type n, const size_type dest_i,
668                             const size_type src_i, btree_node *src_node,
669                             allocator_type *alloc) {
670      next_generation();
671      for (slot_type *src = src_node-&gt;slot(src_i + n), *end = src - n,
672                     *dest = slot(dest_i + n);
673           src != end; --src, --dest) {
674        transfer(dest - 1, src - 1, alloc);
675      }
676    }
677    template &lt;typename P&gt;
678    friend class btree;
679    template &lt;typename N, typename R, typename P&gt;
680    friend class btree_iterator;
681    friend class BtreeNodePeer;
682    friend struct btree_access;
683  };
684  template &lt;typename Node&gt;
685  bool AreNodesFromSameContainer(const Node *node_a, const Node *node_b) {
686    if (node_a == nullptr || node_b == nullptr) return true;
<span onclick='openModal()' class='match'>687    while (!node_a-&gt;is_root()) node_a = node_a-&gt;parent();
688    while (!node_b-&gt;is_root()) node_b = node_b-&gt;parent();
</span>689    return node_a == node_b;
690  }
691  class btree_iterator_generation_info_enabled {
692   public:
693    explicit btree_iterator_generation_info_enabled(uint32_t g)
694        : generation_(g) {}
695    template &lt;typename Node&gt;
696    void update_generation(const Node *node) {
697      if (node != nullptr) generation_ = node-&gt;generation();
698    }
699    uint32_t generation() const { return generation_; }
700    template &lt;typename Node&gt;
701    void assert_valid_generation(const Node *node) const {
702      if (node != nullptr &amp;&amp; node-&gt;generation() != generation_) {
703        ABSL_INTERNAL_LOG(
704            FATAL,
705            &quot;Attempting to use an invalidated iterator. The corresponding b-tree &quot;
706            &quot;container has been mutated since this iterator was constructed.&quot;);
707      }
708    }
709   private:
710    uint32_t generation_;
711  };
712  class btree_iterator_generation_info_disabled {
713   public:
714    explicit btree_iterator_generation_info_disabled(uint32_t) {}
715    static void update_generation(const void *) {}
716    static uint32_t generation() { return 0; }
717    static void assert_valid_generation(const void *) {}
718  };
719  #ifdef ABSL_BTREE_ENABLE_GENERATIONS
720  using btree_iterator_generation_info = btree_iterator_generation_info_enabled;
721  #else
722  using btree_iterator_generation_info = btree_iterator_generation_info_disabled;
723  #endif
724  template &lt;typename Node, typename Reference, typename Pointer&gt;
725  class btree_iterator : private btree_iterator_generation_info {
726    using field_type = typename Node::field_type;
727    using key_type = typename Node::key_type;
728    using size_type = typename Node::size_type;
729    using params_type = typename Node::params_type;
730    using is_map_container = typename params_type::is_map_container;
731    using node_type = Node;
732    using normal_node = typename std::remove_const&lt;Node&gt;::type;
733    using const_node = const Node;
734    using normal_pointer = typename params_type::pointer;
735    using normal_reference = typename params_type::reference;
736    using const_pointer = typename params_type::const_pointer;
737    using const_reference = typename params_type::const_reference;
738    using slot_type = typename params_type::slot_type;
739    using iterator =
740       btree_iterator&lt;normal_node, normal_reference, normal_pointer&gt;;
741    using const_iterator =
742        btree_iterator&lt;const_node, const_reference, const_pointer&gt;;
743   public:
744    using difference_type = typename Node::difference_type;
745    using value_type = typename params_type::value_type;
746    using pointer = Pointer;
747    using reference = Reference;
748    using iterator_category = std::bidirectional_iterator_tag;
749    btree_iterator() : btree_iterator(nullptr, -1) {}
750    explicit btree_iterator(Node *n) : btree_iterator(n, n-&gt;start()) {}
751    btree_iterator(Node *n, int p)
752        : btree_iterator_generation_info(n != nullptr ? n-&gt;generation()
753                                                      : ~uint32_t{}),
754          node_(n),
755          position_(p) {}
756    template &lt;typename N, typename R, typename P,
757              absl::enable_if_t&lt;
758                  std::is_same&lt;btree_iterator&lt;N, R, P&gt;, iterator&gt;::value &amp;&amp;
759                      std::is_same&lt;btree_iterator, const_iterator&gt;::value,
760                  int&gt; = 0&gt;
761    btree_iterator(const btree_iterator&lt;N, R, P&gt; other)  
762        : btree_iterator_generation_info(other),
763          node_(other.node_),
764          position_(other.position_) {}
765    bool operator==(const iterator &amp;other) const {
766      return Equals(other);
767    }
768    bool operator==(const const_iterator &amp;other) const {
769      return Equals(other);
770    }
771    bool operator!=(const iterator &amp;other) const {
772      return !Equals(other);
773    }
774    bool operator!=(const const_iterator &amp;other) const {
775      return !Equals(other);
776    }
777    difference_type operator-(const_iterator other) const {
778      if (node_ == other.node_) {
779        if (node_-&gt;is_leaf()) return position_ - other.position_;
780        if (position_ == other.position_) return 0;
781      }
782      return distance_slow(other);
783    }
784    reference operator*() const {
785      ABSL_HARDENING_ASSERT(node_ != nullptr);
786      assert_valid_generation(node_);
787      ABSL_HARDENING_ASSERT(position_ &gt;= node_-&gt;start());
788      if (position_ &gt;= node_-&gt;finish()) {
789        ABSL_HARDENING_ASSERT(!IsEndIterator() &amp;&amp; &quot;Dereferencing end() iterator&quot;);
790        ABSL_HARDENING_ASSERT(position_ &lt; node_-&gt;finish());
791      }
792      return node_-&gt;value(static_cast&lt;field_type&gt;(position_));
793    }
794    pointer operator-&gt;() const { return &amp;operator*(); }
795    btree_iterator &amp;operator++() {
796      increment();
797      return *this;
798    }
799    btree_iterator &amp;operator--() {
800      decrement();
801      return *this;
802    }
803    btree_iterator operator++(int) {
804      btree_iterator tmp = *this;
805      ++*this;
806      return tmp;
807    }
808    btree_iterator operator--(int) {
809      btree_iterator tmp = *this;
810      --*this;
811      return tmp;
812    }
813   private:
814    friend iterator;
815    friend const_iterator;
816    template &lt;typename Params&gt;
817    friend class btree;
818    template &lt;typename Tree&gt;
819    friend class btree_container;
820    template &lt;typename Tree&gt;
821    friend class btree_set_container;
822    template &lt;typename Tree&gt;
823    friend class btree_map_container;
824    template &lt;typename Tree&gt;
825    friend class btree_multiset_container;
826    template &lt;typename TreeType, typename CheckerType&gt;
827    friend class base_checker;
828    friend struct btree_access;
829    template &lt;typename N, typename R, typename P,
830              absl::enable_if_t&lt;
831                  std::is_same&lt;btree_iterator&lt;N, R, P&gt;, const_iterator&gt;::value &amp;&amp;
832                      std::is_same&lt;btree_iterator, iterator&gt;::value,
833                  int&gt; = 0&gt;
834    explicit btree_iterator(const btree_iterator&lt;N, R, P&gt; other)
835        : btree_iterator_generation_info(other.generation()),
836          node_(const_cast&lt;node_type *&gt;(other.node_)),
837          position_(other.position_) {}
838    bool Equals(const const_iterator other) const {
839      ABSL_HARDENING_ASSERT(((node_ == nullptr &amp;&amp; other.node_ == nullptr) ||
840                             (node_ != nullptr &amp;&amp; other.node_ != nullptr)) &amp;&amp;
841                            &quot;Comparing default-constructed iterator with &quot;
842                            &quot;non-default-constructed iterator.&quot;);
843      assert(AreNodesFromSameContainer(node_, other.node_) &amp;&amp;
844             &quot;Comparing iterators from different containers.&quot;);
845      assert_valid_generation(node_);
846      other.assert_valid_generation(other.node_);
847      return node_ == other.node_ &amp;&amp; position_ == other.position_;
848    }
849    bool IsEndIterator() const {
850      if (position_ != node_-&gt;finish()) return false;
851      node_type *node = node_;
852      while (!node-&gt;is_root()) {
853        if (node-&gt;position() != node-&gt;parent()-&gt;finish()) return false;
854        node = node-&gt;parent();
855      }
856      return true;
857    }
858    difference_type distance_slow(const_iterator other) const;
859    void increment() {
860      assert_valid_generation(node_);
861      if (node_-&gt;is_leaf() &amp;&amp; ++position_ &lt; node_-&gt;finish()) {
862        return;
863      }
864      increment_slow();
865    }
866    void increment_slow();
867    void decrement() {
868      assert_valid_generation(node_);
869      if (node_-&gt;is_leaf() &amp;&amp; --position_ &gt;= node_-&gt;start()) {
870        return;
871      }
872      decrement_slow();
873    }
874    void decrement_slow();
875    const key_type &amp;key() const {
876      return node_-&gt;key(static_cast&lt;size_type&gt;(position_));
877    }
878    decltype(std::declval&lt;Node *&gt;()-&gt;slot(0)) slot() {
879      return node_-&gt;slot(static_cast&lt;size_type&gt;(position_));
880    }
881    void update_generation() {
882      btree_iterator_generation_info::update_generation(node_);
883    }
884    Node *node_;
885    int position_;
886  };
887  template &lt;typename Params&gt;
888  class btree {
889    using node_type = btree_node&lt;Params&gt;;
890    using is_key_compare_to = typename Params::is_key_compare_to;
891    using field_type = typename node_type::field_type;
892    struct alignas(node_type::Alignment()) EmptyNodeType : node_type {
893      using field_type = typename node_type::field_type;
894      node_type *parent;
895  #ifdef ABSL_BTREE_ENABLE_GENERATIONS
896      uint32_t generation = 0;
897  #endif
898      field_type position = 0;
899      field_type start = 0;
900      field_type finish = 0;
901      field_type max_count = node_type::kInternalNodeMaxCount + 1;
902  #ifdef _MSC_VER
903      EmptyNodeType() : parent(this) {}
904  #else
905      explicit constexpr EmptyNodeType(node_type *p) : parent(p) {}
906  #endif
907    };
908    static node_type *EmptyNode() {
909  #ifdef _MSC_VER
910      static EmptyNodeType *empty_node = new EmptyNodeType;
911      assert(empty_node-&gt;parent == empty_node);
912      return empty_node;
913  #else
914      static constexpr EmptyNodeType empty_node(
915          const_cast&lt;EmptyNodeType *&gt;(&amp;empty_node));
916      return const_cast&lt;EmptyNodeType *&gt;(&amp;empty_node);
917  #endif
918    }
919    enum : uint32_t {
920      kNodeSlots = node_type::kNodeSlots,
921      kMinNodeValues = kNodeSlots / 2,
922    };
923    struct node_stats {
924      using size_type = typename Params::size_type;
925      node_stats(size_type l, size_type i) : leaf_nodes(l), internal_nodes(i) {}
926      node_stats &amp;operator+=(const node_stats &amp;other) {
927        leaf_nodes += other.leaf_nodes;
928        internal_nodes += other.internal_nodes;
929        return *this;
930      }
931      size_type leaf_nodes;
932      size_type internal_nodes;
933    };
934   public:
935    using key_type = typename Params::key_type;
936    using value_type = typename Params::value_type;
937    using size_type = typename Params::size_type;
938    using difference_type = typename Params::difference_type;
939    using key_compare = typename Params::key_compare;
940    using original_key_compare = typename Params::original_key_compare;
941    using value_compare = typename Params::value_compare;
942    using allocator_type = typename Params::allocator_type;
943    using reference = typename Params::reference;
944    using const_reference = typename Params::const_reference;
945    using pointer = typename Params::pointer;
946    using const_pointer = typename Params::const_pointer;
947    using iterator =
948        typename btree_iterator&lt;node_type, reference, pointer&gt;::iterator;
949    using const_iterator = typename iterator::const_iterator;
950    using reverse_iterator = std::reverse_iterator&lt;iterator&gt;;
951    using const_reverse_iterator = std::reverse_iterator&lt;const_iterator&gt;;
952    using node_handle_type = node_handle&lt;Params, Params, allocator_type&gt;;
953    using params_type = Params;
954    using slot_type = typename Params::slot_type;
955   private:
956    template &lt;typename Btree&gt;
957    void copy_or_move_values_in_order(Btree &amp;other);
958    constexpr static bool static_assert_validation();
959   public:
960    btree(const key_compare &amp;comp, const allocator_type &amp;alloc)
961        : root_(EmptyNode()), rightmost_(comp, alloc, EmptyNode()), size_(0) {}
962    btree(const btree &amp;other) : btree(other, other.allocator()) {}
963    btree(const btree &amp;other, const allocator_type &amp;alloc)
964        : btree(other.key_comp(), alloc) {
965      copy_or_move_values_in_order(other);
966    }
967    btree(btree &amp;&amp;other) noexcept
968        : root_(absl::exchange(other.root_, EmptyNode())),
969          rightmost_(std::move(other.rightmost_)),
970          size_(absl::exchange(other.size_, 0u)) {
971      other.mutable_rightmost() = EmptyNode();
972    }
973    btree(btree &amp;&amp;other, const allocator_type &amp;alloc)
974        : btree(other.key_comp(), alloc) {
975      if (alloc == other.allocator()) {
976        swap(other);
977      } else {
978        copy_or_move_values_in_order(other);
979      }
980    }
981    ~btree() {
982      static_assert(static_assert_validation(), &quot;This call must be elided.&quot;);
983      clear();
984    }
985    btree &amp;operator=(const btree &amp;other);
986    btree &amp;operator=(btree &amp;&amp;other) noexcept;
987    iterator begin() { return iterator(leftmost()); }
988    const_iterator begin() const { return const_iterator(leftmost()); }
989    iterator end() { return iterator(rightmost(), rightmost()-&gt;finish()); }
990    const_iterator end() const {
991      return const_iterator(rightmost(), rightmost()-&gt;finish());
992    }
993    reverse_iterator rbegin() { return reverse_iterator(end()); }
994    const_reverse_iterator rbegin() const {
995      return const_reverse_iterator(end());
996    }
997    reverse_iterator rend() { return reverse_iterator(begin()); }
998    const_reverse_iterator rend() const {
999      return const_reverse_iterator(begin());
1000    }
1001    template &lt;typename K&gt;
1002    iterator lower_bound(const K &amp;key) {
1003      return internal_end(internal_lower_bound(key).value);
1004    }
1005    template &lt;typename K&gt;
1006    const_iterator lower_bound(const K &amp;key) const {
1007      return internal_end(internal_lower_bound(key).value);
1008    }
1009    template &lt;typename K&gt;
1010    std::pair&lt;iterator, bool&gt; lower_bound_equal(const K &amp;key) const;
1011    template &lt;typename K&gt;
1012    iterator upper_bound(const K &amp;key) {
1013      return internal_end(internal_upper_bound(key));
1014    }
1015    template &lt;typename K&gt;
1016    const_iterator upper_bound(const K &amp;key) const {
1017      return internal_end(internal_upper_bound(key));
1018    }
1019    template &lt;typename K&gt;
1020    std::pair&lt;iterator, iterator&gt; equal_range(const K &amp;key);
1021    template &lt;typename K&gt;
1022    std::pair&lt;const_iterator, const_iterator&gt; equal_range(const K &amp;key) const {
1023      return const_cast&lt;btree *&gt;(this)-&gt;equal_range(key);
1024    }
1025    template &lt;typename K, typename... Args&gt;
1026    std::pair&lt;iterator, bool&gt; insert_unique(const K &amp;key, Args &amp;&amp;...args);
1027    template &lt;typename K, typename... Args&gt;
1028    std::pair&lt;iterator, bool&gt; insert_hint_unique(iterator position, const K &amp;key,
1029                                                 Args &amp;&amp;...args);
1030    template &lt;typename InputIterator,
1031              typename = decltype(std::declval&lt;const key_compare &amp;&gt;()(
1032                  params_type::key(*std::declval&lt;InputIterator&gt;()),
1033                  std::declval&lt;const key_type &amp;&gt;()))&gt;
1034    void insert_iterator_unique(InputIterator b, InputIterator e, int);
1035    template &lt;typename InputIterator&gt;
1036    void insert_iterator_unique(InputIterator b, InputIterator e, char);
1037    template &lt;typename ValueType&gt;
1038    iterator insert_multi(const key_type &amp;key, ValueType &amp;&amp;v);
1039    template &lt;typename ValueType&gt;
1040    iterator insert_multi(ValueType &amp;&amp;v) {
1041      return insert_multi(params_type::key(v), std::forward&lt;ValueType&gt;(v));
1042    }
1043    template &lt;typename ValueType&gt;
1044    iterator insert_hint_multi(iterator position, ValueType &amp;&amp;v);
1045    template &lt;typename InputIterator&gt;
1046    void insert_iterator_multi(InputIterator b,
1047                               InputIterator e);
1048    iterator erase(iterator iter);
1049    std::pair&lt;size_type, iterator&gt; erase_range(iterator begin, iterator end);
1050    template &lt;typename K&gt;
1051    iterator find(const K &amp;key) {
1052      return internal_end(internal_find(key));
1053    }
1054    template &lt;typename K&gt;
1055    const_iterator find(const K &amp;key) const {
1056      return internal_end(internal_find(key));
1057    }
1058    void clear();
1059    void swap(btree &amp;other);
1060    const key_compare &amp;key_comp() const noexcept {
1061      return rightmost_.template get&lt;0&gt;();
1062    }
1063    template &lt;typename K1, typename K2&gt;
1064    bool compare_keys(const K1 &amp;a, const K2 &amp;b) const {
1065      return compare_internal::compare_result_as_less_than(key_comp()(a, b));
1066    }
1067    value_compare value_comp() const {
1068      return value_compare(original_key_compare(key_comp()));
1069    }
1070    void verify() const;
1071    size_type size() const { return size_; }
1072    size_type max_size() const { return (std::numeric_limits&lt;size_type&gt;::max)(); }
1073    bool empty() const { return size_ == 0; }
1074    size_type height() const {
1075      size_type h = 0;
1076      if (!empty()) {
1077        const node_type *n = root();
1078        do {
1079          ++h;
1080          n = n-&gt;parent();
1081        } while (n != root());
1082      }
1083      return h;
1084    }
1085    size_type leaf_nodes() const { return internal_stats(root()).leaf_nodes; }
1086    size_type internal_nodes() const {
1087      return internal_stats(root()).internal_nodes;
1088    }
1089    size_type nodes() const {
1090      node_stats stats = internal_stats(root());
1091      return stats.leaf_nodes + stats.internal_nodes;
1092    }
1093    size_type bytes_used() const {
1094      node_stats stats = internal_stats(root());
1095      if (stats.leaf_nodes == 1 &amp;&amp; stats.internal_nodes == 0) {
1096        return sizeof(*this) + node_type::LeafSize(root()-&gt;max_count());
1097      } else {
1098        return sizeof(*this) + stats.leaf_nodes * node_type::LeafSize() +
1099               stats.internal_nodes * node_type::InternalSize();
1100      }
1101    }
1102    static double average_bytes_per_value() {
1103      const double expected_values_per_node = (kNodeSlots + kMinNodeValues) / 2.0;
1104      return node_type::LeafSize() / expected_values_per_node;
1105    }
1106    double fullness() const {
1107      if (empty()) return 0.0;
1108      return static_cast&lt;double&gt;(size()) / (nodes() * kNodeSlots);
1109    }
1110    double overhead() const {
1111      if (empty()) return 0.0;
1112      return (bytes_used() - size() * sizeof(value_type)) /
1113             static_cast&lt;double&gt;(size());
1114    }
1115    allocator_type get_allocator() const { return allocator(); }
1116   private:
1117    friend struct btree_access;
1118    node_type *root() { return root_; }
1119    const node_type *root() const { return root_; }
1120    node_type *&amp;mutable_root() noexcept { return root_; }
1121    node_type *rightmost() { return rightmost_.template get&lt;2&gt;(); }
1122    const node_type *rightmost() const { return rightmost_.template get&lt;2&gt;(); }
1123    node_type *&amp;mutable_rightmost() noexcept {
1124      return rightmost_.template get&lt;2&gt;();
1125    }
1126    key_compare *mutable_key_comp() noexcept {
1127      return &amp;rightmost_.template get&lt;0&gt;();
1128    }
1129    node_type *leftmost() { return root()-&gt;parent(); }
1130    const node_type *leftmost() const { return root()-&gt;parent(); }
1131    allocator_type *mutable_allocator() noexcept {
1132      return &amp;rightmost_.template get&lt;1&gt;();
1133    }
1134    const allocator_type &amp;allocator() const noexcept {
1135      return rightmost_.template get&lt;1&gt;();
1136    }
1137    node_type *allocate(size_type size) {
1138      return reinterpret_cast&lt;node_type *&gt;(
1139          absl::container_internal::Allocate&lt;node_type::Alignment()&gt;(
1140              mutable_allocator(), size));
1141    }
1142    node_type *new_internal_node(field_type position, node_type *parent) {
1143      node_type *n = allocate(node_type::InternalSize());
1144      n-&gt;init_internal(position, parent);
1145      return n;
1146    }
1147    node_type *new_leaf_node(field_type position, node_type *parent) {
1148      node_type *n = allocate(node_type::LeafSize());
1149      n-&gt;init_leaf(position, kNodeSlots, parent);
1150      return n;
1151    }
1152    node_type *new_leaf_root_node(field_type max_count) {
1153      node_type *n = allocate(node_type::LeafSize(max_count));
1154      n-&gt;init_leaf(&amp;bsol;*position=*/0, max_count, &amp;bsol;*parent=*/n);
1155      return n;
1156    }
1157    iterator rebalance_after_delete(iterator iter);
1158    void rebalance_or_split(iterator *iter);
1159    void merge_nodes(node_type *left, node_type *right);
1160    bool try_merge_or_rebalance(iterator *iter);
1161    void try_shrink();
1162    iterator internal_end(iterator iter) {
1163      return iter.node_ != nullptr ? iter : end();
1164    }
1165    const_iterator internal_end(const_iterator iter) const {
1166      return iter.node_ != nullptr ? iter : end();
1167    }
1168    template &lt;typename... Args&gt;
1169    iterator internal_emplace(iterator iter, Args &amp;&amp;...args);
1170    template &lt;typename IterType&gt;
1171    static IterType internal_last(IterType iter);
1172    template &lt;typename K&gt;
1173    SearchResult&lt;iterator, is_key_compare_to::value&gt; internal_locate(
1174        const K &amp;key) const;
1175    template &lt;typename K&gt;
1176    SearchResult&lt;iterator, is_key_compare_to::value&gt; internal_lower_bound(
1177        const K &amp;key) const;
1178    template &lt;typename K&gt;
1179    iterator internal_upper_bound(const K &amp;key) const;
1180    template &lt;typename K&gt;
1181    iterator internal_find(const K &amp;key) const;
1182    size_type internal_verify(const node_type *node, const key_type *lo,
1183                              const key_type *hi) const;
1184    node_stats internal_stats(const node_type *node) const {
1185      if (node == nullptr || (node == root() &amp;&amp; empty())) {
1186        return node_stats(0, 0);
1187      }
1188      if (node-&gt;is_leaf()) {
1189        return node_stats(1, 0);
1190      }
1191      node_stats res(0, 1);
1192      for (int i = node-&gt;start(); i &lt;= node-&gt;finish(); ++i) {
1193        res += internal_stats(node-&gt;child(i));
1194      }
1195      return res;
1196    }
1197    node_type *root_;
1198    absl::container_internal::CompressedTuple&lt;key_compare, allocator_type,
1199                                              node_type *&gt;
1200        rightmost_;
1201    size_type size_;
1202  };
1203  template &lt;typename P&gt;
1204  template &lt;typename... Args&gt;
1205  inline void btree_node&lt;P&gt;::emplace_value(const field_type i,
1206                                           allocator_type *alloc,
1207                                           Args &amp;&amp;...args) {
1208    assert(i &gt;= start());
1209    assert(i &lt;= finish());
1210    if (i &lt; finish()) {
1211      transfer_n_backward(finish() - i, &amp;bsol;*dest_i=*/i + 1, &amp;bsol;*src_i=*/i, this,
1212                          alloc);
1213    }
1214    value_init(static_cast&lt;field_type&gt;(i), alloc, std::forward&lt;Args&gt;(args)...);
1215    set_finish(finish() + 1);
1216    if (is_internal() &amp;&amp; finish() &gt; i + 1) {
1217      for (field_type j = finish(); j &gt; i + 1; --j) {
1218        set_child(j, child(j - 1));
1219      }
1220      clear_child(i + 1);
1221    }
1222  }
1223  template &lt;typename P&gt;
1224  inline void btree_node&lt;P&gt;::remove_values(const field_type i,
1225                                           const field_type to_erase,
1226                                           allocator_type *alloc) {
1227    value_destroy_n(i, to_erase, alloc);
1228    const field_type orig_finish = finish();
1229    const field_type src_i = i + to_erase;
1230    transfer_n(orig_finish - src_i, i, src_i, this, alloc);
1231    if (is_internal()) {
1232      for (field_type j = 0; j &lt; to_erase; ++j) {
1233        clear_and_delete(child(i + j + 1), alloc);
1234      }
1235      for (field_type j = i + to_erase + 1; j &lt;= orig_finish; ++j) {
1236        set_child(j - to_erase, child(j));
1237        clear_child(j);
1238      }
1239    }
1240    set_finish(orig_finish - to_erase);
1241  }
1242  template &lt;typename P&gt;
1243  void btree_node&lt;P&gt;::rebalance_right_to_left(field_type to_move,
1244                                              btree_node *right,
1245                                              allocator_type *alloc) {
1246    assert(parent() == right-&gt;parent());
1247    assert(position() + 1 == right-&gt;position());
1248    assert(right-&gt;count() &gt;= count());
1249    assert(to_move &gt;= 1);
1250    assert(to_move &lt;= right-&gt;count());
1251    transfer(finish(), position(), parent(), alloc);
1252    transfer_n(to_move - 1, finish() + 1, right-&gt;start(), right, alloc);
1253    parent()-&gt;transfer(position(), right-&gt;start() + to_move - 1, right, alloc);
1254    right-&gt;transfer_n(right-&gt;count() - to_move, right-&gt;start(),
1255                      right-&gt;start() + to_move, right, alloc);
1256    if (is_internal()) {
1257      for (field_type i = 0; i &lt; to_move; ++i) {
1258        init_child(finish() + i + 1, right-&gt;child(i));
1259      }
1260      for (field_type i = right-&gt;start(); i &lt;= right-&gt;finish() - to_move; ++i) {
1261        assert(i + to_move &lt;= right-&gt;max_count());
1262        right-&gt;init_child(i, right-&gt;child(i + to_move));
1263        right-&gt;clear_child(i + to_move);
1264      }
1265    }
1266    set_finish(finish() + to_move);
1267    right-&gt;set_finish(right-&gt;finish() - to_move);
1268  }
1269  template &lt;typename P&gt;
1270  void btree_node&lt;P&gt;::rebalance_left_to_right(field_type to_move,
1271                                              btree_node *right,
1272                                              allocator_type *alloc) {
1273    assert(parent() == right-&gt;parent());
1274    assert(position() + 1 == right-&gt;position());
1275    assert(count() &gt;= right-&gt;count());
1276    assert(to_move &gt;= 1);
1277    assert(to_move &lt;= count());
1278    right-&gt;transfer_n_backward(right-&gt;count(), right-&gt;start() + to_move,
1279                               right-&gt;start(), right, alloc);
1280    right-&gt;transfer(right-&gt;start() + to_move - 1, position(), parent(), alloc);
1281    right-&gt;transfer_n(to_move - 1, right-&gt;start(), finish() - (to_move - 1), this,
1282                      alloc);
1283    parent()-&gt;transfer(position(), finish() - to_move, this, alloc);
1284    if (is_internal()) {
1285      for (field_type i = right-&gt;finish() + 1; i &gt; right-&gt;start(); --i) {
1286        right-&gt;init_child(i - 1 + to_move, right-&gt;child(i - 1));
1287        right-&gt;clear_child(i - 1);
1288      }
1289      for (field_type i = 1; i &lt;= to_move; ++i) {
1290        right-&gt;init_child(i - 1, child(finish() - to_move + i));
1291        clear_child(finish() - to_move + i);
1292      }
1293    }
1294    set_finish(finish() - to_move);
1295    right-&gt;set_finish(right-&gt;finish() + to_move);
1296  }
1297  template &lt;typename P&gt;
1298  void btree_node&lt;P&gt;::split(const int insert_position, btree_node *dest,
1299                            allocator_type *alloc) {
1300    assert(dest-&gt;count() == 0);
1301    assert(max_count() == kNodeSlots);
1302    assert(position() + 1 == dest-&gt;position());
1303    assert(parent() == dest-&gt;parent());
1304    if (insert_position == start()) {
1305      dest-&gt;set_finish(dest-&gt;start() + finish() - 1);
1306    } else if (insert_position == kNodeSlots) {
1307      dest-&gt;set_finish(dest-&gt;start());
1308    } else {
1309      dest-&gt;set_finish(dest-&gt;start() + count() / 2);
1310    }
1311    set_finish(finish() - dest-&gt;count());
1312    assert(count() &gt;= 1);
1313    dest-&gt;transfer_n(dest-&gt;count(), dest-&gt;start(), finish(), this, alloc);
1314    --mutable_finish();
1315    parent()-&gt;emplace_value(position(), alloc, finish_slot());
1316    value_destroy(finish(), alloc);
1317    parent()-&gt;set_child_noupdate_position(position() + 1, dest);
1318    if (is_internal()) {
1319      for (field_type i = dest-&gt;start(), j = finish() + 1; i &lt;= dest-&gt;finish();
1320           ++i, ++j) {
1321        assert(child(j) != nullptr);
1322        dest-&gt;init_child(i, child(j));
1323        clear_child(j);
1324      }
1325    }
1326  }
1327  template &lt;typename P&gt;
1328  void btree_node&lt;P&gt;::merge(btree_node *src, allocator_type *alloc) {
1329    assert(parent() == src-&gt;parent());
1330    assert(position() + 1 == src-&gt;position());
1331    value_init(finish(), alloc, parent()-&gt;slot(position()));
1332    transfer_n(src-&gt;count(), finish() + 1, src-&gt;start(), src, alloc);
1333    if (is_internal()) {
1334      for (field_type i = src-&gt;start(), j = finish() + 1; i &lt;= src-&gt;finish();
1335           ++i, ++j) {
1336        init_child(j, src-&gt;child(i));
1337        src-&gt;clear_child(i);
1338      }
1339    }
1340    set_finish(start() + 1 + count() + src-&gt;count());
1341    src-&gt;set_finish(src-&gt;start());
1342    parent()-&gt;remove_values(position(), &amp;bsol;*to_erase=*/1, alloc);
1343  }
1344  template &lt;typename P&gt;
1345  void btree_node&lt;P&gt;::clear_and_delete(btree_node *node, allocator_type *alloc) {
1346    if (node-&gt;is_leaf()) {
1347      node-&gt;value_destroy_n(node-&gt;start(), node-&gt;count(), alloc);
1348      deallocate(LeafSize(node-&gt;max_count()), node, alloc);
1349      return;
1350    }
1351    if (node-&gt;count() == 0) {
1352      deallocate(InternalSize(), node, alloc);
1353      return;
1354    }
1355    btree_node *delete_root_parent = node-&gt;parent();
1356    while (node-&gt;is_internal()) node = node-&gt;start_child();
1357  #ifdef ABSL_BTREE_ENABLE_GENERATIONS
1358    btree_node *leftmost_leaf = node;
1359  #endif
1360    size_type pos = node-&gt;position();
1361    btree_node *parent = node-&gt;parent();
1362    for (;;) {
1363      assert(pos &lt;= parent-&gt;finish());
1364      do {
1365        node = parent-&gt;child(static_cast&lt;field_type&gt;(pos));
1366        if (node-&gt;is_internal()) {
1367          while (node-&gt;is_internal()) node = node-&gt;start_child();
1368          pos = node-&gt;position();
1369          parent = node-&gt;parent();
1370        }
1371        node-&gt;value_destroy_n(node-&gt;start(), node-&gt;count(), alloc);
1372  #ifdef ABSL_BTREE_ENABLE_GENERATIONS
1373        if (leftmost_leaf != node)
1374  #endif
1375          deallocate(LeafSize(node-&gt;max_count()), node, alloc);
1376        ++pos;
1377      } while (pos &lt;= parent-&gt;finish());
1378      assert(pos &gt; parent-&gt;finish());
1379      do {
1380        node = parent;
1381        pos = node-&gt;position();
1382        parent = node-&gt;parent();
1383        node-&gt;value_destroy_n(node-&gt;start(), node-&gt;count(), alloc);
1384        deallocate(InternalSize(), node, alloc);
1385        if (parent == delete_root_parent) {
1386  #ifdef ABSL_BTREE_ENABLE_GENERATIONS
1387          deallocate(LeafSize(leftmost_leaf-&gt;max_count()), leftmost_leaf, alloc);
1388  #endif
1389          return;
1390        }
1391        ++pos;
1392      } while (pos &gt; parent-&gt;finish());
1393    }
1394  }
1395  template &lt;typename N, typename R, typename P&gt;
1396  auto btree_iterator&lt;N, R, P&gt;::distance_slow(const_iterator other) const
1397      -&gt; difference_type {
1398    const_iterator begin = other;
1399    const_iterator end = *this;
1400    assert(begin.node_ != end.node_ || !begin.node_-&gt;is_leaf() ||
1401           begin.position_ != end.position_);
1402    const node_type *node = begin.node_;
1403    difference_type count = node-&gt;is_leaf() ? -begin.position_ : 0;
1404    if (node-&gt;is_internal()) {
1405      ++count;
1406      node = node-&gt;child(begin.position_ + 1);
1407    }
1408    while (node-&gt;is_internal()) node = node-&gt;start_child();
1409    size_type pos = node-&gt;position();
1410    const node_type *parent = node-&gt;parent();
1411    for (;;) {
1412      assert(pos &lt;= parent-&gt;finish());
1413      do {
1414        node = parent-&gt;child(static_cast&lt;field_type&gt;(pos));
1415        if (node-&gt;is_internal()) {
1416          while (node-&gt;is_internal()) node = node-&gt;start_child();
1417          pos = node-&gt;position();
1418          parent = node-&gt;parent();
1419        }
1420        if (node == end.node_) return count + end.position_;
1421        if (parent == end.node_ &amp;&amp; pos == static_cast&lt;size_type&gt;(end.position_))
1422          return count + node-&gt;count();
1423        count += node-&gt;count() + 1;
1424        ++pos;
1425      } while (pos &lt;= parent-&gt;finish());
1426      assert(pos &gt; parent-&gt;finish());
1427      do {
1428        node = parent;
1429        pos = node-&gt;position();
1430        parent = node-&gt;parent();
1431        if (parent == end.node_ &amp;&amp; pos == static_cast&lt;size_type&gt;(end.position_))
1432          return count - 1;
1433        ++pos;
1434      } while (pos &gt; parent-&gt;finish());
1435    }
1436  }
1437  template &lt;typename N, typename R, typename P&gt;
1438  void btree_iterator&lt;N, R, P&gt;::increment_slow() {
1439    if (node_-&gt;is_leaf()) {
1440      assert(position_ &gt;= node_-&gt;finish());
1441      btree_iterator save(*this);
1442      while (position_ == node_-&gt;finish() &amp;&amp; !node_-&gt;is_root()) {
1443        assert(node_-&gt;parent()-&gt;child(node_-&gt;position()) == node_);
1444        position_ = node_-&gt;position();
1445        node_ = node_-&gt;parent();
1446      }
1447      if (position_ == node_-&gt;finish()) {
1448        *this = save;
1449      }
1450    } else {
1451      assert(position_ &lt; node_-&gt;finish());
1452      node_ = node_-&gt;child(static_cast&lt;field_type&gt;(position_ + 1));
1453      while (node_-&gt;is_internal()) {
1454        node_ = node_-&gt;start_child();
1455      }
1456      position_ = node_-&gt;start();
1457    }
1458  }
1459  template &lt;typename N, typename R, typename P&gt;
1460  void btree_iterator&lt;N, R, P&gt;::decrement_slow() {
1461    if (node_-&gt;is_leaf()) {
1462      assert(position_ &lt;= -1);
1463      btree_iterator save(*this);
1464      while (position_ &lt; node_-&gt;start() &amp;&amp; !node_-&gt;is_root()) {
1465        assert(node_-&gt;parent()-&gt;child(node_-&gt;position()) == node_);
1466        position_ = node_-&gt;position() - 1;
1467        node_ = node_-&gt;parent();
1468      }
1469      if (position_ &lt; node_-&gt;start()) {
1470        *this = save;
1471      }
1472    } else {
1473      assert(position_ &gt;= node_-&gt;start());
1474      node_ = node_-&gt;child(static_cast&lt;field_type&gt;(position_));
1475      while (node_-&gt;is_internal()) {
1476        node_ = node_-&gt;child(node_-&gt;finish());
1477      }
1478      position_ = node_-&gt;finish() - 1;
1479    }
1480  }
1481  template &lt;typename P&gt;
1482  template &lt;typename Btree&gt;
1483  void btree&lt;P&gt;::copy_or_move_values_in_order(Btree &amp;other) {
1484    static_assert(std::is_same&lt;btree, Btree&gt;::value ||
1485                      std::is_same&lt;const btree, Btree&gt;::value,
1486                  &quot;Btree type must be same or const.&quot;);
1487    assert(empty());
1488    auto iter = other.begin();
1489    if (iter == other.end()) return;
1490    insert_multi(iter.slot());
1491    ++iter;
1492    for (; iter != other.end(); ++iter) {
1493      internal_emplace(end(), iter.slot());
1494    }
1495  }
1496  template &lt;typename P&gt;
1497  constexpr bool btree&lt;P&gt;::static_assert_validation() {
1498    static_assert(std::is_nothrow_copy_constructible&lt;key_compare&gt;::value,
1499                  &quot;Key comparison must be nothrow copy constructible&quot;);
1500    static_assert(std::is_nothrow_copy_constructible&lt;allocator_type&gt;::value,
1501                  &quot;Allocator must be nothrow copy constructible&quot;);
1502    static_assert(std::is_trivially_copyable&lt;iterator&gt;::value,
1503                  &quot;iterator not trivially copyable.&quot;);
1504    static_assert(
1505        kNodeSlots &lt; (1 &lt;&lt; (8 * sizeof(typename node_type::field_type))),
1506        &quot;target node size too large&quot;);
1507    static_assert(
1508        compare_has_valid_result_type&lt;key_compare, key_type&gt;(),
1509        &quot;key comparison function must return absl::{weak,strong}_ordering or &quot;
1510        &quot;bool.&quot;);
1511    static_assert(node_type::MinimumOverhead() &gt;= sizeof(void *) + 4,
1512                  &quot;node space assumption incorrect&quot;);
1513    return true;
1514  }
1515  template &lt;typename P&gt;
1516  template &lt;typename K&gt;
1517  auto btree&lt;P&gt;::lower_bound_equal(const K &amp;key) const
1518      -&gt; std::pair&lt;iterator, bool&gt; {
1519    const SearchResult&lt;iterator, is_key_compare_to::value&gt; res =
1520        internal_lower_bound(key);
1521    const iterator lower = iterator(internal_end(res.value));
1522    const bool equal = res.HasMatch()
1523                           ? res.IsEq()
1524                           : lower != end() &amp;&amp; !compare_keys(key, lower.key());
1525    return {lower, equal};
1526  }
1527  template &lt;typename P&gt;
1528  template &lt;typename K&gt;
1529  auto btree&lt;P&gt;::equal_range(const K &amp;key) -&gt; std::pair&lt;iterator, iterator&gt; {
1530    const std::pair&lt;iterator, bool&gt; lower_and_equal = lower_bound_equal(key);
1531    const iterator lower = lower_and_equal.first;
1532    if (!lower_and_equal.second) {
1533      return {lower, lower};
1534    }
1535    const iterator next = std::next(lower);
1536    if (!params_type::template can_have_multiple_equivalent_keys&lt;K&gt;()) {
1537      assert(next == end() || compare_keys(key, next.key()));
1538      return {lower, next};
1539    }
1540    if (next == end() || compare_keys(key, next.key())) return {lower, next};
1541    return {lower, upper_bound(key)};
1542  }
1543  template &lt;typename P&gt;
1544  template &lt;typename K, typename... Args&gt;
1545  auto btree&lt;P&gt;::insert_unique(const K &amp;key, Args &amp;&amp;...args)
1546      -&gt; std::pair&lt;iterator, bool&gt; {
1547    if (empty()) {
1548      mutable_root() = mutable_rightmost() = new_leaf_root_node(1);
1549    }
1550    SearchResult&lt;iterator, is_key_compare_to::value&gt; res = internal_locate(key);
1551    iterator iter = res.value;
1552    if (res.HasMatch()) {
1553      if (res.IsEq()) {
1554        return {iter, false};
1555      }
1556    } else {
1557      iterator last = internal_last(iter);
1558      if (last.node_ &amp;&amp; !compare_keys(key, last.key())) {
1559        return {last, false};
1560      }
1561    }
1562    return {internal_emplace(iter, std::forward&lt;Args&gt;(args)...), true};
1563  }
1564  template &lt;typename P&gt;
1565  template &lt;typename K, typename... Args&gt;
1566  inline auto btree&lt;P&gt;::insert_hint_unique(iterator position, const K &amp;key,
1567                                           Args &amp;&amp;...args)
1568      -&gt; std::pair&lt;iterator, bool&gt; {
1569    if (!empty()) {
1570      if (position == end() || compare_keys(key, position.key())) {
1571        if (position == begin() || compare_keys(std::prev(position).key(), key)) {
1572          return {internal_emplace(position, std::forward&lt;Args&gt;(args)...), true};
1573        }
1574      } else if (compare_keys(position.key(), key)) {
1575        ++position;
1576        if (position == end() || compare_keys(key, position.key())) {
1577          return {internal_emplace(position, std::forward&lt;Args&gt;(args)...), true};
1578        }
1579      } else {
1580        return {position, false};
1581      }
1582    }
1583    return insert_unique(key, std::forward&lt;Args&gt;(args)...);
1584  }
1585  template &lt;typename P&gt;
1586  template &lt;typename InputIterator, typename&gt;
1587  void btree&lt;P&gt;::insert_iterator_unique(InputIterator b, InputIterator e, int) {
1588    for (; b != e; ++b) {
1589      insert_hint_unique(end(), params_type::key(*b), *b);
1590    }
1591  }
1592  template &lt;typename P&gt;
1593  template &lt;typename InputIterator&gt;
1594  void btree&lt;P&gt;::insert_iterator_unique(InputIterator b, InputIterator e, char) {
1595    for (; b != e; ++b) {
1596      auto node_handle =
1597          CommonAccess::Construct&lt;node_handle_type&gt;(get_allocator(), *b);
1598      slot_type *slot = CommonAccess::GetSlot(node_handle);
1599      insert_hint_unique(end(), params_type::key(slot), slot);
1600    }
1601  }
1602  template &lt;typename P&gt;
1603  template &lt;typename ValueType&gt;
1604  auto btree&lt;P&gt;::insert_multi(const key_type &amp;key, ValueType &amp;&amp;v) -&gt; iterator {
1605    if (empty()) {
1606      mutable_root() = mutable_rightmost() = new_leaf_root_node(1);
1607    }
1608    iterator iter = internal_upper_bound(key);
1609    if (iter.node_ == nullptr) {
1610      iter = end();
1611    }
1612    return internal_emplace(iter, std::forward&lt;ValueType&gt;(v));
1613  }
1614  template &lt;typename P&gt;
1615  template &lt;typename ValueType&gt;
1616  auto btree&lt;P&gt;::insert_hint_multi(iterator position, ValueType &amp;&amp;v) -&gt; iterator {
1617    if (!empty()) {
1618      const key_type &amp;key = params_type::key(v);
1619      if (position == end() || !compare_keys(position.key(), key)) {
1620        if (position == begin() ||
1621            !compare_keys(key, std::prev(position).key())) {
1622          return internal_emplace(position, std::forward&lt;ValueType&gt;(v));
1623        }
1624      } else {
1625        ++position;
1626        if (position == end() || !compare_keys(position.key(), key)) {
1627          return internal_emplace(position, std::forward&lt;ValueType&gt;(v));
1628        }
1629      }
1630    }
1631    return insert_multi(std::forward&lt;ValueType&gt;(v));
1632  }
1633  template &lt;typename P&gt;
1634  template &lt;typename InputIterator&gt;
1635  void btree&lt;P&gt;::insert_iterator_multi(InputIterator b, InputIterator e) {
1636    for (; b != e; ++b) {
1637      insert_hint_multi(end(), *b);
1638    }
1639  }
1640  template &lt;typename P&gt;
1641  auto btree&lt;P&gt;::operator=(const btree &amp;other) -&gt; btree &amp; {
1642    if (this != &amp;other) {
1643      clear();
1644      *mutable_key_comp() = other.key_comp();
1645      if (absl::allocator_traits&lt;
1646              allocator_type&gt;::propagate_on_container_copy_assignment::value) {
1647        *mutable_allocator() = other.allocator();
1648      }
1649      copy_or_move_values_in_order(other);
1650    }
1651    return *this;
1652  }
1653  template &lt;typename P&gt;
1654  auto btree&lt;P&gt;::operator=(btree &amp;&amp;other) noexcept -&gt; btree &amp; {
1655    if (this != &amp;other) {
1656      clear();
1657      using std::swap;
1658      if (absl::allocator_traits&lt;
1659              allocator_type&gt;::propagate_on_container_copy_assignment::value) {
1660        swap(root_, other.root_);
1661        swap(rightmost_, other.rightmost_);
1662        swap(size_, other.size_);
1663      } else {
1664        if (allocator() == other.allocator()) {
1665          swap(mutable_root(), other.mutable_root());
1666          swap(*mutable_key_comp(), *other.mutable_key_comp());
1667          swap(mutable_rightmost(), other.mutable_rightmost());
1668          swap(size_, other.size_);
1669        } else {
1670          *mutable_key_comp() = other.key_comp();
1671          copy_or_move_values_in_order(other);
1672        }
1673      }
1674    }
1675    return *this;
1676  }
1677  template &lt;typename P&gt;
1678  auto btree&lt;P&gt;::erase(iterator iter) -&gt; iterator {
1679    iter.node_-&gt;value_destroy(static_cast&lt;field_type&gt;(iter.position_),
1680                              mutable_allocator());
1681    iter.update_generation();
1682    const bool internal_delete = iter.node_-&gt;is_internal();
1683    if (internal_delete) {
1684      iterator internal_iter(iter);
1685      --iter;
1686      assert(iter.node_-&gt;is_leaf());
1687      internal_iter.node_-&gt;transfer(
1688          static_cast&lt;size_type&gt;(internal_iter.position_),
1689          static_cast&lt;size_type&gt;(iter.position_), iter.node_,
1690          mutable_allocator());
1691    } else {
1692      const field_type transfer_from =
1693          static_cast&lt;field_type&gt;(iter.position_ + 1);
1694      const field_type num_to_transfer = iter.node_-&gt;finish() - transfer_from;
1695      iter.node_-&gt;transfer_n(num_to_transfer,
1696                             static_cast&lt;size_type&gt;(iter.position_),
1697                             transfer_from, iter.node_, mutable_allocator());
1698    }
1699    iter.node_-&gt;set_finish(iter.node_-&gt;finish() - 1);
1700    --size_;
1701    iterator res = rebalance_after_delete(iter);
1702    if (internal_delete) {
1703      ++res;
1704    }
1705    return res;
1706  }
1707  template &lt;typename P&gt;
1708  auto btree&lt;P&gt;::rebalance_after_delete(iterator iter) -&gt; iterator {
1709    iterator res(iter);
1710    bool first_iteration = true;
1711    for (;;) {
1712      if (iter.node_ == root()) {
1713        try_shrink();
1714        if (empty()) {
1715          return end();
1716        }
1717        break;
1718      }
1719      if (iter.node_-&gt;count() &gt;= kMinNodeValues) {
1720        break;
1721      }
1722      bool merged = try_merge_or_rebalance(&amp;iter);
1723      if (first_iteration) {
1724        res = iter;
1725        first_iteration = false;
1726      }
1727      if (!merged) {
1728        break;
1729      }
1730      iter.position_ = iter.node_-&gt;position();
1731      iter.node_ = iter.node_-&gt;parent();
1732    }
1733    res.update_generation();
1734    if (res.position_ == res.node_-&gt;finish()) {
1735      res.position_ = res.node_-&gt;finish() - 1;
1736      ++res;
1737    }
1738    return res;
1739  }
1740  template &lt;typename P&gt;
1741  auto btree&lt;P&gt;::erase_range(iterator begin, iterator end)
1742      -&gt; std::pair&lt;size_type, iterator&gt; {
1743    size_type count = static_cast&lt;size_type&gt;(end - begin);
1744    assert(count &gt;= 0);
1745    if (count == 0) {
1746      return {0, begin};
1747    }
1748    if (static_cast&lt;size_type&gt;(count) == size_) {
1749      clear();
1750      return {count, this-&gt;end()};
1751    }
1752    if (begin.node_ == end.node_) {
1753      assert(end.position_ &gt; begin.position_);
1754      begin.node_-&gt;remove_values(
1755          static_cast&lt;field_type&gt;(begin.position_),
1756          static_cast&lt;field_type&gt;(end.position_ - begin.position_),
1757          mutable_allocator());
1758      size_ -= count;
1759      return {count, rebalance_after_delete(begin)};
1760    }
1761    const size_type target_size = size_ - count;
1762    while (size_ &gt; target_size) {
1763      if (begin.node_-&gt;is_leaf()) {
1764        const size_type remaining_to_erase = size_ - target_size;
1765        const size_type remaining_in_node =
1766            static_cast&lt;size_type&gt;(begin.node_-&gt;finish() - begin.position_);
1767        const field_type to_erase = static_cast&lt;field_type&gt;(
1768            (std::min)(remaining_to_erase, remaining_in_node));
1769        begin.node_-&gt;remove_values(static_cast&lt;field_type&gt;(begin.position_),
1770                                   to_erase, mutable_allocator());
1771        size_ -= to_erase;
1772        begin = rebalance_after_delete(begin);
1773      } else {
1774        begin = erase(begin);
1775      }
1776    }
1777    begin.update_generation();
1778    return {count, begin};
1779  }
1780  template &lt;typename P&gt;
1781  void btree&lt;P&gt;::clear() {
1782    if (!empty()) {
1783      node_type::clear_and_delete(root(), mutable_allocator());
1784    }
1785    mutable_root() = mutable_rightmost() = EmptyNode();
1786    size_ = 0;
1787  }
1788  template &lt;typename P&gt;
1789  void btree&lt;P&gt;::swap(btree &amp;other) {
1790    using std::swap;
1791    if (absl::allocator_traits&lt;
1792            allocator_type&gt;::propagate_on_container_swap::value) {
1793      swap(rightmost_, other.rightmost_);
1794    } else {
1795      assert(allocator() == other.allocator());
1796      swap(mutable_rightmost(), other.mutable_rightmost());
1797      swap(*mutable_key_comp(), *other.mutable_key_comp());
1798    }
1799    swap(mutable_root(), other.mutable_root());
1800    swap(size_, other.size_);
1801  }
1802  template &lt;typename P&gt;
1803  void btree&lt;P&gt;::verify() const {
1804    assert(root() != nullptr);
1805    assert(leftmost() != nullptr);
1806    assert(rightmost() != nullptr);
1807    assert(empty() || size() == internal_verify(root(), nullptr, nullptr));
1808    assert(leftmost() == (++const_iterator(root(), -1)).node_);
1809    assert(rightmost() == (--const_iterator(root(), root()-&gt;finish())).node_);
1810    assert(leftmost()-&gt;is_leaf());
1811    assert(rightmost()-&gt;is_leaf());
1812  }
1813  template &lt;typename P&gt;
1814  void btree&lt;P&gt;::rebalance_or_split(iterator *iter) {
1815    node_type *&amp;node = iter-&gt;node_;
1816    int &amp;insert_position = iter-&gt;position_;
1817    assert(node-&gt;count() == node-&gt;max_count());
1818    assert(kNodeSlots == node-&gt;max_count());
1819    node_type *parent = node-&gt;parent();
1820    if (node != root()) {
1821      if (node-&gt;position() &gt; parent-&gt;start()) {
1822        node_type *left = parent-&gt;child(node-&gt;position() - 1);
1823        assert(left-&gt;max_count() == kNodeSlots);
1824        if (left-&gt;count() &lt; kNodeSlots) {
1825          field_type to_move =
1826              (kNodeSlots - left-&gt;count()) /
1827              (1 + (static_cast&lt;field_type&gt;(insert_position) &lt; kNodeSlots));
1828          to_move = (std::max)(field_type{1}, to_move);
1829          if (static_cast&lt;field_type&gt;(insert_position) - to_move &gt;=
1830                  node-&gt;start() ||
1831              left-&gt;count() + to_move &lt; kNodeSlots) {
1832            left-&gt;rebalance_right_to_left(to_move, node, mutable_allocator());
1833            assert(node-&gt;max_count() - node-&gt;count() == to_move);
1834            insert_position = static_cast&lt;int&gt;(
1835                static_cast&lt;field_type&gt;(insert_position) - to_move);
1836            if (insert_position &lt; node-&gt;start()) {
1837              insert_position = insert_position + left-&gt;count() + 1;
1838              node = left;
1839            }
1840            assert(node-&gt;count() &lt; node-&gt;max_count());
1841            return;
1842          }
1843        }
1844      }
1845      if (node-&gt;position() &lt; parent-&gt;finish()) {
1846        node_type *right = parent-&gt;child(node-&gt;position() + 1);
1847        assert(right-&gt;max_count() == kNodeSlots);
1848        if (right-&gt;count() &lt; kNodeSlots) {
1849          field_type to_move = (kNodeSlots - right-&gt;count()) /
1850                               (1 + (insert_position &gt; node-&gt;start()));
1851          to_move = (std::max)(field_type{1}, to_move);
1852          if (static_cast&lt;field_type&gt;(insert_position) &lt;=
1853                  node-&gt;finish() - to_move ||
1854              right-&gt;count() + to_move &lt; kNodeSlots) {
1855            node-&gt;rebalance_left_to_right(to_move, right, mutable_allocator());
1856            if (insert_position &gt; node-&gt;finish()) {
1857              insert_position = insert_position - node-&gt;count() - 1;
1858              node = right;
1859            }
1860            assert(node-&gt;count() &lt; node-&gt;max_count());
1861            return;
1862          }
1863        }
1864      }
1865      assert(parent-&gt;max_count() == kNodeSlots);
1866      if (parent-&gt;count() == kNodeSlots) {
1867        iterator parent_iter(parent, node-&gt;position());
1868        rebalance_or_split(&amp;parent_iter);
1869        parent = node-&gt;parent();
1870      }
1871    } else {
1872      parent = new_internal_node(&amp;bsol;*position=*/0, parent);
1873      parent-&gt;set_generation(root()-&gt;generation());
1874      parent-&gt;init_child(parent-&gt;start(), node);
1875      mutable_root() = parent;
1876      assert(parent-&gt;start_child()-&gt;is_internal() ||
1877             parent-&gt;start_child() == rightmost());
1878    }
1879    node_type *split_node;
1880    if (node-&gt;is_leaf()) {
1881      split_node = new_leaf_node(node-&gt;position() + 1, parent);
1882      node-&gt;split(insert_position, split_node, mutable_allocator());
1883      if (rightmost() == node) mutable_rightmost() = split_node;
1884    } else {
1885      split_node = new_internal_node(node-&gt;position() + 1, parent);
1886      node-&gt;split(insert_position, split_node, mutable_allocator());
1887    }
1888    if (insert_position &gt; node-&gt;finish()) {
1889      insert_position = insert_position - node-&gt;count() - 1;
1890      node = split_node;
1891    }
1892  }
1893  template &lt;typename P&gt;
1894  void btree&lt;P&gt;::merge_nodes(node_type *left, node_type *right) {
1895    left-&gt;merge(right, mutable_allocator());
1896    if (rightmost() == right) mutable_rightmost() = left;
1897  }
1898  template &lt;typename P&gt;
1899  bool btree&lt;P&gt;::try_merge_or_rebalance(iterator *iter) {
1900    node_type *parent = iter-&gt;node_-&gt;parent();
1901    if (iter-&gt;node_-&gt;position() &gt; parent-&gt;start()) {
1902      node_type *left = parent-&gt;child(iter-&gt;node_-&gt;position() - 1);
1903      assert(left-&gt;max_count() == kNodeSlots);
1904      if (1U + left-&gt;count() + iter-&gt;node_-&gt;count() &lt;= kNodeSlots) {
1905        iter-&gt;position_ += 1 + left-&gt;count();
1906        merge_nodes(left, iter-&gt;node_);
1907        iter-&gt;node_ = left;
1908        return true;
1909      }
1910    }
1911    if (iter-&gt;node_-&gt;position() &lt; parent-&gt;finish()) {
1912      node_type *right = parent-&gt;child(iter-&gt;node_-&gt;position() + 1);
1913      assert(right-&gt;max_count() == kNodeSlots);
1914      if (1U + iter-&gt;node_-&gt;count() + right-&gt;count() &lt;= kNodeSlots) {
1915        merge_nodes(iter-&gt;node_, right);
1916        return true;
1917      }
1918      if (right-&gt;count() &gt; kMinNodeValues &amp;&amp;
1919          (iter-&gt;node_-&gt;count() == 0 || iter-&gt;position_ &gt; iter-&gt;node_-&gt;start())) {
1920        field_type to_move = (right-&gt;count() - iter-&gt;node_-&gt;count()) / 2;
1921        to_move =
1922            (std::min)(to_move, static_cast&lt;field_type&gt;(right-&gt;count() - 1));
1923        iter-&gt;node_-&gt;rebalance_right_to_left(to_move, right, mutable_allocator());
1924        return false;
1925      }
1926    }
1927    if (iter-&gt;node_-&gt;position() &gt; parent-&gt;start()) {
1928      node_type *left = parent-&gt;child(iter-&gt;node_-&gt;position() - 1);
1929      if (left-&gt;count() &gt; kMinNodeValues &amp;&amp;
1930          (iter-&gt;node_-&gt;count() == 0 ||
1931           iter-&gt;position_ &lt; iter-&gt;node_-&gt;finish())) {
1932        field_type to_move = (left-&gt;count() - iter-&gt;node_-&gt;count()) / 2;
1933        to_move = (std::min)(to_move, static_cast&lt;field_type&gt;(left-&gt;count() - 1));
1934        left-&gt;rebalance_left_to_right(to_move, iter-&gt;node_, mutable_allocator());
1935        iter-&gt;position_ += to_move;
1936        return false;
1937      }
1938    }
1939    return false;
1940  }
1941  template &lt;typename P&gt;
1942  void btree&lt;P&gt;::try_shrink() {
1943    node_type *orig_root = root();
1944    if (orig_root-&gt;count() &gt; 0) {
1945      return;
1946    }
1947    if (orig_root-&gt;is_leaf()) {
1948      assert(size() == 0);
1949      mutable_root() = mutable_rightmost() = EmptyNode();
1950    } else {
1951      node_type *child = orig_root-&gt;start_child();
1952      child-&gt;make_root();
1953      mutable_root() = child;
1954    }
1955    node_type::clear_and_delete(orig_root, mutable_allocator());
1956  }
1957  template &lt;typename P&gt;
1958  template &lt;typename IterType&gt;
1959  inline IterType btree&lt;P&gt;::internal_last(IterType iter) {
1960    assert(iter.node_ != nullptr);
1961    while (iter.position_ == iter.node_-&gt;finish()) {
1962      iter.position_ = iter.node_-&gt;position();
1963      iter.node_ = iter.node_-&gt;parent();
1964      if (iter.node_-&gt;is_leaf()) {
1965        iter.node_ = nullptr;
1966        break;
1967      }
1968    }
1969    iter.update_generation();
1970    return iter;
1971  }
1972  template &lt;typename P&gt;
1973  template &lt;typename... Args&gt;
1974  inline auto btree&lt;P&gt;::internal_emplace(iterator iter, Args &amp;&amp;...args)
1975      -&gt; iterator {
1976    if (iter.node_-&gt;is_internal()) {
1977      --iter;
1978      ++iter.position_;
1979    }
1980    const field_type max_count = iter.node_-&gt;max_count();
1981    allocator_type *alloc = mutable_allocator();
1982    const auto transfer_and_delete = [&amp;](node_type *old_node,
1983                                         node_type *new_node) {
1984      new_node-&gt;transfer_n(old_node-&gt;count(), new_node-&gt;start(),
1985                           old_node-&gt;start(), old_node, alloc);
1986      new_node-&gt;set_finish(old_node-&gt;finish());
1987      old_node-&gt;set_finish(old_node-&gt;start());
1988      new_node-&gt;set_generation(old_node-&gt;generation());
1989      node_type::clear_and_delete(old_node, alloc);
1990    };
1991    const auto replace_leaf_root_node = [&amp;](field_type new_node_size) {
1992      assert(iter.node_ == root());
1993      node_type *old_root = iter.node_;
1994      node_type *new_root = iter.node_ = new_leaf_root_node(new_node_size);
1995      transfer_and_delete(old_root, new_root);
1996      mutable_root() = mutable_rightmost() = new_root;
1997    };
1998    bool replaced_node = false;
1999    if (iter.node_-&gt;count() == max_count) {
2000      if (max_count &lt; kNodeSlots) {
2001        replace_leaf_root_node(static_cast&lt;field_type&gt;(
2002            (std::min)(static_cast&lt;int&gt;(kNodeSlots), 2 * max_count)));
2003        replaced_node = true;
2004      } else {
2005        rebalance_or_split(&amp;iter);
2006      }
2007    }
2008    (void)replaced_node;
2009  #ifdef ABSL_HAVE_ADDRESS_SANITIZER
2010    if (!replaced_node) {
2011      assert(iter.node_-&gt;is_leaf());
2012      if (iter.node_-&gt;is_root()) {
2013        replace_leaf_root_node(max_count);
2014      } else {
2015        node_type *old_node = iter.node_;
2016        const bool was_rightmost = rightmost() == old_node;
2017        const bool was_leftmost = leftmost() == old_node;
2018        node_type *parent = old_node-&gt;parent();
2019        const field_type position = old_node-&gt;position();
2020        node_type *new_node = iter.node_ = new_leaf_node(position, parent);
2021        parent-&gt;set_child_noupdate_position(position, new_node);
2022        transfer_and_delete(old_node, new_node);
2023        if (was_rightmost) mutable_rightmost() = new_node;
2024        if (was_leftmost) root()-&gt;set_parent(new_node);
2025      }
2026    }
2027  #endif
2028    iter.node_-&gt;emplace_value(static_cast&lt;field_type&gt;(iter.position_), alloc,
2029                              std::forward&lt;Args&gt;(args)...);
2030    assert(
2031        iter.node_-&gt;is_ordered_correctly(static_cast&lt;field_type&gt;(iter.position_),
2032                                         original_key_compare(key_comp())) &amp;&amp;
2033        &quot;If this assert fails, then either (1) the comparator may violate &quot;
2034        &quot;transitivity, i.e. comp(a,b) &amp;&amp; comp(b,c) -&gt; comp(a,c) (see &quot;
2035        &quot;https:&amp;bsol;&amp;bsol;en.cppreference.com/w/cpp/named_req/Compare), or (2) a &quot;
2036        &quot;key may have been mutated after it was inserted into the tree.&quot;);
2037    ++size_;
2038    iter.update_generation();
2039    return iter;
2040  }
2041  template &lt;typename P&gt;
2042  template &lt;typename K&gt;
2043  inline auto btree&lt;P&gt;::internal_locate(const K &amp;key) const
2044      -&gt; SearchResult&lt;iterator, is_key_compare_to::value&gt; {
2045    iterator iter(const_cast&lt;node_type *&gt;(root()));
2046    for (;;) {
2047      SearchResult&lt;size_type, is_key_compare_to::value&gt; res =
2048          iter.node_-&gt;lower_bound(key, key_comp());
2049      iter.position_ = static_cast&lt;int&gt;(res.value);
2050      if (res.IsEq()) {
2051        return {iter, MatchKind::kEq};
2052      }
2053      if (iter.node_-&gt;is_leaf()) {
2054        break;
2055      }
2056      iter.node_ = iter.node_-&gt;child(static_cast&lt;field_type&gt;(iter.position_));
2057    }
2058    return {iter, MatchKind::kNe};
2059  }
2060  template &lt;typename P&gt;
2061  template &lt;typename K&gt;
2062  auto btree&lt;P&gt;::internal_lower_bound(const K &amp;key) const
2063      -&gt; SearchResult&lt;iterator, is_key_compare_to::value&gt; {
2064    if (!params_type::template can_have_multiple_equivalent_keys&lt;K&gt;()) {
2065      SearchResult&lt;iterator, is_key_compare_to::value&gt; ret = internal_locate(key);
2066      ret.value = internal_last(ret.value);
2067      return ret;
2068    }
2069    iterator iter(const_cast&lt;node_type *&gt;(root()));
2070    SearchResult&lt;size_type, is_key_compare_to::value&gt; res;
2071    bool seen_eq = false;
2072    for (;;) {
2073      res = iter.node_-&gt;lower_bound(key, key_comp());
2074      iter.position_ = static_cast&lt;int&gt;(res.value);
2075      if (iter.node_-&gt;is_leaf()) {
2076        break;
2077      }
2078      seen_eq = seen_eq || res.IsEq();
2079      iter.node_ = iter.node_-&gt;child(static_cast&lt;field_type&gt;(iter.position_));
2080    }
2081    if (res.IsEq()) return {iter, MatchKind::kEq};
2082    return {internal_last(iter), seen_eq ? MatchKind::kEq : MatchKind::kNe};
2083  }
2084  template &lt;typename P&gt;
2085  template &lt;typename K&gt;
2086  auto btree&lt;P&gt;::internal_upper_bound(const K &amp;key) const -&gt; iterator {
2087    iterator iter(const_cast&lt;node_type *&gt;(root()));
2088    for (;;) {
2089      iter.position_ = static_cast&lt;int&gt;(iter.node_-&gt;upper_bound(key, key_comp()));
2090      if (iter.node_-&gt;is_leaf()) {
2091        break;
2092      }
2093      iter.node_ = iter.node_-&gt;child(static_cast&lt;field_type&gt;(iter.position_));
2094    }
2095    return internal_last(iter);
2096  }
2097  template &lt;typename P&gt;
2098  template &lt;typename K&gt;
2099  auto btree&lt;P&gt;::internal_find(const K &amp;key) const -&gt; iterator {
2100    SearchResult&lt;iterator, is_key_compare_to::value&gt; res = internal_locate(key);
2101    if (res.HasMatch()) {
2102      if (res.IsEq()) {
2103        return res.value;
2104      }
2105    } else {
2106      const iterator iter = internal_last(res.value);
2107      if (iter.node_ != nullptr &amp;&amp; !compare_keys(key, iter.key())) {
2108        return iter;
2109      }
2110    }
2111    return {nullptr, 0};
2112  }
2113  template &lt;typename P&gt;
2114  typename btree&lt;P&gt;::size_type btree&lt;P&gt;::internal_verify(
2115      const node_type *node, const key_type *lo, const key_type *hi) const {
2116    assert(node-&gt;count() &gt; 0);
2117    assert(node-&gt;count() &lt;= node-&gt;max_count());
2118    if (lo) {
2119      assert(!compare_keys(node-&gt;key(node-&gt;start()), *lo));
2120    }
2121    if (hi) {
2122      assert(!compare_keys(*hi, node-&gt;key(node-&gt;finish() - 1)));
2123    }
2124    for (int i = node-&gt;start() + 1; i &lt; node-&gt;finish(); ++i) {
2125      assert(!compare_keys(node-&gt;key(i), node-&gt;key(i - 1)));
2126    }
2127    size_type count = node-&gt;count();
2128    if (node-&gt;is_internal()) {
2129      for (field_type i = node-&gt;start(); i &lt;= node-&gt;finish(); ++i) {
2130        assert(node-&gt;child(i) != nullptr);
2131        assert(node-&gt;child(i)-&gt;parent() == node);
2132        assert(node-&gt;child(i)-&gt;position() == i);
2133        count += internal_verify(node-&gt;child(i),
2134                                 i == node-&gt;start() ? lo : &amp;node-&gt;key(i - 1),
2135                                 i == node-&gt;finish() ? hi : &amp;node-&gt;key(i));
2136      }
2137    }
2138    return count;
2139  }
2140  struct btree_access {
2141    template &lt;typename BtreeContainer, typename Pred&gt;
2142    static auto erase_if(BtreeContainer &amp;container, Pred pred) -&gt;
2143        typename BtreeContainer::size_type {
2144      const auto initial_size = container.size();
2145      auto &amp;tree = container.tree_;
2146      auto *alloc = tree.mutable_allocator();
2147      for (auto it = container.begin(); it != container.end();) {
2148        if (!pred(*it)) {
2149          ++it;
2150          continue;
2151        }
2152        auto *node = it.node_;
2153        if (node-&gt;is_internal()) {
2154          it = container.erase(it);
2155          continue;
2156        }
2157        int to_pos = it.position_;
2158        node-&gt;value_destroy(it.position_, alloc);
2159        while (++it.position_ &lt; node-&gt;finish()) {
2160          it.update_generation();
2161          if (pred(*it)) {
2162            node-&gt;value_destroy(it.position_, alloc);
2163          } else {
2164            node-&gt;transfer(node-&gt;slot(to_pos++), node-&gt;slot(it.position_), alloc);
2165          }
2166        }
2167        const int num_deleted = node-&gt;finish() - to_pos;
2168        tree.size_ -= num_deleted;
2169        node-&gt;set_finish(to_pos);
2170        it.position_ = to_pos;
2171        it = tree.rebalance_after_delete(it);
2172      }
2173      return initial_size - container.size();
2174    }
2175  };
2176  #undef ABSL_BTREE_ENABLE_GENERATIONS
2177  }  
2178  ABSL_NAMESPACE_END
2179  }  
2180  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-btree.h</h3>
            <pre><code>1  #ifndef ABSL_CONTAINER_INTERNAL_BTREE_H_
2  #define ABSL_CONTAINER_INTERNAL_BTREE_H_
3  #include &lt;algorithm&gt;
4  #include &lt;cassert&gt;
5  #include &lt;cstddef&gt;
6  #include &lt;cstdint&gt;
7  #include &lt;cstring&gt;
8  #include &lt;functional&gt;
9  #include &lt;iterator&gt;
10  #include &lt;limits&gt;
11  #include &lt;new&gt;
12  #include &lt;string&gt;
13  #include &lt;type_traits&gt;
14  #include &lt;utility&gt;
15  #include &quot;absl/base/internal/raw_logging.h&quot;
16  #include &quot;absl/base/macros.h&quot;
17  #include &quot;absl/container/internal/common.h&quot;
18  #include &quot;absl/container/internal/common_policy_traits.h&quot;
19  #include &quot;absl/container/internal/compressed_tuple.h&quot;
20  #include &quot;absl/container/internal/container_memory.h&quot;
21  #include &quot;absl/container/internal/layout.h&quot;
22  #include &quot;absl/memory/memory.h&quot;
23  #include &quot;absl/meta/type_traits.h&quot;
24  #include &quot;absl/strings/cord.h&quot;
25  #include &quot;absl/strings/string_view.h&quot;
26  #include &quot;absl/types/compare.h&quot;
27  #include &quot;absl/utility/utility.h&quot;
28  namespace absl {
29  ABSL_NAMESPACE_BEGIN
30  namespace container_internal {
31  #ifdef ABSL_BTREE_ENABLE_GENERATIONS
32  #error ABSL_BTREE_ENABLE_GENERATIONS cannot be directly set
33  #elif defined(ABSL_HAVE_ADDRESS_SANITIZER) || \
34      defined(ABSL_HAVE_MEMORY_SANITIZER)
35  #define ABSL_BTREE_ENABLE_GENERATIONS
36  #endif
37  #ifdef ABSL_BTREE_ENABLE_GENERATIONS
38  constexpr bool BtreeGenerationsEnabled() { return true; }
39  #else
40  constexpr bool BtreeGenerationsEnabled() { return false; }
41  #endif
42  template &lt;typename Compare, typename T, typename U&gt;
43  using compare_result_t = absl::result_of_t&lt;const Compare(const T &amp;, const U &amp;)&gt;;
44  template &lt;typename Compare, typename T&gt;
45  using btree_is_key_compare_to =
46      std::is_convertible&lt;compare_result_t&lt;Compare, T, T&gt;, absl::weak_ordering&gt;;
47  struct StringBtreeDefaultLess {
48    using is_transparent = void;
49    StringBtreeDefaultLess() = default;
50    StringBtreeDefaultLess(std::less&lt;std::string&gt;) {}        
51    StringBtreeDefaultLess(std::less&lt;absl::string_view&gt;) {}  
52    explicit operator std::less&lt;std::string&gt;() const { return {}; }
53    explicit operator std::less&lt;absl::string_view&gt;() const { return {}; }
54    explicit operator std::less&lt;absl::Cord&gt;() const { return {}; }
55    absl::weak_ordering operator()(absl::string_view lhs,
56                                   absl::string_view rhs) const {
57      return compare_internal::compare_result_as_ordering(lhs.compare(rhs));
58    }
59    StringBtreeDefaultLess(std::less&lt;absl::Cord&gt;) {}  
60    absl::weak_ordering operator()(const absl::Cord &amp;lhs,
61                                   const absl::Cord &amp;rhs) const {
62      return compare_internal::compare_result_as_ordering(lhs.Compare(rhs));
63    }
64    absl::weak_ordering operator()(const absl::Cord &amp;lhs,
65                                   absl::string_view rhs) const {
66      return compare_internal::compare_result_as_ordering(lhs.Compare(rhs));
67    }
68    absl::weak_ordering operator()(absl::string_view lhs,
69                                   const absl::Cord &amp;rhs) const {
70      return compare_internal::compare_result_as_ordering(-rhs.Compare(lhs));
71    }
72  };
73  struct StringBtreeDefaultGreater {
74    using is_transparent = void;
75    StringBtreeDefaultGreater() = default;
76    StringBtreeDefaultGreater(std::greater&lt;std::string&gt;) {}        
77    StringBtreeDefaultGreater(std::greater&lt;absl::string_view&gt;) {}  
78    explicit operator std::greater&lt;std::string&gt;() const { return {}; }
79    explicit operator std::greater&lt;absl::string_view&gt;() const { return {}; }
80    explicit operator std::greater&lt;absl::Cord&gt;() const { return {}; }
81    absl::weak_ordering operator()(absl::string_view lhs,
82                                   absl::string_view rhs) const {
83      return compare_internal::compare_result_as_ordering(rhs.compare(lhs));
84    }
85    StringBtreeDefaultGreater(std::greater&lt;absl::Cord&gt;) {}  
86    absl::weak_ordering operator()(const absl::Cord &amp;lhs,
87                                   const absl::Cord &amp;rhs) const {
88      return compare_internal::compare_result_as_ordering(rhs.Compare(lhs));
89    }
90    absl::weak_ordering operator()(const absl::Cord &amp;lhs,
91                                   absl::string_view rhs) const {
92      return compare_internal::compare_result_as_ordering(-lhs.Compare(rhs));
93    }
94    absl::weak_ordering operator()(absl::string_view lhs,
95                                   const absl::Cord &amp;rhs) const {
96      return compare_internal::compare_result_as_ordering(rhs.Compare(lhs));
97    }
98  };
99  template &lt;typename Compare, bool is_class = std::is_class&lt;Compare&gt;::value&gt;
100  struct checked_compare_base : Compare {
101    using Compare::Compare;
102    explicit checked_compare_base(Compare c) : Compare(std::move(c)) {}
103    const Compare &amp;comp() const { return *this; }
104  };
105  template &lt;typename Compare&gt;
106  struct checked_compare_base&lt;Compare, false&gt; {
107    explicit checked_compare_base(Compare c) : compare(std::move(c)) {}
108    const Compare &amp;comp() const { return compare; }
109    Compare compare;
110  };
111  struct BtreeTestOnlyCheckedCompareOptOutBase {};
112  template &lt;typename Compare, typename Key&gt;
113  struct key_compare_adapter {
114    struct checked_compare : checked_compare_base&lt;Compare&gt; {
115     private:
116      using Base = typename checked_compare::checked_compare_base;
117      using Base::comp;
118      bool is_self_equivalent(const Key &amp;k) const {
119        return comp()(k, k) == 0;
120      }
121      template &lt;typename T&gt;
122      bool is_self_equivalent(const T &amp;) const {
123        return true;
124      }
125     public:
126      using Base::Base;
127      checked_compare(Compare comp) : Base(std::move(comp)) {}  
128      explicit operator Compare() const { return comp(); }
129      template &lt;typename T, typename U,
130                absl::enable_if_t&lt;
131                    std::is_same&lt;bool, compare_result_t&lt;Compare, T, U&gt;&gt;::value,
132                    int&gt; = 0&gt;
133      bool operator()(const T &amp;lhs, const U &amp;rhs) const {
134        assert(is_self_equivalent(lhs));
135        assert(is_self_equivalent(rhs));
136        const bool lhs_comp_rhs = comp()(lhs, rhs);
137        assert(!lhs_comp_rhs || !comp()(rhs, lhs));
138        return lhs_comp_rhs;
139      }
140      template &lt;
141          typename T, typename U,
142          absl::enable_if_t&lt;std::is_convertible&lt;compare_result_t&lt;Compare, T, U&gt;,
143                                                absl::weak_ordering&gt;::value,
144                            int&gt; = 0&gt;
145      absl::weak_ordering operator()(const T &amp;lhs, const U &amp;rhs) const {
146        assert(is_self_equivalent(lhs));
147        assert(is_self_equivalent(rhs));
148        const absl::weak_ordering lhs_comp_rhs = comp()(lhs, rhs);
149  #ifndef NDEBUG
150        const absl::weak_ordering rhs_comp_lhs = comp()(rhs, lhs);
151        if (lhs_comp_rhs &gt; 0) {
152          assert(rhs_comp_lhs &lt; 0 &amp;&amp; &quot;lhs_comp_rhs &gt; 0 -&gt; rhs_comp_lhs &lt; 0&quot;);
153        } else if (lhs_comp_rhs == 0) {
154          assert(rhs_comp_lhs == 0 &amp;&amp; &quot;lhs_comp_rhs == 0 -&gt; rhs_comp_lhs == 0&quot;);
155        } else {
156          assert(rhs_comp_lhs &gt; 0 &amp;&amp; &quot;lhs_comp_rhs &lt; 0 -&gt; rhs_comp_lhs &gt; 0&quot;);
157        }
158  #endif
159        return lhs_comp_rhs;
160      }
161    };
162    using type = absl::conditional_t&lt;
163        std::is_base_of&lt;BtreeTestOnlyCheckedCompareOptOutBase, Compare&gt;::value,
164        Compare, checked_compare&gt;;
165  };
166  template &lt;&gt;
167  struct key_compare_adapter&lt;std::less&lt;std::string&gt;, std::string&gt; {
168    using type = StringBtreeDefaultLess;
169  };
170  template &lt;&gt;
171  struct key_compare_adapter&lt;std::greater&lt;std::string&gt;, std::string&gt; {
172    using type = StringBtreeDefaultGreater;
173  };
174  template &lt;&gt;
175  struct key_compare_adapter&lt;std::less&lt;absl::string_view&gt;, absl::string_view&gt; {
176    using type = StringBtreeDefaultLess;
177  };
178  template &lt;&gt;
179  struct key_compare_adapter&lt;std::greater&lt;absl::string_view&gt;, absl::string_view&gt; {
180    using type = StringBtreeDefaultGreater;
181  };
182  template &lt;&gt;
183  struct key_compare_adapter&lt;std::less&lt;absl::Cord&gt;, absl::Cord&gt; {
184    using type = StringBtreeDefaultLess;
185  };
186  template &lt;&gt;
187  struct key_compare_adapter&lt;std::greater&lt;absl::Cord&gt;, absl::Cord&gt; {
188    using type = StringBtreeDefaultGreater;
189  };
190  template &lt;typename T, typename = void&gt;
191  struct has_linear_node_search_preference : std::false_type {};
192  template &lt;typename T, typename = void&gt;
193  struct prefers_linear_node_search : std::false_type {};
194  template &lt;typename T&gt;
195  struct has_linear_node_search_preference&lt;
196      T, absl::void_t&lt;typename T::absl_btree_prefer_linear_node_search&gt;&gt;
197      : std::true_type {};
198  template &lt;typename T&gt;
199  struct prefers_linear_node_search&lt;
200      T, absl::void_t&lt;typename T::absl_btree_prefer_linear_node_search&gt;&gt;
201      : T::absl_btree_prefer_linear_node_search {};
202  template &lt;typename Compare, typename Key&gt;
203  constexpr bool compare_has_valid_result_type() {
204    using compare_result_type = compare_result_t&lt;Compare, Key, Key&gt;;
205    return std::is_same&lt;compare_result_type, bool&gt;::value ||
206           std::is_convertible&lt;compare_result_type, absl::weak_ordering&gt;::value;
207  }
208  template &lt;typename original_key_compare, typename value_type&gt;
209  class map_value_compare {
210    template &lt;typename Params&gt;
211    friend class btree;
212   protected:
213    explicit map_value_compare(original_key_compare c) : comp(std::move(c)) {}
214    original_key_compare comp;  
215   public:
216    auto operator()(const value_type &amp;lhs, const value_type &amp;rhs) const
217        -&gt; decltype(comp(lhs.first, rhs.first)) {
218      return comp(lhs.first, rhs.first);
219    }
220  };
221  template &lt;typename Key, typename Compare, typename Alloc, int TargetNodeSize,
222            bool IsMulti, bool IsMap, typename SlotPolicy&gt;
223  struct common_params : common_policy_traits&lt;SlotPolicy&gt; {
224    using original_key_compare = Compare;
225    using key_compare =
226        absl::conditional_t&lt;!compare_has_valid_result_type&lt;Compare, Key&gt;(),
227                            Compare,
228                            typename key_compare_adapter&lt;Compare, Key&gt;::type&gt;;
229    static constexpr bool kIsKeyCompareStringAdapted =
230        std::is_same&lt;key_compare, StringBtreeDefaultLess&gt;::value ||
231        std::is_same&lt;key_compare, StringBtreeDefaultGreater&gt;::value;
232    static constexpr bool kIsKeyCompareTransparent =
233        IsTransparent&lt;original_key_compare&gt;::value || kIsKeyCompareStringAdapted;
234    using is_key_compare_to = btree_is_key_compare_to&lt;key_compare, Key&gt;;
235    using allocator_type = Alloc;
236    using key_type = Key;
237    using size_type = size_t;
238    using difference_type = ptrdiff_t;
239    using slot_policy = SlotPolicy;
240    using slot_type = typename slot_policy::slot_type;
241    using value_type = typename slot_policy::value_type;
242    using init_type = typename slot_policy::mutable_value_type;
243    using pointer = value_type *;
244    using const_pointer = const value_type *;
245    using reference = value_type &amp;;
246    using const_reference = const value_type &amp;;
247    using value_compare =
248        absl::conditional_t&lt;IsMap,
249                            map_value_compare&lt;original_key_compare, value_type&gt;,
250                            original_key_compare&gt;;
251    using is_map_container = std::integral_constant&lt;bool, IsMap&gt;;
252    template &lt;typename LookupKey&gt;
253    constexpr static bool can_have_multiple_equivalent_keys() {
254      return IsMulti || (IsTransparent&lt;key_compare&gt;::value &amp;&amp;
255                         !std::is_same&lt;LookupKey, Key&gt;::value &amp;&amp;
256                         !kIsKeyCompareStringAdapted);
257    }
258    enum {
259      kTargetNodeSize = TargetNodeSize,
260      kNodeSlotSpace = TargetNodeSize - &amp;bsol;*minimum overhead=*/(sizeof(void *) + 4),
261    };
262    using node_count_type =
263        absl::conditional_t&lt;(kNodeSlotSpace / sizeof(slot_type) &gt;
264                             (std::numeric_limits&lt;uint8_t&gt;::max)()),
265                            uint16_t, uint8_t&gt;;  
266  };
267  template &lt;typename Compare&gt;
268  struct upper_bound_adapter {
269    explicit upper_bound_adapter(const Compare &amp;c) : comp(c) {}
270    template &lt;typename K1, typename K2&gt;
271    bool operator()(const K1 &amp;a, const K2 &amp;b) const {
272      return !compare_internal::compare_result_as_less_than(comp(b, a));
273    }
274   private:
275    Compare comp;
276  };
277  enum class MatchKind : uint8_t { kEq, kNe };
278  template &lt;typename V, bool IsCompareTo&gt;
279  struct SearchResult {
280    V value;
281    MatchKind match;
282    static constexpr bool HasMatch() { return true; }
283    bool IsEq() const { return match == MatchKind::kEq; }
284  };
285  template &lt;typename V&gt;
286  struct SearchResult&lt;V, false&gt; {
287    SearchResult() {}
288    explicit SearchResult(V v) : value(v) {}
289    SearchResult(V v, MatchKind &amp;bsol;*match*/) : value(v) {}
290    V value;
291    static constexpr bool HasMatch() { return false; }
292    static constexpr bool IsEq() { return false; }
293  };
294  template &lt;typename Params&gt;
295  class btree_node {
296    using is_key_compare_to = typename Params::is_key_compare_to;
297    using field_type = typename Params::node_count_type;
298    using allocator_type = typename Params::allocator_type;
299    using slot_type = typename Params::slot_type;
300    using original_key_compare = typename Params::original_key_compare;
301   public:
302    using params_type = Params;
303    using key_type = typename Params::key_type;
304    using value_type = typename Params::value_type;
305    using pointer = typename Params::pointer;
306    using const_pointer = typename Params::const_pointer;
307    using reference = typename Params::reference;
308    using const_reference = typename Params::const_reference;
309    using key_compare = typename Params::key_compare;
310    using size_type = typename Params::size_type;
311    using difference_type = typename Params::difference_type;
312    using use_linear_search = std::integral_constant&lt;
313        bool, has_linear_node_search_preference&lt;original_key_compare&gt;::value
314                  ? prefers_linear_node_search&lt;original_key_compare&gt;::value
315              : has_linear_node_search_preference&lt;key_type&gt;::value
316                  ? prefers_linear_node_search&lt;key_type&gt;::value
317                  : std::is_arithmetic&lt;key_type&gt;::value &amp;&amp;
318                        (std::is_same&lt;std::less&lt;key_type&gt;,
319                                      original_key_compare&gt;::value ||
320                         std::is_same&lt;std::greater&lt;key_type&gt;,
321                                      original_key_compare&gt;::value)&gt;;
322    ~btree_node() = default;
323    btree_node(btree_node const &amp;) = delete;
324    btree_node &amp;operator=(btree_node const &amp;) = delete;
325    constexpr static size_type Alignment() {
326      static_assert(LeafLayout(1).Alignment() == InternalLayout().Alignment(),
327                    &quot;Alignment of all nodes must be equal.&quot;);
328      return InternalLayout().Alignment();
329    }
330   protected:
331    btree_node() = default;
332   private:
333    using layout_type =
334        absl::container_internal::Layout&lt;btree_node *, uint32_t, field_type,
335                                         slot_type, btree_node *&gt;;
336    constexpr static size_type SizeWithNSlots(size_type n) {
337      return layout_type(
338                  1,
339                  BtreeGenerationsEnabled() ? 1 : 0,
340                  4,
341                  n,
342                  0)
343          .AllocSize();
344    }
345    constexpr static size_type MinimumOverhead() {
346      return SizeWithNSlots(1) - sizeof(slot_type);
347    }
348    constexpr static size_type NodeTargetSlots(const size_type begin,
349                                               const size_type end) {
350      return begin == end ? begin
351             : SizeWithNSlots((begin + end) / 2 + 1) &gt;
352                     params_type::kTargetNodeSize
353                 ? NodeTargetSlots(begin, (begin + end) / 2)
354                 : NodeTargetSlots((begin + end) / 2 + 1, end);
355    }
356    constexpr static size_type kTargetNodeSize = params_type::kTargetNodeSize;
357    constexpr static size_type kNodeTargetSlots =
358        NodeTargetSlots(0, kTargetNodeSize);
359    constexpr static size_type kMinNodeSlots = 4;
360    constexpr static size_type kNodeSlots =
361        kNodeTargetSlots &gt;= kMinNodeSlots ? kNodeTargetSlots : kMinNodeSlots;
362    constexpr static field_type kInternalNodeMaxCount = 0;
363    constexpr static layout_type Layout(const size_type slot_count,
364                                        const size_type child_count) {
365      return layout_type(
366           1,
367           BtreeGenerationsEnabled() ? 1 : 0,
368           4,
369           slot_count,
370           child_count);
371    }
372    constexpr static layout_type LeafLayout(
373        const size_type slot_count = kNodeSlots) {
374      return Layout(slot_count, 0);
375    }
376    constexpr static layout_type InternalLayout() {
377      return Layout(kNodeSlots, kNodeSlots + 1);
378    }
379    constexpr static size_type LeafSize(const size_type slot_count = kNodeSlots) {
380      return LeafLayout(slot_count).AllocSize();
381    }
382    constexpr static size_type InternalSize() {
383      return InternalLayout().AllocSize();
384    }
385    template &lt;size_type N&gt;
386    inline typename layout_type::template ElementType&lt;N&gt; *GetField() {
387      assert(N &lt; 4 || is_internal());
388      return InternalLayout().template Pointer&lt;N&gt;(reinterpret_cast&lt;char *&gt;(this));
389    }
390    template &lt;size_type N&gt;
391    inline const typename layout_type::template ElementType&lt;N&gt; *GetField() const {
392      assert(N &lt; 4 || is_internal());
393      return InternalLayout().template Pointer&lt;N&gt;(
394          reinterpret_cast&lt;const char *&gt;(this));
395    }
396    void set_parent(btree_node *p) { *GetField&lt;0&gt;() = p; }
397    field_type &amp;mutable_finish() { return GetField&lt;2&gt;()[2]; }
398    slot_type *slot(size_type i) { return &amp;GetField&lt;3&gt;()[i]; }
399    slot_type *start_slot() { return slot(start()); }
400    slot_type *finish_slot() { return slot(finish()); }
401    const slot_type *slot(size_type i) const { return &amp;GetField&lt;3&gt;()[i]; }
402    void set_position(field_type v) { GetField&lt;2&gt;()[0] = v; }
403    void set_start(field_type v) { GetField&lt;2&gt;()[1] = v; }
404    void set_finish(field_type v) { GetField&lt;2&gt;()[2] = v; }
405    void set_max_count(field_type v) { GetField&lt;2&gt;()[3] = v; }
406   public:
407    bool is_leaf() const { return GetField&lt;2&gt;()[3] != kInternalNodeMaxCount; }
408    bool is_internal() const { return !is_leaf(); }
409    field_type position() const { return GetField&lt;2&gt;()[0]; }
410    field_type start() const {
411      assert(GetField&lt;2&gt;()[1] == 0);
412      return 0;
413    }
414    field_type finish() const { return GetField&lt;2&gt;()[2]; }
415    field_type count() const {
416      assert(finish() &gt;= start());
417      return finish() - start();
418    }
419    field_type max_count() const {
420      const field_type max_count = GetField&lt;2&gt;()[3];
421      return max_count == field_type{kInternalNodeMaxCount}
422                 ? field_type{kNodeSlots}
423                 : max_count;
424    }
425    btree_node *parent() const { return *GetField&lt;0&gt;(); }
426    bool is_root() const { return parent()-&gt;is_leaf(); }
427    void make_root() {
428      assert(parent()-&gt;is_root());
429      set_generation(parent()-&gt;generation());
430      set_parent(parent()-&gt;parent());
431    }
432    uint32_t *get_root_generation() const {
433      assert(BtreeGenerationsEnabled());
434      const btree_node *curr = this;
435      for (; !curr-&gt;is_root(); curr = curr-&gt;parent()) continue;
436      return const_cast&lt;uint32_t *&gt;(&amp;curr-&gt;GetField&lt;1&gt;()[0]);
437    }
438    uint32_t generation() const {
439      return BtreeGenerationsEnabled() ? *get_root_generation() : 0;
440    }
441    void set_generation(uint32_t generation) {
442      if (BtreeGenerationsEnabled()) GetField&lt;1&gt;()[0] = generation;
443    }
444    void next_generation() {
445      if (BtreeGenerationsEnabled()) ++*get_root_generation();
446    }
447    const key_type &amp;key(size_type i) const { return params_type::key(slot(i)); }
448    reference value(size_type i) { return params_type::element(slot(i)); }
449    const_reference value(size_type i) const {
450      return params_type::element(slot(i));
451    }
452    btree_node *child(field_type i) const { return GetField&lt;4&gt;()[i]; }
453    btree_node *start_child() const { return child(start()); }
454    btree_node *&amp;mutable_child(field_type i) { return GetField&lt;4&gt;()[i]; }
455    void clear_child(field_type i) {
456      absl::container_internal::SanitizerPoisonObject(&amp;mutable_child(i));
457    }
458    void set_child_noupdate_position(field_type i, btree_node *c) {
459      absl::container_internal::SanitizerUnpoisonObject(&amp;mutable_child(i));
460      mutable_child(i) = c;
461    }
462    void set_child(field_type i, btree_node *c) {
463      set_child_noupdate_position(i, c);
464      c-&gt;set_position(i);
465    }
466    void init_child(field_type i, btree_node *c) {
467      set_child(i, c);
468      c-&gt;set_parent(this);
469    }
470    template &lt;typename K&gt;
471    SearchResult&lt;size_type, is_key_compare_to::value&gt; lower_bound(
472        const K &amp;k, const key_compare &amp;comp) const {
473      return use_linear_search::value ? linear_search(k, comp)
474                                      : binary_search(k, comp);
475    }
476    template &lt;typename K&gt;
477    size_type upper_bound(const K &amp;k, const key_compare &amp;comp) const {
478      auto upper_compare = upper_bound_adapter&lt;key_compare&gt;(comp);
479      return use_linear_search::value ? linear_search(k, upper_compare).value
480                                      : binary_search(k, upper_compare).value;
481    }
482    template &lt;typename K, typename Compare&gt;
483    SearchResult&lt;size_type, btree_is_key_compare_to&lt;Compare, key_type&gt;::value&gt;
484    linear_search(const K &amp;k, const Compare &amp;comp) const {
485      return linear_search_impl(k, start(), finish(), comp,
486                                btree_is_key_compare_to&lt;Compare, key_type&gt;());
487    }
488    template &lt;typename K, typename Compare&gt;
489    SearchResult&lt;size_type, btree_is_key_compare_to&lt;Compare, key_type&gt;::value&gt;
490    binary_search(const K &amp;k, const Compare &amp;comp) const {
491      return binary_search_impl(k, start(), finish(), comp,
492                                btree_is_key_compare_to&lt;Compare, key_type&gt;());
493    }
494    template &lt;typename K, typename Compare&gt;
495    SearchResult&lt;size_type, false&gt; linear_search_impl(
496        const K &amp;k, size_type s, const size_type e, const Compare &amp;comp,
497        std::false_type &amp;bsol;* IsCompareTo */) const {
498      while (s &lt; e) {
499        if (!comp(key(s), k)) {
500          break;
501        }
502        ++s;
503      }
504      return SearchResult&lt;size_type, false&gt;{s};
505    }
506    template &lt;typename K, typename Compare&gt;
507    SearchResult&lt;size_type, true&gt; linear_search_impl(
508        const K &amp;k, size_type s, const size_type e, const Compare &amp;comp,
509        std::true_type &amp;bsol;* IsCompareTo */) const {
510      while (s &lt; e) {
511        const absl::weak_ordering c = comp(key(s), k);
512        if (c == 0) {
513          return {s, MatchKind::kEq};
514        } else if (c &gt; 0) {
515          break;
516        }
517        ++s;
518      }
519      return {s, MatchKind::kNe};
520    }
521    template &lt;typename K, typename Compare&gt;
522    SearchResult&lt;size_type, false&gt; binary_search_impl(
523        const K &amp;k, size_type s, size_type e, const Compare &amp;comp,
524        std::false_type &amp;bsol;* IsCompareTo */) const {
525      while (s != e) {
526        const size_type mid = (s + e) &gt;&gt; 1;
527        if (comp(key(mid), k)) {
528          s = mid + 1;
529        } else {
530          e = mid;
531        }
532      }
533      return SearchResult&lt;size_type, false&gt;{s};
534    }
535    template &lt;typename K, typename CompareTo&gt;
536    SearchResult&lt;size_type, true&gt; binary_search_impl(
537        const K &amp;k, size_type s, size_type e, const CompareTo &amp;comp,
538        std::true_type &amp;bsol;* IsCompareTo */) const {
539      if (params_type::template can_have_multiple_equivalent_keys&lt;K&gt;()) {
540        MatchKind exact_match = MatchKind::kNe;
541        while (s != e) {
542          const size_type mid = (s + e) &gt;&gt; 1;
543          const absl::weak_ordering c = comp(key(mid), k);
544          if (c &lt; 0) {
545            s = mid + 1;
546          } else {
547            e = mid;
548            if (c == 0) {
549              exact_match = MatchKind::kEq;
550            }
551          }
552        }
553        return {s, exact_match};
554      } else {  
555        while (s != e) {
556          const size_type mid = (s + e) &gt;&gt; 1;
557          const absl::weak_ordering c = comp(key(mid), k);
558          if (c &lt; 0) {
559            s = mid + 1;
560          } else if (c &gt; 0) {
561            e = mid;
562          } else {
563            return {mid, MatchKind::kEq};
564          }
565        }
566        return {s, MatchKind::kNe};
567      }
568    }
569    template &lt;typename Compare&gt;
570    bool is_ordered_correctly(field_type i, const Compare &amp;comp) const {
571      if (std::is_base_of&lt;BtreeTestOnlyCheckedCompareOptOutBase,
572                          Compare&gt;::value ||
573          params_type::kIsKeyCompareStringAdapted) {
574        return true;
575      }
576      const auto compare = [&amp;](field_type a, field_type b) {
577        const absl::weak_ordering cmp =
578            compare_internal::do_three_way_comparison(comp, key(a), key(b));
579        return cmp &lt; 0 ? -1 : cmp &gt; 0 ? 1 : 0;
580      };
581      int cmp = -1;
582      constexpr bool kCanHaveEquivKeys =
583          params_type::template can_have_multiple_equivalent_keys&lt;key_type&gt;();
584      for (field_type j = start(); j &lt; finish(); ++j) {
585        if (j == i) {
586          if (cmp &gt; 0) return false;
587          continue;
588        }
589        int new_cmp = compare(j, i);
590        if (new_cmp &lt; cmp || (!kCanHaveEquivKeys &amp;&amp; new_cmp == 0)) return false;
591        cmp = new_cmp;
592      }
593      return true;
594    }
595    template &lt;typename... Args&gt;
596    void emplace_value(field_type i, allocator_type *alloc, Args &amp;&amp;...args);
597    void remove_values(field_type i, field_type to_erase, allocator_type *alloc);
598    void rebalance_right_to_left(field_type to_move, btree_node *right,
599                                 allocator_type *alloc);
600    void rebalance_left_to_right(field_type to_move, btree_node *right,
601                                 allocator_type *alloc);
602    void split(int insert_position, btree_node *dest, allocator_type *alloc);
603    void merge(btree_node *src, allocator_type *alloc);
604    void init_leaf(field_type position, field_type max_count,
605                   btree_node *parent) {
606      set_generation(0);
607      set_parent(parent);
608      set_position(position);
609      set_start(0);
610      set_finish(0);
611      set_max_count(max_count);
612      absl::container_internal::SanitizerPoisonMemoryRegion(
613          start_slot(), max_count * sizeof(slot_type));
614    }
615    void init_internal(field_type position, btree_node *parent) {
616      init_leaf(position, kNodeSlots, parent);
617      set_max_count(kInternalNodeMaxCount);
618      absl::container_internal::SanitizerPoisonMemoryRegion(
619          &amp;mutable_child(start()), (kNodeSlots + 1) * sizeof(btree_node *));
620    }
621    static void deallocate(const size_type size, btree_node *node,
622                           allocator_type *alloc) {
623      absl::container_internal::SanitizerUnpoisonMemoryRegion(node, size);
624      absl::container_internal::Deallocate&lt;Alignment()&gt;(alloc, node, size);
625    }
626    static void clear_and_delete(btree_node *node, allocator_type *alloc);
627   private:
628    template &lt;typename... Args&gt;
629    void value_init(const field_type i, allocator_type *alloc, Args &amp;&amp;...args) {
630      next_generation();
631      absl::container_internal::SanitizerUnpoisonObject(slot(i));
632      params_type::construct(alloc, slot(i), std::forward&lt;Args&gt;(args)...);
633    }
634    void value_destroy(const field_type i, allocator_type *alloc) {
635      next_generation();
636      params_type::destroy(alloc, slot(i));
637      absl::container_internal::SanitizerPoisonObject(slot(i));
638    }
639    void value_destroy_n(const field_type i, const field_type n,
640                         allocator_type *alloc) {
641      next_generation();
642      for (slot_type *s = slot(i), *end = slot(i + n); s != end; ++s) {
643        params_type::destroy(alloc, s);
644        absl::container_internal::SanitizerPoisonObject(s);
645      }
646    }
647    static void transfer(slot_type *dest, slot_type *src, allocator_type *alloc) {
648      absl::container_internal::SanitizerUnpoisonObject(dest);
649      params_type::transfer(alloc, dest, src);
650      absl::container_internal::SanitizerPoisonObject(src);
651    }
652    void transfer(const size_type dest_i, const size_type src_i,
653                  btree_node *src_node, allocator_type *alloc) {
654      next_generation();
655      transfer(slot(dest_i), src_node-&gt;slot(src_i), alloc);
656    }
657    void transfer_n(const size_type n, const size_type dest_i,
658                    const size_type src_i, btree_node *src_node,
659                    allocator_type *alloc) {
660      next_generation();
661      for (slot_type *src = src_node-&gt;slot(src_i), *end = src + n,
662                     *dest = slot(dest_i);
663           src != end; ++src, ++dest) {
664        transfer(dest, src, alloc);
665      }
666    }
667    void transfer_n_backward(const size_type n, const size_type dest_i,
668                             const size_type src_i, btree_node *src_node,
669                             allocator_type *alloc) {
670      next_generation();
671      for (slot_type *src = src_node-&gt;slot(src_i + n), *end = src - n,
672                     *dest = slot(dest_i + n);
673           src != end; --src, --dest) {
674        transfer(dest - 1, src - 1, alloc);
675      }
676    }
677    template &lt;typename P&gt;
678    friend class btree;
679    template &lt;typename N, typename R, typename P&gt;
680    friend class btree_iterator;
681    friend class BtreeNodePeer;
682    friend struct btree_access;
683  };
684  template &lt;typename Node&gt;
685  bool AreNodesFromSameContainer(const Node *node_a, const Node *node_b) {
686    if (node_a == nullptr || node_b == nullptr) return true;
687    while (!node_a-&gt;is_root()) node_a = node_a-&gt;parent();
<span onclick='openModal()' class='match'>688    while (!node_b-&gt;is_root()) node_b = node_b-&gt;parent();
689    return node_a == node_b;
</span>690  }
691  class btree_iterator_generation_info_enabled {
692   public:
693    explicit btree_iterator_generation_info_enabled(uint32_t g)
694        : generation_(g) {}
695    template &lt;typename Node&gt;
696    void update_generation(const Node *node) {
697      if (node != nullptr) generation_ = node-&gt;generation();
698    }
699    uint32_t generation() const { return generation_; }
700    template &lt;typename Node&gt;
701    void assert_valid_generation(const Node *node) const {
702      if (node != nullptr &amp;&amp; node-&gt;generation() != generation_) {
703        ABSL_INTERNAL_LOG(
704            FATAL,
705            &quot;Attempting to use an invalidated iterator. The corresponding b-tree &quot;
706            &quot;container has been mutated since this iterator was constructed.&quot;);
707      }
708    }
709   private:
710    uint32_t generation_;
711  };
712  class btree_iterator_generation_info_disabled {
713   public:
714    explicit btree_iterator_generation_info_disabled(uint32_t) {}
715    static void update_generation(const void *) {}
716    static uint32_t generation() { return 0; }
717    static void assert_valid_generation(const void *) {}
718  };
719  #ifdef ABSL_BTREE_ENABLE_GENERATIONS
720  using btree_iterator_generation_info = btree_iterator_generation_info_enabled;
721  #else
722  using btree_iterator_generation_info = btree_iterator_generation_info_disabled;
723  #endif
724  template &lt;typename Node, typename Reference, typename Pointer&gt;
725  class btree_iterator : private btree_iterator_generation_info {
726    using field_type = typename Node::field_type;
727    using key_type = typename Node::key_type;
728    using size_type = typename Node::size_type;
729    using params_type = typename Node::params_type;
730    using is_map_container = typename params_type::is_map_container;
731    using node_type = Node;
732    using normal_node = typename std::remove_const&lt;Node&gt;::type;
733    using const_node = const Node;
734    using normal_pointer = typename params_type::pointer;
735    using normal_reference = typename params_type::reference;
736    using const_pointer = typename params_type::const_pointer;
737    using const_reference = typename params_type::const_reference;
738    using slot_type = typename params_type::slot_type;
739    using iterator =
740       btree_iterator&lt;normal_node, normal_reference, normal_pointer&gt;;
741    using const_iterator =
742        btree_iterator&lt;const_node, const_reference, const_pointer&gt;;
743   public:
744    using difference_type = typename Node::difference_type;
745    using value_type = typename params_type::value_type;
746    using pointer = Pointer;
747    using reference = Reference;
748    using iterator_category = std::bidirectional_iterator_tag;
749    btree_iterator() : btree_iterator(nullptr, -1) {}
750    explicit btree_iterator(Node *n) : btree_iterator(n, n-&gt;start()) {}
751    btree_iterator(Node *n, int p)
752        : btree_iterator_generation_info(n != nullptr ? n-&gt;generation()
753                                                      : ~uint32_t{}),
754          node_(n),
755          position_(p) {}
756    template &lt;typename N, typename R, typename P,
757              absl::enable_if_t&lt;
758                  std::is_same&lt;btree_iterator&lt;N, R, P&gt;, iterator&gt;::value &amp;&amp;
759                      std::is_same&lt;btree_iterator, const_iterator&gt;::value,
760                  int&gt; = 0&gt;
761    btree_iterator(const btree_iterator&lt;N, R, P&gt; other)  
762        : btree_iterator_generation_info(other),
763          node_(other.node_),
764          position_(other.position_) {}
765    bool operator==(const iterator &amp;other) const {
766      return Equals(other);
767    }
768    bool operator==(const const_iterator &amp;other) const {
769      return Equals(other);
770    }
771    bool operator!=(const iterator &amp;other) const {
772      return !Equals(other);
773    }
774    bool operator!=(const const_iterator &amp;other) const {
775      return !Equals(other);
776    }
777    difference_type operator-(const_iterator other) const {
778      if (node_ == other.node_) {
779        if (node_-&gt;is_leaf()) return position_ - other.position_;
780        if (position_ == other.position_) return 0;
781      }
782      return distance_slow(other);
783    }
784    reference operator*() const {
785      ABSL_HARDENING_ASSERT(node_ != nullptr);
786      assert_valid_generation(node_);
787      ABSL_HARDENING_ASSERT(position_ &gt;= node_-&gt;start());
788      if (position_ &gt;= node_-&gt;finish()) {
789        ABSL_HARDENING_ASSERT(!IsEndIterator() &amp;&amp; &quot;Dereferencing end() iterator&quot;);
790        ABSL_HARDENING_ASSERT(position_ &lt; node_-&gt;finish());
791      }
792      return node_-&gt;value(static_cast&lt;field_type&gt;(position_));
793    }
794    pointer operator-&gt;() const { return &amp;operator*(); }
795    btree_iterator &amp;operator++() {
796      increment();
797      return *this;
798    }
799    btree_iterator &amp;operator--() {
800      decrement();
801      return *this;
802    }
803    btree_iterator operator++(int) {
804      btree_iterator tmp = *this;
805      ++*this;
806      return tmp;
807    }
808    btree_iterator operator--(int) {
809      btree_iterator tmp = *this;
810      --*this;
811      return tmp;
812    }
813   private:
814    friend iterator;
815    friend const_iterator;
816    template &lt;typename Params&gt;
817    friend class btree;
818    template &lt;typename Tree&gt;
819    friend class btree_container;
820    template &lt;typename Tree&gt;
821    friend class btree_set_container;
822    template &lt;typename Tree&gt;
823    friend class btree_map_container;
824    template &lt;typename Tree&gt;
825    friend class btree_multiset_container;
826    template &lt;typename TreeType, typename CheckerType&gt;
827    friend class base_checker;
828    friend struct btree_access;
829    template &lt;typename N, typename R, typename P,
830              absl::enable_if_t&lt;
831                  std::is_same&lt;btree_iterator&lt;N, R, P&gt;, const_iterator&gt;::value &amp;&amp;
832                      std::is_same&lt;btree_iterator, iterator&gt;::value,
833                  int&gt; = 0&gt;
834    explicit btree_iterator(const btree_iterator&lt;N, R, P&gt; other)
835        : btree_iterator_generation_info(other.generation()),
836          node_(const_cast&lt;node_type *&gt;(other.node_)),
837          position_(other.position_) {}
838    bool Equals(const const_iterator other) const {
839      ABSL_HARDENING_ASSERT(((node_ == nullptr &amp;&amp; other.node_ == nullptr) ||
840                             (node_ != nullptr &amp;&amp; other.node_ != nullptr)) &amp;&amp;
841                            &quot;Comparing default-constructed iterator with &quot;
842                            &quot;non-default-constructed iterator.&quot;);
843      assert(AreNodesFromSameContainer(node_, other.node_) &amp;&amp;
844             &quot;Comparing iterators from different containers.&quot;);
845      assert_valid_generation(node_);
846      other.assert_valid_generation(other.node_);
847      return node_ == other.node_ &amp;&amp; position_ == other.position_;
848    }
849    bool IsEndIterator() const {
850      if (position_ != node_-&gt;finish()) return false;
851      node_type *node = node_;
852      while (!node-&gt;is_root()) {
853        if (node-&gt;position() != node-&gt;parent()-&gt;finish()) return false;
854        node = node-&gt;parent();
855      }
856      return true;
857    }
858    difference_type distance_slow(const_iterator other) const;
859    void increment() {
860      assert_valid_generation(node_);
861      if (node_-&gt;is_leaf() &amp;&amp; ++position_ &lt; node_-&gt;finish()) {
862        return;
863      }
864      increment_slow();
865    }
866    void increment_slow();
867    void decrement() {
868      assert_valid_generation(node_);
869      if (node_-&gt;is_leaf() &amp;&amp; --position_ &gt;= node_-&gt;start()) {
870        return;
871      }
872      decrement_slow();
873    }
874    void decrement_slow();
875    const key_type &amp;key() const {
876      return node_-&gt;key(static_cast&lt;size_type&gt;(position_));
877    }
878    decltype(std::declval&lt;Node *&gt;()-&gt;slot(0)) slot() {
879      return node_-&gt;slot(static_cast&lt;size_type&gt;(position_));
880    }
881    void update_generation() {
882      btree_iterator_generation_info::update_generation(node_);
883    }
884    Node *node_;
885    int position_;
886  };
887  template &lt;typename Params&gt;
888  class btree {
889    using node_type = btree_node&lt;Params&gt;;
890    using is_key_compare_to = typename Params::is_key_compare_to;
891    using field_type = typename node_type::field_type;
892    struct alignas(node_type::Alignment()) EmptyNodeType : node_type {
893      using field_type = typename node_type::field_type;
894      node_type *parent;
895  #ifdef ABSL_BTREE_ENABLE_GENERATIONS
896      uint32_t generation = 0;
897  #endif
898      field_type position = 0;
899      field_type start = 0;
900      field_type finish = 0;
901      field_type max_count = node_type::kInternalNodeMaxCount + 1;
902  #ifdef _MSC_VER
903      EmptyNodeType() : parent(this) {}
904  #else
905      explicit constexpr EmptyNodeType(node_type *p) : parent(p) {}
906  #endif
907    };
908    static node_type *EmptyNode() {
909  #ifdef _MSC_VER
910      static EmptyNodeType *empty_node = new EmptyNodeType;
911      assert(empty_node-&gt;parent == empty_node);
912      return empty_node;
913  #else
914      static constexpr EmptyNodeType empty_node(
915          const_cast&lt;EmptyNodeType *&gt;(&amp;empty_node));
916      return const_cast&lt;EmptyNodeType *&gt;(&amp;empty_node);
917  #endif
918    }
919    enum : uint32_t {
920      kNodeSlots = node_type::kNodeSlots,
921      kMinNodeValues = kNodeSlots / 2,
922    };
923    struct node_stats {
924      using size_type = typename Params::size_type;
925      node_stats(size_type l, size_type i) : leaf_nodes(l), internal_nodes(i) {}
926      node_stats &amp;operator+=(const node_stats &amp;other) {
927        leaf_nodes += other.leaf_nodes;
928        internal_nodes += other.internal_nodes;
929        return *this;
930      }
931      size_type leaf_nodes;
932      size_type internal_nodes;
933    };
934   public:
935    using key_type = typename Params::key_type;
936    using value_type = typename Params::value_type;
937    using size_type = typename Params::size_type;
938    using difference_type = typename Params::difference_type;
939    using key_compare = typename Params::key_compare;
940    using original_key_compare = typename Params::original_key_compare;
941    using value_compare = typename Params::value_compare;
942    using allocator_type = typename Params::allocator_type;
943    using reference = typename Params::reference;
944    using const_reference = typename Params::const_reference;
945    using pointer = typename Params::pointer;
946    using const_pointer = typename Params::const_pointer;
947    using iterator =
948        typename btree_iterator&lt;node_type, reference, pointer&gt;::iterator;
949    using const_iterator = typename iterator::const_iterator;
950    using reverse_iterator = std::reverse_iterator&lt;iterator&gt;;
951    using const_reverse_iterator = std::reverse_iterator&lt;const_iterator&gt;;
952    using node_handle_type = node_handle&lt;Params, Params, allocator_type&gt;;
953    using params_type = Params;
954    using slot_type = typename Params::slot_type;
955   private:
956    template &lt;typename Btree&gt;
957    void copy_or_move_values_in_order(Btree &amp;other);
958    constexpr static bool static_assert_validation();
959   public:
960    btree(const key_compare &amp;comp, const allocator_type &amp;alloc)
961        : root_(EmptyNode()), rightmost_(comp, alloc, EmptyNode()), size_(0) {}
962    btree(const btree &amp;other) : btree(other, other.allocator()) {}
963    btree(const btree &amp;other, const allocator_type &amp;alloc)
964        : btree(other.key_comp(), alloc) {
965      copy_or_move_values_in_order(other);
966    }
967    btree(btree &amp;&amp;other) noexcept
968        : root_(absl::exchange(other.root_, EmptyNode())),
969          rightmost_(std::move(other.rightmost_)),
970          size_(absl::exchange(other.size_, 0u)) {
971      other.mutable_rightmost() = EmptyNode();
972    }
973    btree(btree &amp;&amp;other, const allocator_type &amp;alloc)
974        : btree(other.key_comp(), alloc) {
975      if (alloc == other.allocator()) {
976        swap(other);
977      } else {
978        copy_or_move_values_in_order(other);
979      }
980    }
981    ~btree() {
982      static_assert(static_assert_validation(), &quot;This call must be elided.&quot;);
983      clear();
984    }
985    btree &amp;operator=(const btree &amp;other);
986    btree &amp;operator=(btree &amp;&amp;other) noexcept;
987    iterator begin() { return iterator(leftmost()); }
988    const_iterator begin() const { return const_iterator(leftmost()); }
989    iterator end() { return iterator(rightmost(), rightmost()-&gt;finish()); }
990    const_iterator end() const {
991      return const_iterator(rightmost(), rightmost()-&gt;finish());
992    }
993    reverse_iterator rbegin() { return reverse_iterator(end()); }
994    const_reverse_iterator rbegin() const {
995      return const_reverse_iterator(end());
996    }
997    reverse_iterator rend() { return reverse_iterator(begin()); }
998    const_reverse_iterator rend() const {
999      return const_reverse_iterator(begin());
1000    }
1001    template &lt;typename K&gt;
1002    iterator lower_bound(const K &amp;key) {
1003      return internal_end(internal_lower_bound(key).value);
1004    }
1005    template &lt;typename K&gt;
1006    const_iterator lower_bound(const K &amp;key) const {
1007      return internal_end(internal_lower_bound(key).value);
1008    }
1009    template &lt;typename K&gt;
1010    std::pair&lt;iterator, bool&gt; lower_bound_equal(const K &amp;key) const;
1011    template &lt;typename K&gt;
1012    iterator upper_bound(const K &amp;key) {
1013      return internal_end(internal_upper_bound(key));
1014    }
1015    template &lt;typename K&gt;
1016    const_iterator upper_bound(const K &amp;key) const {
1017      return internal_end(internal_upper_bound(key));
1018    }
1019    template &lt;typename K&gt;
1020    std::pair&lt;iterator, iterator&gt; equal_range(const K &amp;key);
1021    template &lt;typename K&gt;
1022    std::pair&lt;const_iterator, const_iterator&gt; equal_range(const K &amp;key) const {
1023      return const_cast&lt;btree *&gt;(this)-&gt;equal_range(key);
1024    }
1025    template &lt;typename K, typename... Args&gt;
1026    std::pair&lt;iterator, bool&gt; insert_unique(const K &amp;key, Args &amp;&amp;...args);
1027    template &lt;typename K, typename... Args&gt;
1028    std::pair&lt;iterator, bool&gt; insert_hint_unique(iterator position, const K &amp;key,
1029                                                 Args &amp;&amp;...args);
1030    template &lt;typename InputIterator,
1031              typename = decltype(std::declval&lt;const key_compare &amp;&gt;()(
1032                  params_type::key(*std::declval&lt;InputIterator&gt;()),
1033                  std::declval&lt;const key_type &amp;&gt;()))&gt;
1034    void insert_iterator_unique(InputIterator b, InputIterator e, int);
1035    template &lt;typename InputIterator&gt;
1036    void insert_iterator_unique(InputIterator b, InputIterator e, char);
1037    template &lt;typename ValueType&gt;
1038    iterator insert_multi(const key_type &amp;key, ValueType &amp;&amp;v);
1039    template &lt;typename ValueType&gt;
1040    iterator insert_multi(ValueType &amp;&amp;v) {
1041      return insert_multi(params_type::key(v), std::forward&lt;ValueType&gt;(v));
1042    }
1043    template &lt;typename ValueType&gt;
1044    iterator insert_hint_multi(iterator position, ValueType &amp;&amp;v);
1045    template &lt;typename InputIterator&gt;
1046    void insert_iterator_multi(InputIterator b,
1047                               InputIterator e);
1048    iterator erase(iterator iter);
1049    std::pair&lt;size_type, iterator&gt; erase_range(iterator begin, iterator end);
1050    template &lt;typename K&gt;
1051    iterator find(const K &amp;key) {
1052      return internal_end(internal_find(key));
1053    }
1054    template &lt;typename K&gt;
1055    const_iterator find(const K &amp;key) const {
1056      return internal_end(internal_find(key));
1057    }
1058    void clear();
1059    void swap(btree &amp;other);
1060    const key_compare &amp;key_comp() const noexcept {
1061      return rightmost_.template get&lt;0&gt;();
1062    }
1063    template &lt;typename K1, typename K2&gt;
1064    bool compare_keys(const K1 &amp;a, const K2 &amp;b) const {
1065      return compare_internal::compare_result_as_less_than(key_comp()(a, b));
1066    }
1067    value_compare value_comp() const {
1068      return value_compare(original_key_compare(key_comp()));
1069    }
1070    void verify() const;
1071    size_type size() const { return size_; }
1072    size_type max_size() const { return (std::numeric_limits&lt;size_type&gt;::max)(); }
1073    bool empty() const { return size_ == 0; }
1074    size_type height() const {
1075      size_type h = 0;
1076      if (!empty()) {
1077        const node_type *n = root();
1078        do {
1079          ++h;
1080          n = n-&gt;parent();
1081        } while (n != root());
1082      }
1083      return h;
1084    }
1085    size_type leaf_nodes() const { return internal_stats(root()).leaf_nodes; }
1086    size_type internal_nodes() const {
1087      return internal_stats(root()).internal_nodes;
1088    }
1089    size_type nodes() const {
1090      node_stats stats = internal_stats(root());
1091      return stats.leaf_nodes + stats.internal_nodes;
1092    }
1093    size_type bytes_used() const {
1094      node_stats stats = internal_stats(root());
1095      if (stats.leaf_nodes == 1 &amp;&amp; stats.internal_nodes == 0) {
1096        return sizeof(*this) + node_type::LeafSize(root()-&gt;max_count());
1097      } else {
1098        return sizeof(*this) + stats.leaf_nodes * node_type::LeafSize() +
1099               stats.internal_nodes * node_type::InternalSize();
1100      }
1101    }
1102    static double average_bytes_per_value() {
1103      const double expected_values_per_node = (kNodeSlots + kMinNodeValues) / 2.0;
1104      return node_type::LeafSize() / expected_values_per_node;
1105    }
1106    double fullness() const {
1107      if (empty()) return 0.0;
1108      return static_cast&lt;double&gt;(size()) / (nodes() * kNodeSlots);
1109    }
1110    double overhead() const {
1111      if (empty()) return 0.0;
1112      return (bytes_used() - size() * sizeof(value_type)) /
1113             static_cast&lt;double&gt;(size());
1114    }
1115    allocator_type get_allocator() const { return allocator(); }
1116   private:
1117    friend struct btree_access;
1118    node_type *root() { return root_; }
1119    const node_type *root() const { return root_; }
1120    node_type *&amp;mutable_root() noexcept { return root_; }
1121    node_type *rightmost() { return rightmost_.template get&lt;2&gt;(); }
1122    const node_type *rightmost() const { return rightmost_.template get&lt;2&gt;(); }
1123    node_type *&amp;mutable_rightmost() noexcept {
1124      return rightmost_.template get&lt;2&gt;();
1125    }
1126    key_compare *mutable_key_comp() noexcept {
1127      return &amp;rightmost_.template get&lt;0&gt;();
1128    }
1129    node_type *leftmost() { return root()-&gt;parent(); }
1130    const node_type *leftmost() const { return root()-&gt;parent(); }
1131    allocator_type *mutable_allocator() noexcept {
1132      return &amp;rightmost_.template get&lt;1&gt;();
1133    }
1134    const allocator_type &amp;allocator() const noexcept {
1135      return rightmost_.template get&lt;1&gt;();
1136    }
1137    node_type *allocate(size_type size) {
1138      return reinterpret_cast&lt;node_type *&gt;(
1139          absl::container_internal::Allocate&lt;node_type::Alignment()&gt;(
1140              mutable_allocator(), size));
1141    }
1142    node_type *new_internal_node(field_type position, node_type *parent) {
1143      node_type *n = allocate(node_type::InternalSize());
1144      n-&gt;init_internal(position, parent);
1145      return n;
1146    }
1147    node_type *new_leaf_node(field_type position, node_type *parent) {
1148      node_type *n = allocate(node_type::LeafSize());
1149      n-&gt;init_leaf(position, kNodeSlots, parent);
1150      return n;
1151    }
1152    node_type *new_leaf_root_node(field_type max_count) {
1153      node_type *n = allocate(node_type::LeafSize(max_count));
1154      n-&gt;init_leaf(&amp;bsol;*position=*/0, max_count, &amp;bsol;*parent=*/n);
1155      return n;
1156    }
1157    iterator rebalance_after_delete(iterator iter);
1158    void rebalance_or_split(iterator *iter);
1159    void merge_nodes(node_type *left, node_type *right);
1160    bool try_merge_or_rebalance(iterator *iter);
1161    void try_shrink();
1162    iterator internal_end(iterator iter) {
1163      return iter.node_ != nullptr ? iter : end();
1164    }
1165    const_iterator internal_end(const_iterator iter) const {
1166      return iter.node_ != nullptr ? iter : end();
1167    }
1168    template &lt;typename... Args&gt;
1169    iterator internal_emplace(iterator iter, Args &amp;&amp;...args);
1170    template &lt;typename IterType&gt;
1171    static IterType internal_last(IterType iter);
1172    template &lt;typename K&gt;
1173    SearchResult&lt;iterator, is_key_compare_to::value&gt; internal_locate(
1174        const K &amp;key) const;
1175    template &lt;typename K&gt;
1176    SearchResult&lt;iterator, is_key_compare_to::value&gt; internal_lower_bound(
1177        const K &amp;key) const;
1178    template &lt;typename K&gt;
1179    iterator internal_upper_bound(const K &amp;key) const;
1180    template &lt;typename K&gt;
1181    iterator internal_find(const K &amp;key) const;
1182    size_type internal_verify(const node_type *node, const key_type *lo,
1183                              const key_type *hi) const;
1184    node_stats internal_stats(const node_type *node) const {
1185      if (node == nullptr || (node == root() &amp;&amp; empty())) {
1186        return node_stats(0, 0);
1187      }
1188      if (node-&gt;is_leaf()) {
1189        return node_stats(1, 0);
1190      }
1191      node_stats res(0, 1);
1192      for (int i = node-&gt;start(); i &lt;= node-&gt;finish(); ++i) {
1193        res += internal_stats(node-&gt;child(i));
1194      }
1195      return res;
1196    }
1197    node_type *root_;
1198    absl::container_internal::CompressedTuple&lt;key_compare, allocator_type,
1199                                              node_type *&gt;
1200        rightmost_;
1201    size_type size_;
1202  };
1203  template &lt;typename P&gt;
1204  template &lt;typename... Args&gt;
1205  inline void btree_node&lt;P&gt;::emplace_value(const field_type i,
1206                                           allocator_type *alloc,
1207                                           Args &amp;&amp;...args) {
1208    assert(i &gt;= start());
1209    assert(i &lt;= finish());
1210    if (i &lt; finish()) {
1211      transfer_n_backward(finish() - i, &amp;bsol;*dest_i=*/i + 1, &amp;bsol;*src_i=*/i, this,
1212                          alloc);
1213    }
1214    value_init(static_cast&lt;field_type&gt;(i), alloc, std::forward&lt;Args&gt;(args)...);
1215    set_finish(finish() + 1);
1216    if (is_internal() &amp;&amp; finish() &gt; i + 1) {
1217      for (field_type j = finish(); j &gt; i + 1; --j) {
1218        set_child(j, child(j - 1));
1219      }
1220      clear_child(i + 1);
1221    }
1222  }
1223  template &lt;typename P&gt;
1224  inline void btree_node&lt;P&gt;::remove_values(const field_type i,
1225                                           const field_type to_erase,
1226                                           allocator_type *alloc) {
1227    value_destroy_n(i, to_erase, alloc);
1228    const field_type orig_finish = finish();
1229    const field_type src_i = i + to_erase;
1230    transfer_n(orig_finish - src_i, i, src_i, this, alloc);
1231    if (is_internal()) {
1232      for (field_type j = 0; j &lt; to_erase; ++j) {
1233        clear_and_delete(child(i + j + 1), alloc);
1234      }
1235      for (field_type j = i + to_erase + 1; j &lt;= orig_finish; ++j) {
1236        set_child(j - to_erase, child(j));
1237        clear_child(j);
1238      }
1239    }
1240    set_finish(orig_finish - to_erase);
1241  }
1242  template &lt;typename P&gt;
1243  void btree_node&lt;P&gt;::rebalance_right_to_left(field_type to_move,
1244                                              btree_node *right,
1245                                              allocator_type *alloc) {
1246    assert(parent() == right-&gt;parent());
1247    assert(position() + 1 == right-&gt;position());
1248    assert(right-&gt;count() &gt;= count());
1249    assert(to_move &gt;= 1);
1250    assert(to_move &lt;= right-&gt;count());
1251    transfer(finish(), position(), parent(), alloc);
1252    transfer_n(to_move - 1, finish() + 1, right-&gt;start(), right, alloc);
1253    parent()-&gt;transfer(position(), right-&gt;start() + to_move - 1, right, alloc);
1254    right-&gt;transfer_n(right-&gt;count() - to_move, right-&gt;start(),
1255                      right-&gt;start() + to_move, right, alloc);
1256    if (is_internal()) {
1257      for (field_type i = 0; i &lt; to_move; ++i) {
1258        init_child(finish() + i + 1, right-&gt;child(i));
1259      }
1260      for (field_type i = right-&gt;start(); i &lt;= right-&gt;finish() - to_move; ++i) {
1261        assert(i + to_move &lt;= right-&gt;max_count());
1262        right-&gt;init_child(i, right-&gt;child(i + to_move));
1263        right-&gt;clear_child(i + to_move);
1264      }
1265    }
1266    set_finish(finish() + to_move);
1267    right-&gt;set_finish(right-&gt;finish() - to_move);
1268  }
1269  template &lt;typename P&gt;
1270  void btree_node&lt;P&gt;::rebalance_left_to_right(field_type to_move,
1271                                              btree_node *right,
1272                                              allocator_type *alloc) {
1273    assert(parent() == right-&gt;parent());
1274    assert(position() + 1 == right-&gt;position());
1275    assert(count() &gt;= right-&gt;count());
1276    assert(to_move &gt;= 1);
1277    assert(to_move &lt;= count());
1278    right-&gt;transfer_n_backward(right-&gt;count(), right-&gt;start() + to_move,
1279                               right-&gt;start(), right, alloc);
1280    right-&gt;transfer(right-&gt;start() + to_move - 1, position(), parent(), alloc);
1281    right-&gt;transfer_n(to_move - 1, right-&gt;start(), finish() - (to_move - 1), this,
1282                      alloc);
1283    parent()-&gt;transfer(position(), finish() - to_move, this, alloc);
1284    if (is_internal()) {
1285      for (field_type i = right-&gt;finish() + 1; i &gt; right-&gt;start(); --i) {
1286        right-&gt;init_child(i - 1 + to_move, right-&gt;child(i - 1));
1287        right-&gt;clear_child(i - 1);
1288      }
1289      for (field_type i = 1; i &lt;= to_move; ++i) {
1290        right-&gt;init_child(i - 1, child(finish() - to_move + i));
1291        clear_child(finish() - to_move + i);
1292      }
1293    }
1294    set_finish(finish() - to_move);
1295    right-&gt;set_finish(right-&gt;finish() + to_move);
1296  }
1297  template &lt;typename P&gt;
1298  void btree_node&lt;P&gt;::split(const int insert_position, btree_node *dest,
1299                            allocator_type *alloc) {
1300    assert(dest-&gt;count() == 0);
1301    assert(max_count() == kNodeSlots);
1302    assert(position() + 1 == dest-&gt;position());
1303    assert(parent() == dest-&gt;parent());
1304    if (insert_position == start()) {
1305      dest-&gt;set_finish(dest-&gt;start() + finish() - 1);
1306    } else if (insert_position == kNodeSlots) {
1307      dest-&gt;set_finish(dest-&gt;start());
1308    } else {
1309      dest-&gt;set_finish(dest-&gt;start() + count() / 2);
1310    }
1311    set_finish(finish() - dest-&gt;count());
1312    assert(count() &gt;= 1);
1313    dest-&gt;transfer_n(dest-&gt;count(), dest-&gt;start(), finish(), this, alloc);
1314    --mutable_finish();
1315    parent()-&gt;emplace_value(position(), alloc, finish_slot());
1316    value_destroy(finish(), alloc);
1317    parent()-&gt;set_child_noupdate_position(position() + 1, dest);
1318    if (is_internal()) {
1319      for (field_type i = dest-&gt;start(), j = finish() + 1; i &lt;= dest-&gt;finish();
1320           ++i, ++j) {
1321        assert(child(j) != nullptr);
1322        dest-&gt;init_child(i, child(j));
1323        clear_child(j);
1324      }
1325    }
1326  }
1327  template &lt;typename P&gt;
1328  void btree_node&lt;P&gt;::merge(btree_node *src, allocator_type *alloc) {
1329    assert(parent() == src-&gt;parent());
1330    assert(position() + 1 == src-&gt;position());
1331    value_init(finish(), alloc, parent()-&gt;slot(position()));
1332    transfer_n(src-&gt;count(), finish() + 1, src-&gt;start(), src, alloc);
1333    if (is_internal()) {
1334      for (field_type i = src-&gt;start(), j = finish() + 1; i &lt;= src-&gt;finish();
1335           ++i, ++j) {
1336        init_child(j, src-&gt;child(i));
1337        src-&gt;clear_child(i);
1338      }
1339    }
1340    set_finish(start() + 1 + count() + src-&gt;count());
1341    src-&gt;set_finish(src-&gt;start());
1342    parent()-&gt;remove_values(position(), &amp;bsol;*to_erase=*/1, alloc);
1343  }
1344  template &lt;typename P&gt;
1345  void btree_node&lt;P&gt;::clear_and_delete(btree_node *node, allocator_type *alloc) {
1346    if (node-&gt;is_leaf()) {
1347      node-&gt;value_destroy_n(node-&gt;start(), node-&gt;count(), alloc);
1348      deallocate(LeafSize(node-&gt;max_count()), node, alloc);
1349      return;
1350    }
1351    if (node-&gt;count() == 0) {
1352      deallocate(InternalSize(), node, alloc);
1353      return;
1354    }
1355    btree_node *delete_root_parent = node-&gt;parent();
1356    while (node-&gt;is_internal()) node = node-&gt;start_child();
1357  #ifdef ABSL_BTREE_ENABLE_GENERATIONS
1358    btree_node *leftmost_leaf = node;
1359  #endif
1360    size_type pos = node-&gt;position();
1361    btree_node *parent = node-&gt;parent();
1362    for (;;) {
1363      assert(pos &lt;= parent-&gt;finish());
1364      do {
1365        node = parent-&gt;child(static_cast&lt;field_type&gt;(pos));
1366        if (node-&gt;is_internal()) {
1367          while (node-&gt;is_internal()) node = node-&gt;start_child();
1368          pos = node-&gt;position();
1369          parent = node-&gt;parent();
1370        }
1371        node-&gt;value_destroy_n(node-&gt;start(), node-&gt;count(), alloc);
1372  #ifdef ABSL_BTREE_ENABLE_GENERATIONS
1373        if (leftmost_leaf != node)
1374  #endif
1375          deallocate(LeafSize(node-&gt;max_count()), node, alloc);
1376        ++pos;
1377      } while (pos &lt;= parent-&gt;finish());
1378      assert(pos &gt; parent-&gt;finish());
1379      do {
1380        node = parent;
1381        pos = node-&gt;position();
1382        parent = node-&gt;parent();
1383        node-&gt;value_destroy_n(node-&gt;start(), node-&gt;count(), alloc);
1384        deallocate(InternalSize(), node, alloc);
1385        if (parent == delete_root_parent) {
1386  #ifdef ABSL_BTREE_ENABLE_GENERATIONS
1387          deallocate(LeafSize(leftmost_leaf-&gt;max_count()), leftmost_leaf, alloc);
1388  #endif
1389          return;
1390        }
1391        ++pos;
1392      } while (pos &gt; parent-&gt;finish());
1393    }
1394  }
1395  template &lt;typename N, typename R, typename P&gt;
1396  auto btree_iterator&lt;N, R, P&gt;::distance_slow(const_iterator other) const
1397      -&gt; difference_type {
1398    const_iterator begin = other;
1399    const_iterator end = *this;
1400    assert(begin.node_ != end.node_ || !begin.node_-&gt;is_leaf() ||
1401           begin.position_ != end.position_);
1402    const node_type *node = begin.node_;
1403    difference_type count = node-&gt;is_leaf() ? -begin.position_ : 0;
1404    if (node-&gt;is_internal()) {
1405      ++count;
1406      node = node-&gt;child(begin.position_ + 1);
1407    }
1408    while (node-&gt;is_internal()) node = node-&gt;start_child();
1409    size_type pos = node-&gt;position();
1410    const node_type *parent = node-&gt;parent();
1411    for (;;) {
1412      assert(pos &lt;= parent-&gt;finish());
1413      do {
1414        node = parent-&gt;child(static_cast&lt;field_type&gt;(pos));
1415        if (node-&gt;is_internal()) {
1416          while (node-&gt;is_internal()) node = node-&gt;start_child();
1417          pos = node-&gt;position();
1418          parent = node-&gt;parent();
1419        }
1420        if (node == end.node_) return count + end.position_;
1421        if (parent == end.node_ &amp;&amp; pos == static_cast&lt;size_type&gt;(end.position_))
1422          return count + node-&gt;count();
1423        count += node-&gt;count() + 1;
1424        ++pos;
1425      } while (pos &lt;= parent-&gt;finish());
1426      assert(pos &gt; parent-&gt;finish());
1427      do {
1428        node = parent;
1429        pos = node-&gt;position();
1430        parent = node-&gt;parent();
1431        if (parent == end.node_ &amp;&amp; pos == static_cast&lt;size_type&gt;(end.position_))
1432          return count - 1;
1433        ++pos;
1434      } while (pos &gt; parent-&gt;finish());
1435    }
1436  }
1437  template &lt;typename N, typename R, typename P&gt;
1438  void btree_iterator&lt;N, R, P&gt;::increment_slow() {
1439    if (node_-&gt;is_leaf()) {
1440      assert(position_ &gt;= node_-&gt;finish());
1441      btree_iterator save(*this);
1442      while (position_ == node_-&gt;finish() &amp;&amp; !node_-&gt;is_root()) {
1443        assert(node_-&gt;parent()-&gt;child(node_-&gt;position()) == node_);
1444        position_ = node_-&gt;position();
1445        node_ = node_-&gt;parent();
1446      }
1447      if (position_ == node_-&gt;finish()) {
1448        *this = save;
1449      }
1450    } else {
1451      assert(position_ &lt; node_-&gt;finish());
1452      node_ = node_-&gt;child(static_cast&lt;field_type&gt;(position_ + 1));
1453      while (node_-&gt;is_internal()) {
1454        node_ = node_-&gt;start_child();
1455      }
1456      position_ = node_-&gt;start();
1457    }
1458  }
1459  template &lt;typename N, typename R, typename P&gt;
1460  void btree_iterator&lt;N, R, P&gt;::decrement_slow() {
1461    if (node_-&gt;is_leaf()) {
1462      assert(position_ &lt;= -1);
1463      btree_iterator save(*this);
1464      while (position_ &lt; node_-&gt;start() &amp;&amp; !node_-&gt;is_root()) {
1465        assert(node_-&gt;parent()-&gt;child(node_-&gt;position()) == node_);
1466        position_ = node_-&gt;position() - 1;
1467        node_ = node_-&gt;parent();
1468      }
1469      if (position_ &lt; node_-&gt;start()) {
1470        *this = save;
1471      }
1472    } else {
1473      assert(position_ &gt;= node_-&gt;start());
1474      node_ = node_-&gt;child(static_cast&lt;field_type&gt;(position_));
1475      while (node_-&gt;is_internal()) {
1476        node_ = node_-&gt;child(node_-&gt;finish());
1477      }
1478      position_ = node_-&gt;finish() - 1;
1479    }
1480  }
1481  template &lt;typename P&gt;
1482  template &lt;typename Btree&gt;
1483  void btree&lt;P&gt;::copy_or_move_values_in_order(Btree &amp;other) {
1484    static_assert(std::is_same&lt;btree, Btree&gt;::value ||
1485                      std::is_same&lt;const btree, Btree&gt;::value,
1486                  &quot;Btree type must be same or const.&quot;);
1487    assert(empty());
1488    auto iter = other.begin();
1489    if (iter == other.end()) return;
1490    insert_multi(iter.slot());
1491    ++iter;
1492    for (; iter != other.end(); ++iter) {
1493      internal_emplace(end(), iter.slot());
1494    }
1495  }
1496  template &lt;typename P&gt;
1497  constexpr bool btree&lt;P&gt;::static_assert_validation() {
1498    static_assert(std::is_nothrow_copy_constructible&lt;key_compare&gt;::value,
1499                  &quot;Key comparison must be nothrow copy constructible&quot;);
1500    static_assert(std::is_nothrow_copy_constructible&lt;allocator_type&gt;::value,
1501                  &quot;Allocator must be nothrow copy constructible&quot;);
1502    static_assert(std::is_trivially_copyable&lt;iterator&gt;::value,
1503                  &quot;iterator not trivially copyable.&quot;);
1504    static_assert(
1505        kNodeSlots &lt; (1 &lt;&lt; (8 * sizeof(typename node_type::field_type))),
1506        &quot;target node size too large&quot;);
1507    static_assert(
1508        compare_has_valid_result_type&lt;key_compare, key_type&gt;(),
1509        &quot;key comparison function must return absl::{weak,strong}_ordering or &quot;
1510        &quot;bool.&quot;);
1511    static_assert(node_type::MinimumOverhead() &gt;= sizeof(void *) + 4,
1512                  &quot;node space assumption incorrect&quot;);
1513    return true;
1514  }
1515  template &lt;typename P&gt;
1516  template &lt;typename K&gt;
1517  auto btree&lt;P&gt;::lower_bound_equal(const K &amp;key) const
1518      -&gt; std::pair&lt;iterator, bool&gt; {
1519    const SearchResult&lt;iterator, is_key_compare_to::value&gt; res =
1520        internal_lower_bound(key);
1521    const iterator lower = iterator(internal_end(res.value));
1522    const bool equal = res.HasMatch()
1523                           ? res.IsEq()
1524                           : lower != end() &amp;&amp; !compare_keys(key, lower.key());
1525    return {lower, equal};
1526  }
1527  template &lt;typename P&gt;
1528  template &lt;typename K&gt;
1529  auto btree&lt;P&gt;::equal_range(const K &amp;key) -&gt; std::pair&lt;iterator, iterator&gt; {
1530    const std::pair&lt;iterator, bool&gt; lower_and_equal = lower_bound_equal(key);
1531    const iterator lower = lower_and_equal.first;
1532    if (!lower_and_equal.second) {
1533      return {lower, lower};
1534    }
1535    const iterator next = std::next(lower);
1536    if (!params_type::template can_have_multiple_equivalent_keys&lt;K&gt;()) {
1537      assert(next == end() || compare_keys(key, next.key()));
1538      return {lower, next};
1539    }
1540    if (next == end() || compare_keys(key, next.key())) return {lower, next};
1541    return {lower, upper_bound(key)};
1542  }
1543  template &lt;typename P&gt;
1544  template &lt;typename K, typename... Args&gt;
1545  auto btree&lt;P&gt;::insert_unique(const K &amp;key, Args &amp;&amp;...args)
1546      -&gt; std::pair&lt;iterator, bool&gt; {
1547    if (empty()) {
1548      mutable_root() = mutable_rightmost() = new_leaf_root_node(1);
1549    }
1550    SearchResult&lt;iterator, is_key_compare_to::value&gt; res = internal_locate(key);
1551    iterator iter = res.value;
1552    if (res.HasMatch()) {
1553      if (res.IsEq()) {
1554        return {iter, false};
1555      }
1556    } else {
1557      iterator last = internal_last(iter);
1558      if (last.node_ &amp;&amp; !compare_keys(key, last.key())) {
1559        return {last, false};
1560      }
1561    }
1562    return {internal_emplace(iter, std::forward&lt;Args&gt;(args)...), true};
1563  }
1564  template &lt;typename P&gt;
1565  template &lt;typename K, typename... Args&gt;
1566  inline auto btree&lt;P&gt;::insert_hint_unique(iterator position, const K &amp;key,
1567                                           Args &amp;&amp;...args)
1568      -&gt; std::pair&lt;iterator, bool&gt; {
1569    if (!empty()) {
1570      if (position == end() || compare_keys(key, position.key())) {
1571        if (position == begin() || compare_keys(std::prev(position).key(), key)) {
1572          return {internal_emplace(position, std::forward&lt;Args&gt;(args)...), true};
1573        }
1574      } else if (compare_keys(position.key(), key)) {
1575        ++position;
1576        if (position == end() || compare_keys(key, position.key())) {
1577          return {internal_emplace(position, std::forward&lt;Args&gt;(args)...), true};
1578        }
1579      } else {
1580        return {position, false};
1581      }
1582    }
1583    return insert_unique(key, std::forward&lt;Args&gt;(args)...);
1584  }
1585  template &lt;typename P&gt;
1586  template &lt;typename InputIterator, typename&gt;
1587  void btree&lt;P&gt;::insert_iterator_unique(InputIterator b, InputIterator e, int) {
1588    for (; b != e; ++b) {
1589      insert_hint_unique(end(), params_type::key(*b), *b);
1590    }
1591  }
1592  template &lt;typename P&gt;
1593  template &lt;typename InputIterator&gt;
1594  void btree&lt;P&gt;::insert_iterator_unique(InputIterator b, InputIterator e, char) {
1595    for (; b != e; ++b) {
1596      auto node_handle =
1597          CommonAccess::Construct&lt;node_handle_type&gt;(get_allocator(), *b);
1598      slot_type *slot = CommonAccess::GetSlot(node_handle);
1599      insert_hint_unique(end(), params_type::key(slot), slot);
1600    }
1601  }
1602  template &lt;typename P&gt;
1603  template &lt;typename ValueType&gt;
1604  auto btree&lt;P&gt;::insert_multi(const key_type &amp;key, ValueType &amp;&amp;v) -&gt; iterator {
1605    if (empty()) {
1606      mutable_root() = mutable_rightmost() = new_leaf_root_node(1);
1607    }
1608    iterator iter = internal_upper_bound(key);
1609    if (iter.node_ == nullptr) {
1610      iter = end();
1611    }
1612    return internal_emplace(iter, std::forward&lt;ValueType&gt;(v));
1613  }
1614  template &lt;typename P&gt;
1615  template &lt;typename ValueType&gt;
1616  auto btree&lt;P&gt;::insert_hint_multi(iterator position, ValueType &amp;&amp;v) -&gt; iterator {
1617    if (!empty()) {
1618      const key_type &amp;key = params_type::key(v);
1619      if (position == end() || !compare_keys(position.key(), key)) {
1620        if (position == begin() ||
1621            !compare_keys(key, std::prev(position).key())) {
1622          return internal_emplace(position, std::forward&lt;ValueType&gt;(v));
1623        }
1624      } else {
1625        ++position;
1626        if (position == end() || !compare_keys(position.key(), key)) {
1627          return internal_emplace(position, std::forward&lt;ValueType&gt;(v));
1628        }
1629      }
1630    }
1631    return insert_multi(std::forward&lt;ValueType&gt;(v));
1632  }
1633  template &lt;typename P&gt;
1634  template &lt;typename InputIterator&gt;
1635  void btree&lt;P&gt;::insert_iterator_multi(InputIterator b, InputIterator e) {
1636    for (; b != e; ++b) {
1637      insert_hint_multi(end(), *b);
1638    }
1639  }
1640  template &lt;typename P&gt;
1641  auto btree&lt;P&gt;::operator=(const btree &amp;other) -&gt; btree &amp; {
1642    if (this != &amp;other) {
1643      clear();
1644      *mutable_key_comp() = other.key_comp();
1645      if (absl::allocator_traits&lt;
1646              allocator_type&gt;::propagate_on_container_copy_assignment::value) {
1647        *mutable_allocator() = other.allocator();
1648      }
1649      copy_or_move_values_in_order(other);
1650    }
1651    return *this;
1652  }
1653  template &lt;typename P&gt;
1654  auto btree&lt;P&gt;::operator=(btree &amp;&amp;other) noexcept -&gt; btree &amp; {
1655    if (this != &amp;other) {
1656      clear();
1657      using std::swap;
1658      if (absl::allocator_traits&lt;
1659              allocator_type&gt;::propagate_on_container_copy_assignment::value) {
1660        swap(root_, other.root_);
1661        swap(rightmost_, other.rightmost_);
1662        swap(size_, other.size_);
1663      } else {
1664        if (allocator() == other.allocator()) {
1665          swap(mutable_root(), other.mutable_root());
1666          swap(*mutable_key_comp(), *other.mutable_key_comp());
1667          swap(mutable_rightmost(), other.mutable_rightmost());
1668          swap(size_, other.size_);
1669        } else {
1670          *mutable_key_comp() = other.key_comp();
1671          copy_or_move_values_in_order(other);
1672        }
1673      }
1674    }
1675    return *this;
1676  }
1677  template &lt;typename P&gt;
1678  auto btree&lt;P&gt;::erase(iterator iter) -&gt; iterator {
1679    iter.node_-&gt;value_destroy(static_cast&lt;field_type&gt;(iter.position_),
1680                              mutable_allocator());
1681    iter.update_generation();
1682    const bool internal_delete = iter.node_-&gt;is_internal();
1683    if (internal_delete) {
1684      iterator internal_iter(iter);
1685      --iter;
1686      assert(iter.node_-&gt;is_leaf());
1687      internal_iter.node_-&gt;transfer(
1688          static_cast&lt;size_type&gt;(internal_iter.position_),
1689          static_cast&lt;size_type&gt;(iter.position_), iter.node_,
1690          mutable_allocator());
1691    } else {
1692      const field_type transfer_from =
1693          static_cast&lt;field_type&gt;(iter.position_ + 1);
1694      const field_type num_to_transfer = iter.node_-&gt;finish() - transfer_from;
1695      iter.node_-&gt;transfer_n(num_to_transfer,
1696                             static_cast&lt;size_type&gt;(iter.position_),
1697                             transfer_from, iter.node_, mutable_allocator());
1698    }
1699    iter.node_-&gt;set_finish(iter.node_-&gt;finish() - 1);
1700    --size_;
1701    iterator res = rebalance_after_delete(iter);
1702    if (internal_delete) {
1703      ++res;
1704    }
1705    return res;
1706  }
1707  template &lt;typename P&gt;
1708  auto btree&lt;P&gt;::rebalance_after_delete(iterator iter) -&gt; iterator {
1709    iterator res(iter);
1710    bool first_iteration = true;
1711    for (;;) {
1712      if (iter.node_ == root()) {
1713        try_shrink();
1714        if (empty()) {
1715          return end();
1716        }
1717        break;
1718      }
1719      if (iter.node_-&gt;count() &gt;= kMinNodeValues) {
1720        break;
1721      }
1722      bool merged = try_merge_or_rebalance(&amp;iter);
1723      if (first_iteration) {
1724        res = iter;
1725        first_iteration = false;
1726      }
1727      if (!merged) {
1728        break;
1729      }
1730      iter.position_ = iter.node_-&gt;position();
1731      iter.node_ = iter.node_-&gt;parent();
1732    }
1733    res.update_generation();
1734    if (res.position_ == res.node_-&gt;finish()) {
1735      res.position_ = res.node_-&gt;finish() - 1;
1736      ++res;
1737    }
1738    return res;
1739  }
1740  template &lt;typename P&gt;
1741  auto btree&lt;P&gt;::erase_range(iterator begin, iterator end)
1742      -&gt; std::pair&lt;size_type, iterator&gt; {
1743    size_type count = static_cast&lt;size_type&gt;(end - begin);
1744    assert(count &gt;= 0);
1745    if (count == 0) {
1746      return {0, begin};
1747    }
1748    if (static_cast&lt;size_type&gt;(count) == size_) {
1749      clear();
1750      return {count, this-&gt;end()};
1751    }
1752    if (begin.node_ == end.node_) {
1753      assert(end.position_ &gt; begin.position_);
1754      begin.node_-&gt;remove_values(
1755          static_cast&lt;field_type&gt;(begin.position_),
1756          static_cast&lt;field_type&gt;(end.position_ - begin.position_),
1757          mutable_allocator());
1758      size_ -= count;
1759      return {count, rebalance_after_delete(begin)};
1760    }
1761    const size_type target_size = size_ - count;
1762    while (size_ &gt; target_size) {
1763      if (begin.node_-&gt;is_leaf()) {
1764        const size_type remaining_to_erase = size_ - target_size;
1765        const size_type remaining_in_node =
1766            static_cast&lt;size_type&gt;(begin.node_-&gt;finish() - begin.position_);
1767        const field_type to_erase = static_cast&lt;field_type&gt;(
1768            (std::min)(remaining_to_erase, remaining_in_node));
1769        begin.node_-&gt;remove_values(static_cast&lt;field_type&gt;(begin.position_),
1770                                   to_erase, mutable_allocator());
1771        size_ -= to_erase;
1772        begin = rebalance_after_delete(begin);
1773      } else {
1774        begin = erase(begin);
1775      }
1776    }
1777    begin.update_generation();
1778    return {count, begin};
1779  }
1780  template &lt;typename P&gt;
1781  void btree&lt;P&gt;::clear() {
1782    if (!empty()) {
1783      node_type::clear_and_delete(root(), mutable_allocator());
1784    }
1785    mutable_root() = mutable_rightmost() = EmptyNode();
1786    size_ = 0;
1787  }
1788  template &lt;typename P&gt;
1789  void btree&lt;P&gt;::swap(btree &amp;other) {
1790    using std::swap;
1791    if (absl::allocator_traits&lt;
1792            allocator_type&gt;::propagate_on_container_swap::value) {
1793      swap(rightmost_, other.rightmost_);
1794    } else {
1795      assert(allocator() == other.allocator());
1796      swap(mutable_rightmost(), other.mutable_rightmost());
1797      swap(*mutable_key_comp(), *other.mutable_key_comp());
1798    }
1799    swap(mutable_root(), other.mutable_root());
1800    swap(size_, other.size_);
1801  }
1802  template &lt;typename P&gt;
1803  void btree&lt;P&gt;::verify() const {
1804    assert(root() != nullptr);
1805    assert(leftmost() != nullptr);
1806    assert(rightmost() != nullptr);
1807    assert(empty() || size() == internal_verify(root(), nullptr, nullptr));
1808    assert(leftmost() == (++const_iterator(root(), -1)).node_);
1809    assert(rightmost() == (--const_iterator(root(), root()-&gt;finish())).node_);
1810    assert(leftmost()-&gt;is_leaf());
1811    assert(rightmost()-&gt;is_leaf());
1812  }
1813  template &lt;typename P&gt;
1814  void btree&lt;P&gt;::rebalance_or_split(iterator *iter) {
1815    node_type *&amp;node = iter-&gt;node_;
1816    int &amp;insert_position = iter-&gt;position_;
1817    assert(node-&gt;count() == node-&gt;max_count());
1818    assert(kNodeSlots == node-&gt;max_count());
1819    node_type *parent = node-&gt;parent();
1820    if (node != root()) {
1821      if (node-&gt;position() &gt; parent-&gt;start()) {
1822        node_type *left = parent-&gt;child(node-&gt;position() - 1);
1823        assert(left-&gt;max_count() == kNodeSlots);
1824        if (left-&gt;count() &lt; kNodeSlots) {
1825          field_type to_move =
1826              (kNodeSlots - left-&gt;count()) /
1827              (1 + (static_cast&lt;field_type&gt;(insert_position) &lt; kNodeSlots));
1828          to_move = (std::max)(field_type{1}, to_move);
1829          if (static_cast&lt;field_type&gt;(insert_position) - to_move &gt;=
1830                  node-&gt;start() ||
1831              left-&gt;count() + to_move &lt; kNodeSlots) {
1832            left-&gt;rebalance_right_to_left(to_move, node, mutable_allocator());
1833            assert(node-&gt;max_count() - node-&gt;count() == to_move);
1834            insert_position = static_cast&lt;int&gt;(
1835                static_cast&lt;field_type&gt;(insert_position) - to_move);
1836            if (insert_position &lt; node-&gt;start()) {
1837              insert_position = insert_position + left-&gt;count() + 1;
1838              node = left;
1839            }
1840            assert(node-&gt;count() &lt; node-&gt;max_count());
1841            return;
1842          }
1843        }
1844      }
1845      if (node-&gt;position() &lt; parent-&gt;finish()) {
1846        node_type *right = parent-&gt;child(node-&gt;position() + 1);
1847        assert(right-&gt;max_count() == kNodeSlots);
1848        if (right-&gt;count() &lt; kNodeSlots) {
1849          field_type to_move = (kNodeSlots - right-&gt;count()) /
1850                               (1 + (insert_position &gt; node-&gt;start()));
1851          to_move = (std::max)(field_type{1}, to_move);
1852          if (static_cast&lt;field_type&gt;(insert_position) &lt;=
1853                  node-&gt;finish() - to_move ||
1854              right-&gt;count() + to_move &lt; kNodeSlots) {
1855            node-&gt;rebalance_left_to_right(to_move, right, mutable_allocator());
1856            if (insert_position &gt; node-&gt;finish()) {
1857              insert_position = insert_position - node-&gt;count() - 1;
1858              node = right;
1859            }
1860            assert(node-&gt;count() &lt; node-&gt;max_count());
1861            return;
1862          }
1863        }
1864      }
1865      assert(parent-&gt;max_count() == kNodeSlots);
1866      if (parent-&gt;count() == kNodeSlots) {
1867        iterator parent_iter(parent, node-&gt;position());
1868        rebalance_or_split(&amp;parent_iter);
1869        parent = node-&gt;parent();
1870      }
1871    } else {
1872      parent = new_internal_node(&amp;bsol;*position=*/0, parent);
1873      parent-&gt;set_generation(root()-&gt;generation());
1874      parent-&gt;init_child(parent-&gt;start(), node);
1875      mutable_root() = parent;
1876      assert(parent-&gt;start_child()-&gt;is_internal() ||
1877             parent-&gt;start_child() == rightmost());
1878    }
1879    node_type *split_node;
1880    if (node-&gt;is_leaf()) {
1881      split_node = new_leaf_node(node-&gt;position() + 1, parent);
1882      node-&gt;split(insert_position, split_node, mutable_allocator());
1883      if (rightmost() == node) mutable_rightmost() = split_node;
1884    } else {
1885      split_node = new_internal_node(node-&gt;position() + 1, parent);
1886      node-&gt;split(insert_position, split_node, mutable_allocator());
1887    }
1888    if (insert_position &gt; node-&gt;finish()) {
1889      insert_position = insert_position - node-&gt;count() - 1;
1890      node = split_node;
1891    }
1892  }
1893  template &lt;typename P&gt;
1894  void btree&lt;P&gt;::merge_nodes(node_type *left, node_type *right) {
1895    left-&gt;merge(right, mutable_allocator());
1896    if (rightmost() == right) mutable_rightmost() = left;
1897  }
1898  template &lt;typename P&gt;
1899  bool btree&lt;P&gt;::try_merge_or_rebalance(iterator *iter) {
1900    node_type *parent = iter-&gt;node_-&gt;parent();
1901    if (iter-&gt;node_-&gt;position() &gt; parent-&gt;start()) {
1902      node_type *left = parent-&gt;child(iter-&gt;node_-&gt;position() - 1);
1903      assert(left-&gt;max_count() == kNodeSlots);
1904      if (1U + left-&gt;count() + iter-&gt;node_-&gt;count() &lt;= kNodeSlots) {
1905        iter-&gt;position_ += 1 + left-&gt;count();
1906        merge_nodes(left, iter-&gt;node_);
1907        iter-&gt;node_ = left;
1908        return true;
1909      }
1910    }
1911    if (iter-&gt;node_-&gt;position() &lt; parent-&gt;finish()) {
1912      node_type *right = parent-&gt;child(iter-&gt;node_-&gt;position() + 1);
1913      assert(right-&gt;max_count() == kNodeSlots);
1914      if (1U + iter-&gt;node_-&gt;count() + right-&gt;count() &lt;= kNodeSlots) {
1915        merge_nodes(iter-&gt;node_, right);
1916        return true;
1917      }
1918      if (right-&gt;count() &gt; kMinNodeValues &amp;&amp;
1919          (iter-&gt;node_-&gt;count() == 0 || iter-&gt;position_ &gt; iter-&gt;node_-&gt;start())) {
1920        field_type to_move = (right-&gt;count() - iter-&gt;node_-&gt;count()) / 2;
1921        to_move =
1922            (std::min)(to_move, static_cast&lt;field_type&gt;(right-&gt;count() - 1));
1923        iter-&gt;node_-&gt;rebalance_right_to_left(to_move, right, mutable_allocator());
1924        return false;
1925      }
1926    }
1927    if (iter-&gt;node_-&gt;position() &gt; parent-&gt;start()) {
1928      node_type *left = parent-&gt;child(iter-&gt;node_-&gt;position() - 1);
1929      if (left-&gt;count() &gt; kMinNodeValues &amp;&amp;
1930          (iter-&gt;node_-&gt;count() == 0 ||
1931           iter-&gt;position_ &lt; iter-&gt;node_-&gt;finish())) {
1932        field_type to_move = (left-&gt;count() - iter-&gt;node_-&gt;count()) / 2;
1933        to_move = (std::min)(to_move, static_cast&lt;field_type&gt;(left-&gt;count() - 1));
1934        left-&gt;rebalance_left_to_right(to_move, iter-&gt;node_, mutable_allocator());
1935        iter-&gt;position_ += to_move;
1936        return false;
1937      }
1938    }
1939    return false;
1940  }
1941  template &lt;typename P&gt;
1942  void btree&lt;P&gt;::try_shrink() {
1943    node_type *orig_root = root();
1944    if (orig_root-&gt;count() &gt; 0) {
1945      return;
1946    }
1947    if (orig_root-&gt;is_leaf()) {
1948      assert(size() == 0);
1949      mutable_root() = mutable_rightmost() = EmptyNode();
1950    } else {
1951      node_type *child = orig_root-&gt;start_child();
1952      child-&gt;make_root();
1953      mutable_root() = child;
1954    }
1955    node_type::clear_and_delete(orig_root, mutable_allocator());
1956  }
1957  template &lt;typename P&gt;
1958  template &lt;typename IterType&gt;
1959  inline IterType btree&lt;P&gt;::internal_last(IterType iter) {
1960    assert(iter.node_ != nullptr);
1961    while (iter.position_ == iter.node_-&gt;finish()) {
1962      iter.position_ = iter.node_-&gt;position();
1963      iter.node_ = iter.node_-&gt;parent();
1964      if (iter.node_-&gt;is_leaf()) {
1965        iter.node_ = nullptr;
1966        break;
1967      }
1968    }
1969    iter.update_generation();
1970    return iter;
1971  }
1972  template &lt;typename P&gt;
1973  template &lt;typename... Args&gt;
1974  inline auto btree&lt;P&gt;::internal_emplace(iterator iter, Args &amp;&amp;...args)
1975      -&gt; iterator {
1976    if (iter.node_-&gt;is_internal()) {
1977      --iter;
1978      ++iter.position_;
1979    }
1980    const field_type max_count = iter.node_-&gt;max_count();
1981    allocator_type *alloc = mutable_allocator();
1982    const auto transfer_and_delete = [&amp;](node_type *old_node,
1983                                         node_type *new_node) {
1984      new_node-&gt;transfer_n(old_node-&gt;count(), new_node-&gt;start(),
1985                           old_node-&gt;start(), old_node, alloc);
1986      new_node-&gt;set_finish(old_node-&gt;finish());
1987      old_node-&gt;set_finish(old_node-&gt;start());
1988      new_node-&gt;set_generation(old_node-&gt;generation());
1989      node_type::clear_and_delete(old_node, alloc);
1990    };
1991    const auto replace_leaf_root_node = [&amp;](field_type new_node_size) {
1992      assert(iter.node_ == root());
1993      node_type *old_root = iter.node_;
1994      node_type *new_root = iter.node_ = new_leaf_root_node(new_node_size);
1995      transfer_and_delete(old_root, new_root);
1996      mutable_root() = mutable_rightmost() = new_root;
1997    };
1998    bool replaced_node = false;
1999    if (iter.node_-&gt;count() == max_count) {
2000      if (max_count &lt; kNodeSlots) {
2001        replace_leaf_root_node(static_cast&lt;field_type&gt;(
2002            (std::min)(static_cast&lt;int&gt;(kNodeSlots), 2 * max_count)));
2003        replaced_node = true;
2004      } else {
2005        rebalance_or_split(&amp;iter);
2006      }
2007    }
2008    (void)replaced_node;
2009  #ifdef ABSL_HAVE_ADDRESS_SANITIZER
2010    if (!replaced_node) {
2011      assert(iter.node_-&gt;is_leaf());
2012      if (iter.node_-&gt;is_root()) {
2013        replace_leaf_root_node(max_count);
2014      } else {
2015        node_type *old_node = iter.node_;
2016        const bool was_rightmost = rightmost() == old_node;
2017        const bool was_leftmost = leftmost() == old_node;
2018        node_type *parent = old_node-&gt;parent();
2019        const field_type position = old_node-&gt;position();
2020        node_type *new_node = iter.node_ = new_leaf_node(position, parent);
2021        parent-&gt;set_child_noupdate_position(position, new_node);
2022        transfer_and_delete(old_node, new_node);
2023        if (was_rightmost) mutable_rightmost() = new_node;
2024        if (was_leftmost) root()-&gt;set_parent(new_node);
2025      }
2026    }
2027  #endif
2028    iter.node_-&gt;emplace_value(static_cast&lt;field_type&gt;(iter.position_), alloc,
2029                              std::forward&lt;Args&gt;(args)...);
2030    assert(
2031        iter.node_-&gt;is_ordered_correctly(static_cast&lt;field_type&gt;(iter.position_),
2032                                         original_key_compare(key_comp())) &amp;&amp;
2033        &quot;If this assert fails, then either (1) the comparator may violate &quot;
2034        &quot;transitivity, i.e. comp(a,b) &amp;&amp; comp(b,c) -&gt; comp(a,c) (see &quot;
2035        &quot;https:&amp;bsol;&amp;bsol;en.cppreference.com/w/cpp/named_req/Compare), or (2) a &quot;
2036        &quot;key may have been mutated after it was inserted into the tree.&quot;);
2037    ++size_;
2038    iter.update_generation();
2039    return iter;
2040  }
2041  template &lt;typename P&gt;
2042  template &lt;typename K&gt;
2043  inline auto btree&lt;P&gt;::internal_locate(const K &amp;key) const
2044      -&gt; SearchResult&lt;iterator, is_key_compare_to::value&gt; {
2045    iterator iter(const_cast&lt;node_type *&gt;(root()));
2046    for (;;) {
2047      SearchResult&lt;size_type, is_key_compare_to::value&gt; res =
2048          iter.node_-&gt;lower_bound(key, key_comp());
2049      iter.position_ = static_cast&lt;int&gt;(res.value);
2050      if (res.IsEq()) {
2051        return {iter, MatchKind::kEq};
2052      }
2053      if (iter.node_-&gt;is_leaf()) {
2054        break;
2055      }
2056      iter.node_ = iter.node_-&gt;child(static_cast&lt;field_type&gt;(iter.position_));
2057    }
2058    return {iter, MatchKind::kNe};
2059  }
2060  template &lt;typename P&gt;
2061  template &lt;typename K&gt;
2062  auto btree&lt;P&gt;::internal_lower_bound(const K &amp;key) const
2063      -&gt; SearchResult&lt;iterator, is_key_compare_to::value&gt; {
2064    if (!params_type::template can_have_multiple_equivalent_keys&lt;K&gt;()) {
2065      SearchResult&lt;iterator, is_key_compare_to::value&gt; ret = internal_locate(key);
2066      ret.value = internal_last(ret.value);
2067      return ret;
2068    }
2069    iterator iter(const_cast&lt;node_type *&gt;(root()));
2070    SearchResult&lt;size_type, is_key_compare_to::value&gt; res;
2071    bool seen_eq = false;
2072    for (;;) {
2073      res = iter.node_-&gt;lower_bound(key, key_comp());
2074      iter.position_ = static_cast&lt;int&gt;(res.value);
2075      if (iter.node_-&gt;is_leaf()) {
2076        break;
2077      }
2078      seen_eq = seen_eq || res.IsEq();
2079      iter.node_ = iter.node_-&gt;child(static_cast&lt;field_type&gt;(iter.position_));
2080    }
2081    if (res.IsEq()) return {iter, MatchKind::kEq};
2082    return {internal_last(iter), seen_eq ? MatchKind::kEq : MatchKind::kNe};
2083  }
2084  template &lt;typename P&gt;
2085  template &lt;typename K&gt;
2086  auto btree&lt;P&gt;::internal_upper_bound(const K &amp;key) const -&gt; iterator {
2087    iterator iter(const_cast&lt;node_type *&gt;(root()));
2088    for (;;) {
2089      iter.position_ = static_cast&lt;int&gt;(iter.node_-&gt;upper_bound(key, key_comp()));
2090      if (iter.node_-&gt;is_leaf()) {
2091        break;
2092      }
2093      iter.node_ = iter.node_-&gt;child(static_cast&lt;field_type&gt;(iter.position_));
2094    }
2095    return internal_last(iter);
2096  }
2097  template &lt;typename P&gt;
2098  template &lt;typename K&gt;
2099  auto btree&lt;P&gt;::internal_find(const K &amp;key) const -&gt; iterator {
2100    SearchResult&lt;iterator, is_key_compare_to::value&gt; res = internal_locate(key);
2101    if (res.HasMatch()) {
2102      if (res.IsEq()) {
2103        return res.value;
2104      }
2105    } else {
2106      const iterator iter = internal_last(res.value);
2107      if (iter.node_ != nullptr &amp;&amp; !compare_keys(key, iter.key())) {
2108        return iter;
2109      }
2110    }
2111    return {nullptr, 0};
2112  }
2113  template &lt;typename P&gt;
2114  typename btree&lt;P&gt;::size_type btree&lt;P&gt;::internal_verify(
2115      const node_type *node, const key_type *lo, const key_type *hi) const {
2116    assert(node-&gt;count() &gt; 0);
2117    assert(node-&gt;count() &lt;= node-&gt;max_count());
2118    if (lo) {
2119      assert(!compare_keys(node-&gt;key(node-&gt;start()), *lo));
2120    }
2121    if (hi) {
2122      assert(!compare_keys(*hi, node-&gt;key(node-&gt;finish() - 1)));
2123    }
2124    for (int i = node-&gt;start() + 1; i &lt; node-&gt;finish(); ++i) {
2125      assert(!compare_keys(node-&gt;key(i), node-&gt;key(i - 1)));
2126    }
2127    size_type count = node-&gt;count();
2128    if (node-&gt;is_internal()) {
2129      for (field_type i = node-&gt;start(); i &lt;= node-&gt;finish(); ++i) {
2130        assert(node-&gt;child(i) != nullptr);
2131        assert(node-&gt;child(i)-&gt;parent() == node);
2132        assert(node-&gt;child(i)-&gt;position() == i);
2133        count += internal_verify(node-&gt;child(i),
2134                                 i == node-&gt;start() ? lo : &amp;node-&gt;key(i - 1),
2135                                 i == node-&gt;finish() ? hi : &amp;node-&gt;key(i));
2136      }
2137    }
2138    return count;
2139  }
2140  struct btree_access {
2141    template &lt;typename BtreeContainer, typename Pred&gt;
2142    static auto erase_if(BtreeContainer &amp;container, Pred pred) -&gt;
2143        typename BtreeContainer::size_type {
2144      const auto initial_size = container.size();
2145      auto &amp;tree = container.tree_;
2146      auto *alloc = tree.mutable_allocator();
2147      for (auto it = container.begin(); it != container.end();) {
2148        if (!pred(*it)) {
2149          ++it;
2150          continue;
2151        }
2152        auto *node = it.node_;
2153        if (node-&gt;is_internal()) {
2154          it = container.erase(it);
2155          continue;
2156        }
2157        int to_pos = it.position_;
2158        node-&gt;value_destroy(it.position_, alloc);
2159        while (++it.position_ &lt; node-&gt;finish()) {
2160          it.update_generation();
2161          if (pred(*it)) {
2162            node-&gt;value_destroy(it.position_, alloc);
2163          } else {
2164            node-&gt;transfer(node-&gt;slot(to_pos++), node-&gt;slot(it.position_), alloc);
2165          }
2166        }
2167        const int num_deleted = node-&gt;finish() - to_pos;
2168        tree.size_ -= num_deleted;
2169        node-&gt;set_finish(to_pos);
2170        it.position_ = to_pos;
2171        it = tree.rebalance_after_delete(it);
2172      }
2173      return initial_size - container.size();
2174    }
2175  };
2176  #undef ABSL_BTREE_ENABLE_GENERATIONS
2177  }  
2178  ABSL_NAMESPACE_END
2179  }  
2180  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-btree.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-btree.h</div>
                </div>
                <div class="column column_space"><pre><code>687    while (!node_a-&gt;is_root()) node_a = node_a-&gt;parent();
688    while (!node_b-&gt;is_root()) node_b = node_b-&gt;parent();
</pre></code></div>
                <div class="column column_space"><pre><code>688    while (!node_b-&gt;is_root()) node_b = node_b-&gt;parent();
689    return node_a == node_b;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    