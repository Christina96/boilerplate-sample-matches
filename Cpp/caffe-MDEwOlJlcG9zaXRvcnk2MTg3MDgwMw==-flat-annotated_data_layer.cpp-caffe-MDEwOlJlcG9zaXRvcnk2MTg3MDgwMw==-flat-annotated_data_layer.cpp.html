
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 61, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-annotated_data_layer.cpp</h3>
            <pre><code>1  #ifdef USE_OPENCV
2  #include <opencv2/core/core.hpp>
3  #endif  
4  #include <stdint.h>
5  #include <algorithm>
6  #include <map>
7  #include <vector>
8  #include <boost/container/vector.hpp>
9  #include "caffe/data_transformer.hpp"
10  #include "caffe/layers/annotated_data_layer.hpp"
11  #include "caffe/util/benchmark.hpp"
12  #include "caffe/util/sampler.hpp"
13  namespace caffe {
14  template <typename Dtype>
15  AnnotatedDataLayer<Dtype>::AnnotatedDataLayer(const LayerParameter& param)
16    : BasePrefetchingDataLayer<Dtype>(param),
17      reader_(param) {
18  }
19  template <typename Dtype>
20  AnnotatedDataLayer<Dtype>::~AnnotatedDataLayer() {
21    this->StopInternalThread();
22  }
23  template <typename Dtype>
24  void AnnotatedDataLayer<Dtype>::DataLayerSetUp(
25      const vector<Blob<Dtype>*>& bottom, const vector<Blob<Dtype>*>& top) {
26    const int batch_size = this->layer_param_.data_param().batch_size();
27    const AnnotatedDataParameter& anno_data_param =
28        this->layer_param_.annotated_data_param();
29    for (int i = 0; i < anno_data_param.batch_sampler_size(); ++i) {
30      batch_samplers_.push_back(anno_data_param.batch_sampler(i));
31    }
32    label_map_file_ = anno_data_param.label_map_file();
33    const TransformationParameter& transform_param =
34      this->layer_param_.transform_param();
35    if (transform_param.has_resize_param()) {
36      if (transform_param.resize_param().resize_mode() ==
37          ResizeParameter_Resize_mode_FIT_SMALL_SIZE) {
38        CHECK_EQ(batch_size, 1)
39          << "Only support batch size of 1 for FIT_SMALL_SIZE.";
40      }
41    }
42    AnnotatedDatum anno_datum;
43    anno_datum.ParseFromString(*(reader_.full().peek()));
44    vector<int> top_shape =
45        this->data_transformer_->InferBlobShape(anno_datum.datum());
46    this->transformed_data_.Reshape(top_shape);
47    top_shape[0] = batch_size;
48    top[0]->Reshape(top_shape);
49    for (int i = 0; i < this->PREFETCH_COUNT; ++i) {
50      this->prefetch_[i].data_.Reshape(top_shape);
51    }
52    LOG(INFO) << "output data size: " << top[0]->num() << ","
53        << top[0]->channels() << "," << top[0]->height() << ","
54        << top[0]->width();
55    if (this->output_labels_) {
56      has_anno_type_ = anno_datum.has_type() || anno_data_param.has_anno_type();
57      vector<int> label_shape(4, 1);
58      if (has_anno_type_) {
59        anno_type_ = anno_datum.type();
60        if (anno_data_param.has_anno_type()) {
61          LOG(WARNING) << "type stored in AnnotatedDatum is shadowed.";
62          anno_type_ = anno_data_param.anno_type();
63        }
64        int num_bboxes = 0;
65        if (anno_type_ == AnnotatedDatum_AnnotationType_BBOX) {
66          for (int g = 0; g < anno_datum.annotation_group_size(); ++g) {
67            num_bboxes += anno_datum.annotation_group(g).annotation_size();
68          }
69          label_shape[0] = 1;
70          label_shape[1] = 1;
71          label_shape[2] = std::max(num_bboxes, 1);
72          label_shape[3] = 8;
73        } else {
74          LOG(FATAL) << "Unknown annotation type.";
75        }
76      } else {
77        label_shape[0] = batch_size;
78      }
79      top[1]->Reshape(label_shape);
80      for (int i = 0; i < this->PREFETCH_COUNT; ++i) {
81        this->prefetch_[i].label_.Reshape(label_shape);
82      }
83    }
84  }
85  #ifdef _OPENMP
86  template<typename Dtype>
87  void AnnotatedDataLayer<Dtype>::load_batch(Batch<Dtype>* batch) {
88    CPUTimer batch_timer;
89    CPUTimer trans_timer;
90    batch_timer.Start();
91    double read_time = 0;
92    double trans_time = 0;
93    CPUTimer timer;
94    CHECK(batch->data_.count());
95    const int batch_size = this->layer_param_.data_param().batch_size();
96    const AnnotatedDataParameter& anno_data_param =
97        this->layer_param_.annotated_data_param();
98    const TransformationParameter& transform_param =
99      this->layer_param_.transform_param();
100    AnnotatedDatum anno_datum;
101    anno_datum.ParseFromString(*(reader_.full().peek()));
102    vector<int> top_shape =
103        this->data_transformer_->InferBlobShape(anno_datum.datum());
104    top_shape[0] = batch_size;
105    batch->data_.Reshape(top_shape);
106    Dtype* top_data = batch->data_.mutable_cpu_data();
107    Dtype* top_label = NULL;  
108    if (this->output_labels_ && !has_anno_type_) {
109      top_label = batch->label_.mutable_cpu_data();
110    }
111    std::vector<std::vector<AnnotationGroup>> all_anno(batch_size);
112    std::vector<boost::shared_ptr<AnnotatedDatum>> expand_data(batch_size, nullptr);
113    std::vector<std::vector<NormalizedBBox>> sampled_bboxes(batch_size);
114    boost::container::vector<bool> have_samples(batch_size, false);
115    int num_bboxes = 0;
116    trans_timer.Start();
117  #pragma omp parallel if (batch_size > 1)
118  #pragma omp single nowait
119    {
120      for (int item_id = 0; item_id < batch_size; ++item_id) {
121        timer.Start();
122        string* data = reader_.full().pop("Waiting for data");
123        timer.Stop();
124        read_time += timer.MicroSeconds();
125  #if !defined(_MSC_EXTENSIONS)
126  #pragma omp task firstprivate(item_id, data) shared(all_anno, expand_data, sampled_bboxes, have_samples)
127  #endif
128        {
129          std::unique_ptr<AnnotatedDatum> anno_datum(new AnnotatedDatum());
130          anno_datum->ParseFromString(*data);
131          reader_.free().push(data);
132          std::unique_ptr<AnnotatedDatum> distort_datum(new AnnotatedDatum());
133          boost::shared_ptr<AnnotatedDatum> expand_datum;
134          if (transform_param.has_distort_param()) {
135            distort_datum->CopyFrom(*anno_datum);
136            this->data_transformer_->DistortImage(anno_datum->datum(),
137                                                  distort_datum->mutable_datum());
138            if (transform_param.has_expand_param()) {
139              expand_datum.reset(new AnnotatedDatum());
140              this->data_transformer_->ExpandImage(*distort_datum, expand_datum.get());
141            } else {
142              expand_datum = std::move(distort_datum);
143            }
144          } else {
145            if (transform_param.has_expand_param()) {
146              expand_datum.reset(new AnnotatedDatum());
147              this->data_transformer_->ExpandImage(*anno_datum, expand_datum.get());
148            } else {
149              expand_datum = std::move(anno_datum);
150            }
151          }
152          bool has_sampled = false;
153          if (batch_samplers_.size() > 0) {
154            GenerateBatchSamples(*expand_datum, batch_samplers_, &sampled_bboxes[item_id]);
155            if (sampled_bboxes[item_id].size() > 0) {
156              has_sampled = true;
157            }
158          }
159          expand_data[item_id] = expand_datum;
160          have_samples[item_id] = has_sampled;
161        }
162      }
163  #if !defined(_MSC_EXTENSIONS)
164  #pragma omp taskwait
165  #endif
166      this->data_transformer_->ReinitRand();
167      for (int item_id = 0; item_id < batch_size; ++item_id) {
168        PreclcRandomNumbers precalculated_rand_numbers;
169        this->data_transformer_->GenerateRandNumbers(precalculated_rand_numbers, &bsol;* sample_bboxes */ have_samples[item_id]);
170  #if !defined(_MSC_EXTENSIONS)
171  #pragma omp task firstprivate(precalculated_rand_numbers, item_id) shared(num_bboxes, all_anno, expand_data, sampled_bboxes, have_samples)
172  #endif
173        {
174          boost::shared_ptr<AnnotatedDatum> sampled_datum;
175          bool has_sampled = have_samples[item_id];
176          if (has_sampled) {
177            int rand_idx = precalculated_rand_numbers(sampled_bboxes[item_id].size());
178            sampled_datum.reset(new AnnotatedDatum());
179            this->data_transformer_->CropImage(*expand_data[item_id],
180                                               sampled_bboxes[item_id][rand_idx],
181                                               sampled_datum.get());
182          } else {
183            sampled_datum = expand_data[item_id];
184          }
185          CHECK(sampled_datum.get()  != NULL);
186          Blob<Dtype> data_blob;
187          data_blob.Reshape(top_shape);
188          vector<int> shape =
189            this->data_transformer_->InferBlobShape(sampled_datum->datum());
190          if (transform_param.has_resize_param()) {
191            if (transform_param.resize_param().resize_mode() ==
192              ResizeParameter_Resize_mode_FIT_SMALL_SIZE) {
193              DLOG(INFO) << "Has resize param";
194              data_blob.Reshape(shape);
195              batch->data_.Reshape(shape);
196              top_data = batch->data_.mutable_cpu_data();
197            } else {
198              CHECK(std::equal(top_shape.begin() + 1, top_shape.begin() + 4,
199                               shape.begin() + 1));
200            }
201          } else {
202            CHECK(std::equal(top_shape.begin() + 1, top_shape.begin() + 4,
203                  shape.begin() + 1));
204          }
205          int offset = batch->data_.offset(item_id);
206          data_blob.set_cpu_data(top_data + offset);
207          if (this->output_labels_) {
208            if (has_anno_type_) {
209              CHECK(sampled_datum->has_type()) << "Some datum misses AnnotationType.";
210              if (anno_data_param.has_anno_type()) {
211                sampled_datum->set_type(anno_type_);
212              } else {
213                CHECK_EQ(anno_type_, sampled_datum->type()) <<
214                         "Different AnnotationType.";
215              }
216              this->data_transformer_->Transform(*sampled_datum,
217                                                 &data_blob,
218                                                 &all_anno[item_id],
219                                                 precalculated_rand_numbers);
220              if (anno_type_ == AnnotatedDatum_AnnotationType_BBOX) {
221                for (int g = 0; g < all_anno[item_id].size(); ++g) {
222  #pragma omp atomic
223                  num_bboxes += all_anno[item_id][g].annotation_size();
224                }
225              } else {
226                LOG(FATAL) << "Unknown annotation type.";
227              }
228            } else {
229              this->data_transformer_->Transform(sampled_datum->datum(),
230                                                 &data_blob,
231                                                 precalculated_rand_numbers);
232              CHECK(sampled_datum->datum().has_label()) << "Cannot find any label.";
233              top_label[item_id] = sampled_datum->datum().label();
234            }
235          } else {
236            this->data_transformer_->Transform(sampled_datum->datum(),
237                                               &data_blob,
238                                               precalculated_rand_numbers);
239          }
240        }
241      }
242    }
243    if (this->output_labels_ && has_anno_type_) {
244      vector<int> label_shape(4);
245      if (anno_type_ == AnnotatedDatum_AnnotationType_BBOX) {
246        label_shape[0] = 1;
247        label_shape[1] = 1;
248        label_shape[3] = 8;
249        if (num_bboxes == 0) {
250          label_shape[2] = 1;
251          batch->label_.Reshape(label_shape);
252          caffe_set<Dtype>(8, -1, batch->label_.mutable_cpu_data());
253        } else {
254          label_shape[2] = num_bboxes;
255          batch->label_.Reshape(label_shape);
256          top_label = batch->label_.mutable_cpu_data();
257          int idx = 0;
258          for (int item_id = 0; item_id < batch_size; ++item_id) {
259            const vector<AnnotationGroup>& anno_vec = all_anno[item_id];
260            for (int g = 0; g < anno_vec.size(); ++g) {
261              const AnnotationGroup& anno_group = anno_vec[g];
262              for (int a = 0; a < anno_group.annotation_size(); ++a) {
263                const Annotation& anno = anno_group.annotation(a);
264                const NormalizedBBox& bbox = anno.bbox();
265                top_label[idx++] = item_id;
266                top_label[idx++] = anno_group.group_label();
267                top_label[idx++] = anno.instance_id();
268                top_label[idx++] = bbox.xmin();
269                top_label[idx++] = bbox.ymin();
270                top_label[idx++] = bbox.xmax();
271                top_label[idx++] = bbox.ymax();
272                top_label[idx++] = bbox.difficult();
273              }
274            }
275          }
276        }
277      } else {
278        LOG(FATAL) << "Unknown annotation type.";
279      }
280    }
281    trans_timer.Stop();
282    batch_timer.Stop();
283    trans_time = trans_timer.MicroSeconds() - read_time;
284    DLOG(INFO) << "Prefetch batch: " << batch_timer.MilliSeconds() << " ms.";
285    DLOG(INFO) << "     Read time: " << read_time / 1000 << " ms.";
286    DLOG(INFO) << "Transform time: " << trans_time / 1000 << " ms.";
287  }
288  #else
289  template<typename Dtype>
290  void AnnotatedDataLayer<Dtype>::load_batch(Batch<Dtype>* batch) {
291    CPUTimer batch_timer;
292    batch_timer.Start();
293    double read_time = 0;
294    double trans_time = 0;
295    CPUTimer timer;
296    CHECK(batch->data_.count());
297    CHECK(this->transformed_data_.count());
298    const int batch_size = this->layer_param_.data_param().batch_size();
299    const AnnotatedDataParameter& anno_data_param =
<span onclick='openModal()' class='match'>300        this->layer_param_.annotated_data_param();
301    const TransformationParameter& transform_param =
302      this->layer_param_.transform_param();
303    AnnotatedDatum anno_datum;
304    anno_datum.ParseFromString(*(reader_.full().peek()));
305    vector<int> top_shape =
306        this->data_transformer_->InferBlobShape(anno_datum.datum());
307    this->transformed_data_.Reshape(top_shape);
</span>308    top_shape[0] = batch_size;
309    batch->data_.Reshape(top_shape);
310    Dtype* top_data = batch->data_.mutable_cpu_data();
311    Dtype* top_label = NULL;  
312    if (this->output_labels_ && !has_anno_type_) {
313      top_label = batch->label_.mutable_cpu_data();
314    }
315    map<int, vector<AnnotationGroup> > all_anno;
316    int num_bboxes = 0;
317    for (int item_id = 0; item_id < batch_size; ++item_id) {
318      timer.Start();
319      string* data = reader_.full().pop("Waiting for data");
320      AnnotatedDatum anno_datum;
321      anno_datum.ParseFromString(*data);
322      reader_.free().push(data);
323      read_time += timer.MicroSeconds();
324      timer.Start();
325      AnnotatedDatum distort_datum;
326      AnnotatedDatum* expand_datum = NULL;
327      if (transform_param.has_distort_param()) {
328        distort_datum.CopyFrom(anno_datum);
329        this->data_transformer_->DistortImage(anno_datum.datum(),
330                                              distort_datum.mutable_datum());
331        if (transform_param.has_expand_param()) {
332          expand_datum = new AnnotatedDatum();
333          this->data_transformer_->ExpandImage(distort_datum, expand_datum);
334        } else {
335          expand_datum = &distort_datum;
336        }
337      } else {
338        if (transform_param.has_expand_param()) {
339          expand_datum = new AnnotatedDatum();
340          this->data_transformer_->ExpandImage(anno_datum, expand_datum);
341        } else {
342          expand_datum = &anno_datum;
343        }
344      }
345      AnnotatedDatum* sampled_datum = NULL;
346      bool has_sampled = false;
347      if (batch_samplers_.size() > 0) {
348        vector<NormalizedBBox> sampled_bboxes;
349        GenerateBatchSamples(*expand_datum, batch_samplers_, &sampled_bboxes);
350        if (sampled_bboxes.size() > 0) {
351          int rand_idx = caffe_rng_rand() % sampled_bboxes.size();
352          sampled_datum = new AnnotatedDatum();
353          this->data_transformer_->CropImage(*expand_datum,
354                                             sampled_bboxes[rand_idx],
355                                             sampled_datum);
356          has_sampled = true;
357        } else {
358          sampled_datum = expand_datum;
359        }
360      } else {
361        sampled_datum = expand_datum;
362      }
363      CHECK(sampled_datum != NULL);
364      timer.Start();
365      vector<int> shape =
366          this->data_transformer_->InferBlobShape(sampled_datum->datum());
367      if (transform_param.has_resize_param()) {
368        if (transform_param.resize_param().resize_mode() ==
369            ResizeParameter_Resize_mode_FIT_SMALL_SIZE) {
370          DLOG(INFO) << "Has resize param";
371          this->transformed_data_.Reshape(shape);
372          batch->data_.Reshape(shape);
373          top_data = batch->data_.mutable_cpu_data();
374        } else {
375          CHECK(std::equal(top_shape.begin() + 1, top_shape.begin() + 4,
376                shape.begin() + 1));
377        }
378      } else {
379        CHECK(std::equal(top_shape.begin() + 1, top_shape.begin() + 4,
380              shape.begin() + 1));
381      }
382      int offset = batch->data_.offset(item_id);
383      this->transformed_data_.set_cpu_data(top_data + offset);
384      vector<AnnotationGroup> transformed_anno_vec;
385      if (this->output_labels_) {
386        if (has_anno_type_) {
387          CHECK(sampled_datum->has_type()) << "Some datum misses AnnotationType.";
388          if (anno_data_param.has_anno_type()) {
389            sampled_datum->set_type(anno_type_);
390          } else {
391            CHECK_EQ(anno_type_, sampled_datum->type()) <<
392                "Different AnnotationType.";
393          }
394          transformed_anno_vec.clear();
395          this->data_transformer_->Transform(*sampled_datum,
396                                             &(this->transformed_data_),
397                                             &transformed_anno_vec);
398          if (anno_type_ == AnnotatedDatum_AnnotationType_BBOX) {
399            for (int g = 0; g < transformed_anno_vec.size(); ++g) {
400              num_bboxes += transformed_anno_vec[g].annotation_size();
401            }
402          } else {
403            LOG(FATAL) << "Unknown annotation type.";
404          }
405          all_anno[item_id] = transformed_anno_vec;
406        } else {
407          this->data_transformer_->Transform(sampled_datum->datum(),
408                                             &(this->transformed_data_));
409          CHECK(sampled_datum->datum().has_label()) << "Cannot find any label.";
410          top_label[item_id] = sampled_datum->datum().label();
411        }
412      } else {
413        this->data_transformer_->Transform(sampled_datum->datum(),
414                                           &(this->transformed_data_));
415      }
416      if (has_sampled) {
417        delete sampled_datum;
418      }
419      if (transform_param.has_expand_param()) {
420        delete expand_datum;
421      }
422      trans_time += timer.MicroSeconds();
423    }
424    if (this->output_labels_ && has_anno_type_) {
425      vector<int> label_shape(4);
426      if (anno_type_ == AnnotatedDatum_AnnotationType_BBOX) {
427        label_shape[0] = 1;
428        label_shape[1] = 1;
429        label_shape[3] = 8;
430        if (num_bboxes == 0) {
431          label_shape[2] = 1;
432          batch->label_.Reshape(label_shape);
433          caffe_set<Dtype>(8, -1, batch->label_.mutable_cpu_data());
434        } else {
435          label_shape[2] = num_bboxes;
436          batch->label_.Reshape(label_shape);
437          top_label = batch->label_.mutable_cpu_data();
438          int idx = 0;
439          for (int item_id = 0; item_id < batch_size; ++item_id) {
440            const vector<AnnotationGroup>& anno_vec = all_anno[item_id];
441            for (int g = 0; g < anno_vec.size(); ++g) {
442              const AnnotationGroup& anno_group = anno_vec[g];
443              for (int a = 0; a < anno_group.annotation_size(); ++a) {
444                const Annotation& anno = anno_group.annotation(a);
445                const NormalizedBBox& bbox = anno.bbox();
446                top_label[idx++] = item_id;
447                top_label[idx++] = anno_group.group_label();
448                top_label[idx++] = anno.instance_id();
449                top_label[idx++] = bbox.xmin();
450                top_label[idx++] = bbox.ymin();
451                top_label[idx++] = bbox.xmax();
452                top_label[idx++] = bbox.ymax();
453                top_label[idx++] = bbox.difficult();
454              }
455            }
456          }
457        }
458      } else {
459        LOG(FATAL) << "Unknown annotation type.";
460      }
461    }
462    timer.Stop();
463    batch_timer.Stop();
464    DLOG(INFO) << "Prefetch batch: " << batch_timer.MilliSeconds() << " ms.";
465    DLOG(INFO) << "     Read time: " << read_time / 1000 << " ms.";
466    DLOG(INFO) << "Transform time: " << trans_time / 1000 << " ms.";
467  }
468  #endif 
469  INSTANTIATE_CLASS(AnnotatedDataLayer);
470  REGISTER_LAYER_CLASS(AnnotatedData);
471  }  
</code></pre>
        </div>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-annotated_data_layer.cpp</h3>
            <pre><code>1  #ifdef USE_OPENCV
2  #include <opencv2/core/core.hpp>
3  #endif  
4  #include <stdint.h>
5  #include <algorithm>
6  #include <map>
7  #include <vector>
8  #include <boost/container/vector.hpp>
9  #include "caffe/data_transformer.hpp"
10  #include "caffe/layers/annotated_data_layer.hpp"
11  #include "caffe/util/benchmark.hpp"
12  #include "caffe/util/sampler.hpp"
13  namespace caffe {
14  template <typename Dtype>
15  AnnotatedDataLayer<Dtype>::AnnotatedDataLayer(const LayerParameter& param)
16    : BasePrefetchingDataLayer<Dtype>(param),
17      reader_(param) {
18  }
19  template <typename Dtype>
20  AnnotatedDataLayer<Dtype>::~AnnotatedDataLayer() {
21    this->StopInternalThread();
22  }
23  template <typename Dtype>
24  void AnnotatedDataLayer<Dtype>::DataLayerSetUp(
25      const vector<Blob<Dtype>*>& bottom, const vector<Blob<Dtype>*>& top) {
26    const int batch_size = this->layer_param_.data_param().batch_size();
27    const AnnotatedDataParameter& anno_data_param =
28        this->layer_param_.annotated_data_param();
29    for (int i = 0; i < anno_data_param.batch_sampler_size(); ++i) {
30      batch_samplers_.push_back(anno_data_param.batch_sampler(i));
31    }
32    label_map_file_ = anno_data_param.label_map_file();
33    const TransformationParameter& transform_param =
34      this->layer_param_.transform_param();
35    if (transform_param.has_resize_param()) {
36      if (transform_param.resize_param().resize_mode() ==
37          ResizeParameter_Resize_mode_FIT_SMALL_SIZE) {
38        CHECK_EQ(batch_size, 1)
39          << "Only support batch size of 1 for FIT_SMALL_SIZE.";
40      }
41    }
42    AnnotatedDatum anno_datum;
43    anno_datum.ParseFromString(*(reader_.full().peek()));
44    vector<int> top_shape =
45        this->data_transformer_->InferBlobShape(anno_datum.datum());
46    this->transformed_data_.Reshape(top_shape);
47    top_shape[0] = batch_size;
48    top[0]->Reshape(top_shape);
49    for (int i = 0; i < this->PREFETCH_COUNT; ++i) {
50      this->prefetch_[i].data_.Reshape(top_shape);
51    }
52    LOG(INFO) << "output data size: " << top[0]->num() << ","
53        << top[0]->channels() << "," << top[0]->height() << ","
54        << top[0]->width();
55    if (this->output_labels_) {
56      has_anno_type_ = anno_datum.has_type() || anno_data_param.has_anno_type();
57      vector<int> label_shape(4, 1);
58      if (has_anno_type_) {
59        anno_type_ = anno_datum.type();
60        if (anno_data_param.has_anno_type()) {
61          LOG(WARNING) << "type stored in AnnotatedDatum is shadowed.";
62          anno_type_ = anno_data_param.anno_type();
63        }
64        int num_bboxes = 0;
65        if (anno_type_ == AnnotatedDatum_AnnotationType_BBOX) {
66          for (int g = 0; g < anno_datum.annotation_group_size(); ++g) {
67            num_bboxes += anno_datum.annotation_group(g).annotation_size();
68          }
69          label_shape[0] = 1;
70          label_shape[1] = 1;
71          label_shape[2] = std::max(num_bboxes, 1);
72          label_shape[3] = 8;
73        } else {
74          LOG(FATAL) << "Unknown annotation type.";
75        }
76      } else {
77        label_shape[0] = batch_size;
78      }
79      top[1]->Reshape(label_shape);
80      for (int i = 0; i < this->PREFETCH_COUNT; ++i) {
81        this->prefetch_[i].label_.Reshape(label_shape);
82      }
83    }
84  }
85  #ifdef _OPENMP
86  template<typename Dtype>
87  void AnnotatedDataLayer<Dtype>::load_batch(Batch<Dtype>* batch) {
88    CPUTimer batch_timer;
89    CPUTimer trans_timer;
90    batch_timer.Start();
91    double read_time = 0;
92    double trans_time = 0;
93    CPUTimer timer;
94    CHECK(batch->data_.count());
95    const int batch_size = this->layer_param_.data_param().batch_size();
96    const AnnotatedDataParameter& anno_data_param =
97        this->layer_param_.annotated_data_param();
98    const TransformationParameter& transform_param =
99      this->layer_param_.transform_param();
100    AnnotatedDatum anno_datum;
101    anno_datum.ParseFromString(*(reader_.full().peek()));
102    vector<int> top_shape =
103        this->data_transformer_->InferBlobShape(anno_datum.datum());
104    top_shape[0] = batch_size;
105    batch->data_.Reshape(top_shape);
106    Dtype* top_data = batch->data_.mutable_cpu_data();
107    Dtype* top_label = NULL;  
108    if (this->output_labels_ && !has_anno_type_) {
109      top_label = batch->label_.mutable_cpu_data();
110    }
111    std::vector<std::vector<AnnotationGroup>> all_anno(batch_size);
112    std::vector<boost::shared_ptr<AnnotatedDatum>> expand_data(batch_size, nullptr);
113    std::vector<std::vector<NormalizedBBox>> sampled_bboxes(batch_size);
114    boost::container::vector<bool> have_samples(batch_size, false);
115    int num_bboxes = 0;
116    trans_timer.Start();
117  #pragma omp parallel if (batch_size > 1)
118  #pragma omp single nowait
119    {
120      for (int item_id = 0; item_id < batch_size; ++item_id) {
121        timer.Start();
122        string* data = reader_.full().pop("Waiting for data");
123        timer.Stop();
124        read_time += timer.MicroSeconds();
125  #if !defined(_MSC_EXTENSIONS)
126  #pragma omp task firstprivate(item_id, data) shared(all_anno, expand_data, sampled_bboxes, have_samples)
127  #endif
128        {
129          std::unique_ptr<AnnotatedDatum> anno_datum(new AnnotatedDatum());
130          anno_datum->ParseFromString(*data);
131          reader_.free().push(data);
132          std::unique_ptr<AnnotatedDatum> distort_datum(new AnnotatedDatum());
133          boost::shared_ptr<AnnotatedDatum> expand_datum;
134          if (transform_param.has_distort_param()) {
135            distort_datum->CopyFrom(*anno_datum);
136            this->data_transformer_->DistortImage(anno_datum->datum(),
137                                                  distort_datum->mutable_datum());
138            if (transform_param.has_expand_param()) {
139              expand_datum.reset(new AnnotatedDatum());
140              this->data_transformer_->ExpandImage(*distort_datum, expand_datum.get());
141            } else {
142              expand_datum = std::move(distort_datum);
143            }
144          } else {
145            if (transform_param.has_expand_param()) {
146              expand_datum.reset(new AnnotatedDatum());
147              this->data_transformer_->ExpandImage(*anno_datum, expand_datum.get());
148            } else {
149              expand_datum = std::move(anno_datum);
150            }
151          }
152          bool has_sampled = false;
153          if (batch_samplers_.size() > 0) {
154            GenerateBatchSamples(*expand_datum, batch_samplers_, &sampled_bboxes[item_id]);
155            if (sampled_bboxes[item_id].size() > 0) {
156              has_sampled = true;
157            }
158          }
159          expand_data[item_id] = expand_datum;
160          have_samples[item_id] = has_sampled;
161        }
162      }
163  #if !defined(_MSC_EXTENSIONS)
164  #pragma omp taskwait
165  #endif
166      this->data_transformer_->ReinitRand();
167      for (int item_id = 0; item_id < batch_size; ++item_id) {
168        PreclcRandomNumbers precalculated_rand_numbers;
169        this->data_transformer_->GenerateRandNumbers(precalculated_rand_numbers, &bsol;* sample_bboxes */ have_samples[item_id]);
170  #if !defined(_MSC_EXTENSIONS)
171  #pragma omp task firstprivate(precalculated_rand_numbers, item_id) shared(num_bboxes, all_anno, expand_data, sampled_bboxes, have_samples)
172  #endif
173        {
174          boost::shared_ptr<AnnotatedDatum> sampled_datum;
175          bool has_sampled = have_samples[item_id];
176          if (has_sampled) {
177            int rand_idx = precalculated_rand_numbers(sampled_bboxes[item_id].size());
178            sampled_datum.reset(new AnnotatedDatum());
179            this->data_transformer_->CropImage(*expand_data[item_id],
180                                               sampled_bboxes[item_id][rand_idx],
181                                               sampled_datum.get());
182          } else {
183            sampled_datum = expand_data[item_id];
184          }
185          CHECK(sampled_datum.get()  != NULL);
186          Blob<Dtype> data_blob;
187          data_blob.Reshape(top_shape);
188          vector<int> shape =
189            this->data_transformer_->InferBlobShape(sampled_datum->datum());
190          if (transform_param.has_resize_param()) {
191            if (transform_param.resize_param().resize_mode() ==
192              ResizeParameter_Resize_mode_FIT_SMALL_SIZE) {
193              DLOG(INFO) << "Has resize param";
194              data_blob.Reshape(shape);
195              batch->data_.Reshape(shape);
196              top_data = batch->data_.mutable_cpu_data();
197            } else {
198              CHECK(std::equal(top_shape.begin() + 1, top_shape.begin() + 4,
199                               shape.begin() + 1));
200            }
201          } else {
202            CHECK(std::equal(top_shape.begin() + 1, top_shape.begin() + 4,
203                  shape.begin() + 1));
204          }
205          int offset = batch->data_.offset(item_id);
206          data_blob.set_cpu_data(top_data + offset);
207          if (this->output_labels_) {
208            if (has_anno_type_) {
209              CHECK(sampled_datum->has_type()) << "Some datum misses AnnotationType.";
210              if (anno_data_param.has_anno_type()) {
211                sampled_datum->set_type(anno_type_);
212              } else {
213                CHECK_EQ(anno_type_, sampled_datum->type()) <<
214                         "Different AnnotationType.";
215              }
216              this->data_transformer_->Transform(*sampled_datum,
217                                                 &data_blob,
218                                                 &all_anno[item_id],
219                                                 precalculated_rand_numbers);
220              if (anno_type_ == AnnotatedDatum_AnnotationType_BBOX) {
221                for (int g = 0; g < all_anno[item_id].size(); ++g) {
222  #pragma omp atomic
223                  num_bboxes += all_anno[item_id][g].annotation_size();
224                }
225              } else {
226                LOG(FATAL) << "Unknown annotation type.";
227              }
228            } else {
229              this->data_transformer_->Transform(sampled_datum->datum(),
230                                                 &data_blob,
231                                                 precalculated_rand_numbers);
232              CHECK(sampled_datum->datum().has_label()) << "Cannot find any label.";
233              top_label[item_id] = sampled_datum->datum().label();
234            }
235          } else {
236            this->data_transformer_->Transform(sampled_datum->datum(),
237                                               &data_blob,
238                                               precalculated_rand_numbers);
239          }
240        }
241      }
242    }
243    if (this->output_labels_ && has_anno_type_) {
244      vector<int> label_shape(4);
245      if (anno_type_ == AnnotatedDatum_AnnotationType_BBOX) {
246        label_shape[0] = 1;
247        label_shape[1] = 1;
248        label_shape[3] = 8;
249        if (num_bboxes == 0) {
250          label_shape[2] = 1;
251          batch->label_.Reshape(label_shape);
252          caffe_set<Dtype>(8, -1, batch->label_.mutable_cpu_data());
253        } else {
254          label_shape[2] = num_bboxes;
255          batch->label_.Reshape(label_shape);
256          top_label = batch->label_.mutable_cpu_data();
257          int idx = 0;
258          for (int item_id = 0; item_id < batch_size; ++item_id) {
259            const vector<AnnotationGroup>& anno_vec = all_anno[item_id];
260            for (int g = 0; g < anno_vec.size(); ++g) {
261              const AnnotationGroup& anno_group = anno_vec[g];
262              for (int a = 0; a < anno_group.annotation_size(); ++a) {
263                const Annotation& anno = anno_group.annotation(a);
264                const NormalizedBBox& bbox = anno.bbox();
265                top_label[idx++] = item_id;
266                top_label[idx++] = anno_group.group_label();
267                top_label[idx++] = anno.instance_id();
268                top_label[idx++] = bbox.xmin();
269                top_label[idx++] = bbox.ymin();
270                top_label[idx++] = bbox.xmax();
271                top_label[idx++] = bbox.ymax();
272                top_label[idx++] = bbox.difficult();
273              }
274            }
275          }
276        }
277      } else {
278        LOG(FATAL) << "Unknown annotation type.";
279      }
280    }
281    trans_timer.Stop();
282    batch_timer.Stop();
283    trans_time = trans_timer.MicroSeconds() - read_time;
284    DLOG(INFO) << "Prefetch batch: " << batch_timer.MilliSeconds() << " ms.";
285    DLOG(INFO) << "     Read time: " << read_time / 1000 << " ms.";
286    DLOG(INFO) << "Transform time: " << trans_time / 1000 << " ms.";
287  }
288  #else
289  template<typename Dtype>
290  void AnnotatedDataLayer<Dtype>::load_batch(Batch<Dtype>* batch) {
291    CPUTimer batch_timer;
292    batch_timer.Start();
293    double read_time = 0;
294    double trans_time = 0;
295    CPUTimer timer;
296    CHECK(batch->data_.count());
297    CHECK(this->transformed_data_.count());
298    const int batch_size = this->layer_param_.data_param().batch_size();
299    const AnnotatedDataParameter& anno_data_param =
<span onclick='openModal()' class='match'>300        this->layer_param_.annotated_data_param();
301    const TransformationParameter& transform_param =
302      this->layer_param_.transform_param();
303    AnnotatedDatum anno_datum;
304    anno_datum.ParseFromString(*(reader_.full().peek()));
305    vector<int> top_shape =
306        this->data_transformer_->InferBlobShape(anno_datum.datum());
307    this->transformed_data_.Reshape(top_shape);
</span>308    top_shape[0] = batch_size;
309    batch->data_.Reshape(top_shape);
310    Dtype* top_data = batch->data_.mutable_cpu_data();
311    Dtype* top_label = NULL;  
312    if (this->output_labels_ && !has_anno_type_) {
313      top_label = batch->label_.mutable_cpu_data();
314    }
315    map<int, vector<AnnotationGroup> > all_anno;
316    int num_bboxes = 0;
317    for (int item_id = 0; item_id < batch_size; ++item_id) {
318      timer.Start();
319      string* data = reader_.full().pop("Waiting for data");
320      AnnotatedDatum anno_datum;
321      anno_datum.ParseFromString(*data);
322      reader_.free().push(data);
323      read_time += timer.MicroSeconds();
324      timer.Start();
325      AnnotatedDatum distort_datum;
326      AnnotatedDatum* expand_datum = NULL;
327      if (transform_param.has_distort_param()) {
328        distort_datum.CopyFrom(anno_datum);
329        this->data_transformer_->DistortImage(anno_datum.datum(),
330                                              distort_datum.mutable_datum());
331        if (transform_param.has_expand_param()) {
332          expand_datum = new AnnotatedDatum();
333          this->data_transformer_->ExpandImage(distort_datum, expand_datum);
334        } else {
335          expand_datum = &distort_datum;
336        }
337      } else {
338        if (transform_param.has_expand_param()) {
339          expand_datum = new AnnotatedDatum();
340          this->data_transformer_->ExpandImage(anno_datum, expand_datum);
341        } else {
342          expand_datum = &anno_datum;
343        }
344      }
345      AnnotatedDatum* sampled_datum = NULL;
346      bool has_sampled = false;
347      if (batch_samplers_.size() > 0) {
348        vector<NormalizedBBox> sampled_bboxes;
349        GenerateBatchSamples(*expand_datum, batch_samplers_, &sampled_bboxes);
350        if (sampled_bboxes.size() > 0) {
351          int rand_idx = caffe_rng_rand() % sampled_bboxes.size();
352          sampled_datum = new AnnotatedDatum();
353          this->data_transformer_->CropImage(*expand_datum,
354                                             sampled_bboxes[rand_idx],
355                                             sampled_datum);
356          has_sampled = true;
357        } else {
358          sampled_datum = expand_datum;
359        }
360      } else {
361        sampled_datum = expand_datum;
362      }
363      CHECK(sampled_datum != NULL);
364      timer.Start();
365      vector<int> shape =
366          this->data_transformer_->InferBlobShape(sampled_datum->datum());
367      if (transform_param.has_resize_param()) {
368        if (transform_param.resize_param().resize_mode() ==
369            ResizeParameter_Resize_mode_FIT_SMALL_SIZE) {
370          DLOG(INFO) << "Has resize param";
371          this->transformed_data_.Reshape(shape);
372          batch->data_.Reshape(shape);
373          top_data = batch->data_.mutable_cpu_data();
374        } else {
375          CHECK(std::equal(top_shape.begin() + 1, top_shape.begin() + 4,
376                shape.begin() + 1));
377        }
378      } else {
379        CHECK(std::equal(top_shape.begin() + 1, top_shape.begin() + 4,
380              shape.begin() + 1));
381      }
382      int offset = batch->data_.offset(item_id);
383      this->transformed_data_.set_cpu_data(top_data + offset);
384      vector<AnnotationGroup> transformed_anno_vec;
385      if (this->output_labels_) {
386        if (has_anno_type_) {
387          CHECK(sampled_datum->has_type()) << "Some datum misses AnnotationType.";
388          if (anno_data_param.has_anno_type()) {
389            sampled_datum->set_type(anno_type_);
390          } else {
391            CHECK_EQ(anno_type_, sampled_datum->type()) <<
392                "Different AnnotationType.";
393          }
394          transformed_anno_vec.clear();
395          this->data_transformer_->Transform(*sampled_datum,
396                                             &(this->transformed_data_),
397                                             &transformed_anno_vec);
398          if (anno_type_ == AnnotatedDatum_AnnotationType_BBOX) {
399            for (int g = 0; g < transformed_anno_vec.size(); ++g) {
400              num_bboxes += transformed_anno_vec[g].annotation_size();
401            }
402          } else {
403            LOG(FATAL) << "Unknown annotation type.";
404          }
405          all_anno[item_id] = transformed_anno_vec;
406        } else {
407          this->data_transformer_->Transform(sampled_datum->datum(),
408                                             &(this->transformed_data_));
409          CHECK(sampled_datum->datum().has_label()) << "Cannot find any label.";
410          top_label[item_id] = sampled_datum->datum().label();
411        }
412      } else {
413        this->data_transformer_->Transform(sampled_datum->datum(),
414                                           &(this->transformed_data_));
415      }
416      if (has_sampled) {
417        delete sampled_datum;
418      }
419      if (transform_param.has_expand_param()) {
420        delete expand_datum;
421      }
422      trans_time += timer.MicroSeconds();
423    }
424    if (this->output_labels_ && has_anno_type_) {
425      vector<int> label_shape(4);
426      if (anno_type_ == AnnotatedDatum_AnnotationType_BBOX) {
427        label_shape[0] = 1;
428        label_shape[1] = 1;
429        label_shape[3] = 8;
430        if (num_bboxes == 0) {
431          label_shape[2] = 1;
432          batch->label_.Reshape(label_shape);
433          caffe_set<Dtype>(8, -1, batch->label_.mutable_cpu_data());
434        } else {
435          label_shape[2] = num_bboxes;
436          batch->label_.Reshape(label_shape);
437          top_label = batch->label_.mutable_cpu_data();
438          int idx = 0;
439          for (int item_id = 0; item_id < batch_size; ++item_id) {
440            const vector<AnnotationGroup>& anno_vec = all_anno[item_id];
441            for (int g = 0; g < anno_vec.size(); ++g) {
442              const AnnotationGroup& anno_group = anno_vec[g];
443              for (int a = 0; a < anno_group.annotation_size(); ++a) {
444                const Annotation& anno = anno_group.annotation(a);
445                const NormalizedBBox& bbox = anno.bbox();
446                top_label[idx++] = item_id;
447                top_label[idx++] = anno_group.group_label();
448                top_label[idx++] = anno.instance_id();
449                top_label[idx++] = bbox.xmin();
450                top_label[idx++] = bbox.ymin();
451                top_label[idx++] = bbox.xmax();
452                top_label[idx++] = bbox.ymax();
453                top_label[idx++] = bbox.difficult();
454              }
455            }
456          }
457        }
458      } else {
459        LOG(FATAL) << "Unknown annotation type.";
460      }
461    }
462    timer.Stop();
463    batch_timer.Stop();
464    DLOG(INFO) << "Prefetch batch: " << batch_timer.MilliSeconds() << " ms.";
465    DLOG(INFO) << "     Read time: " << read_time / 1000 << " ms.";
466    DLOG(INFO) << "Transform time: " << trans_time / 1000 << " ms.";
467  }
468  #endif 
469  INSTANTIATE_CLASS(AnnotatedDataLayer);
470  REGISTER_LAYER_CLASS(AnnotatedData);
471  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-annotated_data_layer.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-annotated_data_layer.cpp</div>
                </div>
                <div class="column column_space"><pre><code>300        this->layer_param_.annotated_data_param();
301    const TransformationParameter& transform_param =
302      this->layer_param_.transform_param();
303    AnnotatedDatum anno_datum;
304    anno_datum.ParseFromString(*(reader_.full().peek()));
305    vector<int> top_shape =
306        this->data_transformer_->InferBlobShape(anno_datum.datum());
307    this->transformed_data_.Reshape(top_shape);
</pre></code></div>
                <div class="column column_space"><pre><code>300        this->layer_param_.annotated_data_param();
301    const TransformationParameter& transform_param =
302      this->layer_param_.transform_param();
303    AnnotatedDatum anno_datum;
304    anno_datum.ParseFromString(*(reader_.full().peek()));
305    vector<int> top_shape =
306        this->data_transformer_->InferBlobShape(anno_datum.datum());
307    this->transformed_data_.Reshape(top_shape);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    