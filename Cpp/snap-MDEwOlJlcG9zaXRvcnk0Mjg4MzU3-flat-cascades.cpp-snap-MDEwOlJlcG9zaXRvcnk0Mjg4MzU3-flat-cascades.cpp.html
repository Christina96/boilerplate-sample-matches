
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 61, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-cascades.cpp</h3>
            <pre><code>1  #include "stdafx.h"
2  class TCascadeStat {
3  public:
4    THash<TFlt, TMom> NCascInf, NCascNet;   
5    THash<TFlt, TMom> MxSzInf, MxSzNet;     
6    THash<TFlt, TMom> AvgSzInf, AvgSzNet;   
7    THash<TFlt, TMom> NIsoInf, NIsoNet;     
8    THash<TFlt, TMom> NLfInf, NLfNet;       
9    THash<TFlt, TMom> NRtInf, NRtNet;       
10    THash<TFlt, TMom> OutDegInf, OutDegNet; 
11    THash<TFlt, TMom> InDegInf, InDegNet;   
12    THash<TFlt, TMom> DepthInf, DepthNet;   
13    THash<TFlt, TMom> MxWidInf, MxWidNet;   
14    THash<TFlt, TMom> MxLevInf, MxLevNet;   
15    THash<TFlt, TMom> IncLevInf, IncLevNet; 
16  public:
17    TCascadeStat() { }
18    void PlotAll(const TStr& OutFNm, const TStr& Desc, const bool& DivByM=true);
19    static double NonZ(double C) { return C==0?1.0:C; }
20    template <class PGraph>
21    void SampleCascade(const PGraph& InfCasc, const PGraph& NetCasc, const TIntH& NIdInfTmH, const double& PStep=0.05, const int& NRuns=1, const bool& DivByM=true) {
22      for (int Run=0; Run < NRuns; Run++) {
23        for (double P = PStep; P <= 1.01; P += PStep) {
24          TIntV NIdV;
25          for (typename PGraph::TObj::TNodeI NI = InfCasc->BegNI(); NI < InfCasc->EndNI(); NI++) {
26            if (TInt::Rnd.GetUniDev() < P) { NIdV.Add(NI.GetId()); } }
27          PGraph InfG = TSnap::GetSubGraph(InfCasc, NIdV);
28          PGraph NetG = TSnap::GetSubGraph(NetCasc, NIdV);
29          if (InfG->GetNodes()==0) { continue; }
30          TakeStat(InfG, NetG, NIdInfTmH, P, DivByM);
31        }
32      }
33    }
34    template<class PGraph>
35    int FindCascadeRoot(const PGraph& G, const TIntH& NIdInfTmH) { 
36      int Min=TInt::Mx, MinNId=-1;
37      for (typename PGraph::TObj::TNodeI NI = G->BegNI(); NI < G->EndNI(); NI++) {
38        const int t = NIdInfTmH.GetDat(NI.GetId());
39        if (t < Min && NI.GetInDeg()==0) { Min=t; MinNId=NI.GetId(); } }
40      IAssert(MinNId!=-1);  return MinNId;
41    }
42    template<class PGraph>
43    double GetAvgDepthFromRoot(const PGraph& G) {
44      TMom Mom;
45      TIntPrV HopCntV;
46      for (typename PGraph::TObj::TNodeI NI = G->BegNI(); NI < G->EndNI(); NI++) {
47        if (NI.GetOutDeg()>0 && NI.GetInDeg()==0) {
48          TSnap::GetNodesAtHops(G, NI.GetId(), HopCntV, true);
49          Mom.Add(HopCntV.Last().Val1()); }
50      }
51      Mom.Def();  return Mom.GetMean();
52    }
53    template <class PGraph>
54    void TakeStat(const PGraph& InfG, const PGraph& NetG, const TIntH& NIdInfTmH, const double& P, const bool& DivByM=true) {
55      const double M = DivByM ? InfG->GetNodes() : 1;  IAssert(M>=1);
56      PGraph CcInf, CcNet; 
57      { TCnComV CnComV;  TSnap::GetWccs(InfG, CnComV);
58      NCascInf.AddDat(P).Add(CnComV.Len()/M);
59      MxSzInf.AddDat(P).Add(CnComV[0].Len()/M);
60      { int a=0; for (int i=0; i<CnComV.Len(); i++) { a+=CnComV[i].Len(); }
61      AvgSzInf.AddDat(P).Add(a/double(CnComV.Len()*M)); }
62      CcInf = TSnap::GetSubGraph(InfG, CnComV[0].NIdV);
63      TSnap::GetWccs(NetG, CnComV);
64      NCascNet.AddDat(P).Add(CnComV.Len()/M);
65      MxSzNet.AddDat(P).Add(CnComV[0].Len()/M);
66      { int a=0; for (int i=0; i<CnComV.Len(); i++) { a+=CnComV[i].Len(); }
67      AvgSzNet.AddDat(P).Add(a/double(CnComV.Len()*M)); }
68      CcNet = TSnap::GetSubGraph(NetG, CnComV[0].NIdV); }
69      { int i1=0, i2=0,l1=0,l2=0,r1=0,r2=0,ENet=0,EInf=0; double ci1=0,ci2=0,co1=0,co2=0;
70      for (typename PGraph::TObj::TNodeI NI = InfG->BegNI(); NI < InfG->EndNI(); NI++) {
71        if (NI.GetOutDeg()==0 && NI.GetInDeg()>0) { l1++; }
72        if (NI.GetOutDeg()>0 && NI.GetInDeg()==0) { r1++; }
73        if (NI.GetDeg()==0) { i1++; }  if (NI.GetInDeg()>0) { ci1+=1; }
74        if (NI.GetOutDeg()>0) { co1+=1; }  EInf+=NI.GetOutDeg(); }
75      for (typename PGraph::TObj::TNodeI NI = NetG->BegNI(); NI < NetG->EndNI(); NI++) {
76        if (NI.GetOutDeg()==0 && NI.GetInDeg()>0) { l2++; }
77        if (NI.GetOutDeg()>0 && NI.GetInDeg()==0) { r2++; }
78        if (NI.GetDeg()==0) { i2++; }  if (NI.GetInDeg()>0) { ci2+=1; }
79        if (NI.GetOutDeg()>0) { co2+=1; }  ENet+=NI.GetOutDeg(); }
80      if(ci1>0)InDegInf.AddDat(P).Add(EInf/ci1);  if(ci2>0)InDegNet.AddDat(P).Add(ENet/ci2);
81      if(co1>0)OutDegInf.AddDat(P).Add(EInf/co1); if(co2>0)OutDegNet.AddDat(P).Add(ENet/co2);
82      NLfInf.AddDat(P).Add(l1/M);  NLfNet.AddDat(P).Add(l2/M);
83      NRtInf.AddDat(P).Add(r1/M);  NRtNet.AddDat(P).Add(r2/M);
84      NIsoInf.AddDat(P).Add(i1/M); NIsoNet.AddDat(P).Add(i2/M); }
85      { const double M1 = DivByM ? CcNet->GetNodes() : 1;  IAssert(M1>=1);
86      int Root=FindCascadeRoot(CcInf, NIdInfTmH);  TIntPrV HopCntV;
87      TSnap::GetNodesAtHops(CcInf, Root, HopCntV, true);
88      int MxN=0, Lev=0, IncL=0;
89      for (int i = 0; i < HopCntV.Len(); i++) {
90        if (MxN<HopCntV[i].Val2) { MxN=HopCntV[i].Val2; Lev=HopCntV[i].Val1; }
91        if (i > 0 && HopCntV[i-1].Val2<=HopCntV[i].Val2) { IncL++; } }
92      double D=0; int c=0; TIntH DistH;
93      D = HopCntV.Last().Val1; c=1; 
94      if (c!=0 && D!=0) { D = D/c;
95        DepthInf.AddDat(P).Add(D/M1); MxWidInf.AddDat(P).Add(MxN/M1);
96        MxLevInf.AddDat(P).Add(Lev/D); IncLevInf.AddDat(P).Add(IncL/D);
97      }
98      Root=FindCascadeRoot(CcNet, NIdInfTmH);
99      TSnap::GetNodesAtHops(CcNet, Root, HopCntV, true);
100      MxN=0; Lev=0; IncL=0; D=0; c=0;
101      for (int i = 0; i < HopCntV.Len(); i++) {
102        if (MxN<HopCntV[i].Val2) { MxN=HopCntV[i].Val2; Lev=HopCntV[i].Val1; }
103        if (i > 0 && HopCntV[i-1].Val2<=HopCntV[i].Val2) { IncL++; } }
104      D = HopCntV.Last().Val1; c=1; 
105      if (c!=0 && D!=0) { D = D/c;
106        DepthNet.AddDat(P).Add(D/M1); MxWidNet.AddDat(P).Add(MxN/M1);
107        MxLevNet.AddDat(P).Add(Lev/D); IncLevNet.AddDat(P).Add(IncL/D); }
108      }
109    }
110  };
111  PNGraph RunSICascade(PUNGraph G, const double& Beta, const int& CascSz, TIntH& NIdInfTmH);
112  PNGraph RunSICascade2(PUNGraph G, const double& Beta, const int& MxCascSz, TIntH& NIdInfTmH);
113  PNGraph AddSpuriousEdges(const PUNGraph& Graph, const PNGraph& Casc, TIntH NIdTmH);
114  int main(int argc, char* argv[]) {
115    Env = TEnv(argc, argv, TNotify::StdNotify);
116    Env.PrepArgs(TStr::Fmt("Cascades. build: %s, %s. Time: %s", __TIME__, __DATE__, TExeTm::GetCurTm()));
117    TExeTm ExeTm;
118    Try
119    const TStr InFNm = Env.GetIfArgPrefixStr("-i:", "demo", "Input undirected graph");
120    const TStr OutFNm = Env.GetIfArgPrefixStr("-o:", "demo", "Output file name prefix");
121    const double Beta = Env.GetIfArgPrefixFlt("-b:", 0.1, "Beta (infection (i.e., cascade propagation) probability)");
122    printf("Loading %s...", InFNm.CStr());
123    PUNGraph Graph;
124    if (InFNm == "demo") { Graph = TSnap::GenRndGnm<PUNGraph>(100, 200); }
125    else { Graph = TSnap::LoadEdgeList<PUNGraph>(InFNm); }
126    printf("nodes:%d  edges:%d\n", Graph->GetNodes(), Graph->GetEdges());
127    Graph = TSnap::GetMxWcc(Graph);
128    bool DivByM = true;
129    TCascadeStat CascStat;
130    printf("\nGraph:%s -- Beta: %g\n", OutFNm.CStr(), Beta);
131    for (int Run = 0; Run < 10; Run++) { 
132      TIntH NIdInfTmH;
133      PNGraph InfCasc = RunSICascade(Graph, Beta, 100, NIdInfTmH);
134      if (InfCasc->GetNodes() < 10) { printf("."); continue; } 
135      PNGraph NetCasc = AddSpuriousEdges(Graph, InfCasc, NIdInfTmH);
136      CascStat.SampleCascade(InfCasc, NetCasc, NIdInfTmH, 0.1, 10, DivByM);  
137      printf(".");
138    }
139    CascStat.PlotAll(TStr::Fmt("%s-B%03d", OutFNm.CStr(), int(100*Beta)), TStr::Fmt("%s N=%d  E=%d  Beta=%g", 
140      OutFNm.CStr(), Graph->GetNodes(), Graph->GetEdges(), Beta), DivByM);
141    Catch
142    printf("\nrun time: %s (%s)\n", ExeTm.GetTmStr(), TSecTm::GetCurTm().GetTmStr().CStr());
143    return 0;
144  }
145  void TCascadeStat::PlotAll(const TStr& OutFNm, const TStr& Desc, const bool& DivByM) {
146    const TStr MStr = DivByM ? " / M (number of observed nodes)" : "";
147    { TGnuPlot GP(TStr::Fmt("ncasc-%s", OutFNm.CStr()), Desc);
148    GP.SetXYLabel("Fraction of observed data (P)", "Number of connected components" + MStr);
149    GP.AddPlot(NCascInf, gpwLinesPoints, "Influence cascade", "lw 2",true, false, false, false, false, false);
150    GP.AddPlot(NCascNet, gpwLinesPoints, "Network cascade", "lw 2",true, false, false, false, false, false);
151    GP.SavePng(); }
152    { TGnuPlot GP(TStr::Fmt("mxSz-%s", OutFNm.CStr()), Desc);
153    GP.SetXYLabel("Fraction of observed data (P)", "Size of largest connected component" + MStr);
154    GP.AddPlot(MxSzInf, gpwLinesPoints, "Influence cascade", "lw 2",true, false, false, false, false, false);
155    GP.AddPlot(MxSzNet, gpwLinesPoints, "Network cascade", "lw 2",true, false, false, false, false, false);
156    GP.SavePng(); }
157    { TGnuPlot GP(TStr::Fmt("avgSz-%s", OutFNm.CStr()), Desc);
158    GP.SetXYLabel("Fraction of observed data (P)", "Average connected component size" + MStr);
159    GP.AddPlot(AvgSzInf, gpwLinesPoints, "Influence cascade", "lw 2",true, false, false, false, false, false);
160    GP.AddPlot(AvgSzNet, gpwLinesPoints, "Network cascade", "lw 2",true, false, false, false, false, false);
161    GP.SavePng(); }
162    { TGnuPlot GP(TStr::Fmt("nIso-%s", OutFNm.CStr()), Desc);
163    GP.SetXYLabel("Fraction of observed data (P)", "Number of isolated nodes" + MStr);
164    GP.AddPlot(NIsoInf, gpwLinesPoints, "Influence cascade", "lw 2",true, false, false, false, false, false);
165    GP.AddPlot(NIsoNet, gpwLinesPoints, "Network cascade", "lw 2",true, false, false, false, false, false);
166    GP.SavePng(); }
167    { TGnuPlot GP(TStr::Fmt("nRt-%s", OutFNm.CStr()), Desc);
168    GP.SetXYLabel("Fraction of observed data (P)", "Number of root nodes" + MStr);
169    GP.AddPlot(NRtInf, gpwLinesPoints, "Influence cascade", "lw 2",true, false, false, false, false, false);
170    GP.AddPlot(NRtNet, gpwLinesPoints, "Network cascade", "lw 2",true, false, false, false, false, false);
171    GP.SavePng(); }
172    { TGnuPlot GP(TStr::Fmt("nLf-%s", OutFNm.CStr()), Desc);
173    GP.SetXYLabel("Fraction of observed data (P)", "Number of leaves (nodes of zero out-degree)" + MStr);
174    GP.AddPlot(NLfInf, gpwLinesPoints, "Influence cascade", "lw 2",true, false, false, false, false, false);
175    GP.AddPlot(NLfNet, gpwLinesPoints, "Network cascade", "lw 2",true, false, false, false, false, false);
176    GP.SavePng(); }
177    { TGnuPlot GP(TStr::Fmt("outDeg-%s", OutFNm.CStr()), Desc);
178    GP.SetXYLabel("Fraction of observed data (P)", "Average Out-Degree (of a non-leaf)");
179    GP.AddPlot(OutDegInf, gpwLinesPoints, "Influence cascade", "lw 2",true, false, false, false, false, false);
180    GP.AddPlot(OutDegNet, gpwLinesPoints, "Network cascade", "lw 2",true, false, false, false, false, false);
181    GP.SavePng(); }
182    { TGnuPlot GP(TStr::Fmt("inDeg-%s", OutFNm.CStr()), Desc);
183    GP.SetXYLabel("Fraction of observed data (P)", "Average In-Degree (of a non-root)");
184    GP.AddPlot(InDegInf, gpwLinesPoints, "Influence cascade", "lw 2",true, false, false, false, false, false);
185    GP.AddPlot(InDegNet, gpwLinesPoints, "Network cascade", "lw 2",true, false, false, false, false, false);
186    GP.SavePng(); }
187    { TGnuPlot GP(TStr::Fmt("levels-%s", OutFNm.CStr()), Desc);
188    GP.SetXYLabel("Fraction of observed data (P)", "Average depth of largest component" + MStr);
189    GP.AddPlot(DepthInf, gpwLinesPoints, "Influence cascade", "lw 2",true, false, false, false, false, false);
190    GP.AddPlot(DepthNet, gpwLinesPoints, "Network cascade", "lw 2",true, false, false, false, false, false);
191    GP.SavePng(); }
192    { TGnuPlot GP(TStr::Fmt("width-%s", OutFNm.CStr()), Desc);
193    GP.SetXYLabel("Fraction of observed data (P)", "Width of largest components (max nodes at any level)" + MStr);
194    GP.AddPlot(MxWidInf, gpwLinesPoints, "Influence cascade", "lw 2",true, false, false, false, false, false);
195    GP.AddPlot(MxWidNet, gpwLinesPoints, "Network cascade", "lw 2",true, false, false, false, false, false);
196    GP.SavePng(); }
197    { TGnuPlot GP(TStr::Fmt("levWidth-%s", OutFNm.CStr()), Desc);
198    GP.SetXYLabel("Fraction of observed data (P)", "Level with maximum width / Depth");
199    GP.AddPlot(MxLevInf, gpwLinesPoints, "Influence cascade", "lw 2",true, false, false, false, false, false);
200    GP.AddPlot(MxLevNet, gpwLinesPoints, "Network cascade", "lw 2",true, false, false, false, false, false);
201    GP.SavePng(); }
202    { TGnuPlot GP(TStr::Fmt("levInc-%s", OutFNm.CStr()), Desc);
203    GP.SetXYLabel("Fraction of observed data (P)", "Number of levels of increasing width / Depth");
204    GP.AddPlot(IncLevInf, gpwLinesPoints, "Influence cascade", "lw 2",true, false, false, false, false, false);
205    GP.AddPlot(IncLevNet, gpwLinesPoints, "Network cascade", "lw 2",true, false, false, false, false, false);
206    GP.SavePng(); }
<span onclick='openModal()' class='match'>207  }
208  PNGraph RunSICascade(PUNGraph G, const double& Beta, const int& CascSz, TIntH& NIdInfTmH) {
209    PNGraph Casc = TNGraph::New();
210    const int StartId = G->GetRndNId();
211    Casc->AddNode(StartId);
212    NIdInfTmH.AddDat(StartId, NIdInfTmH.Len());
213    for (int X = 0; X < 10*CascSz; X++) {
</span>214      TIntV CascNIdV;  Casc->GetNIdV(CascNIdV);
215      for (int n = 0; n < CascNIdV.Len(); n++) {
216        const TUNGraph::TNodeI NI = G->GetNI(CascNIdV[n]);
217        for (int i = 0; i < NI.GetOutDeg(); i++) {
218          if (Casc->IsNode(NI.GetOutNId(i))) { continue; }
219          if (TInt::Rnd.GetUniDev() < Beta) {
220            Casc->AddNode(NI.GetOutNId(i));
221            NIdInfTmH.AddDat(NI.GetOutNId(i), NIdInfTmH.Len());
222            Casc->AddEdge(NI.GetId(), NI.GetOutNId(i));
223            if (Casc->GetNodes() == CascSz) { return Casc; }
224          }
225        }
226      }
227    }
228    return Casc;
229  }
230  PNGraph RunSICascade2(PUNGraph G, const double& Beta, const int& MxCascSz, TIntH& NIdInfTmH) {
231    PNGraph Casc = TNGraph::New();
232    const int StartNId = G->GetRndNId();
233    Casc->AddNode(StartNId);
234    NIdInfTmH.AddDat(StartNId, NIdInfTmH.Len());
235    TIntQ Q; Q.Push(StartNId);
236    while (! Q.Empty()) {
237      const TUNGraph::TNodeI NI = G->GetNI(Q.Top()); Q.Pop();
238      for (int i = 0; i < NI.GetOutDeg(); i++) {
239        if (TInt::Rnd.GetUniDev() < Beta && ! NIdInfTmH.IsKey(NI.GetOutNId(i))) {
240          Casc->AddNode(NI.GetOutNId(i));
241          NIdInfTmH.AddDat(NI.GetOutNId(i), NIdInfTmH.Len());
242          Casc->AddEdge(NI.GetId(), NI.GetOutNId(i));
243          if (Casc->GetNodes() == MxCascSz) { return Casc; }
244          Q.Push(NI.GetOutNId(i));
245        }
246      }
247    }
248    return Casc;
249  }
250  PNGraph AddSpuriousEdges(const PUNGraph& Graph, const PNGraph& Casc, TIntH NIdTmH) {
251    TIntPrV EdgeV;
252    for (TNGraph::TNodeI NI = Casc->BegNI(); NI < Casc->EndNI(); NI++) {
253      TUNGraph::TNodeI GNI = Graph->GetNI(NI.GetId());
254      const int Tm = NIdTmH.GetDat(NI.GetId());
255      for (int i=0; i < GNI.GetOutDeg(); i++) {
256        const int Dst = GNI.GetOutNId(i);
257        if (NIdTmH.IsKey(Dst) && Tm<NIdTmH.GetDat(Dst) && ! NI.IsNbrNId(Dst)) {
258          EdgeV.Add(TIntPr(GNI.GetId(), Dst)); }
259      }
260    }
261    PNGraph NetCasc = TNGraph::New();
262    *NetCasc = *Casc;
263    for (int e = 0; e < EdgeV.Len(); e++) {
264      NetCasc->AddEdge(EdgeV[e].Val1, EdgeV[e].Val2); }
265    return NetCasc;
266  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-cascades.cpp</h3>
            <pre><code>1  #include "stdafx.h"
2  class TCascadeStat {
3  public:
4    THash<TFlt, TMom> NCascInf, NCascNet;   
5    THash<TFlt, TMom> MxSzInf, MxSzNet;     
6    THash<TFlt, TMom> AvgSzInf, AvgSzNet;   
7    THash<TFlt, TMom> NIsoInf, NIsoNet;     
8    THash<TFlt, TMom> NLfInf, NLfNet;       
9    THash<TFlt, TMom> NRtInf, NRtNet;       
10    THash<TFlt, TMom> OutDegInf, OutDegNet; 
11    THash<TFlt, TMom> InDegInf, InDegNet;   
12    THash<TFlt, TMom> DepthInf, DepthNet;   
13    THash<TFlt, TMom> MxWidInf, MxWidNet;   
14    THash<TFlt, TMom> MxLevInf, MxLevNet;   
15    THash<TFlt, TMom> IncLevInf, IncLevNet; 
16  public:
17    TCascadeStat() { }
18    void PlotAll(const TStr& OutFNm, const TStr& Desc, const bool& DivByM=true);
19    static double NonZ(double C) { return C==0?1.0:C; }
20    template <class PGraph>
21    void SampleCascade(const PGraph& InfCasc, const PGraph& NetCasc, const TIntH& NIdInfTmH, const double& PStep=0.05, const int& NRuns=1, const bool& DivByM=true) {
22      for (int Run=0; Run < NRuns; Run++) {
23        for (double P = PStep; P <= 1.01; P += PStep) {
24          TIntV NIdV;
25          for (typename PGraph::TObj::TNodeI NI = InfCasc->BegNI(); NI < InfCasc->EndNI(); NI++) {
26            if (TInt::Rnd.GetUniDev() < P) { NIdV.Add(NI.GetId()); } }
27          PGraph InfG = TSnap::GetSubGraph(InfCasc, NIdV);
28          PGraph NetG = TSnap::GetSubGraph(NetCasc, NIdV);
29          if (InfG->GetNodes()==0) { continue; }
30          TakeStat(InfG, NetG, NIdInfTmH, P, DivByM);
31        }
32      }
33    }
34    template<class PGraph>
35    int FindCascadeRoot(const PGraph& G, const TIntH& NIdInfTmH) { 
36      int Min=TInt::Mx, MinNId=-1;
37      for (typename PGraph::TObj::TNodeI NI = G->BegNI(); NI < G->EndNI(); NI++) {
38        const int t = NIdInfTmH.GetDat(NI.GetId());
39        if (t < Min && NI.GetInDeg()==0) { Min=t; MinNId=NI.GetId(); } }
40      IAssert(MinNId!=-1);  return MinNId;
41    }
42    template<class PGraph>
43    double GetAvgDepthFromRoot(const PGraph& G) {
44      TMom Mom;
45      TIntPrV HopCntV;
46      for (typename PGraph::TObj::TNodeI NI = G->BegNI(); NI < G->EndNI(); NI++) {
47        if (NI.GetOutDeg()>0 && NI.GetInDeg()==0) {
48          TSnap::GetNodesAtHops(G, NI.GetId(), HopCntV, true);
49          Mom.Add(HopCntV.Last().Val1()); }
50      }
51      Mom.Def();  return Mom.GetMean();
52    }
53    template <class PGraph>
54    void TakeStat(const PGraph& InfG, const PGraph& NetG, const TIntH& NIdInfTmH, const double& P, const bool& DivByM=true) {
55      const double M = DivByM ? InfG->GetNodes() : 1;  IAssert(M>=1);
56      PGraph CcInf, CcNet; 
57      { TCnComV CnComV;  TSnap::GetWccs(InfG, CnComV);
58      NCascInf.AddDat(P).Add(CnComV.Len()/M);
59      MxSzInf.AddDat(P).Add(CnComV[0].Len()/M);
60      { int a=0; for (int i=0; i<CnComV.Len(); i++) { a+=CnComV[i].Len(); }
61      AvgSzInf.AddDat(P).Add(a/double(CnComV.Len()*M)); }
62      CcInf = TSnap::GetSubGraph(InfG, CnComV[0].NIdV);
63      TSnap::GetWccs(NetG, CnComV);
64      NCascNet.AddDat(P).Add(CnComV.Len()/M);
65      MxSzNet.AddDat(P).Add(CnComV[0].Len()/M);
66      { int a=0; for (int i=0; i<CnComV.Len(); i++) { a+=CnComV[i].Len(); }
67      AvgSzNet.AddDat(P).Add(a/double(CnComV.Len()*M)); }
68      CcNet = TSnap::GetSubGraph(NetG, CnComV[0].NIdV); }
69      { int i1=0, i2=0,l1=0,l2=0,r1=0,r2=0,ENet=0,EInf=0; double ci1=0,ci2=0,co1=0,co2=0;
70      for (typename PGraph::TObj::TNodeI NI = InfG->BegNI(); NI < InfG->EndNI(); NI++) {
71        if (NI.GetOutDeg()==0 && NI.GetInDeg()>0) { l1++; }
72        if (NI.GetOutDeg()>0 && NI.GetInDeg()==0) { r1++; }
73        if (NI.GetDeg()==0) { i1++; }  if (NI.GetInDeg()>0) { ci1+=1; }
74        if (NI.GetOutDeg()>0) { co1+=1; }  EInf+=NI.GetOutDeg(); }
75      for (typename PGraph::TObj::TNodeI NI = NetG->BegNI(); NI < NetG->EndNI(); NI++) {
76        if (NI.GetOutDeg()==0 && NI.GetInDeg()>0) { l2++; }
77        if (NI.GetOutDeg()>0 && NI.GetInDeg()==0) { r2++; }
78        if (NI.GetDeg()==0) { i2++; }  if (NI.GetInDeg()>0) { ci2+=1; }
79        if (NI.GetOutDeg()>0) { co2+=1; }  ENet+=NI.GetOutDeg(); }
80      if(ci1>0)InDegInf.AddDat(P).Add(EInf/ci1);  if(ci2>0)InDegNet.AddDat(P).Add(ENet/ci2);
81      if(co1>0)OutDegInf.AddDat(P).Add(EInf/co1); if(co2>0)OutDegNet.AddDat(P).Add(ENet/co2);
82      NLfInf.AddDat(P).Add(l1/M);  NLfNet.AddDat(P).Add(l2/M);
83      NRtInf.AddDat(P).Add(r1/M);  NRtNet.AddDat(P).Add(r2/M);
84      NIsoInf.AddDat(P).Add(i1/M); NIsoNet.AddDat(P).Add(i2/M); }
85      { const double M1 = DivByM ? CcNet->GetNodes() : 1;  IAssert(M1>=1);
86      int Root=FindCascadeRoot(CcInf, NIdInfTmH);  TIntPrV HopCntV;
87      TSnap::GetNodesAtHops(CcInf, Root, HopCntV, true);
88      int MxN=0, Lev=0, IncL=0;
89      for (int i = 0; i < HopCntV.Len(); i++) {
90        if (MxN<HopCntV[i].Val2) { MxN=HopCntV[i].Val2; Lev=HopCntV[i].Val1; }
91        if (i > 0 && HopCntV[i-1].Val2<=HopCntV[i].Val2) { IncL++; } }
92      double D=0; int c=0; TIntH DistH;
93      D = HopCntV.Last().Val1; c=1; 
94      if (c!=0 && D!=0) { D = D/c;
95        DepthInf.AddDat(P).Add(D/M1); MxWidInf.AddDat(P).Add(MxN/M1);
96        MxLevInf.AddDat(P).Add(Lev/D); IncLevInf.AddDat(P).Add(IncL/D);
97      }
98      Root=FindCascadeRoot(CcNet, NIdInfTmH);
99      TSnap::GetNodesAtHops(CcNet, Root, HopCntV, true);
100      MxN=0; Lev=0; IncL=0; D=0; c=0;
101      for (int i = 0; i < HopCntV.Len(); i++) {
102        if (MxN<HopCntV[i].Val2) { MxN=HopCntV[i].Val2; Lev=HopCntV[i].Val1; }
103        if (i > 0 && HopCntV[i-1].Val2<=HopCntV[i].Val2) { IncL++; } }
104      D = HopCntV.Last().Val1; c=1; 
105      if (c!=0 && D!=0) { D = D/c;
106        DepthNet.AddDat(P).Add(D/M1); MxWidNet.AddDat(P).Add(MxN/M1);
107        MxLevNet.AddDat(P).Add(Lev/D); IncLevNet.AddDat(P).Add(IncL/D); }
108      }
109    }
110  };
111  PNGraph RunSICascade(PUNGraph G, const double& Beta, const int& CascSz, TIntH& NIdInfTmH);
112  PNGraph RunSICascade2(PUNGraph G, const double& Beta, const int& MxCascSz, TIntH& NIdInfTmH);
113  PNGraph AddSpuriousEdges(const PUNGraph& Graph, const PNGraph& Casc, TIntH NIdTmH);
114  int main(int argc, char* argv[]) {
115    Env = TEnv(argc, argv, TNotify::StdNotify);
116    Env.PrepArgs(TStr::Fmt("Cascades. build: %s, %s. Time: %s", __TIME__, __DATE__, TExeTm::GetCurTm()));
117    TExeTm ExeTm;
118    Try
119    const TStr InFNm = Env.GetIfArgPrefixStr("-i:", "demo", "Input undirected graph");
120    const TStr OutFNm = Env.GetIfArgPrefixStr("-o:", "demo", "Output file name prefix");
121    const double Beta = Env.GetIfArgPrefixFlt("-b:", 0.1, "Beta (infection (i.e., cascade propagation) probability)");
122    printf("Loading %s...", InFNm.CStr());
123    PUNGraph Graph;
124    if (InFNm == "demo") { Graph = TSnap::GenRndGnm<PUNGraph>(100, 200); }
125    else { Graph = TSnap::LoadEdgeList<PUNGraph>(InFNm); }
126    printf("nodes:%d  edges:%d\n", Graph->GetNodes(), Graph->GetEdges());
127    Graph = TSnap::GetMxWcc(Graph);
128    bool DivByM = true;
129    TCascadeStat CascStat;
130    printf("\nGraph:%s -- Beta: %g\n", OutFNm.CStr(), Beta);
131    for (int Run = 0; Run < 10; Run++) { 
132      TIntH NIdInfTmH;
133      PNGraph InfCasc = RunSICascade(Graph, Beta, 100, NIdInfTmH);
134      if (InfCasc->GetNodes() < 10) { printf("."); continue; } 
135      PNGraph NetCasc = AddSpuriousEdges(Graph, InfCasc, NIdInfTmH);
136      CascStat.SampleCascade(InfCasc, NetCasc, NIdInfTmH, 0.1, 10, DivByM);  
137      printf(".");
138    }
139    CascStat.PlotAll(TStr::Fmt("%s-B%03d", OutFNm.CStr(), int(100*Beta)), TStr::Fmt("%s N=%d  E=%d  Beta=%g", 
140      OutFNm.CStr(), Graph->GetNodes(), Graph->GetEdges(), Beta), DivByM);
141    Catch
142    printf("\nrun time: %s (%s)\n", ExeTm.GetTmStr(), TSecTm::GetCurTm().GetTmStr().CStr());
143    return 0;
144  }
145  void TCascadeStat::PlotAll(const TStr& OutFNm, const TStr& Desc, const bool& DivByM) {
146    const TStr MStr = DivByM ? " / M (number of observed nodes)" : "";
147    { TGnuPlot GP(TStr::Fmt("ncasc-%s", OutFNm.CStr()), Desc);
148    GP.SetXYLabel("Fraction of observed data (P)", "Number of connected components" + MStr);
149    GP.AddPlot(NCascInf, gpwLinesPoints, "Influence cascade", "lw 2",true, false, false, false, false, false);
150    GP.AddPlot(NCascNet, gpwLinesPoints, "Network cascade", "lw 2",true, false, false, false, false, false);
151    GP.SavePng(); }
152    { TGnuPlot GP(TStr::Fmt("mxSz-%s", OutFNm.CStr()), Desc);
153    GP.SetXYLabel("Fraction of observed data (P)", "Size of largest connected component" + MStr);
154    GP.AddPlot(MxSzInf, gpwLinesPoints, "Influence cascade", "lw 2",true, false, false, false, false, false);
155    GP.AddPlot(MxSzNet, gpwLinesPoints, "Network cascade", "lw 2",true, false, false, false, false, false);
156    GP.SavePng(); }
157    { TGnuPlot GP(TStr::Fmt("avgSz-%s", OutFNm.CStr()), Desc);
158    GP.SetXYLabel("Fraction of observed data (P)", "Average connected component size" + MStr);
159    GP.AddPlot(AvgSzInf, gpwLinesPoints, "Influence cascade", "lw 2",true, false, false, false, false, false);
160    GP.AddPlot(AvgSzNet, gpwLinesPoints, "Network cascade", "lw 2",true, false, false, false, false, false);
161    GP.SavePng(); }
162    { TGnuPlot GP(TStr::Fmt("nIso-%s", OutFNm.CStr()), Desc);
163    GP.SetXYLabel("Fraction of observed data (P)", "Number of isolated nodes" + MStr);
164    GP.AddPlot(NIsoInf, gpwLinesPoints, "Influence cascade", "lw 2",true, false, false, false, false, false);
165    GP.AddPlot(NIsoNet, gpwLinesPoints, "Network cascade", "lw 2",true, false, false, false, false, false);
166    GP.SavePng(); }
167    { TGnuPlot GP(TStr::Fmt("nRt-%s", OutFNm.CStr()), Desc);
168    GP.SetXYLabel("Fraction of observed data (P)", "Number of root nodes" + MStr);
169    GP.AddPlot(NRtInf, gpwLinesPoints, "Influence cascade", "lw 2",true, false, false, false, false, false);
170    GP.AddPlot(NRtNet, gpwLinesPoints, "Network cascade", "lw 2",true, false, false, false, false, false);
171    GP.SavePng(); }
172    { TGnuPlot GP(TStr::Fmt("nLf-%s", OutFNm.CStr()), Desc);
173    GP.SetXYLabel("Fraction of observed data (P)", "Number of leaves (nodes of zero out-degree)" + MStr);
174    GP.AddPlot(NLfInf, gpwLinesPoints, "Influence cascade", "lw 2",true, false, false, false, false, false);
175    GP.AddPlot(NLfNet, gpwLinesPoints, "Network cascade", "lw 2",true, false, false, false, false, false);
176    GP.SavePng(); }
177    { TGnuPlot GP(TStr::Fmt("outDeg-%s", OutFNm.CStr()), Desc);
178    GP.SetXYLabel("Fraction of observed data (P)", "Average Out-Degree (of a non-leaf)");
179    GP.AddPlot(OutDegInf, gpwLinesPoints, "Influence cascade", "lw 2",true, false, false, false, false, false);
180    GP.AddPlot(OutDegNet, gpwLinesPoints, "Network cascade", "lw 2",true, false, false, false, false, false);
181    GP.SavePng(); }
182    { TGnuPlot GP(TStr::Fmt("inDeg-%s", OutFNm.CStr()), Desc);
183    GP.SetXYLabel("Fraction of observed data (P)", "Average In-Degree (of a non-root)");
184    GP.AddPlot(InDegInf, gpwLinesPoints, "Influence cascade", "lw 2",true, false, false, false, false, false);
185    GP.AddPlot(InDegNet, gpwLinesPoints, "Network cascade", "lw 2",true, false, false, false, false, false);
186    GP.SavePng(); }
187    { TGnuPlot GP(TStr::Fmt("levels-%s", OutFNm.CStr()), Desc);
188    GP.SetXYLabel("Fraction of observed data (P)", "Average depth of largest component" + MStr);
189    GP.AddPlot(DepthInf, gpwLinesPoints, "Influence cascade", "lw 2",true, false, false, false, false, false);
190    GP.AddPlot(DepthNet, gpwLinesPoints, "Network cascade", "lw 2",true, false, false, false, false, false);
191    GP.SavePng(); }
192    { TGnuPlot GP(TStr::Fmt("width-%s", OutFNm.CStr()), Desc);
193    GP.SetXYLabel("Fraction of observed data (P)", "Width of largest components (max nodes at any level)" + MStr);
194    GP.AddPlot(MxWidInf, gpwLinesPoints, "Influence cascade", "lw 2",true, false, false, false, false, false);
195    GP.AddPlot(MxWidNet, gpwLinesPoints, "Network cascade", "lw 2",true, false, false, false, false, false);
196    GP.SavePng(); }
197    { TGnuPlot GP(TStr::Fmt("levWidth-%s", OutFNm.CStr()), Desc);
198    GP.SetXYLabel("Fraction of observed data (P)", "Level with maximum width / Depth");
199    GP.AddPlot(MxLevInf, gpwLinesPoints, "Influence cascade", "lw 2",true, false, false, false, false, false);
200    GP.AddPlot(MxLevNet, gpwLinesPoints, "Network cascade", "lw 2",true, false, false, false, false, false);
201    GP.SavePng(); }
202    { TGnuPlot GP(TStr::Fmt("levInc-%s", OutFNm.CStr()), Desc);
203    GP.SetXYLabel("Fraction of observed data (P)", "Number of levels of increasing width / Depth");
204    GP.AddPlot(IncLevInf, gpwLinesPoints, "Influence cascade", "lw 2",true, false, false, false, false, false);
205    GP.AddPlot(IncLevNet, gpwLinesPoints, "Network cascade", "lw 2",true, false, false, false, false, false);
206    GP.SavePng(); }
<span onclick='openModal()' class='match'>207  }
208  PNGraph RunSICascade(PUNGraph G, const double& Beta, const int& CascSz, TIntH& NIdInfTmH) {
209    PNGraph Casc = TNGraph::New();
210    const int StartId = G->GetRndNId();
211    Casc->AddNode(StartId);
212    NIdInfTmH.AddDat(StartId, NIdInfTmH.Len());
213    for (int X = 0; X < 10*CascSz; X++) {
</span>214      TIntV CascNIdV;  Casc->GetNIdV(CascNIdV);
215      for (int n = 0; n < CascNIdV.Len(); n++) {
216        const TUNGraph::TNodeI NI = G->GetNI(CascNIdV[n]);
217        for (int i = 0; i < NI.GetOutDeg(); i++) {
218          if (Casc->IsNode(NI.GetOutNId(i))) { continue; }
219          if (TInt::Rnd.GetUniDev() < Beta) {
220            Casc->AddNode(NI.GetOutNId(i));
221            NIdInfTmH.AddDat(NI.GetOutNId(i), NIdInfTmH.Len());
222            Casc->AddEdge(NI.GetId(), NI.GetOutNId(i));
223            if (Casc->GetNodes() == CascSz) { return Casc; }
224          }
225        }
226      }
227    }
228    return Casc;
229  }
230  PNGraph RunSICascade2(PUNGraph G, const double& Beta, const int& MxCascSz, TIntH& NIdInfTmH) {
231    PNGraph Casc = TNGraph::New();
232    const int StartNId = G->GetRndNId();
233    Casc->AddNode(StartNId);
234    NIdInfTmH.AddDat(StartNId, NIdInfTmH.Len());
235    TIntQ Q; Q.Push(StartNId);
236    while (! Q.Empty()) {
237      const TUNGraph::TNodeI NI = G->GetNI(Q.Top()); Q.Pop();
238      for (int i = 0; i < NI.GetOutDeg(); i++) {
239        if (TInt::Rnd.GetUniDev() < Beta && ! NIdInfTmH.IsKey(NI.GetOutNId(i))) {
240          Casc->AddNode(NI.GetOutNId(i));
241          NIdInfTmH.AddDat(NI.GetOutNId(i), NIdInfTmH.Len());
242          Casc->AddEdge(NI.GetId(), NI.GetOutNId(i));
243          if (Casc->GetNodes() == MxCascSz) { return Casc; }
244          Q.Push(NI.GetOutNId(i));
245        }
246      }
247    }
248    return Casc;
249  }
250  PNGraph AddSpuriousEdges(const PUNGraph& Graph, const PNGraph& Casc, TIntH NIdTmH) {
251    TIntPrV EdgeV;
252    for (TNGraph::TNodeI NI = Casc->BegNI(); NI < Casc->EndNI(); NI++) {
253      TUNGraph::TNodeI GNI = Graph->GetNI(NI.GetId());
254      const int Tm = NIdTmH.GetDat(NI.GetId());
255      for (int i=0; i < GNI.GetOutDeg(); i++) {
256        const int Dst = GNI.GetOutNId(i);
257        if (NIdTmH.IsKey(Dst) && Tm<NIdTmH.GetDat(Dst) && ! NI.IsNbrNId(Dst)) {
258          EdgeV.Add(TIntPr(GNI.GetId(), Dst)); }
259      }
260    }
261    PNGraph NetCasc = TNGraph::New();
262    *NetCasc = *Casc;
263    for (int e = 0; e < EdgeV.Len(); e++) {
264      NetCasc->AddEdge(EdgeV[e].Val1, EdgeV[e].Val2); }
265    return NetCasc;
266  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-cascades.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-cascades.cpp</div>
                </div>
                <div class="column column_space"><pre><code>207  }
208  PNGraph RunSICascade(PUNGraph G, const double& Beta, const int& CascSz, TIntH& NIdInfTmH) {
209    PNGraph Casc = TNGraph::New();
210    const int StartId = G->GetRndNId();
211    Casc->AddNode(StartId);
212    NIdInfTmH.AddDat(StartId, NIdInfTmH.Len());
213    for (int X = 0; X < 10*CascSz; X++) {
</pre></code></div>
                <div class="column column_space"><pre><code>207  }
208  PNGraph RunSICascade(PUNGraph G, const double& Beta, const int& CascSz, TIntH& NIdInfTmH) {
209    PNGraph Casc = TNGraph::New();
210    const int StartId = G->GetRndNId();
211    Casc->AddNode(StartId);
212    NIdInfTmH.AddDat(StartId, NIdInfTmH.Len());
213    for (int X = 0; X < 10*CascSz; X++) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    