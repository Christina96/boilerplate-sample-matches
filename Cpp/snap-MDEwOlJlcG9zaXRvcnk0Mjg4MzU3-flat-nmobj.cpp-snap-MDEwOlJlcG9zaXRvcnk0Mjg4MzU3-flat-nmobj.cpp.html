
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 26, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-nmobj.cpp</h3>
            <pre><code>1  #include "nmobj.h"
2  TNmObjBs::TNmObjBs(
3   const TSwSetType& SwSetType, const PSIn& CustSwSetSIn,
4   const PSIn& NrWordBsSIn, const PSIn& WordTypeBsSIn, const TStr& MteFNm):
5    ChDef(),
6    WordStrToNrH(),
7    WordStrVToNmObjAttrSetH(),
8    NmObjWordStrVToNrH(),
9    NmObjWordStrVToDocIdVH(),
10    DocNmToNmObjDocH(){
11    ChDef=THtmlLxChDef::GetChDef();
12    SwSet=TSwSet::GetSwSet(SwSetType);
13    LoadCustSwSet(CustSwSetSIn);
14    LoadNrWordBs(NrWordBsSIn);
15    LoadNmObjTypeBs(WordTypeBsSIn);
16    if (!MteFNm.Empty()){
17      }
18  }
19  TStr TNmObjBs::PeriodTagStr="<.>";
20  TStr TNmObjBs::BreakTagStr="<br>";
21  TStr TNmObjBs::ParagraphTagStr="<p>";
22  TStr TNmObjBs::EofTagStr="<eof>";
23  void TNmObjBs::LoadCustSwSet(const PSIn& SIn){
24    if (SIn.Empty()){return;}
25    TILx Lx(SIn, TFSet(iloCmtAlw, iloRetEoln, iloExcept));
26    Lx.GetSym(syLn, syEof);
27    while (Lx.Sym!=syEof){
28      TStr WordStrVStr=Lx.Str;
29      TStrV WordStrV; WordStrVStr.SplitOnWs(WordStrV);
30      if (!WordStrV.Empty()){
31        WordStrVToNmObjAttrSetH.AddDat(WordStrV).Incl(noaIgnore);
32      }
33      Lx.GetSym(syLn, syEof);
34    }
35  }
36  void TNmObjBs::LoadNrWordBs(const PSIn& SIn){
37    if (SIn.Empty()){return;}
38    TILx Lx(SIn, TFSet(iloCmtAlw, iloRetEoln, iloExcept));
39    Lx.GetSym(syQStr, syEoln, syEof);
40    while (Lx.Sym!=syEof){
41      if (Lx.Sym==syQStr){
42        TStr NrWordStr=Lx.Str;
43        Lx.GetSym(syColon);
44        Lx.GetSym(syQStr, syEoln);
45        while (Lx.Sym!=syEoln){
46          TStr WordStr=Lx.Str;
47          if (WordStrToNrH.IsKey(WordStr)){
48            printf("Word already normalized (%s)", WordStr.CStr());}
49          WordStrToNrH.AddDat(WordStr, NrWordStr);
50          Lx.GetSym(syQStr, syEoln);
51        }
52        Lx.GetSym(syQStr, syEoln, syEof);
53      } else
54      if (Lx.Sym==syEoln){
55        Lx.GetSym(syQStr, syEoln, syEof);
56      } else {
57        Fail;
58      }
59    }
60  }
61  TStr TNmObjBs::GetNrWordStr(const TStr& _WordStr) const {
62    TStr WordStr=_WordStr;
63    if (WordStr.IsChIn('_')){
64      WordStr.ChangeChAll('_', '$');
65    }
66    TStr NrWordStr;
67    if (WordStrToNrH.IsKeyGetDat(WordStr, NrWordStr)){
68      return NrWordStr;
69    } else
70    if (MteLex.Empty()){
71      return WordStr;
72    } else {
73      TStr UcWordStr=ChDef->GetUcStr(WordStr); 
74      TStr NrUcWordStr;
75      if (MteLex->IsInfWord(UcWordStr, NrUcWordStr)){
76        if (UcWordStr==NrUcWordStr){
77          return WordStr;
78        } else
79        if (IsAllCapWordStr(WordStr)){
80          return NrUcWordStr;
81        } else
82        if (IsFirstCapWordStr(WordStr)){
83          TChA NrWordChA(NrUcWordStr);
84          ChDef->GetLcChA(NrWordChA);
85          if (NrWordChA.Len()>0){
86            NrWordChA.PutCh(0, ChDef->GetUc(NrWordChA[0]));}
87          return NrWordChA;
88        } else {
89          TStr NrLcWordStr=ChDef->GetLcStr(NrUcWordStr);
90          return NrLcWordStr;
91        }
92      } else {
93        return WordStr;
94      }
95    }
96  }
97  TNmObjAttr TNmObjBs::GetNmObjTypeFromStr(const TStr& Str){
98    if (Str=="Ignore"){return noaIgnore;}
99    if (Str=="Standalone"){return noaStandalone;}
100    if (Str=="AsCapitalized"){return noaAsCapitalized;}
101    if (Str=="Unperiod"){return noaUnperiod;}
102    if (Str=="Acronym"){return noaAcronym;}
103    if (Str=="FirstName"){return noaFirstName;}
104    if (Str=="Person"){return noaPerson;}
105    if (Str=="Company"){return noaCompany;}
106    if (Str=="Organization"){return noaOrganization;}
107    if (Str=="Country"){return noaCountry;}
108    if (Str=="Geography"){return noaGeography;}
109    TExcept::Throw("Invalid Named-Object name.", Str);
110    return noaIgnore;
111  }
112  void TNmObjBs::LoadNmObjTypeBs(const PSIn& SIn){
113    if (SIn.Empty()){return;}
114    TILx Lx(SIn, TFSet(iloCmtAlw, iloRetEoln, iloExcept));
115    Lx.GetSym(syQStr, syIdStr, syEoln, syEof);
116    while (Lx.Sym!=syEof){
117      if ((Lx.Sym==syQStr)||(Lx.Sym==syIdStr)){
118        TVec<TStrV> NmObjWordStrVV;
119        TB32Set NmObjAttrSet;
120        while ((Lx.Sym==syQStr)||(Lx.Sym==syIdStr)){
121          if (Lx.Sym==syQStr){
122            TStr WordStrVStr=Lx.Str;
123            TStrV WordStrV; WordStrVStr.SplitOnWs(WordStrV);
124            NmObjWordStrVV.Add(WordStrV);
125          } else
126          if (Lx.Sym==syIdStr){
127            TNmObjAttr NmObjAttr=TNmObjBs::GetNmObjTypeFromStr(Lx.Str);
128            NmObjAttrSet.Incl(NmObjAttr);
129          } else {
130            Fail;
131          }
132          Lx.GetSym(syQStr, syIdStr, syEoln, syEof);
133        }
134        if (!NmObjAttrSet.In(noaIgnore)){
135          NmObjAttrSet.Incl(noaDefined);}
136        for (int NmObjN=0; NmObjN<NmObjWordStrVV.Len(); NmObjN++){
137          WordStrVToNmObjAttrSetH.AddDat(NmObjWordStrVV[NmObjN])|=NmObjAttrSet;
138        }
139        {for (int NmObjN=1; NmObjN<NmObjWordStrVV.Len(); NmObjN++){
140          NmObjWordStrVToNrH.AddDat(NmObjWordStrVV[NmObjN], NmObjWordStrVV[0]);
141        }}
142      } else
143      if (Lx.Sym==syEoln){
144        Lx.GetSym(syQStr, syEoln, syEof);
145      } else {
146        Fail;
147      }
148    }
149  }
150  bool TNmObjBs::IsNmObjAttr(const TStr& WordStr, const TNmObjAttr& NmObjAttr) const {
151    TStrV WordStrV; WordStrV.Add(WordStr);
152    return IsNmObjAttr(WordStrV, NmObjAttr);
153  }
154  bool TNmObjBs::IsNmObjAttr(const TStrV& WordStrV, const TNmObjAttr& NmObjAttr) const {
155    int WordStrVToNmObjAttrSetP=WordStrVToNmObjAttrSetH.GetKeyId(WordStrV);
156    if (WordStrVToNmObjAttrSetP==-1){return false;}
157    else {return WordStrVToNmObjAttrSetH[WordStrVToNmObjAttrSetP].In(NmObjAttr);}
158  }
159  bool TNmObjBs::IsFirstCapWordStr(const TStr& Str) const {
160    if (Str.Empty()){return false;}
161    char FirstCh=Str[0];
162    if (!ChDef->IsAlpha(FirstCh)){return false;}
163    if (!ChDef->IsUc(FirstCh)){return false;}
164    return true;
165  }
166  bool TNmObjBs::IsAllCapWordStr(const TStr& Str) const {
167    TChA ChA=Str;
168    for (int ChN=0; ChN<ChA.Len(); ChN++){
169      if (!ChDef->IsUc(ChA[ChN])){return false;}
170    }
171    return true;
172  }
173  bool TNmObjBs::IsNumStr(const TStr& Str) const {
174    if (Str.Empty()){return false;}
175    char FirstCh=Str[0];
176    if (!ChDef->IsNum(FirstCh)){return false;}
177    return true;
178  }
179  bool TNmObjBs::IsTagStr(const TStr& Str) const {
180    return (!Str.Empty())&&(Str[0]=='<');
181  }
182  bool TNmObjBs::IsMatchPfx(
183   const TStr& Str1, const TStr& Str2,
184   const int& MnPfxLen, const int& MxSfxLen) const {
185    TChA ChA1=Str1; TChA ChA2=Str2;
186    int ChN=0;
187    forever {
188      if (ChN>=ChA1.Len()){break;}
189      if (ChN>=ChA2.Len()){break;}
190      if (ChA1[ChN]!=ChA2[ChN]){break;}
191      ChN++;
192    }
193    if (ChN+1<=MnPfxLen){return false;}
194    if (ChA1.Len()-ChN+1>MxSfxLen){return false;}
195    if (ChA2.Len()-ChN+1>MxSfxLen){return false;}
196    return true;
197  }
198  int TNmObjBs::GetNmObjId(const TStrV& WordStrV, const bool& DefP){
199    int NmObjId=-1;
200    if (DefP){
201      NmObjId=NmObjWordStrVToDocIdVH.AddKey(WordStrV);
202    } else {
203      NmObjId=NmObjWordStrVToDocIdVH.GetKeyId(WordStrV);
204    }
205    return NmObjId;
206  }
207  TStr TNmObjBs::GetWordStrVStr(const TStrV& WordStrV, const char& SepCh) const {
208    TChA WordChA;
209    for (int WordStrN=0; WordStrN<WordStrV.Len(); WordStrN++){
210      if (WordStrN>0){WordChA+=SepCh;}
211      WordChA+=WordStrV[WordStrN];
212    }
213    return WordChA;
214  }
215  void TNmObjBs::GetNrNmObjStrV(const TStrV& NmObjStrV, TStrV& NrNmObjStrV) const {
216    int NmObjWordStrVToNrP=NmObjWordStrVToNrH.GetKeyId(NmObjStrV);
217    if (NmObjWordStrVToNrP==-1){NrNmObjStrV=NmObjStrV;}
218    else {NrNmObjStrV=NmObjWordStrVToNrH[NmObjWordStrVToNrP];}
219  }
220  void TNmObjBs::ExtrCandWordStrV(
221   const TStr& HtmlStr, TStrV& CandWordStrV, const bool& DumpP){
222    CandWordStrV.Clr();
223    PSIn HtmlSIn=TStrIn::New(HtmlStr);
224    PHtmlDoc HtmlDoc=THtmlDoc::New(HtmlSIn, hdtAll, false);
225    PHtmlTok Tok;
226    THtmlLxSym Sym; TStr Str; TStr NrStr;
227    CandWordStrV.Add(PeriodTagStr);
228    bool InTitle=false; bool InScript=false; int LastNmObjTokN=-1;
229    if (DumpP){printf("Tokens: ");}
230    for (int TokN=0; TokN<HtmlDoc->GetToks(); TokN++){
231      PHtmlTok Tok=HtmlDoc->GetTok(TokN);
232      HtmlDoc->GetTok(TokN, Sym, Str);
233      switch (Sym){
234        case hsyUndef: break;
235        case hsyStr:
236        case hsyNum:
237          if (InTitle){break;}
238          if (InScript){break;}
239          NrStr=GetNrWordStr(Str);
240          if (DumpP){
241            if (Str==NrStr){printf("%s ", Str.CStr());}
242            else {printf("%s(%s) ", Str.CStr(), NrStr.CStr());}
243          }
244          if (IsFirstCapWordStr(NrStr)||IsNmObjAttr(NrStr, noaAsCapitalized)){
245            if ((LastNmObjTokN!=-1)&&(LastNmObjTokN<TokN-1)){
246              if (CandWordStrV.Last()!=PeriodTagStr){
247                CandWordStrV.Add(BreakTagStr);
248              }
249            }
250            CandWordStrV.Add(NrStr); LastNmObjTokN=TokN;
251          }
252          break;
253        case hsySSym:
254          if (InTitle){break;}
255          if (InScript){break;}
256          if (DumpP){
257            printf("%s ", Str.CStr());}
258          if (
259           (Str==".")||(Str=="!")||(Str=="?")||
260           (Str=="\"")||(Str=="-")||(Str=="/")||
261           (Str==":")||(Str==";")){
262            if (CandWordStrV.Last()!=PeriodTagStr){
263              CandWordStrV.Add(PeriodTagStr);
264            }
265          }
266          break;
267        case hsyBTag:
268        case hsyETag:
269          if (Str=="<TITLE>"){
270            InTitle=(Sym==hsyBTag);
271          } else
272          if (Str=="<SCRIPT>"){
273            InScript=(Sym==hsyBTag);
274          } else
275          if (Str=="<P>"){
276            if ((!CandWordStrV.Empty())&&(CandWordStrV.Last()!=ParagraphTagStr)){
277              CandWordStrV.Add(ParagraphTagStr);
278              CandWordStrV.Add(PeriodTagStr);
279            }
280          } else
281          if ((Str=="<TD>")||(Str=="<BR>")){
282            CandWordStrV.Add(PeriodTagStr);
283          }
284          break;
285        case hsyEof: break;
286        default: break;
287      }
288    }
289    CandWordStrV.Add(EofTagStr);
290    if (DumpP){printf("\n");}
291    if (DumpP){
292      printf("Candidates: ");
293      for (int CandWordStrN=0; CandWordStrN<CandWordStrV.Len(); CandWordStrN++){
294        printf("%s ", CandWordStrV[CandWordStrN].CStr());}
295      printf("\n");
296    }
297  }
298  void TNmObjBs::FilterCandToNmObjIdV(
299   const TStrV& CandWordStrV, TIntV& NmObjIdV, const bool& DumpP){
300    TVec<TStrV> NmObjIdWordStrVV;
301    int CandWordStrN=0; int CandWordStrs=CandWordStrV.Len();
302    while (CandWordStrN<CandWordStrs){
303      TStr WordStr=CandWordStrV[CandWordStrN];
304      if (WordStr.Len()<=1){CandWordStrN++; continue;}
305      if (WordStr==ParagraphTagStr){CandWordStrN++; continue;}
306      if (WordStr==BreakTagStr){CandWordStrN++; continue;}
307      if (WordStr==EofTagStr){CandWordStrN++; break;}
308      if (IsNumStr(WordStr)){CandWordStrN++; continue;}
309      TStr UcWordStr=ChDef->GetUcStr(WordStr);
310      if ((WordStr==UcWordStr)&&((WordStr.Len()>4)&&(!IsNmObjAttr(WordStr, noaAcronym)))){
311        CandWordStrN++; continue;}
312      if (IsNmObjAttr(WordStr, noaUnperiod)&&(CandWordStrV[CandWordStrN+1]==PeriodTagStr)){
313        CandWordStrN+=1;
314      }
315      if (WordStr==PeriodTagStr){
316        CandWordStrN++; WordStr=CandWordStrV[CandWordStrN];
317        if (IsTagStr(WordStr)){continue;}
318        if (IsNmObjAttr(WordStr, noaDefined)){
319          continue;
320        } else 
321        if ((CandWordStrN>1)&&(IsNmObjAttr(CandWordStrV[CandWordStrN-2], noaUnperiod))){
322          continue;
323        } else {
324          TStr NextWordStr=CandWordStrV[CandWordStrN+1];
325          if (IsFirstCapWordStr(NextWordStr)||IsNmObjAttr(NextWordStr, noaAsCapitalized)){
326            continue;
327          } else 
328          if (!IsNmObj(WordStr)){
329            CandWordStrN++; continue;
330          }
331        }
332      }
333      if (IsNmObjAttr(WordStr, noaIgnore)){
334        CandWordStrN++; continue;
335      } 
336      TStrV WordStrV;
337      forever {
338        WordStrV.Add(WordStr);
339        CandWordStrN++; WordStr=CandWordStrV[CandWordStrN];
340        if (IsTagStr(WordStr)){break;}
341        if (WordStr.Len()<=1){break;}
342        if (IsNmObjAttr(WordStr, noaIgnore)){CandWordStrN++; break;}
343        if (IsNmObjAttr(WordStr, noaStandalone)){break;}
344        if (IsNmObjAttr(WordStrV, noaStandalone)){break;}
345      }
346      TStrV NrWordStrV; GetNrNmObjStrV(WordStrV, NrWordStrV);
347      if (IsNmObjAttr(NrWordStrV, noaIgnore)){continue;}
348      if (IsNmObjAttr(NrWordStrV, noaFirstName)){continue;}
349      if (NrWordStrV.Len()>5){
350        while (NrWordStrV.Len()>2){NrWordStrV.Del(0);}}
351      if (NrWordStrV.Len()==1){
352        TStr UcWordStr=ChDef->GetUcStr(NrWordStrV[0]);
353        if (SwSet->IsIn(UcWordStr, true)){continue;}
354      }
355      NmObjIdWordStrVV.Add(NrWordStrV);
356    }
357    for (int NmObjN=0; NmObjN<NmObjIdWordStrVV.Len(); NmObjN++){
358      TStrV& WordStrV=NmObjIdWordStrVV[NmObjN];
359      if (WordStrV.Len()==1){
360        for (int SubNmObjN=0; SubNmObjN<NmObjIdWordStrVV.Len(); SubNmObjN++){
361          TStrV& SubWordStrV=NmObjIdWordStrVV[SubNmObjN];
362          if (SubWordStrV.Len()==1){
363            if (WordStrV[0]!=SubWordStrV[0]){
364              if (IsMatchPfx(WordStrV[0], SubWordStrV[0], 3, 4)){
365                if (WordStrV[0].Len()<SubWordStrV[0].Len()){SubWordStrV=WordStrV;}
366                else {WordStrV=SubWordStrV;}
367              }
368            }
369          }
370        }
371      } else
372      if (WordStrV.Len()>=2){
373        TStr LastNm=WordStrV.Last();
374        for (int SubNmObjN=0; SubNmObjN<NmObjIdWordStrVV.Len(); SubNmObjN++){
375          TStrV& SubWordStrV=NmObjIdWordStrVV[SubNmObjN];
376          if (SubWordStrV.Len()==1){
377            TStr SubLastNm=SubWordStrV[0];
378            if (LastNm!=SubLastNm){
379              if (IsMatchPfx(LastNm, SubLastNm, 3, 4)){
380                if (LastNm.Len()<SubLastNm.Len()){SubWordStrV=WordStrV;} 
381                else {WordStrV=SubWordStrV;}
382              }
383            }
384          } else
385          if (false&&(SubWordStrV.Len()==2)){
386            if ((WordStrV[0]!=SubWordStrV[0])||(WordStrV[1]!=SubWordStrV[1])){
387              if ((IsMatchPfx(WordStrV[0], SubWordStrV[0], 3, 4))&&
388               (IsMatchPfx(WordStrV[1], SubWordStrV[1], 3, 4))){
389                if (WordStrV[0].Len()<SubWordStrV[0].Len()){
390                  SubWordStrV[0]=WordStrV[0];}
391                else {WordStrV[0]=SubWordStrV[0];}
392                if (WordStrV[1].Len()<SubWordStrV[1].Len()){
393                  SubWordStrV[1]=WordStrV[1];}
394                else {WordStrV[1]=SubWordStrV[1];}
395              }
396            }
397          }
398        }
399      }
400    }
401    NmObjIdV.Gen(NmObjIdWordStrVV.Len(), 0);
402    {for (int NmObjN=0; NmObjN<NmObjIdWordStrVV.Len(); NmObjN++){
403      TStrV& NmObjWordStrV=NmObjIdWordStrVV[NmObjN];
404      int NmObjId=GetNmObjId(NmObjWordStrV, true);
405      NmObjIdV.Add(NmObjId);
406    }}
407    if (DumpP){
408      printf("Named-Objects: ");
409      for (int NmObjN=0; NmObjN<NmObjIdV.Len(); NmObjN++){
410        int NmObjId=NmObjIdV[NmObjN];
411        TStr NmObjStr=GetNmObjStr(NmObjId);
412        printf("%s ", NmObjStr.CStr());
413      }
414      printf("\n");
415    }
416  }
417  PNmObjBs TNmObjBs::GetFromStrQuV(
418   const TStrQuV& IdTitleSrcHtmlQuV,
419   const TSwSetType& SwSetType, const TStr& CustSwSetFNm,
420   const TStr& NrWordBsFNm, const TStr& WordTypeBsFNm, const TStr& MteFNm,
421   const int& MxDocs, const bool& DumpP){
422    PSIn CustSwSetSIn;
423    if (!CustSwSetFNm.Empty()&&(TFile::Exists(CustSwSetFNm))){
424      CustSwSetSIn=TFIn::New(CustSwSetFNm);}
425    PSIn NrWordBsSIn;
426    if (!NrWordBsFNm.Empty()&&(TFile::Exists(NrWordBsFNm))){
427      NrWordBsSIn=TFIn::New(NrWordBsFNm);}
428    PSIn WordTypeBsSIn;
429    if (!WordTypeBsFNm.Empty()&&(TFile::Exists(WordTypeBsFNm))){
430      WordTypeBsSIn=TFIn::New(WordTypeBsFNm);}
431    PNmObjBs NmObjBs=
432     TNmObjBs::New(SwSetType, CustSwSetSIn, NrWordBsSIn, WordTypeBsSIn, MteFNm);
433    for (int DocN=0; DocN<IdTitleSrcHtmlQuV.Len(); DocN++){
434      if ((MxDocs!=-1)&&(DocN>MxDocs)){break;}
435      TStr DocNm=IdTitleSrcHtmlQuV[DocN].Val1;
436      TStr TitleStr=IdTitleSrcHtmlQuV[DocN].Val2;
437      TStr HtmlStr=IdTitleSrcHtmlQuV[DocN].Val4;
438      if (DumpP){
439        printf("===============================================\n");
440        printf("%s\n", DocNm.CStr());
441      }
442      TStrV CandWordStrV; NmObjBs->ExtrCandWordStrV(HtmlStr, CandWordStrV, DumpP);
443      TIntV NmObjIdV; NmObjBs->FilterCandToNmObjIdV(CandWordStrV, NmObjIdV, DumpP);
444      NmObjBs->AddDoc(DocNm, "", NmObjIdV);
445    }
446    TIntV NewNmObjIdV; NmObjBs->GetMergedNmObj(NewNmObjIdV);
447    NmObjBs->PutMergedNmObj(NewNmObjIdV);
448    return NmObjBs;
449  }
450  PNmObjBs TNmObjBs::GetFromCpd(
451   const PSIn& _CpdSIn,
452   const TSwSetType& SwSetType, const PSIn& CustSwSetSIn,
453   const PSIn& NrWordBsSIn, const PSIn& WordTypeBsSIn, const TStr& MteFNm,
454   const int& MxDocs, const bool& DumpP){
455    PNmObjBs NmObjBs=
456     TNmObjBs::New(SwSetType, CustSwSetSIn, NrWordBsSIn, WordTypeBsSIn, MteFNm);
457    PSIn CpdSIn=TCpDoc::FFirstCpd(_CpdSIn); PCpDoc CpDoc; int Docs=0;
458    while (TCpDoc::FNextCpd(CpdSIn, CpDoc)){
459      if ((MxDocs!=-1)&&(Docs>MxDocs)){break;}
460      TStr DocNm=CpDoc->GetDocNm();
461      TStr DateStr=CpDoc->GetDateStr();
462      TStr HtmlStr=CpDoc->GetTxtStr();
463      Docs++; printf("%d %s\r", Docs, DocNm.CStr());
464      if (DumpP){
465        printf("===============================================\n");
466        printf("%s\n", DocNm.CStr());
467      }
468      TStrV CandWordStrV; NmObjBs->ExtrCandWordStrV(HtmlStr, CandWordStrV, DumpP);
469      TIntV NmObjIdV; NmObjBs->FilterCandToNmObjIdV(CandWordStrV, NmObjIdV, DumpP);
470      NmObjBs->AddDoc(DocNm, DateStr, NmObjIdV);
471    }
472    TIntV NewNmObjIdV; NmObjBs->GetMergedNmObj(NewNmObjIdV);
473    NmObjBs->PutMergedNmObj(NewNmObjIdV);
474    return NmObjBs;
475  }
476  PNmObjBs TNmObjBs::GetFromCpd(
477   const TStr& CpdFNm,
478   const TSwSetType& SwSetType, const TStr& CustSwSetFNm,
479   const TStr& NrWordBsFNm, const TStr& WordTypeBsFNm, const TStr& MteFNm,
480   const int& MxDocs, const bool& DumpP){
481    PSIn CpdSIn=TFIn::New(CpdFNm);
482    PSIn CustSwSetSIn;
483    if (!CustSwSetFNm.Empty()&&(TFile::Exists(CustSwSetFNm))){
484      CustSwSetSIn=TFIn::New(CustSwSetFNm);}
485    PSIn NrWordBsSIn;
486    if (!NrWordBsFNm.Empty()&&(TFile::Exists(NrWordBsFNm))){
487      NrWordBsSIn=TFIn::New(NrWordBsFNm);}
488    PSIn WordTypeBsSIn;
489    if (!WordTypeBsFNm.Empty()&&(TFile::Exists(WordTypeBsFNm))){
490      WordTypeBsSIn=TFIn::New(WordTypeBsFNm);}
491    return TNmObjBs::GetFromCpd(
492     CpdSIn, SwSetType, CustSwSetSIn, NrWordBsSIn, WordTypeBsSIn, MteFNm,
493     MxDocs, DumpP);
494  }
495  void TNmObjBs::GetMergedNmObj(TIntV& NewNmObjIdV){
496    int MnPfxLen=3; int MxSfxLen=2;
497    int NmObjs=NmObjWordStrVToDocIdVH.Len();
498    NewNmObjIdV.Gen(NmObjs); NewNmObjIdV.PutAll(-1);
499    {int SingleWords=0; int ReducedSingleWords=0;
500    TStrIntVH PfxStrToNmObjIdVH;
501    for (int NmObjId=0; NmObjId<NmObjs; NmObjId++){
502      if (NewNmObjIdV[NmObjId]!=-1){continue;}
503      const TStrV& WordStrV=NmObjWordStrVToDocIdVH.GetKey(NmObjId);
504      if (WordStrV.Len()==1){
505        TStr PfxStr=WordStrV[0].GetSubStr(0, 2);
506        PfxStrToNmObjIdVH.AddDat(PfxStr).Add(NmObjId);
507        SingleWords++;
508      }
509    }
510    int Pfxs=PfxStrToNmObjIdVH.Len();
511    for (int PfxId=0; PfxId<Pfxs; PfxId++){
512      TIntV& NmObjIdV=PfxStrToNmObjIdVH[PfxId];
513      for (int NmObjIdN=0; NmObjIdN<NmObjIdV.Len(); NmObjIdN++){
514        int NmObjId=NmObjIdV[NmObjIdN];
515        if (NewNmObjIdV[NmObjId]!=-1){continue;}
516        NewNmObjIdV[NmObjId]=NmObjId;
517        const TStr& WordStr=NmObjWordStrVToDocIdVH.GetKey(NmObjId)[0];
518        int Fq=NmObjWordStrVToDocIdVH[NmObjId].Len();
519        TIntPrV FqNmObjIdPrV(NmObjIdV.Len(), 0);
520        FqNmObjIdPrV.Add(TIntPr(Fq, NmObjId));
521        for (int SubNmObjIdN=NmObjIdN+1; SubNmObjIdN<NmObjIdV.Len(); SubNmObjIdN++){
522          int SubNmObjId=NmObjIdV[SubNmObjIdN];
523          if (NewNmObjIdV[SubNmObjId]!=-1){continue;}
524          const TStr& SubWordStr=NmObjWordStrVToDocIdVH.GetKey(SubNmObjId)[0];
525          if (IsMatchPfx(WordStr, SubWordStr, MnPfxLen, MxSfxLen)){
526            NewNmObjIdV[SubNmObjId]=NmObjId;
527            int SubFq=NmObjWordStrVToDocIdVH[SubNmObjId].Len();
528            FqNmObjIdPrV.Add(TIntPr(SubFq, SubNmObjId));
529          }
530        }
531        ReducedSingleWords++;
532        if (FqNmObjIdPrV.Len()>1){
533          FqNmObjIdPrV.Sort(false);
534          int MainNmObjId=FqNmObjIdPrV[0].Val2;
535          NewNmObjIdV[MainNmObjId]=MainNmObjId;
536          TStr MainWordStr=NmObjWordStrVToDocIdVH.GetKey(MainNmObjId)[0];
537          for (int FqNmObjIdPrN=1; FqNmObjIdPrN<FqNmObjIdPrV.Len(); FqNmObjIdPrN++){
538            int SubNmObjId=FqNmObjIdPrV[FqNmObjIdPrN].Val2;
539            NewNmObjIdV[SubNmObjId]=MainNmObjId;
540          }
541        }
542      }
543    }
544    }
545    {int DoubleWords=0; int ReducedDoubleWords=0;
546    TStrIntVH PfxStrToNmObjIdVH;
547    for (int NmObjId=0; NmObjId<NmObjs; NmObjId++){
548      if (NewNmObjIdV[NmObjId]!=-1){continue;}
549      const TStrV& WordStrV=NmObjWordStrVToDocIdVH.GetKey(NmObjId);
550      if (WordStrV.Len()==2){
551        TStr PfxStr=WordStrV[0].GetSubStr(0, 2)+WordStrV[1].GetSubStr(0, 2);
552        PfxStrToNmObjIdVH.AddDat(PfxStr).Add(NmObjId);
553        DoubleWords++;
554      }
555    }
556    int Pfxs=PfxStrToNmObjIdVH.Len();
557    for (int PfxId=0; PfxId<Pfxs; PfxId++){
558      TIntV& NmObjIdV=PfxStrToNmObjIdVH[PfxId];
559      for (int NmObjIdN=0; NmObjIdN<NmObjIdV.Len(); NmObjIdN++){
560        int NmObjId=NmObjIdV[NmObjIdN];
561        if (NewNmObjIdV[NmObjId]!=-1){continue;}
562        NewNmObjIdV[NmObjId]=NmObjId;
563        const TStr& WordStr1=NmObjWordStrVToDocIdVH.GetKey(NmObjId)[0];
564        const TStr& WordStr2=NmObjWordStrVToDocIdVH.GetKey(NmObjId)[1];
565        int Fq=NmObjWordStrVToDocIdVH[NmObjId].Len();
566        TIntPrV FqNmObjIdPrV(NmObjIdV.Len(), 0);
567        FqNmObjIdPrV.Add(TIntPr(Fq, NmObjId));
568        for (int SubNmObjIdN=NmObjIdN+1; SubNmObjIdN<NmObjIdV.Len(); SubNmObjIdN++){
569          int SubNmObjId=NmObjIdV[SubNmObjIdN];
570          if (NewNmObjIdV[SubNmObjId]!=-1){continue;}
571          const TStr& SubWordStr1=NmObjWordStrVToDocIdVH.GetKey(SubNmObjId)[0];
572          const TStr& SubWordStr2=NmObjWordStrVToDocIdVH.GetKey(SubNmObjId)[1];
573          if (IsMatchPfx(WordStr1, SubWordStr1, MnPfxLen, MxSfxLen+1)&&
574           IsMatchPfx(WordStr2, SubWordStr2, MnPfxLen, MxSfxLen+1)){
575            NewNmObjIdV[SubNmObjId]=NmObjId;
576            int SubFq=NmObjWordStrVToDocIdVH[SubNmObjId].Len();
577            FqNmObjIdPrV.Add(TIntPr(SubFq, SubNmObjId));
578          }
579        }
580        ReducedDoubleWords++;
581        if (FqNmObjIdPrV.Len()>1){
582          FqNmObjIdPrV.Sort(false);
583          int MainNmObjId=FqNmObjIdPrV[0].Val2;
584          NewNmObjIdV[MainNmObjId]=MainNmObjId;
585          TStr MainWordStr1=NmObjWordStrVToDocIdVH.GetKey(MainNmObjId)[0];
586          TStr MainWordStr2=NmObjWordStrVToDocIdVH.GetKey(MainNmObjId)[1];
587          for (int FqNmObjIdPrN=1; FqNmObjIdPrN<FqNmObjIdPrV.Len(); FqNmObjIdPrN++){
588            int SubNmObjId=FqNmObjIdPrV[FqNmObjIdPrN].Val2;
589            NewNmObjIdV[SubNmObjId]=MainNmObjId;
590          }
591        }
592      }
593    }
594    }
595    {int TripleWords=0; int ReducedTripleWords=0;
596    TStrIntVH PfxStrToNmObjIdVH;
597    for (int NmObjId=0; NmObjId<NmObjs; NmObjId++){
598      if (NewNmObjIdV[NmObjId]!=-1){continue;}
599      const TStrV& WordStrV=NmObjWordStrVToDocIdVH.GetKey(NmObjId);
600      if (WordStrV.Len()==3){
601        TripleWords++;
602        TStrV DbWordStrV(2, 0);
603        DbWordStrV.Add(WordStrV[1]); DbWordStrV.Add(WordStrV[2]);
604        int DbNmObjId=NmObjWordStrVToDocIdVH.GetKeyId(DbWordStrV);
605        if (DbNmObjId!=-1){
606          ReducedTripleWords++;
607          int NewDbNmObjId=NewNmObjIdV[DbNmObjId];
608          NewNmObjIdV[NmObjId]=NewDbNmObjId;
609        }
610      }
611    }
612    }
613    {int TripleWords=0; int ReducedTripleWords=0;
614    TStrIntVH PfxStrToNmObjIdVH;
615    for (int NmObjId=0; NmObjId<NmObjs; NmObjId++){
616      if (NewNmObjIdV[NmObjId]!=-1){continue;}
617      const TStrV& WordStrV=NmObjWordStrVToDocIdVH.GetKey(NmObjId);
618      if (WordStrV.Len()==3){
619        TStr PfxStr=WordStrV[0].GetSubStr(0, 2)+WordStrV[1].GetSubStr(0, 2)+WordStrV[2].GetSubStr(0, 2);
620        PfxStrToNmObjIdVH.AddDat(PfxStr).Add(NmObjId);
621        TripleWords++;
622      }
623    }
624    int Pfxs=PfxStrToNmObjIdVH.Len();
625    for (int PfxId=0; PfxId<Pfxs; PfxId++){
626      TIntV& NmObjIdV=PfxStrToNmObjIdVH[PfxId];
627      for (int NmObjIdN=0; NmObjIdN<NmObjIdV.Len(); NmObjIdN++){
628        int NmObjId=NmObjIdV[NmObjIdN];
629        if (NewNmObjIdV[NmObjId]!=-1){continue;}
630        NewNmObjIdV[NmObjId]=NmObjId;
631        const TStr& WordStr1=NmObjWordStrVToDocIdVH.GetKey(NmObjId)[0];
632        const TStr& WordStr2=NmObjWordStrVToDocIdVH.GetKey(NmObjId)[1];
633        const TStr& WordStr3=NmObjWordStrVToDocIdVH.GetKey(NmObjId)[2];
634        int Fq=NmObjWordStrVToDocIdVH[NmObjId].Len();
635        TIntPrV FqNmObjIdPrV(NmObjIdV.Len(), 0);
636        FqNmObjIdPrV.Add(TIntPr(Fq, NmObjId));
637        for (int SubNmObjIdN=NmObjIdN+1; SubNmObjIdN<NmObjIdV.Len(); SubNmObjIdN++){
638          int SubNmObjId=NmObjIdV[SubNmObjIdN];
639          if (NewNmObjIdV[SubNmObjId]!=-1){continue;}
640          const TStr& SubWordStr1=NmObjWordStrVToDocIdVH.GetKey(SubNmObjId)[0];
641          const TStr& SubWordStr2=NmObjWordStrVToDocIdVH.GetKey(SubNmObjId)[1];
642          const TStr& SubWordStr3=NmObjWordStrVToDocIdVH.GetKey(SubNmObjId)[2];
643          if (IsMatchPfx(WordStr1, SubWordStr1, MnPfxLen, MxSfxLen+1)&&
644           IsMatchPfx(WordStr2, SubWordStr2, MnPfxLen, MxSfxLen+1)&&
645           IsMatchPfx(WordStr3, SubWordStr3, MnPfxLen, MxSfxLen+1)){
646            NewNmObjIdV[SubNmObjId]=NmObjId;
647            int SubFq=NmObjWordStrVToDocIdVH[SubNmObjId].Len();
648            FqNmObjIdPrV.Add(TIntPr(SubFq, SubNmObjId));
649          }
650        }
651        ReducedTripleWords++;
652        if (FqNmObjIdPrV.Len()>1){
653          FqNmObjIdPrV.Sort(false);
654          int MainNmObjId=FqNmObjIdPrV[0].Val2;
655          NewNmObjIdV[MainNmObjId]=MainNmObjId;
656          TStr MainWordStr1=NmObjWordStrVToDocIdVH.GetKey(MainNmObjId)[0];
657          TStr MainWordStr2=NmObjWordStrVToDocIdVH.GetKey(MainNmObjId)[1];
658          TStr MainWordStr3=NmObjWordStrVToDocIdVH.GetKey(MainNmObjId)[2];
659          for (int FqNmObjIdPrN=1; FqNmObjIdPrN<FqNmObjIdPrV.Len(); FqNmObjIdPrN++){
660            int SubNmObjId=FqNmObjIdPrV[FqNmObjIdPrN].Val2;
661            NewNmObjIdV[SubNmObjId]=MainNmObjId;
662          }
663        }
664      }
665    }
666    }
667  }
668  void TNmObjBs::PutMergedNmObj(const TIntV& NewNmObjIdV){
669    TStrVIntVH NewNmObjWordStrVToDocIdVH;
670    for (int NmObjId=0; NmObjId<NewNmObjIdV.Len(); NmObjId++){
671      if (NewNmObjIdV[NmObjId]!=NmObjId){continue;}
672      const TStrV& WordStrV=NmObjWordStrVToDocIdVH.GetKey(NmObjId);
673      NewNmObjWordStrVToDocIdVH.AddDat(WordStrV);
674    }
675    {for (int NmObjId=0; NmObjId<NewNmObjIdV.Len(); NmObjId++){
676      if (NewNmObjIdV[NmObjId]==NmObjId){continue;}
677      const TStrV& WordStrV=NmObjWordStrVToDocIdVH.GetKey(NmObjId);
678      int NrNmObjId=NewNmObjIdV[NmObjId];
679      if (NrNmObjId!=-1){
680        const TStrV& NrWordStrV=NmObjWordStrVToDocIdVH.GetKey(NrNmObjId);
681        NmObjWordStrVToNrH.AddDat(WordStrV, NrWordStrV);
682      }
683    }}
684    int Docs=GetDocs();
685    for (int DocId=0; DocId<Docs; DocId++){
686      TIntPrV& NmObjIdFqPrV=GetDoc_NmObjIdFqPrV(DocId);
687      TIntIntH NewNmObjIdToFqH(NmObjIdFqPrV.Len());
688      for (int NmObjN=0; NmObjN<NmObjIdFqPrV.Len(); NmObjN++){
689        int NmObjId=NmObjIdFqPrV[NmObjN].Val1;
690        int Fq=NmObjIdFqPrV[NmObjN].Val2;
691        int NrNmObjId=NewNmObjIdV[NmObjId];
692        if (NrNmObjId!=-1){
693          const TStrV& NrWordStrV=NmObjWordStrVToDocIdVH.GetKey(NrNmObjId);
694          int NewNmObjId=NewNmObjWordStrVToDocIdVH.GetKeyId(NrWordStrV);
695          NewNmObjIdToFqH.AddDat(NewNmObjId)+=Fq;
696        }
697      }
698      NmObjIdFqPrV.Gen(NewNmObjIdToFqH.Len(), 0);
699      for (int NmObjP=0; NmObjP<NewNmObjIdToFqH.Len(); NmObjP++){
700        int NewNmObjId=NewNmObjIdToFqH.GetKey(NmObjP);
701        int Fq=NewNmObjIdToFqH[NmObjP];
702        NmObjIdFqPrV.Add(TIntPr(NewNmObjId, Fq));
703        NewNmObjWordStrVToDocIdVH[NewNmObjId].Add(DocId);
704      }
705      NmObjIdFqPrV.Sort();
706    }
707    NmObjWordStrVToDocIdVH=NewNmObjWordStrVToDocIdVH;
708  }
709  void TNmObjBs::GetNmObjStrFqPrV(TStrIntPrV& NmObjStrFqPrV, const int& MnFq) const {
710    int NmObjs=GetNmObjs();
711    NmObjStrFqPrV.Gen(NmObjs, 0);
712    for (int NmObjId=0; NmObjId<NmObjs; NmObjId++){
713      TStrIntPr NmObjStrFqPr;
714      NmObjStrFqPr.Val1=GetNmObjStr(NmObjId);
715      NmObjStrFqPr.Val2=GetNmObjDocs(NmObjId);
716      if (NmObjStrFqPr.Val2>=MnFq){
717        NmObjStrFqPrV.Add(NmObjStrFqPr);}
718    }
719  }
720  void TNmObjBs::GetNmObjFqStrPrV(TIntStrPrV& NmObjFqStrPrV, const int& MnFq) const {
721    int NmObjs=GetNmObjs();
722    NmObjFqStrPrV.Gen(NmObjs, 0);
723    for (int NmObjId=0; NmObjId<NmObjs; NmObjId++){
724      TIntStrPr NmObjFqStrPr;
725      NmObjFqStrPr.Val1=GetNmObjDocs(NmObjId);
726      NmObjFqStrPr.Val2=GetNmObjStr(NmObjId);
727      if (NmObjFqStrPr.Val1>=MnFq){
728        NmObjFqStrPrV.Add(NmObjFqStrPr);}
729    }
730  }
731  void TNmObjBs::GetNmObjDIdV(
732   const PBowDocBs& BowDocBs, TIntV& BowDIdV, 
733   const TStr& NmObjStr1, const TStr& NmObjStr2) const {
734    int NmObjId1=GetNmObjId(NmObjStr1);
735    TIntV NmObjDocIdV1; GetNmObjDocIdV(NmObjId1, NmObjDocIdV1);
736    NmObjDocIdV1.Sort();
737    TIntV NmObjDocIdV2;
738    if (!NmObjStr2.Empty()){
739      int NmObjId2=GetNmObjId(NmObjStr2);
740      GetNmObjDocIdV(NmObjId2, NmObjDocIdV2);
741      NmObjDocIdV2.Sort();
742    }
743    TIntV NmObjDocIdV;
744    if (NmObjDocIdV2.Empty()){
745      NmObjDocIdV=NmObjDocIdV1;
746    } else {
747      NmObjDocIdV1.Intrs(NmObjDocIdV2, NmObjDocIdV);
748    }
749    BowDIdV.Gen(NmObjDocIdV.Len(), 0);
750    for (int NmObjDocIdN=0; NmObjDocIdN<NmObjDocIdV.Len(); NmObjDocIdN++){
751      TStr DocNm=GetDocNm(NmObjDocIdV[NmObjDocIdN]);
752      int DId=BowDocBs->GetDId(DocNm);
753      if (DId!=-1){
754        BowDIdV.Add(DId);
755      } 
756    }
757  }
758  PBowSpV TNmObjBs::GetNmObjConcept(
759   const PBowDocBs& BowDocBs, const PBowDocWgtBs& BowDocWgtBs,
760   const TStr& NmObjStr1, const TStr& NmObjStr2) const {
761    TIntV BowDIdV; GetNmObjDIdV(BowDocBs, BowDIdV, NmObjStr1, NmObjStr2);
762    PBowSpV ConceptSpV=TBowClust::GetConceptSpV(BowDocWgtBs, NULL, BowDIdV);
763    return ConceptSpV;
764  }
765  void TNmObjBs::GetFqNmObjIdPrV(
766   const TStr& TargetNmObjStr, TIntPrV& FqNmObjIdPrV) const {
767    int TargetNmObjId=GetNmObjId(TargetNmObjStr);
<span onclick='openModal()' class='match'>768    TIntIntH NmObjIdToFqH;
769    int NmObjDocs=GetNmObjDocs(TargetNmObjId);
770    for (int NmObjDocIdN=0; NmObjDocIdN<NmObjDocs; NmObjDocIdN++){
771      int DocId=GetNmObjDocId(TargetNmObjId, NmObjDocIdN);
</span>772      int DocNmObjs=GetDocNmObjs(DocId);
773      for (int DocNmObjN=0; DocNmObjN<DocNmObjs; DocNmObjN++){
774        int NmObjId; int TermFq;
775        GetDocNmObjId(DocId, DocNmObjN, NmObjId, TermFq);
776        NmObjIdToFqH.AddDat(NmObjId)++;
777      }
778    }
779    FqNmObjIdPrV.Clr(); NmObjIdToFqH.GetDatKeyPrV(FqNmObjIdPrV);
780    FqNmObjIdPrV.Sort(false);
781  }
782  int TNmObjBs::AddDoc(const TStr& DocNm, const TStr& DateStr, const TIntV& NmObjIdV){
783    TIntIntH NmObjIdToFqH(NmObjIdV.Len());
784    for (int NmObjN=0; NmObjN<NmObjIdV.Len(); NmObjN++){
785      int NmObjId=NmObjIdV[NmObjN];
786      NmObjIdToFqH.AddDat(NmObjId)++;
787    }
788    IAssert(!IsDoc(DocNm));
789    int DocId=DocNmToNmObjDocH.AddKey(DocNm);
790    DocNmToNmObjDocH[DocId]=TNmObjDoc::New();
791    DocNmToNmObjDocH[DocId]->DateStr=DateStr;
792    TIntPrV& NmObjIdFqPrV=GetDoc_NmObjIdFqPrV(DocId);
793    for (int NmObjP=0; NmObjP<NmObjIdToFqH.Len(); NmObjP++){
794      int NmObjId=NmObjIdToFqH.GetKey(NmObjP);
795      int Fq=NmObjIdToFqH[NmObjP];
796      NmObjIdFqPrV.Add(TIntPr(NmObjId, Fq));
797      NmObjWordStrVToDocIdVH[NmObjId].AddSorted(DocId);
798    }
799    NmObjIdFqPrV.Sort();
800    return DocId;
801  }
802  TStr TNmObjBs::GetDoc_NmObjStrVStr(const int& DocId, const char& SepCh) const {
803    TChA NmObjStrVChA;
804    TIntPrV& NmObjIdFqPrV=GetDoc_NmObjIdFqPrV(DocId);
805    for (int NmObjIdN=0; NmObjIdN<NmObjIdFqPrV.Len(); NmObjIdN++){
806      if (NmObjIdN>0){NmObjStrVChA+=SepCh;}
807      int NmObjId=NmObjIdFqPrV[NmObjIdN].Val1;
808      TStr NmObjStr=GetNmObjStr(NmObjId);
809      NmObjStrVChA+=NmObjStr;
810    }
811    return NmObjStrVChA;
812  }
813  PBowDocBs TNmObjBs::GetBowDocBs(const int& MnNmObjFq) const {
814    printf("Generating Bag-Of-Words...\n");
815    PBowDocBs BowDocBs=TBowDocBs::New();
816    for (int DocId=0; DocId<GetDocs(); DocId++){
817      if (DocId%100==0){printf("%d\r", DocId);}
818      TStr DocNm=GetDocNm(DocId);
819      TStr DateStr=GetDocDateStr(DocId);
820      TStrV WordStrV;
821      int DocNmObjs=GetDocNmObjs(DocId);
822      for (int DocNmObjN=0; DocNmObjN<DocNmObjs; DocNmObjN++){
823        int NmObjId; int TermFq; GetDocNmObjId(DocId, DocNmObjN, NmObjId, TermFq);
824        if ((MnNmObjFq==-1)||(GetNmObjDocs(NmObjId)>=MnNmObjFq)){
825          TStr NmObjStr=GetNmObjStr(NmObjId);
826          for (int TermOccN=0; TermOccN<TermFq; TermOccN++){
827            WordStrV.Add(NmObjStr);
828          }
829        }
830      }
831      if (!WordStrV.Empty()){
832        int DId=BowDocBs->AddDoc(DocNm, TStrV(), WordStrV);
833        BowDocBs->PutDateStr(DId, DateStr);
834     }
835    }
836    BowDocBs->AssertOk();
837    printf("\nDone.\n");
838    return BowDocBs;
839  }
840  PBowDocBs TNmObjBs::GetNmBowDocBs(
841   const PBowDocBs& BowDocBs, const PBowDocWgtBs& BowDocWgtBs, const int& MnNmObjFq) const {
842    int NmObjs=GetNmObjs();
843    for (int NmObjId=0; NmObjId<NmObjs; NmObjId++){
844      printf("%d/%d\r", (1+NmObjId), NmObjs);
845      TStr NmObjStr=GetNmObjStr(NmObjId);
846      PBowSpV BowSpV=GetNmObjConcept(BowDocBs, BowDocWgtBs, NmObjStr);
847    }
848    printf("\n");
849    return NULL;
850  }
851  PBowDocBs TNmObjBs::GetRelBowDocBs(const PBowDocBs& BowDocBs, const PBowDocWgtBs& BowDocWgtBs, const int& MnNmObjFq) const {
852    return NULL;
853  }
854  void TNmObjBs::SaveTxtNmObj(const TStr& FqFNm, const TStr& SwFNm,
855   const TStr& AbcFNm, const TStr& DocFNm) const {
856    TIntStrVPrV FqWordStrVPrV(NmObjWordStrVToDocIdVH.Len(), 0);
857    TStrVIntPrV WordStrVFqPrV(NmObjWordStrVToDocIdVH.Len(), 0);
858    for (int NmObjId=0; NmObjId<NmObjWordStrVToDocIdVH.Len(); NmObjId++){
859      int Fq=NmObjWordStrVToDocIdVH[NmObjId].Len();
860      const TStrV& WordStrV=NmObjWordStrVToDocIdVH.GetKey(NmObjId);
861      FqWordStrVPrV.Add(TIntStrVPr(Fq, WordStrV));
862      WordStrVFqPrV.Add(TStrVIntPr(WordStrV, Fq));
863    }
864    FqWordStrVPrV.Sort(false);
865    WordStrVFqPrV.Sort();
866    if (!FqFNm.Empty()){
867      printf("Saving by frequency to '%s' ...", FqFNm.CStr());
868      TFOut SOut(FqFNm); FILE* fOut=SOut.GetFileId();
869      for (int PrN=0; PrN<FqWordStrVPrV.Len(); PrN++){
870        int Fq=FqWordStrVPrV[PrN].Val1;
871        TStrV& WordStrV=FqWordStrVPrV[PrN].Val2;
872        TStr WordStrVStr=GetWordStrVStr(WordStrV);
873        fprintf(fOut, "%d - %s\n", Fq, WordStrVStr.CStr());
874      }
875      printf(" Done.\n");
876    }
877    if (!SwFNm.Empty()){
878      printf("Saving by frequency for stop-words proposal to '%s' ...", SwFNm.CStr());
879      TFOut SOut(SwFNm); FILE* fOut=SOut.GetFileId();
880      for (int PrN=0; PrN<FqWordStrVPrV.Len(); PrN++){
881        TStrV& WordStrV=FqWordStrVPrV[PrN].Val2;
882        TStr WordStrVStr=GetWordStrVStr(WordStrV, ' ');
883        fprintf(fOut, "%s\n", WordStrVStr.CStr());
884      }
885      printf(" Done.\n");
886    }
887    if (!AbcFNm.Empty()){
888      printf("Saving by alphabet to '%s' ...", AbcFNm.CStr());
889      TFOut SOut(AbcFNm); FILE* fOut=SOut.GetFileId();
890      for (int PrN=0; PrN<WordStrVFqPrV.Len(); PrN++){
891        TStrV& WordStrV=WordStrVFqPrV[PrN].Val1;
892        int Fq=WordStrVFqPrV[PrN].Val2;
893        TStr WordStrVStr=GetWordStrVStr(WordStrV);
894        fprintf(fOut, "%s - %d [", WordStrVStr.CStr(), Fq);
895        int NmObjId=GetNmObjId(WordStrV);
896        TIntV DocIdV;
897        GetNmObjDocIdV(NmObjId, DocIdV);
898        for (int DocIdN=0; DocIdN<DocIdV.Len(); DocIdN++){
899          TStr DocNm=GetDocNm(DocIdV[DocIdN]);
900          fprintf(fOut, "'%s' ", DocNm.CStr());
901        }
902        fprintf(fOut, "]\n");
903      }
904      printf(" Done.\n");
905    }
906    if (!DocFNm.Empty()){
907      printf("Saving by documents to '%s' ...", DocFNm.CStr());
908      TFOut SOut(DocFNm); FILE* fOut=SOut.GetFileId();
909      for (int DocId=0; DocId<GetDocs(); DocId++){
910        TStr DocNm=GetDocNm(DocId);
911        fprintf(fOut, "'%s'(%d):", DocNm.CStr(), DocId);
912        TStr DateStr=GetDocDateStr(DocId);
913        if (!DateStr.Empty()){
914          fprintf(fOut, "[%s]", DateStr.CStr());}
915        int DocNmObjs=GetDocNmObjs(DocId);
916        for (int DocNmObjN=0; DocNmObjN<DocNmObjs; DocNmObjN++){
917          int NmObjId; int TermFq; GetDocNmObjId(DocId, DocNmObjN, NmObjId, TermFq);
918          TStr NmObjStr=GetNmObjStr(NmObjId);
919          fprintf(fOut, " [%s:%d]", NmObjStr.CStr(), TermFq);
920        }
921        fprintf(fOut, "\n");
922      }
923      printf(" Done.\n");
924    }
925  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-nmobj.cpp</h3>
            <pre><code>1  #include "nmobj.h"
2  TNmObjBs::TNmObjBs(
3   const TSwSetType& SwSetType, const PSIn& CustSwSetSIn,
4   const PSIn& NrWordBsSIn, const PSIn& WordTypeBsSIn, const TStr& MteFNm):
5    ChDef(),
6    WordStrToNrH(),
7    WordStrVToNmObjAttrSetH(),
8    NmObjWordStrVToNrH(),
9    NmObjWordStrVToDocIdVH(),
10    DocNmToNmObjDocH(){
11    ChDef=THtmlLxChDef::GetChDef();
12    SwSet=TSwSet::GetSwSet(SwSetType);
13    LoadCustSwSet(CustSwSetSIn);
14    LoadNrWordBs(NrWordBsSIn);
15    LoadNmObjTypeBs(WordTypeBsSIn);
16    if (!MteFNm.Empty()){
17      }
18  }
19  TStr TNmObjBs::PeriodTagStr="<.>";
20  TStr TNmObjBs::BreakTagStr="<br>";
21  TStr TNmObjBs::ParagraphTagStr="<p>";
22  TStr TNmObjBs::EofTagStr="<eof>";
23  void TNmObjBs::LoadCustSwSet(const PSIn& SIn){
24    if (SIn.Empty()){return;}
25    TILx Lx(SIn, TFSet(iloCmtAlw, iloRetEoln, iloExcept));
26    Lx.GetSym(syLn, syEof);
27    while (Lx.Sym!=syEof){
28      TStr WordStrVStr=Lx.Str;
29      TStrV WordStrV; WordStrVStr.SplitOnWs(WordStrV);
30      if (!WordStrV.Empty()){
31        WordStrVToNmObjAttrSetH.AddDat(WordStrV).Incl(noaIgnore);
32      }
33      Lx.GetSym(syLn, syEof);
34    }
35  }
36  void TNmObjBs::LoadNrWordBs(const PSIn& SIn){
37    if (SIn.Empty()){return;}
38    TILx Lx(SIn, TFSet(iloCmtAlw, iloRetEoln, iloExcept));
39    Lx.GetSym(syQStr, syEoln, syEof);
40    while (Lx.Sym!=syEof){
41      if (Lx.Sym==syQStr){
42        TStr NrWordStr=Lx.Str;
43        Lx.GetSym(syColon);
44        Lx.GetSym(syQStr, syEoln);
45        while (Lx.Sym!=syEoln){
46          TStr WordStr=Lx.Str;
47          if (WordStrToNrH.IsKey(WordStr)){
48            printf("Word already normalized (%s)", WordStr.CStr());}
49          WordStrToNrH.AddDat(WordStr, NrWordStr);
50          Lx.GetSym(syQStr, syEoln);
51        }
52        Lx.GetSym(syQStr, syEoln, syEof);
53      } else
54      if (Lx.Sym==syEoln){
55        Lx.GetSym(syQStr, syEoln, syEof);
56      } else {
57        Fail;
58      }
59    }
60  }
61  TStr TNmObjBs::GetNrWordStr(const TStr& _WordStr) const {
62    TStr WordStr=_WordStr;
63    if (WordStr.IsChIn('_')){
64      WordStr.ChangeChAll('_', '$');
65    }
66    TStr NrWordStr;
67    if (WordStrToNrH.IsKeyGetDat(WordStr, NrWordStr)){
68      return NrWordStr;
69    } else
70    if (MteLex.Empty()){
71      return WordStr;
72    } else {
73      TStr UcWordStr=ChDef->GetUcStr(WordStr); 
74      TStr NrUcWordStr;
75      if (MteLex->IsInfWord(UcWordStr, NrUcWordStr)){
76        if (UcWordStr==NrUcWordStr){
77          return WordStr;
78        } else
79        if (IsAllCapWordStr(WordStr)){
80          return NrUcWordStr;
81        } else
82        if (IsFirstCapWordStr(WordStr)){
83          TChA NrWordChA(NrUcWordStr);
84          ChDef->GetLcChA(NrWordChA);
85          if (NrWordChA.Len()>0){
86            NrWordChA.PutCh(0, ChDef->GetUc(NrWordChA[0]));}
87          return NrWordChA;
88        } else {
89          TStr NrLcWordStr=ChDef->GetLcStr(NrUcWordStr);
90          return NrLcWordStr;
91        }
92      } else {
93        return WordStr;
94      }
95    }
96  }
97  TNmObjAttr TNmObjBs::GetNmObjTypeFromStr(const TStr& Str){
98    if (Str=="Ignore"){return noaIgnore;}
99    if (Str=="Standalone"){return noaStandalone;}
100    if (Str=="AsCapitalized"){return noaAsCapitalized;}
101    if (Str=="Unperiod"){return noaUnperiod;}
102    if (Str=="Acronym"){return noaAcronym;}
103    if (Str=="FirstName"){return noaFirstName;}
104    if (Str=="Person"){return noaPerson;}
105    if (Str=="Company"){return noaCompany;}
106    if (Str=="Organization"){return noaOrganization;}
107    if (Str=="Country"){return noaCountry;}
108    if (Str=="Geography"){return noaGeography;}
109    TExcept::Throw("Invalid Named-Object name.", Str);
110    return noaIgnore;
111  }
112  void TNmObjBs::LoadNmObjTypeBs(const PSIn& SIn){
113    if (SIn.Empty()){return;}
114    TILx Lx(SIn, TFSet(iloCmtAlw, iloRetEoln, iloExcept));
115    Lx.GetSym(syQStr, syIdStr, syEoln, syEof);
116    while (Lx.Sym!=syEof){
117      if ((Lx.Sym==syQStr)||(Lx.Sym==syIdStr)){
118        TVec<TStrV> NmObjWordStrVV;
119        TB32Set NmObjAttrSet;
120        while ((Lx.Sym==syQStr)||(Lx.Sym==syIdStr)){
121          if (Lx.Sym==syQStr){
122            TStr WordStrVStr=Lx.Str;
123            TStrV WordStrV; WordStrVStr.SplitOnWs(WordStrV);
124            NmObjWordStrVV.Add(WordStrV);
125          } else
126          if (Lx.Sym==syIdStr){
127            TNmObjAttr NmObjAttr=TNmObjBs::GetNmObjTypeFromStr(Lx.Str);
128            NmObjAttrSet.Incl(NmObjAttr);
129          } else {
130            Fail;
131          }
132          Lx.GetSym(syQStr, syIdStr, syEoln, syEof);
133        }
134        if (!NmObjAttrSet.In(noaIgnore)){
135          NmObjAttrSet.Incl(noaDefined);}
136        for (int NmObjN=0; NmObjN<NmObjWordStrVV.Len(); NmObjN++){
137          WordStrVToNmObjAttrSetH.AddDat(NmObjWordStrVV[NmObjN])|=NmObjAttrSet;
138        }
139        {for (int NmObjN=1; NmObjN<NmObjWordStrVV.Len(); NmObjN++){
140          NmObjWordStrVToNrH.AddDat(NmObjWordStrVV[NmObjN], NmObjWordStrVV[0]);
141        }}
142      } else
143      if (Lx.Sym==syEoln){
144        Lx.GetSym(syQStr, syEoln, syEof);
145      } else {
146        Fail;
147      }
148    }
149  }
150  bool TNmObjBs::IsNmObjAttr(const TStr& WordStr, const TNmObjAttr& NmObjAttr) const {
151    TStrV WordStrV; WordStrV.Add(WordStr);
152    return IsNmObjAttr(WordStrV, NmObjAttr);
153  }
154  bool TNmObjBs::IsNmObjAttr(const TStrV& WordStrV, const TNmObjAttr& NmObjAttr) const {
155    int WordStrVToNmObjAttrSetP=WordStrVToNmObjAttrSetH.GetKeyId(WordStrV);
156    if (WordStrVToNmObjAttrSetP==-1){return false;}
157    else {return WordStrVToNmObjAttrSetH[WordStrVToNmObjAttrSetP].In(NmObjAttr);}
158  }
159  bool TNmObjBs::IsFirstCapWordStr(const TStr& Str) const {
160    if (Str.Empty()){return false;}
161    char FirstCh=Str[0];
162    if (!ChDef->IsAlpha(FirstCh)){return false;}
163    if (!ChDef->IsUc(FirstCh)){return false;}
164    return true;
165  }
166  bool TNmObjBs::IsAllCapWordStr(const TStr& Str) const {
167    TChA ChA=Str;
168    for (int ChN=0; ChN<ChA.Len(); ChN++){
169      if (!ChDef->IsUc(ChA[ChN])){return false;}
170    }
171    return true;
172  }
173  bool TNmObjBs::IsNumStr(const TStr& Str) const {
174    if (Str.Empty()){return false;}
175    char FirstCh=Str[0];
176    if (!ChDef->IsNum(FirstCh)){return false;}
177    return true;
178  }
179  bool TNmObjBs::IsTagStr(const TStr& Str) const {
180    return (!Str.Empty())&&(Str[0]=='<');
181  }
182  bool TNmObjBs::IsMatchPfx(
183   const TStr& Str1, const TStr& Str2,
184   const int& MnPfxLen, const int& MxSfxLen) const {
185    TChA ChA1=Str1; TChA ChA2=Str2;
186    int ChN=0;
187    forever {
188      if (ChN>=ChA1.Len()){break;}
189      if (ChN>=ChA2.Len()){break;}
190      if (ChA1[ChN]!=ChA2[ChN]){break;}
191      ChN++;
192    }
193    if (ChN+1<=MnPfxLen){return false;}
194    if (ChA1.Len()-ChN+1>MxSfxLen){return false;}
195    if (ChA2.Len()-ChN+1>MxSfxLen){return false;}
196    return true;
197  }
198  int TNmObjBs::GetNmObjId(const TStrV& WordStrV, const bool& DefP){
199    int NmObjId=-1;
200    if (DefP){
201      NmObjId=NmObjWordStrVToDocIdVH.AddKey(WordStrV);
202    } else {
203      NmObjId=NmObjWordStrVToDocIdVH.GetKeyId(WordStrV);
204    }
205    return NmObjId;
206  }
207  TStr TNmObjBs::GetWordStrVStr(const TStrV& WordStrV, const char& SepCh) const {
208    TChA WordChA;
209    for (int WordStrN=0; WordStrN<WordStrV.Len(); WordStrN++){
210      if (WordStrN>0){WordChA+=SepCh;}
211      WordChA+=WordStrV[WordStrN];
212    }
213    return WordChA;
214  }
215  void TNmObjBs::GetNrNmObjStrV(const TStrV& NmObjStrV, TStrV& NrNmObjStrV) const {
216    int NmObjWordStrVToNrP=NmObjWordStrVToNrH.GetKeyId(NmObjStrV);
217    if (NmObjWordStrVToNrP==-1){NrNmObjStrV=NmObjStrV;}
218    else {NrNmObjStrV=NmObjWordStrVToNrH[NmObjWordStrVToNrP];}
219  }
220  void TNmObjBs::ExtrCandWordStrV(
221   const TStr& HtmlStr, TStrV& CandWordStrV, const bool& DumpP){
222    CandWordStrV.Clr();
223    PSIn HtmlSIn=TStrIn::New(HtmlStr);
224    PHtmlDoc HtmlDoc=THtmlDoc::New(HtmlSIn, hdtAll, false);
225    PHtmlTok Tok;
226    THtmlLxSym Sym; TStr Str; TStr NrStr;
227    CandWordStrV.Add(PeriodTagStr);
228    bool InTitle=false; bool InScript=false; int LastNmObjTokN=-1;
229    if (DumpP){printf("Tokens: ");}
230    for (int TokN=0; TokN<HtmlDoc->GetToks(); TokN++){
231      PHtmlTok Tok=HtmlDoc->GetTok(TokN);
232      HtmlDoc->GetTok(TokN, Sym, Str);
233      switch (Sym){
234        case hsyUndef: break;
235        case hsyStr:
236        case hsyNum:
237          if (InTitle){break;}
238          if (InScript){break;}
239          NrStr=GetNrWordStr(Str);
240          if (DumpP){
241            if (Str==NrStr){printf("%s ", Str.CStr());}
242            else {printf("%s(%s) ", Str.CStr(), NrStr.CStr());}
243          }
244          if (IsFirstCapWordStr(NrStr)||IsNmObjAttr(NrStr, noaAsCapitalized)){
245            if ((LastNmObjTokN!=-1)&&(LastNmObjTokN<TokN-1)){
246              if (CandWordStrV.Last()!=PeriodTagStr){
247                CandWordStrV.Add(BreakTagStr);
248              }
249            }
250            CandWordStrV.Add(NrStr); LastNmObjTokN=TokN;
251          }
252          break;
253        case hsySSym:
254          if (InTitle){break;}
255          if (InScript){break;}
256          if (DumpP){
257            printf("%s ", Str.CStr());}
258          if (
259           (Str==".")||(Str=="!")||(Str=="?")||
260           (Str=="\"")||(Str=="-")||(Str=="/")||
261           (Str==":")||(Str==";")){
262            if (CandWordStrV.Last()!=PeriodTagStr){
263              CandWordStrV.Add(PeriodTagStr);
264            }
265          }
266          break;
267        case hsyBTag:
268        case hsyETag:
269          if (Str=="<TITLE>"){
270            InTitle=(Sym==hsyBTag);
271          } else
272          if (Str=="<SCRIPT>"){
273            InScript=(Sym==hsyBTag);
274          } else
275          if (Str=="<P>"){
276            if ((!CandWordStrV.Empty())&&(CandWordStrV.Last()!=ParagraphTagStr)){
277              CandWordStrV.Add(ParagraphTagStr);
278              CandWordStrV.Add(PeriodTagStr);
279            }
280          } else
281          if ((Str=="<TD>")||(Str=="<BR>")){
282            CandWordStrV.Add(PeriodTagStr);
283          }
284          break;
285        case hsyEof: break;
286        default: break;
287      }
288    }
289    CandWordStrV.Add(EofTagStr);
290    if (DumpP){printf("\n");}
291    if (DumpP){
292      printf("Candidates: ");
293      for (int CandWordStrN=0; CandWordStrN<CandWordStrV.Len(); CandWordStrN++){
294        printf("%s ", CandWordStrV[CandWordStrN].CStr());}
295      printf("\n");
296    }
297  }
298  void TNmObjBs::FilterCandToNmObjIdV(
299   const TStrV& CandWordStrV, TIntV& NmObjIdV, const bool& DumpP){
300    TVec<TStrV> NmObjIdWordStrVV;
301    int CandWordStrN=0; int CandWordStrs=CandWordStrV.Len();
302    while (CandWordStrN<CandWordStrs){
303      TStr WordStr=CandWordStrV[CandWordStrN];
304      if (WordStr.Len()<=1){CandWordStrN++; continue;}
305      if (WordStr==ParagraphTagStr){CandWordStrN++; continue;}
306      if (WordStr==BreakTagStr){CandWordStrN++; continue;}
307      if (WordStr==EofTagStr){CandWordStrN++; break;}
308      if (IsNumStr(WordStr)){CandWordStrN++; continue;}
309      TStr UcWordStr=ChDef->GetUcStr(WordStr);
310      if ((WordStr==UcWordStr)&&((WordStr.Len()>4)&&(!IsNmObjAttr(WordStr, noaAcronym)))){
311        CandWordStrN++; continue;}
312      if (IsNmObjAttr(WordStr, noaUnperiod)&&(CandWordStrV[CandWordStrN+1]==PeriodTagStr)){
313        CandWordStrN+=1;
314      }
315      if (WordStr==PeriodTagStr){
316        CandWordStrN++; WordStr=CandWordStrV[CandWordStrN];
317        if (IsTagStr(WordStr)){continue;}
318        if (IsNmObjAttr(WordStr, noaDefined)){
319          continue;
320        } else 
321        if ((CandWordStrN>1)&&(IsNmObjAttr(CandWordStrV[CandWordStrN-2], noaUnperiod))){
322          continue;
323        } else {
324          TStr NextWordStr=CandWordStrV[CandWordStrN+1];
325          if (IsFirstCapWordStr(NextWordStr)||IsNmObjAttr(NextWordStr, noaAsCapitalized)){
326            continue;
327          } else 
328          if (!IsNmObj(WordStr)){
329            CandWordStrN++; continue;
330          }
331        }
332      }
333      if (IsNmObjAttr(WordStr, noaIgnore)){
334        CandWordStrN++; continue;
335      } 
336      TStrV WordStrV;
337      forever {
338        WordStrV.Add(WordStr);
339        CandWordStrN++; WordStr=CandWordStrV[CandWordStrN];
340        if (IsTagStr(WordStr)){break;}
341        if (WordStr.Len()<=1){break;}
342        if (IsNmObjAttr(WordStr, noaIgnore)){CandWordStrN++; break;}
343        if (IsNmObjAttr(WordStr, noaStandalone)){break;}
344        if (IsNmObjAttr(WordStrV, noaStandalone)){break;}
345      }
346      TStrV NrWordStrV; GetNrNmObjStrV(WordStrV, NrWordStrV);
347      if (IsNmObjAttr(NrWordStrV, noaIgnore)){continue;}
348      if (IsNmObjAttr(NrWordStrV, noaFirstName)){continue;}
349      if (NrWordStrV.Len()>5){
350        while (NrWordStrV.Len()>2){NrWordStrV.Del(0);}}
351      if (NrWordStrV.Len()==1){
352        TStr UcWordStr=ChDef->GetUcStr(NrWordStrV[0]);
353        if (SwSet->IsIn(UcWordStr, true)){continue;}
354      }
355      NmObjIdWordStrVV.Add(NrWordStrV);
356    }
357    for (int NmObjN=0; NmObjN<NmObjIdWordStrVV.Len(); NmObjN++){
358      TStrV& WordStrV=NmObjIdWordStrVV[NmObjN];
359      if (WordStrV.Len()==1){
360        for (int SubNmObjN=0; SubNmObjN<NmObjIdWordStrVV.Len(); SubNmObjN++){
361          TStrV& SubWordStrV=NmObjIdWordStrVV[SubNmObjN];
362          if (SubWordStrV.Len()==1){
363            if (WordStrV[0]!=SubWordStrV[0]){
364              if (IsMatchPfx(WordStrV[0], SubWordStrV[0], 3, 4)){
365                if (WordStrV[0].Len()<SubWordStrV[0].Len()){SubWordStrV=WordStrV;}
366                else {WordStrV=SubWordStrV;}
367              }
368            }
369          }
370        }
371      } else
372      if (WordStrV.Len()>=2){
373        TStr LastNm=WordStrV.Last();
374        for (int SubNmObjN=0; SubNmObjN<NmObjIdWordStrVV.Len(); SubNmObjN++){
375          TStrV& SubWordStrV=NmObjIdWordStrVV[SubNmObjN];
376          if (SubWordStrV.Len()==1){
377            TStr SubLastNm=SubWordStrV[0];
378            if (LastNm!=SubLastNm){
379              if (IsMatchPfx(LastNm, SubLastNm, 3, 4)){
380                if (LastNm.Len()<SubLastNm.Len()){SubWordStrV=WordStrV;} 
381                else {WordStrV=SubWordStrV;}
382              }
383            }
384          } else
385          if (false&&(SubWordStrV.Len()==2)){
386            if ((WordStrV[0]!=SubWordStrV[0])||(WordStrV[1]!=SubWordStrV[1])){
387              if ((IsMatchPfx(WordStrV[0], SubWordStrV[0], 3, 4))&&
388               (IsMatchPfx(WordStrV[1], SubWordStrV[1], 3, 4))){
389                if (WordStrV[0].Len()<SubWordStrV[0].Len()){
390                  SubWordStrV[0]=WordStrV[0];}
391                else {WordStrV[0]=SubWordStrV[0];}
392                if (WordStrV[1].Len()<SubWordStrV[1].Len()){
393                  SubWordStrV[1]=WordStrV[1];}
394                else {WordStrV[1]=SubWordStrV[1];}
395              }
396            }
397          }
398        }
399      }
400    }
401    NmObjIdV.Gen(NmObjIdWordStrVV.Len(), 0);
402    {for (int NmObjN=0; NmObjN<NmObjIdWordStrVV.Len(); NmObjN++){
403      TStrV& NmObjWordStrV=NmObjIdWordStrVV[NmObjN];
404      int NmObjId=GetNmObjId(NmObjWordStrV, true);
405      NmObjIdV.Add(NmObjId);
406    }}
407    if (DumpP){
408      printf("Named-Objects: ");
409      for (int NmObjN=0; NmObjN<NmObjIdV.Len(); NmObjN++){
410        int NmObjId=NmObjIdV[NmObjN];
411        TStr NmObjStr=GetNmObjStr(NmObjId);
412        printf("%s ", NmObjStr.CStr());
413      }
414      printf("\n");
415    }
416  }
417  PNmObjBs TNmObjBs::GetFromStrQuV(
418   const TStrQuV& IdTitleSrcHtmlQuV,
419   const TSwSetType& SwSetType, const TStr& CustSwSetFNm,
420   const TStr& NrWordBsFNm, const TStr& WordTypeBsFNm, const TStr& MteFNm,
421   const int& MxDocs, const bool& DumpP){
422    PSIn CustSwSetSIn;
423    if (!CustSwSetFNm.Empty()&&(TFile::Exists(CustSwSetFNm))){
424      CustSwSetSIn=TFIn::New(CustSwSetFNm);}
425    PSIn NrWordBsSIn;
426    if (!NrWordBsFNm.Empty()&&(TFile::Exists(NrWordBsFNm))){
427      NrWordBsSIn=TFIn::New(NrWordBsFNm);}
428    PSIn WordTypeBsSIn;
429    if (!WordTypeBsFNm.Empty()&&(TFile::Exists(WordTypeBsFNm))){
430      WordTypeBsSIn=TFIn::New(WordTypeBsFNm);}
431    PNmObjBs NmObjBs=
432     TNmObjBs::New(SwSetType, CustSwSetSIn, NrWordBsSIn, WordTypeBsSIn, MteFNm);
433    for (int DocN=0; DocN<IdTitleSrcHtmlQuV.Len(); DocN++){
434      if ((MxDocs!=-1)&&(DocN>MxDocs)){break;}
435      TStr DocNm=IdTitleSrcHtmlQuV[DocN].Val1;
436      TStr TitleStr=IdTitleSrcHtmlQuV[DocN].Val2;
437      TStr HtmlStr=IdTitleSrcHtmlQuV[DocN].Val4;
438      if (DumpP){
439        printf("===============================================\n");
440        printf("%s\n", DocNm.CStr());
441      }
442      TStrV CandWordStrV; NmObjBs->ExtrCandWordStrV(HtmlStr, CandWordStrV, DumpP);
443      TIntV NmObjIdV; NmObjBs->FilterCandToNmObjIdV(CandWordStrV, NmObjIdV, DumpP);
444      NmObjBs->AddDoc(DocNm, "", NmObjIdV);
445    }
446    TIntV NewNmObjIdV; NmObjBs->GetMergedNmObj(NewNmObjIdV);
447    NmObjBs->PutMergedNmObj(NewNmObjIdV);
448    return NmObjBs;
449  }
450  PNmObjBs TNmObjBs::GetFromCpd(
451   const PSIn& _CpdSIn,
452   const TSwSetType& SwSetType, const PSIn& CustSwSetSIn,
453   const PSIn& NrWordBsSIn, const PSIn& WordTypeBsSIn, const TStr& MteFNm,
454   const int& MxDocs, const bool& DumpP){
455    PNmObjBs NmObjBs=
456     TNmObjBs::New(SwSetType, CustSwSetSIn, NrWordBsSIn, WordTypeBsSIn, MteFNm);
457    PSIn CpdSIn=TCpDoc::FFirstCpd(_CpdSIn); PCpDoc CpDoc; int Docs=0;
458    while (TCpDoc::FNextCpd(CpdSIn, CpDoc)){
459      if ((MxDocs!=-1)&&(Docs>MxDocs)){break;}
460      TStr DocNm=CpDoc->GetDocNm();
461      TStr DateStr=CpDoc->GetDateStr();
462      TStr HtmlStr=CpDoc->GetTxtStr();
463      Docs++; printf("%d %s\r", Docs, DocNm.CStr());
464      if (DumpP){
465        printf("===============================================\n");
466        printf("%s\n", DocNm.CStr());
467      }
468      TStrV CandWordStrV; NmObjBs->ExtrCandWordStrV(HtmlStr, CandWordStrV, DumpP);
469      TIntV NmObjIdV; NmObjBs->FilterCandToNmObjIdV(CandWordStrV, NmObjIdV, DumpP);
470      NmObjBs->AddDoc(DocNm, DateStr, NmObjIdV);
471    }
472    TIntV NewNmObjIdV; NmObjBs->GetMergedNmObj(NewNmObjIdV);
473    NmObjBs->PutMergedNmObj(NewNmObjIdV);
474    return NmObjBs;
475  }
476  PNmObjBs TNmObjBs::GetFromCpd(
477   const TStr& CpdFNm,
478   const TSwSetType& SwSetType, const TStr& CustSwSetFNm,
479   const TStr& NrWordBsFNm, const TStr& WordTypeBsFNm, const TStr& MteFNm,
480   const int& MxDocs, const bool& DumpP){
481    PSIn CpdSIn=TFIn::New(CpdFNm);
482    PSIn CustSwSetSIn;
483    if (!CustSwSetFNm.Empty()&&(TFile::Exists(CustSwSetFNm))){
484      CustSwSetSIn=TFIn::New(CustSwSetFNm);}
485    PSIn NrWordBsSIn;
486    if (!NrWordBsFNm.Empty()&&(TFile::Exists(NrWordBsFNm))){
487      NrWordBsSIn=TFIn::New(NrWordBsFNm);}
488    PSIn WordTypeBsSIn;
489    if (!WordTypeBsFNm.Empty()&&(TFile::Exists(WordTypeBsFNm))){
490      WordTypeBsSIn=TFIn::New(WordTypeBsFNm);}
491    return TNmObjBs::GetFromCpd(
492     CpdSIn, SwSetType, CustSwSetSIn, NrWordBsSIn, WordTypeBsSIn, MteFNm,
493     MxDocs, DumpP);
494  }
495  void TNmObjBs::GetMergedNmObj(TIntV& NewNmObjIdV){
496    int MnPfxLen=3; int MxSfxLen=2;
497    int NmObjs=NmObjWordStrVToDocIdVH.Len();
498    NewNmObjIdV.Gen(NmObjs); NewNmObjIdV.PutAll(-1);
499    {int SingleWords=0; int ReducedSingleWords=0;
500    TStrIntVH PfxStrToNmObjIdVH;
501    for (int NmObjId=0; NmObjId<NmObjs; NmObjId++){
502      if (NewNmObjIdV[NmObjId]!=-1){continue;}
503      const TStrV& WordStrV=NmObjWordStrVToDocIdVH.GetKey(NmObjId);
504      if (WordStrV.Len()==1){
505        TStr PfxStr=WordStrV[0].GetSubStr(0, 2);
506        PfxStrToNmObjIdVH.AddDat(PfxStr).Add(NmObjId);
507        SingleWords++;
508      }
509    }
510    int Pfxs=PfxStrToNmObjIdVH.Len();
511    for (int PfxId=0; PfxId<Pfxs; PfxId++){
512      TIntV& NmObjIdV=PfxStrToNmObjIdVH[PfxId];
513      for (int NmObjIdN=0; NmObjIdN<NmObjIdV.Len(); NmObjIdN++){
514        int NmObjId=NmObjIdV[NmObjIdN];
515        if (NewNmObjIdV[NmObjId]!=-1){continue;}
516        NewNmObjIdV[NmObjId]=NmObjId;
517        const TStr& WordStr=NmObjWordStrVToDocIdVH.GetKey(NmObjId)[0];
518        int Fq=NmObjWordStrVToDocIdVH[NmObjId].Len();
519        TIntPrV FqNmObjIdPrV(NmObjIdV.Len(), 0);
520        FqNmObjIdPrV.Add(TIntPr(Fq, NmObjId));
521        for (int SubNmObjIdN=NmObjIdN+1; SubNmObjIdN<NmObjIdV.Len(); SubNmObjIdN++){
522          int SubNmObjId=NmObjIdV[SubNmObjIdN];
523          if (NewNmObjIdV[SubNmObjId]!=-1){continue;}
524          const TStr& SubWordStr=NmObjWordStrVToDocIdVH.GetKey(SubNmObjId)[0];
525          if (IsMatchPfx(WordStr, SubWordStr, MnPfxLen, MxSfxLen)){
526            NewNmObjIdV[SubNmObjId]=NmObjId;
527            int SubFq=NmObjWordStrVToDocIdVH[SubNmObjId].Len();
528            FqNmObjIdPrV.Add(TIntPr(SubFq, SubNmObjId));
529          }
530        }
531        ReducedSingleWords++;
532        if (FqNmObjIdPrV.Len()>1){
533          FqNmObjIdPrV.Sort(false);
534          int MainNmObjId=FqNmObjIdPrV[0].Val2;
535          NewNmObjIdV[MainNmObjId]=MainNmObjId;
536          TStr MainWordStr=NmObjWordStrVToDocIdVH.GetKey(MainNmObjId)[0];
537          for (int FqNmObjIdPrN=1; FqNmObjIdPrN<FqNmObjIdPrV.Len(); FqNmObjIdPrN++){
538            int SubNmObjId=FqNmObjIdPrV[FqNmObjIdPrN].Val2;
539            NewNmObjIdV[SubNmObjId]=MainNmObjId;
540          }
541        }
542      }
543    }
544    }
545    {int DoubleWords=0; int ReducedDoubleWords=0;
546    TStrIntVH PfxStrToNmObjIdVH;
547    for (int NmObjId=0; NmObjId<NmObjs; NmObjId++){
548      if (NewNmObjIdV[NmObjId]!=-1){continue;}
549      const TStrV& WordStrV=NmObjWordStrVToDocIdVH.GetKey(NmObjId);
550      if (WordStrV.Len()==2){
551        TStr PfxStr=WordStrV[0].GetSubStr(0, 2)+WordStrV[1].GetSubStr(0, 2);
552        PfxStrToNmObjIdVH.AddDat(PfxStr).Add(NmObjId);
553        DoubleWords++;
554      }
555    }
556    int Pfxs=PfxStrToNmObjIdVH.Len();
557    for (int PfxId=0; PfxId<Pfxs; PfxId++){
558      TIntV& NmObjIdV=PfxStrToNmObjIdVH[PfxId];
559      for (int NmObjIdN=0; NmObjIdN<NmObjIdV.Len(); NmObjIdN++){
560        int NmObjId=NmObjIdV[NmObjIdN];
561        if (NewNmObjIdV[NmObjId]!=-1){continue;}
562        NewNmObjIdV[NmObjId]=NmObjId;
563        const TStr& WordStr1=NmObjWordStrVToDocIdVH.GetKey(NmObjId)[0];
564        const TStr& WordStr2=NmObjWordStrVToDocIdVH.GetKey(NmObjId)[1];
565        int Fq=NmObjWordStrVToDocIdVH[NmObjId].Len();
566        TIntPrV FqNmObjIdPrV(NmObjIdV.Len(), 0);
567        FqNmObjIdPrV.Add(TIntPr(Fq, NmObjId));
568        for (int SubNmObjIdN=NmObjIdN+1; SubNmObjIdN<NmObjIdV.Len(); SubNmObjIdN++){
569          int SubNmObjId=NmObjIdV[SubNmObjIdN];
570          if (NewNmObjIdV[SubNmObjId]!=-1){continue;}
571          const TStr& SubWordStr1=NmObjWordStrVToDocIdVH.GetKey(SubNmObjId)[0];
572          const TStr& SubWordStr2=NmObjWordStrVToDocIdVH.GetKey(SubNmObjId)[1];
573          if (IsMatchPfx(WordStr1, SubWordStr1, MnPfxLen, MxSfxLen+1)&&
574           IsMatchPfx(WordStr2, SubWordStr2, MnPfxLen, MxSfxLen+1)){
575            NewNmObjIdV[SubNmObjId]=NmObjId;
576            int SubFq=NmObjWordStrVToDocIdVH[SubNmObjId].Len();
577            FqNmObjIdPrV.Add(TIntPr(SubFq, SubNmObjId));
578          }
579        }
580        ReducedDoubleWords++;
581        if (FqNmObjIdPrV.Len()>1){
582          FqNmObjIdPrV.Sort(false);
583          int MainNmObjId=FqNmObjIdPrV[0].Val2;
584          NewNmObjIdV[MainNmObjId]=MainNmObjId;
585          TStr MainWordStr1=NmObjWordStrVToDocIdVH.GetKey(MainNmObjId)[0];
586          TStr MainWordStr2=NmObjWordStrVToDocIdVH.GetKey(MainNmObjId)[1];
587          for (int FqNmObjIdPrN=1; FqNmObjIdPrN<FqNmObjIdPrV.Len(); FqNmObjIdPrN++){
588            int SubNmObjId=FqNmObjIdPrV[FqNmObjIdPrN].Val2;
589            NewNmObjIdV[SubNmObjId]=MainNmObjId;
590          }
591        }
592      }
593    }
594    }
595    {int TripleWords=0; int ReducedTripleWords=0;
596    TStrIntVH PfxStrToNmObjIdVH;
597    for (int NmObjId=0; NmObjId<NmObjs; NmObjId++){
598      if (NewNmObjIdV[NmObjId]!=-1){continue;}
599      const TStrV& WordStrV=NmObjWordStrVToDocIdVH.GetKey(NmObjId);
600      if (WordStrV.Len()==3){
601        TripleWords++;
602        TStrV DbWordStrV(2, 0);
603        DbWordStrV.Add(WordStrV[1]); DbWordStrV.Add(WordStrV[2]);
604        int DbNmObjId=NmObjWordStrVToDocIdVH.GetKeyId(DbWordStrV);
605        if (DbNmObjId!=-1){
606          ReducedTripleWords++;
607          int NewDbNmObjId=NewNmObjIdV[DbNmObjId];
608          NewNmObjIdV[NmObjId]=NewDbNmObjId;
609        }
610      }
611    }
612    }
613    {int TripleWords=0; int ReducedTripleWords=0;
614    TStrIntVH PfxStrToNmObjIdVH;
615    for (int NmObjId=0; NmObjId<NmObjs; NmObjId++){
616      if (NewNmObjIdV[NmObjId]!=-1){continue;}
617      const TStrV& WordStrV=NmObjWordStrVToDocIdVH.GetKey(NmObjId);
618      if (WordStrV.Len()==3){
619        TStr PfxStr=WordStrV[0].GetSubStr(0, 2)+WordStrV[1].GetSubStr(0, 2)+WordStrV[2].GetSubStr(0, 2);
620        PfxStrToNmObjIdVH.AddDat(PfxStr).Add(NmObjId);
621        TripleWords++;
622      }
623    }
624    int Pfxs=PfxStrToNmObjIdVH.Len();
625    for (int PfxId=0; PfxId<Pfxs; PfxId++){
626      TIntV& NmObjIdV=PfxStrToNmObjIdVH[PfxId];
627      for (int NmObjIdN=0; NmObjIdN<NmObjIdV.Len(); NmObjIdN++){
628        int NmObjId=NmObjIdV[NmObjIdN];
629        if (NewNmObjIdV[NmObjId]!=-1){continue;}
630        NewNmObjIdV[NmObjId]=NmObjId;
631        const TStr& WordStr1=NmObjWordStrVToDocIdVH.GetKey(NmObjId)[0];
632        const TStr& WordStr2=NmObjWordStrVToDocIdVH.GetKey(NmObjId)[1];
633        const TStr& WordStr3=NmObjWordStrVToDocIdVH.GetKey(NmObjId)[2];
634        int Fq=NmObjWordStrVToDocIdVH[NmObjId].Len();
635        TIntPrV FqNmObjIdPrV(NmObjIdV.Len(), 0);
636        FqNmObjIdPrV.Add(TIntPr(Fq, NmObjId));
637        for (int SubNmObjIdN=NmObjIdN+1; SubNmObjIdN<NmObjIdV.Len(); SubNmObjIdN++){
638          int SubNmObjId=NmObjIdV[SubNmObjIdN];
639          if (NewNmObjIdV[SubNmObjId]!=-1){continue;}
640          const TStr& SubWordStr1=NmObjWordStrVToDocIdVH.GetKey(SubNmObjId)[0];
641          const TStr& SubWordStr2=NmObjWordStrVToDocIdVH.GetKey(SubNmObjId)[1];
642          const TStr& SubWordStr3=NmObjWordStrVToDocIdVH.GetKey(SubNmObjId)[2];
643          if (IsMatchPfx(WordStr1, SubWordStr1, MnPfxLen, MxSfxLen+1)&&
644           IsMatchPfx(WordStr2, SubWordStr2, MnPfxLen, MxSfxLen+1)&&
645           IsMatchPfx(WordStr3, SubWordStr3, MnPfxLen, MxSfxLen+1)){
646            NewNmObjIdV[SubNmObjId]=NmObjId;
647            int SubFq=NmObjWordStrVToDocIdVH[SubNmObjId].Len();
648            FqNmObjIdPrV.Add(TIntPr(SubFq, SubNmObjId));
649          }
650        }
651        ReducedTripleWords++;
652        if (FqNmObjIdPrV.Len()>1){
653          FqNmObjIdPrV.Sort(false);
654          int MainNmObjId=FqNmObjIdPrV[0].Val2;
655          NewNmObjIdV[MainNmObjId]=MainNmObjId;
656          TStr MainWordStr1=NmObjWordStrVToDocIdVH.GetKey(MainNmObjId)[0];
657          TStr MainWordStr2=NmObjWordStrVToDocIdVH.GetKey(MainNmObjId)[1];
658          TStr MainWordStr3=NmObjWordStrVToDocIdVH.GetKey(MainNmObjId)[2];
659          for (int FqNmObjIdPrN=1; FqNmObjIdPrN<FqNmObjIdPrV.Len(); FqNmObjIdPrN++){
660            int SubNmObjId=FqNmObjIdPrV[FqNmObjIdPrN].Val2;
661            NewNmObjIdV[SubNmObjId]=MainNmObjId;
662          }
663        }
664      }
665    }
666    }
667  }
668  void TNmObjBs::PutMergedNmObj(const TIntV& NewNmObjIdV){
669    TStrVIntVH NewNmObjWordStrVToDocIdVH;
670    for (int NmObjId=0; NmObjId<NewNmObjIdV.Len(); NmObjId++){
671      if (NewNmObjIdV[NmObjId]!=NmObjId){continue;}
672      const TStrV& WordStrV=NmObjWordStrVToDocIdVH.GetKey(NmObjId);
673      NewNmObjWordStrVToDocIdVH.AddDat(WordStrV);
674    }
675    {for (int NmObjId=0; NmObjId<NewNmObjIdV.Len(); NmObjId++){
676      if (NewNmObjIdV[NmObjId]==NmObjId){continue;}
677      const TStrV& WordStrV=NmObjWordStrVToDocIdVH.GetKey(NmObjId);
678      int NrNmObjId=NewNmObjIdV[NmObjId];
679      if (NrNmObjId!=-1){
680        const TStrV& NrWordStrV=NmObjWordStrVToDocIdVH.GetKey(NrNmObjId);
681        NmObjWordStrVToNrH.AddDat(WordStrV, NrWordStrV);
682      }
683    }}
684    int Docs=GetDocs();
685    for (int DocId=0; DocId<Docs; DocId++){
686      TIntPrV& NmObjIdFqPrV=GetDoc_NmObjIdFqPrV(DocId);
687      TIntIntH NewNmObjIdToFqH(NmObjIdFqPrV.Len());
688      for (int NmObjN=0; NmObjN<NmObjIdFqPrV.Len(); NmObjN++){
689        int NmObjId=NmObjIdFqPrV[NmObjN].Val1;
690        int Fq=NmObjIdFqPrV[NmObjN].Val2;
691        int NrNmObjId=NewNmObjIdV[NmObjId];
692        if (NrNmObjId!=-1){
693          const TStrV& NrWordStrV=NmObjWordStrVToDocIdVH.GetKey(NrNmObjId);
694          int NewNmObjId=NewNmObjWordStrVToDocIdVH.GetKeyId(NrWordStrV);
695          NewNmObjIdToFqH.AddDat(NewNmObjId)+=Fq;
696        }
697      }
698      NmObjIdFqPrV.Gen(NewNmObjIdToFqH.Len(), 0);
699      for (int NmObjP=0; NmObjP<NewNmObjIdToFqH.Len(); NmObjP++){
700        int NewNmObjId=NewNmObjIdToFqH.GetKey(NmObjP);
701        int Fq=NewNmObjIdToFqH[NmObjP];
702        NmObjIdFqPrV.Add(TIntPr(NewNmObjId, Fq));
703        NewNmObjWordStrVToDocIdVH[NewNmObjId].Add(DocId);
704      }
705      NmObjIdFqPrV.Sort();
706    }
707    NmObjWordStrVToDocIdVH=NewNmObjWordStrVToDocIdVH;
708  }
709  void TNmObjBs::GetNmObjStrFqPrV(TStrIntPrV& NmObjStrFqPrV, const int& MnFq) const {
710    int NmObjs=GetNmObjs();
711    NmObjStrFqPrV.Gen(NmObjs, 0);
712    for (int NmObjId=0; NmObjId<NmObjs; NmObjId++){
713      TStrIntPr NmObjStrFqPr;
714      NmObjStrFqPr.Val1=GetNmObjStr(NmObjId);
715      NmObjStrFqPr.Val2=GetNmObjDocs(NmObjId);
716      if (NmObjStrFqPr.Val2>=MnFq){
717        NmObjStrFqPrV.Add(NmObjStrFqPr);}
718    }
719  }
720  void TNmObjBs::GetNmObjFqStrPrV(TIntStrPrV& NmObjFqStrPrV, const int& MnFq) const {
721    int NmObjs=GetNmObjs();
722    NmObjFqStrPrV.Gen(NmObjs, 0);
723    for (int NmObjId=0; NmObjId<NmObjs; NmObjId++){
724      TIntStrPr NmObjFqStrPr;
725      NmObjFqStrPr.Val1=GetNmObjDocs(NmObjId);
726      NmObjFqStrPr.Val2=GetNmObjStr(NmObjId);
727      if (NmObjFqStrPr.Val1>=MnFq){
728        NmObjFqStrPrV.Add(NmObjFqStrPr);}
729    }
730  }
731  void TNmObjBs::GetNmObjDIdV(
732   const PBowDocBs& BowDocBs, TIntV& BowDIdV, 
733   const TStr& NmObjStr1, const TStr& NmObjStr2) const {
734    int NmObjId1=GetNmObjId(NmObjStr1);
735    TIntV NmObjDocIdV1; GetNmObjDocIdV(NmObjId1, NmObjDocIdV1);
736    NmObjDocIdV1.Sort();
737    TIntV NmObjDocIdV2;
738    if (!NmObjStr2.Empty()){
739      int NmObjId2=GetNmObjId(NmObjStr2);
740      GetNmObjDocIdV(NmObjId2, NmObjDocIdV2);
741      NmObjDocIdV2.Sort();
742    }
743    TIntV NmObjDocIdV;
744    if (NmObjDocIdV2.Empty()){
745      NmObjDocIdV=NmObjDocIdV1;
746    } else {
747      NmObjDocIdV1.Intrs(NmObjDocIdV2, NmObjDocIdV);
748    }
749    BowDIdV.Gen(NmObjDocIdV.Len(), 0);
750    for (int NmObjDocIdN=0; NmObjDocIdN<NmObjDocIdV.Len(); NmObjDocIdN++){
751      TStr DocNm=GetDocNm(NmObjDocIdV[NmObjDocIdN]);
752      int DId=BowDocBs->GetDId(DocNm);
753      if (DId!=-1){
754        BowDIdV.Add(DId);
755      } 
756    }
757  }
758  PBowSpV TNmObjBs::GetNmObjConcept(
759   const PBowDocBs& BowDocBs, const PBowDocWgtBs& BowDocWgtBs,
760   const TStr& NmObjStr1, const TStr& NmObjStr2) const {
761    TIntV BowDIdV; GetNmObjDIdV(BowDocBs, BowDIdV, NmObjStr1, NmObjStr2);
762    PBowSpV ConceptSpV=TBowClust::GetConceptSpV(BowDocWgtBs, NULL, BowDIdV);
763    return ConceptSpV;
764  }
765  void TNmObjBs::GetFqNmObjIdPrV(
766   const TStr& TargetNmObjStr, TIntPrV& FqNmObjIdPrV) const {
767    int TargetNmObjId=GetNmObjId(TargetNmObjStr);
768    TIntIntH NmObjIdToFqH;
769    int NmObjDocs=GetNmObjDocs(TargetNmObjId);
770    for (int NmObjDocIdN=0; NmObjDocIdN<NmObjDocs; NmObjDocIdN++){
771      int DocId=GetNmObjDocId(TargetNmObjId, NmObjDocIdN);
772      int DocNmObjs=GetDocNmObjs(DocId);
773      for (int DocNmObjN=0; DocNmObjN<DocNmObjs; DocNmObjN++){
774        int NmObjId; int TermFq;
775        GetDocNmObjId(DocId, DocNmObjN, NmObjId, TermFq);
776        NmObjIdToFqH.AddDat(NmObjId)++;
777      }
778    }
779    FqNmObjIdPrV.Clr(); NmObjIdToFqH.GetDatKeyPrV(FqNmObjIdPrV);
780    FqNmObjIdPrV.Sort(false);
781  }
782  int TNmObjBs::AddDoc(const TStr& DocNm, const TStr& DateStr, const TIntV& NmObjIdV){
783    TIntIntH NmObjIdToFqH(NmObjIdV.Len());
784    for (int NmObjN=0; NmObjN<NmObjIdV.Len(); NmObjN++){
785      int NmObjId=NmObjIdV[NmObjN];
786      NmObjIdToFqH.AddDat(NmObjId)++;
787    }
788    IAssert(!IsDoc(DocNm));
789    int DocId=DocNmToNmObjDocH.AddKey(DocNm);
790    DocNmToNmObjDocH[DocId]=TNmObjDoc::New();
791    DocNmToNmObjDocH[DocId]->DateStr=DateStr;
792    TIntPrV& NmObjIdFqPrV=GetDoc_NmObjIdFqPrV(DocId);
793    for (int NmObjP=0; NmObjP<NmObjIdToFqH.Len(); NmObjP++){
794      int NmObjId=NmObjIdToFqH.GetKey(NmObjP);
795      int Fq=NmObjIdToFqH[NmObjP];
796      NmObjIdFqPrV.Add(TIntPr(NmObjId, Fq));
797      NmObjWordStrVToDocIdVH[NmObjId].AddSorted(DocId);
798    }
799    NmObjIdFqPrV.Sort();
800    return DocId;
801  }
802  TStr TNmObjBs::GetDoc_NmObjStrVStr(const int& DocId, const char& SepCh) const {
803    TChA NmObjStrVChA;
804    TIntPrV& NmObjIdFqPrV=GetDoc_NmObjIdFqPrV(DocId);
805    for (int NmObjIdN=0; NmObjIdN<NmObjIdFqPrV.Len(); NmObjIdN++){
806      if (NmObjIdN>0){NmObjStrVChA+=SepCh;}
807      int NmObjId=NmObjIdFqPrV[NmObjIdN].Val1;
808      TStr NmObjStr=GetNmObjStr(NmObjId);
809      NmObjStrVChA+=NmObjStr;
810    }
811    return NmObjStrVChA;
812  }
813  PBowDocBs TNmObjBs::GetBowDocBs(const int& MnNmObjFq) const {
814    printf("Generating Bag-Of-Words...\n");
815    PBowDocBs BowDocBs=TBowDocBs::New();
816    for (int DocId=0; DocId<GetDocs(); DocId++){
817      if (DocId%100==0){printf("%d\r", DocId);}
818      TStr DocNm=GetDocNm(DocId);
819      TStr DateStr=GetDocDateStr(DocId);
<span onclick='openModal()' class='match'>820      TStrV WordStrV;
821      int DocNmObjs=GetDocNmObjs(DocId);
822      for (int DocNmObjN=0; DocNmObjN<DocNmObjs; DocNmObjN++){
823        int NmObjId; int TermFq; GetDocNmObjId(DocId, DocNmObjN, NmObjId, TermFq);
</span>824        if ((MnNmObjFq==-1)||(GetNmObjDocs(NmObjId)>=MnNmObjFq)){
825          TStr NmObjStr=GetNmObjStr(NmObjId);
826          for (int TermOccN=0; TermOccN<TermFq; TermOccN++){
827            WordStrV.Add(NmObjStr);
828          }
829        }
830      }
831      if (!WordStrV.Empty()){
832        int DId=BowDocBs->AddDoc(DocNm, TStrV(), WordStrV);
833        BowDocBs->PutDateStr(DId, DateStr);
834     }
835    }
836    BowDocBs->AssertOk();
837    printf("\nDone.\n");
838    return BowDocBs;
839  }
840  PBowDocBs TNmObjBs::GetNmBowDocBs(
841   const PBowDocBs& BowDocBs, const PBowDocWgtBs& BowDocWgtBs, const int& MnNmObjFq) const {
842    int NmObjs=GetNmObjs();
843    for (int NmObjId=0; NmObjId<NmObjs; NmObjId++){
844      printf("%d/%d\r", (1+NmObjId), NmObjs);
845      TStr NmObjStr=GetNmObjStr(NmObjId);
846      PBowSpV BowSpV=GetNmObjConcept(BowDocBs, BowDocWgtBs, NmObjStr);
847    }
848    printf("\n");
849    return NULL;
850  }
851  PBowDocBs TNmObjBs::GetRelBowDocBs(const PBowDocBs& BowDocBs, const PBowDocWgtBs& BowDocWgtBs, const int& MnNmObjFq) const {
852    return NULL;
853  }
854  void TNmObjBs::SaveTxtNmObj(const TStr& FqFNm, const TStr& SwFNm,
855   const TStr& AbcFNm, const TStr& DocFNm) const {
856    TIntStrVPrV FqWordStrVPrV(NmObjWordStrVToDocIdVH.Len(), 0);
857    TStrVIntPrV WordStrVFqPrV(NmObjWordStrVToDocIdVH.Len(), 0);
858    for (int NmObjId=0; NmObjId<NmObjWordStrVToDocIdVH.Len(); NmObjId++){
859      int Fq=NmObjWordStrVToDocIdVH[NmObjId].Len();
860      const TStrV& WordStrV=NmObjWordStrVToDocIdVH.GetKey(NmObjId);
861      FqWordStrVPrV.Add(TIntStrVPr(Fq, WordStrV));
862      WordStrVFqPrV.Add(TStrVIntPr(WordStrV, Fq));
863    }
864    FqWordStrVPrV.Sort(false);
865    WordStrVFqPrV.Sort();
866    if (!FqFNm.Empty()){
867      printf("Saving by frequency to '%s' ...", FqFNm.CStr());
868      TFOut SOut(FqFNm); FILE* fOut=SOut.GetFileId();
869      for (int PrN=0; PrN<FqWordStrVPrV.Len(); PrN++){
870        int Fq=FqWordStrVPrV[PrN].Val1;
871        TStrV& WordStrV=FqWordStrVPrV[PrN].Val2;
872        TStr WordStrVStr=GetWordStrVStr(WordStrV);
873        fprintf(fOut, "%d - %s\n", Fq, WordStrVStr.CStr());
874      }
875      printf(" Done.\n");
876    }
877    if (!SwFNm.Empty()){
878      printf("Saving by frequency for stop-words proposal to '%s' ...", SwFNm.CStr());
879      TFOut SOut(SwFNm); FILE* fOut=SOut.GetFileId();
880      for (int PrN=0; PrN<FqWordStrVPrV.Len(); PrN++){
881        TStrV& WordStrV=FqWordStrVPrV[PrN].Val2;
882        TStr WordStrVStr=GetWordStrVStr(WordStrV, ' ');
883        fprintf(fOut, "%s\n", WordStrVStr.CStr());
884      }
885      printf(" Done.\n");
886    }
887    if (!AbcFNm.Empty()){
888      printf("Saving by alphabet to '%s' ...", AbcFNm.CStr());
889      TFOut SOut(AbcFNm); FILE* fOut=SOut.GetFileId();
890      for (int PrN=0; PrN<WordStrVFqPrV.Len(); PrN++){
891        TStrV& WordStrV=WordStrVFqPrV[PrN].Val1;
892        int Fq=WordStrVFqPrV[PrN].Val2;
893        TStr WordStrVStr=GetWordStrVStr(WordStrV);
894        fprintf(fOut, "%s - %d [", WordStrVStr.CStr(), Fq);
895        int NmObjId=GetNmObjId(WordStrV);
896        TIntV DocIdV;
897        GetNmObjDocIdV(NmObjId, DocIdV);
898        for (int DocIdN=0; DocIdN<DocIdV.Len(); DocIdN++){
899          TStr DocNm=GetDocNm(DocIdV[DocIdN]);
900          fprintf(fOut, "'%s' ", DocNm.CStr());
901        }
902        fprintf(fOut, "]\n");
903      }
904      printf(" Done.\n");
905    }
906    if (!DocFNm.Empty()){
907      printf("Saving by documents to '%s' ...", DocFNm.CStr());
908      TFOut SOut(DocFNm); FILE* fOut=SOut.GetFileId();
909      for (int DocId=0; DocId<GetDocs(); DocId++){
910        TStr DocNm=GetDocNm(DocId);
911        fprintf(fOut, "'%s'(%d):", DocNm.CStr(), DocId);
912        TStr DateStr=GetDocDateStr(DocId);
913        if (!DateStr.Empty()){
914          fprintf(fOut, "[%s]", DateStr.CStr());}
915        int DocNmObjs=GetDocNmObjs(DocId);
916        for (int DocNmObjN=0; DocNmObjN<DocNmObjs; DocNmObjN++){
917          int NmObjId; int TermFq; GetDocNmObjId(DocId, DocNmObjN, NmObjId, TermFq);
918          TStr NmObjStr=GetNmObjStr(NmObjId);
919          fprintf(fOut, " [%s:%d]", NmObjStr.CStr(), TermFq);
920        }
921        fprintf(fOut, "\n");
922      }
923      printf(" Done.\n");
924    }
925  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-nmobj.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-nmobj.cpp</div>
                </div>
                <div class="column column_space"><pre><code>768    TIntIntH NmObjIdToFqH;
769    int NmObjDocs=GetNmObjDocs(TargetNmObjId);
770    for (int NmObjDocIdN=0; NmObjDocIdN<NmObjDocs; NmObjDocIdN++){
771      int DocId=GetNmObjDocId(TargetNmObjId, NmObjDocIdN);
</pre></code></div>
                <div class="column column_space"><pre><code>820      TStrV WordStrV;
821      int DocNmObjs=GetDocNmObjs(DocId);
822      for (int DocNmObjN=0; DocNmObjN<DocNmObjs; DocNmObjN++){
823        int NmObjId; int TermFq; GetDocNmObjId(DocId, DocNmObjN, NmObjId, TermFq);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    