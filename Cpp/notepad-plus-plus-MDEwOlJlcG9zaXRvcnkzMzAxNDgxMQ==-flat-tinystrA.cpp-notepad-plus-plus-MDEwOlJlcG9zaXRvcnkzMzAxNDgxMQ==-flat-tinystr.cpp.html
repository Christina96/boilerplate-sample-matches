
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 14, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-tinystrA.cpp</h3>
            <pre><code>1  #include "tinyxmlA.h"
2  #ifndef TIXMLA_USE_STL
3  #include "tinystrA.h"
4  TiXmlStringA::TiXmlStringA (const char* instring)
5  {
6      unsigned newlen;
7      char * newstring;
8      if (!instring)
9      {
10          allocated = 0;
11          cstring = NULL;
12          current_length = 0;
13          return;
14      }
15      newlen = strlen (instring) + 1;
16      newstring = new char [newlen];
17      memcpy (newstring, instring, newlen);
18      allocated = newlen;
19      cstring = newstring;
20      current_length = newlen - 1;
21  }
22  TiXmlStringA::TiXmlStringA (const TiXmlStringA& copy)
23  {
24      unsigned newlen;
25      char * newstring;
26  	if ( &copy == this )
27  		return;
28      if (! copy . allocated)
29      {
30          allocated = 0;
31          cstring = NULL;
32          current_length = 0;
33          return;
34      }
35      newlen = copy . length () + 1;
36      newstring = new char [newlen];
37      memcpy (newstring, copy . cstring, newlen);
38      allocated = newlen;
39      cstring = newstring;
40      current_length = newlen - 1;
41  }
42  void TiXmlStringA ::operator = (const char * content)
43  {
44      unsigned newlen;
45      char * newstring;
46      if (! content)
47      {
48          empty_it ();
49          return;
50      }
51      newlen = strlen (content) + 1;
52      newstring = new char [newlen];
53      memcpy (newstring, content, newlen);
54      empty_it ();
55      allocated = newlen;
56      cstring = newstring;
57      current_length = newlen - 1;
58  }
59  void TiXmlStringA ::operator = (const TiXmlStringA & copy)
60  {
61      unsigned newlen;
62      char * newstring;
63      if (! copy . length ())
64      {
65          empty_it ();
66          return;
67      }
68      newlen = copy . length () + 1;
69      newstring = new char [newlen];
70      memcpy (newstring, copy . c_str (), newlen);
71      empty_it ();
72      allocated = newlen;
73      cstring = newstring;
74      current_length = newlen - 1;
75  }
76  void TiXmlStringA::append( const char* str, int len )
77  {
78      char * new_string;
79      unsigned new_alloc, new_size, size_suffix;
80      size_suffix = strlen (str);
81      if (len < (int) size_suffix)
82          size_suffix = len;
83      if (! size_suffix)
84          return;
85      new_size = length () + size_suffix + 1;
86      if (new_size > allocated)
87      {
88          new_alloc = assign_new_size (new_size);
89          new_string = new char [new_alloc];        
90          new_string [0] = 0;
91          if (allocated && cstring)
92              memcpy (new_string, cstring, length ());
93          memcpy (new_string + length (), 
94                  str,
95                  size_suffix);
96          if (allocated && cstring)
97              delete [] cstring;
98          cstring = new_string;
99          allocated = new_alloc;
100      }
101      else
102      {
103          memcpy (cstring + length (), 
104                  str,
105                  size_suffix);
106      }
107      current_length = new_size - 1;
108      cstring [current_length] = 0;
109  }
110  void TiXmlStringA::append( const char * suffix )
111  {
112      char * new_string;
113      unsigned new_alloc, new_size;
114      new_size = length () + strlen (suffix) + 1;
115      if (new_size > allocated)
116      {
117          new_alloc = assign_new_size (new_size);
118          new_string = new char [new_alloc];        
119          new_string [0] = 0;
120          if (allocated && cstring)
121              memcpy (new_string, cstring, 1 + length ());
122          memcpy (new_string + length (), 
123                  suffix,
124                  strlen (suffix) + 1);
125          if (allocated && cstring)
<span onclick='openModal()' class='match'>126              delete [] cstring;
127          cstring = new_string;
128          allocated = new_alloc;
129      }
130      else
</span>131      {
132          memcpy (cstring + length (), 
133                  suffix, 
134                  strlen (suffix) + 1);
135      }
136      current_length = new_size - 1;
137  }
138  unsigned TiXmlStringA::find (char tofind, unsigned offset) const
139  {
140      char * lookup;
141      if (offset >= length ())
142          return (unsigned) notfound;
143      for (lookup = cstring + offset; * lookup; lookup++)
144          if (* lookup == tofind)
145              return lookup - cstring;
146      return (unsigned) notfound;
147  }
148  bool TiXmlStringA::operator == (const TiXmlStringA & compare) const
149  {
150  	if ( allocated && compare.allocated )
151  	{
152  		assert( cstring );
153  		assert( compare.cstring );
154  		return ( strcmp( cstring, compare.cstring ) == 0 );
155   	}
156  	return false;
157  }
158  bool TiXmlStringA::operator < (const TiXmlStringA & compare) const
159  {
160  	if ( allocated && compare.allocated )
161  	{
162  		assert( cstring );
163  		assert( compare.cstring );
164  		return ( strcmp( cstring, compare.cstring ) > 0 );
165   	}
166  	return false;
167  }
168  bool TiXmlStringA::operator > (const TiXmlStringA & compare) const
169  {
170  	if ( allocated && compare.allocated )
171  	{
172  		assert( cstring );
173  		assert( compare.cstring );
174  		return ( strcmp( cstring, compare.cstring ) < 0 );
175   	}
176  	return false;
177  }
178  #endif	
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-tinystr.cpp</h3>
            <pre><code>1  #ifndef TIXML_USE_STL
2  #include "tinystr.h"
3  TiXmlString::TiXmlString (const TCHAR* instring)
4  {
5      unsigned newlen;
6      TCHAR * newstring;
7      if (!instring)
8      {
9          allocated = 0;
10          cstring = NULL;
11          current_length = 0;
12          return;
13      }
14      newlen = lstrlen (instring) + 1;
15      newstring = new TCHAR [newlen];
16      memcpy (newstring, instring, newlen);
17      allocated = newlen;
18      cstring = newstring;
19      current_length = newlen - 1;
20  }
21  TiXmlString::TiXmlString (const TiXmlString& copy)
22  {
23      unsigned newlen;
24      TCHAR * newstring;
25  	if ( &copy == this )
26  		return;
27      if (! copy . allocated)
28      {
29          allocated = 0;
30          cstring = NULL;
31          current_length = 0;
32          return;
33      }
34      newlen = copy . length () + 1;
35      newstring = new TCHAR [newlen];
36      memcpy (newstring, copy . cstring, newlen);
37      allocated = newlen;
38      cstring = newstring;
39      current_length = newlen - 1;
40  }
41  void TiXmlString ::operator = (const TCHAR * content)
42  {
43      unsigned newlen;
44      TCHAR * newstring;
45      if (! content)
46      {
47          empty_it ();
48          return;
49      }
50      newlen = lstrlen (content) + 1;
51      newstring = new TCHAR [newlen];
52      memcpy (newstring, content, newlen);
53      empty_it ();
54      allocated = newlen;
55      cstring = newstring;
56      current_length = newlen - 1;
57  }
58  void TiXmlString ::operator = (const TiXmlString & copy)
59  {
60      unsigned newlen;
61      TCHAR * newstring;
62      if (! copy . length ())
63      {
64          empty_it ();
65          return;
66      }
67      newlen = copy . length () + 1;
68      newstring = new TCHAR [newlen];
69      memcpy (newstring, copy . c_str (), newlen);
70      empty_it ();
71      allocated = newlen;
72      cstring = newstring;
73      current_length = newlen - 1;
74  }
75  void TiXmlString::append( const TCHAR* str, int len )
76  {
77      TCHAR * new_string;
78      unsigned new_alloc, new_size, size_suffix;
79      size_suffix = lstrlen (str);
80      if (len < (int) size_suffix)
81          size_suffix = len;
82      if (! size_suffix)
83          return;
84      new_size = length () + size_suffix + 1;
85      if (new_size > allocated)
86      {
87          new_alloc = assign_new_size (new_size);
88          new_string = new TCHAR [new_alloc];        
89          new_string [0] = 0;
90          if (allocated && cstring)
91              memcpy (new_string, cstring, length ());
92          memcpy (new_string + length (), 
93                  str,
94                  size_suffix);
95          if (allocated && cstring)
96              delete [] cstring;
97          cstring = new_string;
98          allocated = new_alloc;
99      }
100      else
101      {
102          memcpy (cstring + length (), 
103                  str,
104                  size_suffix);
105      }
106      current_length = new_size - 1;
107      cstring [current_length] = 0;
108  }
109  void TiXmlString::append( const TCHAR * suffix )
110  {
111      TCHAR * new_string;
112      unsigned new_alloc, new_size;
113      new_size = length () + lstrlen (suffix) + 1;
114      if (new_size > allocated)
115      {
116          new_alloc = assign_new_size (new_size);
117          new_string = new TCHAR [new_alloc];        
118          new_string [0] = 0;
119          if (allocated && cstring)
120              memcpy (new_string, cstring, 1 + length ());
121          memcpy (new_string + length (), 
122                  suffix,
123                  lstrlen (suffix) + 1);
124          if (allocated && cstring)
<span onclick='openModal()' class='match'>125              delete [] cstring;
126          cstring = new_string;
127          allocated = new_alloc;
128      }
129      else
</span>130      {
131          memcpy (cstring + length (), 
132                  suffix, 
133                  lstrlen (suffix) + 1);
134      }
135      current_length = new_size - 1;
136  }
137  unsigned TiXmlString::find (TCHAR tofind, unsigned offset) const
138  {
139      TCHAR * lookup;
140      if (offset >= length ())
141          return (unsigned) notfound;
142      for (lookup = cstring + offset; * lookup; lookup++)
143          if (* lookup == tofind)
144              return lookup - cstring;
145      return (unsigned) notfound;
146  }
147  bool TiXmlString::operator == (const TiXmlString & compare) const
148  {
149  	if ( allocated && compare.allocated )
150  	{
151  		assert( cstring );
152  		assert( compare.cstring );
153  		return ( lstrcmp( cstring, compare.cstring ) == 0 );
154   	}
155  	return false;
156  }
157  bool TiXmlString::operator < (const TiXmlString & compare) const
158  {
159  	if ( allocated && compare.allocated )
160  	{
161  		assert( cstring );
162  		assert( compare.cstring );
163  		return ( lstrcmp( cstring, compare.cstring ) > 0 );
164   	}
165  	return false;
166  }
167  bool TiXmlString::operator > (const TiXmlString & compare) const
168  {
169  	if ( allocated && compare.allocated )
170  	{
171  		assert( cstring );
172  		assert( compare.cstring );
173  		return ( lstrcmp( cstring, compare.cstring ) < 0 );
174   	}
175  	return false;
176  }
177  #endif	
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-tinystrA.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-tinystr.cpp</div>
                </div>
                <div class="column column_space"><pre><code>126              delete [] cstring;
127          cstring = new_string;
128          allocated = new_alloc;
129      }
130      else
</pre></code></div>
                <div class="column column_space"><pre><code>125              delete [] cstring;
126          cstring = new_string;
127          allocated = new_alloc;
128      }
129      else
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    