
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 17, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexTADS3.cxx</h3>
            <pre><code>1  #include &lt;stdlib.h&gt;
2  #include &lt;string.h&gt;
3  #include &lt;stdio.h&gt;
4  #include &lt;stdarg.h&gt;
5  #include &lt;assert.h&gt;
6  #include &lt;ctype.h&gt;
7  #include &lt;string&gt;
8  #include &lt;string_view&gt;
9  #include &quot;ILexer.h&quot;
10  #include &quot;Scintilla.h&quot;
11  #include &quot;SciLexer.h&quot;
12  #include &quot;WordList.h&quot;
13  #include &quot;LexAccessor.h&quot;
14  #include &quot;Accessor.h&quot;
15  #include &quot;StyleContext.h&quot;
16  #include &quot;CharacterSet.h&quot;
17  #include &quot;LexerModule.h&quot;
18  using namespace Lexilla;
19  static const int T3_SINGLE_QUOTE = 1;
20  static const int T3_INT_EXPRESSION = 2;
21  static const int T3_INT_EXPRESSION_IN_TAG = 4;
22  static const int T3_HTML_SQUOTE = 8;
23  static inline bool IsEOL(const int ch, const int chNext) {
24          return (ch == &#x27;\r&#x27; &amp;&amp; chNext != &#x27;\n&#x27;) || (ch == &#x27;\n&#x27;);
25  }
26  static inline bool IsEOLSkip(StyleContext &amp;sc)
27  {
28      if (sc.ch == &#x27;\r&#x27; &amp;&amp; sc.chNext == &#x27;\n&#x27;)
29      {
30          sc.Forward();
31          return true;
32      }
33      return IsEOL(sc.ch, sc.chNext);
34  }
35  static inline bool IsATADS3Operator(const int ch) {
36          return ch == &#x27;=&#x27; || ch == &#x27;{&#x27; || ch == &#x27;}&#x27; || ch == &#x27;(&#x27; || ch == &#x27;)&#x27;
37                  || ch == &#x27;[&#x27; || ch == &#x27;]&#x27; || ch == &#x27;,&#x27; || ch == &#x27;:&#x27; || ch == &#x27;;&#x27;
38                  || ch == &#x27;+&#x27; || ch == &#x27;-&#x27; || ch == &#x27;*&#x27; || ch == &#x27;/&#x27; || ch == &#x27;%&#x27;
39                  || ch == &#x27;?&#x27; || ch == &#x27;!&#x27; || ch == &#x27;&lt;&#x27; || ch == &#x27;&gt;&#x27; || ch == &#x27;|&#x27;
40                  || ch == &#x27;@&#x27; || ch == &#x27;&amp;&#x27; || ch == &#x27;~&#x27;;
41  }
42  static inline bool IsAWordChar(const int ch) {
43          return isalnum(ch) || ch == &#x27;_&#x27;;
44  }
45  static inline bool IsAWordStart(const int ch) {
46          return isalpha(ch) || ch == &#x27;_&#x27;;
47  }
48  static inline bool IsAHexDigit(const int ch) {
49          int lch = tolower(ch);
50          return isdigit(lch) || lch == &#x27;a&#x27; || lch == &#x27;b&#x27; || lch == &#x27;c&#x27;
51                  || lch == &#x27;d&#x27; || lch == &#x27;e&#x27; || lch == &#x27;f&#x27;;
52  }
53  static inline bool IsAnHTMLChar(int ch) {
54          return isalnum(ch) || ch == &#x27;-&#x27; || ch == &#x27;_&#x27; || ch == &#x27;.&#x27;;
55  }
56  static inline bool IsADirectiveChar(int ch) {
57          return isalnum(ch) || isspace(ch) || ch == &#x27;-&#x27; || ch == &#x27;/&#x27;;
58  }
59  static inline bool IsANumberStart(StyleContext &amp;sc) {
60          return isdigit(sc.ch)
61                  || (!isdigit(sc.chPrev) &amp;&amp; sc.ch == &#x27;.&#x27; &amp;&amp; isdigit(sc.chNext));
62  }
63  inline static void ColouriseTADS3Operator(StyleContext &amp;sc) {
64          int initState = sc.state;
65          int c = sc.ch;
66          sc.SetState(c == &#x27;{&#x27; || c == &#x27;}&#x27; ? SCE_T3_BRACE : SCE_T3_OPERATOR);
67          sc.ForwardSetState(initState);
68  }
69  static void ColouriseTADSHTMLString(StyleContext &amp;sc, int &amp;lineState) {
70          int endState = sc.state;
71          int chQuote = sc.ch;
72          int chString = (lineState &amp; T3_SINGLE_QUOTE) ? &#x27;\&#x27;&#x27; : &#x27;&quot;&#x27;;
73          if (endState == SCE_T3_HTML_STRING) {
74                  if (lineState&amp;T3_SINGLE_QUOTE) {
75                          endState = SCE_T3_S_STRING;
76                          chString = &#x27;\&#x27;&#x27;;
77                  } else if (lineState&amp;T3_INT_EXPRESSION) {
78                          endState = SCE_T3_X_STRING;
79                          chString = &#x27;&quot;&#x27;;
80                  } else {
81                          endState = SCE_T3_HTML_DEFAULT;
82                          chString = &#x27;&quot;&#x27;;
83                  }
84                  chQuote = (lineState &amp; T3_HTML_SQUOTE) ? &#x27;\&#x27;&#x27; : &#x27;&quot;&#x27;;
85          } else {
86                  sc.SetState(SCE_T3_HTML_STRING);
87                  sc.Forward();
88          }
89          if (chQuote == &#x27;&quot;&#x27;)
90                  lineState &amp;= ~T3_HTML_SQUOTE;
91          else
92                  lineState |= T3_HTML_SQUOTE;
93          while (sc.More()) {
94                  if (IsEOL(sc.ch, sc.chNext)) {
95                          return;
96                  }
97                  if (sc.ch == chQuote) {
98                          sc.ForwardSetState(endState);
99                          return;
100                  }
101                  if (sc.Match(&#x27;\\&#x27;, static_cast&lt;char&gt;(chQuote))) {
102                          sc.Forward(2);
103                          sc.SetState(endState);
104                          return;
105                  }
106                  if (sc.ch == chString) {
107                          sc.SetState(SCE_T3_DEFAULT);
108                          return;
109                  }
110                  if (sc.Match(&#x27;&lt;&#x27;, &#x27;&lt;&#x27;)) {
111                          lineState |= T3_INT_EXPRESSION | T3_INT_EXPRESSION_IN_TAG;
112                          sc.SetState(SCE_T3_X_DEFAULT);
113                          sc.Forward(2);
114                          return;
115                  }
116                  if (sc.Match(&#x27;\\&#x27;, static_cast&lt;char&gt;(chQuote))
117                          || sc.Match(&#x27;\\&#x27;, static_cast&lt;char&gt;(chString))
118                          || sc.Match(&#x27;\\&#x27;, &#x27;\\&#x27;)) {
119                          sc.Forward(2);
120                  } else {
121                          sc.Forward();
122                  }
123          }
124  }
125  static void ColouriseTADS3HTMLTagStart(StyleContext &amp;sc) {
126          sc.SetState(SCE_T3_HTML_TAG);
127          sc.Forward();
128          if (sc.ch == &#x27;/&#x27;) {
129                  sc.Forward();
130          }
131          while (IsAnHTMLChar(sc.ch)) {
132                  sc.Forward();
133          }
134  }
135  static void ColouriseTADS3HTMLTag(StyleContext &amp;sc, int &amp;lineState) {
136          int endState = sc.state;
137          int chQuote = &#x27;&quot;&#x27;;
138          int chString = &#x27;\&#x27;&#x27;;
139          switch (endState) {
140                  case SCE_T3_S_STRING:
141                          ColouriseTADS3HTMLTagStart(sc);
142                          sc.SetState(SCE_T3_HTML_DEFAULT);
143                          chQuote = &#x27;\&#x27;&#x27;;
144                          chString = &#x27;&quot;&#x27;;
145                          break;
146                  case SCE_T3_D_STRING:
147                  case SCE_T3_X_STRING:
148                          ColouriseTADS3HTMLTagStart(sc);
149                          sc.SetState(SCE_T3_HTML_DEFAULT);
150                          break;
151                  case SCE_T3_HTML_DEFAULT:
152                          if (lineState&amp;T3_SINGLE_QUOTE) {
153                                  endState = SCE_T3_S_STRING;
154                                  chQuote = &#x27;\&#x27;&#x27;;
155                                  chString = &#x27;&quot;&#x27;;
156                          } else if (lineState&amp;T3_INT_EXPRESSION) {
157                                  endState = SCE_T3_X_STRING;
158                          } else {
159                                  endState = SCE_T3_D_STRING;
160                          }
161                          break;
162          }
163          while (sc.More()) {
164                  if (IsEOL(sc.ch, sc.chNext)) {
165                          return;
166                  }
167                  if (sc.Match(&#x27;/&#x27;, &#x27;&gt;&#x27;)) {
168                          sc.SetState(SCE_T3_HTML_TAG);
169                          sc.Forward(2);
170                          sc.SetState(endState);
171                          return;
172                  }
173                  if (sc.ch == &#x27;&gt;&#x27;) {
174                          sc.SetState(SCE_T3_HTML_TAG);
175                          sc.ForwardSetState(endState);
176                          return;
177                  }
178                  if (sc.ch == chQuote) {
179                          sc.SetState(endState);
180                          return;
181                  }
182                  if (sc.Match(&#x27;\\&#x27;, static_cast&lt;char&gt;(chQuote))) {
183                          sc.Forward();
184                          ColouriseTADSHTMLString(sc, lineState);
185                          if (sc.state == SCE_T3_X_DEFAULT)
186                              break;
187                  } else if (sc.ch == chString) {
188                          ColouriseTADSHTMLString(sc, lineState);
189                  } else if (sc.ch == &#x27;=&#x27;) {
190                          ColouriseTADS3Operator(sc);
191                  } else {
192                          sc.Forward();
193                  }
194          }
195  }
196  static void ColouriseTADS3Keyword(StyleContext &amp;sc,
197                                                          WordList *keywordlists[],       Sci_PositionU endPos) {
198          char s[250];
199          WordList &amp;keywords = *keywordlists[0];
200          WordList &amp;userwords1 = *keywordlists[1];
201          WordList &amp;userwords2 = *keywordlists[2];
202          WordList &amp;userwords3 = *keywordlists[3];
203          int initState = sc.state;
204          sc.SetState(SCE_T3_IDENTIFIER);
205          while (sc.More() &amp;&amp; (IsAWordChar(sc.ch))) {
206                  sc.Forward();
207          }
208          sc.GetCurrent(s, sizeof(s));
209          if ( strcmp(s, &quot;is&quot;) == 0 || strcmp(s, &quot;not&quot;) == 0) {
210                  Sci_Position n = 1;
211                  while (n + sc.currentPos &lt; endPos &amp;&amp; IsASpaceOrTab(sc.GetRelative(n)))
212                          n++;
213                  if (sc.GetRelative(n) == &#x27;i&#x27; &amp;&amp; sc.GetRelative(n+1) == &#x27;n&#x27;) {
214                          sc.Forward(n+2);
215                          sc.ChangeState(SCE_T3_KEYWORD);
216                  }
217          } else if (keywords.InList(s)) {
218                  sc.ChangeState(SCE_T3_KEYWORD);
219          } else if (userwords3.InList(s)) {
220                  sc.ChangeState(SCE_T3_USER3);
221          } else if (userwords2.InList(s)) {
222                  sc.ChangeState(SCE_T3_USER2);
223          } else if (userwords1.InList(s)) {
224                  sc.ChangeState(SCE_T3_USER1);
225          }
226          sc.SetState(initState);
227  }
228  static void ColouriseTADS3MsgParam(StyleContext &amp;sc, int &amp;lineState) {
229          int endState = sc.state;
230          int chQuote = &#x27;&quot;&#x27;;
231          switch (endState) {
232                  case SCE_T3_S_STRING:
233                          sc.SetState(SCE_T3_MSG_PARAM);
234                          sc.Forward();
235                          chQuote = &#x27;\&#x27;&#x27;;
236                          break;
237                  case SCE_T3_D_STRING:
238                  case SCE_T3_X_STRING:
239                          sc.SetState(SCE_T3_MSG_PARAM);
240                          sc.Forward();
241                          break;
242                  case SCE_T3_MSG_PARAM:
243                          if (lineState&amp;T3_SINGLE_QUOTE) {
244                                  endState = SCE_T3_S_STRING;
245                                  chQuote = &#x27;\&#x27;&#x27;;
246                          } else if (lineState&amp;T3_INT_EXPRESSION) {
247                                  endState = SCE_T3_X_STRING;
248                          } else {
249                                  endState = SCE_T3_D_STRING;
250                          }
251                          break;
252          }
253          while (sc.More() &amp;&amp; sc.ch != &#x27;}&#x27; &amp;&amp; sc.ch != chQuote) {
254                  if (IsEOL(sc.ch, sc.chNext)) {
255                          return;
256                  }
257                  if (sc.ch == &#x27;\\&#x27;) {
258                          sc.Forward();
259                  }
260                  sc.Forward();
261          }
262          if (sc.ch == chQuote) {
263                  sc.SetState(endState);
264          } else {
265                  sc.ForwardSetState(endState);
266          }
267  }
268  static void ColouriseTADS3LibDirective(StyleContext &amp;sc, int &amp;lineState) {
269          int initState = sc.state;
270          int chQuote = &#x27;&quot;&#x27;;
271          switch (initState) {
272                  case SCE_T3_S_STRING:
273                          sc.SetState(SCE_T3_LIB_DIRECTIVE);
274                          sc.Forward(2);
275                          chQuote = &#x27;\&#x27;&#x27;;
276                          break;
277                  case SCE_T3_D_STRING:
278                          sc.SetState(SCE_T3_LIB_DIRECTIVE);
279                          sc.Forward(2);
280                          break;
281                  case SCE_T3_LIB_DIRECTIVE:
282                          if (lineState&amp;T3_SINGLE_QUOTE) {
283                                  initState = SCE_T3_S_STRING;
284                                  chQuote = &#x27;\&#x27;&#x27;;
285                          } else {
286                                  initState = SCE_T3_D_STRING;
287                          }
288                          break;
289          }
290          while (sc.More() &amp;&amp; IsADirectiveChar(sc.ch)) {
291                  if (IsEOL(sc.ch, sc.chNext)) {
292                          return;
293                  }
294                  sc.Forward();
295          };
296          if (sc.ch == &#x27;&gt;&#x27; || !sc.More()) {
297                  sc.ForwardSetState(initState);
298          } else if (sc.ch == chQuote) {
299                  sc.SetState(initState);
300          } else {
301                  sc.ChangeState(initState);
302                  sc.Forward();
303          }
304  }
305  static void ColouriseTADS3String(StyleContext &amp;sc, int &amp;lineState) {
306          int chQuote = sc.ch;
<span onclick='openModal()' class='match'>307          int endState = sc.state;
308          switch (sc.state) {
309                  case SCE_T3_DEFAULT:
310                  case SCE_T3_X_DEFAULT:
</span>311                          if (chQuote == &#x27;&quot;&#x27;) {
312                                  if (sc.state == SCE_T3_DEFAULT) {
313                                          sc.SetState(SCE_T3_D_STRING);
314                                  } else {
315                                          sc.SetState(SCE_T3_X_STRING);
316                                  }
317                                  lineState &amp;= ~T3_SINGLE_QUOTE;
318                          } else {
319                                  sc.SetState(SCE_T3_S_STRING);
320                                  lineState |= T3_SINGLE_QUOTE;
321                          }
322                          sc.Forward();
323                          break;
324                  case SCE_T3_S_STRING:
325                          chQuote = &#x27;\&#x27;&#x27;;
326                          endState = lineState&amp;T3_INT_EXPRESSION ?
327                                  SCE_T3_X_DEFAULT : SCE_T3_DEFAULT;
328                          break;
329                  case SCE_T3_D_STRING:
330                          chQuote = &#x27;&quot;&#x27;;
331                          endState = SCE_T3_DEFAULT;
332                          break;
333                  case SCE_T3_X_STRING:
334                          chQuote = &#x27;&quot;&#x27;;
335                          endState = SCE_T3_X_DEFAULT;
336                          break;
337          }
338          while (sc.More()) {
339                  if (IsEOL(sc.ch, sc.chNext)) {
340                          return;
341                  }
342                  if (sc.ch == chQuote) {
343                          sc.ForwardSetState(endState);
344                          return;
345                  }
346                  if (sc.state == SCE_T3_D_STRING &amp;&amp; sc.Match(&#x27;&lt;&#x27;, &#x27;&lt;&#x27;)) {
347                          lineState |= T3_INT_EXPRESSION;
348                          sc.SetState(SCE_T3_X_DEFAULT);
349                          sc.Forward(2);
350                          return;
351                  }
352                  if (sc.Match(&#x27;\\&#x27;, static_cast&lt;char&gt;(chQuote))
353                      || sc.Match(&#x27;\\&#x27;, &#x27;\\&#x27;)) {
354                          sc.Forward(2);
355                  } else if (sc.ch == &#x27;{&#x27;) {
356                          ColouriseTADS3MsgParam(sc, lineState);
357                  } else if (sc.Match(&#x27;&lt;&#x27;, &#x27;.&#x27;)) {
358                          ColouriseTADS3LibDirective(sc, lineState);
359                  } else if (sc.ch == &#x27;&lt;&#x27;) {
360                          ColouriseTADS3HTMLTag(sc, lineState);
361                          if (sc.state == SCE_T3_X_DEFAULT)
362                                  return;
363                  } else {
364                          sc.Forward();
365                  }
366          }
367  }
368  static void ColouriseTADS3Comment(StyleContext &amp;sc, int endState) {
369          sc.SetState(SCE_T3_BLOCK_COMMENT);
370          while (sc.More()) {
371                  if (IsEOL(sc.ch, sc.chNext)) {
372                          return;
373                  }
374                  if (sc.Match(&#x27;*&#x27;, &#x27;/&#x27;)) {
375                          sc.Forward(2);
376                          sc.SetState(endState);
377                          return;
378                  }
379                  sc.Forward();
380          }
381  }
382  static void ColouriseToEndOfLine(StyleContext &amp;sc, int initState, int endState) {
383          sc.SetState(initState);
384          while (sc.More()) {
385                  if (sc.ch == &#x27;\\&#x27;) {
386                          sc.Forward();
387                          if (IsEOLSkip(sc)) {
388                                          return;
389                          }
390                  }
391                  if (IsEOL(sc.ch, sc.chNext)) {
392                          sc.SetState(endState);
393                          return;
394                  }
395                  sc.Forward();
396          }
397  }
398  static void ColouriseTADS3Number(StyleContext &amp;sc) {
399          int endState = sc.state;
400          bool inHexNumber = false;
401          bool seenE = false;
402          bool seenDot = sc.ch == &#x27;.&#x27;;
403          sc.SetState(SCE_T3_NUMBER);
404          if (sc.More()) {
405                  sc.Forward();
406          }
407          if (sc.chPrev == &#x27;0&#x27; &amp;&amp; tolower(sc.ch) == &#x27;x&#x27;) {
408                  inHexNumber = true;
409                  sc.Forward();
410          }
411          while (sc.More()) {
412                  if (inHexNumber) {
413                          if (!IsAHexDigit(sc.ch)) {
414                                  break;
415                          }
416                  } else if (!isdigit(sc.ch)) {
417                          if (!seenE &amp;&amp; tolower(sc.ch) == &#x27;e&#x27;) {
418                                  seenE = true;
419                                  seenDot = true;
420                                  if (sc.chNext == &#x27;+&#x27; || sc.chNext == &#x27;-&#x27;) {
421                                          sc.Forward();
422                                  }
423                          } else if (!seenDot &amp;&amp; sc.ch == &#x27;.&#x27;) {
424                                  seenDot = true;
425                          } else {
426                                  break;
427                          }
428                  }
429                  sc.Forward();
430          }
431          sc.SetState(endState);
432  }
433  static void ColouriseTADS3Doc(Sci_PositionU startPos, Sci_Position length, int initStyle,
434                                                             WordList *keywordlists[], Accessor &amp;styler) {
435          int visibleChars = 0;
436          int bracketLevel = 0;
437          int lineState = 0;
438          Sci_PositionU endPos = startPos + length;
439          Sci_Position lineCurrent = styler.GetLine(startPos);
440          if (lineCurrent &gt; 0) {
441                  lineState = styler.GetLineState(lineCurrent-1);
442          }
443          StyleContext sc(startPos, length, initStyle, styler);
444          while (sc.More()) {
445                  if (IsEOL(sc.ch, sc.chNext)) {
446                          styler.SetLineState(lineCurrent, lineState);
447                          lineCurrent++;
448                          visibleChars = 0;
449                          sc.Forward();
450                          if (sc.ch == &#x27;\n&#x27;) {
451                                  sc.Forward();
452                          }
453                  }
454                  switch(sc.state) {
455                          case SCE_T3_PREPROCESSOR:
456                          case SCE_T3_LINE_COMMENT:
457                                  ColouriseToEndOfLine(sc, sc.state, lineState&amp;T3_INT_EXPRESSION ?
458                                          SCE_T3_X_DEFAULT : SCE_T3_DEFAULT);
459                                  break;
460                          case SCE_T3_S_STRING:
461                          case SCE_T3_D_STRING:
462                          case SCE_T3_X_STRING:
463                                  ColouriseTADS3String(sc, lineState);
464                                  visibleChars++;
465                                  break;
466                          case SCE_T3_MSG_PARAM:
467                                  ColouriseTADS3MsgParam(sc, lineState);
468                                  break;
469                          case SCE_T3_LIB_DIRECTIVE:
470                                  ColouriseTADS3LibDirective(sc, lineState);
471                                  break;
472                          case SCE_T3_HTML_DEFAULT:
473                                  ColouriseTADS3HTMLTag(sc, lineState);
474                                  break;
475                          case SCE_T3_HTML_STRING:
476                                  ColouriseTADSHTMLString(sc, lineState);
477                                  break;
478                          case SCE_T3_BLOCK_COMMENT:
479                                  ColouriseTADS3Comment(sc, lineState&amp;T3_INT_EXPRESSION ?
480                                          SCE_T3_X_DEFAULT : SCE_T3_DEFAULT);
481                                  break;
482                          case SCE_T3_DEFAULT:
483                          case SCE_T3_X_DEFAULT:
484                                  if (IsASpaceOrTab(sc.ch)) {
485                                          sc.Forward();
486                                  } else if (sc.ch == &#x27;#&#x27; &amp;&amp; visibleChars == 0) {
487                                          ColouriseToEndOfLine(sc, SCE_T3_PREPROCESSOR, sc.state);
488                                  } else if (sc.Match(&#x27;/&#x27;, &#x27;*&#x27;)) {
489                                          ColouriseTADS3Comment(sc, sc.state);
490                                          visibleChars++;
491                                  } else if (sc.Match(&#x27;/&#x27;, &#x27;/&#x27;)) {
492                                          ColouriseToEndOfLine(sc, SCE_T3_LINE_COMMENT, sc.state);
493                                  } else if (sc.ch == &#x27;&quot;&#x27;) {
494                                          bracketLevel = 0;
495                                          ColouriseTADS3String(sc, lineState);
496                                          visibleChars++;
497                                  } else if (sc.ch == &#x27;\&#x27;&#x27;) {
498                                          ColouriseTADS3String(sc, lineState);
499                                          visibleChars++;
500                                  } else if (sc.state == SCE_T3_X_DEFAULT &amp;&amp; bracketLevel == 0
501                                                     &amp;&amp; sc.Match(&#x27;&gt;&#x27;, &#x27;&gt;&#x27;)) {
502                                          sc.Forward(2);
503                                          sc.SetState(SCE_T3_D_STRING);
504                                          if (lineState &amp; T3_INT_EXPRESSION_IN_TAG)
505                                                  sc.SetState(SCE_T3_HTML_STRING);
506                                          lineState &amp;= ~(T3_SINGLE_QUOTE|T3_INT_EXPRESSION
507                                                         |T3_INT_EXPRESSION_IN_TAG);
508                                  } else if (IsATADS3Operator(sc.ch)) {
509                                          if (sc.state == SCE_T3_X_DEFAULT) {
510                                                  if (sc.ch == &#x27;(&#x27;) {
511                                                          bracketLevel++;
512                                                  } else if (sc.ch == &#x27;)&#x27; &amp;&amp; bracketLevel &gt; 0) {
513                                                          bracketLevel--;
514                                                  }
515                                          }
516                                          ColouriseTADS3Operator(sc);
517                                          visibleChars++;
518                                  } else if (IsANumberStart(sc)) {
519                                          ColouriseTADS3Number(sc);
520                                          visibleChars++;
521                                  } else if (IsAWordStart(sc.ch)) {
522                                          ColouriseTADS3Keyword(sc, keywordlists, endPos);
523                                          visibleChars++;
524                                  } else if (sc.Match(&quot;...&quot;)) {
525                                          sc.SetState(SCE_T3_IDENTIFIER);
526                                          sc.Forward(3);
527                                          sc.SetState(SCE_T3_DEFAULT);
528                                  } else {
529                                          sc.Forward();
530                                          visibleChars++;
531                                  }
532                                  break;
533                          default:
534                                  sc.SetState(SCE_T3_DEFAULT);
535                                  sc.Forward();
536                  }
537          }
538          sc.Complete();
539  }
540  static const int T3_SEENSTART = 1 &lt;&lt; 12;
541  static const int T3_EXPECTINGIDENTIFIER = 1 &lt;&lt; 13;
542  static const int T3_EXPECTINGPUNCTUATION = 1 &lt;&lt; 14;
543  static inline bool IsStringTransition(int s1, int s2) {
544          return s1 != s2
545                  &amp;&amp; (s1 == SCE_T3_S_STRING || s1 == SCE_T3_X_STRING
546                          || (s1 == SCE_T3_D_STRING &amp;&amp; s2 != SCE_T3_X_DEFAULT))
547                  &amp;&amp; s2 != SCE_T3_LIB_DIRECTIVE
548                  &amp;&amp; s2 != SCE_T3_MSG_PARAM
549                  &amp;&amp; s2 != SCE_T3_HTML_TAG
550                  &amp;&amp; s2 != SCE_T3_HTML_STRING;
551  }
552  static inline bool IsATADS3Punctuation(const int ch) {
553          return ch == &#x27;:&#x27; || ch == &#x27;,&#x27; || ch == &#x27;(&#x27; || ch == &#x27;)&#x27;;
554  }
555  static inline bool IsAnIdentifier(const int style) {
556          return style == SCE_T3_IDENTIFIER
557                  || style == SCE_T3_USER1
558                  || style == SCE_T3_USER2
559                  || style == SCE_T3_USER3;
560  }
561  static inline bool IsAnOperator(const int style) {
562      return style == SCE_T3_OPERATOR || style == SCE_T3_BRACE;
563  }
564  static inline bool IsSpaceEquivalent(const int ch, const int style) {
565          return isspace(ch)
566                  || style == SCE_T3_BLOCK_COMMENT
567                  || style == SCE_T3_LINE_COMMENT
568                  || style == SCE_T3_PREPROCESSOR;
569  }
570  static char peekAhead(Sci_PositionU startPos, Sci_PositionU endPos,
571                                            Accessor &amp;styler) {
572          for (Sci_PositionU i = startPos; i &lt; endPos; i++) {
573                  int style = styler.StyleAt(i);
574                  char ch = styler[i];
575                  if (!IsSpaceEquivalent(ch, style)) {
576                          if (IsAnIdentifier(style)) {
577                                  return &#x27;a&#x27;;
578                          }
579                          if (IsATADS3Punctuation(ch)) {
580                                  return &#x27;:&#x27;;
581                          }
582                          if (ch == &#x27;{&#x27;) {
583                                  return &#x27;{&#x27;;
584                          }
585                          return &#x27;*&#x27;;
586                  }
587          }
588          return &#x27; &#x27;;
589  }
590  static void FoldTADS3Doc(Sci_PositionU startPos, Sci_Position length, int initStyle,
591                              WordList *[], Accessor &amp;styler) {
592          Sci_PositionU endPos = startPos + length;
593          Sci_Position lineCurrent = styler.GetLine(startPos);
594          int levelCurrent = SC_FOLDLEVELBASE;
595          if (lineCurrent &gt; 0)
596                  levelCurrent = styler.LevelAt(lineCurrent-1) &gt;&gt; 16;
597          int seenStart = levelCurrent &amp; T3_SEENSTART;
598          int expectingIdentifier = levelCurrent &amp; T3_EXPECTINGIDENTIFIER;
599          int expectingPunctuation = levelCurrent &amp; T3_EXPECTINGPUNCTUATION;
600          levelCurrent &amp;= SC_FOLDLEVELNUMBERMASK;
601          int levelMinCurrent = levelCurrent;
602          int levelNext = levelCurrent;
603          char chNext = styler[startPos];
604          int styleNext = styler.StyleAt(startPos);
605          int style = initStyle;
606          char ch = chNext;
607          int stylePrev = style;
608          bool redo = false;
609          for (Sci_PositionU i = startPos; i &lt; endPos; i++) {
610                  if (redo) {
611                          redo = false;
612                          i--;
613                  } else {
614                          ch = chNext;
615                          chNext = styler.SafeGetCharAt(i + 1);
616                          stylePrev = style;
617                          style = styleNext;
618                          styleNext = styler.StyleAt(i + 1);
619                  }
620                  bool atEOL = IsEOL(ch, chNext);
621                  if (levelNext == SC_FOLDLEVELBASE) {
622                          if (IsSpaceEquivalent(ch, style)) {
623                                  if (expectingPunctuation) {
624                                          expectingIdentifier = 0;
625                                  }
626                                  if (style == SCE_T3_BLOCK_COMMENT) {
627                                          levelNext++;
628                                  }
629                          } else if (ch == &#x27;{&#x27;) {
630                                  levelNext++;
631                                  seenStart = 0;
632                          } else if (ch == &#x27;\&#x27;&#x27; || ch == &#x27;&quot;&#x27; || ch == &#x27;[&#x27;) {
633                                  levelNext++;
634                                  if (seenStart) {
635                                          redo = true;
636                                  }
637                          } else if (ch == &#x27;;&#x27;) {
638                                  seenStart = 0;
639                                  expectingIdentifier = 0;
640                                  expectingPunctuation = 0;
641                          } else if (expectingIdentifier &amp;&amp; expectingPunctuation) {
642                                  if (IsATADS3Punctuation(ch)) {
643                                          if (ch == &#x27;)&#x27; &amp;&amp; peekAhead(i+1, endPos, styler) != &#x27;{&#x27;) {
644                                                  levelNext++;
645                                          } else {
646                                                  expectingPunctuation = 0;
647                                          }
648                                  } else if (!IsAnIdentifier(style)) {
649                                          levelNext++;
650                                  }
651                          } else if (expectingIdentifier &amp;&amp; !expectingPunctuation) {
652                                  if (!IsAnIdentifier(style)) {
653                                          levelNext++;
654                                  } else {
655                                          expectingPunctuation = T3_EXPECTINGPUNCTUATION;
656                                  }
657                          } else if (!expectingIdentifier &amp;&amp; expectingPunctuation) {
658                                  if (!IsATADS3Punctuation(ch)) {
659                                          levelNext++;
660                                  } else {
661                                          if (ch == &#x27;)&#x27; &amp;&amp; peekAhead(i+1, endPos, styler) != &#x27;{&#x27;) {
662                                                  levelNext++;
663                                          } else {
664                                                  expectingIdentifier = T3_EXPECTINGIDENTIFIER;
665                                                  expectingPunctuation = 0;
666                                          }
667                                  }
668                          } else if (!expectingIdentifier &amp;&amp; !expectingPunctuation) {
669                                  if (IsAnIdentifier(style)) {
670                                          seenStart = T3_SEENSTART;
671                                          expectingIdentifier = T3_EXPECTINGIDENTIFIER;
672                                          expectingPunctuation = T3_EXPECTINGPUNCTUATION;
673                                  }
674                          }
675                          if (levelNext != SC_FOLDLEVELBASE &amp;&amp; style != SCE_T3_BLOCK_COMMENT) {
676                                  expectingIdentifier = 0;
677                                  expectingPunctuation = 0;
678                          }
679                  } else if (levelNext == SC_FOLDLEVELBASE+1 &amp;&amp; seenStart
680                                     &amp;&amp; ch == &#x27;;&#x27; &amp;&amp; IsAnOperator(style)) {
681                          levelNext--;
682                          seenStart = 0;
683                  } else if (style == SCE_T3_BLOCK_COMMENT) {
684                          if (stylePrev != SCE_T3_BLOCK_COMMENT) {
685                                  levelNext++;
686                          } else if (styleNext != SCE_T3_BLOCK_COMMENT &amp;&amp; !atEOL) {
687                                  levelNext--;
688                          }
689                  } else if (ch == &#x27;\&#x27;&#x27; || ch == &#x27;&quot;&#x27;) {
690                          if (IsStringTransition(style, stylePrev)) {
691                                  if (levelMinCurrent &gt; levelNext) {
692                                          levelMinCurrent = levelNext;
693                                  }
694                                  levelNext++;
695                          } else if (IsStringTransition(style, styleNext)) {
696                                  levelNext--;
697                          }
698                  } else if (IsAnOperator(style)) {
699                          if (ch == &#x27;{&#x27; || ch == &#x27;[&#x27;) {
700                                  if (levelMinCurrent &gt; levelNext) {
701                                          levelMinCurrent = levelNext;
702                                  }
703                                  levelNext++;
704                          } else if (ch == &#x27;}&#x27; || ch == &#x27;]&#x27;) {
705                                  levelNext--;
706                          }
707                  }
708                  if (atEOL) {
709                          if (seenStart &amp;&amp; levelNext == SC_FOLDLEVELBASE) {
710                                  switch (peekAhead(i+1, endPos, styler)) {
711                                          case &#x27; &#x27;:
712                                          case &#x27;{&#x27;:
713                                                  break;
714                                          case &#x27;*&#x27;:
715                                                  levelNext++;
716                                                  break;
717                                          case &#x27;a&#x27;:
718                                                  if (expectingPunctuation) {
719                                                          levelNext++;
720                                                  }
721                                                  break;
722                                          case &#x27;:&#x27;:
723                                                  if (expectingIdentifier) {
724                                                          levelNext++;
725                                                  }
726                                                  break;
727                                  }
728                                  if (levelNext != SC_FOLDLEVELBASE) {
729                                          expectingIdentifier = 0;
730                                          expectingPunctuation = 0;
731                                  }
732                          }
733                          int lev = levelMinCurrent | (levelNext | expectingIdentifier
734                                  | expectingPunctuation | seenStart) &lt;&lt; 16;
735                          if (levelMinCurrent &lt; levelNext)
736                                  lev |= SC_FOLDLEVELHEADERFLAG;
737                          if (lev != styler.LevelAt(lineCurrent)) {
738                                  styler.SetLevel(lineCurrent, lev);
739                          }
740                          lineCurrent++;
741                          levelCurrent = levelNext;
742                          levelMinCurrent = levelCurrent;
743                  }
744          }
745  }
746  static const char * const tads3WordList[] = {
747          &quot;TADS3 Keywords&quot;,
748          &quot;User defined 1&quot;,
749          &quot;User defined 2&quot;,
750          &quot;User defined 3&quot;,
751          0
752  };
753  LexerModule lmTADS3(SCLEX_TADS3, ColouriseTADS3Doc, &quot;tads3&quot;, FoldTADS3Doc, tads3WordList);
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-ScintillaEditView.cpp</h3>
            <pre><code>1  #include &lt;memory&gt;
2  #include &lt;shlwapi.h&gt;
3  #include &lt;cinttypes&gt;
4  #include &lt;windowsx.h&gt;
5  #include &quot;ScintillaEditView.h&quot;
6  #include &quot;Parameters.h&quot;
7  #include &quot;Sorters.h&quot;
8  #include &quot;verifySignedfile.h&quot;
9  #include &quot;ILexer.h&quot;
10  #include &quot;Lexilla.h&quot;
11  using namespace std;
12  bool ScintillaEditView::_SciInit = false;
13  int ScintillaEditView::_refCount = 0;
14  UserDefineDialog ScintillaEditView::_userDefineDlg;
15  const int ScintillaEditView::_SC_MARGE_LINENUMBER = 0;
16  const int ScintillaEditView::_SC_MARGE_SYMBOL = 1;
17  const int ScintillaEditView::_SC_MARGE_CHANGEHISTORY = 2;
18  const int ScintillaEditView::_SC_MARGE_FOLDER = 3;
19  WNDPROC ScintillaEditView::_scintillaDefaultProc = NULL;
20  string ScintillaEditView::_defaultCharList = &quot;&quot;;
21  const int ScintillaEditView::_markersArray[][NB_FOLDER_STATE] = {
22    {SC_MARKNUM_FOLDEROPEN, SC_MARKNUM_FOLDER, SC_MARKNUM_FOLDERSUB, SC_MARKNUM_FOLDERTAIL, SC_MARKNUM_FOLDEREND,        SC_MARKNUM_FOLDEROPENMID,     SC_MARKNUM_FOLDERMIDTAIL},
23    {SC_MARK_MINUS,         SC_MARK_PLUS,      SC_MARK_EMPTY,        SC_MARK_EMPTY,         SC_MARK_EMPTY,               SC_MARK_EMPTY,                SC_MARK_EMPTY},
24    {SC_MARK_ARROWDOWN,     SC_MARK_ARROW,     SC_MARK_EMPTY,        SC_MARK_EMPTY,         SC_MARK_EMPTY,               SC_MARK_EMPTY,                SC_MARK_EMPTY},
25    {SC_MARK_CIRCLEMINUS,   SC_MARK_CIRCLEPLUS,SC_MARK_VLINE,        SC_MARK_LCORNERCURVE,  SC_MARK_CIRCLEPLUSCONNECTED, SC_MARK_CIRCLEMINUSCONNECTED, SC_MARK_TCORNERCURVE},
26    {SC_MARK_BOXMINUS,      SC_MARK_BOXPLUS,   SC_MARK_VLINE,        SC_MARK_LCORNER,       SC_MARK_BOXPLUSCONNECTED,    SC_MARK_BOXMINUSCONNECTED,    SC_MARK_TCORNER}
27  };
28  LanguageNameInfo ScintillaEditView::_langNameInfoArray[L_EXTERNAL + 1] = {
29  	{TEXT(&quot;normal&quot;),		TEXT(&quot;Normal text&quot;),		TEXT(&quot;Normal text file&quot;),								L_TEXT,			&quot;null&quot;},
30  	{TEXT(&quot;php&quot;),			TEXT(&quot;PHP&quot;),				TEXT(&quot;PHP Hypertext Preprocessor file&quot;),				L_PHP,			&quot;phpscript&quot;},
31  	{TEXT(&quot;c&quot;),				TEXT(&quot;C&quot;),					TEXT(&quot;C source file&quot;),									L_C,			&quot;cpp&quot;},
32  	{TEXT(&quot;cpp&quot;),			TEXT(&quot;C++&quot;),				TEXT(&quot;C++ source file&quot;),								L_CPP,			&quot;cpp&quot;},
33  	{TEXT(&quot;cs&quot;),			TEXT(&quot;C#&quot;),					TEXT(&quot;C# source file&quot;),									L_CS,			&quot;cpp&quot;},
34  	{TEXT(&quot;objc&quot;),			TEXT(&quot;Objective-C&quot;),		TEXT(&quot;Objective-C source file&quot;),						L_OBJC,			&quot;objc&quot;},
35  	{TEXT(&quot;java&quot;),			TEXT(&quot;Java&quot;),				TEXT(&quot;Java source file&quot;),								L_JAVA,			&quot;cpp&quot;},
36  	{TEXT(&quot;rc&quot;),			TEXT(&quot;RC&quot;),					TEXT(&quot;Windows Resource file&quot;),							L_RC,			&quot;cpp&quot;},
37  	{TEXT(&quot;html&quot;),			TEXT(&quot;HTML&quot;),				TEXT(&quot;Hyper Text Markup Language file&quot;),				L_HTML,			&quot;hypertext&quot;},
38  	{TEXT(&quot;xml&quot;),			TEXT(&quot;XML&quot;),				TEXT(&quot;eXtensible Markup Language file&quot;),				L_XML,			&quot;xml&quot;},
39  	{TEXT(&quot;makefile&quot;),		TEXT(&quot;Makefile&quot;),			TEXT(&quot;Makefile&quot;),										L_MAKEFILE,		&quot;makefile&quot;},
40  	{TEXT(&quot;pascal&quot;),		TEXT(&quot;Pascal&quot;),				TEXT(&quot;Pascal source file&quot;),								L_PASCAL,		&quot;pascal&quot;},
41  	{TEXT(&quot;batch&quot;),			TEXT(&quot;Batch&quot;),				TEXT(&quot;Batch file&quot;),										L_BATCH,		&quot;batch&quot;},
42  	{TEXT(&quot;ini&quot;),			TEXT(&quot;ini&quot;),				TEXT(&quot;MS ini file&quot;),									L_INI,			&quot;props&quot;},
43  	{TEXT(&quot;nfo&quot;),			TEXT(&quot;NFO&quot;),				TEXT(&quot;MSDOS Style/ASCII Art&quot;),							L_ASCII,		&quot;null&quot;},
44  	{TEXT(&quot;udf&quot;),			TEXT(&quot;udf&quot;),				TEXT(&quot;User Defined language file&quot;),						L_USER,			&quot;user&quot;},
45  	{TEXT(&quot;asp&quot;),			TEXT(&quot;ASP&quot;),				TEXT(&quot;Active Server Pages script file&quot;),				L_ASP,			&quot;hypertext&quot;},
46  	{TEXT(&quot;sql&quot;),			TEXT(&quot;SQL&quot;),				TEXT(&quot;Structured Query Language file&quot;),					L_SQL,			&quot;sql&quot;},
47  	{TEXT(&quot;vb&quot;),			TEXT(&quot;Visual Basic&quot;),		TEXT(&quot;Visual Basic file&quot;),								L_VB,			&quot;vb&quot;},
48  	{TEXT(&quot;javascript&quot;),	TEXT(&quot;JavaScript&quot;),			TEXT(&quot;JavaScript file&quot;),								L_JS,			&quot;cpp&quot;},
49  	{TEXT(&quot;css&quot;),			TEXT(&quot;CSS&quot;),				TEXT(&quot;Cascade Style Sheets File&quot;),						L_CSS,			&quot;css&quot;},
50  	{TEXT(&quot;perl&quot;),			TEXT(&quot;Perl&quot;),				TEXT(&quot;Perl source file&quot;),								L_PERL,			&quot;perl&quot;},
51  	{TEXT(&quot;python&quot;),		TEXT(&quot;Python&quot;),				TEXT(&quot;Python file&quot;),									L_PYTHON,		&quot;python&quot;},
52  	{TEXT(&quot;lua&quot;),			TEXT(&quot;Lua&quot;),				TEXT(&quot;Lua source File&quot;),								L_LUA,			&quot;lua&quot;},
53  	{TEXT(&quot;tex&quot;),			TEXT(&quot;TeX&quot;),				TEXT(&quot;TeX file&quot;),										L_TEX,			&quot;tex&quot;},
54  	{TEXT(&quot;fortran&quot;),		TEXT(&quot;Fortran free form&quot;),	TEXT(&quot;Fortran free form source file&quot;),					L_FORTRAN,		&quot;fortran&quot;},
55  	{TEXT(&quot;bash&quot;),			TEXT(&quot;Shell&quot;),				TEXT(&quot;Unix script file&quot;),								L_BASH,			&quot;bash&quot;},
56  	{TEXT(&quot;actionscript&quot;),	TEXT(&quot;ActionScript&quot;),		TEXT(&quot;Flash ActionScript file&quot;),						L_FLASH,		&quot;cpp&quot;},
57  	{TEXT(&quot;nsis&quot;),			TEXT(&quot;NSIS&quot;),				TEXT(&quot;Nullsoft Scriptable Install System script file&quot;),	L_NSIS,			&quot;nsis&quot;},
58  	{TEXT(&quot;tcl&quot;),			TEXT(&quot;TCL&quot;),				TEXT(&quot;Tool Command Language file&quot;),						L_TCL,			&quot;tcl&quot;},
59  	{TEXT(&quot;lisp&quot;),			TEXT(&quot;Lisp&quot;),				TEXT(&quot;List Processing language file&quot;),					L_LISP,			&quot;lisp&quot;},
60  	{TEXT(&quot;scheme&quot;),		TEXT(&quot;Scheme&quot;),				TEXT(&quot;Scheme file&quot;),									L_SCHEME,		&quot;lisp&quot;},
61  	{TEXT(&quot;asm&quot;),			TEXT(&quot;Assembly&quot;),			TEXT(&quot;Assembly language source file&quot;),					L_ASM,			&quot;asm&quot;},
62  	{TEXT(&quot;diff&quot;),			TEXT(&quot;Diff&quot;),				TEXT(&quot;Diff file&quot;),										L_DIFF,			&quot;diff&quot;},
63  	{TEXT(&quot;props&quot;),			TEXT(&quot;Properties file&quot;),	TEXT(&quot;Properties file&quot;),								L_PROPS,		&quot;props&quot;},
64  	{TEXT(&quot;postscript&quot;),	TEXT(&quot;PostScript&quot;),			TEXT(&quot;PostScript file&quot;),								L_PS,			&quot;ps&quot;},
65  	{TEXT(&quot;ruby&quot;),			TEXT(&quot;Ruby&quot;),				TEXT(&quot;Ruby file&quot;),										L_RUBY,			&quot;ruby&quot;},
66  	{TEXT(&quot;smalltalk&quot;),		TEXT(&quot;Smalltalk&quot;),			TEXT(&quot;Smalltalk file&quot;),									L_SMALLTALK,	&quot;smalltalk&quot;},
67  	{TEXT(&quot;vhdl&quot;),			TEXT(&quot;VHDL&quot;),				TEXT(&quot;VHSIC Hardware Description Language file&quot;),		L_VHDL,			&quot;vhdl&quot;},
68  	{TEXT(&quot;kix&quot;),			TEXT(&quot;KiXtart&quot;),			TEXT(&quot;KiXtart file&quot;),									L_KIX,			&quot;kix&quot;},
69  	{TEXT(&quot;autoit&quot;),		TEXT(&quot;AutoIt&quot;),				TEXT(&quot;AutoIt&quot;),											L_AU3,			&quot;au3&quot;},
70  	{TEXT(&quot;caml&quot;),			TEXT(&quot;CAML&quot;),				TEXT(&quot;Categorical Abstract Machine Language&quot;),			L_CAML,			&quot;caml&quot;},
71  	{TEXT(&quot;ada&quot;),			TEXT(&quot;Ada&quot;),				TEXT(&quot;Ada file&quot;),										L_ADA,			&quot;ada&quot;},
72  	{TEXT(&quot;verilog&quot;),		TEXT(&quot;Verilog&quot;),			TEXT(&quot;Verilog file&quot;),									L_VERILOG,		&quot;verilog&quot;},
73  	{TEXT(&quot;matlab&quot;),		TEXT(&quot;MATLAB&quot;),				TEXT(&quot;MATrix LABoratory&quot;),								L_MATLAB,		&quot;matlab&quot;},
74  	{TEXT(&quot;haskell&quot;),		TEXT(&quot;Haskell&quot;),			TEXT(&quot;Haskell&quot;),										L_HASKELL,		&quot;haskell&quot;},
75  	{TEXT(&quot;inno&quot;),			TEXT(&quot;Inno Setup&quot;),			TEXT(&quot;Inno Setup script&quot;),								L_INNO,			&quot;inno&quot;},
76  	{TEXT(&quot;searchResult&quot;),	TEXT(&quot;Internal Search&quot;),	TEXT(&quot;Internal Search&quot;),								L_SEARCHRESULT,	&quot;searchResult&quot;},
77  	{TEXT(&quot;cmake&quot;),			TEXT(&quot;CMake&quot;),				TEXT(&quot;CMake file&quot;),										L_CMAKE,		&quot;cmake&quot;},
78  	{TEXT(&quot;yaml&quot;),			TEXT(&quot;YAML&quot;),				TEXT(&quot;YAML Ain&#x27;t Markup Language&quot;),						L_YAML,			&quot;yaml&quot;},
79  	{TEXT(&quot;cobol&quot;),			TEXT(&quot;COBOL&quot;),				TEXT(&quot;COmmon Business Oriented Language&quot;),				L_COBOL,		&quot;COBOL&quot;},
80  	{TEXT(&quot;gui4cli&quot;),		TEXT(&quot;Gui4Cli&quot;),			TEXT(&quot;Gui4Cli file&quot;),									L_GUI4CLI,		&quot;gui4cli&quot;},
81  	{TEXT(&quot;d&quot;),				TEXT(&quot;D&quot;),					TEXT(&quot;D programming language&quot;),							L_D,			&quot;d&quot;},
82  	{TEXT(&quot;powershell&quot;),	TEXT(&quot;PowerShell&quot;),			TEXT(&quot;Windows PowerShell&quot;),								L_POWERSHELL,	&quot;powershell&quot;},
83  	{TEXT(&quot;r&quot;),				TEXT(&quot;R&quot;),					TEXT(&quot;R programming language&quot;),							L_R,			&quot;r&quot;},
84  	{TEXT(&quot;jsp&quot;),			TEXT(&quot;JSP&quot;),				TEXT(&quot;JavaServer Pages script file&quot;),					L_JSP,			&quot;hypertext&quot;},
85  	{TEXT(&quot;coffeescript&quot;),	TEXT(&quot;CoffeeScript&quot;),		TEXT(&quot;CoffeeScript file&quot;),								L_COFFEESCRIPT,	&quot;coffeescript&quot;},
86  	{TEXT(&quot;json&quot;),			TEXT(&quot;json&quot;),				TEXT(&quot;JSON file&quot;),										L_JSON,			&quot;json&quot;},
87  	{TEXT(&quot;javascript.js&quot;), TEXT(&quot;JavaScript&quot;),			TEXT(&quot;JavaScript file&quot;),								L_JAVASCRIPT,	&quot;cpp&quot;},
88  	{TEXT(&quot;fortran77&quot;),		TEXT(&quot;Fortran fixed form&quot;),	TEXT(&quot;Fortran fixed form source file&quot;),					L_FORTRAN_77,	&quot;f77&quot;},
89  	{TEXT(&quot;baanc&quot;),			TEXT(&quot;BaanC&quot;),				TEXT(&quot;BaanC File&quot;),										L_BAANC,		&quot;baan&quot;},
90  	{TEXT(&quot;srec&quot;),			TEXT(&quot;S-Record&quot;),			TEXT(&quot;Motorola S-Record binary data&quot;),					L_SREC,			&quot;srec&quot;},
91  	{TEXT(&quot;ihex&quot;),			TEXT(&quot;Intel HEX&quot;),			TEXT(&quot;Intel HEX binary data&quot;),							L_IHEX,			&quot;ihex&quot;},
92  	{TEXT(&quot;tehex&quot;),			TEXT(&quot;Tektronix extended HEX&quot;),	TEXT(&quot;Tektronix extended HEX binary data&quot;),			L_TEHEX,		&quot;tehex&quot;},
93  	{TEXT(&quot;swift&quot;),			TEXT(&quot;Swift&quot;),              TEXT(&quot;Swift file&quot;),										L_SWIFT,		&quot;cpp&quot;},
94  	{TEXT(&quot;asn1&quot;),			TEXT(&quot;ASN.1&quot;),				TEXT(&quot;Abstract Syntax Notation One file&quot;),				L_ASN1,			&quot;asn1&quot;},
95  	{TEXT(&quot;avs&quot;),			TEXT(&quot;AviSynth&quot;),			TEXT(&quot;AviSynth scripts files&quot;),							L_AVS,			&quot;avs&quot;},
96  	{TEXT(&quot;blitzbasic&quot;),	TEXT(&quot;BlitzBasic&quot;),			TEXT(&quot;BlitzBasic file&quot;),								L_BLITZBASIC,	&quot;blitzbasic&quot;},
97  	{TEXT(&quot;purebasic&quot;),		TEXT(&quot;PureBasic&quot;),			TEXT(&quot;PureBasic file&quot;),									L_PUREBASIC,	&quot;purebasic&quot;},
98  	{TEXT(&quot;freebasic&quot;),		TEXT(&quot;FreeBasic&quot;),			TEXT(&quot;FreeBasic file&quot;),									L_FREEBASIC,	&quot;freebasic&quot;},
99  	{TEXT(&quot;csound&quot;),		TEXT(&quot;Csound&quot;),				TEXT(&quot;Csound file&quot;),									L_CSOUND,		&quot;csound&quot;},
100  	{TEXT(&quot;erlang&quot;),		TEXT(&quot;Erlang&quot;),				TEXT(&quot;Erlang file&quot;),									L_ERLANG,		&quot;erlang&quot;},
101  	{TEXT(&quot;escript&quot;),		TEXT(&quot;ESCRIPT&quot;),			TEXT(&quot;ESCRIPT file&quot;),									L_ESCRIPT,		&quot;escript&quot;},
102  	{TEXT(&quot;forth&quot;),			TEXT(&quot;Forth&quot;),				TEXT(&quot;Forth file&quot;),										L_FORTH,		&quot;forth&quot;},
103  	{TEXT(&quot;latex&quot;),			TEXT(&quot;LaTeX&quot;),				TEXT(&quot;LaTeX file&quot;),										L_LATEX,		&quot;latex&quot;},
104  	{TEXT(&quot;mmixal&quot;),		TEXT(&quot;MMIXAL&quot;),				TEXT(&quot;MMIXAL file&quot;),									L_MMIXAL,		&quot;mmixal&quot;},
105  	{TEXT(&quot;nim&quot;),			TEXT(&quot;Nim&quot;),				TEXT(&quot;Nim file&quot;),										L_NIM,			&quot;nimrod&quot;},
106  	{TEXT(&quot;nncrontab&quot;),		TEXT(&quot;Nncrontab&quot;),			TEXT(&quot;extended crontab file&quot;),							L_NNCRONTAB,	&quot;nncrontab&quot;},
107  	{TEXT(&quot;oscript&quot;),		TEXT(&quot;OScript&quot;),			TEXT(&quot;OScript source file&quot;),							L_OSCRIPT,		&quot;oscript&quot;},
108  	{TEXT(&quot;rebol&quot;),			TEXT(&quot;REBOL&quot;),				TEXT(&quot;REBOL file&quot;),										L_REBOL,		&quot;rebol&quot;},
109  	{TEXT(&quot;registry&quot;),		TEXT(&quot;registry&quot;),			TEXT(&quot;registry file&quot;),									L_REGISTRY,		&quot;registry&quot;},
110  	{TEXT(&quot;rust&quot;),			TEXT(&quot;Rust&quot;),				TEXT(&quot;Rust file&quot;),										L_RUST,			&quot;rust&quot;},
111  	{TEXT(&quot;spice&quot;),			TEXT(&quot;Spice&quot;),				TEXT(&quot;spice file&quot;),										L_SPICE,		&quot;spice&quot;},
112  	{TEXT(&quot;txt2tags&quot;),		TEXT(&quot;txt2tags&quot;),			TEXT(&quot;txt2tags file&quot;),									L_TXT2TAGS,		&quot;txt2tags&quot;},
113  	{TEXT(&quot;visualprolog&quot;),	TEXT(&quot;Visual Prolog&quot;),		TEXT(&quot;Visual Prolog file&quot;),								L_VISUALPROLOG,	&quot;visualprolog&quot;},
114  	{TEXT(&quot;typescript&quot;),	TEXT(&quot;TypeScript&quot;),			TEXT(&quot;TypeScript file&quot;),								L_TYPESCRIPT,	&quot;cpp&quot;},
115  	{TEXT(&quot;json5&quot;),			TEXT(&quot;json5&quot;),				TEXT(&quot;JSON5 file&quot;),										L_JSON5,		&quot;json&quot;},
116  	{TEXT(&quot;mssql&quot;),			TEXT(&quot;mssql&quot;),				TEXT(&quot;Microsoft Transact-SQL (SQL Server) file&quot;),		L_MSSQL,		&quot;mssql&quot;},
117  	{TEXT(&quot;gdscript&quot;),		TEXT(&quot;GDScript&quot;),			TEXT(&quot;GDScript file&quot;),									L_GDSCRIPT,		&quot;gdscript&quot;},
118  	{TEXT(&quot;hollywood&quot;),		TEXT(&quot;Hollywood&quot;),			TEXT(&quot;Hollywood script&quot;),								L_HOLLYWOOD,	&quot;hollywood&quot;},
119  	{TEXT(&quot;ext&quot;),			TEXT(&quot;External&quot;),			TEXT(&quot;External&quot;),										L_EXTERNAL,		&quot;null&quot;}
120  };
121  int getNbDigits(int aNum, int base)
122  {
123  	int nbChiffre = 1;
124  	int diviseur = base;
125  	for (;;)
126  	{
127  		int result = aNum / diviseur;
128  		if (!result)
129  			break;
130  		else
131  		{
132  			diviseur *= base;
133  			++nbChiffre;
134  		}
135  	}
136  	if ((base == 16) &amp;&amp; (nbChiffre % 2 != 0))
137  		nbChiffre += 1;
138  	return nbChiffre;
139  }
140  void ScintillaEditView::init(HINSTANCE hInst, HWND hPere)
141  {
142  	if (!_SciInit)
143  	{
144  		if (!Scintilla_RegisterClasses(hInst))
145  		{
146  			throw std::runtime_error(&quot;ScintillaEditView::init : SCINTILLA ERROR - Scintilla_RegisterClasses failed&quot;);
147  		}
148  		_SciInit = true;
149  	}
150  	Window::init(hInst, hPere);
151  	_hSelf = ::CreateWindowEx(
152  					0,\
153  					TEXT(&quot;Scintilla&quot;),\
154  					TEXT(&quot;Notepad++&quot;),\
155  					WS_CHILD | WS_VSCROLL | WS_HSCROLL | WS_CLIPCHILDREN | WS_EX_RTLREADING,\
156  					0, 0, 100, 100,\
157  					_hParent,\
158  					NULL,\
159  					_hInst,\
160  					NULL);
161  	if (!_hSelf)
162  	{
163  		throw std::runtime_error(&quot;ScintillaEditView::init : CreateWindowEx() function return null&quot;);
164  	}
165  	NppDarkMode::setDarkScrollBar(_hSelf);
166  	_pScintillaFunc = (SCINTILLA_FUNC)::SendMessage(_hSelf, SCI_GETDIRECTFUNCTION, 0, 0);
167  	_pScintillaPtr = (SCINTILLA_PTR)::SendMessage(_hSelf, SCI_GETDIRECTPOINTER, 0, 0);
168  	_userDefineDlg.init(_hInst, _hParent, this);
169  	if (!_pScintillaFunc)
170  	{
171  		throw std::runtime_error(&quot;ScintillaEditView::init : SCI_GETDIRECTFUNCTION message failed&quot;);
172  	}
173  	if (!_pScintillaPtr)
174  	{
175  		throw std::runtime_error(&quot;ScintillaEditView::init : SCI_GETDIRECTPOINTER message failed&quot;);
176  	}
177  	execute(SCI_SETMARGINMASKN, _SC_MARGE_FOLDER, SC_MASK_FOLDERS);
178  	showMargin(_SC_MARGE_FOLDER, true);
179  	execute(SCI_SETMARGINMASKN, _SC_MARGE_SYMBOL, (1 &lt;&lt; MARK_BOOKMARK) | (1 &lt;&lt; MARK_HIDELINESBEGIN) | (1 &lt;&lt; MARK_HIDELINESEND));
180  	execute(SCI_SETMARGINMASKN, _SC_MARGE_CHANGEHISTORY, (1 &lt;&lt; SC_MARKNUM_HISTORY_REVERTED_TO_ORIGIN) | (1 &lt;&lt; SC_MARKNUM_HISTORY_SAVED) | (1 &lt;&lt; SC_MARKNUM_HISTORY_MODIFIED) | (1 &lt;&lt; SC_MARKNUM_HISTORY_REVERTED_TO_MODIFIED));
181  	COLORREF modifiedColor = RGB(255, 128, 0);
182  	execute(SCI_MARKERSETBACK, SC_MARKNUM_HISTORY_MODIFIED, modifiedColor);
183  	execute(SCI_MARKERSETALPHA, MARK_BOOKMARK, 70);
184  	const COLORREF hiddenLinesGreen = RGB(0x77, 0xCC, 0x77);
185  	long hiddenLinesGreenWithAlpha = hiddenLinesGreen | 0xFF000000;
186  	execute(SCI_SETELEMENTCOLOUR, SC_ELEMENT_HIDDEN_LINE, hiddenLinesGreenWithAlpha);
187  	if (NppParameters::getInstance()._dpiManager.scaleX(100) &gt;= 150)
188  	{
189  		execute(SCI_RGBAIMAGESETWIDTH, 18);
190  		execute(SCI_RGBAIMAGESETHEIGHT, 18);
191  		execute(SCI_MARKERDEFINERGBAIMAGE, MARK_BOOKMARK, reinterpret_cast&lt;LPARAM&gt;(bookmark18));
192  		execute(SCI_MARKERDEFINERGBAIMAGE, MARK_HIDELINESBEGIN, reinterpret_cast&lt;LPARAM&gt;(hidelines_begin18));
193  		execute(SCI_MARKERDEFINERGBAIMAGE, MARK_HIDELINESEND, reinterpret_cast&lt;LPARAM&gt;(hidelines_end18));
194  	}
195  	else
196  	{
197  		execute(SCI_RGBAIMAGESETWIDTH, 14);
198  		execute(SCI_RGBAIMAGESETHEIGHT, 14);
199  		execute(SCI_MARKERDEFINERGBAIMAGE, MARK_BOOKMARK, reinterpret_cast&lt;LPARAM&gt;(bookmark14));
200  		execute(SCI_MARKERDEFINERGBAIMAGE, MARK_HIDELINESBEGIN, reinterpret_cast&lt;LPARAM&gt;(hidelines_begin14));
201  		execute(SCI_MARKERDEFINERGBAIMAGE, MARK_HIDELINESEND, reinterpret_cast&lt;LPARAM&gt;(hidelines_end14));
202  	}
203      execute(SCI_SETMARGINSENSITIVEN, _SC_MARGE_FOLDER, true); 
204      execute(SCI_SETMARGINSENSITIVEN, _SC_MARGE_SYMBOL, true); 
205      execute(SCI_SETFOLDFLAGS, SC_FOLDFLAG_LINEAFTER_CONTRACTED);
206  	execute(SCI_SETSCROLLWIDTHTRACKING, true);
207  	execute(SCI_SETSCROLLWIDTH, 1);	
208  	execute(SCI_INDICSETSTYLE, SCE_UNIVERSAL_FOUND_STYLE_SMART, INDIC_ROUNDBOX);
209  	execute(SCI_INDICSETSTYLE, SCE_UNIVERSAL_FOUND_STYLE, INDIC_ROUNDBOX);
210  	execute(SCI_INDICSETSTYLE, SCE_UNIVERSAL_FOUND_STYLE_INC, INDIC_ROUNDBOX);
211  	execute(SCI_INDICSETSTYLE, SCE_UNIVERSAL_TAGMATCH, INDIC_ROUNDBOX);
212  	execute(SCI_INDICSETSTYLE, SCE_UNIVERSAL_TAGATTR, INDIC_ROUNDBOX);
213  	execute(SCI_INDICSETSTYLE, SCE_UNIVERSAL_FOUND_STYLE_EXT1, INDIC_ROUNDBOX);
214  	execute(SCI_INDICSETSTYLE, SCE_UNIVERSAL_FOUND_STYLE_EXT2, INDIC_ROUNDBOX);
215  	execute(SCI_INDICSETSTYLE, SCE_UNIVERSAL_FOUND_STYLE_EXT3, INDIC_ROUNDBOX);
216  	execute(SCI_INDICSETSTYLE, SCE_UNIVERSAL_FOUND_STYLE_EXT4, INDIC_ROUNDBOX);
217  	execute(SCI_INDICSETSTYLE, SCE_UNIVERSAL_FOUND_STYLE_EXT5, INDIC_ROUNDBOX);
218  	execute(SCI_INDICSETALPHA, SCE_UNIVERSAL_FOUND_STYLE_SMART, 100);
219  	execute(SCI_INDICSETALPHA, SCE_UNIVERSAL_FOUND_STYLE, 100);
220  	execute(SCI_INDICSETALPHA, SCE_UNIVERSAL_FOUND_STYLE_INC, 100);
221  	execute(SCI_INDICSETALPHA, SCE_UNIVERSAL_TAGMATCH, 100);
222  	execute(SCI_INDICSETALPHA, SCE_UNIVERSAL_TAGATTR, 100);
223  	execute(SCI_INDICSETALPHA, SCE_UNIVERSAL_FOUND_STYLE_EXT1, 100);
224  	execute(SCI_INDICSETALPHA, SCE_UNIVERSAL_FOUND_STYLE_EXT2, 100);
225  	execute(SCI_INDICSETALPHA, SCE_UNIVERSAL_FOUND_STYLE_EXT3, 100);
226  	execute(SCI_INDICSETALPHA, SCE_UNIVERSAL_FOUND_STYLE_EXT4, 100);
227  	execute(SCI_INDICSETALPHA, SCE_UNIVERSAL_FOUND_STYLE_EXT5, 100);
228  	execute(SCI_INDICSETUNDER, SCE_UNIVERSAL_FOUND_STYLE_SMART, true);
229  	execute(SCI_INDICSETUNDER, SCE_UNIVERSAL_FOUND_STYLE, true);
230  	execute(SCI_INDICSETUNDER, SCE_UNIVERSAL_FOUND_STYLE_INC, true);
231  	execute(SCI_INDICSETUNDER, SCE_UNIVERSAL_TAGMATCH, true);
232  	execute(SCI_INDICSETUNDER, SCE_UNIVERSAL_TAGATTR, true);
233  	execute(SCI_INDICSETUNDER, SCE_UNIVERSAL_FOUND_STYLE_EXT1, true);
234  	execute(SCI_INDICSETUNDER, SCE_UNIVERSAL_FOUND_STYLE_EXT2, true);
235  	execute(SCI_INDICSETUNDER, SCE_UNIVERSAL_FOUND_STYLE_EXT3, true);
236  	execute(SCI_INDICSETUNDER, SCE_UNIVERSAL_FOUND_STYLE_EXT4, true);
237  	execute(SCI_INDICSETUNDER, SCE_UNIVERSAL_FOUND_STYLE_EXT5, true);
238  	if ((NppParameters::getInstance()).getNppGUI()._writeTechnologyEngine == directWriteTechnology)
239  		execute(SCI_SETTECHNOLOGY, SC_TECHNOLOGY_DIRECTWRITE);
240  	_codepage = ::GetACP();
241  	::SetWindowLongPtr(_hSelf, GWLP_USERDATA, reinterpret_cast&lt;LONG_PTR&gt;(this));
242  	_callWindowProc = CallWindowProc;
243  	_scintillaDefaultProc = reinterpret_cast&lt;WNDPROC&gt;(::SetWindowLongPtr(_hSelf, GWLP_WNDPROC, reinterpret_cast&lt;LONG_PTR&gt;(scintillaStatic_Proc)));
244  	if (_defaultCharList.empty())
245  	{
246  		auto defaultCharListLen = execute(SCI_GETWORDCHARS);
247  		char *defaultCharList = new char[defaultCharListLen + 1];
248  		execute(SCI_GETWORDCHARS, 0, reinterpret_cast&lt;LPARAM&gt;(defaultCharList));
249  		defaultCharList[defaultCharListLen] = &#x27;\0&#x27;;
250  		_defaultCharList = defaultCharList;
251  		delete[] defaultCharList;
252  	}
253  	attachDefaultDoc();
254  }
255  LRESULT CALLBACK ScintillaEditView::scintillaStatic_Proc(HWND hwnd, UINT Message, WPARAM wParam, LPARAM lParam)
256  {
257  	ScintillaEditView *pScint = (ScintillaEditView *)(::GetWindowLongPtr(hwnd, GWLP_USERDATA));
258  	if (Message == WM_MOUSEWHEEL || Message == WM_MOUSEHWHEEL)
259  	{
260  		POINT pt{};
261  		POINTS pts = MAKEPOINTS(lParam);
262  		POINTSTOPOINT(pt, pts);
263  		HWND hwndOnMouse = WindowFromPoint(pt);
264  		char synapticsHack[26]{};
265  		GetClassNameA(hwndOnMouse, (LPSTR)&amp;synapticsHack, 26);
266  		bool isSynpnatic = std::string(synapticsHack) == &quot;SynTrackCursorWindowClass&quot;;
267  		bool makeTouchPadCompetible = ((NppParameters::getInstance()).getSVP())._disableAdvancedScrolling;
268  		if (pScint &amp;&amp; (isSynpnatic || makeTouchPadCompetible))
269  			return (pScint-&gt;scintillaNew_Proc(hwnd, Message, wParam, lParam));
270  		ScintillaEditView *pScintillaOnMouse = (ScintillaEditView *)(::GetWindowLongPtr(hwndOnMouse, GWLP_USERDATA));
271  		if (pScintillaOnMouse != pScint)
272  			return ::SendMessage(hwndOnMouse, Message, wParam, lParam);
273  	}
274  	if (pScint)
275  		return (pScint-&gt;scintillaNew_Proc(hwnd, Message, wParam, lParam));
276  	else
277  		return ::DefWindowProc(hwnd, Message, wParam, lParam);
278  }
279  LRESULT ScintillaEditView::scintillaNew_Proc(HWND hwnd, UINT Message, WPARAM wParam, LPARAM lParam)
280  {
281  	switch (Message)
282  	{
283  		case NPPM_INTERNAL_REFRESHDARKMODE:
284  		{
285  			NppDarkMode::setDarkScrollBar(_hSelf);
286  			return TRUE;
287  		}
288  		case WM_MOUSEHWHEEL :
289  		{
290  			::CallWindowProc(_scintillaDefaultProc, hwnd, WM_HSCROLL, ((short)HIWORD(wParam) &gt; 0)?SB_LINERIGHT:SB_LINELEFT, 0);
291  			return TRUE;
292  		}
293  		case WM_MOUSEWHEEL :
294  		{
295  			if (LOWORD(wParam) &amp; MK_RBUTTON)
296  			{
297  				::SendMessage(_hParent, Message, wParam, lParam);
298  				return TRUE;
299  			}
300  			if (LOWORD(wParam) &amp; MK_SHIFT)
301  			{
302  				::CallWindowProc(_scintillaDefaultProc, hwnd, WM_HSCROLL, ((short)HIWORD(wParam) &lt; 0) ? SB_LINERIGHT : SB_LINELEFT, 0);
303  				::CallWindowProc(_scintillaDefaultProc, hwnd, WM_HSCROLL, ((short)HIWORD(wParam) &lt; 0) ? SB_LINERIGHT : SB_LINELEFT, 0);
304  				::CallWindowProc(_scintillaDefaultProc, hwnd, WM_HSCROLL, ((short)HIWORD(wParam) &lt; 0) ? SB_LINERIGHT : SB_LINELEFT, 0);
305  				return TRUE;
306  			}
307  			LRESULT scrollResult = ::CallWindowProc(_scintillaDefaultProc, hwnd, Message, wParam, lParam);
308  			return scrollResult;
309  		}
310  		case WM_IME_REQUEST:
311  		{
312  			if (wParam == IMR_RECONVERTSTRING)
313  			{
314  				intptr_t					textLength = 0;
315  				intptr_t					selectSize = 0;
316  				char				smallTextBuffer[128] = { &#x27;\0&#x27; };
317  				char			  *	selectedStr = smallTextBuffer;
318  				RECONVERTSTRING   *	reconvert = (RECONVERTSTRING *)lParam;
319  				if (execute(SCI_SELECTIONISRECTANGLE, 0, 0))
320  					return 0;
321  				size_t cp = execute(SCI_GETCODEPAGE);
322  				UINT codepage = static_cast&lt;UINT&gt;(cp);
323  				Sci_CharacterRangeFull range = getSelection();
324  				if (range.cpMax == range.cpMin)
325  				{
326  					expandWordSelection();
327  					range = getSelection();
328  				}
329  				selectSize = range.cpMax - range.cpMin;
330  				if (selectSize == 0)
331  					return 0;
332  				if (static_cast&lt;size_t&gt;(selectSize + 1) &gt; sizeof(smallTextBuffer))
333  					selectedStr = new char[selectSize + 1];
334  				getText(selectedStr, range.cpMin, range.cpMax);
335  				if (reconvert == NULL)
336  				{
337  					textLength = sizeof(WCHAR) * ::MultiByteToWideChar(codepage, 0, selectedStr, (int)selectSize, NULL, 0);
338  				}
339  				else
340  				{
341  					textLength = ::MultiByteToWideChar(	codepage, 0,
342  														selectedStr, (int)selectSize,
343  														(LPWSTR)((LPSTR)reconvert + sizeof(RECONVERTSTRING)),
344  														static_cast&lt;int&gt;(reconvert-&gt;dwSize - sizeof(RECONVERTSTRING)));
345  					reconvert-&gt;dwVersion		 = 0;
346  					reconvert-&gt;dwStrLen			 = static_cast&lt;DWORD&gt;(textLength);
347  					reconvert-&gt;dwStrOffset		 = sizeof(RECONVERTSTRING);
348  					reconvert-&gt;dwCompStrLen		 = static_cast&lt;DWORD&gt;(textLength);
349  					reconvert-&gt;dwCompStrOffset	 = 0;
350  					reconvert-&gt;dwTargetStrLen	 = reconvert-&gt;dwCompStrLen;
351  					reconvert-&gt;dwTargetStrOffset = reconvert-&gt;dwCompStrOffset;
352  					textLength *= sizeof(WCHAR);
353  				}
354  				if (selectedStr != smallTextBuffer)
355  					delete [] selectedStr;
356  				return sizeof(RECONVERTSTRING) + textLength;
357  			}
358  			break;
359  		}
360  		case WM_KEYUP :
361  		{
362  			if (wParam == VK_PRIOR || wParam == VK_NEXT)
363  			{
364  				SCNotification notification = {};
365  				notification.nmhdr.code = SCN_PAINTED;
366  				notification.nmhdr.hwndFrom = _hSelf;
367  				notification.nmhdr.idFrom = ::GetDlgCtrlID(_hSelf);
368  				::SendMessage(_hParent, WM_NOTIFY, LINKTRIGGERED, reinterpret_cast&lt;LPARAM&gt;(&amp;notification));
369  			}
370  			break;
371  		}
372  		case WM_VSCROLL :
373  		{
374  			break;
375  		}
376  		case WM_RBUTTONDOWN:
377  		{
378  			bool rightClickKeepsSelection = ((NppParameters::getInstance()).getSVP())._rightClickKeepsSelection;
379  			if (rightClickKeepsSelection)
380  			{
381  				size_t clickX = GET_X_LPARAM(lParam);
382  				size_t marginX = execute(SCI_POINTXFROMPOSITION, 0, 0);
383  				if (clickX &gt;= marginX)
384  				{
385  					return TRUE;
386  				}
387  			}
388  			break;
389  		}
390  	}
391  	return _callWindowProc(_scintillaDefaultProc, hwnd, Message, wParam, lParam);
392  }
393  #define DEFAULT_FONT_NAME &quot;Courier New&quot;
394  void ScintillaEditView::setSpecialStyle(const Style &amp; styleToSet)
395  {
396  	int styleID = styleToSet._styleID;
397  	if ( styleToSet._colorStyle &amp; COLORSTYLE_FOREGROUND )
398  	    execute(SCI_STYLESETFORE, styleID, styleToSet._fgColor);
399      if ( styleToSet._colorStyle &amp; COLORSTYLE_BACKGROUND )
400  	    execute(SCI_STYLESETBACK, styleID, styleToSet._bgColor);
401      if (!styleToSet._fontName.empty())
402  	{
403  		if (!NppParameters::getInstance().isInFontList(styleToSet._fontName))
404  		{
405  			execute(SCI_STYLESETFONT, styleID, reinterpret_cast&lt;LPARAM&gt;(DEFAULT_FONT_NAME));
406  		}
407  		else
408  		{
409  			std::string fontNameA = wstring2string(styleToSet._fontName, CP_UTF8);
410  			execute(SCI_STYLESETFONT, styleID, reinterpret_cast&lt;LPARAM&gt;(fontNameA.c_str()));
411  		}
412  	}
413  	int fontStyle = styleToSet._fontStyle;
414      if (fontStyle != STYLE_NOT_USED)
415      {
416          execute(SCI_STYLESETBOLD,		styleID, fontStyle &amp; FONTSTYLE_BOLD);
417          execute(SCI_STYLESETITALIC,		styleID, fontStyle &amp; FONTSTYLE_ITALIC);
418          execute(SCI_STYLESETUNDERLINE,	styleID, fontStyle &amp; FONTSTYLE_UNDERLINE);
419      }
420  	if (styleToSet._fontSize &gt; 0)
421  		execute(SCI_STYLESETSIZE, styleID, styleToSet._fontSize);
422  }
423  void ScintillaEditView::setHotspotStyle(const Style&amp; styleToSet)
424  {
425  	StyleMap* styleMap;
426  	if ( _hotspotStyles.find(_currentBuffer) == _hotspotStyles.end() )
427  	{
428  		_hotspotStyles[_currentBuffer] = new StyleMap;
429  	}
430  	styleMap = _hotspotStyles[_currentBuffer];
431  	(*styleMap)[styleToSet._styleID] = styleToSet;
432  	setStyle(styleToSet);
433  }
434  void ScintillaEditView::setStyle(Style styleToSet)
435  {
436  	GlobalOverride &amp; go = NppParameters::getInstance().getGlobalOverrideStyle();
437  	if (go.isEnable())
438  	{
439  		const Style * pStyle = NppParameters::getInstance().getMiscStylerArray().findByName(TEXT(&quot;Global override&quot;));
440  		if (pStyle)
441  		{
442  			if (go.enableFg)
443  			{
444  				if (pStyle-&gt;_colorStyle &amp; COLORSTYLE_FOREGROUND)
445  				{
446  					styleToSet._colorStyle |= COLORSTYLE_FOREGROUND;
447  					styleToSet._fgColor = pStyle-&gt;_fgColor;
448  				}
449  				else
450  				{
451  					if (styleToSet._styleID == STYLE_DEFAULT) 
452  						styleToSet._colorStyle |= COLORSTYLE_FOREGROUND;
453  					else
454  						styleToSet._colorStyle &amp;= ~COLORSTYLE_FOREGROUND;
455  				}
456  			}
457  			if (go.enableBg)
458  			{
459  				if (pStyle-&gt;_colorStyle &amp; COLORSTYLE_BACKGROUND)
460  				{
461  					styleToSet._colorStyle |= COLORSTYLE_BACKGROUND;
462  					styleToSet._bgColor = pStyle-&gt;_bgColor;
463  				}
464  				else
465  				{
466  					if (styleToSet._styleID == STYLE_DEFAULT) 	
467  						styleToSet._colorStyle |= COLORSTYLE_BACKGROUND;
468  					else
469  						styleToSet._colorStyle &amp;= ~COLORSTYLE_BACKGROUND;
470  				}
471  			}
472  			if (go.enableFont &amp;&amp; !pStyle-&gt;_fontName.empty())
473  				styleToSet._fontName = pStyle-&gt;_fontName;
474  			if (go.enableFontSize &amp;&amp; (pStyle-&gt;_fontSize &gt; 0))
475  				styleToSet._fontSize = pStyle-&gt;_fontSize;
476  			if (pStyle-&gt;_fontStyle != STYLE_NOT_USED)
477  			{
478  				if (go.enableBold)
479  				{
480  					if (pStyle-&gt;_fontStyle &amp; FONTSTYLE_BOLD)
481  						styleToSet._fontStyle |= FONTSTYLE_BOLD;
482  					else
483  						styleToSet._fontStyle &amp;= ~FONTSTYLE_BOLD;
484  				}
485  				if (go.enableItalic)
486  				{
487  					if (pStyle-&gt;_fontStyle &amp; FONTSTYLE_ITALIC)
488  						styleToSet._fontStyle |= FONTSTYLE_ITALIC;
489  					else
490  						styleToSet._fontStyle &amp;= ~FONTSTYLE_ITALIC;
491  				}
492  				if (go.enableUnderLine)
493  				{
494  					if (pStyle-&gt;_fontStyle &amp; FONTSTYLE_UNDERLINE)
495  						styleToSet._fontStyle |= FONTSTYLE_UNDERLINE;
496  					else
497  						styleToSet._fontStyle &amp;= ~FONTSTYLE_UNDERLINE;
498  				}
499  			}
500  		}
501  	}
502  	setSpecialStyle(styleToSet);
503  }
504  void ScintillaEditView::setXmlLexer(LangType type)
505  {
506  	if (type == L_XML)
507  	{
508  		setLexerFromLangID(L_XML);
509  		for (int i = 0 ; i &lt; 4 ; ++i)
510  			execute(SCI_SETKEYWORDS, i, reinterpret_cast&lt;LPARAM&gt;(TEXT(&quot;&quot;)));
511          makeStyle(type);
512  		execute(SCI_SETPROPERTY, reinterpret_cast&lt;WPARAM&gt;(&quot;lexer.xml.allow.scripts&quot;), reinterpret_cast&lt;LPARAM&gt;(&quot;0&quot;));
513  	}
514  	else if ((type == L_HTML) || (type == L_PHP) || (type == L_ASP) || (type == L_JSP))
515  	{
516  		setLexerFromLangID(L_HTML);
517  		const TCHAR *htmlKeyWords_generic = NppParameters::getInstance().getWordList(L_HTML, LANG_INDEX_INSTR);
518  		WcharMbcsConvertor&amp; wmc = WcharMbcsConvertor::getInstance();
519  		const char *htmlKeyWords = wmc.wchar2char(htmlKeyWords_generic, CP_ACP);
520  		execute(SCI_SETKEYWORDS, 0, reinterpret_cast&lt;LPARAM&gt;(htmlKeyWords?htmlKeyWords:&quot;&quot;));
521  		makeStyle(L_HTML);
522          setEmbeddedJSLexer();
523          setEmbeddedPhpLexer();
524  		setEmbeddedAspLexer();
525  	}
526  	execute(SCI_SETPROPERTY, reinterpret_cast&lt;WPARAM&gt;(&quot;fold&quot;), reinterpret_cast&lt;LPARAM&gt;(&quot;1&quot;));
527  	execute(SCI_SETPROPERTY, reinterpret_cast&lt;WPARAM&gt;(&quot;fold.compact&quot;), reinterpret_cast&lt;LPARAM&gt;(&quot;0&quot;));
528  	execute(SCI_SETPROPERTY, reinterpret_cast&lt;WPARAM&gt;(&quot;fold.html&quot;), reinterpret_cast&lt;LPARAM&gt;(&quot;1&quot;));
529  	execute(SCI_SETPROPERTY, reinterpret_cast&lt;WPARAM&gt;(&quot;fold.hypertext.comment&quot;), reinterpret_cast&lt;LPARAM&gt;(&quot;1&quot;));
530  }
531  void ScintillaEditView::setEmbeddedJSLexer()
532  {
533  	const TCHAR *pKwArray[10] = {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};
534  	makeStyle(L_JS, pKwArray);
535  	basic_string&lt;char&gt; keywordList(&quot;&quot;);
536  	if (pKwArray[LANG_INDEX_INSTR])
537  	{
538  		basic_string&lt;wchar_t&gt; kwlW = pKwArray[LANG_INDEX_INSTR];
539  		keywordList = wstring2string(kwlW, CP_ACP);
540  	}
541  	execute(SCI_SETKEYWORDS, 1, reinterpret_cast&lt;LPARAM&gt;(getCompleteKeywordList(keywordList, L_JS, LANG_INDEX_INSTR)));
542  	execute(SCI_STYLESETEOLFILLED, SCE_HJ_DEFAULT, true);
543  	execute(SCI_STYLESETEOLFILLED, SCE_HJ_COMMENT, true);
544  	execute(SCI_STYLESETEOLFILLED, SCE_HJ_COMMENTDOC, true);
545  }
546  void ScintillaEditView::setJsonLexer(bool isJson5)
547  {
548  	LangType j = isJson5 ? L_JSON5 : L_JSON;
549  	setLexerFromLangID(j);
550  	const TCHAR *pKwArray[10] = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL };
551  	makeStyle(L_JSON, pKwArray);
552  	string keywordList;
553  	string keywordList2;
554  	if (pKwArray[LANG_INDEX_INSTR])
555  	{
556  		wstring kwlW = pKwArray[LANG_INDEX_INSTR];
557  		keywordList = wstring2string(kwlW, CP_ACP);
558  	}
559  	if (pKwArray[LANG_INDEX_INSTR2])
560  	{
561  		wstring kwlW = pKwArray[LANG_INDEX_INSTR2];
562  		keywordList2 = wstring2string(kwlW, CP_ACP);
563  	}
564  	execute(SCI_SETKEYWORDS, 0, reinterpret_cast&lt;LPARAM&gt;(getCompleteKeywordList(keywordList, j, LANG_INDEX_INSTR)));
565  	execute(SCI_SETKEYWORDS, 1, reinterpret_cast&lt;LPARAM&gt;(getCompleteKeywordList(keywordList2, j, LANG_INDEX_INSTR2)));
566  	execute(SCI_SETPROPERTY, reinterpret_cast&lt;WPARAM&gt;(&quot;fold&quot;), reinterpret_cast&lt;LPARAM&gt;(&quot;1&quot;));
567  	execute(SCI_SETPROPERTY, reinterpret_cast&lt;WPARAM&gt;(&quot;fold.compact&quot;), reinterpret_cast&lt;LPARAM&gt;(&quot;0&quot;));
568  	if (j == L_JSON5)
569  		execute(SCI_SETPROPERTY, reinterpret_cast&lt;WPARAM&gt;(&quot;lexer.json.allow.comments&quot;), reinterpret_cast&lt;LPARAM&gt;(&quot;1&quot;));
570  }
571  void ScintillaEditView::setEmbeddedPhpLexer()
572  {
573  	const TCHAR *pKwArray[10] = {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};
574  	makeStyle(L_PHP, pKwArray);
575  	basic_string&lt;char&gt; keywordList(&quot;&quot;);
576  	if (pKwArray[LANG_INDEX_INSTR])
577  	{
578  		basic_string&lt;wchar_t&gt; kwlW = pKwArray[LANG_INDEX_INSTR];
579  		keywordList = wstring2string(kwlW, CP_ACP);
580  	}
581  	execute(SCI_SETKEYWORDS, 4, reinterpret_cast&lt;LPARAM&gt;(getCompleteKeywordList(keywordList, L_PHP, LANG_INDEX_INSTR)));
582  	execute(SCI_STYLESETEOLFILLED, SCE_HPHP_DEFAULT, true);
583  	execute(SCI_STYLESETEOLFILLED, SCE_HPHP_COMMENT, true);
584  }
585  void ScintillaEditView::setEmbeddedAspLexer()
586  {
587  	const TCHAR *pKwArray[10] = {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};
588  	makeStyle(L_ASP, pKwArray);
589  	basic_string&lt;char&gt; keywordList(&quot;&quot;);
590  	if (pKwArray[LANG_INDEX_INSTR])
591  	{
592  		basic_string&lt;wchar_t&gt; kwlW = pKwArray[LANG_INDEX_INSTR];
593  		keywordList = wstring2string(kwlW, CP_ACP);
594  	}
595  	execute(SCI_SETPROPERTY, reinterpret_cast&lt;WPARAM&gt;(&quot;asp.default.language&quot;), reinterpret_cast&lt;LPARAM&gt;(&quot;2&quot;));
596  	execute(SCI_SETKEYWORDS, 2, reinterpret_cast&lt;LPARAM&gt;(getCompleteKeywordList(keywordList, L_VB, LANG_INDEX_INSTR)));
597      execute(SCI_STYLESETEOLFILLED, SCE_HBA_DEFAULT, true);
598  }
599  void ScintillaEditView::setUserLexer(const TCHAR *userLangName)
600  {
601  	int setKeywordsCounter = 0;
602  	setLexerFromLangID(L_USER);
603  	UserLangContainer * userLangContainer = userLangName? NppParameters::getInstance().getULCFromName(userLangName):_userDefineDlg._pCurrentUserLang;
604  	if (!userLangContainer)
605  		return;
606  	UINT codepage = CP_ACP;
607  	UniMode unicodeMode = _currentBuffer-&gt;getUnicodeMode();
608  	int encoding = _currentBuffer-&gt;getEncoding();
609  	if (encoding == -1)
610  	{
611  		if (unicodeMode == uniUTF8 || unicodeMode == uniCookie)
612  			codepage = CP_UTF8;
613  	}
614  	else
615  	{
616  		codepage = CP_OEMCP;	
617  	}
618  	execute(SCI_SETPROPERTY, reinterpret_cast&lt;WPARAM&gt;(&quot;fold&quot;), reinterpret_cast&lt;LPARAM&gt;(&quot;1&quot;));
619  	execute(SCI_SETPROPERTY, reinterpret_cast&lt;WPARAM&gt;(&quot;userDefine.isCaseIgnored&quot;),		  reinterpret_cast&lt;LPARAM&gt;(userLangContainer-&gt;_isCaseIgnored ? &quot;1&quot;:&quot;0&quot;));
620  	execute(SCI_SETPROPERTY, reinterpret_cast&lt;WPARAM&gt;(&quot;userDefine.allowFoldOfComments&quot;),  reinterpret_cast&lt;LPARAM&gt;(userLangContainer-&gt;_allowFoldOfComments ? &quot;1&quot;:&quot;0&quot;));
621  	execute(SCI_SETPROPERTY, reinterpret_cast&lt;WPARAM&gt;(&quot;userDefine.foldCompact&quot;),		  reinterpret_cast&lt;LPARAM&gt;(userLangContainer-&gt;_foldCompact ? &quot;1&quot;:&quot;0&quot;));
622      char name[] = &quot;userDefine.prefixKeywords0&quot;;
623  	for (int i=0 ; i&lt;SCE_USER_TOTAL_KEYWORD_GROUPS ; ++i)
624  	{
625  		itoa(i+1, (name+25), 10);
626  		execute(SCI_SETPROPERTY, reinterpret_cast&lt;WPARAM&gt;(name), reinterpret_cast&lt;LPARAM&gt;(userLangContainer-&gt;_isPrefix[i] ? &quot;1&quot; : &quot;0&quot;));
627  	}
628  	char* temp = new char[max_char];
629  	for (int i = 0 ; i &lt; SCE_USER_KWLIST_TOTAL ; ++i)
630  	{
631  		WcharMbcsConvertor&amp; wmc = WcharMbcsConvertor::getInstance();
632  		const char * keyWords_char = wmc.wchar2char(userLangContainer-&gt;_keywordLists[i], codepage);
633  		if (globalMappper().setLexerMapper.find(i) != globalMappper().setLexerMapper.end())
634  		{
635  			execute(SCI_SETPROPERTY, reinterpret_cast&lt;WPARAM&gt;(globalMappper().setLexerMapper[i].c_str()), reinterpret_cast&lt;LPARAM&gt;(keyWords_char));
636  		}
637  		else 
638  		{
639  			bool inDoubleQuote = false;
640  			bool inSingleQuote = false;
641  			bool nonWSFound = false;
642  			int index = 0;
643  			for (size_t j=0, len = strlen(keyWords_char); j&lt;len &amp;&amp; index &lt; (max_char-1); ++j)
644  			{
645  				if (!inSingleQuote &amp;&amp; keyWords_char[j] == &#x27;&quot;&#x27;)
646  				{
647  					inDoubleQuote = !inDoubleQuote;
648  					continue;
649  				}
650  				if (!inDoubleQuote &amp;&amp; keyWords_char[j] == &#x27;\&#x27;&#x27;)
651  				{
652  					inSingleQuote = !inSingleQuote;
653  					continue;
654  				}
655  				if (keyWords_char[j] == &#x27;\\&#x27; &amp;&amp; (keyWords_char[j+1] == &#x27;&quot;&#x27; || keyWords_char[j+1] == &#x27;\&#x27;&#x27; || keyWords_char[j+1] == &#x27;\\&#x27;))
656  				{
657  					++j;
658  					temp[index++] = keyWords_char[j];
659  					continue;
660  				}
661  				if (inDoubleQuote || inSingleQuote)
662  				{
663  					if (keyWords_char[j] &gt; &#x27; &#x27;)		
664  					{
665  						temp[index++] = keyWords_char[j];
666  						if (nonWSFound == false)
667  							nonWSFound = true;
668  					}
669  					else if (nonWSFound == true &amp;&amp; keyWords_char[j-1] != &#x27;&quot;&#x27; &amp;&amp; keyWords_char[j+1] != &#x27;&quot;&#x27; &amp;&amp; keyWords_char[j+1] &gt; &#x27; &#x27;)
670  					{
671  						temp[index++] = inDoubleQuote ? &#x27;\v&#x27; : &#x27;\b&#x27;;
672  					}
673  					else
674  						continue;
675  				}
676  				else
677  				{
678  					temp[index++] = keyWords_char[j];
679  				}
680  			}
681  			temp[index++] = 0;
682  			execute(SCI_SETKEYWORDS, setKeywordsCounter++, reinterpret_cast&lt;LPARAM&gt;(temp));
683  		}
684  	}
685  	delete[] temp;
686   	char intBuffer[32];
687  	sprintf(intBuffer, &quot;%d&quot;, userLangContainer-&gt;_forcePureLC);
688  	execute(SCI_SETPROPERTY, reinterpret_cast&lt;WPARAM&gt;(&quot;userDefine.forcePureLC&quot;), reinterpret_cast&lt;LPARAM&gt;(intBuffer));
689  	sprintf(intBuffer, &quot;%d&quot;, userLangContainer-&gt;_decimalSeparator);
690  	execute(SCI_SETPROPERTY, reinterpret_cast&lt;WPARAM&gt;(&quot;userDefine.decimalSeparator&quot;), reinterpret_cast&lt;LPARAM&gt;(intBuffer));
691  	sprintf(intBuffer, &quot;%&quot; PRIuPTR, reinterpret_cast&lt;uintptr_t&gt;(userLangContainer-&gt;getName())); 
692  	execute(SCI_SETPROPERTY, reinterpret_cast&lt;WPARAM&gt;(&quot;userDefine.udlName&quot;), reinterpret_cast&lt;LPARAM&gt;(intBuffer));
693  	sprintf(intBuffer, &quot;%&quot; PRIuPTR, reinterpret_cast&lt;uintptr_t&gt;(_currentBufferID)); 
694      execute(SCI_SETPROPERTY, reinterpret_cast&lt;WPARAM&gt;(&quot;userDefine.currentBufferID&quot;), reinterpret_cast&lt;LPARAM&gt;(intBuffer));
695  	for (const Style &amp; style : userLangContainer-&gt;_styles)
696  	{
697  		if (style._styleID == STYLE_NOT_USED)
698  			continue;
699  		char nestingBuffer[32];
700  		sprintf(nestingBuffer, &quot;userDefine.nesting.%02d&quot;, style._styleID);
701  		sprintf(intBuffer, &quot;%d&quot;, style._nesting);
702  		execute(SCI_SETPROPERTY, reinterpret_cast&lt;WPARAM&gt;(nestingBuffer), reinterpret_cast&lt;LPARAM&gt;(intBuffer));
703  		setStyle(style);
704  	}
705  }
706  void ScintillaEditView::setExternalLexer(LangType typeDoc)
707  {
708  	int id = typeDoc - L_EXTERNAL;
709  	ExternalLangContainer&amp; externalLexer = NppParameters::getInstance().getELCFromIndex(id);
710  	if (!externalLexer.fnCL)
711  		return;
712  	ILexer5* iLex5 = externalLexer.fnCL(externalLexer._name.c_str());
713  	if (!iLex5)
714  		return;
715  	execute(SCI_SETILEXER, 0, reinterpret_cast&lt;LPARAM&gt;(iLex5));
716  	::SendMessage(_hParent, NPPM_INTERNAL_EXTERNALLEXERBUFFER, 0, (LPARAM)getCurrentBufferID());
717  	WcharMbcsConvertor&amp; wmc = WcharMbcsConvertor::getInstance();
718  	const wchar_t* lexerNameW = wmc.char2wchar(externalLexer._name.c_str(), CP_ACP);
719  	LexerStyler *pStyler = (NppParameters::getInstance().getLStylerArray()).getLexerStylerByName(lexerNameW);
720  	if (pStyler)
721  	{
722  		for (const Style &amp; style : *pStyler)
723  		{
724  			setStyle(style);
725  			if (style._keywordClass &gt;= 0 &amp;&amp; style._keywordClass &lt;= KEYWORDSET_MAX)
726  			{
727  				basic_string&lt;char&gt; keywordList(&quot;&quot;);
728  				if (!style._keywords.empty())
729  				{
730  					keywordList = wstring2string(style._keywords, CP_ACP);
731  				}
732  				execute(SCI_SETKEYWORDS, style._keywordClass, reinterpret_cast&lt;LPARAM&gt;(getCompleteKeywordList(keywordList, typeDoc, style._keywordClass)));
733  			}
734  		}
735  	}
736  }
737  void ScintillaEditView::setCppLexer(LangType langType)
738  {
739      const char *cppInstrs;
740      const char *cppTypes;
741      const TCHAR *doxygenKeyWords  = NppParameters::getInstance().getWordList(L_CPP, LANG_INDEX_TYPE2);
742      setLexerFromLangID(L_CPP);
743  	if (langType != L_RC)
744      {
745          if (doxygenKeyWords)
746  		{
747  			WcharMbcsConvertor&amp; wmc = WcharMbcsConvertor::getInstance();
748  			const char * doxygenKeyWords_char = wmc.wchar2char(doxygenKeyWords, CP_ACP);
749  			execute(SCI_SETKEYWORDS, 2, reinterpret_cast&lt;LPARAM&gt;(doxygenKeyWords_char));
750  		}
751      }
752  	const TCHAR *pKwArray[10] = {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};
753  	makeStyle(langType, pKwArray);
754  	basic_string&lt;char&gt; keywordListInstruction(&quot;&quot;);
755  	basic_string&lt;char&gt; keywordListType(&quot;&quot;);
756  	if (pKwArray[LANG_INDEX_INSTR])
757  	{
758  		basic_string&lt;wchar_t&gt; kwlW = pKwArray[LANG_INDEX_INSTR];
759  		keywordListInstruction = wstring2string(kwlW, CP_ACP);
760  	}
761  	cppInstrs = getCompleteKeywordList(keywordListInstruction, langType, LANG_INDEX_INSTR);
762  	if (pKwArray[LANG_INDEX_TYPE])
763  	{
764  		basic_string&lt;wchar_t&gt; kwlW = pKwArray[LANG_INDEX_TYPE];
765  		keywordListType = wstring2string(kwlW, CP_ACP);
766  	}
767  	cppTypes = getCompleteKeywordList(keywordListType, langType, LANG_INDEX_TYPE);
768  	execute(SCI_SETKEYWORDS, 0, reinterpret_cast&lt;LPARAM&gt;(cppInstrs));
769  	execute(SCI_SETKEYWORDS, 1, reinterpret_cast&lt;LPARAM&gt;(cppTypes));
770  	execute(SCI_SETPROPERTY, reinterpret_cast&lt;WPARAM&gt;(&quot;fold&quot;), reinterpret_cast&lt;LPARAM&gt;(&quot;1&quot;));
771  	execute(SCI_SETPROPERTY, reinterpret_cast&lt;WPARAM&gt;(&quot;fold.compact&quot;), reinterpret_cast&lt;LPARAM&gt;(&quot;0&quot;));
772  	execute(SCI_SETPROPERTY, reinterpret_cast&lt;WPARAM&gt;(&quot;fold.comment&quot;), reinterpret_cast&lt;LPARAM&gt;(&quot;1&quot;));
773  	execute(SCI_SETPROPERTY, reinterpret_cast&lt;WPARAM&gt;(&quot;fold.cpp.comment.explicit&quot;), reinterpret_cast&lt;LPARAM&gt;(&quot;0&quot;));
774  	execute(SCI_SETPROPERTY, reinterpret_cast&lt;WPARAM&gt;(&quot;fold.preprocessor&quot;), reinterpret_cast&lt;LPARAM&gt;(&quot;1&quot;));
775  	execute(SCI_SETPROPERTY, reinterpret_cast&lt;WPARAM&gt;(&quot;lexer.cpp.track.preprocessor&quot;), reinterpret_cast&lt;LPARAM&gt;(&quot;0&quot;));
776  }
777  void ScintillaEditView::setJsLexer()
778  {
779  	const TCHAR *doxygenKeyWords = NppParameters::getInstance().getWordList(L_CPP, LANG_INDEX_TYPE2);
780  	setLexerFromLangID(L_JAVASCRIPT);
781  	const TCHAR *pKwArray[10] = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL };
782  	makeStyle(L_JAVASCRIPT, pKwArray);
783  	if (doxygenKeyWords)
784  	{
785  		WcharMbcsConvertor&amp; wmc = WcharMbcsConvertor::getInstance();
786  		const char * doxygenKeyWords_char = wmc.wchar2char(doxygenKeyWords, CP_ACP);
787  		execute(SCI_SETKEYWORDS, 2, reinterpret_cast&lt;LPARAM&gt;(doxygenKeyWords_char));
788  	}
789  	const TCHAR *newLexerName = ScintillaEditView::_langNameInfoArray[L_JAVASCRIPT]._langName;
790  	LexerStyler *pNewStyler = (NppParameters::getInstance().getLStylerArray()).getLexerStylerByName(newLexerName);
791  	if (pNewStyler) 
792  	{
793  		for (const Style &amp; style : *pNewStyler)
794  		{
795  			setStyle(style);
796  		}
797  		basic_string&lt;char&gt; keywordListInstruction(&quot;&quot;);
798  		basic_string&lt;char&gt; keywordListType(&quot;&quot;);
799  		basic_string&lt;char&gt; keywordListInstruction2(&quot;&quot;);
800  		if (pKwArray[LANG_INDEX_INSTR])
801  		{
802  			basic_string&lt;wchar_t&gt; kwlW = pKwArray[LANG_INDEX_INSTR];
803  			keywordListInstruction = wstring2string(kwlW, CP_ACP);
804  		}
805  		const char *jsInstrs = getCompleteKeywordList(keywordListInstruction, L_JAVASCRIPT, LANG_INDEX_INSTR);
806  		if (pKwArray[LANG_INDEX_TYPE])
807  		{
808  			basic_string&lt;wchar_t&gt; kwlW = pKwArray[LANG_INDEX_TYPE];
809  			keywordListType = wstring2string(kwlW, CP_ACP);
810  		}
811  		const char *jsTypes = getCompleteKeywordList(keywordListType, L_JAVASCRIPT, LANG_INDEX_TYPE);
812  		if (pKwArray[LANG_INDEX_INSTR2])
813  		{
814  			basic_string&lt;wchar_t&gt; kwlW = pKwArray[LANG_INDEX_INSTR2];
815  			keywordListInstruction2 = wstring2string(kwlW, CP_ACP);
816  		}
817  		const char *jsInstrs2 = getCompleteKeywordList(keywordListInstruction2, L_JAVASCRIPT, LANG_INDEX_INSTR2);
818  		execute(SCI_SETKEYWORDS, 0, reinterpret_cast&lt;LPARAM&gt;(jsInstrs));
819  		execute(SCI_SETKEYWORDS, 1, reinterpret_cast&lt;LPARAM&gt;(jsTypes));
820  		execute(SCI_SETKEYWORDS, 3, reinterpret_cast&lt;LPARAM&gt;(jsInstrs2));
821  	}
822  	else 
823  	{
824  		const TCHAR *lexerName = ScintillaEditView::_langNameInfoArray[L_JS]._langName;
825  		LexerStyler *pOldStyler = (NppParameters::getInstance().getLStylerArray()).getLexerStylerByName(lexerName);
826  		if (pOldStyler)
827  		{
828  			for (Style style : *pOldStyler) 
829  			{
<span onclick='openModal()' class='match'>830  				int cppID = style._styleID;
831  				switch (style._styleID)
832  				{
833  					case SCE_HJ_DEFAULT: cppID = SCE_C_DEFAULT; break;
</span>834  					case SCE_HJ_WORD: cppID = SCE_C_IDENTIFIER; break;
835  					case SCE_HJ_SYMBOLS: cppID = SCE_C_OPERATOR; break;
836  					case SCE_HJ_COMMENT: cppID = SCE_C_COMMENT; break;
837  					case SCE_HJ_COMMENTLINE: cppID = SCE_C_COMMENTLINE; break;
838  					case SCE_HJ_COMMENTDOC: cppID = SCE_C_COMMENTDOC; break;
839  					case SCE_HJ_NUMBER: cppID = SCE_C_NUMBER; break;
840  					case SCE_HJ_KEYWORD: cppID = SCE_C_WORD; break;
841  					case SCE_HJ_DOUBLESTRING: cppID = SCE_C_STRING; break;
842  					case SCE_HJ_SINGLESTRING: cppID = SCE_C_CHARACTER; break;
843  					case SCE_HJ_REGEX: cppID = SCE_C_REGEX; break;
844  				}
845  				style._styleID = cppID;
846  				setStyle(style);
847  			}
848  		}
849  		execute(SCI_STYLESETEOLFILLED, SCE_C_DEFAULT, true);
850  		execute(SCI_STYLESETEOLFILLED, SCE_C_COMMENTLINE, true);
851  		execute(SCI_STYLESETEOLFILLED, SCE_C_COMMENT, true);
852  		execute(SCI_STYLESETEOLFILLED, SCE_C_COMMENTDOC, true);
853  		makeStyle(L_JS, pKwArray);
854  		basic_string&lt;char&gt; keywordListInstruction(&quot;&quot;);
855  		if (pKwArray[LANG_INDEX_INSTR])
856  		{
857  			basic_string&lt;wchar_t&gt; kwlW = pKwArray[LANG_INDEX_INSTR];
858  			keywordListInstruction = wstring2string(kwlW, CP_ACP);
859  		}
860  		const char *jsEmbeddedInstrs = getCompleteKeywordList(keywordListInstruction, L_JS, LANG_INDEX_INSTR);
861  		execute(SCI_SETKEYWORDS, 0, reinterpret_cast&lt;LPARAM&gt;(jsEmbeddedInstrs));
862  	}
863  	execute(SCI_SETPROPERTY, reinterpret_cast&lt;WPARAM&gt;(&quot;fold&quot;), reinterpret_cast&lt;LPARAM&gt;(&quot;1&quot;));
864  	execute(SCI_SETPROPERTY, reinterpret_cast&lt;WPARAM&gt;(&quot;fold.compact&quot;), reinterpret_cast&lt;LPARAM&gt;(&quot;0&quot;));
865  	execute(SCI_SETPROPERTY, reinterpret_cast&lt;WPARAM&gt;(&quot;fold.comment&quot;), reinterpret_cast&lt;LPARAM&gt;(&quot;1&quot;));
866  	execute(SCI_SETPROPERTY, reinterpret_cast&lt;WPARAM&gt;(&quot;fold.cpp.comment.explicit&quot;), reinterpret_cast&lt;LPARAM&gt;(&quot;0&quot;));
867  	execute(SCI_SETPROPERTY, reinterpret_cast&lt;WPARAM&gt;(&quot;fold.preprocessor&quot;), reinterpret_cast&lt;LPARAM&gt;(&quot;1&quot;));
868  	execute(SCI_SETPROPERTY, reinterpret_cast&lt;WPARAM&gt;(&quot;lexer.cpp.track.preprocessor&quot;), reinterpret_cast&lt;LPARAM&gt;(&quot;0&quot;));
869  	execute(SCI_SETPROPERTY, reinterpret_cast&lt;WPARAM&gt;(&quot;lexer.cpp.backquoted.strings&quot;), reinterpret_cast&lt;LPARAM&gt;(&quot;1&quot;));
870  }
871  void ScintillaEditView::setTclLexer()
872  {
873  	const char *tclInstrs;
874      const char *tclTypes;
875  	setLexerFromLangID(L_TCL);
876  	const TCHAR *pKwArray[10] = {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};
877  	makeStyle(L_TCL, pKwArray);
878  	basic_string&lt;char&gt; keywordListInstruction(&quot;&quot;);
879  	basic_string&lt;char&gt; keywordListType(&quot;&quot;);
880  	if (pKwArray[LANG_INDEX_INSTR])
881  	{
882  		basic_string&lt;wchar_t&gt; kwlW = pKwArray[LANG_INDEX_INSTR];
883  		keywordListInstruction = wstring2string(kwlW, CP_ACP);
884  	}
885  	tclInstrs = getCompleteKeywordList(keywordListInstruction, L_TCL, LANG_INDEX_INSTR);
886  	if (pKwArray[LANG_INDEX_TYPE])
887  	{
888  		basic_string&lt;wchar_t&gt; kwlW = pKwArray[LANG_INDEX_TYPE];
889  		keywordListType = wstring2string(kwlW, CP_ACP);
890  	}
891  	tclTypes = getCompleteKeywordList(keywordListType, L_TCL, LANG_INDEX_TYPE);
892  	execute(SCI_SETKEYWORDS, 0, reinterpret_cast&lt;LPARAM&gt;(tclInstrs));
893  	execute(SCI_SETKEYWORDS, 1, reinterpret_cast&lt;LPARAM&gt;(tclTypes));
894  }
895  void ScintillaEditView::setObjCLexer(LangType langType)
896  {
897  	setLexerFromLangID(L_OBJC);
898  	const TCHAR *pKwArray[10] = {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};
899  	makeStyle(langType, pKwArray);
900  	basic_string&lt;char&gt; objcInstr1Kwl(&quot;&quot;);
901  	if (pKwArray[LANG_INDEX_INSTR])
902  	{
903  		objcInstr1Kwl = wstring2string(pKwArray[LANG_INDEX_INSTR], CP_ACP);
904  	}
905  	const char *objcInstrs = getCompleteKeywordList(objcInstr1Kwl, langType, LANG_INDEX_INSTR);
906  	basic_string&lt;char&gt; objcInstr2Kwl(&quot;&quot;);
907  	if (pKwArray[LANG_INDEX_INSTR2])
908  	{
909  		objcInstr2Kwl = wstring2string(pKwArray[LANG_INDEX_INSTR2], CP_ACP);
910  	}
911  	const char *objCDirective = getCompleteKeywordList(objcInstr2Kwl, langType, LANG_INDEX_INSTR2);
912  	basic_string&lt;char&gt; objcTypeKwl(&quot;&quot;);
913  	if (pKwArray[LANG_INDEX_TYPE])
914  	{
915  		objcTypeKwl = wstring2string(pKwArray[LANG_INDEX_TYPE], CP_ACP);
916  	}
917  	const char *objcTypes = getCompleteKeywordList(objcTypeKwl, langType, LANG_INDEX_TYPE);
918  	basic_string&lt;char&gt; objcType2Kwl(&quot;&quot;);
919  	if (pKwArray[LANG_INDEX_TYPE2])
920  	{
921  		objcType2Kwl = wstring2string(pKwArray[LANG_INDEX_TYPE2], CP_ACP);
922  	}
923  	const char *objCQualifier = getCompleteKeywordList(objcType2Kwl, langType, LANG_INDEX_TYPE2);
924  	basic_string&lt;char&gt; doxygenKeyWordsString(&quot;&quot;);
925  	const TCHAR *doxygenKeyWordsW = NppParameters::getInstance().getWordList(L_CPP, LANG_INDEX_TYPE2);
926  	if (doxygenKeyWordsW)
927  	{
928  		doxygenKeyWordsString = wstring2string(doxygenKeyWordsW, CP_ACP);
929  	}
930  	const char *doxygenKeyWords = doxygenKeyWordsString.c_str();
931  	execute(SCI_SETKEYWORDS, 0, reinterpret_cast&lt;LPARAM&gt;(objcInstrs));
932      execute(SCI_SETKEYWORDS, 1, reinterpret_cast&lt;LPARAM&gt;(objcTypes));
933  	execute(SCI_SETKEYWORDS, 2, reinterpret_cast&lt;LPARAM&gt;(doxygenKeyWords));
934  	execute(SCI_SETKEYWORDS, 3, reinterpret_cast&lt;LPARAM&gt;(objCDirective));
935  	execute(SCI_SETKEYWORDS, 4, reinterpret_cast&lt;LPARAM&gt;(objCQualifier));
936  	execute(SCI_SETPROPERTY, reinterpret_cast&lt;WPARAM&gt;(&quot;fold&quot;), reinterpret_cast&lt;LPARAM&gt;(&quot;1&quot;));
937  	execute(SCI_SETPROPERTY, reinterpret_cast&lt;WPARAM&gt;(&quot;fold.compact&quot;), reinterpret_cast&lt;LPARAM&gt;(&quot;0&quot;));
938  	execute(SCI_SETPROPERTY, reinterpret_cast&lt;WPARAM&gt;(&quot;fold.comment&quot;), reinterpret_cast&lt;LPARAM&gt;(&quot;1&quot;));
939  	execute(SCI_SETPROPERTY, reinterpret_cast&lt;WPARAM&gt;(&quot;fold.cpp.comment.explicit&quot;), reinterpret_cast&lt;LPARAM&gt;(&quot;0&quot;));
940  	execute(SCI_SETPROPERTY, reinterpret_cast&lt;WPARAM&gt;(&quot;fold.preprocessor&quot;), reinterpret_cast&lt;LPARAM&gt;(&quot;1&quot;));
941  }
942  void ScintillaEditView::setTypeScriptLexer()
943  {
944  	const TCHAR* doxygenKeyWords = NppParameters::getInstance().getWordList(L_CPP, LANG_INDEX_TYPE2);
945  	setLexerFromLangID(L_TYPESCRIPT);
946  	if (doxygenKeyWords)
947  	{
948  		WcharMbcsConvertor&amp; wmc = WcharMbcsConvertor::getInstance();
949  		const char* doxygenKeyWords_char = wmc.wchar2char(doxygenKeyWords, CP_ACP);
950  		execute(SCI_SETKEYWORDS, 2, reinterpret_cast&lt;LPARAM&gt;(doxygenKeyWords_char));
951  	}
952  	const TCHAR* pKwArray[10] = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL };
953  	makeStyle(L_TYPESCRIPT, pKwArray);
954  	auto getKeywordList = [&amp;pKwArray](const int i) 
955  	{
956  		if (pKwArray[i])
957  		{
958  			basic_string&lt;wchar_t&gt; kwlW = pKwArray[i];
959  			return wstring2string(kwlW, CP_ACP);
960  		}
961  		return basic_string&lt;char&gt;(&quot;&quot;);
962  	};
963  	std::string keywordListInstruction = getKeywordList(LANG_INDEX_INSTR);
964  	const char* tsInstructions = getCompleteKeywordList(keywordListInstruction, L_TYPESCRIPT, LANG_INDEX_INSTR);
965  	string keywordListType = getKeywordList(LANG_INDEX_TYPE);
966  	const char* tsTypes = getCompleteKeywordList(keywordListType, L_TYPESCRIPT, LANG_INDEX_TYPE);
967  	execute(SCI_SETKEYWORDS, 0, reinterpret_cast&lt;LPARAM&gt;(tsInstructions));
968  	execute(SCI_SETKEYWORDS, 1, reinterpret_cast&lt;LPARAM&gt;(tsTypes));
969  	execute(SCI_SETPROPERTY, reinterpret_cast&lt;WPARAM&gt;(&quot;fold&quot;), reinterpret_cast&lt;LPARAM&gt;(&quot;1&quot;));
970  	execute(SCI_SETPROPERTY, reinterpret_cast&lt;WPARAM&gt;(&quot;fold.compact&quot;), reinterpret_cast&lt;LPARAM&gt;(&quot;0&quot;));
971  	execute(SCI_SETPROPERTY, reinterpret_cast&lt;WPARAM&gt;(&quot;fold.comment&quot;), reinterpret_cast&lt;LPARAM&gt;(&quot;1&quot;));
972  	execute(SCI_SETPROPERTY, reinterpret_cast&lt;WPARAM&gt;(&quot;fold.cpp.comment.explicit&quot;), reinterpret_cast&lt;LPARAM&gt;(&quot;0&quot;));
973  	execute(SCI_SETPROPERTY, reinterpret_cast&lt;WPARAM&gt;(&quot;fold.preprocessor&quot;), reinterpret_cast&lt;LPARAM&gt;(&quot;1&quot;));
974  	execute(SCI_SETPROPERTY, reinterpret_cast&lt;WPARAM&gt;(&quot;lexer.cpp.track.preprocessor&quot;), reinterpret_cast&lt;LPARAM&gt;(&quot;0&quot;));
975  	execute(SCI_SETPROPERTY, reinterpret_cast&lt;WPARAM&gt;(&quot;lexer.cpp.backquoted.strings&quot;), reinterpret_cast&lt;LPARAM&gt;(&quot;1&quot;));
976  }
977  void ScintillaEditView::setKeywords(LangType langType, const char *keywords, int index)
978  {
979  	std::basic_string&lt;char&gt; wordList;
980  	wordList = (keywords)?keywords:&quot;&quot;;
981  	execute(SCI_SETKEYWORDS, index, reinterpret_cast&lt;LPARAM&gt;(getCompleteKeywordList(wordList, langType, index)));
982  }
983  void ScintillaEditView::setLexer(LangType langType, int whichList)
984  {
985  	setLexerFromLangID(langType);
986  	const TCHAR *pKwArray[10] = {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};
987  	makeStyle(langType, pKwArray);
988  	WcharMbcsConvertor&amp; wmc = WcharMbcsConvertor::getInstance();
989  	if (whichList &amp; LIST_0)
990  	{
991  		const char * keyWords_char = wmc.wchar2char(pKwArray[LANG_INDEX_INSTR], CP_ACP);
992  		setKeywords(langType, keyWords_char, LANG_INDEX_INSTR);
993  	}
994  	if (whichList &amp; LIST_1)
995  	{
996  		const char * keyWords_char = wmc.wchar2char(pKwArray[LANG_INDEX_INSTR2], CP_ACP);
997  		setKeywords(langType, keyWords_char, LANG_INDEX_INSTR2);
998  	}
999  	if (whichList &amp; LIST_2)
1000  	{
1001  		const char * keyWords_char = wmc.wchar2char(pKwArray[LANG_INDEX_TYPE], CP_ACP);
1002  		setKeywords(langType, keyWords_char, LANG_INDEX_TYPE);
1003  	}
1004  	if (whichList &amp; LIST_3)
1005  	{
1006  		const char * keyWords_char = wmc.wchar2char(pKwArray[LANG_INDEX_TYPE2], CP_ACP);
1007  		setKeywords(langType, keyWords_char, LANG_INDEX_TYPE2);
1008  	}
1009  	if (whichList &amp; LIST_4)
1010  	{
1011  		const char * keyWords_char = wmc.wchar2char(pKwArray[LANG_INDEX_TYPE3], CP_ACP);
1012  		setKeywords(langType, keyWords_char, LANG_INDEX_TYPE3);
1013  	}
1014  	if (whichList &amp; LIST_5)
1015  	{
1016  		const char * keyWords_char = wmc.wchar2char(pKwArray[LANG_INDEX_TYPE4], CP_ACP);
1017  		setKeywords(langType, keyWords_char, LANG_INDEX_TYPE4);
1018  	}
1019  	if (whichList &amp; LIST_6)
1020  	{
1021  		const char * keyWords_char = wmc.wchar2char(pKwArray[LANG_INDEX_TYPE5], CP_ACP);
1022  		setKeywords(langType, keyWords_char, LANG_INDEX_TYPE5);
1023  	}
1024  	if (whichList &amp; LIST_7)
1025  	{
1026  		const char * keyWords_char = wmc.wchar2char(pKwArray[LANG_INDEX_TYPE6], CP_ACP);
1027  		setKeywords(langType, keyWords_char, LANG_INDEX_TYPE6);
1028  	}
1029  	if (whichList &amp; LIST_8)
1030  	{
1031  		const char * keyWords_char = wmc.wchar2char(pKwArray[LANG_INDEX_TYPE7], CP_ACP);
1032  		setKeywords(langType, keyWords_char, LANG_INDEX_TYPE7);
1033  	}
1034  	execute(SCI_SETPROPERTY, reinterpret_cast&lt;WPARAM&gt;(&quot;fold&quot;), reinterpret_cast&lt;LPARAM&gt;(&quot;1&quot;));
1035  	execute(SCI_SETPROPERTY, reinterpret_cast&lt;WPARAM&gt;(&quot;fold.compact&quot;), reinterpret_cast&lt;LPARAM&gt;(&quot;0&quot;));
1036  	execute(SCI_SETPROPERTY, reinterpret_cast&lt;WPARAM&gt;(&quot;fold.comment&quot;), reinterpret_cast&lt;LPARAM&gt;(&quot;1&quot;));
1037  }
1038  void ScintillaEditView::makeStyle(LangType language, const TCHAR **keywordArray)
1039  {
1040  	const TCHAR * lexerName = ScintillaEditView::_langNameInfoArray[language]._langName;
1041  	LexerStyler *pStyler = (NppParameters::getInstance().getLStylerArray()).getLexerStylerByName(lexerName);
1042  	if (pStyler)
1043  	{
1044  		for (const Style &amp; style : *pStyler)
1045  		{
1046  			setStyle(style);
1047  			if (keywordArray)
1048  			{
1049  				if ((style._keywordClass != STYLE_NOT_USED) &amp;&amp; (!style._keywords.empty()))
1050  					keywordArray[style._keywordClass] = style._keywords.c_str();
1051  			}
1052  		}
1053  	}
1054  }
1055  void ScintillaEditView::restoreDefaultWordChars()
1056  {
1057  	execute(SCI_SETWORDCHARS, 0, reinterpret_cast&lt;LPARAM&gt;(_defaultCharList.c_str()));
1058  }
1059  void ScintillaEditView::addCustomWordChars()
1060  {
1061  	NppParameters&amp; nppParam = NppParameters::getInstance();
1062  	const NppGUI &amp; nppGUI = nppParam.getNppGUI();
1063  	if (nppGUI._customWordChars.empty())
1064  		return;
1065  	string chars2addStr;
1066  	for (size_t i = 0; i &lt; nppGUI._customWordChars.length(); ++i)
1067  	{
1068  		bool found = false;
1069  		char char2check = nppGUI._customWordChars[i];
1070  		for (size_t j = 0; j &lt; _defaultCharList.length(); ++j)
1071  		{
1072  			char wordChar = _defaultCharList[j];
1073  			if (char2check == wordChar)
1074  			{
1075  				found = true;
1076  				break;
1077  			}
1078  		}
1079  		if (!found)
1080  		{
1081  			chars2addStr.push_back(char2check);
1082  		}
1083  	}
1084  	if (!chars2addStr.empty())
1085  	{
1086  		string newCharList = _defaultCharList;
1087  		newCharList += chars2addStr;
1088  		execute(SCI_SETWORDCHARS, 0, reinterpret_cast&lt;LPARAM&gt;(newCharList.c_str()));
1089  	}
1090  }
1091  void ScintillaEditView::setWordChars()
1092  {
1093  	NppParameters&amp; nppParam = NppParameters::getInstance();
1094  	const NppGUI &amp; nppGUI = nppParam.getNppGUI();
1095  	if (nppGUI._isWordCharDefault)
1096  		restoreDefaultWordChars();
1097  	else
1098  		addCustomWordChars();
1099  }
1100  void ScintillaEditView::setCRLF(long color)
1101  {
1102  	NppParameters&amp; nppParams = NppParameters::getInstance();
1103  	const ScintillaViewParams&amp; svp = nppParams.getSVP();
1104  	COLORREF eolCustomColor = liteGrey;
1105  	if (color == -1)
1106  	{
1107  		StyleArray&amp; stylers = nppParams.getMiscStylerArray();
1108  		Style* pStyle = stylers.findByName(TEXT(&quot;EOL custom color&quot;));
1109  		if (pStyle)
1110  		{
1111  			eolCustomColor = pStyle-&gt;_fgColor;
1112  		}
1113  	}
1114  	else
1115  	{
1116  		eolCustomColor = color;
1117  	}
1118  	ScintillaViewParams::crlfMode eolMode = svp._eolMode;
1119  	long appearance = SC_REPRESENTATION_BLOB;
1120  	if (eolMode == ScintillaViewParams::crlfMode::plainText)
1121  		appearance = SC_REPRESENTATION_PLAIN;
1122  	else if (eolMode == ScintillaViewParams::crlfMode::plainTextCustomColor)
1123  		appearance = SC_REPRESENTATION_PLAIN | SC_REPRESENTATION_COLOUR;
1124  	else if (eolMode == ScintillaViewParams::crlfMode::roundedRectangleText)
1125  		appearance = SC_REPRESENTATION_BLOB;
1126  	else if (eolMode == ScintillaViewParams::crlfMode::roundedRectangleTextCustomColor)
1127  		appearance = SC_REPRESENTATION_BLOB | SC_REPRESENTATION_COLOUR;
1128  	const wchar_t* cr = L&quot;\x0d&quot;;
1129  	const wchar_t* lf = L&quot;\x0a&quot;;
1130  	long alphaEolCustomColor = eolCustomColor;
1131  	alphaEolCustomColor |= 0xFF000000; 
1132  	execute(SCI_SETREPRESENTATIONCOLOUR, reinterpret_cast&lt;WPARAM&gt;(cr), alphaEolCustomColor);
1133  	execute(SCI_SETREPRESENTATIONCOLOUR, reinterpret_cast&lt;WPARAM&gt;(lf), alphaEolCustomColor);
1134  	execute(SCI_SETREPRESENTATIONAPPEARANCE, reinterpret_cast&lt;WPARAM&gt;(cr), appearance);
1135  	execute(SCI_SETREPRESENTATIONAPPEARANCE, reinterpret_cast&lt;WPARAM&gt;(lf), appearance);
1136  	redraw();
1137  }
1138  void ScintillaEditView::setNpcAndCcUniEOL(long color)
1139  {
1140  	NppParameters&amp; nppParams = NppParameters::getInstance();
1141  	const ScintillaViewParams&amp; svp = nppParams.getSVP();
1142  	COLORREF npcCustomColor = liteGrey;
1143  	if (color == -1)
1144  	{
1145  		StyleArray&amp; stylers = nppParams.getMiscStylerArray();
1146  		Style* pStyle = stylers.findByName(g_npcStyleName);
1147  		if (pStyle)
1148  		{
1149  			npcCustomColor = pStyle-&gt;_fgColor;
1150  		}
1151  	}
1152  	else
1153  	{
1154  		npcCustomColor = color;
1155  	}
1156  	const long appearance = svp._npcCustomColor ? SC_REPRESENTATION_BLOB | SC_REPRESENTATION_COLOUR : SC_REPRESENTATION_BLOB;
1157  	const long alphaNpcCustomColor = npcCustomColor | 0xFF000000; 
1158  	if (svp._npcShow)
1159  	{
1160  		for (const auto&amp; invChar : g_nonPrintingChars)
1161  		{
1162  			execute(SCI_SETREPRESENTATIONCOLOUR, reinterpret_cast&lt;WPARAM&gt;(invChar.at(0)), alphaNpcCustomColor);
1163  			execute(SCI_SETREPRESENTATIONAPPEARANCE, reinterpret_cast&lt;WPARAM&gt;(invChar.at(0)), appearance);
1164  		}
1165  	}
1166  	if (svp._ccUniEolShow &amp;&amp; svp._npcIncludeCcUniEol)
1167  	{
1168  		for (const auto&amp; invChar : g_ccUniEolChars)
1169  		{
1170  			execute(SCI_SETREPRESENTATIONCOLOUR, reinterpret_cast&lt;WPARAM&gt;(invChar.at(0)), alphaNpcCustomColor);
1171  			execute(SCI_SETREPRESENTATIONAPPEARANCE, reinterpret_cast&lt;WPARAM&gt;(invChar.at(0)), appearance);
1172  		}
1173  	}
1174  	redraw();
1175  }
1176  void ScintillaEditView::defineDocType(LangType typeDoc)
1177  {
1178  	StyleArray &amp; stylers = NppParameters::getInstance().getMiscStylerArray();
1179  	Style * pStyleDefault = stylers.findByID(STYLE_DEFAULT);
1180  	if (pStyleDefault)
1181  	{
1182  		pStyleDefault-&gt;_colorStyle = COLORSTYLE_ALL;	
1183  		setStyle(*pStyleDefault);
1184  	}
1185  	execute(SCI_STYLECLEARALL);
1186  	Style defaultIndicatorStyle;
1187  	const Style * pStyle;
1188  	defaultIndicatorStyle._styleID = SCE_UNIVERSAL_FOUND_STYLE;
1189  	defaultIndicatorStyle._bgColor = red;
1190  	pStyle = stylers.findByID(defaultIndicatorStyle._styleID);
1191  	setSpecialIndicator(pStyle ? *pStyle : defaultIndicatorStyle);
1192  	defaultIndicatorStyle._styleID = SCE_UNIVERSAL_FOUND_STYLE_SMART;
1193  	defaultIndicatorStyle._bgColor = liteGreen;
1194  	pStyle = stylers.findByID(defaultIndicatorStyle._styleID);
1195  	setSpecialIndicator(pStyle ? *pStyle : defaultIndicatorStyle);
1196  	defaultIndicatorStyle._styleID = SCE_UNIVERSAL_FOUND_STYLE_INC;
1197  	defaultIndicatorStyle._bgColor = blue;
1198  	pStyle = stylers.findByID(defaultIndicatorStyle._styleID);
1199  	setSpecialIndicator(pStyle ? *pStyle : defaultIndicatorStyle);
1200  	defaultIndicatorStyle._styleID = SCE_UNIVERSAL_TAGMATCH;
1201  	defaultIndicatorStyle._bgColor = RGB(0x80, 0x00, 0xFF);
1202  	pStyle = stylers.findByID(defaultIndicatorStyle._styleID);
1203  	setSpecialIndicator(pStyle ? *pStyle : defaultIndicatorStyle);
1204  	defaultIndicatorStyle._styleID = SCE_UNIVERSAL_TAGATTR;
1205  	defaultIndicatorStyle._bgColor = yellow;
1206  	pStyle = stylers.findByID(defaultIndicatorStyle._styleID);
1207  	setSpecialIndicator(pStyle ? *pStyle : defaultIndicatorStyle);
1208  	defaultIndicatorStyle._styleID = SCE_UNIVERSAL_FOUND_STYLE_EXT1;
1209  	defaultIndicatorStyle._bgColor = cyan;
1210  	pStyle = stylers.findByID(defaultIndicatorStyle._styleID);
1211  	setSpecialIndicator(pStyle ? *pStyle : defaultIndicatorStyle);
1212  	defaultIndicatorStyle._styleID = SCE_UNIVERSAL_FOUND_STYLE_EXT2;
1213  	defaultIndicatorStyle._bgColor = orange;
1214  	pStyle = stylers.findByID(defaultIndicatorStyle._styleID);
1215  	setSpecialIndicator(pStyle ? *pStyle : defaultIndicatorStyle);
1216  	defaultIndicatorStyle._styleID = SCE_UNIVERSAL_FOUND_STYLE_EXT3;
1217  	defaultIndicatorStyle._bgColor = yellow;
1218  	pStyle = stylers.findByID(defaultIndicatorStyle._styleID);
1219  	setSpecialIndicator(pStyle ? *pStyle : defaultIndicatorStyle);
1220  	defaultIndicatorStyle._styleID = SCE_UNIVERSAL_FOUND_STYLE_EXT4;
1221  	defaultIndicatorStyle._bgColor = purple;
1222  	pStyle = stylers.findByID(defaultIndicatorStyle._styleID);
1223  	setSpecialIndicator(pStyle ? *pStyle : defaultIndicatorStyle);
1224  	defaultIndicatorStyle._styleID = SCE_UNIVERSAL_FOUND_STYLE_EXT5;
1225  	defaultIndicatorStyle._bgColor = darkGreen;
1226  	pStyle = stylers.findByID(defaultIndicatorStyle._styleID);
1227  	setSpecialIndicator(pStyle ? *pStyle : defaultIndicatorStyle);
1228  	if (isCJK())
1229  	{
1230  		if (getCurrentBuffer()-&gt;getUnicodeMode() == uni8Bit)
1231  		{
1232  			if (typeDoc == L_CSS || typeDoc == L_CAML || typeDoc == L_ASM || typeDoc == L_MATLAB)
1233  				execute(SCI_SETCODEPAGE, CP_ACP);
1234  			else
1235  				execute(SCI_SETCODEPAGE, _codepage);
1236  		}
1237  	}
1238  	ScintillaViewParams &amp; svp = (ScintillaViewParams &amp;)NppParameters::getInstance().getSVP();
1239  	if (svp._folderStyle != FOLDER_STYLE_NONE)
1240  		showMargin(_SC_MARGE_FOLDER, isNeededFolderMarge(typeDoc));
1241  	switch (typeDoc)
1242  	{
1243  		case L_C :
1244  		case L_CPP :
1245  		case L_JAVA :
1246  		case L_RC :
1247  		case L_CS :
1248  		case L_FLASH :
1249  		case L_SWIFT:
1250  			setCppLexer(typeDoc); break;
1251  		case L_JS:
1252  		case L_JAVASCRIPT:
1253  			setJsLexer(); break;
1254  		case L_TCL :
1255              setTclLexer(); break;
1256          case L_OBJC :
1257              setObjCLexer(typeDoc); break;
1258  	    case L_PHP :
1259  		case L_ASP :
1260          case L_JSP :
1261  		case L_HTML :
1262  		case L_XML :
1263  			setXmlLexer(typeDoc); break;
1264  		case L_JSON:
1265  			setJsonLexer(); break;
1266  		case L_JSON5:
1267  			setJsonLexer(true); break;
1268  		case L_CSS :
1269  			setCssLexer(); break;
1270  		case L_LUA :
1271  			setLuaLexer(); break;
1272  		case L_MAKEFILE :
1273  			setMakefileLexer(); break;
1274  		case L_INI :
1275  			setPropsLexer(false); break;
1276  		case L_USER : {
1277  			const TCHAR * langExt = _currentBuffer-&gt;getUserDefineLangName();
1278  			if (langExt[0])
1279  				setUserLexer(langExt);
1280  			else
1281  				setUserLexer();
1282  			break; }
1283          case L_ASCII :
1284  		{
1285  			LexerStyler *pStyler = (NppParameters::getInstance().getLStylerArray()).getLexerStylerByName(TEXT(&quot;nfo&quot;));
1286  			Style nfoStyle;
1287  			nfoStyle._styleID = STYLE_DEFAULT;
1288  			nfoStyle._fontName = TEXT(&quot;Lucida Console&quot;);
1289  			nfoStyle._fontSize = 10;
1290  			if (pStyler)
1291  			{
1292  				const Style * pStyle = pStyler-&gt;findByName(TEXT(&quot;DEFAULT&quot;));
1293  				if (pStyle)
1294  				{
1295  					nfoStyle._bgColor = pStyle-&gt;_bgColor;
1296  					nfoStyle._fgColor = pStyle-&gt;_fgColor;
1297  					nfoStyle._colorStyle = pStyle-&gt;_colorStyle;
1298  				}
1299  			}
1300  			setSpecialStyle(nfoStyle);
1301  			execute(SCI_STYLECLEARALL);
1302  			Buffer * buf = MainFileManager.getBufferByID(_currentBufferID);
1303  			if (buf-&gt;getEncoding() != NPP_CP_DOS_437)
1304  			{
1305  			   buf-&gt;setEncoding(NPP_CP_DOS_437);
1306  			   ::SendMessage(_hParent, WM_COMMAND, IDM_FILE_RELOAD, 0);
1307  			}
1308  		}
1309  		break;
1310  		case L_SQL :
1311  			setSqlLexer(); break;
1312  		case L_MSSQL :
1313  			setMSSqlLexer(); break;
1314  		case L_VB :
1315  			setVBLexer(); break;
1316  		case L_PASCAL :
1317  			setPascalLexer(); break;
1318  		case L_PERL :
1319  			setPerlLexer(); break;
1320  		case L_PYTHON :
1321  			setPythonLexer(); break;
1322  		case L_BATCH :
1323  			setBatchLexer(); break;
1324  		case L_TEX :
1325  			setTeXLexer(); break;
1326  		case L_NSIS :
1327  			setNsisLexer(); break;
1328  		case L_BASH :
1329  			setBashLexer(); break;
1330  		case L_FORTRAN :
1331  			setFortranLexer(); break;
1332  		case L_FORTRAN_77 :
1333  			setFortran77Lexer(); break;
1334  		case L_LISP :
1335              setLispLexer(); break;
1336  		case L_SCHEME :
1337              setSchemeLexer(); break;
1338  		case L_ASM :
1339              setAsmLexer(); break;
1340  		case L_DIFF :
1341              setDiffLexer(); break;
1342  		case L_PROPS :
1343              setPropsLexer(); break;
1344  		case L_PS :
1345              setPostscriptLexer(); break;
1346  		case L_RUBY :
1347              setRubyLexer(); break;
1348  		case L_SMALLTALK :
1349              setSmalltalkLexer(); break;
1350  		case L_VHDL :
1351              setVhdlLexer(); break;
1352  		case L_KIX :
1353              setKixLexer(); break;
1354  		case L_CAML :
1355              setCamlLexer(); break;
1356  		case L_ADA :
1357              setAdaLexer(); break;
1358  		case L_VERILOG :
1359              setVerilogLexer(); break;
1360  		case L_AU3 :
1361              setAutoItLexer(); break;
1362  		case L_MATLAB :
1363              setMatlabLexer(); break;
1364  		case L_HASKELL :
1365              setHaskellLexer(); break;
1366  		case L_INNO :
1367  			setInnoLexer(); break;
1368  		case L_CMAKE :
1369  			setCmakeLexer(); break;
1370  		case L_YAML :
1371  			setYamlLexer(); break;
1372          case L_COBOL :
1373  			setCobolLexer(); break;
1374          case L_GUI4CLI :
1375  			setGui4CliLexer(); break;
1376          case L_D :
1377  			setDLexer(); break;
1378          case L_POWERSHELL :
1379  			setPowerShellLexer(); break;
1380          case L_R :
1381  			setRLexer(); break;
1382  		case L_COFFEESCRIPT :
1383  			setCoffeeScriptLexer(); break;
1384  		case L_BAANC:
1385  			setBaanCLexer(); break;
1386  		case L_SREC :
1387  			setSrecLexer(); break;
1388  		case L_IHEX :
1389  			setIHexLexer(); break;
1390  		case L_TEHEX :
1391  			setTEHexLexer(); break;
1392  		case L_ASN1 :
1393  			setAsn1Lexer(); break;
1394  		case L_AVS :
1395  			setAVSLexer(); break;
1396  		case L_BLITZBASIC :
1397  			setBlitzBasicLexer(); break;
1398  		case L_PUREBASIC :
1399  			setPureBasicLexer(); break;
1400  		case L_FREEBASIC :
1401  			setFreeBasicLexer(); break;
1402  		case L_CSOUND :
1403  			setCsoundLexer(); break;
1404  		case L_ERLANG :
1405  			setErlangLexer(); break;
1406  		case L_ESCRIPT :
1407  			setESCRIPTLexer(); break;
1408  		case L_FORTH :
1409  			setForthLexer(); break;
1410  		case L_LATEX :
1411  			setLatexLexer(); break;
1412  		case L_MMIXAL :
1413  			setMMIXALLexer(); break;
1414  		case L_NIM :
1415  			setNimrodLexer(); break;
1416  		case L_NNCRONTAB :
1417  			setNncrontabLexer(); break;
1418  		case L_OSCRIPT :
1419  			setOScriptLexer(); break;
1420  		case L_REBOL :
1421  			setREBOLLexer(); break;
1422  		case L_REGISTRY :
1423  			setRegistryLexer(); break;
1424  		case L_RUST :
1425  			setRustLexer(); break;
1426  		case L_SPICE :
1427  			setSpiceLexer(); break;
1428  		case L_TXT2TAGS :
1429  			setTxt2tagsLexer(); break;
1430  		case L_VISUALPROLOG:
1431  			setVisualPrologLexer(); break;
1432  		case L_TYPESCRIPT:
1433  			setTypeScriptLexer(); break;
1434  		case L_GDSCRIPT:
1435  			setGDScriptLexer(); break;
1436  		case L_HOLLYWOOD:
1437  			setHollywoodLexer(); break;
1438  		case L_TEXT :
1439  		default :
1440  			if (typeDoc &gt;= L_EXTERNAL &amp;&amp; typeDoc &lt; NppParameters::getInstance().L_END)
1441  				setExternalLexer(typeDoc);
1442  			else
1443  				setLexerFromLangID(L_TEXT);
1444  			break;
1445  	}
1446  	pStyle = stylers.findByID(STYLE_INDENTGUIDE);
1447  	if (pStyle)
1448  	{
1449  		setStyle(*pStyle);
1450  	}
1451  	pStyle = stylers.findByID(STYLE_BRACELIGHT);
1452  	if (pStyle)
1453  	{
1454  		setStyle(*pStyle);
1455  	}
1456  	pStyle = stylers.findByID(STYLE_BRACEBAD);
1457  	if (pStyle)
1458  	{
1459  		setStyle(*pStyle);
1460  	}
1461  	pStyle = stylers.findByID(STYLE_LINENUMBER);
1462  	if (pStyle)
1463  	{
1464  		setSpecialStyle(*pStyle);
1465  	}
1466  	setTabSettings(NppParameters::getInstance().getLangFromID(typeDoc));
1467  	if (svp._indentGuideLineShow)
1468  	{
1469  		const auto currentIndentMode = execute(SCI_GETINDENTATIONGUIDES);
1470  		const int docIndentMode = isPythonStyleIndentation(typeDoc) ? SC_IV_LOOKFORWARD : SC_IV_LOOKBOTH;
1471  		if (currentIndentMode != docIndentMode)
1472  			execute(SCI_SETINDENTATIONGUIDES, docIndentMode);
1473  	}
1474  }
1475  BufferID ScintillaEditView::attachDefaultDoc()
1476  {
1477  	Document doc = execute(SCI_GETDOCPOINTER, 0, 0);
1478  	execute(SCI_ADDREFDOCUMENT, 0, doc);
1479  	BufferID id = MainFileManager.bufferFromDocument(doc, false, true);
1480  	Buffer * buf = MainFileManager.getBufferByID(id);
1481  	MainFileManager.addBufferReference(id, this);	
1482  	_currentBufferID = id;
1483  	_currentBuffer = buf;
1484  	bufferUpdated(buf, BufferChangeMask);	
1485  	return id;
1486  }
1487  void ScintillaEditView::saveCurrentPos()
1488  {
1489  	size_t displayedLine = execute(SCI_GETFIRSTVISIBLELINE);
1490  	size_t docLine = execute(SCI_DOCLINEFROMVISIBLE, displayedLine);		
1491  	size_t offset = displayedLine - execute(SCI_VISIBLEFROMDOCLINE, docLine);		
1492  	size_t wrapCount = execute(SCI_WRAPCOUNT, docLine);
1493  	Buffer * buf = MainFileManager.getBufferByID(_currentBufferID);
1494  	Position pos;
1495  	pos._firstVisibleLine = docLine;
1496  	pos._startPos = execute(SCI_GETANCHOR);
1497  	pos._endPos = execute(SCI_GETCURRENTPOS);
1498  	pos._xOffset = execute(SCI_GETXOFFSET);
1499  	pos._selMode = execute(SCI_GETSELECTIONMODE);
1500  	pos._scrollWidth = execute(SCI_GETSCROLLWIDTH);
1501  	pos._offset = offset;
1502  	pos._wrapCount = wrapCount;
1503  	buf-&gt;setPosition(pos, this);
1504  }
1505  void ScintillaEditView::restoreCurrentPosPreStep()
1506  {
1507  	Buffer * buf = MainFileManager.getBufferByID(_currentBufferID);
1508  	Position &amp; pos = buf-&gt;getPosition(this);
1509  	execute(SCI_SETSELECTIONMODE, pos._selMode);	
1510  	execute(SCI_SETANCHOR, pos._startPos);
1511  	execute(SCI_SETCURRENTPOS, pos._endPos);
1512  	execute(SCI_CANCEL);							
1513  	if (!isWrap()) 
1514  	{
1515  		execute(SCI_SETSCROLLWIDTH, pos._scrollWidth);
1516  		execute(SCI_SETXOFFSET, pos._xOffset);
1517  	}
1518  	execute(SCI_CHOOSECARETX); 
1519  	intptr_t lineToShow = execute(SCI_VISIBLEFROMDOCLINE, pos._firstVisibleLine);
1520  	execute(SCI_SETFIRSTVISIBLELINE, lineToShow);
1521  	if (isWrap())
1522  	{
1523  		_positionRestoreNeeded = true;
1524  	}
1525  	_restorePositionRetryCount = 0;
1526  }
1527  void ScintillaEditView::restoreCurrentPosPostStep()
1528  {
1529  	if (!_positionRestoreNeeded)
1530  		return;
1531  	Buffer * buf = MainFileManager.getBufferByID(_currentBufferID);
1532  	Position &amp; pos = buf-&gt;getPosition(this);
1533  	++_restorePositionRetryCount;
1534  	if (_restorePositionRetryCount &gt; 8)
1535  	{
1536  		_positionRestoreNeeded = false;
1537  		return;
1538  	}
1539  	intptr_t displayedLine = execute(SCI_GETFIRSTVISIBLELINE);
1540  	intptr_t docLine = execute(SCI_DOCLINEFROMVISIBLE, displayedLine);		
1541  	if (docLine != pos._firstVisibleLine)
1542  	{
1543  		intptr_t lineToShow = execute(SCI_VISIBLEFROMDOCLINE, pos._firstVisibleLine);
1544  		execute(SCI_SETFIRSTVISIBLELINE, lineToShow);
1545  	}
1546  	else if (pos._offset &gt; 0)
1547  	{
1548  		intptr_t wrapCount = execute(SCI_WRAPCOUNT, docLine);
1549  		if (wrapCount == pos._wrapCount)
1550  		{
1551  			scroll(0, pos._offset);
1552  			_positionRestoreNeeded = false;
1553  		}
1554  	}
1555  	else
1556  	{
1557  		_positionRestoreNeeded = false;
1558  	}
1559  }
1560  void ScintillaEditView::restyleBuffer()
1561  {
1562  	execute(SCI_CLEARDOCUMENTSTYLE);
1563  	execute(SCI_COLOURISE, 0, -1);
1564  	_currentBuffer-&gt;setNeedsLexing(false);
1565  }
1566  void ScintillaEditView::styleChange()
1567  {
1568  	defineDocType(_currentBuffer-&gt;getLangType());
1569  	restyleBuffer();
1570  }
1571  bool ScintillaEditView::setLexerFromLangID(int langID) 
1572  {
1573  	if (langID &gt;= L_EXTERNAL)
1574  		return false;
1575  	const char* lexerNameID = _langNameInfoArray[langID]._lexerID;
1576  	execute(SCI_SETILEXER, 0, reinterpret_cast&lt;LPARAM&gt;(CreateLexer(lexerNameID)));
1577  	return true;
1578  }
1579  void ScintillaEditView::activateBuffer(BufferID buffer, bool force)
1580  {
1581  	if (buffer == BUFFER_INVALID)
1582  		return;
1583  	if (!force &amp;&amp; buffer == _currentBuffer)
1584  		return;
1585  	Buffer * newBuf = MainFileManager.getBufferByID(buffer);
1586  	saveCurrentPos();
1587  	std::vector&lt;size_t&gt; lineStateVector;
1588  	getCurrentFoldStates(lineStateVector);
1589  	_currentBuffer-&gt;setHeaderLineState(lineStateVector, this);
1590  	_currentBufferID = buffer;	
1591  	_currentBuffer = newBuf;
1592  	execute(SCI_SETDOCPOINTER, 0, _currentBuffer-&gt;getDocument());
1593  	defineDocType(_currentBuffer-&gt;getLangType());
1594  	setWordChars();
1595  	if (_currentBuffer-&gt;getNeedsLexing())
1596  	{
1597  		restyleBuffer();
1598  	}
1599  	maintainStateForNpc();
1600  	bufferUpdated(_currentBuffer, (BufferChangeMask &amp; ~BufferChangeLanguage));
1601  	const std::vector&lt;size_t&gt; &amp; lineStateVectorNew = newBuf-&gt;getHeaderLineState(this);
1602  	syncFoldStateWith(lineStateVectorNew);
1603  	restoreCurrentPosPreStep();
1604  	runMarkers(true, 0, true, false);
1605  	setCRLF();
1606  	NppParameters&amp; nppParam = NppParameters::getInstance();
1607  	const ScintillaViewParams&amp; svp = nppParam.getSVP();
1608  	int enabledCH = svp._isChangeHistoryEnabled ? (SC_CHANGE_HISTORY_ENABLED | SC_CHANGE_HISTORY_MARKERS) : SC_CHANGE_HISTORY_DISABLED;
1609  	execute(SCI_SETCHANGEHISTORY, enabledCH);
1610      return;	
1611  }
1612  void ScintillaEditView::getCurrentFoldStates(std::vector&lt;size_t&gt; &amp; lineStateVector)
1613  {
1614  	size_t contractedFoldHeaderLine = 0;
1615  	do {
1616  		contractedFoldHeaderLine = execute(SCI_CONTRACTEDFOLDNEXT, contractedFoldHeaderLine);
1617  		if (static_cast&lt;intptr_t&gt;(contractedFoldHeaderLine) != -1)
1618  		{
1619  			lineStateVector.push_back(contractedFoldHeaderLine);
1620  			++contractedFoldHeaderLine;
1621  		}
1622  	} while (static_cast&lt;intptr_t&gt;(contractedFoldHeaderLine) != -1);
1623  }
1624  void ScintillaEditView::syncFoldStateWith(const std::vector&lt;size_t&gt; &amp; lineStateVectorNew)
1625  {
1626  	size_t nbLineState = lineStateVectorNew.size();
1627  	for (size_t i = 0 ; i &lt; nbLineState ; ++i)
1628  	{
1629  		auto line = lineStateVectorNew.at(i);
1630  		fold(line, false);
1631  	}
1632  }
1633  void ScintillaEditView::bufferUpdated(Buffer * buffer, int mask)
1634  {
1635  	if (buffer == _currentBuffer)
1636  	{
1637  		if (mask &amp; BufferChangeLanguage)
1638  		{
1639  			defineDocType(buffer-&gt;getLangType());
1640  			foldAll(fold_uncollapse);
1641  		}
1642  		if (mask &amp; BufferChangeLexing)
1643  		{
1644  			if (buffer-&gt;getNeedsLexing())
1645  			{
1646  				restyleBuffer();	
1647  			}	
1648  		}
1649  		if (mask &amp; BufferChangeFormat)
1650  		{
1651  			execute(SCI_SETEOLMODE, static_cast&lt;int&gt;(_currentBuffer-&gt;getEolFormat()));
1652  		}
1653  		if (mask &amp; BufferChangeReadonly)
1654  		{
1655  			execute(SCI_SETREADONLY, _currentBuffer-&gt;isReadOnly());
1656  		}
1657  		if (mask &amp; BufferChangeUnicode)
1658  		{
1659              int enc = CP_ACP;
1660  			if (buffer-&gt;getUnicodeMode() == uni8Bit)
1661  			{	
1662  				LangType typeDoc = buffer-&gt;getLangType();
1663  				if (isCJK())
1664  				{
1665  					if (typeDoc == L_CSS || typeDoc == L_CAML || typeDoc == L_ASM || typeDoc == L_MATLAB)
1666  						enc = CP_ACP;	
1667  					else
1668  						enc = _codepage;
1669  				}
1670                  else
1671                      enc = CP_ACP;
1672  			}
1673  			else	
1674  				enc = SC_CP_UTF8;
1675              execute(SCI_SETCODEPAGE, enc);
1676  		}
1677  	}
1678  }
1679  bool ScintillaEditView::isFoldIndentationBased() const
1680  {
1681  	const auto lexer = execute(SCI_GETLEXER);
1682  	return lexer == SCLEX_PYTHON
1683  		|| lexer == SCLEX_COFFEESCRIPT
1684  		|| lexer == SCLEX_HASKELL
1685  		|| lexer == SCLEX_NIMROD
1686  		|| lexer == SCLEX_VB
1687  		|| lexer == SCLEX_YAML
1688  	;
1689  }
1690  namespace {
1691  struct FoldLevelStack
1692  {
1693  	int levelCount = 0; 
1694  	intptr_t levelStack[MAX_FOLD_COLLAPSE_LEVEL]{};
1695  	void push(intptr_t level)
1696  	{
1697  		while (levelCount != 0 &amp;&amp; level &lt;= levelStack[levelCount - 1])
1698  		{
1699  			--levelCount;
1700  		}
1701  		levelStack[levelCount++] = level;
1702  	}
1703  };
1704  }
1705  void ScintillaEditView::collapseFoldIndentationBased(int level2Collapse, bool mode)
1706  {
1707  	execute(SCI_COLOURISE, 0, -1);
1708  	FoldLevelStack levelStack;
1709  	++level2Collapse; 
1710  	const intptr_t maxLine = execute(SCI_GETLINECOUNT);
1711  	intptr_t line = 0;
1712  	while (line &lt; maxLine)
1713  	{
1714  		intptr_t level = execute(SCI_GETFOLDLEVEL, line);
1715  		if (level &amp; SC_FOLDLEVELHEADERFLAG)
1716  		{
1717  			level &amp;= SC_FOLDLEVELNUMBERMASK;
1718  			levelStack.push(level);
1719  			if (level2Collapse == levelStack.levelCount)
1720  			{
1721  				if (isFolded(line) != mode)
1722  				{
1723  					fold(line, mode);
1724  				}
1725  				line = execute(SCI_GETLASTCHILD, line, -1);
1726  			}
1727  		}
1728  		++line;
1729  	}
1730  	runMarkers(true, 0, true, false);
1731  }
1732  void ScintillaEditView::collapse(int level2Collapse, bool mode)
1733  {
1734  	if (isFoldIndentationBased())
1735  	{
1736  		collapseFoldIndentationBased(level2Collapse, mode);
1737  		return;
1738  	}
1739  	execute(SCI_COLOURISE, 0, -1);
1740  	intptr_t maxLine = execute(SCI_GETLINECOUNT);
1741  	for (int line = 0; line &lt; maxLine; ++line)
1742  	{
1743  		intptr_t level = execute(SCI_GETFOLDLEVEL, line);
1744  		if (level &amp; SC_FOLDLEVELHEADERFLAG)
1745  		{
1746  			level -= SC_FOLDLEVELBASE;
1747  			if (level2Collapse == (level &amp; SC_FOLDLEVELNUMBERMASK))
1748  				if (isFolded(line) != mode)
1749  				{
1750  					fold(line, mode);
1751  				}
1752  		}
1753  	}
1754  	runMarkers(true, 0, true, false);
1755  }
1756  void ScintillaEditView::foldCurrentPos(bool mode)
1757  {
1758  	auto currentLine = getCurrentLineNumber();
1759  	fold(currentLine, mode);
1760  }
1761  bool ScintillaEditView::isCurrentLineFolded() const
1762  {
1763  	auto currentLine = getCurrentLineNumber();
1764  	intptr_t headerLine;
1765  	auto level = execute(SCI_GETFOLDLEVEL, currentLine);
1766  	if (level &amp; SC_FOLDLEVELHEADERFLAG)
1767  		headerLine = currentLine;
1768  	else
1769  	{
1770  		headerLine = execute(SCI_GETFOLDPARENT, currentLine);
1771  		if (headerLine == -1)
1772  			return false;
1773  	}
1774  	bool isExpanded = execute(SCI_GETFOLDEXPANDED, headerLine);
1775  	return !isExpanded;
1776  }
1777  void ScintillaEditView::fold(size_t line, bool mode)
1778  {
1779  	auto endStyled = execute(SCI_GETENDSTYLED);
1780  	auto len = execute(SCI_GETTEXTLENGTH);
1781  	if (endStyled &lt; len)
1782  		execute(SCI_COLOURISE, 0, -1);
1783  	intptr_t headerLine;
1784  	auto level = execute(SCI_GETFOLDLEVEL, line);
1785  	if (level &amp; SC_FOLDLEVELHEADERFLAG)
1786  		headerLine = line;
1787  	else
1788  	{
1789  		headerLine = execute(SCI_GETFOLDPARENT, line);
1790  		if (headerLine == -1)
1791  			return;
1792  	}
1793  	if (isFolded(headerLine) != mode)
1794  	{
1795  		execute(SCI_TOGGLEFOLD, headerLine);
1796  		SCNotification scnN{};
1797  		scnN.nmhdr.code = SCN_FOLDINGSTATECHANGED;
1798  		scnN.nmhdr.hwndFrom = _hSelf;
1799  		scnN.nmhdr.idFrom = 0;
1800  		scnN.line = headerLine;
1801  		scnN.foldLevelNow = isFolded(headerLine)?1:0; 
1802  		::SendMessage(_hParent, WM_NOTIFY, 0, reinterpret_cast&lt;LPARAM&gt;(&amp;scnN));
1803  	}
1804  }
1805  void ScintillaEditView::foldAll(bool mode)
1806  {
1807  	auto maxLine = execute(SCI_GETLINECOUNT);
1808  	for (int line = 0; line &lt; maxLine; ++line)
1809  	{
1810  		auto level = execute(SCI_GETFOLDLEVEL, line);
1811  		if (level &amp; SC_FOLDLEVELHEADERFLAG)
1812  			if (isFolded(line) != mode)
1813  				fold(line, mode);
1814  	}
1815  }
1816  void ScintillaEditView::getText(char *dest, size_t start, size_t end) const
1817  {
1818  	Sci_TextRangeFull tr{};
1819  	tr.chrg.cpMin = static_cast&lt;Sci_Position&gt;(start);
1820  	tr.chrg.cpMax = static_cast&lt;Sci_Position&gt;(end);
1821  	tr.lpstrText = dest;
1822  	execute(SCI_GETTEXTRANGEFULL, 0, reinterpret_cast&lt;LPARAM&gt;(&amp;tr));
1823  }
1824  generic_string ScintillaEditView::getGenericTextAsString(size_t start, size_t end) const
1825  {
1826  	assert(end &gt; start);
1827  	const size_t bufSize = end - start + 1;
1828  	TCHAR *buf = new TCHAR[bufSize];
1829  	getGenericText(buf, bufSize, start, end);
1830  	generic_string text = buf;
1831  	delete[] buf;
1832  	return text;
1833  }
1834  void ScintillaEditView::getGenericText(TCHAR *dest, size_t destlen, size_t start, size_t end) const
1835  {
1836  	WcharMbcsConvertor&amp; wmc = WcharMbcsConvertor::getInstance();
1837  	char *destA = new char[end - start + 1];
1838  	getText(destA, start, end);
1839  	size_t cp = execute(SCI_GETCODEPAGE);
1840  	const TCHAR *destW = wmc.char2wchar(destA, cp);
1841  	wcsncpy_s(dest, destlen, destW, _TRUNCATE);
1842  	delete [] destA;
1843  }
1844  void ScintillaEditView::getGenericText(TCHAR *dest, size_t destlen, size_t start, size_t end, intptr_t* mstart, intptr_t* mend) const
1845  {
1846  	WcharMbcsConvertor&amp; wmc = WcharMbcsConvertor::getInstance();
1847  	char *destA = new char[end - start + 1];
1848  	getText(destA, start, end);
1849  	size_t cp = execute(SCI_GETCODEPAGE)    ;
1850  	const TCHAR *destW = wmc.char2wchar(destA, cp, mstart, mend);
1851  	wcsncpy_s(dest, destlen, destW, _TRUNCATE);
1852  	delete [] destA;
1853  }
1854  void ScintillaEditView::insertGenericTextFrom(size_t position, const TCHAR *text2insert) const
1855  {
1856  	WcharMbcsConvertor&amp; wmc = WcharMbcsConvertor::getInstance();
1857  	size_t cp = execute(SCI_GETCODEPAGE);
1858  	const char *text2insertA = wmc.wchar2char(text2insert, cp);
1859  	execute(SCI_INSERTTEXT, position, reinterpret_cast&lt;LPARAM&gt;(text2insertA));
1860  }
1861  void ScintillaEditView::replaceSelWith(const char * replaceText)
1862  {
1863  	execute(SCI_REPLACESEL, 0, reinterpret_cast&lt;LPARAM&gt;(replaceText));
1864  }
1865  void ScintillaEditView::getVisibleStartAndEndPosition(intptr_t* startPos, intptr_t* endPos)
1866  {
1867  	assert(startPos != NULL &amp;&amp; endPos != NULL);
1868  	RECT rcEditView{};
1869  	getClientRect(rcEditView);
1870  	LRESULT pos = execute(SCI_POSITIONFROMPOINT, 0, 0);
1871  	LRESULT line = execute(SCI_LINEFROMPOSITION, pos);
1872  	*startPos = execute(SCI_POSITIONFROMLINE, line);
1873  	pos = execute(SCI_POSITIONFROMPOINT, static_cast&lt;WPARAM&gt;(rcEditView.right - rcEditView.left), static_cast&lt;LPARAM&gt;(rcEditView.bottom - rcEditView.top));
1874  	line = execute(SCI_LINEFROMPOSITION, pos);
1875  	*endPos = execute(SCI_GETLINEENDPOSITION, line);
1876  }
1877  char * ScintillaEditView::getWordFromRange(char * txt, size_t size, size_t pos1, size_t pos2)
1878  {
1879      if (!size)
1880  		return NULL;
1881      if (pos1 &gt; pos2)
1882      {
1883          size_t tmp = pos1;
1884          pos1 = pos2;
1885          pos2 = tmp;
1886      }
1887      if (size &lt; pos2 - pos1)
1888          return NULL;
1889      getText(txt, pos1, pos2);
1890  	return txt;
1891  }
1892  char * ScintillaEditView::getWordOnCaretPos(char * txt, size_t size)
1893  {
1894      if (!size)
1895  		return NULL;
1896      pair&lt;size_t, size_t&gt; range = getWordRange();
1897      return getWordFromRange(txt, size, range.first, range.second);
1898  }
1899  TCHAR * ScintillaEditView::getGenericWordOnCaretPos(TCHAR * txt, int size)
1900  {
1901  	WcharMbcsConvertor&amp; wmc = WcharMbcsConvertor::getInstance();
1902  	size_t cp = execute(SCI_GETCODEPAGE);
1903  	char *txtA = new char[size + 1];
1904  	getWordOnCaretPos(txtA, size);
1905  	const TCHAR * txtW = wmc.char2wchar(txtA, cp);
1906  	wcscpy_s(txt, size, txtW);
1907  	delete [] txtA;
1908  	return txt;
1909  }
1910  char * ScintillaEditView::getSelectedText(char * txt, size_t size, bool expand)
1911  {
1912  	if (!size)
1913  		return NULL;
1914  	Sci_CharacterRangeFull range = getSelection();
1915  	if (range.cpMax == range.cpMin &amp;&amp; expand)
1916  	{
1917  		expandWordSelection();
1918  		range = getSelection();
1919  	}
1920  	if (!(static_cast&lt;Sci_Position&gt;(size) &gt; (range.cpMax - range.cpMin)))	
1921  	{
1922  		range.cpMax = range.cpMin + size -1;	
1923  	}
1924  	return getWordFromRange(txt, size, range.cpMin, range.cpMax);
1925  }
1926  TCHAR * ScintillaEditView::getGenericSelectedText(TCHAR * txt, int size, bool expand)
1927  {
1928  	WcharMbcsConvertor&amp; wmc = WcharMbcsConvertor::getInstance();
1929  	size_t cp = execute(SCI_GETCODEPAGE);
1930  	char *txtA = new char[size + 1];
1931  	getSelectedText(txtA, size, expand);
1932  	const TCHAR * txtW = wmc.char2wchar(txtA, cp);
1933  	wcscpy_s(txt, size, txtW);
1934  	delete [] txtA;
1935  	return txt;
1936  }
1937  intptr_t ScintillaEditView::searchInTarget(const TCHAR * text2Find, size_t lenOfText2Find, size_t fromPos, size_t toPos) const
1938  {
1939  	execute(SCI_SETTARGETRANGE, fromPos, toPos);
1940  	WcharMbcsConvertor&amp; wmc = WcharMbcsConvertor::getInstance();
1941  	size_t cp = execute(SCI_GETCODEPAGE);
1942  	const char *text2FindA = wmc.wchar2char(text2Find, cp);
1943  	size_t text2FindALen = strlen(text2FindA);
1944     	size_t len = (lenOfText2Find &gt; text2FindALen) ? lenOfText2Find : text2FindALen;
1945  	return execute(SCI_SEARCHINTARGET, len, reinterpret_cast&lt;LPARAM&gt;(text2FindA));
1946  }
1947  void ScintillaEditView::appandGenericText(const TCHAR * text2Append) const
1948  {
1949  	WcharMbcsConvertor&amp; wmc = WcharMbcsConvertor::getInstance();
1950  	size_t cp = execute(SCI_GETCODEPAGE);
1951  	const char *text2AppendA =wmc.wchar2char(text2Append, cp);
1952  	execute(SCI_APPENDTEXT, strlen(text2AppendA), reinterpret_cast&lt;LPARAM&gt;(text2AppendA));
1953  }
1954  void ScintillaEditView::addGenericText(const TCHAR * text2Append) const
1955  {
1956  	WcharMbcsConvertor&amp; wmc = WcharMbcsConvertor::getInstance();
1957  	size_t cp = execute(SCI_GETCODEPAGE);
1958  	const char *text2AppendA =wmc.wchar2char(text2Append, cp);
1959  	execute(SCI_ADDTEXT, strlen(text2AppendA), reinterpret_cast&lt;LPARAM&gt;(text2AppendA));
1960  }
1961  void ScintillaEditView::addGenericText(const TCHAR * text2Append, intptr_t* mstart, intptr_t* mend) const
1962  {
1963  	WcharMbcsConvertor&amp; wmc = WcharMbcsConvertor::getInstance();
1964  	size_t cp = execute(SCI_GETCODEPAGE);
1965  	const char *text2AppendA =wmc.wchar2char(text2Append, cp, mstart, mend);
1966  	execute(SCI_ADDTEXT, strlen(text2AppendA), reinterpret_cast&lt;LPARAM&gt;(text2AppendA));
1967  }
1968  intptr_t ScintillaEditView::replaceTarget(const TCHAR * str2replace, intptr_t fromTargetPos, intptr_t toTargetPos) const
1969  {
1970  	if (fromTargetPos != -1 || toTargetPos != -1)
1971  	{
1972  		execute(SCI_SETTARGETRANGE, fromTargetPos, toTargetPos);
1973  	}
1974  	WcharMbcsConvertor&amp; wmc = WcharMbcsConvertor::getInstance();
1975  	size_t cp = execute(SCI_GETCODEPAGE);
1976  	const char *str2replaceA = wmc.wchar2char(str2replace, cp);
1977  	return execute(SCI_REPLACETARGET, static_cast&lt;WPARAM&gt;(-1), reinterpret_cast&lt;LPARAM&gt;(str2replaceA));
1978  }
1979  intptr_t ScintillaEditView::replaceTargetRegExMode(const TCHAR * re, intptr_t fromTargetPos, intptr_t toTargetPos) const
1980  {
1981  	if (fromTargetPos != -1 || toTargetPos != -1)
1982  	{
1983  		execute(SCI_SETTARGETRANGE, fromTargetPos, toTargetPos);
1984  	}
1985  	WcharMbcsConvertor&amp; wmc = WcharMbcsConvertor::getInstance();
1986  	size_t cp = execute(SCI_GETCODEPAGE);
1987  	const char *reA = wmc.wchar2char(re, cp);
1988  	return execute(SCI_REPLACETARGETRE, static_cast&lt;WPARAM&gt;(-1), reinterpret_cast&lt;LPARAM&gt;(reA));
1989  }
1990  void ScintillaEditView::showAutoComletion(size_t lenEntered, const TCHAR* list)
1991  {
1992  	WcharMbcsConvertor&amp; wmc = WcharMbcsConvertor::getInstance();
1993  	size_t cp = execute(SCI_GETCODEPAGE);
1994  	const char *listA = wmc.wchar2char(list, cp);
1995  	execute(SCI_AUTOCSHOW, lenEntered, reinterpret_cast&lt;LPARAM&gt;(listA));
1996  	NppDarkMode::setDarkAutoCompletion();
1997  }
1998  void ScintillaEditView::showCallTip(size_t startPos, const TCHAR * def)
1999  {
2000  	WcharMbcsConvertor&amp; wmc = WcharMbcsConvertor::getInstance();
2001  	size_t cp = execute(SCI_GETCODEPAGE);
2002  	const char *defA = wmc.wchar2char(def, cp);
2003  	execute(SCI_CALLTIPSHOW, startPos, reinterpret_cast&lt;LPARAM&gt;(defA));
2004  }
2005  generic_string ScintillaEditView::getLine(size_t lineNumber)
2006  {
2007  	size_t lineLen = execute(SCI_LINELENGTH, lineNumber);
2008  	const size_t bufSize = lineLen + 1;
2009  	std::unique_ptr&lt;TCHAR[]&gt; buf = std::make_unique&lt;TCHAR[]&gt;(bufSize);
2010  	getLine(lineNumber, buf.get(), bufSize);
2011  	return buf.get();
2012  }
2013  void ScintillaEditView::getLine(size_t lineNumber, TCHAR * line, size_t lineBufferLen)
2014  {
2015  	size_t lineLen = execute(SCI_LINELENGTH, lineNumber);
2016  	if (lineLen &gt;= lineBufferLen)
2017  		return;
2018  	WcharMbcsConvertor&amp; wmc = WcharMbcsConvertor::getInstance();
2019  	size_t cp = execute(SCI_GETCODEPAGE);
2020  	char *lineA = new char[lineBufferLen];
2021  	memset(lineA, 0x0, sizeof(char) * lineBufferLen);
2022  	execute(SCI_GETLINE, lineNumber, reinterpret_cast&lt;LPARAM&gt;(lineA));
2023  	const TCHAR *lineW = wmc.char2wchar(lineA, cp);
2024  	lstrcpyn(line, lineW, static_cast&lt;int&gt;(lineBufferLen));
2025  	delete [] lineA;
2026  }
2027  void ScintillaEditView::addText(size_t length, const char *buf)
2028  {
2029  	execute(SCI_ADDTEXT, length, reinterpret_cast&lt;LPARAM&gt;(buf));
2030  }
2031  void ScintillaEditView::beginOrEndSelect(bool isColumnMode)
2032  {
2033  	if (_beginSelectPosition == -1)
2034  	{
2035  		_beginSelectPosition = execute(SCI_GETCURRENTPOS);
2036  	}
2037  	else
2038  	{
2039  		execute(SCI_SETSELECTIONMODE, static_cast&lt;WPARAM&gt;(isColumnMode ? SC_SEL_RECTANGLE : SC_SEL_STREAM));
2040  		execute(SCI_SETANCHOR, static_cast&lt;WPARAM&gt;(_beginSelectPosition));
2041  		_beginSelectPosition = -1;
2042  	}
2043  }
2044  void ScintillaEditView::showMargin(int whichMarge, bool willBeShowed)
2045  {
2046  	if (whichMarge == _SC_MARGE_LINENUMBER)
2047  	{
2048  		bool forcedToHide = !willBeShowed;
2049  		updateLineNumbersMargin(forcedToHide);
2050  	}
2051  	else
2052  	{
2053  		DPIManager&amp; dpiManager = NppParameters::getInstance()._dpiManager;
2054  		int width = dpiManager.scaleX(3);
2055  		if (whichMarge == _SC_MARGE_SYMBOL)
2056  			width = dpiManager.scaleX(16);
2057  		else if (whichMarge == _SC_MARGE_FOLDER)
2058  			width = dpiManager.scaleX(14);
2059  		execute(SCI_SETMARGINWIDTHN, whichMarge, willBeShowed ? width : 0);
2060  	}
2061  }
2062  void ScintillaEditView::showChangeHistoryMargin(bool willBeShowed)
2063  {
2064  	DPIManager&amp; dpiManager = NppParameters::getInstance()._dpiManager;
2065  	int	width = dpiManager.scaleX(9);
2066  	execute(SCI_SETMARGINWIDTHN, _SC_MARGE_CHANGEHISTORY, willBeShowed ? width : 0);
2067  }
2068  void ScintillaEditView::updateBeginEndSelectPosition(bool is_insert, size_t position, size_t length)
2069  {
2070  	if (_beginSelectPosition != -1 &amp;&amp; static_cast&lt;intptr_t&gt;(position) &lt; _beginSelectPosition - 1)
2071  	{
2072  		if (is_insert)
2073  			_beginSelectPosition += length;
2074  		else
2075  			_beginSelectPosition -= length;
2076  		assert(_beginSelectPosition &gt;= 0);
2077  	}
2078  }
2079  void ScintillaEditView::marginClick(Sci_Position position, int modifiers)
2080  {
2081  	size_t lineClick = execute(SCI_LINEFROMPOSITION, position, 0);
2082  	intptr_t levelClick = execute(SCI_GETFOLDLEVEL, lineClick, 0);
2083  	if (levelClick &amp; SC_FOLDLEVELHEADERFLAG)
2084      {
2085  		if (modifiers &amp; SCMOD_SHIFT)
2086          {
2087  			execute(SCI_SETFOLDEXPANDED, lineClick, 1);
2088  			expand(lineClick, true, true, 100, levelClick);
2089  		}
2090          else if (modifiers &amp; SCMOD_CTRL)
2091          {
2092  			if (isFolded(lineClick))
2093              {
2094  				execute(SCI_SETFOLDEXPANDED, lineClick, 0);
2095  				expand(lineClick, false, true, 0, levelClick);
2096  			}
2097              else
2098              {
2099  				execute(SCI_SETFOLDEXPANDED, lineClick, 1);
2100  				expand(lineClick, true, true, 100, levelClick);
2101  			}
2102  		}
2103          else
2104          {
2105  			bool mode = isFolded(lineClick);
2106  			fold(lineClick, !mode);
2107  			runMarkers(true, lineClick, true, false);
2108  		}
2109  	}
2110  }
2111  void ScintillaEditView::expand(size_t&amp; line, bool doExpand, bool force, intptr_t visLevels, intptr_t level)
2112  {
2113  	size_t lineMaxSubord = execute(SCI_GETLASTCHILD, line, level &amp; SC_FOLDLEVELNUMBERMASK);
2114  	++line;
2115  	while (line &lt;= lineMaxSubord)
2116      {
2117  		if (force)
2118          {
2119  			execute(((visLevels &gt; 0) ? SCI_SHOWLINES : SCI_HIDELINES), line, line);
2120  		}
2121          else
2122          {
2123  			if (doExpand)
2124  				execute(SCI_SHOWLINES, line, line);
2125  		}
2126  		intptr_t levelLine = level;
2127  		if (levelLine == -1)
2128  			levelLine = execute(SCI_GETFOLDLEVEL, line, 0);
2129  		if (levelLine &amp; SC_FOLDLEVELHEADERFLAG)
2130          {
2131  			if (force)
2132              {
2133  				if (visLevels &gt; 1)
2134  					execute(SCI_SETFOLDEXPANDED, line, 1);
2135  				else
2136  					execute(SCI_SETFOLDEXPANDED, line, 0);
2137  				expand(line, doExpand, force, visLevels - 1);
2138  			}
2139              else
2140              {
2141  				if (doExpand)
2142                  {
2143  					if (!isFolded(line))
2144  						execute(SCI_SETFOLDEXPANDED, line, 1);
2145  					expand(line, true, force, visLevels - 1);
2146  				}
2147                  else
2148  					expand(line, false, force, visLevels - 1);
2149  			}
2150  		}
2151          else
2152  			++line;
2153  	}
2154  	runMarkers(true, 0, true, false);
2155  }
2156  void ScintillaEditView::performGlobalStyles()
2157  {
2158  	NppParameters&amp; nppParams = NppParameters::getInstance();
2159  	const ScintillaViewParams&amp; svp = nppParams.getSVP();
2160  	StyleArray&amp; stylers = nppParams.getMiscStylerArray();
2161  	const Style* pStyle{};
2162  	if (svp._currentLineHiliteMode != LINEHILITE_NONE)
2163  	{
2164  		pStyle = stylers.findByName(TEXT(&quot;Current line background colour&quot;));
2165  		if (pStyle)
2166  		{
2167  			execute(SCI_SETELEMENTCOLOUR, SC_ELEMENT_CARET_LINE_BACK, pStyle-&gt;_bgColor);
2168  		}
2169  	}
2170  	execute(SCI_SETCARETLINEFRAME, (svp._currentLineHiliteMode == LINEHILITE_FRAME) ? svp._currentLineFrameWidth : 0);
2171  	COLORREF selectColorBack = grey;
2172  	COLORREF selectColorFore = black;
2173  	pStyle = stylers.findByName(TEXT(&quot;Selected text colour&quot;));
2174  	if (pStyle)
2175  	{
2176  		selectColorBack = pStyle-&gt;_bgColor;
2177  		selectColorFore = pStyle-&gt;_fgColor;
2178  	}
2179  	execute(SCI_SETSELBACK, 1, selectColorBack);
2180  	execute(SCI_SETELEMENTCOLOUR, SC_ELEMENT_SELECTION_INACTIVE_BACK, selectColorBack);
2181  	if (nppParams.isSelectFgColorEnabled())
2182  	{
2183  		execute(SCI_SETSELFORE, 1, selectColorFore);
2184  		long alphaSelectColorFore = selectColorFore;
2185  		alphaSelectColorFore |= 0xFF000000; 
2186  		execute(SCI_SETELEMENTCOLOUR, SC_ELEMENT_SELECTION_INACTIVE_TEXT, alphaSelectColorFore);
2187  	}
2188  	COLORREF caretColor = black;
2189  	pStyle = stylers.findByID(SCI_SETCARETFORE);
2190  	if (pStyle)
2191  	{
2192  		caretColor = pStyle-&gt;_fgColor;
2193  	}
2194  	execute(SCI_SETCARETFORE, caretColor);
2195  	COLORREF edgeColor = liteGrey;
2196  	pStyle = stylers.findByName(TEXT(&quot;Edge colour&quot;));
2197  	if (pStyle)
2198  	{
2199  		edgeColor = pStyle-&gt;_fgColor;
2200  	}
2201  	execute(SCI_SETEDGECOLOUR, edgeColor);
2202  	::SendMessage(_hParent, NPPM_INTERNAL_EDGEMULTISETSIZE, 0, 0);
2203  	COLORREF foldMarginColor = grey;
2204  	COLORREF foldMarginHiColor = white;
2205  	pStyle = stylers.findByName(TEXT(&quot;Fold margin&quot;));
2206  	if (pStyle)
2207  	{
2208  		foldMarginHiColor = pStyle-&gt;_fgColor;
2209  		foldMarginColor = pStyle-&gt;_bgColor;
2210  	}
2211  	execute(SCI_SETFOLDMARGINCOLOUR, true, foldMarginColor);
2212  	execute(SCI_SETFOLDMARGINHICOLOUR, true, foldMarginHiColor);
2213  	COLORREF bookmarkMarginColor = veryLiteGrey;
2214  	pStyle = stylers.findByName(TEXT(&quot;Bookmark margin&quot;));
2215  	if (!pStyle)
2216  	{
2217  		pStyle = stylers.findByName(TEXT(&quot;Line number margin&quot;)); 
2218  		if (pStyle)                                              
2219  		{
2220  			bookmarkMarginColor = pStyle-&gt;_bgColor;
2221  		}
2222  	}
2223  	else
2224  	{
2225  		bookmarkMarginColor = pStyle-&gt;_bgColor;
2226  	}
2227  	execute(SCI_SETMARGINTYPEN, _SC_MARGE_SYMBOL, SC_MARGIN_COLOUR);
2228  	execute(SCI_SETMARGINBACKN, _SC_MARGE_SYMBOL, bookmarkMarginColor);
2229  	COLORREF changeHistoryMarginColor = veryLiteGrey;
2230  	pStyle = stylers.findByName(TEXT(&quot;Change History margin&quot;));
2231  	if (!pStyle)
2232  	{
2233  		pStyle = stylers.findByName(TEXT(&quot;Line number margin&quot;));
2234  		if (pStyle)
2235  		{
2236  			changeHistoryMarginColor = pStyle-&gt;_bgColor;
2237  		}
2238  	}
2239  	else
2240  	{
2241  		changeHistoryMarginColor = pStyle-&gt;_bgColor;
2242  	}
2243  	execute(SCI_SETMARGINTYPEN, _SC_MARGE_CHANGEHISTORY, SC_MARGIN_COLOUR);
2244  	execute(SCI_SETMARGINBACKN, _SC_MARGE_CHANGEHISTORY, changeHistoryMarginColor);
2245  	COLORREF urlHoveredFG = grey;
2246  	pStyle = stylers.findByName(TEXT(&quot;URL hovered&quot;));
2247  	if (pStyle)
2248  	{
2249  		urlHoveredFG = pStyle-&gt;_fgColor;
2250  	}
2251  	execute(SCI_INDICSETHOVERFORE, URL_INDIC, urlHoveredFG);
2252  	COLORREF foldfgColor = white, foldbgColor = grey, activeFoldFgColor = red;
2253  	getFoldColor(foldfgColor, foldbgColor, activeFoldFgColor);
2254  	for (int j = 0 ; j &lt; NB_FOLDER_STATE ; ++j)
2255  		defineMarker(_markersArray[FOLDER_TYPE][j], _markersArray[svp._folderStyle][j], foldfgColor, foldbgColor, activeFoldFgColor);
2256  	execute(SCI_MARKERENABLEHIGHLIGHT, true);
2257  	COLORREF wsSymbolFgColor = black;
2258  	pStyle = stylers.findByName(TEXT(&quot;White space symbol&quot;));
2259  	if (pStyle)
2260  	{
2261  		wsSymbolFgColor = pStyle-&gt;_fgColor;
2262  	}
2263  	execute(SCI_SETWHITESPACEFORE, true, wsSymbolFgColor);
2264  	COLORREF eolCustomColor = liteGrey;
2265  	pStyle = stylers.findByName(TEXT(&quot;EOL custom color&quot;));
2266  	if (pStyle)
2267  	{
2268  		eolCustomColor = pStyle-&gt;_fgColor;
2269  	}
2270  	setCRLF(eolCustomColor);
2271  	COLORREF npcCustomColor = liteGrey;
2272  	pStyle = stylers.findByName(g_npcStyleName);
2273  	if (pStyle)
2274  	{
2275  		npcCustomColor = pStyle-&gt;_fgColor;
2276  	}
2277  	setNpcAndCcUniEOL(npcCustomColor);
2278  }
2279  void ScintillaEditView::showNpc(bool willBeShowed, bool isSearchResult)
2280  {
2281  	auto&amp; svp = NppParameters::getInstance().getSVP();
2282  	if (willBeShowed)
2283  	{
2284  		const auto&amp; mode = static_cast&lt;size_t&gt;(svp._npcMode);
2285  		for (const auto&amp; invChar : g_nonPrintingChars)
2286  		{
2287  			execute(SCI_SETREPRESENTATION, reinterpret_cast&lt;WPARAM&gt;(invChar.at(0)), reinterpret_cast&lt;LPARAM&gt;(invChar.at(mode)));
2288  		}
2289  		if (svp._npcCustomColor)
2290  		{
2291  			setNpcAndCcUniEOL();
2292  		}
2293  		showEOL(isShownEol());
2294  	}
2295  	else
2296  	{
2297  		execute(SCI_CLEARALLREPRESENTATIONS);
2298  		if (!isSearchResult &amp;&amp; svp._eolMode != svp.roundedRectangleText)
2299  		{
2300  			setCRLF();
2301  		}
2302  		showCcUniEol(svp._ccUniEolShow);
2303  	}
2304  }
2305  void ScintillaEditView::showCcUniEol(bool willBeShowed, bool isSearchResult)
2306  {
2307  	auto&amp; svp = NppParameters::getInstance().getSVP();
2308  	if (willBeShowed)
2309  	{
2310  		const auto&amp; mode = static_cast&lt;size_t&gt;(svp._npcIncludeCcUniEol ? svp._npcMode : ScintillaViewParams::npcMode::abbreviation);
2311  		for (const auto&amp; invChar : g_ccUniEolChars)
2312  		{
2313  			execute(SCI_SETREPRESENTATION, reinterpret_cast&lt;WPARAM&gt;(invChar.at(0)), reinterpret_cast&lt;LPARAM&gt;(invChar.at(mode)));
2314  		}
2315  		if (svp._npcIncludeCcUniEol &amp;&amp; svp._npcCustomColor)
2316  		{
2317  			setNpcAndCcUniEOL();
2318  		}
2319  	}
2320  	else
2321  	{
2322  		execute(SCI_CLEARALLREPRESENTATIONS);
2323  		for (const auto&amp; invChar : g_ccUniEolChars)
2324  		{
2325  			execute(SCI_SETREPRESENTATION, reinterpret_cast&lt;WPARAM&gt;(invChar.at(0)), reinterpret_cast&lt;LPARAM&gt;(g_ZWSP));
2326  			execute(SCI_SETREPRESENTATIONAPPEARANCE, reinterpret_cast&lt;WPARAM&gt;(invChar.at(0)), SC_REPRESENTATION_PLAIN);
2327  		}
2328  		if (!isSearchResult &amp;&amp; svp._eolMode != svp.roundedRectangleText)
2329  		{
2330  			setCRLF();
2331  		}
2332  		if (svp._npcShow)
2333  		{
2334  			showNpc();
2335  			return; 
2336  		}
2337  	}
2338  	showEOL(isShownEol());
2339  }
2340  void ScintillaEditView::showIndentGuideLine(bool willBeShowed)
2341  {
2342  	auto typeDoc = _currentBuffer-&gt;getLangType();
2343  	const int docIndentMode = isPythonStyleIndentation(typeDoc) ? SC_IV_LOOKFORWARD : SC_IV_LOOKBOTH;
2344  	execute(SCI_SETINDENTATIONGUIDES, willBeShowed ? docIndentMode : SC_IV_NONE);
2345  }
2346  void ScintillaEditView::setLineIndent(size_t line, size_t indent) const
2347  {
2348  	Sci_CharacterRangeFull crange = getSelection();
2349  	int64_t posBefore = execute(SCI_GETLINEINDENTPOSITION, line);
2350  	execute(SCI_SETLINEINDENTATION, line, indent);
2351  	int64_t posAfter = execute(SCI_GETLINEINDENTPOSITION, line);
2352  	long long posDifference = posAfter - posBefore;
2353  	if (posAfter &gt; posBefore)
2354  	{
2355  		if (crange.cpMin &gt;= posBefore)
2356  		{
2357  			crange.cpMin += static_cast&lt;Sci_Position&gt;(posDifference);
2358  		}
2359  		if (crange.cpMax &gt;= posBefore)
2360  		{
2361  			crange.cpMax += static_cast&lt;Sci_Position&gt;(posDifference);
2362  		}
2363  	}
2364  	else if (posAfter &lt; posBefore)
2365  	{
2366  		if (crange.cpMin &gt;= posAfter)
2367  		{
2368  			if (crange.cpMin &gt;= posBefore)
2369  				crange.cpMin += static_cast&lt;Sci_Position&gt;(posDifference);
2370  			else
2371  				crange.cpMin = static_cast&lt;Sci_Position&gt;(posAfter);
2372  		}
2373  		if (crange.cpMax &gt;= posAfter)
2374  		{
2375  			if (crange.cpMax &gt;= posBefore)
2376  				crange.cpMax += static_cast&lt;Sci_Position&gt;(posDifference);
2377  			else
2378  				crange.cpMax = static_cast&lt;Sci_Position&gt;(posAfter);
2379  		}
2380  	}
2381  	execute(SCI_SETSEL, crange.cpMin, crange.cpMax);
2382  }
2383  void ScintillaEditView::updateLineNumberWidth()
2384  {
2385  	const ScintillaViewParams&amp; svp = NppParameters::getInstance().getSVP();
2386  	if (svp._lineNumberMarginShow)
2387  	{
2388  		auto linesVisible = execute(SCI_LINESONSCREEN);
2389  		if (linesVisible)
2390  		{
2391  			int nbDigits = 0;
2392  			if (svp._lineNumberMarginDynamicWidth)
2393  			{
2394  				auto firstVisibleLineVis = execute(SCI_GETFIRSTVISIBLELINE);
2395  				auto lastVisibleLineVis = linesVisible + firstVisibleLineVis + 1;
2396  				auto lastVisibleLineDoc = execute(SCI_DOCLINEFROMVISIBLE, lastVisibleLineVis);
2397  				nbDigits = nbDigitsFromNbLines(lastVisibleLineDoc);
2398  				nbDigits = nbDigits &lt; 3 ? 3 : nbDigits;
2399  			}
2400  			else
2401  			{
2402  				auto nbLines = execute(SCI_GETLINECOUNT);
2403  				nbDigits = nbDigitsFromNbLines(nbLines);
2404  				nbDigits = nbDigits &lt; 4 ? 4 : nbDigits;
2405  			}
2406  			auto pixelWidth = 8 + nbDigits * execute(SCI_TEXTWIDTH, STYLE_LINENUMBER, reinterpret_cast&lt;LPARAM&gt;(&quot;8&quot;));
2407  			execute(SCI_SETMARGINWIDTHN, _SC_MARGE_LINENUMBER, pixelWidth);
2408  		}
2409  	}
2410  }
2411  const char * ScintillaEditView::getCompleteKeywordList(std::basic_string&lt;char&gt; &amp; kwl, LangType langType, int keywordIndex)
2412  {
2413  	kwl += &quot; &quot;;
2414  	const TCHAR *defKwl_generic = NppParameters::getInstance().getWordList(langType, keywordIndex);
2415  	WcharMbcsConvertor&amp; wmc = WcharMbcsConvertor::getInstance();
2416  	const char * defKwl = wmc.wchar2char(defKwl_generic, CP_ACP);
2417  	kwl += defKwl?defKwl:&quot;&quot;;
2418  	return kwl.c_str();
2419  }
2420  void ScintillaEditView::setMultiSelections(const ColumnModeInfos &amp; cmi)
2421  {
2422  	for (size_t i = 0, len = cmi.size(); i &lt; len ; ++i)
2423  	{
2424  		if (cmi[i].isValid())
2425  		{
2426  			intptr_t selStart = cmi[i]._direction == L2R?cmi[i]._selLpos:cmi[i]._selRpos;
2427  			intptr_t selEnd   = cmi[i]._direction == L2R?cmi[i]._selRpos:cmi[i]._selLpos;
2428  			execute(SCI_SETSELECTIONNSTART, i, selStart);
2429  			execute(SCI_SETSELECTIONNEND, i, selEnd);
2430  		}
2431  		if (cmi[i]._nbVirtualAnchorSpc)
2432  			execute(SCI_SETSELECTIONNANCHORVIRTUALSPACE, i, cmi[i]._nbVirtualAnchorSpc);
2433  		if (cmi[i]._nbVirtualCaretSpc)
2434  			execute(SCI_SETSELECTIONNCARETVIRTUALSPACE, i, cmi[i]._nbVirtualCaretSpc);
2435  	}
2436  }
2437  pair&lt;size_t, size_t&gt; ScintillaEditView::getSelectionLinesRange(intptr_t selectionNumber &amp;bsol;* = -1 */) const
2438  {
2439  	size_t numSelections = execute(SCI_GETSELECTIONS);
2440  	size_t start_pos, end_pos;
2441  	if ((selectionNumber &lt; 0) || (static_cast&lt;size_t&gt;(selectionNumber) &gt;= numSelections))
2442  	{
2443  		start_pos = execute(SCI_GETSELECTIONSTART);
2444  		end_pos = execute(SCI_GETSELECTIONEND);
2445  	}
2446  	else
2447  	{
2448  		start_pos = execute(SCI_GETSELECTIONNSTART, selectionNumber);
2449  		end_pos = execute(SCI_GETSELECTIONNEND, selectionNumber);
2450  	}
2451  	size_t line1 = execute(SCI_LINEFROMPOSITION, start_pos);
2452  	size_t line2 = execute(SCI_LINEFROMPOSITION, end_pos);
2453  	if ((line1 != line2) &amp;&amp; (static_cast&lt;size_t&gt;(execute(SCI_POSITIONFROMLINE, line2)) == end_pos))
2454  	{
2455  		--line2;
2456  	}
2457  	return pair&lt;size_t, size_t&gt;(line1, line2);
2458  }
2459  void ScintillaEditView::currentLinesUp() const
2460  {
2461  	execute(SCI_MOVESELECTEDLINESUP);
2462  }
2463  void ScintillaEditView::currentLinesDown() const
2464  {
2465  	execute(SCI_MOVESELECTEDLINESDOWN);
2466  	execute(SCI_SCROLLRANGE, execute(SCI_GETSELECTIONEND), execute(SCI_GETSELECTIONSTART));
2467  }
2468  intptr_t ScintillaEditView::caseConvertRange(intptr_t start, intptr_t end, TextCase caseToConvert)
2469  {
2470  	if (end &lt;= start || uintptr_t(end) - uintptr_t(start) &gt; INT_MAX/2)
2471  		return 0;
2472  	unsigned codepage = getCurrentBuffer()-&gt;getUnicodeMode() == uni8Bit ? _codepage : CP_UTF8;
2473  	int mbLen = int(end - start);
2474  	const int mbLenMax = 2 * mbLen + 1;  
2475  	char *mbStr = new char[mbLenMax];
2476  	getText(mbStr, start, end);
2477  	if (int wideLen = ::MultiByteToWideChar(codepage, 0, mbStr, mbLen, NULL, 0))
2478  	{
2479  		wchar_t *wideStr = new wchar_t[wideLen];  
2480  		::MultiByteToWideChar(codepage, 0, mbStr, mbLen, wideStr, wideLen);
2481  		changeCase(wideStr, wideLen, caseToConvert);
2482  		if (int mbLenOut = ::WideCharToMultiByte(codepage, 0, wideStr, wideLen, mbStr, mbLenMax, NULL, NULL))
2483  		{
2484  			mbLen = mbLenOut;
2485  			execute(SCI_SETTARGETRANGE, start, end);
2486  			execute(SCI_REPLACETARGET, mbLen, reinterpret_cast&lt;LPARAM&gt;(mbStr));
2487  		}
2488  		delete [] wideStr;
2489  	}
2490  	delete [] mbStr;
2491  	return (start + mbLen) - end;
2492  }
2493  void ScintillaEditView::changeCase(__inout wchar_t * const strWToConvert, const int &amp; nbChars, const TextCase &amp; caseToConvert) const
2494  {
2495  	if (strWToConvert == nullptr || nbChars == 0)
2496  		return;
2497  	switch (caseToConvert)
2498  	{
2499  		case UPPERCASE:
2500  		{
2501  			for (int i = 0; i &lt; nbChars; ++i)
2502  			{
2503  				strWToConvert[i] = (WCHAR)(UINT_PTR)::CharUpperW(reinterpret_cast&lt;LPWSTR&gt;(strWToConvert[i]));
2504  			}
2505  			break; 
2506  		} 
2507  		case LOWERCASE:
2508  		{
2509  			for (int i = 0; i &lt; nbChars; ++i)
2510  			{
2511  				strWToConvert[i] = (WCHAR)(UINT_PTR)::CharLowerW(reinterpret_cast&lt;LPWSTR&gt;(strWToConvert[i]));
2512  			}
2513  			break; 
2514  		} 
2515  		case TITLECASE_FORCE:
2516  		case TITLECASE_BLEND:
2517  		{
2518  			for (int i = 0; i &lt; nbChars; ++i)
2519  			{
2520  				if (::IsCharAlphaW(strWToConvert[i]))
2521  				{
2522  					if ((i &lt; 1) ? true : !::IsCharAlphaNumericW(strWToConvert[i - 1]))
2523  						strWToConvert[i] = (WCHAR)(UINT_PTR)::CharUpperW(reinterpret_cast&lt;LPWSTR&gt;(strWToConvert[i]));
2524  					else if (caseToConvert == TITLECASE_FORCE)
2525  						strWToConvert[i] = (WCHAR)(UINT_PTR)::CharLowerW(reinterpret_cast&lt;LPWSTR&gt;(strWToConvert[i]));
2526  					if ((i &lt; 2) ? false : (strWToConvert[i - 1] == L&#x27;\&#x27;&#x27; &amp;&amp; ::IsCharAlphaW(strWToConvert[i - 2])))
2527  						strWToConvert[i] = (WCHAR)(UINT_PTR)::CharLowerW(reinterpret_cast&lt;LPWSTR&gt;(strWToConvert[i]));
2528  				}
2529  			}
2530  			break; 
2531  		} 
2532  		case SENTENCECASE_FORCE:
2533  		case SENTENCECASE_BLEND:
2534  		{
2535  			bool isNewSentence = true;
2536  			bool wasEolR = false;
2537  			bool wasEolN = false;
2538  			for (int i = 0; i &lt; nbChars; ++i)
2539  			{
2540  				if (::IsCharAlphaW(strWToConvert[i]))
2541  				{
2542  					if (isNewSentence)
2543  					{
2544  						strWToConvert[i] = (WCHAR)(UINT_PTR)::CharUpperW(reinterpret_cast&lt;LPWSTR&gt;(strWToConvert[i]));
2545  						isNewSentence = false;
2546  					}
2547  					else if (caseToConvert == SENTENCECASE_FORCE)
2548  					{
2549  						strWToConvert[i] = (WCHAR)(UINT_PTR)::CharLowerW(reinterpret_cast&lt;LPWSTR&gt;(strWToConvert[i]));
2550  					}
2551  					wasEolR = false;
2552  					wasEolN = false;
2553  					if (strWToConvert[i] == L&#x27;i&#x27; &amp;&amp;
2554  						((i &lt; 1) ? false : (::iswspace(strWToConvert[i - 1]) || strWToConvert[i - 1] == L&#x27;(&#x27; || strWToConvert[i - 1] == L&#x27;&quot;&#x27;)) &amp;&amp;
2555  						((i + 1 == nbChars) ? false : (::iswspace(strWToConvert[i + 1]) || strWToConvert[i + 1] == L&#x27;\&#x27;&#x27;)))
2556  					{
2557  						strWToConvert[i] = L&#x27;I&#x27;;
2558  					}
2559  				}
2560  				else if (strWToConvert[i] == L&#x27;.&#x27; || strWToConvert[i] == L&#x27;!&#x27; || strWToConvert[i] == L&#x27;?&#x27;)
2561  				{
2562  					if ((i + 1 == nbChars) ? true : ::IsCharAlphaNumericW(strWToConvert[i + 1]))
2563  						isNewSentence = false;
2564  					else
2565  						isNewSentence = true;
2566  				}
2567  				else if (strWToConvert[i] == L&#x27;\r&#x27;)
2568  				{
2569  					if (wasEolR)
2570  						isNewSentence = true;
2571  					else
2572  						wasEolR = true;
2573  				}
2574  				else if (strWToConvert[i] == L&#x27;\n&#x27;)
2575  				{
2576  					if (wasEolN)
2577  						isNewSentence = true;
2578  					else
2579  						wasEolN = true;
2580  				}
2581  			}
2582  			break;
2583  		} 
2584  		case INVERTCASE:
2585  		{
2586  			for (int i = 0; i &lt; nbChars; ++i)
2587  			{
2588  				if (::IsCharLowerW(strWToConvert[i]))
2589  					strWToConvert[i] = (WCHAR)(UINT_PTR)::CharUpperW(reinterpret_cast&lt;LPWSTR&gt;(strWToConvert[i]));
2590  				else
2591  					strWToConvert[i] = (WCHAR)(UINT_PTR)::CharLowerW(reinterpret_cast&lt;LPWSTR&gt;(strWToConvert[i]));
2592  			}
2593  			break; 
2594  		} 
2595  		case RANDOMCASE:
2596  		{
2597  			for (int i = 0; i &lt; nbChars; ++i)
2598  			{
2599  				if (::IsCharAlphaW(strWToConvert[i]))
2600  				{
2601  					if (std::rand() &amp; true)
2602  						strWToConvert[i] = (WCHAR)(UINT_PTR)::CharUpperW(reinterpret_cast&lt;LPWSTR&gt;(strWToConvert[i]));
2603  					else
2604  						strWToConvert[i] = (WCHAR)(UINT_PTR)::CharLowerW(reinterpret_cast&lt;LPWSTR&gt;(strWToConvert[i]));
2605  				}
2606  			}
2607  			break; 
2608  		} 
2609  	} 
2610  }
2611  void ScintillaEditView::convertSelectedTextTo(const TextCase &amp; caseToConvert)
2612  {
2613  	if (execute(SCI_GETSELECTIONS) &gt; 1) 
2614  	{
2615          execute(SCI_BEGINUNDOACTION);
2616  		ColumnModeInfos cmi = getColumnModeSelectInfo();
2617  		bool reversed = !cmi.empty() &amp;&amp; cmi.back()._selLpos &lt; cmi.front()._selLpos;
2618  		std::sort(cmi.begin(), cmi.end(), SortInPositionOrder());
2619  		intptr_t sizedelta = 0;
2620  		for (ColumnModeInfo&amp; info : cmi)
2621  		{
2622  			info._selLpos += sizedelta;
2623  			sizedelta += caseConvertRange(info._selLpos, info._selRpos + sizedelta, caseToConvert);
2624  			info._selRpos += sizedelta;
2625  		}
2626  		if (reversed)
2627  			std::reverse(cmi.begin(), cmi.end());
2628  		setMultiSelections(cmi);
2629  		execute(SCI_ENDUNDOACTION);
2630  		return;
2631  	}
2632  	size_t selectionStart = execute(SCI_GETSELECTIONSTART);
2633  	size_t selectionEnd = execute(SCI_GETSELECTIONEND);
2634  	if (selectionStart &lt; selectionEnd)
2635  	{
2636  		selectionEnd += caseConvertRange(selectionStart, selectionEnd, caseToConvert);
2637  		execute(SCI_SETSEL, selectionStart, selectionEnd);
2638  	}
2639  }
2640  pair&lt;size_t, size_t&gt; ScintillaEditView::getWordRange()
2641  {
2642  	size_t caretPos = execute(SCI_GETCURRENTPOS, 0, 0);
2643  	size_t startPos = execute(SCI_WORDSTARTPOSITION, caretPos, true);
2644  	size_t endPos = execute(SCI_WORDENDPOSITION, caretPos, true);
2645      return pair&lt;size_t, size_t&gt;(startPos, endPos);
2646  }
2647  bool ScintillaEditView::expandWordSelection()
2648  {
2649      pair&lt;size_t, size_t&gt; wordRange = 	getWordRange();
2650      if (wordRange.first != wordRange.second)
2651  	{
2652          execute(SCI_SETSELECTIONSTART, wordRange.first);
2653          execute(SCI_SETSELECTIONEND, wordRange.second);
2654  		return true;
2655  	}
2656  	return false;
2657  }
2658  TCHAR* int2str(TCHAR* str, int strLen, int number, int base, int nbDigits, ColumnEditorParam::leadingChoice lead)
2659  {
2660  	if (nbDigits &gt;= strLen) return NULL;
2661  	if (base == 2)
2662  	{
2663  		const unsigned int MASK_ULONG_BITFORT = 0x80000000;
2664  		int nbBits = sizeof(unsigned int) * 8;
2665  		int nbBit2Shift = (nbDigits &gt;= nbBits) ? nbBits : (nbBits - nbDigits);
2666  		unsigned long mask = MASK_ULONG_BITFORT &gt;&gt; nbBit2Shift;
2667  		int i = 0;
2668  		for (; mask &gt; 0; ++i)
2669  		{
2670  			str[i] = (mask &amp; number) ? &#x27;1&#x27; : &#x27;0&#x27;;
2671  			mask &gt;&gt;= 1;
2672  		}
2673  		str[i] = &#x27;\0&#x27;;
2674  		if (lead == ColumnEditorParam::spaceLeading)
2675  		{
2676  			for (TCHAR* j = str; *j != &#x27;\0&#x27;; ++j)
2677  			{
2678  				if ((*j == &#x27;1&#x27;) || (*(j + 1) == &#x27;\0&#x27;))
2679  				{
2680  					break;
2681  				}
2682  				else
2683  				{
2684  					*j = &#x27; &#x27;;
2685  				}
2686  			}
2687  		}
2688  		else if (lead != ColumnEditorParam::zeroLeading)
2689  		{
2690  			for (TCHAR* j = str; *j != &#x27;\0&#x27;; ++j)
2691  			{
2692  				if (*j == &#x27;1&#x27; || *(j + 1) == &#x27;\0&#x27;)
2693  				{
2694  					wcscpy_s(str, strLen, j);
2695  					break;
2696  				}
2697  			}
2698  			int i = lstrlen(str);
2699  			for (; i &lt; nbDigits; ++i)
2700  			{
2701  				str[i] = &#x27; &#x27;;
2702  			}
2703  			str[i] = &#x27;\0&#x27;;
2704  		}
2705  	}
2706  	else
2707  	{
2708  		constexpr size_t bufSize = 64;
2709  		TCHAR f[bufSize] = { &#x27;\0&#x27; };
2710  		TCHAR fStr[2] = TEXT(&quot;d&quot;);
2711  		if (base == 16)
2712  			fStr[0] = &#x27;X&#x27;;
2713  		else if (base == 8)
2714  			fStr[0] = &#x27;o&#x27;;
2715  		if (lead == ColumnEditorParam::zeroLeading)
2716  		{
2717  			swprintf(f, bufSize, TEXT(&quot;%%.%d%s&quot;), nbDigits, fStr);
2718  		}
2719  		else if (lead == ColumnEditorParam::spaceLeading)
2720  		{
2721  			swprintf(f, bufSize, TEXT(&quot;%%%d%s&quot;), nbDigits, fStr);
2722  		}
2723  		else
2724  		{
2725  			swprintf(f, bufSize, TEXT(&quot;%%-%d%s&quot;), nbDigits, fStr);
2726  		}
2727  		swprintf(str, strLen, f, number);
2728  	}
2729  	return str;
2730  }
2731  ColumnModeInfos ScintillaEditView::getColumnModeSelectInfo()
2732  {
2733  	ColumnModeInfos columnModeInfos;
2734  	if (execute(SCI_GETSELECTIONS) &gt; 1) 
2735  	{
2736  		intptr_t nbSel = execute(SCI_GETSELECTIONS);
2737  		for (int i = 0 ; i &lt; nbSel ; ++i)
2738  		{
2739  			intptr_t absPosSelStartPerLine = execute(SCI_GETSELECTIONNANCHOR, i);
2740  			intptr_t absPosSelEndPerLine = execute(SCI_GETSELECTIONNCARET, i);
2741  			intptr_t nbVirtualAnchorSpc = execute(SCI_GETSELECTIONNANCHORVIRTUALSPACE, i);
2742  			intptr_t nbVirtualCaretSpc = execute(SCI_GETSELECTIONNCARETVIRTUALSPACE, i);
2743  			if (absPosSelStartPerLine == absPosSelEndPerLine &amp;&amp; execute(SCI_SELECTIONISRECTANGLE))
2744  			{
2745  				bool dir = nbVirtualAnchorSpc&lt;nbVirtualCaretSpc?L2R:R2L;
2746  				columnModeInfos.push_back(ColumnModeInfo(absPosSelStartPerLine, absPosSelEndPerLine, i, dir, nbVirtualAnchorSpc, nbVirtualCaretSpc));
2747  			}
2748  			else if (absPosSelStartPerLine &gt; absPosSelEndPerLine)
2749  				columnModeInfos.push_back(ColumnModeInfo(absPosSelEndPerLine, absPosSelStartPerLine, i, R2L, nbVirtualAnchorSpc, nbVirtualCaretSpc));
2750  			else
2751  				columnModeInfos.push_back(ColumnModeInfo(absPosSelStartPerLine, absPosSelEndPerLine, i, L2R, nbVirtualAnchorSpc, nbVirtualCaretSpc));
2752  		}
2753  	}
2754  	return columnModeInfos;
2755  }
2756  void ScintillaEditView::columnReplace(ColumnModeInfos &amp; cmi, const TCHAR *str)
2757  {
2758  	intptr_t totalDiff = 0;
2759  	for (size_t i = 0, len = cmi.size(); i &lt; len ; ++i)
2760  	{
2761  		if (cmi[i].isValid())
2762  		{
2763  			intptr_t len2beReplace = cmi[i]._selRpos - cmi[i]._selLpos;
2764  			intptr_t diff = lstrlen(str) - len2beReplace;
2765  			cmi[i]._selLpos += totalDiff;
2766  			cmi[i]._selRpos += totalDiff;
2767  			bool hasVirtualSpc = cmi[i]._nbVirtualAnchorSpc &gt; 0;
2768  			if (hasVirtualSpc) 
2769  			{
2770  				for (intptr_t j = 0, k = cmi[i]._selLpos; j &lt; cmi[i]._nbVirtualCaretSpc ; ++j, ++k)
2771  				{
2772  					execute(SCI_INSERTTEXT, k, reinterpret_cast&lt;LPARAM&gt;(&quot; &quot;));
2773  				}
2774  				cmi[i]._selLpos += cmi[i]._nbVirtualAnchorSpc;
2775  				cmi[i]._selRpos += cmi[i]._nbVirtualCaretSpc;
2776  			}
2777  			execute(SCI_SETTARGETRANGE, cmi[i]._selLpos, cmi[i]._selRpos);
2778  			WcharMbcsConvertor&amp; wmc = WcharMbcsConvertor::getInstance();
2779  			size_t cp = execute(SCI_GETCODEPAGE);
2780  			const char *strA = wmc.wchar2char(str, cp);
2781  			execute(SCI_REPLACETARGET, static_cast&lt;WPARAM&gt;(-1), reinterpret_cast&lt;LPARAM&gt;(strA));
2782  			if (hasVirtualSpc)
2783  			{
2784  				totalDiff += cmi[i]._nbVirtualAnchorSpc + lstrlen(str);
2785  				cmi[i]._nbVirtualAnchorSpc = 0;
2786  				cmi[i]._nbVirtualCaretSpc = 0;
2787  			}
2788  			else
2789  			{
2790  				totalDiff += diff;
2791  			}
2792  			cmi[i]._selRpos += diff;
2793  		}
2794  	}
2795  }
2796  void ScintillaEditView::columnReplace(ColumnModeInfos &amp; cmi, int initial, int incr, int repeat, UCHAR format, ColumnEditorParam::leadingChoice lead)
2797  {
2798  	assert(repeat &gt; 0);
2799  	if (cmi.size() &lt;= 0)
2800  		return;
2801  	UCHAR f = format &amp; MASK_FORMAT;
2802  	int base = 10;
2803  	if (f == BASE_16)
2804  		base = 16;
2805  	else if (f == BASE_08)
2806  		base = 8;
2807  	else if (f == BASE_02)
2808  		base = 2;
2809  	const int stringSize = 512;
2810  	TCHAR str[stringSize];
2811  	std::vector&lt;int&gt; numbers;
2812  	{
2813  		int curNumber = initial;
2814  		const size_t kiMaxSize = cmi.size();
2815  		while (numbers.size() &lt; kiMaxSize)
2816  		{
2817  			for (int i = 0; i &lt; repeat; i++)
2818  			{
2819  				numbers.push_back(curNumber);
2820  				if (numbers.size() &gt;= kiMaxSize)
2821  				{
2822  					break;
2823  				}
2824  			}
2825  			curNumber += incr;
2826  		}
2827  	}
2828  	assert(numbers.size()&gt; 0);
2829  	const int kibEnd = getNbDigits(*numbers.rbegin(), base);
2830  	const int kibInit = getNbDigits(initial, base);
2831  	const int kib = std::max&lt;int&gt;(kibInit, kibEnd);
2832  	intptr_t totalDiff = 0;
2833  	const size_t len = cmi.size();
2834  	for (size_t i = 0 ; i &lt; len ; i++)
2835  	{
2836  		if (cmi[i].isValid())
2837  		{
2838  			const intptr_t len2beReplaced = cmi[i]._selRpos - cmi[i]._selLpos;
2839  			const intptr_t diff = kib - len2beReplaced;
2840  			cmi[i]._selLpos += totalDiff;
2841  			cmi[i]._selRpos += totalDiff;
2842  			int2str(str, stringSize, numbers.at(i), base, kib, lead);
2843  			const bool hasVirtualSpc = cmi[i]._nbVirtualAnchorSpc &gt; 0;
2844  			if (hasVirtualSpc) 
2845  			{
2846  				for (intptr_t j = 0, k = cmi[i]._selLpos; j &lt; cmi[i]._nbVirtualCaretSpc ; ++j, ++k)
2847  				{
2848  					execute(SCI_INSERTTEXT, k, reinterpret_cast&lt;LPARAM&gt;(&quot; &quot;));
2849  				}
2850  				cmi[i]._selLpos += cmi[i]._nbVirtualAnchorSpc;
2851  				cmi[i]._selRpos += cmi[i]._nbVirtualCaretSpc;
2852  			}
2853  			execute(SCI_SETTARGETRANGE, cmi[i]._selLpos, cmi[i]._selRpos);
2854  			WcharMbcsConvertor&amp; wmc = WcharMbcsConvertor::getInstance();
2855  			size_t cp = execute(SCI_GETCODEPAGE);
2856  			const char *strA = wmc.wchar2char(str, cp);
2857  			execute(SCI_REPLACETARGET, static_cast&lt;WPARAM&gt;(-1), reinterpret_cast&lt;LPARAM&gt;(strA));
2858  			if (hasVirtualSpc)
2859  			{
2860  				totalDiff += cmi[i]._nbVirtualAnchorSpc + lstrlen(str);
2861  				cmi[i]._nbVirtualAnchorSpc = 0;
2862  				cmi[i]._nbVirtualCaretSpc = 0;
2863  			}
2864  			else
2865  			{
2866  				totalDiff += diff;
2867  			}
2868  			cmi[i]._selRpos += diff;
2869  		}
2870  	}
2871  }
2872  bool ScintillaEditView::getIndicatorRange(size_t indicatorNumber, size_t* from, size_t* to, size_t* cur)
2873  {
2874  	size_t curPos = execute(SCI_GETCURRENTPOS);
2875  	size_t indicMsk = execute(SCI_INDICATORALLONFOR, curPos);
2876  	if (!(static_cast&lt;int&gt;(indicMsk) &amp; (1 &lt;&lt; indicatorNumber)))
2877  		return false;
2878  	size_t startPos = execute(SCI_INDICATORSTART, indicatorNumber, curPos);
2879  	size_t endPos = execute(SCI_INDICATOREND, indicatorNumber, curPos);
2880  	if ((curPos &lt; startPos) || (curPos &gt; endPos))
2881  		return false;
2882  	if (from) *from = startPos;
2883  	if (to) *to = endPos;
2884  	if (cur) *cur = curPos;
2885  	return true;
2886  }
2887  void ScintillaEditView::scrollPosToCenter(size_t pos)
2888  {
2889  	_positionRestoreNeeded = false;
2890  	execute(SCI_GOTOPOS, pos);
2891  	size_t line = execute(SCI_LINEFROMPOSITION, pos);
2892  	size_t firstVisibleDisplayLine = execute(SCI_GETFIRSTVISIBLELINE);
2893  	size_t firstVisibleDocLine = execute(SCI_DOCLINEFROMVISIBLE, firstVisibleDisplayLine);
2894  	size_t nbLine = execute(SCI_LINESONSCREEN, firstVisibleDisplayLine);
2895  	size_t lastVisibleDocLine = execute(SCI_DOCLINEFROMVISIBLE, firstVisibleDisplayLine + nbLine);
2896  	size_t middleLine;
2897  	if (line - firstVisibleDocLine &lt; lastVisibleDocLine - line)
2898  		middleLine = firstVisibleDocLine + nbLine/2;
2899  	else
2900  		middleLine = lastVisibleDocLine -  nbLine/2;
2901  	size_t nbLines2scroll =  line - middleLine;
2902  	scroll(0, nbLines2scroll);
2903  	execute(SCI_ENSUREVISIBLEENFORCEPOLICY, line);
2904  }
2905  void ScintillaEditView::hideLines()
2906  {
2907  	size_t startLine = execute(SCI_LINEFROMPOSITION, execute(SCI_GETSELECTIONSTART));
2908  	size_t endLine = execute(SCI_LINEFROMPOSITION, execute(SCI_GETSELECTIONEND));
2909  	size_t nbLines = execute(SCI_GETLINECOUNT);
2910  	if (nbLines &lt; 3)
2911  		return;	
2912  	if (!startLine)
2913  		++startLine;
2914  	if (endLine == (nbLines-1))
2915  		--endLine;
2916  	if (startLine &gt; endLine)
2917  		return;	
2918  	int scope = 0;
2919  	bool recentMarkerWasOpen = false;
2920  	auto removeMarker = [this, &amp;scope, &amp;recentMarkerWasOpen](size_t line)
2921  	{
2922  		auto state = execute(SCI_MARKERGET, line);
2923  		bool closePresent = (state &amp; (1 &lt;&lt; MARK_HIDELINESEND)) != 0;
2924  		bool openPresent = (state &amp; (1 &lt;&lt; MARK_HIDELINESBEGIN)) != 0;
2925  		if (closePresent)
2926  		{
2927  			execute(SCI_MARKERDELETE, line, MARK_HIDELINESEND);
2928  			recentMarkerWasOpen = false;
2929  			--scope;
2930  		}
2931  		if (openPresent)
2932  		{
2933  			execute(SCI_MARKERDELETE, line, MARK_HIDELINESBEGIN);
2934  			recentMarkerWasOpen = true;
2935  			++scope;
2936  		}
2937  	};
2938  	size_t startMarker = startLine - 1;
2939  	size_t endMarker = endLine + 1;
2940  	for (size_t i = startMarker; i &lt;= endMarker; ++i)
2941  		removeMarker(i);
2942  	if (scope == 0 &amp;&amp; recentMarkerWasOpen)
2943  	{
2944  		while (scope == 0)
2945  			removeMarker(--startMarker);
2946  		while (scope != 0)
2947  			removeMarker(++endMarker);
2948  	}
2949  	else
2950  	{
2951  		while (scope &lt; 0)
2952  			removeMarker(--startMarker);
2953  		while (scope &gt; 0)
2954  			removeMarker(++endMarker);
2955  	}
2956  	execute(SCI_MARKERADD, startMarker, MARK_HIDELINESBEGIN);
2957  	execute(SCI_MARKERADD, endMarker, MARK_HIDELINESEND);
2958  	_currentBuffer-&gt;setHideLineChanged(true, startMarker);
2959  }
2960  bool ScintillaEditView::markerMarginClick(intptr_t lineNumber)
2961  {
2962  	auto state = execute(SCI_MARKERGET, lineNumber);
2963  	bool openPresent = (state &amp; (1 &lt;&lt; MARK_HIDELINESBEGIN)) != 0;
2964  	bool closePresent = (state &amp; (1 &lt;&lt; MARK_HIDELINESEND)) != 0;
2965  	if (!openPresent &amp;&amp; !closePresent)
2966  		return false;
2967  	if (openPresent)
2968  	{
2969  		_currentBuffer-&gt;setHideLineChanged(false, lineNumber);
2970  	}
2971  	if (closePresent)
2972  	{
2973  		openPresent = false;
2974  		for (lineNumber--; lineNumber &gt;= 0 &amp;&amp; !openPresent; lineNumber--)
2975  		{
2976  			state = execute(SCI_MARKERGET, lineNumber);
2977  			openPresent = (state &amp; (1 &lt;&lt; MARK_HIDELINESBEGIN)) != 0;
2978  		}
2979  		if (openPresent)
2980  		{
2981  			_currentBuffer-&gt;setHideLineChanged(false, lineNumber + 1);
2982  		}
2983  	}
2984  	return true;
2985  }
2986  void ScintillaEditView::notifyMarkers(Buffer * buf, bool isHide, size_t location, bool del)
2987  {
2988  	if (buf != _currentBuffer)	
2989  		return;
2990  	runMarkers(isHide, location, false, del);
2991  }
2992  void ScintillaEditView::runMarkers(bool doHide, size_t searchStart, bool endOfDoc, bool doDelete)
2993  {
2994  	size_t maxLines = execute(SCI_GETLINECOUNT);
2995  	if (doHide)
2996  	{
2997  		auto startHiding = searchStart;
2998  		bool isInSection = false;
2999  		for (auto i = searchStart; i &lt; maxLines; ++i)
3000  		{
3001  			auto state = execute(SCI_MARKERGET, i);
3002  			if ( ((state &amp; (1 &lt;&lt; MARK_HIDELINESEND)) != 0) )
3003  			{
3004  				if (isInSection)
3005  				{
3006  					execute(SCI_HIDELINES, startHiding, i-1);
3007  					if (!endOfDoc)
3008  					{
3009  						return;	
3010  					}	
3011  				}
3012  				isInSection = false;
3013  			}
3014  			if ((state &amp; (1 &lt;&lt; MARK_HIDELINESBEGIN)) != 0)
3015  			{
3016  				isInSection = true;
3017  				startHiding = i+1;
3018  			}
3019  		}
3020  	}
3021  	else
3022  	{
3023  		auto startShowing = searchStart;
3024  		bool isInSection = false;
3025  		for (auto i = searchStart; i &lt; maxLines; ++i)
3026  		{
3027  			auto state = execute(SCI_MARKERGET, i);
3028  			if ( ((state &amp; (1 &lt;&lt; MARK_HIDELINESEND)) != 0) )
3029  			{
3030  				if (doDelete)
3031  				{
3032  					execute(SCI_MARKERDELETE, i, MARK_HIDELINESEND);
3033  					if (!endOfDoc)
3034  					{
3035  						return;	
3036  					}	
3037  				}
3038  				 else if (isInSection)
3039  				 {
3040  					if (startShowing &gt;= i)
3041  					{	
3042  						if (!endOfDoc)
3043  						{
3044  							return;
3045  						}
3046  						else
3047  						{
3048  							continue;
3049  						}
3050  					}
3051  					execute(SCI_SHOWLINES, startShowing, i-1);
3052  					if (!endOfDoc)
3053  					{
3054  						return;	
3055  					}	
3056  					isInSection = false;
3057  				}
3058  			}
3059  			if ((state &amp; (1 &lt;&lt; MARK_HIDELINESBEGIN)) != 0)
3060  			{
3061  				if (doDelete)
3062  				{
3063  					execute(SCI_MARKERDELETE, i, MARK_HIDELINESBEGIN);
3064  				}
3065  				else
3066  				{
3067  					isInSection = true;
3068  					startShowing = i+1;
3069  				}
3070  			}
3071  			auto levelLine = execute(SCI_GETFOLDLEVEL, i, 0);
3072  			if (levelLine &amp; SC_FOLDLEVELHEADERFLAG)
3073  			{	
3074  				if (isInSection &amp;&amp; !isFolded(i))
3075  				{
3076  					execute(SCI_SHOWLINES, startShowing, i);
3077  				}
3078  			}
3079  		}
3080  	}
3081  }
3082  void ScintillaEditView::setTabSettings(Lang *lang)
3083  {
3084  	if (lang &amp;&amp; lang-&gt;_tabSize != -1 &amp;&amp; lang-&gt;_tabSize != 0)
3085  	{
3086  		if (lang-&gt;_langID == L_JAVASCRIPT)
3087  		{
3088  			Lang *ljs = NppParameters::getInstance().getLangFromID(L_JS);
3089  			execute(SCI_SETTABWIDTH, ljs-&gt;_tabSize &gt; 0 ? ljs-&gt;_tabSize : lang-&gt;_tabSize);
3090  			execute(SCI_SETUSETABS, !ljs-&gt;_isTabReplacedBySpace);
3091  			return;
3092  		}
3093  		execute(SCI_SETTABWIDTH, lang-&gt;_tabSize);
3094  		execute(SCI_SETUSETABS, !lang-&gt;_isTabReplacedBySpace);
3095  	}
3096      else
3097  	{
3098  		const NppGUI &amp; nppgui = NppParameters::getInstance().getNppGUI();
3099  		execute(SCI_SETTABWIDTH, nppgui._tabSize  &gt; 0 ? nppgui._tabSize : 4);
3100  		execute(SCI_SETUSETABS, !nppgui._tabReplacedBySpace);
3101  	}
3102  }
3103  void ScintillaEditView::insertNewLineAboveCurrentLine()
3104  {
3105  	generic_string newline = getEOLString();
3106  	const auto current_line = getCurrentLineNumber();
3107  	if (current_line == 0)
3108  	{
3109  		insertGenericTextFrom(0, newline.c_str());
3110  	}
3111  	else
3112  	{
3113  		const auto eol_length = newline.length();
3114  		const auto position = execute(SCI_POSITIONFROMLINE, current_line) - eol_length;
3115  		insertGenericTextFrom(position, newline.c_str());
3116  	}
3117  	execute(SCI_SETEMPTYSELECTION, execute(SCI_POSITIONFROMLINE, current_line));
3118  }
3119  void ScintillaEditView::insertNewLineBelowCurrentLine()
3120  {
3121  	generic_string newline = getEOLString();
3122  	const auto line_count = execute(SCI_GETLINECOUNT);
3123  	const auto current_line = getCurrentLineNumber();
3124  	if (current_line == line_count - 1)
3125  	{
3126  		appandGenericText(newline.c_str());
3127  	}
3128  	else
3129  	{
3130  		const auto eol_length = newline.length();
3131  		const auto position = eol_length + execute(SCI_GETLINEENDPOSITION, current_line);
3132  		insertGenericTextFrom(position, newline.c_str());
3133  	}
3134  	execute(SCI_SETEMPTYSELECTION, execute(SCI_POSITIONFROMLINE, current_line + 1));
3135  }
3136  void ScintillaEditView::sortLines(size_t fromLine, size_t toLine, ISorter* pSort)
3137  {
3138  	if (fromLine &gt;= toLine)
3139  	{
3140  		return;
3141  	}
3142  	const auto startPos = execute(SCI_POSITIONFROMLINE, fromLine);
3143  	const auto endPos = execute(SCI_POSITIONFROMLINE, toLine) + execute(SCI_LINELENGTH, toLine);
3144  	const generic_string text = getGenericTextAsString(startPos, endPos);
3145  	std::vector&lt;generic_string&gt; splitText = stringSplit(text, getEOLString());
3146  	const size_t lineCount = execute(SCI_GETLINECOUNT);
3147  	const bool sortEntireDocument = toLine == lineCount - 1;
3148  	if (!sortEntireDocument)
3149  	{
3150  		if (splitText.rbegin()-&gt;empty())
3151  		{
3152  			splitText.pop_back();
3153  		}
3154  	}
3155  	assert(toLine - fromLine + 1 == splitText.size());
3156  	const std::vector&lt;generic_string&gt; sortedText = pSort-&gt;sort(splitText);
3157  	generic_string joined = stringJoin(sortedText, getEOLString());
3158  	if (sortEntireDocument)
3159  	{
3160  		assert(joined.length() == text.length());
3161  	}
3162  	else
3163  	{
3164  		assert(joined.length() + getEOLString().length() == text.length());
3165  		joined += getEOLString();
3166  	}
3167  	if (text != joined)
3168  	{
3169  		replaceTarget(joined.c_str(), startPos, endPos);
3170  	}
3171  }
3172  bool ScintillaEditView::isTextDirectionRTL() const
3173  {
3174  	long exStyle = static_cast&lt;long&gt;(::GetWindowLongPtr(_hSelf, GWL_EXSTYLE));
3175  	return (exStyle &amp; WS_EX_LAYOUTRTL) != 0;
3176  }
3177  void ScintillaEditView::changeTextDirection(bool isRTL)
3178  {
3179  	long exStyle = static_cast&lt;long&gt;(::GetWindowLongPtr(_hSelf, GWL_EXSTYLE));
3180  	exStyle = isRTL ? (exStyle | WS_EX_LAYOUTRTL) : (exStyle &amp; (~WS_EX_LAYOUTRTL));
3181  	::SetWindowLongPtr(_hSelf, GWL_EXSTYLE, exStyle);
3182  	if (isRTL)
3183  	{
3184  		execute(SCI_ASSIGNCMDKEY, SCK_RIGHT, SCI_CHARLEFT);
3185  		execute(SCI_ASSIGNCMDKEY, SCK_RIGHT + (SCMOD_SHIFT &lt;&lt; 16), SCI_CHARLEFTEXTEND);
3186  		execute(SCI_ASSIGNCMDKEY, SCK_RIGHT + ((SCMOD_SHIFT + SCMOD_ALT) &lt;&lt; 16), SCI_CHARLEFTRECTEXTEND);
3187  		execute(SCI_ASSIGNCMDKEY, SCK_RIGHT + (SCMOD_CTRL &lt;&lt; 16), SCI_WORDLEFT);
3188  		execute(SCI_ASSIGNCMDKEY, SCK_RIGHT + ((SCMOD_SHIFT + SCMOD_CTRL) &lt;&lt; 16), SCI_WORDLEFTEXTEND);
3189  		execute(SCI_ASSIGNCMDKEY, SCK_LEFT, SCI_CHARRIGHT);
3190  		execute(SCI_ASSIGNCMDKEY, SCK_LEFT + (SCMOD_SHIFT &lt;&lt; 16), SCI_CHARRIGHTEXTEND);
3191  		execute(SCI_ASSIGNCMDKEY, SCK_LEFT + ((SCMOD_SHIFT + SCMOD_ALT) &lt;&lt; 16), SCI_CHARRIGHTRECTEXTEND);
3192  		execute(SCI_ASSIGNCMDKEY, SCK_LEFT + (SCMOD_CTRL &lt;&lt; 16), SCI_WORDRIGHT);
3193  		execute(SCI_ASSIGNCMDKEY, SCK_LEFT + ((SCMOD_SHIFT + SCMOD_CTRL) &lt;&lt; 16), SCI_WORDRIGHTEXTEND);
3194  	}
3195  	else
3196  	{
3197  		execute(SCI_ASSIGNCMDKEY, SCK_RIGHT, SCI_CHARRIGHT);
3198  		execute(SCI_ASSIGNCMDKEY, SCK_RIGHT + (SCMOD_SHIFT &lt;&lt; 16), SCI_CHARRIGHTEXTEND);
3199  		execute(SCI_ASSIGNCMDKEY, SCK_RIGHT + ((SCMOD_SHIFT + SCMOD_ALT) &lt;&lt; 16), SCI_CHARRIGHTRECTEXTEND);
3200  		execute(SCI_ASSIGNCMDKEY, SCK_RIGHT + (SCMOD_CTRL &lt;&lt; 16), SCI_WORDRIGHT);
3201  		execute(SCI_ASSIGNCMDKEY, SCK_RIGHT + ((SCMOD_SHIFT + SCMOD_CTRL) &lt;&lt; 16), SCI_WORDRIGHTEXTEND);
3202  		execute(SCI_ASSIGNCMDKEY, SCK_LEFT, SCI_CHARLEFT);
3203  		execute(SCI_ASSIGNCMDKEY, SCK_LEFT + (SCMOD_SHIFT &lt;&lt; 16), SCI_CHARLEFTEXTEND);
3204  		execute(SCI_ASSIGNCMDKEY, SCK_LEFT + ((SCMOD_SHIFT + SCMOD_ALT) &lt;&lt; 16), SCI_CHARLEFTRECTEXTEND);
3205  		execute(SCI_ASSIGNCMDKEY, SCK_LEFT + (SCMOD_CTRL &lt;&lt; 16), SCI_WORDLEFT);
3206  		execute(SCI_ASSIGNCMDKEY, SCK_LEFT + ((SCMOD_SHIFT + SCMOD_CTRL) &lt;&lt; 16), SCI_WORDLEFTEXTEND);
3207  	}
3208  }
3209  generic_string ScintillaEditView::getEOLString()
3210  {
3211  	intptr_t eol_mode = execute(SCI_GETEOLMODE);
3212  	if (eol_mode == SC_EOL_CRLF)
3213  	{
3214  		return TEXT(&quot;\r\n&quot;);
3215  	}
3216  	else if (eol_mode == SC_EOL_LF)
3217  	{
3218  		return TEXT(&quot;\n&quot;);
3219  	}
3220  	else
3221  	{
3222  		return TEXT(&quot;\r&quot;);
3223  	}
3224  }
3225  void ScintillaEditView::setBorderEdge(bool doWithBorderEdge)
3226  {
3227  	long style = static_cast&lt;long&gt;(::GetWindowLongPtr(_hSelf, GWL_STYLE));
3228  	long exStyle = static_cast&lt;long&gt;(::GetWindowLongPtr(_hSelf, GWL_EXSTYLE));
3229  	if (NppDarkMode::isEnabled())
3230  	{
3231  		exStyle &amp;= ~WS_EX_CLIENTEDGE;
3232  		if (doWithBorderEdge)
3233  			style |= WS_BORDER;
3234  		else
3235  			style &amp;= ~WS_BORDER;
3236  	}
3237  	else
3238  	{
3239  		style &amp;= ~WS_BORDER;
3240  		if (doWithBorderEdge)
3241  			exStyle |= WS_EX_CLIENTEDGE;
3242  		else
3243  			exStyle &amp;= ~WS_EX_CLIENTEDGE;
3244  	}
3245  	::SetWindowLongPtr(_hSelf, GWL_STYLE, style);
3246  	::SetWindowLongPtr(_hSelf, GWL_EXSTYLE, exStyle);
3247  	::SetWindowPos(_hSelf, NULL, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_FRAMECHANGED);
3248  }
3249  void ScintillaEditView::getFoldColor(COLORREF&amp; fgColor, COLORREF&amp; bgColor, COLORREF&amp; activeFgColor)
3250  {
3251  	StyleArray &amp; stylers = NppParameters::getInstance().getMiscStylerArray();
3252  	const Style * pStyle = stylers.findByName(TEXT(&quot;Fold&quot;));
3253  	if (pStyle)
3254  	{
3255  		fgColor = pStyle-&gt;_bgColor;
3256  		bgColor = pStyle-&gt;_fgColor;
3257  	}
3258  	pStyle = stylers.findByName(TEXT(&quot;Fold active&quot;));
3259  	if (pStyle)
3260  	{
3261  		activeFgColor = pStyle-&gt;_fgColor;
3262  	}
3263  }
3264  int ScintillaEditView::getTextZoneWidth() const
3265  {
3266  	RECT editorRect;
3267  	getClientRect(editorRect);
3268  	intptr_t marginWidths = 0;
3269  	for (int m = 0; m &lt; 4; ++m)
3270  	{
3271  		marginWidths += execute(SCI_GETMARGINWIDTHN, m);
3272  	}
3273  	return editorRect.right - editorRect.left - static_cast&lt;LONG&gt;(marginWidths);
3274  }
3275  pair&lt;size_t, size_t&gt; ScintillaEditView::getSelectedCharsAndLinesCount(long long maxSelectionsForLineCount &amp;bsol;* = -1 */) const
3276  {
3277  	pair&lt;size_t, size_t&gt; selectedCharsAndLines(0, 0);
3278  	selectedCharsAndLines.first = getUnicodeSelectedLength();
3279  	size_t numSelections = execute(SCI_GETSELECTIONS);
3280  	if (numSelections == 1)
3281  	{
3282  		pair&lt;size_t, size_t&gt; lineRange = getSelectionLinesRange();
3283  		selectedCharsAndLines.second = lineRange.second - lineRange.first + 1;
3284  	}
3285  	else if (execute(SCI_SELECTIONISRECTANGLE))
3286  	{
3287  		selectedCharsAndLines.second = numSelections;
3288  	}
3289  	else if ((maxSelectionsForLineCount == -1) ||  
3290  		(numSelections &lt;= static_cast&lt;size_t&gt;(maxSelectionsForLineCount)))
3291  	{
3292  		vector&lt; pair &lt;size_t, size_t&gt; &gt; v;
3293  		for (size_t s = 0; s &lt; numSelections; ++s)
3294  		{
3295  			v.push_back(getSelectionLinesRange(s));
3296  		}
3297  		sort(v.begin(), v.end());
3298  		intptr_t previousSecondLine = -1;
3299  		for (auto&amp; lineRange : v)
3300  		{
3301  			selectedCharsAndLines.second += lineRange.second - lineRange.first;
3302  			if (lineRange.first != static_cast&lt;size_t&gt;(previousSecondLine))
3303  			{
3304  				++selectedCharsAndLines.second;
3305  			}
3306  			previousSecondLine = static_cast&lt;intptr_t&gt;(lineRange.second);
3307  		}
3308  	}
3309  	return selectedCharsAndLines;
3310  }
3311  size_t ScintillaEditView::getUnicodeSelectedLength() const
3312  {
3313  	size_t length = 0;
3314  	size_t numSelections = execute(SCI_GETSELECTIONS);
3315  	for (size_t s = 0; s &lt; numSelections; ++s)
3316  	{
3317  		size_t start = execute(SCI_GETSELECTIONNSTART, s);
3318  		size_t end = execute(SCI_GETSELECTIONNEND, s);
3319  		length += execute(SCI_COUNTCHARACTERS, start, end);
3320  	}
3321  	return length;
3322  }
3323  void ScintillaEditView::markedTextToClipboard(int indiStyle, bool doAll &amp;bsol;*= false*/)
3324  {
3325  	int styleIndicators[] =
3326  	{
3327  		SCE_UNIVERSAL_FOUND_STYLE_EXT1,
3328  		SCE_UNIVERSAL_FOUND_STYLE_EXT2,
3329  		SCE_UNIVERSAL_FOUND_STYLE_EXT3,
3330  		SCE_UNIVERSAL_FOUND_STYLE_EXT4,
3331  		SCE_UNIVERSAL_FOUND_STYLE_EXT5,
3332  		-1  
3333  	};
3334  	if (!doAll)
3335  	{
3336  		styleIndicators[0] = indiStyle;
3337  		styleIndicators[1] = -1;
3338  	}
3339  	std::vector&lt;std::pair&lt;size_t, generic_string&gt;&gt; styledVect;
3340  	const generic_string cr = TEXT(&quot;\r&quot;);
3341  	const generic_string lf = TEXT(&quot;\n&quot;);
3342  	bool textContainsLineEndingChar = false;
3343  	for (int si = 0; styleIndicators[si] != -1; ++si)
3344  	{
3345  		size_t pos = execute(SCI_INDICATOREND, styleIndicators[si], 0);
3346  		if (pos &gt; 0)
3347  		{
3348  			bool atEndOfIndic = execute(SCI_INDICATORVALUEAT, styleIndicators[si], 0) != 0;
3349  			size_t prevPos = pos;
3350  			if (atEndOfIndic) prevPos = 0;
3351  			do
3352  			{
3353  				if (atEndOfIndic)
3354  				{
3355  					generic_string styledText = getGenericTextAsString(prevPos, pos);
3356  					if (!textContainsLineEndingChar)
3357  					{
3358  						if (styledText.find(cr) != std::string::npos ||
3359  							styledText.find(lf) != std::string::npos)
3360  						{
3361  							textContainsLineEndingChar = true;
3362  						}
3363  					}
3364  					styledVect.push_back(::make_pair(prevPos, styledText));
3365  				}
3366  				atEndOfIndic = !atEndOfIndic;
3367  				prevPos = pos;
3368  				pos = execute(SCI_INDICATOREND, styleIndicators[si], pos);
3369  			} while (pos != prevPos);
3370  		}
3371  	}
3372  	if (styledVect.size() &gt; 0)
3373  	{
3374  		if (doAll)
3375  		{
3376  			std::sort(styledVect.begin(), styledVect.end());
3377  		}
3378  		const generic_string delim =
3379  			(textContainsLineEndingChar &amp;&amp; styledVect.size() &gt; 1) ?
3380  			TEXT(&quot;\r\n----\r\n&quot;) : TEXT(&quot;\r\n&quot;);
3381  		generic_string joined;
3382  		for (auto&amp; item : styledVect)
3383  		{
3384  			joined += delim + item.second;
3385  		}
3386  		joined = joined.substr(delim.length());
3387  		if (styledVect.size() &gt; 1)
3388  		{
3389  			joined += TEXT(&quot;\r\n&quot;);
3390  		}
3391  		str2Clipboard(joined, NULL);
3392  	}
3393  }
3394  void ScintillaEditView::removeAnyDuplicateLines()
3395  {
3396  	size_t fromLine = 0, toLine = 0;
3397  	bool hasLineSelection = false;
3398  	auto selStart = execute(SCI_GETSELECTIONSTART);
3399  	auto selEnd = execute(SCI_GETSELECTIONEND);
3400  	hasLineSelection = selStart != selEnd;
3401  	if (hasLineSelection)
3402  	{
3403  		const pair&lt;size_t, size_t&gt; lineRange = getSelectionLinesRange();
3404  		if (lineRange.first == lineRange.second)
3405  		{
3406  			return;
3407  		}
3408  		fromLine = lineRange.first;
3409  		toLine = lineRange.second;
3410  	}
3411  	else
3412  	{
3413  		fromLine = 0;
3414  		toLine = execute(SCI_GETLINECOUNT) - 1;
3415  	}
3416  	if (fromLine &gt;= toLine)
3417  	{
3418  		return;
3419  	}
3420  	const auto startPos = execute(SCI_POSITIONFROMLINE, fromLine);
3421  	const auto endPos = execute(SCI_POSITIONFROMLINE, toLine) + execute(SCI_LINELENGTH, toLine);
3422  	const generic_string text = getGenericTextAsString(startPos, endPos);
3423  	std::vector&lt;generic_string&gt; linesVect = stringSplit(text, getEOLString());
3424  	const size_t lineCount = execute(SCI_GETLINECOUNT);
3425  	const bool doingEntireDocument = toLine == lineCount - 1;
3426  	if (!doingEntireDocument)
3427  	{
3428  		if (linesVect.rbegin()-&gt;empty())
3429  		{
3430  			linesVect.pop_back();
3431  		}
3432  	}
3433  	size_t origSize = linesVect.size();
3434  	size_t newSize = vecRemoveDuplicates(linesVect);
3435  	if (origSize != newSize)
3436  	{
3437  		generic_string joined = stringJoin(linesVect, getEOLString());
3438  		if (!doingEntireDocument)
3439  		{
3440  			joined += getEOLString();
3441  		}
3442  		if (text != joined)
3443  		{
3444  			replaceTarget(joined.c_str(), startPos, endPos);
3445  		}
3446  	}
3447  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexTADS3.cxx</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-ScintillaEditView.cpp</div>
                </div>
                <div class="column column_space"><pre><code>307          int endState = sc.state;
308          switch (sc.state) {
309                  case SCE_T3_DEFAULT:
310                  case SCE_T3_X_DEFAULT:
</pre></code></div>
                <div class="column column_space"><pre><code>830  				int cppID = style._styleID;
831  				switch (style._styleID)
832  				{
833  					case SCE_HJ_DEFAULT: cppID = SCE_C_DEFAULT; break;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    