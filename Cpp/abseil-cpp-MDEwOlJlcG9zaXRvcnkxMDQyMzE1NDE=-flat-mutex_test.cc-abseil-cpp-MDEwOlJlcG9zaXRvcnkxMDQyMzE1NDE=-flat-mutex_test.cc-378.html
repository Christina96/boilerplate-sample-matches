
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 50, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-mutex_test.cc</h3>
            <pre><code>1  #include &quot;absl/synchronization/mutex.h&quot;
2  #ifdef _WIN32
3  #include &lt;windows.h&gt;
4  #endif
5  #include &lt;algorithm&gt;
6  #include &lt;atomic&gt;
7  #include &lt;cstdlib&gt;
8  #include &lt;functional&gt;
9  #include &lt;memory&gt;
10  #include &lt;random&gt;
11  #include &lt;string&gt;
12  #include &lt;thread&gt;  
13  #include &lt;type_traits&gt;
14  #include &lt;vector&gt;
15  #include &quot;gtest/gtest.h&quot;
16  #include &quot;absl/base/attributes.h&quot;
17  #include &quot;absl/base/config.h&quot;
18  #include &quot;absl/base/internal/sysinfo.h&quot;
19  #include &quot;absl/log/check.h&quot;
20  #include &quot;absl/log/log.h&quot;
21  #include &quot;absl/memory/memory.h&quot;
22  #include &quot;absl/synchronization/internal/thread_pool.h&quot;
23  #include &quot;absl/time/clock.h&quot;
24  #include &quot;absl/time/time.h&quot;
25  namespace {
26  static constexpr bool kExtendedTest = false;
27  std::unique_ptr&lt;absl::synchronization_internal::ThreadPool&gt; CreatePool(
28      int threads) {
29    return absl::make_unique&lt;absl::synchronization_internal::ThreadPool&gt;(threads);
30  }
31  std::unique_ptr&lt;absl::synchronization_internal::ThreadPool&gt;
32  CreateDefaultPool() {
33    return CreatePool(kExtendedTest ? 32 : 10);
34  }
35  static void ScheduleAfter(absl::synchronization_internal::ThreadPool *tp,
36                            absl::Duration after,
37                            const std::function&lt;void()&gt; &amp;func) {
38    tp-&gt;Schedule([func, after] {
39      absl::SleepFor(after);
40      func();
41    });
42  }
43  struct TestContext {
44    int iterations;
45    int threads;
46    int g0;  
47    int g1;  
48    absl::Mutex mu;
49    absl::CondVar cv;
50  };
51  static std::atomic&lt;bool&gt; invariant_checked;
52  static bool GetInvariantChecked() {
53    return invariant_checked.load(std::memory_order_relaxed);
54  }
55  static void SetInvariantChecked(bool new_value) {
56    invariant_checked.store(new_value, std::memory_order_relaxed);
57  }
58  static void CheckSumG0G1(void *v) {
59    TestContext *cxt = static_cast&lt;TestContext *&gt;(v);
60    CHECK_EQ(cxt-&gt;g0, -cxt-&gt;g1) &lt;&lt; &quot;Error in CheckSumG0G1&quot;;
61    SetInvariantChecked(true);
62  }
63  static void TestMu(TestContext *cxt, int c) {
64    for (int i = 0; i != cxt-&gt;iterations; i++) {
65      absl::MutexLock l(&amp;cxt-&gt;mu);
66      int a = cxt-&gt;g0 + 1;
67      cxt-&gt;g0 = a;
68      cxt-&gt;g1--;
69    }
70  }
71  static void TestTry(TestContext *cxt, int c) {
72    for (int i = 0; i != cxt-&gt;iterations; i++) {
73      do {
74        std::this_thread::yield();
75      } while (!cxt-&gt;mu.TryLock());
76      int a = cxt-&gt;g0 + 1;
77      cxt-&gt;g0 = a;
78      cxt-&gt;g1--;
79      cxt-&gt;mu.Unlock();
80    }
81  }
82  static void TestR20ms(TestContext *cxt, int c) {
83    for (int i = 0; i != cxt-&gt;iterations; i++) {
84      absl::ReaderMutexLock l(&amp;cxt-&gt;mu);
85      absl::SleepFor(absl::Milliseconds(20));
86      cxt-&gt;mu.AssertReaderHeld();
87    }
88  }
89  static void TestRW(TestContext *cxt, int c) {
90    if ((c &amp; 1) == 0) {
91      for (int i = 0; i != cxt-&gt;iterations; i++) {
92        absl::WriterMutexLock l(&amp;cxt-&gt;mu);
93        cxt-&gt;g0++;
94        cxt-&gt;g1--;
95        cxt-&gt;mu.AssertHeld();
96        cxt-&gt;mu.AssertReaderHeld();
97      }
98    } else {
99      for (int i = 0; i != cxt-&gt;iterations; i++) {
100        absl::ReaderMutexLock l(&amp;cxt-&gt;mu);
101        CHECK_EQ(cxt-&gt;g0, -cxt-&gt;g1) &lt;&lt; &quot;Error in TestRW&quot;;
102        cxt-&gt;mu.AssertReaderHeld();
103      }
104    }
105  }
106  struct MyContext {
107    int target;
108    TestContext *cxt;
109    bool MyTurn();
110  };
111  bool MyContext::MyTurn() {
112    TestContext *cxt = this-&gt;cxt;
113    return cxt-&gt;g0 == this-&gt;target || cxt-&gt;g0 == cxt-&gt;iterations;
114  }
115  static void TestAwait(TestContext *cxt, int c) {
116    MyContext mc;
117    mc.target = c;
118    mc.cxt = cxt;
119    absl::MutexLock l(&amp;cxt-&gt;mu);
120    cxt-&gt;mu.AssertHeld();
121    while (cxt-&gt;g0 &lt; cxt-&gt;iterations) {
122      cxt-&gt;mu.Await(absl::Condition(&amp;mc, &amp;MyContext::MyTurn));
123      CHECK(mc.MyTurn()) &lt;&lt; &quot;Error in TestAwait&quot;;
124      cxt-&gt;mu.AssertHeld();
125      if (cxt-&gt;g0 &lt; cxt-&gt;iterations) {
126        int a = cxt-&gt;g0 + 1;
127        cxt-&gt;g0 = a;
128        mc.target += cxt-&gt;threads;
129      }
130    }
131  }
132  static void TestSignalAll(TestContext *cxt, int c) {
133    int target = c;
134    absl::MutexLock l(&amp;cxt-&gt;mu);
135    cxt-&gt;mu.AssertHeld();
136    while (cxt-&gt;g0 &lt; cxt-&gt;iterations) {
137      while (cxt-&gt;g0 != target &amp;&amp; cxt-&gt;g0 != cxt-&gt;iterations) {
138        cxt-&gt;cv.Wait(&amp;cxt-&gt;mu);
139      }
140      if (cxt-&gt;g0 &lt; cxt-&gt;iterations) {
141        int a = cxt-&gt;g0 + 1;
142        cxt-&gt;g0 = a;
143        cxt-&gt;cv.SignalAll();
144        target += cxt-&gt;threads;
145      }
146    }
147  }
148  static void TestSignal(TestContext *cxt, int c) {
149    CHECK_EQ(cxt-&gt;threads, 2) &lt;&lt; &quot;TestSignal should use 2 threads&quot;;
150    int target = c;
151    absl::MutexLock l(&amp;cxt-&gt;mu);
152    cxt-&gt;mu.AssertHeld();
153    while (cxt-&gt;g0 &lt; cxt-&gt;iterations) {
154      while (cxt-&gt;g0 != target &amp;&amp; cxt-&gt;g0 != cxt-&gt;iterations) {
155        cxt-&gt;cv.Wait(&amp;cxt-&gt;mu);
156      }
157      if (cxt-&gt;g0 &lt; cxt-&gt;iterations) {
158        int a = cxt-&gt;g0 + 1;
159        cxt-&gt;g0 = a;
160        cxt-&gt;cv.Signal();
161        target += cxt-&gt;threads;
162      }
163    }
164  }
165  static void TestCVTimeout(TestContext *cxt, int c) {
166    int target = c;
167    absl::MutexLock l(&amp;cxt-&gt;mu);
168    cxt-&gt;mu.AssertHeld();
169    while (cxt-&gt;g0 &lt; cxt-&gt;iterations) {
170      while (cxt-&gt;g0 != target &amp;&amp; cxt-&gt;g0 != cxt-&gt;iterations) {
171        cxt-&gt;cv.WaitWithTimeout(&amp;cxt-&gt;mu, absl::Seconds(100));
172      }
173      if (cxt-&gt;g0 &lt; cxt-&gt;iterations) {
174        int a = cxt-&gt;g0 + 1;
175        cxt-&gt;g0 = a;
176        cxt-&gt;cv.SignalAll();
177        target += cxt-&gt;threads;
178      }
179    }
180  }
181  static bool G0GE2(TestContext *cxt) { return cxt-&gt;g0 &gt;= 2; }
182  static void TestTime(TestContext *cxt, int c, bool use_cv) {
183    CHECK_EQ(cxt-&gt;iterations, 1) &lt;&lt; &quot;TestTime should only use 1 iteration&quot;;
184    CHECK_GT(cxt-&gt;threads, 2) &lt;&lt; &quot;TestTime should use more than 2 threads&quot;;
185    const bool kFalse = false;
186    absl::Condition false_cond(&amp;kFalse);
187    absl::Condition g0ge2(G0GE2, cxt);
188    if (c == 0) {
189      absl::MutexLock l(&amp;cxt-&gt;mu);
190      absl::Time start = absl::Now();
191      if (use_cv) {
192        cxt-&gt;cv.WaitWithTimeout(&amp;cxt-&gt;mu, absl::Seconds(1));
193      } else {
194        CHECK(!cxt-&gt;mu.AwaitWithTimeout(false_cond, absl::Seconds(1)))
195            &lt;&lt; &quot;TestTime failed&quot;;
196      }
197      absl::Duration elapsed = absl::Now() - start;
198      CHECK(absl::Seconds(0.9) &lt;= elapsed &amp;&amp; elapsed &lt;= absl::Seconds(2.0))
199          &lt;&lt; &quot;TestTime failed&quot;;
200      CHECK_EQ(cxt-&gt;g0, 1) &lt;&lt; &quot;TestTime failed&quot;;
201      start = absl::Now();
202      if (use_cv) {
203        cxt-&gt;cv.WaitWithTimeout(&amp;cxt-&gt;mu, absl::Seconds(1));
204      } else {
205        CHECK(!cxt-&gt;mu.AwaitWithTimeout(false_cond, absl::Seconds(1)))
206            &lt;&lt; &quot;TestTime failed&quot;;
207      }
208      elapsed = absl::Now() - start;
209      CHECK(absl::Seconds(0.9) &lt;= elapsed &amp;&amp; elapsed &lt;= absl::Seconds(2.0))
210          &lt;&lt; &quot;TestTime failed&quot;;
211      cxt-&gt;g0++;
212      if (use_cv) {
213        cxt-&gt;cv.Signal();
214      }
215      start = absl::Now();
216      if (use_cv) {
217        cxt-&gt;cv.WaitWithTimeout(&amp;cxt-&gt;mu, absl::Seconds(4));
218      } else {
219        CHECK(!cxt-&gt;mu.AwaitWithTimeout(false_cond, absl::Seconds(4)))
220            &lt;&lt; &quot;TestTime failed&quot;;
221      }
222      elapsed = absl::Now() - start;
223      CHECK(absl::Seconds(3.9) &lt;= elapsed &amp;&amp; elapsed &lt;= absl::Seconds(6.0))
224          &lt;&lt; &quot;TestTime failed&quot;;
225      CHECK_GE(cxt-&gt;g0, 3) &lt;&lt; &quot;TestTime failed&quot;;
226      start = absl::Now();
227      if (use_cv) {
228        cxt-&gt;cv.WaitWithTimeout(&amp;cxt-&gt;mu, absl::Seconds(1));
229      } else {
230        CHECK(!cxt-&gt;mu.AwaitWithTimeout(false_cond, absl::Seconds(1)))
231            &lt;&lt; &quot;TestTime failed&quot;;
232      }
233      elapsed = absl::Now() - start;
234      CHECK(absl::Seconds(0.9) &lt;= elapsed &amp;&amp; elapsed &lt;= absl::Seconds(2.0))
235          &lt;&lt; &quot;TestTime failed&quot;;
236      if (use_cv) {
237        cxt-&gt;cv.SignalAll();
238      }
239      start = absl::Now();
240      if (use_cv) {
241        cxt-&gt;cv.WaitWithTimeout(&amp;cxt-&gt;mu, absl::Seconds(1));
242      } else {
243        CHECK(!cxt-&gt;mu.AwaitWithTimeout(false_cond, absl::Seconds(1)))
244            &lt;&lt; &quot;TestTime failed&quot;;
245      }
246      elapsed = absl::Now() - start;
247      CHECK(absl::Seconds(0.9) &lt;= elapsed &amp;&amp; elapsed &lt;= absl::Seconds(2.0))
248          &lt;&lt; &quot;TestTime failed&quot;;
249      CHECK_EQ(cxt-&gt;g0, cxt-&gt;threads) &lt;&lt; &quot;TestTime failed&quot;;
250    } else if (c == 1) {
251      absl::MutexLock l(&amp;cxt-&gt;mu);
252      const absl::Time start = absl::Now();
253      if (use_cv) {
254        cxt-&gt;cv.WaitWithTimeout(&amp;cxt-&gt;mu, absl::Milliseconds(500));
255      } else {
256        CHECK(!cxt-&gt;mu.AwaitWithTimeout(false_cond, absl::Milliseconds(500)))
257            &lt;&lt; &quot;TestTime failed&quot;;
258      }
259      const absl::Duration elapsed = absl::Now() - start;
260      CHECK(absl::Seconds(0.4) &lt;= elapsed &amp;&amp; elapsed &lt;= absl::Seconds(0.9))
261          &lt;&lt; &quot;TestTime failed&quot;;
262      cxt-&gt;g0++;
263    } else if (c == 2) {
264      absl::MutexLock l(&amp;cxt-&gt;mu);
265      if (use_cv) {
266        while (cxt-&gt;g0 &lt; 2) {
267          cxt-&gt;cv.WaitWithTimeout(&amp;cxt-&gt;mu, absl::Seconds(100));
268        }
269      } else {
270        CHECK(cxt-&gt;mu.AwaitWithTimeout(g0ge2, absl::Seconds(100)))
271            &lt;&lt; &quot;TestTime failed&quot;;
272      }
273      cxt-&gt;g0++;
274    } else {
275      absl::MutexLock l(&amp;cxt-&gt;mu);
276      if (use_cv) {
277        while (cxt-&gt;g0 &lt; 2) {
278          cxt-&gt;cv.Wait(&amp;cxt-&gt;mu);
279        }
280      } else {
281        cxt-&gt;mu.Await(g0ge2);
282      }
283      cxt-&gt;g0++;
284    }
285  }
286  static void TestMuTime(TestContext *cxt, int c) { TestTime(cxt, c, false); }
287  static void TestCVTime(TestContext *cxt, int c) { TestTime(cxt, c, true); }
288  static void EndTest(int *c0, int *c1, absl::Mutex *mu, absl::CondVar *cv,
289                      const std::function&lt;void(int)&gt; &amp;cb) {
290    mu-&gt;Lock();
291    int c = (*c0)++;
292    mu-&gt;Unlock();
293    cb(c);
294    absl::MutexLock l(mu);
295    (*c1)++;
296    cv-&gt;Signal();
297  }
298  static int RunTestCommon(TestContext *cxt, void (*test)(TestContext *cxt, int),
299                           int threads, int iterations, int operations) {
300    absl::Mutex mu2;
301    absl::CondVar cv2;
302    int c0 = 0;
303    int c1 = 0;
304    cxt-&gt;g0 = 0;
305    cxt-&gt;g1 = 0;
306    cxt-&gt;iterations = iterations;
307    cxt-&gt;threads = threads;
308    absl::synchronization_internal::ThreadPool tp(threads);
309    for (int i = 0; i != threads; i++) {
310      tp.Schedule(std::bind(
311          &amp;EndTest, &amp;c0, &amp;c1, &amp;mu2, &amp;cv2,
312          std::function&lt;void(int)&gt;(std::bind(test, cxt, std::placeholders::_1))));
313    }
314    mu2.Lock();
315    while (c1 != threads) {
316      cv2.Wait(&amp;mu2);
317    }
318    mu2.Unlock();
319    return cxt-&gt;g0;
320  }
321  static int RunTest(void (*test)(TestContext *cxt, int), int threads,
322                     int iterations, int operations) {
323    TestContext cxt;
324    return RunTestCommon(&amp;cxt, test, threads, iterations, operations);
325  }
326  #if !defined(ABSL_MUTEX_ENABLE_INVARIANT_DEBUGGING_NOT_IMPLEMENTED)
327  static int RunTestWithInvariantDebugging(void (*test)(TestContext *cxt, int),
328                                           int threads, int iterations,
329                                           int operations,
330                                           void (*invariant)(void *)) {
331    absl::EnableMutexInvariantDebugging(true);
332    SetInvariantChecked(false);
333    TestContext cxt;
334    cxt.mu.EnableInvariantDebugging(invariant, &amp;cxt);
335    int ret = RunTestCommon(&amp;cxt, test, threads, iterations, operations);
336    CHECK(GetInvariantChecked()) &lt;&lt; &quot;Invariant not checked&quot;;
337    absl::EnableMutexInvariantDebugging(false);  
338    return ret;
339  }
340  #endif
341  struct TimeoutBugStruct {
342    absl::Mutex mu;
343    bool a;
344    int a_waiter_count;
345  };
346  static void WaitForA(TimeoutBugStruct *x) {
347    x-&gt;mu.LockWhen(absl::Condition(&amp;x-&gt;a));
348    x-&gt;a_waiter_count--;
349    x-&gt;mu.Unlock();
350  }
351  static bool NoAWaiters(TimeoutBugStruct *x) { return x-&gt;a_waiter_count == 0; }
352  TEST(Mutex, CondVarWaitSignalsAwait) {
353    struct {
354      absl::Mutex barrier_mu;
355      bool barrier ABSL_GUARDED_BY(barrier_mu) = false;
356      absl::Mutex release_mu;
357      bool release ABSL_GUARDED_BY(release_mu) = false;
358      absl::CondVar released_cv;
359    } state;
360    auto pool = CreateDefaultPool();
361    pool-&gt;Schedule([&amp;state] {
362      state.release_mu.Lock();
363      state.barrier_mu.Lock();
364      state.barrier = true;
365      state.barrier_mu.Unlock();
366      state.release_mu.Await(absl::Condition(&amp;state.release));
367      state.released_cv.Signal();
<span onclick='openModal()' class='match'>368      state.release_mu.Unlock();
369    });
370    state.barrier_mu.LockWhen(absl::Condition(&amp;state.barrier));
371    state.barrier_mu.Unlock();
372    state.release_mu.Lock();
373    state.release = true;
374    state.released_cv.Wait(&amp;state.release_mu);
</span>375    state.release_mu.Unlock();
376  }
377  TEST(Mutex, CondVarWaitWithTimeoutSignalsAwait) {
378    struct {
379      absl::Mutex barrier_mu;
380      bool barrier ABSL_GUARDED_BY(barrier_mu) = false;
381      absl::Mutex release_mu;
382      bool release ABSL_GUARDED_BY(release_mu) = false;
383      absl::CondVar released_cv;
384    } state;
385    auto pool = CreateDefaultPool();
386    pool-&gt;Schedule([&amp;state] {
387      state.release_mu.Lock();
388      state.barrier_mu.Lock();
389      state.barrier = true;
390      state.barrier_mu.Unlock();
391      state.release_mu.Await(absl::Condition(&amp;state.release));
392      state.released_cv.Signal();
393      state.release_mu.Unlock();
394    });
395    state.barrier_mu.LockWhen(absl::Condition(&amp;state.barrier));
396    state.barrier_mu.Unlock();
397    state.release_mu.Lock();
398    state.release = true;
399    EXPECT_TRUE(
400        !state.released_cv.WaitWithTimeout(&amp;state.release_mu, absl::Seconds(10)))
401        &lt;&lt; &quot;; Unrecoverable test failure: CondVar::WaitWithTimeout did not &quot;
402           &quot;unblock the absl::Mutex::Await call in another thread.&quot;;
403    state.release_mu.Unlock();
404  }
405  TEST(Mutex, MutexTimeoutBug) {
406    auto tp = CreateDefaultPool();
407    TimeoutBugStruct x;
408    x.a = false;
409    x.a_waiter_count = 2;
410    tp-&gt;Schedule(std::bind(&amp;WaitForA, &amp;x));
411    tp-&gt;Schedule(std::bind(&amp;WaitForA, &amp;x));
412    absl::SleepFor(absl::Seconds(1));  
413    bool always_false = false;
414    x.mu.LockWhenWithTimeout(absl::Condition(&amp;always_false),
415                             absl::Milliseconds(500));
416    x.a = true;                                    
417    x.mu.Await(absl::Condition(&amp;NoAWaiters, &amp;x));  
418    x.mu.Unlock();
419  }
420  struct CondVarWaitDeadlock : testing::TestWithParam&lt;int&gt; {
421    absl::Mutex mu;
422    absl::CondVar cv;
423    bool cond1 = false;
424    bool cond2 = false;
425    bool read_lock1;
426    bool read_lock2;
427    bool signal_unlocked;
428    CondVarWaitDeadlock() {
429      read_lock1 = GetParam() &amp; (1 &lt;&lt; 0);
430      read_lock2 = GetParam() &amp; (1 &lt;&lt; 1);
431      signal_unlocked = GetParam() &amp; (1 &lt;&lt; 2);
432    }
433    void Waiter1() {
434      if (read_lock1) {
435        mu.ReaderLock();
436        while (!cond1) {
437          cv.Wait(&amp;mu);
438        }
439        mu.ReaderUnlock();
440      } else {
441        mu.Lock();
442        while (!cond1) {
443          cv.Wait(&amp;mu);
444        }
445        mu.Unlock();
446      }
447    }
448    void Waiter2() {
449      if (read_lock2) {
450        mu.ReaderLockWhen(absl::Condition(&amp;cond2));
451        mu.ReaderUnlock();
452      } else {
453        mu.LockWhen(absl::Condition(&amp;cond2));
454        mu.Unlock();
455      }
456    }
457  };
458  TEST_P(CondVarWaitDeadlock, Test) {
459    auto waiter1 = CreatePool(1);
460    auto waiter2 = CreatePool(1);
461    waiter1-&gt;Schedule([this] { this-&gt;Waiter1(); });
462    waiter2-&gt;Schedule([this] { this-&gt;Waiter2(); });
463    absl::SleepFor(absl::Milliseconds(100));
464    mu.Lock();
465    cond1 = true;
466    if (signal_unlocked) {
467      mu.Unlock();
468      cv.Signal();
469    } else {
470      cv.Signal();
471      mu.Unlock();
472    }
473    waiter1.reset();  
474    mu.Lock();
475    cond2 = true;
476    mu.Unlock();
477    waiter2.reset();  
478  }
479  INSTANTIATE_TEST_SUITE_P(CondVarWaitDeadlockTest, CondVarWaitDeadlock,
480                           ::testing::Range(0, 8),
481                           ::testing::PrintToStringParamName());
482  struct DequeueAllWakeableBugStruct {
483    absl::Mutex mu;
484    absl::Mutex mu2;       
485    int unfinished_count;  
486    bool done1;            
487    int finished_count;    
488    bool done2;            
489  };
490  static void AcquireAsReader(DequeueAllWakeableBugStruct *x) {
491    x-&gt;mu.ReaderLock();
492    x-&gt;mu2.Lock();
493    x-&gt;unfinished_count--;
494    x-&gt;done1 = (x-&gt;unfinished_count == 0);
495    x-&gt;mu2.Unlock();
496    absl::SleepFor(absl::Seconds(2));
497    x-&gt;mu.ReaderUnlock();
498    x-&gt;mu2.Lock();
499    x-&gt;finished_count--;
500    x-&gt;done2 = (x-&gt;finished_count == 0);
501    x-&gt;mu2.Unlock();
502  }
503  TEST(Mutex, MutexReaderWakeupBug) {
504    auto tp = CreateDefaultPool();
505    DequeueAllWakeableBugStruct x;
506    x.unfinished_count = 2;
507    x.done1 = false;
508    x.finished_count = 2;
509    x.done2 = false;
510    x.mu.Lock();  
511    tp-&gt;Schedule(std::bind(&amp;AcquireAsReader, &amp;x));
512    tp-&gt;Schedule(std::bind(&amp;AcquireAsReader, &amp;x));
513    absl::SleepFor(absl::Seconds(1));  
514    x.mu.Unlock();                     
515    EXPECT_TRUE(
516        x.mu2.LockWhenWithTimeout(absl::Condition(&amp;x.done1), absl::Seconds(10)));
517    x.mu2.Unlock();
518    EXPECT_TRUE(
519        x.mu2.LockWhenWithTimeout(absl::Condition(&amp;x.done2), absl::Seconds(10)));
520    x.mu2.Unlock();
521  }
522  struct LockWhenTestStruct {
523    absl::Mutex mu1;
524    bool cond = false;
525    absl::Mutex mu2;
526    bool waiting = false;
527  };
528  static bool LockWhenTestIsCond(LockWhenTestStruct *s) {
529    s-&gt;mu2.Lock();
530    s-&gt;waiting = true;
531    s-&gt;mu2.Unlock();
532    return s-&gt;cond;
533  }
534  static void LockWhenTestWaitForIsCond(LockWhenTestStruct *s) {
535    s-&gt;mu1.LockWhen(absl::Condition(&amp;LockWhenTestIsCond, s));
536    s-&gt;mu1.Unlock();
537  }
538  TEST(Mutex, LockWhen) {
539    LockWhenTestStruct s;
540    std::thread t(LockWhenTestWaitForIsCond, &amp;s);
541    s.mu2.LockWhen(absl::Condition(&amp;s.waiting));
542    s.mu2.Unlock();
543    s.mu1.Lock();
544    s.cond = true;
545    s.mu1.Unlock();
546    t.join();
547  }
548  TEST(Mutex, LockWhenGuard) {
549    absl::Mutex mu;
550    int n = 30;
551    bool done = false;
552    bool (*cond_eq_10)(int *) = [](int *p) { return *p == 10; };
553    bool (*cond_lt_10)(int *) = [](int *p) { return *p &lt; 10; };
554    std::thread t1([&amp;mu, &amp;n, &amp;done, cond_eq_10]() {
555      absl::ReaderMutexLock lock(&amp;mu, absl::Condition(cond_eq_10, &amp;n));
556      done = true;
557    });
558    std::thread t2[10];
559    for (std::thread &amp;t : t2) {
560      t = std::thread([&amp;mu, &amp;n, cond_lt_10]() {
561        absl::WriterMutexLock lock(&amp;mu, absl::Condition(cond_lt_10, &amp;n));
562        ++n;
563      });
564    }
565    {
566      absl::MutexLock lock(&amp;mu);
567      n = 0;
568    }
569    for (std::thread &amp;t : t2) t.join();
570    t1.join();
571    EXPECT_TRUE(done);
572    EXPECT_EQ(n, 10);
573  }
574  #if !defined(ABSL_MUTEX_READER_LOCK_IS_EXCLUSIVE)
575  struct ReaderDecrementBugStruct {
576    bool cond;  
577    int done;   
578    absl::Mutex mu;
579    bool waiting_on_cond;   
580    bool have_reader_lock;  
581    bool complete;          
582    absl::Mutex mu2;        
583  };
584  static bool IsCond(void *v) {
585    ReaderDecrementBugStruct *x = reinterpret_cast&lt;ReaderDecrementBugStruct *&gt;(v);
586    x-&gt;mu2.Lock();
587    x-&gt;waiting_on_cond = true;
588    x-&gt;mu2.Unlock();
589    return x-&gt;cond;
590  }
591  static bool AllDone(void *v) {
592    ReaderDecrementBugStruct *x = reinterpret_cast&lt;ReaderDecrementBugStruct *&gt;(v);
593    return x-&gt;done == 0;
594  }
595  static void WaitForCond(ReaderDecrementBugStruct *x) {
596    absl::Mutex dummy;
597    absl::MutexLock l(&amp;dummy);
598    x-&gt;mu.LockWhen(absl::Condition(&amp;IsCond, x));
599    x-&gt;done--;
600    x-&gt;mu.Unlock();
601  }
602  static void GetReadLock(ReaderDecrementBugStruct *x) {
603    x-&gt;mu.ReaderLock();
604    x-&gt;mu2.Lock();
605    x-&gt;have_reader_lock = true;
606    x-&gt;mu2.Await(absl::Condition(&amp;x-&gt;complete));
607    x-&gt;mu2.Unlock();
608    x-&gt;mu.ReaderUnlock();
609    x-&gt;mu.Lock();
610    x-&gt;done--;
611    x-&gt;mu.Unlock();
612  }
613  TEST(Mutex, MutexReaderDecrementBug) ABSL_NO_THREAD_SAFETY_ANALYSIS {
614    ReaderDecrementBugStruct x;
615    x.cond = false;
616    x.waiting_on_cond = false;
617    x.have_reader_lock = false;
618    x.complete = false;
619    x.done = 2;  
620    std::thread thread1(WaitForCond, &amp;x);
621    x.mu2.LockWhen(absl::Condition(&amp;x.waiting_on_cond));
622    x.mu2.Unlock();
623    std::thread thread2(GetReadLock, &amp;x);
624    x.mu2.LockWhen(absl::Condition(&amp;x.have_reader_lock));
625    x.mu2.Unlock();
626    x.mu.ReaderLock();
627    x.mu.ReaderUnlock();
628    x.mu.AssertReaderHeld();
629    x.mu2.Lock();
630    x.complete = true;
631    x.mu2.Unlock();
632    x.mu.Lock();
633    x.cond = true;
634    x.mu.Await(absl::Condition(&amp;AllDone, &amp;x));
635    x.mu.Unlock();
636    thread1.join();
637    thread2.join();
638  }
639  #endif  
640  #ifdef ABSL_HAVE_THREAD_SANITIZER
641  TEST(Mutex, DISABLED_LockedMutexDestructionBug) ABSL_NO_THREAD_SAFETY_ANALYSIS {
642  #else
643  TEST(Mutex, LockedMutexDestructionBug) ABSL_NO_THREAD_SAFETY_ANALYSIS {
644  #endif
645    for (int i = 0; i != 10; i++) {
646      const int kNumLocks = 10;
647      auto mu = absl::make_unique&lt;absl::Mutex[]&gt;(kNumLocks);
648      for (int j = 0; j != kNumLocks; j++) {
649        if ((j % 2) == 0) {
650          mu[j].WriterLock();
651        } else {
652          mu[j].ReaderLock();
653        }
654      }
655    }
656  }
657  bool Equals42(int *p) { return *p == 42; }
658  bool Equals43(int *p) { return *p == 43; }
659  bool ConstEquals42(const int *p) { return *p == 42; }
660  bool ConstEquals43(const int *p) { return *p == 43; }
661  template &lt;typename T&gt;
662  bool TemplateEquals42(T *p) {
663    return *p == 42;
664  }
665  template &lt;typename T&gt;
666  bool TemplateEquals43(T *p) {
667    return *p == 43;
668  }
669  TEST(Mutex, FunctionPointerCondition) {
670    int x = 42;
671    const int const_x = 42;
672    EXPECT_TRUE(absl::Condition(Equals42, &amp;x).Eval());
673    EXPECT_FALSE(absl::Condition(Equals43, &amp;x).Eval());
674    EXPECT_TRUE(absl::Condition(ConstEquals42, &amp;x).Eval());
675    EXPECT_FALSE(absl::Condition(ConstEquals43, &amp;x).Eval());
676    EXPECT_TRUE(absl::Condition(ConstEquals42, &amp;const_x).Eval());
677    EXPECT_FALSE(absl::Condition(ConstEquals43, &amp;const_x).Eval());
678    EXPECT_TRUE(absl::Condition(TemplateEquals42, &amp;x).Eval());
679    EXPECT_FALSE(absl::Condition(TemplateEquals43, &amp;x).Eval());
680    EXPECT_TRUE(absl::Condition(TemplateEquals42, &amp;const_x).Eval());
681    EXPECT_FALSE(absl::Condition(TemplateEquals43, &amp;const_x).Eval());
682    EXPECT_FALSE((std::is_constructible&lt;absl::Condition, decltype(Equals42),
683                                        decltype(&amp;const_x)&gt;::value));
684    EXPECT_TRUE((std::is_constructible&lt;absl::Condition, decltype(ConstEquals42),
685                                       decltype(&amp;const_x)&gt;::value));
686  }
687  struct Base {
688    explicit Base(int v) : value(v) {}
689    int value;
690  };
691  struct Derived : Base {
692    explicit Derived(int v) : Base(v) {}
693  };
694  bool BaseEquals42(Base *p) { return p-&gt;value == 42; }
695  bool BaseEquals43(Base *p) { return p-&gt;value == 43; }
696  bool ConstBaseEquals42(const Base *p) { return p-&gt;value == 42; }
697  bool ConstBaseEquals43(const Base *p) { return p-&gt;value == 43; }
698  TEST(Mutex, FunctionPointerConditionWithDerivedToBaseConversion) {
699    Derived derived(42);
700    const Derived const_derived(42);
701    EXPECT_TRUE(absl::Condition(BaseEquals42, &amp;derived).Eval());
702    EXPECT_FALSE(absl::Condition(BaseEquals43, &amp;derived).Eval());
703    EXPECT_TRUE(absl::Condition(ConstBaseEquals42, &amp;derived).Eval());
704    EXPECT_FALSE(absl::Condition(ConstBaseEquals43, &amp;derived).Eval());
705    EXPECT_TRUE(absl::Condition(ConstBaseEquals42, &amp;const_derived).Eval());
706    EXPECT_FALSE(absl::Condition(ConstBaseEquals43, &amp;const_derived).Eval());
707    EXPECT_TRUE(absl::Condition(ConstBaseEquals42, &amp;const_derived).Eval());
708    EXPECT_FALSE(absl::Condition(ConstBaseEquals43, &amp;const_derived).Eval());
709    bool (*derived_pred)(const Derived *) = [](const Derived *) { return true; };
710    EXPECT_FALSE((std::is_constructible&lt;absl::Condition, decltype(derived_pred),
711                                        Base *&gt;::value));
712    EXPECT_FALSE((std::is_constructible&lt;absl::Condition, decltype(derived_pred),
713                                        const Base *&gt;::value));
714    EXPECT_TRUE((std::is_constructible&lt;absl::Condition, decltype(derived_pred),
715                                       Derived *&gt;::value));
716    EXPECT_TRUE((std::is_constructible&lt;absl::Condition, decltype(derived_pred),
717                                       const Derived *&gt;::value));
718  }
719  struct True {
720    template &lt;class... Args&gt;
721    bool operator()(Args...) const {
722      return true;
723    }
724  };
725  struct DerivedTrue : True {};
726  TEST(Mutex, FunctorCondition) {
727    {  
728      True f;
729      EXPECT_TRUE(absl::Condition(&amp;f).Eval());
730    }
731    {  
732      DerivedTrue g;
733      EXPECT_TRUE(absl::Condition(&amp;g).Eval());
734    }
735    {  
736      int value = 3;
737      auto is_zero = [&amp;value] { return value == 0; };
738      absl::Condition c(&amp;is_zero);
739      EXPECT_FALSE(c.Eval());
740      value = 0;
741      EXPECT_TRUE(c.Eval());
742    }
743    {  
744      int value = 0;
745      auto is_positive = std::bind(std::less&lt;int&gt;(), 0, std::cref(value));
746      absl::Condition c(&amp;is_positive);
747      EXPECT_FALSE(c.Eval());
748      value = 1;
749      EXPECT_TRUE(c.Eval());
750    }
751    {  
752      int value = 3;
753      std::function&lt;bool()&gt; is_zero = [&amp;value] { return value == 0; };
754      absl::Condition c(&amp;is_zero);
755      EXPECT_FALSE(c.Eval());
756      value = 0;
757      EXPECT_TRUE(c.Eval());
758    }
759  }
760  static void ReaderForReaderOnCondVar(absl::Mutex *mu, absl::CondVar *cv,
761                                       int *running) {
762    std::random_device dev;
763    std::mt19937 gen(dev());
764    std::uniform_int_distribution&lt;int&gt; random_millis(0, 15);
765    mu-&gt;ReaderLock();
766    while (*running == 3) {
767      absl::SleepFor(absl::Milliseconds(random_millis(gen)));
768      cv-&gt;WaitWithTimeout(mu, absl::Milliseconds(random_millis(gen)));
769    }
770    mu-&gt;ReaderUnlock();
771    mu-&gt;Lock();
772    (*running)--;
773    mu-&gt;Unlock();
774  }
775  static bool IntIsZero(int *x) { return *x == 0; }
776  TEST(Mutex, TestReaderOnCondVar) {
777    auto tp = CreateDefaultPool();
778    absl::Mutex mu;
779    absl::CondVar cv;
780    int running = 3;
781    tp-&gt;Schedule(std::bind(&amp;ReaderForReaderOnCondVar, &amp;mu, &amp;cv, &amp;running));
782    tp-&gt;Schedule(std::bind(&amp;ReaderForReaderOnCondVar, &amp;mu, &amp;cv, &amp;running));
783    absl::SleepFor(absl::Seconds(2));
784    mu.Lock();
785    running--;
786    mu.Await(absl::Condition(&amp;IntIsZero, &amp;running));
787    mu.Unlock();
788  }
789  struct AcquireFromConditionStruct {
790    absl::Mutex mu0;   
791    int value;         
792    bool done;         
793    absl::Mutex mu1;   
794    absl::CondVar cv;  
795  };
796  static bool ConditionWithAcquire(AcquireFromConditionStruct *x) {
797    x-&gt;value++;  
798    if (x-&gt;value == 2 || x-&gt;value == 3) {
799      bool always_false = false;
800      x-&gt;mu1.LockWhenWithTimeout(absl::Condition(&amp;always_false),
801                                 absl::Milliseconds(100));
802      x-&gt;mu1.Unlock();
803    }
804    CHECK_LT(x-&gt;value, 4) &lt;&lt; &quot;should not be invoked a fourth time&quot;;
805    return x-&gt;value == 2 || x-&gt;value == 3;
806  }
807  static void WaitForCond2(AcquireFromConditionStruct *x) {
808    x-&gt;mu0.LockWhen(absl::Condition(&amp;ConditionWithAcquire, x));
809    x-&gt;done = true;
810    x-&gt;mu0.Unlock();
811  }
812  TEST(Mutex, AcquireFromCondition) {
813    auto tp = CreateDefaultPool();
814    AcquireFromConditionStruct x;
815    x.value = 0;
816    x.done = false;
817    tp-&gt;Schedule(
818        std::bind(&amp;WaitForCond2, &amp;x));  
819    absl::SleepFor(absl::Milliseconds(500));  
820    x.mu0.Lock();
821    x.cv.WaitWithTimeout(&amp;x.mu0, absl::Milliseconds(500));  
822    x.mu0.Unlock();
823    x.mu0.LockWhen(absl::Condition(&amp;x.done));
824    x.mu0.Unlock();
825  }
826  TEST(Mutex, DeadlockDetector) {
827    absl::SetMutexDeadlockDetectionMode(absl::OnDeadlockCycle::kAbort);
828    absl::Mutex m1;
829    absl::Mutex m2;
830    absl::Mutex m3;
831    absl::Mutex m4;
832    m1.Lock();  
833    m2.Lock();  
834    m3.Lock();  
835    m3.Unlock();
836    m2.Unlock();
837    m1.ForgetDeadlockInfo();  
838    m2.Lock();                
839    m3.Lock();                
840    m4.Lock();                
841    m3.Unlock();
842    m2.Unlock();
843    m4.Unlock();
844    m1.Unlock();
845  }
846  class ScopedDisableBazelTestWarnings {
847   public:
848    ScopedDisableBazelTestWarnings() {
849  #ifdef _WIN32
850      char file[MAX_PATH];
851      if (GetEnvironmentVariableA(kVarName, file, sizeof(file)) &lt; sizeof(file)) {
852        warnings_output_file_ = file;
853        SetEnvironmentVariableA(kVarName, nullptr);
854      }
855  #else
856      const char *file = getenv(kVarName);
857      if (file != nullptr) {
858        warnings_output_file_ = file;
859        unsetenv(kVarName);
860      }
861  #endif
862    }
863    ~ScopedDisableBazelTestWarnings() {
864      if (!warnings_output_file_.empty()) {
865  #ifdef _WIN32
866        SetEnvironmentVariableA(kVarName, warnings_output_file_.c_str());
867  #else
868        setenv(kVarName, warnings_output_file_.c_str(), 0);
869  #endif
870      }
871    }
872   private:
873    static const char kVarName[];
874    std::string warnings_output_file_;
875  };
876  const char ScopedDisableBazelTestWarnings::kVarName[] =
877      &quot;TEST_WARNINGS_OUTPUT_FILE&quot;;
878  #ifdef ABSL_HAVE_THREAD_SANITIZER
879  TEST(Mutex, DISABLED_DeadlockDetectorBazelWarning) {
880  #else
881  TEST(Mutex, DeadlockDetectorBazelWarning) {
882  #endif
883    absl::SetMutexDeadlockDetectionMode(absl::OnDeadlockCycle::kReport);
884    ScopedDisableBazelTestWarnings disable_bazel_test_warnings;
885    absl::Mutex mu0;
886    absl::Mutex mu1;
887    bool got_mu0 = mu0.TryLock();
888    mu1.Lock();  
889    if (got_mu0) {
890      mu0.Unlock();
891    }
892    if (mu0.TryLock()) {  
893      mu0.Unlock();
894    }
895    mu0.Lock();  
896    mu0.Unlock();
897    mu1.Unlock();
898    absl::SetMutexDeadlockDetectionMode(absl::OnDeadlockCycle::kAbort);
899  }
900  TEST(Mutex, DeadlockDetectorLongCycle) {
901    absl::SetMutexDeadlockDetectionMode(absl::OnDeadlockCycle::kReport);
902    ScopedDisableBazelTestWarnings disable_bazel_test_warnings;
903    std::vector&lt;absl::Mutex&gt; mutex(100);
904    for (size_t i = 0; i != mutex.size(); i++) {
905      mutex[i].Lock();
906      mutex[(i + 1) % mutex.size()].Lock();
907      mutex[i].Unlock();
908      mutex[(i + 1) % mutex.size()].Unlock();
909    }
910    absl::SetMutexDeadlockDetectionMode(absl::OnDeadlockCycle::kAbort);
911  }
912  TEST(Mutex, DeadlockDetectorStressTest) ABSL_NO_THREAD_SAFETY_ANALYSIS {
913    const int n_locks = 1 &lt;&lt; 17;
914    auto array_of_locks = absl::make_unique&lt;absl::Mutex[]&gt;(n_locks);
915    for (int i = 0; i &lt; n_locks; i++) {
916      int end = std::min(n_locks, i + 5);
917      for (int j = i; j &lt; end; j++) {
918        array_of_locks[j].Lock();
919      }
920      for (int j = i; j &lt; end; j++) {
921        array_of_locks[j].Unlock();
922      }
923    }
924  }
925  #ifdef ABSL_HAVE_THREAD_SANITIZER
926  TEST(Mutex, DISABLED_DeadlockIdBug) ABSL_NO_THREAD_SAFETY_ANALYSIS {
927  #else
928  TEST(Mutex, DeadlockIdBug) ABSL_NO_THREAD_SAFETY_ANALYSIS {
929  #endif
930    absl::SetMutexDeadlockDetectionMode(absl::OnDeadlockCycle::kAbort);
931    absl::Mutex *a = new absl::Mutex;
932    absl::Mutex b, c;
933    a-&gt;Lock();
934    b.Lock();
935    b.Unlock();
936    absl::SetMutexDeadlockDetectionMode(absl::OnDeadlockCycle::kIgnore);
937    delete a;
938    absl::SetMutexDeadlockDetectionMode(absl::OnDeadlockCycle::kAbort);
939    c.Lock();
940    c.Unlock();
941  }
942  static absl::Duration TimeoutTestAllowedSchedulingDelay() {
943    return absl::Milliseconds(150);
944  }
945  ABSL_MUST_USE_RESULT
946  static bool DelayIsWithinBounds(absl::Duration expected_delay,
947                                  absl::Duration actual_delay) {
948    bool pass = true;
949    if (actual_delay &lt; expected_delay) {
950      LOG(WARNING) &lt;&lt; &quot;Actual delay &quot; &lt;&lt; actual_delay
951                   &lt;&lt; &quot; was too short, expected &quot; &lt;&lt; expected_delay
952                   &lt;&lt; &quot; (difference &quot; &lt;&lt; actual_delay - expected_delay &lt;&lt; &quot;)&quot;;
953      pass = false;
954    }
955    absl::Duration tolerance = expected_delay &lt;= absl::ZeroDuration()
956                                   ? absl::Milliseconds(10)
957                                   : TimeoutTestAllowedSchedulingDelay();
958    if (actual_delay &gt; expected_delay + tolerance) {
959      LOG(WARNING) &lt;&lt; &quot;Actual delay &quot; &lt;&lt; actual_delay
960                   &lt;&lt; &quot; was too long, expected &quot; &lt;&lt; expected_delay
961                   &lt;&lt; &quot; (difference &quot; &lt;&lt; actual_delay - expected_delay &lt;&lt; &quot;)&quot;;
962      pass = false;
963    }
964    return pass;
965  }
966  struct TimeoutTestParam {
967    const char *from_file;
968    int from_line;
969    bool use_absolute_deadline;
970    absl::Duration wait_timeout;
971    absl::Duration satisfy_condition_delay;
972    bool expected_result;
973    absl::Duration expected_delay;
974  };
975  std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const TimeoutTestParam &amp;param) {
976    return os &lt;&lt; &quot;from: &quot; &lt;&lt; param.from_file &lt;&lt; &quot;:&quot; &lt;&lt; param.from_line
977              &lt;&lt; &quot; use_absolute_deadline: &quot;
978              &lt;&lt; (param.use_absolute_deadline ? &quot;true&quot; : &quot;false&quot;)
979              &lt;&lt; &quot; wait_timeout: &quot; &lt;&lt; param.wait_timeout
980              &lt;&lt; &quot; satisfy_condition_delay: &quot; &lt;&lt; param.satisfy_condition_delay
981              &lt;&lt; &quot; expected_result: &quot;
982              &lt;&lt; (param.expected_result ? &quot;true&quot; : &quot;false&quot;)
983              &lt;&lt; &quot; expected_delay: &quot; &lt;&lt; param.expected_delay;
984  }
985  static void RunAfterDelay(absl::Duration delay,
986                            absl::synchronization_internal::ThreadPool *pool,
987                            const std::function&lt;void()&gt; &amp;callback) {
988    if (delay &lt;= absl::ZeroDuration()) {
989      callback();  
990    } else if (delay != absl::InfiniteDuration()) {
991      ScheduleAfter(pool, delay, callback);
992    }
993  }
994  class TimeoutTest : public ::testing::Test,
995                      public ::testing::WithParamInterface&lt;TimeoutTestParam&gt; {};
996  std::vector&lt;TimeoutTestParam&gt; MakeTimeoutTestParamValues() {
997    const absl::Duration finite = 3 * TimeoutTestAllowedSchedulingDelay();
998    const absl::Duration never = absl::InfiniteDuration();
999    const absl::Duration negative = -absl::InfiniteDuration();
1000    const absl::Duration immediate = absl::ZeroDuration();
1001    std::vector&lt;TimeoutTestParam&gt; values;
1002    for (bool use_absolute_deadline : {false, true}) {
1003      values.push_back(TimeoutTestParam{
1004          __FILE__, __LINE__, use_absolute_deadline,
1005          negative,   
1006          immediate,  
1007          true,       
1008          immediate,  
1009      });
1010      values.push_back(TimeoutTestParam{
1011          __FILE__, __LINE__, use_absolute_deadline,
1012          negative,  
1013          finite,    
1014          false,     
1015          immediate  
1016      });
1017      values.push_back(TimeoutTestParam{
1018          __FILE__, __LINE__, use_absolute_deadline,
1019          negative,  
1020          never,     
1021          false,     
1022          immediate  
1023      });
1024      values.push_back(TimeoutTestParam{
1025          __FILE__, __LINE__, use_absolute_deadline,
1026          never,      
1027          immediate,  
1028          true,       
1029          immediate   
1030      });
1031      values.push_back(TimeoutTestParam{
1032          __FILE__, __LINE__, use_absolute_deadline,
1033          never,   
1034          finite,  
1035          true,    
1036          finite,  
1037      });
1038      values.push_back(TimeoutTestParam{
1039          __FILE__, __LINE__, use_absolute_deadline,
1040          never,      
1041          immediate,  
1042          true,       
1043          immediate   
1044      });
1045      values.push_back(TimeoutTestParam{
1046          __FILE__, __LINE__, use_absolute_deadline,
1047          finite * 2,  
1048          finite,      
1049          true,        
1050          finite       
1051      });
1052      values.push_back(TimeoutTestParam{
1053          __FILE__, __LINE__, use_absolute_deadline,
1054          finite,      
1055          finite * 2,  
1056          false,       
1057          finite       
1058      });
1059      values.push_back(TimeoutTestParam{
1060          __FILE__, __LINE__, use_absolute_deadline,
1061          finite,  
1062          never,   
1063          false,   
1064          finite   
1065      });
1066    }
1067    return values;
1068  }
1069  INSTANTIATE_TEST_SUITE_P(All, TimeoutTest,
1070                           testing::ValuesIn(MakeTimeoutTestParamValues()));
1071  TEST_P(TimeoutTest, Await) {
1072    const TimeoutTestParam params = GetParam();
1073    LOG(INFO) &lt;&lt; &quot;Params: &quot; &lt;&lt; params;
1074    for (int attempt = 1;; ++attempt) {
1075      LOG(INFO) &lt;&lt; &quot;Attempt &quot; &lt;&lt; attempt;
1076      absl::Mutex mu;
1077      bool value = false;  
1078      std::unique_ptr&lt;absl::synchronization_internal::ThreadPool&gt; pool =
1079          CreateDefaultPool();
1080      RunAfterDelay(params.satisfy_condition_delay, pool.get(), [&amp;] {
1081        absl::MutexLock l(&amp;mu);
1082        value = true;
1083      });
1084      absl::MutexLock lock(&amp;mu);
1085      absl::Time start_time = absl::Now();
1086      absl::Condition cond(&amp;value);
1087      bool result =
1088          params.use_absolute_deadline
1089              ? mu.AwaitWithDeadline(cond, start_time + params.wait_timeout)
1090              : mu.AwaitWithTimeout(cond, params.wait_timeout);
1091      if (DelayIsWithinBounds(params.expected_delay, absl::Now() - start_time)) {
1092        EXPECT_EQ(params.expected_result, result);
1093        break;
1094      }
1095    }
1096  }
1097  TEST_P(TimeoutTest, LockWhen) {
1098    const TimeoutTestParam params = GetParam();
1099    LOG(INFO) &lt;&lt; &quot;Params: &quot; &lt;&lt; params;
1100    for (int attempt = 1;; ++attempt) {
1101      LOG(INFO) &lt;&lt; &quot;Attempt &quot; &lt;&lt; attempt;
1102      absl::Mutex mu;
1103      bool value = false;  
1104      std::unique_ptr&lt;absl::synchronization_internal::ThreadPool&gt; pool =
1105          CreateDefaultPool();
1106      RunAfterDelay(params.satisfy_condition_delay, pool.get(), [&amp;] {
1107        absl::MutexLock l(&amp;mu);
1108        value = true;
1109      });
1110      absl::Time start_time = absl::Now();
1111      absl::Condition cond(&amp;value);
1112      bool result =
1113          params.use_absolute_deadline
1114              ? mu.LockWhenWithDeadline(cond, start_time + params.wait_timeout)
1115              : mu.LockWhenWithTimeout(cond, params.wait_timeout);
1116      mu.Unlock();
1117      if (DelayIsWithinBounds(params.expected_delay, absl::Now() - start_time)) {
1118        EXPECT_EQ(params.expected_result, result);
1119        break;
1120      }
1121    }
1122  }
1123  TEST_P(TimeoutTest, ReaderLockWhen) {
1124    const TimeoutTestParam params = GetParam();
1125    LOG(INFO) &lt;&lt; &quot;Params: &quot; &lt;&lt; params;
1126    for (int attempt = 0;; ++attempt) {
1127      LOG(INFO) &lt;&lt; &quot;Attempt &quot; &lt;&lt; attempt;
1128      absl::Mutex mu;
1129      bool value = false;  
1130      std::unique_ptr&lt;absl::synchronization_internal::ThreadPool&gt; pool =
1131          CreateDefaultPool();
1132      RunAfterDelay(params.satisfy_condition_delay, pool.get(), [&amp;] {
1133        absl::MutexLock l(&amp;mu);
1134        value = true;
1135      });
1136      absl::Time start_time = absl::Now();
1137      bool result =
1138          params.use_absolute_deadline
1139              ? mu.ReaderLockWhenWithDeadline(absl::Condition(&amp;value),
1140                                              start_time + params.wait_timeout)
1141              : mu.ReaderLockWhenWithTimeout(absl::Condition(&amp;value),
1142                                             params.wait_timeout);
1143      mu.ReaderUnlock();
1144      if (DelayIsWithinBounds(params.expected_delay, absl::Now() - start_time)) {
1145        EXPECT_EQ(params.expected_result, result);
1146        break;
1147      }
1148    }
1149  }
1150  TEST_P(TimeoutTest, Wait) {
1151    const TimeoutTestParam params = GetParam();
1152    LOG(INFO) &lt;&lt; &quot;Params: &quot; &lt;&lt; params;
1153    for (int attempt = 0;; ++attempt) {
1154      LOG(INFO) &lt;&lt; &quot;Attempt &quot; &lt;&lt; attempt;
1155      absl::Mutex mu;
1156      bool value = false;  
1157      absl::CondVar cv;    
1158      std::unique_ptr&lt;absl::synchronization_internal::ThreadPool&gt; pool =
1159          CreateDefaultPool();
1160      RunAfterDelay(params.satisfy_condition_delay, pool.get(), [&amp;] {
1161        absl::MutexLock l(&amp;mu);
1162        value = true;
1163        cv.Signal();
1164      });
1165      absl::MutexLock lock(&amp;mu);
1166      absl::Time start_time = absl::Now();
1167      absl::Duration timeout = params.wait_timeout;
1168      absl::Time deadline = start_time + timeout;
1169      while (!value) {
1170        if (params.use_absolute_deadline ? cv.WaitWithDeadline(&amp;mu, deadline)
1171                                         : cv.WaitWithTimeout(&amp;mu, timeout)) {
1172          break;  
1173        }
1174        timeout = deadline - absl::Now();  
1175      }
1176      bool result = value;  
1177      if (DelayIsWithinBounds(params.expected_delay, absl::Now() - start_time)) {
1178        EXPECT_EQ(params.expected_result, result);
1179        break;
1180      }
1181    }
1182  }
1183  TEST(Mutex, Logging) {
1184    absl::Mutex logged_mutex;
1185    logged_mutex.EnableDebugLog(&quot;fido_mutex&quot;);
1186    absl::CondVar logged_cv;
1187    logged_cv.EnableDebugLog(&quot;rover_cv&quot;);
1188    logged_mutex.Lock();
1189    logged_cv.WaitWithTimeout(&amp;logged_mutex, absl::Milliseconds(20));
1190    logged_mutex.Unlock();
1191    logged_mutex.ReaderLock();
1192    logged_mutex.ReaderUnlock();
1193    logged_mutex.Lock();
1194    logged_mutex.Unlock();
1195    logged_cv.Signal();
1196    logged_cv.SignalAll();
1197  }
1198  static std::vector&lt;int&gt; AllThreadCountValues() {
1199    if (kExtendedTest) {
1200      return {2, 4, 8, 10, 16, 20, 24, 30, 32};
1201    }
1202    return {2, 4, 10};
1203  }
1204  class MutexVariableThreadCountTest : public ::testing::TestWithParam&lt;int&gt; {};
1205  INSTANTIATE_TEST_SUITE_P(ThreadCounts, MutexVariableThreadCountTest,
1206                           ::testing::ValuesIn(AllThreadCountValues()),
1207                           ::testing::PrintToStringParamName());
1208  static int ScaleIterations(int x) {
1209  #if defined(ABSL_MUTEX_READER_LOCK_IS_EXCLUSIVE)
1210    return x / 10;
1211  #else
1212    return x;
1213  #endif
1214  }
1215  TEST_P(MutexVariableThreadCountTest, Mutex) {
1216    int threads = GetParam();
1217    int iterations = ScaleIterations(10000000) / threads;
1218    int operations = threads * iterations;
1219    EXPECT_EQ(RunTest(&amp;TestMu, threads, iterations, operations), operations);
1220  #if !defined(ABSL_MUTEX_ENABLE_INVARIANT_DEBUGGING_NOT_IMPLEMENTED)
1221    iterations = std::min(iterations, 10);
1222    operations = threads * iterations;
1223    EXPECT_EQ(RunTestWithInvariantDebugging(&amp;TestMu, threads, iterations,
1224                                            operations, CheckSumG0G1),
1225              operations);
1226  #endif
1227  }
1228  TEST_P(MutexVariableThreadCountTest, Try) {
1229    int threads = GetParam();
1230    int iterations = 1000000 / threads;
1231    int operations = iterations * threads;
1232    EXPECT_EQ(RunTest(&amp;TestTry, threads, iterations, operations), operations);
1233  #if !defined(ABSL_MUTEX_ENABLE_INVARIANT_DEBUGGING_NOT_IMPLEMENTED)
1234    iterations = std::min(iterations, 10);
1235    operations = threads * iterations;
1236    EXPECT_EQ(RunTestWithInvariantDebugging(&amp;TestTry, threads, iterations,
1237                                            operations, CheckSumG0G1),
1238              operations);
1239  #endif
1240  }
1241  TEST_P(MutexVariableThreadCountTest, R20ms) {
1242    int threads = GetParam();
1243    int iterations = 100;
1244    int operations = iterations * threads;
1245    EXPECT_EQ(RunTest(&amp;TestR20ms, threads, iterations, operations), 0);
1246  }
1247  TEST_P(MutexVariableThreadCountTest, RW) {
1248    int threads = GetParam();
1249    int iterations = ScaleIterations(20000000) / threads;
1250    int operations = iterations * threads;
1251    EXPECT_EQ(RunTest(&amp;TestRW, threads, iterations, operations), operations / 2);
1252  #if !defined(ABSL_MUTEX_ENABLE_INVARIANT_DEBUGGING_NOT_IMPLEMENTED)
1253    iterations = std::min(iterations, 10);
1254    operations = threads * iterations;
1255    EXPECT_EQ(RunTestWithInvariantDebugging(&amp;TestRW, threads, iterations,
1256                                            operations, CheckSumG0G1),
1257              operations / 2);
1258  #endif
1259  }
1260  TEST_P(MutexVariableThreadCountTest, Await) {
1261    int threads = GetParam();
1262    int iterations = ScaleIterations(500000);
1263    int operations = iterations;
1264    EXPECT_EQ(RunTest(&amp;TestAwait, threads, iterations, operations), operations);
1265  }
1266  TEST_P(MutexVariableThreadCountTest, SignalAll) {
1267    int threads = GetParam();
1268    int iterations = 200000 / threads;
1269    int operations = iterations;
1270    EXPECT_EQ(RunTest(&amp;TestSignalAll, threads, iterations, operations),
1271              operations);
1272  }
1273  TEST(Mutex, Signal) {
1274    int threads = 2;  
1275    int iterations = 200000;
1276    int operations = iterations;
1277    EXPECT_EQ(RunTest(&amp;TestSignal, threads, iterations, operations), operations);
1278  }
1279  TEST(Mutex, Timed) {
1280    int threads = 10;  
1281    int iterations = 1000;
1282    int operations = iterations;
1283    EXPECT_EQ(RunTest(&amp;TestCVTimeout, threads, iterations, operations),
1284              operations);
1285  }
1286  TEST(Mutex, CVTime) {
1287    int threads = 10;  
1288    int iterations = 1;
1289    EXPECT_EQ(RunTest(&amp;TestCVTime, threads, iterations, 1), threads * iterations);
1290  }
1291  TEST(Mutex, MuTime) {
1292    int threads = 10;  
1293    int iterations = 1;
1294    EXPECT_EQ(RunTest(&amp;TestMuTime, threads, iterations, 1), threads * iterations);
1295  }
1296  TEST(Mutex, SignalExitedThread) {
1297  #if defined(__wasm__) || defined(__asmjs__)
1298    constexpr int kThreads = 1;  
1299  #else
1300    constexpr int kThreads = 100;
1301  #endif
1302    std::vector&lt;std::thread&gt; top;
1303    for (unsigned i = 0; i &lt; 2 * std::thread::hardware_concurrency(); i++) {
1304      top.emplace_back([&amp;]() {
1305        for (int i = 0; i &lt; kThreads; i++) {
1306          absl::Mutex mu;
1307          std::thread t([&amp;]() {
1308            mu.Lock();
1309            mu.Unlock();
1310          });
1311          mu.Lock();
1312          mu.Unlock();
1313          t.join();
1314        }
1315      });
1316    }
1317    for (auto &amp;th : top) th.join();
1318  }
1319  TEST(Mutex, WriterPriority) {
1320    absl::Mutex mu;
1321    bool wrote = false;
1322    std::atomic&lt;bool&gt; saw_wrote{false};
1323    auto readfunc = [&amp;]() {
1324      for (size_t i = 0; i &lt; 10; ++i) {
1325        absl::ReaderMutexLock lock(&amp;mu);
1326        if (wrote) {
1327          saw_wrote = true;
1328          break;
1329        }
1330        absl::SleepFor(absl::Seconds(1));
1331      }
1332    };
1333    std::thread t1(readfunc);
1334    absl::SleepFor(absl::Milliseconds(500));
1335    std::thread t2(readfunc);
1336    std::thread t3([&amp;]() {
1337      absl::MutexLock lock(&amp;mu);
1338      wrote = true;
1339    });
1340    t1.join();
1341    t2.join();
1342    t3.join();
1343    EXPECT_TRUE(saw_wrote.load());
1344  }
1345  TEST(Mutex, LockWhenWithTimeoutResult) {
1346    absl::Mutex mu;
1347    const bool kAlwaysTrue = true, kAlwaysFalse = false;
1348    const absl::Condition kTrueCond(&amp;kAlwaysTrue), kFalseCond(&amp;kAlwaysFalse);
1349    EXPECT_TRUE(mu.LockWhenWithTimeout(kTrueCond, absl::Milliseconds(1)));
1350    mu.Unlock();
1351    EXPECT_FALSE(mu.LockWhenWithTimeout(kFalseCond, absl::Milliseconds(1)));
1352    EXPECT_TRUE(mu.AwaitWithTimeout(kTrueCond, absl::Milliseconds(1)));
1353    EXPECT_FALSE(mu.AwaitWithTimeout(kFalseCond, absl::Milliseconds(1)));
1354    std::thread th1([&amp;]() {
1355      EXPECT_TRUE(mu.LockWhenWithTimeout(kTrueCond, absl::Milliseconds(1)));
1356      mu.Unlock();
1357    });
1358    std::thread th2([&amp;]() {
1359      EXPECT_FALSE(mu.LockWhenWithTimeout(kFalseCond, absl::Milliseconds(1)));
1360      mu.Unlock();
1361    });
1362    absl::SleepFor(absl::Milliseconds(100));
1363    mu.Unlock();
1364    th1.join();
1365    th2.join();
1366  }
1367  }  
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-mutex_test.cc</h3>
            <pre><code>1  #include &quot;absl/synchronization/mutex.h&quot;
2  #ifdef _WIN32
3  #include &lt;windows.h&gt;
4  #endif
5  #include &lt;algorithm&gt;
6  #include &lt;atomic&gt;
7  #include &lt;cstdlib&gt;
8  #include &lt;functional&gt;
9  #include &lt;memory&gt;
10  #include &lt;random&gt;
11  #include &lt;string&gt;
12  #include &lt;thread&gt;  
13  #include &lt;type_traits&gt;
14  #include &lt;vector&gt;
15  #include &quot;gtest/gtest.h&quot;
16  #include &quot;absl/base/attributes.h&quot;
17  #include &quot;absl/base/config.h&quot;
18  #include &quot;absl/base/internal/sysinfo.h&quot;
19  #include &quot;absl/log/check.h&quot;
20  #include &quot;absl/log/log.h&quot;
21  #include &quot;absl/memory/memory.h&quot;
22  #include &quot;absl/synchronization/internal/thread_pool.h&quot;
23  #include &quot;absl/time/clock.h&quot;
24  #include &quot;absl/time/time.h&quot;
25  namespace {
26  static constexpr bool kExtendedTest = false;
27  std::unique_ptr&lt;absl::synchronization_internal::ThreadPool&gt; CreatePool(
28      int threads) {
29    return absl::make_unique&lt;absl::synchronization_internal::ThreadPool&gt;(threads);
30  }
31  std::unique_ptr&lt;absl::synchronization_internal::ThreadPool&gt;
32  CreateDefaultPool() {
33    return CreatePool(kExtendedTest ? 32 : 10);
34  }
35  static void ScheduleAfter(absl::synchronization_internal::ThreadPool *tp,
36                            absl::Duration after,
37                            const std::function&lt;void()&gt; &amp;func) {
38    tp-&gt;Schedule([func, after] {
39      absl::SleepFor(after);
40      func();
41    });
42  }
43  struct TestContext {
44    int iterations;
45    int threads;
46    int g0;  
47    int g1;  
48    absl::Mutex mu;
49    absl::CondVar cv;
50  };
51  static std::atomic&lt;bool&gt; invariant_checked;
52  static bool GetInvariantChecked() {
53    return invariant_checked.load(std::memory_order_relaxed);
54  }
55  static void SetInvariantChecked(bool new_value) {
56    invariant_checked.store(new_value, std::memory_order_relaxed);
57  }
58  static void CheckSumG0G1(void *v) {
59    TestContext *cxt = static_cast&lt;TestContext *&gt;(v);
60    CHECK_EQ(cxt-&gt;g0, -cxt-&gt;g1) &lt;&lt; &quot;Error in CheckSumG0G1&quot;;
61    SetInvariantChecked(true);
62  }
63  static void TestMu(TestContext *cxt, int c) {
64    for (int i = 0; i != cxt-&gt;iterations; i++) {
65      absl::MutexLock l(&amp;cxt-&gt;mu);
66      int a = cxt-&gt;g0 + 1;
67      cxt-&gt;g0 = a;
68      cxt-&gt;g1--;
69    }
70  }
71  static void TestTry(TestContext *cxt, int c) {
72    for (int i = 0; i != cxt-&gt;iterations; i++) {
73      do {
74        std::this_thread::yield();
75      } while (!cxt-&gt;mu.TryLock());
76      int a = cxt-&gt;g0 + 1;
77      cxt-&gt;g0 = a;
78      cxt-&gt;g1--;
79      cxt-&gt;mu.Unlock();
80    }
81  }
82  static void TestR20ms(TestContext *cxt, int c) {
83    for (int i = 0; i != cxt-&gt;iterations; i++) {
84      absl::ReaderMutexLock l(&amp;cxt-&gt;mu);
85      absl::SleepFor(absl::Milliseconds(20));
86      cxt-&gt;mu.AssertReaderHeld();
87    }
88  }
89  static void TestRW(TestContext *cxt, int c) {
90    if ((c &amp; 1) == 0) {
91      for (int i = 0; i != cxt-&gt;iterations; i++) {
92        absl::WriterMutexLock l(&amp;cxt-&gt;mu);
93        cxt-&gt;g0++;
94        cxt-&gt;g1--;
95        cxt-&gt;mu.AssertHeld();
96        cxt-&gt;mu.AssertReaderHeld();
97      }
98    } else {
99      for (int i = 0; i != cxt-&gt;iterations; i++) {
100        absl::ReaderMutexLock l(&amp;cxt-&gt;mu);
101        CHECK_EQ(cxt-&gt;g0, -cxt-&gt;g1) &lt;&lt; &quot;Error in TestRW&quot;;
102        cxt-&gt;mu.AssertReaderHeld();
103      }
104    }
105  }
106  struct MyContext {
107    int target;
108    TestContext *cxt;
109    bool MyTurn();
110  };
111  bool MyContext::MyTurn() {
112    TestContext *cxt = this-&gt;cxt;
113    return cxt-&gt;g0 == this-&gt;target || cxt-&gt;g0 == cxt-&gt;iterations;
114  }
115  static void TestAwait(TestContext *cxt, int c) {
116    MyContext mc;
117    mc.target = c;
118    mc.cxt = cxt;
119    absl::MutexLock l(&amp;cxt-&gt;mu);
120    cxt-&gt;mu.AssertHeld();
121    while (cxt-&gt;g0 &lt; cxt-&gt;iterations) {
122      cxt-&gt;mu.Await(absl::Condition(&amp;mc, &amp;MyContext::MyTurn));
123      CHECK(mc.MyTurn()) &lt;&lt; &quot;Error in TestAwait&quot;;
124      cxt-&gt;mu.AssertHeld();
125      if (cxt-&gt;g0 &lt; cxt-&gt;iterations) {
126        int a = cxt-&gt;g0 + 1;
127        cxt-&gt;g0 = a;
128        mc.target += cxt-&gt;threads;
129      }
130    }
131  }
132  static void TestSignalAll(TestContext *cxt, int c) {
133    int target = c;
134    absl::MutexLock l(&amp;cxt-&gt;mu);
135    cxt-&gt;mu.AssertHeld();
136    while (cxt-&gt;g0 &lt; cxt-&gt;iterations) {
137      while (cxt-&gt;g0 != target &amp;&amp; cxt-&gt;g0 != cxt-&gt;iterations) {
138        cxt-&gt;cv.Wait(&amp;cxt-&gt;mu);
139      }
140      if (cxt-&gt;g0 &lt; cxt-&gt;iterations) {
141        int a = cxt-&gt;g0 + 1;
142        cxt-&gt;g0 = a;
143        cxt-&gt;cv.SignalAll();
144        target += cxt-&gt;threads;
145      }
146    }
147  }
148  static void TestSignal(TestContext *cxt, int c) {
149    CHECK_EQ(cxt-&gt;threads, 2) &lt;&lt; &quot;TestSignal should use 2 threads&quot;;
150    int target = c;
151    absl::MutexLock l(&amp;cxt-&gt;mu);
152    cxt-&gt;mu.AssertHeld();
153    while (cxt-&gt;g0 &lt; cxt-&gt;iterations) {
154      while (cxt-&gt;g0 != target &amp;&amp; cxt-&gt;g0 != cxt-&gt;iterations) {
155        cxt-&gt;cv.Wait(&amp;cxt-&gt;mu);
156      }
157      if (cxt-&gt;g0 &lt; cxt-&gt;iterations) {
158        int a = cxt-&gt;g0 + 1;
159        cxt-&gt;g0 = a;
160        cxt-&gt;cv.Signal();
161        target += cxt-&gt;threads;
162      }
163    }
164  }
165  static void TestCVTimeout(TestContext *cxt, int c) {
166    int target = c;
167    absl::MutexLock l(&amp;cxt-&gt;mu);
168    cxt-&gt;mu.AssertHeld();
169    while (cxt-&gt;g0 &lt; cxt-&gt;iterations) {
170      while (cxt-&gt;g0 != target &amp;&amp; cxt-&gt;g0 != cxt-&gt;iterations) {
171        cxt-&gt;cv.WaitWithTimeout(&amp;cxt-&gt;mu, absl::Seconds(100));
172      }
173      if (cxt-&gt;g0 &lt; cxt-&gt;iterations) {
174        int a = cxt-&gt;g0 + 1;
175        cxt-&gt;g0 = a;
176        cxt-&gt;cv.SignalAll();
177        target += cxt-&gt;threads;
178      }
179    }
180  }
181  static bool G0GE2(TestContext *cxt) { return cxt-&gt;g0 &gt;= 2; }
182  static void TestTime(TestContext *cxt, int c, bool use_cv) {
183    CHECK_EQ(cxt-&gt;iterations, 1) &lt;&lt; &quot;TestTime should only use 1 iteration&quot;;
184    CHECK_GT(cxt-&gt;threads, 2) &lt;&lt; &quot;TestTime should use more than 2 threads&quot;;
185    const bool kFalse = false;
186    absl::Condition false_cond(&amp;kFalse);
187    absl::Condition g0ge2(G0GE2, cxt);
188    if (c == 0) {
189      absl::MutexLock l(&amp;cxt-&gt;mu);
190      absl::Time start = absl::Now();
191      if (use_cv) {
192        cxt-&gt;cv.WaitWithTimeout(&amp;cxt-&gt;mu, absl::Seconds(1));
193      } else {
194        CHECK(!cxt-&gt;mu.AwaitWithTimeout(false_cond, absl::Seconds(1)))
195            &lt;&lt; &quot;TestTime failed&quot;;
196      }
197      absl::Duration elapsed = absl::Now() - start;
198      CHECK(absl::Seconds(0.9) &lt;= elapsed &amp;&amp; elapsed &lt;= absl::Seconds(2.0))
199          &lt;&lt; &quot;TestTime failed&quot;;
200      CHECK_EQ(cxt-&gt;g0, 1) &lt;&lt; &quot;TestTime failed&quot;;
201      start = absl::Now();
202      if (use_cv) {
203        cxt-&gt;cv.WaitWithTimeout(&amp;cxt-&gt;mu, absl::Seconds(1));
204      } else {
205        CHECK(!cxt-&gt;mu.AwaitWithTimeout(false_cond, absl::Seconds(1)))
206            &lt;&lt; &quot;TestTime failed&quot;;
207      }
208      elapsed = absl::Now() - start;
209      CHECK(absl::Seconds(0.9) &lt;= elapsed &amp;&amp; elapsed &lt;= absl::Seconds(2.0))
210          &lt;&lt; &quot;TestTime failed&quot;;
211      cxt-&gt;g0++;
212      if (use_cv) {
213        cxt-&gt;cv.Signal();
214      }
215      start = absl::Now();
216      if (use_cv) {
217        cxt-&gt;cv.WaitWithTimeout(&amp;cxt-&gt;mu, absl::Seconds(4));
218      } else {
219        CHECK(!cxt-&gt;mu.AwaitWithTimeout(false_cond, absl::Seconds(4)))
220            &lt;&lt; &quot;TestTime failed&quot;;
221      }
222      elapsed = absl::Now() - start;
223      CHECK(absl::Seconds(3.9) &lt;= elapsed &amp;&amp; elapsed &lt;= absl::Seconds(6.0))
224          &lt;&lt; &quot;TestTime failed&quot;;
225      CHECK_GE(cxt-&gt;g0, 3) &lt;&lt; &quot;TestTime failed&quot;;
226      start = absl::Now();
227      if (use_cv) {
228        cxt-&gt;cv.WaitWithTimeout(&amp;cxt-&gt;mu, absl::Seconds(1));
229      } else {
230        CHECK(!cxt-&gt;mu.AwaitWithTimeout(false_cond, absl::Seconds(1)))
231            &lt;&lt; &quot;TestTime failed&quot;;
232      }
233      elapsed = absl::Now() - start;
234      CHECK(absl::Seconds(0.9) &lt;= elapsed &amp;&amp; elapsed &lt;= absl::Seconds(2.0))
235          &lt;&lt; &quot;TestTime failed&quot;;
236      if (use_cv) {
237        cxt-&gt;cv.SignalAll();
238      }
239      start = absl::Now();
240      if (use_cv) {
241        cxt-&gt;cv.WaitWithTimeout(&amp;cxt-&gt;mu, absl::Seconds(1));
242      } else {
243        CHECK(!cxt-&gt;mu.AwaitWithTimeout(false_cond, absl::Seconds(1)))
244            &lt;&lt; &quot;TestTime failed&quot;;
245      }
246      elapsed = absl::Now() - start;
247      CHECK(absl::Seconds(0.9) &lt;= elapsed &amp;&amp; elapsed &lt;= absl::Seconds(2.0))
248          &lt;&lt; &quot;TestTime failed&quot;;
249      CHECK_EQ(cxt-&gt;g0, cxt-&gt;threads) &lt;&lt; &quot;TestTime failed&quot;;
250    } else if (c == 1) {
251      absl::MutexLock l(&amp;cxt-&gt;mu);
252      const absl::Time start = absl::Now();
253      if (use_cv) {
254        cxt-&gt;cv.WaitWithTimeout(&amp;cxt-&gt;mu, absl::Milliseconds(500));
255      } else {
256        CHECK(!cxt-&gt;mu.AwaitWithTimeout(false_cond, absl::Milliseconds(500)))
257            &lt;&lt; &quot;TestTime failed&quot;;
258      }
259      const absl::Duration elapsed = absl::Now() - start;
260      CHECK(absl::Seconds(0.4) &lt;= elapsed &amp;&amp; elapsed &lt;= absl::Seconds(0.9))
261          &lt;&lt; &quot;TestTime failed&quot;;
262      cxt-&gt;g0++;
263    } else if (c == 2) {
264      absl::MutexLock l(&amp;cxt-&gt;mu);
265      if (use_cv) {
266        while (cxt-&gt;g0 &lt; 2) {
267          cxt-&gt;cv.WaitWithTimeout(&amp;cxt-&gt;mu, absl::Seconds(100));
268        }
269      } else {
270        CHECK(cxt-&gt;mu.AwaitWithTimeout(g0ge2, absl::Seconds(100)))
271            &lt;&lt; &quot;TestTime failed&quot;;
272      }
273      cxt-&gt;g0++;
274    } else {
275      absl::MutexLock l(&amp;cxt-&gt;mu);
276      if (use_cv) {
277        while (cxt-&gt;g0 &lt; 2) {
278          cxt-&gt;cv.Wait(&amp;cxt-&gt;mu);
279        }
280      } else {
281        cxt-&gt;mu.Await(g0ge2);
282      }
283      cxt-&gt;g0++;
284    }
285  }
286  static void TestMuTime(TestContext *cxt, int c) { TestTime(cxt, c, false); }
287  static void TestCVTime(TestContext *cxt, int c) { TestTime(cxt, c, true); }
288  static void EndTest(int *c0, int *c1, absl::Mutex *mu, absl::CondVar *cv,
289                      const std::function&lt;void(int)&gt; &amp;cb) {
290    mu-&gt;Lock();
291    int c = (*c0)++;
292    mu-&gt;Unlock();
293    cb(c);
294    absl::MutexLock l(mu);
295    (*c1)++;
296    cv-&gt;Signal();
297  }
298  static int RunTestCommon(TestContext *cxt, void (*test)(TestContext *cxt, int),
299                           int threads, int iterations, int operations) {
300    absl::Mutex mu2;
301    absl::CondVar cv2;
302    int c0 = 0;
303    int c1 = 0;
304    cxt-&gt;g0 = 0;
305    cxt-&gt;g1 = 0;
306    cxt-&gt;iterations = iterations;
307    cxt-&gt;threads = threads;
308    absl::synchronization_internal::ThreadPool tp(threads);
309    for (int i = 0; i != threads; i++) {
310      tp.Schedule(std::bind(
311          &amp;EndTest, &amp;c0, &amp;c1, &amp;mu2, &amp;cv2,
312          std::function&lt;void(int)&gt;(std::bind(test, cxt, std::placeholders::_1))));
313    }
314    mu2.Lock();
315    while (c1 != threads) {
316      cv2.Wait(&amp;mu2);
317    }
318    mu2.Unlock();
319    return cxt-&gt;g0;
320  }
321  static int RunTest(void (*test)(TestContext *cxt, int), int threads,
322                     int iterations, int operations) {
323    TestContext cxt;
324    return RunTestCommon(&amp;cxt, test, threads, iterations, operations);
325  }
326  #if !defined(ABSL_MUTEX_ENABLE_INVARIANT_DEBUGGING_NOT_IMPLEMENTED)
327  static int RunTestWithInvariantDebugging(void (*test)(TestContext *cxt, int),
328                                           int threads, int iterations,
329                                           int operations,
330                                           void (*invariant)(void *)) {
331    absl::EnableMutexInvariantDebugging(true);
332    SetInvariantChecked(false);
333    TestContext cxt;
334    cxt.mu.EnableInvariantDebugging(invariant, &amp;cxt);
335    int ret = RunTestCommon(&amp;cxt, test, threads, iterations, operations);
336    CHECK(GetInvariantChecked()) &lt;&lt; &quot;Invariant not checked&quot;;
337    absl::EnableMutexInvariantDebugging(false);  
338    return ret;
339  }
340  #endif
341  struct TimeoutBugStruct {
342    absl::Mutex mu;
343    bool a;
344    int a_waiter_count;
345  };
346  static void WaitForA(TimeoutBugStruct *x) {
347    x-&gt;mu.LockWhen(absl::Condition(&amp;x-&gt;a));
348    x-&gt;a_waiter_count--;
349    x-&gt;mu.Unlock();
350  }
351  static bool NoAWaiters(TimeoutBugStruct *x) { return x-&gt;a_waiter_count == 0; }
352  TEST(Mutex, CondVarWaitSignalsAwait) {
353    struct {
354      absl::Mutex barrier_mu;
355      bool barrier ABSL_GUARDED_BY(barrier_mu) = false;
356      absl::Mutex release_mu;
357      bool release ABSL_GUARDED_BY(release_mu) = false;
358      absl::CondVar released_cv;
359    } state;
360    auto pool = CreateDefaultPool();
361    pool-&gt;Schedule([&amp;state] {
362      state.release_mu.Lock();
363      state.barrier_mu.Lock();
364      state.barrier = true;
365      state.barrier_mu.Unlock();
366      state.release_mu.Await(absl::Condition(&amp;state.release));
367      state.released_cv.Signal();
368      state.release_mu.Unlock();
369    });
370    state.barrier_mu.LockWhen(absl::Condition(&amp;state.barrier));
371    state.barrier_mu.Unlock();
372    state.release_mu.Lock();
373    state.release = true;
374    state.released_cv.Wait(&amp;state.release_mu);
375    state.release_mu.Unlock();
376  }
377  TEST(Mutex, CondVarWaitWithTimeoutSignalsAwait) {
378    struct {
379      absl::Mutex barrier_mu;
380      bool barrier ABSL_GUARDED_BY(barrier_mu) = false;
381      absl::Mutex release_mu;
382      bool release ABSL_GUARDED_BY(release_mu) = false;
383      absl::CondVar released_cv;
384    } state;
385    auto pool = CreateDefaultPool();
386    pool-&gt;Schedule([&amp;state] {
387      state.release_mu.Lock();
388      state.barrier_mu.Lock();
389      state.barrier = true;
390      state.barrier_mu.Unlock();
391      state.release_mu.Await(absl::Condition(&amp;state.release));
392      state.released_cv.Signal();
<span onclick='openModal()' class='match'>393      state.release_mu.Unlock();
394    });
395    state.barrier_mu.LockWhen(absl::Condition(&amp;state.barrier));
396    state.barrier_mu.Unlock();
397    state.release_mu.Lock();
398    state.release = true;
399    EXPECT_TRUE(
</span>400        !state.released_cv.WaitWithTimeout(&amp;state.release_mu, absl::Seconds(10)))
401        &lt;&lt; &quot;; Unrecoverable test failure: CondVar::WaitWithTimeout did not &quot;
402           &quot;unblock the absl::Mutex::Await call in another thread.&quot;;
403    state.release_mu.Unlock();
404  }
405  TEST(Mutex, MutexTimeoutBug) {
406    auto tp = CreateDefaultPool();
407    TimeoutBugStruct x;
408    x.a = false;
409    x.a_waiter_count = 2;
410    tp-&gt;Schedule(std::bind(&amp;WaitForA, &amp;x));
411    tp-&gt;Schedule(std::bind(&amp;WaitForA, &amp;x));
412    absl::SleepFor(absl::Seconds(1));  
413    bool always_false = false;
414    x.mu.LockWhenWithTimeout(absl::Condition(&amp;always_false),
415                             absl::Milliseconds(500));
416    x.a = true;                                    
417    x.mu.Await(absl::Condition(&amp;NoAWaiters, &amp;x));  
418    x.mu.Unlock();
419  }
420  struct CondVarWaitDeadlock : testing::TestWithParam&lt;int&gt; {
421    absl::Mutex mu;
422    absl::CondVar cv;
423    bool cond1 = false;
424    bool cond2 = false;
425    bool read_lock1;
426    bool read_lock2;
427    bool signal_unlocked;
428    CondVarWaitDeadlock() {
429      read_lock1 = GetParam() &amp; (1 &lt;&lt; 0);
430      read_lock2 = GetParam() &amp; (1 &lt;&lt; 1);
431      signal_unlocked = GetParam() &amp; (1 &lt;&lt; 2);
432    }
433    void Waiter1() {
434      if (read_lock1) {
435        mu.ReaderLock();
436        while (!cond1) {
437          cv.Wait(&amp;mu);
438        }
439        mu.ReaderUnlock();
440      } else {
441        mu.Lock();
442        while (!cond1) {
443          cv.Wait(&amp;mu);
444        }
445        mu.Unlock();
446      }
447    }
448    void Waiter2() {
449      if (read_lock2) {
450        mu.ReaderLockWhen(absl::Condition(&amp;cond2));
451        mu.ReaderUnlock();
452      } else {
453        mu.LockWhen(absl::Condition(&amp;cond2));
454        mu.Unlock();
455      }
456    }
457  };
458  TEST_P(CondVarWaitDeadlock, Test) {
459    auto waiter1 = CreatePool(1);
460    auto waiter2 = CreatePool(1);
461    waiter1-&gt;Schedule([this] { this-&gt;Waiter1(); });
462    waiter2-&gt;Schedule([this] { this-&gt;Waiter2(); });
463    absl::SleepFor(absl::Milliseconds(100));
464    mu.Lock();
465    cond1 = true;
466    if (signal_unlocked) {
467      mu.Unlock();
468      cv.Signal();
469    } else {
470      cv.Signal();
471      mu.Unlock();
472    }
473    waiter1.reset();  
474    mu.Lock();
475    cond2 = true;
476    mu.Unlock();
477    waiter2.reset();  
478  }
479  INSTANTIATE_TEST_SUITE_P(CondVarWaitDeadlockTest, CondVarWaitDeadlock,
480                           ::testing::Range(0, 8),
481                           ::testing::PrintToStringParamName());
482  struct DequeueAllWakeableBugStruct {
483    absl::Mutex mu;
484    absl::Mutex mu2;       
485    int unfinished_count;  
486    bool done1;            
487    int finished_count;    
488    bool done2;            
489  };
490  static void AcquireAsReader(DequeueAllWakeableBugStruct *x) {
491    x-&gt;mu.ReaderLock();
492    x-&gt;mu2.Lock();
493    x-&gt;unfinished_count--;
494    x-&gt;done1 = (x-&gt;unfinished_count == 0);
495    x-&gt;mu2.Unlock();
496    absl::SleepFor(absl::Seconds(2));
497    x-&gt;mu.ReaderUnlock();
498    x-&gt;mu2.Lock();
499    x-&gt;finished_count--;
500    x-&gt;done2 = (x-&gt;finished_count == 0);
501    x-&gt;mu2.Unlock();
502  }
503  TEST(Mutex, MutexReaderWakeupBug) {
504    auto tp = CreateDefaultPool();
505    DequeueAllWakeableBugStruct x;
506    x.unfinished_count = 2;
507    x.done1 = false;
508    x.finished_count = 2;
509    x.done2 = false;
510    x.mu.Lock();  
511    tp-&gt;Schedule(std::bind(&amp;AcquireAsReader, &amp;x));
512    tp-&gt;Schedule(std::bind(&amp;AcquireAsReader, &amp;x));
513    absl::SleepFor(absl::Seconds(1));  
514    x.mu.Unlock();                     
515    EXPECT_TRUE(
516        x.mu2.LockWhenWithTimeout(absl::Condition(&amp;x.done1), absl::Seconds(10)));
517    x.mu2.Unlock();
518    EXPECT_TRUE(
519        x.mu2.LockWhenWithTimeout(absl::Condition(&amp;x.done2), absl::Seconds(10)));
520    x.mu2.Unlock();
521  }
522  struct LockWhenTestStruct {
523    absl::Mutex mu1;
524    bool cond = false;
525    absl::Mutex mu2;
526    bool waiting = false;
527  };
528  static bool LockWhenTestIsCond(LockWhenTestStruct *s) {
529    s-&gt;mu2.Lock();
530    s-&gt;waiting = true;
531    s-&gt;mu2.Unlock();
532    return s-&gt;cond;
533  }
534  static void LockWhenTestWaitForIsCond(LockWhenTestStruct *s) {
535    s-&gt;mu1.LockWhen(absl::Condition(&amp;LockWhenTestIsCond, s));
536    s-&gt;mu1.Unlock();
537  }
538  TEST(Mutex, LockWhen) {
539    LockWhenTestStruct s;
540    std::thread t(LockWhenTestWaitForIsCond, &amp;s);
541    s.mu2.LockWhen(absl::Condition(&amp;s.waiting));
542    s.mu2.Unlock();
543    s.mu1.Lock();
544    s.cond = true;
545    s.mu1.Unlock();
546    t.join();
547  }
548  TEST(Mutex, LockWhenGuard) {
549    absl::Mutex mu;
550    int n = 30;
551    bool done = false;
552    bool (*cond_eq_10)(int *) = [](int *p) { return *p == 10; };
553    bool (*cond_lt_10)(int *) = [](int *p) { return *p &lt; 10; };
554    std::thread t1([&amp;mu, &amp;n, &amp;done, cond_eq_10]() {
555      absl::ReaderMutexLock lock(&amp;mu, absl::Condition(cond_eq_10, &amp;n));
556      done = true;
557    });
558    std::thread t2[10];
559    for (std::thread &amp;t : t2) {
560      t = std::thread([&amp;mu, &amp;n, cond_lt_10]() {
561        absl::WriterMutexLock lock(&amp;mu, absl::Condition(cond_lt_10, &amp;n));
562        ++n;
563      });
564    }
565    {
566      absl::MutexLock lock(&amp;mu);
567      n = 0;
568    }
569    for (std::thread &amp;t : t2) t.join();
570    t1.join();
571    EXPECT_TRUE(done);
572    EXPECT_EQ(n, 10);
573  }
574  #if !defined(ABSL_MUTEX_READER_LOCK_IS_EXCLUSIVE)
575  struct ReaderDecrementBugStruct {
576    bool cond;  
577    int done;   
578    absl::Mutex mu;
579    bool waiting_on_cond;   
580    bool have_reader_lock;  
581    bool complete;          
582    absl::Mutex mu2;        
583  };
584  static bool IsCond(void *v) {
585    ReaderDecrementBugStruct *x = reinterpret_cast&lt;ReaderDecrementBugStruct *&gt;(v);
586    x-&gt;mu2.Lock();
587    x-&gt;waiting_on_cond = true;
588    x-&gt;mu2.Unlock();
589    return x-&gt;cond;
590  }
591  static bool AllDone(void *v) {
592    ReaderDecrementBugStruct *x = reinterpret_cast&lt;ReaderDecrementBugStruct *&gt;(v);
593    return x-&gt;done == 0;
594  }
595  static void WaitForCond(ReaderDecrementBugStruct *x) {
596    absl::Mutex dummy;
597    absl::MutexLock l(&amp;dummy);
598    x-&gt;mu.LockWhen(absl::Condition(&amp;IsCond, x));
599    x-&gt;done--;
600    x-&gt;mu.Unlock();
601  }
602  static void GetReadLock(ReaderDecrementBugStruct *x) {
603    x-&gt;mu.ReaderLock();
604    x-&gt;mu2.Lock();
605    x-&gt;have_reader_lock = true;
606    x-&gt;mu2.Await(absl::Condition(&amp;x-&gt;complete));
607    x-&gt;mu2.Unlock();
608    x-&gt;mu.ReaderUnlock();
609    x-&gt;mu.Lock();
610    x-&gt;done--;
611    x-&gt;mu.Unlock();
612  }
613  TEST(Mutex, MutexReaderDecrementBug) ABSL_NO_THREAD_SAFETY_ANALYSIS {
614    ReaderDecrementBugStruct x;
615    x.cond = false;
616    x.waiting_on_cond = false;
617    x.have_reader_lock = false;
618    x.complete = false;
619    x.done = 2;  
620    std::thread thread1(WaitForCond, &amp;x);
621    x.mu2.LockWhen(absl::Condition(&amp;x.waiting_on_cond));
622    x.mu2.Unlock();
623    std::thread thread2(GetReadLock, &amp;x);
624    x.mu2.LockWhen(absl::Condition(&amp;x.have_reader_lock));
625    x.mu2.Unlock();
626    x.mu.ReaderLock();
627    x.mu.ReaderUnlock();
628    x.mu.AssertReaderHeld();
629    x.mu2.Lock();
630    x.complete = true;
631    x.mu2.Unlock();
632    x.mu.Lock();
633    x.cond = true;
634    x.mu.Await(absl::Condition(&amp;AllDone, &amp;x));
635    x.mu.Unlock();
636    thread1.join();
637    thread2.join();
638  }
639  #endif  
640  #ifdef ABSL_HAVE_THREAD_SANITIZER
641  TEST(Mutex, DISABLED_LockedMutexDestructionBug) ABSL_NO_THREAD_SAFETY_ANALYSIS {
642  #else
643  TEST(Mutex, LockedMutexDestructionBug) ABSL_NO_THREAD_SAFETY_ANALYSIS {
644  #endif
645    for (int i = 0; i != 10; i++) {
646      const int kNumLocks = 10;
647      auto mu = absl::make_unique&lt;absl::Mutex[]&gt;(kNumLocks);
648      for (int j = 0; j != kNumLocks; j++) {
649        if ((j % 2) == 0) {
650          mu[j].WriterLock();
651        } else {
652          mu[j].ReaderLock();
653        }
654      }
655    }
656  }
657  bool Equals42(int *p) { return *p == 42; }
658  bool Equals43(int *p) { return *p == 43; }
659  bool ConstEquals42(const int *p) { return *p == 42; }
660  bool ConstEquals43(const int *p) { return *p == 43; }
661  template &lt;typename T&gt;
662  bool TemplateEquals42(T *p) {
663    return *p == 42;
664  }
665  template &lt;typename T&gt;
666  bool TemplateEquals43(T *p) {
667    return *p == 43;
668  }
669  TEST(Mutex, FunctionPointerCondition) {
670    int x = 42;
671    const int const_x = 42;
672    EXPECT_TRUE(absl::Condition(Equals42, &amp;x).Eval());
673    EXPECT_FALSE(absl::Condition(Equals43, &amp;x).Eval());
674    EXPECT_TRUE(absl::Condition(ConstEquals42, &amp;x).Eval());
675    EXPECT_FALSE(absl::Condition(ConstEquals43, &amp;x).Eval());
676    EXPECT_TRUE(absl::Condition(ConstEquals42, &amp;const_x).Eval());
677    EXPECT_FALSE(absl::Condition(ConstEquals43, &amp;const_x).Eval());
678    EXPECT_TRUE(absl::Condition(TemplateEquals42, &amp;x).Eval());
679    EXPECT_FALSE(absl::Condition(TemplateEquals43, &amp;x).Eval());
680    EXPECT_TRUE(absl::Condition(TemplateEquals42, &amp;const_x).Eval());
681    EXPECT_FALSE(absl::Condition(TemplateEquals43, &amp;const_x).Eval());
682    EXPECT_FALSE((std::is_constructible&lt;absl::Condition, decltype(Equals42),
683                                        decltype(&amp;const_x)&gt;::value));
684    EXPECT_TRUE((std::is_constructible&lt;absl::Condition, decltype(ConstEquals42),
685                                       decltype(&amp;const_x)&gt;::value));
686  }
687  struct Base {
688    explicit Base(int v) : value(v) {}
689    int value;
690  };
691  struct Derived : Base {
692    explicit Derived(int v) : Base(v) {}
693  };
694  bool BaseEquals42(Base *p) { return p-&gt;value == 42; }
695  bool BaseEquals43(Base *p) { return p-&gt;value == 43; }
696  bool ConstBaseEquals42(const Base *p) { return p-&gt;value == 42; }
697  bool ConstBaseEquals43(const Base *p) { return p-&gt;value == 43; }
698  TEST(Mutex, FunctionPointerConditionWithDerivedToBaseConversion) {
699    Derived derived(42);
700    const Derived const_derived(42);
701    EXPECT_TRUE(absl::Condition(BaseEquals42, &amp;derived).Eval());
702    EXPECT_FALSE(absl::Condition(BaseEquals43, &amp;derived).Eval());
703    EXPECT_TRUE(absl::Condition(ConstBaseEquals42, &amp;derived).Eval());
704    EXPECT_FALSE(absl::Condition(ConstBaseEquals43, &amp;derived).Eval());
705    EXPECT_TRUE(absl::Condition(ConstBaseEquals42, &amp;const_derived).Eval());
706    EXPECT_FALSE(absl::Condition(ConstBaseEquals43, &amp;const_derived).Eval());
707    EXPECT_TRUE(absl::Condition(ConstBaseEquals42, &amp;const_derived).Eval());
708    EXPECT_FALSE(absl::Condition(ConstBaseEquals43, &amp;const_derived).Eval());
709    bool (*derived_pred)(const Derived *) = [](const Derived *) { return true; };
710    EXPECT_FALSE((std::is_constructible&lt;absl::Condition, decltype(derived_pred),
711                                        Base *&gt;::value));
712    EXPECT_FALSE((std::is_constructible&lt;absl::Condition, decltype(derived_pred),
713                                        const Base *&gt;::value));
714    EXPECT_TRUE((std::is_constructible&lt;absl::Condition, decltype(derived_pred),
715                                       Derived *&gt;::value));
716    EXPECT_TRUE((std::is_constructible&lt;absl::Condition, decltype(derived_pred),
717                                       const Derived *&gt;::value));
718  }
719  struct True {
720    template &lt;class... Args&gt;
721    bool operator()(Args...) const {
722      return true;
723    }
724  };
725  struct DerivedTrue : True {};
726  TEST(Mutex, FunctorCondition) {
727    {  
728      True f;
729      EXPECT_TRUE(absl::Condition(&amp;f).Eval());
730    }
731    {  
732      DerivedTrue g;
733      EXPECT_TRUE(absl::Condition(&amp;g).Eval());
734    }
735    {  
736      int value = 3;
737      auto is_zero = [&amp;value] { return value == 0; };
738      absl::Condition c(&amp;is_zero);
739      EXPECT_FALSE(c.Eval());
740      value = 0;
741      EXPECT_TRUE(c.Eval());
742    }
743    {  
744      int value = 0;
745      auto is_positive = std::bind(std::less&lt;int&gt;(), 0, std::cref(value));
746      absl::Condition c(&amp;is_positive);
747      EXPECT_FALSE(c.Eval());
748      value = 1;
749      EXPECT_TRUE(c.Eval());
750    }
751    {  
752      int value = 3;
753      std::function&lt;bool()&gt; is_zero = [&amp;value] { return value == 0; };
754      absl::Condition c(&amp;is_zero);
755      EXPECT_FALSE(c.Eval());
756      value = 0;
757      EXPECT_TRUE(c.Eval());
758    }
759  }
760  static void ReaderForReaderOnCondVar(absl::Mutex *mu, absl::CondVar *cv,
761                                       int *running) {
762    std::random_device dev;
763    std::mt19937 gen(dev());
764    std::uniform_int_distribution&lt;int&gt; random_millis(0, 15);
765    mu-&gt;ReaderLock();
766    while (*running == 3) {
767      absl::SleepFor(absl::Milliseconds(random_millis(gen)));
768      cv-&gt;WaitWithTimeout(mu, absl::Milliseconds(random_millis(gen)));
769    }
770    mu-&gt;ReaderUnlock();
771    mu-&gt;Lock();
772    (*running)--;
773    mu-&gt;Unlock();
774  }
775  static bool IntIsZero(int *x) { return *x == 0; }
776  TEST(Mutex, TestReaderOnCondVar) {
777    auto tp = CreateDefaultPool();
778    absl::Mutex mu;
779    absl::CondVar cv;
780    int running = 3;
781    tp-&gt;Schedule(std::bind(&amp;ReaderForReaderOnCondVar, &amp;mu, &amp;cv, &amp;running));
782    tp-&gt;Schedule(std::bind(&amp;ReaderForReaderOnCondVar, &amp;mu, &amp;cv, &amp;running));
783    absl::SleepFor(absl::Seconds(2));
784    mu.Lock();
785    running--;
786    mu.Await(absl::Condition(&amp;IntIsZero, &amp;running));
787    mu.Unlock();
788  }
789  struct AcquireFromConditionStruct {
790    absl::Mutex mu0;   
791    int value;         
792    bool done;         
793    absl::Mutex mu1;   
794    absl::CondVar cv;  
795  };
796  static bool ConditionWithAcquire(AcquireFromConditionStruct *x) {
797    x-&gt;value++;  
798    if (x-&gt;value == 2 || x-&gt;value == 3) {
799      bool always_false = false;
800      x-&gt;mu1.LockWhenWithTimeout(absl::Condition(&amp;always_false),
801                                 absl::Milliseconds(100));
802      x-&gt;mu1.Unlock();
803    }
804    CHECK_LT(x-&gt;value, 4) &lt;&lt; &quot;should not be invoked a fourth time&quot;;
805    return x-&gt;value == 2 || x-&gt;value == 3;
806  }
807  static void WaitForCond2(AcquireFromConditionStruct *x) {
808    x-&gt;mu0.LockWhen(absl::Condition(&amp;ConditionWithAcquire, x));
809    x-&gt;done = true;
810    x-&gt;mu0.Unlock();
811  }
812  TEST(Mutex, AcquireFromCondition) {
813    auto tp = CreateDefaultPool();
814    AcquireFromConditionStruct x;
815    x.value = 0;
816    x.done = false;
817    tp-&gt;Schedule(
818        std::bind(&amp;WaitForCond2, &amp;x));  
819    absl::SleepFor(absl::Milliseconds(500));  
820    x.mu0.Lock();
821    x.cv.WaitWithTimeout(&amp;x.mu0, absl::Milliseconds(500));  
822    x.mu0.Unlock();
823    x.mu0.LockWhen(absl::Condition(&amp;x.done));
824    x.mu0.Unlock();
825  }
826  TEST(Mutex, DeadlockDetector) {
827    absl::SetMutexDeadlockDetectionMode(absl::OnDeadlockCycle::kAbort);
828    absl::Mutex m1;
829    absl::Mutex m2;
830    absl::Mutex m3;
831    absl::Mutex m4;
832    m1.Lock();  
833    m2.Lock();  
834    m3.Lock();  
835    m3.Unlock();
836    m2.Unlock();
837    m1.ForgetDeadlockInfo();  
838    m2.Lock();                
839    m3.Lock();                
840    m4.Lock();                
841    m3.Unlock();
842    m2.Unlock();
843    m4.Unlock();
844    m1.Unlock();
845  }
846  class ScopedDisableBazelTestWarnings {
847   public:
848    ScopedDisableBazelTestWarnings() {
849  #ifdef _WIN32
850      char file[MAX_PATH];
851      if (GetEnvironmentVariableA(kVarName, file, sizeof(file)) &lt; sizeof(file)) {
852        warnings_output_file_ = file;
853        SetEnvironmentVariableA(kVarName, nullptr);
854      }
855  #else
856      const char *file = getenv(kVarName);
857      if (file != nullptr) {
858        warnings_output_file_ = file;
859        unsetenv(kVarName);
860      }
861  #endif
862    }
863    ~ScopedDisableBazelTestWarnings() {
864      if (!warnings_output_file_.empty()) {
865  #ifdef _WIN32
866        SetEnvironmentVariableA(kVarName, warnings_output_file_.c_str());
867  #else
868        setenv(kVarName, warnings_output_file_.c_str(), 0);
869  #endif
870      }
871    }
872   private:
873    static const char kVarName[];
874    std::string warnings_output_file_;
875  };
876  const char ScopedDisableBazelTestWarnings::kVarName[] =
877      &quot;TEST_WARNINGS_OUTPUT_FILE&quot;;
878  #ifdef ABSL_HAVE_THREAD_SANITIZER
879  TEST(Mutex, DISABLED_DeadlockDetectorBazelWarning) {
880  #else
881  TEST(Mutex, DeadlockDetectorBazelWarning) {
882  #endif
883    absl::SetMutexDeadlockDetectionMode(absl::OnDeadlockCycle::kReport);
884    ScopedDisableBazelTestWarnings disable_bazel_test_warnings;
885    absl::Mutex mu0;
886    absl::Mutex mu1;
887    bool got_mu0 = mu0.TryLock();
888    mu1.Lock();  
889    if (got_mu0) {
890      mu0.Unlock();
891    }
892    if (mu0.TryLock()) {  
893      mu0.Unlock();
894    }
895    mu0.Lock();  
896    mu0.Unlock();
897    mu1.Unlock();
898    absl::SetMutexDeadlockDetectionMode(absl::OnDeadlockCycle::kAbort);
899  }
900  TEST(Mutex, DeadlockDetectorLongCycle) {
901    absl::SetMutexDeadlockDetectionMode(absl::OnDeadlockCycle::kReport);
902    ScopedDisableBazelTestWarnings disable_bazel_test_warnings;
903    std::vector&lt;absl::Mutex&gt; mutex(100);
904    for (size_t i = 0; i != mutex.size(); i++) {
905      mutex[i].Lock();
906      mutex[(i + 1) % mutex.size()].Lock();
907      mutex[i].Unlock();
908      mutex[(i + 1) % mutex.size()].Unlock();
909    }
910    absl::SetMutexDeadlockDetectionMode(absl::OnDeadlockCycle::kAbort);
911  }
912  TEST(Mutex, DeadlockDetectorStressTest) ABSL_NO_THREAD_SAFETY_ANALYSIS {
913    const int n_locks = 1 &lt;&lt; 17;
914    auto array_of_locks = absl::make_unique&lt;absl::Mutex[]&gt;(n_locks);
915    for (int i = 0; i &lt; n_locks; i++) {
916      int end = std::min(n_locks, i + 5);
917      for (int j = i; j &lt; end; j++) {
918        array_of_locks[j].Lock();
919      }
920      for (int j = i; j &lt; end; j++) {
921        array_of_locks[j].Unlock();
922      }
923    }
924  }
925  #ifdef ABSL_HAVE_THREAD_SANITIZER
926  TEST(Mutex, DISABLED_DeadlockIdBug) ABSL_NO_THREAD_SAFETY_ANALYSIS {
927  #else
928  TEST(Mutex, DeadlockIdBug) ABSL_NO_THREAD_SAFETY_ANALYSIS {
929  #endif
930    absl::SetMutexDeadlockDetectionMode(absl::OnDeadlockCycle::kAbort);
931    absl::Mutex *a = new absl::Mutex;
932    absl::Mutex b, c;
933    a-&gt;Lock();
934    b.Lock();
935    b.Unlock();
936    absl::SetMutexDeadlockDetectionMode(absl::OnDeadlockCycle::kIgnore);
937    delete a;
938    absl::SetMutexDeadlockDetectionMode(absl::OnDeadlockCycle::kAbort);
939    c.Lock();
940    c.Unlock();
941  }
942  static absl::Duration TimeoutTestAllowedSchedulingDelay() {
943    return absl::Milliseconds(150);
944  }
945  ABSL_MUST_USE_RESULT
946  static bool DelayIsWithinBounds(absl::Duration expected_delay,
947                                  absl::Duration actual_delay) {
948    bool pass = true;
949    if (actual_delay &lt; expected_delay) {
950      LOG(WARNING) &lt;&lt; &quot;Actual delay &quot; &lt;&lt; actual_delay
951                   &lt;&lt; &quot; was too short, expected &quot; &lt;&lt; expected_delay
952                   &lt;&lt; &quot; (difference &quot; &lt;&lt; actual_delay - expected_delay &lt;&lt; &quot;)&quot;;
953      pass = false;
954    }
955    absl::Duration tolerance = expected_delay &lt;= absl::ZeroDuration()
956                                   ? absl::Milliseconds(10)
957                                   : TimeoutTestAllowedSchedulingDelay();
958    if (actual_delay &gt; expected_delay + tolerance) {
959      LOG(WARNING) &lt;&lt; &quot;Actual delay &quot; &lt;&lt; actual_delay
960                   &lt;&lt; &quot; was too long, expected &quot; &lt;&lt; expected_delay
961                   &lt;&lt; &quot; (difference &quot; &lt;&lt; actual_delay - expected_delay &lt;&lt; &quot;)&quot;;
962      pass = false;
963    }
964    return pass;
965  }
966  struct TimeoutTestParam {
967    const char *from_file;
968    int from_line;
969    bool use_absolute_deadline;
970    absl::Duration wait_timeout;
971    absl::Duration satisfy_condition_delay;
972    bool expected_result;
973    absl::Duration expected_delay;
974  };
975  std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const TimeoutTestParam &amp;param) {
976    return os &lt;&lt; &quot;from: &quot; &lt;&lt; param.from_file &lt;&lt; &quot;:&quot; &lt;&lt; param.from_line
977              &lt;&lt; &quot; use_absolute_deadline: &quot;
978              &lt;&lt; (param.use_absolute_deadline ? &quot;true&quot; : &quot;false&quot;)
979              &lt;&lt; &quot; wait_timeout: &quot; &lt;&lt; param.wait_timeout
980              &lt;&lt; &quot; satisfy_condition_delay: &quot; &lt;&lt; param.satisfy_condition_delay
981              &lt;&lt; &quot; expected_result: &quot;
982              &lt;&lt; (param.expected_result ? &quot;true&quot; : &quot;false&quot;)
983              &lt;&lt; &quot; expected_delay: &quot; &lt;&lt; param.expected_delay;
984  }
985  static void RunAfterDelay(absl::Duration delay,
986                            absl::synchronization_internal::ThreadPool *pool,
987                            const std::function&lt;void()&gt; &amp;callback) {
988    if (delay &lt;= absl::ZeroDuration()) {
989      callback();  
990    } else if (delay != absl::InfiniteDuration()) {
991      ScheduleAfter(pool, delay, callback);
992    }
993  }
994  class TimeoutTest : public ::testing::Test,
995                      public ::testing::WithParamInterface&lt;TimeoutTestParam&gt; {};
996  std::vector&lt;TimeoutTestParam&gt; MakeTimeoutTestParamValues() {
997    const absl::Duration finite = 3 * TimeoutTestAllowedSchedulingDelay();
998    const absl::Duration never = absl::InfiniteDuration();
999    const absl::Duration negative = -absl::InfiniteDuration();
1000    const absl::Duration immediate = absl::ZeroDuration();
1001    std::vector&lt;TimeoutTestParam&gt; values;
1002    for (bool use_absolute_deadline : {false, true}) {
1003      values.push_back(TimeoutTestParam{
1004          __FILE__, __LINE__, use_absolute_deadline,
1005          negative,   
1006          immediate,  
1007          true,       
1008          immediate,  
1009      });
1010      values.push_back(TimeoutTestParam{
1011          __FILE__, __LINE__, use_absolute_deadline,
1012          negative,  
1013          finite,    
1014          false,     
1015          immediate  
1016      });
1017      values.push_back(TimeoutTestParam{
1018          __FILE__, __LINE__, use_absolute_deadline,
1019          negative,  
1020          never,     
1021          false,     
1022          immediate  
1023      });
1024      values.push_back(TimeoutTestParam{
1025          __FILE__, __LINE__, use_absolute_deadline,
1026          never,      
1027          immediate,  
1028          true,       
1029          immediate   
1030      });
1031      values.push_back(TimeoutTestParam{
1032          __FILE__, __LINE__, use_absolute_deadline,
1033          never,   
1034          finite,  
1035          true,    
1036          finite,  
1037      });
1038      values.push_back(TimeoutTestParam{
1039          __FILE__, __LINE__, use_absolute_deadline,
1040          never,      
1041          immediate,  
1042          true,       
1043          immediate   
1044      });
1045      values.push_back(TimeoutTestParam{
1046          __FILE__, __LINE__, use_absolute_deadline,
1047          finite * 2,  
1048          finite,      
1049          true,        
1050          finite       
1051      });
1052      values.push_back(TimeoutTestParam{
1053          __FILE__, __LINE__, use_absolute_deadline,
1054          finite,      
1055          finite * 2,  
1056          false,       
1057          finite       
1058      });
1059      values.push_back(TimeoutTestParam{
1060          __FILE__, __LINE__, use_absolute_deadline,
1061          finite,  
1062          never,   
1063          false,   
1064          finite   
1065      });
1066    }
1067    return values;
1068  }
1069  INSTANTIATE_TEST_SUITE_P(All, TimeoutTest,
1070                           testing::ValuesIn(MakeTimeoutTestParamValues()));
1071  TEST_P(TimeoutTest, Await) {
1072    const TimeoutTestParam params = GetParam();
1073    LOG(INFO) &lt;&lt; &quot;Params: &quot; &lt;&lt; params;
1074    for (int attempt = 1;; ++attempt) {
1075      LOG(INFO) &lt;&lt; &quot;Attempt &quot; &lt;&lt; attempt;
1076      absl::Mutex mu;
1077      bool value = false;  
1078      std::unique_ptr&lt;absl::synchronization_internal::ThreadPool&gt; pool =
1079          CreateDefaultPool();
1080      RunAfterDelay(params.satisfy_condition_delay, pool.get(), [&amp;] {
1081        absl::MutexLock l(&amp;mu);
1082        value = true;
1083      });
1084      absl::MutexLock lock(&amp;mu);
1085      absl::Time start_time = absl::Now();
1086      absl::Condition cond(&amp;value);
1087      bool result =
1088          params.use_absolute_deadline
1089              ? mu.AwaitWithDeadline(cond, start_time + params.wait_timeout)
1090              : mu.AwaitWithTimeout(cond, params.wait_timeout);
1091      if (DelayIsWithinBounds(params.expected_delay, absl::Now() - start_time)) {
1092        EXPECT_EQ(params.expected_result, result);
1093        break;
1094      }
1095    }
1096  }
1097  TEST_P(TimeoutTest, LockWhen) {
1098    const TimeoutTestParam params = GetParam();
1099    LOG(INFO) &lt;&lt; &quot;Params: &quot; &lt;&lt; params;
1100    for (int attempt = 1;; ++attempt) {
1101      LOG(INFO) &lt;&lt; &quot;Attempt &quot; &lt;&lt; attempt;
1102      absl::Mutex mu;
1103      bool value = false;  
1104      std::unique_ptr&lt;absl::synchronization_internal::ThreadPool&gt; pool =
1105          CreateDefaultPool();
1106      RunAfterDelay(params.satisfy_condition_delay, pool.get(), [&amp;] {
1107        absl::MutexLock l(&amp;mu);
1108        value = true;
1109      });
1110      absl::Time start_time = absl::Now();
1111      absl::Condition cond(&amp;value);
1112      bool result =
1113          params.use_absolute_deadline
1114              ? mu.LockWhenWithDeadline(cond, start_time + params.wait_timeout)
1115              : mu.LockWhenWithTimeout(cond, params.wait_timeout);
1116      mu.Unlock();
1117      if (DelayIsWithinBounds(params.expected_delay, absl::Now() - start_time)) {
1118        EXPECT_EQ(params.expected_result, result);
1119        break;
1120      }
1121    }
1122  }
1123  TEST_P(TimeoutTest, ReaderLockWhen) {
1124    const TimeoutTestParam params = GetParam();
1125    LOG(INFO) &lt;&lt; &quot;Params: &quot; &lt;&lt; params;
1126    for (int attempt = 0;; ++attempt) {
1127      LOG(INFO) &lt;&lt; &quot;Attempt &quot; &lt;&lt; attempt;
1128      absl::Mutex mu;
1129      bool value = false;  
1130      std::unique_ptr&lt;absl::synchronization_internal::ThreadPool&gt; pool =
1131          CreateDefaultPool();
1132      RunAfterDelay(params.satisfy_condition_delay, pool.get(), [&amp;] {
1133        absl::MutexLock l(&amp;mu);
1134        value = true;
1135      });
1136      absl::Time start_time = absl::Now();
1137      bool result =
1138          params.use_absolute_deadline
1139              ? mu.ReaderLockWhenWithDeadline(absl::Condition(&amp;value),
1140                                              start_time + params.wait_timeout)
1141              : mu.ReaderLockWhenWithTimeout(absl::Condition(&amp;value),
1142                                             params.wait_timeout);
1143      mu.ReaderUnlock();
1144      if (DelayIsWithinBounds(params.expected_delay, absl::Now() - start_time)) {
1145        EXPECT_EQ(params.expected_result, result);
1146        break;
1147      }
1148    }
1149  }
1150  TEST_P(TimeoutTest, Wait) {
1151    const TimeoutTestParam params = GetParam();
1152    LOG(INFO) &lt;&lt; &quot;Params: &quot; &lt;&lt; params;
1153    for (int attempt = 0;; ++attempt) {
1154      LOG(INFO) &lt;&lt; &quot;Attempt &quot; &lt;&lt; attempt;
1155      absl::Mutex mu;
1156      bool value = false;  
1157      absl::CondVar cv;    
1158      std::unique_ptr&lt;absl::synchronization_internal::ThreadPool&gt; pool =
1159          CreateDefaultPool();
1160      RunAfterDelay(params.satisfy_condition_delay, pool.get(), [&amp;] {
1161        absl::MutexLock l(&amp;mu);
1162        value = true;
1163        cv.Signal();
1164      });
1165      absl::MutexLock lock(&amp;mu);
1166      absl::Time start_time = absl::Now();
1167      absl::Duration timeout = params.wait_timeout;
1168      absl::Time deadline = start_time + timeout;
1169      while (!value) {
1170        if (params.use_absolute_deadline ? cv.WaitWithDeadline(&amp;mu, deadline)
1171                                         : cv.WaitWithTimeout(&amp;mu, timeout)) {
1172          break;  
1173        }
1174        timeout = deadline - absl::Now();  
1175      }
1176      bool result = value;  
1177      if (DelayIsWithinBounds(params.expected_delay, absl::Now() - start_time)) {
1178        EXPECT_EQ(params.expected_result, result);
1179        break;
1180      }
1181    }
1182  }
1183  TEST(Mutex, Logging) {
1184    absl::Mutex logged_mutex;
1185    logged_mutex.EnableDebugLog(&quot;fido_mutex&quot;);
1186    absl::CondVar logged_cv;
1187    logged_cv.EnableDebugLog(&quot;rover_cv&quot;);
1188    logged_mutex.Lock();
1189    logged_cv.WaitWithTimeout(&amp;logged_mutex, absl::Milliseconds(20));
1190    logged_mutex.Unlock();
1191    logged_mutex.ReaderLock();
1192    logged_mutex.ReaderUnlock();
1193    logged_mutex.Lock();
1194    logged_mutex.Unlock();
1195    logged_cv.Signal();
1196    logged_cv.SignalAll();
1197  }
1198  static std::vector&lt;int&gt; AllThreadCountValues() {
1199    if (kExtendedTest) {
1200      return {2, 4, 8, 10, 16, 20, 24, 30, 32};
1201    }
1202    return {2, 4, 10};
1203  }
1204  class MutexVariableThreadCountTest : public ::testing::TestWithParam&lt;int&gt; {};
1205  INSTANTIATE_TEST_SUITE_P(ThreadCounts, MutexVariableThreadCountTest,
1206                           ::testing::ValuesIn(AllThreadCountValues()),
1207                           ::testing::PrintToStringParamName());
1208  static int ScaleIterations(int x) {
1209  #if defined(ABSL_MUTEX_READER_LOCK_IS_EXCLUSIVE)
1210    return x / 10;
1211  #else
1212    return x;
1213  #endif
1214  }
1215  TEST_P(MutexVariableThreadCountTest, Mutex) {
1216    int threads = GetParam();
1217    int iterations = ScaleIterations(10000000) / threads;
1218    int operations = threads * iterations;
1219    EXPECT_EQ(RunTest(&amp;TestMu, threads, iterations, operations), operations);
1220  #if !defined(ABSL_MUTEX_ENABLE_INVARIANT_DEBUGGING_NOT_IMPLEMENTED)
1221    iterations = std::min(iterations, 10);
1222    operations = threads * iterations;
1223    EXPECT_EQ(RunTestWithInvariantDebugging(&amp;TestMu, threads, iterations,
1224                                            operations, CheckSumG0G1),
1225              operations);
1226  #endif
1227  }
1228  TEST_P(MutexVariableThreadCountTest, Try) {
1229    int threads = GetParam();
1230    int iterations = 1000000 / threads;
1231    int operations = iterations * threads;
1232    EXPECT_EQ(RunTest(&amp;TestTry, threads, iterations, operations), operations);
1233  #if !defined(ABSL_MUTEX_ENABLE_INVARIANT_DEBUGGING_NOT_IMPLEMENTED)
1234    iterations = std::min(iterations, 10);
1235    operations = threads * iterations;
1236    EXPECT_EQ(RunTestWithInvariantDebugging(&amp;TestTry, threads, iterations,
1237                                            operations, CheckSumG0G1),
1238              operations);
1239  #endif
1240  }
1241  TEST_P(MutexVariableThreadCountTest, R20ms) {
1242    int threads = GetParam();
1243    int iterations = 100;
1244    int operations = iterations * threads;
1245    EXPECT_EQ(RunTest(&amp;TestR20ms, threads, iterations, operations), 0);
1246  }
1247  TEST_P(MutexVariableThreadCountTest, RW) {
1248    int threads = GetParam();
1249    int iterations = ScaleIterations(20000000) / threads;
1250    int operations = iterations * threads;
1251    EXPECT_EQ(RunTest(&amp;TestRW, threads, iterations, operations), operations / 2);
1252  #if !defined(ABSL_MUTEX_ENABLE_INVARIANT_DEBUGGING_NOT_IMPLEMENTED)
1253    iterations = std::min(iterations, 10);
1254    operations = threads * iterations;
1255    EXPECT_EQ(RunTestWithInvariantDebugging(&amp;TestRW, threads, iterations,
1256                                            operations, CheckSumG0G1),
1257              operations / 2);
1258  #endif
1259  }
1260  TEST_P(MutexVariableThreadCountTest, Await) {
1261    int threads = GetParam();
1262    int iterations = ScaleIterations(500000);
1263    int operations = iterations;
1264    EXPECT_EQ(RunTest(&amp;TestAwait, threads, iterations, operations), operations);
1265  }
1266  TEST_P(MutexVariableThreadCountTest, SignalAll) {
1267    int threads = GetParam();
1268    int iterations = 200000 / threads;
1269    int operations = iterations;
1270    EXPECT_EQ(RunTest(&amp;TestSignalAll, threads, iterations, operations),
1271              operations);
1272  }
1273  TEST(Mutex, Signal) {
1274    int threads = 2;  
1275    int iterations = 200000;
1276    int operations = iterations;
1277    EXPECT_EQ(RunTest(&amp;TestSignal, threads, iterations, operations), operations);
1278  }
1279  TEST(Mutex, Timed) {
1280    int threads = 10;  
1281    int iterations = 1000;
1282    int operations = iterations;
1283    EXPECT_EQ(RunTest(&amp;TestCVTimeout, threads, iterations, operations),
1284              operations);
1285  }
1286  TEST(Mutex, CVTime) {
1287    int threads = 10;  
1288    int iterations = 1;
1289    EXPECT_EQ(RunTest(&amp;TestCVTime, threads, iterations, 1), threads * iterations);
1290  }
1291  TEST(Mutex, MuTime) {
1292    int threads = 10;  
1293    int iterations = 1;
1294    EXPECT_EQ(RunTest(&amp;TestMuTime, threads, iterations, 1), threads * iterations);
1295  }
1296  TEST(Mutex, SignalExitedThread) {
1297  #if defined(__wasm__) || defined(__asmjs__)
1298    constexpr int kThreads = 1;  
1299  #else
1300    constexpr int kThreads = 100;
1301  #endif
1302    std::vector&lt;std::thread&gt; top;
1303    for (unsigned i = 0; i &lt; 2 * std::thread::hardware_concurrency(); i++) {
1304      top.emplace_back([&amp;]() {
1305        for (int i = 0; i &lt; kThreads; i++) {
1306          absl::Mutex mu;
1307          std::thread t([&amp;]() {
1308            mu.Lock();
1309            mu.Unlock();
1310          });
1311          mu.Lock();
1312          mu.Unlock();
1313          t.join();
1314        }
1315      });
1316    }
1317    for (auto &amp;th : top) th.join();
1318  }
1319  TEST(Mutex, WriterPriority) {
1320    absl::Mutex mu;
1321    bool wrote = false;
1322    std::atomic&lt;bool&gt; saw_wrote{false};
1323    auto readfunc = [&amp;]() {
1324      for (size_t i = 0; i &lt; 10; ++i) {
1325        absl::ReaderMutexLock lock(&amp;mu);
1326        if (wrote) {
1327          saw_wrote = true;
1328          break;
1329        }
1330        absl::SleepFor(absl::Seconds(1));
1331      }
1332    };
1333    std::thread t1(readfunc);
1334    absl::SleepFor(absl::Milliseconds(500));
1335    std::thread t2(readfunc);
1336    std::thread t3([&amp;]() {
1337      absl::MutexLock lock(&amp;mu);
1338      wrote = true;
1339    });
1340    t1.join();
1341    t2.join();
1342    t3.join();
1343    EXPECT_TRUE(saw_wrote.load());
1344  }
1345  TEST(Mutex, LockWhenWithTimeoutResult) {
1346    absl::Mutex mu;
1347    const bool kAlwaysTrue = true, kAlwaysFalse = false;
1348    const absl::Condition kTrueCond(&amp;kAlwaysTrue), kFalseCond(&amp;kAlwaysFalse);
1349    EXPECT_TRUE(mu.LockWhenWithTimeout(kTrueCond, absl::Milliseconds(1)));
1350    mu.Unlock();
1351    EXPECT_FALSE(mu.LockWhenWithTimeout(kFalseCond, absl::Milliseconds(1)));
1352    EXPECT_TRUE(mu.AwaitWithTimeout(kTrueCond, absl::Milliseconds(1)));
1353    EXPECT_FALSE(mu.AwaitWithTimeout(kFalseCond, absl::Milliseconds(1)));
1354    std::thread th1([&amp;]() {
1355      EXPECT_TRUE(mu.LockWhenWithTimeout(kTrueCond, absl::Milliseconds(1)));
1356      mu.Unlock();
1357    });
1358    std::thread th2([&amp;]() {
1359      EXPECT_FALSE(mu.LockWhenWithTimeout(kFalseCond, absl::Milliseconds(1)));
1360      mu.Unlock();
1361    });
1362    absl::SleepFor(absl::Milliseconds(100));
1363    mu.Unlock();
1364    th1.join();
1365    th2.join();
1366  }
1367  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-mutex_test.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-mutex_test.cc</div>
                </div>
                <div class="column column_space"><pre><code>368      state.release_mu.Unlock();
369    });
370    state.barrier_mu.LockWhen(absl::Condition(&amp;state.barrier));
371    state.barrier_mu.Unlock();
372    state.release_mu.Lock();
373    state.release = true;
374    state.released_cv.Wait(&amp;state.release_mu);
</pre></code></div>
                <div class="column column_space"><pre><code>393      state.release_mu.Unlock();
394    });
395    state.barrier_mu.LockWhen(absl::Condition(&amp;state.barrier));
396    state.barrier_mu.Unlock();
397    state.release_mu.Lock();
398    state.release = true;
399    EXPECT_TRUE(
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    