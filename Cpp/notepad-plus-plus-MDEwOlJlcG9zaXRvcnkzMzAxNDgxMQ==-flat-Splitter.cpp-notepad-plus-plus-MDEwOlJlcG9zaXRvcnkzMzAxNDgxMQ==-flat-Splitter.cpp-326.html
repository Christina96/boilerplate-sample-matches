
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 17, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-Splitter.cpp</h3>
            <pre><code>1  #include &lt;iostream&gt;
2  #include &lt;stdexcept&gt;
3  #include &lt;windows.h&gt;
4  #include &quot;Splitter.h&quot;
5  #include &quot;Parameters.h&quot;
6  #include &quot;NppDarkMode.h&quot;
7  bool Splitter::_isHorizontalRegistered = false;
8  bool Splitter::_isVerticalRegistered = false;
9  bool Splitter::_isHorizontalFixedRegistered = false;
10  bool Splitter::_isVerticalFixedRegistered = false;
11  #define SPLITTER_SIZE 8
12  void Splitter::init( HINSTANCE hInst, HWND hPere, int splitterSize, double iSplitRatio, DWORD dwFlags)
13  {
14  	if (hPere == NULL)
15  		throw std::runtime_error(&quot;Splitter::init : Parameter hPere is null&quot;);
16  	if (iSplitRatio &lt; 0)
17  		throw std::runtime_error(&quot;Splitter::init : Parameter iSplitRatio shoulds be 0 &lt; ratio &lt; 100&quot;);
18  	Window::init(hInst, hPere);
19  	_splitterSize = splitterSize;
20  	WNDCLASSEX wcex;
21  	DWORD dwExStyle = 0L;
22  	DWORD dwStyle   = WS_CHILD | WS_VISIBLE;
23  	_hParent = hPere;
24  	_dwFlags = dwFlags;
25  	if (_dwFlags &amp; SV_FIXED)
26  	{
27  		_isFixed = true;
28  	}
29  	else
30  	{
31  		if (iSplitRatio &gt;= 100)
32  		{
33  			throw std::runtime_error(&quot;Splitter::init : Parameter iSplitRatio shoulds be 0 &lt; ratio &lt; 100&quot;);
34  		}
35  	}
36  	_splitPercent = iSplitRatio;
37  	wcex.cbSize			= sizeof(WNDCLASSEX);
38  	wcex.style			= CS_HREDRAW | CS_VREDRAW;
39  	wcex.lpfnWndProc	= (WNDPROC)staticWndProc;
40  	wcex.cbClsExtra		= 0;
41  	wcex.cbWndExtra		= 0;
42  	wcex.hInstance		= _hInst;
43  	wcex.hIcon			= NULL;
44  	::GetClientRect(_hParent, &amp;_rect);
45  	if (_dwFlags &amp; SV_HORIZONTAL) 
46  	{
47  		_rect.top  = (LONG)((_rect.bottom * _splitPercent)/100) - _splitterSize / 2;
48  		_rect.left = 0;
49  		_rect.bottom = _splitterSize;
50  	}
51  	else 
52  	{
53  		_rect.left = (LONG)((_rect.right * _splitPercent)/100) - _splitterSize / 2;
54  		_rect.right = _splitterSize;
55  	}
56  	if (!_isFixed)
57  	{
58  		if ((_dwFlags &amp; SV_ENABLERDBLCLK) || (_dwFlags &amp; SV_ENABLELDBLCLK))
59  		{
60  			wcex.style = wcex.style | CS_DBLCLKS;
61  		}
62  	}
63  	if (_isFixed)
64  	{
65  		wcex.hCursor		= ::LoadCursor(NULL, IDC_ARROW);
66  		if (_dwFlags &amp; SV_HORIZONTAL)
67  			wcex.lpszClassName	= TEXT(&quot;fxdnsspliter&quot;);
68  		else
69  			wcex.lpszClassName	= TEXT(&quot;fxdwespliter&quot;);
70  	}
71  	else
72  	{
73  		if (_dwFlags &amp; SV_HORIZONTAL)
74  		{
75  			wcex.hCursor		= ::LoadCursor(NULL,IDC_SIZENS);
76  			wcex.lpszClassName	= TEXT(&quot;nsspliter&quot;);
77  		}
78  		else
79  		{
80  			wcex.hCursor		= ::LoadCursor(NULL,IDC_SIZEWE);
81  			wcex.lpszClassName	= TEXT(&quot;wespliter&quot;);
82  		}
83  	}
84  	wcex.hbrBackground	= (HBRUSH)(COLOR_3DFACE+1);
85  	wcex.lpszMenuName	= NULL;
86  	wcex.hIconSm		= NULL;
87  	if ((_dwFlags &amp; SV_HORIZONTAL)&amp;&amp;(!_isHorizontalRegistered))
88  	{
89  		RegisterClassEx(&amp;wcex);
90  		_isHorizontalRegistered = true;
91  	}
92  	else if (isVertical()&amp;&amp;(!_isVerticalRegistered))
93  	{
94  		RegisterClassEx(&amp;wcex);
95  		_isVerticalRegistered = true;
96  	}
97  	else if ((_dwFlags &amp; SV_HORIZONTAL)&amp;&amp;(!_isHorizontalFixedRegistered))
98  	{
99  		RegisterClassEx(&amp;wcex);
100  		_isHorizontalFixedRegistered = true;
101  	}
102  	else if (isVertical()&amp;&amp;(!_isVerticalFixedRegistered))
103  	{
104  		RegisterClassEx(&amp;wcex);
105  		_isVerticalFixedRegistered = true;
106  	}
107  	_hSelf = CreateWindowEx(dwExStyle, wcex.lpszClassName,
108  		TEXT(&quot;&quot;),
109  		dwStyle,
110  		_rect.left, _rect.top, _rect.right, _rect.bottom,
111  		_hParent, NULL, _hInst, this);
112  	if (!_hSelf)
113  		throw std::runtime_error(&quot;Splitter::init : CreateWindowEx() function return null&quot;);
114  	RECT rc;
115  	getClientRect(rc);
116  	_clickZone2TL.left   = rc.left;
117  	_clickZone2TL.top    = rc.top;
118  	int clickZoneWidth   = getClickZone(WH::width);
119  	int clickZoneHeight  = getClickZone(WH::height);
120  	_clickZone2TL.right  = clickZoneWidth;
121  	_clickZone2TL.bottom = clickZoneHeight;
122  	_clickZone2BR.left   = rc.right - clickZoneWidth;
123  	_clickZone2BR.top    = rc.bottom - clickZoneHeight;
124  	_clickZone2BR.right  = clickZoneWidth;
125  	_clickZone2BR.bottom = clickZoneHeight;
126  	display();
127  	::SendMessage(_hParent, WM_RESIZE_CONTAINER, _rect.left, _rect.top);
128  }
129  void Splitter::destroy()
130  {
131  	::DestroyWindow(_hSelf);
132  }
133  int Splitter::getClickZone(WH which)
134  {
135  	if (_splitterSize &lt;= 8)
136  	{
137  		return isVertical()
138  			? (which == WH::width ? _splitterSize  : HIEGHT_MINIMAL)
139  			: (which == WH::width ? HIEGHT_MINIMAL : _splitterSize);
140  	}
141  	else 
142  	{
143  		return isVertical()
144  			? ((which == WH::width) ? 8  : 15)
145  			: ((which == WH::width) ? 15 : 8);
146  	}
147  }
148  LRESULT CALLBACK Splitter::staticWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
149  {
150  	switch(uMsg)
151  	{
152  		case WM_NCCREATE:
153  		{
154  			Splitter * pSplitter = static_cast&lt;Splitter *&gt;(reinterpret_cast&lt;LPCREATESTRUCT&gt;(lParam)-&gt;lpCreateParams);
155  			pSplitter-&gt;_hSelf = hWnd;
156  			::SetWindowLongPtr(hWnd, GWLP_USERDATA, reinterpret_cast&lt;LONG_PTR&gt;(pSplitter));
157  			return TRUE;
158  		}
159  		default:
160  		{
161  			Splitter * pSplitter = (Splitter *)::GetWindowLongPtr(hWnd, GWLP_USERDATA);
162  			if (!pSplitter)
163  				return ::DefWindowProc(hWnd, uMsg, wParam, lParam);
164  			return pSplitter-&gt;spliterWndProc(uMsg, wParam, lParam);
165  		}
166  	}
167  }
168  LRESULT CALLBACK Splitter::spliterWndProc(UINT uMsg, WPARAM wParam, LPARAM lParam)
169  {
170  	switch (uMsg)
171  	{
172  		case WM_LBUTTONDOWN:
173  		{
174  			POINT p;
175  			p.x = LOWORD(lParam);
176  			p.y = HIWORD(lParam);
177  			if ((isInLeftTopZone(p))&amp;&amp;(wParam == MK_LBUTTON))
178  			{
179  				gotoTopLeft();
180  				return TRUE;
181  			}
182  			if ((isInRightBottomZone(p))&amp;&amp;(wParam == MK_LBUTTON))
183  			{
184  				gotoRightBottom();
185  				return TRUE;
186  			}
187  			if (!_isFixed)
188  			{
189  				::SetCapture(_hSelf);
190  				_isDraged = true;
191  				_isLeftButtonDown = true;
192  			}
193  			return 0;
194  		}
195  		case WM_RBUTTONDOWN:
196  		{
197  			::SendMessage(_hParent, WM_DOPOPUPMENU, wParam, lParam);
198  			return TRUE;
199  		}
200  		case WM_MOUSEMOVE:
201  		{
202  			POINT p;
203  			p.x = LOWORD(lParam);
204  			p.y = HIWORD(lParam);
205  			if (isInLeftTopZone(p) || isInRightBottomZone(p))
206  			{
207  				::SetCursor(::LoadCursor(NULL, IDC_HAND));
208  				return TRUE;
209  			}
210  			if ((!_isFixed) &amp;&amp; (wParam == MK_LBUTTON) &amp;&amp; _isLeftButtonDown)
211  			{
212  				POINT pt; RECT rt;
213  				::GetClientRect(_hParent, &amp;rt);
214  				::GetCursorPos(&amp;pt);
215  				::ScreenToClient(_hParent, &amp;pt);
216  				if (_dwFlags &amp; SV_HORIZONTAL)
217  				{
218  					if (pt.y &lt;= 1)
219  					{
220  						_rect.top = 1;
221  						_splitPercent = 1;
222  					}
223  					else
224  					{
225  						if (pt.y &lt;= (rt.bottom - 5))
226  						{
227  							_rect.top = pt.y;
228  							_splitPercent = ((pt.y * 100 / (double)rt.bottom*100) / 100);
229  						}
230  						else
231  						{
<span onclick='openModal()' class='match'>232  							_rect.top = rt.bottom - 5;
233  							_splitPercent = 99;
234  						}
235  					}
236  				}
237  				else
</span>238  				{
239  					if (pt.x &lt;= 1)
240  					{
241  						_rect.left = 1;
242  						_splitPercent = 1;
243  					}
244  					else
245  					{
246  						if (pt.x &lt;= (rt.right - 5))
247  						{
248  							_rect.left = pt.x;
249  							_splitPercent = ((pt.x*100 / (double)rt.right*100) / 100);
250  						}
251  						else
252  						{
253  							_rect.left = rt.right - 5;
254  							_splitPercent = 99;
255  						}
256  					}
257  				}
258  				::SendMessage(_hParent, WM_RESIZE_CONTAINER, _rect.left, _rect.top);
259  				::MoveWindow(_hSelf, _rect.left, _rect.top, _rect.right, _rect.bottom, FALSE);
260  				redraw();
261  			}
262  			return 0;
263  		}
264  		case WM_LBUTTONDBLCLK:
265  		{
266  			RECT r;
267  			::GetClientRect(_hParent, &amp;r);
268  			if (_dwFlags &amp; SV_HORIZONTAL)
269  			{
270  				_rect.top = (r.bottom - _splitterSize) / 2;
271  			}
272  			else
273  			{
274  				_rect.left = (r.right - _splitterSize) / 2;
275  			}
276  			_splitPercent = 50;
277  			::SendMessage(_hParent, WM_RESIZE_CONTAINER, _rect.left, _rect.top);
278  			::MoveWindow(_hSelf, _rect.left, _rect.top, _rect.right, _rect.bottom, FALSE);
279  			redraw();
280  			return 0;
281  		}
282  		case WM_LBUTTONUP:
283  		{
284  			if (!_isFixed &amp;&amp; _isLeftButtonDown)
285  			{
286  				ReleaseCapture();
287  				_isLeftButtonDown = false;
288  			}
289  			return 0;
290  		}
291  		case WM_CAPTURECHANGED:
292  		{
293  			if (_isDraged)
294  			{
295  				::SendMessage(_hParent, WM_RESIZE_CONTAINER, _rect.left, _rect.top);
296  				::MoveWindow(_hSelf, _rect.left, _rect.top, _rect.right, _rect.bottom, TRUE);
297  				_isDraged = false;
298  			}
299  			return 0;
300  		}
301  		case WM_ERASEBKGND:
302  		{
303  			if (!NppDarkMode::isEnabled())
304  			{
305  				break;
306  			}
307  			RECT rc = {};
308  			getClientRect(rc);
309  			::FillRect(reinterpret_cast&lt;HDC&gt;(wParam), &amp;rc, NppDarkMode::getDarkerBackgroundBrush());
310  			return 1;
311  		}
312  		case WM_PAINT:
313  		{
314  			drawSplitter();
315  			return 0;
316  		}
317  		case WM_CLOSE:
318  		{
319  			destroy();
320  			return 0;
321  		}
322  	}
323  	return ::DefWindowProc(_hSelf, uMsg, wParam, lParam);
324  }
325  void Splitter::resizeSpliter(RECT *pRect)
326  {
327  	RECT rect;
328  	if (pRect)
329  		rect = *pRect;
330  	else
331  		::GetClientRect(_hParent,&amp;rect);
332  	if (_dwFlags &amp; SV_HORIZONTAL)
333  	{
334  		_rect.right = rect.right;
335  		if (_dwFlags &amp; SV_RESIZEWTHPERCNT)
336  			_rect.top  = (LONG)((rect.bottom * _splitPercent)/100) - _splitterSize / 2;
337  		else 
338  			_rect.top = getSplitterFixPosY();
339  	}
340  	else
341  	{
342  		_rect.bottom = rect.bottom;
343  		if (_dwFlags &amp; SV_RESIZEWTHPERCNT)
344  		{
345  			_rect.left = (LONG)((rect.right * _splitPercent)/100) - _splitterSize / 2;
346  		}
347  		else 
348  			_rect.left = getSplitterFixPosX();
349  	}
350  	::MoveWindow(_hSelf, _rect.left, _rect.top, _rect.right, _rect.bottom, TRUE);
351  	::SendMessage(_hParent, WM_RESIZE_CONTAINER, _rect.left, _rect.top);
352  	RECT rc;
353  	getClientRect(rc);
354  	_clickZone2BR.right = getClickZone(WH::width);
355  	_clickZone2BR.bottom = getClickZone(WH::height);
356  	_clickZone2BR.left = rc.right - _clickZone2BR.right;
357  	_clickZone2BR.top = rc.bottom - _clickZone2BR.bottom;
358  	redraw();
359  }
360  void Splitter::gotoTopLeft()
361  {
362  	if ((_dwFlags &amp; SV_ENABLELDBLCLK) &amp;&amp; (!_isFixed) &amp;&amp; (_splitPercent &gt; 1))
363  	{
364  		if (_dwFlags &amp; SV_HORIZONTAL)
365  			_rect.top  = 1;
366  		else
367  			_rect.left = 1;
368  		_splitPercent = 1;
369  		::SendMessage(_hParent, WM_RESIZE_CONTAINER, _rect.left, _rect.top);
370  		::MoveWindow(_hSelf, _rect.left, _rect.top, _rect.right, _rect.bottom, TRUE);
371  		redraw();
372  	}
373  }
374  void Splitter::gotoRightBottom()
375  {
376  	if ((_dwFlags &amp; SV_ENABLERDBLCLK) &amp;&amp; (!_isFixed) &amp;&amp; (_splitPercent &lt; 99))
377  	{
378  		RECT rt;
379  		GetClientRect(_hParent,&amp;rt);
380  		if (_dwFlags &amp; SV_HORIZONTAL)
381  			_rect.top   = rt.bottom - _splitterSize;
382  		else
383  			_rect.left   = rt.right - _splitterSize;
384  		_splitPercent = 99;
385  		::SendMessage(_hParent, WM_RESIZE_CONTAINER, _rect.left, _rect.top);
386  		::MoveWindow(_hSelf, _rect.left, _rect.top, _rect.right, _rect.bottom, TRUE);
387  		redraw();
388  	}
389  }
390  void Splitter::drawSplitter()
391  {
392  	PAINTSTRUCT ps;
393  	RECT rc, rcToDraw1, rcToDraw2, TLrc, BRrc;
394  	HDC hdc = ::BeginPaint(_hSelf, &amp;ps);
395  	getClientRect(rc);
396  	bool isDarkMode = NppDarkMode::isEnabled();
397  	HBRUSH hBrush = nullptr;
398  	HBRUSH hBrushTop = nullptr;
399  	HPEN holdPen = nullptr;
400  	if (isDarkMode)
401  	{
402  		hBrush = NppDarkMode::getBackgroundBrush();
403  		hBrushTop = NppDarkMode::getSofterBackgroundBrush();
404  		holdPen = static_cast&lt;HPEN&gt;(::SelectObject(hdc, NppDarkMode::getDarkerTextPen()));
405  		::FillRect(hdc, &amp;rc, NppDarkMode::getDarkerBackgroundBrush());
406  	}
407  	else
408  	{
409  		hBrush = ::CreateSolidBrush(RGB(0xFF, 0xFF, 0xFF));
410  		hBrushTop = ::GetSysColorBrush(COLOR_3DSHADOW);
411  	}
412  	DPIManager&amp; dpiMgr = NppParameters::getInstance()._dpiManager;
413  	if ((_splitterSize &gt;= dpiMgr.scaleX(4)) &amp;&amp; (_dwFlags &amp; SV_RESIZEWTHPERCNT))
414  	{
415  		adjustZoneToDraw(TLrc, ZONE_TYPE::topLeft);
416  		adjustZoneToDraw(BRrc, ZONE_TYPE::bottomRight);
417  		paintArrow(hdc, TLrc, isVertical() ? Arrow::left : Arrow::up);
418  	}
419  	if (isVertical())
420  	{
421  		rcToDraw2.top    = (_dwFlags &amp; SV_RESIZEWTHPERCNT) ? _clickZone2TL.bottom : 0;
422  		rcToDraw2.bottom = rcToDraw2.top + dpiMgr.scaleX(2);
423  		rcToDraw1.top    = rcToDraw2.top + dpiMgr.scaleX(1);
424  		rcToDraw1.bottom = rcToDraw1.top + dpiMgr.scaleX(2);
425  	}
426  	else
427  	{
428  		rcToDraw2.top    = dpiMgr.scaleX(1);
429  		rcToDraw2.bottom = dpiMgr.scaleX(3);
430  		rcToDraw1.top    = dpiMgr.scaleX(2);
431  		rcToDraw1.bottom = dpiMgr.scaleX(4);
432  	}
433  	int bottom = 0;
434  	if (_dwFlags &amp; SV_RESIZEWTHPERCNT)
435  		bottom = (isVertical() ? rc.bottom - _clickZone2BR.bottom : rc.bottom);
436  	else
437  		bottom = rc.bottom;
438  	while (rcToDraw1.bottom &lt;= bottom)
439  	{
440  		if (isVertical())
441  		{
442  			rcToDraw2.left  = dpiMgr.scaleX(1);
443  			rcToDraw2.right = dpiMgr.scaleX(3);
444  			rcToDraw1.left  = dpiMgr.scaleX(2);
445  			rcToDraw1.right = dpiMgr.scaleX(4);
446  		}
447  		else
448  		{
449  			rcToDraw2.left = _clickZone2TL.right;
450  			rcToDraw2.right = rcToDraw2.left + dpiMgr.scaleX(2);
451  			rcToDraw1.left = rcToDraw2.left;
452  			rcToDraw1.right = rcToDraw1.left + dpiMgr.scaleX(2);
453  		}
454  		int n = dpiMgr.scaleX(4);
455  		while (rcToDraw1.right &lt;= (isVertical() ? rc.right : rc.right - _clickZone2BR.right))
456  		{
457  			::FillRect(hdc, &amp;rcToDraw1, hBrush);
458  			::FillRect(hdc, &amp;rcToDraw2, hBrushTop);
459  			rcToDraw2.left  += n;
460  			rcToDraw2.right += n;
461  			rcToDraw1.left  += n;
462  			rcToDraw1.right += n;
463  		}
464  		rcToDraw2.top    += n;
465  		rcToDraw2.bottom += n;
466  		rcToDraw1.top    += n;
467  		rcToDraw1.bottom += n;
468  	}
469  	if ((_splitterSize &gt;= dpiMgr.scaleX(4)) &amp;&amp; (_dwFlags &amp; SV_RESIZEWTHPERCNT))
470  		paintArrow(hdc, BRrc, isVertical() ? Arrow::right : Arrow::down);
471  	if (isDarkMode)
472  	{
473  		::SelectObject(hdc, holdPen);
474  	}
475  	else
476  	{
477  		::DeleteObject(hBrush);
478  	}
479  	::EndPaint(_hSelf, &amp;ps);
480  }
481  void Splitter::rotate()
482  {
483  	if (!_isFixed)
484  	{
485  		destroy();
486  		if (_dwFlags &amp; SV_HORIZONTAL)
487  		{
488  			_dwFlags ^= SV_HORIZONTAL;
489  			_dwFlags |= SV_VERTICAL;
490  		}
491  		else 
492  		{
493  			_dwFlags ^= SV_VERTICAL;
494  			_dwFlags |= SV_HORIZONTAL;
495  		}
496  		init(_hInst, _hParent, _splitterSize, _splitPercent, _dwFlags);
497  	}
498  }
499  void Splitter::paintArrow(HDC hdc, const RECT &amp;rect, Arrow arrowDir)
500  {
501  	RECT rc;
502  	rc.left = rect.left;
503  	rc.top = rect.top;
504  	rc.right = rect.right;
505  	rc.bottom = rect.bottom;
506  	switch (arrowDir)
507  	{
508  		case Arrow::left:
509  		{
510  			int x = rc.right;
511  			int y = rc.top;
512  			for (; (x &gt; rc.left) &amp;&amp; (y != rc.bottom) ; --x)
513  			{
514  				::MoveToEx(hdc, x, y++, NULL);
515  				::LineTo(hdc, x, rc.bottom--);
516  			}
517  			break;
518  		}
519  		case Arrow::right:
520  		{
521  			int x = rc.left;
522  			int y = rc.top;
523  			for (; (x &lt; rc.right) &amp;&amp; (y != rc.bottom) ; ++x)
524  			{
525  				::MoveToEx(hdc, x, y++, NULL);
526  				::LineTo(hdc, x, rc.bottom--);
527  			}
528  			break;
529  		}
530  		case Arrow::up:
531  		{
532  			int x = rc.left;
533  			int y = rc.bottom;
534  			for (; (y &gt; rc.top) &amp;&amp; (x != rc.right) ; --y)
535  			{
536  				::MoveToEx(hdc, x++, y, NULL);
537  				::LineTo(hdc, rc.right--, y);
538  			}
539  			break;
540  		}
541  		case Arrow::down:
542  		{
543  			int x = rc.left;
544  			int y = rc.top;
545  			for (; (y &lt; rc.bottom) &amp;&amp; (x != rc.right) ; ++y)
546  			{
547  				::MoveToEx(hdc, x++, y, NULL);
548  				::LineTo(hdc, rc.right--, y);
549  			}
550  			break;
551  		}
552  	}
553  }
554  void Splitter::adjustZoneToDraw(RECT&amp; rc2def, ZONE_TYPE whichZone)
555  {
556  	if (_splitterSize &lt; 4)
557  		return;
558  	int x0, y0, x1, y1, w, h;
559  	if ((4 &lt;= _splitterSize) &amp;&amp; (_splitterSize &lt;= 8))
560  	{
561  		w = (isVertical() ? 4 : 7);
562  		h = (isVertical() ? 7 : 4);
563  	}
564  	else 
565  	{
566  		w = (isVertical() ? 6  : 11);
567  		h = (isVertical() ? 11 : 6);
568  	}
569  	if (isVertical())
570  	{
571  		if (whichZone == ZONE_TYPE::topLeft)
572  		{
573  			x0 = 0;
574  			y0 = (_clickZone2TL.bottom - h) / 2;
575  		}
576  		else 
577  		{
578  			x0 = _clickZone2BR.left + _clickZone2BR.right - w;
579  			y0 = (_clickZone2BR.bottom - h) / 2 + _clickZone2BR.top;
580  		}
581  		x1 = x0 + w;
582  		y1 = y0 + h;
583  	}
584  	else 
585  	{
586  		if (whichZone == ZONE_TYPE::topLeft)
587  		{
588  			x0 = (_clickZone2TL.right - w) / 2;
589  			y0 = 0;
590  		}
591  		else 
592  		{
593  			x0 = ((_clickZone2BR.right - w) / 2) + _clickZone2BR.left;
594  			y0 = _clickZone2BR.top + _clickZone2BR.bottom - h;
595  		}
596  		x1 = x0 + w;
597  		y1 = y0 + h;
598  	}
599  	rc2def.left = x0;
600  	rc2def.top = y0;
601  	rc2def.right = x1;
602  	rc2def.bottom = y1;
603  }
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-Splitter.cpp</h3>
            <pre><code>1  #include &lt;iostream&gt;
2  #include &lt;stdexcept&gt;
3  #include &lt;windows.h&gt;
4  #include &quot;Splitter.h&quot;
5  #include &quot;Parameters.h&quot;
6  #include &quot;NppDarkMode.h&quot;
7  bool Splitter::_isHorizontalRegistered = false;
8  bool Splitter::_isVerticalRegistered = false;
9  bool Splitter::_isHorizontalFixedRegistered = false;
10  bool Splitter::_isVerticalFixedRegistered = false;
11  #define SPLITTER_SIZE 8
12  void Splitter::init( HINSTANCE hInst, HWND hPere, int splitterSize, double iSplitRatio, DWORD dwFlags)
13  {
14  	if (hPere == NULL)
15  		throw std::runtime_error(&quot;Splitter::init : Parameter hPere is null&quot;);
16  	if (iSplitRatio &lt; 0)
17  		throw std::runtime_error(&quot;Splitter::init : Parameter iSplitRatio shoulds be 0 &lt; ratio &lt; 100&quot;);
18  	Window::init(hInst, hPere);
19  	_splitterSize = splitterSize;
20  	WNDCLASSEX wcex;
21  	DWORD dwExStyle = 0L;
22  	DWORD dwStyle   = WS_CHILD | WS_VISIBLE;
23  	_hParent = hPere;
24  	_dwFlags = dwFlags;
25  	if (_dwFlags &amp; SV_FIXED)
26  	{
27  		_isFixed = true;
28  	}
29  	else
30  	{
31  		if (iSplitRatio &gt;= 100)
32  		{
33  			throw std::runtime_error(&quot;Splitter::init : Parameter iSplitRatio shoulds be 0 &lt; ratio &lt; 100&quot;);
34  		}
35  	}
36  	_splitPercent = iSplitRatio;
37  	wcex.cbSize			= sizeof(WNDCLASSEX);
38  	wcex.style			= CS_HREDRAW | CS_VREDRAW;
39  	wcex.lpfnWndProc	= (WNDPROC)staticWndProc;
40  	wcex.cbClsExtra		= 0;
41  	wcex.cbWndExtra		= 0;
42  	wcex.hInstance		= _hInst;
43  	wcex.hIcon			= NULL;
44  	::GetClientRect(_hParent, &amp;_rect);
45  	if (_dwFlags &amp; SV_HORIZONTAL) 
46  	{
47  		_rect.top  = (LONG)((_rect.bottom * _splitPercent)/100) - _splitterSize / 2;
48  		_rect.left = 0;
49  		_rect.bottom = _splitterSize;
50  	}
51  	else 
52  	{
53  		_rect.left = (LONG)((_rect.right * _splitPercent)/100) - _splitterSize / 2;
54  		_rect.right = _splitterSize;
55  	}
56  	if (!_isFixed)
57  	{
58  		if ((_dwFlags &amp; SV_ENABLERDBLCLK) || (_dwFlags &amp; SV_ENABLELDBLCLK))
59  		{
60  			wcex.style = wcex.style | CS_DBLCLKS;
61  		}
62  	}
63  	if (_isFixed)
64  	{
65  		wcex.hCursor		= ::LoadCursor(NULL, IDC_ARROW);
66  		if (_dwFlags &amp; SV_HORIZONTAL)
67  			wcex.lpszClassName	= TEXT(&quot;fxdnsspliter&quot;);
68  		else
69  			wcex.lpszClassName	= TEXT(&quot;fxdwespliter&quot;);
70  	}
71  	else
72  	{
73  		if (_dwFlags &amp; SV_HORIZONTAL)
74  		{
75  			wcex.hCursor		= ::LoadCursor(NULL,IDC_SIZENS);
76  			wcex.lpszClassName	= TEXT(&quot;nsspliter&quot;);
77  		}
78  		else
79  		{
80  			wcex.hCursor		= ::LoadCursor(NULL,IDC_SIZEWE);
81  			wcex.lpszClassName	= TEXT(&quot;wespliter&quot;);
82  		}
83  	}
84  	wcex.hbrBackground	= (HBRUSH)(COLOR_3DFACE+1);
85  	wcex.lpszMenuName	= NULL;
86  	wcex.hIconSm		= NULL;
87  	if ((_dwFlags &amp; SV_HORIZONTAL)&amp;&amp;(!_isHorizontalRegistered))
88  	{
89  		RegisterClassEx(&amp;wcex);
90  		_isHorizontalRegistered = true;
91  	}
92  	else if (isVertical()&amp;&amp;(!_isVerticalRegistered))
93  	{
94  		RegisterClassEx(&amp;wcex);
95  		_isVerticalRegistered = true;
96  	}
97  	else if ((_dwFlags &amp; SV_HORIZONTAL)&amp;&amp;(!_isHorizontalFixedRegistered))
98  	{
99  		RegisterClassEx(&amp;wcex);
100  		_isHorizontalFixedRegistered = true;
101  	}
102  	else if (isVertical()&amp;&amp;(!_isVerticalFixedRegistered))
103  	{
104  		RegisterClassEx(&amp;wcex);
105  		_isVerticalFixedRegistered = true;
106  	}
107  	_hSelf = CreateWindowEx(dwExStyle, wcex.lpszClassName,
108  		TEXT(&quot;&quot;),
109  		dwStyle,
110  		_rect.left, _rect.top, _rect.right, _rect.bottom,
111  		_hParent, NULL, _hInst, this);
112  	if (!_hSelf)
113  		throw std::runtime_error(&quot;Splitter::init : CreateWindowEx() function return null&quot;);
114  	RECT rc;
115  	getClientRect(rc);
116  	_clickZone2TL.left   = rc.left;
117  	_clickZone2TL.top    = rc.top;
118  	int clickZoneWidth   = getClickZone(WH::width);
119  	int clickZoneHeight  = getClickZone(WH::height);
120  	_clickZone2TL.right  = clickZoneWidth;
121  	_clickZone2TL.bottom = clickZoneHeight;
122  	_clickZone2BR.left   = rc.right - clickZoneWidth;
123  	_clickZone2BR.top    = rc.bottom - clickZoneHeight;
124  	_clickZone2BR.right  = clickZoneWidth;
125  	_clickZone2BR.bottom = clickZoneHeight;
126  	display();
127  	::SendMessage(_hParent, WM_RESIZE_CONTAINER, _rect.left, _rect.top);
128  }
129  void Splitter::destroy()
130  {
131  	::DestroyWindow(_hSelf);
132  }
133  int Splitter::getClickZone(WH which)
134  {
135  	if (_splitterSize &lt;= 8)
136  	{
137  		return isVertical()
138  			? (which == WH::width ? _splitterSize  : HIEGHT_MINIMAL)
139  			: (which == WH::width ? HIEGHT_MINIMAL : _splitterSize);
140  	}
141  	else 
142  	{
143  		return isVertical()
144  			? ((which == WH::width) ? 8  : 15)
145  			: ((which == WH::width) ? 15 : 8);
146  	}
147  }
148  LRESULT CALLBACK Splitter::staticWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
149  {
150  	switch(uMsg)
151  	{
152  		case WM_NCCREATE:
153  		{
154  			Splitter * pSplitter = static_cast&lt;Splitter *&gt;(reinterpret_cast&lt;LPCREATESTRUCT&gt;(lParam)-&gt;lpCreateParams);
155  			pSplitter-&gt;_hSelf = hWnd;
156  			::SetWindowLongPtr(hWnd, GWLP_USERDATA, reinterpret_cast&lt;LONG_PTR&gt;(pSplitter));
157  			return TRUE;
158  		}
159  		default:
160  		{
161  			Splitter * pSplitter = (Splitter *)::GetWindowLongPtr(hWnd, GWLP_USERDATA);
162  			if (!pSplitter)
163  				return ::DefWindowProc(hWnd, uMsg, wParam, lParam);
164  			return pSplitter-&gt;spliterWndProc(uMsg, wParam, lParam);
165  		}
166  	}
167  }
168  LRESULT CALLBACK Splitter::spliterWndProc(UINT uMsg, WPARAM wParam, LPARAM lParam)
169  {
170  	switch (uMsg)
171  	{
172  		case WM_LBUTTONDOWN:
173  		{
174  			POINT p;
175  			p.x = LOWORD(lParam);
176  			p.y = HIWORD(lParam);
177  			if ((isInLeftTopZone(p))&amp;&amp;(wParam == MK_LBUTTON))
178  			{
179  				gotoTopLeft();
180  				return TRUE;
181  			}
182  			if ((isInRightBottomZone(p))&amp;&amp;(wParam == MK_LBUTTON))
183  			{
184  				gotoRightBottom();
185  				return TRUE;
186  			}
187  			if (!_isFixed)
188  			{
189  				::SetCapture(_hSelf);
190  				_isDraged = true;
191  				_isLeftButtonDown = true;
192  			}
193  			return 0;
194  		}
195  		case WM_RBUTTONDOWN:
196  		{
197  			::SendMessage(_hParent, WM_DOPOPUPMENU, wParam, lParam);
198  			return TRUE;
199  		}
200  		case WM_MOUSEMOVE:
201  		{
202  			POINT p;
203  			p.x = LOWORD(lParam);
204  			p.y = HIWORD(lParam);
205  			if (isInLeftTopZone(p) || isInRightBottomZone(p))
206  			{
207  				::SetCursor(::LoadCursor(NULL, IDC_HAND));
208  				return TRUE;
209  			}
210  			if ((!_isFixed) &amp;&amp; (wParam == MK_LBUTTON) &amp;&amp; _isLeftButtonDown)
211  			{
212  				POINT pt; RECT rt;
213  				::GetClientRect(_hParent, &amp;rt);
214  				::GetCursorPos(&amp;pt);
215  				::ScreenToClient(_hParent, &amp;pt);
216  				if (_dwFlags &amp; SV_HORIZONTAL)
217  				{
218  					if (pt.y &lt;= 1)
219  					{
220  						_rect.top = 1;
221  						_splitPercent = 1;
222  					}
223  					else
224  					{
225  						if (pt.y &lt;= (rt.bottom - 5))
226  						{
227  							_rect.top = pt.y;
228  							_splitPercent = ((pt.y * 100 / (double)rt.bottom*100) / 100);
229  						}
230  						else
231  						{
232  							_rect.top = rt.bottom - 5;
233  							_splitPercent = 99;
234  						}
235  					}
236  				}
237  				else
238  				{
239  					if (pt.x &lt;= 1)
240  					{
241  						_rect.left = 1;
242  						_splitPercent = 1;
243  					}
244  					else
245  					{
246  						if (pt.x &lt;= (rt.right - 5))
247  						{
248  							_rect.left = pt.x;
249  							_splitPercent = ((pt.x*100 / (double)rt.right*100) / 100);
250  						}
251  						else
252  						{
<span onclick='openModal()' class='match'>253  							_rect.left = rt.right - 5;
254  							_splitPercent = 99;
255  						}
256  					}
257  				}
258  				::SendMessage(_hParent, WM_RESIZE_CONTAINER, _rect.left, _rect.top);
</span>259  				::MoveWindow(_hSelf, _rect.left, _rect.top, _rect.right, _rect.bottom, FALSE);
260  				redraw();
261  			}
262  			return 0;
263  		}
264  		case WM_LBUTTONDBLCLK:
265  		{
266  			RECT r;
267  			::GetClientRect(_hParent, &amp;r);
268  			if (_dwFlags &amp; SV_HORIZONTAL)
269  			{
270  				_rect.top = (r.bottom - _splitterSize) / 2;
271  			}
272  			else
273  			{
274  				_rect.left = (r.right - _splitterSize) / 2;
275  			}
276  			_splitPercent = 50;
277  			::SendMessage(_hParent, WM_RESIZE_CONTAINER, _rect.left, _rect.top);
278  			::MoveWindow(_hSelf, _rect.left, _rect.top, _rect.right, _rect.bottom, FALSE);
279  			redraw();
280  			return 0;
281  		}
282  		case WM_LBUTTONUP:
283  		{
284  			if (!_isFixed &amp;&amp; _isLeftButtonDown)
285  			{
286  				ReleaseCapture();
287  				_isLeftButtonDown = false;
288  			}
289  			return 0;
290  		}
291  		case WM_CAPTURECHANGED:
292  		{
293  			if (_isDraged)
294  			{
295  				::SendMessage(_hParent, WM_RESIZE_CONTAINER, _rect.left, _rect.top);
296  				::MoveWindow(_hSelf, _rect.left, _rect.top, _rect.right, _rect.bottom, TRUE);
297  				_isDraged = false;
298  			}
299  			return 0;
300  		}
301  		case WM_ERASEBKGND:
302  		{
303  			if (!NppDarkMode::isEnabled())
304  			{
305  				break;
306  			}
307  			RECT rc = {};
308  			getClientRect(rc);
309  			::FillRect(reinterpret_cast&lt;HDC&gt;(wParam), &amp;rc, NppDarkMode::getDarkerBackgroundBrush());
310  			return 1;
311  		}
312  		case WM_PAINT:
313  		{
314  			drawSplitter();
315  			return 0;
316  		}
317  		case WM_CLOSE:
318  		{
319  			destroy();
320  			return 0;
321  		}
322  	}
323  	return ::DefWindowProc(_hSelf, uMsg, wParam, lParam);
324  }
325  void Splitter::resizeSpliter(RECT *pRect)
326  {
327  	RECT rect;
328  	if (pRect)
329  		rect = *pRect;
330  	else
331  		::GetClientRect(_hParent,&amp;rect);
332  	if (_dwFlags &amp; SV_HORIZONTAL)
333  	{
334  		_rect.right = rect.right;
335  		if (_dwFlags &amp; SV_RESIZEWTHPERCNT)
336  			_rect.top  = (LONG)((rect.bottom * _splitPercent)/100) - _splitterSize / 2;
337  		else 
338  			_rect.top = getSplitterFixPosY();
339  	}
340  	else
341  	{
342  		_rect.bottom = rect.bottom;
343  		if (_dwFlags &amp; SV_RESIZEWTHPERCNT)
344  		{
345  			_rect.left = (LONG)((rect.right * _splitPercent)/100) - _splitterSize / 2;
346  		}
347  		else 
348  			_rect.left = getSplitterFixPosX();
349  	}
350  	::MoveWindow(_hSelf, _rect.left, _rect.top, _rect.right, _rect.bottom, TRUE);
351  	::SendMessage(_hParent, WM_RESIZE_CONTAINER, _rect.left, _rect.top);
352  	RECT rc;
353  	getClientRect(rc);
354  	_clickZone2BR.right = getClickZone(WH::width);
355  	_clickZone2BR.bottom = getClickZone(WH::height);
356  	_clickZone2BR.left = rc.right - _clickZone2BR.right;
357  	_clickZone2BR.top = rc.bottom - _clickZone2BR.bottom;
358  	redraw();
359  }
360  void Splitter::gotoTopLeft()
361  {
362  	if ((_dwFlags &amp; SV_ENABLELDBLCLK) &amp;&amp; (!_isFixed) &amp;&amp; (_splitPercent &gt; 1))
363  	{
364  		if (_dwFlags &amp; SV_HORIZONTAL)
365  			_rect.top  = 1;
366  		else
367  			_rect.left = 1;
368  		_splitPercent = 1;
369  		::SendMessage(_hParent, WM_RESIZE_CONTAINER, _rect.left, _rect.top);
370  		::MoveWindow(_hSelf, _rect.left, _rect.top, _rect.right, _rect.bottom, TRUE);
371  		redraw();
372  	}
373  }
374  void Splitter::gotoRightBottom()
375  {
376  	if ((_dwFlags &amp; SV_ENABLERDBLCLK) &amp;&amp; (!_isFixed) &amp;&amp; (_splitPercent &lt; 99))
377  	{
378  		RECT rt;
379  		GetClientRect(_hParent,&amp;rt);
380  		if (_dwFlags &amp; SV_HORIZONTAL)
381  			_rect.top   = rt.bottom - _splitterSize;
382  		else
383  			_rect.left   = rt.right - _splitterSize;
384  		_splitPercent = 99;
385  		::SendMessage(_hParent, WM_RESIZE_CONTAINER, _rect.left, _rect.top);
386  		::MoveWindow(_hSelf, _rect.left, _rect.top, _rect.right, _rect.bottom, TRUE);
387  		redraw();
388  	}
389  }
390  void Splitter::drawSplitter()
391  {
392  	PAINTSTRUCT ps;
393  	RECT rc, rcToDraw1, rcToDraw2, TLrc, BRrc;
394  	HDC hdc = ::BeginPaint(_hSelf, &amp;ps);
395  	getClientRect(rc);
396  	bool isDarkMode = NppDarkMode::isEnabled();
397  	HBRUSH hBrush = nullptr;
398  	HBRUSH hBrushTop = nullptr;
399  	HPEN holdPen = nullptr;
400  	if (isDarkMode)
401  	{
402  		hBrush = NppDarkMode::getBackgroundBrush();
403  		hBrushTop = NppDarkMode::getSofterBackgroundBrush();
404  		holdPen = static_cast&lt;HPEN&gt;(::SelectObject(hdc, NppDarkMode::getDarkerTextPen()));
405  		::FillRect(hdc, &amp;rc, NppDarkMode::getDarkerBackgroundBrush());
406  	}
407  	else
408  	{
409  		hBrush = ::CreateSolidBrush(RGB(0xFF, 0xFF, 0xFF));
410  		hBrushTop = ::GetSysColorBrush(COLOR_3DSHADOW);
411  	}
412  	DPIManager&amp; dpiMgr = NppParameters::getInstance()._dpiManager;
413  	if ((_splitterSize &gt;= dpiMgr.scaleX(4)) &amp;&amp; (_dwFlags &amp; SV_RESIZEWTHPERCNT))
414  	{
415  		adjustZoneToDraw(TLrc, ZONE_TYPE::topLeft);
416  		adjustZoneToDraw(BRrc, ZONE_TYPE::bottomRight);
417  		paintArrow(hdc, TLrc, isVertical() ? Arrow::left : Arrow::up);
418  	}
419  	if (isVertical())
420  	{
421  		rcToDraw2.top    = (_dwFlags &amp; SV_RESIZEWTHPERCNT) ? _clickZone2TL.bottom : 0;
422  		rcToDraw2.bottom = rcToDraw2.top + dpiMgr.scaleX(2);
423  		rcToDraw1.top    = rcToDraw2.top + dpiMgr.scaleX(1);
424  		rcToDraw1.bottom = rcToDraw1.top + dpiMgr.scaleX(2);
425  	}
426  	else
427  	{
428  		rcToDraw2.top    = dpiMgr.scaleX(1);
429  		rcToDraw2.bottom = dpiMgr.scaleX(3);
430  		rcToDraw1.top    = dpiMgr.scaleX(2);
431  		rcToDraw1.bottom = dpiMgr.scaleX(4);
432  	}
433  	int bottom = 0;
434  	if (_dwFlags &amp; SV_RESIZEWTHPERCNT)
435  		bottom = (isVertical() ? rc.bottom - _clickZone2BR.bottom : rc.bottom);
436  	else
437  		bottom = rc.bottom;
438  	while (rcToDraw1.bottom &lt;= bottom)
439  	{
440  		if (isVertical())
441  		{
442  			rcToDraw2.left  = dpiMgr.scaleX(1);
443  			rcToDraw2.right = dpiMgr.scaleX(3);
444  			rcToDraw1.left  = dpiMgr.scaleX(2);
445  			rcToDraw1.right = dpiMgr.scaleX(4);
446  		}
447  		else
448  		{
449  			rcToDraw2.left = _clickZone2TL.right;
450  			rcToDraw2.right = rcToDraw2.left + dpiMgr.scaleX(2);
451  			rcToDraw1.left = rcToDraw2.left;
452  			rcToDraw1.right = rcToDraw1.left + dpiMgr.scaleX(2);
453  		}
454  		int n = dpiMgr.scaleX(4);
455  		while (rcToDraw1.right &lt;= (isVertical() ? rc.right : rc.right - _clickZone2BR.right))
456  		{
457  			::FillRect(hdc, &amp;rcToDraw1, hBrush);
458  			::FillRect(hdc, &amp;rcToDraw2, hBrushTop);
459  			rcToDraw2.left  += n;
460  			rcToDraw2.right += n;
461  			rcToDraw1.left  += n;
462  			rcToDraw1.right += n;
463  		}
464  		rcToDraw2.top    += n;
465  		rcToDraw2.bottom += n;
466  		rcToDraw1.top    += n;
467  		rcToDraw1.bottom += n;
468  	}
469  	if ((_splitterSize &gt;= dpiMgr.scaleX(4)) &amp;&amp; (_dwFlags &amp; SV_RESIZEWTHPERCNT))
470  		paintArrow(hdc, BRrc, isVertical() ? Arrow::right : Arrow::down);
471  	if (isDarkMode)
472  	{
473  		::SelectObject(hdc, holdPen);
474  	}
475  	else
476  	{
477  		::DeleteObject(hBrush);
478  	}
479  	::EndPaint(_hSelf, &amp;ps);
480  }
481  void Splitter::rotate()
482  {
483  	if (!_isFixed)
484  	{
485  		destroy();
486  		if (_dwFlags &amp; SV_HORIZONTAL)
487  		{
488  			_dwFlags ^= SV_HORIZONTAL;
489  			_dwFlags |= SV_VERTICAL;
490  		}
491  		else 
492  		{
493  			_dwFlags ^= SV_VERTICAL;
494  			_dwFlags |= SV_HORIZONTAL;
495  		}
496  		init(_hInst, _hParent, _splitterSize, _splitPercent, _dwFlags);
497  	}
498  }
499  void Splitter::paintArrow(HDC hdc, const RECT &amp;rect, Arrow arrowDir)
500  {
501  	RECT rc;
502  	rc.left = rect.left;
503  	rc.top = rect.top;
504  	rc.right = rect.right;
505  	rc.bottom = rect.bottom;
506  	switch (arrowDir)
507  	{
508  		case Arrow::left:
509  		{
510  			int x = rc.right;
511  			int y = rc.top;
512  			for (; (x &gt; rc.left) &amp;&amp; (y != rc.bottom) ; --x)
513  			{
514  				::MoveToEx(hdc, x, y++, NULL);
515  				::LineTo(hdc, x, rc.bottom--);
516  			}
517  			break;
518  		}
519  		case Arrow::right:
520  		{
521  			int x = rc.left;
522  			int y = rc.top;
523  			for (; (x &lt; rc.right) &amp;&amp; (y != rc.bottom) ; ++x)
524  			{
525  				::MoveToEx(hdc, x, y++, NULL);
526  				::LineTo(hdc, x, rc.bottom--);
527  			}
528  			break;
529  		}
530  		case Arrow::up:
531  		{
532  			int x = rc.left;
533  			int y = rc.bottom;
534  			for (; (y &gt; rc.top) &amp;&amp; (x != rc.right) ; --y)
535  			{
536  				::MoveToEx(hdc, x++, y, NULL);
537  				::LineTo(hdc, rc.right--, y);
538  			}
539  			break;
540  		}
541  		case Arrow::down:
542  		{
543  			int x = rc.left;
544  			int y = rc.top;
545  			for (; (y &lt; rc.bottom) &amp;&amp; (x != rc.right) ; ++y)
546  			{
547  				::MoveToEx(hdc, x++, y, NULL);
548  				::LineTo(hdc, rc.right--, y);
549  			}
550  			break;
551  		}
552  	}
553  }
554  void Splitter::adjustZoneToDraw(RECT&amp; rc2def, ZONE_TYPE whichZone)
555  {
556  	if (_splitterSize &lt; 4)
557  		return;
558  	int x0, y0, x1, y1, w, h;
559  	if ((4 &lt;= _splitterSize) &amp;&amp; (_splitterSize &lt;= 8))
560  	{
561  		w = (isVertical() ? 4 : 7);
562  		h = (isVertical() ? 7 : 4);
563  	}
564  	else 
565  	{
566  		w = (isVertical() ? 6  : 11);
567  		h = (isVertical() ? 11 : 6);
568  	}
569  	if (isVertical())
570  	{
571  		if (whichZone == ZONE_TYPE::topLeft)
572  		{
573  			x0 = 0;
574  			y0 = (_clickZone2TL.bottom - h) / 2;
575  		}
576  		else 
577  		{
578  			x0 = _clickZone2BR.left + _clickZone2BR.right - w;
579  			y0 = (_clickZone2BR.bottom - h) / 2 + _clickZone2BR.top;
580  		}
581  		x1 = x0 + w;
582  		y1 = y0 + h;
583  	}
584  	else 
585  	{
586  		if (whichZone == ZONE_TYPE::topLeft)
587  		{
588  			x0 = (_clickZone2TL.right - w) / 2;
589  			y0 = 0;
590  		}
591  		else 
592  		{
593  			x0 = ((_clickZone2BR.right - w) / 2) + _clickZone2BR.left;
594  			y0 = _clickZone2BR.top + _clickZone2BR.bottom - h;
595  		}
596  		x1 = x0 + w;
597  		y1 = y0 + h;
598  	}
599  	rc2def.left = x0;
600  	rc2def.top = y0;
601  	rc2def.right = x1;
602  	rc2def.bottom = y1;
603  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-Splitter.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-Splitter.cpp</div>
                </div>
                <div class="column column_space"><pre><code>232  							_rect.top = rt.bottom - 5;
233  							_splitPercent = 99;
234  						}
235  					}
236  				}
237  				else
</pre></code></div>
                <div class="column column_space"><pre><code>253  							_rect.left = rt.right - 5;
254  							_splitPercent = 99;
255  						}
256  					}
257  				}
258  				::SendMessage(_hParent, WM_RESIZE_CONTAINER, _rect.left, _rect.top);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    