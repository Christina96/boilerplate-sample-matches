
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 4.2105263157894735%, Tokens: 11, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-nytngrams.cpp</h3>
            <pre><code>1  #include "nytngrams.h"
2  bool TNytNGramBs::IsNGram(const TStrV& TermStrV, int& NGramId) const {
3    NGramId=TermStrVH.GetKeyId(TermStrV);
4    return NGramId!=-1;
5  }
6  TStr TNytNGramBs::GetNGramStr(const int& NGramId) const {
7    const TStrV& TermStrV=TermStrVH.GetKey(NGramId);
8    TChA NGramChA;
9    for (int TermStrN=0; TermStrN<TermStrV.Len(); TermStrN++){
10      if (TermStrN>0){NGramChA+=' ';}
11      NGramChA+=TermStrV[TermStrN];
12    }
13    return NGramChA;
14  }
15  void TNytNGramBs::GetNGramStrV(const TStr& HtmlStr, TStrV& NGramStrV){
16    NGramStrV.Clr();
17    PSIn HtmlSIn=TStrIn::New(HtmlStr);
18    THtmlLx HtmlLx(HtmlSIn);
19    TStrV StrV;
20    while (HtmlLx.GetSym()!=hsyEof){
21      TStr Str=HtmlLx.ChA;
22      Str.ToLc();
23      switch (HtmlLx.Sym){
24        case hsyUndef:
25        case hsyUrl:
26        case hsyMTag:
27        case hsySSym:
28          StrV.Clr();
29          break;
30        case hsyStr:
31        case hsyNum:
32          NGramStrV.Add(Str);
33          StrV.Add(Str);
34          for (int NGramLen=2; NGramLen<=4; NGramLen++){
35            if (StrV.Len()<NGramLen){break;}
36            TStrV TermStrV(NGramLen, 0);
37            for (int StrN=StrV.Len()-NGramLen; StrN<StrV.Len(); StrN++){
38              TermStrV.Add(StrV[StrN]);
39            }
40            int NGramId;
41            if (IsNGram(TermStrV, NGramId)){
42              TStr NGramStr=GetNGramStr(NGramId);
43              NGramStrV.Add(NGramStr);
44            }
45          } 
46          break;
47        case hsyBTag:
48        case hsyETag:
49          StrV.Clr();
50          break;
51        case hsyEof: break;
52        default: Fail;
53      }
54    }
55  }
56  PNytNGramBs TNytNGramBs::LoadNytNGramBs(const TStr& InNGramsFPath, const int& ExpectedNGrams){
57    TStr InNGramsNrFPath=TStr::GetNrFPath(InNGramsFPath);
58    TStr LexiconFNm=InNGramsNrFPath+"Lexicon.Csv";
59    TStr Coloc2FNm=InNGramsNrFPath+"significant_colocations_2.bin";
60    TStr Coloc3FNm=InNGramsNrFPath+"significant_colocations_3.bin";
61    TStr Coloc4FNm=InNGramsNrFPath+"significant_colocations_4.bin";
62    printf("Loading Lexicon from %s ...\n", LexiconFNm.CStr());
63    PSs LexiconSs=TSs::LoadTxt(ssfCommaSep, LexiconFNm, TNotify::StdNotify, false);
64    printf("Done.");
<span onclick='openModal()' class='match'>65    PNytNGramBs NytNGramBs=TNytNGramBs::New(ExpectedNGrams);
66    int Terms=LexiconSs->GetYLen();
67    TIntStrH TermIdToStrH(Terms*2);
68    for (int TermN=0; TermN<Terms; TermN++){
69      int TermId=LexiconSs->At(0, TermN).GetInt();
</span>70      TStr TermStr=LexiconSs->At(1, TermN);
71      TermIdToStrH.AddDat(TermId, TermStr);
72      TStrV TermStrV(1, 0); TermStrV.Add(TermStr); 
73      NytNGramBs->TermStrVH.AddDat(TermStrV);
74    }
75    {printf("Load Collocations from '%s' ...\n", Coloc2FNm.CStr());
76    FILE* fColoc=fopen(Coloc2FNm.CStr(), "rb");
77    int Colocs=0; int BadColocs=0;
78    while (!feof(fColoc)){
79      Colocs++; if (Colocs%1000==0){printf("%d\r", Colocs);}
80      int TermId1=-1; int TermId2=-1; 
81      int CorpusFq=-1; int DocFq=-1; double Sig=-1;
82      fread(&TermId1, 4, 1, fColoc); TermId1=TUInt::JavaUIntToCppUInt(TermId1);
83      fread(&TermId2, 4, 1, fColoc); TermId2=TUInt::JavaUIntToCppUInt(TermId2);
84      fread(&CorpusFq, 4, 1, fColoc);
85      fread(&DocFq, 4, 1, fColoc);
86      fread(&Sig, 8, 1, fColoc);
87      TStr TermStr1; TStr TermStr2; 
88      if (TermIdToStrH.IsKeyGetDat(TermId1, TermStr1)){
89        if (TermIdToStrH.IsKeyGetDat(TermId2, TermStr2)){
90          TStrV TermStrV(2, 0); TermStrV.Add(TermStr1); TermStrV.Add(TermStr2);
91          NytNGramBs->TermStrVH.AddDat(TermStrV);
92        } else {BadColocs++;}
93      } else {BadColocs++;}
94    }
95    printf("Colocations:%d Bad Collocations:%d\nDone.\n", Colocs, BadColocs);}
96    {printf("Load Collocations from '%s' ...\n", Coloc3FNm.CStr());
97    FILE* fColoc=fopen(Coloc3FNm.CStr(), "rb");
98    int Colocs=0; int BadColocs=0;
99    while (!feof(fColoc)){
100      Colocs++; if (Colocs%1000==0){printf("%d\r", Colocs);}
101      int TermId1=-1; int TermId2=-1; int TermId3=-1;
102      int CorpusFq=-1; int DocFq=-1; double Sig=-1;
103      fread(&TermId1, 4, 1, fColoc); TermId1=TUInt::JavaUIntToCppUInt(TermId1);
104      fread(&TermId2, 4, 1, fColoc); TermId2=TUInt::JavaUIntToCppUInt(TermId2);
105      fread(&TermId3, 4, 1, fColoc); TermId3=TUInt::JavaUIntToCppUInt(TermId3);
106      fread(&CorpusFq, 4, 1, fColoc);
107      fread(&DocFq, 4, 1, fColoc);
108      fread(&Sig, 8, 1, fColoc);
109      TStr TermStr1; TStr TermStr2; TStr TermStr3; 
110      if (TermIdToStrH.IsKeyGetDat(TermId1, TermStr1)){
111        if (TermIdToStrH.IsKeyGetDat(TermId2, TermStr2)){
112          if (TermIdToStrH.IsKeyGetDat(TermId3, TermStr3)){
113            TStrV TermStrV(3, 0); 
114            TermStrV.Add(TermStr1); TermStrV.Add(TermStr2); TermStrV.Add(TermStr3);
115            NytNGramBs->TermStrVH.AddDat(TermStrV);
116          } else {BadColocs++;}
117        } else {BadColocs++;}
118      } else {BadColocs++;}
119    }
120    printf("Colocations:%d Bad Collocations:%d\nDone.\n", Colocs, BadColocs);}
121    {printf("Load Collocations from '%s' ...\n", Coloc4FNm.CStr());
122    FILE* fColoc=fopen(Coloc4FNm.CStr(), "rb");
123    int Colocs=0; int BadColocs=0;
124    while (!feof(fColoc)){
125      Colocs++; if (Colocs%1000==0){printf("%d\r", Colocs);}
126      int TermId1=-1; int TermId2=-1; int TermId3=-1; int TermId4=-1; 
127      int CorpusFq=-1; int DocFq=-1; double Sig=-1;
128      fread(&TermId1, 4, 1, fColoc); TermId1=TUInt::JavaUIntToCppUInt(TermId1);
129      fread(&TermId2, 4, 1, fColoc); TermId2=TUInt::JavaUIntToCppUInt(TermId2);
130      fread(&TermId3, 4, 1, fColoc); TermId3=TUInt::JavaUIntToCppUInt(TermId3);
131      fread(&TermId4, 4, 1, fColoc); TermId4=TUInt::JavaUIntToCppUInt(TermId4);
132      fread(&CorpusFq, 4, 1, fColoc);
133      fread(&DocFq, 4, 1, fColoc);
134      fread(&Sig, 8, 1, fColoc);
135      TStr TermStr1; TStr TermStr2; TStr TermStr3; TStr TermStr4; 
136      if (TermIdToStrH.IsKeyGetDat(TermId1, TermStr1)){
137        if (TermIdToStrH.IsKeyGetDat(TermId2, TermStr2)){
138          if (TermIdToStrH.IsKeyGetDat(TermId3, TermStr3)){
139            if (TermIdToStrH.IsKeyGetDat(TermId4, TermStr4)){
140              TStrV TermStrV(4, 0); 
141              TermStrV.Add(TermStr1); TermStrV.Add(TermStr2); 
142              TermStrV.Add(TermStr3); TermStrV.Add(TermStr4);
143              NytNGramBs->TermStrVH.AddDat(TermStrV);
144            } else {BadColocs++;}
145          } else {BadColocs++;}
146        } else {BadColocs++;}
147      } else {BadColocs++;}
148    }
149    printf("Colocations:%d Bad Collocations:%d\nDone.\n", Colocs, BadColocs);}
150    printf("All Collocations:%d\n", NytNGramBs->TermStrVH.Len());
151    return NytNGramBs;
152  }
153  void TNytNGramBs::SaveTxt(const TStr& FNm){
154    TFOut FOut(FNm); FILE* fOut=FOut.GetFileId();
155    int NGrams=TermStrVH.Len();
156    for (int NGramId=0; NGramId<NGrams; NGramId++){
157      TStr NGramStr=GetNGramStr(NGramId);
158      fprintf(fOut, "%d\t%s\n", NGramId, NGramStr.CStr());
159    }
160  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-tnt.cpp</h3>
            <pre><code>1  #include "tnt.h"
2  void TTntBinDoc::SaveBinDocV(
3   const TStr& InXmlFPath, const TStr& OutBinFNm, const int& MxDocs){
4    printf("Processing Tnt-News-Xml files from '%s'...\n", InXmlFPath.CStr());
5    TFOut SOut(OutBinFNm);
6    TFFile FFile(InXmlFPath, true); TStr FNm;
7    int Docs=0; int DateDocs=0; uint64 PrevTm=0;
8    while (FFile.Next(FNm)){
9      if ((MxDocs!=-1)&&(Docs>=MxDocs)){break;}
10      PXmlDoc XmlDoc=TXmlDoc::LoadTxt(FNm);
11      PXmlTok ContentTok=XmlDoc->GetTagTok("item|content");
12      TStr DocNm=ContentTok->GetTagTok("swid")->GetArgVal("value");
13      TStr UrlStr=ContentTok->GetTagTok("url")->GetTokStr(false);
14      TStr SubjStr=ContentTok->GetTagTok("title")->GetTokStr(false);
15      TStr FetchedValStr=ContentTok->GetTagTok("fetched")->GetArgVal("value");
16      TXmlTokV EntityTokV; ContentTok->GetTagTokV("annotations|entity", EntityTokV);
17      TStr BodyStr=ContentTok->GetTagTok("body")->GetTokStr(false);
18      TStr DateStr=DocNm.GetSubStr(0, 7);
19      TStr YearStr=DateStr.GetSubStr(0, 3);
20      TStr MonthStr=DateStr.GetSubStr(4, 5);
21      TStr DayStr=DateStr.GetSubStr(6, 7);
22      TTm DateTm(YearStr.GetInt(), MonthStr.GetInt(), DayStr.GetInt());
23      uint64 Tm=TTm::GetMSecsFromTm(DateTm);
24      TStrIntH EntNmToFqH;
25      for (int EntityTokN=0; EntityTokN<EntityTokV.Len(); EntityTokN++){
26        PXmlTok EntityTok=EntityTokV[EntityTokN];
27        if (!EntityTok->IsTag("entity")){continue;}
28        TStr CanonicalNm=EntityTok->GetArgVal("canonical", "");
29        TStr TextStr=EntityTok->GetArgVal("text", "");
30        TStr TypeNm=EntityTok->GetArgVal("type", "");
31        TStr EntNm=CanonicalNm.Empty() ? TextStr : CanonicalNm;
32        EntNmToFqH.AddDat(EntNm)++;
33      }
34      TIntStrPrV FqEntNmPrV; EntNmToFqH.GetDatKeyPrV(FqEntNmPrV); FqEntNmPrV.Sort(false);
35      TChA HeadlineChA=BodyStr.GetSubStr(0, 250);
36      while ((HeadlineChA.Len()>0)&&(HeadlineChA.LastCh()!=' ')){
37        HeadlineChA.Trunc(HeadlineChA.Len()-1);}
38      HeadlineChA+="...";
39      TTntBinDoc Doc(DocNm, Tm, SubjStr, HeadlineChA, FqEntNmPrV);
40      Doc.Save(SOut);
41      if (PrevTm!=Tm){
42        if (PrevTm!=0){printf("\n");}
43        PrevTm=Tm; DateDocs=0;
44      }
45      Docs++; DateDocs++;
46      printf("  %s [Day:%d / All:%d]\r", DateStr.CStr(), DateDocs, Docs);
47    }
48    printf("\nDone.\n");
49  }
50  void TTntBinDoc::LoadBinDocV(const TStr& InBinFNm){
51    printf("Processing Tnt News-Binary file '%s'...\n", InBinFNm.CStr());
52    TFIn SIn(InBinFNm); int Docs=0;
53    while (!SIn.Eof()){
54      TTntBinDoc Doc(SIn);
55      Docs++; printf("%d\r", Docs);
56    }
57    printf("\nDone.\n");
58  }
59  void TTntEnt::GetDocIdV(const TTntBs* TntBs,
60   const uint64& MnTm, const uint64& MxTm, TIntV& DocIdV) const {
61    DocIdV.Gen(GetDocIds(), 0);
62    for (int DocN=0; DocN<GetDocIds(); DocN++){
63      int DocId=GetDocId(DocN);
64      PTntDoc Doc=TntBs->GetDoc(DocId);
65      uint64 DocTm=Doc->GetTm();
66      if (((MnTm==0)||(MnTm<=DocTm))&&((MxTm==0)||(DocTm<MxTm))){
67        DocIdV.Add(DocId);
68      }
69    }
70  }
71  void TTntEnt::GetDocsPerDateV(
72   const TTntBs* TntBs, TStrIntPrV& DateStrDocsPrV, int& Docs) const {
73    TStrIntH DateStrToDocsH; Docs=0;
74    for (int DocN=0; DocN<GetDocIds(); DocN++){
75      int DocId=GetDocId(DocN);
76      PTntDoc Doc=TntBs->GetDoc(DocId);
77      uint64 DocTm=Doc->GetTm();
78      TStr DocDateStr=TTm::GetTmFromMSecs(DocTm).GetWebLogDateStr();
79      DateStrToDocsH.AddDat(DocDateStr)++; Docs++;
80    }
81    DateStrToDocsH.GetKeyDatPrV(DateStrDocsPrV);
82    DateStrDocsPrV.Sort();
83  }
84  void TTntEnt::GetDocCentroid(const TTntBs* TntBs,
85   const int& TopWords, const double& TopWordsWgtSumPrc,
86   TStrFltPrV& WordStrWgtPrV) const {
87    PSwSet SwSet=TSwSet::GetSwSet(swstEn523);
88    PStemmer Stemmer=TStemmer::GetStemmer(stmtPorter);
89    PBowDocBs BowDocBs=TBowDocBs::New(SwSet, Stemmer, NULL);
90    for (int DocN=0; DocN<GetDocIds(); DocN++){
91      int DocId=GetDocId(DocN);
92      PTntDoc Doc=TntBs->GetDoc(DocId);
93      TStr DocStr=Doc->GetContStr();
94      BowDocBs->AddHtmlDoc(TInt::GetStr(DocId), TStrV(), DocStr);
95    }
96    TBowWordWgtType WordWgtType=bwwtNrmTFIDF; 
97    PBowDocWgtBs BowDocWgtBs=TBowDocWgtBs::New(BowDocBs, WordWgtType, 0, 0);
98    PBowSim BowSim=TBowSim::New(bstCos); 
99    TIntV AllDIdV; BowDocBs->GetAllDIdV(AllDIdV);
100    PBowSpV ConceptSpV=TBowClust::GetConceptSpV(BowDocWgtBs, BowSim, AllDIdV);
101    ConceptSpV->GetWordStrWgtPrV(BowDocBs, TopWords, TopWordsWgtSumPrc, WordStrWgtPrV);
102  }
103  void TTntEnt::GetDocCentroid(const TTntBs* TntBs,
104   const PBowDocBs& BowDocBs, const PBowDocWgtBs& BowDocWgtBs,
105   const uint64& MnTm, const TStr& QKwStr, 
106   const int& TopWords, const double& TopWordsWgtSumPrc,
107   int& Docs, TStrFltPrV& WordStrWgtPrV) const {
108    TIntV DocIdV; GetDocIdV(TntBs, MnTm, 0, DocIdV);
109    if (DocIdV.Len()>0){
110    }
111    TIntV BowDIdV(DocIdV.Len(), 0);
112    for (int DocN=0; DocN<DocIdV.Len(); DocN++){
113      int DocId=DocIdV[DocN];
114      TStr BowDocNm=TInt::GetStr(DocId);
115      int BowDId=BowDocBs->GetDId(BowDocNm);
116      if (QKwStr.Empty()){
117        BowDIdV.Add(BowDId);
118      } else {
119        if (BowDocBs->IsDocWordStr(BowDId, QKwStr)){
120          BowDIdV.Add(BowDId);
121        }
122      }
123    }
124    PBowSim BowSim=TBowSim::New(bstCos); 
125    PBowSpV ConceptSpV=TBowClust::GetConceptSpV(BowDocWgtBs, BowSim, BowDIdV);
126    Docs=DocIdV.Len();
127    ConceptSpV->GetWordStrWgtPrV(BowDocBs, TopWords, TopWordsWgtSumPrc, WordStrWgtPrV);
128  }
129  void TTntEnt::GetEntClustV(const TTntBs* TntBs,
130   const uint64& MnTm, const int& MnDocs, const int& MxDocs, const int& Clusts,
131   TVec<TStrFltPrV>& EntNmWgtPrVV) const {
132    EntNmWgtPrVV.Clr();
133    PBowDocBs BowDocBs=TBowDocBs::New();
134    TIntV DocIdV; GetDocIdV(TntBs, MnTm, 0, DocIdV);
135    DocIdV.Reverse();
136    TRnd Rnd(1);
137    DocIdV.Shuffle(Rnd);
138    DocIdV.Trunc(MxDocs);
139    if (DocIdV.Len()<MnDocs){return;}
140    for (int DocN=0; DocN<DocIdV.Len(); DocN++){
141      int DocId=DocIdV[DocN];
142      PTntDoc Doc=TntBs->GetDoc(DocId);
143      TIntFltPrV WIdWgtPrV;
144      for (int EntN=0; EntN<Doc->GetEnts(); EntN++){
145        int EntId; int EntFq; Doc->GetEntNmFq(EntN, EntId, EntFq);
146        TStr EntNm=TntBs->GetEntNm(EntId);
147        int EntWId=BowDocBs->AddWordStr(EntNm);
148        WIdWgtPrV.Add(TIntFltPr(EntWId, EntFq));
149      }
150      int DId=BowDocBs->AddDoc(TInt::GetStr(DocId), TStrV(), WIdWgtPrV);
151      TStr DocDescStr=Doc->GetSubjStr();
152      BowDocBs->PutDocDescStr(DId, DocDescStr);
153    }
154    PBowSim BowSim=TBowSim::New(bstCos); 
155    TBowWordWgtType WordWgtType=bwwtNrmTFIDF; 
156    PBowDocPart BowDocPart=TBowClust::GetKMeansPart(
157     TNotify::StdNotify, 
158     BowDocBs, 
159     BowSim, 
160     Rnd, 
161     Clusts, 
162     1, 
163     1, 
164     1, 
165     WordWgtType, 
166     0, 
167     0); 
168    EntNmWgtPrVV.Clr();
169    for (int ClustN=0; ClustN<BowDocPart->GetClusts(); ClustN++){
170      PBowDocPartClust Clust=BowDocPart->GetClust(ClustN);
171      TStrFltPrV WordStrWgtPrV;
172      Clust->GetTopWordStrWgtPrV(BowDocBs, 25, 0.5, WordStrWgtPrV);
173      EntNmWgtPrVV.Add(WordStrWgtPrV);
174    }
175  }
176  void TTntEnt::GetSorted_LinkWgtDstEntIdPrV(
177   const uint64& MnTm, const double& TopWgtSumPrc, TIntPrV& LinkWgtDstEntIdPrV) const {
178    double AllLinkWgtSum=0;
179    TIntIntH DstEntIdLinkWgtH;
180    int LinkEnts=GetLinkEnts();
181    for (int LinkEntN=0; LinkEntN<LinkEnts; LinkEntN++){
182      int DstEntId=GetLinkEntId(LinkEntN);
183      int EntLinks=GetEntLinks(LinkEntN);
184      int EntLinkWgtSum=0;
185      for (int EntLinkN=0; EntLinkN<EntLinks; EntLinkN++){
186        const TTntEntLinkCtx& EntLinkCtx=GetEntLinkCtx(LinkEntN, EntLinkN);
187        if (EntLinkCtx.Tm>=MnTm){
188          EntLinkWgtSum+=EntLinkCtx.LinkWgt;}
189      }
190      if (EntLinkWgtSum>0){
191        DstEntIdLinkWgtH.AddDat(DstEntId, EntLinkWgtSum);}
192      AllLinkWgtSum+=EntLinkWgtSum;
193    }
194    LinkWgtDstEntIdPrV.Clr(); DstEntIdLinkWgtH.GetDatKeyPrV(LinkWgtDstEntIdPrV);
195    LinkWgtDstEntIdPrV.Sort(false);
196    if ((TopWgtSumPrc>0.0)&&(LinkWgtDstEntIdPrV.Len()>0)){
197      int TopLinkWgt=LinkWgtDstEntIdPrV[0].Val1;
198      if (TopLinkWgt>(3*AllLinkWgtSum)/LinkWgtDstEntIdPrV.Len()){
199        double CutWgtSum=AllLinkWgtSum*(1-TopWgtSumPrc);
200        int LastValN=LinkWgtDstEntIdPrV.Len()-1;
201        while ((LastValN>0)&&(CutWgtSum>0)){
202          CutWgtSum-=LinkWgtDstEntIdPrV[LastValN].Val1;
203          LastValN--;
204        }
205        LinkWgtDstEntIdPrV.Trunc(LastValN+1);
206      }
207    }
208  }
209  void TTntBs::GetSorted_DocsEntIdPrV(TIntPrV& DocsEntIdPrV){
210    TIntIntH EntIdToDocsH;
211    for (int EntId=0; EntId<GetEnts(); EntId++){
212      int Docs=GetEnt(EntId)->GetDocIds();
213      EntIdToDocsH.AddDat(EntId, Docs);
214    }
215    DocsEntIdPrV.Clr(); EntIdToDocsH.GetDatKeyPrV(DocsEntIdPrV);
216    DocsEntIdPrV.Sort(false);
217  }
218  int TTntBs::AddDoc(
219   const TStr& DocNm, const uint64& Tm,
220   const TStr& SubjStr, const TStr& ContStr,
221   const TIntStrPrV FqEntNmPrV){
222    TIntPrV EntIdFqPrV(FqEntNmPrV.Len(), 0);
223    for (int EntN=0; EntN<FqEntNmPrV.Len(); EntN++){
224      TStr EntNm=FqEntNmPrV[EntN].Val2;
225      int EntFq=FqEntNmPrV[EntN].Val1;
226      if (EntFq>=GetMnEntFqPerDoc()){
227        int EntId=AddEnt(EntNm);
228        EntIdFqPrV.Add(TIntPr(EntId, EntFq));
229      }
230    }
231    if (EntIdFqPrV.Len()<GetMnEntsPerDoc()){
232      return -1;}
<span onclick='openModal()' class='match'>233    PTntDoc Doc=
234     TTntDoc::New(DocNm, Tm, SubjStr, ContStr, EntIdFqPrV);
235    int DocId=GetNewDocId();
236    IdToDocH.AddDat(DocId, Doc);
237    for (int EntN=0; EntN<EntIdFqPrV.Len(); EntN++){
238      int EntId=EntIdFqPrV[EntN].Val1;
</span>239      GetEnt(EntId)->PushDocId(DocId);
240    }
241    int EntLinkWgtSum=0;
242    for (int EntN1=0; EntN1<EntIdFqPrV.Len(); EntN1++){
243      int EntId1=EntIdFqPrV[EntN1].Val1;
244      PTntEnt Ent1=GetEnt(EntId1);
245      int EntWgt1=EntIdFqPrV[EntN1].Val2;
246      for (int EntN2=0; EntN2<EntIdFqPrV.Len(); EntN2++){
247        if (EntN1==EntN2){continue;}
248        int EntId2=EntIdFqPrV[EntN2].Val1;
249        int EntWgt2=EntIdFqPrV[EntN2].Val2;
250        int EntLinkWgt=EntWgt1*EntWgt2;
251        EntLinkWgtSum+=EntLinkWgt;
252        TTntEntLinkCtx LinkCtx(EntLinkWgt, DocId, Tm);
253        Ent1->AddLink(EntId2, LinkCtx);
254      }
255    }
256    return DocId;
257  }
258  void TTntBs::GetMnMxDocTm(uint64& MnDocTm, uint64& MxDocTm) const {
259    MnDocTm=TUInt64::Mx; MxDocTm=TUInt64::Mn;
260    TTntIdDocPrV IdDocPrV; GetIdDocPrV(IdDocPrV); int Docs=IdDocPrV.Len();
261    for (int DocN=0; DocN<Docs; DocN++){
262      uint64 Tm=IdDocPrV[DocN].Val2->GetTm();
263      if (Tm<MnDocTm){MnDocTm=Tm;}
264      if (Tm>MxDocTm){MxDocTm=Tm;}
265    }
266  }
267  PBowDocBs TTntBs::GetBowDocBs(
268   const int& MxNGramLen, const int& MnNGramFq) const {
269    PSwSet SwSet=TSwSet::GetSwSet(swstEn523);
270    PStemmer Stemmer=TStemmer::GetStemmer(stmtPorter);
271    PNGramBs NGramBs;
272    if (!((MxNGramLen==1)&&(MnNGramFq==1))){
273      TStrV HtmlStrV;
274      TTntIdDocPrV IdDocPrV; GetIdDocPrV(IdDocPrV);
275      for (int DocN=0; DocN<IdDocPrV.Len(); DocN++){
276        PTntDoc Doc=IdDocPrV[DocN].Val2;
277        TStr DocStr=Doc->GetContStr();
278        HtmlStrV.Add(DocStr);
279      }
280      NGramBs=TNGramBs::GetNGramBsFromHtmlStrV(
281       HtmlStrV, MxNGramLen, MnNGramFq, SwSet, Stemmer);
282    }
283    PBowDocBs BowDocBs=TBowDocBs::New(SwSet, Stemmer, NGramBs);
284    TTntIdDocPrV IdDocPrV; GetIdDocPrV(IdDocPrV);
285    for (int DocN=0; DocN<IdDocPrV.Len(); DocN++){
286      int DocId=IdDocPrV[DocN].Val1;
287      PTntDoc Doc=IdDocPrV[DocN].Val2;
288      TStr DocStr=Doc->GetContStr();
289      BowDocBs->AddHtmlDoc(TInt::GetStr(DocId), TStrV(), DocStr);
290    }
291    return BowDocBs;
292  }
293  PBowDocWgtBs TTntBs::GetBowDocWgtBs(const PBowDocBs& BowDocBs) const {
294    TBowWordWgtType WordWgtType=bwwtNrmTFIDF;
295    PBowDocWgtBs BowDocWgtBs=TBowDocWgtBs::New(BowDocBs, WordWgtType, 0, 0);
296    return BowDocWgtBs;
297  }
298  void TTntBs::GetWordStrWgtPrVDiff(
299   const TStrFltPrV& OldWordStrWgtPrV, const TStrFltPrV& NewWordStrWgtPrV,
300   TStrFltPrV& NegDiffWordStrWgtPrV, TStrFltPrV& PosDiffWordStrWgtPrV){
301    TStrFltH WordStrToWgtH;
302    for (int WordN=0; WordN<NewWordStrWgtPrV.Len(); WordN++){
303      TStr WStr=NewWordStrWgtPrV[WordN].Val1;
304      double WWgt=NewWordStrWgtPrV[WordN].Val2;
305      WordStrToWgtH.AddDat(WStr, WWgt);
306    }
307    for (int WordN=0; WordN<OldWordStrWgtPrV.Len(); WordN++){
308      TStr WStr=OldWordStrWgtPrV[WordN].Val1;
309      double WWgt=OldWordStrWgtPrV[WordN].Val2;
310      double CurWWgt=WordStrToWgtH.AddDat(WStr);
311      WordStrToWgtH.AddDat(WStr, CurWWgt-WWgt);
312    }
313    TFltStrPrV DiffWordWgtStrPrV; WordStrToWgtH.GetDatKeyPrV(DiffWordWgtStrPrV);
314    DiffWordWgtStrPrV.Sort(true);
315    NegDiffWordStrWgtPrV.Gen(DiffWordWgtStrPrV.Len(), 0);
316    for (int WordN=0; WordN<DiffWordWgtStrPrV.Len(); WordN++){
317      TStr WStr=DiffWordWgtStrPrV[WordN].Val2;
318      double WWgt=DiffWordWgtStrPrV[WordN].Val1;
319      if (WWgt!=0){NegDiffWordStrWgtPrV.Add(TStrFltPr(WStr, WWgt));}
320    }
321    DiffWordWgtStrPrV.Sort(false);
322    PosDiffWordStrWgtPrV.Gen(DiffWordWgtStrPrV.Len(), 0);
323    for (int WordN=0; WordN<DiffWordWgtStrPrV.Len(); WordN++){
324      TStr WStr=DiffWordWgtStrPrV[WordN].Val2;
325      double WWgt=DiffWordWgtStrPrV[WordN].Val1;
326      if (WWgt!=0){PosDiffWordStrWgtPrV.Add(TStrFltPr(WStr, WWgt));}
327    }
328  }
329  void TTntBs::GetWordStrWgtPrV(const TStrFltPrV& WordStrWgtPrV, 
330   TChA& WordStrWgtPrVChA, TChA& WordStrWgtPrVXmlChA){
331    WordStrWgtPrVChA.Clr(); WordStrWgtPrVXmlChA.Clr();
332    for (int WordN=0; WordN<WordStrWgtPrV.Len(); WordN++){
333      TStr WStr=WordStrWgtPrV[WordN].Val1;
334      TStr XmlWStr=TXmlLx::GetXmlStrFromPlainStr(WStr);
335      double WWgt=WordStrWgtPrV[WordN].Val2;
336      if (WordN>0){WordStrWgtPrVChA+=' ';}
337      WordStrWgtPrVChA+=TStr::Fmt("['%s':%.3f]", WStr.CStr(), WWgt);
338      WordStrWgtPrVXmlChA+=TStr::Fmt("<Kw str=\"%s\" wgt=\"%.3f\"/>", XmlWStr.CStr(), WWgt);
339    }
340  }
341  void TTntBs::GetLinkWgtDstEntIdPrVDiff(
342   const TIntPrV& OldLinkWgtDstEntIdPrV, const TIntPrV& NewLinkWgtDstEntIdPrV,
343   TIntPrV& NegDiffLinkWgtDstEntIdPrV, TIntPrV& PosDiffLinkWgtDstEntIdPrV){
344    TIntIntH DstEntIdToLinkWgtH;
345    for (int WordN=0; WordN<NewLinkWgtDstEntIdPrV.Len(); WordN++){
346      int LinkWgt=NewLinkWgtDstEntIdPrV[WordN].Val1;
347      int DstEntId=NewLinkWgtDstEntIdPrV[WordN].Val2;
348      DstEntIdToLinkWgtH.AddDat(DstEntId, LinkWgt);
349    }
350    for (int WordN=0; WordN<OldLinkWgtDstEntIdPrV.Len(); WordN++){
351      int LinkWgt=OldLinkWgtDstEntIdPrV[WordN].Val1;
352      int DstEntId=OldLinkWgtDstEntIdPrV[WordN].Val2;
353      int CurLinkWgt=DstEntIdToLinkWgtH.AddDat(DstEntId);
354      DstEntIdToLinkWgtH.AddDat(DstEntId, CurLinkWgt-LinkWgt);
355    }
356    TIntPrV _DiffLinkWgtDstEntIdPrV;
357    DstEntIdToLinkWgtH.GetDatKeyPrV(_DiffLinkWgtDstEntIdPrV);
358    TIntPrV DiffLinkWgtDstEntIdPrV(_DiffLinkWgtDstEntIdPrV.Len(), 0);
359    for (int EntN=0; EntN<_DiffLinkWgtDstEntIdPrV.Len(); EntN++){
360      int LinkWgt=_DiffLinkWgtDstEntIdPrV[EntN].Val1;
361      if (LinkWgt!=0){
362        DiffLinkWgtDstEntIdPrV.Add(_DiffLinkWgtDstEntIdPrV[EntN]);}
363    }
364    DiffLinkWgtDstEntIdPrV.Sort(true);
365    NegDiffLinkWgtDstEntIdPrV=DiffLinkWgtDstEntIdPrV;
366    DiffLinkWgtDstEntIdPrV.Sort(false);
367    PosDiffLinkWgtDstEntIdPrV=DiffLinkWgtDstEntIdPrV;
368  }
369  void TTntBs::GetLinkWgtDstEntNmPrV(const TIntPrV& LinkWgtDstEntIdPrV, 
370   TStrIntPrV& LinkWgtDstEntNmPrV, TChA& LinkWgtDstEntIdPrVChA, TChA& LinkWgtDstEntIdPrVXmlChA){
371    LinkWgtDstEntNmPrV.Clr(); LinkWgtDstEntIdPrVChA.Clr(); LinkWgtDstEntIdPrVXmlChA.Clr();
372    for (int DstEntN=0; DstEntN<LinkWgtDstEntIdPrV.Len(); DstEntN++){
373      int DstEntId=LinkWgtDstEntIdPrV[DstEntN].Val2;
374      TStr DstEntNm=GetEntNm(DstEntId);
375      TStr XmlDstEntNm=TXmlLx::GetXmlStrFromPlainStr(DstEntNm);
376      int LinkWgt=LinkWgtDstEntIdPrV[DstEntN].Val1;
377      LinkWgtDstEntNmPrV.Add(TStrIntPr(DstEntNm, LinkWgt));
378      if (DstEntN>0){LinkWgtDstEntIdPrVChA+=' ';}
379      LinkWgtDstEntIdPrVChA+=TStr::Fmt("['%s':%d]", DstEntNm.CStr(), LinkWgt);
380      LinkWgtDstEntIdPrVXmlChA+=TStr::Fmt("<Ent name=\"%s\" wgt=\"%d\"/>", XmlDstEntNm.CStr(), LinkWgt);
381    }
382  }
383  void TTntBs::GetSchTmV(const TStr& SchNm, const uint64& PivotTm, TUInt64V& SchTmMSecsV){
384    SchTmMSecsV.Clr();
385    if (SchNm=="dayexp"){
386      SchTmMSecsV.Add(PivotTm-0*TTmInfo::GetDayMSecs());
387      SchTmMSecsV.Add(PivotTm-1*TTmInfo::GetDayMSecs());
388      SchTmMSecsV.Add(PivotTm-2*TTmInfo::GetDayMSecs());
389      SchTmMSecsV.Add(PivotTm-4*TTmInfo::GetDayMSecs());
390      SchTmMSecsV.Add(PivotTm-8*TTmInfo::GetDayMSecs());
391      SchTmMSecsV.Add(PivotTm-16*TTmInfo::GetDayMSecs());
392      SchTmMSecsV.Add(PivotTm-32*TTmInfo::GetDayMSecs());
393      SchTmMSecsV.Add(PivotTm-64*TTmInfo::GetDayMSecs());
394    } else 
395    if (SchNm=="day"){
396      SchTmMSecsV.Add(PivotTm-0*TTmInfo::GetDayMSecs());
397      SchTmMSecsV.Add(PivotTm-1*TTmInfo::GetDayMSecs());
398      SchTmMSecsV.Add(PivotTm-2*TTmInfo::GetDayMSecs());
399      SchTmMSecsV.Add(PivotTm-3*TTmInfo::GetDayMSecs());
400      SchTmMSecsV.Add(PivotTm-4*TTmInfo::GetDayMSecs());
401      SchTmMSecsV.Add(PivotTm-5*TTmInfo::GetDayMSecs());
402      SchTmMSecsV.Add(PivotTm-6*TTmInfo::GetDayMSecs());
403      SchTmMSecsV.Add(PivotTm-7*TTmInfo::GetDayMSecs());
404    } else 
405    if (SchNm=="week"){
406      SchTmMSecsV.Add(PivotTm-0*TTmInfo::GetDayMSecs());
407      SchTmMSecsV.Add(PivotTm-7*TTmInfo::GetDayMSecs());
408      SchTmMSecsV.Add(PivotTm-14*TTmInfo::GetDayMSecs());
409      SchTmMSecsV.Add(PivotTm-21*TTmInfo::GetDayMSecs());
410      SchTmMSecsV.Add(PivotTm-28*TTmInfo::GetDayMSecs());
411      SchTmMSecsV.Add(PivotTm-35*TTmInfo::GetDayMSecs());
412      SchTmMSecsV.Add(PivotTm-42*TTmInfo::GetDayMSecs());
413      SchTmMSecsV.Add(PivotTm-49*TTmInfo::GetDayMSecs());
414    } else 
415    if (SchNm=="month"){
416      SchTmMSecsV.Add(PivotTm-0*TTmInfo::GetDayMSecs());
417      SchTmMSecsV.Add(PivotTm-30*TTmInfo::GetDayMSecs());
418      SchTmMSecsV.Add(PivotTm-60*TTmInfo::GetDayMSecs());
419      SchTmMSecsV.Add(PivotTm-90*TTmInfo::GetDayMSecs());
420      SchTmMSecsV.Add(PivotTm-120*TTmInfo::GetDayMSecs());
421      SchTmMSecsV.Add(PivotTm-150*TTmInfo::GetDayMSecs());
422      SchTmMSecsV.Add(PivotTm-180*TTmInfo::GetDayMSecs());
423      SchTmMSecsV.Add(PivotTm-210*TTmInfo::GetDayMSecs());
424    } else 
425  	  if (SchNm=="year"){
426      SchTmMSecsV.Add(PivotTm-0*TTmInfo::GetDayMSecs());
427      SchTmMSecsV.Add(PivotTm-364*TTmInfo::GetDayMSecs());
428      SchTmMSecsV.Add(PivotTm-728*TTmInfo::GetDayMSecs());
429      SchTmMSecsV.Add(PivotTm-1092*TTmInfo::GetDayMSecs());
430      SchTmMSecsV.Add(PivotTm-1457*TTmInfo::GetDayMSecs());
431      SchTmMSecsV.Add(PivotTm-1821*TTmInfo::GetDayMSecs());
432      SchTmMSecsV.Add(PivotTm-2185*TTmInfo::GetDayMSecs());
433      SchTmMSecsV.Add(PivotTm-2550*TTmInfo::GetDayMSecs());
434    } else {
435      FailR("Invalid Time Schedule");
436    }
437  }
438  void TTntBs::Search(
439   const PBowDocBs& TntBsBowDocBs, const PBowDocWgtBs& TntBsBowDocWgtBs, 
440   const TStr& QTmStr, const TStr& QSchNm, 
441   const TStr& QWcEntNm, const TStr& QKwStr,
442   PTntRSet& TntRSet, const TStr& OutXmlFNm, const TStr& OutTxtFNm){
443    TTm QTm=TTm::GetTmFromWebLogDateTimeStr(QTmStr);
444    if (!QTm.IsDef()){
445      uint64 MnDocTm; uint64 MxDocTm; GetMnMxDocTm(MnDocTm, MxDocTm);
446      QTm=TTm::GetTmFromMSecs(MxDocTm);
447    }
448    TTm RawPivotTm=QTm;
449    TStr RawPivotTmStr=RawPivotTm.GetWebLogDateTimeStr();
450    TTm PivotTm=TTm::GetTmFromWebLogDateTimeStr(RawPivotTm.GetWebLogDateStr());
451    TStr PivotTmStr=PivotTm.GetWebLogDateTimeStr();
452    uint64 PivotTmMSecs=TTm::GetMSecsFromTm(PivotTm);
453    TUInt64V SchTmMSecsV; GetSchTmV(QSchNm, PivotTmMSecs, SchTmMSecsV);
454    TStr NrQKwStr=QKwStr.GetUc();
455    TntRSet=TTntRSet::New();
456    TntRSet->PutQStrs(QTmStr, QSchNm, QWcEntNm, QKwStr);
457    TntRSet->PutPivotTm(RawPivotTm, PivotTm);
458    TFOut XmlFOut(OutXmlFNm); FILE* fXmlOut=XmlFOut.GetFileId();
459    fprintf(fXmlOut, "<TntProfile>\n");
460    TFOut TxtFOut(OutTxtFNm); FILE* fTxtOut=TxtFOut.GetFileId();
461    TIntPrV DocsEntIdPrV; GetSorted_DocsEntIdPrV(DocsEntIdPrV);
462    for (int EntN=0; EntN<DocsEntIdPrV.Len(); EntN++){
463      int EntId=DocsEntIdPrV[EntN].Val2;
464      TStr EntNm=GetEntNm(EntId);
465      if (!QWcEntNm.Empty()&&(!EntNm.IsWcMatch(QWcEntNm))){continue;}
466      PTntEntRSet EntRSet=TTntEntRSet::New();
467      EntRSet->PutEntNm(EntNm);
468      TntRSet->AddEntRSet(EntRSet);
469      int EntDocs=DocsEntIdPrV[EntN].Val1;
470      PTntEnt Ent=GetEnt(EntId);
471      int LinkEnts=Ent->GetLinkEnts();
472      fprintf(fXmlOut, "<Entity name=\"%s\" docs=\"%d\" ents=\"%d\">\n", EntNm.CStr(), EntDocs, LinkEnts);
473      fprintf(fTxtOut, "'%s' [%d docs] [%d ents]\n", EntNm.CStr(), EntDocs, LinkEnts);
474      {TStrIntPrV DateStrDocsPrV; int _EntDocs;
475      Ent->GetDocsPerDateV(this, DateStrDocsPrV, _EntDocs);
476      fprintf(fXmlOut, "<DatesDocs docs=\"%d\">\n", _EntDocs);
477      fprintf(fTxtOut, "   Docs per Date (%d docs):", _EntDocs);
478      for (int DateN=0; DateN<DateStrDocsPrV.Len(); DateN++){
479        TStr DateStr=DateStrDocsPrV[DateN].Val1;
480        int Docs=DateStrDocsPrV[DateN].Val2;
481        fprintf(fXmlOut, "  <DateDoc date=\"%s\" docs=\"%d\"/>\n", DateStr.CStr(), Docs);
482        fprintf(fTxtOut, " [%s:%d]", DateStr.CStr(), Docs);
483      }
484      fprintf(fXmlOut, "</DatesDocs>\n");
485      fprintf(fTxtOut, "\n");}
486      fprintf(fXmlOut, "<TimeSlices start-time=\"%s\">\n", RawPivotTmStr.CStr());
487      fprintf(fTxtOut, "   [Now: %s]\n", RawPivotTmStr.CStr());
488      TIntPrV PrevLinkWgtDstEntIdPrV;
489      TStrFltPrV PrevWordStrWgtPrV;
490      for (int SchTmN=0; SchTmN<SchTmMSecsV.Len(); SchTmN++){
491        uint64 StartTmMSecs=SchTmMSecsV[SchTmN];
492        TStr StartTmStr=TTm::GetTmFromMSecs(StartTmMSecs).GetWebLogDateTimeStr();
493        double PastDays=-1*((PivotTmMSecs-StartTmMSecs)/double(TTmInfo::GetDayMSecs()));
494        TStr EndTmStr;
495        if (SchTmN==0){EndTmStr=RawPivotTmStr;} 
496        else {EndTmStr=TTm::GetTmFromMSecs(SchTmMSecsV[SchTmN-1]).GetWebLogDateTimeStr();}
497        uint64 EndTmMSecs=TTm::GetMSecsFromTm(TTm::GetTmFromWebLogDateTimeStr(EndTmStr));
498        PTntEntRSet_TmSlice TmSlice=TTntEntRSet_TmSlice::New();
499        TmSlice->PutStartEndTm(StartTmMSecs, EndTmMSecs);
500        EntRSet->AddTmSlice(TmSlice);
501        fprintf(fXmlOut, "<TimeSlice start-time=\"%s\" end-time=\"%s\" past-days=\"%.1f\">\n", 
502         StartTmStr.CStr(), EndTmStr.CStr(), PastDays);
503        TIntPrV LinkWgtDstEntIdPrV;
504        Ent->GetSorted_LinkWgtDstEntIdPrV(StartTmMSecs, 0.9, LinkWgtDstEntIdPrV);
505        fprintf(fXmlOut, "<SocialProfile>\n");
506        int TopLinkEnts=LinkWgtDstEntIdPrV.Len();
507        TStrIntPrV LinkWgtDstEntNmPrV; TChA LinkWgtDstEntIdPrVChA; TChA LinkWgtDstEntIdPrVXmlChA;
508        GetLinkWgtDstEntNmPrV(LinkWgtDstEntIdPrV, 
509         LinkWgtDstEntNmPrV, LinkWgtDstEntIdPrVChA, LinkWgtDstEntIdPrVXmlChA);
510        TmSlice->PutLinkWgtDstEntNmPrV(LinkWgtDstEntNmPrV);
511        fprintf(fXmlOut, "  <Entities ents=\"%d\">%s</Entities>\n", TopLinkEnts, LinkWgtDstEntIdPrVXmlChA.CStr());
512        fprintf(fTxtOut, "      Entities (%d ents): %s\n", TopLinkEnts, LinkWgtDstEntIdPrVChA.CStr());
513        if (SchTmN>0){
514          TIntPrV NegDiffLinkWgtDstEntIdPrV; TIntPrV PosDiffLinkWgtDstEntIdPrV;
515          GetLinkWgtDstEntIdPrVDiff(LinkWgtDstEntIdPrV, PrevLinkWgtDstEntIdPrV,
516           NegDiffLinkWgtDstEntIdPrV, PosDiffLinkWgtDstEntIdPrV);
517          TStrIntPrV PosDiffLinkWgtDstEntNmPrV; TChA PosDiffLinkWgtDstEntIdPrVChA; TChA PosDiffLinkWgtDstEntIdPrVXmlChA;
518          GetLinkWgtDstEntNmPrV(PosDiffLinkWgtDstEntIdPrV, 
519           PosDiffLinkWgtDstEntNmPrV, PosDiffLinkWgtDstEntIdPrVChA, PosDiffLinkWgtDstEntIdPrVXmlChA);
520          TmSlice->PutPosDiffLinkWgtDstEntNmPrV(PosDiffLinkWgtDstEntNmPrV);
521          fprintf(fXmlOut, "  <RisingEntities>%s</RisingEntities>\n", PosDiffLinkWgtDstEntIdPrVXmlChA.CStr());
522          fprintf(fTxtOut, "         Pos-Diff: %s\n", PosDiffLinkWgtDstEntIdPrVChA.CStr());
523          TStrIntPrV NegDiffLinkWgtDstEntNmPrV; TChA NegDiffLinkWgtDstEntIdPrVChA; TChA NegDiffLinkWgtDstEntIdPrVXmlChA;
524          GetLinkWgtDstEntNmPrV(NegDiffLinkWgtDstEntIdPrV, 
525           NegDiffLinkWgtDstEntNmPrV, NegDiffLinkWgtDstEntIdPrVChA, NegDiffLinkWgtDstEntIdPrVXmlChA);
526          TmSlice->PutNegDiffLinkWgtDstEntNmPrV(NegDiffLinkWgtDstEntNmPrV);
527          fprintf(fXmlOut, "  <FallingEntities>%s</FallingEntities>\n", NegDiffLinkWgtDstEntIdPrVXmlChA.CStr());
528          fprintf(fTxtOut, "         Neg-Diff: %s\n", NegDiffLinkWgtDstEntIdPrVChA.CStr());
529        }
530        PrevLinkWgtDstEntIdPrV=LinkWgtDstEntIdPrV;
531        fprintf(fXmlOut, "</SocialProfile>\n");
532        int CtrDocs; TStrFltPrV WordStrWgtPrV;
533        Ent->GetDocCentroid(this, TntBsBowDocBs, TntBsBowDocWgtBs, StartTmMSecs, NrQKwStr, 150, 0.9, CtrDocs, WordStrWgtPrV);
534        fprintf(fXmlOut, "<ContentProfile>\n");
535        TChA WordStrWgtPrVChA; TChA WordStrWgtPrVXmlChA; 
536        GetWordStrWgtPrV(WordStrWgtPrV, WordStrWgtPrVChA, WordStrWgtPrVXmlChA);
537        TmSlice->PutWordStrWgtPrV(WordStrWgtPrV);
538        fprintf(fXmlOut, "  <Keywords docs=\"%d\" kwords=\"%d\">%s</Keywords>\n", 
539         CtrDocs, WordStrWgtPrV.Len(), WordStrWgtPrVXmlChA.CStr());
540        fprintf(fTxtOut, "      Centroid (%d docs, %d words): %s\n",
541         CtrDocs, WordStrWgtPrV.Len(), WordStrWgtPrVChA.CStr());
542        if (SchTmN>0){
543          TStrFltPrV NegDiffWordStrWgtPrV; TStrFltPrV PosDiffWordStrWgtPrV;
544          GetWordStrWgtPrVDiff(WordStrWgtPrV, PrevWordStrWgtPrV,
545           NegDiffWordStrWgtPrV, PosDiffWordStrWgtPrV);
546          TChA PosDiffWordStrWgtPrVChA; TChA PosDiffWordStrWgtPrVXmlChA; 
547          GetWordStrWgtPrV(PosDiffWordStrWgtPrV, PosDiffWordStrWgtPrVChA, PosDiffWordStrWgtPrVXmlChA);
548          TmSlice->PutPosDiffWordStrWgtPrV(PosDiffWordStrWgtPrV);
549          fprintf(fXmlOut, "  <RisingKeywords>%s</RisingKeywords>\n", PosDiffWordStrWgtPrVXmlChA.CStr());
550          fprintf(fTxtOut, "         Pos-Diff: %s\n", PosDiffWordStrWgtPrVChA.CStr());
551          TChA NegDiffWordStrWgtPrVChA; TChA NegDiffWordStrWgtPrVXmlChA; 
552          GetWordStrWgtPrV(NegDiffWordStrWgtPrV, NegDiffWordStrWgtPrVChA, NegDiffWordStrWgtPrVXmlChA);
553          TmSlice->PutNegDiffWordStrWgtPrV(NegDiffWordStrWgtPrV);
554          fprintf(fXmlOut, "  <FallingKeywords>%s</FallingKeywords>\n", NegDiffWordStrWgtPrVXmlChA.CStr());
555          fprintf(fTxtOut, "         Neg-Diff: %s\n", NegDiffWordStrWgtPrVChA.CStr());
556        }
557        PrevWordStrWgtPrV=WordStrWgtPrV;
558        fprintf(fXmlOut, "</ContentProfile>\n");
559        fprintf(fXmlOut, "</TimeSlice>\n");
560        fprintf(fTxtOut, "   [%.1f days: %s]\n", PastDays, StartTmStr.CStr());
561      }
562      fprintf(fXmlOut, "</TimeSlices>\n");
563      TVec<TStrFltPrV> EntNmWgtPrVV;
564      Ent->GetEntClustV(this, SchTmMSecsV.Last(), 100, 1000, 15, EntNmWgtPrVV);
565      TntRSet->PutClust(EntNmWgtPrVV);
566      fprintf(fXmlOut, "<SocialClusters>\n");
567      for (int ClustN=0; ClustN<EntNmWgtPrVV.Len(); ClustN++){
568        TStrFltPrV& EntNmWgtPrV=EntNmWgtPrVV[ClustN];
569        fprintf(fXmlOut, "<SocialCluster num=\"%d\">\n", ClustN);
570        fprintf(fTxtOut, "   Clust-%d:", ClustN);
571        for (int EntN=0; EntN<EntNmWgtPrV.Len(); EntN++){
572          TStr EntNm=EntNmWgtPrV[EntN].Val1;
573          double Wgt=EntNmWgtPrV[EntN].Val2;
574          fprintf(fXmlOut, "<Entity name=\"%s\" wgt=\"%.3f\"/>", EntNm.CStr(), Wgt);
575          fprintf(fTxtOut, " ['%s':%.3f]", EntNm.CStr(), Wgt);
576        }
577        fprintf(fXmlOut, "</SocialCluster>\n");
578        fprintf(fTxtOut, "\n");
579      }
580      fprintf(fXmlOut, "</SocialClusters>\n");
581      fprintf(fXmlOut, "</Entity>\n");
582      fprintf(fTxtOut, "\n");
583    }
584    fprintf(fXmlOut, "</TntProfile>\n");
585  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-nytngrams.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-tnt.cpp</div>
                </div>
                <div class="column column_space"><pre><code>65    PNytNGramBs NytNGramBs=TNytNGramBs::New(ExpectedNGrams);
66    int Terms=LexiconSs->GetYLen();
67    TIntStrH TermIdToStrH(Terms*2);
68    for (int TermN=0; TermN<Terms; TermN++){
69      int TermId=LexiconSs->At(0, TermN).GetInt();
</pre></code></div>
                <div class="column column_space"><pre><code>233    PTntDoc Doc=
234     TTntDoc::New(DocNm, Tm, SubjStr, ContStr, EntIdFqPrV);
235    int DocId=GetNewDocId();
236    IdToDocH.AddDat(DocId, Doc);
237    for (int EntN=0; EntN<EntIdFqPrV.Len(); EntN++){
238      int EntId=EntIdFqPrV[EntN].Val1;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    