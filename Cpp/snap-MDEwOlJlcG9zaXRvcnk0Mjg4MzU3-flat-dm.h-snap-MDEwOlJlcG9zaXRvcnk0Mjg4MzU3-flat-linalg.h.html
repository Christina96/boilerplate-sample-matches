
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 6.021897810218978%, Tokens: 11</h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-dm.h</h3>
            <pre><code>1  ClassTP(TDm, PDm)
2  private:
3    TStr Nm;
4  public:
5    TDm(const TStr& _Nm="Untitled-Domain"): Nm(_Nm){}
6    TDm(const TDm& Dm): Nm(Dm.Nm){}
7    virtual ~TDm(){}
8    TDm(TSIn& SIn): Nm(SIn){}
9    static PDm Load(TSIn& SIn);
10    virtual void Save(TSOut& SOut){GetTypeNm(*this).Save(SOut); Nm.Save(SOut);}
11    TDm& operator=(const TDm& Dm){
12      Nm=Dm.Nm; return *this;}
13    virtual void PutNm(const TStr& _Nm){Nm=_Nm;}
14    virtual TStr GetNm() const {return Nm;}
15    virtual int GetClasses() const=0;
16    int GetClassN(const TStr& ClassNm) const;
17    virtual PTbVar GetClass(const int& ClassN=0) const=0;
18    virtual TTbVal GetClassVal(const int& ExN, const int& ClassN=0) const=0;
19    virtual TStr GetClassValStr(const int& ExN, const int& ClassN=0) const=0;
20    virtual int GetAttrs() const=0;
21    int GetAttrN(const TStr& AttrNm) const;
22    virtual PTbVar GetAttr(const int& AttrN) const=0;
23    virtual TTbVal GetAttrVal(const int& ExN, const int& AttrN) const=0;
24    virtual TStr GetAttrValStr(const int& ExN, const int& AttrN) const=0;
25    double GetAttrNrmFlt(const int& ExN, const int& AttrN){
26      return GetAttr(AttrN)->GetVarType()->GetNrmFlt(GetAttrVal(ExN, AttrN));}
27    virtual int GetExs() const=0;
28    virtual PExSet GetExSet() const=0;
29    virtual PDmHd GetDmHd() const=0;
30    static const TStr DNm;
31    static PPp GetPp(const TStr& Nm, const TStr& DNm);
32    static PDm New(const PPp& Pp, const PDm& _Dm=NULL);
33    static PDm LoadFile(
34     const TStr& FNm, const TStr& FType="", const TStr& MemRep="General");
35  };
36  class TClassId{
37  public:
38    static const TStr DNm;
39    static PPp GetPp(const TStr& Nm, const TStr& DNm);
40    static int New(const PPp& Pp, const PDm& Dm, const int& _ClassN=-1);
41  };
42  class TDmCheck{
43  private:
44    PDm Dm;
45  public:
46    TDmCheck(const PDm& _Dm): Dm(_Dm){}
47    bool IsClass(const int& ClassN=0) const {
48      return (0<=ClassN)&&(ClassN<Dm->GetClasses());}
49    bool IsAttr(const int& AttrN) const {
50      return (0<=AttrN)&&(AttrN<Dm->GetAttrs());}
51    bool IsClassDsc(const int& ClassN=0) const {
52      return (Dm->GetClass(ClassN)->GetActVTSet().In(tvtDsc));}
53    bool IsAttrDsc(const int& AttrN) const {
54      return (Dm->GetAttr(AttrN)->GetActVTSet().In(tvtDsc));}
55    bool AreClassesDsc() const;
56    bool AreAttrsDsc() const;
57    bool IsDmDsc() const {
58      return AreClassesDsc()&&AreAttrsDsc();}
59    bool IsDmDsc(const int& ClassN=0) const {
60      return IsClassDsc(ClassN)&&AreAttrsDsc();}
61  };
62  class TGDm: public TDm{
63  private:
64    PTb Tb;
65    TIntV ClassToVarV;
66    TIntV AttrToVarV;
67    TIntV ExToTupV;
68  public:
69    TGDm(const PTb& _Tb, const TStr& _Nm);
70    TGDm(TSIn& SIn):
71      TDm(SIn), Tb(TTb::Load(SIn)),
72      ClassToVarV(SIn), AttrToVarV(SIn), ExToTupV(SIn){}
73    void Save(TSOut& SOut){
74      TDm::Save(SOut); Tb.Save(SOut);
75      ClassToVarV.Save(SOut); AttrToVarV.Save(SOut); ExToTupV.Save(SOut);}
76    TGDm& operator=(const TGDm& GDm){
77      TDm::operator=(GDm); Tb=GDm.Tb;
78      ClassToVarV=GDm.ClassToVarV; AttrToVarV=GDm.AttrToVarV;
79      ExToTupV=GDm.ExToTupV; return *this;}
80    int GetClasses() const {return ClassToVarV.Len();}
81    PTbVar GetClass(const int& ClassN) const {
82      return Tb->GetVar(ClassToVarV[ClassN]);}
83    TTbVal GetClassVal(const int& ExN, const int& ClassN) const {
84      return Tb->GetVal(ExToTupV[ExN], ClassToVarV[ClassN]);}
85    TStr GetClassValStr(const int& ExN, const int& ClassN) const {
86      return Tb->GetValStr(ExToTupV[ExN], ClassToVarV[ClassN]);}
87    int GetAttrs() const {return AttrToVarV.Len();}
88    PTbVar GetAttr(const int& AttrN) const {
89      return Tb->GetVar(AttrToVarV[AttrN]);}
90    TTbVal GetAttrVal(const int& ExN, const int& AttrN) const {
91      return Tb->GetVal(ExToTupV[ExN], AttrToVarV[AttrN]);}
92    TStr GetAttrValStr(const int& ExN, const int& AttrN) const {
93      return Tb->GetValStr(ExToTupV[ExN], AttrToVarV[AttrN]);}
94    int GetExs() const {return ExToTupV.Len();}
95    PExSet GetExSet() const;
96    PDmHd GetDmHd() const;
97    static PDm LoadFile(const TStr& FNm, const TStr& FType="");
98  };
99  class TMDm: public TDm{
100  private:
101    TTbV TbV;
102    TIntPrV ClassToVarV;
103    TIntPrV AttrToVarV;
104    TIntV ExToTupV;
105  public:
106    TMDm(const TStr& _Nm):
107      TDm(_Nm), TbV(), ClassToVarV(), AttrToVarV(), ExToTupV(){}
108    TMDm(TSIn& SIn):
109      TDm(SIn), TbV(SIn), ClassToVarV(SIn), AttrToVarV(SIn), ExToTupV(SIn){}
110    void Save(TSOut& SOut){
111      TDm::Save(SOut); TbV.Save(SOut);
112      ClassToVarV.Save(SOut); AttrToVarV.Save(SOut); ExToTupV.Save(SOut);}
113    TDm& operator=(const TMDm& MDm){
114      TDm::operator=(MDm); TbV=MDm.TbV;
115      ClassToVarV=MDm.ClassToVarV; AttrToVarV=MDm.AttrToVarV;
116      ExToTupV=MDm.ExToTupV; return *this;}
117    int AddTb(const PTb& Tb){return TbV.Add(Tb);}
118    int AddClass(const int& TbN, const int& VarN){
119      return ClassToVarV.Add(TIntPr(TbN, VarN));}
120    int AddAttr(const int& TbN, const int& VarN){
121      return AttrToVarV.Add(TIntPr(TbN, VarN));}
122    int GetClasses() const {return ClassToVarV.Len();}
123    PTbVar GetClass(const int& ClassN) const {
124      return TbV[ClassToVarV[ClassN].Val1]->GetVar(ClassToVarV[ClassN].Val2);}
125    TTbVal GetClassVal(const int& ExN, const int& ClassN) const {
126      return TbV[ClassToVarV[ClassN].Val1]->
127       GetVal(ExToTupV[ExN], ClassToVarV[ClassN].Val2);}
<span onclick='openModal()' class='match'>128    TStr GetClassValStr(const int& ExN, const int& ClassN) const {
129      return TbV[ClassToVarV[ClassN].Val1]->
130       GetValStr(ExToTupV[ExN], ClassToVarV[ClassN].Val2);}
131    int GetAttrs() const {return AttrToVarV.Len();}
</span>132    PTbVar GetAttr(const int& AttrN) const {
133      return TbV[AttrToVarV[AttrN].Val1]->GetVar(AttrToVarV[AttrN].Val2);}
134    TTbVal GetAttrVal(const int& ExN, const int& AttrN) const {
135      return TbV[AttrToVarV[AttrN].Val1]->
136        GetVal(ExToTupV[ExN], AttrToVarV[AttrN].Val2);}
137    TStr GetAttrValStr(const int& ExN, const int& AttrN) const {
138      return TbV[AttrToVarV[AttrN].Val1]->
139        GetValStr(ExToTupV[ExN], AttrToVarV[AttrN].Val2);}
140    int GetExs() const {return ExToTupV.Len();}
141    PExSet GetExSet() const;
142    PDmHd GetDmHd() const;
143  };
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-linalg.h</h3>
            <pre><code>1  class TLinAlg;
2  class TLAMisc;
3  class TMatrix {
4  private:
5      bool Transposed;
6  protected:
7      virtual void PMultiply(const TFltVV& B, int ColId, TFltV& Result) const = 0;
8      virtual void PMultiply(const TFltV& Vec, TFltV& Result) const = 0;
9      virtual void PMultiplyT(const TFltVV& B, int ColId, TFltV& Result) const = 0;
10      virtual void PMultiplyT(const TFltV& Vec, TFltV& Result) const = 0;
11      virtual int PGetRows() const = 0;
12      virtual int PGetCols() const = 0;
13  public:
14      TMatrix(): Transposed(false) {}
15      virtual ~TMatrix() { }
16      void Multiply(const TFltVV& B, int ColId, TFltV& Result) const {
17          if (Transposed) { PMultiplyT(B, ColId, Result); }
18          else { PMultiply(B, ColId, Result); }
19      }
20      void Multiply(const TFltV& Vec, TFltV& Result) const {
21          if (Transposed) { PMultiplyT(Vec, Result); }
22          else { PMultiply(Vec, Result); }
23      }
24      void MultiplyT(const TFltVV& B, int ColId, TFltV& Result) const {
25          if (Transposed) { PMultiply(B, ColId, Result); }
26          else { PMultiplyT(B, ColId, Result); }
27      }
28      void MultiplyT(const TFltV& Vec, TFltV& Result) const{
29          if (Transposed) { PMultiply(Vec, Result); }
30          else { PMultiplyT(Vec, Result); }
31      }
32      int GetRows() const { return Transposed ? PGetCols() : PGetRows(); }
33      int GetCols() const { return Transposed ? PGetRows() : PGetCols(); }
34      void Transpose() { Transposed = !Transposed; }
35  };
36  class TSparseColMatrix: public TMatrix {
37  public:
38      int RowN, ColN;
39      TVec<TIntFltKdV> ColSpVV;
40  protected:
41      virtual void PMultiply(const TFltVV& B, int ColId, TFltV& Result) const;
42      virtual void PMultiply(const TFltV& Vec, TFltV& Result) const;
43      virtual void PMultiplyT(const TFltVV& B, int ColId, TFltV& Result) const;
44      virtual void PMultiplyT(const TFltV& Vec, TFltV& Result) const;
45      int PGetRows() const { return RowN; }
46      int PGetCols() const { return ColN; }
47  public:
48      TSparseColMatrix(): TMatrix() {}
49      TSparseColMatrix(TVec<TIntFltKdV> _ColSpVV): TMatrix(), ColSpVV(_ColSpVV) {}
50      TSparseColMatrix(TVec<TIntFltKdV> _ColSpVV, const int& _RowN, const int& _ColN): 
51  		TMatrix(), RowN(_RowN), ColN(_ColN), ColSpVV(_ColSpVV) {}
52      void Save(TSOut& SOut) {
53          SOut.Save(RowN); SOut.Save(ColN); ColSpVV.Save(SOut); }
54      void Load(TSIn& SIn) {
55          SIn.Load(RowN); SIn.Load(ColN); ColSpVV = TVec<TIntFltKdV>(SIn); }
56  };
57  class TSparseRowMatrix: public TMatrix {
58  public:
59      int RowN, ColN;
60      TVec<TIntFltKdV> RowSpVV;
61  protected:
62      virtual void PMultiply(const TFltVV& B, int ColId, TFltV& Result) const;
63      virtual void PMultiply(const TFltV& Vec, TFltV& Result) const;
64      virtual void PMultiplyT(const TFltVV& B, int ColId, TFltV& Result) const;
65      virtual void PMultiplyT(const TFltV& Vec, TFltV& Result) const;
66      int PGetRows() const { return RowN; }
67      int PGetCols() const { return ColN; }
68  public:
69      TSparseRowMatrix(): TMatrix() {}
70      TSparseRowMatrix(TVec<TIntFltKdV> _RowSpVV): TMatrix(), RowSpVV(_RowSpVV) {}
71      TSparseRowMatrix(TVec<TIntFltKdV> _RowSpVV, const int& _RowN, const int& _ColN): 
72  		TMatrix(), RowN(_RowN), ColN(_ColN), RowSpVV(_RowSpVV) {}
73      TSparseRowMatrix(const TStr& MatlabMatrixFNm);
74      void Save(TSOut& SOut) {
75          SOut.Save(RowN); SOut.Save(ColN); RowSpVV.Save(SOut); }
76      void Load(TSIn& SIn) {
77          SIn.Load(RowN); SIn.Load(ColN); RowSpVV = TVec<TIntFltKdV>(SIn); }
78  };
79  class TFullColMatrix: public TMatrix {
80  public:
81      int RowN, ColN;
82      TVec<TFltV> ColV;
83  protected:
84      virtual void PMultiply(const TFltVV& B, int ColId, TFltV& Result) const;
85      virtual void PMultiply(const TFltV& Vec, TFltV& Result) const;
86      virtual void PMultiplyT(const TFltVV& B, int ColId, TFltV& Result) const;
<span onclick='openModal()' class='match'>87      virtual void PMultiplyT(const TFltV& Vec, TFltV& Result) const;
88      int PGetRows() const { return RowN; }
89      int PGetCols() const { return ColN; }
</span>90  public:
91      TFullColMatrix(): TMatrix() {}
92      TFullColMatrix(const TStr& MatlabMatrixFNm);
93      void Save(TSOut& SOut) { ColV.Save(SOut); }
94      void Load(TSIn& SIn) { ColV.Load(SIn); }
95  };
96  class TLinAlg {
97  public:
98      static double DotProduct(const TFltV& x, const TFltV& y);
99      static double DotProduct(const TFltVV& X, int ColIdX, const TFltVV& Y, int ColIdY);
100      static double DotProduct(const TFltVV& X, int ColId, const TFltV& Vec);
101      static double DotProduct(const TIntFltKdV& x, const TIntFltKdV& y);
102      static double DotProduct(const TFltV& x, const TIntFltKdV& y);
103      static double DotProduct(const TFltVV& X, int ColId, const TIntFltKdV& y);
104      static void LinComb(const double& p, const TFltV& x,
105          const double& q, const TFltV& y, TFltV& z);
106      static void ConvexComb(const double& p, const TFltV& x, const TFltV& y, TFltV& z);
107      static void AddVec(const double& k, const TFltV& x, const TFltV& y, TFltV& z);
108      static void AddVec(const double& k, const TIntFltKdV& x, const TFltV& y, TFltV& z);
109      static void AddVec(const double& k, const TIntFltKdV& x, TFltV& y);
110      static void AddVec(double k, const TFltVV& X, int ColIdX, TFltVV& Y, int ColIdY);
111      static void AddVec(double k, const TFltVV& X, int ColId, TFltV& Result);
112      static void AddVec(const TIntFltKdV& x, const TIntFltKdV& y, TIntFltKdV& z);
113      static double SumVec(const TFltV& x);
114      static double SumVec(double k, const TFltV& x, const TFltV& y);
115      static double EuclDist2(const TFltV& x, const TFltV& y);
116      static double EuclDist2(const TFltPr& x, const TFltPr& y);
117      static double EuclDist(const TFltV& x, const TFltV& y);
118      static double EuclDist(const TFltPr& x, const TFltPr& y);
119      static double Norm2(const TFltV& x);
120      static double Norm(const TFltV& x);
121      static void Normalize(TFltV& x);
122      static double Norm2(const TIntFltKdV& x);
123      static double Norm(const TIntFltKdV& x);
124      static void Normalize(TIntFltKdV& x);
125      static double Norm2(const TFltVV& X, int ColId);
126      static double Norm(const TFltVV& X, int ColId);
127      static double NormL1(const TFltV& x);
128      static double NormL1(double k, const TFltV& x, const TFltV& y);
129      static double NormL1(const TIntFltKdV& x);
130      static void NormalizeL1(TFltV& x);
131      static void NormalizeL1(TIntFltKdV& x);
132      static double NormLinf(const TFltV& x);
133      static double NormLinf(const TIntFltKdV& x);
134      static void NormalizeLinf(TFltV& x);
135      static void NormalizeLinf(TIntFltKdV& x);
136      static void MultiplyScalar(const double& k, const TFltV& x, TFltV& y);
137      static void MultiplyScalar(const double& k, const TIntFltKdV& x, TIntFltKdV& y);
138      static void Multiply(const TFltVV& A, const TFltV& x, TFltV& y);
139      static void Multiply(const TFltVV& A, const TFltV& x, TFltVV& C, int ColId);
140      static void Multiply(const TFltVV& A, const TFltVV& B, int ColId, TFltV& y);
141      static void Multiply(const TFltVV& A, const TFltVV& B, int ColIdB, TFltVV& C, int ColIdC);
142      static void MultiplyT(const TFltVV& A, const TFltV& x, TFltV& y);
143      static void Multiply(const TFltVV& A, const TFltVV& B, TFltVV& C);
144  	typedef enum { GEMM_NO_T = 0, GEMM_A_T = 1, GEMM_B_T = 2, GEMM_C_T = 4 } TLinAlgGemmTranspose;
145  	static void Gemm(const double& Alpha, const TFltVV& A, const TFltVV& B, const double& Beta, 
146  		const TFltVV& C, TFltVV& D, const int& TransposeFlags);
147  	typedef enum { DECOMP_SVD } TLinAlgInverseType;
148  	static void Inverse(const TFltVV& A, TFltVV& B, const TLinAlgInverseType& DecompType);
149  	static void InverseSVD(const TFltVV& A, TFltVV& B);
150  	static void Transpose(const TFltVV& A, TFltVV& B);
151      static void GS(TVec<TFltV>& Q);
152      static void GS(TFltVV& Q);
153      static void Rotate(const double& OldX, const double& OldY, const double& Angle, double& NewX, double& NewY);
154      static void AssertOrtogonality(const TVec<TFltV>& Vecs, const double& Threshold);
155      static void AssertOrtogonality(const TFltVV& Vecs, const double& Threshold);
156  };
157  class TNSException : public TExcept {
158  public:
159      TStr Message;
160  public:
161      TNSException(const TStr& Msg): TExcept(Msg) {}
162  };
163  class TNumericalStuff {
164  private:
165    static double sqr(double a);
166    static double sign(double a, double b);
167    static double pythag(double a, double b);
168    static void nrerror(const TStr& error_text);
169  public:
170      static void SymetricToTridiag(TFltVV& a, int n, TFltV& d, TFltV& e);
171  	static void EigSymmetricTridiag(TFltV& d, TFltV& e, int n, TFltVV& z);
172  	static void CholeskyDecomposition(TFltVV& A, TFltV& p);
173  	static void CholeskySolve(const TFltVV& A, const TFltV& p, const TFltV& b, TFltV& x);
174  	static void SolveSymetricSystem(TFltVV& A, const TFltV& b, TFltV& x);
175      static void InverseSubstitute(TFltVV& A, const TFltV& p);
176      static void InverseSymetric(TFltVV& A);
177      static void InverseTriagonal(TFltVV& A);
178      static void LUDecomposition(TFltVV& A, TIntV& indx, double& d);
179      static void LUSolve(const TFltVV& A, const TIntV& indx, TFltV& b);
180      static void SolveLinearSystem(TFltVV& A, const TFltV& b, TFltV& x);
181  };
182  typedef enum { ssotNoOrto, ssotSelective, ssotFull } TSpSVDReOrtoType;
183  class TSparseSVD {
184  private:
185      static void MultiplyATA(const TMatrix& Matrix,
186          const TFltVV& Vec, int ColId, TFltV& Result);
187      static void MultiplyATA(const TMatrix& Matrix,
188          const TFltV& Vec, TFltV& Result);
189  public:
190      static void SimpleLanczos(const TMatrix& Matrix,
191          const int& NumEig, TFltV& EigValV,
192          const bool& DoLocalReortoP = false,
193          const bool& SvdMatrixProductP = false);
194      static void Lanczos(const TMatrix& Matrix,
195          int NumEig, int Iters, const TSpSVDReOrtoType& ReOrtoType,
196          TFltV& EigValV, TFltVV& EigVecVV,
197          const bool& SvdMatrixProductP = false);
198      static void Lanczos2(const TMatrix& Matrix,
199          int MaxNumEig, int MaxSecs, const TSpSVDReOrtoType& ReOrtoType,
200          TFltV& EigValV, TFltVV& EigVecVV,
201          const bool& SvdMatrixProductP = false);
202      static void SimpleLanczosSVD(const TMatrix& Matrix,
203          const int& CalcSV, TFltV& SngValV,
204          const bool& DoLocalReortoP = false);
205      static void LanczosSVD(const TMatrix& Matrix,
206          int NumSV, int Iters, const TSpSVDReOrtoType& ReOrtoType,
207          TFltV& SgnValV, TFltVV& LeftSgnVecVV, TFltVV& RightSgnVecVV);
208      static void OrtoIterSVD(const TMatrix& Matrix,
209          int NumSV, int IterN, TFltV& SgnValV);
210      static void Project(const TIntFltKdV& Vec, const TFltVV& U, TFltV& ProjVec);
211  };
212  class TSigmoid {
213  private:
214      TFlt A;
215      TFlt B;
216  private:
217    static double EvaluateFit(const TFltIntKdV& data, const double A, const double B);
218    static void EvaluateFit(const TFltIntKdV& data, const double A,
219          const double B, double& J, double& JA, double& JB);
220    static void EvaluateFit(const TFltIntKdV& data, const double A,
221          const double B, const double U, const double V, const double lambda,
222      double& J, double& JJ, double& JJJ);
223  public:
224      TSigmoid() { };
225      TSigmoid(const double& A_, const double& B_): A(A_), B(B_) { };
226      TSigmoid(const TFltIntKdV& data);
227      TSigmoid(TSIn& SIn) { A.Load(SIn); B.Load(SIn); }
228      void Load(TSIn& SIn) { A.Load(SIn); B.Load(SIn); }
229      void Save(TSOut& SOut) const {A.Save(SOut); B.Save(SOut);}
230      double GetVal(const double& x) const {
231          return 1.0 / (1.0 + exp(-A * x + B)); }
232      double operator()(const double& x) const {
233          return GetVal(x); }
234      void GetSigmoidAB(double& A_, double& B_) { A_=A; B_=B; }
235  };
236  class TLAMisc {
237  public:
238      static void SaveCsvTFltV(const TFltV& Vec, TSOut& SOut);
239      static void SaveMatlabTFltIntKdV(const TIntFltKdV& SpV, const int& ColN, TSOut& SOut);
240      static void SaveMatlabTFltV(const TFltV& m, const TStr& FName);
241      static void SaveMatlabTIntV(const TIntV& m, const TStr& FName);
242      static void SaveMatlabTFltVVCol(const TFltVV& m, int ColId, const TStr& FName);
243      static void SaveMatlabTFltVV(const TFltVV& m, const TStr& FName);
244  	static void SaveMatlabTFltVVMjrSubMtrx(const TFltVV& m, int rowN, int colN, const TStr& FName);
245      static void LoadMatlabTFltVV(const TStr& FNm, TVec<TFltV>& ColV);
246      static void LoadMatlabTFltVV(const TStr& FNm, TFltVV& MatrixVV);
247      static void PrintTFltV(const TFltV& Vec, const TStr& VecNm);
248  	static void PrintTFltVV(const TFltVV& A, const TStr& MatrixNm);
249      static void PrintTIntV(const TIntV& Vec, const TStr& VecNm);
250      static void FillRnd(TFltV& Vec) { TRnd Rnd(0); FillRnd(Vec, Rnd); }
251      static void FillRnd(TFltV& Vec, TRnd& Rnd);
252      static void Fill(TFltVV& M, const double& Val);
253      static void FillZero(TFltV& Vec) { Vec.PutAll(0.0); }
254      static void FillZero(TFltVV& M) { Fill(M, 0.0); }
255      static void FillIdentity(TFltVV& M);
256      static void FillIdentity(TFltVV& M, const double& Elt);
257      static int SumVec(const TIntV& Vec);
258      static double SumVec(const TFltV& Vec);
259      static void ToSpVec(const TFltV& Vec, TIntFltKdV& SpVec,
260          const double& CutWordWgtSumPrc = 0.0);
261      static void ToVec(const TIntFltKdV& SpVec, TFltV& Vec, const int& VecLen);
262  };
263  template <class TKey, class TDat>
264  class TSparseOps {
265  private:
266  	typedef TVec<TKeyDat<TKey, TDat> > TKeyDatV;
267  public:
268  	static void SparseMerge(const TKeyDatV& SrcV1, const TKeyDatV& SrcV2, TKeyDatV& DstV) {
269  		DstV.Clr();
270  		const int Src1Len = SrcV1.Len();
271  		const int Src2Len = SrcV2.Len();
272  		int Src1N = 0, Src2N = 0;
273  		while (Src1N < Src1Len && Src2N < Src2Len) {
274  			if (SrcV1[Src1N].Key < SrcV2[Src2N].Key) { 
275  				DstV.Add(SrcV1[Src1N]); Src1N++;
276  			} else if (SrcV1[Src1N].Key > SrcV2[Src2N].Key) { 
277  				DstV.Add(SrcV2[Src2N]); Src2N++;
278  			} else { 
279  				DstV.Add(TKeyDat<TKey, TDat>(SrcV1[Src1N].Key, SrcV1[Src1N].Dat + SrcV2[Src2N].Dat));
280  				Src1N++;  Src2N++; 
281  			}
282  		}
283  		while (Src1N < Src1Len) { DstV.Add(SrcV1[Src1N]); Src1N++; }
284  		while (Src2N < Src2Len) { DstV.Add(SrcV2[Src2N]); Src2N++; }
285  	}
286  };
287  typedef TSparseOps<TInt, TFlt> TSparseOpsIntFlt;
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-dm.h</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-linalg.h</div>
                <div class="column column_space"><pre><code>128    TStr GetClassValStr(const int& ExN, const int& ClassN) const {
129      return TbV[ClassToVarV[ClassN].Val1]->
130       GetValStr(ExToTupV[ExN], ClassToVarV[ClassN].Val2);}
131    int GetAttrs() const {return AttrToVarV.Len();}
</pre></code></div>
                <div class="column column_space"><pre><code>87      virtual void PMultiplyT(const TFltV& Vec, TFltV& Result) const;
88      int PGetRows() const { return RowN; }
89      int PGetCols() const { return ColN; }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    