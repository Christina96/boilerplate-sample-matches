
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 18, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-ScintillaEditBase.cpp</h3>
            <pre><code>1  #include "ScintillaEditBase.h"
2  #include "ScintillaQt.h"
3  #include "PlatQt.h"
4  #include <QApplication>
5  #if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)
6  #include <QInputContext>
7  #endif
8  #include <QPainter>
9  #include <QVarLengthArray>
10  #include <QScrollBar>
11  #include <QTextFormat>
12  constexpr int IndicatorInput = static_cast<int>(Scintilla::IndicatorNumbers::Ime);
13  constexpr int IndicatorTarget = IndicatorInput + 1;
14  constexpr int IndicatorConverted = IndicatorInput + 2;
15  constexpr int IndicatorUnknown = IndicatorInput + 3;
16  #if QT_VERSION >= QT_VERSION_CHECK(5, 0, 0)
17  #ifdef Q_OS_MAC
18  #define Q_WS_MAC 1
19  #endif
20  #if !defined(Q_OS_MAC) && !defined(Q_OS_WIN)
21  #define Q_WS_X11 1
22  #endif
23  #endif 
24  using namespace Scintilla;
25  using namespace Scintilla::Internal;
26  ScintillaEditBase::ScintillaEditBase(QWidget *parent)
27  : QAbstractScrollArea(parent), sqt(new ScintillaQt(this)), preeditPos(-1), wheelDelta(0)
28  {
29  	time.start();
30  	setAcceptDrops(true);
31  	setMouseTracking(true);
32  	setAutoFillBackground(false);
33  	setFrameStyle(QFrame::NoFrame);
34  	setFocusPolicy(Qt::StrongFocus);
35  	setAttribute(Qt::WA_StaticContents);
36  	viewport()->setAutoFillBackground(false);
37  	setAttribute(Qt::WA_KeyCompression);
38  	setAttribute(Qt::WA_InputMethodEnabled);
39  	const ColourRGBA colourIME(0, 0, UCHAR_MAX);
40  	sqt->vs.indicators[IndicatorUnknown] = Indicator(IndicatorStyle::Hidden, colourIME);
41  	sqt->vs.indicators[IndicatorInput] = Indicator(IndicatorStyle::Dots, colourIME);
42  	sqt->vs.indicators[IndicatorConverted] = Indicator(IndicatorStyle::CompositionThick, colourIME);
43  	sqt->vs.indicators[IndicatorTarget] = Indicator(IndicatorStyle::StraightBox, colourIME);
44  	connect(sqt, SIGNAL(notifyParent(Scintilla::NotificationData)),
45  		this, SLOT(notifyParent(Scintilla::NotificationData)));
46  	connect(verticalScrollBar(), SIGNAL(valueChanged(int)),
47  	        this, SLOT(scrollVertical(int)));
48  	connect(horizontalScrollBar(), SIGNAL(valueChanged(int)),
49  	        this, SLOT(scrollHorizontal(int)));
50  	connect(sqt, SIGNAL(horizontalRangeChanged(int,int)),
51  	        this, SIGNAL(horizontalRangeChanged(int,int)));
52  	connect(sqt, SIGNAL(verticalRangeChanged(int,int)),
53  	        this, SIGNAL(verticalRangeChanged(int,int)));
54  	connect(sqt, SIGNAL(horizontalScrolled(int)),
55  	        this, SIGNAL(horizontalScrolled(int)));
56  	connect(sqt, SIGNAL(verticalScrolled(int)),
57  	        this, SIGNAL(verticalScrolled(int)));
58  	connect(sqt, SIGNAL(notifyChange()),
59  	        this, SIGNAL(notifyChange()));
60  	connect(sqt, SIGNAL(command(Scintilla::uptr_t,Scintilla::sptr_t)),
61  		this, SLOT(event_command(Scintilla::uptr_t,Scintilla::sptr_t)));
62  	connect(sqt, SIGNAL(aboutToCopy(QMimeData*)),
63  		this, SIGNAL(aboutToCopy(QMimeData*)));
64  }
65  ScintillaEditBase::~ScintillaEditBase() = default;
66  sptr_t ScintillaEditBase::send(
67  	unsigned int iMessage,
68  	uptr_t wParam,
69  	sptr_t lParam) const
70  {
71  	return sqt->WndProc(static_cast<Message>(iMessage), wParam, lParam);
72  }
73  sptr_t ScintillaEditBase::sends(
74      unsigned int iMessage,
75      uptr_t wParam,
76      const char *s) const
77  {
78  	return sqt->WndProc(static_cast<Message>(iMessage), wParam, reinterpret_cast<sptr_t>(s));
79  }
80  void ScintillaEditBase::scrollHorizontal(int value)
81  {
82  	sqt->HorizontalScrollTo(value);
83  }
84  void ScintillaEditBase::scrollVertical(int value)
85  {
86  	sqt->ScrollTo(value);
87  }
88  bool ScintillaEditBase::event(QEvent *event)
89  {
90  	bool result = false;
91  	if (event->type() == QEvent::KeyPress) {
92  		keyPressEvent(static_cast<QKeyEvent *>(event));
93  		result = event->isAccepted();
94  	} else if (event->type() == QEvent::Show) {
95  		setMouseTracking(true);
96  		result = QAbstractScrollArea::event(event);
97  	} else if (event->type() == QEvent::Hide) {
98  		setMouseTracking(false);
99  		result = QAbstractScrollArea::event(event);
100  	} else {
101  		result = QAbstractScrollArea::event(event);
102  	}
103  	return result;
104  }
105  void ScintillaEditBase::paintEvent(QPaintEvent *event)
106  {
107  	sqt->PartialPaint(PRectFromQRect(event->rect()));
108  }
109  namespace {
110  bool isWheelEventHorizontal(QWheelEvent *event) {
111  #if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
112  	return event->angleDelta().y() == 0;
113  #else
114  	return event->orientation() == Qt::Horizontal;
115  #endif
116  }
117  int wheelEventYDelta(QWheelEvent *event) {
118  #if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
119  	return event->angleDelta().y();
120  #else
121  	return event->delta();
122  #endif
123  }
124  }
125  void ScintillaEditBase::wheelEvent(QWheelEvent *event)
126  {
127  	if (isWheelEventHorizontal(event)) {
128  		QAbstractScrollArea::wheelEvent(event);
129  	} else {
130  		if (QApplication::keyboardModifiers() & Qt::ControlModifier) {
131  			if (wheelEventYDelta(event) > 0) {
132  				sqt->KeyCommand(Message::ZoomIn);
133  			} else {
134  				sqt->KeyCommand(Message::ZoomOut);
135  			}
136  		} else {
137  			QAbstractScrollArea::wheelEvent(event);
138  		}
139  	}
140  }
141  void ScintillaEditBase::focusInEvent(QFocusEvent *event)
142  {
143  	sqt->SetFocusState(true);
144  	QAbstractScrollArea::focusInEvent(event);
145  }
146  void ScintillaEditBase::focusOutEvent(QFocusEvent *event)
147  {
148  	sqt->SetFocusState(false);
149  	QAbstractScrollArea::focusOutEvent(event);
150  }
151  void ScintillaEditBase::resizeEvent(QResizeEvent *)
152  {
153  	sqt->ChangeSize();
154  	emit resized();
155  }
156  void ScintillaEditBase::keyPressEvent(QKeyEvent *event)
157  {
158  	if (QApplication::keyboardModifiers() & Qt::MetaModifier) {
159  		QAbstractScrollArea::keyPressEvent(event);
160  		emit keyPressed(event);
161  		return;
162  	}
163  	int key = 0;
164  	switch (event->key()) {
165  		case Qt::Key_Down:          key = SCK_DOWN;     break;
166  		case Qt::Key_Up:            key = SCK_UP;       break;
167  		case Qt::Key_Left:          key = SCK_LEFT;     break;
168  		case Qt::Key_Right:         key = SCK_RIGHT;    break;
169  		case Qt::Key_Home:          key = SCK_HOME;     break;
170  		case Qt::Key_End:           key = SCK_END;      break;
171  		case Qt::Key_PageUp:        key = SCK_PRIOR;    break;
172  		case Qt::Key_PageDown:      key = SCK_NEXT;     break;
173  		case Qt::Key_Delete:        key = SCK_DELETE;   break;
174  		case Qt::Key_Insert:        key = SCK_INSERT;   break;
175  		case Qt::Key_Escape:        key = SCK_ESCAPE;   break;
176  		case Qt::Key_Backspace:     key = SCK_BACK;     break;
177  		case Qt::Key_Plus:          key = SCK_ADD;      break;
178  		case Qt::Key_Minus:         key = SCK_SUBTRACT; break;
179  		case Qt::Key_Backtab:       
180  		case Qt::Key_Tab:           key = SCK_TAB;      break;
181  		case Qt::Key_Enter:         
182  		case Qt::Key_Return:        key = SCK_RETURN;   break;
183  		case Qt::Key_Control:       key = 0;            break;
184  		case Qt::Key_Alt:           key = 0;            break;
185  		case Qt::Key_Shift:         key = 0;            break;
186  		case Qt::Key_Meta:          key = 0;            break;
187  		default:                    key = event->key(); break;
188  	}
189  	bool shift = QApplication::keyboardModifiers() & Qt::ShiftModifier;
190  	bool ctrl  = QApplication::keyboardModifiers() & Qt::ControlModifier;
191  	bool alt   = QApplication::keyboardModifiers() & Qt::AltModifier;
192  	bool consumed = false;
193  	bool added = sqt->KeyDownWithModifiers(static_cast<Keys>(key),
194  					       ModifierFlags(shift, ctrl, alt),
195  					       &consumed) != 0;
196  	if (!consumed)
197  		consumed = added;
198  	if (!consumed) {
199  		bool input = (!ctrl || alt);
200  #ifndef Q_WS_MAC
201  		input &= (!alt || ctrl);
202  #endif
203  		QString text = event->text();
204  		if (input && !text.isEmpty() && text[0].isPrint()) {
205  			const int strLen = text.length();
206  			for (int i = 0; i < strLen;) {
207  				const int ucWidth = text.at(i).isHighSurrogate() ? 2 : 1;
208  				const QString oneCharUTF16 = text.mid(i, ucWidth);
209  				const QByteArray oneChar = sqt->BytesForDocument(oneCharUTF16);
210  				sqt->InsertCharacter(std::string_view(oneChar.data(), oneChar.length()), CharacterSource::DirectInput);
211  				i += ucWidth;
212  			}
213  		} else {
214  			event->ignore();
215  		}
216  	}
217  	emit keyPressed(event);
218  }
219  static int modifierTranslated(int sciModifier)
220  {
221  	switch (sciModifier) {
222  		case SCMOD_SHIFT:
223  			return Qt::ShiftModifier;
224  		case SCMOD_CTRL:
225  			return Qt::ControlModifier;
226  		case SCMOD_ALT:
227  			return Qt::AltModifier;
228  		case SCMOD_SUPER:
229  			return Qt::MetaModifier;
230  		default:
231  			return 0;
232  	}
233  }
234  void ScintillaEditBase::mousePressEvent(QMouseEvent *event)
235  {
236  	Point pos = PointFromQPoint(event->pos());
237  	emit buttonPressed(event);
238  	if (event->button() == Qt::MiddleButton &&
239  	    QApplication::clipboard()->supportsSelection()) {
240  		SelectionPosition selPos = sqt->SPositionFromLocation(
241  					pos, false, false, sqt->UserVirtualSpace());
242  		sqt->sel.Clear();
243  		sqt->SetSelection(selPos, selPos);
244  		sqt->PasteFromMode(QClipboard::Selection);
245  		return;
246  	}
247  	if (event->button() == Qt::LeftButton) {
248  		bool shift = QApplication::keyboardModifiers() & Qt::ShiftModifier;
249  		bool ctrl  = QApplication::keyboardModifiers() & Qt::ControlModifier;
250  		bool alt   = QApplication::keyboardModifiers() & modifierTranslated(sqt->rectangularSelectionModifier);
251  		sqt->ButtonDownWithModifiers(pos, time.elapsed(), ModifierFlags(shift, ctrl, alt));
252  	}
253  	if (event->button() == Qt::RightButton) {
254  		sqt->RightButtonDownWithModifiers(pos, time.elapsed(), ModifiersOfKeyboard());
255  	}
256  }
257  void ScintillaEditBase::mouseReleaseEvent(QMouseEvent *event)
258  {
259  	const QPoint point = event->pos();
260  	if (event->button() == Qt::LeftButton)
261  		sqt->ButtonUpWithModifiers(PointFromQPoint(point), time.elapsed(), ModifiersOfKeyboard());
262  	const sptr_t pos = send(SCI_POSITIONFROMPOINT, point.x(), point.y());
263  	const sptr_t line = send(SCI_LINEFROMPOSITION, pos);
264  	int modifiers = QApplication::keyboardModifiers();
265  	emit textAreaClicked(line, modifiers);
266  	emit buttonReleased(event);
267  }
268  void ScintillaEditBase::mouseDoubleClickEvent(QMouseEvent *event)
269  {
270  	mousePressEvent(event);
271  }
272  void ScintillaEditBase::mouseMoveEvent(QMouseEvent *event)
273  {
274  	Point pos = PointFromQPoint(event->pos());
275  	bool shift = QApplication::keyboardModifiers() & Qt::ShiftModifier;
276  	bool ctrl  = QApplication::keyboardModifiers() & Qt::ControlModifier;
277  	bool alt   = QApplication::keyboardModifiers() & modifierTranslated(sqt->rectangularSelectionModifier);
278  	const KeyMod modifiers = ModifierFlags(shift, ctrl, alt);
279  	sqt->ButtonMoveWithModifiers(pos, time.elapsed(), modifiers);
280  }
281  void ScintillaEditBase::contextMenuEvent(QContextMenuEvent *event)
282  {
283  	Point pos = PointFromQPoint(event->globalPos());
284  	Point pt = PointFromQPoint(event->pos());
285  	if (!sqt->PointInSelection(pt)) {
286  		sqt->SetEmptySelection(sqt->PositionFromLocation(pt));
287  	}
288  	if (sqt->ShouldDisplayPopup(pt)) {
289  		sqt->ContextMenu(pos);
290  	}
291  }
292  void ScintillaEditBase::dragEnterEvent(QDragEnterEvent *event)
293  {
294  	if (event->mimeData()->hasUrls()) {
295  		event->acceptProposedAction();
296  	} else if (event->mimeData()->hasText()) {
297  		event->acceptProposedAction();
298  		Point point = PointFromQPoint(event->pos());
299  		sqt->DragEnter(point);
300  	} else {
301  		event->ignore();
302  	}
303  }
304  void ScintillaEditBase::dragLeaveEvent(QDragLeaveEvent * &bsol;* event */)
305  {
306  	sqt->DragLeave();
307  }
308  void ScintillaEditBase::dragMoveEvent(QDragMoveEvent *event)
309  {
310  	if (event->mimeData()->hasUrls()) {
311  		event->acceptProposedAction();
312  	} else if (event->mimeData()->hasText()) {
313  		event->acceptProposedAction();
314  		Point point = PointFromQPoint(event->pos());
315  		sqt->DragMove(point);
316  	} else {
317  		event->ignore();
318  	}
319  }
320  void ScintillaEditBase::dropEvent(QDropEvent *event)
321  {
322  	if (event->mimeData()->hasUrls()) {
323  		event->acceptProposedAction();
324  		sqt->DropUrls(event->mimeData());
325  	} else if (event->mimeData()->hasText()) {
326  		event->acceptProposedAction();
327  		Point point = PointFromQPoint(event->pos());
328  		bool move = (event->source() == this &&
329                   event->proposedAction() == Qt::MoveAction);
330  		sqt->Drop(point, event->mimeData(), move);
331  	} else {
332  		event->ignore();
333  	}
334  }
335  bool ScintillaEditBase::IsHangul(const QChar qchar)
336  {
337  	unsigned int unicode = qchar.unicode();
338  	const bool HangulJamo = (0x1100 <= unicode && unicode <= 0x11FF);
339  	const bool HangulCompatibleJamo = (0x3130 <= unicode && unicode <= 0x318F);
340  	const bool HangulJamoExtendedA = (0xA960 <= unicode && unicode <= 0xA97F);
341  	const bool HangulJamoExtendedB = (0xD7B0 <= unicode && unicode <= 0xD7FF);
342  	const bool HangulSyllable = (0xAC00 <= unicode && unicode <= 0xD7A3);
343  	return HangulJamo || HangulCompatibleJamo  || HangulSyllable ||
344  				HangulJamoExtendedA || HangulJamoExtendedB;
345  }
346  void ScintillaEditBase::MoveImeCarets(Scintilla::Position offset)
347  {
348  	for (size_t r=0; r < sqt->sel.Count(); r++) {
349  		const Sci::Position positionInsert = sqt->sel.Range(r).Start().Position();
350  		sqt->sel.Range(r).caret.SetPosition(positionInsert + offset);
<span onclick='openModal()' class='match'>351  		sqt->sel.Range(r).anchor.SetPosition(positionInsert + offset);
352   	}
</span>353  }
354  void ScintillaEditBase::DrawImeIndicator(int indicator, int len)
355  {
356  	if (indicator < INDICATOR_CONTAINER || indicator > INDICATOR_MAX) {
357  		return;
358  	}
359  	sqt->pdoc->DecorationSetCurrentIndicator(indicator);
360  	for (size_t r=0; r< sqt-> sel.Count(); r++) {
361  		const Sci::Position positionInsert = sqt->sel.Range(r).Start().Position();
362  		sqt->pdoc->DecorationFillRange(positionInsert - len, 1, len);
363  	}
364  }
365  static int GetImeCaretPos(QInputMethodEvent *event)
366  {
367  	foreach (QInputMethodEvent::Attribute attr, event->attributes()) {
368  		if (attr.type == QInputMethodEvent::Cursor)
369  			return attr.start;
370  	}
371  	return 0;
372  }
373  static std::vector<int> MapImeIndicators(QInputMethodEvent *event)
374  {
375  	std::vector<int> imeIndicator(event->preeditString().size(), IndicatorUnknown);
376  	foreach (QInputMethodEvent::Attribute attr, event->attributes()) {
377  		if (attr.type == QInputMethodEvent::TextFormat) {
378  			QTextFormat format = attr.value.value<QTextFormat>();
379  			QTextCharFormat charFormat = format.toCharFormat();
380  			int indicator = IndicatorUnknown;
381  			switch (charFormat.underlineStyle()) {
382  				case QTextCharFormat::NoUnderline: 
383  				case QTextCharFormat::SingleUnderline: 
384  				case QTextCharFormat::DashUnderline: 
385  					indicator = IndicatorInput;
386  					break;
387  				case QTextCharFormat::DotLine:
388  				case QTextCharFormat::DashDotLine:
389  				case QTextCharFormat::WaveUnderline:
390  				case QTextCharFormat::SpellCheckUnderline:
391  					indicator = IndicatorConverted;
392  					break;
393  				default:
394  					indicator = IndicatorUnknown;
395  			}
396  			if (format.hasProperty(QTextFormat::BackgroundBrush)) 
397  				indicator = IndicatorTarget;
398  #ifdef Q_OS_OSX
399  			if (charFormat.underlineStyle() == QTextCharFormat::SingleUnderline) {
400  				QColor uc = charFormat.underlineColor();
401  				if (uc.lightness() < 2) { 
402  					indicator = IndicatorTarget;
403  				}
404  			}
405  #endif
406  			for (int i = attr.start; i < attr.start+attr.length; i++) {
407  				imeIndicator[i] = indicator;
408  			}
409  		}
410  	}
411  	return imeIndicator;
412  }
413  void ScintillaEditBase::inputMethodEvent(QInputMethodEvent *event)
414  {
415  	if (sqt->pdoc->IsReadOnly() || sqt->SelectionContainsProtected()) {
416  		return;
417  	}
418  	bool initialCompose = false;
419  	if (sqt->pdoc->TentativeActive()) {
420  		sqt->pdoc->TentativeUndo();
421  	} else {
422  		initialCompose = true;
423  	}
424  	sqt->view.imeCaretBlockOverride = false;
425  	preeditPos = -1; 
426  	if (!event->commitString().isEmpty()) {
427  		const QString &commitStr = event->commitString();
428  		const int commitStrLen = commitStr.length();
429  		for (int i = 0; i < commitStrLen;) {
430  			const int ucWidth = commitStr.at(i).isHighSurrogate() ? 2 : 1;
431  			const QString oneCharUTF16 = commitStr.mid(i, ucWidth);
432  			const QByteArray oneChar = sqt->BytesForDocument(oneCharUTF16);
433  			sqt->InsertCharacter(std::string_view(oneChar.data(), oneChar.length()), CharacterSource::DirectInput);
434  			i += ucWidth;
435  		}
436  	} else if (!event->preeditString().isEmpty()) {
437  		const QString preeditStr = event->preeditString();
438  		const int preeditStrLen = preeditStr.length();
439  		if (preeditStrLen == 0) {
440  			sqt->ShowCaretAtCurrentPosition();
441  			return;
442  		}
443  		if (initialCompose)
444  			sqt->ClearBeforeTentativeStart();
445  		sqt->pdoc->TentativeStart(); 
446  		preeditPos = sqt->CurrentPosition();
447  		std::vector<int> imeIndicator = MapImeIndicators(event);
448  		for (int i = 0; i < preeditStrLen;) {
449  			const int ucWidth = preeditStr.at(i).isHighSurrogate() ? 2 : 1;
450  			const QString oneCharUTF16 = preeditStr.mid(i, ucWidth);
451  			const QByteArray oneChar = sqt->BytesForDocument(oneCharUTF16);
452  			const int oneCharLen = oneChar.length();
453  			sqt->InsertCharacter(std::string_view(oneChar.data(), oneCharLen), CharacterSource::TentativeInput);
454  			DrawImeIndicator(imeIndicator[i], oneCharLen);
455  			i += ucWidth;
456  		}
457  		int imeCaretPos = GetImeCaretPos(event);
458  		int imeEndToImeCaretU16 = imeCaretPos - preeditStrLen;
459  		const Sci::Position imeCaretPosDoc = sqt->pdoc->GetRelativePositionUTF16(sqt->CurrentPosition(), imeEndToImeCaretU16);
460  		MoveImeCarets(- sqt->CurrentPosition() + imeCaretPosDoc);
461  		if (IsHangul(preeditStr.at(0))) {
462  #ifndef Q_OS_WIN
463  			if (imeCaretPos > 0) {
464  				int oneCharBefore = sqt->pdoc->GetRelativePosition(sqt->CurrentPosition(), -1);
465  				MoveImeCarets(- sqt->CurrentPosition() + oneCharBefore);
466  			}
467  #endif
468  			sqt->view.imeCaretBlockOverride = true;
469  		}
470  		const bool targetAny = std::any_of(imeIndicator.begin(), imeIndicator.end(), [](int i) noexcept {
471  			return i == IndicatorTarget;
472  		});
473  		if (targetAny)
474  			preeditPos = sqt->CurrentPosition();
475  		sqt->EnsureCaretVisible();
476  	}
477  	sqt->ShowCaretAtCurrentPosition();
478  }
479  QVariant ScintillaEditBase::inputMethodQuery(Qt::InputMethodQuery query) const
480  {
481  	const Scintilla::Position pos = send(SCI_GETCURRENTPOS);
482  	const Scintilla::Position line = send(SCI_LINEFROMPOSITION, pos);
483  	switch (query) {
484  #if QT_VERSION >= QT_VERSION_CHECK(5, 14, 0)
485  		case Qt::ImCursorRectangle:
486  		{
487  			const Scintilla::Position startPos = (preeditPos >= 0) ? preeditPos : pos;
488  			const Point pt = sqt->LocationFromPosition(startPos);
489  			const int width = static_cast<int>(send(SCI_GETCARETWIDTH));
490  			const int height = static_cast<int>(send(SCI_TEXTHEIGHT, line));
491  			return QRectF(pt.x, pt.y, width, height).toRect();
492  		}
493  #else
494  		case Qt::ImMicroFocus:
495  		{
496  			const Scintilla::Position startPos = (preeditPos >= 0) ? preeditPos : pos;
497  			const Point pt = sqt->LocationFromPosition(startPos);
498  			const int width = static_cast<int>(send(SCI_GETCARETWIDTH));
499  			const int height = static_cast<int>(send(SCI_TEXTHEIGHT, line));
500  			return QRect(pt.x, pt.y, width, height);
501  		}
502  #endif
503  		case Qt::ImFont:
504  		{
505  			char fontName[64];
506  			const sptr_t style = send(SCI_GETSTYLEAT, pos);
507  			const int len = static_cast<int>(sends(SCI_STYLEGETFONT, style, fontName));
508  			const int size = static_cast<int>(send(SCI_STYLEGETSIZE, style));
509  			const bool italic = send(SCI_STYLEGETITALIC, style);
510  			const int weight = send(SCI_STYLEGETBOLD, style) ? QFont::Bold : -1;
511  			return QFont(QString::fromUtf8(fontName, len), size, weight, italic);
512  		}
513  		case Qt::ImCursorPosition:
514  		{
515  			const Scintilla::Position paraStart = sqt->pdoc->ParaUp(pos);
516  			return static_cast<int>(sqt->pdoc->CountUTF16(paraStart, pos));
517  		}
518  		case Qt::ImSurroundingText:
519  		{
520  			const Scintilla::Position paraStart = sqt->pdoc->ParaUp(pos);
521  			const Scintilla::Position paraEnd = sqt->pdoc->ParaDown(pos);
522  			const std::string buffer = sqt->RangeText(paraStart, paraEnd);
523  			return sqt->StringFromDocument(buffer.c_str());
524  		}
525  		case Qt::ImCurrentSelection:
526  		{
527  			QVarLengthArray<char,1024> buffer(send(SCI_GETSELTEXT));
528  			sends(SCI_GETSELTEXT, 0, buffer.data());
529  			return sqt->StringFromDocument(buffer.constData());
530  		}
531  		default:
532  			return QVariant();
533  	}
534  }
535  void ScintillaEditBase::notifyParent(NotificationData scn)
536  {
537  	emit notify(&scn);
538  	switch (scn.nmhdr.code) {
539  		case Notification::StyleNeeded:
540  			emit styleNeeded(scn.position);
541  			break;
542  		case Notification::CharAdded:
543  			emit charAdded(scn.ch);
544  			break;
545  		case Notification::SavePointReached:
546  			emit savePointChanged(false);
547  			break;
548  		case Notification::SavePointLeft:
549  			emit savePointChanged(true);
550  			break;
551  		case Notification::ModifyAttemptRO:
552  			emit modifyAttemptReadOnly();
553  			break;
554  		case Notification::Key:
555  			emit key(scn.ch);
556  			break;
557  		case Notification::DoubleClick:
558  			emit doubleClick(scn.position, scn.line);
559  			break;
560  		case Notification::UpdateUI:
561  			emit updateUi(scn.updated);
562  			break;
563  		case Notification::Modified:
564  		{
565  			const bool added = FlagSet(scn.modificationType, ModificationFlags::InsertText);
566  			const bool deleted = FlagSet(scn.modificationType, ModificationFlags::DeleteText);
567  			const Scintilla::Position length = send(SCI_GETTEXTLENGTH);
568  			bool firstLineAdded = (added && length == 1) ||
569  			                      (deleted && length == 0);
570  			if (scn.linesAdded != 0) {
571  				emit linesAdded(scn.linesAdded);
572  			} else if (firstLineAdded) {
573  				emit linesAdded(added ? 1 : -1);
574  			}
575  			const QByteArray bytes = QByteArray::fromRawData(scn.text, scn.text ? scn.length : 0);
576  			emit modified(scn.modificationType, scn.position, scn.length,
577  			              scn.linesAdded, bytes, scn.line,
578  			              scn.foldLevelNow, scn.foldLevelPrev);
579  			break;
580  		}
581  		case Notification::MacroRecord:
582  			emit macroRecord(scn.message, scn.wParam, scn.lParam);
583  			break;
584  		case Notification::MarginClick:
585  			emit marginClicked(scn.position, scn.modifiers, scn.margin);
586  			break;
587  		case Notification::NeedShown:
588  			emit needShown(scn.position, scn.length);
589  			break;
590  		case Notification::Painted:
591  			emit painted();
592  			break;
593  		case Notification::UserListSelection:
594  			emit userListSelection();
595  			break;
596  		case Notification::URIDropped:
597  			emit uriDropped(QString::fromUtf8(scn.text));
598  			break;
599  		case Notification::DwellStart:
600  			emit dwellStart(scn.x, scn.y);
601  			break;
602  		case Notification::DwellEnd:
603  			emit dwellEnd(scn.x, scn.y);
604  			break;
605  		case Notification::Zoom:
606  			emit zoom(send(SCI_GETZOOM));
607  			break;
608  		case Notification::HotSpotClick:
609  			emit hotSpotClick(scn.position, scn.modifiers);
610  			break;
611  		case Notification::HotSpotDoubleClick:
612  			emit hotSpotDoubleClick(scn.position, scn.modifiers);
613  			break;
614  		case Notification::CallTipClick:
615  			emit callTipClick();
616  			break;
617  		case Notification::AutoCSelection:
618  			emit autoCompleteSelection(scn.lParam, QString::fromUtf8(scn.text));
619  			break;
620  		case Notification::AutoCCancelled:
621  			emit autoCompleteCancelled();
622  			break;
623  		case Notification::FocusIn:
624  			emit focusChanged(true);
625  			break;
626  		case Notification::FocusOut:
627  			emit focusChanged(false);
628  			break;
629  		default:
630  			return;
631  	}
632  }
633  void ScintillaEditBase::event_command(uptr_t wParam, sptr_t lParam)
634  {
635  	emit command(wParam, lParam);
636  }
637  KeyMod ScintillaEditBase::ModifiersOfKeyboard()
638  {
639  	const bool shift = QApplication::keyboardModifiers() & Qt::ShiftModifier;
640  	const bool ctrl  = QApplication::keyboardModifiers() & Qt::ControlModifier;
641  	const bool alt   = QApplication::keyboardModifiers() & Qt::AltModifier;
642  	return ModifierFlags(shift, ctrl, alt);
643  }
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-ScintillaEditBase.cpp</h3>
            <pre><code>1  #include "ScintillaEditBase.h"
2  #include "ScintillaQt.h"
3  #include "PlatQt.h"
4  #include <QApplication>
5  #if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)
6  #include <QInputContext>
7  #endif
8  #include <QPainter>
9  #include <QVarLengthArray>
10  #include <QScrollBar>
11  #include <QTextFormat>
12  constexpr int IndicatorInput = static_cast<int>(Scintilla::IndicatorNumbers::Ime);
13  constexpr int IndicatorTarget = IndicatorInput + 1;
14  constexpr int IndicatorConverted = IndicatorInput + 2;
15  constexpr int IndicatorUnknown = IndicatorInput + 3;
16  #if QT_VERSION >= QT_VERSION_CHECK(5, 0, 0)
17  #ifdef Q_OS_MAC
18  #define Q_WS_MAC 1
19  #endif
20  #if !defined(Q_OS_MAC) && !defined(Q_OS_WIN)
21  #define Q_WS_X11 1
22  #endif
23  #endif 
24  using namespace Scintilla;
25  using namespace Scintilla::Internal;
26  ScintillaEditBase::ScintillaEditBase(QWidget *parent)
27  : QAbstractScrollArea(parent), sqt(new ScintillaQt(this)), preeditPos(-1), wheelDelta(0)
28  {
29  	time.start();
30  	setAcceptDrops(true);
31  	setMouseTracking(true);
32  	setAutoFillBackground(false);
33  	setFrameStyle(QFrame::NoFrame);
34  	setFocusPolicy(Qt::StrongFocus);
35  	setAttribute(Qt::WA_StaticContents);
36  	viewport()->setAutoFillBackground(false);
37  	setAttribute(Qt::WA_KeyCompression);
38  	setAttribute(Qt::WA_InputMethodEnabled);
39  	const ColourRGBA colourIME(0, 0, UCHAR_MAX);
40  	sqt->vs.indicators[IndicatorUnknown] = Indicator(IndicatorStyle::Hidden, colourIME);
41  	sqt->vs.indicators[IndicatorInput] = Indicator(IndicatorStyle::Dots, colourIME);
42  	sqt->vs.indicators[IndicatorConverted] = Indicator(IndicatorStyle::CompositionThick, colourIME);
43  	sqt->vs.indicators[IndicatorTarget] = Indicator(IndicatorStyle::StraightBox, colourIME);
44  	connect(sqt, SIGNAL(notifyParent(Scintilla::NotificationData)),
45  		this, SLOT(notifyParent(Scintilla::NotificationData)));
46  	connect(verticalScrollBar(), SIGNAL(valueChanged(int)),
47  	        this, SLOT(scrollVertical(int)));
48  	connect(horizontalScrollBar(), SIGNAL(valueChanged(int)),
49  	        this, SLOT(scrollHorizontal(int)));
50  	connect(sqt, SIGNAL(horizontalRangeChanged(int,int)),
51  	        this, SIGNAL(horizontalRangeChanged(int,int)));
52  	connect(sqt, SIGNAL(verticalRangeChanged(int,int)),
53  	        this, SIGNAL(verticalRangeChanged(int,int)));
54  	connect(sqt, SIGNAL(horizontalScrolled(int)),
55  	        this, SIGNAL(horizontalScrolled(int)));
56  	connect(sqt, SIGNAL(verticalScrolled(int)),
57  	        this, SIGNAL(verticalScrolled(int)));
58  	connect(sqt, SIGNAL(notifyChange()),
59  	        this, SIGNAL(notifyChange()));
60  	connect(sqt, SIGNAL(command(Scintilla::uptr_t,Scintilla::sptr_t)),
61  		this, SLOT(event_command(Scintilla::uptr_t,Scintilla::sptr_t)));
62  	connect(sqt, SIGNAL(aboutToCopy(QMimeData*)),
63  		this, SIGNAL(aboutToCopy(QMimeData*)));
64  }
65  ScintillaEditBase::~ScintillaEditBase() = default;
66  sptr_t ScintillaEditBase::send(
67  	unsigned int iMessage,
68  	uptr_t wParam,
69  	sptr_t lParam) const
70  {
71  	return sqt->WndProc(static_cast<Message>(iMessage), wParam, lParam);
72  }
73  sptr_t ScintillaEditBase::sends(
74      unsigned int iMessage,
75      uptr_t wParam,
76      const char *s) const
77  {
78  	return sqt->WndProc(static_cast<Message>(iMessage), wParam, reinterpret_cast<sptr_t>(s));
79  }
80  void ScintillaEditBase::scrollHorizontal(int value)
81  {
82  	sqt->HorizontalScrollTo(value);
83  }
84  void ScintillaEditBase::scrollVertical(int value)
85  {
86  	sqt->ScrollTo(value);
87  }
88  bool ScintillaEditBase::event(QEvent *event)
89  {
90  	bool result = false;
91  	if (event->type() == QEvent::KeyPress) {
92  		keyPressEvent(static_cast<QKeyEvent *>(event));
93  		result = event->isAccepted();
94  	} else if (event->type() == QEvent::Show) {
95  		setMouseTracking(true);
96  		result = QAbstractScrollArea::event(event);
97  	} else if (event->type() == QEvent::Hide) {
98  		setMouseTracking(false);
99  		result = QAbstractScrollArea::event(event);
100  	} else {
101  		result = QAbstractScrollArea::event(event);
102  	}
103  	return result;
104  }
105  void ScintillaEditBase::paintEvent(QPaintEvent *event)
106  {
107  	sqt->PartialPaint(PRectFromQRect(event->rect()));
108  }
109  namespace {
110  bool isWheelEventHorizontal(QWheelEvent *event) {
111  #if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
112  	return event->angleDelta().y() == 0;
113  #else
114  	return event->orientation() == Qt::Horizontal;
115  #endif
116  }
117  int wheelEventYDelta(QWheelEvent *event) {
118  #if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
119  	return event->angleDelta().y();
120  #else
121  	return event->delta();
122  #endif
123  }
124  }
125  void ScintillaEditBase::wheelEvent(QWheelEvent *event)
126  {
127  	if (isWheelEventHorizontal(event)) {
128  		QAbstractScrollArea::wheelEvent(event);
129  	} else {
130  		if (QApplication::keyboardModifiers() & Qt::ControlModifier) {
131  			if (wheelEventYDelta(event) > 0) {
132  				sqt->KeyCommand(Message::ZoomIn);
133  			} else {
134  				sqt->KeyCommand(Message::ZoomOut);
135  			}
136  		} else {
137  			QAbstractScrollArea::wheelEvent(event);
138  		}
139  	}
140  }
141  void ScintillaEditBase::focusInEvent(QFocusEvent *event)
142  {
143  	sqt->SetFocusState(true);
144  	QAbstractScrollArea::focusInEvent(event);
145  }
146  void ScintillaEditBase::focusOutEvent(QFocusEvent *event)
147  {
148  	sqt->SetFocusState(false);
149  	QAbstractScrollArea::focusOutEvent(event);
150  }
151  void ScintillaEditBase::resizeEvent(QResizeEvent *)
152  {
153  	sqt->ChangeSize();
154  	emit resized();
155  }
156  void ScintillaEditBase::keyPressEvent(QKeyEvent *event)
157  {
158  	if (QApplication::keyboardModifiers() & Qt::MetaModifier) {
159  		QAbstractScrollArea::keyPressEvent(event);
160  		emit keyPressed(event);
161  		return;
162  	}
163  	int key = 0;
164  	switch (event->key()) {
165  		case Qt::Key_Down:          key = SCK_DOWN;     break;
166  		case Qt::Key_Up:            key = SCK_UP;       break;
167  		case Qt::Key_Left:          key = SCK_LEFT;     break;
168  		case Qt::Key_Right:         key = SCK_RIGHT;    break;
169  		case Qt::Key_Home:          key = SCK_HOME;     break;
170  		case Qt::Key_End:           key = SCK_END;      break;
171  		case Qt::Key_PageUp:        key = SCK_PRIOR;    break;
172  		case Qt::Key_PageDown:      key = SCK_NEXT;     break;
173  		case Qt::Key_Delete:        key = SCK_DELETE;   break;
174  		case Qt::Key_Insert:        key = SCK_INSERT;   break;
175  		case Qt::Key_Escape:        key = SCK_ESCAPE;   break;
176  		case Qt::Key_Backspace:     key = SCK_BACK;     break;
177  		case Qt::Key_Plus:          key = SCK_ADD;      break;
178  		case Qt::Key_Minus:         key = SCK_SUBTRACT; break;
179  		case Qt::Key_Backtab:       
180  		case Qt::Key_Tab:           key = SCK_TAB;      break;
181  		case Qt::Key_Enter:         
182  		case Qt::Key_Return:        key = SCK_RETURN;   break;
183  		case Qt::Key_Control:       key = 0;            break;
184  		case Qt::Key_Alt:           key = 0;            break;
185  		case Qt::Key_Shift:         key = 0;            break;
186  		case Qt::Key_Meta:          key = 0;            break;
187  		default:                    key = event->key(); break;
188  	}
189  	bool shift = QApplication::keyboardModifiers() & Qt::ShiftModifier;
190  	bool ctrl  = QApplication::keyboardModifiers() & Qt::ControlModifier;
191  	bool alt   = QApplication::keyboardModifiers() & Qt::AltModifier;
192  	bool consumed = false;
193  	bool added = sqt->KeyDownWithModifiers(static_cast<Keys>(key),
194  					       ModifierFlags(shift, ctrl, alt),
195  					       &consumed) != 0;
196  	if (!consumed)
197  		consumed = added;
198  	if (!consumed) {
199  		bool input = (!ctrl || alt);
200  #ifndef Q_WS_MAC
201  		input &= (!alt || ctrl);
202  #endif
203  		QString text = event->text();
204  		if (input && !text.isEmpty() && text[0].isPrint()) {
205  			const int strLen = text.length();
206  			for (int i = 0; i < strLen;) {
207  				const int ucWidth = text.at(i).isHighSurrogate() ? 2 : 1;
208  				const QString oneCharUTF16 = text.mid(i, ucWidth);
209  				const QByteArray oneChar = sqt->BytesForDocument(oneCharUTF16);
210  				sqt->InsertCharacter(std::string_view(oneChar.data(), oneChar.length()), CharacterSource::DirectInput);
211  				i += ucWidth;
212  			}
213  		} else {
214  			event->ignore();
215  		}
216  	}
217  	emit keyPressed(event);
218  }
219  static int modifierTranslated(int sciModifier)
220  {
221  	switch (sciModifier) {
222  		case SCMOD_SHIFT:
223  			return Qt::ShiftModifier;
224  		case SCMOD_CTRL:
225  			return Qt::ControlModifier;
226  		case SCMOD_ALT:
227  			return Qt::AltModifier;
228  		case SCMOD_SUPER:
229  			return Qt::MetaModifier;
230  		default:
231  			return 0;
232  	}
233  }
234  void ScintillaEditBase::mousePressEvent(QMouseEvent *event)
235  {
236  	Point pos = PointFromQPoint(event->pos());
237  	emit buttonPressed(event);
238  	if (event->button() == Qt::MiddleButton &&
239  	    QApplication::clipboard()->supportsSelection()) {
240  		SelectionPosition selPos = sqt->SPositionFromLocation(
241  					pos, false, false, sqt->UserVirtualSpace());
242  		sqt->sel.Clear();
243  		sqt->SetSelection(selPos, selPos);
244  		sqt->PasteFromMode(QClipboard::Selection);
245  		return;
246  	}
247  	if (event->button() == Qt::LeftButton) {
248  		bool shift = QApplication::keyboardModifiers() & Qt::ShiftModifier;
249  		bool ctrl  = QApplication::keyboardModifiers() & Qt::ControlModifier;
250  		bool alt   = QApplication::keyboardModifiers() & modifierTranslated(sqt->rectangularSelectionModifier);
251  		sqt->ButtonDownWithModifiers(pos, time.elapsed(), ModifierFlags(shift, ctrl, alt));
252  	}
253  	if (event->button() == Qt::RightButton) {
254  		sqt->RightButtonDownWithModifiers(pos, time.elapsed(), ModifiersOfKeyboard());
255  	}
256  }
257  void ScintillaEditBase::mouseReleaseEvent(QMouseEvent *event)
258  {
259  	const QPoint point = event->pos();
260  	if (event->button() == Qt::LeftButton)
261  		sqt->ButtonUpWithModifiers(PointFromQPoint(point), time.elapsed(), ModifiersOfKeyboard());
262  	const sptr_t pos = send(SCI_POSITIONFROMPOINT, point.x(), point.y());
263  	const sptr_t line = send(SCI_LINEFROMPOSITION, pos);
264  	int modifiers = QApplication::keyboardModifiers();
265  	emit textAreaClicked(line, modifiers);
266  	emit buttonReleased(event);
267  }
268  void ScintillaEditBase::mouseDoubleClickEvent(QMouseEvent *event)
269  {
270  	mousePressEvent(event);
271  }
272  void ScintillaEditBase::mouseMoveEvent(QMouseEvent *event)
273  {
274  	Point pos = PointFromQPoint(event->pos());
275  	bool shift = QApplication::keyboardModifiers() & Qt::ShiftModifier;
276  	bool ctrl  = QApplication::keyboardModifiers() & Qt::ControlModifier;
277  	bool alt   = QApplication::keyboardModifiers() & modifierTranslated(sqt->rectangularSelectionModifier);
278  	const KeyMod modifiers = ModifierFlags(shift, ctrl, alt);
279  	sqt->ButtonMoveWithModifiers(pos, time.elapsed(), modifiers);
280  }
281  void ScintillaEditBase::contextMenuEvent(QContextMenuEvent *event)
282  {
283  	Point pos = PointFromQPoint(event->globalPos());
284  	Point pt = PointFromQPoint(event->pos());
285  	if (!sqt->PointInSelection(pt)) {
286  		sqt->SetEmptySelection(sqt->PositionFromLocation(pt));
287  	}
288  	if (sqt->ShouldDisplayPopup(pt)) {
289  		sqt->ContextMenu(pos);
290  	}
291  }
292  void ScintillaEditBase::dragEnterEvent(QDragEnterEvent *event)
293  {
294  	if (event->mimeData()->hasUrls()) {
295  		event->acceptProposedAction();
296  	} else if (event->mimeData()->hasText()) {
297  		event->acceptProposedAction();
298  		Point point = PointFromQPoint(event->pos());
299  		sqt->DragEnter(point);
300  	} else {
301  		event->ignore();
302  	}
303  }
304  void ScintillaEditBase::dragLeaveEvent(QDragLeaveEvent * &bsol;* event */)
305  {
306  	sqt->DragLeave();
307  }
308  void ScintillaEditBase::dragMoveEvent(QDragMoveEvent *event)
309  {
310  	if (event->mimeData()->hasUrls()) {
311  		event->acceptProposedAction();
312  	} else if (event->mimeData()->hasText()) {
313  		event->acceptProposedAction();
314  		Point point = PointFromQPoint(event->pos());
315  		sqt->DragMove(point);
316  	} else {
317  		event->ignore();
318  	}
319  }
320  void ScintillaEditBase::dropEvent(QDropEvent *event)
321  {
322  	if (event->mimeData()->hasUrls()) {
323  		event->acceptProposedAction();
324  		sqt->DropUrls(event->mimeData());
325  	} else if (event->mimeData()->hasText()) {
326  		event->acceptProposedAction();
327  		Point point = PointFromQPoint(event->pos());
328  		bool move = (event->source() == this &&
329                   event->proposedAction() == Qt::MoveAction);
330  		sqt->Drop(point, event->mimeData(), move);
331  	} else {
332  		event->ignore();
333  	}
334  }
335  bool ScintillaEditBase::IsHangul(const QChar qchar)
336  {
337  	unsigned int unicode = qchar.unicode();
338  	const bool HangulJamo = (0x1100 <= unicode && unicode <= 0x11FF);
339  	const bool HangulCompatibleJamo = (0x3130 <= unicode && unicode <= 0x318F);
340  	const bool HangulJamoExtendedA = (0xA960 <= unicode && unicode <= 0xA97F);
341  	const bool HangulJamoExtendedB = (0xD7B0 <= unicode && unicode <= 0xD7FF);
342  	const bool HangulSyllable = (0xAC00 <= unicode && unicode <= 0xD7A3);
343  	return HangulJamo || HangulCompatibleJamo  || HangulSyllable ||
344  				HangulJamoExtendedA || HangulJamoExtendedB;
345  }
346  void ScintillaEditBase::MoveImeCarets(Scintilla::Position offset)
347  {
348  	for (size_t r=0; r < sqt->sel.Count(); r++) {
349  		const Sci::Position positionInsert = sqt->sel.Range(r).Start().Position();
350  		sqt->sel.Range(r).caret.SetPosition(positionInsert + offset);
<span onclick='openModal()' class='match'>351  		sqt->sel.Range(r).anchor.SetPosition(positionInsert + offset);
352   	}
</span>353  }
354  void ScintillaEditBase::DrawImeIndicator(int indicator, int len)
355  {
356  	if (indicator < INDICATOR_CONTAINER || indicator > INDICATOR_MAX) {
357  		return;
358  	}
359  	sqt->pdoc->DecorationSetCurrentIndicator(indicator);
360  	for (size_t r=0; r< sqt-> sel.Count(); r++) {
361  		const Sci::Position positionInsert = sqt->sel.Range(r).Start().Position();
362  		sqt->pdoc->DecorationFillRange(positionInsert - len, 1, len);
363  	}
364  }
365  static int GetImeCaretPos(QInputMethodEvent *event)
366  {
367  	foreach (QInputMethodEvent::Attribute attr, event->attributes()) {
368  		if (attr.type == QInputMethodEvent::Cursor)
369  			return attr.start;
370  	}
371  	return 0;
372  }
373  static std::vector<int> MapImeIndicators(QInputMethodEvent *event)
374  {
375  	std::vector<int> imeIndicator(event->preeditString().size(), IndicatorUnknown);
376  	foreach (QInputMethodEvent::Attribute attr, event->attributes()) {
377  		if (attr.type == QInputMethodEvent::TextFormat) {
378  			QTextFormat format = attr.value.value<QTextFormat>();
379  			QTextCharFormat charFormat = format.toCharFormat();
380  			int indicator = IndicatorUnknown;
381  			switch (charFormat.underlineStyle()) {
382  				case QTextCharFormat::NoUnderline: 
383  				case QTextCharFormat::SingleUnderline: 
384  				case QTextCharFormat::DashUnderline: 
385  					indicator = IndicatorInput;
386  					break;
387  				case QTextCharFormat::DotLine:
388  				case QTextCharFormat::DashDotLine:
389  				case QTextCharFormat::WaveUnderline:
390  				case QTextCharFormat::SpellCheckUnderline:
391  					indicator = IndicatorConverted;
392  					break;
393  				default:
394  					indicator = IndicatorUnknown;
395  			}
396  			if (format.hasProperty(QTextFormat::BackgroundBrush)) 
397  				indicator = IndicatorTarget;
398  #ifdef Q_OS_OSX
399  			if (charFormat.underlineStyle() == QTextCharFormat::SingleUnderline) {
400  				QColor uc = charFormat.underlineColor();
401  				if (uc.lightness() < 2) { 
402  					indicator = IndicatorTarget;
403  				}
404  			}
405  #endif
406  			for (int i = attr.start; i < attr.start+attr.length; i++) {
407  				imeIndicator[i] = indicator;
408  			}
409  		}
410  	}
411  	return imeIndicator;
412  }
413  void ScintillaEditBase::inputMethodEvent(QInputMethodEvent *event)
414  {
415  	if (sqt->pdoc->IsReadOnly() || sqt->SelectionContainsProtected()) {
416  		return;
417  	}
418  	bool initialCompose = false;
419  	if (sqt->pdoc->TentativeActive()) {
420  		sqt->pdoc->TentativeUndo();
421  	} else {
422  		initialCompose = true;
423  	}
424  	sqt->view.imeCaretBlockOverride = false;
425  	preeditPos = -1; 
426  	if (!event->commitString().isEmpty()) {
427  		const QString &commitStr = event->commitString();
428  		const int commitStrLen = commitStr.length();
429  		for (int i = 0; i < commitStrLen;) {
430  			const int ucWidth = commitStr.at(i).isHighSurrogate() ? 2 : 1;
431  			const QString oneCharUTF16 = commitStr.mid(i, ucWidth);
432  			const QByteArray oneChar = sqt->BytesForDocument(oneCharUTF16);
433  			sqt->InsertCharacter(std::string_view(oneChar.data(), oneChar.length()), CharacterSource::DirectInput);
434  			i += ucWidth;
435  		}
436  	} else if (!event->preeditString().isEmpty()) {
437  		const QString preeditStr = event->preeditString();
438  		const int preeditStrLen = preeditStr.length();
439  		if (preeditStrLen == 0) {
440  			sqt->ShowCaretAtCurrentPosition();
441  			return;
442  		}
443  		if (initialCompose)
444  			sqt->ClearBeforeTentativeStart();
445  		sqt->pdoc->TentativeStart(); 
446  		preeditPos = sqt->CurrentPosition();
447  		std::vector<int> imeIndicator = MapImeIndicators(event);
448  		for (int i = 0; i < preeditStrLen;) {
449  			const int ucWidth = preeditStr.at(i).isHighSurrogate() ? 2 : 1;
450  			const QString oneCharUTF16 = preeditStr.mid(i, ucWidth);
451  			const QByteArray oneChar = sqt->BytesForDocument(oneCharUTF16);
452  			const int oneCharLen = oneChar.length();
453  			sqt->InsertCharacter(std::string_view(oneChar.data(), oneCharLen), CharacterSource::TentativeInput);
454  			DrawImeIndicator(imeIndicator[i], oneCharLen);
455  			i += ucWidth;
456  		}
457  		int imeCaretPos = GetImeCaretPos(event);
458  		int imeEndToImeCaretU16 = imeCaretPos - preeditStrLen;
459  		const Sci::Position imeCaretPosDoc = sqt->pdoc->GetRelativePositionUTF16(sqt->CurrentPosition(), imeEndToImeCaretU16);
460  		MoveImeCarets(- sqt->CurrentPosition() + imeCaretPosDoc);
461  		if (IsHangul(preeditStr.at(0))) {
462  #ifndef Q_OS_WIN
463  			if (imeCaretPos > 0) {
464  				int oneCharBefore = sqt->pdoc->GetRelativePosition(sqt->CurrentPosition(), -1);
465  				MoveImeCarets(- sqt->CurrentPosition() + oneCharBefore);
466  			}
467  #endif
468  			sqt->view.imeCaretBlockOverride = true;
469  		}
470  		const bool targetAny = std::any_of(imeIndicator.begin(), imeIndicator.end(), [](int i) noexcept {
471  			return i == IndicatorTarget;
472  		});
473  		if (targetAny)
474  			preeditPos = sqt->CurrentPosition();
475  		sqt->EnsureCaretVisible();
476  	}
477  	sqt->ShowCaretAtCurrentPosition();
478  }
479  QVariant ScintillaEditBase::inputMethodQuery(Qt::InputMethodQuery query) const
480  {
481  	const Scintilla::Position pos = send(SCI_GETCURRENTPOS);
482  	const Scintilla::Position line = send(SCI_LINEFROMPOSITION, pos);
483  	switch (query) {
484  #if QT_VERSION >= QT_VERSION_CHECK(5, 14, 0)
485  		case Qt::ImCursorRectangle:
486  		{
487  			const Scintilla::Position startPos = (preeditPos >= 0) ? preeditPos : pos;
488  			const Point pt = sqt->LocationFromPosition(startPos);
489  			const int width = static_cast<int>(send(SCI_GETCARETWIDTH));
490  			const int height = static_cast<int>(send(SCI_TEXTHEIGHT, line));
491  			return QRectF(pt.x, pt.y, width, height).toRect();
492  		}
493  #else
494  		case Qt::ImMicroFocus:
495  		{
496  			const Scintilla::Position startPos = (preeditPos >= 0) ? preeditPos : pos;
497  			const Point pt = sqt->LocationFromPosition(startPos);
498  			const int width = static_cast<int>(send(SCI_GETCARETWIDTH));
499  			const int height = static_cast<int>(send(SCI_TEXTHEIGHT, line));
500  			return QRect(pt.x, pt.y, width, height);
501  		}
502  #endif
503  		case Qt::ImFont:
504  		{
505  			char fontName[64];
506  			const sptr_t style = send(SCI_GETSTYLEAT, pos);
507  			const int len = static_cast<int>(sends(SCI_STYLEGETFONT, style, fontName));
508  			const int size = static_cast<int>(send(SCI_STYLEGETSIZE, style));
509  			const bool italic = send(SCI_STYLEGETITALIC, style);
510  			const int weight = send(SCI_STYLEGETBOLD, style) ? QFont::Bold : -1;
511  			return QFont(QString::fromUtf8(fontName, len), size, weight, italic);
512  		}
513  		case Qt::ImCursorPosition:
514  		{
515  			const Scintilla::Position paraStart = sqt->pdoc->ParaUp(pos);
516  			return static_cast<int>(sqt->pdoc->CountUTF16(paraStart, pos));
517  		}
518  		case Qt::ImSurroundingText:
519  		{
520  			const Scintilla::Position paraStart = sqt->pdoc->ParaUp(pos);
521  			const Scintilla::Position paraEnd = sqt->pdoc->ParaDown(pos);
522  			const std::string buffer = sqt->RangeText(paraStart, paraEnd);
523  			return sqt->StringFromDocument(buffer.c_str());
524  		}
525  		case Qt::ImCurrentSelection:
526  		{
527  			QVarLengthArray<char,1024> buffer(send(SCI_GETSELTEXT));
528  			sends(SCI_GETSELTEXT, 0, buffer.data());
529  			return sqt->StringFromDocument(buffer.constData());
530  		}
531  		default:
532  			return QVariant();
533  	}
534  }
535  void ScintillaEditBase::notifyParent(NotificationData scn)
536  {
537  	emit notify(&scn);
538  	switch (scn.nmhdr.code) {
539  		case Notification::StyleNeeded:
540  			emit styleNeeded(scn.position);
541  			break;
542  		case Notification::CharAdded:
543  			emit charAdded(scn.ch);
544  			break;
545  		case Notification::SavePointReached:
546  			emit savePointChanged(false);
547  			break;
548  		case Notification::SavePointLeft:
549  			emit savePointChanged(true);
550  			break;
551  		case Notification::ModifyAttemptRO:
552  			emit modifyAttemptReadOnly();
553  			break;
554  		case Notification::Key:
555  			emit key(scn.ch);
556  			break;
557  		case Notification::DoubleClick:
558  			emit doubleClick(scn.position, scn.line);
559  			break;
560  		case Notification::UpdateUI:
561  			emit updateUi(scn.updated);
562  			break;
563  		case Notification::Modified:
564  		{
565  			const bool added = FlagSet(scn.modificationType, ModificationFlags::InsertText);
566  			const bool deleted = FlagSet(scn.modificationType, ModificationFlags::DeleteText);
567  			const Scintilla::Position length = send(SCI_GETTEXTLENGTH);
568  			bool firstLineAdded = (added && length == 1) ||
569  			                      (deleted && length == 0);
570  			if (scn.linesAdded != 0) {
571  				emit linesAdded(scn.linesAdded);
572  			} else if (firstLineAdded) {
573  				emit linesAdded(added ? 1 : -1);
574  			}
575  			const QByteArray bytes = QByteArray::fromRawData(scn.text, scn.text ? scn.length : 0);
576  			emit modified(scn.modificationType, scn.position, scn.length,
577  			              scn.linesAdded, bytes, scn.line,
578  			              scn.foldLevelNow, scn.foldLevelPrev);
579  			break;
580  		}
581  		case Notification::MacroRecord:
582  			emit macroRecord(scn.message, scn.wParam, scn.lParam);
583  			break;
584  		case Notification::MarginClick:
585  			emit marginClicked(scn.position, scn.modifiers, scn.margin);
586  			break;
587  		case Notification::NeedShown:
588  			emit needShown(scn.position, scn.length);
589  			break;
590  		case Notification::Painted:
591  			emit painted();
592  			break;
593  		case Notification::UserListSelection:
594  			emit userListSelection();
595  			break;
596  		case Notification::URIDropped:
597  			emit uriDropped(QString::fromUtf8(scn.text));
598  			break;
599  		case Notification::DwellStart:
600  			emit dwellStart(scn.x, scn.y);
601  			break;
602  		case Notification::DwellEnd:
603  			emit dwellEnd(scn.x, scn.y);
604  			break;
605  		case Notification::Zoom:
606  			emit zoom(send(SCI_GETZOOM));
607  			break;
608  		case Notification::HotSpotClick:
609  			emit hotSpotClick(scn.position, scn.modifiers);
610  			break;
611  		case Notification::HotSpotDoubleClick:
612  			emit hotSpotDoubleClick(scn.position, scn.modifiers);
613  			break;
614  		case Notification::CallTipClick:
615  			emit callTipClick();
616  			break;
617  		case Notification::AutoCSelection:
618  			emit autoCompleteSelection(scn.lParam, QString::fromUtf8(scn.text));
619  			break;
620  		case Notification::AutoCCancelled:
621  			emit autoCompleteCancelled();
622  			break;
623  		case Notification::FocusIn:
624  			emit focusChanged(true);
625  			break;
626  		case Notification::FocusOut:
627  			emit focusChanged(false);
628  			break;
629  		default:
630  			return;
631  	}
632  }
633  void ScintillaEditBase::event_command(uptr_t wParam, sptr_t lParam)
634  {
635  	emit command(wParam, lParam);
636  }
637  KeyMod ScintillaEditBase::ModifiersOfKeyboard()
638  {
639  	const bool shift = QApplication::keyboardModifiers() & Qt::ShiftModifier;
640  	const bool ctrl  = QApplication::keyboardModifiers() & Qt::ControlModifier;
641  	const bool alt   = QApplication::keyboardModifiers() & Qt::AltModifier;
642  	return ModifierFlags(shift, ctrl, alt);
643  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-ScintillaEditBase.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-ScintillaEditBase.cpp</div>
                </div>
                <div class="column column_space"><pre><code>351  		sqt->sel.Range(r).anchor.SetPosition(positionInsert + offset);
352   	}
</pre></code></div>
                <div class="column column_space"><pre><code>351  		sqt->sel.Range(r).anchor.SetPosition(positionInsert + offset);
352   	}
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    