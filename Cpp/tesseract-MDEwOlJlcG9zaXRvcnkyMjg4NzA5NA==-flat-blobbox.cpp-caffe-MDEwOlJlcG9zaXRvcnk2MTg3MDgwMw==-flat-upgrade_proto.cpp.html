
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 8.117706747843734%, Tokens: 16</h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-blobbox.cpp</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #  include "config_auto.h"
3  #endif
4  #include "blobbox.h"
5  #include "blobs.h"   
6  #include "coutln.h"  
7  #include "environ.h" 
8  #include "host.h"    
9  #include "points.h"  
10  #include "helpers.h" 
11  #include <allheaders.h> 
12  #include <algorithm> 
13  #include <cmath>
14  #include <cstdint>   
15  #define PROJECTION_MARGIN 10 
16  namespace tesseract {
17  const double kCosSmallAngle = 0.866;
18  const double kDefiniteAspectRatio = 2.0;
19  const double kComplexShapePerimeterRatio = 1.5;
20  const double kMinMediumSizeRatio = 0.25;
21  const double kMaxMediumSizeRatio = 4.0;
22  void BLOBNBOX::rotate(FCOORD rotation) {
23    cblob_ptr->rotate(rotation);
24    rotate_box(rotation);
25    compute_bounding_box();
26  }
27  void BLOBNBOX::reflect_box_in_y_axis() {
28    int left = -box.right();
29    box.set_right(-box.left());
30    box.set_left(left);
31  }
32  void BLOBNBOX::rotate_box(FCOORD rotation) {
33    if (IsDiacritic()) {
34      ASSERT_HOST(rotation.x() >= kCosSmallAngle);
35      ICOORD top_pt((box.left() + box.right()) / 2, base_char_top_);
36      ICOORD bottom_pt(top_pt.x(), base_char_bottom_);
37      top_pt.rotate(rotation);
38      base_char_top_ = top_pt.y();
39      bottom_pt.rotate(rotation);
40      base_char_bottom_ = bottom_pt.y();
41      box.rotate(rotation);
42    } else {
43      box.rotate(rotation);
44      set_diacritic_box(box);
45    }
46  }
47  void BLOBNBOX::merge(  
48      BLOBNBOX *nextblob 
49  ) {
50    box += nextblob->box; 
51    set_diacritic_box(box);
52    nextblob->joined = true;
53  }
54  void BLOBNBOX::really_merge(BLOBNBOX *other) {
55    if (other->cblob_ptr != nullptr) {
56      C_OUTLINE_IT ol_it(cblob_ptr->out_list());
57      ol_it.add_list_after(other->cblob_ptr->out_list());
58    }
59    compute_bounding_box();
60  }
61  void BLOBNBOX::chop(       
62      BLOBNBOX_IT *start_it, 
63      BLOBNBOX_IT *end_it,   
64      FCOORD rotation,       
65      float xheight          
66  ) {
67    int16_t blobcount;          
68    BLOBNBOX *newblob;          
69    BLOBNBOX *blob;             
70    int16_t blobindex;          
71    int16_t leftx;              
72    float blobwidth;            
73    float rightx;               
74    float ymin, ymax;           
75    float test_ymin, test_ymax; 
76    ICOORD bl, tr;              
77    BLOBNBOX_IT blob_it;        
78    blobcount = static_cast<int16_t>(std::floor(box.width() / xheight));
79    if (blobcount > 1 && cblob_ptr != nullptr) {
80      blobwidth = static_cast<float>(box.width() + 1) / blobcount;
81      for (blobindex = blobcount - 1, rightx = box.right(); blobindex >= 0;
82           blobindex--, rightx -= blobwidth) {
83        ymin = static_cast<float>(INT32_MAX);
84        ymax = static_cast<float>(-INT32_MAX);
85        blob_it = *start_it;
86        do {
87          blob = blob_it.data();
88          find_cblob_vlimits(blob->cblob_ptr, rightx - blobwidth, rightx,
89                              test_ymin, test_ymax);
90          blob_it.forward();
91          UpdateRange(test_ymin, test_ymax, &ymin, &ymax);
92        } while (blob != end_it->data());
93        if (ymin < ymax) {
94          leftx = static_cast<int16_t>(std::floor(rightx - blobwidth));
95          if (leftx < box.left()) {
96            leftx = box.left(); 
97          }
98          bl = ICOORD(leftx, static_cast<int16_t>(std::floor(ymin)));
99          tr = ICOORD(static_cast<int16_t>(std::ceil(rightx)), static_cast<int16_t>(std::ceil(ymax)));
100          if (blobindex == 0) {
101            box = TBOX(bl, tr); 
102          } else {
103            newblob = new BLOBNBOX;
104            newblob->box = TBOX(bl, tr);
105            newblob->base_char_top_ = tr.y();
106            newblob->base_char_bottom_ = bl.y();
107            end_it->add_after_stay_put(newblob);
108          }
109        }
110      }
111    }
112  }
113  void BLOBNBOX::NeighbourGaps(int gaps[BND_COUNT]) const {
114    for (int dir = 0; dir < BND_COUNT; ++dir) {
115      gaps[dir] = INT16_MAX;
116      BLOBNBOX *neighbour = neighbours_[dir];
117      if (neighbour != nullptr) {
118        const TBOX &n_box = neighbour->bounding_box();
119        if (dir == BND_LEFT || dir == BND_RIGHT) {
120          gaps[dir] = box.x_gap(n_box);
121        } else {
122          gaps[dir] = box.y_gap(n_box);
123        }
124      }
125    }
126  }
127  void BLOBNBOX::MinMaxGapsClipped(int *h_min, int *h_max, int *v_min, int *v_max) const {
128    int max_dimension = std::max(box.width(), box.height());
129    int gaps[BND_COUNT];
130    NeighbourGaps(gaps);
131    *h_min = std::min(gaps[BND_LEFT], gaps[BND_RIGHT]);
132    *h_max = std::max(gaps[BND_LEFT], gaps[BND_RIGHT]);
133    if (*h_max > max_dimension && *h_min < max_dimension) {
134      *h_max = *h_min;
135    }
136    *v_min = std::min(gaps[BND_ABOVE], gaps[BND_BELOW]);
137    *v_max = std::max(gaps[BND_ABOVE], gaps[BND_BELOW]);
138    if (*v_max > max_dimension && *v_min < max_dimension) {
139      *v_max = *v_min;
140    }
141  }
142  void BLOBNBOX::CleanNeighbours() {
143    for (int dir = 0; dir < BND_COUNT; ++dir) {
144      BLOBNBOX *neighbour = neighbours_[dir];
145      if (neighbour != nullptr && neighbour->DeletableNoise()) {
146        neighbours_[dir] = nullptr;
147        good_stroke_neighbours_[dir] = false;
148      }
149    }
150  }
151  int BLOBNBOX::GoodTextBlob() const {
152    int score = 0;
153    for (int dir = 0; dir < BND_COUNT; ++dir) {
154      auto bnd = static_cast<BlobNeighbourDir>(dir);
155      if (good_stroke_neighbour(bnd)) {
156        ++score;
157      }
158    }
159    return score;
160  }
161  int BLOBNBOX::NoisyNeighbours() const {
162    int count = 0;
163    for (int dir = 0; dir < BND_COUNT; ++dir) {
164      auto bnd = static_cast<BlobNeighbourDir>(dir);
165      BLOBNBOX *blob = neighbour(bnd);
166      if (blob != nullptr && blob->region_type() == BRT_NOISE) {
167        ++count;
168      }
169    }
170    return count;
171  }
172  bool BLOBNBOX::DefiniteIndividualFlow() {
173    if (cblob() == nullptr) {
174      return false;
175    }
176    int box_perimeter = 2 * (box.height() + box.width());
177    if (box.width() > box.height() * kDefiniteAspectRatio) {
178      int perimeter = cblob()->perimeter();
179      if (vert_stroke_width() > 0 || perimeter <= 0) {
180        perimeter -= 2 * vert_stroke_width();
181      } else {
182        perimeter -= 4 * cblob()->area() / perimeter;
183      }
184      perimeter -= 2 * box.width();
185      if (perimeter > kComplexShapePerimeterRatio * box_perimeter) {
186        set_vert_possible(false);
187        set_horz_possible(true);
188        return true;
189      }
190    }
191    if (box.height() > box.width() * kDefiniteAspectRatio) {
192      int perimeter = cblob()->perimeter();
193      if (horz_stroke_width() > 0 || perimeter <= 0) {
194        perimeter -= 2 * horz_stroke_width();
195      } else {
196        perimeter -= 4 * cblob()->area() / perimeter;
197      }
198      perimeter -= 2 * box.height();
199      if (perimeter > kComplexShapePerimeterRatio * box_perimeter) {
200        set_vert_possible(true);
201        set_horz_possible(false);
202        return true;
203      }
204    }
205    return false;
206  }
207  bool BLOBNBOX::ConfirmNoTabViolation(const BLOBNBOX &other) const {
208    if (box.left() < other.box.left() && box.left() < other.left_rule_) {
209      return false;
210    }
211    if (other.box.left() < box.left() && other.box.left() < left_rule_) {
212      return false;
213    }
214    if (box.right() > other.box.right() && box.right() > other.right_rule_) {
215      return false;
216    }
217    if (other.box.right() > box.right() && other.box.right() > right_rule_) {
218      return false;
219    }
220    return true;
221  }
222  bool BLOBNBOX::MatchingStrokeWidth(const BLOBNBOX &other, double fractional_tolerance,
223                                     double constant_tolerance) const {
224    double p_width = area_stroke_width();
225    double n_p_width = other.area_stroke_width();
226    float h_tolerance = horz_stroke_width_ * fractional_tolerance + constant_tolerance;
227    float v_tolerance = vert_stroke_width_ * fractional_tolerance + constant_tolerance;
228    double p_tolerance = p_width * fractional_tolerance + constant_tolerance;
229    bool h_zero = horz_stroke_width_ == 0.0f || other.horz_stroke_width_ == 0.0f;
230    bool v_zero = vert_stroke_width_ == 0.0f || other.vert_stroke_width_ == 0.0f;
231    bool h_ok = !h_zero && NearlyEqual(horz_stroke_width_, other.horz_stroke_width_, h_tolerance);
232    bool v_ok = !v_zero && NearlyEqual(vert_stroke_width_, other.vert_stroke_width_, v_tolerance);
233    bool p_ok = h_zero && v_zero && NearlyEqual(p_width, n_p_width, p_tolerance);
234    return p_ok || ((v_ok || h_ok) && (h_ok || h_zero) && (v_ok || v_zero));
235  }
236  TBOX BLOBNBOX::BoundsWithinLimits(int left, int right) {
237    FCOORD no_rotation(1.0f, 0.0f);
238    float top = box.top();
239    float bottom = box.bottom();
240    if (cblob_ptr != nullptr) {
241      find_cblob_limits(cblob_ptr, static_cast<float>(left), static_cast<float>(right), no_rotation,
242                        bottom, top);
243    }
244    if (top < bottom) {
245      top = box.top();
246      bottom = box.bottom();
247    }
248    FCOORD bot_left(left, bottom);
249    FCOORD top_right(right, top);
250    TBOX shrunken_box(bot_left);
251    TBOX shrunken_box2(top_right);
252    shrunken_box += shrunken_box2;
253    return shrunken_box;
254  }
255  void BLOBNBOX::EstimateBaselinePosition() {
256    baseline_y_ = box.bottom(); 
257    if (cblob_ptr == nullptr) {
258      return;
259    }
260    baseline_y_ = cblob_ptr->EstimateBaselinePosition();
261  }
262  void BLOBNBOX::CleanNeighbours(BLOBNBOX_LIST *blobs) {
263    BLOBNBOX_IT blob_it(blobs);
264    for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
265      blob_it.data()->CleanNeighbours();
266    }
267  }
268  void BLOBNBOX::DeleteNoiseBlobs(BLOBNBOX_LIST *blobs) {
269    BLOBNBOX_IT blob_it(blobs);
270    for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
271      BLOBNBOX *blob = blob_it.data();
272      if (blob->DeletableNoise()) {
273        delete blob->remove_cblob();
274        delete blob_it.extract();
275      }
276    }
277  }
278  void BLOBNBOX::ComputeEdgeOffsets(Image thresholds, Image grey, BLOBNBOX_LIST *blobs) {
279    int grey_height = 0;
280    int thr_height = 0;
281    int scale_factor = 1;
282    if (thresholds != nullptr && grey != nullptr) {
283      grey_height = pixGetHeight(grey);
284      thr_height = pixGetHeight(thresholds);
285      scale_factor = IntCastRounded(static_cast<double>(grey_height) / thr_height);
286    }
287    BLOBNBOX_IT blob_it(blobs);
288    for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
289      BLOBNBOX *blob = blob_it.data();
290      if (blob->cblob() != nullptr) {
291        l_uint32 threshold = 128;
292        if (thresholds != nullptr && grey != nullptr) {
293          const TBOX &box = blob->cblob()->bounding_box();
294          TPOINT pt((box.left() + box.right()) / 2, (box.top() + box.bottom()) / 2);
295          pixGetPixel(thresholds, pt.x / scale_factor, thr_height - 1 - pt.y / scale_factor,
296                      &threshold);
297        }
298        blob->cblob()->ComputeEdgeOffsets(threshold, grey);
299      }
300    }
301  }
302  #ifndef GRAPHICS_DISABLED
303  void BLOBNBOX::PlotBlobs(BLOBNBOX_LIST *list, ScrollView::Color body_colour,
304                           ScrollView::Color child_colour, ScrollView *win) {
305    BLOBNBOX_IT it(list);
306    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
307      it.data()->plot(win, body_colour, child_colour);
308    }
309  }
310  void BLOBNBOX::PlotNoiseBlobs(BLOBNBOX_LIST *list, ScrollView::Color body_colour,
311                                ScrollView::Color child_colour, ScrollView *win) {
312    BLOBNBOX_IT it(list);
313    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
314      BLOBNBOX *blob = it.data();
315      if (blob->DeletableNoise()) {
316        blob->plot(win, body_colour, child_colour);
317      }
318    }
319  }
320  ScrollView::Color BLOBNBOX::TextlineColor(BlobRegionType region_type, BlobTextFlowType flow_type) {
321    switch (region_type) {
322      case BRT_HLINE:
323        return ScrollView::BROWN;
324      case BRT_VLINE:
325        return ScrollView::DARK_GREEN;
326      case BRT_RECTIMAGE:
327        return ScrollView::RED;
328      case BRT_POLYIMAGE:
329        return ScrollView::ORANGE;
330      case BRT_UNKNOWN:
331        return flow_type == BTFT_NONTEXT ? ScrollView::CYAN : ScrollView::WHITE;
332      case BRT_VERT_TEXT:
333        if (flow_type == BTFT_STRONG_CHAIN || flow_type == BTFT_TEXT_ON_IMAGE) {
334          return ScrollView::GREEN;
335        }
336        if (flow_type == BTFT_CHAIN) {
337          return ScrollView::LIME_GREEN;
338        }
339        return ScrollView::YELLOW;
340      case BRT_TEXT:
<span onclick='openModal()' class='match'>341        if (flow_type == BTFT_STRONG_CHAIN) {
342          return ScrollView::BLUE;
343        }
344        if (flow_type == BTFT_TEXT_ON_IMAGE) {
345          return ScrollView::LIGHT_BLUE;
346        }
347        if (flow_type == BTFT_CHAIN) {
348          return ScrollView::MEDIUM_BLUE;
349        }
350        if (flow_type == BTFT_LEADER) {
351          return ScrollView::WHEAT;
352        }
</span>353        if (flow_type == BTFT_NONTEXT) {
354          return ScrollView::PINK;
355        }
356        return ScrollView::MAGENTA;
357      default:
358        return ScrollView::GREY;
359    }
360  }
361  ScrollView::Color BLOBNBOX::BoxColor() const {
362    return TextlineColor(region_type_, flow_);
363  }
364  void BLOBNBOX::plot(ScrollView *window,               
365                      ScrollView::Color blob_colour,    
366                      ScrollView::Color child_colour) { 
367    if (cblob_ptr != nullptr) {
368      cblob_ptr->plot(window, blob_colour, child_colour);
369    }
370  }
371  #endif
372  void find_cblob_limits( 
373      C_BLOB *blob,       
374      float leftx,        
375      float rightx,
376      FCOORD rotation, 
377      float &ymin,     
378      float &ymax) {
379    int16_t stepindex;  
380    ICOORD pos;         
381    ICOORD vec;         
382    C_OUTLINE *outline; 
383    C_OUTLINE_IT out_it = blob->out_list();
384    ymin = static_cast<float>(INT32_MAX);
385    ymax = static_cast<float>(-INT32_MAX);
386    for (out_it.mark_cycle_pt(); !out_it.cycled_list(); out_it.forward()) {
387      outline = out_it.data();
388      pos = outline->start_pos(); 
389      pos.rotate(rotation);
390      for (stepindex = 0; stepindex < outline->pathlength(); stepindex++) {
391        if (pos.x() >= leftx && pos.x() <= rightx) {
392          UpdateRange(pos.y(), &ymin, &ymax);
393        }
394        vec = outline->step(stepindex);
395        vec.rotate(rotation);
396        pos += vec; 
397      }
398    }
399  }
400  void find_cblob_vlimits( 
401      C_BLOB *blob,        
402      float leftx,         
403      float rightx,
404      float &ymin, 
405      float &ymax) {
406    int16_t stepindex;  
407    ICOORD pos;         
408    ICOORD vec;         
409    C_OUTLINE *outline; 
410    C_OUTLINE_IT out_it = blob->out_list();
411    ymin = static_cast<float>(INT32_MAX);
412    ymax = static_cast<float>(-INT32_MAX);
413    for (out_it.mark_cycle_pt(); !out_it.cycled_list(); out_it.forward()) {
414      outline = out_it.data();
415      pos = outline->start_pos(); 
416      for (stepindex = 0; stepindex < outline->pathlength(); stepindex++) {
417        if (pos.x() >= leftx && pos.x() <= rightx) {
418          UpdateRange(pos.y(), &ymin, &ymax);
419        }
420        vec = outline->step(stepindex);
421        pos += vec; 
422      }
423    }
424  }
425  void find_cblob_hlimits( 
426      C_BLOB *blob,        
427      float bottomy,       
428      float topy,
429      float &xmin, 
430      float &xmax) {
431    int16_t stepindex;  
432    ICOORD pos;         
433    ICOORD vec;         
434    C_OUTLINE *outline; 
435    C_OUTLINE_IT out_it = blob->out_list();
436    xmin = static_cast<float>(INT32_MAX);
437    xmax = static_cast<float>(-INT32_MAX);
438    for (out_it.mark_cycle_pt(); !out_it.cycled_list(); out_it.forward()) {
439      outline = out_it.data();
440      pos = outline->start_pos(); 
441      for (stepindex = 0; stepindex < outline->pathlength(); stepindex++) {
442        if (pos.y() >= bottomy && pos.y() <= topy) {
443          UpdateRange(pos.x(), &xmin, &xmax);
444        }
445        vec = outline->step(stepindex);
446        pos += vec; 
447      }
448    }
449  }
450  C_BLOB *crotate_cblob( 
451      C_BLOB *blob,      
452      FCOORD rotation    
453  ) {
454    C_OUTLINE_LIST out_list; 
455    C_OUTLINE_IT in_it = blob->out_list();
456    C_OUTLINE_IT out_it = &out_list;
457    for (in_it.mark_cycle_pt(); !in_it.cycled_list(); in_it.forward()) {
458      out_it.add_after_then_move(new C_OUTLINE(in_it.data(), rotation));
459    }
460    return new C_BLOB(&out_list);
461  }
462  TBOX box_next(      
463      BLOBNBOX_IT *it 
464  ) {
465    BLOBNBOX *blob; 
466    TBOX result;    
467    blob = it->data();
468    result = blob->bounding_box();
469    do {
470      it->forward();
471      blob = it->data();
472      if (blob->cblob() == nullptr) {
473        result += blob->bounding_box();
474      }
475    }
476    while ((blob->cblob() == nullptr) || blob->joined_to_prev());
477    return result;
478  }
479  TBOX box_next_pre_chopped( 
480      BLOBNBOX_IT *it        
481  ) {
482    BLOBNBOX *blob; 
483    TBOX result;    
484    blob = it->data();
485    result = blob->bounding_box();
486    do {
487      it->forward();
488      blob = it->data();
489    }
490    while (blob->joined_to_prev());
491    return result;
492  }
493  TO_ROW::TO_ROW(     
494      BLOBNBOX *blob, 
495      float top,      
496      float bottom,   
497      float row_size  
498  ) {
499    clear();
500    y_min = bottom;
501    y_max = top;
502    initial_y_min = bottom;
503    float diff;              
504    BLOBNBOX_IT it = &blobs; 
505    it.add_to_end(blob);
506    diff = top - bottom - row_size;
507    if (diff > 0) {
508      y_max -= diff / 2;
509      y_min += diff / 2;
510    }
511    else if ((top - bottom) * 3 < row_size) {
512      diff = row_size / 3 + bottom - top;
513      y_max += diff / 2;
514      y_min -= diff / 2;
515    }
516  }
517  void TO_ROW::print() const {
518    tprintf(
519        "pitch=%d, fp=%g, fps=%g, fpns=%g, prs=%g, prns=%g,"
520        " spacing=%g xh=%g y_origin=%g xev=%d, asc=%g, desc=%g,"
521        " body=%g, minsp=%d maxnsp=%d, thr=%d kern=%g sp=%g\n",
522        pitch_decision, fixed_pitch, fp_space, fp_nonsp, pr_space, pr_nonsp, spacing, xheight,
523        y_origin, xheight_evidence, ascrise, descdrop, body_size, min_space, max_nonspace,
524        space_threshold, kern_size, space_size);
525  }
526  void TO_ROW::add_blob( 
527      BLOBNBOX *blob,    
528      float top,         
529      float bottom,      
530      float row_size     
531  ) {
532    float allowed;           
533    float available;         
534    BLOBNBOX_IT it = &blobs; 
535    it.add_to_end(blob);
536    allowed = row_size + y_min - y_max;
537    if (allowed > 0) {
538      available = top > y_max ? top - y_max : 0;
539      if (bottom < y_min) {
540        available += y_min - bottom;
541      }
542      if (available > 0) {
543        available += available; 
544        if (available < allowed) {
545          available = allowed;
546        }
547        if (bottom < y_min) {
548          y_min -= (y_min - bottom) * allowed / available;
549        }
550        if (top > y_max) {
551          y_max += (top - y_max) * allowed / available;
552        }
553      }
554    }
555  }
556  void TO_ROW::insert_blob( 
557      BLOBNBOX *blob        
558  ) {
559    BLOBNBOX_IT it = &blobs; 
560    if (it.empty()) {
561      it.add_before_then_move(blob);
562    } else {
563      it.mark_cycle_pt();
564      while (!it.cycled_list() && it.data()->bounding_box().left() <= blob->bounding_box().left()) {
565        it.forward();
566      }
567      if (it.cycled_list()) {
568        it.add_to_end(blob);
569      } else {
570        it.add_before_stay_put(blob);
571      }
572    }
573  }
574  void TO_ROW::compute_vertical_projection() { 
575    TBOX row_box;                              
576    BLOBNBOX *blob;                            
577    TBOX blob_box;                             
578    BLOBNBOX_IT blob_it = blob_list();
579    if (blob_it.empty()) {
580      return;
581    }
582    row_box = blob_it.data()->bounding_box();
583    for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
584      row_box += blob_it.data()->bounding_box();
585    }
586    projection.set_range(row_box.left() - PROJECTION_MARGIN, row_box.right() + PROJECTION_MARGIN - 1);
587    projection_left = row_box.left() - PROJECTION_MARGIN;
588    projection_right = row_box.right() + PROJECTION_MARGIN;
589    for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
590      blob = blob_it.data();
591      if (blob->cblob() != nullptr) {
592        vertical_cblob_projection(blob->cblob(), &projection);
593      }
594    }
595  }
596  void TO_ROW::clear() {
597    all_caps = false;
598    used_dm_model = false;
599    projection_left = 0;
600    projection_right = 0;
601    pitch_decision = PITCH_DUNNO;
602    fixed_pitch = 0.0;
603    fp_space = 0.0;
604    fp_nonsp = 0.0;
605    pr_space = 0.0;
606    pr_nonsp = 0.0;
607    spacing = 0.0;
608    xheight = 0.0;
609    xheight_evidence = 0;
610    body_size = 0.0;
611    ascrise = 0.0;
612    descdrop = 0.0;
613    min_space = 0;
614    max_nonspace = 0;
615    space_threshold = 0;
616    kern_size = 0.0;
617    space_size = 0.0;
618    y_min = 0.0;
619    y_max = 0.0;
620    initial_y_min = 0.0;
621    m = 0.0;
622    c = 0.0;
623    error = 0.0;
624    para_c = 0.0;
625    para_error = 0.0;
626    y_origin = 0.0;
627    credibility = 0.0;
628    num_repeated_sets_ = -1;
629  }
630  void vertical_cblob_projection( 
631      C_BLOB *blob,               
632      STATS *stats                
633  ) {
634    C_OUTLINE_IT out_it = blob->out_list();
635    for (out_it.mark_cycle_pt(); !out_it.cycled_list(); out_it.forward()) {
636      vertical_coutline_projection(out_it.data(), stats);
637    }
638  }
639  void vertical_coutline_projection( 
640      C_OUTLINE *outline,            
641      STATS *stats                   
642  ) {
643    ICOORD pos;        
644    ICOORD step;       
645    int32_t length;    
646    int16_t stepindex; 
647    C_OUTLINE_IT out_it = outline->child();
648    pos = outline->start_pos();
649    length = outline->pathlength();
650    for (stepindex = 0; stepindex < length; stepindex++) {
651      step = outline->step(stepindex);
652      if (step.x() > 0) {
653        stats->add(pos.x(), -pos.y());
654      } else if (step.x() < 0) {
655        stats->add(pos.x() - 1, pos.y());
656      }
657      pos += step;
658    }
659    for (out_it.mark_cycle_pt(); !out_it.cycled_list(); out_it.forward()) {
660      vertical_coutline_projection(out_it.data(), stats);
661    }
662  }
663  TO_BLOCK::TO_BLOCK(  
664      BLOCK *src_block 
665  ) {
666    clear();
667    block = src_block;
668  }
669  void TO_BLOCK::clear() {
670    block = nullptr;
671    pitch_decision = PITCH_DUNNO;
672    line_spacing = 0.0;
673    line_size = 0.0;
674    max_blob_size = 0.0;
675    baseline_offset = 0.0;
676    xheight = 0.0;
677    fixed_pitch = 0.0;
678    kern_size = 0.0;
679    space_size = 0.0;
680    min_space = 0;
681    max_nonspace = 0;
682    fp_space = 0.0;
683    fp_nonsp = 0.0;
684    pr_space = 0.0;
685    pr_nonsp = 0.0;
686    key_row = nullptr;
687  }
688  TO_BLOCK::~TO_BLOCK() {
689    BLOBNBOX::clear_blobnboxes(&blobs);
690    BLOBNBOX::clear_blobnboxes(&underlines);
691    BLOBNBOX::clear_blobnboxes(&noise_blobs);
692    BLOBNBOX::clear_blobnboxes(&small_blobs);
693    BLOBNBOX::clear_blobnboxes(&large_blobs);
694  }
695  static void SizeFilterBlobs(int min_height, int max_height, BLOBNBOX_LIST *src_list,
696                              BLOBNBOX_LIST *noise_list, BLOBNBOX_LIST *small_list,
697                              BLOBNBOX_LIST *medium_list, BLOBNBOX_LIST *large_list) {
698    BLOBNBOX_IT noise_it(noise_list);
699    BLOBNBOX_IT small_it(small_list);
700    BLOBNBOX_IT medium_it(medium_list);
701    BLOBNBOX_IT large_it(large_list);
702    for (BLOBNBOX_IT src_it(src_list); !src_it.empty(); src_it.forward()) {
703      BLOBNBOX *blob = src_it.extract();
704      blob->ReInit();
705      int width = blob->bounding_box().width();
706      int height = blob->bounding_box().height();
707      if (height < min_height && (width < min_height || width > max_height)) {
708        noise_it.add_after_then_move(blob);
709      } else if (height > max_height) {
710        large_it.add_after_then_move(blob);
711      } else if (height < min_height) {
712        small_it.add_after_then_move(blob);
713      } else {
714        medium_it.add_after_then_move(blob);
715      }
716    }
717  }
718  void TO_BLOCK::ReSetAndReFilterBlobs() {
719    int min_height = IntCastRounded(kMinMediumSizeRatio * line_size);
720    int max_height = IntCastRounded(kMaxMediumSizeRatio * line_size);
721    BLOBNBOX_LIST noise_list;
722    BLOBNBOX_LIST small_list;
723    BLOBNBOX_LIST medium_list;
724    BLOBNBOX_LIST large_list;
725    SizeFilterBlobs(min_height, max_height, &blobs, &noise_list, &small_list, &medium_list,
726                    &large_list);
727    SizeFilterBlobs(min_height, max_height, &large_blobs, &noise_list, &small_list, &medium_list,
728                    &large_list);
729    SizeFilterBlobs(min_height, max_height, &small_blobs, &noise_list, &small_list, &medium_list,
730                    &large_list);
731    SizeFilterBlobs(min_height, max_height, &noise_blobs, &noise_list, &small_list, &medium_list,
732                    &large_list);
733    BLOBNBOX_IT blob_it(&blobs);
734    blob_it.add_list_after(&medium_list);
735    blob_it.set_to_list(&large_blobs);
736    blob_it.add_list_after(&large_list);
737    blob_it.set_to_list(&small_blobs);
738    blob_it.add_list_after(&small_list);
739    blob_it.set_to_list(&noise_blobs);
740    blob_it.add_list_after(&noise_list);
741  }
742  void TO_BLOCK::DeleteUnownedNoise() {
743    BLOBNBOX::CleanNeighbours(&blobs);
744    BLOBNBOX::CleanNeighbours(&small_blobs);
745    BLOBNBOX::CleanNeighbours(&noise_blobs);
746    BLOBNBOX::CleanNeighbours(&large_blobs);
747    BLOBNBOX::DeleteNoiseBlobs(&blobs);
748    BLOBNBOX::DeleteNoiseBlobs(&small_blobs);
749    BLOBNBOX::DeleteNoiseBlobs(&noise_blobs);
750    BLOBNBOX::DeleteNoiseBlobs(&large_blobs);
751  }
752  void TO_BLOCK::ComputeEdgeOffsets(Image thresholds, Image grey) {
753    BLOBNBOX::ComputeEdgeOffsets(thresholds, grey, &blobs);
754    BLOBNBOX::ComputeEdgeOffsets(thresholds, grey, &small_blobs);
755    BLOBNBOX::ComputeEdgeOffsets(thresholds, grey, &noise_blobs);
756  }
757  #ifndef GRAPHICS_DISABLED
758  void TO_BLOCK::plot_noise_blobs(ScrollView *win) {
759    BLOBNBOX::PlotNoiseBlobs(&noise_blobs, ScrollView::RED, ScrollView::RED, win);
760    BLOBNBOX::PlotNoiseBlobs(&small_blobs, ScrollView::RED, ScrollView::RED, win);
761    BLOBNBOX::PlotNoiseBlobs(&large_blobs, ScrollView::RED, ScrollView::RED, win);
762    BLOBNBOX::PlotNoiseBlobs(&blobs, ScrollView::RED, ScrollView::RED, win);
763  }
764  void TO_BLOCK::plot_graded_blobs(ScrollView *win) {
765    BLOBNBOX::PlotBlobs(&noise_blobs, ScrollView::CORAL, ScrollView::BLUE, win);
766    BLOBNBOX::PlotBlobs(&small_blobs, ScrollView::GOLDENROD, ScrollView::YELLOW, win);
767    BLOBNBOX::PlotBlobs(&large_blobs, ScrollView::DARK_GREEN, ScrollView::YELLOW, win);
768    BLOBNBOX::PlotBlobs(&blobs, ScrollView::WHITE, ScrollView::BROWN, win);
769  }
770  void plot_blob_list(ScrollView *win,                  
771                      BLOBNBOX_LIST *list,              
772                      ScrollView::Color body_colour,    
773                      ScrollView::Color child_colour) { 
774    BLOBNBOX_IT it = list;
775    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
776      it.data()->plot(win, body_colour, child_colour);
777    }
778  }
779  #endif 
780  } 
</code></pre>
        </div>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-upgrade_proto.cpp</h3>
            <pre><code>1  #include <google/protobuf/io/coded_stream.h>
2  #include <google/protobuf/io/zero_copy_stream_impl.h>
3  #include <google/protobuf/text_format.h>
4  #include <boost/algorithm/string/replace.hpp>
5  #include <map>
6  #include <string>
7  #include "caffe/common.hpp"
8  #include "caffe/proto/caffe.pb.h"
9  #include "caffe/util/io.hpp"
10  #include "caffe/util/upgrade_proto.hpp"
11  #ifdef USE_MLSL
12  #include "caffe/multinode/mlsl.hpp"
13  #endif &bsol;* USE_MLSL */
14  namespace caffe {
15  bool NetNeedsUpgrade(const NetParameter& net_param) {
16    return NetNeedsV0ToV1Upgrade(net_param) || NetNeedsV1ToV2Upgrade(net_param)
17        || NetNeedsDataUpgrade(net_param) || NetNeedsInputUpgrade(net_param);
18  }
19  bool UpgradeNetAsNeeded(const string& param_file, NetParameter* param) {
20    bool success = true;
21    if (NetNeedsV0ToV1Upgrade(*param)) {
22      LOG(INFO) << "Attempting to upgrade input file specified using deprecated "
23                << "V0LayerParameter: " << param_file;
24      NetParameter original_param(*param);
25      if (!UpgradeV0Net(original_param, param)) {
26        success = false;
27        LOG(ERROR) << "Warning: had one or more problems upgrading "
28            << "V0NetParameter to NetParameter (see above); continuing anyway.";
29      } else {
30        LOG(INFO) << "Successfully upgraded file specified using deprecated "
31                  << "V0LayerParameter";
32      }
33      LOG(WARNING) << "Note that future Caffe releases will not support "
34          << "V0NetParameter; use ./build/tools/upgrade_net_proto_text for "
35          << "prototxt and ./build/tools/upgrade_net_proto_binary for model "
36          << "weights upgrade this and any other net protos to the new format.";
37    }
38    if (NetNeedsDataUpgrade(*param)) {
39      LOG(INFO) << "Attempting to upgrade input file specified using deprecated "
40                << "transformation parameters: " << param_file;
41      UpgradeNetDataTransformation(param);
42      LOG(INFO) << "Successfully upgraded file specified using deprecated "
43                << "data transformation parameters.";
44      LOG(WARNING) << "Note that future Caffe releases will only support "
45                   << "transform_param messages for transformation fields.";
46    }
47    if (NetNeedsV1ToV2Upgrade(*param)) {
48      LOG(INFO) << "Attempting to upgrade input file specified using deprecated "
49                << "V1LayerParameter: " << param_file;
50      NetParameter original_param(*param);
51      if (!UpgradeV1Net(original_param, param)) {
52        success = false;
53        LOG(ERROR) << "Warning: had one or more problems upgrading "
54                   << "V1LayerParameter (see above); continuing anyway.";
55      } else {
56        LOG(INFO) << "Successfully upgraded file specified using deprecated "
57                  << "V1LayerParameter";
58      }
59    }
60    if (NetNeedsInputUpgrade(*param)) {
61      LOG(INFO) << "Attempting to upgrade input file specified using deprecated "
62                << "input fields: " << param_file;
63      UpgradeNetInput(param);
64      LOG(INFO) << "Successfully upgraded file specified using deprecated "
65                << "input fields.";
66      LOG(WARNING) << "Note that future Caffe releases will only support "
67                   << "input layers and not input fields.";
68    }
69    return success;
70  }
71  void ReadNetParamsFromTextFileOrDie(const string& param_file,
72                                      NetParameter* param) {
73    CHECK(ReadProtoFromTextFile(param_file, param))
74        << "Failed to parse NetParameter file: " << param_file;
75  #ifdef USE_MLSL
76    ReplaceMultinodeNetParams(param);
77  #endif
78    UpgradeNetAsNeeded(param_file, param);
79  }
80  void ReadNetParamsFromBinaryFileOrDie(const string& param_file,
81                                        NetParameter* param) {
82    CHECK(ReadProtoFromBinaryFile(param_file, param))
83        << "Failed to parse NetParameter file: " << param_file;
84    UpgradeNetAsNeeded(param_file, param);
85  }
86  bool NetNeedsV0ToV1Upgrade(const NetParameter& net_param) {
87    for (int i = 0; i < net_param.layers_size(); ++i) {
88      if (net_param.layers(i).has_layer()) {
89        return true;
90      }
91    }
92    return false;
93  }
94  bool NetNeedsV1ToV2Upgrade(const NetParameter& net_param) {
95    return net_param.layers_size() > 0;
96  }
97  bool UpgradeV0Net(const NetParameter& v0_net_param_padding_layers,
98                    NetParameter* net_param) {
99    NetParameter v0_net_param;
100    UpgradeV0PaddingLayers(v0_net_param_padding_layers, &v0_net_param);
101    bool is_fully_compatible = true;
102    net_param->Clear();
103    if (v0_net_param.has_name()) {
104      net_param->set_name(v0_net_param.name());
105    }
106    for (int i = 0; i < v0_net_param.layers_size(); ++i) {
107      is_fully_compatible &= UpgradeV0LayerParameter(v0_net_param.layers(i),
108                                                     net_param->add_layers());
109    }
110    for (int i = 0; i < v0_net_param.input_size(); ++i) {
111      net_param->add_input(v0_net_param.input(i));
112    }
113    for (int i = 0; i < v0_net_param.input_dim_size(); ++i) {
114      net_param->add_input_dim(v0_net_param.input_dim(i));
115    }
116    if (v0_net_param.has_force_backward()) {
117      net_param->set_force_backward(v0_net_param.force_backward());
118    }
119    return is_fully_compatible;
120  }
121  void UpgradeV0PaddingLayers(const NetParameter& param,
122                              NetParameter* param_upgraded_pad) {
123    param_upgraded_pad->Clear();
124    param_upgraded_pad->CopyFrom(param);
125    param_upgraded_pad->clear_layers();
126    map<string, int> blob_name_to_last_top_idx;
127    for (int i = 0; i < param.input_size(); ++i) {
128      const string& blob_name = param.input(i);
129      blob_name_to_last_top_idx[blob_name] = -1;
130    }
131    for (int i = 0; i < param.layers_size(); ++i) {
132      const V1LayerParameter& layer_connection = param.layers(i);
133      const V0LayerParameter& layer_param = layer_connection.layer();
134      if (layer_param.type() != "padding") {
135        param_upgraded_pad->add_layers()->CopyFrom(layer_connection);
136      }
137      for (int j = 0; j < layer_connection.bottom_size(); ++j) {
138        const string& blob_name = layer_connection.bottom(j);
139        if (blob_name_to_last_top_idx.find(blob_name) ==
140            blob_name_to_last_top_idx.end()) {
141          LOG(FATAL) << "Unknown blob input " << blob_name << " to layer " << j;
142        }
143        const int top_idx = blob_name_to_last_top_idx[blob_name];
144        if (top_idx == -1) {
145          continue;
146        }
147        const V1LayerParameter& source_layer = param.layers(top_idx);
148        if (source_layer.layer().type() == "padding") {
149          CHECK((layer_param.type() == "conv") || (layer_param.type() == "pool"))
150              << "Padding layer input to "
151              "non-convolutional / non-pooling layer type "
152              << layer_param.type();
153          CHECK_EQ(layer_connection.bottom_size(), 1)
154              << "Conv Layer takes a single blob as input.";
155          CHECK_EQ(source_layer.bottom_size(), 1)
156              << "Padding Layer takes a single blob as input.";
157          CHECK_EQ(source_layer.top_size(), 1)
158              << "Padding Layer produces a single blob as output.";
159          int layer_index = param_upgraded_pad->layers_size() - 1;
160          param_upgraded_pad->mutable_layers(layer_index)->mutable_layer()
161              ->set_pad(source_layer.layer().pad());
162          param_upgraded_pad->mutable_layers(layer_index)
163              ->set_bottom(j, source_layer.bottom(0));
164        }
165      }
166      for (int j = 0; j < layer_connection.top_size(); ++j) {
167        const string& blob_name = layer_connection.top(j);
168        blob_name_to_last_top_idx[blob_name] = i;
169      }
170    }
171  }
172  bool UpgradeV0LayerParameter(const V1LayerParameter& v0_layer_connection,
173                               V1LayerParameter* layer_param) {
174    bool is_fully_compatible = true;
175    layer_param->Clear();
176    for (int i = 0; i < v0_layer_connection.bottom_size(); ++i) {
177      layer_param->add_bottom(v0_layer_connection.bottom(i));
178    }
179    for (int i = 0; i < v0_layer_connection.top_size(); ++i) {
180      layer_param->add_top(v0_layer_connection.top(i));
181    }
182    if (v0_layer_connection.has_layer()) {
183      const V0LayerParameter& v0_layer_param = v0_layer_connection.layer();
184      if (v0_layer_param.has_name()) {
185        layer_param->set_name(v0_layer_param.name());
186      }
187      const string& type = v0_layer_param.type();
188      if (v0_layer_param.has_type()) {
189        layer_param->set_type(UpgradeV0LayerType(type));
190      }
191      for (int i = 0; i < v0_layer_param.blobs_size(); ++i) {
192        layer_param->add_blobs()->CopyFrom(v0_layer_param.blobs(i));
193      }
194      for (int i = 0; i < v0_layer_param.blobs_lr_size(); ++i) {
195        layer_param->add_blobs_lr(v0_layer_param.blobs_lr(i));
196      }
197      for (int i = 0; i < v0_layer_param.weight_decay_size(); ++i) {
198        layer_param->add_weight_decay(v0_layer_param.weight_decay(i));
199      }
200      if (v0_layer_param.has_num_output()) {
201        if (type == "conv") {
202          layer_param->mutable_convolution_param()->set_num_output(
203              v0_layer_param.num_output());
204        } else if (type == "innerproduct") {
205          layer_param->mutable_inner_product_param()->set_num_output(
206              v0_layer_param.num_output());
207        } else {
208          LOG(ERROR) << "Unknown parameter num_output for layer type " << type;
209          is_fully_compatible = false;
210        }
211      }
212      if (v0_layer_param.has_biasterm()) {
213        if (type == "conv") {
214          layer_param->mutable_convolution_param()->set_bias_term(
215              v0_layer_param.biasterm());
216        } else if (type == "innerproduct") {
217          layer_param->mutable_inner_product_param()->set_bias_term(
218              v0_layer_param.biasterm());
219        } else {
220          LOG(ERROR) << "Unknown parameter biasterm for layer type " << type;
221          is_fully_compatible = false;
222        }
223      }
224      if (v0_layer_param.has_weight_filler()) {
225        if (type == "conv") {
226          layer_param->mutable_convolution_param()->
227              mutable_weight_filler()->CopyFrom(v0_layer_param.weight_filler());
228        } else if (type == "innerproduct") {
229          layer_param->mutable_inner_product_param()->
230              mutable_weight_filler()->CopyFrom(v0_layer_param.weight_filler());
231        } else {
232          LOG(ERROR) << "Unknown parameter weight_filler for layer type " << type;
233          is_fully_compatible = false;
234        }
235      }
236      if (v0_layer_param.has_bias_filler()) {
237        if (type == "conv") {
238          layer_param->mutable_convolution_param()->
239              mutable_bias_filler()->CopyFrom(v0_layer_param.bias_filler());
240        } else if (type == "innerproduct") {
241          layer_param->mutable_inner_product_param()->
242              mutable_bias_filler()->CopyFrom(v0_layer_param.bias_filler());
243        } else {
244          LOG(ERROR) << "Unknown parameter bias_filler for layer type " << type;
245          is_fully_compatible = false;
246        }
247      }
248      if (v0_layer_param.has_pad()) {
249        if (type == "conv") {
250          layer_param->mutable_convolution_param()->add_pad(v0_layer_param.pad());
251        } else if (type == "pool") {
252          layer_param->mutable_pooling_param()->set_pad(v0_layer_param.pad());
253        } else {
254          LOG(ERROR) << "Unknown parameter pad for layer type " << type;
255          is_fully_compatible = false;
256        }
257      }
258      if (v0_layer_param.has_kernelsize()) {
259        if (type == "conv") {
260          layer_param->mutable_convolution_param()->add_kernel_size(
261              v0_layer_param.kernelsize());
262        } else if (type == "pool") {
263          layer_param->mutable_pooling_param()->set_kernel_size(
264              v0_layer_param.kernelsize());
265        } else {
266          LOG(ERROR) << "Unknown parameter kernelsize for layer type " << type;
267          is_fully_compatible = false;
268        }
269      }
270      if (v0_layer_param.has_group()) {
271        if (type == "conv") {
272          layer_param->mutable_convolution_param()->set_group(
273              v0_layer_param.group());
274        } else {
275          LOG(ERROR) << "Unknown parameter group for layer type " << type;
276          is_fully_compatible = false;
277        }
278      }
279      if (v0_layer_param.has_stride()) {
280        if (type == "conv") {
281          layer_param->mutable_convolution_param()->add_stride(
282              v0_layer_param.stride());
283        } else if (type == "pool") {
284          layer_param->mutable_pooling_param()->set_stride(
285              v0_layer_param.stride());
286        } else {
287          LOG(ERROR) << "Unknown parameter stride for layer type " << type;
288          is_fully_compatible = false;
289        }
290      }
291      if (v0_layer_param.has_pool()) {
292        if (type == "pool") {
293          V0LayerParameter_PoolMethod pool = v0_layer_param.pool();
294          switch (pool) {
295          case V0LayerParameter_PoolMethod_MAX:
296            layer_param->mutable_pooling_param()->set_pool(
297                PoolingParameter_PoolMethod_MAX);
298            break;
299          case V0LayerParameter_PoolMethod_AVE:
300            layer_param->mutable_pooling_param()->set_pool(
301                PoolingParameter_PoolMethod_AVE);
302            break;
303          case V0LayerParameter_PoolMethod_STOCHASTIC:
304            layer_param->mutable_pooling_param()->set_pool(
305                PoolingParameter_PoolMethod_STOCHASTIC);
306            break;
307          default:
308            LOG(ERROR) << "Unknown pool method " << pool;
309            is_fully_compatible = false;
310          }
311        } else {
312          LOG(ERROR) << "Unknown parameter pool for layer type " << type;
313          is_fully_compatible = false;
314        }
315      }
316      if (v0_layer_param.has_dropout_ratio()) {
317        if (type == "dropout") {
318          layer_param->mutable_dropout_param()->set_dropout_ratio(
319              v0_layer_param.dropout_ratio());
320        } else {
321          LOG(ERROR) << "Unknown parameter dropout_ratio for layer type " << type;
322          is_fully_compatible = false;
323        }
324      }
325      if (v0_layer_param.has_local_size()) {
326        if (type == "lrn") {
327          layer_param->mutable_lrn_param()->set_local_size(
328              v0_layer_param.local_size());
329        } else {
330          LOG(ERROR) << "Unknown parameter local_size for layer type " << type;
331          is_fully_compatible = false;
332        }
333      }
334      if (v0_layer_param.has_alpha()) {
335        if (type == "lrn") {
336          layer_param->mutable_lrn_param()->set_alpha(v0_layer_param.alpha());
337        } else {
338          LOG(ERROR) << "Unknown parameter alpha for layer type " << type;
339          is_fully_compatible = false;
340        }
341      }
342      if (v0_layer_param.has_beta()) {
343        if (type == "lrn") {
344          layer_param->mutable_lrn_param()->set_beta(v0_layer_param.beta());
345        } else {
346          LOG(ERROR) << "Unknown parameter beta for layer type " << type;
347          is_fully_compatible = false;
348        }
349      }
350      if (v0_layer_param.has_k()) {
351        if (type == "lrn") {
352          layer_param->mutable_lrn_param()->set_k(v0_layer_param.k());
353        } else {
354          LOG(ERROR) << "Unknown parameter k for layer type " << type;
355          is_fully_compatible = false;
356        }
357      }
358      if (v0_layer_param.has_source()) {
359        if (type == "data") {
360          layer_param->mutable_data_param()->set_source(v0_layer_param.source());
361        } else if (type == "hdf5_data") {
362          layer_param->mutable_hdf5_data_param()->set_source(
363              v0_layer_param.source());
364        } else if (type == "images") {
365          layer_param->mutable_image_data_param()->set_source(
366              v0_layer_param.source());
367        } else if (type == "window_data") {
368          layer_param->mutable_window_data_param()->set_source(
369              v0_layer_param.source());
370        } else if (type == "infogain_loss") {
371          layer_param->mutable_infogain_loss_param()->set_source(
372              v0_layer_param.source());
373        } else {
374          LOG(ERROR) << "Unknown parameter source for layer type " << type;
375          is_fully_compatible = false;
376        }
377      }
378      if (v0_layer_param.has_scale()) {
379        layer_param->mutable_transform_param()->
380            set_scale(v0_layer_param.scale());
381      }
382      if (v0_layer_param.has_meanfile()) {
383        layer_param->mutable_transform_param()->
384            set_mean_file(v0_layer_param.meanfile());
385      }
386      if (v0_layer_param.has_batchsize()) {
387        if (type == "data") {
388          layer_param->mutable_data_param()->set_batch_size(
389              v0_layer_param.batchsize());
390        } else if (type == "hdf5_data") {
391          layer_param->mutable_hdf5_data_param()->set_batch_size(
392              v0_layer_param.batchsize());
393        } else if (type == "images") {
394          layer_param->mutable_image_data_param()->set_batch_size(
395              v0_layer_param.batchsize());
396        } else if (type == "window_data") {
397          layer_param->mutable_window_data_param()->set_batch_size(
398              v0_layer_param.batchsize());
399        } else {
400          LOG(ERROR) << "Unknown parameter batchsize for layer type " << type;
401          is_fully_compatible = false;
402        }
403      }
404      if (v0_layer_param.has_cropsize()) {
405        layer_param->mutable_transform_param()->
406            set_crop_size(v0_layer_param.cropsize());
407      }
408      if (v0_layer_param.has_mirror()) {
409        layer_param->mutable_transform_param()->
410            set_mirror(v0_layer_param.mirror());
411      }
412      if (v0_layer_param.has_rand_skip()) {
413        if (type == "data") {
414          layer_param->mutable_data_param()->set_rand_skip(
415              v0_layer_param.rand_skip());
416        } else if (type == "images") {
417          layer_param->mutable_image_data_param()->set_rand_skip(
418              v0_layer_param.rand_skip());
419        } else {
420          LOG(ERROR) << "Unknown parameter rand_skip for layer type " << type;
421          is_fully_compatible = false;
422        }
423      }
424      if (v0_layer_param.has_shuffle_images()) {
425        if (type == "images") {
426          layer_param->mutable_image_data_param()->set_shuffle(
427              v0_layer_param.shuffle_images());
428        } else {
429          LOG(ERROR) << "Unknown parameter shuffle for layer type " << type;
430          is_fully_compatible = false;
431        }
432      }
433      if (v0_layer_param.has_new_height()) {
434        if (type == "images") {
435          layer_param->mutable_image_data_param()->set_new_height(
436              v0_layer_param.new_height());
437        } else {
438          LOG(ERROR) << "Unknown parameter new_height for layer type " << type;
439          is_fully_compatible = false;
440        }
441      }
442      if (v0_layer_param.has_new_width()) {
443        if (type == "images") {
444          layer_param->mutable_image_data_param()->set_new_width(
445              v0_layer_param.new_width());
446        } else {
447          LOG(ERROR) << "Unknown parameter new_width for layer type " << type;
448          is_fully_compatible = false;
449        }
450      }
451      if (v0_layer_param.has_concat_dim()) {
452        if (type == "concat") {
453          layer_param->mutable_concat_param()->set_concat_dim(
454              v0_layer_param.concat_dim());
455        } else {
456          LOG(ERROR) << "Unknown parameter concat_dim for layer type " << type;
457          is_fully_compatible = false;
458        }
459      }
460      if (v0_layer_param.has_det_fg_threshold()) {
461        if (type == "window_data") {
462          layer_param->mutable_window_data_param()->set_fg_threshold(
463              v0_layer_param.det_fg_threshold());
464        } else {
465          LOG(ERROR) << "Unknown parameter det_fg_threshold for layer type "
466                     << type;
467          is_fully_compatible = false;
468        }
469      }
470      if (v0_layer_param.has_det_bg_threshold()) {
471        if (type == "window_data") {
472          layer_param->mutable_window_data_param()->set_bg_threshold(
473              v0_layer_param.det_bg_threshold());
474        } else {
475          LOG(ERROR) << "Unknown parameter det_bg_threshold for layer type "
476                     << type;
477          is_fully_compatible = false;
478        }
479      }
480      if (v0_layer_param.has_det_fg_fraction()) {
481        if (type == "window_data") {
482          layer_param->mutable_window_data_param()->set_fg_fraction(
483              v0_layer_param.det_fg_fraction());
484        } else {
485          LOG(ERROR) << "Unknown parameter det_fg_fraction for layer type "
486                     << type;
487          is_fully_compatible = false;
488        }
489      }
490      if (v0_layer_param.has_det_context_pad()) {
491        if (type == "window_data") {
492          layer_param->mutable_window_data_param()->set_context_pad(
493              v0_layer_param.det_context_pad());
494        } else {
495          LOG(ERROR) << "Unknown parameter det_context_pad for layer type "
496                     << type;
497          is_fully_compatible = false;
498        }
499      }
500      if (v0_layer_param.has_det_crop_mode()) {
501        if (type == "window_data") {
502          layer_param->mutable_window_data_param()->set_crop_mode(
503              v0_layer_param.det_crop_mode());
504        } else {
505          LOG(ERROR) << "Unknown parameter det_crop_mode for layer type "
506                     << type;
507          is_fully_compatible = false;
508        }
509      }
510      if (v0_layer_param.has_hdf5_output_param()) {
511        if (type == "hdf5_output") {
512          layer_param->mutable_hdf5_output_param()->CopyFrom(
513              v0_layer_param.hdf5_output_param());
514        } else {
515          LOG(ERROR) << "Unknown parameter hdf5_output_param for layer type "
516                     << type;
517          is_fully_compatible = false;
518        }
519      }
520    }
521    return is_fully_compatible;
522  }
523  V1LayerParameter_LayerType UpgradeV0LayerType(const string& type) {
524    if (type == "accuracy") {
525      return V1LayerParameter_LayerType_ACCURACY;
526    } else if (type == "bnll") {
527      return V1LayerParameter_LayerType_BNLL;
528    } else if (type == "concat") {
529      return V1LayerParameter_LayerType_CONCAT;
530    } else if (type == "conv") {
531      return V1LayerParameter_LayerType_CONVOLUTION;
532    } else if (type == "data") {
533      return V1LayerParameter_LayerType_DATA;
534    } else if (type == "dropout") {
535      return V1LayerParameter_LayerType_DROPOUT;
536    } else if (type == "euclidean_loss") {
537      return V1LayerParameter_LayerType_EUCLIDEAN_LOSS;
538    } else if (type == "flatten") {
539      return V1LayerParameter_LayerType_FLATTEN;
540    } else if (type == "hdf5_data") {
541      return V1LayerParameter_LayerType_HDF5_DATA;
542    } else if (type == "hdf5_output") {
543      return V1LayerParameter_LayerType_HDF5_OUTPUT;
544    } else if (type == "im2col") {
545      return V1LayerParameter_LayerType_IM2COL;
546    } else if (type == "images") {
547      return V1LayerParameter_LayerType_IMAGE_DATA;
548    } else if (type == "infogain_loss") {
549      return V1LayerParameter_LayerType_INFOGAIN_LOSS;
550    } else if (type == "innerproduct") {
551      return V1LayerParameter_LayerType_INNER_PRODUCT;
552    } else if (type == "lrn") {
553      return V1LayerParameter_LayerType_LRN;
554    } else if (type == "multinomial_logistic_loss") {
555      return V1LayerParameter_LayerType_MULTINOMIAL_LOGISTIC_LOSS;
556    } else if (type == "pool") {
557      return V1LayerParameter_LayerType_POOLING;
558    } else if (type == "relu") {
559      return V1LayerParameter_LayerType_RELU;
560    } else if (type == "sigmoid") {
561      return V1LayerParameter_LayerType_SIGMOID;
562    } else if (type == "softmax") {
563      return V1LayerParameter_LayerType_SOFTMAX;
564    } else if (type == "softmax_loss") {
565      return V1LayerParameter_LayerType_SOFTMAX_LOSS;
566    } else if (type == "split") {
567      return V1LayerParameter_LayerType_SPLIT;
568    } else if (type == "tanh") {
569      return V1LayerParameter_LayerType_TANH;
570    } else if (type == "window_data") {
571      return V1LayerParameter_LayerType_WINDOW_DATA;
572    } else {
573      LOG(FATAL) << "Unknown layer name: " << type;
574      return V1LayerParameter_LayerType_NONE;
575    }
576  }
577  bool NetNeedsDataUpgrade(const NetParameter& net_param) {
578    for (int i = 0; i < net_param.layers_size(); ++i) {
579      if (net_param.layers(i).type() == V1LayerParameter_LayerType_DATA) {
580        DataParameter layer_param = net_param.layers(i).data_param();
581        if (layer_param.has_scale()) { return true; }
582        if (layer_param.has_mean_file()) { return true; }
583        if (layer_param.has_crop_size()) { return true; }
584        if (layer_param.has_mirror()) { return true; }
585      }
586      if (net_param.layers(i).type() == V1LayerParameter_LayerType_IMAGE_DATA) {
587        ImageDataParameter layer_param = net_param.layers(i).image_data_param();
<span onclick='openModal()' class='match'>588        if (layer_param.has_scale()) { return true; }
589        if (layer_param.has_mean_file()) { return true; }
590        if (layer_param.has_crop_size()) { return true; }
591        if (layer_param.has_mirror()) { return true; }
</span>592      }
593      if (net_param.layers(i).type() == V1LayerParameter_LayerType_WINDOW_DATA) {
594        WindowDataParameter layer_param = net_param.layers(i).window_data_param();
595        if (layer_param.has_scale()) { return true; }
596        if (layer_param.has_mean_file()) { return true; }
597        if (layer_param.has_crop_size()) { return true; }
598        if (layer_param.has_mirror()) { return true; }
599      }
600    }
601    return false;
602  }
603  #define CONVERT_LAYER_TRANSFORM_PARAM(TYPE, Name, param_name) \
604    do { \
605      if (net_param->layers(i).type() == V1LayerParameter_LayerType_##TYPE) { \
606        Name##Parameter* layer_param = \
607            net_param->mutable_layers(i)->mutable_##param_name##_param(); \
608        TransformationParameter* transform_param = \
609            net_param->mutable_layers(i)->mutable_transform_param(); \
610        if (layer_param->has_scale()) { \
611          transform_param->set_scale(layer_param->scale()); \
612          layer_param->clear_scale(); \
613        } \
614        if (layer_param->has_mean_file()) { \
615          transform_param->set_mean_file(layer_param->mean_file()); \
616          layer_param->clear_mean_file(); \
617        } \
618        if (layer_param->has_crop_size()) { \
619          transform_param->set_crop_size(layer_param->crop_size()); \
620          layer_param->clear_crop_size(); \
621        } \
622        if (layer_param->has_mirror()) { \
623          transform_param->set_mirror(layer_param->mirror()); \
624          layer_param->clear_mirror(); \
625        } \
626      } \
627    } while (0)
628  void UpgradeNetDataTransformation(NetParameter* net_param) {
629    for (int i = 0; i < net_param->layers_size(); ++i) {
630      CONVERT_LAYER_TRANSFORM_PARAM(DATA, Data, data);
631      CONVERT_LAYER_TRANSFORM_PARAM(IMAGE_DATA, ImageData, image_data);
632      CONVERT_LAYER_TRANSFORM_PARAM(WINDOW_DATA, WindowData, window_data);
633    }
634  }
635  bool UpgradeV1Net(const NetParameter& v1_net_param, NetParameter* net_param) {
636    if (v1_net_param.layer_size() > 0) {
637      LOG(FATAL) << "Refusing to upgrade inconsistent NetParameter input; "
638          << "the definition includes both 'layer' and 'layers' fields. "
639          << "The current format defines 'layer' fields with string type like "
640          << "layer { type: 'Layer' ... } and not layers { type: LAYER ... }. "
641          << "Manually switch the definition to 'layer' format to continue.";
642    }
643    bool is_fully_compatible = true;
644    net_param->CopyFrom(v1_net_param);
645    net_param->clear_layers();
646    net_param->clear_layer();
647    for (int i = 0; i < v1_net_param.layers_size(); ++i) {
648      if (!UpgradeV1LayerParameter(v1_net_param.layers(i),
649                                   net_param->add_layer())) {
650        LOG(ERROR) << "Upgrade of input layer " << i << " failed.";
651        is_fully_compatible = false;
652      }
653    }
654    return is_fully_compatible;
655  }
656  bool UpgradeV1LayerParameter(const V1LayerParameter& v1_layer_param,
657                               LayerParameter* layer_param) {
658    layer_param->Clear();
659    bool is_fully_compatible = true;
660    for (int i = 0; i < v1_layer_param.bottom_size(); ++i) {
661      layer_param->add_bottom(v1_layer_param.bottom(i));
662    }
663    for (int i = 0; i < v1_layer_param.top_size(); ++i) {
664      layer_param->add_top(v1_layer_param.top(i));
665    }
666    if (v1_layer_param.has_name()) {
667      layer_param->set_name(v1_layer_param.name());
668    }
669    for (int i = 0; i < v1_layer_param.include_size(); ++i) {
670      layer_param->add_include()->CopyFrom(v1_layer_param.include(i));
671    }
672    for (int i = 0; i < v1_layer_param.exclude_size(); ++i) {
673      layer_param->add_exclude()->CopyFrom(v1_layer_param.exclude(i));
674    }
675    if (v1_layer_param.has_type()) {
676      layer_param->set_type(UpgradeV1LayerType(v1_layer_param.type()));
677    }
678    for (int i = 0; i < v1_layer_param.blobs_size(); ++i) {
679      layer_param->add_blobs()->CopyFrom(v1_layer_param.blobs(i));
680    }
681    for (int i = 0; i < v1_layer_param.param_size(); ++i) {
682      while (layer_param->param_size() <= i) { layer_param->add_param(); }
683      layer_param->mutable_param(i)->set_name(v1_layer_param.param(i));
684    }
685    ParamSpec_DimCheckMode mode;
686    for (int i = 0; i < v1_layer_param.blob_share_mode_size(); ++i) {
687      while (layer_param->param_size() <= i) { layer_param->add_param(); }
688      switch (v1_layer_param.blob_share_mode(i)) {
689      case V1LayerParameter_DimCheckMode_STRICT:
690        mode = ParamSpec_DimCheckMode_STRICT;
691        break;
692      case V1LayerParameter_DimCheckMode_PERMISSIVE:
693        mode = ParamSpec_DimCheckMode_PERMISSIVE;
694        break;
695      default:
696        LOG(FATAL) << "Unknown blob_share_mode: "
697                   << v1_layer_param.blob_share_mode(i);
698        break;
699      }
700      layer_param->mutable_param(i)->set_share_mode(mode);
701    }
702    for (int i = 0; i < v1_layer_param.blobs_lr_size(); ++i) {
703      while (layer_param->param_size() <= i) { layer_param->add_param(); }
704      layer_param->mutable_param(i)->set_lr_mult(v1_layer_param.blobs_lr(i));
705    }
706    for (int i = 0; i < v1_layer_param.weight_decay_size(); ++i) {
707      while (layer_param->param_size() <= i) { layer_param->add_param(); }
708      layer_param->mutable_param(i)->set_decay_mult(
709          v1_layer_param.weight_decay(i));
710    }
711    for (int i = 0; i < v1_layer_param.loss_weight_size(); ++i) {
712      layer_param->add_loss_weight(v1_layer_param.loss_weight(i));
713    }
714    if (v1_layer_param.has_accuracy_param()) {
715      layer_param->mutable_accuracy_param()->CopyFrom(
716          v1_layer_param.accuracy_param());
717    }
718    if (v1_layer_param.has_argmax_param()) {
719      layer_param->mutable_argmax_param()->CopyFrom(
720          v1_layer_param.argmax_param());
721    }
722    if (v1_layer_param.has_concat_param()) {
723      layer_param->mutable_concat_param()->CopyFrom(
724          v1_layer_param.concat_param());
725    }
726    if (v1_layer_param.has_contrastive_loss_param()) {
727      layer_param->mutable_contrastive_loss_param()->CopyFrom(
728          v1_layer_param.contrastive_loss_param());
729    }
730    if (v1_layer_param.has_convolution_param()) {
731      layer_param->mutable_convolution_param()->CopyFrom(
732          v1_layer_param.convolution_param());
733    }
734    if (v1_layer_param.has_data_param()) {
735      layer_param->mutable_data_param()->CopyFrom(
736          v1_layer_param.data_param());
737    }
738    if (v1_layer_param.has_dropout_param()) {
739      layer_param->mutable_dropout_param()->CopyFrom(
740          v1_layer_param.dropout_param());
741    }
742    if (v1_layer_param.has_dummy_data_param()) {
743      layer_param->mutable_dummy_data_param()->CopyFrom(
744          v1_layer_param.dummy_data_param());
745    }
746    if (v1_layer_param.has_eltwise_param()) {
747      layer_param->mutable_eltwise_param()->CopyFrom(
748          v1_layer_param.eltwise_param());
749    }
750    if (v1_layer_param.has_exp_param()) {
751      layer_param->mutable_exp_param()->CopyFrom(
752          v1_layer_param.exp_param());
753    }
754    if (v1_layer_param.has_hdf5_data_param()) {
755      layer_param->mutable_hdf5_data_param()->CopyFrom(
756          v1_layer_param.hdf5_data_param());
757    }
758    if (v1_layer_param.has_hdf5_output_param()) {
759      layer_param->mutable_hdf5_output_param()->CopyFrom(
760          v1_layer_param.hdf5_output_param());
761    }
762    if (v1_layer_param.has_hinge_loss_param()) {
763      layer_param->mutable_hinge_loss_param()->CopyFrom(
764          v1_layer_param.hinge_loss_param());
765    }
766    if (v1_layer_param.has_image_data_param()) {
767      layer_param->mutable_image_data_param()->CopyFrom(
768          v1_layer_param.image_data_param());
769    }
770    if (v1_layer_param.has_infogain_loss_param()) {
771      layer_param->mutable_infogain_loss_param()->CopyFrom(
772          v1_layer_param.infogain_loss_param());
773    }
774    if (v1_layer_param.has_inner_product_param()) {
775      layer_param->mutable_inner_product_param()->CopyFrom(
776          v1_layer_param.inner_product_param());
777    }
778    if (v1_layer_param.has_lrn_param()) {
779      layer_param->mutable_lrn_param()->CopyFrom(
780          v1_layer_param.lrn_param());
781    }
782    if (v1_layer_param.has_memory_data_param()) {
783      layer_param->mutable_memory_data_param()->CopyFrom(
784          v1_layer_param.memory_data_param());
785    }
786    if (v1_layer_param.has_mvn_param()) {
787      layer_param->mutable_mvn_param()->CopyFrom(
788          v1_layer_param.mvn_param());
789    }
790    if (v1_layer_param.has_pooling_param()) {
791      layer_param->mutable_pooling_param()->CopyFrom(
792          v1_layer_param.pooling_param());
793    }
794    if (v1_layer_param.has_power_param()) {
795      layer_param->mutable_power_param()->CopyFrom(
796          v1_layer_param.power_param());
797    }
798    if (v1_layer_param.has_relu_param()) {
799      layer_param->mutable_relu_param()->CopyFrom(
800          v1_layer_param.relu_param());
801    }
802    if (v1_layer_param.has_sigmoid_param()) {
803      layer_param->mutable_sigmoid_param()->CopyFrom(
804          v1_layer_param.sigmoid_param());
805    }
806    if (v1_layer_param.has_softmax_param()) {
807      layer_param->mutable_softmax_param()->CopyFrom(
808          v1_layer_param.softmax_param());
809    }
810    if (v1_layer_param.has_slice_param()) {
811      layer_param->mutable_slice_param()->CopyFrom(
812          v1_layer_param.slice_param());
813    }
814    if (v1_layer_param.has_tanh_param()) {
815      layer_param->mutable_tanh_param()->CopyFrom(
816          v1_layer_param.tanh_param());
817    }
818    if (v1_layer_param.has_threshold_param()) {
819      layer_param->mutable_threshold_param()->CopyFrom(
820          v1_layer_param.threshold_param());
821    }
822    if (v1_layer_param.has_window_data_param()) {
823      layer_param->mutable_window_data_param()->CopyFrom(
824          v1_layer_param.window_data_param());
825    }
826    if (v1_layer_param.has_transform_param()) {
827      layer_param->mutable_transform_param()->CopyFrom(
828          v1_layer_param.transform_param());
829    }
830    if (v1_layer_param.has_loss_param()) {
831      layer_param->mutable_loss_param()->CopyFrom(
832          v1_layer_param.loss_param());
833    }
834    if (v1_layer_param.has_layer()) {
835      LOG(ERROR) << "Input NetParameter has V0 layer -- ignoring.";
836      is_fully_compatible = false;
837    }
838    return is_fully_compatible;
839  }
840  const char* UpgradeV1LayerType(const V1LayerParameter_LayerType type) {
841    switch (type) {
842    case V1LayerParameter_LayerType_NONE:
843      return "";
844    case V1LayerParameter_LayerType_ABSVAL:
845      return "AbsVal";
846    case V1LayerParameter_LayerType_ACCURACY:
847      return "Accuracy";
848    case V1LayerParameter_LayerType_ARGMAX:
849      return "ArgMax";
850    case V1LayerParameter_LayerType_BNLL:
851      return "BNLL";
852    case V1LayerParameter_LayerType_CONCAT:
853      return "Concat";
854    case V1LayerParameter_LayerType_CONTRASTIVE_LOSS:
855      return "ContrastiveLoss";
856    case V1LayerParameter_LayerType_CONVOLUTION:
857      return "Convolution";
858    case V1LayerParameter_LayerType_DECONVOLUTION:
859      return "Deconvolution";
860    case V1LayerParameter_LayerType_DATA:
861      return "Data";
862    case V1LayerParameter_LayerType_DROPOUT:
863      return "Dropout";
864    case V1LayerParameter_LayerType_DUMMY_DATA:
865      return "DummyData";
866    case V1LayerParameter_LayerType_EUCLIDEAN_LOSS:
867      return "EuclideanLoss";
868    case V1LayerParameter_LayerType_ELTWISE:
869      return "Eltwise";
870    case V1LayerParameter_LayerType_EXP:
871      return "Exp";
872    case V1LayerParameter_LayerType_FLATTEN:
873      return "Flatten";
874    case V1LayerParameter_LayerType_HDF5_DATA:
875      return "HDF5Data";
876    case V1LayerParameter_LayerType_HDF5_OUTPUT:
877      return "HDF5Output";
878    case V1LayerParameter_LayerType_HINGE_LOSS:
879      return "HingeLoss";
880    case V1LayerParameter_LayerType_IM2COL:
881      return "Im2col";
882    case V1LayerParameter_LayerType_IMAGE_DATA:
883      return "ImageData";
884    case V1LayerParameter_LayerType_INFOGAIN_LOSS:
885      return "InfogainLoss";
886    case V1LayerParameter_LayerType_INNER_PRODUCT:
887      return "InnerProduct";
888    case V1LayerParameter_LayerType_LRN:
889      return "LRN";
890    case V1LayerParameter_LayerType_MEMORY_DATA:
891      return "MemoryData";
892    case V1LayerParameter_LayerType_MULTINOMIAL_LOGISTIC_LOSS:
893      return "MultinomialLogisticLoss";
894    case V1LayerParameter_LayerType_MVN:
895      return "MVN";
896    case V1LayerParameter_LayerType_POOLING:
897      return "Pooling";
898    case V1LayerParameter_LayerType_POWER:
899      return "Power";
900    case V1LayerParameter_LayerType_RELU:
901      return "ReLU";
902    case V1LayerParameter_LayerType_SIGMOID:
903      return "Sigmoid";
904    case V1LayerParameter_LayerType_SIGMOID_CROSS_ENTROPY_LOSS:
905      return "SigmoidCrossEntropyLoss";
906    case V1LayerParameter_LayerType_SILENCE:
907      return "Silence";
908    case V1LayerParameter_LayerType_SOFTMAX:
909      return "Softmax";
910    case V1LayerParameter_LayerType_SOFTMAX_LOSS:
911      return "SoftmaxWithLoss";
912    case V1LayerParameter_LayerType_SPLIT:
913      return "Split";
914    case V1LayerParameter_LayerType_SLICE:
915      return "Slice";
916    case V1LayerParameter_LayerType_TANH:
917      return "TanH";
918    case V1LayerParameter_LayerType_WINDOW_DATA:
919      return "WindowData";
920    case V1LayerParameter_LayerType_THRESHOLD:
921      return "Threshold";
922    default:
923      LOG(FATAL) << "Unknown V1LayerParameter layer type: " << type;
924      return "";
925    }
926  }
927  bool NetNeedsInputUpgrade(const NetParameter& net_param) {
928    return net_param.input_size() > 0;
929  }
930  void UpgradeNetInput(NetParameter* net_param) {
931    bool has_shape = net_param->input_shape_size() > 0;
932    bool has_dim = net_param->input_dim_size() > 0;
933    if (has_shape || has_dim) {
934      LayerParameter* layer_param = net_param->add_layer();
935      layer_param->set_name("input");
936      layer_param->set_type("Input");
937      InputParameter* input_param = layer_param->mutable_input_param();
938      for (int i = 0; i < net_param->input_size(); ++i) {
939        layer_param->add_top(net_param->input(i));
940        if (has_shape) {
941          input_param->add_shape()->CopyFrom(net_param->input_shape(i));
942        } else {
943          BlobShape* shape = input_param->add_shape();
944          int first_dim = i*4;
945          int last_dim = first_dim + 4;
946          for (int j = first_dim; j < last_dim; j++) {
947            shape->add_dim(net_param->input_dim(j));
948          }
949        }
950      }
951      for (int i = net_param->layer_size() - 1; i > 0; --i) {
952        net_param->mutable_layer(i-1)->Swap(net_param->mutable_layer(i));
953      }
954    }
955    net_param->clear_input();
956    net_param->clear_input_shape();
957    net_param->clear_input_dim();
958  }
959  bool SolverNeedsTypeUpgrade(const SolverParameter& solver_param) {
960    if (solver_param.has_solver_type()) {
961      return true;
962    }
963    return false;
964  }
965  bool UpgradeSolverType(SolverParameter* solver_param) {
966    CHECK(!solver_param->has_solver_type() || !solver_param->has_type())
967        << "Failed to upgrade solver: old solver_type field (enum) and new type "
968        << "field (string) cannot be both specified in solver proto text.";
969    if (solver_param->has_solver_type()) {
970      string type;
971      switch (solver_param->solver_type()) {
972      case SolverParameter_SolverType_SGD:
973        type = "SGD";
974        break;
975      case SolverParameter_SolverType_NESTEROV:
976        type = "Nesterov";
977        break;
978      case SolverParameter_SolverType_ADAGRAD:
979        type = "AdaGrad";
980        break;
981      case SolverParameter_SolverType_RMSPROP:
982        type = "RMSProp";
983        break;
984      case SolverParameter_SolverType_ADADELTA:
985        type = "AdaDelta";
986        break;
987      case SolverParameter_SolverType_ADAM:
988        type = "Adam";
989        break;
990      default:
991        LOG(FATAL) << "Unknown SolverParameter solver_type: " << type;
992      }
993      solver_param->set_type(type);
994      solver_param->clear_solver_type();
995    } else {
996      LOG(ERROR) << "Warning: solver type already up to date. ";
997      return false;
998    }
999    return true;
1000  }
1001  bool UpgradeSolverAsNeeded(const string& param_file, SolverParameter* param) {
1002    bool success = true;
1003    if (SolverNeedsTypeUpgrade(*param)) {
1004      LOG(INFO) << "Attempting to upgrade input file specified using deprecated "
1005                << "'solver_type' field (enum)': " << param_file;
1006      if (!UpgradeSolverType(param)) {
1007        success = false;
1008        LOG(ERROR) << "Warning: had one or more problems upgrading "
1009                   << "SolverType (see above).";
1010      } else {
1011        LOG(INFO) << "Successfully upgraded file specified using deprecated "
1012                  << "'solver_type' field (enum) to 'type' field (string).";
1013        LOG(WARNING) << "Note that future Caffe releases will only support "
1014                     << "'type' field (string) for a solver's type.";
1015      }
1016    }
1017    return success;
1018  }
1019  void ReadSolverParamsFromTextFileOrDie(const string& param_file,
1020                                         SolverParameter* param) {
1021    CHECK(ReadProtoFromTextFile(param_file, param))
1022        << "Failed to parse SolverParameter file: " << param_file;
1023    UpgradeSolverAsNeeded(param_file, param);
1024  }
1025  #ifdef USE_MLSL
1026  static std::string getNodeId() {
1027    return std::to_string(mn::get_node_id());
1028  }
1029  static std::string getNumNodes() {
1030    return std::to_string(mn::get_nodes_count());
1031  }
1032  void ReplaceMultinodeSolverParams(SolverParameter* param) {
1033    std::string node_id = getNodeId();
1034    std::string num_nodes = getNumNodes();
1035    if (param->has_train_net()) {
1036      std::string* train_net = param->mutable_train_net();
1037      if (train_net) {
1038          boost::replace_all(*train_net, "%#", node_id);
1039          boost::replace_all(*train_net, "%*", num_nodes);
1040      }
1041    }
1042    if (param->has_snapshot_prefix()) {
1043      std::string* prefix = param->mutable_snapshot_prefix();
1044      if (prefix) {
1045          boost::replace_all(*prefix, "%#", node_id);
1046          boost::replace_all(*prefix, "%*", num_nodes);
1047      }
1048    }
1049  }
1050  void ReplaceMultinodeNetParams(NetParameter* param) {
1051    for (int i = 0; i < param->layer_size(); ++i) {
1052      std::string* source = nullptr;
1053      if (param->layer(i).has_data_param()) {
1054        source = param->mutable_layer(i)->mutable_data_param()->
1055                mutable_source();
1056      } else if (param->layer(i).has_image_data_param()) {
1057        source = param->mutable_layer(i)->mutable_image_data_param()->
1058                mutable_source();
1059      }
1060      if (source) {
1061          boost::replace_all(*source, "%#", getNodeId());
1062          boost::replace_all(*source, "%*", getNumNodes());
1063      }
1064    }
1065  }
1066  #endif
1067  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-blobbox.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-upgrade_proto.cpp</div>
                </div>
                <div class="column column_space"><pre><code>341        if (flow_type == BTFT_STRONG_CHAIN) {
342          return ScrollView::BLUE;
343        }
344        if (flow_type == BTFT_TEXT_ON_IMAGE) {
345          return ScrollView::LIGHT_BLUE;
346        }
347        if (flow_type == BTFT_CHAIN) {
348          return ScrollView::MEDIUM_BLUE;
349        }
350        if (flow_type == BTFT_LEADER) {
351          return ScrollView::WHEAT;
352        }
</pre></code></div>
                <div class="column column_space"><pre><code>588        if (layer_param.has_scale()) { return true; }
589        if (layer_param.has_mean_file()) { return true; }
590        if (layer_param.has_crop_size()) { return true; }
591        if (layer_param.has_mirror()) { return true; }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    