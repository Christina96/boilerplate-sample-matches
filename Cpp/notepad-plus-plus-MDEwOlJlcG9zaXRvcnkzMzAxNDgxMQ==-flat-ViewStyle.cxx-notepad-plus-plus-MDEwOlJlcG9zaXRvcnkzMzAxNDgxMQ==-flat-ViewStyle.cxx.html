
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 21, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-ViewStyle.cxx</h3>
            <pre><code>1  #include <cstddef>
2  #include <cassert>
3  #include <cstring>
4  #include <cmath>
5  #include <stdexcept>
6  #include <string>
7  #include <string_view>
8  #include <vector>
9  #include <array>
10  #include <map>
11  #include <set>
12  #include <optional>
13  #include <algorithm>
14  #include <memory>
15  #include <numeric>
16  #include "ScintillaTypes.h"
17  #include "Debugging.h"
18  #include "Geometry.h"
19  #include "Platform.h"
20  #include "Position.h"
21  #include "UniqueString.h"
22  #include "Indicator.h"
23  #include "XPM.h"
24  #include "LineMarker.h"
25  #include "Style.h"
26  #include "ViewStyle.h"
27  using namespace Scintilla;
28  using namespace Scintilla::Internal;
29  MarginStyle::MarginStyle(MarginType style_, int width_, int mask_) noexcept :
30  	style(style_), width(width_), mask(mask_), sensitive(false), cursor(CursorShape::ReverseArrow) {
31  }
32  bool MarginStyle::ShowsFolding() const noexcept {
33  	return (mask & MaskFolders) != 0;
34  }
35  void FontRealised::Realise(Surface &surface, int zoomLevel, Technology technology, const FontSpecification &fs, const char *localeName) {
36  	PLATFORM_ASSERT(fs.fontName);
37  	measurements.sizeZoomed = fs.size + zoomLevel * FontSizeMultiplier;
38  	if (measurements.sizeZoomed <= FontSizeMultiplier)	
39  		measurements.sizeZoomed = FontSizeMultiplier;
40  	const float deviceHeight = static_cast<float>(surface.DeviceHeightFont(measurements.sizeZoomed));
41  	const FontParameters fp(fs.fontName, deviceHeight / FontSizeMultiplier, fs.weight,
42  		fs.italic, fs.extraFontFlag, technology, fs.characterSet, localeName);
43  	font = Font::Allocate(fp);
44  	measurements.ascent = std::floor(surface.Ascent(font.get()));
45  	measurements.descent = std::floor(surface.Descent(font.get()));
46  	measurements.capitalHeight = surface.Ascent(font.get()) - surface.InternalLeading(font.get());
47  	measurements.aveCharWidth = surface.AverageCharWidth(font.get());
48  	measurements.monospaceCharacterWidth = measurements.aveCharWidth;
49  	measurements.spaceWidth = surface.WidthText(font.get(), " ");
50  	if (fs.checkMonospaced) {
51  		constexpr std::string_view allASCIIGraphic("Ayfi"
52  		" !\"#$%&\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~");
53  		std::array<XYPOSITION, allASCIIGraphic.length()> positions {};
54  		surface.MeasureWidthsUTF8(font.get(), allASCIIGraphic, positions.data());
55  		std::adjacent_difference(positions.begin(), positions.end(), positions.begin());
56  		const XYPOSITION maxWidth = *std::max_element(positions.begin(), positions.end());
57  		const XYPOSITION minWidth = *std::min_element(positions.begin(), positions.end());
58  		const XYPOSITION variance = maxWidth - minWidth;
59  		const XYPOSITION scaledVariance = variance / measurements.aveCharWidth;
60  		constexpr XYPOSITION monospaceWidthEpsilon = 0.000001;	
61  		measurements.monospaceASCII = scaledVariance < monospaceWidthEpsilon;
62  		measurements.monospaceCharacterWidth = minWidth;
63  	} else {
64  		measurements.monospaceASCII = false;
65  	}
66  }
67  ViewStyle::ViewStyle(size_t stylesSize_) :
68  	styles(stylesSize_),
69  	markers(MarkerMax + 1),
70  	indicators(static_cast<size_t>(IndicatorNumbers::Max) + 1) {
71  	nextExtendedStyle = 256;
72  	ResetDefaultStyle();
73  	largestMarkerHeight = 0;
74  	indicators[0] = Indicator(IndicatorStyle::Squiggle, ColourRGBA(0, 0x7f, 0));
75  	indicators[1] = Indicator(IndicatorStyle::TT, ColourRGBA(0, 0, 0xff));
76  	indicators[2] = Indicator(IndicatorStyle::Plain, ColourRGBA(0xff, 0, 0));
77  	constexpr ColourRGBA revertedToOrigin(0x40, 0xA0, 0xBF);
78  	constexpr ColourRGBA saved(0x0, 0xA0, 0x0);
79  	constexpr ColourRGBA modified(0xFF, 0x80, 0x0);
80  	constexpr ColourRGBA revertedToChange(0xA0, 0xC0, 0x0);
81  	constexpr size_t indexHistory = static_cast<size_t>(IndicatorNumbers::HistoryRevertedToOriginInsertion);
82  	indicators[indexHistory+0] = Indicator(IndicatorStyle::CompositionThick, revertedToOrigin, false, 30, 60);
83  	indicators[indexHistory+1] = Indicator(IndicatorStyle::Point, revertedToOrigin);
84  	indicators[indexHistory+2] = Indicator(IndicatorStyle::CompositionThick, saved, false, 30, 60);
85  	indicators[indexHistory+3] = Indicator(IndicatorStyle::Point, saved);
86  	indicators[indexHistory+4] = Indicator(IndicatorStyle::CompositionThick, modified, false, 30, 60);
87  	indicators[indexHistory+5] = Indicator(IndicatorStyle::PointTop, modified);
88  	indicators[indexHistory+6] = Indicator(IndicatorStyle::CompositionThick, revertedToChange, false, 30, 60);
89  	indicators[indexHistory+7] = Indicator(IndicatorStyle::Point, revertedToChange);
90  	constexpr size_t indexHistoryRevertedToOrigin = static_cast<size_t>(MarkerOutline::HistoryRevertedToOrigin);
91  	markers[indexHistoryRevertedToOrigin].back = revertedToOrigin;
92  	markers[indexHistoryRevertedToOrigin].fore = revertedToOrigin;
93  	markers[indexHistoryRevertedToOrigin].markType = MarkerSymbol::Bar;
94  	constexpr size_t indexHistorySaved = static_cast<size_t>(MarkerOutline::HistorySaved);
95  	markers[indexHistorySaved].back = saved;
96  	markers[indexHistorySaved].fore = saved;
97  	markers[indexHistorySaved].markType = MarkerSymbol::Bar;
98  	constexpr size_t indexHistoryModified = static_cast<size_t>(MarkerOutline::HistoryModified);
99  	markers[indexHistoryModified].back = Platform::Chrome();
100  	markers[indexHistoryModified].fore = modified;
101  	markers[indexHistoryModified].markType = MarkerSymbol::Bar;
102  	constexpr size_t indexHistoryRevertedToModified = static_cast<size_t>(MarkerOutline::HistoryRevertedToModified);
103  	markers[indexHistoryRevertedToModified].back = revertedToChange;
104  	markers[indexHistoryRevertedToModified].fore = revertedToChange;
105  	markers[indexHistoryRevertedToModified].markType = MarkerSymbol::Bar;
106  	technology = Technology::Default;
107  	indicatorsDynamic = false;
108  	indicatorsSetFore = false;
109  	lineHeight = 1;
110  	lineOverlap = 0;
111  	maxAscent = 1;
112  	maxDescent = 1;
113  	aveCharWidth = 8;
114  	spaceWidth = 8;
115  	tabWidth = spaceWidth * 8;
116  	elementColours.erase(Element::SelectionText);
117  	elementColours.erase(Element::SelectionAdditionalText);
118  	elementColours.erase(Element::SelectionSecondaryText);
119  	elementColours.erase(Element::SelectionInactiveText);
120  	elementBaseColours[Element::SelectionBack] = ColourRGBA(0xc0, 0xc0, 0xc0, 0xff);
121  	elementBaseColours[Element::SelectionAdditionalBack] = ColourRGBA(0xd7, 0xd7, 0xd7, 0xff);
122  	elementBaseColours[Element::SelectionSecondaryBack] = ColourRGBA(0xb0, 0xb0, 0xb0, 0xff);
123  	elementBaseColours[Element::SelectionInactiveBack] = ColourRGBA(0x80, 0x80, 0x80, 0x3f);
124  	elementAllowsTranslucent.insert({
125  		Element::SelectionText,
126  		Element::SelectionBack,
127  		Element::SelectionAdditionalText,
128  		Element::SelectionAdditionalBack,
129  		Element::SelectionSecondaryText,
130  		Element::SelectionSecondaryBack,
131  		Element::SelectionInactiveText,
132  		Element::SelectionInactiveBack,
133  		});
134  	foldmarginColour.reset();
135  	foldmarginHighlightColour.reset();
136  	controlCharSymbol = 0;	&bsol;* Draw the control characters */
137  	controlCharWidth = 0;
138  	selbar = Platform::Chrome();
139  	selbarlight = Platform::ChromeHighlight();
140  	styles[StyleLineNumber].fore = ColourRGBA(0, 0, 0);
141  	styles[StyleLineNumber].back = Platform::Chrome();
142  	elementBaseColours[Element::Caret] = ColourRGBA(0, 0, 0);
143  	elementBaseColours[Element::CaretAdditional] = ColourRGBA(0x7f, 0x7f, 0x7f);
144  	elementAllowsTranslucent.insert({
145  		Element::Caret,
146  		Element::CaretAdditional,
147  		});
148  	elementColours.erase(Element::CaretLineBack);
149  	elementAllowsTranslucent.insert(Element::CaretLineBack);
150  	someStylesProtected = false;
151  	someStylesForceCase = false;
152  	hotspotUnderline = true;
153  	elementColours.erase(Element::HotSpotActive);
154  	elementAllowsTranslucent.insert(Element::HotSpotActive);
155  	leftMarginWidth = 1;
156  	rightMarginWidth = 1;
157  	ms.resize(MaxMargin + 1);
158  	ms[0] = MarginStyle(MarginType::Number);
159  	ms[1] = MarginStyle(MarginType::Symbol, 16, ~MaskFolders);
160  	ms[2] = MarginStyle(MarginType::Symbol);
161  	marginInside = true;
162  	CalculateMarginWidthAndMask();
163  	textStart = marginInside ? fixedColumnWidth : leftMarginWidth;
164  	zoomLevel = 0;
165  	viewWhitespace = WhiteSpace::Invisible;
166  	tabDrawMode = TabDrawMode::LongArrow;
167  	whitespaceSize = 1;
168  	elementColours.erase(Element::WhiteSpace);
169  	elementAllowsTranslucent.insert(Element::WhiteSpace);
170  	viewIndentationGuides = IndentView::None;
171  	viewEOL = false;
172  	extraFontFlag = FontQuality::QualityDefault;
173  	extraAscent = 0;
174  	extraDescent = 0;
175  	marginStyleOffset = 0;
176  	annotationVisible = AnnotationVisible::Hidden;
177  	annotationStyleOffset = 0;
178  	eolAnnotationVisible = EOLAnnotationVisible::Hidden;
179  	eolAnnotationStyleOffset = 0;
180  	braceHighlightIndicatorSet = false;
181  	braceHighlightIndicator = 0;
182  	braceBadLightIndicatorSet = false;
183  	braceBadLightIndicator = 0;
184  	edgeState = EdgeVisualStyle::None;
185  	theEdge = EdgeProperties(0, ColourRGBA(0xc0, 0xc0, 0xc0));
186  	marginNumberPadding = 3;
187  	ctrlCharPadding = 3; 
188  	lastSegItalicsOffset = 2;
189  	localeName = localeNameDefault;
190  }
191  ViewStyle::ViewStyle(const ViewStyle &source) : ViewStyle(source.styles.size()) {
192  	styles = source.styles;
193  	for (Style &style : styles) {
194  		style.fontName = fontNames.Save(style.fontName);
195  	}
196  	nextExtendedStyle = source.nextExtendedStyle;
197  	markers = source.markers;
198  	CalcLargestMarkerHeight();
199  	indicators = source.indicators;
200  	indicatorsDynamic = source.indicatorsDynamic;
201  	indicatorsSetFore = source.indicatorsSetFore;
202  	selection = source.selection;
203  	foldmarginColour = source.foldmarginColour;
204  	foldmarginHighlightColour = source.foldmarginHighlightColour;
205  	hotspotUnderline = source.hotspotUnderline;
206  	controlCharSymbol = source.controlCharSymbol;
207  	controlCharWidth = source.controlCharWidth;
208  	selbar = source.selbar;
209  	selbarlight = source.selbarlight;
210  	caret = source.caret;
211  	caretLine = source.caretLine;
212  	someStylesProtected = false;
213  	someStylesForceCase = false;
214  	leftMarginWidth = source.leftMarginWidth;
215  	rightMarginWidth = source.rightMarginWidth;
216  	ms = source.ms;
217  	maskInLine = source.maskInLine;
218  	maskDrawInText = source.maskDrawInText;
219  	maskDrawWrapped = source.maskDrawWrapped;
220  	fixedColumnWidth = source.fixedColumnWidth;
221  	marginInside = source.marginInside;
222  	textStart = source.textStart;
223  	zoomLevel = source.zoomLevel;
224  	viewWhitespace = source.viewWhitespace;
225  	tabDrawMode = source.tabDrawMode;
226  	whitespaceSize = source.whitespaceSize;
227  	viewIndentationGuides = source.viewIndentationGuides;
228  	viewEOL = source.viewEOL;
229  	extraFontFlag = source.extraFontFlag;
230  	extraAscent = source.extraAscent;
231  	extraDescent = source.extraDescent;
232  	marginStyleOffset = source.marginStyleOffset;
233  	annotationVisible = source.annotationVisible;
234  	annotationStyleOffset = source.annotationStyleOffset;
235  	eolAnnotationVisible = source.eolAnnotationVisible;
236  	eolAnnotationStyleOffset = source.eolAnnotationStyleOffset;
237  	braceHighlightIndicatorSet = source.braceHighlightIndicatorSet;
238  	braceHighlightIndicator = source.braceHighlightIndicator;
239  	braceBadLightIndicatorSet = source.braceBadLightIndicatorSet;
240  	braceBadLightIndicator = source.braceBadLightIndicator;
241  	edgeState = source.edgeState;
242  	theEdge = source.theEdge;
243  	theMultiEdge = source.theMultiEdge;
244  	marginNumberPadding = source.marginNumberPadding;
245  	ctrlCharPadding = source.ctrlCharPadding;
246  	lastSegItalicsOffset = source.lastSegItalicsOffset;
247  	wrap = source.wrap;
248  	localeName = source.localeName;
249  }
250  ViewStyle::~ViewStyle() = default;
251  void ViewStyle::CalculateMarginWidthAndMask() noexcept {
252  	fixedColumnWidth = marginInside ? leftMarginWidth : 0;
253  	maskInLine = 0xffffffff;
254  	int maskDefinedMarkers = 0;
255  	for (const MarginStyle &m : ms) {
256  		fixedColumnWidth += m.width;
257  		if (m.width > 0)
258  			maskInLine &= ~m.mask;
259  		maskDefinedMarkers |= m.mask;
260  	}
261  	maskDrawInText = 0;
262  	for (int markBit = 0; markBit < 32; markBit++) {
263  		const int maskBit = 1U << markBit;
264  		switch (markers[markBit].markType) {
265  		case MarkerSymbol::Empty:
266  			maskInLine &= ~maskBit;
267  			break;
268  		case MarkerSymbol::Background:
269  		case MarkerSymbol::Underline:
270  			maskInLine &= ~maskBit;
271  			maskDrawInText |= maskDefinedMarkers & maskBit;
272  			break;
273  		default:	
274  			break;
275  		}
276  	}
277  	maskDrawWrapped = 0;
278  	for (int markBit = 0; markBit < 32; markBit++) {
279  		const int maskBit = 1U << markBit;
280  		switch (markers[markBit].markType) {
281  		case MarkerSymbol::Bar:
282  			maskDrawWrapped |= maskBit;
283  			break;
284  		default:	
285  			break;
286  		}
287  	}
288  }
289  void ViewStyle::Refresh(Surface &surface, int tabInChars) {
290  	fonts.clear();
291  	selbar = Platform::Chrome();
292  	selbarlight = Platform::ChromeHighlight();
293  	for (Style &style : styles) {
294  		style.extraFontFlag = extraFontFlag;
295  	}
296  	CreateAndAddFont(styles[StyleDefault]);
297  	for (const Style &style : styles) {
298  		CreateAndAddFont(style);
299  	}
300  	for (const std::pair<const FontSpecification, std::unique_ptr<FontRealised>> &font : fonts) {
301  		font.second->Realise(surface, zoomLevel, technology, font.first, localeName.c_str());
302  	}
303  	for (Style &style : styles) {
304  		const FontRealised *fr = Find(style);
305  		style.Copy(fr->font, fr->measurements);
306  	}
307  	indicatorsDynamic = std::any_of(indicators.cbegin(), indicators.cend(),
308  		[](const Indicator &indicator) noexcept { return indicator.IsDynamic(); });
309  	indicatorsSetFore = std::any_of(indicators.cbegin(), indicators.cend(),
310  		[](const Indicator &indicator) noexcept { return indicator.OverridesTextFore(); });
311  	maxAscent = 1;
312  	maxDescent = 1;
313  	FindMaxAscentDescent();
314  	maxAscent = std::max(1.0, maxAscent + extraAscent);
315  	maxDescent = std::max(0.0, maxDescent + extraDescent);
316  	lineHeight = static_cast<int>(std::lround(maxAscent + maxDescent));
317  	lineOverlap = lineHeight / 10;
318  	if (lineOverlap < 2)
319  		lineOverlap = 2;
320  	if (lineOverlap > lineHeight)
321  		lineOverlap = lineHeight;
322  	someStylesProtected = std::any_of(styles.cbegin(), styles.cend(),
323  		[](const Style &style) noexcept { return style.IsProtected(); });
324  	someStylesForceCase = std::any_of(styles.cbegin(), styles.cend(),
325  		[](const Style &style) noexcept { return style.caseForce != Style::CaseForce::mixed; });
326  	aveCharWidth = styles[StyleDefault].aveCharWidth;
327  	spaceWidth = styles[StyleDefault].spaceWidth;
328  	tabWidth = spaceWidth * tabInChars;
329  	controlCharWidth = 0.0;
330  	if (controlCharSymbol >= 32) {
331  		const char cc[2] = { static_cast<char>(controlCharSymbol), '\0' };
332  		controlCharWidth = surface.WidthText(styles[StyleControlChar].font.get(), cc);
333  	}
334  	CalculateMarginWidthAndMask();
335  	textStart = marginInside ? fixedColumnWidth : leftMarginWidth;
336  }
337  void ViewStyle::ReleaseAllExtendedStyles() noexcept {
338  	nextExtendedStyle = 256;
339  }
340  int ViewStyle::AllocateExtendedStyles(int numberStyles) {
341  	const int startRange = nextExtendedStyle;
342  	nextExtendedStyle += numberStyles;
343  	EnsureStyle(nextExtendedStyle);
344  	return startRange;
345  }
346  void ViewStyle::EnsureStyle(size_t index) {
347  	if (index >= styles.size()) {
348  		AllocStyles(index+1);
349  	}
350  }
351  void ViewStyle::ResetDefaultStyle() {
352  	styles[StyleDefault] = Style(fontNames.Save(Platform::DefaultFont()));
353  }
354  void ViewStyle::ClearStyles() {
355  	for (size_t i=0; i<styles.size(); i++) {
356  		if (i != StyleDefault) {
357  			styles[i] = styles[StyleDefault];
358  		}
359  	}
360  	styles[StyleLineNumber].back = Platform::Chrome();
361  	styles[StyleCallTip].back = ColourRGBA(0xff, 0xff, 0xff);
362  	styles[StyleCallTip].fore = ColourRGBA(0x80, 0x80, 0x80);
363  }
364  void ViewStyle::SetStyleFontName(int styleIndex, const char *name) {
365  	styles[styleIndex].fontName = fontNames.Save(name);
366  }
367  void ViewStyle::SetFontLocaleName(const char *name) {
368  	localeName = name;
369  }
370  bool ViewStyle::ProtectionActive() const noexcept {
371  	return someStylesProtected;
372  }
373  int ViewStyle::ExternalMarginWidth() const noexcept {
374  	return marginInside ? 0 : fixedColumnWidth;
375  }
376  int ViewStyle::MarginFromLocation(Point pt) const noexcept {
377  	XYPOSITION x = marginInside ? 0 : -fixedColumnWidth;
378  	for (size_t i = 0; i < ms.size(); i++) {
379  		if ((pt.x >= x) && (pt.x < x + ms[i].width))
380  			return static_cast<int>(i);
381  		x += ms[i].width;
382  	}
383  	return -1;
384  }
385  bool ViewStyle::ValidStyle(size_t styleIndex) const noexcept {
386  	return styleIndex < styles.size();
387  }
388  void ViewStyle::CalcLargestMarkerHeight() noexcept {
389  	largestMarkerHeight = 0;
390  	for (const LineMarker &marker : markers) {
391  		switch (marker.markType) {
392  		case MarkerSymbol::Pixmap:
393  			if (marker.pxpm && marker.pxpm->GetHeight() > largestMarkerHeight)
394  				largestMarkerHeight = marker.pxpm->GetHeight();
395  			break;
396  		case MarkerSymbol::RgbaImage:
397  			if (marker.image && marker.image->GetHeight() > largestMarkerHeight)
398  				largestMarkerHeight = marker.image->GetHeight();
399  			break;
400  		case MarkerSymbol::Bar:
401  			largestMarkerHeight = lineHeight + 2;
402  			break;
403  		default:	
404  			break;
405  		}
406  	}
407  }
408  int ViewStyle::GetFrameWidth() const noexcept {
409  	return std::clamp(caretLine.frame, 1, lineHeight / 3);
410  }
411  bool ViewStyle::IsLineFrameOpaque(bool caretActive, bool lineContainsCaret) const {
412  	return caretLine.frame && (caretActive || caretLine.alwaysShow) &&
413  		ElementColour(Element::CaretLineBack) &&
414  		(caretLine.layer == Layer::Base) && lineContainsCaret;
415  }
416  ColourOptional ViewStyle::Background(int marksOfLine, bool caretActive, bool lineContainsCaret) const {
417  	ColourOptional background;
418  	if (!caretLine.frame && (caretActive || caretLine.alwaysShow) &&
419  		(caretLine.layer == Layer::Base) && lineContainsCaret) {
420  		background = ElementColour(Element::CaretLineBack);
421  	}
422  	if (!background && marksOfLine) {
423  		int marks = marksOfLine;
424  		for (int markBit = 0; (markBit < 32) && marks; markBit++) {
425  			if ((marks & 1) && (markers[markBit].markType == MarkerSymbol::Background) &&
426  				(markers[markBit].layer == Layer::Base)) {
427  				background = markers[markBit].back;
428  			}
429  			marks >>= 1;
430  		}
431  	}
432  	if (!background && maskInLine) {
433  		int marksMasked = marksOfLine & maskInLine;
434  		if (marksMasked) {
435  			for (int markBit = 0; (markBit < 32) && marksMasked; markBit++) {
436  				if ((marksMasked & 1) &&
437  					(markers[markBit].layer == Layer::Base)) {
438  					background = markers[markBit].back;
439  				}
440  				marksMasked >>= 1;
441  			}
442  		}
443  	}
444  	if (background) {
445  		return background->Opaque();
446  	} else {
447  		return {};
448  	}
449  }
450  bool ViewStyle::SelectionBackgroundDrawn() const noexcept {
451  	return selection.layer == Layer::Base;
452  }
453  bool ViewStyle::SelectionTextDrawn() const {
454  	return
455  		ElementIsSet(Element::SelectionText) ||
456  		ElementIsSet(Element::SelectionAdditionalText) ||
457  		ElementIsSet(Element::SelectionSecondaryText) ||
458  		ElementIsSet(Element::SelectionInactiveText);
459  }
460  bool ViewStyle::WhitespaceBackgroundDrawn() const {
461  	return (viewWhitespace != WhiteSpace::Invisible) && (ElementIsSet(Element::WhiteSpaceBack));
462  }
463  bool ViewStyle::WhiteSpaceVisible(bool inIndent) const noexcept {
464  	return (!inIndent && viewWhitespace == WhiteSpace::VisibleAfterIndent) ||
465  		(inIndent && viewWhitespace == WhiteSpace::VisibleOnlyInIndent) ||
466  		viewWhitespace == WhiteSpace::VisibleAlways;
467  }
468  ColourRGBA ViewStyle::WrapColour() const {
469  	return ElementColour(Element::WhiteSpace).value_or(styles[StyleDefault].fore);
470  }
471  void ViewStyle::AddMultiEdge(int column, ColourRGBA colour) {
472  	theMultiEdge.insert(
473  		std::upper_bound(theMultiEdge.begin(), theMultiEdge.end(), column,
474  			[](const EdgeProperties &a, const EdgeProperties &b) noexcept {
475  				return a.column < b.column;
476  			}),
477  		EdgeProperties(column, colour));
478  }
479  ColourOptional ViewStyle::ElementColour(Element element) const {
480  	ElementMap::const_iterator search = elementColours.find(element);
481  	if (search != elementColours.end()) {
482  		if (search->second.has_value()) {
483  			return search->second;
484  		}
485  	}
486  	ElementMap::const_iterator searchBase = elementBaseColours.find(element);
487  	if (searchBase != elementBaseColours.end()) {
488  		if (searchBase->second.has_value()) {
489  			return searchBase->second;
490  		}
491  	}
492  	return {};
493  }
494  ColourRGBA ViewStyle::ElementColourForced(Element element) const {
495  	const ColourOptional colour = ElementColour(element);
496  	constexpr ColourRGBA opaqueBlack(0, 0, 0, 0xff);
497  	return colour.value_or(opaqueBlack);
498  }
499  bool ViewStyle::ElementAllowsTranslucent(Element element) const {
500  	return elementAllowsTranslucent.count(element) > 0;
501  }
502  bool ViewStyle::ResetElement(Element element) {
503  	ElementMap::const_iterator search = elementColours.find(element);
504  	const bool changed = (search != elementColours.end()) && (search->second.has_value());
505  	elementColours.erase(element);
506  	return changed;
507  }
508  bool ViewStyle::SetElementColour(Element element, ColourRGBA colour) {
509  	ElementMap::const_iterator search = elementColours.find(element);
510  	const bool changed =
511  		(search == elementColours.end()) ||
512  		(search->second.has_value() && !(*search->second == colour));
513  	elementColours[element] = colour;
514  	return changed;
515  }
516  bool ViewStyle::SetElementColourOptional(Element element, uptr_t wParam, sptr_t lParam) {
517  	if (wParam) {
518  		return SetElementColour(element, ColourRGBA::FromIpRGB(lParam));
519  	} else {
520  		return ResetElement(element);
521  	}
522  }
523  void ViewStyle::SetElementRGB(Element element, int rgb) {
524  	const ColourRGBA current = ElementColour(element).value_or(ColourRGBA(0, 0, 0, 0));
525  	elementColours[element] = ColourRGBA(ColourRGBA(rgb), current.GetAlpha());
526  }
527  void ViewStyle::SetElementAlpha(Element element, int alpha) {
528  	const ColourRGBA current = ElementColour(element).value_or(ColourRGBA(0, 0, 0, 0));
529  	elementColours[element] = ColourRGBA(current, std::min(alpha, 0xff));
530  }
531  bool ViewStyle::ElementIsSet(Element element) const {
532  	ElementMap::const_iterator search = elementColours.find(element);
533  	if (search != elementColours.end()) {
534  		return search->second.has_value();
535  	}
536  	return false;
537  }
538  bool ViewStyle::SetElementBase(Element element, ColourRGBA colour) {
539  	ElementMap::const_iterator search = elementBaseColours.find(element);
540  	const bool changed =
541  		(search == elementBaseColours.end()) ||
542  		(search->second.has_value() && !(*search->second == colour));
543  	elementBaseColours[element] = colour;
544  	return changed;
545  }
546  bool ViewStyle::SetWrapState(Wrap wrapState_) noexcept {
547  	const bool changed = wrap.state != wrapState_;
548  	wrap.state = wrapState_;
549  	return changed;
550  }
551  bool ViewStyle::SetWrapVisualFlags(WrapVisualFlag wrapVisualFlags_) noexcept {
552  	const bool changed = wrap.visualFlags != wrapVisualFlags_;
553  	wrap.visualFlags = wrapVisualFlags_;
554  	return changed;
555  }
556  bool ViewStyle::SetWrapVisualFlagsLocation(WrapVisualLocation wrapVisualFlagsLocation_) noexcept {
557  	const bool changed = wrap.visualFlagsLocation != wrapVisualFlagsLocation_;
558  	wrap.visualFlagsLocation = wrapVisualFlagsLocation_;
559  	return changed;
560  }
561  bool ViewStyle::SetWrapVisualStartIndent(int wrapVisualStartIndent_) noexcept {
562  	const bool changed = wrap.visualStartIndent != wrapVisualStartIndent_;
563  	wrap.visualStartIndent = wrapVisualStartIndent_;
564  	return changed;
565  }
566  bool ViewStyle::SetWrapIndentMode(WrapIndentMode wrapIndentMode_) noexcept {
567  	const bool changed = wrap.indentMode != wrapIndentMode_;
568  	wrap.indentMode = wrapIndentMode_;
569  	return changed;
570  }
571  bool ViewStyle::IsBlockCaretStyle() const noexcept {
572  	return ((caret.style & CaretStyle::InsMask) == CaretStyle::Block) ||
573  		FlagSet(caret.style, CaretStyle::OverstrikeBlock) ||
574  		FlagSet(caret.style, CaretStyle::Curses);
575  }
576  bool ViewStyle::IsCaretVisible(bool isMainSelection) const noexcept {
577  	return caret.width > 0 &&
578  		((caret.style & CaretStyle::InsMask) != CaretStyle::Invisible ||
579  		(FlagSet(caret.style, CaretStyle::Curses) && !isMainSelection)); 
580  }
581  bool ViewStyle::DrawCaretInsideSelection(bool inOverstrike, bool imeCaretBlockOverride) const noexcept {
582  	if (FlagSet(caret.style, CaretStyle::BlockAfter))
583  		return false;
584  	return ((caret.style & CaretStyle::InsMask) == CaretStyle::Block) ||
585  		(inOverstrike && FlagSet(caret.style, CaretStyle::OverstrikeBlock)) ||
586  		imeCaretBlockOverride ||
587  		FlagSet(caret.style, CaretStyle::Curses);
588  }
589  ViewStyle::CaretShape ViewStyle::CaretShapeForMode(bool inOverstrike, bool isMainSelection) const noexcept {
590  	if (inOverstrike) {
591  		return (FlagSet(caret.style, CaretStyle::OverstrikeBlock)) ? CaretShape::block : CaretShape::bar;
592  	}
593  	if (FlagSet(caret.style, CaretStyle::Curses) && !isMainSelection) {
594  		return CaretShape::block;
595  	}
596  	const CaretStyle caretStyle = caret.style & CaretStyle::InsMask;
597  	return (caretStyle <= CaretStyle::Block) ? static_cast<CaretShape>(caretStyle) : CaretShape::line;
598  }
599  void ViewStyle::AllocStyles(size_t sizeNew) {
600  	size_t i=styles.size();
601  	styles.resize(sizeNew);
602  	if (styles.size() > StyleDefault) {
603  		for (; i<sizeNew; i++) {
604  			if (i != StyleDefault) {
605  				styles[i] = styles[StyleDefault];
606  			}
607  		}
608  	}
609  }
610  void ViewStyle::CreateAndAddFont(const FontSpecification &fs) {
611  	if (fs.fontName) {
612  		FontMap::iterator it = fonts.find(fs);
613  		if (it == fonts.end()) {
614  			fonts[fs] = std::make_unique<FontRealised>();
615  		}
616  	}
617  }
618  FontRealised *ViewStyle::Find(const FontSpecification &fs) {
619  	if (!fs.fontName)	
620  		return fonts.begin()->second.get();
621  	FontMap::iterator it = fonts.find(fs);
622  	if (it != fonts.end()) {
623  		return it->second.get();
624  	}
625  	return nullptr;
626  }
627  void ViewStyle::FindMaxAscentDescent() noexcept {
628  	for (size_t i = 0; i < styles.size(); i++) {
629  		if (i == StyleCallTip)
630  			continue;
631  		const auto &style = styles[i];
632  		if (maxAscent < style.ascent)
<span onclick='openModal()' class='match'>633  			maxAscent = style.ascent;
634  		if (maxDescent < style.descent)
635  			maxDescent = style.descent;
636  	}
637  }
</span></code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-ViewStyle.cxx</h3>
            <pre><code>1  #include <cstddef>
2  #include <cassert>
3  #include <cstring>
4  #include <cmath>
5  #include <stdexcept>
6  #include <string>
7  #include <string_view>
8  #include <vector>
9  #include <array>
10  #include <map>
11  #include <set>
12  #include <optional>
13  #include <algorithm>
14  #include <memory>
15  #include <numeric>
16  #include "ScintillaTypes.h"
17  #include "Debugging.h"
18  #include "Geometry.h"
19  #include "Platform.h"
20  #include "Position.h"
21  #include "UniqueString.h"
22  #include "Indicator.h"
23  #include "XPM.h"
24  #include "LineMarker.h"
25  #include "Style.h"
26  #include "ViewStyle.h"
27  using namespace Scintilla;
28  using namespace Scintilla::Internal;
29  MarginStyle::MarginStyle(MarginType style_, int width_, int mask_) noexcept :
30  	style(style_), width(width_), mask(mask_), sensitive(false), cursor(CursorShape::ReverseArrow) {
31  }
32  bool MarginStyle::ShowsFolding() const noexcept {
33  	return (mask & MaskFolders) != 0;
34  }
35  void FontRealised::Realise(Surface &surface, int zoomLevel, Technology technology, const FontSpecification &fs, const char *localeName) {
36  	PLATFORM_ASSERT(fs.fontName);
37  	measurements.sizeZoomed = fs.size + zoomLevel * FontSizeMultiplier;
38  	if (measurements.sizeZoomed <= FontSizeMultiplier)	
39  		measurements.sizeZoomed = FontSizeMultiplier;
40  	const float deviceHeight = static_cast<float>(surface.DeviceHeightFont(measurements.sizeZoomed));
41  	const FontParameters fp(fs.fontName, deviceHeight / FontSizeMultiplier, fs.weight,
42  		fs.italic, fs.extraFontFlag, technology, fs.characterSet, localeName);
43  	font = Font::Allocate(fp);
44  	measurements.ascent = std::floor(surface.Ascent(font.get()));
45  	measurements.descent = std::floor(surface.Descent(font.get()));
46  	measurements.capitalHeight = surface.Ascent(font.get()) - surface.InternalLeading(font.get());
47  	measurements.aveCharWidth = surface.AverageCharWidth(font.get());
48  	measurements.monospaceCharacterWidth = measurements.aveCharWidth;
49  	measurements.spaceWidth = surface.WidthText(font.get(), " ");
50  	if (fs.checkMonospaced) {
51  		constexpr std::string_view allASCIIGraphic("Ayfi"
52  		" !\"#$%&\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~");
53  		std::array<XYPOSITION, allASCIIGraphic.length()> positions {};
54  		surface.MeasureWidthsUTF8(font.get(), allASCIIGraphic, positions.data());
55  		std::adjacent_difference(positions.begin(), positions.end(), positions.begin());
56  		const XYPOSITION maxWidth = *std::max_element(positions.begin(), positions.end());
57  		const XYPOSITION minWidth = *std::min_element(positions.begin(), positions.end());
58  		const XYPOSITION variance = maxWidth - minWidth;
59  		const XYPOSITION scaledVariance = variance / measurements.aveCharWidth;
60  		constexpr XYPOSITION monospaceWidthEpsilon = 0.000001;	
61  		measurements.monospaceASCII = scaledVariance < monospaceWidthEpsilon;
62  		measurements.monospaceCharacterWidth = minWidth;
63  	} else {
64  		measurements.monospaceASCII = false;
65  	}
66  }
67  ViewStyle::ViewStyle(size_t stylesSize_) :
68  	styles(stylesSize_),
69  	markers(MarkerMax + 1),
70  	indicators(static_cast<size_t>(IndicatorNumbers::Max) + 1) {
71  	nextExtendedStyle = 256;
72  	ResetDefaultStyle();
73  	largestMarkerHeight = 0;
74  	indicators[0] = Indicator(IndicatorStyle::Squiggle, ColourRGBA(0, 0x7f, 0));
75  	indicators[1] = Indicator(IndicatorStyle::TT, ColourRGBA(0, 0, 0xff));
76  	indicators[2] = Indicator(IndicatorStyle::Plain, ColourRGBA(0xff, 0, 0));
77  	constexpr ColourRGBA revertedToOrigin(0x40, 0xA0, 0xBF);
78  	constexpr ColourRGBA saved(0x0, 0xA0, 0x0);
79  	constexpr ColourRGBA modified(0xFF, 0x80, 0x0);
80  	constexpr ColourRGBA revertedToChange(0xA0, 0xC0, 0x0);
81  	constexpr size_t indexHistory = static_cast<size_t>(IndicatorNumbers::HistoryRevertedToOriginInsertion);
82  	indicators[indexHistory+0] = Indicator(IndicatorStyle::CompositionThick, revertedToOrigin, false, 30, 60);
83  	indicators[indexHistory+1] = Indicator(IndicatorStyle::Point, revertedToOrigin);
84  	indicators[indexHistory+2] = Indicator(IndicatorStyle::CompositionThick, saved, false, 30, 60);
85  	indicators[indexHistory+3] = Indicator(IndicatorStyle::Point, saved);
86  	indicators[indexHistory+4] = Indicator(IndicatorStyle::CompositionThick, modified, false, 30, 60);
87  	indicators[indexHistory+5] = Indicator(IndicatorStyle::PointTop, modified);
88  	indicators[indexHistory+6] = Indicator(IndicatorStyle::CompositionThick, revertedToChange, false, 30, 60);
89  	indicators[indexHistory+7] = Indicator(IndicatorStyle::Point, revertedToChange);
90  	constexpr size_t indexHistoryRevertedToOrigin = static_cast<size_t>(MarkerOutline::HistoryRevertedToOrigin);
91  	markers[indexHistoryRevertedToOrigin].back = revertedToOrigin;
92  	markers[indexHistoryRevertedToOrigin].fore = revertedToOrigin;
93  	markers[indexHistoryRevertedToOrigin].markType = MarkerSymbol::Bar;
94  	constexpr size_t indexHistorySaved = static_cast<size_t>(MarkerOutline::HistorySaved);
95  	markers[indexHistorySaved].back = saved;
96  	markers[indexHistorySaved].fore = saved;
97  	markers[indexHistorySaved].markType = MarkerSymbol::Bar;
98  	constexpr size_t indexHistoryModified = static_cast<size_t>(MarkerOutline::HistoryModified);
99  	markers[indexHistoryModified].back = Platform::Chrome();
100  	markers[indexHistoryModified].fore = modified;
101  	markers[indexHistoryModified].markType = MarkerSymbol::Bar;
102  	constexpr size_t indexHistoryRevertedToModified = static_cast<size_t>(MarkerOutline::HistoryRevertedToModified);
103  	markers[indexHistoryRevertedToModified].back = revertedToChange;
104  	markers[indexHistoryRevertedToModified].fore = revertedToChange;
105  	markers[indexHistoryRevertedToModified].markType = MarkerSymbol::Bar;
106  	technology = Technology::Default;
107  	indicatorsDynamic = false;
108  	indicatorsSetFore = false;
109  	lineHeight = 1;
110  	lineOverlap = 0;
111  	maxAscent = 1;
112  	maxDescent = 1;
113  	aveCharWidth = 8;
114  	spaceWidth = 8;
115  	tabWidth = spaceWidth * 8;
116  	elementColours.erase(Element::SelectionText);
117  	elementColours.erase(Element::SelectionAdditionalText);
118  	elementColours.erase(Element::SelectionSecondaryText);
119  	elementColours.erase(Element::SelectionInactiveText);
120  	elementBaseColours[Element::SelectionBack] = ColourRGBA(0xc0, 0xc0, 0xc0, 0xff);
121  	elementBaseColours[Element::SelectionAdditionalBack] = ColourRGBA(0xd7, 0xd7, 0xd7, 0xff);
122  	elementBaseColours[Element::SelectionSecondaryBack] = ColourRGBA(0xb0, 0xb0, 0xb0, 0xff);
123  	elementBaseColours[Element::SelectionInactiveBack] = ColourRGBA(0x80, 0x80, 0x80, 0x3f);
124  	elementAllowsTranslucent.insert({
125  		Element::SelectionText,
126  		Element::SelectionBack,
127  		Element::SelectionAdditionalText,
128  		Element::SelectionAdditionalBack,
129  		Element::SelectionSecondaryText,
130  		Element::SelectionSecondaryBack,
131  		Element::SelectionInactiveText,
132  		Element::SelectionInactiveBack,
133  		});
134  	foldmarginColour.reset();
135  	foldmarginHighlightColour.reset();
136  	controlCharSymbol = 0;	&bsol;* Draw the control characters */
137  	controlCharWidth = 0;
138  	selbar = Platform::Chrome();
139  	selbarlight = Platform::ChromeHighlight();
140  	styles[StyleLineNumber].fore = ColourRGBA(0, 0, 0);
141  	styles[StyleLineNumber].back = Platform::Chrome();
142  	elementBaseColours[Element::Caret] = ColourRGBA(0, 0, 0);
143  	elementBaseColours[Element::CaretAdditional] = ColourRGBA(0x7f, 0x7f, 0x7f);
144  	elementAllowsTranslucent.insert({
145  		Element::Caret,
146  		Element::CaretAdditional,
147  		});
148  	elementColours.erase(Element::CaretLineBack);
149  	elementAllowsTranslucent.insert(Element::CaretLineBack);
150  	someStylesProtected = false;
151  	someStylesForceCase = false;
152  	hotspotUnderline = true;
153  	elementColours.erase(Element::HotSpotActive);
154  	elementAllowsTranslucent.insert(Element::HotSpotActive);
155  	leftMarginWidth = 1;
156  	rightMarginWidth = 1;
157  	ms.resize(MaxMargin + 1);
158  	ms[0] = MarginStyle(MarginType::Number);
159  	ms[1] = MarginStyle(MarginType::Symbol, 16, ~MaskFolders);
160  	ms[2] = MarginStyle(MarginType::Symbol);
161  	marginInside = true;
162  	CalculateMarginWidthAndMask();
163  	textStart = marginInside ? fixedColumnWidth : leftMarginWidth;
164  	zoomLevel = 0;
165  	viewWhitespace = WhiteSpace::Invisible;
166  	tabDrawMode = TabDrawMode::LongArrow;
167  	whitespaceSize = 1;
168  	elementColours.erase(Element::WhiteSpace);
169  	elementAllowsTranslucent.insert(Element::WhiteSpace);
170  	viewIndentationGuides = IndentView::None;
171  	viewEOL = false;
172  	extraFontFlag = FontQuality::QualityDefault;
173  	extraAscent = 0;
174  	extraDescent = 0;
175  	marginStyleOffset = 0;
176  	annotationVisible = AnnotationVisible::Hidden;
177  	annotationStyleOffset = 0;
178  	eolAnnotationVisible = EOLAnnotationVisible::Hidden;
179  	eolAnnotationStyleOffset = 0;
180  	braceHighlightIndicatorSet = false;
181  	braceHighlightIndicator = 0;
182  	braceBadLightIndicatorSet = false;
183  	braceBadLightIndicator = 0;
184  	edgeState = EdgeVisualStyle::None;
185  	theEdge = EdgeProperties(0, ColourRGBA(0xc0, 0xc0, 0xc0));
186  	marginNumberPadding = 3;
187  	ctrlCharPadding = 3; 
188  	lastSegItalicsOffset = 2;
189  	localeName = localeNameDefault;
190  }
191  ViewStyle::ViewStyle(const ViewStyle &source) : ViewStyle(source.styles.size()) {
192  	styles = source.styles;
193  	for (Style &style : styles) {
194  		style.fontName = fontNames.Save(style.fontName);
195  	}
196  	nextExtendedStyle = source.nextExtendedStyle;
197  	markers = source.markers;
198  	CalcLargestMarkerHeight();
199  	indicators = source.indicators;
200  	indicatorsDynamic = source.indicatorsDynamic;
201  	indicatorsSetFore = source.indicatorsSetFore;
202  	selection = source.selection;
203  	foldmarginColour = source.foldmarginColour;
204  	foldmarginHighlightColour = source.foldmarginHighlightColour;
205  	hotspotUnderline = source.hotspotUnderline;
206  	controlCharSymbol = source.controlCharSymbol;
207  	controlCharWidth = source.controlCharWidth;
208  	selbar = source.selbar;
209  	selbarlight = source.selbarlight;
210  	caret = source.caret;
211  	caretLine = source.caretLine;
212  	someStylesProtected = false;
213  	someStylesForceCase = false;
214  	leftMarginWidth = source.leftMarginWidth;
215  	rightMarginWidth = source.rightMarginWidth;
216  	ms = source.ms;
217  	maskInLine = source.maskInLine;
218  	maskDrawInText = source.maskDrawInText;
219  	maskDrawWrapped = source.maskDrawWrapped;
220  	fixedColumnWidth = source.fixedColumnWidth;
221  	marginInside = source.marginInside;
222  	textStart = source.textStart;
223  	zoomLevel = source.zoomLevel;
224  	viewWhitespace = source.viewWhitespace;
225  	tabDrawMode = source.tabDrawMode;
226  	whitespaceSize = source.whitespaceSize;
227  	viewIndentationGuides = source.viewIndentationGuides;
228  	viewEOL = source.viewEOL;
229  	extraFontFlag = source.extraFontFlag;
230  	extraAscent = source.extraAscent;
231  	extraDescent = source.extraDescent;
232  	marginStyleOffset = source.marginStyleOffset;
233  	annotationVisible = source.annotationVisible;
234  	annotationStyleOffset = source.annotationStyleOffset;
235  	eolAnnotationVisible = source.eolAnnotationVisible;
236  	eolAnnotationStyleOffset = source.eolAnnotationStyleOffset;
237  	braceHighlightIndicatorSet = source.braceHighlightIndicatorSet;
238  	braceHighlightIndicator = source.braceHighlightIndicator;
239  	braceBadLightIndicatorSet = source.braceBadLightIndicatorSet;
240  	braceBadLightIndicator = source.braceBadLightIndicator;
241  	edgeState = source.edgeState;
242  	theEdge = source.theEdge;
243  	theMultiEdge = source.theMultiEdge;
244  	marginNumberPadding = source.marginNumberPadding;
245  	ctrlCharPadding = source.ctrlCharPadding;
246  	lastSegItalicsOffset = source.lastSegItalicsOffset;
247  	wrap = source.wrap;
248  	localeName = source.localeName;
249  }
250  ViewStyle::~ViewStyle() = default;
251  void ViewStyle::CalculateMarginWidthAndMask() noexcept {
252  	fixedColumnWidth = marginInside ? leftMarginWidth : 0;
253  	maskInLine = 0xffffffff;
254  	int maskDefinedMarkers = 0;
255  	for (const MarginStyle &m : ms) {
256  		fixedColumnWidth += m.width;
257  		if (m.width > 0)
258  			maskInLine &= ~m.mask;
259  		maskDefinedMarkers |= m.mask;
260  	}
261  	maskDrawInText = 0;
262  	for (int markBit = 0; markBit < 32; markBit++) {
263  		const int maskBit = 1U << markBit;
264  		switch (markers[markBit].markType) {
265  		case MarkerSymbol::Empty:
266  			maskInLine &= ~maskBit;
267  			break;
268  		case MarkerSymbol::Background:
269  		case MarkerSymbol::Underline:
270  			maskInLine &= ~maskBit;
271  			maskDrawInText |= maskDefinedMarkers & maskBit;
272  			break;
273  		default:	
274  			break;
275  		}
276  	}
277  	maskDrawWrapped = 0;
278  	for (int markBit = 0; markBit < 32; markBit++) {
279  		const int maskBit = 1U << markBit;
280  		switch (markers[markBit].markType) {
281  		case MarkerSymbol::Bar:
282  			maskDrawWrapped |= maskBit;
283  			break;
284  		default:	
285  			break;
286  		}
287  	}
288  }
289  void ViewStyle::Refresh(Surface &surface, int tabInChars) {
290  	fonts.clear();
291  	selbar = Platform::Chrome();
292  	selbarlight = Platform::ChromeHighlight();
293  	for (Style &style : styles) {
294  		style.extraFontFlag = extraFontFlag;
295  	}
296  	CreateAndAddFont(styles[StyleDefault]);
297  	for (const Style &style : styles) {
298  		CreateAndAddFont(style);
299  	}
300  	for (const std::pair<const FontSpecification, std::unique_ptr<FontRealised>> &font : fonts) {
301  		font.second->Realise(surface, zoomLevel, technology, font.first, localeName.c_str());
302  	}
303  	for (Style &style : styles) {
304  		const FontRealised *fr = Find(style);
305  		style.Copy(fr->font, fr->measurements);
306  	}
307  	indicatorsDynamic = std::any_of(indicators.cbegin(), indicators.cend(),
308  		[](const Indicator &indicator) noexcept { return indicator.IsDynamic(); });
309  	indicatorsSetFore = std::any_of(indicators.cbegin(), indicators.cend(),
310  		[](const Indicator &indicator) noexcept { return indicator.OverridesTextFore(); });
311  	maxAscent = 1;
312  	maxDescent = 1;
313  	FindMaxAscentDescent();
314  	maxAscent = std::max(1.0, maxAscent + extraAscent);
315  	maxDescent = std::max(0.0, maxDescent + extraDescent);
316  	lineHeight = static_cast<int>(std::lround(maxAscent + maxDescent));
317  	lineOverlap = lineHeight / 10;
318  	if (lineOverlap < 2)
319  		lineOverlap = 2;
320  	if (lineOverlap > lineHeight)
321  		lineOverlap = lineHeight;
322  	someStylesProtected = std::any_of(styles.cbegin(), styles.cend(),
323  		[](const Style &style) noexcept { return style.IsProtected(); });
324  	someStylesForceCase = std::any_of(styles.cbegin(), styles.cend(),
325  		[](const Style &style) noexcept { return style.caseForce != Style::CaseForce::mixed; });
326  	aveCharWidth = styles[StyleDefault].aveCharWidth;
327  	spaceWidth = styles[StyleDefault].spaceWidth;
328  	tabWidth = spaceWidth * tabInChars;
329  	controlCharWidth = 0.0;
330  	if (controlCharSymbol >= 32) {
331  		const char cc[2] = { static_cast<char>(controlCharSymbol), '\0' };
332  		controlCharWidth = surface.WidthText(styles[StyleControlChar].font.get(), cc);
333  	}
334  	CalculateMarginWidthAndMask();
335  	textStart = marginInside ? fixedColumnWidth : leftMarginWidth;
336  }
337  void ViewStyle::ReleaseAllExtendedStyles() noexcept {
338  	nextExtendedStyle = 256;
339  }
340  int ViewStyle::AllocateExtendedStyles(int numberStyles) {
341  	const int startRange = nextExtendedStyle;
342  	nextExtendedStyle += numberStyles;
343  	EnsureStyle(nextExtendedStyle);
344  	return startRange;
345  }
346  void ViewStyle::EnsureStyle(size_t index) {
347  	if (index >= styles.size()) {
348  		AllocStyles(index+1);
349  	}
350  }
351  void ViewStyle::ResetDefaultStyle() {
352  	styles[StyleDefault] = Style(fontNames.Save(Platform::DefaultFont()));
353  }
354  void ViewStyle::ClearStyles() {
355  	for (size_t i=0; i<styles.size(); i++) {
356  		if (i != StyleDefault) {
357  			styles[i] = styles[StyleDefault];
358  		}
359  	}
360  	styles[StyleLineNumber].back = Platform::Chrome();
361  	styles[StyleCallTip].back = ColourRGBA(0xff, 0xff, 0xff);
362  	styles[StyleCallTip].fore = ColourRGBA(0x80, 0x80, 0x80);
363  }
364  void ViewStyle::SetStyleFontName(int styleIndex, const char *name) {
365  	styles[styleIndex].fontName = fontNames.Save(name);
366  }
367  void ViewStyle::SetFontLocaleName(const char *name) {
368  	localeName = name;
369  }
370  bool ViewStyle::ProtectionActive() const noexcept {
371  	return someStylesProtected;
372  }
373  int ViewStyle::ExternalMarginWidth() const noexcept {
374  	return marginInside ? 0 : fixedColumnWidth;
375  }
376  int ViewStyle::MarginFromLocation(Point pt) const noexcept {
377  	XYPOSITION x = marginInside ? 0 : -fixedColumnWidth;
378  	for (size_t i = 0; i < ms.size(); i++) {
379  		if ((pt.x >= x) && (pt.x < x + ms[i].width))
380  			return static_cast<int>(i);
381  		x += ms[i].width;
382  	}
383  	return -1;
384  }
385  bool ViewStyle::ValidStyle(size_t styleIndex) const noexcept {
386  	return styleIndex < styles.size();
387  }
388  void ViewStyle::CalcLargestMarkerHeight() noexcept {
389  	largestMarkerHeight = 0;
390  	for (const LineMarker &marker : markers) {
391  		switch (marker.markType) {
392  		case MarkerSymbol::Pixmap:
393  			if (marker.pxpm && marker.pxpm->GetHeight() > largestMarkerHeight)
394  				largestMarkerHeight = marker.pxpm->GetHeight();
395  			break;
396  		case MarkerSymbol::RgbaImage:
397  			if (marker.image && marker.image->GetHeight() > largestMarkerHeight)
398  				largestMarkerHeight = marker.image->GetHeight();
399  			break;
400  		case MarkerSymbol::Bar:
401  			largestMarkerHeight = lineHeight + 2;
402  			break;
403  		default:	
404  			break;
405  		}
406  	}
407  }
408  int ViewStyle::GetFrameWidth() const noexcept {
409  	return std::clamp(caretLine.frame, 1, lineHeight / 3);
410  }
411  bool ViewStyle::IsLineFrameOpaque(bool caretActive, bool lineContainsCaret) const {
412  	return caretLine.frame && (caretActive || caretLine.alwaysShow) &&
413  		ElementColour(Element::CaretLineBack) &&
414  		(caretLine.layer == Layer::Base) && lineContainsCaret;
415  }
416  ColourOptional ViewStyle::Background(int marksOfLine, bool caretActive, bool lineContainsCaret) const {
417  	ColourOptional background;
418  	if (!caretLine.frame && (caretActive || caretLine.alwaysShow) &&
419  		(caretLine.layer == Layer::Base) && lineContainsCaret) {
420  		background = ElementColour(Element::CaretLineBack);
421  	}
422  	if (!background && marksOfLine) {
423  		int marks = marksOfLine;
424  		for (int markBit = 0; (markBit < 32) && marks; markBit++) {
425  			if ((marks & 1) && (markers[markBit].markType == MarkerSymbol::Background) &&
426  				(markers[markBit].layer == Layer::Base)) {
427  				background = markers[markBit].back;
428  			}
429  			marks >>= 1;
430  		}
431  	}
432  	if (!background && maskInLine) {
433  		int marksMasked = marksOfLine & maskInLine;
434  		if (marksMasked) {
435  			for (int markBit = 0; (markBit < 32) && marksMasked; markBit++) {
436  				if ((marksMasked & 1) &&
437  					(markers[markBit].layer == Layer::Base)) {
438  					background = markers[markBit].back;
439  				}
440  				marksMasked >>= 1;
441  			}
442  		}
443  	}
444  	if (background) {
445  		return background->Opaque();
446  	} else {
447  		return {};
448  	}
449  }
450  bool ViewStyle::SelectionBackgroundDrawn() const noexcept {
451  	return selection.layer == Layer::Base;
452  }
453  bool ViewStyle::SelectionTextDrawn() const {
454  	return
455  		ElementIsSet(Element::SelectionText) ||
456  		ElementIsSet(Element::SelectionAdditionalText) ||
457  		ElementIsSet(Element::SelectionSecondaryText) ||
458  		ElementIsSet(Element::SelectionInactiveText);
459  }
460  bool ViewStyle::WhitespaceBackgroundDrawn() const {
461  	return (viewWhitespace != WhiteSpace::Invisible) && (ElementIsSet(Element::WhiteSpaceBack));
462  }
463  bool ViewStyle::WhiteSpaceVisible(bool inIndent) const noexcept {
464  	return (!inIndent && viewWhitespace == WhiteSpace::VisibleAfterIndent) ||
465  		(inIndent && viewWhitespace == WhiteSpace::VisibleOnlyInIndent) ||
466  		viewWhitespace == WhiteSpace::VisibleAlways;
467  }
468  ColourRGBA ViewStyle::WrapColour() const {
469  	return ElementColour(Element::WhiteSpace).value_or(styles[StyleDefault].fore);
470  }
471  void ViewStyle::AddMultiEdge(int column, ColourRGBA colour) {
472  	theMultiEdge.insert(
473  		std::upper_bound(theMultiEdge.begin(), theMultiEdge.end(), column,
474  			[](const EdgeProperties &a, const EdgeProperties &b) noexcept {
475  				return a.column < b.column;
476  			}),
477  		EdgeProperties(column, colour));
478  }
479  ColourOptional ViewStyle::ElementColour(Element element) const {
480  	ElementMap::const_iterator search = elementColours.find(element);
481  	if (search != elementColours.end()) {
482  		if (search->second.has_value()) {
483  			return search->second;
484  		}
485  	}
486  	ElementMap::const_iterator searchBase = elementBaseColours.find(element);
487  	if (searchBase != elementBaseColours.end()) {
488  		if (searchBase->second.has_value()) {
489  			return searchBase->second;
490  		}
491  	}
492  	return {};
493  }
494  ColourRGBA ViewStyle::ElementColourForced(Element element) const {
495  	const ColourOptional colour = ElementColour(element);
496  	constexpr ColourRGBA opaqueBlack(0, 0, 0, 0xff);
497  	return colour.value_or(opaqueBlack);
498  }
499  bool ViewStyle::ElementAllowsTranslucent(Element element) const {
500  	return elementAllowsTranslucent.count(element) > 0;
501  }
502  bool ViewStyle::ResetElement(Element element) {
503  	ElementMap::const_iterator search = elementColours.find(element);
504  	const bool changed = (search != elementColours.end()) && (search->second.has_value());
505  	elementColours.erase(element);
506  	return changed;
507  }
508  bool ViewStyle::SetElementColour(Element element, ColourRGBA colour) {
509  	ElementMap::const_iterator search = elementColours.find(element);
510  	const bool changed =
511  		(search == elementColours.end()) ||
512  		(search->second.has_value() && !(*search->second == colour));
513  	elementColours[element] = colour;
514  	return changed;
515  }
516  bool ViewStyle::SetElementColourOptional(Element element, uptr_t wParam, sptr_t lParam) {
517  	if (wParam) {
518  		return SetElementColour(element, ColourRGBA::FromIpRGB(lParam));
519  	} else {
520  		return ResetElement(element);
521  	}
522  }
523  void ViewStyle::SetElementRGB(Element element, int rgb) {
524  	const ColourRGBA current = ElementColour(element).value_or(ColourRGBA(0, 0, 0, 0));
525  	elementColours[element] = ColourRGBA(ColourRGBA(rgb), current.GetAlpha());
526  }
527  void ViewStyle::SetElementAlpha(Element element, int alpha) {
528  	const ColourRGBA current = ElementColour(element).value_or(ColourRGBA(0, 0, 0, 0));
529  	elementColours[element] = ColourRGBA(current, std::min(alpha, 0xff));
530  }
531  bool ViewStyle::ElementIsSet(Element element) const {
532  	ElementMap::const_iterator search = elementColours.find(element);
533  	if (search != elementColours.end()) {
534  		return search->second.has_value();
535  	}
536  	return false;
537  }
538  bool ViewStyle::SetElementBase(Element element, ColourRGBA colour) {
539  	ElementMap::const_iterator search = elementBaseColours.find(element);
540  	const bool changed =
541  		(search == elementBaseColours.end()) ||
542  		(search->second.has_value() && !(*search->second == colour));
543  	elementBaseColours[element] = colour;
544  	return changed;
545  }
546  bool ViewStyle::SetWrapState(Wrap wrapState_) noexcept {
547  	const bool changed = wrap.state != wrapState_;
548  	wrap.state = wrapState_;
549  	return changed;
550  }
551  bool ViewStyle::SetWrapVisualFlags(WrapVisualFlag wrapVisualFlags_) noexcept {
552  	const bool changed = wrap.visualFlags != wrapVisualFlags_;
553  	wrap.visualFlags = wrapVisualFlags_;
554  	return changed;
555  }
556  bool ViewStyle::SetWrapVisualFlagsLocation(WrapVisualLocation wrapVisualFlagsLocation_) noexcept {
557  	const bool changed = wrap.visualFlagsLocation != wrapVisualFlagsLocation_;
558  	wrap.visualFlagsLocation = wrapVisualFlagsLocation_;
559  	return changed;
560  }
561  bool ViewStyle::SetWrapVisualStartIndent(int wrapVisualStartIndent_) noexcept {
562  	const bool changed = wrap.visualStartIndent != wrapVisualStartIndent_;
563  	wrap.visualStartIndent = wrapVisualStartIndent_;
564  	return changed;
565  }
566  bool ViewStyle::SetWrapIndentMode(WrapIndentMode wrapIndentMode_) noexcept {
567  	const bool changed = wrap.indentMode != wrapIndentMode_;
568  	wrap.indentMode = wrapIndentMode_;
569  	return changed;
570  }
571  bool ViewStyle::IsBlockCaretStyle() const noexcept {
572  	return ((caret.style & CaretStyle::InsMask) == CaretStyle::Block) ||
573  		FlagSet(caret.style, CaretStyle::OverstrikeBlock) ||
574  		FlagSet(caret.style, CaretStyle::Curses);
575  }
576  bool ViewStyle::IsCaretVisible(bool isMainSelection) const noexcept {
577  	return caret.width > 0 &&
578  		((caret.style & CaretStyle::InsMask) != CaretStyle::Invisible ||
579  		(FlagSet(caret.style, CaretStyle::Curses) && !isMainSelection)); 
580  }
581  bool ViewStyle::DrawCaretInsideSelection(bool inOverstrike, bool imeCaretBlockOverride) const noexcept {
582  	if (FlagSet(caret.style, CaretStyle::BlockAfter))
583  		return false;
584  	return ((caret.style & CaretStyle::InsMask) == CaretStyle::Block) ||
585  		(inOverstrike && FlagSet(caret.style, CaretStyle::OverstrikeBlock)) ||
586  		imeCaretBlockOverride ||
587  		FlagSet(caret.style, CaretStyle::Curses);
588  }
589  ViewStyle::CaretShape ViewStyle::CaretShapeForMode(bool inOverstrike, bool isMainSelection) const noexcept {
590  	if (inOverstrike) {
591  		return (FlagSet(caret.style, CaretStyle::OverstrikeBlock)) ? CaretShape::block : CaretShape::bar;
592  	}
593  	if (FlagSet(caret.style, CaretStyle::Curses) && !isMainSelection) {
594  		return CaretShape::block;
595  	}
596  	const CaretStyle caretStyle = caret.style & CaretStyle::InsMask;
597  	return (caretStyle <= CaretStyle::Block) ? static_cast<CaretShape>(caretStyle) : CaretShape::line;
598  }
599  void ViewStyle::AllocStyles(size_t sizeNew) {
600  	size_t i=styles.size();
601  	styles.resize(sizeNew);
602  	if (styles.size() > StyleDefault) {
603  		for (; i<sizeNew; i++) {
604  			if (i != StyleDefault) {
605  				styles[i] = styles[StyleDefault];
606  			}
607  		}
608  	}
609  }
610  void ViewStyle::CreateAndAddFont(const FontSpecification &fs) {
611  	if (fs.fontName) {
612  		FontMap::iterator it = fonts.find(fs);
613  		if (it == fonts.end()) {
614  			fonts[fs] = std::make_unique<FontRealised>();
615  		}
616  	}
617  }
618  FontRealised *ViewStyle::Find(const FontSpecification &fs) {
619  	if (!fs.fontName)	
620  		return fonts.begin()->second.get();
621  	FontMap::iterator it = fonts.find(fs);
622  	if (it != fonts.end()) {
623  		return it->second.get();
624  	}
625  	return nullptr;
626  }
627  void ViewStyle::FindMaxAscentDescent() noexcept {
628  	for (size_t i = 0; i < styles.size(); i++) {
629  		if (i == StyleCallTip)
630  			continue;
631  		const auto &style = styles[i];
632  		if (maxAscent < style.ascent)
<span onclick='openModal()' class='match'>633  			maxAscent = style.ascent;
634  		if (maxDescent < style.descent)
635  			maxDescent = style.descent;
636  	}
637  }
</span></code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-ViewStyle.cxx</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-ViewStyle.cxx</div>
                </div>
                <div class="column column_space"><pre><code>633  			maxAscent = style.ascent;
634  		if (maxDescent < style.descent)
635  			maxDescent = style.descent;
636  	}
637  }
</pre></code></div>
                <div class="column column_space"><pre><code>633  			maxAscent = style.ascent;
634  		if (maxDescent < style.descent)
635  			maxDescent = style.descent;
636  	}
637  }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    