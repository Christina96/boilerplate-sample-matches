
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 6.572769953051644%, Tokens: 9</h2>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-test_mkldnn_pooling_layer.cpp</h3>
            <pre><code>1  #ifdef MKLDNN_SUPPORTED
2  #include <vector>
3  #include "gtest/gtest.h"
4  #include "caffe/blob.hpp"
5  #include "caffe/common.hpp"
6  #include "caffe/filler.hpp"
7  #include "caffe/layers/mkldnn_layers.hpp"
8  #include "caffe/test/test_caffe_main.hpp"
9  #include "caffe/test/test_gradient_check_util.hpp"
10  namespace caffe {
11  template <typename TypeParam>
12  class MKLDNNPoolingLayerTest : public MultiDeviceTest<TypeParam> {
13    typedef typename TypeParam::Dtype Dtype;
14   protected:
15    MKLDNNPoolingLayerTest()
16        : blob_bottom_(new Blob<Dtype>()),
17          blob_top_(new Blob<Dtype>()),
18          blob_top_mask_(new Blob<size_t>()) {}
19    virtual void SetUp() {
20      Caffe::set_random_seed(1701);
21      blob_bottom_->Reshape(2, 3, 6, 5);
22      FillerParameter filler_param;
23      GaussianFiller<Dtype> filler(filler_param);
24      filler.Fill(this->blob_bottom_);
25      blob_bottom_vec_.push_back(blob_bottom_);
26      blob_top_vec_.push_back(blob_top_);
27    }
28    virtual ~MKLDNNPoolingLayerTest() {
29      delete blob_bottom_;
30      delete blob_top_;
31      delete blob_top_mask_;
32    }
33    Blob<Dtype>* const blob_bottom_;
34    Blob<Dtype>* const blob_top_;
35    Blob<size_t>* const blob_top_mask_;
36    vector<Blob<Dtype>*> blob_bottom_vec_;
37    vector<Blob<Dtype>*> blob_top_vec_;
38    void TestForwardSquare() {
39      LayerParameter layer_param;
40      PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
41      pooling_param->set_kernel_size(2);
42      pooling_param->set_pool(PoolingParameter_PoolMethod_MAX);
43      const int num = 2;
44      const int channels = 2;
45      blob_bottom_->Reshape(num, channels, 3, 5);
46      for (int i = 0; i < 15 * num * channels; i += 15) {
47        blob_bottom_->mutable_cpu_data()[i +  0] = 1;
48        blob_bottom_->mutable_cpu_data()[i +  1] = 2;
49        blob_bottom_->mutable_cpu_data()[i +  2] = 5;
50        blob_bottom_->mutable_cpu_data()[i +  3] = 2;
51        blob_bottom_->mutable_cpu_data()[i +  4] = 3;
52        blob_bottom_->mutable_cpu_data()[i +  5] = 9;
53        blob_bottom_->mutable_cpu_data()[i +  6] = 4;
54        blob_bottom_->mutable_cpu_data()[i +  7] = 1;
55        blob_bottom_->mutable_cpu_data()[i +  8] = 4;
56        blob_bottom_->mutable_cpu_data()[i +  9] = 8;
57        blob_bottom_->mutable_cpu_data()[i + 10] = 1;
58        blob_bottom_->mutable_cpu_data()[i + 11] = 2;
59        blob_bottom_->mutable_cpu_data()[i + 12] = 5;
60        blob_bottom_->mutable_cpu_data()[i + 13] = 2;
61        blob_bottom_->mutable_cpu_data()[i + 14] = 3;
62      }
63      MKLDNNPoolingLayer<Dtype> layer(layer_param);
64      layer.SetUp(blob_bottom_vec_, blob_top_vec_);
65      EXPECT_EQ(blob_top_->num(), num);
66      EXPECT_EQ(blob_top_->channels(), channels);
67      EXPECT_EQ(blob_top_->height(), 2);
68      EXPECT_EQ(blob_top_->width(), 4);
69      if (blob_top_vec_.size() > 1) {
70        EXPECT_EQ(blob_top_mask_->num(), num);
71        EXPECT_EQ(blob_top_mask_->channels(), channels);
72        EXPECT_EQ(blob_top_mask_->height(), 2);
73        EXPECT_EQ(blob_top_mask_->width(), 4);
74      }
75      layer.Forward(blob_bottom_vec_, blob_top_vec_);
76      for (int i = 0; i < 8 * num * channels; i += 8) {
77        EXPECT_EQ(blob_top_->cpu_data()[i + 0], 9);
78        EXPECT_EQ(blob_top_->cpu_data()[i + 1], 5);
79        EXPECT_EQ(blob_top_->cpu_data()[i + 2], 5);
80        EXPECT_EQ(blob_top_->cpu_data()[i + 3], 8);
81        EXPECT_EQ(blob_top_->cpu_data()[i + 4], 9);
82        EXPECT_EQ(blob_top_->cpu_data()[i + 5], 5);
83        EXPECT_EQ(blob_top_->cpu_data()[i + 6], 5);
84        EXPECT_EQ(blob_top_->cpu_data()[i + 7], 8);
85      }
86      if (blob_top_vec_.size() > 1) {
87        uint32_t *mask = reinterpret_cast<uint32_t*>(blob_top_mask_->mutable_cpu_data());
88        for (int i = 0; i < 8 * num * channels; i += 8) {
89          EXPECT_EQ(mask[i + 0],  5);
90          EXPECT_EQ(mask[i + 1],  2);
91          EXPECT_EQ(mask[i + 2],  2);
92          EXPECT_EQ(mask[i + 3],  9);
93          EXPECT_EQ(mask[i + 4],  5);
94          EXPECT_EQ(mask[i + 5], 12);
95          EXPECT_EQ(mask[i + 6], 12);
96          EXPECT_EQ(mask[i + 7],  9);
97        }
98      }
99    }
100    void TestForwardRectHigh() {
101      LayerParameter layer_param;
102      PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
103      pooling_param->set_kernel_h(3);
104      pooling_param->set_kernel_w(2);
105      pooling_param->set_pool(PoolingParameter_PoolMethod_MAX);
106      const int num = 2;
107      const int channels = 2;
108      blob_bottom_->Reshape(num, channels, 6, 6);
109      for (int i = 0; i < 36 * num * channels; i += 36) {
110        blob_bottom_->mutable_cpu_data()[i +  0] = 35;
111        blob_bottom_->mutable_cpu_data()[i +  1] = 1;
112        blob_bottom_->mutable_cpu_data()[i +  2] = 6;
113        blob_bottom_->mutable_cpu_data()[i +  3] = 26;
114        blob_bottom_->mutable_cpu_data()[i +  4] = 19;
115        blob_bottom_->mutable_cpu_data()[i +  5] = 24;
116        blob_bottom_->mutable_cpu_data()[i +  6] = 3;
117        blob_bottom_->mutable_cpu_data()[i +  7] = 32;
118        blob_bottom_->mutable_cpu_data()[i +  8] = 7;
119        blob_bottom_->mutable_cpu_data()[i +  9] = 21;
120        blob_bottom_->mutable_cpu_data()[i + 10] = 23;
121        blob_bottom_->mutable_cpu_data()[i + 11] = 25;
122        blob_bottom_->mutable_cpu_data()[i + 12] = 31;
123        blob_bottom_->mutable_cpu_data()[i + 13] = 9;
124        blob_bottom_->mutable_cpu_data()[i + 14] = 2;
125        blob_bottom_->mutable_cpu_data()[i + 15] = 22;
126        blob_bottom_->mutable_cpu_data()[i + 16] = 27;
127        blob_bottom_->mutable_cpu_data()[i + 17] = 20;
128        blob_bottom_->mutable_cpu_data()[i + 18] = 8;
129        blob_bottom_->mutable_cpu_data()[i + 19] = 28;
130        blob_bottom_->mutable_cpu_data()[i + 20] = 33;
131        blob_bottom_->mutable_cpu_data()[i + 21] = 17;
132        blob_bottom_->mutable_cpu_data()[i + 22] = 10;
133        blob_bottom_->mutable_cpu_data()[i + 23] = 15;
134        blob_bottom_->mutable_cpu_data()[i + 24] = 30;
135        blob_bottom_->mutable_cpu_data()[i + 25] = 5;
136        blob_bottom_->mutable_cpu_data()[i + 26] = 34;
137        blob_bottom_->mutable_cpu_data()[i + 27] = 12;
138        blob_bottom_->mutable_cpu_data()[i + 28] = 14;
139        blob_bottom_->mutable_cpu_data()[i + 29] = 16;
140        blob_bottom_->mutable_cpu_data()[i + 30] = 4;
141        blob_bottom_->mutable_cpu_data()[i + 31] = 36;
142        blob_bottom_->mutable_cpu_data()[i + 32] = 29;
143        blob_bottom_->mutable_cpu_data()[i + 33] = 13;
144        blob_bottom_->mutable_cpu_data()[i + 34] = 18;
145        blob_bottom_->mutable_cpu_data()[i + 35] = 11;
146      }
147      MKLDNNPoolingLayer<Dtype> layer(layer_param);
148      layer.SetUp(blob_bottom_vec_, blob_top_vec_);
149      EXPECT_EQ(blob_top_->num(), num);
150      EXPECT_EQ(blob_top_->channels(), channels);
151      EXPECT_EQ(blob_top_->height(), 4);
152      EXPECT_EQ(blob_top_->width(), 5);
153      if (blob_top_vec_.size() > 1) {
154        EXPECT_EQ(blob_top_mask_->num(), num);
155        EXPECT_EQ(blob_top_mask_->channels(), channels);
156        EXPECT_EQ(blob_top_mask_->height(), 4);
157        EXPECT_EQ(blob_top_mask_->width(), 5);
158      }
159      layer.Forward(blob_bottom_vec_, blob_top_vec_);
160      for (int i = 0; i < 20 * num * channels; i += 20) {
161        EXPECT_EQ(blob_top_->cpu_data()[i +  0], 35);
162        EXPECT_EQ(blob_top_->cpu_data()[i +  1], 32);
163        EXPECT_EQ(blob_top_->cpu_data()[i +  2], 26);
164        EXPECT_EQ(blob_top_->cpu_data()[i +  3], 27);
165        EXPECT_EQ(blob_top_->cpu_data()[i +  4], 27);
166        EXPECT_EQ(blob_top_->cpu_data()[i +  5], 32);
167        EXPECT_EQ(blob_top_->cpu_data()[i +  6], 33);
168        EXPECT_EQ(blob_top_->cpu_data()[i +  7], 33);
169        EXPECT_EQ(blob_top_->cpu_data()[i +  8], 27);
170        EXPECT_EQ(blob_top_->cpu_data()[i +  9], 27);
171        EXPECT_EQ(blob_top_->cpu_data()[i + 10], 31);
172        EXPECT_EQ(blob_top_->cpu_data()[i + 11], 34);
173        EXPECT_EQ(blob_top_->cpu_data()[i + 12], 34);
174        EXPECT_EQ(blob_top_->cpu_data()[i + 13], 27);
175        EXPECT_EQ(blob_top_->cpu_data()[i + 14], 27);
176        EXPECT_EQ(blob_top_->cpu_data()[i + 15], 36);
177        EXPECT_EQ(blob_top_->cpu_data()[i + 16], 36);
178        EXPECT_EQ(blob_top_->cpu_data()[i + 17], 34);
179        EXPECT_EQ(blob_top_->cpu_data()[i + 18], 18);
180        EXPECT_EQ(blob_top_->cpu_data()[i + 19], 18);
181      }
182      if (blob_top_vec_.size() > 1) {
183      uint32_t *mask = reinterpret_cast<uint32_t*>(blob_top_mask_->mutable_cpu_data());
184        for (int i = 0; i < 20 * num * channels; i += 20) {
185          EXPECT_EQ(mask[i +  0],  0);
186          EXPECT_EQ(mask[i +  1],  7);
187          EXPECT_EQ(mask[i +  2],  3);
188          EXPECT_EQ(mask[i +  3], 16);
189          EXPECT_EQ(mask[i +  4], 16);
190          EXPECT_EQ(mask[i +  5],  7);
191          EXPECT_EQ(mask[i +  6], 20);
192          EXPECT_EQ(mask[i +  7], 20);
193          EXPECT_EQ(mask[i +  8], 16);
194          EXPECT_EQ(mask[i +  9], 16);
195          EXPECT_EQ(mask[i + 10], 12);
196          EXPECT_EQ(mask[i + 11], 26);
197          EXPECT_EQ(mask[i + 12], 26);
198          EXPECT_EQ(mask[i + 13], 16);
199          EXPECT_EQ(mask[i + 14], 16);
200          EXPECT_EQ(mask[i + 15], 31);
201          EXPECT_EQ(mask[i + 16], 31);
202          EXPECT_EQ(mask[i + 17], 26);
203          EXPECT_EQ(mask[i + 18], 34);
204          EXPECT_EQ(mask[i + 19], 34);
205        }
206      }
207    }
208    void TestForwardRectWide() {
209      LayerParameter layer_param;
210      PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
211      pooling_param->set_kernel_h(2);
212      pooling_param->set_kernel_w(3);
213      pooling_param->set_pool(PoolingParameter_PoolMethod_MAX);
214      const int num = 2;
<span onclick='openModal()' class='match'>215      const int channels = 2;
216      blob_bottom_->Reshape(num, channels, 6, 6);
217      for (int i = 0; i < 36 * num * channels; i += 36) {
218        blob_bottom_->mutable_cpu_data()[i +  0] = 35;
219        blob_bottom_->mutable_cpu_data()[i +  1] = 1;
</span>220        blob_bottom_->mutable_cpu_data()[i +  2] = 6;
221        blob_bottom_->mutable_cpu_data()[i +  3] = 26;
222        blob_bottom_->mutable_cpu_data()[i +  4] = 19;
223        blob_bottom_->mutable_cpu_data()[i +  5] = 24;
224        blob_bottom_->mutable_cpu_data()[i +  6] = 3;
225        blob_bottom_->mutable_cpu_data()[i +  7] = 32;
226        blob_bottom_->mutable_cpu_data()[i +  8] = 7;
227        blob_bottom_->mutable_cpu_data()[i +  9] = 21;
228        blob_bottom_->mutable_cpu_data()[i + 10] = 23;
229        blob_bottom_->mutable_cpu_data()[i + 11] = 25;
230        blob_bottom_->mutable_cpu_data()[i + 12] = 31;
231        blob_bottom_->mutable_cpu_data()[i + 13] = 9;
232        blob_bottom_->mutable_cpu_data()[i + 14] = 2;
233        blob_bottom_->mutable_cpu_data()[i + 15] = 22;
234        blob_bottom_->mutable_cpu_data()[i + 16] = 27;
235        blob_bottom_->mutable_cpu_data()[i + 17] = 20;
236        blob_bottom_->mutable_cpu_data()[i + 18] = 8;
237        blob_bottom_->mutable_cpu_data()[i + 19] = 28;
238        blob_bottom_->mutable_cpu_data()[i + 20] = 33;
239        blob_bottom_->mutable_cpu_data()[i + 21] = 17;
240        blob_bottom_->mutable_cpu_data()[i + 22] = 10;
241        blob_bottom_->mutable_cpu_data()[i + 23] = 15;
242        blob_bottom_->mutable_cpu_data()[i + 24] = 30;
243        blob_bottom_->mutable_cpu_data()[i + 25] = 5;
244        blob_bottom_->mutable_cpu_data()[i + 26] = 34;
245        blob_bottom_->mutable_cpu_data()[i + 27] = 12;
246        blob_bottom_->mutable_cpu_data()[i + 28] = 14;
247        blob_bottom_->mutable_cpu_data()[i + 29] = 16;
248        blob_bottom_->mutable_cpu_data()[i + 30] = 4;
249        blob_bottom_->mutable_cpu_data()[i + 31] = 36;
250        blob_bottom_->mutable_cpu_data()[i + 32] = 29;
251        blob_bottom_->mutable_cpu_data()[i + 33] = 13;
252        blob_bottom_->mutable_cpu_data()[i + 34] = 18;
253        blob_bottom_->mutable_cpu_data()[i + 35] = 11;
254      }
255      MKLDNNPoolingLayer<Dtype> layer(layer_param);
256      layer.SetUp(blob_bottom_vec_, blob_top_vec_);
257      EXPECT_EQ(blob_top_->num(), num);
258      EXPECT_EQ(blob_top_->channels(), channels);
259      EXPECT_EQ(blob_top_->height(), 5);
260      EXPECT_EQ(blob_top_->width(), 4);
261      if (blob_top_vec_.size() > 1) {
262        EXPECT_EQ(blob_top_mask_->num(), num);
263        EXPECT_EQ(blob_top_mask_->channels(), channels);
264        EXPECT_EQ(blob_top_mask_->height(), 5);
265        EXPECT_EQ(blob_top_mask_->width(), 4);
266      }
267      layer.Forward(blob_bottom_vec_, blob_top_vec_);
268      for (int i = 0; i < 20 * num * channels; i += 20) {
269        EXPECT_EQ(blob_top_->cpu_data()[i +  0], 35);
270        EXPECT_EQ(blob_top_->cpu_data()[i +  1], 32);
271        EXPECT_EQ(blob_top_->cpu_data()[i +  2], 26);
272        EXPECT_EQ(blob_top_->cpu_data()[i +  3], 26);
273        EXPECT_EQ(blob_top_->cpu_data()[i +  4], 32);
274        EXPECT_EQ(blob_top_->cpu_data()[i +  5], 32);
275        EXPECT_EQ(blob_top_->cpu_data()[i +  6], 27);
276        EXPECT_EQ(blob_top_->cpu_data()[i +  7], 27);
277        EXPECT_EQ(blob_top_->cpu_data()[i +  8], 33);
278        EXPECT_EQ(blob_top_->cpu_data()[i +  9], 33);
279        EXPECT_EQ(blob_top_->cpu_data()[i + 10], 33);
280        EXPECT_EQ(blob_top_->cpu_data()[i + 11], 27);
281        EXPECT_EQ(blob_top_->cpu_data()[i + 12], 34);
282        EXPECT_EQ(blob_top_->cpu_data()[i + 13], 34);
283        EXPECT_EQ(blob_top_->cpu_data()[i + 14], 34);
284        EXPECT_EQ(blob_top_->cpu_data()[i + 15], 17);
285        EXPECT_EQ(blob_top_->cpu_data()[i + 16], 36);
286        EXPECT_EQ(blob_top_->cpu_data()[i + 17], 36);
287        EXPECT_EQ(blob_top_->cpu_data()[i + 18], 34);
288        EXPECT_EQ(blob_top_->cpu_data()[i + 19], 18);
289      }
290      if (blob_top_vec_.size() > 1) {
291        uint32_t *mask = reinterpret_cast<uint32_t*>(blob_top_mask_->mutable_cpu_data());
292        for (int i = 0; i < 20 * num * channels; i += 20) {
293          EXPECT_EQ(mask[i +  0],  0);
294          EXPECT_EQ(mask[i +  1],  7);
295          EXPECT_EQ(mask[i +  2],  3);
296          EXPECT_EQ(mask[i +  3],  3);
297          EXPECT_EQ(mask[i +  4],  7);
298          EXPECT_EQ(mask[i +  5],  7);
299          EXPECT_EQ(mask[i +  6], 16);
300          EXPECT_EQ(mask[i +  7], 16);
301          EXPECT_EQ(mask[i +  8], 20);
302          EXPECT_EQ(mask[i +  9], 20);
303          EXPECT_EQ(mask[i + 10], 20);
304          EXPECT_EQ(mask[i + 11], 16);
305          EXPECT_EQ(mask[i + 12], 26);
306          EXPECT_EQ(mask[i + 13], 26);
307          EXPECT_EQ(mask[i + 14], 26);
308          EXPECT_EQ(mask[i + 15], 21);
309          EXPECT_EQ(mask[i + 16], 31);
310          EXPECT_EQ(mask[i + 17], 31);
311          EXPECT_EQ(mask[i + 18], 26);
312          EXPECT_EQ(mask[i + 19], 34);
313        }
314      }
315    }
316  };
317  typedef ::testing::Types<CPUDevice<float> > TestDtypesCPU;
318  TYPED_TEST_CASE(MKLDNNPoolingLayerTest, TestDtypesCPU);
319  TYPED_TEST(MKLDNNPoolingLayerTest, TestSetup) {
320    typedef typename TypeParam::Dtype Dtype;
321    LayerParameter layer_param;
322    PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
323    pooling_param->set_kernel_size(3);
324    pooling_param->set_stride(2);
325    MKLDNNPoolingLayer<Dtype> layer(layer_param);
326    layer.SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
327    EXPECT_EQ(this->blob_top_->num(), this->blob_bottom_->num());
328    EXPECT_EQ(this->blob_top_->channels(), this->blob_bottom_->channels());
329    EXPECT_EQ(this->blob_top_->height(), 3);
330    EXPECT_EQ(this->blob_top_->width(), 2);
331  }
332  TYPED_TEST(MKLDNNPoolingLayerTest, TestSetupPadded) {
333    typedef typename TypeParam::Dtype Dtype;
334    LayerParameter layer_param;
335    PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
336    pooling_param->set_kernel_size(3);
337    pooling_param->set_stride(2);
338    pooling_param->set_pad(1);
339    pooling_param->set_pool(PoolingParameter_PoolMethod_MAX);
340    MKLDNNPoolingLayer<Dtype> layer(layer_param);
341    layer.SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
342    EXPECT_EQ(this->blob_top_->num(), this->blob_bottom_->num());
343    EXPECT_EQ(this->blob_top_->channels(), this->blob_bottom_->channels());
344    EXPECT_EQ(this->blob_top_->height(), 4);
345    EXPECT_EQ(this->blob_top_->width(), 3);
346  }
347  TYPED_TEST(MKLDNNPoolingLayerTest, TestSetupGlobalPooling) {
348    typedef typename TypeParam::Dtype Dtype;
349    LayerParameter layer_param;
350    PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
351    pooling_param->set_global_pooling(true);
352    pooling_param->set_pool(PoolingParameter_PoolMethod_MAX);
353    MKLDNNPoolingLayer<Dtype> layer(layer_param);
354    layer.SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
355    EXPECT_EQ(this->blob_top_->num(), this->blob_bottom_->num());
356    EXPECT_EQ(this->blob_top_->channels(), this->blob_bottom_->channels());
357    EXPECT_EQ(this->blob_top_->height(), 1);
358    EXPECT_EQ(this->blob_top_->width(), 1);
359  }
360  TYPED_TEST(MKLDNNPoolingLayerTest, TestForwardMax) {
361    this->TestForwardSquare();
362    this->TestForwardRectHigh();
363    this->TestForwardRectWide();
364  }
365  #if 0
366  TYPED_TEST(MKLDNNPoolingLayerTest, TestForwardMaxTopMask) {
367    typedef typename TypeParam::Dtype Dtype;
368    this->blob_top_vec_.push_back(reinterpret_cast<Blob<Dtype>* >
369            (this->blob_top_mask_));
370    this->TestForwardSquare();
371    this->TestForwardRectHigh();
372    this->TestForwardRectWide();
373  }
374  #endif
375  TYPED_TEST(MKLDNNPoolingLayerTest, TestGradientMax) {
376    typedef typename TypeParam::Dtype Dtype;
377    for (int kernel_h = 3; kernel_h <= 4; kernel_h++) {
378      for (int kernel_w = 3; kernel_w <= 4; kernel_w++) {
379        LayerParameter layer_param;
380        PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
381        pooling_param->set_kernel_h(kernel_h);
382        pooling_param->set_kernel_w(kernel_w);
383        pooling_param->set_stride(2);
384        pooling_param->set_pad(1);
385        pooling_param->set_pool(PoolingParameter_PoolMethod_MAX);
386        MKLDNNPoolingLayer<Dtype> layer(layer_param);
387        GradientChecker<Dtype> checker(1e-4, 1e-2);
388        checker.CheckGradientExhaustive(&layer, this->blob_bottom_vec_,
389            this->blob_top_vec_);
390      }
391    }
392  }
393  TYPED_TEST(MKLDNNPoolingLayerTest, TestForwardMaxPadded) {
394    typedef typename TypeParam::Dtype Dtype;
395    LayerParameter layer_param;
396    PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
397    pooling_param->set_kernel_size(3);
398    pooling_param->set_stride(2);
399    pooling_param->set_pad(2);
400    pooling_param->set_pool(PoolingParameter_PoolMethod_MAX);
401    this->blob_bottom_->Reshape(1, 1, 3, 3);
402    this->blob_bottom_->mutable_cpu_data()[0] = 1;
403    this->blob_bottom_->mutable_cpu_data()[1] = 2;
404    this->blob_bottom_->mutable_cpu_data()[2] = 4;
405    this->blob_bottom_->mutable_cpu_data()[3] = 2;
406    this->blob_bottom_->mutable_cpu_data()[4] = 3;
407    this->blob_bottom_->mutable_cpu_data()[5] = 2;
408    this->blob_bottom_->mutable_cpu_data()[6] = 4;
409    this->blob_bottom_->mutable_cpu_data()[7] = 2;
410    this->blob_bottom_->mutable_cpu_data()[8] = 1;
411    MKLDNNPoolingLayer<Dtype> layer(layer_param);
412    layer.SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
413    EXPECT_EQ(this->blob_top_->num(), 1);
414    EXPECT_EQ(this->blob_top_->channels(), 1);
415    EXPECT_EQ(this->blob_top_->height(), 3);
416    EXPECT_EQ(this->blob_top_->width(), 3);
417    layer.Forward(this->blob_bottom_vec_, this->blob_top_vec_);
418    Dtype epsilon = 1e-8;
419    EXPECT_NEAR(this->blob_top_->cpu_data()[0], 1, epsilon);
420    EXPECT_NEAR(this->blob_top_->cpu_data()[1], 4, epsilon);
421    EXPECT_NEAR(this->blob_top_->cpu_data()[2], 4, epsilon);
422    EXPECT_NEAR(this->blob_top_->cpu_data()[3], 4, epsilon);
423    EXPECT_NEAR(this->blob_top_->cpu_data()[4], 4, epsilon);
424    EXPECT_NEAR(this->blob_top_->cpu_data()[5], 4, epsilon);
425    EXPECT_NEAR(this->blob_top_->cpu_data()[6], 4, epsilon);
426    EXPECT_NEAR(this->blob_top_->cpu_data()[7], 4, epsilon);
427    EXPECT_NEAR(this->blob_top_->cpu_data()[8], 1, epsilon);
428  }
429  #if 0
430  TYPED_TEST(MKLDNNPoolingLayerTest, TestGradientMaxTopMask) {
431    typedef typename TypeParam::Dtype Dtype;
432    for (int kernel_h = 3; kernel_h <= 4; kernel_h++) {
433      for (int kernel_w = 3; kernel_w <= 4; kernel_w++) {
434        LayerParameter layer_param;
435        PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
436        pooling_param->set_kernel_h(kernel_h);
437        pooling_param->set_kernel_w(kernel_w);
438        pooling_param->set_stride(2);
439        pooling_param->set_pool(PoolingParameter_PoolMethod_MAX);
440        this->blob_top_vec_.push_back(reinterpret_cast<Blob<Dtype>* >
441                (this->blob_top_mask_));
442        MKLDNNPoolingLayer<Dtype> layer(layer_param);
443        GradientChecker<Dtype> checker(1e-4, 1e-2);
444        checker.CheckGradientExhaustive(&layer, this->blob_bottom_vec_,
445            this->blob_top_vec_);
446        this->blob_top_vec_.pop_back();
447      }
448    }
449  }
450  #endif
451  TYPED_TEST(MKLDNNPoolingLayerTest, TestForwardAve) {
452    typedef typename TypeParam::Dtype Dtype;
453    LayerParameter layer_param;
454    PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
455    pooling_param->set_kernel_size(3);
456    pooling_param->set_stride(1);
457    pooling_param->set_pad(1);
458    pooling_param->set_pool(PoolingParameter_PoolMethod_AVE);
459    this->blob_bottom_->Reshape(1, 1, 3, 3);
460    FillerParameter filler_param;
461    filler_param.set_value(Dtype(2));
462    ConstantFiller<Dtype> filler(filler_param);
463    filler.Fill(this->blob_bottom_);
464    MKLDNNPoolingLayer<Dtype> layer(layer_param);
465    layer.SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
466    EXPECT_EQ(this->blob_top_->num(), 1);
467    EXPECT_EQ(this->blob_top_->channels(), 1);
468    EXPECT_EQ(this->blob_top_->height(), 3);
469    EXPECT_EQ(this->blob_top_->width(), 3);
470    layer.Forward(this->blob_bottom_vec_, this->blob_top_vec_);
471    Dtype epsilon = 1e-5;
472  #if 0
473    cout << "bottom blob [0]: " << this->blob_bottom_->cpu_data()[0] << endl;
474    cout << "bottom blob [1]: " << this->blob_bottom_->cpu_data()[1] << endl;
475    cout << "bottom blob [2]: " << this->blob_bottom_->cpu_data()[2] << endl;
476    cout << "bottom blob [3]: " << this->blob_bottom_->cpu_data()[3] << endl;
477    cout << "bottom blob [4]: " << this->blob_bottom_->cpu_data()[4] << endl;
478    cout << "bottom blob [5]: " << this->blob_bottom_->cpu_data()[5] << endl;
479    cout << "bottom blob [6]: " << this->blob_bottom_->cpu_data()[6] << endl;
480    cout << "bottom blob [7]: " << this->blob_bottom_->cpu_data()[7] << endl;
481    cout << "bottom blob [8]: " << this->blob_bottom_->cpu_data()[8] << endl;
482    cout << "top blob [0]: " << this->blob_top_->cpu_data()[0] << endl;
483    cout << "top blob [1]: " << this->blob_top_->cpu_data()[1] << endl;
484    cout << "top blob [2]: " << this->blob_top_->cpu_data()[2] << endl;
485    cout << "top blob [3]: " << this->blob_top_->cpu_data()[3] << endl;
486    cout << "top blob [4]: " << this->blob_top_->cpu_data()[4] << endl;
487    cout << "top blob [5]: " << this->blob_top_->cpu_data()[5] << endl;
488    cout << "top blob [6]: " << this->blob_top_->cpu_data()[6] << endl;
489    cout << "top blob [7]: " << this->blob_top_->cpu_data()[7] << endl;
490    cout << "top blob [8]: " << this->blob_top_->cpu_data()[8] << endl;
491  #endif
492    EXPECT_NEAR(this->blob_top_->cpu_data()[0], 8.0 / 9, epsilon);
493    EXPECT_NEAR(this->blob_top_->cpu_data()[1], 12.0 / 9, epsilon);
494    EXPECT_NEAR(this->blob_top_->cpu_data()[2], 8.0 / 9, epsilon);
495    EXPECT_NEAR(this->blob_top_->cpu_data()[3], 12.0 / 9, epsilon);
496    EXPECT_NEAR(this->blob_top_->cpu_data()[4], 2.0    , epsilon);
497    EXPECT_NEAR(this->blob_top_->cpu_data()[5], 12.0 / 9, epsilon);
498    EXPECT_NEAR(this->blob_top_->cpu_data()[6], 8.0 / 9, epsilon);
499    EXPECT_NEAR(this->blob_top_->cpu_data()[7], 12.0 / 9, epsilon);
500    EXPECT_NEAR(this->blob_top_->cpu_data()[8], 8.0 / 9, epsilon);
501  }
502  #if 0
503  TYPED_TEST(MKLDNNPoolingLayerTest, DISABLED_TestGradientAve) {
504    typedef typename TypeParam::Dtype Dtype;
505    for (int kernel_h = 3; kernel_h <= 4; kernel_h++) {
506      for (int kernel_w = 3; kernel_w <= 4; kernel_w++) {
507        LayerParameter layer_param;
508        PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
509        pooling_param->set_kernel_h(kernel_h);
510        pooling_param->set_kernel_w(kernel_w);
511        pooling_param->set_stride(2);
512        pooling_param->set_pool(PoolingParameter_PoolMethod_AVE);
513        MKLDNNPoolingLayer<Dtype> layer(layer_param);
514        GradientChecker<Dtype> checker(1e-2, 1e-2);
515        checker.CheckGradientExhaustive(&layer, this->blob_bottom_vec_,
516            this->blob_top_vec_);
517      }
518    }
519  }
520  #endif
521  TYPED_TEST(MKLDNNPoolingLayerTest, TestGradientAvePadded) {
522    typedef typename TypeParam::Dtype Dtype;
523    for (int kernel_h = 3; kernel_h <= 4; kernel_h++) {
524      for (int kernel_w = 3; kernel_w <= 4; kernel_w++) {
525        LayerParameter layer_param;
526        PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
527        pooling_param->set_kernel_h(kernel_h);
528        pooling_param->set_kernel_w(kernel_w);
529        pooling_param->set_stride(2);
530        pooling_param->set_pad(2);
531        pooling_param->set_pool(PoolingParameter_PoolMethod_AVE);
532        MKLDNNPoolingLayer<Dtype> layer(layer_param);
533        GradientChecker<Dtype> checker(1e-2, 1e-2);
534        checker.CheckGradientExhaustive(&layer, this->blob_bottom_vec_,
535            this->blob_top_vec_);
536      }
537    }
538  }
539  }  
540  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-VerticalFileSwitcherListView.cpp</h3>
            <pre><code>1  #include <shlwapi.h>
2  #include <stdexcept>
3  #include "VerticalFileSwitcherListView.h"
4  #include "Buffer.h"
5  #include "localization.h"
6  void VerticalFileSwitcherListView::init(HINSTANCE hInst, HWND parent, HIMAGELIST hImaLst)
7  {
8  	Window::init(hInst, parent);
9  	_hImaLst = hImaLst;
10  	INITCOMMONCONTROLSEX icex{};
11  	icex.dwSize = sizeof(INITCOMMONCONTROLSEX);
12  	icex.dwICC  = ICC_LISTVIEW_CLASSES;
13  	InitCommonControlsEx(&icex);
14  	int listViewStyles = LVS_REPORT &bsol;*| LVS_SINGLESEL*/ | LVS_AUTOARRANGE\
15  						| LVS_SHAREIMAGELISTS | LVS_SHOWSELALWAYS | LVS_ALIGNTOP;
16  	_hSelf = ::CreateWindow(WC_LISTVIEW,
17                                  TEXT(""),
18                                  WS_CHILD | WS_BORDER | listViewStyles,
19                                  0,
20                                  0,
21                                  0,
22                                  0,
23                                  _hParent,
24                                  nullptr,
25                                  hInst,
26                                  nullptr);
27  	if (!_hSelf)
28  	{
29  		throw std::runtime_error("VerticalFileSwitcherListView::init : CreateWindowEx() function return null");
30  	}
31  	ListView_SetExtendedListViewStyle(_hSelf, LVS_EX_FULLROWSELECT | LVS_EX_BORDERSELECT | LVS_EX_INFOTIP | LVS_EX_DOUBLEBUFFER);
32  	ListView_SetItemCountEx(_hSelf, 50, LVSICF_NOSCROLL);
33  	ListView_SetImageList(_hSelf, _hImaLst, LVSIL_SMALL);
34  	LVGROUP group{};
35  	constexpr size_t headerLen = 1;
36  	wchar_t header[headerLen] = L"";
37  	group.cbSize = sizeof(LVGROUP);
38  	group.mask = LVGF_HEADER | LVGF_GROUPID | LVGF_STATE;
39  	group.pszHeader = header;
40  	group.cchHeader = headerLen;
41  	group.iGroupId = _groupID;
42  	group.state = LVGS_COLLAPSIBLE;
43  	LVGROUP group2 = group;
44  	group2.iGroupId = _group2ID;
45  	ListView_InsertGroup(_hSelf, -1, &group);
46  	ListView_InsertGroup(_hSelf, -1, &group2);
47  }
48  void VerticalFileSwitcherListView::destroy()
49  {
50  	LVITEM item{};
51  	item.mask = LVIF_PARAM;
52  	int nbItem = ListView_GetItemCount(_hSelf);
53  	for (int i = 0 ; i < nbItem ; ++i)
54  	{
55  		item.iItem = i;
56  		ListView_GetItem(_hSelf, &item);
57  		TaskLstFnStatus *tlfs = (TaskLstFnStatus *)item.lParam;
58  		delete tlfs;
59  	}
60  	::DestroyWindow(_hSelf);
61  	_hSelf = NULL;
62  } 
63  void VerticalFileSwitcherListView::initList()
64  {
65  	NppParameters& nppParams = NppParameters::getInstance();
66  	NativeLangSpeaker *pNativeSpeaker = nppParams.getNativeLangSpeaker();
67  	const bool isListViewGroups = !nppParams.getNppGUI()._fileSwitcherDisableListViewGroups;
68  	ListView_EnableGroupView(_hSelf, isListViewGroups ? TRUE : FALSE);
69  	bool isExtColumn = !nppParams.getNppGUI()._fileSwitcherWithoutExtColumn;
70  	bool isPathColumn = !nppParams.getNppGUI()._fileSwitcherWithoutPathColumn;
71  	RECT rc{};
72  	::GetClientRect(_hParent, &rc);
73  	int nameWidth = rc.right - rc.left;
74  	int colIndex = 0;
75  	if (isExtColumn)
76  		nameWidth -= nppParams._dpiManager.scaleX(nppParams.getNppGUI()._fileSwitcherExtWidth);
77  	if (isPathColumn)
78  		nameWidth -= nppParams._dpiManager.scaleX(nppParams.getNppGUI()._fileSwitcherPathWidth);
79  	generic_string nameStr = pNativeSpeaker->getAttrNameStr(TEXT("Name"), FS_ROOTNODE, FS_CLMNNAME);
80  	insertColumn(nameStr.c_str(), nameWidth, ++colIndex);
81  	if (isExtColumn)
82  	{
83  		generic_string extStr = pNativeSpeaker->getAttrNameStr(TEXT("Ext."), FS_ROOTNODE, FS_CLMNEXT);
84  		insertColumn(extStr.c_str(), nppParams._dpiManager.scaleX(nppParams.getNppGUI()._fileSwitcherExtWidth), ++colIndex); 
85  	}
86  	if (isPathColumn)
87  	{
88  		generic_string pathStr = pNativeSpeaker->getAttrNameStr(TEXT("Path"), FS_ROOTNODE, FS_CLMNPATH);
89  		insertColumn(pathStr.c_str(), nppParams._dpiManager.scaleX(nppParams.getNppGUI()._fileSwitcherPathWidth), ++colIndex); 
90  	}
91  	TaskListInfo taskListInfo;
92  	static HWND nppHwnd = ::GetParent(_hParent);
93  	::SendMessage(nppHwnd, WM_GETTASKLISTINFO, reinterpret_cast<WPARAM>(&taskListInfo), TRUE);
94  	for (size_t i = 0, len = taskListInfo._tlfsLst.size(); i < len ; ++i)
95  	{
96  		TaskLstFnStatus & fileNameStatus = taskListInfo._tlfsLst[i];
97  		TaskLstFnStatus *tl = new TaskLstFnStatus(fileNameStatus);
98  		TCHAR fn[MAX_PATH] = { '\0' };
99  		wcscpy_s(fn, ::PathFindFileName(fileNameStatus._fn.c_str()));
100  		if (isExtColumn)
101  		{
102  			::PathRemoveExtension(fn);
103  		}
104  		LVITEM item{};
105  		item.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM | LVIF_GROUPID;
106  		item.pszText = fn;
107  		item.iItem = static_cast<int32_t>(i);
108  		item.iSubItem = 0;
109  		item.iImage = fileNameStatus._status;
110  		item.lParam = reinterpret_cast<LPARAM>(tl);
111  		item.iGroupId = (fileNameStatus._iView == MAIN_VIEW) ? _groupID : _group2ID;
112  		ListView_InsertItem(_hSelf, &item);
113  		int colIndex = 0;
114  		if (isExtColumn)
115  		{
116  			ListView_SetItemText(_hSelf, i, ++colIndex, ::PathFindExtension(fileNameStatus._fn.c_str()));
117  		}
118  		if (isPathColumn)
119  		{
120  			TCHAR dir[MAX_PATH] = { '\0' }, drive[MAX_PATH] = { '\0' };
121  			_wsplitpath_s(fileNameStatus._fn.c_str(), drive, MAX_PATH, dir, MAX_PATH, NULL, 0, NULL, 0);
122  			wcscat_s(drive, dir);
123  			ListView_SetItemText(_hSelf, i, ++colIndex, drive);
124  		}
125  	}
126  	_currentIndex = taskListInfo._currentIndex;
127  	selectCurrentItem();
128  	ensureVisibleCurrentItem();	
129  }
130  void VerticalFileSwitcherListView::reload()
131  {
132  	removeAll();
133  	initList();
134  	RECT rc{};
135  	::GetClientRect(_hParent, &rc);
136  	resizeColumns(rc.right - rc.left);
137  }
138  BufferID VerticalFileSwitcherListView::getBufferInfoFromIndex(int index, int & view) const
139  {
140  	int nbItem = ListView_GetItemCount(_hSelf);
141  	if (index < 0 || index >= nbItem)
142  		return BUFFER_INVALID;
143  	LVITEM item{};
144  	item.mask = LVIF_PARAM;
145  	item.iItem = index;
146  	ListView_GetItem(_hSelf, &item);
147  	TaskLstFnStatus *tlfs = (TaskLstFnStatus *)item.lParam;
148  	view = tlfs->_iView;
149  	return static_cast<BufferID>(tlfs->_bufID);
150  }
151  int VerticalFileSwitcherListView::newItem(BufferID bufferID, int iView)
152  {
153  	int i = find(bufferID, iView);
154  	if (i == -1)
155  	{
156  		i = add(bufferID, iView);
157  	}
158  	return i;
159  }
160  void VerticalFileSwitcherListView::setItemIconStatus(BufferID bufferID)
161  {
162  	Buffer *buf = bufferID;
163  	TCHAR fn[MAX_PATH] = { '\0' };
164  	wcscpy_s(fn, ::PathFindFileName(buf->getFileName()));
165  	bool isExtColumn = !(NppParameters::getInstance()).getNppGUI()._fileSwitcherWithoutExtColumn;
166  	bool isPathColumn = !(NppParameters::getInstance()).getNppGUI()._fileSwitcherWithoutPathColumn;
167  	if (isExtColumn)
168  	{
169  		::PathRemoveExtension(fn);
170  	}
171  	LVITEM item{};
172  	item.pszText = fn;
173  	item.iSubItem = 0;
174  	item.iImage = buf->isMonitoringOn()?3:(buf->isReadOnly()?2:(buf->isDirty()?1:0));
175  	int nbItem = ListView_GetItemCount(_hSelf);
176  	for (int i = 0 ; i < nbItem ; ++i)
177  	{
178  		item.mask = LVIF_PARAM;
179  		item.iItem = i;
180  		ListView_GetItem(_hSelf, &item);
181  		TaskLstFnStatus *tlfs = (TaskLstFnStatus *)(item.lParam);
182  		if (tlfs->_bufID == bufferID)
183  		{
184  			tlfs->_fn = buf->getFullPathName();
185  			item.mask = LVIF_TEXT | LVIF_IMAGE;
186  			ListView_SetItem(_hSelf, &item);
187  			int colIndex = 0;
188  			if (isExtColumn)
189  			{
190  				ListView_SetItemText(_hSelf, i, ++colIndex, (LPTSTR)::PathFindExtension(buf->getFileName()));
191  			}
192  			if (isPathColumn)
193  			{
194  				TCHAR dir[MAX_PATH] = { '\0' }, drive[MAX_PATH] = { '\0' };
195  				_wsplitpath_s(buf->getFullPathName(), drive, MAX_PATH, dir, MAX_PATH, NULL, 0, NULL, 0);
196  				wcscat_s(drive, dir);
197  				ListView_SetItemText(_hSelf, i, ++colIndex, drive);
198  			}
199  		}
200  	}
201  }
202  void VerticalFileSwitcherListView::setItemColor(BufferID bufferID)
203  {
204  	Buffer* buf = bufferID;
205  	LVITEM item{};
206  	item.mask = LVIF_PARAM;
<span onclick='openModal()' class='match'>207  	int nbItem = ListView_GetItemCount(_hSelf);
208  	for (int i = 0; i < nbItem; ++i)
209  	{
210  		item.iItem = i;
211  		ListView_GetItem(_hSelf, &item);
212  		TaskLstFnStatus* tlfs = reinterpret_cast<TaskLstFnStatus*>(item.lParam);
</span>213  		if (tlfs->_bufID == bufferID)
214  		{
215  			tlfs->_docColor = buf->getDocColorId();
216  			ListView_SetItem(_hSelf, &item);
217  		}
218  	}
219  	redraw();
220  }
221  generic_string VerticalFileSwitcherListView::getFullFilePath(size_t i) const
222  {
223  	size_t nbItem = ListView_GetItemCount(_hSelf);
224  	if (i > nbItem)
225  		return TEXT("");
226  	LVITEM item{};
227  	item.mask = LVIF_PARAM;
228  	item.iItem = static_cast<int32_t>(i);
229  	ListView_GetItem(_hSelf, &item);
230  	TaskLstFnStatus *tlfs = (TaskLstFnStatus *)item.lParam;
231  	return tlfs->_fn;
232  }
233  int VerticalFileSwitcherListView::closeItem(BufferID bufferID, int iView)
234  {
235  	int i = find(bufferID, iView);
236  	if (i != -1)
237  		remove(i);
238  	return i;
239  }
240  void VerticalFileSwitcherListView::activateItem(BufferID bufferID, int iView)
241  {
242  	int nbItem = ListView_GetItemCount(_hSelf);
243  	for (int i = 0; i < nbItem; ++i)
244  		ListView_SetItemState(_hSelf, i, 0, LVIS_FOCUSED|LVIS_SELECTED);
245  	_currentIndex = newItem(bufferID, iView);
246  	selectCurrentItem();
247  	ensureVisibleCurrentItem();
248  }
249  int VerticalFileSwitcherListView::add(BufferID bufferID, int iView)
250  {
251  	_currentIndex = ListView_GetItemCount(_hSelf);
252  	Buffer *buf = bufferID;
253  	const TCHAR *fileName = buf->getFileName();
254  	NppGUI& nppGUI = NppParameters::getInstance().getNppGUI();
255  	TaskLstFnStatus *tl = new TaskLstFnStatus(iView, 0, buf->getFullPathName(), 0, (void *)bufferID, -1);
256  	TCHAR fn[MAX_PATH] = { '\0' };
257  	wcscpy_s(fn, ::PathFindFileName(fileName));
258  	bool isExtColumn = !nppGUI._fileSwitcherWithoutExtColumn;
259  	bool isPathColumn = !nppGUI._fileSwitcherWithoutPathColumn;
260  	if (isExtColumn)
261  	{
262  		::PathRemoveExtension(fn);
263  	}
264  	LVITEM item{};
265  	item.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM | LVIF_GROUPID;
266  	item.pszText = fn;
267  	item.iItem = _currentIndex;
268  	item.iSubItem = 0;
269  	item.iImage = buf->isMonitoringOn()?3:(buf->isReadOnly()?2:(buf->isDirty()?1:0));
270  	item.lParam = reinterpret_cast<LPARAM>(tl);
271  	item.iGroupId = (iView == MAIN_VIEW) ? _groupID : _group2ID;
272  	ListView_InsertItem(_hSelf, &item);
273  	int colIndex = 0;
274  	if (isExtColumn)
275  	{
276  		ListView_SetItemText(_hSelf, _currentIndex, ++colIndex, ::PathFindExtension(fileName));
277  	}
278  	if (isPathColumn)
279  	{
280  		TCHAR dir[MAX_PATH] = { '\0' }, drive[MAX_PATH] = { '\0' };
281  		_wsplitpath_s(buf->getFullPathName(), drive, MAX_PATH, dir, MAX_PATH, NULL, 0, NULL, 0);
282  		wcscat_s(drive, dir);
283  		ListView_SetItemText(_hSelf, _currentIndex, ++colIndex, drive);
284  	}
285  	selectCurrentItem();
286  	return _currentIndex;
287  }
288  void VerticalFileSwitcherListView::remove(int index)
289  {
290  	LVITEM item{};
291  	item.mask = LVIF_PARAM;
292  	item.iItem = index;
293  	ListView_GetItem(_hSelf, &item);
294  	TaskLstFnStatus *tlfs = (TaskLstFnStatus *)item.lParam;
295  	delete tlfs;
296  	ListView_DeleteItem(_hSelf, index);
297  }
298  void VerticalFileSwitcherListView::removeAll()
299  {
300  	int nbItem = ListView_GetItemCount(_hSelf);
301  	for (int i = nbItem - 1; i >= 0 ; --i)
302  	{
303  		remove(i);
304  	}
305  	HWND colHeader = reinterpret_cast<HWND>(SendMessage(_hSelf, LVM_GETHEADER, 0, 0));
306  	int columnCount = static_cast<int32_t>(SendMessage(colHeader, HDM_GETITEMCOUNT, 0, 0));
307  	for (int i = 0; i < columnCount; ++i)
308  	{
309  		ListView_DeleteColumn(_hSelf, 0);
310  	}
311  }
312  int VerticalFileSwitcherListView::find(BufferID bufferID, int iView) const
313  {
314  	LVITEM item{};
315  	bool found = false;
316  	int nbItem = ListView_GetItemCount(_hSelf);
317  	int i = 0;
318  	for (; i < nbItem ; ++i)
319  	{
320  		item.mask = LVIF_PARAM;
321  		item.iItem = i;
322  		ListView_GetItem(_hSelf, &item);
323  		TaskLstFnStatus *tlfs = (TaskLstFnStatus *)item.lParam;
324  		if (tlfs->_bufID == bufferID && tlfs->_iView == iView)
325  		{
326  			found =  true;
327  			break;
328  		}
329  	}
330  	return (found?i:-1);	
331  }
332  void VerticalFileSwitcherListView::insertColumn(const TCHAR *name, int width, int index)
333  {
334  	LVCOLUMN lvColumn{};
335  	lvColumn.mask = LVCF_TEXT | LVCF_WIDTH;
336  	lvColumn.cx = width;
337  	lvColumn.pszText = (TCHAR *)name;
338  	ListView_InsertColumn(_hSelf, index, &lvColumn); 
339  }
340  void VerticalFileSwitcherListView::resizeColumns(int totalWidth)
341  {
342  	NppParameters& nppParams = NppParameters::getInstance();
343  	bool isExtColumn = !nppParams.getNppGUI()._fileSwitcherWithoutExtColumn;
344  	bool isPathColumn = !nppParams.getNppGUI()._fileSwitcherWithoutPathColumn;
345  	const int extWidthDyn = nppParams._dpiManager.scaleX(nppParams.getNppGUI()._fileSwitcherExtWidth);
346  	const int pathWidthDyn = nppParams._dpiManager.scaleX(nppParams.getNppGUI()._fileSwitcherPathWidth);
347  	int totalColWidthDynExceptName = 0;
348  	int colIndex = 0;
349  	if (isExtColumn)
350  	{
351  		totalColWidthDynExceptName += extWidthDyn;
352  		ListView_SetColumnWidth(_hSelf, ++colIndex, extWidthDyn);
353  	}
354  	if (isPathColumn)
355  	{
356  		totalColWidthDynExceptName += pathWidthDyn;
357  		ListView_SetColumnWidth(_hSelf, ++colIndex, pathWidthDyn);
358  	}
359  	const auto style = ::GetWindowLongPtr(_hSelf, GWL_STYLE);
360  	if ((style & WS_VSCROLL) == WS_VSCROLL)
361  	{
362  		totalColWidthDynExceptName += ::GetSystemMetrics(SM_CXVSCROLL);
363  	}
364  	ListView_SetColumnWidth(_hSelf, 0, totalWidth - totalColWidthDynExceptName);
365  }
366  std::vector<SwitcherFileInfo> VerticalFileSwitcherListView::getSelectedFiles(bool reverse) const
367  {
368  	std::vector<SwitcherFileInfo> files;
369  	LVITEM item{};
370  	int nbItem = ListView_GetItemCount(_hSelf);
371  	int i = 0;
372  	for (; i < nbItem ; ++i)
373  	{
374  		int isSelected = ListView_GetItemState(_hSelf, i, LVIS_SELECTED);
375  		bool isChosen = reverse?isSelected != LVIS_SELECTED:isSelected == LVIS_SELECTED;
376  		if (isChosen)
377  		{
378  			item.mask = LVIF_PARAM;
379  			item.iItem = i;
380  			ListView_GetItem(_hSelf, &item);
381  			TaskLstFnStatus *tlfs = (TaskLstFnStatus *)item.lParam;
382  			files.push_back(SwitcherFileInfo(static_cast<BufferID>(tlfs->_bufID), tlfs->_iView));
383  		}
384  	}
385  	return files;
386  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-test_mkldnn_pooling_layer.cpp</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-VerticalFileSwitcherListView.cpp</div>
                <div class="column column_space"><pre><code>215      const int channels = 2;
216      blob_bottom_->Reshape(num, channels, 6, 6);
217      for (int i = 0; i < 36 * num * channels; i += 36) {
218        blob_bottom_->mutable_cpu_data()[i +  0] = 35;
219        blob_bottom_->mutable_cpu_data()[i +  1] = 1;
</pre></code></div>
                <div class="column column_space"><pre><code>207  	int nbItem = ListView_GetItemCount(_hSelf);
208  	for (int i = 0; i < nbItem; ++i)
209  	{
210  		item.iItem = i;
211  		ListView_GetItem(_hSelf, &item);
212  		TaskLstFnStatus* tlfs = reinterpret_cast<TaskLstFnStatus*>(item.lParam);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    