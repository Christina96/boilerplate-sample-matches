
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 19.51219512195122%, Tokens: 12, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-optional_exception_safety_test.cc</h3>
            <pre><code>1  #include "absl/types/optional.h"
2  #include "absl/base/config.h"
3  #if !defined(ABSL_USES_STD_OPTIONAL) && defined(ABSL_HAVE_EXCEPTIONS)
4  #include "gtest/gtest.h"
5  #include "absl/base/internal/exception_safety_testing.h"
6  namespace absl {
7  ABSL_NAMESPACE_BEGIN
8  namespace {
9  using ::testing::AssertionFailure;
10  using ::testing::AssertionResult;
11  using ::testing::AssertionSuccess;
12  using ::testing::MakeExceptionSafetyTester;
13  using Thrower = testing::ThrowingValue<testing::TypeSpec::kEverythingThrows>;
14  using Optional = absl::optional<Thrower>;
15  using MoveThrower = testing::ThrowingValue<testing::TypeSpec::kNoThrowMove>;
16  using MoveOptional = absl::optional<MoveThrower>;
17  constexpr int kInitialInteger = 5;
18  constexpr int kUpdatedInteger = 10;
19  template <typename OptionalT>
20  bool ValueThrowsBadOptionalAccess(const OptionalT& optional) try {
21    return (static_cast<void>(optional.value()), false);
22  } catch (const absl::bad_optional_access&) {
23    return true;
24  }
25  template <typename OptionalT>
26  AssertionResult OptionalInvariants(OptionalT* optional_ptr) {
27    auto& optional = *optional_ptr;
28    if (optional.has_value() && ValueThrowsBadOptionalAccess(optional)) {
29      return AssertionFailure()
30             << "Optional with value should not throw bad_optional_access when "
31                "accessing the value.";
32    }
33    if (!optional.has_value() && !ValueThrowsBadOptionalAccess(optional)) {
34      return AssertionFailure()
35             << "Optional without a value should throw bad_optional_access when "
36                "accessing the value.";
37    }
38    optional.reset();
39    if (optional.has_value()) {
40      return AssertionFailure()
41             << "Optional should not contain a value after being reset.";
42    }
43    if (!ValueThrowsBadOptionalAccess(optional)) {
44      return AssertionFailure() << "Optional should throw bad_optional_access "
45                                   "when accessing the value after being reset.";
46    }
47    return AssertionSuccess();
48  }
49  template <typename OptionalT>
50  AssertionResult CheckDisengaged(OptionalT* optional_ptr) {
51    auto& optional = *optional_ptr;
52    if (optional.has_value()) {
53      return AssertionFailure()
54             << "Expected optional to not contain a value but a value was found.";
55    }
56    return AssertionSuccess();
57  }
58  template <typename OptionalT>
59  AssertionResult CheckEngaged(OptionalT* optional_ptr) {
60    auto& optional = *optional_ptr;
61    if (!optional.has_value()) {
62      return AssertionFailure()
63             << "Expected optional to contain a value but no value was found.";
64    }
65    return AssertionSuccess();
66  }
67  TEST(OptionalExceptionSafety, ThrowingConstructors) {
68    auto thrower_nonempty = Optional(Thrower(kInitialInteger));
69    testing::TestThrowingCtor<Optional>(thrower_nonempty);
70    auto integer_nonempty = absl::optional<int>(kInitialInteger);
71    testing::TestThrowingCtor<Optional>(integer_nonempty);
72    testing::TestThrowingCtor<Optional>(std::move(integer_nonempty));  
73    testing::TestThrowingCtor<Optional>(kInitialInteger);
74    using ThrowerVec = std::vector<Thrower, testing::ThrowingAllocator<Thrower>>;
75    testing::TestThrowingCtor<absl::optional<ThrowerVec>>(
76        absl::in_place,
77        std::initializer_list<Thrower>{Thrower(), Thrower(), Thrower()},
78        testing::ThrowingAllocator<Thrower>());
79  }
80  TEST(OptionalExceptionSafety, NothrowConstructors) {
81    testing::TestThrowingCtor<MoveOptional>(MoveOptional(kUpdatedInteger));
82  }
83  TEST(OptionalExceptionSafety, Emplace) {
84    auto disengaged_test = MakeExceptionSafetyTester().WithContracts(
85        OptionalInvariants<Optional>, CheckDisengaged<Optional>);
86    auto disengaged_test_empty = disengaged_test.WithInitialValue(Optional());
87    auto disengaged_test_nonempty =
88        disengaged_test.WithInitialValue(Optional(kInitialInteger));
89    auto emplace_thrower_directly = [](Optional* optional_ptr) {
90      optional_ptr->emplace(kUpdatedInteger);
91    };
92    EXPECT_TRUE(disengaged_test_empty.Test(emplace_thrower_directly));
93    EXPECT_TRUE(disengaged_test_nonempty.Test(emplace_thrower_directly));
94    auto emplace_thrower_copy = [](Optional* optional_ptr) {
<span onclick='openModal()' class='match'>95      auto thrower = Thrower(kUpdatedInteger, testing::nothrow_ctor);
96      optional_ptr->emplace(thrower);
97    };
98    EXPECT_TRUE(disengaged_test_empty.Test(emplace_thrower_copy));
99    EXPECT_TRUE(disengaged_test_nonempty.Test(emplace_thrower_copy));
100  }
101  TEST(OptionalExceptionSafety, EverythingThrowsSwap) {
102    auto test =
103        MakeExceptionSafetyTester().WithContracts(OptionalInvariants<Optional>);
104    auto disengaged_test_empty = test.WithInitialValue(Optional())
105                                     .WithContracts(CheckDisengaged<Optional>);
106    auto engaged_test_nonempty = test.WithInitialValue(Optional(kInitialInteger))
107                                     .WithContracts(CheckEngaged<Optional>);
108    auto swap_empty = [](Optional* optional_ptr) {
</span>109      auto empty = Optional();
110      optional_ptr->swap(empty);
111    };
112    EXPECT_TRUE(engaged_test_nonempty.Test(swap_empty));
113    auto swap_nonempty = [](Optional* optional_ptr) {
114      auto nonempty =
115          Optional(absl::in_place, kUpdatedInteger, testing::nothrow_ctor);
116      optional_ptr->swap(nonempty);
117    };
118    EXPECT_TRUE(disengaged_test_empty.Test(swap_nonempty));
119    EXPECT_TRUE(engaged_test_nonempty.Test(swap_nonempty));
120  }
121  TEST(OptionalExceptionSafety, NoThrowMoveSwap) {
122    {
123      auto empty = MoveOptional();
124      auto nonempty = MoveOptional(kInitialInteger);
125      EXPECT_TRUE(testing::TestNothrowOp([&]() { nonempty.swap(empty); }));
126    }
127    {
128      auto nonempty = MoveOptional(kUpdatedInteger);
129      auto empty = MoveOptional();
130      EXPECT_TRUE(testing::TestNothrowOp([&]() { empty.swap(nonempty); }));
131    }
132    {
133      auto nonempty_from = MoveOptional(kUpdatedInteger);
134      auto nonempty_to = MoveOptional(kInitialInteger);
135      EXPECT_TRUE(
136          testing::TestNothrowOp([&]() { nonempty_to.swap(nonempty_from); }));
137    }
138  }
139  TEST(OptionalExceptionSafety, CopyAssign) {
140    auto test =
141        MakeExceptionSafetyTester().WithContracts(OptionalInvariants<Optional>);
142    auto disengaged_test_empty = test.WithInitialValue(Optional())
143                                     .WithContracts(CheckDisengaged<Optional>);
144    auto engaged_test_nonempty = test.WithInitialValue(Optional(kInitialInteger))
145                                     .WithContracts(CheckEngaged<Optional>);
146    auto copyassign_nonempty = [](Optional* optional_ptr) {
147      auto nonempty =
148          Optional(absl::in_place, kUpdatedInteger, testing::nothrow_ctor);
149      *optional_ptr = nonempty;
150    };
151    EXPECT_TRUE(disengaged_test_empty.Test(copyassign_nonempty));
152    EXPECT_TRUE(engaged_test_nonempty.Test(copyassign_nonempty));
153    auto copyassign_thrower = [](Optional* optional_ptr) {
154      auto thrower = Thrower(kUpdatedInteger, testing::nothrow_ctor);
155      *optional_ptr = thrower;
156    };
157    EXPECT_TRUE(disengaged_test_empty.Test(copyassign_thrower));
158    EXPECT_TRUE(engaged_test_nonempty.Test(copyassign_thrower));
159  }
160  TEST(OptionalExceptionSafety, MoveAssign) {
161    auto test =
162        MakeExceptionSafetyTester().WithContracts(OptionalInvariants<Optional>);
163    auto disengaged_test_empty = test.WithInitialValue(Optional())
164                                     .WithContracts(CheckDisengaged<Optional>);
165    auto engaged_test_nonempty = test.WithInitialValue(Optional(kInitialInteger))
166                                     .WithContracts(CheckEngaged<Optional>);
167    auto moveassign_empty = [](Optional* optional_ptr) {
168      auto empty = Optional();
169      *optional_ptr = std::move(empty);
170    };
171    EXPECT_TRUE(engaged_test_nonempty.Test(moveassign_empty));
172    auto moveassign_nonempty = [](Optional* optional_ptr) {
173      auto nonempty =
174          Optional(absl::in_place, kUpdatedInteger, testing::nothrow_ctor);
175      *optional_ptr = std::move(nonempty);
176    };
177    EXPECT_TRUE(disengaged_test_empty.Test(moveassign_nonempty));
178    EXPECT_TRUE(engaged_test_nonempty.Test(moveassign_nonempty));
179    auto moveassign_thrower = [](Optional* optional_ptr) {
180      auto thrower = Thrower(kUpdatedInteger, testing::nothrow_ctor);
181      *optional_ptr = std::move(thrower);
182    };
183    EXPECT_TRUE(disengaged_test_empty.Test(moveassign_thrower));
184    EXPECT_TRUE(engaged_test_nonempty.Test(moveassign_thrower));
185  }
186  TEST(OptionalExceptionSafety, NothrowMoveAssign) {
187    {
188      auto empty = MoveOptional();
189      auto nonempty = MoveOptional(kInitialInteger);
190      EXPECT_TRUE(testing::TestNothrowOp([&]() { nonempty = std::move(empty); }));
191    }
192    {
193      auto nonempty = MoveOptional(kInitialInteger);
194      auto empty = MoveOptional();
195      EXPECT_TRUE(testing::TestNothrowOp([&]() { empty = std::move(nonempty); }));
196    }
197    {
198      auto nonempty_from = MoveOptional(kUpdatedInteger);
199      auto nonempty_to = MoveOptional(kInitialInteger);
200      EXPECT_TRUE(testing::TestNothrowOp(
201          [&]() { nonempty_to = std::move(nonempty_from); }));
202    }
203    {
204      auto thrower = MoveThrower(kUpdatedInteger);
205      auto empty = MoveOptional();
206      EXPECT_TRUE(testing::TestNothrowOp([&]() { empty = std::move(thrower); }));
207    }
208    {
209      auto thrower = MoveThrower(kUpdatedInteger);
210      auto nonempty = MoveOptional(kInitialInteger);
211      EXPECT_TRUE(
212          testing::TestNothrowOp([&]() { nonempty = std::move(thrower); }));
213    }
214  }
215  }  
216  ABSL_NAMESPACE_END
217  }  
218  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-receivable.cpp</h3>
            <pre><code>1  #include <nano/node/ipc/ipc_server.hpp>
2  #include <nano/rpc/rpc_request_processor.hpp>
3  #include <nano/rpc_test/common.hpp>
4  #include <nano/test_common/chains.hpp>
5  #include <nano/test_common/system.hpp>
6  #include <nano/test_common/testutil.hpp>
7  #include <gtest/gtest.h>
8  using namespace nano::test;
9  TEST (rpc, receivable)
10  {
11  	nano::test::system system;
12  	auto node = add_ipc_enabled_node (system);
13  	auto chain = nano::test::setup_chain (system, *node, 1);
14  	auto block1 = chain[0];
15  	ASSERT_TIMELY (5s, node->block_confirmed (block1->hash ()));
16  	auto const rpc_ctx = add_rpc (system, node);
17  	boost::property_tree::ptree request;
18  	request.put ("action", "receivable");
19  	request.put ("account", block1->link ().to_account ());
20  	auto response = wait_response (system, rpc_ctx, request);
21  	auto & blocks_node = response.get_child ("blocks");
22  	ASSERT_EQ (1, blocks_node.size ());
23  	nano::block_hash hash{ blocks_node.begin ()->second.get<std::string> ("") };
24  	ASSERT_EQ (block1->hash (), hash);
25  }
26  TEST (rpc, receivable_sorting)
27  {
28  	nano::test::system system;
29  	auto node = add_ipc_enabled_node (system);
30  	auto chain = nano::test::setup_chain (system, *node, 1);
31  	auto block1 = chain[0];
32  	ASSERT_TIMELY (5s, node->block_confirmed (block1->hash ()));
33  	auto const rpc_ctx = add_rpc (system, node);
34  	boost::property_tree::ptree request;
35  	request.put ("action", "receivable");
36  	request.put ("account", block1->link ().to_account ());
37  	request.put ("sorting", "true"); 
38  	auto response = wait_response (system, rpc_ctx, request);
39  	auto & blocks_node = response.get_child ("blocks");
40  	ASSERT_EQ (1, blocks_node.size ());
41  	nano::block_hash hash{ blocks_node.begin ()->first };
42  	ASSERT_EQ (block1->hash (), hash);
43  	std::string amount{ blocks_node.begin ()->second.get<std::string> ("") };
44  	ASSERT_EQ ("1", amount);
45  }
46  TEST (rpc, receivable_threshold_sufficient)
47  {
48  	nano::test::system system;
49  	auto node = add_ipc_enabled_node (system);
50  	auto chain = nano::test::setup_chain (system, *node, 1);
51  	auto block1 = chain[0];
52  	ASSERT_TIMELY (5s, node->block_confirmed (block1->hash ()));
53  	auto const rpc_ctx = add_rpc (system, node);
54  	boost::property_tree::ptree request;
55  	request.put ("action", "receivable");
56  	request.put ("account", block1->link ().to_account ());
57  	request.put ("threshold", "1"); 
58  	auto response = wait_response (system, rpc_ctx, request);
59  	auto & blocks_node = response.get_child ("blocks");
60  	ASSERT_EQ (1, blocks_node.size ());
61  	std::unordered_map<nano::block_hash, nano::uint128_union> blocks;
62  	for (auto i (blocks_node.begin ()), j (blocks_node.end ()); i != j; ++i)
63  	{
64  		nano::block_hash hash;
65  		hash.decode_hex (i->first);
66  		nano::uint128_union amount;
67  		amount.decode_dec (i->second.get<std::string> (""));
68  		blocks[hash] = amount;
69  		auto source = i->second.get_optional<std::string> ("source");
70  		ASSERT_FALSE (source.is_initialized ());
<span onclick='openModal()' class='match'>71  		auto min_version = i->second.get_optional<uint8_t> ("min_version");
72  		ASSERT_FALSE (min_version.is_initialized ());
73  	}
74  	ASSERT_EQ (blocks[block1->hash ()], 1);
75  }
76  TEST (rpc, receivable_threshold_insufficient)
77  {
78  	nano::test::system system;
79  	auto node = add_ipc_enabled_node (system);
80  	auto chain = nano::test::setup_chain (system, *node, 1);
81  	auto block1 = chain[0];
82  	ASSERT_TIMELY (5s, node->block_confirmed (block1->hash ()));
83  	auto const rpc_ctx = add_rpc (system, node);
</span>84  	boost::property_tree::ptree request;
85  	request.put ("action", "receivable");
86  	request.put ("account", block1->link ().to_account ());
87  	request.put ("threshold", "2"); 
88  	auto response = wait_response (system, rpc_ctx, request, 10s);
89  	auto & blocks_node = response.get_child ("blocks");
90  	ASSERT_EQ (0, blocks_node.size ());
91  }
92  TEST (rpc, receivable_source_min_version)
93  {
94  	nano::test::system system;
95  	auto node = add_ipc_enabled_node (system);
96  	auto chain = nano::test::setup_chain (system, *node, 1);
97  	auto block1 = chain[0];
98  	ASSERT_TIMELY (5s, node->block_confirmed (block1->hash ()));
99  	auto const rpc_ctx = add_rpc (system, node);
100  	boost::property_tree::ptree request;
101  	request.put ("action", "receivable");
102  	request.put ("account", block1->link ().to_account ());
103  	request.put ("source", "true");
104  	request.put ("min_version", "true");
105  	auto response (wait_response (system, rpc_ctx, request));
106  	auto & blocks_node (response.get_child ("blocks"));
107  	ASSERT_EQ (1, blocks_node.size ());
108  	std::unordered_map<nano::block_hash, nano::uint128_union> amounts;
109  	std::unordered_map<nano::block_hash, nano::account> sources;
110  	for (auto i (blocks_node.begin ()), j (blocks_node.end ()); i != j; ++i)
111  	{
112  		nano::block_hash hash;
113  		hash.decode_hex (i->first);
114  		amounts[hash].decode_dec (i->second.get<std::string> ("amount"));
115  		sources[hash].decode_account (i->second.get<std::string> ("source"));
116  		ASSERT_EQ (i->second.get<uint8_t> ("min_version"), 0);
117  	}
118  	ASSERT_EQ (amounts[block1->hash ()], 1);
119  	ASSERT_EQ (sources[block1->hash ()], nano::dev::genesis_key.pub);
120  }
121  TEST (rpc, receivable_unconfirmed)
122  {
123  	nano::test::system system;
124  	nano::node_config config;
125  	config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
126  	auto node = add_ipc_enabled_node (system, config);
127  	auto chain = nano::test::setup_chain (system, *node, 1, nano::dev::genesis_key, false);
128  	auto block1 = chain[0];
129  	auto const rpc_ctx = add_rpc (system, node);
130  	boost::property_tree::ptree request;
131  	request.put ("action", "receivable");
132  	request.put ("account", block1->link ().to_account ());
133  	ASSERT_TRUE (check_block_response_count (system, rpc_ctx, request, 0));
134  	request.put ("include_only_confirmed", "true");
135  	ASSERT_TRUE (check_block_response_count (system, rpc_ctx, request, 0));
136  	request.put ("include_only_confirmed", "false");
137  	ASSERT_TRUE (check_block_response_count (system, rpc_ctx, request, 1));
138  	nano::test::confirm (*node, { block1->hash () });
139  	ASSERT_TIMELY (5s, !node->active.active (*block1));
140  	request.put ("include_only_confirmed", "true");
141  	ASSERT_TRUE (check_block_response_count (system, rpc_ctx, request, 1));
142  }
143  TEST (rpc, receivable_offset_and_sorting)
144  {
145  	nano::test::system system;
146  	auto node = add_ipc_enabled_node (system);
147  	nano::keypair key1;
148  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
149  	auto block1 = system.wallet (0)->send_action (nano::dev::genesis_key.pub, key1.pub, 200);
150  	auto block2 = system.wallet (0)->send_action (nano::dev::genesis_key.pub, key1.pub, 100);
151  	auto block3 = system.wallet (0)->send_action (nano::dev::genesis_key.pub, key1.pub, 400);
152  	auto block4 = system.wallet (0)->send_action (nano::dev::genesis_key.pub, key1.pub, 300);
153  	auto block5 = system.wallet (0)->send_action (nano::dev::genesis_key.pub, key1.pub, 300);
154  	auto block6 = system.wallet (0)->send_action (nano::dev::genesis_key.pub, key1.pub, 300);
155  	ASSERT_TIMELY (5s, node->ledger.account_receivable (node->store.tx_begin_read (), key1.pub, true) == 1600);
156  	nano::confirmation_height_info confirmation_height_info;
157  	ASSERT_FALSE (node->store.confirmation_height.get (node->store.tx_begin_read (), nano::dev::genesis->account (), confirmation_height_info));
158  	ASSERT_EQ (confirmation_height_info.height, 7);
159  	ASSERT_EQ (confirmation_height_info.frontier, block6->hash ());
160  	auto hash_exists = [] (boost::property_tree::ptree & node, bool match_first, nano::block_hash hash) {
161  		std::stringstream ss;
162  		boost::property_tree::json_parser::write_json (ss, node);
163  		for (auto itr = node.begin (); itr != node.end (); ++itr)
164  		{
165  			std::string possible_match = match_first ? itr->first : itr->second.get<std::string> ("");
166  			if (possible_match == hash.to_string ())
167  			{
168  				return true;
169  			}
170  		}
171  		return false;
172  	};
173  	auto const rpc_ctx = add_rpc (system, node);
174  	boost::property_tree::ptree request;
175  	request.put ("action", "receivable");
176  	request.put ("account", key1.pub.to_account ());
177  	request.put ("offset", "0");
178  	request.put ("sorting", "false");
179  	{
180  		auto response (wait_response (system, rpc_ctx, request));
181  		auto & blocks_node (response.get_child ("blocks"));
182  		ASSERT_EQ (6, blocks_node.size ());
183  		ASSERT_TRUE (hash_exists (blocks_node, false, block1->hash ()));
184  		ASSERT_TRUE (hash_exists (blocks_node, false, block2->hash ()));
185  		ASSERT_TRUE (hash_exists (blocks_node, false, block3->hash ()));
186  		ASSERT_TRUE (hash_exists (blocks_node, false, block4->hash ()));
187  		ASSERT_TRUE (hash_exists (blocks_node, false, block5->hash ()));
188  		ASSERT_TRUE (hash_exists (blocks_node, false, block6->hash ()));
189  	}
190  	request.put ("offset", "4");
191  	{
192  		auto response (wait_response (system, rpc_ctx, request));
193  		auto & blocks_node (response.get_child ("blocks"));
194  		ASSERT_EQ (2, blocks_node.size ());
195  	}
196  	request.put ("count", "2");
197  	request.put ("offset", "2");
198  	{
199  		auto response (wait_response (system, rpc_ctx, request));
200  		auto & blocks_node (response.get_child ("blocks"));
201  		ASSERT_EQ (2, blocks_node.size ());
202  	}
203  	request.put ("sorting", "true");
204  	request.put ("count", "5");
205  	request.put ("offset", "0");
206  	{
207  		auto response (wait_response (system, rpc_ctx, request));
208  		auto & blocks_node (response.get_child ("blocks"));
209  		ASSERT_EQ (5, blocks_node.size ());
210  		auto itr = blocks_node.begin ();
211  		ASSERT_EQ (block3->hash (), nano::block_hash{ itr->first });
212  		ASSERT_EQ ("400", itr->second.get<std::string> (""));
213  		++itr;
214  		ASSERT_EQ ("300", itr->second.get<std::string> (""));
215  		++itr;
216  		ASSERT_EQ ("300", itr->second.get<std::string> (""));
217  		++itr;
218  		ASSERT_EQ ("300", itr->second.get<std::string> (""));
219  		++itr;
220  		ASSERT_EQ (block1->hash (), nano::block_hash{ itr->first });
221  		ASSERT_EQ ("200", itr->second.get<std::string> (""));
222  		ASSERT_TRUE (hash_exists (blocks_node, true, block4->hash ()));
223  		ASSERT_TRUE (hash_exists (blocks_node, true, block5->hash ()));
224  		ASSERT_TRUE (hash_exists (blocks_node, true, block6->hash ()));
225  	}
226  	request.put ("count", "3");
227  	request.put ("offset", "3");
228  	{
229  		auto response (wait_response (system, rpc_ctx, request));
230  		auto & blocks_node (response.get_child ("blocks"));
231  		ASSERT_EQ (3, blocks_node.size ());
232  		auto itr = blocks_node.begin ();
233  		ASSERT_EQ ("300", itr->second.get<std::string> (""));
234  		++itr;
235  		ASSERT_EQ (block1->hash (), nano::block_hash{ itr->first });
236  		ASSERT_EQ ("200", itr->second.get<std::string> (""));
237  		++itr;
238  		ASSERT_EQ (block2->hash (), nano::block_hash{ itr->first });
239  		ASSERT_EQ ("100", itr->second.get<std::string> (""));
240  	}
241  	request.put ("source", "true");
242  	request.put ("min_version", "true");
243  	request.put ("count", "3");
244  	request.put ("offset", "2");
245  	{
246  		auto response (wait_response (system, rpc_ctx, request));
247  		auto & blocks_node (response.get_child ("blocks"));
248  		ASSERT_EQ (3, blocks_node.size ());
249  		auto itr = blocks_node.begin ();
250  		ASSERT_EQ ("300", itr->second.get<std::string> ("amount"));
251  		++itr;
252  		ASSERT_EQ ("300", itr->second.get<std::string> ("amount"));
253  		++itr;
254  		ASSERT_EQ (block1->hash (), nano::block_hash{ itr->first });
255  		ASSERT_EQ ("200", itr->second.get<std::string> ("amount"));
256  	}
257  }
258  TEST (rpc, receivable_burn)
259  {
260  	nano::test::system system;
261  	auto node = add_ipc_enabled_node (system);
262  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
263  	auto block1 (system.wallet (0)->send_action (nano::dev::genesis_key.pub, nano::dev::constants.burn_account, 100));
264  	auto const rpc_ctx = add_rpc (system, node);
265  	ASSERT_TIMELY (5s, node->block_confirmed (block1->hash ()));
266  	boost::property_tree::ptree request;
267  	request.put ("action", "receivable");
268  	request.put ("account", nano::dev::constants.burn_account.to_account ());
269  	request.put ("count", "100");
270  	{
271  		auto response (wait_response (system, rpc_ctx, request));
272  		auto & blocks_node (response.get_child ("blocks"));
273  		ASSERT_EQ (1, blocks_node.size ());
274  		nano::block_hash hash (blocks_node.begin ()->second.get<std::string> (""));
275  		ASSERT_EQ (block1->hash (), hash);
276  	}
277  }
278  TEST (rpc, search_receivable)
279  {
280  	nano::test::system system;
281  	auto node = add_ipc_enabled_node (system);
282  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
283  	auto wallet (node->wallets.items.begin ()->first.to_string ());
284  	auto latest (node->latest (nano::dev::genesis_key.pub));
285  	nano::block_builder builder;
286  	auto block = builder
287  				 .send ()
288  				 .previous (latest)
289  				 .destination (nano::dev::genesis_key.pub)
290  				 .balance (nano::dev::constants.genesis_amount - node->config.receive_minimum.number ())
291  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
292  				 .work (*node->work_generate_blocking (latest))
293  				 .build ();
294  	{
295  		auto transaction (node->store.tx_begin_write ());
296  		ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *block).code);
297  	}
298  	auto const rpc_ctx = add_rpc (system, node);
299  	boost::property_tree::ptree request;
300  	request.put ("action", "search_receivable");
301  	request.put ("wallet", wallet);
302  	auto response (wait_response (system, rpc_ctx, request));
303  	ASSERT_TIMELY (10s, node->balance (nano::dev::genesis_key.pub) == nano::dev::constants.genesis_amount);
304  }
305  TEST (rpc, accounts_pending_deprecated)
306  {
307  	nano::test::system system;
308  	auto node = add_ipc_enabled_node (system);
309  	auto const rpc_ctx = add_rpc (system, node);
310  	boost::property_tree::ptree request;
311  	boost::property_tree::ptree child;
312  	boost::property_tree::ptree accounts;
313  	child.put ("", nano::dev::genesis_key.pub.to_account ());
314  	accounts.push_back (std::make_pair ("", child));
315  	request.add_child ("accounts", accounts);
316  	request.put ("action", "accounts_pending");
317  	auto response (wait_response (system, rpc_ctx, request));
318  	ASSERT_EQ ("1", response.get<std::string> ("deprecated"));
319  }
320  TEST (rpc, accounts_receivable_blocks)
321  {
322  	nano::test::system system;
323  	auto node = add_ipc_enabled_node (system);
324  	auto chain = nano::test::setup_chain (system, *node, 1);
325  	auto block1 = chain[0];
326  	ASSERT_TIMELY (5s, node->block_confirmed (block1->hash ()));
327  	auto const rpc_ctx = add_rpc (system, node);
328  	boost::property_tree::ptree request;
329  	request.put ("action", "accounts_receivable");
330  	boost::property_tree::ptree entry;
331  	boost::property_tree::ptree peers_l;
332  	entry.put ("", block1->link ().to_account ());
333  	peers_l.push_back (std::make_pair ("", entry));
334  	request.add_child ("accounts", peers_l);
335  	auto response = wait_response (system, rpc_ctx, request);
336  	for (auto & blocks : response.get_child ("blocks"))
337  	{
338  		std::string account_text{ blocks.first };
339  		ASSERT_EQ (block1->link ().to_account (), account_text);
340  		nano::block_hash hash1{ blocks.second.begin ()->second.get<std::string> ("") };
341  		ASSERT_EQ (block1->hash (), hash1);
342  	}
343  }
344  TEST (rpc, accounts_receivable_sorting)
345  {
346  	nano::test::system system;
347  	auto node = add_ipc_enabled_node (system);
348  	auto chain = nano::test::setup_chain (system, *node, 1);
349  	auto block1 = chain[0];
350  	ASSERT_TIMELY (5s, node->block_confirmed (block1->hash ()));
351  	auto const rpc_ctx = add_rpc (system, node);
352  	boost::property_tree::ptree request;
353  	request.put ("action", "accounts_receivable");
354  	boost::property_tree::ptree entry;
355  	boost::property_tree::ptree peers_l;
356  	entry.put ("", block1->link ().to_account ());
357  	peers_l.push_back (std::make_pair ("", entry));
358  	request.add_child ("accounts", peers_l);
359  	request.put ("sorting", "true"); 
360  	auto response = wait_response (system, rpc_ctx, request);
361  	for (auto & blocks : response.get_child ("blocks"))
362  	{
363  		std::string account_text{ blocks.first };
364  		ASSERT_EQ (block1->link ().to_account (), account_text);
365  		nano::block_hash hash1{ blocks.second.begin ()->first };
366  		ASSERT_EQ (block1->hash (), hash1);
367  		std::string amount{ blocks.second.begin ()->second.get<std::string> ("") };
368  		ASSERT_EQ ("1", amount);
369  	}
370  }
371  TEST (rpc, accounts_receivable_threshold)
372  {
373  	nano::test::system system;
374  	auto node = add_ipc_enabled_node (system);
375  	auto chain = nano::test::setup_chain (system, *node, 1);
376  	auto block1 = chain[0];
377  	ASSERT_TIMELY (5s, node->block_confirmed (block1->hash ()));
378  	auto const rpc_ctx = add_rpc (system, node);
379  	boost::property_tree::ptree request;
380  	request.put ("action", "accounts_receivable");
381  	boost::property_tree::ptree entry;
382  	boost::property_tree::ptree peers_l;
383  	entry.put ("", block1->link ().to_account ());
384  	peers_l.push_back (std::make_pair ("", entry));
385  	request.add_child ("accounts", peers_l);
386  	request.put ("threshold", "1"); 
387  	auto response = wait_response (system, rpc_ctx, request);
388  	std::unordered_map<nano::block_hash, nano::uint128_union> blocks;
389  	for (auto & pending : response.get_child ("blocks"))
390  	{
391  		std::string account_text{ pending.first };
392  		ASSERT_EQ (block1->link ().to_account (), account_text);
393  		for (auto i (pending.second.begin ()), j (pending.second.end ()); i != j; ++i)
394  		{
395  			nano::block_hash hash;
396  			hash.decode_hex (i->first);
397  			nano::uint128_union amount;
398  			amount.decode_dec (i->second.get<std::string> (""));
399  			blocks[hash] = amount;
400  			boost::optional<std::string> source{ i->second.get_optional<std::string> ("source") };
401  			ASSERT_FALSE (source.is_initialized ());
402  		}
403  	}
404  	ASSERT_EQ (blocks[block1->hash ()], 1);
405  }
406  TEST (rpc, accounts_receivable_source)
407  {
408  	nano::test::system system;
409  	auto node = add_ipc_enabled_node (system);
410  	auto chain = nano::test::setup_chain (system, *node, 1, nano::dev::genesis_key);
411  	auto block1 = chain[0];
412  	auto const rpc_ctx = add_rpc (system, node);
413  	boost::property_tree::ptree request;
414  	request.put ("action", "accounts_receivable");
415  	boost::property_tree::ptree entry;
416  	boost::property_tree::ptree peers_l;
417  	entry.put ("", block1->link ().to_account ());
418  	peers_l.push_back (std::make_pair ("", entry));
419  	request.add_child ("accounts", peers_l);
420  	request.put ("source", "true");
421  	{
422  		auto response (wait_response (system, rpc_ctx, request));
423  		std::unordered_map<nano::block_hash, nano::uint128_union> amounts;
424  		std::unordered_map<nano::block_hash, nano::account> sources;
425  		for (auto & pending : response.get_child ("blocks"))
426  		{
427  			std::string account_text (pending.first);
428  			ASSERT_EQ (block1->link ().to_account (), account_text);
429  			for (auto i (pending.second.begin ()), j (pending.second.end ()); i != j; ++i)
430  			{
431  				nano::block_hash hash;
432  				hash.decode_hex (i->first);
433  				amounts[hash].decode_dec (i->second.get<std::string> ("amount"));
434  				sources[hash].decode_account (i->second.get<std::string> ("source"));
435  			}
436  		}
437  		ASSERT_EQ (amounts[block1->hash ()], 1);
438  		ASSERT_EQ (sources[block1->hash ()], nano::dev::genesis_key.pub);
439  	}
440  }
441  TEST (rpc, accounts_receivable_confirmed)
442  {
443  	nano::test::system system;
444  	nano::node_config config;
445  	config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
446  	auto node = add_ipc_enabled_node (system, config);
447  	auto chain = nano::test::setup_chain (system, *node, 1, nano::dev::genesis_key, false);
448  	auto block1 = chain[0];
449  	ASSERT_TIMELY (5s, !node->active.active (*block1));
450  	auto const rpc_ctx = add_rpc (system, node);
451  	boost::property_tree::ptree request;
452  	request.put ("action", "accounts_receivable");
453  	boost::property_tree::ptree entry;
454  	boost::property_tree::ptree peers_l;
455  	entry.put ("", block1->link ().to_account ());
456  	peers_l.push_back (std::make_pair ("", entry));
457  	request.add_child ("accounts", peers_l);
458  	ASSERT_TRUE (check_block_response_count (system, rpc_ctx, request, 0));
459  	request.put ("include_only_confirmed", "true");
460  	ASSERT_TRUE (check_block_response_count (system, rpc_ctx, request, 0));
461  	request.put ("include_only_confirmed", "false");
462  	ASSERT_TRUE (check_block_response_count (system, rpc_ctx, request, 1));
463  	nano::test::confirm (*node, { block1->hash () });
464  	ASSERT_TIMELY (5s, !node->active.active (*block1));
465  	request.put ("include_only_confirmed", "true");
466  	ASSERT_TRUE (check_block_response_count (system, rpc_ctx, request, 1));
467  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-optional_exception_safety_test.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-receivable.cpp</div>
                </div>
                <div class="column column_space"><pre><code>95      auto thrower = Thrower(kUpdatedInteger, testing::nothrow_ctor);
96      optional_ptr->emplace(thrower);
97    };
98    EXPECT_TRUE(disengaged_test_empty.Test(emplace_thrower_copy));
99    EXPECT_TRUE(disengaged_test_nonempty.Test(emplace_thrower_copy));
100  }
101  TEST(OptionalExceptionSafety, EverythingThrowsSwap) {
102    auto test =
103        MakeExceptionSafetyTester().WithContracts(OptionalInvariants<Optional>);
104    auto disengaged_test_empty = test.WithInitialValue(Optional())
105                                     .WithContracts(CheckDisengaged<Optional>);
106    auto engaged_test_nonempty = test.WithInitialValue(Optional(kInitialInteger))
107                                     .WithContracts(CheckEngaged<Optional>);
108    auto swap_empty = [](Optional* optional_ptr) {
</pre></code></div>
                <div class="column column_space"><pre><code>71  		auto min_version = i->second.get_optional<uint8_t> ("min_version");
72  		ASSERT_FALSE (min_version.is_initialized ());
73  	}
74  	ASSERT_EQ (blocks[block1->hash ()], 1);
75  }
76  TEST (rpc, receivable_threshold_insufficient)
77  {
78  	nano::test::system system;
79  	auto node = add_ipc_enabled_node (system);
80  	auto chain = nano::test::setup_chain (system, *node, 1);
81  	auto block1 = chain[0];
82  	ASSERT_TIMELY (5s, node->block_confirmed (block1->hash ()));
83  	auto const rpc_ctx = add_rpc (system, node);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    