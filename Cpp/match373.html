<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for cs-module.cpp &amp; rib-module.cpp</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for cs-module.cpp &amp; rib-module.cpp
      </h3>
<h1 align="center">
        11.4%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>cs-module.cpp (20.382166%)<th>rib-module.cpp (7.960199%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(41-51)<td><a href="#" name="0">(50-60)</a><td align="center"><font color="#ff0000">17</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(130-140)<td><a href="#" name="1">(302-314)</a><td align="center"><font color="#e10000">15</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>cs-module.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
/*
 * Copyright (c) 2014-2020,  Regents of the University of California,
 *                           Arizona Board of Regents,
 *                           Colorado State University,
 *                           University Pierre &amp; Marie Curie, Sorbonne University,
 *                           Washington University in St. Louis,
 *                           Beijing Institute of Technology,
 *                           The University of Memphis.
 *
 * This file is part of NFD (Named Data Networking Forwarding Daemon).
 * See AUTHORS.md for complete list of NFD authors and contributors.
 *
 * NFD is free software: you can redistribute it and/or modify it under the terms
 * of the GNU General Public License as published by the Free Software Foundation,
 * either version 3 of the License, or (at your option) any later version.
 *
 * NFD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
 * PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * NFD, e.g., in COPYING.md file.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */

#include "cs-module.hpp"
#include "format-helpers.hpp"

#include &lt;ndn-cxx/util/indented-stream.hpp&gt;

namespace nfd {
namespace tools {
namespace nfdc {

void
CsModule::registerCommands(CommandParser&amp; parser)
{
<a name="0"></a>  CommandDefinition defCsConfig("cs", "config");
  defCsConfig
    .setTitle("change CS configuration")
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    .addArg("capacity", ArgValueType::UNSIGNED, Required::NO, Positional::NO)
    .addArg("admit", ArgValueType::BOOLEAN, Required::NO, Positional::NO)
    .addArg("serve", ArgValueType::BOOLEAN, Required::NO, Positional::NO);
  parser.addCommand(defCsConfig, &amp;CsModule::config);

  CommandDefinition defCsErase("cs", "erase");
  defCsErase
    .setTitle("erase cached Data")
    .addArg("prefix", ArgValueType::NAME, Required::YES, Positional::YES)
    .addArg("count", ArgValueType::UNSIGNED, Required::NO, Positional::NO);
  parser.addCommand(defCsErase, &amp;CsModule::erase);</b></font>
}

void
CsModule::config(ExecuteContext&amp; ctx)
{
  using boost::logic::indeterminate;

  auto capacity = ctx.args.getOptional&lt;uint64_t&gt;("capacity");
  auto enableAdmit = ctx.args.getTribool("admit");
  auto enableServe = ctx.args.getTribool("serve");

  ControlParameters p;
  if (capacity) {
    p.setCapacity(*capacity);
  }
  if (!indeterminate(enableAdmit)) {
    p.setFlagBit(ndn::nfd::BIT_CS_ENABLE_ADMIT, bool(enableAdmit));
  }
  if (!indeterminate(enableServe)) {
    p.setFlagBit(ndn::nfd::BIT_CS_ENABLE_SERVE, bool(enableServe));
  }

  ctx.controller.start&lt;ndn::nfd::CsConfigCommand&gt;(p,
    [&amp;] (const ControlParameters&amp; resp) {
      text::ItemAttributes ia;
      ctx.out &lt;&lt; "cs-config-updated "
              &lt;&lt; ia("capacity") &lt;&lt; resp.getCapacity()
              &lt;&lt; ia("admit") &lt;&lt; text::OnOff{resp.getFlagBit(ndn::nfd::BIT_CS_ENABLE_ADMIT)}
              &lt;&lt; ia("serve") &lt;&lt; text::OnOff{resp.getFlagBit(ndn::nfd::BIT_CS_ENABLE_SERVE)}
              &lt;&lt; '\n';
    },
    ctx.makeCommandFailureHandler("updating CS config"),
    ctx.makeCommandOptions());

  ctx.face.processEvents();
}

void
CsModule::erase(ExecuteContext&amp; ctx)
{
  auto prefix = ctx.args.get&lt;Name&gt;("prefix");
  auto count = ctx.args.getOptional&lt;uint64_t&gt;("count");

  uint64_t numErased = 0;
  bool wasLimited = false;
  bool wasSuccessful = true;

  ControlParameters params;
  params.setName(prefix);

  // The cs/erase command can have a limit on the number of CS entries erased in a single operation.
  // Therefore, we may need to run cs/erase multiple times to achieve the desired number of erases.
  do {
    if (count) {
      params.setCount(*count - numErased);
    }

    wasSuccessful = false;

    ctx.controller.start&lt;ndn::nfd::CsEraseCommand&gt;(
      params,
      [&amp;] (const ControlParameters&amp; resp) {
        wasSuccessful = true;
        numErased += resp.getCount();
        wasLimited = resp.hasCapacity();
      },
      ctx.makeCommandFailureHandler("erasing cached Data"),
      ctx.makeCommandOptions());

    ctx.face.processEvents();
  } while (wasSuccessful &amp;&amp; wasLimited);

  if (wasSuccessful) {
    text::ItemAttributes ia;
    ctx.out &lt;&lt; "cs-erased "
<a name="1"></a>            &lt;&lt; ia("prefix") &lt;&lt; prefix
            &lt;&lt; ia("count") &lt;&lt; numErased
            &lt;&lt; '\n';
<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  }
}

void
CsModule::fetchStatus(Controller&amp; controller,
                      const std::function&lt;void()&gt;&amp; onSuccess,
                      const Controller::DatasetFailCallback&amp; onFailure,
                      const CommandOptions&amp; options)
{
  controller.fetch&lt;ndn::nfd::CsInfoDataset&gt;(
    [this, onSuccess] (const CsInfo&amp; result) {</b></font>
      m_status = result;
      onSuccess();
    },
    onFailure, options);
}

void
CsModule::formatStatusXml(std::ostream&amp; os) const
{
  formatItemXml(os, m_status);
}

void
CsModule::formatItemXml(std::ostream&amp; os, const CsInfo&amp; item)
{
  os &lt;&lt; "&lt;cs&gt;";
  os &lt;&lt; "&lt;capacity&gt;" &lt;&lt; item.getCapacity() &lt;&lt; "&lt;/capacity&gt;";
  os &lt;&lt; xml::Flag{"admitEnabled", item.getEnableAdmit()};
  os &lt;&lt; xml::Flag{"serveEnabled", item.getEnableServe()};
  os &lt;&lt; "&lt;nEntries&gt;" &lt;&lt; item.getNEntries() &lt;&lt; "&lt;/nEntries&gt;";
  os &lt;&lt; "&lt;nHits&gt;" &lt;&lt; item.getNHits() &lt;&lt; "&lt;/nHits&gt;";
  os &lt;&lt; "&lt;nMisses&gt;" &lt;&lt; item.getNMisses() &lt;&lt; "&lt;/nMisses&gt;";
  os &lt;&lt; "&lt;/cs&gt;";
}

void
CsModule::formatStatusText(std::ostream&amp; os) const
{
  os &lt;&lt; "CS information:\n";
  ndn::util::IndentedStream indented(os, "  ");
  formatItemText(indented, m_status);
}

void
CsModule::formatItemText(std::ostream&amp; os, const CsInfo&amp; item)
{
  text::ItemAttributes ia(true, 8);
  os &lt;&lt; ia("capacity") &lt;&lt; item.getCapacity()
     &lt;&lt; ia("admit") &lt;&lt; text::OnOff{item.getEnableAdmit()}
     &lt;&lt; ia("serve") &lt;&lt; text::OnOff{item.getEnableServe()}
     &lt;&lt; ia("nEntries") &lt;&lt; item.getNEntries()
     &lt;&lt; ia("nHits") &lt;&lt; item.getNHits()
     &lt;&lt; ia("nMisses") &lt;&lt; item.getNMisses()
     &lt;&lt; ia.end();
}

} // namespace nfdc
} // namespace tools
} // namespace nfd
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>rib-module.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
/*
 * Copyright (c) 2014-2020,  Regents of the University of California,
 *                           Arizona Board of Regents,
 *                           Colorado State University,
 *                           University Pierre &amp; Marie Curie, Sorbonne University,
 *                           Washington University in St. Louis,
 *                           Beijing Institute of Technology,
 *                           The University of Memphis.
 *
 * This file is part of NFD (Named Data Networking Forwarding Daemon).
 * See AUTHORS.md for complete list of NFD authors and contributors.
 *
 * NFD is free software: you can redistribute it and/or modify it under the terms
 * of the GNU General Public License as published by the Free Software Foundation,
 * either version 3 of the License, or (at your option) any later version.
 *
 * NFD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
 * PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * NFD, e.g., in COPYING.md file.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */

#include "rib-module.hpp"
#include "canonizer.hpp"
#include "face-module.hpp"
#include "find-face.hpp"
#include "format-helpers.hpp"

namespace nfd {
namespace tools {
namespace nfdc {

void
RibModule::registerCommands(CommandParser&amp; parser)
{
  CommandDefinition defRouteList("route", "list");
  defRouteList
    .setTitle("print RIB routes")
    .addArg("nexthop", ArgValueType::FACE_ID_OR_URI, Required::NO, Positional::YES)
    .addArg("origin", ArgValueType::ROUTE_ORIGIN, Required::NO, Positional::NO);
  parser.addCommand(defRouteList, &amp;RibModule::list);
  parser.addAlias("route", "list", "");

<a name="0"></a>  CommandDefinition defRouteShow("route", "show");
  defRouteShow
    .setTitle("show routes toward a prefix")
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    .addArg("prefix", ArgValueType::NAME, Required::YES, Positional::YES);
  parser.addCommand(defRouteShow, &amp;RibModule::show);

  CommandDefinition defRouteAdd("route", "add");
  defRouteAdd
    .setTitle("add a route")
    .addArg("prefix", ArgValueType::NAME, Required::YES, Positional::YES)
    .addArg("nexthop", ArgValueType::FACE_ID_OR_URI, Required::YES, Positional::YES)
    .addArg("origin", ArgValueType::ROUTE_ORIGIN, Required::NO, Positional::NO)
    .addArg("cost", ArgValueType::UNSIGNED, Required::NO, Positional::NO)
    .addArg("no-inherit", ArgValueType::NONE, Required::NO, Positional::NO)</b></font>
    .addArg("capture", ArgValueType::NONE, Required::NO, Positional::NO)
    .addArg("expires", ArgValueType::UNSIGNED, Required::NO, Positional::NO);
  parser.addCommand(defRouteAdd, &amp;RibModule::add);

  CommandDefinition defRouteRemove("route", "remove");
  defRouteRemove
    .setTitle("remove a route")
    .addArg("prefix", ArgValueType::NAME, Required::YES, Positional::YES)
    .addArg("nexthop", ArgValueType::FACE_ID_OR_URI, Required::YES, Positional::YES)
    .addArg("origin", ArgValueType::ROUTE_ORIGIN, Required::NO, Positional::NO);
  parser.addCommand(defRouteRemove, &amp;RibModule::remove);
}

void
RibModule::list(ExecuteContext&amp; ctx)
{
  auto nexthopIt = ctx.args.find("nexthop");
  std::set&lt;uint64_t&gt; nexthops;
  auto origin = ctx.args.getOptional&lt;RouteOrigin&gt;("origin");

  if (nexthopIt != ctx.args.end()) {
    FindFace findFace(ctx);
    FindFace::Code res = findFace.execute(nexthopIt-&gt;second, true);

    ctx.exitCode = static_cast&lt;int&gt;(res);
    switch (res) {
      case FindFace::Code::OK:
        break;
      case FindFace::Code::ERROR:
      case FindFace::Code::CANONIZE_ERROR:
      case FindFace::Code::NOT_FOUND:
        ctx.err &lt;&lt; findFace.getErrorReason() &lt;&lt; '\n';
        return;
      default:
        BOOST_ASSERT_MSG(false, "unexpected FindFace result");
        return;
    }

    nexthops = findFace.getFaceIds();
  }

  listRoutesImpl(ctx, [&amp;] (const RibEntry&amp; entry, const Route&amp; route) {
    return (nexthops.empty() || nexthops.count(route.getFaceId()) &gt; 0) &amp;&amp;
           (!origin || route.getOrigin() == *origin);
  });
}

void
RibModule::show(ExecuteContext&amp; ctx)
{
  auto prefix = ctx.args.get&lt;Name&gt;("prefix");

  listRoutesImpl(ctx, [&amp;] (const RibEntry&amp; entry, const Route&amp; route) {
    return entry.getName() == prefix;
  });
}

void
RibModule::listRoutesImpl(ExecuteContext&amp; ctx, const RoutePredicate&amp; filter)
{
  ctx.controller.fetch&lt;ndn::nfd::RibDataset&gt;(
    [&amp;] (const std::vector&lt;RibEntry&gt;&amp; dataset) {
      bool hasRoute = false;
      for (const RibEntry&amp; entry : dataset) {
        for (const Route&amp; route : entry.getRoutes()) {
          if (filter(entry, route)) {
            hasRoute = true;
            formatRouteText(ctx.out, entry, route, true);
            ctx.out &lt;&lt; '\n';
          }
        }
      }

      if (!hasRoute) {
        ctx.exitCode = 6;
        ctx.err &lt;&lt; "Route not found\n";
      }
    },
    ctx.makeDatasetFailureHandler("RIB dataset"),
    ctx.makeCommandOptions());

  ctx.face.processEvents();
}

void
RibModule::add(ExecuteContext&amp; ctx)
{
  auto prefix = ctx.args.get&lt;Name&gt;("prefix");
  auto nexthop = ctx.args.at("nexthop");
  auto origin = ctx.args.get&lt;RouteOrigin&gt;("origin", ndn::nfd::ROUTE_ORIGIN_STATIC);
  auto cost = ctx.args.get&lt;uint64_t&gt;("cost", 0);
  bool wantChildInherit = !ctx.args.get&lt;bool&gt;("no-inherit", false);
  bool wantCapture = ctx.args.get&lt;bool&gt;("capture", false);
  auto expiresMillis = ctx.args.getOptional&lt;uint64_t&gt;("expires");

  auto registerRoute = [&amp;] (uint64_t faceId) {
    ControlParameters registerParams;
    registerParams
      .setName(prefix)
      .setFaceId(faceId)
      .setOrigin(origin)
      .setCost(cost)
      .setFlags((wantChildInherit ? ndn::nfd::ROUTE_FLAG_CHILD_INHERIT : ndn::nfd::ROUTE_FLAGS_NONE) |
                (wantCapture ? ndn::nfd::ROUTE_FLAG_CAPTURE : ndn::nfd::ROUTE_FLAGS_NONE));
    if (expiresMillis) {
      registerParams.setExpirationPeriod(time::milliseconds(*expiresMillis));
    }

    ctx.controller.start&lt;ndn::nfd::RibRegisterCommand&gt;(
      registerParams,
      [&amp;] (const ControlParameters&amp; resp) {
        ctx.exitCode = static_cast&lt;int&gt;(FindFace::Code::OK);
        ctx.out &lt;&lt; "route-add-accepted ";
        text::ItemAttributes ia;
        ctx.out &lt;&lt; ia("prefix") &lt;&lt; resp.getName()
                &lt;&lt; ia("nexthop") &lt;&lt; resp.getFaceId()
                &lt;&lt; ia("origin") &lt;&lt; resp.getOrigin()
                &lt;&lt; ia("cost") &lt;&lt; resp.getCost()
                &lt;&lt; ia("flags") &lt;&lt; static_cast&lt;ndn::nfd::RouteFlags&gt;(resp.getFlags());
        if (resp.hasExpirationPeriod()) {
          ctx.out &lt;&lt; ia("expires") &lt;&lt; text::formatDuration&lt;time::milliseconds&gt;(resp.getExpirationPeriod()) &lt;&lt; "\n";
        }
        else {
          ctx.out&lt;&lt; ia("expires") &lt;&lt; "never\n";
        }
      },
      ctx.makeCommandFailureHandler("adding route"),
      ctx.makeCommandOptions());
  };

  auto handleFaceNotFound = [&amp;] {
    const FaceUri* faceUri = ndn::any_cast&lt;FaceUri&gt;(&amp;nexthop);
    if (faceUri == nullptr) {
      ctx.err &lt;&lt; "Face not found\n";
      return;
    }

    if (faceUri-&gt;getScheme() == "ether") {
      // Unicast Ethernet faces require a LocalUri, which hasn't been provided
      // Multicast Ethernet faces cannot be created via management (already exist on each interface)
      ctx.err &lt;&lt; "Unable to implicitly create Ethernet faces\n";
      ctx.err &lt;&lt; "Please create the face with 'nfdc face create' before adding the route\n";
      return;
    }

    optional&lt;FaceUri&gt; canonized;
    std::string error;
    std::tie(canonized, error) = canonize(ctx, *faceUri);
    if (!canonized) {
      // Canonization failed
      auto canonizationError = canonizeErrorHelper(*faceUri, error);
      ctx.exitCode = static_cast&lt;int&gt;(canonizationError.first);
      ctx.err &lt;&lt; canonizationError.second &lt;&lt; '\n';
      return;
    }

    ControlParameters faceCreateParams;
    faceCreateParams.setUri(canonized-&gt;toString());

    ctx.controller.start&lt;ndn::nfd::FaceCreateCommand&gt;(
      faceCreateParams,
      [&amp;] (const ControlParameters&amp; resp) {
        FaceModule::printSuccess(ctx.out, "face-created", resp);
        registerRoute(resp.getFaceId());
      },
      ctx.makeCommandFailureHandler("implicitly creating face"),
      ctx.makeCommandOptions());
  };

  FindFace findFace(ctx);
  FindFace::Code res = findFace.execute(nexthop);

  ctx.exitCode = static_cast&lt;int&gt;(res);
  switch (res) {
    case FindFace::Code::OK:
      registerRoute(findFace.getFaceId());
      break;
    case FindFace::Code::ERROR:
    case FindFace::Code::CANONIZE_ERROR:
      ctx.err &lt;&lt; findFace.getErrorReason() &lt;&lt; '\n';
      return;
    case FindFace::Code::NOT_FOUND:
      // Attempt to create face if it doesn't exist
      handleFaceNotFound();
      break;
    case FindFace::Code::AMBIGUOUS:
      ctx.err &lt;&lt; "Multiple faces match specified remote FaceUri. Re-run the command with a FaceId:";
      findFace.printDisambiguation(ctx.err, FindFace::DisambiguationStyle::LOCAL_URI);
      ctx.err &lt;&lt; '\n';
      return;
    default:
      BOOST_ASSERT_MSG(false, "unexpected FindFace result");
      return;
  }

  ctx.face.processEvents();
}

void
RibModule::remove(ExecuteContext&amp; ctx)
{
  auto prefix = ctx.args.get&lt;Name&gt;("prefix");
  auto nexthop = ctx.args.at("nexthop");
  auto origin = ctx.args.get&lt;RouteOrigin&gt;("origin", ndn::nfd::ROUTE_ORIGIN_STATIC);

  FindFace findFace(ctx);
  FindFace::Code res = findFace.execute(nexthop, true);

  ctx.exitCode = static_cast&lt;int&gt;(res);
  switch (res) {
    case FindFace::Code::OK:
      break;
    case FindFace::Code::ERROR:
    case FindFace::Code::CANONIZE_ERROR:
    case FindFace::Code::NOT_FOUND:
      ctx.err &lt;&lt; findFace.getErrorReason() &lt;&lt; '\n';
      return;
    default:
      BOOST_ASSERT_MSG(false, "unexpected FindFace result");
      return;
  }

  for (uint64_t faceId : findFace.getFaceIds()) {
    ControlParameters unregisterParams;
    unregisterParams
      .setName(prefix)
      .setFaceId(faceId)
      .setOrigin(origin);

    ctx.controller.start&lt;ndn::nfd::RibUnregisterCommand&gt;(
      unregisterParams,
      [&amp;] (const ControlParameters&amp; resp) {
        ctx.out &lt;&lt; "route-removed ";
        text::ItemAttributes ia;
        ctx.out &lt;&lt; ia("prefix") &lt;&lt; resp.getName()
                &lt;&lt; ia("nexthop") &lt;&lt; resp.getFaceId()
                &lt;&lt; ia("origin") &lt;&lt; resp.getOrigin()
                &lt;&lt; '\n';
<a name="1"></a>      },
      ctx.makeCommandFailureHandler("removing route"),
      ctx.makeCommandOptions());
<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  }

  ctx.face.processEvents();
}

void
RibModule::fetchStatus(Controller&amp; controller,
                       const std::function&lt;void()&gt;&amp; onSuccess,
                       const Controller::DatasetFailCallback&amp; onFailure,
                       const CommandOptions&amp; options)
{
  controller.fetch&lt;ndn::nfd::RibDataset&gt;(
    [this, onSuccess] (const std::vector&lt;RibEntry&gt;&amp; result) {</b></font>
      m_status = result;
      onSuccess();
    },
    onFailure, options);
}

void
RibModule::formatStatusXml(std::ostream&amp; os) const
{
  os &lt;&lt; "&lt;rib&gt;";
  for (const RibEntry&amp; item : m_status) {
    this-&gt;formatItemXml(os, item);
  }
  os &lt;&lt; "&lt;/rib&gt;";
}

void
RibModule::formatItemXml(std::ostream&amp; os, const RibEntry&amp; item) const
{
  os &lt;&lt; "&lt;ribEntry&gt;";

  os &lt;&lt; "&lt;prefix&gt;" &lt;&lt; xml::Text{item.getName().toUri()} &lt;&lt; "&lt;/prefix&gt;";

  os &lt;&lt; "&lt;routes&gt;";
  for (const Route&amp; route : item.getRoutes()) {
    os &lt;&lt; "&lt;route&gt;"
       &lt;&lt; "&lt;faceId&gt;" &lt;&lt; route.getFaceId() &lt;&lt; "&lt;/faceId&gt;"
       &lt;&lt; "&lt;origin&gt;" &lt;&lt; route.getOrigin() &lt;&lt; "&lt;/origin&gt;"
       &lt;&lt; "&lt;cost&gt;" &lt;&lt; route.getCost() &lt;&lt; "&lt;/cost&gt;";
    if (route.getFlags() == ndn::nfd::ROUTE_FLAGS_NONE) {
       os &lt;&lt; "&lt;flags/&gt;";
    }
    else {
       os &lt;&lt; "&lt;flags&gt;";
      if (route.isChildInherit()) {
        os &lt;&lt; "&lt;childInherit/&gt;";
      }
      if (route.isRibCapture()) {
        os &lt;&lt; "&lt;ribCapture/&gt;";
      }
      os &lt;&lt; "&lt;/flags&gt;";
    }
    if (route.hasExpirationPeriod()) {
      os &lt;&lt; "&lt;expirationPeriod&gt;"
         &lt;&lt; xml::formatDuration(time::duration_cast&lt;time::seconds&gt;(route.getExpirationPeriod()))
         &lt;&lt; "&lt;/expirationPeriod&gt;";
    }
    os &lt;&lt; "&lt;/route&gt;";
  }
  os &lt;&lt; "&lt;/routes&gt;";

  os &lt;&lt; "&lt;/ribEntry&gt;";
}

void
RibModule::formatStatusText(std::ostream&amp; os) const
{
  os &lt;&lt; "RIB:\n";
  for (const RibEntry&amp; item : m_status) {
    os &lt;&lt; "  ";
    formatEntryText(os, item);
    os &lt;&lt; '\n';
  }
}

void
RibModule::formatEntryText(std::ostream&amp; os, const RibEntry&amp; entry)
{
  os &lt;&lt; entry.getName() &lt;&lt; " routes={";

  text::Separator sep(", ");
  for (const Route&amp; route : entry.getRoutes()) {
    os &lt;&lt; sep;
    formatRouteText(os, entry, route, false);
  }

  os &lt;&lt; "}";
}

void
RibModule::formatRouteText(std::ostream&amp; os, const RibEntry&amp; entry, const Route&amp; route,
                           bool includePrefix)
{
  text::ItemAttributes ia;

  if (includePrefix) {
    os &lt;&lt; ia("prefix") &lt;&lt; entry.getName();
  }
  os &lt;&lt; ia("nexthop") &lt;&lt; route.getFaceId();
  os &lt;&lt; ia("origin") &lt;&lt; route.getOrigin();
  os &lt;&lt; ia("cost") &lt;&lt; route.getCost();
  os &lt;&lt; ia("flags") &lt;&lt; static_cast&lt;ndn::nfd::RouteFlags&gt;(route.getFlags());
  if (route.hasExpirationPeriod()) {
    os &lt;&lt; ia("expires") &lt;&lt; text::formatDuration&lt;time::seconds&gt;(route.getExpirationPeriod());
  }
  else {
    os &lt;&lt; ia("expires") &lt;&lt; "never";
  }
}

} // namespace nfdc
} // namespace tools
} // namespace nfd
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
