
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 18, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-yahoodm.cpp</h3>
            <pre><code>1  #include "yahoodm.h"
2  TYTb::TYTb(const PYBs& _YBs, const PYDsBs& _YDsBs):
3    YBs(_YBs), YDsBs(_YDsBs),
4    VarNToWordIdV(YBs->GetWords()), WordIdToVarNV(YBs->GetMxWordIds()),
5    TupNToDocIdV(YBs->GetDocs()), DocIdToTupNV(YBs->GetMxDocIds()){
6    int WordId=YBs->FFirstWordId(); int VarN=0-1;
7    while (YBs->FNextWordId(WordId)){VarN++;
8      VarNToWordIdV[VarN]=WordId; WordIdToVarNV[WordId]=VarN;}
9    int DocId=YBs->FFirstDocId(); int TupN=0-1;
10    while (YBs->FNextDocId(DocId)){TupN++;
11      TupNToDocIdV[TupN]=DocId; DocIdToTupNV[DocId]=TupN;}
12  }
13  TTbVal TYTb::GetVal(const int& TupN, const int& VarN){
14    int DocId=TupNToDocIdV[TupN];
15    int WordId=VarNToWordIdV[VarN];
16    double WordFq;
17    if (YDsBs->GetWordDs(DocId)->IsWordId(WordId, WordFq)){return WordFq;}
18    else {return double(0);}
19  }
20  TYDmDs::TYDmDs(
21   const bool& _DoPriorDmDs, const int& ClassN,
22   const int& _YNegDsType, const int& _YPriorType,
23   const PYBs& _YBs, const PYDsBs& _YDsBs, const PDmHd& _DmHd):
24    DoPriorDmDs(_DoPriorDmDs),
25    YNegDsType(_YNegDsType), YPriorType(_YPriorType),
26    YBs(_YBs), YDsBs(_YDsBs), DmHd(_DmHd),
27    NegWordDs(), PosWordDs(),
28    CValDs(), NegCValPrb(), PosCValPrb(){
29    NegWordDs=GetNegWordDs(YNegDsType, YBs, YDsBs);
30    PosWordDs=YDsBs->GetWordDs(ClassN);
31    CValDs=GetPriorValDs(YPriorType, NegWordDs, PosWordDs);
32    NegCValPrb=CValDs->GetPrb_RelFq(TTbVal::NegVal);
33    PosCValPrb=CValDs->GetPrb_RelFq(TTbVal::PosVal);
34  }
35  double TYDmDs::GetSumW(){
36    return CValDs->GetSumW();
37  }
38  PTbValDs TYDmDs::GetCDs(){
39    return CValDs;
40  }
41  PTbValDs TYDmDs::GetAVDs(const int& AttrN){
42    if (DoPriorDmDs){
43      return TTbValDs::GetBoolValDs(-1, NegWordDs->GetWordPrb(AttrN));
44    } else {
45      return TTbValDs::GetBoolValDs(-1,
46       NegCValPrb*NegWordDs->GetWordPrb(AttrN)+
47       PosCValPrb*PosWordDs->GetWordPrb(AttrN));
48    }
49  }
50  PTbValDs TYDmDs::GetCAVDs(const TTbVal& CVal, const int& AttrN){
51    if (DoPriorDmDs){
52      return TTbValDs::GetBoolValDs(-1, NegWordDs->GetWordPrb(AttrN));
53    } else {
54      if (CVal==TTbVal::NegVal){
55        return TTbValDs::GetBoolValDs(-1, NegWordDs->GetWordPrb(AttrN));
56      } else
57      if (CVal==TTbVal::PosVal){
58        return TTbValDs::GetBoolValDs(-1, PosWordDs->GetWordPrb(AttrN));
59      } else {
60        Fail; return NULL;
61      }
62    }
63  }
64  PYWordDs TYDmDs::GetNegWordDs(
65   const int& YNegDsType, const PYBs& YBs, const PYDsBs& YDsBs){
66    PYWordDs NegWordDs;
67    switch (TYNegDsType(YNegDsType)){
68      case yndtEmpty: NegWordDs=PYWordDs(new TYWordDs(0, 0, 0)); break;
69      case yndtRoot: NegWordDs=YDsBs->GetWordDs(YBs->GetRootDocId()); break;
70      case yndtAll: NegWordDs=YDsBs->GetAllWordDs(); break;
71      default: Fail;
72    }
73    return NegWordDs;
74  }
75  PTbValDs TYDmDs::GetPriorValDs(const int& YPriorType,
76   const PYWordDs& NegWordDs, const PYWordDs& PosWordDs){
77    double PosW; double AllW;
78    switch (TYPriorType(YPriorType)){
79      case yptWords:
80        PosW=PosWordDs->GetSumWordFq(); AllW=NegWordDs->GetSumWordFq(); break;
81      case yptSects:
82        PosW=PosWordDs->GetSects(); AllW=NegWordDs->GetSects(); break;
83      case yptDocs:
84        PosW=PosWordDs->GetDocs(); AllW=NegWordDs->GetDocs(); break;
85      default: Fail;
86    }
87    return TTbValDs::GetBoolValDs(AllW, PosW);
88  }
89  TStr TYDmDs::GetYNegDsTypeStr(const TYNegDsType& YNegDsType){
90    switch (YNegDsType){
91      case yndtEmpty: return "Empty";
92      case yndtRoot: return "Root";
93      case yndtAll: return "All";
94      default: Fail; return TStr();
95    }
96  }
97  TStr TYDmDs::GetYPriorTypeStr(const TYPriorType& YPriorType){
98    switch (YPriorType){
99      case yptWords: return "Words";
100      case yptSects: return "Sects";
101      case yptDocs: return "Docs";
102      default: Fail; return TStr();
103    }
104  }
105  TYFSelBs::TYFSelBs(
106   const TYFSelType& FSelType, const double& FSels,
107   const bool& FSelPosWords, const PAttrEst& AttrEst,
108   const TYNegDsType& _YNegDsType, const TYPriorType& YPriorType,
109   const PYBs& YBs, const PYDsBs& YDsBs, const PNotify& Notify):
110    YNegDsType(_YNegDsType), DocIdToWordIdEstVV(YBs->GetDocs()){
111    TNotify::OnNotify(Notify, ntInfo, "Start Feature Selection");
112    PDmHd DmHd=new TYDmHd(YBs, YDsBs);
113    PYWordDs NegWordDs=TYDmDs::GetNegWordDs(YNegDsType, YBs, YDsBs);
114    PTbValSplit BoolValSplit=TTbValSplit::GetBoolValSplit();
115    int DocId=YBs->FFirstDocId(); int DocIds=0;
116    while (YBs->FNextDocId(DocId)){
117      PYWordDs PosWordDs=YDsBs->GetWordDs(DocId); DocIds++;
118      int SelWordIds;
119      switch (FSelType){
120        case yfstFix: SelWordIds=int(FSels); break;
121        case yfstPosPrc:
122          SelWordIds=int(FSels*double(PosWordDs->GetWordIds())); break;
123        case yfstUnionPrc:{
124          PYWordDs UnionWordDs=TYWordDs::GetMerged(PosWordDs, NegWordDs, 1, 1);
125          SelWordIds=int(FSels*double(UnionWordDs->GetWordIds())); break;}
126        default: Fail; SelWordIds=0;
127      }
128      if (SelWordIds<=0){SelWordIds=1;}
129      PDmDs DmDs=PDmDs(new TYDmDs(
130       false, DocId, YNegDsType, YPriorType, YBs, YDsBs, DmHd));
131      PDmDs PriorDmDs=PDmDs(new TYDmDs(
132       true, DocId, yndtAll, yptDocs, YBs, YDsBs, DmHd));
133      PYWordDs WordDs; PYWordDs TrvWordDs;
134      TIntH SelWordIdH(SelWordIds);
135      TFltIntKdV WordEstIdKdV(SelWordIds, 0);
136      for (int CDsc=0; CDsc<TTbVal::BoolVals; CDsc++){
137        switch (CDsc){
138          case 0: WordDs=NegWordDs; break;
139          case 1: WordDs=PosWordDs; break;
140          default: Fail;
141        }
142        if (FSelPosWords){TrvWordDs=PosWordDs;} else {TrvWordDs=WordDs;}
143        int WordIdN=TrvWordDs->FFirstWordId(); int WordId;
144        while (TrvWordDs->FNextWordId(WordIdN, WordId)){
145          if (SelWordIdH.IsKey(WordId)){continue;}
146          double WordEst;
147          if (AttrEst.Empty()){
148            double PriorSumW=YBs->GetDocs();
149            IAssert(PriorSumW>0);
150            double S1C0Prb=NegWordDs->GetWordPrb(WordId);
151            double S1C1Prb=PosWordDs->GetWordPrb(WordId);
152            if (S1C0Prb==0){S1C0Prb=1/sqr(PriorSumW);}
153            if (S1C0Prb==1){S1C0Prb=1-(1/sqr(PriorSumW));}
154            double OddsS1C0=S1C0Prb/(1-S1C0Prb);
155            if (S1C1Prb==0){S1C1Prb=1/sqr(PriorSumW);}
156            if (S1C1Prb==1){S1C1Prb=1-(1/sqr(PriorSumW));}
157            double OddsS1C1=S1C1Prb/(1-S1C1Prb);
158            WordEst=log(OddsS1C1/OddsS1C0);
159          } else {
160            WordEst=AttrEst->GetAttrQ(WordId, BoolValSplit, DmDs, PriorDmDs);
161          }
162          WordEstIdKdV.AddSorted(TFltIntKd(WordEst, WordId), false, SelWordIds);
163          SelWordIdH.AddKey(WordId);
164        }
165      }
166      TIntFltKdV& WordIdEstKdV=DocIdToWordIdEstVV[DocId];
167      WordIdEstKdV.Gen(WordEstIdKdV.Len(), 0);
168      for (int WordIdN=0; WordIdN<WordEstIdKdV.Len(); WordIdN++){
169        double WordEst=WordEstIdKdV[WordIdN].Key;
170        int WordId=WordEstIdKdV[WordIdN].Dat;
171        WordIdEstKdV.Add(TIntFltKd(WordId, WordEst));
172      }
173      WordIdEstKdV.Sort();
174      if (DocIds%100==0){
175        TNotify::OnNotify(Notify, ntInfo,
176         TStr("...")+TInt::GetStr(DocIds)+" Selections.");}
177    }
178    TNotify::OnNotify(Notify, ntInfo,
179     TStr("Feature Selection Finished (")+ TInt::GetStr(DocIds)+").");
180  }
181  void TYFSelBs::GetBestWordIdV(
182   const int& DocId, const double& EstExp, const double& SumEstPrb,
183   const PYWordDs& IntrsWordDs, TIntV& BestWordIdV){
184    TIntFltKdV& WordIdEstKdV=DocIdToWordIdEstVV[DocId];
185    TFltIntKdV WordEstIdKdV(WordIdEstKdV.Len(), 0);
186    double MnWordEst=TFlt::Mx;
187    for (int WordIdN=0; WordIdN<WordIdEstKdV.Len(); WordIdN++){
188      int WordId=WordIdEstKdV[WordIdN].Key;
189      double WordEst=pow(WordIdEstKdV[WordIdN].Dat, EstExp);
190      if (IntrsWordDs->IsWordId(WordId)){
191        WordEstIdKdV.Add(TFltIntKd(WordEst, WordId));
192        MnWordEst=TFlt::GetMn(WordEst, MnWordEst);
193      }
194    }
195    double SumWordEst=0;
196    {for (int WordIdN=0; WordIdN<WordEstIdKdV.Len(); WordIdN++){
197      SumWordEst+=(WordEstIdKdV[WordIdN].Key-=MnWordEst);}}
198    WordEstIdKdV.Sort(false);
199    {BestWordIdV.Gen(WordEstIdKdV.Len(), 0);
200    SumWordEst*=SumEstPrb; int WordIdN=0;
201    while ((SumWordEst>=0)&&(WordIdN<WordEstIdKdV.Len())){
202      double WordEst=WordEstIdKdV[WordIdN].Key;
203      int WordId=WordEstIdKdV[WordIdN].Dat;
204      SumWordEst-=WordEst;
<span onclick='openModal()' class='match'>205      BestWordIdV.Add(WordId);
206      WordIdN++;
207    }}
208  }
209  void TYFSelBs::SaveTxt(
210   const PSOut& SOut, const PYBs& YBs, const PYDsBs& YDsBs){
</span>211    PYWordDs NegWordDs=TYDmDs::GetNegWordDs(YNegDsType, YBs, YDsBs);
212    TOLx Lx(SOut, TFSet()|oloFrcEoln|oloSigNum);
213    for (int DocId=0; DocId<DocIdToWordIdEstVV.Len(); DocId++){
214      TIntFltKdV& WordIdEstKdV=DocIdToWordIdEstVV[DocId];
215      TFltIntKdV WordEstIdKdV(WordIdEstKdV.Len(), 0);
216      for (int WordIdN=0; WordIdN<WordIdEstKdV.Len(); WordIdN++){
217        int WordId=WordIdEstKdV[WordIdN].Key;
218        double WordEst=WordIdEstKdV[WordIdN].Dat;
219        WordEstIdKdV.Add(TFltIntKd(WordEst, WordId));
220      }
221      WordEstIdKdV.Sort(false);
222      Lx.PutVarStr("UrlStr", YBs->GetDocUrlStr(DocId));
223      Lx.PutVarInt("DocId", DocId);
224      PYWordDs WordDs=YDsBs->GetWordDs(DocId);
225      Lx.PutVar("WordIdEstKdV", true, true); 
226      {for (int WordIdN=0; WordIdN<WordEstIdKdV.Len(); WordIdN++){
227        double WordEst=WordEstIdKdV[WordIdN].Key;
228        int WordId=WordEstIdKdV[WordIdN].Dat;
229        TStr WordStr=YBs->GetWordStr(WordId);
230        double PosWordPrb=WordDs->GetWordPrb(WordId);
231        double NegWordPrb=NegWordDs->GetWordPrb(WordId);
232        Lx.PutQStr(WordStr);
233        Lx.PutTab(); Lx.PutFlt(WordEst);
234        Lx.PutIndent(1); Lx.PutSym(syLBracket);
235        Lx.PutFlt(PosWordPrb); Lx.PutFlt(NegWordPrb);
236        Lx.PutSym(syRBracket);
237        Lx.PutLn();
238      }}
239      Lx.PutSym(syRBracket); Lx.PutLn();
240    }
241  }
242  TStr TYFSelBs::GetYFSelTypeStr(const TYFSelType& YFSelType){
243    switch (YFSelType){
244      case yfstFix: return "Fix";
245      case yfstPosPrc: return "PosPrc";
246      case yfstUnionPrc: return "NegPrc";
247      default: Fail; return TStr();
248    }
249  }
250  TYInvIx::TYInvIx(
251   const double& EstExp, const double& SumEstPrb,
252   const PYBs& YBs, const PYDsBs& YDsBs,
253   const PYFSelBs& YFSelBs, const PNotify& Notify):
254    WordIdToFirstDocIdNH(YBs->GetWords()/2),
255    DocIdVHeap(), AllDocIdV(YBs->GetDocs(), 0){
256    TNotify::OnNotify(Notify, ntInfo, "Start Creating Inverted Index");
257    TIntPrV WordIdDocIdPrV(YBs->GetDocs(), 0);
258    TIntV BestWordIdV;
259    int DocId=YBs->FFirstDocId();
260    while (YBs->FNextDocId(DocId)){
261      AllDocIdV.Add(DocId);
262      PYWordDs PosWordDs=YDsBs->GetWordDs(DocId);
263      YFSelBs->GetBestWordIdV(DocId, EstExp, SumEstPrb, PosWordDs, BestWordIdV);
264      for (int WordIdN=0; WordIdN<BestWordIdV.Len(); WordIdN++){
265        int WordId=BestWordIdV[WordIdN];
266        WordIdDocIdPrV.Add(TIntPr(WordId, DocId));
267      }
268    }
269    WordIdDocIdPrV.Sort();
270    DocIdVHeap.Gen(WordIdDocIdPrV.Len()+YBs->GetDocs(), 0);
271    int PrevWordId=-1;
272    for (int WordIdN=0; WordIdN<WordIdDocIdPrV.Len(); WordIdN++){
273      int WordId=WordIdDocIdPrV[WordIdN].Val1;
274      int DocId=WordIdDocIdPrV[WordIdN].Val2;
275      if (PrevWordId!=WordId){
276        if (PrevWordId!=-1){DocIdVHeap.Add(TInt(-1));}
277        PrevWordId=WordId;
278        WordIdToFirstDocIdNH.AddDat(TInt(WordId), TInt(DocIdVHeap.Len()));
279      }
280      DocIdVHeap.Add(DocId);
281    }
282    DocIdVHeap.Add(TInt(-1));
283    TNotify::OnNotify(Notify, ntInfo, "End Creating Inverted Index");
284  }
285  void TYInvIx::GetDocIdV(
286   const PYWordDs& WordDs, const int& MnDocFq, TIntV& DocIdV){
287    IAssert(MnDocFq>=0);
288    if (MnDocFq==0){
289      DocIdV=AllDocIdV;
290    } else {
291      TIntIntH DocIdFqH(100); int MxDocFq=0;
292      int WordIdN=WordDs->FFirstWordId(); int WordId; double WordFq;
293      while (WordDs->FNextWordId(WordIdN, WordId, WordFq)){
294        if (WordIdToFirstDocIdNH.IsKey(WordId)){
295          int DocIdN=FFirstDocId(WordId); int DocId;
296          while (FNextWordId(DocIdN, DocId)){
297            DocIdFqH.AddDat(DocId)+=int(WordFq);
298            MxDocFq=TInt::GetMx(MxDocFq, DocIdFqH.GetDat(DocId));
299          }
300        }
301      }
302      int NewMnDocFq=(MnDocFq<=MxDocFq) ? MnDocFq : MxDocFq-3;
303      DocIdV.Gen(DocIdFqH.Len(), 0);
304      int DocIdP=DocIdFqH.FFirstKeyId();
305      while (DocIdFqH.FNextKeyId(DocIdP)){
306        int DocId=DocIdFqH.GetKey(DocIdP);
307        int DocFq=DocIdFqH[DocIdP];
308        if (DocFq>=NewMnDocFq){DocIdV.Add(DocId);}
309      }
310    }
311  }
312  void TYInvIx::SaveTxt(const PSOut& SOut, const PYBs& YBs){
313    TOLx Lx(SOut, TFSet()|oloFrcEoln|oloSigNum);
314    int WordIdToFirstDocIdNP=WordIdToFirstDocIdNH.FFirstKeyId();
315    while (WordIdToFirstDocIdNH.FNextKeyId(WordIdToFirstDocIdNP)){
316      int WordId=WordIdToFirstDocIdNH.GetKey(WordIdToFirstDocIdNP);
317      TStr WordStr;
318      if (YBs.Empty()){WordStr=TInt::GetStr(WordId);}
319      else {WordStr=YBs->GetWordStr(WordId);}
320      Lx.PutStr(WordStr); Lx.PutSym(syColon); Lx.PutSym(syLBracket);
321      int DocIdN=FFirstDocId(WordId); int DocId;
322      while (FNextWordId(DocIdN, DocId)){
323        Lx.PutInt(DocId);}
324      Lx.PutSym(syRBracket); Lx.PutLn();
325    }
326  }
327  bool TYValRet::FNextAttrN(int& AttrP, int& AttrN, TTbVal& AttrVal) const {
328    bool IsFNext; double WordFq; double WordPrb;
329    do {
330      IsFNext=WordDs->FNextWordId(AttrP, AttrN, WordFq, WordPrb);
331      if ((IsFNext)&&(WordPrb>MnWordPrb)){AttrVal=TTbVal(WordFq); return true;}
332    } while (IsFNext);
333    return false;
334  }
335  TMdYBayes::TMdYBayes(
336   const TYNegDsType& _YNegDsType, const TYPriorType& _YPriorType,
337   const PYBs& _YBs, const PYDsBs& _YDsBs,
338   const PYFSelBs& _YFSelBs, const PYInvIx& _YInvIx):
339    TMd(PDmHd(new TYDmHd(_YBs, _YDsBs))),
340    YNegDsType(_YNegDsType), YPriorType(_YPriorType),
341    YBs(_YBs), YDsBs(_YDsBs),
342    YFSelBs(_YFSelBs), YInvIx(_YInvIx),
343    NegWordDs(TYDmDs::GetNegWordDs(YNegDsType, YBs, YDsBs)){
344    Def();
345  }
346  PMd TMdYBayes::Load(TSIn& SIn){
347    TStr TypeNm(SIn); 
348    IAssert(TypeNm==TTypeNm<TMdYBayes>());
349    TYNegDsType YNegDsType=TYNegDsType(int(TInt(SIn)));
350    TYPriorType YPriorType=TYPriorType(int(TInt(SIn)));
351    PYBs YBs(SIn);
352    PYDsBs YDsBs(SIn);
353    PYFSelBs YFSelBs(SIn);
354    PYInvIx YInvIx(SIn);
355    PYWordDs NegWordDs(SIn); SIn.LoadCs();
356    PMd Md=PMd(new TMdYBayes(
357     YNegDsType, YPriorType, YBs, YDsBs, YFSelBs, YInvIx));
358    return Md;
359  }
360  void TMdYBayes::Save(TSOut& SOut){
361    GetTypeNm(*this).Save(SOut);
362    YNegDsType.Save(SOut); YPriorType.Save(SOut);
363    YBs.Save(SOut);
364    YDsBs.Save(SOut);
365    YFSelBs.Save(SOut);
366    YInvIx.Save(SOut);
367    NegWordDs.Save(SOut);
368    SOut.SaveCs();
369  }
370  PTbValDs TMdYBayes::GetPostrValDs(
371   const PValRet& ValRet, const int& ClassN) const {
372    PYWordDs PosWordDs=YDsBs->GetWordDs(ClassN);
373    PTbValDs PriorValDs=GetPriorValDs(ClassN);
374    TIntFltKdV& WordIdEstKdV=YFSelBs->GetWordIdEstV(ClassN);
375    double LnSumW=log(PriorValDs->GetSumW());
376    PTbValDs ValDs=new TTbValDs(TTbVal::BoolVals);
377    double NegPriorCPrb=PriorValDs->GetPrb_RelFq(TTbVal::NegVal);
378    double PosPriorCPrb=PriorValDs->GetPrb_RelFq(TTbVal::PosVal);
379    double NegLnPriorCPrb=0; double NegLnPostrCPrb=0;
380    double PosLnPriorCPrb=0; double PosLnPostrCPrb=0;
381    if (NegPriorCPrb!=0){NegLnPostrCPrb=NegLnPriorCPrb=log(NegPriorCPrb);}
382    if (PosPriorCPrb!=0){PosLnPostrCPrb=PosLnPriorCPrb=log(PosPriorCPrb);}
383    int AttrP=ValRet->FFirstAttrN(); int AttrN; TTbVal AVal;
384    while (ValRet->FNextAttrN(AttrP, AttrN, AVal)){
385      int WordId=AttrN; double WordFq=AVal.GetFlt();
386      if (YFSelBs->IsWordId(WordIdEstKdV, WordId)){
387        if (NegPriorCPrb!=0){
388          double NegAValPrb=NegWordDs->GetWordPrb(WordId);
389          if (NegAValPrb==0){NegLnPostrCPrb+=NegLnPriorCPrb-LnSumW;}
390          else {NegLnPostrCPrb+=log(WordFq*NegAValPrb);}
391        }
392        if (PosPriorCPrb!=0){
393          double PosAValPrb=PosWordDs->GetWordPrb(WordId);
394          if (PosAValPrb==0){PosLnPostrCPrb+=PosLnPriorCPrb-LnSumW;}
395          else {PosLnPostrCPrb+=log(WordFq*PosAValPrb);}
396        }
397      }
398    }
399    if (NegPriorCPrb!=0){ValDs->AddVal(TTbVal::NegVal, NegLnPostrCPrb);}
400    if (PosPriorCPrb!=0){ValDs->AddVal(TTbVal::PosVal, PosLnPostrCPrb);}
401    ValDs->ExpW(); ValDs->Def();
402    return ValDs;
403  }
404  PTbValDs TMdYBayes::GetPostrValDs(
405   const PValRet& ValRet, const int& ClassN, TFltIntKdV& WordPrbIdV) const {
406    WordPrbIdV.Clr();
407    PYWordDs PosWordDs=YDsBs->GetWordDs(ClassN);
408    PTbValDs PriorValDs=GetPriorValDs(ClassN);
409    TIntFltKdV& WordIdEstKdV=YFSelBs->GetWordIdEstV(ClassN);
410    double LnSumW=log(PriorValDs->GetSumW());
411    PTbValDs ValDs=new TTbValDs(TTbVal::BoolVals);
412    double NegPriorCPrb=PriorValDs->GetPrb_RelFq(TTbVal::NegVal);
413    double PosPriorCPrb=PriorValDs->GetPrb_RelFq(TTbVal::PosVal);
414    double NegLnPriorCPrb=0; double NegLnPostrCPrb=0;
415    double PosLnPriorCPrb=0; double PosLnPostrCPrb=0;
416    if (NegPriorCPrb!=0){NegLnPostrCPrb=NegLnPriorCPrb=log(NegPriorCPrb);}
417    if (PosPriorCPrb!=0){PosLnPostrCPrb=PosLnPriorCPrb=log(PosPriorCPrb);}
418    int AttrP=ValRet->FFirstAttrN(); int AttrN; TTbVal AVal;
419    while (ValRet->FNextAttrN(AttrP, AttrN, AVal)){
420      int WordId=AttrN; double WordFq=AVal.GetFlt();
421      if (YFSelBs->IsWordId(WordIdEstKdV, WordId)){
422        if (NegPriorCPrb!=0){
423          double NegAValPrb=NegWordDs->GetWordPrb(WordId);
424          if (NegAValPrb==0){NegLnPostrCPrb+=NegLnPriorCPrb-LnSumW;}
425          else {NegLnPostrCPrb+=log(WordFq*NegAValPrb);}
426          if (NegAValPrb!=0){
427            WordPrbIdV.Add(TFltIntKd(-&bsol;*WordFq**/NegAValPrb, WordId));}
428        }
429        if (PosPriorCPrb!=0){
430          double PosAValPrb=PosWordDs->GetWordPrb(WordId);
431          if (PosAValPrb==0){PosLnPostrCPrb+=PosLnPriorCPrb-LnSumW;}
432          else {PosLnPostrCPrb+=log(WordFq*PosAValPrb);}
433          if (PosAValPrb!=0){
434            WordPrbIdV.Add(TFltIntKd(&bsol;*WordFq**/PosAValPrb, WordId));}
435        }
436      }
437    }
438    if (NegPriorCPrb!=0){ValDs->AddVal(TTbVal::NegVal, NegLnPostrCPrb);}
439    if (PosPriorCPrb!=0){ValDs->AddVal(TTbVal::PosVal, PosLnPostrCPrb);}
440    ValDs->ExpW(); ValDs->Def();
441    WordPrbIdV.Sort(false);
442    return ValDs;
443  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-dmoz.cpp</h3>
            <pre><code>1  const TStr TDMozInfo::RdfStructFBase="structure.rdf.u8";
2  const TStr TDMozInfo::RdfContentFBase="content.rdf.u8";
3  const TStr TDMozInfo::RdfStructSampleFBase="kt-structure.rdf.u8";
4  const TStr TDMozInfo::RdfContentSampleFBase="kt-content.rdf.u8";
5  const TStr TDMozInfo::BinStructFBase="DMozStruct.DMoz";
6  const TStr TDMozInfo::BinFullFBase="DMozFull.DMoz";
7  const TStr TDMozInfo::BinStructSampleFBase="DMozSampleStruct.DMoz";
8  const TStr TDMozInfo::BinFullSampleFBase="DMozFullSample.DMoz";
9  void TDMozBs::GetCatIdV(const TStrV& CatNmV, TIntV& CatIdV) const {
10    CatIdV.Clr();
11    for (int CatNmN=0; CatNmN<CatNmV.Len(); CatNmN++){
12      int CatId=GetCatId(CatNmV[CatNmN]);
13      if (CatId==-1){
14        printf("\nWarning: Invalid Category Name ('%s')\n.", CatNmV[CatNmN].CStr());}
15      CatIdV.Add(CatId);
16    }
17  }
18  void TDMozBs::GetSubCatTypeIdPrV(const int& CatId, TUIntV& _SubCatTypeIdPrV) const {
19    _SubCatTypeIdPrV.Clr();
20    int SubCatTypeIdVN=CatMd5ToTopicH[CatId].SubCatTypeIdVN;
21    if (SubCatTypeIdVN!=-1){
22      uint UndefSubCatTypeIdPr=GetSubCatTypeIdPr(dmsctUndef); 
23      forever{
24        uint SubCatTypeIdPr=SubCatTypeIdPrV[SubCatTypeIdVN];
25        if (SubCatTypeIdPr==UndefSubCatTypeIdPr){break;}
<span onclick='openModal()' class='match'>26        _SubCatTypeIdPrV.Add(SubCatTypeIdPr);
27        SubCatTypeIdVN++;
28      }
29    }
30  }
31  void TDMozBs::GetSubCatIdV(
32   const int& CatId, TIntV& SubCatIdV, const bool& SubTreeOnlyP) const {
</span>33    SubCatIdV.Clr();
34    TUIntV SubCatTypeIdPrV; GetSubCatTypeIdPrV(CatId, SubCatTypeIdPrV);
35    for (int SubCatN=0; SubCatN<SubCatTypeIdPrV.Len(); SubCatN++){
36      int SubCatId; TDMozSubCatType SubCatType;
37      TDMozBs::GetSubCatTypeCatId(SubCatTypeIdPrV[SubCatN], SubCatType, SubCatId);
38      if ((SubTreeOnlyP&&IsSubTreeSubCatType(SubCatType))||(!SubTreeOnlyP)){
39        SubCatIdV.Add(SubCatId);
40      }
41    }
42  }
43  void TDMozBs::GetExtUrlIdV(
44   const int& CatId, TIntV& _ExtUrlIdV, const bool& AppendP) const {
45    if (!AppendP){_ExtUrlIdV.Clr();}
46    int ExtUrlIdVN=CatMd5ToTopicH[CatId].ExtUrlIdVN;
47    if (ExtUrlIdVN!=-1){
48      forever{
49        int ExtUrlId=ExtUrlIdV[ExtUrlIdVN];
50        if (ExtUrlId==-1){break;}
51        _ExtUrlIdV.Add(ExtUrlId);
52        ExtUrlIdVN++;
53      }
54    }
55  }
56  void TDMozBs::GetExtUrlIdV(
57   const TIntV& CatIdV, TIntV& _ExtUrlIdV, const bool& AppendP) const {
58    if (!AppendP){_ExtUrlIdV.Clr();}
59    for (int CatIdN=0; CatIdN<CatIdV.Len(); CatIdN++){
60      int CatId=CatIdV[CatIdN];
61      GetExtUrlIdV(CatId, _ExtUrlIdV, true);
62    }
63  }
64  int TDMozBs::GetRndExtUrlId(const int& RootCatId, TRnd& Rnd){
65    TIntV SubCatIdV; GetSubCatIdV(RootCatId, SubCatIdV);
66    TIntV ExtUrlIdV; GetExtUrlIdV(RootCatId, ExtUrlIdV);
67    if (!ExtUrlIdV.Empty()){SubCatIdV.Add(-1);}
68    SubCatIdV.Shuffle(Rnd);
69    if (SubCatIdV.Empty()){
70      return -1;
71    } else {
72      int CatId=SubCatIdV[0];
73      if (CatId==-1){
74        ExtUrlIdV.Shuffle(Rnd);
75        return ExtUrlIdV[0];
76      } else {
77        return GetRndExtUrlId(CatId, Rnd);
78      }
79    }
80  }
81  void TDMozBs::GetSubTreeCatIdV(
82   const int& RootCatId, const TIntV& PosCatIdV, const TIntV& NegCatIdV, 
83   TIntV& CatIdV, const bool& SubTreeOnlyP) const {
84    CatIdV.Clr();
85    TIntPrQ CatIdTypePrQ; TIntH CatIdH; TIntH WaitCatIdH;
86    CatIdTypePrQ.Push(TIntPr(RootCatId, dmsctNarrow));
87    WaitCatIdH.AddKey(RootCatId);
88    while (!CatIdTypePrQ.Empty()){
89      TInt CatId; TInt SubCatTypeInt;
90      CatIdTypePrQ.Top().GetVal(CatId, SubCatTypeInt); CatIdTypePrQ.Pop();
91      IAssert(!CatIdH.IsKey(CatId));
92      CatIdH.AddKey(CatId); CatIdV.Add(CatId);
93      WaitCatIdH.DelKey(CatId);
94      TDMozSubCatType SubCatType=TDMozSubCatType(int(SubCatTypeInt));
95      if (IsSubTreeSubCatType(SubCatType)){
96        TUIntV SubCatTypeIdPrV; GetSubCatTypeIdPrV(CatId, SubCatTypeIdPrV);
97        for (int SubCatN=0; SubCatN<SubCatTypeIdPrV.Len(); SubCatN++){
98          int SubCatId; TDMozSubCatType SubCatType;
99          TDMozBs::GetSubCatTypeCatId(SubCatTypeIdPrV[SubCatN], SubCatType, SubCatId);
100          if ((!CatIdH.IsKey(SubCatId))&&(!WaitCatIdH.IsKey(SubCatId))){
101            if ((SubTreeOnlyP&&IsSubTreeSubCatType(SubCatType))||(!SubTreeOnlyP)){
102              if (((CatId==RootCatId)&&((PosCatIdV.Empty())||(PosCatIdV.IsIn(SubCatId)))&&
103               ((NegCatIdV.Empty())||(!NegCatIdV.IsIn(SubCatId))))||(CatId!=RootCatId)){
104                CatIdTypePrQ.Push(TIntPr(SubCatId, SubCatType));
105                WaitCatIdH.AddKey(SubCatId);
106              }
107            }
108          }
109        }
110      }
111    }
112  }
113  void TDMozBs::GetSubTreeCatIdV(
114   const TStr& RootCatNm, const TStrV& PosCatNmV, const TStrV& NegCatNmV, 
115   TIntV& CatIdV, const bool& SubTreeOnlyP) const {
116    TIntV PosCatIdV; GetCatIdV(PosCatNmV, PosCatIdV);
117    TIntV NegCatIdV; GetCatIdV(NegCatNmV, NegCatIdV);
118    int CatId=GetCatId(RootCatNm);
119    EAssertRA(CatId!=-1, "Category does not exist", RootCatNm);
120    GetSubTreeCatIdV(CatId, PosCatIdV, NegCatIdV, CatIdV, SubTreeOnlyP);
121  }
122  void TDMozBs::GetSubTreeDocV(
123   const TStr& RootCatNm, const TStrV& PosCatNmV, const TStrV& NegCatNmV, 
124   TStrV& DocNmV, TStrV& DocStrV,
125   const bool& SubTreeOnlyP, const int& UrlWordsCopies) const {
126    TIntV CatIdV; GetSubTreeCatIdV(RootCatNm, PosCatNmV, NegCatNmV, CatIdV, SubTreeOnlyP);
127    TIntV ExtUrlIdV; GetExtUrlIdV(CatIdV, ExtUrlIdV);
128    DocNmV.Gen(ExtUrlIdV.Len(), 0); DocStrV.Gen(ExtUrlIdV.Len(), 0);
129    for (int ExtUrlIdN=0; ExtUrlIdN<ExtUrlIdV.Len(); ExtUrlIdN++){
130      int ExtUrlId=ExtUrlIdV[ExtUrlIdN];
131      TStr UrlStr=GetExtUrlStr(ExtUrlId);
132      TStr TitleStr=GetExtUrlTitleStr(ExtUrlId);
133      TStr DescStr=GetExtUrlDescStr(ExtUrlId);
134      TChA DocChA;
135      if (UrlWordsCopies>0){
136        DocChA+='['; DocChA+=TUrl::GetDocStrFromUrlStr(UrlStr, UrlWordsCopies); DocChA+="] ";
137      }
138      DocChA+=TitleStr; DocChA+=" -- ";
139      DocChA+=DescStr; DocChA+='\n';
140      DocNmV.Add(TInt::GetStr(ExtUrlId));
141      DocStrV.Add(DocChA);
142    }
143  }
144  PBowDocPartClust TDMozBs::GetBowDocPartClust(
145   const int& RootCatId, const TIntV& PosCatIdV, const TIntV& NegCatIdV,
146   const PBowDocBs& BowDocBs, const PBowDocWgtBs& BowDocWgtBs, const PBowSim& BowSim,
147   const int& MnCatDocs, const int& Cats, int& CatN){
148    CatN++; printf("%d/%d\r", CatN, Cats);
149    TStr RootCatNm=GetCatNm(RootCatId);
150    TIntV SubTreeCatIdV; GetSubTreeCatIdV(RootCatId, PosCatIdV, NegCatIdV, SubTreeCatIdV);
151    TIntV ExtUrlIdV; GetExtUrlIdV(SubTreeCatIdV, ExtUrlIdV);
152    TIntV DIdV(ExtUrlIdV.Len(), 0);
153    for (int ExtUrlIdN=0; ExtUrlIdN<ExtUrlIdV.Len(); ExtUrlIdN++){
154      int DId=BowDocBs->GetDId(TInt::GetStr(ExtUrlIdV[ExtUrlIdN]));
155      DIdV.Add(DId);
156    }
157    SubTreeCatIdV.Clr(); ExtUrlIdV.Clr();
158    PBowSpV ConceptSpV=TBowClust::GetConceptSpV(BowDocWgtBs, BowSim, DIdV);
159    PBowDocPart SubDocPart=_GetBowDocPart(
160      RootCatId, PosCatIdV, NegCatIdV, 
161      BowDocBs, BowDocWgtBs, BowSim, MnCatDocs, Cats, CatN);
162    if (SubDocPart->GetClusts()==0){SubDocPart=0;}
163    PBowDocPartClust DocPartClust=
164     TBowDocPartClust::New(BowDocBs, RootCatNm, 0, DIdV, ConceptSpV, SubDocPart);
165    return DocPartClust;
166  }
167  PBowDocPart TDMozBs::_GetBowDocPart(
168   const int& RootCatId, const TIntV& PosCatIdV, const TIntV& NegCatIdV, 
169   const PBowDocBs& BowDocBs, const PBowDocWgtBs& BowDocWgtBs, const PBowSim& BowSim,
170   const int& MnCatDocs, const int& Cats, int& CatN){
171    TStr RootCatNm=GetCatNm(RootCatId);
172    PBowDocPart DocPart=TBowDocPart::New();
173    DocPart->PutNm(RootCatNm);
174    TIntV SubCatIdV; 
175    if (PosCatIdV.Empty()){GetSubCatIdV(RootCatId, SubCatIdV, true);} 
176    else {SubCatIdV=PosCatIdV;}
177    for (int NegCatIdN=0; NegCatIdN<NegCatIdV.Len(); NegCatIdN++){
178      SubCatIdV.DelIfIn(NegCatIdV[NegCatIdN]);
179    }
180    for (int SubCatIdN=0; SubCatIdN<SubCatIdV.Len(); SubCatIdN++){
181      PBowDocPartClust DocPartClust=GetBowDocPartClust(
182       SubCatIdV[SubCatIdN], TIntV(), TIntV(), BowDocBs, BowDocWgtBs, BowSim, MnCatDocs, Cats, CatN);
183      if (DocPartClust->GetDocs()>=MAX(1, MnCatDocs)){
184        DocPart->AddClust(DocPartClust);}
185    }
186    return DocPart;
187  }
188  PBowDocPart TDMozBs::GetBowDocPart(
189   const TStr& RootCatNm, const TStrV& PosCatNmV, const TStrV& NegCatNmV,
190   const PBowDocBs& BowDocBs, const PBowDocWgtBs& BowDocWgtBs, const PBowSim& BowSim,
191   const int& MnCatDocs){
192    int RootCatId=GetCatId(RootCatNm);
193    TIntV PosCatIdV; GetCatIdV(PosCatNmV, PosCatIdV);
194    TIntV NegCatIdV; GetCatIdV(NegCatNmV, NegCatIdV);
195    TIntV CatIdV; GetSubTreeCatIdV(RootCatId, PosCatIdV, NegCatIdV, CatIdV);
196    int Cats=CatIdV.Len(); int CatN=0; CatIdV.Clr();
197    PBowDocPart DocPart=TBowDocPart::New();
198    DocPart->PutNm("Root");
199    PBowDocPartClust DocPartClust=GetBowDocPartClust(
200     RootCatId, PosCatIdV, NegCatIdV, BowDocBs, BowDocWgtBs, BowSim, MnCatDocs, Cats, CatN);
201    if (DocPartClust->GetDocs()>=MAX(1, MnCatDocs)){
202      DocPart->AddClust(DocPartClust);}
203    return DocPart;
204  }
205  void TDMozBs::_GetBestClustV(
206   const PBowDocPart& BowDocPart, const PBowSim& BowSim,
207   const PBowSpV DocBowSpV, TFltBowDocPartClustKdV& WgtClustKdV){
208    for (int ClustN=0; ClustN<BowDocPart->GetClusts(); ClustN++){
209      PBowDocPartClust Clust=BowDocPart->GetClust(ClustN);
210      IAssert(Clust->IsConceptSpV());
211      double Sim=BowSim->GetCosSim(DocBowSpV, Clust->GetConceptSpV());
212      if (Sim>0){
213        WgtClustKdV.Add(TFltBowDocPartClustKd(Sim, Clust));}
214      if (Clust->IsSubPart()){
215        _GetBestClustV(Clust->GetSubPart(), BowSim, DocBowSpV, WgtClustKdV);
216      }
217    }
218  }
219  void TDMozBs::_GetBestWordVV(
220   TFltBowDocPartClustKdV& WgtClustKdV, const PBowSim& BowSim,
221   const PBowSpV DocBowSpV, TVec<TFltIntPrV>& WgtWIdPrVV){
222    WgtWIdPrVV.Clr();
223    for (int ClustN=0; ClustN<WgtClustKdV.Len(); ClustN++){
224      PBowDocPartClust Clust=WgtClustKdV[ClustN].Dat;
225      TFltIntPrV WgtWIdPrV;
226      BowSim->GetCosSim(DocBowSpV, Clust->GetConceptSpV(), WgtWIdPrV);
227      WgtWIdPrV.Sort(false);
228      double WgtSum=0;
229      for (int WIdN=0; WIdN<WgtWIdPrV.Len(); WIdN++){WgtSum+=WgtWIdPrV[WIdN].Val1;}
230      double CutWgtSum=WgtSum*0.9; double WgtSumSF=0;
231      for (int WIdN=0; WIdN<WgtWIdPrV.Len(); WIdN++){
232        WgtSumSF+=WgtWIdPrV[WIdN].Val1;
233        WgtWIdPrV[WIdN].Val1=WgtWIdPrV[WIdN].Val1/WgtSum;
234        if (WgtSumSF>CutWgtSum){WgtWIdPrV.Trunc(WIdN+1); break;}
235      }
236      WgtWIdPrVV.Add(WgtWIdPrV);
237    }
238  }
239  void TDMozBs::GetBestClustV(
240   const PBowDocPart& BowDocPart, const PBowSim& BowSim,
241   const PBowSpV DocBowSpV, const int& MxCats,
242   TFltBowDocPartClustKdV& WgtClustKdV, TVec<TFltIntPrV>& WgtWIdPrVV){
243    WgtClustKdV.Clr();
244    _GetBestClustV(BowDocPart, BowSim, DocBowSpV, WgtClustKdV);
245    WgtClustKdV.Sort(false);
246    WgtClustKdV.Trunc(MxCats);
247    _GetBestWordVV(WgtClustKdV, BowSim, DocBowSpV, WgtWIdPrVV);
248  }
249  void TDMozBs::GetBestKWordV(
250   const TFltBowDocPartClustKdV& WgtClustKdV, const double& TopWgtSumPrc, 
251   const bool& AddLevP, const int& MnLev, const int& MxLev, 
252   TStrFltPrV& KWordStrWgtPrV){
253    TStrIntH KWordStrToFqH(WgtClustKdV.Len());
254    TStrFltH KWordStrToWgtH(WgtClustKdV.Len());
255    for (int CatN=0; CatN<WgtClustKdV.Len(); CatN++){
256      double CatWgt=WgtClustKdV[CatN].Key;
257      PBowDocPartClust Clust=WgtClustKdV[CatN].Dat;
258      TStr CatNm=Clust->GetNm();
259      TStrV CatKWordStrV;
260      CatNm.SplitOnAllCh('/', CatKWordStrV);
261      for (int CatKWordStrN=0; CatKWordStrN<CatKWordStrV.Len(); CatKWordStrN++){
262        TStr KWordStr=CatKWordStrV[CatKWordStrN];
263        if (KWordStr=="Top"){continue;}
264        if (AddLevP){
265          KWordStr+=TStr::Fmt("-%d", CatKWordStrN);}
266        if (((MnLev==-1)||(MnLev<=CatKWordStrN))&&((MxLev==-1)||(CatKWordStrN<=MxLev))){
267          int KWordFq=KWordStrToFqH.AddDat(KWordStr)++;
268          KWordStrToWgtH.AddDat(KWordStr)+=CatWgt/KWordFq;
269        }
270      }
271    }
272    TFltStrPrV WgtKWordStrV; KWordStrToWgtH.GetDatKeyPrV(WgtKWordStrV);
273    double KWordWgtSum=0;
274    for (int KWordN=0; KWordN<WgtKWordStrV.Len(); KWordN++){
275      KWordWgtSum+=WgtKWordStrV[KWordN].Val1;}
276    double KWordWgtSumSF=0;
277    WgtKWordStrV.Sort(false); KWordStrWgtPrV.Clr();
278    for (int KWordN=0; KWordN<WgtKWordStrV.Len(); KWordN++){
279      TStr KWordStr=WgtKWordStrV[KWordN].Val2;
280      double KWordWgt=WgtKWordStrV[KWordN].Val1;
281      double NrKWordWgt=KWordWgt;
282      if (KWordWgtSum>0){NrKWordWgt=KWordWgt/KWordWgtSum;}
283      KWordStrWgtPrV.Add(TStrFltPr(KWordStr, NrKWordWgt));
284      KWordWgtSumSF+=KWordWgt;
285      if ((KWordWgtSum>0)&&(KWordWgtSumSF/KWordWgtSum>TopWgtSumPrc)){break;}
286    }
287  }
288  PDMozBs TDMozBs::LoadTxt(const TStr& FPath,
289   const bool& StructOnlyP, const bool& SampleDataP,
290   const int& ExtPgStrPoolLen){
291    PDMozBs DMozBs=TDMozBs::New(ExtPgStrPoolLen);
292    TStr DMozNrFPath=TStr::GetNrFPath(FPath); 
293    TStr DMozStructFNm=DMozNrFPath+TDMozInfo::RdfStructFBase;
294    TStr DMozContFNm=DMozNrFPath+TDMozInfo::RdfContentFBase;
295    if (SampleDataP){
296      DMozStructFNm=DMozNrFPath+TDMozInfo::RdfStructSampleFBase;
297      DMozContFNm=DMozNrFPath+TDMozInfo::RdfContentSampleFBase;
298    }
299    THash<TMd5Sig, TDMozAlias> SymMd5ToAliasH;
300    TStrPool AliasStrPool;
301    {printf("Create topic & alias entries ...\n");
302    PSIn DMozStructSIn=TFIn::New(DMozStructFNm);
303    TXmlDoc::SkipTopTag(DMozStructSIn);
304    PXmlDoc XmlDoc; int XmlDocs=0;
305    forever{
306      XmlDocs++;
307      if (XmlDocs%1000==0){
308        printf("%d Docs   %d Topics   %d Aliases   %s Cat-Chars\r",
309         XmlDocs, DMozBs->CatMd5ToTopicH.Len(), SymMd5ToAliasH.Len(),
310         TInt::GetMegaStr(DMozBs->CatNmPool.Len()).CStr());
311      }
312      XmlDoc=TXmlDoc::LoadTxt(DMozStructSIn);
313      if (!XmlDoc->IsOk()){break;}
314      PXmlTok TopTok=XmlDoc->GetTok();
315      if (TopTok->IsTag("Topic")){
316        TStr CatNm=TopTok->GetArgVal("r:id");
317        TMd5Sig CatMd5(CatNm);
318        IAssert(!DMozBs->CatMd5ToTopicH.IsKey(CatMd5));
319        TDMozTopic& DMozTopic=DMozBs->CatMd5ToTopicH.AddDat(CatMd5);
320        DMozTopic.CatSId=DMozBs->CatNmPool.AddStr(CatNm);
321      } else
322      if (TopTok->IsTag("Alias")){
323        TStr SymStr=TopTok->GetArgVal("r:id");
324        TStr TitleStr=TopTok->GetTagTok("d:Title")->GetTokStr(false);
325        TStr SubstStr=TopTok->GetTagTok("Target")->GetArgVal("r:resource");
326        TMd5Sig SymMd5(SymStr);
327        IAssert(!SymMd5ToAliasH.IsKey(SymMd5));
328        TDMozAlias& DMozAlias=SymMd5ToAliasH.AddDat(SymMd5);
329        DMozAlias.SymSId=AliasStrPool.AddStr(SymStr);
330        DMozAlias.SubstSId=AliasStrPool.AddStr(SubstStr);
331      } else {
332        Fail;
333      }
334    }
335    printf("\n... Done.\n");}
336    {printf("Create sub-topics ...\n");
337    PSIn DMozStructSIn=TFIn::New(DMozStructFNm);
338    TXmlDoc::SkipTopTag(DMozStructSIn);
339    PXmlDoc XmlDoc; int XmlDocs=0;
340    forever{
341      XmlDocs++; if (XmlDocs%1000==0){printf("%d Docs\r", XmlDocs);}
342      XmlDoc=TXmlDoc::LoadTxt(DMozStructSIn);
343      if (!XmlDoc->IsOk()){break;}
344      PXmlTok TopTok=XmlDoc->GetTok();
345      if (TopTok->IsTag("Topic")){
346        TStr CatNm=TopTok->GetArgVal("r:id");
347        TMd5Sig CatMd5(CatNm);
348        IAssert(DMozBs->CatMd5ToTopicH.IsKey(CatMd5));
349        TDMozTopic& DMozTopic=DMozBs->CatMd5ToTopicH.GetDat(CatMd5);
350        DMozTopic.SubCatTypeIdVN=DMozBs->SubCatTypeIdPrV.Len();
351        for (int SubTokN=0; SubTokN<TopTok->GetSubToks(); SubTokN++){
352          PXmlTok SubTok=TopTok->GetSubTok(SubTokN);
353          if (!SubTok->IsTag()){continue;}
354          TStr SubTagNm=SubTok->GetTagNm();
355          TDMozSubCatType SubCatType=GetSubCatType(SubTagNm);
356          if (SubCatType!=dmsctUndef){
357            TStr SubCatNm=SubTok->GetArgVal("r:resource");
358            TMd5Sig SubCatMd5(SubCatNm);
359            int SubCatId=DMozBs->CatMd5ToTopicH.GetKeyId(SubCatMd5);
360            if (SubCatId==-1){
361              int AliasId=SymMd5ToAliasH.GetKeyId(SubCatMd5);
362              if (AliasId!=-1){
363                int SubstSId=SymMd5ToAliasH[AliasId].SubstSId;
364                SubCatNm=AliasStrPool.GetStr(SubstSId);
365                SubCatMd5=TMd5Sig(SubCatNm);
366                SubCatId=DMozBs->CatMd5ToTopicH.GetKeyId(SubCatMd5);
367              } else {
368              }
369            }
370            if (SubCatId!=-1){
371              uint SubCatTypeIdPr=GetSubCatTypeIdPr(SubCatType, SubCatId);
372              DMozBs->SubCatTypeIdPrV.Add(SubCatTypeIdPr);
373            }
374          }
375        }
376        if (DMozTopic.SubCatTypeIdVN==DMozBs->SubCatTypeIdPrV.Len()){
377          DMozTopic.SubCatTypeIdVN=-1; 
378        } else {
379          DMozBs->SubCatTypeIdPrV.Add(GetSubCatTypeIdPr(dmsctUndef));
380        }
381      } else
382      if (TopTok->IsTag("Alias")){
383      } else {
384        Fail;
385      }
386    }
387    printf("\n... Done.\n");}
388    SymMd5ToAliasH.Clr();
389    AliasStrPool.Clr();
390    if (!StructOnlyP){
391      {printf("Create external-urls ...\n");
392      PSIn DMozContSIn=TFIn::New(DMozContFNm);
393      TXmlDoc::SkipTopTag(DMozContSIn);
394      PXmlDoc XmlDoc; int XmlDocs=0; int Dupls=0;
395      forever{
396        XmlDocs++;
397        if (XmlDocs%1000==0){
398          printf("%d Docs   %d Duplicates   %d Ext-Urs   %s Ext-Page-Chars\r",
399           XmlDocs, Dupls, 
400           DMozBs->ExtUrlMd5ToUrlTitleDescSIdTrH.Len(),
401           TInt::GetMegaStr(DMozBs->ExtPgStrPool.Len()).CStr());
402        }
403        XmlDoc=TXmlDoc::LoadTxt(DMozContSIn);
404        if (!XmlDoc->IsOk()){break;}
405        PXmlTok TopTok=XmlDoc->GetTok();
406        if (TopTok->IsTag("Topic")){
407          TStr CatNm=TopTok->GetArgVal("r:id");
408          TMd5Sig CatMd5(CatNm);
409          IAssert(DMozBs->CatMd5ToTopicH.IsKey(CatMd5));
410          TDMozTopic& DMozTopic=DMozBs->CatMd5ToTopicH.AddDat(CatMd5);
411          DMozTopic.ExtUrlIdVN=DMozBs->ExtUrlIdV.Len();
412          for (int SubTokN=0; SubTokN<TopTok->GetSubToks(); SubTokN++){
413            PXmlTok SubTok=TopTok->GetSubTok(SubTokN);
414            if (!SubTok->IsTag()){continue;}
415            TStr SubTagNm=SubTok->GetTagNm();
416            if ((SubTagNm!="link")&&(SubTagNm!="link1")){continue;}
417            TStr ExtUrlStr=SubTok->GetArgVal("r:resource");
418            int ExtUrlSId=DMozBs->ExtPgStrPool.AddStr(ExtUrlStr);
419            TMd5Sig ExtUrlMd5(ExtUrlStr); int ExtUrlId=-1;
420            if (DMozBs->ExtUrlMd5ToUrlTitleDescSIdTrH.IsKey(ExtUrlMd5, ExtUrlId)){
421              Dupls++;
422            } else {
423              ExtUrlId=DMozBs->ExtUrlMd5ToUrlTitleDescSIdTrH.AddKey(ExtUrlMd5);
424              DMozBs->ExtUrlMd5ToUrlTitleDescSIdTrH[ExtUrlId]=
425               TIntTr(ExtUrlSId, -1, -1);
426            }
427            DMozBs->ExtUrlIdV.Add(ExtUrlId);
428          }
429          if (DMozTopic.ExtUrlIdVN==DMozBs->ExtUrlIdV.Len()){
430            DMozTopic.ExtUrlIdVN=-1; 
431          } else {
432            DMozBs->ExtUrlIdV.Add(-1);
433          }
434        } else
435        if (TopTok->IsTag("ExternalPage")){
436          TStr ExtUrlStr=TopTok->GetArgVal("about");
437          TStr TitleStr; PXmlTok TitleTok;
438          if (TopTok->IsSubTag("d:Title", TitleTok)){
439            TitleStr=TitleTok->GetTokStr(false);}
440          TStr DescStr; PXmlTok DescTok;
441          if (TopTok->IsSubTag("d:Description", DescTok)){
442            DescStr=DescTok->GetTokStr(false);}
443          TMd5Sig ExtUrlMd5(ExtUrlStr);
444          int ExtUrlKId=DMozBs->ExtUrlMd5ToUrlTitleDescSIdTrH.GetKeyId(ExtUrlMd5);
445          if (ExtUrlKId!=-1){
446            int UrlSId=DMozBs->ExtUrlMd5ToUrlTitleDescSIdTrH[ExtUrlKId].Val1;
447            int TitleSId=DMozBs->ExtPgStrPool.AddStr(TitleStr);
448            int DescSId=DMozBs->ExtPgStrPool.AddStr(DescStr);
449            DMozBs->ExtUrlMd5ToUrlTitleDescSIdTrH[ExtUrlKId]=
450             TIntTr(UrlSId, TitleSId, DescSId);
451          } else {
452            printf("Undefined external url: '%s'\n", ExtUrlStr.CStr());
453          }
454        } else {
455          Fail;
456        }
457      }}
458    }
459    return DMozBs;
460  }
461  PDMozBs TDMozBs::LoadBin(const TStr& FBase, const TStr& FPath){
462    printf("Loading DMoz-Binary '%s' from '%s' ...", FBase.CStr(), FPath.CStr());
463    TStr FNm=TStr::GetNrFPath(FPath)+FBase;
464    TFIn SIn(FNm);
465    PDMozBs DMozBs=new TDMozBs(SIn);
466    printf(" Done.\n");
467    return DMozBs;
468  }
469  void TDMozBs::SaveBin(const TStr& FBase, const TStr& FPath){
470    TStr FNm=TStr::GetNrFPath(FPath)+FBase;
471    TFOut SOut(FNm); Save(SOut);
472  }
473  void TDMozBs::SaveLnDocTxt(const PDMozBs& DMozBs, const TStr& RootCatNm,
474   const TStr& FBase, const TStr& FPath, const bool& SaveMd5P){
475    TStr FNm=TStr::GetNrFPath(FPath)+FBase;
476    printf("Save DMoz-Binary to %s ...\n", FNm.CStr());
477    TFOut FOut(FNm); FILE* fOut=FOut.GetFileId();
478    int Cats=DMozBs->GetCats(); int SavedCats=0;
479    for (int CatId=0; CatId<Cats; CatId++){
480      TStr CatNm=DMozBs->GetCatNm(CatId);
481      if ((!RootCatNm.Empty())&&(!CatNm.IsPrefix(RootCatNm))){continue;}
482      SavedCats++;
483      if (SavedCats%1000==0){printf("  Saved Categories %d\r", SavedCats);}
484      TIntV ExtUrlIdV; DMozBs->GetExtUrlIdV(CatId, ExtUrlIdV);
485      for (int ExtUrlIdN=0; ExtUrlIdN<ExtUrlIdV.Len(); ExtUrlIdN++){
486        int ExtUrlId=ExtUrlIdV[ExtUrlIdN];
487        TStr Md5Str=DMozBs->GetExtUrlMd5Str(ExtUrlId);
488        TStr UrlStr=DMozBs->GetExtUrlStr(ExtUrlId);
489        TStr TitleStr=DMozBs->GetExtUrlTitleStr(ExtUrlId);
490        TStr DescStr=DMozBs->GetExtUrlDescStr(ExtUrlId);
491        if (SaveMd5P){
492          fprintf(fOut, "%s %s -- %s\n", Md5Str.CStr(), TitleStr.CStr(), DescStr.CStr());
493        } else {
494          fprintf(fOut, "%s -- %s\n", TitleStr.CStr(), DescStr.CStr());
495        }
496      }
497    }
498    printf("  Saved Categories %d\n", SavedCats);
499    printf("Done.\n");
500  }
501  void TDMozBs::SaveTxt(const PDMozBs& DMozBs, const TStr& RootCatNm,
502   const TStr& FBase, const TStr& FPath){
503    TStr FNm=TStr::GetNrFPath(FPath)+FBase;
504    printf("Dump DMoz-Binary to %s ...\n", FNm.CStr());
505    TFOut FOut(FNm); FILE* fOut=FOut.GetFileId();
506    int Cats=DMozBs->GetCats(); int SavedCats=0;
507    fprintf(fOut, "#Categories: %d\n", Cats);
508    for (int CatId=0; CatId<Cats; CatId++){
509      TStr CatNm=DMozBs->GetCatNm(CatId);
510      if ((!RootCatNm.Empty())&&(!CatNm.IsPrefix(RootCatNm))){continue;}
511      SavedCats++;
512      if (SavedCats%1000==0){printf("  Saved Categories %d\r", SavedCats);}
513      fprintf(fOut, "cat: '%s'\n", CatNm.CStr());
514      TUIntV SubCatTypeIdPrV; DMozBs->GetSubCatTypeIdPrV(CatId, SubCatTypeIdPrV);
515      for (int SubCatN=0; SubCatN<SubCatTypeIdPrV.Len(); SubCatN++){
516        TDMozSubCatType SubCatType; int SubCatId;
517        TDMozBs::GetSubCatTypeCatId(SubCatTypeIdPrV[SubCatN], SubCatType, SubCatId);
518        TStr SubCatTypeStr=TDMozBs::GetSubCatTypeNm(SubCatType);
519        TStr SubCatNm=DMozBs->GetCatNm(SubCatId);
520        fprintf(fOut, "scat:   [%s] -- '%s'\n", SubCatTypeStr.CStr(), SubCatNm.CStr());
521      }
522      TIntV ExtUrlIdV; DMozBs->GetExtUrlIdV(CatId, ExtUrlIdV);
523      for (int ExtUrlIdN=0; ExtUrlIdN<ExtUrlIdV.Len(); ExtUrlIdN++){
524        int ExtUrlId=ExtUrlIdV[ExtUrlIdN];
525        TStr UrlStr=DMozBs->GetExtUrlStr(ExtUrlId);
526        TStr TitleStr=DMozBs->GetExtUrlTitleStr(ExtUrlId);
527        TStr DescStr=DMozBs->GetExtUrlDescStr(ExtUrlId);
528        fprintf(fOut, "exut:   [%s] -- %s - %s\n", UrlStr.CStr(), TitleStr.CStr(), DescStr.CStr());
529      }
530    }
531    printf("  Saved Categories %d\n", SavedCats);
532    if (RootCatNm.Empty()){
533      int ExtUrls=DMozBs->GetExtUrls();
534      fprintf(fOut, "#External-Urls: %d\n", ExtUrls);
535      for (int ExtUrlId=0; ExtUrlId<ExtUrls; ExtUrlId++){
536        if (ExtUrlId%1000==0){printf("  Saved External URLs %d\r", ExtUrlId);}
537        TStr UrlStr=DMozBs->GetExtUrlStr(ExtUrlId);
538        TStr TitleStr=DMozBs->GetExtUrlTitleStr(ExtUrlId);
539        TStr DescStr=DMozBs->GetExtUrlDescStr(ExtUrlId);
540        fprintf(fOut, "exutd: [%s] %s -- %s\n", UrlStr.CStr(), TitleStr.CStr(), DescStr.CStr());
541      }
542      printf("  Saved External URLs %d\n", ExtUrls);
543    }
544    printf("Done.\n");
545  }
546  void TDMozBs::SaveSampleTxt(const PDMozBs& DMozBs, const TStr& RootCatNm,
547   const TStr& FBase, const TStr& FPath,
548   const int& SampleRndSeed, const int& SampleSize,
549   const bool& SampleSiteUrlP, const bool& SampleStructP){
550    TStrH UrlStrH;
551    if (SampleStructP){
552      int RootCatId=DMozBs->GetCatId(RootCatNm);
553      TRnd Rnd(SampleRndSeed);
554      while (UrlStrH.Len()<SampleSize){
555        int UrlId=DMozBs->GetRndExtUrlId(RootCatId, Rnd);
556        if (UrlId==-1){continue;}
557        TStr UrlStr=DMozBs->GetExtUrlStr(UrlId);
558        if (SampleSiteUrlP){
559          if (TUrl::IsSite(UrlStr)){
560            UrlStrH.AddKey(UrlStr);}
561        } else {
562          UrlStrH.AddKey(UrlStr);
563        }
564      }
565    } else {
566      TStrV PosCatNmV; TStrV NegCatNmV; TIntV CatIdV;
567      DMozBs->GetSubTreeCatIdV(RootCatNm, PosCatNmV, NegCatNmV, CatIdV);
568      TIntV ExtUrlIdV; DMozBs->GetExtUrlIdV(CatIdV, ExtUrlIdV);
569      TRnd Rnd(SampleRndSeed); ExtUrlIdV.Shuffle(Rnd);
570      for (int ExtUrlIdN=0; ExtUrlIdN<ExtUrlIdV.Len(); ExtUrlIdN++){
571        int UrlId=ExtUrlIdV[ExtUrlIdN];
572        TStr UrlStr=DMozBs->GetExtUrlStr(UrlId);
573        if (SampleSiteUrlP){
574          if (TUrl::IsSite(UrlStr)){
575            UrlStrH.AddKey(UrlStr);}
576        } else {
577          UrlStrH.AddKey(UrlStr);
578        }
579        if (UrlStrH.Len()>=SampleSize){break;}
580      }
581    }
582    {TStr FNm=TStr::GetNrFPath(FPath)+FBase;
583    printf("Save Sample to %s ...\n", FNm.CStr());
584    TFOut FOut(FNm); FILE* fOut=FOut.GetFileId();
585    for (int UrlN=0; UrlN<UrlStrH.Len(); UrlN++){
586      fprintf(fOut, "%s\n", UrlStrH.GetKey(UrlN).CStr());
587    }}
588  }
589  TDMozSubCatType TDMozBs::GetSubCatType(const TStr& CatTypeNm){
590    if (CatTypeNm=="narrow"){return dmsctNarrow;}
591    if (CatTypeNm=="narrow1"){return dmsctNarrow;}
592    if (CatTypeNm=="narrow2"){return dmsctNarrow;}
593    if (CatTypeNm=="letterbar"){return dmsctLetterbar;}
594    if (CatTypeNm=="related"){return dmsctRelated;}
595    if (CatTypeNm=="symbolic"){return dmsctSymbolic;}
596    else {return dmsctUndef;}
597  }
598  TStr TDMozBs::GetSubCatTypeNm(const TDMozSubCatType& SubCatType){
599    switch (SubCatType){
600      case dmsctUndef: return "Undef";
601      case dmsctNarrow: return "Narrow";
602      case dmsctLetterbar: return "Letterbar";
603      case dmsctRelated: return "Related";
604      case dmsctSymbolic: return "Symbolic";
605      default: Fail; return TStr();
606    }
607  }
608  uint TDMozBs::GetSubCatTypeIdPr(
609   const TDMozSubCatType& SubCatType, const int& CatId){
610    IAssert((CatId & 0xFF000000)==0);
611    uint SubCatTypeIdPr=(SubCatType<<24)+CatId;
612    return SubCatTypeIdPr;
613  }
614  void TDMozBs::GetSubCatTypeCatId(
615   const uint& SubCatTypeIdPr, TDMozSubCatType& SubCatType, int& CatId){
616    SubCatType=TDMozSubCatType((SubCatTypeIdPr & 0xFF000000)>>24);
617    CatId=SubCatTypeIdPr & 0x00FFFFFF;
618  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-yahoodm.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-dmoz.cpp</div>
                </div>
                <div class="column column_space"><pre><code>205      BestWordIdV.Add(WordId);
206      WordIdN++;
207    }}
208  }
209  void TYFSelBs::SaveTxt(
210   const PSOut& SOut, const PYBs& YBs, const PYDsBs& YDsBs){
</pre></code></div>
                <div class="column column_space"><pre><code>26        _SubCatTypeIdPrV.Add(SubCatTypeIdPr);
27        SubCatTypeIdVN++;
28      }
29    }
30  }
31  void TDMozBs::GetSubCatIdV(
32   const int& CatId, TIntV& SubCatIdV, const bool& SubTreeOnlyP) const {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    