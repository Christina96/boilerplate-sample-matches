
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 14, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-recodebeam_test.cc</h3>
            <pre><code>1  #include "include_gunit.h"
2  #include "log.h" 
3  #include "matrix.h"
4  #include "normstrngs.h"
5  #include "pageres.h"
6  #include "ratngs.h"
7  #include "recodebeam.h"
8  #include "unicharcompress.h"
9  #include "unicharset_training_utils.h"
10  #include "helpers.h"
11  namespace tesseract {
12  const int kNumChars = 100;
13  const int kPadding = 64;
14  const char *kGWRTops[] = {"G", "e", "f", " ", "s", " ", "w", "o", "r",    "d",
15                            "s", "",  "r", "i", "g", "h", "t", ".", nullptr};
16  const float kGWRTopScores[] = {0.99, 0.85, 0.87, 0.55, 0.99, 0.65, 0.89, 0.99, 0.99,
17                                 0.99, 0.99, 0.95, 0.99, 0.90, 0.90, 0.90, 0.95, 0.75};
18  const char *kGWR2nds[] = {"C", "c", "t", "",  "S", "",  "W", "O", "t",    "h",
19                            "S", " ", "t", "I", "9", "b", "f", ",", nullptr};
20  const float kGWR2ndScores[] = {0.01, 0.10, 0.12, 0.42, 0.01, 0.25, 0.10, 0.01, 0.01,
21                                 0.01, 0.01, 0.05, 0.01, 0.09, 0.09, 0.09, 0.05, 0.25};
22  const char *kZHTops[] = {"实", "学", "储", "啬", "投", "学", "生", nullptr};
23  const float kZHTopScores[] = {0.98, 0.98, 0.98, 0.98, 0.98, 0.98, 0.98};
24  const char *kZH2nds[] = {"学", "储", "投", "生", "学", "生", "实", nullptr};
25  const float kZH2ndScores[] = {0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01};
26  const char *kViTops[] = {"v", "ậ", "y", " ", "t", "ộ", "i", nullptr};
27  const float kViTopScores[] = {0.98, 0.98, 0.98, 0.98, 0.98, 0.98, 0.97};
28  const char *kVi2nds[] = {"V", "a", "v", "", "l", "o", "", nullptr};
29  const float kVi2ndScores[] = {0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01};
30  class RecodeBeamTest : public ::testing::Test {
31  protected:
32    void SetUp() override {
33      std::locale::global(std::locale(""));
34      file::MakeTmpdir();
35    }
36    RecodeBeamTest() : lstm_dict_(&ccutil_) {}
37    ~RecodeBeamTest() override {
38      lstm_dict_.End();
39    }
40    void LoadUnicharset(const std::string &unicharset_name) {
41      std::string radical_stroke_file = file::JoinPath(LANGDATA_DIR, "radical-stroke.txt");
42      std::string unicharset_file = file::JoinPath(TESTDATA_DIR, unicharset_name);
43      std::string radical_data;
44      CHECK_OK(file::GetContents(radical_stroke_file, &radical_data, file::Defaults()));
45      CHECK(ccutil_.unicharset.load_from_file(unicharset_file.c_str()));
46      unichar_null_char_ =
47          ccutil_.unicharset.has_special_codes() ? UNICHAR_BROKEN : ccutil_.unicharset.size();
48      std::string radical_str(radical_data.c_str());
49      EXPECT_TRUE(recoder_.ComputeEncoding(ccutil_.unicharset, unichar_null_char_, &radical_str));
50      RecodedCharID code;
51      recoder_.EncodeUnichar(unichar_null_char_, &code);
52      encoded_null_char_ = code(0);
53      recoder_.EncodeUnichar(UNICHAR_SPACE, &code);
54      EXPECT_EQ(UNICHAR_SPACE, code(0));
55      std::string output_name = file::JoinPath(FLAGS_test_tmpdir, "testenc.txt");
56      std::string encoding = recoder_.GetEncodingAsString(ccutil_.unicharset);
57      std::string encoding_str(&encoding[0], encoding.size());
58      CHECK_OK(file::SetContents(output_name, encoding_str, file::Defaults()));
59      LOG(INFO) << "Wrote encoding to:" << output_name << "\n";
60    }
61    void LoadDict(const std::string &lang) {
62      std::string traineddata_name = lang + ".traineddata";
63      std::string traineddata_file = file::JoinPath(TESTDATA_DIR, traineddata_name);
64      lstm_dict_.SetupForLoad(nullptr);
65      tesseract::TessdataManager mgr;
66      mgr.Init(traineddata_file.c_str());
<span onclick='openModal()' class='match'>67      lstm_dict_.LoadLSTM(lang.c_str(), &mgr);
68      lstm_dict_.FinishLoad();
</span>69    }
70    void ExpectCorrect(const GENERIC_2D_ARRAY<float> &output,
71                       const std::vector<int> &transcription) {
72      std::string truth_utf8;
73      for (int i : transcription) {
74        truth_utf8 += ccutil_.unicharset.id_to_unichar(i);
75      }
76      PointerVector<WERD_RES> words;
77      ExpectCorrect(output, truth_utf8, nullptr, &words);
78    }
79    void ExpectCorrect(const GENERIC_2D_ARRAY<float> &output, const std::string &truth_utf8,
80                       Dict *dict, PointerVector<WERD_RES> *words) {
81      RecodeBeamSearch beam_search(recoder_, encoded_null_char_, false, dict);
82      beam_search.Decode(output, 3.5, -0.125, -25.0, nullptr);
83      std::vector<int> labels, xcoords;
84      beam_search.ExtractBestPathAsLabels(&labels, &xcoords);
85      LOG(INFO) << "Labels size = " << labels.size() << " coords " << xcoords.size() << "\n";
86      std::string decoded;
87      int end = 1;
88      for (unsigned start = 0; start < labels.size(); start = end) {
89        RecodedCharID code;
90        unsigned index = start;
91        int uni_id = INVALID_UNICHAR_ID;
92        do {
93          code.Set(code.length(), labels[index++]);
94          uni_id = recoder_.DecodeUnichar(code);
95        } while (index < labels.size() && code.length() < RecodedCharID::kMaxCodeLen &&
96                 (uni_id == INVALID_UNICHAR_ID || !recoder_.IsValidFirstCode(labels[index])));
97        EXPECT_NE(INVALID_UNICHAR_ID, uni_id) << "index=" << index << "/" << labels.size();
98        if (uni_id != unichar_null_char_ && decoded.size() < truth_utf8.size()) {
99          decoded += ccutil_.unicharset.id_to_unichar(uni_id);
100        }
101        end = index;
102      }
103      EXPECT_EQ(truth_utf8, decoded);
104      std::vector<int> unichar_ids;
105      std::vector<float> certainties, ratings;
106      beam_search.ExtractBestPathAsUnicharIds(false, &ccutil_.unicharset, &unichar_ids, &certainties,
107                                              &ratings, &xcoords);
108      std::string u_decoded;
109      float total_rating = 0.0f;
110      for (unsigned u = 0; u < unichar_ids.size(); ++u) {
111        if (u_decoded.size() < truth_utf8.size()) {
112          const char *str = ccutil_.unicharset.id_to_unichar(unichar_ids[u]);
113          total_rating += ratings[u];
114          LOG(INFO) << u << ":u_id=" << unichar_ids[u] << "=" << str << ", c="
115            << certainties[u] << ", r=" << ratings[u] << "r_sum="
116            << total_rating << " @" << xcoords[u] << "\n";
117          if (str[0] == ' ') {
118            total_rating = 0.0f;
119          }
120          u_decoded += str;
121        }
122      }
123      EXPECT_EQ(truth_utf8, u_decoded);
124      TBOX line_box(0, 0, 100, 10);
125      for (int i = 0; i < 2; ++i) {
126        beam_search.ExtractBestPathAsWords(line_box, 1.0f, false, &ccutil_.unicharset, words);
127        std::string w_decoded;
128        for (int w = 0; w < words->size(); ++w) {
129          const WERD_RES *word = (*words)[w];
130          if (w_decoded.size() < truth_utf8.size()) {
131            if (!w_decoded.empty() && word->word->space()) {
132              w_decoded += " ";
133            }
134            w_decoded += word->best_choice->unichar_string().c_str();
135          }
136          LOG(INFO) << "Word:" << w << " = " << word->best_choice->unichar_string()
137            << ", c=" << word->best_choice->certainty() << ", r=" << word->best_choice->rating()
138            << ", perm=" << word->best_choice->permuter() << "\n";
139        }
140        std::string w_trunc(w_decoded.data(), truth_utf8.size());
141        if (truth_utf8 != w_trunc) {
142          tesseract::NormalizeUTF8String(
143              tesseract::UnicodeNormMode::kNFKD, tesseract::OCRNorm::kNormalize,
144              tesseract::GraphemeNorm::kNone, w_decoded.c_str(), &w_decoded);
145          w_trunc.assign(w_decoded.data(), truth_utf8.size());
146        }
147        EXPECT_EQ(truth_utf8, w_trunc);
148      }
149    }
150    GENERIC_2D_ARRAY<float> GenerateRandomPaddedOutputs(const std::vector<int> &unichar_ids,
151                                                        int padding) {
152      int width = unichar_ids.size() * 2 * RecodedCharID::kMaxCodeLen;
153      int num_codes = recoder_.code_range();
154      GENERIC_2D_ARRAY<float> outputs(width + padding, num_codes, 0.0f);
155      TRand random;
156      for (int t = 0; t < width; ++t) {
157        for (int i = 0; i < num_codes; ++i) {
158          outputs(t, i) = random.UnsignedRand(0.25);
159        }
160      }
161      int t = 0;
162      for (int unichar_id : unichar_ids) {
163        RecodedCharID code;
164        int len = recoder_.EncodeUnichar(unichar_id, &code);
165        EXPECT_NE(0, len);
166        for (int j = 0; j < len; ++j) {
167          if (j > 0 && code(j) == code(j - 1)) {
168            outputs(t++, encoded_null_char_) = 1.0f;
169          }
170          outputs(t++, code(j)) = 1.0f;
171        }
172        outputs(t++, encoded_null_char_) = 1.0f;
173      }
174      for (int t = 0; t < width; ++t) {
175        double sum = 0.0;
176        for (int i = 0; i < num_codes; ++i) {
177          sum += outputs(t, i);
178        }
179        for (int i = 0; i < num_codes; ++i) {
180          outputs(t, i) /= sum;
181        }
182      }
183      return outputs;
184    }
185    int EncodeUTF8(const char *utf8_str, float score, int start_t, TRand *random,
186                   GENERIC_2D_ARRAY<float> *outputs) {
187      int t = start_t;
188      std::vector<int> unichar_ids;
189      EXPECT_TRUE(ccutil_.unicharset.encode_string(utf8_str, true, &unichar_ids, nullptr, nullptr));
190      if (unichar_ids.empty() || utf8_str[0] == '\0') {
191        unichar_ids.clear();
192        unichar_ids.push_back(unichar_null_char_);
193      }
194      int num_ids = unichar_ids.size();
195      for (int u = 0; u < num_ids; ++u) {
196        RecodedCharID code;
197        int len = recoder_.EncodeUnichar(unichar_ids[u], &code);
198        EXPECT_NE(0, len);
199        for (int i = 0; i < len; ++i) {
200          (*outputs)(t++, code(i)) = score;
201          if (random != nullptr && t + (num_ids - u) * RecodedCharID::kMaxCodeLen < outputs->dim1()) {
202            int dups = static_cast<int>(random->UnsignedRand(3.0));
203            for (int d = 0; d < dups; ++d) {
204              (*outputs)(t++, code(i)) = score;
205            }
206          }
207        }
208        if (random != nullptr && t + (num_ids - u) * RecodedCharID::kMaxCodeLen < outputs->dim1()) {
209          int dups = static_cast<int>(random->UnsignedRand(3.0));
210          for (int d = 0; d < dups; ++d) {
211            (*outputs)(t++, encoded_null_char_) = score;
212          }
213        }
214      }
215      return t;
216    }
217    GENERIC_2D_ARRAY<float> GenerateSyntheticOutputs(const char *chars1[], const float scores1[],
218                                                     const char *chars2[], const float scores2[],
219                                                     TRand *random) {
220      int width = 0;
221      while (chars1[width] != nullptr) {
222        ++width;
223      }
224      int padding = width * RecodedCharID::kMaxCodeLen;
225      int num_codes = recoder_.code_range();
226      GENERIC_2D_ARRAY<float> outputs(width + padding, num_codes, 0.0f);
227      int t = 0;
228      for (int i = 0; i < width; ++i) {
229        int end_t2 = EncodeUTF8(chars2[i], scores2[i], t, random, &outputs);
230        int end_t1 = EncodeUTF8(chars1[i], scores1[i], t, random, &outputs);
231        int max_t = std::max(end_t1, end_t2);
232        while (t < max_t) {
233          double total_score = 0.0;
234          for (int j = 0; j < num_codes; ++j) {
235            total_score += outputs(t, j);
236          }
237          double null_remainder = (1.0 - total_score) / 2.0;
238          double remainder = null_remainder / (num_codes - 2);
239          if (outputs(t, encoded_null_char_) < null_remainder) {
240            outputs(t, encoded_null_char_) += null_remainder;
241          } else {
242            remainder += remainder;
243          }
244          for (int j = 0; j < num_codes; ++j) {
245            if (outputs(t, j) == 0.0f) {
246              outputs(t, j) = remainder;
247            }
248          }
249          ++t;
250        }
251      }
252      while (t < width + padding) {
253        outputs(t++, encoded_null_char_) = 1.0f;
254      }
255      return outputs;
256    }
257    UnicharCompress recoder_;
258    int unichar_null_char_ = 0;
259    int encoded_null_char_ = 0;
260    CCUtil ccutil_;
261    Dict lstm_dict_;
262  };
263  TEST_F(RecodeBeamTest, DoesChinese) {
264    LOG(INFO) << "Testing chi_tra"
265              << "\n";
266    LoadUnicharset("chi_tra.unicharset");
267    std::vector<int> transcription;
268    for (int i = SPECIAL_UNICHAR_CODES_COUNT; i < kNumChars; ++i) {
269      transcription.push_back(i);
270    }
271    GENERIC_2D_ARRAY<float> outputs = GenerateRandomPaddedOutputs(transcription, kPadding);
272    ExpectCorrect(outputs, transcription);
273    LOG(INFO) << "Testing chi_sim"
274              << "\n";
275    LoadUnicharset("chi_sim.unicharset");
276    transcription.clear();
277    for (int i = SPECIAL_UNICHAR_CODES_COUNT; i < kNumChars; ++i) {
278      transcription.push_back(i);
279    }
280    outputs = GenerateRandomPaddedOutputs(transcription, kPadding);
281    ExpectCorrect(outputs, transcription);
282  }
283  TEST_F(RecodeBeamTest, DoesJapanese) {
284    LOG(INFO) << "Testing jpn"
285              << "\n";
286    LoadUnicharset("jpn.unicharset");
287    std::vector<int> transcription;
288    for (int i = SPECIAL_UNICHAR_CODES_COUNT; i < kNumChars; ++i) {
289      transcription.push_back(i);
290    }
291    GENERIC_2D_ARRAY<float> outputs = GenerateRandomPaddedOutputs(transcription, kPadding);
292    ExpectCorrect(outputs, transcription);
293  }
294  TEST_F(RecodeBeamTest, DoesKorean) {
295    LOG(INFO) << "Testing kor"
296              << "\n";
297    LoadUnicharset("kor.unicharset");
298    std::vector<int> transcription;
299    for (int i = SPECIAL_UNICHAR_CODES_COUNT; i < kNumChars; ++i) {
300      transcription.push_back(i);
301    }
302    GENERIC_2D_ARRAY<float> outputs = GenerateRandomPaddedOutputs(transcription, kPadding);
303    ExpectCorrect(outputs, transcription);
304  }
305  TEST_F(RecodeBeamTest, DoesKannada) {
306    LOG(INFO) << "Testing kan"
307              << "\n";
308    LoadUnicharset("kan.unicharset");
309    std::vector<int> transcription;
310    for (int i = SPECIAL_UNICHAR_CODES_COUNT; i < kNumChars; ++i) {
311      transcription.push_back(i);
312    }
313    GENERIC_2D_ARRAY<float> outputs = GenerateRandomPaddedOutputs(transcription, kPadding);
314    ExpectCorrect(outputs, transcription);
315  }
316  TEST_F(RecodeBeamTest, DoesMarathi) {
317    LOG(INFO) << "Testing mar"
318              << "\n";
319    LoadUnicharset("mar.unicharset");
320    std::vector<int> transcription;
321    for (int i = SPECIAL_UNICHAR_CODES_COUNT; i < kNumChars; ++i) {
322      transcription.push_back(i);
323    }
324    GENERIC_2D_ARRAY<float> outputs = GenerateRandomPaddedOutputs(transcription, kPadding);
325    ExpectCorrect(outputs, transcription);
326  }
327  TEST_F(RecodeBeamTest, DoesEnglish) {
328    LOG(INFO) << "Testing eng"
329              << "\n";
330    LoadUnicharset("eng.unicharset");
331    std::vector<int> transcription;
332    for (int i = SPECIAL_UNICHAR_CODES_COUNT; i < kNumChars; ++i) {
333      transcription.push_back(i);
334    }
335    GENERIC_2D_ARRAY<float> outputs = GenerateRandomPaddedOutputs(transcription, kPadding);
336    ExpectCorrect(outputs, transcription);
337  }
338  TEST_F(RecodeBeamTest, DISABLED_EngDictionary) {
339    LOG(INFO) << "Testing eng dictionary"
340              << "\n";
341    LoadUnicharset("eng_beam.unicharset");
342    GENERIC_2D_ARRAY<float> outputs =
343        GenerateSyntheticOutputs(kGWRTops, kGWRTopScores, kGWR2nds, kGWR2ndScores, nullptr);
344    std::string default_str;
345    for (int i = 0; kGWRTops[i] != nullptr; ++i) {
346      default_str += kGWRTops[i];
347    }
348    PointerVector<WERD_RES> words;
349    ExpectCorrect(outputs, default_str, nullptr, &words);
350    LoadDict("eng_beam");
351    ExpectCorrect(outputs, "Gets words right.", &lstm_dict_, &words);
352  }
353  TEST_F(RecodeBeamTest, DISABLED_ChiDictionary) {
354    LOG(INFO) << "Testing zh_hans dictionary"
355              << "\n";
356    LoadUnicharset("zh_hans.unicharset");
357    GENERIC_2D_ARRAY<float> outputs =
358        GenerateSyntheticOutputs(kZHTops, kZHTopScores, kZH2nds, kZH2ndScores, nullptr);
359    PointerVector<WERD_RES> words;
360    ExpectCorrect(outputs, "实学储啬投学生", nullptr, &words);
361    EXPECT_EQ(7, words.size());
362    for (int w = 0; w < words.size(); ++w) {
363      EXPECT_EQ(TOP_CHOICE_PERM, words[w]->best_choice->permuter());
364    }
365    LoadDict("zh_hans");
366    ExpectCorrect(outputs, "实学储啬投学生", &lstm_dict_, &words);
367    const int kNumWords = 5;
368    const char *kWords[kNumWords] = {"实学", "储", "啬", "投", "学生"};
369    const int kWordPerms[kNumWords] = {SYSTEM_DAWG_PERM, TOP_CHOICE_PERM, TOP_CHOICE_PERM,
370                                       TOP_CHOICE_PERM, SYSTEM_DAWG_PERM};
371    EXPECT_EQ(kNumWords, words.size());
372    for (int w = 0; w < kNumWords && w < words.size(); ++w) {
373      EXPECT_STREQ(kWords[w], words[w]->best_choice->unichar_string().c_str());
374      EXPECT_EQ(kWordPerms[w], words[w]->best_choice->permuter());
375    }
376  }
377  TEST_F(RecodeBeamTest, DISABLED_MultiCodeSequences) {
378    LOG(INFO) << "Testing duplicates in multi-code sequences"
379              << "\n";
380    LoadUnicharset("vie.d.unicharset");
381    tesseract::SetupBasicProperties(false, true, &ccutil_.unicharset);
382    TRand random;
383    GENERIC_2D_ARRAY<float> outputs =
384        GenerateSyntheticOutputs(kViTops, kViTopScores, kVi2nds, kVi2ndScores, &random);
385    PointerVector<WERD_RES> words;
386    std::string truth_str;
387    tesseract::NormalizeUTF8String(tesseract::UnicodeNormMode::kNFKC, tesseract::OCRNorm::kNormalize,
388                                   tesseract::GraphemeNorm::kNone, "vậy tội", &truth_str);
389    ExpectCorrect(outputs, truth_str, nullptr, &words);
390  }
391  } 
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-equationdetect.cpp</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #  include "config_auto.h"
3  #endif
4  #include "equationdetect.h"
5  #include "bbgrid.h"
6  #include "classify.h"
7  #include "colpartition.h"
8  #include "colpartitiongrid.h"
9  #include "colpartitionset.h"
10  #include "ratngs.h"
11  #include "tesseractclass.h"
12  #include "helpers.h"
13  #include <algorithm>
14  #include <cfloat>
15  #include <cmath>
16  #include <limits>
17  #include <memory>
18  namespace tesseract {
19  static BOOL_VAR(equationdetect_save_bi_image, false, "Save input bi image");
20  static BOOL_VAR(equationdetect_save_spt_image, false, "Save special character image");
21  static BOOL_VAR(equationdetect_save_seed_image, false, "Save the seed image");
22  static BOOL_VAR(equationdetect_save_merged_image, false, "Save the merged image");
23  static int SortCPByTopReverse(const void *p1, const void *p2) {
24    const ColPartition *cp1 = *static_cast<ColPartition *const *>(p1);
25    const ColPartition *cp2 = *static_cast<ColPartition *const *>(p2);
26    ASSERT_HOST(cp1 != nullptr && cp2 != nullptr);
27    const TBOX &box1(cp1->bounding_box()), &box2(cp2->bounding_box());
28    return box2.top() - box1.top();
29  }
30  static int SortCPByBottom(const void *p1, const void *p2) {
31    const ColPartition *cp1 = *static_cast<ColPartition *const *>(p1);
32    const ColPartition *cp2 = *static_cast<ColPartition *const *>(p2);
33    ASSERT_HOST(cp1 != nullptr && cp2 != nullptr);
34    const TBOX &box1(cp1->bounding_box()), &box2(cp2->bounding_box());
35    return box1.bottom() - box2.bottom();
36  }
37  static int SortCPByHeight(const void *p1, const void *p2) {
38    const ColPartition *cp1 = *static_cast<ColPartition *const *>(p1);
39    const ColPartition *cp2 = *static_cast<ColPartition *const *>(p2);
40    ASSERT_HOST(cp1 != nullptr && cp2 != nullptr);
41    const TBOX &box1(cp1->bounding_box()), &box2(cp2->bounding_box());
42    return box1.height() - box2.height();
43  }
44  const float kMathDigitDensityTh1 = 0.25;
45  const float kMathDigitDensityTh2 = 0.1;
46  const float kMathItalicDensityTh = 0.5;
47  const float kUnclearDensityTh = 0.25;
48  const int kSeedBlobsCountTh = 10;
49  const int kLeftIndentAlignmentCountTh = 1;
50  inline bool IsTextOrEquationType(PolyBlockType type) {
51    return PTIsTextType(type) || type == PT_EQUATION;
52  }
53  inline bool IsLeftIndented(const EquationDetect::IndentType type) {
54    return type == EquationDetect::LEFT_INDENT || type == EquationDetect::BOTH_INDENT;
55  }
56  inline bool IsRightIndented(const EquationDetect::IndentType type) {
57    return type == EquationDetect::RIGHT_INDENT || type == EquationDetect::BOTH_INDENT;
58  }
59  EquationDetect::EquationDetect(const char *equ_datapath, const char *equ_name) {
60    const char *default_name = "equ";
61    if (equ_name == nullptr) {
62      equ_name = default_name;
63    }
64    lang_tesseract_ = nullptr;
65    resolution_ = 0;
66    page_count_ = 0;
67    if (equ_tesseract_.init_tesseract(equ_datapath, equ_name, OEM_TESSERACT_ONLY)) {
68      tprintf(
69          "Warning: equation region detection requested,"
70          " but %s failed to load from %s\n",
71          equ_name, equ_datapath);
72    }
73    cps_super_bbox_ = nullptr;
74  }
75  EquationDetect::~EquationDetect() {
76    delete (cps_super_bbox_);
77  }
78  void EquationDetect::SetLangTesseract(Tesseract *lang_tesseract) {
79    lang_tesseract_ = lang_tesseract;
80  }
81  void EquationDetect::SetResolution(const int resolution) {
82    resolution_ = resolution;
83  }
84  int EquationDetect::LabelSpecialText(TO_BLOCK *to_block) {
85    if (to_block == nullptr) {
86      tprintf("Warning: input to_block is nullptr!\n");
87      return -1;
88    }
89    std::vector<BLOBNBOX_LIST *> blob_lists;
90    blob_lists.push_back(&(to_block->blobs));
91    blob_lists.push_back(&(to_block->large_blobs));
92    for (auto &blob_list : blob_lists) {
93      BLOBNBOX_IT bbox_it(blob_list);
94      for (bbox_it.mark_cycle_pt(); !bbox_it.cycled_list(); bbox_it.forward()) {
95        bbox_it.data()->set_special_text_type(BSTT_NONE);
96      }
97    }
98    return 0;
99  }
100  void EquationDetect::IdentifySpecialText(BLOBNBOX *blobnbox, const int height_th) {
101    ASSERT_HOST(blobnbox != nullptr);
102    if (blobnbox->bounding_box().height() < height_th && height_th > 0) {
103      blobnbox->set_special_text_type(BSTT_NONE);
104      return;
105    }
106    BLOB_CHOICE_LIST ratings_equ, ratings_lang;
107    C_BLOB *blob = blobnbox->cblob();
108    TBLOB *tblob = TBLOB::PolygonalCopy(false, blob);
109    const TBOX &box = tblob->bounding_box();
110    const float scaling = static_cast<float>(kBlnXHeight) / box.height();
111    const float x_orig = (box.left() + box.right()) / 2.0f, y_orig = box.bottom();
112    std::unique_ptr<TBLOB> normed_blob(new TBLOB(*tblob));
113    normed_blob->Normalize(nullptr, nullptr, nullptr, x_orig, y_orig, scaling, scaling, 0.0f,
114                           static_cast<float>(kBlnBaselineOffset), false, nullptr);
<span onclick='openModal()' class='match'>115    equ_tesseract_.AdaptiveClassifier(normed_blob.get(), &ratings_equ);
116    lang_tesseract_->AdaptiveClassifier(normed_blob.get(), &ratings_lang);
</span>117    delete tblob;
118    BLOB_CHOICE *lang_choice = nullptr, *equ_choice = nullptr;
119    if (ratings_lang.length() > 0) {
120      BLOB_CHOICE_IT choice_it(&ratings_lang);
121      lang_choice = choice_it.data();
122    }
123    if (ratings_equ.length() > 0) {
124      BLOB_CHOICE_IT choice_it(&ratings_equ);
125      equ_choice = choice_it.data();
126    }
127    const float lang_score = lang_choice ? lang_choice->certainty() : -FLT_MAX;
128    const float equ_score = equ_choice ? equ_choice->certainty() : -FLT_MAX;
129    const float kConfScoreTh = -5.0f, kConfDiffTh = 1.8;
130    const float diff = std::fabs(lang_score - equ_score);
131    BlobSpecialTextType type = BSTT_NONE;
132    if (std::fmax(lang_score, equ_score) < kConfScoreTh) {
133      type = BSTT_UNCLEAR;
134    } else if (diff > kConfDiffTh && equ_score > lang_score) {
135      type = BSTT_MATH;
136    } else if (lang_choice) {
137      type = EstimateTypeForUnichar(lang_tesseract_->unicharset, lang_choice->unichar_id());
138    }
139    if (type == BSTT_NONE &&
140        lang_tesseract_->get_fontinfo_table().at(lang_choice->fontinfo_id()).is_italic()) {
141      blobnbox->set_special_text_type(BSTT_ITALIC);
142    } else {
143      blobnbox->set_special_text_type(type);
144    }
145  }
146  BlobSpecialTextType EquationDetect::EstimateTypeForUnichar(const UNICHARSET &unicharset,
147                                                             const UNICHAR_ID id) const {
148    const std::string s = unicharset.id_to_unichar(id);
149    if (unicharset.get_isalpha(id)) {
150      return BSTT_NONE;
151    }
152    if (unicharset.get_ispunctuation(id)) {
153      static std::vector<UNICHAR_ID> ids_to_exclude;
154      if (ids_to_exclude.empty()) {
155        static const char *kCharsToEx[] = {"'",  "`",  "\"", "\\", ",",  ".",
156                                           "〈", "〉", "《", "》", "」", "「"};
157        for (auto &i : kCharsToEx) {
158          ids_to_exclude.push_back(unicharset.unichar_to_id(i));
159        }
160        std::sort(ids_to_exclude.begin(), ids_to_exclude.end());
161      }
162      auto found = std::binary_search(ids_to_exclude.begin(), ids_to_exclude.end(), id);
163      return found ? BSTT_NONE : BSTT_MATH;
164    }
165    static const char kDigitsChars[] = "|";
166    if (unicharset.get_isdigit(id) || (s.length() == 1 && strchr(kDigitsChars, s[0]) != nullptr)) {
167      return BSTT_DIGIT;
168    } else {
169      return BSTT_MATH;
170    }
171  }
172  void EquationDetect::IdentifySpecialText() {
173    equ_tesseract_.tess_cn_matching.set_value(true); 
174    equ_tesseract_.tess_bn_matching.set_value(false);
175    const int classify_class_pruner = lang_tesseract_->classify_class_pruner_multiplier;
176    const int classify_integer_matcher = lang_tesseract_->classify_integer_matcher_multiplier;
177    lang_tesseract_->classify_class_pruner_multiplier.set_value(0);
178    lang_tesseract_->classify_integer_matcher_multiplier.set_value(0);
179    ColPartitionGridSearch gsearch(part_grid_);
180    ColPartition *part = nullptr;
181    gsearch.StartFullSearch();
182    while ((part = gsearch.NextFullSearch()) != nullptr) {
183      if (!IsTextOrEquationType(part->type())) {
184        continue;
185      }
186      IdentifyBlobsToSkip(part);
187      BLOBNBOX_C_IT bbox_it(part->boxes());
188      std::vector<int> blob_heights;
189      for (bbox_it.mark_cycle_pt(); !bbox_it.cycled_list(); bbox_it.forward()) {
190        if (bbox_it.data()->special_text_type() != BSTT_SKIP) {
191          blob_heights.push_back(bbox_it.data()->bounding_box().height());
192        }
193      }
194      std::sort(blob_heights.begin(), blob_heights.end());
195      const int height_th = blob_heights[blob_heights.size() / 2] / 3 * 2;
196      for (bbox_it.mark_cycle_pt(); !bbox_it.cycled_list(); bbox_it.forward()) {
197        if (bbox_it.data()->special_text_type() != BSTT_SKIP) {
198          IdentifySpecialText(bbox_it.data(), height_th);
199        }
200      }
201    }
202    lang_tesseract_->classify_class_pruner_multiplier.set_value(classify_class_pruner);
203    lang_tesseract_->classify_integer_matcher_multiplier.set_value(classify_integer_matcher);
204    if (equationdetect_save_spt_image) { 
205      std::string outfile;
206      GetOutputTiffName("_spt", outfile);
207      PaintSpecialTexts(outfile);
208    }
209  }
210  void EquationDetect::IdentifyBlobsToSkip(ColPartition *part) {
211    ASSERT_HOST(part);
212    BLOBNBOX_C_IT blob_it(part->boxes());
213    for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
214      ASSERT_HOST(!blob_it.data()->joined_to_prev());
215    }
216    for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
217      BLOBNBOX *blob = blob_it.data();
218      if (blob->joined_to_prev() || blob->special_text_type() == BSTT_SKIP) {
219        continue;
220      }
221      TBOX blob_box = blob->bounding_box();
222      BLOBNBOX_C_IT blob_it2 = blob_it;
223      bool found = false;
224      while (!blob_it2.at_last()) {
225        BLOBNBOX *nextblob = blob_it2.forward();
226        const TBOX &nextblob_box = nextblob->bounding_box();
227        if (nextblob_box.left() >= blob_box.right()) {
228          break;
229        }
230        const float kWidthR = 0.4, kHeightR = 0.3;
231        const bool xoverlap = blob_box.major_x_overlap(nextblob_box),
232                   yoverlap = blob_box.y_overlap(nextblob_box);
233        const float widthR = static_cast<float>(std::min(nextblob_box.width(), blob_box.width())) /
234                             std::max(nextblob_box.width(), blob_box.width());
235        const float heightR = static_cast<float>(std::min(nextblob_box.height(), blob_box.height())) /
236                              std::max(nextblob_box.height(), blob_box.height());
237        if (xoverlap && yoverlap && widthR > kWidthR && heightR > kHeightR) {
238          found = true;
239          nextblob->set_special_text_type(BSTT_SKIP);
240          blob_box += nextblob_box;
241        }
242      }
243      if (found) {
244        blob->set_special_text_type(BSTT_SKIP);
245      }
246    }
247  }
248  int EquationDetect::FindEquationParts(ColPartitionGrid *part_grid, ColPartitionSet **best_columns) {
249    if (!lang_tesseract_) {
250      tprintf("Warning: lang_tesseract_ is nullptr!\n");
251      return -1;
252    }
253    if (!part_grid || !best_columns) {
254      tprintf("part_grid/best_columns is nullptr!!\n");
255      return -1;
256    }
257    cp_seeds_.clear();
258    part_grid_ = part_grid;
259    best_columns_ = best_columns;
260    resolution_ = lang_tesseract_->source_resolution();
261    std::string outfile;
262    page_count_++;
263    if (equationdetect_save_bi_image) {
264      GetOutputTiffName("_bi", outfile);
265      pixWrite(outfile.c_str(), lang_tesseract_->pix_binary(), IFF_TIFF_G4);
266    }
267    IdentifySpecialText();
268    MergePartsByLocation();
269    IdentifySeedParts();
270    IdentifyInlineParts();
271    if (equationdetect_save_seed_image) {
272      GetOutputTiffName("_seed", outfile);
273      PaintColParts(outfile);
274    }
275    while (!cp_seeds_.empty()) {
276      std::vector<ColPartition *> seeds_expanded;
277      for (auto &cp_seed : cp_seeds_) {
278        if (ExpandSeed(cp_seed)) {
279          seeds_expanded.push_back(cp_seed);
280        }
281      }
282      for (auto &i : seeds_expanded) {
283        InsertPartAfterAbsorb(i);
284      }
285      cp_seeds_ = seeds_expanded;
286    }
287    ProcessMathBlockSatelliteParts();
288    if (equationdetect_save_merged_image) { 
289      GetOutputTiffName("_merged", outfile);
290      PaintColParts(outfile);
291    }
292    return 0;
293  }
294  void EquationDetect::MergePartsByLocation() {
295    while (true) {
296      ColPartition *part = nullptr;
297      std::vector<ColPartition *> parts_updated;
298      ColPartitionGridSearch gsearch(part_grid_);
299      gsearch.StartFullSearch();
300      while ((part = gsearch.NextFullSearch()) != nullptr) {
301        if (!IsTextOrEquationType(part->type())) {
302          continue;
303        }
304        std::vector<ColPartition *> parts_to_merge;
305        SearchByOverlap(part, &parts_to_merge);
306        if (parts_to_merge.empty()) {
307          continue;
308        }
309        part_grid_->RemoveBBox(part);
310        for (auto &i : parts_to_merge) {
311          ASSERT_HOST(i != nullptr && i != part);
312          part->Absorb(i, nullptr);
313        }
314        gsearch.RepositionIterator();
315        parts_updated.push_back(part);
316      }
317      if (parts_updated.empty()) { 
318        break;
319      }
320      for (auto &i : parts_updated) {
321        InsertPartAfterAbsorb(i);
322      }
323    }
324  }
325  void EquationDetect::SearchByOverlap(ColPartition *seed,
326                                       std::vector<ColPartition *> *parts_overlap) {
327    ASSERT_HOST(seed != nullptr && parts_overlap != nullptr);
328    if (!IsTextOrEquationType(seed->type())) {
329      return;
330    }
331    ColPartitionGridSearch search(part_grid_);
332    const TBOX &seed_box(seed->bounding_box());
333    const int kRadNeighborCells = 30;
334    search.StartRadSearch((seed_box.left() + seed_box.right()) / 2,
335                          (seed_box.top() + seed_box.bottom()) / 2, kRadNeighborCells);
336    search.SetUniqueMode(true);
337    ColPartition *part;
338    std::vector<ColPartition *> parts;
339    const float kLargeOverlapTh = 0.95;
340    const float kEquXOverlap = 0.4, kEquYOverlap = 0.5;
341    while ((part = search.NextRadSearch()) != nullptr) {
342      if (part == seed || !IsTextOrEquationType(part->type())) {
343        continue;
344      }
345      const TBOX &part_box(part->bounding_box());
346      bool merge = false;
347      const float x_overlap_fraction = part_box.x_overlap_fraction(seed_box),
348                  y_overlap_fraction = part_box.y_overlap_fraction(seed_box);
349      if (x_overlap_fraction >= kLargeOverlapTh && y_overlap_fraction >= kLargeOverlapTh) {
350        merge = true;
351      } else if (seed->type() == PT_EQUATION && IsTextOrEquationType(part->type())) {
352        if ((x_overlap_fraction > kEquXOverlap && y_overlap_fraction > 0.0) ||
353            (x_overlap_fraction > 0.0 && y_overlap_fraction > kEquYOverlap)) {
354          merge = true;
355        }
356      }
357      if (merge) { 
358        search.RemoveBBox();
359        parts_overlap->push_back(part);
360      }
361    }
362  }
363  void EquationDetect::InsertPartAfterAbsorb(ColPartition *part) {
364    ASSERT_HOST(part);
365    BlobTextFlowType flow_type = part->flow();
366    PolyBlockType part_type = part->type();
367    BlobRegionType blob_type = part->blob_type();
368    const TBOX &part_box(part->bounding_box());
369    int grid_x, grid_y;
370    part_grid_->GridCoords(part_box.left(), part_box.bottom(), &grid_x, &grid_y);
371    part->SetPartitionType(resolution_, best_columns_[grid_y]);
372    part->set_type(part_type);
373    part->set_blob_type(blob_type);
374    part->set_flow(flow_type);
375    part->SetBlobTypes();
376    part_grid_->InsertBBox(true, true, part);
377  }
378  void EquationDetect::IdentifySeedParts() {
379    ColPartitionGridSearch gsearch(part_grid_);
380    ColPartition *part = nullptr;
381    gsearch.StartFullSearch();
382    std::vector<ColPartition *> seeds1, seeds2;
383    std::vector<int> indented_texts_left;
384    std::vector<float> texts_foreground_density;
385    while ((part = gsearch.NextFullSearch()) != nullptr) {
386      if (!IsTextOrEquationType(part->type())) {
387        continue;
388      }
389      part->ComputeSpecialBlobsDensity();
390      const bool blobs_check = CheckSeedBlobsCount(part);
391      const int kTextBlobsTh = 20;
392      if (CheckSeedDensity(kMathDigitDensityTh1, kMathDigitDensityTh2, part) && blobs_check) {
393        seeds1.push_back(part);
394      } else {
395        IndentType indent = IsIndented(part);
396        if (IsLeftIndented(indent) && blobs_check &&
397            CheckSeedDensity(kMathDigitDensityTh2, kMathDigitDensityTh2, part)) {
398          seeds2.push_back(part);
399        } else if (!IsRightIndented(indent) && part->boxes_count() > kTextBlobsTh) {
400          const TBOX &box = part->bounding_box();
401          if (IsLeftIndented(indent)) {
402            indented_texts_left.push_back(box.left());
403          }
404          texts_foreground_density.push_back(ComputeForegroundDensity(box));
405        }
406      }
407    }
408    std::sort(indented_texts_left.begin(), indented_texts_left.end());
409    std::sort(texts_foreground_density.begin(), texts_foreground_density.end());
410    float foreground_density_th = 0.15; 
411    if (!texts_foreground_density.empty()) {
412      foreground_density_th = 0.8 * texts_foreground_density[texts_foreground_density.size() / 2];
413    }
414    for (auto &i : seeds1) {
415      const TBOX &box = i->bounding_box();
416      if (CheckSeedFgDensity(foreground_density_th, i) &&
417          !(IsLeftIndented(IsIndented(i)) &&
418            CountAlignment(indented_texts_left, box.left()) >= kLeftIndentAlignmentCountTh)) {
419        i->set_type(PT_EQUATION);
420        cp_seeds_.push_back(i);
421      } else { 
422        i->set_type(PT_INLINE_EQUATION);
423      }
424    }
425    for (auto &i : seeds2) {
426      if (CheckForSeed2(indented_texts_left, foreground_density_th, i)) {
427        i->set_type(PT_EQUATION);
428        cp_seeds_.push_back(i);
429      }
430    }
431  }
432  float EquationDetect::ComputeForegroundDensity(const TBOX &tbox) {
433    Image pix_bi = lang_tesseract_->pix_binary();
434    const int pix_height = pixGetHeight(pix_bi);
435    Box *box = boxCreate(tbox.left(), pix_height - tbox.top(), tbox.width(), tbox.height());
436    Image pix_sub = pixClipRectangle(pix_bi, box, nullptr);
437    l_float32 fract;
438    pixForegroundFraction(pix_sub, &fract);
439    pix_sub.destroy();
440    boxDestroy(&box);
441    return fract;
442  }
443  bool EquationDetect::CheckSeedFgDensity(const float density_th, ColPartition *part) {
444    ASSERT_HOST(part);
445    std::vector<TBOX> sub_boxes;
446    SplitCPHorLite(part, &sub_boxes);
447    float parts_passed = 0.0;
448    for (auto &sub_boxe : sub_boxes) {
449      const float density = ComputeForegroundDensity(sub_boxe);
450      if (density < density_th) {
451        parts_passed++;
452      }
453    }
454    const float kSeedPartRatioTh = 0.3;
455    bool retval = (parts_passed / sub_boxes.size() >= kSeedPartRatioTh);
456    return retval;
457  }
458  void EquationDetect::SplitCPHor(ColPartition *part, std::vector<ColPartition *> *parts_splitted) {
459    ASSERT_HOST(part && parts_splitted);
460    if (part->median_width() == 0 || part->boxes_count() == 0) {
461      return;
462    }
463    ColPartition *right_part = part->CopyButDontOwnBlobs();
464    for (auto data : *parts_splitted) {
465      delete data;
466    }
467    parts_splitted->clear();
468    const double kThreshold = part->median_width() * 3.0;
469    bool found_split = true;
470    while (found_split) {
471      found_split = false;
472      BLOBNBOX_C_IT box_it(right_part->boxes());
473      int previous_right = INT32_MIN;
474      for (box_it.mark_cycle_pt(); !box_it.cycled_list(); box_it.forward()) {
475        const TBOX &box = box_it.data()->bounding_box();
476        if (previous_right != INT32_MIN && box.left() - previous_right > kThreshold) {
477          const int mid_x = (box.left() + previous_right) / 2;
478          ColPartition *left_part = right_part;
479          right_part = left_part->SplitAt(mid_x);
480          parts_splitted->push_back(left_part);
481          left_part->ComputeSpecialBlobsDensity();
482          found_split = true;
483          break;
484        }
485        previous_right = std::max(previous_right, static_cast<int>(box.right()));
486      }
487    }
488    right_part->ComputeSpecialBlobsDensity();
489    parts_splitted->push_back(right_part);
490  }
491  void EquationDetect::SplitCPHorLite(ColPartition *part, std::vector<TBOX> *splitted_boxes) {
492    ASSERT_HOST(part && splitted_boxes);
493    splitted_boxes->clear();
494    if (part->median_width() == 0) {
495      return;
496    }
497    const double kThreshold = part->median_width() * 3.0;
498    TBOX union_box;
499    int previous_right = INT32_MIN;
500    BLOBNBOX_C_IT box_it(part->boxes());
501    for (box_it.mark_cycle_pt(); !box_it.cycled_list(); box_it.forward()) {
502      const TBOX &box = box_it.data()->bounding_box();
503      if (previous_right != INT32_MIN && box.left() - previous_right > kThreshold) {
504        splitted_boxes->push_back(union_box);
505        previous_right = INT32_MIN;
506      }
507      if (previous_right == INT32_MIN) {
508        union_box = box;
509      } else {
510        union_box += box;
511      }
512      previous_right = std::max(previous_right, static_cast<int>(box.right()));
513    }
514    if (previous_right != INT32_MIN) {
515      splitted_boxes->push_back(union_box);
516    }
517  }
518  bool EquationDetect::CheckForSeed2(const std::vector<int> &indented_texts_left,
519                                     const float foreground_density_th, ColPartition *part) {
520    ASSERT_HOST(part);
521    const TBOX &box = part->bounding_box();
522    if (!indented_texts_left.empty() &&
523        CountAlignment(indented_texts_left, box.left()) >= kLeftIndentAlignmentCountTh) {
524      return false;
525    }
526    if (ComputeForegroundDensity(box) > foreground_density_th) {
527      return false;
528    }
529    return true;
530  }
531  int EquationDetect::CountAlignment(const std::vector<int> &sorted_vec, const int val) const {
532    if (sorted_vec.empty()) {
533      return 0;
534    }
535    const int kDistTh = static_cast<int>(std::round(0.03f * resolution_));
536    auto pos = std::upper_bound(sorted_vec.begin(), sorted_vec.end(), val);
537    if (pos > sorted_vec.begin()) {
538      --pos;
539    }
540    int count = 0;
541    auto index = pos - sorted_vec.begin();
542    while (index >= 0 && abs(val - sorted_vec[index--]) < kDistTh) {
543      count++;
544    }
545    index = pos + 1 - sorted_vec.begin();
546    while (static_cast<size_t>(index) < sorted_vec.size() && sorted_vec[index++] - val < kDistTh) {
547      count++;
548    }
549    return count;
550  }
551  void EquationDetect::IdentifyInlineParts() {
552    ComputeCPsSuperBBox();
553    IdentifyInlinePartsHorizontal();
554    const int textparts_linespacing = EstimateTextPartLineSpacing();
555    IdentifyInlinePartsVertical(true, textparts_linespacing);
556    IdentifyInlinePartsVertical(false, textparts_linespacing);
557  }
558  void EquationDetect::ComputeCPsSuperBBox() {
559    ColPartitionGridSearch gsearch(part_grid_);
560    ColPartition *part = nullptr;
561    gsearch.StartFullSearch();
562    delete cps_super_bbox_;
563    cps_super_bbox_ = new TBOX();
564    while ((part = gsearch.NextFullSearch()) != nullptr) {
565      (*cps_super_bbox_) += part->bounding_box();
566    }
567  }
568  void EquationDetect::IdentifyInlinePartsHorizontal() {
569    ASSERT_HOST(cps_super_bbox_);
570    std::vector<ColPartition *> new_seeds;
571    const int kMarginDiffTh = IntCastRounded(0.5 * lang_tesseract_->source_resolution());
572    const int kGapTh = static_cast<int>(std::round(1.0f * lang_tesseract_->source_resolution()));
573    ColPartitionGridSearch search(part_grid_);
574    search.SetUniqueMode(true);
575    const int cps_cx = cps_super_bbox_->left() + cps_super_bbox_->width() / 2;
576    for (auto part : cp_seeds_) {
577      const TBOX &part_box(part->bounding_box());
578      const int left_margin = part_box.left() - cps_super_bbox_->left(),
579                right_margin = cps_super_bbox_->right() - part_box.right();
580      bool right_to_left;
581      if (left_margin + kMarginDiffTh < right_margin && left_margin < kMarginDiffTh) {
582        search.StartSideSearch(part_box.right(), part_box.top(), part_box.bottom());
583        right_to_left = false;
584      } else if (left_margin > cps_cx) {
585        search.StartSideSearch(part_box.left(), part_box.top(), part_box.bottom());
586        right_to_left = true;
587      } else { 
588        new_seeds.push_back(part);
589        continue;
590      }
591      ColPartition *neighbor = nullptr;
592      bool side_neighbor_found = false;
593      while ((neighbor = search.NextSideSearch(right_to_left)) != nullptr) {
594        const TBOX &neighbor_box(neighbor->bounding_box());
595        if (!IsTextOrEquationType(neighbor->type()) || part_box.x_gap(neighbor_box) > kGapTh ||
596            !part_box.major_y_overlap(neighbor_box) || part_box.major_x_overlap(neighbor_box)) {
597          continue;
598        }
599        side_neighbor_found = true;
600        break;
601      }
602      if (!side_neighbor_found) { 
603        part->set_type(PT_INLINE_EQUATION);
604      } else {
605        const TBOX &neighbor_box(neighbor->bounding_box());
606        if (neighbor_box.width() > part_box.width() &&
607            neighbor->type() != PT_EQUATION) { 
608          part->set_type(PT_INLINE_EQUATION);
609        } else { 
610          new_seeds.push_back(part);
611        }
612      }
613    }
614    cp_seeds_ = new_seeds;
615  }
616  int EquationDetect::EstimateTextPartLineSpacing() {
617    ColPartitionGridSearch gsearch(part_grid_);
618    ColPartition *current = nullptr, *prev = nullptr;
619    gsearch.StartFullSearch();
620    std::vector<int> ygaps;
621    while ((current = gsearch.NextFullSearch()) != nullptr) {
622      if (!PTIsTextType(current->type())) {
623        continue;
624      }
625      if (prev != nullptr) {
626        const TBOX &current_box = current->bounding_box();
627        const TBOX &prev_box = prev->bounding_box();
628        if (current_box.major_x_overlap(prev_box) && !current_box.y_overlap(prev_box)) {
629          int gap = current_box.y_gap(prev_box);
630          if (gap < std::min(current_box.height(), prev_box.height())) {
631            ygaps.push_back(gap);
632          }
633        }
634      }
635      prev = current;
636    }
637    if (ygaps.size() < 8) { 
638      return -1;
639    }
640    std::sort(ygaps.begin(), ygaps.end());
641    int spacing = 0;
642    unsigned count;
643    for (count = 0; count < ygaps.size() / 2; count++) {
644      spacing += ygaps[count];
645    }
646    return spacing / count;
647  }
648  void EquationDetect::IdentifyInlinePartsVertical(const bool top_to_bottom,
649                                                   const int textparts_linespacing) {
650    if (cp_seeds_.empty()) {
651      return;
652    }
653    if (top_to_bottom) { 
654      std::sort(cp_seeds_.begin(), cp_seeds_.end(), &SortCPByTopReverse);
655    } else { 
656      std::sort(cp_seeds_.begin(), cp_seeds_.end(), &SortCPByBottom);
657    }
658    std::vector<ColPartition *> new_seeds;
659    for (auto part : cp_seeds_) {
660      if (IsInline(!top_to_bottom, textparts_linespacing, part)) {
661        part->set_type(PT_INLINE_EQUATION);
662      } else {
663        new_seeds.push_back(part);
664      }
665    }
666    cp_seeds_ = new_seeds;
667  }
668  bool EquationDetect::IsInline(const bool search_bottom, const int textparts_linespacing,
669                                ColPartition *part) {
670    ASSERT_HOST(part != nullptr);
671    ColPartitionGridSearch search(part_grid_);
672    ColPartition *neighbor = nullptr;
673    const TBOX &part_box(part->bounding_box());
674    const float kYGapRatioTh = 1.0;
675    if (search_bottom) {
676      search.StartVerticalSearch(part_box.left(), part_box.right(), part_box.bottom());
677    } else {
678      search.StartVerticalSearch(part_box.left(), part_box.right(), part_box.top());
679    }
680    search.SetUniqueMode(true);
681    while ((neighbor = search.NextVerticalSearch(search_bottom)) != nullptr) {
682      const TBOX &neighbor_box(neighbor->bounding_box());
683      if (part_box.y_gap(neighbor_box) >
684          kYGapRatioTh * std::min(part_box.height(), neighbor_box.height())) {
685        break;
686      }
687      if (!PTIsTextType(neighbor->type())) {
688        continue;
689      }
690      const float kHeightRatioTh = 0.5;
691      const int kYGapTh = textparts_linespacing > 0
692                              ? textparts_linespacing + static_cast<int>(std::round(0.02f * resolution_))
693                              : static_cast<int>(std::round(0.05f * resolution_)); 
694      if (part_box.x_overlap(neighbor_box) &&                                 
695          part_box.y_gap(neighbor_box) <= kYGapTh &&                          
696          static_cast<float>(std::min(part_box.height(), neighbor_box.height())) /
697                  std::max(part_box.height(), neighbor_box.height()) >
698              kHeightRatioTh) {
699        return true;
700      }
701    }
702    return false;
703  }
704  bool EquationDetect::CheckSeedBlobsCount(ColPartition *part) {
705    if (!part) {
706      return false;
707    }
708    const int kSeedMathBlobsCount = 2;
709    const int kSeedMathDigitBlobsCount = 5;
710    const int blobs = part->boxes_count(), math_blobs = part->SpecialBlobsCount(BSTT_MATH),
711              digit_blobs = part->SpecialBlobsCount(BSTT_DIGIT);
712    if (blobs < kSeedBlobsCountTh || math_blobs <= kSeedMathBlobsCount ||
713        math_blobs + digit_blobs <= kSeedMathDigitBlobsCount) {
714      return false;
715    }
716    return true;
717  }
718  bool EquationDetect::CheckSeedDensity(const float math_density_high, const float math_density_low,
719                                        const ColPartition *part) const {
720    ASSERT_HOST(part);
721    float math_digit_density =
722        part->SpecialBlobsDensity(BSTT_MATH) + part->SpecialBlobsDensity(BSTT_DIGIT);
723    float italic_density = part->SpecialBlobsDensity(BSTT_ITALIC);
724    if (math_digit_density > math_density_high) {
725      return true;
726    }
727    if (math_digit_density + italic_density > kMathItalicDensityTh &&
728        math_digit_density > math_density_low) {
729      return true;
730    }
731    return false;
732  }
733  EquationDetect::IndentType EquationDetect::IsIndented(ColPartition *part) {
734    ASSERT_HOST(part);
735    ColPartitionGridSearch search(part_grid_);
736    ColPartition *neighbor = nullptr;
737    const TBOX &part_box(part->bounding_box());
738    const int kXGapTh = static_cast<int>(std::round(0.5f * resolution_));
739    const int kRadiusTh = static_cast<int>(std::round(3.0f * resolution_));
740    const int kYGapTh = static_cast<int>(std::round(0.5f * resolution_));
741    search.StartRadSearch((part_box.left() + part_box.right()) / 2,
742                          (part_box.top() + part_box.bottom()) / 2, kRadiusTh);
743    search.SetUniqueMode(true);
744    bool left_indented = false, right_indented = false;
745    while ((neighbor = search.NextRadSearch()) != nullptr && (!left_indented || !right_indented)) {
746      if (neighbor == part) {
747        continue;
748      }
749      const TBOX &neighbor_box(neighbor->bounding_box());
750      if (part_box.major_y_overlap(neighbor_box) && part_box.x_gap(neighbor_box) < kXGapTh) {
751        return NO_INDENT;
752      }
753      if (!IsTextOrEquationType(neighbor->type())) {
754        continue;
755      }
756      if (!part_box.x_overlap(neighbor_box) || part_box.y_overlap(neighbor_box)) {
757        continue;
758      }
759      if (part_box.y_gap(neighbor_box) < kYGapTh) {
760        const int left_gap = part_box.left() - neighbor_box.left();
761        const int right_gap = neighbor_box.right() - part_box.right();
762        if (left_gap > kXGapTh) {
763          left_indented = true;
764        }
765        if (right_gap > kXGapTh) {
766          right_indented = true;
767        }
768      }
769    }
770    if (left_indented && right_indented) {
771      return BOTH_INDENT;
772    }
773    if (left_indented) {
774      return LEFT_INDENT;
775    }
776    if (right_indented) {
777      return RIGHT_INDENT;
778    }
779    return NO_INDENT;
780  }
781  bool EquationDetect::ExpandSeed(ColPartition *seed) {
782    if (seed == nullptr ||        
783        seed->IsVerticalType()) { 
784      return false;
785    }
786    std::vector<ColPartition *> parts_to_merge;
787    ExpandSeedHorizontal(true, seed, &parts_to_merge);
788    ExpandSeedHorizontal(false, seed, &parts_to_merge);
789    ExpandSeedVertical(true, seed, &parts_to_merge);
790    ExpandSeedVertical(false, seed, &parts_to_merge);
791    SearchByOverlap(seed, &parts_to_merge);
792    if (parts_to_merge.empty()) { 
793      return false;
794    }
795    part_grid_->RemoveBBox(seed);
796    for (auto part : parts_to_merge) {
797      if (part->type() == PT_EQUATION) {
798        for (auto &cp_seed : cp_seeds_) {
799          if (part == cp_seed) {
800            cp_seed = nullptr;
801            break;
802          }
803        }
804      }
805      seed->Absorb(part, nullptr);
806    }
807    return true;
808  }
809  void EquationDetect::ExpandSeedHorizontal(const bool search_left, ColPartition *seed,
810                                            std::vector<ColPartition *> *parts_to_merge) {
811    ASSERT_HOST(seed != nullptr && parts_to_merge != nullptr);
812    const float kYOverlapTh = 0.6;
813    const int kXGapTh = static_cast<int>(std::round(0.2f * resolution_));
814    ColPartitionGridSearch search(part_grid_);
815    const TBOX &seed_box(seed->bounding_box());
816    const int x = search_left ? seed_box.left() : seed_box.right();
817    search.StartSideSearch(x, seed_box.bottom(), seed_box.top());
818    search.SetUniqueMode(true);
819    ColPartition *part = nullptr;
820    while ((part = search.NextSideSearch(search_left)) != nullptr) {
821      if (part == seed) {
822        continue;
823      }
824      const TBOX &part_box(part->bounding_box());
825      if (part_box.x_gap(seed_box) > kXGapTh) { 
826        break;
827      }
828      if ((part_box.left() >= seed_box.left() && search_left) ||
829          (part_box.right() <= seed_box.right() && !search_left)) {
830        continue;
831      }
832      if (part->type() != PT_EQUATION) { 
833        if (part->type() == PT_INLINE_EQUATION ||
834            (!IsTextOrEquationType(part->type()) && part->blob_type() != BRT_HLINE)) {
835          continue;
836        }
837        if (!IsNearSmallNeighbor(seed_box, part_box) || !CheckSeedNeighborDensity(part)) {
838          continue;
839        }
840      } else { 
841        if (part_box.y_overlap_fraction(seed_box) < kYOverlapTh &&
842            seed_box.y_overlap_fraction(part_box) < kYOverlapTh) {
843          continue;
844        }
845      }
846      search.RemoveBBox();
847      parts_to_merge->push_back(part);
848    }
849  }
850  void EquationDetect::ExpandSeedVertical(const bool search_bottom, ColPartition *seed,
851                                          std::vector<ColPartition *> *parts_to_merge) {
852    ASSERT_HOST(seed != nullptr && parts_to_merge != nullptr && cps_super_bbox_ != nullptr);
853    const float kXOverlapTh = 0.4;
854    const int kYGapTh = static_cast<int>(std::round(0.2f * resolution_));
855    ColPartitionGridSearch search(part_grid_);
856    const TBOX &seed_box(seed->bounding_box());
857    const int y = search_bottom ? seed_box.bottom() : seed_box.top();
858    search.StartVerticalSearch(cps_super_bbox_->left(), cps_super_bbox_->right(), y);
859    search.SetUniqueMode(true);
860    ColPartition *part = nullptr;
861    std::vector<ColPartition *> parts;
862    int skipped_min_top = std::numeric_limits<int>::max(), skipped_max_bottom = -1;
863    while ((part = search.NextVerticalSearch(search_bottom)) != nullptr) {
864      if (part == seed) {
865        continue;
866      }
867      const TBOX &part_box(part->bounding_box());
868      if (part_box.y_gap(seed_box) > kYGapTh) { 
869        break;
870      }
871      if ((part_box.bottom() >= seed_box.bottom() && search_bottom) ||
872          (part_box.top() <= seed_box.top() && !search_bottom)) {
873        continue;
874      }
875      bool skip_part = false;
876      if (part->type() != PT_EQUATION) { 
877        if (part->type() == PT_INLINE_EQUATION ||
878            (!IsTextOrEquationType(part->type()) && part->blob_type() != BRT_HLINE)) {
879          skip_part = true;
880        } else if (!IsNearSmallNeighbor(seed_box, part_box) || !CheckSeedNeighborDensity(part)) {
881          skip_part = true;
882        }
883      } else { 
884        if (part_box.x_overlap_fraction(seed_box) < kXOverlapTh &&
885            seed_box.x_overlap_fraction(part_box) < kXOverlapTh) {
886          skip_part = true;
887        }
888      }
889      if (skip_part) {
890        if (part->type() != PT_EQUATION) {
891          if (skipped_min_top > part_box.top()) {
892            skipped_min_top = part_box.top();
893          }
894          if (skipped_max_bottom < part_box.bottom()) {
895            skipped_max_bottom = part_box.bottom();
896          }
897        }
898      } else {
899        parts.push_back(part);
900      }
901    }
902    for (auto &part : parts) {
903      const TBOX &part_box(part->bounding_box());
904      if ((search_bottom && part_box.top() <= skipped_max_bottom) ||
905          (!search_bottom && part_box.bottom() >= skipped_min_top)) {
906        continue;
907      }
908      parts_to_merge->push_back(part);
909      part_grid_->RemoveBBox(part);
910    }
911  }
912  bool EquationDetect::IsNearSmallNeighbor(const TBOX &seed_box, const TBOX &part_box) const {
913    const int kXGapTh = static_cast<int>(std::round(0.25f * resolution_));
914    const int kYGapTh = static_cast<int>(std::round(0.05f * resolution_));
915    if (part_box.height() > seed_box.height() || part_box.width() > seed_box.width()) {
916      return false;
917    }
918    if ((!part_box.major_x_overlap(seed_box) || part_box.y_gap(seed_box) > kYGapTh) &&
919        (!part_box.major_y_overlap(seed_box) || part_box.x_gap(seed_box) > kXGapTh)) {
920      return false;
921    }
922    return true;
923  }
924  bool EquationDetect::CheckSeedNeighborDensity(const ColPartition *part) const {
925    ASSERT_HOST(part);
926    if (part->boxes_count() < kSeedBlobsCountTh) {
927      return true;
928    }
929    if (part->SpecialBlobsDensity(BSTT_MATH) + part->SpecialBlobsDensity(BSTT_DIGIT) >
930            kMathDigitDensityTh1 ||
931        part->SpecialBlobsDensity(BSTT_UNCLEAR) > kUnclearDensityTh) {
932      return true;
933    }
934    return false;
935  }
936  void EquationDetect::ProcessMathBlockSatelliteParts() {
937    ColPartition *part = nullptr;
938    std::vector<ColPartition *> text_parts;
939    ColPartitionGridSearch gsearch(part_grid_);
940    gsearch.StartFullSearch();
941    while ((part = gsearch.NextFullSearch()) != nullptr) {
942      if (part->type() == PT_FLOWING_TEXT || part->type() == PT_HEADING_TEXT) {
943        text_parts.push_back(part);
944      }
945    }
946    if (text_parts.empty()) {
947      return;
948    }
949    std::sort(text_parts.begin(), text_parts.end(), &SortCPByHeight);
950    const TBOX &text_box = text_parts[text_parts.size() / 2]->bounding_box();
951    int med_height = text_box.height();
952    if (text_parts.size() % 2 == 0 && text_parts.size() > 1) {
953      const TBOX &text_box = text_parts[text_parts.size() / 2 - 1]->bounding_box();
954      med_height = static_cast<int>(std::round(0.5f * (text_box.height() + med_height)));
955    }
956    for (auto &text_part : text_parts) {
957      const TBOX &text_box(text_part->bounding_box());
958      if (text_box.height() > med_height) {
959        continue;
960      }
961      std::vector<ColPartition *> math_blocks;
962      if (!IsMathBlockSatellite(text_part, &math_blocks)) {
963        continue;
964      }
965      part_grid_->RemoveBBox(text_part);
966      text_part->set_type(PT_EQUATION);
967      for (auto &math_block : math_blocks) {
968        part_grid_->RemoveBBox(math_block);
969        text_part->Absorb(math_block, nullptr);
970      }
971      InsertPartAfterAbsorb(text_part);
972    }
973  }
974  bool EquationDetect::IsMathBlockSatellite(ColPartition *part,
975                                            std::vector<ColPartition *> *math_blocks) {
976    ASSERT_HOST(part != nullptr && math_blocks != nullptr);
977    math_blocks->clear();
978    const TBOX &part_box(part->bounding_box());
979    ColPartition *neighbors[2];
980    int y_gaps[2] = {std::numeric_limits<int>::max(), std::numeric_limits<int>::max()};
981    int neighbors_left = std::numeric_limits<int>::max(), neighbors_right = 0;
982    for (int i = 0; i < 2; ++i) {
983      neighbors[i] = SearchNNVertical(i != 0, part);
984      if (neighbors[i]) {
985        const TBOX &neighbor_box = neighbors[i]->bounding_box();
986        y_gaps[i] = neighbor_box.y_gap(part_box);
987        if (neighbor_box.left() < neighbors_left) {
988          neighbors_left = neighbor_box.left();
989        }
990        if (neighbor_box.right() > neighbors_right) {
991          neighbors_right = neighbor_box.right();
992        }
993      }
994    }
995    if (neighbors[0] == neighbors[1]) {
996      neighbors[1] = nullptr;
997      y_gaps[1] = std::numeric_limits<int>::max();
998    }
999    if (part_box.left() < neighbors_left || part_box.right() > neighbors_right) {
1000      return false;
1001    }
1002    int index = y_gaps[0] < y_gaps[1] ? 0 : 1;
1003    if (IsNearMathNeighbor(y_gaps[index], neighbors[index])) {
1004      math_blocks->push_back(neighbors[index]);
1005    } else {
1006      return false;
1007    }
1008    index = 1 - index;
1009    if (IsNearMathNeighbor(y_gaps[index], neighbors[index])) {
1010      math_blocks->push_back(neighbors[index]);
1011    }
1012    return true;
1013  }
1014  ColPartition *EquationDetect::SearchNNVertical(const bool search_bottom, const ColPartition *part) {
1015    ASSERT_HOST(part);
1016    ColPartition *nearest_neighbor = nullptr, *neighbor = nullptr;
1017    const int kYGapTh = static_cast<int>(std::round(resolution_ * 0.5f));
1018    ColPartitionGridSearch search(part_grid_);
1019    search.SetUniqueMode(true);
1020    const TBOX &part_box(part->bounding_box());
1021    int y = search_bottom ? part_box.bottom() : part_box.top();
1022    search.StartVerticalSearch(part_box.left(), part_box.right(), y);
1023    int min_y_gap = std::numeric_limits<int>::max();
1024    while ((neighbor = search.NextVerticalSearch(search_bottom)) != nullptr) {
1025      if (neighbor == part || !IsTextOrEquationType(neighbor->type())) {
1026        continue;
1027      }
1028      const TBOX &neighbor_box(neighbor->bounding_box());
1029      int y_gap = neighbor_box.y_gap(part_box);
1030      if (y_gap > kYGapTh) { 
1031        break;
1032      }
1033      if (!neighbor_box.major_x_overlap(part_box) ||
1034          (search_bottom && neighbor_box.bottom() > part_box.bottom()) ||
1035          (!search_bottom && neighbor_box.top() < part_box.top())) {
1036        continue;
1037      }
1038      if (y_gap < min_y_gap) {
1039        min_y_gap = y_gap;
1040        nearest_neighbor = neighbor;
1041      }
1042    }
1043    return nearest_neighbor;
1044  }
1045  bool EquationDetect::IsNearMathNeighbor(const int y_gap, const ColPartition *neighbor) const {
1046    if (!neighbor) {
1047      return false;
1048    }
1049    const int kYGapTh = static_cast<int>(std::round(resolution_ * 0.1f));
1050    return neighbor->type() == PT_EQUATION && y_gap <= kYGapTh;
1051  }
1052  void EquationDetect::GetOutputTiffName(const char *name, std::string &image_name) const {
1053    ASSERT_HOST(name);
1054    char page[50];
1055    snprintf(page, sizeof(page), "%04d", page_count_);
1056    image_name = (lang_tesseract_->imagebasename) + page + name + ".tif";
1057  }
1058  void EquationDetect::PaintSpecialTexts(const std::string &outfile) const {
1059    Image pix = nullptr, pixBi = lang_tesseract_->pix_binary();
1060    pix = pixConvertTo32(pixBi);
1061    ColPartitionGridSearch gsearch(part_grid_);
1062    ColPartition *part = nullptr;
1063    gsearch.StartFullSearch();
1064    while ((part = gsearch.NextFullSearch()) != nullptr) {
1065      BLOBNBOX_C_IT blob_it(part->boxes());
1066      for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
1067        RenderSpecialText(pix, blob_it.data());
1068      }
1069    }
1070    pixWrite(outfile.c_str(), pix, IFF_TIFF_LZW);
1071    pix.destroy();
1072  }
1073  void EquationDetect::PaintColParts(const std::string &outfile) const {
1074    Image pix = pixConvertTo32(lang_tesseract_->BestPix());
1075    ColPartitionGridSearch gsearch(part_grid_);
1076    gsearch.StartFullSearch();
1077    ColPartition *part = nullptr;
1078    while ((part = gsearch.NextFullSearch()) != nullptr) {
1079      const TBOX &tbox = part->bounding_box();
1080      Box *box = boxCreate(tbox.left(), pixGetHeight(pix) - tbox.top(), tbox.width(), tbox.height());
1081      if (part->type() == PT_EQUATION) {
1082        pixRenderBoxArb(pix, box, 5, 255, 0, 0);
1083      } else if (part->type() == PT_INLINE_EQUATION) {
1084        pixRenderBoxArb(pix, box, 5, 0, 255, 0);
1085      } else {
1086        pixRenderBoxArb(pix, box, 5, 0, 0, 255);
1087      }
1088      boxDestroy(&box);
1089    }
1090    pixWrite(outfile.c_str(), pix, IFF_TIFF_LZW);
1091    pix.destroy();
1092  }
1093  void EquationDetect::PrintSpecialBlobsDensity(const ColPartition *part) const {
1094    ASSERT_HOST(part);
1095    TBOX box(part->bounding_box());
1096    int h = pixGetHeight(lang_tesseract_->BestPix());
1097    tprintf("Printing special blobs density values for ColParition (t=%d,b=%d) ", h - box.top(),
1098            h - box.bottom());
1099    box.print();
1100    tprintf("blobs count = %d, density = ", part->boxes_count());
1101    for (int i = 0; i < BSTT_COUNT; ++i) {
1102      auto type = static_cast<BlobSpecialTextType>(i);
1103      tprintf("%d:%f ", i, part->SpecialBlobsDensity(type));
1104    }
1105    tprintf("\n");
1106  }
1107  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-recodebeam_test.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-equationdetect.cpp</div>
                </div>
                <div class="column column_space"><pre><code>67      lstm_dict_.LoadLSTM(lang.c_str(), &mgr);
68      lstm_dict_.FinishLoad();
</pre></code></div>
                <div class="column column_space"><pre><code>115    equ_tesseract_.AdaptiveClassifier(normed_blob.get(), &ratings_equ);
116    lang_tesseract_->AdaptiveClassifier(normed_blob.get(), &ratings_lang);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    