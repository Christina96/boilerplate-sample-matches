<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for subscription.cpp & topic_manager.cpp</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for subscription.cpp & topic_manager.cpp
      </h3>
      <h1 align="center">
        4.4%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>subscription.cpp (5.0754457%)<TH>topic_manager.cpp (3.911205%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match655-0.html#0',2,'match655-1.html#0',3)" NAME="0">(777-793)<TD><A HREF="javascript:ZweiFrames('match655-0.html#0',2,'match655-1.html#0',3)" NAME="0">(216-229)</A><TD ALIGN=center><FONT COLOR="#ff0000">13</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match655-0.html#1',2,'match655-1.html#1',3)" NAME="1">(738-745)<TD><A HREF="javascript:ZweiFrames('match655-0.html#1',2,'match655-1.html#1',3)" NAME="1">(150-157)</A><TD ALIGN=center><FONT COLOR="#eb0000">12</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match655-0.html#2',2,'match655-1.html#2',3)" NAME="2">(250-268)<TD><A HREF="javascript:ZweiFrames('match655-0.html#2',2,'match655-1.html#2',3)" NAME="2">(946-956)</A><TD ALIGN=center><FONT COLOR="#eb0000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>subscription.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Software License Agreement (BSD License)
 *
 *  Copyright (c) 2008, Willow Garage, Inc.
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *   * Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials provided
 *     with the distribution.
 *   * Neither the name of Willow Garage, Inc. nor the names of its
 *     contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *  &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGE.
 */

#include &lt;sstream&gt;
#include &lt;fcntl.h&gt;
#include &lt;cerrno&gt;
#include &lt;cstring&gt;
#include &lt;typeinfo&gt;

#include &quot;ros/common.h&quot;
#include &quot;ros/io.h&quot;
#include &quot;ros/subscription.h&quot;
#include &quot;ros/publication.h&quot;
#include &quot;ros/transport_publisher_link.h&quot;
#include &quot;ros/intraprocess_publisher_link.h&quot;
#include &quot;ros/intraprocess_subscriber_link.h&quot;
#include &quot;ros/connection.h&quot;
#include &quot;ros/transport/transport_tcp.h&quot;
#include &quot;ros/transport/transport_udp.h&quot;
#include &quot;ros/callback_queue_interface.h&quot;
#include &quot;ros/this_node.h&quot;
#include &quot;ros/network.h&quot;
#include &quot;ros/poll_manager.h&quot;
#include &quot;ros/connection_manager.h&quot;
#include &quot;ros/message_deserializer.h&quot;
#include &quot;ros/subscription_queue.h&quot;
#include &quot;ros/file_log.h&quot;
#include &quot;ros/transport_hints.h&quot;
#include &quot;ros/subscription_callback_helper.h&quot;

#include &lt;boost/make_shared.hpp&gt;

using XmlRpc::XmlRpcValue;

namespace ros
{

Subscription::Subscription(const std::string &amp;name, const std::string&amp; md5sum, const std::string&amp; datatype, const TransportHints&amp; transport_hints)
: name_(name)
, md5sum_(md5sum)
, datatype_(datatype)
, nonconst_callbacks_(0)
, dropped_(false)
, shutting_down_(false)
, transport_hints_(transport_hints)
{
}

Subscription::~Subscription()
{
  pending_connections_.clear();
  callbacks_.clear();
}

void Subscription::shutdown()
{
  {
    boost::mutex::scoped_lock lock(shutdown_mutex_);
    shutting_down_ = true;
  }

  drop();
}

XmlRpcValue Subscription::getStats()
{
  XmlRpcValue stats;
  stats[0] = name_;
  XmlRpcValue conn_data;
  conn_data.setSize(0);

  boost::mutex::scoped_lock lock(publisher_links_mutex_);

  uint32_t cidx = 0;
  for (V_PublisherLink::iterator c = publisher_links_.begin();
       c != publisher_links_.end(); ++c)
  {
    const PublisherLink::Stats&amp; s = (*c)-&gt;getStats();
    conn_data[cidx][0] = (*c)-&gt;getConnectionID();
    conn_data[cidx][1] = (int)s.bytes_received_;
    conn_data[cidx][2] = (int)s.messages_received_;
    conn_data[cidx][3] = (int)s.drops_;
    conn_data[cidx][4] = 0; // figure out something for this. not sure.
  }

  stats[1] = conn_data;
  return stats;
}

// [(connection_id, publisher_xmlrpc_uri, direction, transport, topic_name, connected, connection_info_string)*]
// e.g. [(1, 'http://host:54893/', 'i', 'TCPROS', '/chatter', 1, 'TCPROS connection on port 59746 to [host:34318 on socket 11]')]
void Subscription::getInfo(XmlRpc::XmlRpcValue&amp; info)
{
  boost::mutex::scoped_lock lock(publisher_links_mutex_);

  for (V_PublisherLink::iterator c = publisher_links_.begin();
       c != publisher_links_.end(); ++c)
  {
    XmlRpcValue curr_info;
    curr_info[0] = (int)(*c)-&gt;getConnectionID();
    curr_info[1] = (*c)-&gt;getPublisherXMLRPCURI();
    curr_info[2] = &quot;i&quot;;
    curr_info[3] = (*c)-&gt;getTransportType();
    curr_info[4] = name_;
    curr_info[5] = true; // For length compatibility with rospy
    curr_info[6] = (*c)-&gt;getTransportInfo();
    info[info.size()] = curr_info;
  }
}

uint32_t Subscription::getNumPublishers()
{
  boost::mutex::scoped_lock lock(publisher_links_mutex_);
  uint32_t num_connected_publishers = 0;
  for (V_PublisherLink::iterator c = publisher_links_.begin();
       c != publisher_links_.end(); ++c)
  {
    // Only count a connection with a received header.
    // Discern this by a non-zero length callerid.
    if ((*c)-&gt;getCallerID().size() &gt; 0)
    {
      num_connected_publishers++;
    }
  }
  return num_connected_publishers;
}

void Subscription::drop()
{
  if (!dropped_)
  {
    dropped_ = true;

    dropAllConnections();
  }
}

void Subscription::dropAllConnections()
{
  // Swap our subscribers list with a local one so we can only lock for a short period of time, because a
  // side effect of our calling drop() on connections can be re-locking the subscribers mutex
  V_PublisherLink localsubscribers;

  {
    boost::mutex::scoped_lock lock(publisher_links_mutex_);

    localsubscribers.swap(publisher_links_);
  }

  V_PublisherLink::iterator it = localsubscribers.begin();
  V_PublisherLink::iterator end = localsubscribers.end();
  for (;it != end; ++it)
  {
    (*it)-&gt;drop();
  }
}

void Subscription::addLocalConnection(const PublicationPtr&amp; pub)
{
  boost::mutex::scoped_lock lock(publisher_links_mutex_);
  if (dropped_)
  {
    return;
  }

  ROSCPP_LOG_DEBUG(&quot;Creating intraprocess link for topic [%s]&quot;, name_.c_str());

  IntraProcessPublisherLinkPtr pub_link(boost::make_shared&lt;IntraProcessPublisherLink&gt;(shared_from_this(), XMLRPCManager::instance()-&gt;getServerURI(), transport_hints_));
  IntraProcessSubscriberLinkPtr sub_link(boost::make_shared&lt;IntraProcessSubscriberLink&gt;(pub));
  pub_link-&gt;setPublisher(sub_link);
  sub_link-&gt;setSubscriber(pub_link);

  addPublisherLink(pub_link);
  pub-&gt;addSubscriberLink(sub_link);
}

bool urisEqual(const std::string&amp; uri1, const std::string&amp; uri2)
{
  std::string host1, host2;
  uint32_t port1 = 0, port2 = 0;
  network::splitURI(uri1, host1, port1);
  network::splitURI(uri2, host2, port2);
  return port1 == port2 &amp;&amp; host1 == host2;
}

bool Subscription::pubUpdate(const V_string&amp; new_pubs)
{
  boost::mutex::scoped_lock lock(shutdown_mutex_);

  if (shutting_down_ || dropped_)
  {
    return false;
  }

  bool retval = true;

  {
    std::stringstream ss;

    for (V_string::const_iterator up_i = new_pubs.begin();
         up_i != new_pubs.end(); ++up_i)
    {
      ss &lt;&lt; *up_i &lt;&lt; &quot;, &quot;;
    }

    ss &lt;&lt; &quot; already have these connections: &quot;;
    {
      boost::mutex::scoped_lock lock(publisher_links_mutex_);
      for (V_PublisherLink::iterator spc = publisher_links_.begin();
           spc!= publisher_links_.end(); ++spc)
      {
        ss &lt;&lt; (*spc)-&gt;getPublisherXMLRPCURI() &lt;&lt; &quot;, &quot;;
      }
    }

<A NAME="2"></A>    boost::mutex::scoped_lock lock(pending_connections_mutex_);
    S_PendingConnection::iterator it = pending_connections_.begin();
    S_PendingConnection::iterator end = pending_connections_.end();
<FONT color="#980517"><A HREF="javascript:ZweiFrames('match655-1.html#2',3,'match655-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>    for (; it != end; ++it)
    {
      ss &lt;&lt; (*it)-&gt;getRemoteURI() &lt;&lt; &quot;, &quot;;
    }

    ROSCPP_LOG_DEBUG(&quot;Publisher update for [%s]: %s&quot;, name_.c_str(), ss.str().c_str());
  }

  V_string additions;
  V_PublisherLink subtractions;
  V_PublisherLink to_add;
  // could use the STL set operations... but these sets are so small
  // it doesn't really matter.
  {
    boost::mutex::scoped_lock lock(publisher_links_mutex_);

    for (V_PublisherLink::iterator spc = publisher_links_.begin();
         spc!= publisher_links_.end(); ++spc)
    {</B></FONT>
      bool found = false;
      for (V_string::const_iterator up_i = new_pubs.begin();
           !found &amp;&amp; up_i != new_pubs.end(); ++up_i)
      {
        if (urisEqual((*spc)-&gt;getPublisherXMLRPCURI(), *up_i))
        {
          found = true;
          break;
        }
      }

      if (!found)
      {
        subtractions.push_back(*spc);
      }
    }

    for (V_string::const_iterator up_i  = new_pubs.begin(); up_i != new_pubs.end(); ++up_i)
    {
      bool found = false;
      for (V_PublisherLink::iterator spc = publisher_links_.begin();
           !found &amp;&amp; spc != publisher_links_.end(); ++spc)
      {
        if (urisEqual(*up_i, (*spc)-&gt;getPublisherXMLRPCURI()))
        {
          found = true;
          break;
        }
      }

      if (!found)
      {
        boost::mutex::scoped_lock lock(pending_connections_mutex_);
        S_PendingConnection::iterator it = pending_connections_.begin();
        S_PendingConnection::iterator end = pending_connections_.end();
        for (; it != end; ++it)
        {
          if (urisEqual(*up_i, (*it)-&gt;getRemoteURI()))
          {
            found = true;
            break;
          }
        }
      }

      if (!found)
      {
        additions.push_back(*up_i);
      }
    }
  }

  for (V_PublisherLink::iterator i = subtractions.begin(); i != subtractions.end(); ++i)
  {
	const PublisherLinkPtr&amp; link = *i;
    if (link-&gt;getPublisherXMLRPCURI() != XMLRPCManager::instance()-&gt;getServerURI())
    {
      ROSCPP_LOG_DEBUG(&quot;Disconnecting from publisher [%s] of topic [%s] at [%s]&quot;,
                        link-&gt;getCallerID().c_str(), name_.c_str(), link-&gt;getPublisherXMLRPCURI().c_str());
		  link-&gt;drop();
	  }
	  else
	  {
		  ROSCPP_LOG_DEBUG(&quot;Disconnect: skipping myself for topic [%s]&quot;, name_.c_str());
	  }
	}

  for (V_string::iterator i = additions.begin();
            i != additions.end(); ++i)
  {
    // this function should never negotiate a self-subscription
    if (XMLRPCManager::instance()-&gt;getServerURI() != *i)
    {
      retval &amp;= negotiateConnection(*i);
    }
    else
    {
      ROSCPP_LOG_DEBUG(&quot;Skipping myself (%s, %s)&quot;, name_.c_str(), XMLRPCManager::instance()-&gt;getServerURI().c_str());
    }
  }

  return retval;
}

bool Subscription::negotiateConnection(const std::string&amp; xmlrpc_uri)
{
  XmlRpcValue tcpros_array, protos_array, params;
  XmlRpcValue udpros_array;
  TransportUDPPtr udp_transport;
  int protos = 0;
  V_string transports = transport_hints_.getTransports();
  if (transports.empty())
  {
    transport_hints_.reliable();
    transports = transport_hints_.getTransports();
  }
  for (V_string::const_iterator it = transports.begin();
       it != transports.end();
       ++it)
  {
    if (*it == &quot;UDP&quot;)
    {
      int max_datagram_size = transport_hints_.getMaxDatagramSize();
      udp_transport = boost::make_shared&lt;TransportUDP&gt;(&amp;PollManager::instance()-&gt;getPollSet());
      if (!max_datagram_size)
        max_datagram_size = udp_transport-&gt;getMaxDatagramSize();
      udp_transport-&gt;createIncoming(0, false);
      udpros_array[0] = &quot;UDPROS&quot;;
      M_string m;
      m[&quot;topic&quot;] = getName();
      m[&quot;md5sum&quot;] = md5sum();
      m[&quot;callerid&quot;] = this_node::getName();
      m[&quot;type&quot;] = datatype();
      boost::shared_array&lt;uint8_t&gt; buffer;
      uint32_t len;
      Header::write(m, buffer, len);
      XmlRpcValue v(buffer.get(), len);
      udpros_array[1] = v;
      udpros_array[2] = network::getHost();
      udpros_array[3] = udp_transport-&gt;getServerPort();
      udpros_array[4] = max_datagram_size;

      protos_array[protos++] = udpros_array;
    }
    else if (*it == &quot;TCP&quot;)
    {
      tcpros_array[0] = std::string(&quot;TCPROS&quot;);
      protos_array[protos++] = tcpros_array;
    }
    else
    {
      ROS_WARN(&quot;Unsupported transport type hinted: %s, skipping&quot;, it-&gt;c_str());
    }
  }
  params[0] = this_node::getName();
  params[1] = name_;
  params[2] = protos_array;
  std::string peer_host;
  uint32_t peer_port;
  if (!network::splitURI(xmlrpc_uri, peer_host, peer_port))
  {
    ROS_ERROR(&quot;Bad xml-rpc URI: [%s]&quot;, xmlrpc_uri.c_str());
    return false;
  }

  XmlRpc::XmlRpcClient* c = new XmlRpc::XmlRpcClient(peer_host.c_str(),
                                                     peer_port, &quot;/&quot;);
 // if (!c.execute(&quot;requestTopic&quot;, params, result) || !g_node-&gt;validateXmlrpcResponse(&quot;requestTopic&quot;, result, proto))

  // Initiate the negotiation.  We'll come back and check on it later.
  if (!c-&gt;executeNonBlock(&quot;requestTopic&quot;, params))
  {
    ROSCPP_LOG_DEBUG(&quot;Failed to contact publisher [%s:%d] for topic [%s]&quot;,
              peer_host.c_str(), peer_port, name_.c_str());
    delete c;
    if (udp_transport)
    {
      udp_transport-&gt;close();
    }

    return false;
  }

  ROSCPP_LOG_DEBUG(&quot;Began asynchronous xmlrpc connection to [%s:%d]&quot;, peer_host.c_str(), peer_port);

  // The PendingConnectionPtr takes ownership of c, and will delete it on
  // destruction.
  PendingConnectionPtr conn(boost::make_shared&lt;PendingConnection&gt;(c, udp_transport, shared_from_this(), xmlrpc_uri));

  XMLRPCManager::instance()-&gt;addASyncConnection(conn);
  // Put this connection on the list that we'll look at later.
  {
    boost::mutex::scoped_lock pending_connections_lock(pending_connections_mutex_);
    pending_connections_.insert(conn);
  }

  return true;
}

void closeTransport(const TransportUDPPtr&amp; trans)
{
  if (trans)
  {
    trans-&gt;close();
  }
}

void Subscription::pendingConnectionDone(const PendingConnectionPtr&amp; conn, XmlRpcValue&amp; result)
{
  boost::mutex::scoped_lock lock(shutdown_mutex_);
  if (shutting_down_ || dropped_)
  {
    return;
  }

  {
    boost::mutex::scoped_lock pending_connections_lock(pending_connections_mutex_);
    pending_connections_.erase(conn);
  }

  TransportUDPPtr udp_transport;

  std::string peer_host = conn-&gt;getClient()-&gt;getHost();
  uint32_t peer_port = conn-&gt;getClient()-&gt;getPort();
  std::stringstream ss;
  ss &lt;&lt; &quot;http://&quot; &lt;&lt; peer_host &lt;&lt; &quot;:&quot; &lt;&lt; peer_port &lt;&lt; &quot;/&quot;;
  std::string xmlrpc_uri = ss.str();
  udp_transport = conn-&gt;getUDPTransport();

  XmlRpc::XmlRpcValue proto;
  if(!XMLRPCManager::instance()-&gt;validateXmlrpcResponse(&quot;requestTopic&quot;, result, proto))
  {
  	ROSCPP_LOG_DEBUG(&quot;Failed to contact publisher [%s:%d] for topic [%s]&quot;,
              peer_host.c_str(), peer_port, name_.c_str());
  	closeTransport(udp_transport);
  	return;
  }

  if (proto.size() == 0)
  {
  	ROSCPP_LOG_DEBUG(&quot;Couldn't agree on any common protocols with [%s] for topic [%s]&quot;, xmlrpc_uri.c_str(), name_.c_str());
  	closeTransport(udp_transport);
  	return;
  }

  if (proto.getType() != XmlRpcValue::TypeArray)
  {
  	ROSCPP_LOG_DEBUG(&quot;Available protocol info returned from %s is not a list.&quot;, xmlrpc_uri.c_str());
  	closeTransport(udp_transport);
  	return;
  }
  if (proto[0].getType() != XmlRpcValue::TypeString)
  {
  	ROSCPP_LOG_DEBUG(&quot;Available protocol info list doesn't have a string as its first element.&quot;);
  	closeTransport(udp_transport);
  	return;
  }

  std::string proto_name = proto[0];
  if (proto_name == &quot;TCPROS&quot;)
  {
    if (proto.size() != 3 ||
        proto[1].getType() != XmlRpcValue::TypeString ||
        proto[2].getType() != XmlRpcValue::TypeInt)
    {
    	ROSCPP_LOG_DEBUG(&quot;publisher implements TCPROS, but the &quot; \
                &quot;parameters aren't string,int&quot;);
      return;
    }
    std::string pub_host = proto[1];
    int pub_port = proto[2];
    ROSCPP_CONN_LOG_DEBUG(&quot;Connecting via tcpros to topic [%s] at host [%s:%d]&quot;, name_.c_str(), pub_host.c_str(), pub_port);

    TransportTCPPtr transport(boost::make_shared&lt;TransportTCP&gt;(&amp;PollManager::instance()-&gt;getPollSet()));
    if (transport-&gt;connect(pub_host, pub_port))
    {
      ConnectionPtr connection(boost::make_shared&lt;Connection&gt;());
      TransportPublisherLinkPtr pub_link(boost::make_shared&lt;TransportPublisherLink&gt;(shared_from_this(), xmlrpc_uri, transport_hints_));

      connection-&gt;initialize(transport, false, HeaderReceivedFunc());
      pub_link-&gt;initialize(connection);

      ConnectionManager::instance()-&gt;addConnection(connection);

      boost::mutex::scoped_lock lock(publisher_links_mutex_);
      addPublisherLink(pub_link);

      ROSCPP_CONN_LOG_DEBUG(&quot;Connected to publisher of topic [%s] at [%s:%d]&quot;, name_.c_str(), pub_host.c_str(), pub_port);
    }
    else
    {
      ROSCPP_CONN_LOG_DEBUG(&quot;Failed to connect to publisher of topic [%s] at [%s:%d]&quot;, name_.c_str(), pub_host.c_str(), pub_port);
    }
  }
  else if (proto_name == &quot;UDPROS&quot;)
  {
    if (proto.size() != 6 ||
        proto[1].getType() != XmlRpcValue::TypeString ||
        proto[2].getType() != XmlRpcValue::TypeInt ||
        proto[3].getType() != XmlRpcValue::TypeInt ||
        proto[4].getType() != XmlRpcValue::TypeInt ||
        proto[5].getType() != XmlRpcValue::TypeBase64)
    {
      ROSCPP_LOG_DEBUG(&quot;publisher implements UDPROS, but the &quot; \
	    	       &quot;parameters aren't string,int,int,int,base64&quot;);
      closeTransport(udp_transport);
      return;
    }
    std::string pub_host = proto[1];
    int pub_port = proto[2];
    int conn_id = proto[3];
    int max_datagram_size = proto[4];
    std::vector&lt;char&gt; header_bytes = proto[5];
    boost::shared_array&lt;uint8_t&gt; buffer(new uint8_t[header_bytes.size()]);
    memcpy(buffer.get(), &amp;header_bytes[0], header_bytes.size());
    Header h;
    std::string err;
    if (!h.parse(buffer, header_bytes.size(), err))
    {
      ROSCPP_LOG_DEBUG(&quot;Unable to parse UDPROS connection header: %s&quot;, err.c_str());
      closeTransport(udp_transport);
      return;
    }
    ROSCPP_LOG_DEBUG(&quot;Connecting via udpros to topic [%s] at host [%s:%d] connection id [%08x] max_datagram_size [%d]&quot;, name_.c_str(), pub_host.c_str(), pub_port, conn_id, max_datagram_size);

    std::string error_msg;
    if (h.getValue(&quot;error&quot;, error_msg))
    {
      ROSCPP_LOG_DEBUG(&quot;Received error message in header for connection to [%s]: [%s]&quot;, xmlrpc_uri.c_str(), error_msg.c_str());
      closeTransport(udp_transport);
      return;
    }

    TransportPublisherLinkPtr pub_link(boost::make_shared&lt;TransportPublisherLink&gt;(shared_from_this(), xmlrpc_uri, transport_hints_));
    if (pub_link-&gt;setHeader(h))
    {
      ConnectionPtr connection(boost::make_shared&lt;Connection&gt;());
      connection-&gt;initialize(udp_transport, false, NULL);
      connection-&gt;setHeader(h);
      pub_link-&gt;initialize(connection);

      ConnectionManager::instance()-&gt;addConnection(connection);

      boost::mutex::scoped_lock lock(publisher_links_mutex_);
      addPublisherLink(pub_link);

      ROSCPP_LOG_DEBUG(&quot;Connected to publisher of topic [%s] at [%s:%d]&quot;, name_.c_str(), pub_host.c_str(), pub_port);
    }
    else
    {
      ROSCPP_LOG_DEBUG(&quot;Failed to connect to publisher of topic [%s] at [%s:%d]&quot;, name_.c_str(), pub_host.c_str(), pub_port);
      closeTransport(udp_transport);
      return;
    }
  }
  else
  {
  	ROSCPP_LOG_DEBUG(&quot;Publisher offered unsupported transport [%s]&quot;, proto_name.c_str());
  }
}

uint32_t Subscription::handleMessage(const SerializedMessage&amp; m, bool ser, bool nocopy, const boost::shared_ptr&lt;M_string&gt;&amp; connection_header, const PublisherLinkPtr&amp; link)
{
  boost::mutex::scoped_lock lock(callbacks_mutex_);

  uint32_t drops = 0;

  // Cache the deserializers by type info.  If all the subscriptions are the same type this has the same performance as before.  If
  // there are subscriptions with different C++ type (but same ROS message type), this now works correctly rather than passing
  // garbage to the messages with different C++ types than the first one.
  cached_deserializers_.clear();

  ros::Time receipt_time = ros::Time::now();

  for (V_CallbackInfo::iterator cb = callbacks_.begin();
       cb != callbacks_.end(); ++cb)
  {
    const CallbackInfoPtr&amp; info = *cb;

    ROS_ASSERT(info-&gt;callback_queue_);

    const std::type_info* ti = &amp;info-&gt;helper_-&gt;getTypeInfo();

    if ((nocopy &amp;&amp; m.type_info &amp;&amp; *ti == *m.type_info) || (ser &amp;&amp; (!m.type_info || *ti != *m.type_info)))
    {
      MessageDeserializerPtr deserializer;

      V_TypeAndDeserializer::iterator des_it = cached_deserializers_.begin();
      V_TypeAndDeserializer::iterator des_end = cached_deserializers_.end();
      for (; des_it != des_end; ++des_it)
      {
        if (*des_it-&gt;first == *ti)
        {
          deserializer = des_it-&gt;second;
          break;
        }
      }

      if (!deserializer)
      {
        deserializer = boost::make_shared&lt;MessageDeserializer&gt;(info-&gt;helper_, m, connection_header);
        cached_deserializers_.push_back(std::make_pair(ti, deserializer));
      }

      bool was_full = false;
      bool nonconst_need_copy = false;
      if (callbacks_.size() &gt; 1)
      {
        nonconst_need_copy = true;
      }

      info-&gt;subscription_queue_-&gt;push(info-&gt;helper_, deserializer, info-&gt;has_tracked_object_, info-&gt;tracked_object_, nonconst_need_copy, receipt_time, &amp;was_full);

      if (was_full)
      {
        ++drops;
      }
      else
      {
        info-&gt;callback_queue_-&gt;addCallback(info-&gt;subscription_queue_, (uint64_t)info.get());
      }
    }
  }

  // measure statistics
  statistics_.callback(connection_header, name_, link-&gt;getCallerID(), m, link-&gt;getStats().bytes_received_, receipt_time, drops &gt; 0, link-&gt;getConnectionID());

  // If this link is latched, store off the message so we can immediately pass it to new subscribers later
  if (link-&gt;isLatched())
  {
    LatchInfo li;
    li.connection_header = connection_header;
    li.link = link;
    li.message = m;
    li.receipt_time = receipt_time;
    latched_messages_[link] = li;
  }

  cached_deserializers_.clear();

  return drops;
}

bool Subscription::addCallback(const SubscriptionCallbackHelperPtr&amp; helper, const std::string&amp; md5sum, CallbackQueueInterface* queue, int32_t queue_size, const VoidConstPtr&amp; tracked_object, bool allow_concurrent_callbacks)
{
  ROS_ASSERT(helper);
  ROS_ASSERT(queue);

  statistics_.init(helper);

  // Decay to a real type as soon as we have a subscriber with a real type
  {
    boost::mutex::scoped_lock lock(md5sum_mutex_);
    if (md5sum_ == &quot;*&quot; &amp;&amp; md5sum != &quot;*&quot;)
    {

      md5sum_ = md5sum;
    }
  }

  if (md5sum != &quot;*&quot; &amp;&amp; md5sum != this-&gt;md5sum())
  {
    return false;
  }

  {
    boost::mutex::scoped_lock lock(callbacks_mutex_);

    CallbackInfoPtr info(boost::make_shared&lt;CallbackInfo&gt;());
    info-&gt;helper_ = helper;
    info-&gt;callback_queue_ = queue;
    info-&gt;subscription_queue_ = boost::make_shared&lt;SubscriptionQueue&gt;(name_, queue_size, allow_concurrent_callbacks);
    info-&gt;tracked_object_ = tracked_object;
    info-&gt;has_tracked_object_ = false;
    if (tracked_object)
    {
      info-&gt;has_tracked_object_ = true;
    }

    if (!helper-&gt;isConst())
    {
      ++nonconst_callbacks_;
    }

    callbacks_.push_back(info);
    cached_deserializers_.reserve(callbacks_.size());
<A NAME="1"></A>
    // if we have any latched links, we need to immediately schedule callbacks
    if (!latched_messages_.empty())
<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match655-1.html#1',3,'match655-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>    {
      boost::mutex::scoped_lock lock(publisher_links_mutex_);

      V_PublisherLink::iterator it = publisher_links_.begin();
      V_PublisherLink::iterator end = publisher_links_.end();
      for (; it != end;++it)
      {
        const PublisherLinkPtr&amp; link = *it;</B></FONT>
        if (link-&gt;isLatched())
        {
          M_PublisherLinkToLatchInfo::iterator des_it = latched_messages_.find(link);
          if (des_it != latched_messages_.end())
          {
            const LatchInfo&amp; latch_info = des_it-&gt;second;

            MessageDeserializerPtr des(boost::make_shared&lt;MessageDeserializer&gt;(helper, latch_info.message, latch_info.connection_header));
            bool was_full = false;
            info-&gt;subscription_queue_-&gt;push(info-&gt;helper_, des, info-&gt;has_tracked_object_, info-&gt;tracked_object_, true, latch_info.receipt_time, &amp;was_full);
            if (!was_full)
            {
              info-&gt;callback_queue_-&gt;addCallback(info-&gt;subscription_queue_, (uint64_t)info.get());
            }
          }
        }
      }
    }
  }

  return true;
}

void Subscription::removeCallback(const SubscriptionCallbackHelperPtr&amp; helper)
{
  CallbackInfoPtr info;
  {
    boost::mutex::scoped_lock cbs_lock(callbacks_mutex_);
<A NAME="0"></A>    for (V_CallbackInfo::iterator it = callbacks_.begin();
         it != callbacks_.end(); ++it)
    {
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match655-1.html#0',3,'match655-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>      if ((*it)-&gt;helper_ == helper)
      {
        info = *it;
        callbacks_.erase(it);

        if (!helper-&gt;isConst())
        {
          --nonconst_callbacks_;
        }

        break;
      }
    }
  }

  if (info)
  {</B></FONT>
    info-&gt;subscription_queue_-&gt;clear();
    info-&gt;callback_queue_-&gt;removeByID((uint64_t)info.get());
  }
}

void Subscription::headerReceived(const PublisherLinkPtr&amp; link, const Header&amp; h)
{
  (void)h;
  boost::mutex::scoped_lock lock(md5sum_mutex_);
  if (md5sum_ == &quot;*&quot;)
  {
    md5sum_ = link-&gt;getMD5Sum();
  }
}

void Subscription::addPublisherLink(const PublisherLinkPtr&amp; link)
{
  publisher_links_.push_back(link);
}

void Subscription::removePublisherLink(const PublisherLinkPtr&amp; pub_link)
{
  boost::mutex::scoped_lock lock(publisher_links_mutex_);

  V_PublisherLink::iterator it = std::find(publisher_links_.begin(), publisher_links_.end(), pub_link);
  if (it != publisher_links_.end())
  {
    publisher_links_.erase(it);
  }

  if (pub_link-&gt;isLatched())
  {
    latched_messages_.erase(pub_link);
  }
}

void Subscription::getPublishTypes(bool&amp; ser, bool&amp; nocopy, const std::type_info&amp; ti)
{
  boost::mutex::scoped_lock lock(callbacks_mutex_);
  for (V_CallbackInfo::iterator cb = callbacks_.begin();
       cb != callbacks_.end(); ++cb)
  {
    const CallbackInfoPtr&amp; info = *cb;
    if (info-&gt;helper_-&gt;getTypeInfo() == ti)
    {
      nocopy = true;
    }
    else
    {
      ser = true;
    }

    if (nocopy &amp;&amp; ser)
    {
      return;
    }
  }
}

const std::string Subscription::datatype()
{
  return datatype_;
}

const std::string Subscription::md5sum()
{
  boost::mutex::scoped_lock lock(md5sum_mutex_);
  return md5sum_;
}

}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>topic_manager.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright (C) 2009, Willow Garage, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *   * Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *   * Neither the names of Willow Garage, Inc. nor the names of its
 *     contributors may be used to endorse or promote products derived from
 *     this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include &quot;ros/topic_manager.h&quot;
#include &quot;ros/xmlrpc_manager.h&quot;
#include &quot;ros/connection_manager.h&quot;
#include &quot;ros/poll_manager.h&quot;
#include &quot;ros/publication.h&quot;
#include &quot;ros/subscription.h&quot;
#include &quot;ros/this_node.h&quot;
#include &quot;ros/network.h&quot;
#include &quot;ros/master.h&quot;
#include &quot;ros/transport/transport_tcp.h&quot;
#include &quot;ros/transport/transport_udp.h&quot;
#include &quot;ros/rosout_appender.h&quot;
#include &quot;ros/init.h&quot;
#include &quot;ros/file_log.h&quot;
#include &quot;ros/subscribe_options.h&quot;

#include &quot;xmlrpcpp/XmlRpc.h&quot;

#include &lt;ros/console.h&gt;

using namespace XmlRpc; // A battle to be fought later
using namespace std; // sigh

/// \todo Locking can be significantly simplified here once the Node API goes away.

namespace ros
{

const TopicManagerPtr&amp; TopicManager::instance()
{
  static TopicManagerPtr topic_manager = boost::make_shared&lt;TopicManager&gt;();
  return topic_manager;
}

TopicManager::TopicManager()
: shutting_down_(false)
{
}

TopicManager::~TopicManager()
{
  shutdown();
}

void TopicManager::start()
{
  boost::mutex::scoped_lock shutdown_lock(shutting_down_mutex_);
  shutting_down_ = false;

  poll_manager_ = PollManager::instance();
  connection_manager_ = ConnectionManager::instance();
  xmlrpc_manager_ = XMLRPCManager::instance();

  xmlrpc_manager_-&gt;bind(&quot;publisherUpdate&quot;, boost::bind(&amp;TopicManager::pubUpdateCallback, this, boost::placeholders::_1, boost::placeholders::_2));
  xmlrpc_manager_-&gt;bind(&quot;requestTopic&quot;, boost::bind(&amp;TopicManager::requestTopicCallback, this, boost::placeholders::_1, boost::placeholders::_2));
  xmlrpc_manager_-&gt;bind(&quot;getBusStats&quot;, boost::bind(&amp;TopicManager::getBusStatsCallback, this, boost::placeholders::_1, boost::placeholders::_2));
  xmlrpc_manager_-&gt;bind(&quot;getBusInfo&quot;, boost::bind(&amp;TopicManager::getBusInfoCallback, this, boost::placeholders::_1, boost::placeholders::_2));
  xmlrpc_manager_-&gt;bind(&quot;getSubscriptions&quot;, boost::bind(&amp;TopicManager::getSubscriptionsCallback, this, boost::placeholders::_1, boost::placeholders::_2));
  xmlrpc_manager_-&gt;bind(&quot;getPublications&quot;, boost::bind(&amp;TopicManager::getPublicationsCallback, this, boost::placeholders::_1, boost::placeholders::_2));

  poll_manager_-&gt;addPollThreadListener(boost::bind(&amp;TopicManager::processPublishQueues, this));
}

void TopicManager::shutdown()
{
  boost::mutex::scoped_lock shutdown_lock(shutting_down_mutex_);
  if (shutting_down_)
  {
    return;
  }

  {
    boost::lock(subs_mutex_, advertised_topics_mutex_);
    shutting_down_ = true;
    subs_mutex_.unlock();
    advertised_topics_mutex_.unlock();
  }

  // actually one should call poll_manager_-&gt;removePollThreadListener(), but the connection is not stored above
  poll_manager_-&gt;shutdown();

  xmlrpc_manager_-&gt;unbind(&quot;publisherUpdate&quot;);
  xmlrpc_manager_-&gt;unbind(&quot;requestTopic&quot;);
  xmlrpc_manager_-&gt;unbind(&quot;getBusStats&quot;);
  xmlrpc_manager_-&gt;unbind(&quot;getBusInfo&quot;);
  xmlrpc_manager_-&gt;unbind(&quot;getSubscriptions&quot;);
  xmlrpc_manager_-&gt;unbind(&quot;getPublications&quot;);

  ROSCPP_LOG_DEBUG(&quot;Shutting down topics...&quot;);
  ROSCPP_LOG_DEBUG(&quot;  shutting down publishers&quot;);
  {
    boost::recursive_mutex::scoped_lock adv_lock(advertised_topics_mutex_);

    for (V_Publication::iterator i = advertised_topics_.begin();
         i != advertised_topics_.end(); ++i)
    {
      if(!(*i)-&gt;isDropped())
      {
        unregisterPublisher((*i)-&gt;getName());
      }
      (*i)-&gt;drop();
    }
    advertised_topics_.clear();
  }

  // unregister all of our subscriptions
  ROSCPP_LOG_DEBUG(&quot;  shutting down subscribers&quot;);
  {
    boost::mutex::scoped_lock subs_lock(subs_mutex_);

    for (L_Subscription::iterator s = subscriptions_.begin(); s != subscriptions_.end(); ++s)
    {
      // Remove us as a subscriber from the master
      unregisterSubscriber((*s)-&gt;getName());
      // now, drop our side of the connection
      (*s)-&gt;shutdown();
    }
    subscriptions_.clear();
  }
<A NAME="1"></A>}

void TopicManager::processPublishQueues()
<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match655-0.html#1',2,'match655-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>{
  boost::recursive_mutex::scoped_lock lock(advertised_topics_mutex_);

  V_Publication::iterator it = advertised_topics_.begin();
  V_Publication::iterator end = advertised_topics_.end();
  for (; it != end; ++it)
  {
    const PublicationPtr&amp; pub = *it;</B></FONT>
    pub-&gt;processPublishQueue();
  }
}

void TopicManager::getAdvertisedTopics(V_string&amp; topics)
{
  boost::mutex::scoped_lock lock(advertised_topic_names_mutex_);

  topics.resize(advertised_topic_names_.size());
  std::copy(advertised_topic_names_.begin(),
            advertised_topic_names_.end(),
            topics.begin());
}

void TopicManager::getSubscribedTopics(V_string&amp; topics)
{
  boost::mutex::scoped_lock lock(subs_mutex_);

  topics.reserve(subscriptions_.size());
  L_Subscription::const_iterator it = subscriptions_.begin();
  L_Subscription::const_iterator end = subscriptions_.end();
  for (; it != end; ++it)
  {
    const SubscriptionPtr&amp; sub = *it;
    topics.push_back(sub-&gt;getName());
  }
}

PublicationPtr TopicManager::lookupPublication(const std::string&amp; topic)
{
  boost::recursive_mutex::scoped_lock lock(advertised_topics_mutex_);

  return lookupPublicationWithoutLock(topic);
}

bool md5sumsMatch(const std::string&amp; lhs, const std::string&amp; rhs)
{
  return lhs == &quot;*&quot; || rhs == &quot;*&quot; || lhs == rhs;
}

bool TopicManager::addSubCallback(const SubscribeOptions&amp; ops)
{
  // spin through the subscriptions and see if we find a match. if so, use it.
  bool found = false;
  bool found_topic = false;

  SubscriptionPtr sub;

  {
    if (isShuttingDown())
    {
      return false;
    }

    for (L_Subscription::iterator s = subscriptions_.begin();
<A NAME="0"></A>         s != subscriptions_.end() &amp;&amp; !found; ++s)
    {
      sub = *s;
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match655-0.html#0',2,'match655-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>      if (!sub-&gt;isDropped() &amp;&amp; sub-&gt;getName() == ops.topic)
      {
        found_topic = true;
        if (md5sumsMatch(ops.md5sum, sub-&gt;md5sum()))
        {
          found = true;
        }
        break;
      }
    }
  }

  if (found_topic &amp;&amp; !found)
  {</B></FONT>
    std::stringstream ss;
    ss &lt;&lt; &quot;Tried to subscribe to a topic with the same name but different md5sum as a topic that was already subscribed [&quot; &lt;&lt; ops.datatype &lt;&lt; &quot;/&quot; &lt;&lt; ops.md5sum &lt;&lt; &quot; vs. &quot; &lt;&lt; sub-&gt;datatype() &lt;&lt; &quot;/&quot; &lt;&lt; sub-&gt;md5sum() &lt;&lt; &quot;]&quot;;
    throw ConflictingSubscriptionException(ss.str());
  }
  else if (found)
  {
    if (!sub-&gt;addCallback(ops.helper, ops.md5sum, ops.callback_queue, ops.queue_size, ops.tracked_object, ops.allow_concurrent_callbacks))
    {
      return false;
    }
  }

  return found;
}

// this function has the subscription code that doesn't need to be templated.
bool TopicManager::subscribe(const SubscribeOptions&amp; ops)
{
  boost::mutex::scoped_lock lock(subs_mutex_);

  if (addSubCallback(ops))
  {
    return true;
  }

  if (isShuttingDown())
  {
    return false;
  }

  if (ops.md5sum.empty())
  {
    throw InvalidParameterException(&quot;Subscribing to topic [&quot; + ops.topic + &quot;] with an empty md5sum&quot;);
  }

  if (ops.datatype.empty())
  {
    throw InvalidParameterException(&quot;Subscribing to topic [&quot; + ops.topic + &quot;] with an empty datatype&quot;);
  }

  if (!ops.helper)
  {
    throw InvalidParameterException(&quot;Subscribing to topic [&quot; + ops.topic + &quot;] without a callback&quot;);
  }

  const std::string&amp; md5sum = ops.md5sum;
  std::string datatype = ops.datatype;

  SubscriptionPtr s(boost::make_shared&lt;Subscription&gt;(ops.topic, md5sum, datatype, ops.transport_hints));
  s-&gt;addCallback(ops.helper, ops.md5sum, ops.callback_queue, ops.queue_size, ops.tracked_object, ops.allow_concurrent_callbacks);

  if (!registerSubscriber(s, ops.datatype))
  {
    ROS_WARN(&quot;couldn't register subscriber on topic [%s]&quot;, ops.topic.c_str());
    s-&gt;shutdown();
    return false;
  }

  subscriptions_.push_back(s);

  return true;
}

bool TopicManager::advertise(const AdvertiseOptions&amp; ops, const SubscriberCallbacksPtr&amp; callbacks)
{
  if (ops.datatype == &quot;*&quot;)
  {
    std::stringstream ss;
    ss &lt;&lt; &quot;Advertising with * as the datatype is not allowed.  Topic [&quot; &lt;&lt; ops.topic &lt;&lt; &quot;]&quot;;
    throw InvalidParameterException(ss.str());
  }

  if (ops.md5sum == &quot;*&quot;)
  {
    std::stringstream ss;
    ss &lt;&lt; &quot;Advertising with * as the md5sum is not allowed.  Topic [&quot; &lt;&lt; ops.topic &lt;&lt; &quot;]&quot;;
    throw InvalidParameterException(ss.str());
  }

  if (ops.md5sum.empty())
  {
    throw InvalidParameterException(&quot;Advertising on topic [&quot; + ops.topic + &quot;] with an empty md5sum&quot;);
  }

  if (ops.datatype.empty())
  {
    throw InvalidParameterException(&quot;Advertising on topic [&quot; + ops.topic + &quot;] with an empty datatype&quot;);
  }

  if (ops.message_definition.empty())
  {
    ROS_WARN(&quot;Advertising on topic [%s] with an empty message definition.  Some tools (e.g. rosbag) may not work correctly.&quot;, ops.topic.c_str());
  }

  PublicationPtr pub;

  {
    boost::recursive_mutex::scoped_lock lock(advertised_topics_mutex_);

    if (isShuttingDown())
    {
      return false;
    }

    pub = lookupPublicationWithoutLock(ops.topic);
    if (pub &amp;&amp; pub-&gt;getNumCallbacks() == 0)
    {
      pub.reset();
    }

    if (pub)
    {
      if (pub-&gt;getMD5Sum() != ops.md5sum)
      {
        ROS_ERROR(&quot;Tried to advertise on topic [%s] with md5sum [%s] and datatype [%s], but the topic is already advertised as md5sum [%s] and datatype [%s]&quot;,
                  ops.topic.c_str(), ops.md5sum.c_str(), ops.datatype.c_str(), pub-&gt;getMD5Sum().c_str(), pub-&gt;getDataType().c_str());
        return false;
      }

      pub-&gt;addCallbacks(callbacks);

      return true;
    }

    pub = PublicationPtr(boost::make_shared&lt;Publication&gt;(ops.topic, ops.datatype, ops.md5sum, ops.message_definition, ops.queue_size, false, ops.has_header));
    pub-&gt;addCallbacks(callbacks);
    advertised_topics_.push_back(pub);
  }


  {
    boost::mutex::scoped_lock lock(advertised_topic_names_mutex_);
    advertised_topic_names_.push_back(ops.topic);
  }

  // Check whether we've already subscribed to this topic.  If so, we'll do
  // the self-subscription here, to avoid the deadlock that would happen if
  // the ROS thread later got the publisherUpdate with its own XMLRPC URI.
  // The assumption is that advertise() is called from somewhere other
  // than the ROS thread.
  bool found = false;
  SubscriptionPtr sub;
  {
    boost::mutex::scoped_lock lock(subs_mutex_);

    for (L_Subscription::iterator s = subscriptions_.begin();
         s != subscriptions_.end() &amp;&amp; !found; ++s)
    {
      if ((*s)-&gt;getName() == ops.topic &amp;&amp; md5sumsMatch((*s)-&gt;md5sum(), ops.md5sum) &amp;&amp; !(*s)-&gt;isDropped())
      {
        found = true;
        sub = *s;
        break;
      }
    }
  }

  if(found)
  {
    sub-&gt;addLocalConnection(pub);
  }

  XmlRpcValue args, result, payload;
  args[0] = this_node::getName();
  args[1] = ops.topic;
  args[2] = ops.datatype;
  args[3] = xmlrpc_manager_-&gt;getServerURI();
  master::execute(&quot;registerPublisher&quot;, args, result, payload, true);

  return true;
}

bool TopicManager::unadvertise(const std::string &amp;topic, const SubscriberCallbacksPtr&amp; callbacks)
{
  PublicationPtr pub;
  V_Publication::iterator i;
  {
    boost::recursive_mutex::scoped_lock lock(advertised_topics_mutex_);

    if (isShuttingDown())
    {
      return false;
    }

    for (i = advertised_topics_.begin();
         i != advertised_topics_.end(); ++i)
    {
      if(((*i)-&gt;getName() == topic) &amp;&amp; (!(*i)-&gt;isDropped()))
      {
        pub = *i;
        break;
      }
    }
  }

  if (!pub)
  {
    return false;
  }

  pub-&gt;removeCallbacks(callbacks);

  {
    boost::recursive_mutex::scoped_lock lock(advertised_topics_mutex_);
    if (pub-&gt;getNumCallbacks() == 0)
    {
      unregisterPublisher(pub-&gt;getName());
      pub-&gt;drop();

      advertised_topics_.erase(i);

      {
        boost::mutex::scoped_lock lock(advertised_topic_names_mutex_);
        advertised_topic_names_.remove(pub-&gt;getName());
      }
    }
  }

  return true;
}

bool TopicManager::unregisterPublisher(const std::string&amp; topic)
{
  XmlRpcValue args, result, payload;
  args[0] = this_node::getName();
  args[1] = topic;
  args[2] = xmlrpc_manager_-&gt;getServerURI();
  master::execute(&quot;unregisterPublisher&quot;, args, result, payload, false);

  return true;
}

bool TopicManager::isTopicAdvertised(const string &amp;topic)
{
  for (V_Publication::iterator t = advertised_topics_.begin(); t != advertised_topics_.end(); ++t)
  {
    if (((*t)-&gt;getName() == topic) &amp;&amp; (!(*t)-&gt;isDropped()))
    {
      return true;
    }
  }

  return false;
}

bool TopicManager::registerSubscriber(const SubscriptionPtr&amp; s, const string &amp;datatype)
{
  XmlRpcValue args, result, payload;
  args[0] = this_node::getName();
  args[1] = s-&gt;getName();
  args[2] = datatype;
  args[3] = xmlrpc_manager_-&gt;getServerURI();

  if (!master::execute(&quot;registerSubscriber&quot;, args, result, payload, true))
  {
    return false;
  }

  vector&lt;string&gt; pub_uris;
  for (int i = 0; i &lt; payload.size(); i++)
  {
    if (payload[i] != xmlrpc_manager_-&gt;getServerURI())
    {
      pub_uris.push_back(string(payload[i]));
    }
  }

  bool self_subscribed = false;
  PublicationPtr pub;
  const std::string&amp; sub_md5sum = s-&gt;md5sum();
  // Figure out if we have a local publisher
  {
    boost::recursive_mutex::scoped_lock lock(advertised_topics_mutex_);
    V_Publication::const_iterator it = advertised_topics_.begin();
    V_Publication::const_iterator end = advertised_topics_.end();
    for (; it != end; ++it)
    {
      pub = *it;
      const std::string&amp; pub_md5sum = pub-&gt;getMD5Sum();

      if (pub-&gt;getName() == s-&gt;getName() &amp;&amp; !pub-&gt;isDropped())
	{
	  if (!md5sumsMatch(pub_md5sum, sub_md5sum))
	    {
	      ROS_ERROR(&quot;md5sum mismatch making local subscription to topic %s.&quot;,
			s-&gt;getName().c_str());
	      ROS_ERROR(&quot;Subscriber expects type %s, md5sum %s&quot;,
			s-&gt;datatype().c_str(), s-&gt;md5sum().c_str());
	      ROS_ERROR(&quot;Publisher provides type %s, md5sum %s&quot;,
			pub-&gt;getDataType().c_str(), pub-&gt;getMD5Sum().c_str());
	      return false;
	    }

	  self_subscribed = true;
	  break;
	}
    }
  }

  s-&gt;pubUpdate(pub_uris);
  if (self_subscribed)
  {
    s-&gt;addLocalConnection(pub);
  }

  return true;
}

bool TopicManager::unregisterSubscriber(const string &amp;topic)
{
  XmlRpcValue args, result, payload;
  args[0] = this_node::getName();
  args[1] = topic;
  args[2] = xmlrpc_manager_-&gt;getServerURI();

  master::execute(&quot;unregisterSubscriber&quot;, args, result, payload, false);

  return true;
}

bool TopicManager::pubUpdate(const string &amp;topic, const vector&lt;string&gt; &amp;pubs)
{
  SubscriptionPtr sub;
  {
    boost::mutex::scoped_lock lock(subs_mutex_);

    if (isShuttingDown())
    {
      return false;
    }

    ROS_DEBUG(&quot;Received update for topic [%s] (%d publishers)&quot;, topic.c_str(), (int)pubs.size());
    // find the subscription
    for (L_Subscription::const_iterator s  = subscriptions_.begin();
                                            s != subscriptions_.end(); ++s)
    {
      if ((*s)-&gt;getName() != topic || (*s)-&gt;isDropped())
        continue;

      sub = *s;
      break;
    }

  }

  if (sub)
  {
    return sub-&gt;pubUpdate(pubs);
  }
  else
  {
    ROSCPP_LOG_DEBUG(&quot;got a request for updating publishers of topic %s, but I &quot; \
              &quot;don't have any subscribers to that topic.&quot;, topic.c_str());
  }

  return false;
}

bool TopicManager::requestTopic(const string &amp;topic,
                         XmlRpcValue &amp;protos,
                         XmlRpcValue &amp;ret)
{
  for (int proto_idx = 0; proto_idx &lt; protos.size(); proto_idx++)
  {
    XmlRpcValue proto = protos[proto_idx]; // save typing
    if (proto.getType() != XmlRpcValue::TypeArray)
    {
    	ROSCPP_LOG_DEBUG( &quot;requestTopic protocol list was not a list of lists&quot;);
      return false;
    }

    if (proto[0].getType() != XmlRpcValue::TypeString)
    {
    	ROSCPP_LOG_DEBUG( &quot;requestTopic received a protocol list in which a sublist &quot; \
                 &quot;did not start with a string&quot;);
      return false;
    }

    string proto_name = proto[0];
    if (proto_name == string(&quot;TCPROS&quot;))
    {
      XmlRpcValue tcpros_params;
      tcpros_params[0] = string(&quot;TCPROS&quot;);
      tcpros_params[1] = network::getHost();
      tcpros_params[2] = int(connection_manager_-&gt;getTCPPort());
      ret[0] = int(1);
      ret[1] = string();
      ret[2] = tcpros_params;
      return true;
    }
    else if (proto_name == string(&quot;UDPROS&quot;))
    {
      if (proto.size() != 5 ||
          proto[1].getType() != XmlRpcValue::TypeBase64 ||
          proto[2].getType() != XmlRpcValue::TypeString ||
          proto[3].getType() != XmlRpcValue::TypeInt ||
          proto[4].getType() != XmlRpcValue::TypeInt)
      {
      	ROSCPP_LOG_DEBUG(&quot;Invalid protocol parameters for UDPROS&quot;);
        return false;
      }
      std::vector&lt;char&gt; header_bytes = proto[1];
      boost::shared_array&lt;uint8_t&gt; buffer(new uint8_t[header_bytes.size()]);
      memcpy(buffer.get(), &amp;header_bytes[0], header_bytes.size());
      Header h;
      string err;
      if (!h.parse(buffer, header_bytes.size(), err))
      {
      	ROSCPP_LOG_DEBUG(&quot;Unable to parse UDPROS connection header: %s&quot;, err.c_str());
        return false;
      }

      PublicationPtr pub_ptr = lookupPublication(topic);
      if(!pub_ptr)
      {
      	ROSCPP_LOG_DEBUG(&quot;Unable to find advertised topic %s for UDPROS connection&quot;, topic.c_str());
        return false;
      }

      std::string host = proto[2];
      int port = proto[3];

      M_string m;
      std::string error_msg;
      if (!pub_ptr-&gt;validateHeader(h, error_msg))
      {
        ROSCPP_LOG_DEBUG(&quot;Error validating header from [%s:%d] for topic [%s]: %s&quot;, host.c_str(), port, topic.c_str(), error_msg.c_str());
        return false;
      }

      int max_datagram_size = proto[4];
      int conn_id = connection_manager_-&gt;getNewConnectionID();
      TransportUDPPtr transport = connection_manager_-&gt;getUDPServerTransport()-&gt;createOutgoing(host, port, conn_id, max_datagram_size);
      if (!transport)
      {
        ROSCPP_LOG_DEBUG(&quot;Error creating outgoing transport for [%s:%d]&quot;, host.c_str(), port);
        return false;
      }
      connection_manager_-&gt;udprosIncomingConnection(transport, h);

      XmlRpcValue udpros_params;
      udpros_params[0] = string(&quot;UDPROS&quot;);
      udpros_params[1] = network::getHost();
      udpros_params[2] = connection_manager_-&gt;getUDPServerTransport()-&gt;getServerPort();
      udpros_params[3] = conn_id;
      udpros_params[4] = max_datagram_size;
      m[&quot;topic&quot;] = topic;
      m[&quot;md5sum&quot;] = pub_ptr-&gt;getMD5Sum();
      m[&quot;type&quot;] = pub_ptr-&gt;getDataType();
      m[&quot;callerid&quot;] = this_node::getName();
      m[&quot;message_definition&quot;] = pub_ptr-&gt;getMessageDefinition();
      boost::shared_array&lt;uint8_t&gt; msg_def_buffer;
      uint32_t len;
      Header::write(m, msg_def_buffer, len);
      XmlRpcValue v(msg_def_buffer.get(), len);
      udpros_params[5] = v;
      ret[0] = int(1);
      ret[1] = string();
      ret[2] = udpros_params;
      return true;
    }
    else
    {
      ROSCPP_LOG_DEBUG( &quot;an unsupported protocol was offered: [%s]&quot;,
          proto_name.c_str());
    }
  }

  ROSCPP_LOG_DEBUG( &quot;Currently, roscpp only supports TCPROS. The caller to &quot; \
             &quot;requestTopic did not support TCPROS, so there are no &quot; \
             &quot;protocols in common.&quot;);
  return false;
}

void TopicManager::publish(const std::string&amp; topic, const boost::function&lt;SerializedMessage(void)&gt;&amp; serfunc, SerializedMessage&amp; m)
{
  boost::recursive_mutex::scoped_lock lock(advertised_topics_mutex_);

  if (isShuttingDown())
  {
    return;
  }

  PublicationPtr p = lookupPublicationWithoutLock(topic);
  if (p-&gt;hasSubscribers() || p-&gt;isLatching())
  {
    ROS_DEBUG_NAMED(&quot;superdebug&quot;, &quot;Publishing message on topic [%s] with sequence number [%d]&quot;, p-&gt;getName().c_str(), p-&gt;getSequence());

    // Determine what kinds of subscribers we're publishing to.  If they're intraprocess with the same C++ type we can
    // do a no-copy publish.
    bool nocopy = false;
    bool serialize = false;

    // We can only do a no-copy publish if a shared_ptr to the message is provided, and we have type information for it
    if (m.type_info &amp;&amp; m.message)
    {
      p-&gt;getPublishTypes(serialize, nocopy, *m.type_info);
    }
    else
    {
      serialize = true;
    }

    if (!nocopy)
    {
      m.message.reset();
      m.type_info = 0;
    }

    if (serialize || p-&gt;isLatching())
    {
      SerializedMessage m2 = serfunc();
      m.buf = m2.buf;
      m.num_bytes = m2.num_bytes;
      m.message_start = m2.message_start;
    }

    p-&gt;publish(m);

    // If we're not doing a serialized publish we don't need to signal the pollset.  The write()
    // call inside signal() is actually relatively expensive when doing a nocopy publish.
    if (serialize)
    {
      poll_manager_-&gt;getPollSet().signal();
    }
  }
  else
  {
    p-&gt;incrementSequence();
  }
}

void TopicManager::incrementSequence(const std::string&amp; topic)
{
  PublicationPtr pub = lookupPublication(topic);
  if (pub)
  {
    pub-&gt;incrementSequence();
  }
}

bool TopicManager::isLatched(const std::string&amp; topic)
{
  PublicationPtr pub = lookupPublication(topic);
  if (pub)
  {
    return pub-&gt;isLatched();
  }

  return false;
}

PublicationPtr TopicManager::lookupPublicationWithoutLock(const string &amp;topic)
{
  PublicationPtr t;
  for (V_Publication::iterator i = advertised_topics_.begin();
       !t &amp;&amp; i != advertised_topics_.end(); ++i)
  {
    if (((*i)-&gt;getName() == topic) &amp;&amp; (!(*i)-&gt;isDropped()))
    {
      t = *i;
      break;
    }
  }

  return t;
}

bool TopicManager::unsubscribe(const std::string &amp;topic, const SubscriptionCallbackHelperPtr&amp; helper)
{
  SubscriptionPtr sub;

  {
    boost::mutex::scoped_lock lock(subs_mutex_);

    if (isShuttingDown())
    {
      return false;
    }

    L_Subscription::iterator it;
    for (it = subscriptions_.begin();
         it != subscriptions_.end(); ++it)
    {
      if ((*it)-&gt;getName() == topic)
      {
        sub = *it;
        break;
      }
    }
  }

  if (!sub)
  {
    return false;
  }

  sub-&gt;removeCallback(helper);

  if (sub-&gt;getNumCallbacks() == 0)
  {
    // nobody is left. blow away the subscription.
    {
      boost::mutex::scoped_lock lock(subs_mutex_);

      L_Subscription::iterator it;
      for (it = subscriptions_.begin();
           it != subscriptions_.end(); ++it)
      {
        if ((*it)-&gt;getName() == topic)
        {
          subscriptions_.erase(it);
          break;
        }
      }

      if (!unregisterSubscriber(topic))
      {
      	ROSCPP_LOG_DEBUG(&quot;Couldn't unregister subscriber for topic [%s]&quot;, topic.c_str());
      }
    }

    sub-&gt;shutdown();
    return true;
  }

  return true;
}

size_t TopicManager::getNumSubscribers(const std::string &amp;topic)
{
  boost::recursive_mutex::scoped_lock lock(advertised_topics_mutex_);

  if (isShuttingDown())
  {
    return 0;
  }

  PublicationPtr p = lookupPublicationWithoutLock(topic);
  if (p)
  {
    return p-&gt;getNumSubscribers();
  }

  return 0;
}

size_t TopicManager::getNumSubscriptions()
{
  boost::mutex::scoped_lock lock(subs_mutex_);
  return subscriptions_.size();
}

size_t TopicManager::getNumPublishers(const std::string &amp;topic)
{
  boost::mutex::scoped_lock lock(subs_mutex_);

  if (isShuttingDown())
  {
    return 0;
  }

  for (L_Subscription::const_iterator t = subscriptions_.begin();
       t != subscriptions_.end(); ++t)
  {
    if (!(*t)-&gt;isDropped() &amp;&amp; (*t)-&gt;getName() == topic)
    {
      return (*t)-&gt;getNumPublishers();
    }
  }

  return 0;
}

void TopicManager::getBusStats(XmlRpcValue &amp;stats)
{
  XmlRpcValue publish_stats, subscribe_stats, service_stats;
  // force these guys to be arrays, even if we don't populate them
  publish_stats.setSize(0);
  subscribe_stats.setSize(0);
  service_stats.setSize(0);

  uint32_t pidx = 0;
  {
    boost::recursive_mutex::scoped_lock lock(advertised_topics_mutex_);
    for (V_Publication::iterator t = advertised_topics_.begin();
         t != advertised_topics_.end(); ++t)
    {
      publish_stats[pidx++] = (*t)-&gt;getStats();
    }
  }

  {
    uint32_t sidx = 0;

    boost::mutex::scoped_lock lock(subs_mutex_);
    for (L_Subscription::iterator t = subscriptions_.begin(); t != subscriptions_.end(); ++t)
    {
      subscribe_stats[sidx++] = (*t)-&gt;getStats();
    }
  }

  stats[0] = publish_stats;
  stats[1] = subscribe_stats;
  stats[2] = service_stats;
}

void TopicManager::getBusInfo(XmlRpcValue &amp;info)
{
  // force these guys to be arrays, even if we don't populate them
  info.setSize(0);

  {
<A NAME="2"></A>    boost::recursive_mutex::scoped_lock lock(advertised_topics_mutex_);

    for (V_Publication::iterator t = advertised_topics_.begin();
<FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match655-0.html#2',2,'match655-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>         t != advertised_topics_.end(); ++t)
    {
      (*t)-&gt;getInfo(info);
    }
  }

  {
    boost::mutex::scoped_lock lock(subs_mutex_);

    for (L_Subscription::iterator t = subscriptions_.begin(); t != subscriptions_.end(); ++t)
    {</B></FONT>
      (*t)-&gt;getInfo(info);
    }
  }
}

void TopicManager::getSubscriptions(XmlRpcValue &amp;subs)
{
  // force these guys to be arrays, even if we don't populate them
  subs.setSize(0);

  {
    boost::mutex::scoped_lock lock(subs_mutex_);

    uint32_t sidx = 0;

    for (L_Subscription::iterator t = subscriptions_.begin(); t != subscriptions_.end(); ++t)
    {
      XmlRpcValue sub;
      sub[0] = (*t)-&gt;getName();
      sub[1] = (*t)-&gt;datatype();
      subs[sidx++] = sub;
    }
  }
}

void TopicManager::getPublications(XmlRpcValue &amp;pubs)
{
  // force these guys to be arrays, even if we don't populate them
  pubs.setSize(0);

  {
    boost::recursive_mutex::scoped_lock lock(advertised_topics_mutex_);

    uint32_t sidx = 0;

    for (V_Publication::iterator t = advertised_topics_.begin();
         t != advertised_topics_.end(); ++t)
    {
      XmlRpcValue pub;
      pub[0] = (*t)-&gt;getName();
      pub[1] = (*t)-&gt;getDataType();
      pubs[sidx++] = pub;
    }

  }
}

void TopicManager::pubUpdateCallback(XmlRpc::XmlRpcValue&amp; params, XmlRpc::XmlRpcValue&amp; result)
{
  std::vector&lt;std::string&gt; pubs;
  for (int idx = 0; idx &lt; params[2].size(); idx++)
  {
    pubs.push_back(params[2][idx]);
  }
  if (pubUpdate(params[1], pubs))
  {
    result = xmlrpc::responseInt(1, &quot;&quot;, 0);
  }
  else
  {
    result = xmlrpc::responseInt(0, console::g_last_error_message, 0);
  }
}

void TopicManager::requestTopicCallback(XmlRpc::XmlRpcValue&amp; params, XmlRpc::XmlRpcValue&amp; result)
{
  if (!requestTopic(params[1], params[2], result))
  {
    result = xmlrpc::responseInt(0, console::g_last_error_message, 0);
  }
}

void TopicManager::getBusStatsCallback(XmlRpc::XmlRpcValue&amp; params, XmlRpc::XmlRpcValue&amp; result)
{
  (void)params;
  result[0] = 1;
  result[1] = std::string(&quot;&quot;);
  XmlRpcValue response;
  getBusStats(result);
  result[2] = response;
}

void TopicManager::getBusInfoCallback(XmlRpc::XmlRpcValue&amp; params, XmlRpc::XmlRpcValue&amp; result)
{
  (void)params;
  result[0] = 1;
  result[1] = std::string(&quot;&quot;);
  XmlRpcValue response;
  getBusInfo(response);
  result[2] = response;
}

void TopicManager::getSubscriptionsCallback(XmlRpc::XmlRpcValue&amp; params, XmlRpc::XmlRpcValue&amp; result)
{
  (void)params;
  result[0] = 1;
  result[1] = std::string(&quot;subscriptions&quot;);
  XmlRpcValue response;
  getSubscriptions(response);
  result[2] = response;
}

void TopicManager::getPublicationsCallback(XmlRpc::XmlRpcValue&amp; params, XmlRpc::XmlRpcValue&amp; result)
{
  (void)params;
  result[0] = 1;
  result[1] = std::string(&quot;publications&quot;);
  XmlRpcValue response;
  getPublications(response);
  result[2] = response;
}

} // namespace ros
</PRE>
</div>
  </div>
</body>
</html>
