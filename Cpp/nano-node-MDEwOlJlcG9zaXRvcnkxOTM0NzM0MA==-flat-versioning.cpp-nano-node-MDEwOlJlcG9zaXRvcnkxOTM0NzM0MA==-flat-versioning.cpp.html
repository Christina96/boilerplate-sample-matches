
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 74, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-versioning.cpp</h3>
            <pre><code>1  #include <nano/secure/versioning.hpp>
2  #include <boost/endian/conversion.hpp>
3  #include <lmdb/libraries/liblmdb/lmdb.h>
4  nano::pending_info_v14::pending_info_v14 (nano::account const & source_a, nano::amount const & amount_a, nano::epoch epoch_a) :
5  	source (source_a),
6  	amount (amount_a),
7  	epoch (epoch_a)
8  {
9  }
10  bool nano::pending_info_v14::deserialize (nano::stream & stream_a)
11  {
12  	auto error (false);
13  	try
14  	{
15  		nano::read (stream_a, source.bytes);
16  		nano::read (stream_a, amount.bytes);
17  	}
18  	catch (std::runtime_error const &)
19  	{
20  		error = true;
21  	}
22  	return error;
23  }
24  size_t nano::pending_info_v14::db_size () const
25  {
26  	return sizeof (source) + sizeof (amount);
27  }
28  bool nano::pending_info_v14::operator== (nano::pending_info_v14 const & other_a) const
29  {
30  	return source == other_a.source && amount == other_a.amount && epoch == other_a.epoch;
31  }
32  nano::account_info_v14::account_info_v14 (nano::block_hash const & head_a, nano::block_hash const & rep_block_a, nano::block_hash const & open_block_a, nano::amount const & balance_a, uint64_t modified_a, uint64_t block_count_a, uint64_t confirmation_height_a, nano::epoch epoch_a) :
33  	head (head_a),
34  	rep_block (rep_block_a),
35  	open_block (open_block_a),
36  	balance (balance_a),
37  	modified (modified_a),
38  	block_count (block_count_a),
39  	confirmation_height (confirmation_height_a),
40  	epoch (epoch_a)
41  {
42  }
43  size_t nano::account_info_v14::db_size () const
44  {
45  	debug_assert (reinterpret_cast<uint8_t const *> (this) == reinterpret_cast<uint8_t const *> (&head));
46  	debug_assert (reinterpret_cast<uint8_t const *> (&head) + sizeof (head) == reinterpret_cast<uint8_t const *> (&rep_block));
47  	debug_assert (reinterpret_cast<uint8_t const *> (&rep_block) + sizeof (rep_block) == reinterpret_cast<uint8_t const *> (&open_block));
48  	debug_assert (reinterpret_cast<uint8_t const *> (&open_block) + sizeof (open_block) == reinterpret_cast<uint8_t const *> (&balance));
49  	debug_assert (reinterpret_cast<uint8_t const *> (&balance) + sizeof (balance) == reinterpret_cast<uint8_t const *> (&modified));
50  	debug_assert (reinterpret_cast<uint8_t const *> (&modified) + sizeof (modified) == reinterpret_cast<uint8_t const *> (&block_count));
51  	debug_assert (reinterpret_cast<uint8_t const *> (&block_count) + sizeof (block_count) == reinterpret_cast<uint8_t const *> (&confirmation_height));
52  	return sizeof (head) + sizeof (rep_block) + sizeof (open_block) + sizeof (balance) + sizeof (modified) + sizeof (block_count) + sizeof (confirmation_height);
53  }
54  nano::block_sideband_v14::block_sideband_v14 (nano::block_type type_a, nano::account const & account_a, nano::block_hash const & successor_a, nano::amount const & balance_a, uint64_t height_a, uint64_t timestamp_a) :
55  	type (type_a),
56  	successor (successor_a),
57  	account (account_a),
58  	balance (balance_a),
59  	height (height_a),
60  	timestamp (timestamp_a)
61  {
62  }
63  size_t nano::block_sideband_v14::size (nano::block_type type_a)
64  {
65  	size_t result (0);
66  	result += sizeof (successor);
67  	if (type_a != nano::block_type::state && type_a != nano::block_type::open)
68  	{
69  		result += sizeof (account);
70  	}
71  	if (type_a != nano::block_type::open)
72  	{
73  		result += sizeof (height);
74  	}
75  	if (type_a == nano::block_type::receive || type_a == nano::block_type::change || type_a == nano::block_type::open)
76  	{
77  		result += sizeof (balance);
78  	}
79  	result += sizeof (timestamp);
80  	return result;
81  }
82  void nano::block_sideband_v14::serialize (nano::stream & stream_a) const
83  {
84  	nano::write (stream_a, successor.bytes);
85  	if (type != nano::block_type::state && type != nano::block_type::open)
86  	{
87  		nano::write (stream_a, account.bytes);
88  	}
89  	if (type != nano::block_type::open)
90  	{
91  		nano::write (stream_a, boost::endian::native_to_big (height));
92  	}
93  	if (type == nano::block_type::receive || type == nano::block_type::change || type == nano::block_type::open)
94  	{
95  		nano::write (stream_a, balance.bytes);
96  	}
97  	nano::write (stream_a, boost::endian::native_to_big (timestamp));
98  }
99  bool nano::block_sideband_v14::deserialize (nano::stream & stream_a)
100  {
101  	bool result (false);
102  	try
103  	{
104  		nano::read (stream_a, successor.bytes);
105  		if (type != nano::block_type::state && type != nano::block_type::open)
106  		{
107  			nano::read (stream_a, account.bytes);
108  		}
109  		if (type != nano::block_type::open)
110  		{
111  			nano::read (stream_a, height);
112  			boost::endian::big_to_native_inplace (height);
113  		}
114  		else
115  		{
116  			height = 1;
117  		}
118  		if (type == nano::block_type::receive || type == nano::block_type::change || type == nano::block_type::open)
119  		{
120  			nano::read (stream_a, balance.bytes);
121  		}
122  		nano::read (stream_a, timestamp);
123  		boost::endian::big_to_native_inplace (timestamp);
124  	}
125  	catch (std::runtime_error &)
126  	{
127  		result = true;
128  	}
129  	return result;
130  }
131  nano::block_sideband_v18::block_sideband_v18 (nano::account const & account_a, nano::block_hash const & successor_a, nano::amount const & balance_a, uint64_t height_a, uint64_t timestamp_a, nano::block_details const & details_a) :
132  	successor (successor_a),
133  	account (account_a),
134  	balance (balance_a),
135  	height (height_a),
136  	timestamp (timestamp_a),
137  	details (details_a)
138  {
139  }
140  nano::block_sideband_v18::block_sideband_v18 (nano::account const & account_a, nano::block_hash const & successor_a, nano::amount const & balance_a, uint64_t height_a, uint64_t timestamp_a, nano::epoch epoch_a, bool is_send, bool is_receive, bool is_epoch) :
141  	successor (successor_a),
142  	account (account_a),
143  	balance (balance_a),
144  	height (height_a),
145  	timestamp (timestamp_a),
146  	details (epoch_a, is_send, is_receive, is_epoch)
147  {
148  }
149  size_t nano::block_sideband_v18::size (nano::block_type type_a)
150  {
151  	size_t result (0);
152  	result += sizeof (successor);
153  	if (type_a != nano::block_type::state && type_a != nano::block_type::open)
154  	{
155  		result += sizeof (account);
156  	}
157  	if (type_a != nano::block_type::open)
158  	{
159  		result += sizeof (height);
160  	}
161  	if (type_a == nano::block_type::receive || type_a == nano::block_type::change || type_a == nano::block_type::open)
162  	{
163  		result += sizeof (balance);
164  	}
165  	result += sizeof (timestamp);
166  	if (type_a == nano::block_type::state)
167  	{
168  		static_assert (sizeof (nano::epoch) == nano::block_details::size (), "block_details_v18 is larger than the epoch enum");
169  		result += nano::block_details::size ();
170  	}
171  	return result;
172  }
173  void nano::block_sideband_v18::serialize (nano::stream & stream_a, nano::block_type type_a) const
174  {
175  	nano::write (stream_a, successor.bytes);
176  	if (type_a != nano::block_type::state && type_a != nano::block_type::open)
177  	{
178  		nano::write (stream_a, account.bytes);
179  	}
180  	if (type_a != nano::block_type::open)
181  	{
182  		nano::write (stream_a, boost::endian::native_to_big (height));
183  	}
184  	if (type_a == nano::block_type::receive || type_a == nano::block_type::change || type_a == nano::block_type::open)
185  	{
186  		nano::write (stream_a, balance.bytes);
187  	}
188  	nano::write (stream_a, boost::endian::native_to_big (timestamp));
189  	if (type_a == nano::block_type::state)
190  	{
191  		details.serialize (stream_a);
192  	}
193  }
194  bool nano::block_sideband_v18::deserialize (nano::stream & stream_a, nano::block_type type_a)
195  {
196  	bool result (false);
197  	try
198  	{
199  		nano::read (stream_a, successor.bytes);
200  		if (type_a != nano::block_type::state && type_a != nano::block_type::open)
201  		{
202  			nano::read (stream_a, account.bytes);
203  		}
204  		if (type_a != nano::block_type::open)
205  		{
206  			nano::read (stream_a, height);
<span onclick='openModal()' class='match'>207  			boost::endian::big_to_native_inplace (height);
208  		}
209  		else
210  		{
211  			height = 1;
212  		}
213  		if (type_a == nano::block_type::receive || type_a == nano::block_type::change || type_a == nano::block_type::open)
214  		{
215  			nano::read (stream_a, balance.bytes);
216  		}
217  		nano::read (stream_a, timestamp);
218  		boost::endian::big_to_native_inplace (timestamp);
219  		if (type_a == nano::block_type::state)
</span>220  		{
221  			result = details.deserialize (stream_a);
222  		}
223  	}
224  	catch (std::runtime_error &)
225  	{
226  		result = true;
227  	}
228  	return result;
229  }
</code></pre>
        </div>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-versioning.cpp</h3>
            <pre><code>1  #include <nano/secure/versioning.hpp>
2  #include <boost/endian/conversion.hpp>
3  #include <lmdb/libraries/liblmdb/lmdb.h>
4  nano::pending_info_v14::pending_info_v14 (nano::account const & source_a, nano::amount const & amount_a, nano::epoch epoch_a) :
5  	source (source_a),
6  	amount (amount_a),
7  	epoch (epoch_a)
8  {
9  }
10  bool nano::pending_info_v14::deserialize (nano::stream & stream_a)
11  {
12  	auto error (false);
13  	try
14  	{
15  		nano::read (stream_a, source.bytes);
16  		nano::read (stream_a, amount.bytes);
17  	}
18  	catch (std::runtime_error const &)
19  	{
20  		error = true;
21  	}
22  	return error;
23  }
24  size_t nano::pending_info_v14::db_size () const
25  {
26  	return sizeof (source) + sizeof (amount);
27  }
28  bool nano::pending_info_v14::operator== (nano::pending_info_v14 const & other_a) const
29  {
30  	return source == other_a.source && amount == other_a.amount && epoch == other_a.epoch;
31  }
32  nano::account_info_v14::account_info_v14 (nano::block_hash const & head_a, nano::block_hash const & rep_block_a, nano::block_hash const & open_block_a, nano::amount const & balance_a, uint64_t modified_a, uint64_t block_count_a, uint64_t confirmation_height_a, nano::epoch epoch_a) :
33  	head (head_a),
34  	rep_block (rep_block_a),
35  	open_block (open_block_a),
36  	balance (balance_a),
37  	modified (modified_a),
38  	block_count (block_count_a),
39  	confirmation_height (confirmation_height_a),
40  	epoch (epoch_a)
41  {
42  }
43  size_t nano::account_info_v14::db_size () const
44  {
45  	debug_assert (reinterpret_cast<uint8_t const *> (this) == reinterpret_cast<uint8_t const *> (&head));
46  	debug_assert (reinterpret_cast<uint8_t const *> (&head) + sizeof (head) == reinterpret_cast<uint8_t const *> (&rep_block));
47  	debug_assert (reinterpret_cast<uint8_t const *> (&rep_block) + sizeof (rep_block) == reinterpret_cast<uint8_t const *> (&open_block));
48  	debug_assert (reinterpret_cast<uint8_t const *> (&open_block) + sizeof (open_block) == reinterpret_cast<uint8_t const *> (&balance));
49  	debug_assert (reinterpret_cast<uint8_t const *> (&balance) + sizeof (balance) == reinterpret_cast<uint8_t const *> (&modified));
50  	debug_assert (reinterpret_cast<uint8_t const *> (&modified) + sizeof (modified) == reinterpret_cast<uint8_t const *> (&block_count));
51  	debug_assert (reinterpret_cast<uint8_t const *> (&block_count) + sizeof (block_count) == reinterpret_cast<uint8_t const *> (&confirmation_height));
52  	return sizeof (head) + sizeof (rep_block) + sizeof (open_block) + sizeof (balance) + sizeof (modified) + sizeof (block_count) + sizeof (confirmation_height);
53  }
54  nano::block_sideband_v14::block_sideband_v14 (nano::block_type type_a, nano::account const & account_a, nano::block_hash const & successor_a, nano::amount const & balance_a, uint64_t height_a, uint64_t timestamp_a) :
55  	type (type_a),
56  	successor (successor_a),
57  	account (account_a),
58  	balance (balance_a),
59  	height (height_a),
60  	timestamp (timestamp_a)
61  {
62  }
63  size_t nano::block_sideband_v14::size (nano::block_type type_a)
64  {
65  	size_t result (0);
66  	result += sizeof (successor);
67  	if (type_a != nano::block_type::state && type_a != nano::block_type::open)
68  	{
69  		result += sizeof (account);
70  	}
71  	if (type_a != nano::block_type::open)
72  	{
73  		result += sizeof (height);
74  	}
75  	if (type_a == nano::block_type::receive || type_a == nano::block_type::change || type_a == nano::block_type::open)
76  	{
77  		result += sizeof (balance);
78  	}
79  	result += sizeof (timestamp);
80  	return result;
81  }
82  void nano::block_sideband_v14::serialize (nano::stream & stream_a) const
83  {
84  	nano::write (stream_a, successor.bytes);
85  	if (type != nano::block_type::state && type != nano::block_type::open)
86  	{
87  		nano::write (stream_a, account.bytes);
88  	}
89  	if (type != nano::block_type::open)
90  	{
91  		nano::write (stream_a, boost::endian::native_to_big (height));
92  	}
93  	if (type == nano::block_type::receive || type == nano::block_type::change || type == nano::block_type::open)
94  	{
95  		nano::write (stream_a, balance.bytes);
96  	}
97  	nano::write (stream_a, boost::endian::native_to_big (timestamp));
98  }
99  bool nano::block_sideband_v14::deserialize (nano::stream & stream_a)
100  {
101  	bool result (false);
102  	try
103  	{
104  		nano::read (stream_a, successor.bytes);
105  		if (type != nano::block_type::state && type != nano::block_type::open)
106  		{
107  			nano::read (stream_a, account.bytes);
108  		}
109  		if (type != nano::block_type::open)
110  		{
111  			nano::read (stream_a, height);
112  			boost::endian::big_to_native_inplace (height);
113  		}
114  		else
115  		{
116  			height = 1;
117  		}
118  		if (type == nano::block_type::receive || type == nano::block_type::change || type == nano::block_type::open)
119  		{
120  			nano::read (stream_a, balance.bytes);
121  		}
122  		nano::read (stream_a, timestamp);
123  		boost::endian::big_to_native_inplace (timestamp);
124  	}
125  	catch (std::runtime_error &)
126  	{
127  		result = true;
128  	}
129  	return result;
130  }
131  nano::block_sideband_v18::block_sideband_v18 (nano::account const & account_a, nano::block_hash const & successor_a, nano::amount const & balance_a, uint64_t height_a, uint64_t timestamp_a, nano::block_details const & details_a) :
132  	successor (successor_a),
133  	account (account_a),
134  	balance (balance_a),
135  	height (height_a),
136  	timestamp (timestamp_a),
137  	details (details_a)
138  {
139  }
140  nano::block_sideband_v18::block_sideband_v18 (nano::account const & account_a, nano::block_hash const & successor_a, nano::amount const & balance_a, uint64_t height_a, uint64_t timestamp_a, nano::epoch epoch_a, bool is_send, bool is_receive, bool is_epoch) :
141  	successor (successor_a),
142  	account (account_a),
143  	balance (balance_a),
144  	height (height_a),
145  	timestamp (timestamp_a),
146  	details (epoch_a, is_send, is_receive, is_epoch)
147  {
148  }
149  size_t nano::block_sideband_v18::size (nano::block_type type_a)
150  {
151  	size_t result (0);
152  	result += sizeof (successor);
153  	if (type_a != nano::block_type::state && type_a != nano::block_type::open)
154  	{
155  		result += sizeof (account);
156  	}
157  	if (type_a != nano::block_type::open)
158  	{
159  		result += sizeof (height);
160  	}
161  	if (type_a == nano::block_type::receive || type_a == nano::block_type::change || type_a == nano::block_type::open)
162  	{
163  		result += sizeof (balance);
164  	}
165  	result += sizeof (timestamp);
166  	if (type_a == nano::block_type::state)
167  	{
168  		static_assert (sizeof (nano::epoch) == nano::block_details::size (), "block_details_v18 is larger than the epoch enum");
169  		result += nano::block_details::size ();
170  	}
171  	return result;
172  }
173  void nano::block_sideband_v18::serialize (nano::stream & stream_a, nano::block_type type_a) const
174  {
175  	nano::write (stream_a, successor.bytes);
176  	if (type_a != nano::block_type::state && type_a != nano::block_type::open)
177  	{
178  		nano::write (stream_a, account.bytes);
179  	}
180  	if (type_a != nano::block_type::open)
181  	{
182  		nano::write (stream_a, boost::endian::native_to_big (height));
183  	}
184  	if (type_a == nano::block_type::receive || type_a == nano::block_type::change || type_a == nano::block_type::open)
185  	{
186  		nano::write (stream_a, balance.bytes);
187  	}
188  	nano::write (stream_a, boost::endian::native_to_big (timestamp));
189  	if (type_a == nano::block_type::state)
190  	{
191  		details.serialize (stream_a);
192  	}
193  }
194  bool nano::block_sideband_v18::deserialize (nano::stream & stream_a, nano::block_type type_a)
195  {
196  	bool result (false);
197  	try
198  	{
199  		nano::read (stream_a, successor.bytes);
200  		if (type_a != nano::block_type::state && type_a != nano::block_type::open)
201  		{
202  			nano::read (stream_a, account.bytes);
203  		}
204  		if (type_a != nano::block_type::open)
205  		{
206  			nano::read (stream_a, height);
<span onclick='openModal()' class='match'>207  			boost::endian::big_to_native_inplace (height);
208  		}
209  		else
210  		{
211  			height = 1;
212  		}
213  		if (type_a == nano::block_type::receive || type_a == nano::block_type::change || type_a == nano::block_type::open)
214  		{
215  			nano::read (stream_a, balance.bytes);
216  		}
217  		nano::read (stream_a, timestamp);
218  		boost::endian::big_to_native_inplace (timestamp);
219  		if (type_a == nano::block_type::state)
</span>220  		{
221  			result = details.deserialize (stream_a);
222  		}
223  	}
224  	catch (std::runtime_error &)
225  	{
226  		result = true;
227  	}
228  	return result;
229  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-versioning.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-versioning.cpp</div>
                </div>
                <div class="column column_space"><pre><code>207  			boost::endian::big_to_native_inplace (height);
208  		}
209  		else
210  		{
211  			height = 1;
212  		}
213  		if (type_a == nano::block_type::receive || type_a == nano::block_type::change || type_a == nano::block_type::open)
214  		{
215  			nano::read (stream_a, balance.bytes);
216  		}
217  		nano::read (stream_a, timestamp);
218  		boost::endian::big_to_native_inplace (timestamp);
219  		if (type_a == nano::block_type::state)
</pre></code></div>
                <div class="column column_space"><pre><code>207  			boost::endian::big_to_native_inplace (height);
208  		}
209  		else
210  		{
211  			height = 1;
212  		}
213  		if (type_a == nano::block_type::receive || type_a == nano::block_type::change || type_a == nano::block_type::open)
214  		{
215  			nano::read (stream_a, balance.bytes);
216  		}
217  		nano::read (stream_a, timestamp);
218  		boost::endian::big_to_native_inplace (timestamp);
219  		if (type_a == nano::block_type::state)
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    