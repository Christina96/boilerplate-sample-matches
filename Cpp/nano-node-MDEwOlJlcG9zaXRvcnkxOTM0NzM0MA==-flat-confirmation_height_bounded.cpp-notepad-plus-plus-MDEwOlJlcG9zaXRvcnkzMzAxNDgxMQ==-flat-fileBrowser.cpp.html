
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 3.016759776536313%, Tokens: 9</h2>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-confirmation_height_bounded.cpp</h3>
            <pre><code>1  #include <nano/lib/logger_mt.hpp>
2  #include <nano/lib/stats.hpp>
3  #include <nano/node/confirmation_height_bounded.hpp>
4  #include <nano/node/logging.hpp>
5  #include <nano/node/write_database_queue.hpp>
6  #include <nano/secure/ledger.hpp>
7  #include <boost/format.hpp>
8  #include <numeric>
9  nano::confirmation_height_bounded::confirmation_height_bounded (nano::ledger & ledger_a, nano::write_database_queue & write_database_queue_a, std::chrono::milliseconds batch_separate_pending_min_time_a, nano::logging const & logging_a, nano::logger_mt & logger_a, std::atomic<bool> & stopped_a, uint64_t & batch_write_size_a, std::function<void (std::vector<std::shared_ptr<nano::block>> const &)> const & notify_observers_callback_a, std::function<void (nano::block_hash const &)> const & notify_block_already_cemented_observers_callback_a, std::function<uint64_t ()> const & awaiting_processing_size_callback_a) :
10  	ledger (ledger_a),
11  	write_database_queue (write_database_queue_a),
12  	batch_separate_pending_min_time (batch_separate_pending_min_time_a),
13  	logging (logging_a),
14  	logger (logger_a),
15  	stopped (stopped_a),
16  	batch_write_size (batch_write_size_a),
17  	notify_observers_callback (notify_observers_callback_a),
18  	notify_block_already_cemented_observers_callback (notify_block_already_cemented_observers_callback_a),
19  	awaiting_processing_size_callback (awaiting_processing_size_callback_a)
20  {
21  }
22  nano::confirmation_height_bounded::top_and_next_hash nano::confirmation_height_bounded::get_next_block (boost::optional<top_and_next_hash> const & next_in_receive_chain_a, boost::circular_buffer_space_optimized<nano::block_hash> const & checkpoints_a, boost::circular_buffer_space_optimized<receive_source_pair> const & receive_source_pairs, boost::optional<receive_chain_details> & receive_details_a, nano::block const & original_block)
23  {
24  	top_and_next_hash next;
25  	if (next_in_receive_chain_a.is_initialized ())
26  	{
27  		next = *next_in_receive_chain_a;
28  	}
29  	else if (!receive_source_pairs.empty ())
30  	{
31  		auto next_receive_source_pair = receive_source_pairs.back ();
32  		receive_details_a = next_receive_source_pair.receive_details;
33  		next = { next_receive_source_pair.source_hash, receive_details_a->next, receive_details_a->height + 1 };
34  	}
35  	else if (!checkpoints_a.empty ())
36  	{
37  		next = { checkpoints_a.back (), boost::none, 0 };
38  	}
39  	else
40  	{
41  		next = { original_block.hash (), boost::none, 0 };
42  	}
43  	return next;
44  }
45  void nano::confirmation_height_bounded::process (std::shared_ptr<nano::block> original_block)
46  {
47  	if (pending_empty ())
48  	{
49  		clear_process_vars ();
50  		timer.restart ();
51  	}
52  	boost::optional<top_and_next_hash> next_in_receive_chain;
53  	boost::circular_buffer_space_optimized<nano::block_hash> checkpoints{ max_items };
54  	boost::circular_buffer_space_optimized<receive_source_pair> receive_source_pairs{ max_items };
55  	nano::block_hash current;
56  	bool first_iter = true;
57  	auto transaction (ledger.store.tx_begin_read ());
58  	do
59  	{
60  		boost::optional<receive_chain_details> receive_details;
61  		auto hash_to_process = get_next_block (next_in_receive_chain, checkpoints, receive_source_pairs, receive_details, *original_block);
62  		current = hash_to_process.top;
63  		auto top_level_hash = current;
64  		std::shared_ptr<nano::block> block;
65  		if (first_iter)
66  		{
67  			debug_assert (current == original_block->hash ());
68  			block = original_block;
69  		}
70  		else
71  		{
72  			block = ledger.store.block.get (transaction, current);
73  		}
74  		if (!block)
75  		{
76  			if (ledger.pruning && ledger.store.pruned.exists (transaction, current))
77  			{
78  				if (!receive_source_pairs.empty ())
79  				{
80  					receive_source_pairs.pop_back ();
81  				}
82  				continue;
83  			}
84  			else
85  			{
86  				auto error_str = (boost::format ("Ledger mismatch trying to set confirmation height for block %1% (bounded processor)") % current.to_string ()).str ();
87  				logger.always_log (error_str);
88  				std::cerr << error_str << std::endl;
89  				release_assert (block);
90  			}
91  		}
92  		nano::account account (block->account ());
93  		if (account.is_zero ())
94  		{
95  			account = block->sideband ().account;
96  		}
97  		nano::confirmation_height_info confirmation_height_info;
98  		auto account_it = accounts_confirmed_info.find (account);
99  		if (account_it != accounts_confirmed_info.cend ())
100  		{
101  			confirmation_height_info.height = account_it->second.confirmed_height;
102  			confirmation_height_info.frontier = account_it->second.iterated_frontier;
103  		}
104  		else
105  		{
106  			ledger.store.confirmation_height.get (transaction, account, confirmation_height_info);
107  			if (first_iter && confirmation_height_info.height >= block->sideband ().height && current == original_block->hash ())
108  			{
109  				notify_block_already_cemented_observers_callback (original_block->hash ());
110  			}
111  		}
112  		auto block_height = block->sideband ().height;
113  		bool already_cemented = confirmation_height_info.height >= block_height;
114  		if (!already_cemented && block_height - confirmation_height_info.height > 1)
115  		{
116  			if (block_height - confirmation_height_info.height == 2)
117  			{
118  				current = block->previous ();
119  				--block_height;
120  			}
121  			else if (!next_in_receive_chain.is_initialized ())
122  			{
123  				current = get_least_unconfirmed_hash_from_top_level (transaction, current, account, confirmation_height_info, block_height);
124  			}
125  			else
126  			{
127  				current = *hash_to_process.next;
128  				block_height = hash_to_process.next_height;
129  			}
130  		}
131  		auto top_most_non_receive_block_hash = current;
132  		bool hit_receive = false;
133  		if (!already_cemented)
134  		{
135  			hit_receive = iterate (transaction, block_height, current, checkpoints, top_most_non_receive_block_hash, top_level_hash, receive_source_pairs, account);
136  		}
137  		if (stopped)
138  		{
139  			break;
140  		}
141  		auto is_set = next_in_receive_chain.is_initialized ();
142  		next_in_receive_chain = boost::none;
143  		if (!hit_receive || (receive_source_pairs.size () == 1 && top_most_non_receive_block_hash != current))
144  		{
145  			preparation_data preparation_data{ transaction, top_most_non_receive_block_hash, already_cemented, checkpoints, account_it, confirmation_height_info, account, block_height, current, receive_details, next_in_receive_chain };
146  			prepare_iterated_blocks_for_cementing (preparation_data);
147  			if (!is_set && !receive_source_pairs.empty ())
148  			{
149  				receive_source_pairs.pop_back ();
150  			}
151  			auto total_pending_write_block_count = std::accumulate (pending_writes.cbegin (), pending_writes.cend (), uint64_t (0), [] (uint64_t total, auto const & write_details_a) {
152  				return total += write_details_a.top_height - write_details_a.bottom_height + 1;
153  			});
154  			auto max_batch_write_size_reached = (total_pending_write_block_count >= batch_write_size);
155  			auto min_time_exceeded = (timer.since_start () >= batch_separate_pending_min_time);
156  			auto finished_iterating = current == original_block->hash ();
157  			auto non_awaiting_processing = awaiting_processing_size_callback () == 0;
158  			auto should_output = finished_iterating && (non_awaiting_processing || min_time_exceeded);
159  			auto force_write = pending_writes.size () >= pending_writes_max_size || accounts_confirmed_info.size () >= pending_writes_max_size;
160  			if ((max_batch_write_size_reached || should_output || force_write) && !pending_writes.empty ())
161  			{
162  				if (write_database_queue.process (nano::writer::confirmation_height))
163  				{
164  					auto scoped_write_guard = write_database_queue.pop ();
165  					cement_blocks (scoped_write_guard);
166  				}
167  				else if (force_write)
168  				{
169  					auto scoped_write_guard = write_database_queue.wait (nano::writer::confirmation_height);
170  					cement_blocks (scoped_write_guard);
171  				}
172  			}
173  		}
174  		first_iter = false;
175  		transaction.refresh ();
176  	} while ((!receive_source_pairs.empty () || current != original_block->hash ()) && !stopped);
177  	debug_assert (checkpoints.empty ());
178  }
179  nano::block_hash nano::confirmation_height_bounded::get_least_unconfirmed_hash_from_top_level (nano::transaction const & transaction_a, nano::block_hash const & hash_a, nano::account const & account_a, nano::confirmation_height_info const & confirmation_height_info_a, uint64_t & block_height_a)
180  {
181  	nano::block_hash least_unconfirmed_hash = hash_a;
182  	if (confirmation_height_info_a.height != 0)
183  	{
184  		if (block_height_a > confirmation_height_info_a.height)
185  		{
186  			auto block (ledger.store.block.get (transaction_a, confirmation_height_info_a.frontier));
187  			release_assert (block != nullptr);
188  			least_unconfirmed_hash = block->sideband ().successor;
189  			block_height_a = block->sideband ().height + 1;
190  		}
191  	}
192  	else
193  	{
194  		auto info = ledger.account_info (transaction_a, account_a);
195  		release_assert (info);
196  		least_unconfirmed_hash = info->open_block;
197  		block_height_a = 1;
198  	}
199  	return least_unconfirmed_hash;
200  }
201  bool nano::confirmation_height_bounded::iterate (nano::read_transaction const & transaction_a, uint64_t bottom_height_a, nano::block_hash const & bottom_hash_a, boost::circular_buffer_space_optimized<nano::block_hash> & checkpoints_a, nano::block_hash & top_most_non_receive_block_hash_a, nano::block_hash const & top_level_hash_a, boost::circular_buffer_space_optimized<receive_source_pair> & receive_source_pairs_a, nano::account const & account_a)
202  {
203  	bool reached_target = false;
204  	bool hit_receive = false;
205  	auto hash = bottom_hash_a;
206  	uint64_t num_blocks = 0;
207  	while (!hash.is_zero () && !reached_target && !stopped)
208  	{
209  		++num_blocks;
210  		auto block = ledger.store.block.get (transaction_a, hash);
211  		auto source (block->source ());
212  		if (source.is_zero ())
213  		{
214  			source = block->link ().as_block_hash ();
215  		}
216  		if (!source.is_zero () && !ledger.is_epoch_link (source) && ledger.store.block.exists (transaction_a, source))
217  		{
218  			hit_receive = true;
219  			reached_target = true;
220  			auto const & sideband (block->sideband ());
221  			auto next = !sideband.successor.is_zero () && sideband.successor != top_level_hash_a ? boost::optional<nano::block_hash> (sideband.successor) : boost::none;
222  			receive_source_pairs_a.push_back ({ receive_chain_details{ account_a, sideband.height, hash, top_level_hash_a, next, bottom_height_a, bottom_hash_a }, source });
223  			if (receive_source_pairs_a.size () % max_items == 0)
224  			{
225  				checkpoints_a.push_back (top_level_hash_a);
226  			}
227  		}
228  		else
229  		{
230  			top_most_non_receive_block_hash_a = hash;
231  			if (hash == top_level_hash_a)
232  			{
233  				reached_target = true;
234  			}
235  			else
236  			{
237  				hash = block->sideband ().successor;
238  			}
239  		}
240  		if ((num_blocks > 0) && num_blocks % batch_read_size == 0)
241  		{
242  			transaction_a.refresh ();
243  		}
244  	}
245  	return hit_receive;
246  }
247  void nano::confirmation_height_bounded::prepare_iterated_blocks_for_cementing (preparation_data & preparation_data_a)
248  {
249  	if (!preparation_data_a.already_cemented)
250  	{
251  		auto block_height = (ledger.store.block.account_height (preparation_data_a.transaction, preparation_data_a.top_most_non_receive_block_hash));
252  		if (block_height > preparation_data_a.confirmation_height_info.height)
253  		{
254  			confirmed_info confirmed_info_l{ block_height, preparation_data_a.top_most_non_receive_block_hash };
255  			if (preparation_data_a.account_it != accounts_confirmed_info.cend ())
256  			{
257  				preparation_data_a.account_it->second = confirmed_info_l;
258  			}
259  			else
260  			{
261  				accounts_confirmed_info.emplace (preparation_data_a.account, confirmed_info_l);
262  				++accounts_confirmed_info_size;
263  			}
264  			preparation_data_a.checkpoints.erase (std::remove (preparation_data_a.checkpoints.begin (), preparation_data_a.checkpoints.end (), preparation_data_a.top_most_non_receive_block_hash), preparation_data_a.checkpoints.end ());
265  			pending_writes.emplace_back (preparation_data_a.account, preparation_data_a.bottom_height, preparation_data_a.bottom_most, block_height, preparation_data_a.top_most_non_receive_block_hash);
266  			++pending_writes_size;
267  		}
268  	}
269  	auto & receive_details = preparation_data_a.receive_details;
270  	if (receive_details)
271  	{
272  		auto receive_confirmed_info_it = accounts_confirmed_info.find (receive_details->account);
273  		if (receive_confirmed_info_it != accounts_confirmed_info.cend ())
274  		{
275  			auto & receive_confirmed_info = receive_confirmed_info_it->second;
276  			receive_confirmed_info.confirmed_height = receive_details->height;
277  			receive_confirmed_info.iterated_frontier = receive_details->hash;
278  		}
279  		else
280  		{
281  			accounts_confirmed_info.emplace (std::piecewise_construct, std::forward_as_tuple (receive_details->account), std::forward_as_tuple (receive_details->height, receive_details->hash));
282  			++accounts_confirmed_info_size;
283  		}
284  		if (receive_details->next.is_initialized ())
285  		{
286  			preparation_data_a.next_in_receive_chain = top_and_next_hash{ receive_details->top_level, receive_details->next, receive_details->height + 1 };
287  		}
288  		else
289  		{
290  			preparation_data_a.checkpoints.erase (std::remove (preparation_data_a.checkpoints.begin (), preparation_data_a.checkpoints.end (), receive_details->hash), preparation_data_a.checkpoints.end ());
291  		}
292  		pending_writes.emplace_back (receive_details->account, receive_details->bottom_height, receive_details->bottom_most, receive_details->height, receive_details->hash);
293  		++pending_writes_size;
294  	}
295  }
296  void nano::confirmation_height_bounded::cement_blocks (nano::write_guard & scoped_write_guard_a)
297  {
298  	std::vector<std::shared_ptr<nano::block>> cemented_blocks;
299  	auto const maximum_batch_write_time = 250; 
300  	auto const maximum_batch_write_time_increase_cutoff = maximum_batch_write_time - (maximum_batch_write_time / 5);
301  	auto const amount_to_change = batch_write_size / 10; 
302  	auto const minimum_batch_write_size = 16384u;
303  	nano::timer<> cemented_batch_timer;
304  	auto error = false;
305  	{
306  		auto transaction (ledger.store.tx_begin_write ({}, { nano::tables::confirmation_height }));
307  		cemented_batch_timer.start ();
308  		while (!error && !pending_writes.empty ())
309  		{
310  			auto const & pending = pending_writes.front ();
311  			auto const & account = pending.account;
312  			auto write_confirmation_height = [&account, &ledger = ledger, &transaction] (uint64_t num_blocks_cemented, uint64_t confirmation_height, nano::block_hash const & confirmed_frontier) {
313  #ifndef NDEBUG
314  				nano::confirmation_height_info confirmation_height_info;
315  				ledger.store.confirmation_height.get (transaction, account, confirmation_height_info);
316  				auto block (ledger.store.block.get (transaction, confirmed_frontier));
317  				debug_assert (block != nullptr);
318  				debug_assert (block->sideband ().height == confirmation_height_info.height + num_blocks_cemented);
319  #endif
320  				ledger.store.confirmation_height.put (transaction, account, nano::confirmation_height_info{ confirmation_height, confirmed_frontier });
321  				ledger.cache.cemented_count += num_blocks_cemented;
322  				ledger.stats.add (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed, nano::stat::dir::in, num_blocks_cemented);
323  				ledger.stats.add (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed_bounded, nano::stat::dir::in, num_blocks_cemented);
324  			};
325  			nano::confirmation_height_info confirmation_height_info;
326  			ledger.store.confirmation_height.get (transaction, pending.account, confirmation_height_info);
327  			if (pending.top_height > confirmation_height_info.height)
328  			{
329  				nano::block_hash new_cemented_frontier;
330  				uint64_t num_blocks_confirmed = 0;
331  				uint64_t start_height = 0;
332  				if (pending.bottom_height > confirmation_height_info.height)
333  				{
334  					new_cemented_frontier = pending.bottom_hash;
335  					debug_assert (pending.bottom_height == confirmation_height_info.height + 1);
336  					num_blocks_confirmed = pending.top_height - pending.bottom_height + 1;
337  					start_height = pending.bottom_height;
338  				}
339  				else
340  				{
341  					auto block = ledger.store.block.get (transaction, confirmation_height_info.frontier);
342  					new_cemented_frontier = block->sideband ().successor;
343  					num_blocks_confirmed = pending.top_height - confirmation_height_info.height;
344  					start_height = confirmation_height_info.height + 1;
345  				}
346  				auto total_blocks_cemented = 0;
347  				auto block = ledger.store.block.get (transaction, new_cemented_frontier);
348  				for (auto num_blocks_iterated = 0; num_blocks_confirmed - num_blocks_iterated != 0; ++num_blocks_iterated)
349  				{
350  					if (!block)
351  					{
352  						auto error_str = (boost::format ("Failed to write confirmation height for block %1% (bounded processor)") % new_cemented_frontier.to_string ()).str ();
353  						logger.always_log (error_str);
354  						std::cerr << error_str << std::endl;
355  						cemented_blocks.erase (cemented_blocks.end () - num_blocks_iterated, cemented_blocks.end ());
356  						error = true;
357  						break;
358  					}
359  					auto last_iteration = (num_blocks_confirmed - num_blocks_iterated) == 1;
360  					cemented_blocks.emplace_back (block);
361  					if (cemented_blocks.size () > batch_write_size + (batch_write_size / 10))
362  					{
363  						auto time_spent_cementing = cemented_batch_timer.since_start ().count ();
364  						auto num_blocks_cemented = num_blocks_iterated - total_blocks_cemented + 1;
365  						total_blocks_cemented += num_blocks_cemented;
366  						write_confirmation_height (num_blocks_cemented, start_height + total_blocks_cemented - 1, new_cemented_frontier);
367  						transaction.commit ();
368  						if (logging.timing_logging ())
369  						{
370  							logger.always_log (boost::str (boost::format ("Cemented %1% blocks in %2% %3% (bounded processor)") % cemented_blocks.size () % time_spent_cementing % cemented_batch_timer.unit ()));
371  						}
<span onclick='openModal()' class='match'>372  						if (time_spent_cementing > maximum_batch_write_time)
373  						{
374  							batch_write_size = std::max<uint64_t> (minimum_batch_write_size, batch_write_size - amount_to_change);
375  						}
376  						else if (time_spent_cementing < maximum_batch_write_time_increase_cutoff)
377  						{
378  							batch_write_size += amount_to_change;
379  						}
</span>380  						scoped_write_guard_a.release ();
381  						notify_observers_callback (cemented_blocks);
382  						cemented_blocks.clear ();
383  						if (!(last_iteration && pending_writes.size () == 1))
384  						{
385  							scoped_write_guard_a = write_database_queue.wait (nano::writer::confirmation_height);
386  							transaction.renew ();
387  						}
388  						cemented_batch_timer.restart ();
389  					}
390  					if (!last_iteration)
391  					{
392  						new_cemented_frontier = block->sideband ().successor;
393  						block = ledger.store.block.get (transaction, new_cemented_frontier);
394  					}
395  					else
396  					{
397  						debug_assert (new_cemented_frontier == pending.top_hash);
398  					}
399  				}
400  				if (error)
401  				{
402  					break;
403  				}
404  				auto num_blocks_cemented = num_blocks_confirmed - total_blocks_cemented;
405  				if (num_blocks_cemented > 0)
406  				{
407  					write_confirmation_height (num_blocks_cemented, pending.top_height, new_cemented_frontier);
408  				}
409  			}
410  			auto it = accounts_confirmed_info.find (pending.account);
411  			if (it != accounts_confirmed_info.cend () && it->second.confirmed_height == pending.top_height)
412  			{
413  				accounts_confirmed_info.erase (pending.account);
414  				--accounts_confirmed_info_size;
415  			}
416  			pending_writes.pop_front ();
417  			--pending_writes_size;
418  		}
419  	}
420  	auto time_spent_cementing = cemented_batch_timer.since_start ().count ();
421  	if (logging.timing_logging () && time_spent_cementing > 50)
422  	{
423  		logger.always_log (boost::str (boost::format ("Cemented %1% blocks in %2% %3% (bounded processor)") % cemented_blocks.size () % time_spent_cementing % cemented_batch_timer.unit ()));
424  	}
425  	if (scoped_write_guard_a.is_owned () && !cemented_blocks.empty ())
426  	{
427  		scoped_write_guard_a.release ();
428  		notify_observers_callback (cemented_blocks);
429  	}
430  	release_assert (!error);
431  	if (time_spent_cementing > maximum_batch_write_time)
432  	{
433  		batch_write_size = std::max<uint64_t> (minimum_batch_write_size, batch_write_size - amount_to_change);
434  	}
435  	debug_assert (pending_writes.empty ());
436  	debug_assert (pending_writes_size == 0);
437  	timer.restart ();
438  }
439  bool nano::confirmation_height_bounded::pending_empty () const
440  {
441  	return pending_writes.empty ();
442  }
443  void nano::confirmation_height_bounded::clear_process_vars ()
444  {
445  	accounts_confirmed_info.clear ();
446  	accounts_confirmed_info_size = 0;
447  }
448  nano::confirmation_height_bounded::receive_chain_details::receive_chain_details (nano::account const & account_a, uint64_t height_a, nano::block_hash const & hash_a, nano::block_hash const & top_level_a, boost::optional<nano::block_hash> next_a, uint64_t bottom_height_a, nano::block_hash const & bottom_most_a) :
449  	account (account_a),
450  	height (height_a),
451  	hash (hash_a),
452  	top_level (top_level_a),
453  	next (next_a),
454  	bottom_height (bottom_height_a),
455  	bottom_most (bottom_most_a)
456  {
457  }
458  nano::confirmation_height_bounded::write_details::write_details (nano::account const & account_a, uint64_t bottom_height_a, nano::block_hash const & bottom_hash_a, uint64_t top_height_a, nano::block_hash const & top_hash_a) :
459  	account (account_a),
460  	bottom_height (bottom_height_a),
461  	bottom_hash (bottom_hash_a),
462  	top_height (top_height_a),
463  	top_hash (top_hash_a)
464  {
465  }
466  nano::confirmation_height_bounded::receive_source_pair::receive_source_pair (confirmation_height_bounded::receive_chain_details const & receive_details_a, const block_hash & source_a) :
467  	receive_details (receive_details_a),
468  	source_hash (source_a)
469  {
470  }
471  nano::confirmation_height_bounded::confirmed_info::confirmed_info (uint64_t confirmed_height_a, nano::block_hash const & iterated_frontier_a) :
472  	confirmed_height (confirmed_height_a),
473  	iterated_frontier (iterated_frontier_a)
474  {
475  }
476  std::unique_ptr<nano::container_info_component> nano::collect_container_info (confirmation_height_bounded & confirmation_height_bounded, std::string const & name_a)
477  {
478  	auto composite = std::make_unique<container_info_composite> (name_a);
479  	composite->add_component (std::make_unique<container_info_leaf> (container_info{ "pending_writes", confirmation_height_bounded.pending_writes_size, sizeof (decltype (confirmation_height_bounded.pending_writes)::value_type) }));
480  	composite->add_component (std::make_unique<container_info_leaf> (container_info{ "accounts_confirmed_info", confirmation_height_bounded.accounts_confirmed_info_size, sizeof (decltype (confirmation_height_bounded.accounts_confirmed_info)::value_type) }));
481  	return composite;
482  }
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-fileBrowser.cpp</h3>
            <pre><code>1  #include "fileBrowser.h"
2  #include "resource.h"
3  #include "tinyxml.h"
4  #include "localization.h"
5  #include "Parameters.h"
6  #include "RunDlg.h"
7  #include "ReadDirectoryChanges.h"
8  #include "menuCmdID.h"
9  #define INDEX_OPEN_ROOT      0
10  #define INDEX_CLOSE_ROOT     1
11  #define INDEX_OPEN_NODE	     2
12  #define INDEX_CLOSE_NODE     3
13  #define INDEX_LEAF           4
14  #define GET_X_LPARAM(lp) static_cast<short>(LOWORD(lp))
15  #define GET_Y_LPARAM(lp) static_cast<short>(HIWORD(lp))
16  #define FB_ADDFILE (WM_USER + 1024)
17  #define FB_RMFILE  (WM_USER + 1025)
18  #define FB_RNFILE  (WM_USER + 1026)
19  #define FB_CMD_AIMFILE 1
20  #define FB_CMD_FOLDALL 2
21  #define FB_CMD_EXPANDALL 3
22  FileBrowser::~FileBrowser()
23  {
24  	for (const auto folder : _folderUpdaters)
25  	{
26  		folder->stopWatcher();
27  		delete folder;
28  	}
29  	for (const auto cd : sortingDataArray)
30  	{
31  		delete cd;
32  	}
33  }
34  vector<generic_string> split(const generic_string & string2split, TCHAR sep)
35  {
36  	vector<generic_string> splitedStrings;
37  	size_t len = string2split.length();
38  	size_t beginPos = 0;
39  	for (size_t i = 0; i < len + 1; ++i)
40  	{
41  		if (string2split[i] == sep || string2split[i] == '\0')
42  		{
43  			splitedStrings.push_back(string2split.substr(beginPos, i - beginPos));
44  			beginPos = i + 1;
45  		}
46  	}
47  	return splitedStrings;
48  }
49  bool isRelatedRootFolder(const generic_string & relatedRoot, const generic_string & subFolder)
50  {
51  	if (relatedRoot.empty())
52  		return false;
53  	if (subFolder.empty())
54  		return false;
55  	size_t pos = subFolder.find(relatedRoot);
56  	if (pos != 0) 
57  		return false;
58  	vector<generic_string> relatedRootArray = split(relatedRoot, '\\');
59  	vector<generic_string> subFolderArray = split(subFolder, '\\');
60  	size_t index2Compare = relatedRootArray.size() - 1;
61  	return relatedRootArray[index2Compare] == subFolderArray[index2Compare];
62  }
63  intptr_t CALLBACK FileBrowser::run_dlgProc(UINT message, WPARAM wParam, LPARAM lParam)
64  {
65  	switch (message)
66  	{
67  		case WM_INITDIALOG :
68  		{
69  			NppParameters& nppParam = NppParameters::getInstance();
70  			int style = WS_CHILD | WS_VISIBLE | CCS_ADJUSTABLE | TBSTYLE_AUTOSIZE | TBSTYLE_FLAT | TBSTYLE_LIST | TBSTYLE_TRANSPARENT | BTNS_AUTOSIZE | BTNS_SEP | TBSTYLE_TOOLTIPS | TBSTYLE_CUSTOMERASE;
71  			_hToolbarMenu = CreateWindowEx(WS_EX_LAYOUTRTL, TOOLBARCLASSNAME, NULL, style, 0, 0, 0, 0, _hSelf, nullptr, _hInst, NULL);
72  			int iconSizeDyn = nppParam._dpiManager.scaleX(16);
73  			::SendMessage(_hToolbarMenu, TB_SETBITMAPSIZE, 0, MAKELPARAM(iconSizeDyn, iconSizeDyn));
74  			TBADDBITMAP addbmp = { 0, 0 };
75  			const int nbIcons = 3;
76  			int iconIDs[nbIcons] = { IDI_FB_SELECTCURRENTFILE, IDI_FB_FOLDALL, IDI_FB_EXPANDALL};
77  			int iconDarkModeIDs[nbIcons] = { IDI_FB_SELECTCURRENTFILE_DM, IDI_FB_FOLDALL_DM, IDI_FB_EXPANDALL_DM};
78  			for (size_t i = 0; i < nbIcons; ++i)
79  			{
80  				int icoID = NppDarkMode::isEnabled() ? iconDarkModeIDs[i] : iconIDs[i];
81  				HBITMAP hBmp = static_cast<HBITMAP>(::LoadImage(_hInst, MAKEINTRESOURCE(icoID), IMAGE_BITMAP, iconSizeDyn, iconSizeDyn, LR_LOADMAP3DCOLORS | LR_LOADTRANSPARENT));
82  				addbmp.nID = reinterpret_cast<UINT_PTR>(hBmp);
83  				::SendMessage(_hToolbarMenu, TB_ADDBITMAP, 1, reinterpret_cast<LPARAM>(&addbmp));
84  			}
85  			TBBUTTON tbButtons[nbIcons];
86  			tbButtons[0].idCommand = FB_CMD_AIMFILE;
87  			tbButtons[0].iBitmap = 0;
88  			tbButtons[0].fsState = TBSTATE_ENABLED;
89  			tbButtons[0].fsStyle = BTNS_BUTTON | BTNS_AUTOSIZE;
90  			tbButtons[0].iString = reinterpret_cast<intptr_t>(TEXT(""));
91  			tbButtons[1].idCommand = FB_CMD_FOLDALL;
92  			tbButtons[1].iBitmap = 1;
93  			tbButtons[1].fsState = TBSTATE_ENABLED;
94  			tbButtons[1].fsStyle = BTNS_BUTTON | BTNS_AUTOSIZE;
95  			tbButtons[1].iString = reinterpret_cast<intptr_t>(TEXT(""));
96  			tbButtons[2].idCommand = FB_CMD_EXPANDALL;
97  			tbButtons[2].iBitmap = 2;
98  			tbButtons[2].fsState = TBSTATE_ENABLED;
99  			tbButtons[2].fsStyle = BTNS_BUTTON | BTNS_AUTOSIZE;
100  			tbButtons[2].iString = reinterpret_cast<intptr_t>(TEXT(""));
101  			NativeLangSpeaker *pNativeSpeaker = nppParam.getNativeLangSpeaker();
102  			_expandAllFolders = pNativeSpeaker->getAttrNameStr(_expandAllFolders.c_str(), FOLDERASWORKSPACE_NODE, "ExpandAllFoldersTip");
103  			_collapseAllFolders = pNativeSpeaker->getAttrNameStr(_collapseAllFolders.c_str(), FOLDERASWORKSPACE_NODE, "CollapseAllFoldersTip");
104  			_locateCurrentFile = pNativeSpeaker->getAttrNameStr(_locateCurrentFile.c_str(), FOLDERASWORKSPACE_NODE, "LocateCurrentFileTip");
105  			::SendMessage(_hToolbarMenu, TB_BUTTONSTRUCTSIZE, sizeof(TBBUTTON), 0);
106  			::SendMessage(_hToolbarMenu, TB_SETBUTTONSIZE, 0, MAKELONG(nppParam._dpiManager.scaleX(20), nppParam._dpiManager.scaleY(20)));
107  			::SendMessage(_hToolbarMenu, TB_SETPADDING, 0, MAKELONG(nppParam._dpiManager.scaleX(10), 0));
108  			::SendMessage(_hToolbarMenu, TB_ADDBUTTONS, sizeof(tbButtons) / sizeof(TBBUTTON), reinterpret_cast<LPARAM>(&tbButtons));
109  			::SendMessage(_hToolbarMenu, TB_AUTOSIZE, 0, 0);
110  			::SendMessage(_hToolbarMenu, TB_GETIMAGELIST, 0, 0);
111  			ShowWindow(_hToolbarMenu, SW_SHOW);
112  			FileBrowser::initPopupMenus();
113  			_treeView.init(_hInst, _hSelf, ID_FILEBROWSERTREEVIEW);
114  			_treeView.setImageList(CX_BITMAP, CY_BITMAP, 5, IDI_FB_ROOTOPEN, IDI_FB_ROOTCLOSE, IDI_PROJECT_FOLDEROPEN, IDI_PROJECT_FOLDERCLOSE, IDI_PROJECT_FILE);
115  			_treeView.addCanNotDropInList(INDEX_OPEN_ROOT);
116  			_treeView.addCanNotDropInList(INDEX_CLOSE_ROOT);
117  			_treeView.addCanNotDropInList(INDEX_OPEN_NODE);
118  			_treeView.addCanNotDropInList(INDEX_CLOSE_NODE);
119  			_treeView.addCanNotDropInList(INDEX_LEAF);
120  			_treeView.addCanNotDragOutList(INDEX_OPEN_ROOT);
121  			_treeView.addCanNotDragOutList(INDEX_CLOSE_ROOT);
122  			_treeView.addCanNotDragOutList(INDEX_OPEN_NODE);
123  			_treeView.addCanNotDragOutList(INDEX_CLOSE_NODE);
124  			_treeView.addCanNotDragOutList(INDEX_LEAF);
125  			_treeView.makeLabelEditable(false);
126  			_treeView.display();
127  			NppDarkMode::autoSubclassAndThemeChildControls(_hSelf);
128  			NppDarkMode::autoSubclassAndThemeWindowNotify(_hSelf);
129  			return TRUE;
130  		}
131  		case NPPM_INTERNAL_REFRESHDARKMODE:
132  		{
133  			if (static_cast<BOOL>(lParam) != TRUE)
134  			{
135  				NppDarkMode::autoThemeChildControls(_hSelf);
136  			}
137  			NppDarkMode::setTreeViewStyle(_treeView.getHSelf());
138  			return TRUE;
139  		}
140  		case WM_MOUSEMOVE:
141  			if (_treeView.isDragging())
142  				_treeView.dragItem(_hSelf, LOWORD(lParam), HIWORD(lParam));
143  			break;
144  		case WM_LBUTTONUP:
145  			if (_treeView.isDragging())
146  				if (_treeView.dropItem())
147  				{
148  				}
149  			break;
150  		case WM_NOTIFY:
151  		{
152  			notified((LPNMHDR)lParam);
153  		}
154  		return TRUE;
155  		case WM_SIZE:
156  		{
157  			int width = LOWORD(lParam);
158  			int height = HIWORD(lParam);
159  			int extraValue = NppParameters::getInstance()._dpiManager.scaleX(4);
160  			RECT toolbarMenuRect;
161  			::GetClientRect(_hToolbarMenu, &toolbarMenuRect);
162  			::MoveWindow(_hToolbarMenu, 0, 0, width, toolbarMenuRect.bottom, TRUE);
163  			HWND hwnd = _treeView.getHSelf();
164  			if (hwnd)
165  				::MoveWindow(hwnd, 0, toolbarMenuRect.bottom + extraValue, width, height - toolbarMenuRect.bottom - extraValue, TRUE);
166  			break;
167  		}
168  		case WM_CONTEXTMENU:
169  			if (!_treeView.isDragging())
170  				showContextMenu(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));
171  		return TRUE;
172  		case WM_COMMAND:
173  		{
174  			switch (LOWORD(wParam))
175  			{
176  				case FB_CMD_AIMFILE:
177  				{
178  					selectCurrentEditingFile();
179  					break;
180  				}
181  				case FB_CMD_FOLDALL:
182  				{
183  					_treeView.foldAll();
184  					break;
185  				}
186  				case FB_CMD_EXPANDALL:
187  				{
188  					_treeView.expandAll();
189  					break;
190  				}
191  				default:
192  					popupMenuCmd(LOWORD(wParam));
193  			}
194  			break;
195  		}
196  		case WM_DESTROY:
197  		{
198  			::DestroyWindow(_hToolbarMenu);
199  			_treeView.destroy();
200  			destroyMenus();
201  			break;
202  		}
203  		case FB_ADDFILE:
204  		{
205  			std::vector<FilesToChange> groupedFiles = getFilesFromParam(lParam);
206  			for (auto & group : groupedFiles) 
207  			{
208  				addToTree(group, nullptr);
209  			}
210  			break;
211  		}
212  		case FB_RMFILE:
213  		{
214  			std::vector<FilesToChange> groupedFiles = getFilesFromParam(lParam);
215  			for (auto & group : groupedFiles) 
216  			{
217  				deleteFromTree(group);
218  			}
219  			break;
220  		}
221  		case FB_RNFILE:
222  		{
223  			const std::vector<generic_string> file2Change = *(std::vector<generic_string> *)lParam;
224  			generic_string separator = TEXT("\\\\");
225  			size_t sepPos = file2Change[0].find(separator);
226  			if (sepPos == generic_string::npos)
227  				return false;
228  			generic_string pathSuffix = file2Change[0].substr(sepPos + separator.length(), file2Change[0].length() - 1);
229  			vector<generic_string> linarPathArray = split(pathSuffix, '\\');
230  			generic_string rootPath = file2Change[0].substr(0, sepPos);
231  			size_t sepPos2 = file2Change[1].find(separator);
232  			if (sepPos2 == generic_string::npos)
233  				return false;
234  			generic_string pathSuffix2 = file2Change[1].substr(sepPos2 + separator.length(), file2Change[1].length() - 1);
235  			vector<generic_string> linarPathArray2 = split(pathSuffix2, '\\');
236  			bool isRenamed = renameInTree(rootPath, nullptr, linarPathArray, linarPathArray2[linarPathArray2.size() - 1]);
237  			if (!isRenamed)
238  			{
239  			}
240  			break;
241  		}
242  		default :
243  			return DockingDlgInterface::run_dlgProc(message, wParam, lParam);
244  	}
245  	return DockingDlgInterface::run_dlgProc(message, wParam, lParam);
246  }
247  void FileBrowser::initPopupMenus()
248  {
249  	NativeLangSpeaker* pNativeSpeaker = NppParameters::getInstance().getNativeLangSpeaker();
250  	generic_string addRoot = pNativeSpeaker->getDlgLangMenuStr(FOLDERASWORKSPACE_NODE, nullptr, IDM_FILEBROWSER_ADDROOT, FB_ADDROOT);
251  	generic_string removeAllRoot = pNativeSpeaker->getDlgLangMenuStr(FOLDERASWORKSPACE_NODE, nullptr, IDM_FILEBROWSER_REMOVEALLROOTS, FB_REMOVEALLROOTS);
252  	generic_string removeRootFolder = pNativeSpeaker->getDlgLangMenuStr(FOLDERASWORKSPACE_NODE, nullptr, IDM_FILEBROWSER_REMOVEROOTFOLDER, FB_REMOVEROOTFOLDER);
253  	generic_string copyPath = pNativeSpeaker->getDlgLangMenuStr(FOLDERASWORKSPACE_NODE, nullptr, IDM_FILEBROWSER_COPYPATH, FB_COPYPATH);
254  	generic_string copyFileName = pNativeSpeaker->getDlgLangMenuStr(FOLDERASWORKSPACE_NODE, nullptr, IDM_FILEBROWSER_COPYFILENAME, FB_COPYFILENAME);
255  	generic_string findInFile = pNativeSpeaker->getDlgLangMenuStr(FOLDERASWORKSPACE_NODE, nullptr, IDM_FILEBROWSER_FINDINFILES, FB_FINDINFILES);
256  	generic_string explorerHere = pNativeSpeaker->getDlgLangMenuStr(FOLDERASWORKSPACE_NODE, nullptr, IDM_FILEBROWSER_EXPLORERHERE, FB_EXPLORERHERE);
257  	generic_string cmdHere = pNativeSpeaker->getDlgLangMenuStr(FOLDERASWORKSPACE_NODE, nullptr, IDM_FILEBROWSER_CMDHERE, FB_CMDHERE);
258  	generic_string openInNpp = pNativeSpeaker->getDlgLangMenuStr(FOLDERASWORKSPACE_NODE, nullptr, IDM_FILEBROWSER_OPENINNPP, FB_OPENINNPP);
259  	generic_string shellExecute = pNativeSpeaker->getDlgLangMenuStr(FOLDERASWORKSPACE_NODE, nullptr, IDM_FILEBROWSER_SHELLEXECUTE, FB_SHELLEXECUTE);
260  	_hGlobalMenu = ::CreatePopupMenu();
261  	::InsertMenu(_hGlobalMenu, 0, MF_BYCOMMAND, IDM_FILEBROWSER_ADDROOT, addRoot.c_str());
262  	::InsertMenu(_hGlobalMenu, 0, MF_BYCOMMAND, IDM_FILEBROWSER_REMOVEALLROOTS, removeAllRoot.c_str());
263  	_hRootMenu = ::CreatePopupMenu();
264  	::InsertMenu(_hRootMenu, 0, MF_BYCOMMAND, IDM_FILEBROWSER_REMOVEROOTFOLDER, removeRootFolder.c_str());
265  	::InsertMenu(_hRootMenu, 0, MF_BYCOMMAND, static_cast<UINT>(-1), 0);
266  	::InsertMenu(_hRootMenu, 0, MF_BYCOMMAND, IDM_FILEBROWSER_COPYPATH, copyPath.c_str());
267  	::InsertMenu(_hRootMenu, 0, MF_BYCOMMAND, IDM_FILEBROWSER_FINDINFILES, findInFile.c_str());
268  	::InsertMenu(_hRootMenu, 0, MF_BYCOMMAND, static_cast<UINT>(-1), 0);
269  	::InsertMenu(_hRootMenu, 0, MF_BYCOMMAND, IDM_FILEBROWSER_EXPLORERHERE, explorerHere.c_str());
270  	::InsertMenu(_hRootMenu, 0, MF_BYCOMMAND, IDM_FILEBROWSER_CMDHERE, cmdHere.c_str());
271  	_hFolderMenu = ::CreatePopupMenu();
272  	::InsertMenu(_hFolderMenu, 0, MF_BYCOMMAND, IDM_FILEBROWSER_COPYPATH, copyPath.c_str());
273  	::InsertMenu(_hFolderMenu, 0, MF_BYCOMMAND, IDM_FILEBROWSER_FINDINFILES, findInFile.c_str());
274  	::InsertMenu(_hFolderMenu, 0, MF_BYCOMMAND, static_cast<UINT>(-1), 0);
275  	::InsertMenu(_hFolderMenu, 0, MF_BYCOMMAND, IDM_FILEBROWSER_EXPLORERHERE, explorerHere.c_str());
276  	::InsertMenu(_hFolderMenu, 0, MF_BYCOMMAND, IDM_FILEBROWSER_CMDHERE, cmdHere.c_str());
277  	_hFileMenu = ::CreatePopupMenu();
278  	::InsertMenu(_hFileMenu, 0, MF_BYCOMMAND, IDM_FILEBROWSER_OPENINNPP, openInNpp.c_str());
279  	::InsertMenu(_hFileMenu, 0, MF_BYCOMMAND, static_cast<UINT>(-1), 0);
280  	::InsertMenu(_hFileMenu, 0, MF_BYCOMMAND, IDM_FILEBROWSER_COPYPATH, copyPath.c_str());
281  	::InsertMenu(_hFileMenu, 0, MF_BYCOMMAND, IDM_FILEBROWSER_COPYFILENAME, copyFileName.c_str());
282  	::InsertMenu(_hFileMenu, 0, MF_BYCOMMAND, IDM_FILEBROWSER_SHELLEXECUTE, shellExecute.c_str());
283  	::InsertMenu(_hFileMenu, 0, MF_BYCOMMAND, static_cast<UINT>(-1), 0);
284  	::InsertMenu(_hFileMenu, 0, MF_BYCOMMAND, IDM_FILEBROWSER_EXPLORERHERE, explorerHere.c_str());
285  	::InsertMenu(_hFileMenu, 0, MF_BYCOMMAND, IDM_FILEBROWSER_CMDHERE, cmdHere.c_str());
286  }
287  bool FileBrowser::selectItemFromPath(const generic_string& itemPath) const
288  {
289  	if (itemPath.empty())
290  		return false;
291  	size_t itemPathLen = itemPath.size();
292  	for (const auto f : _folderUpdaters)
293  	{
294  		if (isRelatedRootFolder(f->_rootFolder._rootPath, itemPath))
295  		{
296  			generic_string rootPath = f->_rootFolder._rootPath;
297  			size_t rootPathLen = rootPath.size();
298  			if (rootPathLen > itemPathLen) 
299  				return false;
300  			vector<generic_string> linarPathArray;
301  			if (rootPathLen == itemPathLen)
302  			{
303  			}
304  			else
305  			{
306  				generic_string pathSuffix = itemPath.substr(rootPathLen + 1, itemPathLen - rootPathLen);
307  				linarPathArray = split(pathSuffix, '\\');
308  			}
309  			HTREEITEM foundItem = findInTree(rootPath, nullptr, linarPathArray);
310  			if (foundItem)
311  			{
312  				_treeView.selectItem(foundItem);
313  				_treeView.getFocus();
314  				return true;
315  			}
316  		}
317  	}
318  	return false;
319  }
320  bool FileBrowser::selectCurrentEditingFile() const
321  {
322  	TCHAR currentDocPath[MAX_PATH] = { '\0' };
323  	::SendMessage(_hParent, NPPM_GETFULLCURRENTPATH, MAX_PATH, reinterpret_cast<LPARAM>(currentDocPath));
324  	generic_string currentDocPathStr = currentDocPath;
325  	return selectItemFromPath(currentDocPathStr);
326  }
327  void FileBrowser::destroyMenus() 
328  {
329  	::DestroyMenu(_hGlobalMenu);
330  	::DestroyMenu(_hRootMenu);
331  	::DestroyMenu(_hFolderMenu);
332  	::DestroyMenu(_hFileMenu);
333  }
334  generic_string FileBrowser::getNodePath(HTREEITEM node) const
335  {
336  	if (!node) return TEXT("");
337  	vector<generic_string> fullPathArray;
338  	generic_string fullPath;
339  	HTREEITEM parent = node;
340  	for (; parent != nullptr;)
341  	{
342  		generic_string folderName = _treeView.getItemDisplayName(parent);
343  		HTREEITEM temp = _treeView.getParent(parent);
344  		if (temp == nullptr)
345  		{
346  			SortingData4lParam* customData = reinterpret_cast<SortingData4lParam*>(_treeView.getItemParam(parent));
347  			folderName = customData->_rootPath;
348  		}
349  		parent = temp;
350  		fullPathArray.push_back(folderName);
351  	}
352  	for (int i = int(fullPathArray.size()) - 1; i >= 0; --i)
353  	{
354  		fullPath += fullPathArray[i];
355  		if (i != 0)
356  			fullPath += TEXT("\\");
357  	}
358  	return fullPath;
359  }
360  generic_string FileBrowser::getNodeName(HTREEITEM node) const
361  {
362  	return node ? _treeView.getItemDisplayName(node) : TEXT("");
363  }
364  void FileBrowser::openSelectFile()
365  {
366  	HTREEITEM selectedNode = _treeView.getSelection();
367  	if (!selectedNode) return;
368  	_selectedNodeFullPath = getNodePath(selectedNode);
369  	if (!::PathFileExists(_selectedNodeFullPath.c_str()))
370  		return;
371  	if (::PathIsDirectory(_selectedNodeFullPath.c_str()))
372  		return;
373  	::PostMessage(_hParent, NPPM_DOOPEN, 0, reinterpret_cast<LPARAM>(_selectedNodeFullPath.c_str()));
374  }
375  void FileBrowser::notified(LPNMHDR notification)
376  {			
377  	if (notification->code == DMN_CLOSE)
378  	{
379  		::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_FILEBROWSER, 0);
380  	}
381  	else if (notification->code == TTN_GETDISPINFO)
382  	{
383  		LPTOOLTIPTEXT lpttt = (LPTOOLTIPTEXT)notification;
384  		lpttt->hinst = NULL;
385  		if (notification->idFrom == FB_CMD_AIMFILE)
386  		{
387  			wcscpy_s(lpttt->szText, _locateCurrentFile.c_str());
388  		}
389  		else if (notification->idFrom == FB_CMD_FOLDALL)
390  		{
391  			wcscpy_s(lpttt->szText, _collapseAllFolders.c_str());
392  		}
393  		else if (notification->idFrom == FB_CMD_EXPANDALL)
394  		{
395  			wcscpy_s(lpttt->szText, _expandAllFolders.c_str());
396  		}
397  	}
398  	else if (notification->hwndFrom == _treeView.getHSelf())
399  	{
400  		TCHAR textBuffer[MAX_PATH] = { '\0' };
401  		TVITEM tvItem;
402  		tvItem.mask = TVIF_TEXT | TVIF_PARAM;
403  		tvItem.pszText = textBuffer;
404  		tvItem.cchTextMax = MAX_PATH;
405  		switch (notification->code)
406  		{
407  			case NM_DBLCLK:
408  			{
409  				openSelectFile();
410  			}
411  			break;
412  			case TVN_ENDLABELEDIT:
413  			{
414  				LPNMTVDISPINFO tvnotif = (LPNMTVDISPINFO)notification;
415  				if (!tvnotif->item.pszText)
416  					return;
417  				if (getNodeType(tvnotif->item.hItem) == browserNodeType_root)
418  					return;
419  				if (tvnotif->item.lParam) 
420  				{
421  					tvItem.hItem = _treeView.getSelection();
422  					::SendMessage(_treeView.getHSelf(), TVM_GETITEM, 0, reinterpret_cast<LPARAM>(&tvItem));
423  					size_t len = lstrlen(tvItem.pszText);
424  					SortingData4lParam* customData = reinterpret_cast<SortingData4lParam*>(tvnotif->item.lParam);
425  					generic_string *filePath = &(customData->_rootPath);
426  					size_t found = filePath->rfind(tvItem.pszText);
427  					if (found != generic_string::npos)
428  						filePath->replace(found, len, tvnotif->item.pszText);
429  					tvItem.mask = TVIF_IMAGE | TVIF_SELECTEDIMAGE;
430  					if (::PathFileExists(filePath->c_str()))
431  					{
432  						tvItem.iImage = INDEX_LEAF;
433  						tvItem.iSelectedImage = INDEX_LEAF;
434  					}
435  					else
436  					{
437  					}
438  					TreeView_SetItem(_treeView.getHSelf(), &tvItem);
439  				}
440  				::SendMessage(_treeView.getHSelf(), TVM_SETITEM, 0, reinterpret_cast<LPARAM>(&(tvnotif->item)));
441  			}
442  			break;
443  			case TVN_GETINFOTIP:
444  			{
445  				LPNMTVGETINFOTIP lpGetInfoTip = (LPNMTVGETINFOTIP)notification;
446  				static generic_string tipStr;
447  				BrowserNodeType nType = getNodeType(lpGetInfoTip->hItem);
<span onclick='openModal()' class='match'>448  				if (nType == browserNodeType_root)
449  				{
450  					tipStr = *((generic_string *)lpGetInfoTip->lParam);
451  				}
452  				else if (nType == browserNodeType_file)
453  				{
454  					tipStr = getNodePath(lpGetInfoTip->hItem);
455  				}
</span>456  				else
457  					return;
458  				lpGetInfoTip->pszText = (LPTSTR)tipStr.c_str();
459  				lpGetInfoTip->cchTextMax = static_cast<int>(tipStr.size());
460  			}
461  			break;
462  			case NM_RETURN:
463  				SetWindowLongPtr(_hSelf, DWLP_MSGRESULT, 1);
464  			break;
465  			case TVN_KEYDOWN:
466  			{
467  				LPNMTVKEYDOWN ptvkd = (LPNMTVKEYDOWN)notification;
468  				if (ptvkd->wVKey == VK_RETURN)
469  				{
470  					HTREEITEM hItem = _treeView.getSelection();
471  					BrowserNodeType nType = getNodeType(hItem);
472  					if (nType == browserNodeType_file)
473  						openSelectFile();
474  					else
475  						_treeView.toggleExpandCollapse(hItem);
476  				}
477  				else if (ptvkd->wVKey == VK_DELETE)
478  				{
479  					HTREEITEM hItem = _treeView.getSelection();
480  					BrowserNodeType nType = getNodeType(hItem);
481  					if (nType == browserNodeType_root)
482  						popupMenuCmd(IDM_FILEBROWSER_REMOVEROOTFOLDER);
483  				}
484  			}
485  			break;
486  			case TVN_ITEMEXPANDED:
487  			{
488  				LPNMTREEVIEW nmtv = (LPNMTREEVIEW)notification;
489  				tvItem.hItem = nmtv->itemNew.hItem;
490  				tvItem.mask = TVIF_IMAGE | TVIF_SELECTEDIMAGE;
491  				if (getNodeType(nmtv->itemNew.hItem) == browserNodeType_folder)
492  				{
493  					if (nmtv->action == TVE_COLLAPSE)
494  					{
495  						_treeView.setItemImage(nmtv->itemNew.hItem, INDEX_CLOSE_NODE, INDEX_CLOSE_NODE);
496  					}
497  					else if (nmtv->action == TVE_EXPAND)
498  					{
499  						_treeView.setItemImage(nmtv->itemNew.hItem, INDEX_OPEN_NODE, INDEX_OPEN_NODE);
500  					}
501  				}
502  				else if (getNodeType(nmtv->itemNew.hItem) == browserNodeType_root)
503  				{
504  					if (nmtv->action == TVE_COLLAPSE)
505  					{
506  						_treeView.setItemImage(nmtv->itemNew.hItem, INDEX_CLOSE_ROOT, INDEX_CLOSE_ROOT);
507  					}
508  					else if (nmtv->action == TVE_EXPAND)
509  					{
510  						_treeView.setItemImage(nmtv->itemNew.hItem, INDEX_OPEN_ROOT, INDEX_OPEN_ROOT);
511  					}
512  				}
513  			}
514  			break;
515  			case TVN_BEGINDRAG:
516  			{
517  				_treeView.beginDrag((LPNMTREEVIEW)notification);
518  			}
519  			break;
520  		}
521  	}
522  }
523  BrowserNodeType FileBrowser::getNodeType(HTREEITEM hItem)
524  {
525  	TVITEM tvItem;
526  	tvItem.hItem = hItem;
527  	tvItem.mask = TVIF_IMAGE | TVIF_PARAM;
528  	SendMessage(_treeView.getHSelf(), TVM_GETITEM, 0, reinterpret_cast<LPARAM>(&tvItem));
529  	if (tvItem.iImage == INDEX_LEAF)
530  	{
531  		return browserNodeType_file;
532  	}
533  	else if (tvItem.lParam && !reinterpret_cast<SortingData4lParam*>(tvItem.lParam)->_rootPath.empty())
534  	{
535  		return browserNodeType_root;
536  	}
537  	else
538  	{
539  		return browserNodeType_folder;
540  	}
541  }
542  void FileBrowser::showContextMenu(int x, int y)
543  {
544  	TVHITTESTINFO tvHitInfo{};
545  	tvHitInfo.pt.x = x;
546  	tvHitInfo.pt.y = y;
547  	tvHitInfo.flags = 0;
548  	ScreenToClient(_treeView.getHSelf(), &(tvHitInfo.pt));
549  	TreeView_HitTest(_treeView.getHSelf(), &tvHitInfo);
550  	if (tvHitInfo.hItem == nullptr)
551  	{
552  		TrackPopupMenu(_hGlobalMenu, 
553  			NppParameters::getInstance().getNativeLangSpeaker()->isRTL() ? TPM_RIGHTALIGN | TPM_LAYOUTRTL : TPM_LEFTALIGN,
554  			x, y, 0, _hSelf, NULL);
555  	}
556  	else
557  	{
558  		_treeView.selectItem(tvHitInfo.hItem);
559  		BrowserNodeType nodeType = getNodeType(tvHitInfo.hItem);
560  		HMENU hMenu = NULL;
561  		if (nodeType == browserNodeType_root)
562  			hMenu = _hRootMenu;
563  		else if (nodeType == browserNodeType_folder)
564  			hMenu = _hFolderMenu;
565  		else 
566  			hMenu = _hFileMenu;
567  		TrackPopupMenu(hMenu, 
568  			NppParameters::getInstance().getNativeLangSpeaker()->isRTL() ? TPM_RIGHTALIGN | TPM_LAYOUTRTL : TPM_LEFTALIGN,
569  			x, y, 0, _hSelf, NULL);
570  	}
571  }
572  void FileBrowser::popupMenuCmd(int cmdID)
573  {
574  	HTREEITEM selectedNode = _treeView.getSelection();
575  	switch (cmdID)
576  	{
577  		case IDM_FILEBROWSER_REMOVEROOTFOLDER:
578  		{
579  			if (!selectedNode) return;
580  			generic_string *rootPath = (generic_string *)_treeView.getItemParam(selectedNode);
581  			if (_treeView.getParent(selectedNode) != nullptr || rootPath == nullptr)
582  				return;
583  			size_t nbFolderUpdaters = _folderUpdaters.size();
584  			for (size_t i = 0; i < nbFolderUpdaters; ++i)
585  			{
586  				if (_folderUpdaters[i]->_rootFolder._rootPath == *rootPath)
587  				{
588  					_folderUpdaters[i]->stopWatcher();
589  					_folderUpdaters.erase(_folderUpdaters.begin() + i);
590  					_treeView.removeItem(selectedNode);
591  					break;
592  				}
593  			}
594  		}
595  		break;
596  		case IDM_FILEBROWSER_EXPLORERHERE:
597  		{
598  			if (!selectedNode) return;
599  			generic_string path = getNodePath(selectedNode);
600  			if (::PathFileExists(path.c_str()))
601  			{
602  				TCHAR cmdStr[1024] = {};
603  				if (getNodeType(selectedNode) == browserNodeType_file)
604  					wsprintf(cmdStr, TEXT("explorer /select,\"%s\""), path.c_str());
605  				else
606  					wsprintf(cmdStr, TEXT("explorer \"%s\""), path.c_str());
607  				Command cmd(cmdStr);
608  				cmd.run(nullptr);
609  			}
610  		}
611  		break;
612  		case IDM_FILEBROWSER_CMDHERE:
613  		{
614  			if (!selectedNode) return;
615  			if (getNodeType(selectedNode) == browserNodeType_file)
616  				selectedNode = _treeView.getParent(selectedNode);
617  			generic_string path = getNodePath(selectedNode);
618  			if (::PathFileExists(path.c_str()))
619  			{
620  				Command cmd(NppParameters::getInstance().getNppGUI()._commandLineInterpreter.c_str());
621  				cmd.run(nullptr, path.c_str());
622  			}
623  		}
624  		break;
625  		case IDM_FILEBROWSER_COPYPATH:
626  		{
627  			if (!selectedNode) return;
628  			generic_string path = getNodePath(selectedNode);
629  			str2Clipboard(path, _hParent);
630  		}
631  		break;
632  		case IDM_FILEBROWSER_COPYFILENAME:
633  		{
634  			if (!selectedNode) return;
635  			generic_string fileName = getNodeName(selectedNode);
636  			str2Clipboard(fileName, _hParent);
637  		}
638  		break;
639  		case IDM_FILEBROWSER_FINDINFILES:
640  		{
641  			if (!selectedNode) return;
642  			generic_string path = getNodePath(selectedNode);
643  			::SendMessage(_hParent, NPPM_LAUNCHFINDINFILESDLG, reinterpret_cast<WPARAM>(path.c_str()), 0);
644  		}
645  		break;
646  		case IDM_FILEBROWSER_OPENINNPP:
647  		{
648  			openSelectFile();
649  		}
650  		break;
651  		case IDM_FILEBROWSER_REMOVEALLROOTS:
652  		{
653  			for (int i = static_cast<int>(_folderUpdaters.size()) - 1; i >= 0; --i)
654  			{
655  				_folderUpdaters[i]->stopWatcher();
656  				HTREEITEM root =  getRootFromFullPath(_folderUpdaters[i]->_rootFolder._rootPath);
657  				if (root)
658  					_treeView.removeItem(root);
659  				_folderUpdaters.erase(_folderUpdaters.begin() + i);
660  			}
661  		}
662  		break;
663  		case IDM_FILEBROWSER_ADDROOT:
664  		{
665  			NativeLangSpeaker *pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
666  			generic_string openWorkspaceStr = pNativeSpeaker->getAttrNameStr(TEXT("Select a folder to add in Folder as Workspace panel"), FOLDERASWORKSPACE_NODE, "SelectFolderFromBrowserString");
667  			generic_string folderPath = folderBrowser(_hParent, openWorkspaceStr);
668  			if (!folderPath.empty())
669  			{
670  				addRootFolder(folderPath);
671  			}
672  		}
673  		break;
674  		case IDM_FILEBROWSER_SHELLEXECUTE:
675  		{
676  			if (!selectedNode) return;
677  			generic_string path = getNodePath(selectedNode);
678  			if (::PathFileExists(path.c_str()))
679  				::ShellExecute(NULL, TEXT("open"), path.c_str(), NULL, NULL, SW_SHOWNORMAL);
680  		}
681  		break;
682  	}
683  }
684  void FileBrowser::getDirectoryStructure(const TCHAR *dir, const std::vector<generic_string> & patterns, FolderInfo & directoryStructure, bool isRecursive, bool isInHiddenDir)
685  {
686  	if (directoryStructure._parent == nullptr) 
687  		directoryStructure.setRootPath(dir);
688  	generic_string dirFilter(dir);
689  	if (dirFilter[dirFilter.length() - 1] != '\\')
690  		dirFilter += TEXT("\\");
691  	dirFilter += TEXT("*.*");
692  	WIN32_FIND_DATA foundData;
693  	HANDLE hFile = ::FindFirstFile(dirFilter.c_str(), &foundData);
694  	if (hFile != INVALID_HANDLE_VALUE)
695  	{
696  		if (foundData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
697  		{
698  			if (!isInHiddenDir && (foundData.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN))
699  			{
700  			}
701  			else if (isRecursive)
702  			{
703  				if ((OrdinalIgnoreCaseCompareStrings(foundData.cFileName, TEXT(".")) != 0) && (OrdinalIgnoreCaseCompareStrings(foundData.cFileName, TEXT("..")) != 0))
704  				{
705  					generic_string pathDir(dir);
706  					if (pathDir[pathDir.length() - 1] != '\\')
707  						pathDir += TEXT("\\");
708  					pathDir += foundData.cFileName;
709  					pathDir += TEXT("\\");
710  					FolderInfo subDirectoryStructure(foundData.cFileName, &directoryStructure);
711  					getDirectoryStructure(pathDir.c_str(), patterns, subDirectoryStructure, isRecursive, isInHiddenDir);
712  					directoryStructure.addSubFolder(subDirectoryStructure);
713  				}
714  			}
715  		}
716  		else
717  		{
718  			if (matchInList(foundData.cFileName, patterns))
719  			{
720  				directoryStructure.addFile(foundData.cFileName);
721  			}
722  		}
723  	}
724  	while (::FindNextFile(hFile, &foundData))
725  	{
726  		if (foundData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
727  		{
728  			if (!isInHiddenDir && (foundData.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN))
729  			{
730  			}
731  			else if (isRecursive)
732  			{
733  				if ((OrdinalIgnoreCaseCompareStrings(foundData.cFileName, TEXT(".")) != 0) && (OrdinalIgnoreCaseCompareStrings(foundData.cFileName, TEXT("..")) != 0))
734  				{
735  					generic_string pathDir(dir);
736  					if (pathDir[pathDir.length() - 1] != '\\')
737  						pathDir += TEXT("\\");
738  					pathDir += foundData.cFileName;
739  					pathDir += TEXT("\\");
740  					FolderInfo subDirectoryStructure(foundData.cFileName, &directoryStructure);
741  					getDirectoryStructure(pathDir.c_str(), patterns, subDirectoryStructure, isRecursive, isInHiddenDir);
742  					directoryStructure.addSubFolder(subDirectoryStructure);
743  				}
744  			}
745  		}
746  		else
747  		{
748  			if (matchInList(foundData.cFileName, patterns))
749  			{
750  				directoryStructure.addFile(foundData.cFileName);
751  			}
752  		}
753  	}
754  	::FindClose(hFile);
755  }
756  void FileBrowser::addRootFolder(generic_string rootFolderPath)
757  {
758  	if (!::PathFileExists(rootFolderPath.c_str()))
759  		return;
760  	if (!::PathIsDirectory(rootFolderPath.c_str()))
761  		return;
762  	if (rootFolderPath[rootFolderPath.length() - 1] == '\\')
763  	{
764  		rootFolderPath = rootFolderPath.substr(0, rootFolderPath.length() - 1);
765  	}
766  	for (const auto f : _folderUpdaters)
767  	{
768  		if (f->_rootFolder._rootPath == rootFolderPath)
769  			return;
770  		else
771  		{
772  			if (isRelatedRootFolder(f->_rootFolder._rootPath, rootFolderPath))
773  			{
774  				generic_string rootPath = f->_rootFolder._rootPath;
775  				generic_string pathSuffix = rootFolderPath.substr(rootPath.size() + 1, rootFolderPath.size() - rootPath.size());
776  				vector<generic_string> linarPathArray = split(pathSuffix, '\\');
777  				HTREEITEM foundItem = findInTree(rootPath, nullptr, linarPathArray);
778  				if (foundItem)
779  					_treeView.selectItem(foundItem);
780  				return;
781  			}
782  			if (isRelatedRootFolder(rootFolderPath, f->_rootFolder._rootPath))
783  			{
784  				NppParameters::getInstance().getNativeLangSpeaker()->messageBox("FolderAsWorspaceSubfolderExists",
785  					_hParent,
786  					TEXT("A sub-folder of the folder you want to add exists.\rPlease remove its root from the panel before you add folder \"$STR_REPLACE$\"."),
787  					TEXT("Folder as Workspace adding folder problem"),
788  					MB_OK,
789  					0, 
790  					rootFolderPath.c_str());
791  				return;
792  			}
793  		}
794  	}
795  	std::vector<generic_string> patterns2Match;
796  	patterns2Match.push_back(TEXT("*.*"));
797  	TCHAR *label = ::PathFindFileName(rootFolderPath.c_str());
798  	TCHAR rootLabel[MAX_PATH] = {'\0'};
799  	wcscpy_s(rootLabel, label);
800  	size_t len = lstrlen(rootLabel);
801  	if (rootLabel[len - 1] == '\\')
802  		rootLabel[len - 1] = '\0';
803  	FolderInfo directoryStructure(rootLabel, nullptr);
804  	getDirectoryStructure(rootFolderPath.c_str(), patterns2Match, directoryStructure, true, false);
805  	HTREEITEM hRootItem = createFolderItemsFromDirStruct(nullptr, directoryStructure);
806  	_treeView.expand(hRootItem);
807  	_folderUpdaters.push_back(new FolderUpdater(directoryStructure, this));
808  	_folderUpdaters[_folderUpdaters.size() - 1]->startWatcher();
809  }
810  HTREEITEM FileBrowser::createFolderItemsFromDirStruct(HTREEITEM hParentItem, const FolderInfo & directoryStructure)
811  {
812  	HTREEITEM hFolderItem = nullptr;
813  	if (directoryStructure._parent == nullptr && hParentItem == nullptr)
814  	{
815  		TCHAR rootPath[MAX_PATH] = { '\0' };
816  		wcscpy_s(rootPath, directoryStructure._rootPath.c_str());
817  		size_t len = lstrlen(rootPath);
818  		if (rootPath[len - 1] == '\\')
819  			rootPath[len - 1] = '\0';
820  		SortingData4lParam* customData = new SortingData4lParam(rootPath, TEXT(""), true);
821  		sortingDataArray.push_back(customData);
822  		hFolderItem = _treeView.addItem(directoryStructure._name.c_str(), TVI_ROOT, INDEX_CLOSE_ROOT, reinterpret_cast<LPARAM>(customData));
823  	}
824  	else
825  	{
826  		SortingData4lParam* customData = new SortingData4lParam(TEXT(""), directoryStructure._name, true);
827  		sortingDataArray.push_back(customData);
828  		hFolderItem = _treeView.addItem(directoryStructure._name.c_str(), hParentItem, INDEX_CLOSE_NODE, reinterpret_cast<LPARAM>(customData));
829  	}
830  	for (const auto& folder : directoryStructure._subFolders)
831  	{
832  		createFolderItemsFromDirStruct(hFolderItem, folder);
833  	}
834  	for (const auto& file : directoryStructure._files)
835  	{
836  		SortingData4lParam* customData = new SortingData4lParam(TEXT(""), file._name, false);
837  		sortingDataArray.push_back(customData);
838  		_treeView.addItem(file._name.c_str(), hFolderItem, INDEX_LEAF, reinterpret_cast<LPARAM>(customData));
839  	}
840  	_treeView.fold(hParentItem);
841  	return hFolderItem;
842  }
843  HTREEITEM FileBrowser::getRootFromFullPath(const generic_string & rootPath) const
844  {
845  	HTREEITEM node = nullptr;
846  	for (HTREEITEM hItemNode = _treeView.getRoot();
847  		hItemNode != nullptr && node == nullptr;
848  		hItemNode = _treeView.getNextSibling(hItemNode))
849  	{
850  		TVITEM tvItem;
851  		tvItem.mask = TVIF_PARAM;
852  		tvItem.cchTextMax = MAX_PATH;
853  		tvItem.hItem = hItemNode;
854  		SendMessage(_treeView.getHSelf(), TVM_GETITEM, 0, reinterpret_cast<LPARAM>(&tvItem));
855  		if (tvItem.lParam != 0 && rootPath == reinterpret_cast<SortingData4lParam *>(tvItem.lParam)->_rootPath)
856  			node = hItemNode;
857  	}
858  	return node;
859  }
860  HTREEITEM FileBrowser::findChildNodeFromName(HTREEITEM parent, const generic_string& label) const
861  {
862  	for (HTREEITEM hItemNode = _treeView.getChildFrom(parent);
863  		hItemNode != NULL;
864  		hItemNode = _treeView.getNextSibling(hItemNode))
865  	{
866  		TCHAR textBuffer[MAX_PATH] = { '\0' };
867  		TVITEM tvItem;
868  		tvItem.mask = TVIF_TEXT;
869  		tvItem.pszText = textBuffer;
870  		tvItem.cchTextMax = MAX_PATH;
871  		tvItem.hItem = hItemNode;
872  		SendMessage(_treeView.getHSelf(), TVM_GETITEM, 0, reinterpret_cast<LPARAM>(&tvItem));
873  		if (label == tvItem.pszText)
874  		{
875  			return hItemNode;
876  		}
877  	}
878  	return nullptr;
879  }
880  vector<generic_string> FileBrowser::getRoots() const
881  {
882  	vector<generic_string> roots;
883  	for (HTREEITEM hItemNode = _treeView.getRoot();
884  		hItemNode != nullptr;
885  		hItemNode = _treeView.getNextSibling(hItemNode))
886  	{
887  		TVITEM tvItem;
888  		tvItem.mask = TVIF_PARAM;
889  		tvItem.cchTextMax = MAX_PATH;
890  		tvItem.hItem = hItemNode;
891  		SendMessage(_treeView.getHSelf(), TVM_GETITEM, 0, reinterpret_cast<LPARAM>(&tvItem));
892  		roots.push_back(reinterpret_cast<SortingData4lParam*>(tvItem.lParam)->_rootPath);
893  	}
894  	return roots;
895  }
896  generic_string FileBrowser::getSelectedItemPath() const
897  {
898  	generic_string itemPath;
899  	HTREEITEM hItemNode = _treeView.getSelection();
900  	if (hItemNode)
901  	{
902  		itemPath = getNodePath(hItemNode);
903  	}
904  	return itemPath;
905  }
906  std::vector<FileBrowser::FilesToChange> FileBrowser::getFilesFromParam(LPARAM lParam) const
907  {
908  	const std::vector<generic_string> filesToChange = *(std::vector<generic_string>*)lParam;
909  	const generic_string separator = TEXT("\\\\");
910  	const size_t separatorLength = separator.length();
911  	std::vector<FilesToChange> groupedFiles;
912  	for (size_t i = 0; i < filesToChange.size(); i++)
913  	{
914  		const size_t sepPos = filesToChange[i].find(separator);
915  		if (sepPos == generic_string::npos)
916  			continue;
917  		const generic_string pathSuffix = filesToChange[i].substr(sepPos + separatorLength, filesToChange[i].length() - 1);
918  		vector<generic_string> linarPathArray = split(pathSuffix, '\\');
919  		const generic_string lastElement = linarPathArray.back();
920  		linarPathArray.pop_back();
921  		const generic_string rootPath = filesToChange[i].substr(0, sepPos);
922  		const generic_string addedFilePath = filesToChange[i].substr(0, sepPos + 1) + pathSuffix;
923  		generic_string commonPath = rootPath;
924  		for (const auto & element : linarPathArray)
925  		{
926  			commonPath.append(TEXT("\\"));
927  			commonPath.append(element);
928  		}
929  		commonPath.append(TEXT("\\"));
930  		const auto it = std::find_if(groupedFiles.begin(), groupedFiles.end(), [&commonPath](const auto & group) { return group._commonPath == commonPath; });
931  		if (it == groupedFiles.end())
932  		{
933  			FilesToChange group;
934  			group._commonPath = commonPath;
935  			group._rootPath = rootPath;
936  			group._linarWithoutLastPathElement = linarPathArray;
937  			group._files.push_back(lastElement);
938  			groupedFiles.push_back(group);
939  		}
940  		else
941  		{
942  			it->_files.push_back(lastElement);
943  		}
944  	}
945  	return groupedFiles;
946  }
947  bool FileBrowser::addToTree(FilesToChange & group, HTREEITEM node)
948  {
949  	if (node == nullptr) 
950  	{
951  		if ((node = getRootFromFullPath(group._rootPath)) == nullptr)
952  			return false;
953  	}
954  	if (group._linarWithoutLastPathElement.size() == 0)
955  	{
956  		group._files.erase(std::remove_if(group._files.begin(), group._files.end(), 
957  			[&group](const auto & file)
958  			{
959  				return !::PathFileExists((group._commonPath + file).c_str());
960  			}),
961  			group._files.end());
962  		if (group._files.empty()) 
963  		{
964  			return false;
965  		}
966  		removeNamesAlreadyInNode(node, group._files);
967  		if (group._files.empty()) 
968  		{
969  			return false;
970  		}
971  		for (auto & file : group._files) {
972  			if (::PathIsDirectory((group._commonPath + file).c_str()))
973  			{
974  				SortingData4lParam* customData = new SortingData4lParam(TEXT(""), file, true);
975  				sortingDataArray.push_back(customData);
976  				_treeView.addItem(file.c_str(), node, INDEX_CLOSE_NODE, reinterpret_cast<LPARAM>(customData));
977  			}
978  			else
979  			{
980  				SortingData4lParam* customData = new SortingData4lParam(TEXT(""), file, false);
981  				sortingDataArray.push_back(customData);
982  				_treeView.addItem(file.c_str(), node, INDEX_LEAF, reinterpret_cast<LPARAM>(customData));
983  			}
984  		}
985  		_treeView.customSorting(node, categorySortFunc, 0, false);
986  		return true;
987  	}
988  	else
989  	{
990  		for (HTREEITEM hItemNode = _treeView.getChildFrom(node);
991  			hItemNode != NULL;
992  			hItemNode = _treeView.getNextSibling(hItemNode))
993  		{
994  			TCHAR textBuffer[MAX_PATH] = { '\0' };
995  			TVITEM tvItem;
996  			tvItem.mask = TVIF_TEXT;
997  			tvItem.pszText = textBuffer;
998  			tvItem.cchTextMax = MAX_PATH;
999  			tvItem.hItem = hItemNode;
1000  			SendMessage(_treeView.getHSelf(), TVM_GETITEM, 0, reinterpret_cast<LPARAM>(&tvItem));
1001  			if (group._linarWithoutLastPathElement[0] == tvItem.pszText)
1002  			{
1003  				group._linarWithoutLastPathElement.erase(group._linarWithoutLastPathElement.begin());
1004  				return addToTree(group, hItemNode);
1005  			}
1006  		}
1007  		return false;
1008  	}
1009  }
1010  bool FileBrowser::deleteFromTree(FilesToChange & group)
1011  {
1012  	std::vector<HTREEITEM> foundItems = findInTree(group, nullptr);
1013  	if (foundItems.empty() == true)
1014  	{
1015  		return false;
1016  	}
1017  	for (auto & item : foundItems)
1018  	{
1019  		_treeView.removeItem(item);
1020  	}
1021  	return true;
1022  }
1023  HTREEITEM FileBrowser::findInTree(const generic_string& rootPath, HTREEITEM node, std::vector<generic_string> linarPathArray) const
1024  {
1025  	if (node == nullptr) 
1026  	{
1027  		if ((node = getRootFromFullPath(rootPath)) == nullptr)
1028  			return nullptr;
1029  	}
1030  	if (linarPathArray.empty()) 
1031  	{
1032  		return node;
1033  	}
1034  	else if (linarPathArray.size() == 1)
1035  	{
1036  		return findChildNodeFromName(node, linarPathArray[0]);
1037  	}
1038  	else
1039  	{
1040  		for (HTREEITEM hItemNode = _treeView.getChildFrom(node);
1041  			hItemNode != NULL;
1042  			hItemNode = _treeView.getNextSibling(hItemNode))
1043  		{
1044  			TCHAR textBuffer[MAX_PATH] = { '\0' };
1045  			TVITEM tvItem;
1046  			tvItem.mask = TVIF_TEXT;
1047  			tvItem.pszText = textBuffer;
1048  			tvItem.cchTextMax = MAX_PATH;
1049  			tvItem.hItem = hItemNode;
1050  			SendMessage(_treeView.getHSelf(), TVM_GETITEM, 0, reinterpret_cast<LPARAM>(&tvItem));
1051  			if (linarPathArray[0] == tvItem.pszText)
1052  			{
1053  				linarPathArray.erase(linarPathArray.begin());
1054  				return findInTree(rootPath, hItemNode, linarPathArray);
1055  			}
1056  		}
1057  		return nullptr;
1058  	}
1059  }
1060  std::vector<HTREEITEM> FileBrowser::findInTree(FilesToChange & group, HTREEITEM node) const
1061  {
1062  	if (node == nullptr) 
1063  	{
1064  		if ((node = getRootFromFullPath(group._rootPath)) == nullptr)
1065  		{
1066  			return {};
1067  		}
1068  	}
1069  	if (group._linarWithoutLastPathElement.empty())
1070  	{
1071  		return findChildNodesFromNames(node, group._files);
1072  	}
1073  	else
1074  	{
1075  		for (HTREEITEM hItemNode = _treeView.getChildFrom(node);
1076  			hItemNode != NULL;
1077  			hItemNode = _treeView.getNextSibling(hItemNode))
1078  		{
1079  			TCHAR textBuffer[MAX_PATH] = {'\0'};
1080  			TVITEM tvItem;
1081  			tvItem.mask = TVIF_TEXT;
1082  			tvItem.pszText = textBuffer;
1083  			tvItem.cchTextMax = MAX_PATH;
1084  			tvItem.hItem = hItemNode;
1085  			SendMessage(_treeView.getHSelf(), TVM_GETITEM, 0, reinterpret_cast<LPARAM>(&tvItem));
1086  			if (group._linarWithoutLastPathElement[0] == tvItem.pszText)
1087  			{
1088  				group._linarWithoutLastPathElement.erase(group._linarWithoutLastPathElement.begin());
1089  				return findInTree(group, hItemNode);
1090  			}
1091  		}
1092  		return {};
1093  	}
1094  }
1095  std::vector<HTREEITEM> FileBrowser::findChildNodesFromNames(HTREEITEM parent, std::vector<generic_string> & labels) const
1096  {
1097  	std::vector<HTREEITEM> itemNodes;
1098  	for (HTREEITEM hItemNode = _treeView.getChildFrom(parent);
1099  		hItemNode != NULL && !labels.empty();
1100  		hItemNode = _treeView.getNextSibling(hItemNode)
1101  		)
1102  	{
1103  		TCHAR textBuffer[MAX_PATH];
1104  		TVITEM tvItem;
1105  		tvItem.mask = TVIF_TEXT;
1106  		tvItem.pszText = textBuffer;
1107  		tvItem.cchTextMax = MAX_PATH;
1108  		tvItem.hItem = hItemNode;
1109  		SendMessage(_treeView.getHSelf(), TVM_GETITEM, 0, reinterpret_cast<LPARAM>(&tvItem));
1110  		auto it = std::find(labels.begin(), labels.end(), tvItem.pszText);
1111  		if (it != labels.end())
1112  		{
1113  			labels.erase(it); 
1114  			itemNodes.push_back(hItemNode);
1115  		}
1116  	}
1117  	return itemNodes;
1118  }
1119  void FileBrowser::removeNamesAlreadyInNode(HTREEITEM parent, std::vector<generic_string> & labels) const
1120  {
1121  	for (HTREEITEM hItemNode = _treeView.getChildFrom(parent);
1122  		hItemNode != NULL && !labels.empty();
1123  		hItemNode = _treeView.getNextSibling(hItemNode)
1124  		)
1125  	{
1126  		TCHAR textBuffer[MAX_PATH];
1127  		TVITEM tvItem;
1128  		tvItem.mask = TVIF_TEXT;
1129  		tvItem.pszText = textBuffer;
1130  		tvItem.cchTextMax = MAX_PATH;
1131  		tvItem.hItem = hItemNode;
1132  		SendMessage(_treeView.getHSelf(), TVM_GETITEM, 0, reinterpret_cast<LPARAM>(&tvItem));
1133  		auto it = std::find(labels.begin(), labels.end(), tvItem.pszText);
1134  		if (it != labels.end())
1135  		{
1136  			labels.erase(it);
1137  		}
1138  	}
1139  }
1140  bool FileBrowser::renameInTree(const generic_string& rootPath, HTREEITEM node, const std::vector<generic_string>& linarPathArrayFrom, const generic_string & renameTo)
1141  {
1142  	HTREEITEM foundItem = findInTree(rootPath, node, linarPathArrayFrom);
1143  	if (foundItem == nullptr)
1144  			return false;
1145  	_treeView.renameItem(foundItem, renameTo.c_str());
1146  	SortingData4lParam* compareData = reinterpret_cast<SortingData4lParam*>(_treeView.getItemParam(foundItem));
1147  	compareData->_label = renameTo;
1148  	_treeView.customSorting(_treeView.getParent(foundItem), categorySortFunc, 0, false);
1149  	return true;
1150  }
1151  int CALLBACK FileBrowser::categorySortFunc(LPARAM lParam1, LPARAM lParam2, LPARAM &bsol;*lParamSort*/)
1152  {
1153  	SortingData4lParam* item1 = reinterpret_cast<SortingData4lParam*>(lParam1);
1154  	SortingData4lParam* item2 = reinterpret_cast<SortingData4lParam*>(lParam2);
1155  	if (!item1 || !item2)
1156  		return 0;
1157  	if (item1->_isFolder && !item2->_isFolder)
1158  		return -1;
1159  	else if (!item1->_isFolder && item2->_isFolder)
1160  		return 1;
1161  	else
1162  		return lstrcmpi(item1->_label.c_str(), item2->_label.c_str());
1163  }
1164  bool FolderInfo::addToStructure(generic_string & fullpath, std::vector<generic_string> linarPathArray)
1165  {
1166  	if (linarPathArray.size() == 1) 
1167  	{
1168  		fullpath += TEXT("\\");
1169  		fullpath += linarPathArray[0];
1170  		if (PathIsDirectory(fullpath.c_str()))
1171  		{
1172  			for (const auto& folder : _subFolders)
1173  			{
1174  				if (linarPathArray[0] == folder.getName())
1175  					return false; 
1176  			}
1177  			_subFolders.push_back(FolderInfo(linarPathArray[0], this));
1178  			return true;
1179  		}
1180  		else
1181  		{
1182  			for (const auto& file : _files)
1183  			{
1184  				if (linarPathArray[0] == file.getName())
1185  					return false; 
1186  			}
1187  			_files.push_back(FileInfo(linarPathArray[0], this));
1188  			return true;
1189  		}	
1190  	}
1191  	else 
1192  	{
1193  		for (auto& folder : _subFolders)
1194  		{
1195  			if (folder.getName() == linarPathArray[0])
1196  			{
1197  				fullpath += TEXT("\\");
1198  				fullpath += linarPathArray[0];
1199  				linarPathArray.erase(linarPathArray.begin());
1200  				return folder.addToStructure(fullpath, linarPathArray);
1201  			}
1202  		}
1203  		return false;
1204  	}
1205  }
1206  bool FolderInfo::removeFromStructure(std::vector<generic_string> linarPathArray)
1207  {
1208  	if (linarPathArray.size() == 1) 
1209  	{
1210  		for (size_t i = 0; i < _files.size(); ++i)
1211  		{
1212  			if (_files[i].getName() == linarPathArray[0])
1213  			{
1214  				_files.erase(_files.begin() + i);
1215  				return true;
1216  			}
1217  		}
1218  		for (size_t i = 0; i < _subFolders.size(); ++i)
1219  		{
1220  			if (_subFolders[i].getName() == linarPathArray[0])
1221  			{
1222  				_subFolders.erase(_subFolders.begin() + i);
1223  				return true;
1224  			}
1225  		}
1226  	}
1227  	else 
1228  	{
1229  		for (size_t i = 0; i < _subFolders.size(); ++i)
1230  		{
1231  			if (_subFolders[i].getName() == linarPathArray[0])
1232  			{
1233  				linarPathArray.erase(linarPathArray.begin());
1234  				return _subFolders[i].removeFromStructure(linarPathArray);
1235  			}
1236  		}
1237  	}
1238  	return false;
1239  }
1240  bool FolderInfo::renameInStructure(std::vector<generic_string> linarPathArrayFrom, std::vector<generic_string> linarPathArrayTo)
1241  {
1242  	if (linarPathArrayFrom.size() == 1) 
1243  	{
1244  		for (auto& file : _files)
1245  		{
1246  			if (file.getName() == linarPathArrayFrom[0])
1247  			{
1248  				file.setName(linarPathArrayTo[0]);
1249  				return true;
1250  			}
1251  		}
1252  		for (auto& folder : _subFolders)
1253  		{
1254  			if (folder.getName() == linarPathArrayFrom[0])
1255  			{
1256  				folder.setName(linarPathArrayTo[0]);
1257  				return true;
1258  			}
1259  		}
1260  		return false;
1261  	}
1262  	else 
1263  	{
1264  		for (auto& folder : _subFolders)
1265  		{
1266  			if (folder.getName() == linarPathArrayFrom[0])
1267  			{
1268  				linarPathArrayFrom.erase(linarPathArrayFrom.begin());
1269  				linarPathArrayTo.erase(linarPathArrayTo.begin());
1270  				return folder.renameInStructure(linarPathArrayFrom, linarPathArrayTo);
1271  			}
1272  		}
1273  		return false;
1274  	}
1275  }
1276  void FolderUpdater::startWatcher()
1277  {
1278  	_EventHandle = ::CreateEvent(nullptr, TRUE, FALSE, nullptr);
1279  	_watchThreadHandle = ::CreateThread(NULL, 0, watching, this, 0, NULL);
1280  }
1281  void FolderUpdater::stopWatcher()
1282  {
1283  	::SetEvent(_EventHandle);
1284  	::CloseHandle(_watchThreadHandle);
1285  	::CloseHandle(_EventHandle);
1286  }
1287  LPCWSTR explainAction(DWORD dwAction)
1288  {
1289  	switch (dwAction)
1290  	{
1291  	case FILE_ACTION_ADDED:
1292  		return L"Added";
1293  	case FILE_ACTION_REMOVED:
1294  		return L"Deleted";
1295  	case FILE_ACTION_MODIFIED:
1296  		return L"Modified";
1297  	case FILE_ACTION_RENAMED_OLD_NAME:
1298  		return L"Renamed From";
1299  	case FILE_ACTION_RENAMED_NEW_NAME:
1300  		return L"Renamed ";
1301  	default:
1302  		return L"BAD DATA";
1303  	}
1304  }
1305  DWORD WINAPI FolderUpdater::watching(void *params)
1306  {
1307  	FolderUpdater *thisFolderUpdater = (FolderUpdater *)params;
1308  	generic_string dir2Watch = (thisFolderUpdater->_rootFolder)._rootPath;
1309  	if (dir2Watch[dir2Watch.length() - 1] != '\\')
1310  		dir2Watch += TEXT("\\"); 
1311  	const DWORD dwNotificationFlags = FILE_NOTIFY_CHANGE_CREATION | FILE_NOTIFY_CHANGE_DIR_NAME | FILE_NOTIFY_CHANGE_FILE_NAME;
1312  	CReadDirectoryChanges changes;
1313  	changes.AddDirectory(dir2Watch.c_str(), true, dwNotificationFlags);
1314  	HANDLE changeHandles[] = { thisFolderUpdater->_EventHandle, changes.GetWaitHandle() };
1315  	bool toBeContinued = true;
1316  	while (toBeContinued)
1317  	{
1318  		DWORD waitStatus = ::WaitForMultipleObjects(_countof(changeHandles), changeHandles, FALSE, INFINITE);
1319  		switch (waitStatus)
1320  		{
1321  			case WAIT_OBJECT_0 + 0:
1322  				toBeContinued = false;
1323  				break;
1324  			case WAIT_OBJECT_0 + 1:
1325  			{
1326  				static const unsigned int MAX_BATCH_SIZE = 100;
1327  				DWORD dwPreviousAction = 0;
1328  				DWORD dwAction;
1329  				generic_string wstrFilename;
1330  				std::vector<generic_string> filesToChange;
1331  				while (changes.Pop(dwAction, wstrFilename))
1332  				{
1333  					if (dwAction != FILE_ACTION_ADDED && dwAction != FILE_ACTION_REMOVED)
1334  					{
1335  						processChange(dwAction, { wstrFilename }, thisFolderUpdater);
1336  					}
1337  					else 
1338  					{
1339  						if (dwPreviousAction == 0)
1340  						{
1341  							dwPreviousAction = dwAction;
1342  						}
1343  						if (dwPreviousAction == dwAction)
1344  						{
1345  							filesToChange.push_back(wstrFilename);
1346  							if (filesToChange.size() > MAX_BATCH_SIZE) 
1347  							{
1348  								processChange(dwAction, filesToChange, thisFolderUpdater);
1349  								filesToChange.clear();
1350  							}
1351  						}
1352  						else
1353  						{
1354  							processChange(dwPreviousAction, filesToChange, thisFolderUpdater);
1355  							filesToChange.clear();
1356  							dwPreviousAction = dwAction;
1357  							filesToChange.push_back(wstrFilename);
1358  						}
1359  					}
1360  				}
1361  				if (dwAction == FILE_ACTION_ADDED || dwAction == FILE_ACTION_REMOVED)
1362  				{
1363  					processChange(dwAction, filesToChange, thisFolderUpdater);
1364  				}
1365  			}
1366  			break;
1367  			case WAIT_IO_COMPLETION:
1368  				break;
1369  		}
1370  	}
1371  	changes.Terminate();
1372  	return EXIT_SUCCESS;
1373  }
1374  void FolderUpdater::processChange(DWORD dwAction, std::vector<generic_string> filesToChange, FolderUpdater* thisFolderUpdater)
1375  {
1376  	static generic_string oldName;
1377  	switch (dwAction)
1378  	{
1379  	case FILE_ACTION_ADDED:
1380  		::SendMessage((thisFolderUpdater->_pFileBrowser)->getHSelf(), FB_ADDFILE, reinterpret_cast<WPARAM>(nullptr), reinterpret_cast<LPARAM>(&filesToChange));
1381  		oldName = TEXT("");
1382  		break;
1383  	case FILE_ACTION_REMOVED:
1384  		::SendMessage((thisFolderUpdater->_pFileBrowser)->getHSelf(), FB_RMFILE, reinterpret_cast<WPARAM>(nullptr), reinterpret_cast<LPARAM>(&filesToChange));
1385  		oldName = TEXT("");
1386  		break;
1387  	case FILE_ACTION_MODIFIED:
1388  		oldName = TEXT("");
1389  		break;
1390  	case FILE_ACTION_RENAMED_OLD_NAME:
1391  		oldName = filesToChange.back();
1392  		break;
1393  	case FILE_ACTION_RENAMED_NEW_NAME:
1394  		if (!oldName.empty())
1395  		{
1396  			std::vector<generic_string> fileRename;
1397  			fileRename.push_back(oldName);
1398  			fileRename.push_back(filesToChange.back());
1399  			::SendMessage((thisFolderUpdater->_pFileBrowser)->getHSelf(), FB_RNFILE, reinterpret_cast<WPARAM>(nullptr), reinterpret_cast<LPARAM>(&fileRename));
1400  		}
1401  		oldName = TEXT("");
1402  		break;
1403  	default:
1404  		oldName = TEXT("");
1405  		break;
1406  	}
1407  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-confirmation_height_bounded.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-fileBrowser.cpp</div>
                </div>
                <div class="column column_space"><pre><code>372  						if (time_spent_cementing > maximum_batch_write_time)
373  						{
374  							batch_write_size = std::max<uint64_t> (minimum_batch_write_size, batch_write_size - amount_to_change);
375  						}
376  						else if (time_spent_cementing < maximum_batch_write_time_increase_cutoff)
377  						{
378  							batch_write_size += amount_to_change;
379  						}
</pre></code></div>
                <div class="column column_space"><pre><code>448  				if (nType == browserNodeType_root)
449  				{
450  					tipStr = *((generic_string *)lpGetInfoTip->lParam);
451  				}
452  				else if (nType == browserNodeType_file)
453  				{
454  					tipStr = getNodePath(lpGetInfoTip->hItem);
455  				}
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    