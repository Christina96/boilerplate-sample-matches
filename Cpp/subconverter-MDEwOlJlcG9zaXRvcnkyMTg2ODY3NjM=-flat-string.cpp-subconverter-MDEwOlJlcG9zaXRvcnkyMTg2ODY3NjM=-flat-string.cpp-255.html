
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 18, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>subconverter-MDEwOlJlcG9zaXRvcnkyMTg2ODY3NjM=-flat-string.cpp</h3>
            <pre><code>1  #include &lt;algorithm&gt;
2  #include &lt;numeric&gt;
3  #include &lt;sstream&gt;
4  #include &lt;string&gt;
5  #include &lt;vector&gt;
6  #include &lt;stdlib.h&gt;
7  #include &lt;time.h&gt;
8  #include &quot;string.h&quot;
9  std::vector&lt;std::string&gt; split(const std::string &amp;s, const std::string &amp;seperator)
10  {
11      std::vector&lt;std::string&gt; result;
12      string_size i = 0;
13      while(i != s.size())
14      {
15          int flag = 0;
16          while(i != s.size() &amp;&amp; flag == 0)
17          {
18              flag = 1;
19              for(string_size x = 0; x &lt; seperator.size(); ++x)
20                  if(s[i] == seperator[x])
21                  {
22                      ++i;
23                      flag = 0;
24                      break;
25                  }
26          }
27          flag = 0;
28          string_size j = i;
29          while(j != s.size() &amp;&amp; flag == 0)
30          {
31              for(string_size x = 0; x &lt; seperator.size(); ++x)
32                  if(s[j] == seperator[x])
33                  {
34                      flag = 1;
35                      break;
36                  }
37              if(flag == 0)
38                  ++j;
39          }
40          if(i != j)
41          {
42              result.push_back(s.substr(i, j-i));
43              i = j;
44          }
45      }
46      return result;
47  }
48  std::string UTF8ToCodePoint(const std::string &amp;data)
49  {
50      std::stringstream ss;
51      for(string_size i = 0; i &lt; data.size(); i++)
52      {
53          int charcode = data[i] &amp; 0xff;
54          if((charcode &gt;&gt; 7) == 0)
55          {
56              ss&lt;&lt;data[i];
57          }
58          else if((charcode &gt;&gt; 5) == 6)
59          {
60              ss&lt;&lt;&quot;\\u&quot;&lt;&lt;std::hex&lt;&lt;((data[i + 1] &amp; 0x3f) | (data[i] &amp; 0x1f) &lt;&lt; 6);
61              i++;
62          }
63          else if((charcode &gt;&gt; 4) == 14)
64          {
65              ss&lt;&lt;&quot;\\u&quot;&lt;&lt;std::hex&lt;&lt;((data[i + 2] &amp; 0x3f) | (data[i + 1] &amp; 0x3f) &lt;&lt; 6 | (data[i] &amp; 0xf) &lt;&lt; 12);
66              i += 2;
67          }
68          else if((charcode &gt;&gt; 3) == 30)
69          {
70              ss&lt;&lt;&quot;\\u&quot;&lt;&lt;std::hex&lt;&lt;((data[i + 3] &amp; 0x3f) | (data[i + 2] &amp; 0x3f) &lt;&lt; 6 | (data[i + 1] &amp; 0x3f) &lt;&lt; 12 | (data[i] &amp; 0x7) &lt;&lt; 18);
71              i += 3;
72          }
73      }
74      return ss.str();
75  }
76  std::string toLower(const std::string &amp;str)
77  {
78      std::string result;
79      std::transform(str.begin(), str.end(), std::back_inserter(result), [](unsigned char c) { return std::tolower(c); });
80      return result;
81  }
82  std::string toUpper(const std::string &amp;str)
83  {
84      std::string result;
85      std::transform(str.begin(), str.end(), std::back_inserter(result), [](unsigned char c) { return std::toupper(c); });
86      return result;
87  }
88  void processEscapeChar(std::string &amp;str)
89  {
90      string_size pos = str.find(&#x27;\\&#x27;);
91      while(pos != str.npos)
92      {
93          if(pos == str.size())
94              break;
95          switch(str[pos + 1])
96          {
97          case &#x27;n&#x27;:
98              str.replace(pos, 2, &quot;\n&quot;);
99              break;
100          case &#x27;r&#x27;:
101              str.replace(pos, 2, &quot;\r&quot;);
102              break;
103          case &#x27;t&#x27;:
<span onclick='openModal()' class='match'>104              str.replace(pos, 2, &quot;\t&quot;);
105              break;
106          default:
107              break;
108          }
109          pos = str.find(&#x27;\\&#x27;, pos + 1);
</span>110      }
111  }
112  void processEscapeCharReverse(std::string &amp;str)
113  {
114      string_size pos = 0;
115      while(pos &lt; str.size())
116      {
117          switch(str[pos])
118          {
119          case &#x27;\n&#x27;:
120              str.replace(pos, 1, &quot;\\n&quot;);
121              break;
122          case &#x27;\r&#x27;:
123              str.replace(pos, 1, &quot;\\r&quot;);
124              break;
125          case &#x27;\t&#x27;:
126              str.replace(pos, 1, &quot;\\t&quot;);
127              break;
128          default:
129              break;
130          }
131          pos++;
132      }
133  }
134  int parseCommaKeyValue(const std::string &amp;input, const std::string &amp;separator, string_pair_array &amp;result)
135  {
136      string_size bpos = 0, epos = input.find(&#x27;,&#x27;);
137      std::string kv;
138      while(bpos &lt; input.size())
139      {
140          if(epos == std::string::npos)
141              epos = input.size();
142          else if(epos &amp;&amp; input[epos - 1] == &#x27;\\&#x27;)
143          {
144              kv += input.substr(bpos, epos - bpos - 1);
145              kv += &#x27;,&#x27;;
146              bpos = epos + 1;
147              epos = input.find(&#x27;,&#x27;, bpos);
148              continue;
149          }
150          kv += input.substr(bpos, epos - bpos);
151          string_size eqpos = kv.find(&#x27;=&#x27;);
152          if(eqpos == std::string::npos)
153              result.emplace_back(&quot;{NONAME}&quot;, kv);
154          else
155              result.emplace_back(kv.substr(0, eqpos), kv.substr(eqpos + 1));
156          kv.clear();
157          bpos = epos + 1;
158          epos = input.find(&#x27;,&#x27;, bpos);
159      }
160      if(kv.size())
161      {
162          string_size eqpos = kv.find(&#x27;=&#x27;);
163          if(eqpos == std::string::npos)
164              result.emplace_back(&quot;{NONAME}&quot;, kv);
165          else
166              result.emplace_back(kv.substr(0, eqpos), kv.substr(eqpos + 1));
167      }
168      return 0;
169  }
170  void trimSelfOf(std::string &amp;str, char target, bool before, bool after)
171  {
172      if (!before &amp;&amp; !after)
173          return;
174      std::string::size_type pos = str.size() - 1;
175      if (after)
176          pos = str.find_last_not_of(target);
177      if (pos != std::string::npos)
178          str.erase(pos + 1);
179      if (before)
180          pos = str.find_first_not_of(target);
181      str.erase(0, pos);
182  }
183  std::string trimOf(const std::string&amp; str, char target, bool before, bool after)
184  {
185      if (!before &amp;&amp; !after)
186          return str;
187      std::string::size_type pos = 0;
188      if (before)
189          pos = str.find_first_not_of(target);
190      if (pos == std::string::npos)
191      {
192          return str;
193      }
194      std::string::size_type pos2 = str.size() - 1;
195      if (after)
196          pos2 = str.find_last_not_of(target);
197      if (pos2 != std::string::npos)
198      {
199          return str.substr(pos, pos2 - pos + 1);
200      }
201      return str.substr(pos);
202  }
203  std::string trim(const std::string&amp; str, bool before, bool after)
204  {
205      return trimOf(str, &#x27; &#x27;, before, after);
206  }
207  std::string trimQuote(const std::string &amp;str, bool before, bool after)
208  {
209      return trimOf(str, &#x27;\&quot;&#x27;, before, after);
210  }
211  std::string trimWhitespace(const std::string &amp;str, bool before, bool after)
212  {
213      static std::string whitespaces(&quot; \t\f\v\n\r&quot;);
214      string_size bpos = 0, epos = str.size();
215      if(after)
216      {
217          epos = str.find_last_not_of(whitespaces);
218          if(epos == std::string::npos)
219              return std::string();
220      }
221      if(before)
222      {
223          bpos = str.find_first_not_of(whitespaces);
224          if(bpos == std::string::npos)
225              return std::string();
226      }
227      return str.substr(bpos, epos - bpos + 1);
228  }
229  std::string getUrlArg(const std::string &amp;url, const std::string &amp;request)
230  {
231      std::string pattern = request + &quot;=&quot;;
232      std::string::size_type pos = url.size();
233      while(pos)
234      {
235          pos = url.rfind(pattern, pos);
236          if(pos != url.npos)
237          {
238              if(pos == 0 || url[pos - 1] == &#x27;&amp;&#x27; || url[pos - 1] == &#x27;?&#x27;)
239              {
240                  pos += pattern.size();
241                  return url.substr(pos, url.find(&quot;&amp;&quot;, pos) - pos);
242              }
243          }
244          else
245              break;
246          pos--;
247      }
248      return std::string();
249  }
250  std::string replaceAllDistinct(std::string str, const std::string &amp;old_value, const std::string &amp;new_value)
251  {
252      for(std::string::size_type pos(0); pos != std::string::npos; pos += new_value.length())
253      {
254          if((pos = str.find(old_value, pos)) != std::string::npos)
255              str.replace(pos, old_value.length(), new_value);
256          else
257              break;
258      }
259      return str;
260  }
261  void removeUTF8BOM(std::string &amp;data)
262  {
263      if(data.compare(0, 3, &quot;\xEF\xBB\xBF&quot;) == 0)
264          data = data.substr(3);
265  }
266  bool isStrUTF8(const std::string &amp;data)
267  {
268      const char *str = data.c_str();
269      unsigned int nBytes = 0;
270      for (unsigned int i = 0; str[i] != &#x27;\0&#x27;; ++i)
271      {
272          unsigned char chr = *(str + i);
273          if (nBytes == 0)
274          {
275              if (chr &gt;= 0x80)
276              {
277                  if (chr &gt;= 0xFC &amp;&amp; chr &lt;= 0xFD)
278                      nBytes = 6;
279                  else if (chr &gt;= 0xF8)
280                      nBytes = 5;
281                  else if (chr &gt;= 0xF0)
282                      nBytes = 4;
283                  else if (chr &gt;= 0xE0)
284                      nBytes = 3;
285                  else if (chr &gt;= 0xC0)
286                      nBytes = 2;
287                  else
288                      return false;
289                  nBytes--;
290              }
291          }
292          else
293          {
294              if ((chr &amp; 0xC0) != 0x80)
295                  return false;
296              nBytes--;
297          }
298      }
299      if (nBytes != 0)
300          return false;
301      return true;
302  }
303  std::string randomStr(const int len)
304  {
305      std::string retData;
306      srand(time(NULL));
307      int cnt = 0;
308      while(cnt &lt; len)
309      {
310          switch((rand() % 3))
311          {
312          case 1:
313              retData += (&#x27;A&#x27; + rand() % 26);
314              break;
315          case 2:
316              retData += (&#x27;a&#x27; + rand() % 26);
317              break;
318          default:
319              retData += (&#x27;0&#x27; + rand() % 10);
320              break;
321          }
322          cnt++;
323      }
324      return retData;
325  }
326  int to_int(const std::string &amp;str, int def_value)
327  {
328      if(str.empty())
329          return def_value;
330      return std::atoi(str.data());
331  }
332  std::string join(const string_array &amp;arr, const std::string &amp;delimiter)
333  {
334      if(arr.size() == 0)
335          return &quot;&quot;;
336      if(arr.size() == 1)
337          return arr[0];
338      return std::accumulate(arr.begin() + 1, arr.end(), arr[0], [&amp;](const std::string &amp;a, const std::string &amp;b) {return a + delimiter + b; });
339  }
</code></pre>
        </div>
        <div class="column">
            <h3>subconverter-MDEwOlJlcG9zaXRvcnkyMTg2ODY3NjM=-flat-string.cpp</h3>
            <pre><code>1  #include &lt;algorithm&gt;
2  #include &lt;numeric&gt;
3  #include &lt;sstream&gt;
4  #include &lt;string&gt;
5  #include &lt;vector&gt;
6  #include &lt;stdlib.h&gt;
7  #include &lt;time.h&gt;
8  #include &quot;string.h&quot;
9  std::vector&lt;std::string&gt; split(const std::string &amp;s, const std::string &amp;seperator)
10  {
11      std::vector&lt;std::string&gt; result;
12      string_size i = 0;
13      while(i != s.size())
14      {
15          int flag = 0;
16          while(i != s.size() &amp;&amp; flag == 0)
17          {
18              flag = 1;
19              for(string_size x = 0; x &lt; seperator.size(); ++x)
20                  if(s[i] == seperator[x])
21                  {
22                      ++i;
23                      flag = 0;
24                      break;
25                  }
26          }
27          flag = 0;
28          string_size j = i;
29          while(j != s.size() &amp;&amp; flag == 0)
30          {
31              for(string_size x = 0; x &lt; seperator.size(); ++x)
32                  if(s[j] == seperator[x])
33                  {
34                      flag = 1;
35                      break;
36                  }
37              if(flag == 0)
38                  ++j;
39          }
40          if(i != j)
41          {
42              result.push_back(s.substr(i, j-i));
43              i = j;
44          }
45      }
46      return result;
47  }
48  std::string UTF8ToCodePoint(const std::string &amp;data)
49  {
50      std::stringstream ss;
51      for(string_size i = 0; i &lt; data.size(); i++)
52      {
53          int charcode = data[i] &amp; 0xff;
54          if((charcode &gt;&gt; 7) == 0)
55          {
56              ss&lt;&lt;data[i];
57          }
58          else if((charcode &gt;&gt; 5) == 6)
59          {
60              ss&lt;&lt;&quot;\\u&quot;&lt;&lt;std::hex&lt;&lt;((data[i + 1] &amp; 0x3f) | (data[i] &amp; 0x1f) &lt;&lt; 6);
61              i++;
62          }
63          else if((charcode &gt;&gt; 4) == 14)
64          {
65              ss&lt;&lt;&quot;\\u&quot;&lt;&lt;std::hex&lt;&lt;((data[i + 2] &amp; 0x3f) | (data[i + 1] &amp; 0x3f) &lt;&lt; 6 | (data[i] &amp; 0xf) &lt;&lt; 12);
66              i += 2;
67          }
68          else if((charcode &gt;&gt; 3) == 30)
69          {
70              ss&lt;&lt;&quot;\\u&quot;&lt;&lt;std::hex&lt;&lt;((data[i + 3] &amp; 0x3f) | (data[i + 2] &amp; 0x3f) &lt;&lt; 6 | (data[i + 1] &amp; 0x3f) &lt;&lt; 12 | (data[i] &amp; 0x7) &lt;&lt; 18);
71              i += 3;
72          }
73      }
74      return ss.str();
75  }
76  std::string toLower(const std::string &amp;str)
77  {
78      std::string result;
79      std::transform(str.begin(), str.end(), std::back_inserter(result), [](unsigned char c) { return std::tolower(c); });
80      return result;
81  }
82  std::string toUpper(const std::string &amp;str)
83  {
84      std::string result;
85      std::transform(str.begin(), str.end(), std::back_inserter(result), [](unsigned char c) { return std::toupper(c); });
86      return result;
87  }
88  void processEscapeChar(std::string &amp;str)
89  {
90      string_size pos = str.find(&#x27;\\&#x27;);
91      while(pos != str.npos)
92      {
93          if(pos == str.size())
94              break;
95          switch(str[pos + 1])
96          {
97          case &#x27;n&#x27;:
98              str.replace(pos, 2, &quot;\n&quot;);
99              break;
100          case &#x27;r&#x27;:
101              str.replace(pos, 2, &quot;\r&quot;);
102              break;
103          case &#x27;t&#x27;:
104              str.replace(pos, 2, &quot;\t&quot;);
105              break;
106          default:
107              break;
108          }
109          pos = str.find(&#x27;\\&#x27;, pos + 1);
110      }
111  }
112  void processEscapeCharReverse(std::string &amp;str)
113  {
114      string_size pos = 0;
115      while(pos &lt; str.size())
116      {
117          switch(str[pos])
118          {
119          case &#x27;\n&#x27;:
120              str.replace(pos, 1, &quot;\\n&quot;);
121              break;
122          case &#x27;\r&#x27;:
123              str.replace(pos, 1, &quot;\\r&quot;);
124              break;
125          case &#x27;\t&#x27;:
<span onclick='openModal()' class='match'>126              str.replace(pos, 1, &quot;\\t&quot;);
127              break;
128          default:
129              break;
130          }
131          pos++;
</span>132      }
133  }
134  int parseCommaKeyValue(const std::string &amp;input, const std::string &amp;separator, string_pair_array &amp;result)
135  {
136      string_size bpos = 0, epos = input.find(&#x27;,&#x27;);
137      std::string kv;
138      while(bpos &lt; input.size())
139      {
140          if(epos == std::string::npos)
141              epos = input.size();
142          else if(epos &amp;&amp; input[epos - 1] == &#x27;\\&#x27;)
143          {
144              kv += input.substr(bpos, epos - bpos - 1);
145              kv += &#x27;,&#x27;;
146              bpos = epos + 1;
147              epos = input.find(&#x27;,&#x27;, bpos);
148              continue;
149          }
150          kv += input.substr(bpos, epos - bpos);
151          string_size eqpos = kv.find(&#x27;=&#x27;);
152          if(eqpos == std::string::npos)
153              result.emplace_back(&quot;{NONAME}&quot;, kv);
154          else
155              result.emplace_back(kv.substr(0, eqpos), kv.substr(eqpos + 1));
156          kv.clear();
157          bpos = epos + 1;
158          epos = input.find(&#x27;,&#x27;, bpos);
159      }
160      if(kv.size())
161      {
162          string_size eqpos = kv.find(&#x27;=&#x27;);
163          if(eqpos == std::string::npos)
164              result.emplace_back(&quot;{NONAME}&quot;, kv);
165          else
166              result.emplace_back(kv.substr(0, eqpos), kv.substr(eqpos + 1));
167      }
168      return 0;
169  }
170  void trimSelfOf(std::string &amp;str, char target, bool before, bool after)
171  {
172      if (!before &amp;&amp; !after)
173          return;
174      std::string::size_type pos = str.size() - 1;
175      if (after)
176          pos = str.find_last_not_of(target);
177      if (pos != std::string::npos)
178          str.erase(pos + 1);
179      if (before)
180          pos = str.find_first_not_of(target);
181      str.erase(0, pos);
182  }
183  std::string trimOf(const std::string&amp; str, char target, bool before, bool after)
184  {
185      if (!before &amp;&amp; !after)
186          return str;
187      std::string::size_type pos = 0;
188      if (before)
189          pos = str.find_first_not_of(target);
190      if (pos == std::string::npos)
191      {
192          return str;
193      }
194      std::string::size_type pos2 = str.size() - 1;
195      if (after)
196          pos2 = str.find_last_not_of(target);
197      if (pos2 != std::string::npos)
198      {
199          return str.substr(pos, pos2 - pos + 1);
200      }
201      return str.substr(pos);
202  }
203  std::string trim(const std::string&amp; str, bool before, bool after)
204  {
205      return trimOf(str, &#x27; &#x27;, before, after);
206  }
207  std::string trimQuote(const std::string &amp;str, bool before, bool after)
208  {
209      return trimOf(str, &#x27;\&quot;&#x27;, before, after);
210  }
211  std::string trimWhitespace(const std::string &amp;str, bool before, bool after)
212  {
213      static std::string whitespaces(&quot; \t\f\v\n\r&quot;);
214      string_size bpos = 0, epos = str.size();
215      if(after)
216      {
217          epos = str.find_last_not_of(whitespaces);
218          if(epos == std::string::npos)
219              return std::string();
220      }
221      if(before)
222      {
223          bpos = str.find_first_not_of(whitespaces);
224          if(bpos == std::string::npos)
225              return std::string();
226      }
227      return str.substr(bpos, epos - bpos + 1);
228  }
229  std::string getUrlArg(const std::string &amp;url, const std::string &amp;request)
230  {
231      std::string pattern = request + &quot;=&quot;;
232      std::string::size_type pos = url.size();
233      while(pos)
234      {
235          pos = url.rfind(pattern, pos);
236          if(pos != url.npos)
237          {
238              if(pos == 0 || url[pos - 1] == &#x27;&amp;&#x27; || url[pos - 1] == &#x27;?&#x27;)
239              {
240                  pos += pattern.size();
241                  return url.substr(pos, url.find(&quot;&amp;&quot;, pos) - pos);
242              }
243          }
244          else
245              break;
246          pos--;
247      }
248      return std::string();
249  }
250  std::string replaceAllDistinct(std::string str, const std::string &amp;old_value, const std::string &amp;new_value)
251  {
252      for(std::string::size_type pos(0); pos != std::string::npos; pos += new_value.length())
253      {
254          if((pos = str.find(old_value, pos)) != std::string::npos)
255              str.replace(pos, old_value.length(), new_value);
256          else
257              break;
258      }
259      return str;
260  }
261  void removeUTF8BOM(std::string &amp;data)
262  {
263      if(data.compare(0, 3, &quot;\xEF\xBB\xBF&quot;) == 0)
264          data = data.substr(3);
265  }
266  bool isStrUTF8(const std::string &amp;data)
267  {
268      const char *str = data.c_str();
269      unsigned int nBytes = 0;
270      for (unsigned int i = 0; str[i] != &#x27;\0&#x27;; ++i)
271      {
272          unsigned char chr = *(str + i);
273          if (nBytes == 0)
274          {
275              if (chr &gt;= 0x80)
276              {
277                  if (chr &gt;= 0xFC &amp;&amp; chr &lt;= 0xFD)
278                      nBytes = 6;
279                  else if (chr &gt;= 0xF8)
280                      nBytes = 5;
281                  else if (chr &gt;= 0xF0)
282                      nBytes = 4;
283                  else if (chr &gt;= 0xE0)
284                      nBytes = 3;
285                  else if (chr &gt;= 0xC0)
286                      nBytes = 2;
287                  else
288                      return false;
289                  nBytes--;
290              }
291          }
292          else
293          {
294              if ((chr &amp; 0xC0) != 0x80)
295                  return false;
296              nBytes--;
297          }
298      }
299      if (nBytes != 0)
300          return false;
301      return true;
302  }
303  std::string randomStr(const int len)
304  {
305      std::string retData;
306      srand(time(NULL));
307      int cnt = 0;
308      while(cnt &lt; len)
309      {
310          switch((rand() % 3))
311          {
312          case 1:
313              retData += (&#x27;A&#x27; + rand() % 26);
314              break;
315          case 2:
316              retData += (&#x27;a&#x27; + rand() % 26);
317              break;
318          default:
319              retData += (&#x27;0&#x27; + rand() % 10);
320              break;
321          }
322          cnt++;
323      }
324      return retData;
325  }
326  int to_int(const std::string &amp;str, int def_value)
327  {
328      if(str.empty())
329          return def_value;
330      return std::atoi(str.data());
331  }
332  std::string join(const string_array &amp;arr, const std::string &amp;delimiter)
333  {
334      if(arr.size() == 0)
335          return &quot;&quot;;
336      if(arr.size() == 1)
337          return arr[0];
338      return std::accumulate(arr.begin() + 1, arr.end(), arr[0], [&amp;](const std::string &amp;a, const std::string &amp;b) {return a + delimiter + b; });
339  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from subconverter-MDEwOlJlcG9zaXRvcnkyMTg2ODY3NjM=-flat-string.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from subconverter-MDEwOlJlcG9zaXRvcnkyMTg2ODY3NjM=-flat-string.cpp</div>
                </div>
                <div class="column column_space"><pre><code>104              str.replace(pos, 2, &quot;\t&quot;);
105              break;
106          default:
107              break;
108          }
109          pos = str.find(&#x27;\\&#x27;, pos + 1);
</pre></code></div>
                <div class="column column_space"><pre><code>126              str.replace(pos, 1, &quot;\\t&quot;);
127              break;
128          default:
129              break;
130          }
131          pos++;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    