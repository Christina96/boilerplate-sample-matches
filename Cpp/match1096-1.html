<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for NCAlignment.h & ncursesw.h</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for NCAlignment.h & ncursesw.h
      </h3>
      <h1 align="center">
        1.4%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>NCAlignment.h (25.531916%)<TH>ncursesw.h (0.7712082%)<TH>Tokens
<TR onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match1096-0.html#0',2,'match1096-1.html#0',3)" NAME="0">(53-54)<TD><A HREF="javascript:ZweiFrames('match1096-0.html#0',2,'match1096-1.html#0',3)" NAME="0">(1702-1708)</A><TD ALIGN=center><FONT COLOR="#ff0000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>NCAlignment.h</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
1 #ifndef NCAlignment_h
2 #define NCAlignment_h
3 #include &lt;iosfwd&gt;
4 #include &lt;yui/YAlignment.h&gt;
5 #include &quot;NCWidget.h&quot;
6 class NCAlignment : public YAlignment, public NCWidget
7 {
8 private:
9     friend std::ostream &amp; operator&lt;&lt;( std::ostream &amp; str, const NCAlignment &amp; obj );
10     NCAlignment &amp; operator=( const NCAlignment &amp; );
11     NCAlignment( const NCAlignment &amp; );
12 protected:
13     virtual const char * location() const { return &quot;NCAlignment&quot;; }
14 public:
15 <A NAME="0"></A>    NCAlignment( YWidget * parent, YAlignmentType halign, YAlignmentType valign );
16     virtual ~NCAlignment();
17 <FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match1096-1.html#0',3,'match1096-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>    virtual int preferredWidth() { return YAlignment::preferredWidth(); }
18     virtual int preferredHeight() { return YAlignment::preferredHeight(); }</B></FONT>
19     virtual void setSize( int newWidth, int newHeight );
20     virtual void moveChild( YWidget * child, int newx, int newy );
21     virtual void setEnabled( bool do_bv );
22 };
#endif </PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>ncursesw.h</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
1 #ifndef _CURSESW_H
2 #define _CURSESW_H
3 #include &lt;iosfwd&gt;
4 #include &lt;ncursesw/curses.h&gt;
5 #ifndef NCURSES_CXX_IMPEXP
6 #define NCURSES_CXX_IMPEXP NCURSES_EXPORT_GENERAL_IMPORT
7 #endif
8 #include &lt;ncursesw/etip.h&gt;
9 #include &lt;cstdio&gt;
10 #include &lt;cstdarg&gt;
11 #include &lt;climits&gt;
12 #include &quot;position.h&quot;
13 #undef lines
14 #undef UNDEF
15 #define UNDEF(name) CUR_ ##name
16 #ifdef addch
17 inline int UNDEF( addch )( chtype ch )	{ return addch( ch ); }
18 #undef addch
19 #define addch UNDEF(addch)
20 #endif
21 #ifdef add_wch
22 inline int UNDEF( add_wch )( cchar_t * cch )  { return add_wch( cch ); }
23 #undef add_wch
24 #define add_wch UNDEF(add_wch)
25 #endif
26 #ifdef echochar
27 inline int UNDEF( echochar )( chtype ch )  { return echochar( ch ); }
28 #undef echochar
29 #define echochar UNDEF(echochar)
30 #endif
31 #ifdef insdelln
32 inline int UNDEF( insdelln )( int n )  { return insdelln( n ); }
33 #undef insdelln
34 #define insdelln UNDEF(insdelln)
35 #endif
36 #ifdef addstr
37 inline int UNDEF( addstr )( const char * str )	{ return addstr( (char *) str ); }
38 #undef addstr
39 #define addstr UNDEF(addstr)
40 #endif
41 #ifdef addwstr
42 inline int UNDEF( addwstr )( const wchar_t * str )  { return addwstr( (wchar_t *) str ); }
43 #undef addwstr
44 #define addwstr UNDEF(addwstr)
45 #endif
46 #ifdef attron
47 inline int UNDEF( attron )( chtype at ) { return attron( at ); }
48 #undef attron
49 #define attron UNDEF(attron)
50 #endif
51 #ifdef attroff
52 inline int UNDEF( attroff )( chtype at ) { return attroff( at ); }
53 #undef attroff
54 #define attroff UNDEF(attroff)
55 #endif
56 #ifdef attrset
57 inline chtype UNDEF( attrset )( chtype at ) { return attrset( at ); }
58 #undef attrset
59 #define attrset UNDEF(attrset)
60 #endif
61 #ifdef border
62 inline int UNDEF( border )( chtype ls, chtype rs, chtype ts, chtype bs, chtype tl, chtype tr, chtype bl, chtype br )
63 { return border( ls, rs, ts, bs, tl, tr, bl, br ); }
64 #undef border
65 #define border UNDEF(border)
66 #endif
67 #ifdef box
68 inline int UNDEF( box )( WINDOW *win, int v, int h ) { return box( win, v, h ); }
69 #undef box
70 #define box UNDEF(box)
71 #endif
72 #ifdef mvwhline
73 inline int UNDEF( mvwhline )( WINDOW *win, int y, int x, chtype c, int n )
74 {
75     return mvwhline( win, y, x, c, n );
76 }
77 #undef mvwhline
78 #define mvwhline UNDEF(mvwhline)
79 #endif
80 #ifdef mvwvline
81 inline int UNDEF( mvwvline )( WINDOW *win, int y, int x, chtype c, int n )
82 {
83     return mvwvline( win, y, x, c, n );
84 }
85 #undef mvwvline
86 #define mvwvline UNDEF(mvwvline)
87 #endif
88 #ifdef clear
89 inline int UNDEF( clear )()  { return clear(); }
90 #undef clear
91 #define clear UNDEF(clear)
92 #endif
93 #ifdef clearok
94 inline int UNDEF( clearok )( WINDOW* win, bool bf )  { return clearok( win, bf ); }
95 #undef clearok
96 #define clearok UNDEF(clearok)
97 #else
98 extern &quot;C&quot; int clearok( WINDOW*, bool );
99 #endif
100 #ifdef clrtobot
101 inline int UNDEF( clrtobot )()	{ return clrtobot(); }
102 #undef clrtobot
103 #define clrtobot UNDEF(clrtobot)
104 #endif
105 #ifdef clrtoeol
106 inline int UNDEF( clrtoeol )()	{ return clrtoeol(); }
107 #undef clrtoeol
108 #define clrtoeol UNDEF(clrtoeol)
109 #endif
110 #ifdef delch
111 inline int UNDEF( delch )()  { return delch(); }
112 #undef delch
113 #define delch UNDEF(delch)
114 #endif
115 #ifdef deleteln
116 inline int UNDEF( deleteln )()	{ return deleteln(); }
117 #undef deleteln
118 #define deleteln UNDEF(deleteln)
119 #endif
120 #ifdef erase
121 inline int UNDEF( erase )()  { return erase(); }
122 #undef erase
123 #define erase UNDEF(erase)
124 #endif
125 #ifdef flushok
126 inline int UNDEF( flushok )( WINDOW* _win, bool _bf )
127 {
128     return flushok( _win, _bf );
129 }
130 #undef flushok
131 #define flushok UNDEF(flushok)
132 #else
133 #define _no_flushok
134 #endif
135 #ifdef getch
136 inline int UNDEF( getch )()  { return getch(); }
137 #undef getch
138 #define getch UNDEF(getch)
139 #endif
140 #ifdef getstr
141 inline int UNDEF( getstr )( char *_str )  { return getstr( _str ); }
142 #undef getstr
143 #define getstr UNDEF(getstr)
144 #endif
145 #ifdef instr
146 inline int UNDEF( instr )( char *_str )  { return instr( _str ); }
147 #undef instr
148 #define instr UNDEF(instr)
149 #endif
150 #ifdef innstr
151 inline int UNDEF( innstr )( char *_str, int n )  { return innstr( _str, n ); }
152 #undef innstr
153 #define innstr UNDEF(innstr)
154 #endif
155 #ifdef mvwinnstr
156 inline int UNDEF( mvwinnstr )( WINDOW *win, int y, int x, char *_str, int n )
157 {
158     return mvwinnstr( win, y, x, _str, n );
159 }
160 #undef mvwinnstr
161 #define mvwinnstr UNDEF(mvwinnstr)
162 #endif
163 #ifdef mvinnstr
164 inline int UNDEF( mvinnstr )( int y, int x, char *_str, int n )
165 {
166     return mvinnstr( y, x, _str, n );
167 }
168 #undef mvinnstr
169 #define mvinnstr UNDEF(mvinnstr)
170 #endif
171 #ifdef winsstr
172 inline int UNDEF( winsstr )( WINDOW *w, const char *_str )
173 {
174     return winsstr( w, _str );
175 }
176 #undef winsstr
177 #define winsstr UNDEF(winsstr)
178 #endif
179 #ifdef mvwinsstr
180 inline int UNDEF( mvwinsstr )( WINDOW *w, int y, int x,  const char *_str )
181 {
182     return mvwinsstr( w, y, x, _str );
183 }
184 #undef mvwinsstr
185 #define mvwinsstr UNDEF(mvwinsstr)
186 #endif
187 #ifdef insstr
188 inline int UNDEF( insstr )( const char *_str )
189 {
190     return insstr( _str );
191 }
192 #undef insstr
193 #define insstr UNDEF(insstr)
194 #endif
195 #ifdef mvinsstr
196 inline int UNDEF( mvinsstr )( int y, int x, const char *_str )
197 {
198     return mvinsstr( y, x, _str );
199 }
200 #undef mvinsstr
201 #define mvinsstr UNDEF(mvinsstr)
202 #endif
203 #ifdef insnstr
204 inline int UNDEF( insnstr )( const char *_str, int n )
205 {
206     return insnstr( _str, n );
207 }
208 #undef insnstr
209 #define insnstr UNDEF(insnstr)
210 #endif
211 #ifdef mvwinsnstr
212 inline int UNDEF( mvwinsnstr )( WINDOW *w, int y, int x, const char *_str, int n )
213 {
214     return mvwinsnstr( w, y, x, _str, n );
215 }
216 #undef mvwinsnstr
217 #define mvwinsnstr UNDEF(mvwinsnstr)
218 #endif
219 #ifdef mvinsnstr
220 inline int UNDEF( mvinsnstr )( int y, int x, const char *_str, int n )
221 {
222     return mvinsnstr( y, x, _str, n );
223 }
224 #undef mvinsnstr
225 #define mvinsnstr UNDEF(mvinsnstr)
226 #endif
227 #ifdef getnstr
228 inline int UNDEF( getnstr )( char *_str, int n )  { return getnstr( _str, n ); }
229 #undef getnstr
230 #define getnstr UNDEF(getnstr)
231 #endif
232 #ifdef getyx
233 inline void UNDEF( getyx )( const WINDOW* win, int&amp; y, int&amp; x )
234 {
235     getyx( win, y, x );
236 }
237 #undef getyx
238 #define getyx UNDEF(getyx)
239 #endif
240 #ifdef getbegyx
241 inline void UNDEF( getbegyx )( WINDOW* win, int&amp; y, int&amp; x ) { getbegyx( win, y, x ); }
242 #undef getbegyx
243 #define getbegyx UNDEF(getbegyx)
244 #endif
245 #ifdef getmaxyx
246 inline void UNDEF( getmaxyx )( WINDOW* win, int&amp; y, int&amp; x ) { getmaxyx( win, y, x ); }
247 #undef getmaxyx
248 #define getmaxyx UNDEF(getmaxyx)
249 #endif
250 #ifdef hline
251 inline int UNDEF( hline )( chtype ch, int n ) { return hline( ch, n ); }
252 #undef hline
253 #define hline UNDEF(hline)
254 #endif
255 #ifdef inch
256 inline chtype UNDEF( inch )()  { return inch(); }
257 #undef inch
258 #define inch UNDEF(inch)
259 #endif
260 #ifdef in_wch
261 inline int UNDEF( in_wch )( cchar_t * cch )  { return in_wch( cch ); }
262 #undef in_wch
263 #define in_wch UNDEF(in_wch)
264 #endif
265 #ifdef insch
266 inline int UNDEF( insch )( char c )  { return insch( c ); }
267 #undef insch
268 #define insch UNDEF(insch)
269 #endif
270 #ifdef ins_wch
271 inline int UNDEF( ins_wch )( const cchar_t *c )  { return ins_wch( c ); }
272 #undef ins_wch
273 #define ins_wch UNDEF(ins_wch)
274 #endif
275 #ifdef mvwins_wch
276 inline int UNDEF( mvwins_wch )( WINDOW *w, int y, int x, const cchar_t *cchar )  { return mvwins_wch( w, y, x, cchar ); }
277 #undef mvwins_wch
278 #define mvwins_wch UNDEF(mvwins_wch)
279 #endif
280 #ifdef insertln
281 inline int UNDEF( insertln )()	{ return insertln(); }
282 #undef insertln
283 #define insertln UNDEF(insertln)
284 #endif
285 #ifdef leaveok
286 inline int UNDEF( leaveok )( WINDOW* win, bool bf )  { return leaveok( win, bf ); }
287 #undef leaveok
288 #define leaveok UNDEF(leaveok)
289 #else
290 extern &quot;C&quot; int leaveok( WINDOW* win, bool bf );
291 #endif
292 #ifdef move
293 inline int UNDEF( move )( int x, int y )  { return move( x, y ); }
294 #undef move
295 #define move UNDEF(move)
296 #endif
297 #ifdef refresh
298 inline int UNDEF( refresh )()  { return refresh(); }
299 #undef refresh
300 #define refresh UNDEF(refresh)
301 #endif
302 #ifdef redrawwin
303 inline int UNDEF( redrawwin )( WINDOW *win )  { return redrawwin( win ); }
304 #undef redrawwin
305 #define redrawwin UNDEF(redrawwin)
306 #endif
307 #ifdef scrl
308 inline int UNDEF( scrl )( int l ) { return scrl( l ); }
309 #undef scrl
310 #define scrl UNDEF(scrl)
311 #endif
312 #ifdef scroll
313 inline int UNDEF( scroll )( WINDOW *win ) { return scroll( win ); }
314 #undef scroll
315 #define scroll UNDEF(scroll)
316 #endif
317 #ifdef scrollok
318 inline int UNDEF( scrollok )( WINDOW* win, bool bf )  { return scrollok( win, bf ); }
319 #undef scrollok
320 #define scrollok UNDEF(scrollok)
321 #else
322 #if	defined(__NCURSES_H)
323 extern &quot;C&quot; int scrollok( WINDOW*, bool );
324 #else
325 extern &quot;C&quot; int scrollok( WINDOW*, char );
326 #endif
327 #endif
328 #ifdef setscrreg
329 inline int UNDEF( setscrreg )( int t, int b ) { return setscrreg( t, b ); }
330 #undef setscrreg
331 #define setscrreg UNDEF(setscrreg)
332 #endif
333 #ifdef standend
334 inline int UNDEF( standend )()	{ return standend(); }
335 #undef standend
336 #define standend UNDEF(standend)
337 #endif
338 #ifdef standout
339 inline int UNDEF( standout )()	{ return standout(); }
340 #undef standout
341 #define standout UNDEF(standout)
342 #endif
343 #ifdef subpad
344 inline WINDOW *UNDEF( subpad )( WINDOW *p, int l, int c, int y, int x )
345 { return derwin( p, l, c, y, x ); }
346 #undef subpad
347 #define subpad UNDEF(subpad)
348 #endif
349 #ifdef timeout
350 #if NCURSES_VERSION_MAJOR &lt; 5
351 inline int UNDEF( timeout )( int delay ) { return timeout( delay ); }
352 #else
353 inline void UNDEF( timeout )( int delay ) { timeout( delay ); }
354 #endif
355 #undef timeout
356 #define timeout UNDEF(timeout)
357 #endif
358 #ifdef touchline
359 inline int UNDEF( touchline )( WINDOW *win, int s, int c )
360 { return touchline( win, s, c ); }
361 #undef touchline
362 #define touchline UNDEF(touchline)
363 #endif
364 #ifdef touchwin
365 inline int UNDEF( touchwin )( WINDOW *win ) { return touchwin( win ); }
366 #undef touchwin
367 #define touchwin UNDEF(touchwin)
368 #endif
369 #ifdef untouchwin
370 inline int UNDEF( untouchwin )( WINDOW *win ) { return untouchwin( win ); }
371 #undef untouchwin
372 #define untouchwin UNDEF(untouchwin)
373 #endif
374 #ifdef vline
375 inline int UNDEF( vline )( chtype ch, int n ) { return vline( ch, n ); }
376 #undef vline
377 #define vline UNDEF(vline)
378 #endif
379 #ifdef waddstr
380 inline int UNDEF( waddstr )( WINDOW *win, char *str ) { return waddstr( win, str ); }
381 #undef waddstr
382 #define waddstr UNDEF(waddstr)
383 #endif
384 #ifdef waddwstr
385 inline int UNDEF( waddwstr )( WINDOW *win, wchar_t *str ) { return waddwstr( win, str ); }
386 #undef waddwstr
387 #define waddwstr UNDEF(waddwstr)
388 #endif
389 #ifdef mvwaddwstr
390 inline int UNDEF( mvwaddwstr )( WINDOW *win, int y, int x, wchar_t *str )
391 { return mvwaddwstr( win, y, x, str ); }
392 #undef mvwaddwstr
393 #define mvwaddwstr UNDEF(mvwaddwstr)
394 #endif
395 #ifdef waddchstr
396 inline int UNDEF( waddchstr )( WINDOW *win, chtype *at ) { return waddchstr( win, at ); }
397 #undef waddchstr
398 #define waddchstr UNDEF(waddchstr)
399 #endif
400 #ifdef wstandend
401 inline int UNDEF( wstandend )( WINDOW *win )  { return wstandend( win ); }
402 #undef wstandend
403 #define wstandend UNDEF(wstandend)
404 #endif
405 #ifdef wstandout
406 inline int UNDEF( wstandout )( WINDOW *win )  { return wstandout( win ); }
407 #undef wstandout
408 #define wstandout UNDEF(wstandout)
409 #endif
410 #ifdef wattroff
411 inline int UNDEF( wattroff )( WINDOW *win, int att ) { return wattroff( win, att ); }
412 #undef wattroff
413 #define wattroff UNDEF(wattroff)
414 #endif
415 #ifdef chgat
416 inline int UNDEF( chgat )( int n, attr_t attr, short color, const void *opts )
417 {
418     return chgat( n, attr, color, opts );
419 }
420 #undef chgat
421 #define chgat UNDEF(chgat)
422 #endif
423 #ifdef mvchgat
424 inline int UNDEF( mvchgat )( int y, int x, int n,
425 			     attr_t attr, short color, const void *opts )
426 {
427     return mvchgat( y, x, n, attr, color, opts );
428 }
429 #undef mvchgat
430 #define mvchgat UNDEF(mvchgat)
431 #endif
432 #ifdef mvwchgat
433 inline int UNDEF( mvwchgat )( WINDOW *win, int y, int x, int n,
434 			      attr_t attr, short color, const void *opts )
435 {
436     return mvwchgat( win, y, x, n, attr, color, opts );
437 }
438 #undef mvwchgat
439 #define mvwchgat UNDEF(mvwchgat)
440 #endif
441 #ifdef wattrset
442 inline int UNDEF( wattrset )( WINDOW *win, int att ) { return wattrset( win, att ); }
443 #undef wattrset
444 #define wattrset UNDEF(wattrset)
445 #endif
446 #ifdef winch
447 inline chtype UNDEF( winch )( const WINDOW* win ) { return winch( win ); }
448 #undef winch
449 #define winch UNDEF(winch)
450 #endif
451 #ifdef mvwaddch
452 inline int UNDEF( mvwaddch )( WINDOW *win, int y, int x, const chtype ch )
453 { return mvwaddch( win, y, x, ch ); }
454 #undef mvwaddch
455 #define mvwaddch UNDEF(mvwaddch)
456 #endif
457 #ifdef mvwaddchnstr
458 inline int UNDEF( mvwaddchnstr )( WINDOW *win, int y, int x, chtype *str, int n )
459 { return mvwaddchnstr( win, y, x, str, n ); }
460 #undef mvwaddchnstr
461 #define mvwaddchnstr UNDEF(mvwaddchnstr)
462 #endif
463 #ifdef mvwaddchstr
464 inline int UNDEF( mvwaddchstr )( WINDOW *win, int y, int x, chtype *str )
465 { return mvwaddchstr( win, y, x, str ); }
466 #undef mvwaddchstr
467 #define mvwaddchstr UNDEF(mvwaddchstr)
468 #endif
469 #ifdef addnstr
470 inline int UNDEF( addnstr )( const char *str, int n )
471 { return addnstr( (char *) str, n ); }
472 #undef addnstr
473 #define addnstr UNDEF(addnstr)
474 #endif
475 #ifdef addnwstr
476 inline int UNDEF( addnwstr )( const wchar_t *str, int n )
477 { return addnwstr( (wchar_t *) str, n ); }
478 #undef addnwstr
479 #define addnwstr UNDEF(addnwstr)
480 #endif
481 #ifdef mvwaddnstr
482 inline int UNDEF( mvwaddnstr )( WINDOW *win, int y, int x, const char *str, int n )
483 { return mvwaddnstr( win, y, x, (char *) str, n ); }
484 #undef mvwaddnstr
485 #define mvwaddnstr UNDEF(mvwaddnstr)
486 #endif
487 #ifdef mvwaddnwstr
488 inline int UNDEF( mvwaddnwstr )( WINDOW *win, int y, int x, const wchar_t *str, int n )
489 { return mvwaddnwstr( win, y, x, (wchar_t *) str, n ); }
490 #undef mvwaddnwstr
491 #define mvwaddnwstr UNDEF(mvwaddnwstr)
492 #endif
493 #ifdef mvwaddstr
494 inline int UNDEF( mvwaddstr )( WINDOW *win, int y, int x, const char * str )
495 { return mvwaddstr( win, y, x, (char *) str ); }
496 #undef mvwaddstr
497 #define mvwaddstr UNDEF(mvwaddstr)
498 #endif
499 #ifdef mvwdelch
500 inline int UNDEF( mvwdelch )( WINDOW *win, int y, int x )
501 { return mvwdelch( win, y, x ); }
502 #undef mvwdelch
503 #define mvwdelch UNDEF(mvwdelch)
504 #endif
505 #ifdef mvwgetch
506 inline int UNDEF( mvwgetch )( WINDOW *win, int y, int x ) { return mvwgetch( win, y, x );}
507 #undef mvwgetch
508 #define mvwgetch UNDEF(mvwgetch)
509 #endif
510 #ifdef mvwgetstr
511 inline int UNDEF( mvwgetstr )( WINDOW *win, int y, int x, char *str )
512 {return mvwgetstr( win, y, x, str );}
513 #undef mvwgetstr
514 #define mvwgetstr UNDEF(mvwgetstr)
515 #endif
516 #ifdef mvwgetnstr
517 inline int UNDEF( mvwgetnstr )( WINDOW *win, int y, int x, char *str, int n )
518 {return mvwgetnstr( win, y, x, str, n );}
519 #undef mvwgetnstr
520 #define mvwgetnstr UNDEF(mvwgetnstr)
521 #endif
522 #ifdef mvwinch
523 inline chtype UNDEF( mvwinch )( WINDOW *win, int y, int x )
524 {
525     return mvwinch( win, y, x );
526 }
527 #undef mvwinch
528 #define mvwinch UNDEF(mvwinch)
529 #endif
530 #ifdef mvwin_wch
531 inline int UNDEF( mvwin_wch )( WINDOW *win, int y, int x, cchar_t * cch )
532 {
533     return mvwin_wch( win, y, x, cch );
534 }
535 #undef mvwin_wch
536 #define mvwin_wch UNDEF(mvwin_wch)
537 #endif
538 #ifdef mvwinsch
539 inline int UNDEF( mvwinsch )( WINDOW *win, int y, int x, char c )
540 { return mvwinsch( win, y, x, c ); }
541 #undef mvwinsch
542 #define mvwinsch UNDEF(mvwinsch)
543 #endif
544 #ifdef mvaddch
545 inline int UNDEF( mvaddch )( int y, int x, chtype ch )
546 { return mvaddch( y, x, ch ); }
547 #undef mvaddch
548 #define mvaddch UNDEF(mvaddch)
549 #endif
550 #ifdef mvaddnstr
551 inline int UNDEF( mvaddnstr )( int y, int x, const char *str, int n )
552 { return mvaddnstr( y, x, (char *) str, n ); }
553 #undef mvaddnstr
554 #define mvaddnstr UNDEF(mvaddnstr)
555 #endif
556 #ifdef mvaddstr
557 inline int UNDEF( mvaddstr )( int y, int x, const char * str )
558 { return mvaddstr( y, x, (char *) str ); }
559 #undef mvaddstr
560 #define mvaddstr UNDEF(mvaddstr)
561 #endif
562 #ifdef mvwadd_wch
563 inline int UNDEF( mvwadd_wch )( WINDOW *win, int y, int x, const cchar_t * cch )
564 { return mvwadd_wch( win, y, x, ( cchar_t* )cch ); }
565 #undef mvwadd_wch
566 #define mvwadd_wch UNDEF(mvwadd_wch)
567 #endif
568 #ifdef mvdelch
569 inline int UNDEF( mvdelch )( int y, int x ) { return mvdelch( y, x );}
570 #undef mvdelch
571 #define mvdelch UNDEF(mvdelch)
572 #endif
573 #ifdef mvgetch
574 inline int UNDEF( mvgetch )( int y, int x ) { return mvgetch( y, x );}
575 #undef mvgetch
576 #define mvgetch UNDEF(mvgetch)
577 #endif
578 #ifdef mvgetstr
579 inline int UNDEF( mvgetstr )( int y, int x, char *str ) {return mvgetstr( y, x, str );}
580 #undef mvgetstr
581 #define mvgetstr UNDEF(mvgetstr)
582 #endif
583 #ifdef mvgetnstr
584 inline int UNDEF( mvgetnstr )( int y, int x, char *str, int n )
585 {
586     return mvgetnstr( y, x, str, n );
587 }
588 #undef mvgetnstr
589 #define mvgetnstr UNDEF(mvgetnstr)
590 #endif
591 #ifdef mvinch
592 inline chtype UNDEF( mvinch )( int y, int x ) { return mvinch( y, x );}
593 #undef mvinch
594 #define mvinch UNDEF(mvinch)
595 #endif
596 #ifdef mvinsch
597 inline int UNDEF( mvinsch )( int y, int x, char c )
598 { return mvinsch( y, x, c ); }
599 #undef mvinsch
600 #define mvinsch UNDEF(mvinsch)
601 #endif
602 #ifdef napms
603 inline void UNDEF( napms )( unsigned long x ) { napms( x ); }
604 #undef napms
605 #define napms UNDEF(napms)
606 #endif
607 #ifdef fixterm
608 inline int UNDEF( fixterm )( void ) { return fixterm(); }
609 #undef fixterm
610 #define fixterm UNDEF(fixterm)
611 #endif
612 #ifdef resetterm
613 inline int UNDEF( resetterm )( void ) { return resetterm(); }
614 #undef resetterm
615 #define resetterm UNDEF(resetterm)
616 #endif
617 #ifdef saveterm
618 inline int UNDEF( saveterm )( void ) { return saveterm(); }
619 #undef saveterm
620 #define saveterm UNDEF(saveterm)
621 #endif
622 #ifdef crmode
623 inline int UNDEF( crmode )( void ) { return crmode(); }
624 #undef crmode
625 #define crmode UNDEF(crmode)
626 #endif
627 #ifdef nocrmode
628 inline int UNDEF( nocrmode )( void ) { return nocrmode(); }
629 #undef nocrmode
630 #define nocrmode UNDEF(nocrmode)
631 #endif
632 #ifdef getbkgd
633 inline chtype UNDEF( getbkgd )( const WINDOW *win ) { return getbkgd( win ); }
634 #undef getbkgd
635 #define getbkgd UNDEF(getbkgd)
636 #endif
637 #ifdef bkgd
638 inline int UNDEF( bkgd )( chtype ch ) { return bkgd( ch ); }
639 #undef bkgd
640 #define bkgd UNDEF(bkgd)
641 #endif
642 #ifdef bkgdset
643 inline void UNDEF( bkgdset )( chtype ch ) { bkgdset( ch ); }
644 #undef bkgdset
645 #define bkgdset UNDEF(bkgdset)
646 #endif
647 template &lt;class _Tp&gt;   inline int ncursesMaxCoord()            { return INT_MAX; }
648 template &lt;&gt;            inline int ncursesMaxCoord&lt;short&gt;()     { return SHRT_MAX; }
649 class NCursesWindow
650 {
651     friend std::ostream &amp; operator&lt;&lt;( std::ostream &amp; Stream, const NCursesWindow &amp; Obj_Cv );
652     friend std::ostream &amp; operator&lt;&lt;( std::ostream &amp; Stream, const NCursesWindow * Obj_Cv );
653     friend class NCursesMenu;
654     friend class NCursesForm;
655 private:
656     static bool    b_initialized;
657     static void    initialize();
658     static int	   ripoff_init( WINDOW *, int );
659     void	   init();
660     short	   getcolor( int getback ) const;
661     static int	   setpalette( short fore, short back, short pair );
662     static int	   colorInitialized;
663     NCursesWindow( WINDOW* win, int cols );
664 protected:
665     void	   err_handler( const char * ) const THROWS( NCursesException );
666     static long count;
667     WINDOW*	   w;
668     bool	   alloced;
669     NCursesWindow* par;
670     NCursesWindow* subwins;
671     NCursesWindow* sib;
672     void	   kill_subwindows();
673     NCursesWindow();
674 public:
675     NCursesWindow( WINDOW* window );
676     NCursesWindow( int lines,
677 		   int cols,
678 		   int begin_y,
679 		   int begin_x );
680     NCursesWindow( NCursesWindow &amp; parent,
681 		   int lines,
682 		   int cols,
683 		   int begin_y,
684 		   int begin_x,
685 		   char absrel = 'a' );
686     virtual ~NCursesWindow();
687     NCursesWindow Clone();
688     static void    useColors( void );
689     static int ripoffline( int ripoff_lines,
690 			   int ( *init )( NCursesWindow&amp; win ) );
691     static int	   lines() { initialize(); return LINES; }
692     static int	   cols() { initialize(); return COLS; }
693     static int	   tabsize() { initialize(); return TABSIZE; }
694     static int	   NumberOfColors();
695     int     colors() const { return NumberOfColors(); }
696     int		   height() const { return maxy() + 1; }
697     int		   width() const { return maxx() + 1; }
698     int		   begx() const { return getbegx(w); }
699     int		   begy() const { return getbegy(w); }
700     int		   maxx() const { return getmaxx(w) == ERR ? ERR : getmaxx(w)-1; }
701     int		   maxy() const { return getmaxy(w) == ERR ? ERR : getmaxy(w)-1; }
702     static int     maxcoord()   { return ncursesMaxCoord&lt;NCURSES_SIZE_T&gt;(); }
703     wsze   size()      const { return wsze( height(), width() ); }
704     wpos   begpos()    const { return wpos( begy(), begx() ); }
705     wpos   maxpos()    const { return wpos( maxy(), maxx() ); }
706     wrect  area()      const { return wrect( begpos(), size() ); }
707     short  getcolor() const;
708     short  foreground() const { return getcolor( 0 ); }
709     short  background() const { return getcolor( 1 ); }
710     int    setpalette( short fore, short back );
711     int    setcolor( short pair );
712     virtual int  mvwin( int begin_y, int begin_x )
713     {
714 	return ::mvwin( w, begin_y, begin_x );
715     }
716     int mvsubwin( NCursesWindow* sub, int begin_y, int begin_x );
717     virtual int resize( int lines, int columns );
718     int		   move( int y, int x ) { return ::wmove( w, y, x ); }
719     void	   getyx( int&amp; y, int&amp; x ) const { ::getyx( w, y, x ); }
720     int		   mvcur( int oldrow, int oldcol, int newrow, int newcol ) const
721     {
722 	return ::mvcur( oldrow, oldcol, newrow, newcol );
723     }
724     int		   nodelay( bool bf ) { return ::nodelay( w, bf ); }
725     int		   getch() { return ::wgetch( w ); }
726     int		   getch( int y, int x ) { return ::mvwgetch( w, y, x ); }
727     int		   getstr( char* str, int n = -1 )
728     {
729 	return ::wgetnstr( w, str, n );
730     }
731     int		   getstr( int y, int x, char* str, int n = -1 )
732     {
733 	return ::mvwgetnstr( w, y, x, str, n );
734     }
735     int		   instr( char *s, int n = -1 ) { return ::winnstr( w, s, n ); }
736     int		   instr( int y, int x, char *s, int n = -1 )
737     {
738 	return ::mvwinnstr( w, y, x, s, n );
739     }
740     int		   addch( const char ch )
741     {
742 	return addch(( const chtype )( ch&amp;A_CHARTEXT ) );
743     }
744     int		   addch( const chtype ch ) { return ::waddch( w, ch ); }
745     int		add_attr_char( int y, int x );
746     int		add_attr_char();
747     int		   add_wch( const cchar_t * cch ) { return ::wadd_wch( w, cch ); }
748     int		   add_wch( int y, int x, const cchar_t * cch ) { return mvwadd_wch( w, y, x, cch ); }
749     int		   addch( int y, int x, const char ch )
750     {
751 	return addch( y, x, ( const chtype )( ch&amp;A_CHARTEXT ) );
752     }
753     int		   addch( int y, int x, const chtype ch )
754     {
755 	return ::mvwaddch( w, y, x, ch );
756     }
757     int		   echochar( const char ch )
758     {
759 	return echochar(( const chtype )( ch&amp;A_CHARTEXT ) );
760     }
761     int		   echochar( const chtype ch ) { return ::wechochar( w, ch ); }
762     int		   addstr( const char* str, int n = -1 )
763     {
764 	return ::waddnstr( w, (char *) str, n );
765     }
766     int		   addstr( int y, int x, const char * str, int n = -1 )
767     {
768 	return ::mvwaddnstr( w, y, x, (char *) str, n );
769     }
770     int		   addwstr( const wchar_t* str, int n = -1 );
771     int		   addwstr( int y, int x, const wchar_t * str, int n = -1 );
772     int		   printw( const char* fmt, ... )
773 #if __GNUG__ &gt;= 2
774     __attribute__(( format( printf, 2, 3 ) ) );
775 #else
776     ;
777 #endif
778     int		   printw( int y, int x, const char * fmt, ... )
779 #if __GNUG__ &gt;= 2
780     __attribute__(( format( printf, 4, 5 ) ) );
781 #else
782     ;
783 #endif
784     chtype	   inch() const { return ::winch( w ); }
785     chtype	   inchar() const { return inch()&amp;( A_CHARTEXT | A_ALTCHARSET ); }
786     chtype	   inch( int y, int x ) { return ::mvwinch( w, y, x ); }
787     chtype	   inchar( int y, int x ) { return inch( y, x )&amp;( A_CHARTEXT | A_ALTCHARSET ); }
788     int		in_wchar( cchar_t * cchar );
789     int 		in_wchar( int y, int x, cchar_t * cchar );
790     int		   insch( chtype ch ) { return ::winsch( w, ch ); }
791     int		   insch( int y, int x, chtype ch )
792     {
793 	return ::mvwinsch( w, y, x, ch );
794     }
795     int		   ins_wch( int y, int x, const cchar_t * cchar )
796     {
797 	return mvwins_wch( w, y, x, cchar );
798     }
799     int		   insertln() { return ::winsdelln( w, 1 ); }
800     int		   insdelln( int n = 1 ) { return ::winsdelln( w, n ); }
801     int		   insstr( const char *s, int n = -1 )
802     {
803 	return ::winsnstr( w, s, n );
804     }
805     int		   insstr( int y, int x, const char *s, int n = -1 )
806     {
807 	return ::mvwinsnstr( w, y, x, s, n );
808     }
809     int		   attron( chtype at ) { return ::wattron( w, at ); }
810     int		   attroff( chtype at ) { return ::wattroff( w, at ); }
811     int		   attrset( chtype at ) { return ::wattrset( w, at ); }
812     int		   chgat( int n, attr_t attr, short color, const void *opts = NULL )
813     {
814 	return ::wchgat( w, n, attr, color, opts );
815     }
816     int		   chgat( int y, int x,
817 			  int n, attr_t attr, short color, const void *opts = NULL )
818     {
819 	return ::mvwchgat( w, y, x, n, attr, color, opts );
820     }
821     chtype	   getbkgd() const { return ::getbkgd( w ); }
822     int		   bkgd( const chtype ch ) { return ::wbkgd( w, ch ); }
823     void	   bkgdset( chtype ch ) { ::wbkgdset( w, ch ); }
824     int box() { return box( wrect( wpos( 0, 0 ), size() ) ); }
825     int		   border( chtype left = 0, chtype right = 0,
826 			   chtype top = 0, chtype bottom = 0,
827 			   chtype top_left = 0, chtype top_right = 0,
828 			   chtype bottom_left = 0, chtype bottom_right = 0 )
829     {
830 	return ::wborder( w, left, right, top, bottom, top_left, top_right,
831 			  bottom_left, bottom_right );
832     }
833     int		   hline( int len, chtype ch = 0 ) { return ::whline( w, ch, len ); }
834     int		   hline( int y, int x, int len, chtype ch = 0 )
835     {
836 	return ::mvwhline( w, y, x, ch, len );
837     }
838     int		   vline( int len, chtype ch = 0 ) { return ::wvline( w, ch, len ); }
839     int		   vline( int y, int x, int len, chtype ch = 0 )
840     {
841 	return ::mvwvline( w, y, x, ch, len );
842     }
843     int		   box( const wrect &amp; dim );
844     int		   erase() { return ::werase( w ); }
845     int		   clear() { return ::wclear( w ); }
846     int		   clearok( bool bf ) { return ::clearok( w, bf ); }
847     int		   clrtobot() { return ::wclrtobot( w ); }
848     int		   clrtoeol() { return ::wclrtoeol( w ); }
849     int		   delch() { return ::wdelch( w ); }
850     int		   delch( int y, int x ) { return ::mvwdelch( w, y, x ); }
851     int		   deleteln() { return ::winsdelln( w, -1 ); }
852     int		   scroll( int amount = 1 ) { return ::wscrl( w, amount ); }
853     int		   scrollok( bool bf ) { return ::scrollok( w, bf ); }
854     int		   setscrreg( int from, int to )
855     {
856 	return ::wsetscrreg( w, from, to );
857     }
858     int		   idlok( bool bf ) { return ::idlok( w, bf ); }
859     void	   idcok( bool bf ) { ::idcok( w, bf ); }
860     int		   touchwin()	{ return ::wtouchln( w, 0, height(), 1 ); }
861     int		   untouchwin() { return ::wtouchln( w, 0, height(), 0 ); }
862     int		   touchln( int s, int cnt, bool changed = TRUE )
863     {
864 	return ::wtouchln( w, s, cnt, (int) ( changed ? 1 : 0 ) );
865     }
866     bool	   is_wintouched() const
867     {
868 	return ( ::is_wintouched( w ) ? TRUE : FALSE );
869     }
870     int		   leaveok( bool bf ) { return ::leaveok( w, bf ); }
871     int		   redrawln( int from, int n ) { return ::wredrawln( w, from, n ); }
872     int		   redrawwin() { return ::wredrawln( w, 0, height() ); }
873     int		   doupdate()  { return ::doupdate(); }
874     void	   syncdown()  { ::wsyncdown( w ); }
875     void	   syncup()    { ::wsyncup( w ); }
876     void	   cursyncup() { ::wcursyncup( w ); }
877     int		   syncok( bool bf ) { return ::syncok( w, bf ); }
878 #ifndef _no_flushok
879     int		   flushok( bool bf ) { return ::flushok( w, bf ); }
880 #endif
881     void	   immedok( bool bf ) { ::immedok( w, bf ); }
882     int		   keypad( bool bf ) { return ::keypad( w, bf ); }
883     int		   meta( bool bf ) { return ::meta( w, bf ); }
884     int		   standout() { return ::wstandout( w ); }
885     int		   standend() { return ::wstandend( w ); }
886 <FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1096-0.html#0',2,'match1096-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>    virtual int    refresh() { return ::wrefresh( w ); }
887     virtual int    noutrefresh() { return ::wnoutrefresh( w ); }</B></FONT>
888     int		   overlay( NCursesWindow&amp; win )
889     {
890 	return ::overlay( w, win.w );
891     }
892     int		   overwrite( NCursesWindow&amp; win )
893     {
894 	return ::overwrite( w, win.w );
895     }
896     int		   copywin( NCursesWindow&amp; win,
897 			    int sminrow, int smincol,
898 			    int dminrow, int dmincol,
899 			    int dmaxrow, int dmaxcol, bool overlay = TRUE )
900     {
901 	return ::copywin( w, win.w, sminrow, smincol, dminrow, dmincol,
902 			  dmaxrow, dmaxcol, (int) ( overlay ? 1 : 0 ) );
903     }
904     bool has_mouse() const;
905     NCursesWindow*	  child()	{ return subwins; }
906     const NCursesWindow*  child() const { return subwins; }
907     NCursesWindow*	  sibling()	  { return sib; }
908     const NCursesWindow*  sibling() const { return sib; }
909     NCursesWindow*	  parent()	 { return par; }
910     const NCursesWindow*  parent() const { return par; }
911     bool isDescendant( NCursesWindow&amp; win );
912 };
913 class NCursesColorWindow : public NCursesWindow
914 {
915 public:
916     NCursesColorWindow( WINDOW* &amp;window )
917 	    : NCursesWindow( window )
918     {
919 	useColors();
920     }
921     NCursesColorWindow( int lines,
922 			int cols,
923 			int begin_y,
924 			int begin_x )
925 	    : NCursesWindow( lines, cols, begin_y, begin_x )
926     {
927 	useColors();
928     }
929     NCursesColorWindow( NCursesWindow&amp; par,
930 			int lines,
931 			int cols,
932 			int begin_y,
933 			int begin_x,
934 			char absrel = 'a' )
935 	    : NCursesWindow( par, lines, cols,
936 			     begin_y, begin_x,
937 			     absrel )
938     {
939 	useColors();
940     }
941 };
942 class NCursesPad : public NCursesWindow
943 {
944 public:
945     NCursesPad( int lines, int cols );
946     int echochar( const chtype ch ) { return ::pechochar( w, ch ); }
947     int refresh() { return OK; };
948     int noutrefresh() { return OK; };
949     int refresh( int pminrow, int pmincol,
950 		 int sminrow, int smincol,
951 		 int smaxrow, int smaxcol )
952     {
953 	return ::prefresh( w, pminrow, pmincol,
954 			   sminrow, smincol, smaxrow, smaxcol );
955     }
956     int noutrefresh( int pminrow, int pmincol,
957 		     int sminrow, int smincol,
958 		     int smaxrow, int smaxcol )
959     {
960 	return ::pnoutrefresh( w, pminrow, pmincol,
961 			       sminrow, smincol, smaxrow, smaxcol );
962     }
963 };
#endif </PRE>
</div>
  </div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
