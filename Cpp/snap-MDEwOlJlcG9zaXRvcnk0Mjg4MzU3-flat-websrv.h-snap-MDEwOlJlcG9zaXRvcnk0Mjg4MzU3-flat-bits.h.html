
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 7.585568917668825%, Tokens: 11, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-websrv.h</h3>
            <pre><code>1  class TWebSrv;
2  class TWebSrvSockEvent: public TSockEvent{
3  private:
4    TWebSrv* WebSrv;
5  public:
6    TWebSrvSockEvent(TWebSrv* _WebSrv):
7      TSockEvent(), WebSrv(_WebSrv){}
8    ~TWebSrvSockEvent(){}
9    void OnRead(const int& SockId, const PSIn& SIn);
10    void OnWrite(const int& SockId);
11    void OnOob(const int& SockId);
12    void OnAccept(const int& SockId, const PSock& Sock);
13    void OnConnect(const int& SockId);
14    void OnClose(const int& SockId);
15    void OnTimeOut(const int& SockId);
16    void OnError(const int& SockId, const int& ErrCd, const TStr& ErrStr);
17    void OnGetHost(const PSockHost& SockHost);
18  };
19  typedef enum {
20    wsctUndef, wsctReceiving, wsctWaitingToRespond, wsctSending} TWebSrvConnType;
21  ClassTP(TWebSrvConn, PWebSrvConn)
22  private:
23    TWebSrv* WebSrv;
24    TWebSrvConnType Type;
25    PSock Sock;
26    TChA HttpRqChA;
27    UndefDefaultCopyAssign(TWebSrvConn);
28  public:
29    TWebSrvConn(const PSock& _Sock, TWebSrv* _WebSrv):
30      Type(wsctUndef), Sock(_Sock), WebSrv(_WebSrv){}
31    static PWebSrvConn New(const PSock& Sock, TWebSrv* WebSrv){
32      return PWebSrvConn(new TWebSrvConn(Sock, WebSrv));}
33    ~TWebSrvConn(){}
34    TWebSrvConn(TSIn&){Fail;}
35    static PWebSrvConn Load(TSIn&){Fail; return NULL;}
36    void Save(TSOut&){Fail;}
37    void PutType(const TWebSrvConnType& _Type){Type=_Type;}
38    TWebSrvConnType GetType() const {return Type;}
39    PSock GetSock() const {return Sock;}
40    void Send(const PSIn& SIn) const {Sock->SendSafe(SIn);}
41    TChA& GetHttpRqChA(){return HttpRqChA;}
42    friend class TWebSrv;
43  };
44  ClassTPV(TWebSrv, PWebSrv, TWebSrvV)
45  private:
46    PNotify Notify;
47    int PortN;
48    TStr HomeNrFPath;
49    PSockEvent SockEvent;
50    PSock Sock;
51    THash<TInt, PWebSrvConn> SockIdToConnH;
52    UndefDefaultCopyAssign(TWebSrv);
53  private:
54    void OnRead(const int& SockId, const PSIn& SIn);
55    void OnWrite(const int& SockId);
56    void OnOob(const int&){Fail;}
57    void OnAccept(const int& SockId, const PSock& Sock);
58    void OnConnect(const int&){Fail;}
59    void OnClose(const int& SockId);
60    void OnTimeOut(const int& SockId);
61    void OnError(const int& SockId, const int& ErrCd, const TStr& ErrStr);
62    void OnGetHost(const PSockHost&){Fail;}
63  public:
64    TWebSrv(
65     const int& _PortN, const bool& FixedPortNP=true, const PNotify& _Notify=NULL);
66    static PWebSrv New(
67     const int& PortN, const bool& FixedPortNP=true, const PNotify& Notify=NULL){
68      return PWebSrv(new TWebSrv(PortN, FixedPortNP, Notify));}
69    virtual ~TWebSrv();
70    TWebSrv(TSIn&){Fail;}
71    static PWebSrv Load(TSIn&){Fail; return NULL;}
72    void Save(TSOut&){Fail;}
73    PNotify GetNotify() const {return Notify;}
74    int GetPortN() const {return PortN;}
75    TStr GetHomeNrFPath() const {return HomeNrFPath;}
76    int GetConns() const {return SockIdToConnH.Len();}
77    bool IsConn(const int& SockId, PWebSrvConn& Conn) const {
78      if (SockIdToConnH.IsKey(SockId)){Conn=GetConn(SockId); return true;}
79      else {return false;}}
80    void AddConn(const int& SockId, const PWebSrvConn& Conn){
81      SockIdToConnH.AddDat(SockId, Conn);}
82    void DelConn(const int& SockId){
<span onclick='openModal()' class='match'>83      SockIdToConnH.DelKey(SockId);}
84    PWebSrvConn GetConn(const int& SockId) const {
85      return SockIdToConnH.GetDat(SockId);}
86    TStr GetPeerIpNum(const int& SockId) const {
</span>87      return GetConn(SockId)->Sock->GetPeerIpNum();}
88    virtual void OnHttpRq(const int& SockId, const PHttpRq& HttpRq);
89    void SendHttpResp(const int& SockId, const PHttpResp& HttpResp);
90    friend class TWebSrvSockEvent;
91  };
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-bits.h</h3>
            <pre><code>1  #include "bd.h"
2  class TB1Def{
3  public:
4    typedef uchar TB1;
5    static const int B1Bits;
6    static const int MxP2Exp;
7    static const TB1 MxB1;
8    TB1* B1P2T;
9    int* B1BitsT;
10  public:
11    TB1Def();
12    ~TB1Def(){delete[] B1P2T; delete[] B1BitsT;}
13    TB1Def& operator=(const TB1Def&){Fail; return *this;}
14    static int GetB1Bits(const TB1& B1);
15    static uint GetP2(const int& P2Exp);
16    static int GetL2(const uchar& Val);
17    static bool GetBit(const int& BitN, const uchar& Val);
18    static const TB1Def B1Def;
19  };
20  class TB2Def{
21  public:
22    typedef unsigned short int TB2;
23    static const int B2Bits;
24    static const int MxP2Exp;
25    static const TB2 MxB2;
26    TB2* B2P2T;
27  public:
28    TB2Def();
29    ~TB2Def(){delete[] B2P2T;}
30    TB2Def& operator=(const TB2Def&){Fail; return *this;}
31    static int GetB2Bits(const TB2& B2);
32    static uint GetP2(const int& P2Exp);
33    static int GetL2(const TB2& Val);
34    static const TB2Def B2Def;
35  };
36  class TB4Def{
37  public:
38    typedef uint TB4;
39    static const int B4Bits;
40    static const int MxP2Exp;
41    static const TB4 MxB4;
42    TB4* B4P2T;
43  public:
44    TB4Def();
45    ~TB4Def(){delete[] B4P2T;}
46    TB4Def& operator=(const TB4Def&){Fail; return *this;}
47    static int GetB4Bits(const TB4& B4);
48    static uint GetP2(const int& P2Exp);
49    static int GetL2(const uint& Val);
50    static const TB4Def B4Def;
51  };
52  class TFSet{
53  private:
54    static const int B4s;
55    static const int Bits;
56    TUIntV B4V;
57  public:
58    TFSet(): B4V(4, 4){}
59    TFSet(const TFSet& FSet): B4V(FSet.B4V){}
60    TFSet(
61     const int& FlagN1, const int& FlagN2=-1, const int& FlagN3=-1,
62     const int& FlagN4=-1, const int& FlagN5=-1, const int& FlagN6=-1,
63     const int& FlagN7=-1, const int& FlagN8=-1, const int& FlagN9=-1);
64    TFSet(const TFSet& FSet1, const TFSet& FSet2):
65      B4V(4, 4){Incl(FSet1); Incl(FSet2);}
66    ~TFSet(){}
67    TFSet(TSIn& SIn): B4V(SIn){}
68    void Save(TSOut& SOut) const {B4V.Save(SOut);}
69    TFSet& operator=(const TFSet& FSet){
70      if (this!=&FSet){B4V=FSet.B4V;} return *this;}
71    bool operator==(const TFSet& FSet) const {return B4V==FSet.B4V;}
72    TFSet& operator|(const int& FlagN){Incl(FlagN); return *this;}
73    TFSet& operator|(const TFSet& FSet){Incl(FSet); return *this;}
74    void Clr(){
75      B4V[0]=0; B4V[1]=0; B4V[2]=0; B4V[3]=0;}
76    bool Empty() const {
77      return
78       (uint(B4V[0])==0)&&(uint(B4V[1])==0)&&
79       (uint(B4V[2])==0)&&(uint(B4V[3])==0);}
80    void Incl(const int& FlagN){
81      Assert((0<=FlagN)&&(FlagN<Bits));
82      B4V[FlagN/TB4Def::B4Def.B4Bits]|=
83       TB4Def::B4Def.B4P2T[FlagN%TB4Def::B4Def.B4Bits];}
84    void Incl(const TFSet& FSet){
85      B4V[0]|=FSet.B4V[0]; B4V[1]|=FSet.B4V[1];
86      B4V[2]|=FSet.B4V[2]; B4V[3]|=FSet.B4V[3];}
87    bool In(const int& FlagN) const {
88      Assert((0<=FlagN)&&(FlagN<Bits));
89      return (B4V[FlagN/TB4Def::B4Def.B4Bits] &
90       TB4Def::B4Def.B4P2T[FlagN%TB4Def::B4Def.B4Bits])!=0;}
91    static const TFSet EmptyFSet;
92  };
93  class TB8Set{
94  private:
95    static const int Bits;
96    TB1Def::TB1 B1;
97  public:
98    TB8Set(): B1(0){}
99    TB8Set(const TB8Set& B8Set): B1(B8Set.B1){}
100    TB8Set(const uchar& _B1): B1(_B1){}
101    TB8Set(TSIn& SIn){SIn.LoadBf(&B1, sizeof(TB1Def::TB1));}
102    void Save(TSOut& SOut) const {SOut.SaveBf(&B1, sizeof(TB1Def::TB1));}
103    TB8Set& operator=(const TB8Set& BSet){B1=BSet.B1; return *this;}
104    TB8Set& operator=(const uchar& _B1){B1=_B1; return *this;}
105    bool operator==(const TB8Set& BSet) const {return B1==BSet.B1;}
106    bool operator<(const TB8Set& BSet) const {return B1<BSet.B1;}
107    bool Empty() const {return B1==0;}
108    TB8Set& Clr(){B1=0; return *this;}
109    TB8Set& Fill(){B1=TB1Def::B1Def.MxB1; return *this;}
110    bool IsPrefix(const TB8Set& BSet, const int& MnBitN) const {
111      Assert((0<=MnBitN)&&(MnBitN<Bits));
112      return (B1>>MnBitN)==(BSet.B1>>MnBitN);}
113    uchar GetUCh() const {return B1;}
114    void Incl(const int& BitN){
115      Assert((0<=BitN)&&(BitN<Bits));
116      B1|=TB1Def::B1Def.B1P2T[BitN];}
117    void Excl(const int& BitN){
118      Assert((0<=BitN)&&(BitN<Bits));
<span onclick='openModal()' class='match'>119      B1&=TB1Def::TB1(~(TB1Def::B1Def.B1P2T[BitN]));}
120    bool In(const int& BitN) const {
121      Assert((0<=BitN)&&(BitN<Bits));
122      return (B1 & TB1Def::B1Def.B1P2T[BitN])!=0;}
123    void SetBit(const int& BitN, const bool& Bool){
</span>124      if (Bool) Incl(BitN); else Excl(BitN);}
125    bool GetBit(const int& BitN) const {
126      Assert((0<=BitN)&&(BitN<Bits));
127      return (B1 & TB1Def::B1Def.B1P2T[BitN])!=0;}
128    int GetBits() const {return Bits;}
129    int Get1s() const {return TB1Def::B1Def.GetB1Bits(B1);}
130    int Get0s() const {return Bits-Get1s();}
131    TStr GetStr() const;
132    void Wr();
133    void PutInt(const int& MnBitN, const int& MxBitN, const int& Val){
134      Assert((0<=MnBitN)&&(MnBitN<=MxBitN)&&(MxBitN<Bits));
135      B1 &= TB1Def::TB1((~(TB1Def::B1Def.B1P2T[MxBitN-MnBitN+1]-1)) << MnBitN);
136      B1 |= TB1Def::TB1((Val & (TB1Def::B1Def.B1P2T[MxBitN-MnBitN+1]-1)) << MnBitN);}
137    int GetInt(const int& MnBitN, const int& MxBitN) const {
138      Assert((0<=MnBitN)&&(MnBitN<=MxBitN)&&(MxBitN<Bits));
139      return (B1>>MnBitN) & (TB1Def::B1Def.B1P2T[MxBitN-MnBitN+1]-1);}
140    TB8Set& operator~(){B1=TB1Def::TB1(~B1); return *this;}
141    TB8Set& operator&=(const TB8Set& BSet){B1&=BSet.B1; return *this;}
142    TB8Set& operator|=(const TB8Set& BSet){B1|=BSet.B1; return *this;}
143    TB8Set& operator|=(const int& BitN){Incl(BitN); return *this;}
144    TB8Set& operator^=(const TB8Set& BSet){B1^=BSet.B1; return *this;}
145    TB8Set& operator>>=(const int& ShiftBits){B1>>=ShiftBits; return *this;}
146    TB8Set& operator<<=(const int& ShiftBits){B1<<=ShiftBits; return *this;}
147    friend TB8Set operator~(const TB8Set& BSet){
148      return ~TB8Set(BSet);}
149    friend TB8Set operator&(const TB8Set& LBSet, const TB8Set& RBSet){
150      return TB8Set(LBSet)&=RBSet;}
151    friend TB8Set operator|(const TB8Set& LBSet, const TB8Set& RBSet){
152      return TB8Set(LBSet)|=RBSet;}
153    friend TB8Set operator^(const TB8Set& LBSet, const TB8Set& RBSet){
154      return TB8Set(LBSet)^=RBSet;}
155  };
156  typedef TVec<TB8Set> TB8SetV;
157  class TB32Set{
158  private:
159    static const int Bits;
160    TB4Def::TB4 B4;
161  public:
162    TB32Set(): B4(0){}
163    TB32Set(const TB32Set& B32Set): B4(B32Set.B4){}
164    TB32Set(const uint& _B4): B4(_B4){}
165    TB32Set(TSIn& SIn){SIn.LoadBf(&B4, sizeof(TB4Def::TB4));}
166    void Save(TSOut& SOut) const {SOut.SaveBf(&B4, sizeof(TB4Def::TB4));}
167    TB32Set& operator=(const TB32Set& BSet){B4=BSet.B4; return *this;}
168    bool operator==(const TB32Set& BSet) const {return B4==BSet.B4;}
169    bool operator<(const TB32Set& BSet) const {return B4<BSet.B4;}
170    bool Empty() const {return B4==0;}
171    TB32Set& Clr(){B4=0; return *this;}
172    TB32Set& Fill(){B4=TB4Def::B4Def.MxB4; return *this;}
173    bool IsPrefix(const TB32Set& BSet, const int& MnBitN) const {
174      Assert((0<=MnBitN)&&(MnBitN<Bits));
175      return (B4>>MnBitN)==(BSet.B4>>MnBitN);}
176    uint GetUInt() const {return B4;}
177    void Incl(const int& BitN){
178      Assert((0<=BitN)&&(BitN<Bits));
179      B4|=TB4Def::B4Def.B4P2T[BitN];}
180    void Excl(const int& BitN){
181      Assert((0<=BitN)&&(BitN<Bits));
182      B4&=~TB4Def::B4Def.B4P2T[BitN];}
183    bool In(const int& BitN) const {
184      Assert((0<=BitN)&&(BitN<Bits));
185      return (B4 & TB4Def::B4Def.B4P2T[BitN])!=0;}
186    void SetBit(const int& BitN, const bool& Bool){
187      if (Bool) Incl(BitN); else Excl(BitN);}
188    bool GetBit(const int& BitN) const {
189      Assert((0<=BitN)&&(BitN<Bits));
190      return (B4 & TB4Def::B4Def.B4P2T[BitN])!=0;}
191    void SwitchBit(const int& BitN){
192      SetBit(BitN, !GetBit(BitN));}
193    int GetBits() const {return Bits;}
194    int Get1s() const {return TB4Def::B4Def.GetB4Bits(B4);}
195    int Get0s() const {return Bits-Get1s();}
196    TStr GetStr() const;
197    void Wr();
198    void PutInt(const int& MnBitN, const int& MxBitN, const int& Val){
199      Assert((0<=MnBitN)&&(MnBitN<=MxBitN)&&(MxBitN<Bits));
200      B4 &= (~(TB4Def::B4Def.B4P2T[MxBitN-MnBitN+1]-1)) << MnBitN;
201      B4 |= (Val & (TB4Def::B4Def.B4P2T[MxBitN-MnBitN+1]-1)) << MnBitN;}
202    int GetInt(const int& MnBitN, const int& MxBitN) const {
203      Assert((0<=MnBitN)&&(MnBitN<=MxBitN)&&(MxBitN<Bits));
204      return (B4>>MnBitN) & (TB4Def::B4Def.B4P2T[MxBitN-MnBitN+1]-1);}
205    TB32Set& operator~(){B4=~B4; return *this;}
206    TB32Set& operator&=(const TB32Set& BSet){B4&=BSet.B4; return *this;}
207    TB32Set& operator|=(const TB32Set& BSet){B4|=BSet.B4; return *this;}
208    TB32Set& operator^=(const TB32Set& BSet){B4^=BSet.B4; return *this;}
209    TB32Set& operator>>=(const int& ShiftBits){B4>>=ShiftBits; return *this;}
210    TB32Set& operator<<=(const int& ShiftBits){B4<<=ShiftBits; return *this;}
211    friend TB32Set operator~(const TB32Set& BSet){
212      return ~TB32Set(BSet);}
213    friend TB32Set operator&(const TB32Set& LBSet, const TB32Set& RBSet){
214      return TB32Set(LBSet)&=RBSet;}
215    friend TB32Set operator|(const TB32Set& LBSet, const TB32Set& RBSet){
216      return TB32Set(LBSet)|=RBSet;}
217    friend TB32Set operator^(const TB32Set& LBSet, const TB32Set& RBSet){
218      return TB32Set(LBSet)^=RBSet;}
219  };
220  typedef TVec<TB32Set> TB32SetV;
221  ClassTPV(TBSet, PBSet, TBSetV)
222  private:
223    int B4s, Bits;
224    TB4Def::TB4 LastB4Mask;
225    TB4Def::TB4* B4T;
226    void SetLastB4(){B4T[B4s-1]&=LastB4Mask;}
227  public:
228    TBSet(): B4s(0), Bits(0), LastB4Mask(0), B4T(NULL){}
229    TBSet(const TBSet& BSet);
230    PBSet Clone() const {return PBSet(new TBSet(*this));}
231    TBSet(const int& _Bits):
232      B4s(0), Bits(0), LastB4Mask(0), B4T(NULL){Gen(_Bits);}
233    static PBSet New(const int& Bits){return PBSet(new TBSet(Bits));}
234    ~TBSet(){delete[] B4T;}
235    TBSet(TSIn& SIn){
236      SIn.Load(B4s); SIn.Load(Bits);
237      SIn.LoadBf(&LastB4Mask, sizeof(TB4Def::TB4));
238      B4T=(TB4Def::TB4*)SIn.LoadNewBf(B4s*sizeof(TB4Def::TB4));}
239    static PBSet Load(TSIn& SIn){return new TBSet(SIn);}
240    void Save(TSOut& SOut) const {
241      SOut.Save(B4s); SOut.Save(Bits);
242      SOut.SaveBf(&LastB4Mask, sizeof(TB4Def::TB4));
243      SOut.SaveBf(B4T, B4s*sizeof(TB4Def::TB4));}
244    TBSet& operator=(const TBSet& BSet);
245    bool operator==(const TBSet& BSet) const;
246    void Gen(const int& _Bits);
247    void Clr();
248    void Fill();
249    void Incl(const int& BitN){
250      Assert((0<=BitN)&&(BitN<Bits));
251      B4T[BitN/TB4Def::B4Def.B4Bits]|=
252       TB4Def::B4Def.B4P2T[BitN%TB4Def::B4Def.B4Bits];}
253    void Excl(const int& BitN){
254      Assert((0<=BitN)&&(BitN<Bits));
255      B4T[BitN/TB4Def::B4Def.B4Bits]&=
256       ~TB4Def::B4Def.B4P2T[BitN%TB4Def::B4Def.B4Bits];}
257    bool In(const int& BitN) const {
258      Assert((0<=BitN)&&(BitN<Bits));
259      return (B4T[BitN/TB4Def::B4Def.B4Bits] &
260       TB4Def::B4Def.B4P2T[BitN%TB4Def::B4Def.B4Bits])!=0;}
261    void SetBit(const int& BitN, const bool& Bool){
262      if (Bool){Incl(BitN);} else {Excl(BitN);}}
263    bool GetBit(const int& BitN) const {
264      Assert((0<=BitN)&&(BitN<Bits));
265      return (B4T[BitN/TB4Def::B4Def.B4Bits] &
266       TB4Def::B4Def.B4P2T[BitN%TB4Def::B4Def.B4Bits])!=0;}
267    void SwitchBit(const int& BitN){
268      SetBit(BitN, !GetBit(BitN));}
269    int GetBits() const {return Bits;}
270    int Get1s();
271    int Get0s(){return Bits-Get1s();}
272    uint64 GetUInt64() const {
273      Assert(Bits>=64); uint64 Val; memcpy(&Val, B4T, 8); return Val;}
274    void Wr();
275    TBSet& operator~(){
276      for (int B4N=0; B4N<B4s; B4N++){B4T[B4N]=~B4T[B4N];} return *this;}
277    TBSet& operator&=(const TBSet& BSet){
278      Assert(B4s==BSet.B4s);
279      for (int B4N=0; B4N<B4s; B4N++){B4T[B4N]&=BSet.B4T[B4N];} return *this;}
280    TBSet& operator|=(const TBSet& BSet){
281      Assert(B4s==BSet.B4s);
282      for (int B4N=0; B4N<B4s; B4N++){B4T[B4N]|=BSet.B4T[B4N];} return *this;}
283    TBSet& operator|=(const int& BitN){
284      Incl(BitN); return *this;}
285    TBSet& operator^=(const TBSet& BSet){
286      Assert(B4s==BSet.B4s);
287      for (int B4N=0; B4N<B4s; B4N++){B4T[B4N]^=BSet.B4T[B4N];} return *this;}
288    friend TBSet operator~(const TBSet& BSet){
289      return ~TBSet(BSet);}
290    friend TBSet operator&(const TBSet& LBSet, const TBSet& RBSet){
291      return TBSet(LBSet)&=RBSet;}
292    friend TBSet operator|(const TBSet& LBSet, const TBSet& RBSet){
293      return TBSet(LBSet)|=RBSet;}
294    friend TBSet operator^(const TBSet& LBSet, const TBSet& RBSet){
295      return TBSet(LBSet)^=RBSet;}
296    friend TBSet operator&(const TBSet& LBSet, const int& BitN){
297      return TBSet(LBSet)&=BitN;}
298    friend TBSet operator|(const TBSet& LBSet, const int& BitN){
299      return TBSet(LBSet)|=BitN;}
300    friend TBSet operator^(const TBSet& LBSet, const int& BitN){
301      return TBSet(LBSet)^=BitN;}
302  };
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-websrv.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-bits.h</div>
                </div>
                <div class="column column_space"><pre><code>83      SockIdToConnH.DelKey(SockId);}
84    PWebSrvConn GetConn(const int& SockId) const {
85      return SockIdToConnH.GetDat(SockId);}
86    TStr GetPeerIpNum(const int& SockId) const {
</pre></code></div>
                <div class="column column_space"><pre><code>119      B1&=TB1Def::TB1(~(TB1Def::B1Def.B1P2T[BitN]));}
120    bool In(const int& BitN) const {
121      Assert((0<=BitN)&&(BitN<Bits));
122      return (B1 & TB1Def::B1Def.B1P2T[BitN])!=0;}
123    void SetBit(const int& BitN, const bool& Bool){
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    