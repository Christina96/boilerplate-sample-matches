<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for TestExpr2Minibex.cpp &amp; TestEval.cpp</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for TestExpr2Minibex.cpp &amp; TestEval.cpp
      </h3>
<h1 align="center">
        7.6%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>TestExpr2Minibex.cpp (30.0%)<th>TestEval.cpp (4.4117646%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(52-63)<td><a href="#" name="0">(92-101)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>TestExpr2Minibex.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "TestExpr2Minibex.h"
2 #include "ibex_Expr2Minibex.h"
3 #include &lt;sstream&gt;
4 using namespace std;
5 namespace ibex {
6 void TestExpr2Minibex::expr01() {
7 	Variable x("x"),y("y");
8 	const ExprNode&amp; e=((x+1)-1)+(y*x);
9 	stringstream stream;
10 	Expr2Minibex().print(stream,e);
11 	CPPUNIT_ASSERT(strcmp(stream.str().c_str(),"  return (((x+1)-1)+(y*x));")==0);
12 }
13 void TestExpr2Minibex::expr02() {
14 	Variable x("x"),y("y");
15 	const ExprNode&amp; e1=x+1;
16 	const ExprNode&amp; e2=e1+y;
17 	const ExprNode&amp; e=(e1*e1)-(e2+e2);
18 	stringstream stream;
19 	Expr2Minibex().print(stream,e);
20 	CPPUNIT_ASSERT(strcmp(stream.str().c_str(),"  _tmp_0_ = (x+1);\n  _tmp_1_ = (_tmp_0_+y);\n  return ((_tmp_0_*_tmp_0_)-(_tmp_1_+_tmp_1_));")==0);
21 }
22 void TestExpr2Minibex::expr03() {
23 <a name="0"></a>
24 	Variable x(Dim::row_vec(3),"x");
25 	IntervalVector v(3,Interval(1,2));
26 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	const ExprConstant&amp; c1=ExprConstant::new_vector(v,true);
27 	const ExprConstant&amp; c2=ExprConstant::new_scalar(3.0);
28 	const ExprNode&amp; e=(c2*(x+c1))-c2*c1;
29 	stringstream stream;
30 	Expr2Minibex().print(stream,e);
31 	CPPUNIT_ASSERT(strcmp(stream.str().c_str(),"  _tmp_0_ = ([1,2] , [1,2] , [1,2]);\n  return ((3*(x+_tmp_0_))-(3*_tmp_0_));")==0);
32 }
33 void TestExpr2Minibex::expr04() {</b></font>
34 	double x=0.1;
35 	const ExprConstant&amp; c=ExprConstant::new_scalar(x);
36 	stringstream stream;
37 	Expr2Minibex().print(stream,c,false);
38 	CPPUNIT_ASSERT(strcmp(stream.str().c_str(),"  return #3fb999999999999a;")==0);
39 }
40 } 
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>TestEval.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "TestEval.h"
2 #include "ibex_Function.h"
3 #include "ibex_Expr.h"
4 #include "ibex_Eval.h"
5 using namespace std;
6 //IntervalMatrix M2() { 
7 namespace ibex {
8 void TestEval::check_deco(Function&amp; f, const ExprNode&amp; e) {
9 	Domain&amp; dx = f.basic_evaluator().d[f.nodes.rank(e)];
10 	CPPUNIT_ASSERT(dx.dim==e.dim);
11 	switch (e.dim.type()) {
12 	case Dim::SCALAR:
13 		dx.i()=Interval(1,2); 		CPPUNIT_ASSERT(dx.i()==Interval(1,2)); 		break;
14 	case Dim::ROW_VECTOR:
15 		{ IntervalVector box(e.dim.nb_cols());
16 		for (int i=0; i&lt;e.dim.nb_cols(); i++) box[i]=Interval(i,i+1);
17 		dx.v()=box; 		CPPUNIT_ASSERT(dx.v()==box); 		}
18 		break;
19 	case Dim::COL_VECTOR:
20 		{ IntervalVector box(e.dim.nb_rows());
21 		for (int i=0; i&lt;e.dim.nb_rows(); i++) box[i]=Interval(i,i+1);
22 		dx.v()=box; 		CPPUNIT_ASSERT(dx.v()==box); 		}
23 		break;
24 	case Dim::MATRIX:
25 		{ IntervalMatrix m(e.dim.nb_rows(),e.dim.nb_cols());
26 		for (int i=0; i&lt;e.dim.nb_rows(); i++)
27 			for (int j=0; j&lt;e.dim.nb_cols(); j++)
28 				m[i][j]=Interval(i,j);
29 		dx.m()=m; 		CPPUNIT_ASSERT(dx.m()==m); 		}
30 		break;
31 	default:
32 		CPPUNIT_ASSERT(false);
33 		break;
34 	}
35 }
36 <a name="0"></a>
37 void TestEval::deco01() {
38 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	const ExprSymbol&amp; x = ExprSymbol::new_("x");
39 	const ExprSymbol&amp; y = ExprSymbol::new_("y");
40 	const ExprNode&amp;   e = x+y;
41 	Function f(x,y,e);
42 	check_deco(f, x);
43 	check_deco(f, y);
44 	check_deco(f, e);
45 }
46 void TestEval::deco02() {</b></font>
47 	const ExprSymbol&amp; x = ExprSymbol::new_("x",Dim::col_vec(3));
48 	const ExprSymbol&amp; y = ExprSymbol::new_("y",Dim::col_vec(3));
49 	const ExprNode&amp;   e = x+y;
50 	Function f(x,y,e);
51 	check_deco(f, x);
52 	check_deco(f, y);
53 	check_deco(f, e);
54 }
55 void TestEval::dist01() {
56 	const ExprSymbol&amp; xa = ExprSymbol::new_("xa");
57 	const ExprSymbol&amp; ya = ExprSymbol::new_("ya");
58 	const ExprSymbol&amp; xb = ExprSymbol::new_("xb");
59 	const ExprSymbol&amp; yb = ExprSymbol::new_("yb");
60 	const ExprSymbol* args[4]={&amp;xa, &amp;ya, &amp;xb, &amp;yb};
61 	Function f(Array&lt;const ExprSymbol&gt;(args,4),sqrt(sqr(xa-ya)+sqr(xb-yb)));
62 	double _xy[][2] = { {3,3}, {4,4},
63 						{4,4}, {5,5} };
64 	IntervalVector box(4,_xy);
65 	Interval res=f.eval(box);
66 	check(res,Interval(::sqrt(2),::sqrt(2)));
67 	CPPUNIT_ASSERT(res.is_superset(Interval(::sqrt(2),::sqrt(2))));
68 }
69 void TestEval::apply01() {
70 	const ExprSymbol&amp; x1 = ExprSymbol::new_("x1");
71 	const ExprSymbol&amp; x2 = ExprSymbol::new_("x2");
72 	Function f1(x1,x1,"f1");
73 	Function f2(x2,f1(x2));
74 	IntervalVector _x2(1,Interval(2,2));
75 	check(f2.eval(_x2), Interval(2,2));
76 	CPPUNIT_ASSERT((f2.eval(_x2)).is_superset(Interval(2,2)));
77 }
78 void TestEval::apply02() {
79 	const ExprSymbol&amp; x1 = ExprSymbol::new_("x1");
80 	const ExprSymbol&amp; y1 = ExprSymbol::new_("y1");
81 	const ExprSymbol&amp; x2 = ExprSymbol::new_("x2");
82 	const ExprSymbol&amp; y2 = ExprSymbol::new_("y2");
83 	Function f1(x1,y1,x1+y1,"f1");
84 	Function f2(x2,y2,f1(x2,x2+y2)+y2,"f2");
85 	IntervalVector x(2);
86 	x[0]=Interval(2,2);
87 	x[1]=Interval(3,3);
88 	check(f2.eval_domain(x).i(), Interval(10,10));
89 	CPPUNIT_ASSERT((f2.eval_domain(x).i()).is_superset(Interval(10,10)));
90 }
91 void TestEval::apply03() {
92 	const ExprSymbol&amp; x1 = ExprSymbol::new_("x1");
93 	const ExprSymbol&amp; y1 = ExprSymbol::new_("y1");
94 	const ExprSymbol&amp; x2 = ExprSymbol::new_("x2");
95 	const ExprSymbol&amp; y2 = ExprSymbol::new_("y2");
96 	const ExprSymbol&amp; x3 = ExprSymbol::new_("x3");
97 	Function f1(x1,y1,x1+y1);
98 	Function f2(x2,y2,x2*y2);
99 	Function f3(x3,f1(x3,x3)-f2(x3,x3));
100 	IntervalVector _x3(1,Interval(3,3));
101 	check(f3.eval_domain(_x3).i(), Interval(-3,-3));
102 	CPPUNIT_ASSERT((f3.eval_domain(_x3).i()).is_superset(Interval(-3,-3)));
103 }
104 void TestEval::apply04() {
105 	const ExprSymbol&amp; x1 = ExprSymbol::new_("x1");
106 	const ExprSymbol&amp; x2 = ExprSymbol::new_("x2");
107 	const ExprSymbol&amp; x3 = ExprSymbol::new_("x3");
108 	Function f1(x1,sqr(x1));
109 	Function f2(x2,x2+Interval(1,1));
110 	Function f3(x3,f2(f1(x3)));
111 	IntervalVector _x3(1,Interval(3,3));
112 	check(f3.eval_domain(_x3).i(), Interval(10,10));
113 	CPPUNIT_ASSERT((f3.eval_domain(_x3).i()).is_superset(Interval(10,10)));
114 }
115 void TestEval::issue242() {
116 	Function f("x[3]","-x");
117 	IntervalVector x(3,Interval::one());
118 	CPPUNIT_ASSERT(almost_eq(f.eval_vector(x),-x,0));
119 }
120 void TestEval::eval_components01() {
121 	const ExprSymbol&amp; x = ExprSymbol::new_("x");
122 	const ExprSymbol&amp; y = ExprSymbol::new_("y");
123 	const ExprSymbol&amp; z = ExprSymbol::new_("z");
124 	const ExprNode&amp; e1=x+3*y;
125 	const ExprNode&amp; e2=y-2*x;
126 	const ExprNode&amp; e3=e1*e2;
127 	Function f(x,y,z,Return(e3+1,e2+3,e3-2,e3-4));
128 	Interval vx=Interval::one();
129 	Interval vy=2*Interval::one();
130 	IntervalVector box(3);
131 	box[0]=vx;
132 	box[1]=vy;
133 	BitSet components=BitSet::empty(4);
134 	components.add(0);
135 	components.add(2);
136 	IntervalVector res=f.eval_vector(box,components);
137 	CPPUNIT_ASSERT(res.size()==2);
138 	CPPUNIT_ASSERT(res[0]==(vx+3*vy)*(vy-2*vx)+1);
139 	CPPUNIT_ASSERT(res[1]==(vx+3*vy)*(vy-2*vx)-2);
140 }
141 void TestEval::eval_components02() {
142 	Dim d=Dim::matrix(3,3);
143 	const ExprSymbol&amp; x = ExprSymbol::new_("x",Dim::col_vec(2));
144 	const ExprSymbol&amp; y = ExprSymbol::new_("y",d);
145 	const ExprSymbol&amp; z = ExprSymbol::new_("z",d);
146 	Function f(x,y,z,Return(x[1],transpose(y[DoubleIndex::one_row(d,1)]),z[DoubleIndex::one_col(d,2)]));
147 	IntervalVector box(20);
148 	for (int i=0; i&lt;20; i++) box[i]=Interval(i,i);
149 	BitSet components=BitSet::empty(9);
150 	components.add(0);
151 	components.add(2);
152 	components.add(4);
153 	components.add(6);
154 	IntervalVector res=f.eval_vector(box,components);
155 	CPPUNIT_ASSERT(res.size()==4);
156 	CPPUNIT_ASSERT(res[0]==1);
157 	CPPUNIT_ASSERT(res[1]==6);
158 	CPPUNIT_ASSERT(res[2]==13);
159 	CPPUNIT_ASSERT(res[3]==19);
160 }
161 void TestEval::matrix_components() {
162 	const ExprSymbol&amp; x = ExprSymbol::new_();
163 	Function f(x,Return(
164 			Return(x  ,x+1,x+2,ExprVector::ROW),
165 			Return(x+3,x+4,x+5,ExprVector::ROW),
166 			Return(x+6,x+7,x+8,ExprVector::ROW),
167 			ExprVector::COL));
168 	double _M1[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8 };
169 	CPPUNIT_ASSERT(f.eval_matrix(IntervalVector(1,Interval::ZERO)) == Matrix(3,3,_M1));
170 	ExprSubNodes nodes(f.expr());
171 	const ExprVector&amp; vec = (const ExprVector&amp;) f.expr();
172 	int rank_row_1=nodes.rank(vec.arg(1));
173 	double _row1[] = { 3, 4, 5 };
174 	Vector row1(3,_row1);
175 	CPPUNIT_ASSERT(f.basic_evaluator().d[rank_row_1].v()==row1);
176 	double _M2[] = { 9, 10, 11, 15, 16, 17 };
177 	BitSet bitset(3);
178 	bitset.add(0);
179 	bitset.add(2);
180 	CPPUNIT_ASSERT(f.eval_matrix(IntervalVector(1,Interval(9,9)),bitset) == Matrix(2,3,_M2));
181 	CPPUNIT_ASSERT(f.basic_evaluator().d[rank_row_1].v()==row1);
182 }
} </pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
