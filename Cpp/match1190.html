<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for TestExpr2Minibex.cpp & TestEval.cpp</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for TestExpr2Minibex.cpp & TestEval.cpp
      </h3>
      <h1 align="center">
        7.6%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>TestExpr2Minibex.cpp (30.0%)<TH>TestEval.cpp (4.4117646%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match1190-0.html#0',2,'match1190-1.html#0',3)" NAME="0">(52-63)<TD><A HREF="javascript:ZweiFrames('match1190-0.html#0',2,'match1190-1.html#0',3)" NAME="0">(92-101)</A><TD ALIGN=center><FONT COLOR="#ff0000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>TestExpr2Minibex.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* ============================================================================
 * I B E X - Expression/Function serialization tests
 * ============================================================================
 * Copyright   : Ecole des Mines de Nantes (FRANCE)
 * License     : This program can be distributed under the terms of the GNU LGPL.
 *               See the file COPYING.LESSER.
 *
 * Author(s)   : Gilles Chabert
 * Created     : Oct 05, 2015
 * ---------------------------------------------------------------------------- */

#include &quot;TestExpr2Minibex.h&quot;
#include &quot;ibex_Expr2Minibex.h&quot;

#include &lt;sstream&gt;

using namespace std;

namespace ibex {

void TestExpr2Minibex::expr01() {

	Variable x(&quot;x&quot;),y(&quot;y&quot;);
	const ExprNode&amp; e=((x+1)-1)+(y*x);

	stringstream stream;

	Expr2Minibex().print(stream,e);
	CPPUNIT_ASSERT(strcmp(stream.str().c_str(),&quot;  return (((x+1)-1)+(y*x));&quot;)==0);
}

void TestExpr2Minibex::expr02() {

	Variable x(&quot;x&quot;),y(&quot;y&quot;);
	const ExprNode&amp; e1=x+1;
	const ExprNode&amp; e2=e1+y;

	const ExprNode&amp; e=(e1*e1)-(e2+e2);

	stringstream stream;

	Expr2Minibex().print(stream,e);

	CPPUNIT_ASSERT(strcmp(stream.str().c_str(),&quot;  _tmp_0_ = (x+1);\n  _tmp_1_ = (_tmp_0_+y);\n  return ((_tmp_0_*_tmp_0_)-(_tmp_1_+_tmp_1_));&quot;)==0);

}

void TestExpr2Minibex::expr03() {
<A NAME="0"></A>
	Variable x(Dim::row_vec(3),&quot;x&quot;);
	IntervalVector v(3,Interval(1,2));
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match1190-1.html#0',3,'match1190-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	const ExprConstant&amp; c1=ExprConstant::new_vector(v,true);
	const ExprConstant&amp; c2=ExprConstant::new_scalar(3.0);
	const ExprNode&amp; e=(c2*(x+c1))-c2*c1;

	stringstream stream;

	Expr2Minibex().print(stream,e);

	CPPUNIT_ASSERT(strcmp(stream.str().c_str(),&quot;  _tmp_0_ = ([1,2] , [1,2] , [1,2]);\n  return ((3*(x+_tmp_0_))-(3*_tmp_0_));&quot;)==0);
}

void TestExpr2Minibex::expr04() {</B></FONT>

	double x=0.1;
	const ExprConstant&amp; c=ExprConstant::new_scalar(x);

	stringstream stream;

	Expr2Minibex().print(stream,c,false);

	CPPUNIT_ASSERT(strcmp(stream.str().c_str(),&quot;  return #3fb999999999999a;&quot;)==0);

}

} // end namespace

</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>TestEval.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* ============================================================================
 * I B E X - Eval Tests
 * ============================================================================
 * Copyright   : IMT Atlantique (FRANCE)
 * License     : This program can be distributed under the terms of the GNU LGPL.
 *               See the file COPYING.LESSER.
 *
 * Author(s)   : Gilles Chabert
 * Created     : Apr 02, 2012
 * Last update : Jul 10, 2019
 * ---------------------------------------------------------------------------- */

#include &quot;TestEval.h&quot;
#include &quot;ibex_Function.h&quot;
#include &quot;ibex_Expr.h&quot;
#include &quot;ibex_Eval.h&quot;

using namespace std;

//namespace {
//
//IntervalMatrix M1() {
//	IntervalMatrix m(2,3);
//	double _r1[][2]={{0,1},{0,2},{0,3}};
//	double _r2[][2]={{-1,0},{-2,0},{-3,0}};
//	IntervalVector r1(3,_r1);
//	IntervalVector r2(3,_r2);
//	m[0]=r1;
//	m[1]=r2;
//	return m;
//}
//
//
//IntervalMatrix M2() { // the transpose of M1
//	IntervalMatrix m(3,2);
//	double _c1[][2]={{0,1},{-1,0}};
//	double _c2[][2]={{0,2},{-2,0}};
//	double _c3[][2]={{0,3},{-3,0}};
//	IntervalVector c1(2,_c1);
//	IntervalVector c2(2,_c2);
//	IntervalVector c3(2,_c3);
//	m[0]=c1;
//	m[1]=c2;
//	m[2]=c3;
//	return m;
//}
//
//}

namespace ibex {

void TestEval::check_deco(Function&amp; f, const ExprNode&amp; e) {
	Domain&amp; dx = f.basic_evaluator().d[f.nodes.rank(e)];
	CPPUNIT_ASSERT(dx.dim==e.dim);
	switch (e.dim.type()) {
	case Dim::SCALAR:
		dx.i()=Interval(1,2); // try to write
		CPPUNIT_ASSERT(dx.i()==Interval(1,2)); // try to read
		break;
	case Dim::ROW_VECTOR:
		{ IntervalVector box(e.dim.nb_cols());
		for (int i=0; i&lt;e.dim.nb_cols(); i++) box[i]=Interval(i,i+1);
		dx.v()=box; // try to write
		CPPUNIT_ASSERT(dx.v()==box); // try to read
		}
		break;
	case Dim::COL_VECTOR:
		{ IntervalVector box(e.dim.nb_rows());
		for (int i=0; i&lt;e.dim.nb_rows(); i++) box[i]=Interval(i,i+1);
		dx.v()=box; // try to write
		CPPUNIT_ASSERT(dx.v()==box); // try to read
		}
		break;
	case Dim::MATRIX:
		{ IntervalMatrix m(e.dim.nb_rows(),e.dim.nb_cols());
		for (int i=0; i&lt;e.dim.nb_rows(); i++)
			for (int j=0; j&lt;e.dim.nb_cols(); j++)
				m[i][j]=Interval(i,j);
		dx.m()=m; // try to write
		CPPUNIT_ASSERT(dx.m()==m); // try to read
		}
		break;
	default:
		CPPUNIT_ASSERT(false);
		break;
	}

}
<A NAME="0"></A>
void TestEval::deco01() {

<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1190-0.html#0',2,'match1190-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	const ExprSymbol&amp; x = ExprSymbol::new_(&quot;x&quot;);
	const ExprSymbol&amp; y = ExprSymbol::new_(&quot;y&quot;);
	const ExprNode&amp;   e = x+y;
	Function f(x,y,e);
	check_deco(f, x);
	check_deco(f, y);
	check_deco(f, e);
}

void TestEval::deco02() {</B></FONT>
	const ExprSymbol&amp; x = ExprSymbol::new_(&quot;x&quot;,Dim::col_vec(3));
	const ExprSymbol&amp; y = ExprSymbol::new_(&quot;y&quot;,Dim::col_vec(3));
	const ExprNode&amp;   e = x+y;
	Function f(x,y,e);

	check_deco(f, x);
	check_deco(f, y);
	check_deco(f, e);
}


void TestEval::dist01() {

	const ExprSymbol&amp; xa = ExprSymbol::new_(&quot;xa&quot;);
	const ExprSymbol&amp; ya = ExprSymbol::new_(&quot;ya&quot;);
	const ExprSymbol&amp; xb = ExprSymbol::new_(&quot;xb&quot;);
	const ExprSymbol&amp; yb = ExprSymbol::new_(&quot;yb&quot;);

	const ExprSymbol* args[4]={&amp;xa, &amp;ya, &amp;xb, &amp;yb};
	Function f(Array&lt;const ExprSymbol&gt;(args,4),sqrt(sqr(xa-ya)+sqr(xb-yb)));

	double _xy[][2] = { {3,3}, {4,4},
						{4,4}, {5,5} };
	IntervalVector box(4,_xy);

	Interval res=f.eval(box);
	//cout &lt;&lt; e.f &lt;&lt; endl;
	check(res,Interval(::sqrt(2),::sqrt(2)));
	CPPUNIT_ASSERT(res.is_superset(Interval(::sqrt(2),::sqrt(2))));
}

void TestEval::apply01() {

	const ExprSymbol&amp; x1 = ExprSymbol::new_(&quot;x1&quot;);
	const ExprSymbol&amp; x2 = ExprSymbol::new_(&quot;x2&quot;);

	Function f1(x1,x1,&quot;f1&quot;);

	Function f2(x2,f1(x2));

	IntervalVector _x2(1,Interval(2,2));
	check(f2.eval(_x2), Interval(2,2));
	CPPUNIT_ASSERT((f2.eval(_x2)).is_superset(Interval(2,2)));
}

void TestEval::apply02() {

	const ExprSymbol&amp; x1 = ExprSymbol::new_(&quot;x1&quot;);
	const ExprSymbol&amp; y1 = ExprSymbol::new_(&quot;y1&quot;);

	const ExprSymbol&amp; x2 = ExprSymbol::new_(&quot;x2&quot;);
	const ExprSymbol&amp; y2 = ExprSymbol::new_(&quot;y2&quot;);

	Function f1(x1,y1,x1+y1,&quot;f1&quot;);
	Function f2(x2,y2,f1(x2,x2+y2)+y2,&quot;f2&quot;);

	//cout &lt;&lt; f1 &lt;&lt; endl;
	//cout &lt;&lt; f2 &lt;&lt; endl;

	IntervalVector x(2);
	x[0]=Interval(2,2);
	x[1]=Interval(3,3);

	check(f2.eval_domain(x).i(), Interval(10,10));
	CPPUNIT_ASSERT((f2.eval_domain(x).i()).is_superset(Interval(10,10)));
}

void TestEval::apply03() {

	const ExprSymbol&amp; x1 = ExprSymbol::new_(&quot;x1&quot;);
	const ExprSymbol&amp; y1 = ExprSymbol::new_(&quot;y1&quot;);

	const ExprSymbol&amp; x2 = ExprSymbol::new_(&quot;x2&quot;);
	const ExprSymbol&amp; y2 = ExprSymbol::new_(&quot;y2&quot;);

	const ExprSymbol&amp; x3 = ExprSymbol::new_(&quot;x3&quot;);

	Function f1(x1,y1,x1+y1);
	Function f2(x2,y2,x2*y2);
	Function f3(x3,f1(x3,x3)-f2(x3,x3));

	//cout &lt;&lt; f3 &lt;&lt; endl;
	IntervalVector _x3(1,Interval(3,3));

	/*
	e.eval().i();
	cout &lt;&lt; &quot;f1:---------\n&quot;;
	f1.cf.print&lt;Domain&gt;();
	cout &lt;&lt; &quot;f2:---------\n&quot;;
	f2.cf.print&lt;Domain&gt;();
	cout &lt;&lt; &quot;f3:---------\n&quot;;
	f3.cf.print&lt;Domain&gt;();
	*/

	check(f3.eval_domain(_x3).i(), Interval(-3,-3));
	CPPUNIT_ASSERT((f3.eval_domain(_x3).i()).is_superset(Interval(-3,-3)));
}

void TestEval::apply04() {

	const ExprSymbol&amp; x1 = ExprSymbol::new_(&quot;x1&quot;);
	const ExprSymbol&amp; x2 = ExprSymbol::new_(&quot;x2&quot;);
	const ExprSymbol&amp; x3 = ExprSymbol::new_(&quot;x3&quot;);

	Function f1(x1,sqr(x1));
	Function f2(x2,x2+Interval(1,1));
	Function f3(x3,f2(f1(x3)));

	IntervalVector _x3(1,Interval(3,3));

	check(f3.eval_domain(_x3).i(), Interval(10,10));
	CPPUNIT_ASSERT((f3.eval_domain(_x3).i()).is_superset(Interval(10,10)));
}

void TestEval::issue242() {
	Function f(&quot;x[3]&quot;,&quot;-x&quot;);
	IntervalVector x(3,Interval::one());
	CPPUNIT_ASSERT(almost_eq(f.eval_vector(x),-x,0));
}

void TestEval::eval_components01() {
	const ExprSymbol&amp; x = ExprSymbol::new_(&quot;x&quot;);
	const ExprSymbol&amp; y = ExprSymbol::new_(&quot;y&quot;);
	const ExprSymbol&amp; z = ExprSymbol::new_(&quot;z&quot;);
	const ExprNode&amp; e1=x+3*y;
	const ExprNode&amp; e2=y-2*x;
	const ExprNode&amp; e3=e1*e2;
	Function f(x,y,z,Return(e3+1,e2+3,e3-2,e3-4));

	Interval vx=Interval::one();
	Interval vy=2*Interval::one();
	IntervalVector box(3);
	box[0]=vx;
	box[1]=vy;

	BitSet components=BitSet::empty(4);
	components.add(0);
	components.add(2);

	IntervalVector res=f.eval_vector(box,components);

	CPPUNIT_ASSERT(res.size()==2);
	CPPUNIT_ASSERT(res[0]==(vx+3*vy)*(vy-2*vx)+1);
	CPPUNIT_ASSERT(res[1]==(vx+3*vy)*(vy-2*vx)-2);
}

void TestEval::eval_components02() {
	Dim d=Dim::matrix(3,3);
	const ExprSymbol&amp; x = ExprSymbol::new_(&quot;x&quot;,Dim::col_vec(2));
	const ExprSymbol&amp; y = ExprSymbol::new_(&quot;y&quot;,d);
	const ExprSymbol&amp; z = ExprSymbol::new_(&quot;z&quot;,d);

	Function f(x,y,z,Return(x[1],transpose(y[DoubleIndex::one_row(d,1)]),z[DoubleIndex::one_col(d,2)]));

	IntervalVector box(20);
	for (int i=0; i&lt;20; i++) box[i]=Interval(i,i);

	BitSet components=BitSet::empty(9);
	components.add(0);
	components.add(2);
	components.add(4);
	components.add(6);
	IntervalVector res=f.eval_vector(box,components);

	CPPUNIT_ASSERT(res.size()==4);
	CPPUNIT_ASSERT(res[0]==1);
	CPPUNIT_ASSERT(res[1]==6);
	CPPUNIT_ASSERT(res[2]==13);
	CPPUNIT_ASSERT(res[3]==19);
}

void TestEval::matrix_components() {
	const ExprSymbol&amp; x = ExprSymbol::new_();
	Function f(x,Return(
			Return(x  ,x+1,x+2,ExprVector::ROW),
			Return(x+3,x+4,x+5,ExprVector::ROW),
			Return(x+6,x+7,x+8,ExprVector::ROW),
			ExprVector::COL));

	double _M1[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8 };

	CPPUNIT_ASSERT(f.eval_matrix(IntervalVector(1,Interval::ZERO)) == Matrix(3,3,_M1));

	ExprSubNodes nodes(f.expr());

	const ExprVector&amp; vec = (const ExprVector&amp;) f.expr();
	int rank_row_1=nodes.rank(vec.arg(1));
	double _row1[] = { 3, 4, 5 };
	Vector row1(3,_row1);
	CPPUNIT_ASSERT(f.basic_evaluator().d[rank_row_1].v()==row1);

	// perform another evaluation
	double _M2[] = { 9, 10, 11, 15, 16, 17 };
	BitSet bitset(3);
	bitset.add(0);
	bitset.add(2);
	CPPUNIT_ASSERT(f.eval_matrix(IntervalVector(1,Interval(9,9)),bitset) == Matrix(2,3,_M2));

	// check that the 1st row in the evaluator hasn't changed
	CPPUNIT_ASSERT(f.basic_evaluator().d[rank_row_1].v()==row1);
}

} // end namespace
</PRE>
</div>
  </div>
</body>
</html>
