
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 71, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-hash_12.h</h3>
            <pre><code>1  #ifndef ABSL_HASH_INTERNAL_HASH_H_
2  #define ABSL_HASH_INTERNAL_HASH_H_
3  #include <algorithm>
4  #include <array>
5  #include <bitset>
6  #include <cmath>
7  #include <cstddef>
8  #include <cstring>
9  #include <deque>
10  #include <forward_list>
11  #include <functional>
12  #include <iterator>
13  #include <limits>
14  #include <list>
15  #include <map>
16  #include <memory>
17  #include <set>
18  #include <string>
19  #include <tuple>
20  #include <type_traits>
21  #include <unordered_map>
22  #include <unordered_set>
23  #include <utility>
24  #include <vector>
25  #include "absl/base/config.h"
26  #include "absl/base/internal/unaligned_access.h"
27  #include "absl/base/port.h"
28  #include "absl/container/fixed_array.h"
29  #include "absl/hash/internal/city.h"
30  #include "absl/hash/internal/low_level_hash.h"
31  #include "absl/meta/type_traits.h"
32  #include "absl/numeric/bits.h"
33  #include "absl/numeric/int128.h"
34  #include "absl/strings/string_view.h"
35  #include "absl/types/optional.h"
36  #include "absl/types/variant.h"
37  #include "absl/utility/utility.h"
38  #ifdef ABSL_HAVE_STD_STRING_VIEW
39  #include <string_view>
40  #endif
41  namespace absl {
42  ABSL_NAMESPACE_BEGIN
43  class HashState;
44  namespace hash_internal {
45  constexpr size_t PiecewiseChunkSize() { return 1024; }
46  class PiecewiseCombiner {
47   public:
48    PiecewiseCombiner() : position_(0) {}
49    PiecewiseCombiner(const PiecewiseCombiner&) = delete;
50    PiecewiseCombiner& operator=(const PiecewiseCombiner&) = delete;
51    template <typename H>
52    H add_buffer(H state, const unsigned char* data, size_t size);
53    template <typename H>
54    H add_buffer(H state, const char* data, size_t size) {
55      return add_buffer(std::move(state),
56                        reinterpret_cast<const unsigned char*>(data), size);
57    }
58    template <typename H>
59    H finalize(H state);
60   private:
61    unsigned char buf_[PiecewiseChunkSize()];
62    size_t position_;
63  };
64  template <typename T>
65  struct is_hashable;
66  template <typename H>
67  class HashStateBase {
68   public:
69    template <typename T, typename... Ts>
70    static H combine(H state, const T& value, const Ts&... values);
71    static H combine(H state) { return state; }
72    template <typename T>
73    static H combine_contiguous(H state, const T* data, size_t size);
74    template <typename I>
75    static H combine_unordered(H state, I begin, I end);
76    using AbslInternalPiecewiseCombiner = PiecewiseCombiner;
77    template <typename T>
78    using is_hashable = absl::hash_internal::is_hashable<T>;
79   private:
80    template <typename I>
81    struct CombineUnorderedCallback {
82      I begin;
83      I end;
84      template <typename InnerH, typename ElementStateConsumer>
85      void operator()(InnerH inner_state, ElementStateConsumer cb) {
86        for (; begin != end; ++begin) {
87          inner_state = H::combine(std::move(inner_state), *begin);
88          cb(inner_state);
89        }
90      }
91    };
92  };
93  template <typename T, typename Enable = void>
94  struct is_uniquely_represented : std::false_type {};
95  template <>
96  struct is_uniquely_represented<unsigned char> : std::true_type {};
97  template <typename Integral>
98  struct is_uniquely_represented<
99      Integral, typename std::enable_if<std::is_integral<Integral>::value>::type>
100      : std::true_type {};
101  template <>
102  struct is_uniquely_represented<bool> : std::false_type {};
103  template <typename H, typename T>
104  H hash_bytes(H hash_state, const T& value) {
105    const unsigned char* start = reinterpret_cast<const unsigned char*>(&value);
106    return H::combine_contiguous(std::move(hash_state), start, sizeof(value));
107  }
108  template <typename H, typename B>
109  typename std::enable_if<std::is_same<B, bool>::value, H>::type AbslHashValue(
110      H hash_state, B value) {
111    return H::combine(std::move(hash_state),
112                      static_cast<unsigned char>(value ? 1 : 0));
113  }
114  template <typename H, typename Enum>
115  typename std::enable_if<std::is_enum<Enum>::value, H>::type AbslHashValue(
116      H hash_state, Enum e) {
117    return H::combine(std::move(hash_state),
118                      static_cast<typename std::underlying_type<Enum>::type>(e));
119  }
120  template <typename H, typename Float>
121  typename std::enable_if<std::is_same<Float, float>::value ||
122                              std::is_same<Float, double>::value,
123                          H>::type
124  AbslHashValue(H hash_state, Float value) {
125    return hash_internal::hash_bytes(std::move(hash_state),
126                                     value == 0 ? 0 : value);
127  }
128  template <typename H, typename LongDouble>
129  typename std::enable_if<std::is_same<LongDouble, long double>::value, H>::type
130  AbslHashValue(H hash_state, LongDouble value) {
131    const int category = std::fpclassify(value);
132    switch (category) {
133      case FP_INFINITE:
134        hash_state = H::combine(std::move(hash_state), std::signbit(value));
135        break;
136      case FP_NAN:
137      case FP_ZERO:
138      default:
139        break;
140      case FP_NORMAL:
141      case FP_SUBNORMAL:
142        int exp;
143        auto mantissa = static_cast<double>(std::frexp(value, &exp));
144        hash_state = H::combine(std::move(hash_state), mantissa, exp);
145    }
146    return H::combine(std::move(hash_state), category);
147  }
148  template <typename H, typename T>
149  H AbslHashValue(H hash_state, T* ptr) {
150    auto v = reinterpret_cast<uintptr_t>(ptr);
151    return H::combine(std::move(hash_state), v, v);
152  }
153  template <typename H>
154  H AbslHashValue(H hash_state, std::nullptr_t) {
155    return H::combine(std::move(hash_state), static_cast<void*>(nullptr));
156  }
157  template <typename H, typename T, typename C>
158  H AbslHashValue(H hash_state, T C::*ptr) {
159    auto salient_ptm_size = [](std::size_t n) -> std::size_t {
160  #if defined(_MSC_VER)
161      if (alignof(T C::*) == alignof(int)) {
162        return n;
163      } else {
164        return n == 24 ? 20 : n == 16 ? 12 : n;
165      }
166  #else
167  #ifdef __cpp_lib_has_unique_object_representations
168      static_assert(std::has_unique_object_representations<T C::*>::value);
169  #endif  
170      return n;
171  #endif
172    };
173    return H::combine_contiguous(std::move(hash_state),
174                                 reinterpret_cast<unsigned char*>(&ptr),
175                                 salient_ptm_size(sizeof ptr));
176  }
177  template <typename H, typename T1, typename T2>
178  typename std::enable_if<is_hashable<T1>::value && is_hashable<T2>::value,
179                          H>::type
180  AbslHashValue(H hash_state, const std::pair<T1, T2>& p) {
181    return H::combine(std::move(hash_state), p.first, p.second);
182  }
183  template <typename H, typename Tuple, size_t... Is>
184  H hash_tuple(H hash_state, const Tuple& t, absl::index_sequence<Is...>) {
185    return H::combine(std::move(hash_state), std::get<Is>(t)...);
186  }
187  template <typename H, typename... Ts>
188  #if defined(_MSC_VER)
189  H
190  #else   
191  typename std::enable_if<absl::conjunction<is_hashable<Ts>...>::value, H>::type
192  #endif  
193  AbslHashValue(H hash_state, const std::tuple<Ts...>& t) {
194    return hash_internal::hash_tuple(std::move(hash_state), t,
195                                     absl::make_index_sequence<sizeof...(Ts)>());
196  }
197  template <typename H, typename T, typename D>
198  H AbslHashValue(H hash_state, const std::unique_ptr<T, D>& ptr) {
199    return H::combine(std::move(hash_state), ptr.get());
200  }
201  template <typename H, typename T>
202  H AbslHashValue(H hash_state, const std::shared_ptr<T>& ptr) {
203    return H::combine(std::move(hash_state), ptr.get());
204  }
205  template <typename H>
206  H AbslHashValue(H hash_state, absl::string_view str) {
207    return H::combine(
208        H::combine_contiguous(std::move(hash_state), str.data(), str.size()),
209        str.size());
210  }
211  template <typename Char, typename Alloc, typename H,
212            typename = absl::enable_if_t<std::is_same<Char, wchar_t>::value ||
213                                         std::is_same<Char, char16_t>::value ||
214                                         std::is_same<Char, char32_t>::value>>
215  H AbslHashValue(
216      H hash_state,
217      const std::basic_string<Char, std::char_traits<Char>, Alloc>& str) {
218    return H::combine(
219        H::combine_contiguous(std::move(hash_state), str.data(), str.size()),
220        str.size());
221  }
222  #ifdef ABSL_HAVE_STD_STRING_VIEW
223  template <typename Char, typename H,
224            typename = absl::enable_if_t<std::is_same<Char, wchar_t>::value ||
225                                         std::is_same<Char, char16_t>::value ||
226                                         std::is_same<Char, char32_t>::value>>
227  H AbslHashValue(H hash_state, std::basic_string_view<Char> str) {
228    return H::combine(
229        H::combine_contiguous(std::move(hash_state), str.data(), str.size()),
230        str.size());
231  }
232  #endif  
233  template <typename H, typename T, size_t N>
234  typename std::enable_if<is_hashable<T>::value, H>::type AbslHashValue(
235      H hash_state, const std::array<T, N>& array) {
236    return H::combine_contiguous(std::move(hash_state), array.data(),
237                                 array.size());
238  }
239  template <typename H, typename T, typename Allocator>
240  typename std::enable_if<is_hashable<T>::value, H>::type AbslHashValue(
241      H hash_state, const std::deque<T, Allocator>& deque) {
242    for (const auto& t : deque) {
243      hash_state = H::combine(std::move(hash_state), t);
244    }
245    return H::combine(std::move(hash_state), deque.size());
246  }
247  template <typename H, typename T, typename Allocator>
248  typename std::enable_if<is_hashable<T>::value, H>::type AbslHashValue(
249      H hash_state, const std::forward_list<T, Allocator>& list) {
250    size_t size = 0;
251    for (const T& t : list) {
252      hash_state = H::combine(std::move(hash_state), t);
253      ++size;
254    }
255    return H::combine(std::move(hash_state), size);
256  }
257  template <typename H, typename T, typename Allocator>
258  typename std::enable_if<is_hashable<T>::value, H>::type AbslHashValue(
259      H hash_state, const std::list<T, Allocator>& list) {
260    for (const auto& t : list) {
261      hash_state = H::combine(std::move(hash_state), t);
262    }
263    return H::combine(std::move(hash_state), list.size());
264  }
265  template <typename H, typename T, typename Allocator>
266  typename std::enable_if<is_hashable<T>::value && !std::is_same<T, bool>::value,
267                          H>::type
268  AbslHashValue(H hash_state, const std::vector<T, Allocator>& vector) {
269    return H::combine(H::combine_contiguous(std::move(hash_state), vector.data(),
270                                            vector.size()),
271                      vector.size());
272  }
273  #if defined(ABSL_IS_BIG_ENDIAN) && \
274      (defined(__GLIBCXX__) || defined(__GLIBCPP__))
275  template <typename H, typename T, typename Allocator>
276  typename std::enable_if<is_hashable<T>::value && std::is_same<T, bool>::value,
277                          H>::type
278  AbslHashValue(H hash_state, const std::vector<T, Allocator>& vector) {
279    typename H::AbslInternalPiecewiseCombiner combiner;
280    for (const auto& i : vector) {
281      unsigned char c = static_cast<unsigned char>(i);
282      hash_state = combiner.add_buffer(std::move(hash_state), &c, sizeof(c));
283    }
284    return H::combine(combiner.finalize(std::move(hash_state)), vector.size());
285  }
286  #else
287  template <typename H, typename T, typename Allocator>
288  typename std::enable_if<is_hashable<T>::value && std::is_same<T, bool>::value,
289                          H>::type
290  AbslHashValue(H hash_state, const std::vector<T, Allocator>& vector) {
291    return H::combine(std::move(hash_state),
292                      std::hash<std::vector<T, Allocator>>{}(vector),
293                      vector.size());
294  }
295  #endif
296  template <typename H, typename Key, typename T, typename Compare,
297            typename Allocator>
298  typename std::enable_if<is_hashable<Key>::value && is_hashable<T>::value,
299                          H>::type
300  AbslHashValue(H hash_state, const std::map<Key, T, Compare, Allocator>& map) {
301    for (const auto& t : map) {
302      hash_state = H::combine(std::move(hash_state), t);
303    }
304    return H::combine(std::move(hash_state), map.size());
305  }
306  template <typename H, typename Key, typename T, typename Compare,
307            typename Allocator>
308  typename std::enable_if<is_hashable<Key>::value && is_hashable<T>::value,
309                          H>::type
310  AbslHashValue(H hash_state,
311                const std::multimap<Key, T, Compare, Allocator>& map) {
312    for (const auto& t : map) {
313      hash_state = H::combine(std::move(hash_state), t);
314    }
315    return H::combine(std::move(hash_state), map.size());
316  }
317  template <typename H, typename Key, typename Compare, typename Allocator>
318  typename std::enable_if<is_hashable<Key>::value, H>::type AbslHashValue(
319      H hash_state, const std::set<Key, Compare, Allocator>& set) {
320    for (const auto& t : set) {
321      hash_state = H::combine(std::move(hash_state), t);
322    }
323    return H::combine(std::move(hash_state), set.size());
324  }
325  template <typename H, typename Key, typename Compare, typename Allocator>
326  typename std::enable_if<is_hashable<Key>::value, H>::type AbslHashValue(
327      H hash_state, const std::multiset<Key, Compare, Allocator>& set) {
328    for (const auto& t : set) {
329      hash_state = H::combine(std::move(hash_state), t);
330    }
331    return H::combine(std::move(hash_state), set.size());
332  }
333  template <typename H, typename Key, typename Hash, typename KeyEqual,
334            typename Alloc>
335  typename std::enable_if<is_hashable<Key>::value, H>::type AbslHashValue(
<span onclick='openModal()' class='match'>336      H hash_state, const std::unordered_set<Key, Hash, KeyEqual, Alloc>& s) {
337    return H::combine(
338        H::combine_unordered(std::move(hash_state), s.begin(), s.end()),
339        s.size());
340  }
341  template <typename H, typename Key, typename Hash, typename KeyEqual,
342            typename Alloc>
</span>343  typename std::enable_if<is_hashable<Key>::value, H>::type AbslHashValue(
344      H hash_state,
345      const std::unordered_multiset<Key, Hash, KeyEqual, Alloc>& s) {
346    return H::combine(
347        H::combine_unordered(std::move(hash_state), s.begin(), s.end()),
348        s.size());
349  }
350  template <typename H, typename Key, typename T, typename Hash,
351            typename KeyEqual, typename Alloc>
352  typename std::enable_if<is_hashable<Key>::value && is_hashable<T>::value,
353                          H>::type
354  AbslHashValue(H hash_state,
355                const std::unordered_map<Key, T, Hash, KeyEqual, Alloc>& s) {
356    return H::combine(
357        H::combine_unordered(std::move(hash_state), s.begin(), s.end()),
358        s.size());
359  }
360  template <typename H, typename Key, typename T, typename Hash,
361            typename KeyEqual, typename Alloc>
362  typename std::enable_if<is_hashable<Key>::value && is_hashable<T>::value,
363                          H>::type
364  AbslHashValue(H hash_state,
365                const std::unordered_multimap<Key, T, Hash, KeyEqual, Alloc>& s) {
366    return H::combine(
367        H::combine_unordered(std::move(hash_state), s.begin(), s.end()),
368        s.size());
369  }
370  template <typename H, typename T>
371  typename std::enable_if<is_hashable<T>::value, H>::type AbslHashValue(
372      H hash_state, std::reference_wrapper<T> opt) {
373    return H::combine(std::move(hash_state), opt.get());
374  }
375  template <typename H, typename T>
376  typename std::enable_if<is_hashable<T>::value, H>::type AbslHashValue(
377      H hash_state, const absl::optional<T>& opt) {
378    if (opt) hash_state = H::combine(std::move(hash_state), *opt);
379    return H::combine(std::move(hash_state), opt.has_value());
380  }
381  template <typename H>
382  struct VariantVisitor {
383    H&& hash_state;
384    template <typename T>
385    H operator()(const T& t) const {
386      return H::combine(std::move(hash_state), t);
387    }
388  };
389  template <typename H, typename... T>
390  typename std::enable_if<conjunction<is_hashable<T>...>::value, H>::type
391  AbslHashValue(H hash_state, const absl::variant<T...>& v) {
392    if (!v.valueless_by_exception()) {
393      hash_state = absl::visit(VariantVisitor<H>{std::move(hash_state)}, v);
394    }
395    return H::combine(std::move(hash_state), v.index());
396  }
397  #if defined(ABSL_IS_BIG_ENDIAN) && \
398      (defined(__GLIBCXX__) || defined(__GLIBCPP__))
399  template <typename H, size_t N>
400  H AbslHashValue(H hash_state, const std::bitset<N>& set) {
401    typename H::AbslInternalPiecewiseCombiner combiner;
402    for (int i = 0; i < N; i++) {
403      unsigned char c = static_cast<unsigned char>(set[i]);
404      hash_state = combiner.add_buffer(std::move(hash_state), &c, sizeof(c));
405    }
406    return H::combine(combiner.finalize(std::move(hash_state)), N);
407  }
408  #endif
409  template <typename H, typename T>
410  typename std::enable_if<is_uniquely_represented<T>::value, H>::type
411  hash_range_or_bytes(H hash_state, const T* data, size_t size) {
412    const auto* bytes = reinterpret_cast<const unsigned char*>(data);
413    return H::combine_contiguous(std::move(hash_state), bytes, sizeof(T) * size);
414  }
415  template <typename H, typename T>
416  typename std::enable_if<!is_uniquely_represented<T>::value, H>::type
417  hash_range_or_bytes(H hash_state, const T* data, size_t size) {
418    for (const auto end = data + size; data < end; ++data) {
419      hash_state = H::combine(std::move(hash_state), *data);
420    }
421    return hash_state;
422  }
423  #if defined(ABSL_INTERNAL_LEGACY_HASH_NAMESPACE) && \
424      ABSL_META_INTERNAL_STD_HASH_SFINAE_FRIENDLY_
425  #define ABSL_HASH_INTERNAL_SUPPORT_LEGACY_HASH_ 1
426  #else
427  #define ABSL_HASH_INTERNAL_SUPPORT_LEGACY_HASH_ 0
428  #endif
429  struct HashSelect {
430   private:
431    struct State : HashStateBase<State> {
432      static State combine_contiguous(State hash_state, const unsigned char*,
433                                      size_t);
434      using State::HashStateBase::combine_contiguous;
435    };
436    struct UniquelyRepresentedProbe {
437      template <typename H, typename T>
438      static auto Invoke(H state, const T& value)
439          -> absl::enable_if_t<is_uniquely_represented<T>::value, H> {
440        return hash_internal::hash_bytes(std::move(state), value);
441      }
442    };
443    struct HashValueProbe {
444      template <typename H, typename T>
445      static auto Invoke(H state, const T& value) -> absl::enable_if_t<
446          std::is_same<H,
447                       decltype(AbslHashValue(std::move(state), value))>::value,
448          H> {
449        return AbslHashValue(std::move(state), value);
450      }
451    };
452    struct LegacyHashProbe {
453  #if ABSL_HASH_INTERNAL_SUPPORT_LEGACY_HASH_
454      template <typename H, typename T>
455      static auto Invoke(H state, const T& value) -> absl::enable_if_t<
456          std::is_convertible<
457              decltype(ABSL_INTERNAL_LEGACY_HASH_NAMESPACE::hash<T>()(value)),
458              size_t>::value,
459          H> {
460        return hash_internal::hash_bytes(
461            std::move(state),
462            ABSL_INTERNAL_LEGACY_HASH_NAMESPACE::hash<T>{}(value));
463      }
464  #endif  
465    };
466    struct StdHashProbe {
467      template <typename H, typename T>
468      static auto Invoke(H state, const T& value)
469          -> absl::enable_if_t<type_traits_internal::IsHashable<T>::value, H> {
470        return hash_internal::hash_bytes(std::move(state), std::hash<T>{}(value));
471      }
472    };
473    template <typename Hash, typename T>
474    struct Probe : Hash {
475     private:
476      template <typename H, typename = decltype(H::Invoke(
477                                std::declval<State>(), std::declval<const T&>()))>
478      static std::true_type Test(int);
479      template <typename U>
480      static std::false_type Test(char);
481     public:
482      static constexpr bool value = decltype(Test<Hash>(0))::value;
483    };
484   public:
485    template <typename T>
486    using Apply = absl::disjunction<         
487        Probe<UniquelyRepresentedProbe, T>,  
488        Probe<HashValueProbe, T>,            
489        Probe<LegacyHashProbe, T>,           
490        Probe<StdHashProbe, T>,              
491        std::false_type>;
492  };
493  template <typename T>
494  struct is_hashable
495      : std::integral_constant<bool, HashSelect::template Apply<T>::value> {};
496  class ABSL_DLL MixingHashState : public HashStateBase<MixingHashState> {
497  #ifdef ABSL_HAVE_INTRINSIC_INT128
498    using uint128 = __uint128_t;
499  #else   
500    using uint128 = absl::uint128;
501  #endif  
502    static constexpr uint64_t kMul =
503    sizeof(size_t) == 4 ? uint64_t{0xcc9e2d51}
504                        : uint64_t{0x9ddfea08eb382d69};
505    template <typename T>
506    using IntegralFastPath =
507        conjunction<std::is_integral<T>, is_uniquely_represented<T>>;
508   public:
509    MixingHashState(MixingHashState&&) = default;
510    MixingHashState& operator=(MixingHashState&&) = default;
511    static MixingHashState combine_contiguous(MixingHashState hash_state,
512                                              const unsigned char* first,
513                                              size_t size) {
514      return MixingHashState(
515          CombineContiguousImpl(hash_state.state_, first, size,
516                                std::integral_constant<int, sizeof(size_t)>{}));
517    }
518    using MixingHashState::HashStateBase::combine_contiguous;
519    template <typename T, absl::enable_if_t<IntegralFastPath<T>::value, int> = 0>
520    static size_t hash(T value) {
521      return static_cast<size_t>(
522          Mix(Seed(), static_cast<std::make_unsigned_t<T>>(value)));
523    }
524    template <typename T, absl::enable_if_t<!IntegralFastPath<T>::value, int> = 0>
525    static size_t hash(const T& value) {
526      return static_cast<size_t>(combine(MixingHashState{}, value).state_);
527    }
528   private:
529    MixingHashState() : state_(Seed()) {}
530    friend class MixingHashState::HashStateBase;
531    template <typename CombinerT>
532    static MixingHashState RunCombineUnordered(MixingHashState state,
533                                               CombinerT combiner) {
534      uint64_t unordered_state = 0;
535      combiner(MixingHashState{}, [&](MixingHashState& inner_state) {
536        auto element_state = inner_state.state_;
537        unordered_state += element_state;
538        if (unordered_state < element_state) {
539          ++unordered_state;
540        }
541        inner_state = MixingHashState{};
542      });
543      return MixingHashState::combine(std::move(state), unordered_state);
544    }
545    friend class absl::HashState;
546    MixingHashState(const MixingHashState&) = default;
547    explicit MixingHashState(uint64_t state) : state_(state) {}
548    static uint64_t CombineContiguousImpl(uint64_t state,
549                                          const unsigned char* first, size_t len,
550                                          std::integral_constant<int, 4>
551                                          );
552    static uint64_t CombineContiguousImpl(uint64_t state,
553                                          const unsigned char* first, size_t len,
554                                          std::integral_constant<int, 8>
555                                          );
556    static uint64_t CombineLargeContiguousImpl32(uint64_t state,
557                                                 const unsigned char* first,
558                                                 size_t len);
559    static uint64_t CombineLargeContiguousImpl64(uint64_t state,
560                                                 const unsigned char* first,
561                                                 size_t len);
562    static std::pair<uint64_t, uint64_t> Read9To16(const unsigned char* p,
563                                                   size_t len) {
564      uint64_t low_mem = absl::base_internal::UnalignedLoad64(p);
565      uint64_t high_mem = absl::base_internal::UnalignedLoad64(p + len - 8);
566  #ifdef ABSL_IS_LITTLE_ENDIAN
567      uint64_t most_significant = high_mem;
568      uint64_t least_significant = low_mem;
569  #else
570      uint64_t most_significant = low_mem;
571      uint64_t least_significant = high_mem;
572  #endif
573      return {least_significant, most_significant};
574    }
575    static uint64_t Read4To8(const unsigned char* p, size_t len) {
576      uint32_t low_mem = absl::base_internal::UnalignedLoad32(p);
577      uint32_t high_mem = absl::base_internal::UnalignedLoad32(p + len - 4);
578  #ifdef ABSL_IS_LITTLE_ENDIAN
579      uint32_t most_significant = high_mem;
580      uint32_t least_significant = low_mem;
581  #else
582      uint32_t most_significant = low_mem;
583      uint32_t least_significant = high_mem;
584  #endif
585      return (static_cast<uint64_t>(most_significant) << (len - 4) * 8) |
586             least_significant;
587    }
588    static uint32_t Read1To3(const unsigned char* p, size_t len) {
589      unsigned char mem0 = p[0];
590      unsigned char mem1 = p[len / 2];
591      unsigned char mem2 = p[len - 1];
592  #ifdef ABSL_IS_LITTLE_ENDIAN
593      unsigned char significant2 = mem2;
594      unsigned char significant1 = mem1;
595      unsigned char significant0 = mem0;
596  #else
597      unsigned char significant2 = mem0;
598      unsigned char significant1 = len == 2 ? mem0 : mem1;
599      unsigned char significant0 = mem2;
600  #endif
601      return static_cast<uint32_t>(significant0 |                     
602                                   (significant1 << (len / 2 * 8)) |  
603                                   (significant2 << ((len - 1) * 8)));
604    }
605    ABSL_ATTRIBUTE_ALWAYS_INLINE static uint64_t Mix(uint64_t state, uint64_t v) {
606      using MultType =
607          absl::conditional_t<sizeof(size_t) == 4, uint64_t, uint128>;
608      MultType m = state + v;
609      m *= kMul;
610      return static_cast<uint64_t>(m ^ (m >> (sizeof(m) * 8 / 2)));
611    }
612    static uint64_t LowLevelHashImpl(const unsigned char* data, size_t len);
613    ABSL_ATTRIBUTE_ALWAYS_INLINE static uint64_t Hash64(const unsigned char* data,
614                                                        size_t len) {
615  #ifdef ABSL_HAVE_INTRINSIC_INT128
616      return LowLevelHashImpl(data, len);
617  #else
618      return hash_internal::CityHash64(reinterpret_cast<const char*>(data), len);
619  #endif
620    }
621    ABSL_ATTRIBUTE_ALWAYS_INLINE static uint64_t Seed() {
622  #if (!defined(__clang__) || __clang_major__ > 11) && \
623      (!defined(__apple_build_version__) ||            \
624       __apple_build_version__ >= 19558921)  
625      return static_cast<uint64_t>(reinterpret_cast<uintptr_t>(&kSeed));
626  #else
627      return static_cast<uint64_t>(reinterpret_cast<uintptr_t>(kSeed));
628  #endif
629    }
630    static const void* const kSeed;
631    uint64_t state_;
632  };
633  inline uint64_t MixingHashState::CombineContiguousImpl(
634      uint64_t state, const unsigned char* first, size_t len,
635      std::integral_constant<int, 4> &bsol;* sizeof_size_t */) {
636    uint64_t v;
637    if (len > 8) {
638      if (ABSL_PREDICT_FALSE(len > PiecewiseChunkSize())) {
639        return CombineLargeContiguousImpl32(state, first, len);
640      }
641      v = hash_internal::CityHash32(reinterpret_cast<const char*>(first), len);
642    } else if (len >= 4) {
643      v = Read4To8(first, len);
644    } else if (len > 0) {
645      v = Read1To3(first, len);
646    } else {
647      return state;
648    }
649    return Mix(state, v);
650  }
651  inline uint64_t MixingHashState::CombineContiguousImpl(
652      uint64_t state, const unsigned char* first, size_t len,
653      std::integral_constant<int, 8> &bsol;* sizeof_size_t */) {
654    uint64_t v;
655    if (len > 16) {
656      if (ABSL_PREDICT_FALSE(len > PiecewiseChunkSize())) {
657        return CombineLargeContiguousImpl64(state, first, len);
658      }
659      v = Hash64(first, len);
660    } else if (len > 8) {
661      auto p = Read9To16(first, len);
662      uint64_t lo = p.first;
663      uint64_t hi = p.second;
664      lo = absl::rotr(lo, 53);
665      state += kMul;
666      lo += state;
667      state ^= hi;
668      uint128 m = state;
669      m *= lo;
670      return static_cast<uint64_t>(m ^ (m >> 64));
671    } else if (len >= 4) {
672      v = Read4To8(first, len);
673    } else if (len > 0) {
674      v = Read1To3(first, len);
675    } else {
676      return state;
677    }
678    return Mix(state, v);
679  }
680  struct AggregateBarrier {};
681  struct PoisonedHash : private AggregateBarrier {
682    PoisonedHash() = delete;
683    PoisonedHash(const PoisonedHash&) = delete;
684    PoisonedHash& operator=(const PoisonedHash&) = delete;
685  };
686  template <typename T>
687  struct HashImpl {
688    size_t operator()(const T& value) const {
689      return MixingHashState::hash(value);
690    }
691  };
692  template <typename T>
693  struct Hash
694      : absl::conditional_t<is_hashable<T>::value, HashImpl<T>, PoisonedHash> {};
695  template <typename H>
696  template <typename T, typename... Ts>
697  H HashStateBase<H>::combine(H state, const T& value, const Ts&... values) {
698    return H::combine(hash_internal::HashSelect::template Apply<T>::Invoke(
699                          std::move(state), value),
700                      values...);
701  }
702  template <typename H>
703  template <typename T>
704  H HashStateBase<H>::combine_contiguous(H state, const T* data, size_t size) {
705    return hash_internal::hash_range_or_bytes(std::move(state), data, size);
706  }
707  template <typename H>
708  template <typename I>
709  H HashStateBase<H>::combine_unordered(H state, I begin, I end) {
710    return H::RunCombineUnordered(std::move(state),
711                                  CombineUnorderedCallback<I>{begin, end});
712  }
713  template <typename H>
714  H PiecewiseCombiner::add_buffer(H state, const unsigned char* data,
715                                  size_t size) {
716    if (position_ + size < PiecewiseChunkSize()) {
717      memcpy(buf_ + position_, data, size);
718      position_ += size;
719      return state;
720    }
721    if (position_ != 0) {
722      const size_t bytes_needed = PiecewiseChunkSize() - position_;
723      memcpy(buf_ + position_, data, bytes_needed);
724      state = H::combine_contiguous(std::move(state), buf_, PiecewiseChunkSize());
725      data += bytes_needed;
726      size -= bytes_needed;
727    }
728    while (size >= PiecewiseChunkSize()) {
729      state = H::combine_contiguous(std::move(state), data, PiecewiseChunkSize());
730      data += PiecewiseChunkSize();
731      size -= PiecewiseChunkSize();
732    }
733    memcpy(buf_, data, size);
734    position_ = size;
735    return state;
736  }
737  template <typename H>
738  H PiecewiseCombiner::finalize(H state) {
739    return H::combine_contiguous(std::move(state), buf_, position_);
740  }
741  }  
742  ABSL_NAMESPACE_END
743  }  
744  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-hash_12.h</h3>
            <pre><code>1  #ifndef ABSL_HASH_INTERNAL_HASH_H_
2  #define ABSL_HASH_INTERNAL_HASH_H_
3  #include <algorithm>
4  #include <array>
5  #include <bitset>
6  #include <cmath>
7  #include <cstddef>
8  #include <cstring>
9  #include <deque>
10  #include <forward_list>
11  #include <functional>
12  #include <iterator>
13  #include <limits>
14  #include <list>
15  #include <map>
16  #include <memory>
17  #include <set>
18  #include <string>
19  #include <tuple>
20  #include <type_traits>
21  #include <unordered_map>
22  #include <unordered_set>
23  #include <utility>
24  #include <vector>
25  #include "absl/base/config.h"
26  #include "absl/base/internal/unaligned_access.h"
27  #include "absl/base/port.h"
28  #include "absl/container/fixed_array.h"
29  #include "absl/hash/internal/city.h"
30  #include "absl/hash/internal/low_level_hash.h"
31  #include "absl/meta/type_traits.h"
32  #include "absl/numeric/bits.h"
33  #include "absl/numeric/int128.h"
34  #include "absl/strings/string_view.h"
35  #include "absl/types/optional.h"
36  #include "absl/types/variant.h"
37  #include "absl/utility/utility.h"
38  #ifdef ABSL_HAVE_STD_STRING_VIEW
39  #include <string_view>
40  #endif
41  namespace absl {
42  ABSL_NAMESPACE_BEGIN
43  class HashState;
44  namespace hash_internal {
45  constexpr size_t PiecewiseChunkSize() { return 1024; }
46  class PiecewiseCombiner {
47   public:
48    PiecewiseCombiner() : position_(0) {}
49    PiecewiseCombiner(const PiecewiseCombiner&) = delete;
50    PiecewiseCombiner& operator=(const PiecewiseCombiner&) = delete;
51    template <typename H>
52    H add_buffer(H state, const unsigned char* data, size_t size);
53    template <typename H>
54    H add_buffer(H state, const char* data, size_t size) {
55      return add_buffer(std::move(state),
56                        reinterpret_cast<const unsigned char*>(data), size);
57    }
58    template <typename H>
59    H finalize(H state);
60   private:
61    unsigned char buf_[PiecewiseChunkSize()];
62    size_t position_;
63  };
64  template <typename T>
65  struct is_hashable;
66  template <typename H>
67  class HashStateBase {
68   public:
69    template <typename T, typename... Ts>
70    static H combine(H state, const T& value, const Ts&... values);
71    static H combine(H state) { return state; }
72    template <typename T>
73    static H combine_contiguous(H state, const T* data, size_t size);
74    template <typename I>
75    static H combine_unordered(H state, I begin, I end);
76    using AbslInternalPiecewiseCombiner = PiecewiseCombiner;
77    template <typename T>
78    using is_hashable = absl::hash_internal::is_hashable<T>;
79   private:
80    template <typename I>
81    struct CombineUnorderedCallback {
82      I begin;
83      I end;
84      template <typename InnerH, typename ElementStateConsumer>
85      void operator()(InnerH inner_state, ElementStateConsumer cb) {
86        for (; begin != end; ++begin) {
87          inner_state = H::combine(std::move(inner_state), *begin);
88          cb(inner_state);
89        }
90      }
91    };
92  };
93  template <typename T, typename Enable = void>
94  struct is_uniquely_represented : std::false_type {};
95  template <>
96  struct is_uniquely_represented<unsigned char> : std::true_type {};
97  template <typename Integral>
98  struct is_uniquely_represented<
99      Integral, typename std::enable_if<std::is_integral<Integral>::value>::type>
100      : std::true_type {};
101  template <>
102  struct is_uniquely_represented<bool> : std::false_type {};
103  template <typename H, typename T>
104  H hash_bytes(H hash_state, const T& value) {
105    const unsigned char* start = reinterpret_cast<const unsigned char*>(&value);
106    return H::combine_contiguous(std::move(hash_state), start, sizeof(value));
107  }
108  template <typename H, typename B>
109  typename std::enable_if<std::is_same<B, bool>::value, H>::type AbslHashValue(
110      H hash_state, B value) {
111    return H::combine(std::move(hash_state),
112                      static_cast<unsigned char>(value ? 1 : 0));
113  }
114  template <typename H, typename Enum>
115  typename std::enable_if<std::is_enum<Enum>::value, H>::type AbslHashValue(
116      H hash_state, Enum e) {
117    return H::combine(std::move(hash_state),
118                      static_cast<typename std::underlying_type<Enum>::type>(e));
119  }
120  template <typename H, typename Float>
121  typename std::enable_if<std::is_same<Float, float>::value ||
122                              std::is_same<Float, double>::value,
123                          H>::type
124  AbslHashValue(H hash_state, Float value) {
125    return hash_internal::hash_bytes(std::move(hash_state),
126                                     value == 0 ? 0 : value);
127  }
128  template <typename H, typename LongDouble>
129  typename std::enable_if<std::is_same<LongDouble, long double>::value, H>::type
130  AbslHashValue(H hash_state, LongDouble value) {
131    const int category = std::fpclassify(value);
132    switch (category) {
133      case FP_INFINITE:
134        hash_state = H::combine(std::move(hash_state), std::signbit(value));
135        break;
136      case FP_NAN:
137      case FP_ZERO:
138      default:
139        break;
140      case FP_NORMAL:
141      case FP_SUBNORMAL:
142        int exp;
143        auto mantissa = static_cast<double>(std::frexp(value, &exp));
144        hash_state = H::combine(std::move(hash_state), mantissa, exp);
145    }
146    return H::combine(std::move(hash_state), category);
147  }
148  template <typename H, typename T>
149  H AbslHashValue(H hash_state, T* ptr) {
150    auto v = reinterpret_cast<uintptr_t>(ptr);
151    return H::combine(std::move(hash_state), v, v);
152  }
153  template <typename H>
154  H AbslHashValue(H hash_state, std::nullptr_t) {
155    return H::combine(std::move(hash_state), static_cast<void*>(nullptr));
156  }
157  template <typename H, typename T, typename C>
158  H AbslHashValue(H hash_state, T C::*ptr) {
159    auto salient_ptm_size = [](std::size_t n) -> std::size_t {
160  #if defined(_MSC_VER)
161      if (alignof(T C::*) == alignof(int)) {
162        return n;
163      } else {
164        return n == 24 ? 20 : n == 16 ? 12 : n;
165      }
166  #else
167  #ifdef __cpp_lib_has_unique_object_representations
168      static_assert(std::has_unique_object_representations<T C::*>::value);
169  #endif  
170      return n;
171  #endif
172    };
173    return H::combine_contiguous(std::move(hash_state),
174                                 reinterpret_cast<unsigned char*>(&ptr),
175                                 salient_ptm_size(sizeof ptr));
176  }
177  template <typename H, typename T1, typename T2>
178  typename std::enable_if<is_hashable<T1>::value && is_hashable<T2>::value,
179                          H>::type
180  AbslHashValue(H hash_state, const std::pair<T1, T2>& p) {
181    return H::combine(std::move(hash_state), p.first, p.second);
182  }
183  template <typename H, typename Tuple, size_t... Is>
184  H hash_tuple(H hash_state, const Tuple& t, absl::index_sequence<Is...>) {
185    return H::combine(std::move(hash_state), std::get<Is>(t)...);
186  }
187  template <typename H, typename... Ts>
188  #if defined(_MSC_VER)
189  H
190  #else   
191  typename std::enable_if<absl::conjunction<is_hashable<Ts>...>::value, H>::type
192  #endif  
193  AbslHashValue(H hash_state, const std::tuple<Ts...>& t) {
194    return hash_internal::hash_tuple(std::move(hash_state), t,
195                                     absl::make_index_sequence<sizeof...(Ts)>());
196  }
197  template <typename H, typename T, typename D>
198  H AbslHashValue(H hash_state, const std::unique_ptr<T, D>& ptr) {
199    return H::combine(std::move(hash_state), ptr.get());
200  }
201  template <typename H, typename T>
202  H AbslHashValue(H hash_state, const std::shared_ptr<T>& ptr) {
203    return H::combine(std::move(hash_state), ptr.get());
204  }
205  template <typename H>
206  H AbslHashValue(H hash_state, absl::string_view str) {
207    return H::combine(
208        H::combine_contiguous(std::move(hash_state), str.data(), str.size()),
209        str.size());
210  }
211  template <typename Char, typename Alloc, typename H,
212            typename = absl::enable_if_t<std::is_same<Char, wchar_t>::value ||
213                                         std::is_same<Char, char16_t>::value ||
214                                         std::is_same<Char, char32_t>::value>>
215  H AbslHashValue(
216      H hash_state,
217      const std::basic_string<Char, std::char_traits<Char>, Alloc>& str) {
218    return H::combine(
219        H::combine_contiguous(std::move(hash_state), str.data(), str.size()),
220        str.size());
221  }
222  #ifdef ABSL_HAVE_STD_STRING_VIEW
223  template <typename Char, typename H,
224            typename = absl::enable_if_t<std::is_same<Char, wchar_t>::value ||
225                                         std::is_same<Char, char16_t>::value ||
226                                         std::is_same<Char, char32_t>::value>>
227  H AbslHashValue(H hash_state, std::basic_string_view<Char> str) {
228    return H::combine(
229        H::combine_contiguous(std::move(hash_state), str.data(), str.size()),
230        str.size());
231  }
232  #endif  
233  template <typename H, typename T, size_t N>
234  typename std::enable_if<is_hashable<T>::value, H>::type AbslHashValue(
235      H hash_state, const std::array<T, N>& array) {
236    return H::combine_contiguous(std::move(hash_state), array.data(),
237                                 array.size());
238  }
239  template <typename H, typename T, typename Allocator>
240  typename std::enable_if<is_hashable<T>::value, H>::type AbslHashValue(
241      H hash_state, const std::deque<T, Allocator>& deque) {
242    for (const auto& t : deque) {
243      hash_state = H::combine(std::move(hash_state), t);
244    }
245    return H::combine(std::move(hash_state), deque.size());
246  }
247  template <typename H, typename T, typename Allocator>
248  typename std::enable_if<is_hashable<T>::value, H>::type AbslHashValue(
249      H hash_state, const std::forward_list<T, Allocator>& list) {
250    size_t size = 0;
251    for (const T& t : list) {
252      hash_state = H::combine(std::move(hash_state), t);
253      ++size;
254    }
255    return H::combine(std::move(hash_state), size);
256  }
257  template <typename H, typename T, typename Allocator>
258  typename std::enable_if<is_hashable<T>::value, H>::type AbslHashValue(
259      H hash_state, const std::list<T, Allocator>& list) {
260    for (const auto& t : list) {
261      hash_state = H::combine(std::move(hash_state), t);
262    }
263    return H::combine(std::move(hash_state), list.size());
264  }
265  template <typename H, typename T, typename Allocator>
266  typename std::enable_if<is_hashable<T>::value && !std::is_same<T, bool>::value,
267                          H>::type
268  AbslHashValue(H hash_state, const std::vector<T, Allocator>& vector) {
269    return H::combine(H::combine_contiguous(std::move(hash_state), vector.data(),
270                                            vector.size()),
271                      vector.size());
272  }
273  #if defined(ABSL_IS_BIG_ENDIAN) && \
274      (defined(__GLIBCXX__) || defined(__GLIBCPP__))
275  template <typename H, typename T, typename Allocator>
276  typename std::enable_if<is_hashable<T>::value && std::is_same<T, bool>::value,
277                          H>::type
278  AbslHashValue(H hash_state, const std::vector<T, Allocator>& vector) {
279    typename H::AbslInternalPiecewiseCombiner combiner;
280    for (const auto& i : vector) {
281      unsigned char c = static_cast<unsigned char>(i);
282      hash_state = combiner.add_buffer(std::move(hash_state), &c, sizeof(c));
283    }
284    return H::combine(combiner.finalize(std::move(hash_state)), vector.size());
285  }
286  #else
287  template <typename H, typename T, typename Allocator>
288  typename std::enable_if<is_hashable<T>::value && std::is_same<T, bool>::value,
289                          H>::type
290  AbslHashValue(H hash_state, const std::vector<T, Allocator>& vector) {
291    return H::combine(std::move(hash_state),
292                      std::hash<std::vector<T, Allocator>>{}(vector),
293                      vector.size());
294  }
295  #endif
296  template <typename H, typename Key, typename T, typename Compare,
297            typename Allocator>
298  typename std::enable_if<is_hashable<Key>::value && is_hashable<T>::value,
299                          H>::type
300  AbslHashValue(H hash_state, const std::map<Key, T, Compare, Allocator>& map) {
301    for (const auto& t : map) {
302      hash_state = H::combine(std::move(hash_state), t);
303    }
304    return H::combine(std::move(hash_state), map.size());
305  }
306  template <typename H, typename Key, typename T, typename Compare,
307            typename Allocator>
308  typename std::enable_if<is_hashable<Key>::value && is_hashable<T>::value,
309                          H>::type
310  AbslHashValue(H hash_state,
311                const std::multimap<Key, T, Compare, Allocator>& map) {
312    for (const auto& t : map) {
313      hash_state = H::combine(std::move(hash_state), t);
314    }
315    return H::combine(std::move(hash_state), map.size());
316  }
317  template <typename H, typename Key, typename Compare, typename Allocator>
318  typename std::enable_if<is_hashable<Key>::value, H>::type AbslHashValue(
319      H hash_state, const std::set<Key, Compare, Allocator>& set) {
320    for (const auto& t : set) {
321      hash_state = H::combine(std::move(hash_state), t);
322    }
323    return H::combine(std::move(hash_state), set.size());
324  }
325  template <typename H, typename Key, typename Compare, typename Allocator>
326  typename std::enable_if<is_hashable<Key>::value, H>::type AbslHashValue(
327      H hash_state, const std::multiset<Key, Compare, Allocator>& set) {
328    for (const auto& t : set) {
329      hash_state = H::combine(std::move(hash_state), t);
330    }
331    return H::combine(std::move(hash_state), set.size());
332  }
333  template <typename H, typename Key, typename Hash, typename KeyEqual,
334            typename Alloc>
335  typename std::enable_if<is_hashable<Key>::value, H>::type AbslHashValue(
336      H hash_state, const std::unordered_set<Key, Hash, KeyEqual, Alloc>& s) {
337    return H::combine(
338        H::combine_unordered(std::move(hash_state), s.begin(), s.end()),
339        s.size());
340  }
341  template <typename H, typename Key, typename Hash, typename KeyEqual,
342            typename Alloc>
343  typename std::enable_if<is_hashable<Key>::value, H>::type AbslHashValue(
<span onclick='openModal()' class='match'>344      H hash_state,
345      const std::unordered_multiset<Key, Hash, KeyEqual, Alloc>& s) {
346    return H::combine(
347        H::combine_unordered(std::move(hash_state), s.begin(), s.end()),
348        s.size());
349  }
350  template <typename H, typename Key, typename T, typename Hash,
351            typename KeyEqual, typename Alloc>
</span>352  typename std::enable_if<is_hashable<Key>::value && is_hashable<T>::value,
353                          H>::type
354  AbslHashValue(H hash_state,
355                const std::unordered_map<Key, T, Hash, KeyEqual, Alloc>& s) {
356    return H::combine(
357        H::combine_unordered(std::move(hash_state), s.begin(), s.end()),
358        s.size());
359  }
360  template <typename H, typename Key, typename T, typename Hash,
361            typename KeyEqual, typename Alloc>
362  typename std::enable_if<is_hashable<Key>::value && is_hashable<T>::value,
363                          H>::type
364  AbslHashValue(H hash_state,
365                const std::unordered_multimap<Key, T, Hash, KeyEqual, Alloc>& s) {
366    return H::combine(
367        H::combine_unordered(std::move(hash_state), s.begin(), s.end()),
368        s.size());
369  }
370  template <typename H, typename T>
371  typename std::enable_if<is_hashable<T>::value, H>::type AbslHashValue(
372      H hash_state, std::reference_wrapper<T> opt) {
373    return H::combine(std::move(hash_state), opt.get());
374  }
375  template <typename H, typename T>
376  typename std::enable_if<is_hashable<T>::value, H>::type AbslHashValue(
377      H hash_state, const absl::optional<T>& opt) {
378    if (opt) hash_state = H::combine(std::move(hash_state), *opt);
379    return H::combine(std::move(hash_state), opt.has_value());
380  }
381  template <typename H>
382  struct VariantVisitor {
383    H&& hash_state;
384    template <typename T>
385    H operator()(const T& t) const {
386      return H::combine(std::move(hash_state), t);
387    }
388  };
389  template <typename H, typename... T>
390  typename std::enable_if<conjunction<is_hashable<T>...>::value, H>::type
391  AbslHashValue(H hash_state, const absl::variant<T...>& v) {
392    if (!v.valueless_by_exception()) {
393      hash_state = absl::visit(VariantVisitor<H>{std::move(hash_state)}, v);
394    }
395    return H::combine(std::move(hash_state), v.index());
396  }
397  #if defined(ABSL_IS_BIG_ENDIAN) && \
398      (defined(__GLIBCXX__) || defined(__GLIBCPP__))
399  template <typename H, size_t N>
400  H AbslHashValue(H hash_state, const std::bitset<N>& set) {
401    typename H::AbslInternalPiecewiseCombiner combiner;
402    for (int i = 0; i < N; i++) {
403      unsigned char c = static_cast<unsigned char>(set[i]);
404      hash_state = combiner.add_buffer(std::move(hash_state), &c, sizeof(c));
405    }
406    return H::combine(combiner.finalize(std::move(hash_state)), N);
407  }
408  #endif
409  template <typename H, typename T>
410  typename std::enable_if<is_uniquely_represented<T>::value, H>::type
411  hash_range_or_bytes(H hash_state, const T* data, size_t size) {
412    const auto* bytes = reinterpret_cast<const unsigned char*>(data);
413    return H::combine_contiguous(std::move(hash_state), bytes, sizeof(T) * size);
414  }
415  template <typename H, typename T>
416  typename std::enable_if<!is_uniquely_represented<T>::value, H>::type
417  hash_range_or_bytes(H hash_state, const T* data, size_t size) {
418    for (const auto end = data + size; data < end; ++data) {
419      hash_state = H::combine(std::move(hash_state), *data);
420    }
421    return hash_state;
422  }
423  #if defined(ABSL_INTERNAL_LEGACY_HASH_NAMESPACE) && \
424      ABSL_META_INTERNAL_STD_HASH_SFINAE_FRIENDLY_
425  #define ABSL_HASH_INTERNAL_SUPPORT_LEGACY_HASH_ 1
426  #else
427  #define ABSL_HASH_INTERNAL_SUPPORT_LEGACY_HASH_ 0
428  #endif
429  struct HashSelect {
430   private:
431    struct State : HashStateBase<State> {
432      static State combine_contiguous(State hash_state, const unsigned char*,
433                                      size_t);
434      using State::HashStateBase::combine_contiguous;
435    };
436    struct UniquelyRepresentedProbe {
437      template <typename H, typename T>
438      static auto Invoke(H state, const T& value)
439          -> absl::enable_if_t<is_uniquely_represented<T>::value, H> {
440        return hash_internal::hash_bytes(std::move(state), value);
441      }
442    };
443    struct HashValueProbe {
444      template <typename H, typename T>
445      static auto Invoke(H state, const T& value) -> absl::enable_if_t<
446          std::is_same<H,
447                       decltype(AbslHashValue(std::move(state), value))>::value,
448          H> {
449        return AbslHashValue(std::move(state), value);
450      }
451    };
452    struct LegacyHashProbe {
453  #if ABSL_HASH_INTERNAL_SUPPORT_LEGACY_HASH_
454      template <typename H, typename T>
455      static auto Invoke(H state, const T& value) -> absl::enable_if_t<
456          std::is_convertible<
457              decltype(ABSL_INTERNAL_LEGACY_HASH_NAMESPACE::hash<T>()(value)),
458              size_t>::value,
459          H> {
460        return hash_internal::hash_bytes(
461            std::move(state),
462            ABSL_INTERNAL_LEGACY_HASH_NAMESPACE::hash<T>{}(value));
463      }
464  #endif  
465    };
466    struct StdHashProbe {
467      template <typename H, typename T>
468      static auto Invoke(H state, const T& value)
469          -> absl::enable_if_t<type_traits_internal::IsHashable<T>::value, H> {
470        return hash_internal::hash_bytes(std::move(state), std::hash<T>{}(value));
471      }
472    };
473    template <typename Hash, typename T>
474    struct Probe : Hash {
475     private:
476      template <typename H, typename = decltype(H::Invoke(
477                                std::declval<State>(), std::declval<const T&>()))>
478      static std::true_type Test(int);
479      template <typename U>
480      static std::false_type Test(char);
481     public:
482      static constexpr bool value = decltype(Test<Hash>(0))::value;
483    };
484   public:
485    template <typename T>
486    using Apply = absl::disjunction<         
487        Probe<UniquelyRepresentedProbe, T>,  
488        Probe<HashValueProbe, T>,            
489        Probe<LegacyHashProbe, T>,           
490        Probe<StdHashProbe, T>,              
491        std::false_type>;
492  };
493  template <typename T>
494  struct is_hashable
495      : std::integral_constant<bool, HashSelect::template Apply<T>::value> {};
496  class ABSL_DLL MixingHashState : public HashStateBase<MixingHashState> {
497  #ifdef ABSL_HAVE_INTRINSIC_INT128
498    using uint128 = __uint128_t;
499  #else   
500    using uint128 = absl::uint128;
501  #endif  
502    static constexpr uint64_t kMul =
503    sizeof(size_t) == 4 ? uint64_t{0xcc9e2d51}
504                        : uint64_t{0x9ddfea08eb382d69};
505    template <typename T>
506    using IntegralFastPath =
507        conjunction<std::is_integral<T>, is_uniquely_represented<T>>;
508   public:
509    MixingHashState(MixingHashState&&) = default;
510    MixingHashState& operator=(MixingHashState&&) = default;
511    static MixingHashState combine_contiguous(MixingHashState hash_state,
512                                              const unsigned char* first,
513                                              size_t size) {
514      return MixingHashState(
515          CombineContiguousImpl(hash_state.state_, first, size,
516                                std::integral_constant<int, sizeof(size_t)>{}));
517    }
518    using MixingHashState::HashStateBase::combine_contiguous;
519    template <typename T, absl::enable_if_t<IntegralFastPath<T>::value, int> = 0>
520    static size_t hash(T value) {
521      return static_cast<size_t>(
522          Mix(Seed(), static_cast<std::make_unsigned_t<T>>(value)));
523    }
524    template <typename T, absl::enable_if_t<!IntegralFastPath<T>::value, int> = 0>
525    static size_t hash(const T& value) {
526      return static_cast<size_t>(combine(MixingHashState{}, value).state_);
527    }
528   private:
529    MixingHashState() : state_(Seed()) {}
530    friend class MixingHashState::HashStateBase;
531    template <typename CombinerT>
532    static MixingHashState RunCombineUnordered(MixingHashState state,
533                                               CombinerT combiner) {
534      uint64_t unordered_state = 0;
535      combiner(MixingHashState{}, [&](MixingHashState& inner_state) {
536        auto element_state = inner_state.state_;
537        unordered_state += element_state;
538        if (unordered_state < element_state) {
539          ++unordered_state;
540        }
541        inner_state = MixingHashState{};
542      });
543      return MixingHashState::combine(std::move(state), unordered_state);
544    }
545    friend class absl::HashState;
546    MixingHashState(const MixingHashState&) = default;
547    explicit MixingHashState(uint64_t state) : state_(state) {}
548    static uint64_t CombineContiguousImpl(uint64_t state,
549                                          const unsigned char* first, size_t len,
550                                          std::integral_constant<int, 4>
551                                          );
552    static uint64_t CombineContiguousImpl(uint64_t state,
553                                          const unsigned char* first, size_t len,
554                                          std::integral_constant<int, 8>
555                                          );
556    static uint64_t CombineLargeContiguousImpl32(uint64_t state,
557                                                 const unsigned char* first,
558                                                 size_t len);
559    static uint64_t CombineLargeContiguousImpl64(uint64_t state,
560                                                 const unsigned char* first,
561                                                 size_t len);
562    static std::pair<uint64_t, uint64_t> Read9To16(const unsigned char* p,
563                                                   size_t len) {
564      uint64_t low_mem = absl::base_internal::UnalignedLoad64(p);
565      uint64_t high_mem = absl::base_internal::UnalignedLoad64(p + len - 8);
566  #ifdef ABSL_IS_LITTLE_ENDIAN
567      uint64_t most_significant = high_mem;
568      uint64_t least_significant = low_mem;
569  #else
570      uint64_t most_significant = low_mem;
571      uint64_t least_significant = high_mem;
572  #endif
573      return {least_significant, most_significant};
574    }
575    static uint64_t Read4To8(const unsigned char* p, size_t len) {
576      uint32_t low_mem = absl::base_internal::UnalignedLoad32(p);
577      uint32_t high_mem = absl::base_internal::UnalignedLoad32(p + len - 4);
578  #ifdef ABSL_IS_LITTLE_ENDIAN
579      uint32_t most_significant = high_mem;
580      uint32_t least_significant = low_mem;
581  #else
582      uint32_t most_significant = low_mem;
583      uint32_t least_significant = high_mem;
584  #endif
585      return (static_cast<uint64_t>(most_significant) << (len - 4) * 8) |
586             least_significant;
587    }
588    static uint32_t Read1To3(const unsigned char* p, size_t len) {
589      unsigned char mem0 = p[0];
590      unsigned char mem1 = p[len / 2];
591      unsigned char mem2 = p[len - 1];
592  #ifdef ABSL_IS_LITTLE_ENDIAN
593      unsigned char significant2 = mem2;
594      unsigned char significant1 = mem1;
595      unsigned char significant0 = mem0;
596  #else
597      unsigned char significant2 = mem0;
598      unsigned char significant1 = len == 2 ? mem0 : mem1;
599      unsigned char significant0 = mem2;
600  #endif
601      return static_cast<uint32_t>(significant0 |                     
602                                   (significant1 << (len / 2 * 8)) |  
603                                   (significant2 << ((len - 1) * 8)));
604    }
605    ABSL_ATTRIBUTE_ALWAYS_INLINE static uint64_t Mix(uint64_t state, uint64_t v) {
606      using MultType =
607          absl::conditional_t<sizeof(size_t) == 4, uint64_t, uint128>;
608      MultType m = state + v;
609      m *= kMul;
610      return static_cast<uint64_t>(m ^ (m >> (sizeof(m) * 8 / 2)));
611    }
612    static uint64_t LowLevelHashImpl(const unsigned char* data, size_t len);
613    ABSL_ATTRIBUTE_ALWAYS_INLINE static uint64_t Hash64(const unsigned char* data,
614                                                        size_t len) {
615  #ifdef ABSL_HAVE_INTRINSIC_INT128
616      return LowLevelHashImpl(data, len);
617  #else
618      return hash_internal::CityHash64(reinterpret_cast<const char*>(data), len);
619  #endif
620    }
621    ABSL_ATTRIBUTE_ALWAYS_INLINE static uint64_t Seed() {
622  #if (!defined(__clang__) || __clang_major__ > 11) && \
623      (!defined(__apple_build_version__) ||            \
624       __apple_build_version__ >= 19558921)  
625      return static_cast<uint64_t>(reinterpret_cast<uintptr_t>(&kSeed));
626  #else
627      return static_cast<uint64_t>(reinterpret_cast<uintptr_t>(kSeed));
628  #endif
629    }
630    static const void* const kSeed;
631    uint64_t state_;
632  };
633  inline uint64_t MixingHashState::CombineContiguousImpl(
634      uint64_t state, const unsigned char* first, size_t len,
635      std::integral_constant<int, 4> &bsol;* sizeof_size_t */) {
636    uint64_t v;
637    if (len > 8) {
638      if (ABSL_PREDICT_FALSE(len > PiecewiseChunkSize())) {
639        return CombineLargeContiguousImpl32(state, first, len);
640      }
641      v = hash_internal::CityHash32(reinterpret_cast<const char*>(first), len);
642    } else if (len >= 4) {
643      v = Read4To8(first, len);
644    } else if (len > 0) {
645      v = Read1To3(first, len);
646    } else {
647      return state;
648    }
649    return Mix(state, v);
650  }
651  inline uint64_t MixingHashState::CombineContiguousImpl(
652      uint64_t state, const unsigned char* first, size_t len,
653      std::integral_constant<int, 8> &bsol;* sizeof_size_t */) {
654    uint64_t v;
655    if (len > 16) {
656      if (ABSL_PREDICT_FALSE(len > PiecewiseChunkSize())) {
657        return CombineLargeContiguousImpl64(state, first, len);
658      }
659      v = Hash64(first, len);
660    } else if (len > 8) {
661      auto p = Read9To16(first, len);
662      uint64_t lo = p.first;
663      uint64_t hi = p.second;
664      lo = absl::rotr(lo, 53);
665      state += kMul;
666      lo += state;
667      state ^= hi;
668      uint128 m = state;
669      m *= lo;
670      return static_cast<uint64_t>(m ^ (m >> 64));
671    } else if (len >= 4) {
672      v = Read4To8(first, len);
673    } else if (len > 0) {
674      v = Read1To3(first, len);
675    } else {
676      return state;
677    }
678    return Mix(state, v);
679  }
680  struct AggregateBarrier {};
681  struct PoisonedHash : private AggregateBarrier {
682    PoisonedHash() = delete;
683    PoisonedHash(const PoisonedHash&) = delete;
684    PoisonedHash& operator=(const PoisonedHash&) = delete;
685  };
686  template <typename T>
687  struct HashImpl {
688    size_t operator()(const T& value) const {
689      return MixingHashState::hash(value);
690    }
691  };
692  template <typename T>
693  struct Hash
694      : absl::conditional_t<is_hashable<T>::value, HashImpl<T>, PoisonedHash> {};
695  template <typename H>
696  template <typename T, typename... Ts>
697  H HashStateBase<H>::combine(H state, const T& value, const Ts&... values) {
698    return H::combine(hash_internal::HashSelect::template Apply<T>::Invoke(
699                          std::move(state), value),
700                      values...);
701  }
702  template <typename H>
703  template <typename T>
704  H HashStateBase<H>::combine_contiguous(H state, const T* data, size_t size) {
705    return hash_internal::hash_range_or_bytes(std::move(state), data, size);
706  }
707  template <typename H>
708  template <typename I>
709  H HashStateBase<H>::combine_unordered(H state, I begin, I end) {
710    return H::RunCombineUnordered(std::move(state),
711                                  CombineUnorderedCallback<I>{begin, end});
712  }
713  template <typename H>
714  H PiecewiseCombiner::add_buffer(H state, const unsigned char* data,
715                                  size_t size) {
716    if (position_ + size < PiecewiseChunkSize()) {
717      memcpy(buf_ + position_, data, size);
718      position_ += size;
719      return state;
720    }
721    if (position_ != 0) {
722      const size_t bytes_needed = PiecewiseChunkSize() - position_;
723      memcpy(buf_ + position_, data, bytes_needed);
724      state = H::combine_contiguous(std::move(state), buf_, PiecewiseChunkSize());
725      data += bytes_needed;
726      size -= bytes_needed;
727    }
728    while (size >= PiecewiseChunkSize()) {
729      state = H::combine_contiguous(std::move(state), data, PiecewiseChunkSize());
730      data += PiecewiseChunkSize();
731      size -= PiecewiseChunkSize();
732    }
733    memcpy(buf_, data, size);
734    position_ = size;
735    return state;
736  }
737  template <typename H>
738  H PiecewiseCombiner::finalize(H state) {
739    return H::combine_contiguous(std::move(state), buf_, position_);
740  }
741  }  
742  ABSL_NAMESPACE_END
743  }  
744  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-hash_12.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-hash_12.h</div>
                </div>
                <div class="column column_space"><pre><code>336      H hash_state, const std::unordered_set<Key, Hash, KeyEqual, Alloc>& s) {
337    return H::combine(
338        H::combine_unordered(std::move(hash_state), s.begin(), s.end()),
339        s.size());
340  }
341  template <typename H, typename Key, typename Hash, typename KeyEqual,
342            typename Alloc>
</pre></code></div>
                <div class="column column_space"><pre><code>344      H hash_state,
345      const std::unordered_multiset<Key, Hash, KeyEqual, Alloc>& s) {
346    return H::combine(
347        H::combine_unordered(std::move(hash_state), s.begin(), s.end()),
348        s.size());
349  }
350  template <typename H, typename Key, typename T, typename Hash,
351            typename KeyEqual, typename Alloc>
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    