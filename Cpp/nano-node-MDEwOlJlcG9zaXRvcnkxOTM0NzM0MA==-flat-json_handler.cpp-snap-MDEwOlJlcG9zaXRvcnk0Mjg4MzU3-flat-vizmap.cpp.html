
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 14, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-json_handler.cpp</h3>
            <pre><code>1  #include <nano/lib/config.hpp>
2  #include <nano/lib/json_error_response.hpp>
3  #include <nano/lib/timer.hpp>
4  #include <nano/node/bootstrap/bootstrap_lazy.hpp>
5  #include <nano/node/bootstrap_ascending/service.hpp>
6  #include <nano/node/common.hpp>
7  #include <nano/node/election.hpp>
8  #include <nano/node/json_handler.hpp>
9  #include <nano/node/node.hpp>
10  #include <nano/node/node_rpc_config.hpp>
11  #include <nano/node/telemetry.hpp>
12  #include <boost/property_tree/json_parser.hpp>
13  #include <boost/property_tree/ptree.hpp>
14  #include <algorithm>
15  #include <chrono>
16  #include <vector>
17  namespace
18  {
19  void construct_json (nano::container_info_component * component, boost::property_tree::ptree & parent);
20  using ipc_json_handler_no_arg_func_map = std::unordered_map<std::string, std::function<void (nano::json_handler *)>>;
21  ipc_json_handler_no_arg_func_map create_ipc_json_handler_no_arg_func_map ();
22  auto ipc_json_handler_no_arg_funcs = create_ipc_json_handler_no_arg_func_map ();
23  bool block_confirmed (nano::node & node, nano::transaction & transaction, nano::block_hash const & hash, bool include_active, bool include_only_confirmed);
24  char const * epoch_as_string (nano::epoch);
25  }
26  nano::json_handler::json_handler (nano::node & node_a, nano::node_rpc_config const & node_rpc_config_a, std::string const & body_a, std::function<void (std::string const &)> const & response_a, std::function<void ()> stop_callback_a) :
27  	body (body_a),
28  	node (node_a),
29  	response (response_a),
30  	stop_callback (stop_callback_a),
31  	node_rpc_config (node_rpc_config_a)
32  {
33  }
34  std::function<void ()> nano::json_handler::create_worker_task (std::function<void (std::shared_ptr<nano::json_handler> const &)> const & action_a)
35  {
36  	return [rpc_l = shared_from_this (), action_a] () {
37  		try
38  		{
39  			action_a (rpc_l);
40  		}
41  		catch (std::runtime_error const &)
42  		{
43  			json_error_response (rpc_l->response, "Unable to parse JSON");
44  		}
45  		catch (...)
46  		{
47  			json_error_response (rpc_l->response, "Internal server error in RPC");
48  		}
49  	};
50  }
51  void nano::json_handler::process_request (bool unsafe_a)
52  {
53  	try
54  	{
55  		std::stringstream istream (body);
56  		boost::property_tree::read_json (istream, request);
57  		if (node_rpc_config.request_callback)
58  		{
59  			debug_assert (node.network_params.network.is_dev_network ());
60  			node_rpc_config.request_callback (request);
61  		}
62  		action = request.get<std::string> ("action");
63  		auto no_arg_func_iter = ipc_json_handler_no_arg_funcs.find (action);
64  		if (no_arg_func_iter != ipc_json_handler_no_arg_funcs.cend ())
65  		{
66  			no_arg_func_iter->second (this);
67  		}
68  		else
69  		{
70  			if (action == "wallet_seed")
71  			{
72  				if (unsafe_a || node.network_params.network.is_dev_network ())
73  				{
74  					wallet_seed ();
75  				}
76  				else
77  				{
78  					json_error_response (response, "Unsafe RPC not allowed");
79  				}
80  			}
81  			else if (action == "chain")
82  			{
83  				chain ();
84  			}
85  			else if (action == "successors")
86  			{
87  				chain (true);
88  			}
89  			else if (action == "history")
90  			{
91  				response_l.put ("deprecated", "1");
92  				request.put ("head", request.get<std::string> ("hash"));
93  				account_history ();
94  			}
95  			else if (action == "knano_from_raw" || action == "krai_from_raw")
96  			{
97  				mnano_from_raw (nano::kxrb_ratio);
98  			}
99  			else if (action == "knano_to_raw" || action == "krai_to_raw")
100  			{
101  				mnano_to_raw (nano::kxrb_ratio);
102  			}
103  			else if (action == "rai_from_raw")
104  			{
105  				mnano_from_raw (nano::xrb_ratio);
106  			}
107  			else if (action == "rai_to_raw")
108  			{
109  				mnano_to_raw (nano::xrb_ratio);
110  			}
111  			else if (action == "mnano_from_raw" || action == "mrai_from_raw")
112  			{
113  				mnano_from_raw ();
114  			}
115  			else if (action == "mnano_to_raw" || action == "mrai_to_raw")
116  			{
117  				mnano_to_raw ();
118  			}
119  			else if (action == "nano_to_raw")
120  			{
121  				nano_to_raw ();
122  			}
123  			else if (action == "raw_to_nano")
124  			{
125  				raw_to_nano ();
126  			}
127  			else if (action == "password_valid")
128  			{
129  				password_valid ();
130  			}
131  			else if (action == "wallet_locked")
132  			{
133  				password_valid (true);
134  			}
135  			else
136  			{
137  				json_error_response (response, "Unknown command");
138  			}
139  		}
140  	}
141  	catch (std::runtime_error const &)
142  	{
143  		json_error_response (response, "Unable to parse JSON");
144  	}
145  	catch (...)
146  	{
147  		json_error_response (response, "Internal server error in RPC");
148  	}
149  }
150  void nano::json_handler::response_errors ()
151  {
152  	if (!ec && response_l.empty ())
153  	{
154  		ec = nano::error_rpc::empty_response;
155  	}
156  	if (ec)
157  	{
158  		boost::property_tree::ptree response_error;
159  		response_error.put ("error", ec.message ());
160  		std::stringstream ostream;
161  		boost::property_tree::write_json (ostream, response_error);
162  		response (ostream.str ());
163  	}
164  	else
165  	{
166  		std::stringstream ostream;
167  		boost::property_tree::write_json (ostream, response_l);
168  		response (ostream.str ());
169  	}
170  }
171  std::shared_ptr<nano::wallet> nano::json_handler::wallet_impl ()
172  {
173  	if (!ec)
174  	{
175  		std::string wallet_text (request.get<std::string> ("wallet"));
176  		nano::wallet_id wallet;
177  		if (!wallet.decode_hex (wallet_text))
178  		{
179  			if (auto existing = node.wallets.open (wallet); existing != nullptr)
180  			{
181  				return existing;
182  			}
183  			else
184  			{
185  				ec = nano::error_common::wallet_not_found;
186  			}
187  		}
188  		else
189  		{
190  			ec = nano::error_common::bad_wallet_number;
191  		}
192  	}
193  	return nullptr;
194  }
195  bool nano::json_handler::wallet_locked_impl (nano::transaction const & transaction_a, std::shared_ptr<nano::wallet> const & wallet_a)
196  {
197  	bool result (false);
198  	if (!ec)
199  	{
200  		if (!wallet_a->store.valid_password (transaction_a))
201  		{
202  			ec = nano::error_common::wallet_locked;
203  			result = true;
204  		}
205  	}
206  	return result;
207  }
208  bool nano::json_handler::wallet_account_impl (nano::transaction const & transaction_a, std::shared_ptr<nano::wallet> const & wallet_a, nano::account const & account_a)
209  {
210  	bool result (false);
211  	if (!ec)
212  	{
213  		if (wallet_a->store.find (transaction_a, account_a) != wallet_a->store.end ())
214  		{
215  			result = true;
216  		}
217  		else
218  		{
219  			ec = nano::error_common::account_not_found_wallet;
220  		}
221  	}
222  	return result;
223  }
224  nano::account nano::json_handler::account_impl (std::string account_text, std::error_code ec_a)
225  {
226  	nano::account result{};
227  	if (!ec)
228  	{
229  		if (account_text.empty ())
230  		{
231  			account_text = request.get<std::string> ("account");
232  		}
233  		if (result.decode_account (account_text))
234  		{
235  			ec = ec_a;
236  		}
237  		else if (account_text[3] == '-' || account_text[4] == '-')
238  		{
239  			response_l.put ("deprecated_account_format", "1");
240  		}
241  	}
242  	return result;
243  }
244  nano::account_info nano::json_handler::account_info_impl (nano::transaction const & transaction_a, nano::account const & account_a)
245  {
246  	nano::account_info result;
247  	if (!ec)
248  	{
249  		auto info = node.ledger.account_info (transaction_a, account_a);
250  		if (!info)
251  		{
252  			ec = nano::error_common::account_not_found;
253  			node.bootstrap_initiator.bootstrap_lazy (account_a, false, account_a.to_account ());
254  		}
255  		else
256  		{
257  			result = *info;
258  		}
259  	}
260  	return result;
261  }
262  nano::amount nano::json_handler::amount_impl ()
263  {
264  	nano::amount result (0);
265  	if (!ec)
266  	{
267  		std::string amount_text (request.get<std::string> ("amount"));
268  		if (result.decode_dec (amount_text))
269  		{
270  			ec = nano::error_common::invalid_amount;
271  		}
272  	}
273  	return result;
274  }
275  std::shared_ptr<nano::block> nano::json_handler::block_impl (bool signature_work_required)
276  {
277  	bool const json_block_l = request.get<bool> ("json_block", false);
278  	std::shared_ptr<nano::block> result{ nullptr };
279  	if (!ec)
280  	{
281  		boost::property_tree::ptree block_l;
282  		if (json_block_l)
283  		{
284  			block_l = request.get_child ("block");
285  		}
286  		else
287  		{
288  			std::string block_text (request.get<std::string> ("block"));
289  			std::stringstream block_stream (block_text);
290  			try
291  			{
292  				boost::property_tree::read_json (block_stream, block_l);
293  			}
294  			catch (...)
295  			{
296  				ec = nano::error_blocks::invalid_block;
297  			}
298  		}
299  		if (!ec)
300  		{
301  			if (!signature_work_required)
302  			{
303  				block_l.put ("signature", "0");
304  				block_l.put ("work", "0");
305  			}
306  			result = nano::deserialize_block_json (block_l);
307  			if (result == nullptr)
308  			{
309  				ec = nano::error_blocks::invalid_block;
310  			}
311  		}
312  	}
313  	return result;
314  }
315  nano::block_hash nano::json_handler::hash_impl (std::string search_text)
316  {
317  	nano::block_hash result (0);
318  	if (!ec)
319  	{
320  		std::string hash_text (request.get<std::string> (search_text));
321  		if (result.decode_hex (hash_text))
322  		{
323  			ec = nano::error_blocks::invalid_block_hash;
324  		}
325  	}
326  	return result;
327  }
328  nano::amount nano::json_handler::threshold_optional_impl ()
329  {
330  	nano::amount result (0);
331  	boost::optional<std::string> threshold_text (request.get_optional<std::string> ("threshold"));
332  	if (!ec && threshold_text.is_initialized ())
333  	{
334  		if (result.decode_dec (threshold_text.get ()))
335  		{
336  			ec = nano::error_common::bad_threshold;
337  		}
338  	}
339  	return result;
340  }
341  uint64_t nano::json_handler::work_optional_impl ()
342  {
343  	uint64_t result (0);
344  	boost::optional<std::string> work_text (request.get_optional<std::string> ("work"));
345  	if (!ec && work_text.is_initialized ())
346  	{
347  		if (nano::from_string_hex (work_text.get (), result))
348  		{
349  			ec = nano::error_common::bad_work_format;
350  		}
351  	}
352  	return result;
353  }
354  uint64_t nano::json_handler::difficulty_optional_impl (nano::work_version const version_a)
355  {
356  	auto difficulty (node.default_difficulty (version_a));
357  	boost::optional<std::string> difficulty_text (request.get_optional<std::string> ("difficulty"));
358  	if (!ec && difficulty_text.is_initialized ())
359  	{
360  		if (nano::from_string_hex (difficulty_text.get (), difficulty))
361  		{
362  			ec = nano::error_rpc::bad_difficulty_format;
363  		}
364  	}
365  	return difficulty;
366  }
367  uint64_t nano::json_handler::difficulty_ledger (nano::block const & block_a)
368  {
369  	nano::block_details details (nano::epoch::epoch_0, false, false, false);
370  	bool details_found (false);
371  	auto transaction (node.store.tx_begin_read ());
372  	std::shared_ptr<nano::block> block_previous (nullptr);
373  	auto previous (block_a.previous ());
374  	if (!previous.is_zero ())
375  	{
376  		block_previous = node.store.block.get (transaction, previous);
377  	}
378  	if (block_previous != nullptr)
379  	{
380  		details.is_send = node.store.block.balance (transaction, previous) > block_a.balance ().number ();
381  		details_found = true;
382  	}
383  	if (block_previous != nullptr)
384  	{
385  		details.epoch = block_previous->sideband ().details.epoch;
386  	}
387  	auto link (block_a.link ());
388  	if (!link.is_zero () && !details.is_send)
389  	{
390  		auto block_link (node.store.block.get (transaction, link.as_block_hash ()));
391  		if (block_link != nullptr && node.store.pending.exists (transaction, nano::pending_key (block_a.account (), link.as_block_hash ())))
392  		{
393  			details.epoch = std::max (details.epoch, block_link->sideband ().details.epoch);
394  			details.is_receive = true;
395  			details_found = true;
396  		}
397  	}
398  	return details_found ? node.network_params.work.threshold (block_a.work_version (), details) : node.default_difficulty (block_a.work_version ());
399  }
400  double nano::json_handler::multiplier_optional_impl (nano::work_version const version_a, uint64_t & difficulty)
401  {
402  	double multiplier (1.);
403  	boost::optional<std::string> multiplier_text (request.get_optional<std::string> ("multiplier"));
404  	if (!ec && multiplier_text.is_initialized ())
405  	{
406  		auto success = boost::conversion::try_lexical_convert<double> (multiplier_text.get (), multiplier);
407  		if (success && multiplier > 0.)
408  		{
409  			difficulty = nano::difficulty::from_multiplier (multiplier, node.default_difficulty (version_a));
410  		}
411  		else
412  		{
413  			ec = nano::error_rpc::bad_multiplier_format;
414  		}
415  	}
416  	return multiplier;
417  }
418  nano::work_version nano::json_handler::work_version_optional_impl (nano::work_version const default_a)
419  {
420  	nano::work_version result = default_a;
421  	boost::optional<std::string> version_text (request.get_optional<std::string> ("version"));
422  	if (!ec && version_text.is_initialized ())
423  	{
424  		if (*version_text == nano::to_string (nano::work_version::work_1))
425  		{
426  			result = nano::work_version::work_1;
427  		}
428  		else
429  		{
430  			ec = nano::error_rpc::bad_work_version;
431  		}
432  	}
433  	return result;
434  }
435  namespace
436  {
437  bool decode_unsigned (std::string const & text, uint64_t & number)
438  {
439  	bool result;
440  	std::size_t end;
441  	try
442  	{
443  		number = std::stoull (text, &end);
444  		result = false;
445  	}
446  	catch (std::invalid_argument const &)
447  	{
448  		result = true;
449  	}
450  	catch (std::out_of_range const &)
451  	{
452  		result = true;
453  	}
454  	result = result || end != text.size ();
455  	return result;
456  }
457  }
458  uint64_t nano::json_handler::count_impl ()
459  {
460  	uint64_t result (0);
461  	if (!ec)
462  	{
463  		std::string count_text (request.get<std::string> ("count"));
464  		if (decode_unsigned (count_text, result) || result == 0)
465  		{
466  			ec = nano::error_common::invalid_count;
467  		}
468  	}
469  	return result;
470  }
471  uint64_t nano::json_handler::count_optional_impl (uint64_t result)
472  {
473  	boost::optional<std::string> count_text (request.get_optional<std::string> ("count"));
474  	if (!ec && count_text.is_initialized ())
475  	{
476  		if (decode_unsigned (count_text.get (), result))
477  		{
478  			ec = nano::error_common::invalid_count;
479  		}
480  	}
481  	return result;
482  }
483  uint64_t nano::json_handler::offset_optional_impl (uint64_t result)
484  {
485  	boost::optional<std::string> offset_text (request.get_optional<std::string> ("offset"));
486  	if (!ec && offset_text.is_initialized ())
487  	{
488  		if (decode_unsigned (offset_text.get (), result))
489  		{
490  			ec = nano::error_rpc::invalid_offset;
491  		}
492  	}
493  	return result;
494  }
495  void nano::json_handler::account_balance ()
496  {
497  	auto account (account_impl ());
498  	if (!ec)
499  	{
500  		bool const include_only_confirmed = request.get<bool> ("include_only_confirmed", true);
501  		auto balance (node.balance_pending (account, include_only_confirmed));
502  		response_l.put ("balance", balance.first.convert_to<std::string> ());
503  		response_l.put ("pending", balance.second.convert_to<std::string> ());
504  		response_l.put ("receivable", balance.second.convert_to<std::string> ());
505  	}
506  	response_errors ();
507  }
508  void nano::json_handler::account_block_count ()
509  {
510  	auto account (account_impl ());
511  	if (!ec)
512  	{
513  		auto transaction (node.store.tx_begin_read ());
514  		auto info (account_info_impl (transaction, account));
515  		if (!ec)
516  		{
517  			response_l.put ("block_count", std::to_string (info.block_count));
518  		}
519  	}
520  	response_errors ();
521  }
522  void nano::json_handler::account_create ()
523  {
524  	node.workers.push_task (create_worker_task ([] (std::shared_ptr<nano::json_handler> const & rpc_l) {
525  		auto wallet (rpc_l->wallet_impl ());
526  		if (!rpc_l->ec)
527  		{
528  			bool const generate_work = rpc_l->request.get<bool> ("work", true);
529  			nano::account new_key;
530  			auto index_text (rpc_l->request.get_optional<std::string> ("index"));
531  			if (index_text.is_initialized ())
532  			{
533  				uint64_t index;
534  				if (decode_unsigned (index_text.get (), index) || index > static_cast<uint64_t> (std::numeric_limits<uint32_t>::max ()))
535  				{
536  					rpc_l->ec = nano::error_common::invalid_index;
537  				}
538  				else
539  				{
540  					new_key = wallet->deterministic_insert (static_cast<uint32_t> (index), generate_work);
541  				}
542  			}
543  			else
544  			{
545  				new_key = wallet->deterministic_insert (generate_work);
546  			}
547  			if (!rpc_l->ec)
548  			{
549  				if (!new_key.is_zero ())
550  				{
551  					rpc_l->response_l.put ("account", new_key.to_account ());
552  				}
553  				else
554  				{
555  					rpc_l->ec = nano::error_common::wallet_locked;
556  				}
557  			}
558  		}
559  		rpc_l->response_errors ();
560  	}));
561  }
562  void nano::json_handler::account_get ()
563  {
564  	std::string key_text (request.get<std::string> ("key"));
565  	nano::public_key pub;
566  	if (!pub.decode_hex (key_text))
567  	{
568  		response_l.put ("account", pub.to_account ());
569  	}
570  	else
571  	{
572  		ec = nano::error_common::bad_public_key;
573  	}
574  	response_errors ();
575  }
576  void nano::json_handler::account_info ()
577  {
578  	auto account (account_impl ());
579  	if (!ec)
580  	{
581  		bool const representative = request.get<bool> ("representative", false);
582  		bool const weight = request.get<bool> ("weight", false);
583  		bool const pending = request.get<bool> ("pending", false);
584  		bool const receivable = request.get<bool> ("receivable", pending);
585  		bool const include_confirmed = request.get<bool> ("include_confirmed", false);
586  		auto transaction (node.store.tx_begin_read ());
587  		auto info (account_info_impl (transaction, account));
588  		nano::confirmation_height_info confirmation_height_info;
589  		node.store.confirmation_height.get (transaction, account, confirmation_height_info);
590  		if (!ec)
591  		{
592  			response_l.put ("frontier", info.head.to_string ());
593  			response_l.put ("open_block", info.open_block.to_string ());
594  			response_l.put ("representative_block", node.ledger.representative (transaction, info.head).to_string ());
595  			nano::amount balance_l (info.balance);
596  			std::string balance;
597  			balance_l.encode_dec (balance);
598  			response_l.put ("balance", balance);
599  			nano::amount confirmed_balance_l;
600  			if (include_confirmed)
601  			{
602  				if (info.block_count != confirmation_height_info.height)
603  				{
604  					confirmed_balance_l = node.ledger.balance (transaction, confirmation_height_info.frontier);
605  				}
606  				else
607  				{
608  					confirmed_balance_l = balance_l;
609  				}
610  				std::string confirmed_balance;
611  				confirmed_balance_l.encode_dec (confirmed_balance);
612  				response_l.put ("confirmed_balance", confirmed_balance);
613  			}
614  			response_l.put ("modified_timestamp", std::to_string (info.modified));
615  			response_l.put ("block_count", std::to_string (info.block_count));
616  			response_l.put ("account_version", epoch_as_string (info.epoch ()));
617  			auto confirmed_frontier = confirmation_height_info.frontier.to_string ();
618  			if (include_confirmed)
619  			{
620  				response_l.put ("confirmed_height", std::to_string (confirmation_height_info.height));
621  				response_l.put ("confirmed_frontier", confirmed_frontier);
622  			}
623  			else
624  			{
625  				response_l.put ("confirmation_height", std::to_string (confirmation_height_info.height));
626  				response_l.put ("confirmation_height_frontier", confirmed_frontier);
627  			}
628  			std::shared_ptr<nano::block> confirmed_frontier_block;
629  			if (include_confirmed && confirmation_height_info.height > 0)
630  			{
631  				confirmed_frontier_block = node.store.block.get (transaction, confirmation_height_info.frontier);
632  			}
633  			if (representative)
634  			{
635  				response_l.put ("representative", info.representative.to_account ());
636  				if (include_confirmed)
637  				{
638  					nano::account confirmed_representative{};
639  					if (confirmed_frontier_block)
640  					{
641  						confirmed_representative = confirmed_frontier_block->representative ();
642  						if (confirmed_representative.is_zero ())
643  						{
644  							confirmed_representative = node.store.block.get (transaction, node.ledger.representative (transaction, confirmation_height_info.frontier))->representative ();
645  						}
646  					}
647  					response_l.put ("confirmed_representative", confirmed_representative.to_account ());
648  				}
649  			}
650  			if (weight)
651  			{
652  				auto account_weight (node.ledger.weight (account));
653  				response_l.put ("weight", account_weight.convert_to<std::string> ());
654  			}
655  			if (receivable)
656  			{
657  				auto account_receivable = node.ledger.account_receivable (transaction, account);
658  				response_l.put ("pending", account_receivable.convert_to<std::string> ());
659  				response_l.put ("receivable", account_receivable.convert_to<std::string> ());
660  				if (include_confirmed)
661  				{
662  					auto account_receivable = node.ledger.account_receivable (transaction, account, true);
663  					response_l.put ("confirmed_pending", account_receivable.convert_to<std::string> ());
664  					response_l.put ("confirmed_receivable", account_receivable.convert_to<std::string> ());
665  				}
666  			}
667  		}
668  	}
669  	response_errors ();
670  }
671  void nano::json_handler::account_key ()
672  {
673  	auto account (account_impl ());
674  	if (!ec)
675  	{
676  		response_l.put ("key", account.to_string ());
677  	}
678  	response_errors ();
679  }
680  void nano::json_handler::account_list ()
681  {
682  	auto wallet (wallet_impl ());
683  	if (!ec)
684  	{
685  		boost::property_tree::ptree accounts;
686  		auto transaction (node.wallets.tx_begin_read ());
687  		for (auto i (wallet->store.begin (transaction)), j (wallet->store.end ()); i != j; ++i)
688  		{
689  			boost::property_tree::ptree entry;
690  			entry.put ("", nano::account (i->first).to_account ());
691  			accounts.push_back (std::make_pair ("", entry));
692  		}
693  		response_l.add_child ("accounts", accounts);
694  	}
695  	response_errors ();
696  }
697  void nano::json_handler::account_move ()
698  {
699  	node.workers.push_task (create_worker_task ([] (std::shared_ptr<nano::json_handler> const & rpc_l) {
700  		auto wallet (rpc_l->wallet_impl ());
701  		if (!rpc_l->ec)
702  		{
703  			std::string source_text (rpc_l->request.get<std::string> ("source"));
704  			auto accounts_text (rpc_l->request.get_child ("accounts"));
705  			nano::wallet_id source;
706  			if (!source.decode_hex (source_text))
707  			{
708  				auto existing (rpc_l->node.wallets.items.find (source));
709  				if (existing != rpc_l->node.wallets.items.end ())
710  				{
711  					auto source (existing->second);
712  					std::vector<nano::public_key> accounts;
713  					for (auto i (accounts_text.begin ()), n (accounts_text.end ()); i != n; ++i)
714  					{
715  						auto account (rpc_l->account_impl (i->second.get<std::string> ("")));
716  						accounts.push_back (account);
717  					}
718  					auto transaction (rpc_l->node.wallets.tx_begin_write ());
719  					auto error (wallet->store.move (transaction, source->store, accounts));
720  					rpc_l->response_l.put ("moved", error ? "0" : "1");
721  				}
722  				else
723  				{
724  					rpc_l->ec = nano::error_rpc::source_not_found;
725  				}
726  			}
727  			else
728  			{
729  				rpc_l->ec = nano::error_rpc::bad_source;
730  			}
731  		}
732  		rpc_l->response_errors ();
733  	}));
734  }
735  void nano::json_handler::account_remove ()
736  {
737  	node.workers.push_task (create_worker_task ([] (std::shared_ptr<nano::json_handler> const & rpc_l) {
738  		auto wallet (rpc_l->wallet_impl ());
739  		auto account (rpc_l->account_impl ());
740  		if (!rpc_l->ec)
741  		{
742  			auto transaction (rpc_l->node.wallets.tx_begin_write ());
743  			rpc_l->wallet_locked_impl (transaction, wallet);
744  			rpc_l->wallet_account_impl (transaction, wallet, account);
745  			if (!rpc_l->ec)
746  			{
747  				wallet->store.erase (transaction, account);
748  				rpc_l->response_l.put ("removed", "1");
749  			}
750  		}
751  		rpc_l->response_errors ();
752  	}));
753  }
754  void nano::json_handler::account_representative ()
755  {
756  	auto account (account_impl ());
757  	if (!ec)
758  	{
759  		auto transaction (node.store.tx_begin_read ());
760  		auto info (account_info_impl (transaction, account));
761  		if (!ec)
762  		{
763  			response_l.put ("representative", info.representative.to_account ());
764  		}
765  	}
766  	response_errors ();
767  }
768  void nano::json_handler::account_representative_set ()
769  {
770  	node.workers.push_task (create_worker_task ([work_generation_enabled = node.work_generation_enabled ()] (std::shared_ptr<nano::json_handler> const & rpc_l) {
771  		auto wallet (rpc_l->wallet_impl ());
772  		auto account (rpc_l->account_impl ());
773  		std::string representative_text (rpc_l->request.get<std::string> ("representative"));
774  		auto representative (rpc_l->account_impl (representative_text, nano::error_rpc::bad_representative_number));
775  		if (!rpc_l->ec)
776  		{
777  			auto work (rpc_l->work_optional_impl ());
778  			if (!rpc_l->ec && work)
779  			{
780  				auto transaction (rpc_l->node.wallets.tx_begin_write ());
781  				rpc_l->wallet_locked_impl (transaction, wallet);
782  				rpc_l->wallet_account_impl (transaction, wallet, account);
783  				if (!rpc_l->ec)
784  				{
785  					auto block_transaction (rpc_l->node.store.tx_begin_read ());
786  					auto info (rpc_l->account_info_impl (block_transaction, account));
787  					if (!rpc_l->ec)
788  					{
789  						nano::block_details details (info.epoch (), false, false, false);
790  						if (rpc_l->node.network_params.work.difficulty (nano::work_version::work_1, info.head, work) < rpc_l->node.network_params.work.threshold (nano::work_version::work_1, details))
791  						{
792  							rpc_l->ec = nano::error_common::invalid_work;
793  						}
794  					}
795  				}
796  			}
797  			else if (!rpc_l->ec) 
798  			{
799  				if (!work_generation_enabled)
800  				{
801  					rpc_l->ec = nano::error_common::disabled_work_generation;
802  				}
803  			}
804  			if (!rpc_l->ec)
805  			{
806  				bool generate_work (work == 0); 
807  				auto response_a (rpc_l->response);
808  				auto response_data (std::make_shared<boost::property_tree::ptree> (rpc_l->response_l));
809  				wallet->change_async (
810  				account, representative, [response_a, response_data] (std::shared_ptr<nano::block> const & block) {
811  					if (block != nullptr)
812  					{
813  						response_data->put ("block", block->hash ().to_string ());
814  						std::stringstream ostream;
815  						boost::property_tree::write_json (ostream, *response_data);
816  						response_a (ostream.str ());
817  					}
818  					else
819  					{
820  						json_error_response (response_a, "Error generating block");
821  					}
822  				},
823  				work, generate_work);
824  			}
825  		}
826  		if (rpc_l->ec)
827  		{
828  			rpc_l->response_errors ();
829  		}
830  	}));
831  }
832  void nano::json_handler::account_weight ()
833  {
834  	auto account (account_impl ());
835  	if (!ec)
836  	{
837  		auto balance (node.weight (account));
838  		response_l.put ("weight", balance.convert_to<std::string> ());
839  	}
840  	response_errors ();
841  }
842  void nano::json_handler::accounts_balances ()
843  {
844  	boost::property_tree::ptree balances;
845  	boost::property_tree::ptree errors;
846  	auto transaction = node.store.tx_begin_read ();
847  	for (auto & account_from_request : request.get_child ("accounts"))
848  	{
849  		boost::property_tree::ptree entry;
850  		auto account = account_impl (account_from_request.second.data ());
851  		if (!ec)
852  		{
853  			bool const include_only_confirmed = request.get<bool> ("include_only_confirmed", true);
854  			auto balance = node.balance_pending (account, include_only_confirmed);
855  			entry.put ("balance", balance.first.convert_to<std::string> ());
856  			entry.put ("pending", balance.second.convert_to<std::string> ());
857  			entry.put ("receivable", balance.second.convert_to<std::string> ());
858  			balances.put_child (account_from_request.second.data (), entry);
859  			continue;
860  		}
861  		debug_assert (ec);
862  		errors.put (account_from_request.second.data (), ec.message ());
863  		ec = {};
864  	}
865  	if (!balances.empty ())
866  	{
867  		response_l.add_child ("balances", balances);
868  	}
869  	if (!errors.empty ())
870  	{
871  		response_l.add_child ("errors", errors);
872  	}
873  	response_errors ();
874  }
875  void nano::json_handler::accounts_representatives ()
876  {
877  	boost::property_tree::ptree representatives;
878  	boost::property_tree::ptree errors;
879  	auto transaction = node.store.tx_begin_read ();
880  	for (auto & account_from_request : request.get_child ("accounts"))
881  	{
882  		auto account = account_impl (account_from_request.second.data ());
883  		if (!ec)
884  		{
885  			auto info = account_info_impl (transaction, account);
886  			if (!ec)
887  			{
888  				representatives.put (account_from_request.second.data (), info.representative.to_account ());
889  				continue;
890  			}
891  		}
892  		debug_assert (ec);
893  		errors.put (account_from_request.second.data (), ec.message ());
894  		ec = {};
895  	}
896  	if (!representatives.empty ())
897  	{
898  		response_l.add_child ("representatives", representatives);
899  	}
900  	if (!errors.empty ())
901  	{
902  		response_l.add_child ("errors", errors);
903  	}
904  	response_errors ();
905  }
906  void nano::json_handler::accounts_create ()
907  {
908  	node.workers.push_task (create_worker_task ([] (std::shared_ptr<nano::json_handler> const & rpc_l) {
909  		auto wallet (rpc_l->wallet_impl ());
910  		auto count (rpc_l->count_impl ());
911  		if (!rpc_l->ec)
912  		{
913  			bool const generate_work = rpc_l->request.get<bool> ("work", false);
914  			boost::property_tree::ptree accounts;
915  			for (auto i (0); accounts.size () < count; ++i)
916  			{
917  				nano::account new_key (wallet->deterministic_insert (generate_work));
918  				if (!new_key.is_zero ())
919  				{
920  					boost::property_tree::ptree entry;
921  					entry.put ("", new_key.to_account ());
922  					accounts.push_back (std::make_pair ("", entry));
923  				}
924  			}
925  			rpc_l->response_l.add_child ("accounts", accounts);
926  		}
927  		rpc_l->response_errors ();
928  	}));
929  }
930  void nano::json_handler::accounts_frontiers ()
931  {
932  	boost::property_tree::ptree frontiers;
933  	boost::property_tree::ptree errors;
934  	auto transaction = node.store.tx_begin_read ();
935  	for (auto & account_from_request : request.get_child ("accounts"))
936  	{
937  		auto account = account_impl (account_from_request.second.data ());
938  		if (!ec)
939  		{
940  			auto latest = node.ledger.latest (transaction, account);
941  			if (!latest.is_zero ())
942  			{
943  				frontiers.put (account.to_account (), latest.to_string ());
944  				continue;
945  			}
946  			else
947  			{
948  				ec = nano::error_common::account_not_found;
949  			}
950  		}
951  		debug_assert (ec);
952  		errors.put (account_from_request.second.data (), ec.message ());
953  		ec = {};
954  	}
955  	if (!frontiers.empty ())
956  	{
957  		response_l.add_child ("frontiers", frontiers);
958  	}
959  	if (!errors.empty ())
960  	{
961  		response_l.add_child ("errors", errors);
962  	}
963  	response_errors ();
964  }
965  void nano::json_handler::accounts_pending ()
966  {
967  	response_l.put ("deprecated", "1");
968  	accounts_receivable ();
969  }
970  void nano::json_handler::accounts_receivable ()
971  {
972  	auto count (count_optional_impl ());
973  	auto threshold (threshold_optional_impl ());
974  	bool const source = request.get<bool> ("source", false);
975  	bool const include_active = request.get<bool> ("include_active", false);
976  	bool const include_only_confirmed = request.get<bool> ("include_only_confirmed", true);
977  	bool const sorting = request.get<bool> ("sorting", false);
978  	auto simple (threshold.is_zero () && !source && !sorting); 
979  	boost::property_tree::ptree pending;
980  	auto transaction (node.store.tx_begin_read ());
981  	for (auto & accounts : request.get_child ("accounts"))
982  	{
983  		auto account (account_impl (accounts.second.data ()));
984  		if (!ec)
985  		{
986  			boost::property_tree::ptree peers_l;
987  			for (auto i (node.store.pending.begin (transaction, nano::pending_key (account, 0))), n (node.store.pending.end ()); i != n && nano::pending_key (i->first).account == account && peers_l.size () < count; ++i)
988  			{
989  				nano::pending_key const & key (i->first);
990  				if (block_confirmed (node, transaction, key.hash, include_active, include_only_confirmed))
991  				{
992  					if (simple)
993  					{
994  						boost::property_tree::ptree entry;
995  						entry.put ("", key.hash.to_string ());
996  						peers_l.push_back (std::make_pair ("", entry));
997  					}
998  					else
999  					{
1000  						nano::pending_info const & info (i->second);
1001  						if (info.amount.number () >= threshold.number ())
1002  						{
1003  							if (source)
1004  							{
1005  								boost::property_tree::ptree pending_tree;
1006  								pending_tree.put ("amount", info.amount.number ().convert_to<std::string> ());
1007  								pending_tree.put ("source", info.source.to_account ());
1008  								peers_l.add_child (key.hash.to_string (), pending_tree);
1009  							}
1010  							else
1011  							{
1012  								peers_l.put (key.hash.to_string (), info.amount.number ().convert_to<std::string> ());
1013  							}
1014  						}
1015  					}
1016  				}
1017  			}
1018  			if (sorting && !simple)
1019  			{
1020  				if (source)
1021  				{
1022  					peers_l.sort ([] (auto const & child1, auto const & child2) -> bool {
1023  						return child1.second.template get<nano::uint128_t> ("amount") > child2.second.template get<nano::uint128_t> ("amount");
1024  					});
1025  				}
1026  				else
1027  				{
1028  					peers_l.sort ([] (auto const & child1, auto const & child2) -> bool {
1029  						return child1.second.template get<nano::uint128_t> ("") > child2.second.template get<nano::uint128_t> ("");
1030  					});
1031  				}
1032  			}
1033  			if (!peers_l.empty ())
1034  			{
1035  				pending.add_child (account.to_account (), peers_l);
1036  			}
1037  		}
1038  	}
1039  	response_l.add_child ("blocks", pending);
1040  	response_errors ();
1041  }
1042  void nano::json_handler::active_difficulty ()
1043  {
1044  	auto include_trend (request.get<bool> ("include_trend", false));
1045  	auto const multiplier_active = 1.0;
1046  	auto const default_difficulty (node.default_difficulty (nano::work_version::work_1));
1047  	auto const default_receive_difficulty (node.default_receive_difficulty (nano::work_version::work_1));
1048  	auto const receive_current_denormalized (node.network_params.work.denormalized_multiplier (multiplier_active, node.network_params.work.epoch_2_receive));
1049  	response_l.put ("deprecated", "1");
1050  	response_l.put ("network_minimum", nano::to_string_hex (default_difficulty));
1051  	response_l.put ("network_receive_minimum", nano::to_string_hex (default_receive_difficulty));
1052  	response_l.put ("network_current", nano::to_string_hex (nano::difficulty::from_multiplier (multiplier_active, default_difficulty)));
1053  	response_l.put ("network_receive_current", nano::to_string_hex (nano::difficulty::from_multiplier (receive_current_denormalized, default_receive_difficulty)));
1054  	response_l.put ("multiplier", 1.0);
1055  	if (include_trend)
1056  	{
1057  		boost::property_tree::ptree difficulty_trend_l;
1058  		boost::property_tree::ptree entry;
1059  		entry.put ("", "1.000000000000000");
1060  		difficulty_trend_l.push_back (std::make_pair ("", entry));
1061  		response_l.add_child ("difficulty_trend", difficulty_trend_l);
1062  	}
1063  	response_errors ();
1064  }
1065  void nano::json_handler::available_supply ()
1066  {
1067  	auto genesis_balance (node.balance (node.network_params.ledger.genesis->account ())); 
1068  	auto landing_balance (node.balance (nano::account ("059F68AAB29DE0D3A27443625C7EA9CDDB6517A8B76FE37727EF6A4D76832AD5"))); 
1069  	auto faucet_balance (node.balance (nano::account ("8E319CE6F3025E5B2DF66DA7AB1467FE48F1679C13DD43BFDB29FA2E9FC40D3B"))); 
1070  	auto burned_balance ((node.balance_pending (nano::account{}, false)).second); 
1071  	auto available (nano::dev::constants.genesis_amount - genesis_balance - landing_balance - faucet_balance - burned_balance);
1072  	response_l.put ("available", available.convert_to<std::string> ());
1073  	response_errors ();
1074  }
1075  void nano::json_handler::block_info ()
1076  {
1077  	auto hash (hash_impl ());
1078  	if (!ec)
1079  	{
1080  		auto transaction (node.store.tx_begin_read ());
1081  		auto block (node.store.block.get (transaction, hash));
1082  		if (block != nullptr)
1083  		{
1084  			nano::account account (block->account ().is_zero () ? block->sideband ().account : block->account ());
1085  			response_l.put ("block_account", account.to_account ());
1086  			bool error_or_pruned (false);
1087  			auto amount (node.ledger.amount_safe (transaction, hash, error_or_pruned));
1088  			if (!error_or_pruned)
1089  			{
1090  				response_l.put ("amount", amount.convert_to<std::string> ());
1091  			}
1092  			auto balance (node.ledger.balance (transaction, hash));
1093  			response_l.put ("balance", balance.convert_to<std::string> ());
1094  			response_l.put ("height", std::to_string (block->sideband ().height));
1095  			response_l.put ("local_timestamp", std::to_string (block->sideband ().timestamp));
1096  			response_l.put ("successor", block->sideband ().successor.to_string ());
1097  			auto confirmed (node.ledger.block_confirmed (transaction, hash));
1098  			response_l.put ("confirmed", confirmed);
1099  			bool json_block_l = request.get<bool> ("json_block", false);
1100  			if (json_block_l)
1101  			{
1102  				boost::property_tree::ptree block_node_l;
1103  				block->serialize_json (block_node_l);
1104  				response_l.add_child ("contents", block_node_l);
1105  			}
1106  			else
1107  			{
1108  				std::string contents;
1109  				block->serialize_json (contents);
1110  				response_l.put ("contents", contents);
1111  			}
1112  			if (block->type () == nano::block_type::state)
1113  			{
1114  				auto subtype (nano::state_subtype (block->sideband ().details));
1115  				response_l.put ("subtype", subtype);
1116  			}
1117  		}
1118  		else
1119  		{
1120  			ec = nano::error_blocks::not_found;
1121  		}
1122  	}
1123  	response_errors ();
1124  }
1125  void nano::json_handler::block_confirm ()
1126  {
1127  	auto hash (hash_impl ());
1128  	if (!ec)
1129  	{
1130  		auto transaction (node.store.tx_begin_read ());
1131  		auto block_l (node.store.block.get (transaction, hash));
1132  		if (block_l != nullptr)
1133  		{
1134  			if (!node.ledger.block_confirmed (transaction, hash))
1135  			{
1136  				if (!node.confirmation_height_processor.is_processing_block (hash))
1137  				{
1138  					node.block_confirm (std::move (block_l));
1139  				}
1140  			}
1141  			else
1142  			{
1143  				nano::election_status status{ block_l, 0, 0, std::chrono::duration_cast<std::chrono::milliseconds> (std::chrono::system_clock::now ().time_since_epoch ()), std::chrono::duration_values<std::chrono::milliseconds>::zero (), 0, 1, 0, nano::election_status_type::active_confirmation_height };
1144  				node.active.recently_cemented.put (status);
1145  				node.block_arrival.add (hash);
1146  				auto account (node.ledger.account (transaction, hash));
1147  				bool error_or_pruned (false);
1148  				auto amount (node.ledger.amount_safe (transaction, hash, error_or_pruned));
1149  				bool is_state_send (false);
1150  				bool is_state_epoch (false);
1151  				if (!error_or_pruned)
1152  				{
1153  					if (auto state = dynamic_cast<nano::state_block *> (block_l.get ()))
1154  					{
1155  						is_state_send = node.ledger.is_send (transaction, *state);
1156  						is_state_epoch = amount == 0 && node.ledger.is_epoch_link (state->link ());
1157  					}
1158  				}
1159  				node.observers.blocks.notify (status, {}, account, amount, is_state_send, is_state_epoch);
1160  			}
1161  			response_l.put ("started", "1");
1162  		}
1163  		else
1164  		{
1165  			ec = nano::error_blocks::not_found;
1166  		}
1167  	}
1168  	response_errors ();
1169  }
1170  void nano::json_handler::blocks ()
1171  {
1172  	bool const json_block_l = request.get<bool> ("json_block", false);
1173  	boost::property_tree::ptree blocks;
1174  	auto transaction (node.store.tx_begin_read ());
1175  	for (boost::property_tree::ptree::value_type & hashes : request.get_child ("hashes"))
1176  	{
1177  		if (!ec)
1178  		{
1179  			std::string hash_text = hashes.second.data ();
1180  			nano::block_hash hash;
1181  			if (!hash.decode_hex (hash_text))
1182  			{
1183  				auto block (node.store.block.get (transaction, hash));
1184  				if (block != nullptr)
1185  				{
1186  					if (json_block_l)
1187  					{
1188  						boost::property_tree::ptree block_node_l;
1189  						block->serialize_json (block_node_l);
1190  						blocks.add_child (hash_text, block_node_l);
1191  					}
1192  					else
1193  					{
1194  						std::string contents;
1195  						block->serialize_json (contents);
1196  						blocks.put (hash_text, contents);
1197  					}
1198  				}
1199  				else
1200  				{
1201  					ec = nano::error_blocks::not_found;
1202  				}
1203  			}
1204  			else
1205  			{
1206  				ec = nano::error_blocks::bad_hash_number;
1207  			}
1208  		}
1209  	}
1210  	response_l.add_child ("blocks", blocks);
1211  	response_errors ();
1212  }
1213  void nano::json_handler::blocks_info ()
1214  {
1215  	bool const pending = request.get<bool> ("pending", false);
1216  	bool const receivable = request.get<bool> ("receivable", pending);
1217  	bool const receive_hash = request.get<bool> ("receive_hash", false);
1218  	bool const source = request.get<bool> ("source", false);
1219  	bool const json_block_l = request.get<bool> ("json_block", false);
1220  	bool const include_not_found = request.get<bool> ("include_not_found", false);
1221  	boost::property_tree::ptree blocks;
1222  	boost::property_tree::ptree blocks_not_found;
1223  	auto transaction (node.store.tx_begin_read ());
1224  	for (boost::property_tree::ptree::value_type & hashes : request.get_child ("hashes"))
1225  	{
1226  		if (!ec)
1227  		{
1228  			std::string hash_text = hashes.second.data ();
1229  			nano::block_hash hash;
1230  			if (!hash.decode_hex (hash_text))
1231  			{
1232  				auto block (node.store.block.get (transaction, hash));
1233  				if (block != nullptr)
1234  				{
1235  					boost::property_tree::ptree entry;
1236  					nano::account account (block->account ().is_zero () ? block->sideband ().account : block->account ());
1237  					entry.put ("block_account", account.to_account ());
1238  					bool error_or_pruned (false);
1239  					auto amount (node.ledger.amount_safe (transaction, hash, error_or_pruned));
1240  					if (!error_or_pruned)
1241  					{
1242  						entry.put ("amount", amount.convert_to<std::string> ());
1243  					}
1244  					auto balance (node.ledger.balance (transaction, hash));
1245  					entry.put ("balance", balance.convert_to<std::string> ());
1246  					entry.put ("height", std::to_string (block->sideband ().height));
1247  					entry.put ("local_timestamp", std::to_string (block->sideband ().timestamp));
1248  					entry.put ("successor", block->sideband ().successor.to_string ());
1249  					auto confirmed (node.ledger.block_confirmed (transaction, hash));
1250  					entry.put ("confirmed", confirmed);
1251  					if (json_block_l)
1252  					{
1253  						boost::property_tree::ptree block_node_l;
1254  						block->serialize_json (block_node_l);
1255  						entry.add_child ("contents", block_node_l);
1256  					}
1257  					else
1258  					{
1259  						std::string contents;
1260  						block->serialize_json (contents);
1261  						entry.put ("contents", contents);
1262  					}
1263  					if (block->type () == nano::block_type::state)
1264  					{
1265  						auto subtype (nano::state_subtype (block->sideband ().details));
1266  						entry.put ("subtype", subtype);
1267  					}
1268  					if (receivable || receive_hash)
1269  					{
1270  						auto destination (node.ledger.block_destination (transaction, *block));
1271  						if (destination.is_zero ())
1272  						{
1273  							if (receivable)
1274  							{
1275  								entry.put ("pending", "0");
1276  								entry.put ("receivable", "0");
1277  							}
1278  							if (receive_hash)
1279  							{
1280  								entry.put ("receive_hash", nano::block_hash (0).to_string ());
1281  							}
1282  						}
1283  						else if (node.store.pending.exists (transaction, nano::pending_key (destination, hash)))
1284  						{
1285  							if (receivable)
1286  							{
1287  								entry.put ("pending", "1");
1288  								entry.put ("receivable", "1");
1289  							}
1290  							if (receive_hash)
1291  							{
1292  								entry.put ("receive_hash", nano::block_hash (0).to_string ());
1293  							}
1294  						}
1295  						else
1296  						{
1297  							if (receivable)
1298  							{
1299  								entry.put ("pending", "0");
1300  								entry.put ("receivable", "0");
1301  							}
1302  							if (receive_hash)
1303  							{
1304  								std::shared_ptr<nano::block> receive_block = node.ledger.find_receive_block_by_send_hash (transaction, destination, hash);
1305  								std::string receive_hash = receive_block ? receive_block->hash ().to_string () : nano::block_hash (0).to_string ();
1306  								entry.put ("receive_hash", receive_hash);
1307  							}
1308  						}
1309  					}
1310  					if (source)
1311  					{
1312  						nano::block_hash source_hash (node.ledger.block_source (transaction, *block));
1313  						auto block_a (node.store.block.get (transaction, source_hash));
1314  						if (block_a != nullptr)
1315  						{
1316  							auto source_account (node.ledger.account (transaction, source_hash));
1317  							entry.put ("source_account", source_account.to_account ());
1318  						}
1319  						else
1320  						{
1321  							entry.put ("source_account", "0");
1322  						}
1323  					}
1324  					blocks.push_back (std::make_pair (hash_text, entry));
1325  				}
1326  				else if (include_not_found)
1327  				{
1328  					boost::property_tree::ptree entry;
1329  					entry.put ("", hash_text);
1330  					blocks_not_found.push_back (std::make_pair ("", entry));
1331  				}
1332  				else
1333  				{
1334  					ec = nano::error_blocks::not_found;
1335  				}
1336  			}
1337  			else
1338  			{
1339  				ec = nano::error_blocks::bad_hash_number;
1340  			}
1341  		}
1342  	}
1343  	if (!ec)
1344  	{
1345  		response_l.add_child ("blocks", blocks);
1346  		if (include_not_found)
1347  		{
1348  			response_l.add_child ("blocks_not_found", blocks_not_found);
1349  		}
1350  	}
1351  	response_errors ();
1352  }
1353  void nano::json_handler::block_account ()
1354  {
1355  	auto hash (hash_impl ());
1356  	if (!ec)
1357  	{
1358  		auto transaction (node.store.tx_begin_read ());
1359  		if (node.store.block.exists (transaction, hash))
1360  		{
1361  			auto account (node.ledger.account (transaction, hash));
1362  			response_l.put ("account", account.to_account ());
1363  		}
1364  		else
1365  		{
1366  			ec = nano::error_blocks::not_found;
1367  		}
1368  	}
1369  	response_errors ();
1370  }
1371  void nano::json_handler::block_count ()
1372  {
1373  	response_l.put ("count", std::to_string (node.ledger.cache.block_count));
1374  	response_l.put ("unchecked", std::to_string (node.unchecked.count ()));
1375  	response_l.put ("cemented", std::to_string (node.ledger.cache.cemented_count));
1376  	if (node.flags.enable_pruning)
1377  	{
1378  		response_l.put ("full", std::to_string (node.ledger.cache.block_count - node.ledger.cache.pruned_count));
1379  		response_l.put ("pruned", std::to_string (node.ledger.cache.pruned_count));
1380  	}
1381  	response_errors ();
1382  }
1383  void nano::json_handler::block_create ()
1384  {
1385  	std::string type (request.get<std::string> ("type"));
1386  	nano::wallet_id wallet (0);
1387  	auto work_version (work_version_optional_impl (nano::work_version::work_1));
1388  	auto difficulty_l (difficulty_optional_impl (work_version));
1389  	boost::optional<std::string> wallet_text (request.get_optional<std::string> ("wallet"));
1390  	if (!ec && wallet_text.is_initialized ())
1391  	{
1392  		if (wallet.decode_hex (wallet_text.get ()))
1393  		{
1394  			ec = nano::error_common::bad_wallet_number;
1395  		}
1396  	}
1397  	nano::account account{};
1398  	boost::optional<std::string> account_text (request.get_optional<std::string> ("account"));
1399  	if (!ec && account_text.is_initialized ())
1400  	{
1401  		account = account_impl (account_text.get ());
1402  	}
1403  	nano::account representative{};
1404  	boost::optional<std::string> representative_text (request.get_optional<std::string> ("representative"));
1405  	if (!ec && representative_text.is_initialized ())
1406  	{
1407  		representative = account_impl (representative_text.get (), nano::error_rpc::bad_representative_number);
1408  	}
1409  	nano::account destination{};
1410  	boost::optional<std::string> destination_text (request.get_optional<std::string> ("destination"));
1411  	if (!ec && destination_text.is_initialized ())
1412  	{
1413  		destination = account_impl (destination_text.get (), nano::error_rpc::bad_destination);
1414  	}
1415  	nano::block_hash source (0);
1416  	boost::optional<std::string> source_text (request.get_optional<std::string> ("source"));
1417  	if (!ec && source_text.is_initialized ())
1418  	{
1419  		if (source.decode_hex (source_text.get ()))
1420  		{
1421  			ec = nano::error_rpc::bad_source;
1422  		}
1423  	}
1424  	nano::amount amount (0);
1425  	boost::optional<std::string> amount_text (request.get_optional<std::string> ("amount"));
1426  	if (!ec && amount_text.is_initialized ())
1427  	{
1428  		if (amount.decode_dec (amount_text.get ()))
1429  		{
1430  			ec = nano::error_common::invalid_amount;
1431  		}
1432  	}
1433  	auto work (work_optional_impl ());
1434  	nano::raw_key prv;
1435  	prv.clear ();
1436  	nano::block_hash previous (0);
1437  	nano::amount balance (0);
1438  	if (work == 0 && !node.work_generation_enabled ())
1439  	{
1440  		ec = nano::error_common::disabled_work_generation;
1441  	}
1442  	if (!ec && wallet != 0 && account != 0)
1443  	{
1444  		auto existing (node.wallets.items.find (wallet));
1445  		if (existing != node.wallets.items.end ())
1446  		{
1447  			auto transaction (node.wallets.tx_begin_read ());
1448  			auto block_transaction (node.store.tx_begin_read ());
1449  			wallet_locked_impl (transaction, existing->second);
1450  			wallet_account_impl (transaction, existing->second, account);
1451  			if (!ec)
1452  			{
1453  				existing->second->store.fetch (transaction, account, prv);
1454  				previous = node.ledger.latest (block_transaction, account);
1455  				balance = node.ledger.account_balance (block_transaction, account);
1456  			}
1457  		}
1458  		else
1459  		{
1460  			ec = nano::error_common::wallet_not_found;
1461  		}
1462  	}
1463  	boost::optional<std::string> key_text (request.get_optional<std::string> ("key"));
1464  	if (!ec && key_text.is_initialized ())
1465  	{
1466  		if (prv.decode_hex (key_text.get ()))
1467  		{
1468  			ec = nano::error_common::bad_private_key;
1469  		}
1470  	}
1471  	boost::optional<std::string> previous_text (request.get_optional<std::string> ("previous"));
1472  	if (!ec && previous_text.is_initialized ())
1473  	{
1474  		if (previous.decode_hex (previous_text.get ()))
1475  		{
1476  			ec = nano::error_rpc::bad_previous;
1477  		}
1478  	}
1479  	boost::optional<std::string> balance_text (request.get_optional<std::string> ("balance"));
1480  	if (!ec && balance_text.is_initialized ())
1481  	{
1482  		if (balance.decode_dec (balance_text.get ()))
1483  		{
1484  			ec = nano::error_rpc::invalid_balance;
1485  		}
1486  	}
1487  	nano::link link (0);
1488  	boost::optional<std::string> link_text (request.get_optional<std::string> ("link"));
1489  	if (!ec && link_text.is_initialized ())
1490  	{
1491  		if (link.decode_account (link_text.get ()))
1492  		{
1493  			if (link.decode_hex (link_text.get ()))
1494  			{
1495  				ec = nano::error_rpc::bad_link;
1496  			}
1497  		}
1498  	}
1499  	else
1500  	{
1501  		if (source.is_zero ())
1502  		{
1503  			link = destination;
1504  		}
1505  		else
1506  		{
1507  			link = source;
1508  		}
1509  	}
1510  	if (!ec)
1511  	{
1512  		auto rpc_l (shared_from_this ());
1513  		auto block_response_put_l = [rpc_l, this] (nano::block const & block_a) {
1514  			boost::property_tree::ptree response_l;
1515  			response_l.put ("hash", block_a.hash ().to_string ());
1516  			response_l.put ("difficulty", nano::to_string_hex (rpc_l->node.network_params.work.difficulty (block_a)));
1517  			bool json_block_l = request.get<bool> ("json_block", false);
1518  			if (json_block_l)
1519  			{
1520  				boost::property_tree::ptree block_node_l;
1521  				block_a.serialize_json (block_node_l);
1522  				response_l.add_child ("block", block_node_l);
1523  			}
1524  			else
1525  			{
1526  				std::string contents;
1527  				block_a.serialize_json (contents);
1528  				response_l.put ("block", contents);
1529  			}
1530  			std::stringstream ostream;
1531  			boost::property_tree::write_json (ostream, response_l);
1532  			rpc_l->response (ostream.str ());
1533  		};
1534  		auto get_callback_l = [rpc_l, block_response_put_l] (std::shared_ptr<nano::block> const & block_a) {
1535  			return [block_a, rpc_l, block_response_put_l] (boost::optional<uint64_t> const & work_a) {
1536  				if (block_a != nullptr)
1537  				{
1538  					if (work_a.is_initialized ())
1539  					{
1540  						block_a->block_work_set (*work_a);
1541  						block_response_put_l (*block_a);
1542  					}
1543  					else
1544  					{
1545  						rpc_l->ec = nano::error_common::failure_work_generation;
1546  					}
1547  				}
1548  				else
1549  				{
1550  					rpc_l->ec = nano::error_common::generic;
1551  				}
1552  				if (rpc_l->ec)
1553  				{
1554  					rpc_l->response_errors ();
1555  				}
1556  			};
1557  		};
1558  		if (prv != 0)
1559  		{
1560  			nano::account pub (nano::pub_key (prv));
1561  			if (!previous_text.is_initialized () && !balance_text.is_initialized ())
1562  			{
1563  				auto transaction (node.store.tx_begin_read ());
1564  				previous = node.ledger.latest (transaction, pub);
1565  				balance = node.ledger.account_balance (transaction, pub);
1566  			}
1567  			else if (previous_text.is_initialized () && balance_text.is_initialized () && type == "send")
1568  			{
1569  				auto transaction (node.store.tx_begin_read ());
1570  				if (node.store.block.exists (transaction, previous) && node.store.block.balance (transaction, previous) != balance.number ())
1571  				{
1572  					ec = nano::error_rpc::block_create_balance_mismatch;
1573  				}
1574  			}
1575  			if (!ec && account_text.is_initialized ())
1576  			{
1577  				if (account != pub)
1578  				{
1579  					ec = nano::error_rpc::block_create_public_key_mismatch;
1580  				}
1581  			}
1582  			nano::block_builder builder_l;
1583  			std::shared_ptr<nano::block> block_l{ nullptr };
1584  			nano::root root_l;
1585  			std::error_code ec_build;
1586  			if (type == "state")
1587  			{
1588  				if (previous_text.is_initialized () && !representative.is_zero () && (!link.is_zero () || link_text.is_initialized ()))
1589  				{
1590  					block_l = builder_l.state ()
1591  							  .account (pub)
1592  							  .previous (previous)
1593  							  .representative (representative)
1594  							  .balance (balance)
1595  							  .link (link)
1596  							  .sign (prv, pub)
1597  							  .build (ec_build);
1598  					if (previous.is_zero ())
1599  					{
1600  						root_l = pub;
1601  					}
1602  					else
1603  					{
1604  						root_l = previous;
1605  					}
1606  				}
1607  				else
1608  				{
1609  					ec = nano::error_rpc::block_create_requirements_state;
1610  				}
1611  			}
1612  			else if (type == "open")
1613  			{
1614  				if (representative != 0 && source != 0)
1615  				{
1616  					block_l = builder_l.open ()
1617  							  .account (pub)
1618  							  .source (source)
1619  							  .representative (representative)
1620  							  .sign (prv, pub)
1621  							  .build (ec_build);
1622  					root_l = pub;
1623  				}
1624  				else
1625  				{
1626  					ec = nano::error_rpc::block_create_requirements_open;
1627  				}
1628  			}
1629  			else if (type == "receive")
1630  			{
1631  				if (source != 0 && previous != 0)
1632  				{
1633  					block_l = builder_l.receive ()
1634  							  .previous (previous)
1635  							  .source (source)
1636  							  .sign (prv, pub)
1637  							  .build (ec_build);
1638  					root_l = previous;
1639  				}
1640  				else
1641  				{
1642  					ec = nano::error_rpc::block_create_requirements_receive;
1643  				}
1644  			}
1645  			else if (type == "change")
1646  			{
1647  				if (representative != 0 && previous != 0)
1648  				{
1649  					block_l = builder_l.change ()
1650  							  .previous (previous)
1651  							  .representative (representative)
1652  							  .sign (prv, pub)
1653  							  .build (ec_build);
1654  					root_l = previous;
1655  				}
1656  				else
1657  				{
1658  					ec = nano::error_rpc::block_create_requirements_change;
1659  				}
1660  			}
1661  			else if (type == "send")
1662  			{
1663  				if (destination != 0 && previous != 0 && balance != 0 && amount != 0)
1664  				{
1665  					if (balance.number () >= amount.number ())
1666  					{
1667  						block_l = builder_l.send ()
1668  								  .previous (previous)
1669  								  .destination (destination)
1670  								  .balance (balance.number () - amount.number ())
1671  								  .sign (prv, pub)
1672  								  .build (ec_build);
1673  						root_l = previous;
1674  					}
1675  					else
1676  					{
1677  						ec = nano::error_common::insufficient_balance;
1678  					}
1679  				}
1680  				else
1681  				{
1682  					ec = nano::error_rpc::block_create_requirements_send;
1683  				}
1684  			}
1685  			else
1686  			{
1687  				ec = nano::error_blocks::invalid_type;
1688  			}
1689  			if (!ec && (!ec_build || ec_build == nano::error_common::missing_work))
1690  			{
1691  				if (work == 0)
1692  				{
1693  					if (request.count ("difficulty") == 0)
1694  					{
1695  						difficulty_l = difficulty_ledger (*block_l);
1696  					}
1697  					node.work_generate (work_version, root_l, difficulty_l, get_callback_l (block_l), nano::account (pub));
1698  				}
1699  				else
1700  				{
1701  					block_l->block_work_set (work);
1702  					block_response_put_l (*block_l);
1703  				}
1704  			}
1705  		}
1706  		else
1707  		{
1708  			ec = nano::error_rpc::block_create_key_required;
1709  		}
1710  	}
1711  	if (ec)
1712  	{
1713  		response_errors ();
1714  	}
1715  }
1716  void nano::json_handler::block_hash ()
1717  {
1718  	auto block (block_impl (true));
1719  	if (!ec)
1720  	{
1721  		response_l.put ("hash", block->hash ().to_string ());
1722  	}
1723  	response_errors ();
1724  }
1725  void nano::json_handler::bootstrap ()
1726  {
1727  	std::string address_text = request.get<std::string> ("address");
1728  	std::string port_text = request.get<std::string> ("port");
1729  	boost::system::error_code address_ec;
1730  	auto address (boost::asio::ip::make_address_v6 (address_text, address_ec));
1731  	if (!address_ec)
1732  	{
1733  		uint16_t port;
1734  		if (!nano::parse_port (port_text, port))
1735  		{
1736  			if (!node.flags.disable_legacy_bootstrap)
1737  			{
1738  				std::string bootstrap_id (request.get<std::string> ("id", ""));
1739  				node.bootstrap_initiator.bootstrap (nano::endpoint (address, port), true, bootstrap_id);
1740  				response_l.put ("success", "");
1741  			}
1742  			else
1743  			{
1744  				ec = nano::error_rpc::disabled_bootstrap_legacy;
1745  			}
1746  		}
1747  		else
1748  		{
1749  			ec = nano::error_common::invalid_port;
1750  		}
1751  	}
1752  	else
1753  	{
1754  		ec = nano::error_common::invalid_ip_address;
1755  	}
1756  	response_errors ();
1757  }
1758  void nano::json_handler::bootstrap_any ()
1759  {
1760  	bool const force = request.get<bool> ("force", false);
1761  	if (!node.flags.disable_legacy_bootstrap)
1762  	{
1763  		nano::account start_account{};
1764  		boost::optional<std::string> account_text (request.get_optional<std::string> ("account"));
1765  		if (account_text.is_initialized ())
1766  		{
1767  			start_account = account_impl (account_text.get ());
1768  		}
1769  		std::string bootstrap_id (request.get<std::string> ("id", ""));
1770  		node.bootstrap_initiator.bootstrap (force, bootstrap_id, std::numeric_limits<uint32_t>::max (), start_account);
1771  		response_l.put ("success", "");
1772  	}
1773  	else
1774  	{
1775  		ec = nano::error_rpc::disabled_bootstrap_legacy;
1776  	}
1777  	response_errors ();
1778  }
1779  void nano::json_handler::bootstrap_lazy ()
1780  {
1781  	auto hash (hash_impl ());
1782  	bool const force = request.get<bool> ("force", false);
1783  	if (!ec)
1784  	{
1785  		if (!node.flags.disable_lazy_bootstrap)
1786  		{
1787  			auto existed (node.bootstrap_initiator.current_lazy_attempt () != nullptr);
1788  			std::string bootstrap_id (request.get<std::string> ("id", ""));
1789  			auto key_inserted (node.bootstrap_initiator.bootstrap_lazy (hash, force, bootstrap_id));
1790  			bool started = !existed && key_inserted;
1791  			response_l.put ("started", started ? "1" : "0");
1792  			response_l.put ("key_inserted", key_inserted ? "1" : "0");
1793  		}
1794  		else
1795  		{
1796  			ec = nano::error_rpc::disabled_bootstrap_lazy;
1797  		}
1798  	}
1799  	response_errors ();
1800  }
1801  void nano::json_handler::bootstrap_status ()
1802  {
1803  	auto attempts_count (node.bootstrap_initiator.attempts.size ());
1804  	response_l.put ("bootstrap_threads", std::to_string (node.config.bootstrap_initiator_threads));
1805  	response_l.put ("running_attempts_count", std::to_string (attempts_count));
1806  	response_l.put ("total_attempts_count", std::to_string (node.bootstrap_initiator.attempts.incremental));
1807  	boost::property_tree::ptree connections;
1808  	{
1809  		nano::lock_guard<nano::mutex> connections_lock (node.bootstrap_initiator.connections->mutex);
1810  		connections.put ("clients", std::to_string (node.bootstrap_initiator.connections->clients.size ()));
1811  		connections.put ("connections", std::to_string (node.bootstrap_initiator.connections->connections_count));
1812  		connections.put ("idle", std::to_string (node.bootstrap_initiator.connections->idle.size ()));
1813  		connections.put ("target_connections", std::to_string (node.bootstrap_initiator.connections->target_connections (node.bootstrap_initiator.connections->pulls.size (), attempts_count)));
1814  		connections.put ("pulls", std::to_string (node.bootstrap_initiator.connections->pulls.size ()));
1815  	}
1816  	response_l.add_child ("connections", connections);
1817  	boost::property_tree::ptree attempts;
1818  	{
1819  		nano::lock_guard<nano::mutex> attempts_lock (node.bootstrap_initiator.attempts.bootstrap_attempts_mutex);
1820  		for (auto i : node.bootstrap_initiator.attempts.attempts)
1821  		{
1822  			boost::property_tree::ptree entry;
1823  			auto & attempt (i.second);
1824  			entry.put ("id", attempt->id);
1825  			entry.put ("mode", attempt->mode_text ());
1826  			entry.put ("started", static_cast<bool> (attempt->started));
1827  			entry.put ("pulling", std::to_string (attempt->pulling));
1828  			entry.put ("total_blocks", std::to_string (attempt->total_blocks));
1829  			entry.put ("requeued_pulls", std::to_string (attempt->requeued_pulls));
1830  			attempt->get_information (entry);
1831  			entry.put ("duration", std::chrono::duration_cast<std::chrono::seconds> (std::chrono::steady_clock::now () - attempt->attempt_start).count ());
1832  			attempts.push_back (std::make_pair ("", entry));
1833  		}
1834  	}
1835  	response_l.add_child ("attempts", attempts);
1836  	response_errors ();
1837  }
1838  void nano::json_handler::chain (bool successors)
1839  {
1840  	successors = successors != request.get<bool> ("reverse", false);
1841  	auto hash (hash_impl ("block"));
1842  	auto count (count_impl ());
1843  	auto offset (offset_optional_impl (0));
1844  	if (!ec)
1845  	{
1846  		boost::property_tree::ptree blocks;
1847  		auto transaction (node.store.tx_begin_read ());
1848  		while (!hash.is_zero () && blocks.size () < count)
1849  		{
1850  			auto block_l (node.store.block.get (transaction, hash));
1851  			if (block_l != nullptr)
1852  			{
1853  				if (offset > 0)
1854  				{
1855  					--offset;
1856  				}
1857  				else
1858  				{
1859  					boost::property_tree::ptree entry;
1860  					entry.put ("", hash.to_string ());
1861  					blocks.push_back (std::make_pair ("", entry));
1862  				}
1863  				hash = successors ? node.store.block.successor (transaction, hash) : block_l->previous ();
1864  			}
1865  			else
1866  			{
1867  				hash.clear ();
1868  			}
1869  		}
1870  		response_l.add_child ("blocks", blocks);
1871  	}
1872  	response_errors ();
1873  }
1874  void nano::json_handler::confirmation_active ()
1875  {
1876  	uint64_t announcements (0);
1877  	uint64_t confirmed (0);
1878  	boost::optional<std::string> announcements_text (request.get_optional<std::string> ("announcements"));
1879  	if (announcements_text.is_initialized ())
1880  	{
1881  		announcements = strtoul (announcements_text.get ().c_str (), NULL, 10);
1882  	}
1883  	boost::property_tree::ptree elections;
1884  	auto active_elections = node.active.list_active ();
1885  	for (auto const & election : active_elections)
1886  	{
1887  		if (election->confirmation_request_count >= announcements)
1888  		{
1889  			if (!election->confirmed ())
1890  			{
1891  				boost::property_tree::ptree entry;
1892  				entry.put ("", election->qualified_root.to_string ());
1893  				elections.push_back (std::make_pair ("", entry));
1894  			}
1895  			else
1896  			{
1897  				++confirmed;
1898  			}
1899  		}
1900  	}
1901  	response_l.add_child ("confirmations", elections);
1902  	response_l.put ("unconfirmed", elections.size ());
1903  	response_l.put ("confirmed", confirmed);
1904  	response_errors ();
1905  }
1906  void nano::json_handler::confirmation_height_currently_processing ()
1907  {
1908  	auto hash = node.confirmation_height_processor.current ();
1909  	if (!hash.is_zero ())
1910  	{
1911  		response_l.put ("hash", hash.to_string ());
1912  	}
1913  	else
1914  	{
1915  		ec = nano::error_rpc::confirmation_height_not_processing;
1916  	}
1917  	response_errors ();
1918  }
1919  void nano::json_handler::confirmation_history ()
1920  {
1921  	boost::property_tree::ptree elections;
1922  	boost::property_tree::ptree confirmation_stats;
1923  	std::chrono::milliseconds running_total (0);
1924  	nano::block_hash hash (0);
1925  	boost::optional<std::string> hash_text (request.get_optional<std::string> ("hash"));
1926  	if (hash_text.is_initialized ())
1927  	{
1928  		hash = hash_impl ();
1929  	}
1930  	if (!ec)
1931  	{
1932  		for (auto const & status : node.active.recently_cemented.list ())
1933  		{
1934  			if (hash.is_zero () || status.winner->hash () == hash)
1935  			{
1936  				boost::property_tree::ptree election;
1937  				election.put ("hash", status.winner->hash ().to_string ());
1938  				election.put ("duration", status.election_duration.count ());
1939  				election.put ("time", status.election_end.count ());
1940  				election.put ("tally", status.tally.to_string_dec ());
1941  				election.add ("final", status.final_tally.to_string_dec ());
1942  				election.put ("blocks", std::to_string (status.block_count));
1943  				election.put ("voters", std::to_string (status.voter_count));
1944  				election.put ("request_count", std::to_string (status.confirmation_request_count));
1945  				elections.push_back (std::make_pair ("", election));
1946  			}
1947  			running_total += status.election_duration;
1948  		}
1949  	}
1950  	confirmation_stats.put ("count", elections.size ());
1951  	if (elections.size () >= 1)
1952  	{
1953  		confirmation_stats.put ("average", (running_total.count ()) / elections.size ());
1954  	}
1955  	response_l.add_child ("confirmation_stats", confirmation_stats);
1956  	response_l.add_child ("confirmations", elections);
1957  	response_errors ();
1958  }
1959  void nano::json_handler::confirmation_info ()
1960  {
1961  	bool const representatives = request.get<bool> ("representatives", false);
1962  	bool const contents = request.get<bool> ("contents", true);
1963  	bool const json_block_l = request.get<bool> ("json_block", false);
1964  	std::string root_text (request.get<std::string> ("root"));
1965  	nano::qualified_root root;
1966  	if (!root.decode_hex (root_text))
1967  	{
1968  		auto election (node.active.election (root));
1969  		if (election != nullptr && !election->confirmed ())
1970  		{
1971  			auto info = election->current_status ();
1972  			response_l.put ("announcements", std::to_string (info.status.confirmation_request_count));
1973  			response_l.put ("voters", std::to_string (info.votes.size ()));
1974  			response_l.put ("last_winner", info.status.winner->hash ().to_string ());
1975  			nano::uint128_t total (0);
1976  			boost::property_tree::ptree blocks;
1977  			for (auto const & [tally, block] : info.tally)
1978  			{
1979  				boost::property_tree::ptree entry;
1980  				entry.put ("tally", tally.convert_to<std::string> ());
1981  				total += tally;
1982  				if (contents)
1983  				{
1984  					if (json_block_l)
1985  					{
1986  						boost::property_tree::ptree block_node_l;
1987  						block->serialize_json (block_node_l);
1988  						entry.add_child ("contents", block_node_l);
1989  					}
1990  					else
1991  					{
1992  						std::string contents;
1993  						block->serialize_json (contents);
1994  						entry.put ("contents", contents);
1995  					}
1996  				}
1997  				if (representatives)
1998  				{
1999  					std::multimap<nano::uint128_t, nano::account, std::greater<nano::uint128_t>> representatives;
2000  					for (auto const & [representative, vote] : info.votes)
2001  					{
2002  						if (block->hash () == vote.hash)
2003  						{
2004  							auto amount (node.ledger.cache.rep_weights.representation_get (representative));
2005  							representatives.emplace (std::move (amount), representative);
2006  						}
2007  					}
2008  					boost::property_tree::ptree representatives_list;
2009  					for (auto const & [amount, representative] : representatives)
2010  					{
2011  						representatives_list.put (representative.to_account (), amount.convert_to<std::string> ());
2012  					}
2013  					entry.add_child ("representatives", representatives_list);
2014  				}
2015  				blocks.add_child ((block->hash ()).to_string (), entry);
2016  			}
2017  			response_l.put ("total_tally", total.convert_to<std::string> ());
2018  			response_l.put ("final_tally", info.status.final_tally.to_string_dec ());
2019  			response_l.add_child ("blocks", blocks);
2020  		}
2021  		else
2022  		{
2023  			ec = nano::error_rpc::confirmation_not_found;
2024  		}
2025  	}
2026  	else
2027  	{
2028  		ec = nano::error_rpc::invalid_root;
2029  	}
2030  	response_errors ();
2031  }
2032  void nano::json_handler::confirmation_quorum ()
2033  {
2034  	response_l.put ("quorum_delta", node.online_reps.delta ().convert_to<std::string> ());
2035  	response_l.put ("online_weight_quorum_percent", std::to_string (node.online_reps.online_weight_quorum));
2036  	response_l.put ("online_weight_minimum", node.config.online_weight_minimum.to_string_dec ());
2037  	response_l.put ("online_stake_total", node.online_reps.online ().convert_to<std::string> ());
2038  	response_l.put ("trended_stake_total", node.online_reps.trended ().convert_to<std::string> ());
2039  	response_l.put ("peers_stake_total", node.rep_crawler.total_weight ().convert_to<std::string> ());
2040  	if (request.get<bool> ("peer_details", false))
2041  	{
2042  		boost::property_tree::ptree peers;
2043  		for (auto & peer : node.rep_crawler.representatives ())
2044  		{
2045  			boost::property_tree::ptree peer_node;
2046  			peer_node.put ("account", peer.account.to_account ());
2047  			peer_node.put ("ip", peer.channel->to_string ());
2048  			peer_node.put ("weight", nano::amount{ node.ledger.weight (peer.account) }.to_string_dec ());
2049  			peers.push_back (std::make_pair ("", peer_node));
2050  		}
2051  		response_l.add_child ("peers", peers);
2052  	}
2053  	response_errors ();
2054  }
2055  void nano::json_handler::database_txn_tracker ()
2056  {
2057  	boost::property_tree::ptree json;
2058  	if (node.config.diagnostics_config.txn_tracking.enable)
2059  	{
2060  		unsigned min_read_time_milliseconds = 0;
2061  		boost::optional<std::string> min_read_time_text (request.get_optional<std::string> ("min_read_time"));
2062  		if (min_read_time_text.is_initialized ())
2063  		{
2064  			auto success = boost::conversion::try_lexical_convert<unsigned> (*min_read_time_text, min_read_time_milliseconds);
2065  			if (!success)
2066  			{
2067  				ec = nano::error_common::invalid_amount;
2068  			}
2069  		}
2070  		unsigned min_write_time_milliseconds = 0;
2071  		if (!ec)
2072  		{
2073  			boost::optional<std::string> min_write_time_text (request.get_optional<std::string> ("min_write_time"));
2074  			if (min_write_time_text.is_initialized ())
2075  			{
2076  				auto success = boost::conversion::try_lexical_convert<unsigned> (*min_write_time_text, min_write_time_milliseconds);
2077  				if (!success)
2078  				{
2079  					ec = nano::error_common::invalid_amount;
2080  				}
2081  			}
2082  		}
2083  		if (!ec)
2084  		{
2085  			node.store.serialize_mdb_tracker (json, std::chrono::milliseconds (min_read_time_milliseconds), std::chrono::milliseconds (min_write_time_milliseconds));
2086  			response_l.put_child ("txn_tracking", json);
2087  		}
2088  	}
2089  	else
2090  	{
2091  		ec = nano::error_common::tracking_not_enabled;
2092  	}
2093  	response_errors ();
2094  }
2095  void nano::json_handler::delegators ()
2096  {
2097  	auto representative (account_impl ());
2098  	auto count (count_optional_impl (1024));
2099  	auto threshold (threshold_optional_impl ());
2100  	auto start_account_text (request.get_optional<std::string> ("start"));
2101  	nano::account start_account{};
2102  	if (!ec && start_account_text.is_initialized ())
2103  	{
2104  		start_account = account_impl (start_account_text.get ());
2105  	}
2106  	if (!ec)
2107  	{
2108  		auto transaction (node.store.tx_begin_read ());
2109  		boost::property_tree::ptree delegators;
2110  		for (auto i (node.store.account.begin (transaction, start_account.number () + 1)), n (node.store.account.end ()); i != n && delegators.size () < count; ++i)
2111  		{
2112  			nano::account_info const & info (i->second);
2113  			if (info.representative == representative)
2114  			{
2115  				if (info.balance.number () >= threshold.number ())
2116  				{
2117  					std::string balance;
2118  					nano::uint128_union (info.balance).encode_dec (balance);
2119  					nano::account const & delegator (i->first);
2120  					delegators.put (delegator.to_account (), balance);
2121  				}
2122  			}
2123  		}
2124  		response_l.add_child ("delegators", delegators);
2125  	}
2126  	response_errors ();
2127  }
2128  void nano::json_handler::delegators_count ()
2129  {
2130  	auto account (account_impl ());
2131  	if (!ec)
2132  	{
2133  		uint64_t count (0);
2134  		auto transaction (node.store.tx_begin_read ());
2135  		for (auto i (node.store.account.begin (transaction)), n (node.store.account.end ()); i != n; ++i)
2136  		{
2137  			nano::account_info const & info (i->second);
2138  			if (info.representative == account)
2139  			{
2140  				++count;
2141  			}
2142  		}
2143  		response_l.put ("count", std::to_string (count));
2144  	}
2145  	response_errors ();
2146  }
2147  void nano::json_handler::deterministic_key ()
2148  {
2149  	std::string seed_text (request.get<std::string> ("seed"));
2150  	std::string index_text (request.get<std::string> ("index"));
2151  	nano::raw_key seed;
2152  	if (!seed.decode_hex (seed_text))
2153  	{
2154  		try
2155  		{
2156  			uint32_t index (std::stoul (index_text));
2157  			nano::raw_key prv = nano::deterministic_key (seed, index);
2158  			nano::public_key pub (nano::pub_key (prv));
2159  			response_l.put ("private", prv.to_string ());
2160  			response_l.put ("public", pub.to_string ());
2161  			response_l.put ("account", pub.to_account ());
2162  		}
2163  		catch (std::logic_error const &)
2164  		{
2165  			ec = nano::error_common::invalid_index;
2166  		}
2167  	}
2168  	else
2169  	{
2170  		ec = nano::error_common::bad_seed;
2171  	}
2172  	response_errors ();
2173  }
2174  void nano::json_handler::epoch_upgrade ()
2175  {
2176  	nano::epoch epoch (nano::epoch::invalid);
2177  	uint8_t epoch_int (request.get<uint8_t> ("epoch"));
2178  	switch (epoch_int)
2179  	{
2180  		case 1:
2181  			epoch = nano::epoch::epoch_1;
2182  			break;
2183  		case 2:
2184  			epoch = nano::epoch::epoch_2;
2185  			break;
2186  		default:
2187  			break;
2188  	}
2189  	if (epoch != nano::epoch::invalid)
2190  	{
2191  		uint64_t count_limit (count_optional_impl ());
2192  		uint64_t threads (0);
2193  		boost::optional<std::string> threads_text (request.get_optional<std::string> ("threads"));
2194  		if (!ec && threads_text.is_initialized ())
2195  		{
2196  			if (decode_unsigned (threads_text.get (), threads))
2197  			{
2198  				ec = nano::error_rpc::invalid_threads_count;
2199  			}
2200  		}
2201  		std::string key_text (request.get<std::string> ("key"));
2202  		nano::raw_key prv;
2203  		if (!prv.decode_hex (key_text))
2204  		{
2205  			if (nano::pub_key (prv) == node.ledger.epoch_signer (node.ledger.epoch_link (epoch)))
2206  			{
2207  				if (!node.epoch_upgrader.start (prv, epoch, count_limit, threads))
2208  				{
2209  					response_l.put ("started", "1");
2210  				}
2211  				else
2212  				{
2213  					response_l.put ("started", "0");
2214  				}
2215  			}
2216  			else
2217  			{
2218  				ec = nano::error_rpc::invalid_epoch_signer;
2219  			}
2220  		}
2221  		else
2222  		{
2223  			ec = nano::error_common::bad_private_key;
2224  		}
2225  	}
2226  	else
2227  	{
2228  		ec = nano::error_rpc::invalid_epoch;
2229  	}
2230  	response_errors ();
2231  }
2232  void nano::json_handler::frontiers ()
2233  {
2234  	auto start (account_impl ());
2235  	auto count (count_impl ());
2236  	if (!ec)
2237  	{
2238  		boost::property_tree::ptree frontiers;
2239  		auto transaction (node.store.tx_begin_read ());
2240  		for (auto i (node.store.account.begin (transaction, start)), n (node.store.account.end ()); i != n && frontiers.size () < count; ++i)
2241  		{
2242  			frontiers.put (i->first.to_account (), i->second.head.to_string ());
2243  		}
2244  		response_l.add_child ("frontiers", frontiers);
2245  	}
2246  	response_errors ();
2247  }
2248  void nano::json_handler::account_count ()
2249  {
2250  	auto size (node.ledger.cache.account_count.load ());
2251  	response_l.put ("count", std::to_string (size));
2252  	response_errors ();
2253  }
2254  namespace
2255  {
2256  class history_visitor : public nano::block_visitor
2257  {
2258  public:
2259  	history_visitor (nano::json_handler & handler_a, bool raw_a, nano::transaction & transaction_a, boost::property_tree::ptree & tree_a, nano::block_hash const & hash_a, std::vector<nano::public_key> const & accounts_filter_a) :
2260  		handler (handler_a),
2261  		raw (raw_a),
2262  		transaction (transaction_a),
2263  		tree (tree_a),
2264  		hash (hash_a),
2265  		accounts_filter (accounts_filter_a)
2266  	{
2267  	}
2268  	virtual ~history_visitor () = default;
2269  	void send_block (nano::send_block const & block_a)
2270  	{
2271  		if (should_ignore_account (block_a.hashables.destination))
2272  		{
2273  			return;
2274  		}
2275  		tree.put ("type", "send");
2276  		auto account (block_a.hashables.destination.to_account ());
2277  		tree.put ("account", account);
2278  		bool error_or_pruned (false);
2279  		auto amount (handler.node.ledger.amount_safe (transaction, hash, error_or_pruned).convert_to<std::string> ());
2280  		if (!error_or_pruned)
2281  		{
2282  			tree.put ("amount", amount);
2283  		}
2284  		if (raw)
2285  		{
2286  			tree.put ("destination", account);
2287  			tree.put ("balance", block_a.hashables.balance.to_string_dec ());
2288  			tree.put ("previous", block_a.hashables.previous.to_string ());
2289  		}
2290  	}
2291  	void receive_block (nano::receive_block const & block_a)
2292  	{
2293  		tree.put ("type", "receive");
2294  		bool error_or_pruned (false);
2295  		auto amount (handler.node.ledger.amount_safe (transaction, hash, error_or_pruned).convert_to<std::string> ());
2296  		if (!error_or_pruned)
2297  		{
2298  			auto source_account (handler.node.ledger.account_safe (transaction, block_a.hashables.source, error_or_pruned));
2299  			if (!error_or_pruned)
2300  			{
2301  				tree.put ("account", source_account.to_account ());
2302  			}
2303  			tree.put ("amount", amount);
2304  		}
2305  		if (raw)
2306  		{
2307  			tree.put ("source", block_a.hashables.source.to_string ());
2308  			tree.put ("previous", block_a.hashables.previous.to_string ());
2309  		}
2310  	}
2311  	void open_block (nano::open_block const & block_a)
2312  	{
2313  		if (raw)
2314  		{
2315  			tree.put ("type", "open");
2316  			tree.put ("representative", block_a.hashables.representative.to_account ());
2317  			tree.put ("source", block_a.hashables.source.to_string ());
2318  			tree.put ("opened", block_a.hashables.account.to_account ());
2319  		}
2320  		else
2321  		{
2322  			tree.put ("type", "receive");
2323  		}
2324  		if (block_a.hashables.source != handler.node.ledger.constants.genesis->account ())
2325  		{
2326  			bool error_or_pruned (false);
2327  			auto amount (handler.node.ledger.amount_safe (transaction, hash, error_or_pruned).convert_to<std::string> ());
2328  			if (!error_or_pruned)
2329  			{
2330  				auto source_account (handler.node.ledger.account_safe (transaction, block_a.hashables.source, error_or_pruned));
2331  				if (!error_or_pruned)
2332  				{
2333  					tree.put ("account", source_account.to_account ());
2334  				}
2335  				tree.put ("amount", amount);
2336  			}
2337  		}
2338  		else
2339  		{
2340  			tree.put ("account", handler.node.ledger.constants.genesis->account ().to_account ());
2341  			tree.put ("amount", nano::dev::constants.genesis_amount.convert_to<std::string> ());
2342  		}
2343  	}
2344  	void change_block (nano::change_block const & block_a)
2345  	{
2346  		if (raw && accounts_filter.empty ())
2347  		{
2348  			tree.put ("type", "change");
2349  			tree.put ("representative", block_a.hashables.representative.to_account ());
2350  			tree.put ("previous", block_a.hashables.previous.to_string ());
2351  		}
2352  	}
2353  	void state_block (nano::state_block const & block_a)
2354  	{
2355  		if (raw)
2356  		{
2357  			tree.put ("type", "state");
2358  			tree.put ("representative", block_a.hashables.representative.to_account ());
2359  			tree.put ("link", block_a.hashables.link.to_string ());
2360  			tree.put ("balance", block_a.hashables.balance.to_string_dec ());
2361  			tree.put ("previous", block_a.hashables.previous.to_string ());
2362  		}
2363  		auto balance (block_a.hashables.balance.number ());
2364  		bool error_or_pruned (false);
2365  		auto previous_balance (handler.node.ledger.balance_safe (transaction, block_a.hashables.previous, error_or_pruned));
2366  		if (error_or_pruned)
2367  		{
2368  			if (raw)
2369  			{
2370  				tree.put ("subtype", "unknown");
2371  			}
2372  			else
2373  			{
2374  				tree.put ("type", "unknown");
2375  			}
2376  		}
2377  		else if (balance < previous_balance)
2378  		{
2379  			if (should_ignore_account (block_a.hashables.link.as_account ()))
2380  			{
2381  				tree.clear ();
2382  				return;
2383  			}
2384  			if (raw)
2385  			{
2386  				tree.put ("subtype", "send");
2387  			}
2388  			else
2389  			{
2390  				tree.put ("type", "send");
2391  			}
2392  			tree.put ("account", block_a.hashables.link.to_account ());
2393  			tree.put ("amount", (previous_balance - balance).convert_to<std::string> ());
2394  		}
2395  		else
2396  		{
2397  			if (block_a.hashables.link.is_zero ())
2398  			{
2399  				if (raw && accounts_filter.empty ())
2400  				{
2401  					tree.put ("subtype", "change");
2402  				}
2403  			}
2404  			else if (balance == previous_balance && handler.node.ledger.is_epoch_link (block_a.hashables.link))
2405  			{
2406  				if (raw && accounts_filter.empty ())
2407  				{
2408  					tree.put ("subtype", "epoch");
2409  					tree.put ("account", handler.node.ledger.epoch_signer (block_a.link ()).to_account ());
2410  				}
2411  			}
2412  			else
2413  			{
2414  				auto source_account (handler.node.ledger.account_safe (transaction, block_a.hashables.link.as_block_hash (), error_or_pruned));
2415  				if (!error_or_pruned && should_ignore_account (source_account))
2416  				{
2417  					tree.clear ();
2418  					return;
2419  				}
2420  				if (raw)
2421  				{
2422  					tree.put ("subtype", "receive");
2423  				}
2424  				else
2425  				{
2426  					tree.put ("type", "receive");
2427  				}
2428  				if (!error_or_pruned)
2429  				{
2430  					tree.put ("account", source_account.to_account ());
2431  				}
2432  				tree.put ("amount", (balance - previous_balance).convert_to<std::string> ());
2433  			}
2434  		}
2435  	}
2436  	bool should_ignore_account (nano::public_key const & account)
2437  	{
2438  		bool ignore (false);
2439  		if (!accounts_filter.empty ())
2440  		{
2441  			if (std::find (accounts_filter.begin (), accounts_filter.end (), account) == accounts_filter.end ())
2442  			{
2443  				ignore = true;
2444  			}
2445  		}
2446  		return ignore;
2447  	}
2448  	nano::json_handler & handler;
2449  	bool raw;
2450  	nano::transaction & transaction;
2451  	boost::property_tree::ptree & tree;
2452  	nano::block_hash const & hash;
2453  	std::vector<nano::public_key> const & accounts_filter;
2454  };
2455  }
2456  void nano::json_handler::account_history ()
2457  {
2458  	std::vector<nano::public_key> accounts_to_filter;
2459  	auto const accounts_filter_node = request.get_child_optional ("account_filter");
2460  	if (accounts_filter_node.is_initialized ())
2461  	{
2462  		for (auto & a : (*accounts_filter_node))
2463  		{
2464  			auto account (account_impl (a.second.get<std::string> ("")));
2465  			if (!ec)
2466  			{
<span onclick='openModal()' class='match'>2467  				accounts_to_filter.push_back (account);
2468  			}
2469  			else
2470  			{
2471  				break;
2472  			}
2473  		}
2474  	}
</span>2475  	nano::account account;
2476  	nano::block_hash hash;
2477  	bool reverse (request.get_optional<bool> ("reverse") == true);
2478  	auto head_str (request.get_optional<std::string> ("head"));
2479  	auto transaction (node.store.tx_begin_read ());
2480  	auto count (count_impl ());
2481  	auto offset (offset_optional_impl (0));
2482  	if (head_str)
2483  	{
2484  		if (!hash.decode_hex (*head_str))
2485  		{
2486  			if (node.store.block.exists (transaction, hash))
2487  			{
2488  				account = node.ledger.account (transaction, hash);
2489  			}
2490  			else
2491  			{
2492  				ec = nano::error_blocks::not_found;
2493  			}
2494  		}
2495  		else
2496  		{
2497  			ec = nano::error_blocks::bad_hash_number;
2498  		}
2499  	}
2500  	else
2501  	{
2502  		account = account_impl ();
2503  		if (!ec)
2504  		{
2505  			if (reverse)
2506  			{
2507  				auto info (account_info_impl (transaction, account));
2508  				if (!ec)
2509  				{
2510  					hash = info.open_block;
2511  				}
2512  			}
2513  			else
2514  			{
2515  				hash = node.ledger.latest (transaction, account);
2516  			}
2517  		}
2518  	}
2519  	if (!ec)
2520  	{
2521  		boost::property_tree::ptree history;
2522  		bool output_raw (request.get_optional<bool> ("raw") == true);
2523  		response_l.put ("account", account.to_account ());
2524  		auto block (node.store.block.get (transaction, hash));
2525  		while (block != nullptr && count > 0)
2526  		{
2527  			if (offset > 0)
2528  			{
2529  				--offset;
2530  			}
2531  			else
2532  			{
2533  				boost::property_tree::ptree entry;
2534  				history_visitor visitor (*this, output_raw, transaction, entry, hash, accounts_to_filter);
2535  				block->visit (visitor);
2536  				if (!entry.empty ())
2537  				{
2538  					entry.put ("local_timestamp", std::to_string (block->sideband ().timestamp));
2539  					entry.put ("height", std::to_string (block->sideband ().height));
2540  					entry.put ("hash", hash.to_string ());
2541  					entry.put ("confirmed", node.ledger.block_confirmed (transaction, hash));
2542  					if (output_raw)
2543  					{
2544  						entry.put ("work", nano::to_string_hex (block->block_work ()));
2545  						entry.put ("signature", block->block_signature ().to_string ());
2546  					}
2547  					history.push_back (std::make_pair ("", entry));
2548  					--count;
2549  				}
2550  			}
2551  			hash = reverse ? node.store.block.successor (transaction, hash) : block->previous ();
2552  			block = node.store.block.get (transaction, hash);
2553  		}
2554  		response_l.add_child ("history", history);
2555  		if (!hash.is_zero ())
2556  		{
2557  			response_l.put (reverse ? "next" : "previous", hash.to_string ());
2558  		}
2559  	}
2560  	response_errors ();
2561  }
2562  void nano::json_handler::keepalive ()
2563  {
2564  	if (!ec)
2565  	{
2566  		std::string address_text (request.get<std::string> ("address"));
2567  		std::string port_text (request.get<std::string> ("port"));
2568  		uint16_t port;
2569  		if (!nano::parse_port (port_text, port))
2570  		{
2571  			node.keepalive (address_text, port);
2572  			response_l.put ("started", "1");
2573  		}
2574  		else
2575  		{
2576  			ec = nano::error_common::invalid_port;
2577  		}
2578  	}
2579  	response_errors ();
2580  }
2581  void nano::json_handler::key_create ()
2582  {
2583  	nano::keypair pair;
2584  	response_l.put ("private", pair.prv.to_string ());
2585  	response_l.put ("public", pair.pub.to_string ());
2586  	response_l.put ("account", pair.pub.to_account ());
2587  	response_errors ();
2588  }
2589  void nano::json_handler::key_expand ()
2590  {
2591  	std::string key_text (request.get<std::string> ("key"));
2592  	nano::raw_key prv;
2593  	if (!prv.decode_hex (key_text))
2594  	{
2595  		nano::public_key pub (nano::pub_key (prv));
2596  		response_l.put ("private", prv.to_string ());
2597  		response_l.put ("public", pub.to_string ());
2598  		response_l.put ("account", pub.to_account ());
2599  	}
2600  	else
2601  	{
2602  		ec = nano::error_common::bad_private_key;
2603  	}
2604  	response_errors ();
2605  }
2606  void nano::json_handler::ledger ()
2607  {
2608  	auto count (count_optional_impl ());
2609  	auto threshold (threshold_optional_impl ());
2610  	if (!ec)
2611  	{
2612  		nano::account start{};
2613  		boost::optional<std::string> account_text (request.get_optional<std::string> ("account"));
2614  		if (account_text.is_initialized ())
2615  		{
2616  			start = account_impl (account_text.get ());
2617  		}
2618  		uint64_t modified_since (0);
2619  		boost::optional<std::string> modified_since_text (request.get_optional<std::string> ("modified_since"));
2620  		if (modified_since_text.is_initialized ())
2621  		{
2622  			if (decode_unsigned (modified_since_text.get (), modified_since))
2623  			{
2624  				ec = nano::error_rpc::invalid_timestamp;
2625  			}
2626  		}
2627  		bool const sorting = request.get<bool> ("sorting", false);
2628  		bool const representative = request.get<bool> ("representative", false);
2629  		bool const weight = request.get<bool> ("weight", false);
2630  		bool const pending = request.get<bool> ("pending", false);
2631  		bool const receivable = request.get<bool> ("receivable", pending);
2632  		boost::property_tree::ptree accounts;
2633  		auto transaction (node.store.tx_begin_read ());
2634  		if (!ec && !sorting) 
2635  		{
2636  			for (auto i (node.store.account.begin (transaction, start)), n (node.store.account.end ()); i != n && accounts.size () < count; ++i)
2637  			{
2638  				nano::account_info const & info (i->second);
2639  				if (info.modified >= modified_since && (receivable || info.balance.number () >= threshold.number ()))
2640  				{
2641  					nano::account const & account (i->first);
2642  					boost::property_tree::ptree response_a;
2643  					if (receivable)
2644  					{
2645  						auto account_receivable = node.ledger.account_receivable (transaction, account);
2646  						if (info.balance.number () + account_receivable < threshold.number ())
2647  						{
2648  							continue;
2649  						}
2650  						response_a.put ("pending", account_receivable.convert_to<std::string> ());
2651  						response_a.put ("receivable", account_receivable.convert_to<std::string> ());
2652  					}
2653  					response_a.put ("frontier", info.head.to_string ());
2654  					response_a.put ("open_block", info.open_block.to_string ());
2655  					response_a.put ("representative_block", node.ledger.representative (transaction, info.head).to_string ());
2656  					std::string balance;
2657  					nano::uint128_union (info.balance).encode_dec (balance);
2658  					response_a.put ("balance", balance);
2659  					response_a.put ("modified_timestamp", std::to_string (info.modified));
2660  					response_a.put ("block_count", std::to_string (info.block_count));
2661  					if (representative)
2662  					{
2663  						response_a.put ("representative", info.representative.to_account ());
2664  					}
2665  					if (weight)
2666  					{
2667  						auto account_weight (node.ledger.weight (account));
2668  						response_a.put ("weight", account_weight.convert_to<std::string> ());
2669  					}
2670  					accounts.push_back (std::make_pair (account.to_account (), response_a));
2671  				}
2672  			}
2673  		}
2674  		else if (!ec) 
2675  		{
2676  			std::vector<std::pair<nano::uint128_union, nano::account>> ledger_l;
2677  			for (auto i (node.store.account.begin (transaction, start)), n (node.store.account.end ()); i != n; ++i)
2678  			{
2679  				nano::account_info const & info (i->second);
2680  				nano::uint128_union balance (info.balance);
2681  				if (info.modified >= modified_since)
2682  				{
2683  					ledger_l.emplace_back (balance, i->first);
2684  				}
2685  			}
2686  			std::sort (ledger_l.begin (), ledger_l.end ());
2687  			std::reverse (ledger_l.begin (), ledger_l.end ());
2688  			nano::account_info info;
2689  			for (auto i (ledger_l.begin ()), n (ledger_l.end ()); i != n && accounts.size () < count; ++i)
2690  			{
2691  				node.store.account.get (transaction, i->second, info);
2692  				if (receivable || info.balance.number () >= threshold.number ())
2693  				{
2694  					nano::account const & account (i->second);
2695  					boost::property_tree::ptree response_a;
2696  					if (receivable)
2697  					{
2698  						auto account_receivable = node.ledger.account_receivable (transaction, account);
2699  						if (info.balance.number () + account_receivable < threshold.number ())
2700  						{
2701  							continue;
2702  						}
2703  						response_a.put ("pending", account_receivable.convert_to<std::string> ());
2704  						response_a.put ("receivable", account_receivable.convert_to<std::string> ());
2705  					}
2706  					response_a.put ("frontier", info.head.to_string ());
2707  					response_a.put ("open_block", info.open_block.to_string ());
2708  					response_a.put ("representative_block", node.ledger.representative (transaction, info.head).to_string ());
2709  					std::string balance;
2710  					(i->first).encode_dec (balance);
2711  					response_a.put ("balance", balance);
2712  					response_a.put ("modified_timestamp", std::to_string (info.modified));
2713  					response_a.put ("block_count", std::to_string (info.block_count));
2714  					if (representative)
2715  					{
2716  						response_a.put ("representative", info.representative.to_account ());
2717  					}
2718  					if (weight)
2719  					{
2720  						auto account_weight (node.ledger.weight (account));
2721  						response_a.put ("weight", account_weight.convert_to<std::string> ());
2722  					}
2723  					accounts.push_back (std::make_pair (account.to_account (), response_a));
2724  				}
2725  			}
2726  		}
2727  		response_l.add_child ("accounts", accounts);
2728  	}
2729  	response_errors ();
2730  }
2731  void nano::json_handler::mnano_from_raw (nano::uint128_t ratio)
2732  {
2733  	auto amount (amount_impl ());
2734  	response_l.put ("deprecated", "1");
2735  	if (!ec)
2736  	{
2737  		auto result (amount.number () / ratio);
2738  		response_l.put ("amount", result.convert_to<std::string> ());
2739  	}
2740  	response_errors ();
2741  }
2742  void nano::json_handler::mnano_to_raw (nano::uint128_t ratio)
2743  {
2744  	auto amount (amount_impl ());
2745  	response_l.put ("deprecated", "1");
2746  	if (!ec)
2747  	{
2748  		auto result (amount.number () * ratio);
2749  		if (result > amount.number ())
2750  		{
2751  			response_l.put ("amount", result.convert_to<std::string> ());
2752  		}
2753  		else
2754  		{
2755  			ec = nano::error_common::invalid_amount_big;
2756  		}
2757  	}
2758  	response_errors ();
2759  }
2760  void nano::json_handler::nano_to_raw ()
2761  {
2762  	auto amount (amount_impl ());
2763  	if (!ec)
2764  	{
2765  		auto result (amount.number () * nano::Mxrb_ratio);
2766  		if (result > amount.number ())
2767  		{
2768  			response_l.put ("amount", result.convert_to<std::string> ());
2769  		}
2770  		else
2771  		{
2772  			ec = nano::error_common::invalid_amount_big;
2773  		}
2774  	}
2775  	response_errors ();
2776  }
2777  void nano::json_handler::raw_to_nano ()
2778  {
2779  	auto amount (amount_impl ());
2780  	if (!ec)
2781  	{
2782  		auto result (amount.number () / nano::Mxrb_ratio);
2783  		response_l.put ("amount", result.convert_to<std::string> ());
2784  	}
2785  	response_errors ();
2786  }
2787  void nano::json_handler::node_id ()
2788  {
2789  	if (!ec)
2790  	{
2791  		response_l.put ("private", node.node_id.prv.to_string ());
2792  		response_l.put ("public", node.node_id.pub.to_string ());
2793  		response_l.put ("as_account", node.node_id.pub.to_account ());
2794  		response_l.put ("node_id", node.node_id.pub.to_node_id ());
2795  	}
2796  	response_errors ();
2797  }
2798  void nano::json_handler::node_id_delete ()
2799  {
2800  	response_l.put ("deprecated", "1");
2801  	response_errors ();
2802  }
2803  void nano::json_handler::password_change ()
2804  {
2805  	node.workers.push_task (create_worker_task ([] (std::shared_ptr<nano::json_handler> const & rpc_l) {
2806  		auto wallet (rpc_l->wallet_impl ());
2807  		if (!rpc_l->ec)
2808  		{
2809  			auto transaction (rpc_l->node.wallets.tx_begin_write ());
2810  			rpc_l->wallet_locked_impl (transaction, wallet);
2811  			if (!rpc_l->ec)
2812  			{
2813  				std::string password_text (rpc_l->request.get<std::string> ("password"));
2814  				bool error (wallet->store.rekey (transaction, password_text));
2815  				rpc_l->response_l.put ("changed", error ? "0" : "1");
2816  				if (!error)
2817  				{
2818  					rpc_l->node.logger.try_log ("Wallet password changed");
2819  				}
2820  			}
2821  		}
2822  		rpc_l->response_errors ();
2823  	}));
2824  }
2825  void nano::json_handler::password_enter ()
2826  {
2827  	node.workers.push_task (create_worker_task ([] (std::shared_ptr<nano::json_handler> const & rpc_l) {
2828  		auto wallet (rpc_l->wallet_impl ());
2829  		if (!rpc_l->ec)
2830  		{
2831  			std::string password_text (rpc_l->request.get<std::string> ("password"));
2832  			auto transaction (wallet->wallets.tx_begin_write ());
2833  			auto error (wallet->enter_password (transaction, password_text));
2834  			rpc_l->response_l.put ("valid", error ? "0" : "1");
2835  		}
2836  		rpc_l->response_errors ();
2837  	}));
2838  }
2839  void nano::json_handler::password_valid (bool wallet_locked)
2840  {
2841  	auto wallet (wallet_impl ());
2842  	if (!ec)
2843  	{
2844  		auto transaction (node.wallets.tx_begin_read ());
2845  		auto valid (wallet->store.valid_password (transaction));
2846  		if (!wallet_locked)
2847  		{
2848  			response_l.put ("valid", valid ? "1" : "0");
2849  		}
2850  		else
2851  		{
2852  			response_l.put ("locked", valid ? "0" : "1");
2853  		}
2854  	}
2855  	response_errors ();
2856  }
2857  void nano::json_handler::peers ()
2858  {
2859  	boost::property_tree::ptree peers_l;
2860  	bool const peer_details = request.get<bool> ("peer_details", false);
2861  	auto peers_list (node.network.list (std::numeric_limits<std::size_t>::max ()));
2862  	std::sort (peers_list.begin (), peers_list.end (), [] (auto const & lhs, auto const & rhs) {
2863  		return lhs->get_endpoint () < rhs->get_endpoint ();
2864  	});
2865  	for (auto i (peers_list.begin ()), n (peers_list.end ()); i != n; ++i)
2866  	{
2867  		std::stringstream text;
2868  		auto channel (*i);
2869  		text << channel->to_string ();
2870  		if (peer_details)
2871  		{
2872  			boost::property_tree::ptree pending_tree;
2873  			pending_tree.put ("protocol_version", std::to_string (channel->get_network_version ()));
2874  			auto node_id_l (channel->get_node_id_optional ());
2875  			if (node_id_l.is_initialized ())
2876  			{
2877  				pending_tree.put ("node_id", node_id_l.get ().to_node_id ());
2878  			}
2879  			else
2880  			{
2881  				pending_tree.put ("node_id", "");
2882  			}
2883  			debug_assert (channel->get_type () == nano::transport::transport_type::tcp);
2884  			pending_tree.put ("type", "tcp");
2885  			peers_l.push_back (boost::property_tree::ptree::value_type (text.str (), pending_tree));
2886  		}
2887  		else
2888  		{
2889  			peers_l.push_back (boost::property_tree::ptree::value_type (text.str (), boost::property_tree::ptree (std::to_string (channel->get_network_version ()))));
2890  		}
2891  	}
2892  	response_l.add_child ("peers", peers_l);
2893  	response_errors ();
2894  }
2895  void nano::json_handler::pending ()
2896  {
2897  	response_l.put ("deprecated", "1");
2898  	receivable ();
2899  }
2900  void nano::json_handler::receivable ()
2901  {
2902  	auto account (account_impl ());
2903  	auto count (count_optional_impl ());
2904  	auto offset (offset_optional_impl (0));
2905  	auto threshold (threshold_optional_impl ());
2906  	bool const source = request.get<bool> ("source", false);
2907  	bool const min_version = request.get<bool> ("min_version", false);
2908  	bool const include_active = request.get<bool> ("include_active", false);
2909  	bool const include_only_confirmed = request.get<bool> ("include_only_confirmed", true);
2910  	bool const sorting = request.get<bool> ("sorting", false);
2911  	auto simple (threshold.is_zero () && !source && !min_version && !sorting); 
2912  	bool const should_sort = sorting && !simple;
2913  	if (!ec)
2914  	{
2915  		auto offset_counter = offset;
2916  		boost::property_tree::ptree peers_l;
2917  		auto transaction (node.store.tx_begin_read ());
2918  		std::vector<std::pair<std::string, boost::property_tree::ptree>> hash_ptree_pairs;
2919  		std::vector<std::pair<std::string, nano::uint128_t>> hash_amount_pairs;
2920  		for (auto i (node.store.pending.begin (transaction, nano::pending_key (account, 0))), n (node.store.pending.end ()); i != n && nano::pending_key (i->first).account == account && (should_sort || peers_l.size () < count); ++i)
2921  		{
2922  			nano::pending_key const & key (i->first);
2923  			if (block_confirmed (node, transaction, key.hash, include_active, include_only_confirmed))
2924  			{
2925  				if (!should_sort && offset_counter > 0)
2926  				{
2927  					--offset_counter;
2928  					continue;
2929  				}
2930  				if (simple)
2931  				{
2932  					boost::property_tree::ptree entry;
2933  					entry.put ("", key.hash.to_string ());
2934  					peers_l.push_back (std::make_pair ("", entry));
2935  				}
2936  				else
2937  				{
2938  					nano::pending_info const & info (i->second);
2939  					if (info.amount.number () >= threshold.number ())
2940  					{
2941  						if (source || min_version)
2942  						{
2943  							boost::property_tree::ptree pending_tree;
2944  							pending_tree.put ("amount", info.amount.number ().convert_to<std::string> ());
2945  							if (source)
2946  							{
2947  								pending_tree.put ("source", info.source.to_account ());
2948  							}
2949  							if (min_version)
2950  							{
2951  								pending_tree.put ("min_version", epoch_as_string (info.epoch));
2952  							}
2953  							if (should_sort)
2954  							{
2955  								hash_ptree_pairs.emplace_back (key.hash.to_string (), pending_tree);
2956  							}
2957  							else
2958  							{
2959  								peers_l.add_child (key.hash.to_string (), pending_tree);
2960  							}
2961  						}
2962  						else
2963  						{
2964  							if (should_sort)
2965  							{
2966  								hash_amount_pairs.emplace_back (key.hash.to_string (), info.amount.number ());
2967  							}
2968  							else
2969  							{
2970  								peers_l.put (key.hash.to_string (), info.amount.number ().convert_to<std::string> ());
2971  							}
2972  						}
2973  					}
2974  				}
2975  			}
2976  		}
2977  		if (should_sort)
2978  		{
2979  			if (source || min_version)
2980  			{
2981  				std::stable_sort (hash_ptree_pairs.begin (), hash_ptree_pairs.end (), [] (auto const & lhs, auto const & rhs) {
2982  					return lhs.second.template get<nano::uint128_t> ("amount") > rhs.second.template get<nano::uint128_t> ("amount");
2983  				});
2984  				for (auto i = offset, j = offset + count; i < hash_ptree_pairs.size () && i < j; ++i)
2985  				{
2986  					peers_l.add_child (hash_ptree_pairs[i].first, hash_ptree_pairs[i].second);
2987  				}
2988  			}
2989  			else
2990  			{
2991  				std::stable_sort (hash_amount_pairs.begin (), hash_amount_pairs.end (), [] (auto const & lhs, auto const & rhs) {
2992  					return lhs.second > rhs.second;
2993  				});
2994  				for (auto i = offset, j = offset + count; i < hash_amount_pairs.size () && i < j; ++i)
2995  				{
2996  					peers_l.put (hash_amount_pairs[i].first, hash_amount_pairs[i].second.convert_to<std::string> ());
2997  				}
2998  			}
2999  		}
3000  		response_l.add_child ("blocks", peers_l);
3001  	}
3002  	response_errors ();
3003  }
3004  void nano::json_handler::pending_exists ()
3005  {
3006  	response_l.put ("deprecated", "1");
3007  	receivable_exists ();
3008  }
3009  void nano::json_handler::receivable_exists ()
3010  {
3011  	auto hash (hash_impl ());
3012  	bool const include_active = request.get<bool> ("include_active", false);
3013  	bool const include_only_confirmed = request.get<bool> ("include_only_confirmed", true);
3014  	if (!ec)
3015  	{
3016  		auto transaction (node.store.tx_begin_read ());
3017  		auto block (node.store.block.get (transaction, hash));
3018  		if (block != nullptr)
3019  		{
3020  			auto exists (false);
3021  			auto destination (node.ledger.block_destination (transaction, *block));
3022  			if (!destination.is_zero ())
3023  			{
3024  				exists = node.store.pending.exists (transaction, nano::pending_key (destination, hash));
3025  			}
3026  			exists = exists && (block_confirmed (node, transaction, block->hash (), include_active, include_only_confirmed));
3027  			response_l.put ("exists", exists ? "1" : "0");
3028  		}
3029  		else
3030  		{
3031  			ec = nano::error_blocks::not_found;
3032  		}
3033  	}
3034  	response_errors ();
3035  }
3036  void nano::json_handler::process ()
3037  {
3038  	node.workers.push_task (create_worker_task ([] (std::shared_ptr<nano::json_handler> const & rpc_l) {
3039  		bool const is_async = rpc_l->request.get<bool> ("async", false);
3040  		auto block (rpc_l->block_impl (true));
3041  		if (!rpc_l->ec && block->type () == nano::block_type::state)
3042  		{
3043  			std::string subtype_text (rpc_l->request.get<std::string> ("subtype", ""));
3044  			if (!subtype_text.empty ())
3045  			{
3046  				std::shared_ptr<nano::state_block> block_state (std::static_pointer_cast<nano::state_block> (block));
3047  				auto transaction (rpc_l->node.store.tx_begin_read ());
3048  				if (!block_state->hashables.previous.is_zero () && !rpc_l->node.store.block.exists (transaction, block_state->hashables.previous))
3049  				{
3050  					rpc_l->ec = nano::error_process::gap_previous;
3051  				}
3052  				else
3053  				{
3054  					auto balance (rpc_l->node.ledger.account_balance (transaction, block_state->hashables.account));
3055  					if (subtype_text == "send")
3056  					{
3057  						if (balance <= block_state->hashables.balance.number ())
3058  						{
3059  							rpc_l->ec = nano::error_rpc::invalid_subtype_balance;
3060  						}
3061  					}
3062  					else if (subtype_text == "receive")
3063  					{
3064  						if (balance > block_state->hashables.balance.number ())
3065  						{
3066  							rpc_l->ec = nano::error_rpc::invalid_subtype_balance;
3067  						}
3068  					}
3069  					else if (subtype_text == "open")
3070  					{
3071  						if (!block_state->hashables.previous.is_zero ())
3072  						{
3073  							rpc_l->ec = nano::error_rpc::invalid_subtype_previous;
3074  						}
3075  					}
3076  					else if (subtype_text == "change")
3077  					{
3078  						if (balance != block_state->hashables.balance.number ())
3079  						{
3080  							rpc_l->ec = nano::error_rpc::invalid_subtype_balance;
3081  						}
3082  						else if (block_state->hashables.previous.is_zero ())
3083  						{
3084  							rpc_l->ec = nano::error_rpc::invalid_subtype_previous;
3085  						}
3086  					}
3087  					else if (subtype_text == "epoch")
3088  					{
3089  						if (balance != block_state->hashables.balance.number ())
3090  						{
3091  							rpc_l->ec = nano::error_rpc::invalid_subtype_balance;
3092  						}
3093  						else if (!rpc_l->node.ledger.is_epoch_link (block_state->hashables.link))
3094  						{
3095  							rpc_l->ec = nano::error_rpc::invalid_subtype_epoch_link;
3096  						}
3097  					}
3098  					else
3099  					{
3100  						rpc_l->ec = nano::error_rpc::invalid_subtype;
3101  					}
3102  				}
3103  			}
3104  		}
3105  		if (!rpc_l->ec)
3106  		{
3107  			if (!rpc_l->node.network_params.work.validate_entry (*block))
3108  			{
3109  				if (!is_async)
3110  				{
3111  					auto result_maybe = rpc_l->node.process_local (block);
3112  					if (!result_maybe)
3113  					{
3114  						rpc_l->ec = nano::error_rpc::stopped;
3115  					}
3116  					else
3117  					{
3118  						auto const & result = result_maybe.value ();
3119  						switch (result.code)
3120  						{
3121  							case nano::process_result::progress:
3122  							{
3123  								rpc_l->response_l.put ("hash", block->hash ().to_string ());
3124  								break;
3125  							}
3126  							case nano::process_result::gap_previous:
3127  							{
3128  								rpc_l->ec = nano::error_process::gap_previous;
3129  								break;
3130  							}
3131  							case nano::process_result::gap_source:
3132  							{
3133  								rpc_l->ec = nano::error_process::gap_source;
3134  								break;
3135  							}
3136  							case nano::process_result::old:
3137  							{
3138  								rpc_l->ec = nano::error_process::old;
3139  								break;
3140  							}
3141  							case nano::process_result::bad_signature:
3142  							{
3143  								rpc_l->ec = nano::error_process::bad_signature;
3144  								break;
3145  							}
3146  							case nano::process_result::negative_spend:
3147  							{
3148  								rpc_l->ec = nano::error_process::negative_spend;
3149  								break;
3150  							}
3151  							case nano::process_result::balance_mismatch:
3152  							{
3153  								rpc_l->ec = nano::error_process::balance_mismatch;
3154  								break;
3155  							}
3156  							case nano::process_result::unreceivable:
3157  							{
3158  								rpc_l->ec = nano::error_process::unreceivable;
3159  								break;
3160  							}
3161  							case nano::process_result::block_position:
3162  							{
3163  								rpc_l->ec = nano::error_process::block_position;
3164  								break;
3165  							}
3166  							case nano::process_result::gap_epoch_open_pending:
3167  							{
3168  								rpc_l->ec = nano::error_process::gap_epoch_open_pending;
3169  								break;
3170  							}
3171  							case nano::process_result::fork:
3172  							{
3173  								bool const force = rpc_l->request.get<bool> ("force", false);
3174  								if (force)
3175  								{
3176  									rpc_l->node.active.erase (*block);
3177  									rpc_l->node.block_processor.force (block);
3178  									rpc_l->response_l.put ("hash", block->hash ().to_string ());
3179  								}
3180  								else
3181  								{
3182  									rpc_l->ec = nano::error_process::fork;
3183  								}
3184  								break;
3185  							}
3186  							case nano::process_result::insufficient_work:
3187  							{
3188  								rpc_l->ec = nano::error_process::insufficient_work;
3189  								break;
3190  							}
3191  							case nano::process_result::opened_burn_account:
3192  								rpc_l->ec = nano::error_process::opened_burn_account;
3193  								break;
3194  							default:
3195  							{
3196  								rpc_l->ec = nano::error_process::other;
3197  								break;
3198  							}
3199  						}
3200  					}
3201  				}
3202  				else
3203  				{
3204  					if (block->type () == nano::block_type::state)
3205  					{
3206  						rpc_l->node.process_local_async (block);
3207  						rpc_l->response_l.put ("started", "1");
3208  					}
3209  					else
3210  					{
3211  						rpc_l->ec = nano::error_common::is_not_state_block;
3212  					}
3213  				}
3214  			}
3215  			else
3216  			{
3217  				rpc_l->ec = nano::error_blocks::work_low;
3218  			}
3219  		}
3220  		rpc_l->response_errors ();
3221  	}));
3222  }
3223  void nano::json_handler::pruned_exists ()
3224  {
3225  	auto hash (hash_impl ());
3226  	if (!ec)
3227  	{
3228  		auto transaction (node.store.tx_begin_read ());
3229  		if (node.ledger.pruning)
3230  		{
3231  			auto exists (node.store.pruned.exists (transaction, hash));
3232  			response_l.put ("exists", exists ? "1" : "0");
3233  		}
3234  		else
3235  		{
3236  			ec = nano::error_rpc::pruning_disabled;
3237  		}
3238  	}
3239  	response_errors ();
3240  }
3241  void nano::json_handler::receive ()
3242  {
3243  	auto wallet (wallet_impl ());
3244  	auto account (account_impl ());
3245  	auto hash (hash_impl ("block"));
3246  	if (!ec)
3247  	{
3248  		auto wallet_transaction (node.wallets.tx_begin_read ());
3249  		wallet_locked_impl (wallet_transaction, wallet);
3250  		wallet_account_impl (wallet_transaction, wallet, account);
3251  		if (!ec)
3252  		{
3253  			auto block_transaction (node.store.tx_begin_read ());
3254  			if (node.ledger.block_or_pruned_exists (block_transaction, hash))
3255  			{
3256  				auto pending_info = node.ledger.pending_info (block_transaction, nano::pending_key (account, hash));
3257  				if (pending_info)
3258  				{
3259  					auto work (work_optional_impl ());
3260  					if (!ec && work)
3261  					{
3262  						nano::root head;
3263  						nano::epoch epoch = pending_info->epoch;
3264  						auto info = node.ledger.account_info (block_transaction, account);
3265  						if (info)
3266  						{
3267  							head = info->head;
3268  							epoch = std::max (info->epoch (), epoch);
3269  						}
3270  						else
3271  						{
3272  							head = account;
3273  						}
3274  						nano::block_details details (epoch, false, true, false);
3275  						if (node.network_params.work.difficulty (nano::work_version::work_1, head, work) < node.network_params.work.threshold (nano::work_version::work_1, details))
3276  						{
3277  							ec = nano::error_common::invalid_work;
3278  						}
3279  					}
3280  					else if (!ec) 
3281  					{
3282  						if (!node.work_generation_enabled ())
3283  						{
3284  							ec = nano::error_common::disabled_work_generation;
3285  						}
3286  					}
3287  					if (!ec)
3288  					{
3289  						nano::account representative (wallet->store.representative (wallet_transaction));
3290  						bool generate_work (work == 0); 
3291  						auto response_a (response);
3292  						wallet->receive_async (
3293  						hash, representative, nano::dev::constants.genesis_amount, account, [response_a] (std::shared_ptr<nano::block> const & block_a) {
3294  							if (block_a != nullptr)
3295  							{
3296  								boost::property_tree::ptree response_l;
3297  								response_l.put ("block", block_a->hash ().to_string ());
3298  								std::stringstream ostream;
3299  								boost::property_tree::write_json (ostream, response_l);
3300  								response_a (ostream.str ());
3301  							}
3302  							else
3303  							{
3304  								json_error_response (response_a, "Error generating block");
3305  							}
3306  						},
3307  						work, generate_work);
3308  					}
3309  				}
3310  				else
3311  				{
3312  					ec = nano::error_process::unreceivable;
3313  				}
3314  			}
3315  			else
3316  			{
3317  				ec = nano::error_blocks::not_found;
3318  			}
3319  		}
3320  	}
3321  	if (ec)
3322  	{
3323  		response_errors ();
3324  	}
3325  }
3326  void nano::json_handler::receive_minimum ()
3327  {
3328  	if (!ec)
3329  	{
3330  		response_l.put ("amount", node.config.receive_minimum.to_string_dec ());
3331  	}
3332  	response_errors ();
3333  }
3334  void nano::json_handler::receive_minimum_set ()
3335  {
3336  	auto amount (amount_impl ());
3337  	if (!ec)
3338  	{
3339  		node.config.receive_minimum = amount;
3340  		response_l.put ("success", "");
3341  	}
3342  	response_errors ();
3343  }
3344  void nano::json_handler::representatives ()
3345  {
3346  	auto count (count_optional_impl ());
3347  	if (!ec)
3348  	{
3349  		bool const sorting = request.get<bool> ("sorting", false);
3350  		boost::property_tree::ptree representatives;
3351  		auto rep_amounts = node.ledger.cache.rep_weights.get_rep_amounts ();
3352  		if (!sorting) 
3353  		{
3354  			std::map<nano::account, nano::uint128_t> ordered (rep_amounts.begin (), rep_amounts.end ());
3355  			for (auto & rep_amount : rep_amounts)
3356  			{
3357  				auto const & account (rep_amount.first);
3358  				auto const & amount (rep_amount.second);
3359  				representatives.put (account.to_account (), amount.convert_to<std::string> ());
3360  				if (representatives.size () > count)
3361  				{
3362  					break;
3363  				}
3364  			}
3365  		}
3366  		else 
3367  		{
3368  			std::vector<std::pair<nano::uint128_t, std::string>> representation;
3369  			for (auto & rep_amount : rep_amounts)
3370  			{
3371  				auto const & account (rep_amount.first);
3372  				auto const & amount (rep_amount.second);
3373  				representation.emplace_back (amount, account.to_account ());
3374  			}
3375  			std::sort (representation.begin (), representation.end ());
3376  			std::reverse (representation.begin (), representation.end ());
3377  			for (auto i (representation.begin ()), n (representation.end ()); i != n && representatives.size () < count; ++i)
3378  			{
3379  				representatives.put (i->second, (i->first).convert_to<std::string> ());
3380  			}
3381  		}
3382  		response_l.add_child ("representatives", representatives);
3383  	}
3384  	response_errors ();
3385  }
3386  void nano::json_handler::representatives_online ()
3387  {
3388  	auto const accounts_node = request.get_child_optional ("accounts");
3389  	bool const weight = request.get<bool> ("weight", false);
3390  	std::vector<nano::public_key> accounts_to_filter;
3391  	if (accounts_node.is_initialized ())
3392  	{
3393  		for (auto & a : (*accounts_node))
3394  		{
3395  			auto account (account_impl (a.second.get<std::string> ("")));
3396  			if (!ec)
3397  			{
3398  				accounts_to_filter.push_back (account);
3399  			}
3400  			else
3401  			{
3402  				break;
3403  			}
3404  		}
3405  	}
3406  	if (!ec)
3407  	{
3408  		boost::property_tree::ptree representatives;
3409  		auto reps (node.online_reps.list ());
3410  		for (auto & i : reps)
3411  		{
3412  			if (accounts_node.is_initialized ())
3413  			{
3414  				if (accounts_to_filter.empty ())
3415  				{
3416  					break;
3417  				}
3418  				auto found_acc = std::find (accounts_to_filter.begin (), accounts_to_filter.end (), i);
3419  				if (found_acc == accounts_to_filter.end ())
3420  				{
3421  					continue;
3422  				}
3423  				else
3424  				{
3425  					accounts_to_filter.erase (found_acc);
3426  				}
3427  			}
3428  			if (weight)
3429  			{
3430  				boost::property_tree::ptree weight_node;
3431  				auto account_weight (node.ledger.weight (i));
3432  				weight_node.put ("weight", account_weight.convert_to<std::string> ());
3433  				representatives.add_child (i.to_account (), weight_node);
3434  			}
3435  			else
3436  			{
3437  				boost::property_tree::ptree entry;
3438  				entry.put ("", i.to_account ());
3439  				representatives.push_back (std::make_pair ("", entry));
3440  			}
3441  		}
3442  		response_l.add_child ("representatives", representatives);
3443  	}
3444  	response_errors ();
3445  }
3446  void nano::json_handler::republish ()
3447  {
3448  	auto count (count_optional_impl (1024U));
3449  	uint64_t sources (0);
3450  	uint64_t destinations (0);
3451  	boost::optional<std::string> sources_text (request.get_optional<std::string> ("sources"));
3452  	if (!ec && sources_text.is_initialized ())
3453  	{
3454  		if (decode_unsigned (sources_text.get (), sources))
3455  		{
3456  			ec = nano::error_rpc::invalid_sources;
3457  		}
3458  	}
3459  	boost::optional<std::string> destinations_text (request.get_optional<std::string> ("destinations"));
3460  	if (!ec && destinations_text.is_initialized ())
3461  	{
3462  		if (decode_unsigned (destinations_text.get (), destinations))
3463  		{
3464  			ec = nano::error_rpc::invalid_destinations;
3465  		}
3466  	}
3467  	auto hash (hash_impl ());
3468  	if (!ec)
3469  	{
3470  		boost::property_tree::ptree blocks;
3471  		auto transaction (node.store.tx_begin_read ());
3472  		auto block (node.store.block.get (transaction, hash));
3473  		if (block != nullptr)
3474  		{
3475  			std::deque<std::shared_ptr<nano::block>> republish_bundle;
3476  			for (auto i (0); !hash.is_zero () && i < count; ++i)
3477  			{
3478  				block = node.store.block.get (transaction, hash);
3479  				if (sources != 0) 
3480  				{
3481  					nano::block_hash source (node.ledger.block_source (transaction, *block));
3482  					auto block_a (node.store.block.get (transaction, source));
3483  					std::vector<nano::block_hash> hashes;
3484  					while (block_a != nullptr && hashes.size () < sources)
3485  					{
3486  						hashes.push_back (source);
3487  						source = block_a->previous ();
3488  						block_a = node.store.block.get (transaction, source);
3489  					}
3490  					std::reverse (hashes.begin (), hashes.end ());
3491  					for (auto & hash_l : hashes)
3492  					{
3493  						block_a = node.store.block.get (transaction, hash_l);
3494  						republish_bundle.push_back (std::move (block_a));
3495  						boost::property_tree::ptree entry_l;
3496  						entry_l.put ("", hash_l.to_string ());
3497  						blocks.push_back (std::make_pair ("", entry_l));
3498  					}
3499  				}
3500  				republish_bundle.push_back (std::move (block)); 
3501  				boost::property_tree::ptree entry;
3502  				entry.put ("", hash.to_string ());
3503  				blocks.push_back (std::make_pair ("", entry));
3504  				if (destinations != 0) 
3505  				{
3506  					auto block_b (node.store.block.get (transaction, hash));
3507  					auto destination (node.ledger.block_destination (transaction, *block_b));
3508  					if (!destination.is_zero ())
3509  					{
3510  						if (!node.store.pending.exists (transaction, nano::pending_key (destination, hash)))
3511  						{
3512  							nano::block_hash previous (node.ledger.latest (transaction, destination));
3513  							auto block_d (node.store.block.get (transaction, previous));
3514  							nano::block_hash source;
3515  							std::vector<nano::block_hash> hashes;
3516  							while (block_d != nullptr && hash != source)
3517  							{
3518  								hashes.push_back (previous);
3519  								source = node.ledger.block_source (transaction, *block_d);
3520  								previous = block_d->previous ();
3521  								block_d = node.store.block.get (transaction, previous);
3522  							}
3523  							std::reverse (hashes.begin (), hashes.end ());
3524  							if (hashes.size () > destinations)
3525  							{
3526  								hashes.resize (destinations);
3527  							}
3528  							for (auto & hash_l : hashes)
3529  							{
3530  								block_d = node.store.block.get (transaction, hash_l);
3531  								republish_bundle.push_back (std::move (block_d));
3532  								boost::property_tree::ptree entry_l;
3533  								entry_l.put ("", hash_l.to_string ());
3534  								blocks.push_back (std::make_pair ("", entry_l));
3535  							}
3536  						}
3537  					}
3538  				}
3539  				hash = node.store.block.successor (transaction, hash);
3540  			}
3541  			node.network.flood_block_many (std::move (republish_bundle), nullptr, 25);
3542  			response_l.put ("success", ""); 
3543  			response_l.add_child ("blocks", blocks);
3544  		}
3545  		else
3546  		{
3547  			ec = nano::error_blocks::not_found;
3548  		}
3549  	}
3550  	response_errors ();
3551  }
3552  void nano::json_handler::search_pending ()
3553  {
3554  	response_l.put ("deprecated", "1");
3555  	search_receivable ();
3556  }
3557  void nano::json_handler::search_receivable ()
3558  {
3559  	auto wallet (wallet_impl ());
3560  	if (!ec)
3561  	{
3562  		auto error (wallet->search_receivable (wallet->wallets.tx_begin_read ()));
3563  		response_l.put ("started", !error);
3564  	}
3565  	response_errors ();
3566  }
3567  void nano::json_handler::search_pending_all ()
3568  {
3569  	response_l.put ("deprecated", "1");
3570  	search_receivable_all ();
3571  }
3572  void nano::json_handler::search_receivable_all ()
3573  {
3574  	if (!ec)
3575  	{
3576  		node.wallets.search_receivable_all ();
3577  		response_l.put ("success", "");
3578  	}
3579  	response_errors ();
3580  }
3581  void nano::json_handler::send ()
3582  {
3583  	auto wallet (wallet_impl ());
3584  	auto amount (amount_impl ());
3585  	if (!ec && amount.is_zero ())
3586  	{
3587  		ec = nano::error_common::invalid_amount;
3588  	}
3589  	std::string source_text (request.get<std::string> ("source"));
3590  	auto source (account_impl (source_text, nano::error_rpc::bad_source));
3591  	std::string destination_text (request.get<std::string> ("destination"));
3592  	auto destination (account_impl (destination_text, nano::error_rpc::bad_destination));
3593  	if (!ec)
3594  	{
3595  		auto work (work_optional_impl ());
3596  		nano::uint128_t balance (0);
3597  		if (!ec && work == 0 && !node.work_generation_enabled ())
3598  		{
3599  			ec = nano::error_common::disabled_work_generation;
3600  		}
3601  		if (!ec)
3602  		{
3603  			auto transaction (node.wallets.tx_begin_read ());
3604  			auto block_transaction (node.store.tx_begin_read ());
3605  			wallet_locked_impl (transaction, wallet);
3606  			wallet_account_impl (transaction, wallet, source);
3607  			auto info (account_info_impl (block_transaction, source));
3608  			if (!ec)
3609  			{
3610  				balance = (info.balance).number ();
3611  			}
3612  			if (!ec && work)
3613  			{
3614  				nano::block_details details (info.epoch (), true, false, false);
3615  				if (node.network_params.work.difficulty (nano::work_version::work_1, info.head, work) < node.network_params.work.threshold (nano::work_version::work_1, details))
3616  				{
3617  					ec = nano::error_common::invalid_work;
3618  				}
3619  			}
3620  		}
3621  		if (!ec)
3622  		{
3623  			bool generate_work (work == 0); 
3624  			boost::optional<std::string> send_id (request.get_optional<std::string> ("id"));
3625  			auto response_a (response);
3626  			auto response_data (std::make_shared<boost::property_tree::ptree> (response_l));
3627  			wallet->send_async (
3628  			source, destination, amount.number (), [balance, amount, response_a, response_data] (std::shared_ptr<nano::block> const & block_a) {
3629  				if (block_a != nullptr)
3630  				{
3631  					response_data->put ("block", block_a->hash ().to_string ());
3632  					std::stringstream ostream;
3633  					boost::property_tree::write_json (ostream, *response_data);
3634  					response_a (ostream.str ());
3635  				}
3636  				else
3637  				{
3638  					if (balance >= amount.number ())
3639  					{
3640  						json_error_response (response_a, "Error generating block");
3641  					}
3642  					else
3643  					{
3644  						std::error_code ec (nano::error_common::insufficient_balance);
3645  						json_error_response (response_a, ec.message ());
3646  					}
3647  				}
3648  			},
3649  			work, generate_work, send_id);
3650  		}
3651  	}
3652  	if (ec)
3653  	{
3654  		response_errors ();
3655  	}
3656  }
3657  void nano::json_handler::sign ()
3658  {
3659  	bool const json_block_l = request.get<bool> ("json_block", false);
3660  	nano::block_hash hash (0);
3661  	boost::optional<std::string> hash_text (request.get_optional<std::string> ("hash"));
3662  	if (hash_text.is_initialized ())
3663  	{
3664  		hash = hash_impl ();
3665  	}
3666  	std::shared_ptr<nano::block> block;
3667  	if (!ec && request.count ("block"))
3668  	{
3669  		block = block_impl (true);
3670  		if (block != nullptr)
3671  		{
3672  			hash = block->hash ();
3673  		}
3674  	}
3675  	if (!ec && hash.is_zero ())
3676  	{
3677  		ec = nano::error_blocks::invalid_block;
3678  	}
3679  	else if (!ec && !hash.is_zero () && block == nullptr && !node_rpc_config.enable_sign_hash)
3680  	{
3681  		ec = nano::error_rpc::sign_hash_disabled;
3682  	}
3683  	if (!ec)
3684  	{
3685  		nano::raw_key prv;
3686  		prv.clear ();
3687  		boost::optional<std::string> key_text (request.get_optional<std::string> ("key"));
3688  		if (key_text.is_initialized ())
3689  		{
3690  			if (prv.decode_hex (key_text.get ()))
3691  			{
3692  				ec = nano::error_common::bad_private_key;
3693  			}
3694  		}
3695  		else
3696  		{
3697  			boost::optional<std::string> account_text (request.get_optional<std::string> ("account"));
3698  			boost::optional<std::string> wallet_text (request.get_optional<std::string> ("wallet"));
3699  			if (wallet_text.is_initialized () && account_text.is_initialized ())
3700  			{
3701  				auto account (account_impl ());
3702  				auto wallet (wallet_impl ());
3703  				if (!ec)
3704  				{
3705  					auto transaction (node.wallets.tx_begin_read ());
3706  					wallet_locked_impl (transaction, wallet);
3707  					wallet_account_impl (transaction, wallet, account);
3708  					if (!ec)
3709  					{
3710  						wallet->store.fetch (transaction, account, prv);
3711  					}
3712  				}
3713  			}
3714  		}
3715  		if (prv != 0)
3716  		{
3717  			nano::public_key pub (nano::pub_key (prv));
3718  			nano::signature signature (nano::sign_message (prv, pub, hash));
3719  			response_l.put ("signature", signature.to_string ());
3720  			if (block != nullptr)
3721  			{
3722  				block->signature_set (signature);
3723  				if (json_block_l)
3724  				{
3725  					boost::property_tree::ptree block_node_l;
3726  					block->serialize_json (block_node_l);
3727  					response_l.add_child ("block", block_node_l);
3728  				}
3729  				else
3730  				{
3731  					std::string contents;
3732  					block->serialize_json (contents);
3733  					response_l.put ("block", contents);
3734  				}
3735  			}
3736  		}
3737  		else
3738  		{
3739  			ec = nano::error_rpc::block_create_key_required;
3740  		}
3741  	}
3742  	response_errors ();
3743  }
3744  void nano::json_handler::stats ()
3745  {
3746  	auto sink = node.stats.log_sink_json ();
3747  	std::string type (request.get<std::string> ("type", ""));
3748  	bool use_sink = false;
3749  	if (type == "counters")
3750  	{
3751  		node.stats.log_counters (*sink);
3752  		use_sink = true;
3753  	}
3754  	else if (type == "objects")
3755  	{
3756  		construct_json (collect_container_info (node, "node").get (), response_l);
3757  	}
3758  	else if (type == "samples")
3759  	{
3760  		node.stats.log_samples (*sink);
3761  		use_sink = true;
3762  	}
3763  	else if (type == "database")
3764  	{
3765  		node.store.serialize_memory_stats (response_l);
3766  	}
3767  	else
3768  	{
3769  		ec = nano::error_rpc::invalid_missing_type;
3770  	}
3771  	if (!ec && use_sink)
3772  	{
3773  		auto stat_tree_l (*static_cast<boost::property_tree::ptree *> (sink->to_object ()));
3774  		stat_tree_l.put ("stat_duration_seconds", node.stats.last_reset ().count ());
3775  		std::stringstream ostream;
3776  		boost::property_tree::write_json (ostream, stat_tree_l);
3777  		response (ostream.str ());
3778  	}
3779  	else
3780  	{
3781  		response_errors ();
3782  	}
3783  }
3784  void nano::json_handler::stats_clear ()
3785  {
3786  	node.stats.clear ();
3787  	response_l.put ("success", "");
3788  	std::stringstream ostream;
3789  	boost::property_tree::write_json (ostream, response_l);
3790  	response (ostream.str ());
3791  }
3792  void nano::json_handler::stop ()
3793  {
3794  	response_l.put ("success", "");
3795  	response_errors ();
3796  	if (!ec)
3797  	{
3798  		stop_callback ();
3799  	}
3800  }
3801  void nano::json_handler::telemetry ()
3802  {
3803  	auto address_text (request.get_optional<std::string> ("address"));
3804  	auto port_text (request.get_optional<std::string> ("port"));
3805  	if (address_text.is_initialized () || port_text.is_initialized ())
3806  	{
3807  		nano::endpoint endpoint{};
3808  		if (address_text.is_initialized () && port_text.is_initialized ())
3809  		{
3810  			uint16_t port;
3811  			if (!nano::parse_port (*port_text, port))
3812  			{
3813  				boost::asio::ip::address address;
3814  				if (!nano::parse_address (*address_text, address))
3815  				{
3816  					endpoint = { address, port };
3817  					if (address.is_loopback () && port == node.network.endpoint ().port ())
3818  					{
3819  						auto telemetry_data = node.local_telemetry ();
3820  						nano::jsonconfig config_l;
3821  						auto const should_ignore_identification_metrics = false;
3822  						auto err = telemetry_data.serialize_json (config_l, should_ignore_identification_metrics);
3823  						auto const & ptree = config_l.get_tree ();
3824  						if (!err)
3825  						{
3826  							response_l.insert (response_l.begin (), ptree.begin (), ptree.end ());
3827  						}
3828  						response_errors ();
3829  						return;
3830  					}
3831  				}
3832  				else
3833  				{
3834  					ec = nano::error_common::invalid_ip_address;
3835  				}
3836  			}
3837  			else
3838  			{
3839  				ec = nano::error_common::invalid_port;
3840  			}
3841  		}
3842  		else
3843  		{
3844  			ec = nano::error_rpc::requires_port_and_address;
3845  		}
3846  		if (!ec)
3847  		{
3848  			auto maybe_telemetry = node.telemetry.get_telemetry (nano::transport::map_endpoint_to_v6 (endpoint));
3849  			if (maybe_telemetry)
3850  			{
3851  				auto telemetry = *maybe_telemetry;
3852  				nano::jsonconfig config_l;
3853  				auto const should_ignore_identification_metrics = false;
3854  				auto err = telemetry.serialize_json (config_l, should_ignore_identification_metrics);
3855  				auto const & ptree = config_l.get_tree ();
3856  				if (!err)
3857  				{
3858  					response_l.insert (response_l.begin (), ptree.begin (), ptree.end ());
3859  				}
3860  				else
3861  				{
3862  					ec = nano::error_rpc::generic;
3863  				}
3864  			}
3865  			else
3866  			{
3867  				ec = nano::error_rpc::peer_not_found;
3868  			}
3869  			response_errors ();
3870  		}
3871  		else
3872  		{
3873  			response_errors ();
3874  		}
3875  	}
3876  	else
3877  	{
3878  		auto raw = request.get_optional<bool> ("raw");
3879  		auto output_raw = raw.value_or (false);
3880  		auto telemetry_responses = node.telemetry.get_all_telemetries ();
3881  		if (output_raw)
3882  		{
3883  			boost::property_tree::ptree metrics;
3884  			for (auto & telemetry_metrics : telemetry_responses)
3885  			{
3886  				nano::jsonconfig config_l;
3887  				auto const should_ignore_identification_metrics = false;
3888  				auto err = telemetry_metrics.second.serialize_json (config_l, should_ignore_identification_metrics);
3889  				config_l.put ("address", telemetry_metrics.first.address ());
3890  				config_l.put ("port", telemetry_metrics.first.port ());
3891  				if (!err)
3892  				{
3893  					metrics.push_back (std::make_pair ("", config_l.get_tree ()));
3894  				}
3895  				else
3896  				{
3897  					ec = nano::error_rpc::generic;
3898  				}
3899  			}
3900  			response_l.put_child ("metrics", metrics);
3901  		}
3902  		else
3903  		{
3904  			nano::jsonconfig config_l;
3905  			std::vector<nano::telemetry_data> telemetry_datas;
3906  			telemetry_datas.reserve (telemetry_responses.size ());
3907  			std::transform (telemetry_responses.begin (), telemetry_responses.end (), std::back_inserter (telemetry_datas), [] (auto const & endpoint_telemetry_data) {
3908  				return endpoint_telemetry_data.second;
3909  			});
3910  			auto average_telemetry_metrics = nano::consolidate_telemetry_data (telemetry_datas);
3911  			auto const should_ignore_identification_metrics = true;
3912  			auto err = average_telemetry_metrics.serialize_json (config_l, should_ignore_identification_metrics);
3913  			auto const & ptree = config_l.get_tree ();
3914  			if (!err)
3915  			{
3916  				response_l.insert (response_l.begin (), ptree.begin (), ptree.end ());
3917  			}
3918  			else
3919  			{
3920  				ec = nano::error_rpc::generic;
3921  			}
3922  		}
3923  		response_errors ();
3924  	}
3925  }
3926  void nano::json_handler::unchecked ()
3927  {
3928  	bool const json_block_l = request.get<bool> ("json_block", false);
3929  	auto count (count_optional_impl ());
3930  	if (!ec)
3931  	{
3932  		boost::property_tree::ptree unchecked;
3933  		node.unchecked.for_each (
3934  		[&unchecked, &json_block_l] (nano::unchecked_key const & key, nano::unchecked_info const & info) {
3935  			if (json_block_l)
3936  			{
3937  				boost::property_tree::ptree block_node_l;
3938  				info.block->serialize_json (block_node_l);
3939  				unchecked.add_child (info.block->hash ().to_string (), block_node_l);
3940  			}
3941  			else
3942  			{
3943  				std::string contents;
3944  				info.block->serialize_json (contents);
3945  				unchecked.put (info.block->hash ().to_string (), contents);
3946  			} }, [iterations = 0, count = count] () mutable { return iterations++ < count; });
3947  		response_l.add_child ("blocks", unchecked);
3948  	}
3949  	response_errors ();
3950  }
3951  void nano::json_handler::unchecked_clear ()
3952  {
3953  	node.workers.push_task (create_worker_task ([] (std::shared_ptr<nano::json_handler> const & rpc_l) {
3954  		rpc_l->node.unchecked.clear ();
3955  		rpc_l->response_l.put ("success", "");
3956  		rpc_l->response_errors ();
3957  	}));
3958  }
3959  void nano::json_handler::unchecked_get ()
3960  {
3961  	bool const json_block_l = request.get<bool> ("json_block", false);
3962  	auto hash (hash_impl ());
3963  	if (!ec)
3964  	{
3965  		bool done = false;
3966  		node.unchecked.for_each (
3967  		[&] (nano::unchecked_key const & key, nano::unchecked_info const & info) {
3968  			if (key.hash == hash)
3969  			{
3970  				response_l.put ("modified_timestamp", std::to_string (info.modified ()));
3971  				if (json_block_l)
3972  				{
3973  					boost::property_tree::ptree block_node_l;
3974  					info.block->serialize_json (block_node_l);
3975  					response_l.add_child ("contents", block_node_l);
3976  				}
3977  				else
3978  				{
3979  					std::string contents;
3980  					info.block->serialize_json (contents);
3981  					response_l.put ("contents", contents);
3982  				}
3983  				done = true;
3984  			} }, [&] () { return !done; });
3985  		if (response_l.empty ())
3986  		{
3987  			ec = nano::error_blocks::not_found;
3988  		}
3989  	}
3990  	response_errors ();
3991  }
3992  void nano::json_handler::unchecked_keys ()
3993  {
3994  	bool const json_block_l = request.get<bool> ("json_block", false);
3995  	auto count (count_optional_impl ());
3996  	nano::block_hash key (0);
3997  	boost::optional<std::string> hash_text (request.get_optional<std::string> ("key"));
3998  	if (!ec && hash_text.is_initialized ())
3999  	{
4000  		if (key.decode_hex (hash_text.get ()))
4001  		{
4002  			ec = nano::error_rpc::bad_key;
4003  		}
4004  	}
4005  	if (!ec)
4006  	{
4007  		boost::property_tree::ptree unchecked;
4008  		node.unchecked.for_each (
4009  		key,
4010  		[&unchecked, json_block_l] (nano::unchecked_key const & key, nano::unchecked_info const & info) {
4011  			boost::property_tree::ptree entry;
4012  			entry.put ("key", key.key ().to_string ());
4013  			entry.put ("hash", info.block->hash ().to_string ());
4014  			entry.put ("modified_timestamp", std::to_string (info.modified ()));
4015  			if (json_block_l)
4016  			{
4017  				boost::property_tree::ptree block_node_l;
4018  				info.block->serialize_json (block_node_l);
4019  				entry.add_child ("contents", block_node_l);
4020  			}
4021  			else
4022  			{
4023  				std::string contents;
4024  				info.block->serialize_json (contents);
4025  				entry.put ("contents", contents);
4026  			}
4027  			unchecked.push_back (std::make_pair ("", entry)); }, [&unchecked, &count] () { return unchecked.size () < count; });
4028  		response_l.add_child ("unchecked", unchecked);
4029  	}
4030  	response_errors ();
4031  }
4032  void nano::json_handler::unopened ()
4033  {
4034  	auto count (count_optional_impl ());
4035  	auto threshold (threshold_optional_impl ());
4036  	nano::account start (1); 
4037  	boost::optional<std::string> account_text (request.get_optional<std::string> ("account"));
4038  	if (account_text.is_initialized ())
4039  	{
4040  		start = account_impl (account_text.get ());
4041  	}
4042  	if (!ec)
4043  	{
4044  		auto transaction (node.store.tx_begin_read ());
4045  		auto iterator (node.store.pending.begin (transaction, nano::pending_key (start, 0)));
4046  		auto end (node.store.pending.end ());
4047  		nano::account current_account (start);
4048  		nano::uint128_t current_account_sum{ 0 };
4049  		boost::property_tree::ptree accounts;
4050  		while (iterator != end && accounts.size () < count)
4051  		{
4052  			nano::pending_key key (iterator->first);
4053  			nano::account account (key.account);
4054  			nano::pending_info info (iterator->second);
4055  			if (node.store.account.exists (transaction, account))
4056  			{
4057  				if (account.number () == std::numeric_limits<nano::uint256_t>::max ())
4058  				{
4059  					break;
4060  				}
4061  				iterator = node.store.pending.begin (transaction, nano::pending_key (account.number () + 1, 0));
4062  			}
4063  			else
4064  			{
4065  				if (account != current_account)
4066  				{
4067  					if (current_account_sum > 0)
4068  					{
4069  						if (current_account_sum >= threshold.number ())
4070  						{
4071  							accounts.put (current_account.to_account (), current_account_sum.convert_to<std::string> ());
4072  						}
4073  						current_account_sum = 0;
4074  					}
4075  					current_account = account;
4076  				}
4077  				current_account_sum += info.amount.number ();
4078  				++iterator;
4079  			}
4080  		}
4081  		if (accounts.size () < count && current_account_sum > 0 && current_account_sum >= threshold.number ())
4082  		{
4083  			accounts.put (current_account.to_account (), current_account_sum.convert_to<std::string> ());
4084  		}
4085  		response_l.add_child ("accounts", accounts);
4086  	}
4087  	response_errors ();
4088  }
4089  void nano::json_handler::uptime ()
4090  {
4091  	response_l.put ("seconds", std::chrono::duration_cast<std::chrono::seconds> (std::chrono::steady_clock::now () - node.startup_time).count ());
4092  	response_errors ();
4093  }
4094  void nano::json_handler::version ()
4095  {
4096  	response_l.put ("rpc_version", "1");
4097  	response_l.put ("store_version", std::to_string (node.store_version ()));
4098  	response_l.put ("protocol_version", std::to_string (node.network_params.network.protocol_version));
4099  	response_l.put ("node_vendor", boost::str (boost::format ("Nano %1%") % NANO_VERSION_STRING));
4100  	response_l.put ("store_vendor", node.store.vendor_get ());
4101  	response_l.put ("network", node.network_params.network.get_current_network_as_string ());
4102  	response_l.put ("network_identifier", node.network_params.ledger.genesis->hash ().to_string ());
4103  	response_l.put ("build_info", BUILD_INFO);
4104  	response_errors ();
4105  }
4106  void nano::json_handler::validate_account_number ()
4107  {
4108  	auto account (account_impl ());
4109  	(void)account;
4110  	response_l.put ("valid", ec ? "0" : "1");
4111  	ec = std::error_code (); 
4112  	response_errors ();
4113  }
4114  void nano::json_handler::wallet_add ()
4115  {
4116  	node.workers.push_task (create_worker_task ([] (std::shared_ptr<nano::json_handler> const & rpc_l) {
4117  		auto wallet (rpc_l->wallet_impl ());
4118  		if (!rpc_l->ec)
4119  		{
4120  			std::string key_text (rpc_l->request.get<std::string> ("key"));
4121  			nano::raw_key key;
4122  			if (!key.decode_hex (key_text))
4123  			{
4124  				bool const generate_work = rpc_l->request.get<bool> ("work", true);
4125  				auto pub (wallet->insert_adhoc (key, generate_work));
4126  				if (!pub.is_zero ())
4127  				{
4128  					rpc_l->response_l.put ("account", pub.to_account ());
4129  				}
4130  				else
4131  				{
4132  					rpc_l->ec = nano::error_common::wallet_locked;
4133  				}
4134  			}
4135  			else
4136  			{
4137  				rpc_l->ec = nano::error_common::bad_private_key;
4138  			}
4139  		}
4140  		rpc_l->response_errors ();
4141  	}));
4142  }
4143  void nano::json_handler::wallet_add_watch ()
4144  {
4145  	node.workers.push_task (create_worker_task ([] (std::shared_ptr<nano::json_handler> const & rpc_l) {
4146  		auto wallet (rpc_l->wallet_impl ());
4147  		if (!rpc_l->ec)
4148  		{
4149  			auto transaction (rpc_l->node.wallets.tx_begin_write ());
4150  			if (wallet->store.valid_password (transaction))
4151  			{
4152  				for (auto & accounts : rpc_l->request.get_child ("accounts"))
4153  				{
4154  					auto account (rpc_l->account_impl (accounts.second.data ()));
4155  					if (!rpc_l->ec)
4156  					{
4157  						if (wallet->insert_watch (transaction, account))
4158  						{
4159  							rpc_l->ec = nano::error_common::bad_public_key;
4160  						}
4161  					}
4162  				}
4163  				if (!rpc_l->ec)
4164  				{
4165  					rpc_l->response_l.put ("success", "");
4166  				}
4167  			}
4168  			else
4169  			{
4170  				rpc_l->ec = nano::error_common::wallet_locked;
4171  			}
4172  		}
4173  		rpc_l->response_errors ();
4174  	}));
4175  }
4176  void nano::json_handler::wallet_info ()
4177  {
4178  	auto wallet (wallet_impl ());
4179  	if (!ec)
4180  	{
4181  		nano::uint128_t balance (0);
4182  		nano::uint128_t receivable (0);
4183  		uint64_t count (0);
4184  		uint64_t block_count (0);
4185  		uint64_t cemented_block_count (0);
4186  		uint64_t deterministic_count (0);
4187  		uint64_t adhoc_count (0);
4188  		auto transaction (node.wallets.tx_begin_read ());
4189  		auto block_transaction (node.store.tx_begin_read ());
4190  		for (auto i (wallet->store.begin (transaction)), n (wallet->store.end ()); i != n; ++i)
4191  		{
4192  			nano::account const & account (i->first);
4193  			auto account_info = node.ledger.account_info (block_transaction, account);
4194  			if (account_info)
4195  			{
4196  				block_count += account_info->block_count;
4197  				balance += account_info->balance.number ();
4198  			}
4199  			nano::confirmation_height_info confirmation_info{};
4200  			if (!node.store.confirmation_height.get (block_transaction, account, confirmation_info))
4201  			{
4202  				cemented_block_count += confirmation_info.height;
4203  			}
4204  			receivable += node.ledger.account_receivable (block_transaction, account);
4205  			nano::key_type key_type (wallet->store.key_type (i->second));
4206  			if (key_type == nano::key_type::deterministic)
4207  			{
4208  				deterministic_count++;
4209  			}
4210  			else if (key_type == nano::key_type::adhoc)
4211  			{
4212  				adhoc_count++;
4213  			}
4214  			++count;
4215  		}
4216  		uint32_t deterministic_index (wallet->store.deterministic_index_get (transaction));
4217  		response_l.put ("balance", balance.convert_to<std::string> ());
4218  		response_l.put ("pending", receivable.convert_to<std::string> ());
4219  		response_l.put ("receivable", receivable.convert_to<std::string> ());
4220  		response_l.put ("accounts_count", std::to_string (count));
4221  		response_l.put ("accounts_block_count", std::to_string (block_count));
4222  		response_l.put ("accounts_cemented_block_count", std::to_string (cemented_block_count));
4223  		response_l.put ("deterministic_count", std::to_string (deterministic_count));
4224  		response_l.put ("adhoc_count", std::to_string (adhoc_count));
4225  		response_l.put ("deterministic_index", std::to_string (deterministic_index));
4226  	}
4227  	response_errors ();
4228  }
4229  void nano::json_handler::wallet_balances ()
4230  {
4231  	auto wallet (wallet_impl ());
4232  	auto threshold (threshold_optional_impl ());
4233  	if (!ec)
4234  	{
4235  		boost::property_tree::ptree balances;
4236  		auto transaction (node.wallets.tx_begin_read ());
4237  		auto block_transaction (node.store.tx_begin_read ());
4238  		for (auto i (wallet->store.begin (transaction)), n (wallet->store.end ()); i != n; ++i)
4239  		{
4240  			nano::account const & account (i->first);
4241  			nano::uint128_t balance = node.ledger.account_balance (block_transaction, account);
4242  			if (balance >= threshold.number ())
4243  			{
4244  				boost::property_tree::ptree entry;
4245  				nano::uint128_t receivable = node.ledger.account_receivable (block_transaction, account);
4246  				entry.put ("balance", balance.convert_to<std::string> ());
4247  				entry.put ("pending", receivable.convert_to<std::string> ());
4248  				entry.put ("receivable", receivable.convert_to<std::string> ());
4249  				balances.push_back (std::make_pair (account.to_account (), entry));
4250  			}
4251  		}
4252  		response_l.add_child ("balances", balances);
4253  	}
4254  	response_errors ();
4255  }
4256  void nano::json_handler::wallet_change_seed ()
4257  {
4258  	node.workers.push_task (create_worker_task ([] (std::shared_ptr<nano::json_handler> const & rpc_l) {
4259  		auto wallet (rpc_l->wallet_impl ());
4260  		if (!rpc_l->ec)
4261  		{
4262  			std::string seed_text (rpc_l->request.get<std::string> ("seed"));
4263  			nano::raw_key seed;
4264  			if (!seed.decode_hex (seed_text))
4265  			{
4266  				auto count (static_cast<uint32_t> (rpc_l->count_optional_impl (0)));
4267  				auto transaction (rpc_l->node.wallets.tx_begin_write ());
4268  				if (wallet->store.valid_password (transaction))
4269  				{
4270  					nano::public_key account (wallet->change_seed (transaction, seed, count));
4271  					rpc_l->response_l.put ("success", "");
4272  					rpc_l->response_l.put ("last_restored_account", account.to_account ());
4273  					auto index (wallet->store.deterministic_index_get (transaction));
4274  					debug_assert (index > 0);
4275  					rpc_l->response_l.put ("restored_count", std::to_string (index));
4276  				}
4277  				else
4278  				{
4279  					rpc_l->ec = nano::error_common::wallet_locked;
4280  				}
4281  			}
4282  			else
4283  			{
4284  				rpc_l->ec = nano::error_common::bad_seed;
4285  			}
4286  		}
4287  		rpc_l->response_errors ();
4288  	}));
4289  }
4290  void nano::json_handler::wallet_contains ()
4291  {
4292  	auto account (account_impl ());
4293  	auto wallet (wallet_impl ());
4294  	if (!ec)
4295  	{
4296  		auto transaction (node.wallets.tx_begin_read ());
4297  		auto exists (wallet->store.find (transaction, account) != wallet->store.end ());
4298  		response_l.put ("exists", exists ? "1" : "0");
4299  	}
4300  	response_errors ();
4301  }
4302  void nano::json_handler::wallet_create ()
4303  {
4304  	node.workers.push_task (create_worker_task ([] (std::shared_ptr<nano::json_handler> const & rpc_l) {
4305  		nano::raw_key seed;
4306  		auto seed_text (rpc_l->request.get_optional<std::string> ("seed"));
4307  		if (seed_text.is_initialized () && seed.decode_hex (seed_text.get ()))
4308  		{
4309  			rpc_l->ec = nano::error_common::bad_seed;
4310  		}
4311  		if (!rpc_l->ec)
4312  		{
4313  			auto wallet_id = random_wallet_id ();
4314  			auto wallet (rpc_l->node.wallets.create (wallet_id));
4315  			auto existing (rpc_l->node.wallets.items.find (wallet_id));
4316  			if (existing != rpc_l->node.wallets.items.end ())
4317  			{
4318  				rpc_l->response_l.put ("wallet", wallet_id.to_string ());
4319  			}
4320  			else
4321  			{
4322  				rpc_l->ec = nano::error_common::wallet_lmdb_max_dbs;
4323  			}
4324  			if (!rpc_l->ec && seed_text.is_initialized ())
4325  			{
4326  				auto transaction (rpc_l->node.wallets.tx_begin_write ());
4327  				nano::public_key account (wallet->change_seed (transaction, seed));
4328  				rpc_l->response_l.put ("last_restored_account", account.to_account ());
4329  				auto index (wallet->store.deterministic_index_get (transaction));
4330  				debug_assert (index > 0);
4331  				rpc_l->response_l.put ("restored_count", std::to_string (index));
4332  			}
4333  		}
4334  		rpc_l->response_errors ();
4335  	}));
4336  }
4337  void nano::json_handler::wallet_destroy ()
4338  {
4339  	node.workers.push_task (create_worker_task ([] (std::shared_ptr<nano::json_handler> const & rpc_l) {
4340  		std::string wallet_text (rpc_l->request.get<std::string> ("wallet"));
4341  		nano::wallet_id wallet;
4342  		if (!wallet.decode_hex (wallet_text))
4343  		{
4344  			auto existing (rpc_l->node.wallets.items.find (wallet));
4345  			if (existing != rpc_l->node.wallets.items.end ())
4346  			{
4347  				rpc_l->node.wallets.destroy (wallet);
4348  				bool destroyed (rpc_l->node.wallets.items.find (wallet) == rpc_l->node.wallets.items.end ());
4349  				rpc_l->response_l.put ("destroyed", destroyed ? "1" : "0");
4350  			}
4351  			else
4352  			{
4353  				rpc_l->ec = nano::error_common::wallet_not_found;
4354  			}
4355  		}
4356  		else
4357  		{
4358  			rpc_l->ec = nano::error_common::bad_wallet_number;
4359  		}
4360  		rpc_l->response_errors ();
4361  	}));
4362  }
4363  void nano::json_handler::wallet_export ()
4364  {
4365  	auto wallet (wallet_impl ());
4366  	if (!ec)
4367  	{
4368  		auto transaction (node.wallets.tx_begin_read ());
4369  		std::string json;
4370  		wallet->store.serialize_json (transaction, json);
4371  		response_l.put ("json", json);
4372  	}
4373  	response_errors ();
4374  }
4375  void nano::json_handler::wallet_frontiers ()
4376  {
4377  	auto wallet (wallet_impl ());
4378  	if (!ec)
4379  	{
4380  		boost::property_tree::ptree frontiers;
4381  		auto transaction (node.wallets.tx_begin_read ());
4382  		auto block_transaction (node.store.tx_begin_read ());
4383  		for (auto i (wallet->store.begin (transaction)), n (wallet->store.end ()); i != n; ++i)
4384  		{
4385  			nano::account const & account (i->first);
4386  			auto latest (node.ledger.latest (block_transaction, account));
4387  			if (!latest.is_zero ())
4388  			{
4389  				frontiers.put (account.to_account (), latest.to_string ());
4390  			}
4391  		}
4392  		response_l.add_child ("frontiers", frontiers);
4393  	}
4394  	response_errors ();
4395  }
4396  void nano::json_handler::wallet_history ()
4397  {
4398  	uint64_t modified_since (1);
4399  	boost::optional<std::string> modified_since_text (request.get_optional<std::string> ("modified_since"));
4400  	if (modified_since_text.is_initialized ())
4401  	{
4402  		if (decode_unsigned (modified_since_text.get (), modified_since))
4403  		{
4404  			ec = nano::error_rpc::invalid_timestamp;
4405  		}
4406  	}
4407  	auto wallet (wallet_impl ());
4408  	if (!ec)
4409  	{
4410  		std::multimap<uint64_t, boost::property_tree::ptree, std::greater<uint64_t>> entries;
4411  		auto transaction (node.wallets.tx_begin_read ());
4412  		auto block_transaction (node.store.tx_begin_read ());
4413  		for (auto i (wallet->store.begin (transaction)), n (wallet->store.end ()); i != n; ++i)
4414  		{
4415  			nano::account const & account (i->first);
4416  			auto info = node.ledger.account_info (block_transaction, account);
4417  			if (info)
4418  			{
4419  				auto timestamp (info->modified);
4420  				auto hash (info->head);
4421  				while (timestamp >= modified_since && !hash.is_zero ())
4422  				{
4423  					auto block (node.store.block.get (block_transaction, hash));
4424  					timestamp = block->sideband ().timestamp;
4425  					if (block != nullptr && timestamp >= modified_since)
4426  					{
4427  						boost::property_tree::ptree entry;
4428  						std::vector<nano::public_key> no_filter;
4429  						history_visitor visitor (*this, false, block_transaction, entry, hash, no_filter);
4430  						block->visit (visitor);
4431  						if (!entry.empty ())
4432  						{
4433  							entry.put ("block_account", account.to_account ());
4434  							entry.put ("hash", hash.to_string ());
4435  							entry.put ("local_timestamp", std::to_string (timestamp));
4436  							entries.insert (std::make_pair (timestamp, entry));
4437  						}
4438  						hash = block->previous ();
4439  					}
4440  					else
4441  					{
4442  						hash.clear ();
4443  					}
4444  				}
4445  			}
4446  		}
4447  		boost::property_tree::ptree history;
4448  		for (auto i (entries.begin ()), n (entries.end ()); i != n; ++i)
4449  		{
4450  			history.push_back (std::make_pair ("", i->second));
4451  		}
4452  		response_l.add_child ("history", history);
4453  	}
4454  	response_errors ();
4455  }
4456  void nano::json_handler::wallet_key_valid ()
4457  {
4458  	auto wallet (wallet_impl ());
4459  	if (!ec)
4460  	{
4461  		auto transaction (node.wallets.tx_begin_read ());
4462  		auto valid (wallet->store.valid_password (transaction));
4463  		response_l.put ("valid", valid ? "1" : "0");
4464  	}
4465  	response_errors ();
4466  }
4467  void nano::json_handler::wallet_ledger ()
4468  {
4469  	bool const representative = request.get<bool> ("representative", false);
4470  	bool const weight = request.get<bool> ("weight", false);
4471  	bool const pending = request.get<bool> ("pending", false);
4472  	bool const receivable = request.get<bool> ("receivable", pending);
4473  	uint64_t modified_since (0);
4474  	boost::optional<std::string> modified_since_text (request.get_optional<std::string> ("modified_since"));
4475  	if (modified_since_text.is_initialized ())
4476  	{
4477  		modified_since = strtoul (modified_since_text.get ().c_str (), NULL, 10);
4478  	}
4479  	auto wallet (wallet_impl ());
4480  	if (!ec)
4481  	{
4482  		boost::property_tree::ptree accounts;
4483  		auto transaction (node.wallets.tx_begin_read ());
4484  		auto block_transaction (node.store.tx_begin_read ());
4485  		for (auto i (wallet->store.begin (transaction)), n (wallet->store.end ()); i != n; ++i)
4486  		{
4487  			nano::account const & account (i->first);
4488  			auto info = node.ledger.account_info (block_transaction, account);
4489  			if (info)
4490  			{
4491  				if (info->modified >= modified_since)
4492  				{
4493  					boost::property_tree::ptree entry;
4494  					entry.put ("frontier", info->head.to_string ());
4495  					entry.put ("open_block", info->open_block.to_string ());
4496  					entry.put ("representative_block", node.ledger.representative (block_transaction, info->head).to_string ());
4497  					std::string balance;
4498  					nano::uint128_union (info->balance).encode_dec (balance);
4499  					entry.put ("balance", balance);
4500  					entry.put ("modified_timestamp", std::to_string (info->modified));
4501  					entry.put ("block_count", std::to_string (info->block_count));
4502  					if (representative)
4503  					{
4504  						entry.put ("representative", info->representative.to_account ());
4505  					}
4506  					if (weight)
4507  					{
4508  						auto account_weight (node.ledger.weight (account));
4509  						entry.put ("weight", account_weight.convert_to<std::string> ());
4510  					}
4511  					if (receivable)
4512  					{
4513  						auto account_receivable (node.ledger.account_receivable (block_transaction, account));
4514  						entry.put ("pending", account_receivable.convert_to<std::string> ());
4515  						entry.put ("receivable", account_receivable.convert_to<std::string> ());
4516  					}
4517  					accounts.push_back (std::make_pair (account.to_account (), entry));
4518  				}
4519  			}
4520  		}
4521  		response_l.add_child ("accounts", accounts);
4522  	}
4523  	response_errors ();
4524  }
4525  void nano::json_handler::wallet_lock ()
4526  {
4527  	auto wallet (wallet_impl ());
4528  	if (!ec)
4529  	{
4530  		nano::raw_key empty;
4531  		empty.clear ();
4532  		wallet->store.password.value_set (empty);
4533  		response_l.put ("locked", "1");
4534  		node.logger.try_log ("Wallet locked");
4535  	}
4536  	response_errors ();
4537  }
4538  void nano::json_handler::wallet_pending ()
4539  {
4540  	response_l.put ("deprecated", "1");
4541  	wallet_receivable ();
4542  }
4543  void nano::json_handler::wallet_receivable ()
4544  {
4545  	auto wallet (wallet_impl ());
4546  	auto count (count_optional_impl ());
4547  	auto threshold (threshold_optional_impl ());
4548  	bool const source = request.get<bool> ("source", false);
4549  	bool const min_version = request.get<bool> ("min_version", false);
4550  	bool const include_active = request.get<bool> ("include_active", false);
4551  	bool const include_only_confirmed = request.get<bool> ("include_only_confirmed", true);
4552  	if (!ec)
4553  	{
4554  		boost::property_tree::ptree pending;
4555  		auto transaction (node.wallets.tx_begin_read ());
4556  		auto block_transaction (node.store.tx_begin_read ());
4557  		for (auto i (wallet->store.begin (transaction)), n (wallet->store.end ()); i != n; ++i)
4558  		{
4559  			nano::account const & account (i->first);
4560  			boost::property_tree::ptree peers_l;
4561  			for (auto ii (node.store.pending.begin (block_transaction, nano::pending_key (account, 0))), nn (node.store.pending.end ()); ii != nn && nano::pending_key (ii->first).account == account && peers_l.size () < count; ++ii)
4562  			{
4563  				nano::pending_key key (ii->first);
4564  				if (block_confirmed (node, block_transaction, key.hash, include_active, include_only_confirmed))
4565  				{
4566  					if (threshold.is_zero () && !source)
4567  					{
4568  						boost::property_tree::ptree entry;
4569  						entry.put ("", key.hash.to_string ());
4570  						peers_l.push_back (std::make_pair ("", entry));
4571  					}
4572  					else
4573  					{
4574  						nano::pending_info info (ii->second);
4575  						if (info.amount.number () >= threshold.number ())
4576  						{
4577  							if (source || min_version)
4578  							{
4579  								boost::property_tree::ptree pending_tree;
4580  								pending_tree.put ("amount", info.amount.number ().convert_to<std::string> ());
4581  								if (source)
4582  								{
4583  									pending_tree.put ("source", info.source.to_account ());
4584  								}
4585  								if (min_version)
4586  								{
4587  									pending_tree.put ("min_version", epoch_as_string (info.epoch));
4588  								}
4589  								peers_l.add_child (key.hash.to_string (), pending_tree);
4590  							}
4591  							else
4592  							{
4593  								peers_l.put (key.hash.to_string (), info.amount.number ().convert_to<std::string> ());
4594  							}
4595  						}
4596  					}
4597  				}
4598  			}
4599  			if (!peers_l.empty ())
4600  			{
4601  				pending.add_child (account.to_account (), peers_l);
4602  			}
4603  		}
4604  		response_l.add_child ("blocks", pending);
4605  	}
4606  	response_errors ();
4607  }
4608  void nano::json_handler::wallet_representative ()
4609  {
4610  	auto wallet (wallet_impl ());
4611  	if (!ec)
4612  	{
4613  		auto transaction (node.wallets.tx_begin_read ());
4614  		response_l.put ("representative", wallet->store.representative (transaction).to_account ());
4615  	}
4616  	response_errors ();
4617  }
4618  void nano::json_handler::wallet_representative_set ()
4619  {
4620  	node.workers.push_task (create_worker_task ([] (std::shared_ptr<nano::json_handler> const & rpc_l) {
4621  		auto wallet (rpc_l->wallet_impl ());
4622  		std::string representative_text (rpc_l->request.get<std::string> ("representative"));
4623  		auto representative (rpc_l->account_impl (representative_text, nano::error_rpc::bad_representative_number));
4624  		if (!rpc_l->ec)
4625  		{
4626  			bool update_existing_accounts (rpc_l->request.get<bool> ("update_existing_accounts", false));
4627  			{
4628  				auto transaction (rpc_l->node.wallets.tx_begin_write ());
4629  				if (wallet->store.valid_password (transaction) || !update_existing_accounts)
4630  				{
4631  					wallet->store.representative_set (transaction, representative);
4632  					rpc_l->response_l.put ("set", "1");
4633  				}
4634  				else
4635  				{
4636  					rpc_l->ec = nano::error_common::wallet_locked;
4637  				}
4638  			}
4639  			if (!rpc_l->ec && update_existing_accounts)
4640  			{
4641  				std::vector<nano::account> accounts;
4642  				{
4643  					auto transaction (rpc_l->node.wallets.tx_begin_read ());
4644  					auto block_transaction (rpc_l->node.store.tx_begin_read ());
4645  					for (auto i (wallet->store.begin (transaction)), n (wallet->store.end ()); i != n; ++i)
4646  					{
4647  						nano::account const & account (i->first);
4648  						auto info = rpc_l->node.ledger.account_info (block_transaction, account);
4649  						if (info)
4650  						{
4651  							if (info->representative != representative)
4652  							{
4653  								accounts.push_back (account);
4654  							}
4655  						}
4656  					}
4657  				}
4658  				for (auto & account : accounts)
4659  				{
4660  					wallet->change_async (
4661  					account, representative, [] (std::shared_ptr<nano::block> const &) {}, 0, false);
4662  				}
4663  			}
4664  		}
4665  		rpc_l->response_errors ();
4666  	}));
4667  }
4668  void nano::json_handler::wallet_republish ()
4669  {
4670  	auto wallet (wallet_impl ());
4671  	auto count (count_impl ());
4672  	if (!ec)
4673  	{
4674  		boost::property_tree::ptree blocks;
4675  		std::deque<std::shared_ptr<nano::block>> republish_bundle;
4676  		auto transaction (node.wallets.tx_begin_read ());
4677  		auto block_transaction (node.store.tx_begin_read ());
4678  		for (auto i (wallet->store.begin (transaction)), n (wallet->store.end ()); i != n; ++i)
4679  		{
4680  			nano::account const & account (i->first);
4681  			auto latest (node.ledger.latest (block_transaction, account));
4682  			std::shared_ptr<nano::block> block;
4683  			std::vector<nano::block_hash> hashes;
4684  			while (!latest.is_zero () && hashes.size () < count)
4685  			{
4686  				hashes.push_back (latest);
4687  				block = node.store.block.get (block_transaction, latest);
4688  				if (block != nullptr)
4689  				{
4690  					latest = block->previous ();
4691  				}
4692  				else
4693  				{
4694  					latest.clear ();
4695  				}
4696  			}
4697  			std::reverse (hashes.begin (), hashes.end ());
4698  			for (auto & hash : hashes)
4699  			{
4700  				block = node.store.block.get (block_transaction, hash);
4701  				republish_bundle.push_back (std::move (block));
4702  				boost::property_tree::ptree entry;
4703  				entry.put ("", hash.to_string ());
4704  				blocks.push_back (std::make_pair ("", entry));
4705  			}
4706  		}
4707  		node.network.flood_block_many (std::move (republish_bundle), nullptr, 25);
4708  		response_l.add_child ("blocks", blocks);
4709  	}
4710  	response_errors ();
4711  }
4712  void nano::json_handler::wallet_seed ()
4713  {
4714  	auto wallet (wallet_impl ());
4715  	if (!ec)
4716  	{
4717  		auto transaction (node.wallets.tx_begin_read ());
4718  		if (wallet->store.valid_password (transaction))
4719  		{
4720  			nano::raw_key seed;
4721  			wallet->store.seed (seed, transaction);
4722  			response_l.put ("seed", seed.to_string ());
4723  		}
4724  		else
4725  		{
4726  			ec = nano::error_common::wallet_locked;
4727  		}
4728  	}
4729  	response_errors ();
4730  }
4731  void nano::json_handler::wallet_work_get ()
4732  {
4733  	auto wallet (wallet_impl ());
4734  	if (!ec)
4735  	{
4736  		boost::property_tree::ptree works;
4737  		auto transaction (node.wallets.tx_begin_read ());
4738  		for (auto i (wallet->store.begin (transaction)), n (wallet->store.end ()); i != n; ++i)
4739  		{
4740  			nano::account const & account (i->first);
4741  			uint64_t work (0);
4742  			auto error_work (wallet->store.work_get (transaction, account, work));
4743  			(void)error_work;
4744  			works.put (account.to_account (), nano::to_string_hex (work));
4745  		}
4746  		response_l.add_child ("works", works);
4747  	}
4748  	response_errors ();
4749  }
4750  void nano::json_handler::work_generate ()
4751  {
4752  	boost::optional<nano::account> account;
4753  	auto account_opt (request.get_optional<std::string> ("account"));
4754  	auto work_version (work_version_optional_impl (nano::work_version::work_1));
4755  	if (!ec && account_opt.is_initialized ())
4756  	{
4757  		account = account_impl (account_opt.get ());
4758  	}
4759  	if (!ec)
4760  	{
4761  		auto hash (hash_impl ());
4762  		auto difficulty (difficulty_optional_impl (work_version));
4763  		multiplier_optional_impl (work_version, difficulty);
4764  		if (!ec && (difficulty > node.max_work_generate_difficulty (work_version) || difficulty < node.network_params.work.threshold_entry (work_version, nano::block_type::state)))
4765  		{
4766  			ec = nano::error_rpc::difficulty_limit;
4767  		}
4768  		std::shared_ptr<nano::block> block;
4769  		if (!ec && request.count ("block"))
4770  		{
4771  			block = block_impl (true);
4772  			if (block != nullptr)
4773  			{
4774  				if (hash != block->root ().as_block_hash ())
4775  				{
4776  					ec = nano::error_rpc::block_root_mismatch;
4777  				}
4778  				if (request.count ("version") == 0)
4779  				{
4780  					work_version = block->work_version ();
4781  				}
4782  				else if (!ec && work_version != block->work_version ())
4783  				{
4784  					ec = nano::error_rpc::block_work_version_mismatch;
4785  				}
4786  				if (!ec && request.count ("difficulty") == 0 && request.count ("multiplier") == 0)
4787  				{
4788  					difficulty = difficulty_ledger (*block);
4789  				}
4790  				if (!ec && node.network_params.work.difficulty (*block) >= difficulty)
4791  				{
4792  					ec = nano::error_rpc::block_work_enough;
4793  				}
4794  			}
4795  		}
4796  		if (!ec && response_l.empty ())
4797  		{
4798  			auto use_peers (request.get<bool> ("use_peers", false));
4799  			auto rpc_l (shared_from_this ());
4800  			auto callback = [rpc_l, hash, work_version, this] (boost::optional<uint64_t> const & work_a) {
4801  				if (work_a)
4802  				{
4803  					boost::property_tree::ptree response_l;
4804  					response_l.put ("hash", hash.to_string ());
4805  					uint64_t work (work_a.value ());
4806  					response_l.put ("work", nano::to_string_hex (work));
4807  					std::stringstream ostream;
4808  					auto result_difficulty (rpc_l->node.network_params.work.difficulty (work_version, hash, work));
4809  					response_l.put ("difficulty", nano::to_string_hex (result_difficulty));
4810  					auto result_multiplier = nano::difficulty::to_multiplier (result_difficulty, node.default_difficulty (work_version));
4811  					response_l.put ("multiplier", nano::to_string (result_multiplier));
4812  					boost::property_tree::write_json (ostream, response_l);
4813  					rpc_l->response (ostream.str ());
4814  				}
4815  				else
4816  				{
4817  					json_error_response (rpc_l->response, "Cancelled");
4818  				}
4819  			};
4820  			if (!use_peers)
4821  			{
4822  				if (node.local_work_generation_enabled ())
4823  				{
4824  					auto error = node.distributed_work.make (work_version, hash, {}, difficulty, callback, {});
4825  					if (error)
4826  					{
4827  						ec = nano::error_common::failure_work_generation;
4828  					}
4829  				}
4830  				else
4831  				{
4832  					ec = nano::error_common::disabled_local_work_generation;
4833  				}
4834  			}
4835  			else
4836  			{
4837  				if (!account_opt.is_initialized ())
4838  				{
4839  					auto transaction_l (node.store.tx_begin_read ());
4840  					if (node.store.block.exists (transaction_l, hash))
4841  					{
4842  						account = node.store.block.account (transaction_l, hash);
4843  					}
4844  				}
4845  				auto secondary_work_peers_l (request.get<bool> ("secondary_work_peers", false));
4846  				auto const & peers_l (secondary_work_peers_l ? node.config.secondary_work_peers : node.config.work_peers);
4847  				if (node.work_generation_enabled (peers_l))
4848  				{
4849  					node.work_generate (work_version, hash, difficulty, callback, account, secondary_work_peers_l);
4850  				}
4851  				else
4852  				{
4853  					ec = nano::error_common::disabled_work_generation;
4854  				}
4855  			}
4856  		}
4857  	}
4858  	if (ec)
4859  	{
4860  		response_errors ();
4861  	}
4862  }
4863  void nano::json_handler::work_cancel ()
4864  {
4865  	auto hash (hash_impl ());
4866  	if (!ec)
4867  	{
4868  		node.observers.work_cancel.notify (hash);
4869  		response_l.put ("success", "");
4870  	}
4871  	response_errors ();
4872  }
4873  void nano::json_handler::work_get ()
4874  {
4875  	auto wallet (wallet_impl ());
4876  	auto account (account_impl ());
4877  	if (!ec)
4878  	{
4879  		auto transaction (node.wallets.tx_begin_read ());
4880  		wallet_account_impl (transaction, wallet, account);
4881  		if (!ec)
4882  		{
4883  			uint64_t work (0);
4884  			auto error_work (wallet->store.work_get (transaction, account, work));
4885  			(void)error_work;
4886  			response_l.put ("work", nano::to_string_hex (work));
4887  		}
4888  	}
4889  	response_errors ();
4890  }
4891  void nano::json_handler::work_set ()
4892  {
4893  	node.workers.push_task (create_worker_task ([] (std::shared_ptr<nano::json_handler> const & rpc_l) {
4894  		auto wallet (rpc_l->wallet_impl ());
4895  		auto account (rpc_l->account_impl ());
4896  		auto work (rpc_l->work_optional_impl ());
4897  		if (!rpc_l->ec)
4898  		{
4899  			auto transaction (rpc_l->node.wallets.tx_begin_write ());
4900  			rpc_l->wallet_account_impl (transaction, wallet, account);
4901  			if (!rpc_l->ec)
4902  			{
4903  				wallet->store.work_put (transaction, account, work);
4904  				rpc_l->response_l.put ("success", "");
4905  			}
4906  		}
4907  		rpc_l->response_errors ();
4908  	}));
4909  }
4910  void nano::json_handler::work_validate ()
4911  {
4912  	auto hash (hash_impl ());
4913  	auto work (work_optional_impl ());
4914  	auto work_version (work_version_optional_impl (nano::work_version::work_1));
4915  	auto difficulty (difficulty_optional_impl (work_version));
4916  	multiplier_optional_impl (work_version, difficulty);
4917  	if (!ec)
4918  	{
4919  		auto result_difficulty (node.network_params.work.difficulty (work_version, hash, work));
4920  		if (request.count ("difficulty"))
4921  		{
4922  			response_l.put ("valid", (result_difficulty >= difficulty) ? "1" : "0");
4923  		}
4924  		response_l.put ("valid_all", (result_difficulty >= node.default_difficulty (work_version)) ? "1" : "0");
4925  		response_l.put ("valid_receive", (result_difficulty >= node.network_params.work.threshold (work_version, nano::block_details (nano::epoch::epoch_2, false, true, false))) ? "1" : "0");
4926  		response_l.put ("difficulty", nano::to_string_hex (result_difficulty));
4927  		auto result_multiplier = nano::difficulty::to_multiplier (result_difficulty, node.default_difficulty (work_version));
4928  		response_l.put ("multiplier", nano::to_string (result_multiplier));
4929  	}
4930  	response_errors ();
4931  }
4932  void nano::json_handler::work_peer_add ()
4933  {
4934  	std::string address_text = request.get<std::string> ("address");
4935  	std::string port_text = request.get<std::string> ("port");
4936  	uint16_t port;
4937  	if (!nano::parse_port (port_text, port))
4938  	{
4939  		node.config.work_peers.push_back (std::make_pair (address_text, port));
4940  		response_l.put ("success", "");
4941  	}
4942  	else
4943  	{
4944  		ec = nano::error_common::invalid_port;
4945  	}
4946  	response_errors ();
4947  }
4948  void nano::json_handler::work_peers ()
4949  {
4950  	boost::property_tree::ptree work_peers_l;
4951  	for (auto i (node.config.work_peers.begin ()), n (node.config.work_peers.end ()); i != n; ++i)
4952  	{
4953  		boost::property_tree::ptree entry;
4954  		entry.put ("", boost::str (boost::format ("%1%:%2%") % i->first % i->second));
4955  		work_peers_l.push_back (std::make_pair ("", entry));
4956  	}
4957  	response_l.add_child ("work_peers", work_peers_l);
4958  	response_errors ();
4959  }
4960  void nano::json_handler::work_peers_clear ()
4961  {
4962  	node.config.work_peers.clear ();
4963  	response_l.put ("success", "");
4964  	response_errors ();
4965  }
4966  void nano::json_handler::populate_backlog ()
4967  {
4968  	node.backlog.trigger ();
4969  	response_l.put ("success", "");
4970  	response_errors ();
4971  }
4972  void nano::json_handler::debug_bootstrap_priority_info ()
4973  {
4974  	if (!ec)
4975  	{
4976  		auto [blocking, priorities] = node.ascendboot.info ();
4977  		{
4978  			boost::property_tree::ptree response_priorities;
4979  			for (auto const & entry : priorities)
4980  			{
4981  				const auto account = entry.account;
4982  				const auto priority = entry.priority;
4983  				response_priorities.put (account.to_account (), priority);
4984  			}
4985  			response_l.add_child ("priorities", response_priorities);
4986  		}
4987  		{
4988  			boost::property_tree::ptree response_blocking;
4989  			for (auto const & entry : blocking)
4990  			{
4991  				const auto account = entry.account;
4992  				const auto dependency = entry.dependency;
4993  				response_blocking.put (account.to_account (), dependency.to_string ());
4994  			}
4995  			response_l.add_child ("blocking", response_blocking);
4996  		}
4997  	}
4998  	response_errors ();
4999  }
5000  void nano::inprocess_rpc_handler::process_request (std::string const &, std::string const & body_a, std::function<void (std::string const &)> response_a)
5001  {
5002  	auto handler (std::make_shared<nano::json_handler> (node, node_rpc_config, body_a, response_a, [this] () {
5003  		this->stop_callback ();
5004  		this->stop ();
5005  	}));
5006  	handler->process_request ();
5007  }
5008  void nano::inprocess_rpc_handler::process_request_v2 (rpc_handler_request_params const & params_a, std::string const & body_a, std::function<void (std::shared_ptr<std::string> const &)> response_a)
5009  {
5010  	std::string body_l = params_a.json_envelope (body_a);
5011  	auto handler (std::make_shared<nano::ipc::flatbuffers_handler> (node, ipc_server, nullptr, node.config.ipc_config));
5012  	handler->process_json (reinterpret_cast<uint8_t const *> (body_l.data ()), body_l.size (), response_a);
5013  }
5014  namespace
5015  {
5016  void construct_json (nano::container_info_component * component, boost::property_tree::ptree & parent)
5017  {
5018  	if (!component->is_composite ())
5019  	{
5020  		auto & leaf_info = static_cast<nano::container_info_leaf *> (component)->get_info ();
5021  		boost::property_tree::ptree child;
5022  		child.put ("count", leaf_info.count);
5023  		child.put ("size", leaf_info.count * leaf_info.sizeof_element);
5024  		parent.add_child (leaf_info.name, child);
5025  		return;
5026  	}
5027  	auto composite = static_cast<nano::container_info_composite *> (component);
5028  	boost::property_tree::ptree current;
5029  	for (auto & child : composite->get_children ())
5030  	{
5031  		construct_json (child.get (), current);
5032  	}
5033  	parent.add_child (composite->get_name (), current);
5034  }
5035  ipc_json_handler_no_arg_func_map create_ipc_json_handler_no_arg_func_map ()
5036  {
5037  	ipc_json_handler_no_arg_func_map no_arg_funcs;
5038  	no_arg_funcs.emplace ("account_balance", &nano::json_handler::account_balance);
5039  	no_arg_funcs.emplace ("account_block_count", &nano::json_handler::account_block_count);
5040  	no_arg_funcs.emplace ("account_count", &nano::json_handler::account_count);
5041  	no_arg_funcs.emplace ("account_create", &nano::json_handler::account_create);
5042  	no_arg_funcs.emplace ("account_get", &nano::json_handler::account_get);
5043  	no_arg_funcs.emplace ("account_history", &nano::json_handler::account_history);
5044  	no_arg_funcs.emplace ("account_info", &nano::json_handler::account_info);
5045  	no_arg_funcs.emplace ("account_key", &nano::json_handler::account_key);
5046  	no_arg_funcs.emplace ("account_list", &nano::json_handler::account_list);
5047  	no_arg_funcs.emplace ("account_move", &nano::json_handler::account_move);
5048  	no_arg_funcs.emplace ("account_remove", &nano::json_handler::account_remove);
5049  	no_arg_funcs.emplace ("account_representative", &nano::json_handler::account_representative);
5050  	no_arg_funcs.emplace ("account_representative_set", &nano::json_handler::account_representative_set);
5051  	no_arg_funcs.emplace ("account_weight", &nano::json_handler::account_weight);
5052  	no_arg_funcs.emplace ("accounts_balances", &nano::json_handler::accounts_balances);
5053  	no_arg_funcs.emplace ("accounts_representatives", &nano::json_handler::accounts_representatives);
5054  	no_arg_funcs.emplace ("accounts_create", &nano::json_handler::accounts_create);
5055  	no_arg_funcs.emplace ("accounts_frontiers", &nano::json_handler::accounts_frontiers);
5056  	no_arg_funcs.emplace ("accounts_pending", &nano::json_handler::accounts_pending);
5057  	no_arg_funcs.emplace ("accounts_receivable", &nano::json_handler::accounts_receivable);
5058  	no_arg_funcs.emplace ("active_difficulty", &nano::json_handler::active_difficulty);
5059  	no_arg_funcs.emplace ("available_supply", &nano::json_handler::available_supply);
5060  	no_arg_funcs.emplace ("block_info", &nano::json_handler::block_info);
5061  	no_arg_funcs.emplace ("block", &nano::json_handler::block_info);
5062  	no_arg_funcs.emplace ("block_confirm", &nano::json_handler::block_confirm);
5063  	no_arg_funcs.emplace ("blocks", &nano::json_handler::blocks);
5064  	no_arg_funcs.emplace ("blocks_info", &nano::json_handler::blocks_info);
5065  	no_arg_funcs.emplace ("block_account", &nano::json_handler::block_account);
5066  	no_arg_funcs.emplace ("block_count", &nano::json_handler::block_count);
5067  	no_arg_funcs.emplace ("block_create", &nano::json_handler::block_create);
5068  	no_arg_funcs.emplace ("block_hash", &nano::json_handler::block_hash);
5069  	no_arg_funcs.emplace ("bootstrap", &nano::json_handler::bootstrap);
5070  	no_arg_funcs.emplace ("bootstrap_any", &nano::json_handler::bootstrap_any);
5071  	no_arg_funcs.emplace ("bootstrap_lazy", &nano::json_handler::bootstrap_lazy);
5072  	no_arg_funcs.emplace ("bootstrap_status", &nano::json_handler::bootstrap_status);
5073  	no_arg_funcs.emplace ("confirmation_active", &nano::json_handler::confirmation_active);
5074  	no_arg_funcs.emplace ("confirmation_height_currently_processing", &nano::json_handler::confirmation_height_currently_processing);
5075  	no_arg_funcs.emplace ("confirmation_history", &nano::json_handler::confirmation_history);
5076  	no_arg_funcs.emplace ("confirmation_info", &nano::json_handler::confirmation_info);
5077  	no_arg_funcs.emplace ("confirmation_quorum", &nano::json_handler::confirmation_quorum);
5078  	no_arg_funcs.emplace ("database_txn_tracker", &nano::json_handler::database_txn_tracker);
5079  	no_arg_funcs.emplace ("delegators", &nano::json_handler::delegators);
5080  	no_arg_funcs.emplace ("delegators_count", &nano::json_handler::delegators_count);
5081  	no_arg_funcs.emplace ("deterministic_key", &nano::json_handler::deterministic_key);
5082  	no_arg_funcs.emplace ("epoch_upgrade", &nano::json_handler::epoch_upgrade);
5083  	no_arg_funcs.emplace ("frontiers", &nano::json_handler::frontiers);
5084  	no_arg_funcs.emplace ("frontier_count", &nano::json_handler::account_count);
5085  	no_arg_funcs.emplace ("keepalive", &nano::json_handler::keepalive);
5086  	no_arg_funcs.emplace ("key_create", &nano::json_handler::key_create);
5087  	no_arg_funcs.emplace ("key_expand", &nano::json_handler::key_expand);
5088  	no_arg_funcs.emplace ("ledger", &nano::json_handler::ledger);
5089  	no_arg_funcs.emplace ("node_id", &nano::json_handler::node_id);
5090  	no_arg_funcs.emplace ("node_id_delete", &nano::json_handler::node_id_delete);
5091  	no_arg_funcs.emplace ("password_change", &nano::json_handler::password_change);
5092  	no_arg_funcs.emplace ("password_enter", &nano::json_handler::password_enter);
5093  	no_arg_funcs.emplace ("wallet_unlock", &nano::json_handler::password_enter);
5094  	no_arg_funcs.emplace ("peers", &nano::json_handler::peers);
5095  	no_arg_funcs.emplace ("pending", &nano::json_handler::pending);
5096  	no_arg_funcs.emplace ("pending_exists", &nano::json_handler::pending_exists);
5097  	no_arg_funcs.emplace ("receivable", &nano::json_handler::receivable);
5098  	no_arg_funcs.emplace ("receivable_exists", &nano::json_handler::receivable_exists);
5099  	no_arg_funcs.emplace ("process", &nano::json_handler::process);
5100  	no_arg_funcs.emplace ("pruned_exists", &nano::json_handler::pruned_exists);
5101  	no_arg_funcs.emplace ("receive", &nano::json_handler::receive);
5102  	no_arg_funcs.emplace ("receive_minimum", &nano::json_handler::receive_minimum);
5103  	no_arg_funcs.emplace ("receive_minimum_set", &nano::json_handler::receive_minimum_set);
5104  	no_arg_funcs.emplace ("representatives", &nano::json_handler::representatives);
5105  	no_arg_funcs.emplace ("representatives_online", &nano::json_handler::representatives_online);
5106  	no_arg_funcs.emplace ("republish", &nano::json_handler::republish);
5107  	no_arg_funcs.emplace ("search_pending", &nano::json_handler::search_pending);
5108  	no_arg_funcs.emplace ("search_receivable", &nano::json_handler::search_receivable);
5109  	no_arg_funcs.emplace ("search_pending_all", &nano::json_handler::search_pending_all);
5110  	no_arg_funcs.emplace ("search_receivable_all", &nano::json_handler::search_receivable_all);
5111  	no_arg_funcs.emplace ("send", &nano::json_handler::send);
5112  	no_arg_funcs.emplace ("sign", &nano::json_handler::sign);
5113  	no_arg_funcs.emplace ("stats", &nano::json_handler::stats);
5114  	no_arg_funcs.emplace ("stats_clear", &nano::json_handler::stats_clear);
5115  	no_arg_funcs.emplace ("stop", &nano::json_handler::stop);
5116  	no_arg_funcs.emplace ("telemetry", &nano::json_handler::telemetry);
5117  	no_arg_funcs.emplace ("unchecked", &nano::json_handler::unchecked);
5118  	no_arg_funcs.emplace ("unchecked_clear", &nano::json_handler::unchecked_clear);
5119  	no_arg_funcs.emplace ("unchecked_get", &nano::json_handler::unchecked_get);
5120  	no_arg_funcs.emplace ("unchecked_keys", &nano::json_handler::unchecked_keys);
5121  	no_arg_funcs.emplace ("unopened", &nano::json_handler::unopened);
5122  	no_arg_funcs.emplace ("uptime", &nano::json_handler::uptime);
5123  	no_arg_funcs.emplace ("validate_account_number", &nano::json_handler::validate_account_number);
5124  	no_arg_funcs.emplace ("version", &nano::json_handler::version);
5125  	no_arg_funcs.emplace ("wallet_add", &nano::json_handler::wallet_add);
5126  	no_arg_funcs.emplace ("wallet_add_watch", &nano::json_handler::wallet_add_watch);
5127  	no_arg_funcs.emplace ("wallet_balances", &nano::json_handler::wallet_balances);
5128  	no_arg_funcs.emplace ("wallet_change_seed", &nano::json_handler::wallet_change_seed);
5129  	no_arg_funcs.emplace ("wallet_contains", &nano::json_handler::wallet_contains);
5130  	no_arg_funcs.emplace ("wallet_create", &nano::json_handler::wallet_create);
5131  	no_arg_funcs.emplace ("wallet_destroy", &nano::json_handler::wallet_destroy);
5132  	no_arg_funcs.emplace ("wallet_export", &nano::json_handler::wallet_export);
5133  	no_arg_funcs.emplace ("wallet_frontiers", &nano::json_handler::wallet_frontiers);
5134  	no_arg_funcs.emplace ("wallet_history", &nano::json_handler::wallet_history);
5135  	no_arg_funcs.emplace ("wallet_info", &nano::json_handler::wallet_info);
5136  	no_arg_funcs.emplace ("wallet_balance_total", &nano::json_handler::wallet_info);
5137  	no_arg_funcs.emplace ("wallet_key_valid", &nano::json_handler::wallet_key_valid);
5138  	no_arg_funcs.emplace ("wallet_ledger", &nano::json_handler::wallet_ledger);
5139  	no_arg_funcs.emplace ("wallet_lock", &nano::json_handler::wallet_lock);
5140  	no_arg_funcs.emplace ("wallet_pending", &nano::json_handler::wallet_pending);
5141  	no_arg_funcs.emplace ("wallet_receivable", &nano::json_handler::wallet_receivable);
5142  	no_arg_funcs.emplace ("wallet_representative", &nano::json_handler::wallet_representative);
5143  	no_arg_funcs.emplace ("wallet_representative_set", &nano::json_handler::wallet_representative_set);
5144  	no_arg_funcs.emplace ("wallet_republish", &nano::json_handler::wallet_republish);
5145  	no_arg_funcs.emplace ("wallet_work_get", &nano::json_handler::wallet_work_get);
5146  	no_arg_funcs.emplace ("work_generate", &nano::json_handler::work_generate);
5147  	no_arg_funcs.emplace ("work_cancel", &nano::json_handler::work_cancel);
5148  	no_arg_funcs.emplace ("work_get", &nano::json_handler::work_get);
5149  	no_arg_funcs.emplace ("work_set", &nano::json_handler::work_set);
5150  	no_arg_funcs.emplace ("work_validate", &nano::json_handler::work_validate);
5151  	no_arg_funcs.emplace ("work_peer_add", &nano::json_handler::work_peer_add);
5152  	no_arg_funcs.emplace ("work_peers", &nano::json_handler::work_peers);
5153  	no_arg_funcs.emplace ("work_peers_clear", &nano::json_handler::work_peers_clear);
5154  	no_arg_funcs.emplace ("populate_backlog", &nano::json_handler::populate_backlog);
5155  	no_arg_funcs.emplace ("debug_bootstrap_priority_info", &nano::json_handler::debug_bootstrap_priority_info);
5156  	return no_arg_funcs;
5157  }
5158  bool block_confirmed (nano::node & node, nano::transaction & transaction, nano::block_hash const & hash, bool include_active, bool include_only_confirmed)
5159  {
5160  	bool is_confirmed = false;
5161  	if (include_active && !include_only_confirmed)
5162  	{
5163  		is_confirmed = true;
5164  	}
5165  	else if (node.ledger.block_confirmed (transaction, hash))
5166  	{
5167  		is_confirmed = true;
5168  	}
5169  	else if (!include_only_confirmed)
5170  	{
5171  		auto block (node.store.block.get (transaction, hash));
5172  		is_confirmed = (block != nullptr && !node.active.active (*block));
5173  	}
5174  	return is_confirmed;
5175  }
5176  char const * epoch_as_string (nano::epoch epoch)
5177  {
5178  	switch (epoch)
5179  	{
5180  		case nano::epoch::epoch_2:
5181  			return "2";
5182  		case nano::epoch::epoch_1:
5183  			return "1";
5184  		default:
5185  			return "0";
5186  	}
5187  }
5188  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-vizmap.cpp</h3>
            <pre><code>1  int TVizMapLink::GetPointN(const int& PointN) const {
2      if (SrcPointN == PointN) { return DstPointN; }
3      else if (DstPointN == PointN) { return SrcPointN; }
4      else { return -1; }
5  }
6  TVizMapLandscape::TVizMapLandscape(const TVizMapLandscapeV& CatLandscapeV,
7          const PVizMapLandscape& FullLandscape, const TIntH& CatIdH,
8          const double& MxCover, const double& MnCover, const int& MnCats) {
9      const int Cats = CatLandscapeV.Len();
10      IAssert(Cats > 0); IAssert(Cats < TInt::Mx);
11      const int XDim = CatLandscapeV[0]->GetXDim();
12      const int YDim = CatLandscapeV[0]->GetYDim();
13      IAssert(FullLandscape->GetXDim() == XDim);
14      IAssert(FullLandscape->GetYDim() == YDim);
15      HeightMatrixVV.Gen(XDim, YDim); HeightMatrixVV.PutAll(0.0);
16      for (int XPos = 0; XPos < XDim; XPos++) {
17          for (int YPos = 0; YPos < YDim; YPos++) {
18              HeightMatrixVV(XPos, YPos) = sdouble(FullLandscape->GetHeight(XPos, YPos));
19          }
20      }
21      TIntH CatIdToCountH; TIntH EdgeCatH;
22      forever {
23          const int ActiveCats = CatIdH.Len() - EdgeCatH.Len();
24          if (ActiveCats <= MnCats) { break; }
25          CatIdToCountH.Clr();
26          for (int XPos = 0; XPos < XDim; XPos++) {
27              for (int YPos = 0; YPos < YDim; YPos++) {
28                  double MxHeight = 0.0; int MxCatId = -1;
29                  for (int CatId = 0; CatId < Cats; CatId++) {
30                      if (EdgeCatH.IsKey(CatId)) { continue; }
31                      const double Height = CatLandscapeV[CatId]->GetHeight(XPos, YPos);
32                      if (Height > MxHeight) { MxHeight = Height; MxCatId = CatId; }
33                  }
34                  if (MxCatId != -1) { CatIdToCountH.AddDat(MxCatId)++; }
35              }
36          }
37          int MxCount = 0, MxCatId = -1;
38          int MnCount = XDim * YDim, MnCatId = -1;
39          int CatKeyId = CatIdToCountH.FFirstKeyId();
40          while (CatIdToCountH.FNextKeyId(CatKeyId)) {
41              const int CatId = CatIdToCountH.GetKey(CatKeyId);
42              const int CatCount = CatIdToCountH[CatKeyId];
43              if (CatCount > MxCount) { MxCount = CatCount; MxCatId = CatId; }
44              if (CatCount < MnCount) { MnCount = CatCount; MnCatId = CatId; }
45          }
46          const double TopCover = double(MxCount) / double(XDim * YDim);
47          const double BottomCover = double(MnCount) / double(XDim * YDim);
48          if (TopCover > MxCover && MxCatId != -1) {
49              printf("RemovingT %d (cover: %.4f), Left: %d\n", MxCatId, TopCover, ActiveCats-1);
50              EdgeCatH.AddDat(MxCatId);
51          } else if (BottomCover < MnCover && MnCatId != -1) {
52              printf("RemovingB %d (cover: %.4f), Left: %d\n", MnCatId, BottomCover, ActiveCats-1);
<span onclick='openModal()' class='match'>53              EdgeCatH.AddDat(MnCatId);
54          } else {
55              break; 
56          }
57      }
58      TIntV SelCatIdV;
</span>59      for (int CatId = 0; CatId < Cats; CatId++) {
60          if (EdgeCatH.IsKey(CatId)) { continue; }
61          SelCatIdV.Add(CatId);
62      }
63      CatIdToCountH.Clr(); CatIdToCenterH.Clr();
64      CatMatrixVV.Gen(XDim, YDim); CatMatrixVV.PutAll(-1);
65      for (int XPos = 0; XPos < XDim; XPos++) {
66          for (int YPos = 0; YPos < YDim; YPos++) {
67              double MxHeight = 0.0; int MxCatIdN = -1;
68              for (int CatN = 0; CatN < SelCatIdV.Len(); CatN++) {
69                  const int CatIdN = SelCatIdV[CatN];
70                  const double Height = CatLandscapeV[CatIdN]->GetHeight(XPos, YPos);
71                  if (Height > MxHeight) { MxHeight = Height; MxCatIdN = CatIdN; }
72              }
73              if (MxCatIdN != -1) {
74                  const int MxCatId = CatIdH.GetKey(MxCatIdN);
75                  CatMatrixVV(XPos, YPos) = MxCatId;
76                  CatIdToCountH.AddDat(MxCatId)++;
77                  CatIdToCenterH.AddDat(MxCatId).Val1 += double(XPos) / double(XDim - 1);
78                  CatIdToCenterH.AddDat(MxCatId).Val2 += double(YPos) / double(YDim - 1);
79              }
80          }
81      }
82      int CatKeyId = CatIdToCenterH.FFirstKeyId();
83      while (CatIdToCenterH.FNextKeyId(CatKeyId)) {
84          const int CatId = CatIdToCenterH.GetKey(CatKeyId);
85          const double CatCount = double(CatIdToCountH.GetDat(CatId));
86          IAssert(CatCount > 0);
87          CatIdToCenterH[CatKeyId].Val1 = CatIdToCenterH[CatKeyId].Val1 / CatCount;
88          CatIdToCenterH[CatKeyId].Val2 = CatIdToCenterH[CatKeyId].Val2 / CatCount;
89      }
90      LevelV = FullLandscape->GetLevelV();
91  }
92  void TVizMapLandscape::PutCatVV(const TIntVV& _CatMatrixVV) {
93      IAssert(_CatMatrixVV.GetXDim() == GetXDim());
94      IAssert(_CatMatrixVV.GetYDim() == GetYDim());
95      CatMatrixVV = _CatMatrixVV;
96  }
97  int TVizMapLandscape::GetCatFromCoord(const double& X, const double& Y) {
98      const int XPos = TFlt::Round(X * double(GetXDim() - 1));
99      const int YPos = TFlt::Round(Y * double(GetYDim() - 1));
100      return GetCat(XPos, YPos);
101  }
102  void TVizMapLandscape::CalcStart(const int& XDim, const int& YDim, const double& Sigma) {
103      PKernel Kernel = TRadialKernel::New(1/Sigma);
104      CalcMatrixVV.Gen(XDim, YDim);
105      CalcMatrixVV.PutAll(0.0);
106      const double Threshold = 1e-10 * Kernel->Calc(0.0,0.0,0.0);
107      const double w = XDim, h = YDim;
108      int StampWidth = 0, StampHeight = 0;
109      while (Kernel->Calc(0,0,TMath::Sqr(StampWidth/w)) > Threshold) { StampWidth++; }
110      while (Kernel->Calc(0,0,TMath::Sqr(StampHeight/h)) > Threshold) { StampHeight++; }
111      StampWidth = TInt::GetMn(StampWidth, XDim);
112      StampHeight = TInt::GetMn(StampHeight, YDim);
113      CalcStampVV.Gen(StampWidth, StampHeight);
114      for (int x = 0; x < StampWidth; x++) {
115          const double X = x/w;
116          for (int y = 0; y < StampHeight; y++) {
117              const double Y = y/h;
118              CalcStampVV(x,y) = Kernel->Calc(0.0,0.0,X*X+Y*Y);
119          }
120      }
121  }
122  void TVizMapLandscape::CalcPutStamp(const double& PointX,
123          const double& PointY, const double& PointWgt) {
124      const int Width = CalcMatrixVV.GetXDim();
125      const int Height = CalcMatrixVV.GetYDim();
126      const int StampWidth = CalcStampVV.GetXDim();
127      const int StampHeight = CalcStampVV.GetYDim();
128      const int DocX = TFlt::Round(PointX * Width);
129      const int DocY = TFlt::Round(PointY * Height);
130      const int LowX = TInt::GetMx(DocX-StampWidth, -1);
131      const int LowY = TInt::GetMx(DocY-StampHeight, -1);
132      const int HighX = TInt::GetMn(DocX+StampWidth, Width);
133      const int HighY = TInt::GetMn(DocY+StampHeight, Height);
134      for (int x = DocX; x < HighX; x++) {
135          for (int y = DocY; y < HighY; y++) {
136              EAssertR(0 <= x && x < Width, TInt(x).GetStr());
137              EAssertR(0 <= y && y < Height, TInt(y).GetStr());
138              EAssertR(0 <= x-DocX && x-DocX < StampWidth, TInt(x).GetStr());
139              EAssertR(0 <= y-DocY && y-DocY < StampHeight, TInt(y).GetStr());
140              CalcMatrixVV(x,y) += PointWgt * CalcStampVV(x-DocX,y-DocY);
141          }
142      }
143      for (int x = DocX-1; x > LowX; x--) {
144          for (int y = DocY; y < HighY; y++) {
145              EAssertR(0 <= x && x < Width, TInt(x).GetStr());
146              EAssertR(0 <= y && y < Height, TInt(y).GetStr());
147              EAssertR(0 <= DocX-x && DocX-x < StampWidth, TInt(x).GetStr());
148              EAssertR(0 <= y-DocY && y-DocY < StampHeight, TInt(y).GetStr());
149              CalcMatrixVV(x,y) += PointWgt * CalcStampVV(DocX-x,y-DocY);
150          }
151      }
152      for (int x = DocX; x < HighX; x++) {
153          for (int y = DocY-1; y > LowY; y--) {
154              EAssertR(0 <= x && x < Width, TInt(x).GetStr());
155              EAssertR(0 <= y && y < Height, TInt(y).GetStr());
156              EAssertR(0 <= x-DocX && x-DocX < StampWidth, TInt(x).GetStr());
157              EAssertR(0 <= DocY-y && DocY-y < StampHeight, TInt(y).GetStr());
158              CalcMatrixVV(x,y) += PointWgt * CalcStampVV(x-DocX,DocY-y);
159          }
160      }
161      for (int x = DocX-1; x > LowX; x--) {
162          for (int y = DocY-1; y > LowY; y--) {
163              EAssertR(0 <= x && x < Width, TInt(x).GetStr());
164              EAssertR(0 <= y && y < Height, TInt(y).GetStr());
165              EAssertR(0 <= DocX-x && DocX-x < StampWidth, TInt(x).GetStr());
166              EAssertR(0 <= DocY-y && DocY-y < StampHeight, TInt(y).GetStr());
167              CalcMatrixVV(x,y) += PointWgt * CalcStampVV(DocX-x,DocY-y);
168          }
169      }
170  }
171  void TVizMapLandscape::CalcFinish(const double& MxVal, const int& Levels) {
172      const int Width = CalcMatrixVV.GetXDim();
173      const int Height = CalcMatrixVV.GetYDim();
174      double Mn = TFlt::Mx, Mx = 0.0;
175      for (int x = 0; x < Width; x++) {
176          for (int y = 0; y < Height; y++) {
177              Mx = TFlt::GetMx(Mx, CalcMatrixVV(x,y));
178              Mn = TFlt::GetMn(Mn, CalcMatrixVV(x,y));
179          }
180      }
181      double Diff = Mx - Mn; EAssert(Diff > 0.0);
182      HeightMatrixVV.Gen(Width, Height);
183      TSFltV HeightV(Width*Height, 0);
184      for (int x = 0; x < Width; x++) {
185          for (int y = 0; y < Height; y++) {
186              HeightMatrixVV(x,y) = sdouble(MxVal * (CalcMatrixVV(x,y)-Mn)/Diff);
187              HeightV.Add(HeightMatrixVV(x,y));
188          }
189      }
190      CalcMatrixVV.Clr(); CalcStampVV.Clr();
191      HeightV.Sort(); LevelV.Gen(Levels-1, 0);
192      for (int LevelN = 1; LevelN < Levels; LevelN++) {
193          LevelV.Add(LevelN * HeightV[HeightV.Len()/Levels]);
194      }
195  }
196  TVizMapFrame::TVizMapFrame(): PointV(), LinkV(), FrameSortN(-1) {
197  }
198  TVizMapFrame::TVizMapFrame(TSIn& SIn) {
199      PointV.Load(SIn); LinkV.Load(SIn);
200      FrameNmStr.Load(SIn); FrameSortN.Load(SIn);
201      LandscapeV.Load(SIn);
202      QueryLandscape = PVizMapLandscape(SIn);
203      PointBowDocBs = PBowDocBs(SIn);
204      KeyWdBowDocBs = PBowDocBs(SIn);
205      KeyWdSpVV.Load(SIn);
206      LinkBowDocBs = PBowDocBs(SIn);
207      LinkSpVV.Load(SIn);
208      KeyWdPointV.Load(SIn); KeyWdV.Load(SIn);
209      CatNmH.Load(SIn); DId2PointNMap.Load(SIn);
210  }
211  TVizMapFrame::TVizMapFrame(TSIn& SIn, PBowDocBs _PointBowDocBs,
212          PBowDocBs _KeyWdBowDocBs, PBowDocBs _LinkBowDocBs) {
213      PointV.Load(SIn); LinkV.Load(SIn);
214      FrameNmStr.Load(SIn); FrameSortN.Load(SIn);
215      LandscapeV.Load(SIn);
216      QueryLandscape = PVizMapLandscape(SIn);
217      PointBowDocBs = _PointBowDocBs;
218      KeyWdBowDocBs = _KeyWdBowDocBs;
219      KeyWdSpVV.Load(SIn);
220      LinkBowDocBs = _LinkBowDocBs;
221      LinkSpVV.Load(SIn);
222      KeyWdPointV.Load(SIn); KeyWdV.Load(SIn);
223      CatNmH.Load(SIn); DId2PointNMap.Load(SIn);
224  }
225  void TVizMapFrame::Save(TSOut& SOut, const bool& SaveBows) const {
226      PointV.Save(SOut); LinkV.Save(SOut);
227      FrameNmStr.Save(SOut); FrameSortN.Save(SOut);
228      LandscapeV.Save(SOut); QueryLandscape.Save(SOut);
229      if (SaveBows) { PointBowDocBs.Save(SOut); }
230      if (SaveBows) { KeyWdBowDocBs.Save(SOut); } KeyWdSpVV.Save(SOut);
231      if (SaveBows) { LinkBowDocBs.Save(SOut); } LinkSpVV.Save(SOut);
232      KeyWdPointV.Save(SOut); KeyWdV.Save(SOut);
233      CatNmH.Save(SOut); DId2PointNMap.Save(SOut);
234  }
235  int TVizMapFrame::GetPointN(const TFltV& CoordV, const double& Radius) const {
236      const int Points = PointV.Len();
237      int MnPointN = -1; double MnDist = TFlt::Mx;
238      for (int PointN = 0; PointN < Points; PointN++) {
239          const double Dist = TLinAlg::EuclDist2(CoordV, GetPoint(PointN)->GetCoordV());
240          if (MnDist > Dist) {
241              MnPointN = PointN; MnDist = Dist;
242          }
243      }
244      if (sqrt(MnDist) > Radius) { MnPointN = -1; }
245      return MnPointN;
246  }
247  int TVizMapFrame::GetRectPointV(const TFltRect& Rect, TIntV& RectPointV) const {
248      const int Points = PointV.Len(); RectPointV.Clr();
249      for (int PointN = 0; PointN < Points; PointN++) {
250          PVizMapPoint Point = GetPoint(PointN);
251          if (Rect.IsXYIn(Point->GetPointX(), Point->GetPointY())) {
252              RectPointV.Add(PointN);
253          }
254      }
255      return RectPointV.Len();
256  }
257  int TVizMapFrame::AddLink(PVizMapLink VizMapLink) {
258      EAssert(IsPointN(VizMapLink->GetSrcPointN()));
259      EAssert(IsPointN(VizMapLink->GetDstPointN()));
260      int LinkN = LinkV.Add(VizMapLink);
261      PointV[VizMapLink->GetSrcPointN()]->PutLinkN(LinkN);
262      PointV[VizMapLink->GetDstPointN()]->PutLinkN(LinkN);
263      return LinkN;
264  }
265  void TVizMapFrame::AddLandscape(const int& XDim, const int& YDim,
266          const double& Sigma, const bool& PointWgtP) {
267      PVizMapLandscape NewLandscape = TVizMapLandscape::New();
268      NewLandscape->CalcStart(XDim, YDim, Sigma);
269      const int Points = GetPoints();
270      for (int PointN = 0; PointN < Points; PointN++) {
271          const PVizMapPoint VizMapPoint = GetPoint(PointN);
272          const double PointWgt = PointWgtP ? VizMapPoint->GetWgt() : 1.0;
273          NewLandscape->CalcPutStamp(VizMapPoint->GetPointX(),
274              VizMapPoint->GetPointY(), PointWgt);
275      }
276      NewLandscape->CalcFinish(1.0, 3);
277      LandscapeV.Add(NewLandscape);
278  }
279  void TVizMapFrame::AddLandscapeFromLndMrk(const int& XDim,
280          const int& YDim, const double& Sigma,
281          const TVec<TFltV>& LndMrkPointV) {
282      PVizMapLandscape NewLandscape = TVizMapLandscape::New();
283      NewLandscape->CalcStart(XDim, YDim, Sigma);
284      const int LndMrkPoints = LndMrkPointV.Len();
285      for (int LndMrkPointN = 0; LndMrkPointN < LndMrkPoints; LndMrkPointN++) {
286          const TFltV LndMrkPoint = LndMrkPointV[LndMrkPointN];
287          IAssert(LndMrkPoint.Len() == 2);
288          NewLandscape->CalcPutStamp(LndMrkPoint[0], LndMrkPoint[1], 1.0);
289      }
290      NewLandscape->CalcFinish(1.0, 3);
291      LandscapeV.Add(NewLandscape);
292  }
293  void TVizMapFrame::AddLandscapeWithCats(const int& XDim, const int& YDim,
294          const double& Sigma, const bool& PointWgtP) {
295      TIntKdV CountCatIdV;
296      {int CatId = CatNmH.FFirstKeyId();
297      while (CatNmH.FNextKeyId(CatId)) {
298          const int Count = CatNmH[CatId];
299          CountCatIdV.Add(TIntKd(Count, CatId));
300      }}
301      CountCatIdV.Sort(false); const int MxCats = 20;
302      if (CountCatIdV.Len() > MxCats) { CountCatIdV.Trunc(MxCats); }
303      TIntH BigCatIdH;
304      for (int CatN = 0; CatN < CountCatIdV.Len(); CatN++) {
305          BigCatIdH.AddKey(CountCatIdV[CatN].Dat); }
306      const int Cats = BigCatIdH.Len(); IAssert(Cats > 0);
307      TVizMapLandscapeV CatLandscapeV(Cats, 0);
308      for (int CatIdN = 0; CatIdN < Cats; CatIdN++) {
309          PVizMapLandscape CatLandscape = TVizMapLandscape::New();
310          CatLandscape->CalcStart(XDim, YDim, Sigma);
311          CatLandscapeV.Add(CatLandscape);
312      }
313      PVizMapLandscape FullLandscape = TVizMapLandscape::New();
314      FullLandscape->CalcStart(XDim, YDim, Sigma);
315      const int Points = GetPoints();
316      for (int PointN = 0; PointN < Points; PointN++) {
317          const PVizMapPoint VizMapPoint = GetPoint(PointN);
318          const double PointWgt = PointWgtP ? VizMapPoint->GetWgt() : 1.0;
319          for (int CatIdN = 0; CatIdN < VizMapPoint->GetCats(); CatIdN++) {
320              const int CatId = VizMapPoint->GetCatId(CatIdN);
321              if (BigCatIdH.IsKey(CatId)) {
322                  CatLandscapeV[BigCatIdH.GetKeyId(CatId)]->CalcPutStamp(
323                      VizMapPoint->GetPointX(), VizMapPoint->GetPointY(), PointWgt);
324              }
325          }
326          FullLandscape->CalcPutStamp(VizMapPoint->GetPointX(),
327              VizMapPoint->GetPointY(), PointWgt);
328      }
329      for (int CatIdN = 0; CatIdN < Cats; CatIdN++) {
330          const int CatId = BigCatIdH.GetKey(CatIdN);
331          const double MxVal = double(CatNmH[CatId]) / double(Points);
332          CatLandscapeV[CatIdN]->CalcFinish(MxVal, 3);
333      }
334      FullLandscape->CalcFinish(1.0, 3);
335      LandscapeV.Add(TVizMapLandscape::New(CatLandscapeV,
336          FullLandscape, BigCatIdH, 0.6, 0.1, 2));
337  }
338  int TVizMapFrame::GetDocId(const int& PointN) const {
339      if (!IsPointN(PointN)) { return -1; }
340      PVizMapPoint Point = GetPoint(PointN);
341      if (PointBowDocBs.Empty() || !Point->IsDocId()) { return -1; }
342      return Point->GetDocId();
343  }
344  TStr TVizMapFrame::GetDocNm(const int& PointN) const {
345      if (!IsPointN(PointN)) { return ""; }
346      PVizMapPoint Point = GetPoint(PointN);
347      if (PointBowDocBs.Empty() || !Point->IsDocId()) { return ""; }
348      return PointBowDocBs->GetDocNm(Point->GetDocId());
349  }
350  TStr TVizMapFrame::GetDocBody(const int& PointN) const {
351      if (!IsPointN(PointN)) { return ""; }
352      PVizMapPoint Point = GetPoint(PointN);
353      if (PointBowDocBs.Empty() || !Point->IsDocId()) { return ""; }
354      return PointBowDocBs->GetDocStr(Point->GetDocId());
355  }
356  TStr TVizMapFrame::GetDocUrl(const int& PointN) const {
357      if (!IsPointN(PointN)) { return ""; }
358      PVizMapPoint Point = GetPoint(PointN);
359      if (PointBowDocBs.Empty() || !Point->IsDocId()) { return ""; }
360      TStr UrlStr = PointBowDocBs->GetDocDescStr(Point->GetDocId());
361      if (UrlStr.SearchStr(":&bsol;&bsol;") != -1) { return UrlStr; }
362      else { return ""; }
363  }
364  int TVizMapFrame::GenKeyWd(const TFltV& CoordV, const double& Radius,
365          const int& MxKeyWd, TStrV& KeyWdStrV, const bool& DistWgtP,
366          const bool& PointWgtP, const bool& BackKeyWdP) const {
367      if (KeyWdBowDocBs.Empty() || KeyWdSpVV.Empty()) {
368          KeyWdStrV.Clr(); return 0; }
369      TFltV FullKeyWdStrV(KeyWdBowDocBs->GetWords());
370      FullKeyWdStrV.PutAll(0.0);
371      const TVizMapPointV& _PointV = KeyWdPointV.Empty() ? PointV : KeyWdPointV;
372      const int Points = _PointV.Len(); int UsedPoints = 0, CenterPoints = 0;
373      bool PPQuad = false, PNQuad = false, NPQuad = false, NNQuad = false;
374      const double CoordX = CoordV[0], CoordY = CoordV[1];
375      for (int PointN = 0; PointN < Points; PointN++) {
376          PVizMapPoint Point = _PointV[PointN];
377          const double Dist = TLinAlg::EuclDist(CoordV, Point->GetCoordV());
378          if (Dist < Radius) {
379              PBowSpV DocSpV = KeyWdSpVV[PointN];
380              const double DistWgt = DistWgtP ? (Radius - Dist)/Radius : 1.0;
381              const double PointWgt = PointWgtP ? Point->GetWgt() : 1.0;
382              TBowLinAlg::AddVec(DistWgt*PointWgt, DocSpV, FullKeyWdStrV);
383              UsedPoints++; if (Dist < (Radius/3.0)) { CenterPoints++; }
384              const double DiffX = CoordX - Point->GetPointX();
385              const double DiffY = CoordY - Point->GetPointY();
386              PPQuad = PPQuad || (DiffX > 0 && DiffY > 0);
387              PNQuad = PNQuad || (DiffX > 0 && DiffY < 0);
388              NPQuad = NPQuad || (DiffX < 0 && DiffY > 0);
389              NNQuad = NNQuad || (DiffX < 0 && DiffY < 0);
390          }
391      }
392      if (UsedPoints == 0) { KeyWdStrV.Clr(); return 0; }
393      if (BackKeyWdP) {
394          if (CenterPoints == 5) { KeyWdStrV.Clr(); return 0; }
395          if (!(PPQuad && PNQuad && NPQuad && NNQuad)) { KeyWdStrV.Clr(); return 0; }
396      }
397      TLinAlg::NormalizeL1(FullKeyWdStrV);
398      TFltIntKdV WgtWIdKdV(FullKeyWdStrV.Len(), 0);
399      for (int WId = 0; WId < FullKeyWdStrV.Len(); WId++) {
400          WgtWIdKdV.Add(TFltIntKd(FullKeyWdStrV[WId], WId));
401      }
402      WgtWIdKdV.Sort(false);
403      KeyWdStrV.Gen(MxKeyWd, 0); int WIdN = 0;
404      while (WIdN < MxKeyWd) {
405          if (WIdN >= WgtWIdKdV.Len()) { return UsedPoints; }
406          if (WgtWIdKdV[WIdN].Key.Val < 0.001) { return UsedPoints; }
407          const int WId = WgtWIdKdV[WIdN].Dat;
408          KeyWdStrV.Add(KeyWdBowDocBs->GetWordStr(WId));
409          WIdN++;
410      }
411      return UsedPoints;
412  }
413  void TVizMapFrame::GenKeyWds(const int& KeyWds, const double& Radius,
414          const int& Candidantes, const int& RndSeed, const TFltRect& Rect) {
415      KeyWdV.Gen(KeyWds, 0); TRnd Rnd(RndSeed); TStrV KeyWdStrV;
416      const double MnX = Rect.GetMnX(), MnY = Rect.GetMnY();
417      const double LenX = Rect.GetXLen(), LenY = Rect.GetYLen();
418      for (int KeyWdN = 0; KeyWdN < KeyWds; KeyWdN++) {
419          const double X = MnX + Rnd.GetUniDev() * LenX;
420          const double Y = MnY + Rnd.GetUniDev() * LenY;
421          GenKeyWd(TFltV::GetV(X, Y), Radius, Candidantes, KeyWdStrV, false, false, true);
422          if (!KeyWdStrV.Empty()) {
423              const int KeyWdStrN = Rnd.GetUniDevInt(KeyWdStrV.Len());
424              TStr KeyWdStr = KeyWdStrV[KeyWdStrN];
425              KeyWdV.Add(TVizMapKeyWd::New(TFltV::GetV(X, Y), KeyWdStr));
426          }
427      }
428  }
429  void TVizMapFrame::AddCat(const int& PointN, const int& CatId) {
430      IAssert(IsPointN(PointN)); IAssert(CatNmH.IsKeyId(CatId));
431      CatNmH[CatId]++; GetPoint(PointN)->AddCat(CatId);
432  }
433  void TVizMapFrame::CalcDId2PointNMap() {
434      DId2PointNMap.Clr(); const int Points = GetPoints();
435      for (int PointN = 0; PointN < Points; PointN++) {
436          const PVizMapPoint VizMapPoint = GetPoint(PointN);
437          EAssert(VizMapPoint->IsDocId());
438          DId2PointNMap.AddDat(VizMapPoint->GetDocId(), PointN);
439      }
440  }
441  void TVizMapFrame::SaveVrml(const TStr& VrmlFNm, PVizMapLandscape Landscape,
442          const bool& ShowDocNmP, const bool& ShowDocPtP,
443          const bool& ShowKeyWdP, const double& FontSize,
444          const TStr& SkyColor, const TStr& TerrainColor,
445          const TStr& KeywordColor, const TStr& DocNmColor) {
446      PSOut SOut = TFOut::New(VrmlFNm);
447      TVrml::InsertHeader(SOut, SkyColor);
448      const TSFltVV& Rlf = Landscape->HeightVV(); TFltVV NewRlf;
449      const double Scale = TVrml::InsertEvelationGrid(SOut,
450          Rlf, NewRlf, TerrainColor, 5, 15.0, 0.7);
451      TStr DocSize = TStr::Fmt("%.3f %.3f %.3f",
452        FontSize, FontSize, FontSize);
453      for (int PointN = 0; PointN < GetPoints(); PointN++) {
454          TStr OrgDocNm = TStr::GetFNmStr(GetPoint(PointN)->GetPointNm());
455          const double PosX = GetPoint(PointN)->GetPointX();
456          const double PosY = GetPoint(PointN)->GetPointY();
457          TVrml::InsertBillboard(SOut, NewRlf, OrgDocNm, KeywordColor,
458            DocSize, PosX, PosY, 1.1, Scale, ShowDocNmP, ShowDocPtP);
459      }
460      if (ShowKeyWdP) {
461          TStr KeyWdSize = TStr::Fmt("%.3f %.3f %.3f",
462            0.5*FontSize, 0.5*FontSize, 0.5*FontSize);
463          TRnd Rnd(0);
464          for (int WdC = 0; WdC < 100; WdC++) {
465              const double PosX = Rnd.GetUniDev();
466              const double PosY = Rnd.GetUniDev();
467              TStrV KeyWdV; GenKeyWd(TFltV::GetV(PosX, PosY),
468                  0.3, 4, KeyWdV, false, false, true);
469              if (KeyWdV.Len() > 0) {
470                  TVrml::InsertBillboard(SOut, NewRlf,
471                    KeyWdV[Rnd.GetUniDevInt(KeyWdV.Len())], DocNmColor,
472                    KeyWdSize, PosX, PosY, 2.0, Scale, true, false);
473              }
474          }
475          for (int WdC = 0; WdC < 50; WdC++) {
476              const double PosX = Rnd.GetUniDev();
477              const double PosY = Rnd.GetUniDev();
478              TStrV KeyWdV; GenKeyWd(TFltV::GetV(PosX, PosY),
479                  0.2, 4, KeyWdV, false, false, true);
480              if (KeyWdV.Len() > 0) {
481                  TVrml::InsertBillboard(SOut, NewRlf,
482                    KeyWdV[Rnd.GetUniDevInt(KeyWdV.Len())], DocNmColor,
483                    KeyWdSize, PosX, PosY, 2.0, Scale, true, false);
484              }
485          }
486      }
487  }
488  void TVizMapFrame::SaveLegend(const TStr& TxtFNm, const int& LegendGridWidth,
489          const int& LegendGridHeight) {
490      TFOut FOut(TxtFNm);
491      for (int PointN = 0; PointN < GetPoints(); PointN++) {
492          PVizMapPoint Point = GetPoint(PointN);
493          const int XMark = (int)floor(Point->GetPointX() * LegendGridWidth);
494          const int YMark = (int)floor(Point->GetPointY() * LegendGridHeight) + 1;
495          const char XMarkCh = 'A' + XMark;
496          FOut.PutStrLn(Point->GetPointNm() + "\t" + TStr(XMarkCh) + TInt::GetStr(YMark));
497      }
498      FOut.Flush();
499  }
500  TVizMap::TVizMap(TSIn& SIn) {
501      TBool AllSameP(SIn);
502      if (AllSameP) {
503          PBowDocBs PointBowDocBs(SIn);
504          PBowDocBs KeyWdBowDocBs(SIn);
505          PBowDocBs LinkBowDocBs(SIn);
506          TInt Frames(SIn);
507          VizMapFrameV.Gen(Frames, 0);
508          for (int FrameN = 0; FrameN < Frames; FrameN++) {
509              PVizMapFrame Frame = TVizMapFrame::Load(SIn,
510                  PointBowDocBs, KeyWdBowDocBs, LinkBowDocBs);
511              VizMapFrameV.Add(Frame);
512          }
513      } else {
514          VizMapFrameV.Load(SIn);
515      }
516  }
517  void TVizMap::Save(TSOut& SOut) const {
518      TBool AllSameP = true;
519      for (int FrameN = 1; FrameN < VizMapFrameV.Len(); FrameN++) {
520          PVizMapFrame PrevFrame = VizMapFrameV[FrameN - 1];
521          PVizMapFrame Frame = VizMapFrameV[FrameN];
522          const bool PointBowP =
523              (Frame->GetPointBow().Empty() && PrevFrame->GetPointBow().Empty()) ||
524              (Frame->GetPointBow()->GetSig() == PrevFrame->GetPointBow()->GetSig());
525          const bool KeyWdBowP =
526              (Frame->GetKeyWdBow().Empty() && PrevFrame->GetKeyWdBow().Empty()) ||
527              (Frame->GetKeyWdBow()->GetSig() == PrevFrame->GetKeyWdBow()->GetSig());
528          const bool LinkBowP =
529              (Frame->GetLinkBow().Empty() && PrevFrame->GetLinkBow().Empty()) ||
530              (Frame->GetLinkBow()->GetSig() == PrevFrame->GetLinkBow()->GetSig());
531          AllSameP = PointBowP && KeyWdBowP && LinkBowP;
532          if (!AllSameP) { break; }
533      }
534      AllSameP.Save(SOut);
535      if (AllSameP) {
536          PVizMapFrame Frame = VizMapFrameV[0];
537          Frame->GetPointBow().Save(SOut);
538          Frame->GetKeyWdBow().Save(SOut);
539          Frame->GetLinkBow().Save(SOut);
540          TInt Frames = VizMapFrameV.Len(); Frames.Save(SOut);
541          for (int FrameN = 0; FrameN < Frames; FrameN++) {
542              VizMapFrameV[FrameN]->Save(SOut, false);
543          }
544      } else {
545          VizMapFrameV.Save(SOut);
546      }
547  }
548  void TVizMap::AddVizMapFrame(const PVizMapFrame& VizMapFrame, const bool& SortedP) {
549      if (SortedP) { VizMapFrameV.Add(VizMapFrame); }
550      else { VizMapFrameV.AddSorted(VizMapFrame); }
551  }
552  void TVizMap::SaveXmlDoc(TSOut& SOut, const TStr& Nm, const TStr& Body,
553          const TStr& DisplayBody, const TStrV& CatNmV, const TStrV& AuthorV,
554          const TStr& FrameNm, const int& FrameSortN) {
555      SOut.PutStrLn(" <document>");
556      SOut.PutStrLn("  <name>" + TXmlDoc::GetXmlStr(Nm) + "</name>");
557      SOut.PutStrLn("  <body>" + TXmlDoc::GetXmlStr(Body) + "</body>");
558      if (!DisplayBody.Empty()) {
559          SOut.PutStrLn("  <display_body>" + TXmlDoc::GetXmlStr(DisplayBody) + "</display_body>");
560      }
561      if (!CatNmV.Empty()) {
562          SOut.PutStrLn("  <categories>");
563          for (int CatNmN = 0; CatNmN < CatNmV.Len(); CatNmN++) {
564              SOut.PutStrLn("   <category>" +
565                  TXmlDoc::GetXmlStr(CatNmV[CatNmN]) + "</category>");
566          }
567          SOut.PutStrLn("  </categories>");
568      }
569      if (!AuthorV.Empty()) {
570          SOut.PutStrLn("  <authors>");
571          for (int AuthorN = 0; AuthorN < AuthorV.Len(); AuthorN++) {
572              SOut.PutStrLn("   <author>" +
573                  TXmlDoc::GetXmlStr(AuthorV[AuthorN]) + "</author>");
574          }
575          SOut.PutStrLn("  </authors>");
576      }
577      if (!FrameNm.Empty() && (FrameSortN != -1)) {
578          SOut.PutStrLn(TStr::Fmt("  <frame id=\"%d\">%s</frame>",
579              FrameSortN, TXmlDoc::GetXmlStr(FrameNm).CStr()));
580      }
581      SOut.PutStrLn(" </document>");
582  }
583  int TVizMapXmlDoc::AddToBowDocBs(PVizMapXmlDocBs VizMapXmlDocBs, PBowDocBs BowDocBs) const {
584      TStr DocNm = Nm;
585      if (BowDocBs->IsDocNm(DocNm)) {
586          int Count = 2; TStr NewDocNm;
587          do { NewDocNm = TStr::Fmt("%s (%3d)", DocNm.CStr(), Count++);
588          } while (BowDocBs->IsDocNm(NewDocNm));
589          DocNm = NewDocNm;
590      }
591      TStr DocBody = Body;
592      TStrV CatNmV;
593      for (int CatIdN = 0; CatIdN < CatIdV.Len(); CatIdN++) {
594          const int CatId = CatIdV[CatIdN];
595          CatNmV.Add(VizMapXmlDocBs->CatNmH.GetKey(CatId));
596      }
597      const int DId = BowDocBs->AddHtmlDoc(DocNm, CatNmV, DocBody, true);
598      TStr AuthorStr;
599      for (int AuthorIdN = 0; AuthorIdN < AuthorIdV.Len(); AuthorIdN++) {
600          const int AuthorId = AuthorIdV[AuthorIdN];
601          if (AuthorIdN > 0) { AuthorStr + ", "; }
602          AuthorStr += VizMapXmlDocBs->AuthorNmH.GetKey(AuthorId);
603      }
604      if (!DisplayBody.Empty()) {
605          TStr DisplayBody = AuthorStr.Empty() ? DisplayBody :
606              AuthorStr + "\r\n" + DisplayBody;
607          BowDocBs->PutDocStr(DId, DisplayBody);
608      } else if (!AuthorStr.Empty()) {
609          BowDocBs->PutDocStr(DId, AuthorStr + "\r\n" + DocBody);
610      }
611      return DId;
612  }
613  TVizMapXmlDocBs::TVizMapXmlDocBs(const TStr& XmlFNm, const PNotify& Notify) {
614      PSIn XmlSIn = TFIn::New(XmlFNm); TXmlDoc::SkipTopTag(XmlSIn);
615      PXmlDoc XmlDoc; int XmlDocs=0;
616      forever {
617          XmlDoc = TXmlDoc::LoadTxt(XmlSIn); XmlDocs++;
618          if (!XmlDoc->IsOk()) { &bsol;*InfoNotify(XmlDoc->GetMsgStr());*/ break; }
619          if (XmlDocs % 10 == 0) { Notify->OnStatus(TStr::Fmt("%d\r", XmlDocs)); }
620          PXmlTok XmlTok = XmlDoc->GetTok();
621          TVizMapXmlDoc VizMapXmlDoc;
622          VizMapXmlDoc.Nm = XmlTok->GetTagVal("name", false);
623          VizMapXmlDoc.Body = XmlTok->GetTagVal("body", false);
624          if (XmlTok->IsTagTok("display_body")) {
625              VizMapXmlDoc.DisplayBody = XmlTok->GetTagVal("display_body", false); }
626          TXmlTokV CatTokV; XmlTok->GetTagTokV("categories|category", CatTokV);
627          for (int CatTokN = 0; CatTokN < CatTokV.Len(); CatTokN++) {
628              TStr CatNm = CatTokV[CatTokN]->GetTokStr(false);
629              int CatId = CatNmH.AddKey(CatNm.GetTrunc());
630              VizMapXmlDoc.CatIdV.Add(CatId);
631          }
632          TXmlTokV AuthorTokV; XmlTok->GetTagTokV("authors|author", AuthorTokV);
633          for (int AuthorTokN = 0; AuthorTokN < AuthorTokV.Len(); AuthorTokN++) {
634              TStr AuthorNm = AuthorTokV[AuthorTokN]->GetTokStr(false);
635              int AuthorId = AuthorNmH.AddKey(AuthorNm.GetTrunc());
636              VizMapXmlDoc.AuthorIdV.Add(AuthorId);
637          }
638          if (XmlTok->IsSubTag("frame")) {
639              TStr FrameNm = XmlTok->GetTagVal("frame", false);
640              const int FrameSortN = XmlTok->GetTagTok("frame")->GetIntArgVal("id", -1);
641              if (FrameNmToSortN.IsKey(FrameNm)) {
642                  IAssert(FrameSortN == FrameNmToSortN(FrameNm));
643              } else {
644                  FrameNmToSortN.AddDat(FrameNm, FrameSortN);
645              }
646              VizMapXmlDoc.FrameNm = FrameNm.GetTrunc();
647              VizMapXmlDoc.FrameSortN = FrameSortN;
648          } else {
649              IAssert(FrameNmToSortN.Empty());
650          }
651          const int DocId = XmlDocV.Add(VizMapXmlDoc);
652          if (!FrameNmToSortN.Empty()) {
653              FrameSortNToDocId.AddDat(VizMapXmlDoc.FrameSortN).Add(DocId);
654          }
655      }
656      Notify->OnStatus(TStr::Fmt("%d", XmlDocs-1));
657  }
658  TVizMapXmlDocBs::TVizMapXmlDocBs(const PWdGixRSet& RSet,
659          const TVizMapXmlDocGrouping& Grouping, const PNotify& Notify) {
660      const int Docs = RSet->GetDocs();
661      for (int DocN = 0; DocN < Docs; DocN++) {
662          TVizMapXmlDoc VizMapXmlDoc;
663          TTm DateTm = RSet->GetDocDateTime(DocN);
664          int FrameSortN = 0; TStr FrameNm = "";
665          if (Grouping == vmxdgDay) {
666              FrameNm = DateTm.GetWebLogDateStr();
667              FrameSortN = TTm::GetDateIntFromTm(DateTm);
668          } else if (Grouping == vmxdgMonth) {
669              FrameNm = TStr::Fmt("%04d-%02d", DateTm.GetYear(), DateTm.GetMonth());
670              FrameSortN = TTm::GetMonthIntFromTm(DateTm);
671          } else if (Grouping == vmxdgYear) {
672              FrameNm = TStr::Fmt("%04d", DateTm.GetYear());
673              FrameSortN = DateTm.GetYear();
674          }
675          if (Grouping == vmxdgNone) {
676              IAssert(FrameNmToSortN.Empty());
677          } else {
678              if (FrameNmToSortN.IsKey(FrameNm)) {
679                  IAssert(FrameSortN == FrameNmToSortN(FrameNm));
680              } else {
681                  FrameNmToSortN.AddDat(FrameNm, FrameSortN);
682              }
683          }
684          VizMapXmlDoc.FrameNm = FrameNm;
685          VizMapXmlDoc.FrameSortN = FrameSortN;
686          PXmlDoc Doc=TXmlDoc::LoadStr(RSet->GetDocStr(DocN));
687          IAssertR(Doc->IsOk(), Doc->GetMsgStr());
688          VizMapXmlDoc.Nm =Doc->GetTagTok("doc|title")->GetTokStr(false);
689          TChA BodyChA; VizMapXmlDoc.AuthorIdV.Clr();
690          TXmlTokV ParTokV; Doc->GetTagTokV("doc|body|p", ParTokV);
691          for (int ParTokN = 0; ParTokN < ParTokV.Len(); ParTokN++){
692              TStr ParStr = ParTokV[ParTokN]->GetTokStr(false);
693              if (!BodyChA.Empty()) { BodyChA += "\r\n"; }
694              BodyChA += ParStr;
695              TXmlTokV NmEnTokV; ParTokV[ParTokN]->GetTagTokV("nmobj", NmEnTokV);
696              for (int NmEnTokN = 0; NmEnTokN < NmEnTokV.Len(); NmEnTokN++) {
697                  TStr NmEnStr = NmEnTokV[NmEnTokN]->GetTokStr(false);
698                  const int NmEnId = AuthorNmH.AddKey(NmEnStr);
699                  VizMapXmlDoc.AuthorIdV.AddMerged(NmEnId);
700              }
701          }
702          VizMapXmlDoc.Body = BodyChA;
703          VizMapXmlDoc.CatIdV.Clr();
704          const TStrV& CatNmV = RSet->GetDocCatNmV(DocN);
705          for (int CatNmN = 0; CatNmN < CatNmV.Len(); CatNmN++) {
706              const TStr& CatNm = CatNmV[CatNmN];
707              const int CatId = CatNmH.AddKey(CatNm); CatNmH[CatId]++;
708              VizMapXmlDoc.CatIdV.AddMerged(CatId);
709          }
710          const int DocId = XmlDocV.Add(VizMapXmlDoc);
711          if (!FrameNmToSortN.Empty()) {
712              FrameSortNToDocId.AddDat(VizMapXmlDoc.FrameSortN).Add(DocId);
713          }
714      }
715  }
716  PBowDocBs TVizMapXmlDocBs::LoadBowDocBs(const TStr& XmlFNm, PSwSet SwSet,
717          PStemmer Stemmer, const int& MxNGramLen, const int& MnNGramFq) {
718      PVizMapXmlDocBs XmlDocBs = TVizMapXmlDocBs::New(XmlFNm);
719      const TVizMapXmlDocV& XmlDocV = XmlDocBs->XmlDocV;
720      PNGramBs NGramBs = NULL;
721      if (MxNGramLen > 1) {
722          TStrV DocBodyV(XmlDocV.Len(), 0);
723          for (int XmlDocN = 0; XmlDocN < XmlDocV.Len(); XmlDocN++) {
724              const TVizMapXmlDoc& XmlDoc = XmlDocV[XmlDocN];
725              DocBodyV.Add(XmlDoc.Nm + "\n" + XmlDoc.Body);
726          }
727          NGramBs = TNGramBs::GetNGramBsFromHtmlStrV(DocBodyV,
728              MxNGramLen, MnNGramFq, SwSet, Stemmer);
729      }
730      PBowDocBs BowDocBs = TBowDocBs::New(SwSet, Stemmer, NGramBs);
731      for (int XmlDocN = 0; XmlDocN < XmlDocV.Len(); XmlDocN++) {
732          const TVizMapXmlDoc& XmlDoc = XmlDocV[XmlDocN];
733          TStr DocNm = XmlDoc.Nm, DocBody = XmlDoc.Body;
734          TStrV CatNmV;
735          for (int CatIdN = 0; CatIdN < XmlDoc.CatIdV.Len(); CatIdN++) {
736              const int CatId = XmlDoc.CatIdV[CatIdN];
737              CatNmV.Add(XmlDocBs->CatNmH.GetKey(CatId));
738          }
739          TStr AuthorStr;
740          for (int AuthorIdN = 0; AuthorIdN < XmlDoc.AuthorIdV.Len(); AuthorIdN++) {
741              const int AuthorId = XmlDoc.AuthorIdV[AuthorIdN];
742              if (AuthorIdN > 0) { AuthorStr + ", "; }
743              AuthorStr += XmlDocBs->AuthorNmH.GetKey(AuthorId);
744          }
745          if (AuthorStr.Empty()) { DocBody = DocBody; }
746          else { DocBody = AuthorStr + "\r\n" + DocBody;}
747          const int DId = BowDocBs->AddHtmlDoc(DocNm, CatNmV, DocBody, true);
748          if (!XmlDoc.DisplayBody.Empty()) {
749              TStr DisplayBody = AuthorStr.Empty() ? XmlDoc.DisplayBody :
750                  AuthorStr + "\r\n" + XmlDoc.DisplayBody;
751              BowDocBs->PutDocStr(DId, DisplayBody);
752          }
753      }
754      return BowDocBs;
755  }
756  void TVizMapFactory::CG(const TMatrix& Matrix, const TFltV& b,
757          TFltV& x, PNotify Notify, const int& MaxStep, const double& EpsTer) {
758      int M = x.Len(), R = b.Len(), i;
759      TFltV r(M), p(M), q(M), tmp(R);
760      x.PutAll(0.0);
761      Matrix.MultiplyT(b, r);
762      double nro, ro, alpha, beta;
763      nro = TLinAlg::Norm2(r);
764      int k=1;
765      while (k <= MaxStep && nro > EpsTer && k <= M){
766          if (k == 1) {
767              p = r;
768          } else {
769              beta = nro / ro;
770              for (i = 0; i < M; i++)
771                  p[i] = r[i] + beta*p[i];
772          }
773          Matrix.Multiply(p, tmp);
774          Matrix.MultiplyT(tmp, q);
775          alpha = nro / TLinAlg::DotProduct(p, q);
776          for (i = 0; i < M; i++) {
777              x[i] = x[i] + alpha * p[i];
778              r[i] = r[i] - alpha * q[i];
779          }
780          ro = nro;
781          nro = TLinAlg::Norm2(r);
782          k++;
783      }
784  }
785  void TVizMapFactory::MakeFlat(PSVMTrainSet Set,
786          const TVizDistType& DistType, TVec<TFltV>& DocPointV,
787          const int& MxStep, const int& MxSecs, const double& MnDiff,
788          const bool& RndStartPos, PNotify Notify) {
789      const int Len = Set->Len();
790      const int EqN = (Len*(Len - 1))/2;
791      Notify->OnStatus(TStr::Fmt("matrix size: %d x %d", EqN, 2*Len));
792      TFltV x(Len), y(Len), dxdy(Len + Len);
793      if (RndStartPos) {
794          TRnd Rnd1(1), Rnd2(2);
795          TLAMisc::FillRnd(x, Rnd1); TLAMisc::FillRnd(y, Rnd2);
796      } else {
797          EAssertR(DocPointV.Len() == Len, TStr::Fmt("%d == %d", DocPointV.Len(), Len));
798          for (int PntN = 0; PntN < Len; PntN++) {
799              x[PntN] = DocPointV[PntN][0];
800              y[PntN] = DocPointV[PntN][1];
801          }
802      }
803      TFltV b(EqN), z(2*Len);
804      TSparseRowMatrix B; B.RowN = EqN; B.ColN = 2*Len; B.DocSpVV.Gen(EqN);
805      for (int i = 0; i < B.RowN; i++) B.DocSpVV[i].Gen(4);
806      int Step = 0; TTm StartTm = TTm::GetCurUniTm();
807      int PrevTimeSec = 0;
808      forever {
809          b.PutAll(0.0); z.PutAll(0.0);
810          int k = 0;
811          TVec<TIntFltKdV>& RowVV = B.DocSpVV;
812          for (int i = 0; i < Len; i++) {
813              for (int j = i+1; j < Len; j++) {
814                  TIntFltKdV& RowV = RowVV[k];
815                  RowV[0] = TIntFltKd(i, x[i] - x[j]);
816                  RowV[1] = TIntFltKd(j, x[j] - x[i]);
817                  RowV[2] = TIntFltKd(Len+i, y[i] - y[j]);
818                  RowV[3] = TIntFltKd(Len+j, y[j] - y[i]);
819                  double Dij = 0.0;
820                  switch (DistType) {
821                      case vdtEucl:    Dij = Set->EuclDist(i, j); break;
822                      case vdtCos: Dij = 1.0 - Set->DotProduct(i, j); break;
823                      case vdtSqrtCos: Dij = 1.0 - sqrt(Set->DotProduct(i, j)); break;
824                      default: TExcept::Throw("Wrong DistType!");
825                  }
826                  b[k] = (TMath::Sqr(Dij) - TMath::Sqr(x[j]-x[i]) - TMath::Sqr(y[j]-y[i])) / 2;
827                  k++;
828              }
829          }
830          dxdy.PutAll(0.0);
831          CG(B, b, dxdy, Notify);
832          double Diff = TMath::Mx(TFlt::Abs(dxdy[0]), TFlt::Abs(dxdy[Len]));
833          for (int i = 0; i < Len; i++) {
834              x[i] += dxdy[i]; y[i] += dxdy[Len+i];
835              Diff = TMath::Mx(Diff, TFlt::Abs(dxdy[i]), TFlt::Abs(dxdy[Len+i]));
836          }
837          Step = Step + 1;
838          const int RunTimeSec =
839            int(TTm::GetDiffMSecs(StartTm, TTm::GetCurUniTm()) / 1000);
840          if (PrevTimeSec < RunTimeSec) {
841              PrevTimeSec = RunTimeSec;
842              Notify->OnStatus(TStr::Fmt("[Step:%5d, Time:%4d, Diff %8.5f]\r", Step, RunTimeSec, Diff));
843          }
844          if ((MxStep > 0) && (Step > MxStep))  { break; }
845          if ((MxSecs > 0) && (RunTimeSec > MxSecs))  { break; }
846          if ((Diff >= 0.0) && (Diff < MnDiff))  { break; }
847      }
848      Notify->OnStatus("\n");
849      DocPointV.Gen(Len, 0);
850      for (int i = 0; i < Len; i++) {
851          DocPointV.Add(TFltV::GetV(x[i], y[i]));
852      }
853  }
854  void TVizMapFactory::NormalizePoints(TVec<TFltV>& PointV) {
855      const int Dim = PointV[0].Len();
856      for (int d = 0; d < Dim; d++) {
857          double Min = PointV[0][d];
858          double Max = PointV[0][d];
859          for (int i = 1; i < PointV.Len(); i++) {
860              const double PointVal = PointV[i][d];
861              Min = TFlt::GetMn(Min, PointVal);
862              Max = TFlt::GetMx(Max, PointVal);
863          }
864          double Diff = Max - Min; IAssert(Diff > 0);
865          for (int i = 0; i < PointV.Len(); i++) {
866              const double OldVal = PointV[i][d];
867              const double NewVal = 0.96*(OldVal - Min)/Diff + 0.02;
868              EAssertR(0.0 <= NewVal && NewVal <= 1.0,
869                TStr::Fmt("%d:%d %g %g %g %g %g", i,
870                PointV.Len(), Min, Max, Diff, OldVal, NewVal));
871              PointV[i][d] = NewVal;
872          }
873      }
874  }
875  void TVizMapFactory::LsiMds(TVec<PBowSpV> DocSpV, PSemSpace SemSpace,
876          TVec<TFltV>& DocPointV, const double& SemSpaceThresh,
877          const int& MxStep, const int& MxSecs, const double& MnDiff,
878          PNotify Notify) {
879      double ApproxVal;
880      Notify->OnStatus(TStr::Fmt("Approximating %d docs ...\n", DocSpV.Len()));
881      int SemSpcDim = SemSpace->GetDimNeededForApprox(
882          DocSpV, SemSpaceThresh, ApproxVal, 3);
883      EAssert((SemSpcDim == -1) || (SemSpcDim > 0));
884      if (SemSpcDim == -1) { SemSpcDim = SemSpace->GetVecs(); }
885      Notify->OnStatus(TStr::Fmt("Norm(dim:%d) = [avg: %.3f, mn:%.3f]",
886          SemSpcDim, ApproxVal, SemSpaceThresh));
887      Notify->OnStatus("Multidimensional Scaling:");
888      const int Docs = DocSpV.Len();
889      TVec<PBowSpV> ProjDocSpV(Docs, 0);
890      for (int DocN = 0; DocN < Docs; DocN++) {
891          ProjDocSpV.Add(SemSpace->ProjectSpV(DocSpV[DocN], SemSpcDim, false)); }
892      PSVMTrainSet DocSet = TBowDocBs2TrainSet::NewBowNoCat(ProjDocSpV);
893      MakeFlat(DocSet, vdtEucl, DocPointV, MxStep,
894          MxSecs, MnDiff, DocPointV.Empty(), Notify);
895      NormalizePoints(DocPointV);
896  }
897  PVizMapFrame TVizMapFactory::DocLsiMds(PBowDocWgtBs BowDocWgtBs,
898          PSemSpace SemSpace, const TVec<TFltV>& _DocPointV,
899          const double& SemSpaceThresh, const int& MxStep,
900          const int& MxSecs, const double& MnDiff, PNotify Notify) {
901      const int Docs = BowDocWgtBs->GetDocs();
902      TVec<PBowSpV> DocSpV(Docs, 0);
903      for (int DIdN = 0; DIdN < Docs; DIdN++) {
904          const int DId = BowDocWgtBs->GetDId(DIdN);
905          DocSpV.Add(BowDocWgtBs->GetSpV(DId));
906      }
907      TVec<TFltV> DocPointV = _DocPointV;
908      LsiMds(DocSpV, SemSpace, DocPointV, SemSpaceThresh, MxStep, MxSecs, MnDiff, Notify);
909      PVizMapFrame VizMapFrame = TVizMapFrame::New();
910      for (int DIdN = 0; DIdN < Docs; DIdN++) {
911          const int DId = BowDocWgtBs->GetDId(DIdN);
912          PVizMapPoint DocPoint = TVizMapPoint::New(DocPointV[DIdN]);
913          DocPoint->PutDocId(DId); VizMapFrame->AddPoint(DocPoint);
914      }
915      VizMapFrame->CalcDId2PointNMap();
916      return VizMapFrame;
917  }
918  void TVizMapFactory::AddDocMetadata(PVizMapFrame VizMapFrame,
919          PBowDocBs PointBowDocBs, PBowDocBs KeyWdBowDocBs,
920          PBowDocWgtBs KeyWdBowDocWgtBs, PVizMapLndMrk VizMapLndMrk) {
921      for (int CId = 0; CId < PointBowDocBs->GetCats(); CId++) {
922          TStr CatNm = PointBowDocBs->GetCatNm(CId);
923          const int NewCId = VizMapFrame->AddCatNm(CatNm);
924          IAssert(NewCId == CId);
925      }
926      VizMapFrame->PutPointBow(PointBowDocBs);
927      const int PointDocs = PointBowDocBs->GetDocs();
928      for (int PointDId = 0; PointDId < PointDocs; PointDId++) {
929          if (VizMapFrame->IsInDId(PointDId)) {
930              const int PointN = VizMapFrame->GetPointN(PointDId);
931              VizMapFrame->GetPoint(PointN)->PutPointNm(PointBowDocBs->GetDocNm(PointDId));
932              const int PointCIds = PointBowDocBs->GetDocCIds(PointDId);
933              for (int PointCIdN = 0; PointCIdN < PointCIds; PointCIdN++) {
934                  const int PointCId = PointBowDocBs->GetDocCId(PointDId, PointCIdN);
935                  VizMapFrame->AddCat(PointN, PointCId);
936              }
937          }
938      }
939      if (VizMapLndMrk.Empty()) {
940          TBowSpVV KeyWdSpVV;
941          const int Points = VizMapFrame->GetPoints();
942          for (int PointN = 0; PointN <  Points; PointN++) {
943              const int PointDId = VizMapFrame->GetPoint(PointN)->GetDocId();
944              PBowSpV KeyWdSpV = KeyWdBowDocWgtBs->GetSpV(PointDId);
945              KeyWdSpVV.Add(KeyWdSpV);
946          }
947          VizMapFrame->PutKeyWdBow(KeyWdBowDocBs, KeyWdSpVV);
948      } else {
949          TBowSpVV KeyWdSpVV;
950          const int LndMrks = VizMapLndMrk->GetLndMrks();
951          for (int LndMrkN = 0; LndMrkN < LndMrks; LndMrkN++) {
952              PVizMapPoint KeyWdPoint =
953                  TVizMapPoint::New(VizMapLndMrk->GetLndMrkPointV(LndMrkN));
954              VizMapFrame->AddKeyWdPoint(KeyWdPoint);
955              PBowSpV KeyWdSpV = VizMapLndMrk->GetLndMrkSpV(LndMrkN);
956              KeyWdSpVV.Add(KeyWdSpV);
957          }
958          VizMapFrame->PutKeyWdBow(KeyWdBowDocBs, KeyWdSpVV);
959      }
960  }
961  void TVizMapFactory::LndMrk(PBowDocWgtBs BowDocWgtBs, PBowSim BowSim,
962          const TVec<PBowSpV>& ClustSpV, const TVec<TFltV>& ClustPointV,
963          TVec<TFltV>& DocPointV, const int& LinCombNum, PNotify Notify) {
964      const int Clusts = ClustSpV.Len();
965      const int TopClustN = TInt::GetMn(LinCombNum, Clusts);
966      const int Docs = BowDocWgtBs->GetDocs();
967      Notify->OnStatus(TStr::Fmt("Positioning %d documents using %d landmarks:", Docs, Clusts));
968      DocPointV.Gen(Docs, 0);
969      for (int DocN = 0; DocN < Docs; DocN++) {
970          Notify->OnStatus(TStr::Fmt("%d\r", DocN));
971          const int DId = BowDocWgtBs->GetDId(DocN);
972          PBowSpV DocSpV = BowDocWgtBs->GetSpV(DId);
973          TFltIntKdV SimClustV(Clusts, 0);
974          for (int ClustId = 0; ClustId < Clusts; ClustId++) {
975              const double ClustSim = BowSim->GetSim(DocSpV, ClustSpV[ClustId]);
976              SimClustV.Add(TFltIntKd(ClustSim, ClustId));
977          }
978          SimClustV.Sort(false);
979          double SimSum = 0.0;
980          for (int ClustN = 0; ClustN < TopClustN; ClustN++) {
981              SimSum += SimClustV[ClustN].Key; }
982          DocPointV.Add(TFltV::GetV(0.0, 0.0));
983          for (int ClustN = 0; ClustN < TopClustN; ClustN++) {
984              const double SumWgt = (SimSum > 1e-7) ?
985                  SimClustV[ClustN].Key / SimSum : 0.0;
986              const int ClustId = SimClustV[ClustN].Dat;
987              TLinAlg::AddVec(SumWgt, ClustPointV[ClustId],
988                  DocPointV.Last(), DocPointV.Last());
989          }
990      }
991      Notify->OnStatus("");
992  }
993  PVizMapFrame TVizMapFactory::DocLndMrk(PBowDocWgtBs BowDocWgtBs,
994          const TVec<PBowSpV>& ClustSpV, const TVec<TFltV>& ClustPointV,
995          const int& LinCombNum, PNotify Notify) {
996      TVec<TFltV> DocPointV;
997      PBowSim BowSim = TBowSim::New(bstCos);
998      LndMrk(BowDocWgtBs, BowSim, ClustSpV, ClustPointV, DocPointV, LinCombNum, Notify);
999      PVizMapFrame VizMapFrame = TVizMapFrame::New();
1000      const int Docs = BowDocWgtBs->GetDocs();
1001      for (int DIdN = 0; DIdN < Docs; DIdN++) {
1002          const int DId = BowDocWgtBs->GetDId(DIdN);
1003          PVizMapPoint DocPoint = TVizMapPoint::New(DocPointV[DIdN]);
1004          DocPoint->PutDocId(DId); VizMapFrame->AddPoint(DocPoint);
1005      }
1006      VizMapFrame->CalcDId2PointNMap();
1007      return VizMapFrame;
1008  }
1009  PVizMapFrame TVizMapFactory::ClustLsiMdsDocLndMrk(PBowDocWgtBs BowDocWgtBs,
1010          PBowDocPart BowDocPart, PSemSpace SemSpace, const int& LinCombNum,
1011          const double& SemSpaceThresh, const int& MxStep, const int& MxSecs,
1012          const double& MnDiff, PNotify Notify) {
1013      const int Clusts = BowDocPart->GetClusts();
1014      TVec<PBowSpV> ClustSpV(Clusts, 0);
1015      for (int ClustN = 0; ClustN < Clusts; ClustN++) {
1016          ClustSpV.Add(BowDocPart->GetClust(ClustN)->GetConceptSpV()); }
1017      TVec<TFltV> ClustPointV; EAssert(ClustPointV.Empty());
1018      LsiMds(ClustSpV, SemSpace, ClustPointV,
1019          SemSpaceThresh, MxStep, MxSecs, MnDiff, Notify);
1020      return DocLndMrk(BowDocWgtBs, ClustSpV, ClustPointV, LinCombNum, Notify);
1021  }
1022  PVizMapFrame TVizMapFactory::NewVizMapFrame(PBowDocBs BowDocBs, PBowDocWgtBs BowDocWgtBs,
1023          PBowDocBs KeyWdBowDocBs, PBowDocWgtBs KeyWdBowDocWgtBs, const int& ThDocs,
1024          const int& Clusts, const double& SvdThreshold, const PNotify& Notify,
1025          const bool& LndPointWgt, const bool& CalcLandscapeP) {
1026      TIntV AllDIdV; BowDocBs->GetAllDIdV(AllDIdV); PVizMapFrame VizMapFrame;
1027      Notify->OnStatus(TStr::Fmt("Size of dataset: %d docs", BowDocBs->GetDocs()));
1028      if (BowDocBs->GetDocs() < ThDocs) {
1029          Notify->OnStatus("Calculating semantic space ... ");
1030          PSemSpace SemSpace = TSemSpaceAlg::CalcFullLSI(
1031              BowDocWgtBs, AllDIdV, BowDocBs->GetDocs());
1032          Notify->OnStatus("Calculating visualization map ... ");
1033          VizMapFrame = TVizMapFactory::DocLsiMds(BowDocWgtBs, SemSpace,
1034              TVec<TFltV>(), 0.93 * SvdThreshold, 5000, 500, 0.0001, Notify);
1035          Notify->OnStatus("Adding metadata ... ");
1036          TVizMapFactory::AddDocMetadata(VizMapFrame,
1037              KeyWdBowDocBs, KeyWdBowDocBs, KeyWdBowDocWgtBs);
1038          Notify->OnStatus("Calculating background landscapes ... ");
1039          if (CalcLandscapeP && KeyWdBowDocBs->IsCats()) {
1040              VizMapFrame->AddLandscape(400, 400, 0.02, LndPointWgt);
1041          } else if (CalcLandscapeP) {
1042              VizMapFrame->AddLandscape(400, 400, 0.02, LndPointWgt);
1043          }
1044      } else {
1045          Notify->OnStatus("Using large-scale pipeline ...");
1046          PBowSim BowSim = TBowSim::New(bstCos);
1047          TRnd Rnd(1);
1048          PBowDocPart BowDocPart = TBowClust::GetKMeansPartForDocWgtBs(
1049              Notify, BowDocWgtBs, BowDocBs, BowSim, Rnd, Clusts, 1, 10, 1);
1050          Notify->OnStatus("Calculating LSI ...");
1051          const int LndMrks = BowDocPart->GetClusts();
1052          TVec<PBowSpV> LndMrkSpV(LndMrks, 0);
1053          for (int LndMrkN = 0; LndMrkN < LndMrks; LndMrkN++) {
1054              LndMrkSpV.Add(BowDocPart->GetClust(LndMrkN)->GetConceptSpV()); }
1055          PSemSpace SemSpace = TSemSpaceAlg::CalcFullLSI(LndMrkSpV, LndMrks-1);
1056          Notify->OnStatus("Calculating visualization map ... ");
1057          VizMapFrame = TVizMapFactory::ClustLsiMdsDocLndMrk(BowDocWgtBs, BowDocPart,
1058              SemSpace, 3, SvdThreshold, 5000, 500, 0.0001, Notify);
1059          Notify->OnStatus("Adding metadata ... ");
1060          TVizMapFactory::AddDocMetadata(VizMapFrame,
1061              KeyWdBowDocBs, KeyWdBowDocBs, KeyWdBowDocWgtBs);
1062          Notify->OnStatus("Calculating background landscapes ... ");
1063          double BellSize = 0.02;
1064          if (BowDocBs->GetDocs() > 1500) BellSize *= 0.7;
1065          if (BowDocBs->GetDocs() > 2000) BellSize *= 0.7;
1066          if (BowDocBs->GetDocs() > 3000) BellSize *= 0.5;
1067          if (BowDocBs->GetDocs() > 4000) BellSize *= 0.5;
1068          if (CalcLandscapeP && KeyWdBowDocBs->IsCats()) {
1069              VizMapFrame->AddLandscape(400, 400, BellSize, LndPointWgt);
1070          } else if (CalcLandscapeP) {
1071              VizMapFrame->AddLandscape(400, 400, BellSize, LndPointWgt);
1072          }
1073      }
1074      Notify->OnStatus("Done ... ");
1075      return VizMapFrame;
1076  }
1077  PVizMapFrame TVizMapFactory::NewVizMapFrame(PBowDocBs BowDocBs, const int& ThDocs,
1078          const int& Clusts, const double& SvdThreshold, const PNotify& Notify,
1079          const bool& LndPointWgt, const bool& CalcLandscapeP) {
1080      PBowDocWgtBs BowDocWgtBs = TBowDocWgtBs::New(BowDocBs, bwwtLogDFNrmTFIDF);
1081      return NewVizMapFrame(BowDocBs, BowDocWgtBs, BowDocBs, BowDocWgtBs,
1082          ThDocs, Clusts, SvdThreshold, Notify, LndPointWgt, CalcLandscapeP);
1083  }
1084  PVizMapFrame TVizMapFactory::NewVizMapFrameFromLndMrk(PBowDocBs BowDocBs,
1085          PBowDocWgtBs BowDocWgtBs, PVizMapLndMrk VizMapLndMrk, const bool& LndMrkLndP,
1086          const bool& LndMrkKeyWdP, const PNotify& Notify) { 
1087      Notify->OnStatus(TStr::Fmt("Size of dataset: %d docs", BowDocWgtBs->GetDocs()));
1088      Notify->OnStatus("Calculating visualization map ... ");
1089      const TBowSpVV& LndMrkSpVV = VizMapLndMrk->GetLndMrkSpVV();
1090      const TVec<TFltV>& LndMrkPointVV = VizMapLndMrk->GetLndMrkPointVV();
1091      PVizMapFrame VizMapFrame = DocLndMrk(BowDocWgtBs,
1092          LndMrkSpVV, LndMrkPointVV, 20, Notify);
1093      Notify->OnStatus("Adding metadata ... ");
1094      if (LndMrkKeyWdP) {
1095          AddDocMetadata(VizMapFrame, BowDocBs, VizMapLndMrk->GetBowDocBs(),
1096              VizMapLndMrk->GetBowDocWgtBs(), VizMapLndMrk);
1097      } else {
1098          AddDocMetadata(VizMapFrame, BowDocBs, BowDocBs, BowDocWgtBs);
1099      }
1100      Notify->OnStatus("Calculating background landscapes ... ");
1101      double BellSize = 0.02;
1102      if (BowDocBs->GetDocs() > 1500) BellSize *= 0.7;
1103      if (BowDocBs->GetDocs() > 2000) BellSize *= 0.7;
1104      if (BowDocBs->GetDocs() > 3000) BellSize *= 0.5;
1105      if (BowDocBs->GetDocs() > 4000) BellSize *= 0.5;
1106      if (!LndMrkLndP && BowDocBs->IsCats()) {
1107          VizMapFrame->AddLandscape(400, 400, BellSize, false);
1108      } else if (!LndMrkLndP) {
1109          VizMapFrame->AddLandscape(400, 400, BellSize, false);
1110      } else {
1111          VizMapFrame->AddLandscapeFromLndMrk(400, 400, BellSize, LndMrkPointVV);
1112      }
1113      Notify->OnStatus("Done ... ");
1114      return VizMapFrame;
1115  }
1116  PVizMap TVizMapFactory::NewVizMap(PBowDocBs BowDocBs, PBowDocWgtBs BowDocWgtBs,
1117          PBowDocBs KeyWdBowDocBs, PBowDocWgtBs KeyWdBowDocWgtBs, const int& ThDocs,
1118          const int& Clusts, const double& SvdThreshold, const PNotify& Notify,
1119          const bool& LndPointWgtP, const bool& CalcLandscapeP) {
1120      return TVizMap::New(NewVizMapFrame(BowDocBs, BowDocWgtBs, KeyWdBowDocBs,
1121          KeyWdBowDocWgtBs, ThDocs, Clusts, SvdThreshold, Notify, LndPointWgtP,
1122          CalcLandscapeP));
1123  }
1124  PVizMap TVizMapFactory::NewVizMap(PBowDocBs BowDocBs, const int& ThDocs,
1125          const int& Clusts, const double& SvdThreshold, const PNotify& Notify,
1126          const bool& LndPointWgtP, const bool& CalcLandscapeP) {
1127      return TVizMap::New(NewVizMapFrame(BowDocBs, ThDocs, Clusts,
1128          SvdThreshold, Notify, LndPointWgtP, CalcLandscapeP));
1129  }
1130  PVizMap TVizMapFactory::NewVizMapStaticDoc(const PVizMapXmlDocBs& XmlDocBs,
1131          PSwSet SwSet, PStemmer Stemmer, const int& ThDocs, const int& Clusts,
1132          const double& SvdThreshold, const PNotify& Notify, const bool& LndPointWgt,
1133          const bool& CalcLandscapeP) {
1134      PBowDocBs BowDocBs = TBowDocBs::New(SwSet, Stemmer, NULL);
1135      const TVizMapXmlDocV& XmlDocV = XmlDocBs->XmlDocV;
1136      for (int XmlDocN = 0; XmlDocN < XmlDocV.Len(); XmlDocN++) {
1137          const TVizMapXmlDoc& XmlDoc = XmlDocV[XmlDocN];
1138          const int DId = XmlDoc.AddToBowDocBs(XmlDocBs, BowDocBs);
1139          IAssertR(DId == XmlDocN, TStr::Fmt("%d-%d", DId, XmlDocN));
1140      }
1141      return NewVizMap(BowDocBs, ThDocs, Clusts, SvdThreshold,
1142          Notify, LndPointWgt, CalcLandscapeP);
1143  }
1144  PVizMap TVizMapFactory::NewVizMapDynamicDoc(const PVizMapXmlDocBs& XmlDocBs,
1145          PSwSet SwSet, PStemmer Stemmer, const int& ThDocs, const int& Clusts,
1146          const double& SvdThreshold, const PNotify& Notify, const bool& LndPointWgt,
1147          const bool& CalcLandscapeP) {
1148      TIntStrH FrameSortNToNmH; TIntIntVH FrameSortNToDIdVH;
1149      PBowDocBs BowDocBs = TBowDocBs::New(SwSet, Stemmer, NULL);
1150      const TVizMapXmlDocV& XmlDocV = XmlDocBs->XmlDocV;
1151      for (int XmlDocN = 0; XmlDocN < XmlDocV.Len(); XmlDocN++) {
1152          const TVizMapXmlDoc& XmlDoc = XmlDocV[XmlDocN];
1153          const int FrameSortN = XmlDoc.FrameSortN;
1154          const TStr& FrameNm = XmlDoc.FrameNm;
1155          if (FrameSortNToNmH.IsKey(FrameSortN)) {
1156              IAssertR(FrameSortNToNmH.GetDat(FrameSortN) == FrameNm,
1157                  FrameSortNToNmH.GetDat(FrameSortN) + " != " + FrameNm);
1158          } else {
1159              FrameSortNToNmH.AddDat(FrameSortN, FrameNm);
1160          }
1161          const int DId = XmlDoc.AddToBowDocBs(XmlDocBs, BowDocBs);
1162          IAssertR(DId == XmlDocN, TStr::Fmt("%d-%d", DId, XmlDocN));
1163          FrameSortNToDIdVH.AddDat(FrameSortN).Add(DId);
1164      }
1165      FrameSortNToNmH.SortByKey();
1166      PVizMapLndMrk VizMapLndMrk = TVizMapFactory::NewVizMapLndMrk(
1167          BowDocBs, TIntV(), ThDocs, Clusts, SvdThreshold, Notify);
1168      PVizMap VizMap = TVizMap::New();
1169      Notify->OnStatus(TStr::Fmt("Processing %d frames ... ", FrameSortNToNmH.Len()));
1170      int FrameKeyId = FrameSortNToNmH.FFirstKeyId();
1171      while (FrameSortNToNmH.FNextKeyId(FrameKeyId)) {
1172          const int FrameSortN = FrameSortNToNmH.GetKey(FrameKeyId);
1173          const TIntV& FrameDIdV = FrameSortNToDIdVH.GetDat(FrameSortN);
1174          Notify->OnStatus(TStr::Fmt("Frame %d/%d (%d)... ",
1175              FrameKeyId+1, FrameSortNToNmH.Len(), FrameDIdV.Len()));
1176          PBowDocWgtBs BowDocWgtBs = TBowDocWgtBs::New(
1177              BowDocBs, bwwtLogDFNrmTFIDF, 0, 0, FrameDIdV);
1178          PVizMapFrame VizMapFrame = NewVizMapFrameFromLndMrk(BowDocBs,
1179              BowDocWgtBs, VizMapLndMrk, false, false, Notify);
1180          Notify->OnStatus("Adding metadata ... ");
1181          VizMapFrame->PutFrameNm(FrameSortNToNmH.GetDat(FrameSortN));
1182          VizMap->AddVizMapFrame(VizMapFrame, true);
1183      }
1184      Notify->OnStatus("Done");
1185      return VizMap;
1186  }
1187  PVizMap TVizMapFactory::NewVizMapStaticAuthor(const PVizMapXmlDocBs& XmlDocBs,
1188          PSwSet SwSet, PStemmer Stemmer, const int& MxAuthors, const int& ThDocs,
1189          const int& Clusts, const double& SvdThreshold, const PNotify& Notify,
1190          const bool& LndPointWgt, const bool& CalcLandscapeP) {
1191      const TVizMapXmlDocV& XmlDocV = XmlDocBs->XmlDocV;
1192      TIntH AuthorIdToFqH;
1193      for (int XmlDocN = 0; XmlDocN < XmlDocV.Len(); XmlDocN++) {
1194          const TVizMapXmlDoc& XmlDoc = XmlDocV[XmlDocN];
1195          for (int AuthorIdN = 0; AuthorIdN < XmlDoc.AuthorIdV.Len(); AuthorIdN++) {
1196              const int AuthorId = XmlDoc.AuthorIdV[AuthorIdN];
1197              AuthorIdToFqH.AddDat(AuthorId)++;
1198          }
1199      }
1200      IAssert(!AuthorIdToFqH.Empty()); AuthorIdToFqH.SortByDat(false);
1201      TIntH FqAuthorIdH;
1202      int AuthorKeyId = AuthorIdToFqH.FFirstKeyId();
1203      while (AuthorIdToFqH.FNextKeyId(AuthorKeyId)) {
1204          if (FqAuthorIdH.Len() == MxAuthors) { break; }
1205          const int AuthorId = AuthorIdToFqH.GetKey(AuthorKeyId);
1206          FqAuthorIdH.AddKey(AuthorId);
1207      }
1208      THash<TInt, TChA> AuthorIdToBodyH, AuthorIdToDisplayBodyH;
1209      TIntStrVH AuthorIdToCatNmVH;
1210      for (int XmlDocN = 0; XmlDocN < XmlDocV.Len(); XmlDocN++) {
1211          const TVizMapXmlDoc& XmlDoc = XmlDocV[XmlDocN];
1212          for (int AuthorIdN = 0; AuthorIdN < XmlDoc.AuthorIdV.Len(); AuthorIdN++) {
1213              const int AuthorId = XmlDoc.AuthorIdV[AuthorIdN];
1214              if (!FqAuthorIdH.IsKey(AuthorId)) { continue; }
1215              AuthorIdToBodyH.AddDat(AuthorId) += XmlDoc.Nm + " -- " + XmlDoc.Body + "\r\n";
1216              TStr DisplayBody = XmlDoc.DisplayBody.Empty() ? XmlDoc.Body : XmlDoc.DisplayBody;
1217              AuthorIdToDisplayBodyH.AddDat(AuthorId) += XmlDoc.Nm + " -- " + DisplayBody + "\r\n";
1218              for (int CatIdN = 0; CatIdN < XmlDoc.CatIdV.Len(); CatIdN++) {
1219                  const int CatId = XmlDoc.CatIdV[CatIdN];
1220                  AuthorIdToCatNmVH.AddDat(AuthorId).Add(
1221                      XmlDocBs->CatNmH.GetKey(CatId));
1222              }
1223          }
1224      }
1225      PBowDocBs BowDocBs = TBowDocBs::New(SwSet, Stemmer, NULL);
1226      TIntH AuthorIdToDIdH; TIntV AuthorDIdV;
1227      AuthorKeyId = AuthorIdToBodyH.FFirstKeyId();
1228      while (AuthorIdToBodyH.FNextKeyId(AuthorKeyId)) {
1229          const int AuthorId = AuthorIdToBodyH.GetKey(AuthorKeyId);
1230          TStr DocNm = XmlDocBs->AuthorNmH.GetKey(AuthorId);
1231          TStr DocBody = AuthorIdToBodyH.GetDat(AuthorId);
1232          const TStrV& CatNmV = AuthorIdToCatNmVH.AddDat(AuthorId);
1233          const int DId = BowDocBs->AddHtmlDoc(DocNm, CatNmV, DocBody, false);
1234          AuthorDIdV.Add(DId);
1235          BowDocBs->PutDocStr(DId, AuthorIdToDisplayBodyH.GetDat(AuthorId));
1236          AuthorIdToDIdH.AddDat(AuthorId, DId);
1237      }
1238      PVizMapFrame VizMapFrame = NewVizMapFrame(BowDocBs, 300, 200, 0.8, Notify, false, true);
1239      const int MxAuthorFq = AuthorIdToFqH[0];
1240      AuthorKeyId = AuthorIdToDIdH.FFirstKeyId();
1241      while (AuthorIdToDIdH.FNextKeyId(AuthorKeyId)) {
1242          const int AuthorId = AuthorIdToDIdH.GetKey(AuthorKeyId);
1243          const int AuthorDId = AuthorIdToDIdH[AuthorKeyId];
1244          const int AuthorFq = AuthorIdToFqH.GetDat(AuthorId);
1245          const double AuthorWgt = double(AuthorFq) / double(MxAuthorFq);
1246          const int PointN = VizMapFrame->GetPointN(AuthorDId);
1247          VizMapFrame->GetPoint(PointN)->PutWgt(AuthorWgt);
1248      }
1249      return TVizMap::New(VizMapFrame);
1250  }
1251  PVizMap TVizMapFactory::NewVizMapDynamicAuthor(const PVizMapXmlDocBs& XmlDocBs,
1252          PSwSet SwSet, PStemmer Stemmer, const int& MxFrames,
1253          const int& MxAuthors, const int& ThDocs,
1254          const int& Clusts, const double& SvdThreshold, const PNotify& Notify,
1255          const bool& LndPointWgt, const bool& CalcLandscapeP) {
1256      const TVizMapXmlDocV& XmlDocV = XmlDocBs->XmlDocV;
1257      TIntH AuthorIdToFqH;
1258      for (int XmlDocN = 0; XmlDocN < XmlDocV.Len(); XmlDocN++) {
1259          const TVizMapXmlDoc& XmlDoc = XmlDocV[XmlDocN];
1260          for (int AuthorIdN = 0; AuthorIdN < XmlDoc.AuthorIdV.Len(); AuthorIdN++) {
1261              const int AuthorId = XmlDoc.AuthorIdV[AuthorIdN];
1262              AuthorIdToFqH.AddDat(AuthorId)++;
1263          }
1264      }
1265      IAssert(!AuthorIdToFqH.Empty()); AuthorIdToFqH.SortByDat(false);
1266      TIntH FqAuthorIdH;
1267      int AuthorKeyId = AuthorIdToFqH.FFirstKeyId();
1268      while (AuthorIdToFqH.FNextKeyId(AuthorKeyId)) {
1269          if (FqAuthorIdH.Len() == MxAuthors) { break; }
1270          const int AuthorId = AuthorIdToFqH.GetKey(AuthorKeyId);
1271          FqAuthorIdH.AddKey(AuthorId);
1272      }
1273      PBowDocBs BowDocBs = TBowDocBs::New(SwSet, Stemmer, NULL);
1274      TIntStrH FrameSortNToNmH; TIntIntHH FrameSortNToAuthorIdHH;
1275      THash<TIntPr, TChA> FrameAuthorIdToBodyH, FrameAuthorIdToDisplayBodyH;
1276      TIntPrStrVH FrameAuthorIdToCatNmVH; TIntV DocDIdV;
1277      for (int XmlDocN = 0; XmlDocN < XmlDocV.Len(); XmlDocN++) {
1278          const TVizMapXmlDoc& XmlDoc = XmlDocV[XmlDocN];
1279          const int FrameSortN = XmlDoc.FrameSortN;
1280          const TStr& FrameNm = XmlDoc.FrameNm;
1281          if (FrameSortNToNmH.IsKey(FrameSortN)) {
1282              IAssertR(FrameSortNToNmH.GetDat(FrameSortN) == FrameNm,
1283                  FrameSortNToNmH.GetDat(FrameSortN) + " != " + FrameNm);
1284          } else {
1285              FrameSortNToNmH.AddDat(FrameSortN, FrameNm);
1286          }
1287          for (int AuthorIdN = 0; AuthorIdN < XmlDoc.AuthorIdV.Len(); AuthorIdN++) {
1288              const int AuthorId = XmlDoc.AuthorIdV[AuthorIdN];
1289              if (!FqAuthorIdH.IsKey(AuthorId)) { continue; }
1290              TIntPr FrameAuthorId(FrameSortN, AuthorId);
1291              FrameSortNToAuthorIdHH.AddDat(FrameSortN).AddDat(AuthorId)++;
1292              FrameAuthorIdToBodyH.AddDat(FrameAuthorId) +=
1293                  XmlDoc.Nm + " -- " + XmlDoc.Body + "\r\n";
1294              TStr DisplayBody = XmlDoc.DisplayBody.Empty() ?
1295                  XmlDoc.Body : XmlDoc.DisplayBody;
1296              FrameAuthorIdToDisplayBodyH.AddDat(FrameAuthorId) +=
1297                  XmlDoc.Nm + " -- " + DisplayBody + "\r\n";
1298              for (int CatIdN = 0; CatIdN < XmlDoc.CatIdV.Len(); CatIdN++) {
1299                  const int CatId = XmlDoc.CatIdV[CatIdN];
1300                  FrameAuthorIdToCatNmVH.AddDat(FrameAuthorId).Add(
1301                      XmlDocBs->CatNmH.GetKey(CatId));
1302              }
1303          }
1304          const int DId = XmlDoc.AddToBowDocBs(XmlDocBs, BowDocBs); DocDIdV.Add(DId);
1305          IAssertR(DId == XmlDocN, TStr::Fmt("%d-%d", DId, XmlDocN));
1306      }
1307      FrameSortNToNmH.SortByKey();
1308      TIntPrIntH FrameAuthorIdToDIdH; TIntIntVH FrameToDIdVH;
1309      int FrameAuthorKeyId = FrameAuthorIdToBodyH.FFirstKeyId();
1310      while (FrameAuthorIdToBodyH.FNextKeyId(FrameAuthorKeyId)) {
1311          const TIntPr& FrameAuthorId = FrameAuthorIdToBodyH.GetKey(FrameAuthorKeyId);
1312          const int FrameSortN = FrameAuthorId.Val1;
1313          const int AuthorId = FrameAuthorId.Val2;
1314          TStr DocNm = TStr::Fmt("%s [[%d]]",
1315              XmlDocBs->AuthorNmH.GetKey(AuthorId).CStr(), FrameSortN);
1316          TStr DocBody = FrameAuthorIdToBodyH.GetDat(FrameAuthorId);
1317          const TStrV& CatNmV = FrameAuthorIdToCatNmVH.GetDat(FrameAuthorId);
1318          const int DId = BowDocBs->AddHtmlDoc(DocNm, CatNmV, DocBody, false);
1319          BowDocBs->PutDocStr(DId, FrameAuthorIdToDisplayBodyH.GetDat(FrameAuthorId));
1320          FrameAuthorIdToDIdH.AddDat(FrameAuthorId, DId);
1321          FrameToDIdVH.AddDat(FrameSortN).Add(DId);
1322      }
1323      PVizMapLndMrk VizMapLndMrk = TVizMapFactory::NewVizMapLndMrk(
1324          BowDocBs, DocDIdV, ThDocs, Clusts, SvdThreshold, Notify);
1325      PVizMap VizMap = TVizMap::New();
1326      Notify->OnStatus(TStr::Fmt("Processing %d frames ... ", FrameSortNToNmH.Len()));
1327      int FrameKeyId = FrameSortNToNmH.FFirstKeyId();
1328      while (FrameSortNToNmH.FNextKeyId(FrameKeyId)) {
1329          const int FrameSortN = FrameSortNToNmH.GetKey(FrameKeyId);
1330          Notify->OnStatus(TStr::Fmt("Frame %d/%d... ",
1331              FrameKeyId+1, FrameSortNToNmH.Len()));
1332          const TIntV& FrameDIdV = FrameToDIdVH.GetDat(FrameSortN);
1333          PBowDocWgtBs BowDocWgtBs = TBowDocWgtBs::New(
1334              BowDocBs, bwwtLogDFNrmTFIDF, 0, 0, FrameDIdV);
1335          PVizMapFrame VizMapFrame = NewVizMapFrameFromLndMrk(BowDocBs,
1336              BowDocWgtBs, VizMapLndMrk, false, false, Notify);
1337          Notify->OnStatus("Adding metadata ... ");
1338          VizMapFrame->PutFrameNm(FrameSortNToNmH.GetDat(FrameSortN));
1339          const TIntH& AuthorIdH = FrameSortNToAuthorIdHH.GetDat(FrameSortN);
1340          int MxAuthorFq = 1, AuthorKeyId = AuthorIdH.FFirstKeyId();
1341          while (AuthorIdH.FNextKeyId(AuthorKeyId)) {
1342              MxAuthorFq = TInt::GetMx(MxAuthorFq, AuthorIdH[AuthorKeyId]); }
1343          AuthorKeyId = AuthorIdH.FFirstKeyId();
1344          while (AuthorIdH.FNextKeyId(AuthorKeyId)) {
1345              const int AuthorId = AuthorIdH.GetKey(AuthorKeyId);
1346              const int AuthorDId = FrameAuthorIdToDIdH.GetDat(TIntPr(FrameSortN, AuthorId));
1347              const int PointN = VizMapFrame->GetPointN(AuthorDId);
1348              const int AuthorFq = AuthorIdH[AuthorKeyId];
1349              const double AuthorWgt = double(AuthorFq) / double(MxAuthorFq);
1350              VizMapFrame->GetPoint(PointN)->PutWgt(AuthorWgt);
1351          }
1352          VizMap->AddVizMapFrame(VizMapFrame, true);
1353      }
1354      Notify->OnStatus("Done");
1355      return VizMap;
1356  }
1357  PVizMap TVizMapFactory::NewVizMap(const PVizMapXmlDocBs& XmlDocBs,
1358          const TVizXmlMapType& VizXmlMapType, PSwSet SwSet, PStemmer Stemmer,
1359          const int& ThDocs, const int& Clusts, const double& SvdThreshold,
1360          const PNotify& Notify, const bool& LndPointWgt, const bool& CalcLandscapeP) {
1361      if (VizXmlMapType == vxmtStaticDoc) {
1362          return NewVizMapStaticDoc(XmlDocBs, SwSet, Stemmer, ThDocs,
1363              Clusts, SvdThreshold, Notify, LndPointWgt, CalcLandscapeP);
1364      } else if (VizXmlMapType == vxmtDynamicAuthor) {
1365          return NewVizMapDynamicDoc(XmlDocBs, SwSet, Stemmer, ThDocs,
1366              Clusts, SvdThreshold, Notify, LndPointWgt, CalcLandscapeP);
1367      } else if (VizXmlMapType == vxmtStaticAuthor) {
1368          return NewVizMapStaticAuthor(XmlDocBs, SwSet, Stemmer, -1, ThDocs,
1369              Clusts, SvdThreshold, Notify, LndPointWgt, CalcLandscapeP);
1370      } else if (VizXmlMapType == vxmtDynamicAuthor) {
1371          return NewVizMapDynamicAuthor(XmlDocBs, SwSet, Stemmer, -1, -1, ThDocs,
1372              Clusts, SvdThreshold, Notify, LndPointWgt, CalcLandscapeP);
1373      }
1374      Fail; return NULL;
1375  }
1376  PVizMap TVizMapFactory::NewVizMap(const TStr& XmlFNm, const TVizXmlMapType& VizXmlMapType,
1377          PSwSet SwSet, PStemmer Stemmer, const int& ThDocs, const int& Clusts,
1378          const double& SvdThreshold, const PNotify& Notify, const bool& LndPointWgt,
1379          const bool& CalcLandscapeP) {
1380      PVizMapXmlDocBs XmlDocBs = TVizMapXmlDocBs::New(XmlFNm, Notify);
1381      return NewVizMap(XmlDocBs, VizXmlMapType, SwSet, Stemmer,
1382          ThDocs, Clusts, SvdThreshold, Notify, LndPointWgt, CalcLandscapeP);
1383  }
1384  PVizMapLndMrk TVizMapFactory::NewVizMapLndMrk(PBowDocBs BowDocBs,
1385          PBowDocWgtBs BowDocWgtBs, const int& ThDocs, const int& Clusts,
1386          const double& SvdThreshold, const PNotify& Notify) {
1387      Notify->OnStatus(TStr::Fmt("Size of dataset: %d docs", BowDocWgtBs->GetDocs()));
1388      TVec<PBowSpV> LndMrkSpV;
1389      if (BowDocWgtBs->GetDocs() < ThDocs) {
1390          const int Docs = BowDocWgtBs->GetDocs();
1391          LndMrkSpV.Gen(Docs, 0);
1392          for (int DIdN = 0; DIdN < Docs; DIdN++) {
1393              const int DId = BowDocWgtBs->GetDId(DIdN);
1394              PBowSpV DocSpV = BowDocWgtBs->GetSpV(DId);
1395              LndMrkSpV.Add(DocSpV);
1396          }
1397      } else {
1398          Notify->OnStatus("Using large-scale pipeline ...");
1399          PBowSim BowSim = TBowSim::New(bstCos);
1400          TRnd Rnd(1);
1401          PBowDocPart BowDocPart = TBowClust::GetKMeansPartForDocWgtBs(
1402              Notify, BowDocWgtBs, BowDocBs, BowSim, Rnd, Clusts, 1, 10, 1);
1403          const int Clusts = BowDocPart->GetClusts();
1404          LndMrkSpV.Gen(Clusts, 0);
1405          for (int ClustN = 0; ClustN < Clusts; ClustN++) {
1406              LndMrkSpV.Add(BowDocPart->GetClust(ClustN)->GetConceptSpV()); }
1407      }
1408      const int LndMrks = LndMrkSpV.Len();
1409      Notify->OnStatus(TStr::Fmt("Calculating LSI on %d landmarks ...", LndMrks));
1410      PSemSpace SemSpace = TSemSpaceAlg::CalcFullLSI(LndMrkSpV, LndMrks-1);
1411      Notify->OnStatus("Calculating LndMrk map ... ");
1412      TVec<TFltV> LndMrkPointV;
1413      LsiMds(LndMrkSpV, SemSpace, LndMrkPointV, SvdThreshold, 5000, 500, 0.0001, Notify);
1414      Notify->OnStatus("Done ... ");
1415      return TVizMapLndMrk::New(BowDocBs, BowDocWgtBs, LndMrkSpV, LndMrkPointV);
1416  }
1417  PVizMapLndMrk TVizMapFactory::NewVizMapLndMrk(PBowDocBs BowDocBs,
1418          const TIntV& DIdV, const int& ThDocs, const int& Clusts,
1419          const double& SvdThreshold, const PNotify& Notify) {
1420      TIntV NewDIdV;
1421      if (DIdV.Empty()) { BowDocBs->GetAllDIdV(NewDIdV); } else { NewDIdV = DIdV; }
1422      PBowDocWgtBs BowDocWgtBs = TBowDocWgtBs::New(BowDocBs, bwwtLogDFNrmTFIDF, 0, 0, NewDIdV);
1423      return NewVizMapLndMrk(BowDocBs, BowDocWgtBs, ThDocs, Clusts, SvdThreshold, Notify);
1424  }
1425  PVizMap TVizMapFactory::NewVizMapFromLndMrk(PBowDocBs BowDocBs, PBowDocWgtBs BowDocWgtBs,
1426          PVizMapLndMrk VizMapLndMrk, const bool& LndMrkLndP, const bool& LndMrkKeyWdP,
1427          const PNotify& Notify) {
1428      return TVizMap::New(NewVizMapFrameFromLndMrk(BowDocBs, BowDocWgtBs,
1429          VizMapLndMrk, LndMrkLndP, LndMrkKeyWdP, Notify));
1430  }
1431  PVizMap TVizMapFactory::NewVizMapFromLndMrk(PBowDocBs BowDocBs, const TIntV& DIdV,
1432          PVizMapLndMrk VizMapLndMrk, const bool& LndMrkLndP, const bool& LndMrkKeyWdP,
1433          const TBowWordWgtType& WgtType, const PNotify& Notify) {
1434      PBowDocWgtBs BowDocWgtBs = TBowDocWgtBs::New(BowDocBs, WgtType, 0, 0, DIdV);
1435      return TVizMap::New(NewVizMapFrameFromLndMrk(BowDocBs, BowDocWgtBs,
1436          VizMapLndMrk, LndMrkLndP, LndMrkKeyWdP, Notify));
1437  }
1438  void TVrml::InsertHeader(PSOut SOut, const TStr& SkyColor) {
1439      SOut->PutStrLn("#VRML V2.0 utf8");
1440      SOut->PutStrLn("WorldInfo {");
1441      SOut->PutStrLn("  title \"Semantic Wonderland\"");
1442      SOut->PutStrLn("  info [\"Spluf\"]");
1443      SOut->PutStrLn("}");
1444      SOut->PutStrLn("Background {");
1445      SOut->PutStrLn("  skyColor [0 0 0 , " + SkyColor + "]");
1446      SOut->PutStrLn("  skyAngle [3.14]");
1447      SOut->PutStrLn("}");
1448      SOut->PutStrLn("PointLight {");
1449      SOut->PutStrLn("  location 0 3.5 1");
1450      SOut->PutStrLn("}");
1451  }
1452  double TVrml::InsertEvelationGrid(PSOut SOut, const TSFltVV& Rlf,
1453          TFltVV& NewRlf, const TStr& TerrainColor, const int& N,
1454          const double& Height, const double& Spacing) {
1455      NewRlf.Gen(Rlf.GetXDim()/N, Rlf.GetYDim()/N);
1456      NewRlf.PutAll(0.0);
1457      for (int x = 0; x < Rlf.GetXDim(); x++) {
1458          for (int y = 0; y < Rlf.GetYDim(); y++) {
1459              NewRlf(x/N,y/N) += double(Rlf(x,y));
1460          }
1461      }
1462      SOut->PutStrLn("Transform {");
1463      SOut->PutStrLn("   translation 0 0 0");
1464      SOut->PutStrLn("   children [");
1465      SOut->PutStrLn("      Shape {");
1466      SOut->PutStrLn("         appearance Appearance {");
1467      SOut->PutStrLn("            material Material {");
1468      SOut->PutStrLn("               diffuseColor " + TerrainColor);
1469      SOut->PutStrLn("            }");
1470      SOut->PutStrLn("         }");
1471      SOut->PutStrLn("         geometry ElevationGrid {");
1472      SOut->PutStrLn("            xDimension " + TInt::GetStr(NewRlf.GetXDim()));
1473      SOut->PutStrLn("            zDimension " + TInt::GetStr(NewRlf.GetYDim()));
1474      SOut->PutStrLn(TStr::Fmt("            xSpacing %.2f", Spacing));
1475      SOut->PutStrLn(TStr::Fmt("            zSpacing %.2f", Spacing));
1476      SOut->PutStrLn("            height [");
1477      for (int x = 0; x < NewRlf.GetXDim(); x++) {
1478          for (int y = 0; y < NewRlf.GetYDim(); y++) {
1479              IAssertR(NewRlf(x,y) <= N*N, TStr::Fmt("%d:%d:%g", x, y, NewRlf(x,y)()));
1480              NewRlf(x,y) = Height * NewRlf(x,y)/(N*N);
1481              SOut->PutStr(TStr::Fmt("%.4f ", NewRlf(x,y)()));
1482          }
1483          SOut->PutLn();
1484      }
1485      SOut->PutStrLn("            ]");
1486      SOut->PutStrLn("         }");
1487      SOut->PutStrLn("      }");
1488      SOut->PutStrLn("   ]");
1489      SOut->PutStrLn("}");
1490      return NewRlf.GetXDim() * Spacing;
1491  }
1492  void TVrml::InsertBillboard(PSOut SOut, const TFltVV& Rlf,
1493          const TStr& Text, const TStr& Color, const TStr& Size,
1494          const double& x, const double& y, const double& Height,
1495          const double& Scale, bool DoText, bool DoPoint) {
1496      const double Spacing = Scale / Rlf.GetXDim();
1497      int PosX = TFlt::Round(Scale*x/Spacing);
1498      int PosY = TFlt::Round(Scale*y/Spacing);
1499      if (PosX < 0) PosX = 0; if (PosY < 0) PosY = 0;
1500      if (PosX >= Rlf.GetXDim()) PosX = Rlf.GetXDim() - 1;
1501      if (PosY >= Rlf.GetYDim()) PosY = Rlf.GetYDim() - 1;
1502      const double z = Rlf(PosX, PosY) + Height;
1503      if (DoText) {
1504          SOut->PutStrLn("Transform {");
1505          SOut->PutStrLn(TStr::Fmt("  translation %.3f %.3f %.3f", Scale*y, z, Scale*x));
1506          SOut->PutStrLn("  scale " + Size);
1507          SOut->PutStrLn("  children Billboard {");
1508        SOut->PutStrLn("  axisOfRotation 0 0 0");
1509        SOut->PutStrLn("  children [");
1510          SOut->PutStrLn("    Shape {");
1511          SOut->PutStrLn("      appearance Appearance { material Material {");
1512          SOut->PutStrLn("                 diffuseColor " + Color + " } }");
1513          SOut->PutStrLn("      geometry Text { fontStyle FontStyle {justify \"MIDDLE\"} string \"" + Text + "\" }");
1514          SOut->PutStrLn("     }]");
1515          SOut->PutStrLn("  }");
1516          SOut->PutStrLn("}");
1517      }
1518      if (DoPoint) {
1519          SOut->PutStrLn("Anchor {");
1520          SOut->PutStrLn("  children [");
1521          SOut->PutStrLn("    Transform {");
1522          SOut->PutStrLn(TStr::Fmt("      translation %.3f %.3f %.3f", Scale*y, z - 0.95*Height, Scale*x));
1523          SOut->PutStrLn("      rotation 0 0 1 0");
1524          SOut->PutStrLn("      children Shape {");
1525          SOut->PutStrLn("        appearance Appearance { material Material { diffuseColor " + Color + "  } }");
1526          SOut->PutStrLn("        geometry Sphere { radius 0.1 }");
1527          SOut->PutStrLn("      }                                     ");
1528          SOut->PutStrLn("    }");
1529          SOut->PutStrLn("  ]");
1530          SOut->PutStrLn("  description \"" + Text + "\"");
1531          SOut->PutStrLn("}");
1532      }
1533  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-json_handler.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-vizmap.cpp</div>
                </div>
                <div class="column column_space"><pre><code>2467  				accounts_to_filter.push_back (account);
2468  			}
2469  			else
2470  			{
2471  				break;
2472  			}
2473  		}
2474  	}
</pre></code></div>
                <div class="column column_space"><pre><code>53              EdgeCatH.AddDat(MnCatId);
54          } else {
55              break; 
56          }
57      }
58      TIntV SelCatIdV;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    