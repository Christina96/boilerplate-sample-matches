
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 79, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-w32_regex_traits.hpp</h3>
            <pre><code>1  #ifndef BOOST_W32_REGEX_TRAITS_HPP_INCLUDED
2  #define BOOST_W32_REGEX_TRAITS_HPP_INCLUDED
3  #ifndef BOOST_REGEX_NO_WIN32_LOCALE
4  #include <boost/regex/pattern_except.hpp>
5  #include <boost/regex/v5/regex_traits_defaults.hpp>
6  #ifdef BOOST_HAS_THREADS
7  #include <mutex>
8  #endif
9  #include <boost/regex/v5/primary_transform.hpp>
10  #include <boost/regex/v5/object_cache.hpp>
11  #if defined(_MSC_VER) && !defined(_WIN32_WCE) && !defined(UNDER_CE)
12  #pragma comment(lib, "user32.lib")
13  #endif
14  #ifdef BOOST_REGEX_MSVC
15  #pragma warning(push)
16  #pragma warning(disable:4786)
17  #if BOOST_REGEX_MSVC < 1910
18  #pragma warning(disable:4800)
19  #endif
20  #endif
21  #ifndef BASETYPES
22  #ifndef NO_STRICT
23  #ifndef STRICT
24  #define STRICT 1
25  #endif
26  #endif
27  #if defined(STRICT)
28  #define BOOST_RE_DETAIL_DECLARE_HANDLE(x) struct x##__; typedef struct x##__ *x
29  #else
30  #define BOOST_RE_DETAIL_DECLARE_HANDLE(x) typedef void* x
31  #endif
32  extern "C" {
33     BOOST_RE_DETAIL_DECLARE_HANDLE(HINSTANCE);
34     typedef HINSTANCE HMODULE;
35  }
36  #endif
37  namespace boost{ 
38  template <class charT>
39  class w32_regex_traits;
40  namespace BOOST_REGEX_DETAIL_NS{
41  typedef unsigned long lcid_type;        
42  typedef std::shared_ptr<void> cat_type; 
43  lcid_type  w32_get_default_locale();
44  bool  w32_is_lower(char, lcid_type);
45  #ifndef BOOST_NO_WREGEX
46  bool  w32_is_lower(wchar_t, lcid_type);
47  #endif
48  bool  w32_is_upper(char, lcid_type);
49  #ifndef BOOST_NO_WREGEX
50  bool  w32_is_upper(wchar_t, lcid_type);
51  #endif
52  cat_type  w32_cat_open(const std::string& name);
53  std::string  w32_cat_get(const cat_type& cat, lcid_type state_id, int i, const std::string& def);
54  #ifndef BOOST_NO_WREGEX
55  std::wstring  w32_cat_get(const cat_type& cat, lcid_type state_id, int i, const std::wstring& def);
56  #endif
57  std::string  w32_transform(lcid_type state_id, const char* p1, const char* p2);
58  #ifndef BOOST_NO_WREGEX
59  std::wstring  w32_transform(lcid_type state_id, const wchar_t* p1, const wchar_t* p2);
60  #endif
61  char  w32_tolower(char c, lcid_type);
62  #ifndef BOOST_NO_WREGEX
63  wchar_t  w32_tolower(wchar_t c, lcid_type);
64  #endif
65  char  w32_toupper(char c, lcid_type);
66  #ifndef BOOST_NO_WREGEX
67  wchar_t  w32_toupper(wchar_t c, lcid_type);
68  #endif
69  bool  w32_is(lcid_type, std::uint32_t mask, char c);
70  #ifndef BOOST_NO_WREGEX
71  bool  w32_is(lcid_type, std::uint32_t mask, wchar_t c);
72  #endif
73  #ifndef BASETYPES
74  #if !defined(__LP64__)
75  using dword = unsigned long;
76  #else
77  using DWORD = unsigned int;
78  #endif
79  using word = unsigned short;
80  using lctype = dword;
81  static constexpr dword ct_ctype1 = 0x00000001;
82  static constexpr dword c1_upper = 0x0001;      
83  static constexpr dword c1_lower = 0x0002;      
84  static constexpr dword c1_digit = 0x0004;      
85  static constexpr dword c1_space = 0x0008;      
86  static constexpr dword c1_punct = 0x0010;      
87  static constexpr dword c1_cntrl = 0x0020;      
88  static constexpr dword c1_blank = 0x0040;      
89  static constexpr dword c1_xdigit = 0x0080;      
90  static constexpr dword c1_alpha = 0x0100;      
91  static constexpr dword c1_defined = 0x0200;      
92  static constexpr unsigned int cp_acp = 0;
93  static constexpr dword lcmap_lowercase = 0x00000100;
94  static constexpr dword lcmap_uppercase = 0x00000200;
95  static constexpr dword lcmap_sortkey = 0x00000400;  
96  static constexpr lctype locale_idefaultansicodepage = 0x00001004;
97  # ifdef UNDER_CE
98  #  ifndef WINAPI
99  #   ifndef _WIN32_WCE_EMULATION
100  #    define BOOST_RE_STDCALL __cdecl     
101  #   else
102  #    define BOOST_RE_STDCALL __stdcall
103  #   endif
104  #  endif
105  # else
106  #  if defined(_M_IX86) || defined(__i386__)
107  #   define BOOST_RE_STDCALL __stdcall
108  #  else
109  #   define BOOST_RE_STDCALL
110  #  endif
111  # endif
112  #if defined (WIN32_PLATFORM_PSPC)
113  #define BOOST_RE_IMPORT __declspec( dllimport )
114  #elif defined (_WIN32_WCE)
115  #define BOOST_RE_IMPORT
116  #else
117  #define BOOST_RE_IMPORT __declspec( dllimport )
118  #endif
119  extern "C" {
120     BOOST_RE_IMPORT int BOOST_RE_STDCALL FreeLibrary(HMODULE hLibModule);
121     BOOST_RE_IMPORT int BOOST_RE_STDCALL LCMapStringA(lcid_type Locale, dword dwMapFlags, const char* lpSrcStr, int cchSrc, char* lpDestStr, int cchDest);
122     BOOST_RE_IMPORT int BOOST_RE_STDCALL LCMapStringW(lcid_type Locale, dword dwMapFlags, const wchar_t* lpSrcStr, int cchSrc, wchar_t* lpDestStr, int cchDest);
123     BOOST_RE_IMPORT int BOOST_RE_STDCALL MultiByteToWideChar(unsigned int CodePage, dword dwFlags, const char* lpMultiByteStr, int cbMultiByte, wchar_t* lpWideCharStr, int cchWideChar);
124     BOOST_RE_IMPORT int BOOST_RE_STDCALL LCMapStringW(lcid_type Locale, dword dwMapFlags, const wchar_t* lpSrcStr, int cchSrc, wchar_t* lpDestStr, int cchDest);
125     BOOST_RE_IMPORT int BOOST_RE_STDCALL WideCharToMultiByte(unsigned int CodePage, dword dwFlags, const wchar_t* lpWideCharStr, int cchWideChar, char* lpMultiByteStr, int cbMultiByte, const char* lpDefaultChar, int* lpUsedDefaultChar);
126     BOOST_RE_IMPORT int BOOST_RE_STDCALL GetStringTypeExA(lcid_type Locale, dword dwInfoType, const char* lpSrcStr, int cchSrc, word* lpCharType);
127     BOOST_RE_IMPORT int BOOST_RE_STDCALL GetStringTypeExW(lcid_type Locale, dword dwInfoType, const wchar_t* lpSrcStr, int cchSrc, word* lpCharType);
128     BOOST_RE_IMPORT lcid_type BOOST_RE_STDCALL GetUserDefaultLCID();
129     BOOST_RE_IMPORT int BOOST_RE_STDCALL GetStringTypeExA(lcid_type Locale, dword dwInfoType, const char* lpSrcStr, int cchSrc, word* lpCharType);
130     BOOST_RE_IMPORT int BOOST_RE_STDCALL GetStringTypeExW(lcid_type Locale, dword dwInfoType, const wchar_t* lpSrcStr, int cchSrc, word* lpCharType);
131     BOOST_RE_IMPORT HMODULE BOOST_RE_STDCALL LoadLibraryA(const char* lpLibFileName);
132     BOOST_RE_IMPORT HMODULE BOOST_RE_STDCALL LoadLibraryW(const wchar_t* lpLibFileName);
133     BOOST_RE_IMPORT int BOOST_RE_STDCALL LoadStringW(HINSTANCE hInstance, unsigned int uID, wchar_t* lpBuffer, int cchBufferMax);
134     BOOST_RE_IMPORT int BOOST_RE_STDCALL LoadStringA(HINSTANCE hInstance, unsigned int uID, char* lpBuffer, int cchBufferMax);
135     BOOST_RE_IMPORT int BOOST_RE_STDCALL GetLocaleInfoW(lcid_type Locale, lctype LCType, wchar_t* lpLCData, int cchData);
136  }
137  #else
138  using dword = DWORD;
139  using word = WORD;
140  using lctype = LCTYPE;
141  static constexpr dword ct_ctype1 = 0x00000001;
142  static constexpr dword c1_upper = 0x0001;      
143  static constexpr dword c1_lower = 0x0002;      
144  static constexpr dword c1_digit = 0x0004;      
145  static constexpr dword c1_space = 0x0008;      
146  static constexpr dword c1_punct = 0x0010;      
147  static constexpr dword c1_cntrl = 0x0020;      
148  static constexpr dword c1_blank = 0x0040;      
149  static constexpr dword c1_xdigit = 0x0080;      
150  static constexpr dword c1_alpha = 0x0100;      
151  static constexpr dword c1_defined = 0x0200;      
152  static constexpr unsigned int cp_acp = 0;
153  static constexpr dword lcmap_lowercase = 0x00000100;
154  static constexpr dword lcmap_uppercase = 0x00000200;
155  static constexpr dword lcmap_sortkey = 0x00000400;  
156  static constexpr lctype locale_idefaultansicodepage = 0x00001004;
157  using ::FreeLibrary;
158  using ::LCMapStringA;
159  using ::LCMapStringW;
160  using ::MultiByteToWideChar;
161  using ::LCMapStringW;
162  using ::WideCharToMultiByte;
163  using ::GetStringTypeExA;
164  using ::GetStringTypeExW;
165  using ::GetUserDefaultLCID;
166  using ::GetStringTypeExA;
167  using ::GetStringTypeExW;
168  using ::LoadLibraryA;
169  using ::LoadLibraryW;
170  using ::LoadStringW;
171  using ::LoadStringA;
172  using ::GetLocaleInfoW;
173  #endif
174  template <class charT>
175  struct w32_regex_traits_base
176  {
177     w32_regex_traits_base(lcid_type l)
178     { imbue(l); }
179     lcid_type imbue(lcid_type l);
180     lcid_type m_locale;
181  };
182  template <class charT>
183  inline lcid_type w32_regex_traits_base<charT>::imbue(lcid_type l)
184  {
185     lcid_type result(m_locale);
186     m_locale = l;
187     return result;
188  }
189  template <class charT>
190  class w32_regex_traits_char_layer : public w32_regex_traits_base<charT>
191  {
192     typedef std::basic_string<charT> string_type;
193     typedef std::map<charT, regex_constants::syntax_type> map_type;
194     typedef typename map_type::const_iterator map_iterator_type;
195  public:
196     w32_regex_traits_char_layer(const lcid_type l);
197     regex_constants::syntax_type syntax_type(charT c)const
198     {
199        map_iterator_type i = m_char_map.find(c);
200        return ((i == m_char_map.end()) ? 0 : i->second);
201     }
202     regex_constants::escape_syntax_type escape_syntax_type(charT c) const
203     {
204        map_iterator_type i = m_char_map.find(c);
205        if(i == m_char_map.end())
206        {
207           if(::boost::BOOST_REGEX_DETAIL_NS::w32_is_lower(c, this->m_locale)) return regex_constants::escape_type_class;
208           if(::boost::BOOST_REGEX_DETAIL_NS::w32_is_upper(c, this->m_locale)) return regex_constants::escape_type_not_class;
209           return 0;
210        }
211        return i->second;
212     }
213     charT tolower(charT c)const
214     {
215        return ::boost::BOOST_REGEX_DETAIL_NS::w32_tolower(c, this->m_locale);
216     }
217     bool isctype(std::uint32_t mask, charT c)const
218     {
219        return ::boost::BOOST_REGEX_DETAIL_NS::w32_is(this->m_locale, mask, c);
220     }
221  private:
222     string_type get_default_message(regex_constants::syntax_type);
223     map_type m_char_map;
224  };
225  template <class charT>
226  w32_regex_traits_char_layer<charT>::w32_regex_traits_char_layer(::boost::BOOST_REGEX_DETAIL_NS::lcid_type l) 
227     : w32_regex_traits_base<charT>(l)
228  {
<span onclick='openModal()' class='match'>229     cat_type cat;
230     std::string cat_name(w32_regex_traits<charT>::get_catalog_name());
231     if(cat_name.size())
232     {
233        cat = ::boost::BOOST_REGEX_DETAIL_NS::w32_cat_open(cat_name);
234        if(!cat)
235        {
236           std::string m("Unable to open message catalog: ");
237           std::runtime_error err(m + cat_name);
238           boost::BOOST_REGEX_DETAIL_NS::raise_runtime_error(err);
239        }
240     }
241     if(cat)
242     {
243        for(regex_constants::syntax_type i = 1; i < regex_constants::syntax_max; ++i)
</span>244        {
245           string_type mss = ::boost::BOOST_REGEX_DETAIL_NS::w32_cat_get(cat, this->m_locale, i, get_default_message(i));
246           for(typename string_type::size_type j = 0; j < mss.size(); ++j)
247           {
248              this->m_char_map[mss[j]] = i;
249           }
250        }
251     }
252     else
253     {
254        for(regex_constants::syntax_type i = 1; i < regex_constants::syntax_max; ++i)
255        {
256           const char* ptr = get_default_syntax(i);
257           while(ptr && *ptr)
258           {
259              this->m_char_map[static_cast<charT>(*ptr)] = i;
260              ++ptr;
261           }
262        }
263     }
264  }
265  template <class charT>
266  typename w32_regex_traits_char_layer<charT>::string_type 
267     w32_regex_traits_char_layer<charT>::get_default_message(regex_constants::syntax_type i)
268  {
269     const char* ptr = get_default_syntax(i);
270     string_type result;
271     while(ptr && *ptr)
272     {
273        result.append(1, static_cast<charT>(*ptr));
274        ++ptr;
275     }
276     return result;
277  }
278  template <>
279  class w32_regex_traits_char_layer<char> : public w32_regex_traits_base<char>
280  {
281     typedef std::string string_type;
282  public:
283     w32_regex_traits_char_layer(::boost::BOOST_REGEX_DETAIL_NS::lcid_type l)
284     : w32_regex_traits_base<char>(l)
285     {
286        init<char>();
287     }
288     regex_constants::syntax_type syntax_type(char c)const
289     {
290        return m_char_map[static_cast<unsigned char>(c)];
291     }
292     regex_constants::escape_syntax_type escape_syntax_type(char c) const
293     {
294        return m_char_map[static_cast<unsigned char>(c)];
295     }
296     char tolower(char c)const
297     {
298        return m_lower_map[static_cast<unsigned char>(c)];
299     }
300     bool isctype(std::uint32_t mask, char c)const
301     {
302        return m_type_map[static_cast<unsigned char>(c)] & mask;
303     }
304  private:
305     regex_constants::syntax_type m_char_map[1u << CHAR_BIT];
306     char m_lower_map[1u << CHAR_BIT];
307     std::uint16_t m_type_map[1u << CHAR_BIT];
308     template <class U>
309     void init();
310  };
311  template <class charT>
312  class w32_regex_traits_implementation : public w32_regex_traits_char_layer<charT>
313  {
314  public:
315     typedef typename w32_regex_traits<charT>::char_class_type char_class_type;
316     static const char_class_type mask_word = 0x0400; 
317     static const char_class_type mask_unicode = 0x0800; 
318     static const char_class_type mask_horizontal = 0x1000; 
319     static const char_class_type mask_vertical = 0x2000; 
320     static const char_class_type mask_base = 0x3ff;  
321     typedef std::basic_string<charT> string_type;
322     typedef charT char_type;
323     w32_regex_traits_implementation(::boost::BOOST_REGEX_DETAIL_NS::lcid_type l);
324     std::string error_string(regex_constants::error_type n) const
325     {
326        if(!m_error_strings.empty())
327        {
328           std::map<int, std::string>::const_iterator p = m_error_strings.find(n);
329           return (p == m_error_strings.end()) ? std::string(get_default_error_string(n)) : p->second;
330        }
331        return get_default_error_string(n);
332     }
333     char_class_type lookup_classname(const charT* p1, const charT* p2) const
334     {
335        char_class_type result = lookup_classname_imp(p1, p2);
336        if(result == 0)
337        {
338           typedef typename string_type::size_type size_type;
339           string_type temp(p1, p2);
340           for(size_type i = 0; i < temp.size(); ++i)
341              temp[i] = this->tolower(temp[i]);
342           result = lookup_classname_imp(&*temp.begin(), &*temp.begin() + temp.size());
343        }
344        return result;
345     }
346     string_type lookup_collatename(const charT* p1, const charT* p2) const;
347     string_type transform_primary(const charT* p1, const charT* p2) const;
348     string_type transform(const charT* p1, const charT* p2) const
349     {
350        return ::boost::BOOST_REGEX_DETAIL_NS::w32_transform(this->m_locale, p1, p2);
351     }
352  private:
353     std::map<int, std::string>     m_error_strings;   
354     std::map<string_type, char_class_type>  m_custom_class_names; 
355     std::map<string_type, string_type>      m_custom_collate_names; 
356     unsigned                       m_collate_type;    
357     charT                          m_collate_delim;   
358     char_class_type lookup_classname_imp(const charT* p1, const charT* p2) const;
359  };
360  template <class charT>
361  typename w32_regex_traits_implementation<charT>::string_type 
362     w32_regex_traits_implementation<charT>::transform_primary(const charT* p1, const charT* p2) const
363  {
364     string_type result;
365     switch(m_collate_type)
366     {
367     case sort_C:
368     case sort_unknown:
369        {
370           result.assign(p1, p2);
371           typedef typename string_type::size_type size_type;
372           for(size_type i = 0; i < result.size(); ++i)
373              result[i] = this->tolower(result[i]);
374           result = this->transform(&*result.begin(), &*result.begin() + result.size());
375           break;
376        }
377     case sort_fixed:
378        {
379           result.assign(this->transform(p1, p2));
380           result.erase(this->m_collate_delim);
381           break;
382        }
383     case sort_delim:
384           result.assign(this->transform(p1, p2));
385           std::size_t i;
386           for(i = 0; i < result.size(); ++i)
387           {
388              if(result[i] == m_collate_delim)
389                 break;
390           }
391           result.erase(i);
392           break;
393     }
394     if(result.empty())
395        result = string_type(1, charT(0));
396     return result;
397  }
398  template <class charT>
399  typename w32_regex_traits_implementation<charT>::string_type 
400     w32_regex_traits_implementation<charT>::lookup_collatename(const charT* p1, const charT* p2) const
401  {
402     typedef typename std::map<string_type, string_type>::const_iterator iter_type;
403     if(m_custom_collate_names.size())
404     {
405        iter_type pos = m_custom_collate_names.find(string_type(p1, p2));
406        if(pos != m_custom_collate_names.end())
407           return pos->second;
408     }
409     std::string name(p1, p2);
410     name = lookup_default_collate_name(name);
411     if(name.size())
412        return string_type(name.begin(), name.end());
413     if(p2 - p1 == 1)
414        return string_type(1, *p1);
415     return string_type();
416  }
417  template <class charT>
418  w32_regex_traits_implementation<charT>::w32_regex_traits_implementation(::boost::BOOST_REGEX_DETAIL_NS::lcid_type l)
419  : w32_regex_traits_char_layer<charT>(l)
420  {
421     cat_type cat;
422     std::string cat_name(w32_regex_traits<charT>::get_catalog_name());
423     if(cat_name.size())
424     {
425        cat = ::boost::BOOST_REGEX_DETAIL_NS::w32_cat_open(cat_name);
426        if(!cat)
427        {
428           std::string m("Unable to open message catalog: ");
429           std::runtime_error err(m + cat_name);
430           boost::BOOST_REGEX_DETAIL_NS::raise_runtime_error(err);
431        }
432     }
433     if(cat)
434     {
435        for(boost::regex_constants::error_type i = static_cast<boost::regex_constants::error_type>(0); 
436           i <= boost::regex_constants::error_unknown; 
437           i = static_cast<boost::regex_constants::error_type>(i + 1))
438        {
439           const char* p = get_default_error_string(i);
440           string_type default_message;
441           while(*p)
442           {
443              default_message.append(1, static_cast<charT>(*p));
444              ++p;
445           }
446           string_type s = ::boost::BOOST_REGEX_DETAIL_NS::w32_cat_get(cat, this->m_locale, i+200, default_message);
447           std::string result;
448           for(std::string::size_type j = 0; j < s.size(); ++j)
449           {
450              result.append(1, static_cast<char>(s[j]));
451           }
452           m_error_strings[i] = result;
453        }
454        static const char_class_type masks[14] = 
455        {
456           0x0104u, 
457           0x0100u, 
458           0x0020u, 
459           0x0004u, 
460           (~(0x0020u|0x0008u) & 0x01ffu) | 0x0400u, 
461           0x0002u, 
462           (~0x0020u & 0x01ffu) | 0x0400, 
463           0x0010u, 
464           0x0008u, 
465           0x0001u, 
466           0x0080u, 
467           0x0040u, 
468           w32_regex_traits_implementation<charT>::mask_word,
469           w32_regex_traits_implementation<charT>::mask_unicode,
470        };
471        static const string_type null_string;
472        for(unsigned int j = 0; j <= 13; ++j)
473        {
474           string_type s(::boost::BOOST_REGEX_DETAIL_NS::w32_cat_get(cat, this->m_locale, j+300, null_string));
475           if(s.size())
476              this->m_custom_class_names[s] = masks[j];
477        }
478     }
479     m_collate_type = BOOST_REGEX_DETAIL_NS::find_sort_syntax(this, &m_collate_delim);
480  }
481  template <class charT>
482  typename w32_regex_traits_implementation<charT>::char_class_type 
483     w32_regex_traits_implementation<charT>::lookup_classname_imp(const charT* p1, const charT* p2) const
484  {
485     static const char_class_type masks[22] = 
486     {
487        0,
488        0x0104u, 
489        0x0100u, 
490        0x0040u, 
491        0x0020u, 
492        0x0004u, 
493        0x0004u, 
494        (~(0x0020u|0x0008u|0x0040) & 0x01ffu) | 0x0400u, 
495        w32_regex_traits_implementation<charT>::mask_horizontal, 
496        0x0002u, 
497        0x0002u, 
498        (~0x0020u & 0x01ffu) | 0x0400, 
499        0x0010u, 
500        0x0008u, 
501        0x0008u, 
502        0x0001u, 
503        w32_regex_traits_implementation<charT>::mask_unicode,
504        0x0001u, 
505        w32_regex_traits_implementation<charT>::mask_vertical, 
506        0x0104u | w32_regex_traits_implementation<charT>::mask_word, 
507        0x0104u | w32_regex_traits_implementation<charT>::mask_word, 
508        0x0080u, 
509     };
510     if(m_custom_class_names.size())
511     {
512        typedef typename std::map<std::basic_string<charT>, char_class_type>::const_iterator map_iter;
513        map_iter pos = m_custom_class_names.find(string_type(p1, p2));
514        if(pos != m_custom_class_names.end())
515           return pos->second;
516     }
517     std::size_t state_id = 1u + (std::size_t)BOOST_REGEX_DETAIL_NS::get_default_class_id(p1, p2);
518     if(state_id < sizeof(masks) / sizeof(masks[0]))
519        return masks[state_id];
520     return masks[0];
521  }
522  template <class charT>
523  std::shared_ptr<const w32_regex_traits_implementation<charT> > create_w32_regex_traits(::boost::BOOST_REGEX_DETAIL_NS::lcid_type l)
524  {
525     return boost::object_cache< ::boost::BOOST_REGEX_DETAIL_NS::lcid_type, w32_regex_traits_implementation<charT> >::get(l, 5);
526  }
527  } 
528  template <class charT>
529  class w32_regex_traits
530  {
531  public:
532     typedef charT                         char_type;
533     typedef std::size_t                   size_type;
534     typedef std::basic_string<char_type>  string_type;
535     typedef ::boost::BOOST_REGEX_DETAIL_NS::lcid_type locale_type;
536     typedef std::uint_least32_t         char_class_type;
537     struct boost_extensions_tag{};
538     w32_regex_traits()
539        : m_pimpl(BOOST_REGEX_DETAIL_NS::create_w32_regex_traits<charT>(::boost::BOOST_REGEX_DETAIL_NS::w32_get_default_locale()))
540     { }
541     static size_type length(const char_type* p)
542     {
543        return std::char_traits<charT>::length(p);
544     }
545     regex_constants::syntax_type syntax_type(charT c)const
546     {
547        return m_pimpl->syntax_type(c);
548     }
549     regex_constants::escape_syntax_type escape_syntax_type(charT c) const
550     {
551        return m_pimpl->escape_syntax_type(c);
552     }
553     charT translate(charT c) const
554     {
555        return c;
556     }
557     charT translate_nocase(charT c) const
558     {
559        return this->m_pimpl->tolower(c);
560     }
561     charT translate(charT c, bool icase) const
562     {
563        return icase ? this->m_pimpl->tolower(c) : c;
564     }
565     charT tolower(charT c) const
566     {
567        return this->m_pimpl->tolower(c);
568     }
569     charT toupper(charT c) const
570     {
571        return ::boost::BOOST_REGEX_DETAIL_NS::w32_toupper(c, this->m_pimpl->m_locale);
572     }
573     string_type transform(const charT* p1, const charT* p2) const
574     {
575        return ::boost::BOOST_REGEX_DETAIL_NS::w32_transform(this->m_pimpl->m_locale, p1, p2);
576     }
577     string_type transform_primary(const charT* p1, const charT* p2) const
578     {
579        return m_pimpl->transform_primary(p1, p2);
580     }
581     char_class_type lookup_classname(const charT* p1, const charT* p2) const
582     {
583        return m_pimpl->lookup_classname(p1, p2);
584     }
585     string_type lookup_collatename(const charT* p1, const charT* p2) const
586     {
587        return m_pimpl->lookup_collatename(p1, p2);
588     }
589     bool isctype(charT c, char_class_type f) const
590     {
591        if((f & BOOST_REGEX_DETAIL_NS::w32_regex_traits_implementation<charT>::mask_base) 
592           && (this->m_pimpl->isctype(f & BOOST_REGEX_DETAIL_NS::w32_regex_traits_implementation<charT>::mask_base, c)))
593           return true;
594        else if((f & BOOST_REGEX_DETAIL_NS::w32_regex_traits_implementation<charT>::mask_unicode) && BOOST_REGEX_DETAIL_NS::is_extended(c))
595           return true;
596        else if((f & BOOST_REGEX_DETAIL_NS::w32_regex_traits_implementation<charT>::mask_word) && (c == '_'))
597           return true;
598        else if((f & BOOST_REGEX_DETAIL_NS::w32_regex_traits_implementation<charT>::mask_vertical)
599           && (::boost::BOOST_REGEX_DETAIL_NS::is_separator(c) || (c == '\v')))
600           return true;
601        else if((f & BOOST_REGEX_DETAIL_NS::w32_regex_traits_implementation<charT>::mask_horizontal) 
602           && this->isctype(c, 0x0008u) && !this->isctype(c, BOOST_REGEX_DETAIL_NS::w32_regex_traits_implementation<charT>::mask_vertical))
603           return true;
604        return false;
605     }
606     std::intmax_t toi(const charT*& p1, const charT* p2, int radix)const
607     {
608        return ::boost::BOOST_REGEX_DETAIL_NS::global_toi(p1, p2, radix, *this);
609     }
610     int value(charT c, int radix)const
611     {
612        int result = (int)::boost::BOOST_REGEX_DETAIL_NS::global_value(c);
613        return result < radix ? result : -1;
614     }
615     locale_type imbue(locale_type l)
616     {
617        ::boost::BOOST_REGEX_DETAIL_NS::lcid_type result(getloc());
618        m_pimpl = BOOST_REGEX_DETAIL_NS::create_w32_regex_traits<charT>(l);
619        return result;
620     }
621     locale_type getloc()const
622     {
623        return m_pimpl->m_locale;
624     }
625     std::string error_string(regex_constants::error_type n) const
626     {
627        return m_pimpl->error_string(n);
628     }
629     static std::string catalog_name(const std::string& name);
630     static std::string get_catalog_name();
631  private:
632     std::shared_ptr<const BOOST_REGEX_DETAIL_NS::w32_regex_traits_implementation<charT> > m_pimpl;
633     static std::string& get_catalog_name_inst();
634  #ifdef BOOST_HAS_THREADS
635     static std::mutex& get_mutex_inst();
636  #endif
637  };
638  template <class charT>
639  std::string w32_regex_traits<charT>::catalog_name(const std::string& name)
640  {
641  #ifdef BOOST_HAS_THREADS
642     std::lock_guard<std::mutex> lk(get_mutex_inst());
643  #endif
644     std::string result(get_catalog_name_inst());
645     get_catalog_name_inst() = name;
646     return result;
647  }
648  template <class charT>
649  std::string& w32_regex_traits<charT>::get_catalog_name_inst()
650  {
651     static std::string s_name;
652     return s_name;
653  }
654  template <class charT>
655  std::string w32_regex_traits<charT>::get_catalog_name()
656  {
657  #ifdef BOOST_HAS_THREADS
658     std::lock_guard<std::mutex> lk(get_mutex_inst());
659  #endif
660     std::string result(get_catalog_name_inst());
661     return result;
662  }
663  #ifdef BOOST_HAS_THREADS
664  template <class charT>
665  std::mutex& w32_regex_traits<charT>::get_mutex_inst()
666  {
667     static std::mutex s_mutex;
668     return s_mutex;
669  }
670  #endif
671  namespace BOOST_REGEX_DETAIL_NS {
672  #ifdef BOOST_NO_ANSI_APIS
673     inline unsigned int get_code_page_for_locale_id(lcid_type idx)
674     {
675        wchar_t code_page_string[7];
676        if (boost::BOOST_REGEX_DETAIL_NS::GetLocaleInfoW(idx, locale_idefaultansicodepage, code_page_string, 7) == 0)
677           return 0;
678        return static_cast<unsigned int>(_wtol(code_page_string));
679  }
680  #endif
681     template <class U>
682     inline void w32_regex_traits_char_layer<char>::init()
683     {
684        std::memset(m_char_map, 0, sizeof(m_char_map));
685        cat_type cat;
686        std::string cat_name(w32_regex_traits<char>::get_catalog_name());
687        if (cat_name.size())
688        {
689           cat = ::boost::BOOST_REGEX_DETAIL_NS::w32_cat_open(cat_name);
690           if (!cat)
691           {
692              std::string m("Unable to open message catalog: ");
693              std::runtime_error err(m + cat_name);
694              ::boost::BOOST_REGEX_DETAIL_NS::raise_runtime_error(err);
695           }
696        }
697        if (cat)
698        {
699           for (regex_constants::syntax_type i = 1; i < regex_constants::syntax_max; ++i)
700           {
701              string_type mss = ::boost::BOOST_REGEX_DETAIL_NS::w32_cat_get(cat, this->m_locale, i, get_default_syntax(i));
702              for (string_type::size_type j = 0; j < mss.size(); ++j)
703              {
704                 m_char_map[static_cast<unsigned char>(mss[j])] = i;
705              }
706           }
707        }
708        else
709        {
710           for (regex_constants::syntax_type i = 1; i < regex_constants::syntax_max; ++i)
711           {
712              const char* ptr = get_default_syntax(i);
713              while (ptr && *ptr)
714              {
715                 m_char_map[static_cast<unsigned char>(*ptr)] = i;
716                 ++ptr;
717              }
718           }
719        }
720        unsigned char i = 'A';
721        do
722        {
723           if (m_char_map[i] == 0)
724           {
725              if (::boost::BOOST_REGEX_DETAIL_NS::w32_is(this->m_locale, 0x0002u, (char)i))
726                 m_char_map[i] = regex_constants::escape_type_class;
727              else if (::boost::BOOST_REGEX_DETAIL_NS::w32_is(this->m_locale, 0x0001u, (char)i))
728                 m_char_map[i] = regex_constants::escape_type_not_class;
729           }
730        } while (0xFF != i++);
731        char char_map[1 << CHAR_BIT];
732        for (int ii = 0; ii < (1 << CHAR_BIT); ++ii)
733           char_map[ii] = static_cast<char>(ii);
734  #ifndef BOOST_NO_ANSI_APIS
735        int r = boost::BOOST_REGEX_DETAIL_NS::LCMapStringA(this->m_locale, lcmap_lowercase, char_map, 1 << CHAR_BIT, this->m_lower_map, 1 << CHAR_BIT);
736        BOOST_REGEX_ASSERT(r != 0);
737  #else
738        unsigned int code_page = get_code_page_for_locale_id(this->m_locale);
739        BOOST_REGEX_ASSERT(code_page != 0);
740        wchar_t wide_char_map[1 << CHAR_BIT];
741        int conv_r = boost::BOOST_REGEX_DETAIL_NS::MultiByteToWideChar(code_page, 0, char_map, 1 << CHAR_BIT, wide_char_map, 1 << CHAR_BIT);
742        BOOST_REGEX_ASSERT(conv_r != 0);
743        wchar_t wide_lower_map[1 << CHAR_BIT];
744        int r = boost::BOOST_REGEX_DETAIL_NS::LCMapStringW(this->m_locale, lcmap_lowercase, wide_char_map, 1 << CHAR_BIT, wide_lower_map, 1 << CHAR_BIT);
745        BOOST_REGEX_ASSERT(r != 0);
746        conv_r = boost::BOOST_REGEX_DETAIL_NS::WideCharToMultiByte(code_page, 0, wide_lower_map, r, this->m_lower_map, 1 << CHAR_BIT, NULL, NULL);
747        BOOST_REGEX_ASSERT(conv_r != 0);
748  #endif
749        if (r < (1 << CHAR_BIT))
750        {
751           for (int jj = r; jj < (1 << CHAR_BIT); ++jj)
752              this->m_lower_map[jj] = static_cast<char>(jj);
753        }
754  #ifndef BOOST_NO_ANSI_APIS
755        r = boost::BOOST_REGEX_DETAIL_NS::GetStringTypeExA(this->m_locale, ct_ctype1, char_map, 1 << CHAR_BIT, this->m_type_map);
756  #else
757        r = boost::BOOST_REGEX_DETAIL_NS::GetStringTypeExW(this->m_locale, ct_ctype1, wide_char_map, 1 << CHAR_BIT, this->m_type_map);
758  #endif
759        BOOST_REGEX_ASSERT(0 != r);
760     }
761     inline lcid_type  w32_get_default_locale()
762     {
763        return boost::BOOST_REGEX_DETAIL_NS::GetUserDefaultLCID();
764     }
765     inline bool  w32_is_lower(char c, lcid_type idx)
766     {
767  #ifndef BOOST_NO_ANSI_APIS
768        word mask;
769        if (boost::BOOST_REGEX_DETAIL_NS::GetStringTypeExA(idx, ct_ctype1, &c, 1, &mask) && (mask & c1_lower))
770           return true;
771        return false;
772  #else
773        unsigned int code_page = get_code_page_for_locale_id(idx);
774        if (code_page == 0)
775           return false;
776        wchar_t wide_c;
777        if (boost::BOOST_REGEX_DETAIL_NS::MultiByteToWideChar(code_page, 0, &c, 1, &wide_c, 1) == 0)
778           return false;
779        word mask;
780        if (boost::BOOST_REGEX_DETAIL_NS::GetStringTypeExW(idx, ct_ctype1, &wide_c, 1, &mask) && (mask & c1_lower))
781           return true;
782        return false;
783  #endif
784     }
785     inline bool  w32_is_lower(wchar_t c, lcid_type idx)
786     {
787        word mask;
788        if (boost::BOOST_REGEX_DETAIL_NS::GetStringTypeExW(idx, ct_ctype1, &c, 1, &mask) && (mask & c1_lower))
789           return true;
790        return false;
791     }
792     inline bool  w32_is_upper(char c, lcid_type idx)
793     {
794  #ifndef BOOST_NO_ANSI_APIS
795        word mask;
796        if (boost::BOOST_REGEX_DETAIL_NS::GetStringTypeExA(idx, ct_ctype1, &c, 1, &mask) && (mask & c1_upper))
797           return true;
798        return false;
799  #else
800        unsigned int code_page = get_code_page_for_locale_id(idx);
801        if (code_page == 0)
802           return false;
803        wchar_t wide_c;
804        if (boost::BOOST_REGEX_DETAIL_NS::MultiByteToWideChar(code_page, 0, &c, 1, &wide_c, 1) == 0)
805           return false;
806        word mask;
807        if (boost::BOOST_REGEX_DETAIL_NS::GetStringTypeExW(idx, ct_ctype1, &wide_c, 1, &mask) && (mask & c1_upper))
808           return true;
809        return false;
810  #endif
811     }
812     inline bool  w32_is_upper(wchar_t c, lcid_type idx)
813     {
814        word mask;
815        if (boost::BOOST_REGEX_DETAIL_NS::GetStringTypeExW(idx, ct_ctype1, &c, 1, &mask) && (mask & c1_upper))
816           return true;
817        return false;
818     }
819     inline void free_module(void* mod)
820     {
821        boost::BOOST_REGEX_DETAIL_NS::FreeLibrary(static_cast<HMODULE>(mod));
822     }
823     inline cat_type  w32_cat_open(const std::string& name)
824     {
825  #ifndef BOOST_NO_ANSI_APIS
826        cat_type result(boost::BOOST_REGEX_DETAIL_NS::LoadLibraryA(name.c_str()), &free_module);
827        return result;
828  #else
829        wchar_t* wide_name = (wchar_t*)_alloca((name.size() + 1) * sizeof(wchar_t));
830        if (boost::BOOST_REGEX_DETAIL_NS::MultiByteToWideChar(cp_acp, 0, name.c_str(), (int)name.size(), wide_name, (int)(name.size() + 1)) == 0)
831           return cat_type();
832        cat_type result(boost::BOOST_REGEX_DETAIL_NS::LoadLibraryW(wide_name), &free_module);
833        return result;
834  #endif
835     }
836     inline std::string  w32_cat_get(const cat_type& cat, lcid_type, int i, const std::string& def)
837     {
838  #ifndef BOOST_NO_ANSI_APIS
839        char buf[256];
840        if (0 == boost::BOOST_REGEX_DETAIL_NS::LoadStringA(
841           static_cast<HMODULE>(cat.get()),
842           i,
843           buf,
844           256
845        ))
846        {
847           return def;
848        }
849  #else
850        wchar_t wbuf[256];
851        int r = boost::BOOST_REGEX_DETAIL_NS::LoadStringW(
852           static_cast<HMODULE>(cat.get()),
853           i,
854           wbuf,
855           256
856        );
857        if (r == 0)
858           return def;
859        int buf_size = 1 + boost::BOOST_REGEX_DETAIL_NS::WideCharToMultiByte(cp_acp, 0, wbuf, r, NULL, 0, NULL, NULL);
860        char* buf = (char*)_alloca(buf_size);
861        if (boost::BOOST_REGEX_DETAIL_NS::WideCharToMultiByte(cp_acp, 0, wbuf, r, buf, buf_size, NULL, NULL) == 0)
862           return def; 
863  #endif
864        return std::string(buf);
865     }
866  #ifndef BOOST_NO_WREGEX
867     inline std::wstring  w32_cat_get(const cat_type& cat, lcid_type, int i, const std::wstring& def)
868     {
869        wchar_t buf[256];
870        if (0 == boost::BOOST_REGEX_DETAIL_NS::LoadStringW(static_cast<HMODULE>(cat.get()), i, buf, 256))
871        {
872           return def;
873        }
874        return std::wstring(buf);
875     }
876  #endif
877     inline std::string  w32_transform(lcid_type idx, const char* p1, const char* p2)
878     {
879  #ifndef BOOST_NO_ANSI_APIS
880        int bytes = boost::BOOST_REGEX_DETAIL_NS::LCMapStringA(
881           idx,       
882           lcmap_sortkey,  
883           p1,  
884           static_cast<int>(p2 - p1),        
885           0,  
886           0        
887        );
888        if (!bytes)
889           return std::string(p1, p2);
890        std::string result(++bytes, '\0');
891        bytes = boost::BOOST_REGEX_DETAIL_NS::LCMapStringA(
892           idx,       
893           lcmap_sortkey,  
894           p1,  
895           static_cast<int>(p2 - p1),        
896           &*result.begin(),  
897           bytes        
898        );
899  #else
900        unsigned int code_page = get_code_page_for_locale_id(idx);
901        if (code_page == 0)
902           return std::string(p1, p2);
903        int src_len = static_cast<int>(p2 - p1);
904        wchar_t* wide_p1 = (wchar_t*)_alloca((src_len + 1) * 2);
905        if (boost::BOOST_REGEX_DETAIL_NS::MultiByteToWideChar(code_page, 0, p1, src_len, wide_p1, src_len + 1) == 0)
906           return std::string(p1, p2);
907        int bytes = boost::BOOST_REGEX_DETAIL_NS::LCMapStringW(
908           idx,       
909           lcmap_sortkey,  
910           wide_p1,  
911           src_len,        
912           0,  
913           0        
914        );
915        if (!bytes)
916           return std::string(p1, p2);
917        std::string result(++bytes, '\0');
918        bytes = boost::BOOST_REGEX_DETAIL_NS::LCMapStringW(
919           idx,       
920           lcmap_sortkey,  
921           wide_p1,  
922           src_len,        
923           (wchar_t*) & *result.begin(),  
924           bytes        
925        );
926  #endif
927        if (bytes > static_cast<int>(result.size()))
928           return std::string(p1, p2);
929        while (result.size() && result[result.size() - 1] == '\0')
930        {
931           result.erase(result.size() - 1);
932        }
933        return result;
934     }
935  #ifndef BOOST_NO_WREGEX
936     inline std::wstring  w32_transform(lcid_type idx, const wchar_t* p1, const wchar_t* p2)
937     {
938        int bytes = boost::BOOST_REGEX_DETAIL_NS::LCMapStringW(
939           idx,       
940           lcmap_sortkey,  
941           p1,  
942           static_cast<int>(p2 - p1),        
943           0,  
944           0        
945        );
946        if (!bytes)
947           return std::wstring(p1, p2);
948        std::string result(++bytes, '\0');
949        bytes = boost::BOOST_REGEX_DETAIL_NS::LCMapStringW(
950           idx,       
951           lcmap_sortkey,  
952           p1,  
953           static_cast<int>(p2 - p1),        
954           reinterpret_cast<wchar_t*>(&*result.begin()),  
955           bytes        
956        );
957        if (bytes > static_cast<int>(result.size()))
958           return std::wstring(p1, p2);
959        while (result.size() && result[result.size() - 1] == L'\0')
960        {
961           result.erase(result.size() - 1);
962        }
963        std::wstring r2;
964        for (std::string::size_type i = 0; i < result.size(); ++i)
965           r2.append(1, static_cast<wchar_t>(static_cast<unsigned char>(result[i])));
966        return r2;
967     }
968  #endif
969     inline char  w32_tolower(char c, lcid_type idx)
970     {
971        char result[2];
972  #ifndef BOOST_NO_ANSI_APIS
973        int b = boost::BOOST_REGEX_DETAIL_NS::LCMapStringA(
974           idx,       
975           lcmap_lowercase,  
976           &c,  
977           1,        
978           result,  
979           1);        
980        if (b == 0)
981           return c;
982  #else
983        unsigned int code_page = get_code_page_for_locale_id(idx);
984        if (code_page == 0)
985           return c;
986        wchar_t wide_c;
987        if (boost::BOOST_REGEX_DETAIL_NS::MultiByteToWideChar(code_page, 0, &c, 1, &wide_c, 1) == 0)
988           return c;
989        wchar_t  wide_result;
990        int b = boost::BOOST_REGEX_DETAIL_NS::LCMapStringW(
991           idx,       
992           lcmap_lowercase,  
993           &wide_c,  
994           1,        
995           &wide_result,  
996           1);        
997        if (b == 0)
998           return c;
999        if (boost::BOOST_REGEX_DETAIL_NS::WideCharToMultiByte(code_page, 0, &wide_result, 1, result, 2, NULL, NULL) == 0)
1000           return c;  
1001  #endif
1002        return result[0];
1003     }
1004  #ifndef BOOST_NO_WREGEX
1005     inline wchar_t  w32_tolower(wchar_t c, lcid_type idx)
1006     {
1007        wchar_t result[2];
1008        int b = boost::BOOST_REGEX_DETAIL_NS::LCMapStringW(
1009           idx,       
1010           lcmap_lowercase,  
1011           &c,  
1012           1,        
1013           result,  
1014           1);        
1015        if (b == 0)
1016           return c;
1017        return result[0];
1018     }
1019  #endif
1020     inline char  w32_toupper(char c, lcid_type idx)
1021     {
1022        char result[2];
1023  #ifndef BOOST_NO_ANSI_APIS
1024        int b = boost::BOOST_REGEX_DETAIL_NS::LCMapStringA(
1025           idx,       
1026           lcmap_uppercase,  
1027           &c,  
1028           1,        
1029           result,  
1030           1);        
1031        if (b == 0)
1032           return c;
1033  #else
1034        unsigned int code_page = get_code_page_for_locale_id(idx);
1035        if (code_page == 0)
1036           return c;
1037        wchar_t wide_c;
1038        if (boost::BOOST_REGEX_DETAIL_NS::MultiByteToWideChar(code_page, 0, &c, 1, &wide_c, 1) == 0)
1039           return c;
1040        wchar_t wide_result;
1041        int b = boost::BOOST_REGEX_DETAIL_NS::LCMapStringW(
1042           idx,       
1043           lcmap_uppercase,  
1044           &wide_c,  
1045           1,        
1046           &wide_result,  
1047           1);        
1048        if (b == 0)
1049           return c;
1050        if (boost::BOOST_REGEX_DETAIL_NS::WideCharToMultiByte(code_page, 0, &wide_result, 1, result, 2, NULL, NULL) == 0)
1051           return c;  
1052  #endif
1053        return result[0];
1054     }
1055  #ifndef BOOST_NO_WREGEX
1056     inline wchar_t  w32_toupper(wchar_t c, lcid_type idx)
1057     {
1058        wchar_t result[2];
1059        int b = boost::BOOST_REGEX_DETAIL_NS::LCMapStringW(
1060           idx,       
1061           lcmap_uppercase,  
1062           &c,  
1063           1,        
1064           result,  
1065           1);        
1066        if (b == 0)
1067           return c;
1068        return result[0];
1069     }
1070  #endif
1071     inline bool  w32_is(lcid_type idx, std::uint32_t m, char c)
1072     {
1073        word mask;
1074  #ifndef BOOST_NO_ANSI_APIS
1075        if (boost::BOOST_REGEX_DETAIL_NS::GetStringTypeExA(idx, ct_ctype1, &c, 1, &mask) && (mask & m & w32_regex_traits_implementation<char>::mask_base))
1076           return true;
1077  #else
1078        unsigned int code_page = get_code_page_for_locale_id(idx);
1079        if (code_page == 0)
1080           return false;
1081        wchar_t wide_c;
1082        if (boost::BOOST_REGEX_DETAIL_NS::MultiByteToWideChar(code_page, 0, &c, 1, &wide_c, 1) == 0)
1083           return false;
1084        if (boost::BOOST_REGEX_DETAIL_NS::GetStringTypeExW(idx, ct_ctype1, &wide_c, 1, &mask) && (mask & m & w32_regex_traits_implementation<char>::mask_base))
1085           return true;
1086  #endif
1087        if ((m & w32_regex_traits_implementation<char>::mask_word) && (c == '_'))
1088           return true;
1089        return false;
1090     }
1091  #ifndef BOOST_NO_WREGEX
1092     inline bool  w32_is(lcid_type idx, std::uint32_t m, wchar_t c)
1093     {
1094        word mask;
1095        if (boost::BOOST_REGEX_DETAIL_NS::GetStringTypeExW(idx, ct_ctype1, &c, 1, &mask) && (mask & m & w32_regex_traits_implementation<wchar_t>::mask_base))
1096           return true;
1097        if ((m & w32_regex_traits_implementation<wchar_t>::mask_word) && (c == '_'))
1098           return true;
1099        if ((m & w32_regex_traits_implementation<wchar_t>::mask_unicode) && (c > 0xff))
1100           return true;
1101        return false;
1102     }
1103  #endif
1104  } 
1105  } 
1106  #ifdef BOOST_REGEX_MSVC
1107  #pragma warning(pop)
1108  #endif
1109  #endif 
1110  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-w32_regex_traits.hpp</h3>
            <pre><code>1  #ifndef BOOST_W32_REGEX_TRAITS_HPP_INCLUDED
2  #define BOOST_W32_REGEX_TRAITS_HPP_INCLUDED
3  #ifndef BOOST_REGEX_NO_WIN32_LOCALE
4  #include <boost/regex/pattern_except.hpp>
5  #include <boost/regex/v5/regex_traits_defaults.hpp>
6  #ifdef BOOST_HAS_THREADS
7  #include <mutex>
8  #endif
9  #include <boost/regex/v5/primary_transform.hpp>
10  #include <boost/regex/v5/object_cache.hpp>
11  #if defined(_MSC_VER) && !defined(_WIN32_WCE) && !defined(UNDER_CE)
12  #pragma comment(lib, "user32.lib")
13  #endif
14  #ifdef BOOST_REGEX_MSVC
15  #pragma warning(push)
16  #pragma warning(disable:4786)
17  #if BOOST_REGEX_MSVC < 1910
18  #pragma warning(disable:4800)
19  #endif
20  #endif
21  #ifndef BASETYPES
22  #ifndef NO_STRICT
23  #ifndef STRICT
24  #define STRICT 1
25  #endif
26  #endif
27  #if defined(STRICT)
28  #define BOOST_RE_DETAIL_DECLARE_HANDLE(x) struct x##__; typedef struct x##__ *x
29  #else
30  #define BOOST_RE_DETAIL_DECLARE_HANDLE(x) typedef void* x
31  #endif
32  extern "C" {
33     BOOST_RE_DETAIL_DECLARE_HANDLE(HINSTANCE);
34     typedef HINSTANCE HMODULE;
35  }
36  #endif
37  namespace boost{ 
38  template <class charT>
39  class w32_regex_traits;
40  namespace BOOST_REGEX_DETAIL_NS{
41  typedef unsigned long lcid_type;        
42  typedef std::shared_ptr<void> cat_type; 
43  lcid_type  w32_get_default_locale();
44  bool  w32_is_lower(char, lcid_type);
45  #ifndef BOOST_NO_WREGEX
46  bool  w32_is_lower(wchar_t, lcid_type);
47  #endif
48  bool  w32_is_upper(char, lcid_type);
49  #ifndef BOOST_NO_WREGEX
50  bool  w32_is_upper(wchar_t, lcid_type);
51  #endif
52  cat_type  w32_cat_open(const std::string& name);
53  std::string  w32_cat_get(const cat_type& cat, lcid_type state_id, int i, const std::string& def);
54  #ifndef BOOST_NO_WREGEX
55  std::wstring  w32_cat_get(const cat_type& cat, lcid_type state_id, int i, const std::wstring& def);
56  #endif
57  std::string  w32_transform(lcid_type state_id, const char* p1, const char* p2);
58  #ifndef BOOST_NO_WREGEX
59  std::wstring  w32_transform(lcid_type state_id, const wchar_t* p1, const wchar_t* p2);
60  #endif
61  char  w32_tolower(char c, lcid_type);
62  #ifndef BOOST_NO_WREGEX
63  wchar_t  w32_tolower(wchar_t c, lcid_type);
64  #endif
65  char  w32_toupper(char c, lcid_type);
66  #ifndef BOOST_NO_WREGEX
67  wchar_t  w32_toupper(wchar_t c, lcid_type);
68  #endif
69  bool  w32_is(lcid_type, std::uint32_t mask, char c);
70  #ifndef BOOST_NO_WREGEX
71  bool  w32_is(lcid_type, std::uint32_t mask, wchar_t c);
72  #endif
73  #ifndef BASETYPES
74  #if !defined(__LP64__)
75  using dword = unsigned long;
76  #else
77  using DWORD = unsigned int;
78  #endif
79  using word = unsigned short;
80  using lctype = dword;
81  static constexpr dword ct_ctype1 = 0x00000001;
82  static constexpr dword c1_upper = 0x0001;      
83  static constexpr dword c1_lower = 0x0002;      
84  static constexpr dword c1_digit = 0x0004;      
85  static constexpr dword c1_space = 0x0008;      
86  static constexpr dword c1_punct = 0x0010;      
87  static constexpr dword c1_cntrl = 0x0020;      
88  static constexpr dword c1_blank = 0x0040;      
89  static constexpr dword c1_xdigit = 0x0080;      
90  static constexpr dword c1_alpha = 0x0100;      
91  static constexpr dword c1_defined = 0x0200;      
92  static constexpr unsigned int cp_acp = 0;
93  static constexpr dword lcmap_lowercase = 0x00000100;
94  static constexpr dword lcmap_uppercase = 0x00000200;
95  static constexpr dword lcmap_sortkey = 0x00000400;  
96  static constexpr lctype locale_idefaultansicodepage = 0x00001004;
97  # ifdef UNDER_CE
98  #  ifndef WINAPI
99  #   ifndef _WIN32_WCE_EMULATION
100  #    define BOOST_RE_STDCALL __cdecl     
101  #   else
102  #    define BOOST_RE_STDCALL __stdcall
103  #   endif
104  #  endif
105  # else
106  #  if defined(_M_IX86) || defined(__i386__)
107  #   define BOOST_RE_STDCALL __stdcall
108  #  else
109  #   define BOOST_RE_STDCALL
110  #  endif
111  # endif
112  #if defined (WIN32_PLATFORM_PSPC)
113  #define BOOST_RE_IMPORT __declspec( dllimport )
114  #elif defined (_WIN32_WCE)
115  #define BOOST_RE_IMPORT
116  #else
117  #define BOOST_RE_IMPORT __declspec( dllimport )
118  #endif
119  extern "C" {
120     BOOST_RE_IMPORT int BOOST_RE_STDCALL FreeLibrary(HMODULE hLibModule);
121     BOOST_RE_IMPORT int BOOST_RE_STDCALL LCMapStringA(lcid_type Locale, dword dwMapFlags, const char* lpSrcStr, int cchSrc, char* lpDestStr, int cchDest);
122     BOOST_RE_IMPORT int BOOST_RE_STDCALL LCMapStringW(lcid_type Locale, dword dwMapFlags, const wchar_t* lpSrcStr, int cchSrc, wchar_t* lpDestStr, int cchDest);
123     BOOST_RE_IMPORT int BOOST_RE_STDCALL MultiByteToWideChar(unsigned int CodePage, dword dwFlags, const char* lpMultiByteStr, int cbMultiByte, wchar_t* lpWideCharStr, int cchWideChar);
124     BOOST_RE_IMPORT int BOOST_RE_STDCALL LCMapStringW(lcid_type Locale, dword dwMapFlags, const wchar_t* lpSrcStr, int cchSrc, wchar_t* lpDestStr, int cchDest);
125     BOOST_RE_IMPORT int BOOST_RE_STDCALL WideCharToMultiByte(unsigned int CodePage, dword dwFlags, const wchar_t* lpWideCharStr, int cchWideChar, char* lpMultiByteStr, int cbMultiByte, const char* lpDefaultChar, int* lpUsedDefaultChar);
126     BOOST_RE_IMPORT int BOOST_RE_STDCALL GetStringTypeExA(lcid_type Locale, dword dwInfoType, const char* lpSrcStr, int cchSrc, word* lpCharType);
127     BOOST_RE_IMPORT int BOOST_RE_STDCALL GetStringTypeExW(lcid_type Locale, dword dwInfoType, const wchar_t* lpSrcStr, int cchSrc, word* lpCharType);
128     BOOST_RE_IMPORT lcid_type BOOST_RE_STDCALL GetUserDefaultLCID();
129     BOOST_RE_IMPORT int BOOST_RE_STDCALL GetStringTypeExA(lcid_type Locale, dword dwInfoType, const char* lpSrcStr, int cchSrc, word* lpCharType);
130     BOOST_RE_IMPORT int BOOST_RE_STDCALL GetStringTypeExW(lcid_type Locale, dword dwInfoType, const wchar_t* lpSrcStr, int cchSrc, word* lpCharType);
131     BOOST_RE_IMPORT HMODULE BOOST_RE_STDCALL LoadLibraryA(const char* lpLibFileName);
132     BOOST_RE_IMPORT HMODULE BOOST_RE_STDCALL LoadLibraryW(const wchar_t* lpLibFileName);
133     BOOST_RE_IMPORT int BOOST_RE_STDCALL LoadStringW(HINSTANCE hInstance, unsigned int uID, wchar_t* lpBuffer, int cchBufferMax);
134     BOOST_RE_IMPORT int BOOST_RE_STDCALL LoadStringA(HINSTANCE hInstance, unsigned int uID, char* lpBuffer, int cchBufferMax);
135     BOOST_RE_IMPORT int BOOST_RE_STDCALL GetLocaleInfoW(lcid_type Locale, lctype LCType, wchar_t* lpLCData, int cchData);
136  }
137  #else
138  using dword = DWORD;
139  using word = WORD;
140  using lctype = LCTYPE;
141  static constexpr dword ct_ctype1 = 0x00000001;
142  static constexpr dword c1_upper = 0x0001;      
143  static constexpr dword c1_lower = 0x0002;      
144  static constexpr dword c1_digit = 0x0004;      
145  static constexpr dword c1_space = 0x0008;      
146  static constexpr dword c1_punct = 0x0010;      
147  static constexpr dword c1_cntrl = 0x0020;      
148  static constexpr dword c1_blank = 0x0040;      
149  static constexpr dword c1_xdigit = 0x0080;      
150  static constexpr dword c1_alpha = 0x0100;      
151  static constexpr dword c1_defined = 0x0200;      
152  static constexpr unsigned int cp_acp = 0;
153  static constexpr dword lcmap_lowercase = 0x00000100;
154  static constexpr dword lcmap_uppercase = 0x00000200;
155  static constexpr dword lcmap_sortkey = 0x00000400;  
156  static constexpr lctype locale_idefaultansicodepage = 0x00001004;
157  using ::FreeLibrary;
158  using ::LCMapStringA;
159  using ::LCMapStringW;
160  using ::MultiByteToWideChar;
161  using ::LCMapStringW;
162  using ::WideCharToMultiByte;
163  using ::GetStringTypeExA;
164  using ::GetStringTypeExW;
165  using ::GetUserDefaultLCID;
166  using ::GetStringTypeExA;
167  using ::GetStringTypeExW;
168  using ::LoadLibraryA;
169  using ::LoadLibraryW;
170  using ::LoadStringW;
171  using ::LoadStringA;
172  using ::GetLocaleInfoW;
173  #endif
174  template <class charT>
175  struct w32_regex_traits_base
176  {
177     w32_regex_traits_base(lcid_type l)
178     { imbue(l); }
179     lcid_type imbue(lcid_type l);
180     lcid_type m_locale;
181  };
182  template <class charT>
183  inline lcid_type w32_regex_traits_base<charT>::imbue(lcid_type l)
184  {
185     lcid_type result(m_locale);
186     m_locale = l;
187     return result;
188  }
189  template <class charT>
190  class w32_regex_traits_char_layer : public w32_regex_traits_base<charT>
191  {
192     typedef std::basic_string<charT> string_type;
193     typedef std::map<charT, regex_constants::syntax_type> map_type;
194     typedef typename map_type::const_iterator map_iterator_type;
195  public:
196     w32_regex_traits_char_layer(const lcid_type l);
197     regex_constants::syntax_type syntax_type(charT c)const
198     {
199        map_iterator_type i = m_char_map.find(c);
200        return ((i == m_char_map.end()) ? 0 : i->second);
201     }
202     regex_constants::escape_syntax_type escape_syntax_type(charT c) const
203     {
204        map_iterator_type i = m_char_map.find(c);
205        if(i == m_char_map.end())
206        {
207           if(::boost::BOOST_REGEX_DETAIL_NS::w32_is_lower(c, this->m_locale)) return regex_constants::escape_type_class;
208           if(::boost::BOOST_REGEX_DETAIL_NS::w32_is_upper(c, this->m_locale)) return regex_constants::escape_type_not_class;
209           return 0;
210        }
211        return i->second;
212     }
213     charT tolower(charT c)const
214     {
215        return ::boost::BOOST_REGEX_DETAIL_NS::w32_tolower(c, this->m_locale);
216     }
217     bool isctype(std::uint32_t mask, charT c)const
218     {
219        return ::boost::BOOST_REGEX_DETAIL_NS::w32_is(this->m_locale, mask, c);
220     }
221  private:
222     string_type get_default_message(regex_constants::syntax_type);
223     map_type m_char_map;
224  };
225  template <class charT>
226  w32_regex_traits_char_layer<charT>::w32_regex_traits_char_layer(::boost::BOOST_REGEX_DETAIL_NS::lcid_type l) 
227     : w32_regex_traits_base<charT>(l)
228  {
229     cat_type cat;
230     std::string cat_name(w32_regex_traits<charT>::get_catalog_name());
231     if(cat_name.size())
232     {
233        cat = ::boost::BOOST_REGEX_DETAIL_NS::w32_cat_open(cat_name);
234        if(!cat)
235        {
236           std::string m("Unable to open message catalog: ");
237           std::runtime_error err(m + cat_name);
238           boost::BOOST_REGEX_DETAIL_NS::raise_runtime_error(err);
239        }
240     }
241     if(cat)
242     {
243        for(regex_constants::syntax_type i = 1; i < regex_constants::syntax_max; ++i)
244        {
245           string_type mss = ::boost::BOOST_REGEX_DETAIL_NS::w32_cat_get(cat, this->m_locale, i, get_default_message(i));
246           for(typename string_type::size_type j = 0; j < mss.size(); ++j)
247           {
248              this->m_char_map[mss[j]] = i;
249           }
250        }
251     }
252     else
253     {
254        for(regex_constants::syntax_type i = 1; i < regex_constants::syntax_max; ++i)
255        {
256           const char* ptr = get_default_syntax(i);
257           while(ptr && *ptr)
258           {
259              this->m_char_map[static_cast<charT>(*ptr)] = i;
260              ++ptr;
261           }
262        }
263     }
264  }
265  template <class charT>
266  typename w32_regex_traits_char_layer<charT>::string_type 
267     w32_regex_traits_char_layer<charT>::get_default_message(regex_constants::syntax_type i)
268  {
269     const char* ptr = get_default_syntax(i);
270     string_type result;
271     while(ptr && *ptr)
272     {
273        result.append(1, static_cast<charT>(*ptr));
274        ++ptr;
275     }
276     return result;
277  }
278  template <>
279  class w32_regex_traits_char_layer<char> : public w32_regex_traits_base<char>
280  {
281     typedef std::string string_type;
282  public:
283     w32_regex_traits_char_layer(::boost::BOOST_REGEX_DETAIL_NS::lcid_type l)
284     : w32_regex_traits_base<char>(l)
285     {
286        init<char>();
287     }
288     regex_constants::syntax_type syntax_type(char c)const
289     {
290        return m_char_map[static_cast<unsigned char>(c)];
291     }
292     regex_constants::escape_syntax_type escape_syntax_type(char c) const
293     {
294        return m_char_map[static_cast<unsigned char>(c)];
295     }
296     char tolower(char c)const
297     {
298        return m_lower_map[static_cast<unsigned char>(c)];
299     }
300     bool isctype(std::uint32_t mask, char c)const
301     {
302        return m_type_map[static_cast<unsigned char>(c)] & mask;
303     }
304  private:
305     regex_constants::syntax_type m_char_map[1u << CHAR_BIT];
306     char m_lower_map[1u << CHAR_BIT];
307     std::uint16_t m_type_map[1u << CHAR_BIT];
308     template <class U>
309     void init();
310  };
311  template <class charT>
312  class w32_regex_traits_implementation : public w32_regex_traits_char_layer<charT>
313  {
314  public:
315     typedef typename w32_regex_traits<charT>::char_class_type char_class_type;
316     static const char_class_type mask_word = 0x0400; 
317     static const char_class_type mask_unicode = 0x0800; 
318     static const char_class_type mask_horizontal = 0x1000; 
319     static const char_class_type mask_vertical = 0x2000; 
320     static const char_class_type mask_base = 0x3ff;  
321     typedef std::basic_string<charT> string_type;
322     typedef charT char_type;
323     w32_regex_traits_implementation(::boost::BOOST_REGEX_DETAIL_NS::lcid_type l);
324     std::string error_string(regex_constants::error_type n) const
325     {
326        if(!m_error_strings.empty())
327        {
328           std::map<int, std::string>::const_iterator p = m_error_strings.find(n);
329           return (p == m_error_strings.end()) ? std::string(get_default_error_string(n)) : p->second;
330        }
331        return get_default_error_string(n);
332     }
333     char_class_type lookup_classname(const charT* p1, const charT* p2) const
334     {
335        char_class_type result = lookup_classname_imp(p1, p2);
336        if(result == 0)
337        {
338           typedef typename string_type::size_type size_type;
339           string_type temp(p1, p2);
340           for(size_type i = 0; i < temp.size(); ++i)
341              temp[i] = this->tolower(temp[i]);
342           result = lookup_classname_imp(&*temp.begin(), &*temp.begin() + temp.size());
343        }
344        return result;
345     }
346     string_type lookup_collatename(const charT* p1, const charT* p2) const;
347     string_type transform_primary(const charT* p1, const charT* p2) const;
348     string_type transform(const charT* p1, const charT* p2) const
349     {
350        return ::boost::BOOST_REGEX_DETAIL_NS::w32_transform(this->m_locale, p1, p2);
351     }
352  private:
353     std::map<int, std::string>     m_error_strings;   
354     std::map<string_type, char_class_type>  m_custom_class_names; 
355     std::map<string_type, string_type>      m_custom_collate_names; 
356     unsigned                       m_collate_type;    
357     charT                          m_collate_delim;   
358     char_class_type lookup_classname_imp(const charT* p1, const charT* p2) const;
359  };
360  template <class charT>
361  typename w32_regex_traits_implementation<charT>::string_type 
362     w32_regex_traits_implementation<charT>::transform_primary(const charT* p1, const charT* p2) const
363  {
364     string_type result;
365     switch(m_collate_type)
366     {
367     case sort_C:
368     case sort_unknown:
369        {
370           result.assign(p1, p2);
371           typedef typename string_type::size_type size_type;
372           for(size_type i = 0; i < result.size(); ++i)
373              result[i] = this->tolower(result[i]);
374           result = this->transform(&*result.begin(), &*result.begin() + result.size());
375           break;
376        }
377     case sort_fixed:
378        {
379           result.assign(this->transform(p1, p2));
380           result.erase(this->m_collate_delim);
381           break;
382        }
383     case sort_delim:
384           result.assign(this->transform(p1, p2));
385           std::size_t i;
386           for(i = 0; i < result.size(); ++i)
387           {
388              if(result[i] == m_collate_delim)
389                 break;
390           }
391           result.erase(i);
392           break;
393     }
394     if(result.empty())
395        result = string_type(1, charT(0));
396     return result;
397  }
398  template <class charT>
399  typename w32_regex_traits_implementation<charT>::string_type 
400     w32_regex_traits_implementation<charT>::lookup_collatename(const charT* p1, const charT* p2) const
401  {
402     typedef typename std::map<string_type, string_type>::const_iterator iter_type;
403     if(m_custom_collate_names.size())
404     {
405        iter_type pos = m_custom_collate_names.find(string_type(p1, p2));
406        if(pos != m_custom_collate_names.end())
407           return pos->second;
408     }
409     std::string name(p1, p2);
410     name = lookup_default_collate_name(name);
411     if(name.size())
412        return string_type(name.begin(), name.end());
413     if(p2 - p1 == 1)
414        return string_type(1, *p1);
415     return string_type();
416  }
417  template <class charT>
418  w32_regex_traits_implementation<charT>::w32_regex_traits_implementation(::boost::BOOST_REGEX_DETAIL_NS::lcid_type l)
419  : w32_regex_traits_char_layer<charT>(l)
420  {
<span onclick='openModal()' class='match'>421     cat_type cat;
422     std::string cat_name(w32_regex_traits<charT>::get_catalog_name());
423     if(cat_name.size())
424     {
425        cat = ::boost::BOOST_REGEX_DETAIL_NS::w32_cat_open(cat_name);
426        if(!cat)
427        {
428           std::string m("Unable to open message catalog: ");
429           std::runtime_error err(m + cat_name);
430           boost::BOOST_REGEX_DETAIL_NS::raise_runtime_error(err);
431        }
432     }
433     if(cat)
434     {
435        for(boost::regex_constants::error_type i = static_cast<boost::regex_constants::error_type>(0); 
</span>436           i <= boost::regex_constants::error_unknown; 
437           i = static_cast<boost::regex_constants::error_type>(i + 1))
438        {
439           const char* p = get_default_error_string(i);
440           string_type default_message;
441           while(*p)
442           {
443              default_message.append(1, static_cast<charT>(*p));
444              ++p;
445           }
446           string_type s = ::boost::BOOST_REGEX_DETAIL_NS::w32_cat_get(cat, this->m_locale, i+200, default_message);
447           std::string result;
448           for(std::string::size_type j = 0; j < s.size(); ++j)
449           {
450              result.append(1, static_cast<char>(s[j]));
451           }
452           m_error_strings[i] = result;
453        }
454        static const char_class_type masks[14] = 
455        {
456           0x0104u, 
457           0x0100u, 
458           0x0020u, 
459           0x0004u, 
460           (~(0x0020u|0x0008u) & 0x01ffu) | 0x0400u, 
461           0x0002u, 
462           (~0x0020u & 0x01ffu) | 0x0400, 
463           0x0010u, 
464           0x0008u, 
465           0x0001u, 
466           0x0080u, 
467           0x0040u, 
468           w32_regex_traits_implementation<charT>::mask_word,
469           w32_regex_traits_implementation<charT>::mask_unicode,
470        };
471        static const string_type null_string;
472        for(unsigned int j = 0; j <= 13; ++j)
473        {
474           string_type s(::boost::BOOST_REGEX_DETAIL_NS::w32_cat_get(cat, this->m_locale, j+300, null_string));
475           if(s.size())
476              this->m_custom_class_names[s] = masks[j];
477        }
478     }
479     m_collate_type = BOOST_REGEX_DETAIL_NS::find_sort_syntax(this, &m_collate_delim);
480  }
481  template <class charT>
482  typename w32_regex_traits_implementation<charT>::char_class_type 
483     w32_regex_traits_implementation<charT>::lookup_classname_imp(const charT* p1, const charT* p2) const
484  {
485     static const char_class_type masks[22] = 
486     {
487        0,
488        0x0104u, 
489        0x0100u, 
490        0x0040u, 
491        0x0020u, 
492        0x0004u, 
493        0x0004u, 
494        (~(0x0020u|0x0008u|0x0040) & 0x01ffu) | 0x0400u, 
495        w32_regex_traits_implementation<charT>::mask_horizontal, 
496        0x0002u, 
497        0x0002u, 
498        (~0x0020u & 0x01ffu) | 0x0400, 
499        0x0010u, 
500        0x0008u, 
501        0x0008u, 
502        0x0001u, 
503        w32_regex_traits_implementation<charT>::mask_unicode,
504        0x0001u, 
505        w32_regex_traits_implementation<charT>::mask_vertical, 
506        0x0104u | w32_regex_traits_implementation<charT>::mask_word, 
507        0x0104u | w32_regex_traits_implementation<charT>::mask_word, 
508        0x0080u, 
509     };
510     if(m_custom_class_names.size())
511     {
512        typedef typename std::map<std::basic_string<charT>, char_class_type>::const_iterator map_iter;
513        map_iter pos = m_custom_class_names.find(string_type(p1, p2));
514        if(pos != m_custom_class_names.end())
515           return pos->second;
516     }
517     std::size_t state_id = 1u + (std::size_t)BOOST_REGEX_DETAIL_NS::get_default_class_id(p1, p2);
518     if(state_id < sizeof(masks) / sizeof(masks[0]))
519        return masks[state_id];
520     return masks[0];
521  }
522  template <class charT>
523  std::shared_ptr<const w32_regex_traits_implementation<charT> > create_w32_regex_traits(::boost::BOOST_REGEX_DETAIL_NS::lcid_type l)
524  {
525     return boost::object_cache< ::boost::BOOST_REGEX_DETAIL_NS::lcid_type, w32_regex_traits_implementation<charT> >::get(l, 5);
526  }
527  } 
528  template <class charT>
529  class w32_regex_traits
530  {
531  public:
532     typedef charT                         char_type;
533     typedef std::size_t                   size_type;
534     typedef std::basic_string<char_type>  string_type;
535     typedef ::boost::BOOST_REGEX_DETAIL_NS::lcid_type locale_type;
536     typedef std::uint_least32_t         char_class_type;
537     struct boost_extensions_tag{};
538     w32_regex_traits()
539        : m_pimpl(BOOST_REGEX_DETAIL_NS::create_w32_regex_traits<charT>(::boost::BOOST_REGEX_DETAIL_NS::w32_get_default_locale()))
540     { }
541     static size_type length(const char_type* p)
542     {
543        return std::char_traits<charT>::length(p);
544     }
545     regex_constants::syntax_type syntax_type(charT c)const
546     {
547        return m_pimpl->syntax_type(c);
548     }
549     regex_constants::escape_syntax_type escape_syntax_type(charT c) const
550     {
551        return m_pimpl->escape_syntax_type(c);
552     }
553     charT translate(charT c) const
554     {
555        return c;
556     }
557     charT translate_nocase(charT c) const
558     {
559        return this->m_pimpl->tolower(c);
560     }
561     charT translate(charT c, bool icase) const
562     {
563        return icase ? this->m_pimpl->tolower(c) : c;
564     }
565     charT tolower(charT c) const
566     {
567        return this->m_pimpl->tolower(c);
568     }
569     charT toupper(charT c) const
570     {
571        return ::boost::BOOST_REGEX_DETAIL_NS::w32_toupper(c, this->m_pimpl->m_locale);
572     }
573     string_type transform(const charT* p1, const charT* p2) const
574     {
575        return ::boost::BOOST_REGEX_DETAIL_NS::w32_transform(this->m_pimpl->m_locale, p1, p2);
576     }
577     string_type transform_primary(const charT* p1, const charT* p2) const
578     {
579        return m_pimpl->transform_primary(p1, p2);
580     }
581     char_class_type lookup_classname(const charT* p1, const charT* p2) const
582     {
583        return m_pimpl->lookup_classname(p1, p2);
584     }
585     string_type lookup_collatename(const charT* p1, const charT* p2) const
586     {
587        return m_pimpl->lookup_collatename(p1, p2);
588     }
589     bool isctype(charT c, char_class_type f) const
590     {
591        if((f & BOOST_REGEX_DETAIL_NS::w32_regex_traits_implementation<charT>::mask_base) 
592           && (this->m_pimpl->isctype(f & BOOST_REGEX_DETAIL_NS::w32_regex_traits_implementation<charT>::mask_base, c)))
593           return true;
594        else if((f & BOOST_REGEX_DETAIL_NS::w32_regex_traits_implementation<charT>::mask_unicode) && BOOST_REGEX_DETAIL_NS::is_extended(c))
595           return true;
596        else if((f & BOOST_REGEX_DETAIL_NS::w32_regex_traits_implementation<charT>::mask_word) && (c == '_'))
597           return true;
598        else if((f & BOOST_REGEX_DETAIL_NS::w32_regex_traits_implementation<charT>::mask_vertical)
599           && (::boost::BOOST_REGEX_DETAIL_NS::is_separator(c) || (c == '\v')))
600           return true;
601        else if((f & BOOST_REGEX_DETAIL_NS::w32_regex_traits_implementation<charT>::mask_horizontal) 
602           && this->isctype(c, 0x0008u) && !this->isctype(c, BOOST_REGEX_DETAIL_NS::w32_regex_traits_implementation<charT>::mask_vertical))
603           return true;
604        return false;
605     }
606     std::intmax_t toi(const charT*& p1, const charT* p2, int radix)const
607     {
608        return ::boost::BOOST_REGEX_DETAIL_NS::global_toi(p1, p2, radix, *this);
609     }
610     int value(charT c, int radix)const
611     {
612        int result = (int)::boost::BOOST_REGEX_DETAIL_NS::global_value(c);
613        return result < radix ? result : -1;
614     }
615     locale_type imbue(locale_type l)
616     {
617        ::boost::BOOST_REGEX_DETAIL_NS::lcid_type result(getloc());
618        m_pimpl = BOOST_REGEX_DETAIL_NS::create_w32_regex_traits<charT>(l);
619        return result;
620     }
621     locale_type getloc()const
622     {
623        return m_pimpl->m_locale;
624     }
625     std::string error_string(regex_constants::error_type n) const
626     {
627        return m_pimpl->error_string(n);
628     }
629     static std::string catalog_name(const std::string& name);
630     static std::string get_catalog_name();
631  private:
632     std::shared_ptr<const BOOST_REGEX_DETAIL_NS::w32_regex_traits_implementation<charT> > m_pimpl;
633     static std::string& get_catalog_name_inst();
634  #ifdef BOOST_HAS_THREADS
635     static std::mutex& get_mutex_inst();
636  #endif
637  };
638  template <class charT>
639  std::string w32_regex_traits<charT>::catalog_name(const std::string& name)
640  {
641  #ifdef BOOST_HAS_THREADS
642     std::lock_guard<std::mutex> lk(get_mutex_inst());
643  #endif
644     std::string result(get_catalog_name_inst());
645     get_catalog_name_inst() = name;
646     return result;
647  }
648  template <class charT>
649  std::string& w32_regex_traits<charT>::get_catalog_name_inst()
650  {
651     static std::string s_name;
652     return s_name;
653  }
654  template <class charT>
655  std::string w32_regex_traits<charT>::get_catalog_name()
656  {
657  #ifdef BOOST_HAS_THREADS
658     std::lock_guard<std::mutex> lk(get_mutex_inst());
659  #endif
660     std::string result(get_catalog_name_inst());
661     return result;
662  }
663  #ifdef BOOST_HAS_THREADS
664  template <class charT>
665  std::mutex& w32_regex_traits<charT>::get_mutex_inst()
666  {
667     static std::mutex s_mutex;
668     return s_mutex;
669  }
670  #endif
671  namespace BOOST_REGEX_DETAIL_NS {
672  #ifdef BOOST_NO_ANSI_APIS
673     inline unsigned int get_code_page_for_locale_id(lcid_type idx)
674     {
675        wchar_t code_page_string[7];
676        if (boost::BOOST_REGEX_DETAIL_NS::GetLocaleInfoW(idx, locale_idefaultansicodepage, code_page_string, 7) == 0)
677           return 0;
678        return static_cast<unsigned int>(_wtol(code_page_string));
679  }
680  #endif
681     template <class U>
682     inline void w32_regex_traits_char_layer<char>::init()
683     {
684        std::memset(m_char_map, 0, sizeof(m_char_map));
685        cat_type cat;
686        std::string cat_name(w32_regex_traits<char>::get_catalog_name());
687        if (cat_name.size())
688        {
689           cat = ::boost::BOOST_REGEX_DETAIL_NS::w32_cat_open(cat_name);
690           if (!cat)
691           {
692              std::string m("Unable to open message catalog: ");
693              std::runtime_error err(m + cat_name);
694              ::boost::BOOST_REGEX_DETAIL_NS::raise_runtime_error(err);
695           }
696        }
697        if (cat)
698        {
699           for (regex_constants::syntax_type i = 1; i < regex_constants::syntax_max; ++i)
700           {
701              string_type mss = ::boost::BOOST_REGEX_DETAIL_NS::w32_cat_get(cat, this->m_locale, i, get_default_syntax(i));
702              for (string_type::size_type j = 0; j < mss.size(); ++j)
703              {
704                 m_char_map[static_cast<unsigned char>(mss[j])] = i;
705              }
706           }
707        }
708        else
709        {
710           for (regex_constants::syntax_type i = 1; i < regex_constants::syntax_max; ++i)
711           {
712              const char* ptr = get_default_syntax(i);
713              while (ptr && *ptr)
714              {
715                 m_char_map[static_cast<unsigned char>(*ptr)] = i;
716                 ++ptr;
717              }
718           }
719        }
720        unsigned char i = 'A';
721        do
722        {
723           if (m_char_map[i] == 0)
724           {
725              if (::boost::BOOST_REGEX_DETAIL_NS::w32_is(this->m_locale, 0x0002u, (char)i))
726                 m_char_map[i] = regex_constants::escape_type_class;
727              else if (::boost::BOOST_REGEX_DETAIL_NS::w32_is(this->m_locale, 0x0001u, (char)i))
728                 m_char_map[i] = regex_constants::escape_type_not_class;
729           }
730        } while (0xFF != i++);
731        char char_map[1 << CHAR_BIT];
732        for (int ii = 0; ii < (1 << CHAR_BIT); ++ii)
733           char_map[ii] = static_cast<char>(ii);
734  #ifndef BOOST_NO_ANSI_APIS
735        int r = boost::BOOST_REGEX_DETAIL_NS::LCMapStringA(this->m_locale, lcmap_lowercase, char_map, 1 << CHAR_BIT, this->m_lower_map, 1 << CHAR_BIT);
736        BOOST_REGEX_ASSERT(r != 0);
737  #else
738        unsigned int code_page = get_code_page_for_locale_id(this->m_locale);
739        BOOST_REGEX_ASSERT(code_page != 0);
740        wchar_t wide_char_map[1 << CHAR_BIT];
741        int conv_r = boost::BOOST_REGEX_DETAIL_NS::MultiByteToWideChar(code_page, 0, char_map, 1 << CHAR_BIT, wide_char_map, 1 << CHAR_BIT);
742        BOOST_REGEX_ASSERT(conv_r != 0);
743        wchar_t wide_lower_map[1 << CHAR_BIT];
744        int r = boost::BOOST_REGEX_DETAIL_NS::LCMapStringW(this->m_locale, lcmap_lowercase, wide_char_map, 1 << CHAR_BIT, wide_lower_map, 1 << CHAR_BIT);
745        BOOST_REGEX_ASSERT(r != 0);
746        conv_r = boost::BOOST_REGEX_DETAIL_NS::WideCharToMultiByte(code_page, 0, wide_lower_map, r, this->m_lower_map, 1 << CHAR_BIT, NULL, NULL);
747        BOOST_REGEX_ASSERT(conv_r != 0);
748  #endif
749        if (r < (1 << CHAR_BIT))
750        {
751           for (int jj = r; jj < (1 << CHAR_BIT); ++jj)
752              this->m_lower_map[jj] = static_cast<char>(jj);
753        }
754  #ifndef BOOST_NO_ANSI_APIS
755        r = boost::BOOST_REGEX_DETAIL_NS::GetStringTypeExA(this->m_locale, ct_ctype1, char_map, 1 << CHAR_BIT, this->m_type_map);
756  #else
757        r = boost::BOOST_REGEX_DETAIL_NS::GetStringTypeExW(this->m_locale, ct_ctype1, wide_char_map, 1 << CHAR_BIT, this->m_type_map);
758  #endif
759        BOOST_REGEX_ASSERT(0 != r);
760     }
761     inline lcid_type  w32_get_default_locale()
762     {
763        return boost::BOOST_REGEX_DETAIL_NS::GetUserDefaultLCID();
764     }
765     inline bool  w32_is_lower(char c, lcid_type idx)
766     {
767  #ifndef BOOST_NO_ANSI_APIS
768        word mask;
769        if (boost::BOOST_REGEX_DETAIL_NS::GetStringTypeExA(idx, ct_ctype1, &c, 1, &mask) && (mask & c1_lower))
770           return true;
771        return false;
772  #else
773        unsigned int code_page = get_code_page_for_locale_id(idx);
774        if (code_page == 0)
775           return false;
776        wchar_t wide_c;
777        if (boost::BOOST_REGEX_DETAIL_NS::MultiByteToWideChar(code_page, 0, &c, 1, &wide_c, 1) == 0)
778           return false;
779        word mask;
780        if (boost::BOOST_REGEX_DETAIL_NS::GetStringTypeExW(idx, ct_ctype1, &wide_c, 1, &mask) && (mask & c1_lower))
781           return true;
782        return false;
783  #endif
784     }
785     inline bool  w32_is_lower(wchar_t c, lcid_type idx)
786     {
787        word mask;
788        if (boost::BOOST_REGEX_DETAIL_NS::GetStringTypeExW(idx, ct_ctype1, &c, 1, &mask) && (mask & c1_lower))
789           return true;
790        return false;
791     }
792     inline bool  w32_is_upper(char c, lcid_type idx)
793     {
794  #ifndef BOOST_NO_ANSI_APIS
795        word mask;
796        if (boost::BOOST_REGEX_DETAIL_NS::GetStringTypeExA(idx, ct_ctype1, &c, 1, &mask) && (mask & c1_upper))
797           return true;
798        return false;
799  #else
800        unsigned int code_page = get_code_page_for_locale_id(idx);
801        if (code_page == 0)
802           return false;
803        wchar_t wide_c;
804        if (boost::BOOST_REGEX_DETAIL_NS::MultiByteToWideChar(code_page, 0, &c, 1, &wide_c, 1) == 0)
805           return false;
806        word mask;
807        if (boost::BOOST_REGEX_DETAIL_NS::GetStringTypeExW(idx, ct_ctype1, &wide_c, 1, &mask) && (mask & c1_upper))
808           return true;
809        return false;
810  #endif
811     }
812     inline bool  w32_is_upper(wchar_t c, lcid_type idx)
813     {
814        word mask;
815        if (boost::BOOST_REGEX_DETAIL_NS::GetStringTypeExW(idx, ct_ctype1, &c, 1, &mask) && (mask & c1_upper))
816           return true;
817        return false;
818     }
819     inline void free_module(void* mod)
820     {
821        boost::BOOST_REGEX_DETAIL_NS::FreeLibrary(static_cast<HMODULE>(mod));
822     }
823     inline cat_type  w32_cat_open(const std::string& name)
824     {
825  #ifndef BOOST_NO_ANSI_APIS
826        cat_type result(boost::BOOST_REGEX_DETAIL_NS::LoadLibraryA(name.c_str()), &free_module);
827        return result;
828  #else
829        wchar_t* wide_name = (wchar_t*)_alloca((name.size() + 1) * sizeof(wchar_t));
830        if (boost::BOOST_REGEX_DETAIL_NS::MultiByteToWideChar(cp_acp, 0, name.c_str(), (int)name.size(), wide_name, (int)(name.size() + 1)) == 0)
831           return cat_type();
832        cat_type result(boost::BOOST_REGEX_DETAIL_NS::LoadLibraryW(wide_name), &free_module);
833        return result;
834  #endif
835     }
836     inline std::string  w32_cat_get(const cat_type& cat, lcid_type, int i, const std::string& def)
837     {
838  #ifndef BOOST_NO_ANSI_APIS
839        char buf[256];
840        if (0 == boost::BOOST_REGEX_DETAIL_NS::LoadStringA(
841           static_cast<HMODULE>(cat.get()),
842           i,
843           buf,
844           256
845        ))
846        {
847           return def;
848        }
849  #else
850        wchar_t wbuf[256];
851        int r = boost::BOOST_REGEX_DETAIL_NS::LoadStringW(
852           static_cast<HMODULE>(cat.get()),
853           i,
854           wbuf,
855           256
856        );
857        if (r == 0)
858           return def;
859        int buf_size = 1 + boost::BOOST_REGEX_DETAIL_NS::WideCharToMultiByte(cp_acp, 0, wbuf, r, NULL, 0, NULL, NULL);
860        char* buf = (char*)_alloca(buf_size);
861        if (boost::BOOST_REGEX_DETAIL_NS::WideCharToMultiByte(cp_acp, 0, wbuf, r, buf, buf_size, NULL, NULL) == 0)
862           return def; 
863  #endif
864        return std::string(buf);
865     }
866  #ifndef BOOST_NO_WREGEX
867     inline std::wstring  w32_cat_get(const cat_type& cat, lcid_type, int i, const std::wstring& def)
868     {
869        wchar_t buf[256];
870        if (0 == boost::BOOST_REGEX_DETAIL_NS::LoadStringW(static_cast<HMODULE>(cat.get()), i, buf, 256))
871        {
872           return def;
873        }
874        return std::wstring(buf);
875     }
876  #endif
877     inline std::string  w32_transform(lcid_type idx, const char* p1, const char* p2)
878     {
879  #ifndef BOOST_NO_ANSI_APIS
880        int bytes = boost::BOOST_REGEX_DETAIL_NS::LCMapStringA(
881           idx,       
882           lcmap_sortkey,  
883           p1,  
884           static_cast<int>(p2 - p1),        
885           0,  
886           0        
887        );
888        if (!bytes)
889           return std::string(p1, p2);
890        std::string result(++bytes, '\0');
891        bytes = boost::BOOST_REGEX_DETAIL_NS::LCMapStringA(
892           idx,       
893           lcmap_sortkey,  
894           p1,  
895           static_cast<int>(p2 - p1),        
896           &*result.begin(),  
897           bytes        
898        );
899  #else
900        unsigned int code_page = get_code_page_for_locale_id(idx);
901        if (code_page == 0)
902           return std::string(p1, p2);
903        int src_len = static_cast<int>(p2 - p1);
904        wchar_t* wide_p1 = (wchar_t*)_alloca((src_len + 1) * 2);
905        if (boost::BOOST_REGEX_DETAIL_NS::MultiByteToWideChar(code_page, 0, p1, src_len, wide_p1, src_len + 1) == 0)
906           return std::string(p1, p2);
907        int bytes = boost::BOOST_REGEX_DETAIL_NS::LCMapStringW(
908           idx,       
909           lcmap_sortkey,  
910           wide_p1,  
911           src_len,        
912           0,  
913           0        
914        );
915        if (!bytes)
916           return std::string(p1, p2);
917        std::string result(++bytes, '\0');
918        bytes = boost::BOOST_REGEX_DETAIL_NS::LCMapStringW(
919           idx,       
920           lcmap_sortkey,  
921           wide_p1,  
922           src_len,        
923           (wchar_t*) & *result.begin(),  
924           bytes        
925        );
926  #endif
927        if (bytes > static_cast<int>(result.size()))
928           return std::string(p1, p2);
929        while (result.size() && result[result.size() - 1] == '\0')
930        {
931           result.erase(result.size() - 1);
932        }
933        return result;
934     }
935  #ifndef BOOST_NO_WREGEX
936     inline std::wstring  w32_transform(lcid_type idx, const wchar_t* p1, const wchar_t* p2)
937     {
938        int bytes = boost::BOOST_REGEX_DETAIL_NS::LCMapStringW(
939           idx,       
940           lcmap_sortkey,  
941           p1,  
942           static_cast<int>(p2 - p1),        
943           0,  
944           0        
945        );
946        if (!bytes)
947           return std::wstring(p1, p2);
948        std::string result(++bytes, '\0');
949        bytes = boost::BOOST_REGEX_DETAIL_NS::LCMapStringW(
950           idx,       
951           lcmap_sortkey,  
952           p1,  
953           static_cast<int>(p2 - p1),        
954           reinterpret_cast<wchar_t*>(&*result.begin()),  
955           bytes        
956        );
957        if (bytes > static_cast<int>(result.size()))
958           return std::wstring(p1, p2);
959        while (result.size() && result[result.size() - 1] == L'\0')
960        {
961           result.erase(result.size() - 1);
962        }
963        std::wstring r2;
964        for (std::string::size_type i = 0; i < result.size(); ++i)
965           r2.append(1, static_cast<wchar_t>(static_cast<unsigned char>(result[i])));
966        return r2;
967     }
968  #endif
969     inline char  w32_tolower(char c, lcid_type idx)
970     {
971        char result[2];
972  #ifndef BOOST_NO_ANSI_APIS
973        int b = boost::BOOST_REGEX_DETAIL_NS::LCMapStringA(
974           idx,       
975           lcmap_lowercase,  
976           &c,  
977           1,        
978           result,  
979           1);        
980        if (b == 0)
981           return c;
982  #else
983        unsigned int code_page = get_code_page_for_locale_id(idx);
984        if (code_page == 0)
985           return c;
986        wchar_t wide_c;
987        if (boost::BOOST_REGEX_DETAIL_NS::MultiByteToWideChar(code_page, 0, &c, 1, &wide_c, 1) == 0)
988           return c;
989        wchar_t  wide_result;
990        int b = boost::BOOST_REGEX_DETAIL_NS::LCMapStringW(
991           idx,       
992           lcmap_lowercase,  
993           &wide_c,  
994           1,        
995           &wide_result,  
996           1);        
997        if (b == 0)
998           return c;
999        if (boost::BOOST_REGEX_DETAIL_NS::WideCharToMultiByte(code_page, 0, &wide_result, 1, result, 2, NULL, NULL) == 0)
1000           return c;  
1001  #endif
1002        return result[0];
1003     }
1004  #ifndef BOOST_NO_WREGEX
1005     inline wchar_t  w32_tolower(wchar_t c, lcid_type idx)
1006     {
1007        wchar_t result[2];
1008        int b = boost::BOOST_REGEX_DETAIL_NS::LCMapStringW(
1009           idx,       
1010           lcmap_lowercase,  
1011           &c,  
1012           1,        
1013           result,  
1014           1);        
1015        if (b == 0)
1016           return c;
1017        return result[0];
1018     }
1019  #endif
1020     inline char  w32_toupper(char c, lcid_type idx)
1021     {
1022        char result[2];
1023  #ifndef BOOST_NO_ANSI_APIS
1024        int b = boost::BOOST_REGEX_DETAIL_NS::LCMapStringA(
1025           idx,       
1026           lcmap_uppercase,  
1027           &c,  
1028           1,        
1029           result,  
1030           1);        
1031        if (b == 0)
1032           return c;
1033  #else
1034        unsigned int code_page = get_code_page_for_locale_id(idx);
1035        if (code_page == 0)
1036           return c;
1037        wchar_t wide_c;
1038        if (boost::BOOST_REGEX_DETAIL_NS::MultiByteToWideChar(code_page, 0, &c, 1, &wide_c, 1) == 0)
1039           return c;
1040        wchar_t wide_result;
1041        int b = boost::BOOST_REGEX_DETAIL_NS::LCMapStringW(
1042           idx,       
1043           lcmap_uppercase,  
1044           &wide_c,  
1045           1,        
1046           &wide_result,  
1047           1);        
1048        if (b == 0)
1049           return c;
1050        if (boost::BOOST_REGEX_DETAIL_NS::WideCharToMultiByte(code_page, 0, &wide_result, 1, result, 2, NULL, NULL) == 0)
1051           return c;  
1052  #endif
1053        return result[0];
1054     }
1055  #ifndef BOOST_NO_WREGEX
1056     inline wchar_t  w32_toupper(wchar_t c, lcid_type idx)
1057     {
1058        wchar_t result[2];
1059        int b = boost::BOOST_REGEX_DETAIL_NS::LCMapStringW(
1060           idx,       
1061           lcmap_uppercase,  
1062           &c,  
1063           1,        
1064           result,  
1065           1);        
1066        if (b == 0)
1067           return c;
1068        return result[0];
1069     }
1070  #endif
1071     inline bool  w32_is(lcid_type idx, std::uint32_t m, char c)
1072     {
1073        word mask;
1074  #ifndef BOOST_NO_ANSI_APIS
1075        if (boost::BOOST_REGEX_DETAIL_NS::GetStringTypeExA(idx, ct_ctype1, &c, 1, &mask) && (mask & m & w32_regex_traits_implementation<char>::mask_base))
1076           return true;
1077  #else
1078        unsigned int code_page = get_code_page_for_locale_id(idx);
1079        if (code_page == 0)
1080           return false;
1081        wchar_t wide_c;
1082        if (boost::BOOST_REGEX_DETAIL_NS::MultiByteToWideChar(code_page, 0, &c, 1, &wide_c, 1) == 0)
1083           return false;
1084        if (boost::BOOST_REGEX_DETAIL_NS::GetStringTypeExW(idx, ct_ctype1, &wide_c, 1, &mask) && (mask & m & w32_regex_traits_implementation<char>::mask_base))
1085           return true;
1086  #endif
1087        if ((m & w32_regex_traits_implementation<char>::mask_word) && (c == '_'))
1088           return true;
1089        return false;
1090     }
1091  #ifndef BOOST_NO_WREGEX
1092     inline bool  w32_is(lcid_type idx, std::uint32_t m, wchar_t c)
1093     {
1094        word mask;
1095        if (boost::BOOST_REGEX_DETAIL_NS::GetStringTypeExW(idx, ct_ctype1, &c, 1, &mask) && (mask & m & w32_regex_traits_implementation<wchar_t>::mask_base))
1096           return true;
1097        if ((m & w32_regex_traits_implementation<wchar_t>::mask_word) && (c == '_'))
1098           return true;
1099        if ((m & w32_regex_traits_implementation<wchar_t>::mask_unicode) && (c > 0xff))
1100           return true;
1101        return false;
1102     }
1103  #endif
1104  } 
1105  } 
1106  #ifdef BOOST_REGEX_MSVC
1107  #pragma warning(pop)
1108  #endif
1109  #endif 
1110  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-w32_regex_traits.hpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-w32_regex_traits.hpp</div>
                </div>
                <div class="column column_space"><pre><code>229     cat_type cat;
230     std::string cat_name(w32_regex_traits<charT>::get_catalog_name());
231     if(cat_name.size())
232     {
233        cat = ::boost::BOOST_REGEX_DETAIL_NS::w32_cat_open(cat_name);
234        if(!cat)
235        {
236           std::string m("Unable to open message catalog: ");
237           std::runtime_error err(m + cat_name);
238           boost::BOOST_REGEX_DETAIL_NS::raise_runtime_error(err);
239        }
240     }
241     if(cat)
242     {
243        for(regex_constants::syntax_type i = 1; i < regex_constants::syntax_max; ++i)
</pre></code></div>
                <div class="column column_space"><pre><code>421     cat_type cat;
422     std::string cat_name(w32_regex_traits<charT>::get_catalog_name());
423     if(cat_name.size())
424     {
425        cat = ::boost::BOOST_REGEX_DETAIL_NS::w32_cat_open(cat_name);
426        if(!cat)
427        {
428           std::string m("Unable to open message catalog: ");
429           std::runtime_error err(m + cat_name);
430           boost::BOOST_REGEX_DETAIL_NS::raise_runtime_error(err);
431        }
432     }
433     if(cat)
434     {
435        for(boost::regex_constants::error_type i = static_cast<boost::regex_constants::error_type>(0); 
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    