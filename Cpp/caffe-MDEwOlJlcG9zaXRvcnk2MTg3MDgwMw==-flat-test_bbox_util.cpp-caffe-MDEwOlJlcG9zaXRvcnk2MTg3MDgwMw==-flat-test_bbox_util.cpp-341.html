
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 63, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-test_bbox_util.cpp</h3>
            <pre><code>1  #include &lt;map&gt;
2  #include &lt;utility&gt;
3  #include &lt;vector&gt;
4  #include &quot;gtest/gtest.h&quot;
5  #include &quot;caffe/common.hpp&quot;
6  #include &quot;caffe/util/bbox_util.hpp&quot;
7  #include &quot;caffe/test/test_caffe_main.hpp&quot;
8  namespace caffe {
9  static const float eps = 1e-6;
10  void FillBBoxes(vector&lt;NormalizedBBox&gt;* gt_bboxes,
11                  vector&lt;NormalizedBBox&gt;* pred_bboxes) {
12    gt_bboxes-&gt;clear();
13    pred_bboxes-&gt;clear();
14    NormalizedBBox bbox;
15    bbox.set_label(1);
16    bbox.set_xmin(0.1);
17    bbox.set_ymin(0.1);
18    bbox.set_xmax(0.3);
19    bbox.set_ymax(0.3);
20    gt_bboxes-&gt;push_back(bbox);
21    bbox.set_label(2);
22    bbox.set_xmin(0.3);
23    bbox.set_ymin(0.3);
24    bbox.set_xmax(0.6);
25    bbox.set_ymax(0.5);
26    gt_bboxes-&gt;push_back(bbox);
27    bbox.set_xmin(0.1);
28    bbox.set_ymin(0);
29    bbox.set_xmax(0.4);
30    bbox.set_ymax(0.3);
31    pred_bboxes-&gt;push_back(bbox);
32    bbox.set_xmin(0);
33    bbox.set_ymin(0.1);
34    bbox.set_xmax(0.2);
35    bbox.set_ymax(0.3);
36    pred_bboxes-&gt;push_back(bbox);
37    bbox.set_xmin(0.2);
38    bbox.set_ymin(0.1);
39    bbox.set_xmax(0.4);
40    bbox.set_ymax(0.4);
41    pred_bboxes-&gt;push_back(bbox);
42    bbox.set_xmin(0.4);
43    bbox.set_ymin(0.3);
44    bbox.set_xmax(0.7);
45    bbox.set_ymax(0.5);
46    pred_bboxes-&gt;push_back(bbox);
47    bbox.set_xmin(0.5);
48    bbox.set_ymin(0.4);
49    bbox.set_xmax(0.7);
50    bbox.set_ymax(0.7);
51    pred_bboxes-&gt;push_back(bbox);
52    bbox.set_xmin(0.7);
53    bbox.set_ymin(0.7);
54    bbox.set_xmax(0.8);
55    bbox.set_ymax(0.8);
56    pred_bboxes-&gt;push_back(bbox);
57  }
58  template &lt;typename TypeParam&gt;
59  class BBoxUtilTest : public MultiDeviceTest&lt;TypeParam&gt; {
60    typedef typename TypeParam::Dtype Dtype;
61  };
62  class CPUBBoxUtilTest : public BBoxUtilTest&lt;CPUDevice&lt;float&gt; &gt; {
63  };
64  TEST_F(CPUBBoxUtilTest, TestIntersectBBox) {
65    NormalizedBBox bbox_ref;
66    bbox_ref.set_xmin(0.2);
67    bbox_ref.set_ymin(0.3);
68    bbox_ref.set_xmax(0.3);
69    bbox_ref.set_ymax(0.5);
70    NormalizedBBox bbox_test;
71    NormalizedBBox bbox_intersect;
72    bbox_test.set_xmin(0.1);
73    bbox_test.set_ymin(0.1);
74    bbox_test.set_xmax(0.3);
75    bbox_test.set_ymax(0.4);
76    IntersectBBox(bbox_ref, bbox_test, &amp;bbox_intersect);
77    EXPECT_NEAR(bbox_intersect.xmin(), 0.2, eps);
78    EXPECT_NEAR(bbox_intersect.ymin(), 0.3, eps);
79    EXPECT_NEAR(bbox_intersect.xmax(), 0.3, eps);
80    EXPECT_NEAR(bbox_intersect.ymax(), 0.4, eps);
81    bbox_test.set_xmin(0.1);
82    bbox_test.set_ymin(0.1);
83    bbox_test.set_xmax(0.4);
84    bbox_test.set_ymax(0.6);
85    IntersectBBox(bbox_ref, bbox_test, &amp;bbox_intersect);
86    EXPECT_NEAR(bbox_intersect.xmin(), 0.2, eps);
87    EXPECT_NEAR(bbox_intersect.ymin(), 0.3, eps);
88    EXPECT_NEAR(bbox_intersect.xmax(), 0.3, eps);
89    EXPECT_NEAR(bbox_intersect.ymax(), 0.5, eps);
90    bbox_test.set_xmin(0);
91    bbox_test.set_ymin(0);
92    bbox_test.set_xmax(0.1);
93    bbox_test.set_ymax(0.1);
94    IntersectBBox(bbox_ref, bbox_test, &amp;bbox_intersect);
95    EXPECT_NEAR(bbox_intersect.xmin(), 0, eps);
96    EXPECT_NEAR(bbox_intersect.ymin(), 0, eps);
97    EXPECT_NEAR(bbox_intersect.xmax(), 0, eps);
98    EXPECT_NEAR(bbox_intersect.ymax(), 0, eps);
99  }
100  TEST_F(CPUBBoxUtilTest, TestBBoxSize) {
101    NormalizedBBox bbox;
102    float size;
103    bbox.set_xmin(0.2);
104    bbox.set_ymin(0.3);
105    bbox.set_xmax(0.3);
106    bbox.set_ymax(0.5);
107    size = BBoxSize(bbox);
108    EXPECT_NEAR(size, 0.02, eps);
109    bbox.set_xmin(0.2);
110    bbox.set_ymin(0.3);
111    bbox.set_xmax(0.2);
112    bbox.set_ymax(0.5);
113    size = BBoxSize(bbox);
114    EXPECT_NEAR(size, 0., eps);
115    bbox.set_xmin(0.2);
116    bbox.set_ymin(0.3);
117    bbox.set_xmax(0.1);
118    bbox.set_ymax(0.5);
119    size = BBoxSize(bbox);
120    EXPECT_NEAR(size, 0., eps);
121  }
122  TEST_F(CPUBBoxUtilTest, TestScaleBBox) {
123    NormalizedBBox bbox;
124    bbox.set_xmin(0.21);
125    bbox.set_ymin(0.32);
126    bbox.set_xmax(0.33);
127    bbox.set_ymax(0.54);
128    NormalizedBBox scale_bbox;
129    float eps = 1e-5;
130    int height = 10;
131    int width = 20;
132    ScaleBBox(bbox, height, width, &amp;scale_bbox);
133    EXPECT_NEAR(scale_bbox.xmin(), 4.2, eps);
134    EXPECT_NEAR(scale_bbox.ymin(), 3.2, eps);
135    EXPECT_NEAR(scale_bbox.xmax(), 6.6, eps);
136    EXPECT_NEAR(scale_bbox.ymax(), 5.4, eps);
137    EXPECT_NEAR(scale_bbox.size(), 10.88, eps);
138    height = 1;
139    width = 1;
140    ScaleBBox(bbox, height, width, &amp;scale_bbox);
141    EXPECT_NEAR(bbox.xmin(), scale_bbox.xmin(), eps);
142    EXPECT_NEAR(bbox.ymin(), scale_bbox.ymin(), eps);
143    EXPECT_NEAR(bbox.xmax(), scale_bbox.xmax(), eps);
144    EXPECT_NEAR(bbox.ymax(), scale_bbox.ymax(), eps);
145    EXPECT_NEAR(scale_bbox.size(), 0.0264, eps);
146  }
147  TEST_F(CPUBBoxUtilTest, TestClipBBox) {
148    NormalizedBBox bbox;
149    NormalizedBBox clip_bbox;
150    bbox.set_xmin(0.2);
151    bbox.set_ymin(0.3);
152    bbox.set_xmax(0.3);
153    bbox.set_ymax(0.5);
154    ClipBBox(bbox, &amp;clip_bbox);
155    EXPECT_NEAR(bbox.xmin(), clip_bbox.xmin(), eps);
156    EXPECT_NEAR(bbox.ymin(), clip_bbox.ymin(), eps);
157    EXPECT_NEAR(bbox.xmax(), clip_bbox.xmax(), eps);
158    EXPECT_NEAR(bbox.ymax(), clip_bbox.ymax(), eps);
159    EXPECT_NEAR(clip_bbox.size(), 0.02, eps);
160    bbox.set_xmin(-0.2);
161    bbox.set_ymin(-0.3);
162    bbox.set_xmax(1.3);
163    bbox.set_ymax(1.5);
164    ClipBBox(bbox, &amp;clip_bbox);
165    EXPECT_NEAR(clip_bbox.xmin(), 0., eps);
166    EXPECT_NEAR(clip_bbox.ymin(), 0., eps);
167    EXPECT_NEAR(clip_bbox.xmax(), 1., eps);
168    EXPECT_NEAR(clip_bbox.ymax(), 1., eps);
169    EXPECT_NEAR(clip_bbox.size(), 1., eps);
170  }
171  TEST_F(CPUBBoxUtilTest, TestOutputBBox) {
172    NormalizedBBox bbox;
173    bbox.set_xmin(-0.1);
174    bbox.set_ymin(0.3);
175    bbox.set_xmax(0.3);
176    bbox.set_ymax(0.5);
177    pair&lt;int, int&gt; img_size(300, 500);
178    bool has_resize = false;
179    ResizeParameter resize_param;
180    resize_param.set_height(300);
181    resize_param.set_width(300);
182    NormalizedBBox out_bbox;
183    OutputBBox(bbox, img_size, has_resize, resize_param, &amp;out_bbox);
184    CHECK_EQ(out_bbox.xmin(), 0.);
185    CHECK_EQ(out_bbox.ymin(), 90.);
186    CHECK_EQ(out_bbox.xmax(), 150.);
187    CHECK_EQ(out_bbox.ymax(), 150.);
188    has_resize = true;
189    resize_param.set_resize_mode(ResizeParameter_Resize_mode_WARP);
190    OutputBBox(bbox, img_size, has_resize, resize_param, &amp;out_bbox);
191    CHECK_EQ(out_bbox.xmin(), 0.);
192    CHECK_EQ(out_bbox.ymin(), 90.);
193    CHECK_EQ(out_bbox.xmax(), 150.);
194    CHECK_EQ(out_bbox.ymax(), 150.);
195    resize_param.set_resize_mode(ResizeParameter_Resize_mode_FIT_SMALL_SIZE);
196    OutputBBox(bbox, img_size, has_resize, resize_param, &amp;out_bbox);
197    CHECK_EQ(out_bbox.xmin(), 0.);
198    CHECK_EQ(out_bbox.ymin(), 90.);
199    CHECK_EQ(out_bbox.xmax(), 150.);
200    CHECK_EQ(out_bbox.ymax(), 150.);
201    resize_param.set_resize_mode(ResizeParameter_Resize_mode_FIT_SMALL_SIZE);
202    resize_param.set_height_scale(300);
203    resize_param.set_width_scale(300);
204    OutputBBox(bbox, img_size, has_resize, resize_param, &amp;out_bbox);
205    CHECK_EQ(out_bbox.xmin(), 0.);
206    CHECK_EQ(out_bbox.ymin(), 90.);
207    CHECK_EQ(out_bbox.xmax(), 90.);
208    CHECK_EQ(out_bbox.ymax(), 150.);
209    resize_param.set_resize_mode(
210        ResizeParameter_Resize_mode_FIT_LARGE_SIZE_AND_PAD);
211    OutputBBox(bbox, img_size, has_resize, resize_param, &amp;out_bbox);
212    static const float errorBound = 1e-4;
213    EXPECT_NEAR(out_bbox.xmin(), 0., errorBound);
214    EXPECT_NEAR(out_bbox.ymin(), 50., errorBound);
215    EXPECT_NEAR(out_bbox.xmax(), 150., errorBound);
216    EXPECT_NEAR(out_bbox.ymax(), 150., errorBound);
217    img_size.first = 500;
218    img_size.second = 300;
219    OutputBBox(bbox, img_size, has_resize, resize_param, &amp;out_bbox);
220    EXPECT_NEAR(out_bbox.xmin(), 0., errorBound);
221    EXPECT_NEAR(out_bbox.ymin(), 150., errorBound);
222    EXPECT_NEAR(out_bbox.xmax(), 50., errorBound);
223    EXPECT_NEAR(out_bbox.ymax(), 250., errorBound);
224  }
225  TEST_F(CPUBBoxUtilTest, TestJaccardOverlap) {
226    NormalizedBBox bbox1;
227    bbox1.set_xmin(0.2);
228    bbox1.set_ymin(0.3);
229    bbox1.set_xmax(0.3);
230    bbox1.set_ymax(0.5);
231    NormalizedBBox bbox2;
232    float overlap;
233    bbox2.set_xmin(0.1);
234    bbox2.set_ymin(0.1);
235    bbox2.set_xmax(0.3);
236    bbox2.set_ymax(0.4);
237    overlap = JaccardOverlap(bbox1, bbox2);
238    EXPECT_NEAR(overlap, 1./7, eps);
239    bbox2.set_xmin(0.1);
240    bbox2.set_ymin(0.1);
241    bbox2.set_xmax(0.4);
242    bbox2.set_ymax(0.6);
243    overlap = JaccardOverlap(bbox1, bbox2);
244    EXPECT_NEAR(overlap, 2./15, eps);
245    bbox2.set_xmin(0);
246    bbox2.set_ymin(0);
247    bbox2.set_xmax(0.1);
248    bbox2.set_ymax(0.1);
249    overlap = JaccardOverlap(bbox1, bbox2);
250    EXPECT_NEAR(overlap, 0., eps);
251  }
252  TEST_F(CPUBBoxUtilTest, TestEncodeBBoxCorner) {
253    NormalizedBBox prior_bbox;
254    prior_bbox.set_xmin(0.1);
255    prior_bbox.set_ymin(0.1);
256    prior_bbox.set_xmax(0.3);
257    prior_bbox.set_ymax(0.3);
258    vector&lt;float&gt; prior_variance(4, 0.1);
259    NormalizedBBox bbox;
260    bbox.set_xmin(0);
261    bbox.set_ymin(0.2);
262    bbox.set_xmax(0.4);
263    bbox.set_ymax(0.5);
264    CodeType code_type = PriorBoxParameter_CodeType_CORNER;
265    NormalizedBBox encode_bbox;
266    bool encode_variance_in_target = true;
267    EncodeBBox(prior_bbox, prior_variance, code_type, encode_variance_in_target,
268               bbox, &amp;encode_bbox);
269    EXPECT_NEAR(encode_bbox.xmin(), -0.1, eps);
270    EXPECT_NEAR(encode_bbox.ymin(), 0.1, eps);
271    EXPECT_NEAR(encode_bbox.xmax(), 0.1, eps);
272    EXPECT_NEAR(encode_bbox.ymax(), 0.2, eps);
273    encode_variance_in_target = false;
274    EncodeBBox(prior_bbox, prior_variance, code_type, encode_variance_in_target,
275               bbox, &amp;encode_bbox);
276    EXPECT_NEAR(encode_bbox.xmin(), -1, eps);
277    EXPECT_NEAR(encode_bbox.ymin(), 1, eps);
278    EXPECT_NEAR(encode_bbox.xmax(), 1, eps);
279    EXPECT_NEAR(encode_bbox.ymax(), 2, eps);
280  }
281  TEST_F(CPUBBoxUtilTest, TestEncodeBBoxCenterSize) {
282    NormalizedBBox prior_bbox;
283    prior_bbox.set_xmin(0.1);
284    prior_bbox.set_ymin(0.1);
285    prior_bbox.set_xmax(0.3);
286    prior_bbox.set_ymax(0.3);
287    vector&lt;float&gt; prior_variance;
288    prior_variance.push_back(0.1);
289    prior_variance.push_back(0.1);
290    prior_variance.push_back(0.2);
291    prior_variance.push_back(0.2);
292    NormalizedBBox bbox;
293    bbox.set_xmin(0);
294    bbox.set_ymin(0.2);
295    bbox.set_xmax(0.4);
296    bbox.set_ymax(0.5);
297    CodeType code_type = PriorBoxParameter_CodeType_CENTER_SIZE;
298    NormalizedBBox encode_bbox;
299    bool encode_variance_in_target = true;
300    EncodeBBox(prior_bbox, prior_variance, code_type, encode_variance_in_target,
301               bbox, &amp;encode_bbox);
302    EXPECT_NEAR(encode_bbox.xmin(), 0, eps);
303    EXPECT_NEAR(encode_bbox.ymin(), 0.75, eps);
304    EXPECT_NEAR(encode_bbox.xmax(), log(2.), eps);
305    EXPECT_NEAR(encode_bbox.ymax(), log(3./2), eps);
306    encode_variance_in_target = false;
307    EncodeBBox(prior_bbox, prior_variance, code_type, encode_variance_in_target,
308               bbox, &amp;encode_bbox);
309    float eps = 1e-5;
310    EXPECT_NEAR(encode_bbox.xmin(), 0 / 0.1, eps);
311    EXPECT_NEAR(encode_bbox.ymin(), 0.75 / 0.1, eps);
312    EXPECT_NEAR(encode_bbox.xmax(), log(2.) / 0.2, eps);
313    EXPECT_NEAR(encode_bbox.ymax(), log(3./2) / 0.2, eps);
314  }
315  TEST_F(CPUBBoxUtilTest, TestDecodeBBoxCorner) {
316    NormalizedBBox prior_bbox;
317    prior_bbox.set_xmin(0.1);
318    prior_bbox.set_ymin(0.1);
319    prior_bbox.set_xmax(0.3);
320    prior_bbox.set_ymax(0.3);
321    vector&lt;float&gt; prior_variance(4, 0.1);
322    NormalizedBBox bbox;
323    bbox.set_xmin(-1);
324    bbox.set_ymin(1);
325    bbox.set_xmax(1);
326    bbox.set_ymax(2);
327    CodeType code_type = PriorBoxParameter_CodeType_CORNER;
328    NormalizedBBox decode_bbox;
329    bool variance_encoded_in_target = false;
330    DecodeBBox(prior_bbox, prior_variance, code_type, variance_encoded_in_target,
331               false, bbox, &amp;decode_bbox);
332    EXPECT_NEAR(decode_bbox.xmin(), 0, eps);
333    EXPECT_NEAR(decode_bbox.ymin(), 0.2, eps);
334    EXPECT_NEAR(decode_bbox.xmax(), 0.4, eps);
335    EXPECT_NEAR(decode_bbox.ymax(), 0.5, eps);
336    variance_encoded_in_target = true;
337    DecodeBBox(prior_bbox, prior_variance, code_type, variance_encoded_in_target,
338               false, bbox, &amp;decode_bbox);
339    EXPECT_NEAR(decode_bbox.xmin(), -0.9, eps);
340    EXPECT_NEAR(decode_bbox.ymin(), 1.1, eps);
341    EXPECT_NEAR(decode_bbox.xmax(), 1.3, eps);
342    EXPECT_NEAR(decode_bbox.ymax(), 2.3, eps);
343  }
344  TEST_F(CPUBBoxUtilTest, TestDecodeBBoxCenterSize) {
345    NormalizedBBox prior_bbox;
346    prior_bbox.set_xmin(0.1);
347    prior_bbox.set_ymin(0.1);
348    prior_bbox.set_xmax(0.3);
349    prior_bbox.set_ymax(0.3);
350    vector&lt;float&gt; prior_variance;
351    prior_variance.push_back(0.1);
352    prior_variance.push_back(0.1);
353    prior_variance.push_back(0.2);
354    prior_variance.push_back(0.2);
355    NormalizedBBox bbox;
356    bbox.set_xmin(0);
357    bbox.set_ymin(0.75);
358    bbox.set_xmax(log(2));
359    bbox.set_ymax(log(3./2));
360    CodeType code_type = PriorBoxParameter_CodeType_CENTER_SIZE;
361    NormalizedBBox decode_bbox;
362    bool variance_encoded_in_target = true;
363    DecodeBBox(prior_bbox, prior_variance, code_type, variance_encoded_in_target,
364               false, bbox, &amp;decode_bbox);
365    EXPECT_NEAR(decode_bbox.xmin(), 0, eps);
366    EXPECT_NEAR(decode_bbox.ymin(), 0.2, eps);
367    EXPECT_NEAR(decode_bbox.xmax(), 0.4, eps);
368    EXPECT_NEAR(decode_bbox.ymax(), 0.5, eps);
369    bbox.set_xmin(0);
370    bbox.set_ymin(7.5);
371    bbox.set_xmax(log(2) * 5);
372    bbox.set_ymax(log(3./2) * 5);
373    variance_encoded_in_target = false;
374    DecodeBBox(prior_bbox, prior_variance, code_type, variance_encoded_in_target,
375               false, bbox, &amp;decode_bbox);
376    EXPECT_NEAR(decode_bbox.xmin(), 0, eps);
377    EXPECT_NEAR(decode_bbox.ymin(), 0.2, eps);
378    EXPECT_NEAR(decode_bbox.xmax(), 0.4, eps);
379    EXPECT_NEAR(decode_bbox.ymax(), 0.5, eps);
380  }
381  TEST_F(CPUBBoxUtilTest, TestDecodeBBoxesCorner) {
382    vector&lt;NormalizedBBox&gt; prior_bboxes;
383    vector&lt;vector&lt;float&gt; &gt; prior_variances;
384    vector&lt;NormalizedBBox&gt; bboxes;
385    for (int i = 1; i &lt; 5; ++i) {
386      NormalizedBBox prior_bbox;
387      prior_bbox.set_xmin(0.1*i);
388      prior_bbox.set_ymin(0.1*i);
389      prior_bbox.set_xmax(0.1*i + 0.2);
390      prior_bbox.set_ymax(0.1*i + 0.2);
391      prior_bboxes.push_back(prior_bbox);
392      vector&lt;float&gt; prior_variance(4, 0.1);
393      prior_variances.push_back(prior_variance);
394      NormalizedBBox bbox;
395      bbox.set_xmin(-1 * (i%2));
396      bbox.set_ymin((i+1)%2);
397      bbox.set_xmax((i+1)%2);
398      bbox.set_ymax(i%2);
399      bboxes.push_back(bbox);
400    }
401    CodeType code_type = PriorBoxParameter_CodeType_CORNER;
402    vector&lt;NormalizedBBox&gt; decode_bboxes;
403    bool variance_encoded_in_target = false;
404    DecodeBBoxes(prior_bboxes, prior_variances, code_type,
405                 variance_encoded_in_target, false, bboxes, &amp;decode_bboxes);
406    EXPECT_EQ(decode_bboxes.size(), 4);
407    for (int i = 1; i &lt; 5; ++i) {
408      EXPECT_NEAR(decode_bboxes[i-1].xmin(), 0.1*i + i%2 * -0.1, eps);
409      EXPECT_NEAR(decode_bboxes[i-1].ymin(), 0.1*i + (i+1)%2 * 0.1, eps);
410      EXPECT_NEAR(decode_bboxes[i-1].xmax(), 0.1*i + 0.2 + (i+1)%2 * 0.1, eps);
411      EXPECT_NEAR(decode_bboxes[i-1].ymax(), 0.1*i + 0.2 + i%2 * 0.1, eps);
412    }
413    variance_encoded_in_target = true;
414    DecodeBBoxes(prior_bboxes, prior_variances, code_type,
415                 variance_encoded_in_target, false, bboxes, &amp;decode_bboxes);
416    EXPECT_EQ(decode_bboxes.size(), 4);
417    for (int i = 1; i &lt; 5; ++i) {
418      EXPECT_NEAR(decode_bboxes[i-1].xmin(), 0.1*i + i%2 * -1, eps);
419      EXPECT_NEAR(decode_bboxes[i-1].ymin(), 0.1*i + (i+1)%2, eps);
420      EXPECT_NEAR(decode_bboxes[i-1].xmax(), 0.1*i + 0.2 + (i+1)%2, eps);
421      EXPECT_NEAR(decode_bboxes[i-1].ymax(), 0.1*i + 0.2 + i%2, eps);
422    }
423  }
424  TEST_F(CPUBBoxUtilTest, TestDecodeBBoxesCenterSize) {
425    vector&lt;NormalizedBBox&gt; prior_bboxes;
426    vector&lt;vector&lt;float&gt; &gt; prior_variances;
427    vector&lt;NormalizedBBox&gt; bboxes;
428    for (int i = 1; i &lt; 5; ++i) {
429      NormalizedBBox prior_bbox;
430      prior_bbox.set_xmin(0.1*i);
431      prior_bbox.set_ymin(0.1*i);
432      prior_bbox.set_xmax(0.1*i + 0.2);
433      prior_bbox.set_ymax(0.1*i + 0.2);
434      prior_bboxes.push_back(prior_bbox);
435      vector&lt;float&gt; prior_variance;
436      prior_variance.push_back(0.1);
437      prior_variance.push_back(0.1);
438      prior_variance.push_back(0.2);
439      prior_variance.push_back(0.2);
440      prior_variances.push_back(prior_variance);
441      NormalizedBBox bbox;
442      bbox.set_xmin(0);
443      bbox.set_ymin(0.75);
444      bbox.set_xmax(log(2.));
445      bbox.set_ymax(log(3./2));
446      bboxes.push_back(bbox);
447    }
448    CodeType code_type = PriorBoxParameter_CodeType_CENTER_SIZE;
449    vector&lt;NormalizedBBox&gt; decode_bboxes;
450    bool variance_encoded_in_target = true;
451    DecodeBBoxes(prior_bboxes, prior_variances, code_type,
452                 variance_encoded_in_target, false, bboxes, &amp;decode_bboxes);
453    EXPECT_EQ(decode_bboxes.size(), 4);
454    float eps = 1e-5;
455    for (int i = 1; i &lt; 5; ++i) {
456      EXPECT_NEAR(decode_bboxes[i-1].xmin(), 0 + (i - 1) * 0.1, eps);
457      EXPECT_NEAR(decode_bboxes[i-1].ymin(), 0.2 + (i - 1) * 0.1, eps);
458      EXPECT_NEAR(decode_bboxes[i-1].xmax(), 0.4 + (i - 1) * 0.1, eps);
459      EXPECT_NEAR(decode_bboxes[i-1].ymax(), 0.5 + (i - 1) * 0.1, eps);
460    }
461    variance_encoded_in_target = false;
462    for (int i = 0; i &lt; 4; ++i) {
463      NormalizedBBox bbox;
464      bboxes[i].set_xmin(0);
465      bboxes[i].set_ymin(7.5);
466      bboxes[i].set_xmax(log(2.) * 5);
467      bboxes[i].set_ymax(log(3./2) * 5);
468    }
469    DecodeBBoxes(prior_bboxes, prior_variances, code_type,
470                 variance_encoded_in_target, false, bboxes, &amp;decode_bboxes);
471    EXPECT_EQ(decode_bboxes.size(), 4);
472    for (int i = 1; i &lt; 5; ++i) {
473      EXPECT_NEAR(decode_bboxes[i-1].xmin(), 0 + (i - 1) * 0.1, eps);
474      EXPECT_NEAR(decode_bboxes[i-1].ymin(), 0.2 + (i - 1) * 0.1, eps);
475      EXPECT_NEAR(decode_bboxes[i-1].xmax(), 0.4 + (i - 1) * 0.1, eps);
476      EXPECT_NEAR(decode_bboxes[i-1].ymax(), 0.5 + (i - 1) * 0.1, eps);
477    }
478  }
479  TEST_F(CPUBBoxUtilTest, TestMatchBBoxLableOneBipartite) {
480    vector&lt;NormalizedBBox&gt; gt_bboxes;
481    vector&lt;NormalizedBBox&gt; pred_bboxes;
482    FillBBoxes(&amp;gt_bboxes, &amp;pred_bboxes);
483    int label = 1;
484    MatchType match_type = MultiBoxLossParameter_MatchType_BIPARTITE;
485    float overlap = -1;
486    vector&lt;int&gt; match_indices;
487    vector&lt;float&gt; match_overlaps;
488    MatchBBox(gt_bboxes, pred_bboxes, label, match_type, overlap, true,
489              &amp;match_indices, &amp;match_overlaps);
490    EXPECT_EQ(match_indices.size(), 6);
491    EXPECT_EQ(match_overlaps.size(), 6);
492    EXPECT_EQ(match_indices[0], 0);
493    EXPECT_EQ(match_indices[1], -1);
494    EXPECT_EQ(match_indices[2], -1);
495    EXPECT_NEAR(match_overlaps[0], 4./9, eps);
496    EXPECT_NEAR(match_overlaps[1], 2./6, eps);
497    EXPECT_NEAR(match_overlaps[2], 2./8, eps);
498    for (int i = 3; i &lt; 6; ++i) {
499      EXPECT_EQ(match_indices[i], -1);
500      EXPECT_NEAR(match_overlaps[i], 0, eps);
501    }
502  }
503  TEST_F(CPUBBoxUtilTest, TestMatchBBoxLableAllBipartite) {
504    vector&lt;NormalizedBBox&gt; gt_bboxes;
505    vector&lt;NormalizedBBox&gt; pred_bboxes;
506    FillBBoxes(&amp;gt_bboxes, &amp;pred_bboxes);
507    int label = -1;
508    MatchType match_type = MultiBoxLossParameter_MatchType_BIPARTITE;
509    float overlap = -1;
510    vector&lt;int&gt; match_indices;
511    vector&lt;float&gt; match_overlaps;
512    MatchBBox(gt_bboxes, pred_bboxes, label, match_type, overlap, true,
513              &amp;match_indices, &amp;match_overlaps);
514    EXPECT_EQ(match_indices.size(), 6);
515    EXPECT_EQ(match_overlaps.size(), 6);
516    EXPECT_EQ(match_indices[0], 0);
517    EXPECT_EQ(match_indices[3], 1);
518    EXPECT_NEAR(match_overlaps[0], 4./9, eps);
519    EXPECT_NEAR(match_overlaps[1], 2./6, eps);
520    EXPECT_NEAR(match_overlaps[2], 2./8, eps);
521    EXPECT_NEAR(match_overlaps[3], 4./8, eps);
522    EXPECT_NEAR(match_overlaps[4], 1./11, eps);
523    EXPECT_NEAR(match_overlaps[5], 0., eps);
524    for (int i = 0; i &lt; 6; ++i) {
525      if (i == 0 || i == 3) {
526        continue;
527      }
528      EXPECT_EQ(match_indices[i], -1);
529    }
530  }
531  TEST_F(CPUBBoxUtilTest, TestMatchBBoxLableOnePerPrediction) {
532    vector&lt;NormalizedBBox&gt; gt_bboxes;
533    vector&lt;NormalizedBBox&gt; pred_bboxes;
534    FillBBoxes(&amp;gt_bboxes, &amp;pred_bboxes);
535    int label = 1;
536    MatchType match_type = MultiBoxLossParameter_MatchType_PER_PREDICTION;
537    float overlap = 0.3;
538    vector&lt;int&gt; match_indices;
539    vector&lt;float&gt; match_overlaps;
540    MatchBBox(gt_bboxes, pred_bboxes, label, match_type, overlap, true,
541              &amp;match_indices, &amp;match_overlaps);
542    EXPECT_EQ(match_indices.size(), 6);
543    EXPECT_EQ(match_overlaps.size(), 6);
544    EXPECT_EQ(match_indices[0], 0);
545    EXPECT_EQ(match_indices[1], 0);
546    EXPECT_EQ(match_indices[2], -1);
547    EXPECT_NEAR(match_overlaps[0], 4./9, eps);
548    EXPECT_NEAR(match_overlaps[1], 2./6, eps);
549    EXPECT_NEAR(match_overlaps[2], 2./8, eps);
550    for (int i = 3; i &lt; 6; ++i) {
551      EXPECT_EQ(match_indices[i], -1);
552      EXPECT_NEAR(match_overlaps[i], 0, eps);
553    }
554  }
555  TEST_F(CPUBBoxUtilTest, TestMatchBBoxLableAllPerPrediction) {
556    vector&lt;NormalizedBBox&gt; gt_bboxes;
557    vector&lt;NormalizedBBox&gt; pred_bboxes;
558    FillBBoxes(&amp;gt_bboxes, &amp;pred_bboxes);
559    int label = -1;
560    MatchType match_type = MultiBoxLossParameter_MatchType_PER_PREDICTION;
561    float overlap = 0.3;
562    vector&lt;int&gt; match_indices;
563    vector&lt;float&gt; match_overlaps;
564    MatchBBox(gt_bboxes, pred_bboxes, label, match_type, overlap, true,
565              &amp;match_indices, &amp;match_overlaps);
566    EXPECT_EQ(match_indices.size(), 6);
567    EXPECT_EQ(match_overlaps.size(), 6);
568    EXPECT_EQ(match_indices[0], 0);
569    EXPECT_EQ(match_indices[1], 0);
570    EXPECT_EQ(match_indices[2], -1);
571    EXPECT_EQ(match_indices[3], 1);
572    EXPECT_EQ(match_indices[4], -1);
573    EXPECT_EQ(match_indices[5], -1);
574    EXPECT_NEAR(match_overlaps[0], 4./9, eps);
575    EXPECT_NEAR(match_overlaps[1], 2./6, eps);
576    EXPECT_NEAR(match_overlaps[2], 2./8, eps);
577    EXPECT_NEAR(match_overlaps[3], 4./8, eps);
578    EXPECT_NEAR(match_overlaps[4], 1./11, eps);
579    EXPECT_NEAR(match_overlaps[5], 0, eps);
580  }
581  TEST_F(CPUBBoxUtilTest, TestMatchBBoxLableAllPerPredictionEx) {
582    vector&lt;NormalizedBBox&gt; gt_bboxes;
583    vector&lt;NormalizedBBox&gt; pred_bboxes;
584    FillBBoxes(&amp;gt_bboxes, &amp;pred_bboxes);
585    int label = -1;
586    MatchType match_type = MultiBoxLossParameter_MatchType_PER_PREDICTION;
587    float overlap = 0.001;
588    vector&lt;int&gt; match_indices;
589    vector&lt;float&gt; match_overlaps;
590    MatchBBox(gt_bboxes, pred_bboxes, label, match_type, overlap, true,
591              &amp;match_indices, &amp;match_overlaps);
592    EXPECT_EQ(match_indices.size(), 6);
593    EXPECT_EQ(match_overlaps.size(), 6);
594    EXPECT_EQ(match_indices[0], 0);
595    EXPECT_EQ(match_indices[1], 0);
596    EXPECT_EQ(match_indices[2], 0);
597    EXPECT_EQ(match_indices[3], 1);
598    EXPECT_EQ(match_indices[4], 1);
599    EXPECT_EQ(match_indices[5], -1);
600    EXPECT_NEAR(match_overlaps[0], 4./9, eps);
601    EXPECT_NEAR(match_overlaps[1], 2./6, eps);
602    EXPECT_NEAR(match_overlaps[2], 2./8, eps);
603    EXPECT_NEAR(match_overlaps[3], 4./8, eps);
604    EXPECT_NEAR(match_overlaps[4], 1./11, eps);
605    EXPECT_NEAR(match_overlaps[5], 0., eps);
606  }
607  TEST_F(CPUBBoxUtilTest, TestGetGroundTruth) {
608    const int num_gt = 4;
609    Blob&lt;float&gt; gt_blob(1, 1, num_gt, 8);
610    float* gt_data = gt_blob.mutable_cpu_data();
611    for (int i = 0; i &lt; 4; ++i) {
612      int image_id = ceil(i / 2.);
613      gt_data[i * 8] = image_id;
614      gt_data[i * 8 + 1] = i;
615      gt_data[i * 8 + 2] = 0;
616      gt_data[i * 8 + 3] = 0.1;
617      gt_data[i * 8 + 4] = 0.1;
618      gt_data[i * 8 + 5] = 0.3;
619      gt_data[i * 8 + 6] = 0.3;
620      gt_data[i * 8 + 7] = i % 2;
621    }
622    map&lt;int, vector&lt;NormalizedBBox&gt; &gt; all_gt_bboxes;
623    GetGroundTruth(gt_data, num_gt, -1, true, &amp;all_gt_bboxes);
624    EXPECT_EQ(all_gt_bboxes.size(), 3);
625    EXPECT_EQ(all_gt_bboxes[0].size(), 1);
626    EXPECT_EQ(all_gt_bboxes[0][0].label(), 0);
627    EXPECT_NEAR(all_gt_bboxes[0][0].xmin(), 0.1, eps);
628    EXPECT_NEAR(all_gt_bboxes[0][0].ymin(), 0.1, eps);
629    EXPECT_NEAR(all_gt_bboxes[0][0].xmax(), 0.3, eps);
630    EXPECT_NEAR(all_gt_bboxes[0][0].ymax(), 0.3, eps);
631    EXPECT_EQ(all_gt_bboxes[0][0].difficult(), false);
632    EXPECT_NEAR(all_gt_bboxes[0][0].size(), 0.04, eps);
633    EXPECT_EQ(all_gt_bboxes[1].size(), 2);
634    for (int i = 1; i &lt; 3; ++i) {
635      EXPECT_EQ(all_gt_bboxes[1][i-1].label(), i);
636      EXPECT_NEAR(all_gt_bboxes[1][i-1].xmin(), 0.1, eps);
637      EXPECT_NEAR(all_gt_bboxes[1][i-1].ymin(), 0.1, eps);
638      EXPECT_NEAR(all_gt_bboxes[1][i-1].xmax(), 0.3, eps);
639      EXPECT_NEAR(all_gt_bboxes[1][i-1].ymax(), 0.3, eps);
640      EXPECT_EQ(all_gt_bboxes[1][i-1].difficult(), i % 2);
641      EXPECT_NEAR(all_gt_bboxes[1][i-1].size(), 0.04, eps);
642    }
643    EXPECT_EQ(all_gt_bboxes[2].size(), 1);
644    EXPECT_EQ(all_gt_bboxes[2][0].label(), 3);
645    EXPECT_NEAR(all_gt_bboxes[2][0].xmin(), 0.1, eps);
646    EXPECT_NEAR(all_gt_bboxes[2][0].ymin(), 0.1, eps);
647    EXPECT_NEAR(all_gt_bboxes[2][0].xmax(), 0.3, eps);
648    EXPECT_NEAR(all_gt_bboxes[2][0].ymax(), 0.3, eps);
649    EXPECT_EQ(all_gt_bboxes[2][0].difficult(), true);
650    EXPECT_NEAR(all_gt_bboxes[2][0].size(), 0.04, eps);
651    GetGroundTruth(gt_data, num_gt, -1, false, &amp;all_gt_bboxes);
652    EXPECT_EQ(all_gt_bboxes.size(), 2);
653    EXPECT_EQ(all_gt_bboxes[0].size(), 1);
654    EXPECT_EQ(all_gt_bboxes[0][0].label(), 0);
655    EXPECT_NEAR(all_gt_bboxes[0][0].xmin(), 0.1, eps);
656    EXPECT_NEAR(all_gt_bboxes[0][0].ymin(), 0.1, eps);
657    EXPECT_NEAR(all_gt_bboxes[0][0].xmax(), 0.3, eps);
658    EXPECT_NEAR(all_gt_bboxes[0][0].ymax(), 0.3, eps);
659    EXPECT_EQ(all_gt_bboxes[0][0].difficult(), false);
660    EXPECT_NEAR(all_gt_bboxes[0][0].size(), 0.04, eps);
661    EXPECT_EQ(all_gt_bboxes[1].size(), 1);
662    EXPECT_EQ(all_gt_bboxes[1][0].label(), 2);
663    EXPECT_NEAR(all_gt_bboxes[1][0].xmin(), 0.1, eps);
664    EXPECT_NEAR(all_gt_bboxes[1][0].ymin(), 0.1, eps);
665    EXPECT_NEAR(all_gt_bboxes[1][0].xmax(), 0.3, eps);
666    EXPECT_NEAR(all_gt_bboxes[1][0].ymax(), 0.3, eps);
667    EXPECT_EQ(all_gt_bboxes[1][0].difficult(), false);
668    EXPECT_NEAR(all_gt_bboxes[1][0].size(), 0.04, eps);
669  }
670  TEST_F(CPUBBoxUtilTest, TestGetGroundTruthLabelBBox) {
671    const int num_gt = 4;
672    Blob&lt;float&gt; gt_blob(1, 1, num_gt, 8);
673    float* gt_data = gt_blob.mutable_cpu_data();
674    for (int i = 0; i &lt; 4; ++i) {
675      int image_id = ceil(i / 2.);
676      gt_data[i * 8] = image_id;
677      gt_data[i * 8 + 1] = i;
678      gt_data[i * 8 + 2] = 0;
679      gt_data[i * 8 + 3] = 0.1;
680      gt_data[i * 8 + 4] = 0.1;
681      gt_data[i * 8 + 5] = 0.3;
682      gt_data[i * 8 + 6] = 0.3;
683      gt_data[i * 8 + 7] = i % 2;
684    }
685    map&lt;int, LabelBBox&gt; all_gt_bboxes;
686    GetGroundTruth(gt_data, num_gt, -1, true, &amp;all_gt_bboxes);
687    EXPECT_EQ(all_gt_bboxes.size(), 3);
688    EXPECT_EQ(all_gt_bboxes[0].size(), 1);
689    EXPECT_EQ(all_gt_bboxes[0].find(0)-&gt;first, 0);
690    EXPECT_NEAR(all_gt_bboxes[0].find(0)-&gt;second[0].xmin(), 0.1, eps);
691    EXPECT_NEAR(all_gt_bboxes[0].find(0)-&gt;second[0].ymin(), 0.1, eps);
692    EXPECT_NEAR(all_gt_bboxes[0].find(0)-&gt;second[0].xmax(), 0.3, eps);
693    EXPECT_NEAR(all_gt_bboxes[0].find(0)-&gt;second[0].ymax(), 0.3, eps);
694    EXPECT_EQ(all_gt_bboxes[0].find(0)-&gt;second[0].difficult(), false);
695    EXPECT_NEAR(all_gt_bboxes[0].find(0)-&gt;second[0].size(), 0.04, eps);
696    EXPECT_EQ(all_gt_bboxes[1].size(), 2);
697    for (int i = 1; i &lt; 3; ++i) {
698      EXPECT_EQ(all_gt_bboxes[1].find(i)-&gt;first, i);
699      EXPECT_NEAR(all_gt_bboxes[1].find(i)-&gt;second[0].xmin(), 0.1, eps);
700      EXPECT_NEAR(all_gt_bboxes[1].find(i)-&gt;second[0].ymin(), 0.1, eps);
701      EXPECT_NEAR(all_gt_bboxes[1].find(i)-&gt;second[0].xmax(), 0.3, eps);
702      EXPECT_NEAR(all_gt_bboxes[1].find(i)-&gt;second[0].ymax(), 0.3, eps);
703      EXPECT_EQ(all_gt_bboxes[1].find(i)-&gt;second[0].difficult(), i % 2);
704      EXPECT_NEAR(all_gt_bboxes[1].find(i)-&gt;second[0].size(), 0.04, eps);
705    }
706    EXPECT_EQ(all_gt_bboxes[2].size(), 1);
707    EXPECT_EQ(all_gt_bboxes[2].find(3)-&gt;first, 3);
708    EXPECT_NEAR(all_gt_bboxes[2].find(3)-&gt;second[0].xmin(), 0.1, eps);
709    EXPECT_NEAR(all_gt_bboxes[2].find(3)-&gt;second[0].ymin(), 0.1, eps);
710    EXPECT_NEAR(all_gt_bboxes[2].find(3)-&gt;second[0].xmax(), 0.3, eps);
711    EXPECT_NEAR(all_gt_bboxes[2].find(3)-&gt;second[0].ymax(), 0.3, eps);
712    EXPECT_EQ(all_gt_bboxes[2].find(3)-&gt;second[0].difficult(), true);
713    EXPECT_NEAR(all_gt_bboxes[2].find(3)-&gt;second[0].size(), 0.04, eps);
714    GetGroundTruth(gt_data, num_gt, -1, false, &amp;all_gt_bboxes);
715    EXPECT_EQ(all_gt_bboxes.size(), 2);
716    EXPECT_EQ(all_gt_bboxes[0].size(), 1);
717    EXPECT_EQ(all_gt_bboxes[0].find(0)-&gt;first, 0);
718    EXPECT_NEAR(all_gt_bboxes[0].find(0)-&gt;second[0].xmin(), 0.1, eps);
719    EXPECT_NEAR(all_gt_bboxes[0].find(0)-&gt;second[0].ymin(), 0.1, eps);
720    EXPECT_NEAR(all_gt_bboxes[0].find(0)-&gt;second[0].xmax(), 0.3, eps);
721    EXPECT_NEAR(all_gt_bboxes[0].find(0)-&gt;second[0].ymax(), 0.3, eps);
722    EXPECT_EQ(all_gt_bboxes[0].find(0)-&gt;second[0].difficult(), false);
723    EXPECT_NEAR(all_gt_bboxes[0].find(0)-&gt;second[0].size(), 0.04, eps);
724    EXPECT_EQ(all_gt_bboxes[1].size(), 1);
725    EXPECT_EQ(all_gt_bboxes[1].find(2)-&gt;first, 2);
726    EXPECT_NEAR(all_gt_bboxes[1].find(2)-&gt;second[0].xmin(), 0.1, eps);
727    EXPECT_NEAR(all_gt_bboxes[1].find(2)-&gt;second[0].ymin(), 0.1, eps);
728    EXPECT_NEAR(all_gt_bboxes[1].find(2)-&gt;second[0].xmax(), 0.3, eps);
729    EXPECT_NEAR(all_gt_bboxes[1].find(2)-&gt;second[0].ymax(), 0.3, eps);
730    EXPECT_EQ(all_gt_bboxes[1].find(2)-&gt;second[0].difficult(), false);
731    EXPECT_NEAR(all_gt_bboxes[1].find(2)-&gt;second[0].size(), 0.04, eps);
732  }
733  TEST_F(CPUBBoxUtilTest, TestGetLocPredictionsShared) {
734    const int num = 2;
735    const int num_preds_per_class = 2;
736    const int num_loc_classes = 1;
737    const bool share_location = true;
738    const int dim = num_preds_per_class * num_loc_classes * 4;
739    Blob&lt;float&gt; loc_blob(num, dim, 1, 1);
740    float* loc_data = loc_blob.mutable_cpu_data();
741    for (int i = 0; i &lt; num; ++i) {
742      for (int j = 0; j &lt; num_preds_per_class; ++j) {
743        int start_idx = i * dim + j * 4;
744        loc_data[start_idx] = i * num_preds_per_class * 0.1 + j * 0.1;
745        loc_data[start_idx + 1] = i * num_preds_per_class * 0.1 + j * 0.1;
746        loc_data[start_idx + 2] = i * num_preds_per_class * 0.1 + j * 0.1 + 0.2;
747        loc_data[start_idx + 3] = i * num_preds_per_class * 0.1 + j * 0.1 + 0.2;
748      }
749    }
750    vector&lt;LabelBBox&gt; all_loc_bboxes;
751    GetLocPredictions(loc_data, num, num_preds_per_class, num_loc_classes,
752                      share_location, &amp;all_loc_bboxes);
753    EXPECT_EQ(all_loc_bboxes.size(), num);
754    for (int i = 0; i &lt; num; ++i) {
755      EXPECT_EQ(all_loc_bboxes[i].size(), 1);
756      LabelBBox::iterator it = all_loc_bboxes[i].begin();
757      EXPECT_EQ(it-&gt;first, -1);
758      const vector&lt;NormalizedBBox&gt;&amp; bboxes = it-&gt;second;
759      EXPECT_EQ(bboxes.size(), num_preds_per_class);
760      float start_value = i * num_preds_per_class * 0.1;
761      for (int j = 0; j &lt; num_preds_per_class; ++j) {
762        EXPECT_EQ(bboxes[j].has_label(), false);
763        EXPECT_NEAR(bboxes[j].xmin(), start_value + j * 0.1, eps);
764        EXPECT_NEAR(bboxes[j].ymin(), start_value + j * 0.1, eps);
765        EXPECT_NEAR(bboxes[j].xmax(), start_value + j * 0.1 + 0.2, eps);
766        EXPECT_NEAR(bboxes[j].ymax(), start_value + j * 0.1 + 0.2, eps);
767        EXPECT_EQ(bboxes[j].has_size(), false);
768      }
769    }
770  }
771  TEST_F(CPUBBoxUtilTest, TestGetLocPredictionsUnShared) {
772    const int num = 2;
773    const int num_preds_per_class = 2;
774    const int num_loc_classes = 2;
775    const bool share_location = false;
776    const int dim = num_preds_per_class * num_loc_classes * 4;
777    Blob&lt;float&gt; loc_blob(num, dim, 1, 1);
778    float* loc_data = loc_blob.mutable_cpu_data();
779    for (int i = 0; i &lt; num; ++i) {
780      for (int j = 0; j &lt; num_preds_per_class; ++j) {
781        float start_value = (i * num_preds_per_class + j) * num_loc_classes * 0.1;
782        for (int c = 0; c &lt; num_loc_classes; ++c) {
783          int idx = ((i * num_preds_per_class + j) * num_loc_classes + c) * 4;
784          loc_data[idx] = start_value + c * 0.1;
785          loc_data[idx + 1] = start_value + c * 0.1;
786          loc_data[idx + 2] = start_value + c * 0.1 + 0.2;
787          loc_data[idx + 3] = start_value + c * 0.1 + 0.2;
788        }
789      }
790    }
791    vector&lt;LabelBBox&gt; all_loc_bboxes;
792    GetLocPredictions(loc_data, num, num_preds_per_class, num_loc_classes,
793                      share_location, &amp;all_loc_bboxes);
794    EXPECT_EQ(all_loc_bboxes.size(), num);
795    for (int i = 0; i &lt; num; ++i) {
796      EXPECT_EQ(all_loc_bboxes[i].size(), num_loc_classes);
797      for (int c = 0; c &lt; num_loc_classes; ++c) {
798        LabelBBox::iterator it = all_loc_bboxes[i].find(c);
799        EXPECT_EQ(it-&gt;first, c);
800        const vector&lt;NormalizedBBox&gt;&amp; bboxes = it-&gt;second;
801        EXPECT_EQ(bboxes.size(), num_preds_per_class);
802        for (int j = 0; j &lt; num_preds_per_class; ++j) {
803          float start_value =
804              (i * num_preds_per_class + j) * num_loc_classes * 0.1;
805          EXPECT_EQ(bboxes[j].has_label(), false);
806          EXPECT_NEAR(bboxes[j].xmin(), start_value + c * 0.1, eps);
807          EXPECT_NEAR(bboxes[j].ymin(), start_value + c * 0.1, eps);
808          EXPECT_NEAR(bboxes[j].xmax(), start_value + c * 0.1 + 0.2, eps);
809          EXPECT_NEAR(bboxes[j].ymax(), start_value + c * 0.1 + 0.2, eps);
810          EXPECT_EQ(bboxes[j].has_size(), false);
811        }
812      }
813    }
814  }
815  TEST_F(CPUBBoxUtilTest, TestGetConfidenceScores) {
816    const int num = 2;
817    const int num_preds_per_class = 2;
818    const int num_classes = 2;
819    const int dim = num_preds_per_class * num_classes;
820    Blob&lt;float&gt; conf_blob(num, dim, 1, 1);
821    float* conf_data = conf_blob.mutable_cpu_data();
822    for (int i = 0; i &lt; num; ++i) {
823      for (int j = 0; j &lt; num_preds_per_class; ++j) {
824        for (int c = 0; c &lt; num_classes; ++c) {
825          int idx = (i * num_preds_per_class + j) * num_classes + c;
826          conf_data[idx] = idx * 0.1;
827        }
828      }
829    }
830    vector&lt;map&lt;int, vector&lt;float&gt; &gt; &gt; all_conf_preds;
831    GetConfidenceScores(conf_data, num, num_preds_per_class, num_classes,
832                        &amp;all_conf_preds);
833    EXPECT_EQ(all_conf_preds.size(), num);
834    for (int i = 0; i &lt; num; ++i) {
835      EXPECT_EQ(all_conf_preds[i].size(), num_classes);
836      for (int c = 0; c &lt; num_classes; ++c) {
837        map&lt;int, vector&lt;float&gt; &gt;::iterator it = all_conf_preds[i].find(c);
838        EXPECT_EQ(it-&gt;first, c);
839        const vector&lt;float&gt;&amp; confidences = it-&gt;second;
840        EXPECT_EQ(confidences.size(), num_preds_per_class);
841        for (int j = 0; j &lt; num_preds_per_class; ++j) {
842          int idx = (i * num_preds_per_class + j) * num_classes + c;
843          EXPECT_NEAR(confidences[j], idx * 0.1, eps);
844        }
845      }
846    }
847  }
848  TEST_F(CPUBBoxUtilTest, TestComputeConfLoss) {
849    const int num = 2;
850    const int num_preds_per_class = 2;
851    const int num_classes = 2;
852    const int dim = num_preds_per_class * num_classes;
853    Blob&lt;float&gt; conf_blob(num, dim, 1, 1);
854    float* conf_data = conf_blob.mutable_cpu_data();
855    for (int i = 0; i &lt; num; ++i) {
856      int sign = i % 2 ? 1 : -1;
857      for (int j = 0; j &lt; num_preds_per_class; ++j) {
858        for (int c = 0; c &lt; num_classes; ++c) {
859          int idx = (i * num_preds_per_class + j) * num_classes + c;
860          conf_data[idx] = sign * idx * 0.1;
861        }
862      }
863    }
864    vector&lt;vector&lt;float&gt; &gt; all_conf_loss;
865    ConfLossType loss_type = MultiBoxLossParameter_ConfLossType_LOGISTIC;
866    ComputeConfLoss(conf_data, num, num_preds_per_class, num_classes,
867                    -1, loss_type, &amp;all_conf_loss);
868    EXPECT_EQ(all_conf_loss.size(), num);
869    EXPECT_EQ(all_conf_loss[0].size(), num_preds_per_class);
870    EXPECT_NEAR(all_conf_loss[0][0],
871                -(log(exp(0.)/(1.+exp(0.))) + log(exp(0.1)/(1+exp(0.1)))), eps);
872    EXPECT_NEAR(all_conf_loss[0][1],
873                -(log(exp(0.2)/(1.+exp(0.2))) + log(exp(0.3)/(1+exp(0.3)))), eps);
874    EXPECT_EQ(all_conf_loss[1].size(), num_preds_per_class);
875    EXPECT_NEAR(all_conf_loss[1][0],
876                -(log(exp(-0.4)/(1.+exp(-0.4))) + log(exp(-0.5)/(1+exp(-0.5)))),
877                eps);
878    EXPECT_NEAR(all_conf_loss[1][1],
879                -(log(exp(-0.6)/(1.+exp(-0.6))) + log(exp(-0.7)/(1+exp(-0.7)))),
880                eps);
881    ComputeConfLoss(conf_data, num, num_preds_per_class, num_classes,
882                    0, loss_type, &amp;all_conf_loss);
883    EXPECT_EQ(all_conf_loss.size(), num);
884    EXPECT_EQ(all_conf_loss[0].size(), num_preds_per_class);
885    EXPECT_NEAR(all_conf_loss[0][0],
886                -(log(1./(1.+exp(0.))) + log(exp(0.1)/(1+exp(0.1)))), eps);
887    EXPECT_NEAR(all_conf_loss[0][1],
888                -(log(1./(1.+exp(0.2))) + log(exp(0.3)/(1+exp(0.3)))), eps);
889    EXPECT_EQ(all_conf_loss[1].size(), num_preds_per_class);
890    EXPECT_NEAR(all_conf_loss[1][0],
891                -(log(1./(1.+exp(-0.4))) + log(exp(-0.5)/(1+exp(-0.5)))), eps);
892    EXPECT_NEAR(all_conf_loss[1][1],
893                -(log(1./(1.+exp(-0.6))) + log(exp(-0.7)/(1+exp(-0.7)))), eps);
894    loss_type = MultiBoxLossParameter_ConfLossType_SOFTMAX;
895    ComputeConfLoss(conf_data, num, num_preds_per_class, num_classes,
896                    0, loss_type, &amp;all_conf_loss);
897    EXPECT_EQ(all_conf_loss.size(), num);
898    for (int i = 0; i &lt; num; ++i) {
899      EXPECT_EQ(all_conf_loss[i].size(), num_preds_per_class);
900      int sign = i % 2 ? 1 : -1;
901      for (int j = 0; j &lt; num_preds_per_class; ++j) {
902        if (sign == 1) {
903          EXPECT_NEAR(all_conf_loss[i][j], -log(exp(-0.1)/(1+exp(-0.1))), eps);
904        } else {
905          EXPECT_NEAR(all_conf_loss[i][j], -log(1./(1+exp(-0.1))), eps);
906        }
907      }
908    }
909  }
910  TEST_F(CPUBBoxUtilTest, TestComputeConfLossMatch) {
911    const int num = 2;
912    const int num_preds_per_class = 2;
913    const int num_classes = 2;
914    const int dim = num_preds_per_class * num_classes;
915    Blob&lt;float&gt; conf_blob(num, dim, 1, 1);
916    float* conf_data = conf_blob.mutable_cpu_data();
917    vector&lt;map&lt;int, vector&lt;int&gt; &gt; &gt; all_match_indices;
918    map&lt;int, vector&lt;NormalizedBBox&gt; &gt; all_gt_bboxes;
919    for (int i = 0; i &lt; num; ++i) {
920      int sign = i % 2 ? 1 : -1;
921      for (int j = 0; j &lt; num_preds_per_class; ++j) {
922        for (int c = 0; c &lt; num_classes; ++c) {
923          int idx = (i * num_preds_per_class + j) * num_classes + c;
924          conf_data[idx] = sign * idx * 0.1;
925        }
926      }
927      map&lt;int, vector&lt;int&gt; &gt; match_indices;
928      vector&lt;int&gt; indices(num_preds_per_class, -1);
929      match_indices[-1] = indices;
930      if (i == 1) {
931        NormalizedBBox gt_bbox;
932        gt_bbox.set_label(1);
933        all_gt_bboxes[i].push_back(gt_bbox);
934        match_indices[-1][0] = 0;
935      }
936      all_match_indices.push_back(match_indices);
937    }
938    vector&lt;vector&lt;float&gt; &gt; all_conf_loss;
939    ConfLossType loss_type = MultiBoxLossParameter_ConfLossType_LOGISTIC;
940    ComputeConfLoss(conf_data, num, num_preds_per_class, num_classes,
941                    -1, loss_type, all_match_indices, all_gt_bboxes,
942                    &amp;all_conf_loss);
943    EXPECT_EQ(all_conf_loss.size(), num);
944    EXPECT_EQ(all_conf_loss[0].size(), num_preds_per_class);
945    EXPECT_NEAR(all_conf_loss[0][0],
946                -(log(exp(0.)/(1.+exp(0.))) + log(exp(0.1)/(1+exp(0.1)))), eps);
947    EXPECT_NEAR(all_conf_loss[0][1],
948                -(log(exp(0.2)/(1.+exp(0.2))) + log(exp(0.3)/(1+exp(0.3)))), eps);
949    EXPECT_EQ(all_conf_loss[1].size(), num_preds_per_class);
950    EXPECT_NEAR(all_conf_loss[1][0],
951                -(log(exp(-0.4)/(1.+exp(-0.4))) + log(1./(1+exp(-0.5)))),
952                eps);
953    EXPECT_NEAR(all_conf_loss[1][1],
954                -(log(exp(-0.6)/(1.+exp(-0.6))) + log(exp(-0.7)/(1+exp(-0.7)))),
955                eps);
956    ComputeConfLoss(conf_data, num, num_preds_per_class, num_classes,
957                    0, loss_type, all_match_indices, all_gt_bboxes,
958                    &amp;all_conf_loss);
959    EXPECT_EQ(all_conf_loss.size(), num);
960    EXPECT_EQ(all_conf_loss[0].size(), num_preds_per_class);
961    EXPECT_NEAR(all_conf_loss[0][0],
962                -(log(1./(1.+exp(0.))) + log(exp(0.1)/(1+exp(0.1)))), eps);
963    EXPECT_NEAR(all_conf_loss[0][1],
964                -(log(1./(1.+exp(0.2))) + log(exp(0.3)/(1+exp(0.3)))), eps);
965    EXPECT_EQ(all_conf_loss[1].size(), num_preds_per_class);
966    EXPECT_NEAR(all_conf_loss[1][0],
967                -(log(exp(-0.4)/(1.+exp(-0.4))) + log(1./(1+exp(-0.5)))), eps);
968    EXPECT_NEAR(all_conf_loss[1][1],
969                -(log(1./(1.+exp(-0.6))) + log(exp(-0.7)/(1+exp(-0.7)))), eps);
970    loss_type = MultiBoxLossParameter_ConfLossType_SOFTMAX;
971    ComputeConfLoss(conf_data, num, num_preds_per_class, num_classes,
972                    0, loss_type, all_match_indices, all_gt_bboxes,
973                    &amp;all_conf_loss);
974    EXPECT_EQ(all_conf_loss.size(), num);
975    for (int i = 0; i &lt; num; ++i) {
976      EXPECT_EQ(all_conf_loss[i].size(), num_preds_per_class);
977      int sign = i % 2 ? 1 : -1;
978      for (int j = 0; j &lt; num_preds_per_class; ++j) {
979        if (sign == 1) {
980          if (j == 0) {
981            EXPECT_NEAR(all_conf_loss[i][j], -log(1./(1+exp(-0.1))), eps);
982          } else {
983            EXPECT_NEAR(all_conf_loss[i][j], -log(exp(-0.1)/(1+exp(-0.1))), eps);
984          }
985        } else {
986          EXPECT_NEAR(all_conf_loss[i][j], -log(1./(1+exp(-0.1))), eps);
987        }
988      }
989    }
990  }
991  TEST_F(CPUBBoxUtilTest, TestGetPriorBBoxes) {
992    const int num_channels = 2;
993    const int num_priors = 2;
994    const int dim = num_priors * 4;
995    Blob&lt;float&gt; prior_blob(1, num_channels, dim, 1);
996    float* prior_data = prior_blob.mutable_cpu_data();
997    for (int i = 0; i &lt; num_priors; ++i) {
998      prior_data[i * 4] = i * 0.1;
999      prior_data[i * 4 + 1] = i * 0.1;
1000      prior_data[i * 4 + 2] = i * 0.1 + 0.2;
1001      prior_data[i * 4 + 3] = i * 0.1 + 0.1;
1002      for (int j = 0; j &lt; 4; ++j) {
1003        prior_data[dim + i * 4 + j]  = 0.1;
1004      }
1005    }
1006    vector&lt;NormalizedBBox&gt; prior_bboxes(num_priors);
1007    vector&lt;vector&lt;float&gt; &gt; prior_variances(num_priors);
1008    GetPriorBBoxes(prior_data, num_priors, &amp;prior_bboxes, &amp;prior_variances);
1009    EXPECT_EQ(prior_bboxes.size(), num_priors);
1010    EXPECT_EQ(prior_variances.size(), num_priors);
1011    for (int i = 0; i &lt; num_priors; ++i) {
1012      EXPECT_NEAR(prior_bboxes[i].xmin(), i * 0.1, eps);
1013      EXPECT_NEAR(prior_bboxes[i].ymin(), i * 0.1, eps);
1014      EXPECT_NEAR(prior_bboxes[i].xmax(), i * 0.1 + 0.2, eps);
1015      EXPECT_NEAR(prior_bboxes[i].ymax(), i * 0.1 + 0.1, eps);
1016      EXPECT_EQ(prior_variances[i].size(), 4);
1017      for (int j = 0; j &lt; 4; ++j) {
1018        EXPECT_NEAR(prior_variances[i][j], 0.1, eps);
1019      }
1020    }
1021  }
1022  TEST_F(CPUBBoxUtilTest, TestGetDetectionResults) {
1023    const int num = 4;
1024    const int num_det = (1 + num) * num / 2;
1025    Blob&lt;float&gt; det_blob(1, 1, num_det, 7);
1026    float* det_data = det_blob.mutable_cpu_data();
1027    int idx = 0;
1028    for (int i = 0; i &lt; num; ++i) {
1029      int image_id = ceil(i / 2.);
1030      for (int j = 0; j &lt;= i; ++j) {
1031        det_data[idx * 7] = image_id;
1032        det_data[idx * 7 + 1] = i;
1033        det_data[idx * 7 + 2] = 0;
1034        det_data[idx * 7 + 3] = 0.1 + j * 0.1;
1035        det_data[idx * 7 + 4] = 0.1 + j * 0.1;
1036        det_data[idx * 7 + 5] = 0.3 + j * 0.1;
1037        det_data[idx * 7 + 6] = 0.3 + j * 0.1;
1038        ++idx;
1039      }
1040    }
1041    CHECK_EQ(idx, num_det);
1042    map&lt;int, LabelBBox&gt; all_detections;
1043    GetDetectionResults(det_data, num_det, -1, &amp;all_detections);
1044    EXPECT_EQ(all_detections.size(), 3);
1045    EXPECT_EQ(all_detections[0].size(), 1);
1046    EXPECT_EQ(all_detections[0].find(0)-&gt;first, 0);
1047    EXPECT_EQ(all_detections[0].find(0)-&gt;second.size(), 1);
1048    EXPECT_NEAR(all_detections[0].find(0)-&gt;second[0].xmin(), 0.1, eps);
1049    EXPECT_NEAR(all_detections[0].find(0)-&gt;second[0].ymin(), 0.1, eps);
1050    EXPECT_NEAR(all_detections[0].find(0)-&gt;second[0].xmax(), 0.3, eps);
1051    EXPECT_NEAR(all_detections[0].find(0)-&gt;second[0].ymax(), 0.3, eps);
1052    EXPECT_NEAR(all_detections[0].find(0)-&gt;second[0].size(), 0.04, eps);
1053    EXPECT_EQ(all_detections[1].size(), 2);
1054    for (int i = 1; i &lt; 3; ++i) {
1055      EXPECT_EQ(all_detections[1].find(i)-&gt;first, i);
1056      EXPECT_EQ(all_detections[1].find(i)-&gt;second.size(), i + 1);
1057      for (int j = 0; j &lt;= i; ++j) {
1058        EXPECT_NEAR(all_detections[1].find(i)-&gt;second[j].xmin(),
1059                    0.1 + j * 0.1, eps);
1060        EXPECT_NEAR(all_detections[1].find(i)-&gt;second[j].ymin(),
1061                    0.1 + j * 0.1, eps);
1062        EXPECT_NEAR(all_detections[1].find(i)-&gt;second[j].xmax(),
1063                    0.3 + j * 0.1, eps);
1064        EXPECT_NEAR(all_detections[1].find(i)-&gt;second[j].ymax(),
1065                    0.3 + j * 0.1, eps);
1066        EXPECT_NEAR(all_detections[1].find(i)-&gt;second[j].size(), 0.04, eps);
1067      }
1068    }
1069    EXPECT_EQ(all_detections[2].size(), 1);
1070    EXPECT_EQ(all_detections[2].find(3)-&gt;first, 3);
1071    EXPECT_EQ(all_detections[2].find(3)-&gt;second.size(), 4);
1072    for (int j = 0; j &lt;= 3; ++j) {
1073      EXPECT_NEAR(all_detections[2].find(3)-&gt;second[j].xmin(),
1074                  0.1 + j * 0.1, eps);
1075      EXPECT_NEAR(all_detections[2].find(3)-&gt;second[j].ymin(),
1076                  0.1 + j * 0.1, eps);
1077      EXPECT_NEAR(all_detections[2].find(3)-&gt;second[j].xmax(),
1078                  0.3 + j * 0.1, eps);
1079      EXPECT_NEAR(all_detections[2].find(3)-&gt;second[j].ymax(),
1080                  0.3 + j * 0.1, eps);
1081      EXPECT_NEAR(all_detections[2].find(3)-&gt;second[j].size(), 0.04, eps);
1082    }
1083  }
1084  TEST_F(CPUBBoxUtilTest, TestApplyNMS) {
1085    vector&lt;NormalizedBBox&gt; bboxes;
1086    vector&lt;float&gt; scores;
1087    float nms_threshold = 0.3;
1088    int top_k = -1;
1089    bool reuse_overlaps = false;
1090    map&lt;int, map&lt;int, float&gt; &gt; overlaps;
1091    vector&lt;int&gt; indices;
1092    NormalizedBBox bbox;
1093    bbox.set_xmin(0.1);
1094    bbox.set_ymin(0.1);
1095    bbox.set_xmax(0.3);
1096    bbox.set_ymax(0.3);
1097    bboxes.push_back(bbox);
1098    scores.push_back(0.8);
1099    bbox.set_xmin(0.2);
1100    bbox.set_ymin(0.1);
1101    bbox.set_xmax(0.4);
1102    bbox.set_ymax(0.3);
1103    bboxes.push_back(bbox);
1104    scores.push_back(0.7);
1105    bbox.set_xmin(0.2);
1106    bbox.set_ymin(0.0);
1107    bbox.set_xmax(0.4);
1108    bbox.set_ymax(0.2);
1109    bboxes.push_back(bbox);
1110    scores.push_back(0.4);
1111    bbox.set_xmin(0.1);
1112    bbox.set_ymin(0.2);
1113    bbox.set_xmax(0.4);
1114    bbox.set_ymax(0.4);
1115    bboxes.push_back(bbox);
1116    scores.push_back(0.5);
1117    ApplyNMS(bboxes, scores, nms_threshold, top_k, reuse_overlaps, &amp;overlaps,
1118             &amp;indices);
1119    EXPECT_EQ(overlaps.size(), 0);  
1120    EXPECT_EQ(indices.size(), 3);
1121    EXPECT_EQ(indices[0], 0);
1122    EXPECT_EQ(indices[1], 3);
1123    EXPECT_EQ(indices[2], 2);
1124    top_k = 2;
1125    ApplyNMS(bboxes, scores, nms_threshold, top_k, reuse_overlaps, &amp;overlaps,
1126             &amp;indices);
1127    EXPECT_EQ(indices.size(), 1);
1128    EXPECT_EQ(indices[0], 0);
1129    top_k = 3;
1130    nms_threshold = 0.2;
1131    ApplyNMS(bboxes, scores, nms_threshold, top_k, reuse_overlaps, &amp;overlaps,
1132             &amp;indices);
1133    EXPECT_EQ(indices.size(), 1);
1134    EXPECT_EQ(indices[0], 0);
1135    reuse_overlaps = true;
1136    ApplyNMS(bboxes, scores, nms_threshold, top_k, reuse_overlaps, &amp;overlaps,
1137             &amp;indices);
1138    EXPECT_EQ(overlaps.size(), 1);
1139    EXPECT_NEAR(overlaps[0][1], 1./3, eps);
1140    EXPECT_NEAR(overlaps[0][2], 0.0, eps);
1141    EXPECT_NEAR(overlaps[0][3], 2./8, eps);
1142    map&lt;int, map&lt;int, float&gt; &gt; old_overlaps = overlaps;
1143    ApplyNMS(bboxes, scores, nms_threshold, top_k, reuse_overlaps, &amp;overlaps,
1144             &amp;indices);
1145    EXPECT_EQ(old_overlaps.size(), overlaps.size());
1146    for (int i = 1; i &lt;= 3; ++i) {
1147      EXPECT_NEAR(old_overlaps[0][i], overlaps[0][i], eps);
1148    }
1149  }
1150  TEST_F(CPUBBoxUtilTest, TestApplyNMSFast) {
1151    vector&lt;NormalizedBBox&gt; bboxes;
1152    vector&lt;float&gt; scores;
1153    float score_threshold = 0.;
1154    float nms_threshold = 0.3;
1155    float eta = 1.;
1156    int top_k = -1;
1157    vector&lt;int&gt; indices;
1158    NormalizedBBox bbox;
1159    bbox.set_xmin(0.1);
1160    bbox.set_ymin(0.1);
1161    bbox.set_xmax(0.3);
1162    bbox.set_ymax(0.3);
1163    bboxes.push_back(bbox);
1164    scores.push_back(0.8);
1165    bbox.set_xmin(0.2);
1166    bbox.set_ymin(0.1);
1167    bbox.set_xmax(0.4);
1168    bbox.set_ymax(0.3);
1169    bboxes.push_back(bbox);
1170    scores.push_back(0.7);
1171    bbox.set_xmin(0.2);
1172    bbox.set_ymin(0.0);
1173    bbox.set_xmax(0.4);
1174    bbox.set_ymax(0.2);
1175    bboxes.push_back(bbox);
1176    scores.push_back(0.4);
1177    bbox.set_xmin(0.1);
1178    bbox.set_ymin(0.2);
1179    bbox.set_xmax(0.4);
1180    bbox.set_ymax(0.4);
1181    bboxes.push_back(bbox);
1182    scores.push_back(0.5);
1183    ApplyNMSFast(bboxes, scores, score_threshold, nms_threshold, eta, top_k,
1184                 &amp;indices);
1185    EXPECT_EQ(indices.size(), 3);
1186    EXPECT_EQ(indices[0], 0);
1187    EXPECT_EQ(indices[1], 3);
1188    EXPECT_EQ(indices[2], 2);
1189    top_k = 2;
1190    ApplyNMSFast(bboxes, scores, score_threshold, nms_threshold, eta, top_k,
1191                 &amp;indices);
1192    EXPECT_EQ(indices.size(), 1);
1193    EXPECT_EQ(indices[0], 0);
1194    top_k = 3;
1195    nms_threshold = 0.2;
1196    ApplyNMSFast(bboxes, scores, score_threshold, nms_threshold, eta, top_k,
1197                 &amp;indices);
1198    EXPECT_EQ(indices.size(), 1);
1199    EXPECT_EQ(indices[0], 0);
1200    top_k = -1;
1201    score_threshold = 0.5;
1202    ApplyNMSFast(bboxes, scores, score_threshold, nms_threshold, eta, top_k,
1203                 &amp;indices);
1204    EXPECT_EQ(indices.size(), 1);
1205    EXPECT_EQ(indices[0], 0);
1206  }
1207  TEST_F(CPUBBoxUtilTest, TestCumSum) {
1208    vector&lt;pair&lt;float, int&gt; &gt; pairs;
1209    vector&lt;int&gt; cumsum;
1210    pairs.push_back(std::make_pair(0.1, 0));
1211    pairs.push_back(std::make_pair(0.2, 1));
1212    pairs.push_back(std::make_pair(0.3, 0));
1213    CumSum(pairs, &amp;cumsum);
1214    EXPECT_EQ(cumsum.size(), 3);
1215    EXPECT_EQ(cumsum[0], 0);
1216    EXPECT_EQ(cumsum[1], 1);
1217    EXPECT_EQ(cumsum[2], 1);
1218  }
1219  TEST_F(CPUBBoxUtilTest, TestComputeAP) {
1220    vector&lt;pair&lt;float, int&gt; &gt; tp;
1221    vector&lt;pair&lt;float, int&gt; &gt; fp;
1222    tp.push_back(std::make_pair(1.0, 0));
1223    tp.push_back(std::make_pair(1.0, 1));
1224    tp.push_back(std::make_pair(0.9, 1));
1225    tp.push_back(std::make_pair(0.9, 0));
1226    tp.push_back(std::make_pair(0.8, 1));
1227    tp.push_back(std::make_pair(0.7, 0));
1228    tp.push_back(std::make_pair(0.7, 1));
1229    tp.push_back(std::make_pair(0.6, 0));
1230    tp.push_back(std::make_pair(0.5, 0));
1231    tp.push_back(std::make_pair(0.4, 0));
1232    tp.push_back(std::make_pair(0.4, 1));
1233    fp.push_back(std::make_pair(1.0, 1));
1234    fp.push_back(std::make_pair(1.0, 0));
1235    fp.push_back(std::make_pair(0.9, 0));
1236    fp.push_back(std::make_pair(0.9, 1));
1237    fp.push_back(std::make_pair(0.8, 0));
1238    fp.push_back(std::make_pair(0.7, 1));
1239    fp.push_back(std::make_pair(0.7, 0));
1240    fp.push_back(std::make_pair(0.6, 1));
1241    fp.push_back(std::make_pair(0.5, 1));
1242    fp.push_back(std::make_pair(0.4, 1));
1243    fp.push_back(std::make_pair(0.4, 0));
1244    float eps = 1e-5;
1245    vector&lt;float&gt; prec, rec;
1246    float ap;
1247    ComputeAP(tp, 5, fp, &quot;Integral&quot;, &amp;prec, &amp;rec, &amp;ap);
1248    EXPECT_NEAR(ap, 0.558528, eps);
1249    EXPECT_EQ(prec.size(), 11);
1250    EXPECT_NEAR(prec[0], 0.0/1.0, eps);
1251    EXPECT_NEAR(prec[1], 1.0/2.0, eps);
1252    EXPECT_NEAR(prec[2], 2.0/3.0, eps);
1253    EXPECT_NEAR(prec[3], 2.0/4.0, eps);
1254    EXPECT_NEAR(prec[4], 3.0/5.0, eps);
1255    EXPECT_NEAR(prec[5], 3.0/6.0, eps);
1256    EXPECT_NEAR(prec[6], 4.0/7.0, eps);
1257    EXPECT_NEAR(prec[7], 4.0/8.0, eps);
1258    EXPECT_NEAR(prec[8], 4.0/9.0, eps);
1259    EXPECT_NEAR(prec[9], 4.0/10.0, eps);
1260    EXPECT_NEAR(prec[10], 5.0/11.0, eps);
1261    EXPECT_EQ(rec.size(), 11);
1262    EXPECT_NEAR(rec[0], 0.0, eps);
1263    EXPECT_NEAR(rec[1], 0.2, eps);
1264    EXPECT_NEAR(rec[2], 0.4, eps);
1265    EXPECT_NEAR(rec[3], 0.4, eps);
1266    EXPECT_NEAR(rec[4], 0.6, eps);
1267    EXPECT_NEAR(rec[5], 0.6, eps);
1268    EXPECT_NEAR(rec[6], 0.8, eps);
1269    EXPECT_NEAR(rec[7], 0.8, eps);
1270    EXPECT_NEAR(rec[8], 0.8, eps);
1271    EXPECT_NEAR(rec[9], 0.8, eps);
1272    EXPECT_NEAR(rec[10], 1.0, eps);
1273    vector&lt;float&gt; prec_old = prec;
1274    vector&lt;float&gt; rec_old = rec;
1275    ComputeAP(tp, 5, fp, &quot;MaxIntegral&quot;, &amp;prec, &amp;rec, &amp;ap);
1276    EXPECT_NEAR(ap, 0.591861, eps);
1277    EXPECT_EQ(prec.size(), 11);
1278    EXPECT_EQ(rec.size(), 11);
1279    for (int i = 0; i &lt; 11; ++i) {
1280      EXPECT_NEAR(prec_old[i], prec[i], eps);
1281      EXPECT_NEAR(rec_old[i], rec[i], eps);
1282    }
1283    ComputeAP(tp, 5, fp, &quot;11point&quot;, &amp;prec, &amp;rec, &amp;ap);
1284    EXPECT_NEAR(ap, 0.598662, eps);
1285    EXPECT_EQ(prec.size(), 11);
1286    EXPECT_EQ(rec.size(), 11);
1287    for (int i = 0; i &lt; 11; ++i) {
1288      EXPECT_NEAR(prec_old[i], prec[i], eps);
1289      EXPECT_NEAR(rec_old[i], rec[i], eps);
1290    }
1291    tp.resize(7);
1292    fp.resize(7);
1293    ComputeAP(tp, 5, fp, &quot;Integral&quot;, &amp;prec, &amp;rec, &amp;ap);
1294    EXPECT_NEAR(ap, 0.558528 - prec_old.back() * 0.2, eps);
1295    EXPECT_EQ(prec.size(), 7);
1296    EXPECT_EQ(rec.size(), 7);
1297    for (int i = 0; i &lt; 7; ++i) {
1298      EXPECT_NEAR(prec_old[i], prec[i], eps);
1299      EXPECT_NEAR(rec_old[i], rec[i], eps);
1300    }
1301    ComputeAP(tp, 5, fp, &quot;MaxIntegral&quot;, &amp;prec, &amp;rec, &amp;ap);
1302    EXPECT_NEAR(ap, 0.591861 - prec_old.back() * 0.2, eps);
1303    EXPECT_EQ(prec.size(), 7);
1304    EXPECT_EQ(rec.size(), 7);
1305    for (int i = 0; i &lt; 7; ++i) {
1306      EXPECT_NEAR(prec_old[i], prec[i], eps);
1307      EXPECT_NEAR(rec_old[i], rec[i], eps);
1308    }
1309    ComputeAP(tp, 5, fp, &quot;11point&quot;, &amp;prec, &amp;rec, &amp;ap);
1310    EXPECT_NEAR(ap, 0.598662 - prec_old.back() * 2 / 11., eps);
1311    EXPECT_EQ(prec.size(), 7);
1312    EXPECT_EQ(rec.size(), 7);
1313    for (int i = 0; i &lt; 7; ++i) {
1314      EXPECT_NEAR(prec_old[i], prec[i], eps);
1315      EXPECT_NEAR(rec_old[i], rec[i], eps);
1316    }
1317  }
1318  #ifndef CPU_ONLY
1319  template &lt;typename Dtype&gt;
1320  void FillBBoxes(Dtype* gt_bboxes, Dtype* pred_bboxes) {
1321  }
1322  template &lt;typename Dtype&gt;
1323  class GPUBBoxUtilTest : public BBoxUtilTest&lt;GPUDevice&lt;Dtype&gt; &gt; {
1324  };
1325  TYPED_TEST_CASE(GPUBBoxUtilTest, TestDtypes);
<span onclick='openModal()' class='match'>1326  TYPED_TEST(GPUBBoxUtilTest, TestBBoxSize) {
1327    float size;
1328    Blob&lt;TypeParam&gt; bbox(1, 1, 1, 4);
1329    TypeParam* bbox_data = bbox.mutable_cpu_data();
1330    bbox_data[0] = 0.2;
1331    bbox_data[1] = 0.3;
1332    bbox_data[2] = 0.3;
1333    bbox_data[3] = 0.5;
1334    size = BBoxSizeGPU(bbox_data);
</span>1335    EXPECT_NEAR(size, 0.02, eps);
1336    bbox_data[2] = 0.2;
1337    size = BBoxSizeGPU(bbox_data);
1338    EXPECT_NEAR(size, 0., eps);
1339    bbox_data[2] = 0.1;
1340    size = BBoxSizeGPU(bbox_data);
1341    EXPECT_NEAR(size, 0., eps);
1342  }
1343  TYPED_TEST(GPUBBoxUtilTest, TestJaccardOverlap) {
1344    float overlap;
1345    Blob&lt;TypeParam&gt; bbox1(1, 1, 1, 4);
1346    TypeParam* bbox1_data = bbox1.mutable_cpu_data();
1347    bbox1_data[0] = 0.2;
1348    bbox1_data[1] = 0.3;
1349    bbox1_data[2] = 0.3;
1350    bbox1_data[3] = 0.5;
1351    Blob&lt;TypeParam&gt; bbox2(1, 1, 1, 4);
1352    TypeParam* bbox2_data = bbox2.mutable_cpu_data();
1353    bbox2_data[0] = 0.1;
1354    bbox2_data[1] = 0.1;
1355    bbox2_data[2] = 0.3;
1356    bbox2_data[3] = 0.4;
1357    overlap = JaccardOverlapGPU(bbox1_data, bbox2_data);
1358    EXPECT_NEAR(overlap, 1./7, eps);
1359    bbox2_data[0] = 0.1;
1360    bbox2_data[1] = 0.1;
1361    bbox2_data[2] = 0.4;
1362    bbox2_data[3] = 0.6;
1363    overlap = JaccardOverlapGPU(bbox1_data, bbox2_data);
1364    EXPECT_NEAR(overlap, 2./15, eps);
1365    bbox2_data[0] = 0.;
1366    bbox2_data[1] = 0.;
1367    bbox2_data[2] = 0.1;
1368    bbox2_data[3] = 0.1;
1369    overlap = JaccardOverlapGPU(bbox1_data, bbox2_data);
1370    EXPECT_NEAR(overlap, 0., eps);
1371  }
1372  TYPED_TEST(GPUBBoxUtilTest, TestDecodeBBoxesCorner) {
1373    int num = 4;
1374    Blob&lt;TypeParam&gt; prior_bboxes(1, 2, num * 4, 1);
1375    TypeParam* prior_data = prior_bboxes.mutable_cpu_data();
1376    Blob&lt;TypeParam&gt; loc_preds(1, num * 4, 1, 1);
1377    TypeParam* loc_data = loc_preds.mutable_cpu_data();
1378    for (int i = 1; i &lt;= num; ++i) {
1379      prior_data[(i - 1) * 4] = 0.1 * i;
1380      prior_data[(i - 1) * 4 + 1] = 0.1 * i;
1381      prior_data[(i - 1) * 4 + 2] = 0.1 * i + 0.2;
1382      prior_data[(i - 1) * 4 + 3] = 0.1 * i + 0.2;
1383      for (int j = 0; j &lt; 4; ++j) {
1384        prior_data[num * 4 + (i - 1) * 4 + j] = 0.1;
1385      }
1386      loc_data[(i - 1) * 4] = -1 * (i % 2);
1387      loc_data[(i - 1) * 4 + 1] = ((i + 1) % 2);
1388      loc_data[(i - 1) * 4 + 2] = ((i + 1) % 2);
1389      loc_data[(i - 1) * 4 + 3] = i % 2;
1390    }
1391    CodeType code_type = PriorBoxParameter_CodeType_CORNER;
1392    Blob&lt;TypeParam&gt; bboxes(1, num * 4, 1, 1);
1393    TypeParam* bbox_data = bboxes.mutable_gpu_data();
1394    bool variance_encoded_in_target = false;
1395    DecodeBBoxesGPU(num * 4, loc_data, prior_data, code_type,
1396                    variance_encoded_in_target, num, false, 1, -1, false,
1397                    bbox_data);
1398    TypeParam* bbox_cpu_data = bboxes.mutable_cpu_data();
1399    for (int i = 1; i &lt;= num; ++i) {
1400      EXPECT_NEAR(bbox_cpu_data[(i - 1) * 4], 0.1*i + i%2 * -0.1, eps);
1401      EXPECT_NEAR(bbox_cpu_data[(i - 1) * 4 + 1], 0.1*i + (i+1)%2 * 0.1, eps);
1402      EXPECT_NEAR(bbox_cpu_data[(i - 1) * 4 + 2],
1403                  0.1*i + 0.2 + (i+1)%2 * 0.1, eps);
1404      EXPECT_NEAR(bbox_cpu_data[(i - 1) * 4 + 3], 0.1*i + 0.2 + i%2 * 0.1, eps);
1405    }
1406    variance_encoded_in_target = true;
1407    bbox_data = bboxes.mutable_gpu_data();
1408    DecodeBBoxesGPU(num * 4, loc_data, prior_data, code_type,
1409                    variance_encoded_in_target, num, false, 1, -1, false,
1410                    bbox_data);
1411    bbox_cpu_data = bboxes.mutable_cpu_data();
1412    for (int i = 1; i &lt;= num; ++i) {
1413      EXPECT_NEAR(bbox_cpu_data[(i - 1) * 4], 0.1*i + i%2 * -1, eps);
1414      EXPECT_NEAR(bbox_cpu_data[(i - 1) * 4 + 1], 0.1*i + (i+1)%2, eps);
1415      EXPECT_NEAR(bbox_cpu_data[(i - 1) * 4 + 2], 0.1*i + 0.2 + (i+1)%2, eps);
1416      EXPECT_NEAR(bbox_cpu_data[(i - 1) * 4 + 3], 0.1*i + 0.2 + i%2, eps);
1417    }
1418  }
1419  TYPED_TEST(GPUBBoxUtilTest, TestDecodeBBoxesCornerTwoClasses) {
1420    int num = 4;
1421    int num_loc_classes = 2;
1422    Blob&lt;TypeParam&gt; prior_bboxes(1, 2, num * 4, 1);
1423    TypeParam* prior_data = prior_bboxes.mutable_cpu_data();
1424    Blob&lt;TypeParam&gt; loc_preds(1, num * num_loc_classes * 4, 1, 1);
1425    TypeParam* loc_data = loc_preds.mutable_cpu_data();
1426    for (int i = 1; i &lt;= num; ++i) {
1427      prior_data[(i - 1) * 4] = 0.1 * i;
1428      prior_data[(i - 1) * 4 + 1] = 0.1 * i;
1429      prior_data[(i - 1) * 4 + 2] = 0.1 * i + 0.2;
1430      prior_data[(i - 1) * 4 + 3] = 0.1 * i + 0.2;
1431      for (int j = 0; j &lt; 4; ++j) {
1432        prior_data[num * 4 + (i - 1) * 4 + j] = 0.1;
1433      }
1434      for (int j = 0; j &lt; num_loc_classes; ++j) {
1435        loc_data[((i - 1) * 2 + j) * 4] = -1 * (i % 2) * (2 - j);
1436        loc_data[((i - 1) * 2 + j) * 4 + 1] = ((i + 1) % 2) * (2 - j);
1437        loc_data[((i - 1) * 2 + j) * 4 + 2] = ((i + 1) % 2) * (2 - j);
1438        loc_data[((i - 1) * 2 + j) * 4 + 3] = i % 2 * (2 - j);
1439      }
1440    }
1441    CodeType code_type = PriorBoxParameter_CodeType_CORNER;
1442    Blob&lt;TypeParam&gt; bboxes(1, num * num_loc_classes * 4, 1, 1);
1443    TypeParam* bbox_data = bboxes.mutable_gpu_data();
1444    bool variance_encoded_in_target = false;
1445    DecodeBBoxesGPU(num * num_loc_classes * 4, loc_data, prior_data, code_type,
1446                    variance_encoded_in_target, num, false, num_loc_classes, -1,
1447                    false, bbox_data);
1448    TypeParam* bbox_cpu_data = bboxes.mutable_cpu_data();
1449    for (int i = 1; i &lt;= num; ++i) {
1450      for (int j = 0; j &lt; num_loc_classes; ++j) {
1451        EXPECT_NEAR(bbox_cpu_data[((i - 1) * 2 + j) * 4],
1452                    0.1*i + i%2 * (2-j) * -0.1, eps);
1453        EXPECT_NEAR(bbox_cpu_data[((i - 1) * 2 + j) * 4 + 1],
1454                    0.1*i + (i+1)%2 * (2-j) * 0.1, eps);
1455        EXPECT_NEAR(bbox_cpu_data[((i - 1) * 2 + j) * 4 + 2],
1456                    0.1*i + 0.2 + (i+1)%2 * (2-j) * 0.1, eps);
1457        EXPECT_NEAR(bbox_cpu_data[((i - 1) * 2 + j) * 4 + 3],
1458                    0.1*i + 0.2 + i%2 * (2-j) * 0.1, eps);
1459      }
1460    }
1461    variance_encoded_in_target = true;
1462    bbox_data = bboxes.mutable_gpu_data();
1463    DecodeBBoxesGPU(num * num_loc_classes * 4, loc_data, prior_data, code_type,
1464                    variance_encoded_in_target, num, false, num_loc_classes, -1,
1465                    false, bbox_data);
1466    bbox_cpu_data = bboxes.mutable_cpu_data();
1467    for (int i = 1; i &lt;= num; ++i) {
1468      for (int j = 0; j &lt; num_loc_classes; ++j) {
1469        EXPECT_NEAR(bbox_cpu_data[((i - 1) * 2 + j) * 4],
1470                    0.1*i + i%2 * (2-j) * -1, eps);
1471        EXPECT_NEAR(bbox_cpu_data[((i - 1) * 2 + j) * 4 + 1],
1472                    0.1*i + (i+1)%2 * (2-j), eps);
1473        EXPECT_NEAR(bbox_cpu_data[((i - 1) * 2 + j) * 4 + 2],
1474                    0.1*i + 0.2 + (i+1)%2 * (2-j), eps);
1475        EXPECT_NEAR(bbox_cpu_data[((i - 1) * 2 + j) * 4 + 3],
1476                    0.1*i + 0.2 + i%2 * (2-j), eps);
1477      }
1478    }
1479  }
1480  TYPED_TEST(GPUBBoxUtilTest, TestDecodeBBoxesCornerTwoClassesNegClass0) {
1481    int num = 4;
1482    int num_loc_classes = 2;
1483    Blob&lt;TypeParam&gt; prior_bboxes(1, 2, num * 4, 1);
1484    TypeParam* prior_data = prior_bboxes.mutable_cpu_data();
1485    Blob&lt;TypeParam&gt; loc_preds(1, num * num_loc_classes * 4, 1, 1);
1486    TypeParam* loc_data = loc_preds.mutable_cpu_data();
1487    for (int i = 1; i &lt;= num; ++i) {
1488      prior_data[(i - 1) * 4] = 0.1 * i;
1489      prior_data[(i - 1) * 4 + 1] = 0.1 * i;
1490      prior_data[(i - 1) * 4 + 2] = 0.1 * i + 0.2;
1491      prior_data[(i - 1) * 4 + 3] = 0.1 * i + 0.2;
1492      for (int j = 0; j &lt; 4; ++j) {
1493        prior_data[num * 4 + (i - 1) * 4 + j] = 0.1;
1494      }
1495      for (int j = 0; j &lt; num_loc_classes; ++j) {
1496        loc_data[((i - 1) * 2 + j) * 4] = -1 * (i % 2) * (2 - j);
1497        loc_data[((i - 1) * 2 + j) * 4 + 1] = ((i + 1) % 2) * (2 - j);
1498        loc_data[((i - 1) * 2 + j) * 4 + 2] = ((i + 1) % 2) * (2 - j);
1499        loc_data[((i - 1) * 2 + j) * 4 + 3] = i % 2 * (2 - j);
1500      }
1501    }
1502    CodeType code_type = PriorBoxParameter_CodeType_CORNER;
1503    Blob&lt;TypeParam&gt; bboxes(1, num * num_loc_classes * 4, 1, 1);
1504    TypeParam* bbox_data = bboxes.mutable_gpu_data();
1505    bool variance_encoded_in_target = false;
1506    DecodeBBoxesGPU(num * num_loc_classes * 4, loc_data, prior_data, code_type,
1507                    variance_encoded_in_target, num, false, num_loc_classes, 0,
1508                    false, bbox_data);
1509    TypeParam* bbox_cpu_data = bboxes.mutable_cpu_data();
1510    for (int i = 1; i &lt;= num; ++i) {
1511      for (int j = 0; j &lt; num_loc_classes; ++j) {
1512        if (j == 0) {
1513          for (int k = 0; k &lt; 4; ++k) {
1514            EXPECT_NEAR(bbox_cpu_data[(i - 1) * 2 * 4 + k], 0., eps);
1515          }
1516        } else {
1517          EXPECT_NEAR(bbox_cpu_data[((i - 1) * 2 + j) * 4],
1518                      0.1*i + i%2 * -0.1, eps);
1519          EXPECT_NEAR(bbox_cpu_data[((i - 1) * 2 + j) * 4 + 1],
1520                      0.1*i + (i+1)%2 * 0.1, eps);
1521          EXPECT_NEAR(bbox_cpu_data[((i - 1) * 2 + j) * 4 + 2],
1522                      0.1*i + 0.2 + (i+1)%2 * 0.1, eps);
1523          EXPECT_NEAR(bbox_cpu_data[((i - 1) * 2 + j) * 4 + 3],
1524                      0.1*i + 0.2 + i%2 * 0.1, eps);
1525        }
1526      }
1527    }
1528    variance_encoded_in_target = true;
1529    bbox_data = bboxes.mutable_gpu_data();
1530    DecodeBBoxesGPU(num * num_loc_classes * 4, loc_data, prior_data, code_type,
1531                    variance_encoded_in_target, num, false, num_loc_classes, 0,
1532                    false, bbox_data);
1533    bbox_cpu_data = bboxes.mutable_cpu_data();
1534    for (int i = 1; i &lt;= num; ++i) {
1535      for (int j = 0; j &lt; num_loc_classes; ++j) {
1536        if (j == 0) {
1537          for (int k = 0; k &lt; 4; ++k) {
1538            EXPECT_NEAR(bbox_cpu_data[(i - 1) * 2 * 4 + k], 0., eps);
1539          }
1540        } else {
1541          EXPECT_NEAR(bbox_cpu_data[((i - 1) * 2 + j) * 4],
1542                      0.1*i + i%2 * -1, eps);
1543          EXPECT_NEAR(bbox_cpu_data[((i - 1) * 2 + j) * 4 + 1],
1544                      0.1*i + (i+1)%2, eps);
1545          EXPECT_NEAR(bbox_cpu_data[((i - 1) * 2 + j) * 4 + 2],
1546                      0.1*i + 0.2 + (i+1)%2, eps);
1547          EXPECT_NEAR(bbox_cpu_data[((i - 1) * 2 + j) * 4 + 3],
1548                      0.1*i + 0.2 + i%2, eps);
1549        }
1550      }
1551    }
1552  }
1553  TYPED_TEST(GPUBBoxUtilTest, TestDecodeBBoxesCenterSize) {
1554    int num = 2;
1555    Blob&lt;TypeParam&gt; prior_bboxes(1, 2, num * 4, 1);
1556    TypeParam* prior_data = prior_bboxes.mutable_cpu_data();
1557    Blob&lt;TypeParam&gt; loc_preds(1, num * 4, 1, 1);
1558    TypeParam* loc_data = loc_preds.mutable_cpu_data();
1559    for (int i = 1; i &lt;= num; ++i) {
1560      prior_data[(i - 1) * 4] = 0.1 * i;
1561      prior_data[(i - 1) * 4 + 1] = 0.1 * i;
1562      prior_data[(i - 1) * 4 + 2] = 0.1 * i + 0.2;
1563      prior_data[(i - 1) * 4 + 3] = 0.1 * i + 0.2;
1564      prior_data[num * 4 + (i - 1) * 4] = 0.1;
1565      prior_data[num * 4 + (i - 1) * 4 + 1] = 0.1;
1566      prior_data[num * 4 + (i - 1) * 4 + 2] = 0.2;
1567      prior_data[num * 4 + (i - 1) * 4 + 3] = 0.2;
1568      loc_data[(i - 1) * 4] = 0;
1569      loc_data[(i - 1) * 4 + 1] = 0.75;
1570      loc_data[(i - 1) * 4 + 2] = log(2.);
1571      loc_data[(i - 1) * 4 + 3] = log(3./2);
1572    }
1573    CodeType code_type = PriorBoxParameter_CodeType_CENTER_SIZE;
1574    Blob&lt;TypeParam&gt; bboxes(1, num * 4, 1, 1);
1575    TypeParam* bbox_data = bboxes.mutable_gpu_data();
1576    bool variance_encoded_in_target = true;
1577    DecodeBBoxesGPU(num * 4, loc_data, prior_data, code_type,
1578                    variance_encoded_in_target, num, false, 1, -1, false,
1579                    bbox_data);
1580    TypeParam* bbox_cpu_data = bboxes.mutable_cpu_data();
1581    for (int i = 1; i &lt;= num; ++i) {
1582      EXPECT_NEAR(bbox_cpu_data[(i - 1) * 4], 0 + (i-1) * 0.1, eps);
1583      EXPECT_NEAR(bbox_cpu_data[(i - 1) * 4 + 1], 0.2 + (i-1) * 0.1, eps);
1584      EXPECT_NEAR(bbox_cpu_data[(i - 1) * 4 + 2], 0.4 + (i-1) * 0.1, eps);
1585      EXPECT_NEAR(bbox_cpu_data[(i - 1) * 4 + 3], 0.5 + (i-1) * 0.1, eps);
1586    }
1587    variance_encoded_in_target = false;
1588    for (int i = 1; i &lt;= num; ++i) {
1589      loc_data[(i - 1) * 4] = 0;
1590      loc_data[(i - 1) * 4 + 1] = 7.5;
1591      loc_data[(i - 1) * 4 + 2] = log(2.) * 5;
1592      loc_data[(i - 1) * 4 + 3] = log(3./2) * 5;
1593    }
1594    bbox_data = bboxes.mutable_gpu_data();
1595    DecodeBBoxesGPU(num * 4, loc_data, prior_data, code_type,
1596                    variance_encoded_in_target, num, false, 1, -1, false,
1597                    bbox_data);
1598    bbox_cpu_data = bboxes.mutable_cpu_data();
1599    for (int i = 1; i &lt;= num; ++i) {
1600      EXPECT_NEAR(bbox_cpu_data[(i - 1) * 4], 0 + (i-1) * 0.1, eps);
1601      EXPECT_NEAR(bbox_cpu_data[(i - 1) * 4 + 1], 0.2 + (i-1) * 0.1, eps);
1602      EXPECT_NEAR(bbox_cpu_data[(i - 1) * 4 + 2], 0.4 + (i-1) * 0.1, eps);
1603      EXPECT_NEAR(bbox_cpu_data[(i - 1) * 4 + 3], 0.5 + (i-1) * 0.1, eps);
1604    }
1605  }
1606  TYPED_TEST(GPUBBoxUtilTest, TestComputeOverlapped) {
1607    const int num = 2;
1608    const int num_bboxes = 2;
1609    const int num_loc_classes = 1;
1610    const TypeParam overlap_threshold = 0.3;
1611    Blob&lt;TypeParam&gt; bboxes(num, num_bboxes * num_loc_classes * 4, 1, 1);
1612    TypeParam* bbox_data = bboxes.mutable_cpu_data();
1613    bbox_data[0] = 0.1;
1614    bbox_data[1] = 0.1;
1615    bbox_data[2] = 0.3;
1616    bbox_data[3] = 0.3;
1617    bbox_data[4] = 0.2;
1618    bbox_data[5] = 0.1;
1619    bbox_data[6] = 0.4;
1620    bbox_data[7] = 0.3;
1621    bbox_data[8] = 0.2;
1622    bbox_data[9] = 0.0;
1623    bbox_data[10] = 0.4;
1624    bbox_data[11] = 0.2;
1625    bbox_data[12] = 0.2;
1626    bbox_data[13] = 0.1;
1627    bbox_data[14] = 0.4;
1628    bbox_data[15] = 0.3;
1629    Blob&lt;bool&gt; overlapped(num, num_loc_classes, num_bboxes, num_bboxes);
1630    const int total_bboxes = overlapped.count();
1631    bool* overlapped_data = overlapped.mutable_gpu_data();
1632    ComputeOverlappedGPU(total_bboxes, bbox_data, num_bboxes, num_loc_classes,
1633                         overlap_threshold, overlapped_data);
1634    const bool* overlapped_cpu_data = overlapped.cpu_data();
1635    EXPECT_EQ(overlapped_cpu_data[0], 0);
1636    EXPECT_EQ(overlapped_cpu_data[1], 1);
1637    EXPECT_EQ(overlapped_cpu_data[2], 1);
1638    EXPECT_EQ(overlapped_cpu_data[3], 0);
1639    EXPECT_EQ(overlapped_cpu_data[4], 0);
1640    EXPECT_EQ(overlapped_cpu_data[5], 1);
1641    EXPECT_EQ(overlapped_cpu_data[6], 1);
1642    EXPECT_EQ(overlapped_cpu_data[7], 0);
1643  }
1644  TYPED_TEST(GPUBBoxUtilTest, TestComputeOverlappedMultiClass) {
1645    const int num = 2;
1646    const int num_bboxes = 2;
1647    const int num_loc_classes = 2;
1648    const TypeParam overlap_threshold = 0.3;
1649    Blob&lt;TypeParam&gt; bboxes(num, num_bboxes * num_loc_classes * 4, 1, 1);
1650    TypeParam* bbox_data = bboxes.mutable_cpu_data();
1651    bbox_data[0] = 0.1;
1652    bbox_data[1] = 0.1;
1653    bbox_data[2] = 0.3;
1654    bbox_data[3] = 0.3;
1655    bbox_data[4] = 0.0;
1656    bbox_data[5] = 0.1;
1657    bbox_data[6] = 0.2;
1658    bbox_data[7] = 0.3;
1659    bbox_data[8] = 0.2;
1660    bbox_data[9] = 0.1;
1661    bbox_data[10] = 0.4;
1662    bbox_data[11] = 0.3;
1663    bbox_data[12] = 0.2;
1664    bbox_data[13] = 0.1;
1665    bbox_data[14] = 0.4;
1666    bbox_data[15] = 0.3;
1667    bbox_data[16] = 0.2;
1668    bbox_data[17] = 0.0;
1669    bbox_data[18] = 0.4;
1670    bbox_data[19] = 0.2;
1671    bbox_data[20] = 0.2;
1672    bbox_data[21] = 0.1;
1673    bbox_data[22] = 0.4;
1674    bbox_data[23] = 0.3;
1675    bbox_data[24] = 0.1;
1676    bbox_data[25] = 0.1;
1677    bbox_data[26] = 0.3;
1678    bbox_data[27] = 0.3;
1679    bbox_data[28] = 0.1;
1680    bbox_data[29] = 0.1;
1681    bbox_data[30] = 0.3;
1682    bbox_data[31] = 0.3;
1683    Blob&lt;bool&gt; overlapped(num, num_loc_classes, num_bboxes, num_bboxes);
1684    const int total_bboxes = overlapped.count();
1685    bool* overlapped_data = overlapped.mutable_gpu_data();
1686    ComputeOverlappedGPU(total_bboxes, bbox_data, num_bboxes, num_loc_classes,
1687                         overlap_threshold, overlapped_data);
1688    const bool* overlapped_cpu_data = overlapped.cpu_data();
1689    EXPECT_EQ(overlapped_cpu_data[0], 0);
1690    EXPECT_EQ(overlapped_cpu_data[1], 1);
1691    EXPECT_EQ(overlapped_cpu_data[2], 1);
1692    EXPECT_EQ(overlapped_cpu_data[3], 0);
1693    EXPECT_EQ(overlapped_cpu_data[4], 0);
1694    EXPECT_EQ(overlapped_cpu_data[5], 0);
1695    EXPECT_EQ(overlapped_cpu_data[6], 0);
1696    EXPECT_EQ(overlapped_cpu_data[7], 0);
1697    EXPECT_EQ(overlapped_cpu_data[8], 0);
1698    EXPECT_EQ(overlapped_cpu_data[9], 0);
1699    EXPECT_EQ(overlapped_cpu_data[10], 0);
1700    EXPECT_EQ(overlapped_cpu_data[11], 0);
1701    EXPECT_EQ(overlapped_cpu_data[12], 0);
1702    EXPECT_EQ(overlapped_cpu_data[13], 1);
1703    EXPECT_EQ(overlapped_cpu_data[14], 1);
1704    EXPECT_EQ(overlapped_cpu_data[15], 0);
1705  }
1706  TYPED_TEST(GPUBBoxUtilTest, TestSoftMaxGPU) {
1707    const int num = 2;
1708    const int num_preds = 2;
1709    const int num_classes = 2;
1710    Blob&lt;TypeParam&gt; data_blob(num, num_preds * num_classes, 1, 1);
1711    Blob&lt;TypeParam&gt; prob_blob(num, num_preds * num_classes, 1, 1);
1712    TypeParam* cpu_data = data_blob.mutable_cpu_data();
1713    cpu_data[0] = 0.1;
1714    cpu_data[1] = 0.9;
1715    cpu_data[2] = 0.9;
1716    cpu_data[3] = 0.1;
1717    cpu_data[4] = 0.3;
1718    cpu_data[5] = 0.7;
1719    cpu_data[6] = 0.7;
1720    cpu_data[7] = 0.3;
1721    const TypeParam* gpu_data = data_blob.gpu_data();
1722    TypeParam* gpu_prob = prob_blob.mutable_gpu_data();
1723    SoftMaxGPU(gpu_data, num * num_preds, num_classes, 1, gpu_prob);
1724    const TypeParam* cpu_prob = prob_blob.cpu_data();
1725    EXPECT_NEAR(cpu_prob[0], exp(-0.8) / (exp(-0.8) + 1), eps);
1726    EXPECT_NEAR(cpu_prob[1], 1 / (exp(-0.8) + 1), eps);
1727    EXPECT_NEAR(cpu_prob[2], 1 / (exp(-0.8) + 1), eps);
1728    EXPECT_NEAR(cpu_prob[3], exp(-0.8) / (exp(-0.8) + 1), eps);
1729    EXPECT_NEAR(cpu_prob[4], exp(-0.4) / (exp(-0.4) + 1), eps);
1730    EXPECT_NEAR(cpu_prob[5], 1 / (exp(-0.4) + 1), eps);
1731    EXPECT_NEAR(cpu_prob[6], 1 / (exp(-0.4) + 1), eps);
1732    EXPECT_NEAR(cpu_prob[7], exp(-0.4) / (exp(-0.4) + 1), eps);
1733  }
1734  TYPED_TEST(GPUBBoxUtilTest, TestComputeConfLossMatchGPU) {
1735    const int num = 2;
1736    const int num_preds_per_class = 2;
1737    const int num_classes = 2;
1738    const int dim = num_preds_per_class * num_classes;
1739    Blob&lt;TypeParam&gt; conf_blob(num, dim, 1, 1);
1740    TypeParam* conf_data = conf_blob.mutable_cpu_data();
1741    vector&lt;map&lt;int, vector&lt;int&gt; &gt; &gt; all_match_indices;
1742    map&lt;int, vector&lt;NormalizedBBox&gt; &gt; all_gt_bboxes;
1743    for (int i = 0; i &lt; num; ++i) {
1744      int sign = i % 2 ? 1 : -1;
1745      for (int j = 0; j &lt; num_preds_per_class; ++j) {
1746        for (int c = 0; c &lt; num_classes; ++c) {
1747          int idx = (i * num_preds_per_class + j) * num_classes + c;
1748          conf_data[idx] = sign * idx * 0.1;
1749        }
1750      }
1751      map&lt;int, vector&lt;int&gt; &gt; match_indices;
1752      vector&lt;int&gt; indices(num_preds_per_class, -1);
1753      match_indices[-1] = indices;
1754      if (i == 1) {
1755        NormalizedBBox gt_bbox;
1756        gt_bbox.set_label(1);
1757        all_gt_bboxes[i].push_back(gt_bbox);
1758        match_indices[-1][0] = 0;
1759      }
1760      all_match_indices.push_back(match_indices);
1761    }
1762    vector&lt;vector&lt;float&gt; &gt; all_conf_loss;
1763    ConfLossType loss_type = MultiBoxLossParameter_ConfLossType_LOGISTIC;
1764    ComputeConfLossGPU(conf_blob, num, num_preds_per_class, num_classes,
1765        -1, loss_type, all_match_indices, all_gt_bboxes, &amp;all_conf_loss);
1766    EXPECT_EQ(all_conf_loss.size(), num);
1767    EXPECT_EQ(all_conf_loss[0].size(), num_preds_per_class);
1768    EXPECT_NEAR(all_conf_loss[0][0],
1769                -(log(exp(0.)/(1.+exp(0.))) + log(exp(0.1)/(1+exp(0.1)))), eps);
1770    EXPECT_NEAR(all_conf_loss[0][1],
1771                -(log(exp(0.2)/(1.+exp(0.2))) + log(exp(0.3)/(1+exp(0.3)))), eps);
1772    EXPECT_EQ(all_conf_loss[1].size(), num_preds_per_class);
1773    EXPECT_NEAR(all_conf_loss[1][0],
1774                -(log(exp(-0.4)/(1.+exp(-0.4))) + log(1./(1+exp(-0.5)))),
1775                eps);
1776    EXPECT_NEAR(all_conf_loss[1][1],
1777                -(log(exp(-0.6)/(1.+exp(-0.6))) + log(exp(-0.7)/(1+exp(-0.7)))),
1778                eps);
1779    ComputeConfLossGPU(conf_blob, num, num_preds_per_class, num_classes,
1780        0, loss_type, all_match_indices, all_gt_bboxes, &amp;all_conf_loss);
1781    EXPECT_EQ(all_conf_loss.size(), num);
1782    EXPECT_EQ(all_conf_loss[0].size(), num_preds_per_class);
1783    EXPECT_NEAR(all_conf_loss[0][0],
1784                -(log(1./(1.+exp(0.))) + log(exp(0.1)/(1+exp(0.1)))), eps);
1785    EXPECT_NEAR(all_conf_loss[0][1],
1786                -(log(1./(1.+exp(0.2))) + log(exp(0.3)/(1+exp(0.3)))), eps);
1787    EXPECT_EQ(all_conf_loss[1].size(), num_preds_per_class);
1788    EXPECT_NEAR(all_conf_loss[1][0],
1789                -(log(exp(-0.4)/(1.+exp(-0.4))) + log(1./(1+exp(-0.5)))), eps);
1790    EXPECT_NEAR(all_conf_loss[1][1],
1791                -(log(1./(1.+exp(-0.6))) + log(exp(-0.7)/(1+exp(-0.7)))), eps);
1792    loss_type = MultiBoxLossParameter_ConfLossType_SOFTMAX;
1793    ComputeConfLossGPU(conf_blob, num, num_preds_per_class, num_classes,
1794        0, loss_type, all_match_indices, all_gt_bboxes, &amp;all_conf_loss);
1795    EXPECT_EQ(all_conf_loss.size(), num);
1796    for (int i = 0; i &lt; num; ++i) {
1797      EXPECT_EQ(all_conf_loss[i].size(), num_preds_per_class);
1798      int sign = i % 2 ? 1 : -1;
1799      for (int j = 0; j &lt; num_preds_per_class; ++j) {
1800        if (sign == 1) {
1801          if (j == 0) {
1802            EXPECT_NEAR(all_conf_loss[i][j], -log(1./(1+exp(-0.1))), eps);
1803          } else {
1804            EXPECT_NEAR(all_conf_loss[i][j], -log(exp(-0.1)/(1+exp(-0.1))), eps);
1805          }
1806        } else {
1807          EXPECT_NEAR(all_conf_loss[i][j], -log(1./(1+exp(-0.1))), eps);
1808        }
1809      }
1810    }
1811  }
1812  #endif
1813  }  
</code></pre>
        </div>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-test_bbox_util.cpp</h3>
            <pre><code>1  #include &lt;map&gt;
2  #include &lt;utility&gt;
3  #include &lt;vector&gt;
4  #include &quot;gtest/gtest.h&quot;
5  #include &quot;caffe/common.hpp&quot;
6  #include &quot;caffe/util/bbox_util.hpp&quot;
7  #include &quot;caffe/test/test_caffe_main.hpp&quot;
8  namespace caffe {
9  static const float eps = 1e-6;
10  void FillBBoxes(vector&lt;NormalizedBBox&gt;* gt_bboxes,
11                  vector&lt;NormalizedBBox&gt;* pred_bboxes) {
12    gt_bboxes-&gt;clear();
13    pred_bboxes-&gt;clear();
14    NormalizedBBox bbox;
15    bbox.set_label(1);
16    bbox.set_xmin(0.1);
17    bbox.set_ymin(0.1);
18    bbox.set_xmax(0.3);
19    bbox.set_ymax(0.3);
20    gt_bboxes-&gt;push_back(bbox);
21    bbox.set_label(2);
22    bbox.set_xmin(0.3);
23    bbox.set_ymin(0.3);
24    bbox.set_xmax(0.6);
25    bbox.set_ymax(0.5);
26    gt_bboxes-&gt;push_back(bbox);
27    bbox.set_xmin(0.1);
28    bbox.set_ymin(0);
29    bbox.set_xmax(0.4);
30    bbox.set_ymax(0.3);
31    pred_bboxes-&gt;push_back(bbox);
32    bbox.set_xmin(0);
33    bbox.set_ymin(0.1);
34    bbox.set_xmax(0.2);
35    bbox.set_ymax(0.3);
36    pred_bboxes-&gt;push_back(bbox);
37    bbox.set_xmin(0.2);
38    bbox.set_ymin(0.1);
39    bbox.set_xmax(0.4);
40    bbox.set_ymax(0.4);
41    pred_bboxes-&gt;push_back(bbox);
42    bbox.set_xmin(0.4);
43    bbox.set_ymin(0.3);
44    bbox.set_xmax(0.7);
45    bbox.set_ymax(0.5);
46    pred_bboxes-&gt;push_back(bbox);
47    bbox.set_xmin(0.5);
48    bbox.set_ymin(0.4);
49    bbox.set_xmax(0.7);
50    bbox.set_ymax(0.7);
51    pred_bboxes-&gt;push_back(bbox);
52    bbox.set_xmin(0.7);
53    bbox.set_ymin(0.7);
54    bbox.set_xmax(0.8);
55    bbox.set_ymax(0.8);
56    pred_bboxes-&gt;push_back(bbox);
57  }
58  template &lt;typename TypeParam&gt;
59  class BBoxUtilTest : public MultiDeviceTest&lt;TypeParam&gt; {
60    typedef typename TypeParam::Dtype Dtype;
61  };
62  class CPUBBoxUtilTest : public BBoxUtilTest&lt;CPUDevice&lt;float&gt; &gt; {
63  };
64  TEST_F(CPUBBoxUtilTest, TestIntersectBBox) {
65    NormalizedBBox bbox_ref;
66    bbox_ref.set_xmin(0.2);
67    bbox_ref.set_ymin(0.3);
68    bbox_ref.set_xmax(0.3);
69    bbox_ref.set_ymax(0.5);
70    NormalizedBBox bbox_test;
71    NormalizedBBox bbox_intersect;
72    bbox_test.set_xmin(0.1);
73    bbox_test.set_ymin(0.1);
74    bbox_test.set_xmax(0.3);
75    bbox_test.set_ymax(0.4);
76    IntersectBBox(bbox_ref, bbox_test, &amp;bbox_intersect);
77    EXPECT_NEAR(bbox_intersect.xmin(), 0.2, eps);
78    EXPECT_NEAR(bbox_intersect.ymin(), 0.3, eps);
79    EXPECT_NEAR(bbox_intersect.xmax(), 0.3, eps);
80    EXPECT_NEAR(bbox_intersect.ymax(), 0.4, eps);
81    bbox_test.set_xmin(0.1);
82    bbox_test.set_ymin(0.1);
83    bbox_test.set_xmax(0.4);
84    bbox_test.set_ymax(0.6);
85    IntersectBBox(bbox_ref, bbox_test, &amp;bbox_intersect);
86    EXPECT_NEAR(bbox_intersect.xmin(), 0.2, eps);
87    EXPECT_NEAR(bbox_intersect.ymin(), 0.3, eps);
88    EXPECT_NEAR(bbox_intersect.xmax(), 0.3, eps);
89    EXPECT_NEAR(bbox_intersect.ymax(), 0.5, eps);
90    bbox_test.set_xmin(0);
91    bbox_test.set_ymin(0);
92    bbox_test.set_xmax(0.1);
93    bbox_test.set_ymax(0.1);
94    IntersectBBox(bbox_ref, bbox_test, &amp;bbox_intersect);
95    EXPECT_NEAR(bbox_intersect.xmin(), 0, eps);
96    EXPECT_NEAR(bbox_intersect.ymin(), 0, eps);
97    EXPECT_NEAR(bbox_intersect.xmax(), 0, eps);
98    EXPECT_NEAR(bbox_intersect.ymax(), 0, eps);
99  }
100  TEST_F(CPUBBoxUtilTest, TestBBoxSize) {
101    NormalizedBBox bbox;
102    float size;
103    bbox.set_xmin(0.2);
104    bbox.set_ymin(0.3);
105    bbox.set_xmax(0.3);
106    bbox.set_ymax(0.5);
107    size = BBoxSize(bbox);
108    EXPECT_NEAR(size, 0.02, eps);
109    bbox.set_xmin(0.2);
110    bbox.set_ymin(0.3);
111    bbox.set_xmax(0.2);
112    bbox.set_ymax(0.5);
113    size = BBoxSize(bbox);
114    EXPECT_NEAR(size, 0., eps);
115    bbox.set_xmin(0.2);
116    bbox.set_ymin(0.3);
117    bbox.set_xmax(0.1);
118    bbox.set_ymax(0.5);
119    size = BBoxSize(bbox);
120    EXPECT_NEAR(size, 0., eps);
121  }
122  TEST_F(CPUBBoxUtilTest, TestScaleBBox) {
123    NormalizedBBox bbox;
124    bbox.set_xmin(0.21);
125    bbox.set_ymin(0.32);
126    bbox.set_xmax(0.33);
127    bbox.set_ymax(0.54);
128    NormalizedBBox scale_bbox;
129    float eps = 1e-5;
130    int height = 10;
131    int width = 20;
132    ScaleBBox(bbox, height, width, &amp;scale_bbox);
133    EXPECT_NEAR(scale_bbox.xmin(), 4.2, eps);
134    EXPECT_NEAR(scale_bbox.ymin(), 3.2, eps);
135    EXPECT_NEAR(scale_bbox.xmax(), 6.6, eps);
136    EXPECT_NEAR(scale_bbox.ymax(), 5.4, eps);
137    EXPECT_NEAR(scale_bbox.size(), 10.88, eps);
138    height = 1;
139    width = 1;
140    ScaleBBox(bbox, height, width, &amp;scale_bbox);
141    EXPECT_NEAR(bbox.xmin(), scale_bbox.xmin(), eps);
142    EXPECT_NEAR(bbox.ymin(), scale_bbox.ymin(), eps);
143    EXPECT_NEAR(bbox.xmax(), scale_bbox.xmax(), eps);
144    EXPECT_NEAR(bbox.ymax(), scale_bbox.ymax(), eps);
145    EXPECT_NEAR(scale_bbox.size(), 0.0264, eps);
146  }
147  TEST_F(CPUBBoxUtilTest, TestClipBBox) {
148    NormalizedBBox bbox;
149    NormalizedBBox clip_bbox;
150    bbox.set_xmin(0.2);
151    bbox.set_ymin(0.3);
152    bbox.set_xmax(0.3);
153    bbox.set_ymax(0.5);
154    ClipBBox(bbox, &amp;clip_bbox);
155    EXPECT_NEAR(bbox.xmin(), clip_bbox.xmin(), eps);
156    EXPECT_NEAR(bbox.ymin(), clip_bbox.ymin(), eps);
157    EXPECT_NEAR(bbox.xmax(), clip_bbox.xmax(), eps);
158    EXPECT_NEAR(bbox.ymax(), clip_bbox.ymax(), eps);
159    EXPECT_NEAR(clip_bbox.size(), 0.02, eps);
160    bbox.set_xmin(-0.2);
161    bbox.set_ymin(-0.3);
162    bbox.set_xmax(1.3);
163    bbox.set_ymax(1.5);
164    ClipBBox(bbox, &amp;clip_bbox);
165    EXPECT_NEAR(clip_bbox.xmin(), 0., eps);
166    EXPECT_NEAR(clip_bbox.ymin(), 0., eps);
167    EXPECT_NEAR(clip_bbox.xmax(), 1., eps);
168    EXPECT_NEAR(clip_bbox.ymax(), 1., eps);
169    EXPECT_NEAR(clip_bbox.size(), 1., eps);
170  }
171  TEST_F(CPUBBoxUtilTest, TestOutputBBox) {
172    NormalizedBBox bbox;
173    bbox.set_xmin(-0.1);
174    bbox.set_ymin(0.3);
175    bbox.set_xmax(0.3);
176    bbox.set_ymax(0.5);
177    pair&lt;int, int&gt; img_size(300, 500);
178    bool has_resize = false;
179    ResizeParameter resize_param;
180    resize_param.set_height(300);
181    resize_param.set_width(300);
182    NormalizedBBox out_bbox;
183    OutputBBox(bbox, img_size, has_resize, resize_param, &amp;out_bbox);
184    CHECK_EQ(out_bbox.xmin(), 0.);
185    CHECK_EQ(out_bbox.ymin(), 90.);
186    CHECK_EQ(out_bbox.xmax(), 150.);
187    CHECK_EQ(out_bbox.ymax(), 150.);
188    has_resize = true;
189    resize_param.set_resize_mode(ResizeParameter_Resize_mode_WARP);
190    OutputBBox(bbox, img_size, has_resize, resize_param, &amp;out_bbox);
191    CHECK_EQ(out_bbox.xmin(), 0.);
192    CHECK_EQ(out_bbox.ymin(), 90.);
193    CHECK_EQ(out_bbox.xmax(), 150.);
194    CHECK_EQ(out_bbox.ymax(), 150.);
195    resize_param.set_resize_mode(ResizeParameter_Resize_mode_FIT_SMALL_SIZE);
196    OutputBBox(bbox, img_size, has_resize, resize_param, &amp;out_bbox);
197    CHECK_EQ(out_bbox.xmin(), 0.);
198    CHECK_EQ(out_bbox.ymin(), 90.);
199    CHECK_EQ(out_bbox.xmax(), 150.);
200    CHECK_EQ(out_bbox.ymax(), 150.);
201    resize_param.set_resize_mode(ResizeParameter_Resize_mode_FIT_SMALL_SIZE);
202    resize_param.set_height_scale(300);
203    resize_param.set_width_scale(300);
204    OutputBBox(bbox, img_size, has_resize, resize_param, &amp;out_bbox);
205    CHECK_EQ(out_bbox.xmin(), 0.);
206    CHECK_EQ(out_bbox.ymin(), 90.);
207    CHECK_EQ(out_bbox.xmax(), 90.);
208    CHECK_EQ(out_bbox.ymax(), 150.);
209    resize_param.set_resize_mode(
210        ResizeParameter_Resize_mode_FIT_LARGE_SIZE_AND_PAD);
211    OutputBBox(bbox, img_size, has_resize, resize_param, &amp;out_bbox);
212    static const float errorBound = 1e-4;
213    EXPECT_NEAR(out_bbox.xmin(), 0., errorBound);
214    EXPECT_NEAR(out_bbox.ymin(), 50., errorBound);
215    EXPECT_NEAR(out_bbox.xmax(), 150., errorBound);
216    EXPECT_NEAR(out_bbox.ymax(), 150., errorBound);
217    img_size.first = 500;
218    img_size.second = 300;
219    OutputBBox(bbox, img_size, has_resize, resize_param, &amp;out_bbox);
220    EXPECT_NEAR(out_bbox.xmin(), 0., errorBound);
221    EXPECT_NEAR(out_bbox.ymin(), 150., errorBound);
222    EXPECT_NEAR(out_bbox.xmax(), 50., errorBound);
223    EXPECT_NEAR(out_bbox.ymax(), 250., errorBound);
224  }
225  TEST_F(CPUBBoxUtilTest, TestJaccardOverlap) {
226    NormalizedBBox bbox1;
227    bbox1.set_xmin(0.2);
228    bbox1.set_ymin(0.3);
229    bbox1.set_xmax(0.3);
230    bbox1.set_ymax(0.5);
231    NormalizedBBox bbox2;
232    float overlap;
233    bbox2.set_xmin(0.1);
234    bbox2.set_ymin(0.1);
235    bbox2.set_xmax(0.3);
236    bbox2.set_ymax(0.4);
237    overlap = JaccardOverlap(bbox1, bbox2);
238    EXPECT_NEAR(overlap, 1./7, eps);
239    bbox2.set_xmin(0.1);
240    bbox2.set_ymin(0.1);
241    bbox2.set_xmax(0.4);
242    bbox2.set_ymax(0.6);
243    overlap = JaccardOverlap(bbox1, bbox2);
244    EXPECT_NEAR(overlap, 2./15, eps);
245    bbox2.set_xmin(0);
246    bbox2.set_ymin(0);
247    bbox2.set_xmax(0.1);
248    bbox2.set_ymax(0.1);
249    overlap = JaccardOverlap(bbox1, bbox2);
250    EXPECT_NEAR(overlap, 0., eps);
251  }
252  TEST_F(CPUBBoxUtilTest, TestEncodeBBoxCorner) {
253    NormalizedBBox prior_bbox;
254    prior_bbox.set_xmin(0.1);
255    prior_bbox.set_ymin(0.1);
256    prior_bbox.set_xmax(0.3);
257    prior_bbox.set_ymax(0.3);
258    vector&lt;float&gt; prior_variance(4, 0.1);
259    NormalizedBBox bbox;
260    bbox.set_xmin(0);
261    bbox.set_ymin(0.2);
262    bbox.set_xmax(0.4);
263    bbox.set_ymax(0.5);
264    CodeType code_type = PriorBoxParameter_CodeType_CORNER;
265    NormalizedBBox encode_bbox;
266    bool encode_variance_in_target = true;
267    EncodeBBox(prior_bbox, prior_variance, code_type, encode_variance_in_target,
268               bbox, &amp;encode_bbox);
269    EXPECT_NEAR(encode_bbox.xmin(), -0.1, eps);
270    EXPECT_NEAR(encode_bbox.ymin(), 0.1, eps);
271    EXPECT_NEAR(encode_bbox.xmax(), 0.1, eps);
272    EXPECT_NEAR(encode_bbox.ymax(), 0.2, eps);
273    encode_variance_in_target = false;
274    EncodeBBox(prior_bbox, prior_variance, code_type, encode_variance_in_target,
275               bbox, &amp;encode_bbox);
276    EXPECT_NEAR(encode_bbox.xmin(), -1, eps);
277    EXPECT_NEAR(encode_bbox.ymin(), 1, eps);
278    EXPECT_NEAR(encode_bbox.xmax(), 1, eps);
279    EXPECT_NEAR(encode_bbox.ymax(), 2, eps);
280  }
281  TEST_F(CPUBBoxUtilTest, TestEncodeBBoxCenterSize) {
282    NormalizedBBox prior_bbox;
283    prior_bbox.set_xmin(0.1);
284    prior_bbox.set_ymin(0.1);
285    prior_bbox.set_xmax(0.3);
286    prior_bbox.set_ymax(0.3);
287    vector&lt;float&gt; prior_variance;
288    prior_variance.push_back(0.1);
289    prior_variance.push_back(0.1);
290    prior_variance.push_back(0.2);
291    prior_variance.push_back(0.2);
292    NormalizedBBox bbox;
293    bbox.set_xmin(0);
294    bbox.set_ymin(0.2);
295    bbox.set_xmax(0.4);
296    bbox.set_ymax(0.5);
297    CodeType code_type = PriorBoxParameter_CodeType_CENTER_SIZE;
298    NormalizedBBox encode_bbox;
299    bool encode_variance_in_target = true;
300    EncodeBBox(prior_bbox, prior_variance, code_type, encode_variance_in_target,
301               bbox, &amp;encode_bbox);
302    EXPECT_NEAR(encode_bbox.xmin(), 0, eps);
303    EXPECT_NEAR(encode_bbox.ymin(), 0.75, eps);
304    EXPECT_NEAR(encode_bbox.xmax(), log(2.), eps);
305    EXPECT_NEAR(encode_bbox.ymax(), log(3./2), eps);
306    encode_variance_in_target = false;
307    EncodeBBox(prior_bbox, prior_variance, code_type, encode_variance_in_target,
308               bbox, &amp;encode_bbox);
309    float eps = 1e-5;
310    EXPECT_NEAR(encode_bbox.xmin(), 0 / 0.1, eps);
311    EXPECT_NEAR(encode_bbox.ymin(), 0.75 / 0.1, eps);
312    EXPECT_NEAR(encode_bbox.xmax(), log(2.) / 0.2, eps);
313    EXPECT_NEAR(encode_bbox.ymax(), log(3./2) / 0.2, eps);
314  }
315  TEST_F(CPUBBoxUtilTest, TestDecodeBBoxCorner) {
316    NormalizedBBox prior_bbox;
317    prior_bbox.set_xmin(0.1);
318    prior_bbox.set_ymin(0.1);
319    prior_bbox.set_xmax(0.3);
320    prior_bbox.set_ymax(0.3);
321    vector&lt;float&gt; prior_variance(4, 0.1);
322    NormalizedBBox bbox;
323    bbox.set_xmin(-1);
324    bbox.set_ymin(1);
325    bbox.set_xmax(1);
326    bbox.set_ymax(2);
327    CodeType code_type = PriorBoxParameter_CodeType_CORNER;
328    NormalizedBBox decode_bbox;
329    bool variance_encoded_in_target = false;
330    DecodeBBox(prior_bbox, prior_variance, code_type, variance_encoded_in_target,
331               false, bbox, &amp;decode_bbox);
332    EXPECT_NEAR(decode_bbox.xmin(), 0, eps);
333    EXPECT_NEAR(decode_bbox.ymin(), 0.2, eps);
334    EXPECT_NEAR(decode_bbox.xmax(), 0.4, eps);
335    EXPECT_NEAR(decode_bbox.ymax(), 0.5, eps);
336    variance_encoded_in_target = true;
337    DecodeBBox(prior_bbox, prior_variance, code_type, variance_encoded_in_target,
338               false, bbox, &amp;decode_bbox);
339    EXPECT_NEAR(decode_bbox.xmin(), -0.9, eps);
340    EXPECT_NEAR(decode_bbox.ymin(), 1.1, eps);
341    EXPECT_NEAR(decode_bbox.xmax(), 1.3, eps);
342    EXPECT_NEAR(decode_bbox.ymax(), 2.3, eps);
343  }
344  TEST_F(CPUBBoxUtilTest, TestDecodeBBoxCenterSize) {
345    NormalizedBBox prior_bbox;
346    prior_bbox.set_xmin(0.1);
347    prior_bbox.set_ymin(0.1);
348    prior_bbox.set_xmax(0.3);
349    prior_bbox.set_ymax(0.3);
350    vector&lt;float&gt; prior_variance;
351    prior_variance.push_back(0.1);
352    prior_variance.push_back(0.1);
353    prior_variance.push_back(0.2);
354    prior_variance.push_back(0.2);
355    NormalizedBBox bbox;
356    bbox.set_xmin(0);
357    bbox.set_ymin(0.75);
358    bbox.set_xmax(log(2));
359    bbox.set_ymax(log(3./2));
360    CodeType code_type = PriorBoxParameter_CodeType_CENTER_SIZE;
361    NormalizedBBox decode_bbox;
362    bool variance_encoded_in_target = true;
363    DecodeBBox(prior_bbox, prior_variance, code_type, variance_encoded_in_target,
364               false, bbox, &amp;decode_bbox);
365    EXPECT_NEAR(decode_bbox.xmin(), 0, eps);
366    EXPECT_NEAR(decode_bbox.ymin(), 0.2, eps);
367    EXPECT_NEAR(decode_bbox.xmax(), 0.4, eps);
368    EXPECT_NEAR(decode_bbox.ymax(), 0.5, eps);
369    bbox.set_xmin(0);
370    bbox.set_ymin(7.5);
371    bbox.set_xmax(log(2) * 5);
372    bbox.set_ymax(log(3./2) * 5);
373    variance_encoded_in_target = false;
374    DecodeBBox(prior_bbox, prior_variance, code_type, variance_encoded_in_target,
375               false, bbox, &amp;decode_bbox);
376    EXPECT_NEAR(decode_bbox.xmin(), 0, eps);
377    EXPECT_NEAR(decode_bbox.ymin(), 0.2, eps);
378    EXPECT_NEAR(decode_bbox.xmax(), 0.4, eps);
379    EXPECT_NEAR(decode_bbox.ymax(), 0.5, eps);
380  }
381  TEST_F(CPUBBoxUtilTest, TestDecodeBBoxesCorner) {
382    vector&lt;NormalizedBBox&gt; prior_bboxes;
383    vector&lt;vector&lt;float&gt; &gt; prior_variances;
384    vector&lt;NormalizedBBox&gt; bboxes;
385    for (int i = 1; i &lt; 5; ++i) {
386      NormalizedBBox prior_bbox;
387      prior_bbox.set_xmin(0.1*i);
388      prior_bbox.set_ymin(0.1*i);
389      prior_bbox.set_xmax(0.1*i + 0.2);
390      prior_bbox.set_ymax(0.1*i + 0.2);
391      prior_bboxes.push_back(prior_bbox);
392      vector&lt;float&gt; prior_variance(4, 0.1);
393      prior_variances.push_back(prior_variance);
394      NormalizedBBox bbox;
395      bbox.set_xmin(-1 * (i%2));
396      bbox.set_ymin((i+1)%2);
397      bbox.set_xmax((i+1)%2);
398      bbox.set_ymax(i%2);
399      bboxes.push_back(bbox);
400    }
401    CodeType code_type = PriorBoxParameter_CodeType_CORNER;
402    vector&lt;NormalizedBBox&gt; decode_bboxes;
403    bool variance_encoded_in_target = false;
404    DecodeBBoxes(prior_bboxes, prior_variances, code_type,
405                 variance_encoded_in_target, false, bboxes, &amp;decode_bboxes);
406    EXPECT_EQ(decode_bboxes.size(), 4);
407    for (int i = 1; i &lt; 5; ++i) {
408      EXPECT_NEAR(decode_bboxes[i-1].xmin(), 0.1*i + i%2 * -0.1, eps);
409      EXPECT_NEAR(decode_bboxes[i-1].ymin(), 0.1*i + (i+1)%2 * 0.1, eps);
410      EXPECT_NEAR(decode_bboxes[i-1].xmax(), 0.1*i + 0.2 + (i+1)%2 * 0.1, eps);
411      EXPECT_NEAR(decode_bboxes[i-1].ymax(), 0.1*i + 0.2 + i%2 * 0.1, eps);
412    }
413    variance_encoded_in_target = true;
414    DecodeBBoxes(prior_bboxes, prior_variances, code_type,
415                 variance_encoded_in_target, false, bboxes, &amp;decode_bboxes);
416    EXPECT_EQ(decode_bboxes.size(), 4);
417    for (int i = 1; i &lt; 5; ++i) {
418      EXPECT_NEAR(decode_bboxes[i-1].xmin(), 0.1*i + i%2 * -1, eps);
419      EXPECT_NEAR(decode_bboxes[i-1].ymin(), 0.1*i + (i+1)%2, eps);
420      EXPECT_NEAR(decode_bboxes[i-1].xmax(), 0.1*i + 0.2 + (i+1)%2, eps);
421      EXPECT_NEAR(decode_bboxes[i-1].ymax(), 0.1*i + 0.2 + i%2, eps);
422    }
423  }
424  TEST_F(CPUBBoxUtilTest, TestDecodeBBoxesCenterSize) {
425    vector&lt;NormalizedBBox&gt; prior_bboxes;
426    vector&lt;vector&lt;float&gt; &gt; prior_variances;
427    vector&lt;NormalizedBBox&gt; bboxes;
428    for (int i = 1; i &lt; 5; ++i) {
429      NormalizedBBox prior_bbox;
430      prior_bbox.set_xmin(0.1*i);
431      prior_bbox.set_ymin(0.1*i);
432      prior_bbox.set_xmax(0.1*i + 0.2);
433      prior_bbox.set_ymax(0.1*i + 0.2);
434      prior_bboxes.push_back(prior_bbox);
435      vector&lt;float&gt; prior_variance;
436      prior_variance.push_back(0.1);
437      prior_variance.push_back(0.1);
438      prior_variance.push_back(0.2);
439      prior_variance.push_back(0.2);
440      prior_variances.push_back(prior_variance);
441      NormalizedBBox bbox;
442      bbox.set_xmin(0);
443      bbox.set_ymin(0.75);
444      bbox.set_xmax(log(2.));
445      bbox.set_ymax(log(3./2));
446      bboxes.push_back(bbox);
447    }
448    CodeType code_type = PriorBoxParameter_CodeType_CENTER_SIZE;
449    vector&lt;NormalizedBBox&gt; decode_bboxes;
450    bool variance_encoded_in_target = true;
451    DecodeBBoxes(prior_bboxes, prior_variances, code_type,
452                 variance_encoded_in_target, false, bboxes, &amp;decode_bboxes);
453    EXPECT_EQ(decode_bboxes.size(), 4);
454    float eps = 1e-5;
455    for (int i = 1; i &lt; 5; ++i) {
456      EXPECT_NEAR(decode_bboxes[i-1].xmin(), 0 + (i - 1) * 0.1, eps);
457      EXPECT_NEAR(decode_bboxes[i-1].ymin(), 0.2 + (i - 1) * 0.1, eps);
458      EXPECT_NEAR(decode_bboxes[i-1].xmax(), 0.4 + (i - 1) * 0.1, eps);
459      EXPECT_NEAR(decode_bboxes[i-1].ymax(), 0.5 + (i - 1) * 0.1, eps);
460    }
461    variance_encoded_in_target = false;
462    for (int i = 0; i &lt; 4; ++i) {
463      NormalizedBBox bbox;
464      bboxes[i].set_xmin(0);
465      bboxes[i].set_ymin(7.5);
466      bboxes[i].set_xmax(log(2.) * 5);
467      bboxes[i].set_ymax(log(3./2) * 5);
468    }
469    DecodeBBoxes(prior_bboxes, prior_variances, code_type,
470                 variance_encoded_in_target, false, bboxes, &amp;decode_bboxes);
471    EXPECT_EQ(decode_bboxes.size(), 4);
472    for (int i = 1; i &lt; 5; ++i) {
473      EXPECT_NEAR(decode_bboxes[i-1].xmin(), 0 + (i - 1) * 0.1, eps);
474      EXPECT_NEAR(decode_bboxes[i-1].ymin(), 0.2 + (i - 1) * 0.1, eps);
475      EXPECT_NEAR(decode_bboxes[i-1].xmax(), 0.4 + (i - 1) * 0.1, eps);
476      EXPECT_NEAR(decode_bboxes[i-1].ymax(), 0.5 + (i - 1) * 0.1, eps);
477    }
478  }
479  TEST_F(CPUBBoxUtilTest, TestMatchBBoxLableOneBipartite) {
480    vector&lt;NormalizedBBox&gt; gt_bboxes;
481    vector&lt;NormalizedBBox&gt; pred_bboxes;
482    FillBBoxes(&amp;gt_bboxes, &amp;pred_bboxes);
483    int label = 1;
484    MatchType match_type = MultiBoxLossParameter_MatchType_BIPARTITE;
485    float overlap = -1;
486    vector&lt;int&gt; match_indices;
487    vector&lt;float&gt; match_overlaps;
488    MatchBBox(gt_bboxes, pred_bboxes, label, match_type, overlap, true,
489              &amp;match_indices, &amp;match_overlaps);
490    EXPECT_EQ(match_indices.size(), 6);
491    EXPECT_EQ(match_overlaps.size(), 6);
492    EXPECT_EQ(match_indices[0], 0);
493    EXPECT_EQ(match_indices[1], -1);
494    EXPECT_EQ(match_indices[2], -1);
495    EXPECT_NEAR(match_overlaps[0], 4./9, eps);
496    EXPECT_NEAR(match_overlaps[1], 2./6, eps);
497    EXPECT_NEAR(match_overlaps[2], 2./8, eps);
498    for (int i = 3; i &lt; 6; ++i) {
499      EXPECT_EQ(match_indices[i], -1);
500      EXPECT_NEAR(match_overlaps[i], 0, eps);
501    }
502  }
503  TEST_F(CPUBBoxUtilTest, TestMatchBBoxLableAllBipartite) {
504    vector&lt;NormalizedBBox&gt; gt_bboxes;
505    vector&lt;NormalizedBBox&gt; pred_bboxes;
506    FillBBoxes(&amp;gt_bboxes, &amp;pred_bboxes);
507    int label = -1;
508    MatchType match_type = MultiBoxLossParameter_MatchType_BIPARTITE;
509    float overlap = -1;
510    vector&lt;int&gt; match_indices;
511    vector&lt;float&gt; match_overlaps;
512    MatchBBox(gt_bboxes, pred_bboxes, label, match_type, overlap, true,
513              &amp;match_indices, &amp;match_overlaps);
514    EXPECT_EQ(match_indices.size(), 6);
515    EXPECT_EQ(match_overlaps.size(), 6);
516    EXPECT_EQ(match_indices[0], 0);
517    EXPECT_EQ(match_indices[3], 1);
518    EXPECT_NEAR(match_overlaps[0], 4./9, eps);
519    EXPECT_NEAR(match_overlaps[1], 2./6, eps);
520    EXPECT_NEAR(match_overlaps[2], 2./8, eps);
521    EXPECT_NEAR(match_overlaps[3], 4./8, eps);
522    EXPECT_NEAR(match_overlaps[4], 1./11, eps);
523    EXPECT_NEAR(match_overlaps[5], 0., eps);
524    for (int i = 0; i &lt; 6; ++i) {
525      if (i == 0 || i == 3) {
526        continue;
527      }
528      EXPECT_EQ(match_indices[i], -1);
529    }
530  }
531  TEST_F(CPUBBoxUtilTest, TestMatchBBoxLableOnePerPrediction) {
532    vector&lt;NormalizedBBox&gt; gt_bboxes;
533    vector&lt;NormalizedBBox&gt; pred_bboxes;
534    FillBBoxes(&amp;gt_bboxes, &amp;pred_bboxes);
535    int label = 1;
536    MatchType match_type = MultiBoxLossParameter_MatchType_PER_PREDICTION;
537    float overlap = 0.3;
538    vector&lt;int&gt; match_indices;
539    vector&lt;float&gt; match_overlaps;
540    MatchBBox(gt_bboxes, pred_bboxes, label, match_type, overlap, true,
541              &amp;match_indices, &amp;match_overlaps);
542    EXPECT_EQ(match_indices.size(), 6);
543    EXPECT_EQ(match_overlaps.size(), 6);
544    EXPECT_EQ(match_indices[0], 0);
545    EXPECT_EQ(match_indices[1], 0);
546    EXPECT_EQ(match_indices[2], -1);
547    EXPECT_NEAR(match_overlaps[0], 4./9, eps);
548    EXPECT_NEAR(match_overlaps[1], 2./6, eps);
549    EXPECT_NEAR(match_overlaps[2], 2./8, eps);
550    for (int i = 3; i &lt; 6; ++i) {
551      EXPECT_EQ(match_indices[i], -1);
552      EXPECT_NEAR(match_overlaps[i], 0, eps);
553    }
554  }
555  TEST_F(CPUBBoxUtilTest, TestMatchBBoxLableAllPerPrediction) {
556    vector&lt;NormalizedBBox&gt; gt_bboxes;
557    vector&lt;NormalizedBBox&gt; pred_bboxes;
558    FillBBoxes(&amp;gt_bboxes, &amp;pred_bboxes);
559    int label = -1;
560    MatchType match_type = MultiBoxLossParameter_MatchType_PER_PREDICTION;
561    float overlap = 0.3;
562    vector&lt;int&gt; match_indices;
563    vector&lt;float&gt; match_overlaps;
564    MatchBBox(gt_bboxes, pred_bboxes, label, match_type, overlap, true,
565              &amp;match_indices, &amp;match_overlaps);
566    EXPECT_EQ(match_indices.size(), 6);
567    EXPECT_EQ(match_overlaps.size(), 6);
568    EXPECT_EQ(match_indices[0], 0);
569    EXPECT_EQ(match_indices[1], 0);
570    EXPECT_EQ(match_indices[2], -1);
571    EXPECT_EQ(match_indices[3], 1);
572    EXPECT_EQ(match_indices[4], -1);
573    EXPECT_EQ(match_indices[5], -1);
574    EXPECT_NEAR(match_overlaps[0], 4./9, eps);
575    EXPECT_NEAR(match_overlaps[1], 2./6, eps);
576    EXPECT_NEAR(match_overlaps[2], 2./8, eps);
577    EXPECT_NEAR(match_overlaps[3], 4./8, eps);
578    EXPECT_NEAR(match_overlaps[4], 1./11, eps);
579    EXPECT_NEAR(match_overlaps[5], 0, eps);
580  }
581  TEST_F(CPUBBoxUtilTest, TestMatchBBoxLableAllPerPredictionEx) {
582    vector&lt;NormalizedBBox&gt; gt_bboxes;
583    vector&lt;NormalizedBBox&gt; pred_bboxes;
584    FillBBoxes(&amp;gt_bboxes, &amp;pred_bboxes);
585    int label = -1;
586    MatchType match_type = MultiBoxLossParameter_MatchType_PER_PREDICTION;
587    float overlap = 0.001;
588    vector&lt;int&gt; match_indices;
589    vector&lt;float&gt; match_overlaps;
590    MatchBBox(gt_bboxes, pred_bboxes, label, match_type, overlap, true,
591              &amp;match_indices, &amp;match_overlaps);
592    EXPECT_EQ(match_indices.size(), 6);
593    EXPECT_EQ(match_overlaps.size(), 6);
594    EXPECT_EQ(match_indices[0], 0);
595    EXPECT_EQ(match_indices[1], 0);
596    EXPECT_EQ(match_indices[2], 0);
597    EXPECT_EQ(match_indices[3], 1);
598    EXPECT_EQ(match_indices[4], 1);
599    EXPECT_EQ(match_indices[5], -1);
600    EXPECT_NEAR(match_overlaps[0], 4./9, eps);
601    EXPECT_NEAR(match_overlaps[1], 2./6, eps);
602    EXPECT_NEAR(match_overlaps[2], 2./8, eps);
603    EXPECT_NEAR(match_overlaps[3], 4./8, eps);
604    EXPECT_NEAR(match_overlaps[4], 1./11, eps);
605    EXPECT_NEAR(match_overlaps[5], 0., eps);
606  }
607  TEST_F(CPUBBoxUtilTest, TestGetGroundTruth) {
608    const int num_gt = 4;
609    Blob&lt;float&gt; gt_blob(1, 1, num_gt, 8);
610    float* gt_data = gt_blob.mutable_cpu_data();
611    for (int i = 0; i &lt; 4; ++i) {
612      int image_id = ceil(i / 2.);
613      gt_data[i * 8] = image_id;
614      gt_data[i * 8 + 1] = i;
615      gt_data[i * 8 + 2] = 0;
616      gt_data[i * 8 + 3] = 0.1;
617      gt_data[i * 8 + 4] = 0.1;
618      gt_data[i * 8 + 5] = 0.3;
619      gt_data[i * 8 + 6] = 0.3;
620      gt_data[i * 8 + 7] = i % 2;
621    }
622    map&lt;int, vector&lt;NormalizedBBox&gt; &gt; all_gt_bboxes;
623    GetGroundTruth(gt_data, num_gt, -1, true, &amp;all_gt_bboxes);
624    EXPECT_EQ(all_gt_bboxes.size(), 3);
625    EXPECT_EQ(all_gt_bboxes[0].size(), 1);
626    EXPECT_EQ(all_gt_bboxes[0][0].label(), 0);
627    EXPECT_NEAR(all_gt_bboxes[0][0].xmin(), 0.1, eps);
628    EXPECT_NEAR(all_gt_bboxes[0][0].ymin(), 0.1, eps);
629    EXPECT_NEAR(all_gt_bboxes[0][0].xmax(), 0.3, eps);
630    EXPECT_NEAR(all_gt_bboxes[0][0].ymax(), 0.3, eps);
631    EXPECT_EQ(all_gt_bboxes[0][0].difficult(), false);
632    EXPECT_NEAR(all_gt_bboxes[0][0].size(), 0.04, eps);
633    EXPECT_EQ(all_gt_bboxes[1].size(), 2);
634    for (int i = 1; i &lt; 3; ++i) {
635      EXPECT_EQ(all_gt_bboxes[1][i-1].label(), i);
636      EXPECT_NEAR(all_gt_bboxes[1][i-1].xmin(), 0.1, eps);
637      EXPECT_NEAR(all_gt_bboxes[1][i-1].ymin(), 0.1, eps);
638      EXPECT_NEAR(all_gt_bboxes[1][i-1].xmax(), 0.3, eps);
639      EXPECT_NEAR(all_gt_bboxes[1][i-1].ymax(), 0.3, eps);
640      EXPECT_EQ(all_gt_bboxes[1][i-1].difficult(), i % 2);
641      EXPECT_NEAR(all_gt_bboxes[1][i-1].size(), 0.04, eps);
642    }
643    EXPECT_EQ(all_gt_bboxes[2].size(), 1);
644    EXPECT_EQ(all_gt_bboxes[2][0].label(), 3);
645    EXPECT_NEAR(all_gt_bboxes[2][0].xmin(), 0.1, eps);
646    EXPECT_NEAR(all_gt_bboxes[2][0].ymin(), 0.1, eps);
647    EXPECT_NEAR(all_gt_bboxes[2][0].xmax(), 0.3, eps);
648    EXPECT_NEAR(all_gt_bboxes[2][0].ymax(), 0.3, eps);
649    EXPECT_EQ(all_gt_bboxes[2][0].difficult(), true);
650    EXPECT_NEAR(all_gt_bboxes[2][0].size(), 0.04, eps);
651    GetGroundTruth(gt_data, num_gt, -1, false, &amp;all_gt_bboxes);
652    EXPECT_EQ(all_gt_bboxes.size(), 2);
653    EXPECT_EQ(all_gt_bboxes[0].size(), 1);
654    EXPECT_EQ(all_gt_bboxes[0][0].label(), 0);
655    EXPECT_NEAR(all_gt_bboxes[0][0].xmin(), 0.1, eps);
656    EXPECT_NEAR(all_gt_bboxes[0][0].ymin(), 0.1, eps);
657    EXPECT_NEAR(all_gt_bboxes[0][0].xmax(), 0.3, eps);
658    EXPECT_NEAR(all_gt_bboxes[0][0].ymax(), 0.3, eps);
659    EXPECT_EQ(all_gt_bboxes[0][0].difficult(), false);
660    EXPECT_NEAR(all_gt_bboxes[0][0].size(), 0.04, eps);
661    EXPECT_EQ(all_gt_bboxes[1].size(), 1);
662    EXPECT_EQ(all_gt_bboxes[1][0].label(), 2);
663    EXPECT_NEAR(all_gt_bboxes[1][0].xmin(), 0.1, eps);
664    EXPECT_NEAR(all_gt_bboxes[1][0].ymin(), 0.1, eps);
665    EXPECT_NEAR(all_gt_bboxes[1][0].xmax(), 0.3, eps);
666    EXPECT_NEAR(all_gt_bboxes[1][0].ymax(), 0.3, eps);
667    EXPECT_EQ(all_gt_bboxes[1][0].difficult(), false);
668    EXPECT_NEAR(all_gt_bboxes[1][0].size(), 0.04, eps);
669  }
670  TEST_F(CPUBBoxUtilTest, TestGetGroundTruthLabelBBox) {
671    const int num_gt = 4;
672    Blob&lt;float&gt; gt_blob(1, 1, num_gt, 8);
673    float* gt_data = gt_blob.mutable_cpu_data();
674    for (int i = 0; i &lt; 4; ++i) {
675      int image_id = ceil(i / 2.);
676      gt_data[i * 8] = image_id;
677      gt_data[i * 8 + 1] = i;
678      gt_data[i * 8 + 2] = 0;
679      gt_data[i * 8 + 3] = 0.1;
680      gt_data[i * 8 + 4] = 0.1;
681      gt_data[i * 8 + 5] = 0.3;
682      gt_data[i * 8 + 6] = 0.3;
683      gt_data[i * 8 + 7] = i % 2;
684    }
685    map&lt;int, LabelBBox&gt; all_gt_bboxes;
686    GetGroundTruth(gt_data, num_gt, -1, true, &amp;all_gt_bboxes);
687    EXPECT_EQ(all_gt_bboxes.size(), 3);
688    EXPECT_EQ(all_gt_bboxes[0].size(), 1);
689    EXPECT_EQ(all_gt_bboxes[0].find(0)-&gt;first, 0);
690    EXPECT_NEAR(all_gt_bboxes[0].find(0)-&gt;second[0].xmin(), 0.1, eps);
691    EXPECT_NEAR(all_gt_bboxes[0].find(0)-&gt;second[0].ymin(), 0.1, eps);
692    EXPECT_NEAR(all_gt_bboxes[0].find(0)-&gt;second[0].xmax(), 0.3, eps);
693    EXPECT_NEAR(all_gt_bboxes[0].find(0)-&gt;second[0].ymax(), 0.3, eps);
694    EXPECT_EQ(all_gt_bboxes[0].find(0)-&gt;second[0].difficult(), false);
695    EXPECT_NEAR(all_gt_bboxes[0].find(0)-&gt;second[0].size(), 0.04, eps);
696    EXPECT_EQ(all_gt_bboxes[1].size(), 2);
697    for (int i = 1; i &lt; 3; ++i) {
698      EXPECT_EQ(all_gt_bboxes[1].find(i)-&gt;first, i);
699      EXPECT_NEAR(all_gt_bboxes[1].find(i)-&gt;second[0].xmin(), 0.1, eps);
700      EXPECT_NEAR(all_gt_bboxes[1].find(i)-&gt;second[0].ymin(), 0.1, eps);
701      EXPECT_NEAR(all_gt_bboxes[1].find(i)-&gt;second[0].xmax(), 0.3, eps);
702      EXPECT_NEAR(all_gt_bboxes[1].find(i)-&gt;second[0].ymax(), 0.3, eps);
703      EXPECT_EQ(all_gt_bboxes[1].find(i)-&gt;second[0].difficult(), i % 2);
704      EXPECT_NEAR(all_gt_bboxes[1].find(i)-&gt;second[0].size(), 0.04, eps);
705    }
706    EXPECT_EQ(all_gt_bboxes[2].size(), 1);
707    EXPECT_EQ(all_gt_bboxes[2].find(3)-&gt;first, 3);
708    EXPECT_NEAR(all_gt_bboxes[2].find(3)-&gt;second[0].xmin(), 0.1, eps);
709    EXPECT_NEAR(all_gt_bboxes[2].find(3)-&gt;second[0].ymin(), 0.1, eps);
710    EXPECT_NEAR(all_gt_bboxes[2].find(3)-&gt;second[0].xmax(), 0.3, eps);
711    EXPECT_NEAR(all_gt_bboxes[2].find(3)-&gt;second[0].ymax(), 0.3, eps);
712    EXPECT_EQ(all_gt_bboxes[2].find(3)-&gt;second[0].difficult(), true);
713    EXPECT_NEAR(all_gt_bboxes[2].find(3)-&gt;second[0].size(), 0.04, eps);
714    GetGroundTruth(gt_data, num_gt, -1, false, &amp;all_gt_bboxes);
715    EXPECT_EQ(all_gt_bboxes.size(), 2);
716    EXPECT_EQ(all_gt_bboxes[0].size(), 1);
717    EXPECT_EQ(all_gt_bboxes[0].find(0)-&gt;first, 0);
718    EXPECT_NEAR(all_gt_bboxes[0].find(0)-&gt;second[0].xmin(), 0.1, eps);
719    EXPECT_NEAR(all_gt_bboxes[0].find(0)-&gt;second[0].ymin(), 0.1, eps);
720    EXPECT_NEAR(all_gt_bboxes[0].find(0)-&gt;second[0].xmax(), 0.3, eps);
721    EXPECT_NEAR(all_gt_bboxes[0].find(0)-&gt;second[0].ymax(), 0.3, eps);
722    EXPECT_EQ(all_gt_bboxes[0].find(0)-&gt;second[0].difficult(), false);
723    EXPECT_NEAR(all_gt_bboxes[0].find(0)-&gt;second[0].size(), 0.04, eps);
724    EXPECT_EQ(all_gt_bboxes[1].size(), 1);
725    EXPECT_EQ(all_gt_bboxes[1].find(2)-&gt;first, 2);
726    EXPECT_NEAR(all_gt_bboxes[1].find(2)-&gt;second[0].xmin(), 0.1, eps);
727    EXPECT_NEAR(all_gt_bboxes[1].find(2)-&gt;second[0].ymin(), 0.1, eps);
728    EXPECT_NEAR(all_gt_bboxes[1].find(2)-&gt;second[0].xmax(), 0.3, eps);
729    EXPECT_NEAR(all_gt_bboxes[1].find(2)-&gt;second[0].ymax(), 0.3, eps);
730    EXPECT_EQ(all_gt_bboxes[1].find(2)-&gt;second[0].difficult(), false);
731    EXPECT_NEAR(all_gt_bboxes[1].find(2)-&gt;second[0].size(), 0.04, eps);
732  }
733  TEST_F(CPUBBoxUtilTest, TestGetLocPredictionsShared) {
734    const int num = 2;
735    const int num_preds_per_class = 2;
736    const int num_loc_classes = 1;
737    const bool share_location = true;
738    const int dim = num_preds_per_class * num_loc_classes * 4;
739    Blob&lt;float&gt; loc_blob(num, dim, 1, 1);
740    float* loc_data = loc_blob.mutable_cpu_data();
741    for (int i = 0; i &lt; num; ++i) {
742      for (int j = 0; j &lt; num_preds_per_class; ++j) {
743        int start_idx = i * dim + j * 4;
744        loc_data[start_idx] = i * num_preds_per_class * 0.1 + j * 0.1;
745        loc_data[start_idx + 1] = i * num_preds_per_class * 0.1 + j * 0.1;
746        loc_data[start_idx + 2] = i * num_preds_per_class * 0.1 + j * 0.1 + 0.2;
747        loc_data[start_idx + 3] = i * num_preds_per_class * 0.1 + j * 0.1 + 0.2;
748      }
749    }
750    vector&lt;LabelBBox&gt; all_loc_bboxes;
751    GetLocPredictions(loc_data, num, num_preds_per_class, num_loc_classes,
752                      share_location, &amp;all_loc_bboxes);
753    EXPECT_EQ(all_loc_bboxes.size(), num);
754    for (int i = 0; i &lt; num; ++i) {
755      EXPECT_EQ(all_loc_bboxes[i].size(), 1);
756      LabelBBox::iterator it = all_loc_bboxes[i].begin();
757      EXPECT_EQ(it-&gt;first, -1);
758      const vector&lt;NormalizedBBox&gt;&amp; bboxes = it-&gt;second;
759      EXPECT_EQ(bboxes.size(), num_preds_per_class);
760      float start_value = i * num_preds_per_class * 0.1;
761      for (int j = 0; j &lt; num_preds_per_class; ++j) {
762        EXPECT_EQ(bboxes[j].has_label(), false);
763        EXPECT_NEAR(bboxes[j].xmin(), start_value + j * 0.1, eps);
764        EXPECT_NEAR(bboxes[j].ymin(), start_value + j * 0.1, eps);
765        EXPECT_NEAR(bboxes[j].xmax(), start_value + j * 0.1 + 0.2, eps);
766        EXPECT_NEAR(bboxes[j].ymax(), start_value + j * 0.1 + 0.2, eps);
767        EXPECT_EQ(bboxes[j].has_size(), false);
768      }
769    }
770  }
771  TEST_F(CPUBBoxUtilTest, TestGetLocPredictionsUnShared) {
772    const int num = 2;
773    const int num_preds_per_class = 2;
774    const int num_loc_classes = 2;
775    const bool share_location = false;
776    const int dim = num_preds_per_class * num_loc_classes * 4;
777    Blob&lt;float&gt; loc_blob(num, dim, 1, 1);
778    float* loc_data = loc_blob.mutable_cpu_data();
779    for (int i = 0; i &lt; num; ++i) {
780      for (int j = 0; j &lt; num_preds_per_class; ++j) {
781        float start_value = (i * num_preds_per_class + j) * num_loc_classes * 0.1;
782        for (int c = 0; c &lt; num_loc_classes; ++c) {
783          int idx = ((i * num_preds_per_class + j) * num_loc_classes + c) * 4;
784          loc_data[idx] = start_value + c * 0.1;
785          loc_data[idx + 1] = start_value + c * 0.1;
786          loc_data[idx + 2] = start_value + c * 0.1 + 0.2;
787          loc_data[idx + 3] = start_value + c * 0.1 + 0.2;
788        }
789      }
790    }
791    vector&lt;LabelBBox&gt; all_loc_bboxes;
792    GetLocPredictions(loc_data, num, num_preds_per_class, num_loc_classes,
793                      share_location, &amp;all_loc_bboxes);
794    EXPECT_EQ(all_loc_bboxes.size(), num);
795    for (int i = 0; i &lt; num; ++i) {
796      EXPECT_EQ(all_loc_bboxes[i].size(), num_loc_classes);
797      for (int c = 0; c &lt; num_loc_classes; ++c) {
798        LabelBBox::iterator it = all_loc_bboxes[i].find(c);
799        EXPECT_EQ(it-&gt;first, c);
800        const vector&lt;NormalizedBBox&gt;&amp; bboxes = it-&gt;second;
801        EXPECT_EQ(bboxes.size(), num_preds_per_class);
802        for (int j = 0; j &lt; num_preds_per_class; ++j) {
803          float start_value =
804              (i * num_preds_per_class + j) * num_loc_classes * 0.1;
805          EXPECT_EQ(bboxes[j].has_label(), false);
806          EXPECT_NEAR(bboxes[j].xmin(), start_value + c * 0.1, eps);
807          EXPECT_NEAR(bboxes[j].ymin(), start_value + c * 0.1, eps);
808          EXPECT_NEAR(bboxes[j].xmax(), start_value + c * 0.1 + 0.2, eps);
809          EXPECT_NEAR(bboxes[j].ymax(), start_value + c * 0.1 + 0.2, eps);
810          EXPECT_EQ(bboxes[j].has_size(), false);
811        }
812      }
813    }
814  }
815  TEST_F(CPUBBoxUtilTest, TestGetConfidenceScores) {
816    const int num = 2;
817    const int num_preds_per_class = 2;
818    const int num_classes = 2;
819    const int dim = num_preds_per_class * num_classes;
820    Blob&lt;float&gt; conf_blob(num, dim, 1, 1);
821    float* conf_data = conf_blob.mutable_cpu_data();
822    for (int i = 0; i &lt; num; ++i) {
823      for (int j = 0; j &lt; num_preds_per_class; ++j) {
824        for (int c = 0; c &lt; num_classes; ++c) {
825          int idx = (i * num_preds_per_class + j) * num_classes + c;
826          conf_data[idx] = idx * 0.1;
827        }
828      }
829    }
830    vector&lt;map&lt;int, vector&lt;float&gt; &gt; &gt; all_conf_preds;
831    GetConfidenceScores(conf_data, num, num_preds_per_class, num_classes,
832                        &amp;all_conf_preds);
833    EXPECT_EQ(all_conf_preds.size(), num);
834    for (int i = 0; i &lt; num; ++i) {
835      EXPECT_EQ(all_conf_preds[i].size(), num_classes);
836      for (int c = 0; c &lt; num_classes; ++c) {
837        map&lt;int, vector&lt;float&gt; &gt;::iterator it = all_conf_preds[i].find(c);
838        EXPECT_EQ(it-&gt;first, c);
839        const vector&lt;float&gt;&amp; confidences = it-&gt;second;
840        EXPECT_EQ(confidences.size(), num_preds_per_class);
841        for (int j = 0; j &lt; num_preds_per_class; ++j) {
842          int idx = (i * num_preds_per_class + j) * num_classes + c;
843          EXPECT_NEAR(confidences[j], idx * 0.1, eps);
844        }
845      }
846    }
847  }
848  TEST_F(CPUBBoxUtilTest, TestComputeConfLoss) {
849    const int num = 2;
850    const int num_preds_per_class = 2;
851    const int num_classes = 2;
852    const int dim = num_preds_per_class * num_classes;
853    Blob&lt;float&gt; conf_blob(num, dim, 1, 1);
854    float* conf_data = conf_blob.mutable_cpu_data();
855    for (int i = 0; i &lt; num; ++i) {
856      int sign = i % 2 ? 1 : -1;
857      for (int j = 0; j &lt; num_preds_per_class; ++j) {
858        for (int c = 0; c &lt; num_classes; ++c) {
859          int idx = (i * num_preds_per_class + j) * num_classes + c;
860          conf_data[idx] = sign * idx * 0.1;
861        }
862      }
863    }
864    vector&lt;vector&lt;float&gt; &gt; all_conf_loss;
865    ConfLossType loss_type = MultiBoxLossParameter_ConfLossType_LOGISTIC;
866    ComputeConfLoss(conf_data, num, num_preds_per_class, num_classes,
867                    -1, loss_type, &amp;all_conf_loss);
868    EXPECT_EQ(all_conf_loss.size(), num);
869    EXPECT_EQ(all_conf_loss[0].size(), num_preds_per_class);
870    EXPECT_NEAR(all_conf_loss[0][0],
871                -(log(exp(0.)/(1.+exp(0.))) + log(exp(0.1)/(1+exp(0.1)))), eps);
872    EXPECT_NEAR(all_conf_loss[0][1],
873                -(log(exp(0.2)/(1.+exp(0.2))) + log(exp(0.3)/(1+exp(0.3)))), eps);
874    EXPECT_EQ(all_conf_loss[1].size(), num_preds_per_class);
875    EXPECT_NEAR(all_conf_loss[1][0],
876                -(log(exp(-0.4)/(1.+exp(-0.4))) + log(exp(-0.5)/(1+exp(-0.5)))),
877                eps);
878    EXPECT_NEAR(all_conf_loss[1][1],
879                -(log(exp(-0.6)/(1.+exp(-0.6))) + log(exp(-0.7)/(1+exp(-0.7)))),
880                eps);
881    ComputeConfLoss(conf_data, num, num_preds_per_class, num_classes,
882                    0, loss_type, &amp;all_conf_loss);
883    EXPECT_EQ(all_conf_loss.size(), num);
884    EXPECT_EQ(all_conf_loss[0].size(), num_preds_per_class);
885    EXPECT_NEAR(all_conf_loss[0][0],
886                -(log(1./(1.+exp(0.))) + log(exp(0.1)/(1+exp(0.1)))), eps);
887    EXPECT_NEAR(all_conf_loss[0][1],
888                -(log(1./(1.+exp(0.2))) + log(exp(0.3)/(1+exp(0.3)))), eps);
889    EXPECT_EQ(all_conf_loss[1].size(), num_preds_per_class);
890    EXPECT_NEAR(all_conf_loss[1][0],
891                -(log(1./(1.+exp(-0.4))) + log(exp(-0.5)/(1+exp(-0.5)))), eps);
892    EXPECT_NEAR(all_conf_loss[1][1],
893                -(log(1./(1.+exp(-0.6))) + log(exp(-0.7)/(1+exp(-0.7)))), eps);
894    loss_type = MultiBoxLossParameter_ConfLossType_SOFTMAX;
895    ComputeConfLoss(conf_data, num, num_preds_per_class, num_classes,
896                    0, loss_type, &amp;all_conf_loss);
897    EXPECT_EQ(all_conf_loss.size(), num);
898    for (int i = 0; i &lt; num; ++i) {
899      EXPECT_EQ(all_conf_loss[i].size(), num_preds_per_class);
900      int sign = i % 2 ? 1 : -1;
901      for (int j = 0; j &lt; num_preds_per_class; ++j) {
902        if (sign == 1) {
903          EXPECT_NEAR(all_conf_loss[i][j], -log(exp(-0.1)/(1+exp(-0.1))), eps);
904        } else {
905          EXPECT_NEAR(all_conf_loss[i][j], -log(1./(1+exp(-0.1))), eps);
906        }
907      }
908    }
909  }
910  TEST_F(CPUBBoxUtilTest, TestComputeConfLossMatch) {
911    const int num = 2;
912    const int num_preds_per_class = 2;
913    const int num_classes = 2;
914    const int dim = num_preds_per_class * num_classes;
915    Blob&lt;float&gt; conf_blob(num, dim, 1, 1);
916    float* conf_data = conf_blob.mutable_cpu_data();
917    vector&lt;map&lt;int, vector&lt;int&gt; &gt; &gt; all_match_indices;
918    map&lt;int, vector&lt;NormalizedBBox&gt; &gt; all_gt_bboxes;
919    for (int i = 0; i &lt; num; ++i) {
920      int sign = i % 2 ? 1 : -1;
921      for (int j = 0; j &lt; num_preds_per_class; ++j) {
922        for (int c = 0; c &lt; num_classes; ++c) {
923          int idx = (i * num_preds_per_class + j) * num_classes + c;
924          conf_data[idx] = sign * idx * 0.1;
925        }
926      }
927      map&lt;int, vector&lt;int&gt; &gt; match_indices;
928      vector&lt;int&gt; indices(num_preds_per_class, -1);
929      match_indices[-1] = indices;
930      if (i == 1) {
931        NormalizedBBox gt_bbox;
932        gt_bbox.set_label(1);
933        all_gt_bboxes[i].push_back(gt_bbox);
934        match_indices[-1][0] = 0;
935      }
936      all_match_indices.push_back(match_indices);
937    }
938    vector&lt;vector&lt;float&gt; &gt; all_conf_loss;
939    ConfLossType loss_type = MultiBoxLossParameter_ConfLossType_LOGISTIC;
940    ComputeConfLoss(conf_data, num, num_preds_per_class, num_classes,
941                    -1, loss_type, all_match_indices, all_gt_bboxes,
942                    &amp;all_conf_loss);
943    EXPECT_EQ(all_conf_loss.size(), num);
944    EXPECT_EQ(all_conf_loss[0].size(), num_preds_per_class);
945    EXPECT_NEAR(all_conf_loss[0][0],
946                -(log(exp(0.)/(1.+exp(0.))) + log(exp(0.1)/(1+exp(0.1)))), eps);
947    EXPECT_NEAR(all_conf_loss[0][1],
948                -(log(exp(0.2)/(1.+exp(0.2))) + log(exp(0.3)/(1+exp(0.3)))), eps);
949    EXPECT_EQ(all_conf_loss[1].size(), num_preds_per_class);
950    EXPECT_NEAR(all_conf_loss[1][0],
951                -(log(exp(-0.4)/(1.+exp(-0.4))) + log(1./(1+exp(-0.5)))),
952                eps);
953    EXPECT_NEAR(all_conf_loss[1][1],
954                -(log(exp(-0.6)/(1.+exp(-0.6))) + log(exp(-0.7)/(1+exp(-0.7)))),
955                eps);
956    ComputeConfLoss(conf_data, num, num_preds_per_class, num_classes,
957                    0, loss_type, all_match_indices, all_gt_bboxes,
958                    &amp;all_conf_loss);
959    EXPECT_EQ(all_conf_loss.size(), num);
960    EXPECT_EQ(all_conf_loss[0].size(), num_preds_per_class);
961    EXPECT_NEAR(all_conf_loss[0][0],
962                -(log(1./(1.+exp(0.))) + log(exp(0.1)/(1+exp(0.1)))), eps);
963    EXPECT_NEAR(all_conf_loss[0][1],
964                -(log(1./(1.+exp(0.2))) + log(exp(0.3)/(1+exp(0.3)))), eps);
965    EXPECT_EQ(all_conf_loss[1].size(), num_preds_per_class);
966    EXPECT_NEAR(all_conf_loss[1][0],
967                -(log(exp(-0.4)/(1.+exp(-0.4))) + log(1./(1+exp(-0.5)))), eps);
968    EXPECT_NEAR(all_conf_loss[1][1],
969                -(log(1./(1.+exp(-0.6))) + log(exp(-0.7)/(1+exp(-0.7)))), eps);
970    loss_type = MultiBoxLossParameter_ConfLossType_SOFTMAX;
971    ComputeConfLoss(conf_data, num, num_preds_per_class, num_classes,
972                    0, loss_type, all_match_indices, all_gt_bboxes,
973                    &amp;all_conf_loss);
974    EXPECT_EQ(all_conf_loss.size(), num);
975    for (int i = 0; i &lt; num; ++i) {
976      EXPECT_EQ(all_conf_loss[i].size(), num_preds_per_class);
977      int sign = i % 2 ? 1 : -1;
978      for (int j = 0; j &lt; num_preds_per_class; ++j) {
979        if (sign == 1) {
980          if (j == 0) {
981            EXPECT_NEAR(all_conf_loss[i][j], -log(1./(1+exp(-0.1))), eps);
982          } else {
983            EXPECT_NEAR(all_conf_loss[i][j], -log(exp(-0.1)/(1+exp(-0.1))), eps);
984          }
985        } else {
986          EXPECT_NEAR(all_conf_loss[i][j], -log(1./(1+exp(-0.1))), eps);
987        }
988      }
989    }
990  }
991  TEST_F(CPUBBoxUtilTest, TestGetPriorBBoxes) {
992    const int num_channels = 2;
993    const int num_priors = 2;
994    const int dim = num_priors * 4;
995    Blob&lt;float&gt; prior_blob(1, num_channels, dim, 1);
996    float* prior_data = prior_blob.mutable_cpu_data();
997    for (int i = 0; i &lt; num_priors; ++i) {
998      prior_data[i * 4] = i * 0.1;
999      prior_data[i * 4 + 1] = i * 0.1;
1000      prior_data[i * 4 + 2] = i * 0.1 + 0.2;
1001      prior_data[i * 4 + 3] = i * 0.1 + 0.1;
1002      for (int j = 0; j &lt; 4; ++j) {
1003        prior_data[dim + i * 4 + j]  = 0.1;
1004      }
1005    }
1006    vector&lt;NormalizedBBox&gt; prior_bboxes(num_priors);
1007    vector&lt;vector&lt;float&gt; &gt; prior_variances(num_priors);
1008    GetPriorBBoxes(prior_data, num_priors, &amp;prior_bboxes, &amp;prior_variances);
1009    EXPECT_EQ(prior_bboxes.size(), num_priors);
1010    EXPECT_EQ(prior_variances.size(), num_priors);
1011    for (int i = 0; i &lt; num_priors; ++i) {
1012      EXPECT_NEAR(prior_bboxes[i].xmin(), i * 0.1, eps);
1013      EXPECT_NEAR(prior_bboxes[i].ymin(), i * 0.1, eps);
1014      EXPECT_NEAR(prior_bboxes[i].xmax(), i * 0.1 + 0.2, eps);
1015      EXPECT_NEAR(prior_bboxes[i].ymax(), i * 0.1 + 0.1, eps);
1016      EXPECT_EQ(prior_variances[i].size(), 4);
1017      for (int j = 0; j &lt; 4; ++j) {
1018        EXPECT_NEAR(prior_variances[i][j], 0.1, eps);
1019      }
1020    }
1021  }
1022  TEST_F(CPUBBoxUtilTest, TestGetDetectionResults) {
1023    const int num = 4;
1024    const int num_det = (1 + num) * num / 2;
1025    Blob&lt;float&gt; det_blob(1, 1, num_det, 7);
1026    float* det_data = det_blob.mutable_cpu_data();
1027    int idx = 0;
1028    for (int i = 0; i &lt; num; ++i) {
1029      int image_id = ceil(i / 2.);
1030      for (int j = 0; j &lt;= i; ++j) {
1031        det_data[idx * 7] = image_id;
1032        det_data[idx * 7 + 1] = i;
1033        det_data[idx * 7 + 2] = 0;
1034        det_data[idx * 7 + 3] = 0.1 + j * 0.1;
1035        det_data[idx * 7 + 4] = 0.1 + j * 0.1;
1036        det_data[idx * 7 + 5] = 0.3 + j * 0.1;
1037        det_data[idx * 7 + 6] = 0.3 + j * 0.1;
1038        ++idx;
1039      }
1040    }
1041    CHECK_EQ(idx, num_det);
1042    map&lt;int, LabelBBox&gt; all_detections;
1043    GetDetectionResults(det_data, num_det, -1, &amp;all_detections);
1044    EXPECT_EQ(all_detections.size(), 3);
1045    EXPECT_EQ(all_detections[0].size(), 1);
1046    EXPECT_EQ(all_detections[0].find(0)-&gt;first, 0);
1047    EXPECT_EQ(all_detections[0].find(0)-&gt;second.size(), 1);
1048    EXPECT_NEAR(all_detections[0].find(0)-&gt;second[0].xmin(), 0.1, eps);
1049    EXPECT_NEAR(all_detections[0].find(0)-&gt;second[0].ymin(), 0.1, eps);
1050    EXPECT_NEAR(all_detections[0].find(0)-&gt;second[0].xmax(), 0.3, eps);
1051    EXPECT_NEAR(all_detections[0].find(0)-&gt;second[0].ymax(), 0.3, eps);
1052    EXPECT_NEAR(all_detections[0].find(0)-&gt;second[0].size(), 0.04, eps);
1053    EXPECT_EQ(all_detections[1].size(), 2);
1054    for (int i = 1; i &lt; 3; ++i) {
1055      EXPECT_EQ(all_detections[1].find(i)-&gt;first, i);
1056      EXPECT_EQ(all_detections[1].find(i)-&gt;second.size(), i + 1);
1057      for (int j = 0; j &lt;= i; ++j) {
1058        EXPECT_NEAR(all_detections[1].find(i)-&gt;second[j].xmin(),
1059                    0.1 + j * 0.1, eps);
1060        EXPECT_NEAR(all_detections[1].find(i)-&gt;second[j].ymin(),
1061                    0.1 + j * 0.1, eps);
1062        EXPECT_NEAR(all_detections[1].find(i)-&gt;second[j].xmax(),
1063                    0.3 + j * 0.1, eps);
1064        EXPECT_NEAR(all_detections[1].find(i)-&gt;second[j].ymax(),
1065                    0.3 + j * 0.1, eps);
1066        EXPECT_NEAR(all_detections[1].find(i)-&gt;second[j].size(), 0.04, eps);
1067      }
1068    }
1069    EXPECT_EQ(all_detections[2].size(), 1);
1070    EXPECT_EQ(all_detections[2].find(3)-&gt;first, 3);
1071    EXPECT_EQ(all_detections[2].find(3)-&gt;second.size(), 4);
1072    for (int j = 0; j &lt;= 3; ++j) {
1073      EXPECT_NEAR(all_detections[2].find(3)-&gt;second[j].xmin(),
1074                  0.1 + j * 0.1, eps);
1075      EXPECT_NEAR(all_detections[2].find(3)-&gt;second[j].ymin(),
1076                  0.1 + j * 0.1, eps);
1077      EXPECT_NEAR(all_detections[2].find(3)-&gt;second[j].xmax(),
1078                  0.3 + j * 0.1, eps);
1079      EXPECT_NEAR(all_detections[2].find(3)-&gt;second[j].ymax(),
1080                  0.3 + j * 0.1, eps);
1081      EXPECT_NEAR(all_detections[2].find(3)-&gt;second[j].size(), 0.04, eps);
1082    }
1083  }
1084  TEST_F(CPUBBoxUtilTest, TestApplyNMS) {
1085    vector&lt;NormalizedBBox&gt; bboxes;
1086    vector&lt;float&gt; scores;
1087    float nms_threshold = 0.3;
1088    int top_k = -1;
1089    bool reuse_overlaps = false;
1090    map&lt;int, map&lt;int, float&gt; &gt; overlaps;
1091    vector&lt;int&gt; indices;
1092    NormalizedBBox bbox;
1093    bbox.set_xmin(0.1);
1094    bbox.set_ymin(0.1);
1095    bbox.set_xmax(0.3);
1096    bbox.set_ymax(0.3);
1097    bboxes.push_back(bbox);
1098    scores.push_back(0.8);
1099    bbox.set_xmin(0.2);
1100    bbox.set_ymin(0.1);
1101    bbox.set_xmax(0.4);
1102    bbox.set_ymax(0.3);
1103    bboxes.push_back(bbox);
1104    scores.push_back(0.7);
1105    bbox.set_xmin(0.2);
1106    bbox.set_ymin(0.0);
1107    bbox.set_xmax(0.4);
1108    bbox.set_ymax(0.2);
1109    bboxes.push_back(bbox);
1110    scores.push_back(0.4);
1111    bbox.set_xmin(0.1);
1112    bbox.set_ymin(0.2);
1113    bbox.set_xmax(0.4);
1114    bbox.set_ymax(0.4);
1115    bboxes.push_back(bbox);
1116    scores.push_back(0.5);
1117    ApplyNMS(bboxes, scores, nms_threshold, top_k, reuse_overlaps, &amp;overlaps,
1118             &amp;indices);
1119    EXPECT_EQ(overlaps.size(), 0);  
1120    EXPECT_EQ(indices.size(), 3);
1121    EXPECT_EQ(indices[0], 0);
1122    EXPECT_EQ(indices[1], 3);
1123    EXPECT_EQ(indices[2], 2);
1124    top_k = 2;
1125    ApplyNMS(bboxes, scores, nms_threshold, top_k, reuse_overlaps, &amp;overlaps,
1126             &amp;indices);
1127    EXPECT_EQ(indices.size(), 1);
1128    EXPECT_EQ(indices[0], 0);
1129    top_k = 3;
1130    nms_threshold = 0.2;
1131    ApplyNMS(bboxes, scores, nms_threshold, top_k, reuse_overlaps, &amp;overlaps,
1132             &amp;indices);
1133    EXPECT_EQ(indices.size(), 1);
1134    EXPECT_EQ(indices[0], 0);
1135    reuse_overlaps = true;
1136    ApplyNMS(bboxes, scores, nms_threshold, top_k, reuse_overlaps, &amp;overlaps,
1137             &amp;indices);
1138    EXPECT_EQ(overlaps.size(), 1);
1139    EXPECT_NEAR(overlaps[0][1], 1./3, eps);
1140    EXPECT_NEAR(overlaps[0][2], 0.0, eps);
1141    EXPECT_NEAR(overlaps[0][3], 2./8, eps);
1142    map&lt;int, map&lt;int, float&gt; &gt; old_overlaps = overlaps;
1143    ApplyNMS(bboxes, scores, nms_threshold, top_k, reuse_overlaps, &amp;overlaps,
1144             &amp;indices);
1145    EXPECT_EQ(old_overlaps.size(), overlaps.size());
1146    for (int i = 1; i &lt;= 3; ++i) {
1147      EXPECT_NEAR(old_overlaps[0][i], overlaps[0][i], eps);
1148    }
1149  }
1150  TEST_F(CPUBBoxUtilTest, TestApplyNMSFast) {
1151    vector&lt;NormalizedBBox&gt; bboxes;
1152    vector&lt;float&gt; scores;
1153    float score_threshold = 0.;
1154    float nms_threshold = 0.3;
1155    float eta = 1.;
1156    int top_k = -1;
1157    vector&lt;int&gt; indices;
1158    NormalizedBBox bbox;
1159    bbox.set_xmin(0.1);
1160    bbox.set_ymin(0.1);
1161    bbox.set_xmax(0.3);
1162    bbox.set_ymax(0.3);
1163    bboxes.push_back(bbox);
1164    scores.push_back(0.8);
1165    bbox.set_xmin(0.2);
1166    bbox.set_ymin(0.1);
1167    bbox.set_xmax(0.4);
1168    bbox.set_ymax(0.3);
1169    bboxes.push_back(bbox);
1170    scores.push_back(0.7);
1171    bbox.set_xmin(0.2);
1172    bbox.set_ymin(0.0);
1173    bbox.set_xmax(0.4);
1174    bbox.set_ymax(0.2);
1175    bboxes.push_back(bbox);
1176    scores.push_back(0.4);
1177    bbox.set_xmin(0.1);
1178    bbox.set_ymin(0.2);
1179    bbox.set_xmax(0.4);
1180    bbox.set_ymax(0.4);
1181    bboxes.push_back(bbox);
1182    scores.push_back(0.5);
1183    ApplyNMSFast(bboxes, scores, score_threshold, nms_threshold, eta, top_k,
1184                 &amp;indices);
1185    EXPECT_EQ(indices.size(), 3);
1186    EXPECT_EQ(indices[0], 0);
1187    EXPECT_EQ(indices[1], 3);
1188    EXPECT_EQ(indices[2], 2);
1189    top_k = 2;
1190    ApplyNMSFast(bboxes, scores, score_threshold, nms_threshold, eta, top_k,
1191                 &amp;indices);
1192    EXPECT_EQ(indices.size(), 1);
1193    EXPECT_EQ(indices[0], 0);
1194    top_k = 3;
1195    nms_threshold = 0.2;
1196    ApplyNMSFast(bboxes, scores, score_threshold, nms_threshold, eta, top_k,
1197                 &amp;indices);
1198    EXPECT_EQ(indices.size(), 1);
1199    EXPECT_EQ(indices[0], 0);
1200    top_k = -1;
1201    score_threshold = 0.5;
1202    ApplyNMSFast(bboxes, scores, score_threshold, nms_threshold, eta, top_k,
1203                 &amp;indices);
1204    EXPECT_EQ(indices.size(), 1);
1205    EXPECT_EQ(indices[0], 0);
1206  }
1207  TEST_F(CPUBBoxUtilTest, TestCumSum) {
1208    vector&lt;pair&lt;float, int&gt; &gt; pairs;
1209    vector&lt;int&gt; cumsum;
1210    pairs.push_back(std::make_pair(0.1, 0));
1211    pairs.push_back(std::make_pair(0.2, 1));
1212    pairs.push_back(std::make_pair(0.3, 0));
1213    CumSum(pairs, &amp;cumsum);
1214    EXPECT_EQ(cumsum.size(), 3);
1215    EXPECT_EQ(cumsum[0], 0);
1216    EXPECT_EQ(cumsum[1], 1);
1217    EXPECT_EQ(cumsum[2], 1);
1218  }
1219  TEST_F(CPUBBoxUtilTest, TestComputeAP) {
1220    vector&lt;pair&lt;float, int&gt; &gt; tp;
1221    vector&lt;pair&lt;float, int&gt; &gt; fp;
1222    tp.push_back(std::make_pair(1.0, 0));
1223    tp.push_back(std::make_pair(1.0, 1));
1224    tp.push_back(std::make_pair(0.9, 1));
1225    tp.push_back(std::make_pair(0.9, 0));
1226    tp.push_back(std::make_pair(0.8, 1));
1227    tp.push_back(std::make_pair(0.7, 0));
1228    tp.push_back(std::make_pair(0.7, 1));
1229    tp.push_back(std::make_pair(0.6, 0));
1230    tp.push_back(std::make_pair(0.5, 0));
1231    tp.push_back(std::make_pair(0.4, 0));
1232    tp.push_back(std::make_pair(0.4, 1));
1233    fp.push_back(std::make_pair(1.0, 1));
1234    fp.push_back(std::make_pair(1.0, 0));
1235    fp.push_back(std::make_pair(0.9, 0));
1236    fp.push_back(std::make_pair(0.9, 1));
1237    fp.push_back(std::make_pair(0.8, 0));
1238    fp.push_back(std::make_pair(0.7, 1));
1239    fp.push_back(std::make_pair(0.7, 0));
1240    fp.push_back(std::make_pair(0.6, 1));
1241    fp.push_back(std::make_pair(0.5, 1));
1242    fp.push_back(std::make_pair(0.4, 1));
1243    fp.push_back(std::make_pair(0.4, 0));
1244    float eps = 1e-5;
1245    vector&lt;float&gt; prec, rec;
1246    float ap;
1247    ComputeAP(tp, 5, fp, &quot;Integral&quot;, &amp;prec, &amp;rec, &amp;ap);
1248    EXPECT_NEAR(ap, 0.558528, eps);
1249    EXPECT_EQ(prec.size(), 11);
1250    EXPECT_NEAR(prec[0], 0.0/1.0, eps);
1251    EXPECT_NEAR(prec[1], 1.0/2.0, eps);
1252    EXPECT_NEAR(prec[2], 2.0/3.0, eps);
1253    EXPECT_NEAR(prec[3], 2.0/4.0, eps);
1254    EXPECT_NEAR(prec[4], 3.0/5.0, eps);
1255    EXPECT_NEAR(prec[5], 3.0/6.0, eps);
1256    EXPECT_NEAR(prec[6], 4.0/7.0, eps);
1257    EXPECT_NEAR(prec[7], 4.0/8.0, eps);
1258    EXPECT_NEAR(prec[8], 4.0/9.0, eps);
1259    EXPECT_NEAR(prec[9], 4.0/10.0, eps);
1260    EXPECT_NEAR(prec[10], 5.0/11.0, eps);
1261    EXPECT_EQ(rec.size(), 11);
1262    EXPECT_NEAR(rec[0], 0.0, eps);
1263    EXPECT_NEAR(rec[1], 0.2, eps);
1264    EXPECT_NEAR(rec[2], 0.4, eps);
1265    EXPECT_NEAR(rec[3], 0.4, eps);
1266    EXPECT_NEAR(rec[4], 0.6, eps);
1267    EXPECT_NEAR(rec[5], 0.6, eps);
1268    EXPECT_NEAR(rec[6], 0.8, eps);
1269    EXPECT_NEAR(rec[7], 0.8, eps);
1270    EXPECT_NEAR(rec[8], 0.8, eps);
1271    EXPECT_NEAR(rec[9], 0.8, eps);
1272    EXPECT_NEAR(rec[10], 1.0, eps);
1273    vector&lt;float&gt; prec_old = prec;
1274    vector&lt;float&gt; rec_old = rec;
1275    ComputeAP(tp, 5, fp, &quot;MaxIntegral&quot;, &amp;prec, &amp;rec, &amp;ap);
1276    EXPECT_NEAR(ap, 0.591861, eps);
1277    EXPECT_EQ(prec.size(), 11);
1278    EXPECT_EQ(rec.size(), 11);
1279    for (int i = 0; i &lt; 11; ++i) {
1280      EXPECT_NEAR(prec_old[i], prec[i], eps);
1281      EXPECT_NEAR(rec_old[i], rec[i], eps);
1282    }
1283    ComputeAP(tp, 5, fp, &quot;11point&quot;, &amp;prec, &amp;rec, &amp;ap);
1284    EXPECT_NEAR(ap, 0.598662, eps);
1285    EXPECT_EQ(prec.size(), 11);
1286    EXPECT_EQ(rec.size(), 11);
1287    for (int i = 0; i &lt; 11; ++i) {
1288      EXPECT_NEAR(prec_old[i], prec[i], eps);
1289      EXPECT_NEAR(rec_old[i], rec[i], eps);
1290    }
1291    tp.resize(7);
1292    fp.resize(7);
1293    ComputeAP(tp, 5, fp, &quot;Integral&quot;, &amp;prec, &amp;rec, &amp;ap);
1294    EXPECT_NEAR(ap, 0.558528 - prec_old.back() * 0.2, eps);
1295    EXPECT_EQ(prec.size(), 7);
1296    EXPECT_EQ(rec.size(), 7);
1297    for (int i = 0; i &lt; 7; ++i) {
1298      EXPECT_NEAR(prec_old[i], prec[i], eps);
1299      EXPECT_NEAR(rec_old[i], rec[i], eps);
1300    }
1301    ComputeAP(tp, 5, fp, &quot;MaxIntegral&quot;, &amp;prec, &amp;rec, &amp;ap);
1302    EXPECT_NEAR(ap, 0.591861 - prec_old.back() * 0.2, eps);
1303    EXPECT_EQ(prec.size(), 7);
1304    EXPECT_EQ(rec.size(), 7);
1305    for (int i = 0; i &lt; 7; ++i) {
1306      EXPECT_NEAR(prec_old[i], prec[i], eps);
1307      EXPECT_NEAR(rec_old[i], rec[i], eps);
1308    }
1309    ComputeAP(tp, 5, fp, &quot;11point&quot;, &amp;prec, &amp;rec, &amp;ap);
1310    EXPECT_NEAR(ap, 0.598662 - prec_old.back() * 2 / 11., eps);
1311    EXPECT_EQ(prec.size(), 7);
1312    EXPECT_EQ(rec.size(), 7);
1313    for (int i = 0; i &lt; 7; ++i) {
1314      EXPECT_NEAR(prec_old[i], prec[i], eps);
1315      EXPECT_NEAR(rec_old[i], rec[i], eps);
1316    }
1317  }
1318  #ifndef CPU_ONLY
1319  template &lt;typename Dtype&gt;
1320  void FillBBoxes(Dtype* gt_bboxes, Dtype* pred_bboxes) {
1321  }
1322  template &lt;typename Dtype&gt;
1323  class GPUBBoxUtilTest : public BBoxUtilTest&lt;GPUDevice&lt;Dtype&gt; &gt; {
1324  };
1325  TYPED_TEST_CASE(GPUBBoxUtilTest, TestDtypes);
1326  TYPED_TEST(GPUBBoxUtilTest, TestBBoxSize) {
1327    float size;
1328    Blob&lt;TypeParam&gt; bbox(1, 1, 1, 4);
1329    TypeParam* bbox_data = bbox.mutable_cpu_data();
1330    bbox_data[0] = 0.2;
1331    bbox_data[1] = 0.3;
1332    bbox_data[2] = 0.3;
1333    bbox_data[3] = 0.5;
1334    size = BBoxSizeGPU(bbox_data);
1335    EXPECT_NEAR(size, 0.02, eps);
1336    bbox_data[2] = 0.2;
1337    size = BBoxSizeGPU(bbox_data);
1338    EXPECT_NEAR(size, 0., eps);
1339    bbox_data[2] = 0.1;
1340    size = BBoxSizeGPU(bbox_data);
1341    EXPECT_NEAR(size, 0., eps);
1342  }
<span onclick='openModal()' class='match'>1343  TYPED_TEST(GPUBBoxUtilTest, TestJaccardOverlap) {
1344    float overlap;
1345    Blob&lt;TypeParam&gt; bbox1(1, 1, 1, 4);
1346    TypeParam* bbox1_data = bbox1.mutable_cpu_data();
1347    bbox1_data[0] = 0.2;
1348    bbox1_data[1] = 0.3;
1349    bbox1_data[2] = 0.3;
1350    bbox1_data[3] = 0.5;
1351    Blob&lt;TypeParam&gt; bbox2(1, 1, 1, 4);
</span>1352    TypeParam* bbox2_data = bbox2.mutable_cpu_data();
1353    bbox2_data[0] = 0.1;
1354    bbox2_data[1] = 0.1;
1355    bbox2_data[2] = 0.3;
1356    bbox2_data[3] = 0.4;
1357    overlap = JaccardOverlapGPU(bbox1_data, bbox2_data);
1358    EXPECT_NEAR(overlap, 1./7, eps);
1359    bbox2_data[0] = 0.1;
1360    bbox2_data[1] = 0.1;
1361    bbox2_data[2] = 0.4;
1362    bbox2_data[3] = 0.6;
1363    overlap = JaccardOverlapGPU(bbox1_data, bbox2_data);
1364    EXPECT_NEAR(overlap, 2./15, eps);
1365    bbox2_data[0] = 0.;
1366    bbox2_data[1] = 0.;
1367    bbox2_data[2] = 0.1;
1368    bbox2_data[3] = 0.1;
1369    overlap = JaccardOverlapGPU(bbox1_data, bbox2_data);
1370    EXPECT_NEAR(overlap, 0., eps);
1371  }
1372  TYPED_TEST(GPUBBoxUtilTest, TestDecodeBBoxesCorner) {
1373    int num = 4;
1374    Blob&lt;TypeParam&gt; prior_bboxes(1, 2, num * 4, 1);
1375    TypeParam* prior_data = prior_bboxes.mutable_cpu_data();
1376    Blob&lt;TypeParam&gt; loc_preds(1, num * 4, 1, 1);
1377    TypeParam* loc_data = loc_preds.mutable_cpu_data();
1378    for (int i = 1; i &lt;= num; ++i) {
1379      prior_data[(i - 1) * 4] = 0.1 * i;
1380      prior_data[(i - 1) * 4 + 1] = 0.1 * i;
1381      prior_data[(i - 1) * 4 + 2] = 0.1 * i + 0.2;
1382      prior_data[(i - 1) * 4 + 3] = 0.1 * i + 0.2;
1383      for (int j = 0; j &lt; 4; ++j) {
1384        prior_data[num * 4 + (i - 1) * 4 + j] = 0.1;
1385      }
1386      loc_data[(i - 1) * 4] = -1 * (i % 2);
1387      loc_data[(i - 1) * 4 + 1] = ((i + 1) % 2);
1388      loc_data[(i - 1) * 4 + 2] = ((i + 1) % 2);
1389      loc_data[(i - 1) * 4 + 3] = i % 2;
1390    }
1391    CodeType code_type = PriorBoxParameter_CodeType_CORNER;
1392    Blob&lt;TypeParam&gt; bboxes(1, num * 4, 1, 1);
1393    TypeParam* bbox_data = bboxes.mutable_gpu_data();
1394    bool variance_encoded_in_target = false;
1395    DecodeBBoxesGPU(num * 4, loc_data, prior_data, code_type,
1396                    variance_encoded_in_target, num, false, 1, -1, false,
1397                    bbox_data);
1398    TypeParam* bbox_cpu_data = bboxes.mutable_cpu_data();
1399    for (int i = 1; i &lt;= num; ++i) {
1400      EXPECT_NEAR(bbox_cpu_data[(i - 1) * 4], 0.1*i + i%2 * -0.1, eps);
1401      EXPECT_NEAR(bbox_cpu_data[(i - 1) * 4 + 1], 0.1*i + (i+1)%2 * 0.1, eps);
1402      EXPECT_NEAR(bbox_cpu_data[(i - 1) * 4 + 2],
1403                  0.1*i + 0.2 + (i+1)%2 * 0.1, eps);
1404      EXPECT_NEAR(bbox_cpu_data[(i - 1) * 4 + 3], 0.1*i + 0.2 + i%2 * 0.1, eps);
1405    }
1406    variance_encoded_in_target = true;
1407    bbox_data = bboxes.mutable_gpu_data();
1408    DecodeBBoxesGPU(num * 4, loc_data, prior_data, code_type,
1409                    variance_encoded_in_target, num, false, 1, -1, false,
1410                    bbox_data);
1411    bbox_cpu_data = bboxes.mutable_cpu_data();
1412    for (int i = 1; i &lt;= num; ++i) {
1413      EXPECT_NEAR(bbox_cpu_data[(i - 1) * 4], 0.1*i + i%2 * -1, eps);
1414      EXPECT_NEAR(bbox_cpu_data[(i - 1) * 4 + 1], 0.1*i + (i+1)%2, eps);
1415      EXPECT_NEAR(bbox_cpu_data[(i - 1) * 4 + 2], 0.1*i + 0.2 + (i+1)%2, eps);
1416      EXPECT_NEAR(bbox_cpu_data[(i - 1) * 4 + 3], 0.1*i + 0.2 + i%2, eps);
1417    }
1418  }
1419  TYPED_TEST(GPUBBoxUtilTest, TestDecodeBBoxesCornerTwoClasses) {
1420    int num = 4;
1421    int num_loc_classes = 2;
1422    Blob&lt;TypeParam&gt; prior_bboxes(1, 2, num * 4, 1);
1423    TypeParam* prior_data = prior_bboxes.mutable_cpu_data();
1424    Blob&lt;TypeParam&gt; loc_preds(1, num * num_loc_classes * 4, 1, 1);
1425    TypeParam* loc_data = loc_preds.mutable_cpu_data();
1426    for (int i = 1; i &lt;= num; ++i) {
1427      prior_data[(i - 1) * 4] = 0.1 * i;
1428      prior_data[(i - 1) * 4 + 1] = 0.1 * i;
1429      prior_data[(i - 1) * 4 + 2] = 0.1 * i + 0.2;
1430      prior_data[(i - 1) * 4 + 3] = 0.1 * i + 0.2;
1431      for (int j = 0; j &lt; 4; ++j) {
1432        prior_data[num * 4 + (i - 1) * 4 + j] = 0.1;
1433      }
1434      for (int j = 0; j &lt; num_loc_classes; ++j) {
1435        loc_data[((i - 1) * 2 + j) * 4] = -1 * (i % 2) * (2 - j);
1436        loc_data[((i - 1) * 2 + j) * 4 + 1] = ((i + 1) % 2) * (2 - j);
1437        loc_data[((i - 1) * 2 + j) * 4 + 2] = ((i + 1) % 2) * (2 - j);
1438        loc_data[((i - 1) * 2 + j) * 4 + 3] = i % 2 * (2 - j);
1439      }
1440    }
1441    CodeType code_type = PriorBoxParameter_CodeType_CORNER;
1442    Blob&lt;TypeParam&gt; bboxes(1, num * num_loc_classes * 4, 1, 1);
1443    TypeParam* bbox_data = bboxes.mutable_gpu_data();
1444    bool variance_encoded_in_target = false;
1445    DecodeBBoxesGPU(num * num_loc_classes * 4, loc_data, prior_data, code_type,
1446                    variance_encoded_in_target, num, false, num_loc_classes, -1,
1447                    false, bbox_data);
1448    TypeParam* bbox_cpu_data = bboxes.mutable_cpu_data();
1449    for (int i = 1; i &lt;= num; ++i) {
1450      for (int j = 0; j &lt; num_loc_classes; ++j) {
1451        EXPECT_NEAR(bbox_cpu_data[((i - 1) * 2 + j) * 4],
1452                    0.1*i + i%2 * (2-j) * -0.1, eps);
1453        EXPECT_NEAR(bbox_cpu_data[((i - 1) * 2 + j) * 4 + 1],
1454                    0.1*i + (i+1)%2 * (2-j) * 0.1, eps);
1455        EXPECT_NEAR(bbox_cpu_data[((i - 1) * 2 + j) * 4 + 2],
1456                    0.1*i + 0.2 + (i+1)%2 * (2-j) * 0.1, eps);
1457        EXPECT_NEAR(bbox_cpu_data[((i - 1) * 2 + j) * 4 + 3],
1458                    0.1*i + 0.2 + i%2 * (2-j) * 0.1, eps);
1459      }
1460    }
1461    variance_encoded_in_target = true;
1462    bbox_data = bboxes.mutable_gpu_data();
1463    DecodeBBoxesGPU(num * num_loc_classes * 4, loc_data, prior_data, code_type,
1464                    variance_encoded_in_target, num, false, num_loc_classes, -1,
1465                    false, bbox_data);
1466    bbox_cpu_data = bboxes.mutable_cpu_data();
1467    for (int i = 1; i &lt;= num; ++i) {
1468      for (int j = 0; j &lt; num_loc_classes; ++j) {
1469        EXPECT_NEAR(bbox_cpu_data[((i - 1) * 2 + j) * 4],
1470                    0.1*i + i%2 * (2-j) * -1, eps);
1471        EXPECT_NEAR(bbox_cpu_data[((i - 1) * 2 + j) * 4 + 1],
1472                    0.1*i + (i+1)%2 * (2-j), eps);
1473        EXPECT_NEAR(bbox_cpu_data[((i - 1) * 2 + j) * 4 + 2],
1474                    0.1*i + 0.2 + (i+1)%2 * (2-j), eps);
1475        EXPECT_NEAR(bbox_cpu_data[((i - 1) * 2 + j) * 4 + 3],
1476                    0.1*i + 0.2 + i%2 * (2-j), eps);
1477      }
1478    }
1479  }
1480  TYPED_TEST(GPUBBoxUtilTest, TestDecodeBBoxesCornerTwoClassesNegClass0) {
1481    int num = 4;
1482    int num_loc_classes = 2;
1483    Blob&lt;TypeParam&gt; prior_bboxes(1, 2, num * 4, 1);
1484    TypeParam* prior_data = prior_bboxes.mutable_cpu_data();
1485    Blob&lt;TypeParam&gt; loc_preds(1, num * num_loc_classes * 4, 1, 1);
1486    TypeParam* loc_data = loc_preds.mutable_cpu_data();
1487    for (int i = 1; i &lt;= num; ++i) {
1488      prior_data[(i - 1) * 4] = 0.1 * i;
1489      prior_data[(i - 1) * 4 + 1] = 0.1 * i;
1490      prior_data[(i - 1) * 4 + 2] = 0.1 * i + 0.2;
1491      prior_data[(i - 1) * 4 + 3] = 0.1 * i + 0.2;
1492      for (int j = 0; j &lt; 4; ++j) {
1493        prior_data[num * 4 + (i - 1) * 4 + j] = 0.1;
1494      }
1495      for (int j = 0; j &lt; num_loc_classes; ++j) {
1496        loc_data[((i - 1) * 2 + j) * 4] = -1 * (i % 2) * (2 - j);
1497        loc_data[((i - 1) * 2 + j) * 4 + 1] = ((i + 1) % 2) * (2 - j);
1498        loc_data[((i - 1) * 2 + j) * 4 + 2] = ((i + 1) % 2) * (2 - j);
1499        loc_data[((i - 1) * 2 + j) * 4 + 3] = i % 2 * (2 - j);
1500      }
1501    }
1502    CodeType code_type = PriorBoxParameter_CodeType_CORNER;
1503    Blob&lt;TypeParam&gt; bboxes(1, num * num_loc_classes * 4, 1, 1);
1504    TypeParam* bbox_data = bboxes.mutable_gpu_data();
1505    bool variance_encoded_in_target = false;
1506    DecodeBBoxesGPU(num * num_loc_classes * 4, loc_data, prior_data, code_type,
1507                    variance_encoded_in_target, num, false, num_loc_classes, 0,
1508                    false, bbox_data);
1509    TypeParam* bbox_cpu_data = bboxes.mutable_cpu_data();
1510    for (int i = 1; i &lt;= num; ++i) {
1511      for (int j = 0; j &lt; num_loc_classes; ++j) {
1512        if (j == 0) {
1513          for (int k = 0; k &lt; 4; ++k) {
1514            EXPECT_NEAR(bbox_cpu_data[(i - 1) * 2 * 4 + k], 0., eps);
1515          }
1516        } else {
1517          EXPECT_NEAR(bbox_cpu_data[((i - 1) * 2 + j) * 4],
1518                      0.1*i + i%2 * -0.1, eps);
1519          EXPECT_NEAR(bbox_cpu_data[((i - 1) * 2 + j) * 4 + 1],
1520                      0.1*i + (i+1)%2 * 0.1, eps);
1521          EXPECT_NEAR(bbox_cpu_data[((i - 1) * 2 + j) * 4 + 2],
1522                      0.1*i + 0.2 + (i+1)%2 * 0.1, eps);
1523          EXPECT_NEAR(bbox_cpu_data[((i - 1) * 2 + j) * 4 + 3],
1524                      0.1*i + 0.2 + i%2 * 0.1, eps);
1525        }
1526      }
1527    }
1528    variance_encoded_in_target = true;
1529    bbox_data = bboxes.mutable_gpu_data();
1530    DecodeBBoxesGPU(num * num_loc_classes * 4, loc_data, prior_data, code_type,
1531                    variance_encoded_in_target, num, false, num_loc_classes, 0,
1532                    false, bbox_data);
1533    bbox_cpu_data = bboxes.mutable_cpu_data();
1534    for (int i = 1; i &lt;= num; ++i) {
1535      for (int j = 0; j &lt; num_loc_classes; ++j) {
1536        if (j == 0) {
1537          for (int k = 0; k &lt; 4; ++k) {
1538            EXPECT_NEAR(bbox_cpu_data[(i - 1) * 2 * 4 + k], 0., eps);
1539          }
1540        } else {
1541          EXPECT_NEAR(bbox_cpu_data[((i - 1) * 2 + j) * 4],
1542                      0.1*i + i%2 * -1, eps);
1543          EXPECT_NEAR(bbox_cpu_data[((i - 1) * 2 + j) * 4 + 1],
1544                      0.1*i + (i+1)%2, eps);
1545          EXPECT_NEAR(bbox_cpu_data[((i - 1) * 2 + j) * 4 + 2],
1546                      0.1*i + 0.2 + (i+1)%2, eps);
1547          EXPECT_NEAR(bbox_cpu_data[((i - 1) * 2 + j) * 4 + 3],
1548                      0.1*i + 0.2 + i%2, eps);
1549        }
1550      }
1551    }
1552  }
1553  TYPED_TEST(GPUBBoxUtilTest, TestDecodeBBoxesCenterSize) {
1554    int num = 2;
1555    Blob&lt;TypeParam&gt; prior_bboxes(1, 2, num * 4, 1);
1556    TypeParam* prior_data = prior_bboxes.mutable_cpu_data();
1557    Blob&lt;TypeParam&gt; loc_preds(1, num * 4, 1, 1);
1558    TypeParam* loc_data = loc_preds.mutable_cpu_data();
1559    for (int i = 1; i &lt;= num; ++i) {
1560      prior_data[(i - 1) * 4] = 0.1 * i;
1561      prior_data[(i - 1) * 4 + 1] = 0.1 * i;
1562      prior_data[(i - 1) * 4 + 2] = 0.1 * i + 0.2;
1563      prior_data[(i - 1) * 4 + 3] = 0.1 * i + 0.2;
1564      prior_data[num * 4 + (i - 1) * 4] = 0.1;
1565      prior_data[num * 4 + (i - 1) * 4 + 1] = 0.1;
1566      prior_data[num * 4 + (i - 1) * 4 + 2] = 0.2;
1567      prior_data[num * 4 + (i - 1) * 4 + 3] = 0.2;
1568      loc_data[(i - 1) * 4] = 0;
1569      loc_data[(i - 1) * 4 + 1] = 0.75;
1570      loc_data[(i - 1) * 4 + 2] = log(2.);
1571      loc_data[(i - 1) * 4 + 3] = log(3./2);
1572    }
1573    CodeType code_type = PriorBoxParameter_CodeType_CENTER_SIZE;
1574    Blob&lt;TypeParam&gt; bboxes(1, num * 4, 1, 1);
1575    TypeParam* bbox_data = bboxes.mutable_gpu_data();
1576    bool variance_encoded_in_target = true;
1577    DecodeBBoxesGPU(num * 4, loc_data, prior_data, code_type,
1578                    variance_encoded_in_target, num, false, 1, -1, false,
1579                    bbox_data);
1580    TypeParam* bbox_cpu_data = bboxes.mutable_cpu_data();
1581    for (int i = 1; i &lt;= num; ++i) {
1582      EXPECT_NEAR(bbox_cpu_data[(i - 1) * 4], 0 + (i-1) * 0.1, eps);
1583      EXPECT_NEAR(bbox_cpu_data[(i - 1) * 4 + 1], 0.2 + (i-1) * 0.1, eps);
1584      EXPECT_NEAR(bbox_cpu_data[(i - 1) * 4 + 2], 0.4 + (i-1) * 0.1, eps);
1585      EXPECT_NEAR(bbox_cpu_data[(i - 1) * 4 + 3], 0.5 + (i-1) * 0.1, eps);
1586    }
1587    variance_encoded_in_target = false;
1588    for (int i = 1; i &lt;= num; ++i) {
1589      loc_data[(i - 1) * 4] = 0;
1590      loc_data[(i - 1) * 4 + 1] = 7.5;
1591      loc_data[(i - 1) * 4 + 2] = log(2.) * 5;
1592      loc_data[(i - 1) * 4 + 3] = log(3./2) * 5;
1593    }
1594    bbox_data = bboxes.mutable_gpu_data();
1595    DecodeBBoxesGPU(num * 4, loc_data, prior_data, code_type,
1596                    variance_encoded_in_target, num, false, 1, -1, false,
1597                    bbox_data);
1598    bbox_cpu_data = bboxes.mutable_cpu_data();
1599    for (int i = 1; i &lt;= num; ++i) {
1600      EXPECT_NEAR(bbox_cpu_data[(i - 1) * 4], 0 + (i-1) * 0.1, eps);
1601      EXPECT_NEAR(bbox_cpu_data[(i - 1) * 4 + 1], 0.2 + (i-1) * 0.1, eps);
1602      EXPECT_NEAR(bbox_cpu_data[(i - 1) * 4 + 2], 0.4 + (i-1) * 0.1, eps);
1603      EXPECT_NEAR(bbox_cpu_data[(i - 1) * 4 + 3], 0.5 + (i-1) * 0.1, eps);
1604    }
1605  }
1606  TYPED_TEST(GPUBBoxUtilTest, TestComputeOverlapped) {
1607    const int num = 2;
1608    const int num_bboxes = 2;
1609    const int num_loc_classes = 1;
1610    const TypeParam overlap_threshold = 0.3;
1611    Blob&lt;TypeParam&gt; bboxes(num, num_bboxes * num_loc_classes * 4, 1, 1);
1612    TypeParam* bbox_data = bboxes.mutable_cpu_data();
1613    bbox_data[0] = 0.1;
1614    bbox_data[1] = 0.1;
1615    bbox_data[2] = 0.3;
1616    bbox_data[3] = 0.3;
1617    bbox_data[4] = 0.2;
1618    bbox_data[5] = 0.1;
1619    bbox_data[6] = 0.4;
1620    bbox_data[7] = 0.3;
1621    bbox_data[8] = 0.2;
1622    bbox_data[9] = 0.0;
1623    bbox_data[10] = 0.4;
1624    bbox_data[11] = 0.2;
1625    bbox_data[12] = 0.2;
1626    bbox_data[13] = 0.1;
1627    bbox_data[14] = 0.4;
1628    bbox_data[15] = 0.3;
1629    Blob&lt;bool&gt; overlapped(num, num_loc_classes, num_bboxes, num_bboxes);
1630    const int total_bboxes = overlapped.count();
1631    bool* overlapped_data = overlapped.mutable_gpu_data();
1632    ComputeOverlappedGPU(total_bboxes, bbox_data, num_bboxes, num_loc_classes,
1633                         overlap_threshold, overlapped_data);
1634    const bool* overlapped_cpu_data = overlapped.cpu_data();
1635    EXPECT_EQ(overlapped_cpu_data[0], 0);
1636    EXPECT_EQ(overlapped_cpu_data[1], 1);
1637    EXPECT_EQ(overlapped_cpu_data[2], 1);
1638    EXPECT_EQ(overlapped_cpu_data[3], 0);
1639    EXPECT_EQ(overlapped_cpu_data[4], 0);
1640    EXPECT_EQ(overlapped_cpu_data[5], 1);
1641    EXPECT_EQ(overlapped_cpu_data[6], 1);
1642    EXPECT_EQ(overlapped_cpu_data[7], 0);
1643  }
1644  TYPED_TEST(GPUBBoxUtilTest, TestComputeOverlappedMultiClass) {
1645    const int num = 2;
1646    const int num_bboxes = 2;
1647    const int num_loc_classes = 2;
1648    const TypeParam overlap_threshold = 0.3;
1649    Blob&lt;TypeParam&gt; bboxes(num, num_bboxes * num_loc_classes * 4, 1, 1);
1650    TypeParam* bbox_data = bboxes.mutable_cpu_data();
1651    bbox_data[0] = 0.1;
1652    bbox_data[1] = 0.1;
1653    bbox_data[2] = 0.3;
1654    bbox_data[3] = 0.3;
1655    bbox_data[4] = 0.0;
1656    bbox_data[5] = 0.1;
1657    bbox_data[6] = 0.2;
1658    bbox_data[7] = 0.3;
1659    bbox_data[8] = 0.2;
1660    bbox_data[9] = 0.1;
1661    bbox_data[10] = 0.4;
1662    bbox_data[11] = 0.3;
1663    bbox_data[12] = 0.2;
1664    bbox_data[13] = 0.1;
1665    bbox_data[14] = 0.4;
1666    bbox_data[15] = 0.3;
1667    bbox_data[16] = 0.2;
1668    bbox_data[17] = 0.0;
1669    bbox_data[18] = 0.4;
1670    bbox_data[19] = 0.2;
1671    bbox_data[20] = 0.2;
1672    bbox_data[21] = 0.1;
1673    bbox_data[22] = 0.4;
1674    bbox_data[23] = 0.3;
1675    bbox_data[24] = 0.1;
1676    bbox_data[25] = 0.1;
1677    bbox_data[26] = 0.3;
1678    bbox_data[27] = 0.3;
1679    bbox_data[28] = 0.1;
1680    bbox_data[29] = 0.1;
1681    bbox_data[30] = 0.3;
1682    bbox_data[31] = 0.3;
1683    Blob&lt;bool&gt; overlapped(num, num_loc_classes, num_bboxes, num_bboxes);
1684    const int total_bboxes = overlapped.count();
1685    bool* overlapped_data = overlapped.mutable_gpu_data();
1686    ComputeOverlappedGPU(total_bboxes, bbox_data, num_bboxes, num_loc_classes,
1687                         overlap_threshold, overlapped_data);
1688    const bool* overlapped_cpu_data = overlapped.cpu_data();
1689    EXPECT_EQ(overlapped_cpu_data[0], 0);
1690    EXPECT_EQ(overlapped_cpu_data[1], 1);
1691    EXPECT_EQ(overlapped_cpu_data[2], 1);
1692    EXPECT_EQ(overlapped_cpu_data[3], 0);
1693    EXPECT_EQ(overlapped_cpu_data[4], 0);
1694    EXPECT_EQ(overlapped_cpu_data[5], 0);
1695    EXPECT_EQ(overlapped_cpu_data[6], 0);
1696    EXPECT_EQ(overlapped_cpu_data[7], 0);
1697    EXPECT_EQ(overlapped_cpu_data[8], 0);
1698    EXPECT_EQ(overlapped_cpu_data[9], 0);
1699    EXPECT_EQ(overlapped_cpu_data[10], 0);
1700    EXPECT_EQ(overlapped_cpu_data[11], 0);
1701    EXPECT_EQ(overlapped_cpu_data[12], 0);
1702    EXPECT_EQ(overlapped_cpu_data[13], 1);
1703    EXPECT_EQ(overlapped_cpu_data[14], 1);
1704    EXPECT_EQ(overlapped_cpu_data[15], 0);
1705  }
1706  TYPED_TEST(GPUBBoxUtilTest, TestSoftMaxGPU) {
1707    const int num = 2;
1708    const int num_preds = 2;
1709    const int num_classes = 2;
1710    Blob&lt;TypeParam&gt; data_blob(num, num_preds * num_classes, 1, 1);
1711    Blob&lt;TypeParam&gt; prob_blob(num, num_preds * num_classes, 1, 1);
1712    TypeParam* cpu_data = data_blob.mutable_cpu_data();
1713    cpu_data[0] = 0.1;
1714    cpu_data[1] = 0.9;
1715    cpu_data[2] = 0.9;
1716    cpu_data[3] = 0.1;
1717    cpu_data[4] = 0.3;
1718    cpu_data[5] = 0.7;
1719    cpu_data[6] = 0.7;
1720    cpu_data[7] = 0.3;
1721    const TypeParam* gpu_data = data_blob.gpu_data();
1722    TypeParam* gpu_prob = prob_blob.mutable_gpu_data();
1723    SoftMaxGPU(gpu_data, num * num_preds, num_classes, 1, gpu_prob);
1724    const TypeParam* cpu_prob = prob_blob.cpu_data();
1725    EXPECT_NEAR(cpu_prob[0], exp(-0.8) / (exp(-0.8) + 1), eps);
1726    EXPECT_NEAR(cpu_prob[1], 1 / (exp(-0.8) + 1), eps);
1727    EXPECT_NEAR(cpu_prob[2], 1 / (exp(-0.8) + 1), eps);
1728    EXPECT_NEAR(cpu_prob[3], exp(-0.8) / (exp(-0.8) + 1), eps);
1729    EXPECT_NEAR(cpu_prob[4], exp(-0.4) / (exp(-0.4) + 1), eps);
1730    EXPECT_NEAR(cpu_prob[5], 1 / (exp(-0.4) + 1), eps);
1731    EXPECT_NEAR(cpu_prob[6], 1 / (exp(-0.4) + 1), eps);
1732    EXPECT_NEAR(cpu_prob[7], exp(-0.4) / (exp(-0.4) + 1), eps);
1733  }
1734  TYPED_TEST(GPUBBoxUtilTest, TestComputeConfLossMatchGPU) {
1735    const int num = 2;
1736    const int num_preds_per_class = 2;
1737    const int num_classes = 2;
1738    const int dim = num_preds_per_class * num_classes;
1739    Blob&lt;TypeParam&gt; conf_blob(num, dim, 1, 1);
1740    TypeParam* conf_data = conf_blob.mutable_cpu_data();
1741    vector&lt;map&lt;int, vector&lt;int&gt; &gt; &gt; all_match_indices;
1742    map&lt;int, vector&lt;NormalizedBBox&gt; &gt; all_gt_bboxes;
1743    for (int i = 0; i &lt; num; ++i) {
1744      int sign = i % 2 ? 1 : -1;
1745      for (int j = 0; j &lt; num_preds_per_class; ++j) {
1746        for (int c = 0; c &lt; num_classes; ++c) {
1747          int idx = (i * num_preds_per_class + j) * num_classes + c;
1748          conf_data[idx] = sign * idx * 0.1;
1749        }
1750      }
1751      map&lt;int, vector&lt;int&gt; &gt; match_indices;
1752      vector&lt;int&gt; indices(num_preds_per_class, -1);
1753      match_indices[-1] = indices;
1754      if (i == 1) {
1755        NormalizedBBox gt_bbox;
1756        gt_bbox.set_label(1);
1757        all_gt_bboxes[i].push_back(gt_bbox);
1758        match_indices[-1][0] = 0;
1759      }
1760      all_match_indices.push_back(match_indices);
1761    }
1762    vector&lt;vector&lt;float&gt; &gt; all_conf_loss;
1763    ConfLossType loss_type = MultiBoxLossParameter_ConfLossType_LOGISTIC;
1764    ComputeConfLossGPU(conf_blob, num, num_preds_per_class, num_classes,
1765        -1, loss_type, all_match_indices, all_gt_bboxes, &amp;all_conf_loss);
1766    EXPECT_EQ(all_conf_loss.size(), num);
1767    EXPECT_EQ(all_conf_loss[0].size(), num_preds_per_class);
1768    EXPECT_NEAR(all_conf_loss[0][0],
1769                -(log(exp(0.)/(1.+exp(0.))) + log(exp(0.1)/(1+exp(0.1)))), eps);
1770    EXPECT_NEAR(all_conf_loss[0][1],
1771                -(log(exp(0.2)/(1.+exp(0.2))) + log(exp(0.3)/(1+exp(0.3)))), eps);
1772    EXPECT_EQ(all_conf_loss[1].size(), num_preds_per_class);
1773    EXPECT_NEAR(all_conf_loss[1][0],
1774                -(log(exp(-0.4)/(1.+exp(-0.4))) + log(1./(1+exp(-0.5)))),
1775                eps);
1776    EXPECT_NEAR(all_conf_loss[1][1],
1777                -(log(exp(-0.6)/(1.+exp(-0.6))) + log(exp(-0.7)/(1+exp(-0.7)))),
1778                eps);
1779    ComputeConfLossGPU(conf_blob, num, num_preds_per_class, num_classes,
1780        0, loss_type, all_match_indices, all_gt_bboxes, &amp;all_conf_loss);
1781    EXPECT_EQ(all_conf_loss.size(), num);
1782    EXPECT_EQ(all_conf_loss[0].size(), num_preds_per_class);
1783    EXPECT_NEAR(all_conf_loss[0][0],
1784                -(log(1./(1.+exp(0.))) + log(exp(0.1)/(1+exp(0.1)))), eps);
1785    EXPECT_NEAR(all_conf_loss[0][1],
1786                -(log(1./(1.+exp(0.2))) + log(exp(0.3)/(1+exp(0.3)))), eps);
1787    EXPECT_EQ(all_conf_loss[1].size(), num_preds_per_class);
1788    EXPECT_NEAR(all_conf_loss[1][0],
1789                -(log(exp(-0.4)/(1.+exp(-0.4))) + log(1./(1+exp(-0.5)))), eps);
1790    EXPECT_NEAR(all_conf_loss[1][1],
1791                -(log(1./(1.+exp(-0.6))) + log(exp(-0.7)/(1+exp(-0.7)))), eps);
1792    loss_type = MultiBoxLossParameter_ConfLossType_SOFTMAX;
1793    ComputeConfLossGPU(conf_blob, num, num_preds_per_class, num_classes,
1794        0, loss_type, all_match_indices, all_gt_bboxes, &amp;all_conf_loss);
1795    EXPECT_EQ(all_conf_loss.size(), num);
1796    for (int i = 0; i &lt; num; ++i) {
1797      EXPECT_EQ(all_conf_loss[i].size(), num_preds_per_class);
1798      int sign = i % 2 ? 1 : -1;
1799      for (int j = 0; j &lt; num_preds_per_class; ++j) {
1800        if (sign == 1) {
1801          if (j == 0) {
1802            EXPECT_NEAR(all_conf_loss[i][j], -log(1./(1+exp(-0.1))), eps);
1803          } else {
1804            EXPECT_NEAR(all_conf_loss[i][j], -log(exp(-0.1)/(1+exp(-0.1))), eps);
1805          }
1806        } else {
1807          EXPECT_NEAR(all_conf_loss[i][j], -log(1./(1+exp(-0.1))), eps);
1808        }
1809      }
1810    }
1811  }
1812  #endif
1813  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-test_bbox_util.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-test_bbox_util.cpp</div>
                </div>
                <div class="column column_space"><pre><code>1326  TYPED_TEST(GPUBBoxUtilTest, TestBBoxSize) {
1327    float size;
1328    Blob&lt;TypeParam&gt; bbox(1, 1, 1, 4);
1329    TypeParam* bbox_data = bbox.mutable_cpu_data();
1330    bbox_data[0] = 0.2;
1331    bbox_data[1] = 0.3;
1332    bbox_data[2] = 0.3;
1333    bbox_data[3] = 0.5;
1334    size = BBoxSizeGPU(bbox_data);
</pre></code></div>
                <div class="column column_space"><pre><code>1343  TYPED_TEST(GPUBBoxUtilTest, TestJaccardOverlap) {
1344    float overlap;
1345    Blob&lt;TypeParam&gt; bbox1(1, 1, 1, 4);
1346    TypeParam* bbox1_data = bbox1.mutable_cpu_data();
1347    bbox1_data[0] = 0.2;
1348    bbox1_data[1] = 0.3;
1349    bbox1_data[2] = 0.3;
1350    bbox1_data[3] = 0.5;
1351    Blob&lt;TypeParam&gt; bbox2(1, 1, 1, 4);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    