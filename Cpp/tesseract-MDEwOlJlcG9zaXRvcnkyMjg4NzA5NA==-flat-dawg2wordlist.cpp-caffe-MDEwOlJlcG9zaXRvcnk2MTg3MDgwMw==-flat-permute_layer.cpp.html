
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 6.923076923076923%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-dawg2wordlist.cpp</h3>
            <pre><code>1  #include "commontraining.h" 
2  #include "dawg.h"
3  #include "trie.h"
4  #include "unicharset.h"
5  #include "serialis.h"
6  using namespace tesseract;
7  static std::unique_ptr<tesseract::Dawg> LoadSquishedDawg(const UNICHARSET &unicharset, const char *filename) {
8    const int kDictDebugLevel = 1;
9    tesseract::TFile dawg_file;
10    if (!dawg_file.Open(filename, nullptr)) {
11      tprintf("Could not open %s for reading.\n", filename);
12      return nullptr;
13    }
14    tprintf("Loading word list from %s\n", filename);
15    auto retval = std::make_unique<tesseract::SquishedDawg>(tesseract::DAWG_TYPE_WORD, "eng",
16                                                            SYSTEM_DAWG_PERM, kDictDebugLevel);
17    if (!retval->Load(&dawg_file)) {
18      tprintf("Could not read %s\n", filename);
19      return nullptr;
20    }
21    tprintf("Word list loaded.\n");
22    return retval;
23  }
24  class WordOutputter {
25  public:
26    WordOutputter(FILE *file) : file_(file) {}
27    void output_word(const char *word) {
28      fprintf(file_, "%s\n", word);
29    }
30  private:
31    FILE *file_;
32  };
33  static int WriteDawgAsWordlist(const UNICHARSET &unicharset, const tesseract::Dawg *dawg,
34                                 const char *outfile_name) {
35    FILE *out = fopen(outfile_name, "wb");
36    if (out == nullptr) {
37      tprintf("Could not open %s for writing.\n", outfile_name);
38      return EXIT_FAILURE;
39    }
40    WordOutputter outputter(out);
41    using namespace std::placeholders; 
42    dawg->iterate_words(unicharset, std::bind(&WordOutputter::output_word, &outputter, _1));
43    return fclose(out);
44  }
45  int main(int argc, char *argv[]) {
46    tesseract::CheckSharedLibraryVersion();
47    if (argc > 1 && (!strcmp(argv[1], "-v") || !strcmp(argv[1], "--version"))) {
48      printf("%s\n", tesseract::TessBaseAPI::Version());
49      return 0;
50    } else if (argc != 4) {
51      tprintf("Print all the words in a given dawg.\n");
52      tprintf(
53          "Usage: %s -v | --version | %s <unicharset> <dawgfile> "
54          "<wordlistfile>\n",
55          argv[0], argv[0]);
56      return EXIT_FAILURE;
57    }
<span onclick='openModal()' class='match'>58    const char *unicharset_file = argv[1];
59    const char *dawg_file = argv[2];
60    const char *wordlist_file = argv[3];
</span>61    UNICHARSET unicharset;
62    if (!unicharset.load_from_file(unicharset_file)) {
63      tprintf("Error loading unicharset from %s.\n", unicharset_file);
64      return EXIT_FAILURE;
65    }
66    auto dict = LoadSquishedDawg(unicharset, dawg_file);
67    if (dict == nullptr) {
68      tprintf("Error loading dictionary from %s.\n", dawg_file);
69      return EXIT_FAILURE;
70    }
71    int retval = WriteDawgAsWordlist(unicharset, dict.get(), wordlist_file);
72    return retval;
73  }
</code></pre>
        </div>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-permute_layer.cpp</h3>
            <pre><code>1  #include <vector>
2  #include "caffe/layers/permute_layer.hpp"
3  #include "caffe/util/math_functions.hpp"
4  namespace caffe {
5  template <typename Dtype>
6  void Permute(const int count, Dtype* bottom_data, const bool forward,
7      const int* permute_order, const int* old_steps, const int* new_steps,
8      const int num_axes, Dtype* top_data) {
9  #ifdef _OPENMP
10  #pragma omp parallel for
11  #endif
12      for (int i = 0; i < count; ++i) {
13        int old_idx = 0;
14        int idx = i;
15        for (int j = 0; j < num_axes; ++j) {
16          int order = permute_order[j];
17          old_idx += (idx / new_steps[j]) * old_steps[order];
18          idx %= new_steps[j];
19        }
20        if (forward) {
21          top_data[i] = bottom_data[old_idx];
22        } else {
23          bottom_data[old_idx] = top_data[i];
24        }
25      }
26  }
27  template <typename Dtype>
28  void PermuteLayer<Dtype>::LayerSetUp(const vector<Blob<Dtype>*>& bottom,
29        const vector<Blob<Dtype>*>& top) {
30    PermuteParameter permute_param = this->layer_param_.permute_param();
31    CHECK_EQ(bottom.size(), 1);
32    num_axes_ = bottom[0]->num_axes();
33    vector<int> orders;
34    for (int i = 0; i < permute_param.order_size(); ++i) {
35      int order = permute_param.order(i);
36      CHECK_LT(order, num_axes_)
37          << "order should be less than the input dimension.";
38      if (std::find(orders.begin(), orders.end(), order) != orders.end()) {
39        LOG(FATAL) << "there are duplicate orders";
40      }
41      orders.push_back(order);
42    }
43    for (int i = 0; i < num_axes_; ++i) {
44      if (std::find(orders.begin(), orders.end(), i) == orders.end()) {
45        orders.push_back(i);
46      }
47    }
48    CHECK_EQ(num_axes_, orders.size());
49    need_permute_ = false;
50    for (int i = 0; i < num_axes_; ++i) {
51      if (orders[i] != i) {
52        need_permute_ = true;
53        break;
54      }
55    }
56    vector<int> top_shape(num_axes_, 1);
57    permute_order_.Reshape(num_axes_, 1, 1, 1);
58    old_steps_.Reshape(num_axes_, 1, 1, 1);
59    new_steps_.Reshape(num_axes_, 1, 1, 1);
60    for (int i = 0; i < num_axes_; ++i) {
61      permute_order_.mutable_cpu_data()[i] = orders[i];
62      top_shape[i] = bottom[0]->shape(orders[i]);
63    }
64    top[0]->Reshape(top_shape);
65  }
66  template <typename Dtype>
67  void PermuteLayer<Dtype>::Reshape(const vector<Blob<Dtype>*>& bottom,
68        const vector<Blob<Dtype>*>& top) {
69    vector<int> top_shape;
70    for (int i = 0; i < num_axes_; ++i) {
71      if (i == num_axes_ - 1) {
72        old_steps_.mutable_cpu_data()[i] = 1;
73      } else {
74        old_steps_.mutable_cpu_data()[i] = bottom[0]->count(i + 1);
75      }
76      top_shape.push_back(bottom[0]->shape(permute_order_.cpu_data()[i]));
77    }
78    top[0]->Reshape(top_shape);
79    for (int i = 0; i < num_axes_; ++i) {
80      if (i == num_axes_ - 1) {
81        new_steps_.mutable_cpu_data()[i] = 1;
82      } else {
83        new_steps_.mutable_cpu_data()[i] = top[0]->count(i + 1);
84      }
85    }
86  }
87  template <typename Dtype>
88  void PermuteLayer<Dtype>::Forward_cpu(const vector<Blob<Dtype>*>& bottom,
89        const vector<Blob<Dtype>*>& top) {
90    if (need_permute_) {
91      Dtype* bottom_data = bottom[0]->mutable_cpu_data();
92      Dtype* top_data = top[0]->mutable_cpu_data();
<span onclick='openModal()' class='match'>93      const int top_count = top[0]->count();
94      const int* permute_order = permute_order_.cpu_data();
95      const int* old_steps = old_steps_.cpu_data();
</span>96      const int* new_steps = new_steps_.cpu_data();
97      bool forward = true;
98      Permute(top_count, bottom_data, forward, permute_order, old_steps,
99              new_steps, num_axes_, top_data);
100    } else {
101      top[0]->ShareData(*bottom[0]);
102    }
103  }
104  template <typename Dtype>
105  void PermuteLayer<Dtype>::Backward_cpu(const vector<Blob<Dtype>*>& top,
106        const vector<bool>& propagate_down, const vector<Blob<Dtype>*>& bottom) {
107    if (need_permute_) {
108      Dtype* top_diff = top[0]->mutable_cpu_diff();
109      Dtype* bottom_diff = bottom[0]->mutable_cpu_diff();
110      const int top_count = top[0]->count();
111      const int* permute_order = permute_order_.cpu_data();
112      const int* old_steps = old_steps_.cpu_data();
113      const int* new_steps = new_steps_.cpu_data();
114      bool forward = false;
115      Permute(top_count, bottom_diff, forward, permute_order, old_steps,
116              new_steps, num_axes_, top_diff);
117    } else {
118      bottom[0]->ShareDiff(*top[0]);
119    }
120  }
121  #ifdef CPU_ONLY
122  STUB_GPU(PermuteLayer);
123  #endif
124  INSTANTIATE_CLASS(PermuteLayer);
125  REGISTER_LAYER_CLASS(Permute);
126  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-dawg2wordlist.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-permute_layer.cpp</div>
                </div>
                <div class="column column_space"><pre><code>58    const char *unicharset_file = argv[1];
59    const char *dawg_file = argv[2];
60    const char *wordlist_file = argv[3];
</pre></code></div>
                <div class="column column_space"><pre><code>93      const int top_count = top[0]->count();
94      const int* permute_order = permute_order_.cpu_data();
95      const int* old_steps = old_steps_.cpu_data();
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    