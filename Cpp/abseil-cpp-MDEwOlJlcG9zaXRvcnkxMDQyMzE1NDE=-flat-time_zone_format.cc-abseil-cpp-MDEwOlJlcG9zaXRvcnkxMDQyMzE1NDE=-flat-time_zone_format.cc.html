
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 33, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-time_zone_format.cc</h3>
            <pre><code>1  #if !defined(HAS_STRPTIME)
2  #if !defined(_MSC_VER) && !defined(__MINGW32__) && !defined(__VXWORKS__)
3  #define HAS_STRPTIME 1  
4  #endif
5  #endif
6  #if defined(HAS_STRPTIME) && HAS_STRPTIME
7  #if !defined(_XOPEN_SOURCE) && !defined(__OpenBSD__)
8  #define _XOPEN_SOURCE  
9  #endif
10  #endif
11  #include "absl/base/config.h"
12  #include "absl/time/internal/cctz/include/cctz/time_zone.h"
13  #include <time.h>
14  #include <cctype>
15  #include <chrono>
16  #include <cstddef>
17  #include <cstdint>
18  #include <cstring>
19  #include <ctime>
20  #include <limits>
21  #include <string>
22  #include <vector>
23  #if !HAS_STRPTIME
24  #include <iomanip>
25  #include <sstream>
26  #endif
27  #include "absl/time/internal/cctz/include/cctz/civil_time.h"
28  #include "time_zone_if.h"
29  namespace absl {
30  ABSL_NAMESPACE_BEGIN
31  namespace time_internal {
32  namespace cctz {
33  namespace detail {
34  namespace {
35  #if !HAS_STRPTIME
36  char* strptime(const char* s, const char* fmt, std::tm* tm) {
37    std::istringstream input(s);
38    input >> std::get_time(tm, fmt);
39    if (input.fail()) return nullptr;
40    return const_cast<char*>(s) +
41           (input.eof() ? strlen(s) : static_cast<std::size_t>(input.tellg()));
42  }
43  #endif
44  int ToTmWday(weekday wd) {
45    switch (wd) {
46      case weekday::sunday:
47        return 0;
48      case weekday::monday:
49        return 1;
50      case weekday::tuesday:
51        return 2;
52      case weekday::wednesday:
53        return 3;
54      case weekday::thursday:
55        return 4;
56      case weekday::friday:
57        return 5;
58      case weekday::saturday:
59        return 6;
60    }
61    return 0; &bsol;*NOTREACHED*/
62  }
63  weekday FromTmWday(int tm_wday) {
64    switch (tm_wday) {
65      case 0:
66        return weekday::sunday;
67      case 1:
68        return weekday::monday;
69      case 2:
70        return weekday::tuesday;
71      case 3:
72        return weekday::wednesday;
73      case 4:
74        return weekday::thursday;
75      case 5:
76        return weekday::friday;
77      case 6:
78        return weekday::saturday;
79    }
80    return weekday::sunday; &bsol;*NOTREACHED*/
81  }
82  std::tm ToTM(const time_zone::absolute_lookup& al) {
83    std::tm tm{};
84    tm.tm_sec = al.cs.second();
85    tm.tm_min = al.cs.minute();
86    tm.tm_hour = al.cs.hour();
87    tm.tm_mday = al.cs.day();
88    tm.tm_mon = al.cs.month() - 1;
89    if (al.cs.year() < std::numeric_limits<int>::min() + 1900) {
90      tm.tm_year = std::numeric_limits<int>::min();
91    } else if (al.cs.year() - 1900 > std::numeric_limits<int>::max()) {
92      tm.tm_year = std::numeric_limits<int>::max();
93    } else {
94      tm.tm_year = static_cast<int>(al.cs.year() - 1900);
95    }
96    tm.tm_wday = ToTmWday(get_weekday(al.cs));
97    tm.tm_yday = get_yearday(al.cs) - 1;
98    tm.tm_isdst = al.is_dst ? 1 : 0;
99    return tm;
100  }
101  int ToWeek(const civil_day& cd, weekday week_start) {
102    const civil_day d(cd.year() % 400, cd.month(), cd.day());
103    return static_cast<int>((d - prev_weekday(civil_year(d), week_start)) / 7);
104  }
105  const char kDigits[] = "0123456789";
106  char* Format64(char* ep, int width, std::int_fast64_t v) {
107    bool neg = false;
108    if (v < 0) {
109      --width;
110      neg = true;
111      if (v == std::numeric_limits<std::int_fast64_t>::min()) {
112        std::int_fast64_t last_digit = -(v % 10);
113        v /= 10;
114        if (last_digit < 0) {
115          ++v;
116          last_digit += 10;
117        }
118        --width;
119        *--ep = kDigits[last_digit];
120      }
121      v = -v;
122    }
123    do {
124      --width;
125      *--ep = kDigits[v % 10];
126    } while (v /= 10);
127    while (--width >= 0) *--ep = '0';  
128    if (neg) *--ep = '-';
129    return ep;
130  }
131  char* Format02d(char* ep, int v) {
132    *--ep = kDigits[v % 10];
133    *--ep = kDigits[(v / 10) % 10];
134    return ep;
135  }
136  char* FormatOffset(char* ep, int offset, const char* mode) {
137    char sign = '+';
138    if (offset < 0) {
139      offset = -offset;  
140      sign = '-';
141    }
142    const int seconds = offset % 60;
143    const int minutes = (offset /= 60) % 60;
144    const int hours = offset /= 60;
145    const char sep = mode[0];
146    const bool ext = (sep != '\0' && mode[1] == '*');
147    const bool ccc = (ext && mode[2] == ':');
148    if (ext && (!ccc || seconds != 0)) {
149      ep = Format02d(ep, seconds);
150      *--ep = sep;
151    } else {
152      if (hours == 0 && minutes == 0) sign = '+';
153    }
154    if (!ccc || minutes != 0 || seconds != 0) {
155      ep = Format02d(ep, minutes);
156      if (sep != '\0') *--ep = sep;
157    }
158    ep = Format02d(ep, hours);
159    *--ep = sign;
160    return ep;
161  }
162  void FormatTM(std::string* out, const std::string& fmt, const std::tm& tm) {
163    for (std::size_t i = 2; i != 32; i *= 2) {
164      std::size_t buf_size = fmt.size() * i;
165      std::vector<char> buf(buf_size);
166      if (std::size_t len = strftime(&buf[0], buf_size, fmt.c_str(), &tm)) {
167        out->append(&buf[0], len);
168        return;
169      }
170    }
171  }
172  template <typename T>
173  const char* ParseInt(const char* dp, int width, T min, T max, T* vp) {
174    if (dp != nullptr) {
175      const T kmin = std::numeric_limits<T>::min();
176      bool erange = false;
177      bool neg = false;
178      T value = 0;
179      if (*dp == '-') {
180        neg = true;
181        if (width <= 0 || --width != 0) {
182          ++dp;
183        } else {
184          dp = nullptr;  
185        }
186      }
187      if (const char* const bp = dp) {
188        while (const char* cp = strchr(kDigits, *dp)) {
189          int d = static_cast<int>(cp - kDigits);
190          if (d >= 10) break;
191          if (value < kmin / 10) {
192            erange = true;
193            break;
194          }
195          value *= 10;
196          if (value < kmin + d) {
197            erange = true;
198            break;
199          }
200          value -= d;
201          dp += 1;
202          if (width > 0 && --width == 0) break;
203        }
204        if (dp != bp && !erange && (neg || value != kmin)) {
205          if (!neg || value != 0) {
206            if (!neg) value = -value;  
207            if (min <= value && value <= max) {
208              *vp = value;
209            } else {
210              dp = nullptr;
211            }
212          } else {
213            dp = nullptr;
214          }
215        } else {
216          dp = nullptr;
217        }
218      }
219    }
220    return dp;
221  }
222  const int kDigits10_64 = 18;
223  const std::int_fast64_t kExp10[kDigits10_64 + 1] = {
224      1,
225      10,
226      100,
227      1000,
228      10000,
229      100000,
230      1000000,
231      10000000,
232      100000000,
233      1000000000,
234      10000000000,
235      100000000000,
236      1000000000000,
237      10000000000000,
238      100000000000000,
239      1000000000000000,
240      10000000000000000,
241      100000000000000000,
242      1000000000000000000,
243  };
244  }  
245  std::string format(const std::string& format, const time_point<seconds>& tp,
246                     const detail::femtoseconds& fs, const time_zone& tz) {
247    std::string result;
248    result.reserve(format.size());  
249    const time_zone::absolute_lookup al = tz.lookup(tp);
250    const std::tm tm = ToTM(al);
251    char buf[3 + kDigits10_64];  
252    char* const ep = buf + sizeof(buf);
253    char* bp;  
254    const char* pending = format.c_str();  
255    const char* cur = pending;
256    const char* end = pending + format.length();
257    while (cur != end) {  
258      const char* start = cur;
259      while (cur != end && *cur != '%') ++cur;
260      if (cur != start && pending == start) {
261        result.append(pending, static_cast<std::size_t>(cur - pending));
262        pending = start = cur;
263      }
264      const char* percent = cur;
265      while (cur != end && *cur == '%') ++cur;
266      if (cur != start && pending == start) {
267        std::size_t escaped = static_cast<std::size_t>(cur - pending) / 2;
268        result.append(pending, escaped);
269        pending += escaped * 2;
270        if (pending != cur && cur == end) {
271          result.push_back(*pending++);
272        }
273      }
274      if (cur == end || (cur - percent) % 2 == 0) continue;
275      if (strchr("YmdeUuWwHMSzZs%", *cur)) {
276        if (cur - 1 != pending) {
277          FormatTM(&result, std::string(pending, cur - 1), tm);
278        }
279        switch (*cur) {
280          case 'Y':
281            bp = Format64(ep, 0, al.cs.year());
282            result.append(bp, static_cast<std::size_t>(ep - bp));
283            break;
284          case 'm':
285            bp = Format02d(ep, al.cs.month());
286            result.append(bp, static_cast<std::size_t>(ep - bp));
287            break;
288          case 'd':
289          case 'e':
290            bp = Format02d(ep, al.cs.day());
291            if (*cur == 'e' && *bp == '0') *bp = ' ';  
292            result.append(bp, static_cast<std::size_t>(ep - bp));
293            break;
294          case 'U':
295            bp = Format02d(ep, ToWeek(civil_day(al.cs), weekday::sunday));
296            result.append(bp, static_cast<std::size_t>(ep - bp));
297            break;
298          case 'u':
299            bp = Format64(ep, 0, tm.tm_wday ? tm.tm_wday : 7);
300            result.append(bp, static_cast<std::size_t>(ep - bp));
301            break;
302          case 'W':
303            bp = Format02d(ep, ToWeek(civil_day(al.cs), weekday::monday));
304            result.append(bp, static_cast<std::size_t>(ep - bp));
305            break;
306          case 'w':
307            bp = Format64(ep, 0, tm.tm_wday);
308            result.append(bp, static_cast<std::size_t>(ep - bp));
309            break;
310          case 'H':
311            bp = Format02d(ep, al.cs.hour());
312            result.append(bp, static_cast<std::size_t>(ep - bp));
313            break;
314          case 'M':
315            bp = Format02d(ep, al.cs.minute());
316            result.append(bp, static_cast<std::size_t>(ep - bp));
317            break;
318          case 'S':
319            bp = Format02d(ep, al.cs.second());
320            result.append(bp, static_cast<std::size_t>(ep - bp));
321            break;
322          case 'z':
323            bp = FormatOffset(ep, al.offset, "");
324            result.append(bp, static_cast<std::size_t>(ep - bp));
325            break;
326          case 'Z':
327            result.append(al.abbr);
328            break;
329          case 's':
330            bp = Format64(ep, 0, ToUnixSeconds(tp));
331            result.append(bp, static_cast<std::size_t>(ep - bp));
332            break;
333          case '%':
334            result.push_back('%');
335            break;
336        }
337        pending = ++cur;
338        continue;
339      }
340      if (*cur == ':' && cur + 1 != end) {
341        if (*(cur + 1) == 'z') {
342          if (cur - 1 != pending) {
343            FormatTM(&result, std::string(pending, cur - 1), tm);
344          }
345          bp = FormatOffset(ep, al.offset, ":");
346          result.append(bp, static_cast<std::size_t>(ep - bp));
347          pending = cur += 2;
348          continue;
349        }
350        if (*(cur + 1) == ':' && cur + 2 != end) {
351          if (*(cur + 2) == 'z') {
352            if (cur - 1 != pending) {
353              FormatTM(&result, std::string(pending, cur - 1), tm);
354            }
355            bp = FormatOffset(ep, al.offset, ":*");
356            result.append(bp, static_cast<std::size_t>(ep - bp));
357            pending = cur += 3;
358            continue;
359          }
360          if (*(cur + 2) == ':' && cur + 3 != end) {
361            if (*(cur + 3) == 'z') {
362              if (cur - 1 != pending) {
363                FormatTM(&result, std::string(pending, cur - 1), tm);
364              }
365              bp = FormatOffset(ep, al.offset, ":*:");
366              result.append(bp, static_cast<std::size_t>(ep - bp));
367              pending = cur += 4;
368              continue;
369            }
370          }
371        }
372      }
373      if (*cur != 'E' || ++cur == end) continue;
374      if (*cur == 'T') {
375        if (cur - 2 != pending) {
376          FormatTM(&result, std::string(pending, cur - 2), tm);
377        }
378        result.append("T");
379        pending = ++cur;
380      } else if (*cur == 'z') {
381        if (cur - 2 != pending) {
382          FormatTM(&result, std::string(pending, cur - 2), tm);
383        }
384        bp = FormatOffset(ep, al.offset, ":");
385        result.append(bp, static_cast<std::size_t>(ep - bp));
386        pending = ++cur;
387      } else if (*cur == '*' && cur + 1 != end && *(cur + 1) == 'z') {
388        if (cur - 2 != pending) {
389          FormatTM(&result, std::string(pending, cur - 2), tm);
390        }
391        bp = FormatOffset(ep, al.offset, ":*");
392        result.append(bp, static_cast<std::size_t>(ep - bp));
393        pending = cur += 2;
394      } else if (*cur == '*' && cur + 1 != end &&
395                 (*(cur + 1) == 'S' || *(cur + 1) == 'f')) {
396        if (cur - 2 != pending) {
397          FormatTM(&result, std::string(pending, cur - 2), tm);
398        }
399        char* cp = ep;
400        bp = Format64(cp, 15, fs.count());
401        while (cp != bp && cp[-1] == '0') --cp;
402        switch (*(cur + 1)) {
403          case 'S':
404            if (cp != bp) *--bp = '.';
405            bp = Format02d(bp, al.cs.second());
406            break;
407          case 'f':
408            if (cp == bp) *--bp = '0';
409            break;
410        }
411        result.append(bp, static_cast<std::size_t>(cp - bp));
412        pending = cur += 2;
413      } else if (*cur == '4' && cur + 1 != end && *(cur + 1) == 'Y') {
414        if (cur - 2 != pending) {
415          FormatTM(&result, std::string(pending, cur - 2), tm);
416        }
417        bp = Format64(ep, 4, al.cs.year());
418        result.append(bp, static_cast<std::size_t>(ep - bp));
419        pending = cur += 2;
420      } else if (std::isdigit(*cur)) {
421        int n = 0;
422        if (const char* np = ParseInt(cur, 0, 0, 1024, &n)) {
423          if (*np == 'S' || *np == 'f') {
424            if (cur - 2 != pending) {
425              FormatTM(&result, std::string(pending, cur - 2), tm);
426            }
427            bp = ep;
428            if (n > 0) {
429              if (n > kDigits10_64) n = kDigits10_64;
430              bp = Format64(bp, n,
431                            (n > 15) ? fs.count() * kExp10[n - 15]
432                                     : fs.count() / kExp10[15 - n]);
433              if (*np == 'S') *--bp = '.';
434            }
435            if (*np == 'S') bp = Format02d(bp, al.cs.second());
436            result.append(bp, static_cast<std::size_t>(ep - bp));
437            pending = cur = ++np;
438          }
439        }
440      }
441    }
442    if (end != pending) {
443      FormatTM(&result, std::string(pending, end), tm);
444    }
445    return result;
446  }
447  namespace {
448  const char* ParseOffset(const char* dp, const char* mode, int* offset) {
449    if (dp != nullptr) {
450      const char first = *dp++;
451      if (first == '+' || first == '-') {
452        char sep = mode[0];
453        int hours = 0;
454        int minutes = 0;
455        int seconds = 0;
456        const char* ap = ParseInt(dp, 2, 0, 23, &hours);
457        if (ap != nullptr && ap - dp == 2) {
458          dp = ap;
<span onclick='openModal()' class='match'>459          if (sep != '\0' && *ap == sep) ++ap;
460          const char* bp = ParseInt(ap, 2, 0, 59, &minutes);
461          if (bp != nullptr && bp - ap == 2) {
</span>462            dp = bp;
463            if (sep != '\0' && *bp == sep) ++bp;
464            const char* cp = ParseInt(bp, 2, 0, 59, &seconds);
465            if (cp != nullptr && cp - bp == 2) dp = cp;
466          }
467          *offset = ((hours * 60 + minutes) * 60) + seconds;
468          if (first == '-') *offset = -*offset;
469        } else {
470          dp = nullptr;
471        }
472      } else if (first == 'Z' || first == 'z') {  
473        *offset = 0;
474      } else {
475        dp = nullptr;
476      }
477    }
478    return dp;
479  }
480  const char* ParseZone(const char* dp, std::string* zone) {
481    zone->clear();
482    if (dp != nullptr) {
483      while (*dp != '\0' && !std::isspace(*dp)) zone->push_back(*dp++);
484      if (zone->empty()) dp = nullptr;
485    }
486    return dp;
487  }
488  const char* ParseSubSeconds(const char* dp, detail::femtoseconds* subseconds) {
489    if (dp != nullptr) {
490      std::int_fast64_t v = 0;
491      std::int_fast64_t exp = 0;
492      const char* const bp = dp;
493      while (const char* cp = strchr(kDigits, *dp)) {
494        int d = static_cast<int>(cp - kDigits);
495        if (d >= 10) break;
496        if (exp < 15) {
497          exp += 1;
498          v *= 10;
499          v += d;
500        }
501        ++dp;
502      }
503      if (dp != bp) {
504        v *= kExp10[15 - exp];
505        *subseconds = detail::femtoseconds(v);
506      } else {
507        dp = nullptr;
508      }
509    }
510    return dp;
511  }
512  const char* ParseTM(const char* dp, const char* fmt, std::tm* tm) {
513    if (dp != nullptr) {
514      dp = strptime(dp, fmt, tm);
515    }
516    return dp;
517  }
518  bool FromWeek(int week_num, weekday week_start, year_t* year, std::tm* tm) {
519    const civil_year y(*year % 400);
520    civil_day cd = prev_weekday(y, week_start);  
521    cd = next_weekday(cd - 1, FromTmWday(tm->tm_wday)) + (week_num * 7);
522    if (const year_t shift = cd.year() - y.year()) {
523      if (shift > 0) {
524        if (*year > std::numeric_limits<year_t>::max() - shift) return false;
525      } else {
526        if (*year < std::numeric_limits<year_t>::min() - shift) return false;
527      }
528      *year += shift;
529    }
530    tm->tm_mon = cd.month() - 1;
531    tm->tm_mday = cd.day();
532    return true;
533  }
534  }  
535  bool parse(const std::string& format, const std::string& input,
536             const time_zone& tz, time_point<seconds>* sec,
537             detail::femtoseconds* fs, std::string* err) {
538    const char* data = input.c_str();  
539    while (std::isspace(*data)) ++data;
540    const year_t kyearmax = std::numeric_limits<year_t>::max();
541    const year_t kyearmin = std::numeric_limits<year_t>::min();
542    bool saw_year = false;
543    year_t year = 1970;
544    std::tm tm{};
545    tm.tm_year = 1970 - 1900;
546    tm.tm_mon = 1 - 1;  
547    tm.tm_mday = 1;
548    tm.tm_hour = 0;
549    tm.tm_min = 0;
550    tm.tm_sec = 0;
551    tm.tm_wday = 4;  
552    tm.tm_yday = 0;
553    tm.tm_isdst = 0;
554    auto subseconds = detail::femtoseconds::zero();
555    bool saw_offset = false;
556    int offset = 0;  
557    std::string zone = "UTC";
558    const char* fmt = format.c_str();  
559    bool twelve_hour = false;
560    bool afternoon = false;
561    int week_num = -1;
562    weekday week_start = weekday::sunday;
563    bool saw_percent_s = false;
564    std::int_fast64_t percent_s = 0;
565    while (data != nullptr && *fmt != '\0') {
566      if (std::isspace(*fmt)) {
567        while (std::isspace(*data)) ++data;
568        while (std::isspace(*++fmt)) continue;
569        continue;
570      }
571      if (*fmt != '%') {
572        if (*data == *fmt) {
573          ++data;
574          ++fmt;
575        } else {
576          data = nullptr;
577        }
578        continue;
579      }
580      const char* percent = fmt;
581      if (*++fmt == '\0') {
582        data = nullptr;
583        continue;
584      }
585      switch (*fmt++) {
586        case 'Y':
587          data = ParseInt(data, 0, kyearmin, kyearmax, &year);
588          if (data != nullptr) saw_year = true;
589          continue;
590        case 'm':
591          data = ParseInt(data, 2, 1, 12, &tm.tm_mon);
592          if (data != nullptr) tm.tm_mon -= 1;
593          week_num = -1;
594          continue;
595        case 'd':
596        case 'e':
597          data = ParseInt(data, 2, 1, 31, &tm.tm_mday);
598          week_num = -1;
599          continue;
600        case 'U':
601          data = ParseInt(data, 0, 0, 53, &week_num);
602          week_start = weekday::sunday;
603          continue;
604        case 'W':
605          data = ParseInt(data, 0, 0, 53, &week_num);
606          week_start = weekday::monday;
607          continue;
608        case 'u':
609          data = ParseInt(data, 0, 1, 7, &tm.tm_wday);
610          if (data != nullptr) tm.tm_wday %= 7;
611          continue;
612        case 'w':
613          data = ParseInt(data, 0, 0, 6, &tm.tm_wday);
614          continue;
615        case 'H':
616          data = ParseInt(data, 2, 0, 23, &tm.tm_hour);
617          twelve_hour = false;
618          continue;
619        case 'M':
620          data = ParseInt(data, 2, 0, 59, &tm.tm_min);
621          continue;
622        case 'S':
623          data = ParseInt(data, 2, 0, 60, &tm.tm_sec);
624          continue;
625        case 'I':
626        case 'l':
627        case 'r':  
628          twelve_hour = true;
629          break;
630        case 'R':  
631        case 'T':  
632        case 'c':  
633        case 'X':  
634          twelve_hour = false;
635          break;
636        case 'z':
637          data = ParseOffset(data, "", &offset);
638          if (data != nullptr) saw_offset = true;
639          continue;
640        case 'Z':  
641          data = ParseZone(data, &zone);
642          continue;
643        case 's':
644          data =
645              ParseInt(data, 0, std::numeric_limits<std::int_fast64_t>::min(),
646                       std::numeric_limits<std::int_fast64_t>::max(), &percent_s);
647          if (data != nullptr) saw_percent_s = true;
648          continue;
649        case ':':
650          if (fmt[0] == 'z' ||
651              (fmt[0] == ':' &&
652               (fmt[1] == 'z' || (fmt[1] == ':' && fmt[2] == 'z')))) {
653            data = ParseOffset(data, ":", &offset);
654            if (data != nullptr) saw_offset = true;
655            fmt += (fmt[0] == 'z') ? 1 : (fmt[1] == 'z') ? 2 : 3;
656            continue;
657          }
658          break;
659        case '%':
660          data = (*data == '%' ? data + 1 : nullptr);
661          continue;
662        case 'E':
663          if (fmt[0] == 'T') {
664            if (*data == 'T' || *data == 't') {
665              ++data;
666              ++fmt;
667            } else {
668              data = nullptr;
669            }
670            continue;
671          }
672          if (fmt[0] == 'z' || (fmt[0] == '*' && fmt[1] == 'z')) {
673            data = ParseOffset(data, ":", &offset);
674            if (data != nullptr) saw_offset = true;
675            fmt += (fmt[0] == 'z') ? 1 : 2;
676            continue;
677          }
678          if (fmt[0] == '*' && fmt[1] == 'S') {
679            data = ParseInt(data, 2, 0, 60, &tm.tm_sec);
680            if (data != nullptr && *data == '.') {
681              data = ParseSubSeconds(data + 1, &subseconds);
682            }
683            fmt += 2;
684            continue;
685          }
686          if (fmt[0] == '*' && fmt[1] == 'f') {
687            if (data != nullptr && std::isdigit(*data)) {
688              data = ParseSubSeconds(data, &subseconds);
689            }
690            fmt += 2;
691            continue;
692          }
693          if (fmt[0] == '4' && fmt[1] == 'Y') {
694            const char* bp = data;
695            data = ParseInt(data, 4, year_t{-999}, year_t{9999}, &year);
696            if (data != nullptr) {
697              if (data - bp == 4) {
698                saw_year = true;
699              } else {
700                data = nullptr;  
701              }
702            }
703            fmt += 2;
704            continue;
705          }
706          if (std::isdigit(*fmt)) {
707            int n = 0;  
708            if (const char* np = ParseInt(fmt, 0, 0, 1024, &n)) {
709              if (*np == 'S') {
710                data = ParseInt(data, 2, 0, 60, &tm.tm_sec);
711                if (data != nullptr && *data == '.') {
712                  data = ParseSubSeconds(data + 1, &subseconds);
713                }
714                fmt = ++np;
715                continue;
716              }
717              if (*np == 'f') {
718                if (data != nullptr && std::isdigit(*data)) {
719                  data = ParseSubSeconds(data, &subseconds);
720                }
721                fmt = ++np;
722                continue;
723              }
724            }
725          }
726          if (*fmt == 'c') twelve_hour = false;  
727          if (*fmt == 'X') twelve_hour = false;  
728          if (*fmt != '\0') ++fmt;
729          break;
730        case 'O':
731          if (*fmt == 'H') twelve_hour = false;
732          if (*fmt == 'I') twelve_hour = true;
733          if (*fmt != '\0') ++fmt;
734          break;
735      }
736      const char* orig_data = data;
737      std::string spec(percent, static_cast<std::size_t>(fmt - percent));
738      data = ParseTM(data, spec.c_str(), &tm);
739      if (spec == "%p" && data != nullptr) {
740        std::string test_input = "1";
741        test_input.append(orig_data, static_cast<std::size_t>(data - orig_data));
742        const char* test_data = test_input.c_str();
743        std::tm tmp{};
744        ParseTM(test_data, "%I%p", &tmp);
745        afternoon = (tmp.tm_hour == 13);
746      }
747    }
748    if (twelve_hour && afternoon && tm.tm_hour < 12) {
749      tm.tm_hour += 12;
750    }
751    if (data == nullptr) {
752      if (err != nullptr) *err = "Failed to parse input";
753      return false;
754    }
755    while (std::isspace(*data)) ++data;
756    if (*data != '\0') {
757      if (err != nullptr) *err = "Illegal trailing data in input string";
758      return false;
759    }
760    if (saw_percent_s) {
761      *sec = FromUnixSeconds(percent_s);
762      *fs = detail::femtoseconds::zero();
763      return true;
764    }
765    time_zone ptz = saw_offset ? utc_time_zone() : tz;
766    if (tm.tm_sec == 60) {
767      tm.tm_sec -= 1;
768      offset -= 1;
769      subseconds = detail::femtoseconds::zero();
770    }
771    if (!saw_year) {
772      year = year_t{tm.tm_year};
773      if (year > kyearmax - 1900) {
774        if (err != nullptr) *err = "Out-of-range year";
775        return false;
776      }
777      year += 1900;
778    }
779    if (week_num != -1) {
780      if (!FromWeek(week_num, week_start, &year, &tm)) {
781        if (err != nullptr) *err = "Out-of-range field";
782        return false;
783      }
784    }
785    const int month = tm.tm_mon + 1;
786    civil_second cs(year, month, tm.tm_mday, tm.tm_hour, tm.tm_min, tm.tm_sec);
787    if (cs.month() != month || cs.day() != tm.tm_mday) {
788      if (err != nullptr) *err = "Out-of-range field";
789      return false;
790    }
791    if ((offset < 0 && cs > civil_second::max() + offset) ||
792        (offset > 0 && cs < civil_second::min() + offset)) {
793      if (err != nullptr) *err = "Out-of-range field";
794      return false;
795    }
796    cs -= offset;
797    const auto tp = ptz.lookup(cs).pre;
798    if (tp == time_point<seconds>::max()) {
799      const auto al = ptz.lookup(time_point<seconds>::max());
800      if (cs > al.cs) {
801        if (err != nullptr) *err = "Out-of-range field";
802        return false;
803      }
804    }
805    if (tp == time_point<seconds>::min()) {
806      const auto al = ptz.lookup(time_point<seconds>::min());
807      if (cs < al.cs) {
808        if (err != nullptr) *err = "Out-of-range field";
809        return false;
810      }
811    }
812    *sec = tp;
813    *fs = subseconds;
814    return true;
815  }
816  }  
817  }  
818  }  
819  ABSL_NAMESPACE_END
820  }  
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-time_zone_format.cc</h3>
            <pre><code>1  #if !defined(HAS_STRPTIME)
2  #if !defined(_MSC_VER) && !defined(__MINGW32__) && !defined(__VXWORKS__)
3  #define HAS_STRPTIME 1  
4  #endif
5  #endif
6  #if defined(HAS_STRPTIME) && HAS_STRPTIME
7  #if !defined(_XOPEN_SOURCE) && !defined(__OpenBSD__)
8  #define _XOPEN_SOURCE  
9  #endif
10  #endif
11  #include "absl/base/config.h"
12  #include "absl/time/internal/cctz/include/cctz/time_zone.h"
13  #include <time.h>
14  #include <cctype>
15  #include <chrono>
16  #include <cstddef>
17  #include <cstdint>
18  #include <cstring>
19  #include <ctime>
20  #include <limits>
21  #include <string>
22  #include <vector>
23  #if !HAS_STRPTIME
24  #include <iomanip>
25  #include <sstream>
26  #endif
27  #include "absl/time/internal/cctz/include/cctz/civil_time.h"
28  #include "time_zone_if.h"
29  namespace absl {
30  ABSL_NAMESPACE_BEGIN
31  namespace time_internal {
32  namespace cctz {
33  namespace detail {
34  namespace {
35  #if !HAS_STRPTIME
36  char* strptime(const char* s, const char* fmt, std::tm* tm) {
37    std::istringstream input(s);
38    input >> std::get_time(tm, fmt);
39    if (input.fail()) return nullptr;
40    return const_cast<char*>(s) +
41           (input.eof() ? strlen(s) : static_cast<std::size_t>(input.tellg()));
42  }
43  #endif
44  int ToTmWday(weekday wd) {
45    switch (wd) {
46      case weekday::sunday:
47        return 0;
48      case weekday::monday:
49        return 1;
50      case weekday::tuesday:
51        return 2;
52      case weekday::wednesday:
53        return 3;
54      case weekday::thursday:
55        return 4;
56      case weekday::friday:
57        return 5;
58      case weekday::saturday:
59        return 6;
60    }
61    return 0; &bsol;*NOTREACHED*/
62  }
63  weekday FromTmWday(int tm_wday) {
64    switch (tm_wday) {
65      case 0:
66        return weekday::sunday;
67      case 1:
68        return weekday::monday;
69      case 2:
70        return weekday::tuesday;
71      case 3:
72        return weekday::wednesday;
73      case 4:
74        return weekday::thursday;
75      case 5:
76        return weekday::friday;
77      case 6:
78        return weekday::saturday;
79    }
80    return weekday::sunday; &bsol;*NOTREACHED*/
81  }
82  std::tm ToTM(const time_zone::absolute_lookup& al) {
83    std::tm tm{};
84    tm.tm_sec = al.cs.second();
85    tm.tm_min = al.cs.minute();
86    tm.tm_hour = al.cs.hour();
87    tm.tm_mday = al.cs.day();
88    tm.tm_mon = al.cs.month() - 1;
89    if (al.cs.year() < std::numeric_limits<int>::min() + 1900) {
90      tm.tm_year = std::numeric_limits<int>::min();
91    } else if (al.cs.year() - 1900 > std::numeric_limits<int>::max()) {
92      tm.tm_year = std::numeric_limits<int>::max();
93    } else {
94      tm.tm_year = static_cast<int>(al.cs.year() - 1900);
95    }
96    tm.tm_wday = ToTmWday(get_weekday(al.cs));
97    tm.tm_yday = get_yearday(al.cs) - 1;
98    tm.tm_isdst = al.is_dst ? 1 : 0;
99    return tm;
100  }
101  int ToWeek(const civil_day& cd, weekday week_start) {
102    const civil_day d(cd.year() % 400, cd.month(), cd.day());
103    return static_cast<int>((d - prev_weekday(civil_year(d), week_start)) / 7);
104  }
105  const char kDigits[] = "0123456789";
106  char* Format64(char* ep, int width, std::int_fast64_t v) {
107    bool neg = false;
108    if (v < 0) {
109      --width;
110      neg = true;
111      if (v == std::numeric_limits<std::int_fast64_t>::min()) {
112        std::int_fast64_t last_digit = -(v % 10);
113        v /= 10;
114        if (last_digit < 0) {
115          ++v;
116          last_digit += 10;
117        }
118        --width;
119        *--ep = kDigits[last_digit];
120      }
121      v = -v;
122    }
123    do {
124      --width;
125      *--ep = kDigits[v % 10];
126    } while (v /= 10);
127    while (--width >= 0) *--ep = '0';  
128    if (neg) *--ep = '-';
129    return ep;
130  }
131  char* Format02d(char* ep, int v) {
132    *--ep = kDigits[v % 10];
133    *--ep = kDigits[(v / 10) % 10];
134    return ep;
135  }
136  char* FormatOffset(char* ep, int offset, const char* mode) {
137    char sign = '+';
138    if (offset < 0) {
139      offset = -offset;  
140      sign = '-';
141    }
142    const int seconds = offset % 60;
143    const int minutes = (offset /= 60) % 60;
144    const int hours = offset /= 60;
145    const char sep = mode[0];
146    const bool ext = (sep != '\0' && mode[1] == '*');
147    const bool ccc = (ext && mode[2] == ':');
148    if (ext && (!ccc || seconds != 0)) {
149      ep = Format02d(ep, seconds);
150      *--ep = sep;
151    } else {
152      if (hours == 0 && minutes == 0) sign = '+';
153    }
154    if (!ccc || minutes != 0 || seconds != 0) {
155      ep = Format02d(ep, minutes);
156      if (sep != '\0') *--ep = sep;
157    }
158    ep = Format02d(ep, hours);
159    *--ep = sign;
160    return ep;
161  }
162  void FormatTM(std::string* out, const std::string& fmt, const std::tm& tm) {
163    for (std::size_t i = 2; i != 32; i *= 2) {
164      std::size_t buf_size = fmt.size() * i;
165      std::vector<char> buf(buf_size);
166      if (std::size_t len = strftime(&buf[0], buf_size, fmt.c_str(), &tm)) {
167        out->append(&buf[0], len);
168        return;
169      }
170    }
171  }
172  template <typename T>
173  const char* ParseInt(const char* dp, int width, T min, T max, T* vp) {
174    if (dp != nullptr) {
175      const T kmin = std::numeric_limits<T>::min();
176      bool erange = false;
177      bool neg = false;
178      T value = 0;
179      if (*dp == '-') {
180        neg = true;
181        if (width <= 0 || --width != 0) {
182          ++dp;
183        } else {
184          dp = nullptr;  
185        }
186      }
187      if (const char* const bp = dp) {
188        while (const char* cp = strchr(kDigits, *dp)) {
189          int d = static_cast<int>(cp - kDigits);
190          if (d >= 10) break;
191          if (value < kmin / 10) {
192            erange = true;
193            break;
194          }
195          value *= 10;
196          if (value < kmin + d) {
197            erange = true;
198            break;
199          }
200          value -= d;
201          dp += 1;
202          if (width > 0 && --width == 0) break;
203        }
204        if (dp != bp && !erange && (neg || value != kmin)) {
205          if (!neg || value != 0) {
206            if (!neg) value = -value;  
207            if (min <= value && value <= max) {
208              *vp = value;
209            } else {
210              dp = nullptr;
211            }
212          } else {
213            dp = nullptr;
214          }
215        } else {
216          dp = nullptr;
217        }
218      }
219    }
220    return dp;
221  }
222  const int kDigits10_64 = 18;
223  const std::int_fast64_t kExp10[kDigits10_64 + 1] = {
224      1,
225      10,
226      100,
227      1000,
228      10000,
229      100000,
230      1000000,
231      10000000,
232      100000000,
233      1000000000,
234      10000000000,
235      100000000000,
236      1000000000000,
237      10000000000000,
238      100000000000000,
239      1000000000000000,
240      10000000000000000,
241      100000000000000000,
242      1000000000000000000,
243  };
244  }  
245  std::string format(const std::string& format, const time_point<seconds>& tp,
246                     const detail::femtoseconds& fs, const time_zone& tz) {
247    std::string result;
248    result.reserve(format.size());  
249    const time_zone::absolute_lookup al = tz.lookup(tp);
250    const std::tm tm = ToTM(al);
251    char buf[3 + kDigits10_64];  
252    char* const ep = buf + sizeof(buf);
253    char* bp;  
254    const char* pending = format.c_str();  
255    const char* cur = pending;
256    const char* end = pending + format.length();
257    while (cur != end) {  
258      const char* start = cur;
259      while (cur != end && *cur != '%') ++cur;
260      if (cur != start && pending == start) {
261        result.append(pending, static_cast<std::size_t>(cur - pending));
262        pending = start = cur;
263      }
264      const char* percent = cur;
265      while (cur != end && *cur == '%') ++cur;
266      if (cur != start && pending == start) {
267        std::size_t escaped = static_cast<std::size_t>(cur - pending) / 2;
268        result.append(pending, escaped);
269        pending += escaped * 2;
270        if (pending != cur && cur == end) {
271          result.push_back(*pending++);
272        }
273      }
274      if (cur == end || (cur - percent) % 2 == 0) continue;
275      if (strchr("YmdeUuWwHMSzZs%", *cur)) {
276        if (cur - 1 != pending) {
277          FormatTM(&result, std::string(pending, cur - 1), tm);
278        }
279        switch (*cur) {
280          case 'Y':
281            bp = Format64(ep, 0, al.cs.year());
282            result.append(bp, static_cast<std::size_t>(ep - bp));
283            break;
284          case 'm':
285            bp = Format02d(ep, al.cs.month());
286            result.append(bp, static_cast<std::size_t>(ep - bp));
287            break;
288          case 'd':
289          case 'e':
290            bp = Format02d(ep, al.cs.day());
291            if (*cur == 'e' && *bp == '0') *bp = ' ';  
292            result.append(bp, static_cast<std::size_t>(ep - bp));
293            break;
294          case 'U':
295            bp = Format02d(ep, ToWeek(civil_day(al.cs), weekday::sunday));
296            result.append(bp, static_cast<std::size_t>(ep - bp));
297            break;
298          case 'u':
299            bp = Format64(ep, 0, tm.tm_wday ? tm.tm_wday : 7);
300            result.append(bp, static_cast<std::size_t>(ep - bp));
301            break;
302          case 'W':
303            bp = Format02d(ep, ToWeek(civil_day(al.cs), weekday::monday));
304            result.append(bp, static_cast<std::size_t>(ep - bp));
305            break;
306          case 'w':
307            bp = Format64(ep, 0, tm.tm_wday);
308            result.append(bp, static_cast<std::size_t>(ep - bp));
309            break;
310          case 'H':
311            bp = Format02d(ep, al.cs.hour());
312            result.append(bp, static_cast<std::size_t>(ep - bp));
313            break;
314          case 'M':
315            bp = Format02d(ep, al.cs.minute());
316            result.append(bp, static_cast<std::size_t>(ep - bp));
317            break;
318          case 'S':
319            bp = Format02d(ep, al.cs.second());
320            result.append(bp, static_cast<std::size_t>(ep - bp));
321            break;
322          case 'z':
323            bp = FormatOffset(ep, al.offset, "");
324            result.append(bp, static_cast<std::size_t>(ep - bp));
325            break;
326          case 'Z':
327            result.append(al.abbr);
328            break;
329          case 's':
330            bp = Format64(ep, 0, ToUnixSeconds(tp));
331            result.append(bp, static_cast<std::size_t>(ep - bp));
332            break;
333          case '%':
334            result.push_back('%');
335            break;
336        }
337        pending = ++cur;
338        continue;
339      }
340      if (*cur == ':' && cur + 1 != end) {
341        if (*(cur + 1) == 'z') {
342          if (cur - 1 != pending) {
343            FormatTM(&result, std::string(pending, cur - 1), tm);
344          }
345          bp = FormatOffset(ep, al.offset, ":");
346          result.append(bp, static_cast<std::size_t>(ep - bp));
347          pending = cur += 2;
348          continue;
349        }
350        if (*(cur + 1) == ':' && cur + 2 != end) {
351          if (*(cur + 2) == 'z') {
352            if (cur - 1 != pending) {
353              FormatTM(&result, std::string(pending, cur - 1), tm);
354            }
355            bp = FormatOffset(ep, al.offset, ":*");
356            result.append(bp, static_cast<std::size_t>(ep - bp));
357            pending = cur += 3;
358            continue;
359          }
360          if (*(cur + 2) == ':' && cur + 3 != end) {
361            if (*(cur + 3) == 'z') {
362              if (cur - 1 != pending) {
363                FormatTM(&result, std::string(pending, cur - 1), tm);
364              }
365              bp = FormatOffset(ep, al.offset, ":*:");
366              result.append(bp, static_cast<std::size_t>(ep - bp));
367              pending = cur += 4;
368              continue;
369            }
370          }
371        }
372      }
373      if (*cur != 'E' || ++cur == end) continue;
374      if (*cur == 'T') {
375        if (cur - 2 != pending) {
376          FormatTM(&result, std::string(pending, cur - 2), tm);
377        }
378        result.append("T");
379        pending = ++cur;
380      } else if (*cur == 'z') {
381        if (cur - 2 != pending) {
382          FormatTM(&result, std::string(pending, cur - 2), tm);
383        }
384        bp = FormatOffset(ep, al.offset, ":");
385        result.append(bp, static_cast<std::size_t>(ep - bp));
386        pending = ++cur;
387      } else if (*cur == '*' && cur + 1 != end && *(cur + 1) == 'z') {
388        if (cur - 2 != pending) {
389          FormatTM(&result, std::string(pending, cur - 2), tm);
390        }
391        bp = FormatOffset(ep, al.offset, ":*");
392        result.append(bp, static_cast<std::size_t>(ep - bp));
393        pending = cur += 2;
394      } else if (*cur == '*' && cur + 1 != end &&
395                 (*(cur + 1) == 'S' || *(cur + 1) == 'f')) {
396        if (cur - 2 != pending) {
397          FormatTM(&result, std::string(pending, cur - 2), tm);
398        }
399        char* cp = ep;
400        bp = Format64(cp, 15, fs.count());
401        while (cp != bp && cp[-1] == '0') --cp;
402        switch (*(cur + 1)) {
403          case 'S':
404            if (cp != bp) *--bp = '.';
405            bp = Format02d(bp, al.cs.second());
406            break;
407          case 'f':
408            if (cp == bp) *--bp = '0';
409            break;
410        }
411        result.append(bp, static_cast<std::size_t>(cp - bp));
412        pending = cur += 2;
413      } else if (*cur == '4' && cur + 1 != end && *(cur + 1) == 'Y') {
414        if (cur - 2 != pending) {
415          FormatTM(&result, std::string(pending, cur - 2), tm);
416        }
417        bp = Format64(ep, 4, al.cs.year());
418        result.append(bp, static_cast<std::size_t>(ep - bp));
419        pending = cur += 2;
420      } else if (std::isdigit(*cur)) {
421        int n = 0;
422        if (const char* np = ParseInt(cur, 0, 0, 1024, &n)) {
423          if (*np == 'S' || *np == 'f') {
424            if (cur - 2 != pending) {
425              FormatTM(&result, std::string(pending, cur - 2), tm);
426            }
427            bp = ep;
428            if (n > 0) {
429              if (n > kDigits10_64) n = kDigits10_64;
430              bp = Format64(bp, n,
431                            (n > 15) ? fs.count() * kExp10[n - 15]
432                                     : fs.count() / kExp10[15 - n]);
433              if (*np == 'S') *--bp = '.';
434            }
435            if (*np == 'S') bp = Format02d(bp, al.cs.second());
436            result.append(bp, static_cast<std::size_t>(ep - bp));
437            pending = cur = ++np;
438          }
439        }
440      }
441    }
442    if (end != pending) {
443      FormatTM(&result, std::string(pending, end), tm);
444    }
445    return result;
446  }
447  namespace {
448  const char* ParseOffset(const char* dp, const char* mode, int* offset) {
449    if (dp != nullptr) {
450      const char first = *dp++;
451      if (first == '+' || first == '-') {
452        char sep = mode[0];
453        int hours = 0;
454        int minutes = 0;
455        int seconds = 0;
456        const char* ap = ParseInt(dp, 2, 0, 23, &hours);
457        if (ap != nullptr && ap - dp == 2) {
458          dp = ap;
459          if (sep != '\0' && *ap == sep) ++ap;
460          const char* bp = ParseInt(ap, 2, 0, 59, &minutes);
461          if (bp != nullptr && bp - ap == 2) {
462            dp = bp;
<span onclick='openModal()' class='match'>463            if (sep != '\0' && *bp == sep) ++bp;
464            const char* cp = ParseInt(bp, 2, 0, 59, &seconds);
465            if (cp != nullptr && cp - bp == 2) dp = cp;
</span>466          }
467          *offset = ((hours * 60 + minutes) * 60) + seconds;
468          if (first == '-') *offset = -*offset;
469        } else {
470          dp = nullptr;
471        }
472      } else if (first == 'Z' || first == 'z') {  
473        *offset = 0;
474      } else {
475        dp = nullptr;
476      }
477    }
478    return dp;
479  }
480  const char* ParseZone(const char* dp, std::string* zone) {
481    zone->clear();
482    if (dp != nullptr) {
483      while (*dp != '\0' && !std::isspace(*dp)) zone->push_back(*dp++);
484      if (zone->empty()) dp = nullptr;
485    }
486    return dp;
487  }
488  const char* ParseSubSeconds(const char* dp, detail::femtoseconds* subseconds) {
489    if (dp != nullptr) {
490      std::int_fast64_t v = 0;
491      std::int_fast64_t exp = 0;
492      const char* const bp = dp;
493      while (const char* cp = strchr(kDigits, *dp)) {
494        int d = static_cast<int>(cp - kDigits);
495        if (d >= 10) break;
496        if (exp < 15) {
497          exp += 1;
498          v *= 10;
499          v += d;
500        }
501        ++dp;
502      }
503      if (dp != bp) {
504        v *= kExp10[15 - exp];
505        *subseconds = detail::femtoseconds(v);
506      } else {
507        dp = nullptr;
508      }
509    }
510    return dp;
511  }
512  const char* ParseTM(const char* dp, const char* fmt, std::tm* tm) {
513    if (dp != nullptr) {
514      dp = strptime(dp, fmt, tm);
515    }
516    return dp;
517  }
518  bool FromWeek(int week_num, weekday week_start, year_t* year, std::tm* tm) {
519    const civil_year y(*year % 400);
520    civil_day cd = prev_weekday(y, week_start);  
521    cd = next_weekday(cd - 1, FromTmWday(tm->tm_wday)) + (week_num * 7);
522    if (const year_t shift = cd.year() - y.year()) {
523      if (shift > 0) {
524        if (*year > std::numeric_limits<year_t>::max() - shift) return false;
525      } else {
526        if (*year < std::numeric_limits<year_t>::min() - shift) return false;
527      }
528      *year += shift;
529    }
530    tm->tm_mon = cd.month() - 1;
531    tm->tm_mday = cd.day();
532    return true;
533  }
534  }  
535  bool parse(const std::string& format, const std::string& input,
536             const time_zone& tz, time_point<seconds>* sec,
537             detail::femtoseconds* fs, std::string* err) {
538    const char* data = input.c_str();  
539    while (std::isspace(*data)) ++data;
540    const year_t kyearmax = std::numeric_limits<year_t>::max();
541    const year_t kyearmin = std::numeric_limits<year_t>::min();
542    bool saw_year = false;
543    year_t year = 1970;
544    std::tm tm{};
545    tm.tm_year = 1970 - 1900;
546    tm.tm_mon = 1 - 1;  
547    tm.tm_mday = 1;
548    tm.tm_hour = 0;
549    tm.tm_min = 0;
550    tm.tm_sec = 0;
551    tm.tm_wday = 4;  
552    tm.tm_yday = 0;
553    tm.tm_isdst = 0;
554    auto subseconds = detail::femtoseconds::zero();
555    bool saw_offset = false;
556    int offset = 0;  
557    std::string zone = "UTC";
558    const char* fmt = format.c_str();  
559    bool twelve_hour = false;
560    bool afternoon = false;
561    int week_num = -1;
562    weekday week_start = weekday::sunday;
563    bool saw_percent_s = false;
564    std::int_fast64_t percent_s = 0;
565    while (data != nullptr && *fmt != '\0') {
566      if (std::isspace(*fmt)) {
567        while (std::isspace(*data)) ++data;
568        while (std::isspace(*++fmt)) continue;
569        continue;
570      }
571      if (*fmt != '%') {
572        if (*data == *fmt) {
573          ++data;
574          ++fmt;
575        } else {
576          data = nullptr;
577        }
578        continue;
579      }
580      const char* percent = fmt;
581      if (*++fmt == '\0') {
582        data = nullptr;
583        continue;
584      }
585      switch (*fmt++) {
586        case 'Y':
587          data = ParseInt(data, 0, kyearmin, kyearmax, &year);
588          if (data != nullptr) saw_year = true;
589          continue;
590        case 'm':
591          data = ParseInt(data, 2, 1, 12, &tm.tm_mon);
592          if (data != nullptr) tm.tm_mon -= 1;
593          week_num = -1;
594          continue;
595        case 'd':
596        case 'e':
597          data = ParseInt(data, 2, 1, 31, &tm.tm_mday);
598          week_num = -1;
599          continue;
600        case 'U':
601          data = ParseInt(data, 0, 0, 53, &week_num);
602          week_start = weekday::sunday;
603          continue;
604        case 'W':
605          data = ParseInt(data, 0, 0, 53, &week_num);
606          week_start = weekday::monday;
607          continue;
608        case 'u':
609          data = ParseInt(data, 0, 1, 7, &tm.tm_wday);
610          if (data != nullptr) tm.tm_wday %= 7;
611          continue;
612        case 'w':
613          data = ParseInt(data, 0, 0, 6, &tm.tm_wday);
614          continue;
615        case 'H':
616          data = ParseInt(data, 2, 0, 23, &tm.tm_hour);
617          twelve_hour = false;
618          continue;
619        case 'M':
620          data = ParseInt(data, 2, 0, 59, &tm.tm_min);
621          continue;
622        case 'S':
623          data = ParseInt(data, 2, 0, 60, &tm.tm_sec);
624          continue;
625        case 'I':
626        case 'l':
627        case 'r':  
628          twelve_hour = true;
629          break;
630        case 'R':  
631        case 'T':  
632        case 'c':  
633        case 'X':  
634          twelve_hour = false;
635          break;
636        case 'z':
637          data = ParseOffset(data, "", &offset);
638          if (data != nullptr) saw_offset = true;
639          continue;
640        case 'Z':  
641          data = ParseZone(data, &zone);
642          continue;
643        case 's':
644          data =
645              ParseInt(data, 0, std::numeric_limits<std::int_fast64_t>::min(),
646                       std::numeric_limits<std::int_fast64_t>::max(), &percent_s);
647          if (data != nullptr) saw_percent_s = true;
648          continue;
649        case ':':
650          if (fmt[0] == 'z' ||
651              (fmt[0] == ':' &&
652               (fmt[1] == 'z' || (fmt[1] == ':' && fmt[2] == 'z')))) {
653            data = ParseOffset(data, ":", &offset);
654            if (data != nullptr) saw_offset = true;
655            fmt += (fmt[0] == 'z') ? 1 : (fmt[1] == 'z') ? 2 : 3;
656            continue;
657          }
658          break;
659        case '%':
660          data = (*data == '%' ? data + 1 : nullptr);
661          continue;
662        case 'E':
663          if (fmt[0] == 'T') {
664            if (*data == 'T' || *data == 't') {
665              ++data;
666              ++fmt;
667            } else {
668              data = nullptr;
669            }
670            continue;
671          }
672          if (fmt[0] == 'z' || (fmt[0] == '*' && fmt[1] == 'z')) {
673            data = ParseOffset(data, ":", &offset);
674            if (data != nullptr) saw_offset = true;
675            fmt += (fmt[0] == 'z') ? 1 : 2;
676            continue;
677          }
678          if (fmt[0] == '*' && fmt[1] == 'S') {
679            data = ParseInt(data, 2, 0, 60, &tm.tm_sec);
680            if (data != nullptr && *data == '.') {
681              data = ParseSubSeconds(data + 1, &subseconds);
682            }
683            fmt += 2;
684            continue;
685          }
686          if (fmt[0] == '*' && fmt[1] == 'f') {
687            if (data != nullptr && std::isdigit(*data)) {
688              data = ParseSubSeconds(data, &subseconds);
689            }
690            fmt += 2;
691            continue;
692          }
693          if (fmt[0] == '4' && fmt[1] == 'Y') {
694            const char* bp = data;
695            data = ParseInt(data, 4, year_t{-999}, year_t{9999}, &year);
696            if (data != nullptr) {
697              if (data - bp == 4) {
698                saw_year = true;
699              } else {
700                data = nullptr;  
701              }
702            }
703            fmt += 2;
704            continue;
705          }
706          if (std::isdigit(*fmt)) {
707            int n = 0;  
708            if (const char* np = ParseInt(fmt, 0, 0, 1024, &n)) {
709              if (*np == 'S') {
710                data = ParseInt(data, 2, 0, 60, &tm.tm_sec);
711                if (data != nullptr && *data == '.') {
712                  data = ParseSubSeconds(data + 1, &subseconds);
713                }
714                fmt = ++np;
715                continue;
716              }
717              if (*np == 'f') {
718                if (data != nullptr && std::isdigit(*data)) {
719                  data = ParseSubSeconds(data, &subseconds);
720                }
721                fmt = ++np;
722                continue;
723              }
724            }
725          }
726          if (*fmt == 'c') twelve_hour = false;  
727          if (*fmt == 'X') twelve_hour = false;  
728          if (*fmt != '\0') ++fmt;
729          break;
730        case 'O':
731          if (*fmt == 'H') twelve_hour = false;
732          if (*fmt == 'I') twelve_hour = true;
733          if (*fmt != '\0') ++fmt;
734          break;
735      }
736      const char* orig_data = data;
737      std::string spec(percent, static_cast<std::size_t>(fmt - percent));
738      data = ParseTM(data, spec.c_str(), &tm);
739      if (spec == "%p" && data != nullptr) {
740        std::string test_input = "1";
741        test_input.append(orig_data, static_cast<std::size_t>(data - orig_data));
742        const char* test_data = test_input.c_str();
743        std::tm tmp{};
744        ParseTM(test_data, "%I%p", &tmp);
745        afternoon = (tmp.tm_hour == 13);
746      }
747    }
748    if (twelve_hour && afternoon && tm.tm_hour < 12) {
749      tm.tm_hour += 12;
750    }
751    if (data == nullptr) {
752      if (err != nullptr) *err = "Failed to parse input";
753      return false;
754    }
755    while (std::isspace(*data)) ++data;
756    if (*data != '\0') {
757      if (err != nullptr) *err = "Illegal trailing data in input string";
758      return false;
759    }
760    if (saw_percent_s) {
761      *sec = FromUnixSeconds(percent_s);
762      *fs = detail::femtoseconds::zero();
763      return true;
764    }
765    time_zone ptz = saw_offset ? utc_time_zone() : tz;
766    if (tm.tm_sec == 60) {
767      tm.tm_sec -= 1;
768      offset -= 1;
769      subseconds = detail::femtoseconds::zero();
770    }
771    if (!saw_year) {
772      year = year_t{tm.tm_year};
773      if (year > kyearmax - 1900) {
774        if (err != nullptr) *err = "Out-of-range year";
775        return false;
776      }
777      year += 1900;
778    }
779    if (week_num != -1) {
780      if (!FromWeek(week_num, week_start, &year, &tm)) {
781        if (err != nullptr) *err = "Out-of-range field";
782        return false;
783      }
784    }
785    const int month = tm.tm_mon + 1;
786    civil_second cs(year, month, tm.tm_mday, tm.tm_hour, tm.tm_min, tm.tm_sec);
787    if (cs.month() != month || cs.day() != tm.tm_mday) {
788      if (err != nullptr) *err = "Out-of-range field";
789      return false;
790    }
791    if ((offset < 0 && cs > civil_second::max() + offset) ||
792        (offset > 0 && cs < civil_second::min() + offset)) {
793      if (err != nullptr) *err = "Out-of-range field";
794      return false;
795    }
796    cs -= offset;
797    const auto tp = ptz.lookup(cs).pre;
798    if (tp == time_point<seconds>::max()) {
799      const auto al = ptz.lookup(time_point<seconds>::max());
800      if (cs > al.cs) {
801        if (err != nullptr) *err = "Out-of-range field";
802        return false;
803      }
804    }
805    if (tp == time_point<seconds>::min()) {
806      const auto al = ptz.lookup(time_point<seconds>::min());
807      if (cs < al.cs) {
808        if (err != nullptr) *err = "Out-of-range field";
809        return false;
810      }
811    }
812    *sec = tp;
813    *fs = subseconds;
814    return true;
815  }
816  }  
817  }  
818  }  
819  ABSL_NAMESPACE_END
820  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-time_zone_format.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-time_zone_format.cc</div>
                </div>
                <div class="column column_space"><pre><code>459          if (sep != '\0' && *ap == sep) ++ap;
460          const char* bp = ParseInt(ap, 2, 0, 59, &minutes);
461          if (bp != nullptr && bp - ap == 2) {
</pre></code></div>
                <div class="column column_space"><pre><code>463            if (sep != '\0' && *bp == sep) ++bp;
464            const char* cp = ParseInt(bp, 2, 0, 59, &seconds);
465            if (cp != nullptr && cp - bp == 2) dp = cp;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    