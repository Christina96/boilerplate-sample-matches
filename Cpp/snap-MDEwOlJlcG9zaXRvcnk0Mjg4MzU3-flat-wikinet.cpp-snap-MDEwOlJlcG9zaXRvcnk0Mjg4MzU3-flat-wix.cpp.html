
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 27, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-wikinet.cpp</h3>
            <pre><code>1  #include "stdafx.h"
2  #include "wikinet.h"
3  #include "trawling.h"
4  TWikiUsr::TWikiUsr() : Usr(), Admin(false), ElecTm(), BarnStars(), MnEdCnt(), MnEdWrds(), MnTkEdCnt(), MnTkEdWrds(),
5    WkEdCnt(), WkEdWrds(), WkTkEdCnt(), WkTkEdWrds(), MnRevCnt(), MnRevWrds() {
6  }
7  TWikiUsr::TWikiUsr(const TChA& UsrStr) : Usr(UsrStr), Admin(false), ElecTm(), BarnStars(), MnEdCnt(), MnEdWrds(),
8    MnTkEdCnt(), MnTkEdWrds(), WkEdCnt(), WkEdWrds(), WkTkEdCnt(), WkTkEdWrds(), MnRevCnt(), MnRevWrds() {
9  }
10  TWikiUsr::TWikiUsr(const TWikiUsr& WikiUsr) : Usr(WikiUsr.Usr), Admin(WikiUsr.Admin), ElecTm(WikiUsr.ElecTm),
11    BarnStars(WikiUsr.BarnStars), MnEdCnt(WikiUsr.MnEdCnt), MnEdWrds(WikiUsr.MnEdWrds),
12    MnTkEdCnt(WikiUsr.MnTkEdCnt), MnTkEdWrds(WikiUsr.MnTkEdWrds), WkEdCnt(WikiUsr.WkEdCnt),
13    WkEdWrds(WikiUsr.WkEdWrds), WkTkEdCnt(WikiUsr.WkTkEdCnt), WkTkEdWrds(WikiUsr.WkTkEdWrds),
14    MnRevCnt(WikiUsr.MnRevCnt), MnRevWrds(WikiUsr.MnRevCnt) {
15  }
16  TWikiUsr::TWikiUsr(TSIn& SIn) : Usr(SIn), Admin(SIn), ElecTm(SIn), BarnStars(SIn), MnEdCnt(SIn),
17    MnEdWrds(SIn), MnTkEdCnt(SIn), MnTkEdWrds(SIn), WkEdCnt(SIn), WkEdWrds(SIn), WkTkEdCnt(SIn), WkTkEdWrds(SIn)
18    , MnRevCnt(SIn), MnRevWrds(SIn)
19  {
20  }
21  void TWikiUsr::Save(TSOut& SOut) const {
22    Usr.Save(SOut);  Admin.Save(SOut);  ElecTm.Save(SOut);
23    BarnStars.Save(SOut);  MnEdCnt.Save(SOut);  MnEdWrds.Save(SOut);
24    MnTkEdCnt.Save(SOut);  MnTkEdWrds.Save(SOut);  WkEdCnt.Save(SOut);  WkEdWrds.Save(SOut);
25    WkTkEdCnt.Save(SOut);  WkTkEdWrds.Save(SOut);
26    MnRevCnt.Save(SOut);   MnRevWrds.Save(SOut);
27  }
28  TWikiTalkEdge::TWikiTalkEdge() : TotTalks(), TotWords(), TalksBE(), WordsBE(), TalksAE(), WordsAE(), VoteSign(0), FirstTalk(), LastTalk(), VoteTm() {
29  }
30  TWikiTalkEdge::TWikiTalkEdge(const int& _VoteSign) : TotTalks(), TotWords(), TalksBE(), WordsBE(), TalksAE(), WordsAE(),
31    VoteSign(_VoteSign), FirstTalk(), LastTalk(), VoteTm() {
32  }
33  TWikiTalkEdge::TWikiTalkEdge(const TSecTm& FTalk, const TSecTm& LTalk, const int& NTalks, const int& NWords) :
34    TotTalks(NTalks), TotWords(NWords), TalksBE(), WordsBE(), TalksAE(), WordsAE(), VoteSign(0), FirstTalk(FTalk), LastTalk(LTalk), VoteTm() {
35  }
36  TWikiTalkEdge::TWikiTalkEdge(const TWikiTalkEdge& Talk) : TotTalks(Talk.TotTalks), TotWords(Talk.TotWords),
37    TalksBE(Talk.TalksBE), WordsBE(Talk.WordsBE), TalksAE(Talk.TalksAE), WordsAE(Talk.WordsAE),
38    VoteSign(Talk.VoteSign), FirstTalk(Talk.FirstTalk), LastTalk(Talk.LastTalk), VoteTm(Talk.VoteTm) {
39  }
40  TWikiTalkEdge::TWikiTalkEdge(TSIn& SIn) : TotTalks(SIn), TotWords(SIn), TalksBE(SIn), WordsBE(SIn),
41    TalksAE(SIn), WordsAE(SIn), VoteSign(SIn), FirstTalk(SIn), LastTalk(SIn), VoteTm(SIn) {
42  }
43  void TWikiTalkEdge::Save(TSOut& SOut) const {
44    TotTalks.Save(SOut);  TotWords.Save(SOut);
45    TalksBE.Save(SOut);   WordsBE.Save(SOut);
46    TalksAE.Save(SOut);   WordsAE.Save(SOut);
47    VoteSign.Save(SOut);  FirstTalk.Save(SOut);
48    LastTalk.Save(SOut);  VoteTm.Save(SOut);
49  }
50  int TWikiTalkNet::GetUsrNId(const TStr& UsrStr) const {
51    const int KeyId = UsrNIdH.GetKeyId(UsrStr);
52    if (KeyId==-1) { return -1; }
53    else { return UsrNIdH[KeyId]; }
54  }
55  bool TWikiTalkNet::IsUsr(const TStr& UsrStr) const {
56    return UsrNIdH.IsKey(UsrStr);
57  }
58  void TWikiTalkNet::PermuteAllVoteSigns(const bool& OnlyVotes) {
59    printf("\nPermuting %s edge signs\n", OnlyVotes?"VOTE":"ALL");
60    TVec<TWikiTalkEdge> EDatV;
61    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
62      if (OnlyVotes && EI().GetVote() != 0) { EDatV.Add(EI()); }
63      else if (! OnlyVotes){ EDatV.Add(EI()); }
64    }
65    EDatV.Shuffle(TInt::Rnd);
66    int cnt = 0;
67    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
68      if (OnlyVotes && EI().GetVote() != 0) { EI() = EDatV[cnt++]; }
69      else if (! OnlyVotes){ EI() = EDatV[cnt++]; }
70    }
71  }
72  void TWikiTalkNet::PermuteOutVoteSigns(const bool& OnlyVotes) {
73    TIntV VoteSignV;
74    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
75      for (int e = 0; e < NI.GetOutDeg(); e++) {
76        if (OnlyVotes && NI.GetOutEDat(e).GetVote() != 0) {
77          VoteSignV.Add(NI.GetOutEDat(e).GetVote()); }
78        else if (! OnlyVotes) {
79          VoteSignV.Add(NI.GetOutEDat(e).GetVote()); }
80      }
81    }
82    VoteSignV.Shuffle(TInt::Rnd);
83    int cnt = 0;
84    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
85      for (int e = 0; e < NI.GetOutDeg(); e++) {
86        if (OnlyVotes && NI.GetOutEDat(e).GetVote() != 0) {
87          NI.GetOutEDat(e).VoteSign = VoteSignV[cnt++]; }
88        else if (! OnlyVotes) {
89          NI.GetOutEDat(e).VoteSign = VoteSignV[cnt++]; }
90      }
91    }
92  }
93  void TWikiTalkNet::CountStructBalance() const {
94    TIntSet NbrIdSet;
95    THash<TIntTr, TInt> TriadCntH;
96    TIntH SignH;
97    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
98      SignH.AddDat(EI().VoteSign()) += 1;
99    }
100    printf("Structural balance triads:\n  background sign distribution:\n");
101    SignH.SortByKey(false);
102    for (int i = 0; i < SignH.Len(); i++) {
103      printf("\t%2d\t%d\n", SignH.GetKey(i), SignH[i]);
104    }
105    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
106      const TNodeI SrcNI = GetNI(EI.GetSrcNId());
107      const TNodeI DstNI = GetNI(EI.GetDstNId());
108      const TInt E1Dat = EI().VoteSign();
109      NbrIdSet.Clr(false);
110      for (int es = 0; es < SrcNI.GetDeg(); es++) {
111        NbrIdSet.AddKey(SrcNI.GetNbrNId(es)); }
112      for (int ed = 0; ed < DstNI.GetDeg(); ed++) {
113        const int nbr = DstNI.GetNbrNId(ed);
114        if (! NbrIdSet.IsKey(nbr)) { continue; }
115        const TInt E2Dat = SrcNI.GetNbrEDat(NbrIdSet.GetKeyId(nbr)).VoteSign();
116        const TInt E3Dat = DstNI.GetNbrEDat(ed).VoteSign();
117        TriadCntH.AddDat(TIntTr(TMath::Mx(E1Dat, E2Dat, E3Dat),
118          TMath::Median(E1Dat, E2Dat, E3Dat), TMath::Mn(E1Dat, E2Dat, E3Dat))) += 1;
119      }
120    }
121    TriadCntH.SortByKey(false);
122    printf("triad counts (all counts times 3):\n");
123    int SumTriad = 0, SignTriad=0;
124    for (int i = 0; i < TriadCntH.Len(); i++) {
125      SumTriad += TriadCntH[i];
126      TIntTr SignTr = TriadCntH.GetKey(i);
127      if (SignTr.Val1!=0 && SignTr.Val2!=0 && SignTr.Val3!=0) {
128        SignTriad += TriadCntH[i];; }
129    }
130    for (int i = 0; i < TriadCntH.Len(); i++) {
131      TIntTr SignTr = TriadCntH.GetKey(i);
132      printf("\t%2d %2d %2d\t%8d\t%f", SignTr.Val1, SignTr.Val2, SignTr.Val3,
133        TriadCntH[i], TriadCntH[i]/double(SumTriad));
134      if (SignTr.Val1!=0 && SignTr.Val2!=0 && SignTr.Val3!=0) {
135        printf("\t%f", TriadCntH[i]/double(SignTriad)); }
136      printf("\n");
137    }
138  }
139  void TWikiTalkNet::FindPartitions(const int& NPart, const bool& OnlyMinus) const {
140    printf("\nFind %d partitions use %s edges\n", NPart, OnlyMinus?"NEGATIVE":"ALL");
141    TIntV NIdV(GetNodes(), 0);
142    TIntH NIdPartH;
143    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
144      NIdPartH.AddDat(NI.GetId(), TInt::Rnd.GetUniDevInt(NPart));
145      NIdV.Add(NI.GetId());
146    }
147    int Flips = 0;
148    TIntPrV CntPartV;
149    for (int p = 0; p < NPart; p++) {
150      CntPartV.Add(TIntPr(0, p)); }
151    for (int iter = 0; iter < 100; iter++) {
152      NIdV.Shuffle(TInt::Rnd);
153      Flips = 0;
154      for (int n = 0; n < NIdV.Len(); n++) {
155        TNodeI NI = GetNI(NIdV[n]);
156        for (int p = 0; p < NPart; p++) {
157          CntPartV[p].Val1=0;  CntPartV[p].Val2=p; }
158        for (int e = 0; e < NI.GetOutDeg(); e++) {
159          const int DstPart = NIdPartH.GetDat(NI.GetOutNId(e));
160          const int Vote = NI.GetOutEDat(e).GetVote();
161          if (OnlyMinus && Vote==-1) { CntPartV[DstPart].Val1 += -1; }
162          else if (! OnlyMinus) { CntPartV[DstPart].Val1 += Vote; }
163        }
164        CntPartV.Sort(false); 
165        const int NewPart = CntPartV[0].Val2;
166        if (NIdPartH.GetDat(NI.GetId()) != NewPart) {
167          NIdPartH.AddDat(NI.GetId(), NewPart);
168          Flips++;
169        }
170      }
171    }
172    int OkMns=0, OkPls=0, AllMns=0, AllPls=0;
173    TIntH OkPlsH, AllPlsH, OkMnsH, AllMnsH;
174    for (int p = 0; p < NPart; p++) {
175      OkPlsH.AddDat(p,0); AllPlsH.AddDat(p,0);
176      OkMnsH.AddDat(p,0); AllMnsH.AddDat(p,0);
177    }
178    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
179      const int SrcPart = NIdPartH.GetDat(NI.GetId());
180      for (int e = 0; e < NI.GetOutDeg(); e++) {
181        const int DstPart = NIdPartH.GetDat(NI.GetOutNId(e));
182        const int Vote = NI.GetOutEDat(e).GetVote();
183        if (Vote == -1) {
184          if (DstPart != SrcPart) { OkMnsH.AddDat(SrcPart) += 1;  OkMns++; }
185          AllMnsH.AddDat(SrcPart) += 1;  AllMns++; }
186        if (Vote == +1) {
187          if (DstPart == SrcPart) { OkPlsH.AddDat(SrcPart) += 1;  OkPls++; }
188          AllPlsH.AddDat(SrcPart) += 1;  AllPls++;
189        }
190      }
191    }
192    printf("\nSatisfied edges: + : %5d / %5d  = %f\n", OkPls, AllPls, double(OkPls)/double(AllPls));
193    printf(  "                 - : %5d / %5d  = %f\n", OkMns, AllMns, double(OkMns)/double(AllMns));
194    TIntH PartCntH;
195    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
196      PartCntH.AddDat(NIdPartH.GetDat(NI.GetId())) += 1; }
197    PartCntH.SortByKey();
198    for (int p = 0; p < PartCntH.Len(); p++) {
199      printf("  part %2d : %5d (%.4f) nodes: +: %25s    -: %25s\n", p, PartCntH[p], PartCntH[p]/double(NIdPartH.Len()),
200        TStr::Fmt("%5d/%d=%.4f", OkPlsH.GetDat(PartCntH.GetKey(p)), AllPlsH.GetDat(PartCntH.GetKey(p)), OkPlsH.GetDat(PartCntH.GetKey(p))/double(AllPlsH.GetDat(PartCntH.GetKey(p)))).CStr(),
201        TStr::Fmt("%5d/%d=%.4f", OkMnsH.GetDat(PartCntH.GetKey(p)), AllMnsH.GetDat(PartCntH.GetKey(p)), OkMnsH.GetDat(PartCntH.GetKey(p))/double(AllMnsH.GetDat(PartCntH.GetKey(p)))).CStr() );
202    }
203  }
204  void TWikiTalkNet::GetPartStat(const TVec<TIntV>& PartNIdV) const {
205    THash<TIntPr, TIntPr> PartEdgeH;
206    TIntH NIdPartH;
207    for (int p = 0; p < PartNIdV.Len(); p++) {
208      for (int n = 0; n < PartNIdV[p].Len(); n++) {
209        NIdPartH.AddDat(PartNIdV[p][n], p);
210      }
211    }
212    TInt DstPart;
213    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
214      if (! NIdPartH.IsKey(NI.GetId())) { continue; }
215      const int p = NIdPartH.GetDat(NI.GetId());
216      for (int e = 0; e < NI.GetOutDeg(); e++) {
217        const int Vote = NI.GetOutEDat(e).GetVote();
218        TIntPr& IOCnt = PartEdgeH.AddDat(TIntPr(p, Vote));
219        if (NIdPartH.IsKeyGetDat(NI.GetOutNId(e), DstPart) && DstPart==p) {
220          if (Vote==1) { IOCnt.Val1++; } else { IOCnt.Val2++; } }
221        else {
222          if (Vote==-1) { IOCnt.Val1++; } else { IOCnt.Val2++; } }
223      }
224    }
225    PartEdgeH.SortByKey();
226    printf("Partition statistics (satisfied edges):\n");
227    for (int p = 0; p < PartEdgeH.Len(); p++) {
228      printf("  %2d  %2d : %6d : %6d  =  %f\n", PartEdgeH.GetKey(p).Val1, PartEdgeH.GetKey(p).Val2,
229        PartEdgeH[p].Val1(), PartEdgeH[p].Val2(), PartEdgeH[p].Val1/double(PartEdgeH[p].Val1+PartEdgeH[p].Val2));
230    }
231  }
232  PWikiTalkNet TWikiTalkNet::GetVoteSubNet(const int& VoteSign, const bool& VoteOnly, const bool& TalkOnly) const {
233    PWikiTalkNet Net = TWikiTalkNet::New();
234    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
235      if (! (EI().GetVote()==VoteSign || (VoteSign==11 && EI().GetVote()!=0))) { continue; }
236      if (VoteOnly && ! EI().IsVoteE()) { continue; }
237      if (TalkOnly && ! EI().IsTalkE()) { continue; }
238      if (! Net->IsNode(EI.GetSrcNId())) {
239        Net->UsrNIdH.AddDat(EI.GetSrcNDat().Usr, EI.GetSrcNId());
240        Net->AddNode(EI.GetSrcNId(), EI.GetSrcNDat());
241      }
242      if (! Net->IsNode(EI.GetDstNId())) {
243        Net->UsrNIdH.AddDat(EI.GetDstNDat().Usr, EI.GetDstNId());
244        Net->AddNode(EI.GetDstNId(), EI.GetDstNDat());
245      }
246      Net->AddEdge(EI);
247    }
248    TSnap::PrintInfo(Net, TStr::Fmt("Vote network: sign %d %s %s",
249      VoteSign, VoteOnly?"OnlyVote":"", TalkOnly?"OnlyTalk":""));
250    return Net;
251  }
252  PSignNet TWikiTalkNet::GetSignNet(const int& VoteSign, const bool& VoteOnly, const bool& TalkOnly) const {
253    PSignNet Net = TSignNet::New();
254    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
255      if (EI.GetSrcNId() == EI.GetDstNId()) { continue; }
256      if (! (EI().GetVote()==VoteSign || (VoteSign==11 && EI().GetVote()!=0))) { continue; }
257      if (VoteOnly && ! EI().IsVoteE()) { continue; }
258      if (TalkOnly && ! EI().IsTalkE()) { continue; }
259      if (! Net->IsNode(EI.GetSrcNId())) {
260        Net->AddNode(EI.GetSrcNId(), 0); }
261      if (! Net->IsNode(EI.GetDstNId())) {
262        Net->AddNode(EI.GetDstNId(), 0); }
263      Net->AddEdge(EI.GetSrcNId(), EI.GetDstNId(), EI().GetVote());
264    }
265    return Net;
266  }
267  void TWikiTalkNet::TestPartitions(const TStr& OutFNm) {
268    { PSignNet MnsNet = GetSignNet(-1, true, false);
269    PSignNet AllNet = GetSignNet(11, true, false);
270    PSignNet CoreNet = TSnap::GetKCore(TSnap::GetMxWcc(MnsNet), 2);
271    TSnap::PrintInfo(CoreNet, "MINUS K-CORE");
272    for (int npart  = 2; npart < 5; npart++) {
273      printf("\n**** %d-partitions\n", npart);
274      THopfield Hopfield(CoreNet);
275      Hopfield.FindStableSet(npart, 1000);
276      TVec<TIntV> PartNIdV;
277      Hopfield.GetStableSet(990, PartNIdV);
278      Hopfield.PlotPartStab(TStr::Fmt("%s-c2-p%d", OutFNm.CStr(), npart));
279      CoreNet->GetPartStat(PartNIdV, "NETWORK 2-CORE");
280      MnsNet->GetPartStat(PartNIdV, "FULL MINUS NET");
281      AllNet->GetPartStat(PartNIdV, "FULL PLUS-MINUS NET");
282    } }
283    PermuteAllVoteSigns(false);
284    printf("\n*** PERMUTE EDGE SIGNS ************************************************************************************\n");
285    { PSignNet MnsNet = GetSignNet(-1, true, false);
286    PSignNet AllNet = GetSignNet(11, true, false);
287    PSignNet CoreNet = TSnap::GetKCore(TSnap::GetMxWcc(MnsNet), 2);
288    TSnap::PrintInfo(CoreNet, "MINUS K-CORE");
289    for (int npart  = 2; npart < 6; npart++) {
290      printf("\n**** %d-partitions\n", npart);
291      THopfield Hopfield(CoreNet);
292      Hopfield.FindStableSet(npart, 1000);
293      TVec<TIntV> PartNIdV;
294      Hopfield.GetStableSet(990, PartNIdV);
295      Hopfield.PlotPartStab(TStr::Fmt("%s-c2-Rp%d", OutFNm.CStr(), npart));
296      CoreNet->GetPartStat(PartNIdV, "NETWORK 2-CORE");
297      MnsNet->GetPartStat(PartNIdV, "FULL MINUS NET");
298      AllNet->GetPartStat(PartNIdV, "FULL PLUS-MINUS NET");
299    } }
300  }
301  void TWikiTalkNet::PlotBarnStarDelta(const TStr& OutFNm) const {
302    THash<TInt, TMom> DiffMomH;
303    TIntH DiffCntH;
304    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
305      if (EI().GetVote() == 0) { continue; }
306      DiffMomH.AddDat(EI.GetSrcNDat().GetStars()-EI.GetDstNDat().GetStars()).Add(EI().GetVote()==1?1:0);
307      DiffCntH.AddDat(EI.GetSrcNDat().GetStars()-EI.GetDstNDat().GetStars()) += 1;
308    }
309    TGnuPlot::PlotValMomH(DiffMomH, "dBarnStars-"+OutFNm, "Number of BarnStars (over ALL VOTES): "+OutFNm, "Barnstars delta (source - destination)",
310      "Fraction of positive votes", gpsAuto, gpwLinesPoints, true, false, false, false, true);
311    TGnuPlot::PlotValCntH(DiffCntH, "dBarnStarts2-"+OutFNm, "Number of BarnSTars (over aLL VOES): "+OutFNm, "Barnstars delta (source - destination)",
312      "Number of such users", gpsAuto, false, gpwLinesPoints, false, false);
313  }
314  int log10Delta(const int& Delta) {
315    if (Delta == 0) { return 0; }
316    else if (Delta > 0) { return (int)log10((double)Delta)+1; }
317    else if (Delta < 0) { return -(int)log10((double)-Delta)+1; }
318    Fail; return -1;
319  }
320  void TWikiTalkNet::PlotFracPosVsWords(const TStr& OutFNm) const {
321    THash<TInt, TMom> DiffMomH, DiffMomH2, WrdAE, WrdBE, TlkAE, TlkBE;
322    TIntH DiffCntH, DiffCntH2, CWrdAE, CWrdBE, CTlkAE, CTlkBE;
323    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
324      if (EI().GetVote() == 0) { continue; }
325      if (! EI().IsVoteTalkE()) { continue; }
326      if (EI().GetTalks() < 50) {
327        DiffMomH.AddDat(EI().GetTalks()).Add(EI().GetVote()==1?1:0);
328        DiffCntH.AddDat(EI().GetTalks()) += 1;
329        TlkBE.AddDat((EI().GetTalksBE())).Add(EI().GetVote()==1?1:0);
330        CTlkBE.AddDat((EI().GetTalksBE())) += 1;
331        TlkAE.AddDat((EI().GetTalksAE())).Add(EI().GetVote()==1?1:0);
332        CTlkAE.AddDat((EI().GetTalksAE())) += 1;
333      }
334      DiffMomH2.AddDat(log10Delta(EI().GetWords())).Add(EI().GetVote()==1?1:0);
335      DiffCntH2.AddDat(log10Delta(EI().GetWords())) += 1;
336      WrdBE.AddDat(log10Delta(EI().GetWordsBE())).Add(EI().GetVote()==1?1:0);
337      CWrdBE.AddDat(log10Delta(EI().GetWordsBE())) += 1;
338      WrdAE.AddDat(log10Delta(EI().GetWordsAE())).Add(EI().GetVote()==1?1:0);
339      CWrdAE.AddDat(log10Delta(EI().GetWordsAE())) += 1;
340    }
341    TGnuPlot::PlotValMomH(DiffMomH, "talks-"+OutFNm, "Number of talks: "+OutFNm, "Number of times users talked",
342      "Fraction of positive votes", gpsAuto, gpwLinesPoints, true, false, false, false, false, true);
343    TGnuPlot::PlotValCntH(DiffCntH, "talks2-"+OutFNm, "Number of talks: "+OutFNm, "Number of times users talked",
344      "Number of such users", gpsAuto, false, gpwLinesPoints, false, false);
345    TGnuPlot::PlotValMomH(DiffMomH2, "words-"+OutFNm, "Number of words edited: "+OutFNm, "Number of words edited",
346      "Fraction of positive votes", gpsAuto, gpwLinesPoints, true, false, false, false, false, true);
347    TGnuPlot::PlotValCntH(DiffCntH2, "words2-"+OutFNm, "Number of words edited: "+OutFNm, "Number of words edited",
348      "Number of such users", gpsAuto, false, gpwLinesPoints, false, false);
349    TGnuPlot::PlotValMomH(WrdAE, "wordsBE-"+OutFNm, "Number of words edited: "+OutFNm, "Number of words edited BEFORE the election (on talk page between a pair)",
350      "Fraction of positive votes", gpsAuto, gpwLinesPoints, true, false, false, false, false, true);
351    TGnuPlot::PlotValCntH(CWrdAE, "wordsBE2-"+OutFNm, "Number of words edited: "+OutFNm, "Number of words edited BEFORE the election (on talk page between a pair)",
352      "Number of such users", gpsAuto, false, gpwLinesPoints, false, false);
353    TGnuPlot::PlotValMomH(WrdBE, "wordsAE-"+OutFNm, "Number of words edited: "+OutFNm, "Number of words edited AFTER the election (on talk page between a pair)",
354      "Fraction of positive votes", gpsAuto, gpwLinesPoints, true, false, false, false, false, true);
355    TGnuPlot::PlotValCntH(CWrdBE, "wordsAE2-"+OutFNm, "Number of words edited: "+OutFNm, "Number of words edited AFTER the election (on talk page between a pair)",
356      "Number of such users", gpsAuto, false, gpwLinesPoints, false, false);
357    TGnuPlot::PlotValMomH(TlkAE, "talksBE-"+OutFNm, "Number of talks edited: "+OutFNm, "Number of talks BEFORE the election (on talk page between a pair)",
358      "Fraction of positive votes", gpsAuto, gpwLinesPoints, true, false, false, false, false, true);
359    TGnuPlot::PlotValCntH(CTlkAE, "talksBE2-"+OutFNm, "Number of talks edited: "+OutFNm, "Number of talks BEFORE the election (on talk page between a pair)",
360      "Number of such users", gpsAuto, false, gpwLinesPoints, false, false);
361    TGnuPlot::PlotValMomH(TlkBE, "talksAE-"+OutFNm, "Number of talks edited: "+OutFNm, "Number of talks AFTER the election (on talk page between a pair)",
362      "Fraction of positive votes", gpsAuto, gpwLinesPoints, true, false, false, false, false, true);
363    TGnuPlot::PlotValCntH(CTlkBE, "talksAE2-"+OutFNm, "Number of talks edited: "+OutFNm, "Number of talks AFTER the election (on talk page between a pair)",
364      "Number of such users", gpsAuto, false, gpwLinesPoints, false, false);
365  }
366  void TWikiTalkNet::PlotFracPosVsWords2(const TStr& OutFNm) const {
367    THash<TInt, TMom> TlkAll, WrdAll, WrdAE, WrdBE, TlkAE, TlkBE, EdtAll, EdtAll2, EdtAll3;
368    TIntH NIdTAE, NIdTBE, NIdTalks, NIdWAE, NIdWBE, NIdWords;
369    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
370      NIdTAE.AddDat(EI.GetDstNId()) += EI().GetTalksAE();
371      NIdTBE.AddDat(EI.GetDstNId()) += EI().GetTalksBE();
372      NIdTalks.AddDat(EI.GetDstNId()) += EI().GetTalks();
373      NIdWAE.AddDat(EI.GetDstNId()) += EI().GetWordsAE();
374      NIdWBE.AddDat(EI.GetDstNId()) += EI().GetWordsBE();
375      NIdWords.AddDat(EI.GetDstNId()) += EI().GetWords();
376    }
377    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
378      if (EI().GetVote() == 0) { continue; }
379      const int C = EI.GetDstNId(); 
380      if (NIdTAE.GetDat(C)<1000) TlkAE.AddDat(NIdTAE.GetDat(C)).Add(EI().GetVote()==1?1:0);
381      if (NIdTBE.GetDat(C)<1000) TlkBE.AddDat(NIdTBE.GetDat(C)).Add(EI().GetVote()==1?1:0);
382      if (NIdTalks.GetDat(C)<1000) TlkAll.AddDat(NIdTalks.GetDat(C)).Add(EI().GetVote()==1?1:0);
383      WrdAE.AddDat(log10Delta(NIdWAE.GetDat(C))).Add(EI().GetVote()==1?1:0);
384      WrdBE.AddDat(log10Delta(NIdWBE.GetDat(C))).Add(EI().GetVote()==1?1:0);
385      WrdAll.AddDat(log10Delta(NIdWords.GetDat(C))).Add(EI().GetVote()==1?1:0);
386      EdtAll.AddDat(log10Delta(EI.GetDstNDat().GetEdCnt())).Add(EI().GetVote()==1?1:0);
387      EdtAll2.AddDat(log10Delta(EI.GetDstNDat().GetAllEdCnt())).Add(EI().GetVote()==1?1:0);
388      EdtAll3.AddDat(log10Delta(EI.GetDstNDat().GetTkEdCnt())).Add(EI().GetVote()==1?1:0);
389    }
390    TGnuPlot::PlotValMomH(EdtAll, "editsTot-"+OutFNm, "Number of edits: "+OutFNm, "Total number of times candidate edited",
391      "Fraction of positive votes", gpsAuto, gpwLinesPoints, true, false, false, false, false, true);
392    TGnuPlot::PlotValMomH(EdtAll2, "editsTot2-"+OutFNm, "Number of edits: "+OutFNm, "Total number of times candidate edited",
393      "Fraction of positive votes", gpsAuto, gpwLinesPoints, true, false, false, false, false, true);
394    TGnuPlot::PlotValMomH(EdtAll3, "editsTot3-"+OutFNm, "Number of edits: "+OutFNm, "Total number of times candidate edited",
395      "Fraction of positive votes", gpsAuto, gpwLinesPoints, true, false, false, false, false, true);
396    TGnuPlot::PlotValMomH(TlkAll, "talksTot-"+OutFNm, "Number of talks: "+OutFNm, "Total number of times candidate talked",
397      "Fraction of positive votes", gpsAuto, gpwLinesPoints, true, false, false, false, false, true);
398    TGnuPlot::PlotValMomH(WrdAE, "wordsBETot-"+OutFNm, "Number of words edited: "+OutFNm, "1+Log_10 Total number of words edited of candidate BEFORE the election",
399      "Fraction of positive votes", gpsAuto, gpwLinesPoints, true, false, false, false, false, true);
400    TGnuPlot::PlotValMomH(WrdBE, "wordsAETot-"+OutFNm, "Number of words edited: "+OutFNm, "1+Log_10 Total number of words edited of candidate AFTER the election",
401      "Fraction of positive votes", gpsAuto, gpwLinesPoints, true, false, false, false, false, true);
402    TGnuPlot::PlotValMomH(WrdAll, "wordsTot-"+OutFNm, "Number of words edited: "+OutFNm, "1+Log_10 Total number of words candidate edited",
403      "Fraction of positive votes", gpsAuto, gpwLinesPoints, true, false, false, false, false, true);
404    TGnuPlot::PlotValMomH(TlkAE, "talksBETot-"+OutFNm, "Number of talks edited: "+OutFNm, "Total number of talks of candidate BEFORE the election",
405      "Fraction of positive votes", gpsAuto, gpwLinesPoints, true, false, false, false, false, true);
406    TGnuPlot::PlotValMomH(TlkBE, "talksAETot-"+OutFNm, "Number of talks edited: "+OutFNm, "Total number of talks of candidate AFTER the election",
407      "Fraction of positive votes", gpsAuto, gpwLinesPoints, true, false, false, false, false, true);
408  }
409  void TWikiTalkNet::PlotNodeAttrDistr(const TStr& OutFNm) const {
410    TIntH BarnStars, AllEdCnt, AllEdWrds, MnEdCnt, MnEdWrds, TkEdCnt, TkEdWrds;
411    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
412      const TWikiUsr& N = NI();
413      BarnStars.AddDat(N.GetStars()) += 1;
414      AllEdCnt.AddDat(N.GetAllEdCnt()) += 1;
415      AllEdWrds.AddDat(1*(N.GetAllWrdCnt()/1)) += 1;
416      MnEdCnt.AddDat(N.GetEdCnt()) += 1;
417      MnEdWrds.AddDat(1*(N.GetWrdCnt()/1)) += 1;
418      TkEdCnt.AddDat(N.GetTkEdCnt()) += 1;
419      TkEdWrds.AddDat(1*(N.GetTkWrdCnt()/1)) += 1;
420    }
421    TGnuPlot::PlotValCntH(BarnStars, "barnStars-"+OutFNm, OutFNm, "Number of barn stars", "Number of users", gpsLog, false, gpwLinesPoints, false, false);
422    TGnuPlot::PlotValCntH(AllEdCnt, "allEdCnt-"+OutFNm, OutFNm, "Number of edits", "Number of users", gpsLog, false, gpwLinesPoints, false, false);
423    TGnuPlot::PlotValCntH(AllEdWrds, "allEdWrds-"+OutFNm, OutFNm, "Number of edited words", "Number of users", gpsLog, false, gpwLinesPoints, false, false);
424    TGnuPlot::PlotValCntH(MnEdCnt, "MnEdCnt-"+OutFNm, OutFNm, "Number of edits on MAIN pages", "Number of users", gpsLog, false, gpwLinesPoints, false, false);
425    TGnuPlot::PlotValCntH(MnEdWrds, "MnEdWrds-"+OutFNm, OutFNm, "Number of edited words onmain pages", "Number of users", gpsLog, false, gpwLinesPoints, false, false);
426    TGnuPlot::PlotValCntH(TkEdCnt, "tkEdCnt-"+OutFNm, OutFNm, "Number of edits on TALK pages", "Number of users", gpsLog, false, gpwLinesPoints, false, false);
427    TGnuPlot::PlotValCntH(TkEdWrds, "tkEdWrds-"+OutFNm, OutFNm, "Number of edited words onmain pages", "Number of users", gpsLog, false, gpwLinesPoints, false, false);
428  }
429  void TWikiTalkNet::PlotFracPosVsEdgeAttr(const TStr& OutFNm) const {
430    THash<TInt, TMom> EdgeTalksH, EdgeTalksH2, EdgeWordsH;
431    THash<TInt, TMom> dBarnStars, dAllEdCnt, dAllEdWrds;
432    TIntH dBarnStarsCnt, dAllEdCntCnt, dAllEdWrdsCnt;
433    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
434      const int Val = EI().GetVote() ==1 ? 1 : 0;
435      if (EI().GetTalks() < 100) {
436        EdgeTalksH.AddDat(int(EI().GetTalks())).Add(Val);
437      }
438      EdgeTalksH2.AddDat((int)log10((double)EI().GetTalks())).Add(Val);
439      EdgeWordsH.AddDat((int)log10((double)EI().GetWords())).Add(Val);
440      const TWikiUsr& S = EI.GetSrcNDat();
441      const TWikiUsr& D = EI.GetDstNDat();
442      if (abs(S.GetStars()-D.GetStars()) < 10) {
443        dBarnStars.AddDat(S.GetStars()-D.GetStars()).Add(Val);
444        dBarnStarsCnt.AddDat(S.GetStars()-D.GetStars())++;
445      }
446      dAllEdCnt.AddDat(log10Delta(S.GetAllEdCnt()-D.GetAllEdCnt())).Add(Val);
447      dAllEdCntCnt.AddDat(log10Delta(S.GetAllEdCnt()-D.GetAllEdCnt()))++;
448      dAllEdWrds.AddDat(log10Delta(S.GetAllWrdCnt()-D.GetAllWrdCnt())).Add(Val);
449      dAllEdWrdsCnt.AddDat(log10Delta(S.GetAllWrdCnt()-D.GetAllWrdCnt()))++;
450    }
451    const bool SDev = true;
452    TGnuPlot::PlotValMomH(EdgeTalksH, "edgeTks"+OutFNm, OutFNm, "Number of talks over the edge", "Fraction of positive edges", gpsAuto, gpwLinesPoints, true, false, false, false, false, SDev);
453    TGnuPlot::PlotValMomH(EdgeTalksH2, "edgeTks2"+OutFNm, OutFNm, "1+Log_{10} Number of talks over the edge", "Fraction of positive edges", gpsAuto, gpwLinesPoints, true, false, false, false, false, SDev);
454    TGnuPlot::PlotValMomH(EdgeWordsH, "edgeWrds"+OutFNm, OutFNm, "1+Log_{10} Number of words over all talks over the edge", "Fraction of positive edges", gpsAuto, gpwLinesPoints, true, false, false, false, false, SDev);
455    TGnuPlot::PlotValMomH(dBarnStars, "dBarnStars-"+OutFNm, OutFNm, "delta BarnStars", "Fraction of positive edges", gpsAuto, gpwLinesPoints, true, false, false, false, false, SDev);
456    TGnuPlot::PlotValMomH(dAllEdCnt, "dAllEdCnt-"+OutFNm, OutFNm, "delta AllEdCnt", "Fraction of positive edges", gpsAuto, gpwLinesPoints, true, false, false, false, false, SDev);
457    TGnuPlot::PlotValMomH(dAllEdWrds, "dAllEdWrds-"+OutFNm, OutFNm, "delta AllEdWrds", "Fraction of positive edges", gpsAuto, gpwLinesPoints, true, false, false, false, false, SDev);
458    TGnuPlot::PlotValCntH(dBarnStarsCnt, "dBarnStarsCnt-"+OutFNm, OutFNm, "delta BarnStars", "Count", gpsAuto);
459    TGnuPlot::PlotValCntH(dAllEdCntCnt, "dAllEdCntCnt-"+OutFNm, OutFNm, "delta AllEdCnt", "Count", gpsAuto);
460    TGnuPlot::PlotValCntH(dAllEdWrdsCnt, "dAllEdWrdsCnt-"+OutFNm, OutFNm, "delta AllEdWrds", "Count", gpsAuto);
461  }
462  void TWikiTalkNet::PlotVoteSignCmnFriends(const TStr& OutFNm) const {
463    TFltFltH SupRngH, OppRngH; 
464    TFltFltH SupCmnH, OppCmnH; 
465    THash<TFlt, TMom> RngFracH, CmnFracH; 
466    PWikiTalkNet ThisPt = PWikiTalkNet((TWikiTalkNet*) this);
467    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
468      const int C = -1; Fail;
469      const int R = -1; 
470      if (EI().GetVote() == 1) {
471        SupRngH.AddDat(R)++;  RngFracH.AddDat(R).Add(1);
472        SupCmnH.AddDat(C)++;  CmnFracH.AddDat(C).Add(1);
473      } else if (EI().GetVote() == -1) {
474        OppRngH.AddDat(R)++;  RngFracH.AddDat(R).Add(0);
475        OppCmnH.AddDat(C)++;  CmnFracH.AddDat(C).Add(0);
476      }
477    }
478    TGnuPlot::PlotValCntH(SupRngH, "rngSup-"+OutFNm, "range of support votes", "range (path length after edge is removed)", "count");
479    TGnuPlot::PlotValCntH(OppRngH, "rngOpp-"+OutFNm, "range of opposing votes", "range (path length after edge is removed)", "count");
480    TGnuPlot::PlotValCntH(SupCmnH, "cmnSup-"+OutFNm, "number of common friends of support votes", "number of common friends", "count", gpsLog);
481    TGnuPlot::PlotValCntH(OppCmnH, "cmnOpp-"+OutFNm, "number of common friends of opposing votes", "number of common friends", "count", gpsLog);
482    TGnuPlot::PlotValMomH(RngFracH, "fracRng-"+OutFNm, "fraction of support edges spanning range X", "range", "fraction of support edges");
483    TGnuPlot::PlotValMomH(CmnFracH, "fracCmn-"+OutFNm, "fraction of support edges having X common neighbors", "number of common neighbors", "fraction of support edges", gpsLog);
484  }
485  void TWikiTalkNet::SaveAreaUTrailAttr(const TStr& OutFNm, const int& MinUsrVotes, const TWikiElecBs& ElecBs) const {
486    TIntV UIdV;
487    TFltV AreaV;
488    TIntSet AdminSet, ElecUsrV;
489    { TIntSet FqVoterSet; ElecBs.GetFqVoters(FqVoterSet, MinUsrVotes, 10, false); FqVoterSet.GetKeyV(UIdV);
490    TIntV ElecUIdV; ElecBs.GetElecUsrV(ElecUIdV); ElecUsrV=TIntSet(ElecUIdV); }
491    ElecBs.GetUsrAreaUTrail(UIdV, AreaV);
492    ElecBs.GetAdminSet(AdminSet);
493    FILE *F = fopen(OutFNm.CStr(), "wt");
494    fprintf(F, "Area\tUser\tIsAdmin\tIsElec\tTalkOutDeg\tInDeg\tTalkTriads\tBarnStars\tInAdmins\tOutAdmins\tAllEdCnt\tAllWrdCnt\tRevCnt\tRevWrds\n");
495    printf("%d users", UIdV.Len());
496    int skip=0;
497    for (int u = 0; u < UIdV.Len(); u++) {
498      TStr Usr = ElecBs.GetUsr(UIdV[u]);
499      if (! IsUsr(Usr)) {  printf("x"); skip++; continue; } else { printf("."); }
500      fprintf(F, "%f\t%s\t%d\t%d", AreaV[u], Usr.CStr(), AdminSet.IsKey(UIdV[u])?1:0, ElecUsrV.IsKey(UIdV[u])?1:0);
501      TNodeI U =  GetNI(GetUsrNId(Usr));
502      fprintf(F, "\t%d\t%d\t%d", U.GetOutDeg(), U.GetInDeg(), TSnap::GetNodeTriads<PWikiTalkNet>((TWikiTalkNet*)this, U.GetId()));
503      int OutAdmins=0, InAdmins=0;
504      for (int i = 0; i < U.GetOutDeg(); i++) {
505        if (U.GetOutNDat(i).IsAdmin()) { OutAdmins++; } }
506      for (int i = 0; i < U.GetInDeg(); i++) {
507        if (U.GetInNDat(i).IsAdmin()) { InAdmins++; } }
508      fprintf(F, "\t%d\t%d\t%d\t%d\t%d\t%d\t%d\n", U().GetStars(), OutAdmins, InAdmins,
509        U().GetAllEdCnt(), U().GetAllWrdCnt(), U().GetRevCnt(), U().GetRevWrds());
510      fflush(F);
511    }
512    fclose(F);
513    printf("\n%d users, %d skip\n", UIdV.Len(), skip);
514  }
515  void TWikiTalkNet::DumpEdgeStat() const {
516    TIntH VoteE, TalkE, AllE, VtTkE;
517    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
518      const TWikiTalkEdge& E = EI();
519      const int V = E.GetVote();
520      AllE.AddDat(V) += 1;
521      if (E.IsTalkE()) { TalkE.AddDat(V)+=1; }
522      if (E.IsVoteE()) { VoteE.AddDat(V)+=1; }
523      if (E.IsVoteTalkE()) { VtTkE.AddDat(V)+=1; }
524    }
525    VoteE.SortByKey(); TalkE.SortByKey(); AllE.SortByKey(); VtTkE.SortByKey();
526    printf("Edge\tAll\tTalk\tVote\tVoteTalk\n");
527    for (int e = 0; e < AllE.Len(); e++) {
528      const int v = AllE.GetKey(e);
529      printf("%4d\t%7d\t%7d\t%7d\t%7d\n", v, AllE[e], TalkE.IsKey(v)?TalkE.GetDat(v):0,
530        VoteE.IsKey(v)?VoteE.GetDat(v):0, VtTkE.IsKey(v)?VtTkE.GetDat(v):0);
531    }
532    printf("\n");
533  }
534  void TWikiTalkNet::ClearElecData() {
535    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
536      EI().VoteSign = -1;
537      EI().VoteTm = TSecTm();
538    }
539    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
540      NI().Admin = false;
541      NI().ElecTm = TSecTm();
542    }
543  }
544  void TWikiTalkNet::ImposeElecNet(const TWikiElecBs& ElecBs, const THash<TChA, TChA>& UsrChageH, const bool& AddVoteOnlyEdges) {
545    int GoodEl=0, ESet=0, ESkip=0, GoodVotes=0, AllCmts=0, VoteEdge=0;
546    int DstNf=0, SrcNf=0;
547    for (int e = 0; e < ElecBs.Len(); e++) {
548      const TWikiElec& E = ElecBs[e];
549      TChA DstUsr = ElecBs.GetUsr(E.GetUId());  DstUsr.ToLc();
550      if (UsrChageH.IsKey(DstUsr)) { DstUsr = UsrChageH.GetDat(DstUsr); }
551      if (! UsrNIdH.IsKey(DstUsr)) { DstNf++; continue; }
552      GoodEl++;
553      TWikiElec Votes;
554      E.GetOnlyVotes(Votes, false);
555      AllCmts += E.Len();
556      GoodVotes += Votes.Len();
557      for (int v = 0; v < Votes.Len(); v++) {
558        TChA SrcUsr = ElecBs.GetUsr(E.GetVote(v).GetUId());  SrcUsr.ToLc();
559        if (UsrChageH.IsKey(SrcUsr)) { SrcUsr = UsrChageH.GetDat(SrcUsr); }
560        if (! UsrNIdH.IsKey(SrcUsr)) { SrcNf++;  continue; }
561        const int SrcId = UsrNIdH.GetDat(SrcUsr);
562        const int DstId = UsrNIdH.GetDat(DstUsr);
563        if (SrcId==DstId) { continue; }
564        if (IsEdge(SrcId, DstId)) {
565          GetEDat(SrcId, DstId).VoteSign = E.GetVote(v).GetVote();
566          GetEDat(SrcId, DstId).VoteTm = E.GetVote(v).GetTm();
567          ESet++;
568        }
569        else if (AddVoteOnlyEdges) {
570          AddEdge(SrcId, DstId);
571          TWikiTalkEdge& EdgeDat = GetEDat(SrcId, DstId);
572          EdgeDat.VoteSign = E[v].GetVote();
573          EdgeDat.VoteTm = E[v].GetTm();
574          VoteEdge++;
575        }
576        else { ESkip++; }
577      }
578    }
579    printf("admins that talk (good elections): %d / %d\n", GoodEl, ElecBs.Len());
580    printf("actual votes vs. comments in elections: %d / %d : %f\n", GoodVotes, AllCmts, GoodVotes/double(AllCmts));
581    printf("votes where both users talk %d (%f of votes where nodes exist)\n", ESet, ESet/double(ESet+ESkip));
582    printf("fraction of all votes found in the graph: %d/%d : %f\n", ESet, GoodVotes, ESet/double(GoodVotes));
583    printf("destination not found: %d\n", DstNf);
584    printf("source not found: %d\n", SrcNf);
585    printf("talk+vote: %d  vote: %d  skip: %d\n", ESet, VoteEdge, ESkip);
586  }
587  PWikiTalkNet TWikiTalkNet::LoadTalkNet(const TStr& ParsedWikiDir, const TWikiElecBs& ElecBs) {
588    const TStr WikiUsrTalk = "enwiki-20080103.user_talk.7z"; 
589    const TStr WikiMain = "enwiki-20080103.main.7z";
590    const TStr WikiMainTalk = "enwiki-20080103.talk.7z";
591    const TStr WikiWiki = "enwiki-20080103.wikipedia.7z";
592    const TStr WikiWikiTalk = "enwiki-20080103.wikipedia_talk.7z";
593    const TStr BarnStartList = "barnstars.history.unsorted";
594    const TStr AdminList = "enwiki.admins2009.txt";
595    const TStr BotList = "enwiki.botlist.2007-03";
596    const TStr UsrChanges = "enwiki.important-username-changes.2007-08-06.txt";
597    THash<TChA, TChA> UsrMapH;
598    THashSet<TChA> BotSet;
599    THash<TChA, TInt> UsrElecId; 
600    TChA Ln;
601    TExeTm ExeTm;
602    for (TFIn FIn(ParsedWikiDir+BotList); FIn.GetNextLn(Ln); ) {
603      BotSet.AddKey(Ln.ToLc()); }
604    printf("Bots: %d bots\n", BotSet.Len());
605    for (TSsParser Ss(ParsedWikiDir+UsrChanges, ssfSpaceSep); Ss.Next(); ) {
606      TChA U1=Ss[0], U2=Ss[1]; if (U1.ToLc()!=U2.ToLc()) { UsrMapH.AddDat(U1,U2); }
607    }
608    printf("User changes: %d chages\n", UsrMapH.Len());
609    for (int e = 0; e < ElecBs.Len(); e++) {
610      UsrElecId.AddDat(ElecBs.GetUsr(ElecBs[e].GetUId()), e); }
611    printf("Elections: %d users up for election\n", UsrElecId.Len());
612    printf("Load WikiTalk network:");
613    PWikiTalkNet Net = TWikiTalkNet::New();
614    printf("  Load %s ", WikiUsrTalk.CStr());
615    { TWikiMetaLoader WML(ParsedWikiDir+WikiUsrTalk);
616    int src, dst, k, elecSet=0;
617    for (int edges=0; WML.Next(); edges++) {
618      if (! WML.Title.IsPrefix("User_talk:")) { printf("."); continue; }
619      const int b = (int) strlen("User_talk:");
620      int e2 = WML.Title.SearchCh('/', b)-1;
621      if (e2<0) { e2=TInt::Mx; }
622      TChA Dst = WML.Title.GetSubStr(b, e2).ToLc();
623      TChA Src = WML.Usr.ToLc();
624      if (BotSet.IsKey(Src) || BotSet.IsKey(Dst)) { printf(""); continue; }
625      if (TWikiMetaLoader::IsIpAddr(Src) || TWikiMetaLoader::IsIpAddr(Dst)) { printf(""); continue; }
626      if (Src != Dst) { 
627        k = UsrMapH.GetKeyId(Src);
628        if (k != -1) { Src = UsrMapH[k]; }
629        k = UsrMapH.GetKeyId(Dst);
630        if (k != -1) { Dst = UsrMapH[k]; }
631        src = Net->UsrNIdH.AddDatId(Src);
632        dst = Net->UsrNIdH.AddDatId(Dst);
633        IAssert(src != dst);
634        if (! Net->IsNode(src)) {
635          Net->AddNode(src, TWikiUsr(Src));
636          if (UsrElecId.IsKey(Src)) { printf("T"); elecSet++; 
637            Net->GetNDat(src).ElecTm = ElecBs.GetElec(UsrElecId.GetDat(Src)).GetTm();  }
638        }
639        if (! Net->IsNode(dst)) {
640          Net->AddNode(dst, TWikiUsr(Dst));
641          if (UsrElecId.IsKey(Dst)) { printf("T"); elecSet++; 
642            Net->GetNDat(dst).ElecTm = ElecBs.GetElec(UsrElecId.GetDat(Dst)).GetTm(); }
643        }
644        if (! Net->IsEdge(src, dst)) {
645          Net->AddEdge(src, dst, TWikiTalkEdge(WML.RevTm, WML.RevTm, 1, WML.RevWrds));
646        }
647        TWikiTalkEdge& TalkEdge = Net->GetEDat(src, dst);
648        if (TalkEdge.FirstTalk > WML.RevTm) { TalkEdge.FirstTalk = WML.RevTm; }
649        if (TalkEdge.LastTalk < WML.RevTm) { TalkEdge.LastTalk = WML.RevTm; }
650        TalkEdge.TotWords += WML.RevWrds;
651        TalkEdge.TotTalks += 1;
652        const TSecTm DstElecTm = Net->GetNDat(dst).ElecTm;
653        if (DstElecTm.IsDef()) { 
654          if (WML.RevTm < DstElecTm) { TalkEdge.TalksBE++; TalkEdge.WordsBE+=WML.RevWrds; }
655          else { TalkEdge.TalksAE++; TalkEdge.WordsAE+=WML.RevWrds; }
656        }
657      }
658    }
659    printf("DONE NET[%s]\n", ExeTm.GetStr());  ExeTm.Tick();
660    printf("node election time %d / %d (%f)\n", elecSet, UsrElecId.Len(), elecSet/double(UsrElecId.Len())); }
661    TSnap::PrintInfo(Net, "WikiUserTalk network.");
662    printf(" [%s]\n  Loading %s\n", ExeTm.GetStr(), BarnStartList.CStr());  ExeTm.Tick();
663    int cnt=0, cnt2=0;
664    for (TSsParser Ss(ParsedWikiDir+BarnStartList, ssfSpaceSep); Ss.Next(); cnt2++) { TChA U1=Ss[3]; U1.ToLc();
665      if (UsrMapH.IsKey(U1)) { U1 = UsrMapH.GetDat(U1); }
666      if (Net->UsrNIdH.IsKey(U1)) { cnt++;
667        Net->GetNDat(Net->UsrNIdH.GetDat(U1)).BarnStars += 1; }
668    }
669    printf("    %d / %d stars set [%s]\n  Loading %s\n", cnt, cnt2, ExeTm.GetStr(), AdminList.CStr());  ExeTm.Tick();
670    cnt=0; cnt2=0;
671    for (TFIn FIn(ParsedWikiDir+AdminList); FIn.GetNextLn(Ln); cnt2++) { Ln.ToLc();
672      if (UsrMapH.IsKey(Ln)) { Ln = UsrMapH.GetDat(Ln); }
673      if (Net->UsrNIdH.IsKey(Ln)) { cnt++;
674        Net->GetNDat(Net->UsrNIdH.GetDat(Ln)).Admin = true; }
675    }/&bsol;*/
676    printf("    %d / %d admins set [%s]\n", cnt, cnt2, ExeTm.GetStr());
677    TIntSet AdminSet; ElecBs.GetAdminSet(AdminSet);
678    for (int a = 0; a < AdminSet.Len(); a++, cnt2++) {
679      TChA Ln = ElecBs.GetUsr(AdminSet[a]);
680      if (Net->UsrNIdH.IsKey(Ln)) { cnt++;
681        Net->GetNDat(Net->UsrNIdH.GetDat(Ln)).Admin = true; }
682    }
683    printf("    %d / %d admins set [%s]\n", cnt, cnt2, ExeTm.GetStr());
684    Net->ImposeElecNet(ElecBs, UsrMapH, true); 
685    TSnap::PrintInfo(Net);
686    printf("SAVE DONE.\n\nLoading user edit statistics:\n");
687    printf("  Loading %s ", WikiMain.CStr());
688    { TWikiMetaLoader WML(ParsedWikiDir+WikiMain);
689    for (int rec=0; WML.Next(); rec++) {
690      const TChA& U = WML.Usr;
691      const int keyId = Net->UsrNIdH.GetKeyId(U);
692      if (keyId == -1) { continue; }
693      TWikiUsr& WU = Net->GetNDat(Net->UsrNIdH[keyId]);
694      WU.MnEdCnt += 1;  WU.MnEdWrds += WML.RevWrds;
695      WML.CommentStr.ToLc();
696      if (WML.CommentStr.IsPrefix("rv") || WML.CommentStr.SearchStr("revert")!=-1) {
697        WU.MnRevCnt+=1; WU.MnRevWrds+=WML.RevWrds; }
698    } }
699    printf(" [%s]\n  Loading %s", ExeTm.GetStr(), WikiMainTalk.CStr());  ExeTm.Tick();
700    { TWikiMetaLoader WML(ParsedWikiDir+WikiMainTalk);
701    for (int rec=0; WML.Next(); rec++) {
702      const TChA& U = WML.Usr.ToLc();
703      const int keyId = Net->UsrNIdH.GetKeyId(U);
704      if (keyId == -1) { continue; }
705      TWikiUsr& WU = Net->GetNDat(Net->UsrNIdH[keyId]);
706      WU.MnTkEdCnt += 1;  WU.MnTkEdWrds += WML.RevWrds;
707    } }
708    printf(" [%s]\n  Loading %s", ExeTm.GetStr(), WikiWiki.CStr());  ExeTm.Tick();
709    { TWikiMetaLoader WML(ParsedWikiDir+WikiWiki);
710    for (int rec=0; WML.Next(); rec++) {
711      const TChA& U = WML.Usr.ToLc();
712      const int keyId = Net->UsrNIdH.GetKeyId(U);
713      if (keyId == -1) { continue; }
714      TWikiUsr& WU = Net->GetNDat(Net->UsrNIdH[keyId]);
715      WU.WkEdCnt += 1;  WU.WkEdWrds += WML.RevWrds;
716    } }
717    printf(" [%s]\n  Loading %s", ExeTm.GetStr(), WikiWikiTalk.CStr());  ExeTm.Tick();
718    { TWikiMetaLoader WML(ParsedWikiDir+WikiWikiTalk);
719    for (int rec=0; WML.Next(); rec++) {
720      const TChA& U = WML.Usr.ToLc();
721      const int keyId = Net->UsrNIdH.GetKeyId(U);
722      if (keyId == -1) { continue; }
723      TWikiUsr& WU = Net->GetNDat(Net->UsrNIdH[keyId]);
724      WU.WkTkEdCnt += 1;  WU.WkTkEdWrds += WML.RevWrds;
725    } }
726    TSnap::PrintInfo(Net, "WikiUserTalk network.");
727    printf("\n[%s]\nDONE.\n", ExeTm.GetStr());
728    return Net;
729  }
730  PWikiTalkNet TWikiTalkNet::LoadSlashdot(const TStr& InFNm) {
731    THashSet<TChA> NIdSet;
732    TChA LnStr;
733    TVec<char *> WrdV;
734    int Sign;
735    PWikiTalkNet Net = TWikiTalkNet::New();
736    for (TFIn FIn(InFNm); FIn.GetNextLn(LnStr); ) {
737      if (LnStr.Empty() || LnStr[0]=='#') { continue; }
738      LnStr.ToLc();
739      TStrUtil::SplitOnCh(LnStr, WrdV, '\t', false);
740      NIdSet.AddKey(WrdV[0]);
741      if (strcmp(WrdV[1], "friends")==0) { Sign = 1; }
742      else if (strcmp(WrdV[1], "fans")==0) { continue; } 
743      else if (strcmp(WrdV[1], "foes")==0) { Sign = -1; }
744      else { Fail; }
745      const int SrcNId = NIdSet.AddKey(WrdV[0]);
746      if (! Net->IsNode(SrcNId)) {
747        Net->AddNode(SrcNId, TWikiUsr(WrdV[0]));
748        Net->UsrNIdH.AddDat(WrdV[0], SrcNId);
749      }
750      for (int e = 2; e < WrdV.Len(); e++) {
751        const int DstNId = NIdSet.AddKey(WrdV[e]);
752        if (! Net->IsNode(DstNId)) {
753          Net->AddNode(DstNId, TWikiUsr(WrdV[e]));
754          Net->UsrNIdH.AddDat(WrdV[e], DstNId);
755        }
756        if (SrcNId != DstNId && ! Net->IsEdge(SrcNId, DstNId)) {
757          Net->AddEdge(SrcNId, DstNId, TWikiTalkEdge(Sign));
758        }
759      }
760    }
761    TSnap::PrintInfo(Net, InFNm);
762    return Net;
763  }
764  PWikiTalkNet TWikiTalkNet::LoadOldNet(const TStr& InFNm) {
765    typedef TNodeEDatNet<TStr, TInt> TOldNet;
766    PWikiTalkNet Net = TWikiTalkNet::New();
767    TPt<TOldNet> ON = TOldNet::Load(TZipIn(InFNm));
768    TSnap::PrintInfo(ON);
769    for(TOldNet::TEdgeI EI = ON->BegEI(); EI<ON->EndEI(); EI++) {
770      if (! Net->IsNode(EI.GetSrcNId())) {
771        Net->AddNode(EI.GetSrcNId(), TWikiUsr(EI.GetSrcNDat().GetLc()));
772        Net->UsrNIdH.AddDat(EI.GetDstNDat().GetLc(), EI.GetSrcNId());
773      }
774      if (! Net->IsNode(EI.GetDstNId())) {
775        Net->AddNode(EI.GetDstNId(), TWikiUsr(EI.GetDstNDat().GetLc()));
776        Net->UsrNIdH.AddDat(EI.GetDstNDat().GetLc(), EI.GetDstNId());
777      }
778      Net->AddEdge(EI.GetSrcNId(), EI.GetDstNId(), TWikiTalkEdge(EI()));
779    }
780    TSnap::PrintInfo(Net);
781    return Net;
782  }
783  PNGraph TWikiTimeTalkNet::GetBeforeTimeG(const TSecTm& EdgeTm) const {
784    PNGraph G = TNGraph::New();
785    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
786      if (EI().Tm <= EdgeTm) {
787        if (! G->IsNode(EI.GetSrcNId())) { G->AddNode(EI.GetSrcNId()); }
788        if (! G->IsNode(EI.GetDstNId())) { G->AddNode(EI.GetDstNId()); }
789        G->AddEdge(EI.GetSrcNId(), EI.GetDstNId());
790      }
791    }
792    return G;
793  }
794  PSignNet TWikiTimeTalkNet::GetBeforeTimeNet(const TSecTm& EdgeTm) const {
795    PSignNet Net = TSignNet::New();
796    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
797      if (EI().Tm <= EdgeTm) {
798        if (! Net->IsNode(EI.GetSrcNId())) { Net->AddNode(EI.GetSrcNId()); }
799        if (! Net->IsNode(EI.GetDstNId())) { Net->AddNode(EI.GetDstNId()); }
800        Net->AddEdge(EI.GetSrcNId(), EI.GetDstNId());
801        Net->GetEDat(EI.GetSrcNId(), EI.GetDstNId()) += EI().Words;
802      }
803    }
804    return Net;
805  }
806  void TWikiTimeTalkNet::SaveDataset(const TWikiElecBs& ElecBs, const TStr& OutFNm) const {
807    FILE *F = fopen(OutFNm.CStr(), "wt");
808    fprintf(F, "SuccElec\tRfa\tNetNodes\tNetEdges\tNetConstraint\tBarnStars\tTalkOutDeg\tTalkInDeg\tTalkTriads\tInWords\tOutWords\tInAdmins\tOutAdmins\tAdminTriads\tInAdminWords\tOutAdminWords\n");
809    TStrSet AdminSet;
810    for (TSsParser Ss("W:\\Data\\wiki20080103-parseByGuerogy\\enwiki.admins2009.txt", ssfTabSep); Ss.Next(); ) {
811      TStr A=Ss[0]; AdminSet.AddKey(A.GetTrunc().GetLc());
812    }
813    TExeTm ExeTm;
814    TBarnStars  BarnStars;
815    TIntSet AdminNIdSet;
816    printf("Admin list: %d\n", AdminSet.Len());
817    for (int e = 0; e < ElecBs.Len(); e++) {
818      const TWikiElec& E = ElecBs.GetElec(e);
819      const TStr Usr = ElecBs.GetUsr(E.UsrId);
820      printf("%s: %s   ", Usr.CStr(), E.RfaTitle.CStr());
821      if (! UsrNIdH.IsKey(Usr)) {
822        printf(" DOES NOT TALK\n", Usr.CStr()); continue;
823      }
824      PSignNet Net = GetBeforeTimeNet(E.ElecTm);
825      const int NId = UsrNIdH.GetDat(Usr);
826      if (! Net->IsNode(NId)) {
827        printf(" TALKS AFTER ELECTION\n"); continue;
828      }
829      const TSignNet::TNodeI NI = Net->GetNI(NId);
830      printf(" deg %d:%d ", NI.GetInDeg(), NI.GetOutDeg());
831      int InWgt=0, OutWgt=0, InAdmins=0, OutAdmins=0, InAWgt=0, OutAWgt=0;
832      AdminNIdSet.Clr(false);
833      AdminNIdSet.AddKey(NI.GetId());
834      for (int i = 0; i < NI.GetOutDeg(); i++) {
835        OutWgt += NI.GetOutEDat(i);
836        if (AdminSet.IsKey(UsrNIdH.GetKey(NI.GetOutNId(i)))) {
837          OutAWgt += NI.GetOutEDat(i);
838          OutAdmins++;
839          AdminNIdSet.AddKey(NI.GetOutNId(e));
840        }
841      }
842      for (int i = 0; i < NI.GetInDeg(); i++) {
843        InWgt += NI.GetInEDat(i);
844        if (AdminSet.IsKey(UsrNIdH.GetKey(NI.GetInNId(i)))) {
845          InAWgt += NI.GetInEDat(i);
846          InAdmins++;
847          AdminNIdSet.AddKey(NI.GetInNId(e));
848        }
849      }
850      TSnap::TNetConstraint<PSignNet> NetC(Net, false);
851      NetC.CalcConstraints(NId);
852      TIntV AdminV; AdminNIdSet.GetKeyV(AdminV);
853      const double C = NetC.GetNodeC(NId);
854      const int BS = BarnStars.GetBarnStars(Usr, E.GetTm());
855      const int Triads = TSnap::GetNodeTriads(Net, NI.GetId());
856      const int AdmintTriads = TSnap::GetNodeTriads(TSnap::GetSubGraph(Net, AdminV), NI.GetId());
857      fprintf(F, "%d\t%s\t%d\t%d\t%f\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\n", E.IsSucc?1:0, E.RfaTitle.CStr(), Net->GetNodes(), Net->GetEdges(), C, BS,
858        NI.GetOutDeg(), NI.GetInDeg(), Triads, InWgt, OutWgt, InAdmins, OutAdmins, AdmintTriads, InAWgt, OutAWgt);
859      fflush(F);
860      printf(" [%s]\n", ExeTm.GetStr());
861    }
862    fclose(F);
863  }
864  PWikiTimeTalkNet TWikiTimeTalkNet::LoadWikiTimeTalkNet() {
865    const TStr WikiUsrTalk = "W:\\data\\wiki20080103-parseByGuerogy\\enwiki-20080103.user_talk.7z"; 
866    const TStr UsrChanges = "W:\\data\\wiki20080103-parseByGuerogy\\enwiki.important-username-changes.2007-08-06";
867    const TStr BotList = "W:\\data\\wiki20080103-parseByGuerogy\\enwiki.botlist.2007-03";
868    THash<TChA, TChA> UsrMapH;
869    THashSet<TChA> BotSet;
870    TChA Ln;
871    TExeTm ExeTm;
872    for (TFIn FIn(BotList); FIn.GetNextLn(Ln); ) {
873      BotSet.AddKey(Ln.ToLc()); }
874    printf("Bots: %d bots\n", BotSet.Len());
875    for (TSsParser Ss(UsrChanges, ssfSpaceSep); Ss.Next(); ) {
876      TChA U1=Ss[3], U2=Ss[4]; if (U1.ToLc()!=U2.ToLc()) { UsrMapH.AddDat(U1,U2); } }
877    printf("User changes: %d chages\n", UsrMapH.Len());
878    printf("Load Take network before the election:");
879    PWikiTimeTalkNet Net = TWikiTimeTalkNet::New();
880    printf("  Load %s ", WikiUsrTalk.CStr());
881    TWikiMetaLoader WML(WikiUsrTalk);
882    int src, dst, k;
883    for (int edges=0; WML.Next(); edges++) {
884      if (! WML.Title.IsPrefix("User_talk:")) { printf("."); continue; }
885      const int b = (int) strlen("User_talk:");
886      int e2 = WML.Title.SearchCh('/', b)-1;
887      if (e2<0) { e2=TInt::Mx; }
888      TChA Dst = WML.Title.GetSubStr(b, e2).ToLc();
889      TChA Src = WML.Usr.ToLc();
890      if (BotSet.IsKey(Src) || BotSet.IsKey(Dst)) { printf(""); continue; }
891      if (TWikiMetaLoader::IsIpAddr(Src) || TWikiMetaLoader::IsIpAddr(Dst)) { printf(""); continue; }
892      if (Src != Dst) { 
893        k = UsrMapH.GetKeyId(Src);
894        if (k != -1) { Src = UsrMapH[k]; }
895        k = UsrMapH.GetKeyId(Dst);
896        if (k != -1) { Dst = UsrMapH[k]; }
897        src = Net->UsrNIdH.AddDatId(Src);
898        dst = Net->UsrNIdH.AddDatId(Dst);
899        if (src != dst) {
900          if (! Net->IsNode(src)) { Net->AddNode(src, Src); }
901          if (! Net->IsNode(dst)) { Net->AddNode(dst, Dst); }
902          Net->AddEdge(src, dst, -1, TWikiTalkEdge2(WML.RevTm, WML.RevWrds));
903        }
904      }
905    }
906    printf("DONE NET[%s]\n", ExeTm.GetStr());  ExeTm.Tick();
907    return Net;
908  }
909  void TWikiEditCnt::LoadTxtBeforeElec(const TWikiElecBs& ElecBs) {
910    const TStr WikiMain = "W:\\Data\\wiki20080103-parseByGuerogy\\enwiki-20080103.main.7z";
911    const TStr WikiMainTalk = "W:\\Data\\wiki20080103-parseByGuerogy\\enwiki-20080103.talk.7z";
912    const TStr WikiWiki = "W:\\Data\\wiki20080103-parseByGuerogy\\enwiki-20080103.wikipedia.7z";
913    const TStr WikiWikiTalk = "W:\\Data\\wiki20080103-parseByGuerogy\\enwiki-20080103.wikipedia_talk.7z";
914    const TStr UsrChanges = "W:\\data\\wiki20080103-parseByGuerogy\\enwiki.important-username-changes.2007-08-06";
915    THash<TChA, TChA> UsrMapH;
916    for (TSsParser Ss(UsrChanges, ssfSpaceSep); Ss.Next(); ) {
917      TChA U1=Ss[3], U2=Ss[4]; if (U1.ToLc()!=U2.ToLc()) { UsrMapH.AddDat(U1,U2); } }
918    THash<TChA, TVec<TPair<TChA, TSecTm> > > UsrToRfaTmH;
919    for (int e = 0; e < ElecBs.Len(); e++) {
920      UsrToRfaTmH.AddDat(ElecBs.GetUsr(ElecBs[e].GetUId())).Add(TPair<TChA, TSecTm>(ElecBs[e].RfaTitle, ElecBs[e].GetTm()));
921    }
922    TExeTm ExeTm;
923    printf("  Loading %s ", WikiMain.GetFMid().CStr());
924    { TWikiMetaLoader WML(WikiMain);
925    for (int rec=0; WML.Next(); rec++) {
926      TChA U = WML.Usr;
927      if (UsrMapH.IsKey(U)) { U = UsrMapH.GetDat(U); }
928      if (! UsrToRfaTmH.IsKey(U)) { continue; }
929      const TVec<TPair<TChA, TSecTm> >& V = UsrToRfaTmH.GetDat(U);
930      for (int t = 0; t < V.Len(); t++) {
931        if (WML.RevTm <= V[t].Val2 ) { 
932          TEditCnt& EC = RfaEdCntH.AddDat(V[t].Val1);
933          EC.MainE+=1; EC.MainW+=WML.RevWrds;
934          WML.CommentStr.ToLc();
935          if (WML.CommentStr.IsPrefix("rv") || WML.CommentStr.SearchStr("revert")!=-1) {
936            EC.RevE+=1; EC.RevW+=WML.RevWrds;
937          }
938        }
939      }
940    } }
941    Save(TZipOut("wikiEditCounts.BeforeElec.rar"));
942    printf(" [%s]\n  Loading %s", ExeTm.GetStr(), WikiMainTalk.GetFMid().CStr());  ExeTm.Tick();
943    { TWikiMetaLoader WML(WikiMainTalk);
944    for (int rec=0; WML.Next(); rec++) {
945      TChA U = WML.Usr;
946      if (UsrMapH.IsKey(U)) { U = UsrMapH.GetDat(U); }
947      if (! UsrToRfaTmH.IsKey(U)) { continue; }
948      const TVec<TPair<TChA, TSecTm> >& V = UsrToRfaTmH.GetDat(U);
949      for (int t = 0; t < V.Len(); t++) {
950        if (WML.RevTm <= V[t].Val2 ) {
951          TEditCnt& EC = RfaEdCntH.AddDat(V[t].Val1);
952          EC.MainTE+=1; EC.MainTW+=WML.RevWrds;
953        }
954      }
955    } }
956    Save(TZipOut("wikiEditCounts.BeforeElec.rar"));
957    printf(" [%s]\n  Loading %s", ExeTm.GetStr(), WikiWiki.GetFMid().CStr());  ExeTm.Tick();
958    { TWikiMetaLoader WML(WikiWiki);
959    for (int rec=0; WML.Next(); rec++) {
960      TChA U = WML.Usr;
961      if (UsrMapH.IsKey(U)) { U = UsrMapH.GetDat(U); }
962      if (! UsrToRfaTmH.IsKey(U)) { continue; }
963      const TVec<TPair<TChA, TSecTm> >& V = UsrToRfaTmH.GetDat(U);
964      for (int t = 0; t < V.Len(); t++) {
965        if (WML.RevTm <= V[t].Val2 ) {
966          TEditCnt& EC = RfaEdCntH.AddDat(V[t].Val1);
967          EC.WikiE+=1; EC.WikiW+=WML.RevWrds;
968        }
969      }
970    } }
971    Save(TZipOut("wikiEditCounts.BeforeElec.rar"));
972    printf(" [%s]\n  Loading %s", ExeTm.GetStr(), WikiWikiTalk.GetFMid().CStr());  ExeTm.Tick();
973    { TWikiMetaLoader WML(WikiWikiTalk);
974    for (int rec=0; WML.Next(); rec++) {
975      TChA U = WML.Usr;
976      if (UsrMapH.IsKey(U)) { U = UsrMapH.GetDat(U); }
977      if (! UsrToRfaTmH.IsKey(U)) { continue; }
978      const TVec<TPair<TChA, TSecTm> >& V = UsrToRfaTmH.GetDat(U);
979      for (int t = 0; t < V.Len(); t++) {
980        if (WML.RevTm <= V[t].Val2 ) {
981          TEditCnt& EC = RfaEdCntH.AddDat(V[t].Val1);
982          EC.WikiTE+=1; EC.WikiTW+=WML.RevWrds;
983        }
984      }
985    } }
986    Save(TZipOut("wikiEditCounts.BeforeElec.rar"));
987    printf(" [%s]\n", ExeTm.GetStr());
988  }
989  void TWikiEditCnt::LoadTxtAll(const TWikiElecBs& ElecBs) {
990    const TStr WikiMain = "W:\\Data\\wiki20080103-parseByGuerogy\\enwiki-20080103.main.7z";
991    const TStr WikiMainTalk = "W:\\Data\\wiki20080103-parseByGuerogy\\enwiki-20080103.talk.7z";
992    const TStr WikiWiki = "W:\\Data\\wiki20080103-parseByGuerogy\\enwiki-20080103.wikipedia.7z";
993    const TStr WikiWikiTalk = "W:\\Data\\wiki20080103-parseByGuerogy\\enwiki-20080103.wikipedia_talk.7z";
994    const TStr UsrChanges = "W:\\data\\wiki20080103-parseByGuerogy\\enwiki.important-username-changes.2007-08-06";
995    TExeTm ExeTm;
996    printf("  Loading %s ", WikiMain.GetFMid().CStr());
997    { TWikiMetaLoader WML(WikiMain);
998    for (int rec=0; WML.Next(); rec++) {
999      if (! ElecBs.IsUsr(WML.Usr)) { continue; }
1000      TEditCnt& EC = RfaEdCntH.AddDat(WML.Usr);
1001      EC.MainE+=1; EC.MainW+=WML.RevWrds;
1002      WML.CommentStr.ToLc();
1003      if (WML.CommentStr.IsPrefix("rv") || WML.CommentStr.SearchStr("revert")!=-1) {
1004        EC.RevE+=1; EC.RevW+=WML.RevWrds;
1005      }
1006    } }
1007    Save(TZipOut("wikiEditCounts.All.rar"));
1008    printf(" [%s]\n  Loading %s", ExeTm.GetStr(), WikiMainTalk.GetFMid().CStr());  ExeTm.Tick();
1009    { TWikiMetaLoader WML(WikiMainTalk);
1010    for (int rec=0; WML.Next(); rec++) {
1011      if (! ElecBs.IsUsr(WML.Usr)) { continue; }
1012      TEditCnt& EC = RfaEdCntH.AddDat(WML.Usr);
1013      EC.MainTE+=1; EC.MainTW+=WML.RevWrds;
1014    } }
1015    Save(TZipOut("wikiEditCounts.All.rar"));
1016    printf(" [%s]\n  Loading %s", ExeTm.GetStr(), WikiWiki.GetFMid().CStr());  ExeTm.Tick();
1017    { TWikiMetaLoader WML(WikiWiki);
1018    for (int rec=0; WML.Next(); rec++) {
1019      TChA U = WML.Usr;
1020      if (! ElecBs.IsUsr(WML.Usr)) { continue; }
1021      TEditCnt& EC = RfaEdCntH.AddDat(WML.Usr);
1022      EC.WikiE+=1; EC.WikiW+=WML.RevWrds;
1023    } }
1024    Save(TZipOut("wikiEditCounts.All.rar"));
1025    printf(" [%s]\n  Loading %s", ExeTm.GetStr(), WikiWikiTalk.GetFMid().CStr());  ExeTm.Tick();
1026    { TWikiMetaLoader WML(WikiWikiTalk);
1027    for (int rec=0; WML.Next(); rec++) {
1028      if (! ElecBs.IsUsr(WML.Usr)) { continue; }
1029      TEditCnt& EC = RfaEdCntH.AddDat(WML.Usr);
1030      EC.WikiTE+=1; EC.WikiTW+=WML.RevWrds;
1031    } }
1032    Save(TZipOut("wikiEditCounts.All.rar"));
1033    printf(" [%s]\n", ExeTm.GetStr());
1034  }
1035  void TWikiEditCnt::SaveTxt(const TWikiElecBs& ElecBs, const TStr& OutFNm) {
1036    FILE *F = fopen(OutFNm.CStr(), "wt");
1037    fprintf(F, "Rfat\tMainE\tMainW\tMainTE\tMainTW\tWikiE\tWikiW\tWikiTE\tWikiTW\n");
1038    for (TSsParser Ss("isSuccVote-TalkNet3.tab", ssfTabSep); Ss.Next(); ) {
1039      TStr Rfa = Ss[1];
1040      if (! RfaEdCntH.IsKey(Rfa)) {
1041        printf("%s\n", Rfa.CStr());
1042        fprintf(F, "%s\t0\t0\t0\t0\t0\t0\t0\t0\n", Rfa.CStr());
1043      } else {
1044        const TEditCnt& EC = RfaEdCntH.GetDat(Rfa);
1045        fprintf(F, "%s\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\n", Rfa.CStr(),
1046          EC.MainE(), EC.MainW(), EC.MainTE(), EC.MainTW(), EC.WikiE(), EC.WikiW(), EC.WikiTE(), EC.WikiTW());
1047      }
1048    }
1049    fclose(F);
1050  }
1051  TWikiElec::TWikiElec(TSIn& SIn) : RfaTitle(SIn), UsrId(SIn), NomUId(SIn), BurUId(SIn), IsSucc(SIn), ElecTm(SIn), VoteV(SIn) {
1052  }
1053  void TWikiElec::Save(TSOut& SOut) const {
1054    RfaTitle.Save(SOut); UsrId.Save(SOut); NomUId.Save(SOut);
1055    BurUId.Save(SOut); IsSucc.Save(SOut); ElecTm.Save(SOut);
1056    VoteV.Save(SOut);
1057  }
1058  bool TWikiElec::operator < (const TWikiElec& WE) const {
1059    return ElecTm<WE.ElecTm || (ElecTm==WE.ElecTm && UsrId<WE.UsrId);
1060  }
1061  void TWikiElec::SetIsVoteFlag() {
1062    THash<TInt, TIntPr> UsrVoteH(Len());
1063    for (int i = 0; i < VoteV.Len(); i++) {
1064      if (VoteV[i].GetIndent() != 0) { continue; } 
1065      if (VoteV[i].GetUId() == UsrId) { continue; }  
1066      if (! UsrVoteH.IsKey(VoteV[i].GetUId())) {
1067        UsrVoteH.AddDat(VoteV[i].GetUId(), TIntPr(VoteV[i].GetTm().GetAbsSecs(), i));
1068      } else {
1069        TIntPr& Dat = UsrVoteH.GetDat(VoteV[i].GetUId());
1070        if (Dat.Val1 > (int)VoteV[i].GetTm().GetAbsSecs()) { 
1071          Dat = TIntPr(VoteV[i].GetTm().GetAbsSecs(), i);
1072        }
1073      }
1074    }
1075    for (int v = 0; v < VoteV.Len(); v++) {
1076      VoteV[v].IsAVote = false;
1077    }
1078    for (int v = 0; v < UsrVoteH.Len(); v++) {
1079      VoteV[UsrVoteH[v].Val2].IsAVote = true;
1080    }
1081  }
1082  double TWikiElec::GetFracSup(const bool& OnlyVotes) const {
1083    const TIntTr Votes = GetVotes(OnlyVotes);
1084    return double(Votes.Val1)/double(Votes.Val1+Votes.Val3);
1085  }
1086  double TWikiElec::GetFracSup(int VoteId1, int VoteId2) const {
1087    double Sup=0;
1088    for (int v = VoteId1; v < TMath::Mn(VoteId2, Len()); v++) {
1089      if (VoteV[v].GetVote()==1) { Sup+=1; }
1090    }
1091    if (VoteId1==VoteId2) { return 0.0; }
1092    return Sup/double(VoteId2-VoteId1);
1093  }
1094  double TWikiElec::GetTrend(int VoteId1, int VoteId2) const {
1095    TFltPrV XY;
1096    for (int v = VoteId1; v < VoteId2; v++) {
1097      XY.Add(TFltPr(v, (double)VoteV[v].GetVote()));
1098    }
1099    double A, B, SigA, SigB, Chi2, R2;
1100    TSpecFunc::LinearFit(XY, A, B, SigA, SigB, Chi2, R2);
1101    return B;
1102  }
1103  TIntTr TWikiElec::GetVotes(const bool& OnlyVotes) const {
1104    int Sup=0, Opp=0, Neu=0;
1105    for (int i = 0; i < VoteV.Len(); i++) {
1106      if (OnlyVotes && ! VoteV[i].IsVote()) { continue; }
1107      if (VoteV[i].GetVote()==1) { Sup++; }
1108      else if (VoteV[i].GetVote()==0) { Neu++; }
1109      else if (VoteV[i].GetVote()==-1) { Opp++; }
1110    }
1111    return TIntTr(Sup, Neu, Opp);
1112  }
1113  void TWikiElec::GetVotesOt(TWikiVoteV& WVoteV, const bool& OnlyVotes) const {
1114    if (! OnlyVotes) {
1115      WVoteV = VoteV;
1116      WVoteV.Sort();
1117      return;
1118    }
1119    TIntPrV TmIdV;
1120    for (int i = 0; i < VoteV.Len(); i++) {
1121      if (OnlyVotes && ! VoteV[i].IsVote()) { continue; }
1122      TmIdV.Add(TIntPr(VoteV[i].VoteTm.GetAbsSecs(), i));
1123    }
1124    TmIdV.Sort();
1125    WVoteV.Clr(false);
1126    for (int v = 0; v < TmIdV.Len(); v++) {
1127      WVoteV.Add(VoteV[TmIdV[v].Val2]);
1128    }
1129    WVoteV.Sort();
1130  }
1131  int TWikiElec::GetAvgVoteOt(TFltV& AvgVoteV, const bool& OnlyVotes) const {
1132    TWikiVoteV WVoteV;  GetVotesOt(WVoteV, OnlyVotes);
1133    double VoteSum = 0;
1134    AvgVoteV.Clr(false);
1135    for (int i = 0; i < WVoteV.Len(); i++) {
1136      VoteSum += WVoteV[i].GetVote() > 0 ? 1 : 0;
1137      AvgVoteV.Add(VoteSum/double(i+1));
1138    }
1139    return AvgVoteV.Len();
1140  }
1141  int TWikiElec::GetAvgVoteDevOt(TFltV& AvgVoteV, const bool& OnlyVotes) const {
1142    TWikiVoteV WVoteV;  GetVotesOt(WVoteV, OnlyVotes);
1143    double XBar = WVoteV[0].GetVote() > 0 ? 1 : 0;
1144    AvgVoteV.Clr(false);
1145    for (int i = 1; i < WVoteV.Len(); i++) {
1146      const double CurVote = WVoteV[i].GetVote() > 0 ? 1 : 0;
1147      AvgVoteV.Add(fabs(CurVote-XBar)/double(i+1));
1148      XBar = (i*XBar+CurVote)/double(i+1);
1149    }
1150    return AvgVoteV.Len();
1151  }
1152  int TWikiElec::GetRunLen(const int& VoteId) const {
1153    const int V = VoteV[VoteId].GetVote();
1154    int runL=0;
1155    for (int v = VoteId+1; v < Len(); v++) {
1156      if (VoteV[v].GetVote() == V) { runL++; }
1157      else { return runL; }
1158    }
1159    return runL;
1160  }
1161  void TWikiElec::PermuteVotes() {
1162    TIntV ValV(VoteV.Len(), 0);
1163    for (int i = 0; i < VoteV.Len(); i++) {
1164      ValV.Add(VoteV[i].UsrVote); }
1165    ValV.Shuffle(TInt::Rnd);
1166    for (int i = 0; i < ValV.Len(); i++) {
1167      VoteV[i].UsrVote=ValV[i]; }
1168  }
1169  void TWikiElec::KeepVotes(const TIntSet& UIdSet) {
1170    TWikiVoteV NewVoteV;
1171    for (int v = 0; v < VoteV.Len(); v++) {
1172      if (UIdSet.IsKey(VoteV[v].GetUId())) {
1173        NewVoteV.Add(VoteV[v]);
1174      }
1175    }
1176    VoteV=NewVoteV;
1177  }
1178  void TWikiElec::GetOnlyVotes(TWikiElec& NewElec, const bool& OnlySupOpp) const {
1179    NewElec.RfaTitle = RfaTitle;
1180    NewElec.UsrId = UsrId;
1181    NewElec.NomUId = NomUId;
1182    NewElec.BurUId = BurUId;
1183    NewElec.IsSucc = IsSucc;
1184    NewElec.ElecTm = ElecTm;
1185    NewElec.VoteV.Clr(false);
1186    for (int i = 0; i < VoteV.Len(); i++) {
1187      if (! VoteV[i].IsVote()) { continue; }
1188      if (OnlySupOpp && VoteV[i].GetVote()==0) { continue; }
1189      NewElec.VoteV.Add(VoteV[i]);
1190    }
1191  }
1192  void TWikiElec::RemoveSelfVotes() {
1193    TWikiVoteV VoteV2(Len(), 0);
1194    for (int v = 0; v < VoteV.Len(); v++) {
1195      if (VoteV[v].GetIndent()==0 && VoteV[v].GetUId()==UsrId) { continue; } 
1196      VoteV2.Add(VoteV[v]);
1197    }
1198    VoteV.Swap(VoteV2);
1199  }
1200  void TWikiElec::Dump(const TStrHash<TInt>& UsrH) const {
1201    TIntTr V = GetVotes(true);
1202    if (UsrH.IsKeyId(UsrId)) {
1203      printf("\nELEC %s : %s %d vote at %s votes %d\n", RfaTitle.CStr(), UsrH.GetKey(UsrId), UsrId, ElecTm.GetYmdTmStr().CStr(), VoteV.Len()); }
1204    else {
1205       printf("\nELEC %s : %d  %d vote at %s votes %d\n", RfaTitle.CStr(), UsrId, ElecTm.GetYmdTmStr().CStr(), VoteV.Len()); }
1206    printf("    %d / %d / %d  =  %f\n", V.Val1, V.Val2, V.Val3, V.Val1/double(V.Val1+V.Val3));
1207    for (int v = 0; v < VoteV.Len(); v++) {
1208      if (UsrH.IsKeyId(VoteV[v].UsrId)) {
1209        printf("  %2d  %2d %s: %s (%d)  %s  t:%d  i: %d\n", v+1, VoteV[v].UsrVote, VoteV[v].IsVote()?"V":" ", UsrH.GetKey(VoteV[v].UsrId), VoteV[v].UsrId, VoteV[v].VoteTm.GetYmdTmStr().CStr(), VoteV[v].TxtLen, VoteV[v].UsrIndent);
1210      } else {
1211        printf("  %2d  %2d %s: %d  %s  t:%d  i: %d\n", v+1, VoteV[v].UsrVote, VoteV[v].IsVote()?"V":" ", VoteV[v].UsrId, VoteV[v].VoteTm.GetYmdTmStr().CStr(), VoteV[v].TxtLen, VoteV[v].UsrIndent);
1212      }
1213    }
1214  }
1215  void TWikiElecBs::GetEIdByVotes(TIntV& EIdV, const bool& AscNumVotes) const {
1216    TIntPrV V(Len(), 0);
1217    for (int u = 0; u < Len(); u++) {
1218      const TWikiElec& E = GetElec(u);
1219      V.Add(TIntPr(E.Len(), E.UsrId));
1220    }
1221    V.Sort(AscNumVotes);
1222    EIdV.Clr(false);
1223    for (int u = 0; u < V.Len(); u++) {
1224      EIdV.Add(V[u].Val2); }
1225  }
1226  void TWikiElecBs::GetEIdByVotes(TIntV& EIdV, const int& MinLen, const double& FracPos, const double AboveFrac, const bool& AscNumVotes) const {
1227    TFltIntPrV V(Len(), 0);
1228    for (int u = 0; u < Len(); u++) {
1229      const TWikiElec& E = GetElec(u);
1230      if (E.Len() < MinLen) { continue; }
1231      if ((AboveFrac && E.GetFracSup() > FracPos) || (!AboveFrac && E.GetFracSup() < FracPos)) {
1232        V.Add(TFltIntPr(E.Len(), E.UsrId)); }
1233    }
1234    V.Sort(AscNumVotes);
1235    EIdV.Clr(false);
1236    for (int u = 0; u < V.Len(); u++) {
1237      EIdV.Add(V[u].Val2); }
1238  }
1239  void TWikiElecBs::GetEIdByFrac(TIntV& EIdV, const int& MinLen, const double& MnFracSup, const double& MxFracSup) const {
1240    TFltIntPrV V(Len(), 0);
1241    for (int u = 0; u < Len(); u++) {
1242      const TWikiElec& E = GetElec(u);
1243      if (E.Len() < MinLen) { continue; }
1244      const double FracSup = E.GetFracSup();
1245      if (FracSup==1) { continue; }
1246      if (FracSup >= MnFracSup && FracSup <= MxFracSup) {
1247        V.Add(TFltIntPr(FracSup, E.UsrId)); }
1248    }
1249    V.Sort(true);
1250    EIdV.Clr(false);
1251    for (int u = 0; u < V.Len(); u++) {
1252      EIdV.Add(V[u].Val2); }
1253  }
1254  void TWikiElecBs::GetUsrV(TIntV& UIdV) const {
1255    TIntSet UIdSet;
1256    for (int e = 0; e < Len(); e++) {
1257      const TWikiElec& E = GetElec(e);
1258      UIdSet.AddKey(E.GetUId());
1259      for (int v = 0; v < E.Len(); v++) {
1260        UIdSet.AddKey(E.GetVote(v).GetUId());
1261      }
1262    }
1263    UIdSet.GetKeyV(UIdV);
1264  }
1265  void TWikiElecBs::GetElecUsrV(TIntV& ElecUsrV) const {
1266    ElecUsrV.Clr(false);
1267    for (int e = 0; e < Len(); e++) {
1268      const TWikiElec& E = GetElec(e);
1269      ElecUsrV.Add(E.UsrId);
1270    }
1271  }
1272  void TWikiElecBs::GetElecAdminUsrV(TIntV& ElecAdminUsrV) const {
1273    ElecAdminUsrV.Clr(false);
1274    for (int e = 0; e < Len(); e++) {
1275      const TWikiElec& E = GetElec(e);
1276      if (E.IsSucc) {
1277        ElecAdminUsrV.Add(E.UsrId);
1278      }
1279    }
1280  }
1281  void TWikiElecBs::GetElecNonAdminUsrV(TIntV& ElecNonAdminUsrV) const {
1282    ElecNonAdminUsrV.Clr(false);
1283    for (int e = 0; e < Len(); e++) {
1284      const TWikiElec& E = GetElec(e);
1285      if (! E.IsSucc) {
1286        ElecNonAdminUsrV.Add(E.UsrId);
1287      }
1288    }
1289  }
1290  void TWikiElecBs::GetFqVoters(TIntSet& FqVoterSet, const int& MinVotes, const int& MinElecLen, const bool& OnlyAdmins) const {
1291    TIntH UsrCntH, CntH;
1292    printf("%d\n", Len());
1293    TIntSet AdminSet;
1294    if (OnlyAdmins) {
1295      GetAdminSet(AdminSet);
1296    }
1297    for (int e = 0; e < Len(); e++) {
1298      const TWikiElec& E = GetElec(e);
1299      if (E.Len() < MinElecLen) { continue; }
1300      for (int v = 0; v < E.Len(); v++) {
1301        if (OnlyAdmins && ! AdminSet.IsKey(E[v].GetUId())) {
1302          continue; } 
1303        UsrCntH.AddDat(E[v].GetUId()) += 1;
1304      }
1305    }
1306    for (int i = 0; i < UsrCntH.Len(); i++) {
1307      CntH.AddDat(UsrCntH[i]) += 1; }
1308    FqVoterSet.Clr(false);
1309    UsrCntH.SortByDat(false);
1310    for (int i = 0; i < UsrCntH.Len(); i++) {
1311      if (UsrCntH[i] >= MinVotes) {
1312        FqVoterSet.AddKey(UsrCntH.GetKey(i));
1313      }
1314    }
1315  }
1316  void TWikiElecBs::GetUsrVotes(TIntPrV& VoteUIdV) const {
1317    TIntH UsrCntH;
1318    for (int e = 0; e < Len(); e++) {
1319      const TWikiElec& E = GetElec(e);
1320      for (int v = 0; v < E.Len(); v++) {
1321        UsrCntH.AddDat(E[v].GetUId()) += 1;
1322      }
1323    }
1324    VoteUIdV.Clr();
1325    for (int i = 0; i < UsrCntH.Len(); i++) {
1326      VoteUIdV.Add(TIntPr(UsrCntH[i], UsrCntH.GetKey(i)));
1327    }
1328    VoteUIdV.Sort(false);
1329  }
1330  void TWikiElecBs::GetAdminSet(TIntSet& AdminSet) const {
1331    AdminSet.Clr(false);
1332    for (int e = 0; e < Len(); e++) {
1333      const TWikiElec& E = GetElec(e);
1334      if (E.IsSucc) {
1335        AdminSet.AddKey(E.UsrId);
1336      }
1337    }
1338    printf("  %d admins from elecs. ", AdminSet.Len());
1339    if (TFile::Exists("../../admin-list.txt")) {
1340      for (TSsParser Ss("../../admin-list.txt", ssfTabSep); Ss.Next(); ) {
1341        TStr U = Ss[0];
1342        if (IsUsr(U)) { AdminSet.AddKey(GetUId(U)); }
1343        if(IsUsr(U.GetLc())) { AdminSet.AddKey(GetUId(U.GetLc())); }
1344      }
1345    }
1346    printf("  %d admins after admin-list.txt\n", AdminSet.Len());
1347  }
1348  void TWikiElecBs::GetFqVoterSet(TIntSet& FqVoterSet) const {
1349    TIntPrV VoteUIdV;
1350    GetUsrVotes(VoteUIdV);
1351    int HalfVotes = GetVotes()/2, SoFar=0;
1352    FqVoterSet.Clr(false);
1353    for (int i = 0; i < VoteUIdV.Len() && SoFar < HalfVotes; i++) {
1354      FqVoterSet.AddKey(VoteUIdV[i].Val2);
1355      SoFar+=VoteUIdV[i].Val1;
1356    }
1357    printf("Users:%d (%d votes) FqVoters:%d (%d votes)\n", VoteUIdV.Len(), HalfVotes*2, FqVoterSet.Len(), SoFar);
1358  }
1359  void TWikiElecBs::GetAdminTmSet(THash<TInt, TSecTm>& AdminSet) const {
1360    AdminSet.Clr(false);
1361    for (int e = 0; e < Len(); e++) {
1362      const TWikiElec& E = GetElec(e);
1363      if (E.IsSucc) {
1364        AdminSet.AddDat(E.UsrId, E.GetTm());
1365      }
1366    }
1367  }
1368  void TWikiElecBs::KeepFqVoters(const int& MinVotes, const int& MinElecLen, const bool& OnlyAdmins) {
1369    TIntSet Voters;
1370    GetFqVoters(Voters, MinVotes, MinElecLen, OnlyAdmins);
1371    printf("freq  voters %d\n", Voters.Len());
1372    int VotesB=0, VotesA=0;
1373    for (int e = 0; e < Len(); e++) {
1374      TWikiElec& E = GetElec(e);
1375      VotesB += E.Len();
1376      if (E.Len() < MinElecLen) { E.VoteV.Clr(); }
1377      E.KeepVotes(Voters);
1378      VotesA += E.Len();
1379    }
1380    printf("Votes: %d --> %d\n", VotesB, VotesA);
1381  }
1382  void TWikiElecBs::KeepVoters(const bool& KeepAdmins, const bool& KeepNonAdmins) {
1383    TIntSet KeepVoters, Admins;
1384    GetAdminSet(Admins);
1385    if (KeepAdmins) {
1386      KeepVoters = Admins; }
1387    if (KeepNonAdmins) {
1388      TIntV UIdV; GetUsrV(UIdV);
1389      for (int i = 0; i < UIdV.Len(); i++) {
1390        if (! Admins.IsKey(UIdV[i])) {
1391          KeepVoters.AddKey(UIdV[i]); } }
1392    }
1393    int VotesB=0, VotesA=0;
1394    printf("voters %d\n", KeepVoters.Len());
1395    for (int e = 0; e < Len(); e++) {
1396      TWikiElec& E = GetElec(e);
1397      VotesB += E.Len();
1398      E.KeepVotes(KeepVoters);
1399      VotesA += E.Len();
1400    }
1401    printf("  votes: %d --> %d\n", VotesB, VotesA);
1402  }
1403  void TWikiElecBs::KeepTopVoters(const int& Votes, const bool& KeepTop) {
1404  }
1405  void TWikiElecBs::PermuteVotes() {
1406    printf("Permute election entries...");
1407    for (int u = 0; u < Len(); u++) {
1408      GetElec(u).PermuteVotes();
1409    }
1410    printf("done.\n");
1411  }
1412  void TWikiElecBs::SortVotesByTm() {
1413    for (int e = 0; e < Len(); e++) {
1414      GetElec(e).VoteV.Sort();
1415    }
1416  }
1417  int TWikiElecBs::GetVoteTrails(const int& MinUsrVotes, const bool& No01Prob, TIntV& UIdV, TVec<TFltPrV>& ProbSupTmV,
1418                                  TVec<TFltPrV>& FracSupTmV, TVec<TFltPrV>& ProbSupFracSupV, TVec<TFltPrV>& VotesTmV) const {
1419    UIdV.Clr();  ProbSupTmV.Clr();  FracSupTmV.Clr();
1420    ProbSupFracSupV.Clr();  VotesTmV.Clr();
1421    THash<TInt, TIntPrV> UIdVotesH;
1422    TIntFltH FracSupH;
1423    for (int e = 0; e < Len(); e++) {
1424      const TWikiElec& E = GetElec(e);
1425      if (E.Len() < 10) { continue; } 
1426      for (int v = 0; v < E.Len(); v++) {
1427        UIdVotesH.AddDat(E[v].GetUId()).Add(TIntPr(e,v));
1428      }
1429      FracSupH.AddDat(e, E.GetFracSup());
1430    }
1431    int Votes = 0;
1432    UIdVotesH.SortByDat(false);
1433    TIntH AllCntH, AllCntHS, AllCntHF;
1434    for (int u = 0; u < UIdVotesH.Len(); u++) {
1435      THash<TInt, TMom> TProbH, TFracH, UFPH;
1436      THash<TFlt, TFlt> TVotesH;
1437      TIntPrV& EV = UIdVotesH[u];
1438      EV.Sort();
1439      const int UId = UIdVotesH.GetKey(u);
1440      if (EV.Len() < MinUsrVotes) { continue; }
1441      EV.Del(EV.Len()/2, EV.Len()-1);
1442      for (int ev = 0; ev < EV.Len(); ev++) { 
1443        const TWikiElec& E = GetElec(EV[ev].Val1);
1444        const int v = EV[ev].Val2;
1445        if (v < 10) { continue; } 
1446        const int Vote = E[v].GetVote()==1 ? 1:0;
1447        const double Frac = E.GetFracSup(0, v); 
1448        if (v < 110) { 
1449          TProbH.AddDat(10*(v/10)).Add(Vote);
1450          TFracH.AddDat(10*(v/10)).Add(Frac);
1451          TVotesH.AddDat(10*(v/10)) += 1;
1452        }
1453        UFPH.AddDat(10*(int)TMath::Round(10*Frac)).Add(Vote);
1454        Votes++;
1455      }
1456      double M;
1457      TFltPrV TPV, TFV, TFPV, TVV;
1458      for (int i = 0; i < TProbH.Len(); i++) {
1459        TProbH[i].Def();   M = TProbH[i].GetMean();
1460        if (No01Prob && M!=0 && M!=1) { TPV.Add(TFltPr(TProbH.GetKey(i).Val, M)); }
1461        else if (! No01Prob) { TPV.Add(TFltPr(TProbH.GetKey(i).Val, M)); }
1462      }
1463      for (int i = 0; i < TFracH.Len(); i++) {
1464        TFracH[i].Def();   M = TFracH[i].GetMean();
1465        if (No01Prob && M!=0 && M!=1) { TFV.Add(TFltPr(TFracH.GetKey(i).Val, M)); }
1466        else if (! No01Prob) { TFV.Add(TFltPr(TFracH.GetKey(i).Val, M)); }
1467      }
1468      for (int i = 0; i < UFPH.Len(); i++) {
1469        UFPH[i].Def();   M = UFPH[i].GetMean();
1470        if (No01Prob && M!=0 && M!=1) { TFPV.Add(TFltPr(UFPH.GetKey(i).Val, M)); }
1471        else if (! No01Prob) { TFPV.Add(TFltPr(UFPH.GetKey(i).Val, M)); }
1472      }
1473      TVotesH.GetKeyDatPrV(TVV);  TVV.Sort();
1474      TFPV.Sort(); TPV.Sort(); TFV.Sort();
1475      if (TFPV[0].Val1!=0.0) { TFPV.Ins(0, TFltPr(0,0)); printf("Z");} 
1476      if (TFPV.Last().Val1!=100.0) { TFPV.Add(TFltPr(100,1)); printf("O");} 
1477      UIdV.Add(UId);
1478      ProbSupTmV.Add(TPV);
1479      FracSupTmV.Add(TFV);
1480      ProbSupFracSupV.Add(TFPV);
1481      VotesTmV.Add(TVV);
1482    }
1483    IAssert(UIdV.Len() == ProbSupTmV.Len());
1484    return Votes;
1485  }
1486  void TWikiElecBs::GetVoteTrails2(const int& MinUsrVotes, const bool& No01Prob, TIntV& UIdV, TVec<TFltPrV>& VoteIdxFracSupV, TVec<TFltPrV>& NVotesFracSupV) const {
1487    UIdV.Clr();  VoteIdxFracSupV.Clr();  NVotesFracSupV.Clr();
1488    THash<TInt, TIntPrV> UIdVotesH;
1489    TIntFltH FracSupH;
1490    for (int e = 0; e < Len(); e++) {
1491      const TWikiElec& E = GetElec(e);
1492      if (E.Len() < 10) { continue; } 
1493      for (int v = 0; v < E.Len(); v++) {
1494        UIdVotesH.AddDat(E[v].GetUId()).Add(TIntPr(e,v));
1495      }
1496      FracSupH.AddDat(e, E.GetFracSup());
1497    }
1498    UIdVotesH.SortByDat(false);
1499    TIntH AllCntH, AllCntHS, AllCntHF;
1500    for (int u = 0; u < UIdVotesH.Len(); u++) {
1501      THash<TInt, TMom> FSVIdxH;
1502      TFltFltH FSVotesH;
1503      const TIntPrV& EV = UIdVotesH[u];
1504      const int UId = UIdVotesH.GetKey(u);
1505      if (EV.Len() < MinUsrVotes) { continue; }
1506      for (int ev = 0; ev < EV.Len(); ev++) { 
1507        const TWikiElec& E = GetElec(EV[ev].Val1);
1508        const int v = EV[ev].Val2;
1509        const int Vote = E[v].GetVote()==1 ? 1:0;
1510        const double Frac = E.GetFracSup(0, v); 
1511        FSVotesH.AddDat(10*int(10*Frac)) += 1;
1512        FSVIdxH.AddDat(10*int(10*Frac)).Add(v);
1513      }
1514      UIdV.Add(UId);
1515      double M = 0;
1516      VoteIdxFracSupV.Add();
1517      TFltPrV& VoteIdxV = VoteIdxFracSupV.Last();
1518      for (int i = 0; i < FSVIdxH.Len(); i++) {
1519        FSVIdxH[i].Def();   M = FSVIdxH[i].GetMean();
1520        if (No01Prob && M!=0 && M!=1) { VoteIdxV.Add(TFltPr(FSVIdxH.GetKey(i).Val, M)); }
1521        else if (! No01Prob) { VoteIdxV.Add(TFltPr(FSVIdxH.GetKey(i).Val, M)); }
1522      }
1523      VoteIdxV.Sort();
1524      NVotesFracSupV.Add();
1525      FSVotesH.GetKeyDatPrV(NVotesFracSupV.Last());
1526      NVotesFracSupV.Last().Sort();
1527    }
1528  }
1529  void TWikiElecBs::GetUsrVoteTrail(const TIntV& UIdV, TVec<TFltPrV>& ProbPosFracPosV) const {
1530    ProbPosFracPosV.Clr();
1531    THash<TInt, TIntPrV> UIdVotesH;
1532    for (int e = 0; e < Len(); e++) {
1533      const TWikiElec& E = GetElec(e);
1534      if (E.Len() < 10) { continue; } 
1535      for (int v = 0; v < E.Len(); v++) {
1536        UIdVotesH.AddDat(E[v].GetUId()).Add(TIntPr(e,v));
1537      }
1538    }
1539    for (int u = 0; u < UIdV.Len(); u++) {
1540      ProbPosFracPosV.Add();
1541      if (! UIdVotesH.IsKey(UIdV[u])) { continue; }
1542      const TIntPrV& EV = UIdVotesH.GetDat(UIdV[u]);
1543      THash<TInt, TMom> FracProbH;
1544      for (int ev = 0; ev < EV.Len(); ev++) { 
1545        const TWikiElec& E = GetElec(EV[ev].Val1);
1546        const int v = EV[ev].Val2;
1547        const int Vote = E[v].GetVote()==1 ? 1:0;
1548        const double Frac = E.GetFracSup(0, v); 
1549        FracProbH.AddDat(10*int(10*Frac)).Add(Vote);
1550      }
1551      FracProbH.SortByKey();
1552      TFltPrV& ProbFracV = ProbPosFracPosV.Last();
1553      for (int i = 0; i < FracProbH.Len(); i++) {
1554        FracProbH[i].Def();
1555        const double M = FracProbH[i].GetMean();
1556        ProbFracV.Add(TFltPr(FracProbH.GetKey(i).Val, M));
1557      }
1558      ProbFracV.Sort();
1559    }
1560  }
1561  void TWikiElecBs::GetUsrAreaUTrail(const TIntV& UIdV, TFltV& AreaV) const {
1562    TVec<TFltPrV> ProbPosFracPosV;
1563    GetUsrVoteTrail(UIdV, ProbPosFracPosV);
1564    AreaV.Clr();
1565    for (int u = 0; u < ProbPosFracPosV.Len(); u++) {
1566      double Area = 0;
1567      TFltPrV& V = ProbPosFracPosV[u];
1568      for (int f = 0; f < V.Len(); f++) {
1569        IAssert(V[f].Val1>= 0 && V[f].Val1<=100);
1570        Area += (V[f].Val2 - V[f].Val1/100.0);
1571      }
1572      AreaV.Add(Area);
1573    }
1574  }
1575  void TWikiElecBs::PlotElecLenDistr(const TStr& OutFNm) const {
1576    TIntH SupCntHS, OppCntHS, VotesCntHS, 
1577          SupCntHF, OppCntHF, VotesCntHF, 
1578          SupCntHA, OppCntHA, VotesCntHA; 
1579    TIntH VotesPerUser;
1580    THashSet<TFltPr> SupOppHS, SupOppHF;
1581    THash<TInt, TMom> ElLenVsSucc;
1582    TIntH SupFracA, SupFracS, SupFracF;
1583    for (int e = 0; e < Len(); e++) {
1584      const TWikiElec& E = GetElec(e);
1585      const int SupFrac = (int)TMath::Round(E.GetFracSup()*10)*10;
1586      TIntTr V = E.GetVotes();
1587      int len = (E.Len()/5)*5;
1588      V.Val1 = (V.Val1/5)*5;
1589      V.Val2 = (V.Val2/5)*5;
1590      V.Val3 = (V.Val3/5)*5;
1591      SupFracA.AddDat(SupFrac) +=1;
1592      if (E.IsSucc) {
1593        SupFracS.AddDat(SupFrac) += 1;
1594        VotesCntHS.AddDat(len) += 1;
1595        SupCntHS.AddDat(V.Val1) += 1;
1596        OppCntHS.AddDat(V.Val3) += 1;
1597        SupOppHS.AddKey(TFltPr(V.Val1+0.1+TInt::Rnd.GetNrmDev(), V.Val3+0.1+TInt::Rnd.GetNrmDev()));
1598        ElLenVsSucc.AddDat(len).Add(1);
1599      } else {
1600        SupFracF.AddDat(SupFrac) += 1;
1601        VotesCntHF.AddDat(len) += 1;
1602        SupCntHF.AddDat(V.Val1) += 1;
1603        OppCntHF.AddDat(V.Val3) += 1;
1604        SupOppHF.AddKey(TFltPr(V.Val1+0.1+TInt::Rnd.GetNrmDev(), V.Val3+0.1+TInt::Rnd.GetNrmDev()));
1605        ElLenVsSucc.AddDat(len).Add(0);
1606      }
1607      VotesCntHA.AddDat(len) += 1;
1608      SupCntHA.AddDat(V.Val1) += 1;
1609      OppCntHA.AddDat(V.Val3) += 1;
1610    }
<span onclick='openModal()' class='match'>1611    TIntPrV VotesUIdV; GetUsrVotes(VotesUIdV);
1612    for (int i = 0; i < VotesUIdV.Len(); i++) {
1613      VotesPerUser.AddDat(10*(VotesUIdV[i].Val1/10))+=1;
</span>1614    }
1615    TGnuPlot::PlotValCntH(VotesPerUser, "userVotes-"+OutFNm, "", "Number of votes", "Number of such users");
1616    TGnuPlot::PlotValMomH(ElLenVsSucc, "elLenSucc-"+OutFNm, "", "Election length", "Probability of success");
1617    { TGnuPlot GP("suppOppScatter-"+OutFNm); GP.SetXYLabel("Support votes", "Oppose votes");
1618    TFltPrV SuccV, FailV;  SupOppHS.GetKeyV(SuccV);  SupOppHF.GetKeyV(FailV);
1619    GP.AddPlot(FailV, gpwPoints, "FAIL");  GP.AddPlot(SuccV, gpwPoints, "SUCC");
1620    GP.SavePng(); }
1621    { TGnuPlot GP("countSup-"+OutFNm); GP.SetXYLabel("Support votes", "Count");
1622    GP.AddPlot(SupCntHA, gpwLinesPoints, "ALL elections");
1623    GP.AddPlot(SupCntHS, gpwLinesPoints, "SUCC elections");
1624    GP.AddPlot(SupCntHF, gpwLinesPoints, "FAIL elections");
1625    GP.SavePng(); }
1626    { TGnuPlot GP("countOpp-"+OutFNm); GP.SetXYLabel("Oppose votes", "Count");
1627    GP.AddPlot(OppCntHA, gpwLinesPoints, "ALL elections");
1628    GP.AddPlot(OppCntHS, gpwLinesPoints, "SUCC elections");
1629    GP.AddPlot(OppCntHF, gpwLinesPoints, "FAIL elections");
1630    GP.SavePng(); }
1631    { TGnuPlot GP("countVot-"+OutFNm); GP.SetXYLabel("Votes", "Count");
1632    GP.AddPlot(VotesCntHA, gpwLinesPoints, "ALL elections");
1633    GP.AddPlot(VotesCntHS, gpwLinesPoints, "SUCC elections");
1634    GP.AddPlot(VotesCntHF, gpwLinesPoints, "FAIL elections");
1635    GP.SavePng(); }
1636    { TGnuPlot GP("supFrac-"+OutFNm); GP.SetXYLabel("Final Fraction of support votes", "Number of such elections");
1637    GP.AddPlot(SupFracA, gpwLinesPoints, "ALL elections");
1638    GP.AddPlot(SupFracS, gpwLinesPoints, "SUCC elections");
1639    GP.AddPlot(SupFracF, gpwLinesPoints, "FAIL elections");
1640    GP.SavePng(); }
1641  }
1642  void TWikiElecBs::PlotElecSupOppOt(const TStr& OutFNm, const int& MinVotes, const int& MaxVotes) const {
1643    int ElecCnt=0;
1644    TGnuPlot GP("supOppOT-"+OutFNm);
1645    for (int e = 0; e < Len(); e++) {
1646      const TWikiElec& E = GetElec(e);
1647      if (E.Len() < MinVotes || E.Len() > MaxVotes) { continue; }
1648      TFltPrV OppSupV; OppSupV.Add(TFltPr(0,0));
1649      for (int v = 0; v < E.Len(); v++) {
1650        const int S = E[v].GetVote();
1651        OppSupV.Add(TFltPr(OppSupV.Last().Val1+(S<0?1:0)+0.1*TInt::Rnd.GetNrmDev(),
1652                           OppSupV.Last().Val2+(S>0?1:0)+0.1*TInt::Rnd.GetNrmDev()));
1653      }
1654      GP.AddPlot(OppSupV, gpwLines, "", TStr::Fmt("lt %d", E.IsSucc?2:1));
1655      ElecCnt++;
1656    }
1657    GP.SetXYLabel("oppose votes", "support votes");
1658    GP.SetTitle(TStr::Fmt("elections with %d -- %d votes: %d elections", MinVotes, MaxVotes, ElecCnt));
1659    GP.SavePng();
1660  }
1661  void TWikiElecBs::PlotRunLenStat(const TStr& OutFNm, const int& MinVotes, const int& MaxVotes) const {
1662    THash<TInt, TTriple<TMom, TMom, TMom> > UsrMomH;
1663    THash<TInt, TMom> TxtLenH;
1664    TPair<TMom, TMom> RunLStat;
1665    THash<TInt, TInt> SupH, OppH;
1666    int Cnt=0;
1667    for (int e = 0; e < Len(); e++) {
1668      const TWikiElec& E = GetElec(e);
1669      if (E.Len() < MinVotes || E.Len() > MaxVotes) { continue; }
1670      for (int v = 0; v < E.Len(); v++) {
1671        const int V = E.GetVote(v).GetVote();
1672        const int RunL = E.GetRunLen(v);
1673        if (V == 1) {
1674          UsrMomH.AddDat(E.GetVote(v).GetUId()).Val1.Add(RunL);
1675          RunLStat.Val1.Add(RunL);
1676          SupH.AddDat(RunL)++;
1677        } else {
1678          UsrMomH.AddDat(E.GetVote(v).GetUId()).Val2.Add(RunL);
1679          RunLStat.Val2.Add(RunL);
1680          OppH.AddDat(RunL)++;
1681        }
1682        UsrMomH.AddDat(E.GetVote(v).GetUId()).Val3.Add(E[v].GetTxtLen());
1683        TxtLenH.AddDat(10*(E[v].GetTxtLen()/10)).Add(RunL);
1684      }
1685      Cnt++;
1686    }
1687    TGnuPlot::PlotValMomH(TxtLenH, "runLenTxtLen-"+OutFNm, "", "Length of the text supporting the vote", "Run length",
1688      gpsAuto, gpwLinesPoints, true, true, false, false, false);
1689    RunLStat.Val1.Def();
1690    RunLStat.Val2.Def();
1691    printf("SUP run len: A:%g  M:%g\n", RunLStat.Val1.GetMean(), RunLStat.Val1.GetMedian());
1692    printf("OPP run len: A:%g  M:%g\n", RunLStat.Val2.GetMean(), RunLStat.Val2.GetMedian());
1693    TGnuPlot GP("runLen-"+OutFNm, TStr::Fmt("Elecs %d--%d: %d. SUP run len: A:%g  M:%g  OPP: A:%g  M:%g", MinVotes, MaxVotes, Cnt,
1694      RunLStat.Val1.GetMean(), RunLStat.Val1.GetMedian(), RunLStat.Val2.GetMean(), RunLStat.Val2.GetMedian()));
1695    GP.AddPlot(OppH, gpwLinesPoints, "OPP");
1696    GP.AddPlot(SupH, gpwLinesPoints, "SUP");
1697    GP.SetXYLabel("run length", "count");
1698    GP.SavePng();
1699    FILE *F = fopen(TStr::Fmt("runLenUsers-%s.tab", OutFNm.CStr()).CStr(), "wt");
1700    fprintf(F, "#UsrId\tUser\tVotes\tSup-Votes\tOpp-Votes\tSup-Avg\tSup-Med\tOpp-Avg\tOpp-Med\tTxtLen-Avg\tTxtLen-Med\n");
1701    for (int u = 0; u < UsrMomH.Len(); u++) {
1702      TMom& MS = UsrMomH[u].Val1;  MS.Def();
1703      TMom& MO = UsrMomH[u].Val2;  MO.Def();
1704      TMom& TL = UsrMomH[u].Val3;  TL.Def();
1705      fprintf(F, "%d\t%s\t%d\t%d\t%d\t%g\t%g\t%g\t%g\t%g\t%g\n", UsrMomH.GetKey(u), GetUsr(UsrMomH.GetKey(u)),
1706        MS.GetVals()+MO.GetVals(), MS.GetVals(), MO.GetVals(), MS.GetMean(), MS.GetMedian(), MO.GetMean(), MO.GetMedian(),
1707        TL.GetMean(), TL.GetMedian());
1708    }
1709    fclose(F);
1710  }
1711  void TWikiElecBs::DrawElecTree(const TStr& OutFNm, const int& MinVotes) const {
1712    TIntV UIdV;  GetEIdByVotes(UIdV);
1713    TWikiVoteV VoteV;
1714    THash<TInt, TIntQu> TreeH;  
1715    const int TakeVotes = 3;
1716    for (int e = 0; e < Len(); e++) {
1717      const TWikiElec& E = GetElec(e);
1718      if (E.Len() < MinVotes) { continue; }
1719      TInt BegVote=1;
1720      const TIntTr SNO = E.GetVotes();
1721      { TIntQu& V = TreeH.AddDat(BegVote);
1722      V.Val1 += SNO.Val1; V.Val2 += SNO.Val3;  V.Val3 += 1;
1723      V.Val4 += E.IsSucc() ? 1:0; }
1724      for (int v = 0; v < TakeVotes; v++) {
1725        if (E[v].GetVote() == 1) { BegVote = 2*BegVote+1; } 
1726        else { BegVote = 2*BegVote; } 
1727        TIntQu& V = TreeH.AddDat(BegVote);
1728        V.Val1 += SNO.Val1;
1729        V.Val2 += SNO.Val3;
1730        V.Val3 += 1;
1731        V.Val4 += E.IsSucc() ? 1:0;
1732      }
1733    }
1734    PNGraph G = TNGraph::New();
1735    TIntStrH LabelH;
1736    TreeH.SortByKey();
1737    for (int i = 0; i < TreeH.Len(); i++) {
1738      printf("%d\n", TreeH.GetKey(i));
1739      const int id = TreeH.GetKey(i);
1740      const int nid = G->AddNode(i+1);
1741      LabelH.AddDat(nid, TStr::Fmt("%sElections: %d\\nSuccessful: %.3f", id==1?"":(id%2==1 ?"SUPPORT\\n":"OPPOSE\\n"), TreeH[i].Val3, TreeH[i].Val4/double(TreeH[i].Val3)));
1742      if (id > 1) {
1743        G->AddEdge(id/2, nid);
1744        printf("link  %d <-- %d\n", id/2, nid);
1745      }
1746    }
1747    TGraphViz::Plot(G, gvlDot, "elecTree-"+OutFNm+".gif", "", LabelH);
1748  }
1749  void TWikiElecBs::PlotVotesOt(const TStr& OutFNm, const int& MinVotes, const int& MaxVotes) const {
1750    THash<TInt, TMom> FSupOtA, PSupOtA, DevOtA,
1751      FSupOtS, PSupOtS, DevOtS, FSupOtF, PSupOtF, DevOtF;
1752    int Cnt=0;
1753    for (int e = 0; e < Len(); e++) {
1754      const TWikiElec& E = GetElec(e);
1755      if (E.Len() < MinVotes || E.Len() > MaxVotes) { continue; }
1756      int S = 0;
1757      double Dev = 0;
1758      for (int v = 0; v < E.Len(); v++) {
1759        const int V = E.GetVote(v).GetVote()==1? 1:0;
1760        if (v > 0) {
1761          Dev = fabs(V - S/double(v))/double(v+1); }
1762        S += V; 
1763        if (E.IsSucc) {
1764          FSupOtS.AddDat(v+1).Add(S/double(v+1));
1765          PSupOtS.AddDat(v+1).Add(V);
1766          DevOtS.AddDat(v+1).Add(Dev);
1767        } else {
1768          FSupOtF.AddDat(v+1).Add(S/double(v+1));
1769          PSupOtF.AddDat(v+1).Add(V);
1770          DevOtF.AddDat(v+1).Add(Dev);
1771        }
1772        FSupOtA.AddDat(v+1).Add(S/double(v+1));
1773        PSupOtA.AddDat(v+1).Add(V);
1774        DevOtA.AddDat(v+1).Add(Dev);
1775      }
1776      Cnt++;
1777    }
1778    { TGnuPlot GP("votesOT-Frac-"+OutFNm, TStr::Fmt("Elections %d--%d: %d", MinVotes, MaxVotes, Cnt));
1779    GP.SetXYLabel("Time (vote index)", "Fraction of support votes so far");
1780    GP.AddPlot(FSupOtA, gpwLinesPoints, "ALL elections", "", true, false);
1781    GP.AddPlot(FSupOtS, gpwLinesPoints, "SUCC elections", "", true, false);
1782    GP.AddPlot(FSupOtF, gpwLinesPoints, "FAIL elections", "", true, false);
1783    if (MinVotes>10) { GP.SetXRange(0, MinVotes); }  GP.SavePng(); }
1784    { TGnuPlot GP("votesOT-Sup-"+OutFNm, TStr::Fmt("Elections %d--%d: %d", MinVotes, MaxVotes, Cnt));
1785    GP.SetXYLabel("Time (vote index)", "Probability i-th vote is Support");
1786    GP.AddPlot(PSupOtA, gpwLinesPoints, "ALL elections", "", true, false);
1787    GP.AddPlot(PSupOtS, gpwLinesPoints, "SUCC elections", "", true, false);
1788    GP.AddPlot(PSupOtF, gpwLinesPoints, "FAIL elections", "", true, false);
1789    if (MinVotes>10) { GP.SetXRange(0, MinVotes); }  GP.SavePng(); }
1790    { TGnuPlot GP("votesOT-Dev-"+OutFNm, TStr::Fmt("Elections %d--%d: %d", MinVotes, MaxVotes, Cnt));
1791    GP.SetXYLabel("Time (vote index)", "Vote deviation: avg |avg(V,t+1) - avg(V,t)|");
1792    GP.AddPlot(DevOtA, gpwLinesPoints, "ALL elections", "", true, false);
1793    GP.AddPlot(DevOtS, gpwLinesPoints, "SUCC elections", "", true, false);
1794    GP.AddPlot(DevOtF, gpwLinesPoints, "FAIL elections", "", true, false);
1795    if (MinVotes>10) { GP.SetXRange(0, MinVotes); }  GP.SavePng(); }
1796  }
1797  void TWikiElecBs::PlotCovotingUsers(const TStr& OutFNm, const TStr& MinSupStr, const int& TakeOnlyVotes) const {
1798    PNGraph G = TNGraph::New();
1799    TStrSet RfaSet;
1800    for (int e = 0; e < Len(); e++) {
1801      const TWikiElec& E = GetElec(e);
1802      const int RfaId = Kilo(100)+RfaSet.AddKey(E.RfaTitle);
1803      if (G->IsNode(RfaId)) { printf("%s\n", E.RfaTitle.CStr()); continue; }
1804      IAssertR(! G->IsNode(RfaId), E.RfaTitle);
1805      G->AddNode(RfaId);
1806      for (int v = 0; v < E.Len(); v++) {
1807        if (TakeOnlyVotes==1 && E[v].GetVote() != 1) { continue; } 
1808        else if (TakeOnlyVotes==-1 && E[v].GetVote() != -1) { continue; } 
1809        const int usr = E[v].GetUId();
1810        if (! G->IsNode(usr)) { G->AddNode(usr); }
1811        IAssert(! G->IsEdge(usr, RfaId));
1812        G->AddEdge(usr, RfaId);
1813      }
1814    }
1815    TSnap::PrintInfo(G);
1816    printf("\n*** ALL VOTES\n");
1817    TStrV MinSupV;
1818    TStr(MinSupStr).SplitOnAllCh(',', MinSupV);
1819    TGnuPlot GP(TStr::Fmt("itemSet-%s", OutFNm.CStr()), "Number and size of frequent itemsets");
1820    for (int i = 0; i < MinSupV.Len(); i++) {
1821      printf("\n*** MinSup = %s\n", MinSupV[i].CStr());
1822      TTrawling Trawl(G, MinSupV[i].GetInt());
1823      const TIntPrV SzCntV = Trawl.PlotMinFqVsMaxSet(TStr::Fmt("%s-%02d", OutFNm.CStr(), MinSupV[i].GetInt()));
1824      GP.AddPlot(SzCntV, gpwLinesPoints, TStr::Fmt("MinSup = %d", MinSupV[i].GetInt()));
1825    }
1826    GP.SetXYLabel("Itemset size", "Number of itemsets");
1827    GP.SavePng();
1828  }
1829  void TWikiElecBs::PlotFracBeforeAfterVote(const TStr& OutFNm) const {
1830    THash<TInt, TIntPrV> UIdVotesH;
1831    for (int e = 0; e < Len(); e++) {
1832      const TWikiElec& E = GetElec(e);
1833      if (E.Len() < 10) { continue; } 
1834      for (int v = 0; v < E.Len(); v++) {
1835        UIdVotesH.AddDat(E[v].GetUId()).Add(TIntPr(e,v));
1836      }
1837    }
1838    THash<TFlt, TInt> DeltaCntHA, DeltaCntHS, DeltaCntHO, DeltaCntHA2, DeltaCntHS2, DeltaCntHO2;
1839    FILE *F = fopen(TStr::Fmt("deltabBAUsr-%s.tab", OutFNm.CStr()).CStr(), "wt");
1840    fprintf(F, "#Usr\tVotes\tAvgDSup\tMedDSup\tSupVotes\tAvgDOpp\tMedDOpp\tOppVotes\tAvgTrendSup\tMedTrendSup\tAvgTrendOpp\tMedTrendOpp\n");
1841    for (int u = 0; u < UIdVotesH.Len(); u++) {
1842      const TIntPrV& EV = UIdVotesH[u];
1843      if (EV.Len() < 10) { continue; } 
1844      TMom MomS, MomO, MomS2, MomO2;
1845      for (int ev = 0; ev < EV.Len(); ev++) {
1846        const TWikiElec& E = GetElec(EV[ev].Val1);
1847        const int v = EV[ev].Val2;
1848        if (v < 5 || v+5 >= E.Len()) { continue; }
1849        const double Bef = E.GetFracSup(0, v); 
1850        const double Aft = E.GetFracSup(v+1, E.Len()); 
1851        const double Bef2 = E.GetTrend(0, v);
1852        const double Aft2 = E.GetTrend(v+1, E.Len()); 
1853        DeltaCntHA.AddDat(TMath::Round(Aft-Bef, 2)) += 1;
1854        DeltaCntHA2.AddDat(TMath::Round(Aft2-Bef2, 2)) += 1;
1855        if (E[v].GetVote() == 1) {
1856          DeltaCntHS.AddDat(TMath::Round(Aft-Bef, 2)) += 1;
1857          DeltaCntHS2.AddDat(TMath::Round(Aft2-Bef2, 2)) += 1;
1858          MomS.Add(Aft-Bef);
1859          MomS2.Add(Aft2-Bef2);
1860        } else {
1861          DeltaCntHO.AddDat(TMath::Round(Aft-Bef, 2)) += 1;
1862          DeltaCntHO2.AddDat(TMath::Round(Aft2-Bef2, 2)) += 1;
1863          MomO.Add(Aft-Bef);
1864          MomO2.Add(Aft2-Bef2);
1865        }
1866      }
1867      MomS.Def(); MomO.Def();  MomS2.Def(); MomO2.Def();
1868      if (! MomS.IsUsable() || ! MomO.IsUsable()) { continue; }
1869      fprintf(F, "%s\t%d\t%f\t%f\t%d\t%f\t%f\t%d\n", GetUsr(UIdVotesH.GetKey(u)), EV.Len(),
1870        MomS.GetMean(), MomS.GetMedian(), MomS.GetVals(), MomO.GetMean(), MomO.GetMedian(), MomO.GetVals(),
1871        MomS2.GetMean(), MomS2.GetMedian(), MomO2.GetMean(), MomO2.GetMedian());
1872    }
1873    fclose(F);
1874    TGnuPlot::PlotValCntH(DeltaCntHA, "deltaBA-"+OutFNm, "Fraction of support votes After-Before user casted a vote. (min 10 votes per user, min 10 vote elections, min 5 votes before/after",
1875      "After - Before fraction of support votes. Any vote.", "Count");
1876    TGnuPlot::PlotValCntH(DeltaCntHS, "deltaBASup-"+OutFNm, "Fraction of support votes After-Before user casted a vote. (min 10 votes per user, min 10 vote elections, min 5 votes before/after",
1877      "After - Before fraction of support votes. User voted +1.", "Count");
1878    TGnuPlot::PlotValCntH(DeltaCntHO, "deltaBAOpp-"+OutFNm, "Fraction of support votes After-Before user casted a vote. (min 10 votes per user, min 10 vote elections, min 5 votes before/after",
1879      "After - Before fraction of support votes. User voted -1.", "Count");
1880    TGnuPlot::PlotValCntH(DeltaCntHA2, "deltaTrBA-"+OutFNm, "Trend of fraction ofsupport votes After-Before user casted a vote. (min 10 votes per user, min 10 vote elections, min 5 votes before/after",
1881      "After - Before trend (linear fit coefficient) fraction of support votes. Any vote.", "Count");
1882    TGnuPlot::PlotValCntH(DeltaCntHS2, "deltaTrBASup-"+OutFNm, "Trend of fraction ofsupport votes After-Before user casted a vote. (min 10 votes per user, min 10 vote elections, min 5 votes before/after",
1883      "After - Before trend (linear fit coefficient) fraction of support votes. User voted +1.", "Count");
1884    TGnuPlot::PlotValCntH(DeltaCntHO2, "deltaTrBAOpp-"+OutFNm, "Trend of fraction of support votes After-Before user casted a vote. (min 10 votes per user, min 10 vote elections, min 5 votes before/after",
1885      "After - Before trend (linear fit coefficient) fraction of support votes. User voted -1.", "Count");
1886  }
1887  void TWikiElecBs::PlotDeltaFracSupOt(const TStr& OutFNm, const int& MinVotes, const int& MaxVotes) const {
1888    THash<TInt, TMom> DeltaOtA, DeltaOtS, DeltaOtF;
1889    int Cnt = 0, CntS=0, CntF=0;
1890    for (int e = 0; e < Len(); e++) {
1891      const TWikiElec& E = GetElec(e);
1892      if (E.Len() < MinVotes || E.Len() > MaxVotes) { continue; }
1893      TIntTr SNO = E.GetVotes();
1894      const double FinalF = SNO.Val1/double(SNO.Val1+SNO.Val3);
1895      int S = 0;
1896      for (int v = 0; v < E.Len(); v++) {
1897        const int V = E.GetVote(v).GetVote()==1? 1:0;
1898        S += V; 
1899        if (E.IsSucc) { DeltaOtS.AddDat(v).Add(S/double(v+1)-FinalF); }
1900        else { DeltaOtF.AddDat(v).Add(S/double(v+1)-FinalF); }
1901        DeltaOtA.AddDat(v).Add(S/double(v+1)-FinalF);
1902      }
1903      if (E.IsSucc) { CntS++; }
1904      else { CntF++; }
1905      Cnt++;
1906    }
1907    TGnuPlot::PlotValMomH(DeltaOtA, "deltaFracSup-A-"+OutFNm, TStr::Fmt("ALL Elections %d--%d: %d", MinVotes, MaxVotes, Cnt),
1908      "Vote index", "Deviation from the final fraction of support votes");
1909    TGnuPlot::PlotValMomH(DeltaOtS, "deltaFracSup-S-"+OutFNm, TStr::Fmt("SUCC Elections %d--%d: %d", MinVotes, MaxVotes, CntS),
1910      "Vote index", "Deviation from the final fraction of support votes");
1911    TGnuPlot::PlotValMomH(DeltaOtF, "deltaFracSup-F-"+OutFNm, TStr::Fmt("FAIL Elections %d--%d: %d", MinVotes, MaxVotes, CntF),
1912      "Vote index", "Deviation from the final fraction of support votes");
1913  }
1914  void TWikiElecBs::PlotUsrVoteVsTime(const TStr& OutFNm, const int& MinUsrVotes, const TIntSet& UsrSplitSet) const {
1915    THash<TInt, TIntPrV> UIdVotesH;
1916    TIntFltH FracSupH;
1917    for (int e = 0; e < Len(); e++) {
1918      const TWikiElec& E = GetElec(e);
1919      for (int v = 0; v < E.Len(); v++) {
1920        UIdVotesH.AddDat(E[v].GetUId()).Add(TIntPr(e,v));
1921      }
1922      FracSupH.AddDat(e, E.GetFracSup());
1923    }
1924    UIdVotesH.SortByDat(false);
1925    THash<TInt, TMom> AllMomH, AllMomHS, AllMomHF, AdmMomH, NAdmMomH;
1926    TIntH AllCntH, AllCntHS, AllCntHF, AdmCntH, NAdmCntH;
1927    int Cnt=0, UCnt=0;
1928    for (int e = 0; e < Len(); e++) {
1929      const TWikiElec& E = GetElec(e);
1930      for (int v = 0; v < TMath::Mn(E.Len(),101); v++) {
1931        const int Vote = E.GetVote(v).GetVote()==1?1:0;
1932        AllMomH.AddDat(v).Add(Vote);
1933        AllCntH.AddDat(v) += 1;
1934        if (E.IsSucc) {
1935          AllMomHS.AddDat(v).Add(Vote);
1936          AllCntHS.AddDat(v) += 1; }
1937        else {
1938          AllMomHF.AddDat(v).Add(Vote);
1939          AllCntHF.AddDat(v) += 1;
1940        }
1941        if (UsrSplitSet.IsKey(E[v].GetUId())) {
1942          AdmMomH.AddDat(v).Add(Vote);
1943          AdmCntH.AddDat(v) += 1;
1944        } else {
1945          NAdmMomH.AddDat(v).Add(Vote);
1946          NAdmCntH.AddDat(v) += 1;
1947        }
1948      }
1949    }
1950    TGnuPlot::PlotValMomH(AllMomH, TStr::Fmt("usrVoteVsTm-%s-all", OutFNm.CStr()),
1951      TStr::Fmt("%d votes of %d users with more than %d votes. ALL ELEC.", Cnt, UCnt, MinUsrVotes),
1952      "time when user voted", "fraction of positive votes",
1953      gpsAuto, gpwLinesPoints, true, false, false, false, false, false);
1954    TGnuPlot::PlotValCntH(AllCntH, TStr::Fmt("usrVoteVsTm-%s-CNT-all", OutFNm.CStr()),
1955      TStr::Fmt("%d votes of %d users with more than %d votes. ALL ELEC.", Cnt, UCnt, MinUsrVotes),
1956      "time when user voted", "number of votes");
1957    TGnuPlot::PlotValMomH(AdmMomH, TStr::Fmt("usrVoteVsTm-%s-admin", OutFNm.CStr()),
1958      TStr::Fmt("%d votes of %d users with more than %d votes. ALL ELEC.", Cnt, UCnt, MinUsrVotes),
1959      "time when user voted", "fraction of positive votes",
1960      gpsAuto, gpwLinesPoints, true, false, false, false, false, false);
1961    TGnuPlot::PlotValCntH(AdmCntH, TStr::Fmt("usrVoteVsTm-%s-CNT-admin", OutFNm.CStr()),
1962      TStr::Fmt("%d votes of %d users with more than %d votes. ALL ELEC.", Cnt, UCnt, MinUsrVotes),
1963      "time when user voted", "number of votes");
1964    TGnuPlot::PlotValMomH(NAdmMomH, TStr::Fmt("usrVoteVsTm-%s-nonadmin", OutFNm.CStr()),
1965      TStr::Fmt("%d votes of %d users with more than %d votes. ALL ELEC.", Cnt, UCnt, MinUsrVotes),
1966      "time when user voted", "fraction of positive votes",
1967      gpsAuto, gpwLinesPoints, true, false, false, false, false, false);
1968    TGnuPlot::PlotValCntH(NAdmCntH, TStr::Fmt("usrVoteVsTm-%s-CNT-nonadmin", OutFNm.CStr()),
1969      TStr::Fmt("%d votes of %d users with more than %d votes. ALL ELEC.", Cnt, UCnt, MinUsrVotes),
1970      "time when user voted", "number of votes");
1971  }
1972  void TWikiElecBs::PlotFirstOppOutcome(const TStr& OutFNm, const int& NVotes) const {
1973    THash<TInt, TMom> FOppH, FOpp2H;
1974    TIntH FOppCntH;
1975    int NElec=0;
1976    for (int e = 0; e < Len(); e++) {
1977      const TWikiElec& E = GetElec(e);
1978      if (E.Len() < 10 || E.Len() < NVotes) { continue; } 
1979      int FirstOpp=-1, VoteSum=0;
1980      for (int v = 0; v < NVotes; v++) {
1981        if (E[v].GetVote()==-1 && FirstOpp==-1) { FirstOpp = v+1; }
1982        VoteSum += E[v].GetVote();
1983      }
1984      if (VoteSum != NVotes-2) { continue; }
1985      FOppCntH.AddDat(FirstOpp) += 1;
1986      FOppH.AddDat(FirstOpp).Add(E.IsSucc?1:0);
1987      FOpp2H.AddDat(FirstOpp).Add(E.GetFracSup());
1988      NElec++;
1989    }
1990    TGnuPlot::PlotValMomH(FOppH, "firstOpp1-"+OutFNm, TStr::Fmt("Take first %d votes of an election, where %d Sup and 1 Opp. %d such elections", NVotes, NVotes-1, NElec),
1991      "Index of the oppose vote", "Fraction of successful elections", gpsAuto, gpwLinesPoints, true, false, false, false, false, true);
1992    TGnuPlot::PlotValMomH(FOpp2H, "firstOpp2-"+OutFNm, TStr::Fmt("Take first %d votes of an election, where %d Sup and 1 Opp. %d such elections", NVotes, NVotes-1, NElec),
1993      "Index of the oppose vote", "Final fraction of support votes in the election", gpsAuto, gpwLinesPoints, true, false, false, false, true, false);
1994    TGnuPlot::PlotValCntH(FOppCntH, "firstOppCnt-"+OutFNm, TStr::Fmt("Take first %d votes of an election, where %d Sup and 1 Opp. %d such elections", NVotes, NVotes-1, NElec),
1995      "Index of the oppose vote", "Number of such elections");
1996  }
1997  void TWikiElecBs::PlotVoteTrails(const TStr& OutFNm, const int& MinUsrVotes, const bool& No01Prob) const {
1998    TIntSet AdminSet;
1999    TIntV UIdV;
2000    TVec<TFltPrV> ProbSupTmV, FracSupTmV, ProbSupFracSupV, VotesTmV, VoteIdxFracSupV, NVotesFracSupV;
2001    const int TotalVotes = GetVoteTrails(MinUsrVotes, No01Prob, UIdV, ProbSupTmV, FracSupTmV, ProbSupFracSupV, VotesTmV);
2002    GetVoteTrails2(MinUsrVotes, No01Prob, UIdV, VoteIdxFracSupV, NVotesFracSupV);
2003    GetAdminSet(AdminSet);
2004    TIntH UsrLnTy;
2005    for (int u = 0; u < UIdV.Len(); u++) { UsrLnTy.AddDat(UIdV[u], AdminSet.IsKey(UIdV[u])?2:1); }
2006    TGnuPlot GPP("voteTrailP-"+OutFNm+"-r10"); 
2007    TGnuPlot GPF("voteTrailF-"+OutFNm+"-r10");
2008    TGnuPlot GPPF("voteTrailPF-"+OutFNm+"-r10");
2009    TGnuPlot GPV("voteHist-"+OutFNm+"-r10"); 
2010    TGnuPlot GPFI("voteFIdx-"+OutFNm+"-r10");
2011    TGnuPlot GPFC("voteFCnt-"+OutFNm+"-r10");
2012    THash<TFlt, TMom> AvgAdm, AvgNAdm;
2013    bool FirstA=true, FirstNA=true;
2014    for (int u = 0; u < UIdV.Len(); u++) {
2015      const int UId = UIdV[u];
2016      TStr Tit;
2017      if (FirstA && UsrLnTy.GetDat(UId) == 2) { Tit="Admin (HIGH)"; FirstA=false; }
2018      if (FirstNA && UsrLnTy.GetDat(UId) == 1) { Tit="NonAdmin (LOW)"; FirstNA=false; }
2019      GPP.AddPlot(ProbSupTmV[u], gpwLines, Tit, TStr::Fmt("lt %d lw 1 smooth bezier", UsrLnTy.GetDat(UId)));
2020      GPF.AddPlot(FracSupTmV[u], gpwLines, Tit, TStr::Fmt("lt %d lw 1 smooth bezier", UsrLnTy.GetDat(UId)));
2021      GPV.AddPlot(VotesTmV[u], gpwLines, Tit, TStr::Fmt("lt %d lw 1 smooth bezier", UsrLnTy.GetDat(UId)));
2022      GPPF.AddPlot(ProbSupFracSupV[u], gpwLinesPoints, Tit, TStr::Fmt("lt %d lw 1 smooth bezier", UsrLnTy.GetDat(UId)));
2023      GPFI.AddPlot(VoteIdxFracSupV[u], gpwLines, Tit, TStr::Fmt("lt %d lw 1 smooth bezier", UsrLnTy.GetDat(UId)));
2024      GPFC.AddPlot(NVotesFracSupV[u], gpwLines, Tit, TStr::Fmt("lt %d lw 1 smooth bezier", UsrLnTy.GetDat(UId)));
2025      for (int i = 0; i < ProbSupFracSupV[u].Len(); i++) {
2026        if (AdminSet.IsKey(UId) || AdminSet.Empty()) { 
2027          AvgAdm.AddDat(ProbSupFracSupV[u][i].Val1).Add(ProbSupFracSupV[u][i].Val2); }
2028        else { 
2029          AvgNAdm.AddDat(ProbSupFracSupV[u][i].Val1).Add(ProbSupFracSupV[u][i].Val2); }
2030      }
2031    }
2032    TFltPrV AvgAdmV, AvgNAdmV;
2033    for (int i =0; i < AvgAdm.Len(); i++) { AvgAdm[i].Def();
2034      AvgAdmV.Add(TFltPr(AvgAdm.GetKey(i), AvgAdm[i].GetMean())); }
2035    for (int i =0; i < AvgNAdm.Len(); i++) { AvgNAdm[i].Def();
2036      AvgNAdmV.Add(TFltPr(AvgNAdm.GetKey(i), AvgNAdm[i].GetMean())); }
2037    AvgAdmV.Sort();  AvgNAdmV.Sort();
2038    GPPF.AddPlot(AvgAdmV, gpwLinesPoints, "AVG ADMIN (HIGH)", TStr::Fmt("lt %d lw 5 smooth bezier", 4));
2039    GPPF.AddPlot(AvgNAdmV, gpwLinesPoints, "AVG NON-ADMIN (LOW)", TStr::Fmt("lt %d lw 5 smooth bezier", 3));
2040    GPP.SetTitle(TStr::Fmt("%d votes of %d users with more than %d votes. ALL ELEC.", TotalVotes, UIdV.Len(), MinUsrVotes));
2041    GPP.SetXYLabel("vote index", "probability of support vote");
2042    GPP.SetYRange(0,1.01);
2043    GPF.SetTitle(TStr::Fmt("%d votes of %d users with more than %d votes. ALL ELEC.", TotalVotes, UIdV.Len(), MinUsrVotes));
2044    GPF.SetXYLabel("vote index", "fraction of support votes so far");
2045    GPF.SetYRange(0,1.01);
2046    GPPF.SetTitle(TStr::Fmt("%d votes of %d users with more than %d votes. ALL ELEC.", TotalVotes, UIdV.Len(), MinUsrVotes));
2047    GPPF.SetXYLabel("Fraction of support votes at time of vote", "Probability of voting positively");
2048    GPPF.SetYRange(0,1.01);
2049    GPPF.SavePng();
2050    GPV.SetTitle(TStr::Fmt("%d votes of %d users with more than %d votes. ALL ELEC.", TotalVotes, UIdV.Len(), MinUsrVotes));
2051    GPV.SetXYLabel("vote index", "number of votes");
2052    GPFI.SetTitle(TStr::Fmt("%d votes of %d users with more than %d votes. ALL ELEC.", TotalVotes, UIdV.Len(), MinUsrVotes));
2053    GPFI.SetXYLabel("Fraction of support votes at time of vote", "Average vote index (time) of a user voting");
2054    GPFC.SetTitle(TStr::Fmt("%d votes of %d users with more than %d votes. ALL ELEC.", TotalVotes, UIdV.Len(), MinUsrVotes));
2055    GPFC.SetXYLabel("Fraction of support votes at time of vote", "Number of times user voted at that fraction");
2056  }
2057  void TWikiElecBs::PlotVoteTrailGlobal(const TStr& OutFNm) const {
2058    THash<TInt, TMom> SuppVoteH, Set1, Set2;
2059    TIntSet UIdSet;
2060    GetAdminSet(UIdSet);
2061    for (int e = 0; e < Len(); e++) {
2062      const TWikiElec& E = GetElec(e);
2063      int nsup=0;
2064      if (E.Len()<10) { continue; }
2065      for (int v = 0; v < E.Len(); v++) {
2066        const int supFrac = v==0? 0 : int(TMath::Round(10.0*nsup/double(v)))*10;
2067        nsup += E.GetVote(v).GetVote()==1?1:0;
2068        if (v<10) { continue; } 
2069        SuppVoteH.AddDat(supFrac).Add(E.GetVote(v).GetVote()==1?1:0);
2070        if (UIdSet.IsKey(E.GetVote(v).GetUId())) { 
2071          Set1.AddDat(supFrac).Add(E.GetVote(v).GetVote()==1?1:0);
2072        } else { 
2073          Set2.AddDat(supFrac).Add(E.GetVote(v).GetVote()==1?1:0);
2074        }
2075      }
2076    }
2077    TGnuPlot::PlotValMomH(SuppVoteH, "voteTrailAll-"+OutFNm, "Global vote trail", "Fraction of support votes at time of vote", "Probability of voting positively", gpsAuto, gpwLinesPoints, true, false, false, false, false, true);
2078    TGnuPlot::PlotValMomH(Set1, "voteTrailAll1-"+OutFNm, "Global vote trail. Set1", "Fraction of support votes at time of vote", "Probability of voting positively", gpsAuto, gpwLinesPoints, true, false, false, false, false, true);
2079    TGnuPlot::PlotValMomH(Set2, "voteTrailAll2-"+OutFNm, "Global vote trail. Set2", "Fraction of support votes at time of vote", "Probability of voting positively", gpsAuto, gpwLinesPoints, true, false, false, false, false, true);
2080  }
2081  void TWikiElecBs::PlotFinalFracVoteCnt(const TStr& OutFNm, const int& MinUsrVotes, const TIntSet& UsrSplitSet) const {
2082    TIntPrV VoteUIdV; GetUsrVotes(VoteUIdV);
2083    THash<TInt, TIntH> UIdVoteCntH;
2084    TIntH FracVotesH, Set1, Set2;
2085    VoteUIdV.Sort(false);
2086    for (int i = 0; i < VoteUIdV.Len() && VoteUIdV[i].Val1>MinUsrVotes; i++) {
2087      UIdVoteCntH.AddKey(VoteUIdV[i].Val2); }
2088    for (int e = 0; e < Len(); e++) {
2089      const TWikiElec& E = GetElec(e);
2090      const int SupFrac= (int(100*E.GetFracSup())/10)*10;
2091      for (int v = 0; v < E.Len(); v++) {
2092        const int V = E[v].GetVote()==1?1:0;
2093        const int U = E[v].GetUId();
2094        FracVotesH.AddDat(SupFrac) += 1;
2095        if (UsrSplitSet.IsKey(U)) { Set1.AddDat(SupFrac) += 1; }
2096        else { Set2.AddDat(SupFrac) += 1; }
2097        if (UIdVoteCntH.IsKey(U)) { UIdVoteCntH.AddDat(U).AddDat(SupFrac) += 1; }
2098      }
2099    }
2100    TGnuPlot::PlotValCntH(FracVotesH, "voteFrac-"+OutFNm+"-all", "All users", "Final fraction of support votes", "Number of votes");
2101    TGnuPlot::PlotValCntH(Set1, "voteFrac-"+OutFNm+"-set1", "UsrSplitSet users", "Final fraction of support votes", "Number of votes");
2102    TGnuPlot::PlotValCntH(Set2, "voteFrac-"+OutFNm+"-set2", "Users no in UsrSplitSet", "Final fraction of support votes", "Number of votes");
2103    TGnuPlot GP("voteFrac-"+OutFNm);
2104    for (int u = 0; u < UIdVoteCntH.Len(); u++) {
2105      TIntPrV ValV;
2106      UIdVoteCntH[u].GetKeyDatPrV(ValV);
2107      ValV.Sort();
2108      GP.AddPlot(ValV, gpwLinesPoints, "", TStr::Fmt("lw 1 smooth bezier"));
2109    }
2110    GP.SetXYLabel("Final fraction of support votes", "Number of votes");
2111    GP.SavePng();
2112  }
2113  void TWikiElecBs::PlotConfusionMatrix(const TStr& OutFNm, const int& MinUsrVotes) const {
2114    THash<TInt, TTuple<TFlt, 4> > TupH;
2115    for (int e = 0; e < Len(); e++) {
2116      const TWikiElec& E = GetElec(e);
2117      const int R = E.IsSucc?1:0;
2118      for (int v = 0; v < E.Len(); v++) {
2119        const int V = E[v].GetVote()==1?1:0;
2120        TupH.AddDat(E[v].GetUId())[2*R+V] += 1;
2121      }
2122    }
2123    FILE *F=fopen(TStr::Fmt("confusion-%s.tab", OutFNm.CStr()).CStr(), "wt");
2124    for (int u = 0; u < TupH.Len(); u++) {
2125      const double S = TupH[u][0]+TupH[u][1]+TupH[u][2]+TupH[u][3];
2126      if (S < MinUsrVotes) { continue; }
2127      fprintf(F, "%f\t%f\t%f\t%f\n", TupH[u][0], TupH[u][1], TupH[u][2], TupH[u][3]);
2128    }
2129    fclose(F);
2130  }
2131  void TWikiElecBs::PlotSlopeHist(const TStr& OutFNm, const int& MinElecLen) const {
2132    const double BPrec = 1000;
2133    TIntH R21A, R22A, K1A, K2A;
2134    TIntH R21S, R22S, K1S, K2S;
2135    TIntH R21F, R22F, K1F, K2F;
2136    int Cnt=0;
2137    for (int e = 0; e < Len(); e++) {
2138      const TWikiElec& E = GetElec(e);
2139      if (E.Len() < MinElecLen) { continue; }
2140      TFltPrV XyV, Xy2;
2141      for (int v = 0; v < E.Len(); v++) {
2142        XyV.Add(TFltPr(v, E[v].GetVote()));
2143        Xy2.Add(TFltPr(v, E.GetFracSup(0, v+1)));
2144      }
2145      double A, B, SigA, SigB, Chi2, R2=0;
2146      TSpecFunc::LinearFit(XyV, A, B, SigA, SigB, Chi2, R2);
2147      if (R2 < -1 || _isnan(R2)) R2 = 0;
2148      K1A.AddDat(int(BPrec*B))+=1;
2149      R21A.AddDat(int(100*R2))+=1;
2150      if (E.IsSucc) {
2151        K1S.AddDat(int(BPrec*B))+=1;
2152        R21S.AddDat(int(100*R2))+=1;
2153      } else {
2154        K1F.AddDat(int(BPrec*B))+=1;
2155        R21F.AddDat(int(100*R2))+=1;
2156      }
2157      TSpecFunc::LinearFit(Xy2, A, B, SigA, SigB, Chi2, R2);
2158      if (R2 < -1 || _isnan(R2)) R2 = 0;
2159      K2A.AddDat(int(BPrec*B))+=1;
2160      R22A.AddDat(int(100*R2))+=1;
2161      if (E.IsSucc) {
2162        K2S.AddDat(int(BPrec*B))+=1;
2163        R22S.AddDat(int(100*R2))+=1;
2164      } else {
2165        K2F.AddDat(int(BPrec*B))+=1;
2166        R22F.AddDat(int(100*R2))+=1;
2167      }
2168      Cnt++;
2169    }
2170    TGnuPlot::PlotValCntH(K1A, "ALL ELEC", K1S, "SUCC ELEC", K1F, "FAIL ELEC", "slopeK1-"+OutFNm, TStr::Fmt("%d elections with >%d votes", Cnt, MinElecLen),  "slope (fit of Prob(+|t) vs t)", "count", gpsLog10Y);
2171    TGnuPlot::PlotValCntH(K2A, "ALL ELEC", K2S, "SUCC ELEC", K2F, "FAIL ELEC", "slopeK2-"+OutFNm, TStr::Fmt("%d elections with >%d votes", Cnt, MinElecLen),  "slope (fit of FracSup(1..t) vs t)", "count", gpsLog10Y);
2172    TGnuPlot::PlotValCntH(R21A, "ALL ELEC", R21S, "SUCC ELEC", R21F, "FAIL ELEC", "slopeR1-"+OutFNm, TStr::Fmt("%d elections with >%d votes", Cnt, MinElecLen),  "R2 (fit of Prob(+|t) vs t)", "count", gpsLog10Y);
2173    TGnuPlot::PlotValCntH(R22A, "ALL ELEC", R22S, "SUCC ELEC", R22F, "FAIL ELEC", "slopeR2-"+OutFNm, TStr::Fmt("%d elections with >%d votes", Cnt, MinElecLen),  "R2 (fit of FracSup(1..t) vs t)", "count", gpsLog10Y);
2174  }
2175  void TWikiElecBs::PlotBarnStarsDelta(const TStr& OutFNm) const {
2176    TBarnStars BarnStars;
2177    THash<TInt, TMom> DiffMomH;
2178    TIntH DiffCntH;
2179    for (int e = 0; e < Len(); e++) {
2180      const TWikiElec& E = GetElec(e);
2181      const TStr TargetUsr = GetUsr(E.GetUId());
2182      const int TB = BarnStars.GetBarnStars(TargetUsr, E.GetTm());
2183      for (int v = 0; v < E.Len(); v++) {
2184        if (! E[v].IsVote()) { continue; }
2185        const int DeltaStars = BarnStars.GetBarnStars(GetUsr(E[v].GetUId()), E[v].GetTm()) - TB;
2186        DiffMomH.AddDat(DeltaStars).Add(E[v].GetVote()==1?1:0);
2187        DiffCntH.AddDat(DeltaStars) += 1;
2188      }
2189    }
2190    TGnuPlot::PlotValMomH(DiffMomH, "dBarnStars-"+OutFNm, "Number of BarnStars (over ALL VOTES): "+OutFNm, "Barnstars delta (source - destination)",
2191      "Fraction of positive votes", gpsAuto, gpwLinesPoints, true, false, false, false, false);
2192    TGnuPlot::PlotValCntH(DiffCntH, "dBarnStarts2-"+OutFNm, "Number of BarnSTars (over aLL VOES): "+OutFNm, "Barnstars delta (source - destination)",
2193      "Number of such users", gpsAuto, false, gpwLinesPoints, false, false);
2194  }
2195  void TWikiElecBs::PlotAdminVotes(const TStr& OutFNm) const {
2196    TIntH APos, NAPos, ANeg, NANeg;
2197    TIntPrSet AVotes, NAVotes;
2198    for (int e = 0; e < Len(); e++) {
2199      const TIntTr V = GetElec(e).GetVotes(true);
2200      if (GetElec(e).IsSucc) {
2201        APos.AddDat(V.Val1) += 1;
2202        ANeg.AddDat(V.Val3) += 1;
2203        AVotes.AddKey(TIntPr(V.Val1, V.Val3));
2204      } else {
2205        NAPos.AddDat(V.Val1) += 1;
2206        NANeg.AddDat(V.Val3) += 1;
2207        NAVotes.AddKey(TIntPr(V.Val1, V.Val3));
2208      }
2209    }
2210    { TGnuPlot GP("adminSup-"+OutFNm, OutFNm);
2211    GP.AddPlot(APos, gpwLinesPoints, "Support votes for ADMINS");
2212    GP.AddPlot(NAPos, gpwLinesPoints, "Support votes for NON-ADMINS");
2213    GP.SetXYLabel("Number of support votes", "Number of elections");
2214    GP.SavePng(); }
2215    { TGnuPlot GP("adminOpp-"+OutFNm, OutFNm);
2216    GP.AddPlot(ANeg, gpwLinesPoints, "Oppose votes for ADMINS");
2217    GP.AddPlot(NANeg, gpwLinesPoints, "Oppose votes for NON-ADMINS");
2218    GP.SetXYLabel("Number of oppose votes", "Number of elections");
2219    GP.SavePng(); }
2220    { TGnuPlot GP("adminSupOpp-"+OutFNm, OutFNm);
2221    TIntPrV V;  AVotes.GetKeyV(V);
2222    GP.AddPlot(V, gpwPoints, "Votes for ADMINS");
2223    NAVotes.GetKeyV(V);
2224    GP.AddPlot(V, gpwPoints, "Votes for NON-ADMINS");
2225    GP.SetXYLabel("Number of support votes", "Number of oppose votes");
2226    GP.SavePng(); }
2227  }
2228  void TWikiElecBs::PlotAvgVote(const TStr& OutFNm, const int& MinVotes, const int& MaxVotes) const {
2229    TIntV ElecV;
2230    for (int e = 0; e < Len(); e++) {
2231      if (! GetElec(e).IsSucc()) {
2232        ElecV.Add(e); }
2233    }
2234    PlotAvgVote(ElecV, OutFNm, TStr::Fmt("Elections with %d--%d votes, %d elections", MinVotes, MaxVotes, ElecV.Len()));
2235  }
2236  void TWikiElecBs::PlotAvgVote(const TIntV& ElecIdV, const TStr& OutFNm, const TStr& Desc) const {
2237    THash<TInt, TMom> MomH;
2238    THash<TInt, TMom> Mom2H;
2239    TFltV AvgVoteV;
2240    for (int i = 0; i < ElecIdV.Len(); i++) {
2241      GetElec(ElecIdV[i]).GetAvgVoteOt(AvgVoteV, true);
2242      for (int v = 0; v < AvgVoteV.Len(); v++) {
2243        MomH.AddDat(v+1).Add(AvgVoteV[v]); }
2244      const TWikiElec& E = GetElec(ElecIdV[i]);
2245      for (int v = 0; v < E.Len(); v++) {
2246        Mom2H.AddDat(v).Add(E.GetVote(v).GetVote()==1?1:0);
2247      }
2248    }
2249    TGnuPlot::PlotValMomH(MomH, "voteAvg-"+OutFNm, TStr::Fmt("%s. %d elections", Desc.CStr(), ElecIdV.Len()),
2250      "n (vote index, time)", "Running average of positive votes", gpsAuto, gpwLinesPoints, true, false, false, false, false);
2251    TGnuPlot::PlotValMomH(Mom2H, "voteAvg2-"+OutFNm, TStr::Fmt("%s. %d elections", Desc.CStr(), ElecIdV.Len()),
2252      "n (vote index, time)", "Probability of positive vote", gpsAuto, gpwLinesPoints, true, false, false, false, false);
2253  }
2254  void TWikiElecBs::PlotAvgVoteDev(const TIntV& ElecIdV, const TStr& OutFNm, const TStr& Desc) const {
2255    THash<TInt, TMom> MomH;
2256    TFltV AvgVoteV;
2257    for (int i = 0; i < ElecIdV.Len(); i++) {
2258      GetElec(ElecIdV[i]).GetAvgVoteDevOt(AvgVoteV, true);
2259      for (int v = 0; v < AvgVoteV.Len(); v++) {
2260        MomH.AddDat(v+1).Add(AvgVoteV[v]); }
2261    }
2262    TGnuPlot::PlotValMomH(MomH, "voteDev-"+OutFNm, TStr::Fmt("%s. %d elections", Desc.CStr(), ElecIdV.Len()),
2263      "n (vote index, time)", "Deviation of the running average", gpsAuto, gpwLinesPoints, true, false, false, false, false);
2264    MomH.SortByKey();
2265    for (int v = 0; v < MomH.Len(); v+=10) {
2266      printf("  %d\t%g\n", v, MomH[v].GetWgt());
2267    }
2268  }
2269  void TWikiElecBs::PlotAvgSupFrac(const TIntV& ElecIdV, const TStr& OutFNm, const TStr& Desc) const {
2270    THash<TInt, TMom> MomH;
2271    TFltV AvgVoteV;
2272    for (int i = 0; i < ElecIdV.Len(); i++) {
2273      TWikiVoteV VoteV;
2274      GetElec(ElecIdV[i]).GetVotesOt(VoteV);
2275      for (int v = 0; v < VoteV.Len(); v++) {
2276        MomH.AddDat(v+1).Add(VoteV[v].GetVote()==1?1:0); }
2277    }
2278    TGnuPlot::PlotValMomH(MomH, "voteFrac-"+OutFNm, TStr::Fmt("%s. %d elections", Desc.CStr(), ElecIdV.Len()),
2279      "T (vote index, time)", "Fraction of all votes casted at time T that were supporting", gpsAuto, gpwLinesPoints, true, false, false, false, false);
2280  }
2281  void TWikiElecBs::PlotOutcomes(const TStr& OutFNm) const {
2282    TWikiVoteV VoteV;
2283    TIntV UIdV;  GetEIdByVotes(UIdV);
2284    TGnuPlot GP("votes-otime3-0"), GP2("votes-otime4-0");
2285    for (int u = 0; u < 100; u++) {
2286      const TWikiElec& E = GetElec(UIdV[u]);
2287      E.GetVotesOt(VoteV, true);
2288      const int b = VoteV[0].GetTm().GetAbsSecs();
2289      TFltPrV FracV, FracV2;
2290      int pos=0, neg=0;
2291      for (int v = 0; v < VoteV.Len(); v++) {
2292        if (VoteV[v].GetVote()==1) { pos++; }
2293        else if (VoteV[v].GetVote()==-1) { neg++; } else { continue; }
2294        FracV.Add(TFltPr(v, pos/double(pos+neg)));
2295        FracV2.Add(TFltPr(v/double(VoteV.Len()), pos/double(pos+neg)));
2296      }
2297      GP.AddPlot(FracV, gpwLines);
2298      GP2.AddPlot(FracV2, gpwLines);
2299      if ((u+1) % 10 == 0) {
2300        GP.SavePng();
2301        GP2.SavePng();
2302        GP = TGnuPlot(TStr::Fmt("votes-otime3-%d", u/10));
2303        GP2 = TGnuPlot(TStr::Fmt("votes-otime4-%d", u/10));
2304      }
2305    }
2306    GP.SavePng();
2307    GP2.SavePng();
2308  }
2309  void TWikiElecBs::PlotSupFracVsElecLen(const TStr& OutFNm) const {
2310    THash<TInt, TMom> ElecMom;
2311    THash<TInt, TMom> ElecMom5;
2312    THash<TInt, TMom> ElecMom10;
2313    for (int e = 0; e < Len(); e++) {
2314      ElecMom.AddDat(GetElec(e).Len()).Add(GetElec(e).GetFracSup());
2315      ElecMom5.AddDat(5*(GetElec(e).Len()/5)).Add(GetElec(e).GetFracSup());
2316      ElecMom10.AddDat(10*(GetElec(e).Len()/10)).Add(GetElec(e).GetFracSup());
2317    }
2318    TGnuPlot::PlotValMomH(ElecMom, "fracSupLen-"+OutFNm, "Bucket size 1", "Number of votes in the election", "Final fraction of support votes");
2319    TGnuPlot::PlotValMomH(ElecMom5, "fracSupLen-"+OutFNm+"5", "Bucket size 5", "Number of votes in the election", "Final fraction of support votes");
2320    TGnuPlot::PlotValMomH(ElecMom10, "fracSupLen-"+OutFNm+"10", "Bucket size 10", "Number of votes in the election", "Final fraction of support votes");
2321  }
2322  void TWikiElecBs::PlotSupOpp(const TStr& OutFNm) const {
2323  }
2324  void TWikiElecBs::PlotVoteDistr(const TStr& OutFNm) const {
2325    TWikiVoteV VoteV;
2326    TIntV UIdV;  GetEIdByVotes(UIdV);
2327    TVec<TMom> SupV, OppV;
2328    THash<TInt, TIntH> PosH, NegH;
2329    for (int u = 0; u < 2000; u++) {
2330      const TWikiElec& E = GetElec(UIdV[u]);
2331      const TIntTr PON = E.GetVotes(true);
2332      if ((PON.Val1+2*PON.Val2) < 50)  {
2333        PosH.AddDat((PON.Val1+PON.Val2)/10).AddDat((PON.Val1))++;
2334        NegH.AddDat((PON.Val1+PON.Val2)/10).AddDat((PON.Val1-PON.Val2))++;
2335        printf("%d ", PON.Val1+PON.Val2);
2336      }
2337    }
2338    PosH.SortByKey(); NegH.SortByKey();
2339    for (int i = 0; i < PosH.Len(); i++) {
2340      TGnuPlot GP(TStr::Fmt("voteX-distr%02d", PosH.GetKey(i)));
2341      TFltPrV PrV1, PrV2;
2342      IAssert(PosH.GetKey(i) == NegH.GetKey(i));
2343      TIntH& CntH1 = PosH[i];  CntH1.SortByKey();
2344      TIntH& CntH2 = NegH[i];  CntH2.SortByKey();
2345      for (int j = 0; j < CntH1.Len(); j++) {
2346        PrV1.Add(TFltPr(CntH1.GetKey(j).Val, CntH1[j].Val)); }
2347      for (int j = 0; j < CntH2.Len(); j++) {
2348        PrV2.Add(TFltPr(CntH2.GetKey(j).Val, CntH2[j].Val)); }
2349      GP.AddPlot(PrV1, gpwLinesPoints, "Pos");
2350      GP.AddCmd("set yzeroaxis lt -1");
2351      GP.SavePng();
2352    }
2353  }
2354  PSignNet TWikiElecBs::GetAdminUsrVoteNet() const {
2355    TIntV UIdV;
2356    GetElecAdminUsrV(UIdV);
2357    return GetVoteNet(UIdV);
2358  }
2359  PSignNet TWikiElecBs::GetElecUsrVoteNet() const {
2360    TIntV UIdV;
2361    GetElecUsrV(UIdV);
2362    return GetVoteNet(UIdV);
2363  }
2364  PSignNet TWikiElecBs::GetAllUsrVoteNet() const {
2365    TIntV UIdV;
2366    GetUsrV(UIdV);
2367    return GetVoteNet(UIdV);
2368  }
2369  PSignNet TWikiElecBs::GetVoteNet(const TIntV& UsrIdV) const {
2370    TIntSet UsrSet;
2371    for (int u = 0; u < UsrIdV.Len(); u++) {
2372      UsrSet.AddKey(UsrIdV[u]);
2373    }
2374    PSignNet Net = TSignNet::New();
2375    THash<TIntPr, TStr> EdgeElecH;
2376    for (int e = 0; e < Len(); e++) {
2377      const TWikiElec& FullE = GetElec(e);
2378      const int Dst = FullE.GetUId();
2379      if (! UsrSet.IsKey(Dst)) { continue; }
2380      TWikiElec NewElec;
2381      FullE.GetOnlyVotes(NewElec, true);
2382      for (int v = 0; v < NewElec.Len(); v++) {
2383        const int Src = NewElec[v].GetUId();
2384        if (! UsrSet.IsKey(Src)) { continue; }
2385        if (Src == Dst) { continue; }
2386        if (! Net->IsNode(Dst)) {
2387          Net->AddNode(Dst); }
2388        if (! Net->IsNode(Src)) {
2389          Net->AddNode(Src); }
2390        if (Net->IsEdge(Src, Dst)) { 
2391        }
2392        Net->AddEdge(Src, Dst, NewElec[v].GetVote());
2393      }
2394    }
2395    return Net;
2396  }
2397  void TWikiElecBs::GetOnlyVoteElecBs(TWikiElecBs& NewElecBs, const bool& OnlySupOpp) const {
2398    NewElecBs.UsrH = UsrH;
2399    NewElecBs.ElecV = ElecV;
2400    for (int e = 0; e < ElecV.Len(); e++) {
2401      ElecV[e].GetOnlyVotes(NewElecBs.ElecV[e], OnlySupOpp);  
2402    }
2403  }
2404  bool TWikiElecBs::AddElecRes(const TWikiMetaHist& WMH, const THash<TStr, TStr>& UsrMapH, const THash<TStr, TWikiElecBs::TElecSum>& ElecSumH) {
2405    if (! WMH.Title.IsPrefix("Wikipedia:Requests_for_adminship/")) { return false; }
2406    const int b = WMH.Title.SearchCh('/')+1;
2407    const int e = WMH.Title.SearchCh('/', b+1)-1;
2408    TChA RfaTitle = WMH.Title.GetSubStr(b, e>b?e:TInt::Mx);
2409    TWikiElec WikiElec(-1, WMH.RevTm); 
2410    ParseVotes(WMH, UsrMapH, WikiElec);
2411    WikiElec.SetIsVoteFlag();
2412    WikiElec.RfaTitle = RfaTitle;
2413    TIntTr V = WikiElec.GetVotes();
2414    if (RfaTitle.IsSuffix("_Couriano")) { RfaTitle = "Couriano"; } 
2415    if (ElecSumH.IsKey(RfaTitle)) {
2416      const TElecSum& ElSum = ElecSumH.GetDat(RfaTitle);
2417      WikiElec.IsSucc = true;
2418      TChA U = ElSum.Usr;
2419      if (UsrMapH.IsKey(U)) { U = UsrMapH.GetDat(U); }
2420      WikiElec.UsrId = AddUsr(ElSum.Usr.CStr()); 
2421      if (! ElSum.Bureaucrat.Empty()) {
2422        TChA U = ElSum.Bureaucrat;
2423        if (UsrMapH.IsKey(U)) { U = UsrMapH.GetDat(U); }
2424        WikiElec.BurUId = AddUsr(U);
2425      }
2426      if (! ElSum.NominatedBy.Empty()) {
2427        TChA U = ElSum.NominatedBy;
2428        if (UsrMapH.IsKey(U)) { U = UsrMapH.GetDat(U); }
2429        WikiElec.NomUId = AddUsr(U);
2430      }
2431      if (abs(V.Val1-ElSum.Sup) > 0) { printf("SUP VOTES: %d != %d\n", V.Val1, ElSum.Sup);  }
2432      if (abs(V.Val2-ElSum.Neu) > 0) { printf("NEU VOTES: %d != %d\n", V.Val2, ElSum.Neu);  }
2433      if (abs(V.Val3-ElSum.Opp) > 0) { printf("OPP VOTES: %d != %d\n", V.Val3, ElSum.Opp);  }
2434    } else {
2435      TChA U = RfaTitle.ToLc(); 
2436      if (UsrMapH.IsKey(U)) { U = UsrMapH.GetDat(U); }
2437      WikiElec.UsrId = AddUsr(U); 
2438    }
2439    if (V.Val1+V.Val2+V.Val3 == 0) {
2440      printf("no votes\n"); return false;
2441    }
2442    ElecV.Add(WikiElec);
2443    return true;
2444  }
2445  int TWikiElecBs::GetWikiTxtLen(char* LineStr) {
2446    int Len=0;
2447    for (char *ch=LineStr+1; *ch != NULL; ch++) {
2448      if (TCh::IsAlNum(*ch)) { Len++; }
2449      if (*ch=='[' && *(ch-1)=='[') {
2450        while (*ch && *ch!=']' && *(ch-1)!=']') { ch++; }
2451      }
2452    }
2453    return Len;
2454  }
2455  void TWikiElecBs::LoadElecSumTxt(const TStr& FNm, THash<TStr, TWikiElecBs::TElecSum>& ElecSumH) {
2456    ElecSumH.Clr();
2457    for (TSsParser SS(FNm, ssfTabSep); SS.Next(); ) {
2458      IAssert(SS.Len() == 9);
2459      TElecSum& S = ElecSumH.AddDat(SS[1]); 
2460      S.Usr = SS[0];          S.Usr.ToLc();
2461      S.RfA = SS[1];
2462      S.Sup = SS.GetInt(2);
2463      S.Opp = SS.GetInt(3);
2464      S.Neu = SS.GetInt(4);
2465      S.NominatedBy = SS[7];  S.NominatedBy.ToLc();
2466      S.Bureaucrat = SS[8];   S.Bureaucrat.ToLc();
2467    }
2468  }
2469  bool EndOfSection(char* Line, const TStr& WhatStr) {
2470    if (Line[0]=='#' || Line[0]==':') { return false; }
2471    TChA LnStr(Line);
2472    LnStr.ToTrunc();
2473    if (LnStr.SearchStr(TStr::Fmt("'''%s'''", WhatStr.CStr()))!=-1) { return true; }
2474    if (LnStr.SearchStr(TStr::Fmt("====%s====", WhatStr.CStr()))!=-1) { return true; }
2475    if (LnStr.SearchStr(TStr::Fmt("==== %s ====", WhatStr.CStr()))!=-1) { return true; }
2476    if (LnStr.SearchStr(TStr::Fmt("'''%s:'''", WhatStr.CStr()))!=-1) { return true; }
2477    if (LnStr.SearchStr(TStr::Fmt("====%s:====", WhatStr.CStr()))!=-1) { return true; }
2478    if (LnStr.IsPrefix(TStr::Fmt("; %s", WhatStr.CStr()))) { return true; }
2479    if (LnStr.IsPrefix(TStr::Fmt(";%s", WhatStr.CStr()))) { return true; }
2480    if (LnStr==TStr::Fmt("%s", WhatStr.CStr())) { return true; }
2481    if (LnStr==TStr::Fmt("%s:", WhatStr.CStr())) { return true; }
2482    return false;
2483  }
2484  void TWikiElecBs::ParseVotes(const TWikiMetaHist& WMH, const THash<TStr, TStr>& UsrMapH, TWikiElec& WikiElec) {
2485    TVec<char *> LineV;  TChA Tmp = WMH.Text;
2486    Tmp.ToLc();
2487    TStrUtil::SplitLines(Tmp, LineV);
2488    int l = 0, goodVote=0;
2489    int NSup=0, NOpp=0, NNeu=0;
2490    for (; l < LineV.Len(); l++) {
2491      if (EndOfSection(LineV[l], "support")) { l++; break; }
2492      char *vote=strstr(LineV[l], ") end");
2493      if (vote == NULL) { vote=strstr(LineV[l], ") end"); }
2494      if (vote != NULL && TCh::IsNum(*(vote-1)) && NSup==-1) {
2495        *vote=0;  vote--;
2496        while(TCh::IsNum(*vote)) { vote--; }
2497        if (*vote == '/') {
2498          NNeu = atoi(vote+1);  *vote=0;  vote--;
2499          while(TCh::IsNum(*vote)) { vote--; }
2500          if (*vote == '/') {
2501            NOpp = atoi(vote+1);  *vote=0;  vote--;
2502            while(TCh::IsNum(*vote)) { vote--; }
2503            if (*vote == '(') { NSup = atoi(vote+1); } }
2504      } }/&bsol;*/
2505    }
2506    TChA Usr;  TSecTm Tm;  int Indent;
2507    for (; l < LineV.Len(); l++) {
2508      if(GetUsrTm(LineV[l], Usr, Tm, Indent)) {  goodVote++;
2509      if (UsrMapH.IsKey(Usr)) { Usr = UsrMapH.GetDat(Usr);  }
2510        WikiElec.VoteV.Add(TWikiVote(AddUsr(Usr), +1, Indent, GetWikiTxtLen(LineV[l]), Tm));
2511      }
2512      if (EndOfSection(LineV[l], "oppose")) { l++; break; }
2513    }
2514    for (; l < LineV.Len(); l++) {
2515      if(GetUsrTm(LineV[l], Usr, Tm, Indent)) {  goodVote++;
2516        if (UsrMapH.IsKey(Usr)) { Usr = UsrMapH.GetDat(Usr); }
2517        WikiElec.VoteV.Add(TWikiVote(AddUsr(Usr), -1, Indent, GetWikiTxtLen(LineV[l]), Tm));
2518      }
2519      if (EndOfSection(LineV[l], "neutral")) { l++; break; }
2520    }
2521    for (; l < LineV.Len(); l++) {
2522      if(GetUsrTm(LineV[l], Usr, Tm, Indent)) {  goodVote++;
2523        if (UsrMapH.IsKey(Usr)) { Usr = UsrMapH.GetDat(Usr); printf("u"); }
2524        WikiElec.VoteV.Add(TWikiVote(AddUsr(Usr), 0, Indent, GetWikiTxtLen(LineV[l]), Tm));
2525      }
2526      if (LineV[l][0]!='#' && (strstr(LineV[l], "'''comments")!=NULL || strstr(LineV[l], "'''no vote")!=NULL
2527        || strstr(LineV[l], "====")!=NULL || strstr(LineV[l], ";comments")!=NULL || strstr(LineV[l], "; comments")!=NULL ||
2528        strcmp(LineV[l],"comment")==0 || strcmp(LineV[l],"comments")==0)) { l++; break; }
2529    }
2530    const TIntTr SON = WikiElec.GetVotes(true);
2531    if (SON.Val1+SON.Val2+SON.Val3 > 100 && (SON.Val1==0 || SON.Val2==0)) {
2532    }
2533  }
2534  void TWikiElecBs::SetUserIdFromRfa() {
2535    THash<TChA, TChA> RfaUsrMapH;
2536    RfaUsrMapH.AddDat("White_Cat_(01)", "White_Cat");
2537    RfaUsrMapH.AddDat("White_Cat_(02)", "White_Cat");
2538    RfaUsrMapH.AddDat("White_Cat_(03)", "White_Cat");
2539    RfaUsrMapH.AddDat("White_Cat_(04)", "White_Cat");
2540    RfaUsrMapH.AddDat("Computerjoe_(4)", "Computerjoe");
2541    RfaUsrMapH.AddDat("Purplefeltangel2", "Purplefeltangel");
2542    RfaUsrMapH.AddDat("Haham_Hanuka_(3)", "Haham_Hanuka");
2543    RfaUsrMapH.AddDat("dbertman_(archive)", "dbertman");
2544    RfaUsrMapH.AddDat("Agentsoo_(archive)", "Agentsoo");
2545    RfaUsrMapH.AddDat("Guanaco3", "Guanaco");
2546    RfaUsrMapH.AddDat("Brendenhull2", "Brendenhull");
2547    RfaUsrMapH.AddDat("Xerocs2", "Xerocs");
2548    RfaUsrMapH.AddDat("Wikiwoohoo2", "Wikiwoohoo");
2549    RfaUsrMapH.AddDat("Folajimi2", "Folajimi");
2550    RfaUsrMapH.AddDat("FuriousFreddy_r1", "FuriousFreddy");
2551    RfaUsrMapH.AddDat("General_Eisenhower3", "General_Eisenhower");
2552    RfaUsrMapH.AddDat("HolyRomanEmperor2", "HolyRomanEmperor");
2553    RfaUsrMapH.AddDat("HolyRomanEmperor3", "HolyRomanEmperor");
2554    RfaUsrMapH.AddDat("HolyRomanEmperor3a", "HolyRomanEmperor");
2555    RfaUsrMapH.AddDat("Jet123_(2nd_nom)", "Jet123");
2556    RfaUsrMapH.AddDat("Natl1_(2nd_nom)", "Natl1");
2557    RfaUsrMapH.AddDat("NickCatal2", "NickCatal");
2558    RfaUsrMapH.AddDat("P.B._Pilhet_2nd_Nomination", "P.B._Pilhet");
2559    RfaUsrMapH.AddDat("Patchouli2", "Patchouli");
2560    RfaUsrMapH.AddDat("Patchouli3", "Patchouli");
2561    RfaUsrMapH.AddDat("The_Wookieepedian2", "The_Wookieepedian");
2562    RfaUsrMapH.AddDat("Son_of_a_Peach_II", "Son_of_a_Peach");
2563    RfaUsrMapH.AddDat("SVera1NY_(second_nomination)", "SVera1NY");
2564    RfaUsrMapH.AddDat("Tellyaddict2", "Tellyaddict");
2565    RfaUsrMapH.AddDat("Tenebrae2", "Tenebrae");
2566    RfaUsrMapH.AddDat("Poccil2", "Poccil");
2567    RfaUsrMapH.AddDat("Purplefeltangel2", "Purplefeltangel");
2568    RfaUsrMapH.AddDat("Ramsquire2", "Ramsquire");
2569    RfaUsrMapH.AddDat("ScienceApologist2", "ScienceApologist");
2570    RfaUsrMapH.AddDat("Jor2", "Jor");
2571    for (int e = 0; e < Len(); e++) {
2572      TWikiElec& E = GetElec(e);
2573      if (E.IsSucc()) { continue; }
2574      TChA Rfa = E.RfaTitle;
2575      const int l = Rfa.Len();
2576      TChA User;
2577      if (l>2 && Rfa[l-2]=='_' && TCh::IsNum(Rfa[l-1])) { User = Rfa.GetSubStr(0, l-3); } 
2578      else if (Rfa.IsSuffix(".08") || Rfa.IsSuffix(".09") || Rfa.IsSuffix(".10")) { User = Rfa.GetSubStr(0, l-4); }
2579      else if (Rfa.IsSuffix("_(renomination)")) { User = Rfa.GetSubStr(0, l-(int)strlen("_(renomination)")-1); }
2580      else if (Rfa.IsSuffix("_(2)")) { User = Rfa.GetSubStr(0, l-5); }
2581      else if (Rfa.IsSuffix("_(2nd)")) { User = Rfa.GetSubStr(0, l-7); }
2582      else if (Rfa.IsSuffix("_(2nd_nomination)")) { User = Rfa.GetSubStr(0, l-(int)strlen("_(2nd_nomination)")-1); }
2583      else if (RfaUsrMapH.IsKey(Rfa)) { User = RfaUsrMapH.GetDat(Rfa); }
2584      else { continue; }
2585      User.ToLc();
2586      printf("%20s\t->\t%s\n", Rfa.CStr(), User.CStr());
2587      E.UsrId = AddUsr(User.CStr());
2588    }
2589  }
2590  void TWikiElecBs::Dump() const {
2591    int v=0, Sup=0, Opp=0, Neu=0;
2592    int VSup=0, VOpp=0, VNeu=0;
2593    for (int e=0; e< Len(); e++) {
2594      v += GetElec(e).Len();
2595      TIntTr Votes = GetElec(e).GetVotes(false);
2596      Sup += Votes.Val1;  Neu += Votes.Val2;  Opp += Votes.Val3;
2597      Votes = GetElec(e).GetVotes(true);
2598      VSup += Votes.Val1;  VNeu += Votes.Val2;  VOpp += Votes.Val3;
2599    }
2600    printf("%5d users, %3d elections, %d all votes (%d/%d/%d)\n", UsrH.Len(), Len(), v, Sup, Opp, Neu);
2601    printf("                             %d all votes (%d/%d/%d)\n", VSup+VOpp+VNeu, VSup, VOpp, VNeu);
2602    TIntSet AdminSet, NAdminSet;
2603    TMom SupA, OppA, NeuA, SupNA, OppNA, NeuNA, ASupFrac, NASupFrac;
2604    TFltIntPrV AElecV, NAElecV;
2605    int nsucc=0;
2606    for (int e = 0; e < Len(); e++) {
2607      const TWikiElec& E = GetElec(e);
2608      const TIntTr V = E.GetVotes(true);
2609      double SupFrac = V.Val1+V.Val3>0 ? V.Val1/double(V.Val1+V.Val3) : 0;
2610      if (V.Val1+V.Val3 == 0) { continue; }
2611      if (E.IsSucc) {
2612        AdminSet.AddKey(E.UsrId);
2613        SupA.Add(V.Val1());  NeuA.Add(V.Val2());  OppA.Add(V.Val3());
2614        AElecV.Add(TFltIntPr(SupFrac, e));
2615        ASupFrac.Add(SupFrac);
2616        nsucc++;
2617      } else {
2618        NAdminSet.AddKey(E.UsrId());
2619        SupNA.Add(V.Val1());  NeuNA.Add(V.Val2());  OppNA.Add(V.Val3());
2620        NAElecV.Add(TFltIntPr(SupFrac, e));
2621        NASupFrac.Add(SupFrac);
2622      }
2623    }
2624    printf("succ elecs %d\n", nsucc);
2625    SupA.Def(); OppA.Def(); NeuA.Def(); SupNA.Def(); OppNA.Def(); NeuNA.Def();
2626    ASupFrac.Def();  NASupFrac.Def();
2627    printf("succ elecs vs. failed elecs: %d admins. Votes:\n", AdminSet.Len());
2628    printf("  sup: %.1f : %.1f\n", SupA.GetMean(), SupNA.GetMean());
2629    printf("  neu:  %.1f : %.1f\n", NeuA.GetMean(), NeuNA.GetMean());
2630    printf("  fail: %.1f : %.1f\n", OppA.GetMean(), OppNA.GetMean());
2631    printf("  support fraction: %f : %f\n", ASupFrac.GetMean(), NASupFrac.GetMean());
2632    TInt ASup, AOpp, NASup, NAOpp, OSup, OOpp, AllSup, AllOpp; 
2633    TInt AEl, NAEl, OEl;
2634    TIntPrV TmV;
2635    for (int e = 0; e < Len(); e++) {
2636      const TWikiElec& E = GetElec(e);
2637      TWikiElec NewElec;  E.GetOnlyVotes(NewElec, true);
2638      bool IsA=false, IsNA=false, IsO=false;
2639      TmV.Add(TIntPr(E.GetTm().GetAbsSecs(), e));
2640      for (int v = 0; v < NewElec.Len(); v++) {
2641        const int vote = NewElec[v].GetVote();
2642        const int uid = NewElec[v].GetUId();
2643        if (AdminSet.IsKey(uid)) {
2644          if (vote == 1) { ASup++; } else { AOpp++; }
2645          IsA=true; }
2646        else if (NAdminSet.IsKey(uid)) {
2647          if (vote == 1) { NASup++; } else { NAOpp++; }
2648          IsNA=true; }
2649        else {
2650          if (vote == 1) { OSup++; } else { OOpp++; }
2651          IsO=true; }
2652        if (vote == 1) { AllSup++; }
2653        if (vote == -1) { AllOpp++; }
2654      }
2655      if (IsA) { AEl++; }
2656      if (IsNA) { NAEl++; }
2657      if (IsO) { OEl++; }
2658    }
2659    TmV.Sort();
2660    printf("elections from:\t%s\n\t%s\n", TSecTm(TmV[0].Val1()).GetStr().CStr(), TSecTm(TmV.Last().Val1()).GetStr().CStr());
2661    for (int i = 0; i <100; i++) { printf("%d\n", TmV[i].Val2); }
2662    for (int i = TmV.Len()-100; i <TmV.Len(); i++) { printf("%d\n", TmV[i].Val2); }
2663    TIntV UsrV; GetUsrV(UsrV);
2664    printf("voters: %d\n", UsrV.Len());
2665    printf("votes by:\n");
2666    printf("  all:         %5d : %5d = %f    elecs: %d    users: %d\n", AllSup, AllOpp, AllSup/double(AllSup+AllOpp), Len(), UsrV.Len());
2667    printf("  admins:      %5d : %5d = %f    elecs: %d    users: %d\n", ASup, AOpp, ASup/double(ASup+AOpp), AEl, AdminSet.Len());
2668    printf("  non-admins:  %5d : %5d = %f    elecs: %d    users: %d\n", NASup, NAOpp, NASup/double(NASup+NAOpp), NAEl, NAdminSet.Len());
2669    printf("  others:      %5d : %5d = %f    elecs: %d    users: %d\n\n", OSup, OOpp, OSup/double(OSup+OOpp), OEl, UsrH.Len()-AdminSet.Len()-NAdminSet.Len());
2670  }
2671  void TWikiElecBs::SaveElecUserVotes(const TStr& OutFNm) const {
2672    TIntSet USet;
2673    for (int e = 0; e < Len(); e++) {
2674      const TWikiElec& E = GetElec(e);
2675      if (E.Len() < 10) { continue; }
2676      for (int v = 0; v < E.Len(); v++) {
2677        USet.AddKey(E[v].GetUId()); }
2678    }
2679    FILE *F = fopen(OutFNm.CStr(), "wt");
2680    fprintf(F, "IsSucc");
2681    for (int u = 0; u < USet.Len(); u++) {
2682      fprintf(F, "\tu%d", USet[u]);
2683    }
2684    fprintf(F, "\n");
2685    for (int e = 0; e < Len(); e++) {
2686      const TWikiElec& E = GetElec(e);
2687      if (E.Len() < 10) { continue; }
2688      TIntSet Voters;
2689      for (int v = 0; v < E.Len(); v++) {
2690        Voters.AddKey(E[v].GetUId()); }
2691      fprintf(F, "%d", E.IsSucc?1:0);
2692      for (int u = 0; u < USet.Len(); u++) {
2693        if (Voters.IsKey(USet[u])) { fprintf(F, "\t1"); }
2694        else { fprintf(F, "\t0"); }
2695      }
2696      fprintf(F, "\n");
2697    }
2698    fclose(F);
2699  }
2700  void TWikiElecBs::SaveTxt(const TStr& OutFNm) {
2701    SortVotesByTm();
2702    FILE *F = fopen(OutFNm.CStr(), "wt");
2703    fprintf(F, "# Wikipedia elections (http:&bsol;&bsol;cs.stanford.edu/people/jure/pubs/triads-chi10.pdf). Data format:\n");
2704    fprintf(F, "#   E: is election succesful (1) or not (0)\n");
2705    fprintf(F, "#   T: time election was closed\n");
2706    fprintf(F, "#   U: user id (and username) of editor that is being considered for promotion\n");
2707    fprintf(F, "#   N: user id (and username) of the nominator\n");
2708    fprintf(F, "#   V: <vote(1:support, 0:neutral, -1:oppose)> <user_id> <time> <username>\n");
2709    for (int e = 0; e < Len(); e++) {
2710      const TWikiElec& E = GetElec(e);
2711      fprintf(F, "E\t%d\n", E.IsSucc?1:0);
2712      fprintf(F, "T\t%s\n", E.ElecTm.GetYmdTmStr().CStr());
2713      fprintf(F, "U\t%d\t%s\n", E.UsrId, GetUsr(E.UsrId));
2714      fprintf(F, "N\t%d\t%s\n", E.NomUId, E.NomUId==-1?"UNKNOWN":GetUsr(E.NomUId));
2715      for (int v = 0; v < E.Len(); v++) {
2716        if (! E[v].IsVote()) { continue; }
2717        fprintf(F, "V\t%d\t%d\t%s\t%s\n", E[v].GetVote(), E[v].GetUId(), E[v].GetTm().GetYmdTmStr().CStr(), GetUsr(E[v].GetUId()));
2718      }
2719      fprintf(F, "\n");
2720    }
2721    fclose(F);
2722  }
2723  void TWikiElecBs::SaveOnlyVotes() {
2724    TWikiElecBs NewElBs;
2725    GetOnlyVoteElecBs(NewElBs, true);
2726    NewElBs.SortVotesByTm();
2727    TStrSet RfaSet;
2728    for (int e = 0; e < NewElBs.Len(); e++) {
2729      TWikiElec& E = NewElBs.GetElec(e);
2730      if (RfaSet.IsKey(E.RfaTitle)) {
2731        for (int i = 2; ; i++) {
2732          TStr NewRfa = TStr::Fmt("%s_%d", E.RfaTitle.CStr(), i);
2733          if (! RfaSet.IsKey(NewRfa)) {
2734            printf("  %s --> %s\n", E.RfaTitle.CStr(), NewRfa.CStr());
2735            E.RfaTitle= NewRfa;
2736            break;
2737          }
2738        }
2739      }
2740      RfaSet.AddKey(E.RfaTitle);
2741    }
2742    NewElBs.Save(TZipOut("wikiElec-Votes.ElecBs3.rar"));
2743  }
2744  bool TWikiElecBs::GetUsrTm(char* LineStr, TChA& Usr, TSecTm& Tm, int& Indent) {
2745    TChA TmpLine=LineStr;
2746    TChA SearchStr = "[[user:";
2747    char *UsrId = NULL;
2748    for (char *next=LineStr; next=strstr(next, SearchStr.CStr()); ) {
2749      UsrId=next; next++; }
2750    if (UsrId == NULL) {
2751      SearchStr = "[[user talk:";
2752      for (char *next=LineStr; next=strstr(next, SearchStr.CStr()); ) {
2753        UsrId=next; next++; }
2754    }
2755    if (UsrId == NULL) {
2756      SearchStr = "[[user_talk:";
2757      for (char *next=LineStr; next=strstr(next, SearchStr.CStr()); ) {
2758        UsrId=next; next++; }
2759    }
2760    if (UsrId == NULL) {
2761      return false;
2762    }
2763    UsrId += SearchStr.Len();
2764    while (*UsrId && TCh::IsWs(*UsrId)) { UsrId++; }
2765    char *c = UsrId;
2766    while (*c && *c!='|' && *c!=']' && *c!='/' && *c!='#' && *c!=' ' && *c!='&') {
2767      if (*c==' ') { *c='_'; }
2768      c++;
2769    }
2770    *c = 0; c++;
2771    Usr = UsrId;  Usr.ToLc();
2772    char *utc = strstr(c, " (utc)");
2773    if (utc == NULL) { return false; }
2774    while (strstr(utc+1, "(utc)")!=NULL) { utc = strstr(utc+1, "(utc)"); }
2775    *utc = 0; utc--;
2776    int FldCnt=0;
2777    char *e = utc;
2778    while (e>c && (*e==' ' || *e=='-' || *e==',')) { e--; }
2779    while(e>c) {
2780      while (e>c && ! (*e==' ' || *e=='-' || *e==',')) { e--; }
2781      if (++FldCnt==4) { break; }
2782      while (e>c && (*e==' ' || *e=='-' || *e==',')) { e--; }
2783    }
2784    e += 1;
2785    if (! TStrUtil::GetTmFromStr(e, Tm)) {
2786      return false; }
2787    Indent=0;
2788    for (char *ch=LineStr; *ch && ! TCh::IsAlNum(*ch); ch++) {
2789      if (*ch == ':' || *ch == '*') { Indent++; }
2790    }
2791    return true;
2792  }
2793  TWikiMetaLoader::TWikiMetaLoader(const TStr& InFNm) {
2794    if (TZipIn::IsZipExt(InFNm.GetFExt())) { SInPt = TZipIn::New(InFNm); }
2795    else if (! InFNm.Empty()) { SInPt = TFIn::New(InFNm); }
2796    else { SInPt = TStdIn::New(); } 
2797  }
2798  bool TWikiMetaLoader::IsIpAddrUsr() const {
2799    return IsIpAddr(Usr);
2800  }
2801  bool TWikiMetaLoader::Next() {
2802    TSIn& SIn = *SInPt;
2803    static TChA LnStr;
2804    for (int rec=0; SIn.GetNextLn(LnStr); rec++) {
2805      if (! LnStr.IsPrefix("REVISION ")) {
2806        continue;
2807      }
2808      TChA Tmp = LnStr;
2809      TVec<char *> FldV; TStrUtil::SplitWords(Tmp, FldV);
2810      if (FldV.Len() != 7) {
2811        continue;
2812      }
2813      IAssert(FldV.Len() == 7);
2814      ArticleId = atoi(FldV[1]);
2815      RevisionId = atoi(FldV[2]);
2816      Title = FldV[3];
2817      RevTm = TSecTm::GetDtTmFromStr(FldV[4]);
2818      Usr = FldV[5];  Usr.ToLc();  Usr.ChangeCh(' ', '_');  
2819      UsrId = atoi(FldV[6]);
2820      IAssert(SIn.GetNextLn(LnStr));  IAssert(LnStr.IsPrefix("CATEGORY"));
2821      CatStr = LnStr.GetSubStr(LnStr.SearchCh(' ')+1, TInt::Mx);
2822      IAssert(SIn.GetNextLn(LnStr)); IAssert(LnStr.IsPrefix("IMAGE"));
2823      ImgStr = LnStr.GetSubStr(LnStr.SearchCh(' ')+1, TInt::Mx);
2824      IAssert(SIn.GetNextLn(LnStr));  IAssert(LnStr.IsPrefix("MAIN"));
2825      MainLStr = LnStr.GetSubStr(LnStr.SearchCh(' ')+1, TInt::Mx);
2826      IAssert(SIn.GetNextLn(LnStr));  IAssert(LnStr.IsPrefix("TALK"));
2827      TalkLStr = LnStr.GetSubStr(LnStr.SearchCh(' ')+1, TInt::Mx);
2828      IAssert(SIn.GetNextLn(LnStr));  IAssert(LnStr.IsPrefix("USER"));
2829      UserLStr = LnStr.GetSubStr(LnStr.SearchCh(' ')+1, TInt::Mx);
2830      IAssert(SIn.GetNextLn(LnStr));  IAssert(LnStr.IsPrefix("USER_TALK"));
2831      UserTalkLStr = LnStr.GetSubStr(LnStr.SearchCh(' ')+1, TInt::Mx);
2832      IAssert(SIn.GetNextLn(LnStr));  IAssert(LnStr.IsPrefix("OTHER"));
2833      OtherLStr =  LnStr.GetSubStr(LnStr.SearchCh(' ')+1, TInt::Mx);
2834      IAssert(SIn.GetNextLn(LnStr));  IAssert(LnStr.IsPrefix("EXTERNAL"));
2835      ExternalLStr = LnStr.GetSubStr(LnStr.SearchCh(' ')+1, TInt::Mx);
2836      IAssert(SIn.GetNextLn(LnStr));  IAssert(LnStr.IsPrefix("TEMPLATE"));
2837      TemplateStr = LnStr.GetSubStr(LnStr.SearchCh(' ')+1, TInt::Mx);
2838      IAssert(SIn.GetNextLn(LnStr));  IAssert(LnStr.IsPrefix("COMMENT"));
2839      CommentStr = LnStr.GetSubStr(LnStr.SearchCh(' ')+1, TInt::Mx);
2840      IAssert(SIn.GetNextLn(LnStr));  IAssert(LnStr.IsPrefix("MINOR"));
2841      MonorEdit = LnStr[LnStr.SearchCh(' ')+1] == '1';
2842      IAssert(SIn.GetNextLn(LnStr));  IAssert(LnStr.IsPrefix("TEXTDATA"));
2843      RevWrds = atoi(LnStr.GetSubStr(LnStr.SearchCh(' ')+1, TInt::Mx).CStr());
2844      return true;
2845    }
2846    return false;
2847  }
2848  bool TWikiMetaLoader::IsIpAddr(const TChA& Usr) {
2849    if (Usr.IsPrefix("ip:")) { return true; }
2850    int i = 0, Len=Usr.Len();
2851    while (i<Len && TCh::IsNum(Usr[i])) { i++; }
2852    if (! (i<Len && Usr[i]=='.')) { return false; }
2853    i++;
2854    while (i<Len && TCh::IsNum(Usr[i])) { i++; }
2855    if (! (i<Len && Usr[i]=='.')) { return false; }
2856    i++;
2857    while (i<Len && TCh::IsNum(Usr[i])) { i++; }
2858    if (i==Len) { return true; }
2859    return false;
2860  }
2861  TWikiMetaHist::TWikiMetaHist(const TStr& InFNm) : SInPt(TZipIn::IsZipFNm(InFNm) ? TZipIn::New(InFNm) : TFIn::New(InFNm)), XmlInPt(TXmlParser::New(SInPt)), PageCnt(0) {
2862    printf("Init from %s\n skip till <page>...", InFNm.CStr());
2863    XmlInPt->SkipTillTag("page");
2864    printf("done\n");
2865  }
2866  TWikiMetaHist::TWikiMetaHist(const PSIn& SIn) : SInPt(SIn), XmlInPt() {
2867  }
2868  void TWikiMetaHist::Save(TSOut& SOut) const {
2869    SOut.Save(PageId);
2870    SOut.Save(RevId);
2871    SOut.Save(UsrId);
2872    RevTm.Save(SOut);
2873    Usr.Save(SOut);
2874    Cmt.Save(SOut);
2875    Title.Save(SOut);
2876    Text.Save(SOut);
2877  }
2878  void TWikiMetaHist::Clr() {
2879    PageId = RevId = UsrId = -1;
2880    RevTm = TSecTm();
2881    Usr.Clr();  Cmt.Clr();
2882    Title.Clr();  Text.Clr();  Tmp.Clr();
2883  }
2884  bool TWikiMetaHist::LoadNextBin() {
2885    TSIn& SIn = *SInPt;
2886    if (SIn.Eof()) { Clr(); return false; }
2887    SIn.Load(PageId);
2888    SIn.Load(RevId);
2889    SIn.Load(UsrId);
2890    RevTm.Load(SIn);
2891    Usr.Load(SIn);
2892    Cmt.Load(SIn);
2893    Title.Load(SIn);
2894    Text.Load(SIn);
2895    for (int i = 0; i < Usr.Len(); i++) {
2896      if (Usr[i]==' ') { Usr[i]='_'; }
2897    }
2898    for (int i = 0; i < Title.Len(); i++) {
2899      if (Title[i]==' ') { Title[i]='_'; }
2900    }
2901    return true;
2902  }
2903  bool TWikiMetaHist::LoadNextTxt() {
2904    IAssert(! XmlInPt.Empty());
2905    TXmlParser& XmlIn = *XmlInPt;
2906    while (! (XmlIn.Sym == xsySTag && (XmlIn.SymStr == "page" || XmlIn.SymStr == "revision"))) {
2907      XmlIn.GetSym();
2908      if (XmlIn.Sym == xsyEof) { return false; }
2909    }
2910    if (XmlIn.SymStr == "page") {
2911      XmlIn.GetTagVal("title", Title);
2912      XmlIn.GetTagVal("id", Tmp);
2913      PageId = atoi(Tmp.CStr());
2914      XmlIn.GetSym();
2915      if (XmlIn.SymStr != "revision") {
2916        while (XmlIn.SymStr != "revision") { printf("NEW_TAG:  %s\n", XmlIn.SymStr.CStr()); XmlIn.GetSym(); }
2917      }
2918    }
2919    EAssertR(XmlIn.SymStr == "revision", XmlIn.SymStr); 
2920    XmlIn.GetTagVal("id", Tmp);
2921    RevId = atoi(Tmp.CStr());          
2922    XmlIn.GetTagVal("timestamp", Tmp); 
2923    Tmp[4]=0; Tmp[7]=0; Tmp[10]=0; Tmp[13]=0; Tmp[16]=0; Tmp[19]=0;
2924    RevTm = TSecTm(atoi(Tmp.CStr()), atoi(Tmp.CStr()+5), atoi(Tmp.CStr()+8),
2925      atoi(Tmp.CStr()+11), atoi(Tmp.CStr()+14), atoi(Tmp.CStr()+17));
2926    EAssert(XmlIn.GetTag("contributor") == xsySTag);
2927    XmlIn.GetSym();
2928    if (XmlIn.SymStr == "ip" && XmlIn.Sym==xsySTag) {
2929      XmlIn.GetSym();  Usr="ip:"; Usr+=XmlIn.SymStr;
2930      XmlIn.GetTag("ip");  IAssert(! XmlIn.SymStr.IsPrefix("ip:")); }
2931    else if (XmlIn.SymStr == "username") {
2932      if (XmlIn.Sym == xsySTag) { XmlIn.GetSym(); Usr=XmlIn.SymStr;  EAssert(XmlIn.GetTag("username") == xsyETag); } 
2933      else { EAssert(XmlIn.Sym == xsyETag && XmlIn.SymStr == "username"); } 
2934      XmlIn.GetTagVal("id", Tmp);  UsrId = atoi(Tmp.CStr());
2935    }
2936    for (int i = 0; i < Usr.Len(); i++) {
2937      if (Usr[i]==' ') { Usr[i]='_'; }
2938    }
2939    EAssert(XmlIn.GetTag("contributor") == xsyETag);
2940    XmlIn.GetSym();
2941    if (XmlIn.Sym == xsyETag && XmlIn.SymStr == "minor") { XmlIn.GetSym(); }
2942    if (XmlIn.Sym == xsySTag && XmlIn.SymStr == "comment") {
2943      XmlIn.GetSym();
2944      if (XmlIn.Sym == xsyStr) { Cmt=XmlIn.SymStr;  EAssert(XmlIn.GetTag("comment") == xsyETag); } 
2945      else { EAssert(XmlIn.Sym == xsyETag && XmlIn.SymStr == "comment"); } 
2946      XmlIn.GetSym();
2947    }
2948    EAssertR(XmlIn.SymStr.IsPrefix("text"), XmlIn.SymStr);
2949    if (XmlIn.Sym == xsySTag) {
2950      XmlIn.GetSym(Text);
2951      if (XmlIn.Sym == xsyStr) { EAssert(XmlIn.GetTag("text") == xsyETag); } 
2952      else { EAssert(XmlIn.Sym == xsyETag && XmlIn.SymStr == "text"); } 
2953    }
2954    EAssert(XmlIn.GetTag("revision") == xsyETag);
2955    if (++PageCnt % 10000 == 0) {
2956      printf("** %dk items: %s time %f\n", PageCnt/1000, ExeTm.GetStr(), ExeTm.GetSecs()); fflush(stdout); }
2957    return true;
2958  }
2959  void TWikiMetaHist::Dump(const bool& AlsoText) const {
2960    printf("page: %d %s\n", PageId, Title.CStr());
2961    printf("rev:  %d %s\n", RevId, RevTm.GetYmdTmStr().CStr());
2962    printf("user: %d %s\n", UsrId, Usr.CStr());
2963    printf("cmt:  %s\n", Cmt.CStr());
2964    if (AlsoText) { printf("text:\n%s\n", Text.CStr()); }
2965    printf("\n");
2966  }
2967  void TWikiMetaHist::DumpNextXmlTags(const int& DumpN) {
2968    TXmlParser& XmlIn = *XmlInPt;
2969    for (int i = 0; i < DumpN; i++) {
2970      printf("%s\n", XmlIn.SymStr.CStr());
2971      XmlIn.GetSym();
2972      if (XmlIn.Sym == xsyEof) { return; }
2973    }
2974  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-wix.cpp</h3>
            <pre><code>1  void TWixChDef::AddBit4CdStr(const TStr& Str){
2    int Cd=Bit4CdToStrV.Add(Str);
3    IAssert(Bit4CdToStrV.Len()<=16);
4    for (int ChN=0; ChN<Str.Len(); ChN++){
5      char Ch=Str[ChN];
6      IAssert(ChToBit4CdV[Ch-TCh::Mn]==-1);
7      ChToBit4CdV[Ch-TCh::Mn]=Cd;
8    }
9  }
10  void TWixChDef::AddBit6CdCh(const char& Ch){
11    int Cd=Bit6CdToChV.Add(Ch);
12    IAssert(Bit6CdToChV.Len()<=64);
13    IAssert(ChToBit6CdV[Ch-TCh::Mn]==-1);
14    ChToBit6CdV[Ch-TCh::Mn]=Cd;
15  }
16  void TWixChDef::AddChSet(const TStr& _ChSetStr){
17    IAssert(_ChSetStr.LastCh()==TCh::HashCh);
18    TChA ChSetChA;
19    TChA Bit4ChA;
20    for (int ChN=0; ChN<_ChSetStr.Len(); ChN++){
21      char Ch=_ChSetStr[ChN];
22      if (Ch==TCh::HashCh){
23        AddBit4CdStr(Bit4ChA);
24        Bit4ChA.Clr();
25      } else {
26        ChSetChA+=Ch;
27        AddBit6CdCh(Ch);
28        Bit4ChA+=Ch;
29      }
30    }
31    ChSetStr=ChSetChA;
32  }
33  void TWixChDef::SetUcCh(const TStr& Str){
34    char UcCh=Str[0];
35    IAssert(GetBit6VCd(UcCh)!=-1);
36    for (int CC=1; CC<Str.Len(); CC++){
37      char Ch=Str[CC];
38      IAssert(GetBit6VCd(Ch)==-1);
39      UcChV[Ch-TCh::Mn]=TCh(UcCh);
40    }
41  }
42  void TWixChDef::SetMnMxCh(){
43    MnCh=Bit6CdToChV[0];
44    MxCh=Bit6CdToChV.Last();
45  }
46  void TWixChDef::ConvVecToTb(){
47    ChToBit4CdT=new int[ChToBit4CdV.Len()];
48    for (int ChToBit4CdN=0; ChToBit4CdN<ChToBit4CdV.Len(); ChToBit4CdN++){
49      ChToBit4CdT[ChToBit4CdN]=ChToBit4CdV[ChToBit4CdN];}
50    Bit6CdToChT=new char[Bit6CdToChV.Len()];
51    for (int Bit6CdToChN=0; Bit6CdToChN<Bit6CdToChV.Len(); Bit6CdToChN++){
52      Bit6CdToChT[Bit6CdToChN]=Bit6CdToChV[Bit6CdToChN];}
53    ChToBit6CdT=new int[ChToBit6CdV.Len()];
54    for (int ChToBit6CdN=0; ChToBit6CdN<ChToBit6CdV.Len(); ChToBit6CdN++){
55      ChToBit6CdT[ChToBit6CdN]=ChToBit6CdV[ChToBit6CdN];}
56    UcChT=new char [UcChV.Len()];
57    for (int UcChN=0; UcChN<UcChV.Len(); UcChN++){
58      UcChT[UcChN]=UcChV[UcChN];}
59  }
60  TWixChDef::TWixChDef():
61    ChSetStr(),
62    Bit4CdToStrV(16, 0), ChToBit4CdV(TCh::Vals),
63    Bit6CdToChV(64, 0), ChToBit6CdV(TCh::Vals),
64    UcChV(TCh::Vals), MnCh(), MxCh(),
65    ChToBit4CdT(NULL), Bit6CdToChT(NULL), ChToBit6CdT(NULL), UcChT(NULL){
66    ChToBit4CdV.PutAll(TInt(-1)); ChToBit6CdV.PutAll(TInt(-1));
67    AddChSet(" #0#123#456#789#AB#C^]D\\#EF#GH#IJKL#MN#OPQ#RS[#TU#VWXY#Z@#");
68    for (int Ch=TCh::Mn; Ch<=TCh::Mx; Ch++){UcChV[Ch-TCh::Mn]=TCh(char(Ch));}
69    SetUcCh("Aa"); SetUcCh("Bb"); SetUcCh("Cc"); SetUcCh("^~"); SetUcCh("]}");
70    SetUcCh("Dd"); SetUcCh("\\|"); SetUcCh("Ee"); SetUcCh("Ff"); SetUcCh("Gg");
71    SetUcCh("Hh"); SetUcCh("Ii"); SetUcCh("Jj"); SetUcCh("Kk"); SetUcCh("Ll");
72    SetUcCh("Mm"); SetUcCh("Nn"); SetUcCh("Oo"); SetUcCh("Pp"); SetUcCh("Qq");
73    SetUcCh("Rr"); SetUcCh("Ss"); SetUcCh("[{"); SetUcCh("Tt"); SetUcCh("Uu");
74    SetUcCh("Vv"); SetUcCh("Ww"); SetUcCh("Xx"); SetUcCh("Yy"); SetUcCh("Zz");
75    SetUcCh("@`");
76    SetUcCh("^\xC8\xE8");
77    SetUcCh("]\xC6\xE6");
78    SetUcCh("\\\xD0\xF0");
79    SetUcCh("[\x8A\x9A");
80    SetUcCh("@\x8E\x9E");
81    SetUcCh("[\xA9\xB9");
82    SetUcCh("@\xAE\xBE");
83    SetMnMxCh();
84    ConvVecToTb();
85  }
86  TWixChDef::~TWixChDef(){
87    delete[] ChToBit4CdT;
88    delete[] Bit6CdToChT;
89    delete[] ChToBit6CdT;
90    delete[] UcChT;
91  }
92  void TWixChDef::GetNrWordChA(
93   const TChA& WordChA, bool& IsWordOk, TChA& NrWordChA) const {
94    NrWordChA.Clr();
95    for (int ChN=0; ChN<WordChA.Len(); ChN++){
96      char Ch=GetUcTCh(WordChA[ChN]);
97      if (GetBit6TCd(Ch)==-1){IsWordOk=false; return;}
98      NrWordChA+=Ch;
99    }
100    IsWordOk=true;
101  }
102  bool TWixChDef::IsNrWordChA(const TChA& NrWordChA) const {
103    for (int ChN=0; ChN<NrWordChA.Len(); ChN++){
104      if (GetBit6TCd(NrWordChA[ChN])==-1){return false;}}
105    return true;
106  }
107  void TWixChDef::SaveTxt(TOLx& Lx) const {
108    Lx.PutVar("ChDef", true, true);
109    Lx.PutVarStr("ChSetStr", ChSetStr);
110    Lx.PutVar("Bit4CdToStrV", true, true);
111    for (int Cd=0; Cd<Bit4CdToStrV.Len(); Cd++){
112      Lx.PutVarStr(TInt::GetStr(Cd), Bit4CdToStrV[Cd], true, false);}
113    Lx.PutVarEnd(true, true);
114    Lx.PutVar("ChToBit4CdV", true, true);
115    {for (int Cd=0; Cd<ChToBit4CdV.Len(); Cd++){
116      Lx.PutVarInt(TInt::GetStr(Cd), ChToBit4CdV[Cd], (Cd+1)%10==0, false);}}
117    Lx.PutVarEnd(true, true);
118    Lx.PutVar("Bit6CdToChV", true, true);
119    {for (int Cd=0; Cd<Bit6CdToChV.Len(); Cd++){
120      Lx.PutVarInt(TInt::GetStr(Cd), int(char(Bit6CdToChV[Cd])), (Cd+1)%10==0, false);}}
121    Lx.PutVarEnd(true, true);
122    Lx.PutVar("ChToBit6CdV", true, true);
123    {for (int Cd=0; Cd<ChToBit6CdV.Len(); Cd++){
124      Lx.PutVarInt(TInt::GetStr(Cd), ChToBit6CdV[Cd], (Cd+1)%10==0, false);}}
125    Lx.PutVarEnd(true, true);
126    Lx.PutVar("UcChV", true, true);
127    {for (int Cd=0; Cd<UcChV.Len(); Cd++){
128      Lx.PutVarInt(TInt::GetStr(Cd), UcChV[Cd], (Cd+1)%10==0, false);}}
129    Lx.PutVarEnd(true, true);
130    Lx.PutVarEnd(true, true);
131  }
132  TWixCdA::TWixCdA(const TChA& NrWordChA, const TWixChDef& ChDef){
133    int NrWordChALen=NrWordChA.Len();
134    IAssert(TWix::MxChsPerWord==16);
135    int Bit6CdT[16]; char Ch; 
136    for (int Bit6CdN=0; Bit6CdN<TWix::MxChsPerWord; Bit6CdN++){
137      if (Bit6CdN<NrWordChALen){Ch=NrWordChA[Bit6CdN];} else {Ch=' ';}
138      Bit6CdT[Bit6CdN]=ChDef.GetBit6TCd(Ch);
139    }
140    BSet1.PutInt(26, 31, Bit6CdT[0]);
141    BSet1.PutInt(20, 25, Bit6CdT[1]);
142    BSet1.PutInt(14, 19, Bit6CdT[2]);
143    BSet1.PutInt(8, 13, Bit6CdT[3]);
144    BSet1.PutInt(2, 7, Bit6CdT[4]);
145    BSet1.PutInt(0, 1, Bit6CdT[5]>>4);
146    BSet2.PutInt(28, 31, Bit6CdT[5]);
147    BSet2.PutInt(22, 27, Bit6CdT[6]);
148    BSet2.PutInt(16, 21, Bit6CdT[7]);
149    BSet2.PutInt(10, 15, Bit6CdT[8]);
150    BSet2.PutInt(4, 9, Bit6CdT[9]);
151    BSet2.PutInt(0, 3, Bit6CdT[10]>>2);
152    BSet3.PutInt(30, 31, Bit6CdT[10]);
153    BSet3.PutInt(24, 29, Bit6CdT[11]);
154    BSet3.PutInt(18, 23, Bit6CdT[12]);
155    BSet3.PutInt(12, 17, Bit6CdT[13]);
156    BSet3.PutInt(6, 11, Bit6CdT[14]);
157    BSet3.PutInt(0, 5, Bit6CdT[15]);
158  }
159  int TWixCdA::GetBit6Cd(const int& ChN) const {
160    switch (ChN){
161      case 0: return BSet1.GetInt(26, 31);
162      case 1: return BSet1.GetInt(20, 25);
163      case 2: return BSet1.GetInt(14, 19);
164      case 3: return BSet1.GetInt(8, 13);
165      case 4: return BSet1.GetInt(2, 7);
166      case 5: return (BSet1.GetInt(0, 1)<<4)+BSet2.GetInt(28, 31);
167      case 6: return BSet2.GetInt(22, 27);
168      case 7: return BSet2.GetInt(16, 21);
169      case 8: return BSet2.GetInt(10, 15);
170      case 9: return BSet2.GetInt(4, 9);
171      case 10: return (BSet2.GetInt(0, 3)<<2)+BSet3.GetInt(30, 31);
172      case 11: return BSet3.GetInt(24, 29);
173      case 12: return BSet3.GetInt(18, 23);
174      case 13: return BSet3.GetInt(12, 17);
175      case 14: return BSet3.GetInt(6, 11);
176      case 15: return BSet3.GetInt(0, 5);
177      default: Fail; return -1;
178    }
179  }
180  bool TWixCdA::IsPrefix(const int& Chs, const TWixCdA& CdA) const {
181    IAssert(TWix::MxChsPerWord==16);
182    IAssert(Chs>=0);
183    switch (Chs){
184      case 0: return true;
185      case 1: return BSet1.IsPrefix(CdA.BSet1, 26);
186      case 2: return BSet1.IsPrefix(CdA.BSet1, 20);
187      case 3: return BSet1.IsPrefix(CdA.BSet1, 14);
188      case 4: return BSet1.IsPrefix(CdA.BSet1, 8);
189      case 5: return BSet1.IsPrefix(CdA.BSet1, 2);
190      case 6: return (BSet1==CdA.BSet1)&&(BSet2.IsPrefix(CdA.BSet2, 28));
191      case 7: return (BSet1==CdA.BSet1)&&(BSet2.IsPrefix(CdA.BSet2, 22));
192      case 8: return (BSet1==CdA.BSet1)&&(BSet2.IsPrefix(CdA.BSet2, 16));
193      case 9: return (BSet1==CdA.BSet1)&&(BSet2.IsPrefix(CdA.BSet2, 10));
194      case 10: return (BSet1==CdA.BSet1)&&(BSet2.IsPrefix(CdA.BSet2, 4));
195      case 11: return (BSet1==CdA.BSet1)&&(BSet2==CdA.BSet2)&&(BSet3.IsPrefix(CdA.BSet3, 30));
196      case 12: return (BSet1==CdA.BSet1)&&(BSet2==CdA.BSet2)&&(BSet3.IsPrefix(CdA.BSet3, 24));
197      case 13: return (BSet1==CdA.BSet1)&&(BSet2==CdA.BSet2)&&(BSet3.IsPrefix(CdA.BSet3, 18));
198      case 14: return (BSet1==CdA.BSet1)&&(BSet2==CdA.BSet2)&&(BSet3.IsPrefix(CdA.BSet3, 12));
199      case 15: return (BSet1==CdA.BSet1)&&(BSet2==CdA.BSet2)&&(BSet3.IsPrefix(CdA.BSet3, 6));
200      default: return (BSet1==CdA.BSet1)&&(BSet2==CdA.BSet2)&&(BSet3==CdA.BSet3);
201    }
202  }
203  void TWixCdA::GetNrWordChA(const TWixChDef& ChDef, TChA& NrWordChA) const {
204    IAssert(TWix::MxChsPerWord==16);
205    NrWordChA.Clr();
206    char Ch;
207    Ch=ChDef.GetBit6TCh(BSet1.GetInt(26, 31));
208    if (Ch!=' '){NrWordChA+=Ch; Ch=ChDef.GetBit6TCh(BSet1.GetInt(20, 25));}
209    if (Ch!=' '){NrWordChA+=Ch; Ch=ChDef.GetBit6TCh(BSet1.GetInt(14, 19));}
210    if (Ch!=' '){NrWordChA+=Ch; Ch=ChDef.GetBit6TCh(BSet1.GetInt(8, 13));}
211    if (Ch!=' '){NrWordChA+=Ch; Ch=ChDef.GetBit6TCh(BSet1.GetInt(2, 7));}
212    if (Ch!=' '){NrWordChA+=Ch; Ch=ChDef.GetBit6TCh((BSet1.GetInt(0, 1)<<4)+BSet2.GetInt(28, 31));}
213    if (Ch!=' '){NrWordChA+=Ch; Ch=ChDef.GetBit6TCh(BSet2.GetInt(22, 27));}
214    if (Ch!=' '){NrWordChA+=Ch; Ch=ChDef.GetBit6TCh(BSet2.GetInt(16, 21));}
215    if (Ch!=' '){NrWordChA+=Ch; Ch=ChDef.GetBit6TCh(BSet2.GetInt(10, 15));}
216    if (Ch!=' '){NrWordChA+=Ch; Ch=ChDef.GetBit6TCh(BSet2.GetInt(4, 9));}
217    if (Ch!=' '){NrWordChA+=Ch; Ch=ChDef.GetBit6TCh((BSet2.GetInt(0, 3)<<2)+BSet3.GetInt(30, 31));}
218    if (Ch!=' '){NrWordChA+=Ch; Ch=ChDef.GetBit6TCh(BSet3.GetInt(24, 29));}
219    if (Ch!=' '){NrWordChA+=Ch; Ch=ChDef.GetBit6TCh(BSet3.GetInt(18, 23));}
220    if (Ch!=' '){NrWordChA+=Ch; Ch=ChDef.GetBit6TCh(BSet3.GetInt(12, 17));}
221    if (Ch!=' '){NrWordChA+=Ch; Ch=ChDef.GetBit6TCh(BSet3.GetInt(6, 11));}
222    if (Ch!=' '){NrWordChA+=Ch; Ch=ChDef.GetBit6TCh(BSet3.GetInt(0, 5));}
223    if (Ch!=' '){NrWordChA+=Ch;}
224  }
225  int TWixCdA::GetPrimHashCd() const {
226    int HashCd=BSet1.GetUInt()^BSet2.GetUInt()^BSet3.GetUInt();
227    HashCd&=0x0FFFFFFF;
228    return HashCd;
229  }
230  int TWixCdA::GetSecHashCd() const {
231    int HashCd=BSet1.GetUInt();
232    HashCd&=0x0FFFFFFF;
233    return HashCd;
234  }
235  int TWixDocIdSet::GetDocIds(){
236    IAssert(Wix->GetWord(WordId).GetDocIds()==DocIdV.Len());
237    return DocIdV.Len();
238  }
239  void TWixDocIdSet::AddDocId(const TBlobPt& DocId, const bool& DoIncDocIds){
240    Modified=true;
241    if (DoIncDocIds){Wix->GetWord(WordId).IncDocIds();}
242    DocIdV.AddSorted(DocId);
243  }
244  void TWixDocIdSet::OnDelFromCache(const TBlobPt& BlobPt, void*){
245    IAssert(Wix->GetWord(WordId).GetDocIds()>TWix::MxDocIdsInWord);
246    if (Modified){
247      TMOut MOut; Save(MOut);
248      TBlobPt NewBlobPt=Wix->GetDocIdBBs()->PutBlob(BlobPt, MOut.GetSIn());
249      Wix->GetWord(WordId).PutDocIdSetBPt(NewBlobPt);
250    }
251  }
252  void TWixDocIdSet::SaveTxt(TOLx& Lx, const TWixChDef& ChDef){
253    TChA NrWordChA;
254    Wix->GetWord(WordId).GetNrWordChA(ChDef, NrWordChA);
255    Lx.PutQStr(NrWordChA);
256    for (int DocIdN=0; DocIdN<DocIdV.Len(); DocIdN++){
257      Lx.PutUQStr(DocIdV[DocIdN].GetStr());
258    }
259  }
260  void TWixWord::AddDocId(const TBlobPt& DocId){
261    IAssert(int(DocIds)<TWix::MxDocIdsInWord);
262    if (DocIds==0){
263      BPt1=DocId; DocIds++;
264    } else
265    if (DocIds==1){
266      if (BPt1<DocId){BPt2=DocId;} else {BPt1=DocId; BPt2=BPt1;}
267      DocIds++;
268    } else {
269      IAssert(TWix::MxDocIdsInWord==4);
270      TBlobPtV BPtV(TWix::MxDocIdsInWord, 0);
271      if (DocIds>=1){BPtV.Add(BPt1);}
272      if (DocIds>=2){BPtV.Add(BPt2);}
273      if (DocIds>=3){BPtV.Add(BPt3);}
274      BPtV.AddSorted(DocId);
275      DocIds++;
276      if (DocIds>=1){BPt1=BPtV[0];}
277      if (DocIds>=2){BPt2=BPtV[1];}
278      if (DocIds>=3){BPt3=BPtV[2];}
279      if (DocIds>=4){BPt4=BPtV[3];}
280    }
281  }
282  PWixDocIdSet TWixWord::GetDocIdSet(TWix* Wix, const int& WordId){
283    IAssert(int(DocIds)<=TWix::MxDocIdsInWord);
284    PWixDocIdSet DocIdSet=PWixDocIdSet(new TWixDocIdSet(Wix, WordId, DocIds+3));
285    IAssert(TWix::MxDocIdsInWord==4);
286    if (DocIds>=1){DocIdSet->AddDocId(BPt1, false);}
287    if (DocIds>=2){DocIdSet->AddDocId(BPt2, false);}
288    if (DocIds>=3){DocIdSet->AddDocId(BPt3, false);}
289    if (DocIds>=4){DocIdSet->AddDocId(BPt4, false);}
290    return DocIdSet;
291  }
292  void TWixWord::PutDocIdSetBPt(const TBlobPt& DocIdSetBPt){
293    IAssert(DocIds>TWix::MxDocIdsInWord);
294    BPt1=DocIdSetBPt;
295  }
296  TBlobPt TWixWord::GetDocIdSetBPt(){
297    IAssert(DocIds>TWix::MxDocIdsInWord);
298    return BPt1;
299  }
300  const int& TWix::WordPortVIxChs=5;
301  const int& TWix::WordPortVBitsPerCh=4;
302  const int& TWix::WordPortVLen=TB4Def::GetP2(WordPortVIxChs*WordPortVBitsPerCh);
303  const int& TWix::MxChsPerWord=16;
304  const int& TWix::MxDocIdsInWord=4;
305  const TStr TWix::WixFExt=".wix";
306  const TStr TWix::WixDocIdFExt=".wdi";
307  const int TWix::InTitle_BPtFlagN=0;
308  const int TWix::WordFqMsb_BPtFlagN=1;
309  const int TWix::WordFqLsb_BPtFlagN=2;
310  const int TWix::InA_BPtFlagN=3;
311  int TWix::GetWordPortN(const TChA& WordChA, const bool& DoMaximize){
312    IAssert(TWix::WordPortVIxChs==5);
313    TWixChDef& RChDef=*ChDef;
314    int WordChALen=WordChA.Len();
315    char Ch1; char Ch2; char Ch3; char Ch4; char Ch5;
316    if (DoMaximize){
317      Ch1=Ch2=Ch3=Ch4=Ch5=RChDef.GetMxCh();
318    } else {
319      Ch1=Ch2=Ch3=Ch4=Ch5=RChDef.GetMnCh();
320    }
321    if (WordChALen>=1){Ch1=WordChA[0];
322      if (WordChALen>=2){Ch2=WordChA[1];
323        if (WordChALen>=3){Ch3=WordChA[2];
324          if (WordChALen>=4){Ch4=WordChA[3];
325            if (WordChALen>=5){Ch5=WordChA[4];}}}}}
326    return
327     RChDef.GetBit4TCd(Ch1)*65536+
328     RChDef.GetBit4TCd(Ch2)*4096+
329     RChDef.GetBit4TCd(Ch3)*256+
330     RChDef.GetBit4TCd(Ch4)*16+
331     RChDef.GetBit4TCd(Ch5);
332  }
333  int TWix::GetWordPortN(const TWixCdA& WordCdA){
334    IAssert(TWix::WordPortVIxChs==5);
335    TWixChDef& RChDef=*ChDef;
336    char Ch1=RChDef.GetBit6TCh(WordCdA.GetBit6Cd(0));
337    char Ch2=RChDef.GetBit6TCh(WordCdA.GetBit6Cd(1));
338    char Ch3=RChDef.GetBit6TCh(WordCdA.GetBit6Cd(2));
339    char Ch4=RChDef.GetBit6TCh(WordCdA.GetBit6Cd(3));
340    char Ch5=RChDef.GetBit6TCh(WordCdA.GetBit6Cd(4));
341    return
342     RChDef.GetBit4TCd(Ch1)*65536+
343     RChDef.GetBit4TCd(Ch2)*4096+
344     RChDef.GetBit4TCd(Ch3)*256+
345     RChDef.GetBit4TCd(Ch4)*16+
346     RChDef.GetBit4TCd(Ch5);
347  }
348  int TWix::GetWordId(const TWixCdA& WordCdA, const bool& CreateIfNo){
349    int WordPortN=GetWordPortN(WordCdA);
350    int WordId=WordPortV[WordPortN];
351    TWixWord Word(WordCdA);
352    int PrevWordId=-1;
353    while ((WordId!=-1)&&(Word<WordV[WordId])){
354      PrevWordId=WordId; WordId=WordV[WordId].GetNext();}
355    if (CreateIfNo){
356      if ((WordId==-1)||(Word>WordV[WordId])){
357        int NextWordId=WordId;
358        WordId=WordV.Add(Word);
359        if (NextWordId!=-1){
360          WordV[WordId].PutNext(NextWordId);}
361        if (PrevWordId==-1){
362          WordPortV[WordPortN]=WordId;
363        } else {
364          WordV[PrevWordId].PutNext(WordId);
365        }
366      }
367    } else {
368      if (WordId!=-1){
369        if (Word!=WordV[WordId]){WordId=-1;}
370      }
371    }
372    return WordId;
373  }
374  int TWix::AddDocId(const int& WordId, const TBlobPt& DocId){
375    TWixWord& Word=WordV[WordId];
376    if (Word.GetDocIds()<TWix::MxDocIdsInWord){
377      Word.AddDocId(DocId);
378    } else
379    if (Word.GetDocIds()==TWix::MxDocIdsInWord){
380      PWixDocIdSet DocIdSet=Word.GetDocIdSet(this, WordId);
381      DocIdSet->AddDocId(DocId);
382      TMOut MOut; DocIdSet->Save(MOut);
383      TBlobPt DocIdSetBPt=DocIdBBs->PutBlob(MOut.GetSIn());
384      Word.PutDocIdSetBPt(DocIdSetBPt);
385      DocIdSet->PutModified(false);
386      DocIdSetCache.Put(DocIdSetBPt, DocIdSet);
387      return DocIdSet->GetMemUsed();
388    } else {
389      TBlobPt DocIdSetBPt=Word.GetDocIdSetBPt();
390      PWixDocIdSet DocIdSet; int OldDocIdSetSize = 0;
391      if (DocIdSetCache.Get(DocIdSetBPt, DocIdSet)){
392        OldDocIdSetSize = DocIdSet->GetMemUsed();
393      } else {
394        PSIn SIn=DocIdBBs->GetBlob(DocIdSetBPt);
395        DocIdSet=PWixDocIdSet(new TWixDocIdSet(*SIn, this, WordId));
396      }
397      DocIdSetCache.Put(DocIdSetBPt, DocIdSet);
398      DocIdSet->AddDocId(DocId);
399      return DocIdSet->GetMemUsed() - OldDocIdSetSize;
400    }
401    return 0;
402  }
403  TWix::TWix(const TStr& Nm, const TStr& FPath, 
404   const TFAccess& _Access, const int64& CacheSize):
405    WixFNm(), WixDocIdFNm(), Access(_Access),
406    ChDef(), SwCdAH(10000),
407    WordPortV(), WordV(),
408    DocIdBBs(), DocIdSetCache(CacheSize, 1000000, GetVoidThis()), 
409    WordCdA_FqDocIdPrH(100000){ 
410    GetFNms(Nm, FPath, WixFNm, WixDocIdFNm);
411    WordPortV.Gen(WordPortVLen);
412    WordPortV.PutAll(TInt(-1));
413    if (Access==faCreate){
414      ChDef=PWixChDef(new TWixChDef());
415      DocIdBBs=PBlobBs(new TMBlobBs(WixDocIdFNm, faCreate)); 
416    } else {
417      IAssert((Access==faUpdate)||(Access==faRdOnly));
418      PBlobBs WixBBs=PBlobBs(new TGBlobBs(WixFNm, faRdOnly));
419      TBlobPt TrvBlobPt=WixBBs->FFirstBlobPt();
420      PSIn BlobSIn;
421      IAssert(WixBBs->FNextBlobPt(TrvBlobPt, BlobSIn));
422      ChDef=PWixChDef(*BlobSIn);
423      IAssert(WixBBs->FNextBlobPt(TrvBlobPt, BlobSIn));
424      TIntV _WordPortV(*BlobSIn);
425      IAssert(_WordPortV.Len()==WordPortV.Len());
426      WordPortV=_WordPortV;
427      while (WixBBs->FNextBlobPt(TrvBlobPt, BlobSIn)){
428        TWixWordV _WordV(*BlobSIn);
429        WordV.AddV(_WordV);
430      }
431      DocIdBBs=PBlobBs(new TMBlobBs(WixDocIdFNm, Access)); 
432    }
433    PSwSet SwSet=PSwSet(new TSwSet(swstNone));
434    int SwId=SwSet->FFirstSwId();
435    TStr SwStr; TChA SwChA; bool IsWordOk; TChA NrSwChA;
436    while (SwSet->FNextSwId(SwId, SwStr)){
437      ChDef->GetNrWordChA(SwStr, IsWordOk, NrSwChA);
438      if (IsWordOk){
439        TWixCdA SwCdA(NrSwChA, *ChDef);
440        SwCdAH.AddKey(SwCdA);
441      }
442    }
443    CacheResetThreshold = int64(0.1 * double(CacheSize));
444    NewCacheSizeInc = 0;
445  }
446  TWix::~TWix(){
447    if ((Access==faCreate)||(Access==faUpdate)){
448      DocIdSetCache.Flush();
449      PBlobBs WixBBs=PBlobBs(new TGBlobBs(WixFNm, faCreate));
450      {TMOut ChDefSOut; ChDef.Save(ChDefSOut);
451      WixBBs->PutBlob(ChDefSOut.GetSIn());}
452      {TMOut WordPortVSOut; WordPortV.Save(WordPortVSOut);
453      WixBBs->PutBlob(WordPortVSOut.GetSIn());}
454      int WordN=0;
455      while (WordN<WordV.Len()){
456        TWixWordV SegWordV(10000, 0);
457        while ((WordN<WordV.Len())&&(SegWordV.Len()<10000)){
458          SegWordV.Add(WordV[WordN]); WordN++;}
459        TMOut SegWordVSOut; SegWordV.Save(SegWordVSOut);
460        WixBBs->PutBlob(SegWordVSOut.GetSIn());
461      }
462    }
463  }
464  TStr TWix::GetMemUsedStr(){
465    return TStr()+
466     "WordPortV:"+TInt::GetMegaStr(WordPortV.GetMemUsed())+
467     " WordV:"+TInt::GetMegaStr(WordV.GetMemUsed())+
468     " DocIdSetCache:"+TUInt64::GetMegaStr(DocIdSetCache.GetMemUsed());
469  }
470  void TWix::AddHtmlDoc(const TBlobPt& DocId, const PSIn& HtmlSIn){
471    WordCdA_FqDocIdPrH.Clr(false, 1000);
472    bool InTitleTag=false; bool InATag=false;
473    THtmlLx Lx(HtmlSIn, false); 
474    bool IsWordOk; TChA NrWordChA; 
475    while (Lx.GetSym()!=hsyEof){
476      if (Lx.Sym==hsyStr){
477        ChDef->GetNrWordChA(Lx.ChA, IsWordOk, NrWordChA);
478        if (IsWordOk){
479          TWixCdA WordCdA(NrWordChA, *ChDef);
480          if (!SwCdAH.IsKey(WordCdA)){
481            int WordKeyId=WordCdA_FqDocIdPrH.AddKey(WordCdA);
482            TFqDocIdPr& FqDocIdPr=WordCdA_FqDocIdPrH[WordKeyId];
483            TInt& WordFq=FqDocIdPr.Val1; 
484            TBlobPt& WordDocId=FqDocIdPr.Val2; 
485            if (WordFq==0){WordDocId=DocId;} 
486            WordFq++; 
487            if (InTitleTag){WordDocId.PutFlag(InTitle_BPtFlagN, true);}
488            if (InATag){WordDocId.PutFlag(InA_BPtFlagN, true);}
489            if (WordCdA_FqDocIdPrH.Len()>200){break;} 
490          }
491        }
492      } else
493      if ((Lx.Sym==hsyBTag)||(Lx.Sym==hsyETag)){
494        if (Lx.ChA==THtmlTok::ATagNm){InATag=(Lx.Sym==hsyBTag);} else
495        if (Lx.ChA==THtmlTok::TitleTagNm){InTitleTag=(Lx.Sym==hsyBTag);}
496      }
497    }
498    int WordKeyId=WordCdA_FqDocIdPrH.FFirstKeyId();
499    while (WordCdA_FqDocIdPrH.FNextKeyId(WordKeyId)){
500      const TWixCdA& WordCdA=WordCdA_FqDocIdPrH.GetKey(WordKeyId);
501      TFqDocIdPr& FqDocIdPr=WordCdA_FqDocIdPrH[WordKeyId];
502      int WordFq=FqDocIdPr.Val1; 
503      TBlobPt& DocId=FqDocIdPr.Val2; 
504      bool WordFqMsbFlag; bool WordFqLsbFlag;
505      if (WordFq<=1){WordFqMsbFlag=false; WordFqLsbFlag=false;}
506      else if (WordFq<=2){WordFqMsbFlag=false; WordFqLsbFlag=true;}
507      else if (WordFq<=4){WordFqMsbFlag=true; WordFqLsbFlag=false;}
508      else {WordFqMsbFlag=true; WordFqLsbFlag=true;}
509      DocId.PutFlag(WordFqMsb_BPtFlagN, WordFqMsbFlag);
510      DocId.PutFlag(WordFqLsb_BPtFlagN, WordFqLsbFlag);
511      int WordId=GetWordId(WordCdA, true);
512      NewCacheSizeInc += int64(AddDocId(WordId, DocId));
513    }
514    if (NewCacheSizeInc > CacheResetThreshold) { 
515      printf("   Cache cleanup (%s:%s)\n", 
516          TUInt64::GetMegaStr(NewCacheSizeInc).CStr(),
517          TUInt64::GetMegaStr(CacheResetThreshold).CStr());
518      DocIdSetCache.RefreshMemUsed();
519      NewCacheSizeInc = 0;
520    }
521  }
522  PWixDocIdSet TWix::GetDocIdSet(const int& WordId){
523    TWixWord& Word=WordV[WordId];
524    if (Word.GetDocIds()<=MxDocIdsInWord){
525      return Word.GetDocIdSet(this, WordId);
526    } else {
527      PWixDocIdSet DocIdSet;
528      TBlobPt DocIdSetBPt=Word.GetDocIdSetBPt();
529      if (!DocIdSetCache.Get(DocIdSetBPt, DocIdSet)){
530        PSIn SIn=DocIdBBs->GetBlob(DocIdSetBPt);
531        DocIdSet=PWixDocIdSet(new TWixDocIdSet(*SIn, this, WordId));
532      }
533      DocIdSetCache.Put(DocIdSetBPt, DocIdSet);
534      return DocIdSet;
535    }
536  }
537  PWixDocIdSet TWix::GetDocIdSet(const TWixCdA& WordCdA){
538    int WordId=GetWordId(WordCdA, false);
539    if (WordId==-1){
540      return NULL;
541    } else {
542      return GetDocIdSet(WordId);
543    }
544  }
545  void TWix::GetDocIdV(const TChA& WordChA, const bool& IsExactMatch,
546   const int& MxWcWords, TBlobPtV& DocIdV){
547    DocIdV.Clr();
548    bool IsWordOk; TChA NrWordChA;
549    ChDef->GetNrWordChA(WordChA, IsWordOk, NrWordChA);
550    if (!IsWordOk){return;}
551    TWixCdA NrWordCdA(NrWordChA, *ChDef);
552    if (IsExactMatch){
553      PWixDocIdSet DocIdSet=GetDocIdSet(NrWordCdA);
554      if (!DocIdSet.Empty()){
555        DocIdSet->GetDocIdV(DocIdV);}
556    } else {
557      int MnWordPortN=GetWordPortN(NrWordChA, false);
558      int MxWordPortN=GetWordPortN(NrWordChA, true);
559      int WcWords=0;
560      for (int WordPortN=MnWordPortN; WordPortN<=MxWordPortN; WordPortN++){
561        int WordId=WordPortV[WordPortN];
562        while (WordId!=-1){
563          TWixWord& Word=WordV[WordId];
564          if (Word.IsPrefixChA(NrWordChA, NrWordCdA)){
565            PWixDocIdSet DocIdSet=GetDocIdSet(WordId);
566            DocIdSet->OrDocIdV(DocIdV);
567            WcWords++;
568            if (WcWords>MxWcWords){break;}
569          }
570          WordId=Word.GetNext();
571        }
572        if (WcWords>MxWcWords){break;}
573      }
574    }
575  }
576  void TWix::GetFqWordV(TIntStrPrV& FqWordV){
577    FqWordV.Gen(GetWords());
578    for (int WordId=0; WordId<GetWords(); WordId++){
579      FqWordV[WordId]=TIntStrPr(GetWordFq(WordId), GetWordStr(WordId));
580    }
581    FqWordV.Sort(false);
582  }
583  void TWix::SaveTxt(const PSOut& SOut){
584    TOLx Lx(SOut, TFSet()|oloFrcEoln|oloSigNum|oloCsSens);
585    TChA NrWordChA;
586    ChDef->SaveTxt(Lx);
587    {for (int WordPortN=0; WordPortN<WordPortV.Len(); WordPortN++){
588      int WordId=WordPortV[WordPortN];
589      if (WordId!=-1){
590        Lx.PutVar(TInt::GetStr(WordPortN), true, false, false);
591        while (WordId!=-1){
592          TWixWord& Word=WordV[WordId];
593          Word.GetNrWordChA(*ChDef, NrWordChA);
594          Lx.PutQStr(NrWordChA);
595          Lx.PutSym(syColon);
596          Lx.PutInt(TInt(Word.GetDocIds()));
597          if (Word.GetDocIds()>TWix::MxDocIdsInWord){
598            Lx.PutUQStr(Word.GetDocIdSetBPt().GetStr());}
599          WordId=Word.GetNext();
600        }
601        Lx.PutVarEnd(true, true);
602      }
603    }}
604    Lx.PutVar("WordV", true, true);
605    {for (int WordPortN=0; WordPortN<WordPortV.Len(); WordPortN++){
606      int WordId=WordPortV[WordPortN];
607      if (WordId!=-1){
608        Lx.PutVar(TInt::GetStr(WordPortN), true, true, false);
609        while (WordId!=-1){
610          TWixWord& Word=WordV[WordId];
611          Word.GetNrWordChA(*ChDef, NrWordChA);
612          TWixCdA NrWordCdA(NrWordChA, *ChDef);
613          Lx.PutQStr(NrWordChA);
614          Lx.PutSym(syLParen); Lx.PutInt(WordId); Lx.PutSym(syRParen);
615          PWixDocIdSet DocIdSet=GetDocIdSet(NrWordCdA);
616          Lx.PutInt(TInt(DocIdSet->GetDocIds()));
617          DocIdSet->SaveTxt(Lx, *ChDef);
618          Lx.PutLn();
619          WordId=Word.GetNext();
620        }
621        Lx.PutVarEnd(true, true);
622      }
623    }}
624    Lx.PutVarEnd(true, true);
625    Lx.PutVar("WordFqV", true, true);
<span onclick='openModal()' class='match'>626    TIntStrPrV FqWordV;
627    GetFqWordV(FqWordV);
628    for (int FqWordN=0; FqWordN<FqWordV.Len(); FqWordN++){
629      Lx.PutQStr(FqWordV[FqWordN].Val2);
</span>630      Lx.PutInt(FqWordV[FqWordN].Val1);
631      Lx.PutLn();
632    }
633    Lx.PutVarEnd(true, true);
634  }
635  void TWix::SaveTxtWordFq(const PSOut& SOut){
636    TOLx Lx(SOut, TFSet()|oloFrcEoln|oloSigNum|oloCsSens);
637    TIntStrPrV FqWordV;
638    GetFqWordV(FqWordV);
639    for (int FqWordN=0; FqWordN<FqWordV.Len(); FqWordN++){
640      Lx.PutQStr(FqWordV[FqWordN].Val2);
641      Lx.PutInt(FqWordV[FqWordN].Val1);
642      Lx.PutLn();
643    }
644  }
645  void TWix::GetFNms(
646   const TStr& Nm, const TStr& FPath,
647   TStr& WixFNm, TStr& WixDocIdFNm){
648    TStr NrFPath=TStr::GetNrFPath(FPath);
649    TStr NrNm=TStr::GetNrFMid(Nm);
650    WixFNm=NrFPath+NrNm+WixFExt;
651    WixDocIdFNm=NrFPath+NrNm+WixDocIdFExt;
652  }
653  bool TWix::Exists(const TStr& Nm, const TStr& FPath){
654    TStr WixFNm; TStr WixDocIdFNm;
655    GetFNms(Nm, FPath, WixFNm, WixDocIdFNm);
656    return
657     TFile::Exists(WixFNm)&&
658     TFile::Exists(WixDocIdFNm);
659  }
660  void TWix::Del(const TStr& Nm, const TStr& FPath){
661    if (Exists(Nm, FPath)){
662      TStr WixFNm; TStr WixDocIdFNm;
663      GetFNms(Nm, FPath, WixFNm, WixDocIdFNm);
664      TFile::Del(WixFNm);
665      TFile::Del(WixDocIdFNm);
666    }
667  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-wikinet.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-wix.cpp</div>
                </div>
                <div class="column column_space"><pre><code>1611    TIntPrV VotesUIdV; GetUsrVotes(VotesUIdV);
1612    for (int i = 0; i < VotesUIdV.Len(); i++) {
1613      VotesPerUser.AddDat(10*(VotesUIdV[i].Val1/10))+=1;
</pre></code></div>
                <div class="column column_space"><pre><code>626    TIntStrPrV FqWordV;
627    GetFqWordV(FqWordV);
628    for (int FqWordN=0; FqWordN<FqWordV.Len(); FqWordN++){
629      Lx.PutQStr(FqWordV[FqWordN].Val2);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    