
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 36, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-type_traits_test.cc</h3>
            <pre><code>1  #include &quot;absl/meta/type_traits.h&quot;
2  #include &lt;cstdint&gt;
3  #include &lt;string&gt;
4  #include &lt;type_traits&gt;
5  #include &lt;utility&gt;
6  #include &lt;vector&gt;
7  #include &quot;gtest/gtest.h&quot;
8  #include &quot;absl/base/attributes.h&quot;
9  #include &quot;absl/base/config.h&quot;
10  #include &quot;absl/time/clock.h&quot;
11  #include &quot;absl/time/time.h&quot;
12  namespace {
13  using ::testing::StaticAssertTypeEq;
14  template &lt;class T, class U&gt;
15  struct simple_pair {
16    T first;
17    U second;
18  };
19  struct Dummy {};
20  struct ReturnType {};
21  struct ConvertibleToReturnType {
22    operator ReturnType() const;  
23  };
24  struct StructA {};
25  struct StructB {};
26  struct StructC {};
27  struct TypeWithBarFunction {
28    template &lt;class T,
29              absl::enable_if_t&lt;std::is_same&lt;T&amp;&amp;, StructA&amp;&gt;::value, int&gt; = 0&gt;
30    ReturnType bar(T&amp;&amp;, const StructB&amp;, StructC&amp;&amp;) &amp;&amp;;  
31  };
32  struct TypeWithBarFunctionAndConvertibleReturnType {
33    template &lt;class T,
34              absl::enable_if_t&lt;std::is_same&lt;T&amp;&amp;, StructA&amp;&gt;::value, int&gt; = 0&gt;
35    ConvertibleToReturnType bar(T&amp;&amp;, const StructB&amp;, StructC&amp;&amp;) &amp;&amp;;  
36  };
37  template &lt;class Class, class... Ts&gt;
38  using BarIsCallableImpl =
39      decltype(std::declval&lt;Class&gt;().bar(std::declval&lt;Ts&gt;()...));
40  template &lt;class Class, class... T&gt;
41  using BarIsCallable =
42      absl::type_traits_internal::is_detected&lt;BarIsCallableImpl, Class, T...&gt;;
43  template &lt;class Class, class... T&gt;
44  using BarIsCallableConv = absl::type_traits_internal::is_detected_convertible&lt;
45      ReturnType, BarIsCallableImpl, Class, T...&gt;;
46  TEST(IsDetectedTest, BasicUsage) {
47    EXPECT_TRUE((BarIsCallable&lt;TypeWithBarFunction, StructA&amp;, const StructB&amp;,
48                               StructC&gt;::value));
49    EXPECT_TRUE(
50        (BarIsCallable&lt;TypeWithBarFunction, StructA&amp;, StructB&amp;, StructC&gt;::value));
51    EXPECT_TRUE(
52        (BarIsCallable&lt;TypeWithBarFunction, StructA&amp;, StructB, StructC&gt;::value));
53    EXPECT_FALSE((BarIsCallable&lt;int, StructA&amp;, const StructB&amp;, StructC&gt;::value));
54    EXPECT_FALSE((BarIsCallable&lt;TypeWithBarFunction&amp;, StructA&amp;, const StructB&amp;,
55                                StructC&gt;::value));
56    EXPECT_FALSE((BarIsCallable&lt;TypeWithBarFunction, StructA, const StructB&amp;,
57                                StructC&gt;::value));
58  }
59  TEST(IsDetectedConvertibleTest, BasicUsage) {
60    EXPECT_TRUE((BarIsCallableConv&lt;TypeWithBarFunction, StructA&amp;, const StructB&amp;,
61                                   StructC&gt;::value));
62    EXPECT_TRUE((BarIsCallableConv&lt;TypeWithBarFunction, StructA&amp;, StructB&amp;,
63                                   StructC&gt;::value));
64    EXPECT_TRUE((BarIsCallableConv&lt;TypeWithBarFunction, StructA&amp;, StructB,
65                                   StructC&gt;::value));
66    EXPECT_TRUE((BarIsCallableConv&lt;TypeWithBarFunctionAndConvertibleReturnType,
67                                   StructA&amp;, const StructB&amp;, StructC&gt;::value));
68    EXPECT_TRUE((BarIsCallableConv&lt;TypeWithBarFunctionAndConvertibleReturnType,
69                                   StructA&amp;, StructB&amp;, StructC&gt;::value));
70    EXPECT_TRUE((BarIsCallableConv&lt;TypeWithBarFunctionAndConvertibleReturnType,
71                                   StructA&amp;, StructB, StructC&gt;::value));
72    EXPECT_FALSE(
73        (BarIsCallableConv&lt;int, StructA&amp;, const StructB&amp;, StructC&gt;::value));
74    EXPECT_FALSE((BarIsCallableConv&lt;TypeWithBarFunction&amp;, StructA&amp;,
75                                    const StructB&amp;, StructC&gt;::value));
76    EXPECT_FALSE((BarIsCallableConv&lt;TypeWithBarFunction, StructA, const StructB&amp;,
77                                    StructC&gt;::value));
78    EXPECT_FALSE((BarIsCallableConv&lt;TypeWithBarFunctionAndConvertibleReturnType&amp;,
79                                    StructA&amp;, const StructB&amp;, StructC&gt;::value));
80    EXPECT_FALSE((BarIsCallableConv&lt;TypeWithBarFunctionAndConvertibleReturnType,
81                                    StructA, const StructB&amp;, StructC&gt;::value));
82  }
83  TEST(VoidTTest, BasicUsage) {
84    StaticAssertTypeEq&lt;void, absl::void_t&lt;Dummy&gt;&gt;();
85    StaticAssertTypeEq&lt;void, absl::void_t&lt;Dummy, Dummy, Dummy&gt;&gt;();
86  }
87  TEST(ConjunctionTest, BasicBooleanLogic) {
88    EXPECT_TRUE(absl::conjunction&lt;&gt;::value);
89    EXPECT_TRUE(absl::conjunction&lt;std::true_type&gt;::value);
90    EXPECT_TRUE((absl::conjunction&lt;std::true_type, std::true_type&gt;::value));
91    EXPECT_FALSE((absl::conjunction&lt;std::true_type, std::false_type&gt;::value));
92    EXPECT_FALSE((absl::conjunction&lt;std::false_type, std::true_type&gt;::value));
93    EXPECT_FALSE((absl::conjunction&lt;std::false_type, std::false_type&gt;::value));
94  }
95  struct MyTrueType {
96    static constexpr bool value = true;
97  };
98  struct MyFalseType {
99    static constexpr bool value = false;
100  };
101  TEST(ConjunctionTest, ShortCircuiting) {
102    EXPECT_FALSE(
103        (absl::conjunction&lt;std::true_type, std::false_type, Dummy&gt;::value));
104    EXPECT_TRUE((std::is_base_of&lt;MyFalseType,
105                                 absl::conjunction&lt;std::true_type, MyFalseType,
106                                                   std::false_type&gt;&gt;::value));
107    EXPECT_TRUE(
108        (std::is_base_of&lt;MyTrueType,
109                         absl::conjunction&lt;std::true_type, MyTrueType&gt;&gt;::value));
110  }
111  TEST(DisjunctionTest, BasicBooleanLogic) {
112    EXPECT_FALSE(absl::disjunction&lt;&gt;::value);
113    EXPECT_FALSE(absl::disjunction&lt;std::false_type&gt;::value);
114    EXPECT_TRUE((absl::disjunction&lt;std::true_type, std::true_type&gt;::value));
115    EXPECT_TRUE((absl::disjunction&lt;std::true_type, std::false_type&gt;::value));
116    EXPECT_TRUE((absl::disjunction&lt;std::false_type, std::true_type&gt;::value));
117    EXPECT_FALSE((absl::disjunction&lt;std::false_type, std::false_type&gt;::value));
118  }
119  TEST(DisjunctionTest, ShortCircuiting) {
120    EXPECT_TRUE(
121        (absl::disjunction&lt;std::false_type, std::true_type, Dummy&gt;::value));
122    EXPECT_TRUE((
123        std::is_base_of&lt;MyTrueType, absl::disjunction&lt;std::false_type, MyTrueType,
124                                                      std::true_type&gt;&gt;::value));
125    EXPECT_TRUE((
126        std::is_base_of&lt;MyFalseType,
127                        absl::disjunction&lt;std::false_type, MyFalseType&gt;&gt;::value));
128  }
129  TEST(NegationTest, BasicBooleanLogic) {
130    EXPECT_FALSE(absl::negation&lt;std::true_type&gt;::value);
131    EXPECT_FALSE(absl::negation&lt;MyTrueType&gt;::value);
132    EXPECT_TRUE(absl::negation&lt;std::false_type&gt;::value);
133    EXPECT_TRUE(absl::negation&lt;MyFalseType&gt;::value);
134  }
135  class Trivial {
136    int n_;
137  };
138  struct TrivialDestructor {
139    ~TrivialDestructor() = default;
140  };
141  struct NontrivialDestructor {
142    ~NontrivialDestructor() {}
143  };
144  struct DeletedDestructor {
145    ~DeletedDestructor() = delete;
146  };
147  class TrivialDefaultCtor {
148   public:
149    TrivialDefaultCtor() = default;
150    explicit TrivialDefaultCtor(int n) : n_(n) {}
151   private:
152    int n_;
153  };
154  class NontrivialDefaultCtor {
155   public:
156    NontrivialDefaultCtor() : n_(1) {}
157   private:
158    int n_;
159  };
160  class DeletedDefaultCtor {
161   public:
162    DeletedDefaultCtor() = delete;
163    explicit DeletedDefaultCtor(int n) : n_(n) {}
164   private:
165    int n_;
166  };
167  class TrivialMoveCtor {
168   public:
169    explicit TrivialMoveCtor(int n) : n_(n) {}
170    TrivialMoveCtor(TrivialMoveCtor&amp;&amp;) = default;
171    TrivialMoveCtor&amp; operator=(const TrivialMoveCtor&amp; t) {
172      n_ = t.n_;
173      return *this;
174    }
175   private:
176    int n_;
177  };
178  class NontrivialMoveCtor {
179   public:
180    explicit NontrivialMoveCtor(int n) : n_(n) {}
181    NontrivialMoveCtor(NontrivialMoveCtor&amp;&amp; t) noexcept : n_(t.n_) {}
182    NontrivialMoveCtor&amp; operator=(const NontrivialMoveCtor&amp;) = default;
183   private:
184    int n_;
185  };
186  class TrivialCopyCtor {
187   public:
188    explicit TrivialCopyCtor(int n) : n_(n) {}
189    TrivialCopyCtor(const TrivialCopyCtor&amp;) = default;
190    TrivialCopyCtor&amp; operator=(const TrivialCopyCtor&amp; t) {
191      n_ = t.n_;
192      return *this;
193    }
194   private:
195    int n_;
196  };
197  class NontrivialCopyCtor {
198   public:
199    explicit NontrivialCopyCtor(int n) : n_(n) {}
200    NontrivialCopyCtor(const NontrivialCopyCtor&amp; t) : n_(t.n_) {}
201    NontrivialCopyCtor&amp; operator=(const NontrivialCopyCtor&amp;) = default;
202   private:
203    int n_;
204  };
205  class DeletedCopyCtor {
206   public:
207    explicit DeletedCopyCtor(int n) : n_(n) {}
208    DeletedCopyCtor(const DeletedCopyCtor&amp;) = delete;
209    DeletedCopyCtor&amp; operator=(const DeletedCopyCtor&amp;) = default;
210   private:
211    int n_;
212  };
213  class TrivialMoveAssign {
214   public:
215    explicit TrivialMoveAssign(int n) : n_(n) {}
216    TrivialMoveAssign(const TrivialMoveAssign&amp; t) : n_(t.n_) {}
217    TrivialMoveAssign&amp; operator=(TrivialMoveAssign&amp;&amp;) = default;
218    ~TrivialMoveAssign() {}  
219   private:
220    int n_;
221  };
222  class NontrivialMoveAssign {
223   public:
224    explicit NontrivialMoveAssign(int n) : n_(n) {}
225    NontrivialMoveAssign(const NontrivialMoveAssign&amp;) = default;
226    NontrivialMoveAssign&amp; operator=(NontrivialMoveAssign&amp;&amp; t) noexcept {
<span onclick='openModal()' class='match'>227      n_ = t.n_;
228      return *this;
229    }
230   private:
231    int n_;
232  };
233  class TrivialCopyAssign {
234   public:
235    explicit TrivialCopyAssign(int n) : n_(n) {}
236    TrivialCopyAssign(const TrivialCopyAssign&amp; t) : n_(t.n_) {}
</span>237    TrivialCopyAssign&amp; operator=(const TrivialCopyAssign&amp; t) = default;
238    ~TrivialCopyAssign() {}  
239   private:
240    int n_;
241  };
242  class NontrivialCopyAssign {
243   public:
244    explicit NontrivialCopyAssign(int n) : n_(n) {}
245    NontrivialCopyAssign(const NontrivialCopyAssign&amp;) = default;
246    NontrivialCopyAssign&amp; operator=(const NontrivialCopyAssign&amp; t) {
247      n_ = t.n_;
248      return *this;
249    }
250   private:
251    int n_;
252  };
253  class DeletedCopyAssign {
254   public:
255    explicit DeletedCopyAssign(int n) : n_(n) {}
256    DeletedCopyAssign(const DeletedCopyAssign&amp;) = default;
257    DeletedCopyAssign&amp; operator=(const DeletedCopyAssign&amp;) = delete;
258   private:
259    int n_;
260  };
261  struct MovableNonCopyable {
262    MovableNonCopyable() = default;
263    MovableNonCopyable(const MovableNonCopyable&amp;) = delete;
264    MovableNonCopyable(MovableNonCopyable&amp;&amp;) = default;
265    MovableNonCopyable&amp; operator=(const MovableNonCopyable&amp;) = delete;
266    MovableNonCopyable&amp; operator=(MovableNonCopyable&amp;&amp;) = default;
267  };
268  struct NonCopyableOrMovable {
269    NonCopyableOrMovable() = default;
270    virtual ~NonCopyableOrMovable() = default;
271    NonCopyableOrMovable(const NonCopyableOrMovable&amp;) = delete;
272    NonCopyableOrMovable(NonCopyableOrMovable&amp;&amp;) = delete;
273    NonCopyableOrMovable&amp; operator=(const NonCopyableOrMovable&amp;) = delete;
274    NonCopyableOrMovable&amp; operator=(NonCopyableOrMovable&amp;&amp;) = delete;
275  };
276  class Base {
277   public:
278    virtual ~Base() {}
279  };
280  TEST(TypeTraitsTest, TestIsFunction) {
281    struct Callable {
282      void operator()() {}
283    };
284    EXPECT_TRUE(absl::is_function&lt;void()&gt;::value);
285    EXPECT_TRUE(absl::is_function&lt;void()&amp;&gt;::value);
286    EXPECT_TRUE(absl::is_function&lt;void() const&gt;::value);
287    EXPECT_TRUE(absl::is_function&lt;void() noexcept&gt;::value);
288    EXPECT_TRUE(absl::is_function&lt;void(...) noexcept&gt;::value);
289    EXPECT_FALSE(absl::is_function&lt;void(*)()&gt;::value);
290    EXPECT_FALSE(absl::is_function&lt;void(&amp;)()&gt;::value);
291    EXPECT_FALSE(absl::is_function&lt;int&gt;::value);
292    EXPECT_FALSE(absl::is_function&lt;Callable&gt;::value);
293  }
294  TEST(TypeTraitsTest, TestRemoveCVRef) {
295    EXPECT_TRUE(
296        (std::is_same&lt;typename absl::remove_cvref&lt;int&gt;::type, int&gt;::value));
297    EXPECT_TRUE(
298        (std::is_same&lt;typename absl::remove_cvref&lt;int&amp;&gt;::type, int&gt;::value));
299    EXPECT_TRUE(
300        (std::is_same&lt;typename absl::remove_cvref&lt;int&amp;&amp;&gt;::type, int&gt;::value));
301    EXPECT_TRUE((
302        std::is_same&lt;typename absl::remove_cvref&lt;const int&amp;&gt;::type, int&gt;::value));
303    EXPECT_TRUE(
304        (std::is_same&lt;typename absl::remove_cvref&lt;int*&gt;::type, int*&gt;::value));
305    EXPECT_TRUE((std::is_same&lt;typename absl::remove_cvref&lt;const int*&gt;::type,
306                              const int*&gt;::value));
307    EXPECT_TRUE((std::is_same&lt;typename absl::remove_cvref&lt;int[2]&gt;::type,
308                              int[2]&gt;::value));
309    EXPECT_TRUE((std::is_same&lt;typename absl::remove_cvref&lt;int(&amp;)[2]&gt;::type,
310                              int[2]&gt;::value));
311    EXPECT_TRUE((std::is_same&lt;typename absl::remove_cvref&lt;int(&amp;&amp;)[2]&gt;::type,
312                              int[2]&gt;::value));
313    EXPECT_TRUE((std::is_same&lt;typename absl::remove_cvref&lt;const int[2]&gt;::type,
314                              int[2]&gt;::value));
315    EXPECT_TRUE((std::is_same&lt;typename absl::remove_cvref&lt;const int(&amp;)[2]&gt;::type,
316                              int[2]&gt;::value));
317    EXPECT_TRUE((std::is_same&lt;typename absl::remove_cvref&lt;const int(&amp;&amp;)[2]&gt;::type,
318                              int[2]&gt;::value));
319  }
320  #define ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(trait_name, ...)          \
321    EXPECT_TRUE((std::is_same&lt;typename std::trait_name&lt;__VA_ARGS__&gt;::type, \
322                              absl::trait_name##_t&lt;__VA_ARGS__&gt;&gt;::value))
323  TEST(TypeTraitsTest, TestRemoveCVAliases) {
324    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_cv, int);
325    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_cv, const int);
326    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_cv, volatile int);
327    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_cv, const volatile int);
328    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_const, int);
329    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_const, const int);
330    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_const, volatile int);
331    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_const, const volatile int);
332    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_volatile, int);
333    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_volatile, const int);
334    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_volatile, volatile int);
335    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_volatile, const volatile int);
336  }
337  TEST(TypeTraitsTest, TestAddCVAliases) {
338    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_cv, int);
339    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_cv, const int);
340    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_cv, volatile int);
341    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_cv, const volatile int);
342    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_const, int);
343    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_const, const int);
344    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_const, volatile int);
345    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_const, const volatile int);
346    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_volatile, int);
347    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_volatile, const int);
348    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_volatile, volatile int);
349    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_volatile, const volatile int);
350  }
351  TEST(TypeTraitsTest, TestReferenceAliases) {
352    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_reference, int);
353    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_reference, volatile int);
354    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_reference, int&amp;);
355    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_reference, volatile int&amp;);
356    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_reference, int&amp;&amp;);
357    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_reference, volatile int&amp;&amp;);
358    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_lvalue_reference, int);
359    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_lvalue_reference, volatile int);
360    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_lvalue_reference, int&amp;);
361    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_lvalue_reference, volatile int&amp;);
362    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_lvalue_reference, int&amp;&amp;);
363    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_lvalue_reference, volatile int&amp;&amp;);
364    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_rvalue_reference, int);
365    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_rvalue_reference, volatile int);
366    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_rvalue_reference, int&amp;);
367    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_rvalue_reference, volatile int&amp;);
368    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_rvalue_reference, int&amp;&amp;);
369    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_rvalue_reference, volatile int&amp;&amp;);
370  }
371  TEST(TypeTraitsTest, TestPointerAliases) {
372    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_pointer, int*);
373    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_pointer, volatile int*);
374    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_pointer, int);
375    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_pointer, volatile int);
376  }
377  TEST(TypeTraitsTest, TestSignednessAliases) {
378    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(make_signed, int);
379    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(make_signed, volatile int);
380    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(make_signed, unsigned);
381    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(make_signed, volatile unsigned);
382    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(make_unsigned, int);
383    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(make_unsigned, volatile int);
384    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(make_unsigned, unsigned);
385    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(make_unsigned, volatile unsigned);
386  }
387  TEST(TypeTraitsTest, TestExtentAliases) {
388    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_extent, int[]);
389    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_extent, int[1]);
390    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_extent, int[1][1]);
391    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_extent, int[][1]);
392    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_all_extents, int[]);
393    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_all_extents, int[1]);
394    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_all_extents, int[1][1]);
395    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_all_extents, int[][1]);
396  }
397  TEST(TypeTraitsTest, TestAlignedStorageAlias) {
398    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 1);
399    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 2);
400    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 3);
401    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 4);
402    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 5);
403    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 6);
404    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 7);
405    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 8);
406    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 9);
407    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 10);
408    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 11);
409    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 12);
410    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 13);
411    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 14);
412    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 15);
413    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 16);
414    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 17);
415    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 18);
416    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 19);
417    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 20);
418    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 21);
419    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 22);
420    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 23);
421    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 24);
422    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 25);
423    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 26);
424    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 27);
425    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 28);
426    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 29);
427    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 30);
428    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 31);
429    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 32);
430    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 33);
431    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 1, 128);
432    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 2, 128);
433    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 3, 128);
434    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 4, 128);
435    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 5, 128);
436    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 6, 128);
437    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 7, 128);
438    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 8, 128);
439    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 9, 128);
440    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 10, 128);
441    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 11, 128);
442    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 12, 128);
443    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 13, 128);
444    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 14, 128);
445    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 15, 128);
446    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 16, 128);
447    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 17, 128);
448    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 18, 128);
449    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 19, 128);
450    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 20, 128);
451    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 21, 128);
452    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 22, 128);
453    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 23, 128);
454    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 24, 128);
455    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 25, 128);
456    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 26, 128);
457    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 27, 128);
458    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 28, 128);
459    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 29, 128);
460    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 30, 128);
461    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 31, 128);
462    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 32, 128);
463    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 33, 128);
464  }
465  TEST(TypeTraitsTest, TestDecay) {
466    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(decay, int);
467    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(decay, const int);
468    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(decay, volatile int);
469    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(decay, const volatile int);
470    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(decay, int&amp;);
471    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(decay, const int&amp;);
472    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(decay, volatile int&amp;);
473    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(decay, const volatile int&amp;);
474    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(decay, int&amp;);
475    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(decay, const int&amp;);
476    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(decay, volatile int&amp;);
477    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(decay, const volatile int&amp;);
478    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(decay, int[1]);
479    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(decay, int[1][1]);
480    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(decay, int[][1]);
481    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(decay, int());
482    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(decay, int(float));  
483    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(decay, int(char, ...));  
484  }
485  struct TypeA {};
486  struct TypeB {};
487  struct TypeC {};
488  struct TypeD {};
489  template &lt;typename T&gt;
490  struct Wrap {};
491  enum class TypeEnum { A, B, C, D };
492  struct GetTypeT {
493    template &lt;typename T,
494              absl::enable_if_t&lt;std::is_same&lt;T, TypeA&gt;::value, int&gt; = 0&gt;
495    TypeEnum operator()(Wrap&lt;T&gt;) const {
496      return TypeEnum::A;
497    }
498    template &lt;typename T,
499              absl::enable_if_t&lt;std::is_same&lt;T, TypeB&gt;::value, int&gt; = 0&gt;
500    TypeEnum operator()(Wrap&lt;T&gt;) const {
501      return TypeEnum::B;
502    }
503    template &lt;typename T,
504              absl::enable_if_t&lt;std::is_same&lt;T, TypeC&gt;::value, int&gt; = 0&gt;
505    TypeEnum operator()(Wrap&lt;T&gt;) const {
506      return TypeEnum::C;
507    }
508  } constexpr GetType = {};
509  TEST(TypeTraitsTest, TestEnableIf) {
510    EXPECT_EQ(TypeEnum::A, GetType(Wrap&lt;TypeA&gt;()));
511    EXPECT_EQ(TypeEnum::B, GetType(Wrap&lt;TypeB&gt;()));
512    EXPECT_EQ(TypeEnum::C, GetType(Wrap&lt;TypeC&gt;()));
513  }
514  TEST(TypeTraitsTest, TestConditional) {
515    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(conditional, true, int, char);
516    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(conditional, false, int, char);
517  }
518  TEST(TypeTraitsTest, TestCommonType) {
519    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(common_type, int);
520    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(common_type, int, char);
521    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(common_type, int, char, int);
522    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(common_type, int&amp;);
523    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(common_type, int, char&amp;);
524    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(common_type, int, char, int&amp;);
525  }
526  TEST(TypeTraitsTest, TestUnderlyingType) {
527    enum class enum_char : char {};
528    enum class enum_long_long : long long {};  
529    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(underlying_type, enum_char);
530    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(underlying_type, enum_long_long);
531  }
532  struct GetTypeExtT {
533    template &lt;typename T&gt;
534    absl::result_of_t&lt;const GetTypeT&amp;(T)&gt; operator()(T&amp;&amp; arg) const {
535      return GetType(std::forward&lt;T&gt;(arg));
536    }
537    TypeEnum operator()(Wrap&lt;TypeD&gt;) const { return TypeEnum::D; }
538  } constexpr GetTypeExt = {};
539  TEST(TypeTraitsTest, TestResultOf) {
540    EXPECT_EQ(TypeEnum::A, GetTypeExt(Wrap&lt;TypeA&gt;()));
541    EXPECT_EQ(TypeEnum::B, GetTypeExt(Wrap&lt;TypeB&gt;()));
542    EXPECT_EQ(TypeEnum::C, GetTypeExt(Wrap&lt;TypeC&gt;()));
543    EXPECT_EQ(TypeEnum::D, GetTypeExt(Wrap&lt;TypeD&gt;()));
544  }
545  namespace adl_namespace {
546  struct DeletedSwap {
547  };
548  void swap(DeletedSwap&amp;, DeletedSwap&amp;) = delete;
549  struct SpecialNoexceptSwap {
550    SpecialNoexceptSwap(SpecialNoexceptSwap&amp;&amp;) {}
551    SpecialNoexceptSwap&amp; operator=(SpecialNoexceptSwap&amp;&amp;) { return *this; }
552    ~SpecialNoexceptSwap() = default;
553  };
554  void swap(SpecialNoexceptSwap&amp;, SpecialNoexceptSwap&amp;) noexcept {}
555  }  
556  TEST(TypeTraitsTest, IsSwappable) {
557    using absl::type_traits_internal::IsSwappable;
558    using absl::type_traits_internal::StdSwapIsUnconstrained;
559    EXPECT_TRUE(IsSwappable&lt;int&gt;::value);
560    struct S {};
561    EXPECT_TRUE(IsSwappable&lt;S&gt;::value);
562    struct NoConstruct {
563      NoConstruct(NoConstruct&amp;&amp;) = delete;
564      NoConstruct&amp; operator=(NoConstruct&amp;&amp;) { return *this; }
565      ~NoConstruct() = default;
566    };
567    EXPECT_EQ(IsSwappable&lt;NoConstruct&gt;::value, StdSwapIsUnconstrained::value);
568    struct NoAssign {
569      NoAssign(NoAssign&amp;&amp;) {}
570      NoAssign&amp; operator=(NoAssign&amp;&amp;) = delete;
571      ~NoAssign() = default;
572    };
573    EXPECT_EQ(IsSwappable&lt;NoAssign&gt;::value, StdSwapIsUnconstrained::value);
574    EXPECT_FALSE(IsSwappable&lt;adl_namespace::DeletedSwap&gt;::value);
575    EXPECT_TRUE(IsSwappable&lt;adl_namespace::SpecialNoexceptSwap&gt;::value);
576  }
577  TEST(TypeTraitsTest, IsNothrowSwappable) {
578    using absl::type_traits_internal::IsNothrowSwappable;
579    using absl::type_traits_internal::StdSwapIsUnconstrained;
580    EXPECT_TRUE(IsNothrowSwappable&lt;int&gt;::value);
581    struct NonNoexceptMoves {
582      NonNoexceptMoves(NonNoexceptMoves&amp;&amp;) {}
583      NonNoexceptMoves&amp; operator=(NonNoexceptMoves&amp;&amp;) { return *this; }
584      ~NonNoexceptMoves() = default;
585    };
586    EXPECT_FALSE(IsNothrowSwappable&lt;NonNoexceptMoves&gt;::value);
587    struct NoConstruct {
588      NoConstruct(NoConstruct&amp;&amp;) = delete;
589      NoConstruct&amp; operator=(NoConstruct&amp;&amp;) { return *this; }
590      ~NoConstruct() = default;
591    };
592    EXPECT_FALSE(IsNothrowSwappable&lt;NoConstruct&gt;::value);
593    struct NoAssign {
594      NoAssign(NoAssign&amp;&amp;) {}
595      NoAssign&amp; operator=(NoAssign&amp;&amp;) = delete;
596      ~NoAssign() = default;
597    };
598    EXPECT_FALSE(IsNothrowSwappable&lt;NoAssign&gt;::value);
599    EXPECT_FALSE(IsNothrowSwappable&lt;adl_namespace::DeletedSwap&gt;::value);
600    EXPECT_TRUE(IsNothrowSwappable&lt;adl_namespace::SpecialNoexceptSwap&gt;::value);
601  }
602  TEST(TriviallyRelocatable, PrimitiveTypes) {
603    static_assert(absl::is_trivially_relocatable&lt;int&gt;::value, &quot;&quot;);
604    static_assert(absl::is_trivially_relocatable&lt;char&gt;::value, &quot;&quot;);
605    static_assert(absl::is_trivially_relocatable&lt;void*&gt;::value, &quot;&quot;);
606  }
607  TEST(TriviallyRelocatable, UserDefinedTriviallyReconstructible) {
608    struct S {
609      int x;
610      int y;
611    };
612    static_assert(absl::is_trivially_relocatable&lt;S&gt;::value, &quot;&quot;);
613  }
614  TEST(TriviallyRelocatable, UserProvidedMoveConstructor) {
615    struct S {
616      S(S&amp;&amp;) {}  
617    };
618    static_assert(!absl::is_trivially_relocatable&lt;S&gt;::value, &quot;&quot;);
619  }
620  TEST(TriviallyRelocatable, UserProvidedCopyConstructor) {
621    struct S {
622      S(const S&amp;) {}  
623    };
624    static_assert(!absl::is_trivially_relocatable&lt;S&gt;::value, &quot;&quot;);
625  }
626  TEST(TriviallyRelocatable, UserProvidedDestructor) {
627    struct S {
628      ~S() {}  
629    };
630    static_assert(!absl::is_trivially_relocatable&lt;S&gt;::value, &quot;&quot;);
631  }
632  #if defined(ABSL_HAVE_ATTRIBUTE_TRIVIAL_ABI) &amp;&amp;      \
633      ABSL_HAVE_BUILTIN(__is_trivially_relocatable) &amp;&amp; \
634      !(defined(__clang__) &amp;&amp; (defined(_WIN32) || defined(_WIN64)))
635  TEST(TrivallyRelocatable, TrivialAbi) {
636    struct ABSL_ATTRIBUTE_TRIVIAL_ABI S {
637      S(S&amp;&amp;) {}       
638      S(const S&amp;) {}  
639      ~S() {}         
640    };
641    static_assert(absl::is_trivially_relocatable&lt;S&gt;::value, &quot;&quot;);
642  }
643  #endif
644  #ifdef ABSL_HAVE_CONSTANT_EVALUATED
645  constexpr int64_t NegateIfConstantEvaluated(int64_t i) {
646    if (absl::is_constant_evaluated()) {
647      return -i;
648    } else {
649      return i;
650    }
651  }
652  #endif  
653  TEST(TrivallyRelocatable, is_constant_evaluated) {
654  #ifdef ABSL_HAVE_CONSTANT_EVALUATED
655    constexpr int64_t constant = NegateIfConstantEvaluated(42);
656    EXPECT_EQ(constant, -42);
657    int64_t now = absl::ToUnixSeconds(absl::Now());
658    int64_t not_constant = NegateIfConstantEvaluated(now);
659    EXPECT_EQ(not_constant, now);
660    static int64_t const_init = NegateIfConstantEvaluated(42);
661    EXPECT_EQ(const_init, -42);
662  #else
663    GTEST_SKIP() &lt;&lt; &quot;absl::is_constant_evaluated is not defined&quot;;
664  #endif  
665  }
666  }  
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-type_traits_test.cc</h3>
            <pre><code>1  #include &quot;absl/meta/type_traits.h&quot;
2  #include &lt;cstdint&gt;
3  #include &lt;string&gt;
4  #include &lt;type_traits&gt;
5  #include &lt;utility&gt;
6  #include &lt;vector&gt;
7  #include &quot;gtest/gtest.h&quot;
8  #include &quot;absl/base/attributes.h&quot;
9  #include &quot;absl/base/config.h&quot;
10  #include &quot;absl/time/clock.h&quot;
11  #include &quot;absl/time/time.h&quot;
12  namespace {
13  using ::testing::StaticAssertTypeEq;
14  template &lt;class T, class U&gt;
15  struct simple_pair {
16    T first;
17    U second;
18  };
19  struct Dummy {};
20  struct ReturnType {};
21  struct ConvertibleToReturnType {
22    operator ReturnType() const;  
23  };
24  struct StructA {};
25  struct StructB {};
26  struct StructC {};
27  struct TypeWithBarFunction {
28    template &lt;class T,
29              absl::enable_if_t&lt;std::is_same&lt;T&amp;&amp;, StructA&amp;&gt;::value, int&gt; = 0&gt;
30    ReturnType bar(T&amp;&amp;, const StructB&amp;, StructC&amp;&amp;) &amp;&amp;;  
31  };
32  struct TypeWithBarFunctionAndConvertibleReturnType {
33    template &lt;class T,
34              absl::enable_if_t&lt;std::is_same&lt;T&amp;&amp;, StructA&amp;&gt;::value, int&gt; = 0&gt;
35    ConvertibleToReturnType bar(T&amp;&amp;, const StructB&amp;, StructC&amp;&amp;) &amp;&amp;;  
36  };
37  template &lt;class Class, class... Ts&gt;
38  using BarIsCallableImpl =
39      decltype(std::declval&lt;Class&gt;().bar(std::declval&lt;Ts&gt;()...));
40  template &lt;class Class, class... T&gt;
41  using BarIsCallable =
42      absl::type_traits_internal::is_detected&lt;BarIsCallableImpl, Class, T...&gt;;
43  template &lt;class Class, class... T&gt;
44  using BarIsCallableConv = absl::type_traits_internal::is_detected_convertible&lt;
45      ReturnType, BarIsCallableImpl, Class, T...&gt;;
46  TEST(IsDetectedTest, BasicUsage) {
47    EXPECT_TRUE((BarIsCallable&lt;TypeWithBarFunction, StructA&amp;, const StructB&amp;,
48                               StructC&gt;::value));
49    EXPECT_TRUE(
50        (BarIsCallable&lt;TypeWithBarFunction, StructA&amp;, StructB&amp;, StructC&gt;::value));
51    EXPECT_TRUE(
52        (BarIsCallable&lt;TypeWithBarFunction, StructA&amp;, StructB, StructC&gt;::value));
53    EXPECT_FALSE((BarIsCallable&lt;int, StructA&amp;, const StructB&amp;, StructC&gt;::value));
54    EXPECT_FALSE((BarIsCallable&lt;TypeWithBarFunction&amp;, StructA&amp;, const StructB&amp;,
55                                StructC&gt;::value));
56    EXPECT_FALSE((BarIsCallable&lt;TypeWithBarFunction, StructA, const StructB&amp;,
57                                StructC&gt;::value));
58  }
59  TEST(IsDetectedConvertibleTest, BasicUsage) {
60    EXPECT_TRUE((BarIsCallableConv&lt;TypeWithBarFunction, StructA&amp;, const StructB&amp;,
61                                   StructC&gt;::value));
62    EXPECT_TRUE((BarIsCallableConv&lt;TypeWithBarFunction, StructA&amp;, StructB&amp;,
63                                   StructC&gt;::value));
64    EXPECT_TRUE((BarIsCallableConv&lt;TypeWithBarFunction, StructA&amp;, StructB,
65                                   StructC&gt;::value));
66    EXPECT_TRUE((BarIsCallableConv&lt;TypeWithBarFunctionAndConvertibleReturnType,
67                                   StructA&amp;, const StructB&amp;, StructC&gt;::value));
68    EXPECT_TRUE((BarIsCallableConv&lt;TypeWithBarFunctionAndConvertibleReturnType,
69                                   StructA&amp;, StructB&amp;, StructC&gt;::value));
70    EXPECT_TRUE((BarIsCallableConv&lt;TypeWithBarFunctionAndConvertibleReturnType,
71                                   StructA&amp;, StructB, StructC&gt;::value));
72    EXPECT_FALSE(
73        (BarIsCallableConv&lt;int, StructA&amp;, const StructB&amp;, StructC&gt;::value));
74    EXPECT_FALSE((BarIsCallableConv&lt;TypeWithBarFunction&amp;, StructA&amp;,
75                                    const StructB&amp;, StructC&gt;::value));
76    EXPECT_FALSE((BarIsCallableConv&lt;TypeWithBarFunction, StructA, const StructB&amp;,
77                                    StructC&gt;::value));
78    EXPECT_FALSE((BarIsCallableConv&lt;TypeWithBarFunctionAndConvertibleReturnType&amp;,
79                                    StructA&amp;, const StructB&amp;, StructC&gt;::value));
80    EXPECT_FALSE((BarIsCallableConv&lt;TypeWithBarFunctionAndConvertibleReturnType,
81                                    StructA, const StructB&amp;, StructC&gt;::value));
82  }
83  TEST(VoidTTest, BasicUsage) {
84    StaticAssertTypeEq&lt;void, absl::void_t&lt;Dummy&gt;&gt;();
85    StaticAssertTypeEq&lt;void, absl::void_t&lt;Dummy, Dummy, Dummy&gt;&gt;();
86  }
87  TEST(ConjunctionTest, BasicBooleanLogic) {
88    EXPECT_TRUE(absl::conjunction&lt;&gt;::value);
89    EXPECT_TRUE(absl::conjunction&lt;std::true_type&gt;::value);
90    EXPECT_TRUE((absl::conjunction&lt;std::true_type, std::true_type&gt;::value));
91    EXPECT_FALSE((absl::conjunction&lt;std::true_type, std::false_type&gt;::value));
92    EXPECT_FALSE((absl::conjunction&lt;std::false_type, std::true_type&gt;::value));
93    EXPECT_FALSE((absl::conjunction&lt;std::false_type, std::false_type&gt;::value));
94  }
95  struct MyTrueType {
96    static constexpr bool value = true;
97  };
98  struct MyFalseType {
99    static constexpr bool value = false;
100  };
101  TEST(ConjunctionTest, ShortCircuiting) {
102    EXPECT_FALSE(
103        (absl::conjunction&lt;std::true_type, std::false_type, Dummy&gt;::value));
104    EXPECT_TRUE((std::is_base_of&lt;MyFalseType,
105                                 absl::conjunction&lt;std::true_type, MyFalseType,
106                                                   std::false_type&gt;&gt;::value));
107    EXPECT_TRUE(
108        (std::is_base_of&lt;MyTrueType,
109                         absl::conjunction&lt;std::true_type, MyTrueType&gt;&gt;::value));
110  }
111  TEST(DisjunctionTest, BasicBooleanLogic) {
112    EXPECT_FALSE(absl::disjunction&lt;&gt;::value);
113    EXPECT_FALSE(absl::disjunction&lt;std::false_type&gt;::value);
114    EXPECT_TRUE((absl::disjunction&lt;std::true_type, std::true_type&gt;::value));
115    EXPECT_TRUE((absl::disjunction&lt;std::true_type, std::false_type&gt;::value));
116    EXPECT_TRUE((absl::disjunction&lt;std::false_type, std::true_type&gt;::value));
117    EXPECT_FALSE((absl::disjunction&lt;std::false_type, std::false_type&gt;::value));
118  }
119  TEST(DisjunctionTest, ShortCircuiting) {
120    EXPECT_TRUE(
121        (absl::disjunction&lt;std::false_type, std::true_type, Dummy&gt;::value));
122    EXPECT_TRUE((
123        std::is_base_of&lt;MyTrueType, absl::disjunction&lt;std::false_type, MyTrueType,
124                                                      std::true_type&gt;&gt;::value));
125    EXPECT_TRUE((
126        std::is_base_of&lt;MyFalseType,
127                        absl::disjunction&lt;std::false_type, MyFalseType&gt;&gt;::value));
128  }
129  TEST(NegationTest, BasicBooleanLogic) {
130    EXPECT_FALSE(absl::negation&lt;std::true_type&gt;::value);
131    EXPECT_FALSE(absl::negation&lt;MyTrueType&gt;::value);
132    EXPECT_TRUE(absl::negation&lt;std::false_type&gt;::value);
133    EXPECT_TRUE(absl::negation&lt;MyFalseType&gt;::value);
134  }
135  class Trivial {
136    int n_;
137  };
138  struct TrivialDestructor {
139    ~TrivialDestructor() = default;
140  };
141  struct NontrivialDestructor {
142    ~NontrivialDestructor() {}
143  };
144  struct DeletedDestructor {
145    ~DeletedDestructor() = delete;
146  };
147  class TrivialDefaultCtor {
148   public:
149    TrivialDefaultCtor() = default;
150    explicit TrivialDefaultCtor(int n) : n_(n) {}
151   private:
152    int n_;
153  };
154  class NontrivialDefaultCtor {
155   public:
156    NontrivialDefaultCtor() : n_(1) {}
157   private:
158    int n_;
159  };
160  class DeletedDefaultCtor {
161   public:
162    DeletedDefaultCtor() = delete;
163    explicit DeletedDefaultCtor(int n) : n_(n) {}
164   private:
165    int n_;
166  };
167  class TrivialMoveCtor {
168   public:
169    explicit TrivialMoveCtor(int n) : n_(n) {}
170    TrivialMoveCtor(TrivialMoveCtor&amp;&amp;) = default;
171    TrivialMoveCtor&amp; operator=(const TrivialMoveCtor&amp; t) {
172      n_ = t.n_;
173      return *this;
174    }
175   private:
176    int n_;
177  };
178  class NontrivialMoveCtor {
179   public:
180    explicit NontrivialMoveCtor(int n) : n_(n) {}
181    NontrivialMoveCtor(NontrivialMoveCtor&amp;&amp; t) noexcept : n_(t.n_) {}
182    NontrivialMoveCtor&amp; operator=(const NontrivialMoveCtor&amp;) = default;
183   private:
184    int n_;
185  };
186  class TrivialCopyCtor {
187   public:
188    explicit TrivialCopyCtor(int n) : n_(n) {}
189    TrivialCopyCtor(const TrivialCopyCtor&amp;) = default;
190    TrivialCopyCtor&amp; operator=(const TrivialCopyCtor&amp; t) {
191      n_ = t.n_;
192      return *this;
193    }
194   private:
195    int n_;
196  };
197  class NontrivialCopyCtor {
198   public:
199    explicit NontrivialCopyCtor(int n) : n_(n) {}
200    NontrivialCopyCtor(const NontrivialCopyCtor&amp; t) : n_(t.n_) {}
201    NontrivialCopyCtor&amp; operator=(const NontrivialCopyCtor&amp;) = default;
202   private:
203    int n_;
204  };
205  class DeletedCopyCtor {
206   public:
207    explicit DeletedCopyCtor(int n) : n_(n) {}
208    DeletedCopyCtor(const DeletedCopyCtor&amp;) = delete;
209    DeletedCopyCtor&amp; operator=(const DeletedCopyCtor&amp;) = default;
210   private:
211    int n_;
212  };
213  class TrivialMoveAssign {
214   public:
215    explicit TrivialMoveAssign(int n) : n_(n) {}
216    TrivialMoveAssign(const TrivialMoveAssign&amp; t) : n_(t.n_) {}
217    TrivialMoveAssign&amp; operator=(TrivialMoveAssign&amp;&amp;) = default;
218    ~TrivialMoveAssign() {}  
219   private:
220    int n_;
221  };
222  class NontrivialMoveAssign {
223   public:
224    explicit NontrivialMoveAssign(int n) : n_(n) {}
225    NontrivialMoveAssign(const NontrivialMoveAssign&amp;) = default;
226    NontrivialMoveAssign&amp; operator=(NontrivialMoveAssign&amp;&amp; t) noexcept {
227      n_ = t.n_;
228      return *this;
229    }
230   private:
231    int n_;
232  };
233  class TrivialCopyAssign {
234   public:
235    explicit TrivialCopyAssign(int n) : n_(n) {}
236    TrivialCopyAssign(const TrivialCopyAssign&amp; t) : n_(t.n_) {}
237    TrivialCopyAssign&amp; operator=(const TrivialCopyAssign&amp; t) = default;
238    ~TrivialCopyAssign() {}  
239   private:
240    int n_;
241  };
242  class NontrivialCopyAssign {
243   public:
244    explicit NontrivialCopyAssign(int n) : n_(n) {}
245    NontrivialCopyAssign(const NontrivialCopyAssign&amp;) = default;
246    NontrivialCopyAssign&amp; operator=(const NontrivialCopyAssign&amp; t) {
<span onclick='openModal()' class='match'>247      n_ = t.n_;
248      return *this;
249    }
250   private:
251    int n_;
252  };
253  class DeletedCopyAssign {
254   public:
255    explicit DeletedCopyAssign(int n) : n_(n) {}
256    DeletedCopyAssign(const DeletedCopyAssign&amp;) = default;
</span>257    DeletedCopyAssign&amp; operator=(const DeletedCopyAssign&amp;) = delete;
258   private:
259    int n_;
260  };
261  struct MovableNonCopyable {
262    MovableNonCopyable() = default;
263    MovableNonCopyable(const MovableNonCopyable&amp;) = delete;
264    MovableNonCopyable(MovableNonCopyable&amp;&amp;) = default;
265    MovableNonCopyable&amp; operator=(const MovableNonCopyable&amp;) = delete;
266    MovableNonCopyable&amp; operator=(MovableNonCopyable&amp;&amp;) = default;
267  };
268  struct NonCopyableOrMovable {
269    NonCopyableOrMovable() = default;
270    virtual ~NonCopyableOrMovable() = default;
271    NonCopyableOrMovable(const NonCopyableOrMovable&amp;) = delete;
272    NonCopyableOrMovable(NonCopyableOrMovable&amp;&amp;) = delete;
273    NonCopyableOrMovable&amp; operator=(const NonCopyableOrMovable&amp;) = delete;
274    NonCopyableOrMovable&amp; operator=(NonCopyableOrMovable&amp;&amp;) = delete;
275  };
276  class Base {
277   public:
278    virtual ~Base() {}
279  };
280  TEST(TypeTraitsTest, TestIsFunction) {
281    struct Callable {
282      void operator()() {}
283    };
284    EXPECT_TRUE(absl::is_function&lt;void()&gt;::value);
285    EXPECT_TRUE(absl::is_function&lt;void()&amp;&gt;::value);
286    EXPECT_TRUE(absl::is_function&lt;void() const&gt;::value);
287    EXPECT_TRUE(absl::is_function&lt;void() noexcept&gt;::value);
288    EXPECT_TRUE(absl::is_function&lt;void(...) noexcept&gt;::value);
289    EXPECT_FALSE(absl::is_function&lt;void(*)()&gt;::value);
290    EXPECT_FALSE(absl::is_function&lt;void(&amp;)()&gt;::value);
291    EXPECT_FALSE(absl::is_function&lt;int&gt;::value);
292    EXPECT_FALSE(absl::is_function&lt;Callable&gt;::value);
293  }
294  TEST(TypeTraitsTest, TestRemoveCVRef) {
295    EXPECT_TRUE(
296        (std::is_same&lt;typename absl::remove_cvref&lt;int&gt;::type, int&gt;::value));
297    EXPECT_TRUE(
298        (std::is_same&lt;typename absl::remove_cvref&lt;int&amp;&gt;::type, int&gt;::value));
299    EXPECT_TRUE(
300        (std::is_same&lt;typename absl::remove_cvref&lt;int&amp;&amp;&gt;::type, int&gt;::value));
301    EXPECT_TRUE((
302        std::is_same&lt;typename absl::remove_cvref&lt;const int&amp;&gt;::type, int&gt;::value));
303    EXPECT_TRUE(
304        (std::is_same&lt;typename absl::remove_cvref&lt;int*&gt;::type, int*&gt;::value));
305    EXPECT_TRUE((std::is_same&lt;typename absl::remove_cvref&lt;const int*&gt;::type,
306                              const int*&gt;::value));
307    EXPECT_TRUE((std::is_same&lt;typename absl::remove_cvref&lt;int[2]&gt;::type,
308                              int[2]&gt;::value));
309    EXPECT_TRUE((std::is_same&lt;typename absl::remove_cvref&lt;int(&amp;)[2]&gt;::type,
310                              int[2]&gt;::value));
311    EXPECT_TRUE((std::is_same&lt;typename absl::remove_cvref&lt;int(&amp;&amp;)[2]&gt;::type,
312                              int[2]&gt;::value));
313    EXPECT_TRUE((std::is_same&lt;typename absl::remove_cvref&lt;const int[2]&gt;::type,
314                              int[2]&gt;::value));
315    EXPECT_TRUE((std::is_same&lt;typename absl::remove_cvref&lt;const int(&amp;)[2]&gt;::type,
316                              int[2]&gt;::value));
317    EXPECT_TRUE((std::is_same&lt;typename absl::remove_cvref&lt;const int(&amp;&amp;)[2]&gt;::type,
318                              int[2]&gt;::value));
319  }
320  #define ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(trait_name, ...)          \
321    EXPECT_TRUE((std::is_same&lt;typename std::trait_name&lt;__VA_ARGS__&gt;::type, \
322                              absl::trait_name##_t&lt;__VA_ARGS__&gt;&gt;::value))
323  TEST(TypeTraitsTest, TestRemoveCVAliases) {
324    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_cv, int);
325    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_cv, const int);
326    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_cv, volatile int);
327    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_cv, const volatile int);
328    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_const, int);
329    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_const, const int);
330    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_const, volatile int);
331    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_const, const volatile int);
332    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_volatile, int);
333    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_volatile, const int);
334    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_volatile, volatile int);
335    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_volatile, const volatile int);
336  }
337  TEST(TypeTraitsTest, TestAddCVAliases) {
338    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_cv, int);
339    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_cv, const int);
340    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_cv, volatile int);
341    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_cv, const volatile int);
342    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_const, int);
343    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_const, const int);
344    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_const, volatile int);
345    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_const, const volatile int);
346    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_volatile, int);
347    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_volatile, const int);
348    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_volatile, volatile int);
349    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_volatile, const volatile int);
350  }
351  TEST(TypeTraitsTest, TestReferenceAliases) {
352    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_reference, int);
353    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_reference, volatile int);
354    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_reference, int&amp;);
355    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_reference, volatile int&amp;);
356    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_reference, int&amp;&amp;);
357    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_reference, volatile int&amp;&amp;);
358    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_lvalue_reference, int);
359    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_lvalue_reference, volatile int);
360    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_lvalue_reference, int&amp;);
361    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_lvalue_reference, volatile int&amp;);
362    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_lvalue_reference, int&amp;&amp;);
363    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_lvalue_reference, volatile int&amp;&amp;);
364    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_rvalue_reference, int);
365    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_rvalue_reference, volatile int);
366    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_rvalue_reference, int&amp;);
367    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_rvalue_reference, volatile int&amp;);
368    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_rvalue_reference, int&amp;&amp;);
369    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_rvalue_reference, volatile int&amp;&amp;);
370  }
371  TEST(TypeTraitsTest, TestPointerAliases) {
372    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_pointer, int*);
373    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_pointer, volatile int*);
374    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_pointer, int);
375    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(add_pointer, volatile int);
376  }
377  TEST(TypeTraitsTest, TestSignednessAliases) {
378    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(make_signed, int);
379    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(make_signed, volatile int);
380    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(make_signed, unsigned);
381    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(make_signed, volatile unsigned);
382    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(make_unsigned, int);
383    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(make_unsigned, volatile int);
384    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(make_unsigned, unsigned);
385    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(make_unsigned, volatile unsigned);
386  }
387  TEST(TypeTraitsTest, TestExtentAliases) {
388    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_extent, int[]);
389    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_extent, int[1]);
390    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_extent, int[1][1]);
391    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_extent, int[][1]);
392    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_all_extents, int[]);
393    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_all_extents, int[1]);
394    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_all_extents, int[1][1]);
395    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(remove_all_extents, int[][1]);
396  }
397  TEST(TypeTraitsTest, TestAlignedStorageAlias) {
398    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 1);
399    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 2);
400    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 3);
401    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 4);
402    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 5);
403    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 6);
404    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 7);
405    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 8);
406    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 9);
407    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 10);
408    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 11);
409    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 12);
410    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 13);
411    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 14);
412    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 15);
413    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 16);
414    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 17);
415    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 18);
416    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 19);
417    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 20);
418    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 21);
419    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 22);
420    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 23);
421    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 24);
422    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 25);
423    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 26);
424    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 27);
425    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 28);
426    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 29);
427    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 30);
428    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 31);
429    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 32);
430    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 33);
431    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 1, 128);
432    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 2, 128);
433    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 3, 128);
434    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 4, 128);
435    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 5, 128);
436    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 6, 128);
437    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 7, 128);
438    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 8, 128);
439    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 9, 128);
440    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 10, 128);
441    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 11, 128);
442    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 12, 128);
443    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 13, 128);
444    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 14, 128);
445    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 15, 128);
446    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 16, 128);
447    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 17, 128);
448    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 18, 128);
449    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 19, 128);
450    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 20, 128);
451    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 21, 128);
452    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 22, 128);
453    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 23, 128);
454    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 24, 128);
455    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 25, 128);
456    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 26, 128);
457    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 27, 128);
458    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 28, 128);
459    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 29, 128);
460    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 30, 128);
461    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 31, 128);
462    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 32, 128);
463    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(aligned_storage, 33, 128);
464  }
465  TEST(TypeTraitsTest, TestDecay) {
466    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(decay, int);
467    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(decay, const int);
468    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(decay, volatile int);
469    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(decay, const volatile int);
470    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(decay, int&amp;);
471    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(decay, const int&amp;);
472    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(decay, volatile int&amp;);
473    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(decay, const volatile int&amp;);
474    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(decay, int&amp;);
475    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(decay, const int&amp;);
476    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(decay, volatile int&amp;);
477    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(decay, const volatile int&amp;);
478    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(decay, int[1]);
479    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(decay, int[1][1]);
480    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(decay, int[][1]);
481    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(decay, int());
482    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(decay, int(float));  
483    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(decay, int(char, ...));  
484  }
485  struct TypeA {};
486  struct TypeB {};
487  struct TypeC {};
488  struct TypeD {};
489  template &lt;typename T&gt;
490  struct Wrap {};
491  enum class TypeEnum { A, B, C, D };
492  struct GetTypeT {
493    template &lt;typename T,
494              absl::enable_if_t&lt;std::is_same&lt;T, TypeA&gt;::value, int&gt; = 0&gt;
495    TypeEnum operator()(Wrap&lt;T&gt;) const {
496      return TypeEnum::A;
497    }
498    template &lt;typename T,
499              absl::enable_if_t&lt;std::is_same&lt;T, TypeB&gt;::value, int&gt; = 0&gt;
500    TypeEnum operator()(Wrap&lt;T&gt;) const {
501      return TypeEnum::B;
502    }
503    template &lt;typename T,
504              absl::enable_if_t&lt;std::is_same&lt;T, TypeC&gt;::value, int&gt; = 0&gt;
505    TypeEnum operator()(Wrap&lt;T&gt;) const {
506      return TypeEnum::C;
507    }
508  } constexpr GetType = {};
509  TEST(TypeTraitsTest, TestEnableIf) {
510    EXPECT_EQ(TypeEnum::A, GetType(Wrap&lt;TypeA&gt;()));
511    EXPECT_EQ(TypeEnum::B, GetType(Wrap&lt;TypeB&gt;()));
512    EXPECT_EQ(TypeEnum::C, GetType(Wrap&lt;TypeC&gt;()));
513  }
514  TEST(TypeTraitsTest, TestConditional) {
515    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(conditional, true, int, char);
516    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(conditional, false, int, char);
517  }
518  TEST(TypeTraitsTest, TestCommonType) {
519    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(common_type, int);
520    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(common_type, int, char);
521    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(common_type, int, char, int);
522    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(common_type, int&amp;);
523    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(common_type, int, char&amp;);
524    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(common_type, int, char, int&amp;);
525  }
526  TEST(TypeTraitsTest, TestUnderlyingType) {
527    enum class enum_char : char {};
528    enum class enum_long_long : long long {};  
529    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(underlying_type, enum_char);
530    ABSL_INTERNAL_EXPECT_ALIAS_EQUIVALENCE(underlying_type, enum_long_long);
531  }
532  struct GetTypeExtT {
533    template &lt;typename T&gt;
534    absl::result_of_t&lt;const GetTypeT&amp;(T)&gt; operator()(T&amp;&amp; arg) const {
535      return GetType(std::forward&lt;T&gt;(arg));
536    }
537    TypeEnum operator()(Wrap&lt;TypeD&gt;) const { return TypeEnum::D; }
538  } constexpr GetTypeExt = {};
539  TEST(TypeTraitsTest, TestResultOf) {
540    EXPECT_EQ(TypeEnum::A, GetTypeExt(Wrap&lt;TypeA&gt;()));
541    EXPECT_EQ(TypeEnum::B, GetTypeExt(Wrap&lt;TypeB&gt;()));
542    EXPECT_EQ(TypeEnum::C, GetTypeExt(Wrap&lt;TypeC&gt;()));
543    EXPECT_EQ(TypeEnum::D, GetTypeExt(Wrap&lt;TypeD&gt;()));
544  }
545  namespace adl_namespace {
546  struct DeletedSwap {
547  };
548  void swap(DeletedSwap&amp;, DeletedSwap&amp;) = delete;
549  struct SpecialNoexceptSwap {
550    SpecialNoexceptSwap(SpecialNoexceptSwap&amp;&amp;) {}
551    SpecialNoexceptSwap&amp; operator=(SpecialNoexceptSwap&amp;&amp;) { return *this; }
552    ~SpecialNoexceptSwap() = default;
553  };
554  void swap(SpecialNoexceptSwap&amp;, SpecialNoexceptSwap&amp;) noexcept {}
555  }  
556  TEST(TypeTraitsTest, IsSwappable) {
557    using absl::type_traits_internal::IsSwappable;
558    using absl::type_traits_internal::StdSwapIsUnconstrained;
559    EXPECT_TRUE(IsSwappable&lt;int&gt;::value);
560    struct S {};
561    EXPECT_TRUE(IsSwappable&lt;S&gt;::value);
562    struct NoConstruct {
563      NoConstruct(NoConstruct&amp;&amp;) = delete;
564      NoConstruct&amp; operator=(NoConstruct&amp;&amp;) { return *this; }
565      ~NoConstruct() = default;
566    };
567    EXPECT_EQ(IsSwappable&lt;NoConstruct&gt;::value, StdSwapIsUnconstrained::value);
568    struct NoAssign {
569      NoAssign(NoAssign&amp;&amp;) {}
570      NoAssign&amp; operator=(NoAssign&amp;&amp;) = delete;
571      ~NoAssign() = default;
572    };
573    EXPECT_EQ(IsSwappable&lt;NoAssign&gt;::value, StdSwapIsUnconstrained::value);
574    EXPECT_FALSE(IsSwappable&lt;adl_namespace::DeletedSwap&gt;::value);
575    EXPECT_TRUE(IsSwappable&lt;adl_namespace::SpecialNoexceptSwap&gt;::value);
576  }
577  TEST(TypeTraitsTest, IsNothrowSwappable) {
578    using absl::type_traits_internal::IsNothrowSwappable;
579    using absl::type_traits_internal::StdSwapIsUnconstrained;
580    EXPECT_TRUE(IsNothrowSwappable&lt;int&gt;::value);
581    struct NonNoexceptMoves {
582      NonNoexceptMoves(NonNoexceptMoves&amp;&amp;) {}
583      NonNoexceptMoves&amp; operator=(NonNoexceptMoves&amp;&amp;) { return *this; }
584      ~NonNoexceptMoves() = default;
585    };
586    EXPECT_FALSE(IsNothrowSwappable&lt;NonNoexceptMoves&gt;::value);
587    struct NoConstruct {
588      NoConstruct(NoConstruct&amp;&amp;) = delete;
589      NoConstruct&amp; operator=(NoConstruct&amp;&amp;) { return *this; }
590      ~NoConstruct() = default;
591    };
592    EXPECT_FALSE(IsNothrowSwappable&lt;NoConstruct&gt;::value);
593    struct NoAssign {
594      NoAssign(NoAssign&amp;&amp;) {}
595      NoAssign&amp; operator=(NoAssign&amp;&amp;) = delete;
596      ~NoAssign() = default;
597    };
598    EXPECT_FALSE(IsNothrowSwappable&lt;NoAssign&gt;::value);
599    EXPECT_FALSE(IsNothrowSwappable&lt;adl_namespace::DeletedSwap&gt;::value);
600    EXPECT_TRUE(IsNothrowSwappable&lt;adl_namespace::SpecialNoexceptSwap&gt;::value);
601  }
602  TEST(TriviallyRelocatable, PrimitiveTypes) {
603    static_assert(absl::is_trivially_relocatable&lt;int&gt;::value, &quot;&quot;);
604    static_assert(absl::is_trivially_relocatable&lt;char&gt;::value, &quot;&quot;);
605    static_assert(absl::is_trivially_relocatable&lt;void*&gt;::value, &quot;&quot;);
606  }
607  TEST(TriviallyRelocatable, UserDefinedTriviallyReconstructible) {
608    struct S {
609      int x;
610      int y;
611    };
612    static_assert(absl::is_trivially_relocatable&lt;S&gt;::value, &quot;&quot;);
613  }
614  TEST(TriviallyRelocatable, UserProvidedMoveConstructor) {
615    struct S {
616      S(S&amp;&amp;) {}  
617    };
618    static_assert(!absl::is_trivially_relocatable&lt;S&gt;::value, &quot;&quot;);
619  }
620  TEST(TriviallyRelocatable, UserProvidedCopyConstructor) {
621    struct S {
622      S(const S&amp;) {}  
623    };
624    static_assert(!absl::is_trivially_relocatable&lt;S&gt;::value, &quot;&quot;);
625  }
626  TEST(TriviallyRelocatable, UserProvidedDestructor) {
627    struct S {
628      ~S() {}  
629    };
630    static_assert(!absl::is_trivially_relocatable&lt;S&gt;::value, &quot;&quot;);
631  }
632  #if defined(ABSL_HAVE_ATTRIBUTE_TRIVIAL_ABI) &amp;&amp;      \
633      ABSL_HAVE_BUILTIN(__is_trivially_relocatable) &amp;&amp; \
634      !(defined(__clang__) &amp;&amp; (defined(_WIN32) || defined(_WIN64)))
635  TEST(TrivallyRelocatable, TrivialAbi) {
636    struct ABSL_ATTRIBUTE_TRIVIAL_ABI S {
637      S(S&amp;&amp;) {}       
638      S(const S&amp;) {}  
639      ~S() {}         
640    };
641    static_assert(absl::is_trivially_relocatable&lt;S&gt;::value, &quot;&quot;);
642  }
643  #endif
644  #ifdef ABSL_HAVE_CONSTANT_EVALUATED
645  constexpr int64_t NegateIfConstantEvaluated(int64_t i) {
646    if (absl::is_constant_evaluated()) {
647      return -i;
648    } else {
649      return i;
650    }
651  }
652  #endif  
653  TEST(TrivallyRelocatable, is_constant_evaluated) {
654  #ifdef ABSL_HAVE_CONSTANT_EVALUATED
655    constexpr int64_t constant = NegateIfConstantEvaluated(42);
656    EXPECT_EQ(constant, -42);
657    int64_t now = absl::ToUnixSeconds(absl::Now());
658    int64_t not_constant = NegateIfConstantEvaluated(now);
659    EXPECT_EQ(not_constant, now);
660    static int64_t const_init = NegateIfConstantEvaluated(42);
661    EXPECT_EQ(const_init, -42);
662  #else
663    GTEST_SKIP() &lt;&lt; &quot;absl::is_constant_evaluated is not defined&quot;;
664  #endif  
665  }
666  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-type_traits_test.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-type_traits_test.cc</div>
                </div>
                <div class="column column_space"><pre><code>227      n_ = t.n_;
228      return *this;
229    }
230   private:
231    int n_;
232  };
233  class TrivialCopyAssign {
234   public:
235    explicit TrivialCopyAssign(int n) : n_(n) {}
236    TrivialCopyAssign(const TrivialCopyAssign&amp; t) : n_(t.n_) {}
</pre></code></div>
                <div class="column column_space"><pre><code>247      n_ = t.n_;
248      return *this;
249    }
250   private:
251    int n_;
252  };
253  class DeletedCopyAssign {
254   public:
255    explicit DeletedCopyAssign(int n) : n_(n) {}
256    DeletedCopyAssign(const DeletedCopyAssign&amp;) = default;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    