
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 5.032169117647059%, Tokens: 9</h2>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-gmock-matchers.h</h3>
            <pre><code>1  #ifndef GMOCK_INCLUDE_GMOCK_GMOCK_MATCHERS_H_
2  #define GMOCK_INCLUDE_GMOCK_GMOCK_MATCHERS_H_
3  #include <math.h>
4  #include <algorithm>
5  #include <iterator>
6  #include <limits>
7  #include <ostream>  
8  #include <sstream>
9  #include <string>
10  #include <utility>
11  #include <vector>
12  #include "gmock/internal/gmock-internal-utils.h"
13  #include "gmock/internal/gmock-port.h"
14  #include "gtest/gtest.h"
15  #if GTEST_LANG_CXX11
16  #include <initializer_list>  
17  #endif
18  namespace testing {
19  class MatchResultListener {
20   public:
21    explicit MatchResultListener(::std::ostream* os) : stream_(os) {}
22    virtual ~MatchResultListener() = 0;  
23    template <typename T>
24    MatchResultListener& operator<<(const T& x) {
25      if (stream_ != NULL)
26        *stream_ << x;
27      return *this;
28    }
29    ::std::ostream* stream() { return stream_; }
30    bool IsInterested() const { return stream_ != NULL; }
31   private:
32    ::std::ostream* const stream_;
33    GTEST_DISALLOW_COPY_AND_ASSIGN_(MatchResultListener);
34  };
35  inline MatchResultListener::~MatchResultListener() {
36  }
37  class MatcherDescriberInterface {
38   public:
39    virtual ~MatcherDescriberInterface() {}
40    virtual void DescribeTo(::std::ostream* os) const = 0;
41    virtual void DescribeNegationTo(::std::ostream* os) const {
42      *os << "not (";
43      DescribeTo(os);
44      *os << ")";
45    }
46  };
47  template <typename T>
48  class MatcherInterface : public MatcherDescriberInterface {
49   public:
50    virtual bool MatchAndExplain(T x, MatchResultListener* listener) const = 0;
51  };
52  class StringMatchResultListener : public MatchResultListener {
53   public:
54    StringMatchResultListener() : MatchResultListener(&ss_) {}
55    internal::string str() const { return ss_.str(); }
56    void Clear() { ss_.str(""); }
57   private:
58    ::std::stringstream ss_;
59    GTEST_DISALLOW_COPY_AND_ASSIGN_(StringMatchResultListener);
60  };
61  namespace internal {
62  class DummyMatchResultListener : public MatchResultListener {
63   public:
64    DummyMatchResultListener() : MatchResultListener(NULL) {}
65   private:
66    GTEST_DISALLOW_COPY_AND_ASSIGN_(DummyMatchResultListener);
67  };
68  class StreamMatchResultListener : public MatchResultListener {
69   public:
70    explicit StreamMatchResultListener(::std::ostream* os)
71        : MatchResultListener(os) {}
72   private:
73    GTEST_DISALLOW_COPY_AND_ASSIGN_(StreamMatchResultListener);
74  };
75  template <typename T>
76  class MatcherBase {
77   public:
78    bool MatchAndExplain(T x, MatchResultListener* listener) const {
79      return impl_->MatchAndExplain(x, listener);
80    }
81    bool Matches(T x) const {
82      DummyMatchResultListener dummy;
83      return MatchAndExplain(x, &dummy);
84    }
85    void DescribeTo(::std::ostream* os) const { impl_->DescribeTo(os); }
86    void DescribeNegationTo(::std::ostream* os) const {
87      impl_->DescribeNegationTo(os);
88    }
89    void ExplainMatchResultTo(T x, ::std::ostream* os) const {
90      StreamMatchResultListener listener(os);
91      MatchAndExplain(x, &listener);
92    }
93    const MatcherDescriberInterface* GetDescriber() const {
94      return impl_.get();
95    }
96   protected:
97    MatcherBase() {}
98    explicit MatcherBase(const MatcherInterface<T>* impl)
99        : impl_(impl) {}
100    virtual ~MatcherBase() {}
101   private:
102    ::testing::internal::linked_ptr<const MatcherInterface<T> > impl_;
103  };
104  }  
105  template <typename T>
106  class Matcher : public internal::MatcherBase<T> {
107   public:
108    Matcher() {}
109    explicit Matcher(const MatcherInterface<T>* impl)
110        : internal::MatcherBase<T>(impl) {}
111    Matcher(T value);  
112  };
113  template <>
114  class GTEST_API_ Matcher<const internal::string&>
115      : public internal::MatcherBase<const internal::string&> {
116   public:
117    Matcher() {}
118    explicit Matcher(const MatcherInterface<const internal::string&>* impl)
119        : internal::MatcherBase<const internal::string&>(impl) {}
120    Matcher(const internal::string& s);  
121    Matcher(const char* s);  
122  };
123  template <>
124  class GTEST_API_ Matcher<internal::string>
125      : public internal::MatcherBase<internal::string> {
126   public:
127    Matcher() {}
128    explicit Matcher(const MatcherInterface<internal::string>* impl)
129        : internal::MatcherBase<internal::string>(impl) {}
130    Matcher(const internal::string& s);  
131    Matcher(const char* s);  
132  };
133  #if GTEST_HAS_STRING_PIECE_
134  template <>
135  class GTEST_API_ Matcher<const StringPiece&>
136      : public internal::MatcherBase<const StringPiece&> {
137   public:
138    Matcher() {}
139    explicit Matcher(const MatcherInterface<const StringPiece&>* impl)
140        : internal::MatcherBase<const StringPiece&>(impl) {}
141    Matcher(const internal::string& s);  
142    Matcher(const char* s);  
143    Matcher(StringPiece s);  
144  };
145  template <>
146  class GTEST_API_ Matcher<StringPiece>
147      : public internal::MatcherBase<StringPiece> {
148   public:
149    Matcher() {}
150    explicit Matcher(const MatcherInterface<StringPiece>* impl)
151        : internal::MatcherBase<StringPiece>(impl) {}
152    Matcher(const internal::string& s);  
153    Matcher(const char* s);  
154    Matcher(StringPiece s);  
155  };
156  #endif  
157  template <class Impl>
158  class PolymorphicMatcher {
159   public:
160    explicit PolymorphicMatcher(const Impl& an_impl) : impl_(an_impl) {}
161    Impl& mutable_impl() { return impl_; }
162    const Impl& impl() const { return impl_; }
163    template <typename T>
164    operator Matcher<T>() const {
165      return Matcher<T>(new MonomorphicImpl<T>(impl_));
166    }
167   private:
168    template <typename T>
169    class MonomorphicImpl : public MatcherInterface<T> {
170     public:
171      explicit MonomorphicImpl(const Impl& impl) : impl_(impl) {}
172      virtual void DescribeTo(::std::ostream* os) const {
173        impl_.DescribeTo(os);
174      }
175      virtual void DescribeNegationTo(::std::ostream* os) const {
176        impl_.DescribeNegationTo(os);
177      }
178      virtual bool MatchAndExplain(T x, MatchResultListener* listener) const {
179        return impl_.MatchAndExplain(x, listener);
180      }
181     private:
182      const Impl impl_;
183      GTEST_DISALLOW_ASSIGN_(MonomorphicImpl);
184    };
185    Impl impl_;
186    GTEST_DISALLOW_ASSIGN_(PolymorphicMatcher);
187  };
188  template <typename T>
189  inline Matcher<T> MakeMatcher(const MatcherInterface<T>* impl) {
190    return Matcher<T>(impl);
191  }
192  template <class Impl>
193  inline PolymorphicMatcher<Impl> MakePolymorphicMatcher(const Impl& impl) {
194    return PolymorphicMatcher<Impl>(impl);
195  }
196  namespace internal {
197  template <typename T, typename M>
198  class MatcherCastImpl {
199   public:
200    static Matcher<T> Cast(M polymorphic_matcher_or_value) {
201      return CastImpl(
202          polymorphic_matcher_or_value,
203          BooleanConstant<
204              internal::ImplicitlyConvertible<M, Matcher<T> >::value>());
205    }
206   private:
207    static Matcher<T> CastImpl(M value, BooleanConstant<false>) {
208      return Matcher<T>(ImplicitCast_<T>(value));
209    }
210    static Matcher<T> CastImpl(M polymorphic_matcher_or_value,
211                               BooleanConstant<true>) {
212      return polymorphic_matcher_or_value;
213    }
214  };
215  template <typename T, typename U>
216  class MatcherCastImpl<T, Matcher<U> > {
217   public:
218    static Matcher<T> Cast(const Matcher<U>& source_matcher) {
219      return Matcher<T>(new Impl(source_matcher));
220    }
221   private:
222    class Impl : public MatcherInterface<T> {
223     public:
224      explicit Impl(const Matcher<U>& source_matcher)
225          : source_matcher_(source_matcher) {}
226      virtual bool MatchAndExplain(T x, MatchResultListener* listener) const {
227        return source_matcher_.MatchAndExplain(static_cast<U>(x), listener);
228      }
229      virtual void DescribeTo(::std::ostream* os) const {
230        source_matcher_.DescribeTo(os);
231      }
232      virtual void DescribeNegationTo(::std::ostream* os) const {
233        source_matcher_.DescribeNegationTo(os);
234      }
235     private:
236      const Matcher<U> source_matcher_;
237      GTEST_DISALLOW_ASSIGN_(Impl);
238    };
239  };
240  template <typename T>
241  class MatcherCastImpl<T, Matcher<T> > {
242   public:
243    static Matcher<T> Cast(const Matcher<T>& matcher) { return matcher; }
244  };
245  }  
246  template <typename T, typename M>
247  inline Matcher<T> MatcherCast(M matcher) {
248    return internal::MatcherCastImpl<T, M>::Cast(matcher);
249  }
250  template <typename T>
251  class SafeMatcherCastImpl {
252   public:
253    template <typename M>
254    static inline Matcher<T> Cast(M polymorphic_matcher_or_value) {
255      return internal::MatcherCastImpl<T, M>::Cast(polymorphic_matcher_or_value);
256    }
257    template <typename U>
258    static inline Matcher<T> Cast(const Matcher<U>& matcher) {
259      GTEST_COMPILE_ASSERT_((internal::ImplicitlyConvertible<T, U>::value),
260                            T_must_be_implicitly_convertible_to_U);
261      GTEST_COMPILE_ASSERT_(
262          internal::is_reference<T>::value || !internal::is_reference<U>::value,
263          cannot_convert_non_referentce_arg_to_reference);
264      typedef GTEST_REMOVE_REFERENCE_AND_CONST_(T) RawT;
265      typedef GTEST_REMOVE_REFERENCE_AND_CONST_(U) RawU;
266      const bool kTIsOther = GMOCK_KIND_OF_(RawT) == internal::kOther;
267      const bool kUIsOther = GMOCK_KIND_OF_(RawU) == internal::kOther;
268      GTEST_COMPILE_ASSERT_(
269          kTIsOther || kUIsOther ||
270          (internal::LosslessArithmeticConvertible<RawT, RawU>::value),
271          conversion_of_arithmetic_types_must_be_lossless);
272      return MatcherCast<T>(matcher);
273    }
274  };
275  template <typename T, typename M>
276  inline Matcher<T> SafeMatcherCast(const M& polymorphic_matcher) {
277    return SafeMatcherCastImpl<T>::Cast(polymorphic_matcher);
278  }
279  template <typename T>
280  Matcher<T> A();
281  namespace internal {
282  inline void PrintIfNotEmpty(const internal::string& explanation,
283                              ::std::ostream* os) {
284    if (explanation != "" && os != NULL) {
285      *os << ", " << explanation;
286    }
287  }
288  inline bool IsReadableTypeName(const string& type_name) {
289    return (type_name.length() <= 20 ||
290            type_name.find_first_of("<(") == string::npos);
291  }
292  template <typename Value, typename T>
293  bool MatchPrintAndExplain(Value& value, const Matcher<T>& matcher,
294                            MatchResultListener* listener) {
295    if (!listener->IsInterested()) {
296      return matcher.Matches(value);
297    }
298    StringMatchResultListener inner_listener;
299    const bool match = matcher.MatchAndExplain(value, &inner_listener);
300    UniversalPrint(value, listener->stream());
301  #if GTEST_HAS_RTTI
302    const string& type_name = GetTypeName<Value>();
303    if (IsReadableTypeName(type_name))
304      *listener->stream() << " (of type " << type_name << ")";
305  #endif
306    PrintIfNotEmpty(inner_listener.str(), listener->stream());
307    return match;
308  }
309  template <size_t N>
310  class TuplePrefix {
311   public:
312    template <typename MatcherTuple, typename ValueTuple>
313    static bool Matches(const MatcherTuple& matcher_tuple,
314                        const ValueTuple& value_tuple) {
315      using ::std::tr1::get;
316      return TuplePrefix<N - 1>::Matches(matcher_tuple, value_tuple)
317          && get<N - 1>(matcher_tuple).Matches(get<N - 1>(value_tuple));
318    }
319    template <typename MatcherTuple, typename ValueTuple>
320    static void ExplainMatchFailuresTo(const MatcherTuple& matchers,
321                                       const ValueTuple& values,
322                                       ::std::ostream* os) {
323      using ::std::tr1::tuple_element;
324      using ::std::tr1::get;
325      TuplePrefix<N - 1>::ExplainMatchFailuresTo(matchers, values, os);
326      typename tuple_element<N - 1, MatcherTuple>::type matcher =
327          get<N - 1>(matchers);
328      typedef typename tuple_element<N - 1, ValueTuple>::type Value;
329      Value value = get<N - 1>(values);
330      StringMatchResultListener listener;
331      if (!matcher.MatchAndExplain(value, &listener)) {
332        *os << "  Expected arg #" << N - 1 << ": ";
333        get<N - 1>(matchers).DescribeTo(os);
334        *os << "\n           Actual: ";
335        internal::UniversalPrint(value, os);
336        PrintIfNotEmpty(listener.str(), os);
337        *os << "\n";
338      }
339    }
340  };
341  template <>
342  class TuplePrefix<0> {
343   public:
344    template <typename MatcherTuple, typename ValueTuple>
345    static bool Matches(const MatcherTuple& &bsol;* matcher_tuple */,
346                        const ValueTuple& &bsol;* value_tuple */) {
347      return true;
348    }
349    template <typename MatcherTuple, typename ValueTuple>
350    static void ExplainMatchFailuresTo(const MatcherTuple& &bsol;* matchers */,
351                                       const ValueTuple& &bsol;* values */,
352                                       ::std::ostream* &bsol;* os */) {}
353  };
354  template <typename MatcherTuple, typename ValueTuple>
355  bool TupleMatches(const MatcherTuple& matcher_tuple,
356                    const ValueTuple& value_tuple) {
357    using ::std::tr1::tuple_size;
358    GTEST_COMPILE_ASSERT_(tuple_size<MatcherTuple>::value ==
359                          tuple_size<ValueTuple>::value,
360                          matcher_and_value_have_different_numbers_of_fields);
361    return TuplePrefix<tuple_size<ValueTuple>::value>::
362        Matches(matcher_tuple, value_tuple);
363  }
364  template <typename MatcherTuple, typename ValueTuple>
365  void ExplainMatchFailureTupleTo(const MatcherTuple& matchers,
366                                  const ValueTuple& values,
367                                  ::std::ostream* os) {
368    using ::std::tr1::tuple_size;
369    TuplePrefix<tuple_size<MatcherTuple>::value>::ExplainMatchFailuresTo(
370        matchers, values, os);
371  }
372  template <typename Tuple, typename Func, typename OutIter>
373  class TransformTupleValuesHelper {
374   private:
375    typedef typename ::std::tr1::tuple_size<Tuple> TupleSize;
376   public:
377    static OutIter Run(Func f, const Tuple& t, OutIter out) {
378      return IterateOverTuple<Tuple, TupleSize::value>()(f, t, out);
379    }
380   private:
381    template <typename Tup, size_t kRemainingSize>
382    struct IterateOverTuple {
383      OutIter operator() (Func f, const Tup& t, OutIter out) const {
384        *out++ = f(::std::tr1::get<TupleSize::value - kRemainingSize>(t));
385        return IterateOverTuple<Tup, kRemainingSize - 1>()(f, t, out);
386      }
387    };
388    template <typename Tup>
389    struct IterateOverTuple<Tup, 0> {
390      OutIter operator() (Func &bsol;* f */, const Tup& &bsol;* t */, OutIter out) const {
391        return out;
392      }
393    };
394  };
395  template <typename Tuple, typename Func, typename OutIter>
396  OutIter TransformTupleValues(Func f, const Tuple& t, OutIter out) {
397    return TransformTupleValuesHelper<Tuple, Func, OutIter>::Run(f, t, out);
398  }
399  template <typename T>
400  class AnyMatcherImpl : public MatcherInterface<T> {
401   public:
402    virtual bool MatchAndExplain(
403        T &bsol;* x */, MatchResultListener* &bsol;* listener */) const { return true; }
404    virtual void DescribeTo(::std::ostream* os) const { *os << "is anything"; }
405    virtual void DescribeNegationTo(::std::ostream* os) const {
406      *os << "never matches";
407    }
408  };
409  class AnythingMatcher {
410   public:
411    template <typename T>
412    operator Matcher<T>() const { return A<T>(); }
413  };
414  #define GMOCK_IMPLEMENT_COMPARISON_MATCHER_( \
415      name, op, relation, negated_relation) \
416    template <typename Rhs> class name##Matcher { \
417     public: \
418      explicit name##Matcher(const Rhs& rhs) : rhs_(rhs) {} \
419      template <typename Lhs> \
420      operator Matcher<Lhs>() const { \
421        return MakeMatcher(new Impl<Lhs>(rhs_)); \
422      } \
423     private: \
424      template <typename Lhs> \
425      class Impl : public MatcherInterface<Lhs> { \
426       public: \
427        explicit Impl(const Rhs& rhs) : rhs_(rhs) {} \
428        virtual bool MatchAndExplain(\
429            Lhs lhs, MatchResultListener* &bsol;* listener */) const { \
430          return lhs op rhs_; \
431        } \
432        virtual void DescribeTo(::std::ostream* os) const { \
433          *os << relation  " "; \
434          UniversalPrint(rhs_, os); \
435        } \
436        virtual void DescribeNegationTo(::std::ostream* os) const { \
437          *os << negated_relation  " "; \
438          UniversalPrint(rhs_, os); \
439        } \
440       private: \
441        Rhs rhs_; \
442        GTEST_DISALLOW_ASSIGN_(Impl); \
443      }; \
444      Rhs rhs_; \
445      GTEST_DISALLOW_ASSIGN_(name##Matcher); \
446    }
447  GMOCK_IMPLEMENT_COMPARISON_MATCHER_(Eq, ==, "is equal to", "isn't equal to");
448  GMOCK_IMPLEMENT_COMPARISON_MATCHER_(Ge, >=, "is >=", "isn't >=");
449  GMOCK_IMPLEMENT_COMPARISON_MATCHER_(Gt, >, "is >", "isn't >");
450  GMOCK_IMPLEMENT_COMPARISON_MATCHER_(Le, <=, "is <=", "isn't <=");
451  GMOCK_IMPLEMENT_COMPARISON_MATCHER_(Lt, <, "is <", "isn't <");
452  GMOCK_IMPLEMENT_COMPARISON_MATCHER_(Ne, !=, "isn't equal to", "is equal to");
453  #undef GMOCK_IMPLEMENT_COMPARISON_MATCHER_
454  class IsNullMatcher {
455   public:
456    template <typename Pointer>
457    bool MatchAndExplain(const Pointer& p,
458                         MatchResultListener* &bsol;* listener */) const {
459      return GetRawPointer(p) == NULL;
460    }
461    void DescribeTo(::std::ostream* os) const { *os << "is NULL"; }
462    void DescribeNegationTo(::std::ostream* os) const {
463      *os << "isn't NULL";
464    }
465  };
466  class NotNullMatcher {
467   public:
468    template <typename Pointer>
469    bool MatchAndExplain(const Pointer& p,
470                         MatchResultListener* &bsol;* listener */) const {
471      return GetRawPointer(p) != NULL;
472    }
473    void DescribeTo(::std::ostream* os) const { *os << "isn't NULL"; }
474    void DescribeNegationTo(::std::ostream* os) const {
475      *os << "is NULL";
476    }
477  };
478  template <typename T>
479  class RefMatcher;
480  template <typename T>
481  class RefMatcher<T&> {
482   public:
483    explicit RefMatcher(T& x) : object_(x) {}  
484    template <typename Super>
485    operator Matcher<Super&>() const {
486      return MakeMatcher(new Impl<Super>(object_));
487    }
488   private:
489    template <typename Super>
490    class Impl : public MatcherInterface<Super&> {
491     public:
492      explicit Impl(Super& x) : object_(x) {}  
493      virtual bool MatchAndExplain(
494          Super& x, MatchResultListener* listener) const {
495        *listener << "which is located @" << static_cast<const void*>(&x);
496        return &x == &object_;
497      }
498      virtual void DescribeTo(::std::ostream* os) const {
499        *os << "references the variable ";
500        UniversalPrinter<Super&>::Print(object_, os);
501      }
502      virtual void DescribeNegationTo(::std::ostream* os) const {
503        *os << "does not reference the variable ";
504        UniversalPrinter<Super&>::Print(object_, os);
505      }
506     private:
507      const Super& object_;
508      GTEST_DISALLOW_ASSIGN_(Impl);
509    };
510    T& object_;
511    GTEST_DISALLOW_ASSIGN_(RefMatcher);
512  };
513  inline bool CaseInsensitiveCStringEquals(const char* lhs, const char* rhs) {
514    return String::CaseInsensitiveCStringEquals(lhs, rhs);
515  }
516  inline bool CaseInsensitiveCStringEquals(const wchar_t* lhs,
517                                           const wchar_t* rhs) {
518    return String::CaseInsensitiveWideCStringEquals(lhs, rhs);
519  }
520  template <typename StringType>
521  bool CaseInsensitiveStringEquals(const StringType& s1,
522                                   const StringType& s2) {
523    if (!CaseInsensitiveCStringEquals(s1.c_str(), s2.c_str())) {
524      return false;
525    }
526    const typename StringType::value_type nul = 0;
527    const size_t i1 = s1.find(nul), i2 = s2.find(nul);
528    if (i1 == StringType::npos || i2 == StringType::npos) {
529      return i1 == i2;
530    }
531    return CaseInsensitiveStringEquals(s1.substr(i1 + 1), s2.substr(i2 + 1));
532  }
533  template <typename StringType>
534  class StrEqualityMatcher {
535   public:
536    StrEqualityMatcher(const StringType& str, bool expect_eq,
537                       bool case_sensitive)
538        : string_(str), expect_eq_(expect_eq), case_sensitive_(case_sensitive) {}
539    template <typename CharType>
540    bool MatchAndExplain(CharType* s, MatchResultListener* listener) const {
541      if (s == NULL) {
542        return !expect_eq_;
543      }
544      return MatchAndExplain(StringType(s), listener);
545    }
546    template <typename MatcheeStringType>
547    bool MatchAndExplain(const MatcheeStringType& s,
548                         MatchResultListener* &bsol;* listener */) const {
549      const StringType& s2(s);
550      const bool eq = case_sensitive_ ? s2 == string_ :
551          CaseInsensitiveStringEquals(s2, string_);
552      return expect_eq_ == eq;
553    }
554    void DescribeTo(::std::ostream* os) const {
555      DescribeToHelper(expect_eq_, os);
556    }
557    void DescribeNegationTo(::std::ostream* os) const {
558      DescribeToHelper(!expect_eq_, os);
559    }
560   private:
561    void DescribeToHelper(bool expect_eq, ::std::ostream* os) const {
562      *os << (expect_eq ? "is " : "isn't ");
563      *os << "equal to ";
564      if (!case_sensitive_) {
565        *os << "(ignoring case) ";
566      }
567      UniversalPrint(string_, os);
568    }
569    const StringType string_;
570    const bool expect_eq_;
571    const bool case_sensitive_;
572    GTEST_DISALLOW_ASSIGN_(StrEqualityMatcher);
573  };
574  template <typename StringType>
575  class HasSubstrMatcher {
576   public:
577    explicit HasSubstrMatcher(const StringType& substring)
578        : substring_(substring) {}
579    template <typename CharType>
580    bool MatchAndExplain(CharType* s, MatchResultListener* listener) const {
581      return s != NULL && MatchAndExplain(StringType(s), listener);
582    }
583    template <typename MatcheeStringType>
584    bool MatchAndExplain(const MatcheeStringType& s,
585                         MatchResultListener* &bsol;* listener */) const {
586      const StringType& s2(s);
587      return s2.find(substring_) != StringType::npos;
588    }
589    void DescribeTo(::std::ostream* os) const {
590      *os << "has substring ";
591      UniversalPrint(substring_, os);
592    }
593    void DescribeNegationTo(::std::ostream* os) const {
594      *os << "has no substring ";
595      UniversalPrint(substring_, os);
596    }
597   private:
598    const StringType substring_;
599    GTEST_DISALLOW_ASSIGN_(HasSubstrMatcher);
600  };
601  template <typename StringType>
602  class StartsWithMatcher {
603   public:
604    explicit StartsWithMatcher(const StringType& prefix) : prefix_(prefix) {
605    }
606    template <typename CharType>
607    bool MatchAndExplain(CharType* s, MatchResultListener* listener) const {
608      return s != NULL && MatchAndExplain(StringType(s), listener);
609    }
610    template <typename MatcheeStringType>
611    bool MatchAndExplain(const MatcheeStringType& s,
612                         MatchResultListener* &bsol;* listener */) const {
613      const StringType& s2(s);
614      return s2.length() >= prefix_.length() &&
615          s2.substr(0, prefix_.length()) == prefix_;
616    }
617    void DescribeTo(::std::ostream* os) const {
618      *os << "starts with ";
619      UniversalPrint(prefix_, os);
620    }
621    void DescribeNegationTo(::std::ostream* os) const {
622      *os << "doesn't start with ";
623      UniversalPrint(prefix_, os);
624    }
625   private:
626    const StringType prefix_;
627    GTEST_DISALLOW_ASSIGN_(StartsWithMatcher);
628  };
629  template <typename StringType>
630  class EndsWithMatcher {
631   public:
632    explicit EndsWithMatcher(const StringType& suffix) : suffix_(suffix) {}
633    template <typename CharType>
634    bool MatchAndExplain(CharType* s, MatchResultListener* listener) const {
635      return s != NULL && MatchAndExplain(StringType(s), listener);
636    }
637    template <typename MatcheeStringType>
638    bool MatchAndExplain(const MatcheeStringType& s,
639                         MatchResultListener* &bsol;* listener */) const {
640      const StringType& s2(s);
641      return s2.length() >= suffix_.length() &&
642          s2.substr(s2.length() - suffix_.length()) == suffix_;
643    }
644    void DescribeTo(::std::ostream* os) const {
645      *os << "ends with ";
646      UniversalPrint(suffix_, os);
647    }
648    void DescribeNegationTo(::std::ostream* os) const {
649      *os << "doesn't end with ";
650      UniversalPrint(suffix_, os);
651    }
652   private:
653    const StringType suffix_;
654    GTEST_DISALLOW_ASSIGN_(EndsWithMatcher);
655  };
656  class MatchesRegexMatcher {
657   public:
658    MatchesRegexMatcher(const RE* regex, bool full_match)
659        : regex_(regex), full_match_(full_match) {}
660    template <typename CharType>
661    bool MatchAndExplain(CharType* s, MatchResultListener* listener) const {
662      return s != NULL && MatchAndExplain(internal::string(s), listener);
663    }
664    template <class MatcheeStringType>
665    bool MatchAndExplain(const MatcheeStringType& s,
666                         MatchResultListener* &bsol;* listener */) const {
667      const internal::string& s2(s);
668      return full_match_ ? RE::FullMatch(s2, *regex_) :
669          RE::PartialMatch(s2, *regex_);
670    }
671    void DescribeTo(::std::ostream* os) const {
672      *os << (full_match_ ? "matches" : "contains")
673          << " regular expression ";
674      UniversalPrinter<internal::string>::Print(regex_->pattern(), os);
675    }
676    void DescribeNegationTo(::std::ostream* os) const {
677      *os << "doesn't " << (full_match_ ? "match" : "contain")
678          << " regular expression ";
679      UniversalPrinter<internal::string>::Print(regex_->pattern(), os);
680    }
681   private:
682    const internal::linked_ptr<const RE> regex_;
683    const bool full_match_;
684    GTEST_DISALLOW_ASSIGN_(MatchesRegexMatcher);
685  };
686  #define GMOCK_IMPLEMENT_COMPARISON2_MATCHER_(name, op, relation) \
687    class name##2Matcher { \
688     public: \
689      template <typename T1, typename T2> \
690      operator Matcher< ::std::tr1::tuple<T1, T2> >() const { \
691        return MakeMatcher(new Impl< ::std::tr1::tuple<T1, T2> >); \
692      } \
693      template <typename T1, typename T2> \
694      operator Matcher<const ::std::tr1::tuple<T1, T2>&>() const { \
695        return MakeMatcher(new Impl<const ::std::tr1::tuple<T1, T2>&>); \
696      } \
697     private: \
698      template <typename Tuple> \
699      class Impl : public MatcherInterface<Tuple> { \
700       public: \
701        virtual bool MatchAndExplain( \
702            Tuple args, \
703            MatchResultListener* &bsol;* listener */) const { \
704          return ::std::tr1::get<0>(args) op ::std::tr1::get<1>(args); \
705        } \
706        virtual void DescribeTo(::std::ostream* os) const { \
707          *os << "are " relation;                                 \
708        } \
709        virtual void DescribeNegationTo(::std::ostream* os) const { \
710          *os << "aren't " relation; \
711        } \
712      }; \
713    }
714  GMOCK_IMPLEMENT_COMPARISON2_MATCHER_(Eq, ==, "an equal pair");
715  GMOCK_IMPLEMENT_COMPARISON2_MATCHER_(
716      Ge, >=, "a pair where the first >= the second");
717  GMOCK_IMPLEMENT_COMPARISON2_MATCHER_(
718      Gt, >, "a pair where the first > the second");
719  GMOCK_IMPLEMENT_COMPARISON2_MATCHER_(
720      Le, <=, "a pair where the first <= the second");
721  GMOCK_IMPLEMENT_COMPARISON2_MATCHER_(
722      Lt, <, "a pair where the first < the second");
723  GMOCK_IMPLEMENT_COMPARISON2_MATCHER_(Ne, !=, "an unequal pair");
724  #undef GMOCK_IMPLEMENT_COMPARISON2_MATCHER_
725  template <typename T>
726  class NotMatcherImpl : public MatcherInterface<T> {
727   public:
728    explicit NotMatcherImpl(const Matcher<T>& matcher)
729        : matcher_(matcher) {}
730    virtual bool MatchAndExplain(T x, MatchResultListener* listener) const {
731      return !matcher_.MatchAndExplain(x, listener);
732    }
733    virtual void DescribeTo(::std::ostream* os) const {
734      matcher_.DescribeNegationTo(os);
735    }
736    virtual void DescribeNegationTo(::std::ostream* os) const {
737      matcher_.DescribeTo(os);
738    }
739   private:
740    const Matcher<T> matcher_;
741    GTEST_DISALLOW_ASSIGN_(NotMatcherImpl);
742  };
743  template <typename InnerMatcher>
744  class NotMatcher {
745   public:
746    explicit NotMatcher(InnerMatcher matcher) : matcher_(matcher) {}
747    template <typename T>
748    operator Matcher<T>() const {
749      return Matcher<T>(new NotMatcherImpl<T>(SafeMatcherCast<T>(matcher_)));
750    }
751   private:
752    InnerMatcher matcher_;
753    GTEST_DISALLOW_ASSIGN_(NotMatcher);
754  };
755  template <typename T>
756  class BothOfMatcherImpl : public MatcherInterface<T> {
757   public:
758    BothOfMatcherImpl(const Matcher<T>& matcher1, const Matcher<T>& matcher2)
759        : matcher1_(matcher1), matcher2_(matcher2) {}
760    virtual void DescribeTo(::std::ostream* os) const {
761      *os << "(";
762      matcher1_.DescribeTo(os);
763      *os << ") and (";
764      matcher2_.DescribeTo(os);
765      *os << ")";
766    }
767    virtual void DescribeNegationTo(::std::ostream* os) const {
768      *os << "(";
769      matcher1_.DescribeNegationTo(os);
770      *os << ") or (";
771      matcher2_.DescribeNegationTo(os);
772      *os << ")";
773    }
774    virtual bool MatchAndExplain(T x, MatchResultListener* listener) const {
775      StringMatchResultListener listener1;
776      if (!matcher1_.MatchAndExplain(x, &listener1)) {
777        *listener << listener1.str();
778        return false;
779      }
780      StringMatchResultListener listener2;
781      if (!matcher2_.MatchAndExplain(x, &listener2)) {
782        *listener << listener2.str();
783        return false;
784      }
785      const internal::string s1 = listener1.str();
786      const internal::string s2 = listener2.str();
787      if (s1 == "") {
788        *listener << s2;
789      } else {
790        *listener << s1;
791        if (s2 != "") {
792          *listener << ", and " << s2;
793        }
794      }
795      return true;
796    }
797   private:
798    const Matcher<T> matcher1_;
799    const Matcher<T> matcher2_;
800    GTEST_DISALLOW_ASSIGN_(BothOfMatcherImpl);
801  };
802  #if GTEST_LANG_CXX11
803  template <int kSize, typename Head, typename... Tail>
804  struct MatcherList {
805    typedef MatcherList<kSize - 1, Tail...> MatcherListTail;
806    typedef ::std::pair<Head, typename MatcherListTail::ListType> ListType;
807    static ListType BuildList(const Head& matcher, const Tail&... tail) {
808      return ListType(matcher, MatcherListTail::BuildList(tail...));
809    }
810    template <typename T, template <typename &bsol;* T */> class CombiningMatcher>
811    static Matcher<T> CreateMatcher(const ListType& matchers) {
812      return Matcher<T>(new CombiningMatcher<T>(
813          SafeMatcherCast<T>(matchers.first),
814          MatcherListTail::template CreateMatcher<T, CombiningMatcher>(
815              matchers.second)));
816    }
817  };
818  template <typename Matcher1, typename Matcher2>
819  struct MatcherList<2, Matcher1, Matcher2> {
820    typedef ::std::pair<Matcher1, Matcher2> ListType;
821    static ListType BuildList(const Matcher1& matcher1,
822                              const Matcher2& matcher2) {
823      return ::std::pair<Matcher1, Matcher2>(matcher1, matcher2);
824    }
825    template <typename T, template <typename &bsol;* T */> class CombiningMatcher>
826    static Matcher<T> CreateMatcher(const ListType& matchers) {
827      return Matcher<T>(new CombiningMatcher<T>(
828          SafeMatcherCast<T>(matchers.first),
829          SafeMatcherCast<T>(matchers.second)));
830    }
831  };
832  template <template <typename T> class CombiningMatcher, typename... Args>
833  class VariadicMatcher {
834   public:
835    VariadicMatcher(const Args&... matchers)  
836        : matchers_(MatcherListType::BuildList(matchers...)) {}
837    template <typename T>
838    operator Matcher<T>() const {
839      return MatcherListType::template CreateMatcher<T, CombiningMatcher>(
840          matchers_);
841    }
842   private:
843    typedef MatcherList<sizeof...(Args), Args...> MatcherListType;
844    const typename MatcherListType::ListType matchers_;
845    GTEST_DISALLOW_ASSIGN_(VariadicMatcher);
846  };
847  template <typename... Args>
848  using AllOfMatcher = VariadicMatcher<BothOfMatcherImpl, Args...>;
849  #endif  
850  template <typename Matcher1, typename Matcher2>
851  class BothOfMatcher {
852   public:
853    BothOfMatcher(Matcher1 matcher1, Matcher2 matcher2)
854        : matcher1_(matcher1), matcher2_(matcher2) {}
855    template <typename T>
856    operator Matcher<T>() const {
857      return Matcher<T>(new BothOfMatcherImpl<T>(SafeMatcherCast<T>(matcher1_),
858                                                 SafeMatcherCast<T>(matcher2_)));
859    }
860   private:
861    Matcher1 matcher1_;
862    Matcher2 matcher2_;
863    GTEST_DISALLOW_ASSIGN_(BothOfMatcher);
864  };
865  template <typename T>
866  class EitherOfMatcherImpl : public MatcherInterface<T> {
867   public:
868    EitherOfMatcherImpl(const Matcher<T>& matcher1, const Matcher<T>& matcher2)
869        : matcher1_(matcher1), matcher2_(matcher2) {}
870    virtual void DescribeTo(::std::ostream* os) const {
871      *os << "(";
872      matcher1_.DescribeTo(os);
873      *os << ") or (";
874      matcher2_.DescribeTo(os);
875      *os << ")";
876    }
877    virtual void DescribeNegationTo(::std::ostream* os) const {
878      *os << "(";
879      matcher1_.DescribeNegationTo(os);
880      *os << ") and (";
881      matcher2_.DescribeNegationTo(os);
882      *os << ")";
883    }
884    virtual bool MatchAndExplain(T x, MatchResultListener* listener) const {
885      StringMatchResultListener listener1;
886      if (matcher1_.MatchAndExplain(x, &listener1)) {
887        *listener << listener1.str();
888        return true;
889      }
890      StringMatchResultListener listener2;
891      if (matcher2_.MatchAndExplain(x, &listener2)) {
892        *listener << listener2.str();
893        return true;
894      }
895      const internal::string s1 = listener1.str();
896      const internal::string s2 = listener2.str();
897      if (s1 == "") {
898        *listener << s2;
899      } else {
900        *listener << s1;
901        if (s2 != "") {
902          *listener << ", and " << s2;
903        }
904      }
905      return false;
906    }
907   private:
908    const Matcher<T> matcher1_;
909    const Matcher<T> matcher2_;
910    GTEST_DISALLOW_ASSIGN_(EitherOfMatcherImpl);
911  };
912  #if GTEST_LANG_CXX11
913  template <typename... Args>
914  using AnyOfMatcher = VariadicMatcher<EitherOfMatcherImpl, Args...>;
915  #endif  
916  template <typename Matcher1, typename Matcher2>
917  class EitherOfMatcher {
918   public:
919    EitherOfMatcher(Matcher1 matcher1, Matcher2 matcher2)
920        : matcher1_(matcher1), matcher2_(matcher2) {}
921    template <typename T>
922    operator Matcher<T>() const {
923      return Matcher<T>(new EitherOfMatcherImpl<T>(
924          SafeMatcherCast<T>(matcher1_), SafeMatcherCast<T>(matcher2_)));
925    }
926   private:
927    Matcher1 matcher1_;
928    Matcher2 matcher2_;
929    GTEST_DISALLOW_ASSIGN_(EitherOfMatcher);
930  };
931  template <typename Predicate>
932  class TrulyMatcher {
933   public:
934    explicit TrulyMatcher(Predicate pred) : predicate_(pred) {}
935    template <typename T>
936    bool MatchAndExplain(T& x,  
937                         MatchResultListener* &bsol;* listener */) const {
938      if (predicate_(x))
939        return true;
940      return false;
941    }
942    void DescribeTo(::std::ostream* os) const {
943      *os << "satisfies the given predicate";
944    }
945    void DescribeNegationTo(::std::ostream* os) const {
946      *os << "doesn't satisfy the given predicate";
947    }
948   private:
949    Predicate predicate_;
950    GTEST_DISALLOW_ASSIGN_(TrulyMatcher);
951  };
952  template <typename M>
953  class MatcherAsPredicate {
954   public:
955    explicit MatcherAsPredicate(M matcher) : matcher_(matcher) {}
956    template <typename T>
957    bool operator()(const T& x) const {
958      return MatcherCast<const T&>(matcher_).Matches(x);
959    }
960   private:
961    M matcher_;
962    GTEST_DISALLOW_ASSIGN_(MatcherAsPredicate);
963  };
964  template <typename M>
965  class PredicateFormatterFromMatcher {
966   public:
967    explicit PredicateFormatterFromMatcher(const M& m) : matcher_(m) {}
968    template <typename T>
969    AssertionResult operator()(const char* value_text, const T& x) const {
970      const Matcher<const T&> matcher = SafeMatcherCast<const T&>(matcher_);
971      StringMatchResultListener listener;
972      if (MatchPrintAndExplain(x, matcher, &listener))
973        return AssertionSuccess();
974      ::std::stringstream ss;
975      ss << "Value of: " << value_text << "\n"
976         << "Expected: ";
977      matcher.DescribeTo(&ss);
978      ss << "\n  Actual: " << listener.str();
979      return AssertionFailure() << ss.str();
980    }
981   private:
982    const M matcher_;
983    GTEST_DISALLOW_ASSIGN_(PredicateFormatterFromMatcher);
984  };
985  template <typename M>
986  inline PredicateFormatterFromMatcher<M>
987  MakePredicateFormatterFromMatcher(const M& matcher) {
988    return PredicateFormatterFromMatcher<M>(matcher);
989  }
990  template <typename FloatType>
991  class FloatingEqMatcher {
992   public:
993    FloatingEqMatcher(FloatType rhs, bool nan_eq_nan) :
994      rhs_(rhs), nan_eq_nan_(nan_eq_nan), max_abs_error_(-1) {
995    }
996    FloatingEqMatcher(FloatType rhs, bool nan_eq_nan, FloatType max_abs_error) :
997      rhs_(rhs), nan_eq_nan_(nan_eq_nan), max_abs_error_(max_abs_error) {
998      GTEST_CHECK_(max_abs_error >= 0)
999          << ", where max_abs_error is" << max_abs_error;
1000    }
1001    template <typename T>
1002    class Impl : public MatcherInterface<T> {
1003     public:
1004      Impl(FloatType rhs, bool nan_eq_nan, FloatType max_abs_error) :
1005        rhs_(rhs), nan_eq_nan_(nan_eq_nan), max_abs_error_(max_abs_error) {}
1006      virtual bool MatchAndExplain(T value,
1007                                   MatchResultListener* &bsol;* listener */) const {
1008        const FloatingPoint<FloatType> lhs(value), rhs(rhs_);
1009        if (lhs.is_nan() || rhs.is_nan()) {
1010          if (lhs.is_nan() && rhs.is_nan()) {
1011            return nan_eq_nan_;
1012          }
1013          return false;
1014        }
1015        if (HasMaxAbsError()) {
1016          return value == rhs_ || fabs(value - rhs_) <= max_abs_error_;
1017        } else {
1018          return lhs.AlmostEquals(rhs);
1019        }
1020      }
1021      virtual void DescribeTo(::std::ostream* os) const {
1022        const ::std::streamsize old_precision = os->precision(
1023            ::std::numeric_limits<FloatType>::digits10 + 2);
1024        if (FloatingPoint<FloatType>(rhs_).is_nan()) {
1025          if (nan_eq_nan_) {
1026            *os << "is NaN";
1027          } else {
1028            *os << "never matches";
1029          }
1030        } else {
1031          *os << "is approximately " << rhs_;
1032          if (HasMaxAbsError()) {
1033            *os << " (absolute error <= " << max_abs_error_ << ")";
1034          }
1035        }
1036        os->precision(old_precision);
1037      }
1038      virtual void DescribeNegationTo(::std::ostream* os) const {
1039        const ::std::streamsize old_precision = os->precision(
1040            ::std::numeric_limits<FloatType>::digits10 + 2);
1041        if (FloatingPoint<FloatType>(rhs_).is_nan()) {
1042          if (nan_eq_nan_) {
1043            *os << "isn't NaN";
1044          } else {
1045            *os << "is anything";
1046          }
1047        } else {
1048          *os << "isn't approximately " << rhs_;
1049          if (HasMaxAbsError()) {
1050            *os << " (absolute error > " << max_abs_error_ << ")";
1051          }
1052        }
1053        os->precision(old_precision);
1054      }
1055     private:
1056      bool HasMaxAbsError() const {
1057        return max_abs_error_ >= 0;
1058      }
1059      const FloatType rhs_;
1060      const bool nan_eq_nan_;
1061      const FloatType max_abs_error_;
1062      GTEST_DISALLOW_ASSIGN_(Impl);
1063    };
1064    operator Matcher<FloatType>() const {
1065      return MakeMatcher(new Impl<FloatType>(rhs_, nan_eq_nan_, max_abs_error_));
1066    }
1067    operator Matcher<const FloatType&>() const {
1068      return MakeMatcher(
1069          new Impl<const FloatType&>(rhs_, nan_eq_nan_, max_abs_error_));
1070    }
1071    operator Matcher<FloatType&>() const {
1072      return MakeMatcher(new Impl<FloatType&>(rhs_, nan_eq_nan_, max_abs_error_));
1073    }
1074   private:
1075    const FloatType rhs_;
1076    const bool nan_eq_nan_;
1077    const FloatType max_abs_error_;
1078    GTEST_DISALLOW_ASSIGN_(FloatingEqMatcher);
1079  };
1080  template <typename InnerMatcher>
1081  class PointeeMatcher {
1082   public:
1083    explicit PointeeMatcher(const InnerMatcher& matcher) : matcher_(matcher) {}
1084    template <typename Pointer>
1085    operator Matcher<Pointer>() const {
1086      return MakeMatcher(new Impl<Pointer>(matcher_));
1087    }
1088   private:
1089    template <typename Pointer>
1090    class Impl : public MatcherInterface<Pointer> {
1091     public:
1092      typedef typename PointeeOf<GTEST_REMOVE_CONST_(  
1093          GTEST_REMOVE_REFERENCE_(Pointer))>::type Pointee;
1094      explicit Impl(const InnerMatcher& matcher)
1095          : matcher_(MatcherCast<const Pointee&>(matcher)) {}
1096      virtual void DescribeTo(::std::ostream* os) const {
1097        *os << "points to a value that ";
1098        matcher_.DescribeTo(os);
1099      }
1100      virtual void DescribeNegationTo(::std::ostream* os) const {
1101        *os << "does not point to a value that ";
1102        matcher_.DescribeTo(os);
1103      }
1104      virtual bool MatchAndExplain(Pointer pointer,
1105                                   MatchResultListener* listener) const {
1106        if (GetRawPointer(pointer) == NULL)
1107          return false;
1108        *listener << "which points to ";
1109        return MatchPrintAndExplain(*pointer, matcher_, listener);
1110      }
1111     private:
1112      const Matcher<const Pointee&> matcher_;
1113      GTEST_DISALLOW_ASSIGN_(Impl);
1114    };
1115    const InnerMatcher matcher_;
1116    GTEST_DISALLOW_ASSIGN_(PointeeMatcher);
1117  };
1118  template <typename Class, typename FieldType>
1119  class FieldMatcher {
1120   public:
1121    FieldMatcher(FieldType Class::*field,
1122                 const Matcher<const FieldType&>& matcher)
1123        : field_(field), matcher_(matcher) {}
1124    void DescribeTo(::std::ostream* os) const {
1125      *os << "is an object whose given field ";
1126      matcher_.DescribeTo(os);
1127    }
1128    void DescribeNegationTo(::std::ostream* os) const {
1129      *os << "is an object whose given field ";
1130      matcher_.DescribeNegationTo(os);
1131    }
1132    template <typename T>
1133    bool MatchAndExplain(const T& value, MatchResultListener* listener) const {
1134      return MatchAndExplainImpl(
1135          typename ::testing::internal::
1136              is_pointer<GTEST_REMOVE_CONST_(T)>::type(),
1137          value, listener);
1138    }
1139   private:
1140    bool MatchAndExplainImpl(false_type &bsol;* is_not_pointer */, const Class& obj,
1141                             MatchResultListener* listener) const {
1142      *listener << "whose given field is ";
1143      return MatchPrintAndExplain(obj.*field_, matcher_, listener);
1144    }
1145    bool MatchAndExplainImpl(true_type &bsol;* is_pointer */, const Class* p,
1146                             MatchResultListener* listener) const {
1147      if (p == NULL)
1148        return false;
1149      *listener << "which points to an object ";
1150      return MatchAndExplainImpl(false_type(), *p, listener);
1151    }
1152    const FieldType Class::*field_;
1153    const Matcher<const FieldType&> matcher_;
1154    GTEST_DISALLOW_ASSIGN_(FieldMatcher);
1155  };
1156  template <typename Class, typename PropertyType>
1157  class PropertyMatcher {
1158   public:
1159    typedef GTEST_REFERENCE_TO_CONST_(PropertyType) RefToConstProperty;
1160    PropertyMatcher(PropertyType (Class::*property)() const,
1161                    const Matcher<RefToConstProperty>& matcher)
1162        : property_(property), matcher_(matcher) {}
1163    void DescribeTo(::std::ostream* os) const {
1164      *os << "is an object whose given property ";
1165      matcher_.DescribeTo(os);
1166    }
1167    void DescribeNegationTo(::std::ostream* os) const {
1168      *os << "is an object whose given property ";
1169      matcher_.DescribeNegationTo(os);
1170    }
1171    template <typename T>
1172    bool MatchAndExplain(const T&value, MatchResultListener* listener) const {
1173      return MatchAndExplainImpl(
1174          typename ::testing::internal::
1175              is_pointer<GTEST_REMOVE_CONST_(T)>::type(),
1176          value, listener);
1177    }
1178   private:
1179    bool MatchAndExplainImpl(false_type &bsol;* is_not_pointer */, const Class& obj,
1180                             MatchResultListener* listener) const {
1181      *listener << "whose given property is ";
1182      RefToConstProperty result = (obj.*property_)();
1183      return MatchPrintAndExplain(result, matcher_, listener);
1184    }
1185    bool MatchAndExplainImpl(true_type &bsol;* is_pointer */, const Class* p,
1186                             MatchResultListener* listener) const {
1187      if (p == NULL)
1188        return false;
1189      *listener << "which points to an object ";
1190      return MatchAndExplainImpl(false_type(), *p, listener);
1191    }
1192    PropertyType (Class::*property_)() const;
1193    const Matcher<RefToConstProperty> matcher_;
1194    GTEST_DISALLOW_ASSIGN_(PropertyMatcher);
1195  };
1196  template <typename Functor>
1197  struct CallableTraits {
1198    typedef typename Functor::result_type ResultType;
1199    typedef Functor StorageType;
1200    static void CheckIsValid(Functor &bsol;* functor */) {}
1201    template <typename T>
1202    static ResultType Invoke(Functor f, T arg) { return f(arg); }
1203  };
1204  template <typename ArgType, typename ResType>
1205  struct CallableTraits<ResType(*)(ArgType)> {
1206    typedef ResType ResultType;
1207    typedef ResType(*StorageType)(ArgType);
1208    static void CheckIsValid(ResType(*f)(ArgType)) {
1209      GTEST_CHECK_(f != NULL)
1210          << "NULL function pointer is passed into ResultOf().";
1211    }
1212    template <typename T>
1213    static ResType Invoke(ResType(*f)(ArgType), T arg) {
1214      return (*f)(arg);
1215    }
1216  };
1217  template <typename Callable>
1218  class ResultOfMatcher {
1219   public:
1220    typedef typename CallableTraits<Callable>::ResultType ResultType;
1221    ResultOfMatcher(Callable callable, const Matcher<ResultType>& matcher)
1222        : callable_(callable), matcher_(matcher) {
1223      CallableTraits<Callable>::CheckIsValid(callable_);
1224    }
1225    template <typename T>
1226    operator Matcher<T>() const {
1227      return Matcher<T>(new Impl<T>(callable_, matcher_));
1228    }
1229   private:
1230    typedef typename CallableTraits<Callable>::StorageType CallableStorageType;
1231    template <typename T>
1232    class Impl : public MatcherInterface<T> {
1233     public:
1234      Impl(CallableStorageType callable, const Matcher<ResultType>& matcher)
1235          : callable_(callable), matcher_(matcher) {}
1236      virtual void DescribeTo(::std::ostream* os) const {
1237        *os << "is mapped by the given callable to a value that ";
1238        matcher_.DescribeTo(os);
1239      }
1240      virtual void DescribeNegationTo(::std::ostream* os) const {
1241        *os << "is mapped by the given callable to a value that ";
1242        matcher_.DescribeNegationTo(os);
1243      }
1244      virtual bool MatchAndExplain(T obj, MatchResultListener* listener) const {
1245        *listener << "which is mapped by the given callable to ";
1246        ResultType result =
1247            CallableTraits<Callable>::template Invoke<T>(callable_, obj);
1248        return MatchPrintAndExplain(result, matcher_, listener);
1249      }
1250     private:
1251      mutable CallableStorageType callable_;
1252      const Matcher<ResultType> matcher_;
1253      GTEST_DISALLOW_ASSIGN_(Impl);
1254    };  
1255    const CallableStorageType callable_;
1256    const Matcher<ResultType> matcher_;
1257    GTEST_DISALLOW_ASSIGN_(ResultOfMatcher);
1258  };
1259  template <typename SizeMatcher>
1260  class SizeIsMatcher {
1261   public:
1262    explicit SizeIsMatcher(const SizeMatcher& size_matcher)
1263         : size_matcher_(size_matcher) {
1264    }
1265    template <typename Container>
1266    operator Matcher<Container>() const {
1267      return MakeMatcher(new Impl<Container>(size_matcher_));
1268    }
1269    template <typename Container>
1270    class Impl : public MatcherInterface<Container> {
1271     public:
1272      typedef internal::StlContainerView<
1273           GTEST_REMOVE_REFERENCE_AND_CONST_(Container)> ContainerView;
1274      typedef typename ContainerView::type::size_type SizeType;
1275      explicit Impl(const SizeMatcher& size_matcher)
1276          : size_matcher_(MatcherCast<SizeType>(size_matcher)) {}
1277      virtual void DescribeTo(::std::ostream* os) const {
1278        *os << "size ";
1279        size_matcher_.DescribeTo(os);
1280      }
1281      virtual void DescribeNegationTo(::std::ostream* os) const {
1282        *os << "size ";
1283        size_matcher_.DescribeNegationTo(os);
1284      }
1285      virtual bool MatchAndExplain(Container container,
1286                                   MatchResultListener* listener) const {
1287        SizeType size = container.size();
1288        StringMatchResultListener size_listener;
1289        const bool result = size_matcher_.MatchAndExplain(size, &size_listener);
1290        *listener
1291            << "whose size " << size << (result ? " matches" : " doesn't match");
1292        PrintIfNotEmpty(size_listener.str(), listener->stream());
1293        return result;
1294      }
1295     private:
1296      const Matcher<SizeType> size_matcher_;
1297      GTEST_DISALLOW_ASSIGN_(Impl);
1298    };
1299   private:
1300    const SizeMatcher size_matcher_;
1301    GTEST_DISALLOW_ASSIGN_(SizeIsMatcher);
1302  };
1303  template <typename Container>
1304  class ContainerEqMatcher {
1305   public:
1306    typedef internal::StlContainerView<Container> View;
1307    typedef typename View::type StlContainer;
1308    typedef typename View::const_reference StlContainerReference;
1309    explicit ContainerEqMatcher(const Container& rhs) : rhs_(View::Copy(rhs)) {
1310      (void)testing::StaticAssertTypeEq<Container,
1311          GTEST_REMOVE_REFERENCE_AND_CONST_(Container)>();
1312    }
1313    void DescribeTo(::std::ostream* os) const {
1314      *os << "equals ";
1315      UniversalPrint(rhs_, os);
1316    }
1317    void DescribeNegationTo(::std::ostream* os) const {
1318      *os << "does not equal ";
1319      UniversalPrint(rhs_, os);
1320    }
1321    template <typename LhsContainer>
1322    bool MatchAndExplain(const LhsContainer& lhs,
1323                         MatchResultListener* listener) const {
1324      typedef internal::StlContainerView<GTEST_REMOVE_CONST_(LhsContainer)>
1325          LhsView;
1326      typedef typename LhsView::type LhsStlContainer;
1327      StlContainerReference lhs_stl_container = LhsView::ConstReference(lhs);
1328      if (lhs_stl_container == rhs_)
1329        return true;
1330      ::std::ostream* const os = listener->stream();
1331      if (os != NULL) {
1332        bool printed_header = false;
1333        for (typename LhsStlContainer::const_iterator it =
1334                 lhs_stl_container.begin();
1335             it != lhs_stl_container.end(); ++it) {
1336          if (internal::ArrayAwareFind(rhs_.begin(), rhs_.end(), *it) ==
1337              rhs_.end()) {
1338            if (printed_header) {
1339              *os << ", ";
1340            } else {
1341              *os << "which has these unexpected elements: ";
1342              printed_header = true;
1343            }
1344            UniversalPrint(*it, os);
1345          }
1346        }
1347        bool printed_header2 = false;
1348        for (typename StlContainer::const_iterator it = rhs_.begin();
1349             it != rhs_.end(); ++it) {
1350          if (internal::ArrayAwareFind(
1351                  lhs_stl_container.begin(), lhs_stl_container.end(), *it) ==
1352              lhs_stl_container.end()) {
1353            if (printed_header2) {
1354              *os << ", ";
1355            } else {
1356              *os << (printed_header ? ",\nand" : "which")
1357                  << " doesn't have these expected elements: ";
1358              printed_header2 = true;
1359            }
1360            UniversalPrint(*it, os);
1361          }
1362        }
1363      }
1364      return false;
1365    }
1366   private:
1367    const StlContainer rhs_;
1368    GTEST_DISALLOW_ASSIGN_(ContainerEqMatcher);
1369  };
1370  struct LessComparator {
1371    template <typename T, typename U>
1372    bool operator()(const T& lhs, const U& rhs) const { return lhs < rhs; }
1373  };
1374  template <typename Comparator, typename ContainerMatcher>
1375  class WhenSortedByMatcher {
1376   public:
1377    WhenSortedByMatcher(const Comparator& comparator,
1378                        const ContainerMatcher& matcher)
1379        : comparator_(comparator), matcher_(matcher) {}
1380    template <typename LhsContainer>
1381    operator Matcher<LhsContainer>() const {
1382      return MakeMatcher(new Impl<LhsContainer>(comparator_, matcher_));
1383    }
1384    template <typename LhsContainer>
1385    class Impl : public MatcherInterface<LhsContainer> {
1386     public:
1387      typedef internal::StlContainerView<
1388           GTEST_REMOVE_REFERENCE_AND_CONST_(LhsContainer)> LhsView;
1389      typedef typename LhsView::type LhsStlContainer;
1390      typedef typename LhsView::const_reference LhsStlContainerReference;
1391      typedef typename RemoveConstFromKey<
1392          typename LhsStlContainer::value_type>::type LhsValue;
1393      Impl(const Comparator& comparator, const ContainerMatcher& matcher)
1394          : comparator_(comparator), matcher_(matcher) {}
1395      virtual void DescribeTo(::std::ostream* os) const {
1396        *os << "(when sorted) ";
1397        matcher_.DescribeTo(os);
1398      }
1399      virtual void DescribeNegationTo(::std::ostream* os) const {
1400        *os << "(when sorted) ";
1401        matcher_.DescribeNegationTo(os);
1402      }
1403      virtual bool MatchAndExplain(LhsContainer lhs,
1404                                   MatchResultListener* listener) const {
1405        LhsStlContainerReference lhs_stl_container = LhsView::ConstReference(lhs);
1406        ::std::vector<LhsValue> sorted_container(lhs_stl_container.begin(),
1407                                                 lhs_stl_container.end());
1408        ::std::sort(
1409             sorted_container.begin(), sorted_container.end(), comparator_);
1410        if (!listener->IsInterested()) {
1411          return matcher_.Matches(sorted_container);
1412        }
1413        *listener << "which is ";
1414        UniversalPrint(sorted_container, listener->stream());
1415        *listener << " when sorted";
1416        StringMatchResultListener inner_listener;
1417        const bool match = matcher_.MatchAndExplain(sorted_container,
1418                                                    &inner_listener);
1419        PrintIfNotEmpty(inner_listener.str(), listener->stream());
1420        return match;
1421      }
1422     private:
1423      const Comparator comparator_;
1424      const Matcher<const ::std::vector<LhsValue>&> matcher_;
1425      GTEST_DISALLOW_COPY_AND_ASSIGN_(Impl);
1426    };
1427   private:
1428    const Comparator comparator_;
1429    const ContainerMatcher matcher_;
1430    GTEST_DISALLOW_ASSIGN_(WhenSortedByMatcher);
1431  };
1432  template <typename TupleMatcher, typename RhsContainer>
1433  class PointwiseMatcher {
1434   public:
1435    typedef internal::StlContainerView<RhsContainer> RhsView;
1436    typedef typename RhsView::type RhsStlContainer;
1437    typedef typename RhsStlContainer::value_type RhsValue;
1438    PointwiseMatcher(const TupleMatcher& tuple_matcher, const RhsContainer& rhs)
1439        : tuple_matcher_(tuple_matcher), rhs_(RhsView::Copy(rhs)) {
1440      (void)testing::StaticAssertTypeEq<RhsContainer,
1441          GTEST_REMOVE_REFERENCE_AND_CONST_(RhsContainer)>();
1442    }
1443    template <typename LhsContainer>
1444    operator Matcher<LhsContainer>() const {
1445      return MakeMatcher(new Impl<LhsContainer>(tuple_matcher_, rhs_));
1446    }
1447    template <typename LhsContainer>
1448    class Impl : public MatcherInterface<LhsContainer> {
1449     public:
1450      typedef internal::StlContainerView<
1451           GTEST_REMOVE_REFERENCE_AND_CONST_(LhsContainer)> LhsView;
1452      typedef typename LhsView::type LhsStlContainer;
1453      typedef typename LhsView::const_reference LhsStlContainerReference;
1454      typedef typename LhsStlContainer::value_type LhsValue;
1455      typedef ::std::tr1::tuple<const LhsValue&, const RhsValue&> InnerMatcherArg;
1456      Impl(const TupleMatcher& tuple_matcher, const RhsStlContainer& rhs)
1457          : mono_tuple_matcher_(SafeMatcherCast<InnerMatcherArg>(tuple_matcher)),
1458            rhs_(rhs) {}
1459      virtual void DescribeTo(::std::ostream* os) const {
1460        *os << "contains " << rhs_.size()
1461            << " values, where each value and its corresponding value in ";
1462        UniversalPrinter<RhsStlContainer>::Print(rhs_, os);
1463        *os << " ";
1464        mono_tuple_matcher_.DescribeTo(os);
1465      }
1466      virtual void DescribeNegationTo(::std::ostream* os) const {
1467        *os << "doesn't contain exactly " << rhs_.size()
1468            << " values, or contains a value x at some index i"
1469            << " where x and the i-th value of ";
1470        UniversalPrint(rhs_, os);
1471        *os << " ";
1472        mono_tuple_matcher_.DescribeNegationTo(os);
1473      }
1474      virtual bool MatchAndExplain(LhsContainer lhs,
1475                                   MatchResultListener* listener) const {
1476        LhsStlContainerReference lhs_stl_container = LhsView::ConstReference(lhs);
1477        const size_t actual_size = lhs_stl_container.size();
1478        if (actual_size != rhs_.size()) {
1479          *listener << "which contains " << actual_size << " values";
1480          return false;
1481        }
1482        typename LhsStlContainer::const_iterator left = lhs_stl_container.begin();
1483        typename RhsStlContainer::const_iterator right = rhs_.begin();
1484        for (size_t i = 0; i != actual_size; ++i, ++left, ++right) {
1485          const InnerMatcherArg value_pair(*left, *right);
1486          if (listener->IsInterested()) {
1487            StringMatchResultListener inner_listener;
1488            if (!mono_tuple_matcher_.MatchAndExplain(
1489                    value_pair, &inner_listener)) {
1490              *listener << "where the value pair (";
1491              UniversalPrint(*left, listener->stream());
1492              *listener << ", ";
1493              UniversalPrint(*right, listener->stream());
1494              *listener << ") at index #" << i << " don't match";
1495              PrintIfNotEmpty(inner_listener.str(), listener->stream());
1496              return false;
1497            }
1498          } else {
1499            if (!mono_tuple_matcher_.Matches(value_pair))
1500              return false;
1501          }
1502        }
1503        return true;
1504      }
1505     private:
1506      const Matcher<InnerMatcherArg> mono_tuple_matcher_;
1507      const RhsStlContainer rhs_;
1508      GTEST_DISALLOW_ASSIGN_(Impl);
1509    };
1510   private:
1511    const TupleMatcher tuple_matcher_;
1512    const RhsStlContainer rhs_;
1513    GTEST_DISALLOW_ASSIGN_(PointwiseMatcher);
1514  };
1515  template <typename Container>
1516  class QuantifierMatcherImpl : public MatcherInterface<Container> {
1517   public:
1518    typedef GTEST_REMOVE_REFERENCE_AND_CONST_(Container) RawContainer;
1519    typedef StlContainerView<RawContainer> View;
1520    typedef typename View::type StlContainer;
1521    typedef typename View::const_reference StlContainerReference;
1522    typedef typename StlContainer::value_type Element;
1523    template <typename InnerMatcher>
1524    explicit QuantifierMatcherImpl(InnerMatcher inner_matcher)
1525        : inner_matcher_(
1526             testing::SafeMatcherCast<const Element&>(inner_matcher)) {}
1527    bool MatchAndExplainImpl(bool all_elements_should_match,
1528                             Container container,
1529                             MatchResultListener* listener) const {
1530      StlContainerReference stl_container = View::ConstReference(container);
1531      size_t i = 0;
1532      for (typename StlContainer::const_iterator it = stl_container.begin();
1533           it != stl_container.end(); ++it, ++i) {
1534        StringMatchResultListener inner_listener;
1535        const bool matches = inner_matcher_.MatchAndExplain(*it, &inner_listener);
1536        if (matches != all_elements_should_match) {
1537          *listener << "whose element #" << i
1538                    << (matches ? " matches" : " doesn't match");
1539          PrintIfNotEmpty(inner_listener.str(), listener->stream());
1540          return !all_elements_should_match;
1541        }
1542      }
1543      return all_elements_should_match;
1544    }
1545   protected:
1546    const Matcher<const Element&> inner_matcher_;
1547    GTEST_DISALLOW_ASSIGN_(QuantifierMatcherImpl);
1548  };
1549  template <typename Container>
1550  class ContainsMatcherImpl : public QuantifierMatcherImpl<Container> {
1551   public:
1552    template <typename InnerMatcher>
1553    explicit ContainsMatcherImpl(InnerMatcher inner_matcher)
1554        : QuantifierMatcherImpl<Container>(inner_matcher) {}
1555    virtual void DescribeTo(::std::ostream* os) const {
1556      *os << "contains at least one element that ";
1557      this->inner_matcher_.DescribeTo(os);
1558    }
1559    virtual void DescribeNegationTo(::std::ostream* os) const {
1560      *os << "doesn't contain any element that ";
1561      this->inner_matcher_.DescribeTo(os);
1562    }
1563    virtual bool MatchAndExplain(Container container,
1564                                 MatchResultListener* listener) const {
1565      return this->MatchAndExplainImpl(false, container, listener);
1566    }
1567   private:
1568    GTEST_DISALLOW_ASSIGN_(ContainsMatcherImpl);
1569  };
1570  template <typename Container>
1571  class EachMatcherImpl : public QuantifierMatcherImpl<Container> {
1572   public:
1573    template <typename InnerMatcher>
1574    explicit EachMatcherImpl(InnerMatcher inner_matcher)
1575        : QuantifierMatcherImpl<Container>(inner_matcher) {}
1576    virtual void DescribeTo(::std::ostream* os) const {
1577      *os << "only contains elements that ";
1578      this->inner_matcher_.DescribeTo(os);
1579    }
1580    virtual void DescribeNegationTo(::std::ostream* os) const {
1581      *os << "contains some element that ";
1582      this->inner_matcher_.DescribeNegationTo(os);
1583    }
1584    virtual bool MatchAndExplain(Container container,
1585                                 MatchResultListener* listener) const {
1586      return this->MatchAndExplainImpl(true, container, listener);
1587    }
1588   private:
1589    GTEST_DISALLOW_ASSIGN_(EachMatcherImpl);
1590  };
1591  template <typename M>
1592  class ContainsMatcher {
1593   public:
1594    explicit ContainsMatcher(M m) : inner_matcher_(m) {}
1595    template <typename Container>
1596    operator Matcher<Container>() const {
1597      return MakeMatcher(new ContainsMatcherImpl<Container>(inner_matcher_));
1598    }
1599   private:
1600    const M inner_matcher_;
1601    GTEST_DISALLOW_ASSIGN_(ContainsMatcher);
1602  };
1603  template <typename M>
1604  class EachMatcher {
1605   public:
1606    explicit EachMatcher(M m) : inner_matcher_(m) {}
1607    template <typename Container>
1608    operator Matcher<Container>() const {
1609      return MakeMatcher(new EachMatcherImpl<Container>(inner_matcher_));
1610    }
1611   private:
1612    const M inner_matcher_;
1613    GTEST_DISALLOW_ASSIGN_(EachMatcher);
1614  };
1615  template <typename PairType>
1616  class KeyMatcherImpl : public MatcherInterface<PairType> {
1617   public:
1618    typedef GTEST_REMOVE_REFERENCE_AND_CONST_(PairType) RawPairType;
1619    typedef typename RawPairType::first_type KeyType;
1620    template <typename InnerMatcher>
1621    explicit KeyMatcherImpl(InnerMatcher inner_matcher)
1622        : inner_matcher_(
1623            testing::SafeMatcherCast<const KeyType&>(inner_matcher)) {
1624    }
1625    virtual bool MatchAndExplain(PairType key_value,
1626                                 MatchResultListener* listener) const {
1627      StringMatchResultListener inner_listener;
1628      const bool match = inner_matcher_.MatchAndExplain(key_value.first,
1629                                                        &inner_listener);
1630      const internal::string explanation = inner_listener.str();
1631      if (explanation != "") {
1632        *listener << "whose first field is a value " << explanation;
1633      }
1634      return match;
1635    }
1636    virtual void DescribeTo(::std::ostream* os) const {
1637      *os << "has a key that ";
1638      inner_matcher_.DescribeTo(os);
1639    }
1640    virtual void DescribeNegationTo(::std::ostream* os) const {
1641      *os << "doesn't have a key that ";
1642      inner_matcher_.DescribeTo(os);
1643    }
1644   private:
1645    const Matcher<const KeyType&> inner_matcher_;
1646    GTEST_DISALLOW_ASSIGN_(KeyMatcherImpl);
1647  };
1648  template <typename M>
1649  class KeyMatcher {
1650   public:
1651    explicit KeyMatcher(M m) : matcher_for_key_(m) {}
1652    template <typename PairType>
1653    operator Matcher<PairType>() const {
1654      return MakeMatcher(new KeyMatcherImpl<PairType>(matcher_for_key_));
1655    }
1656   private:
1657    const M matcher_for_key_;
1658    GTEST_DISALLOW_ASSIGN_(KeyMatcher);
1659  };
1660  template <typename PairType>
1661  class PairMatcherImpl : public MatcherInterface<PairType> {
1662   public:
1663    typedef GTEST_REMOVE_REFERENCE_AND_CONST_(PairType) RawPairType;
1664    typedef typename RawPairType::first_type FirstType;
1665    typedef typename RawPairType::second_type SecondType;
1666    template <typename FirstMatcher, typename SecondMatcher>
1667    PairMatcherImpl(FirstMatcher first_matcher, SecondMatcher second_matcher)
1668        : first_matcher_(
1669              testing::SafeMatcherCast<const FirstType&>(first_matcher)),
1670          second_matcher_(
1671              testing::SafeMatcherCast<const SecondType&>(second_matcher)) {
1672    }
1673    virtual void DescribeTo(::std::ostream* os) const {
1674      *os << "has a first field that ";
1675      first_matcher_.DescribeTo(os);
1676      *os << ", and has a second field that ";
1677      second_matcher_.DescribeTo(os);
1678    }
1679    virtual void DescribeNegationTo(::std::ostream* os) const {
1680      *os << "has a first field that ";
1681      first_matcher_.DescribeNegationTo(os);
1682      *os << ", or has a second field that ";
1683      second_matcher_.DescribeNegationTo(os);
1684    }
1685    virtual bool MatchAndExplain(PairType a_pair,
1686                                 MatchResultListener* listener) const {
1687      if (!listener->IsInterested()) {
1688        return first_matcher_.Matches(a_pair.first) &&
1689               second_matcher_.Matches(a_pair.second);
1690      }
1691      StringMatchResultListener first_inner_listener;
1692      if (!first_matcher_.MatchAndExplain(a_pair.first,
1693                                          &first_inner_listener)) {
1694        *listener << "whose first field does not match";
1695        PrintIfNotEmpty(first_inner_listener.str(), listener->stream());
1696        return false;
1697      }
1698      StringMatchResultListener second_inner_listener;
1699      if (!second_matcher_.MatchAndExplain(a_pair.second,
1700                                           &second_inner_listener)) {
1701        *listener << "whose second field does not match";
1702        PrintIfNotEmpty(second_inner_listener.str(), listener->stream());
1703        return false;
1704      }
1705      ExplainSuccess(first_inner_listener.str(), second_inner_listener.str(),
1706                     listener);
1707      return true;
1708    }
1709   private:
1710    void ExplainSuccess(const internal::string& first_explanation,
1711                        const internal::string& second_explanation,
1712                        MatchResultListener* listener) const {
1713      *listener << "whose both fields match";
1714      if (first_explanation != "") {
1715        *listener << ", where the first field is a value " << first_explanation;
1716      }
<span onclick='openModal()' class='match'>1717      if (second_explanation != "") {
1718        *listener << ", ";
1719        if (first_explanation != "") {
1720          *listener << "and ";
1721        } else {
1722          *listener << "where ";
1723        }
1724        *listener << "the second field is a value " << second_explanation;
1725      }
1726    }
</span>1727    const Matcher<const FirstType&> first_matcher_;
1728    const Matcher<const SecondType&> second_matcher_;
1729    GTEST_DISALLOW_ASSIGN_(PairMatcherImpl);
1730  };
1731  template <typename FirstMatcher, typename SecondMatcher>
1732  class PairMatcher {
1733   public:
1734    PairMatcher(FirstMatcher first_matcher, SecondMatcher second_matcher)
1735        : first_matcher_(first_matcher), second_matcher_(second_matcher) {}
1736    template <typename PairType>
1737    operator Matcher<PairType> () const {
1738      return MakeMatcher(
1739          new PairMatcherImpl<PairType>(
1740              first_matcher_, second_matcher_));
1741    }
1742   private:
1743    const FirstMatcher first_matcher_;
1744    const SecondMatcher second_matcher_;
1745    GTEST_DISALLOW_ASSIGN_(PairMatcher);
1746  };
1747  template <typename Container>
1748  class ElementsAreMatcherImpl : public MatcherInterface<Container> {
1749   public:
1750    typedef GTEST_REMOVE_REFERENCE_AND_CONST_(Container) RawContainer;
1751    typedef internal::StlContainerView<RawContainer> View;
1752    typedef typename View::type StlContainer;
1753    typedef typename View::const_reference StlContainerReference;
1754    typedef typename StlContainer::value_type Element;
1755    template <typename InputIter>
1756    ElementsAreMatcherImpl(InputIter first, InputIter last) {
1757      while (first != last) {
1758        matchers_.push_back(MatcherCast<const Element&>(*first++));
1759      }
1760    }
1761    virtual void DescribeTo(::std::ostream* os) const {
1762      if (count() == 0) {
1763        *os << "is empty";
1764      } else if (count() == 1) {
1765        *os << "has 1 element that ";
1766        matchers_[0].DescribeTo(os);
1767      } else {
1768        *os << "has " << Elements(count()) << " where\n";
1769        for (size_t i = 0; i != count(); ++i) {
1770          *os << "element #" << i << " ";
1771          matchers_[i].DescribeTo(os);
1772          if (i + 1 < count()) {
1773            *os << ",\n";
1774          }
1775        }
1776      }
1777    }
1778    virtual void DescribeNegationTo(::std::ostream* os) const {
1779      if (count() == 0) {
1780        *os << "isn't empty";
1781        return;
1782      }
1783      *os << "doesn't have " << Elements(count()) << ", or\n";
1784      for (size_t i = 0; i != count(); ++i) {
1785        *os << "element #" << i << " ";
1786        matchers_[i].DescribeNegationTo(os);
1787        if (i + 1 < count()) {
1788          *os << ", or\n";
1789        }
1790      }
1791    }
1792    virtual bool MatchAndExplain(Container container,
1793                                 MatchResultListener* listener) const {
1794      const bool listener_interested = listener->IsInterested();
1795      ::std::vector<internal::string> explanations(count());
1796      StlContainerReference stl_container = View::ConstReference(container);
1797      typename StlContainer::const_iterator it = stl_container.begin();
1798      size_t exam_pos = 0;
1799      bool mismatch_found = false;  
1800      for (; it != stl_container.end() && exam_pos != count(); ++it, ++exam_pos) {
1801        bool match;  
1802        if (listener_interested) {
1803          StringMatchResultListener s;
1804          match = matchers_[exam_pos].MatchAndExplain(*it, &s);
1805          explanations[exam_pos] = s.str();
1806        } else {
1807          match = matchers_[exam_pos].Matches(*it);
1808        }
1809        if (!match) {
1810          mismatch_found = true;
1811          break;
1812        }
1813      }
1814      size_t actual_count = exam_pos;
1815      for (; it != stl_container.end(); ++it) {
1816        ++actual_count;
1817      }
1818      if (actual_count != count()) {
1819        if (listener_interested && (actual_count != 0)) {
1820          *listener << "which has " << Elements(actual_count);
1821        }
1822        return false;
1823      }
1824      if (mismatch_found) {
1825        if (listener_interested) {
1826          *listener << "whose element #" << exam_pos << " doesn't match";
1827          PrintIfNotEmpty(explanations[exam_pos], listener->stream());
1828        }
1829        return false;
1830      }
1831      if (listener_interested) {
1832        bool reason_printed = false;
1833        for (size_t i = 0; i != count(); ++i) {
1834          const internal::string& s = explanations[i];
1835          if (!s.empty()) {
1836            if (reason_printed) {
1837              *listener << ",\nand ";
1838            }
1839            *listener << "whose element #" << i << " matches, " << s;
1840            reason_printed = true;
1841          }
1842        }
1843      }
1844      return true;
1845    }
1846   private:
1847    static Message Elements(size_t count) {
1848      return Message() << count << (count == 1 ? " element" : " elements");
1849    }
1850    size_t count() const { return matchers_.size(); }
1851    ::std::vector<Matcher<const Element&> > matchers_;
1852    GTEST_DISALLOW_ASSIGN_(ElementsAreMatcherImpl);
1853  };
1854  class GTEST_API_ MatchMatrix {
1855   public:
1856    MatchMatrix(size_t num_elements, size_t num_matchers)
1857        : num_elements_(num_elements),
1858          num_matchers_(num_matchers),
1859          matched_(num_elements_* num_matchers_, 0) {
1860    }
1861    size_t LhsSize() const { return num_elements_; }
1862    size_t RhsSize() const { return num_matchers_; }
1863    bool HasEdge(size_t ilhs, size_t irhs) const {
1864      return matched_[SpaceIndex(ilhs, irhs)] == 1;
1865    }
1866    void SetEdge(size_t ilhs, size_t irhs, bool b) {
1867      matched_[SpaceIndex(ilhs, irhs)] = b ? 1 : 0;
1868    }
1869    bool NextGraph();
1870    void Randomize();
1871    string DebugString() const;
1872   private:
1873    size_t SpaceIndex(size_t ilhs, size_t irhs) const {
1874      return ilhs * num_matchers_ + irhs;
1875    }
1876    size_t num_elements_;
1877    size_t num_matchers_;
1878    ::std::vector<char> matched_;
1879  };
1880  typedef ::std::pair<size_t, size_t> ElementMatcherPair;
1881  typedef ::std::vector<ElementMatcherPair> ElementMatcherPairs;
1882  GTEST_API_ ElementMatcherPairs
1883  FindMaxBipartiteMatching(const MatchMatrix& g);
1884  GTEST_API_ bool FindPairing(const MatchMatrix& matrix,
1885                              MatchResultListener* listener);
1886  class GTEST_API_ UnorderedElementsAreMatcherImplBase {
1887   protected:
1888    typedef ::std::vector<const MatcherDescriberInterface*> MatcherDescriberVec;
1889    void DescribeToImpl(::std::ostream* os) const;
1890    void DescribeNegationToImpl(::std::ostream* os) const;
1891    bool VerifyAllElementsAndMatchersAreMatched(
1892        const ::std::vector<string>& element_printouts,
1893        const MatchMatrix& matrix,
1894        MatchResultListener* listener) const;
1895    MatcherDescriberVec& matcher_describers() {
1896      return matcher_describers_;
1897    }
1898    static Message Elements(size_t n) {
1899      return Message() << n << " element" << (n == 1 ? "" : "s");
1900    }
1901   private:
1902    MatcherDescriberVec matcher_describers_;
1903    GTEST_DISALLOW_ASSIGN_(UnorderedElementsAreMatcherImplBase);
1904  };
1905  template <typename Container>
1906  class UnorderedElementsAreMatcherImpl
1907      : public MatcherInterface<Container>,
1908        public UnorderedElementsAreMatcherImplBase {
1909   public:
1910    typedef GTEST_REMOVE_REFERENCE_AND_CONST_(Container) RawContainer;
1911    typedef internal::StlContainerView<RawContainer> View;
1912    typedef typename View::type StlContainer;
1913    typedef typename View::const_reference StlContainerReference;
1914    typedef typename StlContainer::const_iterator StlContainerConstIterator;
1915    typedef typename StlContainer::value_type Element;
1916    template <typename InputIter>
1917    UnorderedElementsAreMatcherImpl(InputIter first, InputIter last) {
1918      for (; first != last; ++first) {
1919        matchers_.push_back(MatcherCast<const Element&>(*first));
1920        matcher_describers().push_back(matchers_.back().GetDescriber());
1921      }
1922    }
1923    virtual void DescribeTo(::std::ostream* os) const {
1924      return UnorderedElementsAreMatcherImplBase::DescribeToImpl(os);
1925    }
1926    virtual void DescribeNegationTo(::std::ostream* os) const {
1927      return UnorderedElementsAreMatcherImplBase::DescribeNegationToImpl(os);
1928    }
1929    virtual bool MatchAndExplain(Container container,
1930                                 MatchResultListener* listener) const {
1931      StlContainerReference stl_container = View::ConstReference(container);
1932      ::std::vector<string> element_printouts;
1933      MatchMatrix matrix = AnalyzeElements(stl_container.begin(),
1934                                           stl_container.end(),
1935                                           &element_printouts,
1936                                           listener);
1937      const size_t actual_count = matrix.LhsSize();
1938      if (actual_count == 0 && matchers_.empty()) {
1939        return true;
1940      }
1941      if (actual_count != matchers_.size()) {
1942        if (actual_count != 0 && listener->IsInterested()) {
1943          *listener << "which has " << Elements(actual_count);
1944        }
1945        return false;
1946      }
1947      return VerifyAllElementsAndMatchersAreMatched(element_printouts,
1948                                                    matrix, listener) &&
1949             FindPairing(matrix, listener);
1950    }
1951   private:
1952    typedef ::std::vector<Matcher<const Element&> > MatcherVec;
1953    template <typename ElementIter>
1954    MatchMatrix AnalyzeElements(ElementIter elem_first, ElementIter elem_last,
1955                                ::std::vector<string>* element_printouts,
1956                                MatchResultListener* listener) const {
1957      element_printouts->clear();
1958      ::std::vector<char> did_match;
1959      size_t num_elements = 0;
1960      for (; elem_first != elem_last; ++num_elements, ++elem_first) {
1961        if (listener->IsInterested()) {
1962          element_printouts->push_back(PrintToString(*elem_first));
1963        }
1964        for (size_t irhs = 0; irhs != matchers_.size(); ++irhs) {
1965          did_match.push_back(Matches(matchers_[irhs])(*elem_first));
1966        }
1967      }
1968      MatchMatrix matrix(num_elements, matchers_.size());
1969      ::std::vector<char>::const_iterator did_match_iter = did_match.begin();
1970      for (size_t ilhs = 0; ilhs != num_elements; ++ilhs) {
1971        for (size_t irhs = 0; irhs != matchers_.size(); ++irhs) {
1972          matrix.SetEdge(ilhs, irhs, *did_match_iter++ != 0);
1973        }
1974      }
1975      return matrix;
1976    }
1977    MatcherVec matchers_;
1978    GTEST_DISALLOW_ASSIGN_(UnorderedElementsAreMatcherImpl);
1979  };
1980  template <typename Target>
1981  struct CastAndAppendTransform {
1982    template <typename Arg>
1983    Matcher<Target> operator()(const Arg& a) const {
1984      return MatcherCast<Target>(a);
1985    }
1986  };
1987  template <typename MatcherTuple>
1988  class UnorderedElementsAreMatcher {
1989   public:
1990    explicit UnorderedElementsAreMatcher(const MatcherTuple& args)
1991        : matchers_(args) {}
1992    template <typename Container>
1993    operator Matcher<Container>() const {
1994      typedef GTEST_REMOVE_REFERENCE_AND_CONST_(Container) RawContainer;
1995      typedef typename internal::StlContainerView<RawContainer>::type View;
1996      typedef typename View::value_type Element;
1997      typedef ::std::vector<Matcher<const Element&> > MatcherVec;
1998      MatcherVec matchers;
1999      matchers.reserve(::std::tr1::tuple_size<MatcherTuple>::value);
2000      TransformTupleValues(CastAndAppendTransform<const Element&>(), matchers_,
2001                           ::std::back_inserter(matchers));
2002      return MakeMatcher(new UnorderedElementsAreMatcherImpl<Container>(
2003                             matchers.begin(), matchers.end()));
2004    }
2005   private:
2006    const MatcherTuple matchers_;
2007    GTEST_DISALLOW_ASSIGN_(UnorderedElementsAreMatcher);
2008  };
2009  template <typename MatcherTuple>
2010  class ElementsAreMatcher {
2011   public:
2012    explicit ElementsAreMatcher(const MatcherTuple& args) : matchers_(args) {}
2013    template <typename Container>
2014    operator Matcher<Container>() const {
2015      typedef GTEST_REMOVE_REFERENCE_AND_CONST_(Container) RawContainer;
2016      typedef typename internal::StlContainerView<RawContainer>::type View;
2017      typedef typename View::value_type Element;
2018      typedef ::std::vector<Matcher<const Element&> > MatcherVec;
2019      MatcherVec matchers;
2020      matchers.reserve(::std::tr1::tuple_size<MatcherTuple>::value);
2021      TransformTupleValues(CastAndAppendTransform<const Element&>(), matchers_,
2022                           ::std::back_inserter(matchers));
2023      return MakeMatcher(new ElementsAreMatcherImpl<Container>(
2024                             matchers.begin(), matchers.end()));
2025    }
2026   private:
2027    const MatcherTuple matchers_;
2028    GTEST_DISALLOW_ASSIGN_(ElementsAreMatcher);
2029  };
2030  template <typename T>
2031  class UnorderedElementsAreArrayMatcher {
2032   public:
2033    UnorderedElementsAreArrayMatcher() {}
2034    template <typename Iter>
2035    UnorderedElementsAreArrayMatcher(Iter first, Iter last)
2036        : matchers_(first, last) {}
2037    template <typename Container>
2038    operator Matcher<Container>() const {
2039      return MakeMatcher(
2040          new UnorderedElementsAreMatcherImpl<Container>(matchers_.begin(),
2041                                                         matchers_.end()));
2042    }
2043   private:
2044    ::std::vector<T> matchers_;
2045    GTEST_DISALLOW_ASSIGN_(UnorderedElementsAreArrayMatcher);
2046  };
2047  template <typename T>
2048  class ElementsAreArrayMatcher {
2049   public:
2050    template <typename Iter>
2051    ElementsAreArrayMatcher(Iter first, Iter last) : matchers_(first, last) {}
2052    template <typename Container>
2053    operator Matcher<Container>() const {
2054      return MakeMatcher(new ElementsAreMatcherImpl<Container>(
2055          matchers_.begin(), matchers_.end()));
2056    }
2057   private:
2058    const ::std::vector<T> matchers_;
2059    GTEST_DISALLOW_ASSIGN_(ElementsAreArrayMatcher);
2060  };
2061  GTEST_API_ string FormatMatcherDescription(bool negation,
2062                                             const char* matcher_name,
2063                                             const Strings& param_values);
2064  }  
2065  template <typename Iter>
2066  inline internal::ElementsAreArrayMatcher<
2067      typename ::std::iterator_traits<Iter>::value_type>
2068  ElementsAreArray(Iter first, Iter last) {
2069    typedef typename ::std::iterator_traits<Iter>::value_type T;
2070    return internal::ElementsAreArrayMatcher<T>(first, last);
2071  }
2072  template <typename T>
2073  inline internal::ElementsAreArrayMatcher<T> ElementsAreArray(
2074      const T* pointer, size_t count) {
2075    return ElementsAreArray(pointer, pointer + count);
2076  }
2077  template <typename T, size_t N>
2078  inline internal::ElementsAreArrayMatcher<T> ElementsAreArray(
2079      const T (&array)[N]) {
2080    return ElementsAreArray(array, N);
2081  }
2082  template <typename T, typename A>
2083  inline internal::ElementsAreArrayMatcher<T> ElementsAreArray(
2084      const ::std::vector<T, A>& vec) {
2085    return ElementsAreArray(vec.begin(), vec.end());
2086  }
2087  #if GTEST_LANG_CXX11
2088  template <typename T>
2089  inline internal::ElementsAreArrayMatcher<T>
2090  ElementsAreArray(::std::initializer_list<T> xs) {
2091    return ElementsAreArray(xs.begin(), xs.end());
2092  }
2093  #endif
2094  template <typename Iter>
2095  inline internal::UnorderedElementsAreArrayMatcher<
2096      typename ::std::iterator_traits<Iter>::value_type>
2097  UnorderedElementsAreArray(Iter first, Iter last) {
2098    typedef typename ::std::iterator_traits<Iter>::value_type T;
2099    return internal::UnorderedElementsAreArrayMatcher<T>(first, last);
2100  }
2101  template <typename T>
2102  inline internal::UnorderedElementsAreArrayMatcher<T>
2103  UnorderedElementsAreArray(const T* pointer, size_t count) {
2104    return UnorderedElementsAreArray(pointer, pointer + count);
2105  }
2106  template <typename T, size_t N>
2107  inline internal::UnorderedElementsAreArrayMatcher<T>
2108  UnorderedElementsAreArray(const T (&array)[N]) {
2109    return UnorderedElementsAreArray(array, N);
2110  }
2111  template <typename T, typename A>
2112  inline internal::UnorderedElementsAreArrayMatcher<T>
2113  UnorderedElementsAreArray(const ::std::vector<T, A>& vec) {
2114    return UnorderedElementsAreArray(vec.begin(), vec.end());
2115  }
2116  #if GTEST_LANG_CXX11
2117  template <typename T>
2118  inline internal::UnorderedElementsAreArrayMatcher<T>
2119  UnorderedElementsAreArray(::std::initializer_list<T> xs) {
2120    return UnorderedElementsAreArray(xs.begin(), xs.end());
2121  }
2122  #endif
2123  const internal::AnythingMatcher _ = {};
2124  template <typename T>
2125  inline Matcher<T> A() { return MakeMatcher(new internal::AnyMatcherImpl<T>()); }
2126  template <typename T>
2127  inline Matcher<T> An() { return A<T>(); }
2128  template <typename T>
2129  inline internal::EqMatcher<T> Eq(T x) { return internal::EqMatcher<T>(x); }
2130  template <typename T>
2131  Matcher<T>::Matcher(T value) { *this = Eq(value); }
2132  template <typename Lhs, typename Rhs>
2133  inline Matcher<Lhs> TypedEq(const Rhs& rhs) { return Eq(rhs); }
2134  template <typename Rhs>
2135  inline internal::GeMatcher<Rhs> Ge(Rhs x) {
2136    return internal::GeMatcher<Rhs>(x);
2137  }
2138  template <typename Rhs>
2139  inline internal::GtMatcher<Rhs> Gt(Rhs x) {
2140    return internal::GtMatcher<Rhs>(x);
2141  }
2142  template <typename Rhs>
2143  inline internal::LeMatcher<Rhs> Le(Rhs x) {
2144    return internal::LeMatcher<Rhs>(x);
2145  }
2146  template <typename Rhs>
2147  inline internal::LtMatcher<Rhs> Lt(Rhs x) {
2148    return internal::LtMatcher<Rhs>(x);
2149  }
2150  template <typename Rhs>
2151  inline internal::NeMatcher<Rhs> Ne(Rhs x) {
2152    return internal::NeMatcher<Rhs>(x);
2153  }
2154  inline PolymorphicMatcher<internal::IsNullMatcher > IsNull() {
2155    return MakePolymorphicMatcher(internal::IsNullMatcher());
2156  }
2157  inline PolymorphicMatcher<internal::NotNullMatcher > NotNull() {
2158    return MakePolymorphicMatcher(internal::NotNullMatcher());
2159  }
2160  template <typename T>
2161  inline internal::RefMatcher<T&> Ref(T& x) {  
2162    return internal::RefMatcher<T&>(x);
2163  }
2164  inline internal::FloatingEqMatcher<double> DoubleEq(double rhs) {
2165    return internal::FloatingEqMatcher<double>(rhs, false);
2166  }
2167  inline internal::FloatingEqMatcher<double> NanSensitiveDoubleEq(double rhs) {
2168    return internal::FloatingEqMatcher<double>(rhs, true);
2169  }
2170  inline internal::FloatingEqMatcher<double> DoubleNear(
2171      double rhs, double max_abs_error) {
2172    return internal::FloatingEqMatcher<double>(rhs, false, max_abs_error);
2173  }
2174  inline internal::FloatingEqMatcher<double> NanSensitiveDoubleNear(
2175      double rhs, double max_abs_error) {
2176    return internal::FloatingEqMatcher<double>(rhs, true, max_abs_error);
2177  }
2178  inline internal::FloatingEqMatcher<float> FloatEq(float rhs) {
2179    return internal::FloatingEqMatcher<float>(rhs, false);
2180  }
2181  inline internal::FloatingEqMatcher<float> NanSensitiveFloatEq(float rhs) {
2182    return internal::FloatingEqMatcher<float>(rhs, true);
2183  }
2184  inline internal::FloatingEqMatcher<float> FloatNear(
2185      float rhs, float max_abs_error) {
2186    return internal::FloatingEqMatcher<float>(rhs, false, max_abs_error);
2187  }
2188  inline internal::FloatingEqMatcher<float> NanSensitiveFloatNear(
2189      float rhs, float max_abs_error) {
2190    return internal::FloatingEqMatcher<float>(rhs, true, max_abs_error);
2191  }
2192  template <typename InnerMatcher>
2193  inline internal::PointeeMatcher<InnerMatcher> Pointee(
2194      const InnerMatcher& inner_matcher) {
2195    return internal::PointeeMatcher<InnerMatcher>(inner_matcher);
2196  }
2197  template <typename Class, typename FieldType, typename FieldMatcher>
2198  inline PolymorphicMatcher<
2199    internal::FieldMatcher<Class, FieldType> > Field(
2200      FieldType Class::*field, const FieldMatcher& matcher) {
2201    return MakePolymorphicMatcher(
2202        internal::FieldMatcher<Class, FieldType>(
2203            field, MatcherCast<const FieldType&>(matcher)));
2204  }
2205  template <typename Class, typename PropertyType, typename PropertyMatcher>
2206  inline PolymorphicMatcher<
2207    internal::PropertyMatcher<Class, PropertyType> > Property(
2208      PropertyType (Class::*property)() const, const PropertyMatcher& matcher) {
2209    return MakePolymorphicMatcher(
2210        internal::PropertyMatcher<Class, PropertyType>(
2211            property,
2212            MatcherCast<GTEST_REFERENCE_TO_CONST_(PropertyType)>(matcher)));
2213  }
2214  template <typename Callable, typename ResultOfMatcher>
2215  internal::ResultOfMatcher<Callable> ResultOf(
2216      Callable callable, const ResultOfMatcher& matcher) {
2217    return internal::ResultOfMatcher<Callable>(
2218            callable,
2219            MatcherCast<typename internal::CallableTraits<Callable>::ResultType>(
2220                matcher));
2221  }
2222  inline PolymorphicMatcher<internal::StrEqualityMatcher<internal::string> >
2223      StrEq(const internal::string& str) {
2224    return MakePolymorphicMatcher(internal::StrEqualityMatcher<internal::string>(
2225        str, true, true));
2226  }
2227  inline PolymorphicMatcher<internal::StrEqualityMatcher<internal::string> >
2228      StrNe(const internal::string& str) {
2229    return MakePolymorphicMatcher(internal::StrEqualityMatcher<internal::string>(
2230        str, false, true));
2231  }
2232  inline PolymorphicMatcher<internal::StrEqualityMatcher<internal::string> >
2233      StrCaseEq(const internal::string& str) {
2234    return MakePolymorphicMatcher(internal::StrEqualityMatcher<internal::string>(
2235        str, true, false));
2236  }
2237  inline PolymorphicMatcher<internal::StrEqualityMatcher<internal::string> >
2238      StrCaseNe(const internal::string& str) {
2239    return MakePolymorphicMatcher(internal::StrEqualityMatcher<internal::string>(
2240        str, false, false));
2241  }
2242  inline PolymorphicMatcher<internal::HasSubstrMatcher<internal::string> >
2243      HasSubstr(const internal::string& substring) {
2244    return MakePolymorphicMatcher(internal::HasSubstrMatcher<internal::string>(
2245        substring));
2246  }
2247  inline PolymorphicMatcher<internal::StartsWithMatcher<internal::string> >
2248      StartsWith(const internal::string& prefix) {
2249    return MakePolymorphicMatcher(internal::StartsWithMatcher<internal::string>(
2250        prefix));
2251  }
2252  inline PolymorphicMatcher<internal::EndsWithMatcher<internal::string> >
2253      EndsWith(const internal::string& suffix) {
2254    return MakePolymorphicMatcher(internal::EndsWithMatcher<internal::string>(
2255        suffix));
2256  }
2257  inline PolymorphicMatcher<internal::MatchesRegexMatcher> MatchesRegex(
2258      const internal::RE* regex) {
2259    return MakePolymorphicMatcher(internal::MatchesRegexMatcher(regex, true));
2260  }
2261  inline PolymorphicMatcher<internal::MatchesRegexMatcher> MatchesRegex(
2262      const internal::string& regex) {
2263    return MatchesRegex(new internal::RE(regex));
2264  }
2265  inline PolymorphicMatcher<internal::MatchesRegexMatcher> ContainsRegex(
2266      const internal::RE* regex) {
2267    return MakePolymorphicMatcher(internal::MatchesRegexMatcher(regex, false));
2268  }
2269  inline PolymorphicMatcher<internal::MatchesRegexMatcher> ContainsRegex(
2270      const internal::string& regex) {
2271    return ContainsRegex(new internal::RE(regex));
2272  }
2273  #if GTEST_HAS_GLOBAL_WSTRING || GTEST_HAS_STD_WSTRING
2274  inline PolymorphicMatcher<internal::StrEqualityMatcher<internal::wstring> >
2275      StrEq(const internal::wstring& str) {
2276    return MakePolymorphicMatcher(internal::StrEqualityMatcher<internal::wstring>(
2277        str, true, true));
2278  }
2279  inline PolymorphicMatcher<internal::StrEqualityMatcher<internal::wstring> >
2280      StrNe(const internal::wstring& str) {
2281    return MakePolymorphicMatcher(internal::StrEqualityMatcher<internal::wstring>(
2282        str, false, true));
2283  }
2284  inline PolymorphicMatcher<internal::StrEqualityMatcher<internal::wstring> >
2285      StrCaseEq(const internal::wstring& str) {
2286    return MakePolymorphicMatcher(internal::StrEqualityMatcher<internal::wstring>(
2287        str, true, false));
2288  }
2289  inline PolymorphicMatcher<internal::StrEqualityMatcher<internal::wstring> >
2290      StrCaseNe(const internal::wstring& str) {
2291    return MakePolymorphicMatcher(internal::StrEqualityMatcher<internal::wstring>(
2292        str, false, false));
2293  }
2294  inline PolymorphicMatcher<internal::HasSubstrMatcher<internal::wstring> >
2295      HasSubstr(const internal::wstring& substring) {
2296    return MakePolymorphicMatcher(internal::HasSubstrMatcher<internal::wstring>(
2297        substring));
2298  }
2299  inline PolymorphicMatcher<internal::StartsWithMatcher<internal::wstring> >
2300      StartsWith(const internal::wstring& prefix) {
2301    return MakePolymorphicMatcher(internal::StartsWithMatcher<internal::wstring>(
2302        prefix));
2303  }
2304  inline PolymorphicMatcher<internal::EndsWithMatcher<internal::wstring> >
2305      EndsWith(const internal::wstring& suffix) {
2306    return MakePolymorphicMatcher(internal::EndsWithMatcher<internal::wstring>(
2307        suffix));
2308  }
2309  #endif  
2310  inline internal::Eq2Matcher Eq() { return internal::Eq2Matcher(); }
2311  inline internal::Ge2Matcher Ge() { return internal::Ge2Matcher(); }
2312  inline internal::Gt2Matcher Gt() { return internal::Gt2Matcher(); }
2313  inline internal::Le2Matcher Le() { return internal::Le2Matcher(); }
2314  inline internal::Lt2Matcher Lt() { return internal::Lt2Matcher(); }
2315  inline internal::Ne2Matcher Ne() { return internal::Ne2Matcher(); }
2316  template <typename InnerMatcher>
2317  inline internal::NotMatcher<InnerMatcher> Not(InnerMatcher m) {
2318    return internal::NotMatcher<InnerMatcher>(m);
2319  }
2320  template <typename Predicate>
2321  inline PolymorphicMatcher<internal::TrulyMatcher<Predicate> >
2322  Truly(Predicate pred) {
2323    return MakePolymorphicMatcher(internal::TrulyMatcher<Predicate>(pred));
2324  }
2325  template <typename SizeMatcher>
2326  inline internal::SizeIsMatcher<SizeMatcher>
2327  SizeIs(const SizeMatcher& size_matcher) {
2328    return internal::SizeIsMatcher<SizeMatcher>(size_matcher);
2329  }
2330  template <typename Container>
2331  inline PolymorphicMatcher<internal::ContainerEqMatcher<  
2332                              GTEST_REMOVE_CONST_(Container)> >
2333      ContainerEq(const Container& rhs) {
2334    typedef GTEST_REMOVE_CONST_(Container) RawContainer;
2335    return MakePolymorphicMatcher(
2336        internal::ContainerEqMatcher<RawContainer>(rhs));
2337  }
2338  template <typename Comparator, typename ContainerMatcher>
2339  inline internal::WhenSortedByMatcher<Comparator, ContainerMatcher>
2340  WhenSortedBy(const Comparator& comparator,
2341               const ContainerMatcher& container_matcher) {
2342    return internal::WhenSortedByMatcher<Comparator, ContainerMatcher>(
2343        comparator, container_matcher);
2344  }
2345  template <typename ContainerMatcher>
2346  inline internal::WhenSortedByMatcher<internal::LessComparator, ContainerMatcher>
2347  WhenSorted(const ContainerMatcher& container_matcher) {
2348    return
2349        internal::WhenSortedByMatcher<internal::LessComparator, ContainerMatcher>(
2350            internal::LessComparator(), container_matcher);
2351  }
2352  template <typename TupleMatcher, typename Container>
2353  inline internal::PointwiseMatcher<TupleMatcher,
2354                                    GTEST_REMOVE_CONST_(Container)>
2355  Pointwise(const TupleMatcher& tuple_matcher, const Container& rhs) {
2356    typedef GTEST_REMOVE_CONST_(Container) RawContainer;
2357    return internal::PointwiseMatcher<TupleMatcher, RawContainer>(
2358        tuple_matcher, rhs);
2359  }
2360  template <typename M>
2361  inline internal::ContainsMatcher<M> Contains(M matcher) {
2362    return internal::ContainsMatcher<M>(matcher);
2363  }
2364  template <typename M>
2365  inline internal::EachMatcher<M> Each(M matcher) {
2366    return internal::EachMatcher<M>(matcher);
2367  }
2368  template <typename M>
2369  inline internal::KeyMatcher<M> Key(M inner_matcher) {
2370    return internal::KeyMatcher<M>(inner_matcher);
2371  }
2372  template <typename FirstMatcher, typename SecondMatcher>
2373  inline internal::PairMatcher<FirstMatcher, SecondMatcher>
2374  Pair(FirstMatcher first_matcher, SecondMatcher second_matcher) {
2375    return internal::PairMatcher<FirstMatcher, SecondMatcher>(
2376        first_matcher, second_matcher);
2377  }
2378  template <typename M>
2379  inline internal::MatcherAsPredicate<M> Matches(M matcher) {
2380    return internal::MatcherAsPredicate<M>(matcher);
2381  }
2382  template <typename T, typename M>
2383  inline bool Value(const T& value, M matcher) {
2384    return testing::Matches(matcher)(value);
2385  }
2386  template <typename T, typename M>
2387  inline bool ExplainMatchResult(
2388      M matcher, const T& value, MatchResultListener* listener) {
2389    return SafeMatcherCast<const T&>(matcher).MatchAndExplain(value, listener);
2390  }
2391  #if GTEST_LANG_CXX11
2392  template <typename... Args>
2393  inline internal::AllOfMatcher<Args...> AllOf(const Args&... matchers) {
2394    return internal::AllOfMatcher<Args...>(matchers...);
2395  }
2396  template <typename... Args>
2397  inline internal::AnyOfMatcher<Args...> AnyOf(const Args&... matchers) {
2398    return internal::AnyOfMatcher<Args...>(matchers...);
2399  }
2400  #endif  
2401  template <typename InnerMatcher>
2402  inline InnerMatcher AllArgs(const InnerMatcher& matcher) { return matcher; }
2403  #define ASSERT_THAT(value, matcher) ASSERT_PRED_FORMAT1(\
2404      ::testing::internal::MakePredicateFormatterFromMatcher(matcher), value)
2405  #define EXPECT_THAT(value, matcher) EXPECT_PRED_FORMAT1(\
2406      ::testing::internal::MakePredicateFormatterFromMatcher(matcher), value)
2407  }  
2408  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-table.cpp</h3>
            <pre><code>1  void TPredicateNode::GetVariables(TStrV& Variables) {
2    if (Left != NULL) { Left->GetVariables(Variables); }
3    if (Right != NULL) { Right->GetVariables(Variables); }
4    if (Op == NOP) {
5      if (Atom.Lvar != "" ) { Variables.Add(Atom.Lvar); }
6      if (Atom.Rvar != "" ) { Variables.Add(Atom.Rvar); }
7    }
8  }
9  void TPredicate::GetVariables(TStrV& Variables) {
10    Root->GetVariables(Variables);
11  }
12  TBool TPredicate::Eval() {
13    TPredicateNode* Curr = Root;
14    TPredicateNode* Prev = NULL;
15    while (!(Curr == NULL && Prev == Root)) {
16      if (Prev == NULL || Prev == Curr->Parent) {
17        if (Curr->Left != NULL) {
18          Prev = Curr;
19          Curr = Curr->Left;
20        } else if (Curr->Right != NULL) {
21          Prev = Curr;
22          Curr = Curr->Right;
23        } else {
24          Curr->Result = EvalAtomicPredicate(Curr->Atom);
25          Prev = Curr;
26          Curr = Curr->Parent;
27        }
28      } else if (Prev == Curr->Left) {
29        switch (Curr->Op) {
30          case NOT: {
31            Assert(Curr->Right == NULL);
32            Curr->Result = !(Prev->Result);
33            Prev = Curr;
34            Curr = Curr->Parent;
35            break;
36          }
37          case AND: {
38            Assert(Curr->Right != NULL);
39            if (!Prev->Result) {
40              Curr->Result = false;
41              Prev = Curr;
42              Curr = Curr->Parent;
43            } else {
44              Prev = Curr;
45              Curr = Curr->Right;
46            }
47            break;
48          }
49          case OR: {
50            Assert(Curr->Right != NULL);
51            if (Prev->Result) {
52              Curr->Result = true;
53              Prev = Curr;
54              Curr = Curr->Parent;
55            } else {
56              Prev = Curr;
57              Curr = Curr->Right;
58            }
59            break;
60          }
61          case NOP: {
62            break;
63          }
64        }
65      } else {
66        Assert(Prev == Curr->Right);
67        switch (Curr->Op) {
68          case NOT: {
69            Assert(Curr->Left == NULL);
70            Curr->Result = !(Prev->Result);
71            break;
72          }
73          case AND: {
74            Assert(Curr->Left != NULL);
75            Assert(Curr->Left->Result);
76            Curr->Result = Prev->Result;
77            break;
78          }
79          case OR: {
80            Assert(Curr->Left != NULL);
81            Assert(!Curr->Left->Result);
82            Curr->Result = Prev->Result;
83            break;
84          }
85          case NOP: {
86            break;
87          }
88        }
89        Prev = Curr;
90        Curr = Curr->Parent;
91      }
92    }
93    return Root->Result;
94  }
95  TBool TPredicate::EvalAtomicPredicate(const TAtomicPredicate& Atom) {
96    switch (Atom.Type) {
97      case atInt: {
98        if (Atom.IsConst) { 
99          return EvalAtom<TInt>(IntVars.GetDat(Atom.Lvar), Atom.IntConst, Atom.Compare); 
100        }
101        return EvalAtom<TInt>(IntVars.GetDat(Atom.Lvar), IntVars.GetDat(Atom.Rvar), Atom.Compare);
102      }
103      case atFlt: {
104        if (Atom.IsConst) { 
105          return EvalAtom<TFlt>(FltVars.GetDat(Atom.Lvar), Atom.FltConst, Atom.Compare); 
106        }
107        return EvalAtom<TFlt>(FltVars.GetDat(Atom.Lvar), FltVars.GetDat(Atom.Rvar), Atom.Compare);
108      }
109      case atStr: {
110        if (Atom.IsConst) { 
111          return EvalAtom<TStr>(StrVars.GetDat(Atom.Lvar), Atom.StrConst, Atom.Compare); 
112        }
113        return EvalAtom<TStr>(StrVars.GetDat(Atom.Lvar), StrVars.GetDat(Atom.Rvar), Atom.Compare);
114      }
115    }
116    return false;
117  }
118  TInt const TTable::Last = -1;
119  TInt const TTable::Invalid = -2;
120  TInt TTable::UseMP = 1;
121  TRowIterator& TRowIterator::operator++(int) {
122    return this->Next();
123  }
124  TRowIterator& TRowIterator::Next() {
125    CurrRowIdx = Table->Next[CurrRowIdx];
126    return *this;
127  }
128  bool TRowIterator::operator < (const TRowIterator& RowI) const{
129    if (CurrRowIdx == TTable::Last) { return false; }
130    if (RowI.CurrRowIdx == TTable::Last) { return true; }
131    return CurrRowIdx < RowI.CurrRowIdx;
132  }
133  bool TRowIterator::operator == (const TRowIterator& RowI) const {
134    return CurrRowIdx == RowI.CurrRowIdx;
135  }
136  TInt TRowIterator::GetRowIdx() const {
137    return CurrRowIdx;
138  }
139  TInt TRowIterator::GetIntAttr(TInt ColIdx) const {
140    return Table->IntCols[ColIdx][CurrRowIdx];
141  }
142  TFlt TRowIterator::GetFltAttr(TInt ColIdx) const {
143    return Table->FltCols[ColIdx][CurrRowIdx];
144  }
145  TStr TRowIterator::GetStrAttr(TInt ColIdx) const {
146    return Table->GetStrValIdx(ColIdx, CurrRowIdx);
147  }
148  TInt TRowIterator::GetIntAttr(const TStr& Col) const {
149    TInt ColIdx = Table->GetColIdx(Col);
150    return Table->IntCols[ColIdx][CurrRowIdx];
151  }
152  TFlt TRowIterator::GetFltAttr(const TStr& Col) const {
153    TInt ColIdx = Table->GetColIdx(Col);
154    return Table->FltCols[ColIdx][CurrRowIdx];
155  }
156  TStr TRowIterator::GetStrAttr(const TStr& Col) const {
157    return Table->GetStrVal(Col, CurrRowIdx);
158  }
159  TInt TRowIterator::GetStrMapByName(const TStr& Col) const {
160    TInt ColIdx = Table->GetColIdx(Col);
161    return Table->StrColMaps[ColIdx][CurrRowIdx];
162  }
163  TInt TRowIterator::GetStrMapById(TInt ColIdx) const {
164    return Table->StrColMaps[ColIdx][CurrRowIdx];
165  }
166  TBool TRowIterator::CompareAtomicConst(TInt ColIdx, const TPrimitive& Val, TPredComp Cmp) {
167    TBool Result;
168    switch (Val.GetType()) {
169      case atInt:
170        Result = TPredicate::EvalAtom(GetIntAttr(ColIdx), Val.GetInt(), Cmp);
171        break;
172      case atFlt:
173        Result = TPredicate::EvalAtom(GetFltAttr(ColIdx), Val.GetFlt(), Cmp);
174        break;
175      case atStr:
176        Result = TPredicate::EvalStrAtom(GetStrAttr(ColIdx), Val.GetStr(), Cmp);
177        break;
178      default:
179        Result = TBool(false);
180    }
181    return Result;
182  }
183  TBool TRowIterator::CompareAtomicConstTStr(TInt ColIdx, const TStr& Val, TPredComp Cmp) {
184    TBool Result;
185    Result = TPredicate::EvalStrAtom(GetStrAttr(ColIdx), Val, Cmp);
186    return Result;
187  }
188  TRowIteratorWithRemove::TRowIteratorWithRemove(TInt RowIdx, TTable* TablePtr) :
189    CurrRowIdx(RowIdx), Table(TablePtr), Start(RowIdx == TablePtr->FirstValidRow) {}
190  TRowIteratorWithRemove& TRowIteratorWithRemove::operator++(int) {
191    return this->Next();
192  }
193  TRowIteratorWithRemove& TRowIteratorWithRemove::Next() {
194    CurrRowIdx = GetNextRowIdx();
195    Start = false;
196    Assert(CurrRowIdx != TTable::Invalid);
197    return *this;
198  }
199  bool TRowIteratorWithRemove::operator < (const TRowIteratorWithRemove& RowI) const {
200    if (CurrRowIdx == TTable::Last) { return false; }
201    if (RowI.CurrRowIdx == TTable::Last) { return true; }
202    return CurrRowIdx < RowI.CurrRowIdx;
203  }
204  bool TRowIteratorWithRemove::operator == (const TRowIteratorWithRemove& RowI) const {
205    return CurrRowIdx == RowI.CurrRowIdx;
206  }
207  TInt TRowIteratorWithRemove::GetRowIdx() const {
208    return CurrRowIdx;
209  }
210  TInt TRowIteratorWithRemove::GetNextRowIdx() const {
211    return (Start ? Table->FirstValidRow : Table->Next[CurrRowIdx]);
212  }
213  TInt TRowIteratorWithRemove::GetNextIntAttr(TInt ColIdx) const {
214    return Table->IntCols[ColIdx][GetNextRowIdx()];
215  }
216  TFlt TRowIteratorWithRemove::GetNextFltAttr(TInt ColIdx) const {
217    return Table->FltCols[ColIdx][GetNextRowIdx()];
218  }
219  TStr TRowIteratorWithRemove::GetNextStrAttr(TInt ColIdx) const {
220    return Table->GetStrValIdx(ColIdx, GetNextRowIdx());
221  }
222  TInt TRowIteratorWithRemove::GetNextIntAttr(const TStr& Col) const {
223    TInt ColIdx = Table->GetColIdx(Col);
224    return Table->IntCols[ColIdx][GetNextRowIdx()];
225  }
226  TFlt TRowIteratorWithRemove::GetNextFltAttr(const TStr& Col) const {
227    TInt ColIdx = Table->GetColIdx(Col);
228    return Table->FltCols[ColIdx][GetNextRowIdx()];
229  }
230  TStr TRowIteratorWithRemove::GetNextStrAttr(const TStr& Col) const {
231    return Table->GetStrVal(Col, GetNextRowIdx());
232  }
233  TBool TRowIteratorWithRemove::IsFirst() const {
234    return CurrRowIdx == Table->FirstValidRow;
235  }
236  void TRowIteratorWithRemove::RemoveNext() {
237    Table->RemoveRow(GetNextRowIdx(), CurrRowIdx);
238  }
239  TBool TRowIteratorWithRemove::CompareAtomicConst(TInt ColIdx, const TPrimitive& Val, TPredComp Cmp) {
240    TBool Result;
241    switch (Val.GetType()) {
242      case atInt:
243        Result = TPredicate::EvalAtom(GetNextIntAttr(ColIdx), Val.GetInt(), Cmp);
244        break;
245      case atFlt:
246        Result = TPredicate::EvalAtom(GetNextFltAttr(ColIdx), Val.GetFlt(), Cmp);
247        break;
248      case atStr:
249        Result = TPredicate::EvalStrAtom(GetNextStrAttr(ColIdx), Val.GetStr(), Cmp);
250        break;
251      default:
252        Result = TBool(false);
253    }
254    return Result;
255  }
256  TTable::TTable(): Context(new TTableContext), NumRows(0), NumValidRows(0),
257    FirstValidRow(0), LastValidRow(-1) {}
258  TTable::TTable(TTableContext* Context): Context(Context), NumRows(0),
259    NumValidRows(0), FirstValidRow(0), LastValidRow(-1) {}
260  TTable::TTable(const Schema& TableSchema, TTableContext* Context): Context(Context), 
261    NumRows(0), NumValidRows(0), FirstValidRow(0), LastValidRow(-1), IsNextDirty(0) {
262    TInt IntColCnt = 0;
263    TInt FltColCnt = 0;
264    TInt StrColCnt = 0;
265    for (TInt i = 0; i < TableSchema.Len(); i++) {
266      TStr ColName = TableSchema[i].Val1;
267      TAttrType ColType = TableSchema[i].Val2;
268      AddSchemaCol(ColName, ColType);
269      switch (ColType) {
270        case atInt:
271          AddColType(ColName, atInt, IntColCnt);
272          IntColCnt++;
273          break;
274        case atFlt:
275          AddColType(ColName, atFlt, FltColCnt);
276          FltColCnt++;
277          break;
278        case atStr:
279          AddColType(ColName, atStr, StrColCnt);
280          StrColCnt++;
281          break;
282      }
283    }
284    IntCols = TVec<TIntV>(IntColCnt);
285    FltCols = TVec<TFltV>(FltColCnt);
286    StrColMaps = TVec<TIntV>(StrColCnt);
287  }
288  void TTable::GenerateColTypeMap(THash<TStr,TPair<TInt,TInt> > & ColTypeIntMap) {
289    ColTypeMap.Clr();
290    Sch.Clr();
291    for (THash<TStr,TPair<TInt,TInt> >::TIter it = ColTypeIntMap.BegI(); it < ColTypeIntMap.EndI(); it++) {
292      TPair<TInt,TInt> dat = it.GetDat();
293      switch (dat.GetVal1()) {
294        case 0:
295          AddColType(it.GetKey(), atInt, dat.GetVal2());
296          AddSchemaCol(it.GetKey(), atInt);
297          break;
298        case 1:
299          AddColType(it.GetKey(), atFlt, dat.GetVal2());
300          AddSchemaCol(it.GetKey(), atFlt);
301          break;
302        case 2:
303          AddColType(it.GetKey(), atStr, dat.GetVal2());
304          AddSchemaCol(it.GetKey(), atStr);
305          break;
306      }
307    }
308    IsNextDirty = 0;
309  }
310  void TTable::LoadTableShM(TShMIn& ShMIn, TTableContext* ContextTable) {
311    Context = ContextTable;
312    NumRows = TInt(ShMIn);
313    NumValidRows = TInt(ShMIn);
314    FirstValidRow = TInt(ShMIn);
315    LastValidRow = TInt(ShMIn);
316    Next.LoadShM(ShMIn);
317    TLoadVecInit Fn;
318    IntCols.LoadShM(ShMIn, Fn);
319    FltCols.Load(ShMIn);
320    StrColMaps.LoadShM(ShMIn, Fn);
321    THash<TStr,TPair<TInt,TInt> > ColTypeIntMap;
322    ColTypeIntMap.LoadShM(ShMIn);
323    GenerateColTypeMap(ColTypeIntMap);
324  }
325  TTable::TTable(TSIn& SIn, TTableContext* Context): Context(Context), NumRows(SIn),
326    NumValidRows(SIn), FirstValidRow(SIn), LastValidRow(SIn), Next(SIn), IntCols(SIn),
327    FltCols(SIn), StrColMaps(SIn) {
328    THash<TStr,TPair<TInt,TInt> > ColTypeIntMap(SIn);
329    GenerateColTypeMap(ColTypeIntMap);
330  }
331  TTable::TTable(const TIntIntH& H, const TStr& Col1, const TStr& Col2,
332   TTableContext* Context, const TBool IsStrKeys) : Context(Context), NumRows(H.Len()),
333    NumValidRows(H.Len()), FirstValidRow(0), LastValidRow(H.Len()-1) {
334      TAttrType KeyType = IsStrKeys ? atStr : atInt;
335      AddSchemaCol(Col1, KeyType);
336      AddSchemaCol(Col2, atInt);
337      AddColType(Col1, KeyType, 0);
338      AddColType(Col2, atInt, 1);
339      if (IsStrKeys) {
340        StrColMaps = TVec<TIntV>(1);
341        IntCols = TVec<TIntV>(1);
342        H.GetKeyV(StrColMaps[0]);
343        H.GetDatV(IntCols[0]);
344      } else {
345        IntCols = TVec<TIntV>(2);
346        H.GetKeyV(IntCols[0]);
347        H.GetDatV(IntCols[1]);
348      }
349      Next = TIntV(NumRows);
350      for (TInt i = 0; i < NumRows; i++) {
351        Next[i] = i+1;
352      }
353      Next[NumRows-1] = Last;
354      IsNextDirty = 0;
355      InitIds();
356  }
357  TTable::TTable(const TIntFltH& H, const TStr& Col1, const TStr& Col2,
358   TTableContext* Context, const TBool IsStrKeys) : Context(Context),
359    NumRows(H.Len()), NumValidRows(H.Len()), FirstValidRow(0), LastValidRow(H.Len()-1) {
360    TAttrType KeyType = IsStrKeys ? atStr : atInt;
361    AddSchemaCol(Col1, KeyType);
362    AddSchemaCol(Col2, atFlt);
363    AddColType(Col1, KeyType, 0);
364    AddColType(Col2, atFlt, 0);
365    if (IsStrKeys) {
366      StrColMaps = TVec<TIntV>(1);
367      H.GetKeyV(StrColMaps[0]);
368    } else {
369      IntCols = TVec<TIntV>(1);
370      H.GetKeyV(IntCols[0]);
371    }
372    FltCols = TVec<TFltV>(1);
373    H.GetDatV(FltCols[0]);
374    Next = TIntV(NumRows);
375    for (TInt i = 0; i < NumRows; i++) {
376      Next[i] = i+1;
377    }
378    Next[NumRows-1] = Last;
379    IsNextDirty = 0;
380    InitIds();
381  }
382  TTable::TTable(const TTable& Table, const TIntV& RowIDs) : Context(Table.Context),
383    Sch(Table.Sch), SrcCol(Table.SrcCol), DstCol(Table.DstCol), EdgeAttrV(Table.EdgeAttrV),
384    SrcNodeAttrV(Table.SrcNodeAttrV), DstNodeAttrV(Table.DstNodeAttrV),
385    CommonNodeAttrs(Table.CommonNodeAttrs) {
386    ColTypeMap = Table.ColTypeMap;
387    IntCols = TVec<TIntV>(Table.IntCols.Len());
388    FltCols = TVec<TFltV>(Table.FltCols.Len());
389    StrColMaps = TVec<TIntV>(Table.StrColMaps.Len());
390    FirstValidRow = 0;
391    LastValidRow = -1;
392    NumRows = 0;
393    NumValidRows = 0;
394    AddSelectedRows(Table, RowIDs);
395    IsNextDirty = 0;
396    InitIds();
397  }
398  void TTable::GetSchema(const TStr& InFNm, Schema& S, const char& Separator) {
399    TSsParser Ss(InFNm, '\t', false, false, false);
400    TInt rowsToPeek = 1000;
401    TInt currRow = 0;
402    TInt lastComment = 0;
403    while (Ss.Next()) {
404      if (Ss.IsCmt()) {
405        lastComment += 1;
406      }
407      else break;
408    }
409    if (Ss.Eof()) {TExcept::Throw("No Data to determine attribute types!");}
410    TInt numCols = Ss.GetFlds();
411    TVec<TAttrType> colAttrV(numCols);
412    colAttrV.PutAll(atInt);
413    while (true) {
414      for (TInt i = 0; i < numCols; i++) {
415        if (Ss.IsInt(i)) {
416        }
417        else if (Ss.IsFlt(i)) {
418          colAttrV[i] = atFlt;
419        }
420        else {
421          colAttrV[i] = atStr;
422        }
423      }
424      currRow++;
425      if (currRow > rowsToPeek || Ss.Eof()) break;
426      Ss.Next();
427    }
428    TSsParser SsNames(InFNm, Separator, false, false, false);
429    for (int i = 0; i < lastComment; i++) { SsNames.Next();}
430    TVec<TStr> attrV;
431    TStr first(SsNames[0]);
432    int begin = 0;
433    TStr comment('#');
434    if (first != comment) {
435      for (int i = 1; i < first.Len(); i++){
436        if (first[i] != ' ') { begin = i; break;}
437      }
438      attrV.Add(first.GetSubStr(begin));
439    }
440    for (int i = 1; i < SsNames.GetFlds(); i++) {attrV.Add(SsNames[i]);}
441    for (TInt i = 0; i < numCols; i++) {
442      S.Add(TPair<TStr,TAttrType>(attrV[i],colAttrV[i]));
443    } 
444  }
445  #ifdef GCC_ATOMIC
446  void TTable::LoadSSPar(PTable& T, const Schema& S, const TStr& InFNm, const TIntV& RelevantCols, 
447                          const char& Separator, TBool HasTitleLine) {
448    TInt RowLen = T->Sch.Len();
449    TVec<TAttrType> ColTypes = TVec<TAttrType>(RowLen);
450    for (TInt i = 0; i < RowLen; i++) {
451      ColTypes[i] = T->GetSchemaColType(i);
452    }
453    TSsParserMP Ss(InFNm, Separator);
454    Ss.SkipCommentLines();
455    if (HasTitleLine) {
456      Ss.Next();
457      if (S.Len() != Ss.GetFlds()) {
458        printf("%s\n", Ss[0]); TExcept::Throw("Table Schema Mismatch!");
459      }
460      for (TInt i = 0; i < Ss.GetFlds(); i++) {
461        TInt L = strlen(Ss[i]);
462        if (Ss[i][L-1] < ' ') { Ss[i][L-1] = 0; }
463        if (NormalizeColName(S[i].Val1) != NormalizeColName(Ss[i])) { TExcept::Throw("Table Schema Mismatch!"); }
464      }
465    }
466    int64 Cnt = 0;
467    uint64 Pos = Ss.GetStreamPos();
468    uint64 Len = Ss.GetStreamLen();
469    uint64 Rem = Len - Pos;
470    int NumThreads = omp_get_max_threads();
471    uint64 Delta = Rem / NumThreads;
472    if (Delta < 1) Delta = 1;
473    TVec<uint64> StartIntV(NumThreads);
474    TVec<uint64> LineCountV(NumThreads);
475    TVec<uint64> PrefixSumV(NumThreads);
476    StartIntV[0] = Pos;
477    for (int i = 1; i < NumThreads; i++) {
478      StartIntV[i] = StartIntV[i-1] + Delta;
479    }
480    StartIntV.Add(Len);
481    omp_set_num_threads(NumThreads);
482    #pragma omp parallel for schedule(dynamic) reduction(+:Cnt)
483    for (int i = 0; i < NumThreads; i++) {
484      LineCountV[i] = Ss.CountNewLinesInRange(StartIntV[i], StartIntV[i+1]);
485      Cnt += LineCountV[i];
486    }
487    PrefixSumV[0] = 0;
488    for (int i = 1; i < NumThreads; i++) {
489      PrefixSumV[i] = PrefixSumV[i-1] + LineCountV[i-1];
490    }
491    Ss.SetStreamPos(Pos);
492    TInt IntColIdx = 0;
493    TInt FltColIdx = 0;
494    for (TInt i = 0; i < RowLen; i++) {
495      switch (ColTypes[i]) {
496        case atInt:
497          T->IntCols[IntColIdx].Gen(Cnt);
498          IntColIdx++;
499          break;
500        case atFlt:
501          T->FltCols[FltColIdx].Gen(Cnt);
502          FltColIdx++;
503          break;
504        case atStr:
505          break;
506      }
507    }
508    Cnt = 0;
509    omp_set_num_threads(NumThreads);
510    #pragma omp parallel for schedule(dynamic) reduction(+:Cnt)
511    for (int i = 0; i < NumThreads; i++) {
512      TVec<uint64> LineStartPosV = Ss.GetStartPosV(StartIntV[i], StartIntV[i+1]);
513      for (uint64 k = 0; k < (uint64) LineStartPosV.Len(); k++) {
514        TVec<char*> FieldsV;
515        Ss.NextFromIndex(LineStartPosV[k], FieldsV);
516        if (FieldsV.Len() != S.Len()) {
517          TExcept::Throw("Error reading tsv file");
518        }
519        TInt IntColIdx = 0;
520        TInt FltColIdx = 0;
521        TInt RowIdx = PrefixSumV[i] + k;
522        for (TInt j = 0; j < RowLen; j++) {
523          switch (ColTypes[j]) {
524            case atInt:
525              if (RelevantCols.Len() == 0) {
526                T->IntCols[IntColIdx][RowIdx] = \
527                  (Ss.GetIntFromFldV(FieldsV, j));
528              } else {
529                T->IntCols[IntColIdx][RowIdx] = \
530                  (Ss.GetIntFromFldV(FieldsV, RelevantCols[j]));
531              }
532              IntColIdx++;
533              break;
534            case atFlt:
535              if (RelevantCols.Len() == 0) {
536                T->FltCols[FltColIdx][RowIdx] = \
537                  (Ss.GetFltFromFldV(FieldsV, j));
538              } else {
539                T->FltCols[FltColIdx][RowIdx] = \
540                  (Ss.GetFltFromFldV(FieldsV, RelevantCols[j]));
541              }
542              FltColIdx++;
543              break;
544            case atStr:
545              TExcept::Throw("TTable::LoadSS:: Str Col found\n");
546              break;
547          }
548        }
549        Cnt++;
550      }
551    }
552    T->NumRows = Cnt;
553    T->NumValidRows = T->NumRows;
554    T->Next.Clr();
555    T->Next.Gen(Cnt);
556    omp_set_num_threads(NumThreads);
557    #pragma omp parallel for schedule(dynamic, 10000)
558    for (int64 i = 0; i < Cnt-1; i++) {
559      T->Next[i] = i+1;
560    }
561    T->IsNextDirty = 0;
562    T->Next[Cnt-1] = Last;
563    T->LastValidRow = T->NumRows - 1;
564    T->IdColName = "_id";
565    TInt IdCol = T->IntCols.Add();
566    T->IntCols[IdCol].Gen(Cnt);
567    omp_set_num_threads(NumThreads);
568    #pragma omp parallel for schedule(dynamic, 10000)
569    for (int64 i = 0; i < Cnt; i++) {
570      T->IntCols[IdCol][i] = i;
571    }
572    T->AddSchemaCol(T->IdColName, atInt);
573    T->AddColType(T->IdColName, atInt, T->IntCols.Len()-1);
574  }
575  #endif 
576  void TTable::LoadSSSeq(
577   PTable& T, const Schema& S, const TStr& InFNm, const TIntV& RelevantCols,
578   const char& Separator, TBool HasTitleLine) {
579    int RowLen = T->Sch.Len();
580    TVec<TAttrType> ColTypes = TVec<TAttrType>(RowLen);
581    for (int i = 0; i < RowLen; i++) {
582      ColTypes[i] = T->GetSchemaColType(i);
583    }
584    TSsParser Ss(InFNm, Separator);
585    if (HasTitleLine) {
586      Ss.Next();
587      if (S.Len() != Ss.GetFlds()) {
588        printf("%s\n", Ss[0]); TExcept::Throw("Table Schema Mismatch!");
589      }
590      for (int i = 0; i < Ss.GetFlds(); i++) {
591        int L = strlen(Ss[i]);
592        if (Ss[i][L-1] < ' ') { Ss[i][L-1] = 0; }
593        if (NormalizeColName(S[i].Val1) != NormalizeColName(Ss[i])) { TExcept::Throw("Table Schema Mismatch!"); }
594      }
595    }
596    uint64 Cnt = 0;
597    while (Ss.Next()) {
598      int IntColIdx = 0;
599      int FltColIdx = 0;
600      int StrColIdx = 0;
601      Assert(Ss.GetFlds() == S.Len()); 
602      if (Ss.GetFlds() != S.Len()) {
603        printf("%s\n", Ss[S.Len()]); TExcept::Throw("Error reading tsv file");
604      }
605      for (int i = 0; i < RowLen; i++) {
606        switch (ColTypes[i]) {
607          case atInt:
608            if (RelevantCols.Len() == 0) {
609              T->IntCols[IntColIdx].Add(Ss.GetInt(i));
610            } else {
611              T->IntCols[IntColIdx].Add(Ss.GetInt(RelevantCols[i]));
612            }
613            IntColIdx++;
614            break;
615          case atFlt:
616            if (RelevantCols.Len() == 0) {
617              T->FltCols[FltColIdx].Add(Ss.GetFlt(i));
618            } else {
619              T->FltCols[FltColIdx].Add(Ss.GetFlt(RelevantCols[i]));
620            }
621            FltColIdx++;
622            break;
623          case atStr:
624            int ColIdx;
625            if (RelevantCols.Len() == 0) {
626              ColIdx = i;
627            } else {
628              ColIdx = RelevantCols[i];
629            }
630            TStr Sval = TStr(Ss[ColIdx]);
631            T->AddStrVal(StrColIdx, Sval);
632            StrColIdx++;
633            break;
634        }
635      }
636      Cnt += 1;
637    }
638    T->NumRows = static_cast<int>(Cnt);
639    T->NumValidRows = T->NumRows;
640    T->Next.Clr();
641    T->Next.Gen(static_cast<int>(Cnt));
642    for (uint64 i = 0; i < Cnt-1; i++) {
643      T->Next[static_cast<int>(i)] = static_cast<int>(i+1);
644    }
645    T->IsNextDirty = 0;
646    T->Next[static_cast<int>(Cnt-1)] = Last;
647    T->LastValidRow = T->NumRows - 1;
648    T->InitIds();
649  }
650  PTable TTable::LoadSS(const Schema& S, const TStr& InFNm, TTableContext* Context,
651   const TIntV& RelevantCols, const char& Separator, TBool HasTitleLine) {
652    TVec<uint64> IntGroupByCols;
653    bool NoStringCols = true;
654    Schema SR;
655    if (RelevantCols.Len() == 0) {
656      SR = S;
657    } else {
658      for (int i = 0; i < RelevantCols.Len(); i++) {
659        SR.Add(S[RelevantCols[i]]);
660      }
661    }
662    PTable T = New(SR, Context);
663    for (int i = 0; i < SR.Len(); i++) {
664      if (T->GetSchemaColType(i) == atStr) {
665        NoStringCols = false;
666        break;
667      }
668    }
669    if (GetMP() && NoStringCols) {
670  #ifdef GLib_LINUX
671      LoadSSPar(T, S, InFNm, RelevantCols, Separator, HasTitleLine);
672  #else
673      LoadSSSeq(T, S, InFNm, RelevantCols, Separator, HasTitleLine);
674  #endif
675    } else {
676      LoadSSSeq(T, S, InFNm, RelevantCols, Separator, HasTitleLine);
677    }
678    return T;
679  }
680  PTable TTable::LoadSS(const Schema& S, const TStr& InFNm, TTableContext* Context,
681   const char& Separator, TBool HasTitleLine) {
682    return LoadSS(S, InFNm, Context, TIntV(), Separator, HasTitleLine);
683  }
684  void TTable::SaveSS(const TStr& OutFNm) {
685    if (NumValidRows == 0) {
686      printf("Table is empty");
687      return;
688    }
689    FILE* F = fopen(OutFNm.CStr(), "w");
690    if (F == NULL) {
691      printf("failed to open file %s\n", OutFNm.CStr());
692      perror("fail ");
693      return;
694    }
695    Dump(F);
696  #if 0
697    Schema DSch = DenormalizeSchema();
698    TInt L = Sch.Len();
699    fprintf(F, "# ");
700    for (TInt i = 0; i < L-1; i++) {
701      fprintf(F, "%s\t", DSch[i].Val1.CStr());
702    }  
703    fprintf(F, "%s\n", DSch[L-1].Val1.CStr());
704    for (TRowIterator RowI = BegRI(); RowI < EndRI(); RowI++) {
705      for (TInt i = 0; i < L; i++) {
706        char C = (i == L-1) ? '\n' : '\t';
707        switch (GetSchemaColType(i)) {
708          case atInt: {
709            fprintf(F, "%d%c", RowI.GetIntAttr(GetSchemaColName(i)).Val, C);
710            break;
711          }
712          case atFlt: {
713            fprintf(F, "%f%c", RowI.GetFltAttr(GetSchemaColName(i)).Val, C);
714            break;
715          }
716          case atStr: {
717            fprintf(F, "%s%c", RowI.GetStrAttr(GetSchemaColName(i)).CStr(), C);
718            break;
719          }
720        }
721      }
722    }
723  #endif
724    fclose(F);
725  }
726  void TTable::SaveBin(const TStr& OutFNm) {
727    TFOut SOut(OutFNm);
728    Save(SOut);
729  }
730  void TTable::Save(TSOut& SOut) {
731    NumRows.Save(SOut);
732    NumValidRows.Save(SOut);
733    FirstValidRow.Save(SOut);
734    LastValidRow.Save(SOut);
735    Next.Save(SOut);
736    IntCols.Save(SOut);
737    FltCols.Save(SOut);
738    StrColMaps.Save(SOut);
739    THash<TStr,TPair<TInt,TInt> > ColTypeIntMap;
740    TInt atIntVal = TInt(0);
741    TInt atFltVal = TInt(1);
742    TInt atStrVal = TInt(2);
743    for (THash<TStr,TPair<TAttrType,TInt> >::TIter it = ColTypeMap.BegI(); it < ColTypeMap.EndI(); it++) {
744      TPair<TAttrType,TInt> dat = it.GetDat();
745      TStr DColName = DenormalizeColName(it.GetKey());
746      switch (dat.GetVal1()) {
747        case atInt:
748          ColTypeIntMap.AddDat(DColName, TPair<TInt,TInt>(atIntVal, dat.GetVal2()));
749          break;
750        case atFlt:
751          ColTypeIntMap.AddDat(DColName, TPair<TInt,TInt>(atFltVal, dat.GetVal2()));
752          break;
753        case atStr:
754          ColTypeIntMap.AddDat(DColName, TPair<TInt,TInt>(atStrVal, dat.GetVal2()));
755          break;
756      }
757    }
758    ColTypeIntMap.Save(SOut);
759    SOut.Flush();
760  }
761  void TTable::Dump(FILE *OutF) const {
762    TInt L = Sch.Len();
763    Schema DSch = DenormalizeSchema();
764    fprintf(OutF, "# ");
765    for (TInt i = 0; i < L-1; i++) {
766      fprintf(OutF, "%s\t", DSch[i].Val1.CStr());
767    }  
768    fprintf(OutF, "%s\n", DSch[L-1].Val1.CStr());
769    for (TRowIterator RowI = BegRI(); RowI < EndRI(); RowI++) {
770      for (TInt i = 0; i < L; i++) {
771        char C = (i == L-1) ? '\n' : '\t';
772        switch (GetSchemaColType(i)) {
773          case atInt: {
774            fprintf(OutF, "%d%c", RowI.GetIntAttr(GetSchemaColName(i)).Val, C);
775            break;
776          }
777          case atFlt: {
778            fprintf(OutF, "%f%c", RowI.GetFltAttr(GetSchemaColName(i)).Val, C);
779            break;
780          }
781          case atStr: {
782            fprintf(OutF, "%s%c", RowI.GetStrAttr(GetSchemaColName(i)).CStr(), C);
783            break;
784          }
785        }
786      }
787    }
788  }
789  TTableContext* TTable::ChangeContext(TTableContext* NewContext) {
790    TInt L = Sch.Len();
791  #if 0
792    for (TInt i = 0; i < L; i++) {
793      if (GetSchemaColType(i) != atStr) {
794        continue;
795      }
796      TInt ColIdx = GetColIdx(GetSchemaColName(i));
797      for (TRowIterator RowI = BegRI(); RowI < EndRI(); RowI++) {
798        TInt RowIdx = RowI.GetRowIdx();
799        TInt KeyId = StrColMaps[ColIdx][RowIdx];
800        printf("ChangeContext in  %d  %d  %d  .%s.\n",
801            ColIdx.Val, RowIdx.Val, KeyId.Val, GetStrVal(ColIdx, RowIdx).CStr());
802      }
803    }
804  #endif
805    for (TInt i = 0; i < L; i++) {
806      if (GetSchemaColType(i) != atStr) {
807        continue;
808      }
809      TInt ColIdx = GetColIdx(GetSchemaColName(i));
810      for (TRowIterator RowI = BegRI(); RowI < EndRI(); RowI++) {
811        TInt RowIdx = RowI.GetRowIdx();
812        TStr Key = GetStrValIdx(ColIdx, RowIdx);
813        TInt KeyId = TInt(NewContext->StringVals.AddKey(Key));
814        StrColMaps[ColIdx][RowIdx] = KeyId;
815      }
816    }
817    Context = NewContext;
818    return Context;
819  }
820  void TTable::AddStrVal(const TInt& ColIdx, const TStr& Key) {
821    TInt KeyId = TInt(Context->StringVals.AddKey(Key));
822    StrColMaps[ColIdx].Add(KeyId);
823  }
824  void TTable::AddStrVal(const TStr& Col, const TStr& Key) {
825    if (GetColType(Col) != atStr) {
826      TExcept::Throw(Col + " is not a string valued column");
827    }
828    AddStrVal(GetColIdx(Col), Key);
829  }
830  void TTable::AddGraphAttribute(const TStr& Attr, TBool IsEdge, TBool IsSrc, TBool IsDst) {
831    if (!IsColName(Attr)) { TExcept::Throw(Attr + ": No such column"); }
832    if (IsEdge) { EdgeAttrV.Add(NormalizeColName(Attr)); }
833    if (IsSrc) { SrcNodeAttrV.Add(NormalizeColName(Attr)); }
834    if (IsDst) { DstNodeAttrV.Add(NormalizeColName(Attr)); }
835  }
836  void TTable::AddGraphAttributeV(TStrV& Attrs, TBool IsEdge, TBool IsSrc, TBool IsDst) {
837    for (TInt i = 0; i < Attrs.Len(); i++) {
838      if (!IsColName(Attrs[i])) {
839        TExcept::Throw(Attrs[i] + ": no such column");
840      }
841    }
842    for (TInt i = 0; i < Attrs.Len(); i++) {
843      if (IsEdge) { EdgeAttrV.Add(NormalizeColName(Attrs[i])); }
844      if (IsSrc) { SrcNodeAttrV.Add(NormalizeColName(Attrs[i])); }
845      if (IsDst) { DstNodeAttrV.Add(NormalizeColName(Attrs[i])); }
846    }
847  }
848  TStrV TTable::GetSrcNodeIntAttrV() const {
849    TStrV IntNA = TStrV(IntCols.Len(),0);
850    for (TInt i = 0; i < SrcNodeAttrV.Len(); i++) {
851      TStr Attr = SrcNodeAttrV[i];
852      if (GetColType(Attr) == atInt) {
853        IntNA.Add(Attr);
854      }
855    }
856    return IntNA;
857  }
858  TStrV TTable::GetDstNodeIntAttrV() const {
859    TStrV IntNA = TStrV(IntCols.Len(),0);
860    for (TInt i = 0; i < DstNodeAttrV.Len(); i++) {
861      TStr Attr = DstNodeAttrV[i];
862      if (GetColType(Attr) == atInt) {
863        IntNA.Add(Attr);
864      }
865    }
866    return IntNA;
867  }
868  TStrV TTable::GetEdgeIntAttrV() const {
869    TStrV IntEA = TStrV(IntCols.Len(),0);
870    for (TInt i = 0; i < EdgeAttrV.Len(); i++) {
871      TStr Attr = EdgeAttrV[i];
872      if (GetColType(Attr) == atInt) {
873        IntEA.Add(Attr);
874      }
875    }
876    return IntEA;
877  }
878  TStrV TTable::GetSrcNodeFltAttrV() const {
879    TStrV FltNA = TStrV(FltCols.Len(),0);
880    for (TInt i = 0; i < SrcNodeAttrV.Len(); i++) {
881      TStr Attr = SrcNodeAttrV[i];
882      if (GetColType(Attr) == atFlt) {
883        FltNA.Add(Attr);
884      }
885    }
886    return FltNA;
887  }
888  TStrV TTable::GetDstNodeFltAttrV() const {
889    TStrV FltNA = TStrV(FltCols.Len(),0);
890    for (TInt i = 0; i < DstNodeAttrV.Len(); i++) {
891      TStr Attr = DstNodeAttrV[i];
892      if (GetColType(Attr) == atFlt) {
893        FltNA.Add(Attr);
894      }
895    }
896    return FltNA;
897  }
898  TStrV TTable::GetEdgeFltAttrV() const {
899    TStrV FltEA = TStrV(FltCols.Len(),0);;
900    for (TInt i = 0; i < EdgeAttrV.Len(); i++) {
901      TStr Attr = EdgeAttrV[i];
902      if (GetColType(Attr) == atFlt) {
903        FltEA.Add(Attr);
904      }
905    }
906    return FltEA;
907  }
908  TStrV TTable::GetSrcNodeStrAttrV() const {
909    TStrV StrNA = TStrV(StrColMaps.Len(),0);
910    for (TInt i = 0; i < SrcNodeAttrV.Len(); i++) {
911      TStr Attr = SrcNodeAttrV[i];
912      if (GetColType(Attr) == atStr) {
913        StrNA.Add(Attr);
914      }
915    }
916    return StrNA;
917  }
918  TStrV TTable::GetDstNodeStrAttrV() const {
919    TStrV StrNA = TStrV(StrColMaps.Len(),0);
920    for (TInt i = 0; i < DstNodeAttrV.Len(); i++) {
921      TStr Attr = DstNodeAttrV[i];
922      if (GetColType(Attr) == atStr) {
923        StrNA.Add(Attr);
924      }
925    }
926    return StrNA;
927  }
928  TStrV TTable::GetEdgeStrAttrV() const {
929    TStrV StrEA = TStrV(StrColMaps.Len(),0);
930    for (TInt i = 0; i < EdgeAttrV.Len(); i++) {
931      TStr Attr = EdgeAttrV[i];
932      if (GetColType(Attr) == atStr) {
933        StrEA.Add(Attr);
934      }
935    }
936    return StrEA;
937  }
938  void TTable::Rename(const TStr& column, const TStr& NewLabel) {
939    if (!IsColName(column)) { TExcept::Throw("no such column " + column); }
940    TPair<TAttrType,TInt> ColVal = GetColTypeMap(column);
941    DelColType(column);
942    AddColType(NewLabel, ColVal);
943    TStr NColName = NormalizeColName(column);
944    TStr NLabel = NormalizeColName(NewLabel);
945    for (TInt c = 0; c < Sch.Len(); c++) {
946      if (Sch[c].Val1 == NColName) {
947        Sch.SetVal(c, TPair<TStr, TAttrType>(NLabel, Sch[c].Val2));
948        break;
949      }
950    }
951  }
952  void TTable::RemoveFirstRow() {
953    if (FirstValidRow == LastValidRow) {
954      LastValidRow = -1;
955    }
956    TInt Old = FirstValidRow;
957    FirstValidRow = Next[FirstValidRow];
958    Next[Old] = TTable::Invalid;
959    NumValidRows--;
960    TInt IdColIdx = GetColIdx(GetIdColName());
961    RowIdMap.AddDat(IntCols[IdColIdx][Old], Invalid);
962  }
963  void TTable::RemoveRow(TInt RowIdx, TInt PrevRowIdx) {
964    if (RowIdx == FirstValidRow) {
965      RemoveFirstRow();
966      return;
967    }
968    Assert(RowIdx != TTable::Invalid);
969    if (RowIdx == TTable::Last) { return; }
970    Next[PrevRowIdx] = Next[RowIdx];
971    if (LastValidRow == RowIdx) {
972      LastValidRow = RowIdx;
973    }
974    Next[RowIdx] = TTable::Invalid;
975    NumValidRows--;
976    TInt IdColIdx = GetColIdx(GetIdColName());
977    RowIdMap.AddDat(IntCols[IdColIdx][RowIdx], Invalid);
978  }
979  void TTable::KeepSortedRows(const TIntV& KeepV) {
980    TIntIntH KeepH(KeepV.Len());
981    for (TInt i = 0; i < KeepV.Len(); i++) {
982      KeepH.AddKey(KeepV[i]);
983    }
984    TRowIteratorWithRemove RowI = BegRIWR();
985    TInt KeepSize = 0;
986    while (RowI.GetNextRowIdx() != Last) {
987      if (KeepSize < KeepV.Len()) {
988        if (KeepH.IsKey(RowI.GetNextRowIdx())) {
989          KeepSize++;
990          RowI++;
991        } else {
992          RowI.RemoveNext();
993        }
994      } else {
995        RowI.RemoveNext();
996      }
997    }
998    LastValidRow = KeepV[KeepV.Len()-1];
999  }
1000  void TTable::GetPartitionRanges(TIntPrV& Partitions, TInt NumPartitions) const {
1001    TInt PartitionSize = NumValidRows / (NumPartitions);
1002    if (NumValidRows % NumPartitions != 0) PartitionSize++;
1003    if (PartitionSize < 10) { 
1004      PartitionSize = 10;
1005      NumPartitions = NumValidRows / PartitionSize; 
1006    }
1007    Partitions.Reserve(NumPartitions+1);
1008    TInt currRow = FirstValidRow;
1009    TInt currStart = currRow;
1010    if (IsNextDirty) {
1011      TInt currCount = PartitionSize;
1012      while (currRow != TTable::Last) {
1013        if (currCount == 0) {
1014          Partitions.Add(TIntPr(currStart, currRow));
1015          currStart = currRow;
1016          currCount = PartitionSize;
1017        }
1018        currRow = Next[currRow];
1019        currCount--;
1020      }
1021      Partitions.Add(TIntPr(currStart, currRow));
1022    } else {
1023      currRow += PartitionSize;
1024      while (currRow != TTable::Last && currRow < Next.Len()) {
1025        if (Next[currRow] == TTable::Invalid) { currRow++; continue; }
1026        Partitions.Add(TIntPr(currStart, currRow));
1027        currStart = currRow;
1028        currRow += PartitionSize;
1029      }
1030      Partitions.Add(TIntPr(currStart, TTable::Last));
1031    }
1032  }
1033  void TTable::GroupingSanityCheck(const TStr& GroupBy, const TAttrType& AttrType) const {
1034    if (!IsColName(GroupBy)) {
1035      TExcept::Throw("no such column " + GroupBy);
1036    }
1037    if (GetColType(GroupBy) != AttrType) {
1038      TExcept::Throw(GroupBy + " values are not of expected type");
1039    }
1040  }
1041  #ifdef GCC_ATOMIC
1042  void TTable::GroupByIntColMP(const TStr& GroupBy, THashMP<TInt, TIntV>& Grouping, TBool UsePhysicalIds) const {
1043    timeval timer0;
1044    gettimeofday(&timer0, NULL);
1045    TInt IdColIdx = GetColIdx(IdColName);
1046    TInt GroupByColIdx = GetColIdx(GroupBy);
1047    if(!UsePhysicalIds && IdColIdx < 0){
1048    	TExcept::Throw("Grouping: Either use physical row ids, or have an id column");
1049    }
1050    GroupingSanityCheck(GroupBy, atInt);
1051    TIntPrV Partitions;
1052    GetPartitionRanges(Partitions, 8*CHUNKS_PER_THREAD);
1053    TInt PartitionSize = Partitions[0].GetVal2()-Partitions[0].GetVal1()+1;
1054    Grouping.Gen(NumValidRows);
1055    #pragma omp parallel for schedule(dynamic, CHUNKS_PER_THREAD) 
1056    for (int i = 0; i < Partitions.Len(); i++){
1057      TRowIterator RowI(Partitions[i].GetVal1(), this);
1058      TRowIterator EndI(Partitions[i].GetVal2(), this);
1059      while (RowI < EndI) {
1060        TInt idx = UsePhysicalIds ? RowI.GetRowIdx() : RowI.GetIntAttr(IdColIdx);
1061        UpdateGrouping<TInt>(Grouping, RowI.GetIntAttr(GroupByColIdx), idx);
1062        RowI++;
1063      }
1064    }
1065    gettimeofday(&timer0, NULL);
1066  }
1067  #endif 
1068  void TTable::Unique(const TStr& Col) {
1069    TIntV RemainingRows;
1070    TStr NCol = NormalizeColName(Col);
1071    switch (GetColType(NCol)) {
1072      case atInt: {
1073        TIntIntVH Grouping;
1074        GroupByIntCol(NCol, Grouping, TIntV(), true, true);
1075        for (TIntIntVH::TIter it = Grouping.BegI(); it < Grouping.EndI(); it++) {
1076          RemainingRows.Add(it->Dat[0]);
1077        }
1078        break;
1079      }
1080      case atFlt: {
1081        THash<TFlt,TIntV> Grouping;
1082        GroupByFltCol(NCol, Grouping, TIntV(), true, true);
1083        for (THash<TFlt,TIntV>::TIter it = Grouping.BegI(); it < Grouping.EndI(); it++) {
1084          RemainingRows.Add(it->Dat[0]);
1085        }
1086        break;
1087      } 
1088      case atStr: {
1089        TIntIntVH Grouping;
1090        GroupByStrCol(NCol, Grouping, TIntV(), true, true);
1091        for (TIntIntVH::TIter it = Grouping.BegI(); it < Grouping.EndI(); it++) {
1092          RemainingRows.Add(it->Dat[0]);
1093        }
1094        break;
1095      }
1096    }
1097    KeepSortedRows(RemainingRows);
1098  }
1099  void TTable::Unique(const TStrV& Cols, TBool Ordered) {
1100    if(Cols.Len() == 1){ 
1101    	Unique(Cols[0]);
1102    	return;
1103    }
1104    TStrV NCols = NormalizeColNameV(Cols);
1105    THash<TGroupKey, TPair<TInt, TIntV> > Grouping;
1106    TIntV UniqueVec;
1107    GroupAux(NCols, Grouping, Ordered, "", true, UniqueVec, true);
1108    KeepSortedRows(UniqueVec);
1109  }
1110  void TTable::StoreGroupCol(const TStr& GroupColName, const TVec<TPair<TInt, TInt> >& GroupAndRowIds) {
1111    IntCols.Add(TIntV(NumRows));
1112    TInt L = IntCols.Len();
1113    AddColType(GroupColName, atInt, L-1);
1114    for (TInt i = 0; i < GroupAndRowIds.Len(); i++) {
1115      IntCols[L-1][GroupAndRowIds[i].Val2] = GroupAndRowIds[i].Val1;
1116    }
1117  }
1118  void TTable::GroupAux(const TStrV& GroupBy, THash<TGroupKey, TPair<TInt, TIntV> >& Grouping, 
1119   TBool Ordered, const TStr& GroupColName, TBool KeepUnique, TIntV& UniqueVec, TBool UsePhysicalIds) {
1120    TInt IdColIdx = GetColIdx(IdColName);
1121    if(!UsePhysicalIds && IdColIdx < 0){
1122    	TExcept::Throw("Grouping: Either use physical row ids, or have an id column");
1123    }
1124    TIntV IntGroupByCols;
1125    TIntV FltGroupByCols;
1126    TIntV StrGroupByCols;
1127    for (TInt c = 0; c < GroupBy.Len(); c++) {
1128      if (!IsColName(GroupBy[c])) { 
1129        TExcept::Throw("no such column " + GroupBy[c]); 
1130      }
1131      TPair<TAttrType, TInt> ColType = GetColTypeMap(GroupBy[c]);
1132      switch (ColType.Val1) {
1133        case atInt:
1134          IntGroupByCols.Add(ColType.Val2);
1135          break;
1136        case atFlt:
1137          FltGroupByCols.Add(ColType.Val2);
1138          break;
1139        case atStr:
1140          StrGroupByCols.Add(ColType.Val2);
1141          break;
1142      }
1143    }
1144    TInt IKLen = IntGroupByCols.Len();
1145    TInt FKLen = FltGroupByCols.Len();
1146    TInt SKLen = StrGroupByCols.Len();
1147    TInt GroupNum = 0;
1148    TVec<TPair<TInt, TInt> > GroupAndRowIds;
1149    for (TRowIterator it = BegRI(); it < EndRI(); it++) {
1150      TIntV IKey(IKLen + SKLen, 0);
1151      TFltV FKey(FKLen, 0);
1152      TIntV SKey(SKLen, 0);
1153      for (TInt c = 0; c < IKLen; c++) {
1154        IKey.Add(it.GetIntAttr(IntGroupByCols[c])); 
1155      }
1156      for (TInt c = 0; c < FKLen; c++) {
1157        FKey.Add(it.GetFltAttr(FltGroupByCols[c])); 
1158      }
1159      for (TInt c = 0; c < SKLen; c++) {
1160        SKey.Add(it.GetStrMapById(StrGroupByCols[c])); 
1161      }
1162      if (!Ordered) {
1163        if (IKLen > 0) { IKey.ISort(0, IKey.Len()-1, true); }
1164        if (FKLen > 0) { FKey.ISort(0, FKey.Len()-1, true); }
1165        if (SKLen > 0) { SKey.ISort(0, SKey.Len()-1, true); }
1166      }
1167      for (TInt c = 0; c < SKLen; c++) {
1168        IKey.Add(SKey[c]);
1169      }
1170      TGroupKey GroupKey = TGroupKey(IKey, FKey);
1171      TInt RowIdx = it.GetRowIdx();
1172      TInt idx = UsePhysicalIds ? it.GetRowIdx() : IntCols[IdColIdx][it.GetRowIdx()];
1173      if (!Grouping.IsKey(GroupKey)) {
1174        TPair<TInt, TIntV> NewGroup;
1175        NewGroup.Val1 = GroupNum;
1176        NewGroup.Val2.Add(idx);
1177        Grouping.AddDat(GroupKey, NewGroup);
1178        if (GroupColName != "") {
1179          GroupAndRowIds.Add(TPair<TInt, TInt>(GroupNum, RowIdx));
1180        }
1181        if (KeepUnique) { 
1182          UniqueVec.Add(idx);
1183        }
1184        GroupNum++;
1185      } else {
1186        if (!KeepUnique) {
1187          TPair<TInt, TIntV>& NewGroup = Grouping.GetDat(GroupKey);
1188          NewGroup.Val2.Add(idx);
1189          if (GroupColName != "") {
1190            GroupAndRowIds.Add(TPair<TInt, TInt>(NewGroup.Val1, RowIdx));
1191          }
1192        }
1193      }
1194    }
1195    if (!KeepUnique) {
1196      GroupStmt Stmt(NormalizeColNameV(GroupBy), Ordered, UsePhysicalIds);
1197      GroupStmtNames.AddDat(GroupColName, Stmt);
1198      GroupIDMapping.AddKey(Stmt);
1199      GroupMapping.AddKey(Stmt);
1200      for (THash<TGroupKey, TPair<TInt, TIntV> >::TIter it = Grouping.BegI(); it < Grouping.EndI(); it++) {
1201        TGroupKey key = it.GetKey();
1202        TPair<TInt, TIntV> group = it.GetDat();
1203        GroupIDMapping.GetDat(Stmt).AddDat(group.Val1, TGroupKey(key));
1204        GroupMapping.GetDat(Stmt).AddDat(TGroupKey(key), TIntV(group.Val2));
1205      }
1206    }
1207    if (GroupColName != "") {
1208      StoreGroupCol(GroupColName, GroupAndRowIds);
1209      AddSchemaCol(GroupColName, atInt);  
1210    }
1211  }
1212  void TTable::Group(const TStrV& GroupBy, const TStr& GroupColName, TBool Ordered, TBool UsePhysicalIds) {
1213    TStrV NGroupBy = NormalizeColNameV(GroupBy);
1214    TStr NGroupColName = NormalizeColName(GroupColName);
1215    TIntV UniqueVec;
1216    THash<TGroupKey, TPair<TInt, TIntV> > Grouping;
1217    GroupAux(NGroupBy, Grouping, Ordered, NGroupColName, false, UniqueVec, UsePhysicalIds);
1218  }
1219  void TTable::InvalidatePhysicalGroupings(){
1220  }
1221  void TTable::InvalidateAffectedGroupings(const TStr& Attr){
1222  }
1223  void TTable::Aggregate(const TStrV& GroupByAttrs, TAttrAggr AggOp,
1224   const TStr& ValAttr, const TStr& ResAttr, TBool Ordered) {
1225     for (TInt c = 0; c < GroupByAttrs.Len(); c++) {
1226      if (!IsColName(GroupByAttrs[c])) { 
1227        TExcept::Throw("no such column " + GroupByAttrs[c]); 
1228      }
1229     }
1230    TStrV NGroupByAttrs = NormalizeColNameV(GroupByAttrs);
1231    TBool UsePhysicalIds = (GetColIdx(IdColName) < 0);
1232    THash<TInt,TIntV> GroupByIntMapping;
1233    THash<TFlt,TIntV> GroupByFltMapping;
1234    THash<TInt,TIntV> GroupByStrMapping;
1235    THash<TGroupKey,TIntV> Mapping;
1236  #ifdef GCC_ATOMIC
1237    THashMP<TInt,TIntV> GroupByIntMapping_MP(NumValidRows);
1238    TIntV GroupByIntMPKeys(NumValidRows);
1239  #endif
1240    TInt NumOfGroups = 0;
1241    TInt GroupingCase = 0;
1242    GroupStmt Stmt(NGroupByAttrs, Ordered, UsePhysicalIds);
1243    if (GroupMapping.IsKey(Stmt)) {
1244      Mapping = GroupMapping.GetDat(Stmt);
1245    } else{
1246    	if(NGroupByAttrs.Len() == 1){
1247    		switch(GetColType(NGroupByAttrs[0])){
1248    			case atInt:
1249  #ifdef GCC_ATOMIC
1250    				if(GetMP()){
1251    					GroupByIntColMP(NGroupByAttrs[0], GroupByIntMapping_MP, UsePhysicalIds);
1252    					int x = 0;
1253  					for(THashMP<TInt,TIntV>::TIter it = GroupByIntMapping_MP.BegI(); it < GroupByIntMapping_MP.EndI(); it++){
1254  						GroupByIntMPKeys[x] = it.GetKey();
1255  						x++;
1256  					}
1257    					NumOfGroups = x;
1258    					GroupingCase = 4;
1259    					break;
1260    				}
1261  #endif 
1262    				GroupByIntCol(NGroupByAttrs[0], GroupByIntMapping, TIntV(), true, UsePhysicalIds);
1263    				NumOfGroups = GroupByIntMapping.Len();
1264    				GroupingCase = 1;
1265    				break;
1266    			case atFlt:
1267    				GroupByFltCol(NGroupByAttrs[0], GroupByFltMapping, TIntV(), true, UsePhysicalIds);
1268    				NumOfGroups = GroupByFltMapping.Len();
1269    				GroupingCase = 2;
1270    				break;
1271    			case atStr:
1272    				GroupByStrCol(NGroupByAttrs[0], GroupByStrMapping, TIntV(), true, UsePhysicalIds);
1273    				NumOfGroups = GroupByStrMapping.Len();
1274    				GroupingCase = 3;
1275    				break;
1276    		}
1277    	}
1278    	else{
1279    		TIntV UniqueVector;
1280    		THash<TGroupKey, TPair<TInt, TIntV> > Mapping_aux;
1281    		GroupAux(NGroupByAttrs, Mapping_aux, Ordered, "", false, UniqueVector, UsePhysicalIds);
1282    		for(THash<TGroupKey, TPair<TInt, TIntV> >::TIter it = Mapping_aux.BegI(); it < Mapping_aux.EndI(); it++){
1283    			Mapping.AddDat(it.GetKey(), it.GetDat().Val2);
1284    		}
1285    		NumOfGroups = Mapping.Len();
1286    	}
1287    }
1288    TAttrType T = GetColType(ValAttr);
1289    if (AggOp == aaCount) { AddIntCol(ResAttr); } 
1290    else {
1291      if (T == atInt) { AddIntCol(ResAttr); }
1292      else if (T == atFlt) { AddFltCol(ResAttr); }
1293      else {
1294        TExcept::Throw("Invalid aggregation for Str type!");
1295      }
1296    }
1297    TInt ColIdx = GetColIdx(ResAttr);
1298    TInt AggrColIdx = GetColIdx(ValAttr);
1299  #ifdef USE_OPENMP
1300    #pragma omp parallel for schedule(dynamic)
1301  #endif 
1302    for (int g = 0; g < NumOfGroups; g++) {
1303    	TIntV* GroupRows = NULL;
1304    	switch(GroupingCase){
1305    		case 0:
1306    			GroupRows = & Mapping.GetDat(Mapping.GetKey(g));
1307    			break;
1308    		case 1:
1309    			GroupRows = & GroupByIntMapping.GetDat(GroupByIntMapping.GetKey(g));
1310    			break;
1311    		case 2:
1312    			GroupRows = & GroupByIntMapping.GetDat(GroupByIntMapping.GetKey(g));
1313    			break;
1314    	    case 3:
1315    			GroupRows = & GroupByStrMapping.GetDat(GroupByStrMapping.GetKey(g));
1316    			break;
1317    		case 4:
1318  #ifdef GCC_ATOMIC
1319    			GroupRows = & GroupByIntMapping_MP.GetDat(GroupByIntMPKeys[g]);
1320  #endif
1321    			break;
1322    	}
1323  	TIntV& ValidRows = *GroupRows;
1324      TInt sz = ValidRows.Len();
1325      if (sz <= 0) continue;
1326      if (AggOp == aaCount) {
1327        for (TInt i = 0; i < sz; i++) { IntCols[ColIdx][ValidRows[i]] = sz; }
1328      } else {
1329        if (T == atInt) {
1330          TIntV V;
1331          for (TInt i = 0; i < sz; i++) { V.Add(IntCols[AggrColIdx][ValidRows[i]]); }
1332          TInt Res = AggregateVector<TInt>(V, AggOp);
1333          if (AggOp == aaMean) { Res = Res / sz; }
1334          for (TInt i = 0; i < sz; i++) { IntCols[ColIdx][ValidRows[i]] = Res; }
1335        } else {
1336          TFltV V;
1337          for (TInt i = 0; i < sz; i++) { V.Add(FltCols[AggrColIdx][ValidRows[i]]); }
1338          TFlt Res = AggregateVector<TFlt>(V, AggOp);
1339          if (AggOp == aaMean) { Res /= sz; }
1340          for (TInt i = 0; i < sz; i++) { FltCols[ColIdx][ValidRows[i]] = Res; }
1341        }
1342      }
1343    }
1344  }
1345  void TTable::AggregateCols(const TStrV& AggrAttrs, TAttrAggr AggOp, const TStr& ResAttr) {
1346    TVec<TPair<TAttrType, TInt> >Info;
1347    for (TInt i = 0; i < AggrAttrs.Len(); i++) {
1348      Info.Add(GetColTypeMap(AggrAttrs[i]));
1349      if (Info[i].Val1 != Info[0].Val1) {
1350        TExcept::Throw("AggregateCols: Aggregation attributes must have the same type");
1351      }
1352    }
1353    if (Info[0].Val1 == atInt) {
1354      AddIntCol(ResAttr);
1355      TInt ResIdx = GetColIdx(ResAttr);
1356      for (TRowIterator RI = BegRI(); RI < EndRI(); RI++) {
1357        TInt RowIdx = RI.GetRowIdx();
1358        TIntV V;
1359        for (TInt i = 0; i < AggrAttrs.Len(); i++) {
1360          V.Add(IntCols[Info[i].Val2][RowIdx]);
1361        }
1362        IntCols[ResIdx][RowIdx] = AggregateVector<TInt>(V, AggOp);
1363      }
1364    } else if (Info[0].Val1 == atFlt) {
1365      AddFltCol(ResAttr);
1366      TInt ResIdx = GetColIdx(ResAttr);
1367      for (TRowIterator RI = BegRI(); RI < EndRI(); RI++) {
1368        TInt RowIdx = RI.GetRowIdx();
1369        TFltV V;
1370        for (TInt i = 0; i < AggrAttrs.Len(); i++) {
1371          V.Add(FltCols[Info[i].Val2][RowIdx]);
1372        }
1373        FltCols[ResIdx][RowIdx] = AggregateVector<TFlt>(V, AggOp);
1374      }
1375    } else {
1376      TExcept::Throw("AggregateCols: Only Int and Flt aggregation supported right now");
1377    }
1378  }
1379  void TTable::PrintGrouping(const THash<TGroupKey, TIntV>& Mapping) const{
1380  	for(THash<TGroupKey, TIntV>::TIter it = Mapping.BegI(); it < Mapping.EndI(); it++){
1381    		TGroupKey gk = it.GetKey();
1382    		TIntV ik = gk.Val1;
1383    		TFltV fk = gk.Val2;
1384    		for(int i = 0; i < ik.Len(); i++){ printf("%d ",ik[i].Val);} 
1385    		for(int i = 0; i < fk.Len(); i++){ printf("%f ",fk[i].Val);} 
1386    		printf("-->");
1387    		TIntV v = it.GetDat();
1388    		for(int i = 0; i < v.Len(); i++){ printf("%d ",v[i].Val);} 
1389    		printf("\n");
1390    	}
1391  }
1392  void TTable::Count(const TStr& CountColName, const TStr& Col) {
1393    TStrV GroupByAttrs;
1394    GroupByAttrs.Add(CountColName);
1395    Aggregate(GroupByAttrs, aaCount, "", Col);
1396  }
1397  TVec<PTable> TTable::SpliceByGroup(const TStrV& GroupBy, TBool Ordered) {
1398    TStrV NGroupBy = NormalizeColNameV(GroupBy);
1399    TIntV UniqueVec;
1400    THash<TGroupKey, TPair<TInt, TIntV> >Grouping;
1401    TVec<PTable> Result;
1402    Schema NewSchema;
1403    for (TInt c = 0; c < Sch.Len(); c++) {
1404      if (Sch[c].Val1 != GetIdColName()) {
1405        NewSchema.Add(Sch[c]);
1406      }
1407    }
1408    GroupAux(NGroupBy, Grouping, Ordered, "", false, UniqueVec);
1409    TInt cnt = 0;
1410    for (THash<TGroupKey, TPair<TInt, TIntV> >::TIter it = Grouping.BegI(); it != Grouping.EndI(); it++) {
1411      PTable GroupTable = TTable::New(NewSchema, Context);
1412      TVec<TPair<TAttrType, TInt> > ColInfo;
1413      TIntV V;
1414      for (TInt i = 0; i < Sch.Len(); i++) {
1415        ColInfo.Add(GroupTable->GetColTypeMap(Sch[i].Val1));
1416        if (Sch[i].Val1 == IdColName()) {
1417          ColInfo[i].Val2 = -1;
1418        }
1419        V.Add(GetColIdx(Sch[i].Val1));
1420      }
1421      TIntV& Rows = it.GetDat().Val2;
1422      for (TInt i = 0; i < Rows.Len(); i++) {
1423        TInt RowIdx = RowIdMap.GetDat(Rows[i]);
1424        for (TInt c = 0; c < Sch.Len(); c++) {
1425          TPair<TAttrType, TInt> Info = ColInfo[c];
1426          TInt ColIdx = Info.Val2;
1427          if (ColIdx == -1) { continue; }
1428          switch (Info.Val1) {
1429            case atInt:
1430              GroupTable->IntCols[ColIdx].Add(IntCols[V[c]][RowIdx]);
1431              break;
1432            case atFlt:
1433              GroupTable->FltCols[ColIdx].Add(FltCols[V[c]][RowIdx]);
1434              break;
1435            case atStr:
1436              GroupTable->StrColMaps[ColIdx].Add(StrColMaps[V[c]][RowIdx]);
1437              break;
1438          }
1439        }
1440        if (GroupTable->LastValidRow >= 0) {
1441          GroupTable->Next[GroupTable->LastValidRow] = GroupTable->NumRows;
1442        }
1443        GroupTable->Next.Add(GroupTable->Last);
1444        GroupTable->LastValidRow = GroupTable->NumRows;
1445        GroupTable->NumRows++;
1446        GroupTable->NumValidRows++;
1447      }
1448      GroupTable->InitIds();
1449      Result.Add(GroupTable);
1450      cnt += 1;
1451    }
1452    return Result;
1453  }
1454  void TTable::InitIds() {
1455    IdColName = "_id";
1456    AddIdColumn(IdColName);
1457  }
1458  void TTable::Reindex() {
1459    RowIdMap.Clr();
1460    TInt IdColIdx = GetColIdx(IdColName);
1461    TInt IdCnt = 0;
1462    for (TRowIterator RI = BegRI(); RI < EndRI(); RI++) {
1463      IntCols[IdColIdx][RI.GetRowIdx()] = IdCnt;
1464      RowIdMap.AddDat(RI.GetRowIdx(), IdCnt);
1465      IdCnt++;
1466    }
1467  }
1468  void TTable::AddIdColumn(const TStr& ColName) {
1469    TInt IdCol = IntCols.Add();
1470    IntCols[IdCol].Reserve(NumRows, NumRows);
1471    TInt IdCnt = 0;
1472    RowIdMap.Clr();
1473    for (TRowIterator RI = BegRI(); RI < EndRI(); RI++) {
1474      IntCols[IdCol][RI.GetRowIdx()] = IdCnt;
1475      RowIdMap.AddDat(IdCnt, RI.GetRowIdx());
1476      IdCnt++;
1477    }
1478    AddSchemaCol(ColName, atInt);
1479    AddColType(ColName, atInt, IntCols.Len()-1);
1480  }
1481   PTable TTable::InitializeJointTable(const TTable& Table) {
1482    PTable JointTable = New(Context);
1483    JointTable->IntCols = TVec<TIntV>(IntCols.Len() + Table.IntCols.Len() + 1);
1484    JointTable->FltCols = TVec<TFltV>(FltCols.Len() + Table.FltCols.Len());
1485    JointTable->StrColMaps = TVec<TIntV>(StrColMaps.Len() + Table.StrColMaps.Len());
1486    for (TInt i = 0; i < Sch.Len(); i++) {
1487      TStr ColName = GetSchemaColName(i);
1488      TAttrType ColType = GetSchemaColType(i);
1489      TStr CName = JointTable->RenumberColName(ColName);
1490      TPair<TAttrType, TInt> TypeMap = GetColTypeMap(ColName);
1491      JointTable->AddColType(CName, TypeMap);
1492      JointTable->AddSchemaCol(CName, ColType);
1493    }
1494    for (TInt i = 0; i < Table.Sch.Len(); i++) {
1495      TStr ColName = Table.GetSchemaColName(i);
1496      TAttrType ColType = Table.GetSchemaColType(i);
1497      TStr CName = JointTable->RenumberColName(ColName);
1498      TPair<TAttrType, TInt> NewDat = Table.GetColTypeMap(ColName);
1499      Assert(ColType == NewDat.Val1);
1500      switch (NewDat.Val1) {
1501        case atInt:
1502          NewDat.Val2 += IntCols.Len();
1503          break;
1504        case atFlt:
1505          NewDat.Val2 += FltCols.Len();
1506          break;
1507        case atStr:
1508          NewDat.Val2 += StrColMaps.Len();
1509          break;
1510      }
1511      JointTable->AddColType(CName, NewDat);
1512      JointTable->AddSchemaCol(CName, ColType);
1513    }
1514    TStr IdColName = "_id";
1515    JointTable->AddColType(IdColName, atInt, IntCols.Len() + Table.IntCols.Len());
1516    JointTable->AddSchemaCol(IdColName, atInt);
1517    return JointTable;
1518  }
1519  void TTable::AddJointRow(const TTable& T1, const TTable& T2, TInt RowIdx1, TInt RowIdx2) {
1520    for (TInt i = 0; i < T1.IntCols.Len(); i++) {
1521      IntCols[i].Add(T1.IntCols[i][RowIdx1]);
1522    }
1523    for (TInt i = 0; i < T1.FltCols.Len(); i++) {
1524      FltCols[i].Add(T1.FltCols[i][RowIdx1]);
1525    }
1526    for (TInt i = 0; i < T1.StrColMaps.Len(); i++) {
1527      StrColMaps[i].Add(T1.StrColMaps[i][RowIdx1]);
1528    }
1529    TInt IntOffset = T1.IntCols.Len();
1530    TInt FltOffset = T1.FltCols.Len();
1531    TInt StrOffset = T1.StrColMaps.Len();
1532    for (TInt i = 0; i < T2.IntCols.Len(); i++) {
1533      IntCols[i+IntOffset].Add(T2.IntCols[i][RowIdx2]);
1534    }
1535    for (TInt i = 0; i < T2.FltCols.Len(); i++) {
1536      FltCols[i+FltOffset].Add(T2.FltCols[i][RowIdx2]);
1537    }
1538    for (TInt i = 0; i < T2.StrColMaps.Len(); i++) {
1539      StrColMaps[i+StrOffset].Add(T2.StrColMaps[i][RowIdx2]);
1540    }
1541    TInt IdOffset = IntOffset + T2.IntCols.Len(); 
1542    NumRows++;
1543    NumValidRows++;
1544    if (!Next.Empty()) {
1545      Next[Next.Len()-1] = NumValidRows-1;
1546      LastValidRow = NumValidRows-1;
1547    }
1548    Next.Add(Last);
1549    RowIdMap.AddDat(NumRows-1,NumRows-1);
1550    IntCols[IdOffset].Add(NumRows-1);
1551  }
1552  PTable TTable::SimJoin(const TStrV& Cols1, const TTable& Table, const TStrV& Cols2, const TStr& DistanceColName, const TSimType& SimType, const TFlt& Threshold)
1553  {
1554  	Assert(Cols1.Len() == Cols2.Len());
1555  	if(Cols1.Len()!=Cols2.Len()){
1556  		TExcept::Throw("Column vectors must match in type and length");
1557  	}
1558  	for (TInt i = 0; i < Cols1.Len(); i++) {
1559  		if(!IsColName(Cols1[i]) || !Table.IsColName(Cols2[i])){
1560  			TExcept::Throw("Column not found in Table");
1561  		}
1562  		TAttrType Type1 = GetColType(Cols1[i]);
1563  		TAttrType Type2 = GetColType(Cols2[i]);
1564  		if(Type1!=Type2){
1565  			TExcept::Throw("Column types on the two tables must match.");
1566  		}
1567  		if((Type1!=atInt && Type1!=atFlt) || (Type2!=atInt && Type2!=atFlt)){
1568  			TExcept::Throw("Column type not supported. Only Flt and Int column types are supported.");
1569  		}
1570    }
1571    PTable JointTable = InitializeJointTable(Table);
1572  	TFltV DistanceV;
1573  	for(TRowIterator RowI = this->BegRI(); RowI < this->EndRI(); RowI++) {
1574  		for(TRowIterator RowI2 = Table.BegRI(); RowI2 < Table.EndRI(); RowI2++) {
1575  			float distance = 0;
1576  			switch(SimType)
1577  			{
1578  				case L2Norm:
1579  					for(TInt i = 0; i < Cols1.Len(); i++) {
1580  						float attrVal1, attrVal2;
1581  						attrVal1 = GetColType(Cols1[i])==atInt ? (float)RowI.GetIntAttr(Cols1[i]) : (float)RowI.GetFltAttr(Cols1[i]);
1582  						attrVal2 = Table.GetColType(Cols2[i])==atInt ? (float)RowI2.GetIntAttr(Cols2[i]) : (float)RowI2.GetFltAttr(Cols2[i]);
1583  						distance += pow(attrVal1 - attrVal2, 2);
1584  					}
1585  					distance = sqrt(distance);
1586  					if(distance<=Threshold){
1587  						JointTable->AddJointRow(*this, Table, RowI.GetRowIdx(), RowI2.GetRowIdx());
1588  						DistanceV.Add(distance);
1589  					}
1590  					break;
1591  				case Haversine:
1592  					{
1593  						if(Cols1.Len()!=2){
1594  							TExcept::Throw("Haversine disance expects exactly two attributes - latitude and longitude - in that order.");
1595  						}
1596  						TFlt Radius = 6373; 
1597  						float Latitude1  = GetColType(Cols1[0])==atInt ? (float)RowI.GetIntAttr(Cols1[0]) : (float)RowI.GetFltAttr(Cols1[0]);
1598  						float Latitude2 = Table.GetColType(Cols2[0])==atInt ? (float)RowI2.GetIntAttr(Cols2[0]) : (float)RowI2.GetFltAttr(Cols2[0]);
1599  						float Longitude1  = GetColType(Cols1[1])==atInt ? (float)RowI.GetIntAttr(Cols1[1]) : (float)RowI.GetFltAttr(Cols1[1]);
1600  						float Longitude2  = Table.GetColType(Cols2[1])==atInt ? (float)RowI2.GetIntAttr(Cols2[1]) : (float)RowI2.GetFltAttr(Cols2[1]);
1601  						Latitude1 *= static_cast<float>(M_PI/180.0);
1602  						Latitude2 *= static_cast<float>(M_PI/180.0);
1603  						Longitude1 *= static_cast<float>(M_PI/180.0);
1604  						Longitude2 *= static_cast<float>(M_PI/180.0);
1605  						float dlon = Longitude2 - Longitude1;
1606  						float dlat = Latitude2 - Latitude1;
1607  						float a = pow(sin(dlat/2), 2) + cos(Latitude1)*cos(Latitude2)*pow(sin(dlon/2), 2);
1608  						float c = 2*atan2(sqrt(a), sqrt(1-a));
1609  						distance = (static_cast<float>(Radius.Val))*c;
1610  						if(distance<=Threshold){
1611  							JointTable->AddJointRow(*this, Table, RowI.GetRowIdx(), RowI2.GetRowIdx());
1612  							DistanceV.Add(distance);
1613  						}
1614  					}
1615  					break;
1616  				case L1Norm:
1617  				case Jaccard:
1618  					TExcept::Throw("This distance metric is not supported");
1619  			}
1620  		}	
1621  	}
1622  	JointTable->StoreFltCol(DistanceColName, DistanceV);
1623  	JointTable->InitIds();
1624  	return JointTable;
1625  }
1626  PTable TTable::SelfSimJoinPerGroup(const TStr& GroupAttr, const TStr& SimCol, const TStr& DistanceColName, const TSimType& SimType, const TFlt& Threshold) 
1627  {
1628  	if(!IsColName(SimCol) || !IsColName(GroupAttr)){
1629  		TExcept::Throw("No such column found in table");
1630  	}
1631    PTable JointTable = New(Context);
1632  	JointTable->IntCols = TVec<TIntV>(2);
1633  	JointTable->FltCols = TVec<TFltV>(1);
1634  	for(TInt i=0;i<2;i++){
1635      TInt Suffix = i+1;
1636      TStr CName = "GroupId_" + Suffix.GetStr();
1637      TPair<TAttrType, TInt> Group(atInt, (int)i);
1638      JointTable->AddColType(CName, Group);
1639      JointTable->AddSchemaCol(CName, atInt);
1640    }
1641  	TPair<TAttrType, TInt> Group(atFlt, 0);
1642  	JointTable->AddColType(DistanceColName, Group);
1643  	JointTable->AddSchemaCol(DistanceColName, atFlt);
1644  	THash<TInt, THash<TInt, TInt> > TIntHH;
1645  	TAttrType attrType = GetColType(SimCol);
1646  	TInt GroupColIdx = GetColIdx(GroupAttr);
1647  	TInt SimColIdx = GetColIdx(SimCol);
1648  	for (TRowIterator RowI = this->BegRI(); RowI < this->EndRI(); RowI++) {
1649  		TInt GroupId = IntCols[GroupColIdx][RowI.GetRowIdx()];
1650  		if(attrType==atInt || attrType==atStr)
1651  		{
1652  			if(!TIntHH.IsKey(GroupId)){
1653  				THash<TInt, TInt> TIntH;
1654  				TIntHH.AddDat(GroupId, TIntH);
1655  			}
1656  			THash<TInt, TInt>& TIntH = TIntHH.GetDat(GroupId);
1657  			TInt SimAttrVal = (attrType==atInt ? IntCols[SimColIdx][RowI.GetRowIdx()] : StrColMaps[SimColIdx][RowI.GetRowIdx()]);
1658  			TIntH.AddDat(SimAttrVal, 0);
1659  		}
1660  		else
1661  		{
1662  			TExcept::Throw("Attribute type not supported.");
1663  		}
1664  	}
1665  	for (THash<TInt, THash<TInt, TInt> >::TIter it1 = TIntHH.BegI(); it1 < TIntHH.EndI(); it1++) {
1666  		THash<TInt, TInt> Vals1H = it1.GetDat();
1667  		TInt GroupId1 = it1.GetKey();
1668  		for (THash<TInt, THash<TInt, TInt> >::TIter it2 = TIntHH.BegI(); it2 < TIntHH.EndI(); it2++) {
1669  				int intersectionCount = 0;
1670  				TInt GroupId2 = it2.GetKey();
1671  				THash<TInt, TInt> Vals2H = it2.GetDat();
1672  				for(THash<TInt, TInt>::TIter it = Vals1H.BegI(); it < Vals1H.EndI(); it++)
1673  				{
1674  					TInt Val = it.GetKey();
1675  					if(Vals2H.IsKey(Val)){
1676  						intersectionCount+=1;
1677  					}
1678  				}
1679  				int unionCount = Vals1H.Len() + Vals2H.Len() - intersectionCount;
1680  				float distance = 1.0f - (float)intersectionCount/unionCount;
1681  				if(distance<=Threshold){
1682  						JointTable->IntCols[0].Add(GroupId1);
1683  						JointTable->IntCols[1].Add(GroupId2);
1684  						JointTable->FltCols[0].Add(distance);
1685  						JointTable->IncrementNext();
1686  			}
1687  		}
1688  	}
1689    JointTable->InitIds();
1690  	return JointTable;
1691  }
1692  PTable TTable::SelfSimJoinPerGroup(const TStrV& GroupBy, const TStr& SimCol, 
1693   const TStr& DistanceColName, const TSimType& SimType, const TFlt& Threshold) {
1694    TStrV NGroupBy = NormalizeColNameV(GroupBy);
1695  	TStrV ProjectionV;
1696  	for(TInt i=0; i<GroupBy.Len(); i++)
1697  	{
1698  		ProjectionV.Add(GroupBy[i]);
1699  	}
1700  	ProjectionV.Add(SimCol);
1701  	ProjectInPlace(ProjectionV);
1702  	TStr CName = "Group";
1703    TIntV UniqueVec;
1704    THash<TGroupKey, TPair<TInt, TIntV> > Grouping;
1705    GroupAux(NGroupBy, Grouping, false, CName, false, UniqueVec);
1706  	PTable GroupJointTable = SelfSimJoinPerGroup(CName, SimCol, DistanceColName, SimType, Threshold);
1707  	PTable JointTable = InitializeJointTable(*this);
1708  	THash<TInt, TInt> GroupIdH;
1709  	for(THash<TGroupKey, TPair<TInt, TIntV> >::TIter it=Grouping.BegI(); it<Grouping.EndI(); it++)
1710  	{
1711  		TPair<TInt, TIntV> group = it.GetDat();
1712  		TInt GroupNum = group.Val1;
1713  		TIntV RowIds = group.Val2;
1714  		if(!GroupIdH.IsKey(GroupNum))
1715  		{
1716  			TInt RandomRowId = RowIds[0];  
1717  			GroupIdH.AddDat(GroupNum, RandomRowId);
1718  		}
1719  	}
1720  	for(TRowIterator RowI = GroupJointTable->BegRI(); RowI < GroupJointTable->EndRI(); RowI++)
1721  	{
1722  		TInt GroupId1 = GroupJointTable->IntCols[0][RowI.GetRowIdx()];
1723  		TInt GroupId2 = GroupJointTable->IntCols[1][RowI.GetRowIdx()];
1724  		TInt RowId1 = GroupIdH.GetDat(GroupId1);
1725  		TInt RowId2 = GroupIdH.GetDat(GroupId2);
1726  		JointTable->AddJointRow(*this, *this, RowId1, RowId2);
1727  	} 
1728  	JointTable->StoreFltCol(DistanceColName, GroupJointTable->FltCols[0]);
1729  	ProjectionV.Clr();
1730  	ProjectionV.Add(DistanceColName);
1731  	for(TInt i=0; i<GroupBy.Len(); i++){
1732  		for(TInt j=0; j<JointTable->Sch.Len(); j++)
1733  		{
1734  			TStr ColName = JointTable->Sch[j].Val1;
1735  			if(ColName.IsStrIn(GroupBy[i]))
1736  			{
1737  				ProjectionV.Add(ColName);
1738  			}
1739  		}
1740  	}
1741  	JointTable->ProjectInPlace(ProjectionV);
1742  	JointTable->InitIds();
1743  	return JointTable;
1744  }
1745  void TTable::IncrementNext()
1746  {
1747  	NumRows++;
1748  	NumValidRows++;
1749  	if (!Next.Empty()) {
1750  		Next[Next.Len()-1] = NumValidRows-1;
1751  		LastValidRow = NumValidRows-1;
1752  	}
1753  	Next.Add(Last);
1754  }
1755  PTable TTable::Join(const TStr& Col1, const TTable& Table, const TStr& Col2) {
1756    if (!IsColName(Col1)) {
1757      TExcept::Throw("no such column " + Col1);
1758      printf("no such column %s\n", Col1.CStr());
1759    }
1760    if (!Table.IsColName(Col2)) {
1761      TExcept::Throw("no such column " + Col2);
1762      printf("no such column %s\n", Col2.CStr());
1763    }
1764    if (GetColType(Col1) != Table.GetColType(Col2)) {
1765      TExcept::Throw("Trying to Join on columns of different type");
1766      printf("Trying to Join on columns of different type\n");
1767    }
1768    PTable JointTable = InitializeJointTable(Table);
1769    TAttrType ColType = GetColType(Col1);
1770    TBool ThisIsSmaller = (NumValidRows <= Table.NumValidRows);
1771    const TTable& TS = ThisIsSmaller ? *this : Table;
1772    const TTable& TB = ThisIsSmaller ?  Table : *this;
1773    TStr ColS = ThisIsSmaller ? Col1 : Col2;
1774    TStr ColB = ThisIsSmaller ? Col2 : Col1;
1775    TInt ColBId = ThisIsSmaller ? Table.GetColIdx(ColB) : GetColIdx(ColB);
1776  #ifdef GCC_ATOMIC
1777    if (GetMP()) {
1778      switch(ColType){
1779        case atInt:{
1780          THashMP<TInt, TIntV> T(TS.GetNumValidRows());
1781          TS.GroupByIntColMP(ColS, T, true);
1782          TIntPrV Partitions;
1783          TB.GetPartitionRanges(Partitions, omp_get_max_threads()*CHUNKS_PER_THREAD);
1784          TInt PartitionSize = Partitions[0].GetVal2()-Partitions[0].GetVal1()+1;
1785          TVec<TIntPrV> JointRowIDSet(Partitions.Len());
1786          #pragma omp parallel for schedule(dynamic, CHUNKS_PER_THREAD) 
1787          for (int i = 0; i < Partitions.Len(); i++){
1788            JointRowIDSet[i].Reserve(PartitionSize);
1789            TRowIterator RowI(Partitions[i].GetVal1(), &TB);
1790            TRowIterator EndI(Partitions[i].GetVal2(), &TB);
1791            while (RowI < EndI) {
1792              TInt K = RowI.GetIntAttr(ColBId);
1793              if(T.IsKey(K)){
1794                TIntV& Group = T.GetDat(K);
<span onclick='openModal()' class='match'>1795                for(TInt j = 0; j < Group.Len(); j++){
1796                  if(ThisIsSmaller){
1797                    JointRowIDSet[i].Add(TIntPr(Group[j], RowI.GetRowIdx()));
1798                  } else{
1799                    JointRowIDSet[i].Add(TIntPr(RowI.GetRowIdx(), Group[j]));
1800                  }
1801                }
1802              }
</span>1803              RowI++;
1804            }
1805          }
1806          JointTable->AddNJointRowsMP(*this, Table, JointRowIDSet);      
1807          break;
1808        }
1809        case atFlt:{
1810          THashMP<TFlt, TIntV> T(TS.GetNumValidRows());
1811          TS.GroupByFltCol(ColS, T, TIntV(), true);
1812          TIntPrV Partitions;
1813          TB.GetPartitionRanges(Partitions, omp_get_max_threads()*CHUNKS_PER_THREAD);
1814          TInt PartitionSize = Partitions[0].GetVal2()-Partitions[0].GetVal1()+1;
1815          TVec<TIntPrV> JointRowIDSet(Partitions.Len());
1816          #pragma omp parallel for schedule(dynamic) 
1817          for (int i = 0; i < Partitions.Len(); i++){
1818            JointRowIDSet[i].Reserve(PartitionSize);
1819            TRowIterator RowI(Partitions[i].GetVal1(), &TB);
1820            TRowIterator EndI(Partitions[i].GetVal2(), &TB);
1821            while (RowI < EndI) {
1822              TFlt K = RowI.GetFltAttr(ColBId);
1823              if(T.IsKey(K)){
1824                TIntV& Group = T.GetDat(K);
1825                for(TInt j = 0; j < Group.Len(); j++){
1826                  if(ThisIsSmaller){
1827                    JointRowIDSet[i].Add(TIntPr(Group[j], RowI.GetRowIdx()));
1828                  } else{
1829                    JointRowIDSet[i].Add(TIntPr(RowI.GetRowIdx(), Group[j]));
1830                  }
1831                }
1832              }
1833              RowI++;
1834            }
1835          }
1836          JointTable->AddNJointRowsMP(*this, Table, JointRowIDSet);
1837          break;
1838        }
1839        case atStr:{
1840          THashMP<TInt, TIntV> T(TS.GetNumValidRows());
1841          TS.GroupByStrCol(ColS, T, TIntV(), true);
1842          TIntPrV Partitions;
1843          TB.GetPartitionRanges(Partitions, omp_get_max_threads()*CHUNKS_PER_THREAD);
1844          TInt PartitionSize = Partitions[0].GetVal2()-Partitions[0].GetVal1()+1;
1845          TVec<TIntPrV> JointRowIDSet(Partitions.Len());
1846          #pragma omp parallel for schedule(dynamic) 
1847          for (int i = 0; i < Partitions.Len(); i++){
1848            JointRowIDSet[i].Reserve(PartitionSize);
1849            TRowIterator RowI(Partitions[i].GetVal1(), &TB);
1850            TRowIterator EndI(Partitions[i].GetVal2(), &TB);
1851            while (RowI < EndI) {
1852              TInt K = RowI.GetStrMapById(ColBId);
1853              if(T.IsKey(K)){
1854                TIntV& Group = T.GetDat(K);
1855                for(TInt j = 0; j < Group.Len(); j++){
1856                  if(ThisIsSmaller){
1857                    JointRowIDSet[i].Add(TIntPr(Group[j], RowI.GetRowIdx()));
1858                  } else{
1859                    JointRowIDSet[i].Add(TIntPr(RowI.GetRowIdx(), Group[j]));
1860                  }
1861                }
1862              }
1863              RowI++;
1864            }
1865          }
1866          JointTable->AddNJointRowsMP(*this, Table, JointRowIDSet);
1867        }
1868        break;
1869      }
1870    } else {
1871  #endif 
1872      switch (ColType) {
1873        case atInt:{
1874          TIntIntVH T;
1875          TS.GroupByIntCol(ColS, T, TIntV(), true);
1876          for (TRowIterator RowI = TB.BegRI(); RowI < TB.EndRI(); RowI++) {
1877            TInt K = RowI.GetIntAttr(ColBId);
1878            if (T.IsKey(K)) {
1879              TIntV& Group = T.GetDat(K);
1880              for (TInt i = 0; i < Group.Len(); i++) {
1881                if (ThisIsSmaller) {
1882                  JointTable->AddJointRow(*this, Table, Group[i], RowI.GetRowIdx());
1883                } else {
1884                  JointTable->AddJointRow(*this, Table, RowI.GetRowIdx(), Group[i]);
1885                }
1886              }
1887            }
1888          }
1889          break;
1890        }
1891        case atFlt:{
1892          THash<TFlt, TIntV> T;
1893          TS.GroupByFltCol(ColS, T, TIntV(), true);
1894          for (TRowIterator RowI = TB.BegRI(); RowI < TB.EndRI(); RowI++) {
1895            TFlt K = RowI.GetFltAttr(ColBId);
1896            if (T.IsKey(K)) {
1897              TIntV& Group = T.GetDat(K);
1898              for (TInt i = 0; i < Group.Len(); i++) {
1899                if (ThisIsSmaller) {
1900                  JointTable->AddJointRow(*this, Table, Group[i], RowI.GetRowIdx());
1901                } else {
1902                  JointTable->AddJointRow(*this, Table, RowI.GetRowIdx(), Group[i]);
1903                }
1904              }
1905            }
1906          }
1907          break;
1908        }
1909        case atStr:{
1910          TIntIntVH T;
1911          TS.GroupByStrCol(ColS, T, TIntV(), true);
1912          for (TRowIterator RowI = TB.BegRI(); RowI < TB.EndRI(); RowI++) {
1913            TInt K = RowI.GetStrMapById(ColBId);
1914            if (T.IsKey(K)) {
1915              TIntV& Group = T.GetDat(K);
1916              for (TInt i = 0; i < Group.Len(); i++) {
1917                if (ThisIsSmaller) {
1918                  JointTable->AddJointRow(*this, Table, Group[i], RowI.GetRowIdx());
1919                } else {
1920                  JointTable->AddJointRow(*this, Table, RowI.GetRowIdx(), Group[i]);
1921                }
1922              }
1923            }
1924          }
1925        }
1926        break;
1927      }
1928  #ifdef GCC_ATOMIC
1929    }
1930  #endif
1931    return JointTable; 
1932  }
1933  void TTable::ThresholdJoinInputCorrectness(const TStr& KeyCol1, const TStr& JoinCol1, const TTable& Table, 
1934    const TStr& KeyCol2, const TStr& JoinCol2){
1935    if (!IsColName(KeyCol1)) {
1936      printf("no such column %s\n", KeyCol1.CStr());
1937      TExcept::Throw("no such column " + KeyCol1);
1938    }
1939    if (!Table.IsColName(KeyCol2)) {
1940      printf("no such column %s\n", KeyCol2.CStr());
1941      TExcept::Throw("no such column " + KeyCol2);
1942    }
1943    if (!IsColName(JoinCol1)) {
1944      printf("no such column %s\n", JoinCol1.CStr());
1945      TExcept::Throw("no such column " + JoinCol1);
1946    }
1947    if (!Table.IsColName(JoinCol2)) {
1948      printf("no such column %s\n", JoinCol2.CStr());
1949      TExcept::Throw("no such column " + JoinCol2);
1950    }
1951    if (GetColType(JoinCol1) != Table.GetColType(JoinCol2)) {
1952      printf("Trying to Join on columns of different type\n");
1953      TExcept::Throw("Trying to Join on columns of different type");
1954    }
1955    if (GetColType(KeyCol1) != Table.GetColType(KeyCol2)) {
1956      printf("Key type mismatch\n");
1957      TExcept::Throw("Key type mismatch");
1958    }
1959  }
1960  void TTable::ThresholdJoinCountCollisions(const TTable& TB, const TTable& TS, 
1961    const TIntIntVH& T, TInt JoinColIdxB, TInt KeyColIdxB, TInt KeyColIdxS, 
1962    THash<TIntPr,TIntTr>& Counters, TBool ThisIsSmaller, TAttrType JoinColType, TAttrType KeyType){
1963      for (TRowIterator RowI = TB.BegRI(); RowI < TB.EndRI(); RowI++) {
1964        TInt JVal = 0;
1965        if(JoinColType == atStr){
1966          JVal = RowI.GetStrMapById(JoinColIdxB);
1967        } else{
1968          JVal = RowI.GetIntAttr(JoinColIdxB);
1969        }
1970        if(T.IsKey(JVal)){
1971          TInt KeyB = 0;
1972          if(KeyType == atStr){
1973            KeyB = RowI.GetStrMapById(KeyColIdxB);
1974          } else{
1975            KeyB = RowI.GetIntAttr(KeyColIdxB);
1976          } 
1977          const TIntV& RelevantRows = T.GetDat(JVal);
1978          for(int i = 0; i < RelevantRows.Len(); i++){
1979            TInt KeyS = 0;
1980            if(KeyType == atStr){
1981              KeyS = TS.StrColMaps[KeyColIdxS][RelevantRows[i]];
1982            } else{
1983              KeyS = TS.IntCols[KeyColIdxS][RelevantRows[i]];
1984            }
1985            TIntPr Keys = ThisIsSmaller ? TIntPr(KeyS, KeyB) : TIntPr(KeyB, KeyS);
1986            if(Counters.IsKey(Keys)){
1987              TIntTr& V = Counters.GetDat(Keys);
1988              V.Val3 = V.Val3 + 1;
1989            } else{
1990              if(ThisIsSmaller){
1991                Counters.AddDat(Keys, TIntTr(RelevantRows[i], RowI.GetRowIdx(),1));
1992              } else{
1993                Counters.AddDat(Keys, TIntTr(RowI.GetRowIdx(), RelevantRows[i],1));
1994              }
1995            }
1996          }	
1997        }	
1998      } 
1999  }
2000  void TTable::ThresholdJoinCountPerJoinKeyCollisions(const TTable& TB, const TTable& TS, 
2001    const TIntIntVH& T, TInt JoinColIdxB, TInt KeyColIdxB, TInt KeyColIdxS, 
2002    THash<TIntTr,TIntTr>& Counters, TBool ThisIsSmaller, TAttrType JoinColType, TAttrType KeyType){
2003      for (TRowIterator RowI = TB.BegRI(); RowI < TB.EndRI(); RowI++) {
2004        TInt JVal = 0;
2005        if(JoinColType == atStr){
2006          JVal = RowI.GetStrMapById(JoinColIdxB);
2007         } else{
2008          JVal = RowI.GetIntAttr(JoinColIdxB);
2009         }
2010        if(T.IsKey(JVal)){
2011          TInt KeyB = 0;
2012          if(KeyType == atStr){
2013            KeyB = RowI.GetStrMapById(KeyColIdxB);
2014          } else{
2015            KeyB = RowI.GetIntAttr(KeyColIdxB);
2016          } 
2017          const TIntV& RelevantRows = T.GetDat(JVal);
2018          for(int i = 0; i < RelevantRows.Len(); i++){
2019            TInt KeyS = 0;
2020            if(KeyType == atStr){
2021              KeyS = TS.StrColMaps[KeyColIdxS][RelevantRows[i]];
2022            } else{
2023              KeyS = TS.IntCols[KeyColIdxS][RelevantRows[i]];
2024            }
2025          	TIntPr Keys = ThisIsSmaller ? TIntPr(KeyS, KeyB) : TIntPr(KeyB, KeyS);
2026          	TIntTr K(Keys.Val1,Keys.Val2,JVal);
2027            if(Counters.IsKey(K)){
2028              TIntTr& V = Counters.GetDat(K);
2029              V.Val3 = V.Val3 + 1;
2030            } else{
2031              if(ThisIsSmaller){
2032                Counters.AddDat(K, TIntTr(RelevantRows[i], RowI.GetRowIdx(),1));
2033              } else{
2034                Counters.AddDat(K, TIntTr(RowI.GetRowIdx(), RelevantRows[i],1));
2035              }
2036            }
2037          }	
2038        }	
2039      } 
2040    }
2041  PTable TTable::ThresholdJoinOutputTable(const THash<TIntPr,TIntTr>& Counters, TInt Threshold, const TTable& Table){
2042    PTable JointTable = InitializeJointTable(Table);
2043    for(THash<TIntPr,TIntTr>::TIter iter = Counters.BegI(); iter < Counters.EndI(); iter++){
2044      TIntTr& Counter = iter.GetDat();
2045      if(Counter.Val3 >= Threshold){
2046        JointTable->AddJointRow(*this, Table, Counter.Val1, Counter.Val2);
2047      }
2048    }
2049    return JointTable;
2050  }
2051  PTable TTable::ThresholdJoinPerJoinKeyOutputTable(const THash<TIntTr,TIntTr>& Counters, TInt Threshold, const TTable& Table){
2052    PTable JointTable = InitializeJointTable(Table);
2053    for(THash<TIntTr,TIntTr>::TIter iter = Counters.BegI(); iter < Counters.EndI(); iter++){
2054      const TIntTr& Counter = iter.GetDat();
2055      const TIntTr& Keys = iter.GetKey();
2056      THashSet<TIntPr> Pairs;
2057      if(Counter.Val3 >= Threshold){
2058        TIntPr K(Keys.Val1,Keys.Val2);
2059        if(!Pairs.IsKey(K)){
2060          Pairs.AddKey(K);
2061          JointTable->AddJointRow(*this, Table, Counter.Val1, Counter.Val2);
2062        }
2063      }
2064    }
2065    return JointTable;
2066  }
2067  PTable TTable::ThresholdJoin(const TStr& KeyCol1, const TStr& JoinCol1, const TTable& Table, 
2068    const TStr& KeyCol2, const TStr& JoinCol2, TInt Threshold, TBool PerJoinKey){
2069    ThresholdJoinInputCorrectness(KeyCol1, JoinCol1, Table, KeyCol2, JoinCol2);
2070    TAttrType JoinColType = GetColType(JoinCol1);
2071    TAttrType KeyType = GetColType(KeyCol1);
2072    TBool ThisIsSmaller = (NumValidRows <= Table.NumValidRows);
2073    const TTable& TS = ThisIsSmaller ? *this : Table;
2074    const TTable& TB = ThisIsSmaller ?  Table : *this;
2075    TStr JoinColS = JoinCol1;
2076    TInt JoinColIdxB = GetColIdx(JoinCol2);
2077    TInt KeyColIdxS = GetColIdx(KeyCol1);
2078    TInt KeyColIdxB = GetColIdx(KeyCol2);
2079    if(!ThisIsSmaller){
2080    	JoinColS = JoinCol2;
2081      JoinColIdxB = GetColIdx(JoinCol1);
2082    	KeyColIdxS = GetColIdx(KeyCol2);
2083      KeyColIdxB = GetColIdx(KeyCol1);
2084    }
2085    if(KeyType != atInt && KeyType != atStr){
2086      printf("ThresholdJoin only supports integer or string key attributes\n");
2087      TExcept::Throw("ThresholdJoin only supports integer or string key attributes");
2088    }
2089    if(JoinColType != atInt && JoinColType != atStr){
2090      printf("ThresholdJoin only supports integer or string join attributes\n");
2091      TExcept::Throw("ThresholdJoin only supports integer or string join attributes");
2092    }
2093    TIntIntVH T;
2094    if(JoinColType == atInt){
2095      TS.GroupByIntCol(JoinColS, T, TIntV(), true);
2096    } else if(JoinColType == atStr){
2097      TS.GroupByStrCol(JoinColS, T, TIntV(), true);
2098    } else{
2099      TExcept::Throw("ThresholdJoin only supports integer or string join attributes");
2100    } 
2101    if(PerJoinKey){
2102      THash<TIntTr,TIntTr> Counters;
2103      ThresholdJoinCountPerJoinKeyCollisions(TB, TS, T, JoinColIdxB, KeyColIdxB, KeyColIdxS, Counters, ThisIsSmaller, JoinColType, KeyType);
2104      return ThresholdJoinPerJoinKeyOutputTable(Counters, Threshold, Table);
2105    } else{
2106      THash<TIntPr,TIntTr> Counters;
2107      ThresholdJoinCountCollisions(TB, TS, T, JoinColIdxB, KeyColIdxB, KeyColIdxS, Counters, ThisIsSmaller, JoinColType, KeyType);
2108      return ThresholdJoinOutputTable(Counters, Threshold, Table);
2109    }
2110  }
2111  void TTable::Select(TPredicate& Predicate, TIntV& SelectedRows, TBool Remove) {
2112    TIntV Selected;
2113    TStrV RelevantCols;
2114    Predicate.GetVariables(RelevantCols);
2115    TInt NumRelevantCols = RelevantCols.Len();
2116    TVec<TAttrType> ColTypes = TVec<TAttrType>(NumRelevantCols);
2117    TIntV ColIndices = TIntV(NumRelevantCols);
2118    for (TInt i = 0; i < NumRelevantCols; i++) {
2119      ColTypes[i] = GetColType(RelevantCols[i]);
2120      ColIndices[i] = GetColIdx(RelevantCols[i]);
2121    } 
2122    if (Remove) {
2123      TRowIteratorWithRemove RowI = BegRIWR();
2124      while (RowI.GetNextRowIdx() != Last) {
2125        for (TInt i = 0; i < NumRelevantCols; i++) {
2126          switch (ColTypes[i]) {
2127          case atInt:
2128            Predicate.SetIntVal(RelevantCols[i], RowI.GetNextIntAttr(ColIndices[i]));
2129            break;
2130          case atFlt:
2131            Predicate.SetFltVal(RelevantCols[i], RowI.GetNextFltAttr(ColIndices[i]));
2132            break;
2133          case atStr:
2134            Predicate.SetStrVal(RelevantCols[i], RowI.GetNextStrAttr(ColIndices[i]));
2135            break;
2136          }
2137        }
2138        if (!Predicate.Eval()) { 
2139          RowI.RemoveNext();
2140        } else {
2141          RowI++;
2142        }
2143      }
2144    } else {
2145      for (TRowIterator RowI = BegRI(); RowI < EndRI(); RowI++) {
2146        for (TInt i = 0; i < NumRelevantCols; i++) {
2147          switch (ColTypes[i]) {
2148          case atInt:
2149            Predicate.SetIntVal(RelevantCols[i], RowI.GetIntAttr(RelevantCols[i]));
2150            break;
2151          case atFlt:
2152            Predicate.SetFltVal(RelevantCols[i], RowI.GetFltAttr(RelevantCols[i]));
2153            break;
2154          case atStr:
2155            Predicate.SetStrVal(RelevantCols[i], RowI.GetStrAttr(RelevantCols[i]));
2156            break;
2157          }
2158        }
2159        if (Predicate.Eval()) { SelectedRows.Add(RowI.GetRowIdx()); }
2160      }
2161    }
2162  }
2163  void TTable::Classify(TPredicate& Predicate, const TStr& LabelName, const TInt& PositiveLabel, const TInt& NegativeLabel) {
2164    TIntV SelectedRows;
2165    Select(Predicate, SelectedRows, false);
2166    ClassifyAux(SelectedRows, LabelName, PositiveLabel, NegativeLabel);
2167  }
2168  void TTable::SelectAtomic(const TStr& Col1, const TStr& Col2, TPredComp Cmp, TIntV& SelectedRows, TBool Remove) {
2169    const TAttrType Ty1 = GetColType(Col1);
2170    const TAttrType Ty2 = GetColType(Col2);
2171    const TInt ColIdx1 = GetColIdx(Col1);
2172    const TInt ColIdx2 = GetColIdx(Col2);
2173    if (Ty1 != Ty2) {
2174      TExcept::Throw("SelectAtomic: diff types");
2175    }
2176    if (Cmp == SUBSTR || Cmp == SUPERSTR) { Assert(Ty1 == atStr); }
2177    if (Remove) {
2178      TRowIteratorWithRemove RowI = BegRIWR();
2179      while (RowI.GetNextRowIdx() != Last) {
2180        TBool Result;
2181        switch (Ty1) {
2182          case atInt:
2183            Result = TPredicate::EvalAtom(RowI.GetNextIntAttr(ColIdx1), RowI.GetNextIntAttr(ColIdx2), Cmp);
2184            break;
2185          case atFlt:
2186            Result = TPredicate::EvalAtom(RowI.GetNextFltAttr(ColIdx1), RowI.GetNextFltAttr(ColIdx2), Cmp);
2187            break;
2188          case atStr:
2189            Result = TPredicate::EvalStrAtom(RowI.GetNextStrAttr(ColIdx1), RowI.GetNextStrAttr(ColIdx2), Cmp);
2190            break;
2191        }
2192        if (!Result) { 
2193          RowI.RemoveNext();
2194        } else {
2195          RowI++;
2196        }
2197      }
2198    } else {
2199      for (TRowIterator RowI = BegRI(); RowI < EndRI(); RowI++) {
2200        TBool Result;
2201        switch (Ty1) {
2202          case atInt:
2203            Result = TPredicate::EvalAtom(RowI.GetIntAttr(Col1), RowI.GetIntAttr(Col2), Cmp);
2204            break;
2205          case atFlt:
2206            Result = TPredicate::EvalAtom(RowI.GetFltAttr(Col1), RowI.GetFltAttr(Col2), Cmp);
2207            break;
2208          case atStr:
2209            Result = TPredicate::EvalStrAtom(RowI.GetStrAttr(Col1), RowI.GetStrAttr(Col2), Cmp);
2210            break;
2211        }
2212        if (Result) { SelectedRows.Add(RowI.GetRowIdx()); }
2213      }
2214    }
2215  }
2216  void TTable::ClassifyAtomic(const TStr& Col1, const TStr& Col2, TPredComp Cmp,
2217    const TStr& LabelName, const TInt& PositiveLabel, const TInt& NegativeLabel) {
2218    TIntV SelectedRows;
2219    SelectAtomic(Col1, Col2, Cmp, SelectedRows, false);
2220    ClassifyAux(SelectedRows, LabelName, PositiveLabel, NegativeLabel);
2221  }
2222  void TTable::SelectAtomicConst(const TStr& Col, const TPrimitive& Val, TPredComp Cmp, 
2223    TIntV& SelectedRows, PTable& SelectedTable, TBool Remove, TBool Table) {
2224    TStr ValTStr(Val.GetStr());
2225    TAttrType Type = GetColType(Col);
2226    TInt ColIdx = GetColIdx(Col);
2227    if (Type != Val.GetType()) { 
2228      TExcept::Throw("SelectAtomicConst: coltype does not match const type"); 
2229    }
2230    if(Remove){
2231  #ifdef USE_OPENMP
2232      if (GetMP()) {
2233        TIntPrV Partitions;
2234        GetPartitionRanges(Partitions, omp_get_max_threads()*CHUNKS_PER_THREAD);
2235        TInt PartitionSize = Partitions[0].GetVal2()-Partitions[0].GetVal1()+1;
2236        int RemoveCount = 0;
2237        TIntPrV Bounds(Partitions.Len());
2238        #pragma omp parallel for schedule(dynamic, CHUNKS_PER_THREAD) reduction(+:RemoveCount)
2239        for (int i = 0; i < Partitions.Len(); i++){
2240          TRowIterator RowI(Partitions[i].GetVal1(), this);
2241          TRowIterator EndI(Partitions[i].GetVal2(), this);
2242          TInt FirstRowIdx = TTable::Invalid;
2243          TInt LastRowIdx = TTable::Invalid;
2244          TBool First = true;
2245          while (RowI < EndI) {
2246            TInt CurrRowIdx = RowI.GetRowIdx();
2247            TBool Result;
2248            if (Type != atStr) {
2249              Result = RowI.CompareAtomicConst(ColIdx, Val, Cmp);
2250            } else {
2251              Result = RowI.CompareAtomicConstTStr(ColIdx, ValTStr, Cmp);
2252            }
2253            RowI++;
2254            if(!Result) {
2255              Next[CurrRowIdx] = TTable::Invalid;
2256              RemoveCount++;
2257            } else { 
2258              if (First) { FirstRowIdx = CurrRowIdx; First = false; } 
2259              else { Next[LastRowIdx] = CurrRowIdx; }
2260              LastRowIdx = CurrRowIdx; 
2261            }
2262          }
2263          Bounds[i] = TIntPr(FirstRowIdx, LastRowIdx);
2264        }
2265        TInt CurrBound = 0;
2266        while (CurrBound < Bounds.Len() && Bounds[CurrBound].Val1 == TTable::Invalid) {
2267          CurrBound++;
2268        }
2269        if (CurrBound == Bounds.Len()) {
2270          Assert(NumValidRows == RemoveCount);
2271          NumValidRows = 0;
2272          FirstValidRow = TTable::Invalid;
2273          LastValidRow = TTable::Invalid;
2274        } else {
2275          NumValidRows -= RemoveCount;
2276          FirstValidRow = Bounds[CurrBound].Val1;
2277          LastValidRow = Bounds[CurrBound].Val2;
2278          TInt PrevBound = CurrBound;
2279          CurrBound++;
2280          while (CurrBound < Bounds.Len()) {
2281            if (Bounds[CurrBound].Val1 == TTable::Invalid) { CurrBound++; continue; }
2282            Next[Bounds[PrevBound].Val2] = Bounds[CurrBound].Val1;
2283            LastValidRow = Bounds[CurrBound].Val2;
2284            PrevBound = CurrBound;
2285            CurrBound++;
2286          }
2287          Next[Bounds[PrevBound].Val2] = TTable::Last;
2288        }
2289        IsNextDirty = 1;
2290      } else {
2291  #endif
2292        TRowIteratorWithRemove RowI = BegRIWR();
2293        while(RowI.GetNextRowIdx() != Last){
2294          if (!RowI.CompareAtomicConst(ColIdx, Val, Cmp)) {
2295            RowI.RemoveNext();
2296          } else {
2297            RowI++;
2298          }
2299        }
2300        IsNextDirty = 1;
2301  #ifdef USE_OPENMP
2302      }
2303  #endif
2304    } else if (Table) {
2305  #ifdef USE_OPENMP
2306      if (GetMP()) {
2307        TIntPrV Partitions;
2308        GetPartitionRanges(Partitions, omp_get_max_threads()*CHUNKS_PER_THREAD);
2309        TInt PartitionSize = Partitions[0].GetVal2()-Partitions[0].GetVal1()+1;
2310        int TotalSelectedRows = 0;
2311        #pragma omp parallel for schedule(dynamic, CHUNKS_PER_THREAD) reduction(+:TotalSelectedRows)
2312        for (int i = 0; i < Partitions.Len(); i++){
2313          TRowIterator RowI(Partitions[i].GetVal1(), this);
2314          TRowIterator EndI(Partitions[i].GetVal2(), this);
2315          while (RowI < EndI) {
2316            if (Type != atStr) {
2317              if (RowI.CompareAtomicConst(ColIdx, Val, Cmp)) { 
2318                TotalSelectedRows++;
2319              }
2320            } else {
2321              if (RowI.CompareAtomicConstTStr(ColIdx, ValTStr, Cmp)) { 
2322                TotalSelectedRows++;
2323              }
2324            }
2325            RowI++;
2326          }
2327        }
2328        SelectedTable->ResizeTable(TotalSelectedRows);
2329        if (TotalSelectedRows == 0) {
2330          return;
2331        }
2332        #pragma omp parallel for schedule(dynamic, CHUNKS_PER_THREAD)
2333        for (int i = 0; i < Partitions.Len(); i++){
2334          TIntV LocalSelectedRows;
2335          LocalSelectedRows.Reserve(PartitionSize);
2336          TRowIterator RowI(Partitions[i].GetVal1(), this);
2337          TRowIterator EndI(Partitions[i].GetVal2(), this);
2338          while (RowI < EndI) {
2339            if (Type != atStr) {
2340              if (RowI.CompareAtomicConst(ColIdx, Val, Cmp)) { 
2341                LocalSelectedRows.Add(RowI.GetRowIdx());
2342              }
2343            } else {
2344              if (RowI.CompareAtomicConstTStr(ColIdx, ValTStr, Cmp)) { 
2345                LocalSelectedRows.Add(RowI.GetRowIdx());
2346              }
2347            }
2348            RowI++;
2349          }
2350          SelectedTable->AddSelectedRows(*this, LocalSelectedRows);
2351        }
2352        SelectedTable->SetFirstValidRow();
2353      } else {
2354  #endif
2355        for(TRowIterator RowI = BegRI(); RowI < EndRI(); RowI++){
2356          if (RowI.CompareAtomicConst(ColIdx, Val, Cmp)) { 
2357            SelectedTable->AddRowI(RowI);
2358          }
2359        }
2360  #ifdef USE_OPENMP
2361      }
2362  #endif
2363    } else {
2364      for(TRowIterator RowI = BegRI(); RowI < EndRI(); RowI++){
2365        if (RowI.CompareAtomicConst(ColIdx, Val, Cmp)) { 
2366          SelectedRows.Add(RowI.GetRowIdx());
2367        }
2368      }
2369    }
2370  }
2371  inline TInt TTable::CompareRows(TInt R1, TInt R2, const TAttrType& CompareByType, const TInt& CompareByIndex, TBool Asc) {
2372    switch (CompareByType) {
2373      case atInt:{
2374        if (IntCols[CompareByIndex][R1] > IntCols[CompareByIndex][R2]) { return (Asc ? 1 : -1); }
2375        if (IntCols[CompareByIndex][R1] < IntCols[CompareByIndex][R2]) { return (Asc ? -1 : 1); }
2376        return 0;
2377      }
2378      case atFlt:{
2379        if (FltCols[CompareByIndex][R1] > FltCols[CompareByIndex][R2]) { return (Asc ? 1 : -1); }
2380        if (FltCols[CompareByIndex][R1] < FltCols[CompareByIndex][R2]) { return (Asc ? -1 : 1); }
2381        return 0;
2382      }
2383      case atStr:{
2384        TStr S1 = GetStrValIdx(CompareByIndex, R1);
2385        TStr S2 = GetStrValIdx(CompareByIndex, R2);
2386        int CmpRes = strcmp(S1.CStr(), S2.CStr());
2387        return (Asc ? CmpRes : -CmpRes);
2388      }
2389    }
2390    return 0;
2391  }
2392  inline TInt TTable::CompareRows(TInt R1, TInt R2, const TVec<TAttrType>& CompareByTypes, const TIntV& CompareByIndices, TBool Asc) {
2393    for (TInt i = 0; i < CompareByTypes.Len(); i++) {
2394      TInt res = CompareRows(R1, R2, CompareByTypes[i], CompareByIndices[i], Asc);
2395      if (res != 0) { return res; }
2396    }
2397    return 0;
2398  }
2399  void TTable::ISort(TIntV& V, TInt StartIdx, TInt EndIdx, const TVec<TAttrType>& SortByTypes, const TIntV& SortByIndices, TBool Asc) {
2400    if (StartIdx < EndIdx) {
2401      for (TInt i = StartIdx+1; i <= EndIdx; i++) {
2402        TInt Val = V[i];
2403        TInt j = i;
2404        while ((StartIdx < j) && (CompareRows(V[j-1], Val, SortByTypes, SortByIndices, Asc) > 0)) {
2405          V[j] = V[j-1];
2406          j--;
2407        }
2408        V[j] = Val;
2409      }
2410    }
2411  }
2412  TInt TTable::GetPivot(TIntV& V, TInt StartIdx, TInt EndIdx, const TVec<TAttrType>& SortByTypes, const TIntV& SortByIndices, TBool Asc) {
2413    TInt L = EndIdx - StartIdx + 1;
2414    const TInt Idx1 = StartIdx + TInt::GetRnd(L);
2415    const TInt Idx2 = StartIdx + TInt::GetRnd(L);
2416    const TInt Idx3 = StartIdx + TInt::GetRnd(L);
2417    if (CompareRows(V[Idx1], V[Idx2], SortByTypes, SortByIndices, Asc) < 0) {
2418      if (CompareRows(V[Idx2], V[Idx3], SortByTypes, SortByIndices, Asc) < 0) { return Idx2; }
2419      if (CompareRows(V[Idx1], V[Idx3], SortByTypes, SortByIndices, Asc) < 0) { return Idx3; }
2420      return Idx1;
2421    } else {
2422      if (CompareRows(V[Idx3], V[Idx2], SortByTypes, SortByIndices, Asc) < 0) { return Idx2; }
2423      if (CompareRows(V[Idx3], V[Idx1], SortByTypes, SortByIndices, Asc) < 0) { return Idx3; }
2424      return Idx1;
2425    }
2426  }
2427  TInt TTable::Partition(TIntV& V, TInt StartIdx, TInt EndIdx, const TVec<TAttrType>& SortByTypes, const TIntV& SortByIndices, TBool Asc) {
2428    TInt j;
2429    for (j = StartIdx; j < EndIdx; j++) {
2430      if (CompareRows(V[j], V[j+1], SortByTypes, SortByIndices, Asc) > 0) {
2431        break;
2432      }
2433    }
2434    if (j >= EndIdx) {
2435      return EndIdx+1;
2436    }
2437    TInt PivotIdx = GetPivot(V, StartIdx, EndIdx, SortByTypes, SortByIndices, Asc);
2438    TInt Pivot = V[PivotIdx];
2439    V.Swap(PivotIdx, EndIdx);
2440    TInt StoreIdx = StartIdx;
2441    for (TInt i = StartIdx; i < EndIdx; i++) {
2442      if (CompareRows(V[i], Pivot, SortByTypes, SortByIndices, Asc) <= 0) {
2443        V.Swap(i, StoreIdx);
2444        StoreIdx++;
2445      }
2446    }
2447    V.Swap(StoreIdx, EndIdx);
2448    return StoreIdx;
2449  }
2450  void TTable::QSort(TIntV& V, TInt StartIdx, TInt EndIdx, const TVec<TAttrType>& SortByTypes, const TIntV& SortByIndices, TBool Asc) {
2451    if (StartIdx < EndIdx) {
2452      if (EndIdx - StartIdx < 20) {
2453        ISort(V, StartIdx, EndIdx, SortByTypes, SortByIndices, Asc);
2454      } else {
2455        TInt Pivot = Partition(V, StartIdx, EndIdx, SortByTypes, SortByIndices, Asc);
2456        if (Pivot > EndIdx) {
2457          return;
2458        }
2459        int Ub = Pivot - 1;
2460        while (Ub >= StartIdx && CompareRows(
2461          V[Ub], V[Pivot], SortByTypes, SortByIndices, Asc) == 0) {
2462          Ub -= 1;
2463        }
2464        QSort(V, StartIdx, Ub, SortByTypes, SortByIndices, Asc);
2465        QSort(V, Pivot+1, EndIdx, SortByTypes, SortByIndices, Asc);
2466      }
2467    }
2468  }
2469  void TTable::Merge(TIntV& V, TInt Idx1, TInt Idx2, TInt Idx3, const TVec<TAttrType>& SortByTypes, const TIntV& SortByIndices, TBool Asc) {
2470    TInt i = Idx1, j = Idx2;
2471    TIntV SortedV;
2472    while  (i < Idx2 && j < Idx3) {
2473      if (CompareRows(V[i], V[j], SortByTypes, SortByIndices, Asc) <= 0) {
2474        SortedV.Add(V[i]);
2475        i++;
2476      }
2477      else {
2478        SortedV.Add(V[j]);
2479        j++;
2480      }
2481    }
2482    while (i < Idx2) {
2483      SortedV.Add(V[i]);
2484      i++;
2485    }
2486    while (j < Idx3) {
2487      SortedV.Add(V[j]);
2488      j++;
2489    }
2490    for (TInt sz = 0; sz < Idx3 - Idx1; sz++) {
2491      V[Idx1 + sz] = SortedV[sz];
2492    }
2493  }
2494  #ifdef USE_OPENMP
2495  void TTable::QSortPar(TIntV& V, const TVec<TAttrType>& SortByTypes, const TIntV& SortByIndices, TBool Asc) {
2496    TInt NumThreads = 8; 
2497    TInt Sz = V.Len();
2498    TIntV IndV, NextV;
2499    for (TInt i = 0; i < NumThreads; i++) {
2500      IndV.Add(i * (Sz / NumThreads));
2501    }
2502    IndV.Add(Sz);
2503    omp_set_num_threads(NumThreads);
2504    #pragma omp parallel for
2505    for (int i = 0; i < NumThreads; i++) {
2506      QSort(V, IndV[i], IndV[i+1] - 1, SortByTypes, SortByIndices, Asc);
2507    }
2508    while (NumThreads > 1) {
2509      omp_set_num_threads(NumThreads / 2);
2510      #pragma omp parallel for
2511      for (int i = 0; i < NumThreads; i += 2) {
2512        Merge(V, IndV[i], IndV[i+1], IndV[i+2], SortByTypes, SortByIndices, Asc);
2513      }
2514      NextV.Clr();
2515      for (TInt i = 0; i < NumThreads; i+=2) {
2516        NextV.Add(IndV[i]);
2517      }
2518      NextV.Add(Sz);
2519      IndV = NextV;
2520      NumThreads = NumThreads / 2;
2521    }
2522  }
2523  #endif 
2524  void TTable::Order(const TStrV& OrderBy, TStr OrderColName, TBool ResetRankByMSC, TBool Asc) {
2525    TIntV ValidRows = TIntV(NumValidRows);
2526    if (NumRows == NumValidRows) {
2527      for (TInt i = 0; i < NumValidRows; i++) {
2528        ValidRows[i] = i;
2529      }
2530    } else {
2531      TInt i = 0;
2532      for (TRowIterator RI = BegRI(); RI < EndRI(); RI++) {
2533        ValidRows[i] = RI.GetRowIdx();
2534        i++;
2535      }
2536    }
2537    TVec<TAttrType> OrderByTypes(OrderBy.Len());
2538    TIntV OrderByIndices(OrderBy.Len());
2539    for (TInt i = 0; i < OrderBy.Len(); i++) {
2540      OrderByTypes[i] = GetColType(OrderBy[i]);
2541      OrderByIndices[i] = GetColIdx(OrderBy[i]);
2542    }
2543  #ifdef USE_OPENMP
2544    if (GetMP()) {
2545      QSortPar(ValidRows, OrderByTypes, OrderByIndices, Asc);
2546    } else {
2547  #endif
2548      QSort(ValidRows, 0, NumValidRows-1, OrderByTypes, OrderByIndices, Asc);
2549  #ifdef USE_OPENMP
2550    }
2551  #endif
2552    IsNextDirty = 1;
2553    if (NumValidRows > 0) {
2554      FirstValidRow = ValidRows[0];
2555    } else {
2556      FirstValidRow = Last;
2557    }
2558    for (TInt i = 0; i < NumValidRows-1; i++) {
2559      Next[ValidRows[i]] = ValidRows[i+1];
2560    }
2561    if (NumValidRows > 0) {
2562      Next[ValidRows[NumValidRows-1]] = Last;
2563      LastValidRow = ValidRows[NumValidRows-1];
2564    } else {
2565      LastValidRow = Last;
2566    }
2567    if (!OrderColName.Empty()) {
2568      TIntV RankCol = TIntV(NumRows);
2569      for (TInt i = 0; i < NumValidRows; i++) {
2570        RankCol[ValidRows[i]] = i;
2571      }
2572      if (ResetRankByMSC) {
2573        for (TInt i = 1; i < NumValidRows; i++) {
2574          TStr GroupName = OrderBy[0];
2575          if (GetStrVal(GroupName, ValidRows[i]) != GetStrVal(GroupName, ValidRows[i-1])) { 
2576            RankCol[ValidRows[i]] = 0;
2577          } else {
2578            RankCol[ValidRows[i]] = RankCol[ValidRows[i-1]] + 1;
2579          }
2580        }
2581      }
2582      IntCols.Add(RankCol);
2583      AddSchemaCol(OrderColName, atInt);
2584      AddColType(OrderColName, atInt, IntCols.Len()-1);
2585    }
2586  }
2587  void TTable::Defrag() {
2588    TInt FreeIndex = 0;
2589    TIntV Mapping;  
2590    TInt IdColIdx = GetColIdx(IdColName);
2591    for (TInt i = 0; i < Next.Len(); i++) {
2592      if (Next[i] != TTable::Invalid) {  
2593        if (FreeIndex == 0) {
2594          Assert (i == FirstValidRow);
2595          FirstValidRow = 0;
2596        }
2597        if (Next[i] != Last) { 
2598          Next[FreeIndex] = FreeIndex + 1;
2599          Mapping.Add(FreeIndex);
2600        } else {
2601          Next[FreeIndex] = Last;
2602          LastValidRow = FreeIndex;
2603          Mapping.Add(Last);
2604        }
2605        RowIdMap.AddDat(IntCols[IdColIdx][i], FreeIndex);
2606        for (TInt j = 0; j < IntCols.Len(); j++) {
2607          IntCols[j][FreeIndex] = IntCols[j][i];
2608        }
2609        for (TInt j = 0; j < FltCols.Len(); j++) {
2610          FltCols[j][FreeIndex] = FltCols[j][i];
2611        }
2612        for (TInt j = 0; j < StrColMaps.Len(); j++) {
2613          StrColMaps[j][FreeIndex] = StrColMaps[j][i];
2614        }
2615        FreeIndex++;
2616      } else {
2617        NumRows--;
2618        Mapping.Add(TTable::Invalid);
2619      }
2620    }
2621    Assert (NumValidRows == NumRows);
2622  }
2623  void TTable::SelectFirstNRows(const TInt& N) {
2624    if (N == 0) {
2625      LastValidRow = -1;
2626      return;
2627    }
2628    TRowIterator RowI = BegRI();
2629    TInt count = 1;
2630    while (count < N) {
2631      if (!(RowI < EndRI())) {
2632        return; 
2633      }
2634      RowI++;
2635      count++;
2636    }
2637    NumValidRows = N;
2638    TInt LastId = RowI.GetRowIdx();
2639    if (Next[LastId] == Last) {
2640      return; 
2641    }
2642    TInt CurrId = LastId;
2643    while (Next[CurrId] != Last) {
2644      Assert(Next[CurrId] != Invalid);
2645      TInt NextId = Next[CurrId];
2646      Next[CurrId] = Invalid;
2647      CurrId = NextId;
2648    }
2649    Next[LastId] = Last;
2650    LastValidRow = LastId;
2651  }
2652  inline void TTable::CheckAndAddIntNode(PNEANet Graph, THashSet<TInt>& NodeVals, TInt NodeId) {
2653    if (!NodeVals.IsKey(NodeId)) {
2654      Graph->AddNode(NodeId);
2655      NodeVals.AddKey(NodeId);
2656    }
2657  }
2658  inline void TTable::AddEdgeAttributes(PNEANet& Graph, int RowId) {
2659    for (TInt i = 0; i < EdgeAttrV.Len(); i++) {
2660      TStr ColName = EdgeAttrV[i];
2661      TAttrType T = GetColType(ColName);
2662      TInt Index = GetColIdx(ColName);
2663      switch (T) {
2664        case atInt:
2665          Graph->AddIntAttrDatE(RowId, IntCols[Index][RowId], ColName);
2666          break;
2667        case atFlt:
2668          Graph->AddFltAttrDatE(RowId, FltCols[Index][RowId], ColName);
2669          break;
2670        case atStr:
2671          Graph->AddStrAttrDatE(RowId, GetStrValIdx(Index, RowId), ColName);
2672          break;
2673      }
2674    }
2675  }
2676  inline void TTable::AddNodeAttributes(TInt NId, TStrV NodeAttrV, TInt RowId, THash<TInt, TStrIntVH>& NodeIntAttrs,
2677    THash<TInt, TStrFltVH>& NodeFltAttrs, THash<TInt, TStrStrVH>& NodeStrAttrs) {
2678    for (TInt i = 0; i < NodeAttrV.Len(); i++) {
2679      TStr ColAttr = NodeAttrV[i];
2680      TAttrType CT = GetColType(ColAttr);
2681      int ColId = GetColIdx(ColAttr);
2682      for (TInt i = 0; i < CommonNodeAttrs.Len(); i++) {
2683        if (CommonNodeAttrs[i].Val1 == ColAttr || CommonNodeAttrs[i].Val2 == ColAttr) {
2684          ColAttr = CommonNodeAttrs[i].Val3;
2685          break;
2686        }
2687      }
2688      if (CT == atInt) {
2689        if (!NodeIntAttrs.IsKey(NId)) { NodeIntAttrs.AddKey(NId); }
2690        if (!NodeIntAttrs.GetDat(NId).IsKey(ColAttr)) { NodeIntAttrs.GetDat(NId).AddKey(ColAttr); }
2691        NodeIntAttrs.GetDat(NId).GetDat(ColAttr).Add(IntCols[ColId][RowId]);
2692      } else if (CT == atFlt) {
2693        if (!NodeFltAttrs.IsKey(NId)) { NodeFltAttrs.AddKey(NId); }
2694        if (!NodeFltAttrs.GetDat(NId).IsKey(ColAttr)) { NodeFltAttrs.GetDat(NId).AddKey(ColAttr); }
2695        NodeFltAttrs.GetDat(NId).GetDat(ColAttr).Add(FltCols[ColId][RowId]);
2696      } else {
2697        if (!NodeStrAttrs.IsKey(NId)) { NodeStrAttrs.AddKey(NId); }
2698        if (!NodeStrAttrs.GetDat(NId).IsKey(ColAttr)) { NodeStrAttrs.GetDat(NId).AddKey(ColAttr); }
2699        NodeStrAttrs.GetDat(NId).GetDat(ColAttr).Add(GetStrValIdx(ColId, RowId));
2700      }
2701    }
2702  }
2703  PNEANet TTable::BuildGraph(const TIntV& RowIds, TAttrAggr AggrPolicy) {
2704    PNEANet Graph = TNEANet::New();
2705    const TAttrType NodeType = GetColType(SrcCol);
2706    Assert(NodeType == GetColType(DstCol));
2707    const TInt SrcColIdx = GetColIdx(SrcCol);
2708    const TInt DstColIdx = GetColIdx(DstCol);
2709    THash<TFlt, TInt> FltNodeVals;
2710    THash<TInt, TStrIntVH> NodeIntAttrs;
2711    THash<TInt, TStrFltVH> NodeFltAttrs;
2712    THash<TInt, TStrStrVH> NodeStrAttrs;
2713    for (TVec<TInt>::TIter it = RowIds.BegI(); it < RowIds.EndI(); it++) {
2714      TInt CurrRowIdx = *it;
2715      TInt SVal, DVal;
2716      if (NodeType == atFlt) {
2717        TFlt FSVal = FltCols[SrcColIdx][CurrRowIdx];
2718        SVal = CheckAndAddFltNode(Graph, FltNodeVals, FSVal);
2719        TFlt FDVal = FltCols[SrcColIdx][CurrRowIdx];
2720        DVal = CheckAndAddFltNode(Graph, FltNodeVals, FDVal);
2721      } else if (NodeType == atInt || NodeType == atStr) {
2722        if (NodeType == atInt) {
2723          SVal = IntCols[SrcColIdx][CurrRowIdx];
2724          DVal = IntCols[DstColIdx][CurrRowIdx];
2725        } else {
2726          SVal = StrColMaps[SrcColIdx][CurrRowIdx];
2727          if (strlen(Context->StringVals.GetKey(SVal)) == 0) { continue; }  
2728          DVal = StrColMaps[DstColIdx][CurrRowIdx];
2729          if (strlen(Context->StringVals.GetKey(DVal)) == 0) { continue; }  
2730        }
2731        if (!Graph->IsNode(SVal)) { Graph->AddNode(SVal); }
2732        if (!Graph->IsNode(DVal)) { Graph->AddNode(DVal); }
2733      } 
2734      Graph->AddEdge(SVal, DVal, CurrRowIdx);
2735      if (EdgeAttrV.Len() > 0) { AddEdgeAttributes(Graph, CurrRowIdx); }
2736      if (SrcNodeAttrV.Len() > 0) { 
2737        AddNodeAttributes(SVal, SrcNodeAttrV, CurrRowIdx, NodeIntAttrs, NodeFltAttrs, NodeStrAttrs);
2738      }
2739      if (DstNodeAttrV.Len() > 0) {
2740        AddNodeAttributes(DVal, DstNodeAttrV, CurrRowIdx, NodeIntAttrs, NodeFltAttrs, NodeStrAttrs);
2741      }
2742    }
2743    if (SrcNodeAttrV.Len() > 0 || DstNodeAttrV.Len() > 0) {
2744      for (TNEANet::TNodeI NodeI = Graph->BegNI(); NodeI < Graph->EndNI(); NodeI++) {
2745        TInt NId = NodeI.GetId();
2746        if (NodeIntAttrs.IsKey(NId)) {
2747          TStrIntVH IntAttrVals = NodeIntAttrs.GetDat(NId);
2748          for (TStrIntVH::TIter it = IntAttrVals.BegI(); it < IntAttrVals.EndI(); it++) {
2749            TInt AttrVal = AggregateVector<TInt>(it.GetDat(), AggrPolicy);
2750            Graph->AddIntAttrDatN(NId, AttrVal, it.GetKey());
2751          }
2752        }
2753        if (NodeFltAttrs.IsKey(NId)) {
2754          TStrFltVH FltAttrVals = NodeFltAttrs.GetDat(NId);
2755          for (TStrFltVH::TIter it = FltAttrVals.BegI(); it < FltAttrVals.EndI(); it++) {
2756            TFlt AttrVal = AggregateVector<TFlt>(it.GetDat(), AggrPolicy);
2757            Graph->AddFltAttrDatN(NId, AttrVal, it.GetKey());
2758          }
2759        }
2760        if (NodeStrAttrs.IsKey(NId)) {
2761          TStrStrVH StrAttrVals = NodeStrAttrs.GetDat(NId);
2762          for (TStrStrVH::TIter it = StrAttrVals.BegI(); it < StrAttrVals.EndI(); it++) {
2763            TStr AttrVal = AggregateVector<TStr>(it.GetDat(), AggrPolicy);
2764            Graph->AddStrAttrDatN(NId, AttrVal, it.GetKey());
2765          }
2766        }
2767      }
2768    }
2769    return Graph;
2770  }
2771  void TTable::InitRowIdBuckets(int NumBuckets) {
2772    for (TInt i = 0; i < RowIdBuckets.Len(); i++) {
2773      RowIdBuckets[i].Clr();
2774    }
2775    RowIdBuckets.Clr();
2776    RowIdBuckets.Gen(NumBuckets);
2777    for (TInt i = 0; i < NumBuckets; i++) {
2778      RowIdBuckets[i].Gen(10, 0);
2779    }
2780  }
2781  void TTable::FillBucketsByWindow(TStr SplitAttr, TInt JumpSize, TInt WindowSize, TInt StartVal, TInt EndVal) {
2782    Assert (JumpSize <= WindowSize);
2783    int NumBuckets, MinBucket, MaxBucket;
2784    TInt SplitColId = GetColIdx(SplitAttr);
2785    if (StartVal == TInt::Mn || EndVal == TInt::Mx) {
2786      TInt MinValue = TInt::Mx;
2787      TInt MaxValue = TInt::Mn;
2788      for (TInt i = 0; i < Next.Len(); i++) {
2789        if (Next[i] != Invalid) { 
2790          if (MinValue > IntCols[SplitColId][i]) {
2791            MinValue = IntCols[SplitColId][i];
2792          }
2793          if (MaxValue < IntCols[SplitColId][i]) {
2794            MaxValue = IntCols[SplitColId][i];
2795          }
2796        }
2797      }
2798      if (StartVal == TInt::Mn) StartVal = MinValue;
2799      if (EndVal == TInt::Mx) EndVal = MaxValue;
2800    }
2801    NumBuckets = 1;
2802    if (JumpSize > 0) {
2803      NumBuckets = (EndVal - StartVal)/JumpSize + 1;
2804    }
2805    InitRowIdBuckets(NumBuckets);
2806    for (TInt i = 0; i < Next.Len(); i++) {
2807      if (Next[i] == Invalid) { continue; }
2808      int SplitVal = IntCols[SplitColId][i];
2809      if (SplitVal < StartVal || SplitVal > EndVal) { continue; }
2810      int RowVal = SplitVal - StartVal;
2811      if (JumpSize == 0) { 
2812        MinBucket = RowVal/WindowSize;
2813        MaxBucket = NumBuckets-1;
2814      } else if (JumpSize == WindowSize) { 
2815        MinBucket = MaxBucket = RowVal/JumpSize;  
2816      } else { 
2817        if (RowVal < WindowSize) { MinBucket = 0; }
2818        else { MinBucket = (RowVal-WindowSize)/JumpSize + 1; }
2819        MaxBucket = RowVal/JumpSize;  
2820      }
2821      for (TInt j = MinBucket; j <= MaxBucket; j++) { RowIdBuckets[j].Add(i); }
2822    }
2823  }
2824  void TTable::FillBucketsByInterval(TStr SplitAttr, TIntPrV SplitIntervals) {
2825    TInt SplitColId = GetColIdx(SplitAttr);
2826    int NumBuckets = SplitIntervals.Len();
2827    InitRowIdBuckets(NumBuckets);
2828    for (TInt i = 0; i < Next.Len(); i++) {
2829      if (Next[i] == Invalid) { continue; }
2830      int SplitVal = IntCols[SplitColId][i];
2831      for (TInt j = 0; j < SplitIntervals.Len(); j++) { 
2832        if (SplitVal >= SplitIntervals[j].Val1 && SplitVal < SplitIntervals[j].Val2) {
2833          RowIdBuckets[j].Add(i);
2834        }
2835      }
2836    }
2837  }
2838  TVec<PNEANet> TTable::GetGraphsFromSequence(TAttrAggr AggrPolicy) {
2839    TVec<PNEANet> GraphSequence;
2840    for (TInt i = 0; i < RowIdBuckets.Len(); i++) {
2841      if (RowIdBuckets[i].Len() == 0) { continue; }
2842      PNEANet PNet = BuildGraph(RowIdBuckets[i], AggrPolicy);
2843      GraphSequence.Add(PNet);
2844    }
2845    return GraphSequence;
2846  }
2847  PNEANet TTable::GetFirstGraphFromSequence(TAttrAggr AggrPolicy) {
2848    CurrBucket = -1;
2849    this->AggrPolicy = AggrPolicy;
2850    return GetNextGraphFromSequence();
2851  }
2852  PNEANet TTable::GetNextGraphFromSequence() {
2853    CurrBucket++;
2854    while (CurrBucket < RowIdBuckets.Len() && RowIdBuckets[CurrBucket].Len() == 0) {
2855      CurrBucket++;
2856    }
2857    if (CurrBucket >= RowIdBuckets.Len()) { return NULL; }
2858    return BuildGraph(RowIdBuckets[CurrBucket], AggrPolicy);
2859  }
2860  TVec<PNEANet> TTable::ToGraphSequence(TStr SplitAttr, TAttrAggr AggrPolicy, TInt WindowSize, TInt JumpSize, TInt StartVal, TInt EndVal) {
2861    FillBucketsByWindow(SplitAttr, JumpSize, WindowSize, StartVal, EndVal);
2862    printf("buckets filled\n");
2863    return GetGraphsFromSequence(AggrPolicy);  
2864  }
2865  TVec<PNEANet> TTable::ToVarGraphSequence(TStr SplitAttr, TAttrAggr AggrPolicy, TIntPrV SplitIntervals) {
2866    FillBucketsByInterval(SplitAttr, SplitIntervals);
2867    return GetGraphsFromSequence(AggrPolicy);
2868  }
2869  TVec<PNEANet> TTable::ToGraphPerGroup(TStr GroupAttr, TAttrAggr AggrPolicy) {
2870    return ToGraphSequence(GroupAttr, AggrPolicy, TInt(1), TInt(1), TInt::Mn, TInt::Mx);
2871  }
2872  PNEANet TTable::ToGraphSequenceIterator(TStr SplitAttr, TAttrAggr AggrPolicy, TInt WindowSize, TInt JumpSize, TInt StartVal, TInt EndVal) {
2873    FillBucketsByWindow(SplitAttr, JumpSize, WindowSize, StartVal, EndVal);
2874    return GetFirstGraphFromSequence(AggrPolicy);  
2875  }
2876  PNEANet TTable::ToVarGraphSequenceIterator(TStr SplitAttr, TAttrAggr AggrPolicy, TIntPrV SplitIntervals) {
2877    FillBucketsByInterval(SplitAttr, SplitIntervals);
2878    return GetFirstGraphFromSequence(AggrPolicy);
2879  }
2880  PNEANet TTable::ToGraphPerGroupIterator(TStr GroupAttr, TAttrAggr AggrPolicy) {
2881    return ToGraphSequenceIterator(GroupAttr, AggrPolicy, TInt(1), TInt(1), TInt::Mn, TInt::Mx);
2882  }
2883  PNEANet TTable::NextGraphIterator() {
2884    return GetNextGraphFromSequence();
2885  }
2886  TBool TTable::IsLastGraphOfSequence() {
2887    return CurrBucket >= RowIdBuckets.Len() - 1;
2888  }
2889  PTable TTable::GetNodeTable(const PNEANet& Network, TTableContext* Context) {
2890    Schema SR;
2891    SR.Add(TPair<TStr,TAttrType>("node_id",atInt));
2892    TStrV IntAttrNames;
2893    TStrV FltAttrNames;
2894    TStrV StrAttrNames;
2895    TNEANet::TNodeI NodeI = Network->BegNI();
2896    NodeI.GetIntAttrNames(IntAttrNames);
2897    NodeI.GetFltAttrNames(FltAttrNames);
2898    NodeI.GetStrAttrNames(StrAttrNames);
2899    for (TInt i = 0; i < IntAttrNames.Len(); i++) {
2900      SR.Add(TPair<TStr,TAttrType>(IntAttrNames[i],atInt));
2901    }
2902    for (TInt i = 0; i < FltAttrNames.Len(); i++) {
2903      SR.Add(TPair<TStr,TAttrType>(FltAttrNames[i],atFlt));
2904    }
2905    for (TInt i = 0; i < StrAttrNames.Len(); i++) {
2906      SR.Add(TPair<TStr,TAttrType>(StrAttrNames[i],atStr));
2907    }
2908    PTable T = New(SR, Context);
2909    TInt Cnt = 0;
2910    while (NodeI < Network->EndNI()) {
2911      T->IntCols[0].Add(NodeI.GetId());
2912      for (TInt i = 0; i < IntAttrNames.Len(); i++) {
2913        T->IntCols[i+1].Add(Network->GetIntAttrDatN(NodeI,IntAttrNames[i]));
2914      }
2915      for (TInt i = 0; i < FltAttrNames.Len(); i++) {
2916        T->FltCols[i].Add(Network->GetFltAttrDatN(NodeI,FltAttrNames[i]));
2917      }
2918      for (TInt i = 0; i < StrAttrNames.Len(); i++) {
2919        T->AddStrVal(i, Network->GetStrAttrDatN(NodeI,StrAttrNames[i]));
2920      }
2921      Cnt++;
2922      NodeI++;
2923    }
2924    T->NumRows = Cnt;
2925    T->NumValidRows = T->NumRows;
2926    T->Next = TIntV(T->NumRows,0);
2927    for (TInt i = 0; i < T->NumRows-1; i++) {
2928      T->Next.Add(i+1);
2929    }
2930    T->LastValidRow = T->NumRows-1;
2931    T->Next.Add(Last);
2932    return T;
2933  }
2934  PTable TTable::GetEdgeTable(const PNEANet& Network, TTableContext* Context) {
2935    Schema SR;
2936    SR.Add(TPair<TStr,TAttrType>("edg_id",atInt));
2937    SR.Add(TPair<TStr,TAttrType>("src_id",atInt));
2938    SR.Add(TPair<TStr,TAttrType>("dst_id",atInt));
2939    TStrV IntAttrNames;
2940    TStrV FltAttrNames;
2941    TStrV StrAttrNames;
2942    TNEANet::TEdgeI EdgeI = Network->BegEI();
2943    EdgeI.GetIntAttrNames(IntAttrNames);
2944    EdgeI.GetFltAttrNames(FltAttrNames);
2945    EdgeI.GetStrAttrNames(StrAttrNames);
2946    for (TInt i = 0; i < IntAttrNames.Len(); i++) {
2947      SR.Add(TPair<TStr,TAttrType>(IntAttrNames[i],atInt));
2948    }
2949    for (TInt i = 0; i < FltAttrNames.Len(); i++) {
2950      SR.Add(TPair<TStr,TAttrType>(FltAttrNames[i],atFlt));
2951    }
2952    for (TInt i = 0; i < StrAttrNames.Len(); i++) {
2953      SR.Add(TPair<TStr,TAttrType>(StrAttrNames[i],atStr));
2954    }
2955    PTable T = New(SR, Context);
2956    TInt Cnt = 0;
2957    while (EdgeI < Network->EndEI()) {
2958      T->IntCols[0].Add(EdgeI.GetId());
2959      T->IntCols[1].Add(EdgeI.GetSrcNId());
2960      T->IntCols[2].Add(EdgeI.GetDstNId());
2961      for (TInt i = 0; i < IntAttrNames.Len(); i++) {
2962        T->IntCols[i+3].Add(Network->GetIntAttrDatE(EdgeI,IntAttrNames[i]));
2963      }
2964      for (TInt i = 0; i < FltAttrNames.Len(); i++) {
2965        T->FltCols[i].Add(Network->GetFltAttrDatE(EdgeI,FltAttrNames[i]));
2966      }
2967      for (TInt i = 0; i < StrAttrNames.Len(); i++) {
2968        T->AddStrVal(i, Network->GetStrAttrDatE(EdgeI,StrAttrNames[i]));
2969      }
2970      Cnt++;
2971      EdgeI++;
2972    }
2973    T->NumRows = Cnt;
2974    T->NumValidRows = T->NumRows;
2975    T->Next = TIntV(T->NumRows,0);
2976    for (TInt i = 0; i < T->NumRows-1; i++) {
2977      T->Next.Add(i+1);
2978    }
2979    T->LastValidRow = T->NumRows-1;
2980    T->Next.Add(Last);
2981    return T;
2982  }
2983  #ifdef GCC_ATOMIC
2984  PTable TTable::GetEdgeTablePN(const PNGraphMP& Network, TTableContext* Context){
2985    Schema SR;
2986    SR.Add(TPair<TStr,TAttrType>("src_id",atInt));
2987    SR.Add(TPair<TStr,TAttrType>("dst_id",atInt));
2988    TNGraphMP::TEdgeI FirstEI = Network->BegEI();
2989    PTable T = New(SR, Context);
2990    TInt NumEdges = Network->GetEdges();
2991    TInt NumPartitions = omp_get_max_threads()*CHUNKS_PER_THREAD;
2992    TInt PartitionSize = NumEdges/NumPartitions;
2993    if (PartitionSize*NumPartitions < NumEdges) { NumPartitions++;}
2994    typedef TPair<TNGraphMP::TEdgeI, TNGraphMP::TEdgeI> TEIPr;
2995    TVec<TEIPr> Partitions;
2996    TIntV PartitionSizes;
2997    TNGraphMP::TEdgeI currStart = FirstEI;
2998    TInt currCount = 0;
2999    while (FirstEI < Network->EndEI()){
3000      if (currCount == PartitionSize) {
3001        Partitions.Add(TEIPr(currStart, FirstEI));
3002        currStart = FirstEI;
3003        PartitionSizes.Add(currCount);
3004        currCount = 0;
3005      }
3006      FirstEI++;
3007      currCount++;
3008    }
3009    Partitions.Add(TEIPr(currStart, FirstEI));
3010    PartitionSizes.Add(currCount);
3011    T->ResizeTable(NumEdges);
3012    #pragma omp parallel for schedule(dynamic, CHUNKS_PER_THREAD)
3013    for (int p = 0; p < Partitions.Len(); p++) {
3014      TNGraphMP::TEdgeI EdgeI = Partitions[p].GetVal1();
3015      TNGraphMP::TEdgeI EndI = Partitions[p].GetVal2();
3016      int start = T->GetEmptyRowsStart(PartitionSizes[p]);
3017      while (EdgeI < EndI) {
3018        T->IntCols[0][start] = EdgeI.GetSrcNId();
3019        T->IntCols[1][start] = EdgeI.GetDstNId();
3020        EdgeI++;
3021        if (EdgeI < EndI) { T->Next[start] = start+1;}
3022        start++;
3023      }
3024    }
3025    Assert(T->NumRows == NumEdges);
3026    return T;
3027  }
3028  #endif 
3029  PTable TTable::GetFltNodePropertyTable(const PNEANet& Network, const TIntFltH& Property, 
3030   const TStr& NodeAttrName, const TAttrType& NodeAttrType, const TStr& PropertyAttrName, 
3031   TTableContext* Context) {
3032    Schema SR;
3033    SR.Add(TPair<TStr,TAttrType>(NodeAttrName,NodeAttrType));
3034    SR.Add(TPair<TStr,TAttrType>(PropertyAttrName,atFlt));
3035    PTable T = New(SR, Context);
3036    TInt NodeColIdx = T->GetColIdx(NodeAttrName);
3037    TInt Cnt = 0;
3038    for (TNEANet::TNodeI NodeI = Network->BegNI(); NodeI < Network->EndNI(); NodeI++) {
3039      switch (NodeAttrType) {
3040        case atInt:
3041          T->IntCols[NodeColIdx].Add(Network->GetIntAttrDatN(NodeI,NodeAttrName));
3042          break;
3043        case atFlt:
3044          T->FltCols[NodeColIdx].Add(Network->GetFltAttrDatN(NodeI,NodeAttrName));
3045          break;
3046        case atStr:
3047          T->AddStrVal(TInt(0), Network->GetStrAttrDatN(NodeI,NodeAttrName));
3048          break;
3049      }
3050      T->FltCols[0].Add(Property.GetDat(NodeI.GetId()));
3051      Cnt++;
3052    }
3053    T->NumRows = Cnt;
3054    T->NumValidRows = T->NumRows;
3055    T->Next = TIntV(T->NumRows,0);
3056    for (TInt i = 0; i < T->NumRows-1; i++) {
3057      T->Next.Add(i+1);
3058    }
3059    T->LastValidRow = T->NumRows-1;
3060    T->Next.Add(Last);
3061    return T;
3062  }
3063  PTable TTable::IsNextK(const TStr& OrderCol, TInt K, const TStr& GroupBy, const TStr& RankColName) {
3064    TStrV OrderBy;
3065    if (GroupBy.Empty()) {
3066      OrderBy.Add(OrderCol);
3067    } else {
3068      OrderBy.Add(GroupBy);
3069      OrderBy.Add(OrderCol);
3070    }
3071    if (RankColName.Empty()) {
3072      Order(OrderBy);
3073    } else {
3074      Order(OrderBy, RankColName, true);
3075    }
3076    TAttrType GroupByAttrType = GetColType(GroupBy);
3077    PTable T = InitializeJointTable(*this);
3078    for (TRowIterator RI = BegRI(); RI < EndRI(); RI++) {
3079      TInt Succ = RI.GetRowIdx();
3080      TBool OutOfGroup = false;
3081      for (TInt i = 0; i < K; i++) {
3082        Succ = Next[Succ];
3083        if (Succ == Last) { break; }
3084        switch (GroupByAttrType) {
3085          case atInt:
3086            if (GetIntVal(GroupBy, Succ) != RI.GetIntAttr(GroupBy)) { OutOfGroup = true; }
3087            break;
3088          case atFlt:
3089            if (GetFltVal(GroupBy, Succ) != RI.GetFltAttr(GroupBy)) { OutOfGroup = true; }
3090            break;
3091          case atStr:
3092            if (GetStrVal(GroupBy, Succ) != RI.GetStrAttr(GroupBy)) { OutOfGroup = true; }
3093            break;
3094        }
3095        if (OutOfGroup) { break; }  
3096        T->AddJointRow(*this, *this, RI.GetRowIdx(), Succ);
3097      }
3098    }
3099    return T;
3100  }
3101  void TTable::PrintSize(){
3102  	printf("Total number of rows: %d\n", NumRows.Val);
3103  	printf("Number of valid rows: %d\n", NumValidRows.Val);
3104  	printf("Number of Int columns: %d\n", IntCols.Len());
3105  	printf("Number of Flt columns: %d\n", FltCols.Len());
3106  	printf("Number of Str columns: %d\n", StrColMaps.Len());
3107  	TSize MemUsed = GetMemUsedKB();
3108  	printf("Approximate table size is %s KB\n", TUInt64::GetStr(MemUsed).CStr());
3109  }
3110  TSize TTable::GetMemUsedKB() {
3111    TSize ApproxSize = 0;
3112    ApproxSize += Next.GetMemUsed()/1000;  
3113    for(int i = 0; i < IntCols.Len(); i++){
3114    	ApproxSize += IntCols[i].GetMemUsed()/1000;
3115    }
3116    for(int i = 0; i < FltCols.Len(); i++){
3117    	ApproxSize += FltCols[i].GetMemUsed()/1000;
3118    }
3119    for(int i = 0; i < StrColMaps.Len(); i++){
3120    	ApproxSize += StrColMaps[i].GetMemUsed()/1000;
3121    }
3122    ApproxSize += RowIdMap.GetMemUsed()/1000;
3123    ApproxSize += GroupIDMapping.GetMemUsed()/1000;
3124    ApproxSize += GroupMapping.GetMemUsed()/1000;
3125    ApproxSize += RowIdBuckets.GetMemUsed() / 1000;
3126    return ApproxSize;
3127  }
3128  void TTable::PrintContextSize(){
3129  	printf("Number of strings in pool: ");
3130  	printf("%d\n", Context->StringVals.Len());
3131  	printf("Number of entries in hash table: ");
3132  	printf("%d\n", Context->StringVals.Reserved());
3133  	TSize MemUsed = GetContextMemUsedKB();
3134  	printf("Approximate context size is %s KB\n",
3135            TUInt64::GetStr(MemUsed).CStr());
3136  }
3137  TSize TTable::GetContextMemUsedKB(){
3138  	TSize ApproxSize = 0;
3139  	ApproxSize += Context->StringVals.GetMemUsed();
3140  	return ApproxSize;
3141  }
3142  void TTable::AddTable(const TTable& T) {
3143    for (TInt c = 0; c < Sch.Len(); c++) {
3144      TStr ColName = GetSchemaColName(c);
3145      TInt ColIdx = GetColIdx(ColName);
3146      TInt TColIdx = ColName == IdColName ? T.GetColIdx(T.IdColName) : T.GetColIdx(ColName);
3147      if (TColIdx < 0) { TExcept::Throw("when adding a table, it must contain all columns of source table!"); }
3148      switch (GetColType(ColName)) { 
3149      case atInt:
3150         IntCols[ColIdx].AddV(T.IntCols[TColIdx]);
3151         break;
3152      case atFlt:
3153         FltCols[ColIdx].AddV(T.FltCols[TColIdx]);
3154         break;
3155      case atStr:
3156         StrColMaps[ColIdx].AddV(T.StrColMaps[TColIdx]);
3157         break;
3158      }
3159    }
3160    TIntV TNext(T.Next);
3161    for (TInt i = 0; i < TNext.Len(); i++) {
3162      if (TNext[i] != Last && TNext[i] != Invalid) { TNext[i] += NumRows; }
3163    }
3164    Next.AddV(TNext);
3165    if (LastValidRow >= 0) {
3166      Next[LastValidRow] = NumRows + T.FirstValidRow;
3167    }
3168    LastValidRow = NumRows + T.LastValidRow;
3169    NumRows += T.NumRows;
3170    NumValidRows += T.NumValidRows;
3171  }
3172  void TTable::GetCollidingRows(const TTable& Table, THashSet<TInt>& Collisions) {
3173    TIntV UniqueVec;
3174    THash<TGroupKey, TPair<TInt, TIntV> >Grouping;
3175    TStrV GroupBy;
3176    TIntV IntGroupByCols;
3177    TIntV FltGroupByCols;
3178    TIntV StrGroupByCols;
3179    TInt IKLen, FKLen, SKLen;
3180    for (TInt c = 0; c < Sch.Len(); c++) {
3181      if (Sch[c].Val1 == IdColName) {
3182        if (Table.Sch[c].Val1 != Table.GetIdColName()) {
3183          TExcept::Throw("GetCollidingRows: schemas do not match!");
3184        }
3185        continue;
3186      }
3187      if (Sch[c] != Table.Sch[c]) {
3188        printf("(%s,%d) != (%s,%d)\n", Sch[c].Val1.CStr(), Sch[c].Val2, Table.Sch[c].Val1.CStr(), Table.Sch[c].Val2); 
3189        TExcept::Throw("GetCollidingRows: schemas do not match!");
3190      }
3191      GroupBy.Add(NormalizeColName(Sch[c].Val1));
3192      TPair<TAttrType, TInt> ColType = Table.GetColTypeMap(Sch[c].Val1);
3193      switch (ColType.Val1) {
3194        case atInt:
3195          IntGroupByCols.Add(ColType.Val2);
3196          break;
3197        case atFlt:
3198          FltGroupByCols.Add(ColType.Val2);
3199          break;
3200        case atStr:
3201          StrGroupByCols.Add(ColType.Val2);
3202          break;
3203      }
3204    }
3205    IKLen = IntGroupByCols.Len();
3206    FKLen = FltGroupByCols.Len();
3207    SKLen = StrGroupByCols.Len();
3208    GroupAux(GroupBy, Grouping, true, "", false, UniqueVec, true);
3209    for (TRowIterator it = Table.BegRI(); it < Table.EndRI(); it++) {
3210      TIntV IKey(IKLen + SKLen, 0);
3211      TFltV FKey(FKLen, 0);
3212      for (TInt c = 0; c < IKLen; c++) {
3213        IKey.Add(it.GetIntAttr(IntGroupByCols[c])); 
3214      }
3215      for (TInt c = 0; c < FKLen; c++) {
3216        FKey.Add(it.GetFltAttr(FltGroupByCols[c])); 
3217      }
3218      for (TInt c = 0; c < SKLen; c++) {
3219        IKey.Add(it.GetStrMapById(StrGroupByCols[c])); 
3220      }
3221      TGroupKey GroupKey = TGroupKey(IKey, FKey);
3222      TInt RowIdx = it.GetRowIdx();
3223      if (Grouping.IsKey(GroupKey)) {
3224        Collisions.AddKey(RowIdx);
3225      }
3226    }
3227  }
3228  void TTable::StoreIntCol(const TStr& ColName, const TIntV& ColVals) {
3229    if (ColVals.Len() != NumRows) {
3230      printf("new column dimension must agree with number of rows\n");
3231      return;
3232    }
3233    AddSchemaCol(ColName, atInt);
3234    IntCols.Add(TIntV(NumRows));
3235    TInt ColIdx = IntCols.Len()-1;
3236    TInt i = 0;
3237    for (TRowIterator RI = BegRI(); RI < EndRI(); RI++) {
3238      IntCols[ColIdx][RI.GetRowIdx()] = ColVals[i];
3239      i++;
3240    }
3241    TInt L = IntCols.Len();
3242    AddColType(ColName, atInt, L-1);
3243  }
3244  void TTable::StoreFltCol(const TStr& ColName, const TFltV& ColVals) {
3245    if (ColVals.Len() != NumRows) {
3246      printf("new column dimension must agree with number of rows\n");
3247      return;
3248    }
3249    AddSchemaCol(ColName, atFlt);
3250    FltCols.Add(TFltV(NumRows));
3251    TInt ColIdx = FltCols.Len()-1;
3252    TInt i = 0;
3253    for (TRowIterator RI = BegRI(); RI < EndRI(); RI++) {
3254      FltCols[ColIdx][RI.GetRowIdx()] = ColVals[i];
3255      i++;
3256    }
3257    TInt L = FltCols.Len();
3258    AddColType(ColName, atFlt, L-1);
3259  }
3260  void TTable::StoreStrCol(const TStr& ColName, const TStrV& ColVals) {
3261    if (ColVals.Len() != NumRows) {
3262      printf("new column dimension must agree with number of rows\n");
3263      return;
3264    }
3265    AddSchemaCol(ColName, atStr);
3266    StrColMaps.Add(TIntV(NumRows,0));
3267    TInt ColIdx = FltCols.Len()-1;
3268    TInt i = 0;
3269    for (TRowIterator RI = BegRI(); RI < EndRI(); RI++) {
3270      TInt Key = Context->StringVals.GetKeyId(ColVals[i]);
3271      if (Key == -1) { Context->StringVals.AddKey(ColVals[i]); }
3272      StrColMaps[ColIdx][RI.GetRowIdx()] = Key;
3273      i++;
3274    }
3275    TInt L = StrColMaps.Len();
3276    AddColType(ColName, atStr, L-1);
3277  }
3278  void TTable::UpdateTableForNewRow() {
3279    if (LastValidRow >= 0) {
3280      Next[LastValidRow] = NumRows;
3281    }
3282    Next.Add(Last);
3283    LastValidRow = NumRows;
3284    NumRows++;
3285    NumValidRows++;
3286  }
3287  #ifdef GCC_ATOMIC
3288  void TTable::SetFltColToConstMP(TInt UpdateColIdx, TFlt DefaultFltVal){
3289      if(!GetMP()){ TExcept::Throw("Not Using MP!");}
3290  	TIntPrV Partitions;
3291  	GetPartitionRanges(Partitions, omp_get_max_threads()*CHUNKS_PER_THREAD);
3292  	TInt PartitionSize = Partitions[0].GetVal2()-Partitions[0].GetVal1()+1;
3293  	#pragma omp parallel for schedule(dynamic, CHUNKS_PER_THREAD)
3294  	for (int i = 0; i < Partitions.Len(); i++){
3295  		TRowIterator RowI(Partitions[i].GetVal1(), this);
3296  		TRowIterator EndI(Partitions[i].GetVal2(), this);
3297  		while(RowI < EndI){
3298  			FltCols[UpdateColIdx][RowI.GetRowIdx()] = DefaultFltVal;
3299  			RowI++;
3300  		}
3301  	}
3302  }
3303  int sync_bool_compare_and_swap(int *lock) {
3304    return(__sync_bool_compare_and_swap(lock, 0, 1));
3305  }
3306  void TTable::UpdateFltFromTableMP(const TStr& KeyAttr, const TStr& UpdateAttr,
3307      const TTable& Table, const TStr& FKeyAttr, const TStr& ReadAttr,
3308      TFlt DefaultFltVal) {
3309  	if (!GetMP()) {
3310      TExcept::Throw("Not Using MP!");
3311    }
3312    TAttrType KeyType = GetColType(KeyAttr);
3313    TAttrType FKeyType = Table.GetColType(FKeyAttr);
3314    if(KeyType != FKeyType){TExcept::Throw("Key Type Mismatch");}
3315    if(GetColType(UpdateAttr) != atFlt || Table.GetColType(ReadAttr) != atFlt){
3316      TExcept::Throw("Expecting Float values");
3317    }
3318    TStr NKeyAttr = NormalizeColName(KeyAttr);
3319    TInt UpdateColIdx = GetColIdx(UpdateAttr);
3320    TInt FKeyColIdx = GetColIdx(FKeyAttr);
3321    TInt ReadColIdx = GetColIdx(ReadAttr);
3322    SetFltColToConstMP(UpdateColIdx, DefaultFltVal);
3323  	TIntPrV Partitions;
3324  	Table.GetPartitionRanges(Partitions, omp_get_max_threads()*CHUNKS_PER_THREAD);
3325  	TInt PartitionSize = Partitions[0].GetVal2()-Partitions[0].GetVal1()+1;
3326  	TIntV Locks(NumRows);
3327  	Locks.PutAll(0);	
3328    switch (KeyType) {
3329      case atInt: {
3330          THashMP<TInt,TIntV> Grouping;
3331          GroupByIntColMP(NKeyAttr, Grouping, true);
3332          #pragma omp parallel for schedule(dynamic, CHUNKS_PER_THREAD) 
3333  			  for (int i = 0; i < Partitions.Len(); i++) {
3334  				  TRowIterator RowI(Partitions[i].GetVal1(), &Table);
3335  				  TRowIterator EndI(Partitions[i].GetVal2(), &Table);
3336  				  while (RowI < EndI) {
3337              TInt K = RowI.GetIntAttr(FKeyColIdx);
3338              if (Grouping.IsKey(K)) {
3339                TIntV& UpdateRows = Grouping.GetDat(K);
3340                for (int j = 0; j < UpdateRows.Len(); j++) {
3341                  int* lock = &Locks[UpdateRows[j]].Val;
3342                  if (!sync_bool_compare_and_swap(lock)) {
3343                    continue;
3344                  }
3345    							  FltCols[UpdateColIdx][UpdateRows[j]] = RowI.GetFltAttr(ReadColIdx);
3346                } 
3347              } 
3348              RowI++;
3349            } 
3350          }	
3351        } 
3352        break;
3353      default:
3354        break;
3355    } 
3356  }
3357  #endif	
3358  void TTable::UpdateFltFromTable(const TStr& KeyAttr, const TStr& UpdateAttr, const TTable& Table, 
3359    const TStr& FKeyAttr, const TStr& ReadAttr, TFlt DefaultFltVal){
3360    if(!IsColName(KeyAttr)){ TExcept::Throw("Bad KeyAttr parameter");}
3361    if(!IsColName(UpdateAttr)){ TExcept::Throw("Bad UpdateAttr parameter");}
3362    if(!Table.IsColName(FKeyAttr)){ TExcept::Throw("Bad FKeyAttr parameter");}
3363    if(!Table.IsColName(ReadAttr)){ TExcept::Throw("Bad ReadAttr parameter");}
3364  #ifdef GCC_ATOMIC
3365    if(GetMP()){
3366      UpdateFltFromTableMP(KeyAttr, UpdateAttr,Table, FKeyAttr, ReadAttr, DefaultFltVal);
3367      return;
3368    }
3369  #endif	
3370    TAttrType KeyType = GetColType(KeyAttr);
3371    TAttrType FKeyType = Table.GetColType(FKeyAttr);
3372    if(KeyType != FKeyType){TExcept::Throw("Key Type Mismatch");}
3373    if(GetColType(UpdateAttr) != atFlt || Table.GetColType(ReadAttr) != atFlt){
3374      TExcept::Throw("Expecting Float values");
3375    }
3376    TStr NKeyAttr = NormalizeColName(KeyAttr);
3377    TStr NUpdateAttr = NormalizeColName(UpdateAttr);
3378    TStr NFKeyAttr = Table.NormalizeColName(FKeyAttr);
3379    TStr NReadAttr = Table.NormalizeColName(ReadAttr);
3380    TInt UpdateColIdx = GetColIdx(UpdateAttr);
3381    for(TRowIterator iter = BegRI(); iter < EndRI(); iter++){
3382      FltCols[UpdateColIdx][iter.GetRowIdx()] = DefaultFltVal;
3383    }
3384    switch(KeyType) {
3385      case atInt: {
3386          TIntIntVH Grouping;
3387          GroupByIntCol(NKeyAttr, Grouping, TIntV(), true, true);
3388          for (TRowIterator RI = Table.BegRI(); RI < Table.EndRI(); RI++) {
3389            TInt K = RI.GetIntAttr(NFKeyAttr);
3390            if (Grouping.IsKey(K)) {
3391              TIntV& UpdateRows = Grouping.GetDat(K);
3392              for (int i = 0; i < UpdateRows.Len(); i++) {
3393                FltCols[UpdateColIdx][UpdateRows[i]] = RI.GetFltAttr(NReadAttr);
3394              } 
3395            } 
3396          } 
3397        } 
3398        break;
3399      default:
3400        break;
3401    } 
3402  }
3403  void TTable::AddRowI(const TRowIterator& RI) {
3404    for (TInt c = 0; c < Sch.Len(); c++) {
3405      TStr ColName = GetSchemaColName(c);
3406      if (ColName == IdColName) { continue; }
3407      TInt ColIdx = GetColIdx(ColName);
3408      switch (GetColType(ColName)) {
3409      case atInt:
3410         IntCols[ColIdx].Add(RI.GetIntAttr(ColName));
3411         break;
3412      case atFlt:
3413         FltCols[ColIdx].Add(RI.GetFltAttr(ColName));
3414         break;
3415      case atStr:
3416         StrColMaps[ColIdx].Add(RI.GetStrMapByName(ColName));
3417         break;
3418      }
3419    }
3420    UpdateTableForNewRow();
3421  }
3422  void TTable::AddRowV(const TIntV& IntVals, const TFltV& FltVals, const TStrV& StrVals) {
3423    for (TInt c = 0; c < IntVals.Len(); c++) {
3424      IntCols[c].Add(IntVals[c]);
3425    }
3426    for (TInt c = 0; c < FltVals.Len(); c++) {
3427      FltCols[c].Add(FltVals[c]);
3428    }
3429    for (TInt c = 0; c < StrVals.Len(); c++) {
3430      AddStrVal(c, StrVals[c]);
3431    }
3432    UpdateTableForNewRow();
3433  }
3434  void TTable::ResizeTable(int RowCount) {
3435    if (RowCount == 0) {
3436      NumValidRows = 0;
3437      FirstValidRow = TTable::Invalid;
3438      LastValidRow = TTable::Invalid;
3439    }
3440    if (Next.Len() < RowCount) {
3441      TInt FltOffset = IntCols.Len();
3442      TInt StrOffset = FltOffset + FltCols.Len();
3443      TInt TotalCols = StrOffset + StrColMaps.Len();
3444  #ifdef USE_OPENMP
3445      #pragma omp parallel for schedule(static)
3446  #endif
3447      for (int i = 0; i < TotalCols+1; i++) {
3448        if (i < FltOffset) {
3449          IntCols[i].Reserve(RowCount, RowCount); 
3450        } else if (i < StrOffset) {
3451          FltCols[i-FltOffset].Reserve(RowCount, RowCount);
3452        } else if (i < TotalCols) {
3453          StrColMaps[i-StrOffset].Reserve(RowCount, RowCount);  
3454        } else {
3455          Next.Reserve(RowCount, RowCount);    
3456        }
3457      }
3458    } else if (Next.Len() > RowCount) {
3459      TInt FltOffset = IntCols.Len();
3460      TInt StrOffset = FltOffset + FltCols.Len();
3461      TInt TotalCols = StrOffset + StrColMaps.Len();
3462  #ifdef USE_OPENMP
3463      #pragma omp parallel for schedule(static)
3464  #endif
3465      for (int i = 0; i < TotalCols+1; i++) {
3466        if (i < FltOffset) {
3467          IntCols[i].Trunc(RowCount); 
3468        } else if (i < StrOffset) {
3469          FltCols[i-FltOffset].Trunc(RowCount); 
3470        } else if (i < TotalCols) {
3471          StrColMaps[i-StrOffset].Trunc(RowCount); 
3472        } else {
3473          Next.Trunc(RowCount); 
3474        }
3475      }
3476    }
3477  }
3478  int TTable::GetEmptyRowsStart(int NewRows) {
3479    int start = -1;
3480  #ifdef USE_OPENMP
3481    #pragma omp critical
3482    {
3483  #endif
3484      start = NumRows;
3485      NumRows += NewRows;
3486      NumValidRows += NewRows;
3487      Assert(NumRows <= Next.Len());
3488      if (LastValidRow >= 0) {Next[LastValidRow] = start;}
3489      LastValidRow = start+NewRows-1;
3490      Next[LastValidRow] = Last;
3491  #ifdef USE_OPENMP
3492    }
3493  #endif
3494    Assert (start >= 0);
3495    return start;
3496  }
3497  void TTable::AddSelectedRows(const TTable& Table, const TIntV& RowIDs) {
3498    int NewRows = RowIDs.Len();
3499    if (NewRows == 0) { return; }
3500    int start = GetEmptyRowsStart(NewRows);
3501    for (TInt r = 0; r < NewRows; r++) {
3502      TInt CurrRowIdx = RowIDs[r];
3503      for (TInt i = 0; i < Table.IntCols.Len(); i++) {
3504        IntCols[i][start+r] = Table.IntCols[i][CurrRowIdx];
3505      }
3506      for (TInt i = 0; i < Table.FltCols.Len(); i++) {
3507        FltCols[i][start+r] = Table.FltCols[i][CurrRowIdx];
3508      }
3509      for (TInt i = 0; i < Table.StrColMaps.Len(); i++) {
3510        StrColMaps[i][start+r] = Table.StrColMaps[i][CurrRowIdx];
3511      }
3512    }
3513    for (TInt r = 0; r < NewRows-1; r++) {
3514      Next[start+r] = start+r+1;
3515    }
3516  }  
3517  void TTable::AddNRows(int NewRows, const TVec<TIntV>& IntColsP, const TVec<TFltV>& FltColsP, const TVec<TIntV>& StrColMapsP) {
3518    if (NewRows == 0) { return; }
3519    int start = GetEmptyRowsStart(NewRows);
3520    for (TInt r = 0; r < NewRows; r++) {
3521      for (TInt i = 0; i < IntColsP.Len(); i++) {
3522        IntCols[i][start+r] = IntColsP[i][r];
3523      }
3524      for (TInt i = 0; i < FltColsP.Len(); i++) {
3525        FltCols[i][start+r] = FltColsP[i][r];
3526      }
3527      for (TInt i = 0; i < StrColMapsP.Len(); i++) {
3528        StrColMaps[i][start+r] = StrColMapsP[i][r];
3529      }
3530    }
3531    for (TInt r = 0; r < NewRows-1; r++) {
3532      Next[start+r] = start+r+1;
3533    }
3534  }
3535  #ifdef USE_OPENMP
3536  void TTable::AddNJointRowsMP(const TTable& T1, const TTable& T2, const TVec<TIntPrV>& JointRowIDSet) {
3537    int JointTableSize = 0;
3538    TIntV StartOffsets(JointRowIDSet.Len());
3539    for (int i = 0; i < JointRowIDSet.Len(); i++) {
3540      StartOffsets[i] = JointTableSize;
3541      JointTableSize += JointRowIDSet[i].Len();
3542    }
3543    if (JointTableSize == 0) {
3544      TExcept::Throw("Joint table is empty");
3545    }
3546    ResizeTable(JointTableSize);
3547    NumRows = JointTableSize;
3548    NumValidRows = JointTableSize;
3549    Assert(NumRows <= Next.Len());
3550    TInt IntOffset = T1.IntCols.Len();
3551    TInt FltOffset = T1.FltCols.Len();
3552    TInt StrOffset = T1.StrColMaps.Len();
3553    TInt IdOffset = IntOffset + T2.IntCols.Len();
3554    RowIdMap.Clr();
3555    for (TInt IdCnt = 0; IdCnt < JointTableSize; IdCnt++) {
3556      RowIdMap.AddDat(IdCnt, IdCnt);
3557    }
3558    #pragma omp parallel for schedule(dynamic, CHUNKS_PER_THREAD) 
3559    for (int j = 0; j < JointRowIDSet.Len(); j++) {
3560      const TIntPrV& RowIDs = JointRowIDSet[j];
3561      int start = StartOffsets[j];
3562      int NewRows = RowIDs.Len();
3563      if (NewRows == 0) {continue;}
3564      for (TInt r = 0; r < NewRows; r++){
3565        TIntPr CurrRowIdPr = RowIDs[r]; 
3566        for(TInt i = 0; i < T1.IntCols.Len(); i++){
3567          IntCols[i][start+r] = T1.IntCols[i][CurrRowIdPr.GetVal1()];
3568        }
3569        for(TInt i = 0; i < T1.FltCols.Len(); i++){
3570          FltCols[i][start+r] = T1.FltCols[i][CurrRowIdPr.GetVal1()];
3571        }
3572        for(TInt i = 0; i < T1.StrColMaps.Len(); i++){
3573          StrColMaps[i][start+r] = T1.StrColMaps[i][CurrRowIdPr.GetVal1()];
3574        }
3575        for(TInt i = 0; i < T2.IntCols.Len(); i++){
3576          IntCols[i+IntOffset][start+r] = T2.IntCols[i][CurrRowIdPr.GetVal2()];
3577        }
3578        for(TInt i = 0; i < T2.FltCols.Len(); i++){
3579          FltCols[i+FltOffset][start+r] = T2.FltCols[i][CurrRowIdPr.GetVal2()];
3580        }
3581        for(TInt i = 0; i < T2.StrColMaps.Len(); i++){
3582          StrColMaps[i+StrOffset][start+r] = T2.StrColMaps[i][CurrRowIdPr.GetVal2()];
3583        }
3584        IntCols[IdOffset][start+r] = start+r;
3585      }
3586      for(TInt r = 0; r < NewRows; r++){
3587        Next[start+r] = start+r+1;
3588      }
3589    }      
3590    LastValidRow = JointTableSize-1;
3591    Next[LastValidRow] = Last;
3592  }
3593  #endif 
3594  PTable TTable::UnionAll(const TTable& Table) {
3595    Schema NewSchema;
3596    for (TInt c = 0; c < Sch.Len(); c++) {
3597      if (Sch[c].Val1 != GetIdColName()) {
3598        NewSchema.Add(TPair<TStr,TAttrType>(Sch[c].Val1, Sch[c].Val2));
3599      }
3600    }
3601    PTable result = TTable::New(NewSchema, Context);
3602    result->AddTable(*this);
3603    result->UnionAllInPlace(Table);
3604    return result;
3605  }
3606  void TTable::UnionAllInPlace(const TTable& Table) {
3607    AddTable(Table);
3608  }
3609  PTable TTable::Union(const TTable& Table) {
3610    Schema NewSchema;
3611    THashSet<TInt> Collisions;
3612    TStrV ColNames;
3613    for (TInt c = 0; c < Sch.Len(); c++) {
3614      if (Sch[c].Val1 != GetIdColName()) {
3615        NewSchema.Add(TPair<TStr,TAttrType>(Sch[c].Val1, Sch[c].Val2));
3616        ColNames.Add(Sch[c].Val1);
3617      }
3618    }
3619    PTable result = TTable::New(NewSchema, Context);
3620    GetCollidingRows(Table, Collisions); 
3621    result->AddTable(*this);
3622    result->Unique(ColNames);
3623    for (TRowIterator it = Table.BegRI(); it < Table.EndRI(); it++) {
3624      if (!Collisions.IsKey(it.GetRowIdx())) {
3625        result->AddRowI(it);
3626      }
3627    }
3628    result->InitIds();
3629    return result;
3630  }
3631  PTable TTable::Intersection(const TTable& Table) {
3632    Schema NewSchema;
3633    THashSet<TInt> Collisions;
3634    for (TInt c = 0; c < Sch.Len(); c++) {
3635      if (Sch[c].Val1 != GetIdColName()) {
3636        NewSchema.Add(TPair<TStr,TAttrType>(Sch[c].Val1, Sch[c].Val2));
3637      }
3638    }
3639    PTable result = TTable::New(NewSchema, Context);
3640    GetCollidingRows(Table, Collisions);
3641    for (TRowIterator it = Table.BegRI(); it < Table.EndRI(); it++) {
3642      if (Collisions.IsKey(it.GetRowIdx())) {
3643        result->AddRowI(it);
3644      }
3645    }
3646    result->InitIds();
3647    return result;
3648  }
3649  PTable TTable::Minus(TTable& Table) {
3650    Schema NewSchema;
3651    THashSet<TInt> Collisions;
3652    for (TInt c = 0; c < Sch.Len(); c++) {
3653      if (Sch[c].Val1 != GetIdColName()) {
3654        NewSchema.Add(TPair<TStr,TAttrType>(Sch[c].Val1, Sch[c].Val2));
3655      }
3656    }
3657    PTable result = TTable::New(NewSchema, Context);
3658    Table.GetCollidingRows(*this, Collisions);
3659    for (TRowIterator it = BegRI(); it < EndRI(); it++) {
3660      if (!Collisions.IsKey(it.GetRowIdx())) {
3661        result->AddRowI(it);
3662      }
3663    }
3664    result->InitIds();
3665    return result;
3666  }
3667  PTable TTable::Project(const TStrV& ProjectCols) {
3668    Schema NewSchema;
3669    for (TInt c = 0; c < ProjectCols.Len(); c++) {
3670      if (!IsColName(ProjectCols[c])) { TExcept::Throw("no such column " + ProjectCols[c]); }
3671      NewSchema.Add(TPair<TStr,TAttrType>(ProjectCols[c], GetColType(ProjectCols[c])));
3672    }
3673    PTable result = TTable::New(NewSchema, Context);
3674    result->AddTable(*this);
3675    result->InitIds();
3676    return result;
3677  }
3678  TBool TTable::IsAttr(const TStr& Attr) {
3679    return IsColName(Attr);
3680  }
3681  TStr TTable::RenumberColName(const TStr& ColName) const {
3682    TStr NColName = ColName;
3683    if (NColName.GetCh(NColName.Len()-2) == '-') { 
3684      NColName = NColName.GetSubStr(0,NColName.Len()-3); 
3685    }
3686    TInt Conflicts = 0;
3687    for (TInt i = 0; i < Sch.Len(); i++) {
3688      if (NColName == Sch[i].Val1.GetSubStr(0, Sch[i].Val1.Len()-3)) {
3689        Conflicts++;
3690      }
3691    }
3692    Conflicts++;
3693    NColName = NColName + "-" + Conflicts.GetStr();
3694    return NColName;
3695  }
3696  TStr TTable::DenormalizeColName(const TStr& ColName) const {
3697    TStr DColName = ColName;
3698    if (DColName.Len() == 0) { return DColName; }
3699    if (DColName.GetCh(0) == '_') { return DColName; }
3700    if (DColName.GetCh(DColName.Len()-2) == '-') { 
3701      DColName = DColName.GetSubStr(0,DColName.Len()-3); 
3702    }
3703    TInt Conflicts = 0;
3704    for (TInt i = 0; i < Sch.Len(); i++) {
3705      if (DColName == Sch[i].Val1.GetSubStr(0, Sch[i].Val1.Len()-3)) {
3706        Conflicts++;
3707      }
3708    }
3709    if (Conflicts > 1) { return ColName; } 
3710    else { return DColName; }
3711  }
3712  Schema TTable::DenormalizeSchema() const {
3713    Schema DSch;
3714    for (TInt i = 0; i < Sch.Len(); i++) {
3715      DSch.Add(TPair<TStr, TAttrType>(DenormalizeColName(Sch[i].Val1), Sch[i].Val2));
3716    }
3717    return DSch;
3718  }
3719  void TTable::AddIntCol(const TStr& ColName) {
3720    AddSchemaCol(ColName, atInt);
3721    IntCols.Add(TIntV(NumRows));
3722    TInt L = IntCols.Len();
3723    AddColType(ColName, atInt, L-1);
3724  }
3725  void TTable::AddFltCol(const TStr& ColName) {
3726    AddSchemaCol(ColName, atFlt);
3727    FltCols.Add(TFltV(NumRows));
3728    TInt L = FltCols.Len();
3729    AddColType(ColName, atFlt, L-1);
3730  }
3731  void TTable::AddStrCol(const TStr& ColName) {
3732    AddSchemaCol(ColName, atStr);
3733    StrColMaps.Add(TIntV(NumRows));
3734    TInt L = StrColMaps.Len();
3735    AddColType(ColName, atStr, L-1);
3736  }
3737  void TTable::ClassifyAux(const TIntV& SelectedRows, const TStr& LabelName, const TInt& PositiveLabel, const TInt& NegativeLabel) {
3738    AddSchemaCol(LabelName, atInt);
3739    TInt LabelColIdx = IntCols.Len();
3740    AddColType(LabelName, atInt, LabelColIdx);
3741    IntCols.Add(TIntV(NumRows));
3742    for (TInt i = 0; i < NumRows; i++) {
3743      IntCols[LabelColIdx][i] = NegativeLabel;
3744    }
3745    for (TInt i = 0; i < SelectedRows.Len(); i++) {
3746      IntCols[LabelColIdx][SelectedRows[i]] = PositiveLabel;
3747    }
3748  }
3749  #ifdef USE_OPENMP
3750  void TTable::ColGenericOpMP(TInt ArgColIdx1, TInt ArgColIdx2, TAttrType ArgType1, TAttrType ArgType2, TInt ResColIdx, TArithOp op){
3751  	TAttrType ResType = atFlt;
3752  	if(ArgType1 == atInt && ArgType2 == atInt){ ResType = atInt;}
3753  	TIntPrV Partitions;
3754  	GetPartitionRanges(Partitions, omp_get_max_threads()*CHUNKS_PER_THREAD);
3755  	TInt PartitionSize = Partitions[0].GetVal2()-Partitions[0].GetVal1()+1;
3756  	#pragma omp parallel for schedule(dynamic, CHUNKS_PER_THREAD)
3757  	for (int i = 0; i < Partitions.Len(); i++){
3758  		TRowIterator RowI(Partitions[i].GetVal1(), this);
3759  		TRowIterator EndI(Partitions[i].GetVal2(), this);
3760  		while(RowI < EndI){
3761  			if(ResType == atInt){
3762  				TInt V1 = RowI.GetIntAttr(ArgColIdx1);
3763  				TInt V2 = RowI.GetIntAttr(ArgColIdx2);
3764  				if (op == aoAdd) { IntCols[ResColIdx][RowI.GetRowIdx()] = V1 + V2; }
3765        			if (op == aoSub) { IntCols[ResColIdx][RowI.GetRowIdx()] = V1 - V2; }
3766        			if (op == aoMul) { IntCols[ResColIdx][RowI.GetRowIdx()] = V1 * V2; }
3767        			if (op == aoDiv) { IntCols[ResColIdx][RowI.GetRowIdx()] = V1 / V2; }
3768        			if (op == aoMod) { IntCols[ResColIdx][RowI.GetRowIdx()] = V1 % V2; }
3769        			if (op == aoMin) { IntCols[ResColIdx][RowI.GetRowIdx()] = (V1 < V2) ? V1 : V2;}
3770        			if (op == aoMax) { IntCols[ResColIdx][RowI.GetRowIdx()] = (V1 > V2) ? V1 : V2;}
3771  			} else{
3772  			    TFlt V1 = (ArgType1 == atInt) ? (TFlt)RowI.GetIntAttr(ArgColIdx1) : RowI.GetFltAttr(ArgColIdx1);
3773  			    TFlt V2 = (ArgType2 == atInt) ? (TFlt)RowI.GetIntAttr(ArgColIdx2) : RowI.GetFltAttr(ArgColIdx2);
3774  				if (op == aoAdd) { FltCols[ResColIdx][RowI.GetRowIdx()] = V1 + V2; }
3775        			if (op == aoSub) { FltCols[ResColIdx][RowI.GetRowIdx()] = V1 - V2; }
3776        			if (op == aoMul) { FltCols[ResColIdx][RowI.GetRowIdx()] = V1 * V2; }
3777        			if (op == aoDiv) { FltCols[ResColIdx][RowI.GetRowIdx()] = V1 / V2; }
3778        			if (op == aoMod) { TExcept::Throw("Cannot find modulo for float columns");  }
3779        			if (op == aoMin) { FltCols[ResColIdx][RowI.GetRowIdx()] = (V1 < V2) ? V1 : V2;}
3780        			if (op == aoMax) { FltCols[ResColIdx][RowI.GetRowIdx()] = (V1 > V2) ? V1 : V2;}
3781  			}
3782  			RowI++;
3783  		}
3784  	}
3785  }
3786  #endif	
3787  void TTable::ColGenericOp(const TStr& Attr1, const TStr& Attr2, const TStr& ResAttr, TArithOp op) {
3788    if (!IsAttr(Attr1)) TExcept::Throw("No attribute present: " + Attr1);
3789    if (!IsAttr(Attr2)) TExcept::Throw("No attribute present: " + Attr2);
3790    TPair<TAttrType, TInt> Info1 = GetColTypeMap(Attr1);
3791    TPair<TAttrType, TInt> Info2 = GetColTypeMap(Attr2);
3792    TAttrType Arg1Type = Info1.Val1;
3793    TAttrType Arg2Type = Info2.Val1;
3794    if (Arg1Type == atStr || Arg2Type == atStr) {
3795      TExcept::Throw("Only numeric columns supported in arithmetic operations.");
3796    }
3797    if(Arg1Type == atInt && Arg2Type == atFlt && ResAttr == ""){
3798    	TExcept::Throw("Trying to write float values to an existing int-typed column");
3799    }
3800    TInt ColIdx1 = Info1.Val2;
3801    TInt ColIdx2 = Info2.Val2;
3802    TInt ColIdx3 = ColIdx1;
3803    if (ResAttr != "") {
3804        if (Arg1Type == atInt && Arg2Type == atInt) {
3805            AddIntCol(ResAttr);
3806        }
3807        else {
3808            AddFltCol(ResAttr);
3809        }
3810        ColIdx3 = GetColIdx(ResAttr);
3811    }
3812  #ifdef USE_OPENMP
3813    if(GetMP()){
3814    	ColGenericOpMP(ColIdx1, ColIdx2, Arg1Type, Arg2Type, ColIdx3, op);
3815    	return;
3816    }
3817  #endif	
3818    TAttrType ResType = atFlt;
3819    if(Arg1Type == atInt && Arg2Type == atInt){ printf("hooray!\n"); ResType = atInt;}
3820    for (TRowIterator RowI = BegRI(); RowI < EndRI(); RowI++) {
3821  		if(ResType == atInt){
3822  			TInt V1 = RowI.GetIntAttr(ColIdx1);
3823  			TInt V2 = RowI.GetIntAttr(ColIdx2);
3824  			if (op == aoAdd) { IntCols[ColIdx3][RowI.GetRowIdx()] = V1 + V2; }
3825        		if (op == aoSub) { IntCols[ColIdx3][RowI.GetRowIdx()] = V1 - V2; }
3826        		if (op == aoMul) { IntCols[ColIdx3][RowI.GetRowIdx()] = V1 * V2; }
3827        		if (op == aoDiv) { IntCols[ColIdx3][RowI.GetRowIdx()] = V1 / V2; }
3828        		if (op == aoMod) { IntCols[ColIdx3][RowI.GetRowIdx()] = V1 % V2; }
3829        		if (op == aoMin) { IntCols[ColIdx3][RowI.GetRowIdx()] = (V1 < V2) ? V1 : V2;}
3830        		if (op == aoMax) { IntCols[ColIdx3][RowI.GetRowIdx()] = (V1 > V2) ? V1 : V2;}
3831  		} else{
3832  			TFlt V1 = (Arg1Type == atInt) ? (TFlt)RowI.GetIntAttr(ColIdx1) : RowI.GetFltAttr(ColIdx1);
3833  			TFlt V2 = (Arg2Type == atInt) ? (TFlt)RowI.GetIntAttr(ColIdx2) : RowI.GetFltAttr(ColIdx2);
3834  			if (op == aoAdd) { FltCols[ColIdx3][RowI.GetRowIdx()] = V1 + V2; }
3835        		if (op == aoSub) { FltCols[ColIdx3][RowI.GetRowIdx()] = V1 - V2; }
3836        		if (op == aoMul) { FltCols[ColIdx3][RowI.GetRowIdx()] = V1 * V2; }
3837        		if (op == aoDiv) { FltCols[ColIdx3][RowI.GetRowIdx()] = V1 / V2; }
3838        		if (op == aoMod) { TExcept::Throw("Cannot find modulo for float columns");  }
3839        		if (op == aoMin) { FltCols[ColIdx3][RowI.GetRowIdx()] = (V1 < V2) ? V1 : V2;}
3840        		if (op == aoMax) { FltCols[ColIdx3][RowI.GetRowIdx()] = (V1 > V2) ? V1 : V2;}
3841  		}
3842    }
3843  }
3844  void TTable::ColAdd(const TStr& Attr1, const TStr& Attr2, const TStr& ResultAttrName) {
3845    ColGenericOp(Attr1, Attr2, ResultAttrName, aoAdd);
3846  }
3847  void TTable::ColSub(const TStr& Attr1, const TStr& Attr2, const TStr& ResultAttrName) {
3848    ColGenericOp(Attr1, Attr2, ResultAttrName, aoSub);
3849  }
3850  void TTable::ColMul(const TStr& Attr1, const TStr& Attr2, const TStr& ResultAttrName) {
3851    ColGenericOp(Attr1, Attr2, ResultAttrName, aoMul);
3852  }
3853  void TTable::ColDiv(const TStr& Attr1, const TStr& Attr2, const TStr& ResultAttrName) {
3854    ColGenericOp(Attr1, Attr2, ResultAttrName, aoDiv);
3855  }
3856  void TTable::ColMod(const TStr& Attr1, const TStr& Attr2, const TStr& ResultAttrName) {
3857    ColGenericOp(Attr1, Attr2, ResultAttrName, aoMod);
3858  }
3859  void TTable::ColMin(const TStr& Attr1, const TStr& Attr2, const TStr& ResultAttrName) {
3860    ColGenericOp(Attr1, Attr2, ResultAttrName, aoMin);
3861  }
3862  void TTable::ColMax(const TStr& Attr1, const TStr& Attr2, const TStr& ResultAttrName) {
3863    ColGenericOp(Attr1, Attr2, ResultAttrName, aoMax);
3864  }
3865  void TTable::ColGenericOp(const TStr& Attr1, TTable& Table, const TStr& Attr2, const TStr& ResAttr,
3866   TArithOp op, TBool AddToFirstTable) {
3867    if (!IsAttr(Attr1)) { TExcept::Throw("No attribute present: " + Attr1); }
3868    if (!Table.IsAttr(Attr2)) { TExcept::Throw("No attribute present: " + Attr2); }
3869    if (NumValidRows != Table.NumValidRows) {
3870      TExcept::Throw("Tables do not have equal number of rows");
3871    }
3872    TPair<TAttrType, TInt> Info1 = GetColTypeMap(Attr1);
3873    TPair<TAttrType, TInt> Info2 = Table.GetColTypeMap(Attr2);
3874    TAttrType Arg1Type = Info1.Val1;
3875    TAttrType Arg2Type = Info2.Val1;
3876    if (Info1.Val1 == atStr || Info2.Val1 == atStr) {
3877      TExcept::Throw("Only numeric columns supported in arithmetic operations.");
3878    }
3879    if(Arg1Type == atInt && Arg2Type == atFlt && ResAttr == ""){
3880    	TExcept::Throw("Trying to write float values to an existing int-typed column");
3881    }
3882    TInt ColIdx1 = Info1.Val2;
3883    TInt ColIdx2 = Info2.Val2;
3884    TInt ColIdx3 = AddToFirstTable ? ColIdx1 : ColIdx2;
3885    if (ResAttr != "") {
3886      if (AddToFirstTable) {
3887        if (Arg1Type == atInt && Arg2Type == atInt) {
3888            AddIntCol(ResAttr);
3889        } else {
3890            AddFltCol(ResAttr);
3891        }
3892        ColIdx3 = GetColIdx(ResAttr);
3893      }
3894      else {
3895        if (Arg1Type == atInt && Arg2Type == atInt) {
3896            Table.AddIntCol(ResAttr);
3897        } else {
3898            Table.AddFltCol(ResAttr);
3899        }
3900        ColIdx3 = Table.GetColIdx(ResAttr);
3901      }
3902    }
3903    TRowIterator RI1, RI2;
3904    RI1 = BegRI();
3905    RI2 = Table.BegRI();
3906    TAttrType ResType = atFlt;
3907    if(Arg1Type == atInt && Arg2Type == atInt){ ResType = atInt;}
3908    while (RI1 < EndRI() && RI2 < Table.EndRI()) {
3909      if (ResType == atInt) {
3910  		TInt V1 = RI1.GetIntAttr(ColIdx1);
3911  		TInt V2 = RI2.GetIntAttr(ColIdx2);
3912          if (AddToFirstTable) {
3913          	if (op == aoAdd) { IntCols[ColIdx3][RI1.GetRowIdx()] = V1 + V2; }
3914          	if (op == aoSub) { IntCols[ColIdx3][RI1.GetRowIdx()] = V1 - V2; }
3915          	if (op == aoMul) { IntCols[ColIdx3][RI1.GetRowIdx()] = V1 * V2; }
3916          	if (op == aoDiv) { IntCols[ColIdx3][RI1.GetRowIdx()] = V1 / V2; }
3917         		if (op == aoMod) { IntCols[ColIdx3][RI1.GetRowIdx()] = V1 % V2; }
3918        	}
3919        	else {
3920          	if (op == aoAdd) { Table.IntCols[ColIdx3][RI2.GetRowIdx()] = V1 + V2; }
3921          	if (op == aoSub) { Table.IntCols[ColIdx3][RI2.GetRowIdx()] = V1 - V2; }
3922          	if (op == aoMul) { Table.IntCols[ColIdx3][RI2.GetRowIdx()] = V1 * V2; }
3923          	if (op == aoDiv) { Table.IntCols[ColIdx3][RI2.GetRowIdx()] = V1 / V2; }
3924          	if (op == aoMod) { Table.IntCols[ColIdx3][RI2.GetRowIdx()] = V1 % V2; }
3925        	}
3926      } else {
3927  	  	TFlt V1 = (Arg1Type == atInt) ? (TFlt)RI1.GetIntAttr(ColIdx1) : RI2.GetFltAttr(ColIdx1);
3928  		TFlt V2 = (Arg2Type == atInt) ? (TFlt)RI1.GetIntAttr(ColIdx2) : RI2.GetFltAttr(ColIdx2);
3929        	if (AddToFirstTable) {
3930          	if (op == aoAdd) { FltCols[ColIdx3][RI1.GetRowIdx()] = V1 + V2; }
3931          	if (op == aoSub) { FltCols[ColIdx3][RI1.GetRowIdx()] = V1 - V2; }
3932          	if (op == aoMul) { FltCols[ColIdx3][RI1.GetRowIdx()] = V1 * V2; }
3933         	 	if (op == aoDiv) { FltCols[ColIdx3][RI1.GetRowIdx()] = V1 / V2; }
3934          	if (op == aoMod) { TExcept::Throw("Cannot find modulo for float columns"); }
3935        	} else {
3936          	if (op == aoAdd) { Table.FltCols[ColIdx3][RI2.GetRowIdx()] = V1 + V2; }
3937          	if (op == aoSub) { Table.FltCols[ColIdx3][RI2.GetRowIdx()] = V1 - V2; }
3938          	if (op == aoMul) { Table.FltCols[ColIdx3][RI2.GetRowIdx()] = V1 * V2; }
3939          	if (op == aoDiv) { Table.FltCols[ColIdx3][RI2.GetRowIdx()] = V1 / V2; }
3940          	if (op == aoMod) { TExcept::Throw("Cannot find modulo for float columns"); }
3941        	}
3942      }
3943      RI1++;
3944      RI2++;
3945    }
3946    if (RI1 != EndRI() || RI2 != Table.EndRI()) {
3947      TExcept::Throw("ColGenericOp: Iteration error");
3948    }
3949  }
3950  void TTable::ColAdd(const TStr& Attr1, TTable& Table, const TStr& Attr2, 
3951   const TStr& ResultAttrName, TBool AddToFirstTable) {
3952    ColGenericOp(Attr1, Table, Attr2, ResultAttrName, aoAdd, AddToFirstTable);
3953  }
3954  void TTable::ColSub(const TStr& Attr1, TTable& Table, const TStr& Attr2, 
3955   const TStr& ResultAttrName, TBool AddToFirstTable) {
3956    ColGenericOp(Attr1, Table, Attr2, ResultAttrName, aoSub, AddToFirstTable);
3957  }
3958  void TTable::ColMul(const TStr& Attr1, TTable& Table, const TStr& Attr2, 
3959   const TStr& ResultAttrName, TBool AddToFirstTable) {
3960    ColGenericOp(Attr1, Table, Attr2, ResultAttrName, aoMul, AddToFirstTable);
3961  }
3962  void TTable::ColDiv(const TStr& Attr1, TTable& Table, const TStr& Attr2, 
3963   const TStr& ResultAttrName, TBool AddToFirstTable) {
3964    ColGenericOp(Attr1, Table, Attr2, ResultAttrName, aoDiv, AddToFirstTable);
3965  }
3966  void TTable::ColMod(const TStr& Attr1, TTable& Table, const TStr& Attr2, 
3967   const TStr& ResultAttrName, TBool AddToFirstTable) {
3968    ColGenericOp(Attr1, Table, Attr2, ResultAttrName, aoMod, AddToFirstTable);
3969  }
3970  void TTable::ColGenericOp(const TStr& Attr1, const TFlt& Num, const TStr& ResAttr, TArithOp op, const TBool floatCast) {
3971    if (!IsAttr(Attr1)) { TExcept::Throw("No attribute present: " + Attr1); }
3972    TPair<TAttrType, TInt> Info1 = GetColTypeMap(Attr1);
3973    TAttrType ArgType = Info1.Val1;
3974    if (ArgType == atStr) {
3975      TExcept::Throw("Only numeric columns supported in arithmetic operations.");
3976    }
3977    TInt ColIdx1 = Info1.Val2;
3978    TInt ColIdx2 = ColIdx1;
3979    TBool shouldCast = floatCast;
3980    if (ResAttr != "") {
3981        if ((ArgType == atInt) & !shouldCast) {
3982            AddIntCol(ResAttr);
3983        } else {
3984            AddFltCol(ResAttr);
3985        }
3986        ColIdx2 = GetColIdx(ResAttr);
3987    } else {
3988      shouldCast = false;
3989    }
3990    #ifdef USE_OPENMP
3991    if(GetMP()){
3992    	ColGenericOpMP(ColIdx1, ColIdx2, ArgType, Num, op, shouldCast);
3993    	return;
3994    }
3995    #endif  
3996    for (TRowIterator RowI = BegRI(); RowI < EndRI(); RowI++) {
3997      if ((ArgType == atInt) && !shouldCast) {
3998        TInt CurVal = RowI.GetIntAttr(ColIdx1);
3999        TInt Val = static_cast<int>(Num);
4000        if (op == aoAdd) { IntCols[ColIdx2][RowI.GetRowIdx()] = CurVal + Val; }
4001        if (op == aoSub) { IntCols[ColIdx2][RowI.GetRowIdx()] = CurVal - Val; }
4002        if (op == aoMul) { IntCols[ColIdx2][RowI.GetRowIdx()] = CurVal * Val; }
4003        if (op == aoDiv) { IntCols[ColIdx2][RowI.GetRowIdx()] = CurVal / Val; }
4004        if (op == aoMod) { IntCols[ColIdx2][RowI.GetRowIdx()] = CurVal % Val; }
4005      }
4006      else {
4007        TFlt CurVal = (ArgType == atFlt) ? RowI.GetFltAttr(ColIdx1) : (TFlt) RowI.GetIntAttr(ColIdx1);
4008        if (op == aoAdd) { FltCols[ColIdx2][RowI.GetRowIdx()] = CurVal + Num; }
4009        if (op == aoSub) { FltCols[ColIdx2][RowI.GetRowIdx()] = CurVal - Num; }
4010        if (op == aoMul) { FltCols[ColIdx2][RowI.GetRowIdx()] = CurVal * Num; }
4011        if (op == aoDiv) { FltCols[ColIdx2][RowI.GetRowIdx()] = CurVal / Num; }
4012        if (op == aoMod) { TExcept::Throw("Cannot find modulo for float columns"); }
4013      }
4014    }
4015  }
4016  #ifdef USE_OPENMP
4017  void TTable::ColGenericOpMP(const TInt& ColIdx1, const TInt& ColIdx2, TAttrType ArgType, const TFlt& Num, TArithOp op, TBool ShouldCast){
4018  	TIntPrV Partitions;
4019  	GetPartitionRanges(Partitions, omp_get_max_threads()*CHUNKS_PER_THREAD);
4020  	TInt PartitionSize = Partitions[0].GetVal2()-Partitions[0].GetVal1()+1;
4021  	#pragma omp parallel for schedule(dynamic, CHUNKS_PER_THREAD)
4022  	for (int i = 0; i < Partitions.Len(); i++){
4023  		TRowIterator RowI(Partitions[i].GetVal1(), this);
4024  		TRowIterator EndI(Partitions[i].GetVal2(), this);
4025  		while(RowI < EndI){
4026  			if ((ArgType == atInt) && !ShouldCast) {
4027        			TInt CurVal = RowI.GetIntAttr(ColIdx1);
4028        			TInt Val = static_cast<int>(Num);
4029        			if (op == aoAdd) { IntCols[ColIdx2][RowI.GetRowIdx()] = CurVal + Val; }
4030        			if (op == aoSub) { IntCols[ColIdx2][RowI.GetRowIdx()] = CurVal - Val; }
4031        			if (op == aoMul) { IntCols[ColIdx2][RowI.GetRowIdx()] = CurVal * Val; }
4032        			if (op == aoDiv) { IntCols[ColIdx2][RowI.GetRowIdx()] = CurVal / Val; }
4033        			if (op == aoMod) { IntCols[ColIdx2][RowI.GetRowIdx()] = CurVal % Val; }
4034      		} else {
4035       			TFlt CurVal = (ArgType == atFlt) ? RowI.GetFltAttr(ColIdx1) : (TFlt) RowI.GetIntAttr(ColIdx1);
4036        			if (op == aoAdd) { FltCols[ColIdx2][RowI.GetRowIdx()] = CurVal + Num; }
4037        			if (op == aoSub) { FltCols[ColIdx2][RowI.GetRowIdx()] = CurVal - Num; }
4038        			if (op == aoMul) { FltCols[ColIdx2][RowI.GetRowIdx()] = CurVal * Num; }
4039        			if (op == aoDiv) { FltCols[ColIdx2][RowI.GetRowIdx()] = CurVal / Num; }
4040        			if (op == aoMod) { TExcept::Throw("Cannot find modulo for float columns"); }
4041      		}
4042      		RowI++;
4043  		}
4044  	}
4045  }
4046  #endif
4047  void TTable::ColAdd(const TStr& Attr1, const TFlt& Num, const TStr& ResultAttrName, const TBool floatCast) {
4048    ColGenericOp(Attr1, Num, ResultAttrName, aoAdd, floatCast);
4049  }
4050  void TTable::ColSub(const TStr& Attr1, const TFlt& Num, const TStr& ResultAttrName, const TBool floatCast) {
4051    ColGenericOp(Attr1, Num, ResultAttrName, aoSub, floatCast);
4052  }
4053  void TTable::ColMul(const TStr& Attr1, const TFlt& Num, const TStr& ResultAttrName, const TBool floatCast) {
4054    ColGenericOp(Attr1, Num, ResultAttrName, aoMul, floatCast);
4055  }
4056  void TTable::ColDiv(const TStr& Attr1, const TFlt& Num, const TStr& ResultAttrName, const TBool floatCast) {
4057    ColGenericOp(Attr1, Num, ResultAttrName, aoDiv, floatCast);
4058  }
4059  void TTable::ColMod(const TStr& Attr1, const TFlt& Num, const TStr& ResultAttrName, const TBool floatCast) {
4060    ColGenericOp(Attr1, Num, ResultAttrName, aoMod, floatCast);
4061  }
4062  void TTable::ColConcat(const TStr& Attr1, const TStr& Attr2, const TStr& Sep, const TStr& ResAttr) {
4063    if (!IsAttr(Attr1)) TExcept::Throw("No attribute present: " + Attr1);
4064    if (!IsAttr(Attr2)) TExcept::Throw("No attribute present: " + Attr2);
4065    TPair<TAttrType, TInt> Info1 = GetColTypeMap(Attr1);
4066    TPair<TAttrType, TInt> Info2 = GetColTypeMap(Attr2);
4067    if (Info1.Val1 != atStr || Info2.Val1 != atStr) {
4068      TExcept::Throw("Only string columns supported in concat.");
4069    }
4070    TInt ColIdx1 = Info1.Val2;
4071    TInt ColIdx2 = Info2.Val2;
4072    TInt ColIdx3 = ColIdx1;
4073    if (ResAttr != "") {
4074        AddStrCol(ResAttr);
4075        ColIdx3 = GetColIdx(ResAttr);
4076    }
4077    for (TRowIterator RowI = BegRI(); RowI < EndRI(); RowI++) {
4078      TStr CurVal1 = RowI.GetStrAttr(ColIdx1);
4079      TStr CurVal2 = RowI.GetStrAttr(ColIdx2);
4080      TStr NewVal = CurVal1 + Sep + CurVal2;
4081      TInt Key = TInt(Context->StringVals.AddKey(NewVal));
4082      StrColMaps[ColIdx3][RowI.GetRowIdx()] = Key;
4083    }
4084  }
4085  void TTable::ColConcat(const TStr& Attr1, TTable& Table, const TStr& Attr2, const TStr& Sep, 
4086   const TStr& ResAttr, TBool AddToFirstTable) {
4087    if (!IsAttr(Attr1)) { TExcept::Throw("No attribute present: " + Attr1); }
4088    if (!Table.IsAttr(Attr2)) { TExcept::Throw("No attribute present: " + Attr2); }
4089    if (NumValidRows != Table.NumValidRows) {
4090      TExcept::Throw("Tables do not have equal number of rows");
4091    }
4092    TPair<TAttrType, TInt> Info1 = GetColTypeMap(Attr1);
4093    TPair<TAttrType, TInt> Info2 = Table.GetColTypeMap(Attr2);
4094    if (Info1.Val1 != atStr || Info2.Val1 != atStr) {
4095      TExcept::Throw("Only string columns supported in concat.");
4096    }
4097    TInt ColIdx1 = Info1.Val2;
4098    TInt ColIdx2 = Info2.Val2;
4099    TInt ColIdx3 = ColIdx1;
4100    if (!AddToFirstTable) {
4101      ColIdx3 = ColIdx2;
4102    }
4103    if (ResAttr != "") {
4104      if (AddToFirstTable) {
4105        AddStrCol(ResAttr);
4106        ColIdx3 = GetColIdx(ResAttr);
4107      }
4108      else {
4109        Table.AddStrCol(ResAttr);
4110        ColIdx3 = Table.GetColIdx(ResAttr);
4111      }
4112    }
4113    TRowIterator RI1, RI2;
4114    RI1 = BegRI();
4115    RI2 = Table.BegRI();
4116    while (RI1 < EndRI() && RI2 < Table.EndRI()) {
4117      TStr CurVal1 = RI1.GetStrAttr(ColIdx1);
4118      TStr CurVal2 = RI2.GetStrAttr(ColIdx2);
4119      TStr NewVal = CurVal1 + Sep + CurVal2;
4120      TInt Key = TInt(Context->StringVals.AddKey(NewVal));
4121      if (AddToFirstTable) {
4122        StrColMaps[ColIdx3][RI1.GetRowIdx()] = Key;
4123      }
4124      else {
4125        Table.StrColMaps[ColIdx3][RI2.GetRowIdx()] = Key;
4126      }
4127      RI1++;
4128      RI2++;
4129    }
4130    if (RI1 != EndRI() || RI2 != Table.EndRI()) {
4131      TExcept::Throw("ColGenericOp: Iteration error");
4132    }
4133  }
4134  void TTable::ColConcatConst(const TStr& Attr1, const TStr& Val, const TStr& Sep, const TStr& ResAttr) {
4135    if (!IsAttr(Attr1)) { TExcept::Throw("No attribute present: " + Attr1); }
4136    TPair<TAttrType, TInt> Info1 = GetColTypeMap(Attr1);
4137    if (Info1.Val1 != atStr) {
4138      TExcept::Throw("Only string columns supported in concat.");
4139    }
4140    TInt ColIdx1 = Info1.Val2;
4141    TInt ColIdx2 = ColIdx1;
4142    if (ResAttr != "") {
4143      AddStrCol(ResAttr);
4144      ColIdx2 = GetColIdx(ResAttr);
4145    }
4146    for (TRowIterator RowI = BegRI(); RowI < EndRI(); RowI++) {
4147      TStr CurVal = RowI.GetStrAttr(ColIdx1);
4148      TStr NewVal = CurVal + Sep + Val;
4149      TInt Key = TInt(Context->StringVals.AddKey(NewVal));
4150      StrColMaps[ColIdx2][RowI.GetRowIdx()] = Key;
4151    }  
4152  }
4153  void TTable::ReadIntCol(const TStr& ColName, TIntV& Result) const{
4154    if (!IsColName(ColName)) { TExcept::Throw("no such column " + ColName); }
4155    if (GetColType(ColName) != atInt) { TExcept::Throw("not an integer column " + ColName); }
4156    TInt ColId = GetColIdx(ColName);
4157    for (TRowIterator it = BegRI(); it < EndRI(); it++) {
4158      Result.Add(it.GetIntAttr(ColId));
4159    }
4160  }
4161  void TTable::ReadFltCol(const TStr& ColName, TFltV& Result) const{
4162    if (!IsColName(ColName)) { TExcept::Throw("no such column " + ColName); }
4163    if (GetColType(ColName) != atFlt) { TExcept::Throw("not a floating point column " + ColName); }
4164    TInt ColId = GetColIdx(ColName);
4165    for (TRowIterator it = BegRI(); it < EndRI(); it++) {
4166      Result.Add(it.GetFltAttr(ColId));
4167    }
4168  }
4169  void TTable::ReadStrCol(const TStr& ColName, TStrV& Result) const{
4170    if (!IsColName(ColName)) { TExcept::Throw("no such column " + ColName); }
4171    if (GetColType(ColName) != atStr) { TExcept::Throw("not a string column " + ColName); }
4172    TInt ColId = GetColIdx(ColName);
4173    for (TRowIterator it = BegRI(); it < EndRI(); it++) {
4174      Result.Add(it.GetStrAttr(ColId));
4175    }
4176  }
4177  void TTable::ProjectInPlace(const TStrV& ProjectCols) {
4178    TStrV NProjectCols = NormalizeColNameV(ProjectCols);
4179    for (TInt c = 0; c < NProjectCols.Len(); c++) {
4180      if (!IsColName(NProjectCols[c])) { TExcept::Throw("no such column " + NProjectCols[c]); }
4181    }
4182    THashSet<TStr> ProjectColsSet = THashSet<TStr>(NProjectCols);
4183    for (TInt i = Sch.Len() - 1; i >= 0; i--) {
4184      TStr ColName = GetSchemaColName(i);
4185      if (ProjectColsSet.IsKey(ColName) || ColName == IdColName) { continue; }
4186      TAttrType ColType = GetSchemaColType(i);
4187      TInt ColId = GetColIdx(ColName);
4188      switch (ColType) {
4189        case atInt:
4190          IntCols.Del(ColId);
4191          break;
4192        case atFlt:
4193          FltCols.Del(ColId);
4194          break;
4195        case atStr:
4196          StrColMaps.Del(ColId);
4197          break;
4198      }
4199    }
4200    TInt IntColCnt = 0;
4201    TInt FltColCnt = 0;
4202    TInt StrColCnt = 0;
4203    ColTypeMap.Clr();
4204    for (TInt i = 0; i < Sch.Len(); i++) {
4205      TStr ColName = GetSchemaColName(i);
4206      if (!ProjectColsSet.IsKey(ColName) && ColName != IdColName) { continue; }
4207      TAttrType ColType = GetSchemaColType(i);
4208      switch (ColType) {
4209        case atInt:
4210          AddColType(ColName, atInt, IntColCnt);
4211          IntColCnt++;
4212          break;
4213        case atFlt:
4214          AddColType(ColName, atFlt, FltColCnt);
4215          FltColCnt++;
4216          break;
4217        case atStr:
4218          AddColType(ColName, atStr, StrColCnt);
4219          StrColCnt++;
4220          break;
4221      }
4222    }
4223    for (TInt i = Sch.Len() - 1; i >= 0; i--) {
4224      TStr ColName = GetSchemaColName(i);
4225      if (ProjectColsSet.IsKey(ColName) || ColName == IdColName) { continue; }
4226      Sch.Del(i);
4227    }
4228  }
4229  TInt TTable::CompareKeyVal(const TInt& K1, const TInt& V1, const TInt& K2, const TInt& V2) {
4230    if (K1 == K2) { return V1 - V2; }
4231    else { return K1 - K2; }
4232  }
4233  TInt TTable::CheckSortedKeyVal(TIntV& Key, TIntV& Val, TInt Start, TInt End) {
4234    TInt j;
4235    for (j = Start; j < End; j++) {
4236      if (CompareKeyVal(Key[j], Val[j], Key[j+1], Val[j+1]) > 0) {
4237        break;
4238      }
4239    }
4240    if (j >= End) { return 0; }
4241    else { return 1; }
4242  }
4243  void TTable::ISortKeyVal(TIntV& Key, TIntV& Val, TInt Start, TInt End) {
4244    if (Start < End) {
4245      for (TInt i = Start+1; i <= End; i++) {
4246        TInt K = Key[i];
4247        TInt V = Val[i];
4248        TInt j = i;
4249        while ((Start < j) && (CompareKeyVal(Key[j-1], Val[j-1], K, V) > 0)) {
4250          Key[j] = Key[j-1];
4251          Val[j] = Val[j-1];
4252          j--;
4253        }
4254        Key[j] = K;
4255        Val[j] = V;
4256      }
4257    }
4258  }
4259  TInt TTable::GetPivotKeyVal(TIntV& Key, TIntV& Val, TInt Start, TInt End) {
4260    TInt L = End - Start + 1;
4261    const TInt Idx1 = Start + TInt::GetRnd(L);
4262    const TInt Idx2 = Start + TInt::GetRnd(L);
4263    const TInt Idx3 = Start + TInt::GetRnd(L);
4264    if (CompareKeyVal(Key[Idx1], Val[Idx1], Key[Idx2], Val[Idx2]) < 0) {
4265      if (CompareKeyVal(Key[Idx2], Val[Idx2], Key[Idx3], Val[Idx3]) < 0) { return Idx2; }
4266      if (CompareKeyVal(Key[Idx1], Val[Idx1], Key[Idx3], Val[Idx3]) < 0) { return Idx3; }
4267      return Idx1;
4268    } else {
4269      if (CompareKeyVal(Key[Idx3], Val[Idx3], Key[Idx2], Val[Idx2]) < 0) { return Idx2; }
4270      if (CompareKeyVal(Key[Idx3], Val[Idx3], Key[Idx1], Val[Idx1]) < 0) { return Idx3; }
4271      return Idx1;
4272    }
4273  }
4274  TInt TTable::PartitionKeyVal(TIntV& Key, TIntV& Val, TInt Start, TInt End) {
4275    TInt Pivot = GetPivotKeyVal(Key, Val, Start, End);
4276    TInt PivotKey = Key[Pivot];
4277    TInt PivotVal = Val[Pivot];
4278    Key.Swap(Pivot, End);
4279    Val.Swap(Pivot, End);
4280    TInt StoreIdx = Start;
4281    for (TInt i = Start; i < End; i++) {
4282      if (CompareKeyVal(Key[i], Val[i], PivotKey, PivotVal) <= 0) {
4283        Key.Swap(i, StoreIdx);
4284        Val.Swap(i, StoreIdx);
4285        StoreIdx++;
4286      }
4287    }
4288    Key.Swap(StoreIdx, End);
4289    Val.Swap(StoreIdx, End);
4290    return StoreIdx;
4291  }
4292  void TTable::QSortKeyVal(TIntV& Key, TIntV& Val, TInt Start, TInt End) {
4293    TInt L = End-Start;
4294    if (L <= 0) { return; }
4295    if (CheckSortedKeyVal(Key, Val, Start, End) == 0) { return; }
4296    if (L <= 20) { ISortKeyVal(Key, Val, Start, End); }
4297    else {
4298      TInt Pivot = PartitionKeyVal(Key, Val, Start, End);
4299      if (Pivot > End) { return; }
4300      if (L <= 500000) {
4301        QSortKeyVal(Key, Val, Start, Pivot-1);
4302        QSortKeyVal(Key, Val, Pivot+1, End);
4303      } else {
4304  #ifdef USE_OPENMP
4305  #ifndef GLib_WIN32
4306        #pragma omp task untied shared(Key, Val)
4307  #endif
4308  #endif
4309        { QSortKeyVal(Key, Val, Start, Pivot-1); }
4310  #ifdef USE_OPENMP
4311  #ifndef GLib_WIN32
4312        #pragma omp task untied shared(Key, Val)
4313  #endif
4314  #endif
4315        { QSortKeyVal(Key, Val, Pivot+1, End); }
4316      }
4317    }
4318  }
4319  TIntV TTable::GetIntRowIdxByVal(const TStr& ColName, const TInt& Val) const {
4320    if (IntColIndexes.IsKey(ColName)) {
4321      THash<TInt, TIntV> ColIndex = IntColIndexes.GetDat(ColName);
4322      if (ColIndex.IsKey(Val)) {
4323        return ColIndex.GetDat(Val);
4324      }
4325      else {
4326        TIntV Empty;
4327        return Empty;
4328      }
4329    }
4330    TIntV ToReturn;
4331    for (TRowIterator RowI = BegRI(); RowI < EndRI(); RowI++) {
4332      TInt ValAtRow = RowI.GetIntAttr(ColName);
4333      if ( Val == ValAtRow) {
4334        ToReturn.Add(RowI.GetRowIdx());
4335      }
4336    }
4337    return ToReturn;
4338  }
4339  TIntV TTable::GetStrRowIdxByMap(const TStr& ColName, const TInt& Map) const {
4340    if (StrMapColIndexes.IsKey(ColName)) {
4341      THash<TInt, TIntV> ColIndex = StrMapColIndexes.GetDat(ColName);
4342      if (ColIndex.IsKey(Map)) {
4343        return ColIndex.GetDat(Map);
4344      }
4345      else {
4346        TIntV Empty;
4347        return Empty;
4348      }
4349    }
4350    TIntV ToReturn;
4351    for (TRowIterator RowI = BegRI(); RowI < EndRI(); RowI++) {
4352      TInt MapAtRow = RowI.GetStrMapByName(ColName);
4353      if ( Map == MapAtRow) {
4354        ToReturn.Add(RowI.GetRowIdx());
4355      }
4356    }
4357    return ToReturn;
4358  }
4359  TIntV TTable::GetFltRowIdxByVal(const TStr& ColName, const TFlt& Val) const {
4360    if (FltColIndexes.IsKey(ColName)) {
4361      THash<TFlt, TIntV> ColIndex = FltColIndexes.GetDat(ColName);
4362      if (ColIndex.IsKey(Val)) {
4363        return ColIndex.GetDat(Val);
4364      }
4365      else {
4366        TIntV Empty;
4367        return Empty;
4368      }
4369    }
4370    TIntV ToReturn;
4371    for (TRowIterator RowI = BegRI(); RowI < EndRI(); RowI++) {
4372      TFlt ValAtRow = RowI.GetFltAttr(ColName);
4373      if ( Val == ValAtRow) {
4374        ToReturn.Add(RowI.GetRowIdx());
4375      }
4376    }
4377    return ToReturn;
4378  }
4379  TInt TTable::RequestIndexInt(const TStr& ColName) {
4380    THash<TInt, TIntV> NewIndex;
4381    for (TRowIterator RowI = BegRI(); RowI < EndRI(); RowI++) {
4382      TInt ValAtRow = RowI.GetIntAttr(ColName);
4383      TInt RowIdx = RowI.GetRowIdx();
4384      if (NewIndex.IsKey(ValAtRow)) {
4385         TIntV Curr_V = NewIndex.GetDat(ValAtRow);
4386         Curr_V.Add(RowIdx);
4387      }
4388      else {
4389        TIntV New_V;
4390        New_V.Add(RowIdx);
4391        NewIndex.AddDat(ValAtRow, New_V);
4392      }
4393    }
4394    IntColIndexes.AddDat(ColName, NewIndex); 
4395    return 0;
4396  }
4397  TInt TTable::RequestIndexFlt(const TStr& ColName) {
4398    THash<TFlt, TIntV> NewIndex;
4399    for (TRowIterator RowI = BegRI(); RowI < EndRI(); RowI++) {
4400      TFlt ValAtRow = RowI.GetFltAttr(ColName);
4401      TInt RowIdx = RowI.GetRowIdx();
4402      if (NewIndex.IsKey(ValAtRow)) {
4403         TIntV Curr_V = NewIndex.GetDat(ValAtRow);
4404         Curr_V.Add(RowIdx);
4405      }
4406      else {
4407        TIntV New_V;
4408        New_V.Add(RowIdx);
4409        NewIndex.AddDat(ValAtRow, New_V);
4410      }
4411    }
4412    FltColIndexes.AddDat(ColName, NewIndex); 
4413    return 0;
4414  }
4415  TInt TTable::RequestIndexStrMap(const TStr& ColName) {
4416    THash<TInt, TIntV> NewIndex;
4417    for (TRowIterator RowI = BegRI(); RowI < EndRI(); RowI++) {
4418      TInt MapAtRow = RowI.GetStrMapByName(ColName);
4419      TInt RowIdx = RowI.GetRowIdx();
4420      if (NewIndex.IsKey(MapAtRow)) {
4421         TIntV Curr_V = NewIndex.GetDat(MapAtRow);
4422         Curr_V.Add(RowIdx);
4423      }
4424      else {
4425        TIntV New_V;
4426        New_V.Add(RowIdx);
4427        NewIndex.AddDat(MapAtRow, New_V);
4428      }
4429    }
4430    StrMapColIndexes.AddDat(ColName, NewIndex); 
4431    return 0;
4432  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-gmock-matchers.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-table.cpp</div>
                </div>
                <div class="column column_space"><pre><code>1717      if (second_explanation != "") {
1718        *listener << ", ";
1719        if (first_explanation != "") {
1720          *listener << "and ";
1721        } else {
1722          *listener << "where ";
1723        }
1724        *listener << "the second field is a value " << second_explanation;
1725      }
1726    }
</pre></code></div>
                <div class="column column_space"><pre><code>1795                for(TInt j = 0; j < Group.Len(); j++){
1796                  if(ThisIsSmaller){
1797                    JointRowIDSet[i].Add(TIntPr(Group[j], RowI.GetRowIdx()));
1798                  } else{
1799                    JointRowIDSet[i].Add(TIntPr(RowI.GetRowIdx(), Group[j]));
1800                  }
1801                }
1802              }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    