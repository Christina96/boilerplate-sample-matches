
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 20, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-tomlconfig.hpp</h3>
            <pre><code>1  #pragma once
2  #include <nano/lib/configbase.hpp>
3  #include <nano/lib/utility.hpp>
4  #include <boost/filesystem/path.hpp>
5  #include <boost/lexical_cast.hpp>
6  #include <boost/optional.hpp>
7  #include <cpptoml.h>
8  namespace boost
9  {
10  namespace asio
11  {
12  	namespace ip
13  	{
14  		class address_v6;
15  	}
16  }
17  }
18  namespace nano
19  {
20  class error;
21  class tomlconfig : public nano::configbase
22  {
23  public:
24  	tomlconfig ();
25  	tomlconfig (std::shared_ptr<cpptoml::table> const & tree_a, std::shared_ptr<nano::error> const & error_a = nullptr);
26  	void doc (std::string const & key, std::string const & doc);
27  	nano::error & read (boost::filesystem::path const & path_a);
28  	nano::error & read (std::istream & stream_overrides, boost::filesystem::path const & path_a);
29  	nano::error & read (std::istream & stream_a);
30  	nano::error & read (std::istream & stream_first_a, std::istream & stream_second_a);
31  	void write (boost::filesystem::path const & path_a);
32  	void write (std::ostream & stream_a) const;
33  	void open_or_create (std::fstream & stream_a, std::string const & path_a);
34  	std::shared_ptr<cpptoml::table> get_tree ();
35  	bool empty () const;
36  	boost::optional<tomlconfig> get_optional_child (std::string const & key_a);
37  	tomlconfig get_required_child (std::string const & key_a);
38  	tomlconfig & put_child (std::string const & key_a, nano::tomlconfig & conf_a);
39  	tomlconfig & replace_child (std::string const & key_a, nano::tomlconfig & conf_a);
40  	bool has_key (std::string const & key_a);
41  	tomlconfig & erase (std::string const & key_a);
42  	std::shared_ptr<cpptoml::array> create_array (std::string const & key, boost::optional<char const *> documentation_a);
43  	void erase_default_values (tomlconfig & defaults_a);
44  	std::string to_string ();
45  	std::string to_string_commented_entries ();
46  	template <typename T>
47  	tomlconfig & put (std::string const & key, T const & value, boost::optional<char const *> documentation_a = boost::none)
48  	{
49  		tree->insert (key, value);
50  		if (documentation_a)
51  		{
52  			doc (key, *documentation_a);
53  		}
54  		return *this;
55  	}
56  	template <typename T>
57  	tomlconfig & push (std::string const & key, T const & value)
58  	{
59  		if (!has_key (key))
60  		{
61  			auto arr = cpptoml::make_array ();
62  			tree->insert (key, arr);
63  		}
64  		auto arr = tree->get_qualified (key)->as_array ();
65  		arr->push_back (value);
66  		return *this;
67  	}
68  	template <typename T>
69  	tomlconfig & array_entries_required (std::string const & key, std::function<void (T)> callback)
70  	{
71  		if (tree->contains_qualified (key))
72  		{
73  			auto items = tree->get_qualified_array_of<T> (key);
74  			for (auto & item : *items)
75  			{
76  				callback (item);
77  			}
78  		}
79  		else
80  		{
81  			conditionally_set_error<T> (nano::error_config::missing_value, false, key);
82  		}
83  		return *this;
84  	}
85  	template <typename T>
86  	tomlconfig & get_optional (std::string const & key, T & target, T default_value)
87  	{
88  		get_config (true, key, target, default_value);
89  		return *this;
90  	}
91  	template <typename T>
92  	tomlconfig & get_optional (std::string const & key, T & target)
93  	{
94  		get_config (true, key, target, target);
95  		return *this;
96  	}
97  	template <typename T>
98  	boost::optional<T> get_optional (std::string const & key)
99  	{
100  		boost::optional<T> res;
101  		if (has_key (key))
102  		{
103  			T target{};
104  			get_config (true, key, target, target);
105  			res = target;
106  		}
107  		return res;
108  	}
109  	template <typename T>
110  	tomlconfig & get (std::string const & key, T & target)
111  	{
112  		get_config (true, key, target, target);
113  		return *this;
114  	}
115  	template <typename T>
116  	T get (std::string const & key)
117  	{
118  		T target{};
119  		get_config (true, key, target, target);
120  		return target;
121  	}
122  	template <typename T>
123  	tomlconfig & get_required (std::string const & key, T & target)
124  	{
125  		get_config (false, key, target);
126  		return *this;
127  	}
128  	template <typename T>
129  	tomlconfig & get_required (std::string const & key, T & target, T const & default_value)
130  	{
131  		get_config (false, key, target, default_value);
132  		return *this;
133  	}
134  protected:
<span onclick='openModal()' class='match'>135  	template <typename T, typename = std::enable_if_t<nano::is_lexical_castable<T>::value>>
136  	tomlconfig & get_config (bool optional, std::string const & key, T & target, T default_value = T ())
</span>137  	{
138  		try
139  		{
140  			if (tree->contains_qualified (key))
141  			{
142  				auto val (tree->get_qualified_as<std::string> (key));
143  				if (!boost::conversion::try_lexical_convert<T> (*val, target))
144  				{
145  					conditionally_set_error<T> (nano::error_config::invalid_value, optional, key);
146  				}
147  			}
148  			else if (!optional)
149  			{
150  				conditionally_set_error<T> (nano::error_config::missing_value, optional, key);
151  			}
152  			else
153  			{
154  				target = default_value;
155  			}
156  		}
157  		catch (std::runtime_error & ex)
158  		{
159  			conditionally_set_error<T> (ex, optional, key);
160  		}
161  		return *this;
162  	}
163  	tomlconfig & get_config (bool optional, std::string const & key, uint8_t & target, uint8_t default_value = uint8_t ());
164  	tomlconfig & get_config (bool optional, std::string const & key, bool & target, bool default_value = false);
165  	tomlconfig & get_config (bool optional, std::string key, boost::asio::ip::address_v6 & target, boost::asio::ip::address_v6 const & default_value);
166  private:
167  	std::shared_ptr<cpptoml::table> tree;
168  	void erase_defaults (std::shared_ptr<cpptoml::table> const & base, std::shared_ptr<cpptoml::table> const & other, std::shared_ptr<cpptoml::table> const & update_target);
169  };
170  }
</code></pre>
        </div>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-relaxed_atomic.hpp</h3>
            <pre><code>1  #pragma once
2  #include <atomic>
3  #include <type_traits>
4  namespace nano
5  {
<span onclick='openModal()' class='match'>6  template <typename T, typename = std::enable_if_t<std::is_integral<T>::value>>
7  class relaxed_atomic_integral
</span>8  {
9  public:
10  	relaxed_atomic_integral () noexcept = default;
11  	constexpr relaxed_atomic_integral (T desired) noexcept :
12  		atomic (desired)
13  	{
14  	}
15  	T operator= (T desired) noexcept
16  	{
17  		store (desired);
18  		return atomic;
19  	}
20  	relaxed_atomic_integral (relaxed_atomic_integral const &) = delete;
21  	relaxed_atomic_integral & operator= (relaxed_atomic_integral const &) = delete;
22  	void store (T desired, std::memory_order order = std::memory_order_relaxed) noexcept
23  	{
24  		atomic.store (desired, order);
25  	}
26  	T load (std::memory_order order = std::memory_order_relaxed) const noexcept
27  	{
28  		return atomic.load (std::memory_order_relaxed);
29  	}
30  	operator T () const noexcept
31  	{
32  		return load ();
33  	}
34  	bool compare_exchange_weak (T & expected, T desired, std::memory_order order = std::memory_order_relaxed) noexcept
35  	{
36  		return atomic.compare_exchange_weak (expected, desired, order);
37  	}
38  	bool compare_exchange_strong (T & expected, T desired, std::memory_order order = std::memory_order_relaxed) noexcept
39  	{
40  		return atomic.compare_exchange_strong (expected, desired, order);
41  	}
42  	T fetch_add (T arg, std::memory_order order = std::memory_order_relaxed) noexcept
43  	{
44  		return atomic.fetch_add (arg, order);
45  	}
46  	T fetch_sub (T arg, std::memory_order order = std::memory_order_relaxed) noexcept
47  	{
48  		return atomic.fetch_sub (arg, order);
49  	}
50  	T operator++ () noexcept
51  	{
52  		return fetch_add (1) + 1;
53  	}
54  	T operator++ (int) noexcept
55  	{
56  		return fetch_add (1);
57  	}
58  	T operator-- () noexcept
59  	{
60  		return fetch_sub (1) - 1;
61  	}
62  	T operator-- (int) noexcept
63  	{
64  		return fetch_sub (1);
65  	}
66  private:
67  	std::atomic<T> atomic;
68  };
69  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-tomlconfig.hpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-relaxed_atomic.hpp</div>
                </div>
                <div class="column column_space"><pre><code>135  	template <typename T, typename = std::enable_if_t<nano::is_lexical_castable<T>::value>>
136  	tomlconfig & get_config (bool optional, std::string const & key, T & target, T default_value = T ())
</pre></code></div>
                <div class="column column_space"><pre><code>6  template <typename T, typename = std::enable_if_t<std::is_integral<T>::value>>
7  class relaxed_atomic_integral
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    