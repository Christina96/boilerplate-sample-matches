
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 21.841541755888652%, Tokens: 14</h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-charconv_bigint_test.cc</h3>
            <pre><code>1  #include "absl/strings/internal/charconv_bigint.h"
2  #include <string>
3  #include "gtest/gtest.h"
4  namespace absl {
5  ABSL_NAMESPACE_BEGIN
6  namespace strings_internal {
7  TEST(BigUnsigned, ShiftLeft) {
8    {
9      BigUnsigned<4> num(3u);
10      num.ShiftLeft(100);
11      EXPECT_EQ(num, BigUnsigned<4>("3802951800684688204490109616128"));
12    }
13    {
14      BigUnsigned<4> a(15u);
15      BigUnsigned<4> b(7u);
16      BigUnsigned<4> c(3u);
17      a.ShiftLeft(125);
18      b.ShiftLeft(125);
19      c.ShiftLeft(125);
20      EXPECT_EQ(a, b);
21      EXPECT_NE(a, c);
22    }
23    {
24      BigUnsigned<84> a(15u);
25      BigUnsigned<84> b(7u);
26      BigUnsigned<84> c(3u);
27      a.ShiftLeft(84 * 32 - 3);
28      b.ShiftLeft(84 * 32 - 3);
29      c.ShiftLeft(84 * 32 - 3);
30      EXPECT_EQ(a, b);
31      EXPECT_NE(a, c);
32    }
33    {
34      const std::string seed = "1234567890123456789012345678901234567890";
35      BigUnsigned<84> a(seed);
36      for (int i = 1; i <= 84 * 32; ++i) {
37        a.ShiftLeft(1);
38        BigUnsigned<84> b(seed);
39        b.ShiftLeft(i);
40        EXPECT_EQ(a, b);
41      }
42      EXPECT_EQ(a, BigUnsigned<84>(0u));
43    }
44    {
45      const BigUnsigned<84> all_bits_one(
46          "1474444211396924248063325089479706787923460402125687709454567433186613"
47          "6228083464060749874845919674257665016359189106695900028098437021384227"
48          "3285029708032466536084583113729486015826557532750465299832071590813090"
49          "2011853039837649252477307070509704043541368002938784757296893793903797"
50          "8180292336310543540677175225040919704702800559606097685920595947397024"
51          "8303316808753252115729411497720357971050627997031988036134171378490368"
52          "6008000778741115399296162550786288457245180872759047016734959330367829"
53          "5235612397427686310674725251378116268607113017720538636924549612987647"
54          "5767411074510311386444547332882472126067840027882117834454260409440463"
55          "9345147252664893456053258463203120637089916304618696601333953616715125"
56          "2115882482473279040772264257431663818610405673876655957323083702713344"
57          "4201105427930770976052393421467136557055");
58      const BigUnsigned<84> zero(0u);
59      const BigUnsigned<84> one(1u);
60      for (int i = 1; i < 84*32; ++i) {
61        BigUnsigned<84> big_shifted = all_bits_one;
62        big_shifted.ShiftLeft(i);
63        EXPECT_GT(all_bits_one, big_shifted);
64        BigUnsigned<84> small_shifted = one;
65        small_shifted.ShiftLeft(i);
66        EXPECT_LT(one, small_shifted);
67      }
68      for (int no_op_shift : {0, -1, -84 * 32, std::numeric_limits<int>::min()}) {
69        BigUnsigned<84> big_shifted = all_bits_one;
70        big_shifted.ShiftLeft(no_op_shift);
71        EXPECT_EQ(all_bits_one, big_shifted);
72        BigUnsigned<84> small_shifted = one;
73        big_shifted.ShiftLeft(no_op_shift);
74        EXPECT_EQ(one, small_shifted);
75      }
76      for (int out_of_bounds_shift :
77           {84 * 32, 84 * 32 + 1, std::numeric_limits<int>::max()}) {
78        BigUnsigned<84> big_shifted = all_bits_one;
79        big_shifted.ShiftLeft(out_of_bounds_shift);
80        EXPECT_EQ(zero, big_shifted);
81        BigUnsigned<84> small_shifted = one;
82        small_shifted.ShiftLeft(out_of_bounds_shift);
83        EXPECT_EQ(zero, small_shifted);
84      }
85    }
86  }
87  TEST(BigUnsigned, MultiplyByUint32) {
88    const BigUnsigned<84> factorial_100(
89        "933262154439441526816992388562667004907159682643816214685929638952175999"
90        "932299156089414639761565182862536979208272237582511852109168640000000000"
91        "00000000000000");
92    BigUnsigned<84> a(1u);
93    for (uint32_t i = 1; i <= 100; ++i) {
94      a.MultiplyBy(i);
95    }
96    EXPECT_EQ(a, BigUnsigned<84>(factorial_100));
97  }
98  TEST(BigUnsigned, MultiplyByBigUnsigned) {
99    {
100      const BigUnsigned<84> factorial_200(
101          "7886578673647905035523632139321850622951359776871732632947425332443594"
102          "4996340334292030428401198462390417721213891963883025764279024263710506"
103          "1926624952829931113462857270763317237396988943922445621451664240254033"
104          "2918641312274282948532775242424075739032403212574055795686602260319041"
105          "7032406235170085879617892222278962370389737472000000000000000000000000"
106          "0000000000000000000000000");
107      BigUnsigned<84> evens(1u);
108      BigUnsigned<84> odds(1u);
109      for (uint32_t i = 1; i < 200; i += 2) {
110        odds.MultiplyBy(i);
111        evens.MultiplyBy(i + 1);
112      }
113      evens.MultiplyBy(odds);
114      EXPECT_EQ(evens, factorial_200);
115    }
116    {
117      for (int a = 0 ; a < 700; a += 25) {
118        SCOPED_TRACE(a);
119        BigUnsigned<84> a_value("3" + std::string(a, '0'));
120        for (int b = 0; b < (700 - a); b += 25) {
121          SCOPED_TRACE(b);
122          BigUnsigned<84> b_value("2" + std::string(b, '0'));
123          BigUnsigned<84> expected_product("6" + std::string(a + b, '0'));
124          b_value.MultiplyBy(a_value);
125          EXPECT_EQ(b_value, expected_product);
126        }
127      }
128    }
129  }
130  TEST(BigUnsigned, MultiplyByOverflow) {
131    {
132      BigUnsigned<4> all_bits_on("340282366920938463463374607431768211455");
133      all_bits_on.MultiplyBy(all_bits_on);
134      EXPECT_EQ(all_bits_on, BigUnsigned<4>(1u));
135    }
136    {
137      BigUnsigned<4> value_1("12345678901234567890123456789012345678");
138      BigUnsigned<4> value_2("12345678901234567890123456789012345678");
139      BigUnsigned<4> two_to_fiftieth(1u);
140      two_to_fiftieth.ShiftLeft(50);
141      value_1.ShiftLeft(50);
142      value_2.MultiplyBy(two_to_fiftieth);
143      EXPECT_EQ(value_1, value_2);
144    }
145  }
146  TEST(BigUnsigned, FiveToTheNth) {
<span onclick='openModal()' class='match'>147    {
148      for (int i = 0; i < 1160; ++i) {
149        SCOPED_TRACE(i);
150        BigUnsigned<84> value_1(123u);
151        BigUnsigned<84> value_2(123u);
152        value_1.MultiplyByFiveToTheNth(i);
153        for (int j = 0; j < i; j++) {
154          value_2.MultiplyBy(5u);
155        }
156        EXPECT_EQ(value_1, value_2);
157      }
158    }
</span>159    {
160      for (int i = 0; i < 1160; ++i) {
161        SCOPED_TRACE(i);
162        BigUnsigned<84> value_1(1u);
163        value_1.MultiplyByFiveToTheNth(i);
164        BigUnsigned<84> value_2 = BigUnsigned<84>::FiveToTheNth(i);
165        EXPECT_EQ(value_1, value_2);
166      }
167    }
168  }
169  TEST(BigUnsigned, TenToTheNth) {
170    {
171      for (int i = 0; i < 800; ++i) {
172        SCOPED_TRACE(i);
173        BigUnsigned<84> value_1(123u);
174        BigUnsigned<84> value_2(123u);
175        value_1.MultiplyByTenToTheNth(i);
176        for (int j = 0; j < i; j++) {
177          value_2.MultiplyBy(10u);
178        }
179        EXPECT_EQ(value_1, value_2);
180      }
181    }
182    {
183      for (int i = 0; i < 200; ++i) {
184        SCOPED_TRACE(i);
185        BigUnsigned<84> value_1(135u);
186        value_1.MultiplyByTenToTheNth(i);
187        BigUnsigned<84> value_2("135" + std::string(i, '0'));
188        EXPECT_EQ(value_1, value_2);
189      }
190    }
191  }
192  }  
193  ABSL_NAMESPACE_END
194  }  
</code></pre>
        </div>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-test_io.cpp</h3>
            <pre><code>1  #ifdef USE_OPENCV
2  #include <opencv2/core/core.hpp>
3  #include <opencv2/highgui/highgui.hpp>
4  #include <opencv2/highgui/highgui_c.h>
5  #include <opencv2/imgproc/imgproc.hpp>
6  #include <string>
7  #include "gtest/gtest.h"
8  #include "caffe/common.hpp"
9  #include "caffe/util/io.hpp"
10  #include "caffe/test/test_caffe_main.hpp"
11  namespace caffe {
12  class IOTest : public ::testing::Test {};
13  bool ReadImageToDatumReference(const string& filename, const int label,
14      const int height, const int width, const bool is_color, Datum* datum) {
15    cv::Mat cv_img;
16    int cv_read_flag = (is_color ? CV_LOAD_IMAGE_COLOR :
17      CV_LOAD_IMAGE_GRAYSCALE);
18    cv::Mat cv_img_origin = cv::imread(filename, cv_read_flag);
19    if (!cv_img_origin.data) {
20      LOG(ERROR) << "Could not open or find file " << filename;
21      return false;
22    }
23    if (height > 0 && width > 0) {
24      cv::resize(cv_img_origin, cv_img, cv::Size(width, height));
25    } else {
26      cv_img = cv_img_origin;
27    }
28    int num_channels = (is_color ? 3 : 1);
29    datum->set_channels(num_channels);
30    datum->set_height(cv_img.rows);
31    datum->set_width(cv_img.cols);
32    datum->set_label(label);
33    datum->clear_data();
34    datum->clear_float_data();
35    string* datum_string = datum->mutable_data();
36    if (is_color) {
37      for (int c = 0; c < num_channels; ++c) {
38        for (int h = 0; h < cv_img.rows; ++h) {
39          for (int w = 0; w < cv_img.cols; ++w) {
40            datum_string->push_back(
41              static_cast<char>(cv_img.at<cv::Vec3b>(h, w)[c]));
42          }
43        }
44      }
45    } else {  
46      for (int h = 0; h < cv_img.rows; ++h) {
47        for (int w = 0; w < cv_img.cols; ++w) {
48          datum_string->push_back(
49            static_cast<char>(cv_img.at<uchar>(h, w)));
50          }
51        }
52    }
53    return true;
54  }
55  TEST_F(IOTest, TestReadImageToDatum) {
56    string filename = EXAMPLES_SOURCE_DIR "images/cat.jpg";
57    Datum datum;
58    ReadImageToDatum(filename, 0, &datum);
59    EXPECT_EQ(datum.channels(), 3);
60    EXPECT_EQ(datum.height(), 360);
61    EXPECT_EQ(datum.width(), 480);
62  }
63  TEST_F(IOTest, TestReadImageToDatumReference) {
64    string filename = EXAMPLES_SOURCE_DIR "images/cat.jpg";
65    Datum datum, datum_ref;
66    ReadImageToDatum(filename, 0, 0, 0, true, &datum);
67    ReadImageToDatumReference(filename, 0, 0, 0, true, &datum_ref);
68    EXPECT_EQ(datum.channels(), datum_ref.channels());
69    EXPECT_EQ(datum.height(), datum_ref.height());
70    EXPECT_EQ(datum.width(), datum_ref.width());
71    EXPECT_EQ(datum.data().size(), datum_ref.data().size());
72    const string& data = datum.data();
73    const string& data_ref = datum.data();
74    for (int i = 0; i < datum.data().size(); ++i) {
75      EXPECT_TRUE(data[i] == data_ref[i]);
76    }
77  }
78  TEST_F(IOTest, TestReadImageToDatumReferenceResized) {
79    string filename = EXAMPLES_SOURCE_DIR "images/cat.jpg";
80    Datum datum, datum_ref;
81    ReadImageToDatum(filename, 0, 100, 200, true, &datum);
82    ReadImageToDatumReference(filename, 0, 100, 200, true, &datum_ref);
83    EXPECT_EQ(datum.channels(), datum_ref.channels());
84    EXPECT_EQ(datum.height(), datum_ref.height());
85    EXPECT_EQ(datum.width(), datum_ref.width());
86    EXPECT_EQ(datum.data().size(), datum_ref.data().size());
87    const string& data = datum.data();
88    const string& data_ref = datum.data();
89    for (int i = 0; i < datum.data().size(); ++i) {
90      EXPECT_TRUE(data[i] == data_ref[i]);
91    }
92  }
93  TEST_F(IOTest, TestReadImageToDatumContent) {
94    string filename = EXAMPLES_SOURCE_DIR "images/cat.jpg";
95    Datum datum;
96    ReadImageToDatum(filename, 0, &datum);
97    cv::Mat cv_img = ReadImageToCVMat(filename);
98    EXPECT_EQ(datum.channels(), cv_img.channels());
99    EXPECT_EQ(datum.height(), cv_img.rows);
100    EXPECT_EQ(datum.width(), cv_img.cols);
101    const string& data = datum.data();
102    int index = 0;
103    for (int c = 0; c < datum.channels(); ++c) {
104      for (int h = 0; h < datum.height(); ++h) {
105        for (int w = 0; w < datum.width(); ++w) {
106          EXPECT_TRUE(data[index++] ==
107            static_cast<char>(cv_img.at<cv::Vec3b>(h, w)[c]));
108        }
109      }
110    }
111  }
112  TEST_F(IOTest, TestReadImageToDatumContentGray) {
113    string filename = EXAMPLES_SOURCE_DIR "images/cat.jpg";
114    Datum datum;
115    const bool is_color = false;
116    ReadImageToDatum(filename, 0, is_color, &datum);
117    cv::Mat cv_img = ReadImageToCVMat(filename, is_color);
118    EXPECT_EQ(datum.channels(), cv_img.channels());
119    EXPECT_EQ(datum.height(), cv_img.rows);
120    EXPECT_EQ(datum.width(), cv_img.cols);
121    const string& data = datum.data();
122    int index = 0;
123    for (int h = 0; h < datum.height(); ++h) {
124      for (int w = 0; w < datum.width(); ++w) {
125        EXPECT_TRUE(data[index++] == static_cast<char>(cv_img.at<uchar>(h, w)));
126      }
127    }
128  }
129  TEST_F(IOTest, TestReadImageToDatumResized) {
130    string filename = EXAMPLES_SOURCE_DIR "images/cat.jpg";
131    Datum datum;
132    ReadImageToDatum(filename, 0, 100, 200, &datum);
133    EXPECT_EQ(datum.channels(), 3);
134    EXPECT_EQ(datum.height(), 100);
135    EXPECT_EQ(datum.width(), 200);
136  }
137  TEST_F(IOTest, TestReadImageToDatumResizedSquare) {
138    string filename = EXAMPLES_SOURCE_DIR "images/cat.jpg";
139    Datum datum;
140    ReadImageToDatum(filename, 0, 256, 256, &datum);
141    EXPECT_EQ(datum.channels(), 3);
142    EXPECT_EQ(datum.height(), 256);
143    EXPECT_EQ(datum.width(), 256);
144  }
145  TEST_F(IOTest, TestReadImageToDatumGray) {
146    string filename = EXAMPLES_SOURCE_DIR "images/cat.jpg";
147    Datum datum;
148    const bool is_color = false;
149    ReadImageToDatum(filename, 0, is_color, &datum);
150    EXPECT_EQ(datum.channels(), 1);
151    EXPECT_EQ(datum.height(), 360);
152    EXPECT_EQ(datum.width(), 480);
153  }
154  TEST_F(IOTest, TestReadImageToDatumResizedGray) {
155    string filename = EXAMPLES_SOURCE_DIR "images/cat.jpg";
156    Datum datum;
157    const bool is_color = false;
158    ReadImageToDatum(filename, 0, 256, 256, is_color, &datum);
159    EXPECT_EQ(datum.channels(), 1);
160    EXPECT_EQ(datum.height(), 256);
161    EXPECT_EQ(datum.width(), 256);
162  }
163  TEST_F(IOTest, TestReadImageToCVMat) {
164    string filename = EXAMPLES_SOURCE_DIR "images/cat.jpg";
165    cv::Mat cv_img = ReadImageToCVMat(filename);
166    EXPECT_EQ(cv_img.channels(), 3);
167    EXPECT_EQ(cv_img.rows, 360);
168    EXPECT_EQ(cv_img.cols, 480);
169  }
170  TEST_F(IOTest, TestReadImageToCVMatResized) {
171    string filename = EXAMPLES_SOURCE_DIR "images/cat.jpg";
172    cv::Mat cv_img = ReadImageToCVMat(filename, 100, 200);
173    EXPECT_EQ(cv_img.channels(), 3);
174    EXPECT_EQ(cv_img.rows, 100);
175    EXPECT_EQ(cv_img.cols, 200);
176  }
177  TEST_F(IOTest, TestReadImageToCVMatResizedSquare) {
178    string filename = EXAMPLES_SOURCE_DIR "images/cat.jpg";
179    cv::Mat cv_img = ReadImageToCVMat(filename, 256, 256);
180    EXPECT_EQ(cv_img.channels(), 3);
181    EXPECT_EQ(cv_img.rows, 256);
182    EXPECT_EQ(cv_img.cols, 256);
183  }
184  TEST_F(IOTest, TestReadImageToCVMatGray) {
185    string filename = EXAMPLES_SOURCE_DIR "images/cat.jpg";
186    const bool is_color = false;
187    cv::Mat cv_img = ReadImageToCVMat(filename, is_color);
188    EXPECT_EQ(cv_img.channels(), 1);
189    EXPECT_EQ(cv_img.rows, 360);
190    EXPECT_EQ(cv_img.cols, 480);
191  }
192  TEST_F(IOTest, TestReadImageToCVMatResizedGray) {
193    string filename = EXAMPLES_SOURCE_DIR "images/cat.jpg";
194    const bool is_color = false;
195    cv::Mat cv_img = ReadImageToCVMat(filename, 256, 256, is_color);
196    EXPECT_EQ(cv_img.channels(), 1);
197    EXPECT_EQ(cv_img.rows, 256);
198    EXPECT_EQ(cv_img.cols, 256);
199  }
200  TEST_F(IOTest, TestCVMatToDatum) {
201    string filename = EXAMPLES_SOURCE_DIR "images/cat.jpg";
202    cv::Mat cv_img = ReadImageToCVMat(filename);
203    Datum datum;
204    CVMatToDatum(cv_img, &datum);
205    EXPECT_EQ(datum.channels(), 3);
206    EXPECT_EQ(datum.height(), 360);
207    EXPECT_EQ(datum.width(), 480);
208  }
209  TEST_F(IOTest, TestCVMatToDatumContent) {
210    string filename = EXAMPLES_SOURCE_DIR "images/cat.jpg";
211    cv::Mat cv_img = ReadImageToCVMat(filename);
212    Datum datum;
213    CVMatToDatum(cv_img, &datum);
214    Datum datum_ref;
215    ReadImageToDatum(filename, 0, &datum_ref);
216    EXPECT_EQ(datum.channels(), datum_ref.channels());
217    EXPECT_EQ(datum.height(), datum_ref.height());
218    EXPECT_EQ(datum.width(), datum_ref.width());
219    EXPECT_EQ(datum.data().size(), datum_ref.data().size());
220    const string& data = datum.data();
221    const string& data_ref = datum_ref.data();
222    for (int i = 0; i < datum.data().size(); ++i) {
223      EXPECT_TRUE(data[i] == data_ref[i]);
224    }
225  }
226  TEST_F(IOTest, TestCVMatToDatumReference) {
227    string filename = EXAMPLES_SOURCE_DIR "images/cat.jpg";
228    cv::Mat cv_img = ReadImageToCVMat(filename);
229    Datum datum;
230    CVMatToDatum(cv_img, &datum);
231    Datum datum_ref;
232    ReadImageToDatumReference(filename, 0, 0, 0, true, &datum_ref);
233    EXPECT_EQ(datum.channels(), datum_ref.channels());
234    EXPECT_EQ(datum.height(), datum_ref.height());
235    EXPECT_EQ(datum.width(), datum_ref.width());
236    EXPECT_EQ(datum.data().size(), datum_ref.data().size());
237    const string& data = datum.data();
238    const string& data_ref = datum_ref.data();
239    for (int i = 0; i < datum.data().size(); ++i) {
240      EXPECT_TRUE(data[i] == data_ref[i]);
241    }
242  }
243  TEST_F(IOTest, TestReadFileToDatum) {
244    string filename = EXAMPLES_SOURCE_DIR "images/cat.jpg";
245    Datum datum;
246    EXPECT_TRUE(ReadFileToDatum(filename, &datum));
247    EXPECT_TRUE(datum.encoded());
248    EXPECT_EQ(datum.label(), -1);
249    EXPECT_EQ(datum.data().size(), 140391);
250  }
251  TEST_F(IOTest, TestDecodeDatum) {
252    string filename = EXAMPLES_SOURCE_DIR "images/cat.jpg";
253    Datum datum;
254    EXPECT_TRUE(ReadFileToDatum(filename, &datum));
255    EXPECT_TRUE(DecodeDatum(&datum, true));
256    EXPECT_FALSE(DecodeDatum(&datum, true));
257    Datum datum_ref;
258    ReadImageToDatumReference(filename, 0, 0, 0, true, &datum_ref);
259    EXPECT_EQ(datum.channels(), datum_ref.channels());
260    EXPECT_EQ(datum.height(), datum_ref.height());
261    EXPECT_EQ(datum.width(), datum_ref.width());
262    EXPECT_EQ(datum.data().size(), datum_ref.data().size());
263    const string& data = datum.data();
264    const string& data_ref = datum_ref.data();
265    for (int i = 0; i < datum.data().size(); ++i) {
266      EXPECT_TRUE(data[i] == data_ref[i]);
267    }
268  }
269  TEST_F(IOTest, TestDecodeDatumToCVMat) {
270    string filename = EXAMPLES_SOURCE_DIR "images/cat.jpg";
271    Datum datum;
272    EXPECT_TRUE(ReadFileToDatum(filename, &datum));
273    cv::Mat cv_img = DecodeDatumToCVMat(datum, true);
274    EXPECT_EQ(cv_img.channels(), 3);
275    EXPECT_EQ(cv_img.rows, 360);
276    EXPECT_EQ(cv_img.cols, 480);
277    cv_img = DecodeDatumToCVMat(datum, false);
278    EXPECT_EQ(cv_img.channels(), 1);
279    EXPECT_EQ(cv_img.rows, 360);
280    EXPECT_EQ(cv_img.cols, 480);
281  }
282  TEST_F(IOTest, TestDecodeDatumToCVMatContent) {
283    string filename = EXAMPLES_SOURCE_DIR "images/cat.jpg";
284    Datum datum;
285    EXPECT_TRUE(ReadImageToDatum(filename, 0, std::string("jpg"), &datum));
286    cv::Mat cv_img = DecodeDatumToCVMat(datum, true);
287    cv::Mat cv_img_ref = ReadImageToCVMat(filename);
288    EXPECT_EQ(cv_img_ref.channels(), cv_img.channels());
289    EXPECT_EQ(cv_img_ref.rows, cv_img.rows);
290    EXPECT_EQ(cv_img_ref.cols, cv_img.cols);
291    for (int c = 0; c < datum.channels(); ++c) {
292      for (int h = 0; h < datum.height(); ++h) {
293        for (int w = 0; w < datum.width(); ++w) {
294          EXPECT_TRUE(cv_img.at<cv::Vec3b>(h, w)[c]==
295            cv_img_ref.at<cv::Vec3b>(h, w)[c]);
296        }
297      }
298    }
299  }
300  TEST_F(IOTest, TestDecodeDatumNative) {
301    string filename = EXAMPLES_SOURCE_DIR "images/cat.jpg";
302    Datum datum;
303    EXPECT_TRUE(ReadFileToDatum(filename, &datum));
304    EXPECT_TRUE(DecodeDatumNative(&datum));
305    EXPECT_FALSE(DecodeDatumNative(&datum));
306    Datum datum_ref;
307    ReadImageToDatumReference(filename, 0, 0, 0, true, &datum_ref);
308    EXPECT_EQ(datum.channels(), datum_ref.channels());
309    EXPECT_EQ(datum.height(), datum_ref.height());
310    EXPECT_EQ(datum.width(), datum_ref.width());
311    EXPECT_EQ(datum.data().size(), datum_ref.data().size());
312    const string& data = datum.data();
313    const string& data_ref = datum_ref.data();
314    for (int i = 0; i < datum.data().size(); ++i) {
315      EXPECT_TRUE(data[i] == data_ref[i]);
316    }
317  }
318  TEST_F(IOTest, TestDecodeDatumToCVMatNative) {
319    string filename = EXAMPLES_SOURCE_DIR "images/cat.jpg";
320    Datum datum;
321    EXPECT_TRUE(ReadFileToDatum(filename, &datum));
322    cv::Mat cv_img = DecodeDatumToCVMatNative(datum);
323    EXPECT_EQ(cv_img.channels(), 3);
324    EXPECT_EQ(cv_img.rows, 360);
325    EXPECT_EQ(cv_img.cols, 480);
326  }
327  TEST_F(IOTest, TestDecodeDatumNativeGray) {
328    string filename = EXAMPLES_SOURCE_DIR "images/cat_gray.jpg";
329    Datum datum;
330    EXPECT_TRUE(ReadFileToDatum(filename, &datum));
331    EXPECT_TRUE(DecodeDatumNative(&datum));
332    EXPECT_FALSE(DecodeDatumNative(&datum));
333    Datum datum_ref;
334    ReadImageToDatumReference(filename, 0, 0, 0, false, &datum_ref);
335    EXPECT_EQ(datum.channels(), datum_ref.channels());
336    EXPECT_EQ(datum.height(), datum_ref.height());
337    EXPECT_EQ(datum.width(), datum_ref.width());
338    EXPECT_EQ(datum.data().size(), datum_ref.data().size());
339    const string& data = datum.data();
340    const string& data_ref = datum_ref.data();
341    for (int i = 0; i < datum.data().size(); ++i) {
342      EXPECT_TRUE(data[i] == data_ref[i]);
343    }
344  }
345  TEST_F(IOTest, TestDecodeDatumToCVMatNativeGray) {
346    string filename = EXAMPLES_SOURCE_DIR "images/cat_gray.jpg";
347    Datum datum;
348    EXPECT_TRUE(ReadFileToDatum(filename, &datum));
349    cv::Mat cv_img = DecodeDatumToCVMatNative(datum);
350    EXPECT_EQ(cv_img.channels(), 1);
351    EXPECT_EQ(cv_img.rows, 360);
352    EXPECT_EQ(cv_img.cols, 480);
353  }
354  TEST_F(IOTest, TestDecodeDatumToCVMatContentNative) {
355    string filename = EXAMPLES_SOURCE_DIR "images/cat.jpg";
356    Datum datum;
357    EXPECT_TRUE(ReadImageToDatum(filename, 0, std::string("jpg"), &datum));
358    cv::Mat cv_img = DecodeDatumToCVMatNative(datum);
359    cv::Mat cv_img_ref = ReadImageToCVMat(filename);
360    EXPECT_EQ(cv_img_ref.channels(), cv_img.channels());
361    EXPECT_EQ(cv_img_ref.rows, cv_img.rows);
362    EXPECT_EQ(cv_img_ref.cols, cv_img.cols);
<span onclick='openModal()' class='match'>363    for (int c = 0; c < datum.channels(); ++c) {
364      for (int h = 0; h < datum.height(); ++h) {
365        for (int w = 0; w < datum.width(); ++w) {
366          EXPECT_TRUE(cv_img.at<cv::Vec3b>(h, w)[c]==
367            cv_img_ref.at<cv::Vec3b>(h, w)[c]);
368        }
369      }
370    }
</span>371  }
372  }  
373  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-charconv_bigint_test.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-test_io.cpp</div>
                </div>
                <div class="column column_space"><pre><code>147    {
148      for (int i = 0; i < 1160; ++i) {
149        SCOPED_TRACE(i);
150        BigUnsigned<84> value_1(123u);
151        BigUnsigned<84> value_2(123u);
152        value_1.MultiplyByFiveToTheNth(i);
153        for (int j = 0; j < i; j++) {
154          value_2.MultiplyBy(5u);
155        }
156        EXPECT_EQ(value_1, value_2);
157      }
158    }
</pre></code></div>
                <div class="column column_space"><pre><code>363    for (int c = 0; c < datum.channels(); ++c) {
364      for (int h = 0; h < datum.height(); ++h) {
365        for (int w = 0; w < datum.width(); ++w) {
366          EXPECT_TRUE(cv_img.at<cv::Vec3b>(h, w)[c]==
367            cv_img_ref.at<cv::Vec3b>(h, w)[c]);
368        }
369      }
370    }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    