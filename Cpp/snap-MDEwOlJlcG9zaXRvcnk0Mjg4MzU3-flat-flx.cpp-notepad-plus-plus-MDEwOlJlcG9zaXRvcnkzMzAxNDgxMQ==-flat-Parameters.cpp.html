
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 3.409850679741475%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-flx.cpp</h3>
            <pre><code>1  const int TCs::MxMask=0x0FFFFFFF;
2  TCs TCs::GetCsFromBf(char* Bf, const int& BfL){
3    TCs Cs;
4    for (int BfC=0; BfC<BfL; BfC++){Cs+=Bf[BfC];}
5    return Cs;
6  }
7  TStr TSBase::GetSNm() const {
8    return TStr(SNm.CStr());
9  }
10  TSIn::TSIn(const TStr& Str):
11    TSBase(Str.CStr()), FastMode(false){}
12  void TSIn::LoadCs(){
13    TCs CurCs=Cs; TCs TestCs;
14    Cs+=GetBf(&TestCs, sizeof(TestCs));
15    EAssertR(CurCs==TestCs, "Invalid checksum reading '"+GetSNm()+"'.");
16  }
17  void TSIn::Load(char*& CStr){
18    char Ch; Load(Ch);
19    int CStrLen=int(Ch);
20    EAssertR(CStrLen>=0, "Error reading stream '"+GetSNm()+"'.");
21    CStr=new char[CStrLen+1];
22    if (CStrLen>0){Cs+=GetBf(CStr, CStrLen);}
23    CStr[CStrLen]=TCh::NullCh;
24  }
25  const PSIn TSIn::StdIn=PSIn(new TStdIn());
26  TSOut::TSOut(const TStr& Str):
27    TSBase(Str.CStr()), MxLnLen(-1), LnLen(0){}
28  int TSOut::UpdateLnLen(const int& StrLen, const bool& ForceInLn){
29    int Cs=0;
30    if (MxLnLen!=-1){
31      if ((!ForceInLn)&&(LnLen+StrLen>MxLnLen)){Cs+=PutLn();}
32      LnLen+=StrLen;
33    }
34    return Cs;
35  }
36  int TSOut::PutMem(const TMem& Mem){
37    return PutBf(Mem(), Mem.Len());
38  }
39  int TSOut::PutCh(const char& Ch, const int& Chs){
40    int Cs=0;
41    for (int ChN=0; ChN<Chs; ChN++){Cs+=PutCh(Ch);}
42    return Cs;
43  }
44  int TSOut::PutBool(const bool& Bool){
45    return PutStr(TBool::GetStr(Bool));
46  }
47  int TSOut::PutInt(const int& Int){
48    return PutStr(TInt::GetStr(Int));
49  }
50  int TSOut::PutInt(const int& Int, char* FmtStr){
51    return PutStr(TInt::GetStr(Int, FmtStr));
52  }
53  int TSOut::PutUInt(const uint& UInt){
54    return PutStr(TUInt::GetStr(UInt));
55  }
56  int TSOut::PutUInt(const uint& UInt, char* FmtStr){
57    return PutStr(TUInt::GetStr(UInt, FmtStr));
58  }
59  int TSOut::PutFlt(const double& Flt){
60    return PutStr(TFlt::GetStr(Flt));
61  }
62  int TSOut::PutFlt(const double& Flt, char* FmtStr){
63    return PutStr(TFlt::GetStr(Flt, FmtStr));
64  }
65  int TSOut::PutStr(const char* CStr){
66    int Cs=UpdateLnLen(int(strlen(CStr)));
67    return Cs+PutBf(CStr, int(strlen(CStr)));
68  }
69  int TSOut::PutStr(const TChA& ChA){
70    int Cs=UpdateLnLen(ChA.Len());
71    return Cs+PutBf(ChA.CStr(), ChA.Len());
72  }
73  int TSOut::PutStr(const TStr& Str, char* FmtStr){
74    return PutStr(TStr::GetStr(Str, FmtStr));
75  }
76  int TSOut::PutStr(const TStr& Str, const bool& ForceInLn){
77    int Cs=UpdateLnLen(Str.Len(), ForceInLn);
78    return Cs+PutBf(Str.CStr(), Str.Len());
79  }
80  int TSOut::PutIndent(const int& IndentLev){
81    return PutCh(' ', IndentLev*2);
82  }
83  int TSOut::PutLn(const int& Lns){
84    LnLen=0; int Cs=0;
85    for (int LnN=0; LnN<Lns; LnN++){Cs+=PutCh('\n');}
86    return Cs;
87  }
88  int TSOut::PutDosLn(const int& Lns){
89    LnLen=0; int Cs=0;
90    for (int LnN=0; LnN<Lns; LnN++){Cs+=PutCh(TCh::CrCh)+PutCh(TCh::LfCh);}
91    return Cs;
92  }
93  int TSOut::PutSep(const int& NextStrLen){
94    int Cs=0;
95    if (MxLnLen==-1){
96      Cs+=PutCh(' ');
97    } else {
98      if (LnLen>0){
99        if (LnLen+1+NextStrLen>MxLnLen){Cs+=PutLn();} else {Cs+=PutCh(' ');}
100      }
101    }
102    return Cs;
103  }
104  int TSOut::PutSepLn(const int& Lns){
105    int Cs=0;
106    if (LnLen>0){Cs+=PutLn();}
107    Cs+=PutLn(Lns);
108    return Cs;
109  }
110  void TSOut::Save(const char* CStr){
111    int CStrLen=int(strlen(CStr));
112    EAssertR(CStrLen<=127, "Error writting stream '"+GetSNm()+"'.");
113    Save(char(CStrLen));
114    if (CStrLen>0){Cs+=PutBf(CStr, CStrLen);}
115  }
116  void TSOut::Save(TSIn& SIn, const int& BfL){
117    if (BfL==-1){
118      while (!SIn.Eof()){Save(SIn.GetCh());}
119    } else {
120      for (int BfC=0; BfC<BfL; BfC++){Save(SIn.GetCh());}
121    }
122  }
123  TSOut& TSOut::operator<<(TSIn& SIn) {
124    while (!SIn.Eof())
125      operator<<((char)SIn.GetCh());
126    return *this;
127  }
128  const PSOut TSOut::StdOut=PSOut(new TStdOut());
129  int TStdIn::GetBf(const void* LBf, const int& LBfL){
130    int LBfS=0;
131    for (int LBfC=0; LBfC<LBfL; LBfC++){
132      LBfS+=(((char*)LBf)[LBfC]=GetCh());}
133    return LBfS;
134  }
135  int TStdOut::PutBf(const void* LBf, const int& LBfL){
136    int LBfS=0;
137    for (int LBfC=0; LBfC<LBfL; LBfC++){
138      LBfS+=PutCh(((char*)LBf)[LBfC]);}
139    return LBfS;
140  }
141  const int TFIn::MxBfL=16*1024;
142  void TFIn::SetFPos(const int& FPos) const {
143    EAssertR(
144     fseek(FileId, FPos, SEEK_SET)==0,
145     "Error seeking into file '"+GetSNm()+"'.");
146  }
147  int TFIn::GetFPos() const {
148    const int FPos=ftell(FileId);
149    EAssertR(FPos!=-1, "Error seeking into file '"+GetSNm()+"'.");
150    return FPos;
151  }
152  int TFIn::GetFLen() const {
153    const int FPos=GetFPos();
154    EAssertR(
155     fseek(FileId, 0, SEEK_END)==0,
156     "Error seeking into file '"+GetSNm()+"'.");
157    const int FLen=GetFPos(); SetFPos(FPos);
158    return FLen;
159  }
160  void TFIn::FillBf(){
161    EAssertR(
162     (BfC==BfL)&&((BfL==-1)||(BfL==MxBfL)),
163     "Error reading file '"+GetSNm()+"'.");
164    BfL=int(fread(Bf, 1, MxBfL, FileId));
165    EAssertR((BfC!=0)||(BfL!=0), "Error reading file '"+GetSNm()+"'.");
166    BfC=0;
167  }
168  TFIn::TFIn(const TStr& FNm):
169    TSIn(FNm), FileId(NULL), Bf(NULL), BfC(0), BfL(0){
170    EAssertR(!FNm.Empty(), "Empty file-name.");
171    FileId=fopen(FNm.CStr(), "rb");
172    EAssertR(FileId!=NULL, "Can not open file '"+FNm+"'.");
173    Bf=new char[MxBfL]; BfC=BfL=-1; FillBf();
174  }
175  TFIn::TFIn(const TStr& FNm, bool& OpenedP):
176    TSIn(FNm), FileId(NULL), Bf(NULL), BfC(0), BfL(0){
177    EAssertR(!FNm.Empty(), "Empty file-name.");
178    FileId=fopen(FNm.CStr(), "rb");
179    OpenedP=(FileId!=NULL);
180    if (OpenedP){
181      Bf=new char[MxBfL]; BfC=BfL=-1; FillBf();}
182  }
183  PSIn TFIn::New(const TStr& FNm){
184    return PSIn(new TFIn(FNm));
185  }
186  PSIn TFIn::New(const TStr& FNm, bool& OpenedP){
187    return PSIn(new TFIn(FNm, OpenedP));
188  }
189  TFIn::~TFIn(){
190    if (FileId!=NULL){
191      EAssertR(fclose(FileId)==0, "Can not close file '"+GetSNm()+"'.");}
192    if (Bf!=NULL){delete[] Bf;}
193  }
194  int TFIn::GetBf(const void* LBf, const int& LBfL){
195    int LBfS=0;
196    if (BfC+LBfL>BfL){
197      for (int LBfC=0; LBfC<LBfL; LBfC++){
198        if (BfC==BfL){FillBf();}
199        LBfS+=((char*)LBf)[LBfC]=Bf[BfC++];}
200    } else {
201      for (int LBfC=0; LBfC<LBfL; LBfC++){
202        LBfS+=(((char*)LBf)[LBfC]=Bf[BfC++]);}
203    }
204    return LBfS;
205  }
206  const int TFOut::MxBfL=16*1024;;
207  void TFOut::FlushBf(){
208    EAssertR(
209     (int)fwrite(Bf, 1, BfL, FileId)==BfL,
210     "Error writting to the file '"+GetSNm()+"'.");
211    BfL=0;
212  }
213  TFOut::TFOut(const TStr& FNm, const bool& Append):
214    TSOut(FNm), FileId(NULL), Bf(NULL), BfL(0){
215    if (FNm.GetUc()=="CON"){
216      FileId=stdout;
217    } else {
218      if (Append){FileId=fopen(FNm.CStr(), "a+b");}
219      else {FileId=fopen(FNm.CStr(), "w+b");}
220      EAssertR(FileId!=NULL, "Can not open file '"+FNm+"'.");
221      Bf=new char[MxBfL]; BfL=0;
222    }
223  }
224  TFOut::TFOut(const TStr& FNm, const bool& Append, bool& OpenedP):
225    TSOut(FNm), FileId(NULL), Bf(NULL), BfL(0){
226    if (FNm.GetUc()=="CON"){
227      FileId=stdout;
228    } else {
229      if (Append){FileId=fopen(FNm.CStr(), "a+b");}
230      else {FileId=fopen(FNm.CStr(), "w+b");}
231      OpenedP=(FileId!=NULL);
232      if (OpenedP){
233        Bf=new char[MxBfL]; BfL=0;}
234    }
235  }
236  PSOut TFOut::New(const TStr& FNm, const bool& Append){
237    return PSOut(new TFOut(FNm, Append));
238  }
239  PSOut TFOut::New(const TStr& FNm, const bool& Append, bool& OpenedP){
240    PSOut SOut=PSOut(new TFOut(FNm, Append, OpenedP));
241    if (OpenedP){return SOut;} else {return NULL;}
242  }
243  TFOut::~TFOut(){
244    if (FileId!=NULL){FlushBf();}
245    if (Bf!=NULL){delete[] Bf;}
246    if (FileId!=NULL){
247      EAssertR(fclose(FileId)==0, "Can not close file '"+GetSNm()+"'.");}
248  }
249  int TFOut::PutCh(const char& Ch){
250    if (BfL==MxBfL){FlushBf();}
251    return Bf[BfL++]=Ch;
252  }
253  int TFOut::PutBf(const void* LBf, const int& LBfL){
254    int LBfS=0;
255    if (BfL+LBfL>MxBfL){
256      for (int LBfC=0; LBfC<LBfL; LBfC++){
257        LBfS+=PutCh(((char*)LBf)[LBfC]);}
258    } else {
259      for (int LBfC=0; LBfC<LBfL; LBfC++){
260        LBfS+=(Bf[BfL++]=((char*)LBf)[LBfC]);}
261    }
262    return LBfS;
263  }
264  void TFOut::Flush(){
265    FlushBf();
266    EAssertR(fflush(FileId)==0, "Can not flush file '"+GetSNm()+"'.");
267  }
268  TFInOut::TFInOut(const TStr& FNm, const TFAccess& FAccess, const bool& CreateIfNo) :
269   TSBase(TSStr(FNm.CStr())), FileId(NULL) {
270    switch (FAccess){
271      case faCreate: FileId=fopen(FNm.CStr(), "w+b"); break;
272      case faUpdate: FileId=fopen(FNm.CStr(), "r+b"); break;
273      case faAppend: FileId=fopen(FNm.CStr(), "r+b");
274        if (FileId!=NULL){fseek(FileId, SEEK_END, 0);} break;
275      case faRdOnly: FileId=fopen(FNm.CStr(), "rb"); break;
276      default: Fail;
277    }
278    if ((FileId==NULL)&&(CreateIfNo)){FileId=fopen(FNm.CStr(), "w+b");}
279    IAssert(FileId!=NULL);
280  }
281  PSInOut TFInOut::New(const TStr& FNm, const TFAccess& FAccess, const bool& CreateIfNo) {
282    return PSInOut(new TFInOut(FNm, FAccess, CreateIfNo));
283  }
284  int TFInOut::GetSize() const {
285    const int FPos = GetPos();
286    IAssert(fseek(FileId, 0, SEEK_END) == 0);
287    const int FLen = GetPos();
288    IAssert(fseek(FileId, FPos, SEEK_SET) == 0);
289    return FLen;
290  }
291  int TFInOut::PutBf(const void* LBf, const int& LBfL) {
292    int LBfS = 0;
293    for (int i = 0; i < LBfL; i++) {
294      LBfS += ((char *)LBf)[i];
295    }
296    IAssert(fwrite(LBf, sizeof(char), LBfL, FileId) == (size_t) LBfL);
297    return LBfS;;
298  }
299  int TFInOut::GetBf(const void* LBf, const int& LBfL) {
300    IAssert(fread((void *)LBf, sizeof(char), LBfL, FileId) == (size_t) LBfL);
301    int LBfS = 0;
302    for (int i = 0; i < LBfL; i++) {
303      LBfS += ((char *)LBf)[i];
304    }
305    return LBfS;
306  }
307  TStr TFInOut::GetFNm() const {
308    return GetSNm();
309  }
310  TMIn::TMIn(const void* _Bf, const int& _BfL, const bool& TakeBf, const bool& _Free):
311    TSIn("Input-Memory"), Bf(NULL), BfC(0), BfL(_BfL), Free(_Free){
312    if (TakeBf){
313      Bf=(char*)_Bf;
314    } else {
315      Bf=new char[BfL]; memmove(Bf, _Bf, BfL);
316    }
317  }
318  TMIn::TMIn(TSIn& SIn):
319    TSIn("Input-Memory"), Bf(NULL), BfC(0), BfL(0){
320    BfL=SIn.Len(); Bf=new char[BfL];
321    for (int BfC=0; BfC<BfL; BfC++){Bf[BfC]=SIn.GetCh();}
322  }
323  TMIn::TMIn(const char* CStr):
324    TSIn("Input-Memory"), Bf(NULL), BfC(0), BfL(0){
325    BfL=int(strlen(CStr)); Bf=new char[BfL+1]; strcpy(Bf, CStr);
326  }
327  TMIn::TMIn(const TStr& Str):
328    TSIn("Input-Memory"), Bf(NULL), BfC(0), BfL(0){
329    BfL=Str.Len(); Bf=new char[BfL]; strncpy(Bf, Str.CStr(), BfL);
330  }
331  TMIn::TMIn(const TChA& ChA):
332    TSIn("Input-Memory"), Bf(NULL), BfC(0), BfL(0){
333    BfL=ChA.Len(); Bf=new char[BfL]; strncpy(Bf, ChA.CStr(), BfL);
334  }
335  PSIn TMIn::New(const char* CStr){
336    return PSIn(new TMIn(CStr));
337  }
338  PSIn TMIn::New(const TStr& Str){
339    return PSIn(new TMIn(Str));
340  }
341  PSIn TMIn::New(const TChA& ChA){
342    return PSIn(new TMIn(ChA));
343  }
344  char TMIn::GetCh(){
345    EAssertR(BfC<BfL, "Reading beyond the end of stream.");
346    return Bf[BfC++];
347  }
348  char TMIn::PeekCh(){
349    EAssertR(BfC<BfL, "Reading beyond the end of stream.");
350    return Bf[BfC];
351  }
352  int TMIn::GetBf(const void* LBf, const int& LBfL){
353    EAssertR(BfC+LBfL<=BfL, "Reading beyond the end of stream.");
354    int LBfS=0;
355    for (int LBfC=0; LBfC<LBfL; LBfC++){
356      LBfS+=(((char*)LBf)[LBfC]=Bf[BfC++]);}
357    return LBfS;
358  }
359  void TMOut::Resize(){
360    IAssert(OwnBf&&(BfL==MxBfL));
361    if (Bf==NULL){
362      IAssert(MxBfL==0); Bf=new char[MxBfL=1024];
363    } else {
364      MxBfL*=2; char* NewBf=new char[MxBfL];
365      memmove(NewBf, Bf, BfL); delete[] Bf; Bf=NewBf;
366    }
367  }
368  TMOut::TMOut(const int& _MxBfL):
369    TSOut("Output-Memory"),
370    Bf(NULL), BfL(0), MxBfL(0), OwnBf(true){
371    MxBfL=_MxBfL>0?_MxBfL:1024;
372    Bf=new char[MxBfL];
373  }
374  TMOut::TMOut(char* _Bf, const int& _MxBfL):
375    TSOut("Output-Memory"),
376    Bf(_Bf), BfL(0), MxBfL(_MxBfL), OwnBf(false){}
377  int TMOut::PutBf(const void* LBf, const int& LBfL){
378    int LBfS=0;
379    if (BfL+LBfL>MxBfL){
380      for (int LBfC=0; LBfC<LBfL; LBfC++){
381        LBfS+=PutCh(((char*)LBf)[LBfC]);}
382    } else {
383      for (int LBfC=0; LBfC<LBfL; LBfC++){
384        LBfS+=(Bf[BfL++]=((char*)LBf)[LBfC]);}
385    }
386    return LBfS;
387  }
388  TStr TMOut::GetAsStr() const {
389    TChA ChA(BfL);
390    for (int BfC=0; BfC<BfL; BfC++){ChA+=Bf[BfC];}
391    return ChA;
392  }
393  void TMOut::CutBf(const int& CutBfL){
394    IAssert((0<=CutBfL)&&(CutBfL<=BfL));
<span onclick='openModal()' class='match'>395    if (CutBfL==BfL){BfL=0;}
396    else {memmove(Bf, Bf+CutBfL, BfL-CutBfL); BfL=BfL-CutBfL;}
397  }
</span>398  PSIn TMOut::GetSIn(const bool& IsCut, const int& CutBfL){
399    IAssert((CutBfL==-1)||((0<=CutBfL)));
400    int SInBfL= (CutBfL==-1) ? BfL : TInt::GetMn(BfL, CutBfL);
401    PSIn SIn;
402    if (OwnBf&&IsCut&&(SInBfL==BfL)){
403      SIn=PSIn(new TMIn(Bf, SInBfL, true));
404      Bf=NULL; BfL=MxBfL=0; OwnBf=true;
405    } else {
406      SIn=PSIn(new TMIn(Bf, SInBfL, false));
407      if (IsCut){CutBf(SInBfL);}
408    }
409    return SIn;
410  }
411  bool TMOut::IsCrLfLn() const {
412    for (int BfC=0; BfC<BfL; BfC++){
413      if ((Bf[BfC]==TCh::CrCh)&&((BfC+1<BfL)&&(Bf[BfC+1]==TCh::LfCh))){return true;}}
414    return false;
415  }
416  TStr TMOut::GetCrLfLn(){
417    IAssert(IsCrLfLn());
418    TChA Ln;
419    for (int BfC=0; BfC<BfL; BfC++){
420      char Ch=Bf[BfC];
421      if ((Ch==TCh::CrCh)&&((BfC+1<BfL)&&(Bf[BfC+1]==TCh::LfCh))){
422        Ln+=TCh::CrCh; Ln+=TCh::LfCh; CutBf(BfC+1+1); break;
423      } else {
424        Ln+=Ch;
425      }
426    }
427    return Ln;
428  }
429  bool TMOut::IsEolnLn() const {
430    for (int BfC=0; BfC<BfL; BfC++){
431      if ((Bf[BfC]==TCh::CrCh)||(Bf[BfC]==TCh::LfCh)){return true;}
432    }
433    return false;
434  }
435  TStr TMOut::GetEolnLn(const bool& DoAddEoln, const bool& DoCutBf){
436    IAssert(IsEolnLn());
437    int LnChs=0; TChA Ln;
438    for (int BfC=0; BfC<BfL; BfC++){
439      char Ch=Bf[BfC];
440      if ((Ch==TCh::CrCh)||(Ch==TCh::LfCh)){
441        LnChs++; if (DoAddEoln){Ln+=Ch;}
442        if (BfC+1<BfL){
443          char NextCh=Bf[BfC+1];
444          if (((Ch==TCh::CrCh)&&(NextCh==TCh::LfCh))||
445           ((Ch==TCh::LfCh)&&(NextCh==TCh::CrCh))){
446            LnChs++; if (DoAddEoln){Ln+=NextCh;}
447          }
448        }
449        break;
450      } else {
451        LnChs++; Ln+=Ch;
452      }
453    }
454    if (DoCutBf){
455      CutBf(LnChs);
456    }
457    return Ln;
458  }
459  void TMOut::MkEolnLn(){
460    if (!IsEolnLn()){
461      PutCh(TCh::CrCh); PutCh(TCh::LfCh);}
462  }
463  #ifndef SEEK_SET
464  #define SEEK_CUR    1
465  #define SEEK_END    2
466  #define SEEK_SET    0
467  #endif
468  void TFRnd::RefreshFPos(){
469    EAssertR(
470     fseek(FileId, 0, SEEK_CUR)==0,
471     "Error seeking into file '"+FNm+"'.");
472  }
473  TFRnd::TFRnd(const TStr& _FNm, const TFAccess& FAccess,
474   const bool& CreateIfNo, const int& _HdLen, const int& _RecLen):
475    FileId(NULL), FNm(_FNm.CStr()),
476    RecAct(false), HdLen(_HdLen), RecLen(_RecLen){
477    RecAct=(HdLen>=0)&&(RecLen>0);
478    switch (FAccess){
479      case faCreate: FileId=fopen(FNm.CStr(), "w+b"); break;
480      case faUpdate: FileId=fopen(FNm.CStr(), "r+b"); break;
481      case faAppend: FileId=fopen(FNm.CStr(), "r+b");
482        if (FileId!=NULL){fseek(FileId, SEEK_END, 0);} break;
483      case faRdOnly: FileId=fopen(FNm.CStr(), "rb"); break;
484      default: Fail;
485    }
486    if ((FileId==NULL)&&(CreateIfNo)){
487      FileId=fopen(FNm.CStr(), "w+b");}
488    EAssertR(FileId!=NULL, "Can not open file '"+_FNm+"'.");
489  }
490  TFRnd::~TFRnd(){
491    EAssertR(fclose(FileId)==0, "Can not close file '"+FNm+"'.");
492  }
493  TStr TFRnd::GetFNm() const {
494    return FNm.CStr();
495  }
496  void TFRnd::SetFPos(const int& FPos){
497    EAssertR(
498     fseek(FileId, FPos, SEEK_SET)==0,
499     "Error seeking into file '"+FNm+"'.");
500  }
501  void TFRnd::MoveFPos(const int& DFPos){
502    EAssertR(
503     fseek(FileId, DFPos, SEEK_CUR)==0,
504     "Error seeking into file '"+FNm+"'.");
505  }
506  int TFRnd::GetFPos(){
507    int FPos=ftell(FileId);
508    EAssertR(FPos!=-1, "Error seeking into file '"+FNm+"'.");
509    return FPos;
510  }
511  int TFRnd::GetFLen(){
512    int FPos=GetFPos();
513    EAssertR(
514     fseek(FileId, 0, SEEK_END)==0,
515     "Error seeking into file '"+FNm+"'.");
516    int FLen=GetFPos(); SetFPos(FPos); return FLen;
517  }
518  void TFRnd::SetRecN(const int& RecN){
519    IAssert(RecAct);
520    SetFPos(HdLen+RecN*RecLen);
521  }
522  int TFRnd::GetRecN(){
523    IAssert(RecAct);
524    int FPos=GetFPos()-HdLen;
525    EAssertR(FPos%RecLen==0, "Invalid position in file'"+FNm+"'.");
526    return FPos/RecLen;
527  }
528  int TFRnd::GetRecs(){
529    IAssert(RecAct);
530    int FLen=GetFLen()-HdLen;
531    EAssertR(FLen%RecLen==0, "Invalid length of file'"+FNm+"'.");
532    return FLen/RecLen;
533  }
534  void TFRnd::GetBf(void* Bf, const int& BfL){
535    RefreshFPos();
536    EAssertR(
537     int(fread(Bf, 1, BfL, FileId))==BfL,
538     "Error reading file '"+FNm+"'.");
539  }
540  void TFRnd::PutBf(const void* Bf, const int& BfL){
541    RefreshFPos();
542    EAssertR(
543     int(fwrite(Bf, 1, BfL, FileId))==BfL,
544     "Error writting to the file '"+FNm+"'.");
545  }
546  void TFRnd::Flush(){
547    EAssertR(fflush(FileId)==0, "Can not flush file '"+FNm+"'.");
548  }
549  void TFRnd::PutCh(const char& Ch, const int& Chs){
550    if (Chs>0){
551      char* CStr=new char[Chs];
552      for (int ChN=0; ChN<Chs; ChN++){CStr[ChN]=Ch;}
553      PutBf(CStr, Chs);
554      delete[] CStr;
555    }
556  }
557  void TFRnd::PutStr(const TStr& Str){
558    PutBf(Str.CStr(), Str.Len()+1);
559  }
560  TStr TFRnd::GetStr(const int& StrLen, bool& IsOk){
561    IsOk=false; TStr Str;
562    if (GetFPos()+StrLen+1<=GetFLen()){
563      char* CStr=new char[StrLen+1];
564      GetBf(CStr, StrLen+1);
565      if (CStr[StrLen+1-1]==TCh::NullCh){IsOk=true; Str=CStr;}
566      delete[] CStr;
567    }
568    return Str;
569  }
570  TStr TFRnd::GetStr(const int& StrLen){
571    TStr Str;
572    char* CStr=new char[StrLen+1];
573    GetBf(CStr, StrLen+1);
574    EAssertR(CStr[StrLen+1-1]==TCh::NullCh, "Error reading file '"+FNm+"'.");
575    Str=CStr;
576    delete[] CStr;
577    return Str;
578  }
579  void TFRnd::PutSIn(const PSIn& SIn, TCs& Cs){
580    int BfL=SIn->Len();
581    char* Bf=new char[BfL];
582    SIn->GetBf(Bf, BfL);
583    Cs=TCs::GetCsFromBf(Bf, BfL);
584    PutBf(Bf, BfL);
585    delete[] Bf;
586  }
587  PSIn TFRnd::GetSIn(const int& BfL, TCs& Cs){
588    char* Bf=new char[BfL];
589    GetBf(Bf, BfL);
590    Cs=TCs::GetCsFromBf(Bf, BfL);
591    PSIn SIn=PSIn(new TMIn(Bf, BfL, true));
592    return SIn;
593  }
594  TStr TFRnd::GetStrFromFAccess(const TFAccess& FAccess){
595    switch (FAccess){
596      case faCreate: return "Create";
597      case faUpdate: return "Update";
598      case faAppend: return "Append";
599      case faRdOnly: return "ReadOnly";
600      case faRestore: return "Restore";
601      default: Fail; return TStr();
602    }
603  }
604  TFAccess TFRnd::GetFAccessFromStr(const TStr& Str){
605    TStr UcStr=Str.GetUc();
606    if (UcStr=="CREATE"){return faCreate;}
607    if (UcStr=="UPDATE"){return faUpdate;}
608    if (UcStr=="APPEND"){return faAppend;}
609    if (UcStr=="READONLY"){return faRdOnly;}
610    if (UcStr=="RESTORE"){return faRestore;}
611    if (UcStr=="NEW"){return faCreate;}
612    if (UcStr=="CONT"){return faUpdate;}
613    if (UcStr=="CONTINUE"){return faUpdate;}
614    if (UcStr=="REST"){return faRestore;}
615    if (UcStr=="RESTORE"){return faRestore;}
616    return faUndef;
617  }
618  const TStr TFile::TxtFExt=".Txt";
619  const TStr TFile::HtmlFExt=".Html";
620  const TStr TFile::HtmFExt=".Htm";
621  const TStr TFile::GifFExt=".Gif";
622  const TStr TFile::JarFExt=".Jar";
623  bool TFile::Exists(const TStr& FNm){
624    bool DoExists;
625    TFIn FIn(FNm, DoExists);
626    return DoExists;
627  }
628  void TFile::Del(const TStr& FNm, const bool& ThrowExceptP){
629    if (ThrowExceptP){
630      EAssertR(
631       remove(FNm.CStr())==0,
632       "Error removing file '"+FNm+"'.");
633    } else {
634      remove(FNm.CStr());
635    }
636  }
637  void TFile::DelWc(const TStr& WcStr, const bool& RecurseDirP){
638    TStrV FNmV;
639    TFFile FFile(WcStr, RecurseDirP); TStr FNm;
640    while (FFile.Next(FNm)){
641      FNmV.Add(FNm);}
642    for (int FNmN=0; FNmN<FNmV.Len(); FNmN++){
643      Del(FNmV[FNmN], false);}
644  }
645  void TFile::Rename(const TStr& SrcFNm, const TStr& DstFNm){
646    EAssertR(
647     rename(SrcFNm.CStr(), DstFNm.CStr())==0,
648     "Error renaming file '"+SrcFNm+"' to "+DstFNm+"'.");
649  }
650  TStr TFile::GetUniqueFNm(const TStr& FNm){
651    int Cnt=1; int ch;
652    TStr NewFNm; TStr TmpFNm=FNm;
653    if (FNm.SearchCh('#') == -1) {
654      for (ch = FNm.Len()-1; ch >= 0; ch--) if (FNm[ch] == '.') break;
655      if (ch != -1) TmpFNm.InsStr(ch, ".#");
656      else TmpFNm += ".#";
657    }
658    forever{
659      NewFNm=TmpFNm;
660      NewFNm.ChangeStr("#", TStr::Fmt("%03d", Cnt)); Cnt++;
661      if (!TFile::Exists(NewFNm)){break;}
662    }
663    return NewFNm;
664  }
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-Parameters.cpp</h3>
            <pre><code>1  #include <time.h>
2  #include <shlwapi.h>
3  #include <shlobj.h>
4  #include "Parameters.h"
5  #include "ScintillaEditView.h"
6  #include "keys.h"
7  #include "localization.h"
8  #include "localizationString.h"
9  #include "UserDefineDialog.h"
10  #include "WindowsDlgRc.h"
11  #ifdef _MSC_VER
12  #pragma warning(disable : 4996) 
13  #endif
14  using namespace std;
15  namespace 
16  {
17  struct WinMenuKeyDefinition 
18  {
19  	int vKey;
20  	int functionId;
21  	bool isCtrl;
22  	bool isAlt;
23  	bool isShift;
24  	const TCHAR * specialName;		
25  };
26  struct ScintillaKeyDefinition
27  {
28  	const TCHAR * name;
29  	int functionId;
30  	bool isCtrl;
31  	bool isAlt;
32  	bool isShift;
33  	int vKey;
34  	int redirFunctionId;	
35  };
36  static const WinMenuKeyDefinition winKeyDefs[] =
37  {
38  	{ VK_N,       IDM_FILE_NEW,                                 true,  false, false, nullptr },
39  	{ VK_O,       IDM_FILE_OPEN,                                true,  false, false, nullptr },
40  	{ VK_NULL,    IDM_FILE_OPEN_FOLDER,                         false, false, false, TEXT("Open containing folder in Explorer") },
41  	{ VK_NULL,    IDM_FILE_OPEN_CMD,                            false, false, false, TEXT("Open containing folder in Command Prompt") },
42  	{ VK_NULL,    IDM_FILE_OPEN_DEFAULT_VIEWER,                 false, false, false, nullptr },
43  	{ VK_NULL,    IDM_FILE_OPENFOLDERASWORSPACE,                false, false, false, nullptr },
44  	{ VK_R,       IDM_FILE_RELOAD,                              true,  false, false, nullptr },
45  	{ VK_S,       IDM_FILE_SAVE,                                true,  false, false, nullptr },
46  	{ VK_S,       IDM_FILE_SAVEAS,                              true,  true,  false, nullptr },
47  	{ VK_NULL,    IDM_FILE_SAVECOPYAS,                          false, false, false, nullptr },
48  	{ VK_S,       IDM_FILE_SAVEALL,                             true,  false, true,  nullptr },
49  	{ VK_NULL,    IDM_FILE_RENAME,                              false, false, false, nullptr },
50  	{ VK_W,       IDM_FILE_CLOSE,                               true,  false, false, nullptr },
51  	{ VK_W,       IDM_FILE_CLOSEALL,                            true,  false, true,  nullptr },
52  	{ VK_NULL,    IDM_FILE_CLOSEALL_BUT_CURRENT,                false, false, false, nullptr },
53  	{ VK_NULL,    IDM_FILE_CLOSEALL_TOLEFT,                     false, false, false, nullptr },
54  	{ VK_NULL,    IDM_FILE_CLOSEALL_TORIGHT,                    false, false, false, nullptr },
55  	{ VK_NULL,    IDM_FILE_CLOSEALL_UNCHANGED,                  false, false, false, nullptr },
56  	{ VK_NULL,    IDM_FILE_DELETE,                              false, false, false, nullptr },
57  	{ VK_NULL,    IDM_FILE_LOADSESSION,                         false, false, false, nullptr },
58  	{ VK_NULL,    IDM_FILE_SAVESESSION,                         false, false, false, nullptr },
59  	{ VK_P,       IDM_FILE_PRINT,                               true,  false, false, nullptr },
60  	{ VK_NULL,    IDM_FILE_PRINTNOW,                            false, false, false, nullptr },
61  	{ VK_F4,      IDM_FILE_EXIT,                                false, true,  false, nullptr },
62  	{ VK_T,       IDM_FILE_RESTORELASTCLOSEDFILE,               true,  false, true,  TEXT("Restore Recent Closed File")},
63  	{ VK_B,       IDM_EDIT_BEGINENDSELECT,                      true,  false, true,  nullptr },
64  	{ VK_B,       IDM_EDIT_BEGINENDSELECT_COLUMNMODE,           false, true,  true,  nullptr },
65  	{ VK_NULL,    IDM_EDIT_FULLPATHTOCLIP,                      false, false, false, nullptr },
66  	{ VK_NULL,    IDM_EDIT_FILENAMETOCLIP,                      false, false, false, nullptr },
67  	{ VK_NULL,    IDM_EDIT_CURRENTDIRTOCLIP,                    false, false, false, nullptr },
68  	{ VK_NULL,    IDM_EDIT_COPY_ALL_NAMES,                      false, false, false, nullptr },
69  	{ VK_NULL,    IDM_EDIT_COPY_ALL_PATHS,                      false, false, false, nullptr },
70  	{ VK_NULL,    IDM_EDIT_INS_TAB,                             false, false, false, nullptr },
71  	{ VK_NULL,    IDM_EDIT_RMV_TAB,                             false, false, false, nullptr },
72  	{ VK_U,       IDM_EDIT_UPPERCASE,                           true,  false, true,  nullptr },
73  	{ VK_U,       IDM_EDIT_LOWERCASE,                           true,  false, false, nullptr },
74  	{ VK_U,       IDM_EDIT_PROPERCASE_FORCE,                    false, true,  false, nullptr },
75  	{ VK_U,       IDM_EDIT_PROPERCASE_BLEND,                    false, true,  true,  nullptr },
76  	{ VK_U,       IDM_EDIT_SENTENCECASE_FORCE,                  true,  true,  false, nullptr },
77  	{ VK_U,       IDM_EDIT_SENTENCECASE_BLEND,                  true,  true,  true,  nullptr },
78  	{ VK_NULL,    IDM_EDIT_INVERTCASE,                          false, false, false, nullptr },
79  	{ VK_NULL,    IDM_EDIT_RANDOMCASE,                          false, false, false, nullptr },
80  	{ VK_NULL,    IDM_EDIT_REMOVE_CONSECUTIVE_DUP_LINES,        false, false, false, nullptr },
81  	{ VK_NULL,    IDM_EDIT_REMOVE_ANY_DUP_LINES,                false, false, false, nullptr },
82  	{ VK_I,       IDM_EDIT_SPLIT_LINES,                         true,  false, false, nullptr },
83  	{ VK_J,       IDM_EDIT_JOIN_LINES,                          true,  false, false, nullptr },
84  	{ VK_UP,      IDM_EDIT_LINE_UP,                             true,  false, true,  nullptr },
85  	{ VK_DOWN,    IDM_EDIT_LINE_DOWN,                           true,  false, true,  nullptr },
86  	{ VK_NULL,    IDM_EDIT_REMOVEEMPTYLINES,                    false, false, false, nullptr },
87  	{ VK_NULL,    IDM_EDIT_REMOVEEMPTYLINESWITHBLANK,           false, false, false, nullptr },
88  	{ VK_RETURN,  IDM_EDIT_BLANKLINEABOVECURRENT,               true,  true,  false, nullptr },
89  	{ VK_RETURN,  IDM_EDIT_BLANKLINEBELOWCURRENT,               true,  true,  true,  nullptr },
90  	{ VK_NULL,    IDM_EDIT_SORTLINES_LEXICOGRAPHIC_ASCENDING,   false, false, false, nullptr },
91  	{ VK_NULL,    IDM_EDIT_SORTLINES_LEXICOGRAPHIC_DESCENDING,  false, false, false, nullptr },
92  	{ VK_NULL,    IDM_EDIT_SORTLINES_LEXICO_CASE_INSENS_ASCENDING,   false, false, false, nullptr },
93  	{ VK_NULL,    IDM_EDIT_SORTLINES_LEXICO_CASE_INSENS_DESCENDING,  false, false, false, nullptr },
94  	{ VK_NULL,    IDM_EDIT_SORTLINES_INTEGER_ASCENDING,         false, false, false, nullptr },
95  	{ VK_NULL,    IDM_EDIT_SORTLINES_INTEGER_DESCENDING,        false, false, false, nullptr },
96  	{ VK_NULL,    IDM_EDIT_SORTLINES_DECIMALCOMMA_ASCENDING,    false, false, false, nullptr },
97  	{ VK_NULL,    IDM_EDIT_SORTLINES_DECIMALCOMMA_DESCENDING,   false, false, false, nullptr },
98  	{ VK_NULL,    IDM_EDIT_SORTLINES_DECIMALDOT_ASCENDING,      false, false, false, nullptr },
99  	{ VK_NULL,    IDM_EDIT_SORTLINES_DECIMALDOT_DESCENDING,     false, false, false, nullptr },
100  	{ VK_NULL,    IDM_EDIT_SORTLINES_REVERSE_ORDER,             false, false, false, nullptr },
101  	{ VK_NULL,    IDM_EDIT_SORTLINES_RANDOMLY,                  false, false, false, nullptr },
102  	{ VK_Q,       IDM_EDIT_BLOCK_COMMENT,                       true,  false, false, nullptr },
103  	{ VK_K,       IDM_EDIT_BLOCK_COMMENT_SET,                   true,  false, false, nullptr },
104  	{ VK_K,       IDM_EDIT_BLOCK_UNCOMMENT,                     true,  false, true,  nullptr },
105  	{ VK_Q,       IDM_EDIT_STREAM_COMMENT,                      true,  false, true,  nullptr },
106  	{ VK_NULL,    IDM_EDIT_STREAM_UNCOMMENT,                    false, false, false, nullptr },
107  	{ VK_SPACE,   IDM_EDIT_AUTOCOMPLETE,                        true,  false, false, nullptr },
108  	{ VK_SPACE,   IDM_EDIT_AUTOCOMPLETE_PATH,                   true,  true,  false, nullptr },
109  	{ VK_RETURN,  IDM_EDIT_AUTOCOMPLETE_CURRENTFILE,            true,  false, false, nullptr },
110  	{ VK_SPACE,   IDM_EDIT_FUNCCALLTIP,                         true,  false, true,  nullptr },
111  	{ VK_UP,      IDM_EDIT_FUNCCALLTIP_PREVIOUS,                false, true,  false, nullptr },
112  	{ VK_DOWN,    IDM_EDIT_FUNCCALLTIP_NEXT,                    false, true,  false, nullptr },
113  	{ VK_NULL,    IDM_EDIT_INSERT_DATETIME_SHORT,               false, false, false, nullptr },
114  	{ VK_NULL,    IDM_EDIT_INSERT_DATETIME_LONG,                false, false, false, nullptr },
115  	{ VK_NULL,    IDM_EDIT_INSERT_DATETIME_CUSTOMIZED,          false, false, false, nullptr },
116  	{ VK_NULL,    IDM_FORMAT_TODOS,                             false, false, false, TEXT("EOL Conversion to Windows (CR LF)") },
117  	{ VK_NULL,    IDM_FORMAT_TOUNIX,                            false, false, false, TEXT("EOL Conversion to Unix (LF)") },
118  	{ VK_NULL,    IDM_FORMAT_TOMAC,                             false, false, false, TEXT("EOL Conversion to Macintosh (CR)") },
119  	{ VK_NULL,    IDM_EDIT_TRIMTRAILING,                        false, false, false, nullptr },
120  	{ VK_NULL,    IDM_EDIT_TRIMLINEHEAD,                        false, false, false, nullptr },
121  	{ VK_NULL,    IDM_EDIT_TRIM_BOTH,                           false, false, false, nullptr },
122  	{ VK_NULL,    IDM_EDIT_EOL2WS,                              false, false, false, nullptr },
123  	{ VK_NULL,    IDM_EDIT_TRIMALL,                             false, false, false, nullptr },
124  	{ VK_NULL,    IDM_EDIT_TAB2SW,                              false, false, false, nullptr },
125  	{ VK_NULL,    IDM_EDIT_SW2TAB_ALL,                          false, false, false, nullptr },
126  	{ VK_NULL,    IDM_EDIT_SW2TAB_LEADING,                      false, false, false, nullptr },
127  	{ VK_NULL,    IDM_EDIT_PASTE_AS_HTML,                       false, false, false, nullptr },
128  	{ VK_NULL,    IDM_EDIT_PASTE_AS_RTF,                        false, false, false, nullptr },
129  	{ VK_NULL,    IDM_EDIT_COPY_BINARY,                         false, false, false, nullptr },
130  	{ VK_NULL,    IDM_EDIT_CUT_BINARY,                          false, false, false, nullptr },
131  	{ VK_NULL,    IDM_EDIT_PASTE_BINARY,                        false, false, false, nullptr },
132  	{ VK_NULL,    IDM_EDIT_OPENASFILE,                          false, false, false, nullptr },
133  	{ VK_NULL,    IDM_EDIT_OPENINFOLDER,                        false, false, false, nullptr },
134  	{ VK_NULL,    IDM_EDIT_SEARCHONINTERNET,                    false, false, false, nullptr },
135  	{ VK_NULL,    IDM_EDIT_CHANGESEARCHENGINE,                  false, false, false, nullptr },
136  	{ VK_C,       IDM_EDIT_COLUMNMODE,                          false, true,  false, nullptr },
137  	{ VK_NULL,    IDM_EDIT_CHAR_PANEL,                          false, false, false, TEXT("Toggle Character Panel") },
138  	{ VK_NULL,    IDM_EDIT_CLIPBOARDHISTORY_PANEL,              false, false, false, TEXT("Toggle Clipboard History") },
139  	{ VK_NULL,    IDM_EDIT_SETREADONLY,                         false, false, false, nullptr },
140  	{ VK_NULL,    IDM_EDIT_CLEARREADONLY,                       false, false, false, nullptr },
141  	{ VK_F,       IDM_SEARCH_FIND,                              true,  false, false, nullptr },
142  	{ VK_F,       IDM_SEARCH_FINDINFILES,                       true,  false, true,  nullptr },
143  	{ VK_F3,      IDM_SEARCH_FINDNEXT,                          false, false, false, nullptr },
144  	{ VK_F3,      IDM_SEARCH_FINDPREV,                          false, false, true,  nullptr },
145  	{ VK_F3,      IDM_SEARCH_SETANDFINDNEXT,                    true,  false, false, nullptr },
146  	{ VK_F3,      IDM_SEARCH_SETANDFINDPREV,                    true,  false, true,  nullptr },
147  	{ VK_F3,      IDM_SEARCH_VOLATILE_FINDNEXT,                 true,  true,  false, nullptr },
148  	{ VK_F3,      IDM_SEARCH_VOLATILE_FINDPREV,                 true,  true,  true,  nullptr },
149  	{ VK_H,       IDM_SEARCH_REPLACE,                           true,  false, false, nullptr },
150  	{ VK_I,       IDM_SEARCH_FINDINCREMENT,                     true,  true,  false, nullptr },
151  	{ VK_F7,      IDM_FOCUS_ON_FOUND_RESULTS,                   false, false, false, nullptr },
152  	{ VK_F4,      IDM_SEARCH_GOTOPREVFOUND,                     false, false, true,  nullptr },
153  	{ VK_F4,      IDM_SEARCH_GOTONEXTFOUND,                     false, false, false, nullptr },
154  	{ VK_G,       IDM_SEARCH_GOTOLINE,                          true,  false, false, nullptr },
155  	{ VK_B,       IDM_SEARCH_GOTOMATCHINGBRACE,                 true,  false, false, nullptr },
156  	{ VK_B,       IDM_SEARCH_SELECTMATCHINGBRACES,              true,  true,  false, nullptr },
157  	{ VK_M,       IDM_SEARCH_MARK,                              true,  false, false, nullptr },
158  	{ VK_NULL,    IDM_SEARCH_MARKALLEXT1,                       false, false, false, TEXT("Style all using 1st style") },
159  	{ VK_NULL,    IDM_SEARCH_MARKALLEXT2,                       false, false, false, TEXT("Style all using 2nd style") },
160  	{ VK_NULL,    IDM_SEARCH_MARKALLEXT3,                       false, false, false, TEXT("Style all using 3rd style") },
161  	{ VK_NULL,    IDM_SEARCH_MARKALLEXT4,                       false, false, false, TEXT("Style all using 4th style") },
162  	{ VK_NULL,    IDM_SEARCH_MARKALLEXT5,                       false, false, false, TEXT("Style all using 5th style") },
163  	{ VK_NULL,    IDM_SEARCH_MARKONEEXT1,                       false, false, false, TEXT("Style one using 1st style") },
164  	{ VK_NULL,    IDM_SEARCH_MARKONEEXT2,                       false, false, false, TEXT("Style one using 2nd style") },
165  	{ VK_NULL,    IDM_SEARCH_MARKONEEXT3,                       false, false, false, TEXT("Style one using 3rd style") },
166  	{ VK_NULL,    IDM_SEARCH_MARKONEEXT4,                       false, false, false, TEXT("Style one using 4th style") },
167  	{ VK_NULL,    IDM_SEARCH_MARKONEEXT5,                       false, false, false, TEXT("Style one using 5th style") },
168  	{ VK_NULL,    IDM_SEARCH_UNMARKALLEXT1,                     false, false, false, TEXT("Clear 1st style") },
169  	{ VK_NULL,    IDM_SEARCH_UNMARKALLEXT2,                     false, false, false, TEXT("Clear 2nd style") },
170  	{ VK_NULL,    IDM_SEARCH_UNMARKALLEXT3,                     false, false, false, TEXT("Clear 3rd style") },
171  	{ VK_NULL,    IDM_SEARCH_UNMARKALLEXT4,                     false, false, false, TEXT("Clear 4th style") },
172  	{ VK_NULL,    IDM_SEARCH_UNMARKALLEXT5,                     false, false, false, TEXT("Clear 5th style") },
173  	{ VK_NULL,    IDM_SEARCH_CLEARALLMARKS,                     false, false, false, TEXT("Clear all styles") },
174  	{ VK_1,       IDM_SEARCH_GOPREVMARKER1,                     true,  false, true,  TEXT("Previous style of 1st style") },
175  	{ VK_2,       IDM_SEARCH_GOPREVMARKER2,                     true,  false, true,  TEXT("Previous style of 2nd style") },
176  	{ VK_3,       IDM_SEARCH_GOPREVMARKER3,                     true,  false, true,  TEXT("Previous style of 3rd style") },
177  	{ VK_4,       IDM_SEARCH_GOPREVMARKER4,                     true,  false, true,  TEXT("Previous style of 4th style") },
178  	{ VK_5,       IDM_SEARCH_GOPREVMARKER5,                     true,  false, true,  TEXT("Previous style of 5th style") },
179  	{ VK_0,       IDM_SEARCH_GOPREVMARKER_DEF,                  true,  false, true,  TEXT("Previous style of Find Mark style") },
180  	{ VK_1,       IDM_SEARCH_GONEXTMARKER1,                     true,  false, false, TEXT("Next style of 1st style") },
181  	{ VK_2,       IDM_SEARCH_GONEXTMARKER2,                     true,  false, false, TEXT("Next style of 2nd style") },
182  	{ VK_3,       IDM_SEARCH_GONEXTMARKER3,                     true,  false, false, TEXT("Next style of 3rd style") },
183  	{ VK_4,       IDM_SEARCH_GONEXTMARKER4,                     true,  false, false, TEXT("Next style of 4th style") },
184  	{ VK_5,       IDM_SEARCH_GONEXTMARKER5,                     true,  false, false, TEXT("Next style of 5th style") },
185  	{ VK_0,       IDM_SEARCH_GONEXTMARKER_DEF,                  true,  false, false, TEXT("Next style of Find Mark style") },
186  	{ VK_NULL,    IDM_SEARCH_STYLE1TOCLIP,                      false, false, false, TEXT("Copy Styled Text of 1st Style") },
187  	{ VK_NULL,    IDM_SEARCH_STYLE2TOCLIP,                      false, false, false, TEXT("Copy Styled Text of 2nd Style") },
188  	{ VK_NULL,    IDM_SEARCH_STYLE3TOCLIP,                      false, false, false, TEXT("Copy Styled Text of 3rd Style") },
189  	{ VK_NULL,    IDM_SEARCH_STYLE4TOCLIP,                      false, false, false, TEXT("Copy Styled Text of 4th Style") },
190  	{ VK_NULL,    IDM_SEARCH_STYLE5TOCLIP,                      false, false, false, TEXT("Copy Styled Text of 5th Style") },
191  	{ VK_NULL,    IDM_SEARCH_ALLSTYLESTOCLIP,                   false, false, false, TEXT("Copy Styled Text of All Styles") },
192  	{ VK_NULL,    IDM_SEARCH_MARKEDTOCLIP,                      false, false, false, TEXT("Copy Styled Text of Find Mark style") },
193  	{ VK_F2,      IDM_SEARCH_TOGGLE_BOOKMARK,                   true,  false, false, nullptr },
194  	{ VK_F2,      IDM_SEARCH_NEXT_BOOKMARK,                     false, false, false, nullptr },
195  	{ VK_F2,      IDM_SEARCH_PREV_BOOKMARK,                     false, false, true, nullptr  },
196  	{ VK_NULL,    IDM_SEARCH_CLEAR_BOOKMARKS,                   false, false, false, nullptr },
197  	{ VK_NULL,    IDM_SEARCH_CUTMARKEDLINES,                    false, false, false, nullptr },
198  	{ VK_NULL,    IDM_SEARCH_COPYMARKEDLINES,                   false, false, false, nullptr },
199  	{ VK_NULL,    IDM_SEARCH_PASTEMARKEDLINES,                  false, false, false, nullptr },
200  	{ VK_NULL,    IDM_SEARCH_DELETEMARKEDLINES,                 false, false, false, nullptr },
201  	{ VK_NULL,    IDM_SEARCH_DELETEUNMARKEDLINES,               false, false, false, nullptr },
202  	{ VK_NULL,    IDM_SEARCH_INVERSEMARKS,                      false, false, false, nullptr },
203  	{ VK_NULL,    IDM_SEARCH_FINDCHARINRANGE,                   false, false, false, nullptr },
204  	{ VK_NULL,    IDM_VIEW_ALWAYSONTOP,                         false, false, false, nullptr },
205  	{ VK_F11,     IDM_VIEW_FULLSCREENTOGGLE,                    false, false, false, nullptr },
206  	{ VK_F12,     IDM_VIEW_POSTIT,                              false, false, false, nullptr },
207  	{ VK_NULL,    IDM_VIEW_DISTRACTIONFREE,                     false, false, false, nullptr },
208  	{ VK_NULL,    IDM_VIEW_IN_FIREFOX,                          false, false, false, TEXT("View current file in Firefox") },
209  	{ VK_NULL,    IDM_VIEW_IN_CHROME,                           false, false, false, TEXT("View current file in Chrome") },
210  	{ VK_NULL,    IDM_VIEW_IN_IE,                               false, false, false, TEXT("View current file in IE") },
211  	{ VK_NULL,    IDM_VIEW_IN_EDGE,                             false, false, false, TEXT("View current file in Edge")  },
212  	{ VK_NULL,    IDM_VIEW_TAB_SPACE,                           false, false, false, nullptr },
213  	{ VK_NULL,    IDM_VIEW_EOL,                                 false, false, false, nullptr },
214  	{ VK_NULL,    IDM_VIEW_ALL_CHARACTERS,                      false, false, false, nullptr },
215  	{ VK_NULL,    IDM_VIEW_NPC,                                 false, false, false, nullptr },
216  	{ VK_NULL,    IDM_VIEW_NPC_CCUNIEOL,                        false, false, false, nullptr },
217  	{ VK_NULL,    IDM_VIEW_INDENT_GUIDE,                        false, false, false, nullptr },
218  	{ VK_NULL,    IDM_VIEW_WRAP_SYMBOL,                         false, false, false, nullptr },
219  	{ VK_NULL,    IDM_VIEW_GOTO_ANOTHER_VIEW,                   false, false, false, nullptr },
220  	{ VK_NULL,    IDM_VIEW_CLONE_TO_ANOTHER_VIEW,               false, false, false, nullptr },
221  	{ VK_NULL,    IDM_VIEW_GOTO_NEW_INSTANCE,                   false, false, false, nullptr },
222  	{ VK_NULL,    IDM_VIEW_LOAD_IN_NEW_INSTANCE,                false, false, false, nullptr },
223  	{ VK_NUMPAD1, IDM_VIEW_TAB1,                                true,  false, false, nullptr },
224  	{ VK_NUMPAD2, IDM_VIEW_TAB2,                                true,  false, false, nullptr },
225  	{ VK_NUMPAD3, IDM_VIEW_TAB3,                                true,  false, false, nullptr },
226  	{ VK_NUMPAD4, IDM_VIEW_TAB4,                                true,  false, false, nullptr },
227  	{ VK_NUMPAD5, IDM_VIEW_TAB5,                                true,  false, false, nullptr },
228  	{ VK_NUMPAD6, IDM_VIEW_TAB6,                                true,  false, false, nullptr },
229  	{ VK_NUMPAD7, IDM_VIEW_TAB7,                                true,  false, false, nullptr },
230  	{ VK_NUMPAD8, IDM_VIEW_TAB8,                                true,  false, false, nullptr },
231  	{ VK_NUMPAD9, IDM_VIEW_TAB9,                                true,  false, false, nullptr },
232  	{ VK_NEXT,    IDM_VIEW_TAB_NEXT,                            true,  false, false, nullptr },
233  	{ VK_PRIOR,   IDM_VIEW_TAB_PREV,                            true,  false, false, nullptr },
234  	{ VK_NEXT,    IDM_VIEW_TAB_MOVEFORWARD,                     true,  false, true,  nullptr },
235  	{ VK_PRIOR,   IDM_VIEW_TAB_MOVEBACKWARD,                    true,  false, true,  nullptr },
236  	{ VK_TAB,     IDC_PREV_DOC,                                 true,  false, true,  TEXT("Switch to previous document") },
237  	{ VK_TAB,     IDC_NEXT_DOC,                                 true,  false, false, TEXT("Switch to next document") },
238  	{ VK_NULL,    IDM_VIEW_WRAP,                                false, false, false, nullptr },
239  	{ VK_H,       IDM_VIEW_HIDELINES,                           false, true,  false, nullptr },
240  	{ VK_F8,      IDM_VIEW_SWITCHTO_OTHER_VIEW,                 false, false, false, nullptr },
241  	{ VK_0,       IDM_VIEW_FOLDALL,                             false, true,  false, nullptr },
242  	{ VK_0,       IDM_VIEW_UNFOLDALL,                           false, true,  true,  nullptr },
243  	{ VK_F,       IDM_VIEW_FOLD_CURRENT,                        true,  true,  false, nullptr },
244  	{ VK_F,       IDM_VIEW_UNFOLD_CURRENT,                      true,  true,  true,  nullptr },
245  	{ VK_1,       IDM_VIEW_FOLD_1,                              false, true,  false, TEXT("Fold Level 1") },
246  	{ VK_2,       IDM_VIEW_FOLD_2,                              false, true,  false, TEXT("Fold Level 2") },
247  	{ VK_3,       IDM_VIEW_FOLD_3,                              false, true,  false, TEXT("Fold Level 3") },
248  	{ VK_4,       IDM_VIEW_FOLD_4,                              false, true,  false, TEXT("Fold Level 4") },
249  	{ VK_5,       IDM_VIEW_FOLD_5,                              false, true,  false, TEXT("Fold Level 5") },
250  	{ VK_6,       IDM_VIEW_FOLD_6,                              false, true,  false, TEXT("Fold Level 6") },
251  	{ VK_7,       IDM_VIEW_FOLD_7,                              false, true,  false, TEXT("Fold Level 7") },
252  	{ VK_8,       IDM_VIEW_FOLD_8,                              false, true,  false, TEXT("Fold Level 8") },
253  	{ VK_1,       IDM_VIEW_UNFOLD_1,                            false, true,  true,  TEXT("Unfold Level 1") },
254  	{ VK_2,       IDM_VIEW_UNFOLD_2,                            false, true,  true,  TEXT("Unfold Level 2") },
255  	{ VK_3,       IDM_VIEW_UNFOLD_3,                            false, true,  true,  TEXT("Unfold Level 3") },
256  	{ VK_4,       IDM_VIEW_UNFOLD_4,                            false, true,  true,  TEXT("Unfold Level 4") },
257  	{ VK_5,       IDM_VIEW_UNFOLD_5,                            false, true,  true,  TEXT("Unfold Level 5") },
258  	{ VK_6,       IDM_VIEW_UNFOLD_6,                            false, true,  true,  TEXT("Unfold Level 6") },
259  	{ VK_7,       IDM_VIEW_UNFOLD_7,                            false, true,  true,  TEXT("Unfold Level 7") },
260  	{ VK_8,       IDM_VIEW_UNFOLD_8,                            false, true,  true,  TEXT("Unfold Level 8") },
261  	{ VK_NULL,    IDM_VIEW_SUMMARY,                             false, false, false, nullptr },
262  	{ VK_NULL,    IDM_VIEW_PROJECT_PANEL_1,                     false, false, false, TEXT("Toggle Project Panel 1") },
263  	{ VK_NULL,    IDM_VIEW_PROJECT_PANEL_2,                     false, false, false, TEXT("Toggle Project Panel 2") },
264  	{ VK_NULL,    IDM_VIEW_PROJECT_PANEL_3,                     false, false, false, TEXT("Toggle Project Panel 3") },
265  	{ VK_NULL,    IDM_VIEW_FILEBROWSER,                         false, false, false, TEXT("Toggle Folder as Workspace") },
266  	{ VK_NULL,    IDM_VIEW_DOC_MAP,                             false, false, false, TEXT("Toggle Document Map") },
267  	{ VK_NULL,    IDM_VIEW_DOCLIST,                             false, false, false, TEXT("Toggle Document List") },
268  	{ VK_NULL,    IDM_VIEW_FUNC_LIST,                           false, false, false, TEXT("Toggle Function List") },
269  	{ VK_NULL,    IDM_VIEW_SWITCHTO_PROJECT_PANEL_1,            false, false, false, TEXT("Switch to Project Panel 1") },
270  	{ VK_NULL,    IDM_VIEW_SWITCHTO_PROJECT_PANEL_2,            false, false, false, TEXT("Switch to Project Panel 2") },
271  	{ VK_NULL,    IDM_VIEW_SWITCHTO_PROJECT_PANEL_3,            false, false, false, TEXT("Switch to Project Panel 3") },
272  	{ VK_NULL,    IDM_VIEW_SWITCHTO_FILEBROWSER,                false, false, false, TEXT("Switch to Folder as Workspace") },
273  	{ VK_NULL,    IDM_VIEW_SWITCHTO_FUNC_LIST,                  false, false, false, TEXT("Switch to Function List") },
274  	{ VK_NULL,    IDM_VIEW_SWITCHTO_DOCLIST,                    false, false, false, TEXT("Switch to Document List") },
275  	{ VK_NULL,    IDM_VIEW_TAB_COLOUR_NONE,                     false, false, false, TEXT("Remove Tab Colour") },
276  	{ VK_NULL,    IDM_VIEW_TAB_COLOUR_1,                        false, false, false, TEXT("Apply Tab Colour 1") },
277  	{ VK_NULL,    IDM_VIEW_TAB_COLOUR_2,                        false, false, false, TEXT("Apply Tab Colour 2") },
278  	{ VK_NULL,    IDM_VIEW_TAB_COLOUR_3,                        false, false, false, TEXT("Apply Tab Colour 3") },
279  	{ VK_NULL,    IDM_VIEW_TAB_COLOUR_4,                        false, false, false, TEXT("Apply Tab Colour 4") },
280  	{ VK_NULL,    IDM_VIEW_TAB_COLOUR_5,                        false, false, false, TEXT("Apply Tab Colour 5") },
281  	{ VK_NULL,    IDM_VIEW_SYNSCROLLV,                          false, false, false, nullptr },
282  	{ VK_NULL,    IDM_VIEW_SYNSCROLLH,                          false, false, false, nullptr },
283  	{ VK_R,       IDM_EDIT_RTL,                                 true,  true,  false, nullptr },
284  	{ VK_L,       IDM_EDIT_LTR,                                 true,  true,  false, nullptr },
285  	{ VK_NULL,    IDM_VIEW_MONITORING,                          false, false, false, nullptr },
286  	{ VK_NULL,    IDM_FORMAT_ANSI,                              false, false, false, nullptr },
287  	{ VK_NULL,    IDM_FORMAT_AS_UTF_8,                          false, false, false, nullptr },
288  	{ VK_NULL,    IDM_FORMAT_UTF_8,                             false, false, false, nullptr },
289  	{ VK_NULL,    IDM_FORMAT_UTF_16BE,                          false, false, false, nullptr },
290  	{ VK_NULL,    IDM_FORMAT_UTF_16LE,                          false, false, false, nullptr },
291  	{ VK_NULL,    IDM_FORMAT_ISO_8859_6,                        false, false, false, nullptr },
292  	{ VK_NULL,    IDM_FORMAT_WIN_1256,                          false, false, false, nullptr },
293  	{ VK_NULL,    IDM_FORMAT_ISO_8859_13,                       false, false, false, nullptr },
294  	{ VK_NULL,    IDM_FORMAT_WIN_1257,                          false, false, false, nullptr },
295  	{ VK_NULL,    IDM_FORMAT_ISO_8859_14,                       false, false, false, nullptr },
296  	{ VK_NULL,    IDM_FORMAT_ISO_8859_5,                        false, false, false, nullptr },
297  	{ VK_NULL,    IDM_FORMAT_MAC_CYRILLIC,                      false, false, false, nullptr },
298  	{ VK_NULL,    IDM_FORMAT_KOI8R_CYRILLIC,                    false, false, false, nullptr },
299  	{ VK_NULL,    IDM_FORMAT_KOI8U_CYRILLIC,                    false, false, false, nullptr },
300  	{ VK_NULL,    IDM_FORMAT_WIN_1251,                          false, false, false, nullptr },
301  	{ VK_NULL,    IDM_FORMAT_WIN_1250,                          false, false, false, nullptr },
302  	{ VK_NULL,    IDM_FORMAT_DOS_437,                           false, false, false, nullptr },
303  	{ VK_NULL,    IDM_FORMAT_DOS_720,                           false, false, false, nullptr },
304  	{ VK_NULL,    IDM_FORMAT_DOS_737,                           false, false, false, nullptr },
305  	{ VK_NULL,    IDM_FORMAT_DOS_775,                           false, false, false, nullptr },
306  	{ VK_NULL,    IDM_FORMAT_DOS_850,                           false, false, false, nullptr },
307  	{ VK_NULL,    IDM_FORMAT_DOS_852,                           false, false, false, nullptr },
308  	{ VK_NULL,    IDM_FORMAT_DOS_855,                           false, false, false, nullptr },
309  	{ VK_NULL,    IDM_FORMAT_DOS_857,                           false, false, false, nullptr },
310  	{ VK_NULL,    IDM_FORMAT_DOS_858,                           false, false, false, nullptr },
311  	{ VK_NULL,    IDM_FORMAT_DOS_860,                           false, false, false, nullptr },
312  	{ VK_NULL,    IDM_FORMAT_DOS_861,                           false, false, false, nullptr },
313  	{ VK_NULL,    IDM_FORMAT_DOS_862,                           false, false, false, nullptr },
314  	{ VK_NULL,    IDM_FORMAT_DOS_863,                           false, false, false, nullptr },
315  	{ VK_NULL,    IDM_FORMAT_DOS_865,                           false, false, false, nullptr },
316  	{ VK_NULL,    IDM_FORMAT_DOS_866,                           false, false, false, nullptr },
317  	{ VK_NULL,    IDM_FORMAT_DOS_869,                           false, false, false, nullptr },
318  	{ VK_NULL,    IDM_FORMAT_BIG5,                              false, false, false, nullptr },
319  	{ VK_NULL,    IDM_FORMAT_GB2312,                            false, false, false, nullptr },
320  	{ VK_NULL,    IDM_FORMAT_ISO_8859_2,                        false, false, false, nullptr },
321  	{ VK_NULL,    IDM_FORMAT_ISO_8859_7,                        false, false, false, nullptr },
322  	{ VK_NULL,    IDM_FORMAT_WIN_1253,                          false, false, false, nullptr },
323  	{ VK_NULL,    IDM_FORMAT_ISO_8859_8,                        false, false, false, nullptr },
324  	{ VK_NULL,    IDM_FORMAT_WIN_1255,                          false, false, false, nullptr },
325  	{ VK_NULL,    IDM_FORMAT_SHIFT_JIS,                         false, false, false, nullptr },
326  	{ VK_NULL,    IDM_FORMAT_EUC_KR,                            false, false, false, nullptr },
327  	{ VK_NULL,    IDM_FORMAT_ISO_8859_15,                       false, false, false, nullptr },
328  	{ VK_NULL,    IDM_FORMAT_ISO_8859_4,                        false, false, false, nullptr },
329  	{ VK_NULL,    IDM_FORMAT_ISO_8859_3,                        false, false, false, nullptr },
330  	{ VK_NULL,    IDM_FORMAT_TIS_620,                           false, false, false, nullptr },
331  	{ VK_NULL,    IDM_FORMAT_ISO_8859_9,                        false, false, false, nullptr },
332  	{ VK_NULL,    IDM_FORMAT_WIN_1254,                          false, false, false, nullptr },
333  	{ VK_NULL,    IDM_FORMAT_WIN_1252,                          false, false, false, nullptr },
334  	{ VK_NULL,    IDM_FORMAT_ISO_8859_1,                        false, false, false, nullptr },
335  	{ VK_NULL,    IDM_FORMAT_WIN_1258,                          false, false, false, nullptr },
336  	{ VK_NULL,    IDM_FORMAT_CONV2_ANSI,                        false, false, false, nullptr },
337  	{ VK_NULL,    IDM_FORMAT_CONV2_AS_UTF_8,                    false, false, false, nullptr },
338  	{ VK_NULL,    IDM_FORMAT_CONV2_UTF_8,                       false, false, false, nullptr },
339  	{ VK_NULL,    IDM_FORMAT_CONV2_UTF_16BE,                    false, false, false, nullptr },
340  	{ VK_NULL,    IDM_FORMAT_CONV2_UTF_16LE,                    false, false, false, nullptr },
341  	{ VK_NULL,    IDM_LANG_USER_DLG,                            false, false, false, nullptr },
342  	{ VK_NULL,    IDM_LANG_USER,                                false, false, false, nullptr },
343  	{ VK_NULL,    IDM_LANG_OPENUDLDIR,                          false, false, false, nullptr },
344  	{ VK_NULL,    IDM_SETTING_PREFERENCE,                       false, false, false, nullptr },
345  	{ VK_NULL,    IDM_LANGSTYLE_CONFIG_DLG,                     false, false, false, nullptr },
346  	{ VK_NULL,    IDM_SETTING_SHORTCUT_MAPPER,                  false, false, false, nullptr },
347  	{ VK_NULL,    IDM_SETTING_IMPORTPLUGIN,                     false, false, false, nullptr },
348  	{ VK_NULL,    IDM_SETTING_IMPORTSTYLETHEMS,                 false, false, false, nullptr },
349  	{ VK_NULL,    IDM_SETTING_EDITCONTEXTMENU,                  false, false, false, nullptr },
350  	{ VK_R,       IDC_EDIT_TOGGLEMACRORECORDING,                true,  false, true,  TEXT("Toggle macro recording")},
351  	{ VK_NULL,    IDM_MACRO_STARTRECORDINGMACRO,                false, false, false, nullptr },
352  	{ VK_NULL,    IDM_MACRO_STOPRECORDINGMACRO,                 false, false, false, nullptr },
353  	{ VK_P,       IDM_MACRO_PLAYBACKRECORDEDMACRO,              true,  false, true,  nullptr },
354  	{ VK_NULL,    IDM_MACRO_SAVECURRENTMACRO,                   false, false, false, nullptr },
355  	{ VK_NULL,    IDM_MACRO_RUNMULTIMACRODLG,                   false, false, false, nullptr },
356  	{ VK_F5,      IDM_EXECUTE,                                  false, false, false, nullptr },
357  	{ VK_NULL,    IDM_WINDOW_SORT_FN_ASC,                       false, false, false, TEXT("Sort By Name A to Z") },
358  	{ VK_NULL,    IDM_WINDOW_SORT_FN_DSC,                       false, false, false, TEXT("Sort By Name Z to A") },
359  	{ VK_NULL,    IDM_WINDOW_SORT_FP_ASC,                       false, false, false, TEXT("Sort By Path A to Z") },
360  	{ VK_NULL,    IDM_WINDOW_SORT_FP_DSC,                       false, false, false, TEXT("Sort By Path Z to A") },
361  	{ VK_NULL,    IDM_WINDOW_SORT_FT_ASC,                       false, false, false, TEXT("Sort By Type A to Z") },
362  	{ VK_NULL,    IDM_WINDOW_SORT_FT_DSC,                       false, false, false, TEXT("Sort By Type Z to A") },
363  	{ VK_NULL,    IDM_WINDOW_SORT_FS_ASC,                       false, false, false, TEXT("Sort By Size Smaller to Larger") },
364  	{ VK_NULL,    IDM_WINDOW_SORT_FS_DSC,                       false, false, false, TEXT("Sort By Size Larger to Smaller") },
365  	{ VK_NULL,    IDM_CMDLINEARGUMENTS,                         false, false, false, nullptr },
366  	{ VK_NULL,    IDM_HOMESWEETHOME,                            false, false, false, nullptr },
367  	{ VK_NULL,    IDM_PROJECTPAGE,                              false, false, false, nullptr },
368  	{ VK_NULL,    IDM_ONLINEDOCUMENT,                           false, false, false, nullptr },
369  	{ VK_NULL,    IDM_FORUM,                                    false, false, false, nullptr },
370  	{ VK_NULL,    IDM_UPDATE_NPP,                               false, false, false, TEXT("Update Notepad++") },
371  	{ VK_NULL,    IDM_CONFUPDATERPROXY,                         false, false, false, TEXT("Set Updater Proxy...") },
372  	{ VK_NULL,    IDM_DEBUGINFO,                                false, false, false, nullptr },
373  	{ VK_F1,      IDM_ABOUT,                                    false, false, false, nullptr }
374  };
375  static const ScintillaKeyDefinition scintKeyDefs[] =
376  {
377  	{TEXT("SCI_CUT"),                     SCI_CUT,                     true,  false, false, VK_X,        IDM_EDIT_CUT},
378  	{TEXT(""),                            SCI_CUT,                     false, false, true,  VK_DELETE,   0},
379  	{TEXT("SCI_COPY"),                    SCI_COPY,                    true,  false, false, VK_C,        IDM_EDIT_COPY},
380  	{TEXT(""),                            SCI_COPY,                    true,  false, false, VK_INSERT,   0},
381  	{TEXT("SCI_PASTE"),                   SCI_PASTE,                   true,  false, false, VK_V,        IDM_EDIT_PASTE},
382  	{TEXT(""),                            SCI_PASTE,                   false, false, true,  VK_INSERT,   0},
383  	{TEXT("SCI_SELECTALL"),               SCI_SELECTALL,               true,  false, false, VK_A,        IDM_EDIT_SELECTALL},
384  	{TEXT("SCI_CLEAR"),                   SCI_CLEAR,                   false, false, false, VK_DELETE,   IDM_EDIT_DELETE},
385  	{TEXT("SCI_CLEARALL"),                SCI_CLEARALL,                false, false, false, 0,           0},
386  	{TEXT("SCI_UNDO"),                    SCI_UNDO,                    true,  false, false, VK_Z,        IDM_EDIT_UNDO},
387  	{TEXT(""),                            SCI_UNDO,                    false, true,  false, VK_BACK,     0},
388  	{TEXT("SCI_REDO"),                    SCI_REDO,                    true,  false, false, VK_Y,        IDM_EDIT_REDO},
389  	{TEXT(""),                            SCI_REDO,                    true,  false, true,  VK_Z,        0},
390  	{TEXT("SCI_NEWLINE"),                 SCI_NEWLINE,                 false, false, false, VK_RETURN,   0},
391  	{TEXT(""),                            SCI_NEWLINE,                 false, false, true,  VK_RETURN,   0},
392  	{TEXT("SCI_TAB"),                     SCI_TAB,                     false, false, false, VK_TAB,      0},
393  	{TEXT("SCI_BACKTAB"),                 SCI_BACKTAB,                 false, false, true,  VK_TAB,      0},
394  	{TEXT("SCI_FORMFEED"),                SCI_FORMFEED,                false, false, false, 0,           0},
395  	{TEXT("SCI_ZOOMIN"),                  SCI_ZOOMIN,                  true,  false, false, VK_ADD,      IDM_VIEW_ZOOMIN},
396  	{TEXT("SCI_ZOOMOUT"),                 SCI_ZOOMOUT,                 true,  false, false, VK_SUBTRACT, IDM_VIEW_ZOOMOUT},
397  	{TEXT("SCI_SETZOOM"),                 SCI_SETZOOM,                 true,  false, false, VK_DIVIDE,   IDM_VIEW_ZOOMRESTORE},
398  	{TEXT("SCI_SELECTIONDUPLICATE"),      SCI_SELECTIONDUPLICATE,      true,  false, false, VK_D,        IDM_EDIT_DUP_LINE},
399  	{TEXT("SCI_LINESJOIN"),               SCI_LINESJOIN,               false, false, false, 0,           0},
400  	{TEXT("SCI_SCROLLCARET"),             SCI_SCROLLCARET,             false, false, false, 0,           0},
401  	{TEXT("SCI_EDITTOGGLEOVERTYPE"),      SCI_EDITTOGGLEOVERTYPE,      false, false, false, VK_INSERT,   0},
402  	{TEXT("SCI_MOVECARETINSIDEVIEW"),     SCI_MOVECARETINSIDEVIEW,     false, false, false, 0,           0},
403  	{TEXT("SCI_LINEDOWN"),                SCI_LINEDOWN,                false, false, false, VK_DOWN,     0},
404  	{TEXT("SCI_LINEDOWNEXTEND"),          SCI_LINEDOWNEXTEND,          false, false, true,  VK_DOWN,     0},
405  	{TEXT("SCI_LINEDOWNRECTEXTEND"),      SCI_LINEDOWNRECTEXTEND,      false, true,  true,  VK_DOWN,     0},
406  	{TEXT("SCI_LINESCROLLDOWN"),          SCI_LINESCROLLDOWN,          true,  false, false, VK_DOWN,     0},
407  	{TEXT("SCI_LINEUP"),                  SCI_LINEUP,                  false, false, false, VK_UP,       0},
408  	{TEXT("SCI_LINEUPEXTEND"),            SCI_LINEUPEXTEND,            false, false, true,  VK_UP,       0},
409  	{TEXT("SCI_LINEUPRECTEXTEND"),        SCI_LINEUPRECTEXTEND,        false, true,  true,  VK_UP,       0},
410  	{TEXT("SCI_LINESCROLLUP"),            SCI_LINESCROLLUP,            true,  false, false, VK_UP,       0},
411  	{TEXT("SCI_PARADOWN"),                SCI_PARADOWN,                true,  false, false, VK_OEM_6,    0},
412  	{TEXT("SCI_PARADOWNEXTEND"),          SCI_PARADOWNEXTEND,          true,  false, true,  VK_OEM_6,    0},
413  	{TEXT("SCI_PARAUP"),                  SCI_PARAUP,                  true,  false, false, VK_OEM_4,    0},
414  	{TEXT("SCI_PARAUPEXTEND"),            SCI_PARAUPEXTEND,            true,  false, true,  VK_OEM_4,    0},
415  	{TEXT("SCI_CHARLEFT"),                SCI_CHARLEFT,                false, false, false, VK_LEFT,     0},
416  	{TEXT("SCI_CHARLEFTEXTEND"),          SCI_CHARLEFTEXTEND,          false, false, true,  VK_LEFT,     0},
417  	{TEXT("SCI_CHARLEFTRECTEXTEND"),      SCI_CHARLEFTRECTEXTEND,      false, true,  true,  VK_LEFT,     0},
418  	{TEXT("SCI_CHARRIGHT"),               SCI_CHARRIGHT,               false, false, false, VK_RIGHT,    0},
419  	{TEXT("SCI_CHARRIGHTEXTEND"),         SCI_CHARRIGHTEXTEND,         false, false, true,  VK_RIGHT,    0},
420  	{TEXT("SCI_CHARRIGHTRECTEXTEND"),     SCI_CHARRIGHTRECTEXTEND,     false, true,  true,  VK_RIGHT,    0},
421  	{TEXT("SCI_WORDLEFT"),                SCI_WORDLEFT,                true,  false, false, VK_LEFT,     0},
422  	{TEXT("SCI_WORDLEFTEXTEND"),          SCI_WORDLEFTEXTEND,          true,  false, true,  VK_LEFT,     0},
423  	{TEXT("SCI_WORDRIGHT"),               SCI_WORDRIGHT,               true,  false, false, VK_RIGHT,    0},
424  	{TEXT("SCI_WORDRIGHTEXTEND"),         SCI_WORDRIGHTEXTEND,         false, false, false, 0,           0},
425  	{TEXT("SCI_WORDLEFTEND"),             SCI_WORDLEFTEND,             false, false, false, 0,           0},
426  	{TEXT("SCI_WORDLEFTENDEXTEND"),       SCI_WORDLEFTENDEXTEND,       false, false, false, 0,           0},
427  	{TEXT("SCI_WORDRIGHTEND"),            SCI_WORDRIGHTEND,            false, false, false, 0,           0},
428  	{TEXT("SCI_WORDRIGHTENDEXTEND"),      SCI_WORDRIGHTENDEXTEND,      true,  false, true,  VK_RIGHT,    0},
429  	{TEXT("SCI_WORDPARTLEFT"),            SCI_WORDPARTLEFT,            true,  false, false, VK_OEM_2,    0},
430  	{TEXT("SCI_WORDPARTLEFTEXTEND"),      SCI_WORDPARTLEFTEXTEND,      true,  false, true,  VK_OEM_2,    0},
431  	{TEXT("SCI_WORDPARTRIGHT"),           SCI_WORDPARTRIGHT,           true,  false, false, VK_OEM_5,    0},
432  	{TEXT("SCI_WORDPARTRIGHTEXTEND"),     SCI_WORDPARTRIGHTEXTEND,     true,  false, true,  VK_OEM_5,    0},
433  	{TEXT("SCI_HOME"),                    SCI_HOME,                    false, false, false, 0,           0},
434  	{TEXT("SCI_HOMEEXTEND"),              SCI_HOMEEXTEND,              false, false, false, 0,           0},
435  	{TEXT("SCI_HOMERECTEXTEND"),          SCI_HOMERECTEXTEND,          false, false, false, 0,           0},
436  	{TEXT("SCI_HOMEDISPLAY"),             SCI_HOMEDISPLAY,             false, true,  false, VK_HOME,     0},
437  	{TEXT("SCI_HOMEDISPLAYEXTEND"),       SCI_HOMEDISPLAYEXTEND,       false, false, false, 0,           0},
438  	{TEXT("SCI_HOMEWRAP"),                SCI_HOMEWRAP,                false, false, false, 0,           0},
439  	{TEXT("SCI_HOMEWRAPEXTEND"),          SCI_HOMEWRAPEXTEND,          false, false, false, 0,           0},
440  	{TEXT("SCI_VCHOME"),                  SCI_VCHOME,                  false, false, false, 0,           0},
441  	{TEXT("SCI_VCHOMEEXTEND"),            SCI_VCHOMEEXTEND,            false, false, false, 0,           0},
442  	{TEXT("SCI_VCHOMERECTEXTEND"),        SCI_VCHOMERECTEXTEND,        false, true,  true,  VK_HOME,     0},
443  	{TEXT("SCI_VCHOMEDISPLAY"),           SCI_VCHOMEDISPLAY,           false, false, false, 0,           0},
444  	{TEXT("SCI_VCHOMEDISPLAYEXTEND"),     SCI_VCHOMEDISPLAYEXTEND,     false, false, false, 0,           0},
445  	{TEXT("SCI_VCHOMEWRAP"),              SCI_VCHOMEWRAP,              false, false, false, VK_HOME,     0},
446  	{TEXT("SCI_VCHOMEWRAPEXTEND"),        SCI_VCHOMEWRAPEXTEND,        false, false, true,  VK_HOME,     0},
447  	{TEXT("SCI_LINEEND"),                 SCI_LINEEND,                 false, false, false, 0,           0},
448  	{TEXT("SCI_LINEENDWRAPEXTEND"),       SCI_LINEENDWRAPEXTEND,       false, false, true,  VK_END,      0},
449  	{TEXT("SCI_LINEENDRECTEXTEND"),       SCI_LINEENDRECTEXTEND,       false, true,  true,  VK_END,      0},
450  	{TEXT("SCI_LINEENDDISPLAY"),          SCI_LINEENDDISPLAY,          false, true,  false, VK_END,      0},
451  	{TEXT("SCI_LINEENDDISPLAYEXTEND"),    SCI_LINEENDDISPLAYEXTEND,    false, false, false, 0,           0},
452  	{TEXT("SCI_LINEENDWRAP"),             SCI_LINEENDWRAP,             false, false, false, VK_END,      0},
453  	{TEXT("SCI_LINEENDEXTEND"),           SCI_LINEENDEXTEND,           false, false, false, 0,           0},
454  	{TEXT("SCI_DOCUMENTSTART"),           SCI_DOCUMENTSTART,           true,  false, false, VK_HOME,     0},
455  	{TEXT("SCI_DOCUMENTSTARTEXTEND"),     SCI_DOCUMENTSTARTEXTEND,     true,  false, true,  VK_HOME,     0},
456  	{TEXT("SCI_DOCUMENTEND"),             SCI_DOCUMENTEND,             true,  false, false, VK_END,      0},
457  	{TEXT("SCI_DOCUMENTENDEXTEND"),       SCI_DOCUMENTENDEXTEND,       true,  false, true,  VK_END,      0},
458  	{TEXT("SCI_PAGEUP"),                  SCI_PAGEUP,                  false, false, false, VK_PRIOR,    0},
459  	{TEXT("SCI_PAGEUPEXTEND"),            SCI_PAGEUPEXTEND,            false, false, true,  VK_PRIOR,    0},
460  	{TEXT("SCI_PAGEUPRECTEXTEND"),        SCI_PAGEUPRECTEXTEND,        false, true,  true,  VK_PRIOR,    0},
461  	{TEXT("SCI_PAGEDOWN"),                SCI_PAGEDOWN,                false, false, false, VK_NEXT,     0},
462  	{TEXT("SCI_PAGEDOWNEXTEND"),          SCI_PAGEDOWNEXTEND,          false, false, true,  VK_NEXT,     0},
463  	{TEXT("SCI_PAGEDOWNRECTEXTEND"),      SCI_PAGEDOWNRECTEXTEND,      false, true,  true,  VK_NEXT,     0},
464  	{TEXT("SCI_STUTTEREDPAGEUP"),         SCI_STUTTEREDPAGEUP,         false, false, false, 0,           0},
465  	{TEXT("SCI_STUTTEREDPAGEUPEXTEND"),   SCI_STUTTEREDPAGEUPEXTEND,   false, false, false, 0,           0},
466  	{TEXT("SCI_STUTTEREDPAGEDOWN"),       SCI_STUTTEREDPAGEDOWN,       false, false, false, 0,           0},
467  	{TEXT("SCI_STUTTEREDPAGEDOWNEXTEND"), SCI_STUTTEREDPAGEDOWNEXTEND, false, false, false, 0,           0},
468  	{TEXT("SCI_DELETEBACK"),              SCI_DELETEBACK,              false, false, false, VK_BACK,     0},
469  	{TEXT(""),                            SCI_DELETEBACK,              false, false, true,  VK_BACK,     0},
470  	{TEXT("SCI_DELETEBACKNOTLINE"),       SCI_DELETEBACKNOTLINE,       false, false, false, 0,           0},
471  	{TEXT("SCI_DELWORDLEFT"),             SCI_DELWORDLEFT,             true,  false, false, VK_BACK,     0},
472  	{TEXT("SCI_DELWORDRIGHT"),            SCI_DELWORDRIGHT,            true,  false, false, VK_DELETE,   0},
473  	{TEXT("SCI_DELLINELEFT"),             SCI_DELLINELEFT,             true,  false, true,  VK_BACK,     0},
474  	{TEXT("SCI_DELLINERIGHT"),            SCI_DELLINERIGHT,            true,  false, true,  VK_DELETE,   0},
475  	{TEXT("SCI_LINEDELETE"),              SCI_LINEDELETE,              true,  false, true,  VK_L,        0},
476  	{TEXT("SCI_LINECUT"),                 SCI_LINECUT,                 true,  false, false, VK_L,        0},
477  	{TEXT("SCI_LINECOPY"),                SCI_LINECOPY,                true,  false, true,  VK_X,        0},
478  	{TEXT("SCI_LINETRANSPOSE"),           SCI_LINETRANSPOSE,           true,  false, false, VK_T,        0},
479  	{TEXT("SCI_LINEDUPLICATE"),           SCI_LINEDUPLICATE,           false, false, false, 0,           0},
480  	{TEXT("SCI_CANCEL"),                  SCI_CANCEL,                  false, false, false, VK_ESCAPE,   0},
481  	{TEXT("SCI_SWAPMAINANCHORCARET"),     SCI_SWAPMAINANCHORCARET,     false, false, false, 0,           0},
482  	{TEXT("SCI_ROTATESELECTION"),         SCI_ROTATESELECTION,         false, false, false, 0,           0}
483  };
484  #define NONEEDSHORTCUTSXMLBACKUP_FILENAME L"v852NoNeedShortcutsBackup.xml"
485  #define SHORTCUTSXML_FILENAME L"shortcuts.xml"
486  typedef void (WINAPI *PGNSI)(LPSYSTEM_INFO);
487  int strVal(const TCHAR *str, int base)
488  {
489  	if (!str) return -1;
490  	if (!str[0]) return 0;
491  	TCHAR *finStr;
492  	int result = wcstol(str, &finStr, base);
493  	if (*finStr != '\0')
494  		return -1;
495  	return result;
496  }
497  int decStrVal(const TCHAR *str)
498  {
499  	return strVal(str, 10);
500  }
501  int hexStrVal(const TCHAR *str)
502  {
503  	return strVal(str, 16);
504  }
505  int getKwClassFromName(const TCHAR *str)
506  {
507  	if (!lstrcmp(TEXT("instre1"), str)) return LANG_INDEX_INSTR;
508  	if (!lstrcmp(TEXT("instre2"), str)) return LANG_INDEX_INSTR2;
509  	if (!lstrcmp(TEXT("type1"), str)) return LANG_INDEX_TYPE;
510  	if (!lstrcmp(TEXT("type2"), str)) return LANG_INDEX_TYPE2;
511  	if (!lstrcmp(TEXT("type3"), str)) return LANG_INDEX_TYPE3;
512  	if (!lstrcmp(TEXT("type4"), str)) return LANG_INDEX_TYPE4;
513  	if (!lstrcmp(TEXT("type5"), str)) return LANG_INDEX_TYPE5;
514  	if (!lstrcmp(TEXT("type6"), str)) return LANG_INDEX_TYPE6;
515  	if (!lstrcmp(TEXT("type7"), str)) return LANG_INDEX_TYPE7;
516  	if ((str[1] == '\0') && (str[0] >= '0') && (str[0] <= '8')) 
517  		return str[0] - '0';
518  	return -1;
519  }
520  } 
521  void cutString(const TCHAR* str2cut, vector<generic_string>& patternVect)
522  {
523  	if (str2cut == nullptr) return;
524  	const TCHAR *pBegin = str2cut;
525  	const TCHAR *pEnd = pBegin;
526  	while (*pEnd != '\0')
527  	{
528  		if (_istspace(*pEnd))
529  		{
530  			if (pBegin != pEnd)
531  				patternVect.emplace_back(pBegin, pEnd);
532  			pBegin = pEnd + 1;
533  		}
534  		++pEnd;
535  	}
536  	if (pBegin != pEnd)
537  		patternVect.emplace_back(pBegin, pEnd);
538  }
539  void cutStringBy(const TCHAR* str2cut, vector<generic_string>& patternVect, char byChar, bool allowEmptyStr)
540  {
541  	if (str2cut == nullptr) return;
542  	const TCHAR* pBegin = str2cut;
543  	const TCHAR* pEnd = pBegin;
544  	while (*pEnd != '\0')
545  	{
546  		if (*pEnd == byChar)
547  		{
548  			if (allowEmptyStr)
549  				patternVect.emplace_back(pBegin, pEnd);
550  			else if (pBegin != pEnd)
551  				patternVect.emplace_back(pBegin, pEnd);
552  			pBegin = pEnd + 1;
553  		}
554  		++pEnd;
555  	}
556  	if (allowEmptyStr)
557  		patternVect.emplace_back(pBegin, pEnd);
558  	else if (pBegin != pEnd)
559  		patternVect.emplace_back(pBegin, pEnd);
560  }
561  std::wstring LocalizationSwitcher::getLangFromXmlFileName(const wchar_t *fn) const
562  {
563  	size_t nbItem = sizeof(localizationDefs)/sizeof(LocalizationSwitcher::LocalizationDefinition);
564  	for (size_t i = 0 ; i < nbItem ; ++i)
565  	{
566  		if (0 == wcsicmp(fn, localizationDefs[i]._xmlFileName))
567  			return localizationDefs[i]._langName;
568  	}
569  	return std::wstring();
570  }
571  std::wstring LocalizationSwitcher::getXmlFilePathFromLangName(const wchar_t *langName) const
572  {
573  	for (size_t i = 0, len = _localizationList.size(); i < len ; ++i)
574  	{
575  		if (0 == wcsicmp(langName, _localizationList[i].first.c_str()))
576  			return _localizationList[i].second;
577  	}
578  	return std::wstring();
579  }
580  bool LocalizationSwitcher::addLanguageFromXml(const std::wstring& xmlFullPath)
581  {
582  	wchar_t * fn = ::PathFindFileNameW(xmlFullPath.c_str());
583  	wstring foundLang = getLangFromXmlFileName(fn);
584  	if (!foundLang.empty())
585  	{
586  		_localizationList.push_back(pair<wstring, wstring>(foundLang, xmlFullPath));
587  		return true;
588  	}
589  	return false;
590  }
591  bool LocalizationSwitcher::switchToLang(const wchar_t *lang2switch) const
592  {
593  	wstring langPath = getXmlFilePathFromLangName(lang2switch);
594  	if (langPath.empty())
595  		return false;
596  	return ::CopyFileW(langPath.c_str(), _nativeLangPath.c_str(), FALSE) != FALSE;
597  }
598  generic_string ThemeSwitcher::getThemeFromXmlFileName(const TCHAR *xmlFullPath) const
599  {
600  	if (!xmlFullPath || !xmlFullPath[0])
601  		return generic_string();
602  	generic_string fn(::PathFindFileName(xmlFullPath));
603  	PathRemoveExtension(const_cast<TCHAR *>(fn.c_str()));
604  	return fn;
605  }
606  int DynamicMenu::getTopLevelItemNumber() const
607  {
608  	int nb = 0;
609  	generic_string previousFolderName;
610  	for (const MenuItemUnit& i : _menuItems)
611  	{
612  		if (i._parentFolderName.empty())
613  		{
614  			++nb;
615  		}
616  		else
617  		{
618  			if (previousFolderName.empty())
619  			{
620  				++nb;
621  				previousFolderName = i._parentFolderName;
622  			}
623  			else 
624  			{
625  				if (i._parentFolderName.empty())
626  				{
627  					++nb;
628  					previousFolderName = i._parentFolderName;
629  				}
630  				else if (previousFolderName == i._parentFolderName)
631  				{
632  				}
633  				else
634  				{
635  					++nb;
636  					previousFolderName = i._parentFolderName;
637  				}
638  			}
639  		}
640  	}
641  	return nb;
642  }
643  bool DynamicMenu::attach(HMENU hMenu, unsigned int posBase, int lastCmd, const generic_string& lastCmdLabel)
644  {
645  	if (!hMenu) return false;
646  	_hMenu = hMenu;
647  	_posBase = posBase;
648  	_lastCmd = lastCmd;
649  	_lastCmdLabel = lastCmdLabel;
650  	return createMenu();
651  }
652  bool DynamicMenu::clearMenu() const
653  {
654  	if (!_hMenu) return false;
655  	int nbTopItem = getTopLevelItemNumber();
656  	for (int i = nbTopItem + 1; i >= 0 ; --i)
657  	{
658  		::DeleteMenu(_hMenu, static_cast<int32_t>(_posBase) + i, MF_BYPOSITION);
659  	}
660  	return true;
661  }
662  bool DynamicMenu::createMenu() const
663  {
664  	if (!_hMenu) return false;
665  	bool lastIsSep = false;
666  	HMENU hParentFolder = NULL;
667  	generic_string currentParentFolderStr;
668  	int j = 0;
669  	size_t nb = _menuItems.size();
670  	size_t i = 0;
671  	for (; i < nb; ++i)
672  	{
673  		const MenuItemUnit& item = _menuItems[i];
674  		if (item._parentFolderName.empty())
675  		{
676  			currentParentFolderStr.clear();
677  			hParentFolder = NULL;
678  			j = 0;
679  		}
680  		else
681  		{
682  			if (item._parentFolderName != currentParentFolderStr)
683  			{
684  				currentParentFolderStr = item._parentFolderName;
685  				hParentFolder = ::CreateMenu();
686  				j = 0;
687  				::InsertMenu(_hMenu, static_cast<UINT>(_posBase + i), MF_BYPOSITION | MF_POPUP, (UINT_PTR)hParentFolder, currentParentFolderStr.c_str());
688  			}
689  		}
690  		unsigned int flag = MF_BYPOSITION | ((item._cmdID == 0) ? MF_SEPARATOR : 0);
691  		if (hParentFolder)
692  		{
693  			::InsertMenu(hParentFolder, j++, flag, item._cmdID, item._itemName.c_str());
694  			lastIsSep = false;
695  		}
696  		else if ((i == 0 || i == _menuItems.size() - 1) && item._cmdID == 0)
697  		{
698  			lastIsSep = true;
699  		}
700  		else if (item._cmdID != 0)
701  		{
702  			::InsertMenu(_hMenu, static_cast<UINT>(_posBase + i), flag, item._cmdID, item._itemName.c_str());
703  			lastIsSep = false;
704  		}
<span onclick='openModal()' class='match'>705  		else if (item._cmdID == 0 && !lastIsSep)
706  		{
707  			::InsertMenu(_hMenu, static_cast<int32_t>(_posBase + i), flag, item._cmdID, item._itemName.c_str());
708  			lastIsSep = true;
709  		}
710  		else 
711  		{
712  			lastIsSep = true;
713  		}
714  	}
</span>715  	if (nb > 0)
716  	{
717  		::InsertMenu(_hMenu, static_cast<int32_t>(_posBase + i), MF_BYPOSITION | MF_SEPARATOR, 0, nullptr);
718  		::InsertMenu(_hMenu, static_cast<UINT>(_posBase + i + 2), MF_BYCOMMAND, _lastCmd, _lastCmdLabel.c_str());
719  	}
720  	return true;
721  }
722  winVer NppParameters::getWindowsVersion()
723  {
724  	OSVERSIONINFOEX osvi;
725  	SYSTEM_INFO si;
726  	PGNSI pGNSI;
727  	ZeroMemory(&si, sizeof(SYSTEM_INFO));
728  	ZeroMemory(&osvi, sizeof(OSVERSIONINFOEX));
729  	osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
730  	BOOL bOsVersionInfoEx = GetVersionEx ((OSVERSIONINFO *)&osvi);
731  	if (!bOsVersionInfoEx)
732  	{
733  		osvi.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);
734  		if (! GetVersionEx ( (OSVERSIONINFO *) &osvi) )
735  			return WV_UNKNOWN;
736  	}
737  	pGNSI = (PGNSI) GetProcAddress(GetModuleHandle(TEXT("kernel32.dll")), "GetNativeSystemInfo");
738  	if (pGNSI != NULL)
739  		pGNSI(&si);
740  	else
741  		GetSystemInfo(&si);
742  	switch (si.wProcessorArchitecture)
743  	{
744  	case PROCESSOR_ARCHITECTURE_IA64:
745  		_platForm = PF_IA64;
746  		break;
747  	case PROCESSOR_ARCHITECTURE_AMD64:
748  		_platForm = PF_X64;
749  		break;
750  	case PROCESSOR_ARCHITECTURE_INTEL:
751  		_platForm = PF_X86;
752  		break;
753  	case PROCESSOR_ARCHITECTURE_ARM64:
754  		_platForm = PF_ARM64;
755  		break;
756  	default:
757  		_platForm = PF_UNKNOWN;
758  	}
759     switch (osvi.dwPlatformId)
760     {
761  		case VER_PLATFORM_WIN32_NT:
762  		{
763  			if (osvi.dwMajorVersion == 10 && osvi.dwMinorVersion == 0 && osvi.dwBuildNumber >= 22000)
764  				return WV_WIN11;
765  			if (osvi.dwMajorVersion == 10 && osvi.dwMinorVersion == 0)
766  				return WV_WIN10;
767  			if (osvi.dwMajorVersion == 6 && osvi.dwMinorVersion == 3)
768  				return WV_WIN81;
769  			if (osvi.dwMajorVersion == 6 && osvi.dwMinorVersion == 2)
770  				return WV_WIN8;
771  			if (osvi.dwMajorVersion == 6 && osvi.dwMinorVersion == 1)
772  				return WV_WIN7;
773  			if (osvi.dwMajorVersion == 6 && osvi.dwMinorVersion == 0)
774  				return WV_VISTA;
775  			if (osvi.dwMajorVersion == 5 && osvi.dwMinorVersion == 2)
776  			{
777  				if (osvi.wProductType == VER_NT_WORKSTATION && si.wProcessorArchitecture==PROCESSOR_ARCHITECTURE_AMD64)
778  					return WV_XPX64;
779  				return WV_S2003;
780  			}
781  			if (osvi.dwMajorVersion == 5 && osvi.dwMinorVersion == 1)
782  				return WV_XP;
783  			if (osvi.dwMajorVersion == 5 && osvi.dwMinorVersion == 0)
784  				return WV_W2K;
785  			if (osvi.dwMajorVersion <= 4)
786  				return WV_NT;
787  			break;
788  		}
789  		case VER_PLATFORM_WIN32_WINDOWS:
790  		{
791  			if (osvi.dwMajorVersion == 4 && osvi.dwMinorVersion == 0)
792  				return WV_95;
793  			if (osvi.dwMajorVersion == 4 && osvi.dwMinorVersion == 10)
794  				return WV_98;
795  			if (osvi.dwMajorVersion == 4 && osvi.dwMinorVersion == 90)
796  				return WV_ME;
797  			break;
798  		}
799  		case VER_PLATFORM_WIN32s:
800  			return WV_WIN32S;
801  		default:
802  			return WV_UNKNOWN;
803     }
804     return WV_UNKNOWN;
805  }
806  NppParameters::NppParameters()
807  {
808  	_winVersion = getWindowsVersion();
809  	TCHAR nppPath[MAX_PATH];
810  	::GetModuleFileName(NULL, nppPath, MAX_PATH);
811  	PathRemoveFileSpec(nppPath);
812  	_nppPath = nppPath;
813  	TCHAR curDir[MAX_PATH];
814  	::GetCurrentDirectory(MAX_PATH, curDir);
815  	_currentDirectory = curDir;
816  	_appdataNppDir.clear();
817  	generic_string notepadStylePath(_nppPath);
818  	pathAppend(notepadStylePath, notepadStyleFile);
819  	_asNotepadStyle = (PathFileExists(notepadStylePath.c_str()) == TRUE);
820  	initMenuKeys();
821  	initScintillaKeys();
822  }
823  NppParameters::~NppParameters()
824  {
825  	for (int i = 0 ; i < _nbLang ; ++i)
826  		delete _langList[i];
827  	for (int i = 0 ; i < _nbRecentFile ; ++i)
828  		delete _LRFileList[i];
829  	for (int i = 0 ; i < _nbUserLang ; ++i)
830  		delete _userLangArray[i];
831  	for (std::vector<TiXmlDocument *>::iterator it = _pXmlExternalLexerDoc.begin(), end = _pXmlExternalLexerDoc.end(); it != end; ++it )
832  		delete (*it);
833  	_pXmlExternalLexerDoc.clear();
834  }
835  bool NppParameters::reloadStylers(const TCHAR* stylePath)
836  {
837  	delete _pXmlUserStylerDoc;
838  	const TCHAR* stylePathToLoad = stylePath != nullptr ? stylePath : _stylerPath.c_str();
839  	_pXmlUserStylerDoc = new TiXmlDocument(stylePathToLoad);
840  	bool loadOkay = _pXmlUserStylerDoc->LoadFile();
841  	if (!loadOkay)
842  	{
843  		if (!_pNativeLangSpeaker)
844  		{
845  			::MessageBox(NULL, stylePathToLoad, TEXT("Load stylers.xml failed"), MB_OK);
846  		}
847  		else
848  		{
849  			_pNativeLangSpeaker->messageBox("LoadStylersFailed",
850  				NULL,
851  				TEXT("Load \"$STR_REPLACE$\" failed!"),
852  				TEXT("Load stylers.xml failed"),
853  				MB_OK,
854  				0,
855  				stylePathToLoad);
856  		}
857  		delete _pXmlUserStylerDoc;
858  		_pXmlUserStylerDoc = NULL;
859  		return false;
860  	}
861  	_lexerStylerVect.clear();
862  	_widgetStyleArray.clear();
863  	getUserStylersFromXmlTree();
864  	for ( size_t i = 0; i < getExternalLexerDoc()->size(); ++i)
865  	{
866  		getExternalLexerFromXmlTree( getExternalLexerDoc()->at(i) );
867  	}
868  	return true;
869  }
870  bool NppParameters::reloadLang()
871  {
872  	generic_string nativeLangPath(_localizationSwitcher._nativeLangPath);
873  	if (!PathFileExists(nativeLangPath.c_str()))
874  	{
875  		nativeLangPath = _nppPath;
876  		pathAppend(nativeLangPath, generic_string(TEXT("nativeLang.xml")));
877  		if (!PathFileExists(nativeLangPath.c_str()))
878  			return false;
879  	}
880  	delete _pXmlNativeLangDocA;
881  	_pXmlNativeLangDocA = new TiXmlDocumentA();
882  	bool loadOkay = _pXmlNativeLangDocA->LoadUnicodeFilePath(nativeLangPath.c_str());
883  	if (!loadOkay)
884  	{
885  		delete _pXmlNativeLangDocA;
886  		_pXmlNativeLangDocA = nullptr;
887  		return false;
888  	}
889  	return loadOkay;
890  }
891  generic_string NppParameters::getSpecialFolderLocation(int folderKind)
892  {
893  	TCHAR path[MAX_PATH];
894  	const HRESULT specialLocationResult = SHGetFolderPath(nullptr, folderKind, nullptr, SHGFP_TYPE_CURRENT, path);
895  	generic_string result;
896  	if (SUCCEEDED(specialLocationResult))
897  	{
898  		result = path;
899  	}
900  	return result;
901  }
902  generic_string NppParameters::getSettingsFolder()
903  {
904  	if (_isLocal)
905  		return _nppPath;
906  	generic_string settingsFolderPath = getSpecialFolderLocation(CSIDL_APPDATA);
907  	if (settingsFolderPath.empty())
908  		return _nppPath;
909  	pathAppend(settingsFolderPath, TEXT("Notepad++"));
910  	return settingsFolderPath;
911  }
912  bool NppParameters::load()
913  {
914  	L_END = L_EXTERNAL;
915  	bool isAllLaoded = true;
916  	_isx64 = sizeof(void *) == 8;
917  	generic_string localConfPath(_nppPath);
918  	pathAppend(localConfPath, localConfFile);
919  	_isLocal = (PathFileExists(localConfPath.c_str()) == TRUE);
920  	if (_isLocal)
921  	{
922  		if (_winVersion >= WV_VISTA)
923  		{
924  			generic_string progPath = getSpecialFolderLocation(CSIDL_PROGRAM_FILES);
925  			TCHAR nppDirLocation[MAX_PATH];
926  			wcscpy_s(nppDirLocation, _nppPath.c_str());
927  			::PathRemoveFileSpec(nppDirLocation);
928  			if  (progPath == nppDirLocation)
929  				_isLocal = false;
930  		}
931  	}
932  	_pluginRootDir = _nppPath;
933  	pathAppend(_pluginRootDir, TEXT("plugins"));
934  	generic_string nppPluginRootParent;
935  	if (_isLocal)
936  	{
937  		_userPath = nppPluginRootParent = _nppPath;
938  		_userPluginConfDir = _pluginRootDir;
939  		pathAppend(_userPluginConfDir, TEXT("Config"));
940  	}
941  	else
942  	{
943  		_userPath = getSpecialFolderLocation(CSIDL_APPDATA);
944  		pathAppend(_userPath, TEXT("Notepad++"));
945  		if (!PathFileExists(_userPath.c_str()))
946  			::CreateDirectory(_userPath.c_str(), NULL);
947  		_appdataNppDir = _userPluginConfDir = _userPath;
948  		pathAppend(_userPluginConfDir, TEXT("plugins"));
949  		if (!PathFileExists(_userPluginConfDir.c_str()))
950  			::CreateDirectory(_userPluginConfDir.c_str(), NULL);
951  		pathAppend(_userPluginConfDir, TEXT("Config"));
952  		if (!PathFileExists(_userPluginConfDir.c_str()))
953  			::CreateDirectory(_userPluginConfDir.c_str(), NULL);
954  		setElevationRequired(true);
955  	}
956  	_pluginConfDir = _pluginRootDir; 
957  	pathAppend(_pluginConfDir, TEXT("Config"));
958  	if (!PathFileExists(nppPluginRootParent.c_str()))
959  		::CreateDirectory(nppPluginRootParent.c_str(), NULL);
960  	if (!PathFileExists(_pluginRootDir.c_str()))
961  		::CreateDirectory(_pluginRootDir.c_str(), NULL);
962  	_sessionPath = _userPath; 
963  	generic_string cloudChoicePath{_userPath};
964  	cloudChoicePath += TEXT("\\cloud\\choice");
965  	_isCloud = (::PathFileExists(cloudChoicePath.c_str()) == TRUE);
966  	if (_isCloud)
967  	{
968  		std::string cloudChoiceStr = getFileContent(cloudChoicePath.c_str());
969  		WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
970  		std::wstring cloudChoiceStrW = wmc.char2wchar(cloudChoiceStr.c_str(), SC_CP_UTF8);
971  		if (!cloudChoiceStrW.empty() && ::PathFileExists(cloudChoiceStrW.c_str()))
972  		{
973  			_userPath = cloudChoiceStrW;
974  			_nppGUI._cloudPath = cloudChoiceStrW;
975  			_initialCloudChoice = _nppGUI._cloudPath;
976  		}
977  		else
978  		{
979  			_isCloud = false;
980  		}
981  	}
982  	if (!_cmdSettingsDir.empty())
983  	{
984  		if (!::PathIsDirectory(_cmdSettingsDir.c_str()))
985  		{
986  			generic_string errMsg = TEXT("The given path\r");
987  			errMsg += _cmdSettingsDir;
988  			errMsg += TEXT("\nvia command line \"-settingsDir=\" is not a valid directory.\rThis argument will be ignored.");
989  			::MessageBox(NULL, errMsg.c_str(), TEXT("Invalid directory"), MB_OK);
990  		}
991  		else
992  		{
993  			_userPath = _cmdSettingsDir;
994  			_sessionPath = _userPath; 
995  		}
996  	}
997  	generic_string langs_xml_path(_userPath);
998  	pathAppend(langs_xml_path, TEXT("langs.xml"));
999  	BOOL doRecover = FALSE;
1000  	if (::PathFileExists(langs_xml_path.c_str()))
1001  	{
1002  		WIN32_FILE_ATTRIBUTE_DATA attributes{};
1003  		if (GetFileAttributesEx(langs_xml_path.c_str(), GetFileExInfoStandard, &attributes) != 0)
1004  		{
1005  			if (attributes.nFileSizeLow == 0 && attributes.nFileSizeHigh == 0)
1006  			{
1007  				if (_pNativeLangSpeaker)
1008  				{
1009  					doRecover = _pNativeLangSpeaker->messageBox("LoadLangsFailed",
1010  						NULL,
1011  						TEXT("Load langs.xml failed!\rDo you want to recover your langs.xml?"),
1012  						TEXT("Configurator"),
1013  						MB_YESNO);
1014  				}
1015  				else
1016  				{
1017  					doRecover = ::MessageBox(NULL, TEXT("Load langs.xml failed!\rDo you want to recover your langs.xml?"), TEXT("Configurator"), MB_YESNO);
1018  				}
1019  			}
1020  		}
1021  	}
1022  	else
1023  		doRecover = true;
1024  	if (doRecover)
1025  	{
1026  		generic_string srcLangsPath(_nppPath);
1027  		pathAppend(srcLangsPath, TEXT("langs.model.xml"));
1028  		::CopyFile(srcLangsPath.c_str(), langs_xml_path.c_str(), FALSE);
1029  	}
1030  	_pXmlDoc = new TiXmlDocument(langs_xml_path);
1031  	bool loadOkay = _pXmlDoc->LoadFile();
1032  	if (!loadOkay)
1033  	{
1034  		if (_pNativeLangSpeaker)
1035  		{
1036  			_pNativeLangSpeaker->messageBox("LoadLangsFailedFinal",
1037  				NULL,
1038  				TEXT("Load langs.xml failed!"),
1039  				TEXT("Configurator"),
1040  				MB_OK);
1041  		}
1042  		else
1043  		{
1044  			::MessageBox(NULL, TEXT("Load langs.xml failed!"), TEXT("Configurator"), MB_OK);
1045  		}
1046  		delete _pXmlDoc;
1047  		_pXmlDoc = nullptr;
1048  		isAllLaoded = false;
1049  	}
1050  	else
1051  		getLangKeywordsFromXmlTree();
1052  	generic_string configPath(_userPath);
1053  	pathAppend(configPath, TEXT("config.xml"));
1054  	generic_string srcConfigPath(_nppPath);
1055  	pathAppend(srcConfigPath, TEXT("config.model.xml"));
1056  	if (!::PathFileExists(configPath.c_str()))
1057  		::CopyFile(srcConfigPath.c_str(), configPath.c_str(), FALSE);
1058  	_pXmlUserDoc = new TiXmlDocument(configPath);
1059  	loadOkay = _pXmlUserDoc->LoadFile();
1060  	if (!loadOkay)
1061  	{
1062  		TiXmlDeclaration* decl = new TiXmlDeclaration(TEXT("1.0"), TEXT("UTF-8"), TEXT(""));
1063  		_pXmlUserDoc->LinkEndChild(decl);
1064  	}
1065  	else
1066  	{
1067  		getUserParametersFromXmlTree();
1068  	}
1069  	_stylerPath = _userPath;
1070  	pathAppend(_stylerPath, TEXT("stylers.xml"));
1071  	if (!PathFileExists(_stylerPath.c_str()))
1072  	{
1073  		generic_string srcStylersPath(_nppPath);
1074  		pathAppend(srcStylersPath, TEXT("stylers.model.xml"));
1075  		::CopyFile(srcStylersPath.c_str(), _stylerPath.c_str(), TRUE);
1076  	}
1077  	if (_nppGUI._themeName.empty() || (!PathFileExists(_nppGUI._themeName.c_str())))
1078  		_nppGUI._themeName.assign(_stylerPath);
1079  	_pXmlUserStylerDoc = new TiXmlDocument(_nppGUI._themeName.c_str());
1080  	loadOkay = _pXmlUserStylerDoc->LoadFile();
1081  	if (!loadOkay)
1082  	{
1083  		if (_pNativeLangSpeaker)
1084  		{
1085  			_pNativeLangSpeaker->messageBox("LoadStylersFailed",
1086  				NULL,
1087  				TEXT("Load \"$STR_REPLACE$\" failed!"),
1088  				TEXT("Load stylers.xml failed"),
1089  				MB_OK,
1090  				0,
1091  				_stylerPath.c_str());
1092  		}
1093  		else
1094  		{
1095  			::MessageBox(NULL, _stylerPath.c_str(), TEXT("Load stylers.xml failed"), MB_OK);
1096  		}
1097  		delete _pXmlUserStylerDoc;
1098  		_pXmlUserStylerDoc = NULL;
1099  		isAllLaoded = false;
1100  	}
1101  	else
1102  		getUserStylersFromXmlTree();
1103  	_themeSwitcher._stylesXmlPath = _stylerPath;
1104  	_themeSwitcher.addDefaultThemeFromXml(_stylerPath);
1105  	_userDefineLangsFolderPath = _userDefineLangPath = _userPath;
1106  	pathAppend(_userDefineLangPath, TEXT("userDefineLang.xml"));
1107  	pathAppend(_userDefineLangsFolderPath, TEXT("userDefineLangs"));
1108  	std::vector<generic_string> udlFiles;
1109  	getFilesInFolder(udlFiles, TEXT("*.xml"), _userDefineLangsFolderPath);
1110  	_pXmlUserLangDoc = new TiXmlDocument(_userDefineLangPath);
1111  	loadOkay = _pXmlUserLangDoc->LoadFile();
1112  	if (!loadOkay)
1113  	{
1114  		delete _pXmlUserLangDoc;
1115  		_pXmlUserLangDoc = nullptr;
1116  		isAllLaoded = false;
1117  	}
1118  	else
1119  	{
1120  		auto r = addUserDefineLangsFromXmlTree(_pXmlUserLangDoc);
1121  		if (r.second - r.first > 0)
1122  			_pXmlUserLangsDoc.push_back(UdlXmlFileState(_pXmlUserLangDoc, false, true, r));
1123  	}
1124  	for (const auto& i : udlFiles)
1125  	{
1126  		auto udlDoc = new TiXmlDocument(i);
1127  		loadOkay = udlDoc->LoadFile();
1128  		if (!loadOkay)
1129  		{
1130  			delete udlDoc;
1131  		}
1132  		else
1133  		{
1134  			auto r = addUserDefineLangsFromXmlTree(udlDoc);
1135  			if (r.second - r.first > 0)
1136  				_pXmlUserLangsDoc.push_back(UdlXmlFileState(udlDoc, false, false, r));
1137  		}
1138  	}
1139  	generic_string nativeLangPath;
1140  	nativeLangPath = _userPath;
1141  	pathAppend(nativeLangPath, TEXT("nativeLang.xml"));
1142  	_localizationSwitcher._nativeLangPath = nativeLangPath;
1143  	if (!_startWithLocFileName.empty()) 
1144  	{
1145  		nativeLangPath = _nppPath;
1146  		pathAppend(nativeLangPath, TEXT("localization\\"));
1147  		pathAppend(nativeLangPath, _startWithLocFileName);
1148  	}
1149  	else 
1150  	{
1151  		if (!PathFileExists(nativeLangPath.c_str()))
1152  		{
1153  			nativeLangPath = _nppPath;
1154  			pathAppend(nativeLangPath, TEXT("nativeLang.xml"));
1155  		}
1156  	}
1157  	_pXmlNativeLangDocA = new TiXmlDocumentA();
1158  	loadOkay = _pXmlNativeLangDocA->LoadUnicodeFilePath(nativeLangPath.c_str());
1159  	if (!loadOkay)
1160  	{
1161  		delete _pXmlNativeLangDocA;
1162  		_pXmlNativeLangDocA = nullptr;
1163  		isAllLaoded = false;
1164  	}
1165  	generic_string toolbarIconsPath(_userPath);
1166  	pathAppend(toolbarIconsPath, TEXT("toolbarIcons.xml"));
1167  	_pXmlToolIconsDoc = new TiXmlDocument(toolbarIconsPath);
1168  	loadOkay = _pXmlToolIconsDoc->LoadFile();
1169  	if (!loadOkay)
1170  	{
1171  		delete _pXmlToolIconsDoc;
1172  		_pXmlToolIconsDoc = nullptr;
1173  		isAllLaoded = false;
1174  	}
1175  	wstring v852NoNeedShortcutsBackup;
1176  	_shortcutsPath = v852NoNeedShortcutsBackup = _userPath;
1177  	pathAppend(_shortcutsPath, SHORTCUTSXML_FILENAME);
1178  	pathAppend(v852NoNeedShortcutsBackup, NONEEDSHORTCUTSXMLBACKUP_FILENAME);
1179  	if (!PathFileExists(_shortcutsPath.c_str()))
1180  	{
1181  		generic_string srcShortcutsPath(_nppPath);
1182  		pathAppend(srcShortcutsPath, SHORTCUTSXML_FILENAME);
1183  		::CopyFile(srcShortcutsPath.c_str(), _shortcutsPath.c_str(), TRUE);
1184  		HANDLE hFile = ::CreateFile(v852NoNeedShortcutsBackup.c_str(), GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
1185  		::FlushFileBuffers(hFile);
1186  		::CloseHandle(hFile);
1187  	}
1188  	_pXmlShortcutDocA = new TiXmlDocumentA();
1189  	loadOkay = _pXmlShortcutDocA->LoadUnicodeFilePath(_shortcutsPath.c_str());
1190  	if (!loadOkay)
1191  	{
1192  		delete _pXmlShortcutDocA;
1193  		_pXmlShortcutDocA = nullptr;
1194  		isAllLaoded = false;
1195  	}
1196  	else
1197  	{
1198  		getShortcutsFromXmlTree();
1199  		getMacrosFromXmlTree();
1200  		getUserCmdsFromXmlTree();
1201  		getScintKeysFromXmlTree();
1202  	}
1203  	_contextMenuPath = _userPath;
1204  	pathAppend(_contextMenuPath, TEXT("contextMenu.xml"));
1205  	if (!PathFileExists(_contextMenuPath.c_str()))
1206  	{
1207  		generic_string srcContextMenuPath(_nppPath);
1208  		pathAppend(srcContextMenuPath, TEXT("contextMenu.xml"));
1209  		::CopyFile(srcContextMenuPath.c_str(), _contextMenuPath.c_str(), TRUE);
1210  	}
1211  	_pXmlContextMenuDocA = new TiXmlDocumentA();
1212  	loadOkay = _pXmlContextMenuDocA->LoadUnicodeFilePath(_contextMenuPath.c_str());
1213  	if (!loadOkay)
1214  	{
1215  		delete _pXmlContextMenuDocA;
1216  		_pXmlContextMenuDocA = nullptr;
1217  		isAllLaoded = false;
1218  	}
1219  	_tabContextMenuPath = _userPath;
1220  	pathAppend(_tabContextMenuPath, TEXT("tabContextMenu.xml"));
1221  	_pXmlTabContextMenuDocA = new TiXmlDocumentA();
1222  	loadOkay = _pXmlTabContextMenuDocA->LoadUnicodeFilePath(_tabContextMenuPath.c_str());
1223  	if (!loadOkay)
1224  	{
1225  		delete _pXmlTabContextMenuDocA;
1226  		_pXmlTabContextMenuDocA = nullptr;
1227  	}
1228  	pathAppend(_sessionPath, TEXT("session.xml"));
1229  	const NppGUI & nppGUI = (NppParameters::getInstance()).getNppGUI();
1230  	if (nppGUI._rememberLastSession)
1231  	{
1232  		TiXmlDocument* pXmlSessionDoc = new TiXmlDocument(_sessionPath);
1233  		loadOkay = pXmlSessionDoc->LoadFile();
1234  		if (!loadOkay)
1235  			isAllLaoded = false;
1236  		else
1237  			getSessionFromXmlTree(pXmlSessionDoc, _session);
1238  		delete pXmlSessionDoc;
1239  		for (size_t i = 0, len = _pXmlExternalLexerDoc.size() ; i < len ; ++i)
1240  			if (_pXmlExternalLexerDoc[i])
1241  				delete _pXmlExternalLexerDoc[i];
1242  	}
1243  	generic_string enableSelectFgColorPath = _userPath;
1244  	pathAppend(enableSelectFgColorPath, TEXT("enableSelectFgColor.xml"));
1245  	if (PathFileExists(enableSelectFgColorPath.c_str()))
1246  	{
1247  		_isSelectFgColorEnabled = true;
1248  	}
1249  	generic_string filePath, filePath2, issueFileName;
1250  	filePath = _nppPath;
1251  	issueFileName = nppLogNetworkDriveIssue;
1252  	issueFileName += TEXT(".xml");
1253  	pathAppend(filePath, issueFileName);
1254  	_doNppLogNetworkDriveIssue = (PathFileExists(filePath.c_str()) == TRUE);
1255  	if (!_doNppLogNetworkDriveIssue)
1256  	{
1257  		filePath2 = _userPath;
1258  		pathAppend(filePath2, issueFileName);
1259  		_doNppLogNetworkDriveIssue = (PathFileExists(filePath2.c_str()) == TRUE);
1260  	}
1261  	filePath = _nppPath;
1262  	issueFileName = nppLogNulContentCorruptionIssue;
1263  	issueFileName += TEXT(".xml");
1264  	pathAppend(filePath, issueFileName);
1265  	_doNppLogNulContentCorruptionIssue = (PathFileExists(filePath.c_str()) == TRUE);
1266  	if (!_doNppLogNulContentCorruptionIssue)
1267  	{
1268  		filePath2 = _userPath;
1269  		pathAppend(filePath2, issueFileName);
1270  		_doNppLogNulContentCorruptionIssue = (PathFileExists(filePath2.c_str()) == TRUE);
1271  	}
1272  	return isAllLaoded;
1273  }
1274  void NppParameters::destroyInstance()
1275  {
1276  	delete _pXmlDoc;
1277  	delete _pXmlUserDoc;
1278  	delete _pXmlUserStylerDoc;
1279  	for (auto& l : _pXmlUserLangsDoc)
1280  	{
1281  		delete l._udlXmlDoc;
1282  	}
1283  	delete _pXmlNativeLangDocA;
1284  	delete _pXmlToolIconsDoc;
1285  	delete _pXmlShortcutDocA;
1286  	delete _pXmlContextMenuDocA;
1287  	delete _pXmlTabContextMenuDocA;
1288  	delete 	getInstancePointer();
1289  }
1290  void NppParameters::saveConfig_xml()
1291  {
1292  	if (_pXmlUserDoc)
1293  		_pXmlUserDoc->SaveFile();
1294  }
1295  void NppParameters::setWorkSpaceFilePath(int i, const TCHAR* wsFile)
1296  {
1297  	if (i < 0 || i > 2 || !wsFile)
1298  		return;
1299  	_workSpaceFilePathes[i] = wsFile;
1300  }
1301  void NppParameters::removeTransparent(HWND hwnd)
1302  {
1303  	if (hwnd != nullptr)
1304  		::SetWindowLongPtr(hwnd, GWL_EXSTYLE, ::GetWindowLongPtr(hwnd, GWL_EXSTYLE) & ~WS_EX_LAYERED);
1305  }
1306  void NppParameters::SetTransparent(HWND hwnd, int percent)
1307  {
1308  	::SetWindowLongPtr(hwnd, GWL_EXSTYLE, ::GetWindowLongPtr(hwnd, GWL_EXSTYLE) | WS_EX_LAYERED);
1309  	if (percent > 255)
1310  		percent = 255;
1311  	else if (percent < 0)
1312  		percent = 0;
1313  	::SetLayeredWindowAttributes(hwnd, 0, static_cast<BYTE>(percent), LWA_ALPHA);
1314  }
1315  bool NppParameters::isExistingExternalLangName(const char* newName) const
1316  {
1317  	if ((!newName) || (!newName[0]))
1318  		return true;
1319  	for (int i = 0 ; i < _nbExternalLang ; ++i)
1320  	{
1321  		if (_externalLangArray[i]->_name == newName)
1322  			return true;
1323  	}
1324  	return false;
1325  }
1326  const TCHAR* NppParameters::getUserDefinedLangNameFromExt(TCHAR *ext, TCHAR *fullName) const
1327  {
1328  	if ((!ext) || (!ext[0]))
1329  		return nullptr;
1330  	std::vector<generic_string> extVect;
1331  	int iMatched = -1;
1332  	for (int i = 0 ; i < _nbUserLang ; ++i)
1333  	{
1334  		extVect.clear();
1335  		cutString(_userLangArray[i]->_ext.c_str(), extVect);
1336  		for (size_t j = 0, len = extVect.size(); j < len; ++j)
1337  		{
1338  			if (!wcsicmp(extVect[j].c_str(), ext) || (wcschr(fullName, '.') && !wcsicmp(extVect[j].c_str(), fullName)))
1339  			{
1340  				iMatched = i;
1341  				if (((NppDarkMode::isEnabled() && _userLangArray[i]->_isDarkModeTheme)) ||
1342  					((!NppDarkMode::isEnabled() && !_userLangArray[i]->_isDarkModeTheme)))
1343  					return _userLangArray[i]->_name.c_str();
1344  			}
1345  		}
1346  	}
1347  	if (iMatched >= 0)
1348  	{
1349  		return _userLangArray[iMatched]->_name.c_str();
1350  	}
1351  	return nullptr;
1352  }
1353  int NppParameters::getExternalLangIndexFromName(const TCHAR* externalLangName) const
1354  {
1355  	WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
1356  	for (int i = 0 ; i < _nbExternalLang ; ++i)
1357  	{
1358  		if (!lstrcmp(externalLangName, wmc.char2wchar(_externalLangArray[i]->_name.c_str(), CP_ACP)))
1359  			return i;
1360  	}
1361  	return -1;
1362  }
1363  UserLangContainer* NppParameters::getULCFromName(const TCHAR *userLangName)
1364  {
1365  	for (int i = 0 ; i < _nbUserLang ; ++i)
1366  	{
1367  		if (0 == lstrcmp(userLangName, _userLangArray[i]->_name.c_str()))
1368  			return _userLangArray[i];
1369  	}
1370  	return nullptr;
1371  }
1372  COLORREF NppParameters::getCurLineHilitingColour()
1373  {
1374  	const Style * pStyle = _widgetStyleArray.findByName(TEXT("Current line background colour"));
1375  	if (!pStyle)
1376  		return COLORREF(-1);
1377  	return pStyle->_bgColor;
1378  }
1379  void NppParameters::setCurLineHilitingColour(COLORREF colour2Set)
1380  {
1381  	Style * pStyle = _widgetStyleArray.findByName(TEXT("Current line background colour"));
1382  	if (!pStyle)
1383  		return;
1384  	pStyle->_bgColor = colour2Set;
1385  }
1386  static int CALLBACK EnumFontFamExProc(const LOGFONT* lpelfe, const TEXTMETRIC*, DWORD, LPARAM lParam)
1387  {
1388  	std::vector<generic_string>& strVect = *(std::vector<generic_string> *)lParam;
1389  	const int32_t vectSize = static_cast<int32_t>(strVect.size());
1390  	const TCHAR* lfFaceName = ((ENUMLOGFONTEX*)lpelfe)->elfLogFont.lfFaceName;
1391  	for (int i = vectSize - 1 ; i >= 0 ; i--)
1392  	{
1393  		if (0 == lstrcmp(strVect[i].c_str(), lfFaceName))
1394  			return 1;	
1395  	}
1396  	strVect.push_back(lfFaceName);
1397  	return 1; 
1398  }
1399  void NppParameters::setFontList(HWND hWnd)
1400  {
1401  	LOGFONT lf{};
1402  	_fontlist.clear();
1403  	_fontlist.reserve(64); 
1404  	_fontlist.push_back(generic_string());
1405  	lf.lfCharSet = DEFAULT_CHARSET;
1406  	lf.lfFaceName[0]='\0';
1407  	lf.lfPitchAndFamily = 0;
1408  	HDC hDC = ::GetDC(hWnd);
1409  	::EnumFontFamiliesEx(hDC, &lf, EnumFontFamExProc, reinterpret_cast<LPARAM>(&_fontlist), 0);
1410  }
1411  bool NppParameters::isInFontList(const generic_string& fontName2Search) const
1412  {
1413  	if (fontName2Search.empty())
1414  		return false;
1415  	for (size_t i = 0, len = _fontlist.size(); i < len; i++)
1416  	{
1417  		if (_fontlist[i] == fontName2Search)
1418  			return true;
1419  	}
1420  	return false;
1421  }
1422  LOGFONT NppParameters::getDefaultGUIFont(DefaultFontType type)
1423  {
1424  	LOGFONT lf{};
1425  	NONCLIENTMETRICS ncm{};
1426  	ncm.cbSize = sizeof(NONCLIENTMETRICS);
1427  	if (::SystemParametersInfo(SPI_GETNONCLIENTMETRICS, sizeof(NONCLIENTMETRICS), &ncm, 0) != FALSE)
1428  	{
1429  		switch (type)
1430  		{
1431  			case DefaultFontType::menu:
1432  			{
1433  				lf = ncm.lfMenuFont;
1434  				break;
1435  			}
1436  			case DefaultFontType::status:
1437  			{
1438  				lf = ncm.lfStatusFont;
1439  				break;
1440  			}
1441  			case DefaultFontType::caption:
1442  			{
1443  				lf = ncm.lfCaptionFont;
1444  				break;
1445  			}
1446  			case DefaultFontType::smcaption:
1447  			{
1448  				lf = ncm.lfSmCaptionFont;
1449  				break;
1450  			}
1451  			default:
1452  			{
1453  				lf = ncm.lfMessageFont;
1454  				break;
1455  			}
1456  		}
1457  	}
1458  	else 
1459  	{
1460  		auto hf = static_cast<HFONT>(::GetStockObject(DEFAULT_GUI_FONT));
1461  		::GetObject(hf, sizeof(LOGFONT), &lf);
1462  	}
1463  	return lf;
1464  }
1465  void NppParameters::getLangKeywordsFromXmlTree()
1466  {
1467  	TiXmlNode *root =
1468  		_pXmlDoc->FirstChild(TEXT("NotepadPlus"));
1469  		if (!root) return;
1470  	feedKeyWordsParameters(root);
1471  }
1472  void NppParameters::getExternalLexerFromXmlTree(TiXmlDocument* externalLexerDoc)
1473  {
1474  	TiXmlNode *root = externalLexerDoc->FirstChild(TEXT("NotepadPlus"));
1475  		if (!root) return;
1476  	feedKeyWordsParameters(root);
1477  	feedStylerArray(root);
1478  }
1479  int NppParameters::addExternalLangToEnd(ExternalLangContainer * externalLang)
1480  {
1481  	_externalLangArray[_nbExternalLang] = externalLang;
1482  	++_nbExternalLang;
1483  	++L_END;
1484  	return _nbExternalLang-1;
1485  }
1486  bool NppParameters::getUserStylersFromXmlTree()
1487  {
1488  	TiXmlNode *root = _pXmlUserStylerDoc->FirstChild(TEXT("NotepadPlus"));
1489  		if (!root) return false;
1490  	return feedStylerArray(root);
1491  }
1492  bool NppParameters::getUserParametersFromXmlTree()
1493  {
1494  	if (!_pXmlUserDoc)
1495  		return false;
1496  	TiXmlNode *root = _pXmlUserDoc->FirstChild(TEXT("NotepadPlus"));
1497  	if (!root)
1498  		return false;
1499  	feedGUIParameters(root);
1500  	feedFileListParameters(root);
1501  	TiXmlNode *node = root->FirstChildElement(TEXT("History"));
1502  	root->RemoveChild(node);
1503  	TiXmlElement HistoryNode(TEXT("History"));
1504  	root->InsertEndChild(HistoryNode);
1505  	feedFindHistoryParameters(root);
1506  	feedProjectPanelsParameters(root);
1507  	feedFileBrowserParameters(root);
1508  	feedColumnEditorParameters(root);
1509  	return true;
1510  }
1511  std::pair<unsigned char, unsigned char> NppParameters::addUserDefineLangsFromXmlTree(TiXmlDocument *tixmldoc)
1512  {
1513  	if (!tixmldoc)
1514  		return std::make_pair(static_cast<unsigned char>(0), static_cast<unsigned char>(0));
1515  	TiXmlNode *root = tixmldoc->FirstChild(TEXT("NotepadPlus"));
1516  	if (!root)
1517  		return std::make_pair(static_cast<unsigned char>(0), static_cast<unsigned char>(0));
1518  	return feedUserLang(root);
1519  }
1520  bool NppParameters::getShortcutsFromXmlTree()
1521  {
1522  	if (!_pXmlShortcutDocA)
1523  		return false;
1524  	TiXmlNodeA *root = _pXmlShortcutDocA->FirstChild("NotepadPlus");
1525  	if (!root)
1526  		return false;
1527  	feedShortcut(root);
1528  	return true;
1529  }
1530  bool NppParameters::getMacrosFromXmlTree()
1531  {
1532  	if (!_pXmlShortcutDocA)
1533  		return false;
1534  	TiXmlNodeA *root = _pXmlShortcutDocA->FirstChild("NotepadPlus");
1535  	if (!root)
1536  		return false;
1537  	feedMacros(root);
1538  	return true;
1539  }
1540  bool NppParameters::getUserCmdsFromXmlTree()
1541  {
1542  	if (!_pXmlShortcutDocA)
1543  		return false;
1544  	TiXmlNodeA *root = _pXmlShortcutDocA->FirstChild("NotepadPlus");
1545  	if (!root)
1546  		return false;
1547  	feedUserCmds(root);
1548  	return true;
1549  }
1550  bool NppParameters::getPluginCmdsFromXmlTree()
1551  {
1552  	if (!_pXmlShortcutDocA)
1553  		return false;
1554  	TiXmlNodeA *root = _pXmlShortcutDocA->FirstChild("NotepadPlus");
1555  	if (!root)
1556  		return false;
1557  	feedPluginCustomizedCmds(root);
1558  	return true;
1559  }
1560  bool NppParameters::getScintKeysFromXmlTree()
1561  {
1562  	if (!_pXmlShortcutDocA)
1563  		return false;
1564  	TiXmlNodeA *root = _pXmlShortcutDocA->FirstChild("NotepadPlus");
1565  	if (!root)
1566  		return false;
1567  	feedScintKeys(root);
1568  	return true;
1569  }
1570  void NppParameters::initMenuKeys()
1571  {
1572  	int nbCommands = sizeof(winKeyDefs)/sizeof(WinMenuKeyDefinition);
1573  	WinMenuKeyDefinition wkd;
1574  	for (int i = 0; i < nbCommands; ++i)
1575  	{
1576  		wkd = winKeyDefs[i];
1577  		Shortcut sc((wkd.specialName ? wstring2string(wkd.specialName, CP_UTF8).c_str() : ""), wkd.isCtrl, wkd.isAlt, wkd.isShift, static_cast<unsigned char>(wkd.vKey));
1578  		_shortcuts.push_back( CommandShortcut(sc, wkd.functionId) );
1579  	}
1580  }
1581  void NppParameters::initScintillaKeys()
1582  {
1583  	int nbCommands = sizeof(scintKeyDefs)/sizeof(ScintillaKeyDefinition);
1584  	ScintillaKeyDefinition skd;
1585  	int prevIndex = -1;
1586  	int prevID = -1;
1587  	for (int i = 0; i < nbCommands; ++i)
1588  	{
1589  		skd = scintKeyDefs[i];
1590  		if (skd.functionId == prevID)
1591  		{
1592  			KeyCombo kc;
1593  			kc._isCtrl = skd.isCtrl;
1594  			kc._isAlt = skd.isAlt;
1595  			kc._isShift = skd.isShift;
1596  			kc._key = static_cast<unsigned char>(skd.vKey);
1597  			_scintillaKeyCommands[prevIndex].addKeyCombo(kc);
1598  		}
1599  		else
1600  		{
1601  			Shortcut s = Shortcut(wstring2string(skd.name, CP_UTF8).c_str(), skd.isCtrl, skd.isAlt, skd.isShift, static_cast<unsigned char>(skd.vKey));
1602  			ScintillaKeyMap sm = ScintillaKeyMap(s, skd.functionId, skd.redirFunctionId);
1603  			_scintillaKeyCommands.push_back(sm);
1604  			++prevIndex;
1605  		}
1606  		prevID = skd.functionId;
1607  	}
1608  }
1609  bool NppParameters::reloadContextMenuFromXmlTree(HMENU mainMenuHadle, HMENU pluginsMenu)
1610  {
1611  	_contextMenuItems.clear();
1612  	return getContextMenuFromXmlTree(mainMenuHadle, pluginsMenu);
1613  }
1614  int NppParameters::getCmdIdFromMenuEntryItemName(HMENU mainMenuHadle, const generic_string& menuEntryName, const generic_string& menuItemName)
1615  {
1616  	int nbMenuEntry = ::GetMenuItemCount(mainMenuHadle);
1617  	for (int i = 0; i < nbMenuEntry; ++i)
1618  	{
1619  		TCHAR menuEntryString[menuItemStrLenMax];
1620  		::GetMenuString(mainMenuHadle, i, menuEntryString, menuItemStrLenMax, MF_BYPOSITION);
1621  		if (wcsicmp(menuEntryName.c_str(), purgeMenuItemString(menuEntryString).c_str()) == 0)
1622  		{
1623  			vector< pair<HMENU, int> > parentMenuPos;
1624  			HMENU topMenu = ::GetSubMenu(mainMenuHadle, i);
1625  			int maxTopMenuPos = ::GetMenuItemCount(topMenu);
1626  			HMENU currMenu = topMenu;
1627  			int currMaxMenuPos = maxTopMenuPos;
1628  			int currMenuPos = 0;
1629  			bool notFound = false;
1630  			do {
1631  				if (::GetSubMenu(currMenu, currMenuPos))
1632  				{
1633  					parentMenuPos.push_back(::make_pair(currMenu, currMenuPos));
1634  					currMenu = ::GetSubMenu(currMenu, currMenuPos);
1635  					currMenuPos = 0;
1636  					currMaxMenuPos = ::GetMenuItemCount(currMenu);
1637  				}
1638  				else
1639  				{
1640  					TCHAR cmdStr[menuItemStrLenMax];
1641  					::GetMenuString(currMenu, currMenuPos, cmdStr, menuItemStrLenMax, MF_BYPOSITION);
1642  					if (wcsicmp(menuItemName.c_str(), purgeMenuItemString(cmdStr).c_str()) == 0)
1643  					{
1644  						return ::GetMenuItemID(currMenu, currMenuPos);
1645  					}
1646  					if ((currMenuPos >= currMaxMenuPos) && (parentMenuPos.size() > 0))
1647  					{
1648  						currMenu = parentMenuPos.back().first;
1649  						currMenuPos = parentMenuPos.back().second;
1650  						parentMenuPos.pop_back();
1651  						currMaxMenuPos = ::GetMenuItemCount(currMenu);
1652  					}
1653  					if ((currMenu == topMenu) && (currMenuPos >= maxTopMenuPos))
1654  					{
1655  						notFound = true;
1656  					}
1657  					else
1658  					{
1659  						++currMenuPos;
1660  					}
1661  				}
1662  			} while (!notFound);
1663  		}
1664  	}
1665  	return -1;
1666  }
1667  int NppParameters::getPluginCmdIdFromMenuEntryItemName(HMENU pluginsMenu, const generic_string& pluginName, const generic_string& pluginCmdName)
1668  {
1669  	int nbPlugins = ::GetMenuItemCount(pluginsMenu);
1670  	for (int i = 0; i < nbPlugins; ++i)
1671  	{
1672  		TCHAR menuItemString[menuItemStrLenMax];
1673  		::GetMenuString(pluginsMenu, i, menuItemString, menuItemStrLenMax, MF_BYPOSITION);
1674  		if (wcsicmp(pluginName.c_str(), purgeMenuItemString(menuItemString).c_str()) == 0)
1675  		{
1676  			HMENU pluginMenu = ::GetSubMenu(pluginsMenu, i);
1677  			int nbPluginCmd = ::GetMenuItemCount(pluginMenu);
1678  			for (int j = 0; j < nbPluginCmd; ++j)
1679  			{
1680  				TCHAR pluginCmdStr[menuItemStrLenMax];
1681  				::GetMenuString(pluginMenu, j, pluginCmdStr, menuItemStrLenMax, MF_BYPOSITION);
1682  				if (wcsicmp(pluginCmdName.c_str(), purgeMenuItemString(pluginCmdStr).c_str()) == 0)
1683  				{
1684  					return ::GetMenuItemID(pluginMenu, j);
1685  				}
1686  			}
1687  		}
1688  	}
1689  	return -1;
1690  }
1691  bool NppParameters::getContextMenuFromXmlTree(HMENU mainMenuHadle, HMENU pluginsMenu, bool isEditCM)
1692  {
1693  	std::vector<MenuItemUnit>& contextMenuItems = isEditCM ? _contextMenuItems : _tabContextMenuItems;
1694  	TiXmlDocumentA* pXmlContextMenuDocA = isEditCM ? _pXmlContextMenuDocA : _pXmlTabContextMenuDocA;
1695  	std::string cmName = isEditCM ? "ScintillaContextMenu" : "TabContextMenu";
1696  	if (!pXmlContextMenuDocA)
1697  		return false;
1698  	TiXmlNodeA *root = pXmlContextMenuDocA->FirstChild("NotepadPlus");
1699  	if (!root)
1700  		return false;
1701  	WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
1702  	NativeLangSpeaker* pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
1703  	TiXmlNodeA *contextMenuRoot = root->FirstChildElement(cmName.c_str());
1704  	if (contextMenuRoot)
1705  	{
1706  		for (TiXmlNodeA *childNode = contextMenuRoot->FirstChildElement("Item");
1707  			childNode ;
1708  			childNode = childNode->NextSibling("Item") )
1709  		{
1710  			const char *folderNameDefaultA = (childNode->ToElement())->Attribute("FolderName");
1711  			const char *folderNameTranslateID_A = (childNode->ToElement())->Attribute("TranslateID");
1712  			const char *displayAsA = (childNode->ToElement())->Attribute("ItemNameAs");
1713  			generic_string folderName;
1714  			generic_string displayAs;
1715  			folderName = folderNameDefaultA ? wmc.char2wchar(folderNameDefaultA, SC_CP_UTF8) : TEXT("");
1716  			displayAs = displayAsA ? wmc.char2wchar(displayAsA, SC_CP_UTF8) : TEXT("");
1717  			if (folderNameTranslateID_A)
1718  			{
1719  				folderName = pNativeSpeaker->getLocalizedStrFromID(folderNameTranslateID_A, folderName);
1720  			}
1721  			int id;
1722  			const char *idStr = (childNode->ToElement())->Attribute("id", &id);
1723  			if (idStr)
1724  			{
1725  				contextMenuItems.push_back(MenuItemUnit(id, displayAs.c_str(), folderName.c_str()));
1726  			}
1727  			else
1728  			{
1729  				const char *menuEntryNameA = (childNode->ToElement())->Attribute("MenuEntryName");
1730  				const char *menuItemNameA = (childNode->ToElement())->Attribute("MenuItemName");
1731  				generic_string menuEntryName;
1732  				generic_string menuItemName;
1733  				menuEntryName = menuEntryNameA?wmc.char2wchar(menuEntryNameA, SC_CP_UTF8):TEXT("");
1734  				menuItemName = menuItemNameA?wmc.char2wchar(menuItemNameA, SC_CP_UTF8):TEXT("");
1735  				if (!menuEntryName.empty() && !menuItemName.empty())
1736  				{
1737  					int cmd = getCmdIdFromMenuEntryItemName(mainMenuHadle, menuEntryName, menuItemName);
1738  					if (cmd != -1)
1739  						contextMenuItems.push_back(MenuItemUnit(cmd, displayAs.c_str(), folderName.c_str()));
1740  				}
1741  				else
1742  				{
1743  					const char *pluginNameA = (childNode->ToElement())->Attribute("PluginEntryName");
1744  					const char *pluginCmdNameA = (childNode->ToElement())->Attribute("PluginCommandItemName");
1745  					generic_string pluginName;
1746  					generic_string pluginCmdName;
1747  					pluginName = pluginNameA?wmc.char2wchar(pluginNameA, SC_CP_UTF8):TEXT("");
1748  					pluginCmdName = pluginCmdNameA?wmc.char2wchar(pluginCmdNameA, SC_CP_UTF8):TEXT("");
1749  					if (pluginsMenu && !pluginName.empty() && !pluginCmdName.empty())
1750  					{
1751  						int pluginCmdId = getPluginCmdIdFromMenuEntryItemName(pluginsMenu, pluginName, pluginCmdName);
1752  						if (pluginCmdId != -1)
1753  							contextMenuItems.push_back(MenuItemUnit(pluginCmdId, displayAs.c_str(), folderName.c_str()));
1754  					}
1755  				}
1756  			}
1757  		}
1758  	}
1759  	return true;
1760  }
1761  void NppParameters::setWorkingDir(const TCHAR * newPath)
1762  {
1763  	if (newPath && newPath[0])
1764  	{
1765  		_currentDirectory = newPath;
1766  	}
1767  	else
1768  	{
1769  		if (PathFileExists(_nppGUI._defaultDirExp))
1770  			_currentDirectory = _nppGUI._defaultDirExp;
1771  		else
1772  			_currentDirectory = _nppPath.c_str();
1773  	}
1774  }
1775  bool NppParameters::loadSession(Session & session, const TCHAR *sessionFileName)
1776  {
1777  	TiXmlDocument *pXmlSessionDocument = new TiXmlDocument(sessionFileName);
1778  	bool loadOkay = pXmlSessionDocument->LoadFile();
1779  	if (loadOkay)
1780  		loadOkay = getSessionFromXmlTree(pXmlSessionDocument, session);
1781  	delete pXmlSessionDocument;
1782  	return loadOkay;
1783  }
1784  bool NppParameters::getSessionFromXmlTree(TiXmlDocument *pSessionDoc, Session& session)
1785  {
1786  	if (!pSessionDoc)
1787  		return false;
1788  	TiXmlNode *root = pSessionDoc->FirstChild(TEXT("NotepadPlus"));
1789  	if (!root)
1790  		return false;
1791  	TiXmlNode *sessionRoot = root->FirstChildElement(TEXT("Session"));
1792  	if (!sessionRoot)
1793  		return false;
1794  	TiXmlElement *actView = sessionRoot->ToElement();
1795  	int index = 0;
1796  	const TCHAR *str = actView->Attribute(TEXT("activeView"), &index);
1797  	if (str)
1798  	{
1799  		session._activeView = index;
1800  	}
1801  	const size_t nbView = 2;
1802  	TiXmlNode *viewRoots[nbView];
1803  	viewRoots[0] = sessionRoot->FirstChildElement(TEXT("mainView"));
1804  	viewRoots[1] = sessionRoot->FirstChildElement(TEXT("subView"));
1805  	for (size_t k = 0; k < nbView; ++k)
1806  	{
1807  		if (viewRoots[k])
1808  		{
1809  			int index2 = 0;
1810  			TiXmlElement *actIndex = viewRoots[k]->ToElement();
1811  			str = actIndex->Attribute(TEXT("activeIndex"), &index2);
1812  			if (str)
1813  			{
1814  				if (k == 0)
1815  					session._activeMainIndex = index2;
1816  				else 
1817  					session._activeSubIndex = index2;
1818  			}
1819  			for (TiXmlNode *childNode = viewRoots[k]->FirstChildElement(TEXT("File"));
1820  				childNode ;
1821  				childNode = childNode->NextSibling(TEXT("File")) )
1822  			{
1823  				const TCHAR *fileName = (childNode->ToElement())->Attribute(TEXT("filename"));
1824  				if (fileName)
1825  				{
1826  					Position position;
1827  					const TCHAR* posStr = (childNode->ToElement())->Attribute(TEXT("firstVisibleLine"));
1828  					if (posStr)
1829  						position._firstVisibleLine = static_cast<intptr_t>(_ttoi64(posStr));
1830  					posStr = (childNode->ToElement())->Attribute(TEXT("xOffset"));
1831  					if (posStr)
1832  						position._xOffset = static_cast<intptr_t>(_ttoi64(posStr));
1833  					posStr = (childNode->ToElement())->Attribute(TEXT("startPos"));
1834  					if (posStr)
1835  						position._startPos = static_cast<intptr_t>(_ttoi64(posStr));
1836  					posStr = (childNode->ToElement())->Attribute(TEXT("endPos"));
1837  					if (posStr)
1838  						position._endPos = static_cast<intptr_t>(_ttoi64(posStr));
1839  					posStr = (childNode->ToElement())->Attribute(TEXT("selMode"));
1840  					if (posStr)
1841  						position._selMode = static_cast<intptr_t>(_ttoi64(posStr));
1842  					posStr = (childNode->ToElement())->Attribute(TEXT("scrollWidth"));
1843  					if (posStr)
1844  						position._scrollWidth = static_cast<intptr_t>(_ttoi64(posStr));
1845  					posStr = (childNode->ToElement())->Attribute(TEXT("offset"));
1846  					if (posStr)
1847  						position._offset = static_cast<intptr_t>(_ttoi64(posStr));
1848  					posStr = (childNode->ToElement())->Attribute(TEXT("wrapCount"));
1849  					if (posStr)
1850  						position._wrapCount = static_cast<intptr_t>(_ttoi64(posStr));
1851  					MapPosition mapPosition;
1852  					const TCHAR* mapPosStr = (childNode->ToElement())->Attribute(TEXT("mapFirstVisibleDisplayLine"));
1853  					if (mapPosStr)
1854  						mapPosition._firstVisibleDisplayLine = static_cast<intptr_t>(_ttoi64(mapPosStr));
1855  					mapPosStr = (childNode->ToElement())->Attribute(TEXT("mapFirstVisibleDocLine"));
1856  					if (mapPosStr)
1857  						mapPosition._firstVisibleDocLine = static_cast<intptr_t>(_ttoi64(mapPosStr));
1858  					mapPosStr = (childNode->ToElement())->Attribute(TEXT("mapLastVisibleDocLine"));
1859  					if (mapPosStr)
1860  						mapPosition._lastVisibleDocLine = static_cast<intptr_t>(_ttoi64(mapPosStr));
1861  					mapPosStr = (childNode->ToElement())->Attribute(TEXT("mapNbLine"));
1862  					if (mapPosStr)
1863  						mapPosition._nbLine = static_cast<intptr_t>(_ttoi64(mapPosStr));
1864  					mapPosStr = (childNode->ToElement())->Attribute(TEXT("mapHigherPos"));
1865  					if (mapPosStr)
1866  						mapPosition._higherPos = static_cast<intptr_t>(_ttoi64(mapPosStr));
1867  					mapPosStr = (childNode->ToElement())->Attribute(TEXT("mapWidth"));
1868  					if (mapPosStr)
1869  						mapPosition._width = static_cast<intptr_t>(_ttoi64(mapPosStr));
1870  					mapPosStr = (childNode->ToElement())->Attribute(TEXT("mapHeight"));
1871  					if (mapPosStr)
1872  						mapPosition._height = static_cast<intptr_t>(_ttoi64(mapPosStr));
1873  					mapPosStr = (childNode->ToElement())->Attribute(TEXT("mapKByteInDoc"));
1874  					if (mapPosStr)
1875  						mapPosition._KByteInDoc = static_cast<intptr_t>(_ttoi64(mapPosStr));
1876  					mapPosStr = (childNode->ToElement())->Attribute(TEXT("mapWrapIndentMode"));
1877  					if (mapPosStr)
1878  						mapPosition._wrapIndentMode = static_cast<intptr_t>(_ttoi64(mapPosStr));
1879  					const TCHAR *boolStr = (childNode->ToElement())->Attribute(TEXT("mapIsWrap"));
1880  					if (boolStr)
1881  						mapPosition._isWrap = (lstrcmp(TEXT("yes"), boolStr) == 0);
1882  					const TCHAR *langName;
1883  					langName = (childNode->ToElement())->Attribute(TEXT("lang"));
1884  					int encoding = -1;
1885  					const TCHAR *encStr = (childNode->ToElement())->Attribute(TEXT("encoding"), &encoding);
1886  					const TCHAR *backupFilePath = (childNode->ToElement())->Attribute(TEXT("backupFilePath"));
1887  					FILETIME fileModifiedTimestamp{};
1888  					(childNode->ToElement())->Attribute(TEXT("originalFileLastModifTimestamp"), reinterpret_cast<int32_t*>(&fileModifiedTimestamp.dwLowDateTime));
1889  					(childNode->ToElement())->Attribute(TEXT("originalFileLastModifTimestampHigh"), reinterpret_cast<int32_t*>(&fileModifiedTimestamp.dwHighDateTime));
1890  					bool isUserReadOnly = false;
1891  					const TCHAR *boolStrReadOnly = (childNode->ToElement())->Attribute(TEXT("userReadOnly"));
1892  					if (boolStrReadOnly)
1893  						isUserReadOnly = _wcsicmp(TEXT("yes"), boolStrReadOnly) == 0;
1894  					sessionFileInfo sfi(fileName, langName, encStr ? encoding : -1, isUserReadOnly, position, backupFilePath, fileModifiedTimestamp, mapPosition);
1895  					const TCHAR* intStrTabColour = (childNode->ToElement())->Attribute(TEXT("tabColourId"));
1896  					if (intStrTabColour)
1897  					{
1898  						sfi._individualTabColour = _wtoi(intStrTabColour);
1899  					}
1900  					for (TiXmlNode *markNode = childNode->FirstChildElement(TEXT("Mark"));
1901  						markNode;
1902  						markNode = markNode->NextSibling(TEXT("Mark")))
1903  					{
1904  						const TCHAR* lineNumberStr = (markNode->ToElement())->Attribute(TEXT("line"));
1905  						if (lineNumberStr)
1906  						{
1907  							sfi._marks.push_back(static_cast<size_t>(_ttoi64(lineNumberStr)));
1908  						}
1909  					}
1910  					for (TiXmlNode *foldNode = childNode->FirstChildElement(TEXT("Fold"));
1911  						foldNode;
1912  						foldNode = foldNode->NextSibling(TEXT("Fold")))
1913  					{
1914  						const TCHAR *lineNumberStr = (foldNode->ToElement())->Attribute(TEXT("line"));
1915  						if (lineNumberStr)
1916  						{
1917  							sfi._foldStates.push_back(static_cast<size_t>(_ttoi64(lineNumberStr)));
1918  						}
1919  					}
1920  					if (k == 0)
1921  						session._mainViewFiles.push_back(sfi);
1922  					else 
1923  						session._subViewFiles.push_back(sfi);
1924  				}
1925  			}
1926  		}
1927  	}
1928  	TiXmlNode *fileBrowserRoot = sessionRoot->FirstChildElement(TEXT("FileBrowser"));
1929  	if (fileBrowserRoot)
1930  	{
1931  		const TCHAR *selectedItemPath = (fileBrowserRoot->ToElement())->Attribute(TEXT("latestSelectedItem"));
1932  		if (selectedItemPath)
1933  		{
1934  			session._fileBrowserSelectedItem = selectedItemPath;
1935  		}
1936  		for (TiXmlNode *childNode = fileBrowserRoot->FirstChildElement(TEXT("root"));
1937  			childNode;
1938  			childNode = childNode->NextSibling(TEXT("root")))
1939  		{
1940  			const TCHAR *fileName = (childNode->ToElement())->Attribute(TEXT("foldername"));
1941  			if (fileName)
1942  			{
1943  				session._fileBrowserRoots.push_back({ fileName });
1944  			}
1945  		}
1946  	}
1947  	return true;
1948  }
1949  void NppParameters::feedFileListParameters(TiXmlNode *node)
1950  {
1951  	TiXmlNode *historyRoot = node->FirstChildElement(TEXT("History"));
1952  	if (!historyRoot) return;
1953  	int nbMaxFile = _nbMaxRecentFile;
1954  	const TCHAR *strVal = (historyRoot->ToElement())->Attribute(TEXT("nbMaxFile"), &nbMaxFile);
1955  	if (strVal && (nbMaxFile >= 0) && (nbMaxFile <= NB_MAX_LRF_FILE))
1956  		_nbMaxRecentFile = nbMaxFile;
1957  	int customLen = RECENTFILES_SHOWFULLPATH;
1958  	strVal = (historyRoot->ToElement())->Attribute(TEXT("customLength"), &customLen);
1959  	if (strVal)
1960  		_recentFileCustomLength = std::min<int>(customLen, NB_MAX_LRF_CUSTOMLENGTH);
1961  	strVal = (historyRoot->ToElement())->Attribute(TEXT("inSubMenu"));
1962  	if (strVal)
1963  		_putRecentFileInSubMenu = (lstrcmp(strVal, TEXT("yes")) == 0);
1964  	for (TiXmlNode *childNode = historyRoot->FirstChildElement(TEXT("File"));
1965  		childNode && (_nbRecentFile < NB_MAX_LRF_FILE);
1966  		childNode = childNode->NextSibling(TEXT("File")) )
1967  	{
1968  		const TCHAR *filePath = (childNode->ToElement())->Attribute(TEXT("filename"));
1969  		if (filePath)
1970  		{
1971  			_LRFileList[_nbRecentFile] = new generic_string(filePath);
1972  			++_nbRecentFile;
1973  		}
1974  	}
1975  }
1976  void NppParameters::feedFileBrowserParameters(TiXmlNode *node)
1977  {
1978  	TiXmlNode *fileBrowserRoot = node->FirstChildElement(TEXT("FileBrowser"));
1979  	if (!fileBrowserRoot) return;
1980  	const TCHAR *selectedItemPath = (fileBrowserRoot->ToElement())->Attribute(TEXT("latestSelectedItem"));
1981  	if (selectedItemPath)
1982  	{
1983  		_fileBrowserSelectedItemPath = selectedItemPath;
1984  	}
1985  	for (TiXmlNode *childNode = fileBrowserRoot->FirstChildElement(TEXT("root"));
1986  		childNode;
1987  		childNode = childNode->NextSibling(TEXT("root")) )
1988  	{
1989  		const TCHAR *filePath = (childNode->ToElement())->Attribute(TEXT("foldername"));
1990  		if (filePath)
1991  		{
1992  			_fileBrowserRoot.push_back(filePath);
1993  		}
1994  	}
1995  }
1996  void NppParameters::feedProjectPanelsParameters(TiXmlNode *node)
1997  {
1998  	TiXmlNode *projPanelRoot = node->FirstChildElement(TEXT("ProjectPanels"));
1999  	if (!projPanelRoot) return;
2000  	for (TiXmlNode *childNode = projPanelRoot->FirstChildElement(TEXT("ProjectPanel"));
2001  		childNode;
2002  		childNode = childNode->NextSibling(TEXT("ProjectPanel")) )
2003  	{
2004  		int index = 0;
2005  		const TCHAR *idStr = (childNode->ToElement())->Attribute(TEXT("id"), &index);
2006  		if (idStr && (index >= 0 && index <= 2))
2007  		{
2008  			const TCHAR *filePath = (childNode->ToElement())->Attribute(TEXT("workSpaceFile"));
2009  			if (filePath)
2010  			{
2011  				_workSpaceFilePathes[index] = filePath;
2012  			}
2013  		}
2014  	}
2015  }
2016  void NppParameters::feedColumnEditorParameters(TiXmlNode *node)
2017  {
2018  	TiXmlNode * columnEditorRoot = node->FirstChildElement(TEXT("ColumnEditor"));
2019  	if (!columnEditorRoot) return;
2020  	const TCHAR* strVal = (columnEditorRoot->ToElement())->Attribute(TEXT("choice"));
2021  	if (strVal)
2022  	{
2023  		if (lstrcmp(strVal, TEXT("text")) == 0)
2024  			_columnEditParam._mainChoice = activeText;
2025  		else
2026  			_columnEditParam._mainChoice = activeNumeric;
2027  	}
2028  	TiXmlNode *childNode = columnEditorRoot->FirstChildElement(TEXT("text"));
2029  	if (!childNode) return;
2030  	const TCHAR* content = (childNode->ToElement())->Attribute(TEXT("content"));
2031  	if (content)
2032  	{
2033  		_columnEditParam._insertedTextContent = content;
2034  	}
2035  	childNode = columnEditorRoot->FirstChildElement(TEXT("number"));
2036  	if (!childNode) return;
2037  	int val;
2038  	strVal = (childNode->ToElement())->Attribute(TEXT("initial"), &val);
2039  	if (strVal)
2040  		_columnEditParam._initialNum = val;
2041  	strVal = (childNode->ToElement())->Attribute(TEXT("increase"), &val);
2042  	if (strVal)
2043  		_columnEditParam._increaseNum = val;
2044  	strVal = (childNode->ToElement())->Attribute(TEXT("repeat"), &val);
2045  	if (strVal)
2046  		_columnEditParam._repeatNum = val;
2047  	strVal = (childNode->ToElement())->Attribute(TEXT("formatChoice"));
2048  	if (strVal)
2049  	{
2050  		if (lstrcmp(strVal, TEXT("hex")) == 0)
2051  			_columnEditParam._formatChoice = 1;
2052  		else if (lstrcmp(strVal, TEXT("oct")) == 0)
2053  			_columnEditParam._formatChoice = 2;
2054  		else if (lstrcmp(strVal, TEXT("bin")) == 0)
2055  			_columnEditParam._formatChoice = 3;
2056  		else 
2057  			_columnEditParam._formatChoice = 0;
2058  	}
2059  	strVal = (childNode->ToElement())->Attribute(TEXT("leadingChoice"));
2060  	if (strVal)
2061  	{
2062  		_columnEditParam._leadingChoice = ColumnEditorParam::noneLeading;
2063  		if (lstrcmp(strVal, TEXT("zeros")) == 0)
2064  		{
2065  			_columnEditParam._leadingChoice = ColumnEditorParam::zeroLeading;
2066  		}
2067  		else if (lstrcmp(strVal, TEXT("spaces")) == 0)
2068  		{
2069  			_columnEditParam._leadingChoice = ColumnEditorParam::spaceLeading;
2070  		}
2071  	}
2072  }
2073  void NppParameters::feedFindHistoryParameters(TiXmlNode *node)
2074  {
2075  	TiXmlNode *findHistoryRoot = node->FirstChildElement(TEXT("FindHistory"));
2076  	if (!findHistoryRoot) return;
2077  	(findHistoryRoot->ToElement())->Attribute(TEXT("nbMaxFindHistoryPath"), &_findHistory._nbMaxFindHistoryPath);
2078  	if (_findHistory._nbMaxFindHistoryPath > NB_MAX_FINDHISTORY_PATH)
2079  	{
2080  		_findHistory._nbMaxFindHistoryPath = NB_MAX_FINDHISTORY_PATH;
2081  	}
2082  	if ((_findHistory._nbMaxFindHistoryPath > 0) && (_findHistory._nbMaxFindHistoryPath <= NB_MAX_FINDHISTORY_PATH))
2083  	{
2084  		for (TiXmlNode *childNode = findHistoryRoot->FirstChildElement(TEXT("Path"));
2085  			childNode && (_findHistory._findHistoryPaths.size() < NB_MAX_FINDHISTORY_PATH);
2086  			childNode = childNode->NextSibling(TEXT("Path")) )
2087  		{
2088  			const TCHAR *filePath = (childNode->ToElement())->Attribute(TEXT("name"));
2089  			if (filePath)
2090  			{
2091  				_findHistory._findHistoryPaths.push_back(generic_string(filePath));
2092  			}
2093  		}
2094  	}
2095  	(findHistoryRoot->ToElement())->Attribute(TEXT("nbMaxFindHistoryFilter"), &_findHistory._nbMaxFindHistoryFilter);
2096  	if (_findHistory._nbMaxFindHistoryFilter > NB_MAX_FINDHISTORY_FILTER)
2097  	{
2098  		_findHistory._nbMaxFindHistoryFilter = NB_MAX_FINDHISTORY_FILTER;
2099  	}
2100  	if ((_findHistory._nbMaxFindHistoryFilter > 0) && (_findHistory._nbMaxFindHistoryFilter <= NB_MAX_FINDHISTORY_FILTER))
2101  	{
2102  		for (TiXmlNode *childNode = findHistoryRoot->FirstChildElement(TEXT("Filter"));
2103  			childNode && (_findHistory._findHistoryFilters.size() < NB_MAX_FINDHISTORY_FILTER);
2104  			childNode = childNode->NextSibling(TEXT("Filter")))
2105  		{
2106  			const TCHAR *fileFilter = (childNode->ToElement())->Attribute(TEXT("name"));
2107  			if (fileFilter)
2108  			{
2109  				_findHistory._findHistoryFilters.push_back(generic_string(fileFilter));
2110  			}
2111  		}
2112  	}
2113  	(findHistoryRoot->ToElement())->Attribute(TEXT("nbMaxFindHistoryFind"), &_findHistory._nbMaxFindHistoryFind);
2114  	if (_findHistory._nbMaxFindHistoryFind > NB_MAX_FINDHISTORY_FIND)
2115  	{
2116  		_findHistory._nbMaxFindHistoryFind = NB_MAX_FINDHISTORY_FIND;
2117  	}
2118  	if ((_findHistory._nbMaxFindHistoryFind > 0) && (_findHistory._nbMaxFindHistoryFind <= NB_MAX_FINDHISTORY_FIND))
2119  	{
2120  		for (TiXmlNode *childNode = findHistoryRoot->FirstChildElement(TEXT("Find"));
2121  			childNode && (_findHistory._findHistoryFinds.size() < NB_MAX_FINDHISTORY_FIND);
2122  			childNode = childNode->NextSibling(TEXT("Find")))
2123  		{
2124  			const TCHAR *fileFind = (childNode->ToElement())->Attribute(TEXT("name"));
2125  			if (fileFind)
2126  			{
2127  				_findHistory._findHistoryFinds.push_back(generic_string(fileFind));
2128  			}
2129  		}
2130  	}
2131  	(findHistoryRoot->ToElement())->Attribute(TEXT("nbMaxFindHistoryReplace"), &_findHistory._nbMaxFindHistoryReplace);
2132  	if (_findHistory._nbMaxFindHistoryReplace > NB_MAX_FINDHISTORY_REPLACE)
2133  	{
2134  		_findHistory._nbMaxFindHistoryReplace = NB_MAX_FINDHISTORY_REPLACE;
2135  	}
2136  	if ((_findHistory._nbMaxFindHistoryReplace > 0) && (_findHistory._nbMaxFindHistoryReplace <= NB_MAX_FINDHISTORY_REPLACE))
2137  	{
2138  		for (TiXmlNode *childNode = findHistoryRoot->FirstChildElement(TEXT("Replace"));
2139  			childNode && (_findHistory._findHistoryReplaces.size() < NB_MAX_FINDHISTORY_REPLACE);
2140  			childNode = childNode->NextSibling(TEXT("Replace")))
2141  		{
2142  			const TCHAR *fileReplace = (childNode->ToElement())->Attribute(TEXT("name"));
2143  			if (fileReplace)
2144  			{
2145  				_findHistory._findHistoryReplaces.push_back(generic_string(fileReplace));
2146  			}
2147  		}
2148  	}
2149  	const TCHAR *boolStr = (findHistoryRoot->ToElement())->Attribute(TEXT("matchWord"));
2150  	if (boolStr)
2151  		_findHistory._isMatchWord = (lstrcmp(TEXT("yes"), boolStr) == 0);
2152  	boolStr = (findHistoryRoot->ToElement())->Attribute(TEXT("matchCase"));
2153  	if (boolStr)
2154  		_findHistory._isMatchCase = (lstrcmp(TEXT("yes"), boolStr) == 0);
2155  	boolStr = (findHistoryRoot->ToElement())->Attribute(TEXT("wrap"));
2156  	if (boolStr)
2157  		_findHistory._isWrap = (lstrcmp(TEXT("yes"), boolStr) == 0);
2158  	boolStr = (findHistoryRoot->ToElement())->Attribute(TEXT("directionDown"));
2159  	if (boolStr)
2160  		_findHistory._isDirectionDown = (lstrcmp(TEXT("yes"), boolStr) == 0);
2161  	boolStr = (findHistoryRoot->ToElement())->Attribute(TEXT("fifRecuisive"));
2162  	if (boolStr)
2163  		_findHistory._isFifRecuisive = (lstrcmp(TEXT("yes"), boolStr) == 0);
2164  	boolStr = (findHistoryRoot->ToElement())->Attribute(TEXT("fifInHiddenFolder"));
2165  	if (boolStr)
2166  		_findHistory._isFifInHiddenFolder = (lstrcmp(TEXT("yes"), boolStr) == 0);
2167  	boolStr = (findHistoryRoot->ToElement())->Attribute(TEXT("fifProjectPanel1"));
2168  	if (boolStr)
2169  		_findHistory._isFifProjectPanel_1 = (lstrcmp(TEXT("yes"), boolStr) == 0);
2170  	boolStr = (findHistoryRoot->ToElement())->Attribute(TEXT("fifProjectPanel2"));
2171  	if (boolStr)
2172  		_findHistory._isFifProjectPanel_2 = (lstrcmp(TEXT("yes"), boolStr) == 0);
2173  	boolStr = (findHistoryRoot->ToElement())->Attribute(TEXT("fifProjectPanel3"));
2174  	if (boolStr)
2175  		_findHistory._isFifProjectPanel_3 = (lstrcmp(TEXT("yes"), boolStr) == 0);
2176  	boolStr = (findHistoryRoot->ToElement())->Attribute(TEXT("fifFilterFollowsDoc"));
2177  	if (boolStr)
2178  		_findHistory._isFilterFollowDoc = (lstrcmp(TEXT("yes"), boolStr) == 0);
2179  	boolStr = (findHistoryRoot->ToElement())->Attribute(TEXT("fifFolderFollowsDoc"));
2180  	if (boolStr)
2181  		_findHistory._isFolderFollowDoc = (lstrcmp(TEXT("yes"), boolStr) == 0);
2182  	int mode = 0;
2183  	boolStr = (findHistoryRoot->ToElement())->Attribute(TEXT("searchMode"), &mode);
2184  	if (boolStr)
2185  		_findHistory._searchMode = (FindHistory::searchMode)mode;
2186  	boolStr = (findHistoryRoot->ToElement())->Attribute(TEXT("transparencyMode"), &mode);
2187  	if (boolStr)
2188  		_findHistory._transparencyMode = (FindHistory::transparencyMode)mode;
2189  	(findHistoryRoot->ToElement())->Attribute(TEXT("transparency"), &_findHistory._transparency);
2190  	if (_findHistory._transparency <= 0 || _findHistory._transparency > 200)
2191  		_findHistory._transparency = 150;
2192  	boolStr = (findHistoryRoot->ToElement())->Attribute(TEXT("dotMatchesNewline"));
2193  	if (boolStr)
2194  		_findHistory._dotMatchesNewline = (lstrcmp(TEXT("yes"), boolStr) == 0);
2195  	boolStr = (findHistoryRoot->ToElement())->Attribute(TEXT("isSearch2ButtonsMode"));
2196  	if (boolStr)
2197  		_findHistory._isSearch2ButtonsMode = (lstrcmp(TEXT("yes"), boolStr) == 0);
2198  	boolStr = (findHistoryRoot->ToElement())->Attribute(TEXT("regexBackward4PowerUser"));
2199  	if (boolStr)
2200  		_findHistory._regexBackward4PowerUser = (lstrcmp(TEXT("yes"), boolStr) == 0);
2201  	boolStr = (findHistoryRoot->ToElement())->Attribute(TEXT("bookmarkLine"));
2202  	if (boolStr)
2203  		_findHistory._isBookmarkLine = (lstrcmp(TEXT("yes"), boolStr) == 0);
2204  	boolStr = (findHistoryRoot->ToElement())->Attribute(TEXT("purge"));
2205  	if (boolStr)
2206  		_findHistory._isPurge = (lstrcmp(TEXT("yes"), boolStr) == 0);
2207  }
2208  void NppParameters::feedShortcut(TiXmlNodeA *node)
2209  {
2210  	TiXmlNodeA *shortcutsRoot = node->FirstChildElement("InternalCommands");
2211  	if (!shortcutsRoot) return;
2212  	for (TiXmlNodeA *childNode = shortcutsRoot->FirstChildElement("Shortcut");
2213  		childNode ;
2214  		childNode = childNode->NextSibling("Shortcut"))
2215  	{
2216  		int id;
2217  		const char* idStr = (childNode->ToElement())->Attribute("id", &id);
2218  		if (idStr)
2219  		{
2220  			size_t len = _shortcuts.size();
2221  			for (size_t i = 0; i < len; ++i)
2222  			{
2223  				if (_shortcuts[i].getID() == (unsigned long)id)
2224  				{	
2225  					getShortcuts(childNode, _shortcuts[i]);
2226  					addUserModifiedIndex(i);
2227  				}
2228  			}
2229  		}
2230  	}
2231  }
2232  void NppParameters::feedMacros(TiXmlNodeA *node)
2233  {
2234  	TiXmlNodeA *macrosRoot = node->FirstChildElement("Macros");
2235  	if (!macrosRoot) return;
2236  	for (TiXmlNodeA *childNode = macrosRoot->FirstChildElement("Macro");
2237  		childNode ;
2238  		childNode = childNode->NextSibling("Macro"))
2239  	{
2240  		Shortcut sc;
2241  		string fdnm;
2242  		if (getShortcuts(childNode, sc, &fdnm))
2243  		{
2244  			Macro macro;
2245  			getActions(childNode, macro);
2246  			int cmdID = ID_MACRO + static_cast<int32_t>(_macros.size());
2247  			_macros.push_back(MacroShortcut(sc, macro, cmdID));
2248  			_macroMenuItems.push_back(MenuItemUnit(cmdID, string2wstring(sc.getName(), CP_UTF8), string2wstring(fdnm, CP_UTF8)));
2249  		}
2250  	}
2251  }
2252  void NppParameters::getActions(TiXmlNodeA *node, Macro & macro)
2253  {
2254  	for (TiXmlNodeA *childNode = node->FirstChildElement("Action");
2255  		childNode ;
2256  		childNode = childNode->NextSibling("Action") )
2257  	{
2258  		int type;
2259  		const char *typeStr = (childNode->ToElement())->Attribute("type", &type);
2260  		if ((!typeStr) || (type > 3))
2261  			continue;
2262  		int msg = 0;
2263  		(childNode->ToElement())->Attribute("message", &msg);
2264  		int wParam = 0;
2265  		(childNode->ToElement())->Attribute("wParam", &wParam);
2266  		int lParam = 0;
2267  		(childNode->ToElement())->Attribute("lParam", &lParam);
2268  		const char *sParam = (childNode->ToElement())->Attribute("sParam");
2269  		if (!sParam)
2270  			sParam = "";
2271  		recordedMacroStep step(msg, wParam, lParam, sParam, type);
2272  		if (step.isValid())
2273  			macro.push_back(step);
2274  	}
2275  }
2276  void NppParameters::feedUserCmds(TiXmlNodeA *node)
2277  {
2278  	TiXmlNodeA *userCmdsRoot = node->FirstChildElement("UserDefinedCommands");
2279  	if (!userCmdsRoot) return;
2280  	for (TiXmlNodeA *childNode = userCmdsRoot->FirstChildElement("Command");
2281  		childNode ;
2282  		childNode = childNode->NextSibling("Command") )
2283  	{
2284  		Shortcut sc;
2285  		string fdnm;
2286  		if (getShortcuts(childNode, sc, &fdnm))
2287  		{
2288  			TiXmlNodeA *aNode = childNode->FirstChild();
2289  			if (aNode)
2290  			{
2291  				const char* cmdStr = aNode->Value();
2292  				if (cmdStr)
2293  				{
2294  					int cmdID = ID_USER_CMD + static_cast<int32_t>(_userCommands.size());
2295  					_userCommands.push_back(UserCommand(sc, cmdStr, cmdID));
2296  					_runMenuItems.push_back(MenuItemUnit(cmdID, string2wstring(sc.getName(), CP_UTF8), string2wstring(fdnm, CP_UTF8)));
2297  				}
2298  			}
2299  		}
2300  	}
2301  }
2302  void NppParameters::feedPluginCustomizedCmds(TiXmlNodeA *node)
2303  {
2304  	TiXmlNodeA *pluginCustomizedCmdsRoot = node->FirstChildElement("PluginCommands");
2305  	if (!pluginCustomizedCmdsRoot) return;
2306  	for (TiXmlNodeA *childNode = pluginCustomizedCmdsRoot->FirstChildElement("PluginCommand");
2307  		childNode ;
2308  		childNode = childNode->NextSibling("PluginCommand") )
2309  	{
2310  		const char *moduleName = (childNode->ToElement())->Attribute("moduleName");
2311  		if (!moduleName)
2312  			continue;
2313  		int internalID = -1;
2314  		const char *internalIDStr = (childNode->ToElement())->Attribute("internalID", &internalID);
2315  		if (!internalIDStr)
2316  			continue;
2317  		size_t len = _pluginCommands.size();
2318  		for (size_t i = 0; i < len; ++i)
2319  		{
2320  			PluginCmdShortcut & pscOrig = _pluginCommands[i];
2321  			if (!strnicmp(pscOrig.getModuleName(), moduleName, strlen(moduleName)) && pscOrig.getInternalID() == internalID)
2322  			{
2323  				getShortcuts(childNode, _pluginCommands[i]);
2324  				addPluginModifiedIndex(i);
2325  				break;
2326  			}
2327  		}
2328  	}
2329  }
2330  void NppParameters::feedScintKeys(TiXmlNodeA *node)
2331  {
2332  	TiXmlNodeA *scintKeysRoot = node->FirstChildElement("ScintillaKeys");
2333  	if (!scintKeysRoot) return;
2334  	for (TiXmlNodeA *childNode = scintKeysRoot->FirstChildElement("ScintKey");
2335  		childNode ;
2336  		childNode = childNode->NextSibling("ScintKey") )
2337  	{
2338  		int scintKey;
2339  		const char *keyStr = (childNode->ToElement())->Attribute("ScintID", &scintKey);
2340  		if (!keyStr)
2341  			continue;
2342  		int menuID;
2343  		keyStr = (childNode->ToElement())->Attribute("menuCmdID", &menuID);
2344  		if (!keyStr)
2345  			continue;
2346  		size_t len = _scintillaKeyCommands.size();
2347  		for (int32_t i = 0; i < static_cast<int32_t>(len); ++i)
2348  		{
2349  			ScintillaKeyMap & skmOrig = _scintillaKeyCommands[i];
2350  			if (skmOrig.getScintillaKeyID() == (unsigned long)scintKey && skmOrig.getMenuCmdID() == menuID)
2351  			{
2352  				_scintillaKeyCommands[i].clearDups();
2353  				getShortcuts(childNode, _scintillaKeyCommands[i]);
2354  				_scintillaKeyCommands[i].setKeyComboByIndex(0, _scintillaKeyCommands[i].getKeyCombo());
2355  				addScintillaModifiedIndex(i);
2356  				KeyCombo kc;
2357  				for (TiXmlNodeA *nextNode = childNode->FirstChildElement("NextKey");
2358  					nextNode ;
2359  					nextNode = nextNode->NextSibling("NextKey"))
2360  				{
2361  					const char *str = (nextNode->ToElement())->Attribute("Ctrl");
2362  					if (!str)
2363  						continue;
2364  					kc._isCtrl = (strcmp("yes", str) == 0);
2365  					str = (nextNode->ToElement())->Attribute("Alt");
2366  					if (!str)
2367  						continue;
2368  					kc._isAlt = (strcmp("yes", str) == 0);
2369  					str = (nextNode->ToElement())->Attribute("Shift");
2370  					if (!str)
2371  						continue;
2372  					kc._isShift = (strcmp("yes", str) == 0);
2373  					int key;
2374  					str = (nextNode->ToElement())->Attribute("Key", &key);
2375  					if (!str)
2376  						continue;
2377  					kc._key = static_cast<unsigned char>(key);
2378  					_scintillaKeyCommands[i].addKeyCombo(kc);
2379  				}
2380  				break;
2381  			}
2382  		}
2383  	}
2384  }
2385  bool NppParameters::getShortcuts(TiXmlNodeA *node, Shortcut & sc, string* folderName)
2386  {
2387  	if (!node) return false;
2388  	const char* name = (node->ToElement())->Attribute("name");
2389  	if (!name)
2390  		name = "";
2391  	bool isCtrl = false;
2392  	const char* isCtrlStr = (node->ToElement())->Attribute("Ctrl");
2393  	if (isCtrlStr)
2394  		isCtrl = (strcmp("yes", isCtrlStr) == 0);
2395  	bool isAlt = false;
2396  	const char* isAltStr = (node->ToElement())->Attribute("Alt");
2397  	if (isAltStr)
2398  		isAlt = (strcmp("yes", isAltStr) == 0);
2399  	bool isShift = false;
2400  	const char* isShiftStr = (node->ToElement())->Attribute("Shift");
2401  	if (isShiftStr)
2402  		isShift = (strcmp("yes", isShiftStr) == 0);
2403  	int key;
2404  	const char* keyStr = (node->ToElement())->Attribute("Key", &key);
2405  	if (!keyStr)
2406  		return false;
2407  	if (folderName)
2408  	{
2409  		const char* fn = (node->ToElement())->Attribute("FolderName");
2410  		*folderName = fn ? fn : "";
2411  	}
2412  	sc = Shortcut(name, isCtrl, isAlt, isShift, static_cast<unsigned char>(key));
2413  	return true;
2414  }
2415  std::pair<unsigned char, unsigned char> NppParameters::feedUserLang(TiXmlNode *node)
2416  {
2417  	int iBegin = _nbUserLang;
2418  	for (TiXmlNode *childNode = node->FirstChildElement(TEXT("UserLang"));
2419  		childNode && (_nbUserLang < NB_MAX_USER_LANG);
2420  		childNode = childNode->NextSibling(TEXT("UserLang")) )
2421  	{
2422  		const TCHAR* name = (childNode->ToElement())->Attribute(TEXT("name"));
2423  		const TCHAR* ext = (childNode->ToElement())->Attribute(TEXT("ext"));
2424  		const TCHAR* darkModeTheme = (childNode->ToElement())->Attribute(TEXT("darkModeTheme"));
2425  		const TCHAR* udlVersion = (childNode->ToElement())->Attribute(TEXT("udlVersion"));
2426  		if (!name || !name[0] || !ext)
2427  		{
2428  			continue;
2429  		}
2430  		bool isDarkModeTheme = false;
2431  		if (darkModeTheme && darkModeTheme[0])
2432  		{
2433  			isDarkModeTheme = (lstrcmp(TEXT("yes"), darkModeTheme) == 0);
2434  		}
2435  		try {
2436  			_userLangArray[_nbUserLang] = new UserLangContainer(name, ext, isDarkModeTheme, udlVersion ? udlVersion : TEXT(""));
2437  			++_nbUserLang;
2438  			TiXmlNode *settingsRoot = childNode->FirstChildElement(TEXT("Settings"));
2439  			if (!settingsRoot)
2440  				throw std::runtime_error("NppParameters::feedUserLang : Settings node is missing");
2441  			feedUserSettings(settingsRoot);
2442  			TiXmlNode *keywordListsRoot = childNode->FirstChildElement(TEXT("KeywordLists"));
2443  			if (!keywordListsRoot)
2444  				throw std::runtime_error("NppParameters::feedUserLang : KeywordLists node is missing");
2445  			feedUserKeywordList(keywordListsRoot);
2446  			TiXmlNode *stylesRoot = childNode->FirstChildElement(TEXT("Styles"));
2447  			if (!stylesRoot)
2448  				throw std::runtime_error("NppParameters::feedUserLang : Styles node is missing");
2449  			feedUserStyles(stylesRoot);
2450  			for (int i = 0 ; i < SCE_USER_STYLE_TOTAL_STYLES ; ++i)
2451  			{
2452  				const Style * pStyle = _userLangArray[_nbUserLang - 1]->_styles.findByID(i);
2453  				if (!pStyle)
2454  					_userLangArray[_nbUserLang - 1]->_styles.addStyler(i, globalMappper().styleNameMapper[i]);
2455  			}
2456  		}
2457  		catch (const std::exception&)
2458  		{
2459  			delete _userLangArray[--_nbUserLang];
2460  		}
2461  	}
2462  	int iEnd = _nbUserLang;
2463  	return pair<unsigned char, unsigned char>(static_cast<unsigned char>(iBegin), static_cast<unsigned char>(iEnd));
2464  }
2465  bool NppParameters::importUDLFromFile(const generic_string& sourceFile)
2466  {
2467  	TiXmlDocument *pXmlUserLangDoc = new TiXmlDocument(sourceFile);
2468  	bool loadOkay = pXmlUserLangDoc->LoadFile();
2469  	if (loadOkay)
2470  	{
2471  		auto r = addUserDefineLangsFromXmlTree(pXmlUserLangDoc);
2472  		loadOkay = (r.second - r.first) != 0;
2473  		if (loadOkay)
2474  		{
2475  			_pXmlUserLangsDoc.push_back(UdlXmlFileState(nullptr, true, true, r));
2476  			setUdlXmlDirtyFromXmlDoc(_pXmlUserLangDoc);
2477  		}
2478  	}
2479  	delete pXmlUserLangDoc;
2480  	return loadOkay;
2481  }
2482  bool NppParameters::exportUDLToFile(size_t langIndex2export, const generic_string& fileName2save)
2483  {
2484  	if (langIndex2export >= NB_MAX_USER_LANG)
2485  		return false;
2486  	if (static_cast<int32_t>(langIndex2export) >= _nbUserLang)
2487  		return false;
2488  	TiXmlDocument *pNewXmlUserLangDoc = new TiXmlDocument(fileName2save);
2489  	TiXmlNode *newRoot2export = pNewXmlUserLangDoc->InsertEndChild(TiXmlElement(TEXT("NotepadPlus")));
2490  	insertUserLang2Tree(newRoot2export, _userLangArray[langIndex2export]);
2491  	bool result = pNewXmlUserLangDoc->SaveFile();
2492  	delete pNewXmlUserLangDoc;
2493  	return result;
2494  }
2495  LangType NppParameters::getLangFromExt(const TCHAR *ext)
2496  {
2497  	int i = getNbLang();
2498  	i--;
2499  	while (i >= 0)
2500  	{
2501  		Lang *l = getLangFromIndex(i--);
2502  		const TCHAR *defList = l->getDefaultExtList();
2503  		const TCHAR *userList = NULL;
2504  		LexerStylerArray &lsa = getLStylerArray();
2505  		const TCHAR *lName = l->getLangName();
2506  		LexerStyler *pLS = lsa.getLexerStylerByName(lName);
2507  		if (pLS)
2508  			userList = pLS->getLexerUserExt();
2509  		generic_string list;
2510  		if (defList)
2511  			list += defList;
2512  		if (userList)
2513  		{
2514  			list += TEXT(" ");
2515  			list += userList;
2516  		}
2517  		if (isInList(ext, list.c_str()))
2518  			return l->getLangID();
2519  	}
2520  	return L_TEXT;
2521  }
2522  void NppParameters::setCloudChoice(const TCHAR *pathChoice)
2523  {
2524  	generic_string cloudChoicePath = getSettingsFolder();
2525  	cloudChoicePath += TEXT("\\cloud\\");
2526  	if (!PathFileExists(cloudChoicePath.c_str()))
2527  	{
2528  		::CreateDirectory(cloudChoicePath.c_str(), NULL);
2529  	}
2530  	cloudChoicePath += TEXT("choice");
2531  	WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
2532  	std::string cloudPathA = wmc.wchar2char(pathChoice, SC_CP_UTF8);
2533  	writeFileContent(cloudChoicePath.c_str(), cloudPathA.c_str());
2534  }
2535  void NppParameters::removeCloudChoice()
2536  {
2537  	generic_string cloudChoicePath = getSettingsFolder();
2538  	cloudChoicePath += TEXT("\\cloud\\choice");
2539  	if (PathFileExists(cloudChoicePath.c_str()))
2540  	{
2541  		::DeleteFile(cloudChoicePath.c_str());
2542  	}
2543  }
2544  bool NppParameters::isCloudPathChanged() const
2545  {
2546  	if (_initialCloudChoice == _nppGUI._cloudPath)
2547  		return false;
2548  	else if (_initialCloudChoice.size() - _nppGUI._cloudPath.size() == 1)
2549  	{
2550  		TCHAR c = _initialCloudChoice.at(_initialCloudChoice.size()-1);
2551  		if (c == '\\' || c == '/')
2552  		{
2553  			if (_initialCloudChoice.find(_nppGUI._cloudPath) == 0)
2554  				return false;
2555  		}
2556  	}
2557  	else if (_nppGUI._cloudPath.size() - _initialCloudChoice.size() == 1)
2558  	{
2559  		TCHAR c = _nppGUI._cloudPath.at(_nppGUI._cloudPath.size() - 1);
2560  		if (c == '\\' || c == '/')
2561  		{
2562  			if (_nppGUI._cloudPath.find(_initialCloudChoice) == 0)
2563  				return false;
2564  		}
2565  	}
2566  	return true;
2567  }
2568  bool NppParameters::writeSettingsFilesOnCloudForThe1stTime(const generic_string & cloudSettingsPath)
2569  {
2570  	bool isOK = false;
2571  	if (cloudSettingsPath.empty())
2572  		return false;
2573  	generic_string cloudConfigPath = cloudSettingsPath;
2574  	pathAppend(cloudConfigPath, TEXT("config.xml"));
2575  	if (!::PathFileExists(cloudConfigPath.c_str()) && _pXmlUserDoc)
2576  	{
2577  		isOK = _pXmlUserDoc->SaveFile(cloudConfigPath.c_str());
2578  		if (!isOK)
2579  			return false;
2580  	}
2581  	generic_string cloudStylersPath = cloudSettingsPath;
2582  	pathAppend(cloudStylersPath, TEXT("stylers.xml"));
2583  	if (!::PathFileExists(cloudStylersPath.c_str()) && _pXmlUserStylerDoc)
2584  	{
2585  		isOK = _pXmlUserStylerDoc->SaveFile(cloudStylersPath.c_str());
2586  		if (!isOK)
2587  			return false;
2588  	}
2589  	generic_string cloudLangsPath = cloudSettingsPath;
2590  	pathAppend(cloudLangsPath, TEXT("langs.xml"));
2591  	if (!::PathFileExists(cloudLangsPath.c_str()) && _pXmlUserDoc)
2592  	{
2593  		isOK = _pXmlDoc->SaveFile(cloudLangsPath.c_str());
2594  		if (!isOK)
2595  			return false;
2596  	}
2597  	generic_string cloudUserLangsPath = cloudSettingsPath;
2598  	pathAppend(cloudUserLangsPath, TEXT("userDefineLang.xml"));
2599  	if (!::PathFileExists(cloudUserLangsPath.c_str()) && _pXmlUserLangDoc)
2600  	{
2601  		isOK = _pXmlUserLangDoc->SaveFile(cloudUserLangsPath.c_str());
2602  		if (!isOK)
2603  			return false;
2604  	}
2605  	generic_string cloudShortcutsPath = cloudSettingsPath;
2606  	pathAppend(cloudShortcutsPath, SHORTCUTSXML_FILENAME);
2607  	if (!::PathFileExists(cloudShortcutsPath.c_str()) && _pXmlShortcutDocA)
2608  	{
2609  		isOK = _pXmlShortcutDocA->SaveUnicodeFilePath(cloudShortcutsPath.c_str());
2610  		if (!isOK)
2611  			return false;
2612  	}
2613  	generic_string cloudContextMenuPath = cloudSettingsPath;
2614  	pathAppend(cloudContextMenuPath, TEXT("contextMenu.xml"));
2615  	if (!::PathFileExists(cloudContextMenuPath.c_str()) && _pXmlContextMenuDocA)
2616  	{
2617  		isOK = _pXmlContextMenuDocA->SaveUnicodeFilePath(cloudContextMenuPath.c_str());
2618  		if (!isOK)
2619  			return false;
2620  	}
2621  	generic_string cloudNativeLangPath = cloudSettingsPath;
2622  	pathAppend(cloudNativeLangPath, TEXT("nativeLang.xml"));
2623  	if (!::PathFileExists(cloudNativeLangPath.c_str()) && _pXmlNativeLangDocA)
2624  	{
2625  		isOK = _pXmlNativeLangDocA->SaveUnicodeFilePath(cloudNativeLangPath.c_str());
2626  		if (!isOK)
2627  			return false;
2628  	}
2629  	return true;
2630  }
2631  void NppParameters::writeDefaultUDL()
2632  {
2633  	bool firstCleanDone = false;
2634  	std::vector<std::pair<bool, bool>> deleteState; 
2635  	for (const auto& udl : _pXmlUserLangsDoc)
2636  	{
2637  		if (!_pXmlUserLangDoc)
2638  		{
2639  			_pXmlUserLangDoc = new TiXmlDocument(_userDefineLangPath);
2640  			TiXmlDeclaration* decl = new TiXmlDeclaration(TEXT("1.0"), TEXT("UTF-8"), TEXT(""));
2641  			_pXmlUserLangDoc->LinkEndChild(decl);
2642  			_pXmlUserLangDoc->InsertEndChild(TiXmlElement(TEXT("NotepadPlus")));
2643  		}
2644  		bool toDelete = (udl._indexRange.second - udl._indexRange.first) == 0;
2645  		deleteState.push_back(std::pair(toDelete, udl._isInDefaultSharedContainer));
2646  		if ((!udl._udlXmlDoc || udl._udlXmlDoc == _pXmlUserLangDoc) && udl._isDirty && !toDelete) 
2647  		{
2648  			TiXmlNode *root = _pXmlUserLangDoc->FirstChild(TEXT("NotepadPlus"));
2649  			if (root && !firstCleanDone)
2650  			{
2651  				_pXmlUserLangDoc->RemoveChild(root);
2652  				_pXmlUserLangDoc->InsertEndChild(TiXmlElement(TEXT("NotepadPlus")));
2653  				firstCleanDone = true;
2654  			}
2655  			root = _pXmlUserLangDoc->FirstChild(TEXT("NotepadPlus"));
2656  			for (int i = udl._indexRange.first; i < udl._indexRange.second; ++i)
2657  			{
2658  				insertUserLang2Tree(root, _userLangArray[i]);
2659  			}
2660  		}
2661  	}
2662  	bool deleteAll = true;
2663  	for (std::pair<bool, bool> udlState : deleteState)
2664  	{
2665  		if (!udlState.first && udlState.second) 
2666  		{
2667  			deleteAll = false; 
2668  			break;
2669  		}
2670  	}
2671  	if (firstCleanDone) 
2672  	{
2673  		_pXmlUserLangDoc->SaveFile();
2674  	}
2675  	else if (deleteAll)
2676  	{
2677  		if (::PathFileExists(_userDefineLangPath.c_str()))
2678  		{
2679  			::DeleteFile(_userDefineLangPath.c_str());
2680  		}
2681  	}
2682  }
2683  void NppParameters::writeNonDefaultUDL()
2684  {
2685  	for (auto& udl : _pXmlUserLangsDoc)
2686  	{
2687  		if (udl._isDirty && udl._udlXmlDoc != nullptr && udl._udlXmlDoc != _pXmlUserLangDoc)
2688  		{
2689  			if (udl._indexRange.second == udl._indexRange.first) 
2690  			{
2691  				const TCHAR* docFilePath = udl._udlXmlDoc->Value();
2692  				if (docFilePath && ::PathFileExists(docFilePath))
2693  				{
2694  					::DeleteFile(docFilePath);
2695  				}
2696  			}
2697  			else
2698  			{
2699  				TiXmlNode *root = udl._udlXmlDoc->FirstChild(TEXT("NotepadPlus"));
2700  				if (root)
2701  				{
2702  					udl._udlXmlDoc->RemoveChild(root);
2703  				}
2704  				udl._udlXmlDoc->InsertEndChild(TiXmlElement(TEXT("NotepadPlus")));
2705  				root = udl._udlXmlDoc->FirstChild(TEXT("NotepadPlus"));
2706  				for (int i = udl._indexRange.first; i < udl._indexRange.second; ++i)
2707  				{
2708  					insertUserLang2Tree(root, _userLangArray[i]);
2709  				}
2710  				udl._udlXmlDoc->SaveFile();
2711  			}
2712  		}
2713  	}
2714  }
2715  void NppParameters::writeNeed2SaveUDL()
2716  {
2717  	writeDefaultUDL();
2718  	writeNonDefaultUDL();
2719  }
2720  void NppParameters::insertCmd(TiXmlNodeA *shortcutsRoot, const CommandShortcut & cmd)
2721  {
2722  	const KeyCombo & key = cmd.getKeyCombo();
2723  	TiXmlNodeA *sc = shortcutsRoot->InsertEndChild(TiXmlElementA("Shortcut"));
2724  	sc->ToElement()->SetAttribute("id", cmd.getID());
2725  	sc->ToElement()->SetAttribute("Ctrl", key._isCtrl?"yes":"no");
2726  	sc->ToElement()->SetAttribute("Alt", key._isAlt?"yes":"no");
2727  	sc->ToElement()->SetAttribute("Shift", key._isShift?"yes":"no");
2728  	sc->ToElement()->SetAttribute("Key", key._key);
2729  }
2730  void NppParameters::insertMacro(TiXmlNodeA *macrosRoot, const MacroShortcut & macro, const string& folderName)
2731  {
2732  	const KeyCombo & key = macro.getKeyCombo();
2733  	TiXmlNodeA *macroRoot = macrosRoot->InsertEndChild(TiXmlElementA("Macro"));
2734  	macroRoot->ToElement()->SetAttribute("name", macro.getMenuName());
2735  	macroRoot->ToElement()->SetAttribute("Ctrl", key._isCtrl?"yes":"no");
2736  	macroRoot->ToElement()->SetAttribute("Alt", key._isAlt?"yes":"no");
2737  	macroRoot->ToElement()->SetAttribute("Shift", key._isShift?"yes":"no");
2738  	macroRoot->ToElement()->SetAttribute("Key", key._key);
2739  	if (!folderName.empty())
2740  	{
2741  		macroRoot->ToElement()->SetAttribute("FolderName", folderName);
2742  	}
2743  	for (size_t i = 0, len = macro._macro.size(); i < len ; ++i)
2744  	{
2745  		TiXmlNodeA *actionNode = macroRoot->InsertEndChild(TiXmlElementA("Action"));
2746  		const recordedMacroStep & action = macro._macro[i];
2747  		actionNode->ToElement()->SetAttribute("type", action._macroType);
2748  		actionNode->ToElement()->SetAttribute("message", action._message);
2749  		actionNode->ToElement()->SetAttribute("wParam", static_cast<int>(action._wParameter));
2750  		actionNode->ToElement()->SetAttribute("lParam", static_cast<int>(action._lParameter));
2751  		actionNode->ToElement()->SetAttribute("sParam", action._sParameter.c_str());
2752  	}
2753  }
2754  void NppParameters::insertUserCmd(TiXmlNodeA *userCmdRoot, const UserCommand & userCmd, const string& folderName)
2755  {
2756  	const KeyCombo & key = userCmd.getKeyCombo();
2757  	TiXmlNodeA *cmdRoot = userCmdRoot->InsertEndChild(TiXmlElementA("Command"));
2758  	cmdRoot->ToElement()->SetAttribute("name", userCmd.getMenuName());
2759  	cmdRoot->ToElement()->SetAttribute("Ctrl", key._isCtrl?"yes":"no");
2760  	cmdRoot->ToElement()->SetAttribute("Alt", key._isAlt?"yes":"no");
2761  	cmdRoot->ToElement()->SetAttribute("Shift", key._isShift?"yes":"no");
2762  	cmdRoot->ToElement()->SetAttribute("Key", key._key);
2763  	cmdRoot->InsertEndChild(TiXmlTextA(userCmd._cmd.c_str()));
2764  	if (!folderName.empty())
2765  	{
2766  		cmdRoot->ToElement()->SetAttribute("FolderName", folderName);
2767  	}
2768  }
2769  void NppParameters::insertPluginCmd(TiXmlNodeA *pluginCmdRoot, const PluginCmdShortcut & pluginCmd)
2770  {
2771  	const KeyCombo & key = pluginCmd.getKeyCombo();
2772  	TiXmlNodeA *pluginCmdNode = pluginCmdRoot->InsertEndChild(TiXmlElementA("PluginCommand"));
2773  	pluginCmdNode->ToElement()->SetAttribute("moduleName", pluginCmd.getModuleName());
2774  	pluginCmdNode->ToElement()->SetAttribute("internalID", pluginCmd.getInternalID());
2775  	pluginCmdNode->ToElement()->SetAttribute("Ctrl", key._isCtrl?"yes":"no");
2776  	pluginCmdNode->ToElement()->SetAttribute("Alt", key._isAlt?"yes":"no");
2777  	pluginCmdNode->ToElement()->SetAttribute("Shift", key._isShift?"yes":"no");
2778  	pluginCmdNode->ToElement()->SetAttribute("Key", key._key);
2779  }
2780  void NppParameters::insertScintKey(TiXmlNodeA *scintKeyRoot, const ScintillaKeyMap & scintKeyMap)
2781  {
2782  	TiXmlNodeA *keyRoot = scintKeyRoot->InsertEndChild(TiXmlElementA("ScintKey"));
2783  	keyRoot->ToElement()->SetAttribute("ScintID", scintKeyMap.getScintillaKeyID());
2784  	keyRoot->ToElement()->SetAttribute("menuCmdID", scintKeyMap.getMenuCmdID());
2785  	KeyCombo key = scintKeyMap.getKeyComboByIndex(0);
2786  	keyRoot->ToElement()->SetAttribute("Ctrl", key._isCtrl?"yes":"no");
2787  	keyRoot->ToElement()->SetAttribute("Alt", key._isAlt?"yes":"no");
2788  	keyRoot->ToElement()->SetAttribute("Shift", key._isShift?"yes":"no");
2789  	keyRoot->ToElement()->SetAttribute("Key", key._key);
2790  	size_t size = scintKeyMap.getSize();
2791  	if (size > 1)
2792  	{
2793  		for (size_t i = 1; i < size; ++i)
2794  		{
2795  			TiXmlNodeA *keyNext = keyRoot->InsertEndChild(TiXmlElementA("NextKey"));
2796  			key = scintKeyMap.getKeyComboByIndex(i);
2797  			keyNext->ToElement()->SetAttribute("Ctrl", key._isCtrl?"yes":"no");
2798  			keyNext->ToElement()->SetAttribute("Alt", key._isAlt?"yes":"no");
2799  			keyNext->ToElement()->SetAttribute("Shift", key._isShift?"yes":"no");
2800  			keyNext->ToElement()->SetAttribute("Key", key._key);
2801  		}
2802  	}
2803  }
2804  void NppParameters::writeSession(const Session & session, const TCHAR *fileName)
2805  {
2806  	const TCHAR *sessionPathName = fileName ? fileName : _sessionPath.c_str();
2807  	TCHAR backupPathName[MAX_PATH]{};
2808  	if (PathFileExists(sessionPathName))
2809  	{
2810  		_tcscpy(backupPathName, sessionPathName);
2811  		_tcscat(backupPathName, TEXT(".inCaseOfCorruption.bak"));
2812  		CopyFile(sessionPathName, backupPathName, FALSE);
2813  	}
2814  	TiXmlDocument* pXmlSessionDoc = new TiXmlDocument(sessionPathName);
2815  	TiXmlDeclaration* decl = new TiXmlDeclaration(TEXT("1.0"), TEXT("UTF-8"), TEXT(""));
2816  	pXmlSessionDoc->LinkEndChild(decl);
2817  	TiXmlNode *root = pXmlSessionDoc->InsertEndChild(TiXmlElement(TEXT("NotepadPlus")));
2818  	if (root)
2819  	{
2820  		TiXmlNode *sessionNode = root->InsertEndChild(TiXmlElement(TEXT("Session")));
2821  		(sessionNode->ToElement())->SetAttribute(TEXT("activeView"), static_cast<int32_t>(session._activeView));
2822  		struct ViewElem {
2823  			TiXmlNode *viewNode;
2824  			vector<sessionFileInfo> *viewFiles;
2825  			size_t activeIndex;
2826  		};
2827  		const int nbElem = 2;
2828  		ViewElem viewElems[nbElem];
2829  		viewElems[0].viewNode = sessionNode->InsertEndChild(TiXmlElement(TEXT("mainView")));
2830  		viewElems[1].viewNode = sessionNode->InsertEndChild(TiXmlElement(TEXT("subView")));
2831  		viewElems[0].viewFiles = (vector<sessionFileInfo> *)(&(session._mainViewFiles));
2832  		viewElems[1].viewFiles = (vector<sessionFileInfo> *)(&(session._subViewFiles));
2833  		viewElems[0].activeIndex = session._activeMainIndex;
2834  		viewElems[1].activeIndex = session._activeSubIndex;
2835  		for (size_t k = 0; k < nbElem ; ++k)
2836  		{
2837  			(viewElems[k].viewNode->ToElement())->SetAttribute(TEXT("activeIndex"), static_cast<int32_t>(viewElems[k].activeIndex));
2838  			vector<sessionFileInfo> & viewSessionFiles = *(viewElems[k].viewFiles);
2839  			for (size_t i = 0, len = viewElems[k].viewFiles->size(); i < len ; ++i)
2840  			{
2841  				TiXmlNode *fileNameNode = viewElems[k].viewNode->InsertEndChild(TiXmlElement(TEXT("File")));
2842  				TCHAR szInt64[64];
2843  				(fileNameNode->ToElement())->SetAttribute(TEXT("firstVisibleLine"), _i64tot(static_cast<LONGLONG>(viewSessionFiles[i]._firstVisibleLine), szInt64, 10));
2844  				(fileNameNode->ToElement())->SetAttribute(TEXT("xOffset"), _i64tot(static_cast<LONGLONG>(viewSessionFiles[i]._xOffset), szInt64, 10));
2845  				(fileNameNode->ToElement())->SetAttribute(TEXT("scrollWidth"), _i64tot(static_cast<LONGLONG>(viewSessionFiles[i]._scrollWidth), szInt64, 10));
2846  				(fileNameNode->ToElement())->SetAttribute(TEXT("startPos"), _i64tot(static_cast<LONGLONG>(viewSessionFiles[i]._startPos), szInt64, 10));
2847  				(fileNameNode->ToElement())->SetAttribute(TEXT("endPos"), _i64tot(static_cast<LONGLONG>(viewSessionFiles[i]._endPos), szInt64, 10));
2848  				(fileNameNode->ToElement())->SetAttribute(TEXT("selMode"), _i64tot(static_cast<LONGLONG>(viewSessionFiles[i]._selMode), szInt64, 10));
2849  				(fileNameNode->ToElement())->SetAttribute(TEXT("offset"), _i64tot(static_cast<LONGLONG>(viewSessionFiles[i]._offset), szInt64, 10));
2850  				(fileNameNode->ToElement())->SetAttribute(TEXT("wrapCount"), _i64tot(static_cast<LONGLONG>(viewSessionFiles[i]._wrapCount), szInt64, 10));
2851  				(fileNameNode->ToElement())->SetAttribute(TEXT("lang"), viewSessionFiles[i]._langName.c_str());
2852  				(fileNameNode->ToElement())->SetAttribute(TEXT("encoding"), viewSessionFiles[i]._encoding);
2853  				(fileNameNode->ToElement())->SetAttribute(TEXT("userReadOnly"), (viewSessionFiles[i]._isUserReadOnly && !viewSessionFiles[i]._isMonitoring) ? TEXT("yes") : TEXT("no"));
2854  				(fileNameNode->ToElement())->SetAttribute(TEXT("filename"), viewSessionFiles[i]._fileName.c_str());
2855  				(fileNameNode->ToElement())->SetAttribute(TEXT("backupFilePath"), viewSessionFiles[i]._backupFilePath.c_str());
2856  				(fileNameNode->ToElement())->SetAttribute(TEXT("originalFileLastModifTimestamp"), static_cast<int32_t>(viewSessionFiles[i]._originalFileLastModifTimestamp.dwLowDateTime));
2857  				(fileNameNode->ToElement())->SetAttribute(TEXT("originalFileLastModifTimestampHigh"), static_cast<int32_t>(viewSessionFiles[i]._originalFileLastModifTimestamp.dwHighDateTime));
2858  				(fileNameNode->ToElement())->SetAttribute(TEXT("tabColourId"), static_cast<int32_t>(viewSessionFiles[i]._individualTabColour));
2859  				(fileNameNode->ToElement())->SetAttribute(TEXT("mapFirstVisibleDisplayLine"), _i64tot(static_cast<LONGLONG>(viewSessionFiles[i]._mapPos._firstVisibleDisplayLine), szInt64, 10));
2860  				(fileNameNode->ToElement())->SetAttribute(TEXT("mapFirstVisibleDocLine"), _i64tot(static_cast<LONGLONG>(viewSessionFiles[i]._mapPos._firstVisibleDocLine), szInt64, 10));
2861  				(fileNameNode->ToElement())->SetAttribute(TEXT("mapLastVisibleDocLine"), _i64tot(static_cast<LONGLONG>(viewSessionFiles[i]._mapPos._lastVisibleDocLine), szInt64, 10));
2862  				(fileNameNode->ToElement())->SetAttribute(TEXT("mapNbLine"), _i64tot(static_cast<LONGLONG>(viewSessionFiles[i]._mapPos._nbLine), szInt64, 10));
2863  				(fileNameNode->ToElement())->SetAttribute(TEXT("mapHigherPos"), _i64tot(static_cast<LONGLONG>(viewSessionFiles[i]._mapPos._higherPos), szInt64, 10));
2864  				(fileNameNode->ToElement())->SetAttribute(TEXT("mapWidth"), _i64tot(static_cast<LONGLONG>(viewSessionFiles[i]._mapPos._width), szInt64, 10));
2865  				(fileNameNode->ToElement())->SetAttribute(TEXT("mapHeight"), _i64tot(static_cast<LONGLONG>(viewSessionFiles[i]._mapPos._height), szInt64, 10));
2866  				(fileNameNode->ToElement())->SetAttribute(TEXT("mapKByteInDoc"), _i64tot(static_cast<LONGLONG>(viewSessionFiles[i]._mapPos._KByteInDoc), szInt64, 10));
2867  				(fileNameNode->ToElement())->SetAttribute(TEXT("mapWrapIndentMode"), _i64tot(static_cast<LONGLONG>(viewSessionFiles[i]._mapPos._wrapIndentMode), szInt64, 10));
2868  				fileNameNode->ToElement()->SetAttribute(TEXT("mapIsWrap"), viewSessionFiles[i]._mapPos._isWrap ? TEXT("yes") : TEXT("no"));
2869  				for (size_t j = 0, len = viewSessionFiles[i]._marks.size() ; j < len ; ++j)
2870  				{
2871  					size_t markLine = viewSessionFiles[i]._marks[j];
2872  					TiXmlNode *markNode = fileNameNode->InsertEndChild(TiXmlElement(TEXT("Mark")));
2873  					markNode->ToElement()->SetAttribute(TEXT("line"), _ui64tot(static_cast<ULONGLONG>(markLine), szInt64, 10));
2874  				}
2875  				for (size_t j = 0, len = viewSessionFiles[i]._foldStates.size() ; j < len ; ++j)
2876  				{
2877  					size_t foldLine = viewSessionFiles[i]._foldStates[j];
2878  					TiXmlNode *foldNode = fileNameNode->InsertEndChild(TiXmlElement(TEXT("Fold")));
2879  					foldNode->ToElement()->SetAttribute(TEXT("line"), _ui64tot(static_cast<ULONGLONG>(foldLine), szInt64, 10));
2880  				}
2881  			}
2882  		}
2883  		if (session._includeFileBrowser)
2884  		{
2885  			TiXmlNode* fileBrowserRootNode = sessionNode->InsertEndChild(TiXmlElement(TEXT("FileBrowser")));
2886  			fileBrowserRootNode->ToElement()->SetAttribute(TEXT("latestSelectedItem"), session._fileBrowserSelectedItem.c_str());
2887  			for (const auto& root : session._fileBrowserRoots)
2888  			{
2889  				TiXmlNode *fileNameNode = fileBrowserRootNode->InsertEndChild(TiXmlElement(TEXT("root")));
2890  				(fileNameNode->ToElement())->SetAttribute(TEXT("foldername"), root.c_str());
2891  			}
2892  		}
2893  	}
2894  	bool sessionSaveOK = pXmlSessionDoc->SaveFile();
2895  	if (sessionSaveOK)
2896  	{
2897  		TiXmlDocument* pXmlSessionCheck = new TiXmlDocument(sessionPathName);
2898  		sessionSaveOK = pXmlSessionCheck->LoadFile();
2899  		delete pXmlSessionCheck;
2900  	}
2901  	if (!sessionSaveOK)
2902  	{
2903  		if (backupPathName[0]) 
2904  		{
2905  			_pNativeLangSpeaker->messageBox("ErrorOfSavingSessionFile",
2906  				nullptr,
2907  				TEXT("The old session file will be restored."),
2908  				TEXT("Error of saving session file"),
2909  				MB_OK | MB_APPLMODAL | MB_ICONWARNING);
2910  			CopyFile(backupPathName, sessionPathName, FALSE);
2911  		}
2912  	}
2913  	else
2914  	{
2915  		if (backupPathName[0]) 
2916  		{
2917  			::DeleteFile(backupPathName);
2918  		}
2919  	}
2920  	delete pXmlSessionDoc;
2921  }
2922  void NppParameters::writeShortcuts()
2923  {
2924  	if (!_isAnyShortcutModified) return;
2925  	if (!_pXmlShortcutDocA)
2926  	{
2927  		_pXmlShortcutDocA = new TiXmlDocumentA();
2928  		TiXmlDeclarationA* decl = new TiXmlDeclarationA("1.0", "UTF-8", "");
2929  		_pXmlShortcutDocA->LinkEndChild(decl);
2930  	}
2931  	else
2932  	{
2933  		wchar_t v852NoNeedShortcutsBackup[MAX_PATH]{};
2934  		::wcscpy_s(v852NoNeedShortcutsBackup, _shortcutsPath.c_str());
2935  		::PathRemoveFileSpec(v852NoNeedShortcutsBackup);
2936  		::PathAppend(v852NoNeedShortcutsBackup, NONEEDSHORTCUTSXMLBACKUP_FILENAME);
2937  		if (!::PathFileExists(v852NoNeedShortcutsBackup))
2938  		{
2939  			HANDLE hFile = ::CreateFile(v852NoNeedShortcutsBackup, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
2940  			::FlushFileBuffers(hFile);
2941  			::CloseHandle(hFile);
2942  			wstring v852ShortcutsBackupPath = _shortcutsPath;
2943  			v852ShortcutsBackupPath += L".v8.5.2.backup";
2944  			::CopyFile(_shortcutsPath.c_str(), v852ShortcutsBackupPath.c_str(), TRUE);
2945  			_pNativeLangSpeaker->messageBox("MacroAndRunCmdlWarning",
2946  				nullptr,
2947  				TEXT("Your Macro and Run commands saved in Notepad++ v.8.5.2 (or older) may not be compatible with the current version of Notepad++.\nPlease test those commands and, if needed, re-edit them.\n\nAlternatively, you can downgrade to Notepad++ v8.5.2 and restore your previous data.\nNotepad++ will backup your old \"shortcuts.xml\" and save it as \"shortcuts.xml.v8.5.2.backup\".\nRenaming \"shortcuts.xml.v8.5.2.backup\" -> \"shortcuts.xml\", your commands should be restored and work properly."),
2948  				TEXT("Macro and Run Commands Compatibility"),
2949  				MB_OK | MB_APPLMODAL | MB_ICONWARNING);
2950  		}
2951  	}
2952  	TiXmlNodeA *root = _pXmlShortcutDocA->FirstChild("NotepadPlus");
2953  	if (!root)
2954  	{
2955  		root = _pXmlShortcutDocA->InsertEndChild(TiXmlElementA("NotepadPlus"));
2956  	}
2957  	TiXmlNodeA *cmdRoot = root->FirstChild("InternalCommands");
2958  	if (cmdRoot)
2959  		root->RemoveChild(cmdRoot);
2960  	cmdRoot = root->InsertEndChild(TiXmlElementA("InternalCommands"));
2961  	for (size_t i = 0, len = _customizedShortcuts.size(); i < len ; ++i)
2962  	{
2963  		size_t index = _customizedShortcuts[i];
2964  		CommandShortcut csc = _shortcuts[index];
2965  		insertCmd(cmdRoot, csc);
2966  	}
2967  	TiXmlNodeA *macrosRoot = root->FirstChild("Macros");
2968  	if (macrosRoot)
2969  		root->RemoveChild(macrosRoot);
2970  	macrosRoot = root->InsertEndChild(TiXmlElementA("Macros"));
2971  	for (size_t i = 0, len = _macros.size(); i < len ; ++i)
2972  	{
2973  		insertMacro(macrosRoot, _macros[i], wstring2string(_macroMenuItems.getItemFromIndex(i)._parentFolderName, CP_UTF8));
2974  	}
2975  	TiXmlNodeA *userCmdRoot = root->FirstChild("UserDefinedCommands");
2976  	if (userCmdRoot)
2977  		root->RemoveChild(userCmdRoot);
2978  	userCmdRoot = root->InsertEndChild(TiXmlElementA("UserDefinedCommands"));
2979  	for (size_t i = 0, len = _userCommands.size(); i < len ; ++i)
2980  	{
2981  		insertUserCmd(userCmdRoot, _userCommands[i], wstring2string(_runMenuItems.getItemFromIndex(i)._parentFolderName, CP_UTF8));
2982  	}
2983  	TiXmlNodeA *pluginCmdRoot = root->FirstChild("PluginCommands");
2984  	if (pluginCmdRoot)
2985  		root->RemoveChild(pluginCmdRoot);
2986  	pluginCmdRoot = root->InsertEndChild(TiXmlElementA("PluginCommands"));
2987  	for (size_t i = 0, len = _pluginCustomizedCmds.size(); i < len ; ++i)
2988  	{
2989  		insertPluginCmd(pluginCmdRoot, _pluginCommands[_pluginCustomizedCmds[i]]);
2990  	}
2991  	TiXmlNodeA *scitillaKeyRoot = root->FirstChild("ScintillaKeys");
2992  	if (scitillaKeyRoot)
2993  		root->RemoveChild(scitillaKeyRoot);
2994  	scitillaKeyRoot = root->InsertEndChild(TiXmlElementA("ScintillaKeys"));
2995  	for (size_t i = 0, len = _scintillaModifiedKeyIndices.size(); i < len ; ++i)
2996  	{
2997  		insertScintKey(scitillaKeyRoot, _scintillaKeyCommands[_scintillaModifiedKeyIndices[i]]);
2998  	}
2999  	_pXmlShortcutDocA->SaveUnicodeFilePath(_shortcutsPath.c_str());
3000  }
3001  int NppParameters::addUserLangToEnd(const UserLangContainer & userLang, const TCHAR *newName)
3002  {
3003  	if (isExistingUserLangName(newName))
3004  		return -1;
3005  	unsigned char iBegin = _nbUserLang;
3006  	_userLangArray[_nbUserLang] = new UserLangContainer();
3007  	*(_userLangArray[_nbUserLang]) = userLang;
3008  	_userLangArray[_nbUserLang]->_name = newName;
3009  	++_nbUserLang;
3010  	unsigned char iEnd = _nbUserLang;
3011  	_pXmlUserLangsDoc.push_back(UdlXmlFileState(nullptr, true, true, make_pair(iBegin, iEnd)));
3012  	setUdlXmlDirtyFromXmlDoc(_pXmlUserLangDoc);
3013  	return _nbUserLang-1;
3014  }
3015  void NppParameters::removeUserLang(size_t index)
3016  {
3017  	if (static_cast<int32_t>(index) >= _nbUserLang)
3018  		return;
3019  	delete _userLangArray[index];
3020  	for (int32_t i = static_cast<int32_t>(index); i < (_nbUserLang - 1); ++i)
3021  		_userLangArray[i] = _userLangArray[i+1];
3022  	_nbUserLang--;
3023  	removeIndexFromXmlUdls(index);
3024  }
3025  void NppParameters::feedUserSettings(TiXmlNode *settingsRoot)
3026  {
3027  	const TCHAR *boolStr;
3028  	TiXmlNode *globalSettingNode = settingsRoot->FirstChildElement(TEXT("Global"));
3029  	if (globalSettingNode)
3030  	{
3031  		boolStr = (globalSettingNode->ToElement())->Attribute(TEXT("caseIgnored"));
3032  		if (boolStr)
3033  			_userLangArray[_nbUserLang - 1]->_isCaseIgnored = (lstrcmp(TEXT("yes"), boolStr) == 0);
3034  		boolStr = (globalSettingNode->ToElement())->Attribute(TEXT("allowFoldOfComments"));
3035  		if (boolStr)
3036  			_userLangArray[_nbUserLang - 1]->_allowFoldOfComments = (lstrcmp(TEXT("yes"), boolStr) == 0);
3037  		(globalSettingNode->ToElement())->Attribute(TEXT("forcePureLC"), &_userLangArray[_nbUserLang - 1]->_forcePureLC);
3038  		(globalSettingNode->ToElement())->Attribute(TEXT("decimalSeparator"), &_userLangArray[_nbUserLang - 1]->_decimalSeparator);
3039  		boolStr = (globalSettingNode->ToElement())->Attribute(TEXT("foldCompact"));
3040  		if (boolStr)
3041  			_userLangArray[_nbUserLang - 1]->_foldCompact = (lstrcmp(TEXT("yes"), boolStr) == 0);
3042  	}
3043  	TiXmlNode *prefixNode = settingsRoot->FirstChildElement(TEXT("Prefix"));
3044  	if (prefixNode)
3045  	{
3046  		const TCHAR *udlVersion = _userLangArray[_nbUserLang - 1]->_udlVersion.c_str();
3047  		if (!lstrcmp(udlVersion, TEXT("2.1")) || !lstrcmp(udlVersion, TEXT("2.0")))
3048  		{
3049  			for (int i = 0 ; i < SCE_USER_TOTAL_KEYWORD_GROUPS ; ++i)
3050  			{
3051  				boolStr = (prefixNode->ToElement())->Attribute(globalMappper().keywordNameMapper[i+SCE_USER_KWLIST_KEYWORDS1]);
3052  				if (boolStr)
3053  					_userLangArray[_nbUserLang - 1]->_isPrefix[i] = (lstrcmp(TEXT("yes"), boolStr) == 0);
3054  			}
3055  		}
3056  		else	
3057  		{
3058  			TCHAR names[SCE_USER_TOTAL_KEYWORD_GROUPS][7] = {TEXT("words1"), TEXT("words2"), TEXT("words3"), TEXT("words4")};
3059  			for (int i = 0 ; i < 4 ; ++i)
3060  			{
3061  				boolStr = (prefixNode->ToElement())->Attribute(names[i]);
3062  				if (boolStr)
3063  					_userLangArray[_nbUserLang - 1]->_isPrefix[i] = (lstrcmp(TEXT("yes"), boolStr) == 0);
3064  			}
3065  		}
3066  	}
3067  }
3068  void NppParameters::feedUserKeywordList(TiXmlNode *node)
3069  {
3070  	const TCHAR * udlVersion = _userLangArray[_nbUserLang - 1]->_udlVersion.c_str();
3071  	int id = -1;
3072  	for (TiXmlNode *childNode = node->FirstChildElement(TEXT("Keywords"));
3073  		childNode ;
3074  		childNode = childNode->NextSibling(TEXT("Keywords")))
3075  	{
3076  		const TCHAR * keywordsName = (childNode->ToElement())->Attribute(TEXT("name"));
3077  		TiXmlNode *valueNode = childNode->FirstChild();
3078  		if (valueNode)
3079  		{
3080  			const TCHAR *kwl = nullptr;
3081  			if (!lstrcmp(udlVersion, TEXT("")) && !lstrcmp(keywordsName, TEXT("Delimiters")))	
3082  			{
3083  				basic_string<TCHAR> temp;
3084  				kwl = (valueNode)?valueNode->Value():TEXT("000000");
3085  				temp += TEXT("00");	 if (kwl[0] != '0') temp += kwl[0];	 temp += TEXT(" 01");
3086  				temp += TEXT(" 02");	if (kwl[3] != '0') temp += kwl[3];
3087  				temp += TEXT(" 03");	if (kwl[1] != '0') temp += kwl[1];	 temp += TEXT(" 04");
3088  				temp += TEXT(" 05");	if (kwl[4] != '0') temp += kwl[4];
3089  				temp += TEXT(" 06");	if (kwl[2] != '0') temp += kwl[2];	 temp += TEXT(" 07");
3090  				temp += TEXT(" 08");	if (kwl[5] != '0') temp += kwl[5];
3091  				temp += TEXT(" 09 10 11 12 13 14 15 16 17 18 19 20 21 22 23");
3092  				wcscpy_s(_userLangArray[_nbUserLang - 1]->_keywordLists[SCE_USER_KWLIST_DELIMITERS], temp.c_str());
3093  			}
3094  			else if (!lstrcmp(keywordsName, TEXT("Comment")))
3095  			{
3096  				kwl = (valueNode)?valueNode->Value():TEXT("");
3097  				basic_string<TCHAR> temp{TEXT(" ")};
3098  				temp += kwl;
3099  				size_t pos = 0;
3100  				pos = temp.find(TEXT(" 0"));
3101  				while (pos != string::npos)
3102  				{
3103  					temp.replace(pos, 2, TEXT(" 00"));
3104  					pos = temp.find(TEXT(" 0"), pos+1);
3105  				}
3106  				pos = temp.find(TEXT(" 1"));
3107  				while (pos != string::npos)
3108  				{
3109  					temp.replace(pos, 2, TEXT(" 03"));
3110  					pos = temp.find(TEXT(" 1"));
3111  				}
3112  				pos = temp.find(TEXT(" 2"));
3113  				while (pos != string::npos)
3114  				{
3115  					temp.replace(pos, 2, TEXT(" 04"));
3116  					pos = temp.find(TEXT(" 2"));
3117  				}
3118  				temp += TEXT(" 01 02");
3119  				if (temp[0] == ' ')
3120  					temp.erase(0, 1);
3121  				wcscpy_s(_userLangArray[_nbUserLang - 1]->_keywordLists[SCE_USER_KWLIST_COMMENTS], temp.c_str());
3122  			}
3123  			else
3124  			{
3125  				kwl = (valueNode)?valueNode->Value():TEXT("");
3126  				if (globalMappper().keywordIdMapper.find(keywordsName) != globalMappper().keywordIdMapper.end())
3127  				{
3128  					id = globalMappper().keywordIdMapper[keywordsName];
3129  					if (wcslen(kwl) < max_char)
3130  					{
3131  						wcscpy_s(_userLangArray[_nbUserLang - 1]->_keywordLists[id], kwl);
3132  					}
3133  					else
3134  					{
3135  						wcscpy_s(_userLangArray[_nbUserLang - 1]->_keywordLists[id], TEXT("imported string too long, needs to be < max_char(30720)"));
3136  					}
3137  				}
3138  			}
3139  		}
3140  	}
3141  }
3142  void NppParameters::feedUserStyles(TiXmlNode *node)
3143  {
3144  	int id = -1;
3145  	for (TiXmlNode *childNode = node->FirstChildElement(TEXT("WordsStyle"));
3146  		childNode ;
3147  		childNode = childNode->NextSibling(TEXT("WordsStyle")))
3148  	{
3149  		const TCHAR *styleName = (childNode->ToElement())->Attribute(TEXT("name"));
3150  		if (styleName)
3151  		{
3152  			if (globalMappper().styleIdMapper.find(styleName) != globalMappper().styleIdMapper.end())
3153  			{
3154  				id = globalMappper().styleIdMapper[styleName];
3155  				_userLangArray[_nbUserLang - 1]->_styles.addStyler((id | L_USER << 16), childNode);
3156  			}
3157  		}
3158  	}
3159  }
3160  bool NppParameters::feedStylerArray(TiXmlNode *node)
3161  {
3162  	TiXmlNode *styleRoot = node->FirstChildElement(TEXT("LexerStyles"));
3163  	if (!styleRoot) return false;
3164  	for (TiXmlNode *childNode = styleRoot->FirstChildElement(TEXT("LexerType"));
3165  		 childNode ;
3166  		 childNode = childNode->NextSibling(TEXT("LexerType")) )
3167  	{
3168  		TiXmlElement *element = childNode->ToElement();
3169  		const TCHAR *lexerName = element->Attribute(TEXT("name"));
3170  		const TCHAR *lexerDesc = element->Attribute(TEXT("desc"));
3171  		const TCHAR *lexerUserExt = element->Attribute(TEXT("ext"));
3172  		const TCHAR *lexerExcluded = element->Attribute(TEXT("excluded"));
3173  		if (lexerName)
3174  		{
3175  			_lexerStylerVect.addLexerStyler(lexerName, lexerDesc, lexerUserExt, childNode);
3176  			if (lexerExcluded != NULL && (lstrcmp(lexerExcluded, TEXT("yes")) == 0))
3177  			{
3178  				int index = getExternalLangIndexFromName(lexerName);
3179  				if (index != -1)
3180  					_nppGUI._excludedLangList.push_back(LangMenuItem((LangType)(index + L_EXTERNAL)));
3181  			}
3182  		}
3183  	}
3184  	_lexerStylerVect.sort();
3185  	TiXmlNode *globalStyleRoot = node->FirstChildElement(TEXT("GlobalStyles"));
3186  	if (!globalStyleRoot) return false;
3187  	for (TiXmlNode *childNode = globalStyleRoot->FirstChildElement(TEXT("WidgetStyle"));
3188  		 childNode ;
3189  		 childNode = childNode->NextSibling(TEXT("WidgetStyle")) )
3190  	{
3191  		TiXmlElement *element = childNode->ToElement();
3192  		const TCHAR *styleIDStr = element->Attribute(TEXT("styleID"));
3193  		int styleID = -1;
3194  		if ((styleID = decStrVal(styleIDStr)) != -1)
3195  		{
3196  			_widgetStyleArray.addStyler(styleID, childNode);
3197  		}
3198  	}
3199  	constexpr auto rgbhex = [](COLORREF bbggrr) -> int {
3200  		return
3201  			((bbggrr & 0xFF0000) >> 16) |
3202  			((bbggrr & 0x00FF00)) |
3203  			((bbggrr & 0x0000FF) << 16);
3204  	};
3205  	const Style* pStyle = _widgetStyleArray.findByName(TEXT("EOL custom color"));
3206  	if (!pStyle)
3207  	{
3208  		TiXmlNode* eolColorkNode = globalStyleRoot->InsertEndChild(TiXmlElement(TEXT("WidgetStyle")));
3209  		eolColorkNode->ToElement()->SetAttribute(TEXT("name"), TEXT("EOL custom color"));
3210  		eolColorkNode->ToElement()->SetAttribute(TEXT("styleID"), TEXT("0"));
3211  		eolColorkNode->ToElement()->SetAttribute(TEXT("fgColor"), TEXT("DADADA"));
3212  		_widgetStyleArray.addStyler(0, eolColorkNode);
3213  	}
3214  	const Style* pStyleNpc = _widgetStyleArray.findByName(g_npcStyleName);
3215  	if (!pStyleNpc)
3216  	{
3217  		TiXmlNode* npcColorkNode = globalStyleRoot->InsertEndChild(TiXmlElement(TEXT("WidgetStyle")));
3218  		npcColorkNode->ToElement()->SetAttribute(TEXT("name"), g_npcStyleName);
3219  		npcColorkNode->ToElement()->SetAttribute(TEXT("styleID"), TEXT("0"));
3220  		const Style* pStyleWS = _widgetStyleArray.findByName(TEXT("White space symbol"));
3221  		if (pStyleWS)
3222  		{
3223  			constexpr size_t bufSize = 7;
3224  			wchar_t strColor[bufSize] = { '\0' };
3225  			swprintf(strColor, bufSize, L"%6X", rgbhex(pStyleWS->_fgColor));
3226  			npcColorkNode->ToElement()->SetAttribute(L"fgColor", strColor);
3227  		}
3228  		else
3229  		{
3230  			npcColorkNode->ToElement()->SetAttribute(L"fgColor", L"DADADA");
3231  		}
3232  		_widgetStyleArray.addStyler(0, npcColorkNode);
3233  	}
3234  	return true;
3235  }
3236  void LexerStylerArray::addLexerStyler(const TCHAR *lexerName, const TCHAR *lexerDesc, const TCHAR *lexerUserExt , TiXmlNode *lexerNode)
3237  {
3238  	_lexerStylerVect.emplace_back();
3239  	LexerStyler & ls = _lexerStylerVect.back();
3240  	ls.setLexerName(lexerName);
3241  	if (lexerDesc)
3242  		ls.setLexerDesc(lexerDesc);
3243  	if (lexerUserExt)
3244  		ls.setLexerUserExt(lexerUserExt);
3245  	for (TiXmlNode *childNode = lexerNode->FirstChildElement(TEXT("WordsStyle"));
3246  		 childNode ;
3247  		 childNode = childNode->NextSibling(TEXT("WordsStyle")) )
3248  	{
3249  		TiXmlElement *element = childNode->ToElement();
3250  		const TCHAR *styleIDStr = element->Attribute(TEXT("styleID"));
3251  		if (styleIDStr)
3252  		{
3253  			int styleID = -1;
3254  			if ((styleID = decStrVal(styleIDStr)) != -1)
3255  			{
3256  				ls.addStyler(styleID, childNode);
3257  			}
3258  		}
3259  	}
3260  }
3261  void StyleArray::addStyler(int styleID, TiXmlNode *styleNode)
3262  {
3263  	bool isUser = styleID >> 16 == L_USER;
3264  	if (isUser)
3265  	{
3266  		styleID = (styleID & 0xFFFF);
3267  		if (styleID >= SCE_USER_STYLE_TOTAL_STYLES || findByID(styleID))
3268  			return;
3269  	}
3270  	_styleVect.emplace_back();
3271  	Style & s = _styleVect.back();
3272  	s._styleID = styleID;
3273  	if (styleNode)
3274  	{
3275  		TiXmlElement *element = styleNode->ToElement();
3276  		const TCHAR *str = element->Attribute(TEXT("name"));
3277  		if (str)
3278  		{
3279  			if (isUser)
3280  				s._styleDesc = globalMappper().styleNameMapper[styleID];
3281  			else
3282  				s._styleDesc = str;
3283  		}
3284  		str = element->Attribute(TEXT("fgColor"));
3285  		if (str)
3286  		{
3287  			unsigned long result = hexStrVal(str);
3288  			s._fgColor = (RGB((result >> 16) & 0xFF, (result >> 8) & 0xFF, result & 0xFF)) | (result & 0xFF000000);
3289  		}
3290  		str = element->Attribute(TEXT("bgColor"));
3291  		if (str)
3292  		{
3293  			unsigned long result = hexStrVal(str);
3294  			s._bgColor = (RGB((result >> 16) & 0xFF, (result >> 8) & 0xFF, result & 0xFF)) | (result & 0xFF000000);
3295  		}
3296  		str = element->Attribute(TEXT("colorStyle"));
3297  		if (str)
3298  		{
3299  			s._colorStyle = decStrVal(str);
3300  		}
3301  		str = element->Attribute(TEXT("fontName"));
3302  		if (str)
3303  		{
3304  			s._fontName = str;
3305  			s._isFontEnabled = true;
3306  		}
3307  		str = element->Attribute(TEXT("fontStyle"));
3308  		if (str)
3309  		{
3310  			s._fontStyle = decStrVal(str);
3311  		}
3312  		str = element->Attribute(TEXT("fontSize"));
3313  		if (str)
3314  		{
3315  			s._fontSize = decStrVal(str);
3316  		}
3317  		str = element->Attribute(TEXT("nesting"));
3318  		if (str)
3319  		{
3320  			s._nesting = decStrVal(str);
3321  		}
3322  		str = element->Attribute(TEXT("keywordClass"));
3323  		if (str)
3324  		{
3325  			s._keywordClass = getKwClassFromName(str);
3326  		}
3327  		TiXmlNode *v = styleNode->FirstChild();
3328  		if (v)
3329  		{
3330  			s._keywords = v->Value();
3331  		}
3332  	}
3333  }
3334  bool NppParameters::writeRecentFileHistorySettings(int nbMaxFile) const
3335  {
3336  	if (!_pXmlUserDoc) return false;
3337  	TiXmlNode *nppRoot = _pXmlUserDoc->FirstChild(TEXT("NotepadPlus"));
3338  	if (!nppRoot)
3339  	{
3340  		nppRoot = _pXmlUserDoc->InsertEndChild(TiXmlElement(TEXT("NotepadPlus")));
3341  	}
3342  	TiXmlNode *historyNode = nppRoot->FirstChildElement(TEXT("History"));
3343  	if (!historyNode)
3344  	{
3345  		historyNode = nppRoot->InsertEndChild(TiXmlElement(TEXT("History")));
3346  	}
3347  	(historyNode->ToElement())->SetAttribute(TEXT("nbMaxFile"), nbMaxFile!=-1?nbMaxFile:_nbMaxRecentFile);
3348  	(historyNode->ToElement())->SetAttribute(TEXT("inSubMenu"), _putRecentFileInSubMenu?TEXT("yes"):TEXT("no"));
3349  	(historyNode->ToElement())->SetAttribute(TEXT("customLength"), _recentFileCustomLength);
3350  	return true;
3351  }
3352  bool NppParameters::writeColumnEditorSettings() const
3353  {
3354  	if (!_pXmlUserDoc) return false;
3355  	TiXmlNode *nppRoot = _pXmlUserDoc->FirstChild(TEXT("NotepadPlus"));
3356  	if (!nppRoot)
3357  	{
3358  		nppRoot = _pXmlUserDoc->InsertEndChild(TiXmlElement(TEXT("NotepadPlus")));
3359  	}
3360  	TiXmlNode *oldColumnEditorNode = nppRoot->FirstChildElement(TEXT("ColumnEditor"));
3361  	if (oldColumnEditorNode)
3362  	{
3363  		nppRoot->RemoveChild(oldColumnEditorNode);
3364  	}
3365  	TiXmlElement columnEditorRootNode{TEXT("ColumnEditor")};
3366  	(columnEditorRootNode.ToElement())->SetAttribute(TEXT("choice"), _columnEditParam._mainChoice == activeNumeric ? L"number" : L"text");
3367  	TiXmlElement textNode{ TEXT("text") };
3368  	(textNode.ToElement())->SetAttribute(TEXT("content"), _columnEditParam._insertedTextContent.c_str());
3369  	(columnEditorRootNode.ToElement())->InsertEndChild(textNode);
3370  	TiXmlElement numberNode{ TEXT("number") };
3371  	(numberNode.ToElement())->SetAttribute(TEXT("initial"), _columnEditParam._initialNum);
3372  	(numberNode.ToElement())->SetAttribute(TEXT("increase"), _columnEditParam._increaseNum);
3373  	(numberNode.ToElement())->SetAttribute(TEXT("repeat"), _columnEditParam._repeatNum);
3374  	wstring format = TEXT("dec");
3375  	if (_columnEditParam._formatChoice == 1)
3376  		format = TEXT("hex");
3377  	else if (_columnEditParam._formatChoice == 2)
3378  		format = TEXT("oct");
3379  	else if (_columnEditParam._formatChoice == 3)
3380  		format = TEXT("bin");
3381  	(numberNode.ToElement())->SetAttribute(TEXT("formatChoice"), format);
3382  	wstring leading = TEXT("none");
3383  	if (_columnEditParam._leadingChoice == ColumnEditorParam::zeroLeading)
3384  		leading = TEXT("zeros");
3385  	else if (_columnEditParam._leadingChoice == ColumnEditorParam::spaceLeading)
3386  		leading = TEXT("spaces");
3387  	(numberNode.ToElement())->SetAttribute(TEXT("leadingChoice"), leading);
3388  	(columnEditorRootNode.ToElement())->InsertEndChild(numberNode);
3389  	(nppRoot->ToElement())->InsertEndChild(columnEditorRootNode);
3390  	return true;
3391  }
3392  bool NppParameters::writeProjectPanelsSettings() const
3393  {
3394  	if (!_pXmlUserDoc) return false;
3395  	TiXmlNode *nppRoot = _pXmlUserDoc->FirstChild(TEXT("NotepadPlus"));
3396  	if (!nppRoot)
3397  	{
3398  		nppRoot = _pXmlUserDoc->InsertEndChild(TiXmlElement(TEXT("NotepadPlus")));
3399  	}
3400  	TiXmlNode *oldProjPanelRootNode = nppRoot->FirstChildElement(TEXT("ProjectPanels"));
3401  	if (oldProjPanelRootNode)
3402  	{
3403  		nppRoot->RemoveChild(oldProjPanelRootNode);
3404  	}
3405  	TiXmlElement projPanelRootNode{TEXT("ProjectPanels")};
3406  	for (int32_t i = 0 ; i < 3 ; ++i)
3407  	{
3408  		TiXmlElement projPanelNode{TEXT("ProjectPanel")};
3409  		(projPanelNode.ToElement())->SetAttribute(TEXT("id"), i);
3410  		(projPanelNode.ToElement())->SetAttribute(TEXT("workSpaceFile"), _workSpaceFilePathes[i]);
3411  		(projPanelRootNode.ToElement())->InsertEndChild(projPanelNode);
3412  	}
3413  	(nppRoot->ToElement())->InsertEndChild(projPanelRootNode);
3414  	return true;
3415  }
3416  bool NppParameters::writeFileBrowserSettings(const vector<generic_string> & rootPaths, const generic_string & latestSelectedItemPath) const
3417  {
3418  	if (!_pXmlUserDoc) return false;
3419  	TiXmlNode *nppRoot = _pXmlUserDoc->FirstChild(TEXT("NotepadPlus"));
3420  	if (!nppRoot)
3421  	{
3422  		nppRoot = _pXmlUserDoc->InsertEndChild(TiXmlElement(TEXT("NotepadPlus")));
3423  	}
3424  	TiXmlNode *oldFileBrowserRootNode = nppRoot->FirstChildElement(TEXT("FileBrowser"));
3425  	if (oldFileBrowserRootNode)
3426  	{
3427  		nppRoot->RemoveChild(oldFileBrowserRootNode);
3428  	}
3429  	TiXmlElement fileBrowserRootNode{ TEXT("FileBrowser") };
3430  	if (rootPaths.size() != 0)
3431  	{
3432  		fileBrowserRootNode.SetAttribute(TEXT("latestSelectedItem"), latestSelectedItemPath.c_str());
3433  		size_t len = rootPaths.size();
3434  		for (size_t i = 0; i < len; ++i)
3435  		{
3436  			TiXmlElement fbRootNode{ TEXT("root") };
3437  			(fbRootNode.ToElement())->SetAttribute(TEXT("foldername"), rootPaths[i].c_str());
3438  			(fileBrowserRootNode.ToElement())->InsertEndChild(fbRootNode);
3439  		}
3440  	}
3441  	(nppRoot->ToElement())->InsertEndChild(fileBrowserRootNode);
3442  	return true;
3443  }
3444  bool NppParameters::writeHistory(const TCHAR *fullpath)
3445  {
3446  	TiXmlNode *nppRoot = _pXmlUserDoc->FirstChild(TEXT("NotepadPlus"));
3447  	if (!nppRoot)
3448  	{
3449  		nppRoot = _pXmlUserDoc->InsertEndChild(TiXmlElement(TEXT("NotepadPlus")));
3450  	}
3451  	TiXmlNode *historyNode = nppRoot->FirstChildElement(TEXT("History"));
3452  	if (!historyNode)
3453  	{
3454  		historyNode = nppRoot->InsertEndChild(TiXmlElement(TEXT("History")));
3455  	}
3456  	TiXmlElement recentFileNode(TEXT("File"));
3457  	(recentFileNode.ToElement())->SetAttribute(TEXT("filename"), fullpath);
3458  	(historyNode->ToElement())->InsertEndChild(recentFileNode);
3459  	return true;
3460  }
3461  TiXmlNode * NppParameters::getChildElementByAttribut(TiXmlNode *pere, const TCHAR *childName,\
3462  			const TCHAR *attributName, const TCHAR *attributVal) const
3463  {
3464  	for (TiXmlNode *childNode = pere->FirstChildElement(childName);
3465  		childNode ;
3466  		childNode = childNode->NextSibling(childName))
3467  	{
3468  		TiXmlElement *element = childNode->ToElement();
3469  		const TCHAR *val = element->Attribute(attributName);
3470  		if (val)
3471  		{
3472  			if (!lstrcmp(val, attributVal))
3473  				return childNode;
3474  		}
3475  	}
3476  	return NULL;
3477  }
3478  LangType NppParameters::getLangIDFromStr(const TCHAR *langName)
3479  {
3480  	int lang = static_cast<int32_t>(L_TEXT);
3481  	for (; lang < L_EXTERNAL; ++lang)
3482  	{
3483  		const TCHAR * name = ScintillaEditView::_langNameInfoArray[lang]._langName;
3484  		if (!lstrcmp(name, langName)) 
3485  		{
3486  			return (LangType)lang;
3487  		}
3488  	}
3489  	LangType l = (LangType)lang;
3490  	if (l == L_EXTERNAL) 
3491  	{
3492  		int id = NppParameters::getInstance().getExternalLangIndexFromName(langName);
3493  		if (id != -1) return (LangType)(id + L_EXTERNAL);
3494  	}
3495  	return L_TEXT;
3496  }
3497  generic_string NppParameters::getLocPathFromStr(const generic_string & localizationCode)
3498  {
3499  	if (localizationCode == TEXT("en") || localizationCode == TEXT("en-au") || localizationCode == TEXT("en-bz") || localizationCode == TEXT("en-ca") || localizationCode == TEXT("en-cb") || localizationCode == TEXT("en-gb") || localizationCode == TEXT("en-ie") || localizationCode == TEXT("en-jm") || localizationCode == TEXT("en-nz") || localizationCode == TEXT("en-ph") || localizationCode == TEXT("en-tt") || localizationCode == TEXT("en-us") || localizationCode == TEXT("en-za") || localizationCode == TEXT("en-zw"))
3500  		return TEXT("english.xml");
3501  	if (localizationCode == TEXT("af"))
3502  		return TEXT("afrikaans.xml");
3503  	if (localizationCode == TEXT("sq"))
3504  		return TEXT("albanian.xml");
3505  	if (localizationCode == TEXT("ar") || localizationCode == TEXT("ar-dz") || localizationCode == TEXT("ar-bh") || localizationCode == TEXT("ar-eg") ||localizationCode == TEXT("ar-iq") || localizationCode == TEXT("ar-jo") || localizationCode == TEXT("ar-kw") || localizationCode == TEXT("ar-lb") || localizationCode == TEXT("ar-ly") || localizationCode == TEXT("ar-ma") || localizationCode == TEXT("ar-om") || localizationCode == TEXT("ar-qa") || localizationCode == TEXT("ar-sa") || localizationCode == TEXT("ar-sy") || localizationCode == TEXT("ar-tn") || localizationCode == TEXT("ar-ae") || localizationCode == TEXT("ar-ye"))
3506  		return TEXT("arabic.xml");
3507  	if (localizationCode == TEXT("an"))
3508  		return TEXT("aragonese.xml");
3509  	if (localizationCode == TEXT("az"))
3510  		return TEXT("azerbaijani.xml");
3511  	if (localizationCode == TEXT("eu"))
3512  		return TEXT("basque.xml");
3513  	if (localizationCode == TEXT("be"))
3514  		return TEXT("belarusian.xml");
3515  	if (localizationCode == TEXT("bn"))
3516  		return TEXT("bengali.xml");
3517  	if (localizationCode == TEXT("bs"))
3518  		return TEXT("bosnian.xml");
3519  	if (localizationCode == TEXT("pt-br"))
3520  		return TEXT("brazilian_portuguese.xml");
3521  	if (localizationCode == TEXT("br-fr"))
3522  		return TEXT("breton.xml");
3523  	if (localizationCode == TEXT("bg"))
3524  		return TEXT("bulgarian.xml");
3525  	if (localizationCode == TEXT("ca"))
3526  		return TEXT("catalan.xml");
3527  	if (localizationCode == TEXT("zh-tw") || localizationCode == TEXT("zh-hk") || localizationCode == TEXT("zh-sg"))
3528  		return TEXT("taiwaneseMandarin.xml");
3529  	if (localizationCode == TEXT("zh") || localizationCode == TEXT("zh-cn"))
3530  		return TEXT("chineseSimplified.xml");
3531  	if (localizationCode == TEXT("co") || localizationCode == TEXT("co-fr"))
3532  		return TEXT("corsican.xml");
3533  	if (localizationCode == TEXT("hr"))
3534  		return TEXT("croatian.xml");
3535  	if (localizationCode == TEXT("cs"))
3536  		return TEXT("czech.xml");
3537  	if (localizationCode == TEXT("da"))
3538  		return TEXT("danish.xml");
3539  	if (localizationCode == TEXT("nl") || localizationCode == TEXT("nl-be"))
3540  		return TEXT("dutch.xml");
3541  	if (localizationCode == TEXT("eo"))
3542  		return TEXT("esperanto.xml");
3543  	if (localizationCode == TEXT("et"))
3544  		return TEXT("estonian.xml");
3545  	if (localizationCode == TEXT("fa"))
3546  		return TEXT("farsi.xml");
3547  	if (localizationCode == TEXT("fi"))
3548  		return TEXT("finnish.xml");
3549  	if (localizationCode == TEXT("fr") || localizationCode == TEXT("fr-be") || localizationCode == TEXT("fr-ca") || localizationCode == TEXT("fr-fr") || localizationCode == TEXT("fr-lu") || localizationCode == TEXT("fr-mc") || localizationCode == TEXT("fr-ch"))
3550  		return TEXT("french.xml");
3551  	if (localizationCode == TEXT("fur"))
3552  		return TEXT("friulian.xml");
3553  	if (localizationCode == TEXT("gl"))
3554  		return TEXT("galician.xml");
3555  	if (localizationCode == TEXT("ka"))
3556  		return TEXT("georgian.xml");
3557  	if (localizationCode == TEXT("de") || localizationCode == TEXT("de-at") || localizationCode == TEXT("de-de") || localizationCode == TEXT("de-li") || localizationCode == TEXT("de-lu") || localizationCode == TEXT("de-ch"))
3558  		return TEXT("german.xml");
3559  	if (localizationCode == TEXT("el"))
3560  		return TEXT("greek.xml");
3561  	if (localizationCode == TEXT("gu"))
3562  		return TEXT("gujarati.xml");
3563  	if (localizationCode == TEXT("he"))
3564  		return TEXT("hebrew.xml");
3565  	if (localizationCode == TEXT("hi"))
3566  		return TEXT("hindi.xml");
3567  	if (localizationCode == TEXT("hu"))
3568  		return TEXT("hungarian.xml");
3569  	if (localizationCode == TEXT("id"))
3570  		return TEXT("indonesian.xml");
3571  	if (localizationCode == TEXT("it") || localizationCode == TEXT("it-ch"))
3572  		return TEXT("italian.xml");
3573  	if (localizationCode == TEXT("ja"))
3574  		return TEXT("japanese.xml");
3575  	if (localizationCode == TEXT("kn"))
3576  		return TEXT("kannada.xml");
3577  	if (localizationCode == TEXT("kk"))
3578  		return TEXT("kazakh.xml");
3579  	if (localizationCode == TEXT("ko") || localizationCode == TEXT("ko-kp") || localizationCode == TEXT("ko-kr"))
3580  		return TEXT("korean.xml");
3581  	if (localizationCode == TEXT("ku"))
3582  		return TEXT("kurdish.xml");
3583  	if (localizationCode == TEXT("ky"))
3584  		return TEXT("kyrgyz.xml");
3585  	if (localizationCode == TEXT("lv"))
3586  		return TEXT("latvian.xml");
3587  	if (localizationCode == TEXT("lt"))
3588  		return TEXT("lithuanian.xml");
3589  	if (localizationCode == TEXT("lb"))
3590  		return TEXT("luxembourgish.xml");
3591  	if (localizationCode == TEXT("mk"))
3592  		return TEXT("macedonian.xml");
3593  	if (localizationCode == TEXT("ms"))
3594  		return TEXT("malay.xml");
3595  	if (localizationCode == TEXT("mr"))
3596  		return TEXT("marathi.xml");
3597  	if (localizationCode == TEXT("mn"))
3598  		return TEXT("mongolian.xml");
3599  	if (localizationCode == TEXT("no") || localizationCode == TEXT("nb"))
3600  		return TEXT("norwegian.xml");
3601  	if (localizationCode == TEXT("nn"))
3602  		return TEXT("nynorsk.xml");
3603  	if (localizationCode == TEXT("oc"))
3604  		return TEXT("occitan.xml");
3605  	if (localizationCode == TEXT("pl"))
3606  		return TEXT("polish.xml");
3607  	if (localizationCode == TEXT("pt") || localizationCode == TEXT("pt-pt"))
3608  		return TEXT("portuguese.xml");
3609  	if (localizationCode == TEXT("pa") || localizationCode == TEXT("pa-in"))
3610  		return TEXT("punjabi.xml");
3611  	if (localizationCode == TEXT("ro") || localizationCode == TEXT("ro-mo"))
3612  		return TEXT("romanian.xml");
3613  	if (localizationCode == TEXT("ru") || localizationCode == TEXT("ru-mo"))
3614  		return TEXT("russian.xml");
3615  	if (localizationCode == TEXT("sc"))
3616  		return TEXT("sardinian.xml");
3617  	if (localizationCode == TEXT("sr"))
3618  		return TEXT("serbian.xml");
3619  	if (localizationCode == TEXT("sr-cyrl-ba") || localizationCode == TEXT("sr-cyrl-sp"))
3620  		return TEXT("serbianCyrillic.xml");
3621  	if (localizationCode == TEXT("si"))
3622  		return TEXT("sinhala.xml");
3623  	if (localizationCode == TEXT("sk"))
3624  		return TEXT("slovak.xml");
3625  	if (localizationCode == TEXT("sl"))
3626  		return TEXT("slovenian.xml");
3627  	if (localizationCode == TEXT("es") || localizationCode == TEXT("es-bo") || localizationCode == TEXT("es-cl") || localizationCode == TEXT("es-co") || localizationCode == TEXT("es-cr") || localizationCode == TEXT("es-do") || localizationCode == TEXT("es-ec") || localizationCode == TEXT("es-sv") || localizationCode == TEXT("es-gt") || localizationCode == TEXT("es-hn") || localizationCode == TEXT("es-mx") || localizationCode == TEXT("es-ni") || localizationCode == TEXT("es-pa") || localizationCode == TEXT("es-py") || localizationCode == TEXT("es-pe") || localizationCode == TEXT("es-pr") || localizationCode == TEXT("es-es") || localizationCode == TEXT("es-uy") || localizationCode == TEXT("es-ve"))
3628  		return TEXT("spanish.xml");
3629  	if (localizationCode == TEXT("es-ar"))
3630  		return TEXT("spanish_ar.xml");
3631  	if (localizationCode == TEXT("sv"))
3632  		return TEXT("swedish.xml");
3633  	if (localizationCode == TEXT("tl"))
3634  		return TEXT("tagalog.xml");
3635  	if (localizationCode == TEXT("tg-cyrl-tj"))
3636  		return TEXT("tajikCyrillic.xml");
3637  	if (localizationCode == TEXT("ta"))
3638  		return TEXT("tamil.xml");
3639  	if (localizationCode == TEXT("tt"))
3640  		return TEXT("tatar.xml");
3641  	if (localizationCode == TEXT("te"))
3642  		return TEXT("telugu.xml");
3643  	if (localizationCode == TEXT("th"))
3644  		return TEXT("thai.xml");
3645  	if (localizationCode == TEXT("tr"))
3646  		return TEXT("turkish.xml");
3647  	if (localizationCode == TEXT("uk"))
3648  		return TEXT("ukrainian.xml");
3649  	if (localizationCode == TEXT("ur") || localizationCode == TEXT("ur-pk"))
3650  		return TEXT("urdu.xml");
3651  	if (localizationCode == TEXT("ug-cn"))
3652  		return TEXT("uyghur.xml");
3653  	if (localizationCode == TEXT("uz"))
3654  		return TEXT("uzbek.xml");
3655  	if (localizationCode == TEXT("uz-cyrl-uz"))
3656  		return TEXT("uzbekCyrillic.xml");
3657  	if (localizationCode == TEXT("vec"))
3658  		return TEXT("venetian.xml");
3659  	if (localizationCode == TEXT("vi") || localizationCode == TEXT("vi-vn"))
3660  		return TEXT("vietnamese.xml");
3661  	if (localizationCode == TEXT("cy-gb"))
3662  		return TEXT("welsh.xml");
3663  	if (localizationCode == TEXT("zu") || localizationCode == TEXT("zu-za"))
3664  		return TEXT("zulu.xml");
3665  	if (localizationCode == TEXT("ne") || localizationCode == TEXT("nep"))
3666  		return TEXT("nepali.xml");
3667  	if (localizationCode == TEXT("oc-aranes"))
3668  		return TEXT("aranese.xml");
3669  	if (localizationCode == TEXT("exy"))
3670  		return TEXT("extremaduran.xml");
3671  	if (localizationCode == TEXT("keb"))
3672  		return TEXT("kabyle.xml");
3673  	if (localizationCode == TEXT("lij"))
3674  		return TEXT("ligurian.xml");
3675  	if (localizationCode == TEXT("ga"))
3676  		return TEXT("irish.xml");
3677  	if (localizationCode == TEXT("sgs"))
3678  		return TEXT("samogitian.xml");
3679  	if (localizationCode == TEXT("yue"))
3680  		return TEXT("hongKongCantonese.xml");
3681  	if (localizationCode == TEXT("ab") || localizationCode == TEXT("abk"))
3682  		return TEXT("abkhazian.xml");
3683  	return generic_string();
3684  }
3685  void NppParameters::feedKeyWordsParameters(TiXmlNode *node)
3686  {
3687  	TiXmlNode *langRoot = node->FirstChildElement(TEXT("Languages"));
3688  	if (!langRoot)
3689  		return;
3690  	for (TiXmlNode *langNode = langRoot->FirstChildElement(TEXT("Language"));
3691  		langNode ;
3692  		langNode = langNode->NextSibling(TEXT("Language")) )
3693  	{
3694  		if (_nbLang < NB_LANG)
3695  		{
3696  			TiXmlElement* element = langNode->ToElement();
3697  			const TCHAR* name = element->Attribute(TEXT("name"));
3698  			if (name)
3699  			{
3700  				_langList[_nbLang] = new Lang(getLangIDFromStr(name), name);
3701  				_langList[_nbLang]->setDefaultExtList(element->Attribute(TEXT("ext")));
3702  				_langList[_nbLang]->setCommentLineSymbol(element->Attribute(TEXT("commentLine")));
3703  				_langList[_nbLang]->setCommentStart(element->Attribute(TEXT("commentStart")));
3704  				_langList[_nbLang]->setCommentEnd(element->Attribute(TEXT("commentEnd")));
3705  				int tabSettings;
3706  				if (element->Attribute(TEXT("tabSettings"), &tabSettings))
3707  					_langList[_nbLang]->setTabInfo(tabSettings);
3708  				for (TiXmlNode *kwNode = langNode->FirstChildElement(TEXT("Keywords"));
3709  					kwNode ;
3710  					kwNode = kwNode->NextSibling(TEXT("Keywords")) )
3711  				{
3712  					const TCHAR *indexName = (kwNode->ToElement())->Attribute(TEXT("name"));
3713  					TiXmlNode *kwVal = kwNode->FirstChild();
3714  					const TCHAR *keyWords = TEXT("");
3715  					if ((indexName) && (kwVal))
3716  						keyWords = kwVal->Value();
3717  					int i = getKwClassFromName(indexName);
3718  					if (i >= 0 && i <= KEYWORDSET_MAX)
3719  						_langList[_nbLang]->setWords(keyWords, i);
3720  				}
3721  				++_nbLang;
3722  			}
3723  		}
3724  	}
3725  }
3726  extern "C" {
3727  typedef DWORD (WINAPI * EESFUNC) (LPCTSTR, LPTSTR, DWORD);
3728  }
3729  void NppParameters::feedGUIParameters(TiXmlNode *node)
3730  {
3731  	TiXmlNode *GUIRoot = node->FirstChildElement(TEXT("GUIConfigs"));
3732  	if (nullptr == GUIRoot)
3733  		return;
3734  	for (TiXmlNode *childNode = GUIRoot->FirstChildElement(TEXT("GUIConfig"));
3735  		childNode ;
3736  		childNode = childNode->NextSibling(TEXT("GUIConfig")) )
3737  	{
3738  		TiXmlElement* element = childNode->ToElement();
3739  		const TCHAR* nm = element->Attribute(TEXT("name"));
3740  		if (nullptr == nm)
3741  			continue;
3742  		auto parseYesNoBoolAttribute = [&element](const TCHAR* name, bool defaultValue = false) -> bool {
3743  			const TCHAR* val = element->Attribute(name);
3744  			if (val != nullptr)
3745  			{
3746  				if (!lstrcmp(val, TEXT("yes")))
3747  					return true;
3748  				else if (!lstrcmp(val, TEXT("no")))
3749  					return false;
3750  			}
3751  			return defaultValue;
3752  		};
3753  		if (!lstrcmp(nm, TEXT("ToolBar")))
3754  		{
3755  			const TCHAR* val = element->Attribute(TEXT("visible"));
3756  			if (val)
3757  			{
3758  				if (!lstrcmp(val, TEXT("no")))
3759  					_nppGUI._toolbarShow = false;
3760  				else
3761  					_nppGUI._toolbarShow = true;
3762  			}
3763  			TiXmlNode *n = childNode->FirstChild();
3764  			if (n)
3765  			{
3766  				val = n->Value();
3767  				if (val)
3768  				{
3769  					if (!lstrcmp(val, TEXT("small")))
3770  						_nppGUI._toolBarStatus = TB_SMALL;
3771  					else if (!lstrcmp(val, TEXT("large")))
3772  						_nppGUI._toolBarStatus = TB_LARGE;
3773  					else if (!lstrcmp(val, TEXT("small2")))
3774  						_nppGUI._toolBarStatus = TB_SMALL2;
3775  					else if (!lstrcmp(val, TEXT("large2")))
3776  						_nppGUI._toolBarStatus = TB_LARGE2;
3777  					else 
3778  						_nppGUI._toolBarStatus = TB_STANDARD;
3779  				}
3780  			}
3781  		}
3782  		else if (!lstrcmp(nm, TEXT("StatusBar")))
3783  		{
3784  			TiXmlNode *n = childNode->FirstChild();
3785  			if (n)
3786  			{
3787  				const TCHAR* val = n->Value();
3788  				if (val)
3789  				{
3790  					if (!lstrcmp(val, TEXT("hide")))
3791  						_nppGUI._statusBarShow = false;
3792  					else if (!lstrcmp(val, TEXT("show")))
3793  						_nppGUI._statusBarShow = true;
3794  				}
3795  			}
3796  		}
3797  		else if (!lstrcmp(nm, TEXT("MenuBar")))
3798  		{
3799  			TiXmlNode *n = childNode->FirstChild();
3800  			if (n)
3801  			{
3802  				const TCHAR* val = n->Value();
3803  				if (val)
3804  				{
3805  					if (!lstrcmp(val, TEXT("hide")))
3806  						_nppGUI._menuBarShow = false;
3807  					else if (!lstrcmp(val, TEXT("show")))
3808  						_nppGUI._menuBarShow = true;
3809  				}
3810  			}
3811  		}
3812  		else if (!lstrcmp(nm, TEXT("TabBar")))
3813  		{
3814  			bool isFailed = false;
3815  			int oldValue = _nppGUI._tabStatus;
3816  			const TCHAR* val = element->Attribute(TEXT("dragAndDrop"));
3817  			if (val)
3818  			{
3819  				if (!lstrcmp(val, TEXT("yes")))
3820  					_nppGUI._tabStatus = TAB_DRAGNDROP;
3821  				else if (!lstrcmp(val, TEXT("no")))
3822  					_nppGUI._tabStatus = 0;
3823  				else
3824  					isFailed = true;
3825  			}
3826  			val = element->Attribute(TEXT("drawTopBar"));
3827  			if (val)
3828  			{
3829  				if (!lstrcmp(val, TEXT("yes")))
3830  					_nppGUI._tabStatus |= TAB_DRAWTOPBAR;
3831  				else if (!lstrcmp(val, TEXT("no")))
3832  					_nppGUI._tabStatus |= 0;
3833  				else
3834  					isFailed = true;
3835  			}
3836  			val = element->Attribute(TEXT("drawInactiveTab"));
3837  			if (val)
3838  			{
3839  				if (!lstrcmp(val, TEXT("yes")))
3840  					_nppGUI._tabStatus |= TAB_DRAWINACTIVETAB;
3841  				else if (!lstrcmp(val, TEXT("no")))
3842  					_nppGUI._tabStatus |= 0;
3843  				else
3844  					isFailed = true;
3845  			}
3846  			val = element->Attribute(TEXT("reduce"));
3847  			if (val)
3848  			{
3849  				if (!lstrcmp(val, TEXT("yes")))
3850  					_nppGUI._tabStatus |= TAB_REDUCE;
3851  				else if (!lstrcmp(val, TEXT("no")))
3852  					_nppGUI._tabStatus |= 0;
3853  				else
3854  					isFailed = true;
3855  			}
3856  			val = element->Attribute(TEXT("closeButton"));
3857  			if (val)
3858  			{
3859  				if (!lstrcmp(val, TEXT("yes")))
3860  					_nppGUI._tabStatus |= TAB_CLOSEBUTTON;
3861  				else if (!lstrcmp(val, TEXT("no")))
3862  					_nppGUI._tabStatus |= 0;
3863  				else
3864  					isFailed = true;
3865  			}
3866  			val = element->Attribute(TEXT("doubleClick2Close"));
3867  			if (val)
3868  			{
3869  				if (!lstrcmp(val, TEXT("yes")))
3870  					_nppGUI._tabStatus |= TAB_DBCLK2CLOSE;
3871  				else if (!lstrcmp(val, TEXT("no")))
3872  					_nppGUI._tabStatus |= 0;
3873  				else
3874  					isFailed = true;
3875  			}
3876  			val = element->Attribute(TEXT("vertical"));
3877  			if (val)
3878  			{
3879  				if (!lstrcmp(val, TEXT("yes")))
3880  					_nppGUI._tabStatus |= TAB_VERTICAL;
3881  				else if (!lstrcmp(val, TEXT("no")))
3882  					_nppGUI._tabStatus |= 0;
3883  				else
3884  					isFailed = true;
3885  			}
3886  			val = element->Attribute(TEXT("multiLine"));
3887  			if (val)
3888  			{
3889  				if (!lstrcmp(val, TEXT("yes")))
3890  					_nppGUI._tabStatus |= TAB_MULTILINE;
3891  				else if (!lstrcmp(val, TEXT("no")))
3892  					_nppGUI._tabStatus |= 0;
3893  				else
3894  					isFailed = true;
3895  			}
3896  			val = element->Attribute(TEXT("hide"));
3897  			if (val)
3898  			{
3899  				if (!lstrcmp(val, TEXT("yes")))
3900  					_nppGUI._tabStatus |= TAB_HIDE;
3901  				else if (!lstrcmp(val, TEXT("no")))
3902  					_nppGUI._tabStatus |= 0;
3903  				else
3904  					isFailed = true;
3905  			}
3906  			val = element->Attribute(TEXT("quitOnEmpty"));
3907  			if (val)
3908  			{
3909  				if (!lstrcmp(val, TEXT("yes")))
3910  					_nppGUI._tabStatus |= TAB_QUITONEMPTY;
3911  				else if (!lstrcmp(val, TEXT("no")))
3912  					_nppGUI._tabStatus |= 0;
3913  				else
3914  					isFailed = true;
3915  			}
3916  			val = element->Attribute(TEXT("iconSetNumber"));
3917  			if (val)
3918  			{
3919  				if (!lstrcmp(val, TEXT("1")))
3920  					_nppGUI._tabStatus |= TAB_ALTICONS;
3921  				else if (!lstrcmp(val, TEXT("0")))
3922  					_nppGUI._tabStatus |= 0;
3923  				else
3924  					isFailed = true;
3925  			}
3926  			if (isFailed)
3927  				_nppGUI._tabStatus = oldValue;
3928  		}
3929  		else if (!lstrcmp(nm, TEXT("Auto-detection")))
3930  		{
3931  			TiXmlNode *n = childNode->FirstChild();
3932  			if (n)
3933  			{
3934  				const TCHAR* val = n->Value();
3935  				if (val)
3936  				{
3937  					if (!lstrcmp(val, TEXT("yesOld")))
3938  						_nppGUI._fileAutoDetection = cdEnabledOld;
3939  					else if (!lstrcmp(val, TEXT("autoOld")))
3940  						_nppGUI._fileAutoDetection = (cdEnabledOld | cdAutoUpdate);
3941  					else if (!lstrcmp(val, TEXT("Update2EndOld")))
3942  						_nppGUI._fileAutoDetection = (cdEnabledOld | cdGo2end);
3943  					else if (!lstrcmp(val, TEXT("autoUpdate2EndOld")))
3944  						_nppGUI._fileAutoDetection = (cdEnabledOld | cdAutoUpdate | cdGo2end);
3945  					else if (!lstrcmp(val, TEXT("yes")))
3946  						_nppGUI._fileAutoDetection = cdEnabledNew;
3947  					else if (!lstrcmp(val, TEXT("auto")))
3948  						_nppGUI._fileAutoDetection = (cdEnabledNew | cdAutoUpdate);
3949  					else if (!lstrcmp(val, TEXT("Update2End")))
3950  						_nppGUI._fileAutoDetection = (cdEnabledNew | cdGo2end);
3951  					else if (!lstrcmp(val, TEXT("autoUpdate2End")))
3952  						_nppGUI._fileAutoDetection = (cdEnabledNew | cdAutoUpdate | cdGo2end);
3953  					else 
3954  						_nppGUI._fileAutoDetection = cdDisabled;
3955  				}
3956  			}
3957  		}
3958  		else if (!lstrcmp(nm, TEXT("TrayIcon")))
3959  		{
3960  			TiXmlNode *n = childNode->FirstChild();
3961  			if (n)
3962  			{
3963  				const TCHAR* val = n->Value();
3964  				if (val)
3965  				{
3966  					_nppGUI._isMinimizedToTray = (lstrcmp(val, TEXT("yes")) == 0);
3967  				}
3968  			}
3969  		}
3970  		else if (!lstrcmp(nm, TEXT("RememberLastSession")))
3971  		{
3972  			TiXmlNode *n = childNode->FirstChild();
3973  			if (n)
3974  			{
3975  				const TCHAR* val = n->Value();
3976  				if (val)
3977  				{
3978  					if (lstrcmp(val, TEXT("yes")) == 0)
3979  						_nppGUI._rememberLastSession = true;
3980  					else
3981  						_nppGUI._rememberLastSession = false;
3982  				}
3983  			}
3984  		}
3985  		else if (!lstrcmp(nm, TEXT("DetectEncoding")))
3986  		{
3987  			TiXmlNode *n = childNode->FirstChild();
3988  			if (n)
3989  			{
3990  				const TCHAR* val = n->Value();
3991  				if (val)
3992  				{
3993  					if (lstrcmp(val, TEXT("yes")) == 0)
3994  						_nppGUI._detectEncoding = true;
3995  					else
3996  						_nppGUI._detectEncoding = false;
3997  				}
3998  			}
3999  		}
4000  		else if (!lstrcmp(nm, TEXT("SaveAllConfirm")))
4001  		{
4002  			TiXmlNode *n = childNode->FirstChild();
4003  			if (n)
4004  			{
4005  				const TCHAR* val = n->Value();
4006  				if (val)
4007  				{
4008  					if (lstrcmp(val, TEXT("yes")) == 0)
4009  						_nppGUI._saveAllConfirm = true;
4010  					else
4011  						_nppGUI._saveAllConfirm = false;
4012  				}
4013  			}
4014  		}
4015  		else if (lstrcmp(nm, TEXT("MaitainIndent")) == 0)
4016  		{
4017  			TiXmlNode *n = childNode->FirstChild();
4018  			if (n)
4019  			{
4020  				const TCHAR* val = n->Value();
4021  				if (val)
4022  				{
4023  					if (lstrcmp(val, TEXT("yes")) == 0)
4024  						_nppGUI._maitainIndent = true;
4025  					else
4026  						_nppGUI._maitainIndent = false;
4027  				}
4028  			}
4029  		}
4030  		else if (!lstrcmp(nm, TEXT("MarkAll")))
4031  		{
4032  			const TCHAR* val = element->Attribute(TEXT("matchCase"));
4033  			if (val)
4034  			{
4035  				if (lstrcmp(val, TEXT("yes")) == 0)
4036  					_nppGUI._markAllCaseSensitive = true;
4037  				else if (!lstrcmp(val, TEXT("no")))
4038  					_nppGUI._markAllCaseSensitive = false;
4039  			}
4040  			val = element->Attribute(TEXT("wholeWordOnly"));
4041  			if (val)
4042  			{
4043  				if (lstrcmp(val, TEXT("yes")) == 0)
4044  					_nppGUI._markAllWordOnly = true;
4045  				else if (!lstrcmp(val, TEXT("no")))
4046  					_nppGUI._markAllWordOnly = false;
4047  			}
4048  		}
4049  		else if (!lstrcmp(nm, TEXT("SmartHighLight")))
4050  		{
4051  			TiXmlNode *n = childNode->FirstChild();
4052  			if (n)
4053  			{
4054  				const TCHAR* val = n->Value();
4055  				if (val)
4056  				{
4057  					if (lstrcmp(val, TEXT("yes")) == 0)
4058  						_nppGUI._enableSmartHilite = true;
4059  					else
4060  						_nppGUI._enableSmartHilite = false;
4061  				}
4062  				val = element->Attribute(TEXT("matchCase"));
4063  				if (val)
4064  				{
4065  					if (lstrcmp(val, TEXT("yes")) == 0)
4066  						_nppGUI._smartHiliteCaseSensitive = true;
4067  					else if (!lstrcmp(val, TEXT("no")))
4068  						_nppGUI._smartHiliteCaseSensitive = false;
4069  				}
4070  				val = element->Attribute(TEXT("wholeWordOnly"));
4071  				if (val)
4072  				{
4073  					if (lstrcmp(val, TEXT("yes")) == 0)
4074  						_nppGUI._smartHiliteWordOnly = true;
4075  					else if (!lstrcmp(val, TEXT("no")))
4076  						_nppGUI._smartHiliteWordOnly = false;
4077  				}
4078  				val = element->Attribute(TEXT("useFindSettings"));
4079  				if (val)
4080  				{
4081  					if (lstrcmp(val, TEXT("yes")) == 0)
4082  						_nppGUI._smartHiliteUseFindSettings = true;
4083  					else if (!lstrcmp(val, TEXT("no")))
4084  						_nppGUI._smartHiliteUseFindSettings = false;
4085  				}
4086  				val = element->Attribute(TEXT("onAnotherView"));
4087  				if (val)
4088  				{
4089  					if (lstrcmp(val, TEXT("yes")) == 0)
4090  						_nppGUI._smartHiliteOnAnotherView = true;
4091  					else if (!lstrcmp(val, TEXT("no")))
4092  						_nppGUI._smartHiliteOnAnotherView = false;
4093  				}
4094  			}
4095  		}
4096  		else if (!lstrcmp(nm, TEXT("TagsMatchHighLight")))
4097  		{
4098  			TiXmlNode *n = childNode->FirstChild();
4099  			if (n)
4100  			{
4101  				const TCHAR* val = n->Value();
4102  				if (val)
4103  				{
4104  					_nppGUI._enableTagsMatchHilite = !lstrcmp(val, TEXT("yes"));
4105  					const TCHAR *tahl = element->Attribute(TEXT("TagAttrHighLight"));
4106  					if (tahl)
4107  						_nppGUI._enableTagAttrsHilite = !lstrcmp(tahl, TEXT("yes"));
4108  					tahl = element->Attribute(TEXT("HighLightNonHtmlZone"));
4109  					if (tahl)
4110  						_nppGUI._enableHiliteNonHTMLZone = !lstrcmp(tahl, TEXT("yes"));
4111  				}
4112  			}
4113  		}
4114  		else if (!lstrcmp(nm, TEXT("TaskList")))
4115  		{
4116  			TiXmlNode *n = childNode->FirstChild();
4117  			if (n)
4118  			{
4119  				const TCHAR* val = n->Value();
4120  				if (val)
4121  				{
4122  					_nppGUI._doTaskList = (!lstrcmp(val, TEXT("yes")))?true:false;
4123  				}
4124  			}
4125  		}
4126  		else if (!lstrcmp(nm, TEXT("MRU")))
4127  		{
4128  			TiXmlNode *n = childNode->FirstChild();
4129  			if (n)
4130  			{
4131  				const TCHAR* val = n->Value();
4132  				if (val)
4133  					_nppGUI._styleMRU = (!lstrcmp(val, TEXT("yes")));
4134  			}
4135  		}
4136  		else if (!lstrcmp(nm, TEXT("URL")))
4137  		{
4138  			TiXmlNode *n = childNode->FirstChild();
4139  			if (n)
4140  			{
4141  				const TCHAR* val = n->Value();
4142  				if (val)
4143  				{
4144  					int const i = _wtoi (val);
4145  					if ((i >= urlMin) && (i <= urlMax))
4146  						_nppGUI._styleURL = urlMode(i);
4147  				}
4148  			}
4149  		}
4150  		else if (!lstrcmp(nm, TEXT("uriCustomizedSchemes")))
4151  		{
4152  			TiXmlNode *n = childNode->FirstChild();
4153  			if (n)
4154  			{
4155  				const TCHAR* val = n->Value();
4156  				if (val)
4157  				_nppGUI._uriSchemes = val;
4158  			}
4159  		}
4160  		else if (!lstrcmp(nm, TEXT("CheckHistoryFiles")))
4161  		{
4162  			TiXmlNode *n = childNode->FirstChild();
4163  			if (n)
4164  			{
4165  				const TCHAR* val = n->Value();
4166  				if (val)
4167  				{
4168  					if (!lstrcmp(val, TEXT("no")))
4169  						_nppGUI._checkHistoryFiles = false;
4170  					else if (!lstrcmp(val, TEXT("yes")))
4171  						_nppGUI._checkHistoryFiles = true;
4172  				}
4173  			}
4174  		}
4175  		else if (!lstrcmp(nm, TEXT("ScintillaViewsSplitter")))
4176  		{
4177  			TiXmlNode *n = childNode->FirstChild();
4178  			if (n)
4179  			{
4180  				const TCHAR* val = n->Value();
4181  				if (val)
4182  				{
4183  					if (!lstrcmp(val, TEXT("vertical")))
4184  						_nppGUI._splitterPos = POS_VERTICAL;
4185  					else if (!lstrcmp(val, TEXT("horizontal")))
4186  						_nppGUI._splitterPos = POS_HORIZOTAL;
4187  				}
4188  			}
4189  		}
4190  		else if (!lstrcmp(nm, TEXT("UserDefineDlg")))
4191  		{
4192  			bool isFailed = false;
4193  			int oldValue = _nppGUI._userDefineDlgStatus;
4194  			TiXmlNode *n = childNode->FirstChild();
4195  			if (n)
4196  			{
4197  				const TCHAR* val = n->Value();
4198  				if (val)
4199  				{
4200  					if (!lstrcmp(val, TEXT("hide")))
4201  						_nppGUI._userDefineDlgStatus = 0;
4202  					else if (!lstrcmp(val, TEXT("show")))
4203  						_nppGUI._userDefineDlgStatus = UDD_SHOW;
4204  					else
4205  						isFailed = true;
4206  				}
4207  			}
4208  			const TCHAR* val = element->Attribute(TEXT("position"));
4209  			if (val)
4210  			{
4211  				if (!lstrcmp(val, TEXT("docked")))
4212  					_nppGUI._userDefineDlgStatus |= UDD_DOCKED;
4213  				else if (!lstrcmp(val, TEXT("undocked")))
4214  					_nppGUI._userDefineDlgStatus |= 0;
4215  				else
4216  					isFailed = true;
4217  			}
4218  			if (isFailed)
4219  				_nppGUI._userDefineDlgStatus = oldValue;
4220  		}
4221  		else if (!lstrcmp(nm, TEXT("TabSetting")))
4222  		{
4223  			int i;
4224  			const TCHAR* val = element->Attribute(TEXT("size"), &i);
4225  			if (val)
4226  				_nppGUI._tabSize = i;
4227  			if ((_nppGUI._tabSize == -1) || (_nppGUI._tabSize == 0))
4228  				_nppGUI._tabSize = 4;
4229  			val = element->Attribute(TEXT("replaceBySpace"));
4230  			if (val)
4231  				_nppGUI._tabReplacedBySpace = (!lstrcmp(val, TEXT("yes")));
4232  		}
4233  		else if (!lstrcmp(nm, TEXT("Caret")))
4234  		{
4235  			int i;
4236  			const TCHAR* val = element->Attribute(TEXT("width"), &i);
4237  			if (val)
4238  				_nppGUI._caretWidth = i;
4239  			val = element->Attribute(TEXT("blinkRate"), &i);
4240  			if (val)
4241  				_nppGUI._caretBlinkRate = i;
4242  		}
4243  		else if (!lstrcmp(nm, TEXT("ScintillaGlobalSettings")))
4244  		{
4245  			const TCHAR* val = element->Attribute(TEXT("enableMultiSelection"));
4246  			if (val)
4247  			{
4248  				if (lstrcmp(val, TEXT("yes")) == 0)
4249  					_nppGUI._enableMultiSelection = true;
4250  				else if (lstrcmp(val, TEXT("no")) == 0)
4251  					_nppGUI._enableMultiSelection = false;
4252  			}
4253  		}
4254  		else if (!lstrcmp(nm, TEXT("AppPosition")))
4255  		{
4256  			RECT oldRect = _nppGUI._appPos;
4257  			bool fuckUp = true;
4258  			int i;
4259  			if (element->Attribute(TEXT("x"), &i))
4260  			{
4261  				_nppGUI._appPos.left = i;
4262  				if (element->Attribute(TEXT("y"), &i))
4263  				{
4264  					_nppGUI._appPos.top = i;
4265  					if (element->Attribute(TEXT("width"), &i))
4266  					{
4267  						_nppGUI._appPos.right = i;
4268  						if (element->Attribute(TEXT("height"), &i))
4269  						{
4270  							_nppGUI._appPos.bottom = i;
4271  							fuckUp = false;
4272  						}
4273  					}
4274  				}
4275  			}
4276  			if (fuckUp)
4277  				_nppGUI._appPos = oldRect;
4278  			const TCHAR* val = element->Attribute(TEXT("isMaximized"));
4279  			if (val)
4280  				_nppGUI._isMaximized = (lstrcmp(val, TEXT("yes")) == 0);
4281  		}
4282  		else if (!lstrcmp(nm, TEXT("FindWindowPosition")))
4283  		{
4284  			RECT oldRect = _nppGUI._findWindowPos;
4285  			bool incomplete = true;
4286  			int i;
4287  			if (element->Attribute(TEXT("left"), &i))
4288  			{
4289  				_nppGUI._findWindowPos.left = i;
4290  				if (element->Attribute(TEXT("top"), &i))
4291  				{
4292  					_nppGUI._findWindowPos.top = i;
4293  					if (element->Attribute(TEXT("right"), &i))
4294  					{
4295  						_nppGUI._findWindowPos.right = i;
4296  						if (element->Attribute(TEXT("bottom"), &i))
4297  						{
4298  							_nppGUI._findWindowPos.bottom = i;
4299  							incomplete = false;
4300  						}
4301  					}
4302  				}
4303  			}
4304  			if (incomplete)
4305  			{
4306  				_nppGUI._findWindowPos = oldRect;
4307  			}
4308  			const TCHAR* val = element->Attribute(TEXT("isLessModeOn"));
4309  			if (val)
4310  				_nppGUI._findWindowLessMode = (lstrcmp(val, TEXT("yes")) == 0);
4311  		}
4312  		else if (!lstrcmp(nm, TEXT("FinderConfig")))
4313  		{
4314  			const TCHAR* val = element->Attribute(TEXT("wrappedLines"));
4315  			if (val)
4316  			{
4317  				_nppGUI._finderLinesAreCurrentlyWrapped = (!lstrcmp(val, TEXT("yes")));
4318  			}
4319  			val = element->Attribute(TEXT("purgeBeforeEverySearch"));
4320  			if (val)
4321  			{
4322  				_nppGUI._finderPurgeBeforeEverySearch = (!lstrcmp(val, TEXT("yes")));
4323  			}
4324  			val = element->Attribute(TEXT("showOnlyOneEntryPerFoundLine"));
4325  			if (val)
4326  			{
4327  				_nppGUI._finderShowOnlyOneEntryPerFoundLine = (!lstrcmp(val, TEXT("yes")));
4328  			}
4329  		}
4330  		else if (!lstrcmp(nm, TEXT("NewDocDefaultSettings")))
4331  		{
4332  			int i;
4333  			if (element->Attribute(TEXT("format"), &i))
4334  			{
4335  				EolType newFormat = EolType::osdefault;
4336  				switch (i)
4337  				{
4338  					case static_cast<LPARAM>(EolType::windows) :
4339  						newFormat = EolType::windows;
4340  						break;
4341  					case static_cast<LPARAM>(EolType::macos) :
4342  						newFormat = EolType::macos;
4343  						break;
4344  					case static_cast<LPARAM>(EolType::unix) :
4345  						newFormat = EolType::unix;
4346  						break;
4347  					default:
4348  						assert(false and "invalid buffer format - fallback to default");
4349  				}
4350  				_nppGUI._newDocDefaultSettings._format = newFormat;
4351  			}
4352  			if (element->Attribute(TEXT("encoding"), &i))
4353  				_nppGUI._newDocDefaultSettings._unicodeMode = (UniMode)i;
4354  			if (element->Attribute(TEXT("lang"), &i))
4355  				_nppGUI._newDocDefaultSettings._lang = (LangType)i;
4356  			if (element->Attribute(TEXT("codepage"), &i))
4357  				_nppGUI._newDocDefaultSettings._codepage = (LangType)i;
4358  			const TCHAR* val = element->Attribute(TEXT("openAnsiAsUTF8"));
4359  			if (val)
4360  				_nppGUI._newDocDefaultSettings._openAnsiAsUtf8 = (lstrcmp(val, TEXT("yes")) == 0);
4361  		}
4362  		else if (!lstrcmp(nm, TEXT("langsExcluded")))
4363  		{
4364  			int g0 = 0; 
4365  			int g1 = 0; 
4366  			int g2 = 0; 
4367  			int g3 = 0; 
4368  			int g4 = 0; 
4369  			int g5 = 0; 
4370  			int g6 = 0; 
4371  			int g7 = 0; 
4372  			int g8 = 0; 
4373  			int g9 = 0; 
4374  			int g10= 0; 
4375  			int g11= 0; 
4376  			int g12= 0; 
4377  			{
4378  				int i;
4379  				if (element->Attribute(TEXT("gr0"), &i))
4380  				{
4381  					if (i <= 255)
4382  						g0 = i;
4383  				}
4384  				if (element->Attribute(TEXT("gr1"), &i))
4385  				{
4386  					if (i <= 255)
4387  						g1 = i;
4388  				}
4389  				if (element->Attribute(TEXT("gr2"), &i))
4390  				{
4391  					if (i <= 255)
4392  						g2 = i;
4393  				}
4394  				if (element->Attribute(TEXT("gr3"), &i))
4395  				{
4396  					if (i <= 255)
4397  						g3 = i;
4398  				}
4399  				if (element->Attribute(TEXT("gr4"), &i))
4400  				{
4401  					if (i <= 255)
4402  						g4 = i;
4403  				}
4404  				if (element->Attribute(TEXT("gr5"), &i))
4405  				{
4406  					if (i <= 255)
4407  						g5 = i;
4408  				}
4409  				if (element->Attribute(TEXT("gr6"), &i))
4410  				{
4411  					if (i <= 255)
4412  						g6 = i;
4413  				}
4414  				if (element->Attribute(TEXT("gr7"), &i))
4415  				{
4416  					if (i <= 255)
4417  						g7 = i;
4418  				}
4419  				if (element->Attribute(TEXT("gr8"), &i))
4420  				{
4421  					if (i <= 255)
4422  						g8 = i;
4423  				}
4424  				if (element->Attribute(TEXT("gr9"), &i))
4425  				{
4426  					if (i <= 255)
4427  						g9 = i;
4428  				}
4429  				if (element->Attribute(TEXT("gr10"), &i))
4430  				{
4431  					if (i <= 255)
4432  						g10 = i;
4433  				}
4434  				if (element->Attribute(TEXT("gr11"), &i))
4435  				{
4436  					if (i <= 255)
4437  						g11 = i;
4438  				}
4439  				if (element->Attribute(TEXT("gr12"), &i))
4440  				{
4441  					if (i <= 255)
4442  						g12 = i;
4443  				}
4444  			}
4445  			UCHAR mask = 1;
4446  			for (int i = 0 ; i < 8 ; ++i)
4447  			{
4448  				if (mask & g0)
4449  					_nppGUI._excludedLangList.push_back(LangMenuItem((LangType)i));
4450  				mask <<= 1;
4451  			}
4452  			mask = 1;
4453  			for (int i = 8 ; i < 16 ; ++i)
4454  			{
4455  				if (mask & g1)
4456  					_nppGUI._excludedLangList.push_back(LangMenuItem((LangType)i));
4457  				mask <<= 1;
4458  			}
4459  			mask = 1;
4460  			for (int i = 16 ; i < 24 ; ++i)
4461  			{
4462  				if (mask & g2)
4463  					_nppGUI._excludedLangList.push_back(LangMenuItem((LangType)i));
4464  				mask <<= 1;
4465  			}
4466  			mask = 1;
4467  			for (int i = 24 ; i < 32 ; ++i)
4468  			{
4469  				if (mask & g3)
4470  					_nppGUI._excludedLangList.push_back(LangMenuItem((LangType)i));
4471  				mask <<= 1;
4472  			}
4473  			mask = 1;
4474  			for (int i = 32 ; i < 40 ; ++i)
4475  			{
4476  				if (mask & g4)
4477  					_nppGUI._excludedLangList.push_back(LangMenuItem((LangType)i));
4478  				mask <<= 1;
4479  			}
4480  			mask = 1;
4481  			for (int i = 40 ; i < 48 ; ++i)
4482  			{
4483  				if (mask & g5)
4484  					_nppGUI._excludedLangList.push_back(LangMenuItem((LangType)i));
4485  				mask <<= 1;
4486  			}
4487  			mask = 1;
4488  			for (int i = 48 ; i < 56 ; ++i)
4489  			{
4490  				if (mask & g6)
4491  					_nppGUI._excludedLangList.push_back(LangMenuItem((LangType)i));
4492  				mask <<= 1;
4493  			}
4494  			mask = 1;
4495  			for (int i = 56 ; i < 64 ; ++i)
4496  			{
4497  				if (mask & g7)
4498  					_nppGUI._excludedLangList.push_back(LangMenuItem((LangType)i));
4499  				mask <<= 1;
4500  			}
4501  			mask = 1;
4502  			for (int i = 64; i < 72; ++i)
4503  			{
4504  				if (mask & g8)
4505  					_nppGUI._excludedLangList.push_back(LangMenuItem((LangType)i));
4506  				mask <<= 1;
4507  			}
4508  			mask = 1;
4509  			for (int i = 72; i < 80; ++i)
4510  			{
4511  				if (mask & g9)
4512  					_nppGUI._excludedLangList.push_back(LangMenuItem((LangType)i));
4513  				mask <<= 1;
4514  			}
4515  			mask = 1;
4516  			for (int i = 80; i < 88; ++i)
4517  			{
4518  				if (mask & g10)
4519  					_nppGUI._excludedLangList.push_back(LangMenuItem((LangType)i));
4520  				mask <<= 1;
4521  			}
4522  			mask = 1;
4523  			for (int i = 88; i < 96; ++i)
4524  			{
4525  				if (mask & g11)
4526  					_nppGUI._excludedLangList.push_back(LangMenuItem((LangType)i));
4527  				mask <<= 1;
4528  			}
4529  			mask = 1;
4530  			for (int i = 96; i < 104; ++i)
4531  			{
4532  				if (mask & g12)
4533  					_nppGUI._excludedLangList.push_back(LangMenuItem((LangType)i));
4534  				mask <<= 1;
4535  			}
4536  			const TCHAR* val = element->Attribute(TEXT("langMenuCompact"));
4537  			if (val)
4538  				_nppGUI._isLangMenuCompact = (!lstrcmp(val, TEXT("yes")));
4539  		}
4540  		else if (!lstrcmp(nm, TEXT("Print")))
4541  		{
4542  			const TCHAR* val = element->Attribute(TEXT("lineNumber"));
4543  			if (val)
4544  				_nppGUI._printSettings._printLineNumber = (!lstrcmp(val, TEXT("yes")));
4545  			int i;
4546  			if (element->Attribute(TEXT("printOption"), &i))
4547  				_nppGUI._printSettings._printOption = i;
4548  			val = element->Attribute(TEXT("headerLeft"));
4549  			if (val)
4550  				_nppGUI._printSettings._headerLeft = val;
4551  			val = element->Attribute(TEXT("headerMiddle"));
4552  			if (val)
4553  				_nppGUI._printSettings._headerMiddle = val;
4554  			val = element->Attribute(TEXT("headerRight"));
4555  			if (val)
4556  				_nppGUI._printSettings._headerRight = val;
4557  			val = element->Attribute(TEXT("footerLeft"));
4558  			if (val)
4559  				_nppGUI._printSettings._footerLeft = val;
4560  			val = element->Attribute(TEXT("footerMiddle"));
4561  			if (val)
4562  				_nppGUI._printSettings._footerMiddle = val;
4563  			val = element->Attribute(TEXT("footerRight"));
4564  			if (val)
4565  				_nppGUI._printSettings._footerRight = val;
4566  			val = element->Attribute(TEXT("headerFontName"));
4567  			if (val)
4568  				_nppGUI._printSettings._headerFontName = val;
4569  			val = element->Attribute(TEXT("footerFontName"));
4570  			if (val)
4571  				_nppGUI._printSettings._footerFontName = val;
4572  			if (element->Attribute(TEXT("headerFontStyle"), &i))
4573  				_nppGUI._printSettings._headerFontStyle = i;
4574  			if (element->Attribute(TEXT("footerFontStyle"), &i))
4575  				_nppGUI._printSettings._footerFontStyle = i;
4576  			if (element->Attribute(TEXT("headerFontSize"), &i))
4577  				_nppGUI._printSettings._headerFontSize = i;
4578  			if (element->Attribute(TEXT("footerFontSize"), &i))
4579  				_nppGUI._printSettings._footerFontSize = i;
4580  			if (element->Attribute(TEXT("margeLeft"), &i))
4581  				_nppGUI._printSettings._marge.left = i;
4582  			if (element->Attribute(TEXT("margeTop"), &i))
4583  				_nppGUI._printSettings._marge.top = i;
4584  			if (element->Attribute(TEXT("margeRight"), &i))
4585  				_nppGUI._printSettings._marge.right = i;
4586  			if (element->Attribute(TEXT("margeBottom"), &i))
4587  				_nppGUI._printSettings._marge.bottom = i;
4588  		}
4589  		else if (!lstrcmp(nm, TEXT("ScintillaPrimaryView")))
4590  		{
4591  			feedScintillaParam(element);
4592  		}
4593  		else if (!lstrcmp(nm, TEXT("Backup")))
4594  		{
4595  			int i;
4596  			if (element->Attribute(TEXT("action"), &i))
4597  				_nppGUI._backup = (BackupFeature)i;
4598  			const TCHAR *bDir = element->Attribute(TEXT("useCustumDir"));
4599  			if (bDir)
4600  			{
4601  				_nppGUI._useDir = (lstrcmp(bDir, TEXT("yes")) == 0);
4602  			}
4603  			const TCHAR *pDir = element->Attribute(TEXT("dir"));
4604  			if (pDir)
4605  				_nppGUI._backupDir = pDir;
4606  			const TCHAR *isSnapshotModeStr = element->Attribute(TEXT("isSnapshotMode"));
4607  			if (isSnapshotModeStr && !lstrcmp(isSnapshotModeStr, TEXT("no")))
4608  				_nppGUI._isSnapshotMode = false;
4609  			int timing;
4610  			if (element->Attribute(TEXT("snapshotBackupTiming"), &timing))
4611  				_nppGUI._snapshotBackupTiming = timing;
4612  		}
4613  		else if (!lstrcmp(nm, TEXT("DockingManager")))
4614  		{
4615  			feedDockingManager(element);
4616  		}
4617  		else if (!lstrcmp(nm, TEXT("globalOverride")))
4618  		{
4619  			const TCHAR *bDir = element->Attribute(TEXT("fg"));
4620  			if (bDir)
4621  				_nppGUI._globalOverride.enableFg = (lstrcmp(bDir, TEXT("yes")) == 0);
4622  			bDir = element->Attribute(TEXT("bg"));
4623  			if (bDir)
4624  				_nppGUI._globalOverride.enableBg = (lstrcmp(bDir, TEXT("yes")) == 0);
4625  			bDir = element->Attribute(TEXT("font"));
4626  			if (bDir)
4627  				_nppGUI._globalOverride.enableFont = (lstrcmp(bDir, TEXT("yes")) == 0);
4628  			bDir = element->Attribute(TEXT("fontSize"));
4629  			if (bDir)
4630  				_nppGUI._globalOverride.enableFontSize = (lstrcmp(bDir, TEXT("yes")) == 0);
4631  			bDir = element->Attribute(TEXT("bold"));
4632  			if (bDir)
4633  				_nppGUI._globalOverride.enableBold = (lstrcmp(bDir, TEXT("yes")) == 0);
4634  			bDir = element->Attribute(TEXT("italic"));
4635  			if (bDir)
4636  				_nppGUI._globalOverride.enableItalic = (lstrcmp(bDir, TEXT("yes")) == 0);
4637  			bDir = element->Attribute(TEXT("underline"));
4638  			if (bDir)
4639  				_nppGUI._globalOverride.enableUnderLine = (lstrcmp(bDir, TEXT("yes")) == 0);
4640  		}
4641  		else if (!lstrcmp(nm, TEXT("auto-completion")))
4642  		{
4643  			int i;
4644  			if (element->Attribute(TEXT("autoCAction"), &i))
4645  				_nppGUI._autocStatus = static_cast<NppGUI::AutocStatus>(i);
4646  			if (element->Attribute(TEXT("triggerFromNbChar"), &i))
4647  				_nppGUI._autocFromLen = i;
4648  			const TCHAR * optName = element->Attribute(TEXT("autoCIgnoreNumbers"));
4649  			if (optName)
4650  				_nppGUI._autocIgnoreNumbers = (lstrcmp(optName, TEXT("yes")) == 0);
4651  			optName = element->Attribute(TEXT("insertSelectedItemUseENTER"));
4652  			if (optName)
4653  				_nppGUI._autocInsertSelectedUseENTER = (lstrcmp(optName, TEXT("yes")) == 0);
4654  			optName = element->Attribute(TEXT("insertSelectedItemUseTAB"));
4655  			if (optName)
4656  				_nppGUI._autocInsertSelectedUseTAB = (lstrcmp(optName, TEXT("yes")) == 0);
4657  			optName = element->Attribute(TEXT("autoCBrief"));
4658  			if (optName)
4659  				_nppGUI._autocBrief = (lstrcmp(optName, TEXT("yes")) == 0);
4660  			optName = element->Attribute(TEXT("funcParams"));
4661  			if (optName)
4662  				_nppGUI._funcParams = (lstrcmp(optName, TEXT("yes")) == 0);
4663  		}
4664  		else if (!lstrcmp(nm, TEXT("auto-insert")))
4665  		{
4666  			const TCHAR * optName = element->Attribute(TEXT("htmlXmlTag"));
4667  			if (optName)
4668  				_nppGUI._matchedPairConf._doHtmlXmlTag = (lstrcmp(optName, TEXT("yes")) == 0);
4669  			optName = element->Attribute(TEXT("parentheses"));
4670  			if (optName)
4671  				_nppGUI._matchedPairConf._doParentheses = (lstrcmp(optName, TEXT("yes")) == 0);
4672  			optName = element->Attribute(TEXT("brackets"));
4673  			if (optName)
4674  				_nppGUI._matchedPairConf._doBrackets = (lstrcmp(optName, TEXT("yes")) == 0);
4675  			optName = element->Attribute(TEXT("curlyBrackets"));
4676  			if (optName)
4677  				_nppGUI._matchedPairConf._doCurlyBrackets = (lstrcmp(optName, TEXT("yes")) == 0);
4678  			optName = element->Attribute(TEXT("quotes"));
4679  			if (optName)
4680  				_nppGUI._matchedPairConf._doQuotes = (lstrcmp(optName, TEXT("yes")) == 0);
4681  			optName = element->Attribute(TEXT("doubleQuotes"));
4682  			if (optName)
4683  				_nppGUI._matchedPairConf._doDoubleQuotes = (lstrcmp(optName, TEXT("yes")) == 0);
4684  			for (TiXmlNode *subChildNode = childNode->FirstChildElement(TEXT("UserDefinePair"));
4685  				 subChildNode;
4686  				 subChildNode = subChildNode->NextSibling(TEXT("UserDefinePair")) )
4687  			{
4688  				int open = -1;
4689  				int openVal = 0;
4690  				const TCHAR *openValStr = (subChildNode->ToElement())->Attribute(TEXT("open"), &openVal);
4691  				if (openValStr && (openVal >= 0 && openVal < 128))
4692  					open = openVal;
4693  				int close = -1;
4694  				int closeVal = 0;
4695  				const TCHAR *closeValStr = (subChildNode->ToElement())->Attribute(TEXT("close"), &closeVal);
4696  				if (closeValStr && (closeVal >= 0 && closeVal <= 128))
4697  					close = closeVal;
4698  				if (open != -1 && close != -1)
4699  					_nppGUI._matchedPairConf._matchedPairsInit.push_back(pair<char, char>(char(open), char(close)));
4700  			}
4701  		}
4702  		else if (!lstrcmp(nm, TEXT("sessionExt")))
4703  		{
4704  			TiXmlNode *n = childNode->FirstChild();
4705  			if (n)
4706  			{
4707  				const TCHAR* val = n->Value();
4708  				if (val)
4709  					_nppGUI._definedSessionExt = val;
4710  			}
4711  		}
4712  		else if (!lstrcmp(nm, TEXT("workspaceExt")))
4713  		{
4714  			TiXmlNode *n = childNode->FirstChild();
4715  			if (n)
4716  			{
4717  				const TCHAR* val = n->Value();
4718  				if (val)
4719  					_nppGUI._definedWorkspaceExt = val;
4720  			}
4721  		}
4722  		else if (!lstrcmp(nm, TEXT("noUpdate")))
4723  		{
4724  			TiXmlNode *n = childNode->FirstChild();
4725  			if (n)
4726  			{
4727  				const TCHAR* val = n->Value();
4728  				if (val)
4729  					_nppGUI._autoUpdateOpt._doAutoUpdate = (!lstrcmp(val, TEXT("yes")))?false:true;
4730  				int i;
4731  				val = element->Attribute(TEXT("intervalDays"), &i);
4732  				if (val)
4733  					_nppGUI._autoUpdateOpt._intervalDays = i;
4734  				val = element->Attribute(TEXT("nextUpdateDate"));
4735  				if (val)
4736  					_nppGUI._autoUpdateOpt._nextUpdateDate = Date(val);
4737  			}
4738  		}
4739  		else if (!lstrcmp(nm, TEXT("openSaveDir")))
4740  		{
4741  			const TCHAR * value = element->Attribute(TEXT("value"));
4742  			if (value && value[0])
4743  			{
4744  				if (lstrcmp(value, TEXT("1")) == 0)
4745  					_nppGUI._openSaveDir = dir_last;
4746  				else if (lstrcmp(value, TEXT("2")) == 0)
4747  					_nppGUI._openSaveDir = dir_userDef;
4748  				else
4749  					_nppGUI._openSaveDir = dir_followCurrent;
4750  			}
4751  			const TCHAR * path = element->Attribute(TEXT("defaultDirPath"));
4752  			if (path && path[0])
4753  			{
4754  				lstrcpyn(_nppGUI._defaultDir, path, MAX_PATH);
4755  				::ExpandEnvironmentStrings(_nppGUI._defaultDir, _nppGUI._defaultDirExp, MAX_PATH);
4756  			}
4757   		}
4758  		else if (!lstrcmp(nm, TEXT("titleBar")))
4759  		{
4760  			const TCHAR * value = element->Attribute(TEXT("short"));
4761  			_nppGUI._shortTitlebar = false;	
4762  			if (value && value[0])
4763  			{
4764  				if (lstrcmp(value, TEXT("yes")) == 0)
4765  					_nppGUI._shortTitlebar = true;
4766  				else if (lstrcmp(value, TEXT("no")) == 0)
4767  					_nppGUI._shortTitlebar = false;
4768  			}
4769  		}
4770  		else if (!lstrcmp(nm, TEXT("insertDateTime")))
4771  		{
4772  			const TCHAR* customFormat = element->Attribute(TEXT("customizedFormat"));
4773  			if (customFormat != NULL && customFormat[0])
4774  				_nppGUI._dateTimeFormat = customFormat;
4775  			const TCHAR* value = element->Attribute(TEXT("reverseDefaultOrder"));
4776  			if (value && value[0])
4777  			{
4778  				if (lstrcmp(value, TEXT("yes")) == 0)
4779  					_nppGUI._dateTimeReverseDefaultOrder = true;
4780  				else if (lstrcmp(value, TEXT("no")) == 0)
4781  					_nppGUI._dateTimeReverseDefaultOrder = false;
4782  			}
4783  		}
4784  		else if (!lstrcmp(nm, TEXT("wordCharList")))
4785  		{
4786  			const TCHAR * value = element->Attribute(TEXT("useDefault"));
4787  			if (value && value[0])
4788  			{
4789  				if (lstrcmp(value, TEXT("yes")) == 0)
4790  					_nppGUI._isWordCharDefault = true;
4791  				else if (lstrcmp(value, TEXT("no")) == 0)
4792  					_nppGUI._isWordCharDefault = false;
4793  			}
4794  			const TCHAR *charsAddedW = element->Attribute(TEXT("charsAdded"));
4795  			if (charsAddedW)
4796  			{
4797  				WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
4798  				_nppGUI._customWordChars = wmc.wchar2char(charsAddedW, SC_CP_UTF8);
4799  			}
4800  		}
4801  		else if (!lstrcmp(nm, TEXT("delimiterSelection")))
4802  		{
4803  			int leftmost = 0;
4804  			element->Attribute(TEXT("leftmostDelimiter"), &leftmost);
4805  			if (leftmost > 0 && leftmost < 256)
4806  				_nppGUI._leftmostDelimiter = static_cast<char>(leftmost);
4807  			int rightmost = 0;
4808  			element->Attribute(TEXT("rightmostDelimiter"), &rightmost);
4809  			if (rightmost > 0 && rightmost < 256)
4810  				_nppGUI._rightmostDelimiter = static_cast<char>(rightmost);
4811  			const TCHAR *delimiterSelectionOnEntireDocument = element->Attribute(TEXT("delimiterSelectionOnEntireDocument"));
4812  			if (delimiterSelectionOnEntireDocument != NULL && !lstrcmp(delimiterSelectionOnEntireDocument, TEXT("yes")))
4813  				_nppGUI._delimiterSelectionOnEntireDocument = true;
4814  			else
4815  				_nppGUI._delimiterSelectionOnEntireDocument = false;
4816  		}
4817  		else if (!lstrcmp(nm, TEXT("largeFileRestriction")))
4818  		{
4819  			int fileSizeLimit4StylingMB = 0;
4820  			element->Attribute(TEXT("fileSizeMB"), &fileSizeLimit4StylingMB);
4821  			if (fileSizeLimit4StylingMB > 0 && fileSizeLimit4StylingMB <= 4096)
4822  				_nppGUI._largeFileRestriction._largeFileSizeDefInByte = (static_cast<int64_t>(fileSizeLimit4StylingMB) * 1024 * 1024);
4823  			const TCHAR* boolVal = element->Attribute(TEXT("isEnabled"));
4824  			if (boolVal != NULL && !lstrcmp(boolVal, TEXT("no")))
4825  				_nppGUI._largeFileRestriction._isEnabled = false;
4826  			else
4827  				_nppGUI._largeFileRestriction._isEnabled = true;
4828  			boolVal = element->Attribute(TEXT("allowAutoCompletion"));
4829  			if (boolVal != NULL && !lstrcmp(boolVal, TEXT("yes")))
4830  				_nppGUI._largeFileRestriction._allowAutoCompletion = true;
4831  			else
4832  				_nppGUI._largeFileRestriction._allowAutoCompletion = false;
4833  			boolVal = element->Attribute(TEXT("allowBraceMatch"));
4834  			if (boolVal != NULL && !lstrcmp(boolVal, TEXT("yes")))
4835  				_nppGUI._largeFileRestriction._allowBraceMatch = true;
4836  			else
4837  				_nppGUI._largeFileRestriction._allowBraceMatch = false;
4838  			boolVal = element->Attribute(TEXT("allowSmartHilite"));
4839  			if (boolVal != NULL && !lstrcmp(boolVal, TEXT("yes")))
4840  				_nppGUI._largeFileRestriction._allowSmartHilite = true;
4841  			else
4842  				_nppGUI._largeFileRestriction._allowSmartHilite = false;
4843  			boolVal = element->Attribute(TEXT("allowClickableLink"));
4844  			if (boolVal != NULL && !lstrcmp(boolVal, TEXT("yes")))
4845  				_nppGUI._largeFileRestriction._allowClickableLink = true;
4846  			else
4847  				_nppGUI._largeFileRestriction._allowClickableLink = false;
4848  			boolVal = element->Attribute(TEXT("deactivateWordWrap"));
4849  			if (boolVal != NULL && !lstrcmp(boolVal, TEXT("no")))
4850  				_nppGUI._largeFileRestriction._deactivateWordWrap = false;
4851  			else
4852  				_nppGUI._largeFileRestriction._deactivateWordWrap = true;
4853  		}
4854  		else if (!lstrcmp(nm, TEXT("multiInst")))
4855  		{
4856  			int val = 0;
4857  			element->Attribute(TEXT("setting"), &val);
4858  			if (val < 0 || val > 2)
4859  				val = 0;
4860  			_nppGUI._multiInstSetting = (MultiInstSetting)val;
4861  			_nppGUI._clipboardHistoryPanelKeepState = parseYesNoBoolAttribute(TEXT("clipboardHistory"));
4862  			_nppGUI._docListKeepState = parseYesNoBoolAttribute(TEXT("documentList"));
4863  			_nppGUI._charPanelKeepState = parseYesNoBoolAttribute(TEXT("characterPanel"));
4864  			_nppGUI._fileBrowserKeepState = parseYesNoBoolAttribute(TEXT("folderAsWorkspace"));
4865  			_nppGUI._projectPanelKeepState = parseYesNoBoolAttribute(TEXT("projectPanels"));
4866  			_nppGUI._docMapKeepState = parseYesNoBoolAttribute(TEXT("documentMap"));
4867  			_nppGUI._funcListKeepState = parseYesNoBoolAttribute(TEXT("fuctionList"));
4868  			_nppGUI._pluginPanelKeepState = parseYesNoBoolAttribute(TEXT("pluginPanels"));
4869  		}
4870  		else if (!lstrcmp(nm, TEXT("searchEngine")))
4871  		{
4872  			int i;
4873  			if (element->Attribute(TEXT("searchEngineChoice"), &i))
4874  				_nppGUI._searchEngineChoice = static_cast<NppGUI::SearchEngineChoice>(i);
4875  			const TCHAR * searchEngineCustom = element->Attribute(TEXT("searchEngineCustom"));
4876  			if (searchEngineCustom && searchEngineCustom[0])
4877  				_nppGUI._searchEngineCustom = searchEngineCustom;
4878  		}
4879  		else if (!lstrcmp(nm, TEXT("Searching")))
4880  		{
4881  			const TCHAR* optNameMonoFont = element->Attribute(TEXT("monospacedFontFindDlg"));
4882  			if (optNameMonoFont)
4883  				_nppGUI._monospacedFontFindDlg = (lstrcmp(optNameMonoFont, TEXT("yes")) == 0);
4884  			const TCHAR* optStopFillingFindField = element->Attribute(TEXT("stopFillingFindField"));
4885  			if (optStopFillingFindField) 
4886  			{
4887  				_nppGUI._fillFindFieldWithSelected = (lstrcmp(optStopFillingFindField, TEXT("no")) == 0);
4888  				_nppGUI._fillFindFieldSelectCaret = _nppGUI._fillFindFieldWithSelected;
4889  			}
4890  			const TCHAR* optFillFindFieldWithSelected = element->Attribute(TEXT("fillFindFieldWithSelected"));
4891  			if (optFillFindFieldWithSelected)
4892  				_nppGUI._fillFindFieldWithSelected = (lstrcmp(optFillFindFieldWithSelected, TEXT("yes")) == 0);
4893  			const TCHAR* optFillFindFieldSelectCaret = element->Attribute(TEXT("fillFindFieldSelectCaret"));
4894  			if (optFillFindFieldSelectCaret)
4895  				_nppGUI._fillFindFieldSelectCaret = (lstrcmp(optFillFindFieldSelectCaret, TEXT("yes")) == 0);
4896  			const TCHAR* optFindDlgAlwaysVisible = element->Attribute(TEXT("findDlgAlwaysVisible"));
4897  			if (optFindDlgAlwaysVisible)
4898  				_nppGUI._findDlgAlwaysVisible = (lstrcmp(optFindDlgAlwaysVisible, TEXT("yes")) == 0);
4899  			const TCHAR* optConfirmReplaceOpenDocs = element->Attribute(TEXT("confirmReplaceInAllOpenDocs"));
4900  			if (optConfirmReplaceOpenDocs)
4901  				_nppGUI._confirmReplaceInAllOpenDocs = (lstrcmp(optConfirmReplaceOpenDocs, TEXT("yes")) == 0);
4902  			const TCHAR* optReplaceStopsWithoutFindingNext = element->Attribute(TEXT("replaceStopsWithoutFindingNext"));
4903  			if (optReplaceStopsWithoutFindingNext)
4904  				_nppGUI._replaceStopsWithoutFindingNext = (lstrcmp(optReplaceStopsWithoutFindingNext, TEXT("yes")) == 0);
4905  		}
4906  		else if (!lstrcmp(nm, TEXT("MISC")))
4907  		{
4908  			const TCHAR * optName = element->Attribute(TEXT("fileSwitcherWithoutExtColumn"));
4909  			if (optName)
4910  				_nppGUI._fileSwitcherWithoutExtColumn = (lstrcmp(optName, TEXT("yes")) == 0);
4911  			int i = 0;
4912  			if (element->Attribute(TEXT("fileSwitcherExtWidth"), &i))
4913  				_nppGUI._fileSwitcherExtWidth = i;
4914  			const TCHAR * optNamePath = element->Attribute(TEXT("fileSwitcherWithoutPathColumn"));
4915  			if (optNamePath)
4916  				_nppGUI._fileSwitcherWithoutPathColumn = (lstrcmp(optNamePath, TEXT("yes")) == 0);
4917  			if (element->Attribute(TEXT("fileSwitcherPathWidth"), &i))
4918  				_nppGUI._fileSwitcherPathWidth = i;
4919  			_nppGUI._fileSwitcherDisableListViewGroups = parseYesNoBoolAttribute(TEXT("fileSwitcherNoGroups"));
4920  			const TCHAR * optNameBackSlashEscape = element->Attribute(TEXT("backSlashIsEscapeCharacterForSql"));
4921  			if (optNameBackSlashEscape && !lstrcmp(optNameBackSlashEscape, TEXT("no")))
4922  				_nppGUI._backSlashIsEscapeCharacterForSql = false;
4923  			const TCHAR * optNameWriteTechnologyEngine = element->Attribute(TEXT("writeTechnologyEngine"));
4924  			if (optNameWriteTechnologyEngine)
4925  				_nppGUI._writeTechnologyEngine = (lstrcmp(optNameWriteTechnologyEngine, TEXT("1")) == 0) ? directWriteTechnology : defaultTechnology;
4926  			const TCHAR * optNameFolderDroppedOpenFiles = element->Attribute(TEXT("isFolderDroppedOpenFiles"));
4927  			if (optNameFolderDroppedOpenFiles)
4928  				_nppGUI._isFolderDroppedOpenFiles = (lstrcmp(optNameFolderDroppedOpenFiles, TEXT("yes")) == 0);
4929  			const TCHAR * optDocPeekOnTab = element->Attribute(TEXT("docPeekOnTab"));
4930  			if (optDocPeekOnTab)
4931  				_nppGUI._isDocPeekOnTab = (lstrcmp(optDocPeekOnTab, TEXT("yes")) == 0);
4932  			const TCHAR * optDocPeekOnMap = element->Attribute(TEXT("docPeekOnMap"));
4933  			if (optDocPeekOnMap)
4934  				_nppGUI._isDocPeekOnMap = (lstrcmp(optDocPeekOnMap, TEXT("yes")) == 0);
4935  			const TCHAR* optSortFunctionList = element->Attribute(TEXT("sortFunctionList"));
4936  			if (optSortFunctionList)
4937  				_nppGUI._shouldSortFunctionList = (lstrcmp(optSortFunctionList, TEXT("yes")) == 0);
4938  			const TCHAR* saveDlgExtFilterToAllTypes = element->Attribute(TEXT("saveDlgExtFilterToAllTypes"));
4939  			if (saveDlgExtFilterToAllTypes)
4940  				_nppGUI._setSaveDlgExtFiltToAllTypes = (lstrcmp(saveDlgExtFilterToAllTypes, TEXT("yes")) == 0);
4941  			const TCHAR * optMuteSounds = element->Attribute(TEXT("muteSounds"));
4942  			if (optMuteSounds)
4943  				_nppGUI._muteSounds = lstrcmp(optMuteSounds, TEXT("yes")) == 0;
4944  			const TCHAR * optEnableFoldCmdToggable = element->Attribute(TEXT("enableFoldCmdToggable"));
4945  			if (optEnableFoldCmdToggable)
4946  				_nppGUI._enableFoldCmdToggable = lstrcmp(optEnableFoldCmdToggable, TEXT("yes")) == 0;
4947  			const TCHAR * hideMenuRightShortcuts = element->Attribute(TEXT("hideMenuRightShortcuts"));
4948  			if (hideMenuRightShortcuts)
4949  				_nppGUI._hideMenuRightShortcuts = lstrcmp(hideMenuRightShortcuts, TEXT("yes")) == 0;
4950  		}
4951  		else if (!lstrcmp(nm, TEXT("commandLineInterpreter")))
4952  		{
4953  			TiXmlNode *node = childNode->FirstChild();
4954  			if (node)
4955  			{
4956  				const TCHAR *cli = node->Value();
4957  				if (cli && cli[0])
4958  					_nppGUI._commandLineInterpreter.assign(cli);
4959  			}
4960  		}
4961  		else if (!lstrcmp(nm, TEXT("DarkMode")))
4962  		{
4963  			_nppGUI._darkmode._isEnabled = parseYesNoBoolAttribute(TEXT("enable"));
4964  			int i;
4965  			const TCHAR* val;
4966  			val = element->Attribute(TEXT("colorTone"), &i);
4967  			if (val)
4968  				_nppGUI._darkmode._colorTone = static_cast<NppDarkMode::ColorTone>(i);
4969  			val = element->Attribute(TEXT("customColorTop"), &i);
4970  			if (val)
4971  				_nppGUI._darkmode._customColors.pureBackground = i;
4972  			val = element->Attribute(TEXT("customColorMenuHotTrack"), &i);
4973  			if (val)
4974  				_nppGUI._darkmode._customColors.hotBackground = i;
4975  			val = element->Attribute(TEXT("customColorActive"), &i);
4976  			if (val)
4977  				_nppGUI._darkmode._customColors.softerBackground = i;
4978  			val = element->Attribute(TEXT("customColorMain"), &i);
4979  			if (val)
4980  				_nppGUI._darkmode._customColors.background = i;
4981  			val = element->Attribute(TEXT("customColorError"), &i);
4982  			if (val)
4983  				_nppGUI._darkmode._customColors.errorBackground = i;
4984  			val = element->Attribute(TEXT("customColorText"), &i);
4985  			if (val)
4986  				_nppGUI._darkmode._customColors.text = i;
4987  			val = element->Attribute(TEXT("customColorDarkText"), &i);
4988  			if (val)
4989  				_nppGUI._darkmode._customColors.darkerText = i;
4990  			val = element->Attribute(TEXT("customColorDisabledText"), &i);
4991  			if (val)
4992  				_nppGUI._darkmode._customColors.disabledText = i;
4993  			val = element->Attribute(TEXT("customColorLinkText"), &i);
4994  			if (val)
4995  				_nppGUI._darkmode._customColors.linkText = i;
4996  			val = element->Attribute(TEXT("customColorEdge"), &i);
4997  			if (val)
4998  				_nppGUI._darkmode._customColors.edge = i;
4999  			val = element->Attribute(TEXT("customColorHotEdge"), &i);
5000  			if (val)
5001  				_nppGUI._darkmode._customColors.hotEdge = i;
5002  			val = element->Attribute(TEXT("customColorDisabledEdge"), &i);
5003  			if (val)
5004  				_nppGUI._darkmode._customColors.disabledEdge = i;
5005  			auto parseStringAttribute = [&element](const TCHAR* name, const TCHAR* defaultName = TEXT("")) -> const TCHAR* {
5006  				const TCHAR* val = element->Attribute(name);
5007  				if (val != nullptr && val[0])
5008  				{
5009  					return element->Attribute(name);
5010  				}
5011  				return defaultName;
5012  			};
5013  			auto parseToolBarIconsAttribute = [&element](const TCHAR* name, int defaultValue = -1) -> int {
5014  				int val;
5015  				const TCHAR* valStr = element->Attribute(name, &val);
5016  				if (valStr != nullptr && (val >= 0 && val <= 4))
5017  				{
5018  					return val;
5019  				}
5020  				return defaultValue;
5021  			};
5022  			auto parseTabIconsAttribute = [&element](const TCHAR* name, int defaultValue = -1) -> int {
5023  				int val;
5024  				const TCHAR* valStr = element->Attribute(name, &val);
5025  				if (valStr != nullptr && (val >= 0 && val <= 2))
5026  				{
5027  					return val;
5028  				}
5029  				return defaultValue;
5030  			};
5031  			auto& windowsMode = _nppGUI._darkmode._advOptions._enableWindowsMode;
5032  			windowsMode = parseYesNoBoolAttribute(TEXT("enableWindowsMode"));
5033  			auto& darkDefaults = _nppGUI._darkmode._advOptions._darkDefaults;
5034  			auto& darkThemeName = darkDefaults._xmlFileName;
5035  			darkThemeName = parseStringAttribute(TEXT("darkThemeName"), TEXT("DarkModeDefault.xml"));
5036  			darkDefaults._toolBarIconSet = parseToolBarIconsAttribute(TEXT("darkToolBarIconSet"), 0);
5037  			darkDefaults._tabIconSet = parseTabIconsAttribute(TEXT("darkTabIconSet"), 2);
5038  			darkDefaults._tabUseTheme = parseYesNoBoolAttribute(TEXT("darkTabUseTheme"));
5039  			auto& lightDefaults = _nppGUI._darkmode._advOptions._lightDefaults;
5040  			auto& lightThemeName = lightDefaults._xmlFileName;
5041  			lightThemeName = parseStringAttribute(TEXT("lightThemeName"));
5042  			lightDefaults._toolBarIconSet = parseToolBarIconsAttribute(TEXT("lightToolBarIconSet"), 4);
5043  			lightDefaults._tabIconSet = parseTabIconsAttribute(TEXT("lightTabIconSet"), 0);
5044  			lightDefaults._tabUseTheme = parseYesNoBoolAttribute(TEXT("lightTabUseTheme"), true);
5045  			if (!windowsMode)
5046  			{
5047  				generic_string themePath;
5048  				generic_string xmlFileName = _nppGUI._darkmode._isEnabled ? darkThemeName : lightThemeName;
5049  				const bool isLocalOnly = _isLocal && !_isCloud;
5050  				if (!xmlFileName.empty() && lstrcmp(xmlFileName.c_str(), TEXT("stylers.xml")) != 0)
5051  				{
5052  					themePath = isLocalOnly ? _nppPath : _userPath;
5053  					pathAppend(themePath, TEXT("themes\\"));
5054  					pathAppend(themePath, xmlFileName);
5055  					if (!isLocalOnly && ::PathFileExists(themePath.c_str()) == FALSE)
5056  					{
5057  						themePath = _nppPath;
5058  						pathAppend(themePath, TEXT("themes\\"));
5059  						pathAppend(themePath, xmlFileName);
5060  					}
5061  				}
5062  				else
5063  				{
5064  					themePath = isLocalOnly ? _nppPath : _userPath;
5065  					pathAppend(themePath, TEXT("stylers.xml"));
5066  					if (!isLocalOnly && ::PathFileExists(themePath.c_str()) == FALSE)
5067  					{
5068  						themePath = _nppPath;
5069  						pathAppend(themePath, TEXT("stylers.xml"));
5070  					}
5071  				}
5072  				if (::PathFileExists(themePath.c_str()) == TRUE)
5073  				{
5074  					_nppGUI._themeName.assign(themePath);
5075  				}
5076  			}
5077  		}
5078  	}
5079  }
5080  void NppParameters::feedScintillaParam(TiXmlNode *node)
5081  {
5082  	TiXmlElement* element = node->ToElement();
5083  	auto parseYesNoBoolAttribute = [&element](const TCHAR* name, bool defaultValue = false) -> bool {
5084  		const TCHAR* nm = element->Attribute(name);
5085  		if (nm)
5086  		{
5087  			if (!lstrcmp(nm, TEXT("yes")))
5088  				return true;
5089  			else if (!lstrcmp(nm, TEXT("no")))
5090  				return false;
5091  		}
5092  		return defaultValue;
5093  	};
5094  	auto parseShowHideBoolAttribute = [&element](const TCHAR* name, bool defaultValue = false) -> bool {
5095  		const TCHAR* nm = element->Attribute(name);
5096  		if (nm)
5097  		{
5098  			if (!lstrcmp(nm, TEXT("show")))
5099  				return true;
5100  			else if (!lstrcmp(nm, TEXT("hide")))
5101  				return false;
5102  		}
5103  		return defaultValue;
5104  	};
5105  	const TCHAR *nm = element->Attribute(TEXT("lineNumberMargin"));
5106  	if (nm)
5107  	{
5108  		if (!lstrcmp(nm, TEXT("show")))
5109  			_svp._lineNumberMarginShow = true;
5110  		else if (!lstrcmp(nm, TEXT("hide")))
5111  			_svp._lineNumberMarginShow = false;
5112  	}
5113  	nm = element->Attribute(TEXT("lineNumberDynamicWidth"));
5114  	if (nm)
5115  	{
5116  		if (!lstrcmp(nm, TEXT("yes")))
5117  			_svp._lineNumberMarginDynamicWidth = true;
5118  		else if (!lstrcmp(nm, TEXT("no")))
5119  			_svp._lineNumberMarginDynamicWidth = false;
5120  	}
5121  	nm = element->Attribute(TEXT("bookMarkMargin"));
5122  	if (nm)
5123  	{
5124  		if (!lstrcmp(nm, TEXT("show")))
5125  			_svp._bookMarkMarginShow = true;
5126  		else if (!lstrcmp(nm, TEXT("hide")))
5127  			_svp._bookMarkMarginShow = false;
5128  	}
5129  	nm = element->Attribute(TEXT("isChangeHistoryEnabled"));
5130  	if (nm)
5131  	{
5132  		if (!lstrcmp(nm, TEXT("yes")))
5133  		{
5134  			_svp._isChangeHistoryEnabled = true;
5135  			_svp._isChangeHistoryEnabled4NextSession = true;
5136  		}
5137  		else if (!lstrcmp(nm, TEXT("no")))
5138  		{
5139  			_svp._isChangeHistoryEnabled = false;
5140  			_svp._isChangeHistoryEnabled4NextSession = false;
5141  		}
5142  	}
5143  	nm = element->Attribute(TEXT("indentGuideLine"));
5144  	if (nm)
5145  	{
5146  		if (!lstrcmp(nm, TEXT("show")))
5147  			_svp._indentGuideLineShow = true;
5148  		else if (!lstrcmp(nm, TEXT("hide")))
5149  			_svp._indentGuideLineShow= false;
5150  	}
5151  	nm = element->Attribute(TEXT("folderMarkStyle"));
5152  	if (nm)
5153  	{
5154  		if (!lstrcmp(nm, TEXT("box")))
5155  			_svp._folderStyle = FOLDER_STYLE_BOX;
5156  		else if (!lstrcmp(nm, TEXT("circle")))
5157  			_svp._folderStyle = FOLDER_STYLE_CIRCLE;
5158  		else if (!lstrcmp(nm, TEXT("arrow")))
5159  			_svp._folderStyle = FOLDER_STYLE_ARROW;
5160  		else if (!lstrcmp(nm, TEXT("simple")))
5161  			_svp._folderStyle = FOLDER_STYLE_SIMPLE;
5162  		else if (!lstrcmp(nm, TEXT("none")))
5163  			_svp._folderStyle = FOLDER_STYLE_NONE;
5164  	}
5165  	nm = element->Attribute(TEXT("lineWrapMethod"));
5166  	if (nm)
5167  	{
5168  		if (!lstrcmp(nm, TEXT("default")))
5169  			_svp._lineWrapMethod = LINEWRAP_DEFAULT;
5170  		else if (!lstrcmp(nm, TEXT("aligned")))
5171  			_svp._lineWrapMethod = LINEWRAP_ALIGNED;
5172  		else if (!lstrcmp(nm, TEXT("indent")))
5173  			_svp._lineWrapMethod = LINEWRAP_INDENT;
5174  	}
5175  	nm = element->Attribute(TEXT("currentLineHilitingShow"));
5176  	if (nm)
5177  	{
5178  		if (!lstrcmp(nm, TEXT("show")))
5179  			_svp._currentLineHiliteMode = LINEHILITE_HILITE;
5180  		else
5181  			_svp._currentLineHiliteMode = LINEHILITE_NONE;
5182  	}
5183  	else
5184  	{
5185  		const TCHAR* currentLineModeStr = element->Attribute(TEXT("currentLineIndicator"));
5186  		if (currentLineModeStr && currentLineModeStr[0])
5187  		{
5188  			if (lstrcmp(currentLineModeStr, TEXT("1")) == 0)
5189  				_svp._currentLineHiliteMode = LINEHILITE_HILITE;
5190  			else if (lstrcmp(currentLineModeStr, TEXT("2")) == 0)
5191  				_svp._currentLineHiliteMode = LINEHILITE_FRAME;
5192  			else
5193  				_svp._currentLineHiliteMode = LINEHILITE_NONE;
5194  		}
5195  	}
5196  	nm = element->Attribute(TEXT("currentLineFrameWidth"));
5197  	if (nm)
5198  	{
5199  		unsigned char frameWidth{ 1 };
5200  		try
5201  		{
5202  			frameWidth = static_cast<unsigned char>(std::stoi(nm));
5203  		}
5204  		catch (...)
5205  		{
5206  		}
5207  		_svp._currentLineFrameWidth = (frameWidth < 1) ? 1 : (frameWidth > 6) ? 6 : frameWidth;
5208  	}
5209  	nm = element->Attribute(TEXT("virtualSpace"));
5210  	if (nm)
5211  	{
5212  		if (!lstrcmp(nm, TEXT("yes")))
5213  			_svp._virtualSpace = true;
5214  		else if (!lstrcmp(nm, TEXT("no")))
5215  			_svp._virtualSpace = false;
5216  	}
5217  	nm = element->Attribute(TEXT("scrollBeyondLastLine"));
5218  	if (nm)
5219  	{
5220  		if (!lstrcmp(nm, TEXT("yes")))
5221  			_svp._scrollBeyondLastLine = true;
5222  		else if (!lstrcmp(nm, TEXT("no")))
5223  			_svp._scrollBeyondLastLine = false;
5224  	}
5225  	nm = element->Attribute(TEXT("rightClickKeepsSelection"));
5226  	if (nm)
5227  	{
5228  		if (!lstrcmp(nm, TEXT("yes")))
5229  			_svp._rightClickKeepsSelection = true;
5230  		else if (!lstrcmp(nm, TEXT("no")))
5231  			_svp._rightClickKeepsSelection = false;
5232  	}
5233  	nm = element->Attribute(TEXT("disableAdvancedScrolling"));
5234  	if (nm)
5235  	{
5236  		if (!lstrcmp(nm, TEXT("yes")))
5237  			_svp._disableAdvancedScrolling = true;
5238  		else if (!lstrcmp(nm, TEXT("no")))
5239  			_svp._disableAdvancedScrolling = false;
5240  	}
5241  	nm = element->Attribute(TEXT("wrapSymbolShow"));
5242  	if (nm)
5243  	{
5244  		if (!lstrcmp(nm, TEXT("show")))
5245  			_svp._wrapSymbolShow = true;
5246  		else if (!lstrcmp(nm, TEXT("hide")))
5247  			_svp._wrapSymbolShow = false;
5248  	}
5249  	nm = element->Attribute(TEXT("Wrap"));
5250  	if (nm)
5251  	{
5252  		if (!lstrcmp(nm, TEXT("yes")))
5253  			_svp._doWrap = true;
5254  		else if (!lstrcmp(nm, TEXT("no")))
5255  			_svp._doWrap = false;
5256  	}
5257  	nm = element->Attribute(TEXT("isEdgeBgMode"));
5258  	if (nm)
5259  	{
5260  		if (!lstrcmp(nm, TEXT("yes")))
5261  			_svp._isEdgeBgMode = true;
5262  		else if (!lstrcmp(nm, TEXT("no")))
5263  			_svp._isEdgeBgMode = false;
5264  	}
5265  	nm = element->Attribute(TEXT("borderEdge"));
5266  	if (nm)
5267  	{
5268  		if (!lstrcmp(nm, TEXT("yes")))
5269  			_svp._showBorderEdge = true;
5270  		else if (!lstrcmp(nm, TEXT("no")))
5271  			_svp._showBorderEdge = false;
5272  	}
5273  	nm = element->Attribute(TEXT("edgeMultiColumnPos"));
5274  	if (nm)
5275  	{
5276  		str2numberVector(nm, _svp._edgeMultiColumnPos);
5277  	}
5278  	int val;
5279  	nm = element->Attribute(TEXT("zoom"), &val);
5280  	if (nm)
5281  	{
5282  		_svp._zoom = val;
5283  	}
5284  	nm = element->Attribute(TEXT("zoom2"), &val);
5285  	if (nm)
5286  	{
5287  		_svp._zoom2 = val;
5288  	}
5289  	nm = element->Attribute(TEXT("whiteSpaceShow"));
5290  	if (nm)
5291  	{
5292  		if (!lstrcmp(nm, TEXT("show")))
5293  			_svp._whiteSpaceShow = true;
5294  		else if (!lstrcmp(nm, TEXT("hide")))
5295  			_svp._whiteSpaceShow = false;
5296  	}
5297  	nm = element->Attribute(TEXT("eolShow"));
5298  	if (nm)
5299  	{
5300  		if (!lstrcmp(nm, TEXT("show")))
5301  			_svp._eolShow = true;
5302  		else if (!lstrcmp(nm, TEXT("hide")))
5303  			_svp._eolShow = false;
5304  	}
5305  	nm = element->Attribute(TEXT("eolMode"), &val);
5306  	if (nm)
5307  	{
5308  		if (val >= 0 && val <= 3)
5309  			_svp._eolMode = static_cast<ScintillaViewParams::crlfMode>(val);
5310  	}
5311  	_svp._npcShow = parseShowHideBoolAttribute(TEXT("npcShow"), true);
5312  	nm = element->Attribute(TEXT("npcMode"), &val);
5313  	if (nm)
5314  	{
5315  		if (val >= 1 && val <= 2)
5316  			_svp._npcMode = static_cast<ScintillaViewParams::npcMode>(val);
5317  	}
5318  	_svp._npcCustomColor = parseYesNoBoolAttribute(TEXT("npcCustomColor"));
5319  	_svp._npcIncludeCcUniEol = parseYesNoBoolAttribute(TEXT("npcIncludeCcUniEOL"));
5320  	_svp._ccUniEolShow = parseYesNoBoolAttribute(TEXT("ccShow"), true);
5321  	nm = element->Attribute(TEXT("borderWidth"), &val);
5322  	if (nm)
5323  	{
5324  		if (val >= 0 && val <= 30)
5325  			_svp._borderWidth = val;
5326  	}
5327  	nm = element->Attribute(TEXT("smoothFont"));
5328  	if (nm)
5329  	{
5330  		if (!lstrcmp(nm, TEXT("yes")))
5331  			_svp._doSmoothFont = true;
5332  		else if (!lstrcmp(nm, TEXT("no")))
5333  			_svp._doSmoothFont = false;
5334  	}
5335  	nm = element->Attribute(TEXT("paddingLeft"), &val);
5336  	if (nm)
5337  	{
5338  		if (val >= 0 && val <= 30)
5339  			_svp._paddingLeft = static_cast<unsigned char>(val);
5340  	}
5341  	nm = element->Attribute(TEXT("paddingRight"), &val);
5342  	if (nm)
5343  	{
5344  		if (val >= 0 && val <= 30)
5345  			_svp._paddingRight = static_cast<unsigned char>(val);
5346  	}
5347  	nm = element->Attribute(TEXT("distractionFreeDivPart"), &val);
5348  	if (nm)
5349  	{
5350  		if (val >= 3 && val <= 9)
5351  			_svp._distractionFreeDivPart = static_cast<unsigned char>(val);
5352  	}
5353  }
5354  void NppParameters::feedDockingManager(TiXmlNode *node)
5355  {
5356  	TiXmlElement *element = node->ToElement();
5357  	int i;
5358  	if (element->Attribute(TEXT("leftWidth"), &i))
5359  		_nppGUI._dockingData._leftWidth = i;
5360  	if (element->Attribute(TEXT("rightWidth"), &i))
5361  		_nppGUI._dockingData._rightWidth = i;
5362  	if (element->Attribute(TEXT("topHeight"), &i))
5363  		_nppGUI._dockingData._topHeight = i;
5364  	if (element->Attribute(TEXT("bottomHeight"), &i))
5365  		_nppGUI._dockingData._bottomHight = i;
5366  	for (TiXmlNode *childNode = node->FirstChildElement(TEXT("FloatingWindow"));
5367  		childNode ;
5368  		childNode = childNode->NextSibling(TEXT("FloatingWindow")) )
5369  	{
5370  		TiXmlElement *floatElement = childNode->ToElement();
5371  		int cont;
5372  		if (floatElement->Attribute(TEXT("cont"), &cont))
5373  		{
5374  			int x = 0;
5375  			int y = 0;
5376  			int w = 100;
5377  			int h = 100;
5378  			floatElement->Attribute(TEXT("x"), &x);
5379  			floatElement->Attribute(TEXT("y"), &y);
5380  			floatElement->Attribute(TEXT("width"), &w);
5381  			floatElement->Attribute(TEXT("height"), &h);
5382  			_nppGUI._dockingData._flaotingWindowInfo.push_back(FloatingWindowInfo(cont, x, y, w, h));
5383  		}
5384  	}
5385  	for (TiXmlNode *childNode = node->FirstChildElement(TEXT("PluginDlg"));
5386  		childNode ;
5387  		childNode = childNode->NextSibling(TEXT("PluginDlg")) )
5388  	{
5389  		TiXmlElement *dlgElement = childNode->ToElement();
5390  		const TCHAR *name = dlgElement->Attribute(TEXT("pluginName"));
5391  		int id;
5392  		const TCHAR *idStr = dlgElement->Attribute(TEXT("id"), &id);
5393  		if (name && idStr)
5394  		{
5395  			int curr = 0; 
5396  			int prev = 0; 
5397  			dlgElement->Attribute(TEXT("curr"), &curr);
5398  			dlgElement->Attribute(TEXT("prev"), &prev);
5399  			bool isVisible = false;
5400  			const TCHAR *val = dlgElement->Attribute(TEXT("isVisible"));
5401  			if (val)
5402  			{
5403  				isVisible = (lstrcmp(val, TEXT("yes")) == 0);
5404  			}
5405  			_nppGUI._dockingData._pluginDockInfo.push_back(PluginDlgDockingInfo(name, id, curr, prev, isVisible));
5406  		}
5407  	}
5408  	for (TiXmlNode *childNode = node->FirstChildElement(TEXT("ActiveTabs"));
5409  		childNode ;
5410  		childNode = childNode->NextSibling(TEXT("ActiveTabs")) )
5411  	{
5412  		TiXmlElement *dlgElement = childNode->ToElement();
5413  		int cont;
5414  		if (dlgElement->Attribute(TEXT("cont"), &cont))
5415  		{
5416  			int activeTab = 0;
5417  			dlgElement->Attribute(TEXT("activeTab"), &activeTab);
5418  			_nppGUI._dockingData._containerTabInfo.push_back(ContainerTabInfo(cont, activeTab));
5419  		}
5420  	}
5421  }
5422  void NppParameters::duplicateDockingManager(TiXmlNode* dockMngNode, TiXmlElement* dockMngElmt2Clone)
5423  {
5424  	if (!dockMngNode || !dockMngElmt2Clone) return;
5425  	TiXmlElement *dockMngElmt = dockMngNode->ToElement();
5426  	int i;
5427  	if (dockMngElmt->Attribute(TEXT("leftWidth"), &i))
5428  		dockMngElmt2Clone->SetAttribute(TEXT("leftWidth"), i);
5429  	if (dockMngElmt->Attribute(TEXT("rightWidth"), &i))
5430  		dockMngElmt2Clone->SetAttribute(TEXT("rightWidth"), i);
5431  	if (dockMngElmt->Attribute(TEXT("topHeight"), &i))
5432  		dockMngElmt2Clone->SetAttribute(TEXT("topHeight"), i);
5433  	if (dockMngElmt->Attribute(TEXT("bottomHeight"), &i))
5434  		dockMngElmt2Clone->SetAttribute(TEXT("bottomHeight"), i);
5435  	for (TiXmlNode *childNode = dockMngNode->FirstChildElement(TEXT("FloatingWindow"));
5436  		childNode;
5437  		childNode = childNode->NextSibling(TEXT("FloatingWindow")))
5438  	{
5439  		TiXmlElement *floatElement = childNode->ToElement();
5440  		int cont;
5441  		if (floatElement->Attribute(TEXT("cont"), &cont))
5442  		{
5443  			TiXmlElement FWNode(TEXT("FloatingWindow"));
5444  			FWNode.SetAttribute(TEXT("cont"), cont);
5445  			int x = 0;
5446  			int y = 0;
5447  			int w = 100;
5448  			int h = 100;
5449  			floatElement->Attribute(TEXT("x"), &x);
5450  			FWNode.SetAttribute(TEXT("x"), x);
5451  			floatElement->Attribute(TEXT("y"), &y);
5452  			FWNode.SetAttribute(TEXT("y"), y);
5453  			floatElement->Attribute(TEXT("width"), &w);
5454  			FWNode.SetAttribute(TEXT("width"), w);
5455  			floatElement->Attribute(TEXT("height"), &h);
5456  			FWNode.SetAttribute(TEXT("height"), h);
5457  			dockMngElmt2Clone->InsertEndChild(FWNode);
5458  		}
5459  	}
5460  	for (TiXmlNode *childNode = dockMngNode->FirstChildElement(TEXT("PluginDlg"));
5461  		childNode;
5462  		childNode = childNode->NextSibling(TEXT("PluginDlg")))
5463  	{
5464  		TiXmlElement *dlgElement = childNode->ToElement();
5465  		const TCHAR *name = dlgElement->Attribute(TEXT("pluginName"));
5466  		TiXmlElement PDNode(TEXT("PluginDlg"));
5467  		int id;
5468  		const TCHAR *idStr = dlgElement->Attribute(TEXT("id"), &id);
5469  		if (name && idStr)
5470  		{
5471  			int curr = 0; 
5472  			int prev = 0; 
5473  			dlgElement->Attribute(TEXT("curr"), &curr);
5474  			dlgElement->Attribute(TEXT("prev"), &prev);
5475  			bool isVisible = false;
5476  			const TCHAR *val = dlgElement->Attribute(TEXT("isVisible"));
5477  			if (val)
5478  			{
5479  				isVisible = (lstrcmp(val, TEXT("yes")) == 0);
5480  			}
5481  			PDNode.SetAttribute(TEXT("pluginName"), name);
5482  			PDNode.SetAttribute(TEXT("id"), idStr);
5483  			PDNode.SetAttribute(TEXT("curr"), curr);
5484  			PDNode.SetAttribute(TEXT("prev"), prev);
5485  			PDNode.SetAttribute(TEXT("isVisible"), isVisible ? TEXT("yes") : TEXT("no"));
5486  			dockMngElmt2Clone->InsertEndChild(PDNode);
5487  		}
5488  	}
5489  	for (TiXmlNode *childNode = dockMngNode->FirstChildElement(TEXT("ActiveTabs"));
5490  		childNode;
5491  		childNode = childNode->NextSibling(TEXT("ActiveTabs")))
5492  	{
5493  		TiXmlElement *dlgElement = childNode->ToElement();
5494  		TiXmlElement CTNode(TEXT("ActiveTabs"));
5495  		int cont;
5496  		if (dlgElement->Attribute(TEXT("cont"), &cont))
5497  		{
5498  			int activeTab = 0;
5499  			dlgElement->Attribute(TEXT("activeTab"), &activeTab);
5500  			CTNode.SetAttribute(TEXT("cont"), cont);
5501  			CTNode.SetAttribute(TEXT("activeTab"), activeTab);
5502  			dockMngElmt2Clone->InsertEndChild(CTNode);
5503  		}
5504  	}
5505  }
5506  bool NppParameters::writeScintillaParams()
5507  {
5508  	if (!_pXmlUserDoc) return false;
5509  	const TCHAR *pViewName = TEXT("ScintillaPrimaryView");
5510  	TiXmlNode *nppRoot = _pXmlUserDoc->FirstChild(TEXT("NotepadPlus"));
5511  	if (!nppRoot)
5512  	{
5513  		nppRoot = _pXmlUserDoc->InsertEndChild(TiXmlElement(TEXT("NotepadPlus")));
5514  	}
5515  	TiXmlNode *configsRoot = nppRoot->FirstChildElement(TEXT("GUIConfigs"));
5516  	if (!configsRoot)
5517  	{
5518  		configsRoot = nppRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfigs")));
5519  	}
5520  	TiXmlNode *scintNode = getChildElementByAttribut(configsRoot, TEXT("GUIConfig"), TEXT("name"), pViewName);
5521  	if (!scintNode)
5522  	{
5523  		scintNode = configsRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig")));
5524  		(scintNode->ToElement())->SetAttribute(TEXT("name"), pViewName);
5525  	}
5526  	auto setYesNoBoolAttribute = [&scintNode](const TCHAR* name, bool value) -> void {
5527  		const TCHAR* pStr = value ? TEXT("yes") : TEXT("no");
5528  		(scintNode->ToElement())->SetAttribute(name, pStr);
5529  	};
5530  	auto setShowHideBoolAttribute = [&scintNode](const TCHAR* name, bool value) -> void {
5531  		const TCHAR* pStr = value ? TEXT("show") : TEXT("hide");
5532  		(scintNode->ToElement())->SetAttribute(name, pStr);
5533  	};
5534  	(scintNode->ToElement())->SetAttribute(TEXT("lineNumberMargin"), _svp._lineNumberMarginShow?TEXT("show"):TEXT("hide"));
5535  	(scintNode->ToElement())->SetAttribute(TEXT("lineNumberDynamicWidth"), _svp._lineNumberMarginDynamicWidth ?TEXT("yes"):TEXT("no"));
5536  	(scintNode->ToElement())->SetAttribute(TEXT("bookMarkMargin"), _svp._bookMarkMarginShow?TEXT("show"):TEXT("hide"));
5537  	(scintNode->ToElement())->SetAttribute(TEXT("indentGuideLine"), _svp._indentGuideLineShow?TEXT("show"):TEXT("hide"));
5538  	const TCHAR *pFolderStyleStr = (_svp._folderStyle == FOLDER_STYLE_SIMPLE)?TEXT("simple"):
5539  									(_svp._folderStyle == FOLDER_STYLE_ARROW)?TEXT("arrow"):
5540  										(_svp._folderStyle == FOLDER_STYLE_CIRCLE)?TEXT("circle"):
5541  										(_svp._folderStyle == FOLDER_STYLE_NONE)?TEXT("none"):TEXT("box");
5542  	(scintNode->ToElement())->SetAttribute(TEXT("folderMarkStyle"), pFolderStyleStr);
5543  	(scintNode->ToElement())->SetAttribute(TEXT("isChangeHistoryEnabled"), _svp._isChangeHistoryEnabled4NextSession ? TEXT("yes") : TEXT("no"));
5544  	const TCHAR *pWrapMethodStr = (_svp._lineWrapMethod == LINEWRAP_ALIGNED)?TEXT("aligned"):
5545  								(_svp._lineWrapMethod == LINEWRAP_INDENT)?TEXT("indent"):TEXT("default");
5546  	(scintNode->ToElement())->SetAttribute(TEXT("lineWrapMethod"), pWrapMethodStr);
5547  	(scintNode->ToElement())->SetAttribute(TEXT("currentLineIndicator"), _svp._currentLineHiliteMode);
5548  	(scintNode->ToElement())->SetAttribute(TEXT("currentLineFrameWidth"), _svp._currentLineFrameWidth);
5549  	(scintNode->ToElement())->SetAttribute(TEXT("virtualSpace"), _svp._virtualSpace?TEXT("yes"):TEXT("no"));
5550  	(scintNode->ToElement())->SetAttribute(TEXT("scrollBeyondLastLine"), _svp._scrollBeyondLastLine?TEXT("yes"):TEXT("no"));
5551  	(scintNode->ToElement())->SetAttribute(TEXT("rightClickKeepsSelection"), _svp._rightClickKeepsSelection ? TEXT("yes") : TEXT("no"));
5552  	(scintNode->ToElement())->SetAttribute(TEXT("disableAdvancedScrolling"), _svp._disableAdvancedScrolling?TEXT("yes"):TEXT("no"));
5553  	(scintNode->ToElement())->SetAttribute(TEXT("wrapSymbolShow"), _svp._wrapSymbolShow?TEXT("show"):TEXT("hide"));
5554  	(scintNode->ToElement())->SetAttribute(TEXT("Wrap"), _svp._doWrap?TEXT("yes"):TEXT("no"));
5555  	(scintNode->ToElement())->SetAttribute(TEXT("borderEdge"), _svp._showBorderEdge ? TEXT("yes") : TEXT("no"));
5556  	generic_string edgeColumnPosStr;
5557  	for (auto i : _svp._edgeMultiColumnPos)
5558  	{
5559  		std::string s = std::to_string(i);
5560  		edgeColumnPosStr += generic_string(s.begin(), s.end());
5561  		edgeColumnPosStr += TEXT(" ");
5562  	}
5563  	(scintNode->ToElement())->SetAttribute(TEXT("isEdgeBgMode"), _svp._isEdgeBgMode ? TEXT("yes") : TEXT("no"));
5564  	(scintNode->ToElement())->SetAttribute(TEXT("edgeMultiColumnPos"), edgeColumnPosStr);
5565  	(scintNode->ToElement())->SetAttribute(TEXT("zoom"), static_cast<int>(_svp._zoom));
5566  	(scintNode->ToElement())->SetAttribute(TEXT("zoom2"), static_cast<int>(_svp._zoom2));
5567  	(scintNode->ToElement())->SetAttribute(TEXT("whiteSpaceShow"), _svp._whiteSpaceShow?TEXT("show"):TEXT("hide"));
5568  	(scintNode->ToElement())->SetAttribute(TEXT("eolShow"), _svp._eolShow?TEXT("show"):TEXT("hide"));
5569  	(scintNode->ToElement())->SetAttribute(TEXT("eolMode"), _svp._eolMode);
5570  	setShowHideBoolAttribute(TEXT("npcShow"), _svp._npcShow);
5571  	(scintNode->ToElement())->SetAttribute(TEXT("npcMode"), static_cast<int>(_svp._npcMode));
5572  	setYesNoBoolAttribute(TEXT("npcCustomColor"), _svp._npcCustomColor);
5573  	setYesNoBoolAttribute(TEXT("npcIncludeCcUniEOL"), _svp._npcIncludeCcUniEol);
5574  	setYesNoBoolAttribute(TEXT("ccShow"), _svp._ccUniEolShow);
5575  	(scintNode->ToElement())->SetAttribute(TEXT("borderWidth"), _svp._borderWidth);
5576  	(scintNode->ToElement())->SetAttribute(TEXT("smoothFont"), _svp._doSmoothFont ? TEXT("yes") : TEXT("no"));
5577  	(scintNode->ToElement())->SetAttribute(TEXT("paddingLeft"), _svp._paddingLeft);
5578  	(scintNode->ToElement())->SetAttribute(TEXT("paddingRight"), _svp._paddingRight);
5579  	(scintNode->ToElement())->SetAttribute(TEXT("distractionFreeDivPart"), _svp._distractionFreeDivPart);
5580  	return true;
5581  }
5582  void NppParameters::createXmlTreeFromGUIParams()
5583  {
5584  	TiXmlNode *nppRoot = _pXmlUserDoc->FirstChild(TEXT("NotepadPlus"));
5585  	if (!nppRoot)
5586  	{
5587  		nppRoot = _pXmlUserDoc->InsertEndChild(TiXmlElement(TEXT("NotepadPlus")));
5588  	}
5589  	TiXmlNode *oldGUIRoot = nppRoot->FirstChildElement(TEXT("GUIConfigs"));
5590  	TiXmlElement* dockMngNodeDup = nullptr;
5591  	TiXmlNode* dockMngNodeOriginal = nullptr;
5592  	if (oldGUIRoot && _nppGUI._isCmdlineNosessionActivated)
5593  	{
5594  		for (TiXmlNode *childNode = oldGUIRoot->FirstChildElement(TEXT("GUIConfig"));
5595  			childNode;
5596  			childNode = childNode->NextSibling(TEXT("GUIConfig")))
5597  		{
5598  			TiXmlElement* element = childNode->ToElement();
5599  			const TCHAR* nm = element->Attribute(TEXT("name"));
5600  			if (nullptr == nm)
5601  				continue;
5602  			if (!lstrcmp(nm, TEXT("DockingManager")))
5603  			{
5604  				dockMngNodeOriginal = childNode;
5605  				break;
5606  			}
5607  		}
5608  		if (dockMngNodeOriginal)
5609  		{
5610  			dockMngNodeDup = new TiXmlElement(TEXT("GUIConfig"));
5611  			dockMngNodeDup->SetAttribute(TEXT("name"), TEXT("DockingManager"));
5612  			duplicateDockingManager(dockMngNodeOriginal, dockMngNodeDup);
5613  		}
5614  	}
5615  	if (oldGUIRoot)
5616  	{
5617  		nppRoot->RemoveChild(oldGUIRoot);
5618  	}
5619  	TiXmlNode *newGUIRoot = nppRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfigs")));
5620  	{
5621  		TiXmlElement *GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5622  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("ToolBar"));
5623  		const TCHAR *pStr = (_nppGUI._toolbarShow) ? TEXT("yes") : TEXT("no");
5624  		GUIConfigElement->SetAttribute(TEXT("visible"), pStr);
5625  		if (_nppGUI._toolBarStatus == TB_SMALL)
5626  			pStr = TEXT("small");
5627  		else if (_nppGUI._toolBarStatus == TB_LARGE)
5628  			pStr = TEXT("large");
5629  		else if (_nppGUI._toolBarStatus == TB_SMALL2)
5630  			pStr = TEXT("small2");
5631  		else if (_nppGUI._toolBarStatus == TB_LARGE2)
5632  			pStr = TEXT("large2");
5633  		else 
5634  			pStr = TEXT("standard");
5635  		GUIConfigElement->InsertEndChild(TiXmlText(pStr));
5636  	}
5637  	{
5638  		TiXmlElement *GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5639  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("StatusBar"));
5640  		const TCHAR *pStr = _nppGUI._statusBarShow ? TEXT("show") : TEXT("hide");
5641  		GUIConfigElement->InsertEndChild(TiXmlText(pStr));
5642  	}
5643  	{
5644  		TiXmlElement *GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5645  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("TabBar"));
5646  		const TCHAR *pStr = (_nppGUI._tabStatus & TAB_DRAWTOPBAR) ? TEXT("yes") : TEXT("no");
5647  		GUIConfigElement->SetAttribute(TEXT("dragAndDrop"), pStr);
5648  		pStr = (_nppGUI._tabStatus & TAB_DRAGNDROP) ? TEXT("yes") : TEXT("no");
5649  		GUIConfigElement->SetAttribute(TEXT("drawTopBar"), pStr);
5650  		pStr = (_nppGUI._tabStatus & TAB_DRAWINACTIVETAB) ? TEXT("yes") : TEXT("no");
5651  		GUIConfigElement->SetAttribute(TEXT("drawInactiveTab"), pStr);
5652  		pStr = (_nppGUI._tabStatus & TAB_REDUCE) ? TEXT("yes") : TEXT("no");
5653  		GUIConfigElement->SetAttribute(TEXT("reduce"), pStr);
5654  		pStr = (_nppGUI._tabStatus & TAB_CLOSEBUTTON) ? TEXT("yes") : TEXT("no");
5655  		GUIConfigElement->SetAttribute(TEXT("closeButton"), pStr);
5656  		pStr = (_nppGUI._tabStatus & TAB_DBCLK2CLOSE) ? TEXT("yes") : TEXT("no");
5657  		GUIConfigElement->SetAttribute(TEXT("doubleClick2Close"), pStr);
5658  		pStr = (_nppGUI._tabStatus & TAB_VERTICAL) ? TEXT("yes") : TEXT("no");
5659  		GUIConfigElement->SetAttribute(TEXT("vertical"), pStr);
5660  		pStr = (_nppGUI._tabStatus & TAB_MULTILINE) ? TEXT("yes") : TEXT("no");
5661  		GUIConfigElement->SetAttribute(TEXT("multiLine"), pStr);
5662  		pStr = (_nppGUI._tabStatus & TAB_HIDE) ? TEXT("yes") : TEXT("no");
5663  		GUIConfigElement->SetAttribute(TEXT("hide"), pStr);
5664  		pStr = (_nppGUI._tabStatus & TAB_QUITONEMPTY) ? TEXT("yes") : TEXT("no");
5665  		GUIConfigElement->SetAttribute(TEXT("quitOnEmpty"), pStr);
5666  		pStr = (_nppGUI._tabStatus & TAB_ALTICONS) ? TEXT("1") : TEXT("0");
5667  		GUIConfigElement->SetAttribute(TEXT("iconSetNumber"), pStr);
5668  	}
5669  	{
5670  		TiXmlElement *GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5671  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("ScintillaViewsSplitter"));
5672  		const TCHAR *pStr = _nppGUI._splitterPos == POS_VERTICAL ? TEXT("vertical") : TEXT("horizontal");
5673  		GUIConfigElement->InsertEndChild(TiXmlText(pStr));
5674  	}
5675  	{
5676  		TiXmlElement *GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5677  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("UserDefineDlg"));
5678  		const TCHAR *pStr = (_nppGUI._userDefineDlgStatus & UDD_DOCKED) ? TEXT("docked") : TEXT("undocked");
5679  		GUIConfigElement->SetAttribute(TEXT("position"), pStr);
5680  		pStr = (_nppGUI._userDefineDlgStatus & UDD_SHOW) ? TEXT("show") : TEXT("hide");
5681  		GUIConfigElement->InsertEndChild(TiXmlText(pStr));
5682  	}
5683  	{
5684  		TiXmlElement *GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5685  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("TabSetting"));
5686  		const TCHAR *pStr = _nppGUI._tabReplacedBySpace ? TEXT("yes") : TEXT("no");
5687  		GUIConfigElement->SetAttribute(TEXT("replaceBySpace"), pStr);
5688  		GUIConfigElement->SetAttribute(TEXT("size"), _nppGUI._tabSize);
5689  	}
5690  	{
5691  		TiXmlElement *GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5692  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("AppPosition"));
5693  		GUIConfigElement->SetAttribute(TEXT("x"), _nppGUI._appPos.left);
5694  		GUIConfigElement->SetAttribute(TEXT("y"), _nppGUI._appPos.top);
5695  		GUIConfigElement->SetAttribute(TEXT("width"), _nppGUI._appPos.right);
5696  		GUIConfigElement->SetAttribute(TEXT("height"), _nppGUI._appPos.bottom);
5697  		GUIConfigElement->SetAttribute(TEXT("isMaximized"), _nppGUI._isMaximized ? TEXT("yes") : TEXT("no"));
5698  	}
5699  	{
5700  		TiXmlElement* GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5701  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("FindWindowPosition"));
5702  		GUIConfigElement->SetAttribute(TEXT("left"), _nppGUI._findWindowPos.left);
5703  		GUIConfigElement->SetAttribute(TEXT("top"), _nppGUI._findWindowPos.top);
5704  		GUIConfigElement->SetAttribute(TEXT("right"), _nppGUI._findWindowPos.right);
5705  		GUIConfigElement->SetAttribute(TEXT("bottom"), _nppGUI._findWindowPos.bottom);
5706  		GUIConfigElement->SetAttribute(TEXT("isLessModeOn"), _nppGUI._findWindowLessMode ? TEXT("yes") : TEXT("no"));
5707  	}
5708  	{
5709  		TiXmlElement* GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5710  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("FinderConfig"));
5711  		const TCHAR* pStr = _nppGUI._finderLinesAreCurrentlyWrapped ? TEXT("yes") : TEXT("no");
5712  		GUIConfigElement->SetAttribute(TEXT("wrappedLines"), pStr);
5713  		pStr = _nppGUI._finderPurgeBeforeEverySearch ? TEXT("yes") : TEXT("no");
5714  		GUIConfigElement->SetAttribute(TEXT("purgeBeforeEverySearch"), pStr);
5715  		pStr = _nppGUI._finderShowOnlyOneEntryPerFoundLine ? TEXT("yes") : TEXT("no");
5716  		GUIConfigElement->SetAttribute(TEXT("showOnlyOneEntryPerFoundLine"), pStr);
5717  	}
5718  	{
5719  		TiXmlElement *element = insertGUIConfigBoolNode(newGUIRoot, TEXT("noUpdate"), !_nppGUI._autoUpdateOpt._doAutoUpdate);
5720  		element->SetAttribute(TEXT("intervalDays"), _nppGUI._autoUpdateOpt._intervalDays);
5721  		element->SetAttribute(TEXT("nextUpdateDate"), _nppGUI._autoUpdateOpt._nextUpdateDate.toString().c_str());
5722  	}
5723  	{
5724  		const TCHAR *pStr = TEXT("no");
5725  		if (_nppGUI._fileAutoDetection & cdEnabledOld)
5726  		{
5727  			pStr = TEXT("yesOld");
5728  			if ((_nppGUI._fileAutoDetection & cdAutoUpdate) && (_nppGUI._fileAutoDetection & cdGo2end))
5729  			{
5730  				pStr = TEXT("autoUpdate2EndOld");
5731  			}
5732  			else if (_nppGUI._fileAutoDetection & cdAutoUpdate)
5733  			{
5734  				pStr = TEXT("autoOld");
5735  			}
5736  			else if (_nppGUI._fileAutoDetection & cdGo2end)
5737  			{
5738  				pStr = TEXT("Update2EndOld");
5739  			}
5740  		}
5741  		else if (_nppGUI._fileAutoDetection & cdEnabledNew)
5742  		{
5743  			pStr = TEXT("yes");
5744  			if ((_nppGUI._fileAutoDetection & cdAutoUpdate) && (_nppGUI._fileAutoDetection & cdGo2end))
5745  			{
5746  				pStr = TEXT("autoUpdate2End");
5747  			}
5748  			else if (_nppGUI._fileAutoDetection & cdAutoUpdate)
5749  			{
5750  				pStr = TEXT("auto");
5751  			}
5752  			else if (_nppGUI._fileAutoDetection & cdGo2end)
5753  			{
5754  				pStr = TEXT("Update2End");
5755  			}
5756  		}
5757  		TiXmlElement *GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5758  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("Auto-detection"));
5759  		GUIConfigElement->InsertEndChild(TiXmlText(pStr));
5760  	}
5761  	{
5762  		insertGUIConfigBoolNode(newGUIRoot, TEXT("CheckHistoryFiles"), _nppGUI._checkHistoryFiles);
5763  	}
5764  	{
5765  		insertGUIConfigBoolNode(newGUIRoot, TEXT("TrayIcon"), _nppGUI._isMinimizedToTray);
5766  	}
5767  	{
5768  		insertGUIConfigBoolNode(newGUIRoot, TEXT("MaitainIndent"), _nppGUI._maitainIndent);
5769  	}
5770  	{
5771  		TiXmlElement * ele = insertGUIConfigBoolNode(newGUIRoot, TEXT("TagsMatchHighLight"), _nppGUI._enableTagsMatchHilite);
5772  		ele->SetAttribute(TEXT("TagAttrHighLight"), _nppGUI._enableTagAttrsHilite ? TEXT("yes") : TEXT("no"));
5773  		ele->SetAttribute(TEXT("HighLightNonHtmlZone"), _nppGUI._enableHiliteNonHTMLZone ? TEXT("yes") : TEXT("no"));
5774  	}
5775  	{
5776  		insertGUIConfigBoolNode(newGUIRoot, TEXT("RememberLastSession"), _nppGUI._rememberLastSession);
5777  	}
5778  	{
5779  		insertGUIConfigBoolNode(newGUIRoot, TEXT("DetectEncoding"), _nppGUI._detectEncoding);
5780  	}
5781  	{
5782  		insertGUIConfigBoolNode(newGUIRoot, TEXT("SaveAllConfirm"), _nppGUI._saveAllConfirm);
5783  	}
5784  	{
5785  		TiXmlElement *GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5786  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("NewDocDefaultSettings"));
5787  		GUIConfigElement->SetAttribute(TEXT("format"), static_cast<int32_t>(_nppGUI._newDocDefaultSettings._format));
5788  		GUIConfigElement->SetAttribute(TEXT("encoding"), _nppGUI._newDocDefaultSettings._unicodeMode);
5789  		GUIConfigElement->SetAttribute(TEXT("lang"), _nppGUI._newDocDefaultSettings._lang);
5790  		GUIConfigElement->SetAttribute(TEXT("codepage"), _nppGUI._newDocDefaultSettings._codepage);
5791  		GUIConfigElement->SetAttribute(TEXT("openAnsiAsUTF8"), _nppGUI._newDocDefaultSettings._openAnsiAsUtf8 ? TEXT("yes") : TEXT("no"));
5792  	}
5793  	{
5794  		TiXmlElement *GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5795  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("langsExcluded"));
5796  		writeExcludedLangList(GUIConfigElement);
5797  		GUIConfigElement->SetAttribute(TEXT("langMenuCompact"), _nppGUI._isLangMenuCompact ? TEXT("yes") : TEXT("no"));
5798  	}
5799  	{
5800  		TiXmlElement *GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5801  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("Print"));
5802  		writePrintSetting(GUIConfigElement);
5803  	}
5804  	{
5805  		TiXmlElement *GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5806  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("Backup"));
5807  		GUIConfigElement->SetAttribute(TEXT("action"), _nppGUI._backup);
5808  		GUIConfigElement->SetAttribute(TEXT("useCustumDir"), _nppGUI._useDir ? TEXT("yes") : TEXT("no"));
5809  		GUIConfigElement->SetAttribute(TEXT("dir"), _nppGUI._backupDir.c_str());
5810  		GUIConfigElement->SetAttribute(TEXT("isSnapshotMode"), _nppGUI._isSnapshotMode ? TEXT("yes") : TEXT("no"));
5811  		GUIConfigElement->SetAttribute(TEXT("snapshotBackupTiming"), static_cast<int32_t>(_nppGUI._snapshotBackupTiming));
5812  	}
5813  	{
5814  		insertGUIConfigBoolNode(newGUIRoot, TEXT("TaskList"), _nppGUI._doTaskList);
5815  	}
5816  	{
5817  		insertGUIConfigBoolNode(newGUIRoot, TEXT("MRU"), _nppGUI._styleMRU);
5818  	}
5819  	{
5820  		TCHAR szStr [12] = TEXT("0");
5821  		_itow(_nppGUI._styleURL, szStr, 10);
5822  		TiXmlElement *GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5823  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("URL"));
5824  		GUIConfigElement->InsertEndChild(TiXmlText(szStr));
5825  	}
5826  	{
5827  		TiXmlElement *GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5828  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("uriCustomizedSchemes"));
5829  		GUIConfigElement->InsertEndChild(TiXmlText(_nppGUI._uriSchemes.c_str()));
5830  	}
5831  	{
5832  		TiXmlElement *GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5833  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("globalOverride"));
5834  		GUIConfigElement->SetAttribute(TEXT("fg"), _nppGUI._globalOverride.enableFg ? TEXT("yes") : TEXT("no"));
5835  		GUIConfigElement->SetAttribute(TEXT("bg"), _nppGUI._globalOverride.enableBg ? TEXT("yes") : TEXT("no"));
5836  		GUIConfigElement->SetAttribute(TEXT("font"), _nppGUI._globalOverride.enableFont ? TEXT("yes") : TEXT("no"));
5837  		GUIConfigElement->SetAttribute(TEXT("fontSize"), _nppGUI._globalOverride.enableFontSize ? TEXT("yes") : TEXT("no"));
5838  		GUIConfigElement->SetAttribute(TEXT("bold"), _nppGUI._globalOverride.enableBold ? TEXT("yes") : TEXT("no"));
5839  		GUIConfigElement->SetAttribute(TEXT("italic"), _nppGUI._globalOverride.enableItalic ? TEXT("yes") : TEXT("no"));
5840  		GUIConfigElement->SetAttribute(TEXT("underline"), _nppGUI._globalOverride.enableUnderLine ? TEXT("yes") : TEXT("no"));
5841  	}
5842  	{
5843  		TiXmlElement *GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5844  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("auto-completion"));
5845  		GUIConfigElement->SetAttribute(TEXT("autoCAction"), _nppGUI._autocStatus);
5846  		GUIConfigElement->SetAttribute(TEXT("triggerFromNbChar"), static_cast<int32_t>(_nppGUI._autocFromLen));
5847  		const TCHAR * pStr = _nppGUI._autocIgnoreNumbers ? TEXT("yes") : TEXT("no");
5848  		GUIConfigElement->SetAttribute(TEXT("autoCIgnoreNumbers"), pStr);
5849  		pStr = _nppGUI._autocInsertSelectedUseENTER ? TEXT("yes") : TEXT("no");
5850  		GUIConfigElement->SetAttribute(TEXT("insertSelectedItemUseENTER"), pStr);
5851  		pStr = _nppGUI._autocInsertSelectedUseTAB ? TEXT("yes") : TEXT("no");
5852  		GUIConfigElement->SetAttribute(TEXT("insertSelectedItemUseTAB"), pStr);
5853  		pStr = _nppGUI._autocBrief ? TEXT("yes") : TEXT("no");
5854  		GUIConfigElement->SetAttribute(TEXT("autoCBrief"), pStr);
5855  		pStr = _nppGUI._funcParams ? TEXT("yes") : TEXT("no");
5856  		GUIConfigElement->SetAttribute(TEXT("funcParams"), pStr);
5857  	}
5858  	{
5859  		TiXmlElement *GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5860  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("auto-insert"));
5861  		GUIConfigElement->SetAttribute(TEXT("parentheses"), _nppGUI._matchedPairConf._doParentheses ? TEXT("yes") : TEXT("no"));
5862  		GUIConfigElement->SetAttribute(TEXT("brackets"), _nppGUI._matchedPairConf._doBrackets ? TEXT("yes") : TEXT("no"));
5863  		GUIConfigElement->SetAttribute(TEXT("curlyBrackets"), _nppGUI._matchedPairConf._doCurlyBrackets ? TEXT("yes") : TEXT("no"));
5864  		GUIConfigElement->SetAttribute(TEXT("quotes"), _nppGUI._matchedPairConf._doQuotes ? TEXT("yes") : TEXT("no"));
5865  		GUIConfigElement->SetAttribute(TEXT("doubleQuotes"), _nppGUI._matchedPairConf._doDoubleQuotes ? TEXT("yes") : TEXT("no"));
5866  		GUIConfigElement->SetAttribute(TEXT("htmlXmlTag"), _nppGUI._matchedPairConf._doHtmlXmlTag ? TEXT("yes") : TEXT("no"));
5867  		TiXmlElement hist_element{ TEXT("") };
5868  		hist_element.SetValue(TEXT("UserDefinePair"));
5869  		for (size_t i = 0, nb = _nppGUI._matchedPairConf._matchedPairs.size(); i < nb; ++i)
5870  		{
5871  			int open = _nppGUI._matchedPairConf._matchedPairs[i].first;
5872  			int close = _nppGUI._matchedPairConf._matchedPairs[i].second;
5873  			(hist_element.ToElement())->SetAttribute(TEXT("open"), open);
5874  			(hist_element.ToElement())->SetAttribute(TEXT("close"), close);
5875  			GUIConfigElement->InsertEndChild(hist_element);
5876  		}
5877  	}
5878  	{
5879  		TiXmlElement *GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5880  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("sessionExt"));
5881  		GUIConfigElement->InsertEndChild(TiXmlText(_nppGUI._definedSessionExt.c_str()));
5882  	}
5883  	{
5884  		TiXmlElement *GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5885  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("workspaceExt"));
5886  		GUIConfigElement->InsertEndChild(TiXmlText(_nppGUI._definedWorkspaceExt.c_str()));
5887  	}
5888  	{
5889  		TiXmlElement *GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5890  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("MenuBar"));
5891  		GUIConfigElement->InsertEndChild(TiXmlText(_nppGUI._menuBarShow ? TEXT("show") : TEXT("hide")));
5892  	}
5893  	{
5894  		TiXmlElement *GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5895  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("Caret"));
5896  		GUIConfigElement->SetAttribute(TEXT("width"), _nppGUI._caretWidth);
5897  		GUIConfigElement->SetAttribute(TEXT("blinkRate"), _nppGUI._caretBlinkRate);
5898  	}
5899  	{
5900  		TiXmlElement *GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5901  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("ScintillaGlobalSettings"));
5902  		GUIConfigElement->SetAttribute(TEXT("enableMultiSelection"), _nppGUI._enableMultiSelection ? TEXT("yes") : TEXT("no"));
5903  	}
5904  	{
5905  		TiXmlElement *GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5906  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("openSaveDir"));
5907  		GUIConfigElement->SetAttribute(TEXT("value"), _nppGUI._openSaveDir);
5908  		GUIConfigElement->SetAttribute(TEXT("defaultDirPath"), _nppGUI._defaultDir);
5909  	}
5910  	{
5911  		TiXmlElement *GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5912  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("titleBar"));
5913  		const TCHAR *pStr = (_nppGUI._shortTitlebar) ? TEXT("yes") : TEXT("no");
5914  		GUIConfigElement->SetAttribute(TEXT("short"), pStr);
5915  	}
5916  	{
5917  		TiXmlElement* GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5918  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("insertDateTime"));
5919  		GUIConfigElement->SetAttribute(TEXT("customizedFormat"), _nppGUI._dateTimeFormat.c_str());
5920  		const TCHAR* pStr = (_nppGUI._dateTimeReverseDefaultOrder) ? TEXT("yes") : TEXT("no");
5921  		GUIConfigElement->SetAttribute(TEXT("reverseDefaultOrder"), pStr);
5922  	}
5923  	{
5924  		TiXmlElement *GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5925  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("wordCharList"));
5926  		GUIConfigElement->SetAttribute(TEXT("useDefault"), _nppGUI._isWordCharDefault ? TEXT("yes") : TEXT("no"));
5927  		WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
5928  		const wchar_t* charsAddStr = wmc.char2wchar(_nppGUI._customWordChars.c_str(), SC_CP_UTF8);
5929  		GUIConfigElement->SetAttribute(TEXT("charsAdded"), charsAddStr);
5930  	}
5931  	{
5932  		TiXmlElement *GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5933  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("delimiterSelection"));
5934  		GUIConfigElement->SetAttribute(TEXT("leftmostDelimiter"), _nppGUI._leftmostDelimiter);
5935  		GUIConfigElement->SetAttribute(TEXT("rightmostDelimiter"), _nppGUI._rightmostDelimiter);
5936  		GUIConfigElement->SetAttribute(TEXT("delimiterSelectionOnEntireDocument"), _nppGUI._delimiterSelectionOnEntireDocument ? TEXT("yes") : TEXT("no"));
5937  	}
5938  	{
5939  		TiXmlElement *GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5940  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("largeFileRestriction"));
5941  		GUIConfigElement->SetAttribute(TEXT("fileSizeMB"), static_cast<int>((_nppGUI._largeFileRestriction._largeFileSizeDefInByte / 1024) / 1024));
5942  		GUIConfigElement->SetAttribute(TEXT("isEnabled"), _nppGUI._largeFileRestriction._isEnabled ? TEXT("yes") : TEXT("no"));
5943  		GUIConfigElement->SetAttribute(TEXT("allowAutoCompletion"), _nppGUI._largeFileRestriction._allowAutoCompletion ? TEXT("yes") : TEXT("no"));
5944  		GUIConfigElement->SetAttribute(TEXT("allowBraceMatch"), _nppGUI._largeFileRestriction._allowBraceMatch ? TEXT("yes") : TEXT("no"));
5945  		GUIConfigElement->SetAttribute(TEXT("allowSmartHilite"), _nppGUI._largeFileRestriction._allowSmartHilite ? TEXT("yes") : TEXT("no"));
5946  		GUIConfigElement->SetAttribute(TEXT("allowClickableLink"), _nppGUI._largeFileRestriction._allowClickableLink ? TEXT("yes") : TEXT("no"));
5947  		GUIConfigElement->SetAttribute(TEXT("deactivateWordWrap"), _nppGUI._largeFileRestriction._deactivateWordWrap ? TEXT("yes") : TEXT("no"));
5948  	}
5949  	{
5950  		TiXmlElement *GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5951  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("multiInst"));
5952  		GUIConfigElement->SetAttribute(TEXT("setting"), _nppGUI._multiInstSetting);
5953  		auto setYesNoBoolAttribute = [&GUIConfigElement](const TCHAR* name, bool value) -> void {
5954  			const TCHAR* pStr = value ? TEXT("yes") : TEXT("no");
5955  			GUIConfigElement->SetAttribute(name, pStr);
5956  		};
5957  		setYesNoBoolAttribute(TEXT("clipboardHistory"), _nppGUI._clipboardHistoryPanelKeepState);
5958  		setYesNoBoolAttribute(TEXT("documentList"), _nppGUI._docListKeepState);
5959  		setYesNoBoolAttribute(TEXT("characterPanel"), _nppGUI._charPanelKeepState);
5960  		setYesNoBoolAttribute(TEXT("folderAsWorkspace"), _nppGUI._fileBrowserKeepState);
5961  		setYesNoBoolAttribute(TEXT("projectPanels"), _nppGUI._projectPanelKeepState);
5962  		setYesNoBoolAttribute(TEXT("documentMap"), _nppGUI._docMapKeepState);
5963  		setYesNoBoolAttribute(TEXT("fuctionList"), _nppGUI._funcListKeepState);
5964  		setYesNoBoolAttribute(TEXT("pluginPanels"), _nppGUI._pluginPanelKeepState);
5965  	}
5966  	{
5967  		TiXmlElement *GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5968  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("MISC"));
5969  		auto setYesNoBoolAttribute = [&GUIConfigElement](const TCHAR* name, bool value) -> void {
5970  			const TCHAR* pStr = value ? TEXT("yes") : TEXT("no");
5971  			GUIConfigElement->SetAttribute(name, pStr);
5972  		};
5973  		GUIConfigElement->SetAttribute(TEXT("fileSwitcherWithoutExtColumn"), _nppGUI._fileSwitcherWithoutExtColumn ? TEXT("yes") : TEXT("no"));
5974  		GUIConfigElement->SetAttribute(TEXT("fileSwitcherExtWidth"), _nppGUI._fileSwitcherExtWidth);
5975  		GUIConfigElement->SetAttribute(TEXT("fileSwitcherWithoutPathColumn"), _nppGUI._fileSwitcherWithoutPathColumn ? TEXT("yes") : TEXT("no"));
5976  		GUIConfigElement->SetAttribute(TEXT("fileSwitcherPathWidth"), _nppGUI._fileSwitcherPathWidth);
5977  		setYesNoBoolAttribute(TEXT("fileSwitcherNoGroups"), _nppGUI._fileSwitcherDisableListViewGroups);
5978  		GUIConfigElement->SetAttribute(TEXT("backSlashIsEscapeCharacterForSql"), _nppGUI._backSlashIsEscapeCharacterForSql ? TEXT("yes") : TEXT("no"));
5979  		GUIConfigElement->SetAttribute(TEXT("writeTechnologyEngine"), _nppGUI._writeTechnologyEngine);
5980  		GUIConfigElement->SetAttribute(TEXT("isFolderDroppedOpenFiles"), _nppGUI._isFolderDroppedOpenFiles ? TEXT("yes") : TEXT("no"));
5981  		GUIConfigElement->SetAttribute(TEXT("docPeekOnTab"), _nppGUI._isDocPeekOnTab ? TEXT("yes") : TEXT("no"));
5982  		GUIConfigElement->SetAttribute(TEXT("docPeekOnMap"), _nppGUI._isDocPeekOnMap ? TEXT("yes") : TEXT("no"));
5983  		GUIConfigElement->SetAttribute(TEXT("sortFunctionList"), _nppGUI._shouldSortFunctionList ? TEXT("yes") : TEXT("no"));
5984  		GUIConfigElement->SetAttribute(TEXT("saveDlgExtFilterToAllTypes"), _nppGUI._setSaveDlgExtFiltToAllTypes ? TEXT("yes") : TEXT("no"));
5985  		GUIConfigElement->SetAttribute(TEXT("muteSounds"), _nppGUI._muteSounds ? TEXT("yes") : TEXT("no"));
5986  		GUIConfigElement->SetAttribute(TEXT("enableFoldCmdToggable"), _nppGUI._enableFoldCmdToggable ? TEXT("yes") : TEXT("no"));
5987  		GUIConfigElement->SetAttribute(TEXT("hideMenuRightShortcuts"), _nppGUI._hideMenuRightShortcuts ? TEXT("yes") : TEXT("no"));
5988  	}
5989  	{
5990  		TiXmlElement* GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5991  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("Searching"));
5992  		GUIConfigElement->SetAttribute(TEXT("monospacedFontFindDlg"), _nppGUI._monospacedFontFindDlg ? TEXT("yes") : TEXT("no"));
5993  		GUIConfigElement->SetAttribute(TEXT("fillFindFieldWithSelected"), _nppGUI._fillFindFieldWithSelected ? TEXT("yes") : TEXT("no"));
5994  		GUIConfigElement->SetAttribute(TEXT("fillFindFieldSelectCaret"), _nppGUI._fillFindFieldSelectCaret ? TEXT("yes") : TEXT("no"));
5995  		GUIConfigElement->SetAttribute(TEXT("findDlgAlwaysVisible"), _nppGUI._findDlgAlwaysVisible ? TEXT("yes") : TEXT("no"));
5996  		GUIConfigElement->SetAttribute(TEXT("confirmReplaceInAllOpenDocs"), _nppGUI._confirmReplaceInAllOpenDocs ? TEXT("yes") : TEXT("no"));
5997  		GUIConfigElement->SetAttribute(TEXT("replaceStopsWithoutFindingNext"), _nppGUI._replaceStopsWithoutFindingNext ? TEXT("yes") : TEXT("no"));
5998  	}
5999  	{
6000  		TiXmlElement *GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
6001  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("searchEngine"));
6002  		GUIConfigElement->SetAttribute(TEXT("searchEngineChoice"), _nppGUI._searchEngineChoice);
6003  		GUIConfigElement->SetAttribute(TEXT("searchEngineCustom"), _nppGUI._searchEngineCustom);
6004  	}
6005  	{
6006  		TiXmlElement* GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
6007  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("MarkAll"));
6008  		GUIConfigElement->SetAttribute(TEXT("matchCase"), _nppGUI._markAllCaseSensitive ? TEXT("yes") : TEXT("no"));
6009  		GUIConfigElement->SetAttribute(TEXT("wholeWordOnly"), _nppGUI._markAllWordOnly ? TEXT("yes") : TEXT("no"));
6010  	}
6011  	{
6012  		TiXmlElement *GUIConfigElement = insertGUIConfigBoolNode(newGUIRoot, TEXT("SmartHighLight"), _nppGUI._enableSmartHilite);
6013  		GUIConfigElement->SetAttribute(TEXT("matchCase"), _nppGUI._smartHiliteCaseSensitive ? TEXT("yes") : TEXT("no"));
6014  		GUIConfigElement->SetAttribute(TEXT("wholeWordOnly"), _nppGUI._smartHiliteWordOnly ? TEXT("yes") : TEXT("no"));
6015  		GUIConfigElement->SetAttribute(TEXT("useFindSettings"), _nppGUI._smartHiliteUseFindSettings ? TEXT("yes") : TEXT("no"));
6016  		GUIConfigElement->SetAttribute(TEXT("onAnotherView"), _nppGUI._smartHiliteOnAnotherView ? TEXT("yes") : TEXT("no"));
6017  	}
6018  	if (_nppGUI._commandLineInterpreter.compare(CMD_INTERPRETER))
6019  	{
6020  		TiXmlElement *GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
6021  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("commandLineInterpreter"));
6022  		GUIConfigElement->InsertEndChild(TiXmlText(_nppGUI._commandLineInterpreter.c_str()));
6023  	}
6024  	{
6025  		TiXmlElement* GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
6026  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("DarkMode"));
6027  		NppDarkMode::setAdvancedOptions();
6028  		auto setYesNoBoolAttribute = [&GUIConfigElement](const TCHAR* name, bool value) {
6029  			const TCHAR* pStr = value ? TEXT("yes") : TEXT("no");
6030  			GUIConfigElement->SetAttribute(name, pStr);
6031  		};
6032  		setYesNoBoolAttribute(TEXT("enable"), _nppGUI._darkmode._isEnabled);
6033  		GUIConfigElement->SetAttribute(TEXT("colorTone"), _nppGUI._darkmode._colorTone);
6034  		GUIConfigElement->SetAttribute(TEXT("customColorTop"), _nppGUI._darkmode._customColors.pureBackground);
6035  		GUIConfigElement->SetAttribute(TEXT("customColorMenuHotTrack"), _nppGUI._darkmode._customColors.hotBackground);
6036  		GUIConfigElement->SetAttribute(TEXT("customColorActive"), _nppGUI._darkmode._customColors.softerBackground);
6037  		GUIConfigElement->SetAttribute(TEXT("customColorMain"), _nppGUI._darkmode._customColors.background);
6038  		GUIConfigElement->SetAttribute(TEXT("customColorError"), _nppGUI._darkmode._customColors.errorBackground);
6039  		GUIConfigElement->SetAttribute(TEXT("customColorText"), _nppGUI._darkmode._customColors.text);
6040  		GUIConfigElement->SetAttribute(TEXT("customColorDarkText"), _nppGUI._darkmode._customColors.darkerText);
6041  		GUIConfigElement->SetAttribute(TEXT("customColorDisabledText"), _nppGUI._darkmode._customColors.disabledText);
6042  		GUIConfigElement->SetAttribute(TEXT("customColorLinkText"), _nppGUI._darkmode._customColors.linkText);
6043  		GUIConfigElement->SetAttribute(TEXT("customColorEdge"), _nppGUI._darkmode._customColors.edge);
6044  		GUIConfigElement->SetAttribute(TEXT("customColorHotEdge"), _nppGUI._darkmode._customColors.hotEdge);
6045  		GUIConfigElement->SetAttribute(TEXT("customColorDisabledEdge"), _nppGUI._darkmode._customColors.disabledEdge);
6046  		setYesNoBoolAttribute(TEXT("enableWindowsMode"), _nppGUI._darkmode._advOptions._enableWindowsMode);
6047  		GUIConfigElement->SetAttribute(TEXT("darkThemeName"), _nppGUI._darkmode._advOptions._darkDefaults._xmlFileName.c_str());
6048  		GUIConfigElement->SetAttribute(TEXT("darkToolBarIconSet"), _nppGUI._darkmode._advOptions._darkDefaults._toolBarIconSet);
6049  		GUIConfigElement->SetAttribute(TEXT("darkTabIconSet"), _nppGUI._darkmode._advOptions._darkDefaults._tabIconSet);
6050  		setYesNoBoolAttribute(TEXT("darkTabUseTheme"), _nppGUI._darkmode._advOptions._darkDefaults._tabUseTheme);
6051  		GUIConfigElement->SetAttribute(TEXT("lightThemeName"), _nppGUI._darkmode._advOptions._lightDefaults._xmlFileName.c_str());
6052  		GUIConfigElement->SetAttribute(TEXT("lightToolBarIconSet"), _nppGUI._darkmode._advOptions._lightDefaults._toolBarIconSet);
6053  		GUIConfigElement->SetAttribute(TEXT("lightTabIconSet"), _nppGUI._darkmode._advOptions._lightDefaults._tabIconSet);
6054  		setYesNoBoolAttribute(TEXT("lightTabUseTheme"), _nppGUI._darkmode._advOptions._lightDefaults._tabUseTheme);
6055  	}
6056  	writeScintillaParams();
6057  	if (_nppGUI._isCmdlineNosessionActivated && dockMngNodeDup)
6058  	{
6059  		newGUIRoot->InsertEndChild(*dockMngNodeDup);
6060  		delete dockMngNodeDup;
6061  	}
6062  	else
6063  	{
6064  		insertDockingParamNode(newGUIRoot);
6065  	}
6066  }
6067  bool NppParameters::writeFindHistory()
6068  {
6069  	if (!_pXmlUserDoc) return false;
6070  	TiXmlNode *nppRoot = _pXmlUserDoc->FirstChild(TEXT("NotepadPlus"));
6071  	if (!nppRoot)
6072  	{
6073  		nppRoot = _pXmlUserDoc->InsertEndChild(TiXmlElement(TEXT("NotepadPlus")));
6074  	}
6075  	TiXmlNode *findHistoryRoot = nppRoot->FirstChildElement(TEXT("FindHistory"));
6076  	if (!findHistoryRoot)
6077  	{
6078  		TiXmlElement element(TEXT("FindHistory"));
6079  		findHistoryRoot = nppRoot->InsertEndChild(element);
6080  	}
6081  	findHistoryRoot->Clear();
6082  	(findHistoryRoot->ToElement())->SetAttribute(TEXT("nbMaxFindHistoryPath"),	_findHistory._nbMaxFindHistoryPath);
6083  	(findHistoryRoot->ToElement())->SetAttribute(TEXT("nbMaxFindHistoryFilter"),  _findHistory._nbMaxFindHistoryFilter);
6084  	(findHistoryRoot->ToElement())->SetAttribute(TEXT("nbMaxFindHistoryFind"),	_findHistory._nbMaxFindHistoryFind);
6085  	(findHistoryRoot->ToElement())->SetAttribute(TEXT("nbMaxFindHistoryReplace"), _findHistory._nbMaxFindHistoryReplace);
6086  	(findHistoryRoot->ToElement())->SetAttribute(TEXT("matchWord"),				_findHistory._isMatchWord?TEXT("yes"):TEXT("no"));
6087  	(findHistoryRoot->ToElement())->SetAttribute(TEXT("matchCase"),				_findHistory._isMatchCase?TEXT("yes"):TEXT("no"));
6088  	(findHistoryRoot->ToElement())->SetAttribute(TEXT("wrap"),					_findHistory._isWrap?TEXT("yes"):TEXT("no"));
6089  	(findHistoryRoot->ToElement())->SetAttribute(TEXT("directionDown"),			_findHistory._isDirectionDown?TEXT("yes"):TEXT("no"));
6090  	(findHistoryRoot->ToElement())->SetAttribute(TEXT("fifRecuisive"),			_findHistory._isFifRecuisive?TEXT("yes"):TEXT("no"));
6091  	(findHistoryRoot->ToElement())->SetAttribute(TEXT("fifInHiddenFolder"),		_findHistory._isFifInHiddenFolder?TEXT("yes"):TEXT("no"));
6092  	(findHistoryRoot->ToElement())->SetAttribute(TEXT("fifProjectPanel1"),	    	_findHistory._isFifProjectPanel_1?TEXT("yes"):TEXT("no"));
6093  	(findHistoryRoot->ToElement())->SetAttribute(TEXT("fifProjectPanel2"),	      	_findHistory._isFifProjectPanel_2?TEXT("yes"):TEXT("no"));
6094  	(findHistoryRoot->ToElement())->SetAttribute(TEXT("fifProjectPanel3"),	       	_findHistory._isFifProjectPanel_3?TEXT("yes"):TEXT("no"));
6095  	(findHistoryRoot->ToElement())->SetAttribute(TEXT("fifFilterFollowsDoc"),	_findHistory._isFilterFollowDoc?TEXT("yes"):TEXT("no"));
6096  	(findHistoryRoot->ToElement())->SetAttribute(TEXT("fifFolderFollowsDoc"),	_findHistory._isFolderFollowDoc?TEXT("yes"):TEXT("no"));
6097  	(findHistoryRoot->ToElement())->SetAttribute(TEXT("searchMode"), _findHistory._searchMode);
6098  	(findHistoryRoot->ToElement())->SetAttribute(TEXT("transparencyMode"), _findHistory._transparencyMode);
6099  	(findHistoryRoot->ToElement())->SetAttribute(TEXT("transparency"), _findHistory._transparency);
6100  	(findHistoryRoot->ToElement())->SetAttribute(TEXT("dotMatchesNewline"),		_findHistory._dotMatchesNewline?TEXT("yes"):TEXT("no"));
6101  	(findHistoryRoot->ToElement())->SetAttribute(TEXT("isSearch2ButtonsMode"),		_findHistory._isSearch2ButtonsMode?TEXT("yes"):TEXT("no"));
6102  	(findHistoryRoot->ToElement())->SetAttribute(TEXT("regexBackward4PowerUser"),		_findHistory._regexBackward4PowerUser ? TEXT("yes") : TEXT("no"));
6103  	(findHistoryRoot->ToElement())->SetAttribute(TEXT("bookmarkLine"), _findHistory._isBookmarkLine ? TEXT("yes") : TEXT("no"));
6104  	(findHistoryRoot->ToElement())->SetAttribute(TEXT("purge"), _findHistory._isPurge ? TEXT("yes") : TEXT("no"));
6105  	TiXmlElement hist_element{TEXT("")};
6106  	hist_element.SetValue(TEXT("Path"));
6107  	for (size_t i = 0, len = _findHistory._findHistoryPaths.size(); i < len; ++i)
6108  	{
6109  		(hist_element.ToElement())->SetAttribute(TEXT("name"), _findHistory._findHistoryPaths[i].c_str());
6110  		findHistoryRoot->InsertEndChild(hist_element);
6111  	}
6112  	hist_element.SetValue(TEXT("Filter"));
6113  	for (size_t i = 0, len = _findHistory._findHistoryFilters.size(); i < len; ++i)
6114  	{
6115  		(hist_element.ToElement())->SetAttribute(TEXT("name"), _findHistory._findHistoryFilters[i].c_str());
6116  		findHistoryRoot->InsertEndChild(hist_element);
6117  	}
6118  	hist_element.SetValue(TEXT("Find"));
6119  	for (size_t i = 0, len = _findHistory._findHistoryFinds.size(); i < len; ++i)
6120  	{
6121  		(hist_element.ToElement())->SetAttribute(TEXT("name"), _findHistory._findHistoryFinds[i].c_str());
6122  		findHistoryRoot->InsertEndChild(hist_element);
6123  	}
6124  	hist_element.SetValue(TEXT("Replace"));
6125  	for (size_t i = 0, len = _findHistory._findHistoryReplaces.size(); i < len; ++i)
6126  	{
6127  		(hist_element.ToElement())->SetAttribute(TEXT("name"), _findHistory._findHistoryReplaces[i].c_str());
6128  		findHistoryRoot->InsertEndChild(hist_element);
6129  	}
6130  	return true;
6131  }
6132  void NppParameters::insertDockingParamNode(TiXmlNode *GUIRoot)
6133  {
6134  	TiXmlElement DMNode(TEXT("GUIConfig"));
6135  	DMNode.SetAttribute(TEXT("name"), TEXT("DockingManager"));
6136  	DMNode.SetAttribute(TEXT("leftWidth"), _nppGUI._dockingData._leftWidth);
6137  	DMNode.SetAttribute(TEXT("rightWidth"), _nppGUI._dockingData._rightWidth);
6138  	DMNode.SetAttribute(TEXT("topHeight"), _nppGUI._dockingData._topHeight);
6139  	DMNode.SetAttribute(TEXT("bottomHeight"), _nppGUI._dockingData._bottomHight);
6140  	for (size_t i = 0, len = _nppGUI._dockingData._flaotingWindowInfo.size(); i < len ; ++i)
6141  	{
6142  		FloatingWindowInfo & fwi = _nppGUI._dockingData._flaotingWindowInfo[i];
6143  		TiXmlElement FWNode(TEXT("FloatingWindow"));
6144  		FWNode.SetAttribute(TEXT("cont"), fwi._cont);
6145  		FWNode.SetAttribute(TEXT("x"), fwi._pos.left);
6146  		FWNode.SetAttribute(TEXT("y"), fwi._pos.top);
6147  		FWNode.SetAttribute(TEXT("width"), fwi._pos.right);
6148  		FWNode.SetAttribute(TEXT("height"), fwi._pos.bottom);
6149  		DMNode.InsertEndChild(FWNode);
6150  	}
6151  	for (size_t i = 0, len = _nppGUI._dockingData._pluginDockInfo.size() ; i < len ; ++i)
6152  	{
6153  		PluginDlgDockingInfo & pdi = _nppGUI._dockingData._pluginDockInfo[i];
6154  		TiXmlElement PDNode(TEXT("PluginDlg"));
6155  		PDNode.SetAttribute(TEXT("pluginName"), pdi._name);
6156  		PDNode.SetAttribute(TEXT("id"), pdi._internalID);
6157  		PDNode.SetAttribute(TEXT("curr"), pdi._currContainer);
6158  		PDNode.SetAttribute(TEXT("prev"), pdi._prevContainer);
6159  		PDNode.SetAttribute(TEXT("isVisible"), pdi._isVisible?TEXT("yes"):TEXT("no"));
6160  		DMNode.InsertEndChild(PDNode);
6161  	}
6162  	for (size_t i = 0, len = _nppGUI._dockingData._containerTabInfo.size(); i < len ; ++i)
6163  	{
6164  		ContainerTabInfo & cti = _nppGUI._dockingData._containerTabInfo[i];
6165  		TiXmlElement CTNode(TEXT("ActiveTabs"));
6166  		CTNode.SetAttribute(TEXT("cont"), cti._cont);
6167  		CTNode.SetAttribute(TEXT("activeTab"), cti._activeTab);
6168  		DMNode.InsertEndChild(CTNode);
6169  	}
6170  	GUIRoot->InsertEndChild(DMNode);
6171  }
6172  void NppParameters::writePrintSetting(TiXmlElement *element)
6173  {
6174  	const TCHAR *pStr = _nppGUI._printSettings._printLineNumber?TEXT("yes"):TEXT("no");
6175  	element->SetAttribute(TEXT("lineNumber"), pStr);
6176  	element->SetAttribute(TEXT("printOption"), _nppGUI._printSettings._printOption);
6177  	element->SetAttribute(TEXT("headerLeft"), _nppGUI._printSettings._headerLeft.c_str());
6178  	element->SetAttribute(TEXT("headerMiddle"), _nppGUI._printSettings._headerMiddle.c_str());
6179  	element->SetAttribute(TEXT("headerRight"), _nppGUI._printSettings._headerRight.c_str());
6180  	element->SetAttribute(TEXT("footerLeft"), _nppGUI._printSettings._footerLeft.c_str());
6181  	element->SetAttribute(TEXT("footerMiddle"), _nppGUI._printSettings._footerMiddle.c_str());
6182  	element->SetAttribute(TEXT("footerRight"), _nppGUI._printSettings._footerRight.c_str());
6183  	element->SetAttribute(TEXT("headerFontName"), _nppGUI._printSettings._headerFontName.c_str());
6184  	element->SetAttribute(TEXT("headerFontStyle"), _nppGUI._printSettings._headerFontStyle);
6185  	element->SetAttribute(TEXT("headerFontSize"), _nppGUI._printSettings._headerFontSize);
6186  	element->SetAttribute(TEXT("footerFontName"), _nppGUI._printSettings._footerFontName.c_str());
6187  	element->SetAttribute(TEXT("footerFontStyle"), _nppGUI._printSettings._footerFontStyle);
6188  	element->SetAttribute(TEXT("footerFontSize"), _nppGUI._printSettings._footerFontSize);
6189  	element->SetAttribute(TEXT("margeLeft"), _nppGUI._printSettings._marge.left);
6190  	element->SetAttribute(TEXT("margeRight"), _nppGUI._printSettings._marge.right);
6191  	element->SetAttribute(TEXT("margeTop"), _nppGUI._printSettings._marge.top);
6192  	element->SetAttribute(TEXT("margeBottom"), _nppGUI._printSettings._marge.bottom);
6193  }
6194  void NppParameters::writeExcludedLangList(TiXmlElement *element)
6195  {
6196  	int g0 = 0; 
6197  	int g1 = 0; 
6198  	int g2 = 0; 
6199  	int g3 = 0; 
6200  	int g4 = 0; 
6201  	int g5 = 0; 
6202  	int g6 = 0; 
6203  	int g7 = 0; 
6204  	int g8 = 0; 
6205  	int g9 = 0; 
6206  	int g10= 0; 
6207  	int g11= 0; 
6208  	int g12= 0; 
6209  	const int groupNbMember = 8;
6210  	for (size_t i = 0, len = _nppGUI._excludedLangList.size(); i < len ; ++i)
6211  	{
6212  		LangType langType = _nppGUI._excludedLangList[i]._langType;
6213  		if (langType >= L_EXTERNAL && langType < L_END)
6214  			continue;
6215  		int nGrp = langType / groupNbMember;
6216  		int nMask = 1 << langType % groupNbMember;
6217  		switch (nGrp)
6218  		{
6219  			case 0 :
6220  				g0 |= nMask;
6221  				break;
6222  			case 1 :
6223  				g1 |= nMask;
6224  				break;
6225  			case 2 :
6226  				g2 |= nMask;
6227  				break;
6228  			case 3 :
6229  				g3 |= nMask;
6230  				break;
6231  			case 4 :
6232  				g4 |= nMask;
6233  				break;
6234  			case 5 :
6235  				g5 |= nMask;
6236  				break;
6237  			case 6 :
6238  				g6 |= nMask;
6239  				break;
6240  			case 7 :
6241  				g7 |= nMask;
6242  				break;
6243  			case 8:
6244  				g8 |= nMask;
6245  				break;
6246  			case 9:
6247  				g9 |= nMask;
6248  				break;
6249  			case 10:
6250  				g10 |= nMask;
6251  				break;
6252  			case 11:
6253  				g11 |= nMask;
6254  				break;
6255  			case 12:
6256  				g12 |= nMask;
6257  				break;
6258  		}
6259  	}
6260  	element->SetAttribute(TEXT("gr0"), g0);
6261  	element->SetAttribute(TEXT("gr1"), g1);
6262  	element->SetAttribute(TEXT("gr2"), g2);
6263  	element->SetAttribute(TEXT("gr3"), g3);
6264  	element->SetAttribute(TEXT("gr4"), g4);
6265  	element->SetAttribute(TEXT("gr5"), g5);
6266  	element->SetAttribute(TEXT("gr6"), g6);
6267  	element->SetAttribute(TEXT("gr7"), g7);
6268  	element->SetAttribute(TEXT("gr8"), g8);
6269  	element->SetAttribute(TEXT("gr9"), g9);
6270  	element->SetAttribute(TEXT("gr10"), g10);
6271  	element->SetAttribute(TEXT("gr11"), g11);
6272  	element->SetAttribute(TEXT("gr12"), g12);
6273  }
6274  TiXmlElement * NppParameters::insertGUIConfigBoolNode(TiXmlNode *r2w, const TCHAR *name, bool bVal)
6275  {
6276  	const TCHAR *pStr = bVal?TEXT("yes"):TEXT("no");
6277  	TiXmlElement *GUIConfigElement = (r2w->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
6278  	GUIConfigElement->SetAttribute(TEXT("name"), name);
6279  	GUIConfigElement->InsertEndChild(TiXmlText(pStr));
6280  	return GUIConfigElement;
6281  }
6282  int RGB2int(COLORREF color)
6283  {
6284  	return (((((DWORD)color) & 0x0000FF) << 16) | ((((DWORD)color) & 0x00FF00)) | ((((DWORD)color) & 0xFF0000) >> 16));
6285  }
6286  int NppParameters::langTypeToCommandID(LangType lt) const
6287  {
6288  	int id;
6289  	switch (lt)
6290  	{
6291  		case L_C :
6292  			id = IDM_LANG_C; break;
6293  		case L_CPP :
6294  			id = IDM_LANG_CPP; break;
6295  		case L_JAVA :
6296  			id = IDM_LANG_JAVA;	break;
6297  		case L_CS :
6298  			id = IDM_LANG_CS; break;
6299  		case L_OBJC :
6300  			id = IDM_LANG_OBJC;	break;
6301  		case L_HTML :
6302  			id = IDM_LANG_HTML;	break;
6303  		case L_XML :
6304  			id = IDM_LANG_XML; break;
6305  		case L_JS :
6306  		case L_JAVASCRIPT:
6307  			id = IDM_LANG_JS; break;
6308  		case L_JSON:
6309  			id = IDM_LANG_JSON; break;
6310  		case L_JSON5:
6311  			id = IDM_LANG_JSON5; break;
6312  		case L_PHP :
6313  			id = IDM_LANG_PHP; break;
6314  		case L_ASP :
6315  			id = IDM_LANG_ASP; break;
6316  		case L_JSP :
6317  			id = IDM_LANG_JSP; break;
6318  		case L_CSS :
6319  			id = IDM_LANG_CSS; break;
6320  		case L_LUA :
6321  			id = IDM_LANG_LUA; break;
6322  		case L_PERL :
6323  			id = IDM_LANG_PERL; break;
6324  		case L_PYTHON :
6325  			id = IDM_LANG_PYTHON; break;
6326  		case L_BATCH :
6327  			id = IDM_LANG_BATCH; break;
6328  		case L_PASCAL :
6329  			id = IDM_LANG_PASCAL; break;
6330  		case L_MAKEFILE :
6331  			id = IDM_LANG_MAKEFILE;	break;
6332  		case L_INI :
6333  			id = IDM_LANG_INI; break;
6334  		case L_ASCII :
6335  			id = IDM_LANG_ASCII; break;
6336  		case L_RC :
6337  			id = IDM_LANG_RC; break;
6338  		case L_TEX :
6339  			id = IDM_LANG_TEX; break;
6340  		case L_FORTRAN :
6341  			id = IDM_LANG_FORTRAN; break;
6342  		case L_FORTRAN_77 :
6343  			id = IDM_LANG_FORTRAN_77; break;
6344  		case L_BASH :
6345  			id = IDM_LANG_BASH; break;
6346  		case L_FLASH :
6347  			id = IDM_LANG_FLASH; break;
6348  		case L_NSIS :
6349  			id = IDM_LANG_NSIS; break;
6350  		case L_USER :
6351  			id = IDM_LANG_USER; break;
6352  		case L_SQL :
6353  			id = IDM_LANG_SQL; break;
6354  		case L_MSSQL :
6355  			id = IDM_LANG_MSSQL; break;
6356  		case L_VB :
6357  			id = IDM_LANG_VB; break;
6358  		case L_TCL :
6359  			id = IDM_LANG_TCL; break;
6360  		case L_LISP :
6361  			id = IDM_LANG_LISP; break;
6362  		case L_SCHEME :
6363  			id = IDM_LANG_SCHEME; break;
6364  		case L_ASM :
6365  			id = IDM_LANG_ASM; break;
6366  		case L_DIFF :
6367  			id = IDM_LANG_DIFF; break;
6368  		case L_PROPS :
6369  			id = IDM_LANG_PROPS; break;
6370  		case L_PS :
6371  			id = IDM_LANG_PS; break;
6372  		case L_RUBY :
6373  			id = IDM_LANG_RUBY; break;
6374  		case L_SMALLTALK :
6375  			id = IDM_LANG_SMALLTALK; break;
6376  		case L_VHDL :
6377  			id = IDM_LANG_VHDL; break;
6378  		case L_ADA :
6379  			id = IDM_LANG_ADA; break;
6380  		case L_MATLAB :
6381  			id = IDM_LANG_MATLAB; break;
6382  		case L_HASKELL :
6383  			id = IDM_LANG_HASKELL; break;
6384  		case L_KIX :
6385  			id = IDM_LANG_KIX; break;
6386  		case L_AU3 :
6387  			id = IDM_LANG_AU3; break;
6388  		case L_VERILOG :
6389  			id = IDM_LANG_VERILOG; break;
6390  		case L_CAML :
6391  			id = IDM_LANG_CAML; break;
6392  		case L_INNO :
6393  			id = IDM_LANG_INNO; break;
6394  		case L_CMAKE :
6395  			id = IDM_LANG_CMAKE; break;
6396  		case L_YAML :
6397  			id = IDM_LANG_YAML; break;
6398  		case L_COBOL :
6399  			id = IDM_LANG_COBOL; break;
6400  		case L_D :
6401  			id = IDM_LANG_D; break;
6402  		case L_GUI4CLI :
6403  			id = IDM_LANG_GUI4CLI; break;
6404  		case L_POWERSHELL :
6405  			id = IDM_LANG_POWERSHELL; break;
6406  		case L_R :
6407  			id = IDM_LANG_R; break;
6408  		case L_COFFEESCRIPT :
6409  			id = IDM_LANG_COFFEESCRIPT; break;
6410  		case L_BAANC:
6411  			id = IDM_LANG_BAANC; break;
6412  		case L_SREC :
6413  			id = IDM_LANG_SREC; break;
6414  		case L_IHEX :
6415  			id = IDM_LANG_IHEX; break;
6416  		case L_TEHEX :
6417  			id = IDM_LANG_TEHEX; break;
6418  		case L_SWIFT:
6419  			id = IDM_LANG_SWIFT; break;
6420  		case L_ASN1 :
6421  			id = IDM_LANG_ASN1; break;
6422          case L_AVS :
6423  			id = IDM_LANG_AVS; break;
6424  		case L_BLITZBASIC :
6425  			id = IDM_LANG_BLITZBASIC; break;
6426  		case L_PUREBASIC :
6427  			id = IDM_LANG_PUREBASIC; break;
6428  		case L_FREEBASIC :
6429  			id = IDM_LANG_FREEBASIC; break;
6430  		case L_CSOUND :
6431  			id = IDM_LANG_CSOUND; break;
6432  		case L_ERLANG :
6433  			id = IDM_LANG_ERLANG; break;
6434  		case L_ESCRIPT :
6435  			id = IDM_LANG_ESCRIPT; break;
6436  		case L_FORTH :
6437  			id = IDM_LANG_FORTH; break;
6438  		case L_LATEX :
6439  			id = IDM_LANG_LATEX; break;
6440  		case L_MMIXAL :
6441  			id = IDM_LANG_MMIXAL; break;
6442  		case L_NIM :
6443  			id = IDM_LANG_NIM; break;
6444  		case L_NNCRONTAB :
6445  			id = IDM_LANG_NNCRONTAB; break;
6446  		case L_OSCRIPT :
6447  			id = IDM_LANG_OSCRIPT; break;
6448  		case L_REBOL :
6449  			id = IDM_LANG_REBOL; break;
6450  		case L_REGISTRY :
6451  			id = IDM_LANG_REGISTRY; break;
6452  		case L_RUST :
6453  			id = IDM_LANG_RUST; break;
6454  		case L_SPICE :
6455  			id = IDM_LANG_SPICE; break;
6456  		case L_TXT2TAGS :
6457  			id = IDM_LANG_TXT2TAGS; break;
6458  		case L_VISUALPROLOG:
6459  			id = IDM_LANG_VISUALPROLOG; break;
6460  		case L_TYPESCRIPT:
6461  			id = IDM_LANG_TYPESCRIPT; break;
6462  		case L_GDSCRIPT:
6463  			id = IDM_LANG_GDSCRIPT; break;
6464  		case L_HOLLYWOOD:
6465  			id = IDM_LANG_HOLLYWOOD; break;
6466  		case L_SEARCHRESULT :
6467  			id = -1;	break;
6468  		case L_TEXT :
6469  			id = IDM_LANG_TEXT;	break;
6470  		default :
6471  			if (lt >= L_EXTERNAL && lt < L_END)
6472  				id = lt - L_EXTERNAL + IDM_LANG_EXTERNAL;
6473  			else
6474  				id = IDM_LANG_TEXT;
6475  	}
6476  	return id;
6477  }
6478  generic_string NppParameters:: getWinVersionStr() const
6479  {
6480  	switch (_winVersion)
6481  	{
6482  		case WV_WIN32S: return TEXT("Windows 3.1");
6483  		case WV_95: return TEXT("Windows 95");
6484  		case WV_98: return TEXT("Windows 98");
6485  		case WV_ME: return TEXT("Windows Millennium Edition");
6486  		case WV_NT: return TEXT("Windows NT");
6487  		case WV_W2K: return TEXT("Windows 2000");
6488  		case WV_XP: return TEXT("Windows XP");
6489  		case WV_S2003: return TEXT("Windows Server 2003");
6490  		case WV_XPX64: return TEXT("Windows XP 64 bits");
6491  		case WV_VISTA: return TEXT("Windows Vista");
6492  		case WV_WIN7: return TEXT("Windows 7");
6493  		case WV_WIN8: return TEXT("Windows 8");
6494  		case WV_WIN81: return TEXT("Windows 8.1");
6495  		case WV_WIN10: return TEXT("Windows 10");
6496  		case WV_WIN11: return TEXT("Windows 11");
6497  		default: &bsol;*case WV_UNKNOWN:*/ return TEXT("Windows unknown version");
6498  	}
6499  }
6500  generic_string NppParameters::getWinVerBitStr() const
6501  {
6502  	switch (_platForm)
6503  	{
6504  	case PF_X86:
6505  		return TEXT("32-bit");
6506  	case PF_X64:
6507  	case PF_IA64:
6508  	case PF_ARM64:
6509  		return TEXT("64-bit");
6510  	default:
6511  		return TEXT("Unknown-bit");
6512  	}
6513  }
6514  generic_string NppParameters::writeStyles(LexerStylerArray & lexersStylers, StyleArray & globalStylers)
6515  {
6516  	TiXmlNode *lexersRoot = (_pXmlUserStylerDoc->FirstChild(TEXT("NotepadPlus")))->FirstChildElement(TEXT("LexerStyles"));
6517  	for (TiXmlNode *childNode = lexersRoot->FirstChildElement(TEXT("LexerType"));
6518  		childNode ;
6519  		childNode = childNode->NextSibling(TEXT("LexerType")))
6520  	{
6521  		TiXmlElement *element = childNode->ToElement();
6522  		const TCHAR *nm = element->Attribute(TEXT("name"));
6523  		LexerStyler *pLs = _lexerStylerVect.getLexerStylerByName(nm);
6524  		LexerStyler *pLs2 = lexersStylers.getLexerStylerByName(nm);
6525  		if (pLs)
6526  		{
6527  			const TCHAR *extStr = pLs->getLexerUserExt();
6528  			element->SetAttribute(TEXT("ext"), extStr);
6529  			for (TiXmlNode *grChildNode = childNode->FirstChildElement(TEXT("WordsStyle"));
6530  					grChildNode ;
6531  					grChildNode = grChildNode->NextSibling(TEXT("WordsStyle")))
6532  			{
6533  				TiXmlElement *grElement = grChildNode->ToElement();
6534  				const TCHAR *styleName = grElement->Attribute(TEXT("name"));
6535  				const Style * pStyle = pLs->findByName(styleName);
6536  				Style * pStyle2Sync = pLs2 ? pLs2->findByName(styleName) : nullptr;
6537  				if (pStyle && pStyle2Sync)
6538  				{
6539  					writeStyle2Element(*pStyle, *pStyle2Sync, grElement);
6540  				}
6541  			}
6542  		}
6543  	}
6544  	for (size_t x = 0; x < _pXmlExternalLexerDoc.size(); ++x)
6545  	{
6546  		TiXmlNode* lexersRoot2 = ( _pXmlExternalLexerDoc[x]->FirstChild(TEXT("NotepadPlus")))->FirstChildElement(TEXT("LexerStyles"));
6547  		for (TiXmlNode* childNode = lexersRoot2->FirstChildElement(TEXT("LexerType"));
6548  			childNode ;
6549  			childNode = childNode->NextSibling(TEXT("LexerType")))
6550  		{
6551  			TiXmlElement *element = childNode->ToElement();
6552  			const TCHAR *nm = element->Attribute(TEXT("name"));
6553  			LexerStyler *pLs = _lexerStylerVect.getLexerStylerByName(nm);
6554  			LexerStyler *pLs2 = lexersStylers.getLexerStylerByName(nm);
6555  			if (pLs)
6556  			{
6557  				const TCHAR *extStr = pLs->getLexerUserExt();
6558  				element->SetAttribute(TEXT("ext"), extStr);
6559  				for (TiXmlNode *grChildNode = childNode->FirstChildElement(TEXT("WordsStyle"));
6560  						grChildNode ;
6561  						grChildNode = grChildNode->NextSibling(TEXT("WordsStyle")))
6562  				{
6563  					TiXmlElement *grElement = grChildNode->ToElement();
6564  					const TCHAR *styleName = grElement->Attribute(TEXT("name"));
6565  					const Style * pStyle = pLs->findByName(styleName);
6566  					Style * pStyle2Sync = pLs2 ? pLs2->findByName(styleName) : nullptr;
6567  					if (pStyle && pStyle2Sync)
6568  					{
6569  						writeStyle2Element(*pStyle, *pStyle2Sync, grElement);
6570  					}
6571  				}
6572  			}
6573  		}
6574  		_pXmlExternalLexerDoc[x]->SaveFile();
6575  	}
6576  	TiXmlNode *globalStylesRoot = (_pXmlUserStylerDoc->FirstChild(TEXT("NotepadPlus")))->FirstChildElement(TEXT("GlobalStyles"));
6577  	for (TiXmlNode *childNode = globalStylesRoot->FirstChildElement(TEXT("WidgetStyle"));
6578  		childNode ;
6579  		childNode = childNode->NextSibling(TEXT("WidgetStyle")))
6580  	{
6581  		TiXmlElement *pElement = childNode->ToElement();
6582  		const TCHAR *styleName = pElement->Attribute(TEXT("name"));
6583  		const Style * pStyle = _widgetStyleArray.findByName(styleName);
6584  		Style * pStyle2Sync = globalStylers.findByName(styleName);
6585  		if (pStyle && pStyle2Sync)
6586  		{
6587  			writeStyle2Element(*pStyle, *pStyle2Sync, pElement);
6588  		}
6589  	}
6590  	bool isSaved = _pXmlUserStylerDoc->SaveFile();
6591  	if (!isSaved)
6592  	{
6593  		auto savePath = _themeSwitcher.getSavePathFrom(_pXmlUserStylerDoc->Value());
6594  		if (!savePath.empty())
6595  		{
6596  			_pXmlUserStylerDoc->SaveFile(savePath.c_str());
6597  			return savePath;
6598  		}
6599  	}
6600  	return TEXT("");
6601  }
6602  bool NppParameters::insertTabInfo(const TCHAR *langName, int tabInfo)
6603  {
6604  	if (!_pXmlDoc) return false;
6605  	TiXmlNode *langRoot = (_pXmlDoc->FirstChild(TEXT("NotepadPlus")))->FirstChildElement(TEXT("Languages"));
6606  	for (TiXmlNode *childNode = langRoot->FirstChildElement(TEXT("Language"));
6607  		childNode ;
6608  		childNode = childNode->NextSibling(TEXT("Language")))
6609  	{
6610  		TiXmlElement *element = childNode->ToElement();
6611  		const TCHAR *nm = element->Attribute(TEXT("name"));
6612  		if (nm && lstrcmp(langName, nm) == 0)
6613  		{
6614  			childNode->ToElement()->SetAttribute(TEXT("tabSettings"), tabInfo);
6615  			_pXmlDoc->SaveFile();
6616  			return true;
6617  		}
6618  	}
6619  	return false;
6620  }
6621  void NppParameters::writeStyle2Element(const Style & style2Write, Style & style2Sync, TiXmlElement *element)
6622  {
6623  	if (HIBYTE(HIWORD(style2Write._fgColor)) != 0xFF)
6624  	{
6625  		int rgbVal = RGB2int(style2Write._fgColor);
6626  		TCHAR fgStr[7];
6627  		wsprintf(fgStr, TEXT("%.6X"), rgbVal);
6628  		element->SetAttribute(TEXT("fgColor"), fgStr);
6629  	}
6630  	if (HIBYTE(HIWORD(style2Write._bgColor)) != 0xFF)
6631  	{
6632  		int rgbVal = RGB2int(style2Write._bgColor);
6633  		TCHAR bgStr[7];
6634  		wsprintf(bgStr, TEXT("%.6X"), rgbVal);
6635  		element->SetAttribute(TEXT("bgColor"), bgStr);
6636  	}
6637  	if (style2Write._colorStyle != COLORSTYLE_ALL)
6638  	{
6639  		element->SetAttribute(TEXT("colorStyle"), style2Write._colorStyle);
6640  	}
6641  	if (!style2Write._fontName.empty())
6642  	{
6643  		const TCHAR * oldFontName = element->Attribute(TEXT("fontName"));
6644  		if (oldFontName && oldFontName != style2Write._fontName)
6645  		{
6646  			element->SetAttribute(TEXT("fontName"), style2Write._fontName);
6647  			style2Sync._fontName = style2Write._fontName;
6648  		}
6649  	}
6650  	if (style2Write._fontSize != STYLE_NOT_USED)
6651  	{
6652  		if (!style2Write._fontSize)
6653  			element->SetAttribute(TEXT("fontSize"), TEXT(""));
6654  		else
6655  			element->SetAttribute(TEXT("fontSize"), style2Write._fontSize);
6656  	}
6657  	if (style2Write._fontStyle != STYLE_NOT_USED)
6658  	{
6659  		element->SetAttribute(TEXT("fontStyle"), style2Write._fontStyle);
6660  	}
6661  	if (!style2Write._keywords.empty())
6662  	{
6663  		TiXmlNode *teteDeNoeud = element->LastChild();
6664  		if (teteDeNoeud)
6665  			teteDeNoeud->SetValue(style2Write._keywords.c_str());
6666  		else
6667  			element->InsertEndChild(TiXmlText(style2Write._keywords.c_str()));
6668  	}
6669  }
6670  void NppParameters::insertUserLang2Tree(TiXmlNode *node, UserLangContainer *userLang)
6671  {
6672  	TiXmlElement *rootElement = (node->InsertEndChild(TiXmlElement(TEXT("UserLang"))))->ToElement();
6673  	TCHAR temp[32];
6674  	generic_string udlVersion;
6675  	udlVersion += _itow(SCE_UDL_VERSION_MAJOR, temp, 10);
6676  	udlVersion += TEXT(".");
6677  	udlVersion += _itow(SCE_UDL_VERSION_MINOR, temp, 10);
6678  	rootElement->SetAttribute(TEXT("name"), userLang->_name);
6679  	rootElement->SetAttribute(TEXT("ext"), userLang->_ext);
6680  	if (userLang->_isDarkModeTheme)
6681  		rootElement->SetAttribute(TEXT("darkModeTheme"), TEXT("yes"));
6682  	rootElement->SetAttribute(TEXT("udlVersion"), udlVersion.c_str());
6683  	TiXmlElement *settingsElement = (rootElement->InsertEndChild(TiXmlElement(TEXT("Settings"))))->ToElement();
6684  	{
6685  		TiXmlElement *globalElement = (settingsElement->InsertEndChild(TiXmlElement(TEXT("Global"))))->ToElement();
6686  		globalElement->SetAttribute(TEXT("caseIgnored"),			userLang->_isCaseIgnored ? TEXT("yes"):TEXT("no"));
6687  		globalElement->SetAttribute(TEXT("allowFoldOfComments"),	userLang->_allowFoldOfComments ? TEXT("yes"):TEXT("no"));
6688  		globalElement->SetAttribute(TEXT("foldCompact"),			userLang->_foldCompact ? TEXT("yes"):TEXT("no"));
6689  		globalElement->SetAttribute(TEXT("forcePureLC"),			userLang->_forcePureLC);
6690  		globalElement->SetAttribute(TEXT("decimalSeparator"),	   userLang->_decimalSeparator);
6691  		TiXmlElement *prefixElement = (settingsElement->InsertEndChild(TiXmlElement(TEXT("Prefix"))))->ToElement();
6692  		for (int i = 0 ; i < SCE_USER_TOTAL_KEYWORD_GROUPS ; ++i)
6693  			prefixElement->SetAttribute(globalMappper().keywordNameMapper[i+SCE_USER_KWLIST_KEYWORDS1], userLang->_isPrefix[i]?TEXT("yes"):TEXT("no"));
6694  	}
6695  	TiXmlElement *kwlElement = (rootElement->InsertEndChild(TiXmlElement(TEXT("KeywordLists"))))->ToElement();
6696  	for (int i = 0 ; i < SCE_USER_KWLIST_TOTAL ; ++i)
6697  	{
6698  		TiXmlElement *kwElement = (kwlElement->InsertEndChild(TiXmlElement(TEXT("Keywords"))))->ToElement();
6699  		kwElement->SetAttribute(TEXT("name"), globalMappper().keywordNameMapper[i]);
6700  		kwElement->InsertEndChild(TiXmlText(userLang->_keywordLists[i]));
6701  	}
6702  	TiXmlElement *styleRootElement = (rootElement->InsertEndChild(TiXmlElement(TEXT("Styles"))))->ToElement();
6703  	for (const Style & style2Write : userLang->_styles)
6704  	{
6705  		TiXmlElement *styleElement = (styleRootElement->InsertEndChild(TiXmlElement(TEXT("WordsStyle"))))->ToElement();
6706  		if (style2Write._styleID == -1)
6707  			continue;
6708  		styleElement->SetAttribute(TEXT("name"), style2Write._styleDesc);
6709  		{
6710  			int rgbVal = RGB2int(style2Write._fgColor);
6711  			TCHAR fgStr[7];
6712  			wsprintf(fgStr, TEXT("%.6X"), rgbVal);
6713  			styleElement->SetAttribute(TEXT("fgColor"), fgStr);
6714  		}
6715  		{
6716  			int rgbVal = RGB2int(style2Write._bgColor);
6717  			TCHAR bgStr[7];
6718  			wsprintf(bgStr, TEXT("%.6X"), rgbVal);
6719  			styleElement->SetAttribute(TEXT("bgColor"), bgStr);
6720  		}
6721  		if (style2Write._colorStyle != COLORSTYLE_ALL)
6722  		{
6723  			styleElement->SetAttribute(TEXT("colorStyle"), style2Write._colorStyle);
6724  		}
6725  		if (!style2Write._fontName.empty())
6726  		{
6727  			styleElement->SetAttribute(TEXT("fontName"), style2Write._fontName);
6728  		}
6729  		if (style2Write._fontStyle == STYLE_NOT_USED)
6730  		{
6731  			styleElement->SetAttribute(TEXT("fontStyle"), TEXT("0"));
6732  		}
6733  		else
6734  		{
6735  			styleElement->SetAttribute(TEXT("fontStyle"), style2Write._fontStyle);
6736  		}
6737  		if (style2Write._fontSize != STYLE_NOT_USED)
6738  		{
6739  			if (!style2Write._fontSize)
6740  				styleElement->SetAttribute(TEXT("fontSize"), TEXT(""));
6741  			else
6742  				styleElement->SetAttribute(TEXT("fontSize"), style2Write._fontSize);
6743  		}
6744  		styleElement->SetAttribute(TEXT("nesting"), style2Write._nesting);
6745  	}
6746  }
6747  void NppParameters::addUserModifiedIndex(size_t index)
6748  {
6749  	size_t len = _customizedShortcuts.size();
6750  	bool found = false;
6751  	for (size_t i = 0; i < len; ++i)
6752  	{
6753  		if (_customizedShortcuts[i] == index)
6754  		{
6755  			found = true;
6756  			break;
6757  		}
6758  	}
6759  	if (!found)
6760  	{
6761  		_customizedShortcuts.push_back(index);
6762  	}
6763  }
6764  void NppParameters::addPluginModifiedIndex(size_t index)
6765  {
6766  	size_t len = _pluginCustomizedCmds.size();
6767  	bool found = false;
6768  	for (size_t i = 0; i < len; ++i)
6769  	{
6770  		if (_pluginCustomizedCmds[i] == index)
6771  		{
6772  			found = true;
6773  			break;
6774  		}
6775  	}
6776  	if (!found)
6777  	{
6778  		_pluginCustomizedCmds.push_back(index);
6779  	}
6780  }
6781  void NppParameters::addScintillaModifiedIndex(int index)
6782  {
6783  	size_t len = _scintillaModifiedKeyIndices.size();
6784  	bool found = false;
6785  	for (size_t i = 0; i < len; ++i)
6786  	{
6787  		if (_scintillaModifiedKeyIndices[i] == index)
6788  		{
6789  			found = true;
6790  			break;
6791  		}
6792  	}
6793  	if (!found)
6794  	{
6795  		_scintillaModifiedKeyIndices.push_back(index);
6796  	}
6797  }
6798  void NppParameters::safeWow64EnableWow64FsRedirection(BOOL Wow64FsEnableRedirection)
6799  {
6800  	HMODULE kernel = GetModuleHandle(TEXT("kernel32"));
6801  	if (kernel)
6802  	{
6803  		BOOL isWow64 = FALSE;
6804  		typedef BOOL (WINAPI *LPFN_ISWOW64PROCESS) (HANDLE, PBOOL);
6805  		LPFN_ISWOW64PROCESS IsWow64ProcessFunc = (LPFN_ISWOW64PROCESS) GetProcAddress(kernel,"IsWow64Process");
6806  		if (IsWow64ProcessFunc)
6807  		{
6808  			IsWow64ProcessFunc(GetCurrentProcess(),&isWow64);
6809  			if (isWow64)
6810  			{
6811  				typedef BOOL (WINAPI *LPFN_WOW64ENABLEWOW64FSREDIRECTION)(BOOL);
6812  				LPFN_WOW64ENABLEWOW64FSREDIRECTION Wow64EnableWow64FsRedirectionFunc = (LPFN_WOW64ENABLEWOW64FSREDIRECTION)GetProcAddress(kernel, "Wow64EnableWow64FsRedirection");
6813  				if (Wow64EnableWow64FsRedirectionFunc)
6814  				{
6815  					Wow64EnableWow64FsRedirectionFunc(Wow64FsEnableRedirection);
6816  				}
6817  			}
6818  		}
6819  	}
6820  }
6821  void NppParameters::setUdlXmlDirtyFromIndex(size_t i)
6822  {
6823  	for (auto& uxfs : _pXmlUserLangsDoc)
6824  	{
6825  		if (i >= uxfs._indexRange.first && i < uxfs._indexRange.second)
6826  		{
6827  			uxfs._isDirty = true;
6828  			return;
6829  		}
6830  	}
6831  }
6832  void NppParameters::removeIndexFromXmlUdls(size_t i)
6833  {
6834  	bool isUpdateBegin = false;
6835  	for (auto& uxfs : _pXmlUserLangsDoc)
6836  	{
6837  		if (!isUpdateBegin && (i >= uxfs._indexRange.first && i < uxfs._indexRange.second)) 
6838  		{
6839  			if (uxfs._indexRange.second > 0)
6840  				uxfs._indexRange.second -= 1;
6841  			uxfs._isDirty = true;
6842  			isUpdateBegin = true;
6843  		}
6844  		else if (isUpdateBegin)
6845  		{
6846  			if (uxfs._indexRange.first > 0)
6847  				uxfs._indexRange.first -= 1;
6848  			if (uxfs._indexRange.second > 0)
6849  				uxfs._indexRange.second -= 1;
6850  		}
6851  	}
6852  }
6853  void NppParameters::setUdlXmlDirtyFromXmlDoc(const TiXmlDocument* xmlDoc)
6854  {
6855  	for (auto& uxfs : _pXmlUserLangsDoc)
6856  	{
6857  		if (xmlDoc == uxfs._udlXmlDoc)
6858  		{
6859  			uxfs._isDirty = true;
6860  			return;
6861  		}
6862  	}
6863  }
6864  Date::Date(const TCHAR *dateStr)
6865  {
6866  	assert(dateStr);
6867  	int D = lstrlen(dateStr);
6868  	if ( 8==D )
6869  	{
6870  		generic_string ds(dateStr);
6871  		generic_string yyyy(ds, 0, 4);
6872  		generic_string mm(ds, 4, 2);
6873  		generic_string dd(ds, 6, 2);
6874  		int y = _wtoi(yyyy.c_str());
6875  		int m = _wtoi(mm.c_str());
6876  		int d = _wtoi(dd.c_str());
6877  		if ((y > 0 && y <= 9999) && (m > 0 && m <= 12) && (d > 0 && d <= 31))
6878  		{
6879  			_year = y;
6880  			_month = m;
6881  			_day = d;
6882  			return;
6883  		}
6884  	}
6885  	now();
6886  }
6887  Date::Date(int nbDaysFromNow)
6888  {
6889  	const time_t oneDay = (60 * 60 * 24);
6890  	time_t rawtime;
6891  	tm* timeinfo;
6892  	time(&rawtime);
6893  	rawtime += (nbDaysFromNow * oneDay);
6894  	timeinfo = localtime(&rawtime);
6895  	if (timeinfo)
6896  	{
6897  		_year = timeinfo->tm_year + 1900;
6898  		_month = timeinfo->tm_mon + 1;
6899  		_day = timeinfo->tm_mday;
6900  	}
6901  }
6902  void Date::now()
6903  {
6904  	time_t rawtime;
6905  	tm* timeinfo;
6906  	time(&rawtime);
6907  	timeinfo = localtime(&rawtime);
6908  	if (timeinfo)
6909  	{
6910  		_year = timeinfo->tm_year + 1900;
6911  		_month = timeinfo->tm_mon + 1;
6912  		_day = timeinfo->tm_mday;
6913  	}
6914  }
6915  EolType convertIntToFormatType(int value, EolType defvalue)
6916  {
6917  	switch (value)
6918  	{
6919  		case static_cast<LPARAM>(EolType::windows) :
6920  			return EolType::windows;
6921  		case static_cast<LPARAM>(EolType::macos) :
6922  				return EolType::macos;
6923  		case static_cast<LPARAM>(EolType::unix) :
6924  			return EolType::unix;
6925  		default:
6926  			return defvalue;
6927  	}
6928  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-flx.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-Parameters.cpp</div>
                </div>
                <div class="column column_space"><pre><code>395    if (CutBfL==BfL){BfL=0;}
396    else {memmove(Bf, Bf+CutBfL, BfL-CutBfL); BfL=BfL-CutBfL;}
397  }
</pre></code></div>
                <div class="column column_space"><pre><code>705  		else if (item._cmdID == 0 && !lastIsSep)
706  		{
707  			::InsertMenu(_hMenu, static_cast<int32_t>(_posBase + i), flag, item._cmdID, item._itemName.c_str());
708  			lastIsSep = true;
709  		}
710  		else 
711  		{
712  			lastIsSep = true;
713  		}
714  	}
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    