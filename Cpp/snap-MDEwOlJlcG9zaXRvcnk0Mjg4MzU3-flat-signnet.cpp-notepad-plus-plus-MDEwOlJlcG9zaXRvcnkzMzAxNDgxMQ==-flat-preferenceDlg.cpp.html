
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 6.135865595325055%, Tokens: 13, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-signnet.cpp</h3>
            <pre><code>1  #include "stdafx.h"
2  #include "signnet.h"
3  PSignNet TSignNet::GetEdgeSubNet(const int& EDat1, const int& EDat2, const int& EDat3) const {
4    TIntSet EDatSet;
5    EDatSet.AddKey(EDat1);
6    if (EDat2!=TInt::Mn) { EDatSet.AddKey(EDat2); }
7    if (EDat3!=TInt::Mn) { EDatSet.AddKey(EDat3); }
8    PSignNet Net = TSignNet::New();
9    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
10      if (! EDatSet.IsKey(EI())) { continue; }
11      if (! Net->IsNode(EI.GetSrcNId())) {
12        Net->AddNode(EI.GetSrcNId(), EI.GetSrcNDat()); }
13      if (! Net->IsNode(EI.GetDstNId())) {
14        Net->AddNode(EI.GetDstNId(), EI.GetDstNDat()); }
15      Net->AddEdge(EI);
16    }
17    return Net;
18  }
19  void TSignNet::PermuteEdgeSigns() {
20    TIntV EDatV(GetEdges(), 0);
21    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
22      EDatV.Add(EI());
23    }
24    EDatV.Shuffle(TInt::Rnd);
25    int i = 0;
26    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
27      EI() = EDatV[i++];
28    }
29  }
30  void TSignNet::RewireNetwork() {
31    TIntH NIdDatH;
32    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
33      NIdDatH.AddDat(NI.GetId(), NI()); }
34    PNGraph PlusG = TSnap::ConvertGraph<PNGraph>(GetSignSubNet(+1));
35    PNGraph MinusG = TSnap::ConvertGraph<PNGraph>(GetSignSubNet(-1));
36    PlusG = TSnap::GenRewire(PlusG);
37    MinusG = TSnap::GenRewire(MinusG);
38    Clr(false);
39    for (TNGraph::TNodeI NI = PlusG->BegNI(); NI < PlusG->EndNI(); NI++) {
40      AddNode(NI.GetId()); }
41    for (TNGraph::TNodeI NI = MinusG->BegNI(); NI < MinusG->EndNI(); NI++) {
42      AddNode(NI.GetId(), NIdDatH.GetDat(NI.GetId())); }
43    for (TNGraph::TEdgeI EI = PlusG->BegEI(); EI < PlusG->EndEI(); EI++) {
44      AddEdge(EI.GetSrcNId(), EI.GetDstNId(), +1); }
45    for (TNGraph::TEdgeI EI = MinusG->BegEI(); EI < MinusG->EndEI(); EI++) {
46      AddEdge(EI.GetSrcNId(), EI.GetDstNId(), -1); }
47  }
48  void TSignNet::SimplifyNet() {
49    TIntPrV DelV;
50    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
51      if (EI.GetSrcNId() > EI.GetDstNId()) { continue; }
52      if (EI.GetSrcNId() == EI.GetDstNId()) {
53        DelV.Add(TIntPr(EI.GetSrcNId(), EI.GetDstNId())); }
54      else if (EI.GetSrcNId() < EI.GetDstNId() && IsEdge(EI.GetDstNId(), EI.GetSrcNId())) {
55        if (TInt::Rnd.GetUniDev() < 0.5) {
56          DelV.Add(TIntPr(EI.GetSrcNId(), EI.GetDstNId())); }
57        else {
58          DelV.Add(TIntPr(EI.GetDstNId(), EI.GetSrcNId())); }
59      }
60    }
61    printf("Deleting %d edges\n", DelV.Len());
62    for (int e = 0; e < DelV.Len(); e++) {
63      DelEdge(DelV[e].Val1, DelV[e].Val2);
64    }
65  }
66  void TSignNet::FlipMinusEdges(const int&  OldSign, const int& NewSign) {
67    TIntPrV MinusEV;
68    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
69      if (EI() == OldSign) {
70        MinusEV.Add(TIntPr(EI.GetSrcNId(), EI.GetDstNId())); }
71    }
72    int NFlip = 0;
73    for (int e = 0; e < MinusEV.Len(); e++) {
74      DelEdge(MinusEV[e].Val1, MinusEV[e].Val2);
75      if (! IsEdge(MinusEV[e].Val2, MinusEV[e].Val1)) {
76        AddEdge(MinusEV[e].Val2, MinusEV[e].Val1, NewSign);
77        NFlip++;
78      }
79    }
80    printf("%d/%d (%.4f) edges flipped\n", NFlip, MinusEV.Len(), NFlip/double(MinusEV.Len()));
81  }
82  void TSignNet::CountStructBalance() const {
83    TIntSet NbrIdSet;
84    THash<TIntTr, TInt> TriadCntH;
85    TIntH SignH;
86    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
87      SignH.AddDat(EI()) += 1;
88    }
89    printf("Structural balance triads: %d nodes, %d edges\n  background sign distribution:\n", GetNodes(), GetEdges());
90    SignH.SortByKey(false);
91    for (int i = 0; i < SignH.Len(); i++) {
92      printf("\t%2d\t%d\n", SignH.GetKey(i)(), SignH[i]());
93    }
94    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
95      const TNodeI SrcNI = GetNI(EI.GetSrcNId());
96      const TNodeI DstNI = GetNI(EI.GetDstNId());
97      const TInt E1Dat = EI();
98      NbrIdSet.Clr(false);
99      for (int es = 0; es < SrcNI.GetDeg(); es++) {
100        NbrIdSet.AddKey(SrcNI.GetNbrNId(es));
101      }
102      for (int ed = 0; ed < DstNI.GetDeg(); ed++) {
103        const int nbr = DstNI.GetNbrNId(ed);
104        if (! NbrIdSet.IsKey(nbr)) { continue; }
105        const TInt E3Dat = DstNI.GetNbrEDat(ed);
106        for (int ed2 = 0; ed2 < SrcNI.GetDeg(); ed2++) {
107          if (nbr != SrcNI.GetNbrNId(ed2)) { continue; }
108          const TInt E2Dat = SrcNI.GetNbrEDat(ed2);
109          TriadCntH.AddDat(TIntTr(TMath::Mx(E1Dat, E2Dat, E3Dat),
110            TMath::Median(E1Dat, E2Dat, E3Dat), TMath::Mn(E1Dat, E2Dat, E3Dat))) += 1;
111        }
112      }
113    }
114    TriadCntH.SortByKey(false);
115    printf("triad counts (all counts are real, not times 3):\n");
116    int SumTriad = 0, SignTriad=0;
117    for (int i = 0; i < TriadCntH.Len(); i++) {
118      SumTriad += TriadCntH[i];
119      TIntTr SignTr = TriadCntH.GetKey(i);
120      if (SignTr.Val1!=0 && SignTr.Val2!=0 && SignTr.Val3!=0) {
121        SignTriad += TriadCntH[i]; }
122    }
123    for (int i = 0; i < TriadCntH.Len(); i++) {
124      TIntTr SignTr = TriadCntH.GetKey(i);
125      printf("\t%2d %2d %2d\t%8d\t%f", SignTr.Val1(), SignTr.Val2(), SignTr.Val3(),
126        TriadCntH[i]()/3, TriadCntH[i]()/double(SumTriad));
127      if (SignTr.Val1!=0 && SignTr.Val2!=0 && SignTr.Val3!=0) {
128        printf("\t%f", TriadCntH[i]()/double(SignTriad)); }
129      printf("\n");
130    }
131  }
132  void TSignNet::CountBalUnBal(const int& NId1, const int& NId2, int& BalTriads, int& UnBalTriads) const {
133    BalTriads=0; UnBalTriads=0;
134    int Sign=0;
135    if (IsEdge(NId1, NId2)) { Sign=GetEDat(NId1, NId2); }
136    else if (IsEdge(NId2, NId1)) { Sign=GetEDat(NId2, NId1); }
137    else { return; }
138    TNodeI NI1 = GetNI(NId1);
139    TNodeI NI2 = GetNI(NId2);
140    TIntH NbrH(NI1.GetDeg());
141    for (int i = 0; i < NI1.GetDeg(); i++) {
142      const int nid = NI1.GetNbrNId(i);
143      if (nid!=NId1 && nid!=NId2) {
144        NbrH.AddDat(nid, NI1.GetNbrEDat(i));
145      }
146    }
147    for (int i = 0; i < NI2.GetDeg(); i++) {
148      const int nid = NI2.GetNbrNId(i);
149      if (NbrH.IsKey(nid)) {
150        if (Sign*NbrH.GetDat(nid)*NI2.GetNbrEDat(i) == 1) { BalTriads++; }
151        else { UnBalTriads++; }
152      }
153    }
154  }
155  void TSignNet::SetNodePart(const int& PartId) {
156    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
157      NI() = PartId;
158    }
159  }
160  void TSignNet::SetNodePart(TVec<TIntV>& PartNIdV) {
161    SetNodePart(-1);
162    for (int p = 0; p < PartNIdV.Len(); p++) {
163      for (int n = 0; n < PartNIdV[p].Len(); n++) {
164        if (IsNode(PartNIdV[p][n])) {
165          GetNDat(PartNIdV[p][n]) = p+1; }
166      }
167    }
168  }
169  void TSignNet::GetPartStat(const TVec<TIntV>& PartNIdV, const TStr& Desc) const {
170    THash<TIntPr, TIntPr> PartEdgeH;
171    TIntH NIdPartH;
172    int PartSz=0;
173    for (int p = 0; p < PartNIdV.Len(); p++) {
174      for (int n = 0; n < PartNIdV[p].Len(); n++) {
175        NIdPartH.AddDat(PartNIdV[p][n], p);
176      }
177      PartSz += PartNIdV[p].Len();
178    }
179    TInt DstPart;
180    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
181      if (! NIdPartH.IsKey(NI.GetId())) { continue; }
182      const int SrcPart = NIdPartH.GetDat(NI.GetId());
183      for (int e = 0; e < NI.GetOutDeg(); e++) {
184        const int Sign = NI.GetOutEDat(e);
185        TIntPr& IOCnt = PartEdgeH.AddDat(TIntPr(SrcPart, Sign));
186        if (NIdPartH.IsKeyGetDat(NI.GetOutNId(e), DstPart) && SrcPart==DstPart) {
187          if (Sign>0) { IOCnt.Val1++; } else { IOCnt.Val2++; } }
188        else {
189          if (Sign<0) { IOCnt.Val1++; } else { IOCnt.Val2++; } }
190      }
191    }
192    PartEdgeH.SortByKey();
193    printf("%s: Satisfied edges (n:%d, e:%d, %d in partitions)\n", Desc.CStr(), GetNodes(), GetEdges(), PartSz);
194    int OkEdges=0, AllEdges=0;
195    for (int p = 0; p < PartEdgeH.Len(); p++) {
196      double frac = 0.0;
197      if (PartEdgeH[p].Val1+PartEdgeH[p].Val2>0) {
198        frac=PartEdgeH[p].Val1/double(PartEdgeH[p].Val1+PartEdgeH[p].Val2); }
199      OkEdges += PartEdgeH[p].Val1;
200      AllEdges += PartEdgeH[p].Val1 + PartEdgeH[p].Val2;
201      if (p==0 || PartEdgeH.GetKey(p).Val1!=PartEdgeH.GetKey(p-1).Val1) {
202        printf("  %2d  %2d : %6d : %6d  =  %f     size: %d\n", PartEdgeH.GetKey(p).Val1(), PartEdgeH.GetKey(p).Val2(),
203          PartEdgeH[p].Val1(), PartEdgeH[p].Val2(), frac,
204          PartNIdV[PartEdgeH.GetKey(p).Val1].Len());
205      } else {
206        printf("      %2d : %6d : %6d  =  %f\n", PartEdgeH.GetKey(p).Val2(),
207          PartEdgeH[p].Val1(), PartEdgeH[p].Val2(), frac);
208      }
209    }
210    printf("  all ok edges: %d / %d = %f\n\n", OkEdges, AllEdges, OkEdges/double(AllEdges));
211  }
212  void TSignNet::MakeStatusConsistent() {
213    printf("Make status consistent:\n");
214    PSignNet Net2 = TSignNet::New();
215    *Net2 = *this;
216    Net2->PrintInfo("NETWORK");
217    Net2->FlipMinusEdges(-1, 1);
218    TIntV NIdOrderV;
219    Fail;
220    TIntH NIdPosH;
221    for (int i = 0; i < NIdOrderV.Len(); i++) {
222      NIdPosH.AddDat(NIdOrderV[i], i); }
223    TIntPrV DelEdgeV;
224    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
225      if (NIdPosH.GetDat(EI.GetSrcNId()) > NIdPosH.GetDat(EI.GetDstNId())) {
226        DelEdgeV.Add(TIntPr(EI.GetSrcNId(), EI.GetDstNId()));
227      }
228    }
229    printf("  Deleting %d/%d edges\n", DelEdgeV.Len(), GetEdges());
230    for (int e = 0; e < DelEdgeV.Len(); e++) {
231      DelEdge(DelEdgeV[e].Val1, DelEdgeV[e].Val2);
232    }
233    PrintInfo("STATUS CONSISTENT");
234  }
235  void TSignNet::EdgeSignStat() const {
236    int Plus=0, Minus=0;
237    int OneWayP=0, OneWayM=0;
238    int BWayPP=0, BWayPM=0, BWayMM=0;
239    TEdgeI EndE = EndEI();
240    for (TEdgeI EI = BegEI(); EI < EndE; EI++) {
241      const int Sign = EI();
242      TEdgeI EIX = GetEI(EI.GetDstNId(), EI.GetSrcNId());
243      if (Sign==1) { Plus++; } else { Minus++; }
244      if (EIX == EndE) {
245        if (Sign==1) { OneWayP++; } else { OneWayM++; }
246      } else {
247        if (Sign==EIX()) {
248          if (Sign==1) { BWayPP++; } else { BWayMM++; }
249        } else { BWayPM++; }
250      }
251    }
252    printf("Edges +1: %d\n", Plus);
253    printf("Edges -1: %d\n", Minus);
254    printf("One way +1:  %d\n", OneWayP);
255    printf("One way -1:  %d\n", OneWayM);
256    printf("Both way +1: %d\n", BWayPP);
257    printf("Both way -1: %d\n", BWayMM);
258    printf("Both way +1/-1: %d\n\n", BWayPM);
259  }
260  void TSignNet::PlotSignCmnNbrs(const TStr& OutFNm) const {
261    TFltFltH SupCmnH, SupCmnH2, OppCmnH, OppCmnH2;    
262    THash<TFlt, TMom> CmnFracH, CmnFracH2;  
263    PSignNet ThisPt = PSignNet((TSignNet*) this);
264    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
265      const int C = TSnap::GetCmnNbrs(ThisPt, EI.GetSrcNId(), EI.GetDstNId());
266      if (EI() == 1) { SupCmnH.AddDat(C)++;  CmnFracH.AddDat(C).Add(1);
267      } else if (EI() == -1) { OppCmnH.AddDat(C)++;  CmnFracH.AddDat(C).Add(0);  }
268    }
269    PSignNet PermNet = TSignNet::New();  *PermNet = *this;
270    PermNet->PermuteEdgeSigns();
271    for (TEdgeI EI = PermNet->BegEI(); EI < PermNet->EndEI(); EI++) {
272      const int C = TSnap::GetCmnNbrs(PermNet, EI.GetSrcNId(), EI.GetDstNId());
273      if (EI() == 1) { SupCmnH2.AddDat(C)++;  CmnFracH2.AddDat(C).Add(1);
274      } else if (EI() == -1) { OppCmnH2.AddDat(C)++;  CmnFracH2.AddDat(C).Add(0);  }
275    }
276    { TGnuPlot GP("cmnNbrs-"+OutFNm, "Number of common friends of votes");
277    GP.SetXYLabel("Number of common friends", "Number of votes"); GP.SetScale(gpsLog);
278    GP.AddPlot(SupCmnH, gpwLinesPoints, "Support vote");
279    GP.AddPlot(OppCmnH, gpwLinesPoints, "Oppose vote");
280    GP.AddPlot(SupCmnH2, gpwLinesPoints, "PERMUTED: Support vote");
281    GP.AddPlot(OppCmnH2, gpwLinesPoints, "PERMUTED: Oppose vote");
282    GP.SavePng(); }
283    TFltTrV V1, V2;
284    for (int i = 0; i < CmnFracH.Len(); i++) {
285      CmnFracH[i].Def();
286      const double StdErr = CmnFracH[i].GetSDev()/sqrt((double)CmnFracH[i].GetVals());
287      V1.Add(TFltTr(CmnFracH.GetKey(i), CmnFracH[i].GetMean(), StdErr));
288    }
289    for (int i = 0; i < CmnFracH2.Len(); i++) {
290      CmnFracH2[i].Def();
291      const double StdErr = CmnFracH2[i].GetSDev()/sqrt((double)CmnFracH2[i].GetVals());
292      V2.Add(TFltTr(CmnFracH2.GetKey(i), CmnFracH2[i].GetMean(), StdErr));
293    }
294    V1.Sort();  V2.Sort();
295    { TGnuPlot GP("cmnNbrsFrac-"+OutFNm, "Fraction of support votes");
296    GP.SetXYLabel("Number of common friends", "Fraction of support votes"); GP.SetScale(gpsLog);
297    GP.AddErrBar(V1, "True votes", "standard error");
298    GP.AddErrBar(V2, "PERMUTED edge signs", "standard error");
299    GP.SavePng(); }
300  }
301  PSignNet TSignNet::GetTriad(const int& N1, const int& N2, const int& N3) const {
302    PSignNet Net2 = TSignNet::New();
303    Net2->AddNode(0);  Net2->AddNode(1);  Net2->AddNode(2);
304    if (IsEdge(N1, N2)) { Net2->AddEdge(0, 1, GetEDat(N1, N2)); }
305    if (IsEdge(N2, N1)) { Net2->AddEdge(1, 0, GetEDat(N2, N1)); }
306    if (IsEdge(N1, N3)) { Net2->AddEdge(0, 2, GetEDat(N1, N3)); }
307    if (IsEdge(N3, N1)) { Net2->AddEdge(2, 0, GetEDat(N3, N1)); }
308    if (IsEdge(N2, N3)) { Net2->AddEdge(1, 2, GetEDat(N2, N3)); }
309    if (IsEdge(N3, N2)) { Net2->AddEdge(2, 1, GetEDat(N3, N2)); }
310    return Net2;
311  }
312  bool TSignNet::IsClosedTriad() const {
313    if (GetNodes() != 3) { return false; }
314    TNodeI NI = BegNI();
315    const int nid1 = NI.GetId(); NI++;
316    const int nid2 = NI.GetId(); NI++;
317    const int nid3 = NI.GetId();
318    if (IsEdge(nid1, nid2, false) && IsEdge(nid2, nid3, false) && IsEdge(nid1, nid3, false)) {
319      return true; }
320    return false;
321  }
322  bool TSignNet::IsBalanced() const {
323    if (GetEdges()!=3) { printf("%d\n", GetEdges()); }
324    IAssert(GetEdges()==3 && IsClosedTriad());
325    int Sig=1;
326    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
327      Sig *= EI();
328    }
329    if (Sig == 1) { return true; }
330    else { return false; }
331  }
332  double TSignNet::GetTriadProb(const double& PlusProb) const {
333    const int E = GetEdges();
334    int P = 0;
335    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
336      const int sign = EI();  IAssert(sign==1 || sign==-1);
337      if (sign==1) { P++; }
338    }
339    if (GetNodes()==3) { 
340      TNodeI NI = BegNI();
341      int Homo = 1;
342      if (P!=3 && P!=0 && NI.GetOutDeg()==1 && (NI++).GetOutDeg()==1 && (NI++).GetOutDeg()==1) {
343        NI = BegNI();
344        if (NI.GetId() == GetNI(GetNI(NI.GetOutNId(0)).GetOutNId(0)).GetOutNId(0)) {
345          Homo=3; 
346        }
347      }
348      return Homo * pow(PlusProb, P) * pow(1-PlusProb, E-P); 
349    }
350    return pow(PlusProb, P) * pow(1-PlusProb, E-P);
351  }
352  TIntPr TSignNet::GetNewEdge(const PSignNet& OldTriad) const {
353    IAssert(GetNodes()==3 && OldTriad->GetNodes()==3 && GetEdges()-OldTriad->GetEdges()==1);
354    PSignNet New = TSignNet::New(); *New=*this;
355    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
356      New->DelEdge(EI.GetSrcNId(), EI.GetDstNId());
357      if (TSignNet::IsSameTriad(OldTriad, New)!=-1) {
358        return TIntPr(EI.GetSrcNId(), EI.GetDstNId());
359      }
360      New->AddEdge(EI);
361    }
362    Fail;
363    return TIntPr(-1,-1);
364  }
365  int TSignNet::GetEdgeSig(const int& nid1, const int& nid2) const {
366    int e1, e2;
367    if (IsEdge(nid1, nid2)) { e1=GetEDat(nid1,nid2); } else { e1=0; }
368    if (IsEdge(nid2, nid1)) { e2=GetEDat(nid2,nid1); } else { e2=0; }
369    if (e1==0 && e2==0) { return 0; }
370    if (e1==1 && e2==0) { return 1; }
371    if (e1==-1 && e2==0) { return 2; }
372    if (e1==0 && e2==1) { return 3; }
373    if (e1==0 && e2==-1) { return 4; }
374    if (e1==1 && e2==1) { return 5; }
375    if (e1==1 && e2==-1) { return 6; }
376    if (e1==-1 && e2==1) { return 7; }
377    if (e1==-1 && e2==-1) { return 8; }
378    Fail; return -1;
379  }
380  TChA TSignNet::GetEdgeStr(const int& nid1, const int& nid2) const {
381    const int sig = GetEdgeSig(nid1, nid2);
382    return GetEdgeStr(sig);
383  }
384  TIntTr TSignNet::GetTriadSig(const bool& Canonical) const {
385    if (GetNodes()!=3) { return TIntTr(); }
386    TNodeI NI = BegNI();
387    const int nid1 = NI.GetId(); NI++;
388    const int nid2 = NI.GetId(); NI++;
389    const int nid3 = NI.GetId();
390    const int e1 = GetEdgeSig(nid1, nid2);
391    const int e2 = GetEdgeSig(nid2, nid3);
392    const int e3 = GetEdgeSig(nid3, nid1);
393    if (! Canonical) {
394      return TIntTr(e1, e2, e3); }
395    else { 
396      const TIntTr MinTr = TMath::Mn(TIntTr(e1, e2, e3), TIntTr(e2, e3, e1), TIntTr(e3, e1, e2));
397      const int e1a = GetEdgeSig(nid1, nid3);
398      const int e2a = GetEdgeSig(nid3, nid2);
399      const int e3a = GetEdgeSig(nid2, nid1);
400      return TMath::Mn(MinTr, TMath::Mn(TIntTr(e1a, e2a, e3a), TIntTr(e2a, e3a, e1a), TIntTr(e3a, e1a, e2a)));
401    }
402  }
403  TChA TSignNet::GetTriadStr(const bool& Canonical) const {
404    return GetTriadStr(GetTriadSig(Canonical));
405  }
406  TChA TSignNet::GetEdgeStr(const int& EdgeSig) {
407    switch(EdgeSig) {
<span onclick='openModal()' class='match'>408      case 1 : return "+o";
409      case 2 : return "-o";
410      case 3 : return "o+";
411      case 4 : return "o-";
412      case 5 : return "++";
413      case 6 : return "+-";
414      case 7 : return "-+";
</span>415      case 8 : return "--";
416      default : return TChA();
417    }
418  }
419  TChA TSignNet::GetTriadStr(const TIntTr& TriadSig) {
420    return GetEdgeStr(TriadSig.Val1)+"\t"+GetEdgeStr(TriadSig.Val2)+"\t"+GetEdgeStr(TriadSig.Val3);
421  }
422  int TSignNet::IsSameTriad(const PSignNet& Net1, const PSignNet& Net2) {
423    static THash<TInt, TVec<TIntV> > PermH;
424    if (PermH.Empty()) {
425      PermH.AddDat(2).Add(TIntV::GetV(0,1));
426      PermH.AddDat(2).Add(TIntV::GetV(1,0));
427      PermH.AddDat(3).Add(TIntV::GetV(0,1,2));
428      PermH.AddDat(3).Add(TIntV::GetV(0,2,1));
429      PermH.AddDat(3).Add(TIntV::GetV(1,0,2));
430      PermH.AddDat(3).Add(TIntV::GetV(1,2,0));
431      PermH.AddDat(3).Add(TIntV::GetV(2,0,1));
432      PermH.AddDat(3).Add(TIntV::GetV(2,1,0));
433    }
434    if (Net1->GetNodes() != Net2->GetNodes() || Net1->GetEdges() != Net2->GetEdges()) { return -1; }
435    IAssert(Net1->GetNodes()==2 || Net1->GetNodes()==3);
436    const TVec<TIntV>& PermV = PermH.GetDat(Net1->GetNodes());
437    for (int p = 0; p < PermV.Len(); p++) {
438      const TIntV& Perm = PermV[p];
439      TSignNet::TEdgeI EndEI2 = Net2->EndEI();
440      int i = 0;
441      bool Ok = true;
442      for (TSignNet::TNodeI NI1 = Net1->BegNI(); NI1 < Net1->EndNI(); NI1++, i++) {
443        TSignNet::TNodeI NI2 = Net2->GetNI(Perm[i]);
444        if (NI1.GetOutDeg() != NI2.GetOutDeg() || NI1.GetInDeg() != NI2.GetInDeg()) { Ok=false; break; }
445        for (int e = 0; e < NI1.GetOutDeg(); e++) {
446          const TSignNet::TEdgeI EI2 = Net2->GetEI(NI2.GetId(), Perm[NI1.GetOutNId(e)]);
447          if (EI2 == EndEI2 || NI1.GetOutEDat(e) != EI2()) { Ok=false; break; }
448        }
449      }
450      if (Ok) { return p; }
451    }
452    return -1;
453  }
454  void TSignNet::CountSignedTriads(const TStr& OutFNm) const {
455    printf("Count signed triads");
456    TVec<PSignNet> TriadIdV;
457    TVec<PSignNet> TriadIdV2;
458    TIntH TriadIdCntH;
459    TIntV NbrV;
460    PSignNet ThisPt = PSignNet((TSignNet*) this);
461    double AllPlusE=0, AllE = GetEdges();
462    int c=0, Decile=int(AllE/100);
463    TIntH UnSignCntH;
464    TIntH SignToUnsignH;
465    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
466      TSnap::GetCmnNbrs(ThisPt, EI.GetSrcNId(), EI.GetDstNId(), NbrV);
467      for (int n = 0; n < NbrV.Len(); n++) {
468        PSignNet TriadNet = GetTriad(EI.GetSrcNId(), EI.GetDstNId(), NbrV[n]);
469        int TriadId = -1;
470        for (int i = 0; i < TriadIdV.Len() && TriadId==-1; i++) {
471          if (IsSameTriad(TriadIdV[i], TriadNet)!=-1) { TriadId=i; break; } }
472        if (TriadId==-1) { TriadId=TriadIdV.Len();  TriadIdV.Add(TriadNet); }
473        TriadIdCntH.AddDat(TriadId) += 1;
474        TriadNet = GetTriad(EI.GetSrcNId(), EI.GetDstNId(), NbrV[n]);
475        TriadNet->SetAllEDat(1);
476        int TriadId2 = -1;
477        for (int i = 0; i < TriadIdV2.Len() && TriadId2==-1; i++) {
478          if (IsSameTriad(TriadIdV2[i], TriadNet)!=-1) { TriadId2=i; break; } }
479        if (TriadId2==-1) { TriadId2=TriadIdV2.Len();  TriadIdV2.Add(TriadNet); }
480        UnSignCntH.AddDat(TriadId2) += 1;
481        SignToUnsignH.AddDat(TriadId, TriadId2);
482      }
483      if (EI() == 1) { AllPlusE += 1; }
484      if (++c % Decile ==0) { printf("."); }
485    }
486    TVec<TTriple<TInt, TChA, TInt> > SortIdV;
487    for (int t = 0; t < TriadIdCntH.Len(); t++) {
488      PSignNet Net = TriadIdV[TriadIdCntH.GetKey(t)];
489      const int E = Net->GetEdges();
490      TriadIdCntH[t].Val /= E;
491      SortIdV.Add(TTriple<TInt, TChA, TInt>(Net->GetEdges(), Net->GetTriadStr(true), TriadIdCntH.GetKey(t)));
492    }
493    for (int u=0; u < UnSignCntH.Len(); u++) {
494      const int E = TriadIdV2[UnSignCntH.GetKey(u)]->GetEdges();
495      UnSignCntH[u].Val /= E;
496      printf("unsigned count:  %d\t%d\t%d\n", UnSignCntH.GetKey(u)(), E, UnSignCntH[u]());
497    }
498    SortIdV.Sort();
499    const double PlusProb = AllPlusE / AllE;
500    FILE *T = fopen(TStr::Fmt("SignTriad-%s.tab", OutFNm.CStr()).CStr(), "wt");
501    fprintf(T, "AB\tBC\tCA\tCount\tE[Count]\tSurprise\tTriadProb\n");
502    printf("%d triads\n", TriadIdCntH.Len());
503    printf("plus prob %d / %d = %f\n", int(AllPlusE), int(AllE), PlusProb);
504    for (int t = 0; t < SortIdV.Len(); t++) {
505      const int Id = SortIdV[t].Val3;
506      int PlusE = 0;
507      PSignNet TriadNet = TriadIdV[Id];
508      TStr FNm = TStr::Fmt("SignTriad-%s-%02d", OutFNm.CStr(), t+1);
509      FILE *F = fopen(TStr(FNm+".dot").CStr(), "wt");
510      fprintf(F, "digraph G {\n");
511      fprintf(F, "  graph [splines=true, overlap=false]\n  node  [shape=ellipse, width=0.3, height=0.3 label=\"\"]\n");
512      for (TEdgeI EI = TriadNet->BegEI(); EI < TriadNet->EndEI(); EI++) {
513        fprintf(F, "  n%d -> n%d [label=\"%s\" len=2];\n", EI.GetSrcNId(), EI.GetDstNId(),  EI()==1?"+":"--");
514        if (EI() == 1) { PlusE++; }
515      }
516      const double TriadCnt = TriadIdCntH.GetDat(Id);
517      const double TriadProb = TriadNet->GetTriadProb(PlusProb);
518      const double UnSignCnt = UnSignCntH.GetDat(SignToUnsignH.GetDat(Id)).Val;
519      const double ExpCnt = TriadProb * UnSignCnt; 
520      const double Surp = (TriadCnt-ExpCnt) / sqrt(UnSignCnt*TriadProb*(1.0-TriadProb));
521      fprintf(F, "  label = \"T=%d, E[T]=%d, S=%.1f\";\n}\n", int(TriadCnt), int(ExpCnt), Surp);
522      fclose(F);
523      TGraphViz::DoLayout(FNm+".dot", FNm+".gif",  gvlNeato);
524      fprintf(T, "%s\t%d\t%d\t%.2f\t%f\n", TriadNet->GetTriadStr(true).CStr(), int(TriadCnt), int(ExpCnt), Surp, TriadProb);
525    }
526    fclose(T);
527    printf("\n");
528  }
529  void TSignNet::PlotGraphProp(const TStr& OutFNm) const {
530    PSignNet Net = GetSignSubNet(+1);
531    while (Net->GetNodes() < GetNodes()) { Net->AddNode(); }
532    TSnap::PlotOutDegDistr(Net, OutFNm+"-plus");
533    TSnap::PlotInDegDistr(Net, OutFNm+"-plus");
534    TSnap::PlotWccDistr(Net, OutFNm+"-plus");
535    TSnap::PlotClustCf(Net, OutFNm+"-plus");
536    const int NPlus = Net->GetEdges();
537    Net = TSnap::GetRndESubGraph(PSignNet((TSignNet*) this), NPlus);
538    while (Net->GetNodes() < GetNodes()) { Net->AddNode(); }
539    TSnap::PlotOutDegDistr(Net, OutFNm+"-plusRnd");
540    TSnap::PlotInDegDistr(Net, OutFNm+"-plusRnd");
541    TSnap::PlotWccDistr(Net, OutFNm+"-plusRnd");
542    TSnap::PlotClustCf(Net, OutFNm+"-plusRnd");
543    Net = GetSignSubNet(-1);
544    while (Net->GetNodes() < GetNodes()) { Net->AddNode(); }
545    TSnap::PlotOutDegDistr(Net, OutFNm+"-minus");
546    TSnap::PlotInDegDistr(Net, OutFNm+"-minus");
547    TSnap::PlotWccDistr(Net, OutFNm+"-minus");
548    TSnap::PlotClustCf(Net, OutFNm+"-minus");
549    const int NMinus = Net->GetEdges();
550    Net = TSnap::GetRndESubGraph(PSignNet((TSignNet*) this), NMinus);
551    while (Net->GetNodes() < GetNodes()) { Net->AddNode(); }
552    TSnap::PlotOutDegDistr(Net, OutFNm+"-minusRnd");
553    TSnap::PlotInDegDistr(Net, OutFNm+"-minusRnd");
554    TSnap::PlotWccDistr(Net, OutFNm+"-minusRnd");
555    TSnap::PlotClustCf(Net, OutFNm+"-minusRnd");
556  }
557  void TSignNet::PlotInOutPlusFrac(const TStr& OutFNm) const {
558    THash<TFltPr, TInt> CntH, Cnt2H;
559    THash<TFltPr, TInt> FracH, Frac2H;
560    const int FracRes = 100;
561    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
562      int PlusIn=1, PlusOut=1, MinusIn=1, MinusOut=1;
563      for (int i = 0; i < NI.GetOutDeg(); i++) {
564        if (NI.GetOutEDat(i)==1) { PlusOut++; } else { MinusOut++; } }
565      for (int i = 0; i < NI.GetInDeg(); i++) {
566        if (NI.GetInEDat(i)==1) { PlusIn++; } else { MinusIn++; } }
567      CntH.AddDat(TFltPr(PlusOut+TInt::Rnd.GetUniDev(), PlusIn+TInt::Rnd.GetUniDev())) += 1;
568      Cnt2H.AddDat(TFltPr(MinusOut+TInt::Rnd.GetUniDev(), MinusIn+TInt::Rnd.GetUniDev())) += 1;
569      FracH.AddDat(TFltPr(TInt::Rnd.GetUniDev()+int(FracRes*PlusOut/double(NI.GetOutDeg()+1)), TInt::Rnd.GetUniDev()+int(FracRes*PlusIn/double(NI.GetInDeg()+1)))) += 1;
570      Frac2H.AddDat(TFltPr(TInt::Rnd.GetUniDev()+int(FracRes*MinusOut/double(NI.GetOutDeg()+1)), TInt::Rnd.GetUniDev()+int(FracRes*MinusIn/double(NI.GetInDeg()+1)))) += 1;
571    }
572    TFltPrV V1;  TFltPrV V2;
573    CntH.GetKeyV(V1);
574    FracH.GetKeyV(V2);
575    TGnuPlot::PlotValV(V1, "plusCnt."+OutFNm, OutFNm, "number of pluses out", "number of pluses in", gpsLog10XY, false, gpwPoints);
576    TGnuPlot::PlotValV(V2, "plusFrac."+OutFNm, OutFNm, "fraction of pluses out", "fraction of pluses in", gpsAuto, false, gpwPoints);
577    Cnt2H.GetKeyV(V1);
578    Frac2H.GetKeyV(V2);
579    TGnuPlot::PlotValV(V1, "minusCnt."+OutFNm, OutFNm, "number of minuses out", "number of minuses in", gpsLog10XY, false, gpwPoints);
580    TGnuPlot::PlotValV(V2, "minusFrac."+OutFNm, OutFNm, "fraction of minuses out", "fraction of minuses in", gpsAuto, false, gpwPoints);
581  }
582  void TSignNet::SavePajek(const TStr& OutFNm) {
583    const TStrV ClrV = TStrV::GetV("Gray45", "Green", "Magenta", "Cyan", "OliveGreen", "NavyBlue", "Orange", "Purple", "Brown");
584    const int Clrs = ClrV.Len();
585    TIntH NodeClr;
586    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) { NodeClr.AddKey(NI()); }
587    FILE *F = fopen(OutFNm.CStr(), "wt");
588    TIntH NIdToIdH(GetNodes(), true);
589    fprintf(F, "*Vertices %d\n", GetNodes());
590    int i = 0;
591    for (TNodeI NI = BegNI(); NI < EndNI(); NI++, i++) {
592      fprintf(F, "%d  \"%d\" ic %s fos 10\n", i+1, NI.GetId(), ClrV[NodeClr.GetKeyId(NI())%Clrs].CStr());
593      NIdToIdH.AddDat(NI.GetId(), i+1);
594    }
595    fprintf(F, "*Arcs %d\n", GetEdges()); 
596    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
597      const int NId = NIdToIdH.GetDat(NI.GetId());
598      for (int e = 0; e < NI.GetOutDeg(); e++) {
599        TStr EdgeColor = "Gray45";
600        if (NI()!=-1 && NI.GetOutNDat(e)!=-1) { 
601          if (NI.GetOutEDat(e)==-1) {
602            EdgeColor = NI()!=NI.GetOutNDat(e) ? "Blue":"Red"; }  
603          else if (NI.GetOutEDat(e)==1) {
604            EdgeColor = NI()==NI.GetOutNDat(e) ? "Blue":"Red"; }  
605        }
606        fprintf(F, "%d %d %g c %s\n", NId, NIdToIdH.GetDat(NI.GetOutNId(e)).Val, 1.0, EdgeColor.CStr());
607      }
608    }
609    fclose(F);
610  }
611  void TSignNet::SaveTxt(const TStr& OutFNm) const {
612    FILE *F = fopen(OutFNm.CStr(), "wt");
613    fprintf(F, "# Signed network. %d nodes, %d edges\n", GetNodes(), GetEdges());
614    fprintf(F, "# Source\tDestination\tEdgeSign\n");
615    THashSet<TInt> NIdSet;
616    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
617      NIdSet.AddKey(EI.GetSrcNId());  NIdSet.AddKey(EI.GetDstNId());
618      fprintf(F, "%d\t%d\t%d\n", NIdSet.GetKeyId(EI.GetSrcNId()), NIdSet.GetKeyId(EI.GetDstNId()), EI());
619    }
620    fclose(F);
621  }
622  void TSignNet::DrawGraphViz(const TStr& OutFNm, const TStr& Desc, const bool& NodeLabels, const bool& EdgeLabels, const bool& SaveDir) {
623    FILE *F = fopen(TStr(OutFNm+".dot").CStr(), "wt");
624    if (! SaveDir) { fprintf(F, "graph G {\n"); }
625    else { fprintf(F, "digraph G {\n"); }
626    fprintf(F, "  graph [splines=true, overlap=false]\n");
627    fprintf(F, "  node  [shape=ellipse, width=0.3, height=0.3 %s]\n", NodeLabels?"":", label=\"\"");
628    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
629      fprintf(F, "  %d %s;\n", NI.GetId(), NodeLabels?TStr::Fmt("[label=\"%d : %d\"]", NI.GetId(), NI()).CStr():"");
630    }
631    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
632      for (int e = 0; e < NI.GetOutDeg(); e++) {
633        if (! SaveDir) {
634          if (! IsEdge(NI.GetOutNId(e), NI.GetId())) {
635            fprintf(F, "  %d -- %d [dir=\"forward\"%s];\n", NI.GetId(), NI.GetOutNId(e),
636              EdgeLabels?TStr::Fmt(", label=\"%d\"", GetEDat(NI.GetId(), NI.GetOutNId(e))).CStr():"");  
637          } else if (NI.GetId() < NI.GetOutNId(e)) {
638            fprintf(F, "  %d -- %d %s;\n", NI.GetId(), NI.GetOutNId(e),
639              EdgeLabels?TStr::Fmt("[label=\"%d/%d\"]", GetEDat(NI.GetId(), NI.GetOutNId(e)), 
640              GetEDat(NI.GetOutNId(e), NI.GetId())).CStr():"");  
641          }
642        } else {
643          fprintf(F, "  %d -> %d %s;\n", NI.GetId(), NI.GetOutNId(e),
644            EdgeLabels?TStr::Fmt("[label=\"%d\"]", GetEDat(NI.GetId(), NI.GetOutNId(e))).CStr():"");
645        }
646      }
647    }
648    if (! Desc.Empty()) {
649      fprintf(F, "  label = \"\\n%s\\n\";\n", Desc.CStr());
650    }
651    fprintf(F, "  fontsize=24;\n");
652    fprintf(F, "}\n");
653    fclose(F);
654    TGraphViz::DoLayout(OutFNm+".dot", OutFNm+".gif",  gvlNeato);
655  }
656  void TSignNet::PrintInfo(const TStr& Desc) const {
657    if (! Desc.Empty()) { printf("%s\n", Desc.CStr()); }
658    else { printf("Signed network\n"); }
659    TIntH SignH;
660    int edges = 0;
661    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
662      SignH.AddDat(EI()) += 1;
663      edges++;
664    }
665    SignH.SortByKey();
666    printf("  nodes: %d\n", GetNodes());
667    printf("  edges: %d\n", edges);
668    for (int i = 0; i < SignH.Len(); i++) {
669      printf("  %2d: %d\n", SignH.GetKey(i), SignH[i]);
670    }
671    printf("\n");
672  }
673  void TSignNet::Dump() const {
674    printf("Net (%d, %d)\n", GetNodes(), GetEdges());
675    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
676      printf("  %d\t%d\t%d\n", EI.GetSrcNId(), EI.GetDstNId(), EI());
677    }
678    printf("\n");
679  }
680  bool TSignMicroEvol::IsSameTriad(const PSignNet& Net1, const PSignNet& Net2, const TIntV& Perm) const {
681    int i = 0;
682    TSignNet::TEdgeI EndEI2 = Net2->EndEI();
683    for (TSignNet::TNodeI NI1 = Net1->BegNI(); NI1 < Net1->EndNI(); NI1++, i++) {
684      TSignNet::TNodeI NI2 = Net2->GetNI(Perm[i]);
685      if (NI1.GetOutDeg() != NI2.GetOutDeg() || NI1.GetInDeg() != NI2.GetInDeg()) {
686        return false;
687      }
688      for (int e = 0; e < NI1.GetOutDeg(); e++) {
689        const TSignNet::TEdgeI EI2 = Net2->GetEI(NI2.GetId(), Perm[NI1.GetOutNId(e)]);
690        if (EI2 == EndEI2 || NI1.GetOutEDat(e) != EI2()) {
691          return false;
692        }
693      }
694    }
695    return true;
696  }
697  void TSignNet::GetPartOverlap(const TVec<TIntV>& PartNIdV1, const TVec<TIntV>& PartNIdV2) {
698    printf("Partition overlap:\n");
699    for (int p2 = 0; p2 < PartNIdV2.Len(); p2++) {
700      printf("\t%6d(%d)", p2, PartNIdV2[p2].Len());
701    }
702    printf("\n");
703    for (int p1 = 0; p1 < PartNIdV1.Len(); p1++) {
704      printf("%6d(%d)\t", p1, PartNIdV1[p1].Len());
705      for (int p2 = 0; p2 < PartNIdV2.Len(); p2++) {
706        printf("%9d\t", PartNIdV1[p1].IntrsLen(PartNIdV2[p2]));
707      }
708      printf("\n");
709    }
710  }
711  PSignNet TSignNet::LoadEpinions(const TStr& FNm) {
712    TSsParser Ss(FNm, ssfTabSep);
713    PSignNet Net = TSignNet::New();
714    while (Ss.Next()) {
715      const int src = Ss.GetInt(0);
716      const int dst = Ss.GetInt(1);
717      if (src == dst) { continue; } 
718      if (!Net->IsNode(Ss.GetInt(0))) {
719        Net->AddNode(Ss.GetInt(0));
720      }
721      if (!Net->IsNode(Ss.GetInt(0))) {
722        Net->AddNode(Ss.GetInt(1));
723      }
724      Net->AddEdge(Ss.GetInt(0), Ss.GetInt(1), Ss.GetInt(2));
725    }
726    return Net;
727  }
728  PSignNet TSignNet::LoadSlashdot(const TStr& InFNm) {
729    THashSet<TChA> NIdSet;
730    TChA LnStr;
731    TVec<char *> WrdV;
732    int Sign;
733    PSignNet Net = TSignNet::New();
734    for (TFIn FIn(InFNm); FIn.GetNextLn(LnStr); ) {
735      if (LnStr.Empty() || LnStr[0]=='#') { continue; }
736      LnStr.ToLc();
737      TStrUtil::SplitOnCh(LnStr, WrdV, '\t', false);
738      NIdSet.AddKey(WrdV[0]);
739      if (strcmp(WrdV[1], "friends")==0) { Sign = 1; }
740      else if (strcmp(WrdV[1], "fans")==0) { continue; } 
741      else if (strcmp(WrdV[1], "foes")==0) { Sign = -1; } else { Fail; }
742      const int SrcNId = NIdSet.AddKey(WrdV[0]);
743      if (! Net->IsNode(SrcNId)) {
744        Net->AddNode(SrcNId); }
745      for (int e = 2; e < WrdV.Len(); e++) {
746        const int DstNId = NIdSet.AddKey(WrdV[e]);
747        if (SrcNId != DstNId && ! Net->IsEdge(SrcNId, DstNId)) {
748          Net->AddNode(DstNId);
749          Net->AddEdge(SrcNId, DstNId, Sign);
750        }
751      }
752    }
753    TSnap::PrintInfo(Net, InFNm);
754    return Net;
755  }
756  PSignNet TSignNet::GetSmallNet() {
757    PSignNet Net = TSignNet::New();
758    for (int i = 0; i < 5; i ++) { Net->AddNode(); }
759    Net->AddEdge(0,1, +1); Net->AddEdge(1,2, +1); Net->AddEdge(2,0, -1);  Net->AddEdge(0,2, -1);
760    Net->AddEdge(1,3, +1);
761    Net->AddEdge(3,4, +1); Net->AddEdge(4,3, +1);
762     Net->AddEdge(1,4, +1);
763    return Net;
764  }
765  int THopfield::MinEnergy(const int& NPart) {
766    TIntV NIdV(Net->GetNodes(), 0);
767    for (TSignNet::TNodeI NI = Net->BegNI(); NI < Net->EndNI(); NI++) {
768      NIdPartH.AddDat(NI.GetId(), TInt::Rnd.GetUniDevInt(NPart));
769      NIdV.Add(NI.GetId());
770    }
771    TIntPrV EnergyV(NPart); 
772    int Flips = 0;
773    for (int iter = 0; iter < 100; iter++) {
774      NIdV.Shuffle(TInt::Rnd);
775      Flips = 0;
776      for (int n = 0; n < NIdV.Len(); n++) {
777        TSignNet::TNodeI NI = Net->GetNI(NIdV[n]);
778        for (int p = 0; p < NPart; p++) {
779          EnergyV[p].Val1=0;  EnergyV[p].Val2=p; }
780        for (int e = 0; e < NI.GetOutDeg(); e++) {
781          const int DstPart = NIdPartH.GetDat(NI.GetOutNId(e));
782          const int Sign = NI.GetOutEDat(e);
783          EnergyV[DstPart].Val1 += Sign;
784        }
785        EnergyV.Sort(false); 
786        const int NewPart = EnergyV[0].Val2;
787        if (NIdPartH.GetDat(NI.GetId()) != NewPart) { 
788          NIdPartH.AddDat(NI.GetId(), NewPart);
789          Flips++;
790        }
791      }
792    }
793    int OkMns=0, OkPls=0, AllMns=0, AllPls=0;
794    for (TSignNet::TNodeI NI = Net->BegNI(); NI < Net->EndNI(); NI++) {
795      const int SrcPart = NIdPartH.GetDat(NI.GetId());
796      for (int e = 0; e < NI.GetOutDeg(); e++) {
797        const int DstPart = NIdPartH.GetDat(NI.GetOutNId(e));
798        const int Vote = NI.GetOutEDat(e);
799        if (Vote < 0) {
800          if (DstPart != SrcPart) { OkMns++; }
801          AllMns++; }
802        if (Vote > 0) {
803          if (DstPart == SrcPart) { OkPls++; }
804          AllPls++;
805        }
806      }
807    }
808    if (OkPls+OkMns > MxEnergy) {
809      MxEnergy = OkPls+OkMns;
810      BestPart = NIdPartH;
811    }
812    return OkPls+OkMns;
813  }
814  int THopfield::FindStableSet(const int& NPart, const int& NRuns) {
815    NIdPartH.Clr();
816    for (TSignNet::TNodeI NI = Net->BegNI(); NI < Net->EndNI(); NI++) {
817      NIdPartH.AddDat(NI.GetId(), 0);
818    }
819    TIntPrV PartSzV(NPart);
820    int MxOk=0, SumOk=0;
821    printf("Find stable set %d runs\n", NRuns);
822    for (int runs = 0; runs < NRuns; runs++) {
823      const int OkEdges = MinEnergy(NPart);
824      EnergDistr.AddDat(OkEdges) += 1;
825      for (int i = 0; i < NPart; i++) {
826        PartSzV[i]=TIntPr(0,i); }
827      for (int i = 0; i < NIdPartH.Len(); i++) {
828        PartSzV[NIdPartH[i]].Val1 += 1; }
829      PartSzV.Sort(false); 
830      for (int i = 0; i < NIdPartH.Len(); i++) {
831        const int PartId = PartSzV[NIdPartH[i]].Val2;
832        NIdPartCnt.AddDat(NIdPartH.GetKey(i))[PartId] += 1;
833      }
834      SumOk += OkEdges;
835      MxOk = TMath::Mx(MxOk, OkEdges);
836    }
837    printf("  Best: %d   Average: %d\n", MxOk, SumOk/NRuns);
838    return MxOk;
839  }
840  void THopfield::GetStableSet(const int& Tresh, TVec<TIntV>& PartNIdV) {
841    PartNIdV.Gen(NIdPartCnt[0].Len());
842    for (int i = 0; i < NIdPartCnt.Len(); i++) {
843      const int MxPart = NIdPartCnt[i].FindMx();
844      if (NIdPartCnt[i][MxPart] >= Tresh) {
845        PartNIdV[MxPart].Add(NIdPartCnt.GetKey(i));
846      }
847    }
848    while (! PartNIdV.Empty() && PartNIdV.Last().Empty()) {
849      PartNIdV.DelLast();
850    }
851    for (int p = 0; p < PartNIdV.Len(); p++) {
852      PartNIdV[p].Sort();
853    }
854  }
855  void THopfield::PlotPartStab(const TStr& FNm, TStr Desc) const {
856    int runs = 0;
857    for (int r = 0; r < EnergDistr.Len(); r++) {
858      runs+=EnergDistr[r];
859    }
860    if (Desc.Empty()) { Desc = FNm; }
861    for (int part = 0; part < NIdPartCnt[0].Len(); part++) {
862      TIntH PartH;
863      for (int n = 0; n < NIdPartCnt.Len(); n++) {
864        if (NIdPartCnt[n][part]>0) {
865          PartH.AddDat(NIdPartCnt[n][part]) += 1;
866        }
867      }
868      if (PartH.Len() <= 1) { continue; }
869      TGnuPlot::PlotValCntH(PartH, TStr::Fmt("partStab-%s-%d", FNm.CStr(), part), TStr::Fmt("%s: Partition %d stability. %d runs. Best energy: %d",
870        Desc.CStr(), part, runs, MxEnergy), "Number of times in the partition", "Number of nodes", gpsAuto, false);
871    }
872    TGnuPlot::PlotValCntH(EnergDistr, "hopfEnerg-"+FNm, TStr::Fmt("%s: Hopfield energy distribution over %d runs. Max: %d", Desc.CStr(), runs, MxEnergy),
873      TStr::Fmt("Energy (number of satisfied edges, out of %d", Net->GetEdges()), "Number of solutions");
874  }
875  void THopfield::DumpPartStat() const {
876    int OkMns=0, OkPls=0, AllMns=0, AllPls=0;
877    TIntH OkPlsH, AllPlsH, OkMnsH, AllMnsH;
878    int NPart=0;
879    for (int i = 0; i < NIdPartH.Len(); i++) {
880      NPart = TMath::Mx(NIdPartH[i].Val, NPart);
881    }
882    for (int p = 0; p < NPart; p++) {
883      OkPlsH.AddDat(p,0); AllPlsH.AddDat(p,0);
884      OkMnsH.AddDat(p,0); AllMnsH.AddDat(p,0);
885    }
886    for (TSignNet::TNodeI NI = Net->BegNI(); NI < Net->EndNI(); NI++) {
887      const int SrcPart = NIdPartH.GetDat(NI.GetId());
888      for (int e = 0; e < NI.GetOutDeg(); e++) {
889        const int DstPart = NIdPartH.GetDat(NI.GetOutNId(e));
890        const int Vote = NI.GetOutEDat(e);
891        if (Vote == -1) {
892          if (DstPart != SrcPart) { OkMnsH.AddDat(SrcPart) += 1;  OkMns++; }
893          AllMnsH.AddDat(SrcPart) += 1;  AllMns++; }
894        if (Vote == +1) {
895          if (DstPart == SrcPart) { OkPlsH.AddDat(SrcPart) += 1;  OkPls++; }
896          AllPlsH.AddDat(SrcPart) += 1;  AllPls++;
897        }
898      }
899    }
900    printf("\nSatisfied edges: + : %5d / %5d  = %f\n", OkPls, AllPls, double(OkPls)/double(AllPls));
901    printf(  "                 - : %5d / %5d  = %f\n", OkMns, AllMns, double(OkMns)/double(AllMns));
902    TIntH PartCntH;
903    for (TSignNet::TNodeI NI = Net->BegNI(); NI < Net->EndNI(); NI++) {
904      PartCntH.AddDat(NIdPartH.GetDat(NI.GetId())) += 1; }
905    PartCntH.SortByKey();
906    for (int p = 0; p < PartCntH.Len(); p++) {
907      printf("  part %2d : %5d (%.4f) nodes: +: %25s    -: %25s\n", p, PartCntH[p], PartCntH[p]/double(NIdPartH.Len()),
908        TStr::Fmt("%5d/%d=%.4f", OkPlsH.GetDat(PartCntH.GetKey(p)), AllPlsH.GetDat(PartCntH.GetKey(p)), OkPlsH.GetDat(PartCntH.GetKey(p))/double(AllPlsH.GetDat(PartCntH.GetKey(p)))).CStr(),
909        TStr::Fmt("%5d/%d=%.4f", OkMnsH.GetDat(PartCntH.GetKey(p)), AllMnsH.GetDat(PartCntH.GetKey(p)), OkMnsH.GetDat(PartCntH.GetKey(p))/double(AllMnsH.GetDat(PartCntH.GetKey(p)))).CStr() );
910    }
911  }
912  void TSignMicroEvol::BuildPerms() {
913    PermH.Clr();
914    PermH.AddDat(2).Add(TIntV::GetV(0,1));
915    PermH.AddDat(2).Add(TIntV::GetV(1,0));
916    PermH.AddDat(3).Add(TIntV::GetV(0,1,2));
917    PermH.AddDat(3).Add(TIntV::GetV(0,2,1));
918    PermH.AddDat(3).Add(TIntV::GetV(1,0,2));
919    PermH.AddDat(3).Add(TIntV::GetV(1,2,0));
920    PermH.AddDat(3).Add(TIntV::GetV(2,0,1));
921    PermH.AddDat(3).Add(TIntV::GetV(2,1,0));
922  }
923  TSignMicroEvol::TSignMicroEvol(PSignNet NetPt) : Network(NetPt) {
924    TransNet = TTransitionNet::New();
925    BuildPerms();
926  }
927  TSignMicroEvol::TSignMicroEvol(TSIn& SIn) {
928    TInt Nets(SIn);
929    for (int n = 0; n < Nets; n++) {
930      TriadIdV.Add(TSignNet::Load(SIn));
931    }
932    TransNet = TTransitionNet::Load(SIn);
933    TInt Diads(SIn);
934    for (int d = 0; d < Diads; d++) {
935      OpnTriadV.Add(TSignNet::Load(SIn));
936    }
937    CloseTriadH.Load(SIn);
938    Triad3to4H.Load(SIn);
939    BuildPerms();
940  }
941  void TSignMicroEvol::Save(TSOut& SOut) const {
942    SOut.Save(TriadIdV.Len());
943    for (int n = 0; n < TriadIdV.Len(); n++) {
944      TriadIdV[n]->Save(SOut);
945    }
946    TransNet->Save(SOut);
947    SOut.Save(OpnTriadV.Len());
948    for (int d = 0; d < OpnTriadV.Len(); d++) {
949      OpnTriadV[d]->Save(SOut);
950    }
951    CloseTriadH.Save(SOut);
952    Triad3to4H.Save(SOut);
953  }
954  PSignNet TSignMicroEvol::GetSubGraph(const int& N1, const int& N2) {
955    PSignNet Net2 = TSignNet::New();
956    Net2->AddNode(0);  Net2->AddNode(1);
957    if (Network->IsEdge(N1, N2)) { Net2->AddEdge(0, 1, Network->GetEDat(N1, N2)); }
958    if (Network->IsEdge(N2, N1)) { Net2->AddEdge(1, 0, Network->GetEDat(N2, N1)); }
959    return Net2;
960  }
961  PSignNet TSignMicroEvol::GetSubGraph(const int& N1, const int& N2, const int& N3) {
962    PSignNet Net2 = TSignNet::New();
963    Net2->AddNode(0);  Net2->AddNode(1);  Net2->AddNode(2);
964    if (Network->IsEdge(N1, N2)) { Net2->AddEdge(0, 1, Network->GetEDat(N1, N2)); }
965    if (Network->IsEdge(N2, N1)) { Net2->AddEdge(1, 0, Network->GetEDat(N2, N1)); }
966    if (Network->IsEdge(N1, N3)) { Net2->AddEdge(0, 2, Network->GetEDat(N1, N3)); }
967    if (Network->IsEdge(N3, N1)) { Net2->AddEdge(2, 0, Network->GetEDat(N3, N1)); }
968    if (Network->IsEdge(N2, N3)) { Net2->AddEdge(1, 2, Network->GetEDat(N2, N3)); }
969    if (Network->IsEdge(N3, N2)) { Net2->AddEdge(2, 1, Network->GetEDat(N3, N2)); }
970    return Net2;
971  }
972  void TSignMicroEvol::CountTriadClose(const int& SrcNId, const int& DstNId, const int& Sign, const double& SrcOutPlusProb,
973                               const double& DstInPlusProb, const bool& OnlySimpleTriads) {
974    IAssert(! Network->IsEdge(SrcNId, DstNId));
975    if (! Network->IsEdge(DstNId, SrcNId)) {
976      TIntV NbrV;
977      TSnap::GetCmnNbrs(Network, SrcNId, DstNId, NbrV);
978      for (int n = 0; n < NbrV.Len(); n++) {
979        PSignNet Net1 = GetSubGraph(SrcNId, DstNId, NbrV[n]);
980        PSignNet Net2 = GetSubGraph(SrcNId, DstNId, NbrV[n]);
981        Net2->AddEdge(0, 1, Sign); 
982        const int Net1Id = GetTriadId(Net1);
983        const int Net2Id = GetTriadId(Net2);
984        if (! TransNet->IsNode(Net1Id)) { TransNet->AddNode(Net1Id, 0); }
985        if (! TransNet->IsNode(Net2Id)) { TransNet->AddNode(Net2Id, 0); }
986        if (! TransNet->IsEdge(Net1Id, Net2Id)) { TransNet->AddEdge(Net1Id, Net2Id); }
987        TransNet->GetNDat(Net1Id) += 1;
988        TransNet->GetNDat(Net2Id) += 1;
989        { TTransStat& Stat = TransNet->GetEDat(Net1Id, Net2Id);
990        if (Sign == +1) { Stat.SumWgt += SrcOutPlusProb; }
991        else { Stat.SumWgt+= 1-SrcOutPlusProb; }
992        Stat.Cnt++;  Stat.VarSq += SrcOutPlusProb*(1-SrcOutPlusProb); }
993        { const int TrId = GetOpnTriadId(Net1);
994        TCloseStat& ClsStat = CloseTriadH.AddDat(TrId);
995        if (Sign == +1) { ClsStat.PlsCnt++; }
996        else { ClsStat.MnsCnt++; }
997        ClsStat.OutSumWgt += SrcOutPlusProb;
998        ClsStat.OutVarSq += SrcOutPlusProb*(1-SrcOutPlusProb);
999        ClsStat.InSumWgt += DstInPlusProb;
1000        ClsStat.InVarSq += DstInPlusProb*(1-DstInPlusProb);
1001        ClsStat.OutPlusPH.AddDat(int(SrcOutPlusProb*50)*2) += 1;
1002        ClsStat.InPlusPH.AddDat(int(DstInPlusProb*50)*2) += 1; }
1003      }
1004    } else { 
1005      RepLinkCntH.AddDat(TIntPr(Network->GetEDat(DstNId, SrcNId), Sign)).Val1 += 1;
1006      RepLinkCntH.AddDat(TIntPr(Network->GetEDat(DstNId, SrcNId), Sign)).Val2 += SrcOutPlusProb;
1007    }
1008    if (OnlySimpleTriads && Network->IsEdge(DstNId, SrcNId)) {
1009      return; }
1010    else {
1011      Network->AddNode(SrcNId);
1012      Network->AddNode(DstNId);
1013      Network->AddEdge(SrcNId, DstNId, Sign);
1014    }
1015  }
1016  void TSignMicroEvol::CountTriad3to4Edges(const int& SrcNId, const int& DstNId, const int& Sign, const double& SrcOutPlusProb, const double& DstInPlusProb) {
1017    IAssert(! Network->IsEdge(SrcNId, DstNId));
1018    TIntV NbrV;
1019    TSnap::GetCmnNbrs(Network, SrcNId, DstNId, NbrV);
1020    for (int n = 0; n < NbrV.Len(); n++) {
1021      PSignNet Net1 = GetSubGraph(SrcNId, DstNId, NbrV[n]);
1022      if (! (Net1->GetEdges()==3 && Net1->IsClosedTriad())) { continue; }
1023      PSignNet Net2 = GetSubGraph(SrcNId, DstNId, NbrV[n]);
1024      Net2->AddEdge(0, 1, +1); 
1025      const int Net1Id = GetTriadId(Net1);
1026      const int Net2Id = GetTriadId(Net2);
1027      TCloseStat& ClsStat = Triad3to4H.AddDat(TIntPr(Net1Id, Net2Id));
1028      if (Sign == +1) { ClsStat.PlsCnt++; }
1029      else { ClsStat.MnsCnt++; }
1030      ClsStat.OutSumWgt += SrcOutPlusProb;
1031      ClsStat.OutVarSq += SrcOutPlusProb*(1-SrcOutPlusProb);
1032      ClsStat.InSumWgt += DstInPlusProb;
1033      ClsStat.InVarSq += DstInPlusProb*(1-DstInPlusProb);
1034      ClsStat.OutPlusPH.AddDat(int(SrcOutPlusProb*50)*2) += 1;
1035      ClsStat.InPlusPH.AddDat(int(DstInPlusProb*50)*2) += 1;
1036    }
1037    Network->AddNode(SrcNId);
1038    Network->AddNode(DstNId);
1039    Network->AddEdge(SrcNId, DstNId, Sign);
1040  }
1041  void TSignMicroEvol::CountTriadCloseVec(const int& SrcNId, const int& DstNId, const int& Sign) {
1042    TIntV NbrV;
1043    TSnap::GetCmnNbrs(Network, SrcNId, DstNId, NbrV);
1044    TTuple<TInt, 16> CntV;
1045    for (int n = 0; n < NbrV.Len(); n++) {
1046      PSignNet OpnTriadNet = GetSubGraph(SrcNId, DstNId, NbrV[n]);
1047      if (OpnTriadNet->GetEdges() != 2) { continue; }
1048      const int TdId = GetOpnTriadId(OpnTriadNet);
1049      IAssert(TdId < 16);
1050      CntV[TdId]++;
1051    }
1052    TIntPr& Cnt = TriadVecV.AddDat(CntV);
1053    if (Sign==+1) { Cnt.Val1 += 1; }
1054    else { Cnt.Val2 += 1; }
1055    IAssert(! Network->IsEdge(SrcNId, DstNId));
1056    Network->AddNode(SrcNId);  Network->AddNode(DstNId);
1057    Network->AddEdge(SrcNId, DstNId, Sign);
1058  }
1059  int TSignMicroEvol::IsSameOpnTriad(const PSignNet& Net1, const PSignNet& Net2) {
1060    if (Net1->GetNodes() != Net2->GetNodes() || Net1->GetEdges() != Net2->GetEdges()) {
1061      return false;
1062    }
1063    TSignNet::TEdgeI EI1 = Net1->BegEI();
1064    TSignNet::TEdgeI EI2 = Net2->BegEI();
1065    while (EI1 < Net1->EndEI()) {
1066      if (EI1.GetSrcNId() != EI2.GetSrcNId()) { return false; }
1067      if (EI1.GetDstNId() != EI2.GetDstNId()) { return false; }
1068      if (EI1() != EI2()) { return false; }
1069      EI1++;  EI2++;
1070    }
1071    return true;
1072  }
1073  int TSignMicroEvol::GetOpnTriadId(const PSignNet& Net1) {
1074    for (int i = 0; i < OpnTriadV.Len(); i++) {
1075      if (IsSameOpnTriad(OpnTriadV[i], Net1)) { return i; }
1076    }
1077    OpnTriadV.Add(Net1);
1078    return OpnTriadV.Len()-1;
1079  }
1080  bool TSignMicroEvol::IsSameTriad(const PSignNet& Net1, const PSignNet& Net2, int& PermId) const {
1081    if (Net1->GetNodes() != Net2->GetNodes() || Net1->GetEdges() != Net2->GetEdges()) {
1082      return false; }
1083    const TVec<TIntV>& PermV = PermH.GetDat(Net1->GetNodes());
1084    for (int p = 0; p < PermV.Len(); p++) {
1085      if (IsSameTriad(Net1, Net2, PermV[p])) {
1086        PermId=p; return true;
1087      }
1088    }
1089    return false;
1090  }
1091  int TSignMicroEvol::GetTriadId(const PSignNet& Net1) {
1092    int PermId;
1093    for (int i = 0; i < TriadIdV.Len(); i++) {
1094      if (IsSameTriad(TriadIdV[i], Net1, PermId)) { TriadIdV[i]=Net1; return i; }
1095    }
1096    TriadIdV.Add(Net1);
1097    TransNet->AddNode(TriadIdV.Len()-1, 0);
1098    return TriadIdV.Len()-1;
1099  }
1100  double TSignMicroEvol::GetStatusDelta(const PSignNet& Net, const int& NId1, const int& NId2) {
1101    int S1, S2;
1102    if (! Net->IsEdge(NId1, NId2)) { S1 = 0; }
1103    else if (Net->GetEDat(NId1, NId2)>0) { S1 = 1; } else { S1 = -1; }
1104    if (! Net->IsEdge(NId2, NId1)) { S2 = 0; }
1105    else if (Net->GetEDat(NId2, NId1)>0) { S2 = 1; } else { S2 = -1; }
1106    if (S1==+1 && S2==0) { return +0.2; }
1107    if (S1==-1 && S2==0) { return -0.8; }
1108    if (S1==0 && S2==+1) { return -0.2; }
1109    if (S1==0 && S2==-1) { return +0.8; }
1110    if (S1==+1 && S2==+1) { return +0.4; }
1111    if (S1==-1 && S2==-1) { return -1.6; }
1112    if (S1==+1 && S2==-1) { return +1; }
1113    if (S1==-1 && S2==+1) { return -1; }
1114    Fail;  return -1;
1115  }
1116  double TSignMicroEvol::GetStatus(const PSignNet& Net, const int& NId) {
1117    if (NId == 2) { return 0; }
1118    return GetStatusDelta(Net, 2, NId);
1119  }
1120  bool TSignMicroEvol::IsStatusFrac(const int& OpnTriadId, const bool& DstNode) const {
1121    const TCloseStat Stat = CloseTriadH.GetDat(OpnTriadId); 
1122    PSignNet SrcNet = OpnTriadV[OpnTriadId];
1123    if (DstNode) {
1124      if (GetStatus(SrcNet, 1) > 0) { if (Stat.GetPlsFrac()>0.8) { return true; } }
1125      else { if(Stat.GetPlsFrac()<0.2) { return true; } }
1126    } else {
1127      if (GetStatus(SrcNet, 1) > 0) { if (Stat.GetPlsFrac()<0.2) { return true; } }
1128      else { if(Stat.GetPlsFrac()>0.8) { return true; } }
1129    }
1130    return false;
1131  }
1132  bool TSignMicroEvol::IsStatusSurp(const int& OpnTriadId, const bool& DstNode) const {
1133    const TCloseStat Stat = CloseTriadH.GetDat(OpnTriadId); 
1134    PSignNet SrcNet = OpnTriadV[OpnTriadId];
1135    if (DstNode) {
1136      if (GetStatus(SrcNet, 1)*Stat.GetOutPlsSurp() > 0) { return true; } 
1137    } else {
1138      if (GetStatus(SrcNet, 0)*Stat.GetInPlsSurp() < 0) { return true; }
1139    }
1140    return false;
1141  }
1142  int GetUnDirEdgeSign(const PSignNet& Net, const int& NId1, const int& NId2) {
1143    int S1, S2, S;
1144    if (! Net->IsEdge(NId1, NId2)) { S1 = 0; }
1145    else if (Net->GetEDat(NId1, NId2)>0) { S1 = 1; } else { S1 = -1; }
1146    if (! Net->IsEdge(NId2, NId1)) { S2 = 0; }
1147    else if (Net->GetEDat(NId2, NId1)>0) { S2 = 1; } else { S2 = -1; }
1148    if (S1==0) { S=S2; }
1149    else if (S2==0) { S=S1; }
1150    else { S=TMath::Mx(S1,S2); }
1151    return S;
1152  }
1153  bool TSignMicroEvol::IsBalanceFrac(const int& OpnTriadId) const {
1154    const TCloseStat Stat = CloseTriadH.GetDat(OpnTriadId); 
1155    PSignNet SrcNet = OpnTriadV[OpnTriadId];
1156    const int S1 = GetUnDirEdgeSign(SrcNet, 0,2);
1157    const int S2 = GetUnDirEdgeSign(SrcNet, 1,2);
1158    const double Plus = Stat.GetPlsFrac();
1159    if (S1*S2 > 0 && Plus > 0.8) { return true; }
1160    if (S1*S2 < 0 && Plus < 0.8) { return true; }
1161    return false;
1162  }
1163  bool TSignMicroEvol::IsBalanceSurp(const int& OpnTriadId) const {
1164   const TCloseStat Stat = CloseTriadH.GetDat(OpnTriadId); 
1165    PSignNet SrcNet = OpnTriadV[OpnTriadId];
1166    const int S1 = GetUnDirEdgeSign(SrcNet, 0,2);
1167    const int S2 = GetUnDirEdgeSign(SrcNet, 1,2);
1168    const double Surp = Stat.GetOutPlsSurp();
1169    if (S1*S2 > 0 && Surp > 0) { return true; }
1170    if (S1*S2 < 0 && Surp < 0) { return true; }
1171    return false;
1172  }
1173  void TSignMicroEvol::PrintInfo() const {
1174    TSnap::PrintInfo(Network);
1175    Network->PrintInfo();
1176    THash<TIntPr, TFltPr> H = RepLinkCntH;
1177    H.SortByDat(false);
1178    printf("*** RECIPROCAL Links\n");
1179    for (int i = 0; i < H.Len(); i++) {
1180      printf(" %c is reciprocated by %c :  cnt %g  surp: %f\n",
1181        H.GetKey(i).Val1==1?'+':'-', H.GetKey(i).Val2==1?'+':'-', H[i].Val1, H[i].Val2);
1182    }
1183  }
1184  char TSignMicroEvol::GetEdgeChar(const PSignNet& Network, const int& n1, const int& n2) {
1185    if (! Network->IsEdge(n1,n2)) { return 'o'; }
1186    else if (Network->GetEDat(n1,n2)>0) { return '+'; }
1187    else { return '-'; }
1188  }
1189  void TSignMicroEvol::SaveCloseTriadTxt(const TStr& FNmPref, const bool& DrawNets, const bool& PlotHists) {
1190    printf("*** OPEN TRIADS %d\n", OpnTriadV.Len());
1191    TVec<TTriple<TInt, TStr, TInt> > OpnIdV;
1192    for (int n = 0; n < OpnTriadV.Len(); n++) {
1193      PSignNet SrcNet = OpnTriadV[n];
1194      OpnIdV.Add(TTriple<TInt, TStr, TInt>(SrcNet->GetEdges(), TStr::Fmt("%c%c%c%c", GetEdgeChar(SrcNet, 0,2), GetEdgeChar(SrcNet, 2,0), GetEdgeChar(SrcNet, 2,1), GetEdgeChar(SrcNet, 1,2)), n));
1195    }
1196    OpnIdV.Sort();
1197    FILE* F = fopen(TStr::Fmt("%s-diad.tab", FNmPref.CStr()).CStr(), "wt");
1198    fprintf(F, "AB\tBC\tAC+\tAC-\tPctAC+\tOUT-Surprise\tIN-Surprise\tDst-StsFrac\tDst-StsSurp\tSrc-StsFrac\tSrc-StsSurp\tBalFrac\tBalSurp\n");
1199    for (int n = 0; n < OpnIdV.Len(); n++) {
1200      const int Id = OpnIdV[n].Val3;
1201      PSignNet SrcNet = OpnTriadV[Id];
1202      const TCloseStat Stat = CloseTriadH.GetDat(Id); 
1203      fprintf(F, "%c%c\t%c%c", GetEdgeChar(SrcNet, 0,2), GetEdgeChar(SrcNet, 2,0), GetEdgeChar(SrcNet, 2,1), GetEdgeChar(SrcNet, 1,2));
1204      fprintf(F, "\t%d\t%d\t%.4f\t%.4f\t%.4f\t%s\t%s\t%s\t%s\t%s\t%s\n", Stat.PlsCnt, Stat.MnsCnt, Stat.GetPlsFrac(), Stat.GetOutPlsSurp(), Stat.GetInPlsSurp(),
1205        IsStatusFrac(Id,true)?"1":"0", IsStatusSurp(Id,true)?"1":"0", IsStatusFrac(Id,false)?"1":"0", IsStatusSurp(Id,false)?"1":"0",
1206        IsBalanceFrac(Id)?"1":"0", IsBalanceSurp(Id)?"1":"0");
1207    }
1208    fclose(F);
1209    if (DrawNets) {
1210      for (int i = 0; i < 16; i++) {
1211        const int Id = OpnIdV[i].Val3;
1212        TStr Label = TStr::Fmt("dst-status: p+:%s  s+:%s\\nsrc-status: p+:%s  s+:%s\\nbalance: p+:%s s+:%s",
1213          IsStatusFrac(Id,true)?"Y":"N", IsStatusSurp(Id,true)?"Y":"N",
1214          IsStatusFrac(Id,false)?"Y":"N", IsStatusSurp(Id,false)?"Y":"N",
1215          IsBalanceFrac(Id)?"Y":"N", IsBalanceSurp(Id)?"Y":"N");
1216        DrawCloseTriad(TStr::Fmt("%s_%02d", FNmPref.CStr(), i), Id, Label);
1217      }
1218    }
1219    if (PlotHists) {
1220      for (int i = 0; i < 16; i++) {
1221        const int Id = OpnIdV[i].Val3;
1222        CloseTriadH.GetDat(Id).SaveHist(TStr::Fmt("%s_%02d", FNmPref.CStr(), i));
1223      }
1224    }
1225    printf("done.\n");
1226  }
1227  void TSignMicroEvol::DrawCloseTriad(const TStr& FNmPref, const int& OpnTriadId, const TStr& Label) {
1228    PSignNet Network = OpnTriadV[OpnTriadId];
1229    TStr FNm = TStr::Fmt("%s-OpnTriad.dot", FNmPref.CStr());
1230    FILE *F = fopen(FNm.CStr(), "wt");
1231    fprintf(F, "  digraph G {\n");
1232    fprintf(F, "    graph [splines=true, overlap=false];\n");
1233    fprintf(F, "    node  [shape=ellipse, width=0.3, height=0.3];\n");
1234    fprintf(F, "    edge  [len=4];\n");
1235    for (TSignNet::TNodeI NI = Network->BegNI(); NI < Network->EndNI(); NI++) {
1236      fprintf(F, "    node%d [label=\"%g\"];\n", NI.GetId(), GetStatus(Network, NI.GetId())); }
1237    for (TSignNet::TEdgeI EI = Network->BegEI(); EI < Network->EndEI(); EI++) {
1238      fprintf(F, "    node%d -> node%d [label=\"%s\"];\n",
1239        EI.GetSrcNId(), EI.GetDstNId(), EI()==1?"+":"--"); }
1240    const TCloseStat Stat = CloseTriadH.GetDat(OpnTriadId);
1241    fprintf(F, "    node0 -> node1 [label=\"+:%d -:%d\\np+:%.3f  so: %.1f  si: %.1f\", color=\"red\"];\n",
1242      Stat.PlsCnt(), Stat.MnsCnt(), Stat.GetPlsFrac(), Stat.GetOutPlsSurp(), Stat.GetInPlsSurp());
1243    if (! Label.Empty()) { fprintf(F, "label = \"%s\";\n", Label.CStr()); }
1244    fprintf(F, "}\n");
1245    fclose(F);
1246    TSnap::TSnapDetail::GVizDoLayout(FNm, FNm.GetFMid()+".gif", gvlNeato);
1247  }
1248  bool IsBalancedSwapEdge(const PSignNet& Net, const TIntPr& BackEdge, const int& Sign) {
1249    const int s1 = Net->GetEDat(BackEdge.Val2, BackEdge.Val1);
1250    const int s2 = Net->GetEDat(BackEdge.Val1, BackEdge.Val2);
1251    Net->DelEdge(BackEdge.Val2, BackEdge.Val1);
1252    Net->GetEDat(BackEdge.Val1, BackEdge.Val2) = Sign;
1253    const bool IsBal = Net->IsBalanced();
1254    Net->AddEdge(BackEdge.Val2, BackEdge.Val1, s1);
1255    Net->GetEDat(BackEdge.Val1, BackEdge.Val2) = s2;
1256    return IsBal;
1257  }
1258  void TSignMicroEvol::SaveTriad3to4Edges(const TStr& FNmPref) {
1259    TVec<TPair<TIntTr, TInt> > SigTIdV;
1260    for (int t = 0; t < Triad3to4H.Len(); t++) {
1261      SigTIdV.Add(TPair<TIntTr, TInt>(TriadIdV[Triad3to4H.GetKey(t).Val1]->GetTriadSig(), t));
1262    }
1263    SigTIdV.Sort();
1264    FILE *F = fopen(TStr::Fmt("tr3to4-%s2.tab", FNmPref.CStr()).CStr(), "wt");
1265    fprintf(F, "Balanced\tSrcTriad\t\t\t\tDstTriad\t\t\tPlus-BAL\tMns-BAL\tPlusCnt\tPlusFrac\tOUT-Supr\tIN-Surp\tBal-Frac\tBal-OutSurp\tBal-InSurp\n");
1266    for (int t = 0; t < SigTIdV.Len(); t++) {
1267      const int SrcTId = Triad3to4H.GetKey(SigTIdV[t].Val2).Val1;
1268      const int DstTId = Triad3to4H.GetKey(SigTIdV[t].Val2).Val2;
1269      const TCloseStat& Stat = Triad3to4H[SigTIdV[t].Val2];
1270      TIntTr SrcSig = TriadIdV[SrcTId]->GetTriadSig();
1271      TIntTr DstSig = TriadIdV[DstTId]->GetTriadSig();
1272      TIntPr NewEdge = TriadIdV[DstTId]->GetNewEdge(TriadIdV[SrcTId]);
1273      const bool SrcBal = TriadIdV[SrcTId]->IsBalanced();
1274      const bool DstPlsBal = IsBalancedSwapEdge(TriadIdV[DstTId], NewEdge, 1);
1275      const bool DstMnsBal = IsBalancedSwapEdge(TriadIdV[DstTId], NewEdge, -1);
1276      IAssert(int(DstPlsBal)+int(DstMnsBal)==1);
1277      fprintf(F, "%d\t%s\t->\t%s\t%d\t%d\t%d\t%.3f\t%.3f\t%.3f",
1278        SrcBal?1:0, TSignNet::GetTriadStr(SrcSig).CStr(),
1279        TSignNet::GetTriadStr(DstSig).CStr(), DstPlsBal?1:0, DstMnsBal?1:0,
1280        Stat.PlsCnt, Stat.GetPlsFrac(), Stat.GetOutPlsSurp(), Stat.GetInPlsSurp());
1281      const bool IsPlusBal = (DstPlsBal && Stat.GetPlsFrac()>0.8) || (! DstPlsBal && Stat.GetPlsFrac()<0.8);
1282      const bool IsOutSur = (DstPlsBal && Stat.GetOutPlsSurp()>2) || (! DstPlsBal && Stat.GetOutPlsSurp()<-2);
1283      const bool IsInSur = (DstPlsBal && Stat.GetInPlsSurp()>2) || (! DstPlsBal && Stat.GetInPlsSurp()<-2);
1284      fprintf(F, "\t%d\t%d\t%d\n", IsPlusBal?1:0, IsOutSur?1:0, IsInSur?1:0);
1285    }
1286    fclose(F);
1287  }
1288  void TSignMicroEvol::SaveTriadCloseVec(const TStr& FNmPref) {
1289    IAssert(OpnTriadV.Len() == 16);
1290    TVec<TTriple<TInt, TStr, TInt> > OpnIdV;
1291    for (int n = 0; n < OpnTriadV.Len(); n++) {
1292      PSignNet SrcNet = OpnTriadV[n];
1293      OpnIdV.Add(TTriple<TInt, TStr, TInt>(SrcNet->GetEdges(), TStr::Fmt("%c%c%c%c", GetEdgeChar(SrcNet, 0,2), GetEdgeChar(SrcNet, 2,0), GetEdgeChar(SrcNet, 2,1), GetEdgeChar(SrcNet, 1,2)), n));
1294    }
1295    OpnIdV.Sort();
1296    TriadVecV.SortByKey(false);
1297    FILE *F = fopen(TStr::Fmt("trVec2-%s.tab", FNmPref.CStr()).CStr(), "wt");
1298    for (int i = 0; i < OpnIdV.Len(); i++) { fprintf(F, "%s\t", OpnIdV[i].Val2.CStr()); }
1299    fprintf(F, "PlsCnt\tMnsCnt\n");
1300    printf("%d vectors\n", TriadVecV.Len());
1301    for (int v = 0; v < TMath::Mn(1000, TriadVecV.Len()); v++) {
1302      const TTuple<TInt, 16>& V = TriadVecV.GetKey(v);
1303      for (int i = 0; i < V.Len(); i++) {
1304        fprintf(F, "%d\t", V[OpnIdV[i].Val3]);
1305      }
1306      fprintf(F, "%d\t%d\n", TriadVecV[v].Val1, TriadVecV[v].Val2);
1307    }
1308    fclose(F);
1309  }
1310  void TSignMicroEvol::EpinionsTriadEvolution(const bool& OnlySimpleTriads) {
1311    TSsParser Ss("W:\\Data\\Epinions\\user_rating.txt", ssfTabSep);
1312    TVec<TIntQu> EdgeV;
1313    for (int c = 0; Ss.Next(); c++) {
1314      TChA ChA(Ss[3]);
1315      TVec<char*> V;  TStrUtil::SplitOnCh(ChA, V, '/');
1316      TSecTm Tm(atoi(V[0]), atoi(V[1]), atoi(V[2]));
1317      EdgeV.Add(TIntQu(Tm.GetAbsSecs(), Ss.GetInt(0), Ss.GetInt(1), Ss.GetInt(2))); 
1318    }
1319    EdgeV.Sort();
1320    PSignNet Net = TSignNet::New();
1321    int e = 0;
1322    const TSecTm BegTm(2001, 01, 10);
1323    for (; e < EdgeV.Len() && (uint)EdgeV[e].Val1 <= BegTm.GetAbsSecs(); e++) {
1324      if (OnlySimpleTriads &&  Net->IsEdge(EdgeV[e].Val3, EdgeV[e].Val2)) { continue; }
1325      Net->AddNode(EdgeV[e].Val2);  Net->AddNode(EdgeV[e].Val3);
1326      Net->AddEdge(EdgeV[e].Val2, EdgeV[e].Val3, EdgeV[e].Val4);
1327    }
1328    TSnap::PrintInfo(Net);
1329    TSignMicroEvol SME(Net);
1330    TIntFltH OutPlusProbH, InPlusProbH;
1331    { THash<TInt, TIntPr> PlsMnsCnt1, PlsMnsCnt2;
1332    for (int e1=0; e1 < EdgeV.Len(); e1++) {
1333      if (EdgeV[e1].Val4==1) { PlsMnsCnt1.AddDat(EdgeV[e1].Val2).Val1++; } 
1334      else { PlsMnsCnt1.AddDat(EdgeV[e1].Val2).Val2++; }
1335      if (EdgeV[e1].Val4==1) { PlsMnsCnt2.AddDat(EdgeV[e1].Val3).Val1++; } 
1336      else { PlsMnsCnt2.AddDat(EdgeV[e1].Val3).Val2++; }
1337    }
1338    for (int u = 0; u < PlsMnsCnt1.Len(); u++) {
1339      OutPlusProbH.AddDat(PlsMnsCnt1.GetKey(u), PlsMnsCnt1[u].Val1/double(PlsMnsCnt1[u].Val1+PlsMnsCnt1[u].Val2)); }
1340    for (int u = 0; u < PlsMnsCnt2.Len(); u++) {
1341      InPlusProbH.AddDat(PlsMnsCnt2.GetKey(u), PlsMnsCnt2[u].Val1/double(PlsMnsCnt2[u].Val1+PlsMnsCnt2[u].Val2));
1342    } } /&bsol;*/
1343    printf("*** skip fist %d edges\n", e);
1344    int Plus=0, Minus=0, SkipEdges=e;
1345    const TStr OutFNm = TStr::Fmt("epin851-%s", OnlySimpleTriads?"SmpTr":"AllTr");
1346    for (; e < EdgeV.Len(); e++) {
1347      const int n1 = EdgeV[e].Val2;
1348      const int n2 = EdgeV[e].Val3;
1349      const int Sign = EdgeV[e].Val4;
1350      if (n1 == n2 || Net->IsEdge(n1,n2))  { continue; }
1351      if (Sign==1) { Plus++; } else { Minus++; }
1352      const double SrcOutPlusProb = OutPlusProbH.GetDat(n1);  
1353      const double DstInPlusProb = InPlusProbH.GetDat(n2);    
1354      SME.CountTriad3to4Edges(n1, n2, Sign, SrcOutPlusProb, DstInPlusProb);
1355      if ((e+1) % 1000 == 0) { printf("."); }
1356    }
1357    printf("\n\n*** %s\n", OutFNm.CStr());
1358    printf("In %d good edges %d plus %d minus.\n", EdgeV.Len()-SkipEdges, Plus, Minus);
1359    SME.PrintInfo();
1360    SME.SaveTriad3to4Edges(OutFNm);            
1361  }
1362  void GetKeyPrV(const THash<TIntPr, TInt>& H, const int& MinCnt, TFltPrV& V) {
1363    V.Clr(false);
1364    for (int i = 0; i < H.Len(); i++) {
1365      if (H[i] >= MinCnt) {
1366        V.Add(TFltPr(H.GetKey(i).Val1+TInt::Rnd.GetUniDev()+1.0,
1367          H.GetKey(i).Val2+TInt::Rnd.GetUniDev()+1.0));
1368      }
1369    }
1370  }
1371  void TSignMicroEvol::EpinionsStat() {
1372    TSsParser Ss("W:\\Data\\Epinions\\user_rating.txt", ssfTabSep);
1373    TVec<TIntQu> EdgeV;
1374    for (int c = 0; Ss.Next(); c++) {
1375      TChA ChA(Ss[3]);
1376      TVec<char*> V;  TStrUtil::SplitOnCh(ChA, V, '/');
1377      TSecTm Tm(atoi(V[0]), atoi(V[1]), atoi(V[2]));
1378      EdgeV.Add(TIntQu(Tm.GetAbsSecs(), Ss.GetInt(0), Ss.GetInt(1), Ss.GetInt(2))); 
1379    }
1380    THash<TInt, TIntQu> NIdPmOutInH;
1381    for (int e = 0; e < EdgeV.Len(); e++) {
1382      TIntQu& Src = NIdPmOutInH.AddDat(EdgeV[e].Val2);
1383      TIntQu& Dst = NIdPmOutInH.AddDat(EdgeV[e].Val3);
1384      if (EdgeV[e].Val4 == 1) {
1385        Src.Val1++; Dst.Val3++; 
1386      } else {
1387        Src.Val2++; Dst.Val4++; 
1388      }
1389    }
1390    TFltPrV PiPo, PiMi, PiMo, PoMi, PoMo, MiMo;
1391    THash<TIntPr, TInt> PiPoH, PiMiH, PiMoH, PoMiH, PoMoH, MiMoH;
1392    for (int i = 0; i < NIdPmOutInH.Len(); i++) {
1393      TIntQu PMOI = NIdPmOutInH[i];
1394      PiPo.Add(TFltPr(PMOI.Val3+TInt::Rnd.GetUniDev()+1.0, PMOI.Val1+TInt::Rnd.GetUniDev()+1.0));
1395      PiMi.Add(TFltPr(PMOI.Val3+TInt::Rnd.GetUniDev()+1.0, PMOI.Val4+TInt::Rnd.GetUniDev()+1.0));
1396      PiMo.Add(TFltPr(PMOI.Val3+TInt::Rnd.GetUniDev()+1.0, PMOI.Val2+TInt::Rnd.GetUniDev()+1.0));
1397      PoMi.Add(TFltPr(PMOI.Val1+TInt::Rnd.GetUniDev()+1.0, PMOI.Val4+TInt::Rnd.GetUniDev()+1.0));
1398      PoMo.Add(TFltPr(PMOI.Val1+TInt::Rnd.GetUniDev()+1.0, PMOI.Val2+TInt::Rnd.GetUniDev()+1.0));
1399      MiMo.Add(TFltPr(PMOI.Val4+TInt::Rnd.GetUniDev()+1.0, PMOI.Val2+TInt::Rnd.GetUniDev()+1.0));/&bsol;*/
1400      PiPoH.AddDat(TIntPr(PMOI.Val3, PMOI.Val1)) += 1;
1401      PiMiH.AddDat(TIntPr(PMOI.Val3, PMOI.Val4)) += 1;
1402      PiMoH.AddDat(TIntPr(PMOI.Val3, PMOI.Val2)) += 1;
1403      PoMiH.AddDat(TIntPr(PMOI.Val1, PMOI.Val4)) += 1;
1404      PoMoH.AddDat(TIntPr(PMOI.Val1, PMOI.Val2)) += 1;
1405      MiMoH.AddDat(TIntPr(PMOI.Val4, PMOI.Val2)) += 1;
1406    }
1407    TStr OutFNm = "EpinAll";
1408    TGnuPlot::PlotValV(PiPo, "pipo-"+OutFNm, OutFNm, "Number of + IN", "Number of + OUT", gpsLog, false, gpwPoints);
1409    TGnuPlot::PlotValV(PiMi, "pimi-"+OutFNm, OutFNm, "Number of + IN", "Number of - IN", gpsLog, false, gpwPoints);
1410    TGnuPlot::PlotValV(PiMo, "pimo-"+OutFNm, OutFNm, "Number of + IN", "Number of - OUT", gpsLog, false, gpwPoints);
1411    TGnuPlot::PlotValV(PoMi, "pomi-"+OutFNm, OutFNm, "Number of + OUT", "Number of - IN", gpsLog, false, gpwPoints);
1412    TGnuPlot::PlotValV(PoMo, "pomo-"+OutFNm, OutFNm, "Number of + OUT", "Number of - OUT", gpsLog, false, gpwPoints);
1413    TGnuPlot::PlotValV(MiMo, "mimo-"+OutFNm, OutFNm, "Number of - IN", "Number of - OUT", gpsLog, false, gpwPoints);
1414  }
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-preferenceDlg.cpp</h3>
            <pre><code>1  #include <shlwapi.h>
2  #include "preferenceDlg.h"
3  #include "lesDlgs.h"
4  #include "EncodingMapper.h"
5  #include "localization.h"
6  #define MyGetGValue(rgb)      (LOBYTE((rgb)>>8))
7  using namespace std;
8  const int BLINKRATE_FASTEST = 50;
9  const int BLINKRATE_SLOWEST = 2500;
10  const int BLINKRATE_INTERVAL = 50;
11  const int CARETLINEFRAME_SMALLEST = 1;
12  const int CARETLINEFRAME_LARGEST = 6;
13  const int CARETLINEFRAME_INTERVAL = 1;
14  const int BORDERWIDTH_SMALLEST = 0;
15  const int BORDERWIDTH_LARGEST = 30;
16  const int BORDERWIDTH_INTERVAL = 1;
17  const int PADDING_SMALLEST = 0;
18  const int PADDING_LARGEST = 30;
19  const int PADDING_INTERVAL = 1;
20  const int DISTRACTIONFREE_SMALLEST = 3;
21  const int DISTRACTIONFREE_LARGEST = 9;
22  const int DISTRACTIONFREE_INTERVAL = 1;
23  constexpr int AUTOCOMPLETEFROMCHAR_SMALLEST = 1;
24  constexpr int AUTOCOMPLETEFROMCHAR_LARGEST = 9;
25  constexpr int AUTOCOMPLETEFROMCHAR_INTERVAL = 1;
26  static int encodings[] = {
27  	1250, 
28  	1251, 
29  	1252, 
30  	1253, 
31  	1254, 
32  	1255, 
33  	1256, 
34  	1257, 
35  	1258, 
36  	28591,
37  	28592,
38  	28593,
39  	28594,
40  	28595,
41  	28596,
42  	28597,
43  	28598,
44  	28599,
45  	28603,
46  	28604,
47  	28605,
48  	437,  
49  	720,  
50  	737,  
51  	775,  
52  	850,  
53  	852,  
54  	855,  
55  	857,  
56  	858,  
57  	860,  
58  	861,  
59  	862,  
60  	863,  
61  	865,  
62  	866,  
63  	869,  
64  	950,  
65  	936,  
66  	932,  
67  	949,  
68  	51949,
69  	874,
70  	10007,
71  	21866,
72  	20866
73  };
74  bool PreferenceDlg::goToSection(size_t iPage, intptr_t ctrlID)
75  {
76  	::SendDlgItemMessage(_hSelf, IDC_LIST_DLGTITLE, LB_SETCURSEL, iPage, 0);
77  	showDialogByIndex(iPage);
78  	getFocus();
79  	if (ctrlID != -1)
80  	{
81  		::SetFocus(::GetDlgItem(_wVector[iPage]._dlg->getHSelf(), int(ctrlID)));
82  	}
83  	return true;
84  }
85  intptr_t CALLBACK PreferenceDlg::run_dlgProc(UINT message, WPARAM wParam, LPARAM lParam)
86  {
87  	switch (message) 
88  	{
89  		case WM_INITDIALOG :
90  		{
91  			_generalSubDlg.init(_hInst, _hSelf);
92  			_generalSubDlg.create(IDD_PREFERENCE_SUB_GENRAL, false, false);
93  			_generalSubDlg.display();
94  			_editingSubDlg.init(_hInst, _hSelf);
95  			_editingSubDlg.create(IDD_PREFERENCE_SUB_EDITING, false, false);
96  			_darkModeSubDlg.init(_hInst, _hSelf);
97  			_darkModeSubDlg.create(IDD_PREFERENCE_SUB_DARKMODE, false, false);
98  			_marginsBorderEdgeSubDlg.init(_hInst, _hSelf);
99  			_marginsBorderEdgeSubDlg.create(IDD_PREFERENCE_SUB_MARGING_BORDER_EDGE, false, false);
100  			_miscSubDlg.init(_hInst, _hSelf);
101  			_miscSubDlg.create(IDD_PREFERENCE_SUB_MISC, false, false);
102  			_newDocumentSubDlg.init(_hInst, _hSelf);
103  			_newDocumentSubDlg.create(IDD_PREFERENCE_SUB_NEWDOCUMENT, false, false);
104  			_defaultDirectorySubDlg.init(_hInst, _hSelf);
105  			_defaultDirectorySubDlg.create(IDD_PREFERENCE_SUB_DEFAULTDIRECTORY, false, false);
106  			_recentFilesHistorySubDlg.init(_hInst, _hSelf);
107  			_recentFilesHistorySubDlg.create(IDD_PREFERENCE_SUB_RECENTFILESHISTORY, false, false);
108  			_fileAssocDlg.init(_hInst, _hSelf);
109  			_fileAssocDlg.create(IDD_REGEXT_BOX, false, false);
110  			_printSubDlg.init(_hInst, _hSelf);
111  			_printSubDlg.create(IDD_PREFERENCE_SUB_PRINT, false, false);
112  			_searchingSubDlg.init(_hInst, _hSelf);
113  			_searchingSubDlg.create(IDD_PREFERENCE_SUB_SEARCHING, false, false);
114  			_languageSubDlg.init(_hInst, _hSelf);
115  			_languageSubDlg.create(IDD_PREFERENCE_SUB_LANGUAGE, false, false);
116  			_highlightingSubDlg.init(_hInst, _hSelf);
117  			_highlightingSubDlg.create(IDD_PREFERENCE_SUB_HIGHLIGHTING, false, false);
118  			_backupSubDlg.init(_hInst, _hSelf);
119  			_backupSubDlg.create(IDD_PREFERENCE_SUB_BACKUP, false, false);
120  			_autoCompletionSubDlg.init(_hInst, _hSelf);
121  			_autoCompletionSubDlg.create(IDD_PREFERENCE_SUB_AUTOCOMPLETION, false, false);
122  			_multiInstanceSubDlg.init(_hInst, _hSelf);
123  			_multiInstanceSubDlg.create(IDD_PREFERENCE_SUB_MULTIINSTANCE, false, false);
124  			_delimiterSubDlg.init(_hInst, _hSelf);
125  			_delimiterSubDlg.create(IDD_PREFERENCE_SUB_DELIMITER, false, false);
126  			_performanceSubDlg.init(_hInst, _hSelf);
127  			_performanceSubDlg.create(IDD_PREFERENCE_SUB_PERFORMANCE, false, false);
128  			_cloudAndLinkSubDlg.init(_hInst, _hSelf);
129  			_cloudAndLinkSubDlg.create(IDD_PREFERENCE_SUB_CLOUD_LINK, false, false);
130  			_searchEngineSubDlg.init(_hInst, _hSelf);
131  			_searchEngineSubDlg.create(IDD_PREFERENCE_SUB_SEARCHENGINE, false, false);			
132  			_wVector.push_back(DlgInfo(&_generalSubDlg, TEXT("General"), TEXT("Global")));
133  			_wVector.push_back(DlgInfo(&_editingSubDlg, TEXT("Editing"), TEXT("Scintillas")));
134  			_wVector.push_back(DlgInfo(&_darkModeSubDlg, TEXT("Dark Mode"), TEXT("DarkMode")));
135  			_wVector.push_back(DlgInfo(&_marginsBorderEdgeSubDlg, TEXT("Margins/Border/Edge"), TEXT("MarginsBorderEdge")));
136  			_wVector.push_back(DlgInfo(&_newDocumentSubDlg, TEXT("New Document"), TEXT("NewDoc")));
137  			_wVector.push_back(DlgInfo(&_defaultDirectorySubDlg, TEXT("Default Directory"), TEXT("DefaultDir")));
138  			_wVector.push_back(DlgInfo(&_recentFilesHistorySubDlg, TEXT("Recent Files History"), TEXT("RecentFilesHistory")));
139  			_wVector.push_back(DlgInfo(&_fileAssocDlg, TEXT("File Association"), TEXT("FileAssoc")));
140  			_wVector.push_back(DlgInfo(&_languageSubDlg, TEXT("Language"), TEXT("Language")));
141  			_wVector.push_back(DlgInfo(&_highlightingSubDlg, TEXT("Highlighting"), TEXT("Highlighting")));
142  			_wVector.push_back(DlgInfo(&_printSubDlg, TEXT("Print"), TEXT("Print")));
143  			_wVector.push_back(DlgInfo(&_searchingSubDlg, TEXT("Searching"), TEXT("Searching")));
144  			_wVector.push_back(DlgInfo(&_backupSubDlg, TEXT("Backup"), TEXT("Backup")));
145  			_wVector.push_back(DlgInfo(&_autoCompletionSubDlg, TEXT("Auto-Completion"), TEXT("AutoCompletion")));
146  			_wVector.push_back(DlgInfo(&_multiInstanceSubDlg, TEXT("Multi-Instance & Date"), TEXT("MultiInstance")));
147  			_wVector.push_back(DlgInfo(&_delimiterSubDlg, TEXT("Delimiter"), TEXT("Delimiter")));
148  			_wVector.push_back(DlgInfo(&_performanceSubDlg, TEXT("Performance"), TEXT("Performance")));
149  			_wVector.push_back(DlgInfo(&_cloudAndLinkSubDlg, TEXT("Cloud & Link"), TEXT("Cloud")));
150  			_wVector.push_back(DlgInfo(&_searchEngineSubDlg, TEXT("Search Engine"), TEXT("SearchEngine")));
151  			_wVector.push_back(DlgInfo(&_miscSubDlg, TEXT("MISC."), TEXT("MISC")));
152  			makeCategoryList();
153  			NppDarkMode::autoSubclassAndThemeChildControls(_hSelf);
154  			return TRUE;
155  		}
156  		case WM_CTLCOLORLISTBOX:
157  		{
158  			return NppDarkMode::onCtlColorListbox(wParam, lParam);
159  		}
160  		case WM_CTLCOLORDLG:
161  		case WM_CTLCOLORSTATIC:
162  		{
163  			return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
164  		}
165  		case WM_PRINTCLIENT:
166  		{
167  			if (NppDarkMode::isEnabled())
168  			{
169  				return TRUE;
170  			}
171  			break;
172  		}
173  		case NPPM_INTERNAL_REFRESHDARKMODE:
174  		{
175  			NppDarkMode::autoThemeChildControls(_hSelf);
176  			if (_editingSubDlg._tip != nullptr)
177  				NppDarkMode::setDarkTooltips(_editingSubDlg._tip, NppDarkMode::ToolTipsType::tooltip);
178  			for (auto& tip : _editingSubDlg._tips)
179  			{
180  				if (tip != nullptr)
181  				{
182  					NppDarkMode::setDarkTooltips(tip, NppDarkMode::ToolTipsType::tooltip);
183  				}
184  			}
185  			if (_delimiterSubDlg._tip != nullptr)
186  				NppDarkMode::setDarkTooltips(_delimiterSubDlg._tip, NppDarkMode::ToolTipsType::tooltip);
187  			if (_performanceSubDlg._largeFileRestrictionTip != nullptr)
188  				NppDarkMode::setDarkTooltips(_performanceSubDlg._largeFileRestrictionTip, NppDarkMode::ToolTipsType::tooltip);
189  			if (NppDarkMode::isEnabled())
190  			{
191  				const NppGUI& nppGUI = NppParameters::getInstance().getNppGUI();
192  				::EnableWindow(::GetDlgItem(_highlightingSubDlg.getHSelf(), IDC_SMARTHILITEMATCHING_STATIC), nppGUI._enableSmartHilite);
193  				const bool noBackup = _backupSubDlg.isCheckedOrNot(IDC_RADIO_BKNONE);
194  				::EnableWindow(::GetDlgItem(_backupSubDlg.getHSelf(), IDC_BACKUPDIR_USERCUSTOMDIR_GRPSTATIC), !noBackup);
195  				const bool isEnableAutoC = _autoCompletionSubDlg.isCheckedOrNot(IDD_AUTOC_ENABLECHECK);
196  				::EnableWindow(::GetDlgItem(_autoCompletionSubDlg.getHSelf(), IDD_AUTOC_USEKEY_GRP_STATIC), isEnableAutoC);
197  			}
198  			return TRUE;
199  		}
200  		case PREF_MSG_SETGUITOOLICONSSET:
201  		{
202  			const HWND generalSubDlg = _generalSubDlg.getHSelf();
203  			auto checkOrUncheckBtn = [&generalSubDlg](int id, WPARAM check = BST_UNCHECKED) -> void
204  			{
205  				::SendDlgItemMessage(generalSubDlg, id, BM_SETCHECK, check, 0);
206  			};
207  			const int iconState = NppDarkMode::getToolBarIconSet(static_cast<bool>(wParam));
208  			NppParameters& nppParams = NppParameters::getInstance();
209  			NppGUI& nppGUI = nppParams.getNppGUI();
210  			if (iconState != -1)
211  			{
212  				nppGUI._toolBarStatus = static_cast<toolBarStatusType>(iconState);
213  			}
214  			else
215  			{
216  				auto state = TB_STANDARD;
217  				if (_generalSubDlg.isCheckedOrNot(IDC_RADIO_SMALLICON))
218  				{
219  					state = TB_SMALL;
220  				}
221  				else if (_generalSubDlg.isCheckedOrNot(IDC_RADIO_BIGICON))
222  				{
223  					state = TB_LARGE;
224  				}
225  				else if (_generalSubDlg.isCheckedOrNot(IDC_RADIO_SMALLICON2))
226  				{
227  					state = TB_SMALL2;
228  				}
229  				else if (_generalSubDlg.isCheckedOrNot(IDC_RADIO_BIGICON2))
230  				{
231  					state = TB_LARGE2;
232  				}
233  				nppGUI._toolBarStatus = state;
234  			}
235  			checkOrUncheckBtn(IDC_RADIO_STANDARD);
236  			checkOrUncheckBtn(IDC_RADIO_SMALLICON);
237  			checkOrUncheckBtn(IDC_RADIO_BIGICON);
238  			checkOrUncheckBtn(IDC_RADIO_SMALLICON2);
239  			checkOrUncheckBtn(IDC_RADIO_BIGICON2);
240  			switch (nppGUI._toolBarStatus)
241  			{
242  				case TB_LARGE:
243  				{
244  					checkOrUncheckBtn(IDC_RADIO_BIGICON, BST_CHECKED);
245  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_TOOLBAR_ENLARGE, 0);
246  					break;
247  				}
248  				case TB_SMALL2:
249  				{
250  					checkOrUncheckBtn(IDC_RADIO_SMALLICON2, BST_CHECKED);
251  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_TOOLBAR_REDUCE_SET2, 0);
252  					break;
253  				}
254  				case TB_LARGE2:
255  				{
256  					checkOrUncheckBtn(IDC_RADIO_BIGICON2, BST_CHECKED);
257  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_TOOLBAR_ENLARGE_SET2, 0);
258  					break;
259  				}
260  				case TB_STANDARD:
261  				{
262  					checkOrUncheckBtn(IDC_RADIO_STANDARD, BST_CHECKED);
263  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_TOOLBAR_STANDARD, 0);
264  					break;
265  				}
266  				default:
267  				{
268  					checkOrUncheckBtn(IDC_RADIO_SMALLICON, BST_CHECKED);
269  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_TOOLBAR_REDUCE, 0);
270  				}
271  			}
272  			return TRUE;
273  		}
274  		case PREF_MSG_SETGUITABBARICONS:
275  		{
276  			const int tabIconSet = NppDarkMode::getTabIconSet(static_cast<bool>(wParam));
277  			if (tabIconSet != -1)
278  			{
279  				_generalSubDlg.setTabbarAlternateIcons(tabIconSet == 1);
280  			}
281  			return TRUE;
282  		}
283  		case WM_COMMAND :
284  		{
285  			if (LOWORD(wParam) == IDC_LIST_DLGTITLE)
286  			{
287  				if (HIWORD(wParam) == CBN_SELCHANGE)
288  				{
289  					auto i = ::SendDlgItemMessage(_hSelf, IDC_LIST_DLGTITLE, LB_GETCURSEL, 0, 0);
290  					if (i != LB_ERR)
291  					{
292  						showDialogByIndex(i);
293  					}
294  				}
295  			}
296  			else 
297  			{
298  				switch (wParam)
299  				{
300  					case IDC_BUTTON_CLOSE :
301  					case IDCANCEL :
302  						display(false);
303  						return TRUE;
304  					default :
305  						::SendMessage(_hParent, WM_COMMAND, wParam, lParam);
306  						return TRUE;
307  				}
308  			}
309  		}
310  	}
311  	return FALSE;
312  }
313  void PreferenceDlg::makeCategoryList()
314  {
315  	for (size_t i = 0, len = _wVector.size(); i < len; ++i)
316  	{
317  		::SendDlgItemMessage(_hSelf, IDC_LIST_DLGTITLE, LB_ADDSTRING, 0, reinterpret_cast<LPARAM>(_wVector[i]._name.c_str()));
318  	}
319  	setListSelection(0);
320  }
321  int32_t PreferenceDlg::getIndexFromName(const TCHAR *name) const
322  {
323  	if (!name)
324  		return -1;
325  	int32_t i = 0;
326  	for (auto it = _wVector.begin() ; it != _wVector.end(); ++it, ++i)
327  	{
328  		if (it->_internalName == name)
329  			return i;
330  	}
331  	return -1;
332  }
333  bool PreferenceDlg::setListSelection(size_t currentSel) const
334  {
335  	const size_t selStrLenMax = 255;
336  	TCHAR selStr[selStrLenMax + 1] = { '\0' };
337  	auto lbTextLen = ::SendMessage(_hSelf, LB_GETTEXTLEN, currentSel, 0);
338  	if (static_cast<size_t>(lbTextLen) > selStrLenMax)
339  		return false;
340  	::SendDlgItemMessage(_hSelf, IDC_LIST_DLGTITLE, LB_GETTEXT, currentSel, reinterpret_cast<LPARAM>(selStr));
341  	::SendDlgItemMessage(_hSelf, IDC_LIST_DLGTITLE, LB_SELECTSTRING, currentSel, reinterpret_cast<LPARAM>(selStr));
342  	return true;
343  }
344  bool PreferenceDlg::renameDialogTitle(const TCHAR *internalName, const TCHAR *newName)
345  {
346  	bool foundIt = false;
347  	size_t i = 0;
348  	for (size_t len = _wVector.size(); i < len; ++i)
349  	{
350  		if (_wVector[i]._internalName == internalName)
351  		{
352  			foundIt = true;
353  			break;
354  		}
355  	}
356  	if (!foundIt)
357  		return false;
358  	const size_t lenMax = 256;
359  	TCHAR oldName[lenMax] = { '\0' };
360  	size_t txtLen = ::SendDlgItemMessage(_hSelf, IDC_LIST_DLGTITLE, LB_GETTEXTLEN, i, 0);
361  	if (txtLen >= lenMax)
362  		return false;
363  	::SendDlgItemMessage(_hSelf, IDC_LIST_DLGTITLE, LB_GETTEXT, i, reinterpret_cast<LPARAM>(oldName));
364  	if (lstrcmp(newName, oldName) == 0)
365  		return true;
366  	::SendDlgItemMessage(_hSelf, IDC_LIST_DLGTITLE, LB_DELETESTRING, i, 0);
367  	::SendDlgItemMessage(_hSelf, IDC_LIST_DLGTITLE, LB_INSERTSTRING, i, reinterpret_cast<LPARAM>(newName));
368  	return true;
369  }
370  void PreferenceDlg::showDialogByName(const TCHAR *name) const
371  {
372  	int32_t i = getIndexFromName(name);
373  	if (i >= 0)
374  	{
375  		showDialogByIndex(i);
376  		setListSelection(i);
377  	}
378  }
379  void PreferenceDlg::showDialogByIndex(size_t index) const
380  {
381  	size_t len = _wVector.size();
382  	for (size_t i = 0; i < len; ++i)
383  	{
384  		_wVector[i]._dlg->display(false);
385  	}
386  	_wVector[index]._dlg->display(true);
387  }
388  void PreferenceDlg::destroy()
389  {
390  	_generalSubDlg.destroy();
391  	_editingSubDlg.destroy();
392  	_darkModeSubDlg.destroy();
393  	_marginsBorderEdgeSubDlg.destroy();
394  	_miscSubDlg.destroy();
395  	_fileAssocDlg.destroy();
396  	_languageSubDlg.destroy();
397  	_highlightingSubDlg.destroy();
398  	_printSubDlg.destroy();
399  	_searchingSubDlg.destroy();
400  	_newDocumentSubDlg.destroy();
401  	_defaultDirectorySubDlg.destroy();
402  	_recentFilesHistorySubDlg.destroy();
403  	_backupSubDlg.destroy();
404  	_autoCompletionSubDlg.destroy();
405  	_multiInstanceSubDlg.destroy();
406  	_delimiterSubDlg.destroy();
407  	_performanceSubDlg.destroy();
408  }
409  void GeneralSubDlg::setTabbarAlternateIcons(bool enable)
410  {
411  	NppGUI& nppGUI = NppParameters::getInstance().getNppGUI();
412  	if (!enable)
413  	{
414  		nppGUI._tabStatus &= ~TAB_ALTICONS;
415  		::SendDlgItemMessage(_hSelf, IDC_CHECK_TAB_ALTICONS, BM_SETCHECK, BST_UNCHECKED, 0);
416  	}
417  	else
418  	{
419  		nppGUI._tabStatus |= TAB_ALTICONS;
420  		::SendDlgItemMessage(_hSelf, IDC_CHECK_TAB_ALTICONS, BM_SETCHECK, BST_CHECKED, 0);
421  	}
422  }
423  intptr_t CALLBACK GeneralSubDlg::run_dlgProc(UINT message, WPARAM wParam, LPARAM)
424  {
425  	NppParameters& nppParam = NppParameters::getInstance();
426  	switch (message) 
427  	{
428  		case WM_INITDIALOG :
429  		{
430  			const NppGUI & nppGUI = nppParam.getNppGUI();
431  			toolBarStatusType tbStatus = nppGUI._toolBarStatus;
432  			int tabBarStatus = nppGUI._tabStatus;
433  			bool showTool = nppGUI._toolbarShow;
434  			bool showStatus = nppGUI._statusBarShow;
435  			bool showMenu = nppGUI._menuBarShow;
436  			bool hideRightShortcutsFromMenu = nppGUI._hideMenuRightShortcuts;
437  			::SendDlgItemMessage(_hSelf, IDC_CHECK_HIDE, BM_SETCHECK, showTool?BST_UNCHECKED:BST_CHECKED, 0);
438  			int ID2Check = 0;
439  			switch (tbStatus)
440  			{
441  				case TB_SMALL :
442  					ID2Check = IDC_RADIO_SMALLICON;
443  					break;
444  				case TB_LARGE :
445  					ID2Check = IDC_RADIO_BIGICON;
446  					break;
447  				case TB_SMALL2 :
448  					ID2Check = IDC_RADIO_SMALLICON2;
449  					break;
450  				case TB_LARGE2 :
451  					ID2Check = IDC_RADIO_BIGICON2;
452  					break;
453  				case TB_STANDARD:
454  				default :
455  					ID2Check = IDC_RADIO_STANDARD;
456  			}
457  			::SendDlgItemMessage(_hSelf, ID2Check, BM_SETCHECK, BST_CHECKED, 0);
458  			::SendDlgItemMessage(_hSelf, IDC_CHECK_REDUCE, BM_SETCHECK, tabBarStatus & TAB_REDUCE, 0);
459  			::SendDlgItemMessage(_hSelf, IDC_CHECK_LOCK, BM_SETCHECK, !(tabBarStatus & TAB_DRAGNDROP), 0);
460  			::SendDlgItemMessage(_hSelf, IDC_CHECK_ORANGE, BM_SETCHECK, tabBarStatus & TAB_DRAWTOPBAR, 0);
461  			::SendDlgItemMessage(_hSelf, IDC_CHECK_DRAWINACTIVE, BM_SETCHECK, tabBarStatus & TAB_DRAWINACTIVETAB, 0);
462  			::SendDlgItemMessage(_hSelf, IDC_CHECK_ENABLETABCLOSE, BM_SETCHECK, tabBarStatus & TAB_CLOSEBUTTON, 0);
463  			::SendDlgItemMessage(_hSelf, IDC_CHECK_DBCLICK2CLOSE, BM_SETCHECK, tabBarStatus & TAB_DBCLK2CLOSE, 0);
464  			::SendDlgItemMessage(_hSelf, IDC_CHECK_TAB_VERTICAL, BM_SETCHECK, tabBarStatus & TAB_VERTICAL, 0);
465  			::SendDlgItemMessage(_hSelf, IDC_CHECK_TAB_MULTILINE, BM_SETCHECK, tabBarStatus & TAB_MULTILINE, 0);
466  			::SendDlgItemMessage(_hSelf, IDC_CHECK_TAB_LAST_EXIT, BM_SETCHECK, tabBarStatus & TAB_QUITONEMPTY, 0);
467  			::SendDlgItemMessage(_hSelf, IDC_CHECK_TAB_ALTICONS, BM_SETCHECK, tabBarStatus & TAB_ALTICONS, 0);
468  			::SendDlgItemMessage(_hSelf, IDC_CHECK_TAB_HIDE, BM_SETCHECK, tabBarStatus & TAB_HIDE, 0);
469  			::SendMessage(_hSelf, WM_COMMAND, IDC_CHECK_TAB_HIDE, 0);
470  			::SendDlgItemMessage(_hSelf, IDC_CHECK_HIDESTATUSBAR, BM_SETCHECK, !showStatus, 0);
471  			::SendDlgItemMessage(_hSelf, IDC_CHECK_HIDEMENUBAR, BM_SETCHECK, !showMenu, 0);
472  			::SendDlgItemMessage(_hSelf, IDC_CHECK_HIDERIGHTSHORTCUTSOFMENUBAR, BM_SETCHECK, hideRightShortcutsFromMenu, 0);
473  			LocalizationSwitcher & localizationSwitcher = nppParam.getLocalizationSwitcher();
474  			for (size_t i = 0, len = localizationSwitcher.size(); i < len ; ++i)
475  			{
476  				pair<wstring, wstring> localizationInfo = localizationSwitcher.getElementFromIndex(i);
477  				::SendDlgItemMessage(_hSelf, IDC_COMBO_LOCALIZATION, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(localizationInfo.first.c_str()));
478  			}
479  			wstring lang = TEXT("English"); 
480  			if (nppParam.getNativeLangA()) 
481  			{
482  				string fn = localizationSwitcher.getFileName();
483  				wstring fnW = s2ws(fn);
484  				lang = localizationSwitcher.getLangFromXmlFileName(fnW.c_str());
485  			}
486  			auto index = ::SendDlgItemMessage(_hSelf, IDC_COMBO_LOCALIZATION, CB_FINDSTRINGEXACT, static_cast<WPARAM>(-1), reinterpret_cast<LPARAM>(lang.c_str()));
487  			if (index != CB_ERR)
488                  ::SendDlgItemMessage(_hSelf, IDC_COMBO_LOCALIZATION, CB_SETCURSEL, index, 0);
489  			return TRUE;
490  		}
491  		case WM_CTLCOLORLISTBOX:
492  		{
493  			return NppDarkMode::onCtlColor(reinterpret_cast<HDC>(wParam));
494  		}
495  		case WM_CTLCOLORDLG:
496  		case WM_CTLCOLORSTATIC:
497  		{
498  			return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
499  		}
500  		case WM_PRINTCLIENT:
501  		{
502  			if (NppDarkMode::isEnabled())
503  			{
504  				return TRUE;
505  			}
506  			break;
507  		}
508  		case WM_COMMAND:
509  		{
510  			switch (wParam)
511  			{
512  				case IDC_CHECK_HIDESTATUSBAR:
513  				{
514  					const bool isChecked = isCheckedOrNot(IDC_CHECK_HIDESTATUSBAR);
515  					::SendMessage(::GetParent(_hParent), NPPM_HIDESTATUSBAR, 0, isChecked ? TRUE : FALSE);
516  				}
517  				return TRUE;
518  				case IDC_CHECK_HIDEMENUBAR :
519  				{
520  					bool isChecked = (BST_CHECKED == ::SendDlgItemMessage(_hSelf, IDC_CHECK_HIDEMENUBAR, BM_GETCHECK, 0, 0));
521  					::SendMessage(::GetParent(_hParent), NPPM_HIDEMENU, 0, isChecked?TRUE:FALSE);
522  				}
523  				return TRUE;
524  				case IDC_CHECK_HIDERIGHTSHORTCUTSOFMENUBAR:
525  				{
526  					bool isChecked = (BST_CHECKED == ::SendDlgItemMessage(_hSelf, IDC_CHECK_HIDERIGHTSHORTCUTSOFMENUBAR, BM_GETCHECK, 0, 0));
527  					NppGUI& nppGUI = nppParam.getNppGUI();
528  					nppGUI._hideMenuRightShortcuts = isChecked;
529  				}
530  				return TRUE;
531  				case IDC_CHECK_TAB_HIDE :
532  				{
533  					bool toBeHidden = (BST_CHECKED == ::SendMessage(::GetDlgItem(_hSelf, IDC_CHECK_TAB_HIDE), BM_GETCHECK, 0, 0));
534  					::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_TAB_MULTILINE), !toBeHidden);
535  					::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_TAB_VERTICAL), !toBeHidden);
536  					::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_REDUCE), !toBeHidden);
537  					::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_LOCK), !toBeHidden);
538  					::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_ORANGE), !toBeHidden);
539  					::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_DRAWINACTIVE), !toBeHidden);
540  					::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_ENABLETABCLOSE), !toBeHidden);
541  					::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_DBCLICK2CLOSE), !toBeHidden);
542  					::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_TAB_LAST_EXIT), !toBeHidden);
543  					::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_TAB_ALTICONS), !toBeHidden);
544  					::SendMessage(::GetParent(_hParent), NPPM_HIDETABBAR, 0, toBeHidden);
545  					return TRUE;
546  				}
547  				case  IDC_CHECK_TAB_VERTICAL:
548  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_DRAWTABBAR_VERTICAL, 0);
549  					return TRUE;
550  				case IDC_CHECK_TAB_MULTILINE :
551  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_DRAWTABBAR_MULTILINE, 0);
552  					return TRUE;
553  				case IDC_CHECK_TAB_LAST_EXIT:
554  				{
555  					NppGUI & nppGUI = nppParam.getNppGUI();
556  					nppGUI._tabStatus ^= TAB_QUITONEMPTY;
557  				}
558  				return TRUE;
559  				case IDC_CHECK_TAB_ALTICONS:
560  				{
561  					NppGUI& nppGUI = nppParam.getNppGUI();
562  					nppGUI._tabStatus ^= TAB_ALTICONS;
563  					const bool isChecked = isCheckedOrNot(IDC_CHECK_TAB_ALTICONS);
564  					const bool isBtnCmd = true;
565  					::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_CHANGETABBAEICONS, static_cast<WPARAM>(isBtnCmd), isChecked ? 1 : (nppGUI._darkmode._isEnabled ? 2 : 0));
566  					NppDarkMode::setTabIconSet(isChecked, NppDarkMode::isEnabled());
567  					return TRUE;
568  				}
<span onclick='openModal()' class='match'>569  				case IDC_CHECK_REDUCE :
570  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_REDUCETABBAR, 0);
571  					return TRUE;
572  				case IDC_CHECK_LOCK :
573  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_LOCKTABBAR, 0);
574  					return TRUE;
575  				case IDC_CHECK_ORANGE :
576  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_DRAWTABBAR_TOPBAR, 0);
577  					return TRUE;
578  				case IDC_CHECK_DRAWINACTIVE :
579  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_DRAWTABBAR_INACIVETAB, 0);
580  					return TRUE;
581  				case IDC_CHECK_ENABLETABCLOSE :
582  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_DRAWTABBAR_CLOSEBOTTUN, 0);
583  					return TRUE;
584  				case IDC_CHECK_DBCLICK2CLOSE :
585  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_DRAWTABBAR_DBCLK2CLOSE, 0);
586  					return TRUE;
587  				case IDC_CHECK_HIDE :
</span>588  				{
589  					bool isChecked = (BST_CHECKED == ::SendDlgItemMessage(_hSelf, IDC_CHECK_HIDE, BM_GETCHECK, 0, 0));
590  					::SendMessage(::GetParent(_hParent), NPPM_HIDETOOLBAR, 0, isChecked?TRUE:FALSE);
591  				}
592  				return TRUE;
593  				case IDC_RADIO_SMALLICON :
594  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_TOOLBAR_REDUCE, 0);
595  					NppDarkMode::setToolBarIconSet(0, NppDarkMode::isEnabled());
596  					return TRUE;
597  				case IDC_RADIO_BIGICON :
598  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_TOOLBAR_ENLARGE, 0);
599  					NppDarkMode::setToolBarIconSet(1, NppDarkMode::isEnabled());
600  					return TRUE;
601  				case IDC_RADIO_SMALLICON2:
602  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_TOOLBAR_REDUCE_SET2, 0);
603  					NppDarkMode::setToolBarIconSet(2, NppDarkMode::isEnabled());
604  					return TRUE;
605  				case IDC_RADIO_BIGICON2:
606  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_TOOLBAR_ENLARGE_SET2, 0);
607  					NppDarkMode::setToolBarIconSet(3, NppDarkMode::isEnabled());
608  					return TRUE;
609  				case IDC_RADIO_STANDARD :
610  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_TOOLBAR_STANDARD, 0);
611  					NppDarkMode::setToolBarIconSet(4, NppDarkMode::isEnabled());
612  					return TRUE;
613  				default :
614  					switch (HIWORD(wParam))
615  					{
616  						case CBN_SELCHANGE : 
617  						{
618  							switch (LOWORD(wParam))
619  							{
620  								case IDC_COMBO_LOCALIZATION :
621  								{
622  									LocalizationSwitcher & localizationSwitcher = nppParam.getLocalizationSwitcher();
623  									auto index = ::SendDlgItemMessage(_hSelf, IDC_COMBO_LOCALIZATION, CB_GETCURSEL, 0, 0);
624  									TCHAR langName[MAX_PATH] = { '\0' };
625  									auto cbTextLen = ::SendDlgItemMessage(_hSelf, IDC_COMBO_LOCALIZATION, CB_GETLBTEXTLEN, index, 0);
626  									if (cbTextLen > MAX_PATH - 1)
627  										return TRUE;
628  									::SendDlgItemMessage(_hSelf, IDC_COMBO_LOCALIZATION, CB_GETLBTEXT, index, reinterpret_cast<LPARAM>(langName));
629  									if (langName[0])
630  									{
631  										if (localizationSwitcher.switchToLang(TEXT("English")))
632  										{
633  											::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_RELOADNATIVELANG, 0, 0);
634  										}
635  										if (localizationSwitcher.switchToLang(langName))
636  										{
637  											::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_RELOADNATIVELANG, 0, 0);
638  											::InvalidateRect(_hParent, NULL, TRUE);
639  										}
640  									}
641  								}
642  								return TRUE;
643  								default:
644  									break;
645  							}
646  						}
647  					}
648  			}
649  		}
650  	}
651  	return FALSE;
652  }
653  void EditingSubDlg::initScintParam()
654  {
655  	NppParameters& nppParam = NppParameters::getInstance();
656  	ScintillaViewParams & svp = const_cast<ScintillaViewParams &>(nppParam.getSVP());
657  	int id = 0;
658  	switch (svp._lineWrapMethod)
659  	{
660  		case LINEWRAP_ALIGNED:
661  			id = IDC_RADIO_LWALIGN;
662  			break;
663  		case LINEWRAP_INDENT:
664  			id = IDC_RADIO_LWINDENT;
665  			break;
666  		default : 
667  			id = IDC_RADIO_LWDEF;
668  	}
669  	::SendDlgItemMessage(_hSelf, id, BM_SETCHECK, TRUE, 0);
670  	::SendDlgItemMessage(_hSelf, IDC_CHECK_SMOOTHFONT, BM_SETCHECK, svp._doSmoothFont, 0);
671  	int lineHilite = 0;
672  	switch (svp._currentLineHiliteMode)
673  	{
674  		case LINEHILITE_NONE:
675  			lineHilite = IDC_RADIO_CLM_NONE;
676  			break;
677  		case LINEHILITE_FRAME:
678  			lineHilite = IDC_RADIO_CLM_FRAME;
679  			break;
680  		default : 
681  			lineHilite = IDC_RADIO_CLM_HILITE;
682  	}
683  	::SendDlgItemMessage(_hSelf, lineHilite, BM_SETCHECK, TRUE, 0);
684  	::EnableWindow(::GetDlgItem(_hSelf, IDC_CARETLINEFRAME_WIDTH_SLIDER), (svp._currentLineHiliteMode == LINEHILITE_FRAME));
685  	::SendDlgItemMessage(_hSelf, IDC_CHECK_VIRTUALSPACE, BM_SETCHECK, svp._virtualSpace, 0);
686  	::SendDlgItemMessage(_hSelf, IDC_CHECK_SCROLLBEYONDLASTLINE, BM_SETCHECK, svp._scrollBeyondLastLine, 0);
687  	::SendDlgItemMessage(_hSelf, IDC_CHECK_RIGHTCLICKKEEPSSELECTION, BM_SETCHECK, svp._rightClickKeepsSelection, 0);
688  	::SendDlgItemMessage(_hSelf, IDC_CHECK_DISABLEADVANCEDSCROLL, BM_SETCHECK, svp._disableAdvancedScrolling, 0);
689  }
690  void EditingSubDlg::changeLineHiliteMode(bool enableSlider)
691  {
692  	::EnableWindow(::GetDlgItem(_hSelf, IDC_CARETLINEFRAME_WIDTH_SLIDER), enableSlider);
693  	redrawDlgItem(IDC_CARETLINEFRAME_WIDTH_STATIC);
694  	redrawDlgItem(IDC_CARETLINEFRAME_WIDTH_DISPLAY);
695  	::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_CURLINE_HILITING, 0);
696  }
697  static WNDPROC oldFunclstToolbarProc = NULL;
698  static LRESULT CALLBACK editNumSpaceProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
699  {
700  	switch (message)
701  	{
702  		case WM_CHAR:
703  		{
704  			if ((wParam != 8 && wParam != 32 && wParam < 48) || wParam > 57)
705  			{
706  				return TRUE;
707  			}
708  		}
709  	}
710  	return oldFunclstToolbarProc(hwnd, message, wParam, lParam);
711  }
712  intptr_t CALLBACK EditingSubDlg::run_dlgProc(UINT message, WPARAM wParam, LPARAM lParam)
713  {
714  	NppParameters& nppParam = NppParameters::getInstance();
715  	NppGUI & nppGUI = nppParam.getNppGUI();
716  	ScintillaViewParams& svp = (ScintillaViewParams&)nppParam.getSVP();
717  	switch (message)
718  	{
719  		case WM_INITDIALOG :
720  		{
721  			::SendDlgItemMessage(_hSelf, IDC_WIDTH_COMBO, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(TEXT("0")));
722  			::SendDlgItemMessage(_hSelf, IDC_WIDTH_COMBO, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(TEXT("1")));
723  			::SendDlgItemMessage(_hSelf, IDC_WIDTH_COMBO, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(TEXT("2")));
724  			::SendDlgItemMessage(_hSelf, IDC_WIDTH_COMBO, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(TEXT("3")));
725  			::SendDlgItemMessage(_hSelf, IDC_WIDTH_COMBO, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(TEXT("Block")));
726  			::SendDlgItemMessage(_hSelf, IDC_WIDTH_COMBO, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(TEXT("Block After")));
727  			::SendMessage(::GetDlgItem(_hSelf, IDC_WIDTH_COMBO), CB_SETCURSEL, nppGUI._caretWidth, 0);
728  			::SendDlgItemMessage(_hSelf, IDC_CHECK_FOLDINGTOGGLE, BM_SETCHECK, nppGUI._enableFoldCmdToggable, 0);
729  			::SendDlgItemMessage(_hSelf, IDC_CHECK_MULTISELECTION, BM_SETCHECK, nppGUI._enableMultiSelection, 0);
730  			::SendMessage(::GetDlgItem(_hSelf, IDC_CARETBLINKRATE_SLIDER),TBM_SETRANGEMIN, TRUE, BLINKRATE_FASTEST);
731  			::SendMessage(::GetDlgItem(_hSelf, IDC_CARETBLINKRATE_SLIDER),TBM_SETRANGEMAX, TRUE, BLINKRATE_SLOWEST);
732  			::SendMessage(::GetDlgItem(_hSelf, IDC_CARETBLINKRATE_SLIDER),TBM_SETPAGESIZE, 0, BLINKRATE_INTERVAL);
733  			int blinkRate = (nppGUI._caretBlinkRate == 0) ? BLINKRATE_SLOWEST : nppGUI._caretBlinkRate;
734  			::SendMessage(::GetDlgItem(_hSelf, IDC_CARETBLINKRATE_SLIDER),TBM_SETPOS, TRUE, blinkRate);
735  			::SendMessage(::GetDlgItem(_hSelf, IDC_CARETLINEFRAME_WIDTH_SLIDER), TBM_SETRANGEMIN, TRUE, CARETLINEFRAME_SMALLEST);
736  			::SendMessage(::GetDlgItem(_hSelf, IDC_CARETLINEFRAME_WIDTH_SLIDER), TBM_SETRANGEMAX, TRUE, CARETLINEFRAME_LARGEST);
737  			::SendMessage(::GetDlgItem(_hSelf, IDC_CARETLINEFRAME_WIDTH_SLIDER), TBM_SETPAGESIZE, 0, CARETLINEFRAME_INTERVAL);
738  			::SendMessage(::GetDlgItem(_hSelf, IDC_CARETLINEFRAME_WIDTH_SLIDER), TBM_SETPOS, TRUE, svp._currentLineFrameWidth);
739  			::SetDlgItemInt(_hSelf, IDC_CARETLINEFRAME_WIDTH_DISPLAY, svp._currentLineFrameWidth, FALSE);
740  			bool checkDefaultCRLF = true;
741  			bool checkPlainTextCRLF = false;
742  			bool checkWithColorCRLF = false;
743  			if (svp._eolMode == svp.plainText)
744  			{
745  				checkDefaultCRLF = false;
746  				checkPlainTextCRLF = true;
747  				checkWithColorCRLF = false;
748  			}
749  			else if (svp._eolMode == svp.plainTextCustomColor)
750  			{
751  				checkDefaultCRLF = false;
752  				checkPlainTextCRLF = true;
753  				checkWithColorCRLF = true;
754  			}
755  			else if (svp._eolMode == svp.roundedRectangleTextCustomColor)
756  			{
757  				checkDefaultCRLF = true;
758  				checkPlainTextCRLF = false;
759  				checkWithColorCRLF = true;
760  			}
761  			::SendDlgItemMessage(_hSelf, IDC_RADIO_ROUNDCORNER_CRLF, BM_SETCHECK, checkDefaultCRLF, 0);
762  			::SendDlgItemMessage(_hSelf, IDC_RADIO_PLEINTEXT_CRLF, BM_SETCHECK, checkPlainTextCRLF, 0);
763  			::SendDlgItemMessage(_hSelf, IDC_CHECK_WITHCUSTOMCOLOR_CRLF, BM_SETCHECK, checkWithColorCRLF, 0);
764  			NativeLangSpeaker* pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
765  			generic_string tip2show = pNativeSpeaker->getLocalizedStrFromID("eol-custom-color-tip", TEXT("Go to Style Configurator to change the default EOL custom color (\"EOL custom color\")."));
766  			_tip = CreateToolTip(IDC_BUTTON_LAUNCHSTYLECONF_CRLF, _hSelf, _hInst, const_cast<PTSTR>(tip2show.c_str()), pNativeSpeaker->isRTL());
767  			const bool isNpcModeAbbrv = svp._npcMode == svp.abbreviation;
768  			setChecked(IDC_RADIO_NPC_ABBREVIATION, isNpcModeAbbrv);
769  			setChecked(IDC_RADIO_NPC_CODEPOINT, !isNpcModeAbbrv);
770  			setChecked(IDC_CHECK_NPC_COLOR, svp._npcCustomColor);
771  			setChecked(IDC_CHECK_NPC_INCLUDECCUNIEOL, svp._npcIncludeCcUniEol);
772  			generic_string tipNote2Show = pNativeSpeaker->getLocalizedStrFromID("npcNote-tip",
773  				L"Representation of selected \"non-ASCII\" whitespace and non-printing (control) characters.\n\n"\
774  				L"NOTE:\n"\
775  				L"Using representation will disable character effects on text.\n\n"\
776  				L"For the full list of selected whitespace and non-printing characters check User Manual.\n\n"\
777  				L"Click on this button to open website with User Manual.");
778  			generic_string tipAb2Show = pNativeSpeaker->getLocalizedStrFromID("npcAbbreviation-tip",
779  				L"Abbreviation : name\n"\
780  				L"NBSP : no-break space\n"\
781  				L"ZWSP : zero-width space\n"\
782  				L"ZWNBSP : zero-width no-break space\n\n"\
783  				L"For the full list check User Manual.\n"\
784  				L"Click on \"?\" button on right to open website with User Manual.");
785  			generic_string tipCp2Show = pNativeSpeaker->getLocalizedStrFromID("npcCodepoint-tip",
786  				L"Codepoint : name\n"\
787  				L"U+00A0 : no-break space\n"\
788  				L"U+200B : zero-width space\n"\
789  				L"U+FEFF : zero-width no-break space\n\n"\
790  				L"For the full list check User Manual.\n"\
791  				L"Click on \"?\" button on right to open website with User Manual.");
792  			generic_string tipNpcCol2show = pNativeSpeaker->getLocalizedStrFromID("npcCustomColor-tip",
793  				L"Go to Style Configurator to change the default custom color for selected whitespace and non-printing characters (\"Non-printing characters custom color\").");
794  			generic_string tipNpcInc2show = pNativeSpeaker->getLocalizedStrFromID("npcIncludeCcUniEol-tip",
795  				L"Apply non-printing characters appearance settings to C0, C1 control and Unicode EOL (next line, line separator and paragraph separator) characters.");
796  			_tipNote = CreateToolTip(IDC_BUTTON_NPC_NOTE, _hSelf, _hInst, const_cast<PTSTR>(tipNote2Show.c_str()), pNativeSpeaker->isRTL());
797  			_tipAbb = CreateToolTip(IDC_RADIO_NPC_ABBREVIATION, _hSelf, _hInst, const_cast<PTSTR>(tipAb2Show.c_str()), pNativeSpeaker->isRTL());
798  			_tipCodepoint = CreateToolTip(IDC_RADIO_NPC_CODEPOINT, _hSelf, _hInst, const_cast<PTSTR>(tipCp2Show.c_str()), pNativeSpeaker->isRTL());
799  			_tipNpcColor = CreateToolTip(IDC_BUTTON_NPC_LAUNCHSTYLECONF, _hSelf, _hInst, const_cast<PTSTR>(tipNpcCol2show.c_str()), pNativeSpeaker->isRTL());
800  			_tipNpcInclude = CreateToolTip(IDC_CHECK_NPC_INCLUDECCUNIEOL, _hSelf, _hInst, const_cast<PTSTR>(tipNpcInc2show.c_str()), pNativeSpeaker->isRTL());
801  			_tips.push_back(_tipNote);
802  			_tips.push_back(_tipAbb);
803  			_tips.push_back(_tipCodepoint);
804  			_tips.push_back(_tipNpcColor);
805  			_tips.push_back(_tipNpcInclude);
806  			for (auto& tip : _tips)
807  			{
808  				if (tip != nullptr)
809  				{
810  					::SendMessage(tip, TTM_SETMAXTIPWIDTH, 0, 260);
811  				}
812  			}
813  			if (_tipNote != nullptr)
814  			{
815  				::SendMessage(_tipNote, TTM_SETDELAYTIME, TTDT_AUTOPOP, MAKELPARAM((30000), (0)));
816  			}
817  			initScintParam();
818  			return TRUE;
819  		}
820  		case WM_CTLCOLOREDIT:
821  		{
822  			return NppDarkMode::onCtlColorSofter(reinterpret_cast<HDC>(wParam));
823  		}
824  		case WM_CTLCOLORLISTBOX:
825  		{
826  			return NppDarkMode::onCtlColor(reinterpret_cast<HDC>(wParam));
827  		}
828  		case WM_CTLCOLORDLG:
829  		{
830  			return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
831  		}
832  		case WM_CTLCOLORSTATIC:
833  		{
834  			int dlgCtrlID = ::GetDlgCtrlID(reinterpret_cast<HWND>(lParam));
835  			if (dlgCtrlID == IDC_CARETLINEFRAME_WIDTH_STATIC || dlgCtrlID == IDC_CARETLINEFRAME_WIDTH_DISPLAY)
836  			{
837  				return NppDarkMode::onCtlColorDarkerBGStaticText(reinterpret_cast<HDC>(wParam), (svp._currentLineHiliteMode == LINEHILITE_FRAME));
838  			}
839  			return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
840  		}
841  		case WM_PRINTCLIENT:
842  		{
843  			if (NppDarkMode::isEnabled())
844  			{
845  				return TRUE;
846  			}
847  			break;
848  		}
849  		case WM_HSCROLL:
850  		{
851  			HWND hCaretBlinkRateSlider = ::GetDlgItem(_hSelf, IDC_CARETBLINKRATE_SLIDER);
852  			HWND hCaretLineFrameSlider = ::GetDlgItem(_hSelf, IDC_CARETLINEFRAME_WIDTH_SLIDER);
853  			if (reinterpret_cast<HWND>(lParam) == hCaretBlinkRateSlider)
854  			{
855  				auto blinkRate = ::SendMessage(hCaretBlinkRateSlider, TBM_GETPOS, 0, 0);
856  				if (blinkRate == BLINKRATE_SLOWEST)
857  					blinkRate = 0;
858  				nppGUI._caretBlinkRate = static_cast<int>(blinkRate);
859  				::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_SETCARETBLINKRATE, 0, 0);
860  			}
861  			else if (reinterpret_cast<HWND>(lParam) == hCaretLineFrameSlider)
862  			{
863  				svp._currentLineFrameWidth = static_cast<unsigned char>(::SendMessage(hCaretLineFrameSlider, TBM_GETPOS, 0, 0));
864  				::SetDlgItemInt(_hSelf, IDC_CARETLINEFRAME_WIDTH_DISPLAY, svp._currentLineFrameWidth, FALSE);
865  				::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_CARETLINEFRAME, 0, svp._currentLineFrameWidth);
866  			}
867  			return 0;	
868  		}
869  		case WM_COMMAND : 
870  		{
871  			ScintillaViewParams & svp = const_cast<ScintillaViewParams &>(nppParam.getSVP());
872  			switch (wParam)
873  			{
874  				case IDC_CHECK_SMOOTHFONT:
875  					svp._doSmoothFont = (BST_CHECKED == ::SendDlgItemMessage(_hSelf, IDC_CHECK_SMOOTHFONT, BM_GETCHECK, 0, 0));
876  					::SendMessage(::GetParent(_hParent), NPPM_SETSMOOTHFONT, 0, svp._doSmoothFont);
877  					return TRUE;
878  				case IDC_RADIO_CLM_NONE:
879  					svp._currentLineHiliteMode = LINEHILITE_NONE;
880  					changeLineHiliteMode(false);
881  					return TRUE;
882  				case IDC_RADIO_CLM_HILITE:
883  					svp._currentLineHiliteMode = LINEHILITE_HILITE;
884  					changeLineHiliteMode(false);
885  					return TRUE;
886  				case IDC_RADIO_CLM_FRAME:
887  					svp._currentLineHiliteMode = LINEHILITE_FRAME;
888  					changeLineHiliteMode(true);
889  					return TRUE;
890  				case IDC_RADIO_ROUNDCORNER_CRLF:
891  				case IDC_RADIO_PLEINTEXT_CRLF:
892  				case IDC_CHECK_WITHCUSTOMCOLOR_CRLF:
893  				{
894  					bool doCustomColor = isCheckedOrNot(IDC_CHECK_WITHCUSTOMCOLOR_CRLF);
895  					if (wParam == IDC_RADIO_ROUNDCORNER_CRLF)
896  					{
897  						svp._eolMode = doCustomColor ? svp.roundedRectangleTextCustomColor : svp.roundedRectangleText;
898  					}
899  					else if (wParam == IDC_RADIO_PLEINTEXT_CRLF)
900  					{
901  						svp._eolMode = doCustomColor ? svp.plainTextCustomColor : svp.plainText;
902  					}
903  					else 
904  					{
905  						if (isCheckedOrNot(IDC_RADIO_ROUNDCORNER_CRLF))
906  						{
907  							svp._eolMode = doCustomColor ? svp.roundedRectangleTextCustomColor : svp.roundedRectangleText;
908  						}
909  						else 
910  						{
911  							svp._eolMode = doCustomColor ? svp.plainTextCustomColor : svp.plainText;
912  						}
913  					}
914  					HWND grandParent = ::GetParent(_hParent);
915  					::SendMessage(grandParent, NPPM_INTERNAL_CRLFFORMCHANGED, 0, 0);
916  					return TRUE;
917  				}
918  				case IDC_BUTTON_LAUNCHSTYLECONF_CRLF:
919  				{
920  					HWND grandParent = ::GetParent(_hParent);
921  					::SendMessage(grandParent, NPPM_INTERNAL_CRLFLAUNCHSTYLECONF, 0, 0);
922  					return TRUE;
923  				}
924  				case IDC_RADIO_NPC_ABBREVIATION:
925  				case IDC_RADIO_NPC_CODEPOINT:
926  				{
927  					if (wParam == IDC_RADIO_NPC_CODEPOINT)
928  					{
929  						svp._npcMode = svp.codepoint;
930  					}
931  					else 
932  					{
933  						svp._npcMode = svp.abbreviation;
934  					}
935  					HWND grandParent = ::GetParent(_hParent);
936  					::SendMessage(grandParent, NPPM_INTERNAL_SETNPC, 0, 0);
937  					return TRUE;
938  				}
939  				case IDC_BUTTON_NPC_NOTE:
940  				{
941  					::ShellExecute(NULL, L"open", L"https:&bsol;&bsol;npp-user-manual.org/docs/views/#show-symbol", NULL, NULL, SW_SHOWNORMAL);
942  					return TRUE;
943  				}
944  				case IDC_CHECK_NPC_COLOR:
945  				{
946  					svp._npcCustomColor = isCheckedOrNot(IDC_CHECK_NPC_COLOR);
947  					HWND grandParent = ::GetParent(_hParent);
948  					::SendMessage(grandParent, NPPM_INTERNAL_NPCFORMCHANGED, 0, 0);
949  					return TRUE;
950  				}
951  				case IDC_BUTTON_NPC_LAUNCHSTYLECONF:
952  				{
953  					HWND grandParent = ::GetParent(_hParent);
954  					::SendMessage(grandParent, NPPM_INTERNAL_NPCLAUNCHSTYLECONF, 0, 0);
955  					return TRUE;
956  				}
957  				case IDC_CHECK_NPC_INCLUDECCUNIEOL:
958  				{
959  					svp._npcIncludeCcUniEol = isCheckedOrNot(IDC_CHECK_NPC_INCLUDECCUNIEOL);
960  					const HWND grandParent = ::GetParent(_hParent);
961  					::SendMessage(grandParent, NPPM_INTERNAL_SETNPC, IDC_CHECK_NPC_INCLUDECCUNIEOL, 0);
962  					return TRUE;
963  				}
964  				case IDC_CHECK_VIRTUALSPACE:
965  					svp._virtualSpace = (BST_CHECKED == ::SendDlgItemMessage(_hSelf, IDC_CHECK_VIRTUALSPACE, BM_GETCHECK, 0, 0));
966  					::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_VIRTUALSPACE, 0, 0);
967  					return TRUE;
968  				case IDC_CHECK_SCROLLBEYONDLASTLINE:
969  					svp._scrollBeyondLastLine = (BST_CHECKED == ::SendDlgItemMessage(_hSelf, IDC_CHECK_SCROLLBEYONDLASTLINE, BM_GETCHECK, 0, 0));
970  					::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_SCROLLBEYONDLASTLINE, 0, 0);
971  					return TRUE;
972  				case IDC_CHECK_RIGHTCLICKKEEPSSELECTION:
973  					svp._rightClickKeepsSelection = (BST_CHECKED == ::SendDlgItemMessage(_hSelf, IDC_CHECK_RIGHTCLICKKEEPSSELECTION, BM_GETCHECK, 0, 0));
974  					return TRUE;
975  				case IDC_CHECK_DISABLEADVANCEDSCROLL:
976  					svp._disableAdvancedScrolling = (BST_CHECKED == ::SendDlgItemMessage(_hSelf, IDC_CHECK_DISABLEADVANCEDSCROLL, BM_GETCHECK, 0, 0));
977  					return TRUE;
978                  case IDC_CHECK_MULTISELECTION :
979                      nppGUI._enableMultiSelection = (BST_CHECKED == ::SendDlgItemMessage(_hSelf, IDC_CHECK_MULTISELECTION, BM_GETCHECK, 0, 0));
980                      ::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_SETMULTISELCTION, 0, 0);
981                      return TRUE;
982  				case IDC_CHECK_FOLDINGTOGGLE:
983  					nppGUI._enableFoldCmdToggable = isCheckedOrNot(IDC_CHECK_FOLDINGTOGGLE);
984  					return TRUE;
985  				case IDC_RADIO_LWDEF:
986  					svp._lineWrapMethod = LINEWRAP_DEFAULT;
987  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_LWDEF, 0);
988  					return TRUE;
989  				case IDC_RADIO_LWALIGN:
990  					svp._lineWrapMethod = LINEWRAP_ALIGNED;
991  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_LWALIGN, 0);
992  					return TRUE;
993  				case IDC_RADIO_LWINDENT:
994  					svp._lineWrapMethod = LINEWRAP_INDENT;
995  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_LWINDENT, 0);
996  					return TRUE;
997  				default :
998  					switch (HIWORD(wParam))
999  					{
1000  						case CBN_SELCHANGE : 
1001  						{
1002  							if (LOWORD(wParam) == IDC_WIDTH_COMBO)
1003  							{
1004  								nppGUI._caretWidth = static_cast<int32_t>(::SendDlgItemMessage(_hSelf, IDC_WIDTH_COMBO, CB_GETCURSEL, 0, 0));
1005  								::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_SETCARETWIDTH, 0, 0);
1006  								return TRUE;
1007  							}
1008  						}
1009  						break;
1010  					}
1011  			}
1012  		}
1013  	}
1014  	return FALSE;
1015  }
1016  void DarkModeSubDlg::enableCustomizedColorCtrls(bool doEnable)
1017  {
1018  	::EnableWindow(_pBackgroundColorPicker->getHSelf(), doEnable);
1019  	::EnableWindow(_pSofterBackgroundColorPicker->getHSelf(), doEnable);
1020  	::EnableWindow(_pHotBackgroundColorPicker->getHSelf(), doEnable);
1021  	::EnableWindow(_pPureBackgroundColorPicker->getHSelf(), doEnable);
1022  	::EnableWindow(_pErrorBackgroundColorPicker->getHSelf(), doEnable);
1023  	::EnableWindow(_pTextColorPicker->getHSelf(), doEnable);
1024  	::EnableWindow(_pDarkerTextColorPicker->getHSelf(), doEnable);
1025  	::EnableWindow(_pDisabledTextColorPicker->getHSelf(), doEnable);
1026  	::EnableWindow(_pEdgeColorPicker->getHSelf(), doEnable);
1027  	::EnableWindow(_pLinkColorPicker->getHSelf(), doEnable);
1028  	::EnableWindow(_pHotEdgeColorPicker->getHSelf(), doEnable);
1029  	::EnableWindow(_pDisabledEdgeColorPicker->getHSelf(), doEnable);
1030  	::EnableWindow(::GetDlgItem(_hSelf, IDD_CUSTOMIZED_RESET_BUTTON), doEnable);
1031  	if (doEnable)
1032  	{
1033  		_pBackgroundColorPicker->setColour(NppDarkMode::getBackgroundColor());
1034  		_pSofterBackgroundColorPicker->setColour(NppDarkMode::getSofterBackgroundColor());
1035  		_pHotBackgroundColorPicker->setColour(NppDarkMode::getHotBackgroundColor());
1036  		_pPureBackgroundColorPicker->setColour(NppDarkMode::getDarkerBackgroundColor());
1037  		_pErrorBackgroundColorPicker->setColour(NppDarkMode::getErrorBackgroundColor());
1038  		_pTextColorPicker->setColour(NppDarkMode::getTextColor());
1039  		_pDarkerTextColorPicker->setColour(NppDarkMode::getDarkerTextColor());
1040  		_pDisabledTextColorPicker->setColour(NppDarkMode::getDisabledTextColor());
1041  		_pEdgeColorPicker->setColour(NppDarkMode::getEdgeColor());
1042  		_pLinkColorPicker->setColour(NppDarkMode::getLinkTextColor());
1043  		_pHotEdgeColorPicker->setColour(NppDarkMode::getHotEdgeColor());
1044  		_pDisabledEdgeColorPicker->setColour(NppDarkMode::getDisabledEdgeColor());
1045  	}
1046  }
1047  void DarkModeSubDlg::move2CtrlLeft(int ctrlID, HWND handle2Move, int handle2MoveWidth, int handle2MoveHeight)
1048  {
1049  	POINT p{};
1050  	RECT rc{};
1051  	::GetWindowRect(::GetDlgItem(_hSelf, ctrlID), &rc);
1052  	NppParameters& nppParam = NppParameters::getInstance();
1053  	if(nppParam.getNativeLangSpeaker()->isRTL())
1054  		p.x = rc.right + nppParam._dpiManager.scaleX(5) + handle2MoveWidth;
1055  	else
1056  		p.x = rc.left - nppParam._dpiManager.scaleX(5) - handle2MoveWidth;
1057  	p.y = rc.top + ((rc.bottom - rc.top) / 2) - handle2MoveHeight / 2;
1058  	::ScreenToClient(_hSelf, &p);
1059  	::MoveWindow(handle2Move, p.x, p.y, handle2MoveWidth, handle2MoveHeight, TRUE);
1060  }
1061  intptr_t CALLBACK DarkModeSubDlg::run_dlgProc(UINT message, WPARAM wParam, LPARAM lParam)
1062  {
1063  	UNREFERENCED_PARAMETER(lParam);
1064  	NppParameters& nppParam = NppParameters::getInstance();
1065  	NppGUI& nppGUI = nppParam.getNppGUI();
1066  	switch (message)
1067  	{
1068  		case WM_INITDIALOG:
1069  		{
1070  			::EnableWindow(::GetDlgItem(_hSelf, IDC_RADIO_DARKMODE_FOLLOWWINDOWS), NppDarkMode::isWindows10());
1071  			const int topControlID = NppDarkMode::isWindowsModeEnabled() && NppDarkMode::isWindows10() ? IDC_RADIO_DARKMODE_FOLLOWWINDOWS : NppDarkMode::isEnabled() ? IDC_RADIO_DARKMODE_DARKMODE : IDC_RADIO_DARKMODE_LIGHTMODE;
1072  			::SendDlgItemMessage(_hSelf, topControlID, BM_SETCHECK, BST_CHECKED, 0);
1073  			int id = IDC_RADIO_DARKMODE_BLACK;
1074  			switch (nppGUI._darkmode._colorTone)
1075  			{
1076  				case NppDarkMode::redTone:
1077  					id = IDC_RADIO_DARKMODE_RED;
1078  					break;
1079  				case NppDarkMode::greenTone:
1080  					id = IDC_RADIO_DARKMODE_GREEN;
1081  					break;
1082  				case NppDarkMode::blueTone:
1083  					id = IDC_RADIO_DARKMODE_BLUE;
1084  					break;
1085  				case NppDarkMode::purpleTone:
1086  					id = IDC_RADIO_DARKMODE_PURPLE;
1087  					break;
1088  				case NppDarkMode::cyanTone:
1089  					id = IDC_RADIO_DARKMODE_CYAN;
1090  					break;
1091  				case NppDarkMode::oliveTone:
1092  					id = IDC_RADIO_DARKMODE_OLIVE;
1093  					break;
1094  				case NppDarkMode::customizedTone:
1095  					id = IDC_RADIO_DARKMODE_CUSTOMIZED;
1096  					break;
1097  				case NppDarkMode::blackTone:
1098  				default:
1099  					break;
1100  			}
1101  			::SendDlgItemMessage(_hSelf, id, BM_SETCHECK, TRUE, 0);
1102  			_pBackgroundColorPicker = new ColourPicker;
1103  			_pSofterBackgroundColorPicker = new ColourPicker;
1104  			_pHotBackgroundColorPicker = new ColourPicker;
1105  			_pPureBackgroundColorPicker = new ColourPicker;
1106  			_pErrorBackgroundColorPicker = new ColourPicker;
1107  			_pTextColorPicker = new ColourPicker;
1108  			_pDarkerTextColorPicker = new ColourPicker;
1109  			_pDisabledTextColorPicker = new ColourPicker;
1110  			_pEdgeColorPicker = new ColourPicker;
1111  			_pLinkColorPicker = new ColourPicker;
1112  			_pHotEdgeColorPicker = new ColourPicker;
1113  			_pDisabledEdgeColorPicker = new ColourPicker;
1114  			_pBackgroundColorPicker->init(_hInst, _hSelf);
1115  			_pSofterBackgroundColorPicker->init(_hInst, _hSelf);
1116  			_pHotBackgroundColorPicker->init(_hInst, _hSelf);
1117  			_pPureBackgroundColorPicker->init(_hInst, _hSelf);
1118  			_pErrorBackgroundColorPicker->init(_hInst, _hSelf);
1119  			_pTextColorPicker->init(_hInst, _hSelf);
1120  			_pDarkerTextColorPicker->init(_hInst, _hSelf);
1121  			_pDisabledTextColorPicker->init(_hInst, _hSelf);
1122  			_pEdgeColorPicker->init(_hInst, _hSelf);
1123  			_pLinkColorPicker->init(_hInst, _hSelf);
1124  			_pHotEdgeColorPicker->init(_hInst, _hSelf);
1125  			_pDisabledEdgeColorPicker->init(_hInst, _hSelf);
1126  			int cpDynamicalWidth = NppParameters::getInstance()._dpiManager.scaleX(25);
1127  			int cpDynamicalHeight = NppParameters::getInstance()._dpiManager.scaleY(25);
1128  			move2CtrlLeft(IDD_CUSTOMIZED_COLOR1_STATIC, _pPureBackgroundColorPicker->getHSelf(), cpDynamicalWidth, cpDynamicalHeight);
1129  			move2CtrlLeft(IDD_CUSTOMIZED_COLOR2_STATIC, _pHotBackgroundColorPicker->getHSelf(), cpDynamicalWidth, cpDynamicalHeight);
1130  			move2CtrlLeft(IDD_CUSTOMIZED_COLOR3_STATIC, _pSofterBackgroundColorPicker->getHSelf(), cpDynamicalWidth, cpDynamicalHeight);
1131  			move2CtrlLeft(IDD_CUSTOMIZED_COLOR4_STATIC, _pBackgroundColorPicker->getHSelf(), cpDynamicalWidth, cpDynamicalHeight);
1132  			move2CtrlLeft(IDD_CUSTOMIZED_COLOR5_STATIC, _pErrorBackgroundColorPicker->getHSelf(), cpDynamicalWidth, cpDynamicalHeight);
1133  			move2CtrlLeft(IDD_CUSTOMIZED_COLOR6_STATIC, _pTextColorPicker->getHSelf(), cpDynamicalWidth, cpDynamicalHeight);
1134  			move2CtrlLeft(IDD_CUSTOMIZED_COLOR7_STATIC, _pDarkerTextColorPicker->getHSelf(), cpDynamicalWidth, cpDynamicalHeight);
1135  			move2CtrlLeft(IDD_CUSTOMIZED_COLOR8_STATIC, _pDisabledTextColorPicker->getHSelf(), cpDynamicalWidth, cpDynamicalHeight);
1136  			move2CtrlLeft(IDD_CUSTOMIZED_COLOR9_STATIC, _pEdgeColorPicker->getHSelf(), cpDynamicalWidth, cpDynamicalHeight);
1137  			move2CtrlLeft(IDD_CUSTOMIZED_COLOR10_STATIC, _pLinkColorPicker->getHSelf(), cpDynamicalWidth, cpDynamicalHeight);
1138  			move2CtrlLeft(IDD_CUSTOMIZED_COLOR11_STATIC, _pHotEdgeColorPicker->getHSelf(), cpDynamicalWidth, cpDynamicalHeight);
1139  			move2CtrlLeft(IDD_CUSTOMIZED_COLOR12_STATIC, _pDisabledEdgeColorPicker->getHSelf(), cpDynamicalWidth, cpDynamicalHeight);
1140  			_pBackgroundColorPicker->display();
1141  			_pSofterBackgroundColorPicker->display();
1142  			_pHotBackgroundColorPicker->display();
1143  			_pPureBackgroundColorPicker->display();
1144  			_pErrorBackgroundColorPicker->display();
1145  			_pTextColorPicker->display();
1146  			_pDarkerTextColorPicker->display();
1147  			_pDisabledTextColorPicker->display();
1148  			_pEdgeColorPicker->display();
1149  			_pLinkColorPicker->display();
1150  			_pHotEdgeColorPicker->display();
1151  			_pDisabledEdgeColorPicker->display();
1152  			::EnableWindow(::GetDlgItem(_hSelf, IDC_RADIO_DARKMODE_BLACK), nppGUI._darkmode._isEnabled);
1153  			::EnableWindow(::GetDlgItem(_hSelf, IDC_RADIO_DARKMODE_RED), nppGUI._darkmode._isEnabled);
1154  			::EnableWindow(::GetDlgItem(_hSelf, IDC_RADIO_DARKMODE_GREEN), nppGUI._darkmode._isEnabled);
1155  			::EnableWindow(::GetDlgItem(_hSelf, IDC_RADIO_DARKMODE_BLUE), nppGUI._darkmode._isEnabled);
1156  			::EnableWindow(::GetDlgItem(_hSelf, IDC_RADIO_DARKMODE_PURPLE), nppGUI._darkmode._isEnabled);
1157  			::EnableWindow(::GetDlgItem(_hSelf, IDC_RADIO_DARKMODE_CYAN), nppGUI._darkmode._isEnabled);
1158  			::EnableWindow(::GetDlgItem(_hSelf, IDC_RADIO_DARKMODE_OLIVE), nppGUI._darkmode._isEnabled);
1159  			::EnableWindow(::GetDlgItem(_hSelf, IDC_RADIO_DARKMODE_CUSTOMIZED), nppGUI._darkmode._isEnabled);
1160  			enableCustomizedColorCtrls(nppGUI._darkmode._isEnabled && id == IDC_RADIO_DARKMODE_CUSTOMIZED);
1161  			return TRUE;
1162  		}
1163  		case WM_CTLCOLORDLG:
1164  		{
1165  			return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
1166  		}
1167  		case WM_CTLCOLORSTATIC:
1168  		{
1169  			auto hdcStatic = reinterpret_cast<HDC>(wParam);
1170  			auto dlgCtrlID = ::GetDlgCtrlID(reinterpret_cast<HWND>(lParam));
1171  			bool isStaticText = (dlgCtrlID == IDD_CUSTOMIZED_COLOR1_STATIC ||
1172  				dlgCtrlID == IDD_CUSTOMIZED_COLOR2_STATIC ||
1173  				dlgCtrlID == IDD_CUSTOMIZED_COLOR3_STATIC ||
1174  				dlgCtrlID == IDD_CUSTOMIZED_COLOR4_STATIC ||
1175  				dlgCtrlID == IDD_CUSTOMIZED_COLOR5_STATIC ||
1176  				dlgCtrlID == IDD_CUSTOMIZED_COLOR6_STATIC ||
1177  				dlgCtrlID == IDD_CUSTOMIZED_COLOR7_STATIC ||
1178  				dlgCtrlID == IDD_CUSTOMIZED_COLOR8_STATIC ||
1179  				dlgCtrlID == IDD_CUSTOMIZED_COLOR9_STATIC ||
1180  				dlgCtrlID == IDD_CUSTOMIZED_COLOR10_STATIC ||
1181  				dlgCtrlID == IDD_CUSTOMIZED_COLOR11_STATIC ||
1182  				dlgCtrlID == IDD_CUSTOMIZED_COLOR12_STATIC);
1183  			if (isStaticText)
1184  			{
1185  				bool isTextEnabled = nppGUI._darkmode._isEnabled && nppGUI._darkmode._colorTone == NppDarkMode::customizedTone;
1186  				return NppDarkMode::onCtlColorDarkerBGStaticText(hdcStatic, isTextEnabled);
1187  			}
1188  			return NppDarkMode::onCtlColorDarker(hdcStatic);
1189  		}
1190  		case WM_PRINTCLIENT:
1191  		{
1192  			if (NppDarkMode::isEnabled())
1193  			{
1194  				return TRUE;
1195  			}
1196  			break;
1197  		}
1198  		case WM_DESTROY:
1199  		{
1200  			_pBackgroundColorPicker->destroy();
1201  			_pSofterBackgroundColorPicker->destroy();
1202  			_pHotBackgroundColorPicker->destroy();
1203  			_pPureBackgroundColorPicker->destroy();
1204  			_pErrorBackgroundColorPicker->destroy();
1205  			_pTextColorPicker->destroy();
1206  			_pDarkerTextColorPicker->destroy();
1207  			_pDisabledTextColorPicker->destroy();
1208  			_pEdgeColorPicker->destroy();
1209  			_pLinkColorPicker->destroy();
1210  			_pHotEdgeColorPicker->destroy();
1211  			_pDisabledEdgeColorPicker->destroy();
1212  			delete _pBackgroundColorPicker;
1213  			delete _pSofterBackgroundColorPicker;
1214  			delete _pHotBackgroundColorPicker;
1215  			delete _pPureBackgroundColorPicker;
1216  			delete _pErrorBackgroundColorPicker;
1217  			delete _pTextColorPicker;
1218  			delete _pDarkerTextColorPicker;
1219  			delete _pDisabledTextColorPicker;
1220  			delete _pEdgeColorPicker;
1221  			delete _pLinkColorPicker;
1222  			delete _pHotEdgeColorPicker;
1223  			delete _pDisabledEdgeColorPicker;
1224  			return TRUE;
1225  		}
1226  		case WM_COMMAND:
1227  		{
1228  			bool changed = false;
1229  			bool forceRefresh = false;
1230  			bool doEnableCustomizedColorCtrls = false;
1231  			switch (wParam)
1232  			{
1233  				case IDC_RADIO_DARKMODE_FOLLOWWINDOWS:
1234  				{
1235  					NppDarkMode::handleSettingChange(nullptr, 0, true);
1236  				}
1237  				[[fallthrough]];
1238  				case IDC_RADIO_DARKMODE_LIGHTMODE:
1239  				case IDC_RADIO_DARKMODE_DARKMODE:
1240  				{
1241  					const bool isFollowWindows = isCheckedOrNot(IDC_RADIO_DARKMODE_FOLLOWWINDOWS);
1242  					NppDarkMode::setWindowsMode(isFollowWindows);
1243  					const bool enableDarkMode = isCheckedOrNot(IDC_RADIO_DARKMODE_DARKMODE) || (isFollowWindows && NppDarkMode::isExperimentalActive());
1244  					nppGUI._darkmode._isEnabled = enableDarkMode;
1245  					::EnableWindow(::GetDlgItem(_hSelf, IDC_RADIO_DARKMODE_BLACK), enableDarkMode);
1246  					::EnableWindow(::GetDlgItem(_hSelf, IDC_RADIO_DARKMODE_RED), enableDarkMode);
1247  					::EnableWindow(::GetDlgItem(_hSelf, IDC_RADIO_DARKMODE_GREEN), enableDarkMode);
1248  					::EnableWindow(::GetDlgItem(_hSelf, IDC_RADIO_DARKMODE_BLUE), enableDarkMode);
1249  					::EnableWindow(::GetDlgItem(_hSelf, IDC_RADIO_DARKMODE_PURPLE), enableDarkMode);
1250  					::EnableWindow(::GetDlgItem(_hSelf, IDC_RADIO_DARKMODE_CYAN), enableDarkMode);
1251  					::EnableWindow(::GetDlgItem(_hSelf, IDC_RADIO_DARKMODE_OLIVE), enableDarkMode);
1252  					::EnableWindow(::GetDlgItem(_hSelf, IDC_RADIO_DARKMODE_CUSTOMIZED), enableDarkMode);
1253  					doEnableCustomizedColorCtrls = enableDarkMode && nppGUI._darkmode._colorTone == NppDarkMode::customizedTone;
1254  					enableCustomizedColorCtrls(doEnableCustomizedColorCtrls);
1255  					::SendMessage(_hParent, PREF_MSG_SETGUITOOLICONSSET, static_cast<WPARAM>(enableDarkMode), 0);
1256  					::SendMessage(_hParent, PREF_MSG_SETGUITABBARICONS, static_cast<WPARAM>(enableDarkMode), 0);
1257  					changed = true;
1258  				}
1259  				break;
1260  				case IDC_RADIO_DARKMODE_BLACK:
1261  				case IDC_RADIO_DARKMODE_RED:
1262  				case IDC_RADIO_DARKMODE_GREEN:
1263  				case IDC_RADIO_DARKMODE_BLUE:
1264  				case IDC_RADIO_DARKMODE_PURPLE:
1265  				case IDC_RADIO_DARKMODE_CYAN:
1266  				case IDC_RADIO_DARKMODE_OLIVE:
1267  				case IDC_RADIO_DARKMODE_CUSTOMIZED:
1268  				case IDD_CUSTOMIZED_RESET_BUTTON:
1269  				{
1270  					if (wParam == IDC_RADIO_DARKMODE_BLACK)
1271  					{
1272  						if (nppGUI._darkmode._colorTone == NppDarkMode::blackTone)
1273  							return TRUE;
1274  						nppGUI._darkmode._colorTone = NppDarkMode::blackTone;
1275  					}
1276  					else if (wParam == IDC_RADIO_DARKMODE_RED)
1277  					{
1278  						if (nppGUI._darkmode._colorTone == NppDarkMode::redTone)
1279  							return TRUE;
1280  						nppGUI._darkmode._colorTone = NppDarkMode::redTone;
1281  					}
1282  					else if (wParam == IDC_RADIO_DARKMODE_GREEN)
1283  					{
1284  						if (nppGUI._darkmode._colorTone == NppDarkMode::greenTone)
1285  							return TRUE;
1286  						nppGUI._darkmode._colorTone = NppDarkMode::greenTone;
1287  					}
1288  					else if (wParam == IDC_RADIO_DARKMODE_BLUE)
1289  					{
1290  						if (nppGUI._darkmode._colorTone == NppDarkMode::blueTone)
1291  							return TRUE;
1292  						nppGUI._darkmode._colorTone = NppDarkMode::blueTone;
1293  					}
1294  					else if (wParam == IDC_RADIO_DARKMODE_PURPLE)
1295  					{
1296  						if (nppGUI._darkmode._colorTone == NppDarkMode::purpleTone)
1297  							return TRUE;
1298  						nppGUI._darkmode._colorTone = NppDarkMode::purpleTone;
1299  					}
1300  					else if (wParam == IDC_RADIO_DARKMODE_CYAN)
1301  					{
1302  						if (nppGUI._darkmode._colorTone == NppDarkMode::cyanTone)
1303  							return TRUE;
1304  						nppGUI._darkmode._colorTone = NppDarkMode::cyanTone;
1305  					}
1306  					else if (wParam == IDC_RADIO_DARKMODE_OLIVE)
1307  					{
1308  						if (nppGUI._darkmode._colorTone == NppDarkMode::oliveTone)
1309  							return TRUE;
1310  						nppGUI._darkmode._colorTone = NppDarkMode::oliveTone;
1311  					}
1312  					else if (wParam == IDC_RADIO_DARKMODE_CUSTOMIZED)
1313  					{
1314  						if (nppGUI._darkmode._colorTone == NppDarkMode::customizedTone)
1315  							return TRUE;
1316  						nppGUI._darkmode._colorTone = NppDarkMode::customizedTone;
1317  						doEnableCustomizedColorCtrls = true;
1318  					}
1319  					else if (wParam == IDD_CUSTOMIZED_RESET_BUTTON)
1320  					{
1321  						nppGUI._darkmode._customColors = NppDarkMode::getDarkModeDefaultColors();
1322  						NppDarkMode::changeCustomTheme(nppGUI._darkmode._customColors);
1323  						doEnableCustomizedColorCtrls = true;
1324  					}
1325  					nppGUI._darkmode._isEnabled = true;
1326  					NppDarkMode::setDarkTone(nppGUI._darkmode._colorTone);
1327  					changed = true;
1328  					forceRefresh = true;
1329  					enableCustomizedColorCtrls(doEnableCustomizedColorCtrls);
1330  				}
1331  				break;
1332  				default:
1333  					switch (HIWORD(wParam))
1334  					{
1335  						case CPN_COLOURPICKED:
1336  						{
1337  							COLORREF c = 0;
1338  							if (reinterpret_cast<HWND>(lParam) == _pBackgroundColorPicker->getHSelf())
1339  							{
1340  								c = _pBackgroundColorPicker->getColour();
1341  								NppDarkMode::setBackgroundColor(c);
1342  								nppGUI._darkmode._customColors.background = c;
1343  							}
1344  							else if (reinterpret_cast<HWND>(lParam) == _pSofterBackgroundColorPicker->getHSelf())
1345  							{
1346  								c = _pSofterBackgroundColorPicker->getColour();
1347  								NppDarkMode::setSofterBackgroundColor(c);
1348  								nppGUI._darkmode._customColors.softerBackground = c;
1349  							}
1350  							else if (reinterpret_cast<HWND>(lParam) == _pHotBackgroundColorPicker->getHSelf())
1351  							{
1352  								c = _pHotBackgroundColorPicker->getColour();
1353  								NppDarkMode::setHotBackgroundColor(c);
1354  								nppGUI._darkmode._customColors.hotBackground = c;
1355  							}
1356  							else if (reinterpret_cast<HWND>(lParam) == _pPureBackgroundColorPicker->getHSelf())
1357  							{
1358  								c = _pPureBackgroundColorPicker->getColour();
1359  								NppDarkMode::setDarkerBackgroundColor(c);
1360  								nppGUI._darkmode._customColors.pureBackground = c;
1361  							}
1362  							else if (reinterpret_cast<HWND>(lParam) == _pErrorBackgroundColorPicker->getHSelf())
1363  							{
1364  								c = _pErrorBackgroundColorPicker->getColour();
1365  								NppDarkMode::setErrorBackgroundColor(c);
1366  								nppGUI._darkmode._customColors.errorBackground = c;
1367  							}
1368  							else if (reinterpret_cast<HWND>(lParam) == _pTextColorPicker->getHSelf())
1369  							{
1370  								c = _pTextColorPicker->getColour();
1371  								NppDarkMode::setTextColor(c);
1372  								nppGUI._darkmode._customColors.text = c;
1373  							}
1374  							else if (reinterpret_cast<HWND>(lParam) == _pDarkerTextColorPicker->getHSelf())
1375  							{
1376  								c = _pDarkerTextColorPicker->getColour();
1377  								NppDarkMode::setDarkerTextColor(c);
1378  								nppGUI._darkmode._customColors.darkerText = c;
1379  							}
1380  							else if (reinterpret_cast<HWND>(lParam) == _pDisabledTextColorPicker->getHSelf())
1381  							{
1382  								c = _pDisabledTextColorPicker->getColour();
1383  								NppDarkMode::setDisabledTextColor(c);
1384  								nppGUI._darkmode._customColors.disabledText = c;
1385  							}
1386  							else if (reinterpret_cast<HWND>(lParam) == _pEdgeColorPicker->getHSelf())
1387  							{
1388  								c = _pEdgeColorPicker->getColour();
1389  								NppDarkMode::setEdgeColor(c);
1390  								nppGUI._darkmode._customColors.edge = c;
1391  							}
1392  							else if (reinterpret_cast<HWND>(lParam) == _pLinkColorPicker->getHSelf())
1393  							{
1394  								c = _pLinkColorPicker->getColour();
1395  								NppDarkMode::setLinkTextColor(c);
1396  								nppGUI._darkmode._customColors.linkText = c;
1397  							}
1398  							else if (reinterpret_cast<HWND>(lParam) == _pHotEdgeColorPicker->getHSelf())
1399  							{
1400  								c = _pHotEdgeColorPicker->getColour();
1401  								NppDarkMode::setHotEdgeColor(c);
1402  								nppGUI._darkmode._customColors.hotEdge = c;
1403  							}
1404  							else if (reinterpret_cast<HWND>(lParam) == _pDisabledEdgeColorPicker->getHSelf())
1405  							{
1406  								c = _pDisabledEdgeColorPicker->getColour();
1407  								NppDarkMode::setDisabledEdgeColor(c);
1408  								nppGUI._darkmode._customColors.disabledEdge = c;
1409  							}
1410  							else
1411  							{
1412  								return FALSE;
1413  							}
1414  							nppGUI._darkmode._isEnabled = true;
1415  							NppDarkMode::setDarkTone(nppGUI._darkmode._colorTone);
1416  							changed = true;
1417  							forceRefresh = true;
1418  							doEnableCustomizedColorCtrls = true;
1419  						}
1420  						break;
1421  						default:
1422  						{
1423  							return FALSE;
1424  						}
1425  					}
1426  			}
1427  			if (changed)
1428  			{
1429  				if (!doEnableCustomizedColorCtrls)
1430  				{
1431  					COLORREF disabledColor = nppGUI._darkmode._isEnabled ? NppDarkMode::getDarkerBackgroundColor() : ::GetSysColor(COLOR_3DFACE);
1432  					_pBackgroundColorPicker->setColour(disabledColor);
1433  					_pSofterBackgroundColorPicker->setColour(disabledColor);
1434  					_pHotBackgroundColorPicker->setColour(disabledColor);
1435  					_pPureBackgroundColorPicker->setColour(disabledColor);
1436  					_pErrorBackgroundColorPicker->setColour(disabledColor);
1437  					_pTextColorPicker->setColour(disabledColor);
1438  					_pDarkerTextColorPicker->setColour(disabledColor);
1439  					_pDisabledTextColorPicker->setColour(disabledColor);
1440  					_pEdgeColorPicker->setColour(disabledColor);
1441  					_pLinkColorPicker->setColour(disabledColor);
1442  					_pHotEdgeColorPicker->setColour(disabledColor);
1443  					_pDisabledEdgeColorPicker->setColour(disabledColor);
1444  				}
1445  				NppDarkMode::refreshDarkMode(_hSelf, forceRefresh);
1446  				getFocus(); 
1447  				return TRUE;
1448  			}
1449  			return FALSE;
1450  		}
1451  	}
1452  	return FALSE;
1453  }
1454  void MarginsBorderEdgeSubDlg::initScintParam()
1455  {
1456  	NppParameters& nppParam = NppParameters::getInstance();
1457  	ScintillaViewParams & svp = const_cast<ScintillaViewParams &>(nppParam.getSVP());
1458  	::SendDlgItemMessage(_hSelf, IDC_RADIO_BOX, BM_SETCHECK, FALSE, 0);
1459  	::SendDlgItemMessage(_hSelf, IDC_RADIO_CIRCLE, BM_SETCHECK, FALSE, 0);
1460  	::SendDlgItemMessage(_hSelf, IDC_RADIO_ARROW, BM_SETCHECK, FALSE, 0);
1461  	::SendDlgItemMessage(_hSelf, IDC_RADIO_SIMPLE, BM_SETCHECK, FALSE, 0);
1462  	::SendDlgItemMessage(_hSelf, IDC_RADIO_FOLDMARGENONE, BM_SETCHECK, FALSE, 0);
1463  	int id = 0;
1464  	switch (svp._folderStyle)
1465  	{
1466  		case FOLDER_STYLE_NONE:
1467  			id = IDC_RADIO_FOLDMARGENONE;
1468  			break;
1469  		case FOLDER_STYLE_BOX:
1470  			id = IDC_RADIO_BOX;
1471  			break;
1472  		case FOLDER_STYLE_CIRCLE:
1473  			id = IDC_RADIO_CIRCLE;
1474  			break;
1475  		case FOLDER_STYLE_ARROW:
1476  			id = IDC_RADIO_ARROW;
1477  			break;
1478  		default : 
1479  			id = IDC_RADIO_SIMPLE;
1480  	}
1481  	::SendDlgItemMessage(_hSelf, id, BM_SETCHECK, TRUE, 0);
1482  	::SendDlgItemMessage(_hSelf, IDC_CHECK_LINENUMBERMARGE, BM_SETCHECK, svp._lineNumberMarginShow, 0);
1483  	::SendDlgItemMessage(_hSelf, IDC_RADIO_DYNAMIC, BM_SETCHECK, svp._lineNumberMarginDynamicWidth, 0);
1484  	::SendDlgItemMessage(_hSelf, IDC_RADIO_CONSTANT, BM_SETCHECK, !svp._lineNumberMarginDynamicWidth, 0);
1485  	::EnableWindow(::GetDlgItem(_hSelf, IDC_RADIO_DYNAMIC), svp._lineNumberMarginShow);
1486  	::EnableWindow(::GetDlgItem(_hSelf, IDC_RADIO_CONSTANT), svp._lineNumberMarginShow);
1487  	::SendDlgItemMessage(_hSelf, IDC_CHECK_BOOKMARKMARGE, BM_SETCHECK, svp._bookMarkMarginShow, 0);
1488  	::SendDlgItemMessage(_hSelf, IDC_CHECK_CHANGHISTORYMARGE, BM_SETCHECK, svp._isChangeHistoryEnabled, 0);
1489  	::SendDlgItemMessage(_hSelf, IDC_CHECK_NOEDGE, BM_SETCHECK, !svp._showBorderEdge, 0);
1490  	bool canBeBg = svp._edgeMultiColumnPos.size() == 1;
1491  	if (!canBeBg)
1492  	{
1493  		svp._isEdgeBgMode = false;
1494  		::SendDlgItemMessage(_hSelf, IDC_CHECK_EDGEBGMODE, BM_SETCHECK, FALSE, 0);
1495  		::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_EDGEBGMODE), FALSE);
1496  	}
1497  	else
1498  	{
1499  		::SendDlgItemMessage(_hSelf, IDC_CHECK_EDGEBGMODE, BM_SETCHECK, svp._isEdgeBgMode, 0);
1500  	}
1501  	generic_string edgeColumnPosStr;
1502  	for (auto i : svp._edgeMultiColumnPos)
1503  	{
1504  		std::string s = std::to_string(i);
1505  		edgeColumnPosStr += generic_string(s.begin(), s.end());
1506  		edgeColumnPosStr += TEXT(" ");
1507  	}
1508  	::SendDlgItemMessage(_hSelf, IDC_COLUMNPOS_EDIT, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(edgeColumnPosStr.c_str()));
1509  	oldFunclstToolbarProc = reinterpret_cast<WNDPROC>(::SetWindowLongPtr(::GetDlgItem(_hSelf, IDC_COLUMNPOS_EDIT), GWLP_WNDPROC, reinterpret_cast<LONG_PTR>(editNumSpaceProc)));
1510  }
1511  intptr_t CALLBACK MarginsBorderEdgeSubDlg::run_dlgProc(UINT message, WPARAM wParam, LPARAM lParam)
1512  {
1513  	NppParameters& nppParam = NppParameters::getInstance();
1514  	switch (message) 
1515  	{
1516  		case WM_INITDIALOG :
1517  		{
1518  			const ScintillaViewParams & svp = nppParam.getSVP();
1519  			::SendMessage(::GetDlgItem(_hSelf, IDC_BORDERWIDTH_SLIDER),TBM_SETRANGEMIN, TRUE, BORDERWIDTH_SMALLEST);
1520  			::SendMessage(::GetDlgItem(_hSelf, IDC_BORDERWIDTH_SLIDER),TBM_SETRANGEMAX, TRUE, BORDERWIDTH_LARGEST);
1521  			::SendMessage(::GetDlgItem(_hSelf, IDC_BORDERWIDTH_SLIDER),TBM_SETPAGESIZE, 0, BORDERWIDTH_INTERVAL);
1522  			::SendMessage(::GetDlgItem(_hSelf, IDC_BORDERWIDTH_SLIDER),TBM_SETPOS, TRUE, svp._borderWidth);
1523  			::SetDlgItemInt(_hSelf, IDC_BORDERWIDTHVAL_STATIC, svp._borderWidth, FALSE);
1524  			::SendMessage(::GetDlgItem(_hSelf, IDC_PADDINGLEFT_SLIDER), TBM_SETRANGEMIN, TRUE, PADDING_SMALLEST);
1525  			::SendMessage(::GetDlgItem(_hSelf, IDC_PADDINGLEFT_SLIDER), TBM_SETRANGEMAX, TRUE, PADDING_LARGEST);
1526  			::SendMessage(::GetDlgItem(_hSelf, IDC_PADDINGLEFT_SLIDER), TBM_SETPAGESIZE, 0, PADDING_INTERVAL);
1527  			::SendMessage(::GetDlgItem(_hSelf, IDC_PADDINGLEFT_SLIDER), TBM_SETPOS, TRUE, svp._paddingLeft);
1528  			::SetDlgItemInt(_hSelf, IDC_PADDINGLEFTVAL_STATIC, svp._paddingLeft, FALSE);
1529  			::SendMessage(::GetDlgItem(_hSelf, IDC_PADDINGRIGHT_SLIDER), TBM_SETRANGEMIN, TRUE, PADDING_SMALLEST);
1530  			::SendMessage(::GetDlgItem(_hSelf, IDC_PADDINGRIGHT_SLIDER), TBM_SETRANGEMAX, TRUE, PADDING_LARGEST);
1531  			::SendMessage(::GetDlgItem(_hSelf, IDC_PADDINGRIGHT_SLIDER), TBM_SETPAGESIZE, 0, PADDING_INTERVAL);
1532  			::SendMessage(::GetDlgItem(_hSelf, IDC_PADDINGRIGHT_SLIDER), TBM_SETPOS, TRUE, svp._paddingRight);
1533  			::SetDlgItemInt(_hSelf, IDC_PADDINGRIGHTVAL_STATIC, svp._paddingRight, FALSE);
1534  			::SendMessage(::GetDlgItem(_hSelf, IDC_DISTRACTIONFREE_SLIDER), TBM_SETRANGEMIN, TRUE, DISTRACTIONFREE_SMALLEST);
1535  			::SendMessage(::GetDlgItem(_hSelf, IDC_DISTRACTIONFREE_SLIDER), TBM_SETRANGEMAX, TRUE, DISTRACTIONFREE_LARGEST);
1536  			::SendMessage(::GetDlgItem(_hSelf, IDC_DISTRACTIONFREE_SLIDER), TBM_SETPAGESIZE, 0, DISTRACTIONFREE_INTERVAL);
1537  			::SendMessage(::GetDlgItem(_hSelf, IDC_DISTRACTIONFREE_SLIDER), TBM_SETPOS, TRUE, svp._distractionFreeDivPart);
1538  			::SetDlgItemInt(_hSelf, IDC_DISTRACTIONFREEVAL_STATIC, svp._distractionFreeDivPart, FALSE);
1539  			initScintParam();
1540  			return TRUE;
1541  		}
1542  		case WM_CTLCOLOREDIT:
1543  		{
1544  			return NppDarkMode::onCtlColorSofter(reinterpret_cast<HDC>(wParam));
1545  		}
1546  		case WM_CTLCOLORDLG:
1547  		case WM_CTLCOLORSTATIC:
1548  		{
1549  			return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
1550  		}
1551  		case WM_PRINTCLIENT:
1552  		{
1553  			if (NppDarkMode::isEnabled())
1554  			{
1555  				return TRUE;
1556  			}
1557  			break;
1558  		}
1559  		case WM_HSCROLL:
1560  		{
1561  			ScintillaViewParams & svp = (ScintillaViewParams &)nppParam.getSVP();
1562  			HWND hBorderWidthSlider = ::GetDlgItem(_hSelf, IDC_BORDERWIDTH_SLIDER);
1563  			HWND hPaddingLeftSlider = ::GetDlgItem(_hSelf, IDC_PADDINGLEFT_SLIDER);
1564  			HWND hPaddingRightSlider = ::GetDlgItem(_hSelf, IDC_PADDINGRIGHT_SLIDER);
1565  			HWND hDistractionFreeSlider = ::GetDlgItem(_hSelf, IDC_DISTRACTIONFREE_SLIDER);
1566  			if (reinterpret_cast<HWND>(lParam) == hBorderWidthSlider)
1567  			{
1568  				auto borderWidth = ::SendMessage(hBorderWidthSlider, TBM_GETPOS, 0, 0);
1569  				svp._borderWidth = static_cast<int>(borderWidth);
1570  				::SetDlgItemInt(_hSelf, IDC_BORDERWIDTHVAL_STATIC, static_cast<UINT>(borderWidth), FALSE);
1571  				::SendMessage(::GetParent(_hParent), WM_SIZE, 0, 0);
1572  			}
1573  			else if (reinterpret_cast<HWND>(lParam) == hPaddingLeftSlider)
1574  			{
1575  				svp._paddingLeft = static_cast<unsigned char>(::SendMessage(hPaddingLeftSlider, TBM_GETPOS, 0, 0));
1576  				::SetDlgItemInt(_hSelf, IDC_PADDINGLEFTVAL_STATIC, static_cast<UINT>(svp._paddingLeft), FALSE);
1577  				::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_UPDATETEXTZONEPADDING, 0, 0);
1578  			}
1579  			else if (reinterpret_cast<HWND>(lParam) == hPaddingRightSlider)
1580  			{
1581  				svp._paddingRight = static_cast<unsigned char>(::SendMessage(hPaddingRightSlider, TBM_GETPOS, 0, 0));
1582  				::SetDlgItemInt(_hSelf, IDC_PADDINGRIGHTVAL_STATIC, static_cast<UINT>(svp._paddingRight), FALSE);
1583  				::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_UPDATETEXTZONEPADDING, 0, 0);
1584  			}
1585  			else if (reinterpret_cast<HWND>(lParam) == hDistractionFreeSlider)
1586  			{
1587  				svp._distractionFreeDivPart = static_cast<unsigned char>(::SendMessage(hDistractionFreeSlider, TBM_GETPOS, 0, 0));
1588  				::SetDlgItemInt(_hSelf, IDC_DISTRACTIONFREEVAL_STATIC, static_cast<UINT>(svp._distractionFreeDivPart), FALSE);
1589  				::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_UPDATETEXTZONEPADDING, 0, 0);
1590  			}
1591  			return 0;	
1592  		}
1593  		case WM_COMMAND : 
1594  		{
1595  			ScintillaViewParams & svp = const_cast<ScintillaViewParams &>(nppParam.getSVP());
1596  			switch (wParam)
1597  			{
1598  				case IDC_CHECK_LINENUMBERMARGE:
1599  					svp._lineNumberMarginShow = (BST_CHECKED == ::SendDlgItemMessage(_hSelf, IDC_CHECK_LINENUMBERMARGE, BM_GETCHECK, 0, 0));
1600  					::EnableWindow(::GetDlgItem(_hSelf, IDC_RADIO_DYNAMIC), svp._lineNumberMarginShow);
1601  					::EnableWindow(::GetDlgItem(_hSelf, IDC_RADIO_CONSTANT), svp._lineNumberMarginShow);
1602  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_LINENUMBER, 0);
1603  					return TRUE;
1604  				case IDC_RADIO_DYNAMIC:
1605  					svp._lineNumberMarginDynamicWidth = (BST_CHECKED == ::SendDlgItemMessage(_hSelf, IDC_RADIO_DYNAMIC, BM_GETCHECK, 0, 0));
1606  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_LINENUMBER, 0);
1607  					return TRUE;
1608  				case IDC_RADIO_CONSTANT:
1609  					svp._lineNumberMarginDynamicWidth = !(BST_CHECKED == ::SendDlgItemMessage(_hSelf, IDC_RADIO_CONSTANT, BM_GETCHECK, 0, 0));
1610  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_LINENUMBER, 0);
1611  					return TRUE;
1612  				case IDC_CHECK_BOOKMARKMARGE:
1613  					svp._bookMarkMarginShow = (BST_CHECKED == ::SendDlgItemMessage(_hSelf, IDC_CHECK_BOOKMARKMARGE, BM_GETCHECK, 0, 0));
1614  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_SYMBOLMARGIN, 0);
1615  					return TRUE;
1616  				case IDC_CHECK_CHANGHISTORYMARGE:
1617  				{
1618  					bool isChangeHistoryEnabled = (BST_CHECKED == ::SendDlgItemMessage(_hSelf, IDC_CHECK_CHANGHISTORYMARGE, BM_GETCHECK, 0, 0));
1619  					if (isChangeHistoryEnabled)
1620  					{
1621  						NativeLangSpeaker* pNativeSpeaker = nppParam.getNativeLangSpeaker();
1622  						pNativeSpeaker->messageBox("ChangeHistoryEnabledWarning",
1623  							_hSelf,
1624  							TEXT("You have to restart Notepad++ to enable Change History."),
1625  							TEXT("Notepad++ need to be relaunched"),
1626  							MB_OK | MB_APPLMODAL);
1627  						svp._isChangeHistoryEnabled4NextSession = true;
1628  					}
1629  					else
1630  					{
1631  						svp._isChangeHistoryEnabled = false;
1632  						svp._isChangeHistoryEnabled4NextSession = false;
1633  						::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_ENABLECHANGEHISTORY, 0, 0);
1634  					}
1635  					return TRUE;
1636  				}
1637  				case IDC_CHECK_NOEDGE:
1638  					svp._showBorderEdge = !(BST_CHECKED == ::SendDlgItemMessage(_hSelf, IDC_CHECK_NOEDGE, BM_GETCHECK, 0, 0));
1639  					::SendMessage(::GetParent(_hParent), NPPM_SETEDITORBORDEREDGE, 0, svp._showBorderEdge ? TRUE : FALSE);
1640  					return TRUE;
1641  				case IDC_RADIO_SIMPLE:
1642  					svp._folderStyle = FOLDER_STYLE_SIMPLE;
1643  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_FOLDERMAGIN_SIMPLE, 0);
1644  					return TRUE;
1645  				case IDC_RADIO_ARROW:
1646  					svp._folderStyle = FOLDER_STYLE_ARROW;
1647  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_FOLDERMAGIN_ARROW, 0);
1648  					return TRUE;
1649  				case IDC_RADIO_CIRCLE:
1650  					svp._folderStyle = FOLDER_STYLE_CIRCLE;
1651  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_FOLDERMAGIN_CIRCLE, 0);
1652  					return TRUE;
1653  				case IDC_RADIO_BOX:
1654  					svp._folderStyle = FOLDER_STYLE_BOX;
1655  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_FOLDERMAGIN_BOX, 0);
1656  					return TRUE;
1657  				case IDC_RADIO_FOLDMARGENONE:
1658  					svp._folderStyle = FOLDER_STYLE_NONE;
1659  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_FOLDERMAGIN, 0);
1660  					return TRUE;
1661  				case IDC_CHECK_EDGEBGMODE:
1662  					svp._isEdgeBgMode = isCheckedOrNot(IDC_CHECK_EDGEBGMODE);
1663  					::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_EDGEMULTISETSIZE, 0, 0);
1664  					return TRUE;
1665  				default :
1666  					switch (HIWORD(wParam))
1667  					{
1668  						case EN_CHANGE :
1669  						{
1670  							if (LOWORD(wParam) == IDC_COLUMNPOS_EDIT)
1671  							{
1672  								TCHAR text[MAX_PATH] = {'\0'};
1673  								::SendDlgItemMessage(_hSelf, IDC_COLUMNPOS_EDIT, WM_GETTEXT, MAX_PATH, reinterpret_cast<LPARAM>(text));
1674  								if (str2numberVector(text, svp._edgeMultiColumnPos))
1675  								{
1676  									bool canBeBg = svp._edgeMultiColumnPos.size() == 1;
1677  									if (!canBeBg)
1678  									{
1679  										svp._isEdgeBgMode = false;
1680  										::SendDlgItemMessage(_hSelf, IDC_CHECK_EDGEBGMODE, BM_SETCHECK, FALSE, 0);
1681  									}
1682  									::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_EDGEBGMODE), canBeBg);
1683  									::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_EDGEMULTISETSIZE, 0, 0);
1684  									return TRUE;
1685  								}
1686  							}
1687  						}
1688  						break;
1689  					}
1690  			}
1691  		}
1692  	}
1693  	return FALSE;
1694  }
1695  const size_t fileUpdateChoiceEnable = 0;
1696  const size_t fileUpdateChoiceEnable4All = 1;
1697  const size_t fileUpdateChoiceDisable = 2;
1698  intptr_t CALLBACK MiscSubDlg::run_dlgProc(UINT message, WPARAM wParam, LPARAM)
1699  {
1700  	NppParameters& nppParam = NppParameters::getInstance();
1701  	NppGUI & nppGUI = nppParam.getNppGUI();
1702  	switch (message) 
1703  	{
1704  		case WM_INITDIALOG :
1705  		{
1706  			::SendDlgItemMessage(_hSelf, IDC_COMBO_FILEUPDATECHOICE, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(TEXT("Enable")));
1707  			::SendDlgItemMessage(_hSelf, IDC_COMBO_FILEUPDATECHOICE, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(TEXT("Enable for all opened files")));
1708  			::SendDlgItemMessage(_hSelf, IDC_COMBO_FILEUPDATECHOICE, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(TEXT("Disable")));
1709  			int selIndex = -1;
1710  			if (nppGUI._fileAutoDetection & cdEnabledOld)
1711  			{
1712  				selIndex = fileUpdateChoiceEnable4All;
1713  			}
1714  			else if (nppGUI._fileAutoDetection & cdEnabledNew)
1715  			{				
1716  				selIndex = fileUpdateChoiceEnable;
1717  			}
1718  			else 
1719  			{
1720  				::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_UPDATESILENTLY), FALSE);
1721  				::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_UPDATEGOTOEOF), FALSE);
1722  				selIndex = fileUpdateChoiceDisable;
1723  			}
1724  			::SendDlgItemMessage(_hSelf, IDC_COMBO_FILEUPDATECHOICE, CB_SETCURSEL, selIndex, 0);
1725  			bool bCheck = (nppGUI._fileAutoDetection & cdAutoUpdate) ? true : false;
1726  			::SendDlgItemMessage(_hSelf, IDC_CHECK_UPDATESILENTLY, BM_SETCHECK, bCheck? BST_CHECKED: BST_UNCHECKED, 0);
1727  			bCheck = (nppGUI._fileAutoDetection & cdGo2end) ? true : false;
1728  			::SendDlgItemMessage(_hSelf, IDC_CHECK_UPDATEGOTOEOF, BM_SETCHECK, bCheck ? BST_CHECKED : BST_UNCHECKED, 0);
1729  			::SendDlgItemMessage(_hSelf, IDC_CHECK_MIN2SYSTRAY, BM_SETCHECK, nppGUI._isMinimizedToTray, 0);
1730  			::SendDlgItemMessage(_hSelf, IDC_CHECK_DETECTENCODING, BM_SETCHECK, nppGUI._detectEncoding, 0);
1731  			::SendDlgItemMessage(_hSelf, IDC_CHECK_SAVEALLCONFIRM, BM_SETCHECK, nppGUI._saveAllConfirm, 0);
1732  			::SendDlgItemMessage(_hSelf, IDC_CHECK_AUTOUPDATE, BM_SETCHECK, nppGUI._autoUpdateOpt._doAutoUpdate, 0);
1733  			::SendDlgItemMessage(_hSelf, IDC_CHECK_DIRECTWRITE_ENABLE, BM_SETCHECK, nppGUI._writeTechnologyEngine == directWriteTechnology, 0);
1734  			::SendDlgItemMessage(_hSelf, IDC_CHECK_ENABLEDOCPEEKER, BM_SETCHECK, nppGUI._isDocPeekOnTab ? BST_CHECKED : BST_UNCHECKED, 0);
1735  			::SendDlgItemMessage(_hSelf, IDC_CHECK_ENABLEDOCPEEKONMAP, BM_SETCHECK, nppGUI._isDocPeekOnMap ? BST_CHECKED : BST_UNCHECKED, 0);
1736  			::SendDlgItemMessage(_hSelf, IDC_CHECK_MUTE_SOUNDS, BM_SETCHECK, nppGUI._muteSounds ? BST_CHECKED : BST_UNCHECKED, 0);
1737  			::ShowWindow(::GetDlgItem(_hSelf, IDC_CHECK_AUTOUPDATE), nppGUI._doesExistUpdater?SW_SHOW:SW_HIDE);
1738  			::SendDlgItemMessage(_hSelf, IDC_EDIT_SESSIONFILEEXT, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(nppGUI._definedSessionExt.c_str()));
1739  			::SendDlgItemMessage(_hSelf, IDC_EDIT_WORKSPACEFILEEXT, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(nppGUI._definedWorkspaceExt.c_str()));
1740  			::SendDlgItemMessage(_hSelf, IDC_CHECK_ENABLEDOCSWITCHER, BM_SETCHECK, nppGUI._doTaskList, 0);
1741  			::SendDlgItemMessage(_hSelf, IDC_CHECK_STYLEMRU, BM_SETCHECK, nppGUI._styleMRU, 0);
1742  			::SendDlgItemMessage(_hSelf, IDC_CHECK_SHORTTITLE, BM_SETCHECK, nppGUI._shortTitlebar, 0);
1743  			return TRUE;
1744  		}
1745  		case WM_CTLCOLOREDIT:
1746  		{
1747  			return NppDarkMode::onCtlColorSofter(reinterpret_cast<HDC>(wParam));
1748  		}
1749  		case WM_CTLCOLORLISTBOX:
1750  		{
1751  			return NppDarkMode::onCtlColor(reinterpret_cast<HDC>(wParam));
1752  		}
1753  		case WM_CTLCOLORDLG:
1754  		case WM_CTLCOLORSTATIC:
1755  		{
1756  			return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
1757  		}
1758  		case WM_PRINTCLIENT:
1759  		{
1760  			if (NppDarkMode::isEnabled())
1761  			{
1762  				return TRUE;
1763  			}
1764  			break;
1765  		}
1766  		case WM_COMMAND : 
1767  		{
1768  			if (HIWORD(wParam) == EN_CHANGE)
1769  			{
1770  				switch (LOWORD(wParam))
1771  				{
1772  					case  IDC_EDIT_SESSIONFILEEXT:
1773  					{
1774  						TCHAR sessionExt[MAX_PATH] = { '\0' };
1775  						::SendDlgItemMessage(_hSelf, IDC_EDIT_SESSIONFILEEXT, WM_GETTEXT, MAX_PATH, reinterpret_cast<LPARAM>(sessionExt));
1776  						nppGUI._definedSessionExt = sessionExt;
1777  						return TRUE;
1778  					}
1779  					case  IDC_EDIT_WORKSPACEFILEEXT:
1780  					{
1781  						TCHAR workspaceExt[MAX_PATH] = { '\0' };
1782  						::SendDlgItemMessage(_hSelf, IDC_EDIT_WORKSPACEFILEEXT, WM_GETTEXT, MAX_PATH, reinterpret_cast<LPARAM>(workspaceExt));
1783  						nppGUI._definedWorkspaceExt = workspaceExt;
1784  						return TRUE;
1785  					}
1786  				}
1787  			}
1788  			switch (wParam)
1789  			{
1790  				case IDC_CHECK_UPDATESILENTLY:
1791  				case IDC_CHECK_UPDATEGOTOEOF:
1792  				{
1793  					bool isSilent = isCheckedOrNot(IDC_CHECK_UPDATESILENTLY);
1794  					bool isGo2End = isCheckedOrNot(IDC_CHECK_UPDATEGOTOEOF);
1795  					auto index = ::SendDlgItemMessage(_hSelf, IDC_COMBO_FILEUPDATECHOICE, CB_GETCURSEL, 0, 0);
1796  					int cd = cdDisabled;
1797  					if (index == fileUpdateChoiceEnable || index == fileUpdateChoiceEnable4All)
1798  					{
1799  						if (index == fileUpdateChoiceEnable4All)
1800  							cd |= cdEnabledOld;
1801  						else
1802  							cd |= cdEnabledNew;
1803  						if (isSilent)
1804  							cd |= cdAutoUpdate;
1805  						if (isGo2End)
1806  							cd |= cdGo2end;
1807  					}
1808  					nppGUI._fileAutoDetection = cd;
1809  				}
1810  				return TRUE;
1811  				case IDC_CHECK_AUTOUPDATE:
1812  					nppGUI._autoUpdateOpt._doAutoUpdate = isCheckedOrNot(static_cast<int32_t>(wParam));
1813  					return TRUE;
1814  				case IDC_CHECK_MIN2SYSTRAY:
1815  					nppGUI._isMinimizedToTray = isCheckedOrNot(static_cast<int32_t>(wParam));
1816  					return TRUE;
1817  				case IDC_CHECK_DETECTENCODING:
1818  					nppGUI._detectEncoding = isCheckedOrNot(static_cast<int32_t>(wParam));
1819  					return TRUE;
1820  				case IDC_CHECK_ENABLEDOCSWITCHER :
1821  				{
1822  					nppGUI._doTaskList = !nppGUI._doTaskList;
1823  					if (nppGUI._doTaskList)
1824  					{
1825  						::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_STYLEMRU), TRUE);
1826  					}
1827  					else
1828  					{
1829  						nppGUI._styleMRU = false;
1830  						::SendDlgItemMessage(_hSelf, IDC_CHECK_STYLEMRU, BM_SETCHECK, false, 0);
1831  						::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_STYLEMRU), FALSE);
1832  					}
1833  					return TRUE;
1834  				}
1835  				case IDC_CHECK_STYLEMRU :
1836  				{
1837  					nppGUI._styleMRU = isCheckedOrNot(IDC_CHECK_STYLEMRU);
1838  					return TRUE;
1839  				}
1840  				case IDC_CHECK_SHORTTITLE:
1841  				{
1842  					nppGUI._shortTitlebar = isCheckedOrNot(IDC_CHECK_SHORTTITLE);
1843  					HWND grandParent = ::GetParent(_hParent);
1844  					::SendMessage(grandParent, NPPM_INTERNAL_UPDATETITLEBAR, 0, 0);
1845  					return TRUE;
1846  				}
1847  				case IDC_CHECK_DIRECTWRITE_ENABLE:
1848  				{
1849  					nppGUI._writeTechnologyEngine = isCheckedOrNot(IDC_CHECK_DIRECTWRITE_ENABLE) ? directWriteTechnology : defaultTechnology;
1850  					return TRUE;
1851  				}
1852  				case IDC_CHECK_ENABLEDOCPEEKER:
1853  				{
1854  					nppGUI._isDocPeekOnTab = isCheckedOrNot(IDC_CHECK_ENABLEDOCPEEKER);
1855  					return TRUE;
1856  				}
1857  				case IDC_CHECK_ENABLEDOCPEEKONMAP:
1858  				{
1859  					nppGUI._isDocPeekOnMap = isCheckedOrNot(IDC_CHECK_ENABLEDOCPEEKONMAP);
1860  					return TRUE;
1861  				}
1862  				case IDC_CHECK_MUTE_SOUNDS:
1863  				{
1864  					nppGUI._muteSounds = isCheckedOrNot(IDC_CHECK_MUTE_SOUNDS);
1865  					return TRUE;
1866  				}
1867  				case IDC_CHECK_SAVEALLCONFIRM:
1868  				{
1869  					nppGUI._saveAllConfirm = isCheckedOrNot(IDC_CHECK_SAVEALLCONFIRM);
1870  					return TRUE;
1871  				}
1872  				default:
1873  				{
1874  					if (HIWORD(wParam) == CBN_SELCHANGE)
1875  					{
1876  						if (LOWORD(wParam) == IDC_COMBO_FILEUPDATECHOICE)
1877  						{
1878  							auto index = ::SendDlgItemMessage(_hSelf, IDC_COMBO_FILEUPDATECHOICE, CB_GETCURSEL, 0, 0);
1879  							if (index == fileUpdateChoiceEnable || index == fileUpdateChoiceEnable4All)
1880  							{
1881  								bool isSilent = isCheckedOrNot(IDC_CHECK_UPDATESILENTLY);
1882  								bool isGo2End = isCheckedOrNot(IDC_CHECK_UPDATEGOTOEOF);
1883  								int cd = cdDisabled;
1884  								if (index == fileUpdateChoiceEnable4All)
1885  									cd |= cdEnabledOld;
1886  								else
1887  									cd |= cdEnabledNew;
1888  								if (isSilent)
1889  									cd |= cdAutoUpdate;
1890  								if (isGo2End)
1891  									cd |= cdGo2end;
1892  								nppGUI._fileAutoDetection = cd;
1893  								::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_UPDATESILENTLY), TRUE);
1894  								::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_UPDATEGOTOEOF), TRUE);
1895  							}
1896  							else if (index == fileUpdateChoiceDisable)
1897  							{
1898  								::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_UPDATESILENTLY), FALSE);
1899  								::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_UPDATEGOTOEOF), FALSE);
1900  								nppGUI._fileAutoDetection = cdDisabled;
1901  							}
1902  							return TRUE;
1903  						}
1904  					}
1905  				}
1906  			}
1907  		}
1908  	}
1909  	return FALSE;
1910  }
1911  intptr_t CALLBACK NewDocumentSubDlg::run_dlgProc(UINT message, WPARAM wParam, LPARAM)
1912  {
1913  	NppParameters& nppParam = NppParameters::getInstance();
1914  	NppGUI & nppGUI = (NppGUI & )nppParam.getNppGUI();
1915  	NewDocDefaultSettings & ndds = (NewDocDefaultSettings &)nppGUI.getNewDocDefaultSettings();
1916  	switch (message)
1917  	{
1918  		case WM_INITDIALOG:
1919  		{
1920  			int ID2Check = IDC_RADIO_F_WIN;
1921  			switch (ndds._format)
1922  			{
1923  				case EolType::windows:
1924  					ID2Check = IDC_RADIO_F_WIN;
1925  					break;
1926  				case EolType::macos:
1927  					ID2Check = IDC_RADIO_F_MAC;
1928  					break;
1929  				case EolType::unix:
1930  					ID2Check = IDC_RADIO_F_UNIX;
1931  					break;
1932  				case EolType::unknown:
1933  					assert(false);
1934  					break;
1935  			}
1936  			::SendDlgItemMessage(_hSelf, ID2Check, BM_SETCHECK, BST_CHECKED, 0);
1937  			switch (ndds._unicodeMode)
1938  			{
1939  				case uni16BE :
1940  					ID2Check = IDC_RADIO_UTF16BIG;
1941  					break;
1942  				case uni16LE :
1943  					ID2Check = IDC_RADIO_UTF16SMALL;
1944  					break;
1945  				case uniUTF8 :
1946  					ID2Check = IDC_RADIO_UTF8;
1947  					break;
1948  				case uniCookie :
1949  					ID2Check = IDC_RADIO_UTF8SANSBOM;
1950  					break;
1951  				default : 
1952  					ID2Check = IDC_RADIO_ANSI;
1953  			}
1954  			int selIndex = -1;
1955  			generic_string str;
1956  			EncodingMapper& em = EncodingMapper::getInstance();
1957  			for (size_t i = 0, encodingArraySize = sizeof(encodings)/sizeof(int) ; i < encodingArraySize ; ++i)
1958  			{
1959  				int cmdID = em.getIndexFromEncoding(encodings[i]);
1960  				if (cmdID != -1)
1961  				{
1962  					cmdID += IDM_FORMAT_ENCODE;
1963  					getNameStrFromCmd(cmdID, str);
1964  					int index = static_cast<int32_t>(::SendDlgItemMessage(_hSelf, IDC_COMBO_OTHERCP, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(str.c_str())));
1965  					if (ndds._codepage == encodings[i])
1966  						selIndex = index;
1967  					::SendDlgItemMessage(_hSelf, IDC_COMBO_OTHERCP, CB_SETITEMDATA, index, encodings[i]);
1968  				}
1969  			}
1970  			if (ndds._codepage == -1 || selIndex == -1)
1971  			{
1972  				::EnableWindow(::GetDlgItem(_hSelf, IDC_COMBO_OTHERCP), false);
1973  			}
1974  			else
1975  			{
1976  				ID2Check = IDC_RADIO_OTHERCP;
1977  				::SendDlgItemMessage(_hSelf, IDC_COMBO_OTHERCP, CB_SETCURSEL, selIndex, 0);
1978  			}
1979  			::SendDlgItemMessage(_hSelf, ID2Check, BM_SETCHECK, BST_CHECKED, 0);
1980  			::SendDlgItemMessage(_hSelf, IDC_CHECK_OPENANSIASUTF8, BM_SETCHECK, (ID2Check == IDC_RADIO_UTF8SANSBOM && ndds._openAnsiAsUtf8)?BST_CHECKED:BST_UNCHECKED, 0);
1981  			::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_OPENANSIASUTF8), ID2Check == IDC_RADIO_UTF8SANSBOM);
1982  			for (int i = L_TEXT + 1 ; i < nppParam.L_END ; ++i) 
1983  			{
1984  				LangType lt = static_cast<LangType>(i);
1985  				str.clear();
1986  				if (lt != L_USER && lt != L_JS)
1987  				{
1988  					int cmdID = nppParam.langTypeToCommandID(lt);
1989  					if ((cmdID != -1))
1990  					{
1991  						getNameStrFromCmd(cmdID, str);
1992  						if (str.length() > 0)
1993  						{
1994  							size_t index = ::SendDlgItemMessage(_hSelf, IDC_COMBO_DEFAULTLANG, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(str.c_str()));
1995  							::SendDlgItemMessage(_hSelf, IDC_COMBO_DEFAULTLANG, CB_SETITEMDATA, index, lt);
1996  						}
1997  					}
1998  				}
1999  			}
2000  			int normalTextCmdID = nppParam.langTypeToCommandID(L_TEXT);
2001  			getNameStrFromCmd(normalTextCmdID, str);
2002  			::SendDlgItemMessage(_hSelf, IDC_COMBO_DEFAULTLANG, CB_INSERTSTRING, 0, reinterpret_cast<LPARAM>(str.c_str()));
2003  			LangType l = L_TEXT;
2004  			size_t cbCount = ::SendDlgItemMessage(_hSelf, IDC_COMBO_DEFAULTLANG, CB_GETCOUNT, 0, 0);
2005  			size_t j = 0;
2006  			for (; j < cbCount; ++j)
2007  			{
2008  				l = static_cast<LangType>(::SendDlgItemMessage(_hSelf, IDC_COMBO_DEFAULTLANG, CB_GETITEMDATA, j, 0));
2009  				if (ndds._lang == l)
2010  					break;
2011  			}
2012  			::SendDlgItemMessage(_hSelf, IDC_COMBO_DEFAULTLANG, CB_SETCURSEL, j, 0);
2013  			return TRUE;
2014  		}
2015  		case WM_CTLCOLORLISTBOX:
2016  		{
2017  			return NppDarkMode::onCtlColor(reinterpret_cast<HDC>(wParam));
2018  		}
2019  		case WM_CTLCOLORDLG:
2020  		case WM_CTLCOLORSTATIC:
2021  		{
2022  			return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
2023  		}
2024  		case WM_PRINTCLIENT:
2025  		{
2026  			if (NppDarkMode::isEnabled())
2027  			{
2028  				return TRUE;
2029  			}
2030  			break;
2031  		}
2032  		case WM_COMMAND:
2033  			switch (wParam)
2034  			{
2035  				case IDC_RADIO_UTF16BIG:
2036  					ndds._unicodeMode = uni16BE;
2037  					ndds._openAnsiAsUtf8 = false;
2038  					makeOpenAnsiAsUtf8(false);
2039  					ndds._codepage = -1;
2040  					::EnableWindow(::GetDlgItem(_hSelf, IDC_COMBO_OTHERCP), false);
2041  					return TRUE;
2042  				case IDC_RADIO_UTF16SMALL:
2043  					ndds._unicodeMode = uni16LE;
2044  					ndds._openAnsiAsUtf8 = false;
2045  					makeOpenAnsiAsUtf8(false);
2046  					ndds._codepage = -1;
2047  					::EnableWindow(::GetDlgItem(_hSelf, IDC_COMBO_OTHERCP), false);
2048  					return TRUE;
2049  				case IDC_RADIO_UTF8:
2050  					ndds._unicodeMode = uniUTF8;
2051  					ndds._openAnsiAsUtf8 = false;
2052  					makeOpenAnsiAsUtf8(false);
2053  					ndds._codepage = -1;
2054  					::EnableWindow(::GetDlgItem(_hSelf, IDC_COMBO_OTHERCP), false);
2055  					return TRUE;
2056  				case IDC_RADIO_UTF8SANSBOM:
2057  					ndds._unicodeMode = uniCookie;
2058  					makeOpenAnsiAsUtf8(true);
2059  					ndds._codepage = -1;
2060  					::EnableWindow(::GetDlgItem(_hSelf, IDC_COMBO_OTHERCP), false);
2061  					return TRUE;
2062  				case IDC_RADIO_ANSI:
2063  					ndds._unicodeMode = uni8Bit;
2064  					ndds._openAnsiAsUtf8 = false;
2065  					makeOpenAnsiAsUtf8(false);
2066  					ndds._codepage = -1;
2067  					::EnableWindow(::GetDlgItem(_hSelf, IDC_COMBO_OTHERCP), false);
2068  					return TRUE;
2069  				case IDC_CHECK_OPENANSIASUTF8 :
2070  					ndds._openAnsiAsUtf8 = (BST_CHECKED == ::SendMessage(::GetDlgItem(_hSelf, IDC_CHECK_OPENANSIASUTF8), BM_GETCHECK, 0, 0));
2071  					return TRUE;
2072  				case IDC_RADIO_OTHERCP :
2073  				{
2074  					ndds._openAnsiAsUtf8 = false;
2075  					makeOpenAnsiAsUtf8(false);
2076  					::EnableWindow(::GetDlgItem(_hSelf, IDC_COMBO_OTHERCP), true);
2077  					auto index = ::SendDlgItemMessage(_hSelf, IDC_COMBO_OTHERCP, CB_GETCURSEL, 0, 0);
2078  					ndds._codepage = static_cast<int32_t>(::SendDlgItemMessage(_hSelf, IDC_COMBO_OTHERCP, CB_GETITEMDATA, index, 0));
2079  					return TRUE;
2080  				}
2081  				case IDC_RADIO_F_MAC:
2082  				{
2083  					ndds._format = EolType::macos;
2084  					return TRUE;
2085  				}
2086  				case IDC_RADIO_F_UNIX:
2087  				{
2088  					ndds._format = EolType::unix;
2089  					return TRUE;
2090  				}
2091  				case IDC_RADIO_F_WIN:
2092  				{
2093  					ndds._format = EolType::windows;
2094  					return TRUE;
2095  				}
2096  				default:
2097  				{
2098  					if (HIWORD(wParam) == CBN_SELCHANGE)
2099  					{
2100  						if (LOWORD(wParam) == IDC_COMBO_DEFAULTLANG)
2101  						{
2102  							auto index = ::SendDlgItemMessage(_hSelf, IDC_COMBO_DEFAULTLANG, CB_GETCURSEL, 0, 0);
2103  							ndds._lang = static_cast<LangType>(::SendDlgItemMessage(_hSelf, IDC_COMBO_DEFAULTLANG, CB_GETITEMDATA, index, 0));
2104  							return TRUE;
2105  						}
2106  						else if (LOWORD(wParam) == IDC_COMBO_OTHERCP)
2107  						{
2108  							auto index = ::SendDlgItemMessage(_hSelf, IDC_COMBO_OTHERCP, CB_GETCURSEL, 0, 0);
2109  							ndds._codepage = static_cast<int32_t>(::SendDlgItemMessage(_hSelf, IDC_COMBO_OTHERCP, CB_GETITEMDATA, index, 0));
2110  							return TRUE;
2111  						}
2112  					}
2113  					return FALSE;
2114  				}
2115  			}
2116  	}
2117   	return FALSE;
2118  }
2119  intptr_t CALLBACK DefaultDirectorySubDlg::run_dlgProc(UINT message, WPARAM wParam, LPARAM)
2120  {
2121  	NppParameters& nppParam = NppParameters::getInstance();
2122  	NppGUI & nppGUI = (NppGUI & )nppParam.getNppGUI();
2123  	switch (message) 
2124  	{
2125  		case WM_INITDIALOG :
2126  		{
2127  			int ID2Check = 0;
2128  			bool shouldActivated;
2129  			switch (nppGUI._openSaveDir)
2130  			{
2131  				case dir_last :
2132  					ID2Check = IDC_OPENSAVEDIR_REMEMBERLAST_RADIO;
2133  					shouldActivated = false;
2134  					break;
2135  				case dir_userDef :
2136  					ID2Check = IDC_OPENSAVEDIR_ALWAYSON_RADIO;
2137  					shouldActivated = true;
2138  					break;
2139  				default : 
2140  					ID2Check = IDC_OPENSAVEDIR_FOLLOWCURRENT_RADIO;
2141  					shouldActivated = false;
2142  			}
2143  			::SendDlgItemMessage(_hSelf, ID2Check, BM_SETCHECK, BST_CHECKED, 0);
2144  			::SendDlgItemMessage(_hSelf, IDC_OPENSAVEDIR_ALWAYSON_EDIT, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(nppGUI._defaultDir));
2145  			::EnableWindow(::GetDlgItem(_hSelf, IDC_OPENSAVEDIR_ALWAYSON_EDIT), shouldActivated);
2146  			::EnableWindow(::GetDlgItem(_hSelf, IDD_OPENSAVEDIR_ALWAYSON_BROWSE_BUTTON), shouldActivated);
2147  			::SendDlgItemMessage(_hSelf, IDC_OPENSAVEDIR_CHECK_DRROPFOLDEROPENFILES, BM_SETCHECK, nppGUI._isFolderDroppedOpenFiles ? BST_CHECKED : BST_UNCHECKED, 0);
2148  			return TRUE;
2149  		}
2150  		case WM_CTLCOLOREDIT:
2151  		{
2152  			return NppDarkMode::onCtlColorSofter(reinterpret_cast<HDC>(wParam));
2153  		}
2154  		case WM_CTLCOLORDLG:
2155  		case WM_CTLCOLORSTATIC:
2156  		{
2157  			return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
2158  		}
2159  		case WM_PRINTCLIENT:
2160  		{
2161  			if (NppDarkMode::isEnabled())
2162  			{
2163  				return TRUE;
2164  			}
2165  			break;
2166  		}
2167  		case WM_COMMAND : 
2168  		{
2169  			if (HIWORD(wParam) == EN_CHANGE)
2170  			{
2171  				switch (LOWORD(wParam))
2172  				{
2173  					case  IDC_OPENSAVEDIR_ALWAYSON_EDIT:
2174  					{
2175  						TCHAR inputDir[MAX_PATH] = { '\0' };
2176  						::SendDlgItemMessage(_hSelf, IDC_OPENSAVEDIR_ALWAYSON_EDIT, WM_GETTEXT, MAX_PATH, reinterpret_cast<LPARAM>(inputDir));
2177  						wcscpy_s(nppGUI._defaultDir, inputDir);
2178  						::ExpandEnvironmentStrings(nppGUI._defaultDir, nppGUI._defaultDirExp, _countof(nppGUI._defaultDirExp));
2179  						nppParam.setWorkingDir(nppGUI._defaultDirExp);
2180  						return TRUE;
2181  					}
2182  				}
2183  			}
2184  			switch (wParam)
2185  			{
2186  				case IDC_OPENSAVEDIR_FOLLOWCURRENT_RADIO:
2187  					nppGUI._openSaveDir = dir_followCurrent;
2188  					::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_REFRESHWORKDIR, 0, 0);
2189  					::EnableWindow(::GetDlgItem(_hSelf, IDC_OPENSAVEDIR_ALWAYSON_EDIT), false);
2190  					::EnableWindow(::GetDlgItem(_hSelf, IDD_OPENSAVEDIR_ALWAYSON_BROWSE_BUTTON), false);
2191  					return TRUE;
2192  				case IDC_OPENSAVEDIR_REMEMBERLAST_RADIO:
2193  					nppGUI._openSaveDir = dir_last;
2194  					::EnableWindow(::GetDlgItem(_hSelf, IDC_OPENSAVEDIR_ALWAYSON_EDIT), false);
2195  					::EnableWindow(::GetDlgItem(_hSelf, IDD_OPENSAVEDIR_ALWAYSON_BROWSE_BUTTON), false);
2196  					return TRUE;
2197  				case IDC_OPENSAVEDIR_ALWAYSON_RADIO:
2198  					nppGUI._openSaveDir = dir_userDef;
2199  					::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_REFRESHWORKDIR, 0, 0);
2200  					::EnableWindow(::GetDlgItem(_hSelf, IDC_OPENSAVEDIR_ALWAYSON_EDIT), true);
2201  					::EnableWindow(::GetDlgItem(_hSelf, IDD_OPENSAVEDIR_ALWAYSON_BROWSE_BUTTON), true);
2202  					return TRUE;
2203  				case IDD_OPENSAVEDIR_ALWAYSON_BROWSE_BUTTON :
2204  					{
2205  						generic_string title = nppParam.getNativeLangSpeaker()->getLocalizedStrFromID("default-open-save-select-folder",
2206  							TEXT("Select a folder as default directory"));
2207  						folderBrowser(_hSelf, title, IDC_OPENSAVEDIR_ALWAYSON_EDIT);
2208  					}
2209  					return TRUE;
2210  				case IDC_OPENSAVEDIR_CHECK_DRROPFOLDEROPENFILES:
2211  					nppGUI._isFolderDroppedOpenFiles = isCheckedOrNot(IDC_OPENSAVEDIR_CHECK_DRROPFOLDEROPENFILES);
2212  					return TRUE;
2213  				default:
2214  					return FALSE;
2215  			}
2216  		}
2217  	}
2218  	return FALSE;
2219  }
2220  void RecentFilesHistorySubDlg::setCustomLen(int val)
2221  {
2222  	::SetDlgItemInt(_hSelf, IDC_EDIT_CUSTOMIZELENGTHVAL, val, FALSE);
2223  	::EnableWindow(::GetDlgItem(_hSelf, IDC_EDIT_CUSTOMIZELENGTHVAL), val > 0);
2224  }
2225  intptr_t CALLBACK RecentFilesHistorySubDlg::run_dlgProc(UINT message, WPARAM wParam, LPARAM lParam)
2226  {
2227  	NppParameters& nppParam = NppParameters::getInstance();
2228  	NppGUI& nppGUI = nppParam.getNppGUI();
2229  	switch (message) 
2230  	{
2231  		case WM_INITDIALOG:
2232  		{
2233  			::SetDlgItemInt(_hSelf, IDC_EDIT_MAXNBFILEVAL, nppParam.getNbMaxRecentFile(), FALSE);
2234  			::SendDlgItemMessage(_hSelf, IDC_CHECK_DONTCHECKHISTORY, BM_SETCHECK, !nppGUI._checkHistoryFiles, 0);
2235  			::SendDlgItemMessage(_hSelf, IDC_CHECK_INSUBMENU, BM_SETCHECK, nppParam.putRecentFileInSubMenu(), 0);
2236  			int customLength = nppParam.getRecentFileCustomLength();
2237  			int id = IDC_RADIO_CUSTOMIZELENTH;
2238  			int length = customLength;
2239  			if (customLength == RECENTFILES_SHOWONLYFILENAME)
2240  			{
2241  				id = IDC_RADIO_ONLYFILENAME;
2242  				length = 0;
2243  			}
2244  			else if (customLength == RECENTFILES_SHOWFULLPATH || customLength < 0)
2245  			{
2246  				id = IDC_RADIO_FULLFILENAMEPATH;
2247  				length = 0;
2248  			}
2249  			setChecked(id);
2250  			setCustomLen(length);
2251  			return TRUE;
2252  		}
2253  		case WM_CTLCOLOREDIT:
2254  		{
2255  			return NppDarkMode::onCtlColorSofter(reinterpret_cast<HDC>(wParam));
2256  		}
2257  		case WM_CTLCOLORDLG:
2258  		{
2259  			return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
2260  		}
2261  		case WM_CTLCOLORSTATIC:
2262  		{
2263  			const auto hdcStatic = reinterpret_cast<HDC>(wParam);
2264  			const auto dlgCtrlID = ::GetDlgCtrlID(reinterpret_cast<HWND>(lParam));
2265  			if (dlgCtrlID == IDC_CUSTOMIZELENGTH_RANGE_STATIC)
2266  			{
2267  				const bool isTextEnabled = isCheckedOrNot(IDC_RADIO_CUSTOMIZELENTH);
2268  				return NppDarkMode::onCtlColorDarkerBGStaticText(hdcStatic, isTextEnabled);
2269  			}
2270  			if (dlgCtrlID == IDC_EDIT_CUSTOMIZELENGTHVAL)
2271  			{
2272  				return NppDarkMode::onCtlColor(hdcStatic);
2273  			}
2274  			return NppDarkMode::onCtlColorDarker(hdcStatic);
2275  		}
2276  		case WM_PRINTCLIENT:
2277  		{
2278  			if (NppDarkMode::isEnabled())
2279  			{
2280  				return TRUE;
2281  			}
2282  			break;
2283  		}
2284  		case WM_COMMAND:
2285  		{
2286  			switch (LOWORD(wParam))
2287  			{
2288  				case IDC_EDIT_MAXNBFILEVAL:
2289  				{
2290  					switch (HIWORD(wParam))
2291  					{
2292  						case EN_KILLFOCUS:
2293  						{
2294  							constexpr int stringSize = 3;
2295  							wchar_t str[stringSize]{};
2296  							::GetDlgItemText(_hSelf, IDC_EDIT_MAXNBFILEVAL, str, stringSize);
2297  							if (lstrcmp(str, L"") == 0)
2298  							{
2299  								::SetDlgItemInt(_hSelf, IDC_EDIT_MAXNBFILEVAL, nppParam.getNbMaxRecentFile(), FALSE);
2300  								return FALSE;
2301  							}
2302  							UINT nbMaxFile = ::GetDlgItemInt(_hSelf, IDC_EDIT_MAXNBFILEVAL, nullptr, FALSE);
2303  							if (nbMaxFile == nppParam.getNbMaxRecentFile())
2304  							{
2305  								return FALSE;
2306  							}
2307  							if (nbMaxFile > NB_MAX_LRF_FILE)
2308  							{
2309  								::SetDlgItemInt(_hSelf, IDC_EDIT_MAXNBFILEVAL, NB_MAX_LRF_FILE, FALSE);
2310  								nbMaxFile = NB_MAX_LRF_FILE;
2311  							}
2312  							nppParam.setNbMaxRecentFile(nbMaxFile);
2313  							::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_SETTING_HISTORY_SIZE, 0, 0);
2314  							return TRUE;
2315  						}
2316  						default:
2317  						{
2318  							break;
2319  						}
2320  					}
2321  					return FALSE;
2322  				}
2323  				case IDC_EDIT_CUSTOMIZELENGTHVAL:
2324  				{
2325  					if (!isCheckedOrNot(IDC_RADIO_CUSTOMIZELENTH))
2326  					{
2327  						return FALSE;
2328  					}
2329  					switch (HIWORD(wParam))
2330  					{
2331  						case EN_KILLFOCUS:
2332  						{
2333  							constexpr int stringSize = 4;
2334  							wchar_t str[stringSize]{};
2335  							::GetDlgItemText(_hSelf, IDC_EDIT_CUSTOMIZELENGTHVAL, str, stringSize);
2336  							if (lstrcmp(str, L"") == 0)
2337  							{
2338  								::SetDlgItemInt(_hSelf, IDC_EDIT_CUSTOMIZELENGTHVAL, nppParam.getRecentFileCustomLength(), FALSE);
2339  								return FALSE;
2340  							}
2341  							UINT size = ::GetDlgItemInt(_hSelf, IDC_EDIT_CUSTOMIZELENGTHVAL, nullptr, FALSE);
2342  							if (size == static_cast<UINT>(nppParam.getRecentFileCustomLength()))
2343  							{
2344  								return FALSE;
2345  							}
2346  							bool change = false;
2347  							if (size == 0)
2348  							{
2349  								size = NB_DEFAULT_LRF_CUSTOMLENGTH;
2350  								change = true;
2351  							}
2352  							else if (size > NB_MAX_LRF_CUSTOMLENGTH)
2353  							{
2354  								size = NB_MAX_LRF_CUSTOMLENGTH;
2355  								change = true;
2356  							}
2357  							if (change)
2358  							{
2359  								::SetDlgItemInt(_hSelf, IDC_EDIT_CUSTOMIZELENGTHVAL, size, FALSE);
2360  							}
2361  							nppParam.setRecentFileCustomLength(size);
2362  							::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_RECENTFILELIST_UPDATE, 0, 0);
2363  							return TRUE;
2364  						}
2365  						default:
2366  						{
2367  							break;
2368  						}
2369  					}
2370  					return FALSE;
2371  				}
2372  				default:
2373  				{
2374  					break;
2375  				}
2376  			}
2377  			switch (wParam)
2378  			{
2379  				case IDC_CHECK_DONTCHECKHISTORY:
2380  					nppGUI._checkHistoryFiles = !isCheckedOrNot(IDC_CHECK_DONTCHECKHISTORY);
2381  					return TRUE;
2382  				case IDC_CHECK_INSUBMENU:
2383  					nppParam.setPutRecentFileInSubMenu(isCheckedOrNot(IDC_CHECK_INSUBMENU));
2384  					::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_RECENTFILELIST_SWITCH, 0, 0);
2385  					return TRUE;
2386  				case IDC_RADIO_ONLYFILENAME:
2387  				{
2388  					setCustomLen(0);
2389  					nppParam.setRecentFileCustomLength(0);
2390  					::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_RECENTFILELIST_UPDATE, 0, 0);
2391  					redrawDlgItem(IDC_CUSTOMIZELENGTH_RANGE_STATIC);
2392  					return TRUE;
2393  				}
2394  				case IDC_RADIO_FULLFILENAMEPATH:
2395  				{
2396  					setCustomLen(0);
2397  					nppParam.setRecentFileCustomLength(-1);
2398  					::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_RECENTFILELIST_UPDATE, 0, 0);
2399  					redrawDlgItem(IDC_CUSTOMIZELENGTH_RANGE_STATIC);
2400  					return TRUE;
2401  				}
2402  				case IDC_RADIO_CUSTOMIZELENTH:
2403  				{
2404  					int len = nppParam.getRecentFileCustomLength();
2405  					if (len <= 0)
2406  					{
2407  						setCustomLen(NB_DEFAULT_LRF_CUSTOMLENGTH);
2408  						nppParam.setRecentFileCustomLength(NB_DEFAULT_LRF_CUSTOMLENGTH);
2409  						::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_RECENTFILELIST_UPDATE, 0, 0);
2410  					}
2411  					redrawDlgItem(IDC_CUSTOMIZELENGTH_RANGE_STATIC);
2412  					return TRUE;
2413  				}
2414  				default:
2415  					return FALSE;
2416  			}
2417  		}
2418  	}
2419  	return FALSE;
2420  }
2421  intptr_t CALLBACK LanguageSubDlg::run_dlgProc(UINT message, WPARAM wParam, LPARAM lParam)
2422  {
2423  	NppParameters& nppParam = NppParameters::getInstance();
2424  	NppGUI & nppGUI = nppParam.getNppGUI();
2425  	NativeLangSpeaker *pNativeSpeaker = nppParam.getNativeLangSpeaker();
2426  	switch (message) 
2427  	{
2428  		case WM_INITDIALOG :
2429  		{
2430  			for (int i = L_TEXT ; i < nppParam.L_END ; ++i)
2431  			{
2432  				generic_string str;
2433  				if (static_cast<LangType>(i) != L_USER)
2434  				{
2435  					int cmdID = nppParam.langTypeToCommandID(static_cast<LangType>(i));
2436  					if ((cmdID != -1))
2437  					{
2438  						getNameStrFromCmd(cmdID, str);
2439  						if (str.length() > 0)
2440  						{
2441  							_langList.push_back(LangMenuItem(static_cast<LangType>(i), cmdID, str));
2442  							::SendDlgItemMessage(_hSelf, IDC_LIST_ENABLEDLANG, LB_ADDSTRING, 0, reinterpret_cast<LPARAM>(str.c_str()));
2443  						}
2444  					}
2445  				}
2446  			}
2447  			for (size_t i = 0, len = nppGUI._excludedLangList.size(); i < len ; ++i)
2448  			{
2449  				::SendDlgItemMessage(_hSelf, IDC_LIST_DISABLEDLANG, LB_ADDSTRING, 0, reinterpret_cast<LPARAM>(nppGUI._excludedLangList[i]._langName.c_str()));
2450  			}
2451  			::SendDlgItemMessage(_hSelf, IDC_CHECK_LANGMENUCOMPACT, BM_SETCHECK, nppGUI._isLangMenuCompact?BST_CHECKED:BST_UNCHECKED, 0);
2452  			::EnableWindow(::GetDlgItem(_hSelf, IDC_BUTTON_REMOVE), FALSE);
2453  			::EnableWindow(::GetDlgItem(_hSelf, IDC_BUTTON_RESTORE), FALSE);
2454  			::SetDlgItemInt(_hSelf, IDC_EDIT_TABSIZEVAL, nppGUI._tabSize, FALSE);
2455  			::SendDlgItemMessage(_hSelf, IDC_CHECK_REPLACEBYSPACE, BM_SETCHECK, nppGUI._tabReplacedBySpace, 0);
2456  			::SendDlgItemMessage(_hSelf, IDC_LIST_TABSETTNG, LB_ADDSTRING, 0, reinterpret_cast<LPARAM>(TEXT("[Default]")));
2457  			const int nbLang = nppParam.getNbLang();
2458  			for (int i = 0; i < nbLang; ++i)
2459  			{
2460  				::SendDlgItemMessage(_hSelf, IDC_LIST_TABSETTNG, LB_ADDSTRING, 0, reinterpret_cast<LPARAM>(nppParam.getLangFromIndex(i)->_langName.c_str()));
2461  			}
2462  			const int index2Begin = 0;
2463  			::SendDlgItemMessage(_hSelf, IDC_LIST_TABSETTNG, LB_SETCURSEL, index2Begin, 0);
2464  			::ShowWindow(::GetDlgItem(_hSelf, IDC_GR_TABVALUE_STATIC), SW_HIDE);
2465  			::ShowWindow(::GetDlgItem(_hSelf, IDC_CHECK_DEFAULTTABVALUE), SW_HIDE);
2466  			::SendDlgItemMessage(_hSelf, IDC_CHECK_BACKSLASHISESCAPECHARACTERFORSQL, BM_SETCHECK, nppGUI._backSlashIsEscapeCharacterForSql, 0);
2467  			return TRUE;
2468  		}
2469  		case WM_CTLCOLOREDIT:
2470  		{
2471  			return NppDarkMode::onCtlColorSofter(reinterpret_cast<HDC>(wParam));
2472  		}
2473  		case WM_CTLCOLORLISTBOX:
2474  		{
2475  			return NppDarkMode::onCtlColorListbox(wParam, lParam);
2476  		}
2477  		case WM_CTLCOLORDLG:
2478  		{
2479  			return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
2480  		}
2481  		case WM_CTLCOLORSTATIC:
2482  		{
2483  			const int dlgCtrlID = ::GetDlgCtrlID(reinterpret_cast<HWND>(lParam));
2484  			const auto& hdcStatic = reinterpret_cast<HDC>(wParam);
2485  			const size_t index = ::SendDlgItemMessage(_hSelf, IDC_LIST_TABSETTNG, LB_GETCURSEL, 0, 0);
2486  			if ((index > 0) && (dlgCtrlID == IDC_TABSIZE_STATIC))
2487  			{
2488  				const Lang* lang = nppParam.getLangFromIndex(index - 1);
2489  				if (lang == nullptr)
2490  				{
2491  					return NppDarkMode::onCtlColorDarker(hdcStatic);
2492  				}
2493  				const bool useDefaultTab = isCheckedOrNot(IDC_CHECK_DEFAULTTABVALUE);
2494  				return NppDarkMode::onCtlColorDarkerBGStaticText(hdcStatic, !useDefaultTab);
2495  			}
2496  			return NppDarkMode::onCtlColorDarker(hdcStatic);
2497  		}
2498  		case WM_PRINTCLIENT:
2499  		{
2500  			if (NppDarkMode::isEnabled())
2501  			{
2502  				return TRUE;
2503  			}
2504  			break;
2505  		}
2506  		case WM_COMMAND : 
2507  		{
2508  			switch (HIWORD(wParam))
2509  			{
2510  				case LBN_SELCHANGE:
2511  				{
2512  					if (LOWORD(wParam) == IDC_LIST_DISABLEDLANG || LOWORD(wParam) == IDC_LIST_ENABLEDLANG)
2513  					{
2514  						int idButton2Enable;
2515  						int idButton2Disable;
2516  						if (LOWORD(wParam) == IDC_LIST_ENABLEDLANG)
2517  						{
2518  							idButton2Enable = IDC_BUTTON_REMOVE;
2519  							idButton2Disable = IDC_BUTTON_RESTORE;
2520  						}
2521  						else 
2522  						{
2523  							idButton2Enable = IDC_BUTTON_RESTORE;
2524  							idButton2Disable = IDC_BUTTON_REMOVE;
2525  						}
2526  						auto i = ::SendDlgItemMessage(_hSelf, LOWORD(wParam), LB_GETCURSEL, 0, 0);
2527  						if (i != LB_ERR)
2528  						{
2529  							::EnableWindow(::GetDlgItem(_hSelf, idButton2Enable), TRUE);
2530  							int idListbox2Disable = (LOWORD(wParam) == IDC_LIST_ENABLEDLANG) ? IDC_LIST_DISABLEDLANG : IDC_LIST_ENABLEDLANG;
2531  							::SendDlgItemMessage(_hSelf, idListbox2Disable, LB_SETCURSEL, static_cast<WPARAM>(-1), 0);
2532  							::EnableWindow(::GetDlgItem(_hSelf, idButton2Disable), FALSE);
2533  						}
2534  						return TRUE;
2535  					}
2536  					else if (LOWORD(wParam) == IDC_LIST_TABSETTNG)
2537  					{
2538  						auto index = ::SendDlgItemMessage(_hSelf, IDC_LIST_TABSETTNG, LB_GETCURSEL, 0, 0);
2539  						if (index == LB_ERR)
2540  							return FALSE;
2541  						::ShowWindow(::GetDlgItem(_hSelf, IDC_GR_TABVALUE_STATIC), index > 0 ? SW_SHOW : SW_HIDE);
2542  						::ShowWindow(::GetDlgItem(_hSelf, IDC_CHECK_DEFAULTTABVALUE), index > 0 ? SW_SHOW : SW_HIDE);
2543  						if (index > 0)
2544  						{
2545  							Lang* lang = nppParam.getLangFromIndex(index - 1);
2546  							if (!lang) return FALSE;
2547  							bool useDefaultTab = (lang->_tabSize == -1 || lang->_tabSize == 0);
2548  							::SendMessage(::GetDlgItem(_hSelf, IDC_CHECK_DEFAULTTABVALUE), BM_SETCHECK, useDefaultTab, 0);
2549  							int size = useDefaultTab ? nppGUI._tabSize : lang->_tabSize;
2550  							::SetDlgItemInt(_hSelf, IDC_EDIT_TABSIZEVAL, size, FALSE);
2551  							::SendMessage(::GetDlgItem(_hSelf, IDC_CHECK_REPLACEBYSPACE), BM_SETCHECK, useDefaultTab ? nppGUI._tabReplacedBySpace : lang->_isTabReplacedBySpace, 0);
2552  							::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_REPLACEBYSPACE), !useDefaultTab);
2553  							::EnableWindow(::GetDlgItem(_hSelf, IDC_EDIT_TABSIZEVAL), !useDefaultTab);
2554  							if (!useDefaultTab)
2555  							{
2556  								::SetDlgItemInt(_hSelf, IDC_EDIT_TABSIZEVAL, lang->_tabSize, FALSE);
2557  								::SendMessage(::GetDlgItem(_hSelf, IDC_CHECK_REPLACEBYSPACE), BM_SETCHECK, lang->_isTabReplacedBySpace, 0);
2558  							}
2559  						}
2560  						else
2561  						{
2562  							::SetDlgItemInt(_hSelf, IDC_EDIT_TABSIZEVAL, nppGUI._tabSize, FALSE);
2563  							::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_REPLACEBYSPACE), TRUE);
2564  							::EnableWindow(::GetDlgItem(_hSelf, IDC_EDIT_TABSIZEVAL), TRUE);
2565  							::SendMessage(::GetDlgItem(_hSelf, IDC_CHECK_REPLACEBYSPACE), BM_SETCHECK, nppGUI._tabReplacedBySpace, 0);
2566  						}
2567  						redrawDlgItem(IDC_TABSIZE_STATIC);
2568  						return TRUE;
2569  					}
2570  					break;
2571  				}
2572  				case LBN_DBLCLK:
2573  				{
2574  					if (LOWORD(wParam) == IDC_LIST_DISABLEDLANG || LOWORD(wParam) == IDC_LIST_ENABLEDLANG)
2575  					{
2576  						HWND(lParam) == ::GetDlgItem(_hSelf, IDC_LIST_ENABLEDLANG) ?
2577  							::SendMessage(_hSelf, WM_COMMAND, IDC_BUTTON_REMOVE, 0) :
2578  							::SendMessage(_hSelf, WM_COMMAND, IDC_BUTTON_RESTORE, 0);
2579  						return TRUE;
2580  					}
2581  					break;
2582  				}
2583  				case EN_CHANGE:
2584  				{
2585  					switch (LOWORD(wParam))
2586  					{
2587  						case IDC_EDIT_TABSIZEVAL:
2588  						{
2589  							const auto tabSize = ::GetDlgItemInt(_hSelf, IDC_EDIT_TABSIZEVAL, nullptr, FALSE);
2590  							if (tabSize < 1)
2591  							{
2592  								return FALSE;
2593  							}
2594  							const bool useDefaultTab = isCheckedOrNot(IDC_CHECK_DEFAULTTABVALUE);
2595  							const size_t index = ::SendDlgItemMessage(_hSelf, IDC_LIST_TABSETTNG, LB_GETCURSEL, 0, 0);
2596  							if (!useDefaultTab && index > 0)
2597  							{
2598  								Lang* lang = nppParam.getLangFromIndex(index - 1);
2599  								if (lang == nullptr)
2600  								{
2601  									return FALSE;
2602  								}
2603  								if (lang->_langID == L_JS)
2604  								{
2605  									Lang* ljs = nppParam.getLangFromID(L_JAVASCRIPT);
2606  									ljs->_tabSize = tabSize;
2607  								}
2608  								else if (lang->_langID == L_JAVASCRIPT)
2609  								{
2610  									Lang* ljavascript = nppParam.getLangFromID(L_JS);
2611  									ljavascript->_tabSize = tabSize;
2612  								}
2613  								lang->_tabSize = tabSize;
2614  								nppParam.insertTabInfo(lang->getLangName(), lang->getTabInfo());
2615  							}
2616  							else
2617  							{
2618  								nppGUI._tabSize = tabSize;
2619  							}
2620  							::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_SETTING_TAB_SIZE, 0, 0);
2621  							return TRUE;
2622  						}
2623  						default:
2624  						{
2625  							break;
2626  						}
2627  					}
2628  					break;
2629  				}
2630  				case EN_KILLFOCUS:
2631  				{
2632  					switch (LOWORD(wParam))
2633  					{
2634  						case IDC_EDIT_TABSIZEVAL:
2635  						{
2636  							const auto tabSize = ::GetDlgItemInt(_hSelf, IDC_EDIT_TABSIZEVAL, nullptr, FALSE);
2637  							if (tabSize < 1)
2638  							{
2639  								const bool useDefaultTab = isCheckedOrNot(IDC_CHECK_DEFAULTTABVALUE);
2640  								const size_t index = ::SendDlgItemMessage(_hSelf, IDC_LIST_TABSETTNG, LB_GETCURSEL, 0, 0);
2641  								auto prevSize = nppGUI._tabSize;
2642  								if (!useDefaultTab && index > 0)
2643  								{
2644  									Lang* lang = nppParam.getLangFromIndex(index - 1);
2645  									if (lang != nullptr && lang->_tabSize > 0)
2646  									{
2647  										prevSize = lang->_tabSize;
2648  									}
2649  								}
2650  								::SetDlgItemInt(_hSelf, IDC_EDIT_TABSIZEVAL, prevSize, FALSE);
2651  								return TRUE;
2652  							}
2653  							return FALSE;
2654  						}
2655  						default:
2656  						{
2657  							break;
2658  						}
2659  					}
2660  					break;
2661  				}
2662  				default:
2663  				{
2664  					break;
2665  				}
2666  			}
2667  			switch (wParam)
2668  			{
2669  				case IDC_CHECK_LANGMENUCOMPACT:
2670  				{
2671  					nppGUI._isLangMenuCompact = (BST_CHECKED == ::SendMessage(::GetDlgItem(_hSelf, IDC_CHECK_LANGMENUCOMPACT), BM_GETCHECK, 0, 0));
2672  					pNativeSpeaker->messageBox("LanguageMenuCompactWarning",
2673  						_hSelf,
2674  						TEXT("This option will be changed on the next launch."),
2675  						TEXT("Compact Language Menu"),
2676  						MB_OK);
2677  					return TRUE;
2678  				}
2679  				case IDC_CHECK_BACKSLASHISESCAPECHARACTERFORSQL:
2680  				{
2681  					nppGUI._backSlashIsEscapeCharacterForSql = isCheckedOrNot(IDC_CHECK_BACKSLASHISESCAPECHARACTERFORSQL);
2682  					return TRUE;
2683  				}
2684  				case IDC_BUTTON_RESTORE :
2685  				case IDC_BUTTON_REMOVE :
2686  				{
2687  					int list2Remove, list2Add, idButton2Enable, idButton2Disable;
2688  					vector<LangMenuItem> *pSrcLst, *pDestLst;
2689  					if (LOWORD(wParam)==IDC_BUTTON_REMOVE)
2690  					{
2691  						list2Remove = IDC_LIST_ENABLEDLANG;
2692  						list2Add = IDC_LIST_DISABLEDLANG;
2693  						idButton2Enable = IDC_BUTTON_RESTORE;
2694  						idButton2Disable = IDC_BUTTON_REMOVE;
2695  						pSrcLst = &_langList;
2696  						pDestLst = &nppGUI._excludedLangList;
2697  					}
2698  					else
2699  					{
2700  						list2Remove = IDC_LIST_DISABLEDLANG;
2701  						list2Add = IDC_LIST_ENABLEDLANG;
2702  						idButton2Enable = IDC_BUTTON_REMOVE;
2703  						idButton2Disable = IDC_BUTTON_RESTORE;
2704  						pSrcLst = &nppGUI._excludedLangList;
2705  						pDestLst = &_langList;
2706  					}
2707  					size_t iRemove = ::SendDlgItemMessage(_hSelf, list2Remove, LB_GETCURSEL, 0, 0);
2708  					if (static_cast<intptr_t>(iRemove) == -1)
2709  						return TRUE;
2710  					const size_t sL = 31;
2711  					TCHAR s[sL + 1] = { '\0' };
2712  					auto lbTextLen = ::SendDlgItemMessage(_hSelf, list2Remove, LB_GETTEXTLEN, iRemove, 0);
2713  					if (static_cast<size_t>(lbTextLen) > sL)
2714  						return TRUE;
2715  					::SendDlgItemMessage(_hSelf, list2Remove, LB_GETTEXT, iRemove, reinterpret_cast<LPARAM>(s));
2716  					LangMenuItem lmi = pSrcLst->at(iRemove);
2717  					vector<LangMenuItem>::iterator lang2Remove = pSrcLst->begin() + iRemove;
2718  					pSrcLst->erase(lang2Remove);
2719  					auto iAdd = ::SendDlgItemMessage(_hSelf, list2Add, LB_ADDSTRING, 0, reinterpret_cast<LPARAM>(s));
2720  					::SendDlgItemMessage(_hSelf, list2Remove, LB_DELETESTRING, iRemove, 0);
2721  					pDestLst->push_back(lmi);
2722  					::SendDlgItemMessage(_hSelf, list2Add, LB_SETCURSEL, iAdd, 0);
2723  					::SendDlgItemMessage(_hSelf, list2Remove, LB_SETCURSEL, static_cast<WPARAM>(-1), 0);
2724  					::EnableWindow(::GetDlgItem(_hSelf, idButton2Enable), TRUE);
2725  					::EnableWindow(::GetDlgItem(_hSelf, idButton2Disable), FALSE);
2726  					if ((lmi._langType >= L_EXTERNAL) && (lmi._langType < nppParam.L_END))
2727  					{
2728  						bool found(false);
2729  						for (size_t x = 0; x < nppParam.getExternalLexerDoc()->size() && !found; ++x)
2730  						{
2731  							TiXmlNode *lexersRoot = nppParam.getExternalLexerDoc()->at(x)->FirstChild(TEXT("NotepadPlus"))->FirstChildElement(TEXT("LexerStyles"));
2732  							for (TiXmlNode *childNode = lexersRoot->FirstChildElement(TEXT("LexerType"));
2733  								childNode ;
2734  								childNode = childNode->NextSibling(TEXT("LexerType")))
2735  							{
2736  								TiXmlElement *element = childNode->ToElement();
2737  								if (generic_string(element->Attribute(TEXT("name"))) == lmi._langName)
2738  								{
2739  									element->SetAttribute(TEXT("excluded"), (LOWORD(wParam)==IDC_BUTTON_REMOVE)?TEXT("yes"):TEXT("no"));
2740  									nppParam.getExternalLexerDoc()->at(x)->SaveFile();
2741  									found = true;
2742  									break;
2743  								}
2744  							}
2745  						}
2746  					}
2747  					HWND grandParent = ::GetParent(_hParent);
2748  					if (LOWORD(wParam)==IDC_BUTTON_REMOVE)
2749  					{
2750  						HMENU menu2remove = reinterpret_cast<HMENU>(::SendMessage(grandParent, NPPM_INTERNAL_GETMENU, 0, 0));
2751  						::DeleteMenu(menu2remove, lmi._cmdID, MF_BYCOMMAND);
2752  					}
2753  					else
2754  					{
2755  						HMENU menu = HMENU(::SendMessage(grandParent, NPPM_INTERNAL_GETMENU, 0, 0));
2756  						HMENU subMenu = ::GetSubMenu(menu, MENUINDEX_LANGUAGE);
2757  						int nbItem = ::GetMenuItemCount(subMenu);
2758  						int x = 0;
2759  						MENUITEMINFO menuItemInfo
2760  						{
2761  							.cbSize = sizeof(MENUITEMINFO),
2762  							.fMask = MIIM_FTYPE
2763  						};
2764  						for (; x < nbItem; ++x)
2765  						{
2766  							::GetMenuItemInfo(subMenu, x, TRUE, &menuItemInfo);
2767  							if (menuItemInfo.fType & MFT_SEPARATOR)
2768  							{
2769  								break;
2770  							}
2771  						}
2772  						TCHAR firstLetter = lmi._langName.empty() ? TEXT('\0') : towupper(lmi._langName[0]);
2773  						TCHAR buffer[MAX_EXTERNAL_LEXER_NAME_LEN]{TEXT('\0')};
2774  						menuItemInfo.fMask = MIIM_SUBMENU;
2775  						for (++x; x < nbItem; ++x)
2776  						{
2777  							::GetMenuItemInfo(subMenu, x, TRUE, &menuItemInfo);
2778  							::GetMenuString(subMenu, x, buffer, MAX_EXTERNAL_LEXER_NAME_LEN, MF_BYPOSITION);
2779  							if (menuItemInfo.hSubMenu && buffer[0] == firstLetter)
2780  							{
2781  								subMenu = menuItemInfo.hSubMenu;
2782  								nbItem = ::GetMenuItemCount(subMenu);
2783  								x = -1;
2784  							}
2785  							else if (lstrcmp(lmi._langName.c_str(), buffer) < 0)
2786  							{
2787  								break;
2788  							}
2789  						}
2790  						::InsertMenu(subMenu, x, MF_BYPOSITION, lmi._cmdID, lmi._langName.c_str());
2791  					}
2792  					::DrawMenuBar(grandParent);
2793  					return TRUE;
2794  				}
2795  				case IDC_CHECK_REPLACEBYSPACE:
2796  				{
2797  					bool isTabReplacedBySpace = BST_CHECKED == ::SendMessage(::GetDlgItem(_hSelf, IDC_CHECK_REPLACEBYSPACE), BM_GETCHECK, 0, 0);
2798  					auto index = ::SendDlgItemMessage(_hSelf, IDC_LIST_TABSETTNG, LB_GETCURSEL, 0, 0);
2799  					if (index == LB_ERR) return FALSE;
2800  					if (index != 0)
2801  					{
2802  						Lang *lang = nppParam.getLangFromIndex(index - 1);
2803  						if (!lang) return FALSE;
2804  						if (!lang->_tabSize || lang->_tabSize == -1)
2805  							lang->_tabSize = nppGUI._tabSize;
2806  						if (lang->_langID == L_JS)
2807  						{
2808  							Lang *ljs = nppParam.getLangFromID(L_JAVASCRIPT);
2809  							ljs->_isTabReplacedBySpace = isTabReplacedBySpace;
2810  						}
2811  						else if (lang->_langID == L_JAVASCRIPT)
2812  						{
2813  							Lang *ljavascript = nppParam.getLangFromID(L_JS);
2814  							ljavascript->_isTabReplacedBySpace = isTabReplacedBySpace;
2815  						}
2816  						lang->_isTabReplacedBySpace = isTabReplacedBySpace;
2817  						nppParam.insertTabInfo(lang->getLangName(), lang->getTabInfo());
2818  					}
2819  					else
2820  					{
2821  						nppGUI._tabReplacedBySpace = isTabReplacedBySpace;
2822  					}
2823  					::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_SETTING_TAB_REPLCESPACE, 0, 0);
2824  					return TRUE;
2825  				}
2826  				case IDC_CHECK_DEFAULTTABVALUE:
2827  				{
2828  					const bool useDefaultTab = isCheckedOrNot(IDC_CHECK_DEFAULTTABVALUE);
2829  					const auto index = ::SendDlgItemMessage(_hSelf, IDC_LIST_TABSETTNG, LB_GETCURSEL, 0, 0);
2830  					if (index == LB_ERR || index == 0) 
2831  						return FALSE;
2832  					Lang *lang = nppParam.getLangFromIndex(index - 1);
2833  					if (!lang)
2834  						return FALSE;
2835  					lang->_tabSize = useDefaultTab ? 0 : nppGUI._tabSize;
2836  					lang->_isTabReplacedBySpace = useDefaultTab ? false : nppGUI._tabReplacedBySpace;
2837  					::SetDlgItemInt(_hSelf, IDC_EDIT_TABSIZEVAL, useDefaultTab ? nppGUI._tabSize : lang->_tabSize, FALSE);
2838  					setChecked(IDC_CHECK_REPLACEBYSPACE, useDefaultTab ? nppGUI._tabReplacedBySpace : lang->_isTabReplacedBySpace);
2839  					::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_REPLACEBYSPACE), !useDefaultTab);
2840  					::EnableWindow(::GetDlgItem(_hSelf, IDC_EDIT_TABSIZEVAL), !useDefaultTab);
2841  					if (useDefaultTab)
2842  						nppParam.insertTabInfo(lang->getLangName(), -1);
2843  					redrawDlgItem(IDC_TABSIZE_STATIC);
2844  					return TRUE;
2845  				}
2846  				default:
2847  				{
2848  					break;
2849  				}
2850  			}
2851  		}
2852  		default:
2853  		{
2854  			break;
2855  		}
2856  	}
2857  	return FALSE;
2858  }
2859  intptr_t CALLBACK HighlightingSubDlg::run_dlgProc(UINT message, WPARAM wParam, LPARAM&bsol;* lParam*/)
2860  {
2861  	NppParameters& nppParam = NppParameters::getInstance();
2862  	NppGUI & nppGUI = (NppGUI & )nppParam.getNppGUI();
2863  	switch (message) 
2864  	{
2865  		case WM_INITDIALOG :
2866  		{
2867  			::SendDlgItemMessage(_hSelf, IDC_CHECK_MARKALLCASESENSITIVE, BM_SETCHECK, nppGUI._markAllCaseSensitive, 0);
2868  			::SendDlgItemMessage(_hSelf, IDC_CHECK_MARKALLWHOLEWORDONLY, BM_SETCHECK, nppGUI._markAllWordOnly, 0);
2869  			::SendDlgItemMessage(_hSelf, IDC_CHECK_ENABLSMARTHILITE, BM_SETCHECK, nppGUI._enableSmartHilite, 0);
2870  			::SendDlgItemMessage(_hSelf, IDC_CHECK_SMARTHILITECASESENSITIVE, BM_SETCHECK, nppGUI._smartHiliteCaseSensitive, 0);
2871  			::SendDlgItemMessage(_hSelf, IDC_CHECK_SMARTHILITEWHOLEWORDONLY, BM_SETCHECK, nppGUI._smartHiliteWordOnly, 0);
2872  			::SendDlgItemMessage(_hSelf, IDC_CHECK_SMARTHILITEUSEFINDSETTINGS, BM_SETCHECK, nppGUI._smartHiliteUseFindSettings, 0);
2873  			::SendDlgItemMessage(_hSelf, IDC_CHECK_SMARTHILITEANOTHERRVIEW, BM_SETCHECK, nppGUI._smartHiliteOnAnotherView, 0);
2874  			::SendDlgItemMessage(_hSelf, IDC_CHECK_ENABLTAGSMATCHHILITE, BM_SETCHECK, nppGUI._enableTagsMatchHilite, 0);
2875  			::SendDlgItemMessage(_hSelf, IDC_CHECK_ENABLTAGATTRHILITE, BM_SETCHECK, nppGUI._enableTagAttrsHilite, 0);
2876  			::SendDlgItemMessage(_hSelf, IDC_CHECK_HIGHLITENONEHTMLZONE, BM_SETCHECK, nppGUI._enableHiliteNonHTMLZone, 0);
2877  			::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_ENABLTAGATTRHILITE), nppGUI._enableTagsMatchHilite);
2878  			::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_HIGHLITENONEHTMLZONE), nppGUI._enableTagsMatchHilite);
2879  			::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_SMARTHILITECASESENSITIVE), nppGUI._enableSmartHilite);
2880  			::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_SMARTHILITEWHOLEWORDONLY), nppGUI._enableSmartHilite);
2881  			::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_SMARTHILITEUSEFINDSETTINGS), nppGUI._enableSmartHilite);
2882  			::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_SMARTHILITEANOTHERRVIEW), nppGUI._enableSmartHilite);
2883  			if (NppDarkMode::isEnabled())
2884  			{
2885  				::EnableWindow(::GetDlgItem(_hSelf, IDC_SMARTHILITEMATCHING_STATIC), nppGUI._enableSmartHilite);
2886  			}
2887  			return TRUE;
2888  		}
2889  		case WM_CTLCOLORDLG:
2890  		case WM_CTLCOLORSTATIC:
2891  		{
2892  			return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
2893  		}
2894  		case WM_PRINTCLIENT:
2895  		{
2896  			if (NppDarkMode::isEnabled())
2897  			{
2898  				return TRUE;
2899  			}
2900  			break;
2901  		}
2902  		case WM_COMMAND : 
2903  		{
2904  			switch (wParam)
2905  			{
2906  				case IDC_CHECK_MARKALLCASESENSITIVE:
2907  				{
2908  					nppGUI._markAllCaseSensitive = isCheckedOrNot(IDC_CHECK_MARKALLCASESENSITIVE);
2909  					HWND grandParent = ::GetParent(_hParent);
2910  					::SendMessage(grandParent, NPPM_INTERNAL_CLEARINDICATOR, 0, 0);
2911  					return TRUE;
2912  				}
2913  				case IDC_CHECK_MARKALLWHOLEWORDONLY:
2914  				{
2915  					nppGUI._markAllWordOnly = isCheckedOrNot(IDC_CHECK_MARKALLWHOLEWORDONLY);
2916  					HWND grandParent = ::GetParent(_hParent);
2917  					::SendMessage(grandParent, NPPM_INTERNAL_CLEARINDICATOR, 0, 0);
2918  					return TRUE;
2919  				}
2920  				case IDC_CHECK_ENABLSMARTHILITE:
2921  				{
2922  					nppGUI._enableSmartHilite = !nppGUI._enableSmartHilite;
2923  					if (!nppGUI._enableSmartHilite)
2924  					{
2925  					}
2926  					::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_SMARTHILITECASESENSITIVE), nppGUI._enableSmartHilite);
2927  					::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_SMARTHILITEWHOLEWORDONLY), nppGUI._enableSmartHilite);
2928  					::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_SMARTHILITEUSEFINDSETTINGS), nppGUI._enableSmartHilite);
2929  					::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_SMARTHILITEANOTHERRVIEW), nppGUI._enableSmartHilite);
2930  					if (NppDarkMode::isEnabled())
2931  					{
2932  						::EnableWindow(::GetDlgItem(_hSelf, IDC_SMARTHILITEMATCHING_STATIC), nppGUI._enableSmartHilite);
2933  						redrawDlgItem(IDC_SMARTHILITEMATCHING_STATIC);
2934  					}
2935  					HWND grandParent = ::GetParent(_hParent);
2936  					::SendMessage(grandParent, NPPM_INTERNAL_CLEARINDICATOR, 0, 0);
2937  					return TRUE;
2938  				}
2939  				case IDC_CHECK_SMARTHILITECASESENSITIVE:
2940  				{
2941  					nppGUI._smartHiliteCaseSensitive = isCheckedOrNot(IDC_CHECK_SMARTHILITECASESENSITIVE);
2942  					if (nppGUI._smartHiliteCaseSensitive)
2943  					{
2944  						::SendDlgItemMessage(_hSelf, IDC_CHECK_SMARTHILITEUSEFINDSETTINGS, BM_SETCHECK, false, 0);
2945  						nppGUI._smartHiliteUseFindSettings = false;
2946  					}
2947  					HWND grandParent = ::GetParent(_hParent);
2948  					::SendMessage(grandParent, NPPM_INTERNAL_CLEARINDICATOR, 0, 0);
2949  					return TRUE;
2950  				}
2951  				case IDC_CHECK_SMARTHILITEWHOLEWORDONLY:
2952  				{
2953  					nppGUI._smartHiliteWordOnly = isCheckedOrNot(IDC_CHECK_SMARTHILITEWHOLEWORDONLY);
2954  					if (nppGUI._smartHiliteWordOnly)
2955  					{
2956  						::SendDlgItemMessage(_hSelf, IDC_CHECK_SMARTHILITEUSEFINDSETTINGS, BM_SETCHECK, false, 0);
2957  						nppGUI._smartHiliteUseFindSettings = false;
2958  					}
2959  					HWND grandParent = ::GetParent(_hParent);
2960  					::SendMessage(grandParent, NPPM_INTERNAL_CLEARINDICATOR, 0, 0);
2961  					return TRUE;
2962  				}
2963  				case IDC_CHECK_SMARTHILITEUSEFINDSETTINGS:
2964  				{
2965  					nppGUI._smartHiliteUseFindSettings = isCheckedOrNot(IDC_CHECK_SMARTHILITEUSEFINDSETTINGS);
2966  					if (nppGUI._smartHiliteUseFindSettings)
2967  					{
2968  						::SendDlgItemMessage(_hSelf, IDC_CHECK_SMARTHILITECASESENSITIVE, BM_SETCHECK, false, 0);
2969  						::SendDlgItemMessage(_hSelf, IDC_CHECK_SMARTHILITEWHOLEWORDONLY, BM_SETCHECK, false, 0);
2970  						nppGUI._smartHiliteCaseSensitive = false;
2971  						nppGUI._smartHiliteWordOnly = false;
2972  					}
2973  					HWND grandParent = ::GetParent(_hParent);
2974  					::SendMessage(grandParent, NPPM_INTERNAL_CLEARINDICATOR, 0, 0);
2975  					return TRUE;
2976  				}
2977  				case IDC_CHECK_SMARTHILITEANOTHERRVIEW:
2978  				{
2979  					nppGUI._smartHiliteOnAnotherView = isCheckedOrNot(IDC_CHECK_SMARTHILITEANOTHERRVIEW);
2980  					HWND grandParent = ::GetParent(_hParent);
2981  					::SendMessage(grandParent, NPPM_INTERNAL_CLEARINDICATOR, 0, 0);
2982  					return TRUE;
2983  				}
2984  				case IDC_CHECK_ENABLTAGSMATCHHILITE:
2985  				{
2986  					nppGUI._enableTagsMatchHilite = !nppGUI._enableTagsMatchHilite;
2987  					if (!nppGUI._enableTagsMatchHilite)
2988  					{
2989  						HWND grandParent = ::GetParent(_hParent);
2990  						::SendMessage(grandParent, NPPM_INTERNAL_CLEARINDICATORTAGMATCH, 0, 0);
2991  					}
2992  					::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_ENABLTAGATTRHILITE), nppGUI._enableTagsMatchHilite);
2993  					::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_HIGHLITENONEHTMLZONE), nppGUI._enableTagsMatchHilite);
2994  					return TRUE;
2995  				}
2996  				case IDC_CHECK_ENABLTAGATTRHILITE:
2997  				{
2998  					nppGUI._enableTagAttrsHilite = !nppGUI._enableTagAttrsHilite;
2999  					if (!nppGUI._enableTagAttrsHilite)
3000  					{
3001  						HWND grandParent = ::GetParent(_hParent);
3002  						::SendMessage(grandParent, NPPM_INTERNAL_CLEARINDICATORTAGATTR, 0, 0);
3003  					}
3004  					return TRUE;
3005  				}
3006  				case IDC_CHECK_HIGHLITENONEHTMLZONE:
3007  				{
3008  					nppGUI._enableHiliteNonHTMLZone = !nppGUI._enableHiliteNonHTMLZone;
3009  					return TRUE;
3010  				}
3011  			}
3012  		}
3013  	}
3014  	return FALSE;
3015  }
3016  intptr_t CALLBACK PrintSubDlg::run_dlgProc(UINT message, WPARAM wParam, LPARAM lParam)
3017  {
3018  	NppParameters& nppParam = NppParameters::getInstance();
3019  	NppGUI & nppGUI = (NppGUI & )nppParam.getNppGUI();
3020  	switch (message) 
3021  	{
3022  		case WM_INITDIALOG :
3023  		{
3024  			bool printLN = nppGUI._printSettings._printLineNumber;
3025  			::SendDlgItemMessage(_hSelf, IDC_CHECK_PRINTLINENUM, BM_SETCHECK, printLN, 0);
3026  			int ID2Check = 0;
3027  			switch (nppGUI._printSettings._printOption)
3028  			{
3029  				case SC_PRINT_NORMAL :
3030  					ID2Check = IDC_RADIO_WYSIWYG;
3031  					break;
3032  				case SC_PRINT_INVERTLIGHT :
3033  					ID2Check = IDC_RADIO_INVERT;
3034  					break;
3035  				case SC_PRINT_BLACKONWHITE :
3036  					ID2Check = IDC_RADIO_BW;
3037  					break;
3038  				case SC_PRINT_COLOURONWHITE :
3039  					ID2Check = IDC_RADIO_NOBG;
3040  					break;
3041  			}
3042  			::SendDlgItemMessage(_hSelf, ID2Check, BM_SETCHECK, BST_CHECKED, 0);
3043  			::SetDlgItemInt(_hSelf, IDC_EDIT_ML, nppGUI._printSettings._marge.left, FALSE);
3044  			::SetDlgItemInt(_hSelf, IDC_EDIT_MR, nppGUI._printSettings._marge.right, FALSE);
3045  			::SetDlgItemInt(_hSelf, IDC_EDIT_MT, nppGUI._printSettings._marge.top, FALSE);
3046  			::SetDlgItemInt(_hSelf, IDC_EDIT_MB,  nppGUI._printSettings._marge.bottom, FALSE);
3047  			::SetDlgItemText(_hSelf, IDC_EDIT_HLEFT, nppGUI._printSettings._headerLeft.c_str());
3048  			::SetDlgItemText(_hSelf, IDC_EDIT_HMIDDLE, nppGUI._printSettings._headerMiddle.c_str());
3049  			::SetDlgItemText(_hSelf, IDC_EDIT_HRIGHT, nppGUI._printSettings._headerRight.c_str());
3050  			::SetDlgItemText(_hSelf, IDC_EDIT_FLEFT, nppGUI._printSettings._footerLeft.c_str());
3051  			::SetDlgItemText(_hSelf, IDC_EDIT_FMIDDLE, nppGUI._printSettings._footerMiddle.c_str());
3052  			::SetDlgItemText(_hSelf, IDC_EDIT_FRIGHT, nppGUI._printSettings._footerRight.c_str());
3053  			TCHAR intStr[5]{};
3054  			for (int i = 6 ; i < 15 ; ++i)
3055  			{
3056  				wsprintf(intStr, TEXT("%d"), i);
3057  				::SendDlgItemMessage(_hSelf, IDC_COMBO_HFONTSIZE, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(intStr));
3058  				::SendDlgItemMessage(_hSelf, IDC_COMBO_FFONTSIZE, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(intStr));
3059  			}
3060  			const std::vector<generic_string> & fontlist = nppParam.getFontList();
3061  			for (size_t i = 0, len = fontlist.size() ; i < len ; ++i)
3062  			{
3063  				auto j = ::SendDlgItemMessage(_hSelf, IDC_COMBO_HFONTNAME, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(fontlist[i].c_str()));
3064  				::SendDlgItemMessage(_hSelf, IDC_COMBO_FFONTNAME, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(fontlist[i].c_str()));
3065  				::SendDlgItemMessage(_hSelf, IDC_COMBO_HFONTNAME, CB_SETITEMDATA, j, reinterpret_cast<LPARAM>(fontlist[i].c_str()));
3066  				::SendDlgItemMessage(_hSelf, IDC_COMBO_FFONTNAME, CB_SETITEMDATA, j, reinterpret_cast<LPARAM>(fontlist[i].c_str()));
3067  			}
3068  			auto index = ::SendDlgItemMessage(_hSelf, IDC_COMBO_HFONTNAME, CB_FINDSTRINGEXACT, static_cast<WPARAM>(-1), reinterpret_cast<LPARAM>(nppGUI._printSettings._headerFontName.c_str()));
3069  			if (index == CB_ERR)
3070  				index = 0;
3071  			::SendDlgItemMessage(_hSelf, IDC_COMBO_HFONTNAME, CB_SETCURSEL, index, 0);
3072  			index = ::SendDlgItemMessage(_hSelf, IDC_COMBO_FFONTNAME, CB_FINDSTRINGEXACT, static_cast<WPARAM>(-1), reinterpret_cast<LPARAM>(nppGUI._printSettings._footerFontName.c_str()));
3073  			if (index == CB_ERR)
3074  				index = 0;
3075  			::SendDlgItemMessage(_hSelf, IDC_COMBO_FFONTNAME, CB_SETCURSEL, index, 0);
3076  			wsprintf(intStr, TEXT("%d"), nppGUI._printSettings._headerFontSize);
3077  			::SendDlgItemMessage(_hSelf, IDC_COMBO_HFONTSIZE, CB_SELECTSTRING, static_cast<WPARAM>(-1), reinterpret_cast<LPARAM>(intStr));
3078  			wsprintf(intStr, TEXT("%d"), nppGUI._printSettings._footerFontSize);
3079  			::SendDlgItemMessage(_hSelf, IDC_COMBO_FFONTSIZE, CB_SELECTSTRING, static_cast<WPARAM>(-1), reinterpret_cast<LPARAM>(intStr));
3080  			::SendDlgItemMessage(_hSelf, IDC_CHECK_HBOLD, BM_SETCHECK, nppGUI._printSettings._headerFontStyle & FONTSTYLE_BOLD, 0);
3081  			::SendDlgItemMessage(_hSelf, IDC_CHECK_HITALIC, BM_SETCHECK, nppGUI._printSettings._headerFontStyle & FONTSTYLE_ITALIC, 0);
3082  			::SendDlgItemMessage(_hSelf, IDC_CHECK_FBOLD, BM_SETCHECK, nppGUI._printSettings._footerFontStyle & FONTSTYLE_BOLD, 0);
3083  			::SendDlgItemMessage(_hSelf, IDC_CHECK_FITALIC, BM_SETCHECK, nppGUI._printSettings._footerFontStyle & FONTSTYLE_ITALIC, 0);
3084  			::SendDlgItemMessage(_hSelf, IDC_COMBO_VARLIST, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(TEXT("Full file name path")));
3085  			::SendDlgItemMessage(_hSelf, IDC_COMBO_VARLIST, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(TEXT("File name")));
3086  			::SendDlgItemMessage(_hSelf, IDC_COMBO_VARLIST, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(TEXT("File directory")));
3087  			::SendDlgItemMessage(_hSelf, IDC_COMBO_VARLIST, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(TEXT("Page")));
3088  			::SendDlgItemMessage(_hSelf, IDC_COMBO_VARLIST, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(TEXT("Short date format")));
3089  			::SendDlgItemMessage(_hSelf, IDC_COMBO_VARLIST, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(TEXT("Long date format")));
3090  			::SendDlgItemMessage(_hSelf, IDC_COMBO_VARLIST, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(TEXT("Time")));
3091  			varList.push_back(TEXT("$(FULL_CURRENT_PATH)"));
3092  			varList.push_back(TEXT("$(FILE_NAME)"));
3093  			varList.push_back(TEXT("$(CURRENT_DIRECTORY)"));
3094  			varList.push_back(TEXT("$(CURRENT_PRINTING_PAGE)"));
3095  			varList.push_back(TEXT("$(SHORT_DATE)"));
3096  			varList.push_back(TEXT("$(LONG_DATE)"));
3097  			varList.push_back(TEXT("$(TIME)"));
3098  			::SendDlgItemMessage(_hSelf, IDC_COMBO_VARLIST, CB_SETCURSEL, 0, 0);
3099  			return TRUE;
3100  		}
3101  		case WM_CTLCOLOREDIT:
3102  		{
3103  			return NppDarkMode::onCtlColorSofter(reinterpret_cast<HDC>(wParam));
3104  		}
3105  		case WM_CTLCOLORLISTBOX:
3106  		{
3107  			return NppDarkMode::onCtlColor(reinterpret_cast<HDC>(wParam));
3108  		}
3109  		case WM_CTLCOLORDLG:
3110  		{
3111  			return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
3112  		}
3113  		case WM_CTLCOLORSTATIC:
3114  		{
3115  			const auto hdcStatic = reinterpret_cast<HDC>(wParam);
3116  			const auto dlgCtrlID = ::GetDlgCtrlID(reinterpret_cast<HWND>(lParam));
3117  			if (dlgCtrlID == IDC_EDIT_VIEWPANEL)
3118  			{
3119  				return NppDarkMode::onCtlColor(hdcStatic);
3120  			}
3121  			return NppDarkMode::onCtlColorDarker(hdcStatic);
3122  		}
3123  		case WM_PRINTCLIENT:
3124  		{
3125  			if (NppDarkMode::isEnabled())
3126  			{
3127  				return TRUE;
3128  			}
3129  			break;
3130  		}
3131  		case WM_COMMAND:
3132  		{
3133  			if (HIWORD(wParam) == EN_CHANGE && LOWORD(wParam) != IDC_EDIT_VIEWPANEL)
3134  			{
3135  				switch (LOWORD(wParam))
3136  				{
3137  					case  IDC_EDIT_ML:
3138  						nppGUI._printSettings._marge.left = ::GetDlgItemInt(_hSelf, IDC_EDIT_ML, NULL, FALSE);
3139  						return TRUE;
3140  					case  IDC_EDIT_MR:
3141  						nppGUI._printSettings._marge.right = ::GetDlgItemInt(_hSelf, IDC_EDIT_MR, NULL, FALSE);
3142  						return TRUE;
3143  					case IDC_EDIT_MT :
3144  						nppGUI._printSettings._marge.top = ::GetDlgItemInt(_hSelf, IDC_EDIT_MT, NULL, FALSE);
3145  						return TRUE;
3146  					case IDC_EDIT_MB :
3147  						nppGUI._printSettings._marge.bottom = ::GetDlgItemInt(_hSelf, IDC_EDIT_MB, NULL, FALSE);
3148  						return TRUE;
3149  					default:
3150  					{
3151  						constexpr int stringSize = 256;
3152  						TCHAR str[stringSize]{};
3153  						_focusedEditCtrl = LOWORD(wParam);
3154  						::GetDlgItemText(_hSelf, _focusedEditCtrl, str, stringSize);
3155  						::SendDlgItemMessage(_hSelf, IDC_EDIT_VIEWPANEL, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(str));
3156  						switch (LOWORD(wParam))
3157  						{
3158  							case  IDC_EDIT_HLEFT:
3159  								nppGUI._printSettings._headerLeft = str;
3160  								trim(nppGUI._printSettings._headerLeft);
3161  								return TRUE;
3162  							case  IDC_EDIT_HMIDDLE:
3163  								nppGUI._printSettings._headerMiddle = str;
3164  								trim(nppGUI._printSettings._headerMiddle);
3165  								return TRUE;
3166  							case IDC_EDIT_HRIGHT :
3167  								nppGUI._printSettings._headerRight = str;
3168  								trim(nppGUI._printSettings._headerRight);
3169  								return TRUE;
3170  							case  IDC_EDIT_FLEFT:
3171  								nppGUI._printSettings._footerLeft = str;
3172  								trim(nppGUI._printSettings._footerLeft);
3173  								return TRUE;
3174  							case  IDC_EDIT_FMIDDLE:
3175  								nppGUI._printSettings._footerMiddle = str;
3176  								trim(nppGUI._printSettings._footerMiddle);
3177  								return TRUE;
3178  							case IDC_EDIT_FRIGHT :
3179  								nppGUI._printSettings._footerRight = str;
3180  								trim(nppGUI._printSettings._footerRight);
3181  								return TRUE;
3182  							default :
3183  								return FALSE;
3184  						}
3185  					}
3186  				}
3187  			}
3188  			else if (HIWORD(wParam) == EN_SETFOCUS && LOWORD(wParam) != IDC_EDIT_VIEWPANEL)
3189  			{
3190  				constexpr int stringSize = 256;
3191  				TCHAR str[stringSize]{};
3192  				_focusedEditCtrl = LOWORD(wParam);
3193  				int focusedEditStatic = 0;
3194  				int groupStatic = 0;
3195  				switch (_focusedEditCtrl)
3196  				{
3197  					case IDC_EDIT_HLEFT : focusedEditStatic = IDC_HL_STATIC; groupStatic = IDC_HGB_STATIC; break;
3198  					case IDC_EDIT_HMIDDLE : focusedEditStatic = IDC_HM_STATIC; groupStatic = IDC_HGB_STATIC; break;
3199  					case IDC_EDIT_HRIGHT : focusedEditStatic = IDC_HR_STATIC; groupStatic = IDC_HGB_STATIC; break;
3200  					case IDC_EDIT_FLEFT : focusedEditStatic = IDC_FL_STATIC; groupStatic = IDC_FGB_STATIC; break;
3201  					case IDC_EDIT_FMIDDLE : focusedEditStatic = IDC_FM_STATIC; groupStatic = IDC_FGB_STATIC; break;
3202  					case IDC_EDIT_FRIGHT : focusedEditStatic = IDC_FR_STATIC; groupStatic = IDC_FGB_STATIC; break;
3203  					default : return TRUE;
3204  				}
3205  				::GetDlgItemText(_hSelf, _focusedEditCtrl, str, stringSize);
3206  				::SendDlgItemMessage(_hSelf, IDC_EDIT_VIEWPANEL, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(str));
3207  				::GetDlgItemText(_hSelf, groupStatic, str, stringSize);
3208  				generic_string title = str;
3209  				title += TEXT(" ");
3210  				::GetDlgItemText(_hSelf, focusedEditStatic, str, stringSize);
3211  				title += str;
3212  				title = purgeMenuItemString(title.c_str()); 
3213  				::SendDlgItemMessage(_hSelf, IDC_WHICHPART_STATIC, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(title.c_str()));
3214  				redrawDlgItem(IDC_WHICHPART_STATIC);
3215  				return TRUE;
3216  			}
3217  			else if (HIWORD(wParam) == CBN_SELCHANGE)
3218  			{
3219  				auto iSel = ::SendDlgItemMessage(_hSelf, LOWORD(wParam), CB_GETCURSEL, 0, 0);
3220  				switch (LOWORD(wParam))
3221  				{
3222  					case IDC_COMBO_HFONTNAME :
3223  					case IDC_COMBO_FFONTNAME :
3224  					{
3225  						TCHAR *fnStr = (TCHAR *)::SendDlgItemMessage(_hSelf, LOWORD(wParam), CB_GETITEMDATA, iSel, 0);
3226  						if (LOWORD(wParam) == IDC_COMBO_HFONTNAME)
3227  							nppGUI._printSettings._headerFontName = fnStr;
3228  						else
3229  							nppGUI._printSettings._footerFontName = fnStr;
3230  					}
3231  					break;
3232  					case IDC_COMBO_HFONTSIZE :
3233  					case IDC_COMBO_FFONTSIZE :
3234  					{
3235  						constexpr size_t intStrLen = 3;
3236  						TCHAR intStr[intStrLen]{};
3237  						auto lbTextLen = ::SendDlgItemMessage(_hSelf, LOWORD(wParam), CB_GETLBTEXTLEN, iSel, 0);
3238  						if (static_cast<size_t>(lbTextLen) >= intStrLen)
3239  							return TRUE;
3240  						::SendDlgItemMessage(_hSelf, LOWORD(wParam), CB_GETLBTEXT, iSel, reinterpret_cast<LPARAM>(intStr));
3241  						int *pVal = (LOWORD(wParam) == IDC_COMBO_HFONTSIZE)?&(nppGUI._printSettings._headerFontSize):&(nppGUI._printSettings._footerFontSize);
3242  						if (!intStr[0])
3243  							*pVal = 0;
3244  						else
3245  							*pVal = wcstol(intStr, NULL, 10);
3246  					}
3247  					break;
3248  					case IDC_COMBO_VARLIST:
3249  					{
3250  						break;
3251  					}
3252  					default:
3253  					{
3254  						break;
3255  					}
3256  				}
3257  				return TRUE;
3258  			}
3259  			switch (wParam)
3260  			{
3261  				case IDC_CHECK_PRINTLINENUM:
3262  					nppGUI._printSettings._printLineNumber = (BST_CHECKED == ::SendDlgItemMessage(_hSelf, IDC_CHECK_PRINTLINENUM, BM_GETCHECK, 0, 0));
3263  					break;
3264  				case  IDC_RADIO_WYSIWYG:
3265  					nppGUI._printSettings._printOption = SC_PRINT_NORMAL;
3266  					break;
3267  				case  IDC_RADIO_INVERT:
3268  					nppGUI._printSettings._printOption = SC_PRINT_INVERTLIGHT;
3269  					break;
3270  				case IDC_RADIO_BW :
3271  					nppGUI._printSettings._printOption = SC_PRINT_BLACKONWHITE;
3272  					break;
3273  				case IDC_RADIO_NOBG :
3274  					nppGUI._printSettings._printOption = SC_PRINT_COLOURONWHITE;
3275  					break;
3276  				case IDC_CHECK_HBOLD:
3277  					nppGUI._printSettings._headerFontStyle ^= FONTSTYLE_BOLD;
3278  					break;
3279  				case  IDC_CHECK_HITALIC:
3280  					nppGUI._printSettings._headerFontStyle ^= FONTSTYLE_ITALIC;
3281  					break;
3282  				case  IDC_CHECK_FBOLD:
3283  					nppGUI._printSettings._footerFontStyle ^= FONTSTYLE_BOLD;
3284  					break;
3285  				case  IDC_CHECK_FITALIC:
3286  					nppGUI._printSettings._footerFontStyle ^= FONTSTYLE_ITALIC;
3287  					break;
3288  				case  IDC_BUTTON_ADDVAR:
3289  				{
3290  					try {
3291  						if (!_focusedEditCtrl)
3292  							return TRUE;
3293  						size_t iSel = ::SendDlgItemMessage(_hSelf, IDC_COMBO_VARLIST, CB_GETCURSEL, 0, 0);
3294  						if (iSel >= varList.size())
3295  							return TRUE;
3296  						TCHAR *varStr = (TCHAR*)varList[iSel].c_str();
3297  						size_t selStart = 0;
3298  						size_t selEnd = 0;
3299  						::SendDlgItemMessage(_hSelf, _focusedEditCtrl, EM_GETSEL, reinterpret_cast<WPARAM>(&selStart), reinterpret_cast<LPARAM>(&selEnd));
3300  						constexpr int stringSize = 256;
3301  						TCHAR str[stringSize]{};
3302  						::SendDlgItemMessage(_hSelf, _focusedEditCtrl, WM_GETTEXT, stringSize, reinterpret_cast<LPARAM>(str));
3303  						generic_string str2Set(str);
3304  						size_t strLen = str2Set.length();
3305  						if (selStart > strLen || selEnd > strLen)
3306  							selStart = selEnd = strLen;
3307  						str2Set.replace(selStart, selEnd - selStart, varStr);
3308  						::SetDlgItemText(_hSelf, _focusedEditCtrl, str2Set.c_str());
3309  					}
3310  					catch (...)
3311  					{
3312  					}
3313  				}
3314  				break;
3315  			}
3316  			return TRUE;
3317  		}
3318  	}
3319  	return FALSE;
3320  }
3321  intptr_t CALLBACK BackupSubDlg::run_dlgProc(UINT message, WPARAM wParam, LPARAM lParam)
3322  {
3323  	NppParameters& nppParam = NppParameters::getInstance();
3324  	NppGUI & nppGUI = nppParam.getNppGUI();
3325  	switch (message) 
3326  	{
3327  		case WM_INITDIALOG :
3328  		{
3329  			::SendDlgItemMessage(_hSelf, IDC_CHECK_REMEMBERSESSION, BM_SETCHECK, nppGUI._rememberLastSession, 0);
3330  			bool snapshotCheck = nppGUI._rememberLastSession && nppGUI.isSnapshotMode();
3331  			::SendDlgItemMessage(_hSelf, IDC_BACKUPDIR_RESTORESESSION_CHECK, BM_SETCHECK, snapshotCheck?BST_CHECKED:BST_UNCHECKED, 0);
3332  			auto periodicBackupInSec = static_cast<UINT>(nppGUI._snapshotBackupTiming / 1000);
3333  			::SetDlgItemInt(_hSelf, IDC_BACKUPDIR_RESTORESESSION_EDIT,periodicBackupInSec, FALSE);
3334  			generic_string backupFilePath = NppParameters::getInstance().getUserPath();
3335  			backupFilePath += TEXT("\\backup\\");
3336  			::SetDlgItemText(_hSelf, IDD_BACKUPDIR_RESTORESESSION_PATH_EDIT, backupFilePath.c_str());
3337  			int ID2CheckBackupOnSave = 0;
3338  			switch (nppGUI._backup)
3339  			{
3340  				case bak_simple :
3341  					ID2CheckBackupOnSave = IDC_RADIO_BKSIMPLE;
3342  					break;
3343  				case bak_verbose :
3344  					ID2CheckBackupOnSave = IDC_RADIO_BKVERBOSE;
3345  					break;
3346  				default : 
3347  					ID2CheckBackupOnSave = IDC_RADIO_BKNONE;
3348  			}
3349  			::SendDlgItemMessage(_hSelf, ID2CheckBackupOnSave, BM_SETCHECK, BST_CHECKED, 0);
3350  			if (nppGUI._useDir)
3351  				::SendDlgItemMessage(_hSelf, IDC_BACKUPDIR_CHECK, BM_SETCHECK, BST_CHECKED, 0);
3352  			::SendDlgItemMessage(_hSelf, IDC_BACKUPDIR_EDIT, WM_SETTEXT, 0, reinterpret_cast<LPARAM>((nppGUI._backupDir.c_str())));
3353  			updateBackupSessionGUI();
3354  			updateBackupOnSaveGUI();
3355  			return TRUE;
3356  		}
3357  		case WM_CTLCOLOREDIT:
3358  		{
3359  			return NppDarkMode::onCtlColorSofter(reinterpret_cast<HDC>(wParam));
3360  		}
3361  		case WM_CTLCOLORDLG:
3362  		{
3363  			return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
3364  		}
3365  		case WM_CTLCOLORSTATIC:
3366  		{
3367  			auto hdcStatic = reinterpret_cast<HDC>(wParam);
3368  			auto dlgCtrlID = ::GetDlgCtrlID(reinterpret_cast<HWND>(lParam));
3369  			bool isStaticText = (dlgCtrlID == IDD_BACKUPDIR_RESTORESESSION_STATIC1 ||
3370  				dlgCtrlID == IDD_BACKUPDIR_RESTORESESSION_STATIC2 ||
3371  				dlgCtrlID == IDD_BACKUPDIR_RESTORESESSION_PATHLABEL_STATIC);
3372  			if (isStaticText)
3373  			{
3374  				bool isTextEnabled = isCheckedOrNot(IDC_BACKUPDIR_RESTORESESSION_CHECK);
3375  				return NppDarkMode::onCtlColorDarkerBGStaticText(hdcStatic, isTextEnabled);
3376  			}
3377  			if (dlgCtrlID == IDD_BACKUPDIR_STATIC)
3378  			{
3379  				bool isTextEnabled = !isCheckedOrNot(IDC_RADIO_BKNONE) && isCheckedOrNot(IDC_BACKUPDIR_CHECK);
3380  				return NppDarkMode::onCtlColorDarkerBGStaticText(hdcStatic, isTextEnabled);
3381  			}
3382  			if (dlgCtrlID == IDD_BACKUPDIR_RESTORESESSION_PATH_EDIT)
3383  			{
3384  				return NppDarkMode::onCtlColor(hdcStatic);
3385  			}
3386  			return NppDarkMode::onCtlColorDarker(hdcStatic);
3387  		}
3388  		case WM_PRINTCLIENT:
3389  		{
3390  			if (NppDarkMode::isEnabled())
3391  			{
3392  				return TRUE;
3393  			}
3394  			break;
3395  		}
3396  		case WM_COMMAND : 
3397  		{
3398  			if (HIWORD(wParam) == EN_CHANGE)
3399  			{
3400  				switch (LOWORD(wParam))
3401  				{
3402  					case  IDC_BACKUPDIR_EDIT:
3403  					{
3404  						TCHAR inputDir[MAX_PATH] = {'\0'};
3405  						::SendDlgItemMessage(_hSelf, IDC_BACKUPDIR_EDIT, WM_GETTEXT, MAX_PATH, reinterpret_cast<LPARAM>(inputDir));
3406  						nppGUI._backupDir = inputDir;
3407  						return TRUE;
3408  					}
3409  					case IDC_BACKUPDIR_RESTORESESSION_EDIT:
3410  					{
3411  						constexpr int stringSize = 16;
3412  						TCHAR str[stringSize]{};
3413  						::GetDlgItemText(_hSelf, IDC_BACKUPDIR_RESTORESESSION_EDIT, str, stringSize);
3414  						if (lstrcmp(str, TEXT("")) == 0)
3415  							return TRUE;
3416  						nppGUI._snapshotBackupTiming = ::GetDlgItemInt(_hSelf, IDC_BACKUPDIR_RESTORESESSION_EDIT, NULL, FALSE) * 1000;
3417  						if (!nppGUI._snapshotBackupTiming)
3418  						{
3419  							nppGUI._snapshotBackupTiming = 1000;
3420  							::SetDlgItemInt(_hSelf, IDC_BACKUPDIR_RESTORESESSION_EDIT, 1, FALSE);
3421  						}
3422  						return TRUE;
3423  					}
3424  				}
3425  			}
3426  			else if (HIWORD(wParam) == EN_KILLFOCUS)
3427  			{
3428  				switch (LOWORD(wParam))
3429  				{
3430  					case  IDC_BACKUPDIR_RESTORESESSION_EDIT:
3431  					{
3432  						constexpr int stringSize = 16;
3433  						TCHAR str[stringSize]{};
3434  						::GetDlgItemText(_hSelf, IDC_BACKUPDIR_RESTORESESSION_EDIT, str, stringSize);
3435  						if (lstrcmp(str, TEXT("")) == 0)
3436  						{
3437  							::SetDlgItemInt(_hSelf, IDC_BACKUPDIR_RESTORESESSION_EDIT, static_cast<int32_t>(nppGUI._snapshotBackupTiming / 1000), FALSE);
3438  						}
3439  					}
3440  				}
3441  			}
3442  			switch (wParam)
3443  			{
3444  				case IDC_CHECK_REMEMBERSESSION:
3445  				{
3446  					nppGUI._rememberLastSession = isCheckedOrNot(IDC_CHECK_REMEMBERSESSION);
3447  					if (!nppGUI._rememberLastSession)
3448  					{
3449  						::SendDlgItemMessage(_hSelf, IDC_BACKUPDIR_RESTORESESSION_CHECK, BM_SETCHECK, BST_UNCHECKED, 0);
3450  						::SendMessage(_hSelf, WM_COMMAND, IDC_BACKUPDIR_RESTORESESSION_CHECK, 0);
3451  					}
3452  					updateBackupSessionGUI();
3453  					return TRUE;
3454  				}
3455  				case IDC_BACKUPDIR_RESTORESESSION_CHECK:
3456  				{
3457  					nppGUI._isSnapshotMode = BST_CHECKED == ::SendDlgItemMessage(_hSelf, IDC_BACKUPDIR_RESTORESESSION_CHECK, BM_GETCHECK, 0, 0);
3458  					updateBackupSessionGUI();
3459  					if (nppGUI._isSnapshotMode)
3460  					{
3461  						::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_ENABLESNAPSHOT, 0, 0);
3462  					}
3463  					return TRUE;
3464  				}
3465  				case IDC_RADIO_BKSIMPLE:
3466  				{
3467  					nppGUI._backup = bak_simple;
3468  					updateBackupOnSaveGUI();
3469  					return TRUE;
3470  				}
3471  				case IDC_RADIO_BKVERBOSE:
3472  				{
3473  					nppGUI._backup = bak_verbose;
3474  					updateBackupOnSaveGUI();
3475  					return TRUE;
3476  				}
3477  				case IDC_RADIO_BKNONE:
3478  				{
3479  					nppGUI._backup = bak_none;
3480  					updateBackupOnSaveGUI();
3481  					return TRUE;
3482  				}
3483  				case IDC_BACKUPDIR_CHECK:
3484  				{
3485  					nppGUI._useDir = !nppGUI._useDir;
3486  					updateBackupOnSaveGUI();
3487  					return TRUE;
3488  				}
3489  				case IDD_BACKUPDIR_BROWSE_BUTTON :
3490  				{
3491  					generic_string title = nppParam.getNativeLangSpeaker()->getLocalizedStrFromID("backup-select-folder",
3492  						TEXT("Select a folder as backup directory"));
3493  					folderBrowser(_hSelf, title, IDC_BACKUPDIR_EDIT);
3494  					return TRUE;
3495  				}
3496  				default :
3497  					return FALSE;
3498  			}
3499  		}
3500  	}
3501  	return FALSE;
3502  }
3503  void BackupSubDlg::updateBackupSessionGUI()
3504  {
3505  	bool rememberSession = isCheckedOrNot(IDC_CHECK_REMEMBERSESSION);
3506  	bool isSnapshot = isCheckedOrNot(IDC_BACKUPDIR_RESTORESESSION_CHECK);
3507  	::EnableWindow(::GetDlgItem(_hSelf, IDC_BACKUPDIR_RESTORESESSION_CHECK), rememberSession);
3508  	::EnableWindow(::GetDlgItem(_hSelf, IDC_BACKUPDIR_RESTORESESSION_EDIT), isSnapshot);
3509  	::EnableWindow(::GetDlgItem(_hSelf, IDD_BACKUPDIR_RESTORESESSION_PATH_EDIT), isSnapshot);
3510  	redrawDlgItem(IDD_BACKUPDIR_RESTORESESSION_STATIC1);
3511  	redrawDlgItem(IDD_BACKUPDIR_RESTORESESSION_STATIC2);
3512  	redrawDlgItem(IDD_BACKUPDIR_RESTORESESSION_PATHLABEL_STATIC);
3513  }
3514  void BackupSubDlg::updateBackupOnSaveGUI()
3515  {
3516  	bool noBackup = BST_CHECKED == ::SendDlgItemMessage(_hSelf, IDC_RADIO_BKNONE, BM_GETCHECK, 0, 0);
3517  	bool isEnableGlobableCheck = false;
3518  	bool isEnableLocalCheck = false;
3519  	if (!noBackup)
3520  	{
3521  		isEnableGlobableCheck = true;
3522  		isEnableLocalCheck = BST_CHECKED == ::SendDlgItemMessage(_hSelf, IDC_BACKUPDIR_CHECK, BM_GETCHECK, 0, 0);
3523  	}
3524  	::EnableWindow(::GetDlgItem(_hSelf, IDC_BACKUPDIR_CHECK), isEnableGlobableCheck);
3525  	::EnableWindow(::GetDlgItem(_hSelf, IDC_BACKUPDIR_EDIT), isEnableLocalCheck);
3526  	::EnableWindow(::GetDlgItem(_hSelf, IDD_BACKUPDIR_BROWSE_BUTTON), isEnableLocalCheck);
3527  	if (NppDarkMode::isEnabled())
3528  	{
3529  		::EnableWindow(::GetDlgItem(_hSelf, IDC_BACKUPDIR_USERCUSTOMDIR_GRPSTATIC), !noBackup);
3530  		redrawDlgItem(IDC_BACKUPDIR_USERCUSTOMDIR_GRPSTATIC);
3531  	}
3532  }
3533  intptr_t CALLBACK AutoCompletionSubDlg::run_dlgProc(UINT message, WPARAM wParam, LPARAM lParam)
3534  {
3535  	NppParameters& nppParam = NppParameters::getInstance();
3536  	NppGUI & nppGUI = nppParam.getNppGUI();
3537  	switch (message) 
3538  	{
3539  		case WM_INITDIALOG :
3540  		{
3541  			::SetDlgItemInt(_hSelf, IDD_AUTOC_STATIC_N,  nppGUI._autocFromLen, FALSE);
3542  			const HWND hNbCharSlider = ::GetDlgItem(_hSelf, IDC_AUTOC_CHAR_SLIDER);
3543  			::SendMessage(hNbCharSlider, TBM_SETRANGEMIN, TRUE, AUTOCOMPLETEFROMCHAR_SMALLEST);
3544  			::SendMessage(hNbCharSlider, TBM_SETRANGEMAX, TRUE, AUTOCOMPLETEFROMCHAR_LARGEST);
3545  			::SendMessage(hNbCharSlider, TBM_SETPAGESIZE, 0, AUTOCOMPLETEFROMCHAR_INTERVAL);
3546  			::SendMessage(hNbCharSlider, TBM_SETPOS, TRUE, nppGUI._autocFromLen);
3547  			bool isEnableAutoC = nppGUI._autocStatus != nppGUI.autoc_none;
3548  			::SendDlgItemMessage(_hSelf, IDD_AUTOC_ENABLECHECK, BM_SETCHECK, isEnableAutoC?BST_CHECKED:BST_UNCHECKED, 0);
3549  			int selectedID = IDD_AUTOC_BOTHRADIO;
3550  			if (nppGUI._autocStatus == nppGUI.autoc_func)
3551  				selectedID = IDD_AUTOC_FUNCRADIO;
3552  			else if (nppGUI._autocStatus == nppGUI.autoc_word)
3553  				selectedID = IDD_AUTOC_WORDRADIO;
3554  			else if (nppGUI._autocStatus == nppGUI.autoc_both)
3555  				selectedID = IDD_AUTOC_BOTHRADIO;
3556  			::SendDlgItemMessage(_hSelf, selectedID, BM_SETCHECK, BST_CHECKED, 0);
3557  			if (nppGUI._autocStatus == nppGUI.autoc_word || nppGUI._autocStatus == nppGUI.autoc_both)
3558  				::SendDlgItemMessage(_hSelf, IDD_AUTOC_IGNORENUMBERS, BM_SETCHECK, nppGUI._autocIgnoreNumbers ? BST_CHECKED : BST_UNCHECKED, 0);
3559  			::SendDlgItemMessage(_hSelf, IDD_AUTOC_USEENTER, BM_SETCHECK, nppGUI._autocInsertSelectedUseENTER ? BST_CHECKED : BST_UNCHECKED, 0);
3560  			::SendDlgItemMessage(_hSelf, IDD_AUTOC_USETAB, BM_SETCHECK, nppGUI._autocInsertSelectedUseTAB ? BST_CHECKED : BST_UNCHECKED, 0);
3561  			if (!isEnableAutoC)
3562  			{
3563  				::EnableWindow(::GetDlgItem(_hSelf, IDD_AUTOC_FUNCRADIO), FALSE);
3564  				::EnableWindow(::GetDlgItem(_hSelf, IDD_AUTOC_WORDRADIO), FALSE);
3565  				::EnableWindow(::GetDlgItem(_hSelf, IDD_AUTOC_BRIEF_CHECK), FALSE);
3566  				::EnableWindow(::GetDlgItem(_hSelf, IDD_AUTOC_BOTHRADIO), FALSE);
3567  				::EnableWindow(::GetDlgItem(_hSelf, IDD_AUTOC_USEENTER), FALSE);
3568  				::EnableWindow(::GetDlgItem(_hSelf, IDD_AUTOC_USETAB), FALSE);
3569  				::EnableWindow(::GetDlgItem(_hSelf, IDD_AUTOC_IGNORENUMBERS), FALSE);
3570  				::EnableWindow(::GetDlgItem(_hSelf, IDC_AUTOC_CHAR_SLIDER), FALSE);
3571  				if (NppDarkMode::isEnabled())
3572  				{
3573  					::EnableWindow(::GetDlgItem(_hSelf, IDD_AUTOC_USEKEY_GRP_STATIC), FALSE);
3574  				}
3575  			}
3576  			::SendDlgItemMessage(_hSelf, IDC_CHECK_MAINTAININDENT, BM_SETCHECK, nppGUI._maitainIndent, 0);
3577  			::SendDlgItemMessage(_hSelf, IDD_AUTOC_BRIEF_CHECK, BM_SETCHECK, nppGUI._autocBrief ? BST_CHECKED : BST_UNCHECKED, 0);
3578  			::SendDlgItemMessage(_hSelf, IDD_FUNC_CHECK, BM_SETCHECK, nppGUI._funcParams ? BST_CHECKED : BST_UNCHECKED, 0);
3579  			::SendDlgItemMessage(_hSelf, IDD_AUTOCPARENTHESES_CHECK, BM_SETCHECK, nppGUI._matchedPairConf._doParentheses?BST_CHECKED:BST_UNCHECKED, 0);
3580  			if (nppGUI._matchedPairConf._doParentheses)
3581  				::SendDlgItemMessage(_hSelf, IDD_AUTOCPARENTHESES_CHECK, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(TEXT(" (  )")));
3582  			::SendDlgItemMessage(_hSelf, IDD_AUTOCBRACKET_CHECK, BM_SETCHECK, nppGUI._matchedPairConf._doBrackets?BST_CHECKED:BST_UNCHECKED, 0);
3583  			if (nppGUI._matchedPairConf._doBrackets)
3584  				::SendDlgItemMessage(_hSelf, IDD_AUTOCBRACKET_CHECK, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(TEXT(" [  ]")));
3585  			::SendDlgItemMessage(_hSelf, IDD_AUTOCCURLYBRACKET_CHECK, BM_SETCHECK, nppGUI._matchedPairConf._doCurlyBrackets?BST_CHECKED:BST_UNCHECKED, 0);
3586  			if (nppGUI._matchedPairConf._doCurlyBrackets)
3587  				::SendDlgItemMessage(_hSelf, IDD_AUTOCCURLYBRACKET_CHECK, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(TEXT(" {  }")));
3588  			::SendDlgItemMessage(_hSelf, IDD_AUTOC_QUOTESCHECK, BM_SETCHECK, nppGUI._matchedPairConf._doQuotes?BST_CHECKED:BST_UNCHECKED, 0);
3589  			if (nppGUI._matchedPairConf._doQuotes)
3590  				::SendDlgItemMessage(_hSelf, IDD_AUTOC_QUOTESCHECK, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(TEXT(" '  '")));
3591  			::SendDlgItemMessage(_hSelf, IDD_AUTOC_DOUBLEQUOTESCHECK, BM_SETCHECK, nppGUI._matchedPairConf._doDoubleQuotes?BST_CHECKED:BST_UNCHECKED, 0);
3592  			if (nppGUI._matchedPairConf._doDoubleQuotes)
3593  				::SendDlgItemMessage(_hSelf, IDD_AUTOC_DOUBLEQUOTESCHECK, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(TEXT(" \"  \"")));
3594  			::SendDlgItemMessage(_hSelf, IDD_AUTOCTAG_CHECK, BM_SETCHECK, nppGUI._matchedPairConf._doHtmlXmlTag?BST_CHECKED:BST_UNCHECKED, 0);
3595  			::SendDlgItemMessage(_hSelf, IDC_MACHEDPAIROPEN_EDIT1, EM_LIMITTEXT, 1, 0);
3596  			::SendDlgItemMessage(_hSelf, IDC_MACHEDPAIRCLOSE_EDIT1, EM_LIMITTEXT, 1, 0);
3597  			::SendDlgItemMessage(_hSelf, IDC_MACHEDPAIROPEN_EDIT2, EM_LIMITTEXT, 1, 0);
3598  			::SendDlgItemMessage(_hSelf, IDC_MACHEDPAIRCLOSE_EDIT2, EM_LIMITTEXT, 1, 0);
3599  			::SendDlgItemMessage(_hSelf, IDC_MACHEDPAIROPEN_EDIT3, EM_LIMITTEXT, 1, 0);
3600  			::SendDlgItemMessage(_hSelf, IDC_MACHEDPAIRCLOSE_EDIT3, EM_LIMITTEXT, 1, 0);
3601  			size_t nbMatchedPair = nppGUI._matchedPairConf._matchedPairsInit.size();
3602  			if (nbMatchedPair > 3)
3603  				nbMatchedPair = 3;
3604  			for (size_t i = 0; i < nbMatchedPair; ++i)
3605  			{
3606  				TCHAR openChar[2]{};
3607  				openChar[0] = nppGUI._matchedPairConf._matchedPairsInit[i].first;
3608  				openChar[1] = '\0';
3609  				TCHAR closeChar[2]{};
3610  				closeChar[0] = nppGUI._matchedPairConf._matchedPairsInit[i].second;
3611  				closeChar[1] = '\0';
3612  				if (i == 0)
3613  				{
3614  					::SendDlgItemMessage(_hSelf, IDC_MACHEDPAIROPEN_EDIT1, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(openChar));
3615  					::SendDlgItemMessage(_hSelf, IDC_MACHEDPAIRCLOSE_EDIT1, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(closeChar));
3616  				}
3617  				else if (i == 1)
3618  				{
3619  					::SendDlgItemMessage(_hSelf, IDC_MACHEDPAIROPEN_EDIT2, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(openChar));
3620  					::SendDlgItemMessage(_hSelf, IDC_MACHEDPAIRCLOSE_EDIT2, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(closeChar));
3621  				}
3622  				if (i == 2)
3623  				{
3624  					::SendDlgItemMessage(_hSelf, IDC_MACHEDPAIROPEN_EDIT3, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(openChar));
3625  					::SendDlgItemMessage(_hSelf, IDC_MACHEDPAIRCLOSE_EDIT3, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(closeChar));
3626  				}
3627  			}
3628  			return TRUE;
3629  		}
3630  		case WM_CTLCOLOREDIT:
3631  		{
3632  			return NppDarkMode::onCtlColorSofter(reinterpret_cast<HDC>(wParam));
3633  		}
3634  		case WM_CTLCOLORDLG:
3635  		{
3636  			return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
3637  		}
3638  		case WM_CTLCOLORSTATIC:
3639  		{
3640  			const auto hdcStatic = reinterpret_cast<HDC>(wParam);
3641  			const auto dlgCtrlID = ::GetDlgCtrlID(reinterpret_cast<HWND>(lParam));
3642  			const bool isStaticText = (dlgCtrlID == IDD_AUTOC_STATIC_FROM ||
3643  				dlgCtrlID == IDD_AUTOC_STATIC_CHAR ||
3644  				dlgCtrlID == IDD_AUTOC_STATIC_N ||
3645  				dlgCtrlID == IDD_AUTOC_SLIDER_MIN_STATIC ||
3646  				dlgCtrlID == IDD_AUTOC_SLIDER_MAX_STATIC);
3647  			if (isStaticText)
3648  			{
3649  				const bool isTextEnabled = isCheckedOrNot(IDD_AUTOC_ENABLECHECK);
3650  				return NppDarkMode::onCtlColorDarkerBGStaticText(hdcStatic, isTextEnabled);
3651  			}
3652  			return NppDarkMode::onCtlColorDarker(hdcStatic);
3653  		}
3654  		case WM_PRINTCLIENT:
3655  		{
3656  			if (NppDarkMode::isEnabled())
3657  			{
3658  				return TRUE;
3659  			}
3660  			break;
3661  		}
3662  		case WM_HSCROLL:
3663  		{
3664  			const HWND hNbCharSlider = ::GetDlgItem(_hSelf, IDC_AUTOC_CHAR_SLIDER);
3665  			if (hNbCharSlider == reinterpret_cast<HWND>(lParam))
3666  			{
3667  				nppGUI._autocFromLen = static_cast<UINT>(::SendMessage(hNbCharSlider, TBM_GETPOS, 0, 0));
3668  				::SetDlgItemInt(_hSelf, IDD_AUTOC_STATIC_N, nppGUI._autocFromLen, FALSE);
3669  			}
3670  			return 0; 
3671  		}
3672  		case WM_COMMAND : 
3673  		{
3674  			if (HIWORD(wParam) == EN_CHANGE)
3675  			{
3676  				switch (LOWORD(wParam))
3677  				{
3678  					case IDC_MACHEDPAIROPEN_EDIT1 :
3679  					case IDC_MACHEDPAIRCLOSE_EDIT1:
3680  					case IDC_MACHEDPAIROPEN_EDIT2 :
3681  					case IDC_MACHEDPAIRCLOSE_EDIT2:
3682  					case IDC_MACHEDPAIROPEN_EDIT3 :
3683  					case IDC_MACHEDPAIRCLOSE_EDIT3:
3684  					{
3685  						nppGUI._matchedPairConf._matchedPairs.clear();
3686  						TCHAR opener[2] = {'\0', '\0'};
3687  						TCHAR closer[2] = {'\0', '\0'};
3688  						::SendDlgItemMessage(_hSelf, IDC_MACHEDPAIROPEN_EDIT1, WM_GETTEXT, MAX_PATH, reinterpret_cast<LPARAM>(opener));
3689  						::SendDlgItemMessage(_hSelf, IDC_MACHEDPAIRCLOSE_EDIT1, WM_GETTEXT, MAX_PATH, reinterpret_cast<LPARAM>(closer));
3690  						if (opener[0] < 0x80 && opener[0] != '\0' && closer[0] < 0x80 && closer[0] != '\0')
3691  							nppGUI._matchedPairConf._matchedPairs.push_back(pair<char, char>(static_cast<char>(opener[0]), static_cast<char>(closer[0])));
3692  						::SendDlgItemMessage(_hSelf, IDC_MACHEDPAIROPEN_EDIT2, WM_GETTEXT, MAX_PATH, reinterpret_cast<LPARAM>(opener));
3693  						::SendDlgItemMessage(_hSelf, IDC_MACHEDPAIRCLOSE_EDIT2, WM_GETTEXT, MAX_PATH, reinterpret_cast<LPARAM>(closer));
3694  						if (opener[0] < 0x80 && opener[0] != '\0' && closer[0] < 0x80 && closer[0] != '\0')
3695  							nppGUI._matchedPairConf._matchedPairs.push_back(pair<char, char>(static_cast<char>(opener[0]), static_cast<char>(closer[0])));
3696  						::SendDlgItemMessage(_hSelf, IDC_MACHEDPAIROPEN_EDIT3, WM_GETTEXT, MAX_PATH, reinterpret_cast<LPARAM>(opener));
3697  						::SendDlgItemMessage(_hSelf, IDC_MACHEDPAIRCLOSE_EDIT3, WM_GETTEXT, MAX_PATH, reinterpret_cast<LPARAM>(closer));
3698  						if (opener[0] < 0x80 && opener[0] != '\0' && closer[0] < 0x80 && closer[0] != '\0')
3699  							nppGUI._matchedPairConf._matchedPairs.push_back(pair<char, char>(static_cast<char>(opener[0]), static_cast<char>(closer[0])));
3700  						return TRUE;
3701  					}
3702  				}
3703  			}
3704  			switch (wParam)
3705  			{
3706  				case IDC_CHECK_MAINTAININDENT:
3707  				{
3708  					nppGUI._maitainIndent = isCheckedOrNot(IDC_CHECK_MAINTAININDENT);
3709  					return TRUE;
3710  				}
3711  				case IDD_AUTOC_ENABLECHECK :
3712  				{
3713  					bool isEnableAutoC = BST_CHECKED == ::SendDlgItemMessage(_hSelf, IDD_AUTOC_ENABLECHECK, BM_GETCHECK, 0, 0);
3714  					if (isEnableAutoC)
3715  					{
3716  						::SendDlgItemMessage(_hSelf, IDD_AUTOC_BOTHRADIO, BM_SETCHECK, BST_CHECKED, 0);
3717  						nppGUI._autocStatus = nppGUI.autoc_both;
3718  						::SendDlgItemMessage(_hSelf, IDD_AUTOC_IGNORENUMBERS, BM_SETCHECK, BST_UNCHECKED, 0);
3719  						nppGUI._autocIgnoreNumbers = false;
3720  					}
3721  					else 
3722  					{
3723  						::SendDlgItemMessage(_hSelf, IDD_AUTOC_FUNCRADIO, BM_SETCHECK, BST_UNCHECKED, 0);
3724  						::SendDlgItemMessage(_hSelf, IDD_AUTOC_WORDRADIO, BM_SETCHECK, BST_UNCHECKED, 0);
3725  						::SendDlgItemMessage(_hSelf, IDD_AUTOC_BOTHRADIO, BM_SETCHECK, BST_UNCHECKED, 0);
3726  						::SendDlgItemMessage(_hSelf, IDD_AUTOC_BRIEF_CHECK, BM_SETCHECK, BST_UNCHECKED, 0);
3727  						nppGUI._autocBrief = false;
3728  						nppGUI._autocStatus = nppGUI.autoc_none;
3729  						::SendDlgItemMessage(_hSelf, IDD_AUTOC_IGNORENUMBERS, BM_SETCHECK, BST_UNCHECKED, 0);
3730  						nppGUI._autocIgnoreNumbers = false;
3731  					}
3732  					::EnableWindow(::GetDlgItem(_hSelf, IDD_AUTOC_FUNCRADIO), isEnableAutoC);
3733  					::EnableWindow(::GetDlgItem(_hSelf, IDD_AUTOC_WORDRADIO), isEnableAutoC);
3734  					::EnableWindow(::GetDlgItem(_hSelf, IDD_AUTOC_BOTHRADIO), isEnableAutoC);
3735  					::EnableWindow(::GetDlgItem(_hSelf, IDD_AUTOC_BRIEF_CHECK), isEnableAutoC);
3736  					::EnableWindow(::GetDlgItem(_hSelf, IDD_AUTOC_USEKEY_GRP_STATIC), isEnableAutoC);
3737  					::EnableWindow(::GetDlgItem(_hSelf, IDD_AUTOC_USEENTER), isEnableAutoC);
3738  					::EnableWindow(::GetDlgItem(_hSelf, IDD_AUTOC_USETAB), isEnableAutoC);
3739  					::EnableWindow(::GetDlgItem(_hSelf, IDD_AUTOC_IGNORENUMBERS), isEnableAutoC);
3740  					::EnableWindow(::GetDlgItem(_hSelf, IDC_AUTOC_CHAR_SLIDER), isEnableAutoC);
3741  					redrawDlgItem(IDD_AUTOC_STATIC_FROM);
3742  					redrawDlgItem(IDD_AUTOC_STATIC_N);
3743  					redrawDlgItem(IDD_AUTOC_STATIC_CHAR);
3744  					redrawDlgItem(IDD_AUTOC_SLIDER_MIN_STATIC);
3745  					redrawDlgItem(IDD_AUTOC_SLIDER_MAX_STATIC);
3746  					if (NppDarkMode::isEnabled())
3747  					{
3748  						::EnableWindow(::GetDlgItem(_hSelf, IDD_AUTOC_USEKEY_GRP_STATIC), isEnableAutoC);
3749  						redrawDlgItem(IDD_AUTOC_USEKEY_GRP_STATIC);
3750  					}
3751  					return TRUE;
3752  				}
3753  				case IDD_AUTOC_FUNCRADIO :
3754  				{
3755  					nppGUI._autocStatus = nppGUI.autoc_func;
3756  					::SendDlgItemMessage(_hSelf, IDD_AUTOC_IGNORENUMBERS, BM_SETCHECK, BST_UNCHECKED, 0);
3757  					::EnableWindow(::GetDlgItem(_hSelf, IDD_AUTOC_IGNORENUMBERS), FALSE);
3758  					nppGUI._autocIgnoreNumbers = false;
3759  					::SendDlgItemMessage(_hSelf, IDD_AUTOC_BRIEF_CHECK, BM_SETCHECK, BST_UNCHECKED, 0);
3760  					nppGUI._autocBrief = false;
3761  					return TRUE;
3762  				}
3763  				case IDD_AUTOC_WORDRADIO :
3764  				{
3765  					nppGUI._autocStatus = nppGUI.autoc_word;
3766  					::EnableWindow(::GetDlgItem(_hSelf, IDD_AUTOC_IGNORENUMBERS), TRUE);
3767  					return TRUE;
3768  				}
3769  				case IDD_AUTOC_BOTHRADIO :
3770  				{
3771  					nppGUI._autocStatus = nppGUI.autoc_both;
3772  					::EnableWindow(::GetDlgItem(_hSelf, IDD_AUTOC_IGNORENUMBERS), TRUE);
3773  					return TRUE;
3774  				}
3775  				case IDD_AUTOC_USEENTER:
3776  				{
3777  					nppGUI._autocInsertSelectedUseENTER = isCheckedOrNot(static_cast<int32_t>(wParam));
3778  					return TRUE;
3779  				}
3780  				case IDD_AUTOC_USETAB:
3781  				{
3782  					nppGUI._autocInsertSelectedUseTAB = isCheckedOrNot(static_cast<int32_t>(wParam));
3783  					return TRUE;
3784  				}
3785  				case IDD_AUTOC_IGNORENUMBERS:
3786  				{
3787  					nppGUI._autocIgnoreNumbers = isCheckedOrNot(static_cast<int32_t>(wParam));
3788  					return TRUE;
3789  				}
3790  				case IDD_AUTOC_BRIEF_CHECK :
3791  				{
3792  					nppGUI._autocBrief = isCheckedOrNot(static_cast<int32_t>(wParam));
3793  					return TRUE;
3794  				}
3795  				case IDD_FUNC_CHECK :
3796  				{
3797  					nppGUI._funcParams = isCheckedOrNot(static_cast<int32_t>(wParam));
3798  					return TRUE;
3799  				}
3800  				case IDD_AUTOCPARENTHESES_CHECK :
3801  				case IDD_AUTOCBRACKET_CHECK :
3802  				case IDD_AUTOCCURLYBRACKET_CHECK :
3803  				case IDD_AUTOC_DOUBLEQUOTESCHECK :
3804  				case IDD_AUTOC_QUOTESCHECK :
3805  				{
3806  					bool isChecked = isCheckedOrNot(static_cast<int32_t>(wParam));
3807  					const TCHAR *label = nullptr;
3808  					if (wParam == IDD_AUTOCPARENTHESES_CHECK)
3809  					{
3810  						nppGUI._matchedPairConf._doParentheses = isChecked;
3811  						label = isChecked?TEXT(" (  )"):TEXT(" (");
3812  					}
3813  					else if (wParam == IDD_AUTOCBRACKET_CHECK)
3814  					{
3815  						nppGUI._matchedPairConf._doBrackets = isChecked;
3816  						label = isChecked?TEXT(" [  ]"):TEXT(" [");
3817  					}
3818  					else if (wParam == IDD_AUTOCCURLYBRACKET_CHECK)
3819  					{
3820  						nppGUI._matchedPairConf._doCurlyBrackets = isChecked;
3821  						label = isChecked?TEXT(" {  }"):TEXT(" {");
3822  					}
3823  					else if (wParam == IDD_AUTOC_DOUBLEQUOTESCHECK)
3824  					{
3825  						nppGUI._matchedPairConf._doDoubleQuotes = isChecked;
3826  						label = isChecked?TEXT(" \"  \""):TEXT(" \"");
3827  					}
3828  					else 
3829  					{
3830  						nppGUI._matchedPairConf._doQuotes = isChecked;
3831  						label = isChecked?TEXT(" '  '"):TEXT(" '");
3832  					}
3833  					::SendDlgItemMessage(_hSelf, static_cast<int32_t>(wParam), WM_SETTEXT, 0, reinterpret_cast<LPARAM>(label));
3834  					return TRUE;
3835  				}
3836  				case IDD_AUTOCTAG_CHECK :
3837  				{
3838  					nppGUI._matchedPairConf._doHtmlXmlTag = (BST_CHECKED == ::SendDlgItemMessage(_hSelf, IDD_AUTOCTAG_CHECK, BM_GETCHECK, 0, 0));
3839  					return TRUE;
3840  				}
3841  				default :
3842  					return FALSE;
3843  			}
3844  		}
3845  	}
3846  	return FALSE;
3847  }
3848  intptr_t CALLBACK MultiInstanceSubDlg::run_dlgProc(UINT message, WPARAM wParam, LPARAM)
3849  {
3850  	NppGUI & nppGUI = (NppParameters::getInstance()).getNppGUI();
3851  	switch (message) 
3852  	{
3853  		case WM_INITDIALOG :
3854  		{
3855  			auto checkOrUncheckBtn = [this](int id, bool check) -> void
3856  			{
3857  				::SendDlgItemMessage(_hSelf, id, BM_SETCHECK, check ? BST_CHECKED : BST_UNCHECKED, 0);
3858  			};
3859  			checkOrUncheckBtn(IDC_CHECK_CLIPBOARDHISTORY, nppGUI._clipboardHistoryPanelKeepState);
3860  			checkOrUncheckBtn(IDC_CHECK_DOCLIST, nppGUI._docListKeepState);
3861  			checkOrUncheckBtn(IDC_CHECK_CHARPANEL, nppGUI._charPanelKeepState);
3862  			checkOrUncheckBtn(IDC_CHECK_FILEBROWSER, nppGUI._fileBrowserKeepState);
3863  			checkOrUncheckBtn(IDC_CHECK_PROJECTPANEL, nppGUI._projectPanelKeepState);
3864  			checkOrUncheckBtn(IDC_CHECK_DOCMAP, nppGUI._docMapKeepState);
3865  			checkOrUncheckBtn(IDC_CHECK_FUNCLIST, nppGUI._funcListKeepState);
3866  			checkOrUncheckBtn(IDC_CHECK_PLUGINPANEL, nppGUI._pluginPanelKeepState);
3867  			MultiInstSetting multiInstSetting = nppGUI._multiInstSetting;
3868  			::SendDlgItemMessage(_hSelf, IDC_SESSIONININST_RADIO, BM_SETCHECK, multiInstSetting == multiInstOnSession?BST_CHECKED:BST_UNCHECKED, 0);
3869  			::SendDlgItemMessage(_hSelf, IDC_MULTIINST_RADIO, BM_SETCHECK, multiInstSetting == multiInst?BST_CHECKED:BST_UNCHECKED, 0);
3870  			::SendDlgItemMessage(_hSelf, IDC_MONOINST_RADIO, BM_SETCHECK, multiInstSetting == monoInst?BST_CHECKED:BST_UNCHECKED, 0);
3871  			::SendDlgItemMessage(_hSelf, IDD_DATETIMEFORMAT_REVERSEORDER_CHECK, BM_SETCHECK, nppGUI._dateTimeReverseDefaultOrder ? BST_CHECKED : BST_UNCHECKED, 0);
3872  			::SetDlgItemText(_hSelf, IDC_DATETIMEFORMAT_EDIT, nppGUI._dateTimeFormat.c_str());
3873  			generic_string datetimeStr = getDateTimeStrFrom(nppGUI._dateTimeFormat, _BTTF_time);
3874  			::SetDlgItemText(_hSelf, IDD_DATETIMEFORMAT_RESULT_STATIC, datetimeStr.c_str());
3875  			return TRUE;
3876  		}
3877  		case WM_CTLCOLOREDIT:
3878  		{
3879  			return NppDarkMode::onCtlColorSofter(reinterpret_cast<HDC>(wParam));
3880  		}
3881  		case WM_CTLCOLORDLG:
3882  		case WM_CTLCOLORSTATIC:
3883  		{
3884  			return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
3885  		}
3886  		case WM_PRINTCLIENT:
3887  		{
3888  			if (NppDarkMode::isEnabled())
3889  			{
3890  				return TRUE;
3891  			}
3892  			break;
3893  		}
3894  		case WM_COMMAND : 
3895  		{
3896  			if (HIWORD(wParam) == EN_CHANGE && LOWORD(wParam) == IDC_DATETIMEFORMAT_EDIT)
3897  			{
3898  				constexpr size_t inputLen = 256;
3899  				TCHAR input[inputLen]{};
3900  				::GetDlgItemText(_hSelf, IDC_DATETIMEFORMAT_EDIT, input, inputLen);
3901  				nppGUI._dateTimeFormat = input;
3902  				generic_string datetimeStr = getDateTimeStrFrom(nppGUI._dateTimeFormat, _BTTF_time);
3903  				::SetDlgItemText(_hSelf, IDD_DATETIMEFORMAT_RESULT_STATIC, datetimeStr.c_str());
3904  				return TRUE;
3905  			}
3906  			switch (wParam)
3907  			{
3908  				case IDC_SESSIONININST_RADIO :
3909  				{
3910  					nppGUI._multiInstSetting = multiInstOnSession;
3911  				}
3912  				break;
3913  				case IDC_MULTIINST_RADIO :
3914  				{
3915  					nppGUI._multiInstSetting = multiInst;
3916  				}
3917  				break;
3918  				case IDC_MONOINST_RADIO :
3919  				{
3920  					nppGUI._multiInstSetting = monoInst;
3921  				}
3922  				break;
3923  				case IDD_DATETIMEFORMAT_REVERSEORDER_CHECK:
3924  				{
3925  					nppGUI._dateTimeReverseDefaultOrder = isCheckedOrNot(IDD_DATETIMEFORMAT_REVERSEORDER_CHECK);
3926  				}
3927  				break;
3928  				case IDC_CHECK_CLIPBOARDHISTORY:
3929  				{
3930  					nppGUI._clipboardHistoryPanelKeepState = isCheckedOrNot(IDC_CHECK_CLIPBOARDHISTORY);
3931  				}
3932  				break;
3933  				case IDC_CHECK_DOCLIST:
3934  				{
3935  					nppGUI._docListKeepState = isCheckedOrNot(IDC_CHECK_DOCLIST);
3936  				}
3937  				break;
3938  				case IDC_CHECK_CHARPANEL:
3939  				{
3940  					nppGUI._charPanelKeepState = isCheckedOrNot(IDC_CHECK_CHARPANEL);
3941  				}
3942  				break;
3943  				case IDC_CHECK_FILEBROWSER:
3944  				{
3945  					nppGUI._fileBrowserKeepState = isCheckedOrNot(IDC_CHECK_FILEBROWSER);
3946  				}
3947  				break;
3948  				case IDC_CHECK_PROJECTPANEL:
3949  				{
3950  					nppGUI._projectPanelKeepState = isCheckedOrNot(IDC_CHECK_PROJECTPANEL);
3951  				}
3952  				break;
3953  				case IDC_CHECK_DOCMAP:
3954  				{
3955  					nppGUI._docMapKeepState = isCheckedOrNot(IDC_CHECK_DOCMAP);
3956  				}
3957  				break;
3958  				case IDC_CHECK_FUNCLIST:
3959  				{
3960  					nppGUI._funcListKeepState = isCheckedOrNot(IDC_CHECK_FUNCLIST);
3961  				}
3962  				break;
3963  				case IDC_CHECK_PLUGINPANEL:
3964  				{
3965  					nppGUI._pluginPanelKeepState = isCheckedOrNot(IDC_CHECK_PLUGINPANEL);
3966  				}
3967  				break;
3968  				default :
3969  					return FALSE;
3970  			}
3971  		}
3972  		break;
3973  	}
3974  	return FALSE;
3975  }
3976  void DelimiterSubDlg::detectSpace(const char *text2Check, int & nbSp, int & nbTab) const
3977  {
3978  	nbSp = nbTab = 0;
3979  	for (size_t i = 0; i < strlen(text2Check); ++i)
3980  	{
3981  		if (text2Check[i] == ' ')
3982  			++nbSp;
3983  		else if (text2Check[i] == '\t')
3984  			++nbTab;
3985  	}
3986  }
3987  generic_string DelimiterSubDlg::getWarningText(size_t nbSp, size_t nbTab) const
3988  {
3989  	NativeLangSpeaker *pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
3990  	generic_string msg;
3991  	if (nbSp && nbTab)
3992  	{
3993  		generic_string nbSpStr = std::to_wstring(nbSp);
3994  		generic_string nbTabStr = std::to_wstring(nbTab);
3995  		generic_string warnBegin = pNativeSpeaker->getLocalizedStrFromID("word-chars-list-warning-begin", TEXT(""));
3996  		generic_string space = pNativeSpeaker->getLocalizedStrFromID("word-chars-list-space-warning", TEXT(""));
3997  		generic_string tab = pNativeSpeaker->getLocalizedStrFromID("word-chars-list-tab-warning", TEXT(""));
3998  		generic_string warnEnd = pNativeSpeaker->getLocalizedStrFromID("word-chars-list-warning-end", TEXT(""));
3999  		if (!warnBegin.empty() && !space.empty() && !tab.empty() && !warnEnd.empty())
4000  		{
4001  			space = stringReplace(space, TEXT("$INT_REPLACE$"), nbSpStr);
4002  			tab = stringReplace(tab, TEXT("$INT_REPLACE$"), nbTabStr);
4003  			msg = warnBegin;
4004  			msg += space;
4005  			msg += TEXT(" && ");
4006  			msg += tab;
4007  			msg += warnEnd;
4008  		}
4009  		else
4010  		{
4011  			msg = TEXT("Be aware: ");
4012  			msg += nbSpStr;
4013  			msg += TEXT(" space(s) && ");
4014  			msg += std::to_wstring(nbTab);
4015  			msg += TEXT(" TAB(s) in your character list.");
4016  		}
4017  	}
4018  	else if (nbSp && !nbTab)
4019  	{
4020  		generic_string nbSpStr = std::to_wstring(nbSp);
4021  		generic_string warnBegin = pNativeSpeaker->getLocalizedStrFromID("word-chars-list-warning-begin", TEXT(""));
4022  		generic_string space = pNativeSpeaker->getLocalizedStrFromID("word-chars-list-space-warning", TEXT(""));
4023  		generic_string warnEnd = pNativeSpeaker->getLocalizedStrFromID("word-chars-list-warning-end", TEXT(""));
4024  		if (!warnBegin.empty() && !space.empty() && !warnEnd.empty())
4025  		{
4026  			space = stringReplace(space, TEXT("$INT_REPLACE$"), nbSpStr);
4027  			msg = warnBegin;
4028  			msg += space;
4029  			msg += warnEnd;
4030  		}
4031  		else
4032  		{
4033  			msg = TEXT("Be aware: ");
4034  			msg += std::to_wstring(nbSp);
4035  			msg += TEXT(" space(s) in your character list.");
4036  		}
4037  	}
4038  	else if (!nbSp && nbTab)
4039  	{
4040  		generic_string nbTabStr = std::to_wstring(nbTab);
4041  		generic_string warnBegin = pNativeSpeaker->getLocalizedStrFromID("word-chars-list-warning-begin", TEXT(""));
4042  		generic_string tab = pNativeSpeaker->getLocalizedStrFromID("word-chars-list-tab-warning", TEXT(""));
4043  		generic_string warnEnd = pNativeSpeaker->getLocalizedStrFromID("word-chars-list-warning-end", TEXT(""));
4044  		if (!warnBegin.empty() && !tab.empty() && !warnEnd.empty())
4045  		{
4046  			tab = stringReplace(tab, TEXT("$INT_REPLACE$"), nbTabStr);
4047  			msg = warnBegin;
4048  			msg += tab;
4049  			msg += warnEnd;
4050  		}
4051  		else
4052  		{
4053  			msg = TEXT("Be aware: ");
4054  			msg += std::to_wstring(nbTab);
4055  			msg += TEXT(" TAB(s) in your character list.");
4056  		}
4057  	}
4058  	else 
4059  	{
4060  	}
4061  	return msg;
4062  }
4063  void DelimiterSubDlg::setWarningIfNeed() const
4064  {
4065  	generic_string msg;
4066  	NppGUI & nppGUI = (NppParameters::getInstance()).getNppGUI();
4067  	if (!nppGUI._isWordCharDefault)
4068  	{
4069  		int nbSp = 0;
4070  		int nbTab = 0;
4071  		detectSpace(nppGUI._customWordChars.c_str(), nbSp, nbTab);
4072  		msg = getWarningText(nbSp, nbTab);
4073  	}
4074  	::SetDlgItemText(_hSelf, IDD_STATIC_WORDCHAR_WARNING, msg.c_str());
4075  }
4076  intptr_t CALLBACK DelimiterSubDlg::run_dlgProc(UINT message, WPARAM wParam, LPARAM lParam)
4077  {
4078  	NppGUI & nppGUI = (NppParameters::getInstance()).getNppGUI();
4079  	switch (message) 
4080  	{
4081  		case WM_INITDIALOG :
4082  		{
4083  			TCHAR opener[2]{};
4084  			opener[0] = nppGUI._leftmostDelimiter;
4085  			opener[1] = '\0';
4086  			TCHAR closer[2]{};
4087  			closer[0] = nppGUI._rightmostDelimiter;
4088  			closer[1] = '\0';
4089  			bool onSeveralLines = nppGUI._delimiterSelectionOnEntireDocument;
4090  			::SendDlgItemMessage(_hSelf, IDC_EDIT_OPENDELIMITER, EM_LIMITTEXT, 1, 0);
4091  			::SendDlgItemMessage(_hSelf, IDC_EDIT_CLOSEDELIMITER, EM_LIMITTEXT, 1, 0);
4092  			::SendDlgItemMessage(_hSelf, IDC_EDIT_OPENDELIMITER, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(opener));
4093  			::SendDlgItemMessage(_hSelf, IDC_EDIT_CLOSEDELIMITER, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(closer));
4094  			::SendDlgItemMessage(_hSelf, IDD_SEVERALLINEMODEON_CHECK, BM_SETCHECK, onSeveralLines?BST_CHECKED:BST_UNCHECKED, 0);
4095  			POINT point = getTopPoint(::GetDlgItem(_hSelf, IDD_STATIC_BLABLA), false);
4096  			_singleLineModePoint.x = point.x + 4;
4097  			_singleLineModePoint.y = point.y - 4;
4098  			point = getTopPoint(::GetDlgItem(_hSelf, IDD_STATIC_BLABLA2NDLINE), false);
4099  			_multiLineModePoint.x = point.x + 4;
4100  			_multiLineModePoint.y = point.y - 4;
4101  			::GetClientRect(::GetDlgItem(_hSelf, IDC_EDIT_CLOSEDELIMITER), &_closerRect);
4102  			_closerRect.right = _closerRect.right - _closerRect.left + 4;
4103  			_closerRect.bottom = _closerRect.bottom - _closerRect.top + 4;
4104  			::GetClientRect(::GetDlgItem(_hSelf, IDD_STATIC_CLOSEDELIMITER), &_closerLabelRect);
4105  			_closerLabelRect.right = _closerLabelRect.right - _closerLabelRect.left + 4;
4106  			_closerLabelRect.bottom = _closerLabelRect.bottom - _closerLabelRect.top + 4;
4107  			::ShowWindow(::GetDlgItem(_hSelf, IDD_STATIC_BLABLA2NDLINE),onSeveralLines?SW_SHOW:SW_HIDE);
4108  			POINT *p = onSeveralLines?&_multiLineModePoint:&_singleLineModePoint;
4109  			::MoveWindow(::GetDlgItem(_hSelf, IDC_EDIT_CLOSEDELIMITER), p->x, p->y, _closerRect.right, _closerRect.bottom, TRUE);
4110  			::MoveWindow(::GetDlgItem(_hSelf, IDD_STATIC_CLOSEDELIMITER), p->x + _closerRect.right + 4, p->y + 4, _closerLabelRect.right, _closerLabelRect.bottom, TRUE);
4111  			::SetDlgItemTextA(_hSelf, IDC_WORDCHAR_CUSTOM_EDIT, nppGUI._customWordChars.c_str());
4112  			::SendDlgItemMessage(_hSelf, IDC_RADIO_WORDCHAR_DEFAULT, BM_SETCHECK, nppGUI._isWordCharDefault ? BST_CHECKED : BST_UNCHECKED, 0);
4113  			::SendDlgItemMessage(_hSelf, IDC_RADIO_WORDCHAR_CUSTOM, BM_SETCHECK, !nppGUI._isWordCharDefault ? BST_CHECKED : BST_UNCHECKED, 0);
4114  			::EnableWindow(::GetDlgItem(_hSelf, IDC_WORDCHAR_CUSTOM_EDIT), !nppGUI._isWordCharDefault);
4115  			setWarningIfNeed();
4116  			NativeLangSpeaker *pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
4117  			generic_string tip2show = pNativeSpeaker->getLocalizedStrFromID("word-chars-list-tip", TEXT("This allows you to include additional character into current word characters while double clicking for selection or searching with \"Match whole word only\" option checked."));
4118  			_tip = CreateToolTip(IDD_WORDCHAR_QUESTION_BUTTON, _hSelf, _hInst, const_cast<PTSTR>(tip2show.c_str()), pNativeSpeaker->isRTL());
4119  			if (_tip)
4120  			{
4121  				SendMessage(_tip, TTM_SETDELAYTIME, TTDT_AUTOPOP, MAKELPARAM((30000), (0)));
4122  			}
4123  			return TRUE;
4124  		}
4125  		case WM_CTLCOLOREDIT:
4126  		{
4127  			return NppDarkMode::onCtlColorSofter(reinterpret_cast<HDC>(wParam));
4128  		}
4129  		case WM_CTLCOLORDLG:
4130  		{
4131  			return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
4132  		}
4133  		case WM_CTLCOLORSTATIC:
4134  		{
4135  			auto hdcStatic = reinterpret_cast<HDC>(wParam);
4136  			auto dlgCtrlID = ::GetDlgCtrlID(reinterpret_cast<HWND>(lParam));
4137  			bool isBlabla = (dlgCtrlID == IDD_STATIC_BLABLA) || (dlgCtrlID == IDD_STATIC_BLABLA2NDLINE);
4138  			if (NppDarkMode::isEnabled())
4139  			{
4140  				if (isBlabla)
4141  				{
4142  					return NppDarkMode::onCtlColor(hdcStatic);
4143  				}
4144  				return NppDarkMode::onCtlColorDarker(hdcStatic);
4145  			}
4146  			else if (isBlabla)
4147  			{
4148  				COLORREF bgColor = getCtrlBgColor(_hSelf);
4149  				SetTextColor(hdcStatic, RGB(0, 0, 0));
4150  				BYTE r = GetRValue(bgColor) - 30;
4151  				BYTE g = MyGetGValue(bgColor) - 30;
4152  				BYTE b = GetBValue(bgColor) - 30;
4153  				SetBkColor(hdcStatic, RGB(r, g, b));
4154  				return TRUE;
4155  			}
4156  			break;
4157  		}
4158  		case WM_PRINTCLIENT:
4159  		{
4160  			if (NppDarkMode::isEnabled())
4161  			{
4162  				return TRUE;
4163  			}
4164  			break;
4165  		}
4166  		case WM_COMMAND : 
4167  		{
4168  			if (HIWORD(wParam) == EN_CHANGE)
4169  			{
4170  				switch (LOWORD(wParam))
4171  				{
4172  					case  IDC_EDIT_OPENDELIMITER:
4173  					{
4174  						TCHAR opener[2] = { '\0' };
4175  						::SendDlgItemMessage(_hSelf, IDC_EDIT_OPENDELIMITER, WM_GETTEXT, MAX_PATH, reinterpret_cast<LPARAM>(opener));
4176  						nppGUI._leftmostDelimiter =  static_cast<char>(opener[0]);
4177  						return TRUE;
4178  					}
4179  					case  IDC_EDIT_CLOSEDELIMITER:
4180  					{
4181  						TCHAR closer[2] = { '\0' };
4182  						::SendDlgItemMessage(_hSelf, IDC_EDIT_CLOSEDELIMITER, WM_GETTEXT, MAX_PATH, reinterpret_cast<LPARAM>(closer));
4183  						nppGUI._rightmostDelimiter =  static_cast<char>(closer[0]);
4184  						return TRUE;
4185  					}
4186  					case  IDC_WORDCHAR_CUSTOM_EDIT:
4187  					{
4188  						char customText[MAX_PATH];
4189  						::GetDlgItemTextA(_hSelf, IDC_WORDCHAR_CUSTOM_EDIT, customText, MAX_PATH-1);
4190  						nppGUI._customWordChars = customText;
4191  						setWarningIfNeed();
4192  						::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_SETWORDCHARS, 0, 0);
4193  						return TRUE;
4194  					}
4195  					default:
4196  						return FALSE;
4197  				}
4198  			}
4199  			switch (wParam)
4200  			{
4201  				case IDD_SEVERALLINEMODEON_CHECK :
4202  				{
4203  					bool isChecked = (BST_CHECKED == ::SendDlgItemMessage(_hSelf, IDD_SEVERALLINEMODEON_CHECK, BM_GETCHECK, 0, 0));
4204  					nppGUI._delimiterSelectionOnEntireDocument = isChecked;
4205  					::ShowWindow(::GetDlgItem(_hSelf, IDD_STATIC_BLABLA2NDLINE),isChecked?SW_SHOW:SW_HIDE);
4206  					POINT *p = isChecked?&_multiLineModePoint:&_singleLineModePoint;
4207  					::MoveWindow(::GetDlgItem(_hSelf, IDC_EDIT_CLOSEDELIMITER), p->x, p->y, _closerRect.right, _closerRect.bottom, TRUE);
4208  					::MoveWindow(::GetDlgItem(_hSelf, IDD_STATIC_CLOSEDELIMITER), p->x + _closerRect.right + 4, p->y + 4, _closerLabelRect.right, _closerLabelRect.bottom, TRUE);
4209  					return TRUE;
4210  				}
4211  				case IDC_RADIO_WORDCHAR_DEFAULT:
4212  				{
4213  					::SendDlgItemMessage(_hSelf, IDC_RADIO_WORDCHAR_CUSTOM, BM_SETCHECK, BST_UNCHECKED, 0);
4214  					nppGUI._isWordCharDefault = true;
4215  					::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_SETWORDCHARS, 0, 0);
4216  					::EnableWindow(::GetDlgItem(_hSelf, IDC_WORDCHAR_CUSTOM_EDIT), !nppGUI._isWordCharDefault);
4217  					::SetDlgItemText(_hSelf, IDD_STATIC_WORDCHAR_WARNING, TEXT(""));
4218  					return TRUE;
4219  				}
4220  				case IDC_RADIO_WORDCHAR_CUSTOM:
4221  				{
4222  					::SendDlgItemMessage(_hSelf, IDC_RADIO_WORDCHAR_DEFAULT, BM_SETCHECK, BST_UNCHECKED, 0);
4223  					nppGUI._isWordCharDefault = false;
4224  					::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_SETWORDCHARS, 0, 0);
4225  					::EnableWindow(::GetDlgItem(_hSelf, IDC_WORDCHAR_CUSTOM_EDIT), !nppGUI._isWordCharDefault);
4226  					setWarningIfNeed();
4227  					return TRUE;
4228  				}
4229  				default :
4230  					return FALSE;
4231  			}
4232  		}
4233  		break;
4234  	}
4235  	return FALSE;
4236  }
4237  intptr_t CALLBACK CloudAndLinkSubDlg::run_dlgProc(UINT message, WPARAM wParam, LPARAM lParam)
4238  {
4239  	NppParameters& nppParams = NppParameters::getInstance();
4240  	NppGUI & nppGUI = nppParams.getNppGUI();
4241  	const size_t uriSchemesMaxLength = 2048;
4242  	if (HIWORD(wParam) == EN_CHANGE)
4243  	{
4244  		switch (LOWORD(wParam))
4245  		{
4246  			case  IDC_CLOUDPATH_EDIT:
4247  			{
4248  				TCHAR inputDir[MAX_PATH] = {'\0'};
4249  				TCHAR inputDirExpanded[MAX_PATH] = {'\0'};
4250  				::SendDlgItemMessage(_hSelf, IDC_CLOUDPATH_EDIT, WM_GETTEXT, MAX_PATH, reinterpret_cast<LPARAM>(inputDir));
4251  				::ExpandEnvironmentStrings(inputDir, inputDirExpanded, MAX_PATH);
4252  				NativeLangSpeaker *pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
4253  				if (::PathFileExists(inputDirExpanded))
4254  				{
4255  					nppGUI._cloudPath = inputDirExpanded;
4256  					nppParams.setCloudChoice(inputDirExpanded);
4257  					generic_string message;
4258  					if (nppParams.isCloudPathChanged())
4259  					{
4260  						message = pNativeSpeaker->getLocalizedStrFromID("cloud-restart-warning", TEXT("Please restart Notepad++ to take effect."));
4261  					}
4262  					::SetDlgItemText(_hSelf, IDC_SETTINGSONCLOUD_WARNING_STATIC, message.c_str());
4263  				}
4264  				else
4265  				{
4266  					bool isChecked = (BST_CHECKED == ::SendDlgItemMessage(_hSelf, IDC_WITHCLOUD_RADIO, BM_GETCHECK, 0, 0));
4267  					if (isChecked)
4268  					{
4269  						generic_string message = pNativeSpeaker->getLocalizedStrFromID("cloud-invalid-warning", TEXT("Invalid path."));
4270  						::SetDlgItemText(_hSelf, IDC_SETTINGSONCLOUD_WARNING_STATIC, message.c_str());
4271  						nppParams.removeCloudChoice();
4272  					}
4273  				}
4274  				return TRUE;
4275  			}
4276  			case IDC_URISCHEMES_EDIT:
4277  			{
4278  				TCHAR uriScheme[uriSchemesMaxLength] = { '\0' };
4279  				::SendDlgItemMessage(_hSelf, IDC_URISCHEMES_EDIT, WM_GETTEXT, uriSchemesMaxLength, reinterpret_cast<LPARAM>(uriScheme));
4280  				nppGUI._uriSchemes = uriScheme;
4281  				HWND grandParent = ::GetParent(_hParent);
4282  				::SendMessage(grandParent, NPPM_INTERNAL_UPDATECLICKABLELINKS, 0, 0);
4283  				return TRUE;
4284  			}
4285  		}
4286  	}
4287  	switch (message)
4288  	{
4289  		case WM_INITDIALOG:
4290  		{
4291  			generic_string message = TEXT("");
4292  			bool withCloud = nppGUI._cloudPath != TEXT("");
4293  			if (withCloud)
4294  			{
4295  				if (!::PathFileExists(nppGUI._cloudPath.c_str()))
4296  					message = TEXT("Invalid path");
4297  			}
4298  			::SetDlgItemText(_hSelf, IDC_SETTINGSONCLOUD_WARNING_STATIC, message.c_str());
4299  			::SendDlgItemMessage(_hSelf, IDC_NOCLOUD_RADIO, BM_SETCHECK, !withCloud ? BST_CHECKED : BST_UNCHECKED, 0);
4300  			::SendDlgItemMessage(_hSelf, IDC_WITHCLOUD_RADIO, BM_SETCHECK, withCloud ? BST_CHECKED : BST_UNCHECKED, 0);
4301  			::SendDlgItemMessage(_hSelf, IDC_CLOUDPATH_EDIT, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(nppGUI._cloudPath.c_str()));
4302  			::EnableWindow(::GetDlgItem(_hSelf, IDC_CLOUDPATH_EDIT), withCloud);
4303  			::EnableWindow(::GetDlgItem(_hSelf, IDD_CLOUDPATH_BROWSE_BUTTON), withCloud);
4304  			BOOL linkEnable = nppGUI._styleURL != urlDisable;
4305  			BOOL dontUnderline = (nppGUI._styleURL == urlNoUnderLineFg) || (nppGUI._styleURL == urlNoUnderLineBg);
4306  			BOOL roundBoxMode = (nppGUI._styleURL == urlNoUnderLineBg) || (nppGUI._styleURL == urlUnderLineBg);
4307  			::SendDlgItemMessage(_hSelf, IDC_URISCHEMES_EDIT, EM_SETLIMITTEXT, uriSchemesMaxLength, 0);
4308  			::SetWindowText(::GetDlgItem(_hSelf, IDC_URISCHEMES_EDIT), nppGUI._uriSchemes.c_str());
4309  			::SendDlgItemMessage(_hSelf, IDC_CHECK_CLICKABLELINK_ENABLE, BM_SETCHECK, linkEnable, 0);
4310  			::SendDlgItemMessage(_hSelf, IDC_CHECK_CLICKABLELINK_NOUNDERLINE, BM_SETCHECK, dontUnderline, 0);
4311  			::SendDlgItemMessage(_hSelf, IDC_CHECK_CLICKABLELINK_FULLBOXMODE, BM_SETCHECK, roundBoxMode, 0);
4312  			::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_CLICKABLELINK_NOUNDERLINE), linkEnable);
4313  			::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_CLICKABLELINK_FULLBOXMODE), linkEnable);
4314  			::EnableWindow(::GetDlgItem(_hSelf, IDC_URISCHEMES_EDIT), linkEnable);
4315  			return TRUE;
4316  		}
4317  		case WM_CTLCOLOREDIT:
4318  		{
4319  			return NppDarkMode::onCtlColorSofter(reinterpret_cast<HDC>(wParam));
4320  		}
4321  		case WM_CTLCOLORDLG:
4322  		{
4323  			return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
4324  		}
4325  		case WM_CTLCOLORSTATIC:
4326  		{
4327  			auto hdcStatic = reinterpret_cast<HDC>(wParam);
4328  			auto dlgCtrlID = ::GetDlgCtrlID(reinterpret_cast<HWND>(lParam));
4329  			bool isStaticText = dlgCtrlID == IDC_URISCHEMES_STATIC;
4330  			if (isStaticText)
4331  			{
4332  				bool isTextEnabled = isCheckedOrNot(IDC_CHECK_CLICKABLELINK_ENABLE);
4333  				return NppDarkMode::onCtlColorDarkerBGStaticText(hdcStatic, isTextEnabled);
4334  			}
4335  			return NppDarkMode::onCtlColorDarker(hdcStatic);
4336  		}
4337  		case WM_PRINTCLIENT:
4338  		{
4339  			if (NppDarkMode::isEnabled())
4340  			{
4341  				return TRUE;
4342  			}
4343  			break;
4344  		}
4345  		case WM_COMMAND:
4346  		{
4347  			NativeLangSpeaker *pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
4348  			switch (wParam)
4349  			{
4350  				case IDC_NOCLOUD_RADIO:
4351  				{
4352  					nppGUI._cloudPath = TEXT("");
4353  					nppParams.removeCloudChoice();
4354  					generic_string message;
4355  					if (nppParams.isCloudPathChanged())
4356  					{
4357  						message = pNativeSpeaker->getLocalizedStrFromID("cloud-restart-warning", TEXT("Please restart Notepad++ to take effect."));
4358  					}
4359  					::SetDlgItemText(_hSelf, IDC_SETTINGSONCLOUD_WARNING_STATIC, message.c_str());
4360  					::SendDlgItemMessage(_hSelf, IDC_CLOUDPATH_EDIT, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(nppGUI._cloudPath.c_str()));
4361  					::EnableWindow(::GetDlgItem(_hSelf, IDC_CLOUDPATH_EDIT), false);
4362  					::EnableWindow(::GetDlgItem(_hSelf, IDD_CLOUDPATH_BROWSE_BUTTON), false);
4363  				}
4364  				break;
4365  				case IDC_WITHCLOUD_RADIO:
4366  				{
4367  					generic_string message = pNativeSpeaker->getLocalizedStrFromID("cloud-invalid-warning", TEXT("Invalid path."));
4368  					::SetDlgItemText(_hSelf, IDC_SETTINGSONCLOUD_WARNING_STATIC, message.c_str());
4369  					::EnableWindow(::GetDlgItem(_hSelf, IDC_CLOUDPATH_EDIT), true);
4370  					::EnableWindow(::GetDlgItem(_hSelf, IDD_CLOUDPATH_BROWSE_BUTTON), true);
4371  				}
4372  				break;
4373  				case IDD_CLOUDPATH_BROWSE_BUTTON:
4374  				{
4375  					generic_string message = pNativeSpeaker->getLocalizedStrFromID("cloud-select-folder", TEXT("Select a folder from/to where Notepad++ reads/writes its settings"));
4376  					folderBrowser(_hSelf, message, IDC_CLOUDPATH_EDIT);
4377  				}
4378  				break;
4379  				case IDC_CHECK_CLICKABLELINK_ENABLE:
4380  				{
4381  					bool isChecked = isCheckedOrNot(IDC_CHECK_CLICKABLELINK_ENABLE);
4382  					if (!isChecked)
4383  					{
4384  						::SendDlgItemMessage(_hSelf, IDC_CHECK_CLICKABLELINK_NOUNDERLINE, BM_SETCHECK, BST_UNCHECKED, 0);
4385  						::SendDlgItemMessage(_hSelf, IDC_CHECK_CLICKABLELINK_FULLBOXMODE, BM_SETCHECK, BST_UNCHECKED, 0);
4386  					}
4387  					::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_CLICKABLELINK_NOUNDERLINE), isChecked);
4388  					::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_CLICKABLELINK_FULLBOXMODE), isChecked);
4389  					::EnableWindow(::GetDlgItem(_hSelf, IDC_URISCHEMES_EDIT), isChecked);
4390  					redrawDlgItem(IDC_CLICKABLELINK_STATIC);
4391  					nppGUI._styleURL = isChecked ? urlUnderLineFg : urlDisable;
4392  					HWND grandParent = ::GetParent(_hParent);
4393  					::SendMessage(grandParent, NPPM_INTERNAL_UPDATECLICKABLELINKS, 0, 0);
4394  				}
4395  				return TRUE;
4396  				case IDC_CHECK_CLICKABLELINK_NOUNDERLINE:
4397  				case IDC_CHECK_CLICKABLELINK_FULLBOXMODE:
4398  				{
4399  					bool isNoUnderline = isCheckedOrNot(IDC_CHECK_CLICKABLELINK_NOUNDERLINE);
4400  					bool isRoundBoxMode = isCheckedOrNot(IDC_CHECK_CLICKABLELINK_FULLBOXMODE);
4401  					if (isRoundBoxMode)
4402  						nppGUI._styleURL = isNoUnderline ? urlNoUnderLineBg : urlUnderLineBg;
4403  					else
4404  						nppGUI._styleURL = isNoUnderline ? urlNoUnderLineFg : urlUnderLineFg;
4405  					HWND grandParent = ::GetParent(_hParent);
4406  					::SendMessage(grandParent, NPPM_INTERNAL_UPDATECLICKABLELINKS, 0, 0);
4407  				}
4408  				return TRUE;
4409  				default:
4410  					return FALSE;
4411  			}
4412  		}																						
4413  	}
4414  	return FALSE;
4415  }
4416  intptr_t CALLBACK PerformanceSubDlg::run_dlgProc(UINT message , WPARAM wParam, LPARAM lParam)
4417  {
4418  	NppGUI& nppGUI = NppParameters::getInstance().getNppGUI();
4419  	if (HIWORD(wParam) == EN_CHANGE)
4420  	{
4421  		switch (LOWORD(wParam))
4422  		{
4423  			case  IDC_EDIT_PERFORMANCE_FILESIZE:
4424  			{
4425  				constexpr int stringSize = 16;
4426  				TCHAR str[stringSize]{};
4427  				::GetDlgItemText(_hSelf, IDC_EDIT_PERFORMANCE_FILESIZE, str, stringSize);
4428  				if (lstrcmp(str, TEXT("")) == 0)
4429  					return TRUE;
4430  				int64_t fileLenInMB = ::GetDlgItemInt(_hSelf, IDC_EDIT_PERFORMANCE_FILESIZE, NULL, FALSE);
4431  				if (fileLenInMB > 4096)
4432  				{
4433  					fileLenInMB = 4096;
4434  					::SetDlgItemInt(_hSelf, IDC_EDIT_PERFORMANCE_FILESIZE, UINT(fileLenInMB), FALSE);
4435  				}
4436  				nppGUI._largeFileRestriction._largeFileSizeDefInByte = fileLenInMB * 1024 * 1024;
4437  			}
4438  			return TRUE;
4439  		}
4440  	}
4441  	else if (HIWORD(wParam) == EN_KILLFOCUS)
4442  	{
4443  		switch (LOWORD(wParam))
4444  		{
4445  			case  IDC_EDIT_PERFORMANCE_FILESIZE:
4446  			{
4447  				constexpr int stringSize = 16;
4448  				TCHAR str[stringSize]{};
4449  				::GetDlgItemText(_hSelf, IDC_EDIT_PERFORMANCE_FILESIZE, str, stringSize);
4450  				if (lstrcmp(str, TEXT("")) == 0)
4451  				{
4452  					::SetDlgItemInt(_hSelf, IDC_EDIT_PERFORMANCE_FILESIZE, (NPP_STYLING_FILESIZE_LIMIT_DEFAULT / 1024) / 1024, FALSE);
4453  					return TRUE;
4454  				}
4455  				int64_t fileLenInMB = ::GetDlgItemInt(_hSelf, IDC_EDIT_PERFORMANCE_FILESIZE, NULL, FALSE);
4456  				if (fileLenInMB == 0)
4457  				{
4458  					fileLenInMB = (NPP_STYLING_FILESIZE_LIMIT_DEFAULT / 1024) / 1024;
4459  					::SetDlgItemInt(_hSelf, IDC_EDIT_PERFORMANCE_FILESIZE, UINT(fileLenInMB), FALSE);
4460  					return TRUE;
4461  				}
4462  			}
4463  			return TRUE;
4464  		}
4465  	}
4466  	switch (message)
4467  	{
4468  		case WM_INITDIALOG:
4469  		{
4470  			int64_t fileLenInMB = (nppGUI._largeFileRestriction._largeFileSizeDefInByte / 1024) / 1024;
4471  			::SetDlgItemInt(_hSelf, IDC_EDIT_PERFORMANCE_FILESIZE, UINT(fileLenInMB), FALSE);
4472  			::SendDlgItemMessage(_hSelf, IDC_CHECK_PERFORMANCE_ENABLE, BM_SETCHECK, nppGUI._largeFileRestriction._isEnabled ? BST_CHECKED : BST_UNCHECKED, 0);
4473  			::SendDlgItemMessage(_hSelf, IDC_CHECK_PERFORMANCE_ALLOWBRACEMATCH, BM_SETCHECK, nppGUI._largeFileRestriction._allowBraceMatch ? BST_CHECKED : BST_UNCHECKED, 0);
4474  			::SendDlgItemMessage(_hSelf, IDC_CHECK_PERFORMANCE_ALLOWAUTOCOMPLETION, BM_SETCHECK, nppGUI._largeFileRestriction._allowAutoCompletion ? BST_CHECKED : BST_UNCHECKED, 0);
4475  			::SendDlgItemMessage(_hSelf, IDC_CHECK_PERFORMANCE_ALLOWSMARTHILITE, BM_SETCHECK, nppGUI._largeFileRestriction._allowSmartHilite ? BST_CHECKED : BST_UNCHECKED, 0);
4476  			::SendDlgItemMessage(_hSelf, IDC_CHECK_PERFORMANCE_ALLOWCLICKABLELINK, BM_SETCHECK, nppGUI._largeFileRestriction._allowClickableLink ? BST_CHECKED : BST_UNCHECKED, 0);
4477  			::SendDlgItemMessage(_hSelf, IDC_CHECK_PERFORMANCE_DEACTIVATEWORDWRAP, BM_SETCHECK, nppGUI._largeFileRestriction._deactivateWordWrap ? BST_CHECKED : BST_UNCHECKED, 0);
4478  			bool largeFileRestrictionEnabled = isCheckedOrNot(IDC_CHECK_PERFORMANCE_ENABLE);
4479  			::EnableWindow(::GetDlgItem(_hSelf, IDC_EDIT_PERFORMANCE_FILESIZE), largeFileRestrictionEnabled);
4480  			::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_PERFORMANCE_ALLOWBRACEMATCH), largeFileRestrictionEnabled);
4481  			::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_PERFORMANCE_ALLOWAUTOCOMPLETION), largeFileRestrictionEnabled);
4482  			::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_PERFORMANCE_ALLOWSMARTHILITE), largeFileRestrictionEnabled);
4483  			::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_PERFORMANCE_ALLOWCLICKABLELINK), largeFileRestrictionEnabled);
4484  			::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_PERFORMANCE_DEACTIVATEWORDWRAP), largeFileRestrictionEnabled);
4485  			NativeLangSpeaker* pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
4486  			generic_string enablePerfTip = pNativeSpeaker->getLocalizedStrFromID("largeFileRestriction-tip", TEXT("Some features may slow performance in large files. These features can be auto-disabled on opening a large file. You can customize them here.\n\nNOTE:\n1. Modifying options here requires re-open currently opened large files to get proper behavior.\n\n2. If \"Deactivate Word Wrap globally\" is checked and you open a large file, \"Word Wrap\" will be disabled for all files. You can re-enable it via menu \"View->Word Wrap\""));
4487  			_largeFileRestrictionTip = CreateToolTip(IDD_PERFORMANCE_TIP_QUESTION_BUTTON, _hSelf, _hInst, const_cast<PTSTR>(enablePerfTip.c_str()), false);
4488  			return TRUE;
4489  		}
4490  		case WM_CTLCOLOREDIT:
4491  		{
4492  			return NppDarkMode::onCtlColorSofter(reinterpret_cast<HDC>(wParam));
4493  		}
4494  		case WM_CTLCOLORDLG:
4495  		{
4496  			return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
4497  		}
4498  		case WM_CTLCOLORSTATIC:
4499  		{
4500  			auto hdcStatic = reinterpret_cast<HDC>(wParam);
4501  			auto dlgCtrlID = ::GetDlgCtrlID(reinterpret_cast<HWND>(lParam));
4502  			bool isStaticText = (dlgCtrlID == IDC_STATIC_PERFORMANCE_FILESIZE || dlgCtrlID == IDC_STATIC_PERFORMANCE_MB);
4503  			if (isStaticText)
4504  			{
4505  				bool isTextEnabled = isCheckedOrNot(IDC_CHECK_PERFORMANCE_ENABLE);
4506  				return NppDarkMode::onCtlColorDarkerBGStaticText(hdcStatic, isTextEnabled);
4507  			}
4508  			if (dlgCtrlID == IDC_EDIT_PERFORMANCE_FILESIZE)
4509  			{
4510  				return NppDarkMode::onCtlColor(hdcStatic);
4511  			}
4512  			return NppDarkMode::onCtlColorDarker(hdcStatic);
4513  		}
4514  		case WM_PRINTCLIENT:
4515  		{
4516  			if (NppDarkMode::isEnabled())
4517  			{
4518  				return TRUE;
4519  			}
4520  			break;
4521  		}
4522  		case WM_COMMAND:
4523  		{
4524  			switch (wParam)
4525  			{
4526  				case IDC_CHECK_PERFORMANCE_ENABLE:
4527  				{
4528  					bool largeFileRestrictionEnabled = isCheckedOrNot(IDC_CHECK_PERFORMANCE_ENABLE);
4529  					nppGUI._largeFileRestriction._isEnabled = largeFileRestrictionEnabled;
4530  					::EnableWindow(::GetDlgItem(_hSelf, IDC_EDIT_PERFORMANCE_FILESIZE), largeFileRestrictionEnabled);
4531  					::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_PERFORMANCE_ALLOWBRACEMATCH), largeFileRestrictionEnabled);
4532  					::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_PERFORMANCE_ALLOWAUTOCOMPLETION), largeFileRestrictionEnabled);
4533  					::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_PERFORMANCE_ALLOWSMARTHILITE), largeFileRestrictionEnabled);
4534  					::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_PERFORMANCE_ALLOWCLICKABLELINK), largeFileRestrictionEnabled);
4535  					::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_PERFORMANCE_DEACTIVATEWORDWRAP), largeFileRestrictionEnabled);
4536  					redrawDlgItem(IDC_STATIC_PERFORMANCE_FILESIZE);
4537  					redrawDlgItem(IDC_STATIC_PERFORMANCE_MB);
4538  					if (largeFileRestrictionEnabled)
4539  					{
4540  						::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_CLEANSMARTHILITING, 0, 0);
4541  						::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_CLEANBRACEMATCH, 0, 0);
4542  					}
4543  					else
4544  					{
4545  						::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_UPDATECLICKABLELINKS, 0, 0);
4546  					}
4547  				}
4548  				return TRUE;
4549  				case IDC_CHECK_PERFORMANCE_ALLOWBRACEMATCH:
4550  				{
4551  					bool isAllowed = isCheckedOrNot(int(wParam));
4552  					nppGUI._largeFileRestriction._allowBraceMatch = isAllowed;
4553  					if (!isAllowed)
4554  						::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_CLEANBRACEMATCH, 0, 0);
4555  				}
4556  				return TRUE;
4557  				case IDC_CHECK_PERFORMANCE_ALLOWAUTOCOMPLETION:
4558  				{
4559  					bool isAllowed = isCheckedOrNot(int(wParam));
4560  					nppGUI._largeFileRestriction._allowAutoCompletion = isAllowed;
4561  				}
4562  				return TRUE;
4563  				case IDC_CHECK_PERFORMANCE_ALLOWSMARTHILITE:
4564  				{
4565  					bool isAllowed = isCheckedOrNot(int(wParam));
4566  					nppGUI._largeFileRestriction._allowSmartHilite = isAllowed;
4567  					if (!isAllowed)
4568  						::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_CLEANSMARTHILITING, 0, 0);
4569  				}
4570  				return TRUE;
4571  				case IDC_CHECK_PERFORMANCE_ALLOWCLICKABLELINK:
4572  				{
4573  					bool isAllowed = isCheckedOrNot(int(wParam));
4574  					nppGUI._largeFileRestriction._allowClickableLink = isAllowed;
4575  					::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_UPDATECLICKABLELINKS, 0, 0);
4576  				}
4577  				return TRUE;
4578  				case IDC_CHECK_PERFORMANCE_DEACTIVATEWORDWRAP:
4579  				{
4580  					bool isDeactivated = isCheckedOrNot(int(wParam));
4581  					nppGUI._largeFileRestriction._deactivateWordWrap = isDeactivated;
4582  				}
4583  				return TRUE;
4584  				default:
4585  					return FALSE;
4586  			}
4587  		}
4588  		break;
4589  	}
4590  	return FALSE;
4591  }
4592  intptr_t CALLBACK SearchEngineSubDlg::run_dlgProc(UINT message, WPARAM wParam, LPARAM)
4593  {
4594  	NppParameters& nppParams = NppParameters::getInstance();
4595  	NppGUI & nppGUI = nppParams.getNppGUI();
4596  	if (HIWORD(wParam) == EN_CHANGE)
4597  	{
4598  		switch (LOWORD(wParam))
4599  		{
4600  			case  IDC_SEARCHENGINE_EDIT:
4601  			{
4602  				TCHAR input[MAX_PATH] = { '\0' };
4603  				::SendDlgItemMessage(_hSelf, IDC_SEARCHENGINE_EDIT, WM_GETTEXT, MAX_PATH, reinterpret_cast<LPARAM>(input));
4604  				nppGUI._searchEngineCustom = input;
4605  				return TRUE;
4606  			}
4607  		}
4608  	}
4609  	switch (message)
4610  	{
4611  		case WM_INITDIALOG:
4612  		{
4613  			if (nppGUI._searchEngineChoice == nppGUI.se_custom)
4614  			{
4615  				if (nppGUI._searchEngineCustom.empty())
4616  				{
4617  					nppGUI._searchEngineChoice = nppGUI.se_google;
4618  				}
4619  			}
4620  			if (nppGUI._searchEngineChoice == nppGUI.se_bing)
4621  				nppGUI._searchEngineChoice = nppGUI.se_duckDuckGo;
4622  			::SendDlgItemMessage(_hSelf, IDC_SEARCHENGINE_CUSTOM_RADIO, BM_SETCHECK, nppGUI._searchEngineChoice == nppGUI.se_custom ? BST_CHECKED : BST_UNCHECKED, 0);
4623  			::SendDlgItemMessage(_hSelf, IDC_SEARCHENGINE_DUCKDUCKGO_RADIO, BM_SETCHECK, nppGUI._searchEngineChoice == nppGUI.se_duckDuckGo ? BST_CHECKED : BST_UNCHECKED, 0);
4624  			::SendDlgItemMessage(_hSelf, IDC_SEARCHENGINE_GOOGLE_RADIO, BM_SETCHECK, nppGUI._searchEngineChoice == nppGUI.se_google ? BST_CHECKED : BST_UNCHECKED, 0);
4625  			::SendDlgItemMessage(_hSelf, IDC_SEARCHENGINE_YAHOO_RADIO, BM_SETCHECK, nppGUI._searchEngineChoice == nppGUI.se_yahoo ? BST_CHECKED : BST_UNCHECKED, 0);
4626  			::SendDlgItemMessage(_hSelf, IDC_SEARCHENGINE_STACKOVERFLOW_RADIO, BM_SETCHECK, nppGUI._searchEngineChoice == nppGUI.se_stackoverflow ? BST_CHECKED : BST_UNCHECKED, 0);
4627  			::SendDlgItemMessage(_hSelf, IDC_SEARCHENGINE_EDIT, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(nppGUI._searchEngineCustom.c_str()));
4628  			::EnableWindow(::GetDlgItem(_hSelf, IDC_SEARCHENGINE_EDIT), nppGUI._searchEngineChoice == nppGUI.se_custom);
4629  			return TRUE;
4630  		}
4631  		case WM_CTLCOLOREDIT:
4632  		{
4633  			return NppDarkMode::onCtlColorSofter(reinterpret_cast<HDC>(wParam));
4634  		}
4635  		case WM_CTLCOLORDLG:
4636  		case WM_CTLCOLORSTATIC:
4637  		{
4638  			return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
4639  		}
4640  		case WM_PRINTCLIENT:
4641  		{
4642  			if (NppDarkMode::isEnabled())
4643  			{
4644  				return TRUE;
4645  			}
4646  			break;
4647  		}
4648  		case WM_COMMAND:
4649  		{
4650  			switch (wParam)
4651  			{
4652  				case IDC_SEARCHENGINE_DUCKDUCKGO_RADIO:
4653  				{
4654  					nppGUI._searchEngineChoice = nppGUI.se_duckDuckGo;
4655  					::EnableWindow(::GetDlgItem(_hSelf, IDC_SEARCHENGINE_EDIT), false);
4656  				}
4657  				break;
4658  				case IDC_SEARCHENGINE_GOOGLE_RADIO:
4659  				{
4660  					nppGUI._searchEngineChoice = nppGUI.se_google;
4661  					::EnableWindow(::GetDlgItem(_hSelf, IDC_SEARCHENGINE_EDIT), false);
4662  				}
4663  				break;
4664  				case IDC_SEARCHENGINE_YAHOO_RADIO:
4665  				{
4666  					nppGUI._searchEngineChoice = nppGUI.se_yahoo;
4667  					::EnableWindow(::GetDlgItem(_hSelf, IDC_SEARCHENGINE_EDIT), false);
4668  				}
4669  				break;
4670  				case IDC_SEARCHENGINE_STACKOVERFLOW_RADIO:
4671  				{
4672  					nppGUI._searchEngineChoice = nppGUI.se_stackoverflow;
4673  					::EnableWindow(::GetDlgItem(_hSelf, IDC_SEARCHENGINE_EDIT), false);
4674  				}
4675  				break;
4676  				case IDC_SEARCHENGINE_CUSTOM_RADIO:
4677  				{
4678  					nppGUI._searchEngineChoice = nppGUI.se_custom;
4679  					::EnableWindow(::GetDlgItem(_hSelf, IDC_SEARCHENGINE_EDIT), true);
4680  				}
4681  				break;
4682  				default:
4683  					return FALSE;
4684  			}
4685  		}
4686  		break;
4687  	}
4688  	return FALSE;
4689  }
4690  intptr_t CALLBACK SearchingSubDlg::run_dlgProc(UINT message, WPARAM wParam, LPARAM)
4691  {
4692  	NppParameters& nppParams = NppParameters::getInstance();
4693  	NppGUI& nppGUI = nppParams.getNppGUI();
4694  	switch (message)
4695  	{
4696  		case WM_INITDIALOG:
4697  		{
4698  			::SendDlgItemMessage(_hSelf, IDC_CHECK_FILL_FIND_FIELD_WITH_SELECTED, BM_SETCHECK, nppGUI._fillFindFieldWithSelected, 0);
4699  			::SendDlgItemMessage(_hSelf, IDC_CHECK_FILL_FIND_FIELD_SELECT_CARET, BM_SETCHECK, nppGUI._fillFindFieldSelectCaret, 0);
4700  			::SendDlgItemMessage(_hSelf, IDC_CHECK_MONOSPACEDFONT_FINDDLG, BM_SETCHECK, nppGUI._monospacedFontFindDlg, 0);
4701  			::SendDlgItemMessage(_hSelf, IDC_CHECK_FINDDLG_ALWAYS_VISIBLE, BM_SETCHECK, nppGUI._findDlgAlwaysVisible, 0);
4702  			::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_FILL_FIND_FIELD_SELECT_CARET), nppGUI._fillFindFieldWithSelected ? TRUE : FALSE);
4703  			::SendDlgItemMessage(_hSelf, IDC_CHECK_CONFIRMREPLOPENDOCS, BM_SETCHECK, nppGUI._confirmReplaceInAllOpenDocs, 0);
4704  			::SendDlgItemMessage(_hSelf, IDC_CHECK_REPLACEANDSTOP, BM_SETCHECK, nppGUI._replaceStopsWithoutFindingNext, 0);
4705  			::SendDlgItemMessage(_hSelf, IDC_CHECK_SHOWONCEPERFOUNDLINE, BM_SETCHECK, nppGUI._finderShowOnlyOneEntryPerFoundLine, 0);
4706  			return TRUE;
4707  		}
4708  		case WM_CTLCOLORDLG:
4709  		case WM_CTLCOLORSTATIC:
4710  		{
4711  			return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
4712  		}
4713  		case WM_PRINTCLIENT:
4714  		{
4715  			if (NppDarkMode::isEnabled())
4716  			{
4717  				return TRUE;
4718  			}
4719  			break;
4720  		}
4721  		case WM_COMMAND:
4722  		{
4723  			switch (wParam)
4724  			{
4725  				case IDC_CHECK_FILL_FIND_FIELD_WITH_SELECTED:
4726  				{
4727  					nppGUI._fillFindFieldWithSelected = isCheckedOrNot(IDC_CHECK_FILL_FIND_FIELD_WITH_SELECTED);
4728  					::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_FILL_FIND_FIELD_SELECT_CARET), nppGUI._fillFindFieldWithSelected ? TRUE :FALSE);
4729  					if (!nppGUI._fillFindFieldWithSelected) 
4730  					{
4731  						::SendDlgItemMessage(_hSelf, IDC_CHECK_FILL_FIND_FIELD_SELECT_CARET, BM_SETCHECK, BST_UNCHECKED, 0);
4732  						nppGUI._fillFindFieldSelectCaret = false;
4733  					}
4734  					return TRUE;
4735  				}
4736  				break;
4737  				case IDC_CHECK_MONOSPACEDFONT_FINDDLG:
4738  				{
4739  					nppGUI._monospacedFontFindDlg = isCheckedOrNot(IDC_CHECK_MONOSPACEDFONT_FINDDLG);
4740  					return TRUE;
4741  				}
4742  				break;
4743  				case IDC_CHECK_FINDDLG_ALWAYS_VISIBLE:
4744  				{
4745  					nppGUI._findDlgAlwaysVisible = isCheckedOrNot(IDC_CHECK_FINDDLG_ALWAYS_VISIBLE);
4746  					return TRUE;
4747  				}
4748  				break;
4749  				case IDC_CHECK_CONFIRMREPLOPENDOCS:
4750  				{
4751  					nppGUI._confirmReplaceInAllOpenDocs = isCheckedOrNot(IDC_CHECK_CONFIRMREPLOPENDOCS);
4752  					return TRUE;
4753  				}
4754  				break;
4755  				case IDC_CHECK_REPLACEANDSTOP:
4756  				{
4757  					nppGUI._replaceStopsWithoutFindingNext = isCheckedOrNot(IDC_CHECK_REPLACEANDSTOP);
4758  					return TRUE;
4759  				}
4760  				break;
4761  				case IDC_CHECK_SHOWONCEPERFOUNDLINE:
4762  				{
4763  					nppGUI._finderShowOnlyOneEntryPerFoundLine = isCheckedOrNot(IDC_CHECK_SHOWONCEPERFOUNDLINE);
4764  					return TRUE;
4765  				}
4766  				break;
4767  				case IDC_CHECK_FILL_FIND_FIELD_SELECT_CARET:
4768  				{
4769  					nppGUI._fillFindFieldSelectCaret = isCheckedOrNot(IDC_CHECK_FILL_FIND_FIELD_SELECT_CARET);
4770  					return TRUE;
4771  				}
4772  				break;
4773  				default:
4774  					return FALSE;
4775  			}
4776  		}
4777  		break;
4778  	}
4779  	return FALSE;
4780  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-signnet.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-preferenceDlg.cpp</div>
                </div>
                <div class="column column_space"><pre><code>408      case 1 : return "+o";
409      case 2 : return "-o";
410      case 3 : return "o+";
411      case 4 : return "o-";
412      case 5 : return "++";
413      case 6 : return "+-";
414      case 7 : return "-+";
</pre></code></div>
                <div class="column column_space"><pre><code>569  				case IDC_CHECK_REDUCE :
570  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_REDUCETABBAR, 0);
571  					return TRUE;
572  				case IDC_CHECK_LOCK :
573  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_LOCKTABBAR, 0);
574  					return TRUE;
575  				case IDC_CHECK_ORANGE :
576  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_DRAWTABBAR_TOPBAR, 0);
577  					return TRUE;
578  				case IDC_CHECK_DRAWINACTIVE :
579  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_DRAWTABBAR_INACIVETAB, 0);
580  					return TRUE;
581  				case IDC_CHECK_ENABLETABCLOSE :
582  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_DRAWTABBAR_CLOSEBOTTUN, 0);
583  					return TRUE;
584  				case IDC_CHECK_DBCLICK2CLOSE :
585  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_DRAWTABBAR_DBCLK2CLOSE, 0);
586  					return TRUE;
587  				case IDC_CHECK_HIDE :
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    