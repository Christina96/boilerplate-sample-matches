<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for ParameterMgr.cpp &amp; BitParameterBlockType.cpp</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for ParameterMgr.cpp &amp; BitParameterBlockType.cpp
      </h3>
<h1 align="center">
        1.0%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>ParameterMgr.cpp (0.5242464%)<th>BitParameterBlockType.cpp (30.0%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(344-357)<td><a href="#" name="0">(40-53)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>ParameterMgr.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "version.h"
2 #include "ParameterMgr.h"
3 #include "ConfigurationAccessContext.h"
4 #include "XmlParameterSerializingContext.h"
5 #include "XmlElementSerializingContext.h"
6 #include "SystemClass.h"
7 #include "ElementLibrarySet.h"
8 #include "SubsystemLibrary.h"
9 #include "NamedElementBuilderTemplate.h"
10 #include "KindElementBuilderTemplate.h"
11 #include "ElementBuilderTemplate.h"
12 #include "SelectionCriterionType.h"
13 #include "SubsystemElementBuilder.h"
14 #include "FileIncluderElementBuilder.h"
15 #include "SelectionCriteria.h"
16 #include "ComponentType.h"
17 #include "ComponentInstance.h"
18 #include "ParameterBlockType.h"
19 #include "BooleanParameterType.h"
20 #include "IntegerParameterBuilder.h"
21 #include "FixedPointParameterType.h"
22 #include "FloatingPointParameterType.h"
23 #include "ParameterBlackboard.h"
24 #include "Parameter.h"
25 #include "ParameterAccessContext.h"
26 #include "ParameterFrameworkConfiguration.h"
27 #include "FrameworkConfigurationGroup.h"
28 #include "PluginLocation.h"
29 #include "SubsystemPlugins.h"
30 #include "FrameworkConfigurationLocation.h"
31 #include "ConfigurableDomains.h"
32 #include "ConfigurableDomain.h"
33 #include "DomainConfiguration.h"
34 #include "XmlDomainSerializingContext.h"
35 #include "XmlDomainExportContext.h"
36 #include "XmlDomainImportContext.h"
37 #include "BitParameterBlockType.h"
38 #include "BitParameterType.h"
39 #include "StringParameterType.h"
40 #include "EnumParameterType.h"
41 #include "BackgroundRemoteProcessorServer.h"
42 #include "ElementLocator.h"
43 #include "CompoundRule.h"
44 #include "SelectionCriterionRule.h"
45 #include "SimulatedBackSynchronizer.h"
46 #include "HardwareBackSynchronizer.h"
47 #include &lt;cassert&gt;
48 #include "ParameterHandle.h"
49 #include "LinearParameterAdaptation.h"
50 #include "LogarithmicParameterAdaptation.h"
51 #include "EnumValuePair.h"
52 #include "Subsystem.h"
53 #include "XmlStreamDocSink.h"
54 #include "XmlMemoryDocSink.h"
55 #include "XmlDocSource.h"
56 #include "XmlMemoryDocSource.h"
57 #include "SelectionCriteriaDefinition.h"
58 #include "Utility.h"
59 #include "Memory.hpp"
60 #include &lt;sstream&gt;
61 #include &lt;fstream&gt;
62 #include &lt;algorithm&gt;
63 #include &lt;stdexcept&gt;
64 #include &lt;mutex&gt;
65 #include &lt;iomanip&gt;
66 #include "convert.hpp"
67 #define base CElement
68 #define LOG_CONTEXT(contextTitle) core::log::Context context(_logger, contextTitle)
69 #ifdef SIMULATION
70 typedef CSimulatedBackSynchronizer BackSynchronizer;
71 #else
72 typedef CHardwareBackSynchronizer BackSynchronizer;
73 #endif
74 using std::string;
75 using std::list;
76 using std::vector;
77 using std::ostringstream;
78 using std::ofstream;
79 using std::ifstream;
80 using std::mutex;
81 using std::lock_guard;
82 using namespace core;
83 typedef IRemoteProcessorServerInterface *(*CreateRemoteProcessorServer)(
84     uint16_t uiPort, IRemoteCommandHandler *pCommandHandler);
85 const CParameterMgr::SRemoteCommandParserItem CParameterMgr::gastRemoteCommandParserItems[] = {
86     {"version", &amp;CParameterMgr::versionCommandProcess, 0, "", "Show version"},
87     {"status", &amp;CParameterMgr::statusCommandProcess, 0, "", "Show current status"},
88     {"setTuningMode", &amp;CParameterMgr::setTuningModeCommandProcess, 1, "on|off*",
89      "Turn on or off Tuning Mode"},
90     {"getTuningMode", &amp;CParameterMgr::getTuningModeCommandProcess, 0, "", "Show Tuning Mode"},
91     {"setValueSpace", &amp;CParameterMgr::setValueSpaceCommandProcess, 1, "raw|real*",
92      "Assigns Value Space used for parameter value interpretation"},
93     {"getValueSpace", &amp;CParameterMgr::getValueSpaceCommandProcess, 0, "", "Show Value Space"},
94     {"setOutputRawFormat", &amp;CParameterMgr::setOutputRawFormatCommandProcess, 1, "dec*|hex",
95      "Assigns format used to output parameter values when in raw Value Space"},
96     {"getOutputRawFormat", &amp;CParameterMgr::getOutputRawFormatCommandProcess, 0, "",
97      "Show Output Raw Format"},
98     {"setAutoSync", &amp;CParameterMgr::setAutoSyncCommandProcess, 1, "on*|off",
99      "Turn on or off automatic synchronization to hardware while in Tuning Mode"},
100     {"getAutoSync", &amp;CParameterMgr::getAutoSyncCommandProcess, 0, "", "Show Auto Sync state"},
101     {"sync", &amp;CParameterMgr::syncCommandProcess, 0, "",
102      "Synchronize current settings to hardware while in Tuning Mode and Auto Sync off"},
103     {"listCriteria", &amp;CParameterMgr::listCriteriaCommandProcess, 0, "[CSV|XML]",
104      "List selection criteria"},
105     {"listDomains", &amp;CParameterMgr::listDomainsCommandProcess, 0, "", "List configurable domains"},
106     {"dumpDomains", &amp;CParameterMgr::dumpDomainsCommandProcess, 0, "",
107      "Show all domains and configurations, including applicability conditions"},
108     {"createDomain", &amp;CParameterMgr::createDomainCommandProcess, 1, "&lt;domain&gt;",
109      "Create new configurable domain"},
110     {"deleteDomain", &amp;CParameterMgr::deleteDomainCommandProcess, 1, "&lt;domain&gt;",
111      "Delete configurable domain"},
112     {"deleteAllDomains", &amp;CParameterMgr::deleteAllDomainsCommandProcess, 0, "",
113      "Delete all configurable domains"},
114     {"renameDomain", &amp;CParameterMgr::renameDomainCommandProcess, 2, "&lt;domain&gt; &lt;new name&gt;",
115      "Rename configurable domain"},
116     {"setSequenceAwareness", &amp;CParameterMgr::setSequenceAwarenessCommandProcess, 1,
117      "&lt;domain&gt; true|false*", "Set configurable domain sequence awareness"},
118     {"getSequenceAwareness", &amp;CParameterMgr::getSequenceAwarenessCommandProcess, 1, "&lt;domain&gt;",
119      "Get configurable domain sequence awareness"},
120     {"listDomainElements", &amp;CParameterMgr::listDomainElementsCommandProcess, 1, "&lt;domain&gt;",
121      "List elements associated to configurable domain"},
122     {"addElement", &amp;CParameterMgr::addElementCommandProcess, 2, "&lt;domain&gt; &lt;elem path&gt;",
123      "Associate element at given path to configurable domain"},
124     {"removeElement", &amp;CParameterMgr::removeElementCommandProcess, 2, "&lt;domain&gt; &lt;elem path&gt;",
125      "Dissociate element at given path from configurable domain"},
126     {"splitDomain", &amp;CParameterMgr::splitDomainCommandProcess, 2, "&lt;domain&gt; &lt;elem path&gt;",
127      "Split configurable domain at given associated element path"},
128     {"listConfigurations", &amp;CParameterMgr::listConfigurationsCommandProcess, 1, "&lt;domain&gt;",
129      "List domain configurations"},
130     {"createConfiguration", &amp;CParameterMgr::createConfigurationCommandProcess, 2,
131      "&lt;domain&gt; &lt;configuration&gt;", "Create new domain configuration"},
132     {"deleteConfiguration", &amp;CParameterMgr::deleteConfigurationCommandProcess, 2,
133      "&lt;domain&gt; &lt;configuration&gt;", "Delete domain configuration"},
134     {"renameConfiguration", &amp;CParameterMgr::renameConfigurationCommandProcess, 3,
135      "&lt;domain&gt; &lt;configuration&gt; &lt;new name&gt;", "Rename domain configuration"},
136     {"saveConfiguration", &amp;CParameterMgr::saveConfigurationCommandProcess, 2,
137      "&lt;domain&gt; &lt;configuration&gt;", "Save current settings into configuration"},
138     {"restoreConfiguration", &amp;CParameterMgr::restoreConfigurationCommandProcess, 2,
139      "&lt;domain&gt; &lt;configuration&gt;", "Restore current settings from configuration"},
140     {"setElementSequence", &amp;CParameterMgr::setElementSequenceCommandProcess, 3,
141      "&lt;domain&gt; &lt;configuration&gt; &lt;elem path list&gt;",
142      "Set element application order for configuration"},
143     {"getElementSequence", &amp;CParameterMgr::getElementSequenceCommandProcess, 2,
144      "&lt;domain&gt; &lt;configuration&gt;", "Get element application order for configuration"},
145     {"setRule", &amp;CParameterMgr::setRuleCommandProcess, 3, "&lt;domain&gt; &lt;configuration&gt; &lt;rule&gt;",
146      "Set configuration application rule"},
147     {"clearRule", &amp;CParameterMgr::clearRuleCommandProcess, 2, "&lt;domain&gt; &lt;configuration&gt;",
148      "Clear configuration application rule"},
149     {"getRule", &amp;CParameterMgr::getRuleCommandProcess, 2, "&lt;domain&gt; &lt;configuration&gt;",
150      "Get configuration application rule"},
151     {"listElements", &amp;CParameterMgr::listElementsCommandProcess, 1, "&lt;elem path&gt;|/",
152      "List elements under element at given path or root"},
153     {"listParameters", &amp;CParameterMgr::listParametersCommandProcess, 1, "&lt;elem path&gt;|/",
154      "List parameters under element at given path or root"},
155     {"getElementStructureXML", &amp;CParameterMgr::getElementStructureXMLCommandProcess, 1,
156      "&lt;elem path&gt;", "Get structure of element at given path in XML format"},
157     {"getElementBytes", &amp;CParameterMgr::getElementBytesCommandProcess, 1, "&lt;elem path&gt;",
158      "Get settings of element at given path in Byte Array format"},
159     {"setElementBytes", &amp;CParameterMgr::setElementBytesCommandProcess, 2, "&lt;elem path&gt; &lt;values&gt;",
160      "Set settings of element at given path in Byte Array format"},
161     {"getElementXML", &amp;CParameterMgr::getElementXMLCommandProcess, 1, "&lt;elem path&gt;",
162      "Get settings of element at given path in XML format"},
163     {"setElementXML", &amp;CParameterMgr::setElementXMLCommandProcess, 2, "&lt;elem path&gt; &lt;values&gt;",
164      "Set settings of element at given path in XML format"},
165     {"dumpElement", &amp;CParameterMgr::dumpElementCommandProcess, 1, "&lt;elem path&gt;",
166      "Dump structure and content of element at given path"},
167     {"getElementSize", &amp;CParameterMgr::getElementSizeCommandProcess, 1, "&lt;elem path&gt;",
168      "Show size of element at given path"},
169     {"showProperties", &amp;CParameterMgr::showPropertiesCommandProcess, 1, "&lt;elem path&gt;",
170      "Show properties of element at given path"},
171     {"getParameter", &amp;CParameterMgr::getParameterCommandProcess, 1, "&lt;param path&gt;",
172      "Get value for parameter at given path"},
173     {"setParameter", &amp;CParameterMgr::setParameterCommandProcess, 2, "&lt;param path&gt; &lt;value&gt;",
174      "Set value for parameter at given path"},
175     {"listBelongingDomains", &amp;CParameterMgr::listBelongingDomainsCommandProcess, 1, "&lt;elem path&gt;",
176      "List domain(s) element at given path belongs to"},
177     {"listAssociatedDomains", &amp;CParameterMgr::listAssociatedDomainsCommandProcess, 1, "&lt;elem path&gt;",
178      "List domain(s) element at given path is associated to"},
179     {"getConfigurationParameter", &amp;CParameterMgr::getConfigurationParameterCommandProcess, 3,
180      "&lt;domain&gt; &lt;configuration&gt; &lt;param path&gt;",
181      "Get value for parameter at given path from configuration"},
182     {"setConfigurationParameter", &amp;CParameterMgr::setConfigurationParameterCommandProcess, 4,
183      "&lt;domain&gt; &lt;configuration&gt; &lt;param path&gt; &lt;value&gt;",
184      "Set value for parameter at given path to configuration"},
185     {"showMapping", &amp;CParameterMgr::showMappingCommandProcess, 1, "&lt;elem path&gt;",
186      "Show mapping for an element at given path"},
187     {"listAssociatedElements", &amp;CParameterMgr::listAssociatedElementsCommandProcess, 0, "",
188      "List element sub-trees associated to at least one configurable domain"},
189     {"listConflictingElements", &amp;CParameterMgr::listConflictingElementsCommandProcess, 0, "",
190      "List element sub-trees contained in more than one configurable domain"},
191     {"listRogueElements", &amp;CParameterMgr::listRogueElementsCommandProcess, 0, "",
192      "List element sub-trees owned by no configurable domain"},
193     {"exportDomainsXML", &amp;CParameterMgr::exportDomainsXMLCommandProcess, 1, "&lt;file path&gt; ",
194      "Export domains to an XML file (provide an absolute path or relative"
195      "to the client's working directory)"},
196     {"importDomainsXML", &amp;CParameterMgr::importDomainsXMLCommandProcess, 1, "&lt;file path&gt;",
197      "Import domains from an XML file (provide an absolute path or relative"
198      "to the client's working directory)"},
199     {"exportDomainsWithSettingsXML", &amp;CParameterMgr::exportDomainsWithSettingsXMLCommandProcess, 1,
200      "&lt;file path&gt; ",
201      "Export domains including settings to XML file (provide an absolute path or relative"
202      "to the client's working directory)"},
203     {"exportDomainWithSettingsXML", &amp;CParameterMgr::exportDomainWithSettingsXMLCommandProcess, 2,
204      "&lt;domain&gt; &lt;file path&gt; ", "Export a single given domain including settings to XML file"
205                               " (provide an absolute path or relative to the client's"
206                               " working directory)"},
207     {"importDomainsWithSettingsXML", &amp;CParameterMgr::importDomainsWithSettingsXMLCommandProcess, 1,
208      "&lt;file path&gt;",
209      "Import domains including settings from XML file (provide an absolute path or relative"
210      "to the client's working directory)"},
211     {"importDomainWithSettingsXML", &amp;CParameterMgr::importDomainWithSettingsXMLCommandProcess, 1,
212      "&lt;file path&gt; [overwrite]",
213      "Import a single domain including settings from XML file."
214      " Does not overwrite an existing domain unless 'overwrite' is passed as second"
215      " argument. Provide an absolute path or relative to the client's working directory)"},
216     {"getDomainsWithSettingsXML", &amp;CParameterMgr::getDomainsWithSettingsXMLCommandProcess, 0, "",
217      "Print domains including settings as XML"},
218     {"getDomainWithSettingsXML", &amp;CParameterMgr::getDomainWithSettingsXMLCommandProcess, 1,
219      "&lt;domain&gt;", "Print the given domain including settings as XML"},
220     {"setDomainsWithSettingsXML", &amp;CParameterMgr::setDomainsWithSettingsXMLCommandProcess, 1,
221      "&lt;xml configurable domains&gt;", "Import domains including settings from XML string"},
222     {"setDomainWithSettingsXML", &amp;CParameterMgr::setDomainWithSettingsXMLCommandProcess, 1,
223      "&lt;xml configurable domain&gt; [overwrite]",
224      "Import domains including settings from XML"
225      " string. Does not overwrite an existing domain unless 'overwrite' is passed as second"
226      " argument"},
227     {"getSystemClassXML", &amp;CParameterMgr::getSystemClassXMLCommandProcess, 0, "",
228      "Print parameter structure as XML"},
229     {"getDomainsXML", &amp;CParameterMgr::getDomainsWithSettingsXMLCommandProcess, 0, "",
230      "DEPRECATED COMMAND, please use getDomainsWithSettingsXML"},
231 };
232 CParameterMgr::CParameterMgr(const string &amp;strConfigurationFilePath, log::ILogger &amp;logger)
233     : _pMainParameterBlackboard(new CParameterBlackboard),
234       _pElementLibrarySet(new CElementLibrarySet),
235       _xmlConfigurationUri(CXmlDocSource::mkUri(strConfigurationFilePath, "")), _logger(logger)
236 {
237     addChild(new CParameterFrameworkConfiguration);
238     addChild(new CSelectionCriteria);
239     addChild(new CSystemClass(_logger));
240     addChild(new CConfigurableDomains);
241 }
242 CParameterMgr::~CParameterMgr()
243 {
244 <a name="0"></a>    delete _pRemoteProcessorServer;
245     delete _pMainParameterBlackboard;
246     delete _pElementLibrarySet;
247 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
248 string CParameterMgr::getKind() const
249 {
250     return "ParameterMgr";
251 }
252 string CParameterMgr::getVersion() const
253 {
254     return PARAMETER_FRAMEWORK_VERSION;
255 }
256 bool CParameterMgr::load(string &amp;strError)</b></font>
257 {
258     LOG_CONTEXT("Loading");
259     feedElementLibraries();
260     if (!loadFrameworkConfiguration(strError)) {
261         return false;
262     }
263     if (!loadSubsystems(strError)) {
264         return false;
265     }
266     if (!loadStructure(strError)) {
267         return false;
268     }
269     if (!loadSettings(strError)) {
270         return false;
271     }
272     if (!init(strError)) {
273         return false;
274     }
275     {
276         LOG_CONTEXT("Main blackboard back synchronization");
277         BackSynchronizer(getConstSystemClass(), _pMainParameterBlackboard).sync();
278     }
279     CConfigurableDomains *pConfigurableDomains = getConfigurableDomains();
280     pConfigurableDomains-&gt;validate(_pMainParameterBlackboard);
281     {
282         LOG_CONTEXT("Criterion states");
283         const CSelectionCriteria *selectionCriteria = getConstSelectionCriteria();
284         list&lt;string&gt; criteria;
285         selectionCriteria-&gt;listSelectionCriteria(criteria, true, false);
286         info() &lt;&lt; criteria;
287     }
288     getSystemClass()-&gt;cleanSubsystemsNeedToResync();
289     doApplyConfigurations(true);
290     return handleRemoteProcessingInterface(strError);
291 }
292 bool CParameterMgr::loadFrameworkConfiguration(string &amp;strError)
293 {
294     LOG_CONTEXT("Loading framework configuration");
295     CXmlElementSerializingContext elementSerializingContext(strError);
296     _xmlDoc *doc =
297         CXmlDocSource::mkXmlDoc(_xmlConfigurationUri, true, true, elementSerializingContext);
298     if (doc == nullptr) {
299         return false;
300     }
301     if (!xmlParse(elementSerializingContext, getFrameworkConfiguration(), doc, _xmlConfigurationUri,
302                   EFrameworkConfigurationLibrary)) {
303         return false;
304     }
305     getSystemClass()-&gt;setName(getConstFrameworkConfiguration()-&gt;getSystemClassName());
306     getConfigurableDomains()-&gt;setName(getConstFrameworkConfiguration()-&gt;getSystemClassName());
307     _pSubsystemPlugins = static_cast&lt;const CSubsystemPlugins *&gt;(
308         getConstFrameworkConfiguration()-&gt;findChild("SubsystemPlugins"));
309     if (!_pSubsystemPlugins) {
310         strError = "Parameter Framework Configuration: couldn't find SubsystemPlugins element";
311         return false;
312     }
313     info() &lt;&lt; "Tuning "
314            &lt;&lt; (getConstFrameworkConfiguration()-&gt;isTuningAllowed() ? "allowed" : "prohibited");
315     return true;
316 }
317 bool CParameterMgr::loadSubsystems(std::string &amp;error)
318 {
319     LOG_CONTEXT("Loading subsystem plugins");
320     bool isSuccess =
321         getSystemClass()-&gt;loadSubsystems(error, _pSubsystemPlugins, !_bFailOnMissingSubsystem);
322     if (isSuccess) {
323         info() &lt;&lt; "All subsystem plugins successfully loaded";
324         if (!error.empty()) {
325             info() &lt;&lt; error;
326         }
327     } else {
328         warning() &lt;&lt; error;
329     }
330     return isSuccess;
331 }
332 bool CParameterMgr::loadStructure(string &amp;strError)
333 {
334     CSystemClass *pSystemClass = getSystemClass();
335     LOG_CONTEXT("Loading " + pSystemClass-&gt;getName() + " system class structure");
336     const CFrameworkConfigurationLocation *pStructureDescriptionFileLocation =
337         static_cast&lt;const CFrameworkConfigurationLocation *&gt;(
338             getConstFrameworkConfiguration()-&gt;findChildOfKind("StructureDescriptionFileLocation"));
339     if (!pStructureDescriptionFileLocation) {
340         strError = "No StructureDescriptionFileLocation element found for SystemClass " +
341                    pSystemClass-&gt;getName();
342         return false;
343     }
344     CParameterAccessContext accessContext(strError);
345     CXmlParameterSerializingContext parameterBuildContext(accessContext, strError);
346     {
347         string structureUri =
348             CXmlDocSource::mkUri(_xmlConfigurationUri, pStructureDescriptionFileLocation-&gt;getUri());
349         LOG_CONTEXT("Importing system structure from file " + structureUri);
350         _xmlDoc *doc = CXmlDocSource::mkXmlDoc(structureUri, true, true, parameterBuildContext);
351         if (doc == nullptr) {
352             return false;
353         }
354         if (!xmlParse(parameterBuildContext, pSystemClass, doc, structureUri,
355                       EParameterCreationLibrary)) {
356             return false;
357         }
358     }
359     pSystemClass-&gt;setOffset(0);
360     _pMainParameterBlackboard-&gt;setSize(pSystemClass-&gt;getFootPrint());
361     return true;
362 }
363 bool CParameterMgr::loadSettings(string &amp;strError)
364 {
365     string strLoadError;
366     bool success = loadSettingsFromConfigFile(strLoadError);
367     if (!success &amp;&amp; !_bFailOnFailedSettingsLoad) {
368         warning() &lt;&lt; strLoadError;
369         warning() &lt;&lt; "Failed to load settings, continue without domains.";
370         success = true;
371     }
372     if (!success) {
373         strError = strLoadError;
374         return false;
375     }
376     return true;
377 }
378 bool CParameterMgr::loadSettingsFromConfigFile(string &amp;strError)
379 {
380     LOG_CONTEXT("Loading settings");
381     const CFrameworkConfigurationGroup *pParameterConfigurationGroup =
382         static_cast&lt;const CFrameworkConfigurationGroup *&gt;(
383             getConstFrameworkConfiguration()-&gt;findChildOfKind("SettingsConfiguration"));
384     if (!pParameterConfigurationGroup) {
385         return true;
386     }
387     const CFrameworkConfigurationLocation *pConfigurableDomainsFileLocation =
388         static_cast&lt;const CFrameworkConfigurationLocation *&gt;(
389             pParameterConfigurationGroup-&gt;findChildOfKind("ConfigurableDomainsFileLocation"));
390     if (!pConfigurableDomainsFileLocation) {
391         strError = "No ConfigurableDomainsFileLocation element found for SystemClass " +
392                    getSystemClass()-&gt;getName();
393         return false;
394     }
395     CConfigurableDomains *pConfigurableDomains = getConfigurableDomains();
396     string configurationDomainsUri =
397         CXmlDocSource::mkUri(_xmlConfigurationUri, pConfigurableDomainsFileLocation-&gt;getUri());
398     CXmlDomainImportContext xmlDomainImportContext(strError, true, *getSystemClass());
399     xmlDomainImportContext.setSelectionCriteriaDefinition(
400         getConstSelectionCriteria()-&gt;getSelectionCriteriaDefinition());
401     xmlDomainImportContext.setAutoValidationRequired(true);
402     info() &lt;&lt; "Importing configurable domains from file " &lt;&lt; configurationDomainsUri
403            &lt;&lt; " with settings";
404     _xmlDoc *doc =
405         CXmlDocSource::mkXmlDoc(configurationDomainsUri, true, true, xmlDomainImportContext);
406     if (doc == nullptr) {
407         return false;
408     }
409     return xmlParse(xmlDomainImportContext, pConfigurableDomains, doc, _xmlConfigurationUri,
410                     EParameterConfigurationLibrary, true, "SystemClassName");
411 }
412 bool CParameterMgr::xmlParse(CXmlElementSerializingContext &amp;elementSerializingContext,
413                              CElement *pRootElement, _xmlDoc *doc, const string &amp;baseUri,
414                              CParameterMgr::ElementLibrary eElementLibrary, bool replace,
415                              const string &amp;strNameAttributeName)
416 {
417     elementSerializingContext.set(_pElementLibrarySet-&gt;getElementLibrary(eElementLibrary), baseUri);
418     CXmlDocSource docSource(doc, _bValidateSchemasOnStart, pRootElement-&gt;getXmlElementName(),
419                             pRootElement-&gt;getName(), strNameAttributeName);
420     docSource.setSchemaBaseUri(getSchemaUri());
421     auto clean = [replace, &amp;pRootElement] {
422         if (replace) {
423             pRootElement-&gt;clean();
424         }
425     };
426     clean();
427     CXmlMemoryDocSink memorySink(pRootElement);
428     if (!memorySink.process(docSource, elementSerializingContext)) {
429         clean();
430         return false;
431     }
432     return true;
433 }
434 bool CParameterMgr::init(string &amp;strError)
435 {
436     return base::init(strError);
437 }
438 CSelectionCriterionType *CParameterMgr::createSelectionCriterionType(bool bIsInclusive)
439 {
440     return getSelectionCriteria()-&gt;createSelectionCriterionType(bIsInclusive);
441 }
442 CSelectionCriterion *CParameterMgr::createSelectionCriterion(
443     const string &amp;strName, const CSelectionCriterionType *pSelectionCriterionType)
444 {
445     return getSelectionCriteria()-&gt;createSelectionCriterion(strName, pSelectionCriterionType,
446                                                             _logger);
447 }
448 CSelectionCriterion *CParameterMgr::getSelectionCriterion(const string &amp;strName)
449 {
450     return getSelectionCriteria()-&gt;getSelectionCriterion(strName);
451 }
452 void CParameterMgr::applyConfigurations()
453 {
454     LOG_CONTEXT("Configuration application request");
455     lock_guard&lt;mutex&gt; autoLock(getBlackboardMutex());
456     if (!_bTuningModeIsOn) {
457         doApplyConfigurations(false);
458     } else {
459         warning() &lt;&lt; "Configurations were not applied because the TuningMode is on";
460     }
461 }
462 const CConfigurableElement *CParameterMgr::getConfigurableElement(const string &amp;strPath,
463                                                                   string &amp;strError) const
464 {
465     CPathNavigator pathNavigator(strPath);
466     if (!pathNavigator.navigateThrough(getConstSystemClass()-&gt;getName(), strError)) {
467         return nullptr;
468     }
469     const CElement *pElement = getConstSystemClass()-&gt;findDescendant(pathNavigator);
470     if (!pElement) {
471         strError = "Path not found: " + strPath;
472         return nullptr;
473     }
474     const CConfigurableElement *pConfigurableElement =
475         static_cast&lt;const CConfigurableElement *&gt;(pElement);
476     return pConfigurableElement;
477 }
478 CConfigurableElement *CParameterMgr::getConfigurableElement(const string &amp;strPath, string &amp;strError)
479 {
480     const auto *constThis = this;
481     return const_cast&lt;CConfigurableElement *&gt;(constThis-&gt;getConfigurableElement(strPath, strError));
482 }
483 CParameterHandle *CParameterMgr::createParameterHandle(const string &amp;strPath, string &amp;strError)
484 {
485     CConfigurableElement *pConfigurableElement = getConfigurableElement(strPath, strError);
486     if (!pConfigurableElement) {
487         strError = "Element not found: " + strPath;
488         return nullptr;
489     }
490     if (!pConfigurableElement-&gt;isParameter()) {
491         strError = "Not a parameter: " + strPath;
492         return nullptr;
493     }
494     return new CParameterHandle(static_cast&lt;CBaseParameter &amp;&gt;(*pConfigurableElement), *this);
495 }
496 ElementHandle *CParameterMgr::createElementHandle(const std::string &amp;path, std::string &amp;error)
497 {
498     CConfigurableElement *pConfigurableElement;
499     if (path == "/") {
500         pConfigurableElement = getSystemClass();
501     } else {
502         pConfigurableElement = getConfigurableElement(path, error);
503     }
504     if (!pConfigurableElement) {
505         error = "Element not found: " + path;
506         return nullptr;
507     }
508     return new ElementHandle(*pConfigurableElement, *this);
509 }
510 void CParameterMgr::getSettingsAsBytes(const CConfigurableElement &amp;element,
511                                        std::vector&lt;uint8_t&gt; &amp;settings) const
512 {
513     std::string error;
514     CParameterAccessContext parameterAccessContext(error);
515     parameterAccessContext.setParameterBlackboard(_pMainParameterBlackboard);
516     element.getSettingsAsBytes(settings, parameterAccessContext);
517 }
518 bool CParameterMgr::setSettingsAsBytes(const CConfigurableElement &amp;element,
519                                        const std::vector&lt;uint8_t&gt; &amp;settings, std::string &amp;error)
520 {
521     CParameterAccessContext parameterAccessContext(error);
522     parameterAccessContext.setParameterBlackboard(_pMainParameterBlackboard);
523     parameterAccessContext.setAutoSync(autoSyncOn());
524     return element.setSettingsAsBytes(settings, parameterAccessContext);
525 }
526 void CParameterMgr::setFailureOnMissingSubsystem(bool bFail)
527 {
528     _bFailOnMissingSubsystem = bFail;
529 }
530 bool CParameterMgr::getFailureOnMissingSubsystem() const
531 {
532     return _bFailOnMissingSubsystem;
533 }
534 void CParameterMgr::setFailureOnFailedSettingsLoad(bool bFail)
535 {
536     _bFailOnFailedSettingsLoad = bFail;
537 }
538 bool CParameterMgr::getFailureOnFailedSettingsLoad() const
539 {
540     return _bFailOnFailedSettingsLoad;
541 }
542 const string &amp;CParameterMgr::getSchemaUri() const
543 {
544     return _schemaUri;
545 }
546 void CParameterMgr::setSchemaUri(const string &amp;schemaUri)
547 {
548     _schemaUri = schemaUri;
549 }
550 void CParameterMgr::setValidateSchemasOnStart(bool bValidate)
551 {
552     _bValidateSchemasOnStart = bValidate;
553 }
554 bool CParameterMgr::getValidateSchemasOnStart() const
555 {
556     return _bValidateSchemasOnStart;
557 }
558 CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::versionCommandProcess(
559 {
560     strResult = getVersion();
561     return CCommandHandler::ESucceeded;
562 }
563 CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::statusCommandProcess(
564 {
565     const CSystemClass *pSystemClass = getSystemClass();
566     utility::appendTitle(strResult, "General:");
567     strResult += "System Class: ";
568     strResult += pSystemClass-&gt;getName();
569     strResult += "\n";
570     strResult += "Tuning Mode: ";
571     strResult += tuningModeOn() ? "on" : "off";
572     strResult += "\n";
573     strResult += "Value Space: ";
574     strResult += valueSpaceIsRaw() ? "raw" : "real";
575     strResult += "\n";
576     strResult += "Output Raw Format: ";
577     strResult += outputRawFormatIsHex() ? "hex" : "dec";
578     strResult += "\n";
579     strResult += "Auto Sync: ";
580     strResult += autoSyncOn() ? "on" : "off";
581     strResult += "\n";
582     utility::appendTitle(strResult, "Subsystems:");
583     string strSubsystemList;
584     pSystemClass-&gt;listChildrenPaths(strSubsystemList);
585     strResult += strSubsystemList;
586     utility::appendTitle(strResult, "Last Applied [Pending] Configurations:");
587     string strLastAppliedConfigurations;
588     getConfigurableDomains()-&gt;listLastAppliedConfigurations(strLastAppliedConfigurations);
589     strResult += strLastAppliedConfigurations;
590     utility::appendTitle(strResult, "Selection Criteria:");
591     list&lt;string&gt; lstrSelectionCriteria;
592     getSelectionCriteria()-&gt;listSelectionCriteria(lstrSelectionCriteria, false, true);
593     strResult += utility::asString(lstrSelectionCriteria);
594     return CCommandHandler::ESucceeded;
595 }
596 CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::setTuningModeCommandProcess(
597     const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
598 {
599     if (remoteCommand.getArgument(0) == "on") {
600         if (setTuningMode(true, strResult)) {
601             return CCommandHandler::EDone;
602         }
603     } else if (remoteCommand.getArgument(0) == "off") {
604         if (setTuningMode(false, strResult)) {
605             return CCommandHandler::EDone;
606         }
607     } else {
608         return CCommandHandler::EShowUsage;
609     }
610     return CCommandHandler::EFailed;
611 }
612 CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::getTuningModeCommandProcess(
613 {
614     strResult = tuningModeOn() ? "on" : "off";
615     return CCommandHandler::ESucceeded;
616 }
617 CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::setValueSpaceCommandProcess(
618 {
619     if (remoteCommand.getArgument(0) == "raw") {
620         setValueSpace(true);
621         return CCommandHandler::EDone;
622     } else if (remoteCommand.getArgument(0) == "real") {
623         setValueSpace(false);
624         return CCommandHandler::EDone;
625     } else {
626         return CCommandHandler::EShowUsage;
627     }
628     return CCommandHandler::EFailed;
629 }
630 CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::getValueSpaceCommandProcess(
631 {
632     strResult = valueSpaceIsRaw() ? "raw" : "real";
633     return CCommandHandler::ESucceeded;
634 }
635 CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::setOutputRawFormatCommandProcess(
636 {
637     if (remoteCommand.getArgument(0) == "hex") {
638         setOutputRawFormat(true);
639         return CCommandHandler::EDone;
640     } else if (remoteCommand.getArgument(0) == "dec") {
641         setOutputRawFormat(false);
642         return CCommandHandler::EDone;
643     } else {
644         return CCommandHandler::EShowUsage;
645     }
646     return CCommandHandler::EFailed;
647 }
648 CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::getOutputRawFormatCommandProcess(
649 {
650     strResult = outputRawFormatIsHex() ? "hex" : "dec";
651     return CCommandHandler::ESucceeded;
652 }
653 CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::setAutoSyncCommandProcess(
654     const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
655 {
656     if (remoteCommand.getArgument(0) == "on") {
657         if (setAutoSync(true, strResult)) {
658             return CCommandHandler::EDone;
659         }
660     } else if (remoteCommand.getArgument(0) == "off") {
661         if (setAutoSync(false, strResult)) {
662             return CCommandHandler::EDone;
663         }
664     } else {
665         return CCommandHandler::EShowUsage;
666     }
667     return CCommandHandler::EFailed;
668 }
669 CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::getAutoSyncCommandProcess(
670 {
671     strResult = autoSyncOn() ? "on" : "off";
672     return CCommandHandler::ESucceeded;
673 }
674 CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::syncCommandProcess(
675     const IRemoteCommand &amp;, string &amp;strResult)
676 {
677     return sync(strResult) ? CCommandHandler::EDone : CCommandHandler::EFailed;
678 }
679 CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::listCriteriaCommandProcess(
680     const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
681 {
682     if (remoteCommand.getArgumentCount() &gt; 1) {
683         return CCommandHandler::EShowUsage;
684     }
685     string strOutputFormat;
686     if (remoteCommand.getArgumentCount() == 1) {
687         strOutputFormat = remoteCommand.getArgument(0);
688         std::transform(strOutputFormat.begin(), strOutputFormat.end(), strOutputFormat.begin(),
689                        ::toupper);
690         if (strOutputFormat != "XML" &amp;&amp; strOutputFormat != "CSV") {
691             return CCommandHandler::EShowUsage;
692         }
693     }
694     if (strOutputFormat == "XML") {
695         const CSelectionCriteriaDefinition *pSelectionCriteriaDefinition =
696             getConstSelectionCriteria()-&gt;getSelectionCriteriaDefinition();
697         if (!exportElementToXMLString(pSelectionCriteriaDefinition, "SelectionCriteria",
698                                       CXmlSerializingContext{strResult}, strResult)) {
699             return CCommandHandler::EFailed;
700         }
701         return CCommandHandler::ESucceeded;
702     } else {
703         bool bHumanReadable = strOutputFormat.empty();
704         list&lt;string&gt; lstrResult;
705         getSelectionCriteria()-&gt;listSelectionCriteria(lstrResult, true, bHumanReadable);
706         strResult += utility::asString(lstrResult);
707         return CCommandHandler::ESucceeded;
708     }
709 }
710 CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::listDomainsCommandProcess(
711 {
712     getConfigurableDomains()-&gt;listDomains(strResult);
713     return CCommandHandler::ESucceeded;
714 }
715 CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::createDomainCommandProcess(
716     const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
717 {
718     return createDomain(remoteCommand.getArgument(0), strResult) ? CCommandHandler::EDone
719                                                                  : CCommandHandler::EFailed;
720 }
721 CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::deleteDomainCommandProcess(
722     const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
723 {
724     return deleteDomain(remoteCommand.getArgument(0), strResult) ? CCommandHandler::EDone
725                                                                  : CCommandHandler::EFailed;
726 }
727 CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::deleteAllDomainsCommandProcess(
728 {
729     return deleteAllDomains(strResult) ? CCommandHandler::EDone : CCommandHandler::EFailed;
730 }
731 CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::renameDomainCommandProcess(
732     const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
733 {
734     return renameDomain(remoteCommand.getArgument(0), remoteCommand.getArgument(1), strResult)
735                ? CCommandHandler::EDone
736                : CCommandHandler::EFailed;
737 }
738 CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::setSequenceAwarenessCommandProcess(
739     const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
740 {
741     bool bSequenceAware;
742     if (remoteCommand.getArgument(1) == "true") {
743         bSequenceAware = true;
744     } else if (remoteCommand.getArgument(1) == "false") {
745         bSequenceAware = false;
746     } else {
747         return CCommandHandler::EShowUsage;
748     }
749     return setSequenceAwareness(remoteCommand.getArgument(0), bSequenceAware, strResult)
750                ? CCommandHandler::EDone
751                : CCommandHandler::EFailed;
752 }
753 CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::getSequenceAwarenessCommandProcess(
754     const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
755 {
756     bool bSequenceAware;
757     if (!getSequenceAwareness(remoteCommand.getArgument(0), bSequenceAware, strResult)) {
758         return CCommandHandler::EFailed;
759     }
760     strResult = bSequenceAware ? "true" : "false";
761     return CCommandHandler::ESucceeded;
762 }
763 CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::listDomainElementsCommandProcess(
764     const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
765 {
766     return getConfigurableDomains()-&gt;listDomainElements(remoteCommand.getArgument(0), strResult)
767                ? CCommandHandler::ESucceeded
768                : CCommandHandler::EFailed;
769 }
770 CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::addElementCommandProcess(
771     const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
772 {
773     return addConfigurableElementToDomain(remoteCommand.getArgument(0),
774                                           remoteCommand.getArgument(1), strResult)
775                ? CCommandHandler::EDone
776                : CCommandHandler::EFailed;
777 }
778 CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::removeElementCommandProcess(
779     const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
780 {
781     return removeConfigurableElementFromDomain(remoteCommand.getArgument(0),
782                                                remoteCommand.getArgument(1), strResult)
783                ? CCommandHandler::EDone
784                : CCommandHandler::EFailed;
785 }
786 CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::splitDomainCommandProcess(
787     const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
788 {
789     return split(remoteCommand.getArgument(0), remoteCommand.getArgument(1), strResult)
790                ? CCommandHandler::EDone
791                : CCommandHandler::EFailed;
792 }
793 CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::listConfigurationsCommandProcess(
794     const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
795 {
796     return getConstConfigurableDomains()-&gt;listConfigurations(remoteCommand.getArgument(0),
797                                                              strResult)
798                ? CCommandHandler::ESucceeded
799                : CCommandHandler::EFailed;
800 }
801 CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::dumpDomainsCommandProcess(
802 {
803     string strError;
804     utility::ErrorContext errorContext(strError);
805     strResult = getConstConfigurableDomains()-&gt;dumpContent(errorContext);
806     return CCommandHandler::ESucceeded;
807 }
808 CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::createConfigurationCommandProcess(
809     const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
810 {
811     return createConfiguration(remoteCommand.getArgument(0), remoteCommand.getArgument(1),
812                                strResult)
813                ? CCommandHandler::EDone
814                : CCommandHandler::EFailed;
815 }
816 CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::deleteConfigurationCommandProcess(
817     const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
818 {
819     return deleteConfiguration(remoteCommand.getArgument(0), remoteCommand.getArgument(1),
820                                strResult)
821                ? CCommandHandler::EDone
822                : CCommandHandler::EFailed;
823 }
824 CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::renameConfigurationCommandProcess(
825     const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
826 {
827     return renameConfiguration(remoteCommand.getArgument(0), remoteCommand.getArgument(1),
828                                remoteCommand.getArgument(2), strResult)
829                ? CCommandHandler::EDone
830                : CCommandHandler::EFailed;
831 }
832 CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::saveConfigurationCommandProcess(
833     const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
834 {
835     return saveConfiguration(remoteCommand.getArgument(0), remoteCommand.getArgument(1), strResult)
836                ? CCommandHandler::EDone
837                : CCommandHandler::EFailed;
838 }
839 CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::restoreConfigurationCommandProcess(
840     const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
841 {
842     core::Results result;
843     if (!restoreConfiguration(remoteCommand.getArgument(0), remoteCommand.getArgument(1), result)) {
844         strResult = utility::asString(result);
845         return CCommandHandler::EFailed;
846     }
847     return CCommandHandler::EDone;
848 }
849 CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::setElementSequenceCommandProcess(
850     const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
851 {
852     std::vector&lt;string&gt; astrNewElementSequence;
853     for (size_t argument = 2; argument &lt; remoteCommand.getArgumentCount(); argument++) {
854         astrNewElementSequence.push_back(remoteCommand.getArgument(argument));
855     }
856     return setElementSequence(remoteCommand.getArgument(0), remoteCommand.getArgument(1),
857                               astrNewElementSequence, strResult)
858                ? CCommandHandler::EDone
859                : CCommandHandler::EFailed;
860 }
861 CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::getElementSequenceCommandProcess(
862     const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
863 {
864     return getConfigurableDomains()-&gt;getElementSequence(remoteCommand.getArgument(0),
865                                                         remoteCommand.getArgument(1), strResult)
866                ? CCommandHandler::ESucceeded
867                : CCommandHandler::EFailed;
868 }
869 CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::setRuleCommandProcess(
870     const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
871 {
872     return setApplicationRule(remoteCommand.getArgument(0), remoteCommand.getArgument(1),
873                               remoteCommand.packArguments(2, remoteCommand.getArgumentCount() - 2),
874                               strResult)
875                ? CCommandHandler::EDone
876                : CCommandHandler::EFailed;
877 }
878 CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::clearRuleCommandProcess(
879     const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
880 {
881     return clearApplicationRule(remoteCommand.getArgument(0), remoteCommand.getArgument(1),
882                                 strResult)
883                ? CCommandHandler::EDone
884                : CCommandHandler::EFailed;
885 }
886 CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::getRuleCommandProcess(
887     const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
888 {
889     return getApplicationRule(remoteCommand.getArgument(0), remoteCommand.getArgument(1), strResult)
890                ? CCommandHandler::ESucceeded
891                : CCommandHandler::EFailed;
892 }
893 CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::listElementsCommandProcess(
894     const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
895 {
896     CElementLocator elementLocator(getSystemClass(), false);
897     CElement *pLocatedElement = nullptr;
898     if (!elementLocator.locate(remoteCommand.getArgument(0), &amp;pLocatedElement, strResult)) {
899         return CCommandHandler::EFailed;
900     }
901     if (!pLocatedElement) {
902         pLocatedElement = getSystemClass();
903     }
904     strResult += pLocatedElement-&gt;listQualifiedPaths(false);
905     return CCommandHandler::ESucceeded;
906 }
907 CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::listParametersCommandProcess(
908     const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
909 {
910     CElementLocator elementLocator(getSystemClass(), false);
911     CElement *pLocatedElement = nullptr;
912     if (!elementLocator.locate(remoteCommand.getArgument(0), &amp;pLocatedElement, strResult)) {
913         return CCommandHandler::EFailed;
914     }
915     if (!pLocatedElement) {
916         pLocatedElement = getSystemClass();
917     }
918     strResult += pLocatedElement-&gt;listQualifiedPaths(true);
919     return CCommandHandler::ESucceeded;
920 }
921 CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::getElementStructureXMLCommandProcess(
922     const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
923 {
924     CElementLocator elementLocator(getSystemClass());
925     CElement *pLocatedElement = nullptr;
926     if (!elementLocator.locate(remoteCommand.getArgument(0), &amp;pLocatedElement, strResult)) {
927         return CCommandHandler::EFailed;
928     }
929     CParameterAccessContext accessContext(strResult);
930     if (!exportElementToXMLString(pLocatedElement, pLocatedElement-&gt;getXmlElementName(),
931                                   CXmlParameterSerializingContext{accessContext, strResult},
932                                   strResult)) {
933         return CCommandHandler::EFailed;
934     }
935     return CCommandHandler::ESucceeded;
936 }
937 CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::getElementBytesCommandProcess(
938     const IRemoteCommand &amp;remoteCommand, std::string &amp;strResult)
939 {
940     CElementLocator elementLocator(getSystemClass());
941     CElement *pLocatedElement = nullptr;
942     if (!elementLocator.locate(remoteCommand.getArgument(0), &amp;pLocatedElement, strResult)) {
943         return CCommandHandler::EFailed;
944     }
945     const CConfigurableElement *pConfigurableElement =
946         static_cast&lt;CConfigurableElement *&gt;(pLocatedElement);
947     vector&lt;uint8_t&gt; bytes;
948     getSettingsAsBytes(*pConfigurableElement, bytes);
949     std::ostringstream ostream;
950     ostream &lt;&lt; std::hex &lt;&lt; std::setfill('0');
951     for (auto byte : bytes) {
952         ostream &lt;&lt; "0x" &lt;&lt; std::setw(2) &lt;&lt; int{byte} &lt;&lt; " ";
953     }
954     strResult = ostream.str();
955     if (not strResult.empty()) {
956         strResult.pop_back();
957     }
958     return CCommandHandler::ESucceeded;
959 }
960 CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::setElementBytesCommandProcess(
961     const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
962 {
963     if (!checkTuningModeOn(strResult)) {
964         return CCommandHandler::EFailed;
965     }
966     CElementLocator elementLocator(getSystemClass());
967     CElement *pLocatedElement = nullptr;
968     if (!elementLocator.locate(remoteCommand.getArgument(0), &amp;pLocatedElement, strResult)) {
969         return CCommandHandler::EFailed;
970     }
971     const CConfigurableElement *pConfigurableElement =
972         static_cast&lt;CConfigurableElement *&gt;(pLocatedElement);
973     vector&lt;uint8_t&gt; bytes;
974     auto first = remoteCommand.getArguments().cbegin() + 1;
975     auto last = remoteCommand.getArguments().cend();
976     try {
977         std::transform(first, last, begin(bytes), [](decltype(*first) input) {
978             uint8_t byte;
979             if (!convertTo(input, byte)) {
980                 throw std::domain_error("Some values out of byte range");
981             }
982             return byte;
983         });
984     } catch (const std::domain_error &amp;e) {
985         strResult = e.what();
986         return CCommandHandler::EFailed;
987     }
988     if (!setSettingsAsBytes(*pConfigurableElement, bytes, strResult)) {
989         return CCommandHandler::EFailed;
990     }
991     return CCommandHandler::EDone;
992 }
993 bool CParameterMgr::getSettingsAsXML(const CConfigurableElement *configurableElement,
994                                      string &amp;result) const
995 {
996     string error;
997     CConfigurationAccessContext configContext(error, _pMainParameterBlackboard, _bValueSpaceIsRaw,
998                                               _bOutputRawFormatIsHex, true);
999     CXmlParameterSerializingContext xmlParameterContext(configContext, error);
1000     CXmlMemoryDocSource memorySource(configurableElement, false,
1001                                      configurableElement-&gt;getXmlElementName());
1002     ostringstream output;
1003     CXmlStreamDocSink streamSink(output);
1004     if (not streamSink.process(memorySource, xmlParameterContext)) {
1005         result = error;
1006         return false;
1007     }
1008     result = output.str();
1009     return true;
1010 }
1011 bool CParameterMgr::setSettingsAsXML(CConfigurableElement *configurableElement,
1012                                      const string &amp;settings, string &amp;error)
1013 {
1014     CConfigurationAccessContext configContext(error, _pMainParameterBlackboard, _bValueSpaceIsRaw,
1015                                               _bOutputRawFormatIsHex, false);
1016     CXmlParameterSerializingContext xmlParameterContext(configContext, error);
1017     _xmlDoc *doc = CXmlDocSource::mkXmlDoc(settings, false, false, xmlParameterContext);
1018     if (doc == nullptr) {
1019         return false;
1020     }
1021     if (not xmlParse(xmlParameterContext, configurableElement, doc, "",
1022                      EParameterConfigurationLibrary, false)) {
1023         return false;
1024     }
1025     if (_bAutoSyncOn) {
1026         CSyncerSet syncerSet;
1027         static_cast&lt;CConfigurableElement *&gt;(configurableElement)-&gt;fillSyncerSet(syncerSet);
1028         core::Results errors;
1029         if (not syncerSet.sync(*_pMainParameterBlackboard, false, &amp;errors)) {
1030             error = utility::asString(errors);
1031             return false;
1032         }
1033     }
1034     return true;
1035 }
1036 CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::getElementXMLCommandProcess(
1037     const IRemoteCommand &amp;remoteCommand, string &amp;result)
1038 {
1039     CElementLocator elementLocator(getSystemClass());
1040     CElement *locatedElement = nullptr;
1041     if (not elementLocator.locate(remoteCommand.getArgument(0), &amp;locatedElement, result)) {
1042         return CCommandHandler::EFailed;
1043     }
1044     if (not getSettingsAsXML(static_cast&lt;CConfigurableElement *&gt;(locatedElement), result)) {
1045         return CCommandHandler::EFailed;
1046     }
1047     return CCommandHandler::ESucceeded;
1048 }
1049 CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::setElementXMLCommandProcess(
1050     const IRemoteCommand &amp;remoteCommand, string &amp;result)
1051 {
1052     if (!checkTuningModeOn(result)) {
1053         return CCommandHandler::EFailed;
1054     }
1055     CElementLocator elementLocator(getSystemClass());
1056     CElement *locatedElement = nullptr;
1057     if (not elementLocator.locate(remoteCommand.getArgument(0), &amp;locatedElement, result)) {
1058         return CCommandHandler::EFailed;
1059     }
1060     if (not setSettingsAsXML(static_cast&lt;CConfigurableElement *&gt;(locatedElement),
1061                              remoteCommand.getArgument(1), result)) {
1062         return CCommandHandler::EFailed;
1063     }
1064     return CCommandHandler::EDone;
1065 }
1066 CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::dumpElementCommandProcess(
1067     const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
1068 {
1069     CElementLocator elementLocator(getSystemClass());
1070     CElement *pLocatedElement = nullptr;
1071     if (!elementLocator.locate(remoteCommand.getArgument(0), &amp;pLocatedElement, strResult)) {
1072         return CCommandHandler::EFailed;
1073     }
1074     string strError;
1075     CParameterAccessContext parameterAccessContext(strError, _pMainParameterBlackboard,
1076                                                    _bValueSpaceIsRaw, _bOutputRawFormatIsHex);
1077     strResult = pLocatedElement-&gt;dumpContent(parameterAccessContext);
1078     return CCommandHandler::ESucceeded;
1079 }
1080 CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::getElementSizeCommandProcess(
1081     const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
1082 {
1083     CElementLocator elementLocator(getSystemClass());
1084     CElement *pLocatedElement = nullptr;
1085     if (!elementLocator.locate(remoteCommand.getArgument(0), &amp;pLocatedElement, strResult)) {
1086         return CCommandHandler::EFailed;
1087     }
1088     const CConfigurableElement *pConfigurableElement =
1089         static_cast&lt;const CConfigurableElement *&gt;(pLocatedElement);
1090     strResult = pConfigurableElement-&gt;getFootprintAsString();
1091     return CCommandHandler::ESucceeded;
1092 }
1093 CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::showPropertiesCommandProcess(
1094     const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
1095 {
1096     CElementLocator elementLocator(getSystemClass());
1097     CElement *pLocatedElement = nullptr;
1098     if (!elementLocator.locate(remoteCommand.getArgument(0), &amp;pLocatedElement, strResult)) {
1099         return CCommandHandler::EFailed;
1100     }
1101     const CConfigurableElement *pConfigurableElement =
1102         static_cast&lt;const CConfigurableElement *&gt;(pLocatedElement);
1103     pConfigurableElement-&gt;showProperties(strResult);
1104     return CCommandHandler::ESucceeded;
1105 }
1106 CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::getParameterCommandProcess(
1107     const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
1108 {
1109     string strValue;
1110     if (!accessParameterValue(remoteCommand.getArgument(0), strValue, false, strResult)) {
1111         return CCommandHandler::EFailed;
1112     }
1113     strResult = strValue;
1114     return CCommandHandler::ESucceeded;
1115 }
1116 CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::setParameterCommandProcess(
1117     const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
1118 {
1119     string strValue = remoteCommand.packArguments(1, remoteCommand.getArgumentCount() - 1);
1120     return accessParameterValue(remoteCommand.getArgument(0), strValue, true, strResult)
1121                ? CCommandHandler::EDone
1122                : CCommandHandler::EFailed;
1123 }
1124 CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::listBelongingDomainsCommandProcess(
1125     const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
1126 {
1127     CElementLocator elementLocator(getSystemClass());
1128     CElement *pLocatedElement = nullptr;
1129     if (!elementLocator.locate(remoteCommand.getArgument(0), &amp;pLocatedElement, strResult)) {
1130         return CCommandHandler::EFailed;
1131     }
1132     const CConfigurableElement *pConfigurableElement =
1133         static_cast&lt;const CConfigurableElement *&gt;(pLocatedElement);
1134     pConfigurableElement-&gt;listBelongingDomains(strResult);
1135     return CCommandHandler::ESucceeded;
1136 }
1137 CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::listAssociatedDomainsCommandProcess(
1138     const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
1139 {
1140     CElementLocator elementLocator(getSystemClass());
1141     CElement *pLocatedElement = nullptr;
1142     if (!elementLocator.locate(remoteCommand.getArgument(0), &amp;pLocatedElement, strResult)) {
1143         return CCommandHandler::EFailed;
1144     }
1145     const CConfigurableElement *pConfigurableElement =
1146         static_cast&lt;const CConfigurableElement *&gt;(pLocatedElement);
1147     pConfigurableElement-&gt;listAssociatedDomains(strResult);
1148     return CCommandHandler::ESucceeded;
1149 }
1150 CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::listAssociatedElementsCommandProcess(
1151 {
1152     getConfigurableDomains()-&gt;listAssociatedElements(strResult);
1153     return CCommandHandler::ESucceeded;
1154 }
1155 CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::listConflictingElementsCommandProcess(
1156 {
1157     getConfigurableDomains()-&gt;listConflictingElements(strResult);
1158     return CCommandHandler::ESucceeded;
1159 }
1160 CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::listRogueElementsCommandProcess(
1161 {
1162     getSystemClass()-&gt;listRogueElements(strResult);
1163     return CCommandHandler::ESucceeded;
1164 }
1165 CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::
1166     getConfigurationParameterCommandProcess(const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
1167 {
1168     string strOutputValue;
1169     string strError;
1170     if (!accessConfigurationValue(remoteCommand.getArgument(0), remoteCommand.getArgument(1),
1171                                   remoteCommand.getArgument(2), strOutputValue, false, strError)) {
1172         strResult = strError;
1173         return CCommandHandler::EFailed;
1174     }
1175     strResult = strOutputValue;
1176     return CCommandHandler::ESucceeded;
1177 }
1178 CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::
1179     setConfigurationParameterCommandProcess(const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
1180 {
1181     string strValue = remoteCommand.packArguments(3, remoteCommand.getArgumentCount() - 3);
1182     bool bSuccess =
1183         accessConfigurationValue(remoteCommand.getArgument(0), remoteCommand.getArgument(1),
1184                                  remoteCommand.getArgument(2), strValue, true, strResult);
1185     return bSuccess ? CCommandHandler::EDone : CCommandHandler::EFailed;
1186 }
1187 CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::showMappingCommandProcess(
1188     const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
1189 {
1190     if (!getParameterMapping(remoteCommand.getArgument(0), strResult)) {
1191         return CCommandHandler::EFailed;
1192     }
1193     return CCommandHandler::ESucceeded;
1194 }
1195 CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::exportDomainsXMLCommandProcess(
1196     const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
1197 {
1198     string strFileName = remoteCommand.getArgument(0);
1199     return exportDomainsXml(strFileName, false, true, strResult) ? CCommandHandler::EDone
1200                                                                  : CCommandHandler::EFailed;
1201 }
1202 CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::importDomainsXMLCommandProcess(
1203     const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
1204 {
1205     return importDomainsXml(remoteCommand.getArgument(0), false, true, strResult)
1206                ? CCommandHandler::EDone
1207                : CCommandHandler::EFailed;
1208 }
1209 CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::
1210     exportDomainsWithSettingsXMLCommandProcess(const IRemoteCommand &amp;remoteCommand,
1211                                                string &amp;strResult)
1212 {
1213     string strFileName = remoteCommand.getArgument(0);
1214     return exportDomainsXml(strFileName, true, true, strResult) ? CCommandHandler::EDone
1215                                                                 : CCommandHandler::EFailed;
1216 }
1217 CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::
1218     exportDomainWithSettingsXMLCommandProcess(const IRemoteCommand &amp;remoteCommand, string &amp;result)
1219 {
1220     string domainName = remoteCommand.getArgument(0);
1221     string fileName = remoteCommand.getArgument(1);
1222     return exportSingleDomainXml(fileName, domainName, true, true, result)
1223                ? CCommandHandler::EDone
1224                : CCommandHandler::EFailed;
1225 }
1226 CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::
1227     importDomainsWithSettingsXMLCommandProcess(const IRemoteCommand &amp;remoteCommand,
1228                                                string &amp;strResult)
1229 {
1230     return importDomainsXml(remoteCommand.getArgument(0), true, true, strResult)
1231                ? CCommandHandler::EDone
1232                : CCommandHandler::EFailed;
1233 }
1234 CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::
1235     importDomainWithSettingsXMLCommandProcess(const IRemoteCommand &amp;remoteCommand,
1236                                               string &amp;strResult)
1237 {
1238     bool bOverwrite = false;
1239     if (remoteCommand.getArgumentCount() &gt; 1) {
1240         if (remoteCommand.getArgument(1) == "overwrite") {
1241             bOverwrite = true;
1242         } else {
1243             return CCommandHandler::EShowUsage;
1244         }
1245     }
1246     return importSingleDomainXml(remoteCommand.getArgument(0), bOverwrite, true, true, strResult)
1247                ? CCommandHandler::EDone
1248                : CCommandHandler::EFailed;
1249 }
1250 CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::
1251 {
1252     if (!exportDomainsXml(strResult, true, false, strResult)) {
1253         return CCommandHandler::EFailed;
1254     }
1255     return CCommandHandler::ESucceeded;
1256 }
1257 CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::getDomainWithSettingsXMLCommandProcess(
1258     const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
1259 {
1260     string strDomainName = remoteCommand.getArgument(0);
1261     return exportSingleDomainXml(strResult, strDomainName, true, false, strResult)
1262                ? CCommandHandler::ESucceeded
1263                : CCommandHandler::EFailed;
1264 }
1265 CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::
1266     setDomainsWithSettingsXMLCommandProcess(const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
1267 {
1268     return importDomainsXml(remoteCommand.getArgument(0), true, false, strResult)
1269                ? CCommandHandler::EDone
1270                : CCommandHandler::EFailed;
1271 }
1272 CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::setDomainWithSettingsXMLCommandProcess(
1273     const IRemoteCommand &amp;remoteCommand, string &amp;result)
1274 {
1275     bool overwrite = false;
1276     if (remoteCommand.getArgumentCount() &gt; 1) {
1277         if (remoteCommand.getArgument(1) == "overwrite") {
1278             overwrite = true;
1279         } else {
1280             return CCommandHandler::EShowUsage;
1281         }
1282     }
1283     return importSingleDomainXml(remoteCommand.getArgument(0), overwrite, true, false, result)
1284                ? CCommandHandler::EDone
1285                : CCommandHandler::EFailed;
1286 }
1287 CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::getSystemClassXMLCommandProcess(
1288 {
1289     const CSystemClass *pSystemClass = getSystemClass();
1290     CParameterAccessContext accessContext(strResult);
1291     if (!exportElementToXMLString(pSystemClass, pSystemClass-&gt;getXmlElementName(),
1292                                   CXmlParameterSerializingContext{accessContext, strResult},
1293                                   strResult)) {
1294         return CCommandHandler::EFailed;
1295     }
1296     return CCommandHandler::ESucceeded;
1297 }
1298 bool CParameterMgr::accessParameterValue(const string &amp;strPath, string &amp;strValue, bool bSet,
1299                                          string &amp;strError)
1300 {
1301     if (bSet &amp;&amp; !checkTuningModeOn(strError)) {
1302         return false;
1303     }
1304     CParameterAccessContext parameterAccessContext(strError, _pMainParameterBlackboard,
1305                                                    _bValueSpaceIsRaw, _bOutputRawFormatIsHex);
1306     if (bSet) {
1307         parameterAccessContext.setAutoSync(_bAutoSyncOn);
1308     }
1309     return accessValue(parameterAccessContext, strPath, strValue, bSet, strError);
1310 }
1311 bool CParameterMgr::getParameterMapping(const string &amp;strPath, string &amp;strResult) const
1312 {
1313     const CConfigurableElement *pConfigurableElement = getConfigurableElement(strPath, strResult);
1314     if (!pConfigurableElement) {
1315         return false;
1316     }
1317     auto configurableElementPath = pConfigurableElement-&gt;getConfigurableElementContext();
1318     const CSubsystem *pSubsystem = pConfigurableElement-&gt;getBelongingSubsystem();
1319     if (!pSubsystem) {
1320         strResult = "Unable to find the Subsystem containing the parameter";
1321         return false;
1322     }
1323     strResult = pSubsystem-&gt;getMapping(configurableElementPath);
1324     return true;
1325 }
1326 bool CParameterMgr::accessConfigurationValue(const string &amp;strDomain,
1327                                              const string &amp;strConfiguration, const string &amp;strPath,
1328                                              string &amp;strValue, bool bSet, string &amp;strError)
1329 {
1330     CElementLocator elementLocator(getSystemClass());
1331     CElement *pLocatedElement = nullptr;
1332     if (!elementLocator.locate(strPath, &amp;pLocatedElement, strError)) {
1333         return false;
1334     }
1335     const CConfigurableElement *pConfigurableElement =
1336         static_cast&lt;const CConfigurableElement *&gt;(pLocatedElement);
1337     size_t baseOffset;
1338     bool bIsLastApplied;
1339     CParameterBlackboard *pConfigurationBlackboard = nullptr;
1340     {
1341         pConfigurationBlackboard = getConstConfigurableDomains()-&gt;findConfigurationBlackboard(
1342             strDomain, strConfiguration, pConfigurableElement, baseOffset, bIsLastApplied,
1343             strError);
1344         if (!pConfigurationBlackboard) {
1345             warning() &lt;&lt; "Fail: " &lt;&lt; strError;
1346             return false;
1347         }
1348     }
1349     info() &lt;&lt; "Element " &lt;&lt; strPath &lt;&lt; " in Domain " &lt;&lt; strDomain
1350            &lt;&lt; ", offset: " &lt;&lt; pConfigurableElement-&gt;getOffset() &lt;&lt; ", base offset: " &lt;&lt; baseOffset;
1351     CParameterAccessContext parameterAccessContext(
1352         strError, pConfigurationBlackboard, _bValueSpaceIsRaw, _bOutputRawFormatIsHex, baseOffset);
1353     if (bSet) {
1354         parameterAccessContext.setAutoSync(false);
1355     }
1356     if (!accessValue(parameterAccessContext, strPath, strValue, bSet, strError)) {
1357         return false;
1358     }
1359     if (bIsLastApplied) {
1360         parameterAccessContext.setParameterBlackboard(_pMainParameterBlackboard);
1361         if (bSet) {
1362             parameterAccessContext.setAutoSync(_bAutoSyncOn);
1363         }
1364         return accessValue(parameterAccessContext, strPath, strValue, bSet, strError);
1365     }
1366     return true;
1367 }
1368 bool CParameterMgr::accessValue(CParameterAccessContext &amp;parameterAccessContext,
1369                                 const string &amp;strPath, string &amp;strValue, bool bSet,
1370                                 string &amp;strError)
1371 {
1372     lock_guard&lt;mutex&gt; autoLock(getBlackboardMutex());
1373     CPathNavigator pathNavigator(strPath);
1374     if (!pathNavigator.navigateThrough(getConstSystemClass()-&gt;getName(), strError)) {
1375         parameterAccessContext.setError(strError);
1376         return false;
1377     }
1378     return getConstSystemClass()-&gt;accessValue(pathNavigator, strValue, bSet,
1379                                               parameterAccessContext);
1380 }
1381 bool CParameterMgr::setTuningMode(bool bOn, string &amp;strError)
1382 {
1383     if (bOn == tuningModeOn()) {
1384         strError = "Tuning mode is already in the state requested";
1385         return false;
1386     }
1387     if (bOn &amp;&amp; !getConstFrameworkConfiguration()-&gt;isTuningAllowed()) {
1388         strError = "Tuning prohibited";
1389         return false;
1390     }
1391     lock_guard&lt;mutex&gt; autoLock(getBlackboardMutex());
1392     if (!bOn) {
1393         doApplyConfigurations(true);
1394     }
1395     _bTuningModeIsOn = bOn;
1396     return true;
1397 }
1398 bool CParameterMgr::tuningModeOn() const
1399 {
1400     return _bTuningModeIsOn;
1401 }
1402 void CParameterMgr::setValueSpace(bool bIsRaw)
1403 {
1404     _bValueSpaceIsRaw = bIsRaw;
1405 }
1406 bool CParameterMgr::valueSpaceIsRaw()
1407 {
1408     return _bValueSpaceIsRaw;
1409 }
1410 void CParameterMgr::setOutputRawFormat(bool bIsHex)
1411 {
1412     _bOutputRawFormatIsHex = bIsHex;
1413 }
1414 bool CParameterMgr::outputRawFormatIsHex()
1415 {
1416     return _bOutputRawFormatIsHex;
1417 }
1418 bool CParameterMgr::setAutoSync(bool bAutoSyncOn, string &amp;strError)
1419 {
1420     if (bAutoSyncOn &amp;&amp; !_bAutoSyncOn) {
1421         if (!sync(strError)) {
1422             return false;
1423         }
1424     }
1425     _bAutoSyncOn = bAutoSyncOn;
1426     return true;
1427 }
1428 bool CParameterMgr::autoSyncOn() const
1429 {
1430     return _bAutoSyncOn;
1431 }
1432 bool CParameterMgr::sync(string &amp;strError)
1433 {
1434     if (_bAutoSyncOn) {
1435         strError = "Feature unavailable when Auto Sync is on";
1436         return false;
1437     }
1438     CSyncerSet syncerSet;
1439     getConstSystemClass()-&gt;fillSyncerSet(syncerSet);
1440     core::Results error;
1441     if (!syncerSet.sync(*_pMainParameterBlackboard, false, &amp;error)) {
1442         strError = utility::asString(error);
1443         return false;
1444     };
1445     return true;
1446 }
1447 bool CParameterMgr::createDomain(const string &amp;strName, string &amp;strError)
1448 {
1449     LOG_CONTEXT("Creating configurable domain " + strName);
1450     if (!checkTuningModeOn(strError)) {
1451         return false;
1452     }
1453     return logResult(getConfigurableDomains()-&gt;createDomain(strName, strError), strError);
1454 }
1455 bool CParameterMgr::deleteDomain(const string &amp;strName, string &amp;strError)
1456 {
1457     LOG_CONTEXT("Deleting configurable domain '" + strName + "'");
1458     if (!checkTuningModeOn(strError)) {
1459         warning() &lt;&lt; "Fail: " &lt;&lt; strError;
1460         return false;
1461     }
1462     return logResult(getConfigurableDomains()-&gt;deleteDomain(strName, strError), strError);
1463 }
1464 bool CParameterMgr::renameDomain(const string &amp;strName, const string &amp;strNewName, string &amp;strError)
1465 {
1466     LOG_CONTEXT("Renaming configurable domain '" + strName + "' to '" + strNewName + "'");
1467     return logResult(getConfigurableDomains()-&gt;renameDomain(strName, strNewName, strError),
1468                      strError);
1469 }
1470 bool CParameterMgr::deleteAllDomains(string &amp;strError)
1471 {
1472     LOG_CONTEXT("Deleting all configurable domains");
1473     if (!checkTuningModeOn(strError)) {
1474         warning() &lt;&lt; "Fail: " &lt;&lt; strError;
1475         return false;
1476     }
1477     getConfigurableDomains()-&gt;deleteAllDomains();
1478     info() &lt;&lt; "Success";
1479     return true;
1480 }
1481 bool CParameterMgr::setSequenceAwareness(const string &amp;strName, bool bSequenceAware,
1482                                          string &amp;strResult)
1483 {
1484     LOG_CONTEXT("Making domain '" + strName + "' sequence " +
1485                 (bSequenceAware ? "aware" : "unaware"));
1486     if (!checkTuningModeOn(strResult)) {
1487         warning() &lt;&lt; "Fail: " &lt;&lt; strResult;
1488         return false;
1489     }
1490     return logResult(
1491         getConfigurableDomains()-&gt;setSequenceAwareness(strName, bSequenceAware, strResult),
1492         strResult);
1493 }
1494 bool CParameterMgr::getSequenceAwareness(const string &amp;strName, bool &amp;bSequenceAware,
1495                                          string &amp;strResult)
1496 {
1497     return getConfigurableDomains()-&gt;getSequenceAwareness(strName, bSequenceAware, strResult);
1498 }
1499 bool CParameterMgr::createConfiguration(const string &amp;strDomain, const string &amp;strConfiguration,
1500                                         string &amp;strError)
1501 {
1502     LOG_CONTEXT("Creating domain configuration '" + strConfiguration + "' into domain '" +
1503                 strDomain + "'");
1504     if (!checkTuningModeOn(strError)) {
1505         warning() &lt;&lt; "Fail: " &lt;&lt; strError;
1506         return false;
1507     }
1508     return logResult(getConfigurableDomains()-&gt;createConfiguration(
1509                          strDomain, strConfiguration, _pMainParameterBlackboard, strError),
1510                      strError);
1511 }
1512 bool CParameterMgr::renameConfiguration(const string &amp;strDomain, const string &amp;strConfiguration,
1513                                         const string &amp;strNewConfiguration, string &amp;strError)
1514 {
1515     LOG_CONTEXT("Renaming domain '" + strDomain + "''s configuration '" + strConfiguration +
1516                 "' to '" + strNewConfiguration + "'");
1517     return logResult(getConfigurableDomains()-&gt;renameConfiguration(strDomain, strConfiguration,
1518                                                                    strNewConfiguration, strError),
1519                      strError);
1520 }
1521 bool CParameterMgr::deleteConfiguration(const string &amp;strDomain, const string &amp;strConfiguration,
1522                                         string &amp;strError)
1523 {
1524     LOG_CONTEXT("Deleting configuration '" + strConfiguration + "' from domain '" + strDomain +
1525                 "'");
1526     if (!checkTuningModeOn(strError)) {
1527         warning() &lt;&lt; "Fail:" &lt;&lt; strError;
1528         return false;
1529     }
1530     return logResult(
1531         getConfigurableDomains()-&gt;deleteConfiguration(strDomain, strConfiguration, strError),
1532         strError);
1533 }
1534 bool CParameterMgr::restoreConfiguration(const string &amp;strDomain, const string &amp;strConfiguration,
1535                                          core::Results &amp;errors)
1536 {
1537     string strError;
1538     LOG_CONTEXT("Restoring domain '" + strDomain + "''s configuration '" + strConfiguration +
1539                 "' to parameter blackboard");
1540     if (!checkTuningModeOn(strError)) {
1541         errors.push_back(strError);
1542         warning() &lt;&lt; "Fail:" &lt;&lt; strError;
1543         return false;
1544     }
1545     return logResult(
1546         getConstConfigurableDomains()-&gt;restoreConfiguration(
1547             strDomain, strConfiguration, _pMainParameterBlackboard, _bAutoSyncOn, errors),
1548         strError);
1549 }
1550 bool CParameterMgr::saveConfiguration(const string &amp;strDomain, const string &amp;strConfiguration,
1551                                       string &amp;strError)
1552 {
1553     LOG_CONTEXT("Saving domain '" + strDomain + "' configuration '" + strConfiguration +
1554                 "' from parameter blackboard");
1555     if (!checkTuningModeOn(strError)) {
1556         warning() &lt;&lt; "Fail:" &lt;&lt; strError;
1557         return false;
1558     }
1559     return logResult(getConfigurableDomains()-&gt;saveConfiguration(
1560                          strDomain, strConfiguration, _pMainParameterBlackboard, strError),
1561                      strError);
1562 }
1563 bool CParameterMgr::addConfigurableElementToDomain(const string &amp;strDomain,
1564                                                    const string &amp;strConfigurableElementPath,
1565                                                    string &amp;strError)
1566 {
1567     LOG_CONTEXT("Adding configurable element '" + strConfigurableElementPath + "' to domain '" +
1568                 strDomain + "'");
1569     if (!checkTuningModeOn(strError)) {
1570         warning() &lt;&lt; "Fail: " &lt;&lt; strError;
1571         return false;
1572     }
1573     CElementLocator elementLocator(getSystemClass());
1574     CElement *pLocatedElement = nullptr;
1575     if (!elementLocator.locate(strConfigurableElementPath, &amp;pLocatedElement, strError)) {
1576         warning() &lt;&lt; "Fail: " &lt;&lt; strError;
1577         return false;
1578     }
1579     CConfigurableElement *pConfigurableElement =
1580         static_cast&lt;CConfigurableElement *&gt;(pLocatedElement);
1581     core::Results infos;
1582     bool isSuccess = getConfigurableDomains()-&gt;addConfigurableElementToDomain(
1583         strDomain, pConfigurableElement, _pMainParameterBlackboard, infos);
1584     if (isSuccess) {
1585         info() &lt;&lt; infos;
1586     } else {
1587         warning() &lt;&lt; infos;
1588     }
1589     strError = utility::asString(infos);
1590     return isSuccess;
1591 }
1592 bool CParameterMgr::removeConfigurableElementFromDomain(const string &amp;strDomain,
1593                                                         const string &amp;strConfigurableElementPath,
1594                                                         string &amp;strError)
1595 {
1596     LOG_CONTEXT("Removing configurable element '" + strConfigurableElementPath + "' from domain '" +
1597                 strDomain + "'");
1598     if (!checkTuningModeOn(strError)) {
1599         warning() &lt;&lt; "Fail:" &lt;&lt; strError;
1600         return false;
1601     }
1602     CElementLocator elementLocator(getSystemClass());
1603     CElement *pLocatedElement = nullptr;
1604     if (!elementLocator.locate(strConfigurableElementPath, &amp;pLocatedElement, strError)) {
1605         warning() &lt;&lt; "Fail:" &lt;&lt; strError;
1606         return false;
1607     }
1608     CConfigurableElement *pConfigurableElement =
1609         static_cast&lt;CConfigurableElement *&gt;(pLocatedElement);
1610     return logResult(getConfigurableDomains()-&gt;removeConfigurableElementFromDomain(
1611                          strDomain, pConfigurableElement, strError),
1612                      strError);
1613 }
1614 bool CParameterMgr::split(const string &amp;strDomain, const string &amp;strConfigurableElementPath,
1615                           string &amp;strError)
1616 {
1617     LOG_CONTEXT("Splitting configurable element '" + strConfigurableElementPath + "' domain '" +
1618                 strDomain + "'");
1619     if (!checkTuningModeOn(strError)) {
1620         warning() &lt;&lt; "Fail:" &lt;&lt; strError;
1621         return false;
1622     }
1623     CElementLocator elementLocator(getSystemClass());
1624     CElement *pLocatedElement = nullptr;
1625     if (!elementLocator.locate(strConfigurableElementPath, &amp;pLocatedElement, strError)) {
1626         warning() &lt;&lt; "Fail: " &lt;&lt; strError;
1627         return false;
1628     }
1629     CConfigurableElement *pConfigurableElement =
1630         static_cast&lt;CConfigurableElement *&gt;(pLocatedElement);
1631     core::Results infos;
1632     bool isSuccess = getConfigurableDomains()-&gt;split(strDomain, pConfigurableElement, infos);
1633     if (isSuccess) {
1634         info() &lt;&lt; infos;
1635     } else {
1636         warning() &lt;&lt; infos;
1637     }
1638     strError = utility::asString(infos);
1639     return isSuccess;
1640 }
1641 bool CParameterMgr::setElementSequence(const string &amp;strDomain, const string &amp;strConfiguration,
1642                                        const std::vector&lt;string&gt; &amp;astrNewElementSequence,
1643                                        string &amp;strError)
1644 {
1645     if (!checkTuningModeOn(strError)) {
1646         return false;
1647     }
1648     return getConfigurableDomains()-&gt;setElementSequence(strDomain, strConfiguration,
1649                                                         astrNewElementSequence, strError);
1650 }
1651 bool CParameterMgr::getApplicationRule(const string &amp;strDomain, const string &amp;strConfiguration,
1652                                        string &amp;strResult)
1653 {
1654     return getConfigurableDomains()-&gt;getApplicationRule(strDomain, strConfiguration, strResult);
1655 }
1656 bool CParameterMgr::setApplicationRule(const string &amp;strDomain, const string &amp;strConfiguration,
1657                                        const string &amp;strApplicationRule, string &amp;strError)
1658 {
1659     return getConfigurableDomains()-&gt;setApplicationRule(
1660         strDomain, strConfiguration, strApplicationRule,
1661         getConstSelectionCriteria()-&gt;getSelectionCriteriaDefinition(), strError);
1662 }
1663 bool CParameterMgr::clearApplicationRule(const string &amp;strDomain, const string &amp;strConfiguration,
1664                                          string &amp;strError)
1665 {
1666     return getConfigurableDomains()-&gt;clearApplicationRule(strDomain, strConfiguration, strError);
1667 }
1668 bool CParameterMgr::importDomainsXml(const string &amp;xmlSource, bool withSettings, bool fromFile,
1669                                      string &amp;errorMsg)
1670 {
1671     if (!checkTuningModeOn(errorMsg)) {
1672         return false;
1673     }
1674     LOG_CONTEXT("Importing domains from " +
1675                 (fromFile ? ("\"" + xmlSource + "\"") : "a user-provided buffer"));
1676     CConfigurableDomains *pConfigurableDomains = getConfigurableDomains();
1677     bool importSuccess = wrapLegacyXmlImport(xmlSource, fromFile, withSettings,
1678                                              *pConfigurableDomains, "SystemClassName", errorMsg);
1679     if (importSuccess) {
1680         pConfigurableDomains-&gt;validate(_pMainParameterBlackboard);
1681     }
1682     return importSuccess;
1683 }
1684 bool CParameterMgr::importSingleDomainXml(const string &amp;xmlSource, bool overwrite,
1685                                           bool withSettings, bool fromFile, string &amp;errorMsg)
1686 {
1687     if (!checkTuningModeOn(errorMsg)) {
1688         return false;
1689     }
1690     LOG_CONTEXT("Importing a single domain from " +
1691                 (fromFile ? ('"' + xmlSource + '"') : "a user-provided buffer"));
1692     auto standaloneDomain = utility::make_unique&lt;CConfigurableDomain&gt;();
1693     if (!wrapLegacyXmlImport(xmlSource, fromFile, withSettings, *standaloneDomain, "", errorMsg)) {
1694         return false;
1695     }
1696     if (!getConfigurableDomains()-&gt;addDomain(*standaloneDomain, overwrite, errorMsg)) {
1697         return false;
1698     }
1699     standaloneDomain.release();
1700     return true;
1701 }
1702 bool CParameterMgr::wrapLegacyXmlImport(const string &amp;xmlSource, bool fromFile, bool withSettings,
1703                                         CElement &amp;element, const string &amp;nameAttributeName,
1704                                         string &amp;errorMsg)
1705 {
1706     CXmlDomainImportContext xmlDomainImportContext(errorMsg, withSettings, *getSystemClass());
1707     xmlDomainImportContext.setSelectionCriteriaDefinition(
1708         getConstSelectionCriteria()-&gt;getSelectionCriteriaDefinition());
1709     _xmlDoc *doc = CXmlDocSource::mkXmlDoc(xmlSource, fromFile, false, xmlDomainImportContext);
1710     if (doc == nullptr) {
1711         return false;
1712     }
1713     return xmlParse(xmlDomainImportContext, &amp;element, doc, "", EParameterConfigurationLibrary, true,
1714                     nameAttributeName);
1715 }
1716 bool CParameterMgr::serializeElement(std::ostream &amp;output,
1717                                      CXmlSerializingContext &amp;xmlSerializingContext,
1718                                      const CElement &amp;element) const
1719 {
1720     if (!output.good()) {
1721         xmlSerializingContext.setError("Can't write XML: the output is in a bad state.");
1722         return false;
1723     }
1724     CXmlMemoryDocSource memorySource(&amp;element, _bValidateSchemasOnStart,
1725                                      element.getXmlElementName(), "parameter-framework",
1726                                      getVersion());
1727     CXmlStreamDocSink sink(output);
1728     bool processSuccess = sink.process(memorySource, xmlSerializingContext);
1729     return processSuccess;
1730 }
1731 bool CParameterMgr::exportDomainsXml(string &amp;xmlDest, bool withSettings, bool toFile,
1732                                      string &amp;errorMsg) const
1733 {
1734     LOG_CONTEXT("Exporting domains to " +
1735                 (toFile ? ('"' + xmlDest + '"') : "a user-provided buffer"));
1736     const CConfigurableDomains *configurableDomains = getConstConfigurableDomains();
1737     return wrapLegacyXmlExport(xmlDest, toFile, withSettings, *configurableDomains, errorMsg);
1738 }
1739 bool CParameterMgr::exportSingleDomainXml(string &amp;xmlDest, const string &amp;domainName,
1740                                           bool withSettings, bool toFile, string &amp;errorMsg) const
1741 {
1742     LOG_CONTEXT("Exporting single domain '" + domainName + "' to " +
1743                 (toFile ? ('"' + xmlDest + '"') : "a user-provided buffer"));
1744     const CConfigurableDomain *requestedDomain =
1745         getConstConfigurableDomains()-&gt;findConfigurableDomain(domainName, errorMsg);
1746     if (requestedDomain == nullptr) {
1747         return false;
1748     }
1749     return wrapLegacyXmlExport(xmlDest, toFile, withSettings, *requestedDomain, errorMsg);
1750 }
1751 bool CParameterMgr::wrapLegacyXmlExport(string &amp;xmlDest, bool toFile, bool withSettings,
1752                                         const CElement &amp;element, string &amp;errorMsg) const
1753 {
1754     CXmlDomainExportContext context(errorMsg, withSettings, _bValueSpaceIsRaw,
1755                                     _bOutputRawFormatIsHex);
1756     if (toFile) {
1757         return wrapLegacyXmlExportToFile(xmlDest, element, context);
1758     } else {
1759         return wrapLegacyXmlExportToString(xmlDest, element, context);
1760     }
1761 }
1762 bool CParameterMgr::wrapLegacyXmlExportToFile(string &amp;xmlDest, const CElement &amp;element,
1763                                               CXmlDomainExportContext &amp;context) const
1764 {
1765     try {
1766         std::ofstream output;
1767         output.exceptions(~std::ifstream::goodbit);
1768         output.open(xmlDest.c_str());
1769         bool status = serializeElement(output, context, element);
1770         output.close(); 
1771         return status;
1772     } catch (std::ofstream::failure &amp;e) {
1773         context.setError("Failed to open \"" + xmlDest + "\" for writing: " + e.what());
1774         return false;
1775     }
1776 }
1777 bool CParameterMgr::wrapLegacyXmlExportToString(string &amp;xmlDest, const CElement &amp;element,
1778                                                 CXmlDomainExportContext &amp;context) const
1779 {
1780     std::ostringstream output;
1781     if (!serializeElement(output, context, element)) {
1782         return false;
1783     }
1784     xmlDest = output.str();
1785     return true;
1786 }
1787 bool CParameterMgr::checkTuningModeOn(string &amp;strError) const
1788 {
1789     if (!_bTuningModeIsOn) {
1790         strError = "Tuning Mode must be on";
1791         return false;
1792     }
1793     return true;
1794 }
1795 std::mutex &amp;CParameterMgr::getBlackboardMutex()
1796 {
1797     return _blackboardMutex;
1798 }
1799 CParameterBlackboard *CParameterMgr::getParameterBlackboard()
1800 {
1801     return _pMainParameterBlackboard;
1802 }
1803 void CParameterMgr::feedElementLibraries()
1804 {
1805     auto pFrameworkConfigurationLibrary = new CElementLibrary;
1806     pFrameworkConfigurationLibrary-&gt;addElementBuilder(
1807         "ParameterFrameworkConfiguration",
1808         new TElementBuilderTemplate&lt;CParameterFrameworkConfiguration&gt;());
1809     pFrameworkConfigurationLibrary-&gt;addElementBuilder(
1810         "SubsystemPlugins", new TKindElementBuilderTemplate&lt;CSubsystemPlugins&gt;());
1811     pFrameworkConfigurationLibrary-&gt;addElementBuilder(
1812         "Location", new TKindElementBuilderTemplate&lt;CPluginLocation&gt;());
1813     pFrameworkConfigurationLibrary-&gt;addElementBuilder(
1814         "StructureDescriptionFileLocation",
1815         new TKindElementBuilderTemplate&lt;CFrameworkConfigurationLocation&gt;());
1816     pFrameworkConfigurationLibrary-&gt;addElementBuilder(
1817         "SettingsConfiguration", new TKindElementBuilderTemplate&lt;CFrameworkConfigurationGroup&gt;());
1818     pFrameworkConfigurationLibrary-&gt;addElementBuilder(
1819         "ConfigurableDomainsFileLocation",
1820         new TKindElementBuilderTemplate&lt;CFrameworkConfigurationLocation&gt;());
1821     _pElementLibrarySet-&gt;addElementLibrary(pFrameworkConfigurationLibrary);
1822     auto pParameterCreationLibrary = new CElementLibrary;
1823     pParameterCreationLibrary-&gt;addElementBuilder(
1824         "Subsystem", new CSubsystemElementBuilder(getSystemClass()-&gt;getSubsystemLibrary()));
1825     pParameterCreationLibrary-&gt;addElementBuilder(
1826         "ComponentType", new TNamedElementBuilderTemplate&lt;CComponentType&gt;());
1827     pParameterCreationLibrary-&gt;addElementBuilder(
1828         "Component", new TNamedElementBuilderTemplate&lt;CComponentInstance&gt;());
1829     pParameterCreationLibrary-&gt;addElementBuilder(
1830         "BitParameter", new TNamedElementBuilderTemplate&lt;CBitParameterType&gt;());
1831     pParameterCreationLibrary-&gt;addElementBuilder(
1832         "BitParameterBlock", new TNamedElementBuilderTemplate&lt;CBitParameterBlockType&gt;());
1833     pParameterCreationLibrary-&gt;addElementBuilder(
1834         "StringParameter", new TNamedElementBuilderTemplate&lt;CStringParameterType&gt;());
1835     pParameterCreationLibrary-&gt;addElementBuilder(
1836         "ParameterBlock", new TNamedElementBuilderTemplate&lt;CParameterBlockType&gt;());
1837     pParameterCreationLibrary-&gt;addElementBuilder(
1838         "BooleanParameter", new TNamedElementBuilderTemplate&lt;CBooleanParameterType&gt;());
1839     pParameterCreationLibrary-&gt;addElementBuilder("IntegerParameter", new IntegerParameterBuilder());
1840     pParameterCreationLibrary-&gt;addElementBuilder(
1841         "LinearAdaptation", new TElementBuilderTemplate&lt;CLinearParameterAdaptation&gt;());
1842     pParameterCreationLibrary-&gt;addElementBuilder(
1843         "LogarithmicAdaptation", new TElementBuilderTemplate&lt;CLogarithmicParameterAdaptation&gt;());
1844     pParameterCreationLibrary-&gt;addElementBuilder(
1845         "EnumParameter", new TNamedElementBuilderTemplate&lt;CEnumParameterType&gt;());
1846     pParameterCreationLibrary-&gt;addElementBuilder("ValuePair",
1847                                                  new TElementBuilderTemplate&lt;CEnumValuePair&gt;());
1848     pParameterCreationLibrary-&gt;addElementBuilder(
1849         "FixedPointParameter", new TNamedElementBuilderTemplate&lt;CFixedPointParameterType&gt;());
1850     pParameterCreationLibrary-&gt;addElementBuilder(
1851         "FloatingPointParameter", new TNamedElementBuilderTemplate&lt;CFloatingPointParameterType&gt;);
1852     pParameterCreationLibrary-&gt;addElementBuilder(
1853         "SubsystemInclude",
1854         new CFileIncluderElementBuilder(_bValidateSchemasOnStart, getSchemaUri()));
1855     _pElementLibrarySet-&gt;addElementLibrary(pParameterCreationLibrary);
1856     auto pParameterConfigurationLibrary = new CElementLibrary;
1857     pParameterConfigurationLibrary-&gt;addElementBuilder(
1858         "ConfigurableDomain", new TElementBuilderTemplate&lt;CConfigurableDomain&gt;());
1859     pParameterConfigurationLibrary-&gt;addElementBuilder(
1860         "Configuration", new TNamedElementBuilderTemplate&lt;CDomainConfiguration&gt;());
1861     pParameterConfigurationLibrary-&gt;addElementBuilder("CompoundRule",
1862                                                       new TElementBuilderTemplate&lt;CCompoundRule&gt;());
1863     pParameterConfigurationLibrary-&gt;addElementBuilder(
1864         "SelectionCriterionRule", new TElementBuilderTemplate&lt;CSelectionCriterionRule&gt;());
1865     _pElementLibrarySet-&gt;addElementLibrary(pParameterConfigurationLibrary);
1866 }
1867 bool CParameterMgr::getForceNoRemoteInterface() const
1868 {
1869     return _bForceNoRemoteInterface;
1870 }
1871 void CParameterMgr::setForceNoRemoteInterface(bool bForceNoRemoteInterface)
1872 {
1873     _bForceNoRemoteInterface = bForceNoRemoteInterface;
1874 }
1875 CParameterMgr::CommandHandler CParameterMgr::createCommandHandler()
1876 {
1877     auto commandHandler = utility::make_unique&lt;CCommandHandler&gt;(this);
1878     for (const auto &amp;remoteCommandParserItem : gastRemoteCommandParserItems) {
1879         commandHandler-&gt;addCommandParser(
1880             remoteCommandParserItem._pcCommandName, remoteCommandParserItem._pfnParser,
1881             remoteCommandParserItem._minArgumentCount, remoteCommandParserItem._pcHelp,
1882             remoteCommandParserItem._pcDescription);
1883     }
1884     return commandHandler;
1885 }
1886 bool CParameterMgr::isRemoteInterfaceRequired()
1887 {
1888     return (not _bForceNoRemoteInterface) and getConstFrameworkConfiguration()-&gt;isTuningAllowed();
1889 }
1890 bool CParameterMgr::handleRemoteProcessingInterface(string &amp;strError)
1891 {
1892     LOG_CONTEXT("Handling remote processing interface");
1893     if (not isRemoteInterfaceRequired()) {
1894         return true;
1895     }
1896     auto port = getConstFrameworkConfiguration()-&gt;getServerPort();
1897     try {
1898         _pRemoteProcessorServer = new BackgroundRemoteProcessorServer(port, createCommandHandler());
1899     } catch (std::runtime_error &amp;e) {
1900         strError = string("ParameterMgr: Unable to create Remote Processor Server: ") + e.what();
1901         return false;
1902     }
1903     if (_pRemoteProcessorServer == nullptr) {
1904         strError = "ParameterMgr: Unable to create Remote Processor Server";
1905         return false;
1906     }
1907     if (!_pRemoteProcessorServer-&gt;start(strError)) {
1908         ostringstream oss;
1909         oss &lt;&lt; "ParameterMgr: Unable to start remote processor server on port " &lt;&lt; port;
1910         strError = oss.str() + ": " + strError;
1911         return false;
1912     }
1913     info() &lt;&lt; "Remote Processor Server started on port " &lt;&lt; port;
1914     return true;
1915 }
1916 CParameterFrameworkConfiguration *CParameterMgr::getFrameworkConfiguration()
1917 {
1918     return static_cast&lt;CParameterFrameworkConfiguration *&gt;(getChild(EFrameworkConfiguration));
1919 }
1920 const CParameterFrameworkConfiguration *CParameterMgr::getConstFrameworkConfiguration()
1921 {
1922     return getFrameworkConfiguration();
1923 }
1924 CSelectionCriteria *CParameterMgr::getSelectionCriteria()
1925 {
1926     return static_cast&lt;CSelectionCriteria *&gt;(getChild(ESelectionCriteria));
1927 }
1928 const CSelectionCriteria *CParameterMgr::getConstSelectionCriteria()
1929 {
1930     return static_cast&lt;const CSelectionCriteria *&gt;(getChild(ESelectionCriteria));
1931 }
1932 CSystemClass *CParameterMgr::getSystemClass()
1933 {
1934     return static_cast&lt;CSystemClass *&gt;(getChild(ESystemClass));
1935 }
1936 const CSystemClass *CParameterMgr::getConstSystemClass() const
1937 {
1938     return static_cast&lt;const CSystemClass *&gt;(getChild(ESystemClass));
1939 }
1940 CConfigurableDomains *CParameterMgr::getConfigurableDomains()
1941 {
1942     return static_cast&lt;CConfigurableDomains *&gt;(getChild(EConfigurableDomains));
1943 }
1944 const CConfigurableDomains *CParameterMgr::getConstConfigurableDomains()
1945 {
1946     return static_cast&lt;const CConfigurableDomains *&gt;(getChild(EConfigurableDomains));
1947 }
1948 const CConfigurableDomains *CParameterMgr::getConstConfigurableDomains() const
1949 {
1950     return static_cast&lt;const CConfigurableDomains *&gt;(getChild(EConfigurableDomains));
1951 }
1952 void CParameterMgr::doApplyConfigurations(bool bForce)
1953 {
1954     LOG_CONTEXT("Applying configurations");
1955     CSyncerSet syncerSet;
1956     core::Results infos;
1957     getSystemClass()-&gt;checkForSubsystemsToResync(syncerSet, infos);
1958     getConfigurableDomains()-&gt;apply(_pMainParameterBlackboard, syncerSet, bForce, infos);
1959     info() &lt;&lt; infos;
1960     getSelectionCriteria()-&gt;resetModifiedStatus();
1961 }
1962 bool CParameterMgr::exportElementToXMLString(const IXmlSource *pXmlSource,
1963                                              const string &amp;strRootElementType,
1964                                              CXmlSerializingContext &amp;&amp;xmlSerializingContext,
1965                                              string &amp;strResult) const
1966 {
1967     CXmlMemoryDocSource memorySource(pXmlSource, false, strRootElementType);
1968     ostringstream output;
1969     CXmlStreamDocSink streamSink(output);
1970     bool bProcessSuccess = streamSink.process(memorySource, xmlSerializingContext);
1971     strResult = output.str();
1972     return bProcessSuccess;
1973 }
1974 bool CParameterMgr::logResult(bool isSuccess, const std::string &amp;result)
1975 {
1976     std::string log = result.empty() ? "" : ": " + result;
1977     if (isSuccess) {
1978         info() &lt;&lt; "Success" &lt;&lt; log;
1979     } else {
1980         warning() &lt;&lt; "Fail" &lt;&lt; log;
1981     }
1982     return isSuccess;
1983 }
1984 log::details::Info CParameterMgr::info()
1985 {
1986     return _logger.info();
1987 }
1988 log::details::Warning CParameterMgr::warning()
1989 {
1990     return _logger.warning();
1991 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>BitParameterBlockType.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "BitParameterBlockType.h"
2 #include "BitParameterBlock.h"
3 #include "Utility.h"
4 #define base CTypeElement
5 using std::string;
6 <a name="0"></a>
7 CBitParameterBlockType::CBitParameterBlockType(const string &amp;strName) : base(strName)
8 {
9 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
10 string CBitParameterBlockType::getKind() const
11 {
12     return "BitParameterBlock";
13 }
14 bool CBitParameterBlockType::childrenAreDynamic() const
15 {
16     return true;
17 }
18 size_t CBitParameterBlockType::getSize() const</b></font>
19 {
20     return _size;
21 }
22 bool CBitParameterBlockType::fromXml(const CXmlElement &amp;xmlElement,
23                                      CXmlSerializingContext &amp;serializingContext)
24 {
25     xmlElement.getAttribute("Size", _size);
26     _size /= 8;
27     return base::fromXml(xmlElement, serializingContext);
28 }
29 CInstanceConfigurableElement *CBitParameterBlockType::doInstantiate() const
30 {
31     return new CBitParameterBlock(getName(), this);
32 }
33 void CBitParameterBlockType::toXml(CXmlElement &amp;xmlElement,
34                                    CXmlSerializingContext &amp;serializingContext) const
35 {
36     xmlElement.setAttribute("Size", _size * 8);
37     base::toXml(xmlElement, serializingContext);
38 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
