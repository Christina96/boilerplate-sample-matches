<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for ParameterMgr.cpp &amp; BitParameterBlockType.cpp</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for ParameterMgr.cpp &amp; BitParameterBlockType.cpp
      </h3>
<h1 align="center">
        1.0%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>ParameterMgr.cpp (0.5242464%)<th>BitParameterBlockType.cpp (30.0%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(344-357)<td><a href="#" name="0">(40-53)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>ParameterMgr.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include "version.h"
#include "ParameterMgr.h"
#include "ConfigurationAccessContext.h"
#include "XmlParameterSerializingContext.h"
#include "XmlElementSerializingContext.h"
#include "SystemClass.h"
#include "ElementLibrarySet.h"
#include "SubsystemLibrary.h"
#include "NamedElementBuilderTemplate.h"
#include "KindElementBuilderTemplate.h"
#include "ElementBuilderTemplate.h"
#include "SelectionCriterionType.h"
#include "SubsystemElementBuilder.h"
#include "FileIncluderElementBuilder.h"
#include "SelectionCriteria.h"
#include "ComponentType.h"
#include "ComponentInstance.h"
#include "ParameterBlockType.h"
#include "BooleanParameterType.h"
#include "IntegerParameterBuilder.h"
#include "FixedPointParameterType.h"
#include "FloatingPointParameterType.h"
#include "ParameterBlackboard.h"
#include "Parameter.h"
#include "ParameterAccessContext.h"
#include "ParameterFrameworkConfiguration.h"
#include "FrameworkConfigurationGroup.h"
#include "PluginLocation.h"
#include "SubsystemPlugins.h"
#include "FrameworkConfigurationLocation.h"
#include "ConfigurableDomains.h"
#include "ConfigurableDomain.h"
#include "DomainConfiguration.h"
#include "XmlDomainSerializingContext.h"
#include "XmlDomainExportContext.h"
#include "XmlDomainImportContext.h"
#include "BitParameterBlockType.h"
#include "BitParameterType.h"
#include "StringParameterType.h"
#include "EnumParameterType.h"
#include "BackgroundRemoteProcessorServer.h"
#include "ElementLocator.h"
#include "CompoundRule.h"
#include "SelectionCriterionRule.h"
#include "SimulatedBackSynchronizer.h"
#include "HardwareBackSynchronizer.h"
#include &lt;cassert&gt;
#include "ParameterHandle.h"
#include "LinearParameterAdaptation.h"
#include "LogarithmicParameterAdaptation.h"
#include "EnumValuePair.h"
#include "Subsystem.h"
#include "XmlStreamDocSink.h"
#include "XmlMemoryDocSink.h"
#include "XmlDocSource.h"
#include "XmlMemoryDocSource.h"
#include "SelectionCriteriaDefinition.h"
#include "Utility.h"
#include "Memory.hpp"
#include &lt;sstream&gt;
#include &lt;fstream&gt;
#include &lt;algorithm&gt;
#include &lt;stdexcept&gt;
#include &lt;mutex&gt;
#include &lt;iomanip&gt;
#include "convert.hpp"
#define base CElement
#define LOG_CONTEXT(contextTitle) core::log::Context context(_logger, contextTitle)
#ifdef SIMULATION
typedef CSimulatedBackSynchronizer BackSynchronizer;
#else
typedef CHardwareBackSynchronizer BackSynchronizer;
#endif
using std::string;
using std::list;
using std::vector;
using std::ostringstream;
using std::ofstream;
using std::ifstream;
using std::mutex;
using std::lock_guard;
using namespace core;
typedef IRemoteProcessorServerInterface *(*CreateRemoteProcessorServer)(
    uint16_t uiPort, IRemoteCommandHandler *pCommandHandler);
const CParameterMgr::SRemoteCommandParserItem CParameterMgr::gastRemoteCommandParserItems[] = {
    {"version", &amp;CParameterMgr::versionCommandProcess, 0, "", "Show version"},
    {"status", &amp;CParameterMgr::statusCommandProcess, 0, "", "Show current status"},
    {"setTuningMode", &amp;CParameterMgr::setTuningModeCommandProcess, 1, "on|off*",
     "Turn on or off Tuning Mode"},
    {"getTuningMode", &amp;CParameterMgr::getTuningModeCommandProcess, 0, "", "Show Tuning Mode"},
    {"setValueSpace", &amp;CParameterMgr::setValueSpaceCommandProcess, 1, "raw|real*",
     "Assigns Value Space used for parameter value interpretation"},
    {"getValueSpace", &amp;CParameterMgr::getValueSpaceCommandProcess, 0, "", "Show Value Space"},
    {"setOutputRawFormat", &amp;CParameterMgr::setOutputRawFormatCommandProcess, 1, "dec*|hex",
     "Assigns format used to output parameter values when in raw Value Space"},
    {"getOutputRawFormat", &amp;CParameterMgr::getOutputRawFormatCommandProcess, 0, "",
     "Show Output Raw Format"},
    {"setAutoSync", &amp;CParameterMgr::setAutoSyncCommandProcess, 1, "on*|off",
     "Turn on or off automatic synchronization to hardware while in Tuning Mode"},
    {"getAutoSync", &amp;CParameterMgr::getAutoSyncCommandProcess, 0, "", "Show Auto Sync state"},
    {"sync", &amp;CParameterMgr::syncCommandProcess, 0, "",
     "Synchronize current settings to hardware while in Tuning Mode and Auto Sync off"},
    {"listCriteria", &amp;CParameterMgr::listCriteriaCommandProcess, 0, "[CSV|XML]",
     "List selection criteria"},
    {"listDomains", &amp;CParameterMgr::listDomainsCommandProcess, 0, "", "List configurable domains"},
    {"dumpDomains", &amp;CParameterMgr::dumpDomainsCommandProcess, 0, "",
     "Show all domains and configurations, including applicability conditions"},
    {"createDomain", &amp;CParameterMgr::createDomainCommandProcess, 1, "&lt;domain&gt;",
     "Create new configurable domain"},
    {"deleteDomain", &amp;CParameterMgr::deleteDomainCommandProcess, 1, "&lt;domain&gt;",
     "Delete configurable domain"},
    {"deleteAllDomains", &amp;CParameterMgr::deleteAllDomainsCommandProcess, 0, "",
     "Delete all configurable domains"},
    {"renameDomain", &amp;CParameterMgr::renameDomainCommandProcess, 2, "&lt;domain&gt; &lt;new name&gt;",
     "Rename configurable domain"},
    {"setSequenceAwareness", &amp;CParameterMgr::setSequenceAwarenessCommandProcess, 1,
     "&lt;domain&gt; true|false*", "Set configurable domain sequence awareness"},
    {"getSequenceAwareness", &amp;CParameterMgr::getSequenceAwarenessCommandProcess, 1, "&lt;domain&gt;",
     "Get configurable domain sequence awareness"},
    {"listDomainElements", &amp;CParameterMgr::listDomainElementsCommandProcess, 1, "&lt;domain&gt;",
     "List elements associated to configurable domain"},
    {"addElement", &amp;CParameterMgr::addElementCommandProcess, 2, "&lt;domain&gt; &lt;elem path&gt;",
     "Associate element at given path to configurable domain"},
    {"removeElement", &amp;CParameterMgr::removeElementCommandProcess, 2, "&lt;domain&gt; &lt;elem path&gt;",
     "Dissociate element at given path from configurable domain"},
    {"splitDomain", &amp;CParameterMgr::splitDomainCommandProcess, 2, "&lt;domain&gt; &lt;elem path&gt;",
     "Split configurable domain at given associated element path"},
    {"listConfigurations", &amp;CParameterMgr::listConfigurationsCommandProcess, 1, "&lt;domain&gt;",
     "List domain configurations"},
    {"createConfiguration", &amp;CParameterMgr::createConfigurationCommandProcess, 2,
     "&lt;domain&gt; &lt;configuration&gt;", "Create new domain configuration"},
    {"deleteConfiguration", &amp;CParameterMgr::deleteConfigurationCommandProcess, 2,
     "&lt;domain&gt; &lt;configuration&gt;", "Delete domain configuration"},
    {"renameConfiguration", &amp;CParameterMgr::renameConfigurationCommandProcess, 3,
     "&lt;domain&gt; &lt;configuration&gt; &lt;new name&gt;", "Rename domain configuration"},
    {"saveConfiguration", &amp;CParameterMgr::saveConfigurationCommandProcess, 2,
     "&lt;domain&gt; &lt;configuration&gt;", "Save current settings into configuration"},
    {"restoreConfiguration", &amp;CParameterMgr::restoreConfigurationCommandProcess, 2,
     "&lt;domain&gt; &lt;configuration&gt;", "Restore current settings from configuration"},
    {"setElementSequence", &amp;CParameterMgr::setElementSequenceCommandProcess, 3,
     "&lt;domain&gt; &lt;configuration&gt; &lt;elem path list&gt;",
     "Set element application order for configuration"},
    {"getElementSequence", &amp;CParameterMgr::getElementSequenceCommandProcess, 2,
     "&lt;domain&gt; &lt;configuration&gt;", "Get element application order for configuration"},
    {"setRule", &amp;CParameterMgr::setRuleCommandProcess, 3, "&lt;domain&gt; &lt;configuration&gt; &lt;rule&gt;",
     "Set configuration application rule"},
    {"clearRule", &amp;CParameterMgr::clearRuleCommandProcess, 2, "&lt;domain&gt; &lt;configuration&gt;",
     "Clear configuration application rule"},
    {"getRule", &amp;CParameterMgr::getRuleCommandProcess, 2, "&lt;domain&gt; &lt;configuration&gt;",
     "Get configuration application rule"},
    {"listElements", &amp;CParameterMgr::listElementsCommandProcess, 1, "&lt;elem path&gt;|/",
     "List elements under element at given path or root"},
    {"listParameters", &amp;CParameterMgr::listParametersCommandProcess, 1, "&lt;elem path&gt;|/",
     "List parameters under element at given path or root"},
    {"getElementStructureXML", &amp;CParameterMgr::getElementStructureXMLCommandProcess, 1,
     "&lt;elem path&gt;", "Get structure of element at given path in XML format"},
    {"getElementBytes", &amp;CParameterMgr::getElementBytesCommandProcess, 1, "&lt;elem path&gt;",
     "Get settings of element at given path in Byte Array format"},
    {"setElementBytes", &amp;CParameterMgr::setElementBytesCommandProcess, 2, "&lt;elem path&gt; &lt;values&gt;",
     "Set settings of element at given path in Byte Array format"},
    {"getElementXML", &amp;CParameterMgr::getElementXMLCommandProcess, 1, "&lt;elem path&gt;",
     "Get settings of element at given path in XML format"},
    {"setElementXML", &amp;CParameterMgr::setElementXMLCommandProcess, 2, "&lt;elem path&gt; &lt;values&gt;",
     "Set settings of element at given path in XML format"},
    {"dumpElement", &amp;CParameterMgr::dumpElementCommandProcess, 1, "&lt;elem path&gt;",
     "Dump structure and content of element at given path"},
    {"getElementSize", &amp;CParameterMgr::getElementSizeCommandProcess, 1, "&lt;elem path&gt;",
     "Show size of element at given path"},
    {"showProperties", &amp;CParameterMgr::showPropertiesCommandProcess, 1, "&lt;elem path&gt;",
     "Show properties of element at given path"},
    {"getParameter", &amp;CParameterMgr::getParameterCommandProcess, 1, "&lt;param path&gt;",
     "Get value for parameter at given path"},
    {"setParameter", &amp;CParameterMgr::setParameterCommandProcess, 2, "&lt;param path&gt; &lt;value&gt;",
     "Set value for parameter at given path"},
    {"listBelongingDomains", &amp;CParameterMgr::listBelongingDomainsCommandProcess, 1, "&lt;elem path&gt;",
     "List domain(s) element at given path belongs to"},
    {"listAssociatedDomains", &amp;CParameterMgr::listAssociatedDomainsCommandProcess, 1, "&lt;elem path&gt;",
     "List domain(s) element at given path is associated to"},
    {"getConfigurationParameter", &amp;CParameterMgr::getConfigurationParameterCommandProcess, 3,
     "&lt;domain&gt; &lt;configuration&gt; &lt;param path&gt;",
     "Get value for parameter at given path from configuration"},
    {"setConfigurationParameter", &amp;CParameterMgr::setConfigurationParameterCommandProcess, 4,
     "&lt;domain&gt; &lt;configuration&gt; &lt;param path&gt; &lt;value&gt;",
     "Set value for parameter at given path to configuration"},
    {"showMapping", &amp;CParameterMgr::showMappingCommandProcess, 1, "&lt;elem path&gt;",
     "Show mapping for an element at given path"},
    {"listAssociatedElements", &amp;CParameterMgr::listAssociatedElementsCommandProcess, 0, "",
     "List element sub-trees associated to at least one configurable domain"},
    {"listConflictingElements", &amp;CParameterMgr::listConflictingElementsCommandProcess, 0, "",
     "List element sub-trees contained in more than one configurable domain"},
    {"listRogueElements", &amp;CParameterMgr::listRogueElementsCommandProcess, 0, "",
     "List element sub-trees owned by no configurable domain"},
    {"exportDomainsXML", &amp;CParameterMgr::exportDomainsXMLCommandProcess, 1, "&lt;file path&gt; ",
     "Export domains to an XML file (provide an absolute path or relative"
     "to the client's working directory)"},
    {"importDomainsXML", &amp;CParameterMgr::importDomainsXMLCommandProcess, 1, "&lt;file path&gt;",
     "Import domains from an XML file (provide an absolute path or relative"
     "to the client's working directory)"},
    {"exportDomainsWithSettingsXML", &amp;CParameterMgr::exportDomainsWithSettingsXMLCommandProcess, 1,
     "&lt;file path&gt; ",
     "Export domains including settings to XML file (provide an absolute path or relative"
     "to the client's working directory)"},
    {"exportDomainWithSettingsXML", &amp;CParameterMgr::exportDomainWithSettingsXMLCommandProcess, 2,
     "&lt;domain&gt; &lt;file path&gt; ", "Export a single given domain including settings to XML file"
                              " (provide an absolute path or relative to the client's"
                              " working directory)"},
    {"importDomainsWithSettingsXML", &amp;CParameterMgr::importDomainsWithSettingsXMLCommandProcess, 1,
     "&lt;file path&gt;",
     "Import domains including settings from XML file (provide an absolute path or relative"
     "to the client's working directory)"},
    {"importDomainWithSettingsXML", &amp;CParameterMgr::importDomainWithSettingsXMLCommandProcess, 1,
     "&lt;file path&gt; [overwrite]",
     "Import a single domain including settings from XML file."
     " Does not overwrite an existing domain unless 'overwrite' is passed as second"
     " argument. Provide an absolute path or relative to the client's working directory)"},
    {"getDomainsWithSettingsXML", &amp;CParameterMgr::getDomainsWithSettingsXMLCommandProcess, 0, "",
     "Print domains including settings as XML"},
    {"getDomainWithSettingsXML", &amp;CParameterMgr::getDomainWithSettingsXMLCommandProcess, 1,
     "&lt;domain&gt;", "Print the given domain including settings as XML"},
    {"setDomainsWithSettingsXML", &amp;CParameterMgr::setDomainsWithSettingsXMLCommandProcess, 1,
     "&lt;xml configurable domains&gt;", "Import domains including settings from XML string"},
    {"setDomainWithSettingsXML", &amp;CParameterMgr::setDomainWithSettingsXMLCommandProcess, 1,
     "&lt;xml configurable domain&gt; [overwrite]",
     "Import domains including settings from XML"
     " string. Does not overwrite an existing domain unless 'overwrite' is passed as second"
     " argument"},
    {"getSystemClassXML", &amp;CParameterMgr::getSystemClassXMLCommandProcess, 0, "",
     "Print parameter structure as XML"},
    {"getDomainsXML", &amp;CParameterMgr::getDomainsWithSettingsXMLCommandProcess, 0, "",
     "DEPRECATED COMMAND, please use getDomainsWithSettingsXML"},
};
CParameterMgr::CParameterMgr(const string &amp;strConfigurationFilePath, log::ILogger &amp;logger)
    : _pMainParameterBlackboard(new CParameterBlackboard),
      _pElementLibrarySet(new CElementLibrarySet),
      _xmlConfigurationUri(CXmlDocSource::mkUri(strConfigurationFilePath, "")), _logger(logger)
{
    addChild(new CParameterFrameworkConfiguration);
    addChild(new CSelectionCriteria);
    addChild(new CSystemClass(_logger));
    addChild(new CConfigurableDomains);
}
CParameterMgr::~CParameterMgr()
{
<a name="0"></a>    delete _pRemoteProcessorServer;
    delete _pMainParameterBlackboard;
    delete _pElementLibrarySet;
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
string CParameterMgr::getKind() const
{
    return "ParameterMgr";
}
string CParameterMgr::getVersion() const
{
    return PARAMETER_FRAMEWORK_VERSION;
}
bool CParameterMgr::load(string &amp;strError)</b></font>
{
    LOG_CONTEXT("Loading");
    feedElementLibraries();
    if (!loadFrameworkConfiguration(strError)) {
        return false;
    }
    if (!loadSubsystems(strError)) {
        return false;
    }
    if (!loadStructure(strError)) {
        return false;
    }
    if (!loadSettings(strError)) {
        return false;
    }
    if (!init(strError)) {
        return false;
    }
    {
        LOG_CONTEXT("Main blackboard back synchronization");
        BackSynchronizer(getConstSystemClass(), _pMainParameterBlackboard).sync();
    }
    CConfigurableDomains *pConfigurableDomains = getConfigurableDomains();
    pConfigurableDomains-&gt;validate(_pMainParameterBlackboard);
    {
        LOG_CONTEXT("Criterion states");
        const CSelectionCriteria *selectionCriteria = getConstSelectionCriteria();
        list&lt;string&gt; criteria;
        selectionCriteria-&gt;listSelectionCriteria(criteria, true, false);
        info() &lt;&lt; criteria;
    }
    getSystemClass()-&gt;cleanSubsystemsNeedToResync();
    doApplyConfigurations(true);
    return handleRemoteProcessingInterface(strError);
}
bool CParameterMgr::loadFrameworkConfiguration(string &amp;strError)
{
    LOG_CONTEXT("Loading framework configuration");
    CXmlElementSerializingContext elementSerializingContext(strError);
    _xmlDoc *doc =
        CXmlDocSource::mkXmlDoc(_xmlConfigurationUri, true, true, elementSerializingContext);
    if (doc == nullptr) {
        return false;
    }
    if (!xmlParse(elementSerializingContext, getFrameworkConfiguration(), doc, _xmlConfigurationUri,
                  EFrameworkConfigurationLibrary)) {
        return false;
    }
    getSystemClass()-&gt;setName(getConstFrameworkConfiguration()-&gt;getSystemClassName());
    getConfigurableDomains()-&gt;setName(getConstFrameworkConfiguration()-&gt;getSystemClassName());
    _pSubsystemPlugins = static_cast&lt;const CSubsystemPlugins *&gt;(
        getConstFrameworkConfiguration()-&gt;findChild("SubsystemPlugins"));
    if (!_pSubsystemPlugins) {
        strError = "Parameter Framework Configuration: couldn't find SubsystemPlugins element";
        return false;
    }
    info() &lt;&lt; "Tuning "
           &lt;&lt; (getConstFrameworkConfiguration()-&gt;isTuningAllowed() ? "allowed" : "prohibited");
    return true;
}
bool CParameterMgr::loadSubsystems(std::string &amp;error)
{
    LOG_CONTEXT("Loading subsystem plugins");
    bool isSuccess =
        getSystemClass()-&gt;loadSubsystems(error, _pSubsystemPlugins, !_bFailOnMissingSubsystem);
    if (isSuccess) {
        info() &lt;&lt; "All subsystem plugins successfully loaded";
        if (!error.empty()) {
            info() &lt;&lt; error;
        }
    } else {
        warning() &lt;&lt; error;
    }
    return isSuccess;
}
bool CParameterMgr::loadStructure(string &amp;strError)
{
    CSystemClass *pSystemClass = getSystemClass();
    LOG_CONTEXT("Loading " + pSystemClass-&gt;getName() + " system class structure");
    const CFrameworkConfigurationLocation *pStructureDescriptionFileLocation =
        static_cast&lt;const CFrameworkConfigurationLocation *&gt;(
            getConstFrameworkConfiguration()-&gt;findChildOfKind("StructureDescriptionFileLocation"));
    if (!pStructureDescriptionFileLocation) {
        strError = "No StructureDescriptionFileLocation element found for SystemClass " +
                   pSystemClass-&gt;getName();
        return false;
    }
    CParameterAccessContext accessContext(strError);
    CXmlParameterSerializingContext parameterBuildContext(accessContext, strError);
    {
        string structureUri =
            CXmlDocSource::mkUri(_xmlConfigurationUri, pStructureDescriptionFileLocation-&gt;getUri());
        LOG_CONTEXT("Importing system structure from file " + structureUri);
        _xmlDoc *doc = CXmlDocSource::mkXmlDoc(structureUri, true, true, parameterBuildContext);
        if (doc == nullptr) {
            return false;
        }
        if (!xmlParse(parameterBuildContext, pSystemClass, doc, structureUri,
                      EParameterCreationLibrary)) {
            return false;
        }
    }
    pSystemClass-&gt;setOffset(0);
    _pMainParameterBlackboard-&gt;setSize(pSystemClass-&gt;getFootPrint());
    return true;
}
bool CParameterMgr::loadSettings(string &amp;strError)
{
    string strLoadError;
    bool success = loadSettingsFromConfigFile(strLoadError);
    if (!success &amp;&amp; !_bFailOnFailedSettingsLoad) {
        warning() &lt;&lt; strLoadError;
        warning() &lt;&lt; "Failed to load settings, continue without domains.";
        success = true;
    }
    if (!success) {
        strError = strLoadError;
        return false;
    }
    return true;
}
bool CParameterMgr::loadSettingsFromConfigFile(string &amp;strError)
{
    LOG_CONTEXT("Loading settings");
    const CFrameworkConfigurationGroup *pParameterConfigurationGroup =
        static_cast&lt;const CFrameworkConfigurationGroup *&gt;(
            getConstFrameworkConfiguration()-&gt;findChildOfKind("SettingsConfiguration"));
    if (!pParameterConfigurationGroup) {
        return true;
    }
    const CFrameworkConfigurationLocation *pConfigurableDomainsFileLocation =
        static_cast&lt;const CFrameworkConfigurationLocation *&gt;(
            pParameterConfigurationGroup-&gt;findChildOfKind("ConfigurableDomainsFileLocation"));
    if (!pConfigurableDomainsFileLocation) {
        strError = "No ConfigurableDomainsFileLocation element found for SystemClass " +
                   getSystemClass()-&gt;getName();
        return false;
    }
    CConfigurableDomains *pConfigurableDomains = getConfigurableDomains();
    string configurationDomainsUri =
        CXmlDocSource::mkUri(_xmlConfigurationUri, pConfigurableDomainsFileLocation-&gt;getUri());
    CXmlDomainImportContext xmlDomainImportContext(strError, true, *getSystemClass());
    xmlDomainImportContext.setSelectionCriteriaDefinition(
        getConstSelectionCriteria()-&gt;getSelectionCriteriaDefinition());
    xmlDomainImportContext.setAutoValidationRequired(true);
    info() &lt;&lt; "Importing configurable domains from file " &lt;&lt; configurationDomainsUri
           &lt;&lt; " with settings";
    _xmlDoc *doc =
        CXmlDocSource::mkXmlDoc(configurationDomainsUri, true, true, xmlDomainImportContext);
    if (doc == nullptr) {
        return false;
    }
    return xmlParse(xmlDomainImportContext, pConfigurableDomains, doc, _xmlConfigurationUri,
                    EParameterConfigurationLibrary, true, "SystemClassName");
}
bool CParameterMgr::xmlParse(CXmlElementSerializingContext &amp;elementSerializingContext,
                             CElement *pRootElement, _xmlDoc *doc, const string &amp;baseUri,
                             CParameterMgr::ElementLibrary eElementLibrary, bool replace,
                             const string &amp;strNameAttributeName)
{
    elementSerializingContext.set(_pElementLibrarySet-&gt;getElementLibrary(eElementLibrary), baseUri);
    CXmlDocSource docSource(doc, _bValidateSchemasOnStart, pRootElement-&gt;getXmlElementName(),
                            pRootElement-&gt;getName(), strNameAttributeName);
    docSource.setSchemaBaseUri(getSchemaUri());
    auto clean = [replace, &amp;pRootElement] {
        if (replace) {
            pRootElement-&gt;clean();
        }
    };
    clean();
    CXmlMemoryDocSink memorySink(pRootElement);
    if (!memorySink.process(docSource, elementSerializingContext)) {
        clean();
        return false;
    }
    return true;
}
bool CParameterMgr::init(string &amp;strError)
{
    return base::init(strError);
}
CSelectionCriterionType *CParameterMgr::createSelectionCriterionType(bool bIsInclusive)
{
    return getSelectionCriteria()-&gt;createSelectionCriterionType(bIsInclusive);
}
CSelectionCriterion *CParameterMgr::createSelectionCriterion(
    const string &amp;strName, const CSelectionCriterionType *pSelectionCriterionType)
{
    return getSelectionCriteria()-&gt;createSelectionCriterion(strName, pSelectionCriterionType,
                                                            _logger);
}
CSelectionCriterion *CParameterMgr::getSelectionCriterion(const string &amp;strName)
{
    return getSelectionCriteria()-&gt;getSelectionCriterion(strName);
}
void CParameterMgr::applyConfigurations()
{
    LOG_CONTEXT("Configuration application request");
    lock_guard&lt;mutex&gt; autoLock(getBlackboardMutex());
    if (!_bTuningModeIsOn) {
        doApplyConfigurations(false);
    } else {
        warning() &lt;&lt; "Configurations were not applied because the TuningMode is on";
    }
}
const CConfigurableElement *CParameterMgr::getConfigurableElement(const string &amp;strPath,
                                                                  string &amp;strError) const
{
    CPathNavigator pathNavigator(strPath);
    if (!pathNavigator.navigateThrough(getConstSystemClass()-&gt;getName(), strError)) {
        return nullptr;
    }
    const CElement *pElement = getConstSystemClass()-&gt;findDescendant(pathNavigator);
    if (!pElement) {
        strError = "Path not found: " + strPath;
        return nullptr;
    }
    const CConfigurableElement *pConfigurableElement =
        static_cast&lt;const CConfigurableElement *&gt;(pElement);
    return pConfigurableElement;
}
CConfigurableElement *CParameterMgr::getConfigurableElement(const string &amp;strPath, string &amp;strError)
{
    const auto *constThis = this;
    return const_cast&lt;CConfigurableElement *&gt;(constThis-&gt;getConfigurableElement(strPath, strError));
}
CParameterHandle *CParameterMgr::createParameterHandle(const string &amp;strPath, string &amp;strError)
{
    CConfigurableElement *pConfigurableElement = getConfigurableElement(strPath, strError);
    if (!pConfigurableElement) {
        strError = "Element not found: " + strPath;
        return nullptr;
    }
    if (!pConfigurableElement-&gt;isParameter()) {
        strError = "Not a parameter: " + strPath;
        return nullptr;
    }
    return new CParameterHandle(static_cast&lt;CBaseParameter &amp;&gt;(*pConfigurableElement), *this);
}
ElementHandle *CParameterMgr::createElementHandle(const std::string &amp;path, std::string &amp;error)
{
    CConfigurableElement *pConfigurableElement;
    if (path == "/") {
        pConfigurableElement = getSystemClass();
    } else {
        pConfigurableElement = getConfigurableElement(path, error);
    }
    if (!pConfigurableElement) {
        error = "Element not found: " + path;
        return nullptr;
    }
    return new ElementHandle(*pConfigurableElement, *this);
}
void CParameterMgr::getSettingsAsBytes(const CConfigurableElement &amp;element,
                                       std::vector&lt;uint8_t&gt; &amp;settings) const
{
    std::string error;
    CParameterAccessContext parameterAccessContext(error);
    parameterAccessContext.setParameterBlackboard(_pMainParameterBlackboard);
    element.getSettingsAsBytes(settings, parameterAccessContext);
}
bool CParameterMgr::setSettingsAsBytes(const CConfigurableElement &amp;element,
                                       const std::vector&lt;uint8_t&gt; &amp;settings, std::string &amp;error)
{
    CParameterAccessContext parameterAccessContext(error);
    parameterAccessContext.setParameterBlackboard(_pMainParameterBlackboard);
    parameterAccessContext.setAutoSync(autoSyncOn());
    return element.setSettingsAsBytes(settings, parameterAccessContext);
}
void CParameterMgr::setFailureOnMissingSubsystem(bool bFail)
{
    _bFailOnMissingSubsystem = bFail;
}
bool CParameterMgr::getFailureOnMissingSubsystem() const
{
    return _bFailOnMissingSubsystem;
}
void CParameterMgr::setFailureOnFailedSettingsLoad(bool bFail)
{
    _bFailOnFailedSettingsLoad = bFail;
}
bool CParameterMgr::getFailureOnFailedSettingsLoad() const
{
    return _bFailOnFailedSettingsLoad;
}
const string &amp;CParameterMgr::getSchemaUri() const
{
    return _schemaUri;
}
void CParameterMgr::setSchemaUri(const string &amp;schemaUri)
{
    _schemaUri = schemaUri;
}
void CParameterMgr::setValidateSchemasOnStart(bool bValidate)
{
    _bValidateSchemasOnStart = bValidate;
}
bool CParameterMgr::getValidateSchemasOnStart() const
{
    return _bValidateSchemasOnStart;
}
CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::versionCommandProcess(
{
    strResult = getVersion();
    return CCommandHandler::ESucceeded;
}
CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::statusCommandProcess(
{
    const CSystemClass *pSystemClass = getSystemClass();
    utility::appendTitle(strResult, "General:");
    strResult += "System Class: ";
    strResult += pSystemClass-&gt;getName();
    strResult += "\n";
    strResult += "Tuning Mode: ";
    strResult += tuningModeOn() ? "on" : "off";
    strResult += "\n";
    strResult += "Value Space: ";
    strResult += valueSpaceIsRaw() ? "raw" : "real";
    strResult += "\n";
    strResult += "Output Raw Format: ";
    strResult += outputRawFormatIsHex() ? "hex" : "dec";
    strResult += "\n";
    strResult += "Auto Sync: ";
    strResult += autoSyncOn() ? "on" : "off";
    strResult += "\n";
    utility::appendTitle(strResult, "Subsystems:");
    string strSubsystemList;
    pSystemClass-&gt;listChildrenPaths(strSubsystemList);
    strResult += strSubsystemList;
    utility::appendTitle(strResult, "Last Applied [Pending] Configurations:");
    string strLastAppliedConfigurations;
    getConfigurableDomains()-&gt;listLastAppliedConfigurations(strLastAppliedConfigurations);
    strResult += strLastAppliedConfigurations;
    utility::appendTitle(strResult, "Selection Criteria:");
    list&lt;string&gt; lstrSelectionCriteria;
    getSelectionCriteria()-&gt;listSelectionCriteria(lstrSelectionCriteria, false, true);
    strResult += utility::asString(lstrSelectionCriteria);
    return CCommandHandler::ESucceeded;
}
CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::setTuningModeCommandProcess(
    const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    if (remoteCommand.getArgument(0) == "on") {
        if (setTuningMode(true, strResult)) {
            return CCommandHandler::EDone;
        }
    } else if (remoteCommand.getArgument(0) == "off") {
        if (setTuningMode(false, strResult)) {
            return CCommandHandler::EDone;
        }
    } else {
        return CCommandHandler::EShowUsage;
    }
    return CCommandHandler::EFailed;
}
CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::getTuningModeCommandProcess(
{
    strResult = tuningModeOn() ? "on" : "off";
    return CCommandHandler::ESucceeded;
}
CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::setValueSpaceCommandProcess(
{
    if (remoteCommand.getArgument(0) == "raw") {
        setValueSpace(true);
        return CCommandHandler::EDone;
    } else if (remoteCommand.getArgument(0) == "real") {
        setValueSpace(false);
        return CCommandHandler::EDone;
    } else {
        return CCommandHandler::EShowUsage;
    }
    return CCommandHandler::EFailed;
}
CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::getValueSpaceCommandProcess(
{
    strResult = valueSpaceIsRaw() ? "raw" : "real";
    return CCommandHandler::ESucceeded;
}
CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::setOutputRawFormatCommandProcess(
{
    if (remoteCommand.getArgument(0) == "hex") {
        setOutputRawFormat(true);
        return CCommandHandler::EDone;
    } else if (remoteCommand.getArgument(0) == "dec") {
        setOutputRawFormat(false);
        return CCommandHandler::EDone;
    } else {
        return CCommandHandler::EShowUsage;
    }
    return CCommandHandler::EFailed;
}
CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::getOutputRawFormatCommandProcess(
{
    strResult = outputRawFormatIsHex() ? "hex" : "dec";
    return CCommandHandler::ESucceeded;
}
CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::setAutoSyncCommandProcess(
    const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    if (remoteCommand.getArgument(0) == "on") {
        if (setAutoSync(true, strResult)) {
            return CCommandHandler::EDone;
        }
    } else if (remoteCommand.getArgument(0) == "off") {
        if (setAutoSync(false, strResult)) {
            return CCommandHandler::EDone;
        }
    } else {
        return CCommandHandler::EShowUsage;
    }
    return CCommandHandler::EFailed;
}
CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::getAutoSyncCommandProcess(
{
    strResult = autoSyncOn() ? "on" : "off";
    return CCommandHandler::ESucceeded;
}
CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::syncCommandProcess(
    const IRemoteCommand &amp;, string &amp;strResult)
{
    return sync(strResult) ? CCommandHandler::EDone : CCommandHandler::EFailed;
}
CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::listCriteriaCommandProcess(
    const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    if (remoteCommand.getArgumentCount() &gt; 1) {
        return CCommandHandler::EShowUsage;
    }
    string strOutputFormat;
    if (remoteCommand.getArgumentCount() == 1) {
        strOutputFormat = remoteCommand.getArgument(0);
        std::transform(strOutputFormat.begin(), strOutputFormat.end(), strOutputFormat.begin(),
                       ::toupper);
        if (strOutputFormat != "XML" &amp;&amp; strOutputFormat != "CSV") {
            return CCommandHandler::EShowUsage;
        }
    }
    if (strOutputFormat == "XML") {
        const CSelectionCriteriaDefinition *pSelectionCriteriaDefinition =
            getConstSelectionCriteria()-&gt;getSelectionCriteriaDefinition();
        if (!exportElementToXMLString(pSelectionCriteriaDefinition, "SelectionCriteria",
                                      CXmlSerializingContext{strResult}, strResult)) {
            return CCommandHandler::EFailed;
        }
        return CCommandHandler::ESucceeded;
    } else {
        bool bHumanReadable = strOutputFormat.empty();
        list&lt;string&gt; lstrResult;
        getSelectionCriteria()-&gt;listSelectionCriteria(lstrResult, true, bHumanReadable);
        strResult += utility::asString(lstrResult);
        return CCommandHandler::ESucceeded;
    }
}
CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::listDomainsCommandProcess(
{
    getConfigurableDomains()-&gt;listDomains(strResult);
    return CCommandHandler::ESucceeded;
}
CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::createDomainCommandProcess(
    const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    return createDomain(remoteCommand.getArgument(0), strResult) ? CCommandHandler::EDone
                                                                 : CCommandHandler::EFailed;
}
CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::deleteDomainCommandProcess(
    const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    return deleteDomain(remoteCommand.getArgument(0), strResult) ? CCommandHandler::EDone
                                                                 : CCommandHandler::EFailed;
}
CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::deleteAllDomainsCommandProcess(
{
    return deleteAllDomains(strResult) ? CCommandHandler::EDone : CCommandHandler::EFailed;
}
CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::renameDomainCommandProcess(
    const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    return renameDomain(remoteCommand.getArgument(0), remoteCommand.getArgument(1), strResult)
               ? CCommandHandler::EDone
               : CCommandHandler::EFailed;
}
CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::setSequenceAwarenessCommandProcess(
    const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    bool bSequenceAware;
    if (remoteCommand.getArgument(1) == "true") {
        bSequenceAware = true;
    } else if (remoteCommand.getArgument(1) == "false") {
        bSequenceAware = false;
    } else {
        return CCommandHandler::EShowUsage;
    }
    return setSequenceAwareness(remoteCommand.getArgument(0), bSequenceAware, strResult)
               ? CCommandHandler::EDone
               : CCommandHandler::EFailed;
}
CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::getSequenceAwarenessCommandProcess(
    const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    bool bSequenceAware;
    if (!getSequenceAwareness(remoteCommand.getArgument(0), bSequenceAware, strResult)) {
        return CCommandHandler::EFailed;
    }
    strResult = bSequenceAware ? "true" : "false";
    return CCommandHandler::ESucceeded;
}
CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::listDomainElementsCommandProcess(
    const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    return getConfigurableDomains()-&gt;listDomainElements(remoteCommand.getArgument(0), strResult)
               ? CCommandHandler::ESucceeded
               : CCommandHandler::EFailed;
}
CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::addElementCommandProcess(
    const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    return addConfigurableElementToDomain(remoteCommand.getArgument(0),
                                          remoteCommand.getArgument(1), strResult)
               ? CCommandHandler::EDone
               : CCommandHandler::EFailed;
}
CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::removeElementCommandProcess(
    const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    return removeConfigurableElementFromDomain(remoteCommand.getArgument(0),
                                               remoteCommand.getArgument(1), strResult)
               ? CCommandHandler::EDone
               : CCommandHandler::EFailed;
}
CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::splitDomainCommandProcess(
    const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    return split(remoteCommand.getArgument(0), remoteCommand.getArgument(1), strResult)
               ? CCommandHandler::EDone
               : CCommandHandler::EFailed;
}
CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::listConfigurationsCommandProcess(
    const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    return getConstConfigurableDomains()-&gt;listConfigurations(remoteCommand.getArgument(0),
                                                             strResult)
               ? CCommandHandler::ESucceeded
               : CCommandHandler::EFailed;
}
CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::dumpDomainsCommandProcess(
{
    string strError;
    utility::ErrorContext errorContext(strError);
    strResult = getConstConfigurableDomains()-&gt;dumpContent(errorContext);
    return CCommandHandler::ESucceeded;
}
CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::createConfigurationCommandProcess(
    const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    return createConfiguration(remoteCommand.getArgument(0), remoteCommand.getArgument(1),
                               strResult)
               ? CCommandHandler::EDone
               : CCommandHandler::EFailed;
}
CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::deleteConfigurationCommandProcess(
    const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    return deleteConfiguration(remoteCommand.getArgument(0), remoteCommand.getArgument(1),
                               strResult)
               ? CCommandHandler::EDone
               : CCommandHandler::EFailed;
}
CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::renameConfigurationCommandProcess(
    const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    return renameConfiguration(remoteCommand.getArgument(0), remoteCommand.getArgument(1),
                               remoteCommand.getArgument(2), strResult)
               ? CCommandHandler::EDone
               : CCommandHandler::EFailed;
}
CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::saveConfigurationCommandProcess(
    const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    return saveConfiguration(remoteCommand.getArgument(0), remoteCommand.getArgument(1), strResult)
               ? CCommandHandler::EDone
               : CCommandHandler::EFailed;
}
CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::restoreConfigurationCommandProcess(
    const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    core::Results result;
    if (!restoreConfiguration(remoteCommand.getArgument(0), remoteCommand.getArgument(1), result)) {
        strResult = utility::asString(result);
        return CCommandHandler::EFailed;
    }
    return CCommandHandler::EDone;
}
CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::setElementSequenceCommandProcess(
    const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    std::vector&lt;string&gt; astrNewElementSequence;
    for (size_t argument = 2; argument &lt; remoteCommand.getArgumentCount(); argument++) {
        astrNewElementSequence.push_back(remoteCommand.getArgument(argument));
    }
    return setElementSequence(remoteCommand.getArgument(0), remoteCommand.getArgument(1),
                              astrNewElementSequence, strResult)
               ? CCommandHandler::EDone
               : CCommandHandler::EFailed;
}
CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::getElementSequenceCommandProcess(
    const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    return getConfigurableDomains()-&gt;getElementSequence(remoteCommand.getArgument(0),
                                                        remoteCommand.getArgument(1), strResult)
               ? CCommandHandler::ESucceeded
               : CCommandHandler::EFailed;
}
CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::setRuleCommandProcess(
    const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    return setApplicationRule(remoteCommand.getArgument(0), remoteCommand.getArgument(1),
                              remoteCommand.packArguments(2, remoteCommand.getArgumentCount() - 2),
                              strResult)
               ? CCommandHandler::EDone
               : CCommandHandler::EFailed;
}
CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::clearRuleCommandProcess(
    const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    return clearApplicationRule(remoteCommand.getArgument(0), remoteCommand.getArgument(1),
                                strResult)
               ? CCommandHandler::EDone
               : CCommandHandler::EFailed;
}
CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::getRuleCommandProcess(
    const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    return getApplicationRule(remoteCommand.getArgument(0), remoteCommand.getArgument(1), strResult)
               ? CCommandHandler::ESucceeded
               : CCommandHandler::EFailed;
}
CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::listElementsCommandProcess(
    const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    CElementLocator elementLocator(getSystemClass(), false);
    CElement *pLocatedElement = nullptr;
    if (!elementLocator.locate(remoteCommand.getArgument(0), &amp;pLocatedElement, strResult)) {
        return CCommandHandler::EFailed;
    }
    if (!pLocatedElement) {
        pLocatedElement = getSystemClass();
    }
    strResult += pLocatedElement-&gt;listQualifiedPaths(false);
    return CCommandHandler::ESucceeded;
}
CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::listParametersCommandProcess(
    const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    CElementLocator elementLocator(getSystemClass(), false);
    CElement *pLocatedElement = nullptr;
    if (!elementLocator.locate(remoteCommand.getArgument(0), &amp;pLocatedElement, strResult)) {
        return CCommandHandler::EFailed;
    }
    if (!pLocatedElement) {
        pLocatedElement = getSystemClass();
    }
    strResult += pLocatedElement-&gt;listQualifiedPaths(true);
    return CCommandHandler::ESucceeded;
}
CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::getElementStructureXMLCommandProcess(
    const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    CElementLocator elementLocator(getSystemClass());
    CElement *pLocatedElement = nullptr;
    if (!elementLocator.locate(remoteCommand.getArgument(0), &amp;pLocatedElement, strResult)) {
        return CCommandHandler::EFailed;
    }
    CParameterAccessContext accessContext(strResult);
    if (!exportElementToXMLString(pLocatedElement, pLocatedElement-&gt;getXmlElementName(),
                                  CXmlParameterSerializingContext{accessContext, strResult},
                                  strResult)) {
        return CCommandHandler::EFailed;
    }
    return CCommandHandler::ESucceeded;
}
CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::getElementBytesCommandProcess(
    const IRemoteCommand &amp;remoteCommand, std::string &amp;strResult)
{
    CElementLocator elementLocator(getSystemClass());
    CElement *pLocatedElement = nullptr;
    if (!elementLocator.locate(remoteCommand.getArgument(0), &amp;pLocatedElement, strResult)) {
        return CCommandHandler::EFailed;
    }
    const CConfigurableElement *pConfigurableElement =
        static_cast&lt;CConfigurableElement *&gt;(pLocatedElement);
    vector&lt;uint8_t&gt; bytes;
    getSettingsAsBytes(*pConfigurableElement, bytes);
    std::ostringstream ostream;
    ostream &lt;&lt; std::hex &lt;&lt; std::setfill('0');
    for (auto byte : bytes) {
        ostream &lt;&lt; "0x" &lt;&lt; std::setw(2) &lt;&lt; int{byte} &lt;&lt; " ";
    }
    strResult = ostream.str();
    if (not strResult.empty()) {
        strResult.pop_back();
    }
    return CCommandHandler::ESucceeded;
}
CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::setElementBytesCommandProcess(
    const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    if (!checkTuningModeOn(strResult)) {
        return CCommandHandler::EFailed;
    }
    CElementLocator elementLocator(getSystemClass());
    CElement *pLocatedElement = nullptr;
    if (!elementLocator.locate(remoteCommand.getArgument(0), &amp;pLocatedElement, strResult)) {
        return CCommandHandler::EFailed;
    }
    const CConfigurableElement *pConfigurableElement =
        static_cast&lt;CConfigurableElement *&gt;(pLocatedElement);
    vector&lt;uint8_t&gt; bytes;
    auto first = remoteCommand.getArguments().cbegin() + 1;
    auto last = remoteCommand.getArguments().cend();
    try {
        std::transform(first, last, begin(bytes), [](decltype(*first) input) {
            uint8_t byte;
            if (!convertTo(input, byte)) {
                throw std::domain_error("Some values out of byte range");
            }
            return byte;
        });
    } catch (const std::domain_error &amp;e) {
        strResult = e.what();
        return CCommandHandler::EFailed;
    }
    if (!setSettingsAsBytes(*pConfigurableElement, bytes, strResult)) {
        return CCommandHandler::EFailed;
    }
    return CCommandHandler::EDone;
}
bool CParameterMgr::getSettingsAsXML(const CConfigurableElement *configurableElement,
                                     string &amp;result) const
{
    string error;
    CConfigurationAccessContext configContext(error, _pMainParameterBlackboard, _bValueSpaceIsRaw,
                                              _bOutputRawFormatIsHex, true);
    CXmlParameterSerializingContext xmlParameterContext(configContext, error);
    CXmlMemoryDocSource memorySource(configurableElement, false,
                                     configurableElement-&gt;getXmlElementName());
    ostringstream output;
    CXmlStreamDocSink streamSink(output);
    if (not streamSink.process(memorySource, xmlParameterContext)) {
        result = error;
        return false;
    }
    result = output.str();
    return true;
}
bool CParameterMgr::setSettingsAsXML(CConfigurableElement *configurableElement,
                                     const string &amp;settings, string &amp;error)
{
    CConfigurationAccessContext configContext(error, _pMainParameterBlackboard, _bValueSpaceIsRaw,
                                              _bOutputRawFormatIsHex, false);
    CXmlParameterSerializingContext xmlParameterContext(configContext, error);
    _xmlDoc *doc = CXmlDocSource::mkXmlDoc(settings, false, false, xmlParameterContext);
    if (doc == nullptr) {
        return false;
    }
    if (not xmlParse(xmlParameterContext, configurableElement, doc, "",
                     EParameterConfigurationLibrary, false)) {
        return false;
    }
    if (_bAutoSyncOn) {
        CSyncerSet syncerSet;
        static_cast&lt;CConfigurableElement *&gt;(configurableElement)-&gt;fillSyncerSet(syncerSet);
        core::Results errors;
        if (not syncerSet.sync(*_pMainParameterBlackboard, false, &amp;errors)) {
            error = utility::asString(errors);
            return false;
        }
    }
    return true;
}
CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::getElementXMLCommandProcess(
    const IRemoteCommand &amp;remoteCommand, string &amp;result)
{
    CElementLocator elementLocator(getSystemClass());
    CElement *locatedElement = nullptr;
    if (not elementLocator.locate(remoteCommand.getArgument(0), &amp;locatedElement, result)) {
        return CCommandHandler::EFailed;
    }
    if (not getSettingsAsXML(static_cast&lt;CConfigurableElement *&gt;(locatedElement), result)) {
        return CCommandHandler::EFailed;
    }
    return CCommandHandler::ESucceeded;
}
CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::setElementXMLCommandProcess(
    const IRemoteCommand &amp;remoteCommand, string &amp;result)
{
    if (!checkTuningModeOn(result)) {
        return CCommandHandler::EFailed;
    }
    CElementLocator elementLocator(getSystemClass());
    CElement *locatedElement = nullptr;
    if (not elementLocator.locate(remoteCommand.getArgument(0), &amp;locatedElement, result)) {
        return CCommandHandler::EFailed;
    }
    if (not setSettingsAsXML(static_cast&lt;CConfigurableElement *&gt;(locatedElement),
                             remoteCommand.getArgument(1), result)) {
        return CCommandHandler::EFailed;
    }
    return CCommandHandler::EDone;
}
CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::dumpElementCommandProcess(
    const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    CElementLocator elementLocator(getSystemClass());
    CElement *pLocatedElement = nullptr;
    if (!elementLocator.locate(remoteCommand.getArgument(0), &amp;pLocatedElement, strResult)) {
        return CCommandHandler::EFailed;
    }
    string strError;
    CParameterAccessContext parameterAccessContext(strError, _pMainParameterBlackboard,
                                                   _bValueSpaceIsRaw, _bOutputRawFormatIsHex);
    strResult = pLocatedElement-&gt;dumpContent(parameterAccessContext);
    return CCommandHandler::ESucceeded;
}
CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::getElementSizeCommandProcess(
    const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    CElementLocator elementLocator(getSystemClass());
    CElement *pLocatedElement = nullptr;
    if (!elementLocator.locate(remoteCommand.getArgument(0), &amp;pLocatedElement, strResult)) {
        return CCommandHandler::EFailed;
    }
    const CConfigurableElement *pConfigurableElement =
        static_cast&lt;const CConfigurableElement *&gt;(pLocatedElement);
    strResult = pConfigurableElement-&gt;getFootprintAsString();
    return CCommandHandler::ESucceeded;
}
CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::showPropertiesCommandProcess(
    const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    CElementLocator elementLocator(getSystemClass());
    CElement *pLocatedElement = nullptr;
    if (!elementLocator.locate(remoteCommand.getArgument(0), &amp;pLocatedElement, strResult)) {
        return CCommandHandler::EFailed;
    }
    const CConfigurableElement *pConfigurableElement =
        static_cast&lt;const CConfigurableElement *&gt;(pLocatedElement);
    pConfigurableElement-&gt;showProperties(strResult);
    return CCommandHandler::ESucceeded;
}
CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::getParameterCommandProcess(
    const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    string strValue;
    if (!accessParameterValue(remoteCommand.getArgument(0), strValue, false, strResult)) {
        return CCommandHandler::EFailed;
    }
    strResult = strValue;
    return CCommandHandler::ESucceeded;
}
CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::setParameterCommandProcess(
    const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    string strValue = remoteCommand.packArguments(1, remoteCommand.getArgumentCount() - 1);
    return accessParameterValue(remoteCommand.getArgument(0), strValue, true, strResult)
               ? CCommandHandler::EDone
               : CCommandHandler::EFailed;
}
CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::listBelongingDomainsCommandProcess(
    const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    CElementLocator elementLocator(getSystemClass());
    CElement *pLocatedElement = nullptr;
    if (!elementLocator.locate(remoteCommand.getArgument(0), &amp;pLocatedElement, strResult)) {
        return CCommandHandler::EFailed;
    }
    const CConfigurableElement *pConfigurableElement =
        static_cast&lt;const CConfigurableElement *&gt;(pLocatedElement);
    pConfigurableElement-&gt;listBelongingDomains(strResult);
    return CCommandHandler::ESucceeded;
}
CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::listAssociatedDomainsCommandProcess(
    const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    CElementLocator elementLocator(getSystemClass());
    CElement *pLocatedElement = nullptr;
    if (!elementLocator.locate(remoteCommand.getArgument(0), &amp;pLocatedElement, strResult)) {
        return CCommandHandler::EFailed;
    }
    const CConfigurableElement *pConfigurableElement =
        static_cast&lt;const CConfigurableElement *&gt;(pLocatedElement);
    pConfigurableElement-&gt;listAssociatedDomains(strResult);
    return CCommandHandler::ESucceeded;
}
CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::listAssociatedElementsCommandProcess(
{
    getConfigurableDomains()-&gt;listAssociatedElements(strResult);
    return CCommandHandler::ESucceeded;
}
CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::listConflictingElementsCommandProcess(
{
    getConfigurableDomains()-&gt;listConflictingElements(strResult);
    return CCommandHandler::ESucceeded;
}
CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::listRogueElementsCommandProcess(
{
    getSystemClass()-&gt;listRogueElements(strResult);
    return CCommandHandler::ESucceeded;
}
CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::
    getConfigurationParameterCommandProcess(const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    string strOutputValue;
    string strError;
    if (!accessConfigurationValue(remoteCommand.getArgument(0), remoteCommand.getArgument(1),
                                  remoteCommand.getArgument(2), strOutputValue, false, strError)) {
        strResult = strError;
        return CCommandHandler::EFailed;
    }
    strResult = strOutputValue;
    return CCommandHandler::ESucceeded;
}
CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::
    setConfigurationParameterCommandProcess(const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    string strValue = remoteCommand.packArguments(3, remoteCommand.getArgumentCount() - 3);
    bool bSuccess =
        accessConfigurationValue(remoteCommand.getArgument(0), remoteCommand.getArgument(1),
                                 remoteCommand.getArgument(2), strValue, true, strResult);
    return bSuccess ? CCommandHandler::EDone : CCommandHandler::EFailed;
}
CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::showMappingCommandProcess(
    const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    if (!getParameterMapping(remoteCommand.getArgument(0), strResult)) {
        return CCommandHandler::EFailed;
    }
    return CCommandHandler::ESucceeded;
}
CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::exportDomainsXMLCommandProcess(
    const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    string strFileName = remoteCommand.getArgument(0);
    return exportDomainsXml(strFileName, false, true, strResult) ? CCommandHandler::EDone
                                                                 : CCommandHandler::EFailed;
}
CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::importDomainsXMLCommandProcess(
    const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    return importDomainsXml(remoteCommand.getArgument(0), false, true, strResult)
               ? CCommandHandler::EDone
               : CCommandHandler::EFailed;
}
CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::
    exportDomainsWithSettingsXMLCommandProcess(const IRemoteCommand &amp;remoteCommand,
                                               string &amp;strResult)
{
    string strFileName = remoteCommand.getArgument(0);
    return exportDomainsXml(strFileName, true, true, strResult) ? CCommandHandler::EDone
                                                                : CCommandHandler::EFailed;
}
CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::
    exportDomainWithSettingsXMLCommandProcess(const IRemoteCommand &amp;remoteCommand, string &amp;result)
{
    string domainName = remoteCommand.getArgument(0);
    string fileName = remoteCommand.getArgument(1);
    return exportSingleDomainXml(fileName, domainName, true, true, result)
               ? CCommandHandler::EDone
               : CCommandHandler::EFailed;
}
CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::
    importDomainsWithSettingsXMLCommandProcess(const IRemoteCommand &amp;remoteCommand,
                                               string &amp;strResult)
{
    return importDomainsXml(remoteCommand.getArgument(0), true, true, strResult)
               ? CCommandHandler::EDone
               : CCommandHandler::EFailed;
}
CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::
    importDomainWithSettingsXMLCommandProcess(const IRemoteCommand &amp;remoteCommand,
                                              string &amp;strResult)
{
    bool bOverwrite = false;
    if (remoteCommand.getArgumentCount() &gt; 1) {
        if (remoteCommand.getArgument(1) == "overwrite") {
            bOverwrite = true;
        } else {
            return CCommandHandler::EShowUsage;
        }
    }
    return importSingleDomainXml(remoteCommand.getArgument(0), bOverwrite, true, true, strResult)
               ? CCommandHandler::EDone
               : CCommandHandler::EFailed;
}
CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::
{
    if (!exportDomainsXml(strResult, true, false, strResult)) {
        return CCommandHandler::EFailed;
    }
    return CCommandHandler::ESucceeded;
}
CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::getDomainWithSettingsXMLCommandProcess(
    const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    string strDomainName = remoteCommand.getArgument(0);
    return exportSingleDomainXml(strResult, strDomainName, true, false, strResult)
               ? CCommandHandler::ESucceeded
               : CCommandHandler::EFailed;
}
CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::
    setDomainsWithSettingsXMLCommandProcess(const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    return importDomainsXml(remoteCommand.getArgument(0), true, false, strResult)
               ? CCommandHandler::EDone
               : CCommandHandler::EFailed;
}
CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::setDomainWithSettingsXMLCommandProcess(
    const IRemoteCommand &amp;remoteCommand, string &amp;result)
{
    bool overwrite = false;
    if (remoteCommand.getArgumentCount() &gt; 1) {
        if (remoteCommand.getArgument(1) == "overwrite") {
            overwrite = true;
        } else {
            return CCommandHandler::EShowUsage;
        }
    }
    return importSingleDomainXml(remoteCommand.getArgument(0), overwrite, true, false, result)
               ? CCommandHandler::EDone
               : CCommandHandler::EFailed;
}
CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::getSystemClassXMLCommandProcess(
{
    const CSystemClass *pSystemClass = getSystemClass();
    CParameterAccessContext accessContext(strResult);
    if (!exportElementToXMLString(pSystemClass, pSystemClass-&gt;getXmlElementName(),
                                  CXmlParameterSerializingContext{accessContext, strResult},
                                  strResult)) {
        return CCommandHandler::EFailed;
    }
    return CCommandHandler::ESucceeded;
}
bool CParameterMgr::accessParameterValue(const string &amp;strPath, string &amp;strValue, bool bSet,
                                         string &amp;strError)
{
    if (bSet &amp;&amp; !checkTuningModeOn(strError)) {
        return false;
    }
    CParameterAccessContext parameterAccessContext(strError, _pMainParameterBlackboard,
                                                   _bValueSpaceIsRaw, _bOutputRawFormatIsHex);
    if (bSet) {
        parameterAccessContext.setAutoSync(_bAutoSyncOn);
    }
    return accessValue(parameterAccessContext, strPath, strValue, bSet, strError);
}
bool CParameterMgr::getParameterMapping(const string &amp;strPath, string &amp;strResult) const
{
    const CConfigurableElement *pConfigurableElement = getConfigurableElement(strPath, strResult);
    if (!pConfigurableElement) {
        return false;
    }
    auto configurableElementPath = pConfigurableElement-&gt;getConfigurableElementContext();
    const CSubsystem *pSubsystem = pConfigurableElement-&gt;getBelongingSubsystem();
    if (!pSubsystem) {
        strResult = "Unable to find the Subsystem containing the parameter";
        return false;
    }
    strResult = pSubsystem-&gt;getMapping(configurableElementPath);
    return true;
}
bool CParameterMgr::accessConfigurationValue(const string &amp;strDomain,
                                             const string &amp;strConfiguration, const string &amp;strPath,
                                             string &amp;strValue, bool bSet, string &amp;strError)
{
    CElementLocator elementLocator(getSystemClass());
    CElement *pLocatedElement = nullptr;
    if (!elementLocator.locate(strPath, &amp;pLocatedElement, strError)) {
        return false;
    }
    const CConfigurableElement *pConfigurableElement =
        static_cast&lt;const CConfigurableElement *&gt;(pLocatedElement);
    size_t baseOffset;
    bool bIsLastApplied;
    CParameterBlackboard *pConfigurationBlackboard = nullptr;
    {
        pConfigurationBlackboard = getConstConfigurableDomains()-&gt;findConfigurationBlackboard(
            strDomain, strConfiguration, pConfigurableElement, baseOffset, bIsLastApplied,
            strError);
        if (!pConfigurationBlackboard) {
            warning() &lt;&lt; "Fail: " &lt;&lt; strError;
            return false;
        }
    }
    info() &lt;&lt; "Element " &lt;&lt; strPath &lt;&lt; " in Domain " &lt;&lt; strDomain
           &lt;&lt; ", offset: " &lt;&lt; pConfigurableElement-&gt;getOffset() &lt;&lt; ", base offset: " &lt;&lt; baseOffset;
    CParameterAccessContext parameterAccessContext(
        strError, pConfigurationBlackboard, _bValueSpaceIsRaw, _bOutputRawFormatIsHex, baseOffset);
    if (bSet) {
        parameterAccessContext.setAutoSync(false);
    }
    if (!accessValue(parameterAccessContext, strPath, strValue, bSet, strError)) {
        return false;
    }
    if (bIsLastApplied) {
        parameterAccessContext.setParameterBlackboard(_pMainParameterBlackboard);
        if (bSet) {
            parameterAccessContext.setAutoSync(_bAutoSyncOn);
        }
        return accessValue(parameterAccessContext, strPath, strValue, bSet, strError);
    }
    return true;
}
bool CParameterMgr::accessValue(CParameterAccessContext &amp;parameterAccessContext,
                                const string &amp;strPath, string &amp;strValue, bool bSet,
                                string &amp;strError)
{
    lock_guard&lt;mutex&gt; autoLock(getBlackboardMutex());
    CPathNavigator pathNavigator(strPath);
    if (!pathNavigator.navigateThrough(getConstSystemClass()-&gt;getName(), strError)) {
        parameterAccessContext.setError(strError);
        return false;
    }
    return getConstSystemClass()-&gt;accessValue(pathNavigator, strValue, bSet,
                                              parameterAccessContext);
}
bool CParameterMgr::setTuningMode(bool bOn, string &amp;strError)
{
    if (bOn == tuningModeOn()) {
        strError = "Tuning mode is already in the state requested";
        return false;
    }
    if (bOn &amp;&amp; !getConstFrameworkConfiguration()-&gt;isTuningAllowed()) {
        strError = "Tuning prohibited";
        return false;
    }
    lock_guard&lt;mutex&gt; autoLock(getBlackboardMutex());
    if (!bOn) {
        doApplyConfigurations(true);
    }
    _bTuningModeIsOn = bOn;
    return true;
}
bool CParameterMgr::tuningModeOn() const
{
    return _bTuningModeIsOn;
}
void CParameterMgr::setValueSpace(bool bIsRaw)
{
    _bValueSpaceIsRaw = bIsRaw;
}
bool CParameterMgr::valueSpaceIsRaw()
{
    return _bValueSpaceIsRaw;
}
void CParameterMgr::setOutputRawFormat(bool bIsHex)
{
    _bOutputRawFormatIsHex = bIsHex;
}
bool CParameterMgr::outputRawFormatIsHex()
{
    return _bOutputRawFormatIsHex;
}
bool CParameterMgr::setAutoSync(bool bAutoSyncOn, string &amp;strError)
{
    if (bAutoSyncOn &amp;&amp; !_bAutoSyncOn) {
        if (!sync(strError)) {
            return false;
        }
    }
    _bAutoSyncOn = bAutoSyncOn;
    return true;
}
bool CParameterMgr::autoSyncOn() const
{
    return _bAutoSyncOn;
}
bool CParameterMgr::sync(string &amp;strError)
{
    if (_bAutoSyncOn) {
        strError = "Feature unavailable when Auto Sync is on";
        return false;
    }
    CSyncerSet syncerSet;
    getConstSystemClass()-&gt;fillSyncerSet(syncerSet);
    core::Results error;
    if (!syncerSet.sync(*_pMainParameterBlackboard, false, &amp;error)) {
        strError = utility::asString(error);
        return false;
    };
    return true;
}
bool CParameterMgr::createDomain(const string &amp;strName, string &amp;strError)
{
    LOG_CONTEXT("Creating configurable domain " + strName);
    if (!checkTuningModeOn(strError)) {
        return false;
    }
    return logResult(getConfigurableDomains()-&gt;createDomain(strName, strError), strError);
}
bool CParameterMgr::deleteDomain(const string &amp;strName, string &amp;strError)
{
    LOG_CONTEXT("Deleting configurable domain '" + strName + "'");
    if (!checkTuningModeOn(strError)) {
        warning() &lt;&lt; "Fail: " &lt;&lt; strError;
        return false;
    }
    return logResult(getConfigurableDomains()-&gt;deleteDomain(strName, strError), strError);
}
bool CParameterMgr::renameDomain(const string &amp;strName, const string &amp;strNewName, string &amp;strError)
{
    LOG_CONTEXT("Renaming configurable domain '" + strName + "' to '" + strNewName + "'");
    return logResult(getConfigurableDomains()-&gt;renameDomain(strName, strNewName, strError),
                     strError);
}
bool CParameterMgr::deleteAllDomains(string &amp;strError)
{
    LOG_CONTEXT("Deleting all configurable domains");
    if (!checkTuningModeOn(strError)) {
        warning() &lt;&lt; "Fail: " &lt;&lt; strError;
        return false;
    }
    getConfigurableDomains()-&gt;deleteAllDomains();
    info() &lt;&lt; "Success";
    return true;
}
bool CParameterMgr::setSequenceAwareness(const string &amp;strName, bool bSequenceAware,
                                         string &amp;strResult)
{
    LOG_CONTEXT("Making domain '" + strName + "' sequence " +
                (bSequenceAware ? "aware" : "unaware"));
    if (!checkTuningModeOn(strResult)) {
        warning() &lt;&lt; "Fail: " &lt;&lt; strResult;
        return false;
    }
    return logResult(
        getConfigurableDomains()-&gt;setSequenceAwareness(strName, bSequenceAware, strResult),
        strResult);
}
bool CParameterMgr::getSequenceAwareness(const string &amp;strName, bool &amp;bSequenceAware,
                                         string &amp;strResult)
{
    return getConfigurableDomains()-&gt;getSequenceAwareness(strName, bSequenceAware, strResult);
}
bool CParameterMgr::createConfiguration(const string &amp;strDomain, const string &amp;strConfiguration,
                                        string &amp;strError)
{
    LOG_CONTEXT("Creating domain configuration '" + strConfiguration + "' into domain '" +
                strDomain + "'");
    if (!checkTuningModeOn(strError)) {
        warning() &lt;&lt; "Fail: " &lt;&lt; strError;
        return false;
    }
    return logResult(getConfigurableDomains()-&gt;createConfiguration(
                         strDomain, strConfiguration, _pMainParameterBlackboard, strError),
                     strError);
}
bool CParameterMgr::renameConfiguration(const string &amp;strDomain, const string &amp;strConfiguration,
                                        const string &amp;strNewConfiguration, string &amp;strError)
{
    LOG_CONTEXT("Renaming domain '" + strDomain + "''s configuration '" + strConfiguration +
                "' to '" + strNewConfiguration + "'");
    return logResult(getConfigurableDomains()-&gt;renameConfiguration(strDomain, strConfiguration,
                                                                   strNewConfiguration, strError),
                     strError);
}
bool CParameterMgr::deleteConfiguration(const string &amp;strDomain, const string &amp;strConfiguration,
                                        string &amp;strError)
{
    LOG_CONTEXT("Deleting configuration '" + strConfiguration + "' from domain '" + strDomain +
                "'");
    if (!checkTuningModeOn(strError)) {
        warning() &lt;&lt; "Fail:" &lt;&lt; strError;
        return false;
    }
    return logResult(
        getConfigurableDomains()-&gt;deleteConfiguration(strDomain, strConfiguration, strError),
        strError);
}
bool CParameterMgr::restoreConfiguration(const string &amp;strDomain, const string &amp;strConfiguration,
                                         core::Results &amp;errors)
{
    string strError;
    LOG_CONTEXT("Restoring domain '" + strDomain + "''s configuration '" + strConfiguration +
                "' to parameter blackboard");
    if (!checkTuningModeOn(strError)) {
        errors.push_back(strError);
        warning() &lt;&lt; "Fail:" &lt;&lt; strError;
        return false;
    }
    return logResult(
        getConstConfigurableDomains()-&gt;restoreConfiguration(
            strDomain, strConfiguration, _pMainParameterBlackboard, _bAutoSyncOn, errors),
        strError);
}
bool CParameterMgr::saveConfiguration(const string &amp;strDomain, const string &amp;strConfiguration,
                                      string &amp;strError)
{
    LOG_CONTEXT("Saving domain '" + strDomain + "' configuration '" + strConfiguration +
                "' from parameter blackboard");
    if (!checkTuningModeOn(strError)) {
        warning() &lt;&lt; "Fail:" &lt;&lt; strError;
        return false;
    }
    return logResult(getConfigurableDomains()-&gt;saveConfiguration(
                         strDomain, strConfiguration, _pMainParameterBlackboard, strError),
                     strError);
}
bool CParameterMgr::addConfigurableElementToDomain(const string &amp;strDomain,
                                                   const string &amp;strConfigurableElementPath,
                                                   string &amp;strError)
{
    LOG_CONTEXT("Adding configurable element '" + strConfigurableElementPath + "' to domain '" +
                strDomain + "'");
    if (!checkTuningModeOn(strError)) {
        warning() &lt;&lt; "Fail: " &lt;&lt; strError;
        return false;
    }
    CElementLocator elementLocator(getSystemClass());
    CElement *pLocatedElement = nullptr;
    if (!elementLocator.locate(strConfigurableElementPath, &amp;pLocatedElement, strError)) {
        warning() &lt;&lt; "Fail: " &lt;&lt; strError;
        return false;
    }
    CConfigurableElement *pConfigurableElement =
        static_cast&lt;CConfigurableElement *&gt;(pLocatedElement);
    core::Results infos;
    bool isSuccess = getConfigurableDomains()-&gt;addConfigurableElementToDomain(
        strDomain, pConfigurableElement, _pMainParameterBlackboard, infos);
    if (isSuccess) {
        info() &lt;&lt; infos;
    } else {
        warning() &lt;&lt; infos;
    }
    strError = utility::asString(infos);
    return isSuccess;
}
bool CParameterMgr::removeConfigurableElementFromDomain(const string &amp;strDomain,
                                                        const string &amp;strConfigurableElementPath,
                                                        string &amp;strError)
{
    LOG_CONTEXT("Removing configurable element '" + strConfigurableElementPath + "' from domain '" +
                strDomain + "'");
    if (!checkTuningModeOn(strError)) {
        warning() &lt;&lt; "Fail:" &lt;&lt; strError;
        return false;
    }
    CElementLocator elementLocator(getSystemClass());
    CElement *pLocatedElement = nullptr;
    if (!elementLocator.locate(strConfigurableElementPath, &amp;pLocatedElement, strError)) {
        warning() &lt;&lt; "Fail:" &lt;&lt; strError;
        return false;
    }
    CConfigurableElement *pConfigurableElement =
        static_cast&lt;CConfigurableElement *&gt;(pLocatedElement);
    return logResult(getConfigurableDomains()-&gt;removeConfigurableElementFromDomain(
                         strDomain, pConfigurableElement, strError),
                     strError);
}
bool CParameterMgr::split(const string &amp;strDomain, const string &amp;strConfigurableElementPath,
                          string &amp;strError)
{
    LOG_CONTEXT("Splitting configurable element '" + strConfigurableElementPath + "' domain '" +
                strDomain + "'");
    if (!checkTuningModeOn(strError)) {
        warning() &lt;&lt; "Fail:" &lt;&lt; strError;
        return false;
    }
    CElementLocator elementLocator(getSystemClass());
    CElement *pLocatedElement = nullptr;
    if (!elementLocator.locate(strConfigurableElementPath, &amp;pLocatedElement, strError)) {
        warning() &lt;&lt; "Fail: " &lt;&lt; strError;
        return false;
    }
    CConfigurableElement *pConfigurableElement =
        static_cast&lt;CConfigurableElement *&gt;(pLocatedElement);
    core::Results infos;
    bool isSuccess = getConfigurableDomains()-&gt;split(strDomain, pConfigurableElement, infos);
    if (isSuccess) {
        info() &lt;&lt; infos;
    } else {
        warning() &lt;&lt; infos;
    }
    strError = utility::asString(infos);
    return isSuccess;
}
bool CParameterMgr::setElementSequence(const string &amp;strDomain, const string &amp;strConfiguration,
                                       const std::vector&lt;string&gt; &amp;astrNewElementSequence,
                                       string &amp;strError)
{
    if (!checkTuningModeOn(strError)) {
        return false;
    }
    return getConfigurableDomains()-&gt;setElementSequence(strDomain, strConfiguration,
                                                        astrNewElementSequence, strError);
}
bool CParameterMgr::getApplicationRule(const string &amp;strDomain, const string &amp;strConfiguration,
                                       string &amp;strResult)
{
    return getConfigurableDomains()-&gt;getApplicationRule(strDomain, strConfiguration, strResult);
}
bool CParameterMgr::setApplicationRule(const string &amp;strDomain, const string &amp;strConfiguration,
                                       const string &amp;strApplicationRule, string &amp;strError)
{
    return getConfigurableDomains()-&gt;setApplicationRule(
        strDomain, strConfiguration, strApplicationRule,
        getConstSelectionCriteria()-&gt;getSelectionCriteriaDefinition(), strError);
}
bool CParameterMgr::clearApplicationRule(const string &amp;strDomain, const string &amp;strConfiguration,
                                         string &amp;strError)
{
    return getConfigurableDomains()-&gt;clearApplicationRule(strDomain, strConfiguration, strError);
}
bool CParameterMgr::importDomainsXml(const string &amp;xmlSource, bool withSettings, bool fromFile,
                                     string &amp;errorMsg)
{
    if (!checkTuningModeOn(errorMsg)) {
        return false;
    }
    LOG_CONTEXT("Importing domains from " +
                (fromFile ? ("\"" + xmlSource + "\"") : "a user-provided buffer"));
    CConfigurableDomains *pConfigurableDomains = getConfigurableDomains();
    bool importSuccess = wrapLegacyXmlImport(xmlSource, fromFile, withSettings,
                                             *pConfigurableDomains, "SystemClassName", errorMsg);
    if (importSuccess) {
        pConfigurableDomains-&gt;validate(_pMainParameterBlackboard);
    }
    return importSuccess;
}
bool CParameterMgr::importSingleDomainXml(const string &amp;xmlSource, bool overwrite,
                                          bool withSettings, bool fromFile, string &amp;errorMsg)
{
    if (!checkTuningModeOn(errorMsg)) {
        return false;
    }
    LOG_CONTEXT("Importing a single domain from " +
                (fromFile ? ('"' + xmlSource + '"') : "a user-provided buffer"));
    auto standaloneDomain = utility::make_unique&lt;CConfigurableDomain&gt;();
    if (!wrapLegacyXmlImport(xmlSource, fromFile, withSettings, *standaloneDomain, "", errorMsg)) {
        return false;
    }
    if (!getConfigurableDomains()-&gt;addDomain(*standaloneDomain, overwrite, errorMsg)) {
        return false;
    }
    standaloneDomain.release();
    return true;
}
bool CParameterMgr::wrapLegacyXmlImport(const string &amp;xmlSource, bool fromFile, bool withSettings,
                                        CElement &amp;element, const string &amp;nameAttributeName,
                                        string &amp;errorMsg)
{
    CXmlDomainImportContext xmlDomainImportContext(errorMsg, withSettings, *getSystemClass());
    xmlDomainImportContext.setSelectionCriteriaDefinition(
        getConstSelectionCriteria()-&gt;getSelectionCriteriaDefinition());
    _xmlDoc *doc = CXmlDocSource::mkXmlDoc(xmlSource, fromFile, false, xmlDomainImportContext);
    if (doc == nullptr) {
        return false;
    }
    return xmlParse(xmlDomainImportContext, &amp;element, doc, "", EParameterConfigurationLibrary, true,
                    nameAttributeName);
}
bool CParameterMgr::serializeElement(std::ostream &amp;output,
                                     CXmlSerializingContext &amp;xmlSerializingContext,
                                     const CElement &amp;element) const
{
    if (!output.good()) {
        xmlSerializingContext.setError("Can't write XML: the output is in a bad state.");
        return false;
    }
    CXmlMemoryDocSource memorySource(&amp;element, _bValidateSchemasOnStart,
                                     element.getXmlElementName(), "parameter-framework",
                                     getVersion());
    CXmlStreamDocSink sink(output);
    bool processSuccess = sink.process(memorySource, xmlSerializingContext);
    return processSuccess;
}
bool CParameterMgr::exportDomainsXml(string &amp;xmlDest, bool withSettings, bool toFile,
                                     string &amp;errorMsg) const
{
    LOG_CONTEXT("Exporting domains to " +
                (toFile ? ('"' + xmlDest + '"') : "a user-provided buffer"));
    const CConfigurableDomains *configurableDomains = getConstConfigurableDomains();
    return wrapLegacyXmlExport(xmlDest, toFile, withSettings, *configurableDomains, errorMsg);
}
bool CParameterMgr::exportSingleDomainXml(string &amp;xmlDest, const string &amp;domainName,
                                          bool withSettings, bool toFile, string &amp;errorMsg) const
{
    LOG_CONTEXT("Exporting single domain '" + domainName + "' to " +
                (toFile ? ('"' + xmlDest + '"') : "a user-provided buffer"));
    const CConfigurableDomain *requestedDomain =
        getConstConfigurableDomains()-&gt;findConfigurableDomain(domainName, errorMsg);
    if (requestedDomain == nullptr) {
        return false;
    }
    return wrapLegacyXmlExport(xmlDest, toFile, withSettings, *requestedDomain, errorMsg);
}
bool CParameterMgr::wrapLegacyXmlExport(string &amp;xmlDest, bool toFile, bool withSettings,
                                        const CElement &amp;element, string &amp;errorMsg) const
{
    CXmlDomainExportContext context(errorMsg, withSettings, _bValueSpaceIsRaw,
                                    _bOutputRawFormatIsHex);
    if (toFile) {
        return wrapLegacyXmlExportToFile(xmlDest, element, context);
    } else {
        return wrapLegacyXmlExportToString(xmlDest, element, context);
    }
}
bool CParameterMgr::wrapLegacyXmlExportToFile(string &amp;xmlDest, const CElement &amp;element,
                                              CXmlDomainExportContext &amp;context) const
{
    try {
        std::ofstream output;
        output.exceptions(~std::ifstream::goodbit);
        output.open(xmlDest.c_str());
        bool status = serializeElement(output, context, element);
        output.close(); 
        return status;
    } catch (std::ofstream::failure &amp;e) {
        context.setError("Failed to open \"" + xmlDest + "\" for writing: " + e.what());
        return false;
    }
}
bool CParameterMgr::wrapLegacyXmlExportToString(string &amp;xmlDest, const CElement &amp;element,
                                                CXmlDomainExportContext &amp;context) const
{
    std::ostringstream output;
    if (!serializeElement(output, context, element)) {
        return false;
    }
    xmlDest = output.str();
    return true;
}
bool CParameterMgr::checkTuningModeOn(string &amp;strError) const
{
    if (!_bTuningModeIsOn) {
        strError = "Tuning Mode must be on";
        return false;
    }
    return true;
}
std::mutex &amp;CParameterMgr::getBlackboardMutex()
{
    return _blackboardMutex;
}
CParameterBlackboard *CParameterMgr::getParameterBlackboard()
{
    return _pMainParameterBlackboard;
}
void CParameterMgr::feedElementLibraries()
{
    auto pFrameworkConfigurationLibrary = new CElementLibrary;
    pFrameworkConfigurationLibrary-&gt;addElementBuilder(
        "ParameterFrameworkConfiguration",
        new TElementBuilderTemplate&lt;CParameterFrameworkConfiguration&gt;());
    pFrameworkConfigurationLibrary-&gt;addElementBuilder(
        "SubsystemPlugins", new TKindElementBuilderTemplate&lt;CSubsystemPlugins&gt;());
    pFrameworkConfigurationLibrary-&gt;addElementBuilder(
        "Location", new TKindElementBuilderTemplate&lt;CPluginLocation&gt;());
    pFrameworkConfigurationLibrary-&gt;addElementBuilder(
        "StructureDescriptionFileLocation",
        new TKindElementBuilderTemplate&lt;CFrameworkConfigurationLocation&gt;());
    pFrameworkConfigurationLibrary-&gt;addElementBuilder(
        "SettingsConfiguration", new TKindElementBuilderTemplate&lt;CFrameworkConfigurationGroup&gt;());
    pFrameworkConfigurationLibrary-&gt;addElementBuilder(
        "ConfigurableDomainsFileLocation",
        new TKindElementBuilderTemplate&lt;CFrameworkConfigurationLocation&gt;());
    _pElementLibrarySet-&gt;addElementLibrary(pFrameworkConfigurationLibrary);
    auto pParameterCreationLibrary = new CElementLibrary;
    pParameterCreationLibrary-&gt;addElementBuilder(
        "Subsystem", new CSubsystemElementBuilder(getSystemClass()-&gt;getSubsystemLibrary()));
    pParameterCreationLibrary-&gt;addElementBuilder(
        "ComponentType", new TNamedElementBuilderTemplate&lt;CComponentType&gt;());
    pParameterCreationLibrary-&gt;addElementBuilder(
        "Component", new TNamedElementBuilderTemplate&lt;CComponentInstance&gt;());
    pParameterCreationLibrary-&gt;addElementBuilder(
        "BitParameter", new TNamedElementBuilderTemplate&lt;CBitParameterType&gt;());
    pParameterCreationLibrary-&gt;addElementBuilder(
        "BitParameterBlock", new TNamedElementBuilderTemplate&lt;CBitParameterBlockType&gt;());
    pParameterCreationLibrary-&gt;addElementBuilder(
        "StringParameter", new TNamedElementBuilderTemplate&lt;CStringParameterType&gt;());
    pParameterCreationLibrary-&gt;addElementBuilder(
        "ParameterBlock", new TNamedElementBuilderTemplate&lt;CParameterBlockType&gt;());
    pParameterCreationLibrary-&gt;addElementBuilder(
        "BooleanParameter", new TNamedElementBuilderTemplate&lt;CBooleanParameterType&gt;());
    pParameterCreationLibrary-&gt;addElementBuilder("IntegerParameter", new IntegerParameterBuilder());
    pParameterCreationLibrary-&gt;addElementBuilder(
        "LinearAdaptation", new TElementBuilderTemplate&lt;CLinearParameterAdaptation&gt;());
    pParameterCreationLibrary-&gt;addElementBuilder(
        "LogarithmicAdaptation", new TElementBuilderTemplate&lt;CLogarithmicParameterAdaptation&gt;());
    pParameterCreationLibrary-&gt;addElementBuilder(
        "EnumParameter", new TNamedElementBuilderTemplate&lt;CEnumParameterType&gt;());
    pParameterCreationLibrary-&gt;addElementBuilder("ValuePair",
                                                 new TElementBuilderTemplate&lt;CEnumValuePair&gt;());
    pParameterCreationLibrary-&gt;addElementBuilder(
        "FixedPointParameter", new TNamedElementBuilderTemplate&lt;CFixedPointParameterType&gt;());
    pParameterCreationLibrary-&gt;addElementBuilder(
        "FloatingPointParameter", new TNamedElementBuilderTemplate&lt;CFloatingPointParameterType&gt;);
    pParameterCreationLibrary-&gt;addElementBuilder(
        "SubsystemInclude",
        new CFileIncluderElementBuilder(_bValidateSchemasOnStart, getSchemaUri()));
    _pElementLibrarySet-&gt;addElementLibrary(pParameterCreationLibrary);
    auto pParameterConfigurationLibrary = new CElementLibrary;
    pParameterConfigurationLibrary-&gt;addElementBuilder(
        "ConfigurableDomain", new TElementBuilderTemplate&lt;CConfigurableDomain&gt;());
    pParameterConfigurationLibrary-&gt;addElementBuilder(
        "Configuration", new TNamedElementBuilderTemplate&lt;CDomainConfiguration&gt;());
    pParameterConfigurationLibrary-&gt;addElementBuilder("CompoundRule",
                                                      new TElementBuilderTemplate&lt;CCompoundRule&gt;());
    pParameterConfigurationLibrary-&gt;addElementBuilder(
        "SelectionCriterionRule", new TElementBuilderTemplate&lt;CSelectionCriterionRule&gt;());
    _pElementLibrarySet-&gt;addElementLibrary(pParameterConfigurationLibrary);
}
bool CParameterMgr::getForceNoRemoteInterface() const
{
    return _bForceNoRemoteInterface;
}
void CParameterMgr::setForceNoRemoteInterface(bool bForceNoRemoteInterface)
{
    _bForceNoRemoteInterface = bForceNoRemoteInterface;
}
CParameterMgr::CommandHandler CParameterMgr::createCommandHandler()
{
    auto commandHandler = utility::make_unique&lt;CCommandHandler&gt;(this);
    for (const auto &amp;remoteCommandParserItem : gastRemoteCommandParserItems) {
        commandHandler-&gt;addCommandParser(
            remoteCommandParserItem._pcCommandName, remoteCommandParserItem._pfnParser,
            remoteCommandParserItem._minArgumentCount, remoteCommandParserItem._pcHelp,
            remoteCommandParserItem._pcDescription);
    }
    return commandHandler;
}
bool CParameterMgr::isRemoteInterfaceRequired()
{
    return (not _bForceNoRemoteInterface) and getConstFrameworkConfiguration()-&gt;isTuningAllowed();
}
bool CParameterMgr::handleRemoteProcessingInterface(string &amp;strError)
{
    LOG_CONTEXT("Handling remote processing interface");
    if (not isRemoteInterfaceRequired()) {
        return true;
    }
    auto port = getConstFrameworkConfiguration()-&gt;getServerPort();
    try {
        _pRemoteProcessorServer = new BackgroundRemoteProcessorServer(port, createCommandHandler());
    } catch (std::runtime_error &amp;e) {
        strError = string("ParameterMgr: Unable to create Remote Processor Server: ") + e.what();
        return false;
    }
    if (_pRemoteProcessorServer == nullptr) {
        strError = "ParameterMgr: Unable to create Remote Processor Server";
        return false;
    }
    if (!_pRemoteProcessorServer-&gt;start(strError)) {
        ostringstream oss;
        oss &lt;&lt; "ParameterMgr: Unable to start remote processor server on port " &lt;&lt; port;
        strError = oss.str() + ": " + strError;
        return false;
    }
    info() &lt;&lt; "Remote Processor Server started on port " &lt;&lt; port;
    return true;
}
CParameterFrameworkConfiguration *CParameterMgr::getFrameworkConfiguration()
{
    return static_cast&lt;CParameterFrameworkConfiguration *&gt;(getChild(EFrameworkConfiguration));
}
const CParameterFrameworkConfiguration *CParameterMgr::getConstFrameworkConfiguration()
{
    return getFrameworkConfiguration();
}
CSelectionCriteria *CParameterMgr::getSelectionCriteria()
{
    return static_cast&lt;CSelectionCriteria *&gt;(getChild(ESelectionCriteria));
}
const CSelectionCriteria *CParameterMgr::getConstSelectionCriteria()
{
    return static_cast&lt;const CSelectionCriteria *&gt;(getChild(ESelectionCriteria));
}
CSystemClass *CParameterMgr::getSystemClass()
{
    return static_cast&lt;CSystemClass *&gt;(getChild(ESystemClass));
}
const CSystemClass *CParameterMgr::getConstSystemClass() const
{
    return static_cast&lt;const CSystemClass *&gt;(getChild(ESystemClass));
}
CConfigurableDomains *CParameterMgr::getConfigurableDomains()
{
    return static_cast&lt;CConfigurableDomains *&gt;(getChild(EConfigurableDomains));
}
const CConfigurableDomains *CParameterMgr::getConstConfigurableDomains()
{
    return static_cast&lt;const CConfigurableDomains *&gt;(getChild(EConfigurableDomains));
}
const CConfigurableDomains *CParameterMgr::getConstConfigurableDomains() const
{
    return static_cast&lt;const CConfigurableDomains *&gt;(getChild(EConfigurableDomains));
}
void CParameterMgr::doApplyConfigurations(bool bForce)
{
    LOG_CONTEXT("Applying configurations");
    CSyncerSet syncerSet;
    core::Results infos;
    getSystemClass()-&gt;checkForSubsystemsToResync(syncerSet, infos);
    getConfigurableDomains()-&gt;apply(_pMainParameterBlackboard, syncerSet, bForce, infos);
    info() &lt;&lt; infos;
    getSelectionCriteria()-&gt;resetModifiedStatus();
}
bool CParameterMgr::exportElementToXMLString(const IXmlSource *pXmlSource,
                                             const string &amp;strRootElementType,
                                             CXmlSerializingContext &amp;&amp;xmlSerializingContext,
                                             string &amp;strResult) const
{
    CXmlMemoryDocSource memorySource(pXmlSource, false, strRootElementType);
    ostringstream output;
    CXmlStreamDocSink streamSink(output);
    bool bProcessSuccess = streamSink.process(memorySource, xmlSerializingContext);
    strResult = output.str();
    return bProcessSuccess;
}
bool CParameterMgr::logResult(bool isSuccess, const std::string &amp;result)
{
    std::string log = result.empty() ? "" : ": " + result;
    if (isSuccess) {
        info() &lt;&lt; "Success" &lt;&lt; log;
    } else {
        warning() &lt;&lt; "Fail" &lt;&lt; log;
    }
    return isSuccess;
}
log::details::Info CParameterMgr::info()
{
    return _logger.info();
}
log::details::Warning CParameterMgr::warning()
{
    return _logger.warning();
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>BitParameterBlockType.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include "BitParameterBlockType.h"
#include "BitParameterBlock.h"
#include "Utility.h"
#define base CTypeElement
using std::string;
<a name="0"></a>
CBitParameterBlockType::CBitParameterBlockType(const string &amp;strName) : base(strName)
{
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
string CBitParameterBlockType::getKind() const
{
    return "BitParameterBlock";
}
bool CBitParameterBlockType::childrenAreDynamic() const
{
    return true;
}
size_t CBitParameterBlockType::getSize() const</b></font>
{
    return _size;
}
bool CBitParameterBlockType::fromXml(const CXmlElement &amp;xmlElement,
                                     CXmlSerializingContext &amp;serializingContext)
{
    xmlElement.getAttribute("Size", _size);
    _size /= 8;
    return base::fromXml(xmlElement, serializingContext);
}
CInstanceConfigurableElement *CBitParameterBlockType::doInstantiate() const
{
    return new CBitParameterBlock(getName(), this);
}
void CBitParameterBlockType::toXml(CXmlElement &amp;xmlElement,
                                   CXmlSerializingContext &amp;serializingContext) const
{
    xmlElement.setAttribute("Size", _size * 8);
    base::toXml(xmlElement, serializingContext);
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
