<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for ParameterMgr.cpp & BitParameterBlockType.cpp</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for ParameterMgr.cpp & BitParameterBlockType.cpp
      </h3>
      <h1 align="center">
        1.0%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>ParameterMgr.cpp (0.5242464%)<TH>BitParameterBlockType.cpp (30.0%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match598-0.html#0',2,'match598-1.html#0',3)" NAME="0">(344-357)<TD><A HREF="javascript:ZweiFrames('match598-0.html#0',2,'match598-1.html#0',3)" NAME="0">(40-53)</A><TD ALIGN=center><FONT COLOR="#ff0000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>ParameterMgr.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright (c) 2011-2016, Intel Corporation
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation and/or
 * other materials provided with the distribution.
 *
 * 3. Neither the name of the copyright holder nor the names of its contributors
 * may be used to endorse or promote products derived from this software without
 * specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
#include &quot;version.h&quot;
#include &quot;ParameterMgr.h&quot;
#include &quot;ConfigurationAccessContext.h&quot;
#include &quot;XmlParameterSerializingContext.h&quot;
#include &quot;XmlElementSerializingContext.h&quot;
#include &quot;SystemClass.h&quot;
#include &quot;ElementLibrarySet.h&quot;
#include &quot;SubsystemLibrary.h&quot;
#include &quot;NamedElementBuilderTemplate.h&quot;
#include &quot;KindElementBuilderTemplate.h&quot;
#include &quot;ElementBuilderTemplate.h&quot;
#include &quot;SelectionCriterionType.h&quot;
#include &quot;SubsystemElementBuilder.h&quot;
#include &quot;FileIncluderElementBuilder.h&quot;
#include &quot;SelectionCriteria.h&quot;
#include &quot;ComponentType.h&quot;
#include &quot;ComponentInstance.h&quot;
#include &quot;ParameterBlockType.h&quot;
#include &quot;BooleanParameterType.h&quot;
#include &quot;IntegerParameterBuilder.h&quot;
#include &quot;FixedPointParameterType.h&quot;
#include &quot;FloatingPointParameterType.h&quot;
#include &quot;ParameterBlackboard.h&quot;
#include &quot;Parameter.h&quot;
#include &quot;ParameterAccessContext.h&quot;
#include &quot;ParameterFrameworkConfiguration.h&quot;
#include &quot;FrameworkConfigurationGroup.h&quot;
#include &quot;PluginLocation.h&quot;
#include &quot;SubsystemPlugins.h&quot;
#include &quot;FrameworkConfigurationLocation.h&quot;
#include &quot;ConfigurableDomains.h&quot;
#include &quot;ConfigurableDomain.h&quot;
#include &quot;DomainConfiguration.h&quot;
#include &quot;XmlDomainSerializingContext.h&quot;
#include &quot;XmlDomainExportContext.h&quot;
#include &quot;XmlDomainImportContext.h&quot;
#include &quot;BitParameterBlockType.h&quot;
#include &quot;BitParameterType.h&quot;
#include &quot;StringParameterType.h&quot;
#include &quot;EnumParameterType.h&quot;
#include &quot;BackgroundRemoteProcessorServer.h&quot;
#include &quot;ElementLocator.h&quot;
#include &quot;CompoundRule.h&quot;
#include &quot;SelectionCriterionRule.h&quot;
#include &quot;SimulatedBackSynchronizer.h&quot;
#include &quot;HardwareBackSynchronizer.h&quot;
#include &lt;cassert&gt;
#include &quot;ParameterHandle.h&quot;
#include &quot;LinearParameterAdaptation.h&quot;
#include &quot;LogarithmicParameterAdaptation.h&quot;
#include &quot;EnumValuePair.h&quot;
#include &quot;Subsystem.h&quot;
#include &quot;XmlStreamDocSink.h&quot;
#include &quot;XmlMemoryDocSink.h&quot;
#include &quot;XmlDocSource.h&quot;
#include &quot;XmlMemoryDocSource.h&quot;
#include &quot;SelectionCriteriaDefinition.h&quot;
#include &quot;Utility.h&quot;
#include &quot;Memory.hpp&quot;
#include &lt;sstream&gt;
#include &lt;fstream&gt;
#include &lt;algorithm&gt;
#include &lt;stdexcept&gt;
#include &lt;mutex&gt;
#include &lt;iomanip&gt;
#include &quot;convert.hpp&quot;

#define base CElement

/** Private macro helper to declare a new context
 *
 * Context declaration always need logger and logging prefix to be
 * passed as parameters.
 * This macro aims to avoid this boring notation.
 * This macro should be called only once in a scope. Nested scopes can
 * call this macro too, as variable shadowing is supported.
 */
#define LOG_CONTEXT(contextTitle) core::log::Context context(_logger, contextTitle)

#ifdef SIMULATION
// In simulation, back synchronization of the blackboard won't probably work
// We need to ensure though the blackboard is initialized with valid data
typedef CSimulatedBackSynchronizer BackSynchronizer;
#else
// Real back synchronizer from subsystems
typedef CHardwareBackSynchronizer BackSynchronizer;
#endif

using std::string;
using std::list;
using std::vector;
using std::ostringstream;
using std::ofstream;
using std::ifstream;
using std::mutex;
using std::lock_guard;

// FIXME: integrate ParameterMgr to core namespace
using namespace core;

// Used for remote processor server creation
typedef IRemoteProcessorServerInterface *(*CreateRemoteProcessorServer)(
    uint16_t uiPort, IRemoteCommandHandler *pCommandHandler);

// Config File System looks normally like this:
// ---------------------------------------------
//|-- &lt;ParameterFrameworkConfiguration&gt;.xml
//|-- schemas
//|   `-- *.xsd
//|-- Settings
//|   `-- &lt;SystemClassName folder&gt;*
//|       |-- &lt;ConfigurableDomains&gt;.xml
//|       `-- &lt;Settings&gt;.bin?
//`-- Structure
//    `-- &lt;SystemClassName folder&gt;*
//        |-- &lt;SystemClassName&gt;Class.xml
//        `-- &lt;Subsystem&gt;.xml*
// --------------------------------------------

// Remote command parser array
const CParameterMgr::SRemoteCommandParserItem CParameterMgr::gastRemoteCommandParserItems[] = {

    /// Version
    {&quot;version&quot;, &amp;CParameterMgr::versionCommandProcess, 0, &quot;&quot;, &quot;Show version&quot;},

    /// Status
    {&quot;status&quot;, &amp;CParameterMgr::statusCommandProcess, 0, &quot;&quot;, &quot;Show current status&quot;},

    /// Tuning Mode
    {&quot;setTuningMode&quot;, &amp;CParameterMgr::setTuningModeCommandProcess, 1, &quot;on|off*&quot;,
     &quot;Turn on or off Tuning Mode&quot;},
    {&quot;getTuningMode&quot;, &amp;CParameterMgr::getTuningModeCommandProcess, 0, &quot;&quot;, &quot;Show Tuning Mode&quot;},

    /// Value Space
    {&quot;setValueSpace&quot;, &amp;CParameterMgr::setValueSpaceCommandProcess, 1, &quot;raw|real*&quot;,
     &quot;Assigns Value Space used for parameter value interpretation&quot;},
    {&quot;getValueSpace&quot;, &amp;CParameterMgr::getValueSpaceCommandProcess, 0, &quot;&quot;, &quot;Show Value Space&quot;},

    /// Output Raw Format
    {&quot;setOutputRawFormat&quot;, &amp;CParameterMgr::setOutputRawFormatCommandProcess, 1, &quot;dec*|hex&quot;,
     &quot;Assigns format used to output parameter values when in raw Value Space&quot;},
    {&quot;getOutputRawFormat&quot;, &amp;CParameterMgr::getOutputRawFormatCommandProcess, 0, &quot;&quot;,
     &quot;Show Output Raw Format&quot;},

    /// Sync
    {&quot;setAutoSync&quot;, &amp;CParameterMgr::setAutoSyncCommandProcess, 1, &quot;on*|off&quot;,
     &quot;Turn on or off automatic synchronization to hardware while in Tuning Mode&quot;},
    {&quot;getAutoSync&quot;, &amp;CParameterMgr::getAutoSyncCommandProcess, 0, &quot;&quot;, &quot;Show Auto Sync state&quot;},
    {&quot;sync&quot;, &amp;CParameterMgr::syncCommandProcess, 0, &quot;&quot;,
     &quot;Synchronize current settings to hardware while in Tuning Mode and Auto Sync off&quot;},

    /// Criteria
    {&quot;listCriteria&quot;, &amp;CParameterMgr::listCriteriaCommandProcess, 0, &quot;[CSV|XML]&quot;,
     &quot;List selection criteria&quot;},

    /// Domains
    {&quot;listDomains&quot;, &amp;CParameterMgr::listDomainsCommandProcess, 0, &quot;&quot;, &quot;List configurable domains&quot;},
    {&quot;dumpDomains&quot;, &amp;CParameterMgr::dumpDomainsCommandProcess, 0, &quot;&quot;,
     &quot;Show all domains and configurations, including applicability conditions&quot;},
    {&quot;createDomain&quot;, &amp;CParameterMgr::createDomainCommandProcess, 1, &quot;&lt;domain&gt;&quot;,
     &quot;Create new configurable domain&quot;},
    {&quot;deleteDomain&quot;, &amp;CParameterMgr::deleteDomainCommandProcess, 1, &quot;&lt;domain&gt;&quot;,
     &quot;Delete configurable domain&quot;},
    {&quot;deleteAllDomains&quot;, &amp;CParameterMgr::deleteAllDomainsCommandProcess, 0, &quot;&quot;,
     &quot;Delete all configurable domains&quot;},
    {&quot;renameDomain&quot;, &amp;CParameterMgr::renameDomainCommandProcess, 2, &quot;&lt;domain&gt; &lt;new name&gt;&quot;,
     &quot;Rename configurable domain&quot;},
    {&quot;setSequenceAwareness&quot;, &amp;CParameterMgr::setSequenceAwarenessCommandProcess, 1,
     &quot;&lt;domain&gt; true|false*&quot;, &quot;Set configurable domain sequence awareness&quot;},
    {&quot;getSequenceAwareness&quot;, &amp;CParameterMgr::getSequenceAwarenessCommandProcess, 1, &quot;&lt;domain&gt;&quot;,
     &quot;Get configurable domain sequence awareness&quot;},
    {&quot;listDomainElements&quot;, &amp;CParameterMgr::listDomainElementsCommandProcess, 1, &quot;&lt;domain&gt;&quot;,
     &quot;List elements associated to configurable domain&quot;},
    {&quot;addElement&quot;, &amp;CParameterMgr::addElementCommandProcess, 2, &quot;&lt;domain&gt; &lt;elem path&gt;&quot;,
     &quot;Associate element at given path to configurable domain&quot;},
    {&quot;removeElement&quot;, &amp;CParameterMgr::removeElementCommandProcess, 2, &quot;&lt;domain&gt; &lt;elem path&gt;&quot;,
     &quot;Dissociate element at given path from configurable domain&quot;},
    {&quot;splitDomain&quot;, &amp;CParameterMgr::splitDomainCommandProcess, 2, &quot;&lt;domain&gt; &lt;elem path&gt;&quot;,
     &quot;Split configurable domain at given associated element path&quot;},

    /// Configurations
    {&quot;listConfigurations&quot;, &amp;CParameterMgr::listConfigurationsCommandProcess, 1, &quot;&lt;domain&gt;&quot;,
     &quot;List domain configurations&quot;},
    {&quot;createConfiguration&quot;, &amp;CParameterMgr::createConfigurationCommandProcess, 2,
     &quot;&lt;domain&gt; &lt;configuration&gt;&quot;, &quot;Create new domain configuration&quot;},
    {&quot;deleteConfiguration&quot;, &amp;CParameterMgr::deleteConfigurationCommandProcess, 2,
     &quot;&lt;domain&gt; &lt;configuration&gt;&quot;, &quot;Delete domain configuration&quot;},
    {&quot;renameConfiguration&quot;, &amp;CParameterMgr::renameConfigurationCommandProcess, 3,
     &quot;&lt;domain&gt; &lt;configuration&gt; &lt;new name&gt;&quot;, &quot;Rename domain configuration&quot;},
    {&quot;saveConfiguration&quot;, &amp;CParameterMgr::saveConfigurationCommandProcess, 2,
     &quot;&lt;domain&gt; &lt;configuration&gt;&quot;, &quot;Save current settings into configuration&quot;},
    {&quot;restoreConfiguration&quot;, &amp;CParameterMgr::restoreConfigurationCommandProcess, 2,
     &quot;&lt;domain&gt; &lt;configuration&gt;&quot;, &quot;Restore current settings from configuration&quot;},
    {&quot;setElementSequence&quot;, &amp;CParameterMgr::setElementSequenceCommandProcess, 3,
     &quot;&lt;domain&gt; &lt;configuration&gt; &lt;elem path list&gt;&quot;,
     &quot;Set element application order for configuration&quot;},
    {&quot;getElementSequence&quot;, &amp;CParameterMgr::getElementSequenceCommandProcess, 2,
     &quot;&lt;domain&gt; &lt;configuration&gt;&quot;, &quot;Get element application order for configuration&quot;},
    {&quot;setRule&quot;, &amp;CParameterMgr::setRuleCommandProcess, 3, &quot;&lt;domain&gt; &lt;configuration&gt; &lt;rule&gt;&quot;,
     &quot;Set configuration application rule&quot;},
    {&quot;clearRule&quot;, &amp;CParameterMgr::clearRuleCommandProcess, 2, &quot;&lt;domain&gt; &lt;configuration&gt;&quot;,
     &quot;Clear configuration application rule&quot;},
    {&quot;getRule&quot;, &amp;CParameterMgr::getRuleCommandProcess, 2, &quot;&lt;domain&gt; &lt;configuration&gt;&quot;,
     &quot;Get configuration application rule&quot;},

    /// Elements/Parameters
    {&quot;listElements&quot;, &amp;CParameterMgr::listElementsCommandProcess, 1, &quot;&lt;elem path&gt;|/&quot;,
     &quot;List elements under element at given path or root&quot;},
    {&quot;listParameters&quot;, &amp;CParameterMgr::listParametersCommandProcess, 1, &quot;&lt;elem path&gt;|/&quot;,
     &quot;List parameters under element at given path or root&quot;},
    {&quot;getElementStructureXML&quot;, &amp;CParameterMgr::getElementStructureXMLCommandProcess, 1,
     &quot;&lt;elem path&gt;&quot;, &quot;Get structure of element at given path in XML format&quot;},
    {&quot;getElementBytes&quot;, &amp;CParameterMgr::getElementBytesCommandProcess, 1, &quot;&lt;elem path&gt;&quot;,
     &quot;Get settings of element at given path in Byte Array format&quot;},
    {&quot;setElementBytes&quot;, &amp;CParameterMgr::setElementBytesCommandProcess, 2, &quot;&lt;elem path&gt; &lt;values&gt;&quot;,
     &quot;Set settings of element at given path in Byte Array format&quot;},
    {&quot;getElementXML&quot;, &amp;CParameterMgr::getElementXMLCommandProcess, 1, &quot;&lt;elem path&gt;&quot;,
     &quot;Get settings of element at given path in XML format&quot;},
    {&quot;setElementXML&quot;, &amp;CParameterMgr::setElementXMLCommandProcess, 2, &quot;&lt;elem path&gt; &lt;values&gt;&quot;,
     &quot;Set settings of element at given path in XML format&quot;},
    {&quot;dumpElement&quot;, &amp;CParameterMgr::dumpElementCommandProcess, 1, &quot;&lt;elem path&gt;&quot;,
     &quot;Dump structure and content of element at given path&quot;},
    {&quot;getElementSize&quot;, &amp;CParameterMgr::getElementSizeCommandProcess, 1, &quot;&lt;elem path&gt;&quot;,
     &quot;Show size of element at given path&quot;},
    {&quot;showProperties&quot;, &amp;CParameterMgr::showPropertiesCommandProcess, 1, &quot;&lt;elem path&gt;&quot;,
     &quot;Show properties of element at given path&quot;},
    {&quot;getParameter&quot;, &amp;CParameterMgr::getParameterCommandProcess, 1, &quot;&lt;param path&gt;&quot;,
     &quot;Get value for parameter at given path&quot;},
    {&quot;setParameter&quot;, &amp;CParameterMgr::setParameterCommandProcess, 2, &quot;&lt;param path&gt; &lt;value&gt;&quot;,
     &quot;Set value for parameter at given path&quot;},
    {&quot;listBelongingDomains&quot;, &amp;CParameterMgr::listBelongingDomainsCommandProcess, 1, &quot;&lt;elem path&gt;&quot;,
     &quot;List domain(s) element at given path belongs to&quot;},
    {&quot;listAssociatedDomains&quot;, &amp;CParameterMgr::listAssociatedDomainsCommandProcess, 1, &quot;&lt;elem path&gt;&quot;,
     &quot;List domain(s) element at given path is associated to&quot;},
    {&quot;getConfigurationParameter&quot;, &amp;CParameterMgr::getConfigurationParameterCommandProcess, 3,
     &quot;&lt;domain&gt; &lt;configuration&gt; &lt;param path&gt;&quot;,
     &quot;Get value for parameter at given path from configuration&quot;},
    {&quot;setConfigurationParameter&quot;, &amp;CParameterMgr::setConfigurationParameterCommandProcess, 4,
     &quot;&lt;domain&gt; &lt;configuration&gt; &lt;param path&gt; &lt;value&gt;&quot;,
     &quot;Set value for parameter at given path to configuration&quot;},
    {&quot;showMapping&quot;, &amp;CParameterMgr::showMappingCommandProcess, 1, &quot;&lt;elem path&gt;&quot;,
     &quot;Show mapping for an element at given path&quot;},

    /// Browse
    {&quot;listAssociatedElements&quot;, &amp;CParameterMgr::listAssociatedElementsCommandProcess, 0, &quot;&quot;,
     &quot;List element sub-trees associated to at least one configurable domain&quot;},
    {&quot;listConflictingElements&quot;, &amp;CParameterMgr::listConflictingElementsCommandProcess, 0, &quot;&quot;,
     &quot;List element sub-trees contained in more than one configurable domain&quot;},
    {&quot;listRogueElements&quot;, &amp;CParameterMgr::listRogueElementsCommandProcess, 0, &quot;&quot;,
     &quot;List element sub-trees owned by no configurable domain&quot;},

    /// Settings Import/Export
    {&quot;exportDomainsXML&quot;, &amp;CParameterMgr::exportDomainsXMLCommandProcess, 1, &quot;&lt;file path&gt; &quot;,
     &quot;Export domains to an XML file (provide an absolute path or relative&quot;
     &quot;to the client's working directory)&quot;},
    {&quot;importDomainsXML&quot;, &amp;CParameterMgr::importDomainsXMLCommandProcess, 1, &quot;&lt;file path&gt;&quot;,
     &quot;Import domains from an XML file (provide an absolute path or relative&quot;
     &quot;to the client's working directory)&quot;},
    {&quot;exportDomainsWithSettingsXML&quot;, &amp;CParameterMgr::exportDomainsWithSettingsXMLCommandProcess, 1,
     &quot;&lt;file path&gt; &quot;,
     &quot;Export domains including settings to XML file (provide an absolute path or relative&quot;
     &quot;to the client's working directory)&quot;},
    {&quot;exportDomainWithSettingsXML&quot;, &amp;CParameterMgr::exportDomainWithSettingsXMLCommandProcess, 2,
     &quot;&lt;domain&gt; &lt;file path&gt; &quot;, &quot;Export a single given domain including settings to XML file&quot;
                              &quot; (provide an absolute path or relative to the client's&quot;
                              &quot; working directory)&quot;},
    {&quot;importDomainsWithSettingsXML&quot;, &amp;CParameterMgr::importDomainsWithSettingsXMLCommandProcess, 1,
     &quot;&lt;file path&gt;&quot;,
     &quot;Import domains including settings from XML file (provide an absolute path or relative&quot;
     &quot;to the client's working directory)&quot;},
    {&quot;importDomainWithSettingsXML&quot;, &amp;CParameterMgr::importDomainWithSettingsXMLCommandProcess, 1,
     &quot;&lt;file path&gt; [overwrite]&quot;,
     &quot;Import a single domain including settings from XML file.&quot;
     &quot; Does not overwrite an existing domain unless 'overwrite' is passed as second&quot;
     &quot; argument. Provide an absolute path or relative to the client's working directory)&quot;},
    {&quot;getDomainsWithSettingsXML&quot;, &amp;CParameterMgr::getDomainsWithSettingsXMLCommandProcess, 0, &quot;&quot;,
     &quot;Print domains including settings as XML&quot;},
    {&quot;getDomainWithSettingsXML&quot;, &amp;CParameterMgr::getDomainWithSettingsXMLCommandProcess, 1,
     &quot;&lt;domain&gt;&quot;, &quot;Print the given domain including settings as XML&quot;},
    {&quot;setDomainsWithSettingsXML&quot;, &amp;CParameterMgr::setDomainsWithSettingsXMLCommandProcess, 1,
     &quot;&lt;xml configurable domains&gt;&quot;, &quot;Import domains including settings from XML string&quot;},
    {&quot;setDomainWithSettingsXML&quot;, &amp;CParameterMgr::setDomainWithSettingsXMLCommandProcess, 1,
     &quot;&lt;xml configurable domain&gt; [overwrite]&quot;,
     &quot;Import domains including settings from XML&quot;
     &quot; string. Does not overwrite an existing domain unless 'overwrite' is passed as second&quot;
     &quot; argument&quot;},
    /// Structure Export
    {&quot;getSystemClassXML&quot;, &amp;CParameterMgr::getSystemClassXMLCommandProcess, 0, &quot;&quot;,
     &quot;Print parameter structure as XML&quot;},
    /// Deprecated Commands
    {&quot;getDomainsXML&quot;, &amp;CParameterMgr::getDomainsWithSettingsXMLCommandProcess, 0, &quot;&quot;,
     &quot;DEPRECATED COMMAND, please use getDomainsWithSettingsXML&quot;},

};

// Remote command parsers array Size
CParameterMgr::CParameterMgr(const string &amp;strConfigurationFilePath, log::ILogger &amp;logger)
    : _pMainParameterBlackboard(new CParameterBlackboard),
      _pElementLibrarySet(new CElementLibrarySet),
      _xmlConfigurationUri(CXmlDocSource::mkUri(strConfigurationFilePath, &quot;&quot;)), _logger(logger)
{
    // Deal with children
    addChild(new CParameterFrameworkConfiguration);
    addChild(new CSelectionCriteria);
    addChild(new CSystemClass(_logger));
    addChild(new CConfigurableDomains);
}

CParameterMgr::~CParameterMgr()
{
    // Children
<A NAME="0"></A>    delete _pRemoteProcessorServer;
    delete _pMainParameterBlackboard;
    delete _pElementLibrarySet;
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match598-1.html#0',3,'match598-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>}

string CParameterMgr::getKind() const
{
    return &quot;ParameterMgr&quot;;
}

// Version
string CParameterMgr::getVersion() const
{
    return PARAMETER_FRAMEWORK_VERSION;
}

bool CParameterMgr::load(string &amp;strError)</B></FONT>
{
    LOG_CONTEXT(&quot;Loading&quot;);

    feedElementLibraries();

    // Load Framework configuration
    if (!loadFrameworkConfiguration(strError)) {

        return false;
    }

    if (!loadSubsystems(strError)) {

        return false;
    }

    // Load structure
    if (!loadStructure(strError)) {

        return false;
    }

    // Load settings
    if (!loadSettings(strError)) {

        return false;
    }

    // Init flow of element tree
    if (!init(strError)) {

        return false;
    }

    {
        LOG_CONTEXT(&quot;Main blackboard back synchronization&quot;);

        // Back synchronization for areas in parameter blackboard not covered by any domain
        BackSynchronizer(getConstSystemClass(), _pMainParameterBlackboard).sync();
    }

    // We're done loading the settings and back synchronizing
    CConfigurableDomains *pConfigurableDomains = getConfigurableDomains();

    // We need to ensure all domains are valid
    pConfigurableDomains-&gt;validate(_pMainParameterBlackboard);

    // Log selection criterion states
    {
        LOG_CONTEXT(&quot;Criterion states&quot;);

        const CSelectionCriteria *selectionCriteria = getConstSelectionCriteria();

        list&lt;string&gt; criteria;
        selectionCriteria-&gt;listSelectionCriteria(criteria, true, false);

        info() &lt;&lt; criteria;
    }

    // Subsystem can not ask for resync as they have not been synced yet
    getSystemClass()-&gt;cleanSubsystemsNeedToResync();

    // At initialization, check subsystems that need resync
    doApplyConfigurations(true);

    // Start remote processor server if appropriate
    return handleRemoteProcessingInterface(strError);
}

bool CParameterMgr::loadFrameworkConfiguration(string &amp;strError)
{
    LOG_CONTEXT(&quot;Loading framework configuration&quot;);

    // Parse Structure XML file
    CXmlElementSerializingContext elementSerializingContext(strError);

    _xmlDoc *doc =
        CXmlDocSource::mkXmlDoc(_xmlConfigurationUri, true, true, elementSerializingContext);
    if (doc == nullptr) {
        return false;
    }

    if (!xmlParse(elementSerializingContext, getFrameworkConfiguration(), doc, _xmlConfigurationUri,
                  EFrameworkConfigurationLibrary)) {

        return false;
    }
    // Set class name to system class and configurable domains
    getSystemClass()-&gt;setName(getConstFrameworkConfiguration()-&gt;getSystemClassName());
    getConfigurableDomains()-&gt;setName(getConstFrameworkConfiguration()-&gt;getSystemClassName());

    // Get subsystem plugins elements
    _pSubsystemPlugins = static_cast&lt;const CSubsystemPlugins *&gt;(
        getConstFrameworkConfiguration()-&gt;findChild(&quot;SubsystemPlugins&quot;));

    if (!_pSubsystemPlugins) {

        strError = &quot;Parameter Framework Configuration: couldn't find SubsystemPlugins element&quot;;

        return false;
    }

    // Log tuning availability
    info() &lt;&lt; &quot;Tuning &quot;
           &lt;&lt; (getConstFrameworkConfiguration()-&gt;isTuningAllowed() ? &quot;allowed&quot; : &quot;prohibited&quot;);

    return true;
}

bool CParameterMgr::loadSubsystems(std::string &amp;error)
{
    LOG_CONTEXT(&quot;Loading subsystem plugins&quot;);

    // Load subsystems
    bool isSuccess =
        getSystemClass()-&gt;loadSubsystems(error, _pSubsystemPlugins, !_bFailOnMissingSubsystem);

    if (isSuccess) {
        info() &lt;&lt; &quot;All subsystem plugins successfully loaded&quot;;

        if (!error.empty()) {
            // Log missing subsystems as info
            info() &lt;&lt; error;
        }
    } else {
        warning() &lt;&lt; error;
    }
    return isSuccess;
}

bool CParameterMgr::loadStructure(string &amp;strError)
{
    // Retrieve system to load structure to
    CSystemClass *pSystemClass = getSystemClass();

    LOG_CONTEXT(&quot;Loading &quot; + pSystemClass-&gt;getName() + &quot; system class structure&quot;);

    // Get structure description element
    const CFrameworkConfigurationLocation *pStructureDescriptionFileLocation =
        static_cast&lt;const CFrameworkConfigurationLocation *&gt;(
            getConstFrameworkConfiguration()-&gt;findChildOfKind(&quot;StructureDescriptionFileLocation&quot;));

    if (!pStructureDescriptionFileLocation) {

        strError = &quot;No StructureDescriptionFileLocation element found for SystemClass &quot; +
                   pSystemClass-&gt;getName();

        return false;
    }

    // Parse Structure XML file
    CParameterAccessContext accessContext(strError);
    CXmlParameterSerializingContext parameterBuildContext(accessContext, strError);

    {
        // Get structure URI
        string structureUri =
            CXmlDocSource::mkUri(_xmlConfigurationUri, pStructureDescriptionFileLocation-&gt;getUri());

        LOG_CONTEXT(&quot;Importing system structure from file &quot; + structureUri);

        _xmlDoc *doc = CXmlDocSource::mkXmlDoc(structureUri, true, true, parameterBuildContext);
        if (doc == nullptr) {
            return false;
        }

        if (!xmlParse(parameterBuildContext, pSystemClass, doc, structureUri,
                      EParameterCreationLibrary)) {

            return false;
        }
    }

    // Initialize offsets
    pSystemClass-&gt;setOffset(0);

    // Initialize main blackboard's size
    _pMainParameterBlackboard-&gt;setSize(pSystemClass-&gt;getFootPrint());

    return true;
}

bool CParameterMgr::loadSettings(string &amp;strError)
{
    string strLoadError;
    bool success = loadSettingsFromConfigFile(strLoadError);

    if (!success &amp;&amp; !_bFailOnFailedSettingsLoad) {
        // Load can not fail, ie continue but log the load errors
        warning() &lt;&lt; strLoadError;
        warning() &lt;&lt; &quot;Failed to load settings, continue without domains.&quot;;
        success = true;
    }

    if (!success) {
        // Propagate the litteral error only if the function fails
        strError = strLoadError;
        return false;
    }

    return true;
}

bool CParameterMgr::loadSettingsFromConfigFile(string &amp;strError)
{
    LOG_CONTEXT(&quot;Loading settings&quot;);

    // Get settings configuration element
    const CFrameworkConfigurationGroup *pParameterConfigurationGroup =
        static_cast&lt;const CFrameworkConfigurationGroup *&gt;(
            getConstFrameworkConfiguration()-&gt;findChildOfKind(&quot;SettingsConfiguration&quot;));

    if (!pParameterConfigurationGroup) {

        // No settings to load

        return true;
    }

    // Get configurable domains element
    const CFrameworkConfigurationLocation *pConfigurableDomainsFileLocation =
        static_cast&lt;const CFrameworkConfigurationLocation *&gt;(
            pParameterConfigurationGroup-&gt;findChildOfKind(&quot;ConfigurableDomainsFileLocation&quot;));

    if (!pConfigurableDomainsFileLocation) {

        strError = &quot;No ConfigurableDomainsFileLocation element found for SystemClass &quot; +
                   getSystemClass()-&gt;getName();

        return false;
    }
    // Get destination root element
    CConfigurableDomains *pConfigurableDomains = getConfigurableDomains();

    // Get Xml configuration domains URI
    string configurationDomainsUri =
        CXmlDocSource::mkUri(_xmlConfigurationUri, pConfigurableDomainsFileLocation-&gt;getUri());

    // Parse configuration domains XML file
    CXmlDomainImportContext xmlDomainImportContext(strError, true, *getSystemClass());

    // Selection criteria definition for rule creation
    xmlDomainImportContext.setSelectionCriteriaDefinition(
        getConstSelectionCriteria()-&gt;getSelectionCriteriaDefinition());

    // Auto validation of configurations
    xmlDomainImportContext.setAutoValidationRequired(true);

    info() &lt;&lt; &quot;Importing configurable domains from file &quot; &lt;&lt; configurationDomainsUri
           &lt;&lt; &quot; with settings&quot;;

    _xmlDoc *doc =
        CXmlDocSource::mkXmlDoc(configurationDomainsUri, true, true, xmlDomainImportContext);
    if (doc == nullptr) {
        return false;
    }

    return xmlParse(xmlDomainImportContext, pConfigurableDomains, doc, _xmlConfigurationUri,
                    EParameterConfigurationLibrary, true, &quot;SystemClassName&quot;);
}

// XML parsing
bool CParameterMgr::xmlParse(CXmlElementSerializingContext &amp;elementSerializingContext,
                             CElement *pRootElement, _xmlDoc *doc, const string &amp;baseUri,
                             CParameterMgr::ElementLibrary eElementLibrary, bool replace,
                             const string &amp;strNameAttributeName)
{
    // Init serializing context
    elementSerializingContext.set(_pElementLibrarySet-&gt;getElementLibrary(eElementLibrary), baseUri);

    CXmlDocSource docSource(doc, _bValidateSchemasOnStart, pRootElement-&gt;getXmlElementName(),
                            pRootElement-&gt;getName(), strNameAttributeName);

    docSource.setSchemaBaseUri(getSchemaUri());

    // Start clean
    auto clean = [replace, &amp;pRootElement] {
        if (replace) {
            pRootElement-&gt;clean();
        }
    };
    clean();

    CXmlMemoryDocSink memorySink(pRootElement);

    if (!memorySink.process(docSource, elementSerializingContext)) {
        clean();
        return false;
    }

    return true;
}

// Init
bool CParameterMgr::init(string &amp;strError)
{
    return base::init(strError);
}

// Selection criteria interface
CSelectionCriterionType *CParameterMgr::createSelectionCriterionType(bool bIsInclusive)
{
    // Propagate
    return getSelectionCriteria()-&gt;createSelectionCriterionType(bIsInclusive);
}

CSelectionCriterion *CParameterMgr::createSelectionCriterion(
    const string &amp;strName, const CSelectionCriterionType *pSelectionCriterionType)
{
    // Propagate
    return getSelectionCriteria()-&gt;createSelectionCriterion(strName, pSelectionCriterionType,
                                                            _logger);
}

// Selection criterion retrieval
CSelectionCriterion *CParameterMgr::getSelectionCriterion(const string &amp;strName)
{
    // Propagate
    return getSelectionCriteria()-&gt;getSelectionCriterion(strName);
}

// Configuration application
void CParameterMgr::applyConfigurations()
{
    LOG_CONTEXT(&quot;Configuration application request&quot;);

    // Lock state
    lock_guard&lt;mutex&gt; autoLock(getBlackboardMutex());

    if (!_bTuningModeIsOn) {

        // Apply configuration(s)
        doApplyConfigurations(false);
    } else {

        warning() &lt;&lt; &quot;Configurations were not applied because the TuningMode is on&quot;;
    }
}

const CConfigurableElement *CParameterMgr::getConfigurableElement(const string &amp;strPath,
                                                                  string &amp;strError) const
{
    CPathNavigator pathNavigator(strPath);

    // Nagivate through system class
    if (!pathNavigator.navigateThrough(getConstSystemClass()-&gt;getName(), strError)) {

        return nullptr;
    }

    // Find element
    const CElement *pElement = getConstSystemClass()-&gt;findDescendant(pathNavigator);

    if (!pElement) {

        strError = &quot;Path not found: &quot; + strPath;

        return nullptr;
    }

    // Check found element is a parameter
    const CConfigurableElement *pConfigurableElement =
        static_cast&lt;const CConfigurableElement *&gt;(pElement);

    return pConfigurableElement;
}

CConfigurableElement *CParameterMgr::getConfigurableElement(const string &amp;strPath, string &amp;strError)
{
    // Implement the mutable version by calling the const one and removing
    // the const from the result.
    const auto *constThis = this;
    return const_cast&lt;CConfigurableElement *&gt;(constThis-&gt;getConfigurableElement(strPath, strError));
}

// Dynamic parameter handling
CParameterHandle *CParameterMgr::createParameterHandle(const string &amp;strPath, string &amp;strError)
{
    CConfigurableElement *pConfigurableElement = getConfigurableElement(strPath, strError);

    if (!pConfigurableElement) {

        // Element not found
        strError = &quot;Element not found: &quot; + strPath;
        return nullptr;
    }

    if (!pConfigurableElement-&gt;isParameter()) {

        // Element is not parameter
        strError = &quot;Not a parameter: &quot; + strPath;

        return nullptr;
    }

    // Convert as parameter and return new handle
    return new CParameterHandle(static_cast&lt;CBaseParameter &amp;&gt;(*pConfigurableElement), *this);
}

// Dynamic element handling
ElementHandle *CParameterMgr::createElementHandle(const std::string &amp;path, std::string &amp;error)
{
    CConfigurableElement *pConfigurableElement;

    if (path == &quot;/&quot;) {
        // Attempt to access root configurable element
        pConfigurableElement = getSystemClass();
    } else {
        pConfigurableElement = getConfigurableElement(path, error);
    }

    if (!pConfigurableElement) {

        // Element not found
        error = &quot;Element not found: &quot; + path;
        return nullptr;
    }

    // The only reason why a heap object is returned instead of retuning by copy
    // is to inform the client of a failure through a nullptr.
    // It could be avoided (return by copy) with an
    //  - optional equivalent (see boost::optional or std::experimental::optional)
    //  - exception (but the api is noexcept)
    return new ElementHandle(*pConfigurableElement, *this);
}

void CParameterMgr::getSettingsAsBytes(const CConfigurableElement &amp;element,
                                       std::vector&lt;uint8_t&gt; &amp;settings) const
{
    // Not useful as the get can not fail,
    // but the current design forces all serialization and deserialization to
    // have an error out string
    std::string error;

    // Prepare parameter access context for main blackboard.
    // No need to handle output raw format and value space as Byte arrays are hexa formatted
    CParameterAccessContext parameterAccessContext(error);
    parameterAccessContext.setParameterBlackboard(_pMainParameterBlackboard);

    // Get the settings
    element.getSettingsAsBytes(settings, parameterAccessContext);
}

bool CParameterMgr::setSettingsAsBytes(const CConfigurableElement &amp;element,
                                       const std::vector&lt;uint8_t&gt; &amp;settings, std::string &amp;error)
{
    // Prepare parameter access context for main blackboard.
    // Notes:
    //     - No need to handle output raw format and value space as Byte arrays are interpreted as
    //     raw formatted
    //     - No check is done as to the intgrity of the input data.
    //       This may lead to undetected out of range value assignment.
    //       Use this functionality with caution
    CParameterAccessContext parameterAccessContext(error);
    parameterAccessContext.setParameterBlackboard(_pMainParameterBlackboard);
    parameterAccessContext.setAutoSync(autoSyncOn());

    // Set the settings
    return element.setSettingsAsBytes(settings, parameterAccessContext);
}

void CParameterMgr::setFailureOnMissingSubsystem(bool bFail)
{
    _bFailOnMissingSubsystem = bFail;
}

bool CParameterMgr::getFailureOnMissingSubsystem() const
{
    return _bFailOnMissingSubsystem;
}

void CParameterMgr::setFailureOnFailedSettingsLoad(bool bFail)
{
    _bFailOnFailedSettingsLoad = bFail;
}

bool CParameterMgr::getFailureOnFailedSettingsLoad() const
{
    return _bFailOnFailedSettingsLoad;
}

const string &amp;CParameterMgr::getSchemaUri() const
{
    return _schemaUri;
}

void CParameterMgr::setSchemaUri(const string &amp;schemaUri)
{
    _schemaUri = schemaUri;
}

void CParameterMgr::setValidateSchemasOnStart(bool bValidate)
{
    _bValidateSchemasOnStart = bValidate;
}

bool CParameterMgr::getValidateSchemasOnStart() const
{
    return _bValidateSchemasOnStart;
}

/////////////////// Remote command parsers
/// Version
CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::versionCommandProcess(
    const IRemoteCommand &amp; /*command*/, string &amp;strResult)
{
    // Show version
    strResult = getVersion();

    return CCommandHandler::ESucceeded;
}

/// Status
CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::statusCommandProcess(
    const IRemoteCommand &amp; /*command*/, string &amp;strResult)
{
    // System class
    const CSystemClass *pSystemClass = getSystemClass();

    // Show status
    /// General section
    utility::appendTitle(strResult, &quot;General:&quot;);
    // System class
    strResult += &quot;System Class: &quot;;
    strResult += pSystemClass-&gt;getName();
    strResult += &quot;\n&quot;;

    // Tuning mode
    strResult += &quot;Tuning Mode: &quot;;
    strResult += tuningModeOn() ? &quot;on&quot; : &quot;off&quot;;
    strResult += &quot;\n&quot;;

    // Value space
    strResult += &quot;Value Space: &quot;;
    strResult += valueSpaceIsRaw() ? &quot;raw&quot; : &quot;real&quot;;
    strResult += &quot;\n&quot;;

    // Output raw format
    strResult += &quot;Output Raw Format: &quot;;
    strResult += outputRawFormatIsHex() ? &quot;hex&quot; : &quot;dec&quot;;
    strResult += &quot;\n&quot;;

    // Auto Sync
    strResult += &quot;Auto Sync: &quot;;
    strResult += autoSyncOn() ? &quot;on&quot; : &quot;off&quot;;
    strResult += &quot;\n&quot;;

    /// Subsystem list
    utility::appendTitle(strResult, &quot;Subsystems:&quot;);
    string strSubsystemList;
    pSystemClass-&gt;listChildrenPaths(strSubsystemList);
    strResult += strSubsystemList;

    /// Last applied configurations
    utility::appendTitle(strResult, &quot;Last Applied [Pending] Configurations:&quot;);
    string strLastAppliedConfigurations;
    getConfigurableDomains()-&gt;listLastAppliedConfigurations(strLastAppliedConfigurations);
    strResult += strLastAppliedConfigurations;

    /// Criteria states
    utility::appendTitle(strResult, &quot;Selection Criteria:&quot;);
    list&lt;string&gt; lstrSelectionCriteria;
    getSelectionCriteria()-&gt;listSelectionCriteria(lstrSelectionCriteria, false, true);
    // Concatenate the criterion list as the command result
    strResult += utility::asString(lstrSelectionCriteria);

    return CCommandHandler::ESucceeded;
}

/// Tuning Mode
CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::setTuningModeCommandProcess(
    const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    if (remoteCommand.getArgument(0) == &quot;on&quot;) {

        if (setTuningMode(true, strResult)) {

            return CCommandHandler::EDone;
        }
    } else if (remoteCommand.getArgument(0) == &quot;off&quot;) {

        if (setTuningMode(false, strResult)) {

            return CCommandHandler::EDone;
        }
    } else {
        // Show usage
        return CCommandHandler::EShowUsage;
    }
    return CCommandHandler::EFailed;
}

CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::getTuningModeCommandProcess(
    const IRemoteCommand &amp; /*command*/, string &amp;strResult)
{
    strResult = tuningModeOn() ? &quot;on&quot; : &quot;off&quot;;

    return CCommandHandler::ESucceeded;
}

/// Value Space
CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::setValueSpaceCommandProcess(
    const IRemoteCommand &amp;remoteCommand, string &amp; /*strResult*/)
{
    if (remoteCommand.getArgument(0) == &quot;raw&quot;) {

        setValueSpace(true);

        return CCommandHandler::EDone;

    } else if (remoteCommand.getArgument(0) == &quot;real&quot;) {

        setValueSpace(false);

        return CCommandHandler::EDone;

    } else {
        // Show usage
        return CCommandHandler::EShowUsage;
    }
    return CCommandHandler::EFailed;
}

CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::getValueSpaceCommandProcess(
    const IRemoteCommand &amp; /*command*/, string &amp;strResult)
{
    strResult = valueSpaceIsRaw() ? &quot;raw&quot; : &quot;real&quot;;

    return CCommandHandler::ESucceeded;
}

/// Output Raw Format
CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::setOutputRawFormatCommandProcess(
    const IRemoteCommand &amp;remoteCommand, string &amp; /*strResult*/)
{
    if (remoteCommand.getArgument(0) == &quot;hex&quot;) {

        setOutputRawFormat(true);

        return CCommandHandler::EDone;

    } else if (remoteCommand.getArgument(0) == &quot;dec&quot;) {

        setOutputRawFormat(false);

        return CCommandHandler::EDone;

    } else {
        // Show usage
        return CCommandHandler::EShowUsage;
    }
    return CCommandHandler::EFailed;
}

CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::getOutputRawFormatCommandProcess(
    const IRemoteCommand &amp; /*command*/, string &amp;strResult)
{
    strResult = outputRawFormatIsHex() ? &quot;hex&quot; : &quot;dec&quot;;

    return CCommandHandler::ESucceeded;
}

/// Sync
CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::setAutoSyncCommandProcess(
    const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    if (remoteCommand.getArgument(0) == &quot;on&quot;) {

        if (setAutoSync(true, strResult)) {

            return CCommandHandler::EDone;
        }
    } else if (remoteCommand.getArgument(0) == &quot;off&quot;) {

        if (setAutoSync(false, strResult)) {

            return CCommandHandler::EDone;
        }
    } else {
        // Show usage
        return CCommandHandler::EShowUsage;
    }
    return CCommandHandler::EFailed;
}

CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::getAutoSyncCommandProcess(
    const IRemoteCommand &amp; /*command*/, string &amp;strResult)
{
    strResult = autoSyncOn() ? &quot;on&quot; : &quot;off&quot;;

    return CCommandHandler::ESucceeded;
}

CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::syncCommandProcess(
    const IRemoteCommand &amp;, string &amp;strResult)
{
    return sync(strResult) ? CCommandHandler::EDone : CCommandHandler::EFailed;
}

/// Criteria
CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::listCriteriaCommandProcess(
    const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    if (remoteCommand.getArgumentCount() &gt; 1) {

        return CCommandHandler::EShowUsage;
    }

    string strOutputFormat;

    // Look for optional arguments
    if (remoteCommand.getArgumentCount() == 1) {

        // Get requested format
        strOutputFormat = remoteCommand.getArgument(0);

        // Capitalize
        std::transform(strOutputFormat.begin(), strOutputFormat.end(), strOutputFormat.begin(),
                       ::toupper);

        if (strOutputFormat != &quot;XML&quot; &amp;&amp; strOutputFormat != &quot;CSV&quot;) {

            return CCommandHandler::EShowUsage;
        }
    }

    if (strOutputFormat == &quot;XML&quot;) {
        // Get Root element where to export from
        const CSelectionCriteriaDefinition *pSelectionCriteriaDefinition =
            getConstSelectionCriteria()-&gt;getSelectionCriteriaDefinition();

        if (!exportElementToXMLString(pSelectionCriteriaDefinition, &quot;SelectionCriteria&quot;,
                                      CXmlSerializingContext{strResult}, strResult)) {

            return CCommandHandler::EFailed;
        }

        // Succeeded
        return CCommandHandler::ESucceeded;
    } else {

        // Requested format will be either CSV or human readable based on strOutputFormat content
        bool bHumanReadable = strOutputFormat.empty();

        list&lt;string&gt; lstrResult;
        getSelectionCriteria()-&gt;listSelectionCriteria(lstrResult, true, bHumanReadable);

        // Concatenate the criterion list as the command result
        strResult += utility::asString(lstrResult);

        return CCommandHandler::ESucceeded;
    }
}

/// Domains
CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::listDomainsCommandProcess(
    const IRemoteCommand &amp; /*command*/, string &amp;strResult)
{
    getConfigurableDomains()-&gt;listDomains(strResult);

    return CCommandHandler::ESucceeded;
}

CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::createDomainCommandProcess(
    const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    return createDomain(remoteCommand.getArgument(0), strResult) ? CCommandHandler::EDone
                                                                 : CCommandHandler::EFailed;
}

CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::deleteDomainCommandProcess(
    const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    return deleteDomain(remoteCommand.getArgument(0), strResult) ? CCommandHandler::EDone
                                                                 : CCommandHandler::EFailed;
}

CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::deleteAllDomainsCommandProcess(
    const IRemoteCommand &amp; /*command*/, string &amp;strResult)
{
    return deleteAllDomains(strResult) ? CCommandHandler::EDone : CCommandHandler::EFailed;
}

CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::renameDomainCommandProcess(
    const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    return renameDomain(remoteCommand.getArgument(0), remoteCommand.getArgument(1), strResult)
               ? CCommandHandler::EDone
               : CCommandHandler::EFailed;
}

CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::setSequenceAwarenessCommandProcess(
    const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    // Set property
    bool bSequenceAware;

    if (remoteCommand.getArgument(1) == &quot;true&quot;) {

        bSequenceAware = true;

    } else if (remoteCommand.getArgument(1) == &quot;false&quot;) {

        bSequenceAware = false;

    } else {
        // Show usage
        return CCommandHandler::EShowUsage;
    }

    return setSequenceAwareness(remoteCommand.getArgument(0), bSequenceAware, strResult)
               ? CCommandHandler::EDone
               : CCommandHandler::EFailed;
}

CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::getSequenceAwarenessCommandProcess(
    const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    // Get property
    bool bSequenceAware;

    if (!getSequenceAwareness(remoteCommand.getArgument(0), bSequenceAware, strResult)) {

        return CCommandHandler::EFailed;
    }

    strResult = bSequenceAware ? &quot;true&quot; : &quot;false&quot;;

    return CCommandHandler::ESucceeded;
}

CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::listDomainElementsCommandProcess(
    const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    return getConfigurableDomains()-&gt;listDomainElements(remoteCommand.getArgument(0), strResult)
               ? CCommandHandler::ESucceeded
               : CCommandHandler::EFailed;
}

CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::addElementCommandProcess(
    const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    return addConfigurableElementToDomain(remoteCommand.getArgument(0),
                                          remoteCommand.getArgument(1), strResult)
               ? CCommandHandler::EDone
               : CCommandHandler::EFailed;
}

CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::removeElementCommandProcess(
    const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    return removeConfigurableElementFromDomain(remoteCommand.getArgument(0),
                                               remoteCommand.getArgument(1), strResult)
               ? CCommandHandler::EDone
               : CCommandHandler::EFailed;
}

CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::splitDomainCommandProcess(
    const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    return split(remoteCommand.getArgument(0), remoteCommand.getArgument(1), strResult)
               ? CCommandHandler::EDone
               : CCommandHandler::EFailed;
}

/// Configurations
CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::listConfigurationsCommandProcess(
    const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    return getConstConfigurableDomains()-&gt;listConfigurations(remoteCommand.getArgument(0),
                                                             strResult)
               ? CCommandHandler::ESucceeded
               : CCommandHandler::EFailed;
}

CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::dumpDomainsCommandProcess(
    const IRemoteCommand &amp; /*command*/, string &amp;strResult)
{
    // Dummy error context
    string strError;
    utility::ErrorContext errorContext(strError);

    // Dump
    strResult = getConstConfigurableDomains()-&gt;dumpContent(errorContext);

    return CCommandHandler::ESucceeded;
}

CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::createConfigurationCommandProcess(
    const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    return createConfiguration(remoteCommand.getArgument(0), remoteCommand.getArgument(1),
                               strResult)
               ? CCommandHandler::EDone
               : CCommandHandler::EFailed;
}

CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::deleteConfigurationCommandProcess(
    const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    return deleteConfiguration(remoteCommand.getArgument(0), remoteCommand.getArgument(1),
                               strResult)
               ? CCommandHandler::EDone
               : CCommandHandler::EFailed;
}

CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::renameConfigurationCommandProcess(
    const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    return renameConfiguration(remoteCommand.getArgument(0), remoteCommand.getArgument(1),
                               remoteCommand.getArgument(2), strResult)
               ? CCommandHandler::EDone
               : CCommandHandler::EFailed;
}

CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::saveConfigurationCommandProcess(
    const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    return saveConfiguration(remoteCommand.getArgument(0), remoteCommand.getArgument(1), strResult)
               ? CCommandHandler::EDone
               : CCommandHandler::EFailed;
}

CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::restoreConfigurationCommandProcess(
    const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    core::Results result;
    if (!restoreConfiguration(remoteCommand.getArgument(0), remoteCommand.getArgument(1), result)) {
        // Concatenate the error list as the command result
        strResult = utility::asString(result);

        return CCommandHandler::EFailed;
    }
    return CCommandHandler::EDone;
}

CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::setElementSequenceCommandProcess(
    const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    // Build configurable element path list
    std::vector&lt;string&gt; astrNewElementSequence;

    for (size_t argument = 2; argument &lt; remoteCommand.getArgumentCount(); argument++) {

        astrNewElementSequence.push_back(remoteCommand.getArgument(argument));
    }

    // Delegate to configurable domains
    return setElementSequence(remoteCommand.getArgument(0), remoteCommand.getArgument(1),
                              astrNewElementSequence, strResult)
               ? CCommandHandler::EDone
               : CCommandHandler::EFailed;
}

CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::getElementSequenceCommandProcess(
    const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    // Delegate to configurable domains
    return getConfigurableDomains()-&gt;getElementSequence(remoteCommand.getArgument(0),
                                                        remoteCommand.getArgument(1), strResult)
               ? CCommandHandler::ESucceeded
               : CCommandHandler::EFailed;
}

CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::setRuleCommandProcess(
    const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    // Delegate to configurable domains
    return setApplicationRule(remoteCommand.getArgument(0), remoteCommand.getArgument(1),
                              remoteCommand.packArguments(2, remoteCommand.getArgumentCount() - 2),
                              strResult)
               ? CCommandHandler::EDone
               : CCommandHandler::EFailed;
}

CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::clearRuleCommandProcess(
    const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    // Delegate to configurable domains
    return clearApplicationRule(remoteCommand.getArgument(0), remoteCommand.getArgument(1),
                                strResult)
               ? CCommandHandler::EDone
               : CCommandHandler::EFailed;
}

CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::getRuleCommandProcess(
    const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    // Delegate to configurable domains
    return getApplicationRule(remoteCommand.getArgument(0), remoteCommand.getArgument(1), strResult)
               ? CCommandHandler::ESucceeded
               : CCommandHandler::EFailed;
}

/// Elements/Parameters
CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::listElementsCommandProcess(
    const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    CElementLocator elementLocator(getSystemClass(), false);

    CElement *pLocatedElement = nullptr;

    if (!elementLocator.locate(remoteCommand.getArgument(0), &amp;pLocatedElement, strResult)) {

        return CCommandHandler::EFailed;
    }

    if (!pLocatedElement) {

        // List from root folder

        // Return system class qualified name
        pLocatedElement = getSystemClass();
    }

    // Return sub-elements
    strResult += pLocatedElement-&gt;listQualifiedPaths(false);

    return CCommandHandler::ESucceeded;
}

/// Elements/Parameters
CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::listParametersCommandProcess(
    const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    CElementLocator elementLocator(getSystemClass(), false);

    CElement *pLocatedElement = nullptr;

    if (!elementLocator.locate(remoteCommand.getArgument(0), &amp;pLocatedElement, strResult)) {

        return CCommandHandler::EFailed;
    }

    if (!pLocatedElement) {

        // List from root folder

        // Return system class qualified name
        pLocatedElement = getSystemClass();
    }

    // Return sub-elements
    strResult += pLocatedElement-&gt;listQualifiedPaths(true);

    return CCommandHandler::ESucceeded;
}

CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::getElementStructureXMLCommandProcess(
    const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    CElementLocator elementLocator(getSystemClass());

    CElement *pLocatedElement = nullptr;

    if (!elementLocator.locate(remoteCommand.getArgument(0), &amp;pLocatedElement, strResult)) {

        return CCommandHandler::EFailed;
    }

    // Use default access context for structure export
    CParameterAccessContext accessContext(strResult);
    if (!exportElementToXMLString(pLocatedElement, pLocatedElement-&gt;getXmlElementName(),
                                  CXmlParameterSerializingContext{accessContext, strResult},
                                  strResult)) {

        return CCommandHandler::EFailed;
    }

    return CCommandHandler::ESucceeded;
}

CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::getElementBytesCommandProcess(
    const IRemoteCommand &amp;remoteCommand, std::string &amp;strResult)
{
    CElementLocator elementLocator(getSystemClass());

    CElement *pLocatedElement = nullptr;

    if (!elementLocator.locate(remoteCommand.getArgument(0), &amp;pLocatedElement, strResult)) {

        return CCommandHandler::EFailed;
    }

    const CConfigurableElement *pConfigurableElement =
        static_cast&lt;CConfigurableElement *&gt;(pLocatedElement);

    // Get the settings
    vector&lt;uint8_t&gt; bytes;
    getSettingsAsBytes(*pConfigurableElement, bytes);

    // Hexa formatting
    std::ostringstream ostream;
    ostream &lt;&lt; std::hex &lt;&lt; std::setfill('0');

    // Format bytes
    for (auto byte : bytes) {

        // Convert to an int in order to avoid the &quot;char&quot; overload that would
        // print characters instead of numbers.
        ostream &lt;&lt; &quot;0x&quot; &lt;&lt; std::setw(2) &lt;&lt; int{byte} &lt;&lt; &quot; &quot;;
    }

    strResult = ostream.str();
    if (not strResult.empty()) {
        // Remove the trailing space
        strResult.pop_back();
    }

    return CCommandHandler::ESucceeded;
}

CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::setElementBytesCommandProcess(
    const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    // Check tuning mode
    if (!checkTuningModeOn(strResult)) {

        return CCommandHandler::EFailed;
    }

    // Retrieve configurable element
    CElementLocator elementLocator(getSystemClass());

    CElement *pLocatedElement = nullptr;

    if (!elementLocator.locate(remoteCommand.getArgument(0), &amp;pLocatedElement, strResult)) {

        return CCommandHandler::EFailed;
    }

    const CConfigurableElement *pConfigurableElement =
        static_cast&lt;CConfigurableElement *&gt;(pLocatedElement);

    // Convert input data to binary
    vector&lt;uint8_t&gt; bytes;

    auto first = remoteCommand.getArguments().cbegin() + 1;
    auto last = remoteCommand.getArguments().cend();

    try {
        std::transform(first, last, begin(bytes), [](decltype(*first) input) {
            uint8_t byte;

            if (!convertTo(input, byte)) {
                throw std::domain_error(&quot;Some values out of byte range&quot;);
            }

            return byte;
        });
    } catch (const std::domain_error &amp;e) {
        strResult = e.what();

        return CCommandHandler::EFailed;
    }

    // Set the settings
    if (!setSettingsAsBytes(*pConfigurableElement, bytes, strResult)) {

        return CCommandHandler::EFailed;
    }

    return CCommandHandler::EDone;
}

bool CParameterMgr::getSettingsAsXML(const CConfigurableElement *configurableElement,
                                     string &amp;result) const
{
    string error;
    CConfigurationAccessContext configContext(error, _pMainParameterBlackboard, _bValueSpaceIsRaw,
                                              _bOutputRawFormatIsHex, true);

    CXmlParameterSerializingContext xmlParameterContext(configContext, error);

    // Use a doc source by loading data from instantiated Configurable Domains
    CXmlMemoryDocSource memorySource(configurableElement, false,
                                     configurableElement-&gt;getXmlElementName());

    // Use a doc sink that write the doc data in a string
    ostringstream output;
    CXmlStreamDocSink streamSink(output);

    if (not streamSink.process(memorySource, xmlParameterContext)) {
        result = error;
        return false;
    }
    result = output.str();
    return true;
}

bool CParameterMgr::setSettingsAsXML(CConfigurableElement *configurableElement,
                                     const string &amp;settings, string &amp;error)
{
    CConfigurationAccessContext configContext(error, _pMainParameterBlackboard, _bValueSpaceIsRaw,
                                              _bOutputRawFormatIsHex, false);

    CXmlParameterSerializingContext xmlParameterContext(configContext, error);

    // It doesn't make sense to resolve XIncludes on an imported file because
    // we can't reliably decide of a &quot;base url&quot;
    _xmlDoc *doc = CXmlDocSource::mkXmlDoc(settings, false, false, xmlParameterContext);
    if (doc == nullptr) {
        return false;
    }
    if (not xmlParse(xmlParameterContext, configurableElement, doc, &quot;&quot;,
                     EParameterConfigurationLibrary, false)) {
        return false;
    }
    if (_bAutoSyncOn) {
        CSyncerSet syncerSet;
        static_cast&lt;CConfigurableElement *&gt;(configurableElement)-&gt;fillSyncerSet(syncerSet);
        core::Results errors;
        if (not syncerSet.sync(*_pMainParameterBlackboard, false, &amp;errors)) {
            error = utility::asString(errors);

            return false;
        }
    }
    return true;
}

CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::getElementXMLCommandProcess(
    const IRemoteCommand &amp;remoteCommand, string &amp;result)
{
    CElementLocator elementLocator(getSystemClass());

    CElement *locatedElement = nullptr;

    if (not elementLocator.locate(remoteCommand.getArgument(0), &amp;locatedElement, result)) {

        return CCommandHandler::EFailed;
    }

    if (not getSettingsAsXML(static_cast&lt;CConfigurableElement *&gt;(locatedElement), result)) {
        return CCommandHandler::EFailed;
    }
    return CCommandHandler::ESucceeded;
}

CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::setElementXMLCommandProcess(
    const IRemoteCommand &amp;remoteCommand, string &amp;result)
{
    if (!checkTuningModeOn(result)) {

        return CCommandHandler::EFailed;
    }

    CElementLocator elementLocator(getSystemClass());

    CElement *locatedElement = nullptr;

    if (not elementLocator.locate(remoteCommand.getArgument(0), &amp;locatedElement, result)) {

        return CCommandHandler::EFailed;
    }
    if (not setSettingsAsXML(static_cast&lt;CConfigurableElement *&gt;(locatedElement),
                             remoteCommand.getArgument(1), result)) {
        return CCommandHandler::EFailed;
    }
    return CCommandHandler::EDone;
}

CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::dumpElementCommandProcess(
    const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    CElementLocator elementLocator(getSystemClass());

    CElement *pLocatedElement = nullptr;

    if (!elementLocator.locate(remoteCommand.getArgument(0), &amp;pLocatedElement, strResult)) {

        return CCommandHandler::EFailed;
    }

    string strError;

    CParameterAccessContext parameterAccessContext(strError, _pMainParameterBlackboard,
                                                   _bValueSpaceIsRaw, _bOutputRawFormatIsHex);

    // Dump elements
    strResult = pLocatedElement-&gt;dumpContent(parameterAccessContext);

    return CCommandHandler::ESucceeded;
}

CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::getElementSizeCommandProcess(
    const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    CElementLocator elementLocator(getSystemClass());

    CElement *pLocatedElement = nullptr;

    if (!elementLocator.locate(remoteCommand.getArgument(0), &amp;pLocatedElement, strResult)) {

        return CCommandHandler::EFailed;
    }

    // Converted to actual sizable element
    const CConfigurableElement *pConfigurableElement =
        static_cast&lt;const CConfigurableElement *&gt;(pLocatedElement);

    // Get size as string
    strResult = pConfigurableElement-&gt;getFootprintAsString();

    return CCommandHandler::ESucceeded;
}

CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::showPropertiesCommandProcess(
    const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    CElementLocator elementLocator(getSystemClass());

    CElement *pLocatedElement = nullptr;

    if (!elementLocator.locate(remoteCommand.getArgument(0), &amp;pLocatedElement, strResult)) {

        return CCommandHandler::EFailed;
    }

    // Convert element
    const CConfigurableElement *pConfigurableElement =
        static_cast&lt;const CConfigurableElement *&gt;(pLocatedElement);

    // Return element properties
    pConfigurableElement-&gt;showProperties(strResult);

    return CCommandHandler::ESucceeded;
}

CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::getParameterCommandProcess(
    const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    string strValue;

    if (!accessParameterValue(remoteCommand.getArgument(0), strValue, false, strResult)) {

        return CCommandHandler::EFailed;
    }
    // Succeeded
    strResult = strValue;

    return CCommandHandler::ESucceeded;
}

CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::setParameterCommandProcess(
    const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    // Get value to set
    string strValue = remoteCommand.packArguments(1, remoteCommand.getArgumentCount() - 1);

    return accessParameterValue(remoteCommand.getArgument(0), strValue, true, strResult)
               ? CCommandHandler::EDone
               : CCommandHandler::EFailed;
}

CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::listBelongingDomainsCommandProcess(
    const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    CElementLocator elementLocator(getSystemClass());

    CElement *pLocatedElement = nullptr;

    if (!elementLocator.locate(remoteCommand.getArgument(0), &amp;pLocatedElement, strResult)) {

        return CCommandHandler::EFailed;
    }

    // Convert element
    const CConfigurableElement *pConfigurableElement =
        static_cast&lt;const CConfigurableElement *&gt;(pLocatedElement);

    // Return element belonging domains
    pConfigurableElement-&gt;listBelongingDomains(strResult);

    return CCommandHandler::ESucceeded;
}

CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::listAssociatedDomainsCommandProcess(
    const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    CElementLocator elementLocator(getSystemClass());

    CElement *pLocatedElement = nullptr;

    if (!elementLocator.locate(remoteCommand.getArgument(0), &amp;pLocatedElement, strResult)) {

        return CCommandHandler::EFailed;
    }

    // Convert element
    const CConfigurableElement *pConfigurableElement =
        static_cast&lt;const CConfigurableElement *&gt;(pLocatedElement);

    // Return element belonging domains
    pConfigurableElement-&gt;listAssociatedDomains(strResult);

    return CCommandHandler::ESucceeded;
}

CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::listAssociatedElementsCommandProcess(
    const IRemoteCommand &amp; /*command*/, string &amp;strResult)
{
    getConfigurableDomains()-&gt;listAssociatedElements(strResult);

    return CCommandHandler::ESucceeded;
}

CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::listConflictingElementsCommandProcess(
    const IRemoteCommand &amp; /*command*/, string &amp;strResult)
{
    getConfigurableDomains()-&gt;listConflictingElements(strResult);

    return CCommandHandler::ESucceeded;
}

CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::listRogueElementsCommandProcess(
    const IRemoteCommand &amp; /*command*/, string &amp;strResult)
{
    getSystemClass()-&gt;listRogueElements(strResult);

    return CCommandHandler::ESucceeded;
}

CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::
    getConfigurationParameterCommandProcess(const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    string strOutputValue;
    string strError;

    if (!accessConfigurationValue(remoteCommand.getArgument(0), remoteCommand.getArgument(1),
                                  remoteCommand.getArgument(2), strOutputValue, false, strError)) {

        strResult = strError;
        return CCommandHandler::EFailed;
    }
    // Succeeded
    strResult = strOutputValue;

    return CCommandHandler::ESucceeded;
}

CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::
    setConfigurationParameterCommandProcess(const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    // Get value to set
    string strValue = remoteCommand.packArguments(3, remoteCommand.getArgumentCount() - 3);

    bool bSuccess =
        accessConfigurationValue(remoteCommand.getArgument(0), remoteCommand.getArgument(1),
                                 remoteCommand.getArgument(2), strValue, true, strResult);

    return bSuccess ? CCommandHandler::EDone : CCommandHandler::EFailed;
}

CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::showMappingCommandProcess(
    const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    if (!getParameterMapping(remoteCommand.getArgument(0), strResult)) {

        return CCommandHandler::EFailed;
    }

    return CCommandHandler::ESucceeded;
}

/// Settings Import/Export
CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::exportDomainsXMLCommandProcess(
    const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    string strFileName = remoteCommand.getArgument(0);
    return exportDomainsXml(strFileName, false, true, strResult) ? CCommandHandler::EDone
                                                                 : CCommandHandler::EFailed;
}

CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::importDomainsXMLCommandProcess(
    const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    return importDomainsXml(remoteCommand.getArgument(0), false, true, strResult)
               ? CCommandHandler::EDone
               : CCommandHandler::EFailed;
}

CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::
    exportDomainsWithSettingsXMLCommandProcess(const IRemoteCommand &amp;remoteCommand,
                                               string &amp;strResult)
{
    string strFileName = remoteCommand.getArgument(0);
    return exportDomainsXml(strFileName, true, true, strResult) ? CCommandHandler::EDone
                                                                : CCommandHandler::EFailed;
}

CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::
    exportDomainWithSettingsXMLCommandProcess(const IRemoteCommand &amp;remoteCommand, string &amp;result)
{
    string domainName = remoteCommand.getArgument(0);
    string fileName = remoteCommand.getArgument(1);
    return exportSingleDomainXml(fileName, domainName, true, true, result)
               ? CCommandHandler::EDone
               : CCommandHandler::EFailed;
}

CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::
    importDomainsWithSettingsXMLCommandProcess(const IRemoteCommand &amp;remoteCommand,
                                               string &amp;strResult)
{
    return importDomainsXml(remoteCommand.getArgument(0), true, true, strResult)
               ? CCommandHandler::EDone
               : CCommandHandler::EFailed;
}

CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::
    importDomainWithSettingsXMLCommandProcess(const IRemoteCommand &amp;remoteCommand,
                                              string &amp;strResult)
{
    bool bOverwrite = false;

    // Look for optional arguments
    if (remoteCommand.getArgumentCount() &gt; 1) {

        if (remoteCommand.getArgument(1) == &quot;overwrite&quot;) {

            bOverwrite = true;
        } else {
            // Show usage
            return CCommandHandler::EShowUsage;
        }
    }

    return importSingleDomainXml(remoteCommand.getArgument(0), bOverwrite, true, true, strResult)
               ? CCommandHandler::EDone
               : CCommandHandler::EFailed;
}

CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::
    getDomainsWithSettingsXMLCommandProcess(const IRemoteCommand &amp; /*command*/, string &amp;strResult)
{
    if (!exportDomainsXml(strResult, true, false, strResult)) {

        return CCommandHandler::EFailed;
    }
    // Succeeded
    return CCommandHandler::ESucceeded;
}

CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::getDomainWithSettingsXMLCommandProcess(
    const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    string strDomainName = remoteCommand.getArgument(0);

    return exportSingleDomainXml(strResult, strDomainName, true, false, strResult)
               ? CCommandHandler::ESucceeded
               : CCommandHandler::EFailed;
}

CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::
    setDomainsWithSettingsXMLCommandProcess(const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    return importDomainsXml(remoteCommand.getArgument(0), true, false, strResult)
               ? CCommandHandler::EDone
               : CCommandHandler::EFailed;
}

CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::setDomainWithSettingsXMLCommandProcess(
    const IRemoteCommand &amp;remoteCommand, string &amp;result)
{
    bool overwrite = false;

    if (remoteCommand.getArgumentCount() &gt; 1) {

        if (remoteCommand.getArgument(1) == &quot;overwrite&quot;) {

            overwrite = true;
        } else {
            // Show usage
            return CCommandHandler::EShowUsage;
        }
    }

    return importSingleDomainXml(remoteCommand.getArgument(0), overwrite, true, false, result)
               ? CCommandHandler::EDone
               : CCommandHandler::EFailed;
}

CParameterMgr::CCommandHandler::CommandStatus CParameterMgr::getSystemClassXMLCommandProcess(
    const IRemoteCommand &amp; /*command*/, string &amp;strResult)
{
    // Get Root element where to export from
    const CSystemClass *pSystemClass = getSystemClass();

    // Use default access context for structure export
    CParameterAccessContext accessContext(strResult);
    if (!exportElementToXMLString(pSystemClass, pSystemClass-&gt;getXmlElementName(),
                                  CXmlParameterSerializingContext{accessContext, strResult},
                                  strResult)) {
        return CCommandHandler::EFailed;
    }
    // Succeeded
    return CCommandHandler::ESucceeded;
}

// User set/get parameters in main BlackBoard
bool CParameterMgr::accessParameterValue(const string &amp;strPath, string &amp;strValue, bool bSet,
                                         string &amp;strError)
{
    // Forbid write access when not in TuningMode
    if (bSet &amp;&amp; !checkTuningModeOn(strError)) {

        return false;
    }

    // Define context
    CParameterAccessContext parameterAccessContext(strError, _pMainParameterBlackboard,
                                                   _bValueSpaceIsRaw, _bOutputRawFormatIsHex);

    // Activate the auto synchronization with the hardware
    if (bSet) {

        parameterAccessContext.setAutoSync(_bAutoSyncOn);
    }

    return accessValue(parameterAccessContext, strPath, strValue, bSet, strError);
}

// User get parameter mapping
bool CParameterMgr::getParameterMapping(const string &amp;strPath, string &amp;strResult) const
{
    // Get the ConfigurableElement corresponding to strPath
    const CConfigurableElement *pConfigurableElement = getConfigurableElement(strPath, strResult);
    if (!pConfigurableElement) {

        return false;
    }

    // Find the list of the ancestors of the current ConfigurableElement that have a mapping
    auto configurableElementPath = pConfigurableElement-&gt;getConfigurableElementContext();

    // Get the Subsystem containing the ConfigurableElement
    const CSubsystem *pSubsystem = pConfigurableElement-&gt;getBelongingSubsystem();
    if (!pSubsystem) {

        strResult = &quot;Unable to find the Subsystem containing the parameter&quot;;
        return false;
    }

    // Fetch the mapping corresponding to the ConfigurableElement
    strResult = pSubsystem-&gt;getMapping(configurableElementPath);

    return true;
}

// User set/get parameters in specific Configuration BlackBoard
bool CParameterMgr::accessConfigurationValue(const string &amp;strDomain,
                                             const string &amp;strConfiguration, const string &amp;strPath,
                                             string &amp;strValue, bool bSet, string &amp;strError)
{
    CElementLocator elementLocator(getSystemClass());

    CElement *pLocatedElement = nullptr;

    if (!elementLocator.locate(strPath, &amp;pLocatedElement, strError)) {

        return false;
    }

    // Convert element
    const CConfigurableElement *pConfigurableElement =
        static_cast&lt;const CConfigurableElement *&gt;(pLocatedElement);

    // Get the Configuration blackboard and the Base Offset of the configurable element in this
    // blackboard
    size_t baseOffset;
    bool bIsLastApplied;

    CParameterBlackboard *pConfigurationBlackboard = nullptr;

    {
        pConfigurationBlackboard = getConstConfigurableDomains()-&gt;findConfigurationBlackboard(
            strDomain, strConfiguration, pConfigurableElement, baseOffset, bIsLastApplied,
            strError);
        if (!pConfigurationBlackboard) {

            warning() &lt;&lt; &quot;Fail: &quot; &lt;&lt; strError;
            return false;
        }
    }

    info() &lt;&lt; &quot;Element &quot; &lt;&lt; strPath &lt;&lt; &quot; in Domain &quot; &lt;&lt; strDomain
           &lt;&lt; &quot;, offset: &quot; &lt;&lt; pConfigurableElement-&gt;getOffset() &lt;&lt; &quot;, base offset: &quot; &lt;&lt; baseOffset;

    /// Update the Configuration Blackboard

    // Define Configuration context using Base Offset and keep Auto Sync off to prevent access to HW
    CParameterAccessContext parameterAccessContext(
        strError, pConfigurationBlackboard, _bValueSpaceIsRaw, _bOutputRawFormatIsHex, baseOffset);

    // Deactivate the auto synchronization with the hardware during the Configuration Blackboard
    // access (only Main Blackboard shall be synchronized, Configurations Blackboards are copied
    // into the Main Blackboard each time a configuration is restored but they are not synchronized
    // directly).
    if (bSet) {

        parameterAccessContext.setAutoSync(false);
    }

    // Access Value in the Configuration Blackboard
    if (!accessValue(parameterAccessContext, strPath, strValue, bSet, strError)) {

        return false;
    }

    /// If the Configuration is the last one applied, update the Main Blackboard as well

    if (bIsLastApplied) {

        // Define Main context
        parameterAccessContext.setParameterBlackboard(_pMainParameterBlackboard);

        // Activate the auto synchronization with the hardware
        if (bSet) {

            parameterAccessContext.setAutoSync(_bAutoSyncOn);
        }

        // Access Value in the Main Blackboard
        return accessValue(parameterAccessContext, strPath, strValue, bSet, strError);
    }

    return true;
}

// User set/get parameters
bool CParameterMgr::accessValue(CParameterAccessContext &amp;parameterAccessContext,
                                const string &amp;strPath, string &amp;strValue, bool bSet,
                                string &amp;strError)
{
    // Lock state
    lock_guard&lt;mutex&gt; autoLock(getBlackboardMutex());

    CPathNavigator pathNavigator(strPath);

    // Nagivate through system class
    if (!pathNavigator.navigateThrough(getConstSystemClass()-&gt;getName(), strError)) {

        parameterAccessContext.setError(strError);

        return false;
    }

    // Do the get
    return getConstSystemClass()-&gt;accessValue(pathNavigator, strValue, bSet,
                                              parameterAccessContext);
}

// Tuning mode
bool CParameterMgr::setTuningMode(bool bOn, string &amp;strError)
{
    if (bOn == tuningModeOn()) {
        strError = &quot;Tuning mode is already in the state requested&quot;;
        return false;
    }
    // Tuning allowed?
    if (bOn &amp;&amp; !getConstFrameworkConfiguration()-&gt;isTuningAllowed()) {

        strError = &quot;Tuning prohibited&quot;;

        return false;
    }
    // Lock state
    lock_guard&lt;mutex&gt; autoLock(getBlackboardMutex());

    // Warn domains about exiting tuning mode
    if (!bOn) {

        // Ensure application of currently selected configurations
        // Force-apply configurations
        doApplyConfigurations(true);
    }

    // Store
    _bTuningModeIsOn = bOn;

    return true;
}

bool CParameterMgr::tuningModeOn() const
{
    return _bTuningModeIsOn;
}

// Current value space for user set/get value interpretation
void CParameterMgr::setValueSpace(bool bIsRaw)
{
    _bValueSpaceIsRaw = bIsRaw;
}

bool CParameterMgr::valueSpaceIsRaw()
{
    return _bValueSpaceIsRaw;
}

// Current Output Raw Format for user get value interpretation
void CParameterMgr::setOutputRawFormat(bool bIsHex)
{
    _bOutputRawFormatIsHex = bIsHex;
}

bool CParameterMgr::outputRawFormatIsHex()
{
    return _bOutputRawFormatIsHex;
}

/// Sync
// Automatic hardware synchronization control (during tuning session)
bool CParameterMgr::setAutoSync(bool bAutoSyncOn, string &amp;strError)
{
    // Warn domains about turning auto sync back on
    if (bAutoSyncOn &amp;&amp; !_bAutoSyncOn) {

        // Do the synchronization at system class level (could be optimized by keeping track of all
        // modified parameters)
        if (!sync(strError)) {

            return false;
        }
    }

    // Set Auto sync
    _bAutoSyncOn = bAutoSyncOn;

    return true;
}

bool CParameterMgr::autoSyncOn() const
{
    return _bAutoSyncOn;
}

// Manual hardware synchronization control (during tuning session)
bool CParameterMgr::sync(string &amp;strError)
{
    // Warn domains about turning auto sync back on
    if (_bAutoSyncOn) {

        strError = &quot;Feature unavailable when Auto Sync is on&quot;;

        return false;
    }

    // Get syncer set
    CSyncerSet syncerSet;
    // ... from system class
    getConstSystemClass()-&gt;fillSyncerSet(syncerSet);

    // Sync
    core::Results error;
    if (!syncerSet.sync(*_pMainParameterBlackboard, false, &amp;error)) {

        strError = utility::asString(error);
        return false;
    };

    return true;
}

// Configuration/Domains handling
bool CParameterMgr::createDomain(const string &amp;strName, string &amp;strError)
{
    LOG_CONTEXT(&quot;Creating configurable domain &quot; + strName);
    // Check tuning mode
    if (!checkTuningModeOn(strError)) {

        return false;
    }

    // Delegate to configurable domains
    return logResult(getConfigurableDomains()-&gt;createDomain(strName, strError), strError);
}

bool CParameterMgr::deleteDomain(const string &amp;strName, string &amp;strError)
{
    LOG_CONTEXT(&quot;Deleting configurable domain '&quot; + strName + &quot;'&quot;);

    // Check tuning mode
    if (!checkTuningModeOn(strError)) {

        warning() &lt;&lt; &quot;Fail: &quot; &lt;&lt; strError;
        return false;
    }

    // Delegate to configurable domains
    return logResult(getConfigurableDomains()-&gt;deleteDomain(strName, strError), strError);
}

bool CParameterMgr::renameDomain(const string &amp;strName, const string &amp;strNewName, string &amp;strError)
{
    LOG_CONTEXT(&quot;Renaming configurable domain '&quot; + strName + &quot;' to '&quot; + strNewName + &quot;'&quot;);

    // Delegate to configurable domains
    return logResult(getConfigurableDomains()-&gt;renameDomain(strName, strNewName, strError),
                     strError);
}

bool CParameterMgr::deleteAllDomains(string &amp;strError)
{
    LOG_CONTEXT(&quot;Deleting all configurable domains&quot;);

    // Check tuning mode
    if (!checkTuningModeOn(strError)) {

        warning() &lt;&lt; &quot;Fail: &quot; &lt;&lt; strError;
        return false;
    }

    // Delegate to configurable domains
    getConfigurableDomains()-&gt;deleteAllDomains();

    info() &lt;&lt; &quot;Success&quot;;
    return true;
}

bool CParameterMgr::setSequenceAwareness(const string &amp;strName, bool bSequenceAware,
                                         string &amp;strResult)
{
    LOG_CONTEXT(&quot;Making domain '&quot; + strName + &quot;' sequence &quot; +
                (bSequenceAware ? &quot;aware&quot; : &quot;unaware&quot;));
    // Check tuning mode
    if (!checkTuningModeOn(strResult)) {

        warning() &lt;&lt; &quot;Fail: &quot; &lt;&lt; strResult;
        return false;
    }

    return logResult(
        getConfigurableDomains()-&gt;setSequenceAwareness(strName, bSequenceAware, strResult),
        strResult);
}

bool CParameterMgr::getSequenceAwareness(const string &amp;strName, bool &amp;bSequenceAware,
                                         string &amp;strResult)
{
    return getConfigurableDomains()-&gt;getSequenceAwareness(strName, bSequenceAware, strResult);
}

bool CParameterMgr::createConfiguration(const string &amp;strDomain, const string &amp;strConfiguration,
                                        string &amp;strError)
{
    LOG_CONTEXT(&quot;Creating domain configuration '&quot; + strConfiguration + &quot;' into domain '&quot; +
                strDomain + &quot;'&quot;);
    // Check tuning mode
    if (!checkTuningModeOn(strError)) {

        warning() &lt;&lt; &quot;Fail: &quot; &lt;&lt; strError;
        return false;
    }

    // Delegate to configurable domains
    return logResult(getConfigurableDomains()-&gt;createConfiguration(
                         strDomain, strConfiguration, _pMainParameterBlackboard, strError),
                     strError);
}
bool CParameterMgr::renameConfiguration(const string &amp;strDomain, const string &amp;strConfiguration,
                                        const string &amp;strNewConfiguration, string &amp;strError)
{
    LOG_CONTEXT(&quot;Renaming domain '&quot; + strDomain + &quot;''s configuration '&quot; + strConfiguration +
                &quot;' to '&quot; + strNewConfiguration + &quot;'&quot;);

    return logResult(getConfigurableDomains()-&gt;renameConfiguration(strDomain, strConfiguration,
                                                                   strNewConfiguration, strError),
                     strError);
}

bool CParameterMgr::deleteConfiguration(const string &amp;strDomain, const string &amp;strConfiguration,
                                        string &amp;strError)
{
    LOG_CONTEXT(&quot;Deleting configuration '&quot; + strConfiguration + &quot;' from domain '&quot; + strDomain +
                &quot;'&quot;);

    // Check tuning mode
    if (!checkTuningModeOn(strError)) {

        warning() &lt;&lt; &quot;Fail:&quot; &lt;&lt; strError;
        return false;
    }

    // Delegate to configurable domains
    return logResult(
        getConfigurableDomains()-&gt;deleteConfiguration(strDomain, strConfiguration, strError),
        strError);
}

bool CParameterMgr::restoreConfiguration(const string &amp;strDomain, const string &amp;strConfiguration,
                                         core::Results &amp;errors)
{
    string strError;
    LOG_CONTEXT(&quot;Restoring domain '&quot; + strDomain + &quot;''s configuration '&quot; + strConfiguration +
                &quot;' to parameter blackboard&quot;);
    // Check tuning mode
    if (!checkTuningModeOn(strError)) {

        errors.push_back(strError);
        warning() &lt;&lt; &quot;Fail:&quot; &lt;&lt; strError;
        return false;
    }

    // Delegate to configurable domains
    return logResult(
        getConstConfigurableDomains()-&gt;restoreConfiguration(
            strDomain, strConfiguration, _pMainParameterBlackboard, _bAutoSyncOn, errors),
        strError);
}

bool CParameterMgr::saveConfiguration(const string &amp;strDomain, const string &amp;strConfiguration,
                                      string &amp;strError)
{
    LOG_CONTEXT(&quot;Saving domain '&quot; + strDomain + &quot;' configuration '&quot; + strConfiguration +
                &quot;' from parameter blackboard&quot;);
    // Check tuning mode
    if (!checkTuningModeOn(strError)) {

        warning() &lt;&lt; &quot;Fail:&quot; &lt;&lt; strError;
        return false;
    }

    // Delegate to configurable domains
    return logResult(getConfigurableDomains()-&gt;saveConfiguration(
                         strDomain, strConfiguration, _pMainParameterBlackboard, strError),
                     strError);
}

// Configurable element - domain association
bool CParameterMgr::addConfigurableElementToDomain(const string &amp;strDomain,
                                                   const string &amp;strConfigurableElementPath,
                                                   string &amp;strError)
{
    LOG_CONTEXT(&quot;Adding configurable element '&quot; + strConfigurableElementPath + &quot;' to domain '&quot; +
                strDomain + &quot;'&quot;);
    // Check tuning mode
    if (!checkTuningModeOn(strError)) {

        warning() &lt;&lt; &quot;Fail: &quot; &lt;&lt; strError;
        return false;
    }

    CElementLocator elementLocator(getSystemClass());

    CElement *pLocatedElement = nullptr;

    if (!elementLocator.locate(strConfigurableElementPath, &amp;pLocatedElement, strError)) {

        warning() &lt;&lt; &quot;Fail: &quot; &lt;&lt; strError;
        return false;
    }

    // Convert element
    CConfigurableElement *pConfigurableElement =
        static_cast&lt;CConfigurableElement *&gt;(pLocatedElement);

    // Delegate
    core::Results infos;
    bool isSuccess = getConfigurableDomains()-&gt;addConfigurableElementToDomain(
        strDomain, pConfigurableElement, _pMainParameterBlackboard, infos);

    if (isSuccess) {
        info() &lt;&lt; infos;
    } else {
        warning() &lt;&lt; infos;
    }

    strError = utility::asString(infos);
    return isSuccess;
}

bool CParameterMgr::removeConfigurableElementFromDomain(const string &amp;strDomain,
                                                        const string &amp;strConfigurableElementPath,
                                                        string &amp;strError)
{
    LOG_CONTEXT(&quot;Removing configurable element '&quot; + strConfigurableElementPath + &quot;' from domain '&quot; +
                strDomain + &quot;'&quot;);

    // Check tuning mode
    if (!checkTuningModeOn(strError)) {

        warning() &lt;&lt; &quot;Fail:&quot; &lt;&lt; strError;
        return false;
    }

    CElementLocator elementLocator(getSystemClass());

    CElement *pLocatedElement = nullptr;

    if (!elementLocator.locate(strConfigurableElementPath, &amp;pLocatedElement, strError)) {

        warning() &lt;&lt; &quot;Fail:&quot; &lt;&lt; strError;
        return false;
    }

    // Convert element
    CConfigurableElement *pConfigurableElement =
        static_cast&lt;CConfigurableElement *&gt;(pLocatedElement);

    // Delegate
    return logResult(getConfigurableDomains()-&gt;removeConfigurableElementFromDomain(
                         strDomain, pConfigurableElement, strError),
                     strError);
}

bool CParameterMgr::split(const string &amp;strDomain, const string &amp;strConfigurableElementPath,
                          string &amp;strError)
{
    LOG_CONTEXT(&quot;Splitting configurable element '&quot; + strConfigurableElementPath + &quot;' domain '&quot; +
                strDomain + &quot;'&quot;);
    // Check tuning mode
    if (!checkTuningModeOn(strError)) {

        warning() &lt;&lt; &quot;Fail:&quot; &lt;&lt; strError;
        return false;
    }

    CElementLocator elementLocator(getSystemClass());

    CElement *pLocatedElement = nullptr;

    if (!elementLocator.locate(strConfigurableElementPath, &amp;pLocatedElement, strError)) {

        warning() &lt;&lt; &quot;Fail: &quot; &lt;&lt; strError;
        return false;
    }

    // Convert element
    CConfigurableElement *pConfigurableElement =
        static_cast&lt;CConfigurableElement *&gt;(pLocatedElement);

    // Delegate
    core::Results infos;
    bool isSuccess = getConfigurableDomains()-&gt;split(strDomain, pConfigurableElement, infos);

    if (isSuccess) {
        info() &lt;&lt; infos;
    } else {
        warning() &lt;&lt; infos;
    }

    strError = utility::asString(infos);
    return isSuccess;
}

bool CParameterMgr::setElementSequence(const string &amp;strDomain, const string &amp;strConfiguration,
                                       const std::vector&lt;string&gt; &amp;astrNewElementSequence,
                                       string &amp;strError)
{
    // Check tuning mode
    if (!checkTuningModeOn(strError)) {

        return false;
    }

    return getConfigurableDomains()-&gt;setElementSequence(strDomain, strConfiguration,
                                                        astrNewElementSequence, strError);
}

bool CParameterMgr::getApplicationRule(const string &amp;strDomain, const string &amp;strConfiguration,
                                       string &amp;strResult)
{
    return getConfigurableDomains()-&gt;getApplicationRule(strDomain, strConfiguration, strResult);
}

bool CParameterMgr::setApplicationRule(const string &amp;strDomain, const string &amp;strConfiguration,
                                       const string &amp;strApplicationRule, string &amp;strError)
{
    return getConfigurableDomains()-&gt;setApplicationRule(
        strDomain, strConfiguration, strApplicationRule,
        getConstSelectionCriteria()-&gt;getSelectionCriteriaDefinition(), strError);
}

bool CParameterMgr::clearApplicationRule(const string &amp;strDomain, const string &amp;strConfiguration,
                                         string &amp;strError)
{
    return getConfigurableDomains()-&gt;clearApplicationRule(strDomain, strConfiguration, strError);
}

bool CParameterMgr::importDomainsXml(const string &amp;xmlSource, bool withSettings, bool fromFile,
                                     string &amp;errorMsg)
{
    // Check tuning mode
    if (!checkTuningModeOn(errorMsg)) {

        return false;
    }

    LOG_CONTEXT(&quot;Importing domains from &quot; +
                (fromFile ? (&quot;\&quot;&quot; + xmlSource + &quot;\&quot;&quot;) : &quot;a user-provided buffer&quot;));

    // Root element
    CConfigurableDomains *pConfigurableDomains = getConfigurableDomains();

    bool importSuccess = wrapLegacyXmlImport(xmlSource, fromFile, withSettings,
                                             *pConfigurableDomains, &quot;SystemClassName&quot;, errorMsg);

    if (importSuccess) {

        // Validate domains after XML import
        pConfigurableDomains-&gt;validate(_pMainParameterBlackboard);
    }

    return importSuccess;
}

bool CParameterMgr::importSingleDomainXml(const string &amp;xmlSource, bool overwrite,
                                          bool withSettings, bool fromFile, string &amp;errorMsg)
{
    if (!checkTuningModeOn(errorMsg)) {

        return false;
    }

    LOG_CONTEXT(&quot;Importing a single domain from &quot; +
                (fromFile ? ('&quot;' + xmlSource + '&quot;') : &quot;a user-provided buffer&quot;));

    // We initialize the domain with an empty name but since we have set the isDomainStandalone
    // context, the name will be retrieved during de-serialization
    auto standaloneDomain = utility::make_unique&lt;CConfigurableDomain&gt;();

    if (!wrapLegacyXmlImport(xmlSource, fromFile, withSettings, *standaloneDomain, &quot;&quot;, errorMsg)) {
        return false;
    }

    if (!getConfigurableDomains()-&gt;addDomain(*standaloneDomain, overwrite, errorMsg)) {
        return false;
    }

    // ownership has been transfered to the ConfigurableDomains object
    standaloneDomain.release();
    return true;
}

bool CParameterMgr::wrapLegacyXmlImport(const string &amp;xmlSource, bool fromFile, bool withSettings,
                                        CElement &amp;element, const string &amp;nameAttributeName,
                                        string &amp;errorMsg)
{
    CXmlDomainImportContext xmlDomainImportContext(errorMsg, withSettings, *getSystemClass());

    // Selection criteria definition for rule creation
    xmlDomainImportContext.setSelectionCriteriaDefinition(
        getConstSelectionCriteria()-&gt;getSelectionCriteriaDefinition());

    // It doesn't make sense to resolve XIncludes on an imported file because
    // we can't reliably decide of a &quot;base url&quot;
    _xmlDoc *doc = CXmlDocSource::mkXmlDoc(xmlSource, fromFile, false, xmlDomainImportContext);
    if (doc == nullptr) {
        return false;
    }

    return xmlParse(xmlDomainImportContext, &amp;element, doc, &quot;&quot;, EParameterConfigurationLibrary, true,
                    nameAttributeName);
}

bool CParameterMgr::serializeElement(std::ostream &amp;output,
                                     CXmlSerializingContext &amp;xmlSerializingContext,
                                     const CElement &amp;element) const
{
    if (!output.good()) {
        xmlSerializingContext.setError(&quot;Can't write XML: the output is in a bad state.&quot;);
        return false;
    }

    // Use a doc source by loading data from instantiated Configurable Domains
    CXmlMemoryDocSource memorySource(&amp;element, _bValidateSchemasOnStart,
                                     element.getXmlElementName(), &quot;parameter-framework&quot;,
                                     getVersion());

    // Use a doc sink to write the doc data in a stream
    CXmlStreamDocSink sink(output);

    bool processSuccess = sink.process(memorySource, xmlSerializingContext);

    return processSuccess;
}

bool CParameterMgr::exportDomainsXml(string &amp;xmlDest, bool withSettings, bool toFile,
                                     string &amp;errorMsg) const
{
    LOG_CONTEXT(&quot;Exporting domains to &quot; +
                (toFile ? ('&quot;' + xmlDest + '&quot;') : &quot;a user-provided buffer&quot;));

    const CConfigurableDomains *configurableDomains = getConstConfigurableDomains();

    return wrapLegacyXmlExport(xmlDest, toFile, withSettings, *configurableDomains, errorMsg);
}

bool CParameterMgr::exportSingleDomainXml(string &amp;xmlDest, const string &amp;domainName,
                                          bool withSettings, bool toFile, string &amp;errorMsg) const
{
    LOG_CONTEXT(&quot;Exporting single domain '&quot; + domainName + &quot;' to &quot; +
                (toFile ? ('&quot;' + xmlDest + '&quot;') : &quot;a user-provided buffer&quot;));

    // Element to be serialized
    const CConfigurableDomain *requestedDomain =
        getConstConfigurableDomains()-&gt;findConfigurableDomain(domainName, errorMsg);

    if (requestedDomain == nullptr) {
        return false;
    }

    return wrapLegacyXmlExport(xmlDest, toFile, withSettings, *requestedDomain, errorMsg);
}

bool CParameterMgr::wrapLegacyXmlExport(string &amp;xmlDest, bool toFile, bool withSettings,
                                        const CElement &amp;element, string &amp;errorMsg) const
{
    CXmlDomainExportContext context(errorMsg, withSettings, _bValueSpaceIsRaw,
                                    _bOutputRawFormatIsHex);

    if (toFile) {
        return wrapLegacyXmlExportToFile(xmlDest, element, context);
    } else {
        return wrapLegacyXmlExportToString(xmlDest, element, context);
    }
}

bool CParameterMgr::wrapLegacyXmlExportToFile(string &amp;xmlDest, const CElement &amp;element,
                                              CXmlDomainExportContext &amp;context) const
{
    try {
        std::ofstream output;
        // Force stream to throw instead of using fail/bad bit
        // in order to retreive an error message.
        output.exceptions(~std::ifstream::goodbit);

        output.open(xmlDest.c_str());
        bool status = serializeElement(output, context, element);
        output.close(); // Explicit close to detect errors

        return status;

    } catch (std::ofstream::failure &amp;e) {
        context.setError(&quot;Failed to open \&quot;&quot; + xmlDest + &quot;\&quot; for writing: &quot; + e.what());
        return false;
    }
}

bool CParameterMgr::wrapLegacyXmlExportToString(string &amp;xmlDest, const CElement &amp;element,
                                                CXmlDomainExportContext &amp;context) const
{
    std::ostringstream output;

    if (!serializeElement(output, context, element)) {
        return false;
    }

    xmlDest = output.str();

    return true;
}

// For tuning, check we're in tuning mode
bool CParameterMgr::checkTuningModeOn(string &amp;strError) const
{
    // Tuning Mode on?
    if (!_bTuningModeIsOn) {

        strError = &quot;Tuning Mode must be on&quot;;

        return false;
    }
    return true;
}

// Tuning mutex dynamic parameter handling
std::mutex &amp;CParameterMgr::getBlackboardMutex()
{
    return _blackboardMutex;
}

// Blackboard reference (dynamic parameter handling)
CParameterBlackboard *CParameterMgr::getParameterBlackboard()
{
    return _pMainParameterBlackboard;
}

// Dynamic creation library feeding
void CParameterMgr::feedElementLibraries()
{
    // Global Configuration handling
    auto pFrameworkConfigurationLibrary = new CElementLibrary;

    pFrameworkConfigurationLibrary-&gt;addElementBuilder(
        &quot;ParameterFrameworkConfiguration&quot;,
        new TElementBuilderTemplate&lt;CParameterFrameworkConfiguration&gt;());
    pFrameworkConfigurationLibrary-&gt;addElementBuilder(
        &quot;SubsystemPlugins&quot;, new TKindElementBuilderTemplate&lt;CSubsystemPlugins&gt;());
    pFrameworkConfigurationLibrary-&gt;addElementBuilder(
        &quot;Location&quot;, new TKindElementBuilderTemplate&lt;CPluginLocation&gt;());
    pFrameworkConfigurationLibrary-&gt;addElementBuilder(
        &quot;StructureDescriptionFileLocation&quot;,
        new TKindElementBuilderTemplate&lt;CFrameworkConfigurationLocation&gt;());
    pFrameworkConfigurationLibrary-&gt;addElementBuilder(
        &quot;SettingsConfiguration&quot;, new TKindElementBuilderTemplate&lt;CFrameworkConfigurationGroup&gt;());
    pFrameworkConfigurationLibrary-&gt;addElementBuilder(
        &quot;ConfigurableDomainsFileLocation&quot;,
        new TKindElementBuilderTemplate&lt;CFrameworkConfigurationLocation&gt;());

    _pElementLibrarySet-&gt;addElementLibrary(pFrameworkConfigurationLibrary);

    // Parameter creation
    auto pParameterCreationLibrary = new CElementLibrary;

    pParameterCreationLibrary-&gt;addElementBuilder(
        &quot;Subsystem&quot;, new CSubsystemElementBuilder(getSystemClass()-&gt;getSubsystemLibrary()));
    pParameterCreationLibrary-&gt;addElementBuilder(
        &quot;ComponentType&quot;, new TNamedElementBuilderTemplate&lt;CComponentType&gt;());
    pParameterCreationLibrary-&gt;addElementBuilder(
        &quot;Component&quot;, new TNamedElementBuilderTemplate&lt;CComponentInstance&gt;());
    pParameterCreationLibrary-&gt;addElementBuilder(
        &quot;BitParameter&quot;, new TNamedElementBuilderTemplate&lt;CBitParameterType&gt;());
    pParameterCreationLibrary-&gt;addElementBuilder(
        &quot;BitParameterBlock&quot;, new TNamedElementBuilderTemplate&lt;CBitParameterBlockType&gt;());
    pParameterCreationLibrary-&gt;addElementBuilder(
        &quot;StringParameter&quot;, new TNamedElementBuilderTemplate&lt;CStringParameterType&gt;());
    pParameterCreationLibrary-&gt;addElementBuilder(
        &quot;ParameterBlock&quot;, new TNamedElementBuilderTemplate&lt;CParameterBlockType&gt;());
    pParameterCreationLibrary-&gt;addElementBuilder(
        &quot;BooleanParameter&quot;, new TNamedElementBuilderTemplate&lt;CBooleanParameterType&gt;());
    pParameterCreationLibrary-&gt;addElementBuilder(&quot;IntegerParameter&quot;, new IntegerParameterBuilder());
    pParameterCreationLibrary-&gt;addElementBuilder(
        &quot;LinearAdaptation&quot;, new TElementBuilderTemplate&lt;CLinearParameterAdaptation&gt;());
    pParameterCreationLibrary-&gt;addElementBuilder(
        &quot;LogarithmicAdaptation&quot;, new TElementBuilderTemplate&lt;CLogarithmicParameterAdaptation&gt;());
    pParameterCreationLibrary-&gt;addElementBuilder(
        &quot;EnumParameter&quot;, new TNamedElementBuilderTemplate&lt;CEnumParameterType&gt;());
    pParameterCreationLibrary-&gt;addElementBuilder(&quot;ValuePair&quot;,
                                                 new TElementBuilderTemplate&lt;CEnumValuePair&gt;());
    pParameterCreationLibrary-&gt;addElementBuilder(
        &quot;FixedPointParameter&quot;, new TNamedElementBuilderTemplate&lt;CFixedPointParameterType&gt;());
    pParameterCreationLibrary-&gt;addElementBuilder(
        &quot;FloatingPointParameter&quot;, new TNamedElementBuilderTemplate&lt;CFloatingPointParameterType&gt;);
    pParameterCreationLibrary-&gt;addElementBuilder(
        &quot;SubsystemInclude&quot;,
        new CFileIncluderElementBuilder(_bValidateSchemasOnStart, getSchemaUri()));

    _pElementLibrarySet-&gt;addElementLibrary(pParameterCreationLibrary);

    // Parameter Configuration Domains creation
    auto pParameterConfigurationLibrary = new CElementLibrary;

    pParameterConfigurationLibrary-&gt;addElementBuilder(
        &quot;ConfigurableDomain&quot;, new TElementBuilderTemplate&lt;CConfigurableDomain&gt;());
    pParameterConfigurationLibrary-&gt;addElementBuilder(
        &quot;Configuration&quot;, new TNamedElementBuilderTemplate&lt;CDomainConfiguration&gt;());
    pParameterConfigurationLibrary-&gt;addElementBuilder(&quot;CompoundRule&quot;,
                                                      new TElementBuilderTemplate&lt;CCompoundRule&gt;());
    pParameterConfigurationLibrary-&gt;addElementBuilder(
        &quot;SelectionCriterionRule&quot;, new TElementBuilderTemplate&lt;CSelectionCriterionRule&gt;());

    _pElementLibrarySet-&gt;addElementLibrary(pParameterConfigurationLibrary);
}

bool CParameterMgr::getForceNoRemoteInterface() const
{
    return _bForceNoRemoteInterface;
}

void CParameterMgr::setForceNoRemoteInterface(bool bForceNoRemoteInterface)
{
    _bForceNoRemoteInterface = bForceNoRemoteInterface;
}

CParameterMgr::CommandHandler CParameterMgr::createCommandHandler()
{
    auto commandHandler = utility::make_unique&lt;CCommandHandler&gt;(this);

    // Add command parsers
    for (const auto &amp;remoteCommandParserItem : gastRemoteCommandParserItems) {
        commandHandler-&gt;addCommandParser(
            remoteCommandParserItem._pcCommandName, remoteCommandParserItem._pfnParser,
            remoteCommandParserItem._minArgumentCount, remoteCommandParserItem._pcHelp,
            remoteCommandParserItem._pcDescription);
    }

    return commandHandler;
}

bool CParameterMgr::isRemoteInterfaceRequired()
{
    // The remote interface should only be started if the client didn't
    // explicitly forbid it and if the configuration file allows it.
    return (not _bForceNoRemoteInterface) and getConstFrameworkConfiguration()-&gt;isTuningAllowed();
}

// Remote Processor Server connection handling
bool CParameterMgr::handleRemoteProcessingInterface(string &amp;strError)
{
    LOG_CONTEXT(&quot;Handling remote processing interface&quot;);

    if (not isRemoteInterfaceRequired()) {
        return true;
    }

    auto port = getConstFrameworkConfiguration()-&gt;getServerPort();

    try {
        // The ownership of remoteComandHandler is given to Bg remote processor server.
        _pRemoteProcessorServer = new BackgroundRemoteProcessorServer(port, createCommandHandler());
    } catch (std::runtime_error &amp;e) {
        strError = string(&quot;ParameterMgr: Unable to create Remote Processor Server: &quot;) + e.what();
        return false;
    }

    if (_pRemoteProcessorServer == nullptr) {
        strError = &quot;ParameterMgr: Unable to create Remote Processor Server&quot;;
        return false;
    }

    if (!_pRemoteProcessorServer-&gt;start(strError)) {
        ostringstream oss;
        oss &lt;&lt; &quot;ParameterMgr: Unable to start remote processor server on port &quot; &lt;&lt; port;
        strError = oss.str() + &quot;: &quot; + strError;
        return false;
    }
    info() &lt;&lt; &quot;Remote Processor Server started on port &quot; &lt;&lt; port;
    return true;
}

// Children typwise access
CParameterFrameworkConfiguration *CParameterMgr::getFrameworkConfiguration()
{
    return static_cast&lt;CParameterFrameworkConfiguration *&gt;(getChild(EFrameworkConfiguration));
}

const CParameterFrameworkConfiguration *CParameterMgr::getConstFrameworkConfiguration()
{
    return getFrameworkConfiguration();
}

CSelectionCriteria *CParameterMgr::getSelectionCriteria()
{
    return static_cast&lt;CSelectionCriteria *&gt;(getChild(ESelectionCriteria));
}

const CSelectionCriteria *CParameterMgr::getConstSelectionCriteria()
{
    return static_cast&lt;const CSelectionCriteria *&gt;(getChild(ESelectionCriteria));
}

CSystemClass *CParameterMgr::getSystemClass()
{
    return static_cast&lt;CSystemClass *&gt;(getChild(ESystemClass));
}

const CSystemClass *CParameterMgr::getConstSystemClass() const
{
    return static_cast&lt;const CSystemClass *&gt;(getChild(ESystemClass));
}

// Configurable Domains
CConfigurableDomains *CParameterMgr::getConfigurableDomains()
{
    return static_cast&lt;CConfigurableDomains *&gt;(getChild(EConfigurableDomains));
}

const CConfigurableDomains *CParameterMgr::getConstConfigurableDomains()
{
    return static_cast&lt;const CConfigurableDomains *&gt;(getChild(EConfigurableDomains));
}

const CConfigurableDomains *CParameterMgr::getConstConfigurableDomains() const
{
    return static_cast&lt;const CConfigurableDomains *&gt;(getChild(EConfigurableDomains));
}

// Apply configurations
void CParameterMgr::doApplyConfigurations(bool bForce)
{
    LOG_CONTEXT(&quot;Applying configurations&quot;);

    CSyncerSet syncerSet;

    core::Results infos;
    // Check subsystems that need resync
    getSystemClass()-&gt;checkForSubsystemsToResync(syncerSet, infos);

    // Ensure application of currently selected configurations
    getConfigurableDomains()-&gt;apply(_pMainParameterBlackboard, syncerSet, bForce, infos);
    info() &lt;&lt; infos;

    // Reset the modified status of the current criteria to indicate that a new configuration has
    // been applied
    getSelectionCriteria()-&gt;resetModifiedStatus();
}

// Export to XML string
bool CParameterMgr::exportElementToXMLString(const IXmlSource *pXmlSource,
                                             const string &amp;strRootElementType,
                                             CXmlSerializingContext &amp;&amp;xmlSerializingContext,
                                             string &amp;strResult) const
{
    // Use a doc source by loading data from instantiated Configurable Domains
    CXmlMemoryDocSource memorySource(pXmlSource, false, strRootElementType);

    // Use a doc sink that write the doc data in a string
    ostringstream output;
    CXmlStreamDocSink streamSink(output);

    // Do the export
    bool bProcessSuccess = streamSink.process(memorySource, xmlSerializingContext);

    strResult = output.str();

    return bProcessSuccess;
}

bool CParameterMgr::logResult(bool isSuccess, const std::string &amp;result)
{
    std::string log = result.empty() ? &quot;&quot; : &quot;: &quot; + result;

    if (isSuccess) {
        info() &lt;&lt; &quot;Success&quot; &lt;&lt; log;
    } else {
        warning() &lt;&lt; &quot;Fail&quot; &lt;&lt; log;
    }

    return isSuccess;
}

log::details::Info CParameterMgr::info()
{
    return _logger.info();
}

log::details::Warning CParameterMgr::warning()
{
    return _logger.warning();
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>BitParameterBlockType.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright (c) 2011-2015, Intel Corporation
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation and/or
 * other materials provided with the distribution.
 *
 * 3. Neither the name of the copyright holder nor the names of its contributors
 * may be used to endorse or promote products derived from this software without
 * specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
#include &quot;BitParameterBlockType.h&quot;
#include &quot;BitParameterBlock.h&quot;
#include &quot;Utility.h&quot;

#define base CTypeElement

using std::string;
<A NAME="0"></A>
CBitParameterBlockType::CBitParameterBlockType(const string &amp;strName) : base(strName)
{
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match598-0.html#0',2,'match598-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

string CBitParameterBlockType::getKind() const
{
    return &quot;BitParameterBlock&quot;;
}

bool CBitParameterBlockType::childrenAreDynamic() const
{
    return true;
}

// Size
size_t CBitParameterBlockType::getSize() const</B></FONT>
{
    return _size;
}

// From IXmlSink
bool CBitParameterBlockType::fromXml(const CXmlElement &amp;xmlElement,
                                     CXmlSerializingContext &amp;serializingContext)
{
    // Size
    xmlElement.getAttribute(&quot;Size&quot;, _size);
    _size /= 8;

    // Base
    return base::fromXml(xmlElement, serializingContext);
}

// Instantiation
CInstanceConfigurableElement *CBitParameterBlockType::doInstantiate() const
{
    return new CBitParameterBlock(getName(), this);
}

// From IXmlSource
void CBitParameterBlockType::toXml(CXmlElement &amp;xmlElement,
                                   CXmlSerializingContext &amp;serializingContext) const
{
    // Size
    xmlElement.setAttribute(&quot;Size&quot;, _size * 8);

    base::toXml(xmlElement, serializingContext);
}
</PRE>
</div>
  </div>
</body>
</html>
