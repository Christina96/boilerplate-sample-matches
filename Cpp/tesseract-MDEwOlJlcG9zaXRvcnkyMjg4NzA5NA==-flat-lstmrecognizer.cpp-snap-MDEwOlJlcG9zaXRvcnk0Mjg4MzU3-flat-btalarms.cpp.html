
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 6.691962745774404%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-lstmrecognizer.cpp</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #  include "config_auto.h"
3  #endif
4  #include "lstmrecognizer.h"
5  #include <allheaders.h>
6  #include "dict.h"
7  #include "genericheap.h"
8  #include "helpers.h"
9  #include "imagedata.h"
10  #include "input.h"
11  #include "lstm.h"
12  #include "normalis.h"
13  #include "pageres.h"
14  #include "ratngs.h"
15  #include "recodebeam.h"
16  #include "scrollview.h"
17  #include "statistc.h"
18  #include "tprintf.h"
19  #include <unordered_set>
20  #include <vector>
21  namespace tesseract {
22  const double kDictRatio = 2.25;
23  const double kCertOffset = -0.085;
24  LSTMRecognizer::LSTMRecognizer(const std::string &language_data_path_prefix)
25      : LSTMRecognizer::LSTMRecognizer() {
26    ccutil_.language_data_path_prefix = language_data_path_prefix;
27  }
28  LSTMRecognizer::LSTMRecognizer()
29      : network_(nullptr)
30      , training_flags_(0)
31      , training_iteration_(0)
32      , sample_iteration_(0)
33      , null_char_(UNICHAR_BROKEN)
34      , learning_rate_(0.0f)
35      , momentum_(0.0f)
36      , adam_beta_(0.0f)
37      , dict_(nullptr)
38      , search_(nullptr)
39      , debug_win_(nullptr) {}
40  LSTMRecognizer::~LSTMRecognizer() {
41    delete network_;
42    delete dict_;
43    delete search_;
44  }
45  bool LSTMRecognizer::Load(const ParamsVectors *params, const std::string &lang,
46                            TessdataManager *mgr) {
47    TFile fp;
48    if (!mgr->GetComponent(TESSDATA_LSTM, &fp)) {
49      return false;
50    }
51    if (!DeSerialize(mgr, &fp)) {
52      return false;
53    }
54    if (lang.empty()) {
55      return true;
56    }
57    LoadDictionary(params, lang, mgr);
58    return true;
59  }
60  bool LSTMRecognizer::Serialize(const TessdataManager *mgr, TFile *fp) const {
61    bool include_charsets = mgr == nullptr || !mgr->IsComponentAvailable(TESSDATA_LSTM_RECODER) ||
62                            !mgr->IsComponentAvailable(TESSDATA_LSTM_UNICHARSET);
63    if (!network_->Serialize(fp)) {
64      return false;
65    }
66    if (include_charsets && !GetUnicharset().save_to_file(fp)) {
67      return false;
68    }
69    if (!fp->Serialize(network_str_)) {
70      return false;
71    }
72    if (!fp->Serialize(&training_flags_)) {
73      return false;
74    }
75    if (!fp->Serialize(&training_iteration_)) {
76      return false;
77    }
78    if (!fp->Serialize(&sample_iteration_)) {
79      return false;
80    }
81    if (!fp->Serialize(&null_char_)) {
82      return false;
83    }
84    if (!fp->Serialize(&adam_beta_)) {
85      return false;
86    }
87    if (!fp->Serialize(&learning_rate_)) {
88      return false;
89    }
90    if (!fp->Serialize(&momentum_)) {
91      return false;
92    }
93    if (include_charsets && IsRecoding() && !recoder_.Serialize(fp)) {
94      return false;
95    }
96    return true;
97  }
98  bool LSTMRecognizer::DeSerialize(const TessdataManager *mgr, TFile *fp) {
99    delete network_;
100    network_ = Network::CreateFromFile(fp);
101    if (network_ == nullptr) {
102      return false;
103    }
104    bool include_charsets = mgr == nullptr || !mgr->IsComponentAvailable(TESSDATA_LSTM_RECODER) ||
105                            !mgr->IsComponentAvailable(TESSDATA_LSTM_UNICHARSET);
106    if (include_charsets && !ccutil_.unicharset.load_from_file(fp, false)) {
107      return false;
108    }
109    if (!fp->DeSerialize(network_str_)) {
110      return false;
111    }
112    if (!fp->DeSerialize(&training_flags_)) {
113      return false;
114    }
115    if (!fp->DeSerialize(&training_iteration_)) {
116      return false;
117    }
118    if (!fp->DeSerialize(&sample_iteration_)) {
119      return false;
120    }
121    if (!fp->DeSerialize(&null_char_)) {
122      return false;
123    }
124    if (!fp->DeSerialize(&adam_beta_)) {
125      return false;
126    }
127    if (!fp->DeSerialize(&learning_rate_)) {
128      return false;
129    }
130    if (!fp->DeSerialize(&momentum_)) {
131      return false;
132    }
133    if (include_charsets && !LoadRecoder(fp)) {
134      return false;
135    }
136    if (!include_charsets && !LoadCharsets(mgr)) {
137      return false;
138    }
139    network_->SetRandomizer(&randomizer_);
140    network_->CacheXScaleFactor(network_->XScaleFactor());
141    return true;
142  }
143  bool LSTMRecognizer::LoadCharsets(const TessdataManager *mgr) {
144    TFile fp;
145    if (!mgr->GetComponent(TESSDATA_LSTM_UNICHARSET, &fp)) {
146      return false;
147    }
148    if (!ccutil_.unicharset.load_from_file(&fp, false)) {
149      return false;
150    }
151    if (!mgr->GetComponent(TESSDATA_LSTM_RECODER, &fp)) {
152      return false;
153    }
154    if (!LoadRecoder(&fp)) {
155      return false;
156    }
157    return true;
158  }
159  bool LSTMRecognizer::LoadRecoder(TFile *fp) {
160    if (IsRecoding()) {
161      if (!recoder_.DeSerialize(fp)) {
162        return false;
163      }
164      RecodedCharID code;
165      recoder_.EncodeUnichar(UNICHAR_SPACE, &code);
166      if (code(0) != UNICHAR_SPACE) {
167        tprintf("Space was garbled in recoding!!\n");
168        return false;
169      }
170    } else {
171      recoder_.SetupPassThrough(GetUnicharset());
172      training_flags_ |= TF_COMPRESS_UNICHARSET;
173    }
174    return true;
175  }
176  bool LSTMRecognizer::LoadDictionary(const ParamsVectors *params, const std::string &lang,
177                                      TessdataManager *mgr) {
178    delete dict_;
179    dict_ = new Dict(&ccutil_);
180    dict_->user_words_file.ResetFrom(params);
181    dict_->user_words_suffix.ResetFrom(params);
182    dict_->user_patterns_file.ResetFrom(params);
183    dict_->user_patterns_suffix.ResetFrom(params);
184    dict_->SetupForLoad(Dict::GlobalDawgCache());
185    dict_->LoadLSTM(lang, mgr);
186    if (dict_->FinishLoad()) {
187      return true; 
188    }
189    if (log_level <= 0) {
190      tprintf("Failed to load any lstm-specific dictionaries for lang %s!!\n", lang.c_str());
191    }
192    delete dict_;
193    dict_ = nullptr;
194    return false;
195  }
196  void LSTMRecognizer::RecognizeLine(const ImageData &image_data,
197                                     float invert_threshold, bool debug,
198                                     double worst_dict_cert, const TBOX &line_box,
199                                     PointerVector<WERD_RES> *words, int lstm_choice_mode,
200                                     int lstm_choice_amount) {
201    NetworkIO outputs;
202    float scale_factor;
203    NetworkIO inputs;
204    if (!RecognizeLine(image_data, invert_threshold, debug, false, false, &scale_factor, &inputs, &outputs)) {
205      return;
206    }
207    if (search_ == nullptr) {
208      search_ = new RecodeBeamSearch(recoder_, null_char_, SimpleTextOutput(), dict_);
209    }
210    search_->excludedUnichars.clear();
211    search_->Decode(outputs, kDictRatio, kCertOffset, worst_dict_cert, &GetUnicharset(),
212                    lstm_choice_mode);
213    search_->ExtractBestPathAsWords(line_box, scale_factor, debug, &GetUnicharset(), words,
214                                    lstm_choice_mode);
215    if (lstm_choice_mode) {
216      search_->extractSymbolChoices(&GetUnicharset());
217      for (int i = 0; i < lstm_choice_amount; ++i) {
218        search_->DecodeSecondaryBeams(outputs, kDictRatio, kCertOffset, worst_dict_cert,
219                                      &GetUnicharset(), lstm_choice_mode);
220        search_->extractSymbolChoices(&GetUnicharset());
221      }
222      search_->segmentTimestepsByCharacters();
223      unsigned char_it = 0;
224      for (size_t i = 0; i < words->size(); ++i) {
225        for (int j = 0; j < words->at(i)->end; ++j) {
226          if (char_it < search_->ctc_choices.size()) {
227            words->at(i)->CTC_symbol_choices.push_back(search_->ctc_choices[char_it]);
228          }
229          if (char_it < search_->segmentedTimesteps.size()) {
230            words->at(i)->segmented_timesteps.push_back(search_->segmentedTimesteps[char_it]);
231          }
232          ++char_it;
233        }
234        words->at(i)->timesteps =
235            search_->combineSegmentedTimesteps(&words->at(i)->segmented_timesteps);
236      }
237      search_->segmentedTimesteps.clear();
238      search_->ctc_choices.clear();
239      search_->excludedUnichars.clear();
240    }
241  }
242  void LSTMRecognizer::OutputStats(const NetworkIO &outputs, float *min_output, float *mean_output,
<span onclick='openModal()' class='match'>243                                   float *sd) {
244    const int kOutputScale = INT8_MAX;
245    STATS stats(0, kOutputScale);
246    for (int t = 0; t < outputs.Width(); ++t) {
</span>247      int best_label = outputs.BestLabel(t, nullptr);
248      if (best_label != null_char_) {
249        float best_output = outputs.f(t)[best_label];
250        stats.add(static_cast<int>(kOutputScale * best_output), 1);
251      }
252    }
253    if (stats.get_total() == 0) {
254      *min_output = 0.0f;
255      *mean_output = 0.0f;
256      *sd = 1.0f;
257    } else {
258      *min_output = static_cast<float>(stats.min_bucket()) / kOutputScale;
259      *mean_output = stats.mean() / kOutputScale;
260      *sd = stats.sd() / kOutputScale;
261    }
262  }
263  bool LSTMRecognizer::RecognizeLine(const ImageData &image_data,
264                                     float invert_threshold, bool debug,
265                                     bool re_invert, bool upside_down, float *scale_factor,
266                                     NetworkIO *inputs, NetworkIO *outputs) {
267    SetRandomSeed();
268    int min_width = network_->XScaleFactor();
269    Image pix = Input::PrepareLSTMInputs(image_data, network_, min_width, &randomizer_, scale_factor);
270    if (pix == nullptr) {
271      tprintf("Line cannot be recognized!!\n");
272      return false;
273    }
274    const int kMaxImageWidth = 128 * pixGetHeight(pix);
275    if (network_->IsTraining() && pixGetWidth(pix) > kMaxImageWidth) {
276      tprintf("Image too large to learn!! Size = %dx%d\n", pixGetWidth(pix), pixGetHeight(pix));
277      pix.destroy();
278      return false;
279    }
280    if (upside_down) {
281      pixRotate180(pix, pix);
282    }
283    *scale_factor = min_width / *scale_factor;
284    inputs->set_int_mode(IsIntMode());
285    SetRandomSeed();
286    Input::PreparePixInput(network_->InputShape(), pix, &randomizer_, inputs);
287    network_->Forward(debug, *inputs, nullptr, &scratch_space_, outputs);
288    if (invert_threshold > 0.0f) {
289      float pos_min, pos_mean, pos_sd;
290      OutputStats(*outputs, &pos_min, &pos_mean, &pos_sd);
291      if (pos_mean < invert_threshold) {
292        NetworkIO inv_inputs, inv_outputs;
293        inv_inputs.set_int_mode(IsIntMode());
294        SetRandomSeed();
295        pixInvert(pix, pix);
296        Input::PreparePixInput(network_->InputShape(), pix, &randomizer_, &inv_inputs);
297        network_->Forward(debug, inv_inputs, nullptr, &scratch_space_, &inv_outputs);
298        float inv_min, inv_mean, inv_sd;
299        OutputStats(inv_outputs, &inv_min, &inv_mean, &inv_sd);
300        if (inv_mean > pos_mean) {
301          if (debug) {
302            tprintf("Inverting image: old min=%g, mean=%g, sd=%g, inv %g,%g,%g\n", pos_min, pos_mean,
303                    pos_sd, inv_min, inv_mean, inv_sd);
304          }
305          *outputs = inv_outputs;
306          *inputs = inv_inputs;
307        } else if (re_invert) {
308          SetRandomSeed();
309          network_->Forward(debug, *inputs, nullptr, &scratch_space_, outputs);
310        }
311      }
312    }
313    pix.destroy();
314    if (debug) {
315      std::vector<int> labels, coords;
316      LabelsFromOutputs(*outputs, &labels, &coords);
317  #ifndef GRAPHICS_DISABLED
318      DisplayForward(*inputs, labels, coords, "LSTMForward", &debug_win_);
319  #endif
320      DebugActivationPath(*outputs, labels, coords);
321    }
322    return true;
323  }
324  std::string LSTMRecognizer::DecodeLabels(const std::vector<int> &labels) {
325    std::string result;
326    unsigned end = 1;
327    for (unsigned start = 0; start < labels.size(); start = end) {
328      if (labels[start] == null_char_) {
329        end = start + 1;
330      } else {
331        result += DecodeLabel(labels, start, &end, nullptr);
332      }
333    }
334    return result;
335  }
336  #ifndef GRAPHICS_DISABLED
337  void LSTMRecognizer::DisplayForward(const NetworkIO &inputs, const std::vector<int> &labels,
338                                      const std::vector<int> &label_coords, const char *window_name,
339                                      ScrollView **window) {
340    Image input_pix = inputs.ToPix();
341    Network::ClearWindow(false, window_name, pixGetWidth(input_pix), pixGetHeight(input_pix), window);
342    int line_height = Network::DisplayImage(input_pix, *window);
343    DisplayLSTMOutput(labels, label_coords, line_height, *window);
344  }
345  void LSTMRecognizer::DisplayLSTMOutput(const std::vector<int> &labels,
346                                         const std::vector<int> &xcoords, int height,
347                                         ScrollView *window) {
348    int x_scale = network_->XScaleFactor();
349    window->TextAttributes("Arial", height / 4, false, false, false);
350    unsigned end = 1;
351    for (unsigned start = 0; start < labels.size(); start = end) {
352      int xpos = xcoords[start] * x_scale;
353      if (labels[start] == null_char_) {
354        end = start + 1;
355        window->Pen(ScrollView::RED);
356      } else {
357        window->Pen(ScrollView::GREEN);
358        const char *str = DecodeLabel(labels, start, &end, nullptr);
359        if (*str == '\\') {
360          str = "\\\\";
361        }
362        xpos = xcoords[(start + end) / 2] * x_scale;
363        window->Text(xpos, height, str);
364      }
365      window->Line(xpos, 0, xpos, height * 3 / 2);
366    }
367    window->Update();
368  }
369  #endif 
370  void LSTMRecognizer::DebugActivationPath(const NetworkIO &outputs, const std::vector<int> &labels,
371                                           const std::vector<int> &xcoords) {
372    if (xcoords[0] > 0) {
373      DebugActivationRange(outputs, "<null>", null_char_, 0, xcoords[0]);
374    }
375    unsigned end = 1;
376    for (unsigned start = 0; start < labels.size(); start = end) {
377      if (labels[start] == null_char_) {
378        end = start + 1;
379        DebugActivationRange(outputs, "<null>", null_char_, xcoords[start], xcoords[end]);
380        continue;
381      } else {
382        int decoded;
383        const char *label = DecodeLabel(labels, start, &end, &decoded);
384        DebugActivationRange(outputs, label, labels[start], xcoords[start], xcoords[start + 1]);
385        for (unsigned i = start + 1; i < end; ++i) {
386          DebugActivationRange(outputs, DecodeSingleLabel(labels[i]), labels[i], xcoords[i],
387                               xcoords[i + 1]);
388        }
389      }
390    }
391  }
392  void LSTMRecognizer::DebugActivationRange(const NetworkIO &outputs, const char *label,
393                                            int best_choice, int x_start, int x_end) {
394    tprintf("%s=%d On [%d, %d), scores=", label, best_choice, x_start, x_end);
395    double max_score = 0.0;
396    double mean_score = 0.0;
397    const int width = x_end - x_start;
398    for (int x = x_start; x < x_end; ++x) {
399      const float *line = outputs.f(x);
400      const double score = line[best_choice] * 100.0;
401      if (score > max_score) {
402        max_score = score;
403      }
404      mean_score += score / width;
405      int best_c = 0;
406      double best_score = 0.0;
407      for (int c = 0; c < outputs.NumFeatures(); ++c) {
408        if (c != best_choice && line[c] > best_score) {
409          best_c = c;
410          best_score = line[c];
411        }
412      }
413      tprintf(" %.3g(%s=%d=%.3g)", score, DecodeSingleLabel(best_c), best_c, best_score * 100.0);
414    }
415    tprintf(", Mean=%g, max=%g\n", mean_score, max_score);
416  }
417  #if 0 
418  static bool NullIsBest(const NetworkIO& output, float null_thr,
419                         int null_char, int t) {
420    if (output.f(t)[null_char] >= null_thr) return true;
421    if (output.BestLabel(t, null_char, null_char, nullptr) != UNICHAR_SPACE)
422      return false;
423    return output.f(t)[null_char] > output.f(t)[UNICHAR_SPACE];
424  }
425  #endif
426  void LSTMRecognizer::LabelsFromOutputs(const NetworkIO &outputs, std::vector<int> *labels,
427                                         std::vector<int> *xcoords) {
428    if (SimpleTextOutput()) {
429      LabelsViaSimpleText(outputs, labels, xcoords);
430    } else {
431      LabelsViaReEncode(outputs, labels, xcoords);
432    }
433  }
434  void LSTMRecognizer::LabelsViaReEncode(const NetworkIO &output, std::vector<int> *labels,
435                                         std::vector<int> *xcoords) {
436    if (search_ == nullptr) {
437      search_ = new RecodeBeamSearch(recoder_, null_char_, SimpleTextOutput(), dict_);
438    }
439    search_->Decode(output, 1.0, 0.0, RecodeBeamSearch::kMinCertainty, nullptr);
440    search_->ExtractBestPathAsLabels(labels, xcoords);
441  }
442  void LSTMRecognizer::LabelsViaSimpleText(const NetworkIO &output, std::vector<int> *labels,
443                                           std::vector<int> *xcoords) {
444    labels->clear();
445    xcoords->clear();
446    const int width = output.Width();
447    for (int t = 0; t < width; ++t) {
448      float score = 0.0f;
449      const int label = output.BestLabel(t, &score);
450      if (label != null_char_) {
451        labels->push_back(label);
452        xcoords->push_back(t);
453      }
454    }
455    xcoords->push_back(width);
456  }
457  const char *LSTMRecognizer::DecodeLabel(const std::vector<int> &labels, unsigned start, unsigned *end,
458                                          int *decoded) {
459    *end = start + 1;
460    if (IsRecoding()) {
461      RecodedCharID code;
462      if (labels[start] == null_char_) {
463        if (decoded != nullptr) {
464          code.Set(0, null_char_);
465          *decoded = recoder_.DecodeUnichar(code);
466        }
467        return "<null>";
468      }
469      unsigned index = start;
470      while (index < labels.size() && code.length() < RecodedCharID::kMaxCodeLen) {
471        code.Set(code.length(), labels[index++]);
472        while (index < labels.size() && labels[index] == null_char_) {
473          ++index;
474        }
475        int uni_id = recoder_.DecodeUnichar(code);
476        if (uni_id != INVALID_UNICHAR_ID &&
477            (index == labels.size() || code.length() == RecodedCharID::kMaxCodeLen ||
478             recoder_.IsValidFirstCode(labels[index]))) {
479          *end = index;
480          if (decoded != nullptr) {
481            *decoded = uni_id;
482          }
483          if (uni_id == UNICHAR_SPACE) {
484            return " ";
485          }
486          return GetUnicharset().get_normed_unichar(uni_id);
487        }
488      }
489      return "<Undecodable>";
490    } else {
491      if (decoded != nullptr) {
492        *decoded = labels[start];
493      }
494      if (labels[start] == null_char_) {
495        return "<null>";
496      }
497      if (labels[start] == UNICHAR_SPACE) {
498        return " ";
499      }
500      return GetUnicharset().get_normed_unichar(labels[start]);
501    }
502  }
503  const char *LSTMRecognizer::DecodeSingleLabel(int label) {
504    if (label == null_char_) {
505      return "<null>";
506    }
507    if (IsRecoding()) {
508      RecodedCharID code;
509      code.Set(0, label);
510      label = recoder_.DecodeUnichar(code);
511      if (label == INVALID_UNICHAR_ID) {
512        return ".."; 
513      }
514    }
515    if (label == UNICHAR_SPACE) {
516      return " ";
517    }
518    return GetUnicharset().get_normed_unichar(label);
519  }
520  } 
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-btalarms.cpp</h3>
            <pre><code>1  #include "btalarms.h"
2  PBtaDevDefBs TBtaDevDefBs::LoadTxt(const TStr& FNm){
3    PBtaDevDefBs DevDefBs=TBtaDevDefBs::New();
4    printf("Loading Device Definitions from '%s' ...\n", FNm.CStr());
5    PSIn SIn=TFIn::New(FNm);
6    char SsCh=' '; TStrV FldNmV;
7    TSs::LoadTxtFldV(ssfTabSep, SIn, SsCh, FldNmV, false, false);
8    int IpNum_FldN=FldNmV.SearchForw("IP");
9    int Node_FldN=FldNmV.SearchForw("Node");
10    int Zone_FldN=FldNmV.SearchForw("Zone");
11    int Loc_FldN=FldNmV.SearchForw("Location");
12    int Proj_FldN=FldNmV.SearchForw("Project");
13    int Type_FldN=FldNmV.SearchForw("Type");
14    TStrV FldValV; int Recs=0;
15    while (!SIn->Eof()){
16      Recs++; printf("  %d\r", Recs);
17      TSs::LoadTxtFldV(ssfTabSep, SIn, SsCh, FldValV, false, false);
18      IAssert(FldNmV.Len()==FldValV.Len());
19      TStr IpNumNm=FldValV[IpNum_FldN].GetTrunc();
20      TStr NodeNm=FldValV[Node_FldN].GetTrunc();
21      TStr ZoneNm=FldValV[Zone_FldN].GetTrunc();
22      TStr LocNm=FldValV[Loc_FldN].GetTrunc();
23      TStr ProjNm=FldValV[Proj_FldN].GetTrunc();
24      TStr TypeNm=FldValV[Type_FldN].GetTrunc();
25      int IpNumId=-1; int NodeId=-1; int ZoneId=-1;
26      int LocId=-1; int ProjId=-1; int TypeId=-1;
27      if (!IpNumNm.Empty()){IpNumId=DevDefBs->AddIpNumNm(IpNumNm);}
28      if (!NodeNm.Empty()){NodeId=DevDefBs->AddNodeNm(NodeNm);}
29      if (!ZoneNm.Empty()){ZoneId=DevDefBs->AddZoneNm(ZoneNm);}
30      if (!LocNm.Empty()){LocId=DevDefBs->AddLocNm(LocNm);}
31      if (!ProjNm.Empty()){ProjId=DevDefBs->AddProjNm(ProjNm);}
32      if (!TypeNm.Empty()){TypeId=DevDefBs->AddTypeNm(TypeNm);}
33      PBtaDevDef DevDef=
34       TBtaDevDef::New(IpNumId, NodeId, ZoneId, LocId, ProjId, TypeId);
35      if (!DevDefBs->IsDevDef(DevDef)){
36        DevDefBs->AddDevDef(DevDef);
37      } else {
38        printf("  Duplicate [%s]\n", IpNumNm.CStr());
39      }
40    }
41    printf("\nDone.\n");
42    return DevDefBs;
43  }
44  TStr TBtaEventDat::GetNodeId() const {
45      return IsFld("NODE") ? GetFld("NODE") : "&nbsp;";
46  }
47  TStr TBtaEventDat::GetComponentId() const {
48      return IsFld("COMPONENTID") ? GetFld("COMPONENTID") : "&nbsp;";
49  }
50  TStr TBtaEventDat::GetFirstTm() const {
51      return IsFld("FIRSTOCCURRENCE") ? GetFld("FIRSTOCCURRENCE") : "&nbsp;";
52  }
53  TStr TBtaEventDat::GetLastTm() const {
54      return IsFld("LASTOCCURRENCE") ? GetFld("LASTOCCURRENCE") : "&nbsp;";
55  }
56  TStr TBtaEventDat::GetSeverity() const {
57      return IsFld("SEVERITY") ? GetFld("SEVERITY") : "&nbsp;";
58  }
59  TStr TBtaEventDat::GetSummary() const {
60      return IsFld("SUMMARY") ? GetFld("SUMMARY") : "&nbsp;";
61  }
62  TStr TBtaEventDat::GetIR() const {
63      return IsFld("IR") ? GetFld("IR") : "&nbsp;";
64  }
65  TBtaEvent::TBtaEvent() {}
66  TBtaEvent::TBtaEvent(const int& _IpNumId, const int& _ProjId, const int& _Severity,
67      const uint64& _FirstTmMSecs, const uint64& _LastTmMSecs, const int& _CaseId, 
68      const int& _BtaEventDatPt): 
69          IpNumId(_IpNumId), ProjId(_ProjId), Severity(_Severity), FirstTmMSecs(_FirstTmMSecs), 
70          LastTmMSecs(_LastTmMSecs), CaseId(_CaseId), BtaEventDatPt(_BtaEventDatPt) { }
71  TBtaEvent::TBtaEvent(TSIn& SIn): 
72      IpNumId(SIn), 
73      ProjId(SIn), 
74      Severity(SIn), 
75      FirstTmMSecs(SIn), 
76      LastTmMSecs(SIn), 
77      CaseId(SIn), 
78      BtaEventDatPt(SIn) { }
79  void TBtaEvent::Save(TSOut& SOut) const { 
80    IpNumId.Save(SOut); 
81    ProjId.Save(SOut); 
82    Severity.Save(SOut);
83    FirstTmMSecs.Save(SOut); 
84    LastTmMSecs.Save(SOut); 
85    CaseId.Save(SOut); 
86    BtaEventDatPt.Save(SOut); 
87  }
88  void TBtaEventBs::LoadValidColumnH() {
89      ValidColumnH.AddKey("IDENTIFIER");
90      ValidColumnH.AddKey("SERIAL");
91      ValidColumnH.AddKey("NODEALIAS");
92      ValidColumnH.AddKey("ALERTKEY");
93      ValidColumnH.AddKey("SEVERITY");
94      ValidColumnH.AddKey("SUMMARY");
95      ValidColumnH.AddKey("FIRSTOCCURRENCE");
96      ValidColumnH.AddKey("LASTOCCURRENCE");
97      ValidColumnH.AddKey("TALLY");
98      ValidColumnH.AddKey("PROJECT");
99      ValidColumnH.AddKey("CLASS");
100      ValidColumnH.AddKey("IP");
101      ValidColumnH.AddKey("SERVERSERIAL");
102      ValidColumnH.AddKey("IR");
103      ValidColumnH.AddKey("NODE");
104      ValidColumnH.AddKey("ALERTGROUP");
105      ValidColumnH.AddKey("MANAGER");
106      ValidColumnH.AddKey("AGENT");
107      ValidColumnH.AddKey("SUPPRESS");
108      ValidColumnH.AddKey("BUSINESSCRITICALITY");
109      ValidColumnH.AddKey("COMPONENTID");
110      ValidColumnH.AddKey("ALERTITEM");
111      ValidColumnH.AddKey("STATECHANGE");
112      ValidColumnH.AddKey("LOCATION");
113      ValidColumnH.AddKey("OWNERUID");
114      ValidColumnH.AddKey("ACKNOWLEDGED");
115      ValidColumnH.AddKey("ZONE");
116      ValidColumnH.AddKey("SERVERNAME");
117      ValidColumnH.AddKey("HELP");
118  }
119  void TBtaEventBs::LoadLastEventId() {
120      LastEventId = -1;
121      {TStr CountDumpSqlStr = "select count(id) from dump_buffer;";
122      if (!Query->ExeSql(CountDumpSqlStr)) { TExcept::Throw(Query->GetMsgStr()); }
123      POdbcTb CountDumpTb = TOdbcTb::New(Query);
124      EAssert(CountDumpTb->GetCols() == 1 && CountDumpTb->GetRows() == 1);
125      const int CountDump = CountDumpTb->GetRowVal(0, 0).GetInt();
126      if (CountDump > 0) { 
127          TStr MaxIdDumpSqlStr = "select max(id) from dump_buffer;";
128          if (!Query->ExeSql(MaxIdDumpSqlStr)) { TExcept::Throw(Query->GetMsgStr()); }
129          POdbcTb MaxIdDumpTb = TOdbcTb::New(Query);
130          EAssert(CountDumpTb->GetCols() == 1 && CountDumpTb->GetRows() == 1);
131          const int MaxIdDump = MaxIdDumpTb->GetRowVal(0, 0).GetInt();
132          LastEventId = TInt::GetMx(LastEventId, MaxIdDump);
133      }}
134      {TStr CountAlarmsSqlStr = "select count(id) from alarms;";
135      if (!Query->ExeSql(CountAlarmsSqlStr)) { TExcept::Throw(Query->GetMsgStr()); }
136      POdbcTb CountAlarmsTb = TOdbcTb::New(Query);
137      EAssert(CountAlarmsTb->GetCols() == 1 && CountAlarmsTb->GetRows() == 1);
138      const int CountAlarms = CountAlarmsTb->GetRowVal(0, 0).GetInt();
139      if (CountAlarms > 0) { 
140          TStr MaxIdAlarmsSqlStr = "select max(id) from alarms;";
141          if (!Query->ExeSql(MaxIdAlarmsSqlStr)) { TExcept::Throw(Query->GetMsgStr()); }
142          POdbcTb MaxIdAlarmsTb = TOdbcTb::New(Query);
143          EAssert(MaxIdAlarmsTb->GetCols() == 1 && MaxIdAlarmsTb->GetRows() == 1);
144          const int MaxIdAlarms = MaxIdAlarmsTb->GetRowVal(0, 0).GetInt();
145          LastEventId = TInt::GetMx(LastEventId, MaxIdAlarms);
146      }}
147      printf("LastEventId = %d\n", LastEventId.Val);
148  }
149  void TBtaEventBs::ParseBtaEventDat(const TBtaEventDat& EventDat, 
150          const int& BtaEventDatPt, TBtaEvent& Event) {
151      const TStrStrH FldNmValH = EventDat.GetFldNmToValH();
152      TStr IpNumNm = FldNmValH.IsKey("IP") ? FldNmValH.GetDat("IP") : "";
153      TStr FirstOccTmStr = FldNmValH.IsKey("FIRSTOCCURRENCE") ? FldNmValH.GetDat("FIRSTOCCURRENCE") : "";
154      TStr LastOccTmStr = FldNmValH.IsKey("LASTOCCURRENCE") ? FldNmValH.GetDat("LASTOCCURRENCE") : "";
155      TStr ProjNm = FldNmValH.IsKey("PROJECT") ? FldNmValH.GetDat("PROJECT") : "";
156      TStr SeverityStr = FldNmValH.IsKey("SEVERITY") ? FldNmValH.GetDat("SEVERITY") : "";
157      TStr CaseNm = FldNmValH.IsKey("IR") ? FldNmValH.GetDat("IR") : "";
158      uint64 FirstOccTmMSecs = 0;
159      try {
160          TTm FirstOccTm = TTm::GetTmFromWebLogDateTimeStr(FirstOccTmStr);
161          EAssert(FirstOccTm.IsDef());
162          FirstOccTmMSecs = TTm::GetMSecsFromTm(FirstOccTm);
163      } catch (...) { }
164      uint64 LastOccTmMSecs = 0;
165      try {
166          TTm LastOccTm = TTm::GetTmFromWebLogDateTimeStr(LastOccTmStr);
167          EAssert(LastOccTm.IsDef());
168          LastOccTmMSecs = TTm::GetMSecsFromTm(LastOccTm);
169      } catch (...) { }
170      const int IpNumId = DevDefBs->IsIpNumId(IpNumNm) ? DevDefBs->GetIpNumId(IpNumNm) : -1;
171      const int ProjId = DevDefBs->IsProjId(ProjNm) ? DevDefBs->GetProjId(ProjNm) : -1;
172      const int Severity = SeverityStr.IsInt() ? SeverityStr.GetInt() : -1;
173      const int CaseId = CaseNm.Empty() ? -1 : AddCase(CaseNm);
174      Event = TBtaEvent(IpNumId, ProjId, Severity,
175          FirstOccTmMSecs, LastOccTmMSecs, CaseId, BtaEventDatPt);
176  }
177  int TBtaEventBs::StoreEventDat(const TBtaEventDat& EventDat, const TStr& TableNm) {
178      const int EventId = GetNextEventId();
179      TChA ColumnNmChA, ColumnValChA;
180      const TStrStrH& FldNmToValH = EventDat.GetFldNmToValH();
181      int KeyId = FldNmToValH.FFirstKeyId();
182      while (FldNmToValH.FNextKeyId(KeyId)) {
183          const TStr& FldNm = FldNmToValH.GetKey(KeyId);
184          const TStr& FldVal = FldNmToValH[KeyId];
185          if (IsValidColumn(FldNm)) { 
186              if (!ColumnNmChA.Empty()) { 
187                  ColumnNmChA += ", "; 
188                  ColumnValChA += ", ";
189              }
190              ColumnNmChA += FldNm;
191              ColumnValChA += '"'; 
192              ColumnValChA += TOdbcQuery::GetSqlStr(FldVal); 
193              ColumnValChA += '"'; 
194          }
195      }
196      TStr InsertSqlStr = TStr::Fmt("INSERT INTO %s (Id, %s) VALUES (%d, %s);",
197          TableNm.CStr(), ColumnNmChA.CStr(), EventId, ColumnValChA.CStr());
198      if (!Query->ExeSql(InsertSqlStr)) { TExcept::Throw(Query->GetMsgStr()); }
199      return EventId;
200  }
201  bool TBtaEventBs::GetEventDat(const int& EventDatPt, 
202          const TStr& TableNm, TBtaEventDat& EventDat) const {
203      TStr SelectSqlStr = TStr::Fmt(
204          "SELECT * FROM %s WHERE id=%d LIMIT 1;", TableNm.CStr(), EventDatPt);
205      if (!Query->ExeSql(SelectSqlStr)) { TExcept::Throw(Query->GetMsgStr()); }
206      POdbcTb Table = TOdbcTb::New(Query);
207      EAssertR(Table->IsOk(), Table->GetMsgStr());
208      EventDat.Clr();
209      if (Table->GetRows() > 0) {
210          for (int ColN = 0; ColN < Table->GetCols(); ColN++) {
211              TStr ColNm = Table->GetColNm(ColN).GetUc();
212              TStr RowVal = Table->GetRowVal(0, ColN);
213              if (!RowVal.Empty()) { EventDat.AddFld(ColNm, RowVal); }
214          }
215      }
216      return (Table->GetRows() > 0);
217  }
218  int TBtaEventBs::AddCase(const TStr& CaseNm) {
219      const int CaseId = CaseNmFqH.AddKey(CaseNm);
220      CaseNmFqH[CaseId]++;
221      return CaseId;
222  }
223  TBtaEventBs::TBtaEventBs(const PBtaDevDefBs& _DevDefBs, 
224          const POdbcDb& _OdbcDb, const int& ExpEvents) { 
225      DevDefBs = _DevDefBs; 
226      if (ExpEvents > 0) { EventV.Gen(ExpEvents, 0); }
227      OdbcDb = _OdbcDb; Query = TOdbcQuery::New(OdbcDb);
228      LoadValidColumnH(); LoadLastEventId();
229  }
230  TBtaEventBs::TBtaEventBs(TSIn& SIn, const POdbcDb& _OdbcDb) {
231      printf("Loading events ... ");
232      DevDefBs = PBtaDevDefBs(SIn); printf("(1)"); 
233      EventV.Load(SIn); printf("(2)");
234      CaseNmFqH.Load(SIn); printf("(3)\n");
235      OdbcDb = _OdbcDb; Query = TOdbcQuery::New(OdbcDb);
236      LoadValidColumnH(); LoadLastEventId();
237  }
238  void TBtaEventBs::Save(TSOut& SOut) const {
239      DevDefBs.Save(SOut); 
240      EventV.Save(SOut); 
241      CaseNmFqH.Save(SOut);
242  }
243  void TBtaEventBs::GetEventDat(const int& EventDatPt, TBtaEventDat& EventDat) const {
244      const bool DumpBufferP = GetEventDat(EventDatPt, "dump_buffer", EventDat);
245      if (!DumpBufferP) { GetEventDat(EventDatPt, "alarms", EventDat); }    
246  }
247  int TBtaEventBs::GetNextEvent(const int& StartEventN, const int& IpNumId) {
248      int EventN = StartEventN; const int Events = EventV.Len();
249      while (EventN < Events) {
250          if (EventV[EventN].GetIpNumId() == IpNumId) { return EventN; }
251          EventN++;
252      }
253      return -1;
254  }
255  void TBtaEventBs::GetMostActiveProjs(const int64& TimeWnd, 
256          const int& EventWnd, const int& MnSeverity, TIntKdV& ProjIdFqV) {
257      TIntH ProjEventsH;
258      const int64 NowTmMSec = GetLastEvent().GetFirstTmMSecs();
259      const int Events = GetEvents(); int ProcEventN = 0;
260      for (int EventN = Events - 1; EventN >= 0; EventN--) {
261          const TBtaEvent& Event = GetEvent(EventN);
262          const int IpNumId = Event.GetIpNumId();
263          const int ProjId = Event.GetProjId();
264          const int64 EventTmMSec = Event.GetFirstTmMSecs();
265          if (EventTmMSec < NowTmMSec) { 
266              const int64 TmMSecDiff = NowTmMSec - EventTmMSec;
267              if (TmMSecDiff > TimeWnd) { break; }
268          }
269          if (IpNumId == -1 || ProjId == -1) { continue; }
270          if (Event.GetSeverity() < MnSeverity) { continue; }
271          if (ProcEventN > EventWnd) { break; }
272          ProjEventsH.AddDat(ProjId)++;
273          ProcEventN++;
274      }
275      ProjEventsH.SortByDat(false); ProjIdFqV.Clr();
276      int KeyId = ProjEventsH.FFirstKeyId();
277      while (ProjEventsH.FNextKeyId(KeyId)) {
278          const int ProjId = ProjEventsH.GetKey(KeyId);
279          const int Events = ProjEventsH[KeyId];
280          ProjIdFqV.Add(TIntKd(ProjId, Events));
281      }
282  }
283  int TBtaEventBs::AddBtEvent(const TBtaEventDat& EventDat, const bool& BatchP) {
284      const int BtaEventDatPt = StoreEventDat(EventDat, BatchP ? "alarms" : "dump_buffer");
285      TBtaEvent Event; ParseBtaEventDat(EventDat, BtaEventDatPt, Event);
286      return AddEvent(Event);
287  }
288  void TBtaEventBs::AddNewBuffer(TIntV& EventIdV) {
289      EventIdV.Clr();
290      forever {
291          TStr SelectSqlStr = TStr::Fmt("SELECT * FROM new_buffer LIMIT 100;");
292          if (!Query->ExeSql(SelectSqlStr)) { TExcept::Throw(Query->GetMsgStr()); }
293          POdbcTb Table = TOdbcTb::New(Query);
294          EAssertR(Table->IsOk(), Table->GetMsgStr());
295          const int Rows = Table->GetRows();
296          const int Cols = Table->GetCols();
297          if (Rows == 0) { break; }
298          for (int RowN = 0; RowN < Rows; RowN++) {
299              TStr BufferId;
300              TBtaEventDat EventDat;       
301              for (int ColN = 0; ColN < Table->GetCols(); ColN++) {
302                  TStr ColNm = Table->GetColNm(ColN).GetUc();
303                  TStr RowVal = Table->GetRowVal(RowN, ColN);
304                  if (ColNm == "ID") { BufferId = RowVal; } 
305                  else if (!RowVal.Empty()) { EventDat.AddFld(ColNm, RowVal); }
306              }
307              EventIdV.Add(AddBtEvent(EventDat, false));
308              TStr DeleteSqlStr = "DELETE FROM new_buffer WHERE id=" + BufferId + ";";
309              if (!Query->ExeSql(DeleteSqlStr)) { TExcept::Throw(Query->GetMsgStr()); }
310          }
311      }
312  }
313  void TBtaEventBs::SaveDumpBuffer() {
314      TStr InsertSqlStr = "INSERT INTO alarms SELECT * FROM dump_buffer;";
315      if (!Query->ExeSql(InsertSqlStr)) { TExcept::Throw(Query->GetMsgStr()); }
316      TStr TruncateSqlStr = "TRUNCATE TABLE dump_buffer;";
317      if (!Query->ExeSql(TruncateSqlStr)) { TExcept::Throw(Query->GetMsgStr()); }
318  }
319  void TBtaEventBs::RescueDumpBuffer(TIntV& EventIdV) {
320      TStr SqlStr = "SELECT * FROM dump_buffer;";
321      if (!Query->ExeSql(SqlStr)) { TExcept::Throw(Query->GetMsgStr()); }
322      POdbcTb Table = TOdbcTb::New(Query);
323      EAssertR(Table->IsOk(), Table->GetMsgStr());
324      const int Rows = Table->GetRows();
325      const int Cols = Table->GetCols();
326      printf("Found %d non-archived alarms from previous run.\n", Rows);
327      EventIdV.Clr();
328      for (int RowN = 0; RowN < Rows; RowN++) {
329          TStr EventDatIdStr;
330          TBtaEventDat EventDat;       
331          for (int ColN = 0; ColN < Table->GetCols(); ColN++) {
332              TStr ColNm = Table->GetColNm(ColN).GetUc();
333              TStr RowVal = Table->GetRowVal(RowN, ColN);
334              if (ColNm == "ID") { EventDatIdStr = RowVal; } 
335              else if (!RowVal.Empty()) { EventDat.AddFld(ColNm, RowVal); }
336          }
337          EAssertR(EventDatIdStr.IsInt(), EventDatIdStr);
338          TBtaEvent Event; 
339          ParseBtaEventDat(EventDat, EventDatIdStr.GetInt(), Event);
340          EventIdV.Add(AddEvent(Event));
341      }
342  }
343  PBtaEventBs TBtaEventBs::LoadBtTxt(const PBtaDevDefBs& DevDefBs, const TStr& TxtFNm, 
344          const POdbcDb& OdbcDb, const int& ExpEvents, const int& Offset) { 
345      printf("Loading BTAlarms-Data from '%s'...\n", TxtFNm.CStr());
346      PBtaEventBs EventBs = TBtaEventBs::New(DevDefBs, OdbcDb, ExpEvents);
347      PSIn SIn = TFIn::New(TxtFNm); char SsCh=' ';
348      TStrV FldNmV; TSs::LoadTxtFldV(ssfTabSep, SIn, SsCh, FldNmV, false, false);
349      TStrV FldValV; int Recs = 0;
350      while (!SIn->Eof() && (EventBs->GetEvents() != ExpEvents)){
351          Recs++; if (Recs%1000 == 0){printf("  %d / %d\r", EventBs->GetEvents(), Recs);}
352          TSs::LoadTxtFldV(ssfTabSep, SIn, SsCh, FldValV, false, false);
353          IAssert(FldNmV.Len() == FldValV.Len());
354          if (Offset > Recs) { continue; }
355          TBtaEventDat EventDat;
356          for (int FldN = 0; FldN < FldValV.Len(); FldN++) {
357              if (!FldValV[FldN].Empty()) { 
358                  EventDat.AddFld(FldNmV[FldN], FldValV[FldN]); }
359          }
360          EventBs->AddBtEvent(EventDat, true);
361      }
362      printf("  %d / %d \nDone.\n", EventBs->GetEvents(), Recs);
363      return EventBs;
364  }
365  PBtaEventBs TBtaEventBs::LoadBankTxt(const PBtaDevDefBs& DevDefBs, 
366          const TStr& InFPath, const POdbcDb& OdbcDb, const int& ExpEvents) {
367      const int ProjId = DevDefBs->AddProjNm("default");
368      PBtaEventBs EventBs = TBtaEventBs::New(DevDefBs, OdbcDb, ExpEvents);
369      TFFile FFile(InFPath, "", false); 
370      TStr InFNm; int FileCount = 1;
371      while (FFile.Next(InFNm)) {
372          printf("(%d) Loading %s ...\n", FileCount, InFNm.CStr()); FileCount++;
373          TFIn FIn(InFNm); int Events = 0;
374          TStr LnStr, Rest1, Rest2;
375          while (FIn.GetNextLn(LnStr)) {
376              if (LnStr.IsWs()) { continue; }
377              if (Events % 1000 == 0) { printf("%d\r", Events); }
378              LnStr.ChangeStr("  ", " ");
379              TStr MonthStr; LnStr.SplitOnCh(MonthStr, ' ', Rest1);
380              TStr DayStr; Rest1.SplitOnCh(DayStr, ' ', Rest2);
381              TStr TimeStr; Rest2.SplitOnCh(TimeStr, ' ', Rest1);
382              TStr DeviceNm; Rest1.SplitOnCh(DeviceNm, ' ', Rest2);
383              TStr EventTxt = Rest2;
384              const int Year = 2007;
385              const int Month = TTmInfo::GetMonthN(MonthStr);
386              if (Month == -1) { printf("MonthStr: %s\n", MonthStr.CStr()); continue; }
387              if (!DayStr.IsInt()) { printf("DayStr: %s\n", DayStr.CStr()); continue; }
388              const int Day = DayStr.GetInt();
389              if (Day < 0 || Day > 31) { printf("Day: %d\n", Day); continue; }
390              TStrV TimePartV; TimeStr.SplitOnAllCh(':', TimePartV);
391              if (TimePartV.Len() != 3) { printf("TimePartV.Len: %d\n", TimePartV.Len()); continue; };
392              if (!TimePartV[0].IsInt()) { printf("TimePartV[0]: %s\n", TimePartV[0].CStr()); continue; }
393              if (!TimePartV[1].IsInt()) { printf("TimePartV[1]: %s\n", TimePartV[1].CStr()); continue; }
394              if (!TimePartV[2].IsInt()) { printf("TimePartV[2]: %s\n", TimePartV[2].CStr()); continue; }
395              const int Hour = TimePartV[0].GetInt();
396              const int Minute = TimePartV[1].GetInt();
397              const int Second = TimePartV[2].GetInt();
398              if (Hour < 0 || Hour > 23) { printf("Hour: %d\n", Hour); continue; }
399              if (Minute < 0 || Minute > 59) { printf("Minute: %d\n", Minute); continue; }
400              if (Second < 0 || Second > 59) { printf("Second: %d\n", Second); continue; }
401              TTm EventTime(Year, Month, Day, -1, Hour, Minute, Second);
402              if (!DevDefBs->IsIpNumId(DeviceNm)) { DevDefBs->AddIpNumNm(DeviceNm); }
403              const int IpNumId = DevDefBs->GetIpNumId(DeviceNm);
404              const int Severity = 3;
405              TBtaEventDat EventDat; 
406              EventDat.AddFld("FIRSTOCCURRENCE", EventTime.GetWebLogDateTimeStr());
407              EventDat.AddFld("LASTOCCURRENCE", EventTime.GetWebLogDateTimeStr());
408              EventDat.AddFld("SEVERITY", TInt(Severity).GetStr());
409              EventDat.AddFld("SUMMARY", EventTxt);
410              const int BtaEventDatPt = EventBs->StoreEventDat(EventDat, "alarms");
411              TBtaEvent Event(IpNumId, ProjId, Severity, TTm::GetMSecsFromTm(EventTime), 
412                  TTm::GetMSecsFromTm(EventTime), -1, BtaEventDatPt);
413              EventBs->AddEvent(Event); Events++;
414          }
415          printf("%d\n", Events);
416      }
417      printf("All Events: %d\n", EventBs->GetEvents());
418      return EventBs;
419  }
420  int TBtaCorrBs::SumFqV(const TIntH& IdFqH) const {
421      int Sum = 0, KeyId = IdFqH.FFirstKeyId();
422      while (IdFqH.FNextKeyId(KeyId)) { Sum += IdFqH[KeyId]; }
423      return Sum;
424  }
425  int TBtaCorrBs::CountEvents(const TIntV& EventV, const int& MxEventId) const {
426      int Events = 0;
427      for (int EventN = 0; EventN < EventV.Len(); EventN++) {
428          if (EventV[EventN] <= MxEventId) { Events++; }
429      }
430      return Events;
431  }
432  int TBtaCorrBs::CountEvents(const TIntPrV& EventPrV, const int& MxEventId) const {
433      int Events = 0;
434      for (int EventPrN = 0; EventPrN < EventPrV.Len(); EventPrN++) {
435          const TIntPr& Pr = EventPrV[EventPrN];
436          if (Pr.Val1 <= MxEventId && Pr.Val2 <= MxEventId) { Events++; }
437      }
438      return Events;
439  }
440  TBtaCorrBs::TBtaCorrBs(const int& _MnSeverity, const int& _MxEvents, 
441          const int& _MxEventWnd, const int64& _MxTmMSecWnd) {
442      MnSeverity = _MnSeverity; MxEvents = _MxEvents;
443      MxEventWnd = _MxEventWnd; MxTmMSecWnd = _MxTmMSecWnd;
444      RecentEventV.Gen(MxEventWnd);
445      RecentEventV.PutAll(-1);
446      NextEventN = 0;
447  }
448  TBtaCorrBs::TBtaCorrBs(TSIn& SIn) {
449      printf("Loading Correlation Parameters ... ");
450      MnSeverity.Load(SIn); printf("<1>"); 
451      MxEvents.Load(SIn); printf("<2>"); 
452      MxEventWnd.Load(SIn); printf("<3>"); 
453      MxTmMSecWnd.Load(SIn); printf("<4>\n"); 
454      printf("Loading Alarm Counts ... ");
455      IpNumIdEvents.Load(SIn); printf("<1>"); 
456      ProjIdEvents.Load(SIn); printf("<2>");
457      IpNumIdToEventVH.Load(SIn); printf("<3>"); 
458      ProjIdToEventVH.Load(SIn); printf("<4>\n");
459      printf("Loading Alarm Pair Counts ... ");
460      IpNumIdPrEvents.Load(SIn); printf("<1>"); 
461      ProjIdPrEvents.Load(SIn); printf("<2>\n");
462      printf("Loading Alarm Correlations ... ");
463      IpNumIdPrToEventPrVH.Load(SIn); printf("<1>"); 
464      ProjIdPrToEventPrVH.Load(SIn); printf("<2>"); 
465      IpNumIdToCorrIpNumIdFqHH.Load(SIn); printf("<3>"); 
466      ProjIdToCorrProjIdFqHH.Load(SIn); printf("<4>\n"); 
467      printf("Loading Alarm Backward Correlations ... ");
468      CorrIpNumIdToIpNumIdFqHH.Load(SIn); printf("<1>"); 
469      CorrProjIdToProjIdFqHH.Load(SIn); printf("<2>\n"); 
470      printf("Loading Mappings ... ");
471      IpNumIdToProjIdH.Load(SIn); printf("<1>"); 
472      ProjIdToIpNumIdVH.Load(SIn); printf("<2>"); 
473      CaseIdToEventIdVH.Load(SIn); printf("<3>\n"); 
474      printf("Loading Recent Alarms ... ");
475      NextEventN.Load(SIn); printf("<1>"); 
476      RecentEventV.Load(SIn); printf("<2>\n");        
477  }
478  void TBtaCorrBs::Save(TSOut& SOut) const {
479      MnSeverity.Save(SOut);  
480      MxEvents.Save(SOut);  
481      MxEventWnd.Save(SOut);  
482      MxTmMSecWnd.Save(SOut);  
483      IpNumIdEvents.Save(SOut);  
484      ProjIdEvents.Save(SOut); 
485      IpNumIdToEventVH.Save(SOut);  
486      ProjIdToEventVH.Save(SOut); 
487      IpNumIdPrEvents.Save(SOut);  
488      ProjIdPrEvents.Save(SOut);  
489      IpNumIdPrToEventPrVH.Save(SOut);  
490      ProjIdPrToEventPrVH.Save(SOut);  
491      IpNumIdToCorrIpNumIdFqHH.Save(SOut);  
492      ProjIdToCorrProjIdFqHH.Save(SOut);  
493      CorrIpNumIdToIpNumIdFqHH.Save(SOut);  
494      CorrProjIdToProjIdFqHH.Save(SOut);  
495      IpNumIdToProjIdH.Save(SOut);  
496      ProjIdToIpNumIdVH.Save(SOut);  
497      CaseIdToEventIdVH.Save(SOut);  
498      NextEventN.Save(SOut);  
499      RecentEventV.Save(SOut);  
500  }
501  void TBtaCorrBs::AddEventBs(const PBtaEventBs& BtaEventBs) {
502      printf("Processing events ...\n");
503      int Events = BtaEventBs->GetEvents(), Skiped = 0; int64 MemUsed = 0;
504      int MxEventN = (MxEvents == -1) ? Events : TInt::GetMn(MxEvents, Events);
505      for (int EventN = 0; EventN < MxEventN; EventN++){
506          if (EventN % 100000 == 0) {
507              const TBtaEvent& Event = BtaEventBs->GetEvent(EventN);
508              TStr TmStr = Event.GetFirstTm().GetWebLogDateTimeStr();
509              printf("%dk / %dk (Dev: %dk, Corr: %dk, Date: %s)\n", 
510                  EventN/1000, MxEventN/1000, IpNumIdEvents/1000, 
511                  IpNumIdPrEvents/1000, TmStr.CStr());
512          }
513          if (EventN % 1000000 == 0) {
514              printf("  IpNumIdToEventVH     : %5dk : %sB\n", IpNumIdToEventVH.Len()/1000, 
515                  TUInt64::GetMegaStr(IpNumIdToEventVH.GetMemUsed()).CStr());
516              printf("  ProjIdToEventVH      : %6d : %sB\n", ProjIdToEventVH.Len(), 
517                  TUInt64::GetMegaStr(ProjIdToEventVH.GetMemUsed()).CStr());
518              printf("  IpNumIdToProjIdH     : %5dk : %sB\n", IpNumIdToProjIdH.Len()/1000, 
519                  TUInt64::GetMegaStr(IpNumIdToProjIdH.GetMemUsed()).CStr());
520              printf("  ProjIdToIpNumIdVH    : %6d : %sB\n", ProjIdToIpNumIdVH.Len(), 
521                  TUInt64::GetMegaStr(ProjIdToIpNumIdVH.GetMemUsed()).CStr());
522              printf("  IpNumIdPrToEventPrVH : %5dk : %sB\n", IpNumIdPrToEventPrVH.Len()/1000, 
523                  TUInt64::GetMegaStr(IpNumIdPrToEventPrVH.GetMemUsed()).CStr());
524              printf("  ProjIdPrToEventPrVH  : %6d : %sB\n", ProjIdPrToEventPrVH.Len(), 
525                  TUInt64::GetMegaStr(ProjIdPrToEventPrVH.GetMemUsed()).CStr());
526          }
527          const TBtaAddEventRes Res = AddEvent(BtaEventBs, EventN);
528          if (Res == baerUnknowIpNum || Res == baerUnknowProjId) { Skiped++; }
529      }
530      const TBtaEvent& Event = BtaEventBs->GetEvent(MxEventN - 1);
531      TStr TmStr = Event.GetFirstTm().GetWebLogDateTimeStr();
532      printf("%dk / %dk (Dev: %dk, Corr: %dk, Date: %s)\n", 
533          MxEventN/1000, MxEventN/1000, IpNumIdEvents/1000, 
534          IpNumIdPrEvents/1000, TmStr.CStr());
535      printf("  IpNumIdToEventVH     : %5dk : %sB\n", IpNumIdToEventVH.Len()/1000, 
536          TUInt64::GetMegaStr(IpNumIdToEventVH.GetMemUsed()).CStr());
537      printf("  ProjIdToEventVH      : %6d : %sB\n", ProjIdToEventVH.Len(), 
538          TUInt64::GetMegaStr(ProjIdToEventVH.GetMemUsed()).CStr());
539      printf("  IpNumIdToProjIdH     : %5dk : %sB\n", IpNumIdToProjIdH.Len()/1000, 
540          TUInt64::GetMegaStr(IpNumIdToProjIdH.GetMemUsed()).CStr());
541      printf("  ProjIdToIpNumIdVH    : %6d : %sB\n", ProjIdToIpNumIdVH.Len(), 
542          TUInt64::GetMegaStr(ProjIdToIpNumIdVH.GetMemUsed()).CStr());
543      printf("  IpNumIdPrToEventPrVH : %5dk : %sB\n", IpNumIdPrToEventPrVH.Len()/1000, 
544          TUInt64::GetMegaStr(IpNumIdPrToEventPrVH.GetMemUsed()).CStr());
545      printf("  ProjIdPrToEventPrVH  : %6d : %sB\n", ProjIdPrToEventPrVH.Len(), 
546          TUInt64::GetMegaStr(ProjIdPrToEventPrVH.GetMemUsed()).CStr());
547      printf("\nDone.\n");
548  }
549  TBtaCorrBs::TBtaAddEventRes TBtaCorrBs::AddEvent(
550          const PBtaEventBs& BtaEventBs, const int& EventN) {
551      const TBtaEvent& Event = BtaEventBs->GetEvent(EventN);
552      const int IpNumId = Event.GetIpNumId();
553      const int ProjId = Event.GetProjId();
554      const uint64 TmMSec = Event.GetFirstTmMSecs();
555      if (IpNumId == -1) { return baerUnknowIpNum; }
556      if (ProjId == -1) { return baerUnknowProjId; }
557      const int Severity = Event.GetSeverity();
558      if (Severity < MnSeverity) { return baerLowSeverity; }
559      IpNumIdToEventVH.AddDat(IpNumId).Add(EventN); IpNumIdEvents++;
560      ProjIdToEventVH.AddDat(ProjId).Add(EventN); ProjIdEvents++;
561      IpNumIdToProjIdH.AddDat(IpNumId) = ProjId;
562      ProjIdToIpNumIdVH.AddDat(ProjId).AddMerged(IpNumId);
563      const int CaseId = Event.GetCaseId();
564      if (CaseId != -1) { CaseIdToEventIdVH.AddDat(CaseId).Add(EventN); }
565      const int RecentEvents = RecentEventV.Len();
566      for (int RecentEventN = 0; RecentEventN < RecentEvents; RecentEventN++) {
567          const int CorrEventN = RecentEventV[RecentEventN];
568          if (CorrEventN == -1) { continue; }
569          const TBtaEvent& CorrEvent = BtaEventBs->GetEvent(CorrEventN); 
570          const uint64 CorrTmMSec = CorrEvent.GetFirstTmMSecs();
571          if (MxTmMSecWnd > 0) { 
572              if ((TmMSec > CorrTmMSec) && ((TmMSec - CorrTmMSec) >  MxTmMSecWnd)) { continue; }
573              if ((TmMSec < CorrTmMSec) && ((CorrTmMSec - TmMSec) >  MxTmMSecWnd)) { continue; }
574          }        
575          const int CorrIpNumId = CorrEvent.GetIpNumId();
576          const int CorrProjId = CorrEvent.GetProjId();
577          IAssertR((IpNumId != -1) && (CorrIpNumId != -1), TStr::Fmt("(%d,%d)", IpNumId, CorrIpNumId));
578          IAssertR((ProjId != -1) && (CorrProjId != -1), TStr::Fmt("(%d,%d)", ProjId, CorrProjId));
579          IAssert(CorrEvent.GetSeverity() >= MnSeverity);
580          if (TmMSec < CorrTmMSec) { 
581              TIntPrV& EventPrV = IpNumIdPrToEventPrVH.AddDat(TIntPr(IpNumId, CorrIpNumId));
582              EventPrV.Add(TIntPr(EventN, CorrEventN)); IpNumIdPrEvents++;
583              IpNumIdToCorrIpNumIdFqHH.AddDat(IpNumId).AddDat(CorrIpNumId)++;
584              CorrIpNumIdToIpNumIdFqHH.AddDat(CorrIpNumId).AddDat(IpNumId)++;
585          } else {
586              TIntPrV& EventPrV = IpNumIdPrToEventPrVH.AddDat(TIntPr(CorrIpNumId, IpNumId));
587              EventPrV.Add(TIntPr(CorrEventN, EventN)); IpNumIdPrEvents++;
588              IpNumIdToCorrIpNumIdFqHH.AddDat(CorrIpNumId).AddDat(IpNumId)++;
589              CorrIpNumIdToIpNumIdFqHH.AddDat(IpNumId).AddDat(CorrIpNumId)++;
590          }
591          if (ProjId != CorrProjId) {
592              if (TmMSec < CorrTmMSec) { 
593                  TIntPrV& EventPrV = ProjIdPrToEventPrVH.AddDat(TIntPr(ProjId, CorrProjId));
594                  EventPrV.Add(TIntPr(EventN, CorrEventN)); ProjIdPrEvents++;
595                  ProjIdToCorrProjIdFqHH.AddDat(ProjId).AddDat(CorrProjId)++;
596                  CorrProjIdToProjIdFqHH.AddDat(CorrProjId).AddDat(ProjId)++;
597              } else {
598                  TIntPrV& EventPrV = ProjIdPrToEventPrVH.AddDat(TIntPr(CorrProjId, ProjId));
599                  EventPrV.Add(TIntPr(CorrEventN, EventN)); ProjIdPrEvents++;
600                  ProjIdToCorrProjIdFqHH.AddDat(CorrProjId).AddDat(ProjId)++;
601                  CorrProjIdToProjIdFqHH.AddDat(ProjId).AddDat(CorrProjId)++;
602              }
603          }
604      }
605      RecentEventV[NextEventN] = EventN;
606      NextEventN++; NextEventN = NextEventN % RecentEvents;
607      return baerOk;
608  }
609  TStr TBtaCorrBs::GetErrorMsgStr(const TBtaCorrBs::TBtaAddEventRes& ErrorCode) const {
610      if (ErrorCode == TBtaCorrBs::baerLowSeverity) { return "To low severity!"; }
611      if (ErrorCode == TBtaCorrBs::baerUnknowIpNum) { return "Unknown IpNum!"; }
612      if (ErrorCode == TBtaCorrBs::baerUnknowProjId) { return "Unknown ProjId!"; }
613      if (ErrorCode == TBtaCorrBs::baerOk) { return "Event OK!"; }
614      return "Unknown error when adding event to CorrBs!";
615  }
616  double TBtaCorrBs::ProbIpNumId(const int& IpNumId) const {
617      const int IpNumIds = IpNumIdToEventVH.Len();
618      const int IpNumIdFq = IpNumIdToEventVH.IsKey(IpNumId) ?
619          IpNumIdToEventVH.GetDat(IpNumId).Len() : 0;
620      return double(IpNumIdFq + 1) / double(IpNumIdEvents + IpNumIds);
621  }
622  double TBtaCorrBs::ProbIpNumIdAndCorrIpNumId(const int& IpNumId, const int& CorrIpNumId) const {
623      TIntPr IpNumPr(IpNumId, CorrIpNumId), RevIpNumPr(CorrIpNumId, IpNumId);
624      const int IpNumIdPrFq = IpNumIdPrToEventPrVH.IsKey(IpNumPr) ?
625          IpNumIdPrToEventPrVH.GetDat(IpNumPr).Len() : 0; 
626      const int RevIpNumIdPrFq = IpNumIdPrToEventPrVH.IsKey(RevIpNumPr) ? 
627          IpNumIdPrToEventPrVH.GetDat(RevIpNumPr).Len() : 0; 
628      const int IpNumIds = IpNumIdToEventVH.Len();
629      const int AllIpNumIdPrs = IpNumIds*IpNumIds;
630      const double Prior = 1.0;
631      return (double(IpNumIdPrFq + RevIpNumIdPrFq) + Prior) / 
632          double(IpNumIdPrEvents + AllIpNumIdPrs);
633  }
634  double TBtaCorrBs::ProbCorrIpNumIdGivenIpNumId(const int& IpNumId, const int& CorrIpNumId) const {
635      const int IpNumIdFq = IpNumIdToEventVH.GetDat(IpNumId).Len();
636      const int CorrIpNumIdFq = IpNumIdToEventVH.GetDat(CorrIpNumId).Len();
637      if (CorrIpNumIdFq / IpNumIdFq > 10) { return 0.0; }
638      TIntPr IpNumPr(IpNumId, CorrIpNumId);
639      const int IpNumIdPrFq = IpNumIdPrToEventPrVH.GetDat(IpNumPr).Len(); 
640      const int AllIpNumIdPrs = SumFqV(IpNumIdToCorrIpNumIdFqHH.GetDat(IpNumId));
641      const int IpNumIds = IpNumIdToEventVH.Len();
642      return (double(IpNumIdPrFq) + 1.0) / double(AllIpNumIdPrs + IpNumIds);
643  }
644  double TBtaCorrBs::GetIpNumMxCorrIpNumProb(const int& IpNumId) const {
645      double MxCorrProb = 0.0;
646      const TIntH& CorrIdFqH = GetIpNumCorrIpNumH(IpNumId);
647      int CorrIdKeyId = CorrIdFqH.FFirstKeyId();
648      while (CorrIdFqH.FNextKeyId(CorrIdKeyId)) {
649          const int CorrIpNumId = CorrIdFqH.GetKey(CorrIdKeyId);
650          if (IsCorrIpNumId(CorrIpNumId)) {
651              const double CorrProb = ProbCorrIpNumIdGivenIpNumId(IpNumId, CorrIpNumId);
652              MxCorrProb = TFlt::GetMx(CorrProb, MxCorrProb);
653          }
654      }
655      return MxCorrProb;
656  }
657  double TBtaCorrBs::ProbIpNumId(const int& IpNumId, const int& MxEventId) const {
658      const int IpNumIds = IpNumIdToEventVH.Len();
659      const int IpNumIdFq = IpNumIdToEventVH.IsKey(IpNumId) ?
660          CountEvents(IpNumIdToEventVH.GetDat(IpNumId), MxEventId) : 0;
661      return double(IpNumIdFq + 1) / double((MxEventId + 1) + IpNumIds);
662  }
663  double TBtaCorrBs::ProbIpNumIdAndCorrIpNumId(const int& IpNumId, 
664          const int& CorrIpNumId, const int& MxEventId) const {
665      TIntPr IpNumPr(IpNumId, CorrIpNumId), RevIpNumPr(CorrIpNumId, IpNumId);
666      const int IpNumIdPrFq = IpNumIdPrToEventPrVH.IsKey(IpNumPr) ? 
667          CountEvents(IpNumIdPrToEventPrVH.GetDat(IpNumPr), MxEventId) : 0; 
668      const int RevIpNumIdPrFq = IpNumIdPrToEventPrVH.IsKey(RevIpNumPr) ?
669          CountEvents(IpNumIdPrToEventPrVH.GetDat(RevIpNumPr), MxEventId) : 0; 
670      const int IpNumIds = IpNumIdToEventVH.Len();
671      const int AllIpNumIdPrs = IpNumIds*IpNumIds;
672      const double Prior = 1.0;
673      return (double(IpNumIdPrFq + RevIpNumIdPrFq) + Prior) / 
674          double(IpNumIdPrEvents + AllIpNumIdPrs);
675  }
676  double TBtaCorrBs::ProbCorrIpNumIdGivenIpNumId(const int& IpNumId, 
677          const int& CorrIpNumId, const int& MxEventId) const {
678      const int AllIpNumIdPrs = SumFqV(IpNumIdToCorrIpNumIdFqHH.GetDat(IpNumId));
679      const int IpNumIds = IpNumIdToEventVH.Len();
680      const int IpNumIdFq = IpNumIdToEventVH.IsKey(IpNumId) ?
681          CountEvents(IpNumIdToEventVH.GetDat(IpNumId), MxEventId) : 0;
682      const int CorrIpNumIdFq = IpNumIdToEventVH.IsKey(CorrIpNumId) ?
683          CountEvents(IpNumIdToEventVH.GetDat(CorrIpNumId), MxEventId) : 0;
684      if ((IpNumIdFq == 0) || (CorrIpNumIdFq / IpNumIdFq > 10)) {
685          return 1.0 / double(AllIpNumIdPrs + IpNumIds);
686      } else {
687          TIntPr IpNumPr(IpNumId, CorrIpNumId);
688          const int IpNumIdPrFq = IpNumIdPrToEventPrVH.IsKey(IpNumPr) ?
689              CountEvents(IpNumIdPrToEventPrVH.GetDat(IpNumPr), MxEventId) : 0; 
690          return (double(IpNumIdPrFq) + 1.0) / double(AllIpNumIdPrs + IpNumIds);
691      }
692  }
693  double TBtaCorrBs::GetProjCorrProjProb(const int& ProjId, const int& CorrProjId) const {
694      const int CorrFq = ProjIdPrToEventPrVH.GetDat(TIntPr(ProjId, CorrProjId)).Len();
695      const double ForwardProb = double(CorrFq) / double(GetProjCorrProjFqs(ProjId));
696      const double BackwardProb = double(CorrFq) / double(GetCorrProjProjFqs(CorrProjId));
697      return ForwardProb * BackwardProb;
698  }
699  double TBtaCorrBs::GetProjMxCorrProjProb(const int& ProjId) const {
700      double MxCorrProb = 0.0;
701      const TIntH& CorrIdFqH = GetProjCorrProjH(ProjId);
702      int CorrIdKeyId = CorrIdFqH.FFirstKeyId();
703      while (CorrIdFqH.FNextKeyId(CorrIdKeyId)) {
704          const int CorrProjId = CorrIdFqH.GetKey(CorrIdKeyId);
705          if (IsCorrProjId(CorrProjId)) {
706              const double CorrProb = GetProjCorrProjProb(ProjId, CorrProjId);
707              MxCorrProb = TFlt::GetMx(CorrProb, MxCorrProb);
708          }
709      }
710      return MxCorrProb;
711  }
712  void TBtaCorrBs::GetIpNumCorrDevices(const int& IpNumId, const bool& SameProjP, 
713          const int& MxItems, TIntFltKdV& CorrIpNumIdProbV) const {
714      CorrIpNumIdProbV.Clr();
715      if (!IsIpNumId(IpNumId) || !IsIpNumProj(IpNumId)) { return; }
716      const int IpNumProjId = GetIpNumProjId(IpNumId);
717      double MxCorrProb = 0.0;
718      TVec<TIntBoolPr> CorrIpNumIdForwardV;
719      {const TIntH& ForwardCorrIdFqH = GetIpNumCorrIpNumH(IpNumId);
720      int ForwardCorrIdKeyId = ForwardCorrIdFqH.FFirstKeyId();
721      while (ForwardCorrIdFqH.FNextKeyId(ForwardCorrIdKeyId)) {
722          const int CorrIpNumId = ForwardCorrIdFqH.GetKey(ForwardCorrIdKeyId);
723          CorrIpNumIdForwardV.Add(TIntBoolPr(CorrIpNumId, true));
724      }}
725      {const TIntH& BackwardCorrIdFqH = GetCorrIpNumIpNumH(IpNumId);
726      int BackwardCorrIdKeyId = BackwardCorrIdFqH.FFirstKeyId();
727      while (BackwardCorrIdFqH.FNextKeyId(BackwardCorrIdKeyId)) {
728          const int CorrIpNumId = BackwardCorrIdFqH.GetKey(BackwardCorrIdKeyId);
729          CorrIpNumIdForwardV.Add(TIntBoolPr(CorrIpNumId, false));
730      }}
731      TVec<TFltIntBoolPrKd> CorrProbIpNumIdV;
732      for (int CorrIpNumIdN = 0; CorrIpNumIdN < CorrIpNumIdForwardV.Len(); CorrIpNumIdN++) {
733          const int CorrIpNumId = CorrIpNumIdForwardV[CorrIpNumIdN].Val1;
734          const bool ForwardP = CorrIpNumIdForwardV[CorrIpNumIdN].Val2;
735          if (IpNumId == CorrIpNumId) { continue; }
736          if (IsCorrIpNumId(CorrIpNumId) && IsIpNumProj(CorrIpNumId)) {
737              const int CorrIpNumProjId = GetIpNumProjId(CorrIpNumId);            
738              if (SameProjP && (IpNumProjId != CorrIpNumProjId)) { continue; }
739              if (!SameProjP && (IpNumProjId == CorrIpNumProjId)) { continue; }
740              const double CorrProb = ForwardP ? 
741                  ProbCorrIpNumIdGivenIpNumId(IpNumId, CorrIpNumId) :
742                  ProbCorrIpNumIdGivenIpNumId(CorrIpNumId, IpNumId);
743              if (CorrProb > 0.0) { 
744                  CorrProbIpNumIdV.Add(TFltIntBoolPrKd(
745                      CorrProb, TIntBoolPr(CorrIpNumId, ForwardP))); 
746              }
747              MxCorrProb = TFlt::GetMx(CorrProb, MxCorrProb);
748          }
749      }
750      CorrProbIpNumIdV.Sort(false);
751      const int Items = TInt::GetMn(CorrProbIpNumIdV.Len(), MxItems);
752      CorrIpNumIdProbV.Gen(Items, 0);
753      for (int ItemN = 0; ItemN < Items; ItemN++) {
754          const double CorrProb = CorrProbIpNumIdV[ItemN].Key;
755          const int CorrIpNumId = CorrProbIpNumIdV[ItemN].Dat.Val1;
756          const bool ForwardP = CorrProbIpNumIdV[ItemN].Dat.Val2;
757          if ((MxCorrProb / CorrProb) < 10.0) {
758              CorrIpNumIdProbV.Add(TIntFltKd(CorrIpNumId, 
759                  ForwardP ? CorrProb : -CorrProb));
760          }
761      }
762  }
763  void TBtaCorrBs::GetProjCorrDevices(const int& ProjId, 
764          const int& MxItems, TIntPrFltKdV& CorrIpNumIdPrProbV) const {
765      CorrIpNumIdPrProbV.Clr();
766      if (!IsProjIpNums(ProjId)) { return; }
767      double MxCorrProb = 0.0;
768      TFltIntIntTrV CorrProbIpNumPrV;
769      const TIntV& IpNumIdV = GetProjIpNumV(ProjId);
770      for (int IpNumIdN = 0; IpNumIdN < IpNumIdV.Len(); IpNumIdN++) {
771          const int IpNumId = IpNumIdV[IpNumIdN];
772          const TIntH& CorrIpFqH = GetIpNumCorrIpNumH(IpNumId);
773          int CorrIpKeyId = CorrIpFqH.FFirstKeyId(), CorrIpNums = 0;
774          while (CorrIpFqH.FNextKeyId(CorrIpKeyId)) {
775              const int CorrIpNumId = CorrIpFqH.GetKey(CorrIpKeyId);
776              if (IpNumId == CorrIpNumId) { continue; }
777              if (IsCorrIpNumId(CorrIpNumId) && IsIpNumProj(CorrIpNumId)) {
778                  const int CorrIpNumProjId = GetIpNumProjId(CorrIpNumId);            
779                  if (ProjId != CorrIpNumProjId) { continue; }
780                  const double CorrProb = 
781                      ProbCorrIpNumIdGivenIpNumId(IpNumId, CorrIpNumId);
782                  if (CorrProb > 0.0) { 
783                      CorrProbIpNumPrV.Add(TFltIntIntTr(
784                          CorrProb, IpNumId, CorrIpNumId)); 
785                  }
786                  MxCorrProb = TFlt::GetMx(CorrProb, MxCorrProb);
787                  CorrIpNums++;
788              }
789          }
790          printf("%d/%d [%5d / %5d]\r", IpNumIdN, IpNumIdV.Len(), CorrIpNums, CorrIpFqH.Len());
791      }
792      CorrProbIpNumPrV.Sort(false);
793      const int Items = TInt::GetMn(CorrProbIpNumPrV.Len(), MxItems);
794      CorrIpNumIdPrProbV.Gen(Items, 0);
795      for (int ItemN = 0; ItemN < Items; ItemN++) {
796          const double CorrProb = CorrProbIpNumPrV[ItemN].Val1;
797          const int IpNumId = CorrProbIpNumPrV[ItemN].Val2;
798          const int CorrIpNumId = CorrProbIpNumPrV[ItemN].Val3;
799          if ((MxCorrProb / CorrProb) < 10.0) {
800              CorrIpNumIdPrProbV.Add(TIntPrFltKd(
801                  TIntPr(IpNumId, CorrIpNumId), CorrProb));
802          }
803      }
804  }
805  void TBtaCorrBs::GetNextIpNumIdProb(const int& LastEventN, const int& ProjId,
806          const PBtaEventBs& BtaEventBs, const int& MxEventWnd, 
807          const int64& MxTmMSecWnd, TIntFltH& IpNumIdProbH) const {
808      IpNumIdProbH.Clr();
809      TBtaEventV EventWndV;
810      int EventWndN = LastEventN;
811      while (EventWndN >= 0) {
812          const TBtaEvent& Event = BtaEventBs->GetEvent(EventWndN); EventWndN--; 
813          if ((Event.GetIpNumId() == -1) || (Event.GetProjId() == -1)){ continue; }
814          if (Event.GetProjId() != ProjId) { continue; }
815          if (!EventWndV.Empty()) {
816              const int CountDiff = LastEventN - EventWndN;
817              const int64 TmMSecDiff = Event.GetFirstTmMSecs() - EventWndV[0].GetFirstTmMSecs();
818              if ((MxEventWnd > 0) && (CountDiff > MxEventWnd)) { break; }
819              if ((MxTmMSecWnd > 0) && (TmMSecDiff > MxTmMSecWnd)) { break; }
820          }
821          EventWndV.Add(Event);
822      }
823      if (EventWndV.Empty()) { return; } 
824      EventWndV.Reverse();
825      PBtaDevDefBs BtaDevDefBs = BtaEventBs->GetDevDefBs();
826      TIntH CandIpNumIdH;
827      for (int IpNumId = 0; IpNumId < BtaDevDefBs->GetIpNums(); IpNumId++) {
828          if (!IsIpNumProj(IpNumId)) { continue; };
829          if (GetIpNumProjId(IpNumId) != ProjId) { continue; };
830          for (int EventWndN = 0; EventWndN < EventWndV.Len(); EventWndN++) {
831              const int PrevIpNumId = EventWndV[EventWndN].GetIpNumId();
832              if (IsIpNumIdPrCorr(PrevIpNumId, IpNumId)) {
833                  CandIpNumIdH.AddDat(IpNumId) += 
834                      GetIpNumCorrIpNumPrEventV(PrevIpNumId, IpNumId).Len();
835              }
836          }
837      }
838      if (CandIpNumIdH.Empty()) { return; } 
839      TIntPrIntH WndIpNumPrH;
840      for (int FirstEventWndN = 0; FirstEventWndN < EventWndV.Len(); FirstEventWndN++) {
841          for (int SecondEventWndN = FirstEventWndN+1; SecondEventWndN < EventWndV.Len(); SecondEventWndN++) {
842              TBtaEvent FirstEvent = EventWndV[FirstEventWndN];
843              TBtaEvent SecondEvent = EventWndV[SecondEventWndN];
844              TIntPr WndIpNumIdPr(FirstEvent.GetIpNumId(), SecondEvent.GetIpNumId());
845              if (!WndIpNumPrH.IsKey(WndIpNumIdPr)) {
846                  WndIpNumPrH.AddDat(WndIpNumIdPr)++;
847              }
848          }
849      }
850      int CandKeyId = CandIpNumIdH.FFirstKeyId();
851      const int IpNumIds = IpNumIdToEventVH.Len();
852      const double IpNumIdPrs = double(IpNumIds*(IpNumIds - 1) / 2);
853      const double IpNumIdTrs = double(IpNumIds*(IpNumIds - 1)*(IpNumIds - 2) / 6);
854      while (CandIpNumIdH.FNextKeyId(CandKeyId)) {
855          const int CandIpNumId = CandIpNumIdH.GetKey(CandKeyId);
856          double CandProb = 0.0;
857          int WndKeyId = WndIpNumPrH.FFirstKeyId();
858          while (WndIpNumPrH.FNextKeyId(WndKeyId)) {
859              const int FirstIpNumId = WndIpNumPrH.GetKey(WndKeyId).Val1;
860              const int SecondIpNumId = WndIpNumPrH.GetKey(WndKeyId).Val2;
861              IAssertR(FirstIpNumId != -1, TInt::GetStr(FirstIpNumId));
862              IAssertR(SecondIpNumId != -1, TInt::GetStr(SecondIpNumId));
863              const double FirstSecondProb = ProbIpNumIdAndCorrIpNumId(
864                  FirstIpNumId, SecondIpNumId, LastEventN);
865              const double FirstCandProb = ProbIpNumIdAndCorrIpNumId(
866                  FirstIpNumId, CandIpNumId, LastEventN);
867              const double SecondCandProb = ProbIpNumIdAndCorrIpNumId(
868                  SecondIpNumId, CandIpNumId, LastEventN);
869              const double Prob = FirstSecondProb*FirstCandProb*SecondCandProb;
870              CandProb += Prob;
871          }
872          IpNumIdProbH.AddDat(CandIpNumId, CandProb);
873      }   
874  }
875  void TBtaCorrBs::GetListOfFutureIpNums(const PBtaEventBs& BtaEventBs, 
876          const int& LastEventN, const int& MxEventWnd, const int64& MxTmMSecWnd, 
877          TIntH& FutureIpNumH) const {
878      const int MxEvents = TInt::GetMn(BtaEventBs->GetEvents(), LastEventN + MxEventWnd + 1);
879      const uint64 FirstTmMSec = BtaEventBs->GetEvent(LastEventN+1).GetFirstTmMSecs();
880      int EventWndN = LastEventN+1;
881      while (EventWndN < MxEvents) {
882          const TBtaEvent& Event = BtaEventBs->GetEvent(EventWndN); EventWndN++; 
883          if ((Event.GetIpNumId() == -1) || (Event.GetProjId() == -1)){ continue; }
884          const int CountDiff = EventWndN - LastEventN - 1;
885          const int64 TmMSecDiff = Event.GetFirstTmMSecs() - FirstTmMSec;
886          if ((MxEventWnd > 0) && (CountDiff > MxEventWnd)) { break; }
887          if ((MxTmMSecWnd > 0) && (TmMSecDiff > MxTmMSecWnd)) { break; }
888          FutureIpNumH.AddDat(Event.GetIpNumId())++;
889      }    
890  }
891  void TBtaCorrBs::GetPredStat(const PBtaEventBs& BtaEventBs, const int& MxEvents, 
<span onclick='openModal()' class='match'>892          const int& MxEventWnd, const int64& MxTmMSecWnd, const int& MxEvalWnd) const {
893      const int TopRank = 100; TMomV TopMomV(TopRank), TimeMomV(TopRank);
894      for (int RankN = 0; RankN < TopRank; RankN++) {
</span>895          TopMomV[RankN] = TMom::New(); TimeMomV[RankN] = TMom::New(); }
896      TRnd Rnd(1);
897      for (int EventIdN = 0; EventIdN < MxEvents; EventIdN++) {
898          printf("%d / %d\r", EventIdN+1, MxEvents);
899          const int EventId = Rnd.GetUniDevInt(BtaEventBs->GetEvents() - MxEvalWnd);
900          const TBtaEvent& Event = BtaEventBs->GetEvent(EventId);
901          TIntFltH IpNumIdProbH;
902          GetNextIpNumIdProb(EventId, Event.GetProjId(),
903              BtaEventBs, MxEventWnd, MxTmMSecWnd, IpNumIdProbH);
904          if (!IpNumIdProbH.Empty()) {
905              TFltIntPrV ProbIpNumIdV;
906              IpNumIdProbH.GetDatKeyPrV(ProbIpNumIdV);
907              ProbIpNumIdV.Sort(false);
908              TIntH FutureIpNumH;
909              GetListOfFutureIpNums(BtaEventBs, EventId+1, MxEvalWnd, -1, FutureIpNumH);
910              TFltV RankCountV(TopRank); RankCountV.PutAll(0.0); double SumTime = 0.0;
911              for (int RankN = 0; RankN < TopRank; RankN++) {
912                  if (RankN >= ProbIpNumIdV.Len()) { break; }
913                  const int RankIpNumId = ProbIpNumIdV[RankN].Val2;
914                  if (FutureIpNumH.IsKey(RankIpNumId)) {
915                      for (int RestRankN = RankN; RestRankN < TopRank; RestRankN++) {
916                          RankCountV[RestRankN] += 1.0; }
917                  }
918                  TopMomV[RankN]->Add(RankCountV[RankN]);
919                  const int NextEventId = BtaEventBs->GetNextEvent(EventId+1, RankIpNumId);
920                  if (NextEventId != -1) {
921                      const TBtaEvent& NextEvent = BtaEventBs->GetEvent(NextEventId);
922                      const uint64 TimeDiffMSec = NextEvent.GetFirstTmMSecs() - Event.GetFirstTmMSecs();
923                      const int TimeDiffSec = int(TimeDiffMSec / uint64(1000));
924                      SumTime += double(TimeDiffSec);
925                  }
926                  TimeMomV[RankN]->Add(SumTime / double(RankN + 1));
927              }
928          }
929      }
930      TFOut RankFOut(TFile::GetUniqueFNm("PredRes.txt")); 
931      for (int RankN = 0; RankN < TopRank; RankN++) {
932          TopMomV[RankN]->Def(); TimeMomV[RankN]->Def();
933          RankFOut.PutStrLn(TStr::Fmt("%3d: Prec: %3.5f +/- %2.5f    Time: %5.5f +/- %3.5f",
934              RankN + 1, TopMomV[RankN]->GetMean(), TopMomV[RankN]->GetSDev(),    
935              TimeMomV[RankN]->GetMean(), TimeMomV[RankN]->GetSDev()));
936      }
937      printf("\n");
938  }
939  void TBtaCorrBs::EventRootCauseProb(const PBtaEventBs& BtaEventBs, 
940          const int& EventId, const int& RootCouseEventWnd, 
941          const int64& RootCouseTimeWnd, TIntFltKdV& EventIdScoreV) const {
942      TBtaEvent Event = BtaEventBs->GetEvent(EventId);
943      const int IpNumId = Event.GetIpNumId();
944      const int ProjId = Event.GetProjId();
945      const int64 TmMSec = Event.GetFirstTmMSecs();
946      TFltIntPrV ProbEventIdV;
947      int ProcEventN = 0, CurrEventId = EventId;
948      while (CurrEventId > 0) {
949          CurrEventId--; 
950          TBtaEvent CurrEvent = BtaEventBs->GetEvent(CurrEventId);
951          const int CurrIpNumId = CurrEvent.GetIpNumId();
952          const int CurrProjId = CurrEvent.GetProjId();
953          const int64 TmMSecDiff = TmMSec - CurrEvent.GetFirstTmMSecs();
954          if (TmMSecDiff > RootCouseTimeWnd) { break; }
955          if (CurrIpNumId == -1 || CurrProjId == -1) { continue; }
956          if (ProjId != CurrProjId) { continue; }
957          if (CurrEvent.GetSeverity() < 3) { continue; }
958          if (!IsIpNumIdPrCorr(CurrIpNumId, IpNumId)) { continue; }
959          if (ProcEventN > RootCouseEventWnd) { break; }
960          ProcEventN++;
961          const double CorrProb = ProbCorrIpNumIdGivenIpNumId(CurrIpNumId, IpNumId, true);
962          ProbEventIdV.Add(TFltIntPr(CorrProb, CurrEventId));
963      }
964      ProbEventIdV.Sort(false); 
965      const int MxEvents = 5;
966      const int ProbEventIds = TInt::GetMn(ProbEventIdV.Len(), MxEvents);
967      EventIdScoreV.Clr(); double OldProb = 0.0;
968      for (int ProbEventIdN = 0; ProbEventIdN < ProbEventIds; ProbEventIdN++) {
969          const int ProbEventId = ProbEventIdV[ProbEventIdN].Val2;
970          const double Prob = ProbEventIdV[ProbEventIdN].Val1;
971          if (Prob < OldProb / 3) { break; } OldProb = Prob;
972          EventIdScoreV.Add(TIntFltKd(ProbEventId, Prob));
973      }
974  }
975  void TBtaCorrBs::EventRootCauseText(const PBtaEventBs& BtaEventBs, 
976          const int& EventId,const int& RootCouseEventWnd, 
977          const int64& RootCouseTimeWnd, TIntFltKdV& EventIdScoreV) const {
978      TBtaEvent Event = BtaEventBs->GetEvent(EventId);
979      TBtaEventDat EventDat; BtaEventBs->GetEventDat(Event.GetBlobPt(), EventDat);
980      const int IpNumId = Event.GetIpNumId();
981      const int ProjId = Event.GetProjId();
982      const int64 TmMSec = Event.GetFirstTmMSecs();
983      PBowDocBs BowDocBs = TBowDocBs::New();
984      const int FirstDId = BowDocBs->AddHtmlDoc(
985          TInt::GetStr(EventId), TStrV(), EventDat.GetSummary());
986      IAssert(FirstDId == 0); int ProcEventN = 0, CurrEventId = EventId;
987      while (CurrEventId > 0) {
988          CurrEventId--; 
989          TBtaEvent CurrEvent = BtaEventBs->GetEvent(CurrEventId);
990          const int CurrIpNumId = CurrEvent.GetIpNumId();
991          const int CurrProjId = CurrEvent.GetProjId();
992          const int64 TmMSecDiff = TmMSec - CurrEvent.GetFirstTmMSecs();
993          if (TmMSecDiff > RootCouseTimeWnd) { break; }
994          if (CurrIpNumId == -1 || CurrProjId == -1) { continue; }
995          if (ProjId != CurrProjId) { continue; }
996          if (CurrEvent.GetSeverity() < 3) { continue; }
997          if (ProcEventN > RootCouseEventWnd) { break; }
998          ProcEventN++;
999          TBtaEventDat CurrEventDat; BtaEventBs->GetEventDat(CurrEvent.GetBlobPt(), CurrEventDat);
1000          BowDocBs->AddHtmlDoc(TInt::GetStr(CurrEventId), TStrV(), CurrEventDat.GetSummary());
1001      }
1002      TIntFltIntTrV HeaderSimEventIdV;
1003      PBowSim BowSim = TBowSim::New(bstCos);
1004      TStr EventSummary = EventDat.GetSummary(), HeaderStr = "";
1005      if (EventSummary.SearchCh(':') > 0) {
1006          HeaderStr = EventSummary.GetSubStr(0, EventSummary.SearchCh(':')-1); 
1007      }
1008      for (int DId = 0; DId < BowDocBs->GetDocs(); DId++) {
1009          if (DId == FirstDId) { continue; }
1010          const int CurrEventId = BowDocBs->GetDocNm(DId).GetInt();
1011          TBtaEvent CurrEvent = BtaEventBs->GetEvent(CurrEventId);
1012          TStr CurrEventSummary = EventDat.GetSummary(), CurrHeaderStr = "";
1013          const int ColonPos = EventSummary.SearchCh(':');
1014          if (ColonPos > 0) { CurrHeaderStr = CurrEventSummary.GetSubStr(0, ColonPos-1); }
1015          TIntFltIntTr HeaderSimEventId;
1016          HeaderSimEventId.Val1 = (HeaderStr == CurrHeaderStr) ? 1 : 0;
1017          HeaderSimEventId.Val2 = BowSim->GetSim(
1018              BowDocBs->GetDocSpV(FirstDId), BowDocBs->GetDocSpV(DId));
1019          HeaderSimEventId.Val3 = CurrEventId;
1020          HeaderSimEventIdV.Add(HeaderSimEventId);
1021      }
1022      HeaderSimEventIdV.Sort(false); 
1023      const int MxEvents = 5;
1024      const int HeaderSimEventIds = TInt::GetMn(HeaderSimEventIdV.Len(), MxEvents);
1025      EventIdScoreV.Clr(); double OldSim = 0.0;
1026      for (int HeaderSimEventIdN = 0; HeaderSimEventIdN < HeaderSimEventIds; HeaderSimEventIdN++) {
1027          const int HeaderSimEventId = HeaderSimEventIdV[HeaderSimEventIdN].Val3;
1028          const double Sim = HeaderSimEventIdV[HeaderSimEventIdN].Val2;
1029          if (Sim < 0.001) { break; }
1030          if (Sim < OldSim / 3) { break; } OldSim = Sim;
1031          EventIdScoreV.Add(TIntFltKd(HeaderSimEventId, Sim));
1032      }
1033  }
1034  void TBtaCorrBs::EventRootCause(const PBtaEventBs& BtaEventBs, const int& EventId, 
1035          const int& RootCouseEventWnd, const int64& RootCouseTimeWnd,
1036          TIntFltKdV& EventIdScoreV, TStrV& CorrTypeV) const {
1037      TIntFltKdV EventIdProbV;
1038      EventRootCauseProb(BtaEventBs, EventId, 
1039          RootCouseEventWnd, RootCouseTimeWnd, EventIdProbV);
1040      TIntFltKdV EventIdSimV; 
1041      EventRootCauseText(BtaEventBs, EventId,
1042          RootCouseEventWnd, RootCouseTimeWnd, EventIdSimV);
1043      TIntFltH EventIdScoreH; TIntStrH EventIdTypeH;
1044      for (int EventIdProbN = 0; EventIdProbN < EventIdProbV.Len(); EventIdProbN++) {
1045          const int ProbEventId = EventIdProbV[EventIdProbN].Key;
1046          const double Prob = EventIdProbV[EventIdProbN].Dat;
1047          const double MxProb = EventIdProbV[0].Dat;
1048          const double Score = Prob / MxProb;
1049          EventIdScoreH.AddDat(ProbEventId, Score);
1050          EventIdTypeH.AddDat(ProbEventId, "Prob");
1051      }
1052      for (int EventIdSimN = 0; EventIdSimN < EventIdSimV.Len(); EventIdSimN++) {
1053          const int SimEventId = EventIdSimV[EventIdSimN].Key;
1054          const double Sim = EventIdSimV[EventIdSimN].Dat;
1055          const double MxSim = EventIdSimV[0].Dat;
1056          const double Score = Sim / MxSim;
1057          if (EventIdScoreH.IsKey(SimEventId)) {
1058              const double OldScore = EventIdScoreH.GetDat(SimEventId);
1059              EventIdScoreH.GetDat(SimEventId) = TFlt::GetMx(OldScore, Score);
1060              EventIdTypeH.GetDat(SimEventId) = "Text";
1061          } else {
1062              EventIdScoreH.AddDat(SimEventId, Score);
1063              EventIdTypeH.AddDat(SimEventId, "Text");
1064          }
1065      }
1066      TFltIntKdV ScoreEventIdV;
1067      int EventKeyId = EventIdScoreH.FFirstKeyId();
1068      while (EventIdScoreH.FNextKeyId(EventKeyId)) {
1069          const int EventId = EventIdScoreH.GetKey(EventKeyId);
1070          const double Score = EventIdScoreH[EventKeyId];
1071          ScoreEventIdV.Add(TFltIntKd(Score, EventId));
1072      }
1073      ScoreEventIdV.Sort(false);
1074      GetSwitchedKdV<TFlt, TInt>(ScoreEventIdV, EventIdScoreV);
1075      CorrTypeV.Gen(EventIdScoreV.Len(), 0);
1076      for (int EventIdN = 0; EventIdN < EventIdScoreV.Len(); EventIdN++) {
1077          CorrTypeV.Add(EventIdTypeH.GetDat(EventIdScoreV[EventIdN].Key));
1078      }
1079  }
1080  void TBtaCorrBs::GetRootCauseStat(const PBtaEventBs& BtaEventBs, 
1081          const int& MxEvents, const int& MnSeverity, const int& RootCouseEventWnd, 
1082          const int64& RootCouseTimeWnd, const bool& PropP, const bool& TextP, 
1083          TIntV& AllScoresCountV, TIntV& ProbScoresCountV, TIntV& TextScoresCountV, 
1084          int& AllEvents) const {
1085      const int MxCount = 10;
1086      AllScoresCountV.Gen(MxCount); 
1087      ProbScoresCountV.Gen(MxCount);  
1088      TextScoresCountV.Gen(MxCount);  
1089      AllEvents = 0;
1090      TTmStopWatch AllSw, ProbSw, TextSw;
1091      int EventN = BtaEventBs->GetEvents();
1092      while (EventN > 0) {
1093          EventN--;
1094          const int Events = BtaEventBs->GetEvents() - EventN;
1095          if (Events % 100 == 0) { printf("%d\r", Events ); }
1096          if (Events >= MxEvents) { break; }
1097          const int EventSeverity = BtaEventBs->GetEvent(EventN).GetSeverity();
1098          if (EventSeverity < MnSeverity) { continue; }
1099          TIntFltKdV EventIdScoreV; TStrV CorrTypeV;
1100          if (PropP && TextP) {
1101              AllSw.Start();
1102              EventRootCause(BtaEventBs, EventN, RootCouseEventWnd, 
1103                  RootCouseTimeWnd, EventIdScoreV, CorrTypeV);
1104              AllSw.Stop();
1105          } else if (PropP) {
1106              ProbSw.Start();
1107              EventRootCauseProb(BtaEventBs, EventN, RootCouseEventWnd, 
1108                  RootCouseTimeWnd, EventIdScoreV);
1109              ProbSw.Stop();
1110              CorrTypeV.Gen(EventIdScoreV.Len());
1111              CorrTypeV.PutAll("Prob");
1112          } else if (TextP) {
1113              TextSw.Start();
1114              EventRootCauseText(BtaEventBs, EventN, RootCouseEventWnd, 
1115                  RootCouseTimeWnd, EventIdScoreV);
1116              TextSw.Stop();
1117              CorrTypeV.Gen(EventIdScoreV.Len());
1118              CorrTypeV.PutAll("Text");
1119          }
1120          const int AllCount = EventIdScoreV.Len();
1121          const int ProbCount = CorrTypeV.Count("Prob");
1122          const int TextCount = CorrTypeV.Count("Text");
1123          AllScoresCountV[TInt::GetMn(AllCount, MxCount-1)]++;
1124          ProbScoresCountV[TInt::GetMn(ProbCount, MxCount-1)]++;
1125          TextScoresCountV[TInt::GetMn(TextCount, MxCount-1)]++;
1126          AllEvents++;
1127      }
1128      printf("RootCauseStatTm: [a:%.2fs, p:%.2fs, t:%.2fs]\n", 
1129          AllSw.GetSec(), ProbSw.GetSec(), TextSw.GetSec());
1130  }
1131  void TBtaCorrBs::GetStat(const PBtaEventBs& BtaEventBs) const {
1132      TIntH SeverityH;
1133      TStrIntVH CaseIdEventVH;
1134      int CaseIds = 0;
1135      for (int EventN = 0; EventN < BtaEventBs->GetEvents(); EventN++) {
1136          const TBtaEvent& Event = BtaEventBs->GetEvent(EventN);
1137          if (EventN % 10000 == 0) { 
1138              printf("%10d / %d\r", EventN, BtaEventBs->GetEvents()); }
1139          if (Event.GetSeverity() != -1) {
1140              const int Severity = Event.GetSeverity();
1141              SeverityH.AddDat(Severity)++;
1142          }
1143          if (Event.GetCaseId() != -1) {
1144              TStr CaseNm = BtaEventBs->GetCase(Event.GetCaseId());
1145              CaseIdEventVH.AddDat(CaseNm).Add(EventN);
1146              CaseIds++;
1147          }
1148      } printf("\n");
1149      TIntPrV SeverityFqV; 
1150      SeverityH.GetKeyDatPrV(SeverityFqV);
1151      SeverityFqV.Sort();
1152      printf("Severity:\n");
1153      for (int SeverityN = 0; SeverityN < SeverityFqV.Len(); SeverityN++) {
1154          printf("  %d: %d\n", SeverityFqV[SeverityN].Val1.Val,
1155              SeverityFqV[SeverityN].Val2.Val);
1156      }
1157      printf("CaseIds: All=%d, Unique=%d\n", CaseIds, CaseIdEventVH.Len());
1158      PMom SeqDiff = TMom::New(), TmDiff = TMom::New(), CaseFq = TMom::New();
1159      int CaseIdKeyId = CaseIdEventVH.FFirstKeyId();
1160      while (CaseIdEventVH.FNextKeyId(CaseIdKeyId)) {
1161          const TIntV& EventV = CaseIdEventVH[CaseIdKeyId];
1162          for (int EventN = 1; EventN < EventV.Len(); EventN++) {
1163              const int EventId = EventV[EventN-1];
1164              const int CorrEventId = EventV[EventN];
1165              SeqDiff->Add(CorrEventId - EventId);
1166              const TBtaEvent& Event = BtaEventBs->GetEvent(EventId);
1167              const TBtaEvent& CorrEvent = BtaEventBs->GetEvent(CorrEventId);
1168              const uint64 TmDiffMSec = TTm::GetDiffMSecs(
1169                  Event.GetFirstTm(), CorrEvent.GetFirstTm());
1170              TmDiff->Add(int(TmDiffMSec/uint64(1000)));
1171          }
1172          CaseFq->Add(EventV.Len());
1173      }
1174      SeqDiff->Def(); TmDiff->Def(); CaseFq->Def();
1175      printf(" FQ: %.2f +/- %.2f [Min:%.0f Med:%.0f Max:%.0f]\n:", CaseFq->GetMean(), 
1176          CaseFq->GetSDev(), CaseFq->GetMn(), CaseFq->GetMedian(), CaseFq->GetMx());
1177      printf(" SD: %.2f +/- %.2f [Min:%.0f Med:%.0f Max:%.0f]\n:", SeqDiff->GetMean(), 
1178          SeqDiff->GetSDev(), SeqDiff->GetMn(), SeqDiff->GetMedian(), SeqDiff->GetMx());
1179      printf(" TD: %.2f +/- %.2f [Min:%.0f Med:%.0f Max:%.0f]\n:", TmDiff->GetMean(), 
1180          TmDiff->GetSDev(), TmDiff->GetMn(), TmDiff->GetMedian(), TmDiff->GetMx());
1181  }
1182  void TBtaLongProj::GetCountV(const TTm& StartDate, const TTm& BreakDate, 
1183          const TTm& EndDate, TIntH& IpNumIdH, TFltV& OldV, TFltV& NewV) const {
1184      IpNumIdH.Clr(); 
1185      {int DayKeyId = DayToIpNumIdFqVH.FFirstKeyId();
1186      while (DayToIpNumIdFqVH.FNextKeyId(DayKeyId)) {
1187          const TIntPrV& IpNumIdFqV = DayToIpNumIdFqVH[DayKeyId];
1188          for (int IpNumN = 0; IpNumN < IpNumIdFqV.Len(); IpNumN++) {
1189              IpNumIdH.AddKey(IpNumIdFqV[IpNumN].Val1);
1190          }
1191      }}
1192      const int IpNums = IpNumIdH.Len();
1193      OldV.Gen(IpNums); OldV.PutAll(1.0);   
1194      NewV.Gen(IpNums); NewV.PutAll(1.0);
1195      int OldTotalCount = IpNums, NewTotalCount = IpNums;
1196      {int DayKeyId = DayToIpNumIdFqVH.FFirstKeyId();
1197      while (DayToIpNumIdFqVH.FNextKeyId(DayKeyId)) {
1198          const int DateInt = DayToIpNumIdFqVH.GetKey(DayKeyId);
1199          TTm Date = TTm::GetTmFromDateTimeInt(DateInt);
1200          if (Date < StartDate || Date > EndDate) { continue; }
1201          const TIntPrV& IpNumIdFqV = DayToIpNumIdFqVH[DayKeyId];
1202          for (int IpNumN = 0; IpNumN < IpNumIdFqV.Len(); IpNumN++) {
1203              const int IpNumId = IpNumIdH.GetKeyId(IpNumIdFqV[IpNumN].Val1);
1204              const int IpNumFq = IpNumIdFqV[IpNumN].Val2;
1205              if (Date < BreakDate) { OldV[IpNumId] += double(IpNumFq); OldTotalCount++; }
1206              else { NewV[IpNumId] += double(IpNumFq); NewTotalCount++; }
1207          }
1208      }}
1209      int OldDayDiff = TTm::GetDiffDays(StartDate, BreakDate);
1210      int NewDayDiff = TTm::GetDiffDays(BreakDate, EndDate);
1211      IAssert(OldDayDiff > 0 && NewDayDiff > 0);
1212      double NormFact = double(NewDayDiff) / double(OldDayDiff);
1213      if (OldTotalCount > 0 && NewTotalCount > 0) {
1214          TLinAlg::MultiplyScalar(NormFact, OldV, OldV);
1215      } else {
1216          OldV.Clr(); NewV.Clr();
1217      }
1218  }
1219  void TBtaLongProj::AddEvent(const uint64& DateMSecs, const int& IpNumId) { 
1220      const int DateInt = TTm::GetDateIntFromTm(TTm::GetTmFromMSecs(DateMSecs));
1221      DayToIpNumIdFqHH.AddDat(DateInt).AddDat(IpNumId)++;
1222  }
1223  void TBtaLongProj::Def() {
1224      int DayKeyId = DayToIpNumIdFqHH.FFirstKeyId();
1225      while (DayToIpNumIdFqHH.FNextKeyId(DayKeyId)) {
1226          const int DayInt = DayToIpNumIdFqHH.GetKey(DayKeyId);
1227          TIntPrV& IpNumIdFqV = DayToIpNumIdFqVH.AddDat(DayInt);
1228          DayToIpNumIdFqHH[DayKeyId].GetKeyDatPrV(IpNumIdFqV);
1229          DayToIpNumIdFqHH[DayKeyId].Clr();
1230      }
1231      DayToIpNumIdFqHH.Clr();
1232  }
1233  void TBtaLongProj::Count(const TTm& StartDate, const TTm& BreakDate, 
1234          const TTm& EndDate, int& BeforeCount, int& AfterCount) const {
1235      BeforeCount = 0; AfterCount = 0;
1236      int DayKeyId = DayToIpNumIdFqVH.FFirstKeyId();
1237      while (DayToIpNumIdFqVH.FNextKeyId(DayKeyId)) {
1238          const int DateInt = DayToIpNumIdFqVH.GetKey(DayKeyId);
1239          TTm Date = TTm::GetTmFromDateTimeInt(DateInt);
1240          if (Date < StartDate || Date > EndDate) { continue; }
1241          int DayEvents = 0;
1242          const TIntPrV& IpNumIdFqV = DayToIpNumIdFqVH[DayKeyId];
1243          for (int IpNumIdN = 0; IpNumIdN < IpNumIdFqV.Len(); IpNumIdN++) {
1244              DayEvents += IpNumIdFqV[IpNumIdN].Val2; }
1245          if (Date < BreakDate) { BeforeCount += DayEvents; }
1246          else { AfterCount += DayEvents; }
1247      }
1248  }
1249  double TBtaLongProj::ChiSquare(const TTm& StartDate, 
1250          const TTm& BreakDate, const TTm& EndDate) const { 
1251      TIntH IpNumIdH; TFltV OldV, NewV; 
1252      GetCountV(StartDate, BreakDate, EndDate, IpNumIdH, OldV, NewV);
1253      if (OldV.Empty() || NewV.Empty()) { return 1.0; }
1254      double Val, Prb; TStatTest::ChiSquareOne(NewV, OldV, Val, Prb);
1255      return Prb;
1256  }
1257  bool TBtaLongProj::IsTrendPos(const TTm& StartDate, 
1258          const TTm& BreakDate, const TTm& EndDate) const {
1259      const double NormFact = GetNormFact(StartDate, BreakDate, EndDate);
1260      int BeforeCount, AfterCount; 
1261      Count(StartDate, BreakDate, EndDate, BeforeCount, AfterCount);
1262      const bool IsTrendPosP = ((NormFact * double(BeforeCount)) < AfterCount);
1263      return IsTrendPosP;
1264  }
1265  void TBtaLongProj::GetIpNumWgtV(const TTm& StartDate, const TTm& BreakDate, 
1266          const TTm& EndDate, TIntFltKdV& IpNumIdWgtV) const {
1267      TIntH IpNumIdH; TFltV OldV, NewV; 
1268      GetCountV(StartDate, BreakDate, EndDate, IpNumIdH, OldV, NewV);
1269      if (OldV.Empty() || NewV.Empty()) { IpNumIdWgtV.Clr(); return; }
1270      IAssert(OldV.Len() == NewV.Len());
1271      const int IpNumIds = OldV.Len(); TFltIntKdV IpNumWgtIdV;
1272      for (int IpNumIdN = 0; IpNumIdN < IpNumIds; IpNumIdN++){
1273          IAssert(OldV[IpNumIdN] > 0);
1274          const int IpNumId = IpNumIdH.GetKey(IpNumIdN);
1275          const double BinDiff = NewV[IpNumIdN] - OldV[IpNumIdN];
1276          const double ChiSquareVal = TMath::Sqr(BinDiff) / OldV[IpNumIdN];
1277          IpNumWgtIdV.Add(TFltIntKd(ChiSquareVal, IpNumId));
1278      }
1279      IpNumWgtIdV.Sort(false);
1280      GetSwitchedKdV<TFlt, TInt>(IpNumWgtIdV, IpNumIdWgtV);
1281  }
1282  double TBtaLongProj::GetNormFact(const TTm& StartDate, 
1283          const TTm& BreakDate, const TTm& EndDate) {
1284      int OldDayDiff = TTm::GetDiffDays(StartDate, BreakDate);
1285      int NewDayDiff = TTm::GetDiffDays(BreakDate, EndDate);
1286      IAssert(OldDayDiff > 0 && NewDayDiff > 0);
1287      return double(NewDayDiff) / double(OldDayDiff);;
1288  }
1289  TBtaLongBs::TBtaLongBs(const PBtaEventBs& BtaEventBs, 
1290          const PBtaCorrBs& BtaCorrBs, const int& MnSeverity) {
1291      printf("Trends over projects ...\n");
1292      const int Events = BtaEventBs->GetEvents(); int Skiped = 0;
1293      for (int EventN = 0; EventN < Events; EventN++) {
1294          const TBtaEvent& Event = BtaEventBs->GetEvent(EventN);
1295          if (EventN % 10000 == 0) { printf("%10d / %d [%d]\r", EventN, Events, Events-Skiped); }
1296          const int ProjId = Event.GetProjId();
1297          const int IpNumId = Event.GetIpNumId();
1298          if ((ProjId != -1) && (IpNumId != -1) && 
1299                  BtaCorrBs->IsIpNumId(IpNumId) &&
1300                  Event.GetSeverity() >= MnSeverity) {
1301              const uint64 DateMSecs = TTm::GetMSecsFromTm(Event.GetFirstTm());
1302              if (!ProjIdToProfileH.IsKey(ProjId)) {
1303                  ProjIdToProfileH.AddDat(ProjId, TBtaLongProj::New()); }
1304              ProjIdToProfileH.GetDat(ProjId)->AddEvent(DateMSecs, IpNumId);
1305          } else { 
1306              Skiped++; 
1307          }
1308      } printf("\n");
1309      printf("Summarizing ...");
1310      int ProjKeyId = ProjIdToProfileH.FFirstKeyId();
1311      while (ProjIdToProfileH.FNextKeyId(ProjKeyId)) {
1312          ProjIdToProfileH[ProjKeyId]->Def();
1313      }
1314      printf("\nDone\n");
1315  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-lstmrecognizer.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-btalarms.cpp</div>
                </div>
                <div class="column column_space"><pre><code>243                                   float *sd) {
244    const int kOutputScale = INT8_MAX;
245    STATS stats(0, kOutputScale);
246    for (int t = 0; t < outputs.Width(); ++t) {
</pre></code></div>
                <div class="column column_space"><pre><code>892          const int& MxEventWnd, const int64& MxTmMSecWnd, const int& MxEvalWnd) const {
893      const int TopRank = 100; TMomV TopMomV(TopRank), TimeMomV(TopRank);
894      for (int RankN = 0; RankN < TopRank; RankN++) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    