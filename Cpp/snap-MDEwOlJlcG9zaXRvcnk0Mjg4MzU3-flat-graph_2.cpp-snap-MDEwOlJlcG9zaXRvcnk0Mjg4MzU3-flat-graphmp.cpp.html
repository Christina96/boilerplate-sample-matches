
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 178, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-graph_2.cpp</h3>
            <pre><code>1  bool TUNGraph::HasFlag(const TGraphFlag& Flag) const {
2    return HasGraphFlag(TUNGraph::TNet, Flag);
3  }
4  int TUNGraph::AddNode(int NId) {
5    if (NId == -1) {
6      NId = MxNId;  MxNId++;
7    } else {
8      IAssertR(!IsNode(NId), TStr::Fmt("NodeId %d already exists", NId));
9      MxNId = TMath::Mx(NId+1, MxNId());
10    }
11    NodeH.AddDat(NId, TNode(NId));
12    return NId;
13  }
14  int TUNGraph::AddNodeUnchecked(int NId) {
15    if (IsNode(NId)) { return -1;}
16    MxNId = TMath::Mx(NId+1, MxNId());
17    NodeH.AddDat(NId, TNode(NId));
18    return NId;
19  }
20  int TUNGraph::AddNode(const int& NId, const TIntV& NbrNIdV) {
21    int NewNId;
22    if (NId == -1) {
23      NewNId = MxNId;  MxNId++;
24    } else {
25      IAssertR(! IsNode(NId), TStr::Fmt("NodeId %d already exists", NId));
26      NewNId = NId;
27      MxNId = TMath::Mx(NewNId+1, MxNId());
28    }
29    TNode& Node = NodeH.AddDat(NewNId);
30    Node.Id = NewNId;
31    Node.NIdV = NbrNIdV;
32    Node.NIdV.Sort();
33    NEdges += Node.GetDeg();
34    for (int i = 0; i < NbrNIdV.Len(); i++) {
35      GetNode(NbrNIdV[i]).NIdV.AddSorted(NewNId);
36    }
37    return NewNId;
38  }
39  int TUNGraph::AddNode(const int& NId, const TVecPool<TInt>& Pool, const int& NIdVId) {
40    int NewNId;
41    if (NId == -1) {
42      NewNId = MxNId;  MxNId++;
43    } else {
44      IAssertR(!IsNode(NId), TStr::Fmt("NodeId %d already exists", NId));
45      NewNId = NId;
46      MxNId = TMath::Mx(NewNId+1, MxNId()); 
47    }
48    TNode& Node = NodeH.AddDat(NewNId);
49    Node.Id = NewNId;
50    Node.NIdV.GenExt(Pool.GetValVPt(NIdVId), Pool.GetVLen(NIdVId));
51    Node.NIdV.Sort();
52    NEdges += Node.GetDeg();
53    return NewNId;
54  }
55  void TUNGraph::DelNode(const int& NId) {
56    { AssertR(IsNode(NId), TStr::Fmt("NodeId %d does not exist", NId));
57    TNode& Node = GetNode(NId);
58    NEdges -= Node.GetDeg();
59    for (int e = 0; e < Node.GetDeg(); e++) {
60      const int nbr = Node.GetNbrNId(e);
61      if (nbr == NId) { continue; }
62      TNode& N = GetNode(nbr);
63      const int n = N.NIdV.SearchBin(NId);
64      IAssert(n != -1); 
65      if (n!= -1) { N.NIdV.Del(n); }
66    } }
67    NodeH.DelKey(NId);
68  }
69  int TUNGraph::GetEdges() const {
70    return NEdges;
71  }
72  int TUNGraph::AddEdge(const int& SrcNId, const int& DstNId) {
73    IAssertR(IsNode(SrcNId) && IsNode(DstNId), TStr::Fmt("%d or %d not a node.", SrcNId, DstNId).CStr());
74    if (IsEdge(SrcNId, DstNId)) { return -2; } 
75    GetNode(SrcNId).NIdV.AddSorted(DstNId);
76    if (SrcNId!=DstNId) { 
77      GetNode(DstNId).NIdV.AddSorted(SrcNId); }
78    NEdges++;
79    return -1; 
80  }
81  int TUNGraph::AddEdgeUnchecked(const int& SrcNId, const int& DstNId) {
82    GetNode(SrcNId).NIdV.Add(DstNId);
83    if (SrcNId!=DstNId) { 
84      GetNode(DstNId).NIdV.Add(SrcNId); }
85    NEdges++;
86    return -1; 
87  }
88  int TUNGraph::AddEdge2(const int& SrcNId, const int& DstNId) {
89    if (! IsNode(SrcNId)) { AddNode(SrcNId); }
90    if (! IsNode(DstNId)) { AddNode(DstNId); }
91    if (GetNode(SrcNId).IsNbrNId(DstNId)) { return -2; } 
92    GetNode(SrcNId).NIdV.AddSorted(DstNId);
93    if (SrcNId!=DstNId) { 
94      GetNode(DstNId).NIdV.AddSorted(SrcNId); }
95    NEdges++;
96    return -1; 
97  }
98  void TUNGraph::DelEdge(const int& SrcNId, const int& DstNId) {
99    IAssertR(IsNode(SrcNId) && IsNode(DstNId), TStr::Fmt("%d or %d not a node.", SrcNId, DstNId).CStr());
100    { TNode& N = GetNode(SrcNId);
101    const int n = N.NIdV.SearchBin(DstNId);
102    if (n!= -1) { N.NIdV.Del(n);  NEdges--; } }
103    if (SrcNId != DstNId) { 
104      TNode& N = GetNode(DstNId);
105      const int n = N.NIdV.SearchBin(SrcNId);
106      if (n!= -1) { N.NIdV.Del(n); }
107    }
108  }
109  bool TUNGraph::IsEdge(const int& SrcNId, const int& DstNId) const {
110    if (! IsNode(SrcNId) || ! IsNode(DstNId)) return false;
111    return GetNode(SrcNId).IsNbrNId(DstNId);
112  }
113  TUNGraph::TEdgeI TUNGraph::GetEI(const int& SrcNId, const int& DstNId) const {
114    const int MnNId = TMath::Mn(SrcNId, DstNId);
115    const int MxNId = TMath::Mx(SrcNId, DstNId);
116    const TNodeI SrcNI = GetNI(MnNId);
117    const int NodeN = SrcNI.NodeHI.GetDat().NIdV.SearchBin(MxNId);
118    IAssert(NodeN != -1);
119    return TEdgeI(SrcNI, EndNI(), NodeN);
120  }
121  void TUNGraph::GetNIdV(TIntV& NIdV) const {
122    NIdV.Gen(GetNodes(), 0);
123    for (int N=NodeH.FFirstKeyId(); NodeH.FNextKeyId(N); ) {
124      NIdV.Add(NodeH.GetKey(N)); }
125  }
126  void TUNGraph::Defrag(const bool& OnlyNodeLinks) {
127    for (int n = NodeH.FFirstKeyId(); NodeH.FNextKeyId(n); ) {
128      NodeH[n].NIdV.Pack();
129    }
130    if (! OnlyNodeLinks && ! NodeH.IsKeyIdEqKeyN()) {
131      NodeH.Defrag();
132    }
133  }
134  bool TUNGraph::IsOk(const bool& ThrowExcept) const {
135    bool RetVal = true;
136    for (int N = NodeH.FFirstKeyId(); NodeH.FNextKeyId(N); ) {
137      const TNode& Node = NodeH[N];
138      if (! Node.NIdV.IsSorted()) {
139        const TStr Msg = TStr::Fmt("Neighbor list of node %d is not sorted.", Node.GetId());
140        if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); }
141        RetVal=false;
142      }
143      int prevNId = -1;
144      for (int e = 0; e < Node.GetDeg(); e++) {
145        if (! IsNode(Node.GetNbrNId(e))) {
146          const TStr Msg = TStr::Fmt("Edge %d --> %d: node %d does not exist.",
147            Node.GetId(), Node.GetNbrNId(e), Node.GetNbrNId(e));
148          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); }
149          RetVal=false;
150        }
151        if (e > 0 && prevNId == Node.GetNbrNId(e)) {
152          const TStr Msg = TStr::Fmt("Node %d has duplicate edge %d --> %d.",
153            Node.GetId(), Node.GetId(), Node.GetNbrNId(e));
154          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); }
155          RetVal=false;
156        }
157        prevNId = Node.GetNbrNId(e);
158      }
159    }
160    int EdgeCnt = 0;
161    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) { EdgeCnt++; }
162    if (EdgeCnt != GetEdges()) {
163      const TStr Msg = TStr::Fmt("Number of edges counter is corrupted: GetEdges():%d, EdgeCount:%d.", GetEdges(), EdgeCnt);
164      if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); }
165      RetVal=false;
166    }
167    return RetVal;
168  }
169  void TUNGraph::Dump(FILE *OutF) const {
170    const int NodePlaces = (int) ceil(log10((double) GetNodes()));
171    fprintf(OutF, "-------------------------------------------------\nUndirected Node Graph: nodes: %d, edges: %d\n", GetNodes(), GetEdges());
172    for (int N = NodeH.FFirstKeyId(); NodeH.FNextKeyId(N); ) {
173      const TNode& Node = NodeH[N];
174      fprintf(OutF, "  %*d [%d] ", NodePlaces, Node.GetId(), Node.GetDeg());
175      for (int edge = 0; edge < Node.GetDeg(); edge++) {
176        fprintf(OutF, " %*d", NodePlaces, Node.GetNbrNId(edge)); }
177      fprintf(OutF, "\n");
178    }
179    fprintf(OutF, "\n");
180  }
181  PUNGraph TUNGraph::GetSmallGraph() {
182    PUNGraph Graph = TUNGraph::New();
183    for (int i = 0; i < 5; i++) { Graph->AddNode(i); }
184    Graph->AddEdge(0,1);  Graph->AddEdge(0,2);
185    Graph->AddEdge(0,3);  Graph->AddEdge(0,4);
186    Graph->AddEdge(1,2);
187    return Graph;
188  }
189  bool TNGraph::HasFlag(const TGraphFlag& Flag) const {
190    return HasGraphFlag(TNGraph::TNet, Flag);
191  }
192  int TNGraph::AddNode(int NId) {
193    if (NId == -1) {
194      NId = MxNId;  MxNId++;
195    } else {
196      IAssertR(!IsNode(NId), TStr::Fmt("NodeId %d already exists", NId));
197      MxNId = TMath::Mx(NId+1, MxNId());
198    }
199    NodeH.AddDat(NId, TNode(NId));
200    return NId;
201  }
202  int TNGraph::AddNodeUnchecked(int NId) {
203    if (IsNode(NId)) { return NId;}
204    MxNId = TMath::Mx(NId+1, MxNId());
205    NodeH.AddDat(NId, TNode(NId));
206    return NId;
207  }
208  int TNGraph::AddNode(const int& NId, const TIntV& InNIdV, const TIntV& OutNIdV) {
209    int NewNId;
210    if (NId == -1) {
211      NewNId = MxNId;  MxNId++;
212    } else {
213      IAssertR(!IsNode(NId), TStr::Fmt("NodeId %d already exists", NId));
214      NewNId = NId;
215      MxNId = TMath::Mx(NewNId+1, MxNId());
216    }
217    TNode& Node = NodeH.AddDat(NewNId);
218    Node.Id = NewNId;
219    Node.InNIdV = InNIdV;
220    Node.OutNIdV = OutNIdV;
221    Node.InNIdV.Sort();
222    Node.OutNIdV.Sort();
223    return NewNId;
224  }
<span onclick='openModal()' class='match'>225  int TNGraph::AddNode(const int& NId, const TVecPool<TInt>& Pool, const int& SrcVId, const int& DstVId) {
226    int NewNId;
227    if (NId == -1) {
228      NewNId = MxNId;  MxNId++;
229    } else {
230      IAssertR(!IsNode(NId), TStr::Fmt("NodeId %d already exists", NId));
231      NewNId = NId;
232      MxNId = TMath::Mx(NewNId+1, MxNId());
233    }
234    TNode& Node = NodeH.AddDat(NewNId);
235    Node.Id = NewNId;
236    Node.InNIdV.GenExt(Pool.GetValVPt(SrcVId), Pool.GetVLen(SrcVId));
237    Node.OutNIdV.GenExt(Pool.GetValVPt(DstVId), Pool.GetVLen(DstVId));
238    Node.InNIdV.Sort();
239    Node.OutNIdV.Sort();
240    return NewNId;
241  }
242  void TNGraph::DelNode(const int& NId) {
243    { TNode& Node = GetNode(NId);
</span>244    for (int e = 0; e < Node.GetOutDeg(); e++) {
245    const int nbr = Node.GetOutNId(e);
246    if (nbr == NId) { continue; }
247      TNode& N = GetNode(nbr);
248      const int n = N.InNIdV.SearchBin(NId);
249      if (n!= -1) { N.InNIdV.Del(n); }
250    }
251    for (int e = 0; e < Node.GetInDeg(); e++) {
252    const int nbr = Node.GetInNId(e);
253    if (nbr == NId) { continue; }
254      TNode& N = GetNode(nbr);
255      const int n = N.OutNIdV.SearchBin(NId);
256      if (n!= -1) { N.OutNIdV.Del(n); }
257    } }
258    NodeH.DelKey(NId);
259  }
260  int TNGraph::GetEdges() const {
261    int edges=0;
262    for (int N=NodeH.FFirstKeyId(); NodeH.FNextKeyId(N); ) {
263      edges+=NodeH[N].GetOutDeg();
264    }
265    return edges;
266  }
267  int TNGraph::AddEdge(const int& SrcNId, const int& DstNId) {
268    IAssertR(IsNode(SrcNId) && IsNode(DstNId), TStr::Fmt("%d or %d not a node.", SrcNId, DstNId).CStr());
269    if (IsEdge(SrcNId, DstNId)) { return -2; }
270    GetNode(SrcNId).OutNIdV.AddSorted(DstNId);
271    GetNode(DstNId).InNIdV.AddSorted(SrcNId);
272    return -1; 
273  }
274  int TNGraph::AddEdgeUnchecked(const int& SrcNId, const int& DstNId) {
275    GetNode(SrcNId).OutNIdV.Add(DstNId);
276    GetNode(DstNId).InNIdV.Add(SrcNId);
277    return -1; 
278  }
279  int TNGraph::AddEdge2(const int& SrcNId, const int& DstNId) {
280    if (! IsNode(SrcNId)) { AddNode(SrcNId); }
281    if (! IsNode(DstNId)) { AddNode(DstNId); }
282    if (GetNode(SrcNId).IsOutNId(DstNId)) { return -2; } 
283    GetNode(SrcNId).OutNIdV.AddSorted(DstNId);
284    GetNode(DstNId).InNIdV.AddSorted(SrcNId);
285    return -1; 
286  }
287  void TNGraph::DelEdge(const int& SrcNId, const int& DstNId, const bool& IsDir) {
288    IAssertR(IsNode(SrcNId) && IsNode(DstNId), TStr::Fmt("%d or %d not a node.", SrcNId, DstNId).CStr());
289    { TNode& N = GetNode(SrcNId);
290    const int n = N.OutNIdV.SearchBin(DstNId);
291    if (n!= -1) { N.OutNIdV.Del(n); } }
292    { TNode& N = GetNode(DstNId);
293    const int n = N.InNIdV.SearchBin(SrcNId);
294    if (n!= -1) { N.InNIdV.Del(n); } }
295    if (! IsDir) {
296      { TNode& N = GetNode(SrcNId);
297      const int n = N.InNIdV.SearchBin(DstNId);
298      if (n!= -1) { N.InNIdV.Del(n); } }
299      { TNode& N = GetNode(DstNId);
300      const int n = N.OutNIdV.SearchBin(SrcNId);
301      if (n!= -1) { N.OutNIdV.Del(n); } }
302    }
303  }
304  bool TNGraph::IsEdge(const int& SrcNId, const int& DstNId, const bool& IsDir) const {
305    if (! IsNode(SrcNId) || ! IsNode(DstNId)) { return false; }
306    if (IsDir) { return GetNode(SrcNId).IsOutNId(DstNId); }
307    else { return GetNode(SrcNId).IsOutNId(DstNId) || GetNode(DstNId).IsOutNId(SrcNId); }
308  }
309  TNGraph::TEdgeI TNGraph::GetEI(const int& SrcNId, const int& DstNId) const {
310    const TNodeI SrcNI = GetNI(SrcNId);
311    const int NodeN = SrcNI.NodeHI.GetDat().OutNIdV.SearchBin(DstNId);
312    IAssert(NodeN != -1);
313    return TEdgeI(SrcNI, EndNI(), NodeN);
314  }
315  void TNGraph::GetNIdV(TIntV& NIdV) const {
316    NIdV.Gen(GetNodes(), 0);
317    for (int N=NodeH.FFirstKeyId(); NodeH.FNextKeyId(N); ) {
318      NIdV.Add(NodeH.GetKey(N)); }
319  }
320  void TNGraph::Defrag(const bool& OnlyNodeLinks) {
321    for (int n = NodeH.FFirstKeyId(); NodeH.FNextKeyId(n); ) {
322      TNode& Node = NodeH[n];
323      Node.InNIdV.Pack();  Node.OutNIdV.Pack();
324    }
325    if (! OnlyNodeLinks && ! NodeH.IsKeyIdEqKeyN()) { NodeH.Defrag(); }
326  }
327  bool TNGraph::IsOk(const bool& ThrowExcept) const {
328    bool RetVal = true;
329    for (int N = NodeH.FFirstKeyId(); NodeH.FNextKeyId(N); ) {
330      const TNode& Node = NodeH[N];
331      if (! Node.OutNIdV.IsSorted()) {
332        const TStr Msg = TStr::Fmt("Out-neighbor list of node %d is not sorted.", Node.GetId());
333        if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
334      }
335      if (! Node.InNIdV.IsSorted()) {
336        const TStr Msg = TStr::Fmt("In-neighbor list of node %d is not sorted.", Node.GetId());
337        if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
338      }
339      int prevNId = -1;
340      for (int e = 0; e < Node.GetOutDeg(); e++) {
341        if (! IsNode(Node.GetOutNId(e))) {
342          const TStr Msg = TStr::Fmt("Out-edge %d --> %d: node %d does not exist.",
343            Node.GetId(), Node.GetOutNId(e), Node.GetOutNId(e));
344          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
345        }
346        if (e > 0 && prevNId == Node.GetOutNId(e)) {
347          const TStr Msg = TStr::Fmt("Node %d has duplidate out-edge %d --> %d.",
348            Node.GetId(), Node.GetId(), Node.GetOutNId(e));
349          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
350        }
351        prevNId = Node.GetOutNId(e);
352      }
353      prevNId = -1;
354      for (int e = 0; e < Node.GetInDeg(); e++) {
355        if (! IsNode(Node.GetInNId(e))) {
356          const TStr Msg = TStr::Fmt("In-edge %d <-- %d: node %d does not exist.",
357            Node.GetId(), Node.GetInNId(e), Node.GetInNId(e));
358          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
359        }
360        if (e > 0 && prevNId == Node.GetInNId(e)) {
361          const TStr Msg = TStr::Fmt("Node %d has duplidate in-edge %d <-- %d.",
362            Node.GetId(), Node.GetId(), Node.GetInNId(e));
363          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
364        }
365        prevNId = Node.GetInNId(e);
366      }
367    }
368    return RetVal;
369  }
370  void TNGraph::Dump(FILE *OutF) const {
371    const int NodePlaces = (int) ceil(log10((double) GetNodes()));
372    fprintf(OutF, "-------------------------------------------------\nDirected Node Graph: nodes: %d, edges: %d\n", GetNodes(), GetEdges());
373    for (int N = NodeH.FFirstKeyId(); NodeH.FNextKeyId(N); ) {
374      const TNode& Node = NodeH[N];
375      fprintf(OutF, "  %*d]\n", NodePlaces, Node.GetId());
376      fprintf(OutF, "    in [%d]", Node.GetInDeg());
377      for (int edge = 0; edge < Node.GetInDeg(); edge++) {
378        fprintf(OutF, " %*d", NodePlaces, Node.GetInNId(edge)); }
379      fprintf(OutF, "\n    out[%d]", Node.GetOutDeg());
380      for (int edge = 0; edge < Node.GetOutDeg(); edge++) {
381        fprintf(OutF, " %*d", NodePlaces, Node.GetOutNId(edge)); }
382      fprintf(OutF, "\n");
383    }
384    fprintf(OutF, "\n");
385  }
386  PNGraph TNGraph::GetSmallGraph() {
387    PNGraph G = TNGraph::New();
388    for (int i = 0; i < 5; i++) { G->AddNode(i); }
389    G->AddEdge(0,1); G->AddEdge(1,2); G->AddEdge(0,2);
390    G->AddEdge(1,3); G->AddEdge(3,4); G->AddEdge(2,3);
391    return G;
392  }
393  bool TNEGraph::HasFlag(const TGraphFlag& Flag) const {
394    return HasGraphFlag(TNEGraph::TNet, Flag);
395  }
396  bool TNEGraph::TNodeI::IsInNId(const int& NId) const {
397    const TNode& Node = NodeHI.GetDat();
398    for (int edge = 0; edge < Node.GetInDeg(); edge++) {
399      if (NId == Graph->GetEdge(Node.GetInEId(edge)).GetSrcNId())
400        return true;
401    }
402    return false;
403  }
404  bool TNEGraph::TNodeI::IsOutNId(const int& NId) const {
405    const TNode& Node = NodeHI.GetDat();
406    for (int edge = 0; edge < Node.GetOutDeg(); edge++) {
407      if (NId == Graph->GetEdge(Node.GetOutEId(edge)).GetDstNId())
408        return true;
409    }
410    return false;
411  }
412  int TNEGraph::AddNode(int NId) {
413    if (NId == -1) {
414      NId = MxNId;  MxNId++;
415    } else {
416      IAssertR(!IsNode(NId), TStr::Fmt("NodeId %d already exists", NId));
417      MxNId = TMath::Mx(NId+1, MxNId());
418    }
419    NodeH.AddDat(NId, TNode(NId));
420    return NId;
421  }
422  void TNEGraph::DelNode(const int& NId) {
423    const TNode& Node = GetNode(NId);
424    for (int out = 0; out < Node.GetOutDeg(); out++) {
425      const int EId = Node.GetOutEId(out);
426      const TEdge& Edge = GetEdge(EId);
427      IAssert(Edge.GetSrcNId() == NId);
428      GetNode(Edge.GetDstNId()).InEIdV.DelIfIn(EId);
429      EdgeH.DelKey(EId);
430    }
431    for (int in = 0; in < Node.GetInDeg(); in++) {
432      const int EId = Node.GetInEId(in);
433      const TEdge& Edge = GetEdge(EId);
434      IAssert(Edge.GetDstNId() == NId);
435      GetNode(Edge.GetSrcNId()).OutEIdV.DelIfIn(EId);
436      EdgeH.DelKey(EId);
437    }
438    NodeH.DelKey(NId);
439  }
440  int TNEGraph::AddEdge(const int& SrcNId, const int& DstNId, int EId) {
441    if (EId == -1) { EId = MxEId;  MxEId++; }
442    else { MxEId = TMath::Mx(EId+1, MxEId()); }
443    IAssertR(!IsEdge(EId), TStr::Fmt("EdgeId %d already exists", EId));
444    IAssertR(IsNode(SrcNId) && IsNode(DstNId), TStr::Fmt("%d or %d not a node.", SrcNId, DstNId).CStr());
445    EdgeH.AddDat(EId, TEdge(EId, SrcNId, DstNId));
446    GetNode(SrcNId).OutEIdV.AddSorted(EId);
447    GetNode(DstNId).InEIdV.AddSorted(EId);
448    return EId;
449  }
450  void TNEGraph::DelEdge(const int& EId) {
451    IAssert(IsEdge(EId));
452    const int SrcNId = GetEdge(EId).GetSrcNId();
453    const int DstNId = GetEdge(EId).GetDstNId();
454    GetNode(SrcNId).OutEIdV.DelIfIn(EId);
455    GetNode(DstNId).InEIdV.DelIfIn(EId);
456    EdgeH.DelKey(EId);
457  }
458  void TNEGraph::DelEdge(const int& SrcNId, const int& DstNId, const bool& IsDir) {
459    int EId;
460    IAssert(IsEdge(SrcNId, DstNId, EId, IsDir)); 
461    while (IsEdge(SrcNId, DstNId, EId, IsDir)) {
462      GetNode(SrcNId).OutEIdV.DelIfIn(EId);
463      GetNode(DstNId).InEIdV.DelIfIn(EId);
464    }
465    EdgeH.DelKey(EId);
466  }
467  bool TNEGraph::IsEdge(const int& SrcNId, const int& DstNId, int& EId, const bool& IsDir) const {
468    const TNode& SrcNode = GetNode(SrcNId);
469    for (int edge = 0; edge < SrcNode.GetOutDeg(); edge++) {
470      const TEdge& Edge = GetEdge(SrcNode.GetOutEId(edge));
471      if (DstNId == Edge.GetDstNId()) {
472        EId = Edge.GetId();  return true; }
473    }
474    if (! IsDir) {
475      for (int edge = 0; edge < SrcNode.GetInDeg(); edge++) {
476      const TEdge& Edge = GetEdge(SrcNode.GetInEId(edge));
477      if (DstNId == Edge.GetSrcNId()) {
478        EId = Edge.GetId();  return true; }
479      }
480    }
481    return false;
482  }
483  void TNEGraph::GetNIdV(TIntV& NIdV) const {
484    NIdV.Gen(GetNodes(), 0);
485    for (int N=NodeH.FFirstKeyId(); NodeH.FNextKeyId(N); ) {
486      NIdV.Add(NodeH.GetKey(N)); }
487  }
488  void TNEGraph::GetEIdV(TIntV& EIdV) const {
489    EIdV.Gen(GetEdges(), 0);
490    for (int E=EdgeH.FFirstKeyId(); EdgeH.FNextKeyId(E); ) {
491      EIdV.Add(EdgeH.GetKey(E));
492    }
493  }
494  void TNEGraph::Defrag(const bool& OnlyNodeLinks) {
495    for (int kid = NodeH.FFirstKeyId(); NodeH.FNextKeyId(kid); ) {
496      TNode& Node = NodeH[kid];
497      Node.InEIdV.Pack();  Node.OutEIdV.Pack();
498    }
499    if (! OnlyNodeLinks && ! NodeH.IsKeyIdEqKeyN()) { NodeH.Defrag(); }
500    if (! OnlyNodeLinks && ! EdgeH.IsKeyIdEqKeyN()) { EdgeH.Defrag(); }
501  }
502  bool TNEGraph::IsOk(const bool& ThrowExcept) const {
503  bool RetVal = true;
504    for (int N = NodeH.FFirstKeyId(); NodeH.FNextKeyId(N); ) {
505      const TNode& Node = NodeH[N];
506      if (! Node.OutEIdV.IsSorted()) {
507        const TStr Msg = TStr::Fmt("Out-edge list of node %d is not sorted.", Node.GetId());
508        if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
509      }
510      if (! Node.InEIdV.IsSorted()) {
511        const TStr Msg = TStr::Fmt("In-edge list of node %d is not sorted.", Node.GetId());
512        if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
513      }
514      int prevEId = -1;
515      for (int e = 0; e < Node.GetOutDeg(); e++) {
516        if (! IsEdge(Node.GetOutEId(e))) {
517          const TStr Msg = TStr::Fmt("Out-edge id %d of node %d does not exist.",  Node.GetOutEId(e), Node.GetId());
518          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
519        }
520        if (e > 0 && prevEId == Node.GetOutEId(e)) {
521          const TStr Msg = TStr::Fmt("Node %d has duplidate out-edge id %d.", Node.GetId(), Node.GetOutEId(e));
522          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
523        }
524        prevEId = Node.GetOutEId(e);
525      }
526      prevEId = -1;
527      for (int e = 0; e < Node.GetInDeg(); e++) {
528        if (! IsEdge(Node.GetInEId(e))) {
529          const TStr Msg = TStr::Fmt("Out-edge id %d of node %d does not exist.",  Node.GetInEId(e), Node.GetId());
530          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
531        }
532        if (e > 0 && prevEId == Node.GetInEId(e)) {
533          const TStr Msg = TStr::Fmt("Node %d has duplidate out-edge id %d.", Node.GetId(), Node.GetInEId(e));
534          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
535        }
536        prevEId = Node.GetInEId(e);
537      }
538    }
539    for (int E = EdgeH.FFirstKeyId(); EdgeH.FNextKeyId(E); ) {
540      const TEdge& Edge = EdgeH[E];
541      if (! IsNode(Edge.GetSrcNId())) {
542        const TStr Msg = TStr::Fmt("Edge %d source node %d does not exist.", Edge.GetId(), Edge.GetSrcNId());
543        if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
544      }
545      if (! IsNode(Edge.GetDstNId())) {
546        const TStr Msg = TStr::Fmt("Edge %d destination node %d does not exist.", Edge.GetId(), Edge.GetDstNId());
547        if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
548      }
549    }
550    return RetVal;
551  }
552  void TNEGraph::Dump(FILE *OutF) const {
553    const int NodePlaces = (int) ceil(log10((double) GetNodes()));
554    const int EdgePlaces = (int) ceil(log10((double) GetEdges()));
555    fprintf(OutF, "-------------------------------------------------\nDirected Node-Edge Graph: nodes: %d, edges: %d\n", GetNodes(), GetEdges());
556    for (TNodeI NodeI = BegNI(); NodeI < EndNI(); NodeI++) {
557      fprintf(OutF, "  %*d]\n", NodePlaces, NodeI.GetId());
558      fprintf(OutF, "    in[%d]", NodeI.GetInDeg());
559      for (int edge = 0; edge < NodeI.GetInDeg(); edge++) {
560        fprintf(OutF, " %*d", EdgePlaces, NodeI.GetInEId(edge)); }
561      fprintf(OutF, "\n    out[%d]", NodeI.GetOutDeg());
562      for (int edge = 0; edge < NodeI.GetOutDeg(); edge++) {
563        fprintf(OutF, " %*d", EdgePlaces, NodeI.GetOutEId(edge)); }
564      fprintf(OutF, "\n");
565    }
566    for (TEdgeI EdgeI = BegEI(); EdgeI < EndEI(); EdgeI++) {
567      fprintf(OutF, "  %*d]  %*d  ->  %*d\n", EdgePlaces, EdgeI.GetId(), NodePlaces, EdgeI.GetSrcNId(), NodePlaces, EdgeI.GetDstNId());
568    }
569    fprintf(OutF, "\n");
570  }
571  PNEGraph TNEGraph::GetSmallGraph() {
572    PNEGraph Graph = TNEGraph::New();
573    for (int i = 0; i < 5; i++) { Graph->AddNode(i); }
574    Graph->AddEdge(0,1);  Graph->AddEdge(0,2);
575    Graph->AddEdge(0,3);  Graph->AddEdge(0,4);
576    Graph->AddEdge(1,2);  Graph->AddEdge(1,2);
577    return Graph;
578  }
579  int TBPGraph::AddNode(int NId, const bool& LeftNode) {
580    if (NId == -1) { NId = MxNId;  MxNId++; }
581    else if (IsLNode(NId)) { IAssertR(LeftNode, TStr::Fmt("Node with id %s already exists on the 'left'.", NId));  return NId; }
582    else if (IsRNode(NId)) { IAssertR(! LeftNode, TStr::Fmt("Node with id %s already exists on the 'right'.", NId));  return NId; }
583    else { MxNId = TMath::Mx(NId+1, MxNId()); }
584    if (LeftNode) { LeftH.AddDat(NId, TNode(NId)); }
585    else { RightH.AddDat(NId, TNode(NId)); }
586    return NId;
587  }
588  void TBPGraph::DelNode(const int& NId) {
589    AssertR(IsNode(NId), TStr::Fmt("NodeId %d does not exist", NId));
590    THash<TInt, TNode>& SrcH = IsLNode(NId) ? LeftH : RightH;
591    THash<TInt, TNode>& DstH = IsLNode(NId) ? RightH : LeftH;
592    { TNode& Node = SrcH.GetDat(NId);
593    for (int e = 0; e < Node.GetOutDeg(); e++) {
594      const int nbr = Node.GetOutNId(e);
595      IAssertR(nbr != NId, "Bipartite graph has a loop!");
596      TNode& N = DstH.GetDat(nbr);
597      const int n = N.NIdV.SearchBin(NId);
598      IAssert(n!= -1); 
599      N.NIdV.Del(n);
600    } }
601    SrcH.DelKey(NId);
602  }
603  int TBPGraph::GetEdges() const {
604    int Edges = 0;
605    for (int N=LeftH.FFirstKeyId(); LeftH.FNextKeyId(N); ) {
606      Edges += LeftH[N].GetDeg(); }
607    return Edges;
608  }
609  int TBPGraph::AddEdge(const int& LeftNId, const int& RightNId) {
610    const bool IsLL = IsLNode(LeftNId), IsLR = IsRNode(LeftNId);
611    const bool IsRL = IsLNode(RightNId), IsRR = IsRNode(RightNId);
612    IAssertR((IsLL||IsLR)&&(IsRL||IsRR), TStr::Fmt("%d or %d is not a node.", LeftNId, RightNId).CStr());
613    IAssertR(LeftNId!=RightNId, "No self-edges are allowed."); 
614    IAssertR((IsLL&&!IsLR&&!IsRL&&IsRR)||(!IsLL&&IsLR&&IsRL&&!IsRR), "One node should be on the 'left' and the other on the 'right'.");
615    const int LNId = IsLL ? LeftNId : RightNId; 
616    const int RNId = IsLL ? RightNId : LeftNId; 
617    if (LeftH.GetDat(LNId).IsOutNId(RNId)) { return -2; } 
618    LeftH.GetDat(LNId).NIdV.AddSorted(RNId);
619    RightH.GetDat(RNId).NIdV.AddSorted(LNId);
620    return -1; 
621  }
622  void TBPGraph::DelEdge(const int& LeftNId, const int& RightNId) {
623    const bool IsLL = IsLNode(LeftNId), IsLR = IsRNode(LeftNId);
624    const bool IsRL = IsLNode(RightNId), IsRR = IsRNode(RightNId);
625    IAssertR((IsLL||IsLR)&&(IsRL||IsRR), TStr::Fmt("%d or %d is not a node.", LeftNId, RightNId).CStr());
626    IAssertR(LeftNId!=RightNId, "No self-edges are allowed."); 
627    IAssertR((IsLL&&!IsLR&&!IsRL&&IsRR)||(!IsLL&&IsLR&&IsRL&&!IsRR), "One node should be on the 'left' and the other on the 'right'.");
628    const int LNId = IsLL ? LeftNId : RightNId; 
629    const int RNId = IsLL ? RightNId : LeftNId; 
630    { TIntV& NIdV = LeftH.GetDat(LNId).NIdV;
631    const int n = NIdV.SearchBin(RNId);
632    if (n != -1) { NIdV.Del(n); } }
633    { TIntV& NIdV = RightH.GetDat(RNId).NIdV;
634    const int n = NIdV.SearchBin(LNId);
635    if (n != -1) { NIdV.Del(n); } }
636  }
637  bool TBPGraph::IsEdge(const int& LeftNId, const int& RightNId) const {
638    if (! IsNode(LeftNId) || ! IsNode(RightNId)) { return false; }
639    return IsLNode(LeftNId) ? LeftH.GetDat(LeftNId).IsOutNId(RightNId) : RightH.GetDat(LeftNId).IsOutNId(RightNId);
640  }
641  TBPGraph::TEdgeI TBPGraph::GetEI(const int& LeftNId, const int& RightNId) const {
642    const bool IsLL = IsLNode(LeftNId), IsLR = IsRNode(LeftNId);
643    const bool IsRL = IsLNode(RightNId), IsRR = IsRNode(RightNId);
644    IAssertR((IsLL||IsLR)&&(IsRL||IsRR), TStr::Fmt("%d or %d is not a node.", LeftNId, RightNId).CStr());
645    IAssertR(LeftNId!=RightNId, "No self-edges are allowed."); 
646    IAssertR((IsLL&&!IsLR&&!IsRL&&IsRR)||(!IsLL&&IsLR&&IsRL&&!IsRR), "One node should be on the 'left' and the other on the 'right'.");
647    const int LNId = IsLL ? LeftNId : RightNId; 
648    const int RNId = IsLL ? RightNId : LeftNId; 
649    const TNodeI SrcNI = GetNI(LNId);
650    const int NodeN = SrcNI.LeftHI.GetDat().NIdV.SearchBin(RNId);
651    IAssertR(NodeN != -1, "Right edge endpoint does not exists!");
652    return TEdgeI(SrcNI, EndNI(), NodeN);
653  }
654  int TBPGraph::GetRndNId(TRnd& Rnd) { 
655    const int NNodes = GetNodes();
656    if (Rnd.GetUniDevInt(NNodes) < GetLNodes()) {
657      return GetRndLNId(Rnd); }
658    else {
659      return GetRndRNId(Rnd); }
660  }
661  int TBPGraph::GetRndLNId(TRnd& Rnd) { 
662    return LeftH.GetKey(LeftH.GetRndKeyId(Rnd, 0.8)); 
663  }
664  int TBPGraph::GetRndRNId(TRnd& Rnd) { 
665    return RightH.GetKey(RightH.GetRndKeyId(Rnd, 0.8)); 
666  }
667  void TBPGraph::GetNIdV(TIntV& NIdV) const {
668    NIdV.Gen(GetNodes(), 0);
669    for (int N=LeftH.FFirstKeyId(); LeftH.FNextKeyId(N); ) {
670      NIdV.Add(LeftH.GetKey(N)); }
671    for (int N=RightH.FFirstKeyId(); RightH.FNextKeyId(N); ) {
672      NIdV.Add(RightH.GetKey(N)); }
673  }
674  void TBPGraph::GetLNIdV(TIntV& NIdV) const {
675    NIdV.Gen(GetLNodes(), 0);
676    for (int N=LeftH.FFirstKeyId(); LeftH.FNextKeyId(N); ) {
677      NIdV.Add(LeftH.GetKey(N)); }
678  }
679  void TBPGraph::GetRNIdV(TIntV& NIdV) const {
680    NIdV.Gen(GetRNodes(), 0);
681    for (int N=RightH.FFirstKeyId(); RightH.FNextKeyId(N); ) {
682      NIdV.Add(RightH.GetKey(N)); }
683  }
684  void TBPGraph::Reserve(const int& Nodes, const int& Edges) { 
685    if (Nodes>0) { LeftH.Gen(Nodes/2); RightH.Gen(Nodes/2); } 
686  }
687  void TBPGraph::Defrag(const bool& OnlyNodeLinks) {
688    for (int n = LeftH.FFirstKeyId(); LeftH.FNextKeyId(n); ) {
689      LeftH[n].NIdV.Pack(); }
690    for (int n = RightH.FFirstKeyId(); RightH.FNextKeyId(n); ) {
691      RightH[n].NIdV.Pack(); }
692    if (! OnlyNodeLinks && ! LeftH.IsKeyIdEqKeyN()) { LeftH.Defrag(); }
693    if (! OnlyNodeLinks && ! RightH.IsKeyIdEqKeyN()) { RightH.Defrag(); }
694  }
695  bool TBPGraph::IsOk(const bool& ThrowExcept) const {
696    bool RetVal = false;
697    for (int n = LeftH.FFirstKeyId(); LeftH.FNextKeyId(n); ) {
698      if (! LeftH[n].NIdV.IsSorted()) {
699        const TStr Msg = TStr::Fmt("Neighbor list of node %d is not sorted.", LeftH[n].GetId());
700        if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false; }
701    }
702    for (int n = RightH.FFirstKeyId(); RightH.FNextKeyId(n); ) {
703      if (! RightH[n].NIdV.IsSorted()) {
704        const TStr Msg = TStr::Fmt("Neighbor list of node %d is not sorted.", RightH[n].GetId());
705        if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false; }
706    }
707    for (int n = LeftH.FFirstKeyId(); LeftH.FNextKeyId(n); ) {
708      if (RightH.IsKey(LeftH[n].GetId())) {
709        const TStr Msg = TStr::Fmt("'Left' node %d also appears on the 'right'.", LeftH[n].GetId());
710        if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false; }
711    } 
712    for (int n = RightH.FFirstKeyId(); RightH.FNextKeyId(n); ) {
713      if (LeftH.IsKey(RightH[n].GetId())) {
714        const TStr Msg = TStr::Fmt("'Right' node %d also appears on the 'left'.", RightH[n].GetId());
715        if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false; }
716    }
717    for (int n = LeftH.FFirstKeyId(); LeftH.FNextKeyId(n); ) {
718      for (int e = 0; e < LeftH[n].NIdV.Len(); e++) {
719        if (! RightH.IsKey(LeftH[n].NIdV[e]) || ! RightH.GetDat(LeftH[n].NIdV[e]).NIdV.IsIn(LeftH[n].GetId())) {
720          const TStr Msg = TStr::Fmt("'Left' node %d does not point to the 'right' node %d.", LeftH[n].GetId(), LeftH[n].NIdV[e]());
721          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false; }
722      }
723    }
724    for (int n = RightH.FFirstKeyId(); RightH.FNextKeyId(n); ) {
725      for (int e = 0; e < RightH[n].NIdV.Len(); e++) {
726        if (! LeftH.IsKey(RightH[n].NIdV[e]) || ! LeftH.GetDat(RightH[n].NIdV[e]).NIdV.IsIn(RightH[n].GetId())) {
727          const TStr Msg = TStr::Fmt("'Left' node %d does not point to the 'right' node %d.", RightH[n].GetId(), RightH[n].NIdV[e]());
728          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false; }
729      }
730    }
731    return RetVal;
732  }
733  void TBPGraph::Dump(FILE *OutF) const {
734    const int NodePlaces = (int) ceil(log10((double) GetNodes()));
735    fprintf(OutF, "-------------------------------------------------\nBipartite Graph: nodes: %d+%d=%d, edges: %d\n", GetLNodes(), GetRNodes(), GetNodes(), GetEdges());
736    for (int N = LeftH.FFirstKeyId(); LeftH.FNextKeyId(N); ) {
737      const TNode& Node = LeftH[N];
738      fprintf(OutF, "  %*d [%d] ", NodePlaces, Node.GetId(), Node.GetDeg());
739      for (int edge = 0; edge < Node.GetDeg(); edge++) {
740        fprintf(OutF, " %*d", NodePlaces, Node.GetNbrNId(edge)); }
741      fprintf(OutF, "\n");
742    }
743    fprintf(OutF, "\n");
744  }
745  PBPGraph TBPGraph::GetSmallGraph() {
746    PBPGraph BP = TBPGraph::New();
747    BP->AddNode(0, true);
748    BP->AddNode(1, true);
749    BP->AddNode(2, false);
750    BP->AddNode(3, false);
751    BP->AddNode(4, false);
752    BP->AddEdge(0, 2);
753    BP->AddEdge(0, 3);
754    BP->AddEdge(1, 2);
755    BP->AddEdge(1, 3);
756    BP->AddEdge(1, 4);
757    return BP;
758  }
759  bool THGraph::HasFlag(const TGraphFlag& Flag) const {
760    return HasGraphFlag(THGraph::TNet, Flag);
761  }
762  int THGraph::AddNode(int NId, TStr NName) {
763    if (NId == -1) {
764      NId = MxNId;  MxNId++;
765    } else {
766      IAssertR(!IsNode(NId), TStr::Fmt("NodeId %d already exists", NId));
767      MxNId = TMath::Mx(NId+1, MxNId());
768    }
769    NodeH.AddDat(NId, TNode(NId, NName));
770    return NId;
771  }
772  int THGraph::AddNodeUnchecked(int NId, TStr NName) {
773    if (IsNode(NId)) { return -1;}
774    MxNId = TMath::Mx(NId+1, MxNId());
775    NodeH.AddDat(NId, TNode(NId, NName));
776    return NId;
777  }
778  void THGraph::DelNode(const int& NId) {
779    AssertR(IsNode(NId), TStr::Fmt("NodeId %d does not exist", NId));
780    TNode& Node = GetNode(NId);
781    int EId = Node.EIdV.GetVal(0);
782    int NumNei;
783    TIntSet& ENIdsHS = GetEdge(EId).NeiNIdSH;
784    for (int e = 0; e < Node.GetDeg(); e++) {
785      EId = Node.EIdV.GetVal(e);
786      ENIdsHS = GetEdge(EId).NeiNIdSH;
787      int iKey;
788      for (int i=0; i < ENIdsHS.Len(); i++) {
789        iKey = ENIdsHS.GetKey(i);
790        if (iKey == NId) { continue; }
791        GetNode(iKey).DelNeighbor(NId);
792      }
793      NumNei = ENIdsHS.Len();
794      N2Edges = N2Edges - (NumNei*(NumNei-1))/2 + ((NumNei-1)*(NumNei-2))/2;
795      if (ENIdsHS.Len() > 2) {
796        GetEdge(EId).NeiNIdSH.DelKey(NId);
797      } else { DelEdge(EId); }
798      NodeH.DelKey(NId);
799    }
800    delete &Node;
801  }
802  void THGraph::TNode::UpdEInfo(const int& EId, const TIntSet& ENodesHS){
803    if (! EIdV.IsIn(EId)) {
804      EIdV.Add(EId);
805      for (int j = 0; j < ENodesHS.Len(); j++) {
806        if (Id == ENodesHS.GetKey(j)) { continue; }
807        if (! NbrNIdENumH.IsKey(ENodesHS.GetKey(j))) {
808          NbrNIdENumH.AddDat(ENodesHS.GetKey(j), 1);
809        } else {
810          NbrNIdENumH.AddDat(ENodesHS.GetKey(j), 1 + NbrNIdENumH.GetDat(ENodesHS.GetKey(j)));
811        }
812      }
813    }
814  }
815  inline THGraph::TEdge::TEdge( THGraph* GraphPt, const TIntSet& NodeIdsHS) {
816    TInt EIdCandidate = GraphPt->NEdges;
817    while (GraphPt->EdgeH.IsKey(EIdCandidate)) { EIdCandidate++; }
818    TEdge(EIdCandidate, NodeIdsHS, GraphPt);
819  }
820  inline THGraph::TEdge::TEdge( THGraph* GraphPt, const TIntV& NodeIdsV) {
821    TInt EIdCandidate = GraphPt->NEdges;
822    while (GraphPt->EdgeH.IsKey(EIdCandidate)) { EIdCandidate++; }
823    TEdge(EIdCandidate, NodeIdsV, GraphPt);
824  }
825  void THGraph::TEdge::UpdNEInfo(const TIntSet& ENodesHS){
826    for (int i = 0; i < ENodesHS.Len(); i++) {
827      Graph->GetNode(ENodesHS.GetKey(i)).UpdEInfo(Id, ENodesHS);
828    }
829  }
830  bool THGraph::IsEdge(const TIntSet& NIdH) {
831    if (NIdH.Len() < 2) { return false; }
832    if (! IsNode(NIdH.GetKey(0))) { return false; }
833    int NId = NIdH.GetKey(0);
834    TIntSet SharedEIdsH;
835    NodeH.GetDat(NId).GetEIDs(SharedEIdsH);
836    for (int n = 1; n< NIdH.Len(); n++){
837      int N1Id = NIdH.GetKey(n);
838      TIntSet NeiEIdH;
839      NodeH.GetDat(N1Id).GetEIDs(NeiEIdH);
840      TIntersect(SharedEIdsH, NeiEIdH);
841      if (SharedEIdsH.Len()==0) { return false; }
842    }
843    for (THashSetKeyI<TInt> e = SharedEIdsH.BegI(); e < SharedEIdsH.EndI(); e++) {
844      if(GetEI(e.GetKey()).Len() == NIdH.Len()) {
845        return true;
846      }
847    }
848    return false;
849  }
850  int THGraph::AddEdge(const TIntSet& NIdH, int& EId) {
851    if (IsEdge(NIdH)) { return -1; }
852    EId = TMath::Mx(EId, MxEId());
853    MxEId = EId + 1;
854    IAssertR(!IsEdgeId(EId), TStr::Fmt("EdgeId %d already exists", EId));
855    EdgeH.AddDat(EId, TEdge(EId, NIdH, this));
856    EdgeH.GetDat(EId).UpdNEInfo(NIdH);
857    NEdges++;
858    N2Edges += (NIdH.Len() * (NIdH.Len()-1))/2;
859    return EId;
860  }
861  int THGraph::AssertNodes(const TIntSet& NodesIS) {
862    int NKey;
863    for (int N=0; N < NodesIS.Len(); N++) {
864      NKey = NodesIS.GetKey(N);
865      if (! IsNode(NKey)) {return NKey;}
866    }
867    return -1;
868  }
869  void THGraph::DelEdge(const int& EId) {
870    IAssertR(IsEdgeId(EId), TStr::Fmt("EdgeId %d not found", EId));
871    TIntSet NodeIdsHS = GetEdge(EId).NeiNIdSH;
872    int iKey, jKey;
873    for (int i=NodeIdsHS.FFirstKeyId(); NodeIdsHS.FNextKeyId(i); ) {
874      iKey = NodeIdsHS.GetKey(i);
875      for (int j=NodeIdsHS.FFirstKeyId(); NodeIdsHS.FNextKeyId(j); ) {
876        if (i==j) { continue; }
877        jKey = NodeIdsHS.GetKey(j);
878        GetNode(iKey).DelNeighbor(jKey);
879      }
880    }
881    EdgeH.DelKey(EId);
882    int ESize = GetEdge(EId).NeiNIdSH.Len();
883    NEdges--;
884    N2Edges -= (ESize*(ESize-1))/2;
885    delete &GetEdge(EId);
886  }
887  void THGraph::GetNIdV(TIntV& NIdV) const {
888    NIdV.Gen(GetNodes(), 0);
889    for (int N=NodeH.FFirstKeyId(); NodeH.FNextKeyId(N); ) {
890      NIdV.Add(NodeH.GetKey(N)); }
891  }
892  void THGraph::Defrag(const bool& OnlyNodeLinks) {
893    int nKey;
894    for (int n = EdgeH.FFirstKeyId(); EdgeH.FNextKeyId(n); ) {
895      nKey = EdgeH.GetKey(n);
896      if (! EdgeH.GetDat(nKey).NeiNIdSH.IsKeyIdEqKeyN()) {
897        EdgeH.GetDat(nKey).NeiNIdSH.Defrag();
898      }
899    }
900    for (int n = NodeH.FFirstKeyId(); NodeH.FNextKeyId(n); ) {
901      nKey = NodeH.GetKey(n);
902      NodeH.GetDat(nKey).EIdV.Pack();
903      if (! NodeH.GetDat(nKey).NbrNIdENumH.IsKeyIdEqKeyN()) {
904        NodeH.GetDat(nKey).NbrNIdENumH.Defrag();
905      }
906    }
907    if (! OnlyNodeLinks) {
908      if (! NodeH.IsKeyIdEqKeyN()){ NodeH.Defrag(); }
909      if (! EdgeH.IsKeyIdEqKeyN()){ EdgeH.Defrag(); }
910    }
911  }
912  void THGraph::PrintEdge(const int EId) {
913    if (! EdgeH.IsKey(EId)) {
914      printf("\nEdge Not Found!\n");
915    }
916    TIntV NV;
917    TStr EStr("Edge nodes: ");
918    EdgeH.GetDat(EId).GetNodesV(NV);
919    for (int i = 0; i < NV.Len(); i++) {
920      EStr += (" " + NV[i].GetStr());
921    }
922    EStr += "\n";
923    printf(EStr.GetCStr());
924  }
925  void THGraph::Dump(FILE *OutF) const {
926    const int NodePlaces = (int) ceil(log10((double) GetNodes()));
927    int NKey;
928    for (int N = NodeH.FFirstKeyId(); NodeH.FNextKeyId(N); ) {
929      NKey = NodeH.GetKey(N);
930      const TNode& Node = NodeH.GetDat(NKey);
931      fprintf(OutF, "  %*d [%d] ", NodePlaces, Node.GetId(), Node.GetDeg());
932      for (int edge = 0; edge < Node.GetDeg(); edge++) {
933        fprintf(OutF, " %*d", NodePlaces, Node.GetNbrNId(edge)); }
934      fprintf(OutF, "\n");
935    }
936    fprintf(OutF, "\n");
937  }
938  PHGraph THGraph::GetSmallGraph() {
939    PHGraph Graph = THGraph::New();
940    for (int i = 0; i < 5; i++) { Graph->AddNode(i); }
941    TIntV EV(3);
942    int el[] = {0,1,3};
943    for (int i = 0; i < 3; i++)
944      EV.Add(el[i]);
945    Graph->AddEdge(EV);
946    return Graph;
947  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-graphmp.cpp</h3>
            <pre><code>1  #ifdef GCC_ATOMIC
2  bool TNGraphMP::HasFlag(const TGraphFlag& Flag) const {
3    return HasGraphFlag(TNGraphMP::TNet, Flag);
4  }
5  int TNGraphMP::AddNode(int NId) {
6    if (NId == -1) {
7      NId = MxNId;  MxNId++;
8    } else {
9      IAssertR(!IsNode(NId), TStr::Fmt("NodeId %d already exists", NId));
10      MxNId = TMath::Mx(NId+1, MxNId());
11    }
12    NodeH.AddDat(NId, TNode(NId));
13    return NId;
14  }
15  int TNGraphMP::AddNodeUnchecked(int NId) {
16    if (IsNode(NId)) { return NId;}
17    MxNId = TMath::Mx(NId+1, MxNId());
18    NodeH.AddDat(NId, TNode(NId));
19    return NId;
20  }
21  int TNGraphMP::AddNode(const int& NId, const TIntV& InNIdV, const TIntV& OutNIdV) {
22    int NewNId;
23    if (NId == -1) {
24      NewNId = MxNId;  MxNId++;
25    } else {
26      IAssertR(!IsNode(NId), TStr::Fmt("NodeId %d already exists", NId));
27      NewNId = NId;
28      MxNId = TMath::Mx(NewNId+1, MxNId());
29    }
30    TNode& Node = NodeH.AddDat(NewNId);
31    Node.Id = NewNId;
32    Node.InNIdV = InNIdV;
33    Node.OutNIdV = OutNIdV;
34    Node.InNIdV.Sort();
35    Node.OutNIdV.Sort();
36    return NewNId;
37  }
<span onclick='openModal()' class='match'>38  int TNGraphMP::AddNode(const int& NId, const TVecPool<TInt>& Pool, const int& SrcVId, const int& DstVId) {
39    int NewNId;
40    if (NId == -1) {
41      NewNId = MxNId;  MxNId++;
42    } else {
43      IAssertR(!IsNode(NId), TStr::Fmt("NodeId %d already exists", NId));
44      NewNId = NId;
45      MxNId = TMath::Mx(NewNId+1, MxNId());
46    }
47    TNode& Node = NodeH.AddDat(NewNId);
48    Node.Id = NewNId;
49    Node.InNIdV.GenExt(Pool.GetValVPt(SrcVId), Pool.GetVLen(SrcVId));
50    Node.OutNIdV.GenExt(Pool.GetValVPt(DstVId), Pool.GetVLen(DstVId));
51    Node.InNIdV.Sort();
52    Node.OutNIdV.Sort();
53    return NewNId;
54  }
55  void TNGraphMP::DelNode(const int& NId) {
56  #if 0
</span>57    { TNode& Node = GetNode(NId);
58    for (int e = 0; e < Node.GetOutDeg(); e++) {
59    const int nbr = Node.GetOutNId(e);
60    if (nbr == NId) { continue; }
61      TNode& N = GetNode(nbr);
62      const int n = N.InNIdV.SearchBin(NId);
63      if (n!= -1) { N.InNIdV.Del(n); }
64    }
65    for (int e = 0; e < Node.GetInDeg(); e++) {
66    const int nbr = Node.GetInNId(e);
67    if (nbr == NId) { continue; }
68      TNode& N = GetNode(nbr);
69      const int n = N.OutNIdV.SearchBin(NId);
70      if (n!= -1) { N.OutNIdV.Del(n); }
71    } }
72    NodeH.DelKey(NId);
73  #endif
74  }
75  int TNGraphMP::GetEdges() const {
76    int edges=0;
77    for (int N=NodeH.FFirstKeyId(); NodeH.FNextKeyId(N); ) {
78      edges+=NodeH[N].GetOutDeg();
79    }
80    return edges;
81  }
82  int TNGraphMP::AddEdge(const int& SrcNId, const int& DstNId) {
83    IAssertR(IsNode(SrcNId) && IsNode(DstNId), TStr::Fmt("%d or %d not a node.", SrcNId, DstNId).CStr());
84    if (IsEdge(SrcNId, DstNId)) { return -2; }
85    GetNode(SrcNId).OutNIdV.AddSorted(DstNId);
86    GetNode(DstNId).InNIdV.AddSorted(SrcNId);
87    return -1; 
88  }
89  int TNGraphMP::AddEdgeUnchecked(const int& SrcNId, const int& DstNId) {
90    GetNode(SrcNId).OutNIdV.Add(DstNId);
91    GetNode(DstNId).InNIdV.Add(SrcNId);
92    return -1; 
93  }
94  void TNGraphMP::DelEdge(const int& SrcNId, const int& DstNId, const bool& IsDir) {
95    IAssertR(IsNode(SrcNId) && IsNode(DstNId), TStr::Fmt("%d or %d not a node.", SrcNId, DstNId).CStr());
96    { TNode& N = GetNode(SrcNId);
97    const int n = N.OutNIdV.SearchBin(DstNId);
98    if (n!= -1) { N.OutNIdV.Del(n); } }
99    { TNode& N = GetNode(DstNId);
100    const int n = N.InNIdV.SearchBin(SrcNId);
101    if (n!= -1) { N.InNIdV.Del(n); } }
102    if (! IsDir) {
103      { TNode& N = GetNode(SrcNId);
104      const int n = N.InNIdV.SearchBin(DstNId);
105      if (n!= -1) { N.InNIdV.Del(n); } }
106      { TNode& N = GetNode(DstNId);
107      const int n = N.OutNIdV.SearchBin(SrcNId);
108      if (n!= -1) { N.OutNIdV.Del(n); } }
109    }
110  }
111  bool TNGraphMP::IsEdge(const int& SrcNId, const int& DstNId, const bool& IsDir) const {
112    if (! IsNode(SrcNId) || ! IsNode(DstNId)) { return false; }
113    if (IsDir) { return GetNode(SrcNId).IsOutNId(DstNId); }
114    else { return GetNode(SrcNId).IsOutNId(DstNId) || GetNode(DstNId).IsOutNId(SrcNId); }
115  }
116  TNGraphMP::TEdgeI TNGraphMP::GetEI(const int& SrcNId, const int& DstNId) const {
117    const TNodeI SrcNI = GetNI(SrcNId);
118    const int NodeN = SrcNI.NodeHI.GetDat().OutNIdV.SearchBin(DstNId);
119    IAssert(NodeN != -1);
120    return TEdgeI(SrcNI, EndNI(), NodeN);
121  }
122  void TNGraphMP::GetNIdV(TIntV& NIdV) const {
123    NIdV.Gen(GetNodes(), 0);
124    for (int N=NodeH.FFirstKeyId(); NodeH.FNextKeyId(N); ) {
125      NIdV.Add(NodeH.GetKey(N)); }
126  }
127  void TNGraphMP::Defrag(const bool& OnlyNodeLinks) {
128  #if 0
129    for (int n = NodeH.FFirstKeyId(); NodeH.FNextKeyId(n); ) {
130      TNode& Node = NodeH[n];
131      Node.InNIdV.Pack();  Node.OutNIdV.Pack();
132    }
133    if (! OnlyNodeLinks && ! NodeH.IsKeyIdEqKeyN()) { NodeH.Defrag(); }
134  #endif
135  }
136  bool TNGraphMP::IsOk(const bool& ThrowExcept) const {
137    bool RetVal = true;
138    for (int N = NodeH.FFirstKeyId(); NodeH.FNextKeyId(N); ) {
139      const TNode& Node = NodeH[N];
140      if (! Node.OutNIdV.IsSorted()) {
141        const TStr Msg = TStr::Fmt("Out-neighbor list of node %d is not sorted.", Node.GetId());
142        if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
143      }
144      if (! Node.InNIdV.IsSorted()) {
145        const TStr Msg = TStr::Fmt("In-neighbor list of node %d is not sorted.", Node.GetId());
146        if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
147      }
148      int prevNId = -1;
149      for (int e = 0; e < Node.GetOutDeg(); e++) {
150        if (! IsNode(Node.GetOutNId(e))) {
151          const TStr Msg = TStr::Fmt("Out-edge %d --> %d: node %d does not exist.",
152            Node.GetId(), Node.GetOutNId(e), Node.GetOutNId(e));
153          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
154        }
155        if (e > 0 && prevNId == Node.GetOutNId(e)) {
156          const TStr Msg = TStr::Fmt("Node %d has duplidate out-edge %d --> %d.",
157            Node.GetId(), Node.GetId(), Node.GetOutNId(e));
158          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
159        }
160        prevNId = Node.GetOutNId(e);
161      }
162      prevNId = -1;
163      for (int e = 0; e < Node.GetInDeg(); e++) {
164        if (! IsNode(Node.GetInNId(e))) {
165          const TStr Msg = TStr::Fmt("In-edge %d <-- %d: node %d does not exist.",
166            Node.GetId(), Node.GetInNId(e), Node.GetInNId(e));
167          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
168        }
169        if (e > 0 && prevNId == Node.GetInNId(e)) {
170          const TStr Msg = TStr::Fmt("Node %d has duplidate in-edge %d <-- %d.",
171            Node.GetId(), Node.GetId(), Node.GetInNId(e));
172          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
173        }
174        prevNId = Node.GetInNId(e);
175      }
176    }
177    return RetVal;
178  }
179  void TNGraphMP::Dump(FILE *OutF) const {
180    const int NodePlaces = (int) ceil(log10((double) GetNodes()));
181    fprintf(OutF, "-------------------------------------------------\nDirected Node Graph: nodes: %d, edges: %d\n", GetNodes(), GetEdges());
182    for (int N = NodeH.FFirstKeyId(); NodeH.FNextKeyId(N); ) {
183      const TNode& Node = NodeH[N];
184      fprintf(OutF, "  %*d]\n", NodePlaces, Node.GetId());
185      fprintf(OutF, "    in [%d]", Node.GetInDeg());
186      for (int edge = 0; edge < Node.GetInDeg(); edge++) {
187        fprintf(OutF, " %*d", NodePlaces, Node.GetInNId(edge)); }
188      fprintf(OutF, "\n    out[%d]", Node.GetOutDeg());
189      for (int edge = 0; edge < Node.GetOutDeg(); edge++) {
190        fprintf(OutF, " %*d", NodePlaces, Node.GetOutNId(edge)); }
191      fprintf(OutF, "\n");
192    }
193    fprintf(OutF, "\n");
194  }
195  PNGraphMP TNGraphMP::GetSmallGraph() {
196    PNGraphMP G = TNGraphMP::New();
197    for (int i = 0; i < 5; i++) { G->AddNode(i); }
198    G->AddEdge(0,1); G->AddEdge(1,2); G->AddEdge(0,2);
199    G->AddEdge(1,3);
200    G->AddEdge(3,4);
201    G->AddEdge(2,3);
202    return G;
203  }
204  int TNGraphMP::AddOutEdge1(int& SrcIdx, const int& SrcNId, const int& DstNId) {
205    bool Found;
206    int SrcKeyId;
207    SrcKeyId = NodeH.AddKey12(SrcIdx, SrcNId, Found);
208    if (!Found) {
209      NodeH[SrcKeyId] = TNode(SrcNId);
210    }
211    SrcIdx = SrcKeyId;
212    return Found;
213  }
214  int TNGraphMP::AddInEdge1(int& DstIdx, const int& SrcNId, const int& DstNId) {
215    bool Found;
216    int DstKeyId;
217    DstKeyId = NodeH.AddKey12(DstIdx, DstNId, Found);
218    if (!Found) {
219      NodeH[DstKeyId] = TNode(DstNId);
220    }
221    DstIdx = DstKeyId;
222    return Found;
223  }
224  void TNGraphMP::AddOutEdge2(const int& SrcNId, const int& DstNId) {
225    NodeH[NodeH.GetKeyId(SrcNId)].OutNIdV.AddMP(DstNId);
226  }
227  void TNGraphMP::AddInEdge2(const int& SrcNId, const int& DstNId) {
228    NodeH[NodeH.GetKeyId(DstNId)].InNIdV.AddMP(SrcNId);
229  }
230  void TNGraphMP::AddNodeWithEdges(const TInt& NId, TIntV& InNIdV, TIntV& OutNIdV) {
231    int NodeIdx = abs((NId.GetPrimHashCd()) % Reserved());
232    int NodeKeyId = NodeH.AddKey13(NodeIdx, NId);
233    NodeH[NodeKeyId] = TNode(NId);
234    NodeH[NodeKeyId].InNIdV.MoveFrom(InNIdV);
235    NodeH[NodeKeyId].OutNIdV.MoveFrom(OutNIdV);  
236  }
237  #endif 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-graph_2.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-graphmp.cpp</div>
                </div>
                <div class="column column_space"><pre><code>225  int TNGraph::AddNode(const int& NId, const TVecPool<TInt>& Pool, const int& SrcVId, const int& DstVId) {
226    int NewNId;
227    if (NId == -1) {
228      NewNId = MxNId;  MxNId++;
229    } else {
230      IAssertR(!IsNode(NId), TStr::Fmt("NodeId %d already exists", NId));
231      NewNId = NId;
232      MxNId = TMath::Mx(NewNId+1, MxNId());
233    }
234    TNode& Node = NodeH.AddDat(NewNId);
235    Node.Id = NewNId;
236    Node.InNIdV.GenExt(Pool.GetValVPt(SrcVId), Pool.GetVLen(SrcVId));
237    Node.OutNIdV.GenExt(Pool.GetValVPt(DstVId), Pool.GetVLen(DstVId));
238    Node.InNIdV.Sort();
239    Node.OutNIdV.Sort();
240    return NewNId;
241  }
242  void TNGraph::DelNode(const int& NId) {
243    { TNode& Node = GetNode(NId);
</pre></code></div>
                <div class="column column_space"><pre><code>38  int TNGraphMP::AddNode(const int& NId, const TVecPool<TInt>& Pool, const int& SrcVId, const int& DstVId) {
39    int NewNId;
40    if (NId == -1) {
41      NewNId = MxNId;  MxNId++;
42    } else {
43      IAssertR(!IsNode(NId), TStr::Fmt("NodeId %d already exists", NId));
44      NewNId = NId;
45      MxNId = TMath::Mx(NewNId+1, MxNId());
46    }
47    TNode& Node = NodeH.AddDat(NewNId);
48    Node.Id = NewNId;
49    Node.InNIdV.GenExt(Pool.GetValVPt(SrcVId), Pool.GetVLen(SrcVId));
50    Node.OutNIdV.GenExt(Pool.GetValVPt(DstVId), Pool.GetVLen(DstVId));
51    Node.InNIdV.Sort();
52    Node.OutNIdV.Sort();
53    return NewNId;
54  }
55  void TNGraphMP::DelNode(const int& NId) {
56  #if 0
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    