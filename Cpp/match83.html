<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for iniz.c &amp; types.h</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for iniz.c &amp; types.h
      </h3>
<h1 align="center">
        10.0%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>iniz.c (25.882353%)<th>types.h (6.2146893%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(25-47)<td><a href="#" name="0">(177-196)</a><td align="center"><font color="#ff0000">22</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>iniz.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "iniz.h"
2 void            iniz(piece * w, piece * b)
3 <a name="0"></a>{                                   int             i;
4 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    rule50 = 0;
5     depthmax = STARTDPTH;
6     w[0].type = 'r';
7     w[0].value = ROOK_VAL;
8     w[0].bm_pos = 1;
9     w[1].type = 'n';
10     w[1].value = KNIGHT_VAL;
11     w[1].bm_pos = 1 &lt;&lt; 1;
12     w[2].type = 'b';
13     w[2].value = BISHOP_VAL;
14     w[2].bm_pos = 1 &lt;&lt; 2;
15     w[3].type = 'q';
16     w[3].value = QUEEN_VAL;
17     w[3].bm_pos = 1 &lt;&lt; 3;
18     w[4].type = 'k';
19     w[4].value = 2 * ROOK_VAL + 2 * KNIGHT_VAL + 2 * BISHOP_VAL + QUEEN_VAL + 8 * PAWN_VAL;
20     w[4].bm_pos = 1 &lt;&lt; 4;
21     w[5].type = 'b';
22     w[5].value = BISHOP_VAL;
23     w[5].bm_pos = 1 &lt;&lt; 5;
24     w[6].type = 'n';
25     w[6].value = KNIGHT_VAL;</b></font>
26     w[6].bm_pos = 1 &lt;&lt; 6;
27     w[7].type = 'r';
28     w[7].value = ROOK_VAL;
29     w[7].bm_pos = 1 &lt;&lt; 7;
30     for (i = 8; i &lt;= 15; i++) {
31         w[i].type = 'p';
32         w[i].value = PAWN_VAL;
33         w[i].bm_pos = 1 &lt;&lt; i;
34     }
35     b[0].type = 'r';
36     b[0].value = ROOK_VAL;
37     b[0].bm_pos = pow(2, 56);
38     b[1].type = 'n';
39     b[1].value = KNIGHT_VAL;
40     b[1].bm_pos = pow(2, 57);
41     b[2].type = 'b';
42     b[2].value = BISHOP_VAL;
43     b[2].bm_pos = pow(2, 58);
44     b[3].type = 'q';
45     b[3].value = QUEEN_VAL;
46     b[3].bm_pos = pow(2, 59);
47     b[4].type = 'k';
48     b[4].value = 2 * ROOK_VAL + 2 * KNIGHT_VAL + 2 * BISHOP_VAL + QUEEN_VAL + 8 * PAWN_VAL;
49     b[4].bm_pos = pow(2, 60);
50     b[5].type = 'b';
51     b[5].value = BISHOP_VAL;
52     b[5].bm_pos = pow(2, 61);
53     b[6].type = 'n';
54     b[6].value = KNIGHT_VAL;
55     b[6].bm_pos = pow(2, 62);
56     b[7].type = 'r';
57     b[7].value = ROOK_VAL;
58     b[7].bm_pos = pow(2, 63);
59     for (i = 8; i &lt;= 15; i++) {
60         b[i].type = 'p';
61         b[i].value = PAWN_VAL;
62         b[i].bm_pos = pow(2, 40 + i);
63     }
64     for (i = 0; i &lt;= 15; i++) {
65         w[i].color = 'W';
66         w[i].bm_legmov = 0;
67         w[i].last_double_move = 0;
68         w[i].deja_moved = 0;
69         w[i].under_check = 0;
70         b[i].color = 'B';
71         b[i].bm_legmov = 0;
72         b[i].last_double_move = 0;
73         b[i].deja_moved = 0;
74         b[i].under_check = 0;
75     }
76 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>types.h</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifndef TYPES_H_INCLUDED
2 #define TYPES_H_INCLUDED
3 #include &lt;cassert&gt;
4 #include &lt;cctype&gt;
5 #include &lt;climits&gt;
6 #include &lt;cstdlib&gt;
7 #include "platform.h"
8 #define unlikely(x) (x) 
9 #if defined(_WIN64) &amp;&amp; !defined(IS_64BIT)
10 #  include &lt;intrin.h&gt; #  define IS_64BIT
11 #  define USE_BSFQ
12 #endif
13 #if defined(USE_POPCNT) &amp;&amp; defined(_MSC_VER) &amp;&amp; defined(__INTEL_COMPILER)
14 #  include &lt;nmmintrin.h&gt; #endif
15 #if defined(USE_PEXT)
16 #  include &lt;immintrin.h&gt; #else
17 #  define _pext_u64(b, m) (0)
18 #endif
19 #  if !defined(NO_PREFETCH) &amp;&amp; (defined(__INTEL_COMPILER) || defined(_MSC_VER))
20 #   include &lt;xmmintrin.h&gt; #  endif
21 #define CACHE_LINE_SIZE 64
22 #if defined(_MSC_VER) || defined(__INTEL_COMPILER)
23 #  define CACHE_LINE_ALIGNMENT __declspec(align(CACHE_LINE_SIZE))
24 #else
25 #  define CACHE_LINE_ALIGNMENT  __attribute__ ((aligned(CACHE_LINE_SIZE)))
26 #endif
27 #ifdef _MSC_VER
28 #  define FORCE_INLINE  __forceinline
29 #elif defined(__GNUC__)
30 #  define FORCE_INLINE  inline __attribute__((always_inline))
31 #else
32 #  define FORCE_INLINE  inline
33 #endif
34 #ifdef USE_POPCNT
35 const bool HasPopCnt = true;
36 #else
37 const bool HasPopCnt = false;
38 #endif
39 #ifdef USE_PEXT
40 const bool HasPext = true;
41 #else
42 const bool HasPext = false;
43 #endif
44 #ifdef IS_64BIT
45 const bool Is64Bit = true;
46 #else
47 const bool Is64Bit = false;
48 #endif
49 typedef uint64_t Key;
50 typedef uint64_t Bitboard;
51 const int MAX_MOVES      = 256;
52 const int MAX_PLY        = 120;
53 const int MAX_PLY_PLUS_6 = MAX_PLY + 6;
54 enum Move {
55   MOVE_NONE,
56   MOVE_NULL = 65
57 };
58 enum MoveType {
59   NORMAL,
60   PROMOTION = 1 &lt;&lt; 14,
61   ENPASSANT = 2 &lt;&lt; 14,
62   CASTLING  = 3 &lt;&lt; 14
63 };
64 enum Color {
65   WHITE, BLACK, NO_COLOR, COLOR_NB = 2
66 };
67 enum CastlingSide {
68   KING_SIDE, QUEEN_SIDE, CASTLING_SIDE_NB = 2
69 };
70 enum CastlingRight {    NO_CASTLING,
71   WHITE_OO,
72   WHITE_OOO   = WHITE_OO &lt;&lt; 1,
73   BLACK_OO    = WHITE_OO &lt;&lt; 2,
74   BLACK_OOO   = WHITE_OO &lt;&lt; 3,
75   ANY_CASTLING = WHITE_OO | WHITE_OOO | BLACK_OO | BLACK_OOO,
76   CASTLING_RIGHT_NB = 16
77 };
78 template&lt;Color C, CastlingSide S&gt; struct MakeCastling {
79   static const CastlingRight
80   right = C == WHITE ? S == QUEEN_SIDE ? WHITE_OOO : WHITE_OO
81                      : S == QUEEN_SIDE ? BLACK_OOO : BLACK_OO;
82 };
83 enum Phase {
84   PHASE_ENDGAME,
85   PHASE_MIDGAME = 128,
86   MG = 0, EG = 1, PHASE_NB = 2
87 };
88 enum ScaleFactor {
89   SCALE_FACTOR_DRAW    = 0,
90   SCALE_FACTOR_ONEPAWN = 48,
91   SCALE_FACTOR_NORMAL  = 64,
92   SCALE_FACTOR_MAX     = 128,
93   SCALE_FACTOR_NONE    = 255
94 };
95 enum Bound {
96   BOUND_NONE,
97   BOUND_UPPER,
98   BOUND_LOWER,
99   BOUND_EXACT = BOUND_UPPER | BOUND_LOWER
100 <a name="0"></a>};
101 enum Value {
102 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  VALUE_ZERO      = 0,
103   VALUE_DRAW      = 0,
104   VALUE_KNOWN_WIN = 10000,
105   VALUE_MATE      = 32000,
106   VALUE_INFINITE  = 32001,
107   VALUE_NONE      = 32002,
108   VALUE_MATE_IN_MAX_PLY  =  VALUE_MATE - MAX_PLY,
109   VALUE_MATED_IN_MAX_PLY = -VALUE_MATE + MAX_PLY,
110   VALUE_ENSURE_INTEGER_SIZE_P = INT_MAX,
111   VALUE_ENSURE_INTEGER_SIZE_N = INT_MIN,
112   PawnValueMg   = 198,   PawnValueEg   = 258,
113   KnightValueMg = 817,   KnightValueEg = 846,
114   BishopValueMg = 836,   BishopValueEg = 857,
115   RookValueMg   = 1270,  RookValueEg   = 1278,
116   QueenValueMg  = 2521,  QueenValueEg  = 2558,
117   MidgameLimit  = 15581, EndgameLimit  = 3998</b></font>
118 };
119 enum PieceType {
120   NO_PIECE_TYPE, PAWN, KNIGHT, BISHOP, ROOK, QUEEN, KING,
121   ALL_PIECES = 0,
122   PIECE_TYPE_NB = 8
123 };
124 enum Piece {
125   NO_PIECE,
126   W_PAWN = 1, W_KNIGHT, W_BISHOP, W_ROOK, W_QUEEN, W_KING,
127   B_PAWN = 9, B_KNIGHT, B_BISHOP, B_ROOK, B_QUEEN, B_KING,
128   PIECE_NB = 16
129 };
130 enum Depth {
131   ONE_PLY = 2,
132   DEPTH_ZERO          =  0 * ONE_PLY,
133   DEPTH_QS_CHECKS     =  0 * ONE_PLY,
134   DEPTH_QS_NO_CHECKS  = -1 * ONE_PLY,
135   DEPTH_QS_RECAPTURES = -5 * ONE_PLY,
136   DEPTH_NONE = -127 * ONE_PLY
137 };
138 enum Square {
139   SQ_A1, SQ_B1, SQ_C1, SQ_D1, SQ_E1, SQ_F1, SQ_G1, SQ_H1,
140   SQ_A2, SQ_B2, SQ_C2, SQ_D2, SQ_E2, SQ_F2, SQ_G2, SQ_H2,
141   SQ_A3, SQ_B3, SQ_C3, SQ_D3, SQ_E3, SQ_F3, SQ_G3, SQ_H3,
142   SQ_A4, SQ_B4, SQ_C4, SQ_D4, SQ_E4, SQ_F4, SQ_G4, SQ_H4,
143   SQ_A5, SQ_B5, SQ_C5, SQ_D5, SQ_E5, SQ_F5, SQ_G5, SQ_H5,
144   SQ_A6, SQ_B6, SQ_C6, SQ_D6, SQ_E6, SQ_F6, SQ_G6, SQ_H6,
145   SQ_A7, SQ_B7, SQ_C7, SQ_D7, SQ_E7, SQ_F7, SQ_G7, SQ_H7,
146   SQ_A8, SQ_B8, SQ_C8, SQ_D8, SQ_E8, SQ_F8, SQ_G8, SQ_H8,
147   SQ_NONE,
148   SQUARE_NB = 64,
149   DELTA_N =  8,
150   DELTA_E =  1,
151   DELTA_S = -8,
152   DELTA_W = -1,
153   DELTA_NN = DELTA_N + DELTA_N,
154   DELTA_NE = DELTA_N + DELTA_E,
155   DELTA_SE = DELTA_S + DELTA_E,
156   DELTA_SS = DELTA_S + DELTA_S,
157   DELTA_SW = DELTA_S + DELTA_W,
158   DELTA_NW = DELTA_N + DELTA_W
159 };
160 enum File {
161   FILE_A, FILE_B, FILE_C, FILE_D, FILE_E, FILE_F, FILE_G, FILE_H, FILE_NB
162 };
163 enum Rank {
164   RANK_1, RANK_2, RANK_3, RANK_4, RANK_5, RANK_6, RANK_7, RANK_8, RANK_NB
165 };
166 enum Score {
167   SCORE_ZERO,
168   SCORE_ENSURE_INTEGER_SIZE_P = INT_MAX,
169   SCORE_ENSURE_INTEGER_SIZE_N = INT_MIN
170 };
171 typedef union {
172   uint32_t full;
173   struct { int16_t eg, mg; } half;
174 } ScoreView;
175 inline Score make_score(int mg, int eg) {
176   ScoreView v;
177   v.half.mg = (int16_t)(mg - (uint16_t(eg) &gt;&gt; 15));
178   v.half.eg = (int16_t)eg;
179   return Score(v.full);
180 }
181 inline Value mg_value(Score s) {
182   ScoreView v;
183   v.full = s;
184   return Value(v.half.mg + (uint16_t(v.half.eg) &gt;&gt; 15));
185 }
186 inline Value eg_value(Score s) {
187   ScoreView v;
188   v.full = s;
189   return Value(v.half.eg);
190 }
191 #define ENABLE_BASE_OPERATORS_ON(T)                                         \
192 inline T operator+(const T d1, const T d2) { return T(int(d1) + int(d2)); } \
193 inline T operator-(const T d1, const T d2) { return T(int(d1) - int(d2)); } \
194 inline T operator*(int i, const T d) { return T(i * int(d)); }              \
195 inline T operator*(const T d, int i) { return T(int(d) * i); }              \
196 inline T operator-(const T d) { return T(-int(d)); }                        \
197 inline T&amp; operator+=(T&amp; d1, const T d2) { return d1 = d1 + d2; }            \
198 inline T&amp; operator-=(T&amp; d1, const T d2) { return d1 = d1 - d2; }            \
199 inline T&amp; operator*=(T&amp; d, int i) { return d = T(int(d) * i); }
200 ENABLE_BASE_OPERATORS_ON(Score)
201 #define ENABLE_FULL_OPERATORS_ON(T)                                         \
202 ENABLE_BASE_OPERATORS_ON(T)                                                 \
203 inline T&amp; operator++(T&amp; d) { return d = T(int(d) + 1); }                    \
204 inline T&amp; operator--(T&amp; d) { return d = T(int(d) - 1); }                    \
205 inline T operator/(const T d, int i) { return T(int(d) / i); }              \
206 inline T&amp; operator/=(T&amp; d, int i) { return d = T(int(d) / i); }
207 ENABLE_FULL_OPERATORS_ON(Value)
208 ENABLE_FULL_OPERATORS_ON(PieceType)
209 ENABLE_FULL_OPERATORS_ON(Piece)
210 ENABLE_FULL_OPERATORS_ON(Color)
211 ENABLE_FULL_OPERATORS_ON(Depth)
212 ENABLE_FULL_OPERATORS_ON(Square)
213 ENABLE_FULL_OPERATORS_ON(File)
214 ENABLE_FULL_OPERATORS_ON(Rank)
215 #undef ENABLE_FULL_OPERATORS_ON
216 #undef ENABLE_BASE_OPERATORS_ON
217 inline Value operator+(Value v, int i) { return Value(int(v) + i); }
218 inline Value operator-(Value v, int i) { return Value(int(v) - i); }
219 inline Value&amp; operator+=(Value&amp; v, int i) { return v = v + i; }
220 inline Value&amp; operator-=(Value&amp; v, int i) { return v = v - i; }
221 inline Score operator*(Score s1, Score s2);
222 inline Score operator/(Score s, int i) {
223   return make_score(mg_value(s) / i, eg_value(s) / i);
224 }
225 extern Value PieceValue[PHASE_NB][PIECE_NB];
226 struct ExtMove {
227   Move move;
228   Value value;
229 };
230 inline bool operator&lt;(const ExtMove&amp; f, const ExtMove&amp; s) {
231   return f.value &lt; s.value;
232 }
233 inline Color operator~(Color c) {
234   return Color(c ^ BLACK);
235 }
236 inline Square operator~(Square s) {
237   return Square(s ^ SQ_A8); }
238 inline CastlingRight operator|(Color c, CastlingSide s) {
239   return CastlingRight(WHITE_OO &lt;&lt; ((s == QUEEN_SIDE) + 2 * c));
240 }
241 inline Value mate_in(int ply) {
242   return VALUE_MATE - ply;
243 }
244 inline Value mated_in(int ply) {
245   return -VALUE_MATE + ply;
246 }
247 inline Square make_square(File f, Rank r) {
248   return Square((r &lt;&lt; 3) | f);
249 }
250 inline Piece make_piece(Color c, PieceType pt) {
251   return Piece((c &lt;&lt; 3) | pt);
252 }
253 inline PieceType type_of(Piece pc)  {
254   return PieceType(pc &amp; 7);
255 }
256 inline Color color_of(Piece pc) {
257   assert(pc != NO_PIECE);
258   return Color(pc &gt;&gt; 3);
259 }
260 inline bool is_ok(Square s) {
261   return s &gt;= SQ_A1 &amp;&amp; s &lt;= SQ_H8;
262 }
263 inline File file_of(Square s) {
264   return File(s &amp; 7);
265 }
266 inline Rank rank_of(Square s) {
267   return Rank(s &gt;&gt; 3);
268 }
269 inline Square relative_square(Color c, Square s) {
270   return Square(s ^ (c * 56));
271 }
272 inline Rank relative_rank(Color c, Rank r) {
273   return Rank(r ^ (c * 7));
274 }
275 inline Rank relative_rank(Color c, Square s) {
276   return relative_rank(c, rank_of(s));
277 }
278 inline bool opposite_colors(Square s1, Square s2) {
279   int s = int(s1) ^ int(s2);
280   return ((s &gt;&gt; 3) ^ s) &amp; 1;
281 }
282 inline char to_char(File f, bool tolower = true) {
283   return char(f - FILE_A + (tolower ? 'a' : 'A'));
284 }
285 inline char to_char(Rank r) {
286   return char(r - RANK_1 + '1');
287 }
288 inline Square pawn_push(Color c) {
289   return c == WHITE ? DELTA_N : DELTA_S;
290 }
291 inline Square from_sq(Move m) {
292   return Square((m &gt;&gt; 6) &amp; 0x3F);
293 }
294 inline Square to_sq(Move m) {
295   return Square(m &amp; 0x3F);
296 }
297 inline MoveType type_of(Move m) {
298   return MoveType(m &amp; (3 &lt;&lt; 14));
299 }
300 inline PieceType promotion_type(Move m) {
301   return PieceType(((m &gt;&gt; 12) &amp; 3) + 2);
302 }
303 inline Move make_move(Square from, Square to) {
304   return Move(to | (from &lt;&lt; 6));
305 }
306 template&lt;MoveType T&gt;
307 inline Move make(Square from, Square to, PieceType pt = KNIGHT) {
308   return Move(to | (from &lt;&lt; 6) | T | ((pt - KNIGHT) &lt;&lt; 12));
309 }
310 inline bool is_ok(Move m) {
311   return from_sq(m) != to_sq(m); }
312 #include &lt;string&gt;
313 inline const std::string to_string(Square s) {
314   char ch[] = { to_char(file_of(s)), to_char(rank_of(s)), 0 };
315   return ch;
316 }
#endif </pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
