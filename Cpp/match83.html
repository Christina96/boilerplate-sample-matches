<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for iniz.c &amp; types.h</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for iniz.c &amp; types.h
      </h3>
<h1 align="center">
        10.0%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>iniz.c (25.882353%)<th>types.h (6.2146893%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(25-47)<td><a href="#" name="0">(177-196)</a><td align="center"><font color="#ff0000">22</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>iniz.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include "iniz.h"
void            iniz(piece * w, piece * b)
<a name="0"></a>{                                   int             i;
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    rule50 = 0;
    depthmax = STARTDPTH;
    w[0].type = 'r';
    w[0].value = ROOK_VAL;
    w[0].bm_pos = 1;
    w[1].type = 'n';
    w[1].value = KNIGHT_VAL;
    w[1].bm_pos = 1 &lt;&lt; 1;
    w[2].type = 'b';
    w[2].value = BISHOP_VAL;
    w[2].bm_pos = 1 &lt;&lt; 2;
    w[3].type = 'q';
    w[3].value = QUEEN_VAL;
    w[3].bm_pos = 1 &lt;&lt; 3;
    w[4].type = 'k';
    w[4].value = 2 * ROOK_VAL + 2 * KNIGHT_VAL + 2 * BISHOP_VAL + QUEEN_VAL + 8 * PAWN_VAL;
    w[4].bm_pos = 1 &lt;&lt; 4;
    w[5].type = 'b';
    w[5].value = BISHOP_VAL;
    w[5].bm_pos = 1 &lt;&lt; 5;
    w[6].type = 'n';
    w[6].value = KNIGHT_VAL;</b></font>
    w[6].bm_pos = 1 &lt;&lt; 6;
    w[7].type = 'r';
    w[7].value = ROOK_VAL;
    w[7].bm_pos = 1 &lt;&lt; 7;
    for (i = 8; i &lt;= 15; i++) {
        w[i].type = 'p';
        w[i].value = PAWN_VAL;
        w[i].bm_pos = 1 &lt;&lt; i;
    }
    b[0].type = 'r';
    b[0].value = ROOK_VAL;
    b[0].bm_pos = pow(2, 56);
    b[1].type = 'n';
    b[1].value = KNIGHT_VAL;
    b[1].bm_pos = pow(2, 57);
    b[2].type = 'b';
    b[2].value = BISHOP_VAL;
    b[2].bm_pos = pow(2, 58);
    b[3].type = 'q';
    b[3].value = QUEEN_VAL;
    b[3].bm_pos = pow(2, 59);
    b[4].type = 'k';
    b[4].value = 2 * ROOK_VAL + 2 * KNIGHT_VAL + 2 * BISHOP_VAL + QUEEN_VAL + 8 * PAWN_VAL;
    b[4].bm_pos = pow(2, 60);
    b[5].type = 'b';
    b[5].value = BISHOP_VAL;
    b[5].bm_pos = pow(2, 61);
    b[6].type = 'n';
    b[6].value = KNIGHT_VAL;
    b[6].bm_pos = pow(2, 62);
    b[7].type = 'r';
    b[7].value = ROOK_VAL;
    b[7].bm_pos = pow(2, 63);
    for (i = 8; i &lt;= 15; i++) {
        b[i].type = 'p';
        b[i].value = PAWN_VAL;
        b[i].bm_pos = pow(2, 40 + i);
    }
    for (i = 0; i &lt;= 15; i++) {
        w[i].color = 'W';
        w[i].bm_legmov = 0;
        w[i].last_double_move = 0;
        w[i].deja_moved = 0;
        w[i].under_check = 0;
        b[i].color = 'B';
        b[i].bm_legmov = 0;
        b[i].last_double_move = 0;
        b[i].deja_moved = 0;
        b[i].under_check = 0;
    }
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>types.h</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#ifndef TYPES_H_INCLUDED
#define TYPES_H_INCLUDED
#include &lt;cassert&gt;
#include &lt;cctype&gt;
#include &lt;climits&gt;
#include &lt;cstdlib&gt;
#include "platform.h"
#define unlikely(x) (x) 
#if defined(_WIN64) &amp;&amp; !defined(IS_64BIT)
#  include &lt;intrin.h&gt; #  define IS_64BIT
#  define USE_BSFQ
#endif
#if defined(USE_POPCNT) &amp;&amp; defined(_MSC_VER) &amp;&amp; defined(__INTEL_COMPILER)
#  include &lt;nmmintrin.h&gt; #endif
#if defined(USE_PEXT)
#  include &lt;immintrin.h&gt; #else
#  define _pext_u64(b, m) (0)
#endif
#  if !defined(NO_PREFETCH) &amp;&amp; (defined(__INTEL_COMPILER) || defined(_MSC_VER))
#   include &lt;xmmintrin.h&gt; #  endif
#define CACHE_LINE_SIZE 64
#if defined(_MSC_VER) || defined(__INTEL_COMPILER)
#  define CACHE_LINE_ALIGNMENT __declspec(align(CACHE_LINE_SIZE))
#else
#  define CACHE_LINE_ALIGNMENT  __attribute__ ((aligned(CACHE_LINE_SIZE)))
#endif
#ifdef _MSC_VER
#  define FORCE_INLINE  __forceinline
#elif defined(__GNUC__)
#  define FORCE_INLINE  inline __attribute__((always_inline))
#else
#  define FORCE_INLINE  inline
#endif
#ifdef USE_POPCNT
const bool HasPopCnt = true;
#else
const bool HasPopCnt = false;
#endif
#ifdef USE_PEXT
const bool HasPext = true;
#else
const bool HasPext = false;
#endif
#ifdef IS_64BIT
const bool Is64Bit = true;
#else
const bool Is64Bit = false;
#endif
typedef uint64_t Key;
typedef uint64_t Bitboard;
const int MAX_MOVES      = 256;
const int MAX_PLY        = 120;
const int MAX_PLY_PLUS_6 = MAX_PLY + 6;
enum Move {
  MOVE_NONE,
  MOVE_NULL = 65
};
enum MoveType {
  NORMAL,
  PROMOTION = 1 &lt;&lt; 14,
  ENPASSANT = 2 &lt;&lt; 14,
  CASTLING  = 3 &lt;&lt; 14
};
enum Color {
  WHITE, BLACK, NO_COLOR, COLOR_NB = 2
};
enum CastlingSide {
  KING_SIDE, QUEEN_SIDE, CASTLING_SIDE_NB = 2
};
enum CastlingRight {    NO_CASTLING,
  WHITE_OO,
  WHITE_OOO   = WHITE_OO &lt;&lt; 1,
  BLACK_OO    = WHITE_OO &lt;&lt; 2,
  BLACK_OOO   = WHITE_OO &lt;&lt; 3,
  ANY_CASTLING = WHITE_OO | WHITE_OOO | BLACK_OO | BLACK_OOO,
  CASTLING_RIGHT_NB = 16
};
template&lt;Color C, CastlingSide S&gt; struct MakeCastling {
  static const CastlingRight
  right = C == WHITE ? S == QUEEN_SIDE ? WHITE_OOO : WHITE_OO
                     : S == QUEEN_SIDE ? BLACK_OOO : BLACK_OO;
};
enum Phase {
  PHASE_ENDGAME,
  PHASE_MIDGAME = 128,
  MG = 0, EG = 1, PHASE_NB = 2
};
enum ScaleFactor {
  SCALE_FACTOR_DRAW    = 0,
  SCALE_FACTOR_ONEPAWN = 48,
  SCALE_FACTOR_NORMAL  = 64,
  SCALE_FACTOR_MAX     = 128,
  SCALE_FACTOR_NONE    = 255
};
enum Bound {
  BOUND_NONE,
  BOUND_UPPER,
  BOUND_LOWER,
  BOUND_EXACT = BOUND_UPPER | BOUND_LOWER
<a name="0"></a>};
enum Value {
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  VALUE_ZERO      = 0,
  VALUE_DRAW      = 0,
  VALUE_KNOWN_WIN = 10000,
  VALUE_MATE      = 32000,
  VALUE_INFINITE  = 32001,
  VALUE_NONE      = 32002,
  VALUE_MATE_IN_MAX_PLY  =  VALUE_MATE - MAX_PLY,
  VALUE_MATED_IN_MAX_PLY = -VALUE_MATE + MAX_PLY,
  VALUE_ENSURE_INTEGER_SIZE_P = INT_MAX,
  VALUE_ENSURE_INTEGER_SIZE_N = INT_MIN,
  PawnValueMg   = 198,   PawnValueEg   = 258,
  KnightValueMg = 817,   KnightValueEg = 846,
  BishopValueMg = 836,   BishopValueEg = 857,
  RookValueMg   = 1270,  RookValueEg   = 1278,
  QueenValueMg  = 2521,  QueenValueEg  = 2558,
  MidgameLimit  = 15581, EndgameLimit  = 3998</b></font>
};
enum PieceType {
  NO_PIECE_TYPE, PAWN, KNIGHT, BISHOP, ROOK, QUEEN, KING,
  ALL_PIECES = 0,
  PIECE_TYPE_NB = 8
};
enum Piece {
  NO_PIECE,
  W_PAWN = 1, W_KNIGHT, W_BISHOP, W_ROOK, W_QUEEN, W_KING,
  B_PAWN = 9, B_KNIGHT, B_BISHOP, B_ROOK, B_QUEEN, B_KING,
  PIECE_NB = 16
};
enum Depth {
  ONE_PLY = 2,
  DEPTH_ZERO          =  0 * ONE_PLY,
  DEPTH_QS_CHECKS     =  0 * ONE_PLY,
  DEPTH_QS_NO_CHECKS  = -1 * ONE_PLY,
  DEPTH_QS_RECAPTURES = -5 * ONE_PLY,
  DEPTH_NONE = -127 * ONE_PLY
};
enum Square {
  SQ_A1, SQ_B1, SQ_C1, SQ_D1, SQ_E1, SQ_F1, SQ_G1, SQ_H1,
  SQ_A2, SQ_B2, SQ_C2, SQ_D2, SQ_E2, SQ_F2, SQ_G2, SQ_H2,
  SQ_A3, SQ_B3, SQ_C3, SQ_D3, SQ_E3, SQ_F3, SQ_G3, SQ_H3,
  SQ_A4, SQ_B4, SQ_C4, SQ_D4, SQ_E4, SQ_F4, SQ_G4, SQ_H4,
  SQ_A5, SQ_B5, SQ_C5, SQ_D5, SQ_E5, SQ_F5, SQ_G5, SQ_H5,
  SQ_A6, SQ_B6, SQ_C6, SQ_D6, SQ_E6, SQ_F6, SQ_G6, SQ_H6,
  SQ_A7, SQ_B7, SQ_C7, SQ_D7, SQ_E7, SQ_F7, SQ_G7, SQ_H7,
  SQ_A8, SQ_B8, SQ_C8, SQ_D8, SQ_E8, SQ_F8, SQ_G8, SQ_H8,
  SQ_NONE,
  SQUARE_NB = 64,
  DELTA_N =  8,
  DELTA_E =  1,
  DELTA_S = -8,
  DELTA_W = -1,
  DELTA_NN = DELTA_N + DELTA_N,
  DELTA_NE = DELTA_N + DELTA_E,
  DELTA_SE = DELTA_S + DELTA_E,
  DELTA_SS = DELTA_S + DELTA_S,
  DELTA_SW = DELTA_S + DELTA_W,
  DELTA_NW = DELTA_N + DELTA_W
};
enum File {
  FILE_A, FILE_B, FILE_C, FILE_D, FILE_E, FILE_F, FILE_G, FILE_H, FILE_NB
};
enum Rank {
  RANK_1, RANK_2, RANK_3, RANK_4, RANK_5, RANK_6, RANK_7, RANK_8, RANK_NB
};
enum Score {
  SCORE_ZERO,
  SCORE_ENSURE_INTEGER_SIZE_P = INT_MAX,
  SCORE_ENSURE_INTEGER_SIZE_N = INT_MIN
};
typedef union {
  uint32_t full;
  struct { int16_t eg, mg; } half;
} ScoreView;
inline Score make_score(int mg, int eg) {
  ScoreView v;
  v.half.mg = (int16_t)(mg - (uint16_t(eg) &gt;&gt; 15));
  v.half.eg = (int16_t)eg;
  return Score(v.full);
}
inline Value mg_value(Score s) {
  ScoreView v;
  v.full = s;
  return Value(v.half.mg + (uint16_t(v.half.eg) &gt;&gt; 15));
}
inline Value eg_value(Score s) {
  ScoreView v;
  v.full = s;
  return Value(v.half.eg);
}
#define ENABLE_BASE_OPERATORS_ON(T)                                         \
inline T operator+(const T d1, const T d2) { return T(int(d1) + int(d2)); } \
inline T operator-(const T d1, const T d2) { return T(int(d1) - int(d2)); } \
inline T operator*(int i, const T d) { return T(i * int(d)); }              \
inline T operator*(const T d, int i) { return T(int(d) * i); }              \
inline T operator-(const T d) { return T(-int(d)); }                        \
inline T&amp; operator+=(T&amp; d1, const T d2) { return d1 = d1 + d2; }            \
inline T&amp; operator-=(T&amp; d1, const T d2) { return d1 = d1 - d2; }            \
inline T&amp; operator*=(T&amp; d, int i) { return d = T(int(d) * i); }
ENABLE_BASE_OPERATORS_ON(Score)
#define ENABLE_FULL_OPERATORS_ON(T)                                         \
ENABLE_BASE_OPERATORS_ON(T)                                                 \
inline T&amp; operator++(T&amp; d) { return d = T(int(d) + 1); }                    \
inline T&amp; operator--(T&amp; d) { return d = T(int(d) - 1); }                    \
inline T operator/(const T d, int i) { return T(int(d) / i); }              \
inline T&amp; operator/=(T&amp; d, int i) { return d = T(int(d) / i); }
ENABLE_FULL_OPERATORS_ON(Value)
ENABLE_FULL_OPERATORS_ON(PieceType)
ENABLE_FULL_OPERATORS_ON(Piece)
ENABLE_FULL_OPERATORS_ON(Color)
ENABLE_FULL_OPERATORS_ON(Depth)
ENABLE_FULL_OPERATORS_ON(Square)
ENABLE_FULL_OPERATORS_ON(File)
ENABLE_FULL_OPERATORS_ON(Rank)
#undef ENABLE_FULL_OPERATORS_ON
#undef ENABLE_BASE_OPERATORS_ON
inline Value operator+(Value v, int i) { return Value(int(v) + i); }
inline Value operator-(Value v, int i) { return Value(int(v) - i); }
inline Value&amp; operator+=(Value&amp; v, int i) { return v = v + i; }
inline Value&amp; operator-=(Value&amp; v, int i) { return v = v - i; }
inline Score operator*(Score s1, Score s2);
inline Score operator/(Score s, int i) {
  return make_score(mg_value(s) / i, eg_value(s) / i);
}
extern Value PieceValue[PHASE_NB][PIECE_NB];
struct ExtMove {
  Move move;
  Value value;
};
inline bool operator&lt;(const ExtMove&amp; f, const ExtMove&amp; s) {
  return f.value &lt; s.value;
}
inline Color operator~(Color c) {
  return Color(c ^ BLACK);
}
inline Square operator~(Square s) {
  return Square(s ^ SQ_A8); }
inline CastlingRight operator|(Color c, CastlingSide s) {
  return CastlingRight(WHITE_OO &lt;&lt; ((s == QUEEN_SIDE) + 2 * c));
}
inline Value mate_in(int ply) {
  return VALUE_MATE - ply;
}
inline Value mated_in(int ply) {
  return -VALUE_MATE + ply;
}
inline Square make_square(File f, Rank r) {
  return Square((r &lt;&lt; 3) | f);
}
inline Piece make_piece(Color c, PieceType pt) {
  return Piece((c &lt;&lt; 3) | pt);
}
inline PieceType type_of(Piece pc)  {
  return PieceType(pc &amp; 7);
}
inline Color color_of(Piece pc) {
  assert(pc != NO_PIECE);
  return Color(pc &gt;&gt; 3);
}
inline bool is_ok(Square s) {
  return s &gt;= SQ_A1 &amp;&amp; s &lt;= SQ_H8;
}
inline File file_of(Square s) {
  return File(s &amp; 7);
}
inline Rank rank_of(Square s) {
  return Rank(s &gt;&gt; 3);
}
inline Square relative_square(Color c, Square s) {
  return Square(s ^ (c * 56));
}
inline Rank relative_rank(Color c, Rank r) {
  return Rank(r ^ (c * 7));
}
inline Rank relative_rank(Color c, Square s) {
  return relative_rank(c, rank_of(s));
}
inline bool opposite_colors(Square s1, Square s2) {
  int s = int(s1) ^ int(s2);
  return ((s &gt;&gt; 3) ^ s) &amp; 1;
}
inline char to_char(File f, bool tolower = true) {
  return char(f - FILE_A + (tolower ? 'a' : 'A'));
}
inline char to_char(Rank r) {
  return char(r - RANK_1 + '1');
}
inline Square pawn_push(Color c) {
  return c == WHITE ? DELTA_N : DELTA_S;
}
inline Square from_sq(Move m) {
  return Square((m &gt;&gt; 6) &amp; 0x3F);
}
inline Square to_sq(Move m) {
  return Square(m &amp; 0x3F);
}
inline MoveType type_of(Move m) {
  return MoveType(m &amp; (3 &lt;&lt; 14));
}
inline PieceType promotion_type(Move m) {
  return PieceType(((m &gt;&gt; 12) &amp; 3) + 2);
}
inline Move make_move(Square from, Square to) {
  return Move(to | (from &lt;&lt; 6));
}
template&lt;MoveType T&gt;
inline Move make(Square from, Square to, PieceType pt = KNIGHT) {
  return Move(to | (from &lt;&lt; 6) | T | ((pt - KNIGHT) &lt;&lt; 12));
}
inline bool is_ok(Move m) {
  return from_sq(m) != to_sq(m); }
#include &lt;string&gt;
inline const std::string to_string(Square s) {
  char ch[] = { to_char(file_of(s)), to_char(rank_of(s)), 0 };
  return ch;
}
#endif </pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
