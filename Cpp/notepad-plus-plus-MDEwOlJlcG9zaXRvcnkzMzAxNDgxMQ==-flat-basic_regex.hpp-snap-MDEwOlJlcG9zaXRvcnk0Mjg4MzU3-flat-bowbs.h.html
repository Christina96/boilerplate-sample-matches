
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 5.910852713178294%, Tokens: 9</h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-basic_regex.hpp</h3>
            <pre><code>1  #ifndef BOOST_REGEX_V5_BASIC_REGEX_HPP
2  #define BOOST_REGEX_V5_BASIC_REGEX_HPP
3  #include <vector>
4  namespace boost{
5  #ifdef BOOST_REGEX_MSVC
6  #pragma warning(push)
7  #pragma warning(disable : 4251)
8  #if BOOST_REGEX_MSVC < 1700
9  #     pragma warning(disable : 4231)
10  #endif
11  #if BOOST_REGEX_MSVC < 1600
12  #pragma warning(disable : 4660)
13  #endif
14  #if BOOST_REGEX_MSVC < 1910
15  #pragma warning(disable:4800)
16  #endif
17  #endif
18  namespace BOOST_REGEX_DETAIL_NS{
19  template <class charT, class traits>
20  class basic_regex_parser;
21  template <class I>
22  void bubble_down_one(I first, I last)
23  {
24     if(first != last)
25     {
26        I next = last - 1;
27        while((next != first) && (*next < *(next-1)))
28        {
29           (next-1)->swap(*next);
30           --next;
31        }
32     }
33  }
34  static const int hash_value_mask = 1 << (std::numeric_limits<int>::digits - 1);
35  template <class Iterator>
36  inline int hash_value_from_capture_name(Iterator i, Iterator j)
37  {
38     std::size_t r = 0;
39     while (i != j)
40     {
41        r ^= *i + 0x9e3779b9 + (r << 6) + (r >> 2);
42        ++i;
43     }
44     r %= ((std::numeric_limits<int>::max)());
45     return static_cast<int>(r) | hash_value_mask;
46  }
47  class named_subexpressions
48  {
49  public:
50     struct name
51     {
52        template <class charT>
53        name(const charT* i, const charT* j, int idx)
54           : index(idx) 
55        { 
56           hash = hash_value_from_capture_name(i, j); 
57        }
58        name(int h, int idx)
59           : index(idx), hash(h)
60        { 
61        }
62        int index;
63        int hash;
64        bool operator < (const name& other)const
65        {
66           return hash < other.hash;
67        }
68        bool operator == (const name& other)const
69        {
70           return hash == other.hash; 
71        }
72        void swap(name& other)
73        {
74           std::swap(index, other.index);
75           std::swap(hash, other.hash);
76        }
77     };
78     typedef std::vector<name>::const_iterator const_iterator;
79     typedef std::pair<const_iterator, const_iterator> range_type;
80     named_subexpressions(){}
81     template <class charT>
82     void set_name(const charT* i, const charT* j, int index)
83     {
84        m_sub_names.push_back(name(i, j, index));
85        bubble_down_one(m_sub_names.begin(), m_sub_names.end());
86     }
87     template <class charT>
88     int get_id(const charT* i, const charT* j)const
89     {
90        name t(i, j, 0);
91        typename std::vector<name>::const_iterator pos = std::lower_bound(m_sub_names.begin(), m_sub_names.end(), t);
92        if((pos != m_sub_names.end()) && (*pos == t))
93        {
94           return pos->index;
95        }
96        return -1;
97     }
98     template <class charT>
99     range_type equal_range(const charT* i, const charT* j)const
100     {
101        name t(i, j, 0);
102        return std::equal_range(m_sub_names.begin(), m_sub_names.end(), t);
103     }
104     int get_id(int h)const
105     {
106        name t(h, 0);
107        std::vector<name>::const_iterator pos = std::lower_bound(m_sub_names.begin(), m_sub_names.end(), t);
108        if((pos != m_sub_names.end()) && (*pos == t))
109        {
110           return pos->index;
111        }
112        return -1;
113     }
114     range_type equal_range(int h)const
115     {
116        name t(h, 0);
117        return std::equal_range(m_sub_names.begin(), m_sub_names.end(), t);
118     }
119  private:
120     std::vector<name> m_sub_names;
121  };
122  template <class charT, class traits>
123  struct regex_data : public named_subexpressions
124  {
125     typedef regex_constants::syntax_option_type   flag_type;
126     typedef std::size_t                           size_type;  
127     regex_data(const ::std::shared_ptr<
128        ::boost::regex_traits_wrapper<traits> >& t) 
129        : m_ptraits(t), m_flags(0), m_status(0), m_expression(0), m_expression_len(0),
130           m_mark_count(0), m_first_state(0), m_restart_type(0),
131           m_startmap{ 0 },
132           m_can_be_null(0), m_word_mask(0), m_has_recursions(false), m_disable_match_any(false) {}
133     regex_data() 
134        : m_ptraits(new ::boost::regex_traits_wrapper<traits>()), m_flags(0), m_status(0), m_expression(0), m_expression_len(0), 
135           m_mark_count(0), m_first_state(0), m_restart_type(0), 
136        m_startmap{ 0 },
137           m_can_be_null(0), m_word_mask(0), m_has_recursions(false), m_disable_match_any(false) {}
138     ::std::shared_ptr<
139        ::boost::regex_traits_wrapper<traits>
140        >                        m_ptraits;                 
141     flag_type                   m_flags;                   
142     int                         m_status;                  
143     const charT*                m_expression;              
144     std::ptrdiff_t              m_expression_len;          
145     size_type                   m_mark_count;              
146     BOOST_REGEX_DETAIL_NS::re_syntax_base*  m_first_state;             
147     unsigned                    m_restart_type;            
148     unsigned char               m_startmap[1 << CHAR_BIT]; 
149     unsigned int                m_can_be_null;             
150     BOOST_REGEX_DETAIL_NS::raw_storage      m_data;                    
151     typename traits::char_class_type    m_word_mask;       
152     std::vector<
153        std::pair<
154        std::size_t, std::size_t> > m_subs;                 
155     bool                        m_has_recursions;          
156     bool                        m_disable_match_any;       
157  };
158  template <class charT, class traits>
159  class basic_regex_implementation
160     : public regex_data<charT, traits>
161  {
162  public:
163     typedef regex_constants::syntax_option_type   flag_type;
164     typedef std::ptrdiff_t                        difference_type;
165     typedef std::size_t                           size_type; 
166     typedef typename traits::locale_type          locale_type;
167     typedef const charT*                          const_iterator;
168     basic_regex_implementation(){}
169     basic_regex_implementation(const ::std::shared_ptr<
170        ::boost::regex_traits_wrapper<traits> >& t)
171        : regex_data<charT, traits>(t) {}
172     void assign(const charT* arg_first,
173                            const charT* arg_last,
174                            flag_type f)
175     {
176        regex_data<charT, traits>* pdat = this;
177        basic_regex_parser<charT, traits> parser(pdat);
178        parser.parse(arg_first, arg_last, f);
179     }
180     locale_type  imbue(locale_type l)
181     { 
182        return this->m_ptraits->imbue(l); 
183     }
184     locale_type  getloc()const
185     { 
186        return this->m_ptraits->getloc(); 
187     }
188     std::basic_string<charT>  str()const
189     {
190        std::basic_string<charT> result;
191        if(this->m_status == 0)
192           result = std::basic_string<charT>(this->m_expression, this->m_expression_len);
193        return result;
194     }
195     const_iterator  expression()const
196     {
197        return this->m_expression;
198     }
199     std::pair<const_iterator, const_iterator>  subexpression(std::size_t n)const
200     {
201        const std::pair<std::size_t, std::size_t>& pi = this->m_subs.at(n);
202        std::pair<const_iterator, const_iterator> p(expression() + pi.first, expression() + pi.second);
203        return p;
204     }
205     const_iterator  begin()const
206     { 
207        return (this->m_status ? 0 : this->m_expression); 
208     }
209     const_iterator  end()const
210     { 
211        return (this->m_status ? 0 : this->m_expression + this->m_expression_len); 
212     }
213     flag_type  flags()const
214     {
215        return this->m_flags;
216     }
<span onclick='openModal()' class='match'>217     size_type  size()const
218     {
219        return this->m_expression_len;
220     }
221     int  status()const
222     {
223        return this->m_status;
</span>224     }
225     size_type  mark_count()const
226     {
227        return this->m_mark_count - 1;
228     }
229     const BOOST_REGEX_DETAIL_NS::re_syntax_base* get_first_state()const
230     {
231        return this->m_first_state;
232     }
233     unsigned get_restart_type()const
234     {
235        return this->m_restart_type;
236     }
237     const unsigned char* get_map()const
238     {
239        return this->m_startmap;
240     }
241     const ::boost::regex_traits_wrapper<traits>& get_traits()const
242     {
243        return *(this->m_ptraits);
244     }
245     bool can_be_null()const
246     {
247        return this->m_can_be_null;
248     }
249     const regex_data<charT, traits>& get_data()const
250     {
251        basic_regex_implementation<charT, traits> const* p = this;
252        return *static_cast<const regex_data<charT, traits>*>(p);
253     }
254  };
255  } 
256  #ifdef BOOST_REGEX_NO_FWD
257  template <class charT, class traits = regex_traits<charT> >
258  #else
259  template <class charT, class traits >
260  #endif
261  class basic_regex : public regbase
262  {
263  public:
264     typedef std::size_t                           traits_size_type;
265     typedef typename traits::string_type          traits_string_type;
266     typedef charT                                 char_type;
267     typedef traits                                traits_type;
268     typedef charT                                 value_type;
269     typedef charT&                                reference;
270     typedef const charT&                          const_reference;
271     typedef const charT*                          const_iterator;
272     typedef const_iterator                        iterator;
273     typedef std::ptrdiff_t                        difference_type;
274     typedef std::size_t                           size_type;   
275     typedef regex_constants::syntax_option_type   flag_type;
276     typedef typename traits::locale_type          locale_type;
277  public:
278     explicit basic_regex(){}
279     explicit basic_regex(const charT* p, flag_type f = regex_constants::normal)
280     {
281        assign(p, f);
282     }
283     basic_regex(const charT* p1, const charT* p2, flag_type f = regex_constants::normal)
284     {
285        assign(p1, p2, f);
286     }
287     basic_regex(const charT* p, size_type len, flag_type f)
288     {
289        assign(p, len, f);
290     }
291     basic_regex(const basic_regex& that)
292        : m_pimpl(that.m_pimpl) {}
293     ~basic_regex(){}
294     basic_regex&  operator=(const basic_regex& that)
295     {
296        return assign(that);
297     }
298     basic_regex&  operator=(const charT* ptr)
299     {
300        return assign(ptr);
301     }
302     basic_regex& assign(const basic_regex& that)
303     { 
304        m_pimpl = that.m_pimpl;
305        return *this; 
306     }
307     basic_regex& assign(const charT* p, flag_type f = regex_constants::normal)
308     {
309        return assign(p, p + traits::length(p), f);
310     }
311     basic_regex& assign(const charT* p, size_type len, flag_type f)
312     {
313        return assign(p, p + len, f);
314     }
315  private:
316     basic_regex& do_assign(const charT* p1,
317                            const charT* p2,
318                            flag_type f);
319  public:
320     basic_regex& assign(const charT* p1,
321                            const charT* p2,
322                            flag_type f = regex_constants::normal)
323     {
324        return do_assign(p1, p2, f);
325     }
326     template <class ST, class SA>
327     unsigned int  set_expression(const std::basic_string<charT, ST, SA>& p, flag_type f = regex_constants::normal)
328     { 
329        return set_expression(p.data(), p.data() + p.size(), f); 
330     }
331     template <class ST, class SA>
332     explicit basic_regex(const std::basic_string<charT, ST, SA>& p, flag_type f = regex_constants::normal)
333     { 
334        assign(p, f); 
335     }
336     template <class InputIterator>
337     basic_regex(InputIterator arg_first, InputIterator arg_last, flag_type f = regex_constants::normal)
338     {
339        typedef typename traits::string_type seq_type;
340        seq_type a(arg_first, arg_last);
341        if(!a.empty())
342           assign(static_cast<const charT*>(&*a.begin()), static_cast<const charT*>(&*a.begin() + a.size()), f);
343        else
344           assign(static_cast<const charT*>(0), static_cast<const charT*>(0), f);
345     }
346     template <class ST, class SA>
347     basic_regex&  operator=(const std::basic_string<charT, ST, SA>& p)
348     {
349        return assign(p.data(), p.data() + p.size(), regex_constants::normal);
350     }
351     template <class string_traits, class A>
352     basic_regex&  assign(
353         const std::basic_string<charT, string_traits, A>& s,
354         flag_type f = regex_constants::normal)
355     {
356        return assign(s.data(), s.data() + s.size(), f);
357     }
358     template <class InputIterator>
359     basic_regex&  assign(InputIterator arg_first,
360                            InputIterator arg_last,
361                            flag_type f = regex_constants::normal)
362     {
363        typedef typename traits::string_type seq_type;
364        seq_type a(arg_first, arg_last);
365        if(a.size())
366        {
367           const charT* p1 = &*a.begin();
368           const charT* p2 = &*a.begin() + a.size();
369           return assign(p1, p2, f);
370        }
371        return assign(static_cast<const charT*>(0), static_cast<const charT*>(0), f);
372     }
373     locale_type  imbue(locale_type l);
374     locale_type  getloc()const
375     { 
376        return m_pimpl.get() ? m_pimpl->getloc() : locale_type(); 
377     }
378     flag_type  getflags()const
379     { 
380        return flags();
381     }
382     flag_type  flags()const
383     { 
384        return m_pimpl.get() ? m_pimpl->flags() : 0;
385     }
386     std::basic_string<charT>  str()const
387     {
388        return m_pimpl.get() ? m_pimpl->str() : std::basic_string<charT>();
389     }
390     std::pair<const_iterator, const_iterator>  subexpression(std::size_t n)const
391     {
392  #ifdef BOOST_REGEX_STANDALONE
393        if (!m_pimpl.get())
394           throw std::logic_error("Can't access subexpressions in an invalid regex.");
395  #else
396        if(!m_pimpl.get())
397           boost::throw_exception(std::logic_error("Can't access subexpressions in an invalid regex."));
398  #endif
399        return m_pimpl->subexpression(n);
400     }
401     const_iterator  begin()const
402     { 
403        return (m_pimpl.get() ? m_pimpl->begin() : 0); 
404     }
405     const_iterator  end()const
406     { 
407        return (m_pimpl.get() ? m_pimpl->end() : 0); 
408     }
409     void  swap(basic_regex& that)throw()
410     {
411        m_pimpl.swap(that.m_pimpl);
412     }
413     size_type  size()const
414     { 
415        return (m_pimpl.get() ? m_pimpl->size() : 0); 
416     }
417     size_type  max_size()const
418     { 
419        return UINT_MAX; 
420     }
421     bool  empty()const
422     { 
423        return (m_pimpl.get() ? 0 != m_pimpl->status() : true); 
424     }
425     size_type  mark_count()const 
426     { 
427        return (m_pimpl.get() ? m_pimpl->mark_count() : 0); 
428     }
429     int status()const
430     {
431        return (m_pimpl.get() ? m_pimpl->status() : regex_constants::error_empty);
432     }
433     int  compare(const basic_regex& that) const
434     {
435        if(m_pimpl.get() == that.m_pimpl.get())
436           return 0;
437        if(!m_pimpl.get())
438           return -1;
439        if(!that.m_pimpl.get())
440           return 1;
441        if(status() != that.status())
442           return status() - that.status();
443        if(flags() != that.flags())
444           return flags() - that.flags();
445        return str().compare(that.str());
446     }
447     bool  operator==(const basic_regex& e)const
448     { 
449        return compare(e) == 0; 
450     }
451     bool  operator != (const basic_regex& e)const
452     { 
453        return compare(e) != 0; 
454     }
455     bool  operator<(const basic_regex& e)const
456     { 
457        return compare(e) < 0; 
458     }
459     bool  operator>(const basic_regex& e)const
460     { 
461        return compare(e) > 0; 
462     }
463     bool  operator<=(const basic_regex& e)const
464     { 
465        return compare(e) <= 0; 
466     }
467     bool  operator>=(const basic_regex& e)const
468     { 
469        return compare(e) >= 0; 
470     }
471     const charT*  expression()const 
472     { 
473        return (m_pimpl.get() && !m_pimpl->status() ? m_pimpl->expression() : 0); 
474     }
475     unsigned int  set_expression(const charT* p1, const charT* p2, flag_type f = regex_constants::normal)
476     {
477        assign(p1, p2, f | regex_constants::no_except);
478        return status();
479     }
480     unsigned int  set_expression(const charT* p, flag_type f = regex_constants::normal) 
481     { 
482        assign(p, f | regex_constants::no_except); 
483        return status();
484     }
485     unsigned int  error_code()const
486     {
487        return status();
488     }
489     const BOOST_REGEX_DETAIL_NS::re_syntax_base* get_first_state()const
490     {
491        BOOST_REGEX_ASSERT(0 != m_pimpl.get());
492        return m_pimpl->get_first_state();
493     }
494     unsigned get_restart_type()const
495     {
496        BOOST_REGEX_ASSERT(0 != m_pimpl.get());
497        return m_pimpl->get_restart_type();
498     }
499     const unsigned char* get_map()const
500     {
501        BOOST_REGEX_ASSERT(0 != m_pimpl.get());
502        return m_pimpl->get_map();
503     }
504     const ::boost::regex_traits_wrapper<traits>& get_traits()const
505     {
506        BOOST_REGEX_ASSERT(0 != m_pimpl.get());
507        return m_pimpl->get_traits();
508     }
509     bool can_be_null()const
510     {
511        BOOST_REGEX_ASSERT(0 != m_pimpl.get());
512        return m_pimpl->can_be_null();
513     }
514     const BOOST_REGEX_DETAIL_NS::regex_data<charT, traits>& get_data()const
515     {
516        BOOST_REGEX_ASSERT(0 != m_pimpl.get());
517        return m_pimpl->get_data();
518     }
519     std::shared_ptr<BOOST_REGEX_DETAIL_NS::named_subexpressions > get_named_subs()const
520     {
521        return m_pimpl;
522     }
523  private:
524     std::shared_ptr<BOOST_REGEX_DETAIL_NS::basic_regex_implementation<charT, traits> > m_pimpl;
525  };
526  template <class charT, class traits>
527  basic_regex<charT, traits>& basic_regex<charT, traits>::do_assign(const charT* p1,
528                          const charT* p2,
529                          flag_type f)
530  {
531     std::shared_ptr<BOOST_REGEX_DETAIL_NS::basic_regex_implementation<charT, traits> > temp;
532     if(!m_pimpl.get())
533     {
534        temp = std::shared_ptr<BOOST_REGEX_DETAIL_NS::basic_regex_implementation<charT, traits> >(new BOOST_REGEX_DETAIL_NS::basic_regex_implementation<charT, traits>());
535     }
536     else
537     {
538        temp = std::shared_ptr<BOOST_REGEX_DETAIL_NS::basic_regex_implementation<charT, traits> >(new BOOST_REGEX_DETAIL_NS::basic_regex_implementation<charT, traits>(m_pimpl->m_ptraits));
539     }
540     temp->assign(p1, p2, f);
541     temp.swap(m_pimpl);
542     return *this;
543  }
544  template <class charT, class traits>
545  typename basic_regex<charT, traits>::locale_type  basic_regex<charT, traits>::imbue(locale_type l)
546  { 
547     std::shared_ptr<BOOST_REGEX_DETAIL_NS::basic_regex_implementation<charT, traits> > temp(new BOOST_REGEX_DETAIL_NS::basic_regex_implementation<charT, traits>());
548     locale_type result = temp->imbue(l);
549     temp.swap(m_pimpl);
550     return result;
551  }
552  template <class charT, class traits>
553  void swap(basic_regex<charT, traits>& e1, basic_regex<charT, traits>& e2)
554  {
555     e1.swap(e2);
556  }
557  template <class charT, class traits, class traits2>
558  std::basic_ostream<charT, traits>& 
559     operator << (std::basic_ostream<charT, traits>& os, 
560                  const basic_regex<charT, traits2>& e)
561  {
562     return (os << e.str());
563  }
564  #ifdef BOOST_REGEX_NO_FWD
565  template <class charT, class traits = regex_traits<charT> >
566  #else
567  template <class charT, class traits >
568  #endif
569  class reg_expression : public basic_regex<charT, traits>
570  {
571  public:
572     typedef typename basic_regex<charT, traits>::flag_type flag_type;
573     typedef typename basic_regex<charT, traits>::size_type size_type;
574     explicit reg_expression(){}
575     explicit reg_expression(const charT* p, flag_type f = regex_constants::normal)
576        : basic_regex<charT, traits>(p, f){}
577     reg_expression(const charT* p1, const charT* p2, flag_type f = regex_constants::normal)
578        : basic_regex<charT, traits>(p1, p2, f){}
579     reg_expression(const charT* p, size_type len, flag_type f)
580        : basic_regex<charT, traits>(p, len, f){}
581     reg_expression(const reg_expression& that)
582        : basic_regex<charT, traits>(that) {}
583     ~reg_expression(){}
584     reg_expression&  operator=(const reg_expression& that)
585     {
586        return this->assign(that);
587     }
588     template <class ST, class SA>
589     explicit reg_expression(const std::basic_string<charT, ST, SA>& p, flag_type f = regex_constants::normal)
590     : basic_regex<charT, traits>(p, f)
591     { 
592     }
593     template <class InputIterator>
594     reg_expression(InputIterator arg_first, InputIterator arg_last, flag_type f = regex_constants::normal)
595     : basic_regex<charT, traits>(arg_first, arg_last, f)
596     {
597     }
598     template <class ST, class SA>
599     reg_expression&  operator=(const std::basic_string<charT, ST, SA>& p)
600     {
601        this->assign(p);
602        return *this;
603     }
604  };
605  #ifdef BOOST_REGEX_MSVC
606  #pragma warning (pop)
607  #endif
608  } 
609  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-bowbs.h</h3>
            <pre><code>1  ClassHdTP(TBowDocBs, PBowDocBs);
2  ClassTP(TBowKWordSet, PBowKWordSet)
3  private:
4    TStr Nm;
5    THash<TStr, TFlt> WStrToWWgtH;
6  public:
7    TBowKWordSet(const TStr& _Nm=""): Nm(_Nm), WStrToWWgtH(){}
8    static PBowKWordSet New(const TStr& Nm=""){return new TBowKWordSet(Nm);}
9    TBowKWordSet(const TBowKWordSet& BowKWordSet):
10      Nm(BowKWordSet.Nm), WStrToWWgtH(BowKWordSet.WStrToWWgtH){}
11    TBowKWordSet(TSIn& SIn): Nm(SIn), WStrToWWgtH(SIn){}
12    static PBowKWordSet Load(TSIn& SIn){return new TBowKWordSet(SIn);}
13    void Save(TSOut& SOut) const {Nm.Save(SOut); WStrToWWgtH.Save(SOut);}
14    TBowKWordSet& operator=(const TBowKWordSet& BowKWordSet){
15      Nm=BowKWordSet.Nm; WStrToWWgtH=BowKWordSet.WStrToWWgtH; return *this;}
16    void PutNm(const TStr& _Nm){Nm=_Nm;}
17    TStr GetNm() const {return Nm;}
18    void AddKWord(const TStr& KWordStr, const double& KWordWgt){
19      WStrToWWgtH.AddDat(KWordStr, KWordWgt);}
20    int GetKWords() const {return WStrToWWgtH.Len();}
21    bool IsKWordStr(const TStr& KWordStr) const {return WStrToWWgtH.IsKey(KWordStr);}
22    int GetKWordN(const TStr& KWordStr) const {return WStrToWWgtH.GetKeyId(KWordStr);}
23    TStr GetKWordStr(const int& KWordN) const {return WStrToWWgtH.GetKey(KWordN);}
24    double GetKWordWgt(const int& KWordN) const {return WStrToWWgtH[KWordN];}
25    void GetWordStrV(TStrV& WordStrV) const;
26    TStr GetKWordsStr() const;
27    void SortByStr();
28    void SortByWgt();
29    PBowKWordSet GetTopKWords(const int& MxKWords, const double& WgtSumPrc) const;
30    void SaveTxt(const PSOut& SOut) const;
31    void SaveTxt(const TStr& FNm) const {
32      PSOut SOut=TFOut::New(FNm); SaveTxt(SOut);}
33    void SaveXml(const PSOut& SOut) const;
34    void SaveXml(const TStr& FNm) const {
35      PSOut SOut=TFOut::New(FNm); SaveXml(SOut);}
36    void SaveBin(const PSOut& SOut) const {
37      Save(*SOut);}
38    void SaveBin(const TStr& FNm) const {
39      PSOut SOut=TFOut::New(FNm); SaveBin(SOut);}
40  };
41  ClassTP(TBowKWordBs, PBowKWordBs)
42  private:
43    THash<TStr, PBowKWordSet> SetNmToSetH;
44  public:
45    TBowKWordBs(): SetNmToSetH(){}
46    static PBowKWordBs New(){return new TBowKWordBs();}
47    TBowKWordBs(const TBowKWordBs& BowKWordBs):
48      SetNmToSetH(BowKWordBs.SetNmToSetH){}
49    TBowKWordBs(TSIn& SIn): SetNmToSetH(SIn){}
50    static PBowKWordBs Load(TSIn& SIn){return new TBowKWordBs(SIn);}
51    void Save(TSOut& SOut) const {SetNmToSetH.Save(SOut);}
52    TBowKWordBs& operator=(const TBowKWordBs& BowKWordBs){
53      SetNmToSetH=BowKWordBs.SetNmToSetH; return *this;}
54    void AddKWordSet(const TStr& KWordSetNm, const PBowKWordSet& KWordSet){
55      SetNmToSetH.AddDat(KWordSetNm, KWordSet);}
56    void AddKWordSet(const PBowKWordSet& KWordSet){
57      SetNmToSetH.AddDat(KWordSet->GetNm(), KWordSet);}
58    int GetKWordSets() const {return SetNmToSetH.Len();}
59    bool IsKWordSset(const TStr& KWordSetNm) const {return SetNmToSetH.IsKey(KWordSetNm);}
60    PBowKWordSet GetKWordSet(const int& KWordSetN) const {return SetNmToSetH[KWordSetN];}
61    PBowKWordSet GetKWordSet(const TStr& KWordSetNm) const {return SetNmToSetH.GetDat(KWordSetNm);}
62    void SaveTxt(const PSOut& SOut) const;
63    void SaveTxt(const TStr& FNm) const {
64      PSOut SOut=TFOut::New(FNm); SaveTxt(SOut);}
65    void SaveXml(const PSOut& SOut) const;
66    void SaveXml(const TStr& FNm) const {
67      PSOut SOut=TFOut::New(FNm); SaveXml(SOut);}
68    static PBowKWordBs LoadBin(const TStr& FNm){
69      TFIn SIn(FNm); return Load(SIn);}
70    void SaveBin(const PSOut& SOut) const {
71      Save(*SOut);}
72    void SaveBin(const TStr& FNm) const {
73      PSOut SOut=TFOut::New(FNm); SaveBin(SOut);}
74  };
75  typedef TIntSFltKd TBowWIdWgtKd;
76  typedef TBowWIdWgtKd* PBowWIdWgtKd;
77  typedef TVec<TBowWIdWgtKd> TBowWIdWgtKdV;
78  typedef TVec<TBowWIdWgtKdV> TBowWIdWgtKdVV;
79  ClassTPV(TBowSpV, PBowSpV, TBowSpVV)
80  private:
81    TInt DId;
82    TFlt Norm;
83    TBowWIdWgtKdV WIdWgtKdV;
84    UndefCopyAssign(TBowSpV);
85  public:
86    TBowSpV(const int& _DId=-1, const int& ExpWIds=0):
87      DId(_DId), Norm(-1), WIdWgtKdV(ExpWIds, 0){}
88    static PBowSpV New(const int& DId=-1, const int& ExpWIds=0){
89      return PBowSpV(new TBowSpV(DId, ExpWIds));}
90    TBowSpV(const int& DId, const TFltV& FullVec, const double& Eps=1e-14);
91    static PBowSpV New(const int& DId, const TFltV& FullVec,
92      const double& Eps=1e-14) { return PBowSpV(new TBowSpV(DId, FullVec, Eps));}
93    TBowSpV(const int& DId, const TIntFltKdV& SpV);
94    static PBowSpV New(const int& DId, const TIntFltKdV& SpV) {
95      return PBowSpV(new TBowSpV(DId, SpV));}
96    TBowSpV(TSIn& SIn):
97      DId(SIn), Norm(SIn), WIdWgtKdV(SIn){}
98    static PBowSpV Load(TSIn& SIn){return new TBowSpV(SIn);}
99    void Save(TSOut& SOut) const {
100      DId.Save(SOut); Norm.Save(SOut); WIdWgtKdV.Save(SOut);}
101    void Clr(){DId=-1; WIdWgtKdV.Clr();}
102    void GenMx(const int& MxWIds){WIdWgtKdV.Gen(MxWIds, 0);}
103    void Sort(){WIdWgtKdV.Sort();}
104    void Trunc(){WIdWgtKdV.Trunc();}
105    int Len() const {return WIdWgtKdV.Len();}
106    int Reserved() const {return WIdWgtKdV.Reserved();}
107    void PutDId(const int& _DId){DId=_DId;}
108    int GetDId() const {return DId;}
109    bool IsDId() const {return DId!=-1;}
110    PBowWIdWgtKd BegI() const {return WIdWgtKdV.BegI();}
111    PBowWIdWgtKd EndI() const {return WIdWgtKdV.EndI();}
112    PBowWIdWgtKd GetI(const int& ValN) const {return WIdWgtKdV.GetI(ValN);}
113    void AssignNorm(const double& _Norm){Norm=_Norm;}
114    void PutUnitNorm();
115    double GetNorm();
116    void AddWIdWgt(const int& WId, const double& Wgt){
117      WIdWgtKdV.Add(TBowWIdWgtKd(WId, (sdouble)Wgt));}
118    int GetWIds() const {return WIdWgtKdV.Len();}
119    int GetWIdN(const int& WId) const {return WIdWgtKdV.SearchForw(TBowWIdWgtKd(WId));}
120    bool IsWId(const int& WId) const {return WIdWgtKdV.SearchForw(TBowWIdWgtKd(WId))!=-1;}
121    int GetWId(const int& WIdN) const {return WIdWgtKdV[WIdN].Key;}
122    TSFlt& GetWgt(const int& WIdN){return WIdWgtKdV[WIdN].Dat;}
123    void GetWIdWgt(const int& WIdN, int& WId, double& Wgt) const {
124      const TBowWIdWgtKd& WIdWgtKd=WIdWgtKdV[WIdN];
125      WId=WIdWgtKd.Key; Wgt=WIdWgtKd.Dat;}
126    void GetWordStrWgtPrV(const PBowDocBs& BowDocBs,
127     const int& TopWords, const double& TopWordsWgtPrc,
128     TStrFltPrV& WordStrWgtPrV) const;
129    PBowKWordSet GetKWordSet(const PBowDocBs& BowDocBs) const;
130    int GetLastWId() const { return WIdWgtKdV.Last().Key; }
131    void GetIntFltKdV(TIntFltKdV& SpV) const;
132    void CutLowWgtWords(const double& CutWordWgtSumPrc);
133    TStr GetStr(const PBowDocBs& BowDocBs,
134     const int& TopWords=-1, const double& TopWordsWgtPrc=1, const TStr& SepStr=" ",
135     const bool& ShowWeightsP=true, const bool& KeepUndelineP=true) const;
136    void SaveTxt(const PSOut& SOut, const PBowDocBs& BowDocBs,
137     const int& TopWords=-1, const double& TopWordsWgtPrc=1,
138     const char& SepCh=' ') const;
139    void SaveXml(const PSOut& SOut, const PBowDocBs& BowDocBs) const;
140  };
141  ClassTP(TBowSimMtx, PBowSimMtx)
142  private:
143    TIntV MtxDIdV;
144    TIntPrFltH DIdPrToSimH;
145  public:
146    TBowSimMtx(): MtxDIdV(), DIdPrToSimH(){}
147    static PBowSimMtx New(){return new TBowSimMtx();}
148    TBowSimMtx(TSIn& SIn): MtxDIdV(SIn), DIdPrToSimH(SIn){}
149    static PBowSimMtx Load(TSIn& SIn){return new TBowSimMtx(SIn);}
150    void Save(TSOut& SOut) const {MtxDIdV.Save(SOut); DIdPrToSimH.Save(SOut);}
<span onclick='openModal()' class='match'>151    TBowSimMtx& operator=(const TBowSimMtx&){Fail; return *this;}
152    int GetDocs() const {return MtxDIdV.Len();}
</span>153    int GetMtxDId(const int& MtxDIdN) const {return MtxDIdV[MtxDIdN];}
154    void GetDIdV(TIntV& _MtxDIdV) const {_MtxDIdV=MtxDIdV;}
155    double GetSim(const int& DId1, const int& DId2) const;
156    static PBowSimMtx LoadTxt(const TStr& FNm);
157  };
158  typedef enum {bstUndef, bstBlock, bstEucl, bstCos, bstMtx} TBowSimType;
159  ClassTP(TBowSim, PBowSim)
160  private:
161    TInt SimType; 
162    PBowSimMtx SimMtx;
163  public:
164    TBowSim(const TBowSimType& _Type=bstUndef, const PBowSimMtx& _SimMtx=NULL):
165      SimType(_Type), SimMtx(_SimMtx){}
166    static PBowSim New(const TBowSimType& SimType, const PBowSimMtx& SimMtx=NULL){
167      return new TBowSim(SimType, SimMtx);}
168    TBowSim(TSIn& SIn): SimType(SIn), SimMtx(SIn){}
169    static PBowSim Load(TSIn& SIn){return new TBowSim(SIn);}
170    void Save(TSOut& SOut) const {SimType.Save(SOut); SimMtx.Save(SOut);}
171    TBowSim& operator=(const TBowSim&){Fail; return *this;}
172    TBowSimType GetSimType() const {return TBowSimType(int(SimType));}
173    double GetSim(const int& DId1, const int& DId2) const;
174    double GetSim(const PBowSpV& SpV1, const PBowSpV& SpV2) const;
175    double GetSim(const TBowSpVV& SpVV1, const TBowSpVV& SpVV2) const;
176    static double GetBlockSim(const PBowSpV& SpV1, const PBowSpV& SpV2);
177    static double GetEuclSim(const PBowSpV& SpV1, const PBowSpV& SpV2);
178    static double GetCosSim(const PBowSpV& SpV1, const PBowSpV& SpV2);
179    static double GetCosSim(const PBowSpV& SpV1, const PBowSpV& SpV2,
180     TFltIntPrV& WgtWIdPrV);
181    static TBowSimType GetSimType(const TStr& Nm);
182  };
183  typedef enum {bwwtUndef,
184    bwwtEq, 
185    bwwtNrmEq, 
186    bwwtBin, 
187    bwwtNrmBin, 
188    bwwtNrm01, 
189    bwwtNrmTFIDF, 
190    bwwtLogDFNrmTFIDF, 
191    bwwtNrmTFICF, 
192    bwwtPreCalc, 
193    bwwtSvm 
194  } TBowWordWgtType;
195  ClassTP(TBowDocWgtBs, PBowDocWgtBs)
196  private:
197    TInt Sig; 
198    TInt BowDocBsSig; 
199    TInt WordWgtType;
200    TFlt CutWordWgtSumPrc;
201    TInt MnWordFq;
202    TIntV DIdV;
203    TFltV WordFqV;
204    TBowSpVV DocSpVV;
205  public:
206    TBowDocWgtBs(const int& _BowDocBsSig):
207      Sig(TSecTm::GetCurTm().GetAbsSecs()), BowDocBsSig(_BowDocBsSig),
208      WordWgtType(), CutWordWgtSumPrc(), MnWordFq(),
209      DIdV(), WordFqV(), DocSpVV(){}
210    static PBowDocWgtBs New(const int& BowDocBsSig){
211      return PBowDocWgtBs(new TBowDocWgtBs(BowDocBsSig));}
212    static PBowDocWgtBs New(
213     const PBowDocBs& BowDocBs, const TBowWordWgtType& _WordWgtType,
214     const double& _CutWordWgtSumPrc=0, const int& _MnWordFq=0,
215     const TIntV& _DIdV=TIntV(), const TIntV& BaseDIdV=TIntV(),
216     const PNotify& Notify=TNotify::NullNotify);
217    static PBowDocWgtBs New(const TVec<PBowSpV>& BowSpVV);
218    static PBowDocWgtBs NewPreCalcWgt(const PBowDocBs& BowDocBs,
219     const TFltV& WordWgtV, const bool& PutUniteNorm = false,
220     const double& _CutWordWgtSumPrc=0, const int& _MnWordFq=0,
221     const TIntV& _DIdV=TIntV());
222    static PBowDocWgtBs NewSvmWgt(
223     const PBowDocBs& BowDocBs,
224     const PBowDocWgtBs& BowDocWgtBs,
225     const TIntV& _TrainDIdV = TIntV(),
226     const double& SvmCostParam = 1.0,
227     const int& MxTimePerCat = 60,
228     const bool& NegFeaturesP = false,
229     const TIntV& _DIdV = TIntV(),
230     const bool& PutUniteNormP = false,
231     const double& _CutWordWgtSumPrc = 0.0,
232     const int& _MnWordFq = 0);
233    static PBowDocWgtBs NewBinSvmWgt(
234     const PBowDocBs& BowDocBs,
235     const PBowDocWgtBs& BowDocWgtBs,
236     const TStr& CatNm,
237     const TIntV& TrainDIdV = TIntV(),
238     const double& SvmCostParam = 1.0,
239     const double& SvmUnbalanceParam = 1.0,
240     const double& MnWgt = 0.0,
241     const bool& NegFeaturesP = false,
242     const bool& PutUniteNormP = true,
243     const bool& AvgNormalP = true,
244     const TIntV& _DIdV = TIntV(),
245     const double& _CutWordWgtSumPrc = 0.0,
246     const int& _MnWordFq = 0);
247    TBowDocWgtBs(TSIn& SIn):
248      Sig(SIn), BowDocBsSig(SIn),
249      WordWgtType(SIn), CutWordWgtSumPrc(SIn), MnWordFq(SIn),
250      DIdV(SIn), WordFqV(SIn), DocSpVV(SIn){}
251    static PBowDocWgtBs Load(TSIn& SIn){return new TBowDocWgtBs(SIn);}
252    void Save(TSOut& SOut) const {
253      Sig.Save(SOut); BowDocBsSig.Save(SOut);
254      WordWgtType.Save(SOut); CutWordWgtSumPrc.Save(SOut); MnWordFq.Save(SOut);
255      DIdV.Save(SOut); WordFqV.Save(SOut); DocSpVV.Save(SOut);}
256    TBowDocWgtBs& operator=(const TBowDocWgtBs& BowDocWgtBs){
257      Sig=BowDocWgtBs.Sig;
258      BowDocBsSig=BowDocWgtBs.BowDocBsSig;
259      WordWgtType=BowDocWgtBs.WordWgtType;
260      CutWordWgtSumPrc=BowDocWgtBs.CutWordWgtSumPrc;
261      MnWordFq=BowDocWgtBs.MnWordFq;
262      DIdV=BowDocWgtBs.DIdV;
263      WordFqV=BowDocWgtBs.WordFqV;
264      DocSpVV=BowDocWgtBs.DocSpVV;
265      return *this;}
266    PBowDocWgtBs GetSubSet(const TIntV& IdSubSet){
267      PBowDocWgtBs BowDocWgtBs=TBowDocWgtBs::New(BowDocBsSig);
268      *BowDocWgtBs=*this;
269      BowDocWgtBs->DIdV=IdSubSet;
270      return BowDocWgtBs;}
271    int GetSig() const {return Sig;}
272    int GetBowDocBsSig() const {return BowDocBsSig;}
273    TBowWordWgtType GetWordWgtType() const {
274      return TBowWordWgtType(int(WordWgtType));}
275    static TBowWordWgtType GetWordWgtTypeFromStr(const TStr& Nm);
276    double GetCutWordWgtSumPrc() const {return CutWordWgtSumPrc;}
277    int GetMnWordFq() const {return MnWordFq;}
278    int GetDocs() const {return DIdV.Len();}
279    int GetDId(const int& DIdN) const {return DIdV[DIdN];}
280    PBowSpV GetSpV(const int& DId) const {return DocSpVV[DId];}
281    void SetSpV(const int& DId, PBowSpV DocSpV) { DocSpVV[DId] = DocSpV; } 
282    void GetDIdV(TIntV& _DIdV) const {_DIdV=DIdV;}
283    void SetDIdV(const TIntV& _DIdV){DIdV=_DIdV;}
284    const TBowSpVV& GetDocSpVV() const { return DocSpVV; }
285    int GetWords() const {return WordFqV.Len();}
286    double GetWordFq(const int& WId) const {return WordFqV[WId];}
287    void GetSimDIdV(
288     const PBowSpV& RefBowSpV, const PBowSim& BowSim,
289     TFltIntKdV& SimDIdKdV, const bool& RefBowSpVInclude=false) const;
290    void SaveTxtSimDIdV(
291     const PSOut& SOut, const PBowDocBs& BowDocBs,
292     const PBowSpV& RefBowSpV, const TFltIntKdV& SimDIdKdV,
293     const int& TopHits=-1, const double& MnSim=0, const int& TopDocWords=-1,
294     const char& SepCh=' ') const;
295    void SaveXmlSimDIdV(
296     const PSOut& SOut, const PBowDocBs& BowDocBs,
297     const PBowSpV& RefBowSpV, const TFltIntKdV& SimDIdKdV,
298     const int& TopHits=-1, const double& MnSim=0) const;
299    void SaveTxtStat(
300     const TStr& StatFNm, const PBowDocBs& BowDocBs,
301     const bool& SaveWordsP=true, const bool& SaveCatsP=true,
302     const bool& SaveDocsP=true) const;
303    static const TStr BowDocWgtBsFExt;
304    static PBowDocWgtBs LoadBin(const TStr& FNm){
305      TFIn SIn(FNm); return Load(SIn);}
306    void SaveBin(const TStr& FNm) const {
307      TFOut SOut(FNm); Save(SOut);}
308  };
309  class TBowWordDesc{
310  public:
311    TInt Fq;
312    TFlt MnVal;
313    TFlt MxVal;
314  public:
315    TBowWordDesc():
316      Fq(0), MnVal(0), MxVal(0){}
317    TBowWordDesc(const int& _Fq, const double& _MnVal, const double& _MxVal):
318      Fq(_Fq), MnVal(_MnVal), MxVal(_MxVal){}
319    TBowWordDesc(TSIn& SIn):
320      Fq(SIn), MnVal(SIn), MxVal(SIn){}
321    void Save(TSOut& SOut) const {
322      Fq.Save(SOut); MnVal.Save(SOut); MxVal.Save(SOut);}
323    TBowWordDesc& operator=(const TBowWordDesc& BowWordDesc){
324      Fq=BowWordDesc.Fq; MnVal=BowWordDesc.MnVal; MxVal=BowWordDesc.MxVal;
325      return *this;}
326    bool operator==(const TBowWordDesc& BowWordDesc) const {
327      return Fq==BowWordDesc.Fq;}
328    bool operator<(const TBowWordDesc& BowWordDesc) const {
329      return Fq<BowWordDesc.Fq;}
330  };
331  typedef TPair<TBowWordDesc, TStr> TBowWordDescStrPr;
332  typedef TVec<TBowWordDescStrPr> TBowWordDescStrPrV;
333  ClassTP(TBowDocBs, PBowDocBs)
334  private:
335    TInt Sig; 
336    PNGramBs NGramBs; 
337    PSwSet SwSet; 
338    PStemmer Stemmer; 
339    TStrStrH DocNmToDescStrH; 
340    THash<TStr, TBowWordDesc> WordStrToDescH; 
341    TStrIntH CatNmToFqH; 
342    TBowSpVV DocSpVV; 
343    TStrV DocStrV; 
344    TVec<TIntV> DocCIdVV; 
345    TIntV TrainDIdV; 
346    TIntV TestDIdV; 
347  public:
348    TBowDocBs():
349      Sig(TSecTm::GetCurTm().GetAbsSecs()),
350      NGramBs(), SwSet(), Stemmer(),
351      DocNmToDescStrH(), WordStrToDescH(), CatNmToFqH(),
352      DocSpVV(), DocStrV(), DocCIdVV(),
353      TrainDIdV(), TestDIdV(){}
354    static PBowDocBs New(){return new TBowDocBs();}
355    static PBowDocBs New(
356     const PSwSet& SwSet, const PStemmer& Stemmer, const PNGramBs& NGramBs);
357    TBowDocBs(TSIn& SIn):
358      Sig(SIn),
359      NGramBs(SIn), SwSet(SIn), Stemmer(SIn),
360      DocNmToDescStrH(SIn), WordStrToDescH(SIn), CatNmToFqH(SIn),
361      DocSpVV(SIn), DocStrV(SIn), DocCIdVV(SIn),
362      TrainDIdV(SIn), TestDIdV(SIn){}
363    static PBowDocBs Load(TSIn& SIn){return new TBowDocBs(SIn);}
364    void Save(TSOut& SOut) const {
365      Sig.Save(SOut);
366      NGramBs.Save(SOut); SwSet.Save(SOut); Stemmer.Save(SOut);
367      DocNmToDescStrH.Save(SOut); WordStrToDescH.Save(SOut); CatNmToFqH.Save(SOut);
368      DocSpVV.Save(SOut); DocStrV.Save(SOut); DocCIdVV.Save(SOut);
369      TrainDIdV.Save(SOut); TestDIdV.Save(SOut);}
370    TBowDocBs& operator=(const TBowDocBs& BowDocBs){
371      Sig=BowDocBs.Sig;
372      NGramBs=BowDocBs.NGramBs;
373      SwSet=BowDocBs.SwSet;
374      Stemmer=BowDocBs.Stemmer;
375      DocNmToDescStrH=BowDocBs.DocNmToDescStrH;
376      WordStrToDescH=BowDocBs.WordStrToDescH;
377      CatNmToFqH=BowDocBs.CatNmToFqH;
378      DocSpVV=BowDocBs.DocSpVV;
379      DocStrV=BowDocBs.DocStrV;
380      DocCIdVV=BowDocBs.DocCIdVV;
381      TrainDIdV=BowDocBs.TrainDIdV;
382      TestDIdV=BowDocBs.TestDIdV;
383      return *this;}
384    void AddDocs(const PBowDocBs& BowDocBs);
385    void AssertOk() const;
386    int GetSig() const {return Sig;}
387    void PutNGramBs(const PNGramBs& _NGramBs){NGramBs=_NGramBs;}
388    PNGramBs GetNGramBs() const {return NGramBs;}
389    void PutSwSet(const PSwSet& _SwSet){SwSet=_SwSet;}
390    PSwSet GetSwSet() const {return SwSet;}
391    void PutStemmer(const PStemmer& _Stemmer){Stemmer=_Stemmer;}
392    PStemmer GetStemmer() const {return Stemmer;}
393    int GetWords() const {return WordStrToDescH.Len();}
394    int AddWordStr(const TStr& WordStr){return WordStrToDescH.AddKey(WordStr);}
395    bool IsWordStr(const TStr& WordStr) const {
396      return WordStrToDescH.IsKey(WordStr);}
397    bool IsWordStr(const TStr& WordStr, int& WId) const {
398      return WordStrToDescH.IsKey(WordStr, WId);}
399    bool IsWId(const int& WId) const {
400      return WordStrToDescH.IsKeyId(WId);}
401    int GetWId(const TStr& WordStr) const {
402      return WordStrToDescH.GetKeyId(WordStr);}
403    TStr GetWordStr(const int& WId) const {
404      return WordStrToDescH.GetKey(WId);}
405    double GetWordMnVal(const int& WId) const {
406      return WordStrToDescH[WId].MnVal;}
407    double GetWordMxVal(const int& WId) const {
408      return WordStrToDescH[WId].MxVal;}
409    void PutWordFq(const int& WId, const int& Fq){
410      WordStrToDescH[WId].Fq=Fq;}
411    int GetWordFq(const int& WId) const {
412      return WordStrToDescH[WId].Fq;}
413    void GetWordStrVFromHtml(const TStr& HtmlStr, TStrV& WordStrV) const;
414    int AddDoc(const TStr& DocNm,
415     const TStrV& CatNmV, const TIntFltPrV& WIdWgtPrV);
416    int AddDoc(const TStr& DocNm,
417     const TStrV& CatNmV, const TStrV& WordStrV, const TStr& DocStr=TStr());
418    int AddDoc(const TStr& DocNm,
419     const TStr& CatNm, const TStrV& WordStrV, const TStr& DocStr=TStr()){
420      TStrV CatNmV; CatNmV.Add(CatNm);
421      return AddDoc(DocNm, CatNmV, WordStrV, DocStr);}
422    int AddHtmlDoc(const TStr& DocNm, const TStrV& CatNmV,
423     const TStr& HtmlDocStr, const bool& SaveDocP=false);
424    int GetDocs() const {return DocSpVV.Len();}
425    PBowSpV GetDocSpV(const int& DId) const {return DocSpVV[DId];}
426    void PutDocStr(const int& DId, const TStr& DocStr){DocStrV[DId]=DocStr; }
427    TStr GetDocStr(const int& DId) const {return DocStrV[DId];}
428    bool IsDocNm(const TStr& DocNm) const {
429      return DocNmToDescStrH.IsKey(DocNm);}
430    bool IsDocNm(const TStr& DocNm, int& DId) const {
431      DId=DocNmToDescStrH.GetKeyId(DocNm); return DId!=-1;}
432    TStr GetDocNm(const int& DId) const {
433      if (DocNmToDescStrH.Empty()){return TInt::GetStr(DId);}
434      else {return DocNmToDescStrH.GetKey(DId);}}
435    bool IsDId(const int& DId) const {
436      return (0<=DId)&&(DId<DocSpVV.Len());}
437    int GetDId(const TStr& DocNm) const {
438      return DocNmToDescStrH.GetKeyId(DocNm);}
439    void GetAllDIdV(TIntV& DIdV) const;
440    int GetDocWIds(const int& DId) const {
441      return DocSpVV[DId]->GetWIds();}
442    void GetDocWIdFq(
443     const int& DId, const int& DocWIdN, int& WId, double& WordFq) const {
444      DocSpVV[DId]->GetWIdWgt(DocWIdN, WId, WordFq);}
445    int GetDocWIdN(const int& DId, const int& DocWId) const {
446      return DocSpVV[DId]->GetWId(DocWId);}
447    int GetDocWId(const int& DId, const int& DocWIdN) const {
448      return DocSpVV[DId]->GetWId(DocWIdN);}
449    void PutDocWFq(const int& DId, const int& DocWIdN, double& WordFq){
450      DocSpVV[DId]->GetWgt(DocWIdN)=sdouble(WordFq);}
451    double GetDocWFq(const int& DId, const int& DocWIdN) const {
452      return DocSpVV[DId]->GetWgt(DocWIdN);}
453    bool IsDocWordStr(const int& DId, const TStr& WordStr) const;
454    int GetDocCIds(const int& DId) const {
455      return DocCIdVV.Empty() ? 0 : DocCIdVV[DId].Len();}
456    int GetDocCId(const int& DId, const int& DocCIdN) const {
457      return DocCIdVV[DId][DocCIdN];}
458    bool IsCatInDoc(const int& DId, const int& CId) const {
459      return DocCIdVV[DId].IsIn(CId);}
460    void PutDocDescStr(const int& DId, const TStr& DocDescStr){
461      DocNmToDescStrH[DId]=DocDescStr;}
462    TStr GetDocDescStr(const int& DId) const {
463      return DocNmToDescStrH[DId];}
464    void PutDateStr(const int& DId, const TStr& DateStr){
465      PutDocDescStr(DId, DateStr);}
466    TStr GetDateStr(const int& DId) const {
467      return GetDocDescStr(DId);}
468    bool IsCats() const {return GetCats()>0;}
469    int GetCats() const {return CatNmToFqH.Len();}
470    bool IsCatNm(const TStr& CatNm) const {
471      return CatNmToFqH.IsKey(CatNm);}
472    bool IsCatNm(const TStr& CatNm, int& CId) const {
473      return CatNmToFqH.IsKey(CatNm, CId);}
474    bool IsCId(const int& CId) const {
475      return CatNmToFqH.IsKeyId(CId);}
476    int GetCId(const TStr& CatNm) const {
477      return CatNmToFqH.GetKeyId(CatNm);}
478    TStr GetCatNm(const int& CId) const {
479      return CatNmToFqH.GetKey(CId);}
480    int GetCatFq(const int& CId) const {
481      return CatNmToFqH[CId];}
482    void GetTopCatV(const int& TopCats, TIntStrPrV& FqCatNmPrV) const;
483    void AddDocCId(const int& DId, const int& CId){
484      CatNmToFqH[CId]++; DocCIdVV[DId].AddUnique(CId);}
485    int AddCatNm(const TStr& CatNm){
486      return CatNmToFqH.AddKey(CatNm);}
487    void PutTrainDIdV(const TIntV& DIdV){TrainDIdV=DIdV;}
488    void PutTestDIdV(const TIntV& DIdV){TestDIdV=DIdV;}
489    void PutTrainDocNmV(const TStrV& DocNmV){
490      TrainDIdV.Gen(DocNmV.Len(), 0);
491      for (int DocNmN=0; DocNmN<DocNmV.Len(); DocNmN++){
492        TrainDIdV.Add(GetDId(DocNmV[DocNmN]));}}
493    void PutTestDocNmV(const TStrV& DocNmV){
494      TestDIdV.Gen(DocNmV.Len(), 0);
495      for (int DocNmN=0; DocNmN<DocNmV.Len(); DocNmN++){
496        TestDIdV.Add(GetDId(DocNmV[DocNmN]));}}
497    void AddTrainDId(const int& DId){TrainDIdV.Add(DId);}
498    int GetTrainDocs() const {return TrainDIdV.Len();}
499    int GetTrainDId(const int& DIdN) const {return TrainDIdV[DIdN];}
500    void GetTrainDIdV(TIntV& _TrainDIdV){_TrainDIdV=TrainDIdV;}
501    void AddTestDId(const int& DId){TestDIdV.Add(DId);}
502    int GetTestDocs() const {return TestDIdV.Len();}
503    int GetTestDId(const int& DIdN) const {return TestDIdV[DIdN];}
504    void GetTestDIdV(TIntV& _TestDIdV){_TestDIdV=TestDIdV;}
505    void SetHOTrainTestDIdV(const double& TestDocsPrc, TRnd& Rnd);
506    void SetCVTrainTestDIdV(const int& Folds, const int& FoldN, TRnd& Rnd);
507    void GetAbsSampleDIdV(const int& Docs, TRnd& Rnd, TIntV& DIdV) const {
508      GetAllDIdV(DIdV); DIdV.Shuffle(Rnd); DIdV.Trunc(Docs);}
509    void GetRelSampleDIdV(const double& DocsPrc, TRnd& Rnd, TIntV& DIdV) const {
510      IAssert((0<=DocsPrc)&&(DocsPrc<=1));
511      int Docs=int(DocsPrc*GetDocs()); GetAbsSampleDIdV(Docs, Rnd, DIdV);}
512    PBowDocBs GetLimWordRelFqDocBs(
513     const double& MnWordFqPrc, const double& MxWordFqPrc) const;
514    PBowDocBs GetLimWordAbsFqDocBs(const int& MnWordFq) const;
515    PBowDocBs GetSubDocSet(const TIntV& DIdV) const;
516    PBowDocBs GetInvDocBs() const;
517    PBowSpV GetSpVFromHtmlStr(
518     const TStr& HtmlStr, const PBowDocWgtBs& BowDocWgtBs=NULL) const;
519    PBowSpV GetSpVFromHtmlFile(
520     const TStr& HtmlFNm, const PBowDocWgtBs& BowDocWgtBs=NULL) const;
521    PBowSpV GetSpVFromWIdWgtPrV(
522     const TIntFltPrV& WIdWgtPrV, const PBowDocWgtBs& BowDocWgtBs=NULL) const;
523    void SaveTxtStat(const TStr& StatFNm, const bool& SaveWordsP=true,
524     const bool& SaveCatsP=true, const bool& SaveDocsP=true) const;
525    static const TStr BowDocBsFExt;
526    static PBowDocBs LoadBin(const TStr& FNm){
527      TFIn SIn(FNm); return Load(SIn);}
528    void SaveBin(const TStr& FNm) const {
529      TFOut SOut(FNm); Save(SOut);}
530    friend class TBowFl;
531  };
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-basic_regex.hpp</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-bowbs.h</div>
                <div class="column column_space"><pre><code>217     size_type  size()const
218     {
219        return this->m_expression_len;
220     }
221     int  status()const
222     {
223        return this->m_status;
</pre></code></div>
                <div class="column column_space"><pre><code>151    TBowSimMtx& operator=(const TBowSimMtx&){Fail; return *this;}
152    int GetDocs() const {return MtxDIdV.Len();}
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    