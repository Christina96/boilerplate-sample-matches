
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 2.3872679045092835%, Tokens: 9</h2>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-online_reps.cpp</h3>
            <pre><code>1  #include <nano/node/nodeconfig.hpp>
2  #include <nano/node/online_reps.hpp>
3  #include <nano/secure/ledger.hpp>
4  #include <nano/secure/store.hpp>
5  nano::online_reps::online_reps (nano::ledger & ledger_a, nano::node_config const & config_a) :
6  	ledger{ ledger_a },
7  	config{ config_a }
8  {
9  	if (!ledger.store.init_error ())
10  	{
11  		auto transaction (ledger.store.tx_begin_read ());
12  		trended_m = calculate_trend (transaction);
13  	}
14  }
15  void nano::online_reps::observe (nano::account const & rep_a)
16  {
17  	if (ledger.weight (rep_a) > 0)
18  	{
19  		nano::lock_guard<nano::mutex> lock{ mutex };
20  		auto now = std::chrono::steady_clock::now ();
21  		auto new_insert = reps.get<tag_account> ().erase (rep_a) == 0;
22  		reps.insert ({ now, rep_a });
23  		auto cutoff = reps.get<tag_time> ().lower_bound (now - std::chrono::seconds (config.network_params.node.weight_period));
24  		auto trimmed = reps.get<tag_time> ().begin () != cutoff;
25  		reps.get<tag_time> ().erase (reps.get<tag_time> ().begin (), cutoff);
26  		if (new_insert || trimmed)
27  		{
28  			online_m = calculate_online ();
29  		}
30  	}
31  }
32  void nano::online_reps::sample ()
33  {
34  	nano::unique_lock<nano::mutex> lock{ mutex };
35  	nano::uint128_t online_l = online_m;
36  	lock.unlock ();
37  	nano::uint128_t trend_l;
38  	{
39  		auto transaction (ledger.store.tx_begin_write ({ tables::online_weight }));
40  		while (ledger.store.online_weight.count (transaction) >= config.network_params.node.max_weight_samples)
41  		{
42  			auto oldest (ledger.store.online_weight.begin (transaction));
43  			debug_assert (oldest != ledger.store.online_weight.end ());
44  			ledger.store.online_weight.del (transaction, oldest->first);
45  		}
46  		ledger.store.online_weight.put (transaction, std::chrono::system_clock::now ().time_since_epoch ().count (), online_l);
47  		trend_l = calculate_trend (transaction);
48  	}
49  	lock.lock ();
50  	trended_m = trend_l;
51  }
52  nano::uint128_t nano::online_reps::calculate_online () const
53  {
54  	nano::uint128_t current;
55  	for (auto & i : reps)
56  	{
57  		current += ledger.weight (i.account);
58  	}
59  	return current;
60  }
61  nano::uint128_t nano::online_reps::calculate_trend (nano::transaction & transaction_a) const
62  {
63  	std::vector<nano::uint128_t> items;
64  	items.reserve (config.network_params.node.max_weight_samples + 1);
65  	items.push_back (config.online_weight_minimum.number ());
66  	for (auto i (ledger.store.online_weight.begin (transaction_a)), n (ledger.store.online_weight.end ()); i != n; ++i)
67  	{
68  		items.push_back (i->second.number ());
69  	}
70  	nano::uint128_t result;
71  	auto median_idx = items.size () / 2;
72  	nth_element (items.begin (), items.begin () + median_idx, items.end ());
73  	result = items[median_idx];
74  	return result;
75  }
76  nano::uint128_t nano::online_reps::trended () const
77  {
78  	nano::lock_guard<nano::mutex> lock{ mutex };
79  	return trended_m;
80  }
81  nano::uint128_t nano::online_reps::online () const
82  {
83  	nano::lock_guard<nano::mutex> lock{ mutex };
84  	return online_m;
85  }
86  nano::uint128_t nano::online_reps::delta () const
87  {
88  	nano::lock_guard<nano::mutex> lock{ mutex };
89  	auto weight = static_cast<nano::uint256_t> (std::max ({ online_m, trended_m, config.online_weight_minimum.number () }));
90  	return ((weight * online_weight_quorum) / 100).convert_to<nano::uint128_t> ();
91  }
92  std::vector<nano::account> nano::online_reps::list ()
93  {
94  	std::vector<nano::account> result;
95  	nano::lock_guard<nano::mutex> lock{ mutex };
96  	std::for_each (reps.begin (), reps.end (), [&result] (rep_info const & info_a) { result.push_back (info_a.account); });
97  	return result;
98  }
99  void nano::online_reps::clear ()
100  {
101  	nano::lock_guard<nano::mutex> lock{ mutex };
102  	reps.clear ();
103  	online_m = 0;
104  }
105  std::unique_ptr<nano::container_info_component> nano::collect_container_info (online_reps & online_reps, std::string const & name)
106  {
107  	std::size_t count;
108  	{
109  		nano::lock_guard<nano::mutex> guard{ online_reps.mutex };
110  		count = online_reps.reps.size ();
111  	}
<span onclick='openModal()' class='match'>112  	auto sizeof_element = sizeof (decltype (online_reps.reps)::value_type);
113  	auto composite = std::make_unique<container_info_composite> (name);
114  	composite->add_component (std::make_unique<container_info_leaf> (container_info{ "reps", count, sizeof_element }));
115  	return composite;
116  }
</span></code></pre>
        </div>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-common_12.cpp</h3>
            <pre><code>1  #include <nano/crypto_lib/random_pool.hpp>
2  #include <nano/lib/config.hpp>
3  #include <nano/lib/numbers.hpp>
4  #include <nano/lib/timer.hpp>
5  #include <nano/secure/common.hpp>
6  #include <nano/secure/store.hpp>
7  #include <boost/endian/conversion.hpp>
8  #include <boost/property_tree/json_parser.hpp>
9  #include <boost/variant/get.hpp>
10  #include <limits>
11  #include <queue>
12  #include <crypto/ed25519-donna/ed25519.h>
13  #include <cryptopp/words.h>
14  size_t constexpr nano::send_block::size;
15  size_t constexpr nano::receive_block::size;
16  size_t constexpr nano::open_block::size;
17  size_t constexpr nano::change_block::size;
18  size_t constexpr nano::state_block::size;
19  nano::networks nano::network_constants::active_network = nano::networks::ACTIVE_NETWORK;
20  namespace
21  {
22  char const * dev_private_key_data = "34F0A37AAD20F4A260F0A5B3CB3D7FB50673212263E58A380BC10474BB039CE4";
23  char const * dev_public_key_data = "B0311EA55708D6A53C75CDBF88300259C6D018522FE3D4D0A242E431F9E8B6D0"; 
24  char const * beta_public_key_data = "259A43ABDB779E97452E188BA3EB951B41C961D3318CA6B925380F4D99F0577A"; 
25  char const * live_public_key_data = "E89208DD038FBB269987689621D52292AE9C35941A7484756ECCED92A65093BA"; 
26  std::string const test_public_key_data = nano::get_env_or_default ("NANO_TEST_GENESIS_PUB", "45C6FF9D1706D61F0821327752671BDA9F9ED2DA40326B01935AB566FB9E08ED"); 
27  char const * dev_genesis_data = R"%%%({
28  	"type": "open",
29  	"source": "B0311EA55708D6A53C75CDBF88300259C6D018522FE3D4D0A242E431F9E8B6D0",
30  	"representative": "xrb_3e3j5tkog48pnny9dmfzj1r16pg8t1e76dz5tmac6iq689wyjfpiij4txtdo",
31  	"account": "xrb_3e3j5tkog48pnny9dmfzj1r16pg8t1e76dz5tmac6iq689wyjfpiij4txtdo",
32  	"work": "7b42a00ee91d5810",
33  	"signature": "ECDA914373A2F0CA1296475BAEE40500A7F0A7AD72A5A80C81D7FAB7F6C802B2CC7DB50F5DD0FB25B2EF11761FA7344A158DD5A700B21BD47DE5BD0F63153A02"
34      })%%%";
35  char const * beta_genesis_data = R"%%%({
36  	"type": "open",
37  	"source": "259A43ABDB779E97452E188BA3EB951B41C961D3318CA6B925380F4D99F0577A",
38  	"representative": "nano_1betagoxpxwykx4kw86dnhosc8t3s7ix8eeentwkcg1hbpez1outjrcyg4n1",
39  	"account": "nano_1betagoxpxwykx4kw86dnhosc8t3s7ix8eeentwkcg1hbpez1outjrcyg4n1",
40  	"work": "79d4e27dc873c6f2",
41  	"signature": "4BD7F96F9ED2721BCEE5EAED400EA50AD00524C629AE55E9AFF11220D2C1B00C3D4B3BB770BF67D4F8658023B677F91110193B6C101C2666931F57046A6DB806"
42      })%%%";
43  char const * live_genesis_data = R"%%%({
44  	"type": "open",
45  	"source": "E89208DD038FBB269987689621D52292AE9C35941A7484756ECCED92A65093BA",
46  	"representative": "xrb_3t6k35gi95xu6tergt6p69ck76ogmitsa8mnijtpxm9fkcm736xtoncuohr3",
47  	"account": "xrb_3t6k35gi95xu6tergt6p69ck76ogmitsa8mnijtpxm9fkcm736xtoncuohr3",
48  	"work": "62f05417dd3fb691",
49  	"signature": "9F0C933C8ADE004D808EA1985FA746A7E95BA2A38F867640F53EC8F180BDFE9E2C1268DEAD7C2664F356E37ABA362BC58E46DBA03E523A7B5A19E4B6EB12BB02"
50      })%%%";
51  std::string const test_genesis_data = nano::get_env_or_default ("NANO_TEST_GENESIS_BLOCK", R"%%%({
52  	"type": "open",
53  	"source": "45C6FF9D1706D61F0821327752671BDA9F9ED2DA40326B01935AB566FB9E08ED",
54  	"representative": "nano_1jg8zygjg3pp5w644emqcbmjqpnzmubfni3kfe1s8pooeuxsw49fdq1mco9j",
55  	"account": "nano_1jg8zygjg3pp5w644emqcbmjqpnzmubfni3kfe1s8pooeuxsw49fdq1mco9j",
56  	"work": "bc1ef279c1a34eb1",
57  	"signature": "15049467CAEE3EC768639E8E35792399B6078DA763DA4EBA8ECAD33B0EDC4AF2E7403893A5A602EB89B978DABEF1D6606BB00F3C0EE11449232B143B6E07170E"
58      })%%%");
59  std::shared_ptr<nano::block> parse_block_from_genesis_data (std::string const & genesis_data_a)
60  {
61  	boost::property_tree::ptree tree;
62  	std::stringstream istream (genesis_data_a);
63  	boost::property_tree::read_json (istream, tree);
64  	return nano::deserialize_block_json (tree);
65  }
66  char const * beta_canary_public_key_data = "868C6A9F79D4506E029B378262B91538C5CB26D7C346B63902FFEB365F1C1947"; 
67  char const * live_canary_public_key_data = "7CBAF192A3763DAEC9F9BAC1B2CDF665D8369F8400B4BC5AB4BA31C00BAA4404"; 
68  std::string const test_canary_public_key_data = nano::get_env_or_default ("NANO_TEST_CANARY_PUB", "3BAD2C554ACE05F5E528FBBCE79D51E552C55FA765CCFD89B289C4835DE5F04A"); 
69  }
70  nano::keypair nano::dev::genesis_key{ dev_private_key_data };
71  nano::network_params nano::dev::network_params{ nano::networks::nano_dev_network };
72  nano::ledger_constants & nano::dev::constants{ nano::dev::network_params.ledger };
73  std::shared_ptr<nano::block> & nano::dev::genesis = nano::dev::constants.genesis;
74  nano::network_params::network_params (nano::networks network_a) :
75  	work{ network_a == nano::networks::nano_live_network ? nano::work_thresholds::publish_full : network_a == nano::networks::nano_beta_network ? nano::work_thresholds::publish_beta
76  		: network_a == nano::networks::nano_test_network                                                                                        ? nano::work_thresholds::publish_test
77  																																				: nano::work_thresholds::publish_dev },
78  	network{ work, network_a },
79  	ledger{ work, network_a },
80  	voting{ network },
81  	node{ network },
82  	portmapping{ network },
83  	bootstrap{ network }
84  {
85  	unsigned constexpr kdf_full_work = 64 * 1024;
86  	unsigned constexpr kdf_dev_work = 8;
87  	kdf_work = network.is_dev_network () ? kdf_dev_work : kdf_full_work;
88  }
89  nano::ledger_constants::ledger_constants (nano::work_thresholds & work, nano::networks network_a) :
90  	work{ work },
91  	zero_key ("0"),
92  	nano_beta_account (beta_public_key_data),
93  	nano_live_account (live_public_key_data),
94  	nano_test_account (test_public_key_data),
95  	nano_dev_genesis (parse_block_from_genesis_data (dev_genesis_data)),
96  	nano_beta_genesis (parse_block_from_genesis_data (beta_genesis_data)),
97  	nano_live_genesis (parse_block_from_genesis_data (live_genesis_data)),
98  	nano_test_genesis (parse_block_from_genesis_data (test_genesis_data)),
99  	genesis (network_a == nano::networks::nano_dev_network ? nano_dev_genesis : network_a == nano::networks::nano_beta_network ? nano_beta_genesis
100  	: network_a == nano::networks::nano_test_network                                                                           ? nano_test_genesis
101  																															   : nano_live_genesis),
102  	genesis_amount{ std::numeric_limits<nano::uint128_t>::max () },
103  	burn_account{},
104  	nano_dev_final_votes_canary_account (dev_public_key_data),
105  	nano_beta_final_votes_canary_account (beta_canary_public_key_data),
106  	nano_live_final_votes_canary_account (live_canary_public_key_data),
107  	nano_test_final_votes_canary_account (test_canary_public_key_data),
108  	final_votes_canary_account (network_a == nano::networks::nano_dev_network ? nano_dev_final_votes_canary_account : network_a == nano::networks::nano_beta_network ? nano_beta_final_votes_canary_account
109  	: network_a == nano::networks::nano_test_network                                                                                                                 ? nano_test_final_votes_canary_account
110  																																									 : nano_live_final_votes_canary_account),
111  	nano_dev_final_votes_canary_height (1),
112  	nano_beta_final_votes_canary_height (1),
113  	nano_live_final_votes_canary_height (1),
114  	nano_test_final_votes_canary_height (1),
115  	final_votes_canary_height (network_a == nano::networks::nano_dev_network ? nano_dev_final_votes_canary_height : network_a == nano::networks::nano_beta_network ? nano_beta_final_votes_canary_height
116  	: network_a == nano::networks::nano_test_network                                                                                                               ? nano_test_final_votes_canary_height
117  																																								   : nano_live_final_votes_canary_height)
118  {
119  	nano_beta_genesis->sideband_set (nano::block_sideband (nano_beta_genesis->account (), 0, std::numeric_limits<nano::uint128_t>::max (), 1, nano::seconds_since_epoch (), nano::epoch::epoch_0, false, false, false, nano::epoch::epoch_0));
120  	nano_dev_genesis->sideband_set (nano::block_sideband (nano_dev_genesis->account (), 0, std::numeric_limits<nano::uint128_t>::max (), 1, nano::seconds_since_epoch (), nano::epoch::epoch_0, false, false, false, nano::epoch::epoch_0));
121  	nano_live_genesis->sideband_set (nano::block_sideband (nano_live_genesis->account (), 0, std::numeric_limits<nano::uint128_t>::max (), 1, nano::seconds_since_epoch (), nano::epoch::epoch_0, false, false, false, nano::epoch::epoch_0));
122  	nano_test_genesis->sideband_set (nano::block_sideband (nano_test_genesis->account (), 0, std::numeric_limits<nano::uint128_t>::max (), 1, nano::seconds_since_epoch (), nano::epoch::epoch_0, false, false, false, nano::epoch::epoch_0));
123  	nano::link epoch_link_v1;
124  	char const * epoch_message_v1 ("epoch v1 block");
125  	strncpy ((char *)epoch_link_v1.bytes.data (), epoch_message_v1, epoch_link_v1.bytes.size ());
126  	epochs.add (nano::epoch::epoch_1, genesis->account (), epoch_link_v1);
127  	nano::link epoch_link_v2;
128  	nano::account nano_live_epoch_v2_signer;
129  	auto error (nano_live_epoch_v2_signer.decode_account ("nano_3qb6o6i1tkzr6jwr5s7eehfxwg9x6eemitdinbpi7u8bjjwsgqfj4wzser3x"));
130  	debug_assert (!error);
131  	auto epoch_v2_signer (network_a == nano::networks::nano_dev_network ? nano::dev::genesis_key.pub : network_a == nano::networks::nano_beta_network ? nano_beta_account
132  	: network_a == nano::networks::nano_test_network                                                                                                  ? nano_test_account
133  																																					  : nano_live_epoch_v2_signer);
134  	char const * epoch_message_v2 ("epoch v2 block");
135  	strncpy ((char *)epoch_link_v2.bytes.data (), epoch_message_v2, epoch_link_v2.bytes.size ());
136  	epochs.add (nano::epoch::epoch_2, epoch_v2_signer, epoch_link_v2);
137  }
138  nano::hardened_constants & nano::hardened_constants::get ()
139  {
140  	static hardened_constants instance{};
141  	return instance;
142  }
143  nano::hardened_constants::hardened_constants () :
144  	not_an_account{},
145  	random_128{}
146  {
147  	nano::random_pool::generate_block (not_an_account.bytes.data (), not_an_account.bytes.size ());
148  	nano::random_pool::generate_block (random_128.bytes.data (), random_128.bytes.size ());
149  }
150  nano::node_constants::node_constants (nano::network_constants & network_constants)
151  {
152  	backup_interval = std::chrono::minutes (5);
153  	search_pending_interval = network_constants.is_dev_network () ? std::chrono::seconds (1) : std::chrono::seconds (5 * 60);
154  	unchecked_cleaning_interval = std::chrono::minutes (30);
155  	process_confirmed_interval = network_constants.is_dev_network () ? std::chrono::milliseconds (50) : std::chrono::milliseconds (500);
156  	max_weight_samples = (network_constants.is_live_network () || network_constants.is_test_network ()) ? 4032 : 288;
157  	weight_period = 5 * 60; 
158  }
159  nano::voting_constants::voting_constants (nano::network_constants & network_constants) :
160  	max_cache{ network_constants.is_dev_network () ? 256U : 128U * 1024 },
161  	delay{ network_constants.is_dev_network () ? 1 : 15 }
162  {
163  }
164  nano::portmapping_constants::portmapping_constants (nano::network_constants & network_constants)
165  {
166  	lease_duration = std::chrono::seconds (1787); 
167  	health_check_period = std::chrono::seconds (53);
168  }
169  nano::bootstrap_constants::bootstrap_constants (nano::network_constants & network_constants)
170  {
171  	lazy_max_pull_blocks = network_constants.is_dev_network () ? 2 : 512;
172  	lazy_min_pull_blocks = network_constants.is_dev_network () ? 1 : 32;
173  	frontier_retry_limit = network_constants.is_dev_network () ? 2 : 16;
174  	lazy_retry_limit = network_constants.is_dev_network () ? 2 : frontier_retry_limit * 4;
175  	lazy_destinations_retry_limit = network_constants.is_dev_network () ? 1 : frontier_retry_limit / 4;
176  	gap_cache_bootstrap_start_interval = network_constants.is_dev_network () ? std::chrono::milliseconds (5) : std::chrono::milliseconds (30 * 1000);
177  	default_frontiers_age_seconds = network_constants.is_dev_network () ? 1 : 24 * 60 * 60; 
178  }
179  nano::keypair::keypair ()
180  {
181  	random_pool::generate_block (prv.bytes.data (), prv.bytes.size ());
182  	ed25519_publickey (prv.bytes.data (), pub.bytes.data ());
183  }
184  nano::keypair::keypair (nano::raw_key && prv_a) :
185  	prv (std::move (prv_a))
186  {
187  	ed25519_publickey (prv.bytes.data (), pub.bytes.data ());
188  }
189  nano::keypair::keypair (std::string const & prv_a)
190  {
191  	[[maybe_unused]] auto error (prv.decode_hex (prv_a));
192  	debug_assert (!error);
193  	ed25519_publickey (prv.bytes.data (), pub.bytes.data ());
194  }
195  nano::account_info::account_info (nano::block_hash const & head_a, nano::account const & representative_a, nano::block_hash const & open_block_a, nano::amount const & balance_a, nano::seconds_t modified_a, uint64_t block_count_a, nano::epoch epoch_a) :
196  	head (head_a),
197  	representative (representative_a),
198  	open_block (open_block_a),
199  	balance (balance_a),
200  	modified (modified_a),
201  	block_count (block_count_a),
202  	epoch_m (epoch_a)
203  {
204  }
205  bool nano::account_info::deserialize (nano::stream & stream_a)
206  {
207  	auto error (false);
208  	try
209  	{
210  		nano::read (stream_a, head.bytes);
211  		nano::read (stream_a, representative.bytes);
212  		nano::read (stream_a, open_block.bytes);
213  		nano::read (stream_a, balance.bytes);
214  		nano::read (stream_a, modified);
215  		nano::read (stream_a, block_count);
216  		nano::read (stream_a, epoch_m);
217  	}
218  	catch (std::runtime_error const &)
219  	{
220  		error = true;
221  	}
222  	return error;
223  }
224  bool nano::account_info::operator== (nano::account_info const & other_a) const
225  {
226  	return head == other_a.head && representative == other_a.representative && open_block == other_a.open_block && balance == other_a.balance && modified == other_a.modified && block_count == other_a.block_count && epoch () == other_a.epoch ();
227  }
228  bool nano::account_info::operator!= (nano::account_info const & other_a) const
229  {
230  	return !(*this == other_a);
231  }
232  size_t nano::account_info::db_size () const
233  {
234  	debug_assert (reinterpret_cast<uint8_t const *> (this) == reinterpret_cast<uint8_t const *> (&head));
235  	debug_assert (reinterpret_cast<uint8_t const *> (&head) + sizeof (head) == reinterpret_cast<uint8_t const *> (&representative));
236  	debug_assert (reinterpret_cast<uint8_t const *> (&representative) + sizeof (representative) == reinterpret_cast<uint8_t const *> (&open_block));
237  	debug_assert (reinterpret_cast<uint8_t const *> (&open_block) + sizeof (open_block) == reinterpret_cast<uint8_t const *> (&balance));
238  	debug_assert (reinterpret_cast<uint8_t const *> (&balance) + sizeof (balance) == reinterpret_cast<uint8_t const *> (&modified));
239  	debug_assert (reinterpret_cast<uint8_t const *> (&modified) + sizeof (modified) == reinterpret_cast<uint8_t const *> (&block_count));
240  	debug_assert (reinterpret_cast<uint8_t const *> (&block_count) + sizeof (block_count) == reinterpret_cast<uint8_t const *> (&epoch_m));
241  	return sizeof (head) + sizeof (representative) + sizeof (open_block) + sizeof (balance) + sizeof (modified) + sizeof (block_count) + sizeof (epoch_m);
242  }
243  nano::epoch nano::account_info::epoch () const
244  {
245  	return epoch_m;
246  }
247  nano::pending_info::pending_info (nano::account const & source_a, nano::amount const & amount_a, nano::epoch epoch_a) :
248  	source (source_a),
249  	amount (amount_a),
250  	epoch (epoch_a)
251  {
252  }
253  bool nano::pending_info::deserialize (nano::stream & stream_a)
254  {
255  	auto error (false);
256  	try
257  	{
258  		nano::read (stream_a, source.bytes);
259  		nano::read (stream_a, amount.bytes);
260  		nano::read (stream_a, epoch);
261  	}
262  	catch (std::runtime_error const &)
263  	{
264  		error = true;
265  	}
266  	return error;
267  }
268  size_t nano::pending_info::db_size () const
269  {
270  	return sizeof (source) + sizeof (amount) + sizeof (epoch);
271  }
272  bool nano::pending_info::operator== (nano::pending_info const & other_a) const
273  {
274  	return source == other_a.source && amount == other_a.amount && epoch == other_a.epoch;
275  }
276  nano::pending_key::pending_key (nano::account const & account_a, nano::block_hash const & hash_a) :
277  	account (account_a),
278  	hash (hash_a)
279  {
280  }
281  bool nano::pending_key::deserialize (nano::stream & stream_a)
282  {
283  	auto error (false);
284  	try
285  	{
286  		nano::read (stream_a, account.bytes);
287  		nano::read (stream_a, hash.bytes);
288  	}
289  	catch (std::runtime_error const &)
290  	{
291  		error = true;
292  	}
293  	return error;
294  }
295  bool nano::pending_key::operator== (nano::pending_key const & other_a) const
296  {
297  	return account == other_a.account && hash == other_a.hash;
298  }
299  nano::account const & nano::pending_key::key () const
300  {
301  	return account;
302  }
303  nano::unchecked_info::unchecked_info (std::shared_ptr<nano::block> const & block_a) :
304  	block (block_a),
305  	modified_m (nano::seconds_since_epoch ())
306  {
307  }
308  void nano::unchecked_info::serialize (nano::stream & stream_a) const
309  {
310  	debug_assert (block != nullptr);
311  	nano::serialize_block (stream_a, *block);
312  	nano::write (stream_a, modified_m);
313  }
314  bool nano::unchecked_info::deserialize (nano::stream & stream_a)
315  {
316  	block = nano::deserialize_block (stream_a);
317  	bool error (block == nullptr);
318  	if (!error)
319  	{
320  		try
321  		{
322  			nano::read (stream_a, modified_m);
323  		}
324  		catch (std::runtime_error const &)
325  		{
326  			error = true;
327  		}
328  	}
329  	return error;
330  }
331  uint64_t nano::unchecked_info::modified () const
332  {
333  	return modified_m;
334  }
335  nano::endpoint_key::endpoint_key (std::array<uint8_t, 16> const & address_a, uint16_t port_a) :
336  	address (address_a), network_port (boost::endian::native_to_big (port_a))
337  {
338  }
339  std::array<uint8_t, 16> const & nano::endpoint_key::address_bytes () const
340  {
341  	return address;
342  }
343  uint16_t nano::endpoint_key::port () const
344  {
345  	return boost::endian::big_to_native (network_port);
346  }
347  nano::confirmation_height_info::confirmation_height_info (uint64_t confirmation_height_a, nano::block_hash const & confirmed_frontier_a) :
348  	height (confirmation_height_a),
349  	frontier (confirmed_frontier_a)
350  {
351  }
352  void nano::confirmation_height_info::serialize (nano::stream & stream_a) const
353  {
354  	nano::write (stream_a, height);
355  	nano::write (stream_a, frontier);
356  }
357  bool nano::confirmation_height_info::deserialize (nano::stream & stream_a)
358  {
359  	auto error (false);
360  	try
361  	{
362  		nano::read (stream_a, height);
363  		nano::read (stream_a, frontier);
364  	}
365  	catch (std::runtime_error const &)
366  	{
367  		error = true;
368  	}
369  	return error;
370  }
371  nano::block_info::block_info (nano::account const & account_a, nano::amount const & balance_a) :
372  	account (account_a),
373  	balance (balance_a)
374  {
375  }
376  bool nano::vote::operator== (nano::vote const & other_a) const
377  {
378  	return timestamp_m == other_a.timestamp_m && hashes == other_a.hashes && account == other_a.account && signature == other_a.signature;
379  }
380  bool nano::vote::operator!= (nano::vote const & other_a) const
381  {
382  	return !(*this == other_a);
383  }
384  void nano::vote::serialize_json (boost::property_tree::ptree & tree) const
385  {
386  	tree.put ("account", account.to_account ());
387  	tree.put ("signature", signature.number ());
388  	tree.put ("sequence", std::to_string (timestamp ()));
389  	tree.put ("timestamp", std::to_string (timestamp ()));
390  	tree.put ("duration", std::to_string (duration_bits ()));
391  	boost::property_tree::ptree blocks_tree;
392  	for (auto const & hash : hashes)
393  	{
394  		boost::property_tree::ptree entry;
395  		entry.put ("", hash.to_string ());
396  		blocks_tree.push_back (std::make_pair ("", entry));
397  	}
398  	tree.add_child ("blocks", blocks_tree);
399  }
400  std::string nano::vote::to_json () const
401  {
402  	std::stringstream stream;
403  	boost::property_tree::ptree tree;
404  	serialize_json (tree);
405  	boost::property_tree::write_json (stream, tree);
406  	return stream.str ();
407  }
408  uint64_t nano::vote::timestamp () const
409  {
410  	return (timestamp_m == std::numeric_limits<uint64_t>::max ())
411  	? timestamp_m 
412  	: (timestamp_m & timestamp_mask);
413  }
414  uint8_t nano::vote::duration_bits () const
415  {
416  	auto result = timestamp_m & ~timestamp_mask;
417  	debug_assert (result < 16);
418  	return static_cast<uint8_t> (result);
419  }
420  std::chrono::milliseconds nano::vote::duration () const
421  {
422  	return std::chrono::milliseconds{ 1u << (duration_bits () + 4) };
423  }
424  nano::vote::vote (nano::vote const & other_a) :
425  	timestamp_m{ other_a.timestamp_m },
426  	hashes{ other_a.hashes },
427  	account (other_a.account),
428  	signature (other_a.signature)
429  {
430  }
431  nano::vote::vote (bool & error_a, nano::stream & stream_a)
432  {
433  	error_a = deserialize (stream_a);
434  }
435  nano::vote::vote (nano::account const & account_a, nano::raw_key const & prv_a, uint64_t timestamp_a, uint8_t duration, std::vector<nano::block_hash> const & hashes) :
436  	hashes{ hashes },
437  	timestamp_m{ packed_timestamp (timestamp_a, duration) },
438  	account (account_a)
439  {
440  	signature = nano::sign_message (prv_a, account_a, hash ());
441  }
442  std::string nano::vote::hashes_string () const
443  {
444  	std::string result;
445  	for (auto const & hash : hashes)
446  	{
447  		result += hash.to_string ();
448  		result += ", ";
449  	}
450  	return result;
451  }
452  std::string const nano::vote::hash_prefix = "vote ";
453  nano::block_hash nano::vote::hash () const
454  {
455  	nano::block_hash result;
456  	blake2b_state hash;
457  	blake2b_init (&hash, sizeof (result.bytes));
458  	blake2b_update (&hash, hash_prefix.data (), hash_prefix.size ());
459  	for (auto const & block_hash : hashes)
460  	{
461  		blake2b_update (&hash, block_hash.bytes.data (), sizeof (block_hash.bytes));
462  	}
463  	union
464  	{
465  		uint64_t qword;
466  		std::array<uint8_t, 8> bytes;
467  	};
468  	qword = timestamp_m;
469  	blake2b_update (&hash, bytes.data (), sizeof (bytes));
470  	blake2b_final (&hash, result.bytes.data (), sizeof (result.bytes));
471  	return result;
472  }
473  nano::block_hash nano::vote::full_hash () const
474  {
475  	nano::block_hash result;
476  	blake2b_state state;
477  	blake2b_init (&state, sizeof (result.bytes));
478  	blake2b_update (&state, hash ().bytes.data (), sizeof (hash ().bytes));
479  	blake2b_update (&state, account.bytes.data (), sizeof (account.bytes.data ()));
480  	blake2b_update (&state, signature.bytes.data (), sizeof (signature.bytes.data ()));
481  	blake2b_final (&state, result.bytes.data (), sizeof (result.bytes));
482  	return result;
483  }
484  void nano::vote::serialize (nano::stream & stream_a) const
485  {
486  	write (stream_a, account);
487  	write (stream_a, signature);
488  	write (stream_a, boost::endian::native_to_little (timestamp_m));
489  	for (auto const & hash : hashes)
490  	{
491  		write (stream_a, hash);
492  	}
493  }
494  bool nano::vote::deserialize (nano::stream & stream_a)
495  {
496  	auto error = false;
497  	try
498  	{
499  		nano::read (stream_a, account.bytes);
500  		nano::read (stream_a, signature.bytes);
501  		nano::read (stream_a, timestamp_m);
502  		while (stream_a.in_avail () > 0)
503  		{
504  			nano::block_hash block_hash;
505  			nano::read (stream_a, block_hash);
506  			hashes.push_back (block_hash);
507  		}
508  	}
509  	catch (std::runtime_error const &)
510  	{
511  		error = true;
512  	}
513  	return error;
514  }
515  bool nano::vote::validate () const
516  {
517  	return nano::validate_message (account, hash (), signature);
518  }
519  uint64_t nano::vote::packed_timestamp (uint64_t timestamp, uint8_t duration) const
520  {
521  	debug_assert (duration <= duration_max && "Invalid duration");
522  	debug_assert ((!(timestamp == timestamp_max) || (duration == duration_max)) && "Invalid final vote");
523  	return (timestamp & timestamp_mask) | duration;
524  }
525  nano::block_hash nano::iterate_vote_blocks_as_hash::operator() (nano::block_hash const & item) const
526  {
527  	return item;
528  }
529  nano::vote_uniquer::vote_uniquer (nano::block_uniquer & uniquer_a) :
530  	uniquer (uniquer_a)
531  {
532  }
533  std::shared_ptr<nano::vote> nano::vote_uniquer::unique (std::shared_ptr<nano::vote> const & vote_a)
534  {
535  	auto result = vote_a;
536  	if (result != nullptr)
537  	{
538  		nano::block_hash key = vote_a->full_hash ();
539  		nano::lock_guard<nano::mutex> lock{ mutex };
540  		auto & existing = votes[key];
541  		if (auto block_l = existing.lock ())
542  		{
543  			result = block_l;
544  		}
545  		else
546  		{
547  			existing = vote_a;
548  		}
549  		release_assert (std::numeric_limits<CryptoPP::word32>::max () > votes.size ());
550  		for (auto i (0); i < cleanup_count && !votes.empty (); ++i)
551  		{
552  			auto random_offset = nano::random_pool::generate_word32 (0, static_cast<CryptoPP::word32> (votes.size () - 1));
553  			auto existing (std::next (votes.begin (), random_offset));
554  			if (existing == votes.end ())
555  			{
556  				existing = votes.begin ();
557  			}
558  			if (existing != votes.end ())
559  			{
560  				if (auto block_l = existing->second.lock ())
561  				{
562  				}
563  				else
564  				{
565  					votes.erase (existing);
566  				}
567  			}
568  		}
569  	}
570  	return result;
571  }
572  size_t nano::vote_uniquer::size ()
573  {
574  	nano::lock_guard<nano::mutex> lock{ mutex };
575  	return votes.size ();
576  }
577  std::unique_ptr<nano::container_info_component> nano::collect_container_info (vote_uniquer & vote_uniquer, std::string const & name)
578  {
579  	auto count = vote_uniquer.size ();
<span onclick='openModal()' class='match'>580  	auto sizeof_element = sizeof (vote_uniquer::value_type);
581  	auto composite = std::make_unique<container_info_composite> (name);
582  	composite->add_component (std::make_unique<container_info_leaf> (container_info{ "votes", count, sizeof_element }));
583  	return composite;
584  }
</span>585  nano::wallet_id nano::random_wallet_id ()
586  {
587  	nano::wallet_id wallet_id;
588  	nano::uint256_union dummy_secret;
589  	random_pool::generate_block (dummy_secret.bytes.data (), dummy_secret.bytes.size ());
590  	ed25519_publickey (dummy_secret.bytes.data (), wallet_id.bytes.data ());
591  	return wallet_id;
592  }
593  nano::unchecked_key::unchecked_key (nano::hash_or_account const & dependency) :
594  	unchecked_key{ dependency, 0 }
595  {
596  }
597  nano::unchecked_key::unchecked_key (nano::hash_or_account const & previous_a, nano::block_hash const & hash_a) :
598  	previous (previous_a.as_block_hash ()),
599  	hash (hash_a)
600  {
601  }
602  nano::unchecked_key::unchecked_key (nano::uint512_union const & union_a) :
603  	previous (union_a.uint256s[0].number ()),
604  	hash (union_a.uint256s[1].number ())
605  {
606  }
607  bool nano::unchecked_key::deserialize (nano::stream & stream_a)
608  {
609  	auto error (false);
610  	try
611  	{
612  		nano::read (stream_a, previous.bytes);
613  		nano::read (stream_a, hash.bytes);
614  	}
615  	catch (std::runtime_error const &)
616  	{
617  		error = true;
618  	}
619  	return error;
620  }
621  bool nano::unchecked_key::operator== (nano::unchecked_key const & other_a) const
622  {
623  	return previous == other_a.previous && hash == other_a.hash;
624  }
625  bool nano::unchecked_key::operator< (nano::unchecked_key const & other_a) const
626  {
627  	return previous != other_a.previous ? previous < other_a.previous : hash < other_a.hash;
628  }
629  nano::block_hash const & nano::unchecked_key::key () const
630  {
631  	return previous;
632  }
633  void nano::generate_cache::enable_all ()
634  {
635  	reps = true;
636  	cemented_count = true;
637  	unchecked_count = true;
638  	account_count = true;
639  }
640  nano::stat::detail nano::to_stat_detail (nano::process_result process_result)
641  {
642  	switch (process_result)
643  	{
644  		case process_result::progress:
645  			return nano::stat::detail::progress;
646  		case process_result::bad_signature:
647  			return nano::stat::detail::bad_signature;
648  		case process_result::old:
649  			return nano::stat::detail::old;
650  		case process_result::negative_spend:
651  			return nano::stat::detail::negative_spend;
652  		case process_result::fork:
653  			return nano::stat::detail::fork;
654  		case process_result::unreceivable:
655  			return nano::stat::detail::unreceivable;
656  		case process_result::gap_previous:
657  			return nano::stat::detail::gap_previous;
658  		case process_result::gap_source:
659  			return nano::stat::detail::gap_source;
660  		case process_result::gap_epoch_open_pending:
661  			return nano::stat::detail::gap_epoch_open_pending;
662  		case process_result::opened_burn_account:
663  			return nano::stat::detail::opened_burn_account;
664  		case process_result::balance_mismatch:
665  			return nano::stat::detail::balance_mismatch;
666  		case process_result::representative_mismatch:
667  			return nano::stat::detail::representative_mismatch;
668  		case process_result::block_position:
669  			return nano::stat::detail::block_position;
670  		case process_result::insufficient_work:
671  			return nano::stat::detail::insufficient_work;
672  	}
673  	debug_assert (false && "There should be always a defined nano::stat::detail that is not _last");
674  	return nano::stat::detail::_last;
675  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-online_reps.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-common_12.cpp</div>
                </div>
                <div class="column column_space"><pre><code>112  	auto sizeof_element = sizeof (decltype (online_reps.reps)::value_type);
113  	auto composite = std::make_unique<container_info_composite> (name);
114  	composite->add_component (std::make_unique<container_info_leaf> (container_info{ "reps", count, sizeof_element }));
115  	return composite;
116  }
</pre></code></div>
                <div class="column column_space"><pre><code>580  	auto sizeof_element = sizeof (vote_uniquer::value_type);
581  	auto composite = std::make_unique<container_info_composite> (name);
582  	composite->add_component (std::make_unique<container_info_leaf> (container_info{ "votes", count, sizeof_element }));
583  	return composite;
584  }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    