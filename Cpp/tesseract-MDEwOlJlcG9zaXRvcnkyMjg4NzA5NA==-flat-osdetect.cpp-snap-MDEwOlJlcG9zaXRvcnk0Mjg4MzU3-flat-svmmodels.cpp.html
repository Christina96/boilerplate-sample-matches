
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 6.83477106834771%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-osdetect.cpp</h3>
            <pre><code>1  #include <tesseract/osdetect.h>
2  #include "blobbox.h"
3  #include "blread.h"
4  #include "colfind.h"
5  #include "fontinfo.h"
6  #include "imagefind.h"
7  #include "linefind.h"
8  #include "oldlist.h"
9  #include "qrsequence.h"
10  #include "ratngs.h"
11  #include "tabvector.h"
12  #include "tesseractclass.h"
13  #include "textord.h"
14  #include <algorithm>
15  #include <cmath> 
16  #include <memory>
17  namespace tesseract {
18  const float kSizeRatioToReject = 2.0;
19  const int kMinAcceptableBlobHeight = 10;
20  const float kScriptAcceptRatio = 1.3;
21  const float kHanRatioInKorean = 0.7;
22  const float kHanRatioInJapanese = 0.3;
23  const float kNonAmbiguousMargin = 1.0;
24  static const char *han_script = "Han";
25  static const char *latin_script = "Latin";
26  static const char *katakana_script = "Katakana";
27  static const char *hiragana_script = "Hiragana";
28  static const char *hangul_script = "Hangul";
29  const char *ScriptDetector::korean_script_ = "Korean";
30  const char *ScriptDetector::japanese_script_ = "Japanese";
31  const char *ScriptDetector::fraktur_script_ = "Fraktur";
32  void OSResults::update_best_orientation() {
33    float first = orientations[0];
34    float second = orientations[1];
35    best_result.orientation_id = 0;
36    if (orientations[0] < orientations[1]) {
37      first = orientations[1];
38      second = orientations[0];
39      best_result.orientation_id = 1;
40    }
41    for (int i = 2; i < 4; ++i) {
42      if (orientations[i] > first) {
43        second = first;
44        first = orientations[i];
45        best_result.orientation_id = i;
46      } else if (orientations[i] > second) {
47        second = orientations[i];
48      }
49    }
50    best_result.oconfidence = first - second;
51  }
52  void OSResults::set_best_orientation(int orientation_id) {
53    best_result.orientation_id = orientation_id;
54    best_result.oconfidence = 0;
55  }
56  void OSResults::update_best_script(int orientation) {
57    float first = scripts_na[orientation][1];
58    float second = scripts_na[orientation][2];
59    best_result.script_id = 1;
60    if (scripts_na[orientation][1] < scripts_na[orientation][2]) {
61      first = scripts_na[orientation][2];
62      second = scripts_na[orientation][1];
63      best_result.script_id = 2;
64    }
65    for (int i = 3; i < kMaxNumberOfScripts; ++i) {
66      if (scripts_na[orientation][i] > first) {
67        best_result.script_id = i;
68        second = first;
69        first = scripts_na[orientation][i];
70      } else if (scripts_na[orientation][i] > second) {
71        second = scripts_na[orientation][i];
72      }
73    }
74    best_result.sconfidence =
75        (second == 0.0f) ? 2.0f : (first / second - 1.0) / (kScriptAcceptRatio - 1.0);
76  }
77  int OSResults::get_best_script(int orientation_id) const {
78    int max_id = -1;
79    for (int j = 0; j < kMaxNumberOfScripts; ++j) {
80      const char *script = unicharset->get_script_from_script_id(j);
81      if (strcmp(script, "Common") && strcmp(script, "NULL")) {
82        if (max_id == -1 || scripts_na[orientation_id][j] > scripts_na[orientation_id][max_id]) {
83          max_id = j;
84        }
85      }
86    }
87    return max_id;
88  }
89  void OSResults::print_scores(void) const {
90    for (int i = 0; i < 4; ++i) {
91      tprintf("Orientation id #%d", i);
92      print_scores(i);
93    }
94  }
95  void OSResults::print_scores(int orientation_id) const {
96    for (int j = 0; j < kMaxNumberOfScripts; ++j) {
97      if (scripts_na[orientation_id][j]) {
98        tprintf("%12s\t: %f\n", unicharset->get_script_from_script_id(j),
99                scripts_na[orientation_id][j]);
100      }
101    }
102  }
103  void OSResults::accumulate(const OSResults &osr) {
104    for (int i = 0; i < 4; ++i) {
105      orientations[i] += osr.orientations[i];
106      for (int j = 0; j < kMaxNumberOfScripts; ++j) {
107        scripts_na[i][j] += osr.scripts_na[i][j];
108      }
109    }
110    unicharset = osr.unicharset;
111    update_best_orientation();
112    update_best_script(best_result.orientation_id);
113  }
114  static void remove_nontext_regions(tesseract::Tesseract *tess, BLOCK_LIST *blocks,
115                                     TO_BLOCK_LIST *to_blocks) {
116    Image pix = tess->pix_binary();
117    ASSERT_HOST(pix != nullptr);
118    int vertical_x = 0;
119    int vertical_y = 1;
120    tesseract::TabVector_LIST v_lines;
121    tesseract::TabVector_LIST h_lines;
122    int resolution;
123    if (kMinCredibleResolution > pixGetXRes(pix)) {
124      resolution = kMinCredibleResolution;
125      tprintf("Warning. Invalid resolution %d dpi. Using %d instead.\n", pixGetXRes(pix), resolution);
126    } else {
127      resolution = pixGetXRes(pix);
128    }
129    tesseract::LineFinder::FindAndRemoveLines(resolution, false, pix, &vertical_x, &vertical_y,
130                                              nullptr, &v_lines, &h_lines);
131    Image im_pix = tesseract::ImageFind::FindImages(pix, nullptr);
132    if (im_pix != nullptr) {
133      pixSubtract(pix, pix, im_pix);
134      im_pix.destroy();
135    }
136    tess->mutable_textord()->find_components(tess->pix_binary(), blocks, to_blocks);
137  }
138  int orientation_and_script_detection(const char *filename, OSResults *osr,
139                                       tesseract::Tesseract *tess) {
140    std::string name = filename; 
141    const char *lastdot = strrchr(name.c_str(), '.');
142    if (lastdot != nullptr) {
143      name[lastdot - name.c_str()] = '\0';
144    }
145    ASSERT_HOST(tess->pix_binary() != nullptr);
146    int width = pixGetWidth(tess->pix_binary());
147    int height = pixGetHeight(tess->pix_binary());
148    BLOCK_LIST blocks;
149    if (!read_unlv_file(name, width, height, &blocks)) {
150      FullPageBlock(width, height, &blocks);
151    }
152    TO_BLOCK_LIST land_blocks, port_blocks;
153    remove_nontext_regions(tess, &blocks, &port_blocks);
154    if (port_blocks.empty()) {
155      tess->mutable_textord()->find_components(tess->pix_binary(), &blocks, &port_blocks);
156    } else {
157      TBOX page_box(0, 0, width, height);
158      tess->mutable_textord()->filter_blobs(page_box.topright(), &port_blocks, true);
159    }
160    return os_detect(&port_blocks, osr, tess);
161  }
162  int os_detect(TO_BLOCK_LIST *port_blocks, OSResults *osr, tesseract::Tesseract *tess) {
163    int blobs_total = 0;
164    TO_BLOCK_IT block_it;
165    block_it.set_to_list(port_blocks);
166    BLOBNBOX_CLIST filtered_list;
167    BLOBNBOX_C_IT filtered_it(&filtered_list);
168    for (block_it.mark_cycle_pt(); !block_it.cycled_list(); block_it.forward()) {
169      TO_BLOCK *to_block = block_it.data();
170      if (to_block->block->pdblk.poly_block() && !to_block->block->pdblk.poly_block()->IsText()) {
171        continue;
172      }
173      BLOBNBOX_IT bbox_it;
174      bbox_it.set_to_list(&to_block->blobs);
175      for (bbox_it.mark_cycle_pt(); !bbox_it.cycled_list(); bbox_it.forward()) {
176        BLOBNBOX *bbox = bbox_it.data();
177        C_BLOB *blob = bbox->cblob();
178        TBOX box = blob->bounding_box();
179        ++blobs_total;
180        if (box.width() == 0) {
181          continue;
182        }
183        float y_x = std::fabs((box.height() * 1.0f) / box.width());
184        float x_y = 1.0f / y_x;
185        float ratio = x_y > y_x ? x_y : y_x;
186        if (ratio > kSizeRatioToReject) {
187          continue;
188        }
189        if (box.height() < kMinAcceptableBlobHeight) {
190          continue;
191        }
192        filtered_it.add_to_end(bbox);
193      }
194    }
195    return os_detect_blobs(nullptr, &filtered_list, osr, tess);
196  }
197  int os_detect_blobs(const std::vector<int> *allowed_scripts, BLOBNBOX_CLIST *blob_list,
198                      OSResults *osr, tesseract::Tesseract *tess) {
199    OSResults osr_;
200    int minCharactersToTry = tess->min_characters_to_try;
201    int maxCharactersToTry = 5 * minCharactersToTry;
202    if (osr == nullptr) {
203      osr = &osr_;
204    }
205    osr->unicharset = &tess->unicharset;
206    OrientationDetector o(allowed_scripts, osr);
207    ScriptDetector s(allowed_scripts, osr, tess);
208    BLOBNBOX_C_IT filtered_it(blob_list);
209    int real_max = std::min(filtered_it.length(), maxCharactersToTry);
210    if (real_max < minCharactersToTry / 2) {
211      tprintf("Too few characters. Skipping this page\n");
212      return 0;
213    }
214    auto **blobs = new BLOBNBOX *[filtered_it.length()];
215    int number_of_blobs = 0;
216    for (filtered_it.mark_cycle_pt(); !filtered_it.cycled_list(); filtered_it.forward()) {
217      blobs[number_of_blobs++] = filtered_it.data();
218    }
219    QRSequenceGenerator sequence(number_of_blobs);
220    int num_blobs_evaluated = 0;
221    for (int i = 0; i < real_max; ++i) {
222      if (os_detect_blob(blobs[sequence.GetVal()], &o, &s, osr, tess) && i > minCharactersToTry) {
223        break;
224      }
225      ++num_blobs_evaluated;
226    }
227    delete[] blobs;
228    int orientation = o.get_orientation();
229    osr->update_best_script(orientation);
230    return num_blobs_evaluated;
231  }
232  bool os_detect_blob(BLOBNBOX *bbox, OrientationDetector *o, ScriptDetector *s, OSResults *osr,
233                      tesseract::Tesseract *tess) {
234    tess->tess_cn_matching.set_value(true); 
235    tess->tess_bn_matching.set_value(false);
236    C_BLOB *blob = bbox->cblob();
237    TBLOB *tblob = TBLOB::PolygonalCopy(tess->poly_allow_detailed_fx, blob);
238    TBOX box = tblob->bounding_box();
239    FCOORD current_rotation(1.0f, 0.0f);
240    FCOORD rotation90(0.0f, 1.0f);
241    BLOB_CHOICE_LIST ratings[4];
242    for (int i = 0; i < 4; ++i) {
243      float scaling = static_cast<float>(kBlnXHeight) / box.height();
244      float x_origin = (box.left() + box.right()) / 2.0f;
245      float y_origin = (box.bottom() + box.top()) / 2.0f;
246      if (i == 0 || i == 2) {
247        y_origin = i == 0 ? box.bottom() : box.top();
248      } else {
249        scaling = static_cast<float>(kBlnXHeight) / box.width();
250        x_origin = i == 1 ? box.left() : box.right();
251      }
252      std::unique_ptr<TBLOB> rotated_blob(new TBLOB(*tblob));
253      rotated_blob->Normalize(nullptr, &current_rotation, nullptr, x_origin, y_origin, scaling,
254                              scaling, 0.0f, static_cast<float>(kBlnBaselineOffset), false, nullptr);
255      tess->AdaptiveClassifier(rotated_blob.get(), ratings + i);
256      current_rotation.rotate(rotation90);
257    }
258    delete tblob;
259    bool stop = o->detect_blob(ratings);
260    s->detect_blob(ratings);
261    int orientation = o->get_orientation();
262    stop = s->must_stop(orientation) && stop;
263    return stop;
264  }
265  OrientationDetector::OrientationDetector(const std::vector<int> *allowed_scripts, OSResults *osr) {
266    osr_ = osr;
267    allowed_scripts_ = allowed_scripts;
268  }
269  bool OrientationDetector::detect_blob(BLOB_CHOICE_LIST *scores) {
270    float blob_o_score[4] = {0.0f, 0.0f, 0.0f, 0.0f};
271    float total_blob_o_score = 0.0f;
272    for (int i = 0; i < 4; ++i) {
273      BLOB_CHOICE_IT choice_it(scores + i);
274      if (!choice_it.empty()) {
275        BLOB_CHOICE *choice = nullptr;
276        if (allowed_scripts_ != nullptr && !allowed_scripts_->empty()) {
277          for (choice_it.mark_cycle_pt(); !choice_it.cycled_list() && choice == nullptr;
278               choice_it.forward()) {
279            int choice_script = choice_it.data()->script_id();
280            unsigned s = 0;
281            for (s = 0; s < allowed_scripts_->size(); ++s) {
282              if ((*allowed_scripts_)[s] == choice_script) {
283                choice = choice_it.data();
284                break;
285              }
286            }
287          }
288        } else {
289          choice = choice_it.data();
290        }
291        if (choice != nullptr) {
292          blob_o_score[i] = 1 + 0.05 * choice->certainty();
293          total_blob_o_score += blob_o_score[i];
294        }
295      }
296    }
297    if (total_blob_o_score == 0.0) {
298      return false;
299    }
300    float worst_score = 0.0f;
301    int num_good_scores = 0;
302    for (float f : blob_o_score) {
303      if (f > 0.0f) {
304        ++num_good_scores;
305        if (worst_score == 0.0f || f < worst_score) {
306          worst_score = f;
307        }
308      }
309    }
310    if (num_good_scores == 1) {
311      worst_score /= 2.0f;
312    }
313    for (float &f : blob_o_score) {
<span onclick='openModal()' class='match'>314      if (f == 0.0f) {
315        f = worst_score;
316        total_blob_o_score += worst_score;
317      }
318    }
319    for (int i = 0; total_blob_o_score != 0 && i < 4; ++i) {
</span>320      osr_->orientations[i] += std::log(blob_o_score[i] / total_blob_o_score);
321    }
322    return false;
323  }
324  int OrientationDetector::get_orientation() {
325    osr_->update_best_orientation();
326    return osr_->best_result.orientation_id;
327  }
328  ScriptDetector::ScriptDetector(const std::vector<int> *allowed_scripts, OSResults *osr,
329                                 tesseract::Tesseract *tess) {
330    osr_ = osr;
331    tess_ = tess;
332    allowed_scripts_ = allowed_scripts;
333    katakana_id_ = tess_->unicharset.add_script(katakana_script);
334    hiragana_id_ = tess_->unicharset.add_script(hiragana_script);
335    han_id_ = tess_->unicharset.add_script(han_script);
336    hangul_id_ = tess_->unicharset.add_script(hangul_script);
337    japanese_id_ = tess_->unicharset.add_script(japanese_script_);
338    korean_id_ = tess_->unicharset.add_script(korean_script_);
339    latin_id_ = tess_->unicharset.add_script(latin_script);
340    fraktur_id_ = tess_->unicharset.add_script(fraktur_script_);
341  }
342  void ScriptDetector::detect_blob(BLOB_CHOICE_LIST *scores) {
343    for (int i = 0; i < 4; ++i) {
344      std::vector<bool> done(kMaxNumberOfScripts);
345      BLOB_CHOICE_IT choice_it;
346      choice_it.set_to_list(scores + i);
347      float prev_score = -1;
348      int script_count = 0;
349      int prev_id = -1;
350      int prev_fontinfo_id = -1;
351      const char *prev_unichar = "";
352      const char *unichar = "";
353      for (choice_it.mark_cycle_pt(); !choice_it.cycled_list(); choice_it.forward()) {
354        BLOB_CHOICE *choice = choice_it.data();
355        int id = choice->script_id();
356        if (allowed_scripts_ != nullptr && !allowed_scripts_->empty()) {
357          size_t s = 0;
358          for (s = 0; s < allowed_scripts_->size(); ++s) {
359            if ((*allowed_scripts_)[s] == id) {
360              break;
361            }
362          }
363          if (s == allowed_scripts_->size()) {
364            continue; 
365          }
366        }
367        if (done.at(id)) {
368          continue;
369        }
370        done[id] = true;
371        unichar = tess_->unicharset.id_to_unichar(choice->unichar_id());
372        if (prev_score < 0) {
373          prev_score = -choice->certainty();
374          script_count = 1;
375          prev_id = id;
376          prev_unichar = unichar;
377          prev_fontinfo_id = choice->fontinfo_id();
378        } else if (-choice->certainty() < prev_score + kNonAmbiguousMargin) {
379          ++script_count;
380        }
381        if (strlen(prev_unichar) == 1) {
382          if (unichar[0] >= '0' && unichar[0] <= '9') {
383            break;
384          }
385        }
386        if (script_count >= 2) {
387          break;
388        }
389      }
390      if (script_count == 1) {
391        osr_->scripts_na[i][prev_id] += 1.0;
392        if (prev_id == latin_id_) {
393          if (prev_fontinfo_id >= 0) {
394            const tesseract::FontInfo &fi = tess_->get_fontinfo_table().at(prev_fontinfo_id);
395            if (fi.is_fraktur()) {
396              osr_->scripts_na[i][prev_id] -= 1.0;
397              osr_->scripts_na[i][fraktur_id_] += 1.0;
398            }
399          }
400        }
401        if (prev_id == katakana_id_) {
402          osr_->scripts_na[i][japanese_id_] += 1.0;
403        }
404        if (prev_id == hiragana_id_) {
405          osr_->scripts_na[i][japanese_id_] += 1.0;
406        }
407        if (prev_id == hangul_id_) {
408          osr_->scripts_na[i][korean_id_] += 1.0;
409        }
410        if (prev_id == han_id_) {
411          osr_->scripts_na[i][korean_id_] += kHanRatioInKorean;
412          osr_->scripts_na[i][japanese_id_] += kHanRatioInJapanese;
413        }
414      }
415    } 
416  }
417  bool ScriptDetector::must_stop(int orientation) const {
418    osr_->update_best_script(orientation);
419    return osr_->best_result.sconfidence > 1;
420  }
421  int OrientationIdToValue(const int &id) {
422    switch (id) {
423      case 0:
424        return 0;
425      case 1:
426        return 270;
427      case 2:
428        return 180;
429      case 3:
430        return 90;
431      default:
432        return -1;
433    }
434  }
435  } 
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-svmmodels.cpp</h3>
            <pre><code>1  void TCrossValid::PrepareFolds(const int& Folds, TIntV& DIdV,
2          const int& Seed, TVec<TIntV>& DIdVFoldV) {
3      IAssert(Folds > 1);
4      IAssertR(DIdV.Len()/Folds > 1,
5          TStr::Fmt("To little documents per fold (%d/%d)", DIdV.Len(), Folds));
6      DIdVFoldV.Gen(Folds);
7      const int Len = DIdV.Len();
8      for (int FoldN = 0; FoldN < Folds; FoldN++)
9          DIdVFoldV[FoldN].Gen(Len/Folds, 0);
10      int DocN = 0;
11      TRnd Rnd(Seed); DIdV.Shuffle(Rnd);
12      while (DocN < Len) {
13          int FoldN = 0;
<span onclick='openModal()' class='match'>14          while (DocN < Len && FoldN < Folds) {
15              DIdVFoldV[FoldN].Add(DIdV[DocN]);
16              FoldN++; DocN++;
17          }
18      }
19      DIdV.Sort();
20      for (int FoldN = 0; FoldN < Folds; FoldN++) {
</span>21          DIdVFoldV[FoldN].Sort();
22      }
23  }
24  void TCrossValid::PrepareSplit(const int& FoldN, const TVec<TIntV>& DIdVFoldV,
25                                 TIntV& TrainSubDIdV, TIntV& TestSubDIdV) {
26      TrainSubDIdV.Clr(); TestSubDIdV.Clr();
27      for (int n = 0; n < DIdVFoldV.Len(); n++) {
28          if (n == FoldN) {
29              TestSubDIdV.AddV(DIdVFoldV[n]);
30          } else {
31              TrainSubDIdV.AddV(DIdVFoldV[n]);
32          }
33      }
34      TrainSubDIdV.Sort(); TestSubDIdV.Sort();
35  }
36  void TCrossValid::PrepareSubDIdV(const TIntV& SubSet, const int& DataSetLen, TIntV& DIdV) {
37      if (SubSet.Empty()) {
38          DIdV.Gen(DataSetLen, 0);
39          for (int i = 0; i < DataSetLen; i++) DIdV.Add(i);
40      } else {
41          DIdV = SubSet;
42      }
43  }
44  bool TSparseTrainSet::IsReg=TSparseTrainSet::MkReg();
45  TSparseTrainSet::TSparseTrainSet(const TIntV& VecIdV, const int& _MaxDim, const TFltV& _ClsV,
46          const TFltV& _NormV, const TVec<TIntFltKdV>& _TrainV): TSVMTrainSet(ststSparse) {
47      if (VecIdV.Empty()) {
48          MaxDim = _MaxDim; ClsV = _ClsV;
49          NormV = _NormV; TrainV = _TrainV;
50      } else {
51          MaxDim = _MaxDim;
52          const int Vecs = VecIdV.Len();
53          ClsV.Gen(Vecs, 0); NormV.Gen(Vecs, 0); TrainV.Gen(Vecs, 0);
54          for (int VecN = 0; VecN < Vecs; VecN++) {
55              const int VecId = VecIdV[VecN];
56              ClsV.Add(_ClsV[VecId]);
57              NormV.Add(_NormV[VecId]);
58              TrainV.Add(_TrainV[VecId]);
59          }
60      }
61  }
62  void TSparseTrainSet::SaveTxt(const TStr& OutFNm) const {
63      PSOut SOut = TFOut::New(OutFNm);
64      for (int VecN = 0; VecN < TrainV.Len(); VecN++) {
65          const TIntFltKdV& AttrV = TrainV[VecN];
66          SOut->PutStr(TStr::Fmt("%f", GetVecParam(VecN)));
67          for (int a = 0; a < AttrV.Len(); a++) {
68              SOut->PutStr(TStr::Fmt(" %d:%f", AttrV[a].Key(), AttrV[a].Dat()));
69          }
70          SOut->PutLn();
71      }
72      SOut->Flush();
73  }
74  void TSparseTrainSet::SaveMatlab(const TStr& FName) const {
75      PSOut out = TFOut::New(FName);
76      int ColN = Len();
77      for (int ColId = 0; ColId < ColN; ColId++) {
78          const TIntFltKdV& Vec = TrainV[ColId];
79          for (int RowId = 0, RowN = Vec.Len(); RowId < RowN; RowId++) {
80              out->PutStr(TInt::GetStr(Vec[RowId].Key + 1) + TStr(" ") + TInt::GetStr(ColId + 1) + TStr(" "));
81              out->PutStr(TFlt::GetStr(Vec[RowId].Dat, 20, 18));
82              out->PutCh('\n');
83          }
84      }
85  }
86  double TSparseTrainSet::DotProduct(const int& VecId1, double* vec2, const int& n) const {
87      double Res = 0.0;
88      const TIntFltKdV& V1 = TrainV[VecId1];
89      for (int i = 0; i < V1.Len(); i++) {
90          const int key = V1[i].Key;
91          if (key < n) Res += V1[i].Dat * vec2[key];
92      }
93      return Res;
94  }
95  void TSparseTrainSet::AddVec(const int& VecId1, double* vec2,
96          const int& n, const double& K) const {
97      const TIntFltKdV& V1 = TrainV[VecId1];
98      for (int i = 0; i < V1.Len(); i++) {
99          Assert(V1[i].Key < n);
100          vec2[V1[i].Key] += K * V1[i].Dat;
101      }
102  }
103  int TSparseTrainSet::AddAttrV(const TIntFltKdV& AttrV,
104          const double& Cls, const bool& Normalize) {
105      double Norm = TLinAlg::Norm2(AttrV);
106      IAssertR(Norm >= 0.0, TStr::Fmt("%g (len = %d)", Norm, AttrV.Len()));
107      NormV.Add(Norm); TrainV.Add(AttrV); TrainV.Last().Pack(); ClsV.Add(Cls);
108      if (AttrV.Empty()) {
109          TrainV.Last().Add(TIntFltKd(1, 0.0));
110      } else {
111          MaxDim = TInt::GetMx(int(MaxDim), AttrV.Last().Key+1);
112          if (Normalize) { TLinAlg::Normalize(TrainV.Last()); }
113      }
114      return TrainV.Len()-1;
115  }
116  void TSparseTrainSet::Shuffle(TRnd& Rnd) {
117      const int Vals = TrainV.Len();
118      for (int ValN=0; ValN<Vals-1; ValN++) {
119          const int NewValN = ValN+Rnd.GetUniDevInt(Vals-ValN);
120          TrainV.Swap(ValN, NewValN);
121          ClsV.Swap(ValN, NewValN);
122          NormV.Swap(ValN, NewValN);
123      }
124  }
125  PSVMTrainSet TSparseTrainSet::LoadTxt(PSIn SIn, const bool& Normalize, const int& verbosity) {
126      TMem buffer;
127      TMem::LoadMem(SIn, buffer);
128      if (buffer[buffer.Len()-1] != '\n') buffer += '\n';  
129      int len = buffer.Len(), n = 0;
130      char ch, *s; int vecsP = 0, vecsM = 0, line = 0;
131      double cls; TIntFltKdV vec;
132      PSVMTrainSet docs = TSparseTrainSet::New();
133      if (len == 0) return docs;
134      ch = buffer[n++];
135      while (n < len) {
136          line++;
137          vec.Clr(false);
138          if (ch != '#') {
139              while (ch == ' ') ch = buffer[n++]; 
140              TChA clsChA;
141              while (ch != ' ' && ch != '\r' && ch != '\n') {
142                  clsChA += ch;
143                  ch = buffer[n++];
144              }
145              if (clsChA.Len() > 0) {
146                  cls = strtod(clsChA.CStr(), &s);
147                  int part = 0;
148                  TChA idChA, valChA;
149                  while (ch != '\r' && ch != '\n' && ch != '#') {
150                      if (part == 0 && ch == ' ') {
151                      } else if (part == 0 && ch != ' ') {
152                          part = 1;     
153                          Assert('0' <= ch && ch <= '9');
154                          idChA += ch;
155                      } else if (part == 1 && ch != ':') {
156                          Assert('0' <= ch && ch <= '9');
157                          idChA += ch;  
158                      } else if (part == 1 && ch == ':') {
159                          part = 2;     
160                      } else if (part == 2 && ch != ' ') {
161                          Assert(('0' <= ch && ch <= '9') || ch == '.');
162                          valChA += ch; 
163                      } else if (part == 2 && ch == ' ') {
164                          int id = strtol(idChA.CStr(), &s, 10);
165                          double val = strtod(valChA.CStr(), &s);
166                          vec.Add(TIntFltKd(id, val));
167                          idChA.Clr(); valChA.Clr();
168                          part = 0;
169                      } else {
170                          printf("error in %d, unexpected charater %c!\n", line, ch);
171                          Assert(false);
172                      }
173                      ch = buffer[n++];
174                      if (part == 2 && (ch == '\r' || ch == '\n' || ch == '#')) {
175                          int id = strtol(idChA.CStr(), &s, 10);
176                          double val = strtod(valChA.CStr(), &s);
177                          vec.Add(TIntFltKd(id, val));
178                          idChA.Clr(); valChA.Clr();
179                          part = 0;
180                      }
181                  } 
182                  if (part != 0) printf("unexpected end of line %d\n", line);
183                  Assert(part == 0); 
184                  docs->AddAttrV(vec, cls, Normalize);
185                  if (cls > 0) vecsP++;
186                  else vecsM++;
187                  if (verbosity > 0 && (vecsP + vecsM)%100 == 0) printf("%d\r", vecsP + vecsM);
188                  while (ch != '\n') ch = buffer[n++]; 
189              }
190          } else {
191              while (ch != '\n') ch = buffer[n++];
192          }
193          if (n < len) ch = buffer[n++];
194      }
195      printf("\n");
196      if (verbosity > 1)
197          printf("\ninput: %d = %d + %d vectors\n", vecsP + vecsM, vecsP, vecsM);
198      else if (verbosity > 0)
199          printf("\n");
200      return docs;
201  }
202  bool TDenseTrainSet::IsReg=TDenseTrainSet::MkReg();
203  TDenseTrainSet::TDenseTrainSet(const TIntV& VecIdV, const int& _MaxDim, const TFltV& _ClsV,
204          const TFltV& _NormV, const TVec<TFltV>& _TrainV): TSVMTrainSet(ststDense) {
205      if (VecIdV.Empty()) {
206          MaxDim = _MaxDim; ClsV = _ClsV;
207          NormV = _NormV; TrainV = _TrainV;
208      } else {
209          MaxDim = _MaxDim;
210          const int Vecs = VecIdV.Len();
211          ClsV.Gen(Vecs, 0); NormV.Gen(Vecs, 0); TrainV.Gen(Vecs, 0);
212          for (int VecN = 0; VecN < Vecs; VecN++) {
213              const int VecId = VecIdV[VecN];
214              ClsV.Add(_ClsV[VecId]);
215              NormV.Add(_NormV[VecId]);
216              TrainV.Add(_TrainV[VecId]);
217          }
218      }
219  }
220  PSVMTrainSet TDenseTrainSet::LoadFromSparse(PSVMTrainSet SparseSet) {
221      const int Vecs = SparseSet->Len();
222      const int Dims = SparseSet->Dim();
223      PSVMTrainSet DenseSet = TDenseTrainSet::New(Vecs);
224      TFltV AttrDenseV(Dims);
225      for (int VecN = 0; VecN < SparseSet->Len(); VecN++) {
226          const TIntFltKdV& AttrSparseV = SparseSet->GetAttrSparseV(VecN);
227          AttrDenseV.PutAll(0.0);
228          TLinAlg::AddVec(1.0, AttrSparseV, AttrDenseV);
229          DenseSet->AddAttrV(AttrDenseV, SparseSet->GetVecParam(VecN), false);
230      }
231      return DenseSet;
232  }
233  void TDenseTrainSet::SaveTxt(const TStr& OutFNm) const {
234      PSOut SOut = TFOut::New(OutFNm);
235      for (int VecN = 0; VecN < TrainV.Len(); VecN++) {
236          const TFltV& AttrV = TrainV[VecN];
237          SOut->PutStr(TStr::Fmt("%f", GetVecParam(VecN)));
238          for (int a = 0; a < AttrV.Len(); a++) {
239              SOut->PutStr(TStr::Fmt(" %d:%f", a+1, AttrV[a]()));
240          }
241          SOut->PutLn();
242      }
243      SOut->Flush();
244  }
245  int TDenseTrainSet::AddAttrV(const TFltV& AttrV, const double& Cls, const bool& Normalize) {
246      IAssert(!AttrV.Empty());
247      IAssert(MaxDim == 0 || AttrV.Len() == MaxDim);
248      MaxDim = AttrV.Len();
249      double Norm = TLinAlg::Norm2(AttrV); NormV.Add(Norm);
250      TrainV.Add(AttrV); TrainV.Last().Pack(); ClsV.Add(Cls);
251      if (Normalize) { TLinAlg::Normalize(TrainV.Last()); }
252      return TrainV.Len()-1;
253  }
254  double TDenseTrainSet::DotProduct(const int& VecId1, double* vec2, const int& n) const {
255      IAssert(n == MaxDim);
256      const TFltV& V1 = TrainV[VecId1];
257      double Res = V1[0]*vec2[0];
258      for (int i = 1; i < MaxDim; i++)
259          Res += V1[i]*vec2[i];
260      return Res;
261  }
262  void TDenseTrainSet::AddVec(const int& VecId1, double* vec2,
263                              const int& n, const double& K) const {
264      IAssert(n == MaxDim);
265      const TFltV& V1 = TrainV[VecId1];
266      for (int i = 0; i < MaxDim; i++)
267          vec2[i] += K*V1[i];
268  }
269  void TDenseTrainSet::Shuffle(TRnd& Rnd) {
270      const int Vals = TrainV.Len();
271      for (int ValN=0; ValN<Vals-1; ValN++) {
272          const int NewValN = ValN+Rnd.GetUniDevInt(Vals-ValN);
273          TrainV.Swap(ValN, NewValN);
274          ClsV.Swap(ValN, NewValN);
275          NormV.Swap(ValN, NewValN);
276      }
277  }
278  PSVMTrainSet TDenseTrainSet::ProjectLin(PSVMTrainSet Set,
279          const TFltVV& Basis, const bool& Normalize, const int& NewDim) {
280      IAssert(NewDim == -1 || (NewDim >= 0 && NewDim <= Basis.GetYDim()));
281      const int Dim = (NewDim == -1) ? Basis.GetYDim() : NewDim; 
282      const int Len = Basis.GetXDim();
283      TVec<TFltV> NewBasis(Dim);
284      for (int VecC = 0; VecC < Dim; VecC++) {
285          NewBasis[VecC].Gen(Len,0);
286          for (int i = 0; i < Len; i++) {
287              NewBasis[VecC].Add(Basis(i, VecC));
288          }
289      }
290      return ProjectLin(Set, NewBasis, Normalize);
291  }
292  PSVMTrainSet TDenseTrainSet::ProjectLin(PSVMTrainSet Set,
293          const TVec<TFltV>& Basis, const bool& Normalize, const int& NewDim) {
294      IAssert(NewDim == -1 || (NewDim >= 0 && NewDim <= Basis.Len()));
295      const int VecN = Set->Len(); 
296      const int Dim = (NewDim == -1) ? Basis.Len() : NewDim; 
297      PSVMTrainSet NewSet = TDenseTrainSet::New(VecN);
298      for (int VecC = 0; VecC < VecN; VecC++) {
299          if (VecC % 100 == 0) printf("%d\r", VecC);
300          TFltV Vec(Dim, 0);
301          for (int i = 0; i < Dim; i++) {
302              Vec.Add(Set->DotProduct(VecC, Basis[i]));
303          }
304          NewSet->AddAttrV(Vec, Set->GetVecParam(VecC), Normalize);
305      }
306      printf("\n");
307      return NewSet;
308  }
309  bool TBowTrainSet::IsReg=TBowTrainSet::MkReg();
310  TBowTrainSet::TBowTrainSet(const TIntV& VecIdV, const int& _MaxDim, const TIntV& _DIdV,
311          const TVec<PBowSpV>& _TrainV, const TFltV& _ClsV): TSVMTrainSet(ststBow) {
312      if (VecIdV.Empty()) {
313          MaxDim = _MaxDim; DIdV = _DIdV;
314          TrainV = _TrainV; ClsV = _ClsV;
315      } else {
316          MaxDim = _MaxDim;
317          const int Vecs = VecIdV.Len();
318          DIdV.Gen(Vecs, 0); TrainV.Gen(Vecs, 0); ClsV.Gen(Vecs, 0);
319          for (int VecN = 0; VecN < Vecs; VecN++) {
320              const int VecId = VecIdV[VecN];
321              DIdV.Add(_DIdV[VecId]);
322              TrainV.Add(_TrainV[VecId]);
323              ClsV.Add(_ClsV[VecId]);
324          }
325      }
326  }
327  void TBowTrainSet::SaveTxt(const TStr& OutFNm) const {
328      PSOut SOut = TFOut::New(OutFNm);
329      for (int VecN = 0; VecN < TrainV.Len(); VecN++) {
330          PBowSpV AttrV = TrainV[VecN];
331          SOut->PutStr(TStr::Fmt("%f", GetVecParam(VecN)));
332          for (int a = 0; a < AttrV->Len(); a++) {
333              SOut->PutStr(TStr::Fmt(" %d:%f", AttrV->GetWId(a), AttrV->GetWgt(a).Val));
334          }
335          SOut->PutLn();
336      }
337      SOut->Flush();
338  }
339  double TBowTrainSet::DotProduct(const int& VecId1, double* vec2, const int& n) const {
340      double res = 0.0;
341      TBowWIdWgtKd* vec1 = TrainV[VecId1]->BegI();
342      int len1 = TrainV[VecId1]->Len();
343      for (int i = 0; i < len1; i++) {
344          Assert(vec1[i].Key < n);
345          res += vec2[vec1[i].Key] * vec1[i].Dat;
346      }
347      return res;
348  }
349  void TBowTrainSet::AddVec(const int& VecId1, double* vec2,
350                            const int& n, const double& K) const {
351      TBowWIdWgtKd* vec1 = TrainV[VecId1]->BegI();
352      int len1 = TrainV[VecId1]->Len();
353      for (int i = 0; i < len1; i++) {
354          Assert(vec1[i].Key < n);
355          vec2[vec1[i].Key] += K * vec1[i].Dat;
356      }
357  }
358  void TBowTrainSet::AddVec(const int& VecId1, TFltV& vec2, const double& K) const {
359      PBowSpV vec1 = TrainV[VecId1]; int len1 = vec1->Len();
360      for (int i = 0; i < len1; i++) {
361          Assert(vec1->GetWId(i) < vec2.Len());
362          vec2[vec1->GetWId(i)] += K * vec1->GetWgt(i);
363      }
364  }
365  int TBowTrainSet::AddAttrV(const int& DId, PBowSpV SpVec, const double& Cls) {
366      DIdV.Add(DId); TrainV.Add(SpVec); ClsV.Add(Cls);
367      if (SpVec->GetWIds() > 0) {
368          int VecDim = SpVec->GetWId(SpVec->GetWIds()-1);
369          MaxDim = MaxDim > VecDim ? MaxDim() : VecDim + 1;
370      }
371      return TrainV.Len()-1;
372  }
373  void TBowTrainSet::Shuffle(TRnd& Rnd) {
374      const int Vals = TrainV.Len();
375      for (int ValN=0; ValN<Vals-1; ValN++) {
376          const int NewValN = ValN+Rnd.GetUniDevInt(Vals-ValN);
377          DIdV.Swap(ValN, NewValN);
378          TrainV.Swap(ValN, NewValN);
379          ClsV.Swap(ValN, NewValN);
380      }
381  }
382  bool TStringTrainSet::IsReg=TStringTrainSet::MkReg();
383  void TStringTrainSet::UpdateAlphN(const TIntV& Vec) {
384      for (int i = 0, l = Vec.Len(); i < l; i++)
385          AlphN = TInt::GetMx(AlphN, Vec[i]+1);
386      StrKer->UpdateAlphN(AlphN);
387  }
388  TStringTrainSet::TStringTrainSet(const TIntV& VecIdV, const TFltV& _ClsV,
389          const TFltV& _NormV, const TVec<TIntV>& _TrainV, PStrParser _Parser,
390          const int& _AlphN, PStringKernel _StrKer): TSVMTrainSet(ststString) {
391      if (VecIdV.Empty()) {
392          ClsV = _ClsV; NormV = _NormV; TrainV = _TrainV;
393          Parser = _Parser; AlphN = _AlphN; StrKer = _StrKer;
394      } else {
395          const int Vecs = VecIdV.Len();
396          ClsV.Gen(Vecs, 0); NormV.Gen(Vecs, 0); TrainV.Gen(Vecs, 0);
397          for (int VecN = 0; VecN < Vecs; VecN++) {
398              const int VecId = VecIdV[VecN];
399              ClsV.Add(_ClsV[VecId]);
400              NormV.Add(_NormV[VecId]);
401              TrainV.Add(_TrainV[VecId]);
402          }
403          Parser = _Parser; AlphN = _AlphN; StrKer = _StrKer;
404      }
405      printf("AlphN = [%d => %d]\n", _AlphN, AlphN.Val);
406  }
407  int TStringTrainSet::AddAttrV(const TStr& AttrV, const double& Cls) {
408      TIntV ParsedAttrV; Parser->ProcessDocStr(AttrV, ParsedAttrV);
409      return AddAttrV(ParsedAttrV, Cls);
410  }
411  int TStringTrainSet::AddAttrV(const TIntV& AttrV, const double& Cls) {
412      IAssert(!AttrV.Empty());
413      UpdateAlphN(AttrV);
414      const double Norm = StrKer->CalcKernel(AttrV, AttrV);
415      ClsV.Add(Cls); NormV.Add(Norm);
416      TrainV.Add(AttrV); TrainV.Last().Pack();
417      return TrainV.Len()-1;
418  }
419  double TStringTrainSet::DotProduct(const int& VecId1, const TStr& Vec2) const {
420      TIntV ParsedVec2; Parser->ProcessDocStr(Vec2, ParsedVec2);
421      return DotProduct(VecId1, ParsedVec2);
422  }
423  double TStringTrainSet::DotProduct(const int& VecId1, const TIntV& Vec2) const {
424      const double Norm = StrKer->CalcKernel(Vec2, Vec2);
425      return StrKer->CalcKernel(TrainV[VecId1],Vec2) / sqrt(NormV[VecId1]*Norm);
426  }
427  void TStringTrainSet::Shuffle(TRnd& Rnd) {
428      const int Vals = TrainV.Len();
429      for (int ValN=0; ValN<Vals-1; ValN++) {
430          const int NewValN = ValN+Rnd.GetUniDevInt(Vals-ValN);
431          TrainV.Swap(ValN, NewValN);
432          ClsV.Swap(ValN, NewValN);
433          NormV.Swap(ValN, NewValN);
434      }
435  }
436  TSimMatrixTrainSet::TSimMatrixTrainSet(const TIntV& VecIdV,
437          const TFltV& _ClsV, const TFltVV& _SimMatrix): TSVMTrainSet(ststSimMatrix) {
438      const int Vecs = VecIdV.Len();
439      SimMatrix.Gen(Vecs, Vecs); ClsV.Gen(Vecs, 0);
440      for (int i = 0; i < Vecs; i++) {
441          const int VecId1 = VecIdV[i];
442          ClsV.Add(_ClsV[VecId1]);
443          for (int j = 0; j < Vecs; j++) {
444              const int VecId2 = VecIdV[j];
445              SimMatrix(i, j) = _SimMatrix(VecId1, VecId2);
446          }
447      }
448  }
449  TSimMatrixTrainSet::TSimMatrixTrainSet(const TFltVV& _SimMatrix,
450          const TFltV& _ClsV): TSVMTrainSet(ststSimMatrix), SimMatrix(_SimMatrix) {
451      if (_ClsV.Empty()) {
452          ClsV.Gen(SimMatrix.GetXDim());
453          ClsV.PutAll(0.0);
454      } else {
455          ClsV = _ClsV;
456          Assert(ClsV.Len() == SimMatrix.GetXDim());
457      }
458  }
459  void TBowDocBs2TrainSet::MakeSpVec(PBowSpV BowVec, TIntFltKdV& SpVec) {
460      const int BowVecLen = BowVec->GetWIds(); SpVec.Gen(BowVecLen, 0);
461      for (int WgtC = 0, WgtN = BowVecLen; WgtC < WgtN; WgtC++) {
462          SpVec.Add(TIntFltKd(BowVec->GetWId(WgtC), BowVec->GetWgt(WgtC).Val));
463      }
464  }
465  PSVMTrainSet TBowDocBs2TrainSet::NewBowNoCat(
466          const TVec<PBowSpV>& BowSpV, const double& DefParam) {
467      int DocN = BowSpV.Len();
468      PSVMTrainSet docs = TBowTrainSet::New(DocN);
469      for (int DocC = 0; DocC < DocN; DocC++) {
470          docs->AddAttrV(DocC, BowSpV[DocC], DefParam);
471      }
472      return docs;
473  }
474  PSVMTrainSet TBowDocBs2TrainSet::NewBowNoCat(PBowDocWgtBs BowDocWgtBs,
475          const TIntV& DIdV, const double& DefParam) {
476      int DocN = DIdV.Len();
477      PSVMTrainSet docs = TBowTrainSet::New(DocN);
478      for (int DocC = 0; DocC < DocN; DocC++) {
479          int DId = DIdV[DocC];
480          PBowSpV SpV = BowDocWgtBs->GetSpV(DId);
481          docs->AddAttrV(DId, SpV, DefParam);
482      }
483      return docs;
484  }
485  PSVMTrainSet TBowDocBs2TrainSet::NewSparseNoCat(
486          const TVec<PBowSpV>& BowSpV, const double& DefParam) {
487      int DocN = BowSpV.Len();
488      PSVMTrainSet Set = TSparseTrainSet::New(DocN); TIntFltKdV SpVec;
489      for (int DocC = 0; DocC < DocN; DocC++) {
490          MakeSpVec(BowSpV[DocC], SpVec);
491          Set->AddAttrV(SpVec, DefParam, false);
492      }
493      return Set;
494  }
495  PSVMTrainSet TBowDocBs2TrainSet::NewSparseNoCat(PBowDocWgtBs BowDocWgtBs,
496          const TIntV& DIdV, const double& DefParam) {
497      int DocN=DIdV.Len();
498      PSVMTrainSet Set = TSparseTrainSet::New(DocN); TIntFltKdV SpVec;
499      for (int DocC = 0; DocC < DocN; DocC++) {
500          int DId = DIdV[DocC];
501          MakeSpVec(BowDocWgtBs->GetSpV(DId), SpVec);
502          Set->AddAttrV(SpVec, DefParam, false);
503      }
504      return Set;
505  }
506  PSVMTrainSet TBowDocBs2TrainSet::NewBowOneCat(const PBowDocBs& BowDocBs,
507          PBowDocWgtBs BowDocWgtBs, const int& CatId, const TIntV& DIdV) {
508      int DocN = DIdV.Len();
509      PSVMTrainSet docs = TBowTrainSet::New(DocN);
510      for (int DocC = 0; DocC < DocN; DocC++) {
511          int DId = DIdV[DocC];
512          if (BowDocBs->IsCatInDoc(DId, CatId)) {
513              PBowSpV SpV = BowDocWgtBs->GetSpV(DId);
514              docs->AddAttrV(DId, SpV, 1.0);
515          }
516      }
517      return docs;
518  }
519  PSVMTrainSet TBowDocBs2TrainSet::NewSparseOneCat(const PBowDocBs& BowDocBs,
520          PBowDocWgtBs BowDocWgtBs, const int& CatId, const TIntV& DIdV) {
521      int DocN=DIdV.Len();
522      PSVMTrainSet Set = TSparseTrainSet::New(DocN); TIntFltKdV SpVec;
523      for (int DocC = 0; DocC < DocN; DocC++) {
524          int DId = DIdV[DocC];
525          if (BowDocBs->IsCatInDoc(DId, CatId)) {
526              MakeSpVec(BowDocWgtBs->GetSpV(DId), SpVec);
527              Set->AddAttrV(SpVec, 1.0, false);
528          }
529      }
530      return Set;
531  }
532  PSVMTrainSet TBowDocBs2TrainSet::NewStringOneCat(const PBowDocBs& BowDocBs,
533          const int& CatId, const TIntV& DIdV, PStrParser Parser, PStringKernel StrKer) {
534      int DocN=DIdV.Len();
535      PSVMTrainSet Set = TStringTrainSet::New(Parser, StrKer, DocN); TIntFltKdV SpVec;
536      for (int DocC = 0; DocC < DocN; DocC++) {
537          int DId = DIdV[DocC];
538          if (BowDocBs->IsCatInDoc(DId, CatId)) {
539              TStr DocStr = BowDocBs->GetDocStr(DId);
540              Set->AddAttrV(DocStr, 1.0);
541          }
542      }
543      return Set;
544  }
545  PSVMTrainSet TBowDocBs2TrainSet::NewBowAllCat(const PBowDocBs& BowDocBs,
546          PBowDocWgtBs BowDocWgtBs, const int& CatId, const TIntV& DIdV,
547          const double& SampleNegP) {
548      int Docs = DIdV.Len();
549      TIntV PosDIdV, NegDIdV;
550      for (int DocN = 0; DocN < Docs; DocN++) {
551          const int DId = DIdV[DocN];
552          if(BowDocBs->IsCatInDoc(DId, CatId)) {
553              PosDIdV.Add(DId);
554          } else {
555              NegDIdV.Add(DId);
556          }
557      }
558      const int SampleSize = TFlt::Round(PosDIdV.Len() * SampleNegP);
559      if ((SampleSize > 0) && (NegDIdV.Len() > SampleSize)) {
560          TRnd Rnd(1); NegDIdV.Shuffle(Rnd); NegDIdV.Trunc(SampleSize);
561      }
562      PSVMTrainSet docs = TBowTrainSet::New(NegDIdV.Len() + PosDIdV.Len());
563      for (int PosDocN = 0; PosDocN < PosDIdV.Len(); PosDocN++) {
564          const int DId = PosDIdV[PosDocN]; docs->AddAttrV(DId, BowDocWgtBs->GetSpV(DId), 1.0); }
565      for (int NegDocN = 0; NegDocN < NegDIdV.Len(); NegDocN++) {
566          const int DId = NegDIdV[NegDocN]; docs->AddAttrV(DId, BowDocWgtBs->GetSpV(DId), -1.0); }
567      return docs;
568  }
569  PSVMTrainSet TBowDocBs2TrainSet::NewSparseAllCat(const PBowDocBs& BowDocBs,
570          PBowDocWgtBs BowDocWgtBs, const int& CatId, const TIntV& DIdV) {
571      int DocN = DIdV.Len();
572      PSVMTrainSet Set = TSparseTrainSet::New(DocN); TIntFltKdV SpVec;
573      for (int DocC = 0; DocC < DocN; DocC++) {
574          int DId = DIdV[DocC];
575          double param = BowDocBs->IsCatInDoc(DId, CatId) ? 1.0 : -1.0;
576          MakeSpVec(BowDocWgtBs->GetSpV(DId), SpVec);
577          Set->AddAttrV(SpVec, param, false);
578      }
579      return Set;
580  }
581  PSVMTrainSet TBowDocBs2TrainSet::NewStringAllCat(const PBowDocBs& BowDocBs,
582          const int& CatId, const TIntV& DIdV, PStrParser Parser, PStringKernel StrKer) {
583      int DocN = DIdV.Len();
584      PSVMTrainSet Set = TStringTrainSet::New(Parser, StrKer, DocN); TIntFltKdV SpVec;
585      for (int DocC = 0; DocC < DocN; DocC++) {
586          int DId = DIdV[DocC];
587          double DocParam = BowDocBs->IsCatInDoc(DId, CatId) ? 1.0 : -1.0;
588          TStr DocStr = BowDocBs->GetDocStr(DId);
589          Set->AddAttrV(DocStr, DocParam);
590      }
591      return Set;
592  }
593  PSVMTrainSet TBowDocBs2TrainSet::NewBowAllCatV(PBowDocWgtBs BowDocWgtBs,
594          const TIntV& AllDIdV, const TIntV& CatDIdV) {
595      int DocN = AllDIdV.Len();
596      PSVMTrainSet docs = TBowTrainSet::New(DocN);
597      for (int DocC = 0; DocC < DocN; DocC++) {
598          int DId = AllDIdV[DocC];
599          double param = CatDIdV.SearchBin(DId) == -1 ? -1.0 : 1.0;
600          PBowSpV SpV = BowDocWgtBs->GetSpV(DId);
601          docs->AddAttrV(DId, SpV, param);
602      }
603      return docs;
604  }
605  PSVMTrainSet TBowDocBs2TrainSet::NewSparseAllCatV(PBowDocWgtBs BowDocWgtBs,
606          const TIntV& AllDIdV, const TIntV& CatDIdV) {
607      int DocN = AllDIdV.Len();
608      PSVMTrainSet Set = TSparseTrainSet::New(DocN); TIntFltKdV SpVec;
609      for (int DocC = 0; DocC < DocN; DocC++) {
610          int DId = AllDIdV[DocC];
611          double param = CatDIdV.SearchBin(DId) == -1 ? -1.0 : 1.0;
612          MakeSpVec(BowDocWgtBs->GetSpV(DId), SpVec);
613          Set->AddAttrV(SpVec, param, false);
614      }
615      return Set;
616  }
617  PSVMTrainSet TBowDocBs2TrainSet::NewBowFromCat(const PBowDocBs& BowDocBs,
618          PBowDocWgtBs BowDocWgtBs, const TIntV& AllDIdV) {
619      Fail; return NULL;
620  }
621  PSVMTrainSet TBowDocBs2TrainSet::NewSparseFromCat(const PBowDocBs& BowDocBs,
622          PBowDocWgtBs BowDocWgtBs, const TIntV& AllDIdV) {
623      Fail; return NULL;
624  }
625  PSVMTrainSet TBowDocBs2TrainSet::NewBow(PBowDocPart BowDocPart) {
626      int Clusts = BowDocPart->GetClusts();
627      PSVMTrainSet Set = TBowTrainSet::New(Clusts);
628      for (int ClustN = 0; ClustN < Clusts; ClustN++) {
629          IAssert(BowDocPart->GetClust(ClustN)->IsConceptSpV());
630          Set->AddAttrV(ClustN, BowDocPart->GetClust(ClustN)->GetConceptSpV(), 1.0);
631      }
632      return Set;
633  }
634  PSVMTrainSet TBowDocBs2TrainSet::NewSparse(PBowDocPart BowDocPart) {
635      int Clusts = BowDocPart->GetClusts();
636      PSVMTrainSet Set = TSparseTrainSet::New(Clusts); TIntFltKdV SpVec;
637      for (int ClustN = 0; ClustN < Clusts; ClustN++) {
638          IAssert(BowDocPart->GetClust(ClustN)->IsConceptSpV());
639          MakeSpVec(BowDocPart->GetClust(ClustN)->GetConceptSpV(), SpVec);
640          Set->AddAttrV(SpVec, 1.0, false);
641      }
642      return Set;
643  }
644  PSVMModel TSVMModel::MakeModel(const bool& Linear,
645          const PKernel& ker, const PSVMTrainSet& TrainSet,
646          const TIntV& SubSet, const TSVMModelParam& ModelParam,
647          const TSVMLearnParam& LearnParam) {
648      PSVMModel Model = TSVMModel::New();
649      Model->Linear = Linear;
650      TIntV DIdV; int Len;
651      if (SubSet.Len() != 0) {
652          TSVMFactory::train(Model->AlphaV, Model->Thresh.Val, Linear, ker,
653              TSVMTrainSubSet::New(TrainSet(), SubSet), ModelParam, LearnParam);
654          DIdV = SubSet; Len = SubSet.Len();
655      } else {
656          TSVMFactory::train(Model->AlphaV, Model->Thresh.Val,
657              Linear, ker, TrainSet(), ModelParam, LearnParam);
658          Len = TrainSet->Len(); DIdV.Gen(Len);
659          for (int i = 0; i < Len; i++) { DIdV[i] = i; }
660      }
661      if (ModelParam.ModelType == smtClassifier) {
662          for (int i = 0; i < Len; i++) {
663              Model->AlphaV[i] = TrainSet->GetVecParam(DIdV[i]) * Model->AlphaV[i];
664          }
665      } else if (ModelParam.ModelType == smtRegression) {
666          IAssert(Model->AlphaV.Len() == 2*Len);
667          for (int i = 0; i < Len; i++) {
668              Model->AlphaV[i] = Model->AlphaV[i+Len] - Model->AlphaV[i];
669          }
670          Model->AlphaV.Trunc(Len);
671          Model->Thresh = -1.0 * Model->Thresh;
672      }
673      if (Linear) {
674          TrainSet->LinComb(DIdV, Model->AlphaV, Model->WgtV);
675      } else {
676          if (TrainSet->Type() != ststSimMatrix) {
677              TFltV NewAlphaV; TIntV VecIdV;
678              for (int VecN = 0; VecN < Len; VecN++) {
679                  if (TFlt::Abs(Model->AlphaV[VecN]) > EPSILON) {
680                      NewAlphaV.Add(Model->AlphaV[VecN]);
681                      VecIdV.Add(DIdV[VecN]);
682                  }
683              }
684              Model->AlphaV = NewAlphaV; 
685              Model->SupVecs = TrainSet->Clone(VecIdV);
686          } else {
687              TFltV NewAlphaV(TrainSet->Len()); NewAlphaV.PutAll(0.0);
688              for (int VecN = 0; VecN < Len; VecN++) {
689                  NewAlphaV[DIdV[VecN]] = Model->AlphaV[VecN];
690              }
691              Model->AlphaV = NewAlphaV; 
692              Model->SupVecs = TrainSet;
693          }
694          Model->Kernel = ker;
695      }
696      Model->AlphaV.Pack();
697      return Model;
698  }
699  TCfyRes TSVMModel::CrossValidation(const int& Folds, const int&Seed, const bool& Linear,
700          const PKernel& ker, const PSVMTrainSet& TrainSet, const TIntV& SubSet,
701          const TSVMModelParam& ModelParam, const TSVMLearnParam& LearnParam) {
702      TIntV DIdV; TCrossValid::PrepareSubDIdV(SubSet, TrainSet->Len(), DIdV);
703      TVec<TIntV> DIdVFoldV; TCrossValid::PrepareFolds(Folds, DIdV, Seed, DIdVFoldV);
704      TIntV TrainSubDIdV, TestSubDIdV; TCfyRes CfyRes;
705      double MarginSum = 0.0;
706      for (int FoldN = 0; FoldN < Folds; FoldN++) {
707          printf("%d.. ", FoldN);
708          TCrossValid::PrepareSplit(FoldN, DIdVFoldV, TrainSubDIdV, TestSubDIdV);
709          if (ModelParam.ModelType == smtOneClass) {
710              TIntV PosTrainSubDIdV;
711              for (int DIdN = 0; DIdN < TrainSubDIdV.Len(); DIdN++) {
712                  const int DId = TrainSubDIdV[DIdN];
713                  if (TrainSet->GetVecParam(DId) > 0.0) {
714                      PosTrainSubDIdV.Add(DId);
715                  }
716              }
717              TrainSubDIdV = PosTrainSubDIdV;
718          }
719          PSVMModel FoldModel = MakeModel(Linear, ker,
720              TrainSet, TrainSubDIdV, ModelParam, LearnParam);
721          TCfyRes FoldCfyRes = FoldModel->Test(TrainSet, TestSubDIdV);
722          MarginSum += FoldModel->GetMargin();
723          CfyRes.Add(FoldCfyRes);
724      } printf("\n");
725      CfyRes.Def();
726      CfyRes.AddStat("AvgMargin", MarginSum / Folds);
727      return CfyRes;
728  }
729  TSVMModel::TSVMModel(TSIn& SIn) {
730      AlphaV.Load(SIn);
731      Thresh.Load(SIn);
732      Linear.Load(SIn);
733      if (Linear) {
734          WgtV.Load(SIn);
735      } else {
736          SupVecs = TSVMTrainSet::Load(SIn);
737          Kernel = TKernel::Load(SIn);
738      }
739  }
740  void TSVMModel::Save(TSOut& SOut) {
741      AlphaV.Save(SOut);
742      Thresh.Save(SOut);
743      Linear.Save(SOut);
744      if (Linear) {
745          WgtV.Save(SOut);
746      } else {
747          SupVecs->Save(SOut);
748          Kernel->Save(SOut);
749      }
750  }
751  double TSVMModel::GetRes(const TIntFltKdV& Vec) const {
752      double Result = Thresh;
753      if (Linear) {
754          Result += TLinAlg::DotProduct(WgtV, Vec);
755      } else {
756          IAssert(!SupVecs.Empty() && ! Kernel.Empty());
757          IAssert(SupVecs->Len() == AlphaV.Len());
758          const double Norm2 = TLinAlg::Norm2(Vec);
759          for (int i = 0; i < AlphaV.Len(); i++) {
760              Result += AlphaV[i] * Kernel->Calc(
761                  SupVecs->DotProduct(i, Vec),
762                  Norm2, SupVecs->GetNorm2(i));
763          }
764      }
765      return Result;
766  }
767  double TSVMModel::GetRes(const TFltV& Vec) const {
768      double Result = Thresh;
769      if (Linear) {
770          Result += TLinAlg::DotProduct(WgtV, Vec);
771      } else {
772          IAssert(!SupVecs.Empty() && ! Kernel.Empty());
773          IAssert(SupVecs->Len() == AlphaV.Len());
774          const double Norm2 = TLinAlg::Norm2(Vec);
775          for (int i = 0; i < AlphaV.Len(); i++) {
776              Result += AlphaV[i] * Kernel->Calc(
777                  SupVecs->DotProduct(i, Vec),
778                  Norm2, SupVecs->GetNorm2(i));
779          }
780      }
781      return Result;
782  }
783  double TSVMModel::GetRes(const TStr& Vec) const {
784      IAssert(!Linear); 
785      IAssert(!SupVecs.Empty() && ! Kernel.Empty());
786      IAssert(SupVecs->Len() == AlphaV.Len());
787      IAssert(SupVecs->Type() == ststString);
788      double Result = Thresh;
789      const double Norm2 = 1.0; 
790      for (int i = 0; i < AlphaV.Len(); i++) {
791          Result += AlphaV[i] * Kernel->Calc(
792              SupVecs->DotProduct(i, Vec),
793              Norm2, SupVecs->GetNorm2(i));
794      }
795      return Result;
796  }
797  double TSVMModel::GetRes(const TIntV& Vec) const {
798      IAssert(!Linear); 
799      IAssert(!SupVecs.Empty() && ! Kernel.Empty());
800      IAssert(SupVecs->Len() == AlphaV.Len());
801      IAssert(SupVecs->Type() == ststString);
802      double Result = Thresh;
803      const double Norm2 = 1.0; 
804      for (int i = 0; i < AlphaV.Len(); i++) {
805          Result += AlphaV[i] * Kernel->Calc(
806              SupVecs->DotProduct(i, Vec),
807              Norm2, SupVecs->GetNorm2(i));
808      }
809      return Result;
810  }
811  double TSVMModel::GetRes(PBowSpV Vec) const {
812      double Result = Thresh;
813      if (Linear) {
814          Result += TBowLinAlg::DotProduct(WgtV, Vec);
815      } else {
816          IAssert(!SupVecs.Empty() && ! Kernel.Empty());
817          IAssert(SupVecs->Len() == AlphaV.Len());
818          IAssert(SupVecs->Type() == ststBow);
819          const double Norm2 = TMath::Sqr(Vec->GetNorm());
820          for (int i = 0; i < AlphaV.Len(); i++) {
821              Result += AlphaV[i] * Kernel->Calc(
822                  SupVecs->DotProduct(i, Vec),
823                  Norm2, SupVecs->GetNorm2(i));
824          }
825      }
826      return Result;
827  }
828  double TSVMModel::GetRes(const int& VecId) const {
829      IAssert(!Linear); 
830      IAssert(!SupVecs.Empty() && ! Kernel.Empty());
831      IAssert(SupVecs->Len() == AlphaV.Len());
832      IAssert(0 <= VecId && VecId < AlphaV.Len());
833      IAssert(SupVecs->Type() == ststSimMatrix);
834      double Result = Thresh;
835      const double Norm2 = SupVecs->GetNorm2(VecId);
836      for (int i = 0; i < AlphaV.Len(); i++) {
837          Result += AlphaV[i] * Kernel->Calc(
838              SupVecs->DotProduct(i, VecId),
839              Norm2, SupVecs->GetNorm2(i));
840      }
841      return Result;
842  }
843  TCfyRes TSVMModel::Test(const PSVMTrainSet& TestSet, const TIntV& SubSet) const {
844      TIntV DIdV; TCrossValid::PrepareSubDIdV(SubSet, TestSet->Len(), DIdV);
845      int Len = DIdV.Len(); TCountCfyRes Result;
846      for (int DocC = 0; DocC < Len; DocC++) {
847          if (TestSet->Type() == ststSparse) {
848              Result.Add(GetRes(TestSet->GetAttrSparseV(DIdV[DocC])),
849                  TestSet->GetVecParam(DIdV[DocC]));
850          } else if (TestSet->Type() == ststDense) {
851              Result.Add(GetRes(TestSet->GetAttrDenseV(DIdV[DocC])),
852                  TestSet->GetVecParam(DIdV[DocC]));
853          } else if (TestSet->Type() == ststBow) {
854              Result.Add(GetRes(TestSet->GetAttrBowV(DIdV[DocC])),
855                  TestSet->GetVecParam(DIdV[DocC]));
856          } else if (TestSet->Type() == ststString) {
857              Result.Add(GetRes(TestSet->GetAttrStringV(DIdV[DocC])),
858                  TestSet->GetVecParam(DIdV[DocC]));
859          } else if (TestSet->Type() == ststSimMatrix) {
860              Result.Add(GetRes(DIdV[DocC]), TestSet->GetVecParam(DIdV[DocC]));
861          }
862      }
863      return Result.ToTCfyRes();
864  }
865  void TSVMModel::MakeProb(const PSVMTrainSet& TrainSet, const TIntV& SubSet) {
866      TIntV DIdV; TCrossValid::PrepareSubDIdV(SubSet, TrainSet->Len(), DIdV);
867      int Docs = DIdV.Len();
868      TFltIntKdV DistParamV(Docs, 0);
869      for (int DocC = 0; DocC < Docs; DocC++) {
870          double DistToHyperplane = 0.0;
871          if (TrainSet->Type() == ststSparse) {
872              DistToHyperplane = GetRes(TrainSet->GetAttrSparseV(DIdV[DocC]));
873          } else if (TrainSet->Type() == ststDense) {
874              DistToHyperplane = GetRes(TrainSet->GetAttrDenseV(DIdV[DocC]));
875          } else if (TrainSet->Type() == ststBow) {
876              DistToHyperplane = GetRes(TrainSet->GetAttrBowV(DIdV[DocC]));
877          } else if (TrainSet->Type() == ststString) {
878              DistToHyperplane = GetRes(TrainSet->GetAttrStringV(DIdV[DocC]));
879          } else if (TrainSet->Type() == ststSimMatrix) {
880              DistToHyperplane = GetRes(DIdV[DocC]);
881          }
882          DistParamV.Add(TFltIntKd(DistToHyperplane,
883              TFlt::Round(TrainSet->GetVecParam(DIdV[DocC]))));
884      }
885      Sigmoid = TSigmoid(DistParamV);
886      IsSigDef = true;
887  }
888  double TSVMModel::GetMargin() const {
889      if (IsLinear()) {
890          const double WgtNorm = TLinAlg::Norm(WgtV);
891          if (WgtNorm > 0.0) { return 1.0 / WgtNorm; }
892          else { return 0.0; }
893      } else {
894          double WgtNorm2 = 0.0;
895          for (int i = 0; i < AlphaV.Len(); i++) {
896              for (int j = 0; j < AlphaV.Len(); j++) {
897                  WgtNorm2 += AlphaV[i]*AlphaV[j] * Kernel->CalcSet(SupVecs, i, j);
898              }
899          }
900          if (WgtNorm2 > 0.0) { return 1.0 / sqrt(WgtNorm2); }
901          else { return 0.0; }
902      }
903  }
904  bool TBowSVMMd::IsReg=TBowSVMMd::MkReg();
905  TBowSVMMd::TBowSVMMd(TSIn& SIn): TBowMd(SIn) {
906      CatNm.Load(SIn);
907      Model = TSVMModel::Load(SIn);
908  }
909  void TBowSVMMd::Save(TSOut &SOut) {
910      TBowMd::Save(SOut);
911      CatNm.Save(SOut);
912      Model->Save(SOut);
913  }
914  void TBowSVMMd::GetLinComb(
915   const PBowDocBs& BowDocBs, TFltStrPrV& WgtStrPrV, double& Tsh) const {
916    IAssert(IsLinComb());
917    TFltV WgtV; Model->GetWgtV(WgtV);
918    for (int WordId=0; WordId<WgtV.Len(); WordId++){
919      if (WgtV[WordId]!=0.0){
920        if (BowDocBs.Empty()){
921          WgtStrPrV.Add(TFltStrPr(WgtV[WordId], TInt::GetStr(WordId)));
922        } else {
923          TStr Str=BowDocBs->GetWordStr(WordId);
924          WgtStrPrV.Add(TFltStrPr(WgtV[WordId], Str));
925        }
926      }
927    }
928    Tsh=Model->GetThresh();
929  }
930  PSVMTrainSet TBowSVMMd::PrepareClsTrainSet(PBowDocBs BowDocBs,
931          PBowDocWgtBs BowDocWgtBs, const TStr& CatNm, const TIntV& TrainDIdV,
932          const double& SampleNegP) {
933      IAssertR(BowDocBs->IsCatNm(CatNm), CatNm);
934      const int CId = BowDocBs->GetCId(CatNm);
935      return TBowDocBs2TrainSet::NewBowAllCat(BowDocBs,
936          BowDocWgtBs, CId, TrainDIdV, SampleNegP);
937  }
938  PSVMTrainSet TBowSVMMd::PrepareOneClassTrainSet(PBowDocBs BowDocBs,
939          PBowDocWgtBs BowDocWgtBs, const TStr& CatNm, const TIntV& TrainDIdV) {
940      IAssertR(BowDocBs->IsCatNm(CatNm), CatNm);
941      const int CId = BowDocBs->GetCId(CatNm);
942      return TBowDocBs2TrainSet::NewBowOneCat(BowDocBs, BowDocWgtBs, CId, TrainDIdV);
943  }
944  inline PSVMTrainSet TBowSVMMd::PrepareClsTrainSet(PBowDocBs BowDocBs,
945          PBowDocWgtBs BowDocWgtBs, const TIntV& AllDIdV, const TIntV& CatDIdV) {
946      return TBowDocBs2TrainSet::NewSparseAllCatV(BowDocWgtBs, AllDIdV, CatDIdV);
947  }
948  PBowSpV TBowSVMMd::GetKeywords(const PSVMTrainSet& TrainSet,
949          const PSVMModel& SVMModel, const int WdN,
950          const double& VecSign, const double& WgtSign, const bool& AvgOverSet) {
951      TFltV NormalV; SVMModel->GetWgtV(NormalV);
952      TIntFltKdV WIdWgtKdV;
953      TrainSet->GetKeywords(NormalV, WIdWgtKdV,
954          TIntV(), WdN, VecSign, WgtSign, AvgOverSet);
955      PBowSpV BowSpV = TBowSpV::New(-1, WIdWgtKdV.Len());
956      for (int WdN = 0; WdN < WIdWgtKdV.Len(); WdN++) {
957          BowSpV->AddWIdWgt(WIdWgtKdV[WdN].Key, WIdWgtKdV[WdN].Dat);
958      }
959      return BowSpV;
960  }
961  inline void TBowSVMMd::GetCfy(const PBowSpV& QueryBowSpV, TFltStrPrV& WgtCatNmPrV) {
962      WgtCatNmPrV = TFltStrPrV::GetV(TFltStrPr(Model->IsProb() ?
963          Model->GetProbCfy(QueryBowSpV) : Model->GetRes(QueryBowSpV), CatNm));
964  }
965  TCfyRes TBowSVMMd::Test(PBowMd BowMd, PBowDocBs BowDocBs,
966          PBowDocWgtBs BowDocWgtBs, const TIntV& DIdV, const TStr& CatNm) {
967      TCountCfyRes Result; TFltStrPrV ResV;
968      IAssertR(BowDocBs->IsCatNm(CatNm), CatNm);
969      const int CId = BowDocBs->GetCId(CatNm);
970      for (int VecC = 0, VecN = DIdV.Len(); VecC < VecN; VecC++) {
971          PBowSpV DocSpV = BowDocWgtBs->GetSpV(DIdV[VecC]);
972          ResV.Clr(); BowMd->GetCfy(DocSpV, ResV);
973          double PredCls = ResV.Len() > 0 ? ResV[0].Val1() : -1.0;
974          double TrueCls = BowDocBs->IsCatInDoc(DIdV[VecC], CId) ? 1.0 : -1.0;
975          Result.Add(PredCls, TrueCls);
976      }
977      return Result.ToTCfyRes();
978  }
979  void TBowSVMMd::SaveTxt(const TStr& FNm, const PBowDocBs& BowDocBs,
980          const PBowDocWgtBs& BowDocWgtBs) {
981      PSOut SOut = TFOut::New(FNm);
982      TIntV DIdV; BowDocBs->GetAllDIdV(DIdV);
983      TCfyRes Res = Test(this, BowDocBs, BowDocWgtBs, DIdV, this->GetCatNm());
984      Res.PrStat("Results on the training data", SOut);
985      SOut->PutLn();
986  }
987  PBowMd TBowSVMMd::NewClsLinear(const PBowDocBs& BowDocBs, PBowDocWgtBs BowDocWgtBs,
988          const TStr& CatNm, const TIntV& TrainDIdV, const double& C, const double& j,
989          const bool& ProbabilisticP, const TSVMLearnParam& LearnParam) {
990      PSVMTrainSet TrainSet = PrepareClsTrainSet(BowDocBs, BowDocWgtBs, CatNm, TrainDIdV);
991      PSVMModel Model = TSVMModel::NewClsLinear(TrainSet, C, j, TIntV(), LearnParam);
992      if (ProbabilisticP) Model->MakeProb(TrainSet);
993      return TBowSVMMd::New(BowDocBs, CatNm, Model);
994  }
995  PBowMd TBowSVMMd::NewClsLinear(const PBowDocBs& BowDocBs, PBowDocWgtBs BowDocWgtBs,
996          const TIntV& TrainDIdV, const TIntV& CatDIdV, const double& C, const double& j,
997          const bool& ProbabilisticP, const TSVMLearnParam& LearnParam) {
998      PSVMTrainSet TrainSet = PrepareClsTrainSet(BowDocBs, BowDocWgtBs, TrainDIdV, CatDIdV);
999      PSVMModel Model = TSVMModel::NewClsLinear(TrainSet, C, j, TIntV(), LearnParam);
1000      if (ProbabilisticP) Model->MakeProb(TrainSet);
1001      return TBowSVMMd::New(BowDocBs, "unknown", Model);
1002  }
1003  PBowMd TBowSVMMd::NewCls(const PKernel& ker, const PBowDocBs& BowDocBs,
1004          PBowDocWgtBs BowDocWgtBs, const TStr& CatNm, const TIntV& TrainDIdV,
1005          const double& C, const double& j, const bool& ProbabilisticP,
1006          const TSVMLearnParam& LearnParam) {
1007      PSVMTrainSet TrainSet = PrepareClsTrainSet(BowDocBs, BowDocWgtBs, CatNm, TrainDIdV);
1008      PSVMModel Model = TSVMModel::NewCls(TrainSet, ker, C, j, TIntV(), LearnParam);
1009      if (ProbabilisticP) Model->MakeProb(TrainSet);
1010      return TBowSVMMd::New(BowDocBs, CatNm, Model);
1011  }
1012  TCfyRes TBowSVMMd::CrossValidClsLinear(const int& Folds, const int&Seed,
1013          const PBowDocBs& BowDocBs, PBowDocWgtBs BowDocWgtBs, const TStr& CatNm,
1014          const TIntV& TrainDIdV, const double& C, const double& j,
1015          const TSVMLearnParam& LearnParam) {
1016      PSVMTrainSet TrainSet = PrepareClsTrainSet(BowDocBs, BowDocWgtBs, CatNm, TrainDIdV);
1017      return TSVMModel::CrossValidClsLinear(Folds, Seed, TrainSet, C, j, TIntV(), LearnParam);
1018  }
1019  TCfyRes TBowSVMMd::CrossValidClsLinear(const int& Folds, const int&Seed,
1020          const PBowDocBs& BowDocBs, PBowDocWgtBs BowDocWgtBs, const TIntV& TrainDIdV,
1021          const TIntV& CatDIdV, const double& C, const double& j,
1022          const TSVMLearnParam& LearnParam) {
1023      PSVMTrainSet TrainSet = PrepareClsTrainSet(BowDocBs, BowDocWgtBs, TrainDIdV, CatDIdV);
1024      return TSVMModel::CrossValidClsLinear(Folds, Seed, TrainSet, C, j, TIntV(), LearnParam);
1025  }
1026  TCfyRes TBowSVMMd::CrossValidCls(const int& Folds, const int&Seed,
1027          const PKernel& ker, const PBowDocBs& BowDocBs, PBowDocWgtBs BowDocWgtBs,
1028          const TStr& CatNm, const TIntV& TrainDIdV, const double& C,
1029          const double& j, const TSVMLearnParam& LearnParam) {
1030      PSVMTrainSet TrainSet = PrepareClsTrainSet(BowDocBs, BowDocWgtBs, CatNm, TrainDIdV);
1031      return TSVMModel::CrossValidCls(Folds, Seed, TrainSet, ker, C, j, TIntV(), LearnParam);
1032  }
1033  PBowMd TBowSVMMd::NewMultiClsLinear(const PBowDocBs& BowDocBs, PBowDocWgtBs BowDocWgtBs,
1034          const TIntV& TrainDIdV, const double& C, const double& j,
1035          const bool& SampleNegP, const TSVMLearnParam& LearnParam) {
1036      const int Cats = BowDocBs->GetCats(); TBowMdV BowMdV(Cats, 0);
1037      for (int CatN = 0; CatN < Cats; CatN++) {
1038          const TStr& CatNm = BowDocBs->GetCatNm(CatN);
1039          PSVMTrainSet TrainSet = PrepareClsTrainSet(BowDocBs,
1040              BowDocWgtBs, CatNm, TrainDIdV, (SampleNegP ? j : -1.0));
1041          printf("(%4d/ %4d (Docs: %9d\r) ", CatN+1, Cats, TrainSet->Len());
1042          PSVMModel Model = TSVMModel::NewClsLinear(
1043              TrainSet, C, j, TIntV(), LearnParam);
1044          Model->MakeProb(TrainSet);
1045          BowMdV.Add(TBowSVMMd::New(BowDocBs, CatNm, Model));
1046      } printf("\n");
1047      return new TBowMultiMd(BowDocBs, BowMdV);
1048  }
1049  TCfyRes TBowSVMMd::CrossValidMultiClsLinear(const int& Folds, const int& Seed,
1050          const PBowDocBs& BowDocBs, PBowDocWgtBs BowDocWgtBs, const double& C,
1051          const double& j, const bool& SampleNegP, const TSVMLearnParam& LearnParam) {
1052      TIntV AllDIdV; BowDocBs->GetAllDIdV(AllDIdV); AllDIdV.Sort();
1053      TIntPrV CIdDIdV; const int DIds = AllDIdV.Len();
1054      for (int DIdN = 0; DIdN < DIds; DIdN++) {
1055          const int DId = AllDIdV[DIdN];
1056          const int CIds = BowDocBs->GetDocCIds(DId);
1057          for (int CIdN = 0; CIdN < CIds; CIdN++) {
1058              const int CId = BowDocBs->GetDocCId(DId, CIdN);
1059              CIdDIdV.Add(TIntPr(CId, DId));
1060          }
1061      }
1062      CIdDIdV.Sort();
1063      TVec<TIntV> FoldV(Folds); int FoldN = 0;
1064      for (int CIdDIdN = 0; CIdDIdN < CIdDIdV.Len(); CIdDIdN++) {
1065          const int DId = CIdDIdV[CIdDIdN].Val2;
1066          FoldV[FoldN].Add(DId);
1067          FoldN++;
1068          if (FoldN >= Folds) { FoldN = 0; }
1069      }
1070      for (int FoldN = 0; FoldN < Folds; FoldN++) { FoldV[FoldN].Sort(); }
1071      const int Cats = BowDocBs->GetCats(); TBowMdV BowMdV(Cats, 0);
1072      TVec<TCountCfyRes> CatCfyResV(Cats);
1073      for (int FoldN = 0; FoldN < Folds; FoldN++) {
1074          printf("Fold %d ...\n", FoldN+1);
1075          TIntV TestDIdV = FoldV[FoldN];
1076          TIntV TrainDIdV; AllDIdV.Minus(TestDIdV, TrainDIdV);
1077          PBowMd FoldBowMd = TBowSVMMd::NewMultiClsLinear(BowDocBs,
1078              BowDocWgtBs, TrainDIdV, C, j, SampleNegP, LearnParam);
1079          for (int TestDIdN = 0; TestDIdN < TestDIdV.Len(); TestDIdN++) {
1080              const int TestDId = TestDIdV[TestDIdN];
1081              TFltStrPrV WgtCatNmV;
1082              FoldBowMd->GetCfy(BowDocWgtBs->GetSpV(TestDId), WgtCatNmV);
1083              TIntH PredCIdH;
1084              if (!WgtCatNmV.Empty()) {
1085                  PredCIdH.AddKey(BowDocBs->GetCId(WgtCatNmV[0].Val2)); }
1086              const int CIds = BowDocBs->GetDocCIds(TestDId);
1087              for (int CIdN = 0; CIdN < CIds; CIdN++) {
1088                  const int CId = BowDocBs->GetDocCId(TestDId, CIdN);
1089                  if (PredCIdH.IsKey(CId)) {
1090                      CatCfyResV[CId].Add(1.0, 1.0);
1091                      PredCIdH.DelKey(CId);
1092                  } else {
1093                      CatCfyResV[CId].Add(-1.0, 1.0);
1094                  }
1095              }
1096              if (!PredCIdH.Empty()) {
1097                  int KeyId = PredCIdH.FFirstKeyId();
1098                  while (PredCIdH.FNextKeyId(KeyId)) {
1099                      const int CId = PredCIdH.GetKey(KeyId);
1100                      CatCfyResV[CId].Add(1.0, -1.0);
1101                  }
1102              }
1103          }
1104      }
1105      return TCountCfyRes::ToMacroTCfyRes(CatCfyResV);
1106  }
1107  PBowMd TBowSVMMd::NewOneClassLinear(const PBowDocBs& BowDocBs,
1108          PBowDocWgtBs BowDocWgtBs, const TStr& CatNm, const TIntV& TrainDIdV,
1109          const double& nu, const TSVMLearnParam& LearnParam) {
1110      PSVMTrainSet TrainSet = PrepareOneClassTrainSet(BowDocBs, BowDocWgtBs, CatNm, TrainDIdV);
1111      PSVMModel Model = TSVMModel::NewOneClassLinear(TrainSet, nu, TIntV(), LearnParam);
1112      return TBowSVMMd::New(BowDocBs, CatNm, Model);
1113  }
1114  PBowMd TBowSVMMd::NewOneClass(const PKernel& ker, const PBowDocBs& BowDocBs,
1115          PBowDocWgtBs BowDocWgtBs, const TStr& CatNm, const TIntV& TrainDIdV,
1116          const double& nu, const TSVMLearnParam& LearnParam) {
1117      PSVMTrainSet TrainSet = PrepareOneClassTrainSet(BowDocBs, BowDocWgtBs, CatNm, TrainDIdV);
1118      PSVMModel Model = TSVMModel::NewOneClass(TrainSet, ker, nu, TIntV(), LearnParam);
1119      return TBowSVMMd::New(BowDocBs, CatNm, Model);
1120  }
1121  TCfyRes TBowSVMMd::CrossValidOneClassLinear(const int& Folds, const int&Seed,
1122          const PBowDocBs& BowDocBs, PBowDocWgtBs BowDocWgtBs, const TStr& CatNm,
1123          const TIntV& TrainDIdV, const double& nu, const TSVMLearnParam& LearnParam) {
1124      PSVMTrainSet TrainSet = PrepareClsTrainSet(BowDocBs, BowDocWgtBs, CatNm, TrainDIdV);
1125      return TSVMModel::CrossValidOneClassLinear(Folds, Seed, TrainSet, nu, TIntV(), LearnParam);
1126  }
1127  TCfyRes TBowSVMMd::CrossValidOneClass(const int& Folds, const int&Seed,
1128          const PKernel& ker, const PBowDocBs& BowDocBs, PBowDocWgtBs BowDocWgtBs,
1129          const TStr& CatNm, const TIntV& TrainDIdV, const double& nu,
1130          const TSVMLearnParam& LearnParam) {
1131      PSVMTrainSet TrainSet = PrepareClsTrainSet(BowDocBs, BowDocWgtBs, CatNm, TrainDIdV);
1132      return TSVMModel::CrossValidOneClass(Folds, Seed, TrainSet, ker, nu, TIntV(), LearnParam);
1133  }
1134  PBowSpV TBowSVMMd::GetKeywords(const PBowDocBs& BowDocBs, const TIntV& TrainDIdV,
1135          const TIntV& CatDIdV, const int WdN, const double& C, const double& j,
1136          const int& Time, const TBowWordWgtType& SvmWordWgtType, const double& VecSign,
1137          const double& WgtSign, const bool& AvgOverSet) {
1138      PBowDocWgtBs BowDocWgtBs = TBowDocWgtBs::New(BowDocBs, SvmWordWgtType);
1139      PSVMTrainSet TrainSet = PrepareClsTrainSet(BowDocBs, BowDocWgtBs, TrainDIdV, CatDIdV);
1140      PSVMModel Model = TSVMModel::NewClsLinear(TrainSet, C, j, TIntV(), TSVMLearnParam::Lin(Time));
1141      return GetKeywords(TrainSet, Model, WdN, VecSign, WgtSign, AvgOverSet);
1142  }
1143  PBowSpV TBowSVMMd::GetKeywords(const PBowDocBs& BowDocBs, PBowDocWgtBs BowDocWgtBs,
1144          const TIntV& TrainDIdV, const TIntV& CatDIdV, const int WdN, const double& C,
1145          const double& j, const int& Time, const double& VecSign, const double& WgtSign,
1146          const bool& AvgOverSet) {
1147      PSVMTrainSet TrainSet = PrepareClsTrainSet(BowDocBs, BowDocWgtBs, TrainDIdV, CatDIdV);
1148      PSVMModel Model = TSVMModel::NewClsLinear(TrainSet, C, j, TIntV(), TSVMLearnParam::Lin(Time));
1149      return GetKeywords(TrainSet, Model, WdN, VecSign, WgtSign, AvgOverSet);
1150  }
1151  PBowSpV TBowSVMMd::GetKeywords(const PBowDocBs& BowDocBs, const TIntV& TrainDIdV,
1152          const TStr& CatNm, const int WdN, const double& C, const double& j,
1153          const int& Time, const TBowWordWgtType& SvmWordWgtType, const double& VecSign,
1154          const double& WgtSign, const bool& AvgOverSet) {
1155      PBowDocWgtBs BowDocWgtBs = TBowDocWgtBs::New(BowDocBs, SvmWordWgtType);
1156      PSVMTrainSet TrainSet = PrepareClsTrainSet(BowDocBs, BowDocWgtBs, CatNm, TrainDIdV);
1157      PSVMModel Model = TSVMModel::NewClsLinear(TrainSet, C, j, TIntV(), TSVMLearnParam::Lin(Time));
1158      return GetKeywords(TrainSet, Model, WdN, VecSign, WgtSign, AvgOverSet);
1159  }
1160  PBowSpV TBowSVMMd::GetKeywords(const PBowDocBs& BowDocBs, PBowDocWgtBs BowDocWgtBs,
1161          const TIntV& TrainDIdV, const TStr& CatNm, const int WdN, const double& C,
1162          const double& j, const int& Time, const double& VecSign, const double& WgtSign,
1163          const bool& AvgOverSet) {
1164      PSVMTrainSet TrainSet = PrepareClsTrainSet(BowDocBs, BowDocWgtBs, CatNm, TrainDIdV);
1165      PSVMModel Model = TSVMModel::NewClsLinear(TrainSet, C, j, TIntV(), TSVMLearnParam::Lin(Time));
1166      return GetKeywords(TrainSet, Model, WdN, VecSign, WgtSign, AvgOverSet);
1167  }
1168  void TSVMTrainSetCsv::TFtrGen::AddWds(const TStr& Prefix,
1169          const PBowDocBs& BowDocBs, int& Offset) const {
1170      const int Vals = GetVals();
1171      for (int ValN = 0; ValN < Vals; ValN++) {
1172          const int WId = BowDocBs->AddWordStr(
1173              TStr::Fmt("%s-%s", Prefix.CStr(), GetVal(ValN).CStr()));
1174          IAssert(Offset == WId); Offset++;
1175      }
1176  }
1177  TStr TSVMTrainSetCsv::TFtrGenNumeric::Type = "NUM";
1178  double TSVMTrainSetCsv::TFtrGenNumeric::Trans(const double& Val) const {
1179          return MnVal != MxVal ? (double(Val) - MnVal) / (MxVal - MnVal) : 0.0;
1180  }
1181  double TSVMTrainSetCsv::TFtrGenNumeric::GetFlt(const TStr& Str) const {
1182      double Val = 0.0;
1183      if (!Str.IsFlt(Val)) {
1184          TExcept::Throw(TStr::Fmt("Number expected  but '%s' found!", Str.CStr())); }
1185      return Val;
1186  }
1187  void TSVMTrainSetCsv::TFtrGenNumeric::Update(const TStr& Val) {
1188      double Flt = GetFlt(Val);
1189      MnVal = TFlt::GetMn(MnVal, Flt);
1190      MxVal = TFlt::GetMx(MxVal, Flt);
1191  }
1192  void TSVMTrainSetCsv::TFtrGenNumeric::Add(
1193          const TStr& Val, TIntFltKdV& SpV, int& Offset) const {
1194      double Flt = GetFlt(Val);
1195      SpV.Add(TIntFltKd(Offset, Trans(Flt)));
1196      Offset++;
1197  }
1198  TStr TSVMTrainSetCsv::TFtrGenNominal::Type = "NOM";
1199  void TSVMTrainSetCsv::TFtrGenNominal::Update(const TStr& Val) {
1200      if (!Val.Empty()) { ValH.AddKey(Val); }
1201  }
1202  void TSVMTrainSetCsv::TFtrGenNominal::Add(
1203          const TStr& Val, TIntFltKdV& SpV, int& Offset) const {
1204      if (ValH.IsKey(Val)) {
1205          SpV.Add(TIntFltKd(Offset + ValH.GetKeyId(Val), 1.0));
1206      }
1207      Offset += ValH.Len();
1208  }
1209  TStr TSVMTrainSetCsv::TFtrGenToken::Type = "TOK";
1210  void TSVMTrainSetCsv::TFtrGenToken::GetTokenV(
1211          const TStr& Str, TStrV& TokenStrV) const {
1212      THtmlLx HtmlLx(TStrIn::New(Str));
1213      while (HtmlLx.Sym != hsyEof){
1214          if (HtmlLx.Sym == hsyStr){
1215              TStr TokenStr = HtmlLx.UcChA;
1216              if (SwSet.Empty() || !SwSet->IsIn(TokenStr)) {
1217                  if (!Stemmer.Empty()) {
1218                      TokenStr = Stemmer->GetStem(TokenStr); }
1219                  TokenStrV.Add(TokenStr);
1220              }
1221          }
1222          HtmlLx.GetSym();
1223      }
1224  }
1225  void TSVMTrainSetCsv::TFtrGenToken::Update(const TStr& Val) {
1226      TStrV TokenStrV; GetTokenV(Val, TokenStrV);
1227      for (int TokenStrN = 0; TokenStrN < TokenStrV.Len(); TokenStrN++) {
1228          const TStr& TokenStr = TokenStrV[TokenStrN];
1229          TokenH.AddDat(TokenStr)++;
1230      }
1231      Docs++;
1232  }
1233  void TSVMTrainSetCsv::TFtrGenToken::Add(
1234          const TStr& Val, TIntFltKdV& SpV, int& Offset) const {
1235      TStrV TokenStrV; GetTokenV(Val, TokenStrV);
1236      TIntH TokenFqH;
1237      for (int TokenStrN = 0; TokenStrN < TokenStrV.Len(); TokenStrN++) {
1238          const TStr& TokenStr = TokenStrV[TokenStrN];
1239          if (TokenH.IsKey(TokenStr)) {
1240              const int TokenId = TokenH.GetKeyId(TokenStr);
1241              TokenFqH.AddDat(TokenId)++;
1242          }
1243      }
1244      TIntFltKdV ValSpV(TokenFqH.Len(), 0);
1245      int KeyId = TokenFqH.FFirstKeyId();
1246      while (TokenFqH.FNextKeyId(KeyId)) {
1247          const int TokenId = TokenFqH.GetKey(KeyId);
1248          const int TokenFq = TokenFqH[KeyId];
1249          const int TokenDocFq = TokenH[TokenId];
1250          const double IDF = log(double(Docs) / double(TokenDocFq));
1251          ValSpV.Add(TIntFltKd(TokenId, double(TokenFq) * IDF));
1252      }
1253      ValSpV.Sort(); TLinAlg::NormalizeL1(ValSpV);
1254      for (int ValSpN = 0; ValSpN < ValSpV.Len(); ValSpN++) {
1255          const int Key = ValSpV[ValSpN].Key + Offset;
1256          const double Dat = ValSpV[ValSpN].Dat;
1257          SpV.Add(TIntFltKd(Key, Dat));
1258      }
1259      Offset += TokenH.Len();
1260  }
1261  TStr TSVMTrainSetCsv::TFtrGenSparseNumeric::Type = "SP-NUM";
1262  void TSVMTrainSetCsv::TFtrGenSparseNumeric::Split(
1263          const TStr& Str, int& Id, TStr& Val) const {
1264      if (!Str.IsChIn(':')) { TExcept::Throw("Wrong sparse numeric '" + Str + "'!"); }
1265      TStr IdStr; Str.SplitOnCh(IdStr, ':', Val);
1266      if (!IdStr.IsInt(Id)) { TExcept::Throw("Wrong sparse numeric '" + Str + "'!"); }
1267  }
1268  void TSVMTrainSetCsv::TFtrGenSparseNumeric::Update(const TStr& Str) {
1269      TStrV EltV; Str.SplitOnAllCh(';', EltV);
1270      for (int EltN = 0; EltN < EltV.Len(); EltN++) {
1271          int Id; TStr Val; Split(EltV[EltN], Id, Val);
1272          MxId = TInt::GetMx(Id, MxId);
1273          FtrGen.Update(Val);
1274      }
1275  }
1276  void TSVMTrainSetCsv::TFtrGenSparseNumeric::Add(
1277          const TStr& Str, TIntFltKdV& SpV, int& Offset) const {
1278      TStrV EltV; Str.SplitOnAllCh(';', EltV); TIntH UsedIdH;
1279      for (int EltN = 0; EltN < EltV.Len(); EltN++) {
1280          int Id; TStr Val; Split(EltV[EltN], Id, Val);
1281          EAssertR(!UsedIdH.IsKey(Id), "Field ID repeated in '" + Str + "'!");
1282          int TmpOffset = Offset + Id;
1283          FtrGen.Add(Val, SpV, TmpOffset);
1284          UsedIdH.AddKey(Id);
1285      }
1286      Offset += GetVals();
1287  }
1288  TStr TSVMTrainSetCsv::TFtrGenSparseNumeric::GetVal(const int& ValN) const {
1289      const int FtrGenId = ValN / FtrGen.GetVals();
1290      const int FtrGenValN = ValN % FtrGen.GetVals();
1291      return TStr::Fmt("SP-%d-%d-%s", FtrGenId,
1292          FtrGenValN, FtrGen.GetVal(FtrGenValN).CStr());
1293  }
1294  TStr TSVMTrainSetCsv::TFtrGenMultiNom::Type = "MULTI-NOM";
1295  void TSVMTrainSetCsv::TFtrGenMultiNom::Update(const TStr& Str) {
1296      TStrV EltV; Str.SplitOnAllCh(';', EltV);
1297      for (int EltN = 0; EltN < EltV.Len(); EltN++) {
1298          FtrGen.Update(EltV[EltN]);
1299      }
1300  }
1301  void TSVMTrainSetCsv::TFtrGenMultiNom::Add(
1302          const TStr& Str, TIntFltKdV& SpV, int& Offset) const {
1303      TStrV EltV; Str.SplitOnAllCh(';', EltV);
1304      for (int EltN = 0; EltN < EltV.Len(); EltN++) {
1305          int TmpOffset = Offset;
1306          FtrGen.Add(EltV[EltN], SpV, TmpOffset);
1307      }
1308      Offset += GetVals();
1309  }
1310  TStr TSVMTrainSetCsv::TFtrGenMultiNom::GetVal(const int& ValN) const {
1311      return TStr::Fmt("MULTI-%d-%s", ValN, FtrGen.GetVal(ValN).CStr());
1312  }
1313  void TSVMTrainSetCsv::TFtrGenMultiNom::GetValV(const TStr& Str, TStrV& ValV) const {
1314      TStrV EltV; Str.SplitOnAllCh(';', EltV); ValV.Clr();
1315      for (int EltN = 0; EltN < EltV.Len(); EltN++) {
1316          const TStr& Val = EltV[EltN];
1317          TStrV SubValV; FtrGen.GetValV(Val, SubValV);
1318          ValV.AddV(SubValV);
1319      }
1320  }
1321  PBowDocBs TSVMTrainSetCsv::LoadCsv(TStr& FNm, const int& ClassId,
1322          const TIntV& IgnoreIdV, const int& TrainLen) {
1323      THash<TInt, PFtrGen> FtrGenH;
1324      PFtrGen ClassFtrGen;
1325      PSIn SIn = TFIn::New(FNm);
1326      char SsCh = ' '; TStrV FldValV;
1327      TSs::LoadTxtFldV(ssfCommaSep, SIn, SsCh, FldValV, false);
1328      for (int FldValN = 0; FldValN < FldValV.Len(); FldValN++) {
1329          const TStr& FldVal = FldValV[FldValN];
1330          if (FldValN == ClassId) {
1331              if (FldVal == "NOM") {
1332                  ClassFtrGen = TFtrGenNominal::New();
1333              } else if (FldVal == "MULTI-NOM") {
1334                  ClassFtrGen = TFtrGenMultiNom::New();
1335              } else {
1336                  TExcept::Throw("Wrong class type '" + FldVal + "', should be NOM or MULTI-NOM!");
1337              }
1338          } else if (!IgnoreIdV.IsIn(FldValN)) {
1339              if (FldVal == TFtrGenNumeric::Type) {
1340                  FtrGenH.AddDat(FldValN, TFtrGenNumeric::New());
1341              } else if (FldVal == TFtrGenNominal::Type) {
1342                  FtrGenH.AddDat(FldValN, TFtrGenNominal::New());
1343              } else if (FldVal == TFtrGenToken::Type) {
1344                  FtrGenH.AddDat(FldValN, TFtrGenToken::New(
1345                      TSwSet::New(swstNone), TStemmer::New(stmtNone)));
1346              } else if (FldVal == TFtrGenSparseNumeric::Type) {
1347                  FtrGenH.AddDat(FldValN, TFtrGenSparseNumeric::New());
1348              } else if (FldVal == TFtrGenMultiNom::Type) {
1349                  FtrGenH.AddDat(FldValN, TFtrGenMultiNom::New());
1350              } else {
1351                  TExcept::Throw("Wrong type '" + FldVal + "'!");
1352              }
1353          }
1354      }
1355      const int Flds = FldValV.Len();
1356      int Recs = 0;
1357      while (!SIn->Eof()) {
1358          if (Recs == TrainLen) { break; }
1359          Recs++; printf("%7d\r", Recs);
1360          TSs::LoadTxtFldV(ssfCommaSep, SIn, SsCh, FldValV, false);
1361          EAssertR(FldValV.Len() == Flds,
1362              TStr::Fmt("Wrong number of fields in line %d! Found %d and expected %d!",
1363              Recs + 1, FldValV.Len(), Flds));
1364          try {
1365              for (int FldValN = 0; FldValN < FldValV.Len(); FldValN++) {
1366                  const TStr& FldVal = FldValV[FldValN];
1367                  if (FldValN == ClassId) {
1368                      ClassFtrGen->Update(FldVal);
1369                  } else if (FtrGenH.IsKey(FldValN)) {
1370                      PFtrGen FtrGen = FtrGenH.GetDat(FldValN);
1371                      FtrGen->Update(FldVal);
1372                  }
1373              }
1374          } catch (PExcept Ex) {
1375              TExcept::Throw(TStr::Fmt("Error in line %d: '%s'!",
1376                  Recs+1, Ex->GetMsgStr().CStr()));
1377          }
1378      }
1379      PBowDocBs BowDocBs = TBowDocBs::New();
1380      int WdsOffset = 0;
1381      for (int FtrGenId = 0; FtrGenId < FtrGenH.Len(); FtrGenId++) {
1382          PFtrGen FtrGen = FtrGenH[FtrGenId];
1383          TStr Prefix = FtrGenH.GetKey(FtrGenId).GetStr();
1384          FtrGen->AddWds(Prefix, BowDocBs, WdsOffset);
1385      }
1386      SIn = TFIn::New(FNm); SsCh = ' ';
1387      TSs::LoadTxtFldV(ssfCommaSep, SIn, SsCh, FldValV, false);
1388      Recs = 0;
1389      while (!SIn->Eof()){
1390          Recs++; printf("%7d\r", Recs);
1391          TSs::LoadTxtFldV(ssfCommaSep, SIn, SsCh, FldValV, false);
1392          EAssertR(FldValV.Len() == Flds,
1393              TStr::Fmt("Wrong number of fields in line %s! Found %d and expected %d!",
1394              Recs + 1, FldValV.Len(), Flds));
1395          TIntFltKdV FtrSpV; TStrV CatNmV; int Offset = 0;
1396          try {
1397              for (int FldValN = 0; FldValN < FldValV.Len(); FldValN++) {
1398                  const TStr& FldVal = FldValV[FldValN];
1399                  if (FldValN == ClassId) {
1400                      ClassFtrGen->GetValV(FldVal, CatNmV);
1401                  } else if (FtrGenH.IsKey(FldValN)) {
1402                      PFtrGen FtrGen = FtrGenH.GetDat(FldValN);
1403                      FtrGen->Add(FldVal, FtrSpV, Offset);
1404                  }
1405              }
1406          } catch (PExcept Ex) {
1407              TExcept::Throw(TStr::Fmt("Error in line %d: '%s'!",
1408                  Recs+1, Ex->GetMsgStr().CStr()));
1409          }
1410          const int WIds = FtrSpV.Len();
1411          TIntFltPrV WIdWgtPrV(WIds, 0);
1412          for (int WIdN = 0; WIdN < WIds; WIdN++) {
1413              WIdWgtPrV.Add(TIntFltPr(FtrSpV[WIdN].Key, FtrSpV[WIdN].Dat));
1414          }
1415          BowDocBs->AddDoc(TStr::Fmt("Line-%d", Recs), CatNmV, WIdWgtPrV);
1416      }
1417      return BowDocBs;
1418  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-osdetect.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-svmmodels.cpp</div>
                </div>
                <div class="column column_space"><pre><code>314      if (f == 0.0f) {
315        f = worst_score;
316        total_blob_o_score += worst_score;
317      }
318    }
319    for (int i = 0; total_blob_o_score != 0 && i < 4; ++i) {
</pre></code></div>
                <div class="column column_space"><pre><code>14          while (DocN < Len && FoldN < Folds) {
15              DIdVFoldV[FoldN].Add(DIdV[DocN]);
16              FoldN++; DocN++;
17          }
18      }
19      DIdV.Sort();
20      for (int FoldN = 0; FoldN < Folds; FoldN++) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    