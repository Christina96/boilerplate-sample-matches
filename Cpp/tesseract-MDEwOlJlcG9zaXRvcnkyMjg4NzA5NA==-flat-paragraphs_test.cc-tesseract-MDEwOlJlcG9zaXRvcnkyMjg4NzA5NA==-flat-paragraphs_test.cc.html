
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 19, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-paragraphs_test.cc</h3>
            <pre><code>1  #include <string> 
2  #include "include_gunit.h" 
3  #include "log.h"           
4  #include "paragraphs.h"
5  #include "paragraphs_internal.h"
6  #include "ocrpara.h"
7  namespace tesseract {
8  const ParagraphJustification kLeft = JUSTIFICATION_LEFT;
9  const ParagraphJustification kCenter = JUSTIFICATION_CENTER;
10  const ParagraphJustification kRight = JUSTIFICATION_RIGHT;
11  const ParagraphJustification kUnknown = JUSTIFICATION_UNKNOWN;
12  enum TextModelInputType {
13    PCONT = 0,  
14    PSTART = 1, 
15    PNONE = 2,  
16  };
17  struct TextAndModel {
18    const char *ascii;
19    TextModelInputType model_type;
20    ParagraphModel model;
21    bool is_very_first_or_continuation;
22    bool is_list_item;
23  };
24  void AsciiToRowInfo(const char *text, int row_number, RowInfo *info) {
25    const int kCharWidth = 10;
26    const int kLineSpace = 30;
27    info->text = text;
28    info->has_leaders = strstr(text, "...") != nullptr || strstr(text, ". . .") != nullptr;
29    info->has_drop_cap = false;
30    info->pix_ldistance = info->pix_rdistance = 0;
31    info->average_interword_space = kCharWidth;
32    info->pix_xheight = kCharWidth;
33    info->lword_text = info->rword_text = "";
34    info->ltr = true;
35    std::vector<std::string> words = split(text, ' ');
36    info->num_words = words.size();
37    if (info->num_words < 1) {
38      return;
39    }
40    info->lword_text = words[0].c_str();
41    info->rword_text = words[words.size() - 1].c_str();
42    int lspace = 0;
43    while (lspace < info->text.size() && text[lspace] == ' ') {
44      lspace++;
45    }
46    int rspace = 0;
47    while (rspace < info->text.size() && text[info->text.size() - rspace - 1] == ' ') {
48      rspace++;
49    }
50    int top = -kLineSpace * row_number;
51    int bottom = top - kLineSpace;
52    int row_right = kCharWidth * info->text.size();
53    int lword_width = kCharWidth * info->lword_text.size();
54    int rword_width = kCharWidth * info->rword_text.size();
55    info->pix_ldistance = lspace * kCharWidth;
56    info->pix_rdistance = rspace * kCharWidth;
57    info->lword_box = TBOX(info->pix_ldistance, bottom, info->pix_ldistance + lword_width, top);
58    info->rword_box = TBOX(row_right - info->pix_rdistance - rword_width, bottom,
59                           row_right - info->pix_rdistance, top);
60    LeftWordAttributes(nullptr, nullptr, info->lword_text, &info->lword_indicates_list_item,
61                       &info->lword_likely_starts_idea, &info->lword_likely_ends_idea);
62    RightWordAttributes(nullptr, nullptr, info->rword_text, &info->rword_indicates_list_item,
63                        &info->rword_likely_starts_idea, &info->rword_likely_ends_idea);
64  }
65  void MakeAsciiRowInfos(const TextAndModel *row_infos, int n, std::vector<RowInfo> *output) {
66    output->clear();
67    RowInfo info;
68    for (int i = 0; i < n; i++) {
69      AsciiToRowInfo(row_infos[i].ascii, i, &info);
70      output->push_back(info);
71    }
72  }
73  void EvaluateParagraphDetection(const TextAndModel *correct, int n,
74                                  const std::vector<PARA *> &detector_output) {
75    int incorrect_breaks = 0;
76    int missed_breaks = 0;
77    int poorly_matched_models = 0;
78    int bad_crowns = 0;
79    int bad_list_items = 0;
80    ASSERT_EQ(detector_output.size(), n);
81    for (int i = 1; i < n; i++) {
82      bool has_break = correct[i].model_type != PCONT;
83      bool detected_break = (detector_output[i - 1] != detector_output[i]);
84      if (has_break && !detected_break) {
85        missed_breaks++;
86      }
87      if (detected_break && !has_break) {
88        incorrect_breaks++;
89      }
90      if (has_break) {
91        if (correct[i].model_type == PNONE) {
92          if (detector_output[i]->model != nullptr) {
93            poorly_matched_models++;
94          }
95        } else {
96          if (correct[i].model.justification() != kUnknown &&
97              (detector_output[i]->model == nullptr ||
98               !correct[i].model.Comparable(*detector_output[i]->model))) {
99            poorly_matched_models++;
100          }
101        }
102        if (correct[i].is_very_first_or_continuation ^
103            detector_output[i]->is_very_first_or_continuation) {
104          bad_crowns++;
105        }
106        if (correct[i].is_list_item ^ detector_output[i]->is_list_item) {
107          bad_list_items++;
108        }
109      }
110    }
111    EXPECT_EQ(incorrect_breaks, 0);
112    EXPECT_EQ(missed_breaks, 0);
113    EXPECT_EQ(poorly_matched_models, 0);
114    EXPECT_EQ(bad_list_items, 0);
115    EXPECT_EQ(bad_crowns, 0);
116    if (incorrect_breaks || missed_breaks || poorly_matched_models || bad_list_items || bad_crowns) {
117      std::vector<std::string> dbg_lines;
118      dbg_lines.emplace_back("# ==========================");
119      dbg_lines.emplace_back("# Correct paragraph breaks:");
120      dbg_lines.emplace_back("# ==========================");
121      for (int i = 0; i < n; i++) {
122        if (correct[i].model_type != PCONT) {
123          std::string s = std::string(correct[i].ascii) + "  #  " +
124                          correct[i].model.ToString() +
125                          (correct[i].is_very_first_or_continuation ? " crown" : "") +
126                          (correct[i].is_list_item ? " li" : "");
127          dbg_lines.push_back(s);
128        } else {
129          dbg_lines.emplace_back(correct[i].ascii);
130        }
131      }
132      dbg_lines.emplace_back("");
133      dbg_lines.emplace_back("# ==========================");
134      dbg_lines.emplace_back("# Paragraph detector output:");
135      dbg_lines.emplace_back("# ==========================");
136      for (int i = 0; i < n; i++) {
137        std::string annotation;
138        if (i == 0 || (detector_output[i - 1] != detector_output[i])) {
139          if (detector_output[i] && detector_output[i]->model) {
140            annotation +=
141                "  #  " + detector_output[i]->model->ToString() +
142                (detector_output[i]->is_very_first_or_continuation ? " crown" : "") +
143                (detector_output[i]->is_list_item ? " li" : "");
144          } else {
145            annotation = "  #  Unmodeled paragraph.";
146          }
147        }
148        std::string s = correct[i].ascii + annotation;
149        dbg_lines.push_back(s);
150      }
151      std::string s;
152      for (auto &dbg_line : dbg_lines) {
153        s += dbg_line + "\n";
154      }
155      LOG(INFO) << "Discrepancy!\n" << s;
156    }
157  }
158  void TestParagraphDetection(const TextAndModel *correct, int num_rows) {
159    std::vector<RowInfo> row_infos;
160    std::vector<PARA *> row_owners;
161    PARA_LIST paragraphs;
162    std::vector<ParagraphModel *> models;
163    MakeAsciiRowInfos(correct, num_rows, &row_infos);
164    int debug_level(3);
<span onclick='openModal()' class='match'>165    tesseract::DetectParagraphs(debug_level, &row_infos, &row_owners, &paragraphs, &models);
166    EvaluateParagraphDetection(correct, num_rows, row_owners);
</span>167    for (auto *model : models) {
168      delete model;
169    }
170  }
171  TEST(ParagraphsTest, ListItemsIdentified) {
172    EXPECT_TRUE(tesseract::AsciiLikelyListItem("iii"));
173    EXPECT_TRUE(tesseract::AsciiLikelyListItem("A."));
174    EXPECT_TRUE(tesseract::AsciiLikelyListItem("B."));
175    EXPECT_TRUE(tesseract::AsciiLikelyListItem("C."));
176    EXPECT_TRUE(tesseract::AsciiLikelyListItem("1."));
177    EXPECT_TRUE(tesseract::AsciiLikelyListItem("2."));
178    EXPECT_TRUE(tesseract::AsciiLikelyListItem("3."));
179    EXPECT_TRUE(tesseract::AsciiLikelyListItem("1"));
180    EXPECT_TRUE(tesseract::AsciiLikelyListItem("2"));
181    EXPECT_TRUE(tesseract::AsciiLikelyListItem("3"));
182    EXPECT_TRUE(tesseract::AsciiLikelyListItem("[[1]]"));
183    EXPECT_TRUE(tesseract::AsciiLikelyListItem("A-1."));
184    EXPECT_TRUE(tesseract::AsciiLikelyListItem("A-2"));
185    EXPECT_TRUE(tesseract::AsciiLikelyListItem("(A)(i)"));
186    EXPECT_FALSE(tesseract::AsciiLikelyListItem("The"));
187    EXPECT_FALSE(tesseract::AsciiLikelyListItem("first"));
188    EXPECT_FALSE(tesseract::AsciiLikelyListItem("house"));
189    EXPECT_FALSE(tesseract::AsciiLikelyListItem("Oregonian."));
190    EXPECT_FALSE(tesseract::AsciiLikelyListItem("on."));
191  }
192  typedef ParagraphModel PModel;
193  const TextAndModel kTwoSimpleParagraphs[] = {
194      {"  Look here, I have a paragraph.", PSTART, PModel(kLeft, 0, 20, 0, 0), false, false},
195      {"This paragraph starts at the top", PCONT, PModel(), false, false},
196      {"of the page and takes 3 lines.  ", PCONT, PModel(), false, false},
197      {"  Here I have a second paragraph", PSTART, PModel(kLeft, 0, 20, 0, 0), false, false},
198      {"which indicates that the first  ", PCONT, PModel(), false, false},
199      {"paragraph is not a continuation ", PCONT, PModel(), false, false},
200      {"from a previous page, as it is  ", PCONT, PModel(), false, false},
201      {"indented just like this second  ", PCONT, PModel(), false, false},
202      {"paragraph.                      ", PCONT, PModel(), false, false},
203  };
204  TEST(ParagraphsTest, TestSimpleParagraphDetection) {
205    TestParagraphDetection(kTwoSimpleParagraphs, countof(kTwoSimpleParagraphs));
206  }
207  const TextAndModel kFewCluesWithCrown[] = {
208      {"This paragraph starts at the top", PSTART, PModel(kLeft, 0, 20, 0, 0), true, false},
209      {"of the page and takes two lines.", PCONT, PModel(), false, false},
210      {"  Here I have a second paragraph", PSTART, PModel(kLeft, 0, 20, 0, 0), false, false},
211      {"which indicates that the first  ", PCONT, PModel(), false, false},
212      {"paragraph is a continuation from", PCONT, PModel(), false, false},
213      {"a previous page, as it is       ", PCONT, PModel(), false, false},
214      {"indented just like this second  ", PCONT, PModel(), false, false},
215      {"paragraph.                      ", PCONT, PModel(), false, false},
216  };
217  TEST(ParagraphsTest, TestFewCluesWithCrown) {
218    TestParagraphDetection(kFewCluesWithCrown, countof(kFewCluesWithCrown));
219  }
220  const TextAndModel kCrownedParagraph[] = {
221      {"The first paragraph on a page is", PSTART, PModel(kLeft, 0, 20, 0, 0), true, false},
222      {"often not indented as the rest  ", PCONT, PModel(), false, false},
223      {"of the paragraphs are.  Nonethe-", PCONT, PModel(), false, false},
224      {"less it should be counted as the", PCONT, PModel(), false, false},
225      {"same type of paragraph.         ", PCONT, PModel(), false, false},
226      {"  The second and third para-    ", PSTART, PModel(kLeft, 0, 20, 0, 0), false, false},
227      {"graphs are both indented two    ", PCONT, PModel(), false, false},
228      {"spaces.                         ", PCONT, PModel(), false, false},
229      {"  The first paragraph has what  ", PSTART, PModel(kLeft, 0, 20, 0, 0), false, false},
230      {"fmt refers to as a 'crown.'     ", PCONT, PModel(), false, false},
231  };
232  TEST(ParagraphsTest, TestCrownParagraphDetection) {
233    TestParagraphDetection(kCrownedParagraph, countof(kCrownedParagraph));
234  }
235  const TextAndModel kFlushLeftParagraphs[] = {
236      {"It  is sometimes  the case  that", PSTART, PModel(kLeft, 0, 0, 0, 0), false, false},
237      {"flush  left   paragraphs  (those", PCONT, PModel(), false, false},
238      {"with  no  body  indent)  are not", PCONT, PModel(), false, false},
239      {"actually crowns.                ", PCONT, PModel(), false, false},
240      {"Instead,  further paragraphs are", PSTART, PModel(kLeft, 0, 0, 0, 0), false, false},
241      {"also flush left aligned.  Usual-", PCONT, PModel(), false, false},
242      {"ly,  these  paragraphs  are  set", PCONT, PModel(), false, false},
243      {"apart vertically  by some white-", PCONT, PModel(), false, false},
244      {"space,  but you can also  detect", PCONT, PModel(), false, false},
245      {"them by observing  the big empty", PCONT, PModel(), false, false},
246      {"space at the  ends  of the para-", PCONT, PModel(), false, false},
247      {"graphs.                         ", PCONT, PModel(), false, false},
248  };
249  TEST(ParagraphsText, TestRealFlushLeftParagraphs) {
250    TestParagraphDetection(kFlushLeftParagraphs, countof(kFlushLeftParagraphs));
251  }
252  const TextAndModel kSingleFullPageContinuation[] = {
253      {"sometimes a page is one giant", PSTART, PModel(kLeft, 0, 20, 0, 0), true, false},
254      {"continuation.  It flows  from", PCONT, PModel(), false, false},
255      {"line to  line, using the full", PCONT, PModel(), false, false},
256      {"column  width  with  no clear", PCONT, PModel(), false, false},
257      {"paragraph  break,  because it", PCONT, PModel(), false, false},
258      {"actually doesn't have one. It", PCONT, PModel(), false, false},
259      {"is the  middle of one monster", PCONT, PModel(), false, false},
260      {"paragraph continued  from the", PCONT, PModel(), false, false},
261      {"previous page and  continuing", PCONT, PModel(), false, false},
262      {"onto the  next  page.  There-", PCONT, PModel(), false, false},
263      {"fore,  it  ends  up   getting", PCONT, PModel(), false, false},
264      {"marked  as a  crown  and then", PCONT, PModel(), false, false},
265      {"getting re-marked as any  ex-", PCONT, PModel(), false, false},
266      {"isting model.  Not great, but", PCONT, PModel(), false, false},
267  };
268  TEST(ParagraphsTest, TestSingleFullPageContinuation) {
269    const TextAndModel *correct = kSingleFullPageContinuation;
270    int num_rows = countof(kSingleFullPageContinuation);
271    std::vector<RowInfo> row_infos;
272    std::vector<PARA *> row_owners;
273    PARA_LIST paragraphs;
274    std::vector<ParagraphModel *> models;
275    models.push_back(new ParagraphModel(kLeft, 0, 20, 0, 10));
276    MakeAsciiRowInfos(correct, num_rows, &row_infos);
277    tesseract::DetectParagraphs(3, &row_infos, &row_owners, &paragraphs, &models);
278    EvaluateParagraphDetection(correct, num_rows, row_owners);
279    for (auto *model : models) {
280      delete model;
281    }
282  }
283  const TextAndModel kRightAligned[] = {
284      {"Right-aligned paragraphs are", PSTART, PModel(kRight, 0, 0, 0, 0), false, false},
285      {"   uncommon in Left-to-Right", PCONT, PModel(), false, false},
286      {"      languages, but they do", PCONT, PModel(), false, false},
287      {"                      exist.", PCONT, PModel(), false, false},
288      {"    Mostly, however, they're", PSTART, PModel(kRight, 0, 0, 0, 0), false, false},
289      {" horribly tiny paragraphs in", PCONT, PModel(), false, false},
290      {"  tables on which we have no", PCONT, PModel(), false, false},
291      {"             chance anyways.", PCONT, PModel(), false, false},
292  };
293  TEST(ParagraphsTest, TestRightAlignedParagraph) {
294    TestParagraphDetection(kRightAligned, countof(kRightAligned));
295  }
296  const TextAndModel kTinyParagraphs[] = {
297      {"  Occasionally, interspersed with", PSTART, PModel(kLeft, 0, 20, 0, 0), false, false},
298      {"obvious paragraph text, you might", PCONT, PModel(), false, false},
299      {"find short exchanges of dialogue ", PCONT, PModel(), false, false},
300      {"between characters.              ", PCONT, PModel(), false, false},
301      {"  'Oh?'                          ", PSTART, PModel(kLeft, 0, 20, 0, 0), false, false},
302      {"  'Don't be confused!'           ", PSTART, PModel(kLeft, 0, 20, 0, 0), false, false},
303      {"  'Not me!'                      ", PSTART, PModel(kLeft, 0, 20, 0, 0), false, false},
304      {"  One naive approach would be to ", PSTART, PModel(kLeft, 0, 20, 0, 0), false, false},
305      {"mark a new paragraph whenever one", PCONT, PModel(), false, false},
306      {"of the statistics (left, right or", PCONT, PModel(), false, false},
307      {"center)  changes  from  one text-", PCONT, PModel(), false, false},
308      {"line  to  the  next.    Such   an", PCONT, PModel(), false, false},
309      {"approach  would  misclassify  the", PCONT, PModel(), false, false},
310      {"tiny paragraphs above as a single", PCONT, PModel(), false, false},
311      {"paragraph.                       ", PCONT, PModel(), false, false},
312  };
313  TEST(ParagraphsTest, TestTinyParagraphs) {
314    TestParagraphDetection(kTinyParagraphs, countof(kTinyParagraphs));
315  }
316  const TextAndModel kComplexPage1[] = {
317      {"       Awesome                  ", PSTART, PModel(kCenter, 0, 0, 0, 0), false, false},
318      {"   Centered Title               ", PCONT, PModel(), false, false},
319      {" Paragraph Detection            ", PCONT, PModel(), false, false},
320      {"      OCR TEAM                  ", PCONT, PModel(), false, false},
321      {"  10 November 2010              ", PCONT, PModel(), false, false},
322      {"                                ", PNONE, PModel(), false, false},
323      {"  Look here, I have a paragraph.", PSTART, PModel(kLeft, 0, 20, 0, 0), false, false},
324      {"This paragraph starts at the top", PCONT, PModel(), false, false},
325      {"of the page and takes 3 lines.  ", PCONT, PModel(), false, false},
326      {"  Here I have a second paragraph", PSTART, PModel(kLeft, 0, 20, 0, 0), false, false},
327      {"which indicates that the first  ", PCONT, PModel(), false, false},
328      {"paragraph is not a continuation ", PCONT, PModel(), false, false},
329      {"from a previous page, as it is  ", PCONT, PModel(), false, false},
330      {"indented just like this second  ", PCONT, PModel(), false, false},
331      {"paragraph.                      ", PCONT, PModel(), false, false},
332      {"   Here is a block quote. It    ", PSTART, PModel(kLeft, 30, 0, 0, 0), true, false},
333      {"   looks like the prior text    ", PCONT, PModel(), false, false},
334      {"   but it  is indented  more    ", PCONT, PModel(), false, false},
335      {"   and is fully justified.      ", PCONT, PModel(), false, false},
336      {"  So how does one deal with     ", PSTART, PModel(kLeft, 0, 20, 0, 0), false, false},
337      {"centered text, block quotes,    ", PCONT, PModel(), false, false},
338      {"normal paragraphs, and lists    ", PCONT, PModel(), false, false},
339      {"like what follows?              ", PCONT, PModel(), false, false},
340      {"1. Make a plan.                 ", PSTART, PModel(kLeft, 0, 0, 30, 0), false, true},
341      {"2. Use a heuristic, for example,", PSTART, PModel(kLeft, 0, 0, 30, 0), false, true},
342      {"   looking for lines where the  ", PCONT, PModel(), false, false},
343      {"   first word of the next line  ", PCONT, PModel(), false, false},
344      {"   would fit on the previous    ", PCONT, PModel(), false, false},
345      {"   line.                        ", PCONT, PModel(), false, false},
346      {"8. Try to implement the plan in ", PSTART, PModel(kLeft, 0, 0, 30, 0), false, true},
347      {"   Python and try it out.       ", PCONT, PModel(), false, false},
348      {"4. Determine how to fix the     ", PSTART, PModel(kLeft, 0, 0, 30, 0), false, true},
349      {"   mistakes.                    ", PCONT, PModel(), false, false},
350      {"5. Repeat.                      ", PSTART, PModel(kLeft, 0, 0, 30, 0), false, true},
351      {"  For extra painful penalty work", PSTART, PModel(kLeft, 0, 20, 0, 0), false, false},
352      {"you can try to identify source  ", PCONT, PModel(), false, false},
353      {"code.  Ouch!                    ", PCONT, PModel(), false, false},
354  };
355  TEST(ParagraphsTest, TestComplexPage1) {
356    TestParagraphDetection(kComplexPage1, countof(kComplexPage1));
357  }
358  const TextAndModel kComplexPage2[] = {
359      {"       Awesome                     ", PSTART, PModel(kCenter, 0, 0, 0, 0), false, false},
360      {"   Centered Title                  ", PCONT, PModel(), false, false},
361      {" Paragraph Detection               ", PCONT, PModel(), false, false},
362      {"      OCR TEAM                     ", PCONT, PModel(), false, false},
363      {"  10 November 2010                 ", PCONT, PModel(), false, false},
364      {"                                   ", PNONE, PModel(), false, false},
365      {"  Look here, I have a paragraph.   ", PSTART, PModel(kLeft, 0, 20, 0, 0), false, false},
366      {"This paragraph starts at the top of", PCONT, PModel(), false, false},
367      {"the page and takes 3 lines.        ", PCONT, PModel(), false, false},
368      {"  Here I have a second paragraph   ", PSTART, PModel(kLeft, 0, 20, 0, 0), false, false},
369      {"which indicates that the first     ", PCONT, PModel(), false, false},
370      {"paragraph is not a continuation    ", PCONT, PModel(), false, false},
371      {"from a previous page, as it is in- ", PCONT, PModel(), false, false},
372      {"dented just like this second para- ", PCONT, PModel(), false, false},
373      {"graph.                             ", PCONT, PModel(), false, false},
374      {"   Here is a block quote. It       ", PSTART, PModel(kLeft, 30, 0, 0, 0), true, false},
375      {"   looks like the prior text       ", PCONT, PModel(), false, false},
376      {"   but it  is indented  more       ", PCONT, PModel(), false, false},
377      {"   and is fully justified.         ", PCONT, PModel(), false, false},
378      {"  So how does one deal with center-", PSTART, PModel(kLeft, 0, 20, 0, 0), false, false},
379      {"ed text, block quotes, normal para-", PCONT, PModel(), false, false},
380      {"graphs, and lists like what follow?", PCONT, PModel(), false, false},
381      {"1. Make a plan.                    ", PCONT, PModel(), false, false}, 
382      {"2. Use a heuristic, for example,   ", PSTART, PModel(kLeft, 0, 0, 30, 0), false, true},
383      {"   looking for lines where the     ", PCONT, PModel(), false, false},
384      {"   first word of the next line     ", PCONT, PModel(), false, false},
385      {"   would fit on the previous line. ", PCONT, PModel(), false, false},
386      {"8. Try to implement the plan in    ", PSTART, PModel(kLeft, 0, 0, 30, 0), false, true},
387      {"   Python and try it out.          ", PCONT, PModel(), false, false},
388      {"4. Determine how to fix the        ", PSTART, PModel(kLeft, 0, 0, 30, 0), false, true},
389      {"   mistakes.                       ", PCONT, PModel(), false, false},
390      {"5. Repeat.                         ", PSTART, PModel(kLeft, 0, 0, 30, 0), false, true},
391      {"  For extra painful penalty work   ", PSTART, PModel(kLeft, 0, 20, 0, 0), false, false},
392      {"you can try to identify source     ", PCONT, PModel(), false, false},
393      {"code.  Ouch!                       ", PCONT, PModel(), false, false},
394  };
395  TEST(ParagraphsTest, TestComplexPage2) {
396    TestParagraphDetection(kComplexPage2, countof(kComplexPage2));
397  }
398  const TextAndModel kSubtleCrown[] = {
399      {"The first paragraph on a page is", PSTART, PModel(kLeft, 0, 20, 0, 0), true, false},
400      {"often not indented as the rest  ", PCONT, PModel(), false, false},
401      {"of the paragraphs are.  Nonethe-", PCONT, PModel(), false, false},
402      {"less it should be counted as the", PCONT, PModel(), false, false},
403      {"same type of paragraph.         ", PCONT, PModel(), false, false},
404      {"  Even a short second paragraph ", PSTART, PModel(kLeft, 0, 20, 0, 0), false, false},
405      {"should suffice.                 ", PCONT, PModel(), false, false},
406      {"             1235               ", PNONE, PModel(), false, false},
407  };
408  TEST(ParagraphsTest, TestSubtleCrown) {
409    TestParagraphDetection(kSubtleCrown, countof(kSubtleCrown) - 1);
410  }
411  TEST(ParagraphsTest, TestStrayLineInBlock) {
412    TestParagraphDetection(kSubtleCrown, countof(kSubtleCrown));
413  }
414  const TextAndModel kUnlvRep3AO[] = {
415      {"    Defined contribution plans cover employees in Australia, New", PSTART,
416       PModel(kLeft, 0, 50, 0, 0), false, false},
417      {"Zealand, Spain, the United Kingdom and some U.S. subsidiaries.  ", PCONT, PModel(), false,
418       false},
419      {"In addition, employees in the U.S. are eligible to participate in    ", PCONT, PModel(),
420       false, false},
421      {"deﬁned contribution plans (Employee Savings Plans) by contribut-", PCONT, PModel(), false,
422       false},
423      {"ing a portion of their compensation. The Company matches com- ", PCONT, PModel(), false,
424       false},
425      {"pensation, depending on Company proﬁt levels. Contributions    ", PCONT, PModel(), false,
426       false},
427      {"charged to income for deﬁned contribution plans were $92 in    ", PCONT, PModel(), false,
428       false},
429      {"1993, $98 in 1992 and $89 in 1991.                             ", PCONT, PModel(), false,
430       false},
431      {"     In addition to providing pension beneﬁts, the Company pro- ", PSTART,
432       PModel(kLeft, 0, 50, 0, 0), false, false},
433      {"vides certain health care and life insurance beneﬁts to retired     ", PCONT, PModel(), false,
434       false},
435      {"employees. As discussed in Note A, the Company adopted FASB   ", PCONT, PModel(), false,
436       false},
437      {"Statement No. 106 effective January 1, 1992. Previously, the     ", PCONT, PModel(), false,
438       false},
439      {"Company recognized the cost of providing these beneﬁts as the     ", PCONT, PModel(), false,
440       false},
441      {"beneﬁts were paid. These pretax costs amounted to $53 in 1991.   ", PCONT, PModel(), false,
442       false},
443      {"The Company continues to fund most of the cost of these medical ", PCONT, PModel(), false,
444       false},
445      {"and life insurance beneﬁts in the year incurred.                ", PCONT, PModel(), false,
446       false},
447      {"     The U.S. plan covering the parent company is the largest plan.", PSTART,
448       PModel(kLeft, 0, 50, 0, 0), false, false},
449      {"It provides medical and life insurance beneﬁts including hospital,  ", PCONT, PModel(), false,
450       false},
451      {"physicians’ services and major medical expense beneﬁts and life   ", PCONT, PModel(), false,
452       false},
453      {"insurance beneﬁts. The plan provides beneﬁts supplemental to    ", PCONT, PModel(), false,
454       false},
455      {"Medicare after retirees are eligible for these beneﬁts. The cost of  ", PCONT, PModel(),
456       false, false},
457      {"these beneﬁts are shared by the Company and the retiree, with the  ", PCONT, PModel(), false,
458       false},
459      {"Company portion increasing as the retiree has increased years of   ", PCONT, PModel(), false,
460       false},
461      {"credited service. The Company has the ability to change these    ", PCONT, PModel(), false,
462       false},
463      {"beneﬁts at any time.                                            ", PCONT, PModel(), false,
464       false},
465      {"     Effective October 1993, the Company amended its health   ", PSTART,
466       PModel(kLeft, 0, 50, 0, 0), false, false},
467      {"beneﬁts plan in the U.S. to cap the cost absorbed by the Company ", PCONT, PModel(), false,
468       false},
469      {"at approximately twice the 1993 cost per person for employees who", PCONT, PModel(), false,
470       false},
471      {"retire after December 31, 1993. The effect of this amendment was ", PCONT, PModel(), false,
472       false},
473      {"to reduce the December 31, 1993 accumulated postretirement   ", PCONT, PModel(), false,
474       false},
475      {"beneﬁt obligation by $327. It also reduced the net periodic postre- ", PCONT, PModel(), false,
476       false},
477      {"tirement cost by $21 for 1993 and is estimated to reduce this cost  ", PCONT, PModel(), false,
478       false},
479      {"for 1994 by approximately $83.                                     ", PCONT, PModel(), false,
480       false},
481  };
482  TEST(ParagraphsTest, TestUnlvInsurance) {
483    TestParagraphDetection(kUnlvRep3AO, countof(kUnlvRep3AO));
484  }
485  const TextAndModel kTableOfContents[] = {
486      {"1 Hmong People ........... 1", PSTART, PModel(kUnknown, 0, 0, 0, 0), false, false},
487      {"   Hmong Origins . . . . . 1", PSTART, PModel(kUnknown, 0, 0, 0, 0), false, false},
488      {"    Language . . . . . . . 1", PSTART, PModel(kUnknown, 0, 0, 0, 0), false, false},
489      {"     Proverbs . . . . . .  2", PSTART, PModel(kUnknown, 0, 0, 0, 0), false, false},
490      {"        Discussion . . . . 2", PSTART, PModel(kUnknown, 0, 0, 0, 0), false, false},
491      {"     Riddles . . . . . . . 2", PSTART, PModel(kUnknown, 0, 0, 0, 0), false, false},
492      {"        Discussion . . . . 3", PSTART, PModel(kUnknown, 0, 0, 0, 0), false, false},
493      {"     Appearance . . . . .  3", PSTART, PModel(kUnknown, 0, 0, 0, 0), false, false},
494      {"   Hmong History . . . . . 4", PSTART, PModel(kUnknown, 0, 0, 0, 0), false, false},
495      {"    Hmong in SE Asia . . . 4", PSTART, PModel(kUnknown, 0, 0, 0, 0), false, false},
496      {"    Hmong in the West . . .5", PSTART, PModel(kUnknown, 0, 0, 0, 0), false, false},
497      {"    Hmong in the USA . . . 5", PSTART, PModel(kUnknown, 0, 0, 0, 0), false, false},
498      {"        Discussion . . . . 6", PSTART, PModel(kUnknown, 0, 0, 0, 0), false, false},
499  };
500  TEST(ParagraphsTest, TestSplitsOutLeaderLines) {
501    TestParagraphDetection(kTableOfContents, countof(kTableOfContents));
502  }
503  const TextAndModel kTextWithSourceCode[] = {
504      {"  A typical page of a programming book may contain", PSTART, PModel(kLeft, 0, 20, 0, 0),
505       false, false},
506      {"examples of source code to exemplify an algorithm ", PCONT, PModel(), false, false},
507      {"being described in prose.  Such examples should be", PCONT, PModel(), false, false},
508      {"rendered as lineated text, meaning text with      ", PCONT, PModel(), false, false},
509      {"explicit line breaks but without extra inter-line ", PCONT, PModel(), false, false},
510      {"spacing.  Accidentally finding stray paragraphs in", PCONT, PModel(), false, false},
511      {"source code would lead to a bad reading experience", PCONT, PModel(), false, false},
512      {"when the text is re-flowed.                       ", PCONT, PModel(), false, false},
513      {"  Let's show this by describing the function fact-", PSTART, PModel(kLeft, 0, 20, 0, 0),
514       false, false},
515      {"orial.  Factorial is a simple recursive function  ", PCONT, PModel(), false, false},
516      {"which grows very quickly.  So quickly, in fact,   ", PCONT, PModel(), false, false},
517      {"that the typical C implementation will only work  ", PCONT, PModel(), false, false},
518      {"for values less than about 12:                    ", PCONT, PModel(), false, false},
519      {"                                                  ", PNONE, PModel(), false, false},
520      {"  # Naive implementation in C                     ", PCONT, PModel(), false, false},
521      {"  int factorial(int n) {                          ", PCONT, PModel(), false, false},
522      {"    if (n < 2)                                    ", PCONT, PModel(), false, false},
523      {"      return 1;                                   ", PCONT, PModel(), false, false},
524      {"    return  n * factorial(n - 1);                 ", PCONT, PModel(), false, false},
525      {"  }                                               ", PCONT, PModel(), false, false},
526      {"                                                  ", PCONT, PModel(), false, false},
527      {"  The C programming language does not have built- ", PSTART, PModel(kLeft, 0, 20, 0, 0),
528       false, false},
529      {"in support for detecting integer overflow, so this", PCONT, PModel(), false, false},
530      {"naive implementation simply returns random values ", PCONT, PModel(), false, false},
531      {"if even a moderate sized n is provided.           ", PCONT, PModel(), false, false},
532  };
533  TEST(ParagraphsTest, NotDistractedBySourceCode) {
534    TestParagraphDetection(kTextWithSourceCode, countof(kTextWithSourceCode));
535  }
536  const TextAndModel kOldManAndSea[] = {
537      {"royal  palm  which  are called  guano  and  in it  there was a bed,  a", PSTART,
538       PModel(kLeft, 0, 50, 0, 0), false, false},
539      {"table, one chair, and a place on the dirt floor to cook with charcoal.", PCONT, PModel(),
540       false, false},
541      {"On  the  brown  walls  of  the ﬂattened,  overlapping  leaves  of  the", PCONT, PModel(),
542       false, false},
543      {"sturdy  fibered guano  there  was  a  picture in  color of  the Sacred", PCONT, PModel(),
544       false, false},
545      {"Heart  of  Jesus  and  another  of  the  Virgin  of Cobre.  These were", PCONT, PModel(),
546       false, false},
547      {"relics of  his wife.   Once there had been  a tinted photograph of his", PCONT, PModel(),
548       false, false},
549      {"wife on  the wall  but he  had taken  it  down because it made him too", PCONT, PModel(),
550       false, false},
551      {"lonely to see it and it was on the shelf in the corner under his clean", PCONT, PModel(),
552       false, false},
553      {"shirt.                                                                ", PCONT, PModel(),
554       false, false},
555      {"     \"What  do  you  have  to  eat?\"     the  boy   asked.          ", PSTART,
556       PModel(kLeft, 0, 50, 0, 0), false, false},
557      {"     \"A pot of yellow rice with fish. Do you want some?\"            ", PSTART,
558       PModel(kLeft, 0, 50, 0, 0), false, false},
559      {"     \"No. I will eat at home. Do you want me to make the fire?\"   ", PSTART,
560       PModel(kLeft, 0, 50, 0, 0), false, false},
561      {"     \"No. I will make it later on. Or I may eat the rice cold.\"     ", PSTART,
562       PModel(kLeft, 0, 50, 0, 0), false, false},
563      {"     \"May I take the cast net?\"                                     ", PSTART,
564       PModel(kLeft, 0, 50, 0, 0), false, false},
565      {"     \"Of course.\"                                                   ", PSTART,
566       PModel(kLeft, 0, 50, 0, 0), false, false},
567      {"     There was  no  cast net  and  the boy  remembered  when  they had", PSTART,
568       PModel(kLeft, 0, 50, 0, 0), false, false},
569      {"sold it.   But they went through  this fiction every day. There was no", PCONT, PModel(),
570       false, false},
571      {"pot of yellow rice and fish and the boy knew this too.                 "
572       " ",
573       PCONT, PModel(), false, false},
574      {"     \"Eighty-five  is a lucky number,\"  the  old  man  said.   \"How", PSTART,
575       PModel(kLeft, 0, 50, 0, 0), false, false},
576      {"would  you  like to see  me  bring one  in that dressed out over a "
577       "thou-",
578       PCONT, PModel(), false, false},
579      {"sand pounds?                                                           "
580       " ",
581       PCONT, PModel(), false, false},
582      {"     \"I'll get the cast net and go for sardines.  Will you sit in the "
583       "sun",
584       PSTART, PModel(kLeft, 0, 50, 0, 0), false, false},
585      {"in the doorway?\"                                                        "
586       " ",
587       PCONT, PModel(), false, false},
588      {"     \"Yes.  I have yesterday's paper and I will read the baseball.\"   ", PSTART,
589       PModel(kLeft, 0, 50, 0, 0), false, false},
590      {"     The boy  did not  know  whether  yesterday's paper  was a fiction", PSTART,
591       PModel(kLeft, 0, 50, 0, 0), false, false},
592      {"too.  But the old man brought it out from under the bed.              ", PCONT, PModel(),
593       false, false},
594      {"     \"Pedrico gave it to me at the bodega,\" he explained.             "
595       " ",
596       PSTART, PModel(kLeft, 0, 50, 0, 0), false, false},
597      {"     \"I'll be back when I have the sardines.  I'll keep yours and mine", PSTART,
598       PModel(kLeft, 0, 50, 0, 0), false, false},
599      {"together  on ice  and  we  can  share  them  in the  morning.   When I", PCONT, PModel(),
600       false, false},
601      {"come back you can tell me about the baseball.\"                       ", PCONT, PModel(),
602       false, false},
603      {"     \"The Yankees cannot lose.\"                                     ", PSTART,
604       PModel(kLeft, 0, 50, 0, 0), false, false},
605      {"     \"But I fear the Indians of Cleveland.\"                         ", PSTART,
606       PModel(kLeft, 0, 50, 0, 0), false, false},
607      {"     \"Have faith  in  the Yankees  my son.   Think of  the great  Di-", PSTART,
608       PModel(kLeft, 0, 50, 0, 0), false, false},
609      {"Maggio.\"                                                             ", PCONT, PModel(),
610       false, false},
611      {"     \"I  fear both  the Tigers of Detroit  and the  Indians of Cleve-", PSTART,
612       PModel(kLeft, 0, 50, 0, 0), false, false},
613      {"land.\"                                                               ", PCONT, PModel(),
614       false, false}};
615  TEST(ParagraphsTest, NotOverlyAggressiveWithBlockQuotes) {
616    TestParagraphDetection(kOldManAndSea, countof(kOldManAndSea));
617  }
618  const TextAndModel kNewZealandIndex[] = {
619      {"Oats, 51                      ", PSTART, PModel(kLeft, 0, 0, 30, 0), false, false},
620      {"O'Brien, Gregory, 175         ", PSTART, PModel(kLeft, 0, 0, 30, 0), false, false},
621      {"Occupational composition, 110,", PSTART, PModel(kLeft, 0, 0, 30, 0), false, false},
622      {"   138                        ", PCONT, PModel(), false, false},
623      {"OECD rankings, 155, 172       ", PSTART, PModel(kLeft, 0, 0, 30, 0), false, false},
624      {"Okiato (original capital), 47 ", PSTART, PModel(kLeft, 0, 0, 30, 0), false, false},
625      {"Oil shock: 1974, xxx, 143; 1979,", PSTART, PModel(kLeft, 0, 0, 30, 0), false, false},
626      {"   145                        ", PCONT, PModel(), false, false},
627      {"Old Age Pensions, xxii, 89-90 ", PSTART, PModel(kLeft, 0, 0, 30, 0), false, false},
628      {"Old World evils, 77           ", PSTART, PModel(kLeft, 0, 0, 30, 0), false, false},
629      {"Oliver, W. H., 39, 77, 89     ", PSTART, PModel(kLeft, 0, 0, 30, 0), false, false},
630      {"Olssen, Erik, 45, 64, 84      ", PSTART, PModel(kLeft, 0, 0, 30, 0), false, false},
631      {"Olympic Games, 1924, 111, 144 ", PSTART, PModel(kLeft, 0, 0, 30, 0), false, false},
632      {"Once on Chunuk Bair, 149      ", PSTART, PModel(kLeft, 0, 0, 30, 0), false, false},
633      {"Once Were Warriors, xxxiii, 170", PSTART, PModel(kLeft, 0, 0, 30, 0), false, false},
634      {"On—shore whaling, xvi         ", PSTART, PModel(kLeft, 0, 0, 30, 0), false, false},
635      {"Opotiki, xix                  ", PSTART, PModel(kLeft, 0, 0, 30, 0), false, false},
636      {"Orakau battle of, xviii, 57   ", PSTART, PModel(kLeft, 0, 0, 30, 0), false, false},
637      {"O’Regan, Tipene, 170, 198-99  ", PSTART, PModel(kLeft, 0, 0, 30, 0), false, false},
638      {"Organic agriculture, 177      ", PSTART, PModel(kLeft, 0, 0, 30, 0), false, false},
639      {"Orwell, George, 151           ", PSTART, PModel(kLeft, 0, 0, 30, 0), false, false},
640      {"Otago, xvii, 45, 49-50, 70    ", PSTART, PModel(kLeft, 0, 0, 30, 0), false, false},
641      {"Otago block, xvii             ", PSTART, PModel(kLeft, 0, 0, 30, 0), false, false},
642      {"Otago Daily Times, 67         ", PSTART, PModel(kLeft, 0, 0, 30, 0), false, false},
643      {"Otago Girls’ High School, xix, 61,", PSTART, PModel(kLeft, 0, 0, 30, 0), false, false},
644      {"   85                         ", PCONT, PModel(), false, false},
645      {"Otago gold rushes, 61-63      ", PSTART, PModel(kLeft, 0, 0, 30, 0), false, false},
646      {"Otago Peninsula, xx           ", PSTART, PModel(kLeft, 0, 0, 30, 0), false, false},
647      {"Otago Provincial Council, 68  ", PSTART, PModel(kLeft, 0, 0, 30, 0), false, false},
648      {"Otaki, 33                     ", PSTART, PModel(kLeft, 0, 0, 30, 0), false, false},
649      {"Owls Do Cry, 139              ", PSTART, PModel(kLeft, 0, 0, 30, 0), false, false}};
650  TEST(ParagraphsTest, IndexPageTest) {
651    TestParagraphDetection(kNewZealandIndex, countof(kNewZealandIndex));
652  }
653  } 
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-paragraphs_test.cc</h3>
            <pre><code>1  #include <string> 
2  #include "include_gunit.h" 
3  #include "log.h"           
4  #include "paragraphs.h"
5  #include "paragraphs_internal.h"
6  #include "ocrpara.h"
7  namespace tesseract {
8  const ParagraphJustification kLeft = JUSTIFICATION_LEFT;
9  const ParagraphJustification kCenter = JUSTIFICATION_CENTER;
10  const ParagraphJustification kRight = JUSTIFICATION_RIGHT;
11  const ParagraphJustification kUnknown = JUSTIFICATION_UNKNOWN;
12  enum TextModelInputType {
13    PCONT = 0,  
14    PSTART = 1, 
15    PNONE = 2,  
16  };
17  struct TextAndModel {
18    const char *ascii;
19    TextModelInputType model_type;
20    ParagraphModel model;
21    bool is_very_first_or_continuation;
22    bool is_list_item;
23  };
24  void AsciiToRowInfo(const char *text, int row_number, RowInfo *info) {
25    const int kCharWidth = 10;
26    const int kLineSpace = 30;
27    info->text = text;
28    info->has_leaders = strstr(text, "...") != nullptr || strstr(text, ". . .") != nullptr;
29    info->has_drop_cap = false;
30    info->pix_ldistance = info->pix_rdistance = 0;
31    info->average_interword_space = kCharWidth;
32    info->pix_xheight = kCharWidth;
33    info->lword_text = info->rword_text = "";
34    info->ltr = true;
35    std::vector<std::string> words = split(text, ' ');
36    info->num_words = words.size();
37    if (info->num_words < 1) {
38      return;
39    }
40    info->lword_text = words[0].c_str();
41    info->rword_text = words[words.size() - 1].c_str();
42    int lspace = 0;
43    while (lspace < info->text.size() && text[lspace] == ' ') {
44      lspace++;
45    }
46    int rspace = 0;
47    while (rspace < info->text.size() && text[info->text.size() - rspace - 1] == ' ') {
48      rspace++;
49    }
50    int top = -kLineSpace * row_number;
51    int bottom = top - kLineSpace;
52    int row_right = kCharWidth * info->text.size();
53    int lword_width = kCharWidth * info->lword_text.size();
54    int rword_width = kCharWidth * info->rword_text.size();
55    info->pix_ldistance = lspace * kCharWidth;
56    info->pix_rdistance = rspace * kCharWidth;
57    info->lword_box = TBOX(info->pix_ldistance, bottom, info->pix_ldistance + lword_width, top);
58    info->rword_box = TBOX(row_right - info->pix_rdistance - rword_width, bottom,
59                           row_right - info->pix_rdistance, top);
60    LeftWordAttributes(nullptr, nullptr, info->lword_text, &info->lword_indicates_list_item,
61                       &info->lword_likely_starts_idea, &info->lword_likely_ends_idea);
62    RightWordAttributes(nullptr, nullptr, info->rword_text, &info->rword_indicates_list_item,
63                        &info->rword_likely_starts_idea, &info->rword_likely_ends_idea);
64  }
65  void MakeAsciiRowInfos(const TextAndModel *row_infos, int n, std::vector<RowInfo> *output) {
66    output->clear();
67    RowInfo info;
68    for (int i = 0; i < n; i++) {
69      AsciiToRowInfo(row_infos[i].ascii, i, &info);
70      output->push_back(info);
71    }
72  }
73  void EvaluateParagraphDetection(const TextAndModel *correct, int n,
74                                  const std::vector<PARA *> &detector_output) {
75    int incorrect_breaks = 0;
76    int missed_breaks = 0;
77    int poorly_matched_models = 0;
78    int bad_crowns = 0;
79    int bad_list_items = 0;
80    ASSERT_EQ(detector_output.size(), n);
81    for (int i = 1; i < n; i++) {
82      bool has_break = correct[i].model_type != PCONT;
83      bool detected_break = (detector_output[i - 1] != detector_output[i]);
84      if (has_break && !detected_break) {
85        missed_breaks++;
86      }
87      if (detected_break && !has_break) {
88        incorrect_breaks++;
89      }
90      if (has_break) {
91        if (correct[i].model_type == PNONE) {
92          if (detector_output[i]->model != nullptr) {
93            poorly_matched_models++;
94          }
95        } else {
96          if (correct[i].model.justification() != kUnknown &&
97              (detector_output[i]->model == nullptr ||
98               !correct[i].model.Comparable(*detector_output[i]->model))) {
99            poorly_matched_models++;
100          }
101        }
102        if (correct[i].is_very_first_or_continuation ^
103            detector_output[i]->is_very_first_or_continuation) {
104          bad_crowns++;
105        }
106        if (correct[i].is_list_item ^ detector_output[i]->is_list_item) {
107          bad_list_items++;
108        }
109      }
110    }
111    EXPECT_EQ(incorrect_breaks, 0);
112    EXPECT_EQ(missed_breaks, 0);
113    EXPECT_EQ(poorly_matched_models, 0);
114    EXPECT_EQ(bad_list_items, 0);
115    EXPECT_EQ(bad_crowns, 0);
116    if (incorrect_breaks || missed_breaks || poorly_matched_models || bad_list_items || bad_crowns) {
117      std::vector<std::string> dbg_lines;
118      dbg_lines.emplace_back("# ==========================");
119      dbg_lines.emplace_back("# Correct paragraph breaks:");
120      dbg_lines.emplace_back("# ==========================");
121      for (int i = 0; i < n; i++) {
122        if (correct[i].model_type != PCONT) {
123          std::string s = std::string(correct[i].ascii) + "  #  " +
124                          correct[i].model.ToString() +
125                          (correct[i].is_very_first_or_continuation ? " crown" : "") +
126                          (correct[i].is_list_item ? " li" : "");
127          dbg_lines.push_back(s);
128        } else {
129          dbg_lines.emplace_back(correct[i].ascii);
130        }
131      }
132      dbg_lines.emplace_back("");
133      dbg_lines.emplace_back("# ==========================");
134      dbg_lines.emplace_back("# Paragraph detector output:");
135      dbg_lines.emplace_back("# ==========================");
136      for (int i = 0; i < n; i++) {
137        std::string annotation;
138        if (i == 0 || (detector_output[i - 1] != detector_output[i])) {
139          if (detector_output[i] && detector_output[i]->model) {
140            annotation +=
141                "  #  " + detector_output[i]->model->ToString() +
142                (detector_output[i]->is_very_first_or_continuation ? " crown" : "") +
143                (detector_output[i]->is_list_item ? " li" : "");
144          } else {
145            annotation = "  #  Unmodeled paragraph.";
146          }
147        }
148        std::string s = correct[i].ascii + annotation;
149        dbg_lines.push_back(s);
150      }
151      std::string s;
152      for (auto &dbg_line : dbg_lines) {
153        s += dbg_line + "\n";
154      }
155      LOG(INFO) << "Discrepancy!\n" << s;
156    }
157  }
158  void TestParagraphDetection(const TextAndModel *correct, int num_rows) {
159    std::vector<RowInfo> row_infos;
160    std::vector<PARA *> row_owners;
161    PARA_LIST paragraphs;
162    std::vector<ParagraphModel *> models;
163    MakeAsciiRowInfos(correct, num_rows, &row_infos);
164    int debug_level(3);
<span onclick='openModal()' class='match'>165    tesseract::DetectParagraphs(debug_level, &row_infos, &row_owners, &paragraphs, &models);
166    EvaluateParagraphDetection(correct, num_rows, row_owners);
</span>167    for (auto *model : models) {
168      delete model;
169    }
170  }
171  TEST(ParagraphsTest, ListItemsIdentified) {
172    EXPECT_TRUE(tesseract::AsciiLikelyListItem("iii"));
173    EXPECT_TRUE(tesseract::AsciiLikelyListItem("A."));
174    EXPECT_TRUE(tesseract::AsciiLikelyListItem("B."));
175    EXPECT_TRUE(tesseract::AsciiLikelyListItem("C."));
176    EXPECT_TRUE(tesseract::AsciiLikelyListItem("1."));
177    EXPECT_TRUE(tesseract::AsciiLikelyListItem("2."));
178    EXPECT_TRUE(tesseract::AsciiLikelyListItem("3."));
179    EXPECT_TRUE(tesseract::AsciiLikelyListItem("1"));
180    EXPECT_TRUE(tesseract::AsciiLikelyListItem("2"));
181    EXPECT_TRUE(tesseract::AsciiLikelyListItem("3"));
182    EXPECT_TRUE(tesseract::AsciiLikelyListItem("[[1]]"));
183    EXPECT_TRUE(tesseract::AsciiLikelyListItem("A-1."));
184    EXPECT_TRUE(tesseract::AsciiLikelyListItem("A-2"));
185    EXPECT_TRUE(tesseract::AsciiLikelyListItem("(A)(i)"));
186    EXPECT_FALSE(tesseract::AsciiLikelyListItem("The"));
187    EXPECT_FALSE(tesseract::AsciiLikelyListItem("first"));
188    EXPECT_FALSE(tesseract::AsciiLikelyListItem("house"));
189    EXPECT_FALSE(tesseract::AsciiLikelyListItem("Oregonian."));
190    EXPECT_FALSE(tesseract::AsciiLikelyListItem("on."));
191  }
192  typedef ParagraphModel PModel;
193  const TextAndModel kTwoSimpleParagraphs[] = {
194      {"  Look here, I have a paragraph.", PSTART, PModel(kLeft, 0, 20, 0, 0), false, false},
195      {"This paragraph starts at the top", PCONT, PModel(), false, false},
196      {"of the page and takes 3 lines.  ", PCONT, PModel(), false, false},
197      {"  Here I have a second paragraph", PSTART, PModel(kLeft, 0, 20, 0, 0), false, false},
198      {"which indicates that the first  ", PCONT, PModel(), false, false},
199      {"paragraph is not a continuation ", PCONT, PModel(), false, false},
200      {"from a previous page, as it is  ", PCONT, PModel(), false, false},
201      {"indented just like this second  ", PCONT, PModel(), false, false},
202      {"paragraph.                      ", PCONT, PModel(), false, false},
203  };
204  TEST(ParagraphsTest, TestSimpleParagraphDetection) {
205    TestParagraphDetection(kTwoSimpleParagraphs, countof(kTwoSimpleParagraphs));
206  }
207  const TextAndModel kFewCluesWithCrown[] = {
208      {"This paragraph starts at the top", PSTART, PModel(kLeft, 0, 20, 0, 0), true, false},
209      {"of the page and takes two lines.", PCONT, PModel(), false, false},
210      {"  Here I have a second paragraph", PSTART, PModel(kLeft, 0, 20, 0, 0), false, false},
211      {"which indicates that the first  ", PCONT, PModel(), false, false},
212      {"paragraph is a continuation from", PCONT, PModel(), false, false},
213      {"a previous page, as it is       ", PCONT, PModel(), false, false},
214      {"indented just like this second  ", PCONT, PModel(), false, false},
215      {"paragraph.                      ", PCONT, PModel(), false, false},
216  };
217  TEST(ParagraphsTest, TestFewCluesWithCrown) {
218    TestParagraphDetection(kFewCluesWithCrown, countof(kFewCluesWithCrown));
219  }
220  const TextAndModel kCrownedParagraph[] = {
221      {"The first paragraph on a page is", PSTART, PModel(kLeft, 0, 20, 0, 0), true, false},
222      {"often not indented as the rest  ", PCONT, PModel(), false, false},
223      {"of the paragraphs are.  Nonethe-", PCONT, PModel(), false, false},
224      {"less it should be counted as the", PCONT, PModel(), false, false},
225      {"same type of paragraph.         ", PCONT, PModel(), false, false},
226      {"  The second and third para-    ", PSTART, PModel(kLeft, 0, 20, 0, 0), false, false},
227      {"graphs are both indented two    ", PCONT, PModel(), false, false},
228      {"spaces.                         ", PCONT, PModel(), false, false},
229      {"  The first paragraph has what  ", PSTART, PModel(kLeft, 0, 20, 0, 0), false, false},
230      {"fmt refers to as a 'crown.'     ", PCONT, PModel(), false, false},
231  };
232  TEST(ParagraphsTest, TestCrownParagraphDetection) {
233    TestParagraphDetection(kCrownedParagraph, countof(kCrownedParagraph));
234  }
235  const TextAndModel kFlushLeftParagraphs[] = {
236      {"It  is sometimes  the case  that", PSTART, PModel(kLeft, 0, 0, 0, 0), false, false},
237      {"flush  left   paragraphs  (those", PCONT, PModel(), false, false},
238      {"with  no  body  indent)  are not", PCONT, PModel(), false, false},
239      {"actually crowns.                ", PCONT, PModel(), false, false},
240      {"Instead,  further paragraphs are", PSTART, PModel(kLeft, 0, 0, 0, 0), false, false},
241      {"also flush left aligned.  Usual-", PCONT, PModel(), false, false},
242      {"ly,  these  paragraphs  are  set", PCONT, PModel(), false, false},
243      {"apart vertically  by some white-", PCONT, PModel(), false, false},
244      {"space,  but you can also  detect", PCONT, PModel(), false, false},
245      {"them by observing  the big empty", PCONT, PModel(), false, false},
246      {"space at the  ends  of the para-", PCONT, PModel(), false, false},
247      {"graphs.                         ", PCONT, PModel(), false, false},
248  };
249  TEST(ParagraphsText, TestRealFlushLeftParagraphs) {
250    TestParagraphDetection(kFlushLeftParagraphs, countof(kFlushLeftParagraphs));
251  }
252  const TextAndModel kSingleFullPageContinuation[] = {
253      {"sometimes a page is one giant", PSTART, PModel(kLeft, 0, 20, 0, 0), true, false},
254      {"continuation.  It flows  from", PCONT, PModel(), false, false},
255      {"line to  line, using the full", PCONT, PModel(), false, false},
256      {"column  width  with  no clear", PCONT, PModel(), false, false},
257      {"paragraph  break,  because it", PCONT, PModel(), false, false},
258      {"actually doesn't have one. It", PCONT, PModel(), false, false},
259      {"is the  middle of one monster", PCONT, PModel(), false, false},
260      {"paragraph continued  from the", PCONT, PModel(), false, false},
261      {"previous page and  continuing", PCONT, PModel(), false, false},
262      {"onto the  next  page.  There-", PCONT, PModel(), false, false},
263      {"fore,  it  ends  up   getting", PCONT, PModel(), false, false},
264      {"marked  as a  crown  and then", PCONT, PModel(), false, false},
265      {"getting re-marked as any  ex-", PCONT, PModel(), false, false},
266      {"isting model.  Not great, but", PCONT, PModel(), false, false},
267  };
268  TEST(ParagraphsTest, TestSingleFullPageContinuation) {
269    const TextAndModel *correct = kSingleFullPageContinuation;
270    int num_rows = countof(kSingleFullPageContinuation);
271    std::vector<RowInfo> row_infos;
272    std::vector<PARA *> row_owners;
273    PARA_LIST paragraphs;
274    std::vector<ParagraphModel *> models;
275    models.push_back(new ParagraphModel(kLeft, 0, 20, 0, 10));
276    MakeAsciiRowInfos(correct, num_rows, &row_infos);
277    tesseract::DetectParagraphs(3, &row_infos, &row_owners, &paragraphs, &models);
278    EvaluateParagraphDetection(correct, num_rows, row_owners);
279    for (auto *model : models) {
280      delete model;
281    }
282  }
283  const TextAndModel kRightAligned[] = {
284      {"Right-aligned paragraphs are", PSTART, PModel(kRight, 0, 0, 0, 0), false, false},
285      {"   uncommon in Left-to-Right", PCONT, PModel(), false, false},
286      {"      languages, but they do", PCONT, PModel(), false, false},
287      {"                      exist.", PCONT, PModel(), false, false},
288      {"    Mostly, however, they're", PSTART, PModel(kRight, 0, 0, 0, 0), false, false},
289      {" horribly tiny paragraphs in", PCONT, PModel(), false, false},
290      {"  tables on which we have no", PCONT, PModel(), false, false},
291      {"             chance anyways.", PCONT, PModel(), false, false},
292  };
293  TEST(ParagraphsTest, TestRightAlignedParagraph) {
294    TestParagraphDetection(kRightAligned, countof(kRightAligned));
295  }
296  const TextAndModel kTinyParagraphs[] = {
297      {"  Occasionally, interspersed with", PSTART, PModel(kLeft, 0, 20, 0, 0), false, false},
298      {"obvious paragraph text, you might", PCONT, PModel(), false, false},
299      {"find short exchanges of dialogue ", PCONT, PModel(), false, false},
300      {"between characters.              ", PCONT, PModel(), false, false},
301      {"  'Oh?'                          ", PSTART, PModel(kLeft, 0, 20, 0, 0), false, false},
302      {"  'Don't be confused!'           ", PSTART, PModel(kLeft, 0, 20, 0, 0), false, false},
303      {"  'Not me!'                      ", PSTART, PModel(kLeft, 0, 20, 0, 0), false, false},
304      {"  One naive approach would be to ", PSTART, PModel(kLeft, 0, 20, 0, 0), false, false},
305      {"mark a new paragraph whenever one", PCONT, PModel(), false, false},
306      {"of the statistics (left, right or", PCONT, PModel(), false, false},
307      {"center)  changes  from  one text-", PCONT, PModel(), false, false},
308      {"line  to  the  next.    Such   an", PCONT, PModel(), false, false},
309      {"approach  would  misclassify  the", PCONT, PModel(), false, false},
310      {"tiny paragraphs above as a single", PCONT, PModel(), false, false},
311      {"paragraph.                       ", PCONT, PModel(), false, false},
312  };
313  TEST(ParagraphsTest, TestTinyParagraphs) {
314    TestParagraphDetection(kTinyParagraphs, countof(kTinyParagraphs));
315  }
316  const TextAndModel kComplexPage1[] = {
317      {"       Awesome                  ", PSTART, PModel(kCenter, 0, 0, 0, 0), false, false},
318      {"   Centered Title               ", PCONT, PModel(), false, false},
319      {" Paragraph Detection            ", PCONT, PModel(), false, false},
320      {"      OCR TEAM                  ", PCONT, PModel(), false, false},
321      {"  10 November 2010              ", PCONT, PModel(), false, false},
322      {"                                ", PNONE, PModel(), false, false},
323      {"  Look here, I have a paragraph.", PSTART, PModel(kLeft, 0, 20, 0, 0), false, false},
324      {"This paragraph starts at the top", PCONT, PModel(), false, false},
325      {"of the page and takes 3 lines.  ", PCONT, PModel(), false, false},
326      {"  Here I have a second paragraph", PSTART, PModel(kLeft, 0, 20, 0, 0), false, false},
327      {"which indicates that the first  ", PCONT, PModel(), false, false},
328      {"paragraph is not a continuation ", PCONT, PModel(), false, false},
329      {"from a previous page, as it is  ", PCONT, PModel(), false, false},
330      {"indented just like this second  ", PCONT, PModel(), false, false},
331      {"paragraph.                      ", PCONT, PModel(), false, false},
332      {"   Here is a block quote. It    ", PSTART, PModel(kLeft, 30, 0, 0, 0), true, false},
333      {"   looks like the prior text    ", PCONT, PModel(), false, false},
334      {"   but it  is indented  more    ", PCONT, PModel(), false, false},
335      {"   and is fully justified.      ", PCONT, PModel(), false, false},
336      {"  So how does one deal with     ", PSTART, PModel(kLeft, 0, 20, 0, 0), false, false},
337      {"centered text, block quotes,    ", PCONT, PModel(), false, false},
338      {"normal paragraphs, and lists    ", PCONT, PModel(), false, false},
339      {"like what follows?              ", PCONT, PModel(), false, false},
340      {"1. Make a plan.                 ", PSTART, PModel(kLeft, 0, 0, 30, 0), false, true},
341      {"2. Use a heuristic, for example,", PSTART, PModel(kLeft, 0, 0, 30, 0), false, true},
342      {"   looking for lines where the  ", PCONT, PModel(), false, false},
343      {"   first word of the next line  ", PCONT, PModel(), false, false},
344      {"   would fit on the previous    ", PCONT, PModel(), false, false},
345      {"   line.                        ", PCONT, PModel(), false, false},
346      {"8. Try to implement the plan in ", PSTART, PModel(kLeft, 0, 0, 30, 0), false, true},
347      {"   Python and try it out.       ", PCONT, PModel(), false, false},
348      {"4. Determine how to fix the     ", PSTART, PModel(kLeft, 0, 0, 30, 0), false, true},
349      {"   mistakes.                    ", PCONT, PModel(), false, false},
350      {"5. Repeat.                      ", PSTART, PModel(kLeft, 0, 0, 30, 0), false, true},
351      {"  For extra painful penalty work", PSTART, PModel(kLeft, 0, 20, 0, 0), false, false},
352      {"you can try to identify source  ", PCONT, PModel(), false, false},
353      {"code.  Ouch!                    ", PCONT, PModel(), false, false},
354  };
355  TEST(ParagraphsTest, TestComplexPage1) {
356    TestParagraphDetection(kComplexPage1, countof(kComplexPage1));
357  }
358  const TextAndModel kComplexPage2[] = {
359      {"       Awesome                     ", PSTART, PModel(kCenter, 0, 0, 0, 0), false, false},
360      {"   Centered Title                  ", PCONT, PModel(), false, false},
361      {" Paragraph Detection               ", PCONT, PModel(), false, false},
362      {"      OCR TEAM                     ", PCONT, PModel(), false, false},
363      {"  10 November 2010                 ", PCONT, PModel(), false, false},
364      {"                                   ", PNONE, PModel(), false, false},
365      {"  Look here, I have a paragraph.   ", PSTART, PModel(kLeft, 0, 20, 0, 0), false, false},
366      {"This paragraph starts at the top of", PCONT, PModel(), false, false},
367      {"the page and takes 3 lines.        ", PCONT, PModel(), false, false},
368      {"  Here I have a second paragraph   ", PSTART, PModel(kLeft, 0, 20, 0, 0), false, false},
369      {"which indicates that the first     ", PCONT, PModel(), false, false},
370      {"paragraph is not a continuation    ", PCONT, PModel(), false, false},
371      {"from a previous page, as it is in- ", PCONT, PModel(), false, false},
372      {"dented just like this second para- ", PCONT, PModel(), false, false},
373      {"graph.                             ", PCONT, PModel(), false, false},
374      {"   Here is a block quote. It       ", PSTART, PModel(kLeft, 30, 0, 0, 0), true, false},
375      {"   looks like the prior text       ", PCONT, PModel(), false, false},
376      {"   but it  is indented  more       ", PCONT, PModel(), false, false},
377      {"   and is fully justified.         ", PCONT, PModel(), false, false},
378      {"  So how does one deal with center-", PSTART, PModel(kLeft, 0, 20, 0, 0), false, false},
379      {"ed text, block quotes, normal para-", PCONT, PModel(), false, false},
380      {"graphs, and lists like what follow?", PCONT, PModel(), false, false},
381      {"1. Make a plan.                    ", PCONT, PModel(), false, false}, 
382      {"2. Use a heuristic, for example,   ", PSTART, PModel(kLeft, 0, 0, 30, 0), false, true},
383      {"   looking for lines where the     ", PCONT, PModel(), false, false},
384      {"   first word of the next line     ", PCONT, PModel(), false, false},
385      {"   would fit on the previous line. ", PCONT, PModel(), false, false},
386      {"8. Try to implement the plan in    ", PSTART, PModel(kLeft, 0, 0, 30, 0), false, true},
387      {"   Python and try it out.          ", PCONT, PModel(), false, false},
388      {"4. Determine how to fix the        ", PSTART, PModel(kLeft, 0, 0, 30, 0), false, true},
389      {"   mistakes.                       ", PCONT, PModel(), false, false},
390      {"5. Repeat.                         ", PSTART, PModel(kLeft, 0, 0, 30, 0), false, true},
391      {"  For extra painful penalty work   ", PSTART, PModel(kLeft, 0, 20, 0, 0), false, false},
392      {"you can try to identify source     ", PCONT, PModel(), false, false},
393      {"code.  Ouch!                       ", PCONT, PModel(), false, false},
394  };
395  TEST(ParagraphsTest, TestComplexPage2) {
396    TestParagraphDetection(kComplexPage2, countof(kComplexPage2));
397  }
398  const TextAndModel kSubtleCrown[] = {
399      {"The first paragraph on a page is", PSTART, PModel(kLeft, 0, 20, 0, 0), true, false},
400      {"often not indented as the rest  ", PCONT, PModel(), false, false},
401      {"of the paragraphs are.  Nonethe-", PCONT, PModel(), false, false},
402      {"less it should be counted as the", PCONT, PModel(), false, false},
403      {"same type of paragraph.         ", PCONT, PModel(), false, false},
404      {"  Even a short second paragraph ", PSTART, PModel(kLeft, 0, 20, 0, 0), false, false},
405      {"should suffice.                 ", PCONT, PModel(), false, false},
406      {"             1235               ", PNONE, PModel(), false, false},
407  };
408  TEST(ParagraphsTest, TestSubtleCrown) {
409    TestParagraphDetection(kSubtleCrown, countof(kSubtleCrown) - 1);
410  }
411  TEST(ParagraphsTest, TestStrayLineInBlock) {
412    TestParagraphDetection(kSubtleCrown, countof(kSubtleCrown));
413  }
414  const TextAndModel kUnlvRep3AO[] = {
415      {"    Defined contribution plans cover employees in Australia, New", PSTART,
416       PModel(kLeft, 0, 50, 0, 0), false, false},
417      {"Zealand, Spain, the United Kingdom and some U.S. subsidiaries.  ", PCONT, PModel(), false,
418       false},
419      {"In addition, employees in the U.S. are eligible to participate in    ", PCONT, PModel(),
420       false, false},
421      {"deﬁned contribution plans (Employee Savings Plans) by contribut-", PCONT, PModel(), false,
422       false},
423      {"ing a portion of their compensation. The Company matches com- ", PCONT, PModel(), false,
424       false},
425      {"pensation, depending on Company proﬁt levels. Contributions    ", PCONT, PModel(), false,
426       false},
427      {"charged to income for deﬁned contribution plans were $92 in    ", PCONT, PModel(), false,
428       false},
429      {"1993, $98 in 1992 and $89 in 1991.                             ", PCONT, PModel(), false,
430       false},
431      {"     In addition to providing pension beneﬁts, the Company pro- ", PSTART,
432       PModel(kLeft, 0, 50, 0, 0), false, false},
433      {"vides certain health care and life insurance beneﬁts to retired     ", PCONT, PModel(), false,
434       false},
435      {"employees. As discussed in Note A, the Company adopted FASB   ", PCONT, PModel(), false,
436       false},
437      {"Statement No. 106 effective January 1, 1992. Previously, the     ", PCONT, PModel(), false,
438       false},
439      {"Company recognized the cost of providing these beneﬁts as the     ", PCONT, PModel(), false,
440       false},
441      {"beneﬁts were paid. These pretax costs amounted to $53 in 1991.   ", PCONT, PModel(), false,
442       false},
443      {"The Company continues to fund most of the cost of these medical ", PCONT, PModel(), false,
444       false},
445      {"and life insurance beneﬁts in the year incurred.                ", PCONT, PModel(), false,
446       false},
447      {"     The U.S. plan covering the parent company is the largest plan.", PSTART,
448       PModel(kLeft, 0, 50, 0, 0), false, false},
449      {"It provides medical and life insurance beneﬁts including hospital,  ", PCONT, PModel(), false,
450       false},
451      {"physicians’ services and major medical expense beneﬁts and life   ", PCONT, PModel(), false,
452       false},
453      {"insurance beneﬁts. The plan provides beneﬁts supplemental to    ", PCONT, PModel(), false,
454       false},
455      {"Medicare after retirees are eligible for these beneﬁts. The cost of  ", PCONT, PModel(),
456       false, false},
457      {"these beneﬁts are shared by the Company and the retiree, with the  ", PCONT, PModel(), false,
458       false},
459      {"Company portion increasing as the retiree has increased years of   ", PCONT, PModel(), false,
460       false},
461      {"credited service. The Company has the ability to change these    ", PCONT, PModel(), false,
462       false},
463      {"beneﬁts at any time.                                            ", PCONT, PModel(), false,
464       false},
465      {"     Effective October 1993, the Company amended its health   ", PSTART,
466       PModel(kLeft, 0, 50, 0, 0), false, false},
467      {"beneﬁts plan in the U.S. to cap the cost absorbed by the Company ", PCONT, PModel(), false,
468       false},
469      {"at approximately twice the 1993 cost per person for employees who", PCONT, PModel(), false,
470       false},
471      {"retire after December 31, 1993. The effect of this amendment was ", PCONT, PModel(), false,
472       false},
473      {"to reduce the December 31, 1993 accumulated postretirement   ", PCONT, PModel(), false,
474       false},
475      {"beneﬁt obligation by $327. It also reduced the net periodic postre- ", PCONT, PModel(), false,
476       false},
477      {"tirement cost by $21 for 1993 and is estimated to reduce this cost  ", PCONT, PModel(), false,
478       false},
479      {"for 1994 by approximately $83.                                     ", PCONT, PModel(), false,
480       false},
481  };
482  TEST(ParagraphsTest, TestUnlvInsurance) {
483    TestParagraphDetection(kUnlvRep3AO, countof(kUnlvRep3AO));
484  }
485  const TextAndModel kTableOfContents[] = {
486      {"1 Hmong People ........... 1", PSTART, PModel(kUnknown, 0, 0, 0, 0), false, false},
487      {"   Hmong Origins . . . . . 1", PSTART, PModel(kUnknown, 0, 0, 0, 0), false, false},
488      {"    Language . . . . . . . 1", PSTART, PModel(kUnknown, 0, 0, 0, 0), false, false},
489      {"     Proverbs . . . . . .  2", PSTART, PModel(kUnknown, 0, 0, 0, 0), false, false},
490      {"        Discussion . . . . 2", PSTART, PModel(kUnknown, 0, 0, 0, 0), false, false},
491      {"     Riddles . . . . . . . 2", PSTART, PModel(kUnknown, 0, 0, 0, 0), false, false},
492      {"        Discussion . . . . 3", PSTART, PModel(kUnknown, 0, 0, 0, 0), false, false},
493      {"     Appearance . . . . .  3", PSTART, PModel(kUnknown, 0, 0, 0, 0), false, false},
494      {"   Hmong History . . . . . 4", PSTART, PModel(kUnknown, 0, 0, 0, 0), false, false},
495      {"    Hmong in SE Asia . . . 4", PSTART, PModel(kUnknown, 0, 0, 0, 0), false, false},
496      {"    Hmong in the West . . .5", PSTART, PModel(kUnknown, 0, 0, 0, 0), false, false},
497      {"    Hmong in the USA . . . 5", PSTART, PModel(kUnknown, 0, 0, 0, 0), false, false},
498      {"        Discussion . . . . 6", PSTART, PModel(kUnknown, 0, 0, 0, 0), false, false},
499  };
500  TEST(ParagraphsTest, TestSplitsOutLeaderLines) {
501    TestParagraphDetection(kTableOfContents, countof(kTableOfContents));
502  }
503  const TextAndModel kTextWithSourceCode[] = {
504      {"  A typical page of a programming book may contain", PSTART, PModel(kLeft, 0, 20, 0, 0),
505       false, false},
506      {"examples of source code to exemplify an algorithm ", PCONT, PModel(), false, false},
507      {"being described in prose.  Such examples should be", PCONT, PModel(), false, false},
508      {"rendered as lineated text, meaning text with      ", PCONT, PModel(), false, false},
509      {"explicit line breaks but without extra inter-line ", PCONT, PModel(), false, false},
510      {"spacing.  Accidentally finding stray paragraphs in", PCONT, PModel(), false, false},
511      {"source code would lead to a bad reading experience", PCONT, PModel(), false, false},
512      {"when the text is re-flowed.                       ", PCONT, PModel(), false, false},
513      {"  Let's show this by describing the function fact-", PSTART, PModel(kLeft, 0, 20, 0, 0),
514       false, false},
515      {"orial.  Factorial is a simple recursive function  ", PCONT, PModel(), false, false},
516      {"which grows very quickly.  So quickly, in fact,   ", PCONT, PModel(), false, false},
517      {"that the typical C implementation will only work  ", PCONT, PModel(), false, false},
518      {"for values less than about 12:                    ", PCONT, PModel(), false, false},
519      {"                                                  ", PNONE, PModel(), false, false},
520      {"  # Naive implementation in C                     ", PCONT, PModel(), false, false},
521      {"  int factorial(int n) {                          ", PCONT, PModel(), false, false},
522      {"    if (n < 2)                                    ", PCONT, PModel(), false, false},
523      {"      return 1;                                   ", PCONT, PModel(), false, false},
524      {"    return  n * factorial(n - 1);                 ", PCONT, PModel(), false, false},
525      {"  }                                               ", PCONT, PModel(), false, false},
526      {"                                                  ", PCONT, PModel(), false, false},
527      {"  The C programming language does not have built- ", PSTART, PModel(kLeft, 0, 20, 0, 0),
528       false, false},
529      {"in support for detecting integer overflow, so this", PCONT, PModel(), false, false},
530      {"naive implementation simply returns random values ", PCONT, PModel(), false, false},
531      {"if even a moderate sized n is provided.           ", PCONT, PModel(), false, false},
532  };
533  TEST(ParagraphsTest, NotDistractedBySourceCode) {
534    TestParagraphDetection(kTextWithSourceCode, countof(kTextWithSourceCode));
535  }
536  const TextAndModel kOldManAndSea[] = {
537      {"royal  palm  which  are called  guano  and  in it  there was a bed,  a", PSTART,
538       PModel(kLeft, 0, 50, 0, 0), false, false},
539      {"table, one chair, and a place on the dirt floor to cook with charcoal.", PCONT, PModel(),
540       false, false},
541      {"On  the  brown  walls  of  the ﬂattened,  overlapping  leaves  of  the", PCONT, PModel(),
542       false, false},
543      {"sturdy  fibered guano  there  was  a  picture in  color of  the Sacred", PCONT, PModel(),
544       false, false},
545      {"Heart  of  Jesus  and  another  of  the  Virgin  of Cobre.  These were", PCONT, PModel(),
546       false, false},
547      {"relics of  his wife.   Once there had been  a tinted photograph of his", PCONT, PModel(),
548       false, false},
549      {"wife on  the wall  but he  had taken  it  down because it made him too", PCONT, PModel(),
550       false, false},
551      {"lonely to see it and it was on the shelf in the corner under his clean", PCONT, PModel(),
552       false, false},
553      {"shirt.                                                                ", PCONT, PModel(),
554       false, false},
555      {"     \"What  do  you  have  to  eat?\"     the  boy   asked.          ", PSTART,
556       PModel(kLeft, 0, 50, 0, 0), false, false},
557      {"     \"A pot of yellow rice with fish. Do you want some?\"            ", PSTART,
558       PModel(kLeft, 0, 50, 0, 0), false, false},
559      {"     \"No. I will eat at home. Do you want me to make the fire?\"   ", PSTART,
560       PModel(kLeft, 0, 50, 0, 0), false, false},
561      {"     \"No. I will make it later on. Or I may eat the rice cold.\"     ", PSTART,
562       PModel(kLeft, 0, 50, 0, 0), false, false},
563      {"     \"May I take the cast net?\"                                     ", PSTART,
564       PModel(kLeft, 0, 50, 0, 0), false, false},
565      {"     \"Of course.\"                                                   ", PSTART,
566       PModel(kLeft, 0, 50, 0, 0), false, false},
567      {"     There was  no  cast net  and  the boy  remembered  when  they had", PSTART,
568       PModel(kLeft, 0, 50, 0, 0), false, false},
569      {"sold it.   But they went through  this fiction every day. There was no", PCONT, PModel(),
570       false, false},
571      {"pot of yellow rice and fish and the boy knew this too.                 "
572       " ",
573       PCONT, PModel(), false, false},
574      {"     \"Eighty-five  is a lucky number,\"  the  old  man  said.   \"How", PSTART,
575       PModel(kLeft, 0, 50, 0, 0), false, false},
576      {"would  you  like to see  me  bring one  in that dressed out over a "
577       "thou-",
578       PCONT, PModel(), false, false},
579      {"sand pounds?                                                           "
580       " ",
581       PCONT, PModel(), false, false},
582      {"     \"I'll get the cast net and go for sardines.  Will you sit in the "
583       "sun",
584       PSTART, PModel(kLeft, 0, 50, 0, 0), false, false},
585      {"in the doorway?\"                                                        "
586       " ",
587       PCONT, PModel(), false, false},
588      {"     \"Yes.  I have yesterday's paper and I will read the baseball.\"   ", PSTART,
589       PModel(kLeft, 0, 50, 0, 0), false, false},
590      {"     The boy  did not  know  whether  yesterday's paper  was a fiction", PSTART,
591       PModel(kLeft, 0, 50, 0, 0), false, false},
592      {"too.  But the old man brought it out from under the bed.              ", PCONT, PModel(),
593       false, false},
594      {"     \"Pedrico gave it to me at the bodega,\" he explained.             "
595       " ",
596       PSTART, PModel(kLeft, 0, 50, 0, 0), false, false},
597      {"     \"I'll be back when I have the sardines.  I'll keep yours and mine", PSTART,
598       PModel(kLeft, 0, 50, 0, 0), false, false},
599      {"together  on ice  and  we  can  share  them  in the  morning.   When I", PCONT, PModel(),
600       false, false},
601      {"come back you can tell me about the baseball.\"                       ", PCONT, PModel(),
602       false, false},
603      {"     \"The Yankees cannot lose.\"                                     ", PSTART,
604       PModel(kLeft, 0, 50, 0, 0), false, false},
605      {"     \"But I fear the Indians of Cleveland.\"                         ", PSTART,
606       PModel(kLeft, 0, 50, 0, 0), false, false},
607      {"     \"Have faith  in  the Yankees  my son.   Think of  the great  Di-", PSTART,
608       PModel(kLeft, 0, 50, 0, 0), false, false},
609      {"Maggio.\"                                                             ", PCONT, PModel(),
610       false, false},
611      {"     \"I  fear both  the Tigers of Detroit  and the  Indians of Cleve-", PSTART,
612       PModel(kLeft, 0, 50, 0, 0), false, false},
613      {"land.\"                                                               ", PCONT, PModel(),
614       false, false}};
615  TEST(ParagraphsTest, NotOverlyAggressiveWithBlockQuotes) {
616    TestParagraphDetection(kOldManAndSea, countof(kOldManAndSea));
617  }
618  const TextAndModel kNewZealandIndex[] = {
619      {"Oats, 51                      ", PSTART, PModel(kLeft, 0, 0, 30, 0), false, false},
620      {"O'Brien, Gregory, 175         ", PSTART, PModel(kLeft, 0, 0, 30, 0), false, false},
621      {"Occupational composition, 110,", PSTART, PModel(kLeft, 0, 0, 30, 0), false, false},
622      {"   138                        ", PCONT, PModel(), false, false},
623      {"OECD rankings, 155, 172       ", PSTART, PModel(kLeft, 0, 0, 30, 0), false, false},
624      {"Okiato (original capital), 47 ", PSTART, PModel(kLeft, 0, 0, 30, 0), false, false},
625      {"Oil shock: 1974, xxx, 143; 1979,", PSTART, PModel(kLeft, 0, 0, 30, 0), false, false},
626      {"   145                        ", PCONT, PModel(), false, false},
627      {"Old Age Pensions, xxii, 89-90 ", PSTART, PModel(kLeft, 0, 0, 30, 0), false, false},
628      {"Old World evils, 77           ", PSTART, PModel(kLeft, 0, 0, 30, 0), false, false},
629      {"Oliver, W. H., 39, 77, 89     ", PSTART, PModel(kLeft, 0, 0, 30, 0), false, false},
630      {"Olssen, Erik, 45, 64, 84      ", PSTART, PModel(kLeft, 0, 0, 30, 0), false, false},
631      {"Olympic Games, 1924, 111, 144 ", PSTART, PModel(kLeft, 0, 0, 30, 0), false, false},
632      {"Once on Chunuk Bair, 149      ", PSTART, PModel(kLeft, 0, 0, 30, 0), false, false},
633      {"Once Were Warriors, xxxiii, 170", PSTART, PModel(kLeft, 0, 0, 30, 0), false, false},
634      {"On—shore whaling, xvi         ", PSTART, PModel(kLeft, 0, 0, 30, 0), false, false},
635      {"Opotiki, xix                  ", PSTART, PModel(kLeft, 0, 0, 30, 0), false, false},
636      {"Orakau battle of, xviii, 57   ", PSTART, PModel(kLeft, 0, 0, 30, 0), false, false},
637      {"O’Regan, Tipene, 170, 198-99  ", PSTART, PModel(kLeft, 0, 0, 30, 0), false, false},
638      {"Organic agriculture, 177      ", PSTART, PModel(kLeft, 0, 0, 30, 0), false, false},
639      {"Orwell, George, 151           ", PSTART, PModel(kLeft, 0, 0, 30, 0), false, false},
640      {"Otago, xvii, 45, 49-50, 70    ", PSTART, PModel(kLeft, 0, 0, 30, 0), false, false},
641      {"Otago block, xvii             ", PSTART, PModel(kLeft, 0, 0, 30, 0), false, false},
642      {"Otago Daily Times, 67         ", PSTART, PModel(kLeft, 0, 0, 30, 0), false, false},
643      {"Otago Girls’ High School, xix, 61,", PSTART, PModel(kLeft, 0, 0, 30, 0), false, false},
644      {"   85                         ", PCONT, PModel(), false, false},
645      {"Otago gold rushes, 61-63      ", PSTART, PModel(kLeft, 0, 0, 30, 0), false, false},
646      {"Otago Peninsula, xx           ", PSTART, PModel(kLeft, 0, 0, 30, 0), false, false},
647      {"Otago Provincial Council, 68  ", PSTART, PModel(kLeft, 0, 0, 30, 0), false, false},
648      {"Otaki, 33                     ", PSTART, PModel(kLeft, 0, 0, 30, 0), false, false},
649      {"Owls Do Cry, 139              ", PSTART, PModel(kLeft, 0, 0, 30, 0), false, false}};
650  TEST(ParagraphsTest, IndexPageTest) {
651    TestParagraphDetection(kNewZealandIndex, countof(kNewZealandIndex));
652  }
653  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-paragraphs_test.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-paragraphs_test.cc</div>
                </div>
                <div class="column column_space"><pre><code>165    tesseract::DetectParagraphs(debug_level, &row_infos, &row_owners, &paragraphs, &models);
166    EvaluateParagraphDetection(correct, num_rows, row_owners);
</pre></code></div>
                <div class="column column_space"><pre><code>165    tesseract::DetectParagraphs(debug_level, &row_infos, &row_owners, &paragraphs, &models);
166    EvaluateParagraphDetection(correct, num_rows, row_owners);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    