
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 9.107806691449815%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-osdetect.cpp</h3>
            <pre><code>1  #include <tesseract/osdetect.h>
2  #include "blobbox.h"
3  #include "blread.h"
4  #include "colfind.h"
5  #include "fontinfo.h"
6  #include "imagefind.h"
7  #include "linefind.h"
8  #include "oldlist.h"
9  #include "qrsequence.h"
10  #include "ratngs.h"
11  #include "tabvector.h"
12  #include "tesseractclass.h"
13  #include "textord.h"
14  #include <algorithm>
15  #include <cmath> 
16  #include <memory>
17  namespace tesseract {
18  const float kSizeRatioToReject = 2.0;
19  const int kMinAcceptableBlobHeight = 10;
20  const float kScriptAcceptRatio = 1.3;
21  const float kHanRatioInKorean = 0.7;
22  const float kHanRatioInJapanese = 0.3;
23  const float kNonAmbiguousMargin = 1.0;
24  static const char *han_script = "Han";
25  static const char *latin_script = "Latin";
26  static const char *katakana_script = "Katakana";
27  static const char *hiragana_script = "Hiragana";
28  static const char *hangul_script = "Hangul";
29  const char *ScriptDetector::korean_script_ = "Korean";
30  const char *ScriptDetector::japanese_script_ = "Japanese";
31  const char *ScriptDetector::fraktur_script_ = "Fraktur";
32  void OSResults::update_best_orientation() {
33    float first = orientations[0];
34    float second = orientations[1];
35    best_result.orientation_id = 0;
36    if (orientations[0] < orientations[1]) {
37      first = orientations[1];
38      second = orientations[0];
39      best_result.orientation_id = 1;
40    }
41    for (int i = 2; i < 4; ++i) {
42      if (orientations[i] > first) {
43        second = first;
44        first = orientations[i];
45        best_result.orientation_id = i;
46      } else if (orientations[i] > second) {
47        second = orientations[i];
48      }
49    }
50    best_result.oconfidence = first - second;
51  }
52  void OSResults::set_best_orientation(int orientation_id) {
53    best_result.orientation_id = orientation_id;
54    best_result.oconfidence = 0;
55  }
56  void OSResults::update_best_script(int orientation) {
57    float first = scripts_na[orientation][1];
58    float second = scripts_na[orientation][2];
59    best_result.script_id = 1;
60    if (scripts_na[orientation][1] < scripts_na[orientation][2]) {
61      first = scripts_na[orientation][2];
62      second = scripts_na[orientation][1];
63      best_result.script_id = 2;
64    }
65    for (int i = 3; i < kMaxNumberOfScripts; ++i) {
66      if (scripts_na[orientation][i] > first) {
67        best_result.script_id = i;
68        second = first;
69        first = scripts_na[orientation][i];
70      } else if (scripts_na[orientation][i] > second) {
71        second = scripts_na[orientation][i];
72      }
73    }
74    best_result.sconfidence =
75        (second == 0.0f) ? 2.0f : (first / second - 1.0) / (kScriptAcceptRatio - 1.0);
76  }
77  int OSResults::get_best_script(int orientation_id) const {
78    int max_id = -1;
79    for (int j = 0; j < kMaxNumberOfScripts; ++j) {
80      const char *script = unicharset->get_script_from_script_id(j);
81      if (strcmp(script, "Common") && strcmp(script, "NULL")) {
82        if (max_id == -1 || scripts_na[orientation_id][j] > scripts_na[orientation_id][max_id]) {
83          max_id = j;
84        }
85      }
86    }
87    return max_id;
88  }
89  void OSResults::print_scores(void) const {
90    for (int i = 0; i < 4; ++i) {
91      tprintf("Orientation id #%d", i);
92      print_scores(i);
93    }
94  }
95  void OSResults::print_scores(int orientation_id) const {
96    for (int j = 0; j < kMaxNumberOfScripts; ++j) {
97      if (scripts_na[orientation_id][j]) {
98        tprintf("%12s\t: %f\n", unicharset->get_script_from_script_id(j),
99                scripts_na[orientation_id][j]);
100      }
101    }
102  }
103  void OSResults::accumulate(const OSResults &osr) {
104    for (int i = 0; i < 4; ++i) {
105      orientations[i] += osr.orientations[i];
106      for (int j = 0; j < kMaxNumberOfScripts; ++j) {
107        scripts_na[i][j] += osr.scripts_na[i][j];
108      }
109    }
110    unicharset = osr.unicharset;
111    update_best_orientation();
112    update_best_script(best_result.orientation_id);
113  }
114  static void remove_nontext_regions(tesseract::Tesseract *tess, BLOCK_LIST *blocks,
115                                     TO_BLOCK_LIST *to_blocks) {
116    Image pix = tess->pix_binary();
117    ASSERT_HOST(pix != nullptr);
118    int vertical_x = 0;
119    int vertical_y = 1;
120    tesseract::TabVector_LIST v_lines;
121    tesseract::TabVector_LIST h_lines;
122    int resolution;
123    if (kMinCredibleResolution > pixGetXRes(pix)) {
124      resolution = kMinCredibleResolution;
125      tprintf("Warning. Invalid resolution %d dpi. Using %d instead.\n", pixGetXRes(pix), resolution);
126    } else {
127      resolution = pixGetXRes(pix);
128    }
129    tesseract::LineFinder::FindAndRemoveLines(resolution, false, pix, &vertical_x, &vertical_y,
130                                              nullptr, &v_lines, &h_lines);
131    Image im_pix = tesseract::ImageFind::FindImages(pix, nullptr);
132    if (im_pix != nullptr) {
133      pixSubtract(pix, pix, im_pix);
134      im_pix.destroy();
135    }
136    tess->mutable_textord()->find_components(tess->pix_binary(), blocks, to_blocks);
137  }
138  int orientation_and_script_detection(const char *filename, OSResults *osr,
139                                       tesseract::Tesseract *tess) {
140    std::string name = filename; 
141    const char *lastdot = strrchr(name.c_str(), '.');
142    if (lastdot != nullptr) {
143      name[lastdot - name.c_str()] = '\0';
144    }
145    ASSERT_HOST(tess->pix_binary() != nullptr);
146    int width = pixGetWidth(tess->pix_binary());
147    int height = pixGetHeight(tess->pix_binary());
148    BLOCK_LIST blocks;
149    if (!read_unlv_file(name, width, height, &blocks)) {
150      FullPageBlock(width, height, &blocks);
151    }
152    TO_BLOCK_LIST land_blocks, port_blocks;
153    remove_nontext_regions(tess, &blocks, &port_blocks);
154    if (port_blocks.empty()) {
155      tess->mutable_textord()->find_components(tess->pix_binary(), &blocks, &port_blocks);
156    } else {
157      TBOX page_box(0, 0, width, height);
158      tess->mutable_textord()->filter_blobs(page_box.topright(), &port_blocks, true);
159    }
160    return os_detect(&port_blocks, osr, tess);
161  }
162  int os_detect(TO_BLOCK_LIST *port_blocks, OSResults *osr, tesseract::Tesseract *tess) {
163    int blobs_total = 0;
164    TO_BLOCK_IT block_it;
165    block_it.set_to_list(port_blocks);
166    BLOBNBOX_CLIST filtered_list;
167    BLOBNBOX_C_IT filtered_it(&filtered_list);
168    for (block_it.mark_cycle_pt(); !block_it.cycled_list(); block_it.forward()) {
169      TO_BLOCK *to_block = block_it.data();
170      if (to_block->block->pdblk.poly_block() && !to_block->block->pdblk.poly_block()->IsText()) {
171        continue;
172      }
173      BLOBNBOX_IT bbox_it;
174      bbox_it.set_to_list(&to_block->blobs);
175      for (bbox_it.mark_cycle_pt(); !bbox_it.cycled_list(); bbox_it.forward()) {
176        BLOBNBOX *bbox = bbox_it.data();
177        C_BLOB *blob = bbox->cblob();
178        TBOX box = blob->bounding_box();
179        ++blobs_total;
180        if (box.width() == 0) {
181          continue;
182        }
183        float y_x = std::fabs((box.height() * 1.0f) / box.width());
184        float x_y = 1.0f / y_x;
185        float ratio = x_y > y_x ? x_y : y_x;
186        if (ratio > kSizeRatioToReject) {
187          continue;
188        }
189        if (box.height() < kMinAcceptableBlobHeight) {
190          continue;
191        }
192        filtered_it.add_to_end(bbox);
193      }
194    }
195    return os_detect_blobs(nullptr, &filtered_list, osr, tess);
196  }
197  int os_detect_blobs(const std::vector<int> *allowed_scripts, BLOBNBOX_CLIST *blob_list,
198                      OSResults *osr, tesseract::Tesseract *tess) {
199    OSResults osr_;
200    int minCharactersToTry = tess->min_characters_to_try;
201    int maxCharactersToTry = 5 * minCharactersToTry;
202    if (osr == nullptr) {
203      osr = &osr_;
204    }
205    osr->unicharset = &tess->unicharset;
206    OrientationDetector o(allowed_scripts, osr);
207    ScriptDetector s(allowed_scripts, osr, tess);
208    BLOBNBOX_C_IT filtered_it(blob_list);
209    int real_max = std::min(filtered_it.length(), maxCharactersToTry);
210    if (real_max < minCharactersToTry / 2) {
211      tprintf("Too few characters. Skipping this page\n");
212      return 0;
213    }
214    auto **blobs = new BLOBNBOX *[filtered_it.length()];
215    int number_of_blobs = 0;
216    for (filtered_it.mark_cycle_pt(); !filtered_it.cycled_list(); filtered_it.forward()) {
217      blobs[number_of_blobs++] = filtered_it.data();
218    }
219    QRSequenceGenerator sequence(number_of_blobs);
220    int num_blobs_evaluated = 0;
221    for (int i = 0; i < real_max; ++i) {
222      if (os_detect_blob(blobs[sequence.GetVal()], &o, &s, osr, tess) && i > minCharactersToTry) {
223        break;
224      }
225      ++num_blobs_evaluated;
226    }
227    delete[] blobs;
228    int orientation = o.get_orientation();
229    osr->update_best_script(orientation);
230    return num_blobs_evaluated;
231  }
232  bool os_detect_blob(BLOBNBOX *bbox, OrientationDetector *o, ScriptDetector *s, OSResults *osr,
233                      tesseract::Tesseract *tess) {
234    tess->tess_cn_matching.set_value(true); 
235    tess->tess_bn_matching.set_value(false);
<span onclick='openModal()' class='match'>236    C_BLOB *blob = bbox->cblob();
237    TBLOB *tblob = TBLOB::PolygonalCopy(tess->poly_allow_detailed_fx, blob);
238    TBOX box = tblob->bounding_box();
239    FCOORD current_rotation(1.0f, 0.0f);
240    FCOORD rotation90(0.0f, 1.0f);
241    BLOB_CHOICE_LIST ratings[4];
242    for (int i = 0; i < 4; ++i) {
243      float scaling = static_cast<float>(kBlnXHeight) / box.height();
</span>244      float x_origin = (box.left() + box.right()) / 2.0f;
245      float y_origin = (box.bottom() + box.top()) / 2.0f;
246      if (i == 0 || i == 2) {
247        y_origin = i == 0 ? box.bottom() : box.top();
248      } else {
249        scaling = static_cast<float>(kBlnXHeight) / box.width();
250        x_origin = i == 1 ? box.left() : box.right();
251      }
252      std::unique_ptr<TBLOB> rotated_blob(new TBLOB(*tblob));
253      rotated_blob->Normalize(nullptr, &current_rotation, nullptr, x_origin, y_origin, scaling,
254                              scaling, 0.0f, static_cast<float>(kBlnBaselineOffset), false, nullptr);
255      tess->AdaptiveClassifier(rotated_blob.get(), ratings + i);
256      current_rotation.rotate(rotation90);
257    }
258    delete tblob;
259    bool stop = o->detect_blob(ratings);
260    s->detect_blob(ratings);
261    int orientation = o->get_orientation();
262    stop = s->must_stop(orientation) && stop;
263    return stop;
264  }
265  OrientationDetector::OrientationDetector(const std::vector<int> *allowed_scripts, OSResults *osr) {
266    osr_ = osr;
267    allowed_scripts_ = allowed_scripts;
268  }
269  bool OrientationDetector::detect_blob(BLOB_CHOICE_LIST *scores) {
270    float blob_o_score[4] = {0.0f, 0.0f, 0.0f, 0.0f};
271    float total_blob_o_score = 0.0f;
272    for (int i = 0; i < 4; ++i) {
273      BLOB_CHOICE_IT choice_it(scores + i);
274      if (!choice_it.empty()) {
275        BLOB_CHOICE *choice = nullptr;
276        if (allowed_scripts_ != nullptr && !allowed_scripts_->empty()) {
277          for (choice_it.mark_cycle_pt(); !choice_it.cycled_list() && choice == nullptr;
278               choice_it.forward()) {
279            int choice_script = choice_it.data()->script_id();
280            unsigned s = 0;
281            for (s = 0; s < allowed_scripts_->size(); ++s) {
282              if ((*allowed_scripts_)[s] == choice_script) {
283                choice = choice_it.data();
284                break;
285              }
286            }
287          }
288        } else {
289          choice = choice_it.data();
290        }
291        if (choice != nullptr) {
292          blob_o_score[i] = 1 + 0.05 * choice->certainty();
293          total_blob_o_score += blob_o_score[i];
294        }
295      }
296    }
297    if (total_blob_o_score == 0.0) {
298      return false;
299    }
300    float worst_score = 0.0f;
301    int num_good_scores = 0;
302    for (float f : blob_o_score) {
303      if (f > 0.0f) {
304        ++num_good_scores;
305        if (worst_score == 0.0f || f < worst_score) {
306          worst_score = f;
307        }
308      }
309    }
310    if (num_good_scores == 1) {
311      worst_score /= 2.0f;
312    }
313    for (float &f : blob_o_score) {
314      if (f == 0.0f) {
315        f = worst_score;
316        total_blob_o_score += worst_score;
317      }
318    }
319    for (int i = 0; total_blob_o_score != 0 && i < 4; ++i) {
320      osr_->orientations[i] += std::log(blob_o_score[i] / total_blob_o_score);
321    }
322    return false;
323  }
324  int OrientationDetector::get_orientation() {
325    osr_->update_best_orientation();
326    return osr_->best_result.orientation_id;
327  }
328  ScriptDetector::ScriptDetector(const std::vector<int> *allowed_scripts, OSResults *osr,
329                                 tesseract::Tesseract *tess) {
330    osr_ = osr;
331    tess_ = tess;
332    allowed_scripts_ = allowed_scripts;
333    katakana_id_ = tess_->unicharset.add_script(katakana_script);
334    hiragana_id_ = tess_->unicharset.add_script(hiragana_script);
335    han_id_ = tess_->unicharset.add_script(han_script);
336    hangul_id_ = tess_->unicharset.add_script(hangul_script);
337    japanese_id_ = tess_->unicharset.add_script(japanese_script_);
338    korean_id_ = tess_->unicharset.add_script(korean_script_);
339    latin_id_ = tess_->unicharset.add_script(latin_script);
340    fraktur_id_ = tess_->unicharset.add_script(fraktur_script_);
341  }
342  void ScriptDetector::detect_blob(BLOB_CHOICE_LIST *scores) {
343    for (int i = 0; i < 4; ++i) {
344      std::vector<bool> done(kMaxNumberOfScripts);
345      BLOB_CHOICE_IT choice_it;
346      choice_it.set_to_list(scores + i);
347      float prev_score = -1;
348      int script_count = 0;
349      int prev_id = -1;
350      int prev_fontinfo_id = -1;
351      const char *prev_unichar = "";
352      const char *unichar = "";
353      for (choice_it.mark_cycle_pt(); !choice_it.cycled_list(); choice_it.forward()) {
354        BLOB_CHOICE *choice = choice_it.data();
355        int id = choice->script_id();
356        if (allowed_scripts_ != nullptr && !allowed_scripts_->empty()) {
357          size_t s = 0;
358          for (s = 0; s < allowed_scripts_->size(); ++s) {
359            if ((*allowed_scripts_)[s] == id) {
360              break;
361            }
362          }
363          if (s == allowed_scripts_->size()) {
364            continue; 
365          }
366        }
367        if (done.at(id)) {
368          continue;
369        }
370        done[id] = true;
371        unichar = tess_->unicharset.id_to_unichar(choice->unichar_id());
372        if (prev_score < 0) {
373          prev_score = -choice->certainty();
374          script_count = 1;
375          prev_id = id;
376          prev_unichar = unichar;
377          prev_fontinfo_id = choice->fontinfo_id();
378        } else if (-choice->certainty() < prev_score + kNonAmbiguousMargin) {
379          ++script_count;
380        }
381        if (strlen(prev_unichar) == 1) {
382          if (unichar[0] >= '0' && unichar[0] <= '9') {
383            break;
384          }
385        }
386        if (script_count >= 2) {
387          break;
388        }
389      }
390      if (script_count == 1) {
391        osr_->scripts_na[i][prev_id] += 1.0;
392        if (prev_id == latin_id_) {
393          if (prev_fontinfo_id >= 0) {
394            const tesseract::FontInfo &fi = tess_->get_fontinfo_table().at(prev_fontinfo_id);
395            if (fi.is_fraktur()) {
396              osr_->scripts_na[i][prev_id] -= 1.0;
397              osr_->scripts_na[i][fraktur_id_] += 1.0;
398            }
399          }
400        }
401        if (prev_id == katakana_id_) {
402          osr_->scripts_na[i][japanese_id_] += 1.0;
403        }
404        if (prev_id == hiragana_id_) {
405          osr_->scripts_na[i][japanese_id_] += 1.0;
406        }
407        if (prev_id == hangul_id_) {
408          osr_->scripts_na[i][korean_id_] += 1.0;
409        }
410        if (prev_id == han_id_) {
411          osr_->scripts_na[i][korean_id_] += kHanRatioInKorean;
412          osr_->scripts_na[i][japanese_id_] += kHanRatioInJapanese;
413        }
414      }
415    } 
416  }
417  bool ScriptDetector::must_stop(int orientation) const {
418    osr_->update_best_script(orientation);
419    return osr_->best_result.sconfidence > 1;
420  }
421  int OrientationIdToValue(const int &id) {
422    switch (id) {
423      case 0:
424        return 0;
425      case 1:
426        return 270;
427      case 2:
428        return 180;
429      case 3:
430        return 90;
431      default:
432        return -1;
433    }
434  }
435  } 
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-nmobj.cpp</h3>
            <pre><code>1  #include "nmobj.h"
2  TNmObjBs::TNmObjBs(
3   const TSwSetType& SwSetType, const PSIn& CustSwSetSIn,
4   const PSIn& NrWordBsSIn, const PSIn& WordTypeBsSIn, const TStr& MteFNm):
5    ChDef(),
6    WordStrToNrH(),
7    WordStrVToNmObjAttrSetH(),
8    NmObjWordStrVToNrH(),
9    NmObjWordStrVToDocIdVH(),
10    DocNmToNmObjDocH(){
11    ChDef=THtmlLxChDef::GetChDef();
12    SwSet=TSwSet::GetSwSet(SwSetType);
13    LoadCustSwSet(CustSwSetSIn);
14    LoadNrWordBs(NrWordBsSIn);
15    LoadNmObjTypeBs(WordTypeBsSIn);
16    if (!MteFNm.Empty()){
17      }
18  }
19  TStr TNmObjBs::PeriodTagStr="<.>";
20  TStr TNmObjBs::BreakTagStr="<br>";
21  TStr TNmObjBs::ParagraphTagStr="<p>";
22  TStr TNmObjBs::EofTagStr="<eof>";
23  void TNmObjBs::LoadCustSwSet(const PSIn& SIn){
24    if (SIn.Empty()){return;}
25    TILx Lx(SIn, TFSet(iloCmtAlw, iloRetEoln, iloExcept));
26    Lx.GetSym(syLn, syEof);
27    while (Lx.Sym!=syEof){
28      TStr WordStrVStr=Lx.Str;
29      TStrV WordStrV; WordStrVStr.SplitOnWs(WordStrV);
30      if (!WordStrV.Empty()){
31        WordStrVToNmObjAttrSetH.AddDat(WordStrV).Incl(noaIgnore);
32      }
33      Lx.GetSym(syLn, syEof);
34    }
35  }
36  void TNmObjBs::LoadNrWordBs(const PSIn& SIn){
37    if (SIn.Empty()){return;}
38    TILx Lx(SIn, TFSet(iloCmtAlw, iloRetEoln, iloExcept));
39    Lx.GetSym(syQStr, syEoln, syEof);
40    while (Lx.Sym!=syEof){
41      if (Lx.Sym==syQStr){
42        TStr NrWordStr=Lx.Str;
43        Lx.GetSym(syColon);
44        Lx.GetSym(syQStr, syEoln);
45        while (Lx.Sym!=syEoln){
46          TStr WordStr=Lx.Str;
47          if (WordStrToNrH.IsKey(WordStr)){
48            printf("Word already normalized (%s)", WordStr.CStr());}
49          WordStrToNrH.AddDat(WordStr, NrWordStr);
50          Lx.GetSym(syQStr, syEoln);
51        }
52        Lx.GetSym(syQStr, syEoln, syEof);
53      } else
54      if (Lx.Sym==syEoln){
55        Lx.GetSym(syQStr, syEoln, syEof);
56      } else {
57        Fail;
58      }
59    }
60  }
61  TStr TNmObjBs::GetNrWordStr(const TStr& _WordStr) const {
62    TStr WordStr=_WordStr;
63    if (WordStr.IsChIn('_')){
64      WordStr.ChangeChAll('_', '$');
65    }
66    TStr NrWordStr;
67    if (WordStrToNrH.IsKeyGetDat(WordStr, NrWordStr)){
68      return NrWordStr;
69    } else
70    if (MteLex.Empty()){
71      return WordStr;
72    } else {
73      TStr UcWordStr=ChDef->GetUcStr(WordStr); 
74      TStr NrUcWordStr;
75      if (MteLex->IsInfWord(UcWordStr, NrUcWordStr)){
76        if (UcWordStr==NrUcWordStr){
77          return WordStr;
78        } else
79        if (IsAllCapWordStr(WordStr)){
80          return NrUcWordStr;
81        } else
82        if (IsFirstCapWordStr(WordStr)){
83          TChA NrWordChA(NrUcWordStr);
84          ChDef->GetLcChA(NrWordChA);
85          if (NrWordChA.Len()>0){
86            NrWordChA.PutCh(0, ChDef->GetUc(NrWordChA[0]));}
87          return NrWordChA;
88        } else {
89          TStr NrLcWordStr=ChDef->GetLcStr(NrUcWordStr);
90          return NrLcWordStr;
91        }
92      } else {
93        return WordStr;
94      }
95    }
96  }
97  TNmObjAttr TNmObjBs::GetNmObjTypeFromStr(const TStr& Str){
98    if (Str=="Ignore"){return noaIgnore;}
99    if (Str=="Standalone"){return noaStandalone;}
100    if (Str=="AsCapitalized"){return noaAsCapitalized;}
101    if (Str=="Unperiod"){return noaUnperiod;}
102    if (Str=="Acronym"){return noaAcronym;}
103    if (Str=="FirstName"){return noaFirstName;}
104    if (Str=="Person"){return noaPerson;}
105    if (Str=="Company"){return noaCompany;}
106    if (Str=="Organization"){return noaOrganization;}
107    if (Str=="Country"){return noaCountry;}
108    if (Str=="Geography"){return noaGeography;}
109    TExcept::Throw("Invalid Named-Object name.", Str);
110    return noaIgnore;
111  }
112  void TNmObjBs::LoadNmObjTypeBs(const PSIn& SIn){
113    if (SIn.Empty()){return;}
114    TILx Lx(SIn, TFSet(iloCmtAlw, iloRetEoln, iloExcept));
115    Lx.GetSym(syQStr, syIdStr, syEoln, syEof);
116    while (Lx.Sym!=syEof){
117      if ((Lx.Sym==syQStr)||(Lx.Sym==syIdStr)){
118        TVec<TStrV> NmObjWordStrVV;
119        TB32Set NmObjAttrSet;
120        while ((Lx.Sym==syQStr)||(Lx.Sym==syIdStr)){
121          if (Lx.Sym==syQStr){
122            TStr WordStrVStr=Lx.Str;
123            TStrV WordStrV; WordStrVStr.SplitOnWs(WordStrV);
124            NmObjWordStrVV.Add(WordStrV);
125          } else
126          if (Lx.Sym==syIdStr){
127            TNmObjAttr NmObjAttr=TNmObjBs::GetNmObjTypeFromStr(Lx.Str);
128            NmObjAttrSet.Incl(NmObjAttr);
129          } else {
130            Fail;
131          }
132          Lx.GetSym(syQStr, syIdStr, syEoln, syEof);
133        }
134        if (!NmObjAttrSet.In(noaIgnore)){
135          NmObjAttrSet.Incl(noaDefined);}
136        for (int NmObjN=0; NmObjN<NmObjWordStrVV.Len(); NmObjN++){
137          WordStrVToNmObjAttrSetH.AddDat(NmObjWordStrVV[NmObjN])|=NmObjAttrSet;
138        }
139        {for (int NmObjN=1; NmObjN<NmObjWordStrVV.Len(); NmObjN++){
140          NmObjWordStrVToNrH.AddDat(NmObjWordStrVV[NmObjN], NmObjWordStrVV[0]);
141        }}
142      } else
143      if (Lx.Sym==syEoln){
144        Lx.GetSym(syQStr, syEoln, syEof);
145      } else {
146        Fail;
147      }
148    }
149  }
150  bool TNmObjBs::IsNmObjAttr(const TStr& WordStr, const TNmObjAttr& NmObjAttr) const {
151    TStrV WordStrV; WordStrV.Add(WordStr);
152    return IsNmObjAttr(WordStrV, NmObjAttr);
153  }
154  bool TNmObjBs::IsNmObjAttr(const TStrV& WordStrV, const TNmObjAttr& NmObjAttr) const {
155    int WordStrVToNmObjAttrSetP=WordStrVToNmObjAttrSetH.GetKeyId(WordStrV);
156    if (WordStrVToNmObjAttrSetP==-1){return false;}
157    else {return WordStrVToNmObjAttrSetH[WordStrVToNmObjAttrSetP].In(NmObjAttr);}
158  }
159  bool TNmObjBs::IsFirstCapWordStr(const TStr& Str) const {
160    if (Str.Empty()){return false;}
161    char FirstCh=Str[0];
162    if (!ChDef->IsAlpha(FirstCh)){return false;}
163    if (!ChDef->IsUc(FirstCh)){return false;}
164    return true;
165  }
166  bool TNmObjBs::IsAllCapWordStr(const TStr& Str) const {
167    TChA ChA=Str;
168    for (int ChN=0; ChN<ChA.Len(); ChN++){
169      if (!ChDef->IsUc(ChA[ChN])){return false;}
170    }
171    return true;
172  }
173  bool TNmObjBs::IsNumStr(const TStr& Str) const {
174    if (Str.Empty()){return false;}
175    char FirstCh=Str[0];
176    if (!ChDef->IsNum(FirstCh)){return false;}
177    return true;
178  }
179  bool TNmObjBs::IsTagStr(const TStr& Str) const {
180    return (!Str.Empty())&&(Str[0]=='<');
181  }
182  bool TNmObjBs::IsMatchPfx(
183   const TStr& Str1, const TStr& Str2,
184   const int& MnPfxLen, const int& MxSfxLen) const {
185    TChA ChA1=Str1; TChA ChA2=Str2;
186    int ChN=0;
187    forever {
188      if (ChN>=ChA1.Len()){break;}
189      if (ChN>=ChA2.Len()){break;}
190      if (ChA1[ChN]!=ChA2[ChN]){break;}
191      ChN++;
192    }
193    if (ChN+1<=MnPfxLen){return false;}
194    if (ChA1.Len()-ChN+1>MxSfxLen){return false;}
195    if (ChA2.Len()-ChN+1>MxSfxLen){return false;}
196    return true;
197  }
198  int TNmObjBs::GetNmObjId(const TStrV& WordStrV, const bool& DefP){
199    int NmObjId=-1;
200    if (DefP){
201      NmObjId=NmObjWordStrVToDocIdVH.AddKey(WordStrV);
202    } else {
203      NmObjId=NmObjWordStrVToDocIdVH.GetKeyId(WordStrV);
204    }
205    return NmObjId;
206  }
207  TStr TNmObjBs::GetWordStrVStr(const TStrV& WordStrV, const char& SepCh) const {
208    TChA WordChA;
209    for (int WordStrN=0; WordStrN<WordStrV.Len(); WordStrN++){
210      if (WordStrN>0){WordChA+=SepCh;}
211      WordChA+=WordStrV[WordStrN];
212    }
213    return WordChA;
214  }
215  void TNmObjBs::GetNrNmObjStrV(const TStrV& NmObjStrV, TStrV& NrNmObjStrV) const {
216    int NmObjWordStrVToNrP=NmObjWordStrVToNrH.GetKeyId(NmObjStrV);
217    if (NmObjWordStrVToNrP==-1){NrNmObjStrV=NmObjStrV;}
218    else {NrNmObjStrV=NmObjWordStrVToNrH[NmObjWordStrVToNrP];}
219  }
220  void TNmObjBs::ExtrCandWordStrV(
221   const TStr& HtmlStr, TStrV& CandWordStrV, const bool& DumpP){
222    CandWordStrV.Clr();
223    PSIn HtmlSIn=TStrIn::New(HtmlStr);
224    PHtmlDoc HtmlDoc=THtmlDoc::New(HtmlSIn, hdtAll, false);
225    PHtmlTok Tok;
226    THtmlLxSym Sym; TStr Str; TStr NrStr;
227    CandWordStrV.Add(PeriodTagStr);
228    bool InTitle=false; bool InScript=false; int LastNmObjTokN=-1;
229    if (DumpP){printf("Tokens: ");}
230    for (int TokN=0; TokN<HtmlDoc->GetToks(); TokN++){
231      PHtmlTok Tok=HtmlDoc->GetTok(TokN);
232      HtmlDoc->GetTok(TokN, Sym, Str);
233      switch (Sym){
234        case hsyUndef: break;
235        case hsyStr:
236        case hsyNum:
237          if (InTitle){break;}
238          if (InScript){break;}
239          NrStr=GetNrWordStr(Str);
240          if (DumpP){
241            if (Str==NrStr){printf("%s ", Str.CStr());}
242            else {printf("%s(%s) ", Str.CStr(), NrStr.CStr());}
243          }
244          if (IsFirstCapWordStr(NrStr)||IsNmObjAttr(NrStr, noaAsCapitalized)){
245            if ((LastNmObjTokN!=-1)&&(LastNmObjTokN<TokN-1)){
246              if (CandWordStrV.Last()!=PeriodTagStr){
247                CandWordStrV.Add(BreakTagStr);
248              }
249            }
250            CandWordStrV.Add(NrStr); LastNmObjTokN=TokN;
251          }
252          break;
253        case hsySSym:
254          if (InTitle){break;}
255          if (InScript){break;}
256          if (DumpP){
257            printf("%s ", Str.CStr());}
258          if (
259           (Str==".")||(Str=="!")||(Str=="?")||
260           (Str=="\"")||(Str=="-")||(Str=="/")||
261           (Str==":")||(Str==";")){
262            if (CandWordStrV.Last()!=PeriodTagStr){
263              CandWordStrV.Add(PeriodTagStr);
264            }
265          }
266          break;
267        case hsyBTag:
268        case hsyETag:
269          if (Str=="<TITLE>"){
270            InTitle=(Sym==hsyBTag);
271          } else
272          if (Str=="<SCRIPT>"){
273            InScript=(Sym==hsyBTag);
274          } else
275          if (Str=="<P>"){
276            if ((!CandWordStrV.Empty())&&(CandWordStrV.Last()!=ParagraphTagStr)){
277              CandWordStrV.Add(ParagraphTagStr);
278              CandWordStrV.Add(PeriodTagStr);
279            }
280          } else
281          if ((Str=="<TD>")||(Str=="<BR>")){
282            CandWordStrV.Add(PeriodTagStr);
283          }
284          break;
285        case hsyEof: break;
286        default: break;
287      }
288    }
289    CandWordStrV.Add(EofTagStr);
290    if (DumpP){printf("\n");}
291    if (DumpP){
292      printf("Candidates: ");
293      for (int CandWordStrN=0; CandWordStrN<CandWordStrV.Len(); CandWordStrN++){
294        printf("%s ", CandWordStrV[CandWordStrN].CStr());}
295      printf("\n");
296    }
297  }
298  void TNmObjBs::FilterCandToNmObjIdV(
299   const TStrV& CandWordStrV, TIntV& NmObjIdV, const bool& DumpP){
300    TVec<TStrV> NmObjIdWordStrVV;
301    int CandWordStrN=0; int CandWordStrs=CandWordStrV.Len();
302    while (CandWordStrN<CandWordStrs){
303      TStr WordStr=CandWordStrV[CandWordStrN];
304      if (WordStr.Len()<=1){CandWordStrN++; continue;}
305      if (WordStr==ParagraphTagStr){CandWordStrN++; continue;}
306      if (WordStr==BreakTagStr){CandWordStrN++; continue;}
307      if (WordStr==EofTagStr){CandWordStrN++; break;}
308      if (IsNumStr(WordStr)){CandWordStrN++; continue;}
309      TStr UcWordStr=ChDef->GetUcStr(WordStr);
310      if ((WordStr==UcWordStr)&&((WordStr.Len()>4)&&(!IsNmObjAttr(WordStr, noaAcronym)))){
311        CandWordStrN++; continue;}
312      if (IsNmObjAttr(WordStr, noaUnperiod)&&(CandWordStrV[CandWordStrN+1]==PeriodTagStr)){
313        CandWordStrN+=1;
314      }
315      if (WordStr==PeriodTagStr){
316        CandWordStrN++; WordStr=CandWordStrV[CandWordStrN];
317        if (IsTagStr(WordStr)){continue;}
318        if (IsNmObjAttr(WordStr, noaDefined)){
319          continue;
320        } else 
321        if ((CandWordStrN>1)&&(IsNmObjAttr(CandWordStrV[CandWordStrN-2], noaUnperiod))){
322          continue;
323        } else {
324          TStr NextWordStr=CandWordStrV[CandWordStrN+1];
325          if (IsFirstCapWordStr(NextWordStr)||IsNmObjAttr(NextWordStr, noaAsCapitalized)){
326            continue;
327          } else 
328          if (!IsNmObj(WordStr)){
329            CandWordStrN++; continue;
330          }
331        }
332      }
333      if (IsNmObjAttr(WordStr, noaIgnore)){
334        CandWordStrN++; continue;
335      } 
336      TStrV WordStrV;
337      forever {
338        WordStrV.Add(WordStr);
339        CandWordStrN++; WordStr=CandWordStrV[CandWordStrN];
340        if (IsTagStr(WordStr)){break;}
341        if (WordStr.Len()<=1){break;}
342        if (IsNmObjAttr(WordStr, noaIgnore)){CandWordStrN++; break;}
343        if (IsNmObjAttr(WordStr, noaStandalone)){break;}
344        if (IsNmObjAttr(WordStrV, noaStandalone)){break;}
345      }
346      TStrV NrWordStrV; GetNrNmObjStrV(WordStrV, NrWordStrV);
347      if (IsNmObjAttr(NrWordStrV, noaIgnore)){continue;}
348      if (IsNmObjAttr(NrWordStrV, noaFirstName)){continue;}
349      if (NrWordStrV.Len()>5){
350        while (NrWordStrV.Len()>2){NrWordStrV.Del(0);}}
351      if (NrWordStrV.Len()==1){
352        TStr UcWordStr=ChDef->GetUcStr(NrWordStrV[0]);
353        if (SwSet->IsIn(UcWordStr, true)){continue;}
354      }
355      NmObjIdWordStrVV.Add(NrWordStrV);
356    }
357    for (int NmObjN=0; NmObjN<NmObjIdWordStrVV.Len(); NmObjN++){
358      TStrV& WordStrV=NmObjIdWordStrVV[NmObjN];
359      if (WordStrV.Len()==1){
360        for (int SubNmObjN=0; SubNmObjN<NmObjIdWordStrVV.Len(); SubNmObjN++){
361          TStrV& SubWordStrV=NmObjIdWordStrVV[SubNmObjN];
362          if (SubWordStrV.Len()==1){
363            if (WordStrV[0]!=SubWordStrV[0]){
364              if (IsMatchPfx(WordStrV[0], SubWordStrV[0], 3, 4)){
365                if (WordStrV[0].Len()<SubWordStrV[0].Len()){SubWordStrV=WordStrV;}
366                else {WordStrV=SubWordStrV;}
367              }
368            }
369          }
370        }
371      } else
372      if (WordStrV.Len()>=2){
373        TStr LastNm=WordStrV.Last();
374        for (int SubNmObjN=0; SubNmObjN<NmObjIdWordStrVV.Len(); SubNmObjN++){
375          TStrV& SubWordStrV=NmObjIdWordStrVV[SubNmObjN];
376          if (SubWordStrV.Len()==1){
377            TStr SubLastNm=SubWordStrV[0];
378            if (LastNm!=SubLastNm){
379              if (IsMatchPfx(LastNm, SubLastNm, 3, 4)){
380                if (LastNm.Len()<SubLastNm.Len()){SubWordStrV=WordStrV;} 
381                else {WordStrV=SubWordStrV;}
382              }
383            }
384          } else
385          if (false&&(SubWordStrV.Len()==2)){
386            if ((WordStrV[0]!=SubWordStrV[0])||(WordStrV[1]!=SubWordStrV[1])){
387              if ((IsMatchPfx(WordStrV[0], SubWordStrV[0], 3, 4))&&
388               (IsMatchPfx(WordStrV[1], SubWordStrV[1], 3, 4))){
389                if (WordStrV[0].Len()<SubWordStrV[0].Len()){
390                  SubWordStrV[0]=WordStrV[0];}
391                else {WordStrV[0]=SubWordStrV[0];}
392                if (WordStrV[1].Len()<SubWordStrV[1].Len()){
393                  SubWordStrV[1]=WordStrV[1];}
394                else {WordStrV[1]=SubWordStrV[1];}
395              }
396            }
397          }
398        }
399      }
400    }
401    NmObjIdV.Gen(NmObjIdWordStrVV.Len(), 0);
402    {for (int NmObjN=0; NmObjN<NmObjIdWordStrVV.Len(); NmObjN++){
403      TStrV& NmObjWordStrV=NmObjIdWordStrVV[NmObjN];
404      int NmObjId=GetNmObjId(NmObjWordStrV, true);
405      NmObjIdV.Add(NmObjId);
406    }}
407    if (DumpP){
408      printf("Named-Objects: ");
409      for (int NmObjN=0; NmObjN<NmObjIdV.Len(); NmObjN++){
410        int NmObjId=NmObjIdV[NmObjN];
411        TStr NmObjStr=GetNmObjStr(NmObjId);
412        printf("%s ", NmObjStr.CStr());
413      }
414      printf("\n");
415    }
416  }
417  PNmObjBs TNmObjBs::GetFromStrQuV(
418   const TStrQuV& IdTitleSrcHtmlQuV,
419   const TSwSetType& SwSetType, const TStr& CustSwSetFNm,
420   const TStr& NrWordBsFNm, const TStr& WordTypeBsFNm, const TStr& MteFNm,
421   const int& MxDocs, const bool& DumpP){
422    PSIn CustSwSetSIn;
423    if (!CustSwSetFNm.Empty()&&(TFile::Exists(CustSwSetFNm))){
424      CustSwSetSIn=TFIn::New(CustSwSetFNm);}
425    PSIn NrWordBsSIn;
426    if (!NrWordBsFNm.Empty()&&(TFile::Exists(NrWordBsFNm))){
427      NrWordBsSIn=TFIn::New(NrWordBsFNm);}
428    PSIn WordTypeBsSIn;
429    if (!WordTypeBsFNm.Empty()&&(TFile::Exists(WordTypeBsFNm))){
430      WordTypeBsSIn=TFIn::New(WordTypeBsFNm);}
431    PNmObjBs NmObjBs=
432     TNmObjBs::New(SwSetType, CustSwSetSIn, NrWordBsSIn, WordTypeBsSIn, MteFNm);
433    for (int DocN=0; DocN<IdTitleSrcHtmlQuV.Len(); DocN++){
434      if ((MxDocs!=-1)&&(DocN>MxDocs)){break;}
435      TStr DocNm=IdTitleSrcHtmlQuV[DocN].Val1;
436      TStr TitleStr=IdTitleSrcHtmlQuV[DocN].Val2;
437      TStr HtmlStr=IdTitleSrcHtmlQuV[DocN].Val4;
438      if (DumpP){
439        printf("===============================================\n");
440        printf("%s\n", DocNm.CStr());
441      }
442      TStrV CandWordStrV; NmObjBs->ExtrCandWordStrV(HtmlStr, CandWordStrV, DumpP);
443      TIntV NmObjIdV; NmObjBs->FilterCandToNmObjIdV(CandWordStrV, NmObjIdV, DumpP);
444      NmObjBs->AddDoc(DocNm, "", NmObjIdV);
445    }
446    TIntV NewNmObjIdV; NmObjBs->GetMergedNmObj(NewNmObjIdV);
447    NmObjBs->PutMergedNmObj(NewNmObjIdV);
448    return NmObjBs;
449  }
450  PNmObjBs TNmObjBs::GetFromCpd(
451   const PSIn& _CpdSIn,
452   const TSwSetType& SwSetType, const PSIn& CustSwSetSIn,
453   const PSIn& NrWordBsSIn, const PSIn& WordTypeBsSIn, const TStr& MteFNm,
454   const int& MxDocs, const bool& DumpP){
455    PNmObjBs NmObjBs=
456     TNmObjBs::New(SwSetType, CustSwSetSIn, NrWordBsSIn, WordTypeBsSIn, MteFNm);
457    PSIn CpdSIn=TCpDoc::FFirstCpd(_CpdSIn); PCpDoc CpDoc; int Docs=0;
458    while (TCpDoc::FNextCpd(CpdSIn, CpDoc)){
459      if ((MxDocs!=-1)&&(Docs>MxDocs)){break;}
460      TStr DocNm=CpDoc->GetDocNm();
461      TStr DateStr=CpDoc->GetDateStr();
462      TStr HtmlStr=CpDoc->GetTxtStr();
463      Docs++; printf("%d %s\r", Docs, DocNm.CStr());
464      if (DumpP){
465        printf("===============================================\n");
466        printf("%s\n", DocNm.CStr());
467      }
468      TStrV CandWordStrV; NmObjBs->ExtrCandWordStrV(HtmlStr, CandWordStrV, DumpP);
469      TIntV NmObjIdV; NmObjBs->FilterCandToNmObjIdV(CandWordStrV, NmObjIdV, DumpP);
470      NmObjBs->AddDoc(DocNm, DateStr, NmObjIdV);
471    }
472    TIntV NewNmObjIdV; NmObjBs->GetMergedNmObj(NewNmObjIdV);
473    NmObjBs->PutMergedNmObj(NewNmObjIdV);
474    return NmObjBs;
475  }
476  PNmObjBs TNmObjBs::GetFromCpd(
477   const TStr& CpdFNm,
478   const TSwSetType& SwSetType, const TStr& CustSwSetFNm,
479   const TStr& NrWordBsFNm, const TStr& WordTypeBsFNm, const TStr& MteFNm,
480   const int& MxDocs, const bool& DumpP){
481    PSIn CpdSIn=TFIn::New(CpdFNm);
482    PSIn CustSwSetSIn;
483    if (!CustSwSetFNm.Empty()&&(TFile::Exists(CustSwSetFNm))){
484      CustSwSetSIn=TFIn::New(CustSwSetFNm);}
485    PSIn NrWordBsSIn;
486    if (!NrWordBsFNm.Empty()&&(TFile::Exists(NrWordBsFNm))){
487      NrWordBsSIn=TFIn::New(NrWordBsFNm);}
488    PSIn WordTypeBsSIn;
489    if (!WordTypeBsFNm.Empty()&&(TFile::Exists(WordTypeBsFNm))){
490      WordTypeBsSIn=TFIn::New(WordTypeBsFNm);}
491    return TNmObjBs::GetFromCpd(
492     CpdSIn, SwSetType, CustSwSetSIn, NrWordBsSIn, WordTypeBsSIn, MteFNm,
493     MxDocs, DumpP);
494  }
495  void TNmObjBs::GetMergedNmObj(TIntV& NewNmObjIdV){
496    int MnPfxLen=3; int MxSfxLen=2;
497    int NmObjs=NmObjWordStrVToDocIdVH.Len();
498    NewNmObjIdV.Gen(NmObjs); NewNmObjIdV.PutAll(-1);
499    {int SingleWords=0; int ReducedSingleWords=0;
500    TStrIntVH PfxStrToNmObjIdVH;
501    for (int NmObjId=0; NmObjId<NmObjs; NmObjId++){
502      if (NewNmObjIdV[NmObjId]!=-1){continue;}
503      const TStrV& WordStrV=NmObjWordStrVToDocIdVH.GetKey(NmObjId);
504      if (WordStrV.Len()==1){
505        TStr PfxStr=WordStrV[0].GetSubStr(0, 2);
506        PfxStrToNmObjIdVH.AddDat(PfxStr).Add(NmObjId);
507        SingleWords++;
508      }
509    }
510    int Pfxs=PfxStrToNmObjIdVH.Len();
511    for (int PfxId=0; PfxId<Pfxs; PfxId++){
512      TIntV& NmObjIdV=PfxStrToNmObjIdVH[PfxId];
513      for (int NmObjIdN=0; NmObjIdN<NmObjIdV.Len(); NmObjIdN++){
514        int NmObjId=NmObjIdV[NmObjIdN];
515        if (NewNmObjIdV[NmObjId]!=-1){continue;}
516        NewNmObjIdV[NmObjId]=NmObjId;
517        const TStr& WordStr=NmObjWordStrVToDocIdVH.GetKey(NmObjId)[0];
518        int Fq=NmObjWordStrVToDocIdVH[NmObjId].Len();
519        TIntPrV FqNmObjIdPrV(NmObjIdV.Len(), 0);
520        FqNmObjIdPrV.Add(TIntPr(Fq, NmObjId));
521        for (int SubNmObjIdN=NmObjIdN+1; SubNmObjIdN<NmObjIdV.Len(); SubNmObjIdN++){
522          int SubNmObjId=NmObjIdV[SubNmObjIdN];
523          if (NewNmObjIdV[SubNmObjId]!=-1){continue;}
524          const TStr& SubWordStr=NmObjWordStrVToDocIdVH.GetKey(SubNmObjId)[0];
525          if (IsMatchPfx(WordStr, SubWordStr, MnPfxLen, MxSfxLen)){
526            NewNmObjIdV[SubNmObjId]=NmObjId;
527            int SubFq=NmObjWordStrVToDocIdVH[SubNmObjId].Len();
528            FqNmObjIdPrV.Add(TIntPr(SubFq, SubNmObjId));
529          }
530        }
531        ReducedSingleWords++;
532        if (FqNmObjIdPrV.Len()>1){
533          FqNmObjIdPrV.Sort(false);
<span onclick='openModal()' class='match'>534          int MainNmObjId=FqNmObjIdPrV[0].Val2;
535          NewNmObjIdV[MainNmObjId]=MainNmObjId;
536          TStr MainWordStr=NmObjWordStrVToDocIdVH.GetKey(MainNmObjId)[0];
537          for (int FqNmObjIdPrN=1; FqNmObjIdPrN<FqNmObjIdPrV.Len(); FqNmObjIdPrN++){
538            int SubNmObjId=FqNmObjIdPrV[FqNmObjIdPrN].Val2;
</span>539            NewNmObjIdV[SubNmObjId]=MainNmObjId;
540          }
541        }
542      }
543    }
544    }
545    {int DoubleWords=0; int ReducedDoubleWords=0;
546    TStrIntVH PfxStrToNmObjIdVH;
547    for (int NmObjId=0; NmObjId<NmObjs; NmObjId++){
548      if (NewNmObjIdV[NmObjId]!=-1){continue;}
549      const TStrV& WordStrV=NmObjWordStrVToDocIdVH.GetKey(NmObjId);
550      if (WordStrV.Len()==2){
551        TStr PfxStr=WordStrV[0].GetSubStr(0, 2)+WordStrV[1].GetSubStr(0, 2);
552        PfxStrToNmObjIdVH.AddDat(PfxStr).Add(NmObjId);
553        DoubleWords++;
554      }
555    }
556    int Pfxs=PfxStrToNmObjIdVH.Len();
557    for (int PfxId=0; PfxId<Pfxs; PfxId++){
558      TIntV& NmObjIdV=PfxStrToNmObjIdVH[PfxId];
559      for (int NmObjIdN=0; NmObjIdN<NmObjIdV.Len(); NmObjIdN++){
560        int NmObjId=NmObjIdV[NmObjIdN];
561        if (NewNmObjIdV[NmObjId]!=-1){continue;}
562        NewNmObjIdV[NmObjId]=NmObjId;
563        const TStr& WordStr1=NmObjWordStrVToDocIdVH.GetKey(NmObjId)[0];
564        const TStr& WordStr2=NmObjWordStrVToDocIdVH.GetKey(NmObjId)[1];
565        int Fq=NmObjWordStrVToDocIdVH[NmObjId].Len();
566        TIntPrV FqNmObjIdPrV(NmObjIdV.Len(), 0);
567        FqNmObjIdPrV.Add(TIntPr(Fq, NmObjId));
568        for (int SubNmObjIdN=NmObjIdN+1; SubNmObjIdN<NmObjIdV.Len(); SubNmObjIdN++){
569          int SubNmObjId=NmObjIdV[SubNmObjIdN];
570          if (NewNmObjIdV[SubNmObjId]!=-1){continue;}
571          const TStr& SubWordStr1=NmObjWordStrVToDocIdVH.GetKey(SubNmObjId)[0];
572          const TStr& SubWordStr2=NmObjWordStrVToDocIdVH.GetKey(SubNmObjId)[1];
573          if (IsMatchPfx(WordStr1, SubWordStr1, MnPfxLen, MxSfxLen+1)&&
574           IsMatchPfx(WordStr2, SubWordStr2, MnPfxLen, MxSfxLen+1)){
575            NewNmObjIdV[SubNmObjId]=NmObjId;
576            int SubFq=NmObjWordStrVToDocIdVH[SubNmObjId].Len();
577            FqNmObjIdPrV.Add(TIntPr(SubFq, SubNmObjId));
578          }
579        }
580        ReducedDoubleWords++;
581        if (FqNmObjIdPrV.Len()>1){
582          FqNmObjIdPrV.Sort(false);
583          int MainNmObjId=FqNmObjIdPrV[0].Val2;
584          NewNmObjIdV[MainNmObjId]=MainNmObjId;
585          TStr MainWordStr1=NmObjWordStrVToDocIdVH.GetKey(MainNmObjId)[0];
586          TStr MainWordStr2=NmObjWordStrVToDocIdVH.GetKey(MainNmObjId)[1];
587          for (int FqNmObjIdPrN=1; FqNmObjIdPrN<FqNmObjIdPrV.Len(); FqNmObjIdPrN++){
588            int SubNmObjId=FqNmObjIdPrV[FqNmObjIdPrN].Val2;
589            NewNmObjIdV[SubNmObjId]=MainNmObjId;
590          }
591        }
592      }
593    }
594    }
595    {int TripleWords=0; int ReducedTripleWords=0;
596    TStrIntVH PfxStrToNmObjIdVH;
597    for (int NmObjId=0; NmObjId<NmObjs; NmObjId++){
598      if (NewNmObjIdV[NmObjId]!=-1){continue;}
599      const TStrV& WordStrV=NmObjWordStrVToDocIdVH.GetKey(NmObjId);
600      if (WordStrV.Len()==3){
601        TripleWords++;
602        TStrV DbWordStrV(2, 0);
603        DbWordStrV.Add(WordStrV[1]); DbWordStrV.Add(WordStrV[2]);
604        int DbNmObjId=NmObjWordStrVToDocIdVH.GetKeyId(DbWordStrV);
605        if (DbNmObjId!=-1){
606          ReducedTripleWords++;
607          int NewDbNmObjId=NewNmObjIdV[DbNmObjId];
608          NewNmObjIdV[NmObjId]=NewDbNmObjId;
609        }
610      }
611    }
612    }
613    {int TripleWords=0; int ReducedTripleWords=0;
614    TStrIntVH PfxStrToNmObjIdVH;
615    for (int NmObjId=0; NmObjId<NmObjs; NmObjId++){
616      if (NewNmObjIdV[NmObjId]!=-1){continue;}
617      const TStrV& WordStrV=NmObjWordStrVToDocIdVH.GetKey(NmObjId);
618      if (WordStrV.Len()==3){
619        TStr PfxStr=WordStrV[0].GetSubStr(0, 2)+WordStrV[1].GetSubStr(0, 2)+WordStrV[2].GetSubStr(0, 2);
620        PfxStrToNmObjIdVH.AddDat(PfxStr).Add(NmObjId);
621        TripleWords++;
622      }
623    }
624    int Pfxs=PfxStrToNmObjIdVH.Len();
625    for (int PfxId=0; PfxId<Pfxs; PfxId++){
626      TIntV& NmObjIdV=PfxStrToNmObjIdVH[PfxId];
627      for (int NmObjIdN=0; NmObjIdN<NmObjIdV.Len(); NmObjIdN++){
628        int NmObjId=NmObjIdV[NmObjIdN];
629        if (NewNmObjIdV[NmObjId]!=-1){continue;}
630        NewNmObjIdV[NmObjId]=NmObjId;
631        const TStr& WordStr1=NmObjWordStrVToDocIdVH.GetKey(NmObjId)[0];
632        const TStr& WordStr2=NmObjWordStrVToDocIdVH.GetKey(NmObjId)[1];
633        const TStr& WordStr3=NmObjWordStrVToDocIdVH.GetKey(NmObjId)[2];
634        int Fq=NmObjWordStrVToDocIdVH[NmObjId].Len();
635        TIntPrV FqNmObjIdPrV(NmObjIdV.Len(), 0);
636        FqNmObjIdPrV.Add(TIntPr(Fq, NmObjId));
637        for (int SubNmObjIdN=NmObjIdN+1; SubNmObjIdN<NmObjIdV.Len(); SubNmObjIdN++){
638          int SubNmObjId=NmObjIdV[SubNmObjIdN];
639          if (NewNmObjIdV[SubNmObjId]!=-1){continue;}
640          const TStr& SubWordStr1=NmObjWordStrVToDocIdVH.GetKey(SubNmObjId)[0];
641          const TStr& SubWordStr2=NmObjWordStrVToDocIdVH.GetKey(SubNmObjId)[1];
642          const TStr& SubWordStr3=NmObjWordStrVToDocIdVH.GetKey(SubNmObjId)[2];
643          if (IsMatchPfx(WordStr1, SubWordStr1, MnPfxLen, MxSfxLen+1)&&
644           IsMatchPfx(WordStr2, SubWordStr2, MnPfxLen, MxSfxLen+1)&&
645           IsMatchPfx(WordStr3, SubWordStr3, MnPfxLen, MxSfxLen+1)){
646            NewNmObjIdV[SubNmObjId]=NmObjId;
647            int SubFq=NmObjWordStrVToDocIdVH[SubNmObjId].Len();
648            FqNmObjIdPrV.Add(TIntPr(SubFq, SubNmObjId));
649          }
650        }
651        ReducedTripleWords++;
652        if (FqNmObjIdPrV.Len()>1){
653          FqNmObjIdPrV.Sort(false);
654          int MainNmObjId=FqNmObjIdPrV[0].Val2;
655          NewNmObjIdV[MainNmObjId]=MainNmObjId;
656          TStr MainWordStr1=NmObjWordStrVToDocIdVH.GetKey(MainNmObjId)[0];
657          TStr MainWordStr2=NmObjWordStrVToDocIdVH.GetKey(MainNmObjId)[1];
658          TStr MainWordStr3=NmObjWordStrVToDocIdVH.GetKey(MainNmObjId)[2];
659          for (int FqNmObjIdPrN=1; FqNmObjIdPrN<FqNmObjIdPrV.Len(); FqNmObjIdPrN++){
660            int SubNmObjId=FqNmObjIdPrV[FqNmObjIdPrN].Val2;
661            NewNmObjIdV[SubNmObjId]=MainNmObjId;
662          }
663        }
664      }
665    }
666    }
667  }
668  void TNmObjBs::PutMergedNmObj(const TIntV& NewNmObjIdV){
669    TStrVIntVH NewNmObjWordStrVToDocIdVH;
670    for (int NmObjId=0; NmObjId<NewNmObjIdV.Len(); NmObjId++){
671      if (NewNmObjIdV[NmObjId]!=NmObjId){continue;}
672      const TStrV& WordStrV=NmObjWordStrVToDocIdVH.GetKey(NmObjId);
673      NewNmObjWordStrVToDocIdVH.AddDat(WordStrV);
674    }
675    {for (int NmObjId=0; NmObjId<NewNmObjIdV.Len(); NmObjId++){
676      if (NewNmObjIdV[NmObjId]==NmObjId){continue;}
677      const TStrV& WordStrV=NmObjWordStrVToDocIdVH.GetKey(NmObjId);
678      int NrNmObjId=NewNmObjIdV[NmObjId];
679      if (NrNmObjId!=-1){
680        const TStrV& NrWordStrV=NmObjWordStrVToDocIdVH.GetKey(NrNmObjId);
681        NmObjWordStrVToNrH.AddDat(WordStrV, NrWordStrV);
682      }
683    }}
684    int Docs=GetDocs();
685    for (int DocId=0; DocId<Docs; DocId++){
686      TIntPrV& NmObjIdFqPrV=GetDoc_NmObjIdFqPrV(DocId);
687      TIntIntH NewNmObjIdToFqH(NmObjIdFqPrV.Len());
688      for (int NmObjN=0; NmObjN<NmObjIdFqPrV.Len(); NmObjN++){
689        int NmObjId=NmObjIdFqPrV[NmObjN].Val1;
690        int Fq=NmObjIdFqPrV[NmObjN].Val2;
691        int NrNmObjId=NewNmObjIdV[NmObjId];
692        if (NrNmObjId!=-1){
693          const TStrV& NrWordStrV=NmObjWordStrVToDocIdVH.GetKey(NrNmObjId);
694          int NewNmObjId=NewNmObjWordStrVToDocIdVH.GetKeyId(NrWordStrV);
695          NewNmObjIdToFqH.AddDat(NewNmObjId)+=Fq;
696        }
697      }
698      NmObjIdFqPrV.Gen(NewNmObjIdToFqH.Len(), 0);
699      for (int NmObjP=0; NmObjP<NewNmObjIdToFqH.Len(); NmObjP++){
700        int NewNmObjId=NewNmObjIdToFqH.GetKey(NmObjP);
701        int Fq=NewNmObjIdToFqH[NmObjP];
702        NmObjIdFqPrV.Add(TIntPr(NewNmObjId, Fq));
703        NewNmObjWordStrVToDocIdVH[NewNmObjId].Add(DocId);
704      }
705      NmObjIdFqPrV.Sort();
706    }
707    NmObjWordStrVToDocIdVH=NewNmObjWordStrVToDocIdVH;
708  }
709  void TNmObjBs::GetNmObjStrFqPrV(TStrIntPrV& NmObjStrFqPrV, const int& MnFq) const {
710    int NmObjs=GetNmObjs();
711    NmObjStrFqPrV.Gen(NmObjs, 0);
712    for (int NmObjId=0; NmObjId<NmObjs; NmObjId++){
713      TStrIntPr NmObjStrFqPr;
714      NmObjStrFqPr.Val1=GetNmObjStr(NmObjId);
715      NmObjStrFqPr.Val2=GetNmObjDocs(NmObjId);
716      if (NmObjStrFqPr.Val2>=MnFq){
717        NmObjStrFqPrV.Add(NmObjStrFqPr);}
718    }
719  }
720  void TNmObjBs::GetNmObjFqStrPrV(TIntStrPrV& NmObjFqStrPrV, const int& MnFq) const {
721    int NmObjs=GetNmObjs();
722    NmObjFqStrPrV.Gen(NmObjs, 0);
723    for (int NmObjId=0; NmObjId<NmObjs; NmObjId++){
724      TIntStrPr NmObjFqStrPr;
725      NmObjFqStrPr.Val1=GetNmObjDocs(NmObjId);
726      NmObjFqStrPr.Val2=GetNmObjStr(NmObjId);
727      if (NmObjFqStrPr.Val1>=MnFq){
728        NmObjFqStrPrV.Add(NmObjFqStrPr);}
729    }
730  }
731  void TNmObjBs::GetNmObjDIdV(
732   const PBowDocBs& BowDocBs, TIntV& BowDIdV, 
733   const TStr& NmObjStr1, const TStr& NmObjStr2) const {
734    int NmObjId1=GetNmObjId(NmObjStr1);
735    TIntV NmObjDocIdV1; GetNmObjDocIdV(NmObjId1, NmObjDocIdV1);
736    NmObjDocIdV1.Sort();
737    TIntV NmObjDocIdV2;
738    if (!NmObjStr2.Empty()){
739      int NmObjId2=GetNmObjId(NmObjStr2);
740      GetNmObjDocIdV(NmObjId2, NmObjDocIdV2);
741      NmObjDocIdV2.Sort();
742    }
743    TIntV NmObjDocIdV;
744    if (NmObjDocIdV2.Empty()){
745      NmObjDocIdV=NmObjDocIdV1;
746    } else {
747      NmObjDocIdV1.Intrs(NmObjDocIdV2, NmObjDocIdV);
748    }
749    BowDIdV.Gen(NmObjDocIdV.Len(), 0);
750    for (int NmObjDocIdN=0; NmObjDocIdN<NmObjDocIdV.Len(); NmObjDocIdN++){
751      TStr DocNm=GetDocNm(NmObjDocIdV[NmObjDocIdN]);
752      int DId=BowDocBs->GetDId(DocNm);
753      if (DId!=-1){
754        BowDIdV.Add(DId);
755      } 
756    }
757  }
758  PBowSpV TNmObjBs::GetNmObjConcept(
759   const PBowDocBs& BowDocBs, const PBowDocWgtBs& BowDocWgtBs,
760   const TStr& NmObjStr1, const TStr& NmObjStr2) const {
761    TIntV BowDIdV; GetNmObjDIdV(BowDocBs, BowDIdV, NmObjStr1, NmObjStr2);
762    PBowSpV ConceptSpV=TBowClust::GetConceptSpV(BowDocWgtBs, NULL, BowDIdV);
763    return ConceptSpV;
764  }
765  void TNmObjBs::GetFqNmObjIdPrV(
766   const TStr& TargetNmObjStr, TIntPrV& FqNmObjIdPrV) const {
767    int TargetNmObjId=GetNmObjId(TargetNmObjStr);
768    TIntIntH NmObjIdToFqH;
769    int NmObjDocs=GetNmObjDocs(TargetNmObjId);
770    for (int NmObjDocIdN=0; NmObjDocIdN<NmObjDocs; NmObjDocIdN++){
771      int DocId=GetNmObjDocId(TargetNmObjId, NmObjDocIdN);
772      int DocNmObjs=GetDocNmObjs(DocId);
773      for (int DocNmObjN=0; DocNmObjN<DocNmObjs; DocNmObjN++){
774        int NmObjId; int TermFq;
775        GetDocNmObjId(DocId, DocNmObjN, NmObjId, TermFq);
776        NmObjIdToFqH.AddDat(NmObjId)++;
777      }
778    }
779    FqNmObjIdPrV.Clr(); NmObjIdToFqH.GetDatKeyPrV(FqNmObjIdPrV);
780    FqNmObjIdPrV.Sort(false);
781  }
782  int TNmObjBs::AddDoc(const TStr& DocNm, const TStr& DateStr, const TIntV& NmObjIdV){
783    TIntIntH NmObjIdToFqH(NmObjIdV.Len());
784    for (int NmObjN=0; NmObjN<NmObjIdV.Len(); NmObjN++){
785      int NmObjId=NmObjIdV[NmObjN];
786      NmObjIdToFqH.AddDat(NmObjId)++;
787    }
788    IAssert(!IsDoc(DocNm));
789    int DocId=DocNmToNmObjDocH.AddKey(DocNm);
790    DocNmToNmObjDocH[DocId]=TNmObjDoc::New();
791    DocNmToNmObjDocH[DocId]->DateStr=DateStr;
792    TIntPrV& NmObjIdFqPrV=GetDoc_NmObjIdFqPrV(DocId);
793    for (int NmObjP=0; NmObjP<NmObjIdToFqH.Len(); NmObjP++){
794      int NmObjId=NmObjIdToFqH.GetKey(NmObjP);
795      int Fq=NmObjIdToFqH[NmObjP];
796      NmObjIdFqPrV.Add(TIntPr(NmObjId, Fq));
797      NmObjWordStrVToDocIdVH[NmObjId].AddSorted(DocId);
798    }
799    NmObjIdFqPrV.Sort();
800    return DocId;
801  }
802  TStr TNmObjBs::GetDoc_NmObjStrVStr(const int& DocId, const char& SepCh) const {
803    TChA NmObjStrVChA;
804    TIntPrV& NmObjIdFqPrV=GetDoc_NmObjIdFqPrV(DocId);
805    for (int NmObjIdN=0; NmObjIdN<NmObjIdFqPrV.Len(); NmObjIdN++){
806      if (NmObjIdN>0){NmObjStrVChA+=SepCh;}
807      int NmObjId=NmObjIdFqPrV[NmObjIdN].Val1;
808      TStr NmObjStr=GetNmObjStr(NmObjId);
809      NmObjStrVChA+=NmObjStr;
810    }
811    return NmObjStrVChA;
812  }
813  PBowDocBs TNmObjBs::GetBowDocBs(const int& MnNmObjFq) const {
814    printf("Generating Bag-Of-Words...\n");
815    PBowDocBs BowDocBs=TBowDocBs::New();
816    for (int DocId=0; DocId<GetDocs(); DocId++){
817      if (DocId%100==0){printf("%d\r", DocId);}
818      TStr DocNm=GetDocNm(DocId);
819      TStr DateStr=GetDocDateStr(DocId);
820      TStrV WordStrV;
821      int DocNmObjs=GetDocNmObjs(DocId);
822      for (int DocNmObjN=0; DocNmObjN<DocNmObjs; DocNmObjN++){
823        int NmObjId; int TermFq; GetDocNmObjId(DocId, DocNmObjN, NmObjId, TermFq);
824        if ((MnNmObjFq==-1)||(GetNmObjDocs(NmObjId)>=MnNmObjFq)){
825          TStr NmObjStr=GetNmObjStr(NmObjId);
826          for (int TermOccN=0; TermOccN<TermFq; TermOccN++){
827            WordStrV.Add(NmObjStr);
828          }
829        }
830      }
831      if (!WordStrV.Empty()){
832        int DId=BowDocBs->AddDoc(DocNm, TStrV(), WordStrV);
833        BowDocBs->PutDateStr(DId, DateStr);
834     }
835    }
836    BowDocBs->AssertOk();
837    printf("\nDone.\n");
838    return BowDocBs;
839  }
840  PBowDocBs TNmObjBs::GetNmBowDocBs(
841   const PBowDocBs& BowDocBs, const PBowDocWgtBs& BowDocWgtBs, const int& MnNmObjFq) const {
842    int NmObjs=GetNmObjs();
843    for (int NmObjId=0; NmObjId<NmObjs; NmObjId++){
844      printf("%d/%d\r", (1+NmObjId), NmObjs);
845      TStr NmObjStr=GetNmObjStr(NmObjId);
846      PBowSpV BowSpV=GetNmObjConcept(BowDocBs, BowDocWgtBs, NmObjStr);
847    }
848    printf("\n");
849    return NULL;
850  }
851  PBowDocBs TNmObjBs::GetRelBowDocBs(const PBowDocBs& BowDocBs, const PBowDocWgtBs& BowDocWgtBs, const int& MnNmObjFq) const {
852    return NULL;
853  }
854  void TNmObjBs::SaveTxtNmObj(const TStr& FqFNm, const TStr& SwFNm,
855   const TStr& AbcFNm, const TStr& DocFNm) const {
856    TIntStrVPrV FqWordStrVPrV(NmObjWordStrVToDocIdVH.Len(), 0);
857    TStrVIntPrV WordStrVFqPrV(NmObjWordStrVToDocIdVH.Len(), 0);
858    for (int NmObjId=0; NmObjId<NmObjWordStrVToDocIdVH.Len(); NmObjId++){
859      int Fq=NmObjWordStrVToDocIdVH[NmObjId].Len();
860      const TStrV& WordStrV=NmObjWordStrVToDocIdVH.GetKey(NmObjId);
861      FqWordStrVPrV.Add(TIntStrVPr(Fq, WordStrV));
862      WordStrVFqPrV.Add(TStrVIntPr(WordStrV, Fq));
863    }
864    FqWordStrVPrV.Sort(false);
865    WordStrVFqPrV.Sort();
866    if (!FqFNm.Empty()){
867      printf("Saving by frequency to '%s' ...", FqFNm.CStr());
868      TFOut SOut(FqFNm); FILE* fOut=SOut.GetFileId();
869      for (int PrN=0; PrN<FqWordStrVPrV.Len(); PrN++){
870        int Fq=FqWordStrVPrV[PrN].Val1;
871        TStrV& WordStrV=FqWordStrVPrV[PrN].Val2;
872        TStr WordStrVStr=GetWordStrVStr(WordStrV);
873        fprintf(fOut, "%d - %s\n", Fq, WordStrVStr.CStr());
874      }
875      printf(" Done.\n");
876    }
877    if (!SwFNm.Empty()){
878      printf("Saving by frequency for stop-words proposal to '%s' ...", SwFNm.CStr());
879      TFOut SOut(SwFNm); FILE* fOut=SOut.GetFileId();
880      for (int PrN=0; PrN<FqWordStrVPrV.Len(); PrN++){
881        TStrV& WordStrV=FqWordStrVPrV[PrN].Val2;
882        TStr WordStrVStr=GetWordStrVStr(WordStrV, ' ');
883        fprintf(fOut, "%s\n", WordStrVStr.CStr());
884      }
885      printf(" Done.\n");
886    }
887    if (!AbcFNm.Empty()){
888      printf("Saving by alphabet to '%s' ...", AbcFNm.CStr());
889      TFOut SOut(AbcFNm); FILE* fOut=SOut.GetFileId();
890      for (int PrN=0; PrN<WordStrVFqPrV.Len(); PrN++){
891        TStrV& WordStrV=WordStrVFqPrV[PrN].Val1;
892        int Fq=WordStrVFqPrV[PrN].Val2;
893        TStr WordStrVStr=GetWordStrVStr(WordStrV);
894        fprintf(fOut, "%s - %d [", WordStrVStr.CStr(), Fq);
895        int NmObjId=GetNmObjId(WordStrV);
896        TIntV DocIdV;
897        GetNmObjDocIdV(NmObjId, DocIdV);
898        for (int DocIdN=0; DocIdN<DocIdV.Len(); DocIdN++){
899          TStr DocNm=GetDocNm(DocIdV[DocIdN]);
900          fprintf(fOut, "'%s' ", DocNm.CStr());
901        }
902        fprintf(fOut, "]\n");
903      }
904      printf(" Done.\n");
905    }
906    if (!DocFNm.Empty()){
907      printf("Saving by documents to '%s' ...", DocFNm.CStr());
908      TFOut SOut(DocFNm); FILE* fOut=SOut.GetFileId();
909      for (int DocId=0; DocId<GetDocs(); DocId++){
910        TStr DocNm=GetDocNm(DocId);
911        fprintf(fOut, "'%s'(%d):", DocNm.CStr(), DocId);
912        TStr DateStr=GetDocDateStr(DocId);
913        if (!DateStr.Empty()){
914          fprintf(fOut, "[%s]", DateStr.CStr());}
915        int DocNmObjs=GetDocNmObjs(DocId);
916        for (int DocNmObjN=0; DocNmObjN<DocNmObjs; DocNmObjN++){
917          int NmObjId; int TermFq; GetDocNmObjId(DocId, DocNmObjN, NmObjId, TermFq);
918          TStr NmObjStr=GetNmObjStr(NmObjId);
919          fprintf(fOut, " [%s:%d]", NmObjStr.CStr(), TermFq);
920        }
921        fprintf(fOut, "\n");
922      }
923      printf(" Done.\n");
924    }
925  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-osdetect.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-nmobj.cpp</div>
                </div>
                <div class="column column_space"><pre><code>236    C_BLOB *blob = bbox->cblob();
237    TBLOB *tblob = TBLOB::PolygonalCopy(tess->poly_allow_detailed_fx, blob);
238    TBOX box = tblob->bounding_box();
239    FCOORD current_rotation(1.0f, 0.0f);
240    FCOORD rotation90(0.0f, 1.0f);
241    BLOB_CHOICE_LIST ratings[4];
242    for (int i = 0; i < 4; ++i) {
243      float scaling = static_cast<float>(kBlnXHeight) / box.height();
</pre></code></div>
                <div class="column column_space"><pre><code>534          int MainNmObjId=FqNmObjIdPrV[0].Val2;
535          NewNmObjIdV[MainNmObjId]=MainNmObjId;
536          TStr MainWordStr=NmObjWordStrVToDocIdVH.GetKey(MainNmObjId)[0];
537          for (int FqNmObjIdPrN=1; FqNmObjIdPrN<FqNmObjIdPrV.Len(); FqNmObjIdPrN++){
538            int SubNmObjId=FqNmObjIdPrV[FqNmObjIdPrN].Val2;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    