
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 23, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>subconverter-MDEwOlJlcG9zaXRvcnkyMTg2ODY3NjM=-flat-settings.cpp</h3>
            <pre><code>1  #include &lt;string&gt;
2  #include &lt;mutex&gt;
3  #include &lt;toml.hpp&gt;
4  #include &quot;../config/binding.h&quot;
5  #include &quot;../handler/webget.h&quot;
6  #include &quot;../script/cron.h&quot;
7  #include &quot;../server/webserver.h&quot;
8  #include &quot;../utils/logger.h&quot;
9  #include &quot;../utils/network.h&quot;
10  #include &quot;interfaces.h&quot;
11  #include &quot;multithread.h&quot;
12  #include &quot;settings.h&quot;
13  std::mutex gMutexConfigure;
14  Settings global;
15  extern WebServer webServer;
16  const std::map&lt;std::string, ruleset_type&gt; RulesetTypes = {{&quot;clash-domain:&quot;, RULESET_CLASH_DOMAIN}, {&quot;clash-ipcidr:&quot;, RULESET_CLASH_IPCIDR}, {&quot;clash-classic:&quot;, RULESET_CLASH_CLASSICAL}, \
17              {&quot;quanx:&quot;, RULESET_QUANX}, {&quot;surge:&quot;, RULESET_SURGE}};
18  int importItems(string_array &amp;target, bool scope_limit)
19  {
20      string_array result;
21      std::stringstream ss;
22      std::string path, content, strLine;
23      unsigned int itemCount = 0;
24      for(std::string &amp;x : target)
25      {
26          if(x.find(&quot;!!import:&quot;) == x.npos)
27          {
28              result.emplace_back(x);
29              continue;
30          }
31          path = x.substr(x.find(&quot;:&quot;) + 1);
32          writeLog(0, &quot;Trying to import items from &quot; + path);
33          std::string proxy = parseProxy(global.proxyConfig);
34          if(fileExist(path))
35              content = fileGet(path, scope_limit);
36          else if(isLink(path))
37              content = webGet(path, proxy, global.cacheConfig);
38          else
39              writeLog(0, &quot;File not found or not a valid URL: &quot; + path, LOG_LEVEL_ERROR);
40          if(!content.size())
41              return -1;
42          ss &lt;&lt; content;
43          char delimiter = getLineBreak(content);
44          std::string::size_type lineSize;
45          while(getline(ss, strLine, delimiter))
46          {
47              lineSize = strLine.size();
48              if(lineSize &amp;&amp; strLine[lineSize - 1] == &#x27;\r&#x27;) 
49                  strLine.erase(--lineSize);
50              if(!lineSize || strLine[0] == &#x27;;&#x27; || strLine[0] == &#x27;#&#x27; || (lineSize &gt;= 2 &amp;&amp; strLine[0] == &#x27;/&#x27; &amp;&amp; strLine[1] == &#x27;/&#x27;)) 
51                  continue;
52              result.emplace_back(std::move(strLine));
53              itemCount++;
54          }
55          ss.clear();
56      }
<span onclick='openModal()' class='match'>57      target.swap(result);
58      writeLog(0, &quot;Imported &quot; + std::to_string(itemCount) + &quot; item(s).&quot;);
59      return 0;
</span>60  }
61  toml::value parseToml(const std::string &amp;content, const std::string &amp;fname)
62  {
63      std::istringstream is(content);
64      return toml::parse(is, fname);
65  }
66  void importItems(std::vector&lt;toml::value&gt; &amp;root, const std::string &amp;import_key, bool scope_limit = true)
67  {
68      std::string content;
69      std::vector&lt;toml::value&gt; newRoot;
70      auto iter = root.begin();
71      size_t count = 0;
72      std::string proxy = parseProxy(global.proxyConfig);
73      while(iter != root.end())
74      {
75          auto&amp; table = iter-&gt;as_table();
76          if(table.find(&quot;import&quot;) == table.end())
77              newRoot.emplace_back(std::move(*iter));
78          else
79          {
80              const std::string &amp;path = toml::get&lt;std::string&gt;(table.at(&quot;import&quot;));
81              writeLog(0, &quot;Trying to import items from &quot; + path);
82              if(fileExist(path))
83                  content = fileGet(path, scope_limit);
84              else if(isLink(path))
85                  content = webGet(path, proxy, global.cacheConfig);
86              else
87                  writeLog(0, &quot;File not found or not a valid URL: &quot; + path, LOG_LEVEL_ERROR);
88              if(content.size())
89              {
90                  auto items = parseToml(content, path);
91                  auto list = toml::find&lt;std::vector&lt;toml::value&gt;&gt;(items, import_key);
92                  count += list.size();
93                  std::move(list.begin(), list.end(), std::back_inserter(newRoot));
94              }
95          }
96          iter++;
97      }
98      root.swap(newRoot);
99      writeLog(0, &quot;Imported &quot; + std::to_string(count) + &quot; item(s).&quot;);
100      return;
101  }
102  void readRegexMatch(YAML::Node node, const std::string &amp;delimiter, string_array &amp;dest, bool scope_limit = true)
103  {
104      YAML::Node object;
105      std::string script, url, match, rep, strLine;
106      for(unsigned i = 0; i &lt; node.size(); i++)
107      {
108          object = node[i];
109          object[&quot;script&quot;] &gt;&gt;= script;
110          if(script.size())
111          {
112              dest.emplace_back(&quot;!!script:&quot; + script);
113              continue;
114          }
115          object[&quot;import&quot;] &gt;&gt;= url;
116          if(url.size())
117          {
118              dest.emplace_back(&quot;!!import:&quot; + url);
119              continue;
120          }
121          object[&quot;match&quot;] &gt;&gt;= match;
122          object[&quot;replace&quot;] &gt;&gt;= rep;
123          if(match.size() &amp;&amp; rep.size())
124              strLine = match + delimiter + rep;
125          else
126              continue;
127          dest.emplace_back(std::move(strLine));
128      }
129      importItems(dest, scope_limit);
130  }
131  void readEmoji(YAML::Node node, string_array &amp;dest, bool scope_limit = true)
132  {
133      YAML::Node object;
134      std::string script, url, match, rep, strLine;
135      for(unsigned i = 0; i &lt; node.size(); i++)
136      {
137          object = node[i];
138          object[&quot;script&quot;] &gt;&gt;= script;
139          if(script.size())
140          {
141              dest.emplace_back(&quot;!!script:&quot; + script);
142              continue;
143          }
144          object[&quot;import&quot;] &gt;&gt;= url;
145          if(url.size())
146          {
147              url = &quot;!!import:&quot; + url;
148              dest.emplace_back(url);
149              continue;
150          }
151          object[&quot;match&quot;] &gt;&gt;= match;
152          object[&quot;emoji&quot;] &gt;&gt;= rep;
153          if(match.size() &amp;&amp; rep.size())
154              strLine = match + &quot;,&quot; + rep;
155          else
156              continue;
157          dest.emplace_back(std::move(strLine));
158      }
159      importItems(dest, scope_limit);
160  }
161  void readGroup(YAML::Node node, string_array &amp;dest, bool scope_limit = true)
162  {
163      std::string strLine, name, type;
164      string_array tempArray;
165      YAML::Node object;
166      unsigned int i, j;
167      for(i = 0; i &lt; node.size(); i++)
168      {
169          eraseElements(tempArray);
170          object = node[i];
171          object[&quot;import&quot;] &gt;&gt;= name;
172          if(name.size())
173          {
174              dest.emplace_back(&quot;!!import:&quot; + name);
175              continue;
176          }
177          std::string url = &quot;http:&amp;bsol;&amp;bsol;www.gstatic.com/generate_204&quot;, interval = &quot;300&quot;, tolerance, timeout;
178          object[&quot;name&quot;] &gt;&gt;= name;
179          object[&quot;type&quot;] &gt;&gt;= type;
180          tempArray.emplace_back(name);
181          tempArray.emplace_back(type);
182          object[&quot;url&quot;] &gt;&gt;= url;
183          object[&quot;interval&quot;] &gt;&gt;= interval;
184          object[&quot;tolerance&quot;] &gt;&gt;= tolerance;
185          object[&quot;timeout&quot;] &gt;&gt;= timeout;
186          for(j = 0; j &lt; object[&quot;rule&quot;].size(); j++)
187              tempArray.emplace_back(safe_as&lt;std::string&gt;(object[&quot;rule&quot;][j]));
188          switch(hash_(type))
189          {
190          case &quot;select&quot;_hash:
191              if(tempArray.size() &lt; 3)
192                  continue;
193              break;
194          case &quot;ssid&quot;_hash:
195              if(tempArray.size() &lt; 4)
196                  continue;
197              break;
198          default:
199              if(tempArray.size() &lt; 3)
200                  continue;
201              tempArray.emplace_back(url);
202              tempArray.emplace_back(interval + &quot;,&quot; + timeout + &quot;,&quot; + tolerance);
203          }
204          strLine = std::accumulate(std::next(tempArray.begin()), tempArray.end(), tempArray[0], [](std::string a, std::string b) -&gt; std::string
205          {
206              return std::move(a) + &quot;`&quot; + std::move(b);
207          });
208          dest.emplace_back(std::move(strLine));
209      }
210      importItems(dest, scope_limit);
211  }
212  void readRuleset(YAML::Node node, string_array &amp;dest, bool scope_limit = true)
213  {
214      std::string strLine, name, url, group, interval;
215      YAML::Node object;
216      for(unsigned int i = 0; i &lt; node.size(); i++)
217      {
218          object = node[i];
219          object[&quot;import&quot;] &gt;&gt;= name;
220          if(name.size())
221          {
222              dest.emplace_back(&quot;!!import:&quot; + name);
223              continue;
224          }
225          object[&quot;ruleset&quot;] &gt;&gt;= url;
226          object[&quot;group&quot;] &gt;&gt;= group;
227          object[&quot;rule&quot;] &gt;&gt;= name;
228          object[&quot;interval&quot;] &gt;&gt;= interval;
229          if(url.size())
230          {
231              strLine = group + &quot;,&quot; + url;
232              if(interval.size())
233                  strLine += &quot;,&quot; + interval;
234          }
235          else if(name.size())
236              strLine = group + &quot;,[]&quot; + name;
237          else
238              continue;
239          dest.emplace_back(std::move(strLine));
240      }
241      importItems(dest, scope_limit);
242  }
243  void refreshRulesets(RulesetConfigs &amp;ruleset_list, std::vector&lt;RulesetContent&gt; &amp;ruleset_content_array)
244  {
245      eraseElements(ruleset_content_array);
246      std::string rule_group, rule_url, rule_url_typed, interval;
247      RulesetContent rc;
248      std::string proxy = parseProxy(global.proxyRuleset);
249      for(RulesetConfig &amp;x : ruleset_list)
250      {
251          rule_group = x.Group;
252          rule_url = x.Url;
253          std::string::size_type pos = x.Url.find(&quot;[]&quot;);
254          if(pos != std::string::npos)
255          {
256              writeLog(0, &quot;Adding rule &#x27;&quot; + rule_url.substr(pos + 2) + &quot;,&quot; + rule_group + &quot;&#x27;.&quot;, LOG_LEVEL_INFO);
257              rc = {rule_group, &quot;&quot;, &quot;&quot;, RULESET_SURGE, std::async(std::launch::async, [=](){return rule_url.substr(pos);}), 0};
258          }
259          else
260          {
261              ruleset_type type = RULESET_SURGE;
262              rule_url_typed = rule_url;
263              auto iter = std::find_if(RulesetTypes.begin(), RulesetTypes.end(), [rule_url](auto y){ return startsWith(rule_url, y.first); });
264              if(iter != RulesetTypes.end())
265              {
266                  rule_url.erase(0, iter-&gt;first.size());
267                  type = iter-&gt;second;
268              }
269              writeLog(0, &quot;Updating ruleset url &#x27;&quot; + rule_url + &quot;&#x27; with group &#x27;&quot; + rule_group + &quot;&#x27;.&quot;, LOG_LEVEL_INFO);
270              rc = {rule_group, rule_url, rule_url_typed, type, fetchFileAsync(rule_url, proxy, global.cacheRuleset, true, global.asyncFetchRuleset), x.Interval};
271          }
272          ruleset_content_array.emplace_back(std::move(rc));
273      }
274      ruleset_content_array.shrink_to_fit();
275  }
276  void readYAMLConf(YAML::Node &amp;node)
277  {
278      YAML::Node section = node[&quot;common&quot;];
279      std::string strLine;
280      string_array tempArray;
281      section[&quot;api_mode&quot;] &gt;&gt; global.APIMode;
282      section[&quot;api_access_token&quot;] &gt;&gt; global.accessToken;
283      if(section[&quot;default_url&quot;].IsSequence())
284      {
285          section[&quot;default_url&quot;] &gt;&gt; tempArray;
286          if(tempArray.size())
287          {
288              strLine = std::accumulate(std::next(tempArray.begin()), tempArray.end(), tempArray[0], [](std::string a, std::string b)
289              {
290                  return std::move(a) + &quot;|&quot; + std::move(b);
291              });
292              global.defaultUrls = strLine;
293              eraseElements(tempArray);
294          }
295      }
296      global.enableInsert = safe_as&lt;std::string&gt;(section[&quot;enable_insert&quot;]);
297      if(section[&quot;insert_url&quot;].IsSequence())
298      {
299          section[&quot;insert_url&quot;] &gt;&gt; tempArray;
300          if(tempArray.size())
301          {
302              strLine = std::accumulate(std::next(tempArray.begin()), tempArray.end(), tempArray[0], [](std::string a, std::string b)
303              {
304                  return std::move(a) + &quot;|&quot; + std::move(b);
305              });
306              global.insertUrls = strLine;
307              eraseElements(tempArray);
308          }
309      }
310      section[&quot;prepend_insert_url&quot;] &gt;&gt; global.prependInsert;
311      if(section[&quot;exclude_remarks&quot;].IsSequence())
312          section[&quot;exclude_remarks&quot;] &gt;&gt; global.excludeRemarks;
313      if(section[&quot;include_remarks&quot;].IsSequence())
314          section[&quot;include_remarks&quot;] &gt;&gt; global.includeRemarks;
315      global.filterScript = safe_as&lt;bool&gt;(section[&quot;enable_filter&quot;]) ? safe_as&lt;std::string&gt;(section[&quot;filter_script&quot;]) : &quot;&quot;;
316      section[&quot;base_path&quot;] &gt;&gt; global.basePath;
317      section[&quot;clash_rule_base&quot;] &gt;&gt; global.clashBase;
318      section[&quot;surge_rule_base&quot;] &gt;&gt; global.surgeBase;
319      section[&quot;surfboard_rule_base&quot;] &gt;&gt; global.surfboardBase;
320      section[&quot;mellow_rule_base&quot;] &gt;&gt; global.mellowBase;
321      section[&quot;quan_rule_base&quot;] &gt;&gt; global.quanBase;
322      section[&quot;quanx_rule_base&quot;] &gt;&gt; global.quanXBase;
323      section[&quot;loon_rule_base&quot;] &gt;&gt; global.loonBase;
324      section[&quot;sssub_rule_base&quot;] &gt;&gt; global.SSSubBase;
325      section[&quot;default_external_config&quot;] &gt;&gt; global.defaultExtConfig;
326      section[&quot;append_proxy_type&quot;] &gt;&gt; global.appendType;
327      section[&quot;proxy_config&quot;] &gt;&gt; global.proxyConfig;
328      section[&quot;proxy_ruleset&quot;] &gt;&gt; global.proxyRuleset;
329      section[&quot;proxy_subscription&quot;] &gt;&gt; global.proxySubscription;
330      if(node[&quot;userinfo&quot;].IsDefined())
331      {
332          section = node[&quot;userinfo&quot;];
333          if(section[&quot;stream_rule&quot;].IsSequence())
334          {
335              readRegexMatch(section[&quot;stream_rule&quot;], &quot;|&quot;, tempArray, false);
336              auto configs = INIBinding::from&lt;RegexMatchConfig&gt;::from_ini(tempArray, &quot;|&quot;);
337              safe_set_streams(configs);
338              eraseElements(tempArray);
339          }
340          if(section[&quot;time_rule&quot;].IsSequence())
341          {
342              readRegexMatch(section[&quot;time_rule&quot;], &quot;|&quot;, tempArray, false);
343              auto configs = INIBinding::from&lt;RegexMatchConfig&gt;::from_ini(tempArray, &quot;|&quot;);
344              safe_set_times(configs);
345              eraseElements(tempArray);
346          }
347      }
348      if(node[&quot;node_pref&quot;].IsDefined())
349      {
350          section = node[&quot;node_pref&quot;];
351          global.UDPFlag.set(safe_as&lt;std::string&gt;(section[&quot;udp_flag&quot;]));
352          global.TFOFlag.set(safe_as&lt;std::string&gt;(section[&quot;tcp_fast_open_flag&quot;]));
353          global.skipCertVerify.set(safe_as&lt;std::string&gt;(section[&quot;skip_cert_verify_flag&quot;]));
354          global.TLS13Flag.set(safe_as&lt;std::string&gt;(section[&quot;tls13_flag&quot;]));
355          section[&quot;sort_flag&quot;] &gt;&gt; global.enableSort;
356          section[&quot;sort_script&quot;] &gt;&gt; global.sortScript;
357          section[&quot;filter_deprecated_nodes&quot;] &gt;&gt; global.filterDeprecated;
358          section[&quot;append_sub_userinfo&quot;] &gt;&gt; global.appendUserinfo;
359          section[&quot;clash_use_new_field_name&quot;] &gt;&gt; global.clashUseNewField;
360          section[&quot;clash_proxies_style&quot;] &gt;&gt; global.clashProxiesStyle;
361      }
362      if(section[&quot;rename_node&quot;].IsSequence())
363      {
364          readRegexMatch(section[&quot;rename_node&quot;], &quot;@&quot;, tempArray, false);
365          auto configs = INIBinding::from&lt;RegexMatchConfig&gt;::from_ini(tempArray, &quot;@&quot;);
366          safe_set_renames(configs);
367          eraseElements(tempArray);
368      }
369      if(node[&quot;managed_config&quot;].IsDefined())
370      {
371          section = node[&quot;managed_config&quot;];
372          section[&quot;write_managed_config&quot;] &gt;&gt; global.writeManagedConfig;
373          section[&quot;managed_config_prefix&quot;] &gt;&gt; global.managedConfigPrefix;
374          section[&quot;config_update_interval&quot;] &gt;&gt; global.updateInterval;
375          section[&quot;config_update_strict&quot;] &gt;&gt; global.updateStrict;
376          section[&quot;quanx_device_id&quot;] &gt;&gt; global.quanXDevID;
377      }
378      if(node[&quot;surge_external_proxy&quot;].IsDefined())
379      {
380          node[&quot;surge_external_proxy&quot;][&quot;surge_ssr_path&quot;] &gt;&gt; global.surgeSSRPath;
381          node[&quot;surge_external_proxy&quot;][&quot;resolve_hostname&quot;] &gt;&gt; global.surgeResolveHostname;
382      }
383      if(node[&quot;emojis&quot;].IsDefined())
384      {
385          section = node[&quot;emojis&quot;];
386          section[&quot;add_emoji&quot;] &gt;&gt; global.addEmoji;
387          section[&quot;remove_old_emoji&quot;] &gt;&gt; global.removeEmoji;
388          if(section[&quot;rules&quot;].IsSequence())
389          {
390              readEmoji(section[&quot;rules&quot;], tempArray, false);
391              auto configs = INIBinding::from&lt;RegexMatchConfig&gt;::from_ini(tempArray, &quot;,&quot;);
392              safe_set_emojis(configs);
393              eraseElements(tempArray);
394          }
395      }
396      const char *rulesets_title = node[&quot;rulesets&quot;].IsDefined() ? &quot;rulesets&quot; : &quot;ruleset&quot;;
397      if(node[rulesets_title].IsDefined())
398      {
399          section = node[rulesets_title];
400          section[&quot;enabled&quot;] &gt;&gt; global.enableRuleGen;
401          if(!global.enableRuleGen)
402          {
403              global.overwriteOriginalRules = false;
404              global.updateRulesetOnRequest = false;
405          }
406          else
407          {
408              section[&quot;overwrite_original_rules&quot;] &gt;&gt; global.overwriteOriginalRules;
409              section[&quot;update_ruleset_on_request&quot;] &gt;&gt; global.updateRulesetOnRequest;
410          }
411          const char *ruleset_title = section[&quot;rulesets&quot;].IsDefined() ? &quot;rulesets&quot; : &quot;surge_ruleset&quot;;
412          if(section[ruleset_title].IsSequence())
413          {
414              string_array vArray;
415              readRuleset(section[ruleset_title], vArray, false);
416              global.customRulesets = INIBinding::from&lt;RulesetConfig&gt;::from_ini(vArray);
417          }
418      }
419      const char *groups_title = node[&quot;proxy_groups&quot;].IsDefined() ? &quot;proxy_groups&quot; : &quot;proxy_group&quot;;
420      if(node[groups_title].IsDefined() &amp;&amp; node[groups_title][&quot;custom_proxy_group&quot;].IsDefined())
421      {
422          string_array vArray;
423          readGroup(node[groups_title][&quot;custom_proxy_group&quot;], vArray, false);
424          global.customProxyGroups = INIBinding::from&lt;ProxyGroupConfig&gt;::from_ini(vArray);
425      }
426      if(node[&quot;template&quot;].IsDefined())
427      {
428          node[&quot;template&quot;][&quot;template_path&quot;] &gt;&gt; global.templatePath;
429          if(node[&quot;template&quot;][&quot;globals&quot;].IsSequence())
430          {
431              eraseElements(global.templateVars);
432              for(size_t i = 0; i &lt; node[&quot;template&quot;][&quot;globals&quot;].size(); i++)
433              {
434                  std::string key, value;
435                  node[&quot;template&quot;][&quot;globals&quot;][i][&quot;key&quot;] &gt;&gt; key;
436                  node[&quot;template&quot;][&quot;globals&quot;][i][&quot;value&quot;] &gt;&gt; value;
437                  global.templateVars[key] = value;
438              }
439          }
440      }
441      if(node[&quot;aliases&quot;].IsSequence())
442      {
443          webServer.reset_redirect();
444          for(size_t i = 0; i &lt; node[&quot;aliases&quot;].size(); i++)
445          {
446              std::string uri, target;
447              node[&quot;aliases&quot;][i][&quot;uri&quot;] &gt;&gt; uri;
448              node[&quot;aliases&quot;][i][&quot;target&quot;] &gt;&gt; target;
449              webServer.append_redirect(uri, target);
450          }
451      }
452      if(node[&quot;tasks&quot;].IsSequence())
453      {
454          string_array vArray;
455          for(size_t i = 0; i &lt; node[&quot;tasks&quot;].size(); i++)
456          {
457              std::string name, exp, path, timeout;
458              node[&quot;tasks&quot;][i][&quot;import&quot;] &gt;&gt; name;
459              if(name.size())
460              {
461                  vArray.emplace_back(&quot;!!import:&quot; + name);
462                  continue;
463              }
464              node[&quot;tasks&quot;][i][&quot;name&quot;] &gt;&gt; name;
465              node[&quot;tasks&quot;][i][&quot;cronexp&quot;] &gt;&gt; exp;
466              node[&quot;tasks&quot;][i][&quot;path&quot;] &gt;&gt; path;
467              node[&quot;tasks&quot;][i][&quot;timeout&quot;] &gt;&gt; timeout;
468              strLine = name + &quot;`&quot; + exp + &quot;`&quot; + path + &quot;`&quot; + timeout;
469              vArray.emplace_back(std::move(strLine));
470          }
471          importItems(vArray, false);
472          global.enableCron = !vArray.empty();
473          global.cronTasks = INIBinding::from&lt;CronTaskConfig&gt;::from_ini(vArray);
474          refresh_schedule();
475      }
476      if(node[&quot;server&quot;].IsDefined())
477      {
478          node[&quot;server&quot;][&quot;listen&quot;] &gt;&gt; global.listenAddress;
479          node[&quot;server&quot;][&quot;port&quot;] &gt;&gt; global.listenPort;
480          node[&quot;server&quot;][&quot;serve_file_root&quot;] &gt;&gt;= webServer.serve_file_root;
481          webServer.serve_file = !webServer.serve_file_root.empty();
482      }
483      if(node[&quot;advanced&quot;].IsDefined())
484      {
485          std::string log_level;
486          node[&quot;advanced&quot;][&quot;log_level&quot;] &gt;&gt; log_level;
487          node[&quot;advanced&quot;][&quot;print_debug_info&quot;] &gt;&gt; global.printDbgInfo;
488          if(global.printDbgInfo)
489              global.logLevel = LOG_LEVEL_VERBOSE;
490          else
491          {
492              switch(hash_(log_level))
493              {
494              case &quot;warn&quot;_hash:
495                  global.logLevel = LOG_LEVEL_WARNING;
496                  break;
497              case &quot;error&quot;_hash:
498                  global.logLevel = LOG_LEVEL_ERROR;
499                  break;
500              case &quot;fatal&quot;_hash:
501                  global.logLevel = LOG_LEVEL_FATAL;
502                  break;
503              case &quot;verbose&quot;_hash:
504                  global.logLevel = LOG_LEVEL_VERBOSE;
505                  break;
506              case &quot;debug&quot;_hash:
507                  global.logLevel = LOG_LEVEL_DEBUG;
508                  break;
509              default:
510                  global.logLevel = LOG_LEVEL_INFO;
511              }
512          }
513          node[&quot;advanced&quot;][&quot;max_pending_connections&quot;] &gt;&gt; global.maxPendingConns;
514          node[&quot;advanced&quot;][&quot;max_concurrent_threads&quot;] &gt;&gt; global.maxConcurThreads;
515          node[&quot;advanced&quot;][&quot;max_allowed_rulesets&quot;] &gt;&gt; global.maxAllowedRulesets;
516          node[&quot;advanced&quot;][&quot;max_allowed_rules&quot;] &gt;&gt; global.maxAllowedRules;
517          node[&quot;advanced&quot;][&quot;max_allowed_download_size&quot;] &gt;&gt; global.maxAllowedDownloadSize;
518          if(node[&quot;advanced&quot;][&quot;enable_cache&quot;].IsDefined())
519          {
520              if(safe_as&lt;bool&gt;(node[&quot;advanced&quot;][&quot;enable_cache&quot;]))
521              {
522                  node[&quot;advanced&quot;][&quot;cache_subscription&quot;] &gt;&gt; global.cacheSubscription;
523                  node[&quot;advanced&quot;][&quot;cache_config&quot;] &gt;&gt; global.cacheConfig;
524                  node[&quot;advanced&quot;][&quot;cache_ruleset&quot;] &gt;&gt; global.cacheRuleset;
525                  node[&quot;advanced&quot;][&quot;serve_cache_on_fetch_fail&quot;] &gt;&gt; global.serveCacheOnFetchFail;
526              }
527              else
528                  global.cacheSubscription = global.cacheConfig = global.cacheRuleset = 0; 
529          }
530          node[&quot;advanced&quot;][&quot;script_clean_context&quot;] &gt;&gt; global.scriptCleanContext;
531          node[&quot;advanced&quot;][&quot;async_fetch_ruleset&quot;] &gt;&gt; global.asyncFetchRuleset;
532          node[&quot;advanced&quot;][&quot;skip_failed_links&quot;] &gt;&gt; global.skipFailedLinks;
533      }
534      writeLog(0, &quot;Load preference settings in YAML format completed.&quot;, LOG_LEVEL_INFO);
535  }
536  template &lt;class T, class... U&gt;
537  void find_if_exist(const toml::value &amp;v, const toml::key &amp;k, T&amp; target, U&amp;&amp;... args)
538  {
539      if(v.contains(k)) target = toml::find&lt;T&gt;(v, k);
540      if constexpr (sizeof...(args) &gt; 0) find_if_exist(v, std::forward&lt;U&gt;(args)...);
541  }
542  void operate_toml_kv_table(const std::vector&lt;toml::table&gt; &amp;arr, const toml::key &amp;key_name, const toml::key &amp;value_name, std::function&lt;void (const toml::value&amp;, const toml::value&amp;)&gt; binary_op)
543  {
544      for(const toml::table &amp;table : arr)
545      {
546          const auto &amp;key = table.at(key_name), value = table.at(value_name);
547          binary_op(key, value);
548      }
549  }
550  void readTOMLConf(toml::value &amp;root)
551  {
552      const auto &amp;section_common = toml::find(root, &quot;common&quot;);
553      string_array default_url, insert_url;
554      find_if_exist(section_common, &quot;default_url&quot;, default_url, &quot;insert_url&quot;, insert_url);
555      global.defaultUrls = join(default_url, &quot;|&quot;);
556      global.insertUrls = join(insert_url, &quot;|&quot;);
557      bool filter = false;
558      find_if_exist(section_common,
559                    &quot;api_mode&quot;, global.APIMode,
560                    &quot;api_access_token&quot;, global.accessToken,
561                    &quot;exclude_remarks&quot;, global.excludeRemarks,
562                    &quot;include_remarks&quot;, global.includeRemarks,
563                    &quot;enable_insert&quot;, global.enableInsert,
564                    &quot;prepend_insert_url&quot;, global.prependInsert,
565                    &quot;enable_filter&quot;, filter,
566                    &quot;default_external_config&quot;, global.defaultExtConfig,
567                    &quot;base_path&quot;, global.basePath,
568                    &quot;clash_rule_base&quot;, global.clashBase,
569                    &quot;surge_rule_base&quot;, global.surgeBase,
570                    &quot;surfboard_rule_base&quot;, global.surfboardBase,
571                    &quot;mellow_rule_base&quot;, global.mellowBase,
572                    &quot;quan_rule_base&quot;, global.quanBase,
573                    &quot;quanx_rule_base&quot;, global.quanXBase,
574                    &quot;loon_rule_base&quot;, global.loonBase,
575                    &quot;proxy_config&quot;, global.proxyConfig,
576                    &quot;proxy_ruleset&quot;, global.proxyRuleset,
577                    &quot;proxy_subscription&quot;, global.proxySubscription,
578                    &quot;append_proxy_type&quot;, global.appendType
579      );
580      if(filter)
581          find_if_exist(section_common, &quot;filter_script&quot;, global.filterScript);
582      else
583          global.filterScript.clear();
584      safe_set_streams(toml::find_or&lt;RegexMatchConfigs&gt;(root, &quot;userinfo&quot;, &quot;stream_rule&quot;, RegexMatchConfigs{}));
585      safe_set_times(toml::find_or&lt;RegexMatchConfigs&gt;(root, &quot;userinfo&quot;, &quot;time_rule&quot;, RegexMatchConfigs{}));
586      const auto &amp;section_node_pref = toml::find(root, &quot;node_pref&quot;);
587      find_if_exist(section_node_pref,
588                    &quot;udp_flag&quot;, global.UDPFlag,
589                    &quot;tcp_fast_open_flag&quot;, global.TFOFlag,
590                    &quot;skip_cert_verify_flag&quot;, global.skipCertVerify,
591                    &quot;tls13_flag&quot;, global.TLS13Flag,
592                    &quot;sort_flag&quot;, global.enableSort,
593                    &quot;sort_script&quot;, global.sortScript,
594                    &quot;filter_deprecated_nodes&quot;, global.filterDeprecated,
595                    &quot;append_sub_userinfo&quot;, global.appendUserinfo,
596                    &quot;clash_use_new_field_name&quot;, global.clashUseNewField,
597                    &quot;clash_proxies_style&quot;, global.clashProxiesStyle
598      );
599      auto renameconfs = toml::find_or&lt;std::vector&lt;toml::value&gt;&gt;(section_node_pref, &quot;rename_node&quot;, {});
600      importItems(renameconfs, &quot;rename_node&quot;, false);
601      safe_set_renames(toml::get&lt;RegexMatchConfigs&gt;(toml::value(renameconfs)));
602      const auto &amp;section_managed = toml::find(root, &quot;managed_config&quot;);
603      find_if_exist(section_managed,
604                    &quot;write_managed_config&quot;, global.writeManagedConfig,
605                    &quot;managed_config_prefix&quot;, global.managedConfigPrefix,
606                    &quot;config_update_interval&quot;, global.updateInterval,
607                    &quot;config_update_strict&quot;, global.updateStrict,
608                    &quot;quanx_device_id&quot;, global.quanXDevID
609      );
610      const auto &amp;section_surge_external = toml::find(root, &quot;surge_external_proxy&quot;);
611      find_if_exist(section_surge_external,
612                    &quot;surge_ssr_path&quot;, global.surgeSSRPath,
613                    &quot;resolve_hostname&quot;, global.surgeResolveHostname
614      );
615      const auto &amp;section_emojis = toml::find(root, &quot;emojis&quot;);
616      find_if_exist(section_emojis,
617                    &quot;add_emoji&quot;, global.addEmoji,
618                    &quot;remove_old_emoji&quot;, global.removeEmoji
619      );
620      auto emojiconfs = toml::find_or&lt;std::vector&lt;toml::value&gt;&gt;(section_emojis, &quot;emoji&quot;, {});
621      importItems(emojiconfs, &quot;emoji&quot;, false);
622      safe_set_emojis(toml::get&lt;RegexMatchConfigs&gt;(toml::value(emojiconfs)));
623      auto groups = toml::find_or&lt;std::vector&lt;toml::value&gt;&gt;(root, &quot;custom_groups&quot;, {});
624      importItems(groups, &quot;custom_groups&quot;, false);
625      global.customProxyGroups = toml::get&lt;ProxyGroupConfigs&gt;(toml::value(groups));
626      const auto &amp;section_ruleset = toml::find(root, &quot;ruleset&quot;);
627      find_if_exist(section_ruleset,
628                    &quot;enabled&quot;, global.enableRuleGen,
629                    &quot;overwrite_original_rules&quot;, global.overwriteOriginalRules,
630                    &quot;update_ruleset_on_request&quot;, global.updateRulesetOnRequest
631      );
632      auto rulesets = toml::find_or&lt;std::vector&lt;toml::value&gt;&gt;(root, &quot;rulesets&quot;, {});
633      importItems(rulesets, &quot;rulesets&quot;, false);
634      global.customRulesets = toml::get&lt;RulesetConfigs&gt;(toml::value(rulesets));
635      const auto &amp;section_template = toml::find(root, &quot;template&quot;);
636      global.templatePath = toml::find_or(section_template, &quot;template_path&quot;, &quot;template&quot;);
637      eraseElements(global.templateVars);
638      operate_toml_kv_table(toml::find_or&lt;std::vector&lt;toml::table&gt;&gt;(section_template, &quot;globals&quot;, {}), &quot;key&quot;, &quot;value&quot;, [&amp;](const toml::value &amp;key, const toml::value &amp;value)
639      {
640          global.templateVars[key.as_string()] = value.as_string();
641      });
642      webServer.reset_redirect();
643      operate_toml_kv_table(toml::find_or&lt;std::vector&lt;toml::table&gt;&gt;(root, &quot;aliases&quot;, {}), &quot;uri&quot;, &quot;target&quot;, [&amp;](const toml::value &amp;key, const toml::value &amp;value)
644      {
645          webServer.append_redirect(key.as_string(), value.as_string());
646      });
647      auto tasks = toml::find_or&lt;std::vector&lt;toml::value&gt;&gt;(root, &quot;tasks&quot;, {});
648      importItems(tasks, &quot;tasks&quot;, false);
649      global.cronTasks = toml::get&lt;CronTaskConfigs&gt;(toml::value(tasks));
650      const auto &amp;section_server = toml::find(root, &quot;server&quot;);
651      find_if_exist(section_server,
652                    &quot;listen&quot;, global.listenAddress,
653                    &quot;port&quot;, global.listenPort,
654                    &quot;serve_file_root&quot;, webServer.serve_file_root
655      );
656      webServer.serve_file = !webServer.serve_file_root.empty();
657      const auto &amp;section_advanced = toml::find(root, &quot;advanced&quot;);
658      std::string log_level;
659      bool enable_cache = true;
660      int cache_subscription = global.cacheSubscription, cache_config = global.cacheConfig, cache_ruleset = global.cacheRuleset;
661      find_if_exist(section_advanced,
662                    &quot;log_level&quot;, log_level,
663                    &quot;print_debug_info&quot;, global.printDbgInfo,
664                    &quot;max_pending_connections&quot;, global.maxPendingConns,
665                    &quot;max_concurrent_threads&quot;, global.maxConcurThreads,
666                    &quot;max_allowed_rulesets&quot;, global.maxAllowedRulesets,
667                    &quot;max_allowed_rules&quot;, global.maxAllowedRules,
668                    &quot;max_allowed_download_size&quot;, global.maxAllowedDownloadSize,
669                    &quot;enable_cache&quot;, enable_cache,
670                    &quot;cache_subscription&quot;, cache_subscription,
671                    &quot;cache_config&quot;, cache_config,
672                    &quot;cache_ruleset&quot;, cache_ruleset,
673                    &quot;script_clean_context&quot;, global.scriptCleanContext,
674                    &quot;async_fetch_ruleset&quot;, global.asyncFetchRuleset,
675                    &quot;skip_failed_links&quot;, global.skipFailedLinks
676      );
677      if(global.printDbgInfo)
678          global.logLevel = LOG_LEVEL_VERBOSE;
679      else
680      {
681          switch(hash_(log_level))
682          {
683          case &quot;warn&quot;_hash:
684              global.logLevel = LOG_LEVEL_WARNING;
685              break;
686          case &quot;error&quot;_hash:
687              global.logLevel = LOG_LEVEL_ERROR;
688              break;
689          case &quot;fatal&quot;_hash:
690              global.logLevel = LOG_LEVEL_FATAL;
691              break;
692          case &quot;verbose&quot;_hash:
693              global.logLevel = LOG_LEVEL_VERBOSE;
694              break;
695          case &quot;debug&quot;_hash:
696              global.logLevel = LOG_LEVEL_DEBUG;
697              break;
698          default:
699              global.logLevel = LOG_LEVEL_INFO;
700          }
701      }
702      if(enable_cache)
703      {
704          global.cacheSubscription = cache_subscription;
705          global.cacheConfig = cache_config;
706          global.cacheRuleset = cache_ruleset;
707      }
708      else
709      {
710          global.cacheSubscription = global.cacheConfig = global.cacheRuleset = 0;
711      }
712      writeLog(0, &quot;Load preference settings in TOML format completed.&quot;, LOG_LEVEL_INFO);
713  }
714  void readConf()
715  {
716      guarded_mutex guard(gMutexConfigure);
717      writeLog(0, &quot;Loading preference settings...&quot;, LOG_LEVEL_INFO);
718      eraseElements(global.excludeRemarks);
719      eraseElements(global.includeRemarks);
720      eraseElements(global.customProxyGroups);
721      eraseElements(global.customRulesets);
722      try
723      {
724          std::string prefdata = fileGet(global.prefPath, false);
725          if(prefdata.find(&quot;common:&quot;) != prefdata.npos)
726          {
727              YAML::Node yaml = YAML::Load(prefdata);
728              if(yaml.size() &amp;&amp; yaml[&quot;common&quot;])
729                  return readYAMLConf(yaml);
730          }
731          toml::value conf = parseToml(prefdata, global.prefPath);
732          if(!conf.is_uninitialized() &amp;&amp; toml::find_or&lt;int&gt;(conf, &quot;version&quot;, 0))
733              return readTOMLConf(conf);
734      }
735      catch (YAML::Exception &amp;e)
736      {
737          writeLog(0, e.what(), LOG_LEVEL_DEBUG);
738          writeLog(0, &quot;Unable to load preference settings as YAML.&quot;, LOG_LEVEL_DEBUG);
739      }
740      catch (toml::exception &amp;e)
741      {
742          writeLog(0, e.what(), LOG_LEVEL_DEBUG);
743          writeLog(0, &quot;Unable to load preference settings as TOML.&quot;, LOG_LEVEL_DEBUG);
744      }
745      INIReader ini;
746      ini.allow_dup_section_titles = true;
747      int retVal = ini.ParseFile(global.prefPath);
748      if(retVal != INIREADER_EXCEPTION_NONE)
749      {
750          writeLog(0, &quot;Unable to load preference settings as INI. Reason: &quot; + ini.GetLastError(), LOG_LEVEL_FATAL);
751          return;
752      }
753      string_array tempArray;
754      ini.EnterSection(&quot;common&quot;);
755      ini.GetBoolIfExist(&quot;api_mode&quot;, global.APIMode);
756      ini.GetIfExist(&quot;api_access_token&quot;, global.accessToken);
757      ini.GetIfExist(&quot;default_url&quot;, global.defaultUrls);
758      global.enableInsert = ini.Get(&quot;enable_insert&quot;);
759      ini.GetIfExist(&quot;insert_url&quot;, global.insertUrls);
760      ini.GetBoolIfExist(&quot;prepend_insert_url&quot;, global.prependInsert);
761      if(ini.ItemPrefixExist(&quot;exclude_remarks&quot;))
762          ini.GetAll(&quot;exclude_remarks&quot;, global.excludeRemarks);
763      if(ini.ItemPrefixExist(&quot;include_remarks&quot;))
764          ini.GetAll(&quot;include_remarks&quot;, global.includeRemarks);
765      global.filterScript = ini.GetBool(&quot;enable_filter&quot;) ? ini.Get(&quot;filter_script&quot;): &quot;&quot;;
766      ini.GetIfExist(&quot;base_path&quot;, global.basePath);
767      ini.GetIfExist(&quot;clash_rule_base&quot;, global.clashBase);
768      ini.GetIfExist(&quot;surge_rule_base&quot;, global.surgeBase);
769      ini.GetIfExist(&quot;surfboard_rule_base&quot;, global.surfboardBase);
770      ini.GetIfExist(&quot;mellow_rule_base&quot;, global.mellowBase);
771      ini.GetIfExist(&quot;quan_rule_base&quot;, global.quanBase);
772      ini.GetIfExist(&quot;quanx_rule_base&quot;, global.quanXBase);
773      ini.GetIfExist(&quot;loon_rule_base&quot;, global.loonBase);
774      ini.GetIfExist(&quot;default_external_config&quot;, global.defaultExtConfig);
775      ini.GetBoolIfExist(&quot;append_proxy_type&quot;, global.appendType);
776      ini.GetIfExist(&quot;proxy_config&quot;, global.proxyConfig);
777      ini.GetIfExist(&quot;proxy_ruleset&quot;, global.proxyRuleset);
778      ini.GetIfExist(&quot;proxy_subscription&quot;, global.proxySubscription);
779      if(ini.SectionExist(&quot;surge_external_proxy&quot;))
780      {
781          ini.EnterSection(&quot;surge_external_proxy&quot;);
782          ini.GetIfExist(&quot;surge_ssr_path&quot;, global.surgeSSRPath);
783          ini.GetBoolIfExist(&quot;resolve_hostname&quot;, global.surgeResolveHostname);
784      }
785      if(ini.SectionExist(&quot;node_pref&quot;))
786      {
787          ini.EnterSection(&quot;node_pref&quot;);
788          global.UDPFlag.set(ini.Get(&quot;udp_flag&quot;));
789          global.TFOFlag.set(ini.Get(&quot;tcp_fast_open_flag&quot;));
790          global.skipCertVerify.set(ini.Get(&quot;skip_cert_verify_flag&quot;));
791          global.TLS13Flag.set(ini.Get(&quot;tls13_flag&quot;));
792          ini.GetBoolIfExist(&quot;sort_flag&quot;, global.enableSort);
793          global.sortScript = ini.Get(&quot;sort_script&quot;);
794          ini.GetBoolIfExist(&quot;filter_deprecated_nodes&quot;, global.filterDeprecated);
795          ini.GetBoolIfExist(&quot;append_sub_userinfo&quot;, global.appendUserinfo);
796          ini.GetBoolIfExist(&quot;clash_use_new_field_name&quot;, global.clashUseNewField);
797          ini.GetIfExist(&quot;clash_proxies_style&quot;, global.clashProxiesStyle);
798          if(ini.ItemPrefixExist(&quot;rename_node&quot;))
799          {
800              ini.GetAll(&quot;rename_node&quot;, tempArray);
801              importItems(tempArray, false);
802              auto configs = INIBinding::from&lt;RegexMatchConfig&gt;::from_ini(tempArray, &quot;@&quot;);
803              safe_set_renames(configs);
804              eraseElements(tempArray);
805          }
806      }
807      if(ini.SectionExist(&quot;userinfo&quot;))
808      {
809          ini.EnterSection(&quot;userinfo&quot;);
810          if(ini.ItemPrefixExist(&quot;stream_rule&quot;))
811          {
812              ini.GetAll(&quot;stream_rule&quot;, tempArray);
813              importItems(tempArray, false);
814              auto configs = INIBinding::from&lt;RegexMatchConfig&gt;::from_ini(tempArray, &quot;|&quot;);
815              safe_set_streams(configs);
816              eraseElements(tempArray);
817          }
818          if(ini.ItemPrefixExist(&quot;time_rule&quot;))
819          {
820              ini.GetAll(&quot;time_rule&quot;, tempArray);
821              importItems(tempArray, false);
822              auto configs = INIBinding::from&lt;RegexMatchConfig&gt;::from_ini(tempArray, &quot;|&quot;);
823              safe_set_times(configs);
824              eraseElements(tempArray);
825          }
826      }
827      ini.EnterSection(&quot;managed_config&quot;);
828      ini.GetBoolIfExist(&quot;write_managed_config&quot;, global.writeManagedConfig);
829      ini.GetIfExist(&quot;managed_config_prefix&quot;, global.managedConfigPrefix);
830      ini.GetIntIfExist(&quot;config_update_interval&quot;, global.updateInterval);
831      ini.GetBoolIfExist(&quot;config_update_strict&quot;, global.updateStrict);
832      ini.GetIfExist(&quot;quanx_device_id&quot;, global.quanXDevID);
833      ini.EnterSection(&quot;emojis&quot;);
834      ini.GetBoolIfExist(&quot;add_emoji&quot;, global.addEmoji);
835      ini.GetBoolIfExist(&quot;remove_old_emoji&quot;, global.removeEmoji);
836      if(ini.ItemPrefixExist(&quot;rule&quot;))
837      {
838          ini.GetAll(&quot;rule&quot;, tempArray);
839          importItems(tempArray, false);
840          auto configs = INIBinding::from&lt;RegexMatchConfig&gt;::from_ini(tempArray, &quot;,&quot;);
841          safe_set_emojis(configs);
842          eraseElements(tempArray);
843      }
844      if(ini.SectionExist(&quot;rulesets&quot;))
845          ini.EnterSection(&quot;rulesets&quot;);
846      else
847          ini.EnterSection(&quot;ruleset&quot;);
848      global.enableRuleGen = ini.GetBool(&quot;enabled&quot;);
849      if(global.enableRuleGen)
850      {
851          ini.GetBoolIfExist(&quot;overwrite_original_rules&quot;, global.overwriteOriginalRules);
852          ini.GetBoolIfExist(&quot;update_ruleset_on_request&quot;, global.updateRulesetOnRequest);
853          if(ini.ItemPrefixExist(&quot;ruleset&quot;))
854          {
855              string_array vArray;
856              ini.GetAll(&quot;ruleset&quot;, vArray);
857              importItems(vArray, false);
858              global.customRulesets = INIBinding::from&lt;RulesetConfig&gt;::from_ini(vArray);
859          }
860          else if(ini.ItemPrefixExist(&quot;surge_ruleset&quot;))
861          {
862              string_array vArray;
863              ini.GetAll(&quot;surge_ruleset&quot;, vArray);
864              importItems(vArray, false);
865              global.customRulesets = INIBinding::from&lt;RulesetConfig&gt;::from_ini(vArray);
866          }
867      }
868      else
869      {
870          global.overwriteOriginalRules = false;
871          global.updateRulesetOnRequest = false;
872      }
873      if(ini.SectionExist(&quot;proxy_groups&quot;))
874          ini.EnterSection(&quot;proxy_groups&quot;);
875      else
876          ini.EnterSection(&quot;clash_proxy_group&quot;);
877      if(ini.ItemPrefixExist(&quot;custom_proxy_group&quot;))
878      {
879          string_array vArray;
880          ini.GetAll(&quot;custom_proxy_group&quot;, vArray);
881          importItems(vArray, false);
882          global.customProxyGroups = INIBinding::from&lt;ProxyGroupConfig&gt;::from_ini(vArray);
883      }
884      ini.EnterSection(&quot;template&quot;);
885      ini.GetIfExist(&quot;template_path&quot;, global.templatePath);
886      string_multimap tempmap;
887      ini.GetItems(tempmap);
888      eraseElements(global.templateVars);
889      for(auto &amp;x : tempmap)
890      {
891          if(x.first == &quot;template_path&quot;)
892              continue;
893          global.templateVars[x.first] = x.second;
894      }
895      global.templateVars[&quot;managed_config_prefix&quot;] = global.managedConfigPrefix;
896      if(ini.SectionExist(&quot;aliases&quot;))
897      {
898          ini.EnterSection(&quot;aliases&quot;);
899          ini.GetItems(tempmap);
900          webServer.reset_redirect();
901          for(auto &amp;x : tempmap)
902              webServer.append_redirect(x.first, x.second);
903      }
904      if(ini.SectionExist(&quot;tasks&quot;))
905      {
906          string_array vArray;
907          ini.EnterSection(&quot;tasks&quot;);
908          ini.GetAll(&quot;task&quot;, vArray);
909          importItems(vArray, false);
910          global.enableCron = !vArray.empty();
911          global.cronTasks = INIBinding::from&lt;CronTaskConfig&gt;::from_ini(vArray);
912          refresh_schedule();
913      }
914      ini.EnterSection(&quot;server&quot;);
915      ini.GetIfExist(&quot;listen&quot;, global.listenAddress);
916      ini.GetIntIfExist(&quot;port&quot;, global.listenPort);
917      webServer.serve_file_root = ini.Get(&quot;serve_file_root&quot;);
918      webServer.serve_file = !webServer.serve_file_root.empty();
919      ini.EnterSection(&quot;advanced&quot;);
920      std::string log_level;
921      ini.GetIfExist(&quot;log_level&quot;, log_level);
922      ini.GetBoolIfExist(&quot;print_debug_info&quot;, global.printDbgInfo);
923      if(global.printDbgInfo)
924          global.logLevel = LOG_LEVEL_VERBOSE;
925      else
926      {
927          switch(hash_(log_level))
928          {
929          case &quot;warn&quot;_hash:
930              global.logLevel = LOG_LEVEL_WARNING;
931              break;
932          case &quot;error&quot;_hash:
933              global.logLevel = LOG_LEVEL_ERROR;
934              break;
935          case &quot;fatal&quot;_hash:
936              global.logLevel = LOG_LEVEL_FATAL;
937              break;
938          case &quot;verbose&quot;_hash:
939              global.logLevel = LOG_LEVEL_VERBOSE;
940              break;
941          case &quot;debug&quot;_hash:
942              global.logLevel = LOG_LEVEL_DEBUG;
943              break;
944          default:
945              global.logLevel = LOG_LEVEL_INFO;
946          }
947      }
948      ini.GetIntIfExist(&quot;max_pending_connections&quot;, global.maxPendingConns);
949      ini.GetIntIfExist(&quot;max_concurrent_threads&quot;, global.maxConcurThreads);
950      ini.GetNumberIfExist(&quot;max_allowed_rulesets&quot;, global.maxAllowedRulesets);
951      ini.GetNumberIfExist(&quot;max_allowed_rules&quot;, global.maxAllowedRules);
952      ini.GetNumberIfExist(&quot;max_allowed_download_size&quot;, global.maxAllowedDownloadSize);
953      if(ini.ItemExist(&quot;enable_cache&quot;))
954      {
955          if(ini.GetBool(&quot;enable_cache&quot;))
956          {
957              ini.GetIntIfExist(&quot;cache_subscription&quot;, global.cacheSubscription);
958              ini.GetIntIfExist(&quot;cache_config&quot;, global.cacheConfig);
959              ini.GetIntIfExist(&quot;cache_ruleset&quot;, global.cacheRuleset);
960              ini.GetBoolIfExist(&quot;serve_cache_on_fetch_fail&quot;, global.serveCacheOnFetchFail);
961          }
962          else
963          {
964              global.cacheSubscription = global.cacheConfig = global.cacheRuleset = 0; 
965              global.serveCacheOnFetchFail = false;
966          }
967      }
968      ini.GetBoolIfExist(&quot;script_clean_context&quot;, global.scriptCleanContext);
969      ini.GetBoolIfExist(&quot;async_fetch_ruleset&quot;, global.asyncFetchRuleset);
970      ini.GetBoolIfExist(&quot;skip_failed_links&quot;, global.skipFailedLinks);
971      writeLog(0, &quot;Load preference settings in INI format completed.&quot;, LOG_LEVEL_INFO);
972  }
973  int loadExternalYAML(YAML::Node &amp;node, ExternalConfig &amp;ext)
974  {
975      YAML::Node section = node[&quot;custom&quot;], object;
976      std::string name, type, url, interval;
977      std::string group, strLine;
978      section[&quot;clash_rule_base&quot;] &gt;&gt; ext.clash_rule_base;
979      section[&quot;surge_rule_base&quot;] &gt;&gt; ext.surge_rule_base;
980      section[&quot;surfboard_rule_base&quot;] &gt;&gt; ext.surfboard_rule_base;
981      section[&quot;mellow_rule_base&quot;] &gt;&gt; ext.mellow_rule_base;
982      section[&quot;quan_rule_base&quot;] &gt;&gt; ext.quan_rule_base;
983      section[&quot;quanx_rule_base&quot;] &gt;&gt; ext.quanx_rule_base;
984      section[&quot;loon_rule_base&quot;] &gt;&gt; ext.loon_rule_base;
985      section[&quot;sssub_rule_base&quot;] &gt;&gt; ext.sssub_rule_base;
986      section[&quot;enable_rule_generator&quot;] &gt;&gt; ext.enable_rule_generator;
987      section[&quot;overwrite_original_rules&quot;] &gt;&gt; ext.overwrite_original_rules;
988      const char *group_name = section[&quot;proxy_groups&quot;].IsDefined() ? &quot;proxy_groups&quot; : &quot;custom_proxy_group&quot;;
989      if(section[group_name].size())
990      {
991          string_array vArray;
992          readGroup(section[group_name], vArray, global.APIMode);
993          ext.custom_proxy_group = INIBinding::from&lt;ProxyGroupConfig&gt;::from_ini(vArray);
994      }
995      const char *ruleset_name = section[&quot;rulesets&quot;].IsDefined() ? &quot;rulesets&quot; : &quot;surge_ruleset&quot;;
996      if(section[ruleset_name].size())
997      {
998          string_array vArray;
999          readRuleset(section[ruleset_name], vArray, global.APIMode);
1000          if(global.maxAllowedRulesets &amp;&amp; vArray.size() &gt; global.maxAllowedRulesets)
1001          {
1002              writeLog(0, &quot;Ruleset count in external config has exceeded limit.&quot;, LOG_LEVEL_WARNING);
1003              return -1;
1004          }
1005          ext.surge_ruleset = INIBinding::from&lt;RulesetConfig&gt;::from_ini(vArray);
1006      }
1007      if(section[&quot;rename_node&quot;].size())
1008      {
1009          string_array vArray;
1010          readRegexMatch(section[&quot;rename_node&quot;], &quot;@&quot;, vArray, global.APIMode);
1011          ext.rename = INIBinding::from&lt;RegexMatchConfig&gt;::from_ini(vArray, &quot;@&quot;);
1012      }
1013      ext.add_emoji = safe_as&lt;std::string&gt;(section[&quot;add_emoji&quot;]);
1014      ext.remove_old_emoji = safe_as&lt;std::string&gt;(section[&quot;remove_old_emoji&quot;]);
1015      const char *emoji_name = section[&quot;emojis&quot;].IsDefined() ? &quot;emojis&quot; : &quot;emoji&quot;;
1016      if(section[emoji_name].size())
1017      {
1018          string_array vArray;
1019          readEmoji(section[emoji_name], vArray, global.APIMode);
1020          ext.emoji = INIBinding::from&lt;RegexMatchConfig&gt;::from_ini(vArray, &quot;,&quot;);
1021      }
1022      section[&quot;include_remarks&quot;] &gt;&gt; ext.include;
1023      section[&quot;exclude_remarks&quot;] &gt;&gt; ext.exclude;
1024      if(node[&quot;template_args&quot;].IsSequence() &amp;&amp; ext.tpl_args != NULL)
1025      {
1026          std::string key, value;
1027          for(size_t i = 0; i &lt; node[&quot;template_args&quot;].size(); i++)
1028          {
1029              node[&quot;template_args&quot;][i][&quot;key&quot;] &gt;&gt; key;
1030              node[&quot;template_args&quot;][i][&quot;value&quot;] &gt;&gt; value;
1031              ext.tpl_args-&gt;local_vars[key] = value;
1032          }
1033      }
1034      return 0;
1035  }
1036  int loadExternalTOML(toml::value &amp;root, ExternalConfig &amp;ext)
1037  {
1038      const auto &amp;section = toml::find(root, &quot;custom&quot;);
1039      find_if_exist(section,
1040                    &quot;enable_rule_generator&quot;, ext.enable_rule_generator,
1041                    &quot;overwrite_original_rules&quot;, ext.overwrite_original_rules,
1042                    &quot;clash_rule_base&quot;, ext.clash_rule_base,
1043                    &quot;surge_rule_base&quot;, ext.surge_rule_base,
1044                    &quot;surfboard_rule_base&quot;, ext.surfboard_rule_base,
1045                    &quot;mellow_rule_base&quot;, ext.mellow_rule_base,
1046                    &quot;quan_rule_base&quot;, ext.quan_rule_base,
1047                    &quot;quanx_rule_base&quot;, ext.quanx_rule_base,
1048                    &quot;sssub_rule_base&quot;, ext.sssub_rule_base,
1049                    &quot;add_emoji&quot;, ext.add_emoji,
1050                    &quot;remove_old_emoji&quot;, ext.remove_old_emoji,
1051                    &quot;include_remarks&quot;, ext.include,
1052                    &quot;exclude_remarks&quot;, ext.exclude
1053      );
1054      if(ext.tpl_args != nullptr) operate_toml_kv_table(toml::find_or&lt;std::vector&lt;toml::table&gt;&gt;(section, &quot;template_args&quot;, {}), &quot;key&quot;, &quot;value&quot;,
1055                                                        [&amp;](const toml::value &amp;key, const toml::value &amp;value)
1056      {
1057          std::string val = toml::format(value);
1058          ext.tpl_args-&gt;local_vars[key.as_string()] = val;
1059      });
1060      auto groups = toml::find_or&lt;std::vector&lt;toml::value&gt;&gt;(root, &quot;custom_groups&quot;, {});
1061      importItems(groups, &quot;custom_groups&quot;, false);
1062      ext.custom_proxy_group = toml::get&lt;ProxyGroupConfigs&gt;(toml::value(groups));
1063      auto rulesets = toml::find_or&lt;std::vector&lt;toml::value&gt;&gt;(root, &quot;rulesets&quot;, {});
1064      importItems(rulesets, &quot;rulesets&quot;, false);
1065      if(global.maxAllowedRulesets &amp;&amp; rulesets.size() &gt; global.maxAllowedRulesets)
1066      {
1067          writeLog(0, &quot;Ruleset count in external config has exceeded limit. &quot;, LOG_LEVEL_WARNING);
1068          return -1;
1069      }
1070      ext.surge_ruleset = toml::get&lt;RulesetConfigs&gt;(toml::value(rulesets));
1071      auto emojiconfs = toml::find_or&lt;std::vector&lt;toml::value&gt;&gt;(root, &quot;emoji&quot;, {});
1072      importItems(emojiconfs, &quot;emoji&quot;, false);
1073      ext.emoji = toml::get&lt;RegexMatchConfigs&gt;(toml::value(emojiconfs));
1074      auto renameconfs = toml::find_or&lt;std::vector&lt;toml::value&gt;&gt;(root, &quot;rename_node&quot;, {});
1075      importItems(renameconfs, &quot;rename_node&quot;, false);
1076      ext.rename = toml::get&lt;RegexMatchConfigs&gt;(toml::value(renameconfs));
1077      return 0;
1078  }
1079  int loadExternalConfig(std::string &amp;path, ExternalConfig &amp;ext)
1080  {
1081      std::string base_content, proxy = parseProxy(global.proxyConfig), config = fetchFile(path, proxy, global.cacheConfig);
1082      if(render_template(config, *ext.tpl_args, base_content, global.templatePath) != 0)
1083          base_content = config;
1084      try
1085      {
1086          YAML::Node yaml = YAML::Load(base_content);
1087          if(yaml.size() &amp;&amp; yaml[&quot;custom&quot;].IsDefined())
1088              return loadExternalYAML(yaml, ext);
1089          toml::value conf = parseToml(base_content, path);
1090          if(!conf.is_uninitialized() &amp;&amp; toml::find_or&lt;int&gt;(conf, &quot;version&quot;, 0))
1091              return loadExternalTOML(conf, ext);
1092      }
1093      catch (YAML::Exception &amp;e)
1094      {
1095      }
1096      catch (toml::exception &amp;e)
1097      {
1098      }
1099      INIReader ini;
1100      ini.store_isolated_line = true;
1101      ini.SetIsolatedItemsSection(&quot;custom&quot;);
1102      if(ini.Parse(base_content) != INIREADER_EXCEPTION_NONE)
1103      {
1104          writeLog(0, &quot;Load external configuration failed. Reason: &quot; + ini.GetLastError(), LOG_LEVEL_ERROR);
1105          return -1;
1106      }
1107      ini.EnterSection(&quot;custom&quot;);
1108      if(ini.ItemPrefixExist(&quot;custom_proxy_group&quot;))
1109      {
1110          string_array vArray;
1111          ini.GetAll(&quot;custom_proxy_group&quot;, vArray);
1112          importItems(vArray, global.APIMode);
1113          ext.custom_proxy_group = INIBinding::from&lt;ProxyGroupConfig&gt;::from_ini(vArray);
1114      }
1115      std::string ruleset_name = ini.ItemPrefixExist(&quot;ruleset&quot;) ? &quot;ruleset&quot; : &quot;surge_ruleset&quot;;
1116      if(ini.ItemPrefixExist(ruleset_name))
1117      {
1118          string_array vArray;
1119          ini.GetAll(ruleset_name, vArray);
1120          importItems(vArray, global.APIMode);
1121          if(global.maxAllowedRulesets &amp;&amp; vArray.size() &gt; global.maxAllowedRulesets)
1122          {
1123              writeLog(0, &quot;Ruleset count in external config has exceeded limit. &quot;, LOG_LEVEL_WARNING);
1124              return -1;
1125          }
1126          ext.surge_ruleset = INIBinding::from&lt;RulesetConfig&gt;::from_ini(vArray);
1127      }
1128      ini.GetIfExist(&quot;clash_rule_base&quot;, ext.clash_rule_base);
1129      ini.GetIfExist(&quot;surge_rule_base&quot;, ext.surge_rule_base);
1130      ini.GetIfExist(&quot;surfboard_rule_base&quot;, ext.surfboard_rule_base);
1131      ini.GetIfExist(&quot;mellow_rule_base&quot;, ext.mellow_rule_base);
1132      ini.GetIfExist(&quot;quan_rule_base&quot;, ext.quan_rule_base);
1133      ini.GetIfExist(&quot;quanx_rule_base&quot;, ext.quanx_rule_base);
1134      ini.GetIfExist(&quot;loon_rule_base&quot;, ext.loon_rule_base);
1135      ini.GetIfExist(&quot;sssub_rule_base&quot;, ext.sssub_rule_base);
1136      ini.GetBoolIfExist(&quot;overwrite_original_rules&quot;, ext.overwrite_original_rules);
1137      ini.GetBoolIfExist(&quot;enable_rule_generator&quot;, ext.enable_rule_generator);
1138      if(ini.ItemPrefixExist(&quot;rename&quot;))
1139      {
1140          string_array vArray;
1141          ini.GetAll(&quot;rename&quot;, vArray);
1142          importItems(vArray, global.APIMode);
1143          ext.rename = INIBinding::from&lt;RegexMatchConfig&gt;::from_ini(vArray, &quot;@&quot;);
1144      }
1145      ext.add_emoji = ini.Get(&quot;add_emoji&quot;);
1146      ext.remove_old_emoji = ini.Get(&quot;remove_old_emoji&quot;);
1147      if(ini.ItemPrefixExist(&quot;emoji&quot;))
1148      {
1149          string_array vArray;
1150          ini.GetAll(&quot;emoji&quot;, vArray);
1151          importItems(vArray, global.APIMode);
1152          ext.emoji = INIBinding::from&lt;RegexMatchConfig&gt;::from_ini(vArray, &quot;,&quot;);
1153      }
1154      if(ini.ItemPrefixExist(&quot;include_remarks&quot;))
1155          ini.GetAll(&quot;include_remarks&quot;, ext.include);
1156      if(ini.ItemPrefixExist(&quot;exclude_remarks&quot;))
1157          ini.GetAll(&quot;exclude_remarks&quot;, ext.exclude);
1158      if(ini.SectionExist(&quot;template&quot;) &amp;&amp; ext.tpl_args != nullptr)
1159      {
1160          ini.EnterSection(&quot;template&quot;);
1161          string_multimap tempmap;
1162          ini.GetItems(tempmap);
1163          for(auto &amp;x : tempmap)
1164              ext.tpl_args-&gt;local_vars[x.first] = x.second;
1165      }
1166      return 0;
1167  }
</code></pre>
        </div>
        <div class="column">
            <h3>subconverter-MDEwOlJlcG9zaXRvcnkyMTg2ODY3NjM=-flat-settings.cpp</h3>
            <pre><code>1  #include &lt;string&gt;
2  #include &lt;mutex&gt;
3  #include &lt;toml.hpp&gt;
4  #include &quot;../config/binding.h&quot;
5  #include &quot;../handler/webget.h&quot;
6  #include &quot;../script/cron.h&quot;
7  #include &quot;../server/webserver.h&quot;
8  #include &quot;../utils/logger.h&quot;
9  #include &quot;../utils/network.h&quot;
10  #include &quot;interfaces.h&quot;
11  #include &quot;multithread.h&quot;
12  #include &quot;settings.h&quot;
13  std::mutex gMutexConfigure;
14  Settings global;
15  extern WebServer webServer;
16  const std::map&lt;std::string, ruleset_type&gt; RulesetTypes = {{&quot;clash-domain:&quot;, RULESET_CLASH_DOMAIN}, {&quot;clash-ipcidr:&quot;, RULESET_CLASH_IPCIDR}, {&quot;clash-classic:&quot;, RULESET_CLASH_CLASSICAL}, \
17              {&quot;quanx:&quot;, RULESET_QUANX}, {&quot;surge:&quot;, RULESET_SURGE}};
18  int importItems(string_array &amp;target, bool scope_limit)
19  {
20      string_array result;
21      std::stringstream ss;
22      std::string path, content, strLine;
23      unsigned int itemCount = 0;
24      for(std::string &amp;x : target)
25      {
26          if(x.find(&quot;!!import:&quot;) == x.npos)
27          {
28              result.emplace_back(x);
29              continue;
30          }
31          path = x.substr(x.find(&quot;:&quot;) + 1);
32          writeLog(0, &quot;Trying to import items from &quot; + path);
33          std::string proxy = parseProxy(global.proxyConfig);
34          if(fileExist(path))
35              content = fileGet(path, scope_limit);
36          else if(isLink(path))
37              content = webGet(path, proxy, global.cacheConfig);
38          else
39              writeLog(0, &quot;File not found or not a valid URL: &quot; + path, LOG_LEVEL_ERROR);
40          if(!content.size())
41              return -1;
42          ss &lt;&lt; content;
43          char delimiter = getLineBreak(content);
44          std::string::size_type lineSize;
45          while(getline(ss, strLine, delimiter))
46          {
47              lineSize = strLine.size();
48              if(lineSize &amp;&amp; strLine[lineSize - 1] == &#x27;\r&#x27;) 
49                  strLine.erase(--lineSize);
50              if(!lineSize || strLine[0] == &#x27;;&#x27; || strLine[0] == &#x27;#&#x27; || (lineSize &gt;= 2 &amp;&amp; strLine[0] == &#x27;/&#x27; &amp;&amp; strLine[1] == &#x27;/&#x27;)) 
51                  continue;
52              result.emplace_back(std::move(strLine));
53              itemCount++;
54          }
55          ss.clear();
56      }
57      target.swap(result);
58      writeLog(0, &quot;Imported &quot; + std::to_string(itemCount) + &quot; item(s).&quot;);
59      return 0;
60  }
61  toml::value parseToml(const std::string &amp;content, const std::string &amp;fname)
62  {
63      std::istringstream is(content);
64      return toml::parse(is, fname);
65  }
66  void importItems(std::vector&lt;toml::value&gt; &amp;root, const std::string &amp;import_key, bool scope_limit = true)
67  {
68      std::string content;
69      std::vector&lt;toml::value&gt; newRoot;
70      auto iter = root.begin();
71      size_t count = 0;
72      std::string proxy = parseProxy(global.proxyConfig);
73      while(iter != root.end())
74      {
75          auto&amp; table = iter-&gt;as_table();
76          if(table.find(&quot;import&quot;) == table.end())
77              newRoot.emplace_back(std::move(*iter));
78          else
79          {
80              const std::string &amp;path = toml::get&lt;std::string&gt;(table.at(&quot;import&quot;));
81              writeLog(0, &quot;Trying to import items from &quot; + path);
82              if(fileExist(path))
83                  content = fileGet(path, scope_limit);
84              else if(isLink(path))
85                  content = webGet(path, proxy, global.cacheConfig);
86              else
87                  writeLog(0, &quot;File not found or not a valid URL: &quot; + path, LOG_LEVEL_ERROR);
88              if(content.size())
89              {
90                  auto items = parseToml(content, path);
91                  auto list = toml::find&lt;std::vector&lt;toml::value&gt;&gt;(items, import_key);
92                  count += list.size();
93                  std::move(list.begin(), list.end(), std::back_inserter(newRoot));
94              }
95          }
96          iter++;
97      }
<span onclick='openModal()' class='match'>98      root.swap(newRoot);
99      writeLog(0, &quot;Imported &quot; + std::to_string(count) + &quot; item(s).&quot;);
100      return;
</span>101  }
102  void readRegexMatch(YAML::Node node, const std::string &amp;delimiter, string_array &amp;dest, bool scope_limit = true)
103  {
104      YAML::Node object;
105      std::string script, url, match, rep, strLine;
106      for(unsigned i = 0; i &lt; node.size(); i++)
107      {
108          object = node[i];
109          object[&quot;script&quot;] &gt;&gt;= script;
110          if(script.size())
111          {
112              dest.emplace_back(&quot;!!script:&quot; + script);
113              continue;
114          }
115          object[&quot;import&quot;] &gt;&gt;= url;
116          if(url.size())
117          {
118              dest.emplace_back(&quot;!!import:&quot; + url);
119              continue;
120          }
121          object[&quot;match&quot;] &gt;&gt;= match;
122          object[&quot;replace&quot;] &gt;&gt;= rep;
123          if(match.size() &amp;&amp; rep.size())
124              strLine = match + delimiter + rep;
125          else
126              continue;
127          dest.emplace_back(std::move(strLine));
128      }
129      importItems(dest, scope_limit);
130  }
131  void readEmoji(YAML::Node node, string_array &amp;dest, bool scope_limit = true)
132  {
133      YAML::Node object;
134      std::string script, url, match, rep, strLine;
135      for(unsigned i = 0; i &lt; node.size(); i++)
136      {
137          object = node[i];
138          object[&quot;script&quot;] &gt;&gt;= script;
139          if(script.size())
140          {
141              dest.emplace_back(&quot;!!script:&quot; + script);
142              continue;
143          }
144          object[&quot;import&quot;] &gt;&gt;= url;
145          if(url.size())
146          {
147              url = &quot;!!import:&quot; + url;
148              dest.emplace_back(url);
149              continue;
150          }
151          object[&quot;match&quot;] &gt;&gt;= match;
152          object[&quot;emoji&quot;] &gt;&gt;= rep;
153          if(match.size() &amp;&amp; rep.size())
154              strLine = match + &quot;,&quot; + rep;
155          else
156              continue;
157          dest.emplace_back(std::move(strLine));
158      }
159      importItems(dest, scope_limit);
160  }
161  void readGroup(YAML::Node node, string_array &amp;dest, bool scope_limit = true)
162  {
163      std::string strLine, name, type;
164      string_array tempArray;
165      YAML::Node object;
166      unsigned int i, j;
167      for(i = 0; i &lt; node.size(); i++)
168      {
169          eraseElements(tempArray);
170          object = node[i];
171          object[&quot;import&quot;] &gt;&gt;= name;
172          if(name.size())
173          {
174              dest.emplace_back(&quot;!!import:&quot; + name);
175              continue;
176          }
177          std::string url = &quot;http:&amp;bsol;&amp;bsol;www.gstatic.com/generate_204&quot;, interval = &quot;300&quot;, tolerance, timeout;
178          object[&quot;name&quot;] &gt;&gt;= name;
179          object[&quot;type&quot;] &gt;&gt;= type;
180          tempArray.emplace_back(name);
181          tempArray.emplace_back(type);
182          object[&quot;url&quot;] &gt;&gt;= url;
183          object[&quot;interval&quot;] &gt;&gt;= interval;
184          object[&quot;tolerance&quot;] &gt;&gt;= tolerance;
185          object[&quot;timeout&quot;] &gt;&gt;= timeout;
186          for(j = 0; j &lt; object[&quot;rule&quot;].size(); j++)
187              tempArray.emplace_back(safe_as&lt;std::string&gt;(object[&quot;rule&quot;][j]));
188          switch(hash_(type))
189          {
190          case &quot;select&quot;_hash:
191              if(tempArray.size() &lt; 3)
192                  continue;
193              break;
194          case &quot;ssid&quot;_hash:
195              if(tempArray.size() &lt; 4)
196                  continue;
197              break;
198          default:
199              if(tempArray.size() &lt; 3)
200                  continue;
201              tempArray.emplace_back(url);
202              tempArray.emplace_back(interval + &quot;,&quot; + timeout + &quot;,&quot; + tolerance);
203          }
204          strLine = std::accumulate(std::next(tempArray.begin()), tempArray.end(), tempArray[0], [](std::string a, std::string b) -&gt; std::string
205          {
206              return std::move(a) + &quot;`&quot; + std::move(b);
207          });
208          dest.emplace_back(std::move(strLine));
209      }
210      importItems(dest, scope_limit);
211  }
212  void readRuleset(YAML::Node node, string_array &amp;dest, bool scope_limit = true)
213  {
214      std::string strLine, name, url, group, interval;
215      YAML::Node object;
216      for(unsigned int i = 0; i &lt; node.size(); i++)
217      {
218          object = node[i];
219          object[&quot;import&quot;] &gt;&gt;= name;
220          if(name.size())
221          {
222              dest.emplace_back(&quot;!!import:&quot; + name);
223              continue;
224          }
225          object[&quot;ruleset&quot;] &gt;&gt;= url;
226          object[&quot;group&quot;] &gt;&gt;= group;
227          object[&quot;rule&quot;] &gt;&gt;= name;
228          object[&quot;interval&quot;] &gt;&gt;= interval;
229          if(url.size())
230          {
231              strLine = group + &quot;,&quot; + url;
232              if(interval.size())
233                  strLine += &quot;,&quot; + interval;
234          }
235          else if(name.size())
236              strLine = group + &quot;,[]&quot; + name;
237          else
238              continue;
239          dest.emplace_back(std::move(strLine));
240      }
241      importItems(dest, scope_limit);
242  }
243  void refreshRulesets(RulesetConfigs &amp;ruleset_list, std::vector&lt;RulesetContent&gt; &amp;ruleset_content_array)
244  {
245      eraseElements(ruleset_content_array);
246      std::string rule_group, rule_url, rule_url_typed, interval;
247      RulesetContent rc;
248      std::string proxy = parseProxy(global.proxyRuleset);
249      for(RulesetConfig &amp;x : ruleset_list)
250      {
251          rule_group = x.Group;
252          rule_url = x.Url;
253          std::string::size_type pos = x.Url.find(&quot;[]&quot;);
254          if(pos != std::string::npos)
255          {
256              writeLog(0, &quot;Adding rule &#x27;&quot; + rule_url.substr(pos + 2) + &quot;,&quot; + rule_group + &quot;&#x27;.&quot;, LOG_LEVEL_INFO);
257              rc = {rule_group, &quot;&quot;, &quot;&quot;, RULESET_SURGE, std::async(std::launch::async, [=](){return rule_url.substr(pos);}), 0};
258          }
259          else
260          {
261              ruleset_type type = RULESET_SURGE;
262              rule_url_typed = rule_url;
263              auto iter = std::find_if(RulesetTypes.begin(), RulesetTypes.end(), [rule_url](auto y){ return startsWith(rule_url, y.first); });
264              if(iter != RulesetTypes.end())
265              {
266                  rule_url.erase(0, iter-&gt;first.size());
267                  type = iter-&gt;second;
268              }
269              writeLog(0, &quot;Updating ruleset url &#x27;&quot; + rule_url + &quot;&#x27; with group &#x27;&quot; + rule_group + &quot;&#x27;.&quot;, LOG_LEVEL_INFO);
270              rc = {rule_group, rule_url, rule_url_typed, type, fetchFileAsync(rule_url, proxy, global.cacheRuleset, true, global.asyncFetchRuleset), x.Interval};
271          }
272          ruleset_content_array.emplace_back(std::move(rc));
273      }
274      ruleset_content_array.shrink_to_fit();
275  }
276  void readYAMLConf(YAML::Node &amp;node)
277  {
278      YAML::Node section = node[&quot;common&quot;];
279      std::string strLine;
280      string_array tempArray;
281      section[&quot;api_mode&quot;] &gt;&gt; global.APIMode;
282      section[&quot;api_access_token&quot;] &gt;&gt; global.accessToken;
283      if(section[&quot;default_url&quot;].IsSequence())
284      {
285          section[&quot;default_url&quot;] &gt;&gt; tempArray;
286          if(tempArray.size())
287          {
288              strLine = std::accumulate(std::next(tempArray.begin()), tempArray.end(), tempArray[0], [](std::string a, std::string b)
289              {
290                  return std::move(a) + &quot;|&quot; + std::move(b);
291              });
292              global.defaultUrls = strLine;
293              eraseElements(tempArray);
294          }
295      }
296      global.enableInsert = safe_as&lt;std::string&gt;(section[&quot;enable_insert&quot;]);
297      if(section[&quot;insert_url&quot;].IsSequence())
298      {
299          section[&quot;insert_url&quot;] &gt;&gt; tempArray;
300          if(tempArray.size())
301          {
302              strLine = std::accumulate(std::next(tempArray.begin()), tempArray.end(), tempArray[0], [](std::string a, std::string b)
303              {
304                  return std::move(a) + &quot;|&quot; + std::move(b);
305              });
306              global.insertUrls = strLine;
307              eraseElements(tempArray);
308          }
309      }
310      section[&quot;prepend_insert_url&quot;] &gt;&gt; global.prependInsert;
311      if(section[&quot;exclude_remarks&quot;].IsSequence())
312          section[&quot;exclude_remarks&quot;] &gt;&gt; global.excludeRemarks;
313      if(section[&quot;include_remarks&quot;].IsSequence())
314          section[&quot;include_remarks&quot;] &gt;&gt; global.includeRemarks;
315      global.filterScript = safe_as&lt;bool&gt;(section[&quot;enable_filter&quot;]) ? safe_as&lt;std::string&gt;(section[&quot;filter_script&quot;]) : &quot;&quot;;
316      section[&quot;base_path&quot;] &gt;&gt; global.basePath;
317      section[&quot;clash_rule_base&quot;] &gt;&gt; global.clashBase;
318      section[&quot;surge_rule_base&quot;] &gt;&gt; global.surgeBase;
319      section[&quot;surfboard_rule_base&quot;] &gt;&gt; global.surfboardBase;
320      section[&quot;mellow_rule_base&quot;] &gt;&gt; global.mellowBase;
321      section[&quot;quan_rule_base&quot;] &gt;&gt; global.quanBase;
322      section[&quot;quanx_rule_base&quot;] &gt;&gt; global.quanXBase;
323      section[&quot;loon_rule_base&quot;] &gt;&gt; global.loonBase;
324      section[&quot;sssub_rule_base&quot;] &gt;&gt; global.SSSubBase;
325      section[&quot;default_external_config&quot;] &gt;&gt; global.defaultExtConfig;
326      section[&quot;append_proxy_type&quot;] &gt;&gt; global.appendType;
327      section[&quot;proxy_config&quot;] &gt;&gt; global.proxyConfig;
328      section[&quot;proxy_ruleset&quot;] &gt;&gt; global.proxyRuleset;
329      section[&quot;proxy_subscription&quot;] &gt;&gt; global.proxySubscription;
330      if(node[&quot;userinfo&quot;].IsDefined())
331      {
332          section = node[&quot;userinfo&quot;];
333          if(section[&quot;stream_rule&quot;].IsSequence())
334          {
335              readRegexMatch(section[&quot;stream_rule&quot;], &quot;|&quot;, tempArray, false);
336              auto configs = INIBinding::from&lt;RegexMatchConfig&gt;::from_ini(tempArray, &quot;|&quot;);
337              safe_set_streams(configs);
338              eraseElements(tempArray);
339          }
340          if(section[&quot;time_rule&quot;].IsSequence())
341          {
342              readRegexMatch(section[&quot;time_rule&quot;], &quot;|&quot;, tempArray, false);
343              auto configs = INIBinding::from&lt;RegexMatchConfig&gt;::from_ini(tempArray, &quot;|&quot;);
344              safe_set_times(configs);
345              eraseElements(tempArray);
346          }
347      }
348      if(node[&quot;node_pref&quot;].IsDefined())
349      {
350          section = node[&quot;node_pref&quot;];
351          global.UDPFlag.set(safe_as&lt;std::string&gt;(section[&quot;udp_flag&quot;]));
352          global.TFOFlag.set(safe_as&lt;std::string&gt;(section[&quot;tcp_fast_open_flag&quot;]));
353          global.skipCertVerify.set(safe_as&lt;std::string&gt;(section[&quot;skip_cert_verify_flag&quot;]));
354          global.TLS13Flag.set(safe_as&lt;std::string&gt;(section[&quot;tls13_flag&quot;]));
355          section[&quot;sort_flag&quot;] &gt;&gt; global.enableSort;
356          section[&quot;sort_script&quot;] &gt;&gt; global.sortScript;
357          section[&quot;filter_deprecated_nodes&quot;] &gt;&gt; global.filterDeprecated;
358          section[&quot;append_sub_userinfo&quot;] &gt;&gt; global.appendUserinfo;
359          section[&quot;clash_use_new_field_name&quot;] &gt;&gt; global.clashUseNewField;
360          section[&quot;clash_proxies_style&quot;] &gt;&gt; global.clashProxiesStyle;
361      }
362      if(section[&quot;rename_node&quot;].IsSequence())
363      {
364          readRegexMatch(section[&quot;rename_node&quot;], &quot;@&quot;, tempArray, false);
365          auto configs = INIBinding::from&lt;RegexMatchConfig&gt;::from_ini(tempArray, &quot;@&quot;);
366          safe_set_renames(configs);
367          eraseElements(tempArray);
368      }
369      if(node[&quot;managed_config&quot;].IsDefined())
370      {
371          section = node[&quot;managed_config&quot;];
372          section[&quot;write_managed_config&quot;] &gt;&gt; global.writeManagedConfig;
373          section[&quot;managed_config_prefix&quot;] &gt;&gt; global.managedConfigPrefix;
374          section[&quot;config_update_interval&quot;] &gt;&gt; global.updateInterval;
375          section[&quot;config_update_strict&quot;] &gt;&gt; global.updateStrict;
376          section[&quot;quanx_device_id&quot;] &gt;&gt; global.quanXDevID;
377      }
378      if(node[&quot;surge_external_proxy&quot;].IsDefined())
379      {
380          node[&quot;surge_external_proxy&quot;][&quot;surge_ssr_path&quot;] &gt;&gt; global.surgeSSRPath;
381          node[&quot;surge_external_proxy&quot;][&quot;resolve_hostname&quot;] &gt;&gt; global.surgeResolveHostname;
382      }
383      if(node[&quot;emojis&quot;].IsDefined())
384      {
385          section = node[&quot;emojis&quot;];
386          section[&quot;add_emoji&quot;] &gt;&gt; global.addEmoji;
387          section[&quot;remove_old_emoji&quot;] &gt;&gt; global.removeEmoji;
388          if(section[&quot;rules&quot;].IsSequence())
389          {
390              readEmoji(section[&quot;rules&quot;], tempArray, false);
391              auto configs = INIBinding::from&lt;RegexMatchConfig&gt;::from_ini(tempArray, &quot;,&quot;);
392              safe_set_emojis(configs);
393              eraseElements(tempArray);
394          }
395      }
396      const char *rulesets_title = node[&quot;rulesets&quot;].IsDefined() ? &quot;rulesets&quot; : &quot;ruleset&quot;;
397      if(node[rulesets_title].IsDefined())
398      {
399          section = node[rulesets_title];
400          section[&quot;enabled&quot;] &gt;&gt; global.enableRuleGen;
401          if(!global.enableRuleGen)
402          {
403              global.overwriteOriginalRules = false;
404              global.updateRulesetOnRequest = false;
405          }
406          else
407          {
408              section[&quot;overwrite_original_rules&quot;] &gt;&gt; global.overwriteOriginalRules;
409              section[&quot;update_ruleset_on_request&quot;] &gt;&gt; global.updateRulesetOnRequest;
410          }
411          const char *ruleset_title = section[&quot;rulesets&quot;].IsDefined() ? &quot;rulesets&quot; : &quot;surge_ruleset&quot;;
412          if(section[ruleset_title].IsSequence())
413          {
414              string_array vArray;
415              readRuleset(section[ruleset_title], vArray, false);
416              global.customRulesets = INIBinding::from&lt;RulesetConfig&gt;::from_ini(vArray);
417          }
418      }
419      const char *groups_title = node[&quot;proxy_groups&quot;].IsDefined() ? &quot;proxy_groups&quot; : &quot;proxy_group&quot;;
420      if(node[groups_title].IsDefined() &amp;&amp; node[groups_title][&quot;custom_proxy_group&quot;].IsDefined())
421      {
422          string_array vArray;
423          readGroup(node[groups_title][&quot;custom_proxy_group&quot;], vArray, false);
424          global.customProxyGroups = INIBinding::from&lt;ProxyGroupConfig&gt;::from_ini(vArray);
425      }
426      if(node[&quot;template&quot;].IsDefined())
427      {
428          node[&quot;template&quot;][&quot;template_path&quot;] &gt;&gt; global.templatePath;
429          if(node[&quot;template&quot;][&quot;globals&quot;].IsSequence())
430          {
431              eraseElements(global.templateVars);
432              for(size_t i = 0; i &lt; node[&quot;template&quot;][&quot;globals&quot;].size(); i++)
433              {
434                  std::string key, value;
435                  node[&quot;template&quot;][&quot;globals&quot;][i][&quot;key&quot;] &gt;&gt; key;
436                  node[&quot;template&quot;][&quot;globals&quot;][i][&quot;value&quot;] &gt;&gt; value;
437                  global.templateVars[key] = value;
438              }
439          }
440      }
441      if(node[&quot;aliases&quot;].IsSequence())
442      {
443          webServer.reset_redirect();
444          for(size_t i = 0; i &lt; node[&quot;aliases&quot;].size(); i++)
445          {
446              std::string uri, target;
447              node[&quot;aliases&quot;][i][&quot;uri&quot;] &gt;&gt; uri;
448              node[&quot;aliases&quot;][i][&quot;target&quot;] &gt;&gt; target;
449              webServer.append_redirect(uri, target);
450          }
451      }
452      if(node[&quot;tasks&quot;].IsSequence())
453      {
454          string_array vArray;
455          for(size_t i = 0; i &lt; node[&quot;tasks&quot;].size(); i++)
456          {
457              std::string name, exp, path, timeout;
458              node[&quot;tasks&quot;][i][&quot;import&quot;] &gt;&gt; name;
459              if(name.size())
460              {
461                  vArray.emplace_back(&quot;!!import:&quot; + name);
462                  continue;
463              }
464              node[&quot;tasks&quot;][i][&quot;name&quot;] &gt;&gt; name;
465              node[&quot;tasks&quot;][i][&quot;cronexp&quot;] &gt;&gt; exp;
466              node[&quot;tasks&quot;][i][&quot;path&quot;] &gt;&gt; path;
467              node[&quot;tasks&quot;][i][&quot;timeout&quot;] &gt;&gt; timeout;
468              strLine = name + &quot;`&quot; + exp + &quot;`&quot; + path + &quot;`&quot; + timeout;
469              vArray.emplace_back(std::move(strLine));
470          }
471          importItems(vArray, false);
472          global.enableCron = !vArray.empty();
473          global.cronTasks = INIBinding::from&lt;CronTaskConfig&gt;::from_ini(vArray);
474          refresh_schedule();
475      }
476      if(node[&quot;server&quot;].IsDefined())
477      {
478          node[&quot;server&quot;][&quot;listen&quot;] &gt;&gt; global.listenAddress;
479          node[&quot;server&quot;][&quot;port&quot;] &gt;&gt; global.listenPort;
480          node[&quot;server&quot;][&quot;serve_file_root&quot;] &gt;&gt;= webServer.serve_file_root;
481          webServer.serve_file = !webServer.serve_file_root.empty();
482      }
483      if(node[&quot;advanced&quot;].IsDefined())
484      {
485          std::string log_level;
486          node[&quot;advanced&quot;][&quot;log_level&quot;] &gt;&gt; log_level;
487          node[&quot;advanced&quot;][&quot;print_debug_info&quot;] &gt;&gt; global.printDbgInfo;
488          if(global.printDbgInfo)
489              global.logLevel = LOG_LEVEL_VERBOSE;
490          else
491          {
492              switch(hash_(log_level))
493              {
494              case &quot;warn&quot;_hash:
495                  global.logLevel = LOG_LEVEL_WARNING;
496                  break;
497              case &quot;error&quot;_hash:
498                  global.logLevel = LOG_LEVEL_ERROR;
499                  break;
500              case &quot;fatal&quot;_hash:
501                  global.logLevel = LOG_LEVEL_FATAL;
502                  break;
503              case &quot;verbose&quot;_hash:
504                  global.logLevel = LOG_LEVEL_VERBOSE;
505                  break;
506              case &quot;debug&quot;_hash:
507                  global.logLevel = LOG_LEVEL_DEBUG;
508                  break;
509              default:
510                  global.logLevel = LOG_LEVEL_INFO;
511              }
512          }
513          node[&quot;advanced&quot;][&quot;max_pending_connections&quot;] &gt;&gt; global.maxPendingConns;
514          node[&quot;advanced&quot;][&quot;max_concurrent_threads&quot;] &gt;&gt; global.maxConcurThreads;
515          node[&quot;advanced&quot;][&quot;max_allowed_rulesets&quot;] &gt;&gt; global.maxAllowedRulesets;
516          node[&quot;advanced&quot;][&quot;max_allowed_rules&quot;] &gt;&gt; global.maxAllowedRules;
517          node[&quot;advanced&quot;][&quot;max_allowed_download_size&quot;] &gt;&gt; global.maxAllowedDownloadSize;
518          if(node[&quot;advanced&quot;][&quot;enable_cache&quot;].IsDefined())
519          {
520              if(safe_as&lt;bool&gt;(node[&quot;advanced&quot;][&quot;enable_cache&quot;]))
521              {
522                  node[&quot;advanced&quot;][&quot;cache_subscription&quot;] &gt;&gt; global.cacheSubscription;
523                  node[&quot;advanced&quot;][&quot;cache_config&quot;] &gt;&gt; global.cacheConfig;
524                  node[&quot;advanced&quot;][&quot;cache_ruleset&quot;] &gt;&gt; global.cacheRuleset;
525                  node[&quot;advanced&quot;][&quot;serve_cache_on_fetch_fail&quot;] &gt;&gt; global.serveCacheOnFetchFail;
526              }
527              else
528                  global.cacheSubscription = global.cacheConfig = global.cacheRuleset = 0; 
529          }
530          node[&quot;advanced&quot;][&quot;script_clean_context&quot;] &gt;&gt; global.scriptCleanContext;
531          node[&quot;advanced&quot;][&quot;async_fetch_ruleset&quot;] &gt;&gt; global.asyncFetchRuleset;
532          node[&quot;advanced&quot;][&quot;skip_failed_links&quot;] &gt;&gt; global.skipFailedLinks;
533      }
534      writeLog(0, &quot;Load preference settings in YAML format completed.&quot;, LOG_LEVEL_INFO);
535  }
536  template &lt;class T, class... U&gt;
537  void find_if_exist(const toml::value &amp;v, const toml::key &amp;k, T&amp; target, U&amp;&amp;... args)
538  {
539      if(v.contains(k)) target = toml::find&lt;T&gt;(v, k);
540      if constexpr (sizeof...(args) &gt; 0) find_if_exist(v, std::forward&lt;U&gt;(args)...);
541  }
542  void operate_toml_kv_table(const std::vector&lt;toml::table&gt; &amp;arr, const toml::key &amp;key_name, const toml::key &amp;value_name, std::function&lt;void (const toml::value&amp;, const toml::value&amp;)&gt; binary_op)
543  {
544      for(const toml::table &amp;table : arr)
545      {
546          const auto &amp;key = table.at(key_name), value = table.at(value_name);
547          binary_op(key, value);
548      }
549  }
550  void readTOMLConf(toml::value &amp;root)
551  {
552      const auto &amp;section_common = toml::find(root, &quot;common&quot;);
553      string_array default_url, insert_url;
554      find_if_exist(section_common, &quot;default_url&quot;, default_url, &quot;insert_url&quot;, insert_url);
555      global.defaultUrls = join(default_url, &quot;|&quot;);
556      global.insertUrls = join(insert_url, &quot;|&quot;);
557      bool filter = false;
558      find_if_exist(section_common,
559                    &quot;api_mode&quot;, global.APIMode,
560                    &quot;api_access_token&quot;, global.accessToken,
561                    &quot;exclude_remarks&quot;, global.excludeRemarks,
562                    &quot;include_remarks&quot;, global.includeRemarks,
563                    &quot;enable_insert&quot;, global.enableInsert,
564                    &quot;prepend_insert_url&quot;, global.prependInsert,
565                    &quot;enable_filter&quot;, filter,
566                    &quot;default_external_config&quot;, global.defaultExtConfig,
567                    &quot;base_path&quot;, global.basePath,
568                    &quot;clash_rule_base&quot;, global.clashBase,
569                    &quot;surge_rule_base&quot;, global.surgeBase,
570                    &quot;surfboard_rule_base&quot;, global.surfboardBase,
571                    &quot;mellow_rule_base&quot;, global.mellowBase,
572                    &quot;quan_rule_base&quot;, global.quanBase,
573                    &quot;quanx_rule_base&quot;, global.quanXBase,
574                    &quot;loon_rule_base&quot;, global.loonBase,
575                    &quot;proxy_config&quot;, global.proxyConfig,
576                    &quot;proxy_ruleset&quot;, global.proxyRuleset,
577                    &quot;proxy_subscription&quot;, global.proxySubscription,
578                    &quot;append_proxy_type&quot;, global.appendType
579      );
580      if(filter)
581          find_if_exist(section_common, &quot;filter_script&quot;, global.filterScript);
582      else
583          global.filterScript.clear();
584      safe_set_streams(toml::find_or&lt;RegexMatchConfigs&gt;(root, &quot;userinfo&quot;, &quot;stream_rule&quot;, RegexMatchConfigs{}));
585      safe_set_times(toml::find_or&lt;RegexMatchConfigs&gt;(root, &quot;userinfo&quot;, &quot;time_rule&quot;, RegexMatchConfigs{}));
586      const auto &amp;section_node_pref = toml::find(root, &quot;node_pref&quot;);
587      find_if_exist(section_node_pref,
588                    &quot;udp_flag&quot;, global.UDPFlag,
589                    &quot;tcp_fast_open_flag&quot;, global.TFOFlag,
590                    &quot;skip_cert_verify_flag&quot;, global.skipCertVerify,
591                    &quot;tls13_flag&quot;, global.TLS13Flag,
592                    &quot;sort_flag&quot;, global.enableSort,
593                    &quot;sort_script&quot;, global.sortScript,
594                    &quot;filter_deprecated_nodes&quot;, global.filterDeprecated,
595                    &quot;append_sub_userinfo&quot;, global.appendUserinfo,
596                    &quot;clash_use_new_field_name&quot;, global.clashUseNewField,
597                    &quot;clash_proxies_style&quot;, global.clashProxiesStyle
598      );
599      auto renameconfs = toml::find_or&lt;std::vector&lt;toml::value&gt;&gt;(section_node_pref, &quot;rename_node&quot;, {});
600      importItems(renameconfs, &quot;rename_node&quot;, false);
601      safe_set_renames(toml::get&lt;RegexMatchConfigs&gt;(toml::value(renameconfs)));
602      const auto &amp;section_managed = toml::find(root, &quot;managed_config&quot;);
603      find_if_exist(section_managed,
604                    &quot;write_managed_config&quot;, global.writeManagedConfig,
605                    &quot;managed_config_prefix&quot;, global.managedConfigPrefix,
606                    &quot;config_update_interval&quot;, global.updateInterval,
607                    &quot;config_update_strict&quot;, global.updateStrict,
608                    &quot;quanx_device_id&quot;, global.quanXDevID
609      );
610      const auto &amp;section_surge_external = toml::find(root, &quot;surge_external_proxy&quot;);
611      find_if_exist(section_surge_external,
612                    &quot;surge_ssr_path&quot;, global.surgeSSRPath,
613                    &quot;resolve_hostname&quot;, global.surgeResolveHostname
614      );
615      const auto &amp;section_emojis = toml::find(root, &quot;emojis&quot;);
616      find_if_exist(section_emojis,
617                    &quot;add_emoji&quot;, global.addEmoji,
618                    &quot;remove_old_emoji&quot;, global.removeEmoji
619      );
620      auto emojiconfs = toml::find_or&lt;std::vector&lt;toml::value&gt;&gt;(section_emojis, &quot;emoji&quot;, {});
621      importItems(emojiconfs, &quot;emoji&quot;, false);
622      safe_set_emojis(toml::get&lt;RegexMatchConfigs&gt;(toml::value(emojiconfs)));
623      auto groups = toml::find_or&lt;std::vector&lt;toml::value&gt;&gt;(root, &quot;custom_groups&quot;, {});
624      importItems(groups, &quot;custom_groups&quot;, false);
625      global.customProxyGroups = toml::get&lt;ProxyGroupConfigs&gt;(toml::value(groups));
626      const auto &amp;section_ruleset = toml::find(root, &quot;ruleset&quot;);
627      find_if_exist(section_ruleset,
628                    &quot;enabled&quot;, global.enableRuleGen,
629                    &quot;overwrite_original_rules&quot;, global.overwriteOriginalRules,
630                    &quot;update_ruleset_on_request&quot;, global.updateRulesetOnRequest
631      );
632      auto rulesets = toml::find_or&lt;std::vector&lt;toml::value&gt;&gt;(root, &quot;rulesets&quot;, {});
633      importItems(rulesets, &quot;rulesets&quot;, false);
634      global.customRulesets = toml::get&lt;RulesetConfigs&gt;(toml::value(rulesets));
635      const auto &amp;section_template = toml::find(root, &quot;template&quot;);
636      global.templatePath = toml::find_or(section_template, &quot;template_path&quot;, &quot;template&quot;);
637      eraseElements(global.templateVars);
638      operate_toml_kv_table(toml::find_or&lt;std::vector&lt;toml::table&gt;&gt;(section_template, &quot;globals&quot;, {}), &quot;key&quot;, &quot;value&quot;, [&amp;](const toml::value &amp;key, const toml::value &amp;value)
639      {
640          global.templateVars[key.as_string()] = value.as_string();
641      });
642      webServer.reset_redirect();
643      operate_toml_kv_table(toml::find_or&lt;std::vector&lt;toml::table&gt;&gt;(root, &quot;aliases&quot;, {}), &quot;uri&quot;, &quot;target&quot;, [&amp;](const toml::value &amp;key, const toml::value &amp;value)
644      {
645          webServer.append_redirect(key.as_string(), value.as_string());
646      });
647      auto tasks = toml::find_or&lt;std::vector&lt;toml::value&gt;&gt;(root, &quot;tasks&quot;, {});
648      importItems(tasks, &quot;tasks&quot;, false);
649      global.cronTasks = toml::get&lt;CronTaskConfigs&gt;(toml::value(tasks));
650      const auto &amp;section_server = toml::find(root, &quot;server&quot;);
651      find_if_exist(section_server,
652                    &quot;listen&quot;, global.listenAddress,
653                    &quot;port&quot;, global.listenPort,
654                    &quot;serve_file_root&quot;, webServer.serve_file_root
655      );
656      webServer.serve_file = !webServer.serve_file_root.empty();
657      const auto &amp;section_advanced = toml::find(root, &quot;advanced&quot;);
658      std::string log_level;
659      bool enable_cache = true;
660      int cache_subscription = global.cacheSubscription, cache_config = global.cacheConfig, cache_ruleset = global.cacheRuleset;
661      find_if_exist(section_advanced,
662                    &quot;log_level&quot;, log_level,
663                    &quot;print_debug_info&quot;, global.printDbgInfo,
664                    &quot;max_pending_connections&quot;, global.maxPendingConns,
665                    &quot;max_concurrent_threads&quot;, global.maxConcurThreads,
666                    &quot;max_allowed_rulesets&quot;, global.maxAllowedRulesets,
667                    &quot;max_allowed_rules&quot;, global.maxAllowedRules,
668                    &quot;max_allowed_download_size&quot;, global.maxAllowedDownloadSize,
669                    &quot;enable_cache&quot;, enable_cache,
670                    &quot;cache_subscription&quot;, cache_subscription,
671                    &quot;cache_config&quot;, cache_config,
672                    &quot;cache_ruleset&quot;, cache_ruleset,
673                    &quot;script_clean_context&quot;, global.scriptCleanContext,
674                    &quot;async_fetch_ruleset&quot;, global.asyncFetchRuleset,
675                    &quot;skip_failed_links&quot;, global.skipFailedLinks
676      );
677      if(global.printDbgInfo)
678          global.logLevel = LOG_LEVEL_VERBOSE;
679      else
680      {
681          switch(hash_(log_level))
682          {
683          case &quot;warn&quot;_hash:
684              global.logLevel = LOG_LEVEL_WARNING;
685              break;
686          case &quot;error&quot;_hash:
687              global.logLevel = LOG_LEVEL_ERROR;
688              break;
689          case &quot;fatal&quot;_hash:
690              global.logLevel = LOG_LEVEL_FATAL;
691              break;
692          case &quot;verbose&quot;_hash:
693              global.logLevel = LOG_LEVEL_VERBOSE;
694              break;
695          case &quot;debug&quot;_hash:
696              global.logLevel = LOG_LEVEL_DEBUG;
697              break;
698          default:
699              global.logLevel = LOG_LEVEL_INFO;
700          }
701      }
702      if(enable_cache)
703      {
704          global.cacheSubscription = cache_subscription;
705          global.cacheConfig = cache_config;
706          global.cacheRuleset = cache_ruleset;
707      }
708      else
709      {
710          global.cacheSubscription = global.cacheConfig = global.cacheRuleset = 0;
711      }
712      writeLog(0, &quot;Load preference settings in TOML format completed.&quot;, LOG_LEVEL_INFO);
713  }
714  void readConf()
715  {
716      guarded_mutex guard(gMutexConfigure);
717      writeLog(0, &quot;Loading preference settings...&quot;, LOG_LEVEL_INFO);
718      eraseElements(global.excludeRemarks);
719      eraseElements(global.includeRemarks);
720      eraseElements(global.customProxyGroups);
721      eraseElements(global.customRulesets);
722      try
723      {
724          std::string prefdata = fileGet(global.prefPath, false);
725          if(prefdata.find(&quot;common:&quot;) != prefdata.npos)
726          {
727              YAML::Node yaml = YAML::Load(prefdata);
728              if(yaml.size() &amp;&amp; yaml[&quot;common&quot;])
729                  return readYAMLConf(yaml);
730          }
731          toml::value conf = parseToml(prefdata, global.prefPath);
732          if(!conf.is_uninitialized() &amp;&amp; toml::find_or&lt;int&gt;(conf, &quot;version&quot;, 0))
733              return readTOMLConf(conf);
734      }
735      catch (YAML::Exception &amp;e)
736      {
737          writeLog(0, e.what(), LOG_LEVEL_DEBUG);
738          writeLog(0, &quot;Unable to load preference settings as YAML.&quot;, LOG_LEVEL_DEBUG);
739      }
740      catch (toml::exception &amp;e)
741      {
742          writeLog(0, e.what(), LOG_LEVEL_DEBUG);
743          writeLog(0, &quot;Unable to load preference settings as TOML.&quot;, LOG_LEVEL_DEBUG);
744      }
745      INIReader ini;
746      ini.allow_dup_section_titles = true;
747      int retVal = ini.ParseFile(global.prefPath);
748      if(retVal != INIREADER_EXCEPTION_NONE)
749      {
750          writeLog(0, &quot;Unable to load preference settings as INI. Reason: &quot; + ini.GetLastError(), LOG_LEVEL_FATAL);
751          return;
752      }
753      string_array tempArray;
754      ini.EnterSection(&quot;common&quot;);
755      ini.GetBoolIfExist(&quot;api_mode&quot;, global.APIMode);
756      ini.GetIfExist(&quot;api_access_token&quot;, global.accessToken);
757      ini.GetIfExist(&quot;default_url&quot;, global.defaultUrls);
758      global.enableInsert = ini.Get(&quot;enable_insert&quot;);
759      ini.GetIfExist(&quot;insert_url&quot;, global.insertUrls);
760      ini.GetBoolIfExist(&quot;prepend_insert_url&quot;, global.prependInsert);
761      if(ini.ItemPrefixExist(&quot;exclude_remarks&quot;))
762          ini.GetAll(&quot;exclude_remarks&quot;, global.excludeRemarks);
763      if(ini.ItemPrefixExist(&quot;include_remarks&quot;))
764          ini.GetAll(&quot;include_remarks&quot;, global.includeRemarks);
765      global.filterScript = ini.GetBool(&quot;enable_filter&quot;) ? ini.Get(&quot;filter_script&quot;): &quot;&quot;;
766      ini.GetIfExist(&quot;base_path&quot;, global.basePath);
767      ini.GetIfExist(&quot;clash_rule_base&quot;, global.clashBase);
768      ini.GetIfExist(&quot;surge_rule_base&quot;, global.surgeBase);
769      ini.GetIfExist(&quot;surfboard_rule_base&quot;, global.surfboardBase);
770      ini.GetIfExist(&quot;mellow_rule_base&quot;, global.mellowBase);
771      ini.GetIfExist(&quot;quan_rule_base&quot;, global.quanBase);
772      ini.GetIfExist(&quot;quanx_rule_base&quot;, global.quanXBase);
773      ini.GetIfExist(&quot;loon_rule_base&quot;, global.loonBase);
774      ini.GetIfExist(&quot;default_external_config&quot;, global.defaultExtConfig);
775      ini.GetBoolIfExist(&quot;append_proxy_type&quot;, global.appendType);
776      ini.GetIfExist(&quot;proxy_config&quot;, global.proxyConfig);
777      ini.GetIfExist(&quot;proxy_ruleset&quot;, global.proxyRuleset);
778      ini.GetIfExist(&quot;proxy_subscription&quot;, global.proxySubscription);
779      if(ini.SectionExist(&quot;surge_external_proxy&quot;))
780      {
781          ini.EnterSection(&quot;surge_external_proxy&quot;);
782          ini.GetIfExist(&quot;surge_ssr_path&quot;, global.surgeSSRPath);
783          ini.GetBoolIfExist(&quot;resolve_hostname&quot;, global.surgeResolveHostname);
784      }
785      if(ini.SectionExist(&quot;node_pref&quot;))
786      {
787          ini.EnterSection(&quot;node_pref&quot;);
788          global.UDPFlag.set(ini.Get(&quot;udp_flag&quot;));
789          global.TFOFlag.set(ini.Get(&quot;tcp_fast_open_flag&quot;));
790          global.skipCertVerify.set(ini.Get(&quot;skip_cert_verify_flag&quot;));
791          global.TLS13Flag.set(ini.Get(&quot;tls13_flag&quot;));
792          ini.GetBoolIfExist(&quot;sort_flag&quot;, global.enableSort);
793          global.sortScript = ini.Get(&quot;sort_script&quot;);
794          ini.GetBoolIfExist(&quot;filter_deprecated_nodes&quot;, global.filterDeprecated);
795          ini.GetBoolIfExist(&quot;append_sub_userinfo&quot;, global.appendUserinfo);
796          ini.GetBoolIfExist(&quot;clash_use_new_field_name&quot;, global.clashUseNewField);
797          ini.GetIfExist(&quot;clash_proxies_style&quot;, global.clashProxiesStyle);
798          if(ini.ItemPrefixExist(&quot;rename_node&quot;))
799          {
800              ini.GetAll(&quot;rename_node&quot;, tempArray);
801              importItems(tempArray, false);
802              auto configs = INIBinding::from&lt;RegexMatchConfig&gt;::from_ini(tempArray, &quot;@&quot;);
803              safe_set_renames(configs);
804              eraseElements(tempArray);
805          }
806      }
807      if(ini.SectionExist(&quot;userinfo&quot;))
808      {
809          ini.EnterSection(&quot;userinfo&quot;);
810          if(ini.ItemPrefixExist(&quot;stream_rule&quot;))
811          {
812              ini.GetAll(&quot;stream_rule&quot;, tempArray);
813              importItems(tempArray, false);
814              auto configs = INIBinding::from&lt;RegexMatchConfig&gt;::from_ini(tempArray, &quot;|&quot;);
815              safe_set_streams(configs);
816              eraseElements(tempArray);
817          }
818          if(ini.ItemPrefixExist(&quot;time_rule&quot;))
819          {
820              ini.GetAll(&quot;time_rule&quot;, tempArray);
821              importItems(tempArray, false);
822              auto configs = INIBinding::from&lt;RegexMatchConfig&gt;::from_ini(tempArray, &quot;|&quot;);
823              safe_set_times(configs);
824              eraseElements(tempArray);
825          }
826      }
827      ini.EnterSection(&quot;managed_config&quot;);
828      ini.GetBoolIfExist(&quot;write_managed_config&quot;, global.writeManagedConfig);
829      ini.GetIfExist(&quot;managed_config_prefix&quot;, global.managedConfigPrefix);
830      ini.GetIntIfExist(&quot;config_update_interval&quot;, global.updateInterval);
831      ini.GetBoolIfExist(&quot;config_update_strict&quot;, global.updateStrict);
832      ini.GetIfExist(&quot;quanx_device_id&quot;, global.quanXDevID);
833      ini.EnterSection(&quot;emojis&quot;);
834      ini.GetBoolIfExist(&quot;add_emoji&quot;, global.addEmoji);
835      ini.GetBoolIfExist(&quot;remove_old_emoji&quot;, global.removeEmoji);
836      if(ini.ItemPrefixExist(&quot;rule&quot;))
837      {
838          ini.GetAll(&quot;rule&quot;, tempArray);
839          importItems(tempArray, false);
840          auto configs = INIBinding::from&lt;RegexMatchConfig&gt;::from_ini(tempArray, &quot;,&quot;);
841          safe_set_emojis(configs);
842          eraseElements(tempArray);
843      }
844      if(ini.SectionExist(&quot;rulesets&quot;))
845          ini.EnterSection(&quot;rulesets&quot;);
846      else
847          ini.EnterSection(&quot;ruleset&quot;);
848      global.enableRuleGen = ini.GetBool(&quot;enabled&quot;);
849      if(global.enableRuleGen)
850      {
851          ini.GetBoolIfExist(&quot;overwrite_original_rules&quot;, global.overwriteOriginalRules);
852          ini.GetBoolIfExist(&quot;update_ruleset_on_request&quot;, global.updateRulesetOnRequest);
853          if(ini.ItemPrefixExist(&quot;ruleset&quot;))
854          {
855              string_array vArray;
856              ini.GetAll(&quot;ruleset&quot;, vArray);
857              importItems(vArray, false);
858              global.customRulesets = INIBinding::from&lt;RulesetConfig&gt;::from_ini(vArray);
859          }
860          else if(ini.ItemPrefixExist(&quot;surge_ruleset&quot;))
861          {
862              string_array vArray;
863              ini.GetAll(&quot;surge_ruleset&quot;, vArray);
864              importItems(vArray, false);
865              global.customRulesets = INIBinding::from&lt;RulesetConfig&gt;::from_ini(vArray);
866          }
867      }
868      else
869      {
870          global.overwriteOriginalRules = false;
871          global.updateRulesetOnRequest = false;
872      }
873      if(ini.SectionExist(&quot;proxy_groups&quot;))
874          ini.EnterSection(&quot;proxy_groups&quot;);
875      else
876          ini.EnterSection(&quot;clash_proxy_group&quot;);
877      if(ini.ItemPrefixExist(&quot;custom_proxy_group&quot;))
878      {
879          string_array vArray;
880          ini.GetAll(&quot;custom_proxy_group&quot;, vArray);
881          importItems(vArray, false);
882          global.customProxyGroups = INIBinding::from&lt;ProxyGroupConfig&gt;::from_ini(vArray);
883      }
884      ini.EnterSection(&quot;template&quot;);
885      ini.GetIfExist(&quot;template_path&quot;, global.templatePath);
886      string_multimap tempmap;
887      ini.GetItems(tempmap);
888      eraseElements(global.templateVars);
889      for(auto &amp;x : tempmap)
890      {
891          if(x.first == &quot;template_path&quot;)
892              continue;
893          global.templateVars[x.first] = x.second;
894      }
895      global.templateVars[&quot;managed_config_prefix&quot;] = global.managedConfigPrefix;
896      if(ini.SectionExist(&quot;aliases&quot;))
897      {
898          ini.EnterSection(&quot;aliases&quot;);
899          ini.GetItems(tempmap);
900          webServer.reset_redirect();
901          for(auto &amp;x : tempmap)
902              webServer.append_redirect(x.first, x.second);
903      }
904      if(ini.SectionExist(&quot;tasks&quot;))
905      {
906          string_array vArray;
907          ini.EnterSection(&quot;tasks&quot;);
908          ini.GetAll(&quot;task&quot;, vArray);
909          importItems(vArray, false);
910          global.enableCron = !vArray.empty();
911          global.cronTasks = INIBinding::from&lt;CronTaskConfig&gt;::from_ini(vArray);
912          refresh_schedule();
913      }
914      ini.EnterSection(&quot;server&quot;);
915      ini.GetIfExist(&quot;listen&quot;, global.listenAddress);
916      ini.GetIntIfExist(&quot;port&quot;, global.listenPort);
917      webServer.serve_file_root = ini.Get(&quot;serve_file_root&quot;);
918      webServer.serve_file = !webServer.serve_file_root.empty();
919      ini.EnterSection(&quot;advanced&quot;);
920      std::string log_level;
921      ini.GetIfExist(&quot;log_level&quot;, log_level);
922      ini.GetBoolIfExist(&quot;print_debug_info&quot;, global.printDbgInfo);
923      if(global.printDbgInfo)
924          global.logLevel = LOG_LEVEL_VERBOSE;
925      else
926      {
927          switch(hash_(log_level))
928          {
929          case &quot;warn&quot;_hash:
930              global.logLevel = LOG_LEVEL_WARNING;
931              break;
932          case &quot;error&quot;_hash:
933              global.logLevel = LOG_LEVEL_ERROR;
934              break;
935          case &quot;fatal&quot;_hash:
936              global.logLevel = LOG_LEVEL_FATAL;
937              break;
938          case &quot;verbose&quot;_hash:
939              global.logLevel = LOG_LEVEL_VERBOSE;
940              break;
941          case &quot;debug&quot;_hash:
942              global.logLevel = LOG_LEVEL_DEBUG;
943              break;
944          default:
945              global.logLevel = LOG_LEVEL_INFO;
946          }
947      }
948      ini.GetIntIfExist(&quot;max_pending_connections&quot;, global.maxPendingConns);
949      ini.GetIntIfExist(&quot;max_concurrent_threads&quot;, global.maxConcurThreads);
950      ini.GetNumberIfExist(&quot;max_allowed_rulesets&quot;, global.maxAllowedRulesets);
951      ini.GetNumberIfExist(&quot;max_allowed_rules&quot;, global.maxAllowedRules);
952      ini.GetNumberIfExist(&quot;max_allowed_download_size&quot;, global.maxAllowedDownloadSize);
953      if(ini.ItemExist(&quot;enable_cache&quot;))
954      {
955          if(ini.GetBool(&quot;enable_cache&quot;))
956          {
957              ini.GetIntIfExist(&quot;cache_subscription&quot;, global.cacheSubscription);
958              ini.GetIntIfExist(&quot;cache_config&quot;, global.cacheConfig);
959              ini.GetIntIfExist(&quot;cache_ruleset&quot;, global.cacheRuleset);
960              ini.GetBoolIfExist(&quot;serve_cache_on_fetch_fail&quot;, global.serveCacheOnFetchFail);
961          }
962          else
963          {
964              global.cacheSubscription = global.cacheConfig = global.cacheRuleset = 0; 
965              global.serveCacheOnFetchFail = false;
966          }
967      }
968      ini.GetBoolIfExist(&quot;script_clean_context&quot;, global.scriptCleanContext);
969      ini.GetBoolIfExist(&quot;async_fetch_ruleset&quot;, global.asyncFetchRuleset);
970      ini.GetBoolIfExist(&quot;skip_failed_links&quot;, global.skipFailedLinks);
971      writeLog(0, &quot;Load preference settings in INI format completed.&quot;, LOG_LEVEL_INFO);
972  }
973  int loadExternalYAML(YAML::Node &amp;node, ExternalConfig &amp;ext)
974  {
975      YAML::Node section = node[&quot;custom&quot;], object;
976      std::string name, type, url, interval;
977      std::string group, strLine;
978      section[&quot;clash_rule_base&quot;] &gt;&gt; ext.clash_rule_base;
979      section[&quot;surge_rule_base&quot;] &gt;&gt; ext.surge_rule_base;
980      section[&quot;surfboard_rule_base&quot;] &gt;&gt; ext.surfboard_rule_base;
981      section[&quot;mellow_rule_base&quot;] &gt;&gt; ext.mellow_rule_base;
982      section[&quot;quan_rule_base&quot;] &gt;&gt; ext.quan_rule_base;
983      section[&quot;quanx_rule_base&quot;] &gt;&gt; ext.quanx_rule_base;
984      section[&quot;loon_rule_base&quot;] &gt;&gt; ext.loon_rule_base;
985      section[&quot;sssub_rule_base&quot;] &gt;&gt; ext.sssub_rule_base;
986      section[&quot;enable_rule_generator&quot;] &gt;&gt; ext.enable_rule_generator;
987      section[&quot;overwrite_original_rules&quot;] &gt;&gt; ext.overwrite_original_rules;
988      const char *group_name = section[&quot;proxy_groups&quot;].IsDefined() ? &quot;proxy_groups&quot; : &quot;custom_proxy_group&quot;;
989      if(section[group_name].size())
990      {
991          string_array vArray;
992          readGroup(section[group_name], vArray, global.APIMode);
993          ext.custom_proxy_group = INIBinding::from&lt;ProxyGroupConfig&gt;::from_ini(vArray);
994      }
995      const char *ruleset_name = section[&quot;rulesets&quot;].IsDefined() ? &quot;rulesets&quot; : &quot;surge_ruleset&quot;;
996      if(section[ruleset_name].size())
997      {
998          string_array vArray;
999          readRuleset(section[ruleset_name], vArray, global.APIMode);
1000          if(global.maxAllowedRulesets &amp;&amp; vArray.size() &gt; global.maxAllowedRulesets)
1001          {
1002              writeLog(0, &quot;Ruleset count in external config has exceeded limit.&quot;, LOG_LEVEL_WARNING);
1003              return -1;
1004          }
1005          ext.surge_ruleset = INIBinding::from&lt;RulesetConfig&gt;::from_ini(vArray);
1006      }
1007      if(section[&quot;rename_node&quot;].size())
1008      {
1009          string_array vArray;
1010          readRegexMatch(section[&quot;rename_node&quot;], &quot;@&quot;, vArray, global.APIMode);
1011          ext.rename = INIBinding::from&lt;RegexMatchConfig&gt;::from_ini(vArray, &quot;@&quot;);
1012      }
1013      ext.add_emoji = safe_as&lt;std::string&gt;(section[&quot;add_emoji&quot;]);
1014      ext.remove_old_emoji = safe_as&lt;std::string&gt;(section[&quot;remove_old_emoji&quot;]);
1015      const char *emoji_name = section[&quot;emojis&quot;].IsDefined() ? &quot;emojis&quot; : &quot;emoji&quot;;
1016      if(section[emoji_name].size())
1017      {
1018          string_array vArray;
1019          readEmoji(section[emoji_name], vArray, global.APIMode);
1020          ext.emoji = INIBinding::from&lt;RegexMatchConfig&gt;::from_ini(vArray, &quot;,&quot;);
1021      }
1022      section[&quot;include_remarks&quot;] &gt;&gt; ext.include;
1023      section[&quot;exclude_remarks&quot;] &gt;&gt; ext.exclude;
1024      if(node[&quot;template_args&quot;].IsSequence() &amp;&amp; ext.tpl_args != NULL)
1025      {
1026          std::string key, value;
1027          for(size_t i = 0; i &lt; node[&quot;template_args&quot;].size(); i++)
1028          {
1029              node[&quot;template_args&quot;][i][&quot;key&quot;] &gt;&gt; key;
1030              node[&quot;template_args&quot;][i][&quot;value&quot;] &gt;&gt; value;
1031              ext.tpl_args-&gt;local_vars[key] = value;
1032          }
1033      }
1034      return 0;
1035  }
1036  int loadExternalTOML(toml::value &amp;root, ExternalConfig &amp;ext)
1037  {
1038      const auto &amp;section = toml::find(root, &quot;custom&quot;);
1039      find_if_exist(section,
1040                    &quot;enable_rule_generator&quot;, ext.enable_rule_generator,
1041                    &quot;overwrite_original_rules&quot;, ext.overwrite_original_rules,
1042                    &quot;clash_rule_base&quot;, ext.clash_rule_base,
1043                    &quot;surge_rule_base&quot;, ext.surge_rule_base,
1044                    &quot;surfboard_rule_base&quot;, ext.surfboard_rule_base,
1045                    &quot;mellow_rule_base&quot;, ext.mellow_rule_base,
1046                    &quot;quan_rule_base&quot;, ext.quan_rule_base,
1047                    &quot;quanx_rule_base&quot;, ext.quanx_rule_base,
1048                    &quot;sssub_rule_base&quot;, ext.sssub_rule_base,
1049                    &quot;add_emoji&quot;, ext.add_emoji,
1050                    &quot;remove_old_emoji&quot;, ext.remove_old_emoji,
1051                    &quot;include_remarks&quot;, ext.include,
1052                    &quot;exclude_remarks&quot;, ext.exclude
1053      );
1054      if(ext.tpl_args != nullptr) operate_toml_kv_table(toml::find_or&lt;std::vector&lt;toml::table&gt;&gt;(section, &quot;template_args&quot;, {}), &quot;key&quot;, &quot;value&quot;,
1055                                                        [&amp;](const toml::value &amp;key, const toml::value &amp;value)
1056      {
1057          std::string val = toml::format(value);
1058          ext.tpl_args-&gt;local_vars[key.as_string()] = val;
1059      });
1060      auto groups = toml::find_or&lt;std::vector&lt;toml::value&gt;&gt;(root, &quot;custom_groups&quot;, {});
1061      importItems(groups, &quot;custom_groups&quot;, false);
1062      ext.custom_proxy_group = toml::get&lt;ProxyGroupConfigs&gt;(toml::value(groups));
1063      auto rulesets = toml::find_or&lt;std::vector&lt;toml::value&gt;&gt;(root, &quot;rulesets&quot;, {});
1064      importItems(rulesets, &quot;rulesets&quot;, false);
1065      if(global.maxAllowedRulesets &amp;&amp; rulesets.size() &gt; global.maxAllowedRulesets)
1066      {
1067          writeLog(0, &quot;Ruleset count in external config has exceeded limit. &quot;, LOG_LEVEL_WARNING);
1068          return -1;
1069      }
1070      ext.surge_ruleset = toml::get&lt;RulesetConfigs&gt;(toml::value(rulesets));
1071      auto emojiconfs = toml::find_or&lt;std::vector&lt;toml::value&gt;&gt;(root, &quot;emoji&quot;, {});
1072      importItems(emojiconfs, &quot;emoji&quot;, false);
1073      ext.emoji = toml::get&lt;RegexMatchConfigs&gt;(toml::value(emojiconfs));
1074      auto renameconfs = toml::find_or&lt;std::vector&lt;toml::value&gt;&gt;(root, &quot;rename_node&quot;, {});
1075      importItems(renameconfs, &quot;rename_node&quot;, false);
1076      ext.rename = toml::get&lt;RegexMatchConfigs&gt;(toml::value(renameconfs));
1077      return 0;
1078  }
1079  int loadExternalConfig(std::string &amp;path, ExternalConfig &amp;ext)
1080  {
1081      std::string base_content, proxy = parseProxy(global.proxyConfig), config = fetchFile(path, proxy, global.cacheConfig);
1082      if(render_template(config, *ext.tpl_args, base_content, global.templatePath) != 0)
1083          base_content = config;
1084      try
1085      {
1086          YAML::Node yaml = YAML::Load(base_content);
1087          if(yaml.size() &amp;&amp; yaml[&quot;custom&quot;].IsDefined())
1088              return loadExternalYAML(yaml, ext);
1089          toml::value conf = parseToml(base_content, path);
1090          if(!conf.is_uninitialized() &amp;&amp; toml::find_or&lt;int&gt;(conf, &quot;version&quot;, 0))
1091              return loadExternalTOML(conf, ext);
1092      }
1093      catch (YAML::Exception &amp;e)
1094      {
1095      }
1096      catch (toml::exception &amp;e)
1097      {
1098      }
1099      INIReader ini;
1100      ini.store_isolated_line = true;
1101      ini.SetIsolatedItemsSection(&quot;custom&quot;);
1102      if(ini.Parse(base_content) != INIREADER_EXCEPTION_NONE)
1103      {
1104          writeLog(0, &quot;Load external configuration failed. Reason: &quot; + ini.GetLastError(), LOG_LEVEL_ERROR);
1105          return -1;
1106      }
1107      ini.EnterSection(&quot;custom&quot;);
1108      if(ini.ItemPrefixExist(&quot;custom_proxy_group&quot;))
1109      {
1110          string_array vArray;
1111          ini.GetAll(&quot;custom_proxy_group&quot;, vArray);
1112          importItems(vArray, global.APIMode);
1113          ext.custom_proxy_group = INIBinding::from&lt;ProxyGroupConfig&gt;::from_ini(vArray);
1114      }
1115      std::string ruleset_name = ini.ItemPrefixExist(&quot;ruleset&quot;) ? &quot;ruleset&quot; : &quot;surge_ruleset&quot;;
1116      if(ini.ItemPrefixExist(ruleset_name))
1117      {
1118          string_array vArray;
1119          ini.GetAll(ruleset_name, vArray);
1120          importItems(vArray, global.APIMode);
1121          if(global.maxAllowedRulesets &amp;&amp; vArray.size() &gt; global.maxAllowedRulesets)
1122          {
1123              writeLog(0, &quot;Ruleset count in external config has exceeded limit. &quot;, LOG_LEVEL_WARNING);
1124              return -1;
1125          }
1126          ext.surge_ruleset = INIBinding::from&lt;RulesetConfig&gt;::from_ini(vArray);
1127      }
1128      ini.GetIfExist(&quot;clash_rule_base&quot;, ext.clash_rule_base);
1129      ini.GetIfExist(&quot;surge_rule_base&quot;, ext.surge_rule_base);
1130      ini.GetIfExist(&quot;surfboard_rule_base&quot;, ext.surfboard_rule_base);
1131      ini.GetIfExist(&quot;mellow_rule_base&quot;, ext.mellow_rule_base);
1132      ini.GetIfExist(&quot;quan_rule_base&quot;, ext.quan_rule_base);
1133      ini.GetIfExist(&quot;quanx_rule_base&quot;, ext.quanx_rule_base);
1134      ini.GetIfExist(&quot;loon_rule_base&quot;, ext.loon_rule_base);
1135      ini.GetIfExist(&quot;sssub_rule_base&quot;, ext.sssub_rule_base);
1136      ini.GetBoolIfExist(&quot;overwrite_original_rules&quot;, ext.overwrite_original_rules);
1137      ini.GetBoolIfExist(&quot;enable_rule_generator&quot;, ext.enable_rule_generator);
1138      if(ini.ItemPrefixExist(&quot;rename&quot;))
1139      {
1140          string_array vArray;
1141          ini.GetAll(&quot;rename&quot;, vArray);
1142          importItems(vArray, global.APIMode);
1143          ext.rename = INIBinding::from&lt;RegexMatchConfig&gt;::from_ini(vArray, &quot;@&quot;);
1144      }
1145      ext.add_emoji = ini.Get(&quot;add_emoji&quot;);
1146      ext.remove_old_emoji = ini.Get(&quot;remove_old_emoji&quot;);
1147      if(ini.ItemPrefixExist(&quot;emoji&quot;))
1148      {
1149          string_array vArray;
1150          ini.GetAll(&quot;emoji&quot;, vArray);
1151          importItems(vArray, global.APIMode);
1152          ext.emoji = INIBinding::from&lt;RegexMatchConfig&gt;::from_ini(vArray, &quot;,&quot;);
1153      }
1154      if(ini.ItemPrefixExist(&quot;include_remarks&quot;))
1155          ini.GetAll(&quot;include_remarks&quot;, ext.include);
1156      if(ini.ItemPrefixExist(&quot;exclude_remarks&quot;))
1157          ini.GetAll(&quot;exclude_remarks&quot;, ext.exclude);
1158      if(ini.SectionExist(&quot;template&quot;) &amp;&amp; ext.tpl_args != nullptr)
1159      {
1160          ini.EnterSection(&quot;template&quot;);
1161          string_multimap tempmap;
1162          ini.GetItems(tempmap);
1163          for(auto &amp;x : tempmap)
1164              ext.tpl_args-&gt;local_vars[x.first] = x.second;
1165      }
1166      return 0;
1167  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from subconverter-MDEwOlJlcG9zaXRvcnkyMTg2ODY3NjM=-flat-settings.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from subconverter-MDEwOlJlcG9zaXRvcnkyMTg2ODY3NjM=-flat-settings.cpp</div>
                </div>
                <div class="column column_space"><pre><code>57      target.swap(result);
58      writeLog(0, &quot;Imported &quot; + std::to_string(itemCount) + &quot; item(s).&quot;);
59      return 0;
</pre></code></div>
                <div class="column column_space"><pre><code>98      root.swap(newRoot);
99      writeLog(0, &quot;Imported &quot; + std::to_string(count) + &quot; item(s).&quot;);
100      return;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    