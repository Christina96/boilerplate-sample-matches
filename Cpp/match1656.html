<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for ibex_Optimizer.cpp &amp; ibex_CompiledFunction.h</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for ibex_Optimizer.cpp &amp; ibex_CompiledFunction.h
      </h3>
<h1 align="center">
        3.0%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>ibex_Optimizer.cpp (3.2036614%)<th>ibex_CompiledFunction.h (2.9850745%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(575-593)<td><a href="#" name="0">(213-219)</a><td align="center"><font color="#ff0000">14</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>ibex_Optimizer.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
//                                  I B E X
// File        : ibex_Optimizer.cpp
// Author      : Gilles Chabert, Bertrand Neveu
// Copyright   : IMT Atlantique (France)
// License     : See the LICENSE file
// Created     : May 14, 2012
// Last Update : Apr 08, 2019
//============================================================================

#include "ibex_Optimizer.h"
#include "ibex_Timer.h"
#include "ibex_Function.h"
#include "ibex_NoBisectableVariableException.h"
#include "ibex_BxpOptimData.h"
#include "ibex_CovOptimData.h"

#include &lt;float.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;iomanip&gt;

using namespace std;

namespace ibex {

/*
 * TODO: redundant with ExtendedSystem.
 */
void Optimizer::write_ext_box(const IntervalVector&amp; box, IntervalVector&amp; ext_box) {
	int i2=0;
	for (int i=0; i&lt;n; i++,i2++) {
		if (i2==goal_var) i2++; // skip goal variable
		ext_box[i2]=box[i];
	}
}

void Optimizer::read_ext_box(const IntervalVector&amp; ext_box, IntervalVector&amp; box) {
	int i2=0;
	for (int i=0; i&lt;n; i++,i2++) {
		if (i2==goal_var) i2++; // skip goal variable
		box[i]=ext_box[i2];
	}
}

Optimizer::Optimizer(int n, Ctc&amp; ctc, Bsc&amp; bsc, LoupFinder&amp; finder,
		CellBufferOptim&amp; buffer,
		int goal_var, double eps_x, double rel_eps_f, double abs_eps_f) :
                						n(n), goal_var(goal_var),
										ctc(ctc), bsc(bsc), loup_finder(finder), buffer(buffer),
										eps_x(eps_x), rel_eps_f(rel_eps_f), abs_eps_f(abs_eps_f),
										trace(0), timeout(-1), extended_COV(true), anticipated_upper_bounding(true),
										status(SUCCESS),
										uplo(NEG_INFINITY), uplo_of_epsboxes(POS_INFINITY), loup(POS_INFINITY),
										loup_point(IntervalVector::empty(n)), initial_loup(POS_INFINITY), loup_changed(false),
										time(0), nb_cells(0), cov(NULL) {

	if (trace) cout.precision(12);
}


Optimizer::Optimizer(OptimizerConfig&amp; config) :
		n           (config.nb_var()),
		goal_var    (config.goal_var()),
		ctc         (config.get_ctc()),
		bsc         (config.get_bsc()),
		loup_finder (config.get_loup_finder()),
		buffer      (config.get_cell_buffer()),
		eps_x       (config.get_eps_x()),
		rel_eps_f   (config.get_rel_eps_f()),
		abs_eps_f   (config.get_abs_eps_f()),
		trace       (config.get_trace()),
		timeout     (config.get_timeout()),
		extended_COV(config.with_extended_cov()),
		anticipated_upper_bounding(config.with_anticipated_upper_bounding()),
		status(SUCCESS),
		uplo(NEG_INFINITY), uplo_of_epsboxes(POS_INFINITY), loup(POS_INFINITY),
		loup_point(IntervalVector::empty(n)), initial_loup(POS_INFINITY), loup_changed(false),
		time(0), nb_cells(0), cov(NULL) {

}

Optimizer::~Optimizer() {
	if (cov) delete cov;
}

// compute the value ymax (decreasing the loup with the precision)
// the heap and the current box are contracted with y &lt;= ymax
double Optimizer::compute_ymax() {
	if (anticipated_upper_bounding) {
		//double ymax = loup - rel_eps_f*fabs(loup); ---&gt; wrong :the relative precision must be correct for ymax (not loup)
		double ymax = loup&gt;0 ?
				1/(1+rel_eps_f)*loup
		:
				1/(1-rel_eps_f)*loup;

		if (loup - abs_eps_f &lt; ymax)
			ymax = loup - abs_eps_f;
		//return ymax;
		return next_float(ymax);
	} else
		return loup;
}

bool Optimizer::update_loup(const IntervalVector&amp; box, BoxProperties&amp; prop) {

	try {

		pair&lt;IntervalVector,double&gt; p=loup_finder.find(box,loup_point,loup,prop);
		loup_point = p.first;
		loup = p.second;

		if (trace) {
			cout &lt;&lt; "                    ";
			cout &lt;&lt; "\033[32m loup= " &lt;&lt; loup &lt;&lt; "\033[0m" &lt;&lt; endl;
//			cout &lt;&lt; " loup point=";
//			if (loup_finder.rigorous())
//				cout &lt;&lt; loup_point &lt;&lt; endl;
//			else
//				cout &lt;&lt; loup_point.lb() &lt;&lt; endl;
		}
		return true;

	} catch(LoupFinder::NotFound&amp;) {
		return false;
	}
}

//bool Optimizer::update_entailed_ctr(const IntervalVector&amp; box) {
//	for (int j=0; j&lt;m; j++) {
//		if (entailed-&gt;normalized(j)) {
//			continue;
//		}
//		Interval y=sys.ctrs[j].f.eval(box);
//		if (y.lb()&gt;0) return false;
//		else if (y.ub()&lt;=0) {
//			entailed-&gt;set_normalized_entailed(j);
//		}
//	}
//	return true;
//}

void Optimizer::update_uplo() {
	double new_uplo=POS_INFINITY;

	if (! buffer.empty()) {
		new_uplo= buffer.minimum();
		if (new_uplo &gt; loup &amp;&amp; uplo_of_epsboxes &gt; loup) {
			cout &lt;&lt; " loup = " &lt;&lt; loup &lt;&lt; " new_uplo=" &lt;&lt; new_uplo &lt;&lt;  " uplo_of_epsboxes=" &lt;&lt; uplo_of_epsboxes &lt;&lt; endl;
			ibex_error("optimizer: new_uplo&gt;loup (please report bug)");
		}
		if (new_uplo &lt; uplo) {
			cout &lt;&lt; "uplo= " &lt;&lt; uplo &lt;&lt; " new_uplo=" &lt;&lt; new_uplo &lt;&lt; endl;
			ibex_error("optimizer: new_uplo&lt;uplo (please report bug)");
		}

		// uplo &lt;- max(uplo, min(new_uplo, uplo_of_epsboxes))
		if (new_uplo &lt; uplo_of_epsboxes) {
			if (new_uplo &gt; uplo) {
				uplo = new_uplo;

				if (trace)
					cout &lt;&lt; "\033[33m uplo= " &lt;&lt; uplo &lt;&lt; "\033[0m" &lt;&lt; endl;
			}
		}
		else uplo = uplo_of_epsboxes;
	}
	else if (buffer.empty() &amp;&amp; loup != POS_INFINITY) {
		// empty buffer : new uplo is set to ymax (loup - precision) if a loup has been found
		new_uplo=compute_ymax(); // not new_uplo=loup, because constraint y &lt;= ymax was enforced
		//    cout &lt;&lt; " new uplo buffer empty " &lt;&lt; new_uplo &lt;&lt; " uplo " &lt;&lt; uplo &lt;&lt; endl;

		double m = (new_uplo &lt; uplo_of_epsboxes) ? new_uplo :  uplo_of_epsboxes;
		if (uplo &lt; m) uplo = m; // warning: hides the field "m" of the class
		// note: we always have uplo &lt;= uplo_of_epsboxes but we may have uplo &gt; new_uplo, because
		// ymax is strictly lower than the loup.
	}

}

void Optimizer::update_uplo_of_epsboxes(double ymin) {

	// the current box cannot be bisected.  ymin is a lower bound of the objective on this box
	// uplo of epsboxes can only go down, but not under uplo : it is an upperbound for uplo,
	// that indicates a lowerbound for the objective in all the small boxes
	// found by the precision criterion
	assert (uplo_of_epsboxes &gt;= uplo);
	assert(ymin &gt;= uplo);
	if (uplo_of_epsboxes &gt; ymin) {
		uplo_of_epsboxes = ymin;
		if (trace) {
			cout &lt;&lt; " unprocessable tiny box: now uplo&lt;=" &lt;&lt; setprecision(12) &lt;&lt;  uplo_of_epsboxes &lt;&lt; " uplo=" &lt;&lt; uplo &lt;&lt; endl;
		}
	}
}

void Optimizer::handle_cell(Cell&amp; c) {

	contract_and_bound(c);

	if (c.box.is_empty()) {
		delete &amp;c;
	} else {
		buffer.push(&amp;c);
	}
}

void Optimizer::contract_and_bound(Cell&amp; c) {

	/*======================== contract y with y&lt;=loup ========================*/
	Interval&amp; y=c.box[goal_var];

	double ymax;
	if (loup==POS_INFINITY) ymax = POS_INFINITY;
	// ymax is slightly increased to favour subboxes of the loup
	// TODO: useful with double heap??
	else ymax = compute_ymax()+1.e-15;

	y &amp;= Interval(NEG_INFINITY,ymax);

	if (y.is_empty()) {
		c.box.set_empty();
		return;
	} else {
		c.prop.update(BoxEvent(c.box,BoxEvent::CONTRACT,BitSet::singleton(n+1,goal_var)));
	}

	/*================ contract x with f(x)=y and g(x)&lt;=0 ================*/
	//cout &lt;&lt; " [contract]  x before=" &lt;&lt; c.box &lt;&lt; endl;
	//cout &lt;&lt; " [contract]  y before=" &lt;&lt; y &lt;&lt; endl;

	ContractContext context(c.prop);
	if (c.bisected_var!=-1) {
		context.impact.clear();
		context.impact.add(c.bisected_var);
		context.impact.add(goal_var);
	}

	ctc.contract(c.box, context);
	//cout &lt;&lt; c.prop &lt;&lt; endl;
	if (c.box.is_empty()) return;

	//cout &lt;&lt; " [contract]  x after=" &lt;&lt; c.box &lt;&lt; endl;
	//cout &lt;&lt; " [contract]  y after=" &lt;&lt; y &lt;&lt; endl;
	/*====================================================================*/

	/*========================= update loup =============================*/

	IntervalVector tmp_box(n);
	read_ext_box(c.box,tmp_box);

	c.prop.update(BoxEvent(c.box,BoxEvent::CHANGE));

	bool loup_ch=update_loup(tmp_box, c.prop);

	// update of the upper bound of y in case of a new loup found
	if (loup_ch) {
		y &amp;= Interval(NEG_INFINITY,compute_ymax());
		c.prop.update(BoxEvent(c.box,BoxEvent::CONTRACT,BitSet::singleton(n+1,goal_var)));
	}

	//TODO: should we propagate constraints again?

	loup_changed |= loup_ch;

	if (y.is_empty()) { // fix issue #44
		c.box.set_empty();
		return;
	}

	/*====================================================================*/
	// Note: there are three different cases of "epsilon" box,
	// - NoBisectableVariableException raised by the bisector (---&gt; see optimize(...)) which
	//   is independent from the optimizer
	// - the width of the box is less than the precision given to the optimizer ("prec" for the original variables
	//   and "goal_abs_prec" for the goal variable)
	// - the extended box has no bisectable domains (if prec=0 or &lt;1 ulp)
	if ((tmp_box.max_diam()&lt;=eps_x &amp;&amp; y.diam() &lt;=abs_eps_f) || !c.box.is_bisectable()) {
		update_uplo_of_epsboxes(y.lb());
		c.box.set_empty();
		return;
	}

	// ** important: ** must be done after upper-bounding
	//kkt.contract(tmp_box);

	if (tmp_box.is_empty()) {
		c.box.set_empty();
	} else {
		// the current extended box in the cell is updated
		write_ext_box(tmp_box,c.box);
	}
}

Optimizer::Status Optimizer::optimize(const IntervalVector&amp; init_box, double obj_init_bound) {
	start(init_box, obj_init_bound);
	return optimize();
}


Optimizer::Status Optimizer::optimize(const CovOptimData&amp; data, double obj_init_bound) {
	start(data, obj_init_bound);
	return optimize();
}

Optimizer::Status Optimizer::optimize(const char* cov_file, double obj_init_bound) {
	CovOptimData data(cov_file);
	start(data, obj_init_bound);
	return optimize();
}

void Optimizer::start(const IntervalVector&amp; init_box, double obj_init_bound) {

	loup=obj_init_bound;

	// Just to initialize the "loup" for the buffer
	// TODO: replace with a set_loup function
	buffer.contract(loup);

	uplo=NEG_INFINITY;
	uplo_of_epsboxes=POS_INFINITY;

	nb_cells=0;

	buffer.flush();

	Cell* root=new Cell(IntervalVector(n+1));

	write_ext_box(init_box, root-&gt;box);

	// add data required by the bisector
	bsc.add_property(init_box, root-&gt;prop);

	// add data required by the contractor
	ctc.add_property(init_box, root-&gt;prop);

	// add data required by the buffer
	buffer.add_property(init_box, root-&gt;prop);

	// add data required by the loup finder
	loup_finder.add_property(init_box, root-&gt;prop);

	//cout &lt;&lt; "**** Properties ****\n" &lt;&lt; root-&gt;prop &lt;&lt; endl;

	loup_changed=false;
	initial_loup=obj_init_bound;

	loup_point = init_box; //.set_empty();
	time=0;

	if (cov) delete cov;
	cov = new CovOptimData(extended_COV? n+1 : n, extended_COV);
	cov-&gt;data-&gt;_optim_time = 0;
	cov-&gt;data-&gt;_optim_nb_cells = 0;

	handle_cell(*root);
}

void Optimizer::start(const CovOptimData&amp; data, double obj_init_bound) {

	loup=obj_init_bound;

	// Just to initialize the "loup" for the buffer
	// TODO: replace with a set_loup function
	buffer.contract(loup);

	uplo=data.uplo();
	loup=data.loup();
	loup_point=data.loup_point();
	uplo_of_epsboxes=POS_INFINITY;

	nb_cells=0;

	buffer.flush();

	for (size_t i=loup_point.is_empty()? 0 : 1; i&lt;data.size(); i++) {

		IntervalVector box(n+1);

		if (data.is_extended_space())
			box = data[i];
		else {
			write_ext_box(data[i], box);
			box[goal_var] = Interval(uplo,loup);
			ctc.contract(box);
			if (box.is_empty()) continue;
		}

		Cell* cell=new Cell(box);

		// add data required by the cell buffer
		buffer.add_property(box, cell-&gt;prop);

		// add data required by the bisector
		bsc.add_property(box, cell-&gt;prop);

		// add data required by the contractor
		ctc.add_property(box, cell-&gt;prop);

		// add data required by the loup finder
		loup_finder.add_property(box, cell-&gt;prop);

		buffer.push(cell);
	}

	loup_changed=false;
	initial_loup=obj_init_bound;

	time=0;

	if (cov) delete cov;
	cov = new CovOptimData(extended_COV? n+1 : n, extended_COV);
	cov-&gt;data-&gt;_optim_time = data.time();
	cov-&gt;data-&gt;_optim_nb_cells = data.nb_cells();
}

Optimizer::Status Optimizer::optimize() {
	Timer timer;
	timer.start();

	update_uplo();

	try {
	     while (!buffer.empty()) {

			loup_changed=false;
			// for double heap , choose randomly the buffer : top  has to be called before pop
			Cell *c = buffer.top();
			if (trace &gt;= 2) cout &lt;&lt; " current box " &lt;&lt; c-&gt;box &lt;&lt; endl;

			try {

				pair&lt;Cell*,Cell*&gt; new_cells=bsc.bisect(*c);
				buffer.pop();
				delete c; // deletes the cell.

				nb_cells+=2;  // counting the cells handled ( in previous versions nb_cells was the number of cells put into the buffer after being handled)

				handle_cell(*new_cells.first);
				handle_cell(*new_cells.second);

				if (uplo_of_epsboxes == NEG_INFINITY) {
					break;
				}
				if (loup_changed) {
					// In case of a new upper bound (loup_changed == true), all the boxes
					// with a lower bound greater than (loup - goal_prec) are removed and deleted.
					// Note: if contraction was before bisection, we could have the problem
					// that the current cell is removed by contractHeap. See comments in
					// older version of the code (before revision 284).

					double ymax=compute_ymax();

					buffer.contract(ymax);

					//cout &lt;&lt; " now buffer is contracted and min=" &lt;&lt; buffer.minimum() &lt;&lt; endl;

					// TODO: check if happens. What is the return code in this case?
					if (ymax &lt;= NEG_INFINITY) {
						if (trace) cout &lt;&lt; " infinite value for the minimum " &lt;&lt; endl;
						break;
					}
				}
				update_uplo();

				if (!anticipated_upper_bounding) // useless to check precision on objective if 'true'
					if (get_obj_rel_prec()&lt;rel_eps_f || get_obj_abs_prec()&lt;abs_eps_f)
						break;

				if (timeout&gt;0) timer.check(timeout); // TODO: not reentrant, JN: done
				time = timer.get_time();

			}
			catch (NoBisectableVariableException&amp; ) {
				update_uplo_of_epsboxes((c-&gt;box)[goal_var].lb());
				buffer.pop();
				delete c; // deletes the cell.
				update_uplo(); // the heap has changed -&gt; recalculate the uplo (eg: if not in best-first search)

			}
		}

	 	timer.stop();
	 	time = timer.get_time();

		// No solution found and optimization stopped with empty buffer
		// before the required precision is reached =&gt; means infeasible problem
	 	if (uplo_of_epsboxes == NEG_INFINITY)
	 		status = UNBOUNDED_OBJ;
	 	else if (uplo_of_epsboxes == POS_INFINITY &amp;&amp; (loup==POS_INFINITY || (loup==initial_loup &amp;&amp; abs_eps_f==0 &amp;&amp; rel_eps_f==0)))
	 		status = INFEASIBLE;
	 	else if (loup==initial_loup)
	 		status = NO_FEASIBLE_FOUND;
	 	else if (get_obj_rel_prec()&gt;rel_eps_f &amp;&amp; get_obj_abs_prec()&gt;abs_eps_f)
	 		status = UNREACHED_PREC;
	 	else
	 		status = SUCCESS;
	}
	catch (TimeOutException&amp; ) {
		status = TIME_OUT;
	}

	/* TODO: cannot retrieve variable names here. */
	for (int i=0; i&lt;(extended_COV ? n+1 : n); i++)
		cov-&gt;data-&gt;_optim_var_names.push_back(string(""));

	cov-&gt;data-&gt;_optim_optimizer_status = (unsigned int) status;
	cov-&gt;data-&gt;_optim_uplo = uplo;
	cov-&gt;data-&gt;_optim_uplo_of_epsboxes = uplo_of_epsboxes;
	cov-&gt;data-&gt;_optim_loup = loup;

	cov-&gt;data-&gt;_optim_time += time;
	cov-&gt;data-&gt;_optim_nb_cells += nb_cells;
	cov-&gt;data-&gt;_optim_loup_point = loup_point;

	// for conversion between original/extended boxes
	IntervalVector tmp(extended_COV ? n+1 : n);

	// by convention, the first box has to be the loup-point.
	if (extended_COV) {
		write_ext_box(loup_point, tmp);
		tmp[goal_var] = Interval(uplo,loup);
		cov-&gt;add(tmp);
	}
	else {
		cov-&gt;add(loup_point);
	}

	while (!buffer.empty()) {
		Cell* cell=buffer.top();
		if (extended_COV)
			cov-&gt;add(cell-&gt;box);
		else {
			read_ext_box(cell-&gt;box,tmp);
			cov-&gt;add(tmp);
		}
		delete buffer.pop();
	}

	return status;
}

namespace {
const char* green() {
#ifndef _WIN32
	return "\033[32m";
#else
	return "";
#endif
}

const char* red(){
#ifndef _WIN32
	return "\033[31m";
#else
	return "";
#endif
}

const char* white() {
#ifndef _WIN32
	return "\033[0m";
#else
	return "";
#endif
}

}

void Optimizer::report() {

	if (!cov || !buffer.empty()) { // not started
		cout &lt;&lt; " not started." &lt;&lt; endl;
<a name="0"></a>		return;
	}

<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	switch(status) {
	case SUCCESS:
		cout &lt;&lt; green() &lt;&lt; " optimization successful!" &lt;&lt; endl;
		break;
	case INFEASIBLE:
		cout &lt;&lt; red() &lt;&lt; " infeasible problem" &lt;&lt; endl;
		break;
	case NO_FEASIBLE_FOUND:
		cout &lt;&lt; red() &lt;&lt; " no feasible point found (the problem may be infeasible)" &lt;&lt; endl;
		break;
	case UNBOUNDED_OBJ:
		cout &lt;&lt; red() &lt;&lt; " possibly unbounded objective (f*=-oo)" &lt;&lt; endl;
		break;
	case TIME_OUT:
		cout &lt;&lt; red() &lt;&lt; " time limit " &lt;&lt; timeout &lt;&lt; "s. reached " &lt;&lt; endl;
		break;
	case UNREACHED_PREC:
		cout &lt;&lt; red() &lt;&lt; " unreached precision" &lt;&lt; endl;
		break;</b></font>
	}
	cout &lt;&lt; white() &lt;&lt;  endl;

	// No solution found and optimization stopped with empty buffer
	// before the required precision is reached =&gt; means infeasible problem
	if (status==INFEASIBLE) {
		cout &lt;&lt; " infeasible problem " &lt;&lt; endl;
	} else {
		cout &lt;&lt; " f* in\t[" &lt;&lt; uplo &lt;&lt; "," &lt;&lt; loup &lt;&lt; "]" &lt;&lt; endl;
		cout &lt;&lt; "\t(best bound)" &lt;&lt; endl &lt;&lt; endl;

		if (loup==initial_loup)
			cout &lt;&lt; " x* =\t--\n\t(no feasible point found)" &lt;&lt; endl;
		else {
			if (loup_finder.rigorous())
				cout &lt;&lt; " x* in\t" &lt;&lt; loup_point &lt;&lt; endl;
			else
				cout &lt;&lt; " x* =\t" &lt;&lt; loup_point.lb() &lt;&lt; endl;
			cout &lt;&lt; "\t(best feasible point)" &lt;&lt; endl;
		}
		cout &lt;&lt; endl;
		double rel_prec=get_obj_rel_prec();
		double abs_prec=get_obj_abs_prec();

		cout &lt;&lt; " relative precision on f*:\t" &lt;&lt; rel_prec;
		if (rel_prec &lt;= rel_eps_f)
			cout &lt;&lt; green() &lt;&lt; " [passed] " &lt;&lt; white();
		cout &lt;&lt; endl;

		cout &lt;&lt; " absolute precision on f*:\t" &lt;&lt; abs_prec;
		if (abs_prec &lt;= abs_eps_f)
			cout &lt;&lt; green() &lt;&lt; " [passed] " &lt;&lt; white();
		cout &lt;&lt; endl;
	}

	cout &lt;&lt; " cpu time used:\t\t\t" &lt;&lt; time &lt;&lt; "s";
	if (cov-&gt;time()!=time)
		cout &lt;&lt; " [total=" &lt;&lt; cov-&gt;time() &lt;&lt; "]";
	cout &lt;&lt; endl;
	cout &lt;&lt; " number of cells:\t\t" &lt;&lt; nb_cells;
	if (cov-&gt;nb_cells()!=nb_cells)
		cout &lt;&lt; " [total=" &lt;&lt; cov-&gt;nb_cells() &lt;&lt; "]";
	cout &lt;&lt; endl &lt;&lt; endl;
}



} // end namespace ibex
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>ibex_CompiledFunction.h</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
//============================================================================
//                                  I B E X                                   
// File        : Compiled function
// Author      : Gilles Chabert
// Copyright   : Ecole des Mines de Nantes (France)
// License     : See the LICENSE file
// Created     : Dec 31, 2011
// Last Update : 
//============================================================================

#ifndef __IBEX_COMPILED_FUNCTION_H__
#define __IBEX_COMPILED_FUNCTION_H__

#include &lt;stack&gt;

#include "ibex_Expr.h"
#include "ibex_ExprVisitor.h"
#include "ibex_ExprSubNodes.h"
#include "ibex_FwdAlgorithm.h"
#include "ibex_BwdAlgorithm.h"
#include "ibex_Agenda.h"

namespace ibex {

class Function;

template&lt;class T&gt;
class ExprData;

/**
 * \ingroup symbolic
 * \brief A low-level representation of a function for speeding up forward/backward algorithms.
 *
 */
class CompiledFunction : public ExprVisitor&lt;void&gt; {
public:

	CompiledFunction();

	/**
	 * Create a compiled version of the function \a f. */
	void compile(Function&amp; f);

	/**
	 * \brier Delete this.
	 */
	~CompiledFunction();

	/**
	 * Run the forward phase of a forward algorithm and
	 * return a reference to the label
	 * of the root node. V must be a subclass of FwdAlgorithm.
	 * Note that the type V is just passed in order to have static linkage.
	 */
	template&lt;class V&gt;
	void forward(const V&amp; algo) const;

	/**
	 * Forward phase on a specific set of operations (in the agenda).
	 */
	template&lt;class V&gt;
	void forward(const V&amp; algo, const Agenda&amp; a) const;

	/**
	 * Run the backward phase.  V must be a subclass of BwdAlgorithm.
	 * Note that the type V is just passed in order to have static linkage.
	 */
	template&lt;class V&gt;
	void backward(const V&amp; algo) const;

	/**
	 * Backward phase on a specific set of operations (in the agenda).
	 */
	template&lt;class V&gt;
	void backward(const V&amp; algo, const Agenda&amp; a) const;

	/**
	 * Return an agenda of all the operations
	 * that need to be considered for a subexpression
	 * of a given rank (including itself).
	 *
	 * \note To be deleted by the caller.
	 */
	Agenda* agenda(int rank) const;

	/**
	 * Print the structure to the standard output.
	 */
	friend class Function;

protected:
	typedef enum {
		IDX,    // index with reference
		IDX_CP, // index with copy
		VEC, SYM, CST, APPLY, CHI,
		ADD, MUL, SUB, DIV, MAX, MIN, ATAN2,
		GEN1, GEN2, GENN,
		MINUS, MINUS_V, MINUS_M,
		TRANS_V, TRANS_M, SIGN, ABS, POWER,
		SQR, SQRT, EXP, LOG,
		COS,  SIN,  TAN,  ACOS,  ASIN,  ATAN,
		COSH, SINH, TANH, ACOSH, ASINH, ATANH,
		FLOOR,  CEIL, SAW,

		ADD_V, ADD_M, SUB_V, SUB_M,
		MUL_SV, MUL_SM, MUL_VV, MUL_MV, MUL_MM, MUL_VM
	} operation;

private:

#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Woverloaded-virtual"
#endif
	void visit(const ExprNAryOp&amp; e, operation op);
	void visit(const ExprBinaryOp&amp; b, operation op);
	void visit(const ExprUnaryOp&amp; u, operation op);
#ifdef __clang__
#pragma clang diagnostic pop
#endif

	void visit(const ExprNode&amp; e);
	void visit(const ExprIndex&amp; i);
	void visit(const ExprSymbol&amp; v);
	void visit(const ExprConstant&amp; c);
	void visit(const ExprVector&amp; e);
	void visit(const ExprApply&amp; e);
	void visit(const ExprChi&amp; e);
	void visit(const ExprGenericBinaryOp&amp; e);
	void visit(const ExprAdd&amp; e);
	void visit(const ExprMul&amp; e);
	void visit(const ExprSub&amp; e);
	void visit(const ExprDiv&amp; e);
	void visit(const ExprMax&amp; e);
	void visit(const ExprMin&amp; e);
	void visit(const ExprAtan2&amp; e);
	void visit(const ExprGenericUnaryOp&amp; e);
	void visit(const ExprMinus&amp; e);
	void visit(const ExprTrans&amp; e);
	void visit(const ExprSign&amp; e);
	void visit(const ExprAbs&amp; e);
	void visit(const ExprPower&amp; e);
	void visit(const ExprSqr&amp; e);
	void visit(const ExprSqrt&amp; e);
	void visit(const ExprExp&amp; e);
	void visit(const ExprLog&amp; e);
	void visit(const ExprCos&amp; e);
	void visit(const ExprSin&amp; e);
	void visit(const ExprTan&amp; e);
	void visit(const ExprCosh&amp; e);
	void visit(const ExprSinh&amp; e);
	void visit(const ExprTanh&amp; e);
	void visit(const ExprAcos&amp; e);
	void visit(const ExprAsin&amp; e);
	void visit(const ExprAtan&amp; e);
	void visit(const ExprAcosh&amp; e);
	void visit(const ExprAsinh&amp; e);
	void visit(const ExprAtanh&amp; e);
	void visit(const ExprFloor&amp; e);
	void visit(const ExprCeil&amp; e);
	void visit(const ExprSaw&amp; e);

private:
	template&lt;class V&gt;
	void forward(const V&amp; algo, int i) const;

	template&lt;class V&gt;
	void backward(const V&amp; algo, int i) const;

	friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const CompiledFunction&amp; data);

	const char* op(operation o) const;

	int n; // == the size of the root expression

	int n_total; // == the size of the expression, including all arguments

	ExprSubNodes *nodes;

	operation *code;

	int* nb_args;

	mutable int** args;

	// Node counter in Polish prefix notation
	// (only useful during construction)
	mutable int ptr;
};

std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const CompiledFunction&amp; data);

template&lt;class V&gt;
inline void CompiledFunction::forward(const V&amp; algo) const {
	assert(dynamic_cast&lt;const FwdAlgorithm* &gt;(&amp;algo)!=NULL);

	for (int i=n-1; i&gt;=0; i--) {
		forward(algo, i);
	}
}

template&lt;class V&gt;
inline void CompiledFunction::forward(const V&amp; algo, const Agenda&amp; a) const {
	assert(dynamic_cast&lt;const FwdAlgorithm* &gt;(&amp;algo)!=NULL);

	for (int i=a.first(); i!=a.end(); i=a.next(i)) {
		forward(algo, i);
	}
}
<a name="0"></a>
template&lt;class V&gt;
void CompiledFunction::forward(const V&amp; algo, int i) const {
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	switch(code[i]) {
	case IDX:    ((V&amp;) algo).idx_fwd    (args[i][0], i); break;
	case IDX_CP: ((V&amp;) algo).idx_cp_fwd (args[i][0], i); break;
	case VEC:    ((V&amp;) algo).vector_fwd (args[i], i); break;
	case SYM:    ((V&amp;) algo).symbol_fwd (i); break;
	case CST:    ((V&amp;) algo).cst_fwd    (i); break;
	case APPLY:  ((V&amp;) algo).apply_fwd  (args[i],i); break;</b></font>
	case CHI:    ((V&amp;) algo).chi_fwd    (args[i][0], args[i][1], args[i][2], i); break;
	case GEN2:   ((V&amp;) algo).gen2_fwd   (args[i][0], args[i][1], i); break;
	case ADD:    ((V&amp;) algo).add_fwd    (args[i][0], args[i][1], i); break;
	case ADD_V:  ((V&amp;) algo).add_V_fwd  (args[i][0], args[i][1], i); break;
	case ADD_M:  ((V&amp;) algo).add_M_fwd  (args[i][0], args[i][1], i); break;
	case MUL:    ((V&amp;) algo).mul_fwd    (args[i][0], args[i][1], i); break;
	case MUL_SV: ((V&amp;) algo).mul_SV_fwd (args[i][0], args[i][1], i); break;
	case MUL_SM: ((V&amp;) algo).mul_SM_fwd (args[i][0], args[i][1], i); break;
	case MUL_VV: ((V&amp;) algo).mul_VV_fwd (args[i][0], args[i][1], i); break;
	case MUL_MV: ((V&amp;) algo).mul_MV_fwd (args[i][0], args[i][1], i); break;
	case MUL_MM: ((V&amp;) algo).mul_MM_fwd (args[i][0], args[i][1], i); break;
	case MUL_VM: ((V&amp;) algo).mul_VM_fwd (args[i][0], args[i][1], i); break;
	case SUB:    ((V&amp;) algo).sub_fwd    (args[i][0], args[i][1], i); break;
	case SUB_V:  ((V&amp;) algo).sub_V_fwd  (args[i][0], args[i][1], i); break;
	case SUB_M:  ((V&amp;) algo).sub_M_fwd  (args[i][0], args[i][1], i); break;
	case DIV:    ((V&amp;) algo).div_fwd    (args[i][0], args[i][1], i); break;
	case MAX:    ((V&amp;) algo).max_fwd    (args[i][0], args[i][1], i); break;
	case MIN:    ((V&amp;) algo).min_fwd    (args[i][0], args[i][1], i); break;
	case ATAN2:  ((V&amp;) algo).atan2_fwd  (args[i][0], args[i][1], i); break;
	case GEN1:   ((V&amp;) algo).gen1_fwd   (args[i][0], i); break;
	case MINUS:  ((V&amp;) algo).minus_fwd  (args[i][0], i); break;
	case MINUS_V:((V&amp;) algo).minus_V_fwd(args[i][0], i); break;
	case MINUS_M:((V&amp;) algo).minus_M_fwd(args[i][0], i); break;
	case TRANS_V:((V&amp;) algo).trans_V_fwd(args[i][0], i); break;
	case TRANS_M:((V&amp;) algo).trans_M_fwd(args[i][0], i); break;
	case SIGN:   ((V&amp;) algo).sign_fwd   (args[i][0], i); break;
	case ABS:    ((V&amp;) algo).abs_fwd    (args[i][0], i); break;
	case POWER:  ((V&amp;) algo).power_fwd  (args[i][0], i, ((const ExprPower&amp;) (*nodes)[i]).expon); break;
	case SQR:    ((V&amp;) algo).sqr_fwd    (args[i][0], i); break;
	case SQRT:   ((V&amp;) algo).sqrt_fwd   (args[i][0], i); break;
	case EXP:    ((V&amp;) algo).exp_fwd    (args[i][0], i); break;
	case LOG:    ((V&amp;) algo).log_fwd    (args[i][0], i); break;
	case COS:    ((V&amp;) algo).cos_fwd    (args[i][0], i); break;
	case SIN:    ((V&amp;) algo).sin_fwd    (args[i][0], i); break;
	case TAN:    ((V&amp;) algo).tan_fwd    (args[i][0], i); break;
	case COSH:   ((V&amp;) algo).cosh_fwd   (args[i][0], i); break;
	case SINH:   ((V&amp;) algo).sinh_fwd   (args[i][0], i); break;
	case TANH:   ((V&amp;) algo).tanh_fwd   (args[i][0], i); break;
	case ACOS:   ((V&amp;) algo).acos_fwd   (args[i][0], i); break;
	case ASIN:   ((V&amp;) algo).asin_fwd   (args[i][0], i); break;
	case ATAN:   ((V&amp;) algo).atan_fwd   (args[i][0], i); break;
	case ACOSH:  ((V&amp;) algo).acosh_fwd  (args[i][0], i); break;
	case ASINH:  ((V&amp;) algo).asinh_fwd  (args[i][0], i); break;
	case ATANH:  ((V&amp;) algo).atanh_fwd  (args[i][0], i); break;
	case FLOOR:  ((V&amp;) algo).floor_fwd  (args[i][0], i); break;
	case CEIL:   ((V&amp;) algo).ceil_fwd   (args[i][0], i); break;
	case SAW:    ((V&amp;) algo).saw_fwd    (args[i][0], i); break;
	default: 	 assert(false);
	}
}

template&lt;class V&gt;
void CompiledFunction::backward(const V&amp; algo) const {

	assert(dynamic_cast&lt;const BwdAlgorithm* &gt;(&amp;algo)!=NULL);

	for (int i=0; i&lt;n; i++) {
		backward(algo, i);
	}
}

template&lt;class V&gt;
void CompiledFunction::backward(const V&amp; algo, const Agenda&amp; a) const {

	assert(dynamic_cast&lt;const BwdAlgorithm* &gt;(&amp;algo)!=NULL);

	for (int i=a.first(); i!=a.end(); i=a.next(i)) {
		backward(algo, i);
	}
}

template&lt;class V&gt;
void CompiledFunction::backward(const V&amp; algo, int i) const {
	switch(code[i]) {
	case IDX:    ((V&amp;) algo).idx_bwd    (args[i][0], i); break;
	case IDX_CP: ((V&amp;) algo).idx_cp_bwd (args[i][0], i); break;
	case VEC:    ((V&amp;) algo).vector_bwd (args[i], i); break;
	case SYM:    ((V&amp;) algo).symbol_bwd (i); break;
	case CST:    ((V&amp;) algo).cst_bwd    (i); break;
	case APPLY:  ((V&amp;) algo).apply_bwd  (args[i], i); break;
	case CHI:    ((V&amp;) algo).chi_bwd    (args[i][0], args[i][1], args[i][2], i); break;
	case GEN2:   ((V&amp;) algo).gen2_bwd   (args[i][0], args[i][1], i); break;
	case ADD:    ((V&amp;) algo).add_bwd    (args[i][0], args[i][1], i); break;
	case ADD_V:  ((V&amp;) algo).add_V_bwd  (args[i][0], args[i][1], i); break;
	case ADD_M:  ((V&amp;) algo).add_M_bwd  (args[i][0], args[i][1], i); break;
	case MUL:    ((V&amp;) algo).mul_bwd    (args[i][0], args[i][1], i); break;
	case MUL_SV: ((V&amp;) algo).mul_SV_bwd (args[i][0], args[i][1], i); break;
	case MUL_SM: ((V&amp;) algo).mul_SM_bwd (args[i][0], args[i][1], i); break;
	case MUL_VV: ((V&amp;) algo).mul_VV_bwd (args[i][0], args[i][1], i); break;
	case MUL_MV: ((V&amp;) algo).mul_MV_bwd (args[i][0], args[i][1], i); break;
	case MUL_MM: ((V&amp;) algo).mul_MM_bwd (args[i][0], args[i][1], i); break;
	case MUL_VM: ((V&amp;) algo).mul_VM_bwd (args[i][0], args[i][1], i); break;
	case SUB:    ((V&amp;) algo).sub_bwd    (args[i][0], args[i][1], i); break;
	case SUB_V:  ((V&amp;) algo).sub_V_bwd  (args[i][0], args[i][1], i); break;
	case SUB_M:  ((V&amp;) algo).sub_M_bwd  (args[i][0], args[i][1], i); break;
	case DIV:    ((V&amp;) algo).div_bwd    (args[i][0], args[i][1], i); break;
	case MAX:    ((V&amp;) algo).max_bwd    (args[i][0], args[i][1], i); break;
	case MIN:    ((V&amp;) algo).min_bwd    (args[i][0], args[i][1], i); break;
	case ATAN2:  ((V&amp;) algo).atan2_bwd  (args[i][0], args[i][1], i); break;
	case GEN1:   ((V&amp;) algo).gen1_bwd   (args[i][0], i); break;
	case MINUS:  ((V&amp;) algo).minus_bwd  (args[i][0], i); break;
	case MINUS_V:((V&amp;) algo).minus_V_bwd(args[i][0], i); break;
	case MINUS_M:((V&amp;) algo).minus_M_bwd(args[i][0], i); break;
	case TRANS_V:((V&amp;) algo).trans_V_bwd(args[i][0], i); break;
	case TRANS_M:((V&amp;) algo).trans_M_bwd(args[i][0], i); break;
	case SIGN:   ((V&amp;) algo).sign_bwd   (args[i][0], i); break;
	case ABS:    ((V&amp;) algo).abs_bwd    (args[i][0], i); break;
	case POWER:  ((V&amp;) algo).power_bwd  (args[i][0], i, ((const ExprPower&amp;) (*nodes)[i]).expon); break;
	case SQR:    ((V&amp;) algo).sqr_bwd    (args[i][0], i); break;
	case SQRT:   ((V&amp;) algo).sqrt_bwd   (args[i][0], i); break;
	case EXP:    ((V&amp;) algo).exp_bwd    (args[i][0], i); break;
	case LOG:    ((V&amp;) algo).log_bwd    (args[i][0], i); break;
	case COS:    ((V&amp;) algo).cos_bwd    (args[i][0], i); break;
	case SIN:    ((V&amp;) algo).sin_bwd    (args[i][0], i); break;
	case TAN:    ((V&amp;) algo).tan_bwd    (args[i][0], i); break;
	case COSH:   ((V&amp;) algo).cosh_bwd   (args[i][0], i); break;
	case SINH:   ((V&amp;) algo).sinh_bwd   (args[i][0], i); break;
	case TANH:   ((V&amp;) algo).tanh_bwd   (args[i][0], i); break;
	case ACOS:   ((V&amp;) algo).acos_bwd   (args[i][0], i); break;
	case ASIN:   ((V&amp;) algo).asin_bwd   (args[i][0], i); break;
	case ATAN:   ((V&amp;) algo).atan_bwd   (args[i][0], i); break;
	case ACOSH:  ((V&amp;) algo).acosh_bwd  (args[i][0], i); break;
	case ASINH:  ((V&amp;) algo).asinh_bwd  (args[i][0], i); break;
	case ATANH:  ((V&amp;) algo).atanh_bwd  (args[i][0], i); break;
	case FLOOR:  ((V&amp;) algo).floor_bwd  (args[i][0], i); break;
	case CEIL:   ((V&amp;) algo).ceil_bwd   (args[i][0], i); break;
	case SAW:    ((V&amp;) algo).saw_bwd    (args[i][0], i); break;
	default: 	 assert(false);
	}
}

} // namespace ibex

#endif // __IBEX_COMPILED_FUNCTION_H__
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
