
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 48, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-html.cpp</h3>
            <pre><code>1  void THtmlLxChDef::SetUcCh(const char& UcCh, const char& LcCh){
2    IAssert(
3     (UcChV[LcCh-TCh::Mn]==TCh(0))||
4     (UcChV[LcCh-TCh::Mn]==TCh(LcCh)));
5    UcChV[LcCh-TCh::Mn]=TCh(UcCh);
6    if ((LcChV[UcCh-TCh::Mn]==TCh(0))||(LcChV[UcCh-TCh::Mn]==TCh(UcCh))){
7      LcChV[UcCh-TCh::Mn]=TCh(LcCh);
8    }
9  }
10  void THtmlLxChDef::SetUcCh(const TStr& Str){
11    SetChTy(hlctAlpha, Str);
12    for (int ChN=1; ChN<Str.Len(); ChN++){
13      SetUcCh(Str[0], Str[ChN]);
14    }
15  }
16  void THtmlLxChDef::SetChTy(const THtmlLxChTy& ChTy, const TStr& Str){
17    for (int ChN=0; ChN<Str.Len(); ChN++){
18      ChTyV[Str[ChN]-TCh::Mn]=TInt(ChTy);}
19  }
20  void THtmlLxChDef::SetEscStr(const TStr& SrcStr, const TStr& DstStr){
21    EscStrH.AddDat(SrcStr, DstStr);
22  }
23  TStr THtmlLxChDef::GetEscStr(const TStr& Str) const {
24    int EscStrId;
25    if ((EscStrId=EscStrH.GetKeyId(Str))!=-1){
26      return EscStrH[EscStrId];
27    } else
28    if ((Str.Len()>=2)&&(Str[0]=='&')&&(Str[1]=='#')){
29      int ChCd=0;
30      for (int ChN=2; ChN<Str.Len(); ChN++){
<span onclick='openModal()' class='match'>31        if (ChCd<=0xFFFF){ChCd=ChCd*10+Str[ChN]-'0';}}
32      return TStr((char)ChCd);
33    } else {
34      return TStr(' ');
35    }
36  }
37  THtmlLxChDef::THtmlLxChDef():
38    ChTyV(TCh::Vals), UcChV(TCh::Vals), LcChV(TCh::Vals), EscStrH(100){
</span>39    ChTyV.PutAll(TInt(hlctSpace));
40    SetChTy(hlctAlpha, "ABCDEFGHIJKLMNOPQRSTUVWXYZ");
41    SetChTy(hlctAlpha, "abcdefghijklmnopqrstuvwxyz");
42    SetChTy(hlctAlpha, "@_");
43    SetChTy(hlctNum, "0123456789");
44    SetChTy(hlctSym, "`~!#$%^&*()-=+[{]}\\|;:'\",<.>/?");
45    SetChTy(hlctLTag, "<"); SetChTy(hlctRTag, ">");
46    SetChTy(hlctEof, TStr(TCh::EofCh));
47    for (int Ch=TCh::Mn; Ch<=TCh::Mx; Ch++){
48      if ((Ch<0)||(127<Ch)){SetChTy(hlctAlpha, TStr(TCh(char(Ch))));}}
49    {for (int Ch=TCh::Mn; Ch<=TCh::Mx; Ch++){
50      SetUcCh(char(Ch), char(Ch));}}
51    SetUcCh("Aa"); SetUcCh("\xc0\xe0"); SetUcCh("\xc1\xe1"); SetUcCh("\xc2\xe2");
52    SetUcCh("\xc3\xe3"); SetUcCh("\xc4\xe4"); SetUcCh("\xc5\xe5"); SetUcCh("\xc6\xe6");
53    SetUcCh("Bb"); SetUcCh("Cc"); SetUcCh("\xc7\xe7"); SetUcCh("Dd");
54    SetUcCh("\xd0\xf0"); SetUcCh("Ee"); SetUcCh("\xc8\xe8"); SetUcCh("\xc9\xe9");
55    SetUcCh("\xca\xea"); SetUcCh("\xcb\xeb"); SetUcCh("Ff"); SetUcCh("Gg");
56    SetUcCh("Hh"); SetUcCh("Ii"); SetUcCh("\xcc\xec"); SetUcCh("\xcd\xed");
57    SetUcCh("\xce\xee"); SetUcCh("\xcf\xef"); SetUcCh("Jj"); SetUcCh("Kk");
58    SetUcCh("Ll"); SetUcCh("Mm"); SetUcCh("Nn"); SetUcCh("\xd1\xf1");
59    SetUcCh("Oo"); SetUcCh("\xd2\xf2"); SetUcCh("\xd3\xf3"); SetUcCh("\xd4\xf4");
60    SetUcCh("\xd5\xf5"); SetUcCh("\xd6\xf6"); SetUcCh("\xd8\xf8"); SetUcCh("Pp");
61    SetUcCh("Qq"); SetUcCh("Rr"); SetUcCh("Ss"); SetUcCh("\x8a\x9a");
62    SetUcCh("Tt"); SetUcCh("Uu"); SetUcCh("\xd9\xf9"); SetUcCh("\xda\xfa");
63    SetUcCh("\xdb\xfb"); SetUcCh("\xdc\xfc"); SetUcCh("Vv"); SetUcCh("Ww");
64    SetUcCh("Xx"); SetUcCh("Yy\xff"); SetUcCh("\xdd\xfd"); SetUcCh("Zz");
65    SetUcCh("\x8e\x9e");
66    SetEscStr("&quot", "\""); SetEscStr("&amp", "&");
67    SetEscStr("&lt", "<"); SetEscStr("&gt", ">");
68    SetEscStr("&nbsp", " ");
69    SetEscStr("&auml", "\xe4"); SetEscStr("&Auml", "\xc4");
70    SetEscStr("&ouml", "\xf6"); SetEscStr("&Ouml", "\xd6");
71    SetEscStr("&uuml", "\xfc"); SetEscStr("&Uuml", "\xdc");
72    SetEscStr("&aring", "\xe5"); SetEscStr("&Aring", "\xc5");
73    SetEscStr("&oslash", "\xf8"); SetEscStr("&Oslash", "\xd8");
74    SetEscStr("&Aelig", "\xc6"); SetEscStr("&aelig", "\xe6");
75    SetEscStr("&eacute", "e"); SetEscStr("&Eacute", "E");
76    SetEscStr("&egrave", "e"); SetEscStr("&Egrave", "E");
77    SetEscStr("&agrave", "a"); SetEscStr("&Agrave", "A");
78  }
79  PHtmlLxChDef THtmlLxChDef::ChDef=PHtmlLxChDef(new THtmlLxChDef());
80  TStr THtmlLxChDef::GetCSZFromYuascii(const TChA& ChA){
81    TChA DstChA;
82    for (int ChN=0; ChN<ChA.Len(); ChN++){
83      char Ch=ChA[ChN];
84      switch (Ch){
85        case '~': DstChA+='c'; break;
86        case '^': DstChA+='C'; break;
87        case '}': DstChA+='c'; break;
88        case ']': DstChA+='C'; break;
89        case '|': DstChA+='d'; break;
90        case '\\': DstChA+='D'; break;
91        case '{': DstChA+='s'; break;
92        case '[': DstChA+='S'; break;
93        case '`': DstChA+='z'; break;
94        case '@': DstChA+='Z'; break;
95        default: DstChA+=Ch;
96      }
97    }
98    return DstChA;
99  }
100  TStr THtmlLxChDef::GetCSZFromWin1250(const TChA& ChA){
101    TChA DstChA;
102    for (int ChN=0; ChN<ChA.Len(); ChN++){
103      const uchar Ch=ChA[ChN];
104      switch (Ch){
105        case 232: DstChA+='c'; break;
106        case 200: DstChA+='C'; break;
107        case 154: DstChA+='s'; break;
108        case 138: DstChA+='S'; break;
109        case 158: DstChA+='z'; break;
110        case 142: DstChA+='Z'; break;
111        default: DstChA+=Ch;
112      }
113    }
114    return DstChA;
115  }
116  TStr THtmlLxChDef::GetWin1250FromYuascii(const TChA& ChA){
117    TChA DstChA;
118    for (int ChN=0; ChN<ChA.Len(); ChN++){
119      char Ch=ChA[ChN];
120      switch (Ch){
121        case '~': DstChA+=uchar(232); break;
122        case '^': DstChA+=uchar(200); break;
123        case '}': DstChA+='c'; break;
124        case ']': DstChA+='C'; break;
125        case '|': DstChA+='d'; break;
126        case '\\': DstChA+='D'; break;
127        case '{': DstChA+=uchar(154); break;
128        case '[': DstChA+=uchar(138); break;
129        case '`': DstChA+=uchar(158); break;
130        case '@': DstChA+=uchar(142); break;
131        default: DstChA+=Ch;
132      }
133    }
134    return DstChA;
135  }
136  TStr THtmlLxChDef::GetIsoCeFromYuascii(const TChA& ChA){
137    TChA DstChA;
138    for (int ChN=0; ChN<ChA.Len(); ChN++){
139      char Ch=ChA[ChN];
140      switch (Ch){
141        case '~': DstChA+=uchar(232); break;
142        case '^': DstChA+=uchar(200); break;
143        case '}': DstChA+=uchar(230); break;
144        case ']': DstChA+=uchar(198); break;
145        case '|': DstChA+=uchar(240); break;
146        case '\\': DstChA+=uchar(208); break;
147        case '{': DstChA+=uchar(185); break;
148        case '[': DstChA+=uchar(169); break;
149        case '`': DstChA+=uchar(190); break;
150        case '@': DstChA+=uchar(174); break;
151        default: DstChA+=Ch;
152      }
153    }
154    return DstChA;
155  }
156  THtmlLxChDef THtmlLx::ChDef;
157  void THtmlLx::GetEscCh(){
158    GetCh();
159    EscCh=(Ch=='&');
160    if (EscCh){
161      EscChA.Clr(); EscChA.AddCh(Ch); GetCh();
162      if (Ch=='#'){
163        EscChA.AddCh(Ch); GetCh();
164        if (('0'<=Ch)&&(Ch<='9')){
165          do {EscChA.AddCh(Ch); GetCh();} while (('0'<=Ch)&&(Ch<='9'));
166          if (Ch==';'){GetCh();}
167          PutStr(ChDef.GetEscStr(EscChA));
168        } else {
169          PutCh('#'); PutCh('&');
170        }
171      } else
172      if ((('a'<=Ch)&&(Ch<='z'))||(('A'<=Ch)&&(Ch<='Z'))){
173        do {
174          EscChA.AddCh(Ch); GetCh();
175        } while ((('A'<=Ch)&&(Ch<='Z'))||(('a'<=Ch)&&(Ch<='z'))||(('0'<=Ch)&&(Ch<='9')));
176        if (Ch==';'){
177          GetCh(); PutStr(ChDef.GetEscStr(EscChA));
178        } else {
179          PutStr(EscChA);
180        }      
181      } else {
182        PutCh('&');
183      }
184    }
185  }
186  void THtmlLx::GetMetaTag(){
187    Sym=hsyMTag;
188    if (Ch=='-'){
189      char PCh=' ';
190      while ((Ch!=TCh::EofCh) && ((PCh!='-')||(Ch!='>'))){PCh=Ch; GetCh();}
191    } else {
192      while ((Ch!=TCh::EofCh) && (Ch!='>')){GetCh();}
193    }
194    if (Ch!=TCh::EofCh){GetEscCh();}
195  }
196  void THtmlLx::GetTag(){
197    if (Ch=='/'){Sym=hsyETag; GetCh();} else {Sym=hsyBTag;}
198    UcChA.AddCh('<');
199    while (ChDef.IsAlNum(Ch)||(Ch==':')){
200      UcChA.AddCh(ChDef.GetUc(Ch)); GetCh();}
201    UcChA.AddCh('>');
202    ChA=UcChA;
203    if (DoParseArg){
204      while ((Ch!='>')&&(Ch!=TCh::EofCh)){
205        while ((!ChDef.IsAlpha(Ch))&&(Ch!='>')&&(Ch!=TCh::EofCh)){GetCh();}
206        if (ChDef.IsAlpha(Ch)){
207          ArgNm.Clr(); ArgVal.Clr();
208          while (ChDef.IsAlNum(Ch)||(Ch=='-')){ArgNm.AddCh(ChDef.GetUc(Ch)); GetCh();}
209          while (ChDef.IsWs(Ch)){GetCh();}
210          if (Ch=='='){
211            GetCh(); while (ChDef.IsWs(Ch)){GetCh();}
212            if (Ch=='"'){
213              GetCh();
214              while ((Ch!=TCh::EofCh)&&(Ch!='"')&&(Ch!='>')){
215                if (!ChDef.IsEoln(Ch)){ArgVal.AddCh(Ch);} GetCh();}
216              if (Ch=='"'){GetCh();}
217            } else if (Ch=='\''){
218              GetCh();
219              while ((Ch!=TCh::EofCh)&&(Ch!='\'')&&(Ch!='>')){
220                if (!ChDef.IsEoln(Ch)){ArgVal.AddCh(Ch);} GetCh();}
221              if (Ch=='\''){GetCh();}
222            } else {
223              while ((!ChDef.IsWs(Ch))&&(Ch!='>')&&(Ch!=TCh::EofCh)){
224                ArgVal.AddCh(Ch); GetCh();}
225            }
226            ArgNmValV.Add(TStrKd(ArgNm, ArgVal));
227          }
228        }
229      }
230    } else {
231      while ((Ch!='>')&&(Ch!=TCh::EofCh)){GetCh();}
232    }
233    if (Ch!=TCh::EofCh){GetEscCh();}
234  }
235  THtmlLxSym THtmlLx::GetSym(){
236    ChA.Clr(); UcChA.Clr();
237    PreSpaces=0; PreSpaceChA.Clr();
238    ArgNmValV.Clr();
239    while (ChDef.IsSpace(Ch)){
240      if (ChX>0){PreSpaceChA+=Ch; PreSpaces++;} GetEscCh();}
241    SymChA.Clr(); SymChA+=Ch; SymBChX=ChX;
242    switch (ChDef.GetChTy(Ch)){
243      case hlctAlpha:
244        Sym=hsyStr;
245        forever{
246          do {
247            ChA.AddCh(Ch); UcChA.AddCh(ChDef.GetUc(Ch)); GetEscCh();
248          } while (ChDef.IsAlNum(Ch));
249          if (Ch=='.'){
250            GetCh();
251            if (ChDef.IsAlNum(Ch)){ChA.AddCh('.'); UcChA.AddCh('.');}
252            else {PutCh(Ch); Ch='.'; break;}
253          } else {break;}
254        }
255        break;
256      case hlctNum:
257        Sym=hsyNum;
258        forever{
259          do {
260            ChA.AddCh(Ch); UcChA.AddCh(Ch); GetEscCh();
261          } while (ChDef.IsNum(Ch));
262          if (Ch=='.'){
263            GetCh();
264            if (ChDef.IsAlNum(Ch)){ChA.AddCh('.'); UcChA.AddCh('.');}
265            else {PutCh(Ch); Ch='.'; break;}
266          } else if (ChDef.IsAlpha(Ch)){
267            Sym=hsyStr;
268          } else {
269            break;
270          }
271        }
272        break;
273      case hlctSym:
274        Sym=hsySSym; ChA.AddCh(Ch); UcChA.AddCh(Ch); GetEscCh();
275        if ((ChA.LastCh()=='.')&&(ChDef.IsAlNum(Ch))){
276          Sym=hsyStr;
277          do {
278            ChA.AddCh(Ch); UcChA.AddCh(ChDef.GetUc(Ch)); GetEscCh();
279          } while (ChDef.IsAlNum(Ch));
280        }
281        break;
282      case hlctLTag:
283        if (EscCh){
284          Sym=hsySSym; ChA.AddCh(Ch); UcChA.AddCh(Ch); GetEscCh();
285        } else {
286          GetCh();
287          if (Ch=='!'){GetCh(); GetMetaTag();} else {GetTag();}
288        }
289        break;
290      case hlctRTag:
291        if (EscCh){
292          Sym=hsySSym; ChA.AddCh(Ch); UcChA.AddCh(Ch); GetEscCh();
293        } else {
294          Sym=hsySSym; ChA.AddCh(Ch); UcChA.AddCh(Ch);  GetEscCh();
295        }
296        break;
297      case hlctEof: Sym=hsyEof; break;
298      default: Sym=hsyUndef; GetEscCh();
299    }
300    SymEChX=ChX-1;
301    if (!SymChA.Empty()){SymChA.Pop();}
302    return Sym;
303  }
304  PHtmlTok THtmlLx::GetTok(const bool& DoUc){
305    if (DoUc){return PHtmlTok(new THtmlTok(Sym, UcChA, ArgNmValV));}
306    else {return PHtmlTok(new THtmlTok(Sym, ChA, ArgNmValV));}
307  }
308  TStr THtmlLx::GetFullBTagStr() const {
309    IAssert(Sym==hsyBTag);
310    TChA BTagChA;
311    BTagChA+=ChA; BTagChA.Pop();
312    for (int ArgN=0; ArgN<GetArgs(); ArgN++){
313      BTagChA+=' '; BTagChA+=GetArgNm(ArgN);
314      BTagChA+='='; BTagChA+='"'; BTagChA+=GetArgVal(ArgN); BTagChA+='"';
315    }
316    BTagChA+='>';
317    return BTagChA;
318  }
319  void THtmlLx::MoveToStrOrEof(const TStr& Str){
320    do {
321      GetSym();
322    } while ((Sym!=hsyEof)&&((Sym!=hsyStr)||(ChA!=Str)));
323  }
324  void THtmlLx::MoveToBTagOrEof(const TStr& TagNm){
325    do {
326      GetSym();
327    } while ((Sym!=hsyEof)&&((Sym!=hsyBTag)||(UcChA!=TagNm)));
328  }
329  void THtmlLx::MoveToBTag2OrEof(const TStr& TagNm1, const TStr& TagNm2){
330    do {
331      GetSym();
332    } while ((Sym!=hsyEof)&&((Sym!=hsyBTag)||((UcChA!=TagNm1)&&(UcChA!=TagNm2))));
333  }
334  void THtmlLx::MoveToBTag3OrEof(const TStr& TagNm1, const TStr& TagNm2, const TStr& TagNm3){
335    do {
336      GetSym();
337    } while ((Sym!=hsyEof)&&((Sym!=hsyBTag)||((UcChA!=TagNm1)&&(UcChA!=TagNm2)&&(UcChA!=TagNm3))));
338  }
339  void THtmlLx::MoveToBTagOrETagOrEof(const TStr& BTagNm, const TStr& ETagNm){
340    do {
341      GetSym();
342    } while ((Sym!=hsyEof) && ((Sym!=hsyBTag)||(UcChA!=BTagNm)) && ((Sym!=hsyETag) || (UcChA!=ETagNm)));
343  }
344  void THtmlLx::MoveToBTagArgOrEof(
345   const TStr& TagNm, const TStr& ArgNm, const TStr& ArgVal){
346    forever {
347      GetSym();
348      if (Sym==hsyEof){break;}
349      if ((Sym==hsyBTag)&&(UcChA==TagNm)&&
350       (IsArg(ArgNm))&&(GetArg(ArgNm)==ArgVal)){break;}
351    }
352  }
353  void THtmlLx::MoveToBTagArg2OrEof(const TStr& TagNm,
354   const TStr& ArgNm1, const TStr& ArgVal1,
355   const TStr& ArgNm2, const TStr& ArgVal2, const bool& AndOpP){
356    forever {
357      GetSym();
358      if (Sym==hsyEof){break;}
359      if (AndOpP){
360        if ((Sym==hsyBTag)&&(UcChA==TagNm)&&
361         (IsArg(ArgNm1))&&(GetArg(ArgNm1)==ArgVal1)&&
362         (IsArg(ArgNm2))&&(GetArg(ArgNm2)==ArgVal2)){break;}
363      } else {
364        if ((Sym==hsyBTag)&&(UcChA==TagNm)&&
365         (((IsArg(ArgNm1))&&(GetArg(ArgNm1)==ArgVal1))||
366          ((IsArg(ArgNm2))&&(GetArg(ArgNm2)==ArgVal2)))){break;}
367      }
368    }
369  }
370  void THtmlLx::MoveToBTagOrEof(
371   const TStr& TagNm1, const TStr& ArgNm1, const TStr& ArgVal1,
372   const TStr& TagNm2, const TStr& ArgNm2, const TStr& ArgVal2){
373    forever {
374      GetSym();
375      if (Sym==hsyEof){break;}
376      if ((Sym==hsyBTag)&&(UcChA==TagNm1)&&
377       (IsArg(ArgNm1))&&(GetArg(ArgNm1)==ArgVal1)){break;}
378      if ((Sym==hsyBTag)&&(UcChA==TagNm2)&&
379       (IsArg(ArgNm2))&&(GetArg(ArgNm2)==ArgVal2)){break;}
380    }
381  }
382  void THtmlLx::MoveToETagOrEof(const TStr& TagNm){
383    do {
384      GetSym();
385    } while ((Sym!=hsyEof)&&((Sym!=hsyETag)||(UcChA!=TagNm)));
386  }
387  TStr THtmlLx::GetTextOnlyStrToEof(){
388    TChA OutChA;
389    forever {
390      GetSym();
391      if (Sym==hsyEof){
392        break;
393      } else {
394        if (PreSpaces>0){OutChA+=' ';}
395        if ((Sym!=hsyBTag)&&(Sym!=hsyETag)){
396          OutChA+=ChA;}
397      }
398    }
399    return OutChA;
400  }
401  TStr THtmlLx::GetStrToBTag(const TStr& TagNm, const bool& TxtOnlyP){
402    TChA OutChA;
403    forever {
404      GetSym();
405      if ((Sym==hsyEof)||((Sym==hsyBTag)&&(UcChA==TagNm))){
406        break;
407      } else {
408        if (PreSpaces>0){OutChA+=' ';}
409        if ((TxtOnlyP&&(Sym!=hsyBTag)&&(Sym!=hsyETag))||(!TxtOnlyP)){
410          OutChA+=ChA;}
411      }
412    }
413    return OutChA;
414  }
415  TStr THtmlLx::GetStrToBTag(const TStr& TagNm, const TStr& ArgNm,
416   const TStr& ArgVal, const bool& TxtOnlyP){
417    TChA OutChA;
418    forever {
419      GetSym();
420      if ((Sym==hsyEof)||((Sym==hsyBTag)&&(UcChA==TagNm)&&
421       (IsArg(ArgNm))&&(GetArg(ArgNm)==ArgVal))){
422        break;
423      } else {
424        if (PreSpaces>0){OutChA+=' ';}
425        if ((TxtOnlyP&&(Sym!=hsyBTag)&&(Sym!=hsyETag))||(!TxtOnlyP)){
426          OutChA+=ChA;}
427      }
428    }
429    return OutChA;
430  }
431  TStr THtmlLx::GetStrToETag(const TStr& TagNm, const bool& TxtOnlyP){
432    TChA OutChA;
433    forever {
434      GetSym();
435      if ((Sym==hsyEof)||((Sym==hsyETag)&&(UcChA==TagNm))){
436        break;
437      } else {
438        if (PreSpaces>0){OutChA+=' ';}
439        if ((TxtOnlyP&&(Sym!=hsyBTag)&&(Sym!=hsyETag))||(!TxtOnlyP)){
440          OutChA+=ChA;}
441      }
442    }
443    return OutChA;
444  }
445  TStr THtmlLx::GetStrToETag2(const TStr& TagNm1, 
446   const TStr& TagNm2, const bool& TxtOnlyP){
447    TChA OutChA;
448    forever {
449      GetSym();
450      if ((Sym==hsyEof)||((Sym==hsyETag)&&(UcChA==TagNm1))||((Sym==hsyETag)&&(UcChA==TagNm2))){
451        break;
452      } else {
453        if (PreSpaces>0){OutChA+=' ';}
454        if ((TxtOnlyP&&(Sym!=hsyBTag)&&(Sym!=hsyETag))||(!TxtOnlyP)){
455          OutChA+=ChA;}
456      }
457    }
458    return OutChA;
459  }
460  TStr THtmlLx::GetStrInTag(const TStr& TagNm, const bool& TxtOnlyP){
461    MoveToBTagOrEof(TagNm);
462    return GetStrToETag(TagNm, TxtOnlyP);
463  }
464  TStr THtmlLx::GetHRefBeforeStr(const TStr& Str){
465    TStr HRefStr;
466    forever {
467      GetSym();
468      if (Sym==hsyEof){HRefStr=""; break;}
469      if ((Sym==hsyBTag)&&(UcChA=="<A>")){HRefStr=GetArg("HREF");}
470      if ((Sym==hsyStr)&&(ChA==Str)){break;}
471    }
472    return HRefStr;
473  }
474  bool THtmlLx::IsGetBTag(const TStr& TagNm){
475    if (GetSym()==hsyBTag){
476      return ChA==TagNm;
477    } else {return false;}
478  }
479  bool THtmlLx::IsGetETag(const TStr& TagNm){
480    if (GetSym()==hsyETag){
481      return ChA==TagNm;
482    } else {return false;}
483  }
484  TStr THtmlLx::GetSymStr(const THtmlLxSym& Sym){
485    switch (Sym){
486      case hsyUndef: return "Undef";
487      case hsyStr: return "Str";
488      case hsyNum: return "Num";
489      case hsySSym: return "SSym";
490      case hsyUrl: return "Url";
491      case hsyBTag: return "BTag";
492      case hsyETag: return "ETag";
493      case hsyMTag: return "MTag";
494      case hsyEof: return "Eof";
495      default: Fail; return TStr();
496    }
497  }
498  TStr THtmlLx::GetEscapedStr(const TChA& ChA){
499    TChA EscapedChA;
500    for (int ChN=0; ChN<ChA.Len(); ChN++){
501      char Ch=ChA[ChN];
502      switch (Ch){
503        case '"': EscapedChA+="&quot;"; break;
504        case '&': EscapedChA+="&amp;"; break;
505        case '\'': EscapedChA+="&apos;"; break;
506        case '<': EscapedChA+="&lt;"; break;
507        case '>': EscapedChA+="&gt;"; break;
508        default: EscapedChA+=Ch;
509      }
510    }
511    return EscapedChA;
512  }
513  TStr THtmlLx::GetAsciiStr(const TChA& ChA, const char& GenericCh){
514    TChA AsciiChA;
515    for (int ChN=0; ChN<ChA.Len(); ChN++){
516      char Ch=ChA[ChN];
517      if ((Ch<' ')||('~'<Ch)){
518        Ch=GenericCh;}
519      AsciiChA+=Ch;
520    }
521    return AsciiChA;
522  }
523  void THtmlLx::GetTokStrV(const TStr& Str, TStrV& TokStrV){
524    PSIn SIn=TStrIn::New(Str);
525    THtmlLx Lx(SIn);
526    Lx.GetSym();
527    TokStrV.Clr();
528    while (Lx.Sym!=hsyEof){
529      TokStrV.Add(Lx.ChA);
530      Lx.GetSym();
531    }
532  }
533  TStr THtmlLx::GetNoTag(const TStr& Str) {
534    PSIn SIn=TStrIn::New(Str);
535    THtmlLx Lx(SIn);
536    Lx.GetSym();
537    TChA ChA;
538    while (Lx.Sym!=hsyEof){
539      switch (Lx.Sym){
540  	  case hsyUndef: 
541  	  case hsyStr: 
542  	  case hsyNum: 
543  	  case hsySSym:
544  		if (Lx.PreSpaces > 0) { ChA += ' '; }
545  		ChA += Lx.ChA;
546  	  default: break;
547  	}
548  	Lx.GetSym();
549    }
550    return ChA;
551  }
552  TStr THtmlTok::GetFullStr() const {
553    if ((Sym==hsyBTag)&&(ArgNmValV.Len()>0)){
554      TChA FullChA;
555      FullChA+=Str.GetSubStr(0, Str.Len()-2);
556      for (int ArgNmValN=0; ArgNmValN<ArgNmValV.Len(); ArgNmValN++){
557        FullChA+=' '; FullChA+=ArgNmValV[ArgNmValN].Key; FullChA+='=';
558        FullChA+='"'; FullChA+=ArgNmValV[ArgNmValN].Dat; FullChA+='"';
559      }
560      FullChA+='>';
561      return FullChA;
562    } else
563    if (Sym==hsyETag){
564      TChA FullChA;
565      FullChA+='<'; FullChA+='/'; FullChA+=Str.GetSubStr(1, Str.Len()-1);
566      return FullChA;
567    } else {
568      return GetStr();
569    }
570  }
571  bool THtmlTok::IsUrlTok(TStr& RelUrlStr) const {
572    if (GetSym()==hsyBTag){
573      TStr TagNm=GetStr();
574      if ((TagNm==ATagNm)&&(IsArg(HRefArgNm))){
575        RelUrlStr=GetArg(HRefArgNm); return true;}
576      else if ((TagNm==AreaTagNm)&&(IsArg(HRefArgNm))){
577        RelUrlStr=GetArg(HRefArgNm); return true;}
578      else if ((TagNm==FrameTagNm)&&(IsArg(SrcArgNm))){
579        RelUrlStr=GetArg(SrcArgNm); return true;}
580      else if ((TagNm==ImgTagNm)&&(IsArg(SrcArgNm))){
581        RelUrlStr=GetArg(SrcArgNm); return true;}
582      else if ((TagNm==MetaTagNm)&&(IsArg(HttpEquivArgNm))){
583        TStr HttpEquivArgVal=GetArg(HttpEquivArgNm).GetUc();
584        if ((HttpEquivArgVal=="REFRESH")&&IsArg("CONTENT")){
585          TStr ContentStr=GetArg("CONTENT");
586          TStr LeftStr; TStr RightStr; TStr UrlEqStr="URL=";
587          ContentStr.GetUc().SplitOnStr(LeftStr, UrlEqStr, RightStr);
588          RelUrlStr=ContentStr.GetSubStr(
589           LeftStr.Len()+UrlEqStr.Len(), ContentStr.Len());
590          return !RelUrlStr.Empty();
591        } else {
592          return false;
593        }
594      }
595    }
596    return false;
597  }
598  bool THtmlTok::IsRedirUrlTok() const {
599    if (GetSym()==hsyBTag){
600      TStr TagNm=GetStr();
601      if ((TagNm==MetaTagNm)&&(IsArg(HttpEquivArgNm))){
602        TStr HttpEquivArgVal=GetArg(HttpEquivArgNm).GetUc();
603        if ((HttpEquivArgVal=="REFRESH")&&IsArg("CONTENT")){
604          return true;
605        } else {
606          return false;
607        }
608      }
609    }
610    return false;
611  }
612  void THtmlTok::SaveTxt(const PSOut& SOut, const bool& TxtMode){
613    if (TxtMode){
614      SOut->PutStr(GetFullStr()); SOut->PutStr(" ");
615    } else {
616      SOut->PutStr(THtmlLx::GetSymStr(Sym)); SOut->PutStr(" ");
617      SOut->PutStr(GetFullStr()); SOut->PutStr(" ");
618    }
619  }
620  const TStr THtmlTok::ATagNm="<A>";
621  const TStr THtmlTok::AreaTagNm="<AREA>";
622  const TStr THtmlTok::BrTagNm="<BR>";
623  const TStr THtmlTok::CardTagNm="<CARD>";
624  const TStr THtmlTok::CenterTagNm="<CENTER>";
625  const TStr THtmlTok::FrameTagNm="<FRAME>";
626  const TStr THtmlTok::H1TagNm="<H1>";
627  const TStr THtmlTok::H2TagNm="<H2>";
628  const TStr THtmlTok::H3TagNm="<H3>";
629  const TStr THtmlTok::H4TagNm="<H4>";
630  const TStr THtmlTok::H5TagNm="<H5>";
631  const TStr THtmlTok::H6TagNm="<H6>";
632  const TStr THtmlTok::ImgTagNm="<IMG>";
633  const TStr THtmlTok::LiTagNm="<LI>";
634  const TStr THtmlTok::MetaTagNm="<META>";
635  const TStr THtmlTok::PTagNm="<P>";
636  const TStr THtmlTok::UlTagNm="<UL>";
637  const TStr THtmlTok::TitleTagNm="<TITLE>";
638  const TStr THtmlTok::TitleETagNm="</TITLE>";
639  const TStr THtmlTok::AltArgNm="ALT";
640  const TStr THtmlTok::HRefArgNm="HREF";
641  const TStr THtmlTok::SrcArgNm="SRC";
642  const TStr THtmlTok::TitleArgNm="TITLE";
643  const TStr THtmlTok::HttpEquivArgNm="HTTP-EQUIV";
644  bool THtmlTok::IsBreakTag(const TStr& TagNm){
645    static TStrH BreakTagNmH(50);
646    if (BreakTagNmH.Len()==0){
647      BreakTagNmH.AddKey(TStr("<H1>")); BreakTagNmH.AddKey(TStr("<H2>"));
648      BreakTagNmH.AddKey(TStr("<H3>")); BreakTagNmH.AddKey(TStr("<H4>"));
649      BreakTagNmH.AddKey(TStr("<H5>")); BreakTagNmH.AddKey(TStr("<H6>"));
650      BreakTagNmH.AddKey(TStr("<BR>")); BreakTagNmH.AddKey(TStr("<HR>"));
651      BreakTagNmH.AddKey(TStr("<P>")); BreakTagNmH.AddKey(TStr("<DL>"));
652      BreakTagNmH.AddKey(TStr("<UL>")); BreakTagNmH.AddKey(TStr("<OL>"));
653      BreakTagNmH.AddKey(TStr("<LI>")); BreakTagNmH.AddKey(TStr("<DT>"));
654      BreakTagNmH.AddKey(TStr("<DD>")); BreakTagNmH.AddKey(TStr("<HEAD>"));
655      BreakTagNmH.AddKey(TStr("<TITLE>")); BreakTagNmH.AddKey(TStr("<META>"));
656      BreakTagNmH.AddKey(TStr("<SCRIPT>"));
657      BreakTagNmH.AddKey(TStr("<HEAD>")); BreakTagNmH.AddKey(TStr("<BODY>"));
658    }
659    return BreakTagNmH.IsKey(TagNm);
660  }
661  bool THtmlTok::IsBreakTok(const PHtmlTok& Tok){
662    if ((Tok->GetSym()==hsyBTag)||(Tok->GetSym()==hsyETag)){
663      return IsBreakTag(Tok->GetStr());
664    } else {
665      return false;
666    }
667  }
668  bool THtmlTok::IsHTag(const TStr& TagNm, int& HTagN){
669    if ((TagNm.Len()==4)&&(TagNm[0]=='<')&&(TagNm[1]=='H')&&(TagNm[3]=='>')){
670      char Ch=TagNm[2];
671      if (('1'<=Ch)&&(Ch<='6')){HTagN=Ch-'0'; return true;}
672      else {HTagN=-1; return false;}
673    } else {
674      HTagN=-1; return false;
675    }
676  }
677  PHtmlTok THtmlTok::GetHTok(const bool& IsBTag, const int& HTagN){
678    THtmlLxSym HTagSym=IsBTag?hsyBTag:hsyETag;
679    TStr HTagNm;
680    switch (HTagN){
681      case 1: HTagNm=H1TagNm; break;
682      case 2: HTagNm=H2TagNm; break;
683      case 3: HTagNm=H3TagNm; break;
684      case 4: HTagNm=H4TagNm; break;
685      case 5: HTagNm=H5TagNm; break;
686      case 6: HTagNm=H6TagNm; break;
687      default: Fail;
688    }
689    return PHtmlTok(new THtmlTok(HTagSym, HTagNm));
690  }
691  THtmlDoc::THtmlDoc(const PSIn& SIn, const THtmlDocType& Type, const bool& DoUc):
692    TokV(1000, 0){
693    THtmlLx Lx(SIn);
694    bool MkTok=false; bool InUL=false;
695    while (Lx.GetSym()!=hsyEof){
696      switch (Type){
697        case hdtAll: MkTok=true; break;
698        case hdtStr: MkTok=(Lx.Sym==hsyStr); break;
699        case hdtStrNum: MkTok=(Lx.Sym==hsyStr)||(Lx.Sym==hsyNum); break;
700        case hdtTag: MkTok=(Lx.Sym==hsyBTag)||(Lx.Sym==hsyETag); break;
701        case hdtA: MkTok=(Lx.Sym==hsyBTag)&&(Lx.UcChA==THtmlTok::ATagNm); break;
702        case hdtHRef:
703          MkTok=(Lx.Sym==hsyBTag)&&
704           ((Lx.UcChA==THtmlTok::ATagNm)||(Lx.UcChA==THtmlTok::AreaTagNm)||
705           (Lx.UcChA==THtmlTok::FrameTagNm)||(Lx.UcChA==THtmlTok::ImgTagNm)||
706           (Lx.UcChA==THtmlTok::MetaTagNm));
707          break;
708        case hdtUL:
709          if ((Lx.Sym==hsyBTag)&&(Lx.UcChA==THtmlTok::UlTagNm)){InUL=true;}
710          MkTok=InUL;
711          if ((Lx.Sym==hsyETag)&&(Lx.UcChA==THtmlTok::UlTagNm)){InUL=false;}
712          break;
713        default: Fail;
714      }
715      if (MkTok){TokV.Add(Lx.GetTok(DoUc));}
716    }
717    TokV.Add(PHtmlTok(new THtmlTok(hsyEof)));
718  }
719  TStr THtmlDoc::GetTxtLnDoc(const TStr& HtmlStr){
720    TChA LnDocChA;
721    PSIn HtmlSIn=TStrIn::New(HtmlStr);
722    THtmlLx HtmlLx(HtmlSIn);
723    bool InScript=false;
724    while (HtmlLx.GetSym()!=hsyEof){
725      TStr Str=HtmlLx.ChA;
726      switch (HtmlLx.Sym){
727        case hsyStr:
728        case hsyNum:
729        case hsySSym:
730          if (InScript){break;}
731          if (HtmlLx.PreSpaces>0){LnDocChA+=' ';}
732          LnDocChA+=Str.CStr();
733          break;
734        case hsyBTag:
735          if ((!LnDocChA.Empty())&&(LnDocChA.LastCh()!=' ')){LnDocChA+=' ';}
736          if ((!InScript)&&(Str=="<SCRIPT>")){InScript=true;}
737          break;
738        case hsyETag:
739          if ((!LnDocChA.Empty())&&(LnDocChA.LastCh()!=' ')){LnDocChA+=' ';}
740          if ((InScript)&&(Str=="<SCRIPT>")){InScript=false;}
741          break;
742        default: break;
743      }
744    }
745    return LnDocChA;
746  }
747  TStr THtmlDoc::GetTxtLnDoc(const TStr& HtmlStr, 
748   const TStr& BaseUrlStr, const bool& OutUrlP, const bool& OutTagsP){
749    TChA OutChA; OutChA+=' ';
750    PSIn HtmlSIn=TStrIn::New(HtmlStr);
751    THtmlLx HtmlLx(HtmlSIn);
752    bool InScript=false;
753    while (HtmlLx.GetSym()!=hsyEof){
754      TStr Str=HtmlLx.ChA;
755      switch (HtmlLx.Sym){
756        case hsyUndef:
757        case hsyUrl:
758        case hsyMTag:
759          break;
760        case hsyStr:
761        case hsyNum:
762        case hsySSym:
763          if (InScript){break;}
764          if (HtmlLx.PreSpaces>0){if (OutChA.LastCh()!=' '){OutChA+=' ';}}
765          OutChA+=Str;
766          break;
767        case hsyBTag:
768          Str=Str.GetSubStr(1, Str.Len()-2);
769          if (!InScript){
770            if (Str=="SCRIPT"){
771              InScript=true; break;}
772            if (OutTagsP){
773              OutChA+='<'; OutChA+=Str; OutChA+='>';
774            } else {
775              if (OutChA.LastCh()!=' '){OutChA+=' ';}
776            }
777            PHtmlTok Tok=HtmlLx.GetTok();
778            TStr RelUrlStr;
779            if (Tok->IsUrlTok(RelUrlStr)){
780              PUrl Url=TUrl::New(RelUrlStr, BaseUrlStr);
781              if (Url->IsOk()){
782                if (OutUrlP){
783                  TStr XmlUrlStr=TXmlLx::GetXmlStrFromPlainStr(Url->GetUrlStr());
784                  OutChA+="<Url>"; OutChA+=XmlUrlStr; OutChA+="</Url>";
785                }
786              }
787            }
788          }
789          break;
790        case hsyETag:
791          Str=Str.GetSubStr(1, Str.Len()-2);
792          if (InScript){
793            if (Str=="SCRIPT"){
794              InScript=false; break;}
795          } else {
796            if (OutTagsP){
797              OutChA+="</"; OutChA+=Str; OutChA+='>';
798            } else {
799              if (OutChA.LastCh()!=' '){OutChA+=' ';}
800            }
801          }
802          break;
803        case hsyEof: break;
804        default: Fail;
805      }
806    }
807    return OutChA;
808  }
809  void THtmlDoc::SaveTxt(const PSOut& SOut, const bool& TxtMode) const {
810    if (TxtMode){
811      for (int TokN=0; TokN<TokV.Len(); TokN++){TokV[TokN]->SaveTxt(SOut);}
812      SOut->PutLn();
813    } else {
814      for (int TokN=0; TokN<TokV.Len(); TokN++){
815        SOut->PutStr(TInt::GetStr(TokN)); SOut->PutStr(": ");
816        TokV[TokN]->SaveTxt(SOut);
817        SOut->PutLn();
818      }
819    }
820  }
821  void THtmlDoc::SaveHtmlToTxt(
822   const TStr& HtmlStr, const PSOut& TxtSOut, const TStr& BaseUrlStr,
823   const bool& OutUrlP, const bool& OutTagsP){
824    TStr TxtStr=GetTxtLnDoc(HtmlStr, BaseUrlStr, OutUrlP, OutTagsP);
825    TxtStr.SaveTxt(TxtSOut);
826  }
827  void THtmlDoc::SaveHtmlToTxt(
828   const TStr& HtmlStr, const TStr& TxtFNm, const TStr& BaseUrlStr,
829   const bool& OutUrlP, const bool& OutTagsP){
830    PSOut TxtSOut=TFOut::New(TxtFNm);
831    SaveHtmlToTxt(HtmlStr, TxtSOut, BaseUrlStr, OutUrlP, OutTagsP);
832  }
833  void THtmlDoc::SaveHtmlToXml(
834   const TStr& HtmlStr, const PSOut& XmlSOut, const TStr& BaseUrlStr,
835   const bool& OutTextP, const bool& OutUrlP, const bool& OutToksP,
836   const bool& OutTagsP, const bool& OutArgsP){
837    TFileId fXml=XmlSOut->GetFileId();
838    TStrV OutUrlStrV;
839    fprintf(fXml, "<HtmlDoc>\n");
840    if (!BaseUrlStr.Empty()){
841      TStr XmlBaseUrlStr=TXmlLx::GetXmlStrFromPlainStr(BaseUrlStr);
842      fprintf(fXml, "<BaseUrl>%s</BaseUrl>\n", XmlBaseUrlStr.CStr());
843    }
844    PSIn HtmlSIn=TStrIn::New(HtmlStr);
845    THtmlLx HtmlLx(HtmlSIn);
846    TChA ContTextChA; bool InScript=false;
847    fprintf(fXml, "<Body>\n");
848    while (HtmlLx.GetSym()!=hsyEof){
849      TStr Str=HtmlLx.ChA;
850      switch (HtmlLx.Sym){
851        case hsyUndef:
852        case hsyUrl:
853        case hsyMTag:
854          break;
855        case hsyStr:
856          if (InScript){break;}
857          Str=TXmlLx::GetXmlStrFromPlainStr(Str);
858          if (OutToksP){
859            fprintf(fXml, "  <Str>%s</Str>\n", Str.CStr());}
860          if (!ContTextChA.Empty()){ContTextChA+=' ';} ContTextChA+=Str;
861          break;
862        case hsyNum:
863          if (InScript){break;}
864          Str=TXmlLx::GetXmlStrFromPlainStr(Str);
865          if (OutToksP){
866            fprintf(fXml, "  <Num>%s</Num>\n", Str.CStr());}
867          if (!ContTextChA.Empty()){ContTextChA+=' ';} ContTextChA+=Str;
868          break;
869        case hsySSym:
870          if (InScript){break;}
871          Str=TXmlLx::GetXmlStrFromPlainStr(Str);
872          if (OutToksP){
873            fprintf(fXml, "  <Sym>%s</Sym>\n", Str.CStr());}
874          if (!ContTextChA.Empty()){ContTextChA+=' ';} ContTextChA+=Str;
875          break;
876        case hsyBTag:{
877          if (!ContTextChA.Empty()){
878            if (OutTextP){
879              fprintf(fXml, "  <Text>%s</Text>\n", ContTextChA.CStr());}
880            ContTextChA.Clr();
881          }
882          Str=Str.GetSubStr(1, Str.Len()-2);
883          Str=TXmlLx::GetXmlStrFromPlainStr(Str);
884          if (!InScript){
885            if (Str=="SCRIPT"){
886              InScript=true; break;}
887            if (OutTagsP){
888              if (OutArgsP){
889                fprintf(fXml, "  <BTag Nm=\"%s\">\n", Str.CStr());
890                for (int ArgN=0; ArgN<HtmlLx.GetArgs(); ArgN++){
891                  TStr ArgNm=TXmlLx::GetXmlStrFromPlainStr(HtmlLx.GetArgNm(ArgN));
892                  TStr ArgVal=TXmlLx::GetXmlStrFromPlainStr(HtmlLx.GetArgVal(ArgN));
893                  fprintf(fXml, "    <Arg Nm=\"%s\" Val=\"%s\"/>", ArgNm.CStr(), ArgVal.CStr());
894                }
895                fprintf(fXml, "  </BTag>\n");
896              } else {
897                fprintf(fXml, "  <BTag Nm=\"%s\"/>\n", Str.CStr());
898              }
899            }
900            PHtmlTok Tok=HtmlLx.GetTok();
901            TStr RelUrlStr;
902            if (Tok->IsUrlTok(RelUrlStr)){
903              PUrl Url=TUrl::New(RelUrlStr, BaseUrlStr);
904              if (Url->IsOk()){
905                OutUrlStrV.Add(Url->GetUrlStr());
906                if (OutUrlP){
907                  TStr XmlUrlStr=TXmlLx::GetXmlStrFromPlainStr(Url->GetUrlStr());
908                  fprintf(fXml, "  <Url>%s</Url>\n", XmlUrlStr.CStr());
909                }
910              }
911            }
912          }
913          break;}
914        case hsyETag:{
915          if (!ContTextChA.Empty()){
916            if (OutTextP){
917              fprintf(fXml, "  <Text>%s</Text>\n", ContTextChA.CStr());}
918            ContTextChA.Clr();
919          }
920          Str=Str.GetSubStr(1, Str.Len()-2);
921          Str=TXmlLx::GetXmlStrFromPlainStr(Str);
922          if (InScript){
923            if (Str=="SCRIPT"){
924              InScript=false; break;}
925          } else {
926            if (OutTagsP){
927              fprintf(fXml, "  <ETag Nm=\"%s\"/>\n", Str.CStr());}
928          }
929          break;}
930        case hsyEof: break;
931        default: Fail;
932      }
933    }
934    if (!ContTextChA.Empty()){
935      if (OutTextP){
936        fprintf(fXml, "  <Text>%s</Text>\n", ContTextChA.CStr());}
937      ContTextChA.Clr();
938    }
939    fprintf(fXml, "</Body>\n");
940    fprintf(fXml, "<OutUrls>\n");
941    for (int UrlN=0; UrlN<OutUrlStrV.Len(); UrlN++){
942      TStr XmlUrlStr=TXmlLx::GetXmlStrFromPlainStr(OutUrlStrV[UrlN]);
943      fprintf(fXml, "  <Url N=\"%d\">%s</Url>\n", 1+UrlN, XmlUrlStr.CStr());
944    }
945    fprintf(fXml, "</OutUrls>\n");
946    fprintf(fXml, "</HtmlDoc>\n");
947  }
948  void THtmlDoc::SaveHtmlToXml(
949   const TStr& HtmlStr, const TStr& XmlFNm, const TStr& BaseUrlStr,
950   const bool& OutTextP, const bool& OutUrlP, const bool& OutToksP,
951   const bool& OutTagsP, const bool& OutArgsP){
952    PSOut XmlSOut=TFOut::New(XmlFNm);
953    SaveHtmlToXml(HtmlStr, XmlSOut, BaseUrlStr, OutTextP, OutUrlP,
954     OutToksP, OutTagsP, OutArgsP);
955  }
956  TLxSym THtmlDoc::GetLxSym(const THtmlLxSym& HtmlLxSym, const TChA& ChA){
957    switch (HtmlLxSym){
958      case hsyUndef: return syUndef;
959      case hsyStr: return syStr;
960      case hsyNum: return syFlt;
961      case hsySSym: return TLxSymStr::GetSSym(ChA);
962      case hsyUrl: return syStr;
963      case hsyBTag: return syStr;
964      case hsyETag: return syStr;
965      case hsyEof: return syEof;
966      default: Fail; return syUndef;
967    }
968  }
969  bool THtmlDoc::_IsTagRedir(
970   const TStr& TagStr, const TStr& ArgNm, THtmlLx& Lx,
971   const TStr& BaseUrlStr, const TStr& RedirUrlStr){
972    IAssert(Lx.Sym==hsyBTag);
973    if ((Lx.ChA==TagStr)&&(Lx.IsArg(ArgNm))){
974      TStr RelUrlStr=Lx.GetArg(ArgNm);
975      PUrl Url=TUrl::New(RelUrlStr, BaseUrlStr);
976      if (Url->IsOk(usHttp)){
977        TStr UrlStr=Url->GetUrlStr();
978        PUrlEnv RedirUrlEnv=TUrlEnv::New(RedirUrlStr, "url", UrlStr);
979        Lx.PutArg(ArgNm, RedirUrlEnv->GetFullUrlStr());
980        return true;
981      } else {
982        return false;
983      }
984    } else {
985      return false;
986    }
987  }
988  TStr THtmlDoc::GetRedirHtmlDocStr(const TStr& HtmlStr,
989   const TStr& BaseUrlStr, const TStr& RedirUrlStr){
990    PSIn SIn=TStrIn::New(HtmlStr);
991    TMOut SOut;
992    THtmlLx Lx(SIn);
993    while (Lx.GetSym()!=hsyEof){
994      SOut.PutStr(Lx.PreSpaceChA);
995      if ((Lx.Sym==hsyBTag)&&(
996       (_IsTagRedir(THtmlTok::ATagNm, THtmlTok::HRefArgNm, Lx, BaseUrlStr, RedirUrlStr))||
997       (_IsTagRedir(THtmlTok::AreaTagNm, THtmlTok::HRefArgNm, Lx, BaseUrlStr, RedirUrlStr))||
998       (_IsTagRedir(THtmlTok::FrameTagNm, THtmlTok::SrcArgNm, Lx, BaseUrlStr, RedirUrlStr))||
999       (_IsTagRedir(THtmlTok::ImgTagNm, THtmlTok::SrcArgNm, Lx, BaseUrlStr, RedirUrlStr)))){
1000        SOut.PutStr(Lx.GetFullBTagStr());
1001      } else {
1002        SOut.PutStr(Lx.SymChA());
1003      }
1004    }
1005    return SOut.GetAsStr();
1006  }
1007  THtmlHldV::THtmlHldV(const PHtmlDoc& _RefHtmlDoc, const int& HldWnLen):
1008    RefHtmlDoc(_RefHtmlDoc), HldV(){
1009    bool IsTitleAct=false; THtmlTokV TitleTokV;
1010    bool IsHAct=false; int ActHTagN=-1;
1011    TVec<THtmlTokV> HTokV(6);
1012    PHtmlTok Tok; THtmlLxSym TokSym; TStr TokStr;
1013    for (int TokN=0; TokN<RefHtmlDoc->GetToks(); TokN++){
1014      Tok=RefHtmlDoc->GetTok(TokN, TokSym, TokStr);
1015      if ((TokSym==hsyBTag)&&(TokStr==THtmlTok::ATagNm)){
1016        int ATokN; PHtmlTok ATok; THtmlLxSym ATokSym; TStr ATokStr;
1017        THtmlTokV ATokV; ATokN=TokN;
1018        forever{
1019          ATok=RefHtmlDoc->GetTok(ATokN, ATokSym, ATokStr);
1020          if (ATokSym!=hsySSym){ATokV.Add(ATok);}
1021          if ((ATokSym==hsyETag)&&(ATokStr==THtmlTok::ATagNm)){break;}
1022          ATokN++;
1023          if (ATokN>=RefHtmlDoc->GetToks()){break;}
1024        }
1025        int ETagATokN=ATokN+1;
1026        THtmlTokV PrevATokV; ATokN=TokN;
1027        forever{
1028          ATokN--;
1029          if (ATokN<0){break;}
1030          ATok=RefHtmlDoc->GetTok(ATokN, ATokSym, ATokStr);
1031          if (THtmlTok::IsBreakTok(ATok)){break;}
1032          if ((ATokSym==hsyStr)||(ATokSym==hsyNum)){PrevATokV.Add(ATok);}
1033          if (ATokV.Len()>=HldWnLen){break;}
1034        }
1035        THtmlTokV NextATokV; ATokN=ETagATokN;
1036        forever{
1037          ATokN++;
1038          if (ATokN>=RefHtmlDoc->GetToks()){break;}
1039          ATok=RefHtmlDoc->GetTok(ATokN, ATokSym, ATokStr);
1040          if (THtmlTok::IsBreakTok(ATok)){break;}
1041          if ((ATokSym==hsyStr)||(ATokSym==hsyNum)){NextATokV.Add(ATok);}
1042          if (ATokV.Len()>=HldWnLen){break;}
1043        }
1044        PHtmlDoc HtmlDoc=PHtmlDoc(new THtmlDoc());
1045        HtmlDoc->AddTokV(TitleTokV);
1046        for (int HTagN=1; HTagN<=6; HTagN++){HtmlDoc->AddTokV(HTokV[HTagN-1]);}
1047        HtmlDoc->AddTokV(PrevATokV);
1048        HtmlDoc->AddTokV(ATokV);
1049        HtmlDoc->AddTokV(NextATokV);
1050        HldV.Add(HtmlDoc);
1051        HtmlDoc->SaveTxt(TSOut::StdOut);
1052      } else
1053      if (TokSym==hsyBTag){
1054        int HTagN;
1055        if (TokStr==THtmlTok::TitleTagNm){
1056          IsTitleAct=true; TitleTokV.Clr(); TitleTokV.Add(Tok);
1057        } else
1058        if (THtmlTok::IsHTag(TokStr, HTagN)){
1059          if (IsHAct){
1060            HTokV[ActHTagN-1].Add(THtmlTok::GetHTok(false, ActHTagN));}
1061          IsHAct=true; ActHTagN=HTagN;
1062          {for (int HTagN=ActHTagN; HTagN<=6; HTagN++){HTokV[HTagN-1].Clr();}}
1063          HTokV[ActHTagN-1].Add(Tok);
1064        }
1065      } else
1066      if (TokSym==hsyETag){
1067        int HTagN;
1068        if (TokStr==THtmlTok::TitleTagNm){
1069          if (IsTitleAct){TitleTokV.Add(Tok); IsTitleAct=false;}
1070        } else
1071        if (THtmlTok::IsHTag(TokStr, HTagN)){
1072          if (IsHAct){HTokV[ActHTagN-1].Add(Tok); IsHAct=false;}
1073        }
1074      } else
1075      if (TokSym!=hsySSym){
1076        if (IsTitleAct){TitleTokV.Add(Tok);}
1077        if (IsHAct){HTokV[ActHTagN-1].Add(Tok);}
1078      }
1079    }
1080  }
1081  void TWebPg::GetOutUrlV(TUrlV& OutUrlV, TUrlV& OutRedirUrlV) const {
1082    OutUrlV.Clr(); OutRedirUrlV.Clr();
1083    TStr UrlStr=GetUrlStr();
1084    TStr HtmlStr=GetHttpBodyAsStr();
1085    PSIn HtmlSIn=TStrIn::New(HtmlStr);
1086    PHtmlDoc HtmlDoc=THtmlDoc::New(HtmlSIn);
1087    PHtmlTok Tok;
1088    for (int TokN=0; TokN<HtmlDoc->GetToks(); TokN++){
1089      PHtmlTok Tok=HtmlDoc->GetTok(TokN);
1090      if (Tok->GetSym()==hsyBTag){
1091        TStr RelUrlStr;
1092        if (Tok->IsUrlTok(RelUrlStr)){
1093          PUrl Url=TUrl::New(RelUrlStr, UrlStr);
1094          if (Url->IsOk(usHttp)){
1095            OutUrlV.Add(Url);
1096            if (Tok->IsRedirUrlTok()){
1097              OutRedirUrlV.Add(Url);
1098            }
1099          }
1100        }
1101      }
1102    }
1103  }
1104  void TWebPg::GetOutDescUrlStrKdV(TStrKdV& OutDescUrlStrKdV) const {
1105    OutDescUrlStrKdV.Clr();
1106    TStr UrlStr=GetUrlStr();
1107    TStr HtmlStr=GetHttpBodyAsStr();
1108    PSIn HtmlSIn=TStrIn::New(HtmlStr);
1109    PHtmlDoc HtmlDoc=THtmlDoc::New(HtmlSIn);
1110    PHtmlTok Tok; THtmlLxSym TokSym; TStr TokStr;
1111    int TokN=0; int Toks=HtmlDoc->GetToks();
1112    while (TokN<Toks){
1113      Tok=HtmlDoc->GetTok(TokN, TokSym, TokStr); TokN++;
1114      if ((TokSym==hsyBTag)&&(TokStr==THtmlTok::ATagNm)){
1115        TStr RelUrlStr;
1116        if (Tok->IsUrlTok(RelUrlStr)){
1117          PUrl Url=TUrl::New(RelUrlStr, UrlStr);
1118          if (Url->IsOk()){
1119            TChA DescChA;
1120            while (TokN<Toks){
1121              Tok=HtmlDoc->GetTok(TokN, TokSym, TokStr); TokN++;
1122              if ((TokSym==hsyETag)&&(TokStr==THtmlTok::ATagNm)){
1123                break;
1124              } else {
1125                if ((TokSym==hsyStr)||(TokSym==hsyNum)||(TokSym==hsySSym)){
1126                  if (!DescChA.Empty()){DescChA+=' ';}
1127                  DescChA+=TokStr;
1128                }
1129              }
1130            }
1131            OutDescUrlStrKdV.Add(TStrKd(DescChA, Url->GetUrlStr()));
1132          }
1133        }
1134      }
1135    }
1136  }
1137  void TWebPg::SaveAsHttpBody(const TStr& FNm) const {
1138    PSOut SOut=TFOut::New(FNm);
1139    HttpResp->SaveBody(SOut);
1140  }
1141  void TWebPg::SaveAsHttp(const TStr& FNm) const {
1142    PSOut SOut=TFOut::New(FNm);
1143    HttpResp->SaveTxt(SOut);
1144  }
1145  bool TWebPg::IsTxt() const {
1146    if ((!HttpResp->IsContType())||HttpResp->IsContType(THttp::TextFldVal)){
1147      TStr Str=HttpResp->GetBodyAsStr();
1148      int StrLen=Str.Len(); int ChN=0; int PrintChs=0;
1149      while ((ChN<100)&&(ChN<StrLen)){
1150        char Ch=Str[ChN++];
1151        if (((' '<=Ch)&&(Ch<='~'))||(Ch==TCh::TabCh)||(Ch==TCh::LfCh)||(Ch==TCh::CrCh)){
1152          PrintChs++;}
1153      }
1154      double PrintPrb=double(PrintChs)/double(ChN+1);
1155      return PrintPrb>0.9;
1156    } else {
1157      return false;
1158    }
1159  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-sskj.cpp</h3>
            <pre><code>1  #include "sskj.h"
2  void TSskjLxChDef::SetUcCh(const TStr& Str){
3    for (int ChN=1; ChN<Str.Len(); ChN++){UcChV[Str[ChN]-TCh::Mn]=TCh(Str[0]);}}
4  void TSskjLxChDef::SetChTy(const TSskjLxChTy& ChTy, const TStr& Str){
5    for (int ChN=0; ChN<Str.Len(); ChN++){ChTyV[Str[ChN]-TCh::Mn]=TInt(ChTy);}}
6  void TSskjLxChDef::SetEscStr(const TStr& SrcStr, const TStr& DstStr){
7    EscStrH.AddDat(SrcStr, DstStr);}
8  TStr TSskjLxChDef::GetEscStr(const TStr& Str){
9    int EscStrId;
10    if ((EscStrId=EscStrH.GetKeyId(Str))!=-1){
11      return EscStrH[EscStrId];
12    } else
13    if ((Str.Len()>=2)&&(Str[0]=='&')&&(Str[1]=='#')){
14      int ChCd=0;
15      for (int ChN=2; ChN<Str.Len(); ChN++){
<span onclick='openModal()' class='match'>16        if (ChCd<=0xFFFF){ChCd=ChCd*10+Str[ChN]-'0';}}
17      return TStr((char)ChCd);
18    } else {
19      return TStr(' ');
20    }
21  }
22  TSskjLxChDef::TSskjLxChDef():
23    ChTyV(TCh::Vals), UcChV(TCh::Vals), EscStrH(100){
</span>24    ChTyV.PutToAll(TInt(hlctSpace));
25    SetChTy(hlctAlpha, "ABCDEFGHIJKLMNOPQRSTUVWXYZ");
26    SetChTy(hlctAlpha, "abcdefghijklmnopqrstuvwxyz");
27    SetChTy(hlctAlpha, "~^{[@`}]\\|");
28    SetChTy(hlctNum, "0123456789");
29    SetChTy(hlctSym, "!#$%&*()-=+;:'\",./?");
30    SetChTy(hlctLTag, "<"); SetChTy(hlctRTag, ">");
31    SetChTy(hlctEof, EofCh);
32    for (int Ch=TCh::Mn; Ch<=TCh::Mx; Ch++){
33      if ((Ch<0)||(Ch>127)){SetChTy(hlctAlpha, TStr(TCh(char(Ch))));}}
34    {for (int Ch=TCh::Mn; Ch<=TCh::Mx; Ch++){UcChV[Ch-TCh::Mn]=TCh(char(Ch));}}
35    SetUcCh("Aa"); SetUcCh("\xc0\xe0"); SetUcCh("\xc1\xe1"); SetUcCh("\xc2\xe2");
36    SetUcCh("\xc3\xe3"); SetUcCh("\xc4\xe4"); SetUcCh("\xc5\xe5"); SetUcCh("\xc6\xe6");
37    SetUcCh("Bb"); SetUcCh("Cc"); SetUcCh("\xc7\xe7"); SetUcCh("Dd");
38    SetUcCh("\xd0\xf0"); SetUcCh("Ee"); SetUcCh("\xc8\xe8"); SetUcCh("\xc9\xe9");
39    SetUcCh("\xca\xea"); SetUcCh("\xcb\xeb"); SetUcCh("Ff"); SetUcCh("Gg");
40    SetUcCh("Hh"); SetUcCh("Ii"); SetUcCh("\xcc\xec"); SetUcCh("\xcd\xed");
41    SetUcCh("\xce\xee"); SetUcCh("\xcf\xef"); SetUcCh("Jj"); SetUcCh("Kk");
42    SetUcCh("Ll"); SetUcCh("Mm"); SetUcCh("Nn"); SetUcCh("\xd1\xf1");
43    SetUcCh("Oo"); SetUcCh("\xd2\xf2"); SetUcCh("\xd3\xf3"); SetUcCh("\xd4\xf4");
44    SetUcCh("\xd5\xf5"); SetUcCh("\xd6\xf6"); SetUcCh("\xd8\xf8"); SetUcCh("Pp");
45    SetUcCh("Qq"); SetUcCh("Rr"); SetUcCh("Ss"); SetUcCh("Tt");
46    SetUcCh("Uu"); SetUcCh("\xd9\xf9"); SetUcCh("\xda\xfa"); SetUcCh("\xdb\xfb");
47    SetUcCh("\xdc\xfc"); SetUcCh("Vv"); SetUcCh("Ww"); SetUcCh("Xx");
48    SetUcCh("Yy\xff"); SetUcCh("\xdd\xfd"); SetUcCh("Zz");
49    SetEscStr("&quot", "\""); SetEscStr("&amp", "&");
50    SetEscStr("&lt", "<"); SetEscStr("&gt", ">");
51    SetEscStr("&nbsp", " ");
52    SetEscStr("&auml", "\xe4"); SetEscStr("&Auml", "\xc4");
53    SetEscStr("&ouml", "\xf6"); SetEscStr("&Ouml", "\xd6");
54    SetEscStr("&uuml", "\xfc"); SetEscStr("&Uuml", "\xdc");
55    SetEscStr("&aring", "\xe5"); SetEscStr("&Aring", "\xc5");
56    SetEscStr("&oslash", "\xf8"); SetEscStr("&Oslash", "\xd8");
57    SetEscStr("&Aelig", "\xc6"); SetEscStr("&aelig", "\xe6");
58    SetEscStr("&eacute", "e"); SetEscStr("&Eacute", "E");
59    SetEscStr("&egrave", "e"); SetEscStr("&Egrave", "E");
60    SetEscStr("&agrave", "a"); SetEscStr("&Agrave", "A");
61  }
62  TSskjLxChDef TSskjLx::ChDef;
63  void TSskjLx::GetCh(){
64    if (ChStack.Empty()){
65      Ch=(SIn->Eof()) ? EofCh : SIn->GetCh();
66    } else {
67      Ch=ChStack.Pop();
68    }
69    if ((Ch==CrCh)||(Ch==LfCh)){GetCh();}
70  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-html.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-sskj.cpp</div>
                </div>
                <div class="column column_space"><pre><code>31        if (ChCd<=0xFFFF){ChCd=ChCd*10+Str[ChN]-'0';}}
32      return TStr((char)ChCd);
33    } else {
34      return TStr(' ');
35    }
36  }
37  THtmlLxChDef::THtmlLxChDef():
38    ChTyV(TCh::Vals), UcChV(TCh::Vals), LcChV(TCh::Vals), EscStrH(100){
</pre></code></div>
                <div class="column column_space"><pre><code>16        if (ChCd<=0xFFFF){ChCd=ChCd*10+Str[ChN]-'0';}}
17      return TStr((char)ChCd);
18    } else {
19      return TStr(' ');
20    }
21  }
22  TSskjLxChDef::TSskjLxChDef():
23    ChTyV(TCh::Vals), UcChV(TCh::Vals), EscStrH(100){
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    