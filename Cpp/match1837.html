<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for ibex_Interval.h &amp; vibes.cpp</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for ibex_Interval.h &amp; vibes.cpp
      </h3>
<h1 align="center">
        1.6%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>ibex_Interval.h (1.1100832%)<th>vibes.cpp (3.217158%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(164-216)<td><a href="#" name="0">(228-230)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>ibex_Interval.h</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#ifndef _IBEX_INTERVAL_H_
#define _IBEX_INTERVAL_H_
#include &lt;array&gt;
#include &lt;math.h&gt;
#include "ibex_Exception.h"
#include "ibex_Setting.h"
#include "ibex_IntervalLibWrapper.h"
#define NEG_INFINITY IBEX_INTERVAL_LIB_NEG_INFINITY
#define POS_INFINITY IBEX_INTERVAL_LIB_POS_INFINITY
#ifdef _MSC_VER
#include &lt;intrin.h&gt;
#define __builtin_popcount __popcnt
#define __builtin_powi(__x,__n) ((double)::pow((double)(__x),(int)(__n)))
#endif 
namespace ibex {
class IntervalVector;
class IntervalMatrix;
class ExprConstant;
void fpu_round_down();
void fpu_round_up();
void fpu_round_near();
void fpu_round_zero();
double previous_float(double x);
double next_float(double x);
class Interval {
  public:
    Interval();
    Interval(double a, double b);
    Interval(double a);
    Interval(std::array&lt;double, 1&gt; array);
    Interval(std::array&lt;double, 2&gt; array);
    bool operator==(const Interval&amp; x) const;
    bool operator!=(const Interval&amp; x) const;
    void set_empty();
    Interval&amp; operator=(const Interval&amp; x);
    Interval&amp; operator=(double x);
    Interval&amp; operator&amp;=(const Interval&amp; x);
    Interval&amp; operator|=(const Interval&amp; x);
    Interval&amp; inflate(double rad);
	Interval&amp; inflate(double delta, double chi);
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    double lb() const;
    double ub() const;
    double mid() const;
    double rad() const;
    double diam() const;
    double mig() const;
    double mag() const;</b></font>
    bool is_subset(const Interval&amp; x) const;
    bool is_strict_subset(const Interval&amp; x) const;
    bool is_interior_subset(const Interval&amp; x) const;
    bool is_relative_interior_subset(const Interval&amp; x) const;
    bool is_strict_interior_subset(const Interval&amp; x) const;
    bool is_superset(const Interval&amp; x) const;
    bool is_strict_superset(const Interval&amp; x) const;
    bool contains(const double&amp; d) const;
    bool interior_contains(const double&amp; d) const;
    bool intersects(const Interval &amp;x) const;
    bool overlaps(const Interval &amp;x) const;
    bool is_disjoint(const Interval &amp;x) const;
    bool is_empty() const;
    bool is_degenerated() const;
    bool is_unbounded() const;
    bool is_bisectable() const;
    double rel_distance(const Interval&amp; x) const;
    int complementary(Interval&amp; c1, Interval&amp; c2, bool compactness = true) const;
    int diff(const Interval&amp; y, Interval&amp; c1, Interval&amp; c2, bool compactness = true) const;
    Interval operator-() const;
    Interval&amp; operator+=(double d);
    Interval&amp; operator-=(double d);
    Interval&amp; operator*=(double d);
    Interval&amp; operator/=(double d);
    Interval&amp; operator+=(const Interval&amp; x);
    Interval&amp; operator-=(const Interval&amp; x);
    Interval&amp; operator*=(const Interval&amp; x);
    Interval&amp; operator/=(const Interval&amp; x);
    bool div2_inter(const Interval&amp; x, const Interval&amp; y, Interval&amp; out2);
    Interval&amp; div2_inter(const Interval&amp; x, const Interval&amp; y);
    double delta(const Interval&amp; x) const;
    double ratiodelta(const Interval&amp; x) const;
    std::pair&lt;Interval,Interval&gt; bisect(double ratio=0.5) const;
    static const Interval PI;
    static const Interval&amp; pi();
    static const Interval TWO_PI;
    static const Interval&amp; two_pi();
    static const Interval HALF_PI;
    static const Interval&amp; half_pi();
    static const Interval EMPTY_SET;
    static const Interval&amp; empty_set();
    static const Interval ALL_REALS;
    static const Interval&amp; all_reals();
    static const Interval ZERO;
    static const Interval&amp; zero();
    static const Interval ONE;
    static const Interval&amp; one();
    static const Interval POS_REALS;
    static const Interval&amp; pos_reals();
    static const Interval NEG_REALS;
    static const Interval&amp; neg_reals();
    typedef Interval SCALAR;
    typedef IntervalVector VECTOR;
    typedef IntervalMatrix MATRIX;
    operator const ExprConstant&amp;() const;
    Interval(const interval_type_wrapper&amp; x);
    Interval&amp; operator=(const interval_type_wrapper&amp; x);
    interval_type_wrapper itv;
};
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Interval&amp; x);
Interval operator&amp;(const Interval&amp; x1, const Interval&amp; x2);
Interval operator|(const Interval&amp; x1, const Interval&amp; x2);
Interval operator+(const Interval&amp; x, double d);
Interval operator-(const Interval&amp; x, double d);
Interval operator*(const Interval&amp; x, double d);
Interval operator/(const Interval&amp; x, double d);
void div2(const Interval&amp; x, const Interval&amp; y, Interval&amp; out1, Interval&amp; out2);
Interval operator+(double d,const Interval&amp; x);
Interval operator-(double d, const Interval&amp; x);
Interval operator*(double d, const Interval&amp; x);
Interval operator/(double d, const Interval&amp; x);
Interval operator+(const Interval&amp; x1, const Interval&amp; x2);
Interval operator-(const Interval&amp; x1, const Interval&amp; x2);
Interval operator*(const Interval&amp; x1, const Interval&amp; x2);
Interval operator/(const Interval&amp; x1, const Interval&amp; x2);
double distance(const Interval &amp;x1, const Interval &amp;x2);
Interval sqr(const Interval&amp; x);
Interval sqrt(const Interval&amp; x);
Interval pow(const Interval&amp; x, int n);
Interval pow(const Interval&amp; x, double d);
Interval pow(const Interval &amp;x, const Interval &amp;y);
Interval root(const Interval&amp; x, int n);
Interval exp(const Interval&amp; x);
Interval log(const Interval&amp; x);
Interval cos(const Interval&amp; x);
Interval sin(const Interval&amp; x);
Interval tan(const Interval&amp; x);
Interval acos(const Interval&amp; x);
Interval asin(const Interval&amp; x);
Interval atan(const Interval&amp; x);
Interval atan2(const Interval&amp; y, const Interval&amp; x);
Interval cosh(const Interval&amp; x);
Interval sinh(const Interval&amp; x);
Interval tanh(const Interval&amp; x);
Interval acosh(const Interval&amp; x);
Interval asinh(const Interval&amp; x);
Interval atanh(const Interval&amp; x);
Interval abs(const Interval &amp;x);
Interval max(const Interval&amp; x, const Interval&amp; y);
Interval min(const Interval&amp; x, const Interval&amp; y);
Interval sign(const Interval&amp; x);
Interval chi(const Interval&amp; a, const Interval&amp; b, const Interval&amp; c);
Interval integer(const Interval&amp; x);
Interval floor(const Interval&amp; x);
Interval ceil(const Interval&amp; x);
Interval saw(const Interval&amp; x);
bool bwd_add(const Interval&amp; y, Interval&amp; x1, Interval&amp; x2);
bool bwd_sub(const Interval&amp; y, Interval&amp; x1, Interval&amp; x2);
bool bwd_mul(const Interval&amp; y, Interval&amp; x1, Interval&amp; x2);
bool bwd_div(const Interval&amp; y, Interval&amp; x1, Interval&amp; x2);
bool bwd_sqr(const Interval&amp; y, Interval&amp; x);
bool bwd_sqrt(const Interval&amp; y, Interval&amp; x);
bool bwd_pow(const Interval&amp; y, int n, Interval&amp; x);
bool bwd_pow(const Interval&amp; y, Interval&amp; x1, Interval&amp; x2);
bool bwd_root(const Interval&amp; y, int n, Interval&amp; x);
bool bwd_exp(const Interval&amp; y,  Interval&amp; x);
bool bwd_log(const Interval&amp; y,  Interval&amp; x);
bool bwd_cos(const Interval&amp; y,  Interval&amp; x);
bool bwd_sin(const Interval&amp; y,  Interval&amp; x);
bool bwd_tan(const Interval&amp; y,  Interval&amp; x);
bool bwd_acos(const Interval&amp; y,  Interval&amp; x);
bool bwd_asin(const Interval&amp; y,  Interval&amp; x);
bool bwd_atan(const Interval&amp; y,  Interval&amp; x);
bool bwd_atan2(const Interval&amp; y, Interval&amp; x1, Interval&amp; x2);
bool bwd_cosh(const Interval&amp; y,  Interval&amp; x);
bool bwd_sinh(const Interval&amp; y,  Interval&amp; x);
bool bwd_tanh(const Interval&amp; y,  Interval&amp; x);
bool bwd_acosh(const Interval&amp; y,  Interval&amp; x);
bool bwd_asinh(const Interval&amp; y,  Interval&amp; x);
bool bwd_atanh(const Interval&amp; y,  Interval&amp; x);
bool bwd_abs(const Interval&amp; y,  Interval&amp; x);
bool bwd_max(const Interval&amp; y, Interval&amp; x1, Interval&amp; x2);
bool bwd_min(const Interval&amp; y, Interval&amp; x1, Interval&amp; x2);
bool bwd_sign(const Interval&amp; y, Interval&amp; x);
bool bwd_chi(const Interval&amp; f, Interval&amp; a, Interval&amp; b, Interval&amp; c);
bool bwd_floor(const Interval&amp; y, Interval&amp; x);
bool bwd_ceil(const Interval&amp; y, Interval&amp; x);
bool bwd_saw(const Interval&amp; y, Interval&amp; x);
bool bwd_imod(Interval&amp; x, Interval&amp; y, const double&amp; p);
} 
#include "ibex_IntervalLibWrapper.inl"
namespace ibex {
inline bool ___is_empty(double)             { return false; }
inline bool ___is_empty(const Interval&amp; x)  { return x.is_empty(); }
inline void ___set_empty(double)            { }
inline void ___set_empty(Interval&amp; x)       { x.set_empty(); }
inline double ___abs(double x)              { return fabs(x);}
inline Interval ___abs(const Interval&amp; x)   { return abs(x);}
inline double ___mag(double x)              { return fabs(x);}
inline double ___mag(const Interval&amp; x)     { return x.mag();}
inline Interval::Interval() : itv(NEG_INFINITY, POS_INFINITY) {
}
inline Interval::Interval(double a, double b) : itv(a,b) {
	if (a==POS_INFINITY || b==NEG_INFINITY || a&gt;b) *this=EMPTY_SET;
}
inline Interval::Interval(double a) : itv(a,a) {
	if (a==NEG_INFINITY || a==POS_INFINITY) *this=EMPTY_SET;
}
inline Interval::Interval(std::array&lt;double, 1&gt; array): Interval(array[0]) {}
inline Interval::Interval(std::array&lt;double, 2&gt; array): Interval(array[0], array[1]) {}
inline bool Interval::operator==(const Interval&amp; x) const {
	return (is_empty() &amp;&amp; x.is_empty()) || (lb()==x.lb() &amp;&amp; ub()==x.ub());
}
inline Interval&amp; Interval::operator=(double x) {
	if (x==NEG_INFINITY || x==POS_INFINITY)
		*this=EMPTY_SET;
	else
		itv = x;
	return *this;
}
inline Interval&amp; Interval::operator=(const Interval&amp; x) {
	itv = x.itv;
	return *this;
}
inline Interval&amp; Interval::inflate(double radd) {
	(*this) += Interval(-radd,radd);
	return *this;
}
inline Interval&amp; Interval::inflate(double delta, double chi) {
	double m=mid();
	(*this) = m + delta*(*this-m)+Interval(-chi,chi);
	return *this;
}
inline bool Interval::operator!=(const Interval&amp; x) const {
	return !(*this==x);
}
inline double Interval::rad() const {
	if (is_empty()) return 0;
	else if (is_unbounded()) return POS_INFINITY;
	else {
		double t = mid();
		double t1 =(t-*this).ub();
		double t2= (*this-t).ub();
		return (t1&gt;t2) ? t1 : t2;
	}
}
inline bool Interval::is_bisectable() const {
	if (is_empty()) return false;
	double m=mid();
	return (lb()&lt;m &amp;&amp; m&lt;ub());
}
inline double Interval::rel_distance(const Interval&amp; x) const {
	  double d=distance(*this,x);
	  if (d==POS_INFINITY) return 1;
	  double D=diam();
	  return (D==0 || D==POS_INFINITY) ? 0.0 : (d/D); }
inline double distance(const Interval &amp;x1, const Interval &amp;x2) {
    if (x1.is_empty()) return x2.rad();
    if (x2.is_empty()) return x1.rad();
    if (x1.lb()==NEG_INFINITY) {
    	if (x2.lb()!=NEG_INFINITY)
    		return POS_INFINITY;
    	else if (x1.ub()==POS_INFINITY) {
    		if (x2.ub()==POS_INFINITY) return 0.0;
    		else return POS_INFINITY;
    	}
    	else if (x2.ub()==POS_INFINITY) return POS_INFINITY;
    	else return fabs(x1.ub()-x2.ub());
    }
    else if (x1.ub()==POS_INFINITY) {
    	if (x2.ub()!=POS_INFINITY)
    		return POS_INFINITY;
    	else if (x2.lb()==NEG_INFINITY)
    		return POS_INFINITY;
    	else return fabs(x1.lb()-x2.lb());
    }
    else if (x2.is_unbounded())
    	return POS_INFINITY;
    else
    	return _interval_distance_wrapper (x1.itv, x2.itv);
}
inline Interval sign(const Interval&amp; x) {
	return x.ub()&lt;0 ? Interval(-1,-1) : x.lb()&gt;0 ? Interval(1,1) : Interval(-1,1);
}
inline Interval chi(const Interval&amp; a, const Interval&amp; b, const Interval&amp; c){
	if (a.ub()&lt;=0) {
		return b;
	} else if (a.lb()&gt;0) {
		return c;
	} else {
		return b|c;
	}
}
inline Interval atan2(const Interval&amp; y, const Interval&amp; x) {
	if (y.is_empty() || x.is_empty()) return Interval::empty_set();
	else if (x==Interval::zero()) {
		if (y.lb()&gt;=0)
			if (y.ub()==0) return Interval::empty_set(); 			else return Interval::half_pi();
		else if (y.ub()&lt;=0) return -Interval::half_pi();
		else return Interval(-1,1)*Interval::half_pi();
	}
	else if (x.lb()&gt;=0) {
		return atan(y/x); 	}
	else if (x.ub()&lt;=0) {
		if (y.lb()&gt;=0)
			return atan(y/x)+Interval::pi(); 		else if (y.ub()&lt;0)
			return atan(y/x)-Interval::pi();
		else
			return Interval(-1,1)*Interval::pi();
	} else {
		if (y.lb()&gt;=0)
			return atan(y/x.ub()) | (atan(y/x.lb()) + Interval::pi());
		else if (y.ub()&lt;=0){
			if(x.lb()!=NEG_INFINITY){
				if(x.ub()!=POS_INFINITY){
					return (atan(y/x.lb())-Interval::pi()) | atan(y/x.ub());
				}
				else
					return (atan(y/x.lb())-Interval::pi()) | Interval::zero();
			}
			else{
				if(x.ub()!=POS_INFINITY)
					return (-Interval::pi()) | atan(y/x.ub());
				else
					return -Interval::pi() | Interval::zero();
			}
		}
		else
			return Interval(-1,1)*Interval::pi();
	}
}
inline bool bwd_add(const Interval&amp; y, Interval&amp; x1, Interval&amp; x2) {
	if ((x1 &amp;= y-x2).is_empty()) { x2.set_empty(); return false; }
	if ((x2 &amp;= y-x1).is_empty()) { x1.set_empty(); return false; }
	return true;
}
inline bool bwd_sub(const Interval&amp; y, Interval&amp; x1, Interval&amp; x2) {
	if ((x1 &amp;= y+x2).is_empty()) { x2.set_empty(); return false; }
	if ((x2 &amp;= x1-y).is_empty()) { x1.set_empty(); return false; }
	return true;
}
inline bool bwd_div(const Interval&amp; y, Interval&amp; x1, Interval&amp; x2) {
	if ((x1 &amp;= y*x2).is_empty()) { x2.set_empty(); return false; }
	Interval tmp=y;
	bwd_mul(x1, tmp, x2);
	if (x2.is_empty()) { x1.set_empty(); return false; }
	return true;
}
inline bool bwd_sqrt(const Interval&amp; y, Interval&amp; x) {
	if (y.is_empty() || y.ub()&lt;0) {
		x.set_empty();
	} else if (y.lb()&lt;0) {
		x &amp;= sqr(Interval(0,y.ub()));
	} else  {
		x &amp;= sqr(y);
	}
	return !x.is_empty();
}
inline bool bwd_root(const Interval&amp; y, int n, Interval&amp; x) {
	x &amp;= pow(y,n);
	return !x.is_empty();
}
inline bool bwd_exp(const Interval&amp; y,  Interval&amp; x) {
	x &amp;= log(y);
	return !x.is_empty();
}
inline bool bwd_log(const Interval&amp; y,  Interval&amp; x) {
	x &amp;= exp(y);
	return !x.is_empty();
}
inline bool bwd_acos(const Interval&amp; y,  Interval&amp; x) {
	x &amp;= cos(y);
	return !x.is_empty();
}
inline bool bwd_asin(const Interval&amp; y,  Interval&amp; x) {
	x &amp;= sin(y);
	return !x.is_empty();
}
inline bool bwd_atan(const Interval&amp; y,  Interval&amp; x) {
	if (y.is_empty()) {
		x.set_empty();
		return false;
	}
	Interval z=y;
	double pi2l=(Interval::pi()/2).lb();
	double pi2u=(Interval::pi()/2).ub();
	if (z.ub()&gt;=pi2l) 		if (z.lb()&gt;=pi2u)
			x.set_empty();
		else {
			if (z.lb()&gt;-pi2l) {
				x &amp;= Interval(tan(Interval(z.lb())).lb(),POS_INFINITY);
			}
		}
	else
		if (z.ub()&lt;=-pi2u)
			x.set_empty();
		else if (z.lb()&lt;-pi2l)
			x &amp;= Interval(NEG_INFINITY,tan(Interval(z.ub())).ub());
		else
			x &amp;= Interval(tan(Interval(z.lb())).lb(),
					tan(Interval(z.ub())).ub());
	return !x.is_empty();
}
inline bool bwd_acosh(const Interval&amp; y,  Interval&amp; x) {
	if (y.is_empty() || y.ub()&lt;0.0) {
		x.set_empty(); return false;
	}
	else {
		x &amp;= cosh(Interval(y.lb()&lt;0?0:y.lb(),y.ub()));
		return !x.is_empty();
	}
}
inline bool bwd_asinh(const Interval&amp; y,  Interval&amp; x) {
	x &amp;= sinh(y);
	return !x.is_empty();
}
inline bool bwd_atanh(const Interval&amp; y,  Interval&amp; x) {
	x &amp;= tanh(y);
	return !x.is_empty();
}
inline bool bwd_max(const Interval&amp; y, Interval&amp; x1, Interval&amp; x2) {
	if (y.is_empty()) {
		x1.set_empty();
		x2.set_empty();
		return false;
	}
	if (x2.lb()&gt;x1.ub() || y.lb()&gt;x1.ub()) {
		if ((x2 &amp;= y).is_empty()) { x1.set_empty(); return false;}
		else return true;
	} else if (x1.lb()&gt;x2.ub() || y.lb()&gt;x2.ub()) {
		if ((x1 &amp;= y).is_empty()) { x2.set_empty(); return false;}
		else return true;
	}
	if (y.ub()&lt;x1.lb() || y.ub()&lt;x2.lb()) {
		x1.set_empty();
		x2.set_empty();
		return false; 	}
	if (x1.ub()&gt;y.ub())
		x1=Interval(x1.lb(),y.ub());
	if (x2.ub()&gt;y.ub())
		x2=Interval(x2.lb(),y.ub());
	return true;
}
inline bool bwd_min(const Interval&amp; y, Interval&amp; x1, Interval&amp; x2) {
	Interval mx1=-x1;
	Interval mx2=-x2;
	if (!bwd_max(-y,mx1,mx2)) {
		x1.set_empty();
		x2.set_empty();
		return false;
	}
	x1=-mx1;
	x2=-mx2;
	return true;
}
inline bool bwd_sign(const Interval&amp; y,  Interval&amp; x) {
	if (y.is_empty()) {
		x.set_empty();
		return false;
	}
	if(y.lb()&gt;0)
		x &amp;= Interval::pos_reals();
	else if(y.ub()&lt;0)
		x &amp;= Interval::neg_reals();
	return !x.is_empty();
}
inline bool bwd_atan2(const Interval&amp; theta, Interval&amp; y, Interval&amp; x) {
	Interval theta_xpos = theta  &amp; Interval(-1,1)*Interval::half_pi();
	Interval theta_xneg_ypos = theta  &amp; (Interval::half_pi() | Interval::pi());
	Interval theta_xneg_yneg = theta  &amp; -(Interval::half_pi() | Interval::pi());
	Interval xres= Interval::empty_set();
	Interval yres= Interval::empty_set();
	if (!theta_xpos.is_empty()) {
		Interval xpos=x &amp; Interval::pos_reals();
		Interval yall=y;
		if (theta_xneg_ypos.is_empty() || theta_xneg_yneg.is_empty()) { 			Interval z=yall/xpos;
			bwd_atan(theta_xpos,z);
			bwd_div(z,yall,xpos);
		}
		xres |= xpos;
		yres |= yall;
		if (theta_xpos.lb()&gt;=Interval::half_pi().lb()) {
			xres |= (x &amp; Interval::zero());
			yres |= (y &amp; Interval::pos_reals());
		} else if (theta_xpos.ub()&lt;=-Interval::half_pi().lb()) {
			xres |= (x &amp; Interval::zero());
			yres |= (y &amp; Interval::neg_reals());
		}
	}
	if (!theta_xneg_ypos.is_empty()) {
		Interval xneg=x &amp; Interval::neg_reals();
		Interval ypos=y &amp; Interval::pos_reals();
		Interval z=ypos/xneg;
		bwd_atan(theta_xneg_ypos - Interval::pi(),z);
		bwd_div(z,ypos,xneg);
		xres |= xneg;
		yres |= ypos;	}
	if (!theta_xneg_yneg.is_empty()) {
		Interval xneg=x &amp; Interval::neg_reals();
		Interval yneg=y &amp; Interval::neg_reals();
		Interval z=yneg/xneg;
		bwd_atan(theta_xneg_yneg + Interval::pi(),z);
		bwd_div(z,yneg,xneg);
		xres |= xneg;
		yres |= yneg;
	}
	x=xres;
	y=yres;
	return !x.is_empty();
}
inline bool bwd_chi(const Interval&amp; f, Interval&amp; a, Interval&amp; b, Interval&amp; c){
	if      (a.ub()&lt;=0) {if ((b &amp;= f).is_empty()) { a.set_empty(); c.set_empty(); return false; } }
	else if (a.lb()&gt;0)  {if ((c &amp;= f).is_empty()) { a.set_empty(); b.set_empty(); return false; } }
	if (f.is_disjoint(b)) {
		if ((a &amp;= Interval::pos_reals()).is_empty()) { b.set_empty(); c.set_empty(); return false; }
		if ((c &amp;= f).is_empty()) { a.set_empty(); b.set_empty(); return false; }
	}
	if (f.is_disjoint(c)) {
		if ((a &amp;= Interval::neg_reals()).is_empty()) { b.set_empty(); c.set_empty(); return false; }
		if ((b &amp;= f).is_empty()) { a.set_empty(); c.set_empty(); return false; }
	}
	return true;
}
inline bool bwd_floor(const Interval&amp; y, Interval&amp; x) {
	if (y.is_empty()) {
		x.set_empty();
		return false;
	} else {
		double r=std::floor(y.ub());
		double l=std::ceil(y.lb());
		if (r&lt;l) {
			x.set_empty();
			return false;
		}
		else {
			x &amp;= Interval(l,r) + Interval(0,1);
			return !x.is_empty();
		}
	}
}
inline bool bwd_ceil(const Interval&amp; y, Interval&amp; x) {
	if (y.is_empty()) {
		x.set_empty();
		return false;
	} else {
		double r=std::floor(y.ub());
		double l=std::ceil(y.lb());
		if (r&lt;l) {
			x.set_empty();
			return false;
		}
		else {
			x &amp;= Interval(l,r) + Interval(-1,0);
			return !x.is_empty();
		}
	}
}
inline bool bwd_imod(Interval&amp; x, Interval&amp; y, const double&amp; p) {
    if (p &lt;= 0.)
    {
        ibex_error("Modulo needs a strictly positive period p.");
        return false;
    }
    if (y.diam()&gt;p || x.diam()&gt;p)
        return false;
    Interval r = (x-y)/p;
    Interval ir = integer(r);
    if (ir.is_empty())     {
        x.set_empty(); y.set_empty();
        return false;
    }
    if (ir.is_degenerated())
        bwd_sub(ir*p,x,y);
    else if (ir.diam()==1.)
    {
        double ir1 = ir.lb();
        double ir2 = ir.ub();
        Interval x1 = x; Interval x2 = x;
        Interval y1 = y; Interval y2 = y;
        bwd_sub(Interval(ir1*p),x1,y1);
        bwd_sub(Interval(ir2*p),x2,y2);
        x = x1 | x2;
        y = y1 | y2;
    }
    else
    {
        ibex_error("Modulo diameter error.");
        return false;
    }
    return true;
}
} 
#endif </pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>vibes.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include "vibes.h"
#include &lt;sstream&gt;
#include &lt;cstdlib&gt;
#include &lt;cstdio&gt;
#include &lt;cassert&gt;
namespace vibes {
    std::string Value::toJSONString() const {
        std::ostringstream ss;
        switch (_type) {
        case vt_integer:
            ss&lt;&lt;_integer; break;
        case vt_decimal:
            ss&lt;&lt;_decimal; break;
        case vt_string:
            ss&lt;&lt;'"'&lt;&lt;_string&lt;&lt;'"'; break;
        case vt_array:
            ss &lt;&lt; '[';
            for (std::vector&lt;Value&gt;::const_iterator it = _array.begin(); it != _array.end(); ++it) {
                if (it != _array.begin()) ss &lt;&lt; ',';
                ss &lt;&lt; it-&gt;toJSONString();
            }
            ss &lt;&lt; ']';
            break;
        case vt_object:
            ss &lt;&lt; '{' &lt;&lt; _object-&gt;toJSON() &lt;&lt; '}';
            break;
        case vt_none:
        default:
            break;
        }
        return ss.str();
    }
    std::string Params::toJSON() const {
        std::ostringstream ss;
        for(std::map&lt;std::string, Value&gt;::const_iterator it = _values.begin(); it != _values.end(); ++it)
            ss &lt;&lt; (it==_values.begin()?"":", ") &lt;&lt; "\"" &lt;&lt; it-&gt;first &lt;&lt; "\":" &lt;&lt; it-&gt;second.toJSONString();
        return ss.str();
    }
    Value Params::pop(const std::string &amp;key, const Value &amp;value_not_found) {
        KeyValueMap::iterator it = _values.find(key);
        if (it == _values.end())
            return value_not_found;
        Value val = it-&gt;second;
        _values.erase(it);
        return val;
    }
}
using namespace std;
namespace vibes
{
  FILE *channel=0;
  string current_fig="default";
  void beginDrawing()
  {
      char * user_dir = getenv("USERPROFILE");       if (!user_dir)
          user_dir = getenv("HOME");       if (user_dir)
      {           std::string file_name(user_dir);
          file_name.append("/.vibes.json");
          beginDrawing(file_name);
      }
      else
      {           beginDrawing("vibes.json");
      }
  }
  void beginDrawing(const std::string &amp;fileName)
  {
    channel=fopen(fileName.c_str(),"a");
  }
  void endDrawing()
  {
    fclose(channel);
  }
  void newFigure(const std::string &amp;figureName)
  {
    std::string msg;
    if (!figureName.empty()) current_fig = figureName;
    msg ="{\"action\":\"new\","
          "\"figure\":\""+(figureName.empty()?current_fig:figureName)+"\"}\n\n";
    fputs(msg.c_str(),channel);
    fflush(channel);
  }
  void clearFigure(const std::string &amp;figureName)
  {
    std::string msg;
    msg="{\"action\":\"clear\","
         "\"figure\":\""+(figureName.empty()?current_fig:figureName)+"\"}\n\n";
    fputs(msg.c_str(),channel);
    fflush(channel);
  }
  void closeFigure(const std::string &amp;figureName)
  {
    std::string msg;
    msg="{\"action\":\"close\","
         "\"figure\":\""+(figureName.empty()?current_fig:figureName)+"\"}\n\n";
    fputs(msg.c_str(),channel);
    fflush(channel);
  }
  void saveImage(const std::string &amp;fileName, const std::string &amp;figureName)
  {
      std::string msg;
      msg="{\"action\":\"export\","
           "\"figure\":\""+(figureName.empty()?current_fig:figureName)+"\","
           "\"file\":\""+fileName+"\"}\n\n";
      fputs(msg.c_str(),channel);
      fflush(channel);
  }
  void selectFigure(const std::string &amp;figureName)
  {
     current_fig = figureName;
  }
  void axisAuto(const std::string &amp;figureName)
  {
    setFigureProperty(figureName.empty()?current_fig:figureName, "viewbox", "auto");
  }
  void axisLimits(const double &amp;x_lb, const double &amp;x_ub, const double &amp;y_lb, const double &amp;y_ub, const std::string &amp;figureName)
  {
    setFigureProperty(figureName.empty()?current_fig:figureName, "viewbox", (Vec4d){x_lb,x_ub,y_lb,y_ub});
  }
  void axisLabels(const std::string &amp;x_label, const std::string &amp;y_label, const std::string &amp;figureName)
  {
    vector&lt;string&gt; labels;
    labels.push_back(x_label);
    labels.push_back(y_label);
    axisLabels(labels, figureName);
  }
  void axisLabels(const std::vector&lt;std::string&gt; &amp;labels, const std::string &amp;figureName)
  {
    setFigureProperty( figureName.empty()?current_fig:figureName, "axislabels", labels);
  }
  void drawBox(const double &amp;x_lb, const double &amp;x_ub, const double &amp;y_lb, const double &amp;y_ub, Params params)
  {
    Params msg;
    msg["action"] = "draw";
    msg["figure"] = params.pop("figure",current_fig);
    msg["shape"] = (params, "type", "box", "bounds", (Vec4d){x_lb,x_ub,y_lb,y_ub});
    fputs(Value(msg).toJSONString().append("\n\n").c_str(), channel);
    fflush(channel);
  }
  void drawBox(const vector&lt;double&gt; &amp;bounds, Params params)
  {
    assert(!bounds.empty());
    assert(bounds.size()%2 == 0);
    Params msg;
    msg["action"] = "draw";
    msg["figure"] = params.pop("figure",current_fig);
    msg["shape"] = (params, "type", "box", "bounds", vector&lt;Value&gt;(bounds.begin(),bounds.end()));
    fputs(Value(msg).toJSONString().append("\n\n").c_str(), channel);
    fflush(channel);
  }
  void drawEllipse(const double &amp;cx, const double &amp;cy, const double &amp;a, const double &amp;b, const double &amp;rot, Params params)
  {
      Params msg;
      msg["action"] = "draw";
      msg["figure"] = params.pop("figure",current_fig);
      msg["shape"] = (params, "type", "ellipse",
                              "center", (Vec2d){cx,cy},
                              "axis", (Vec2d){a,b},
                              "orientation", rot);
      fputs(Value(msg).toJSONString().append("\n\n").c_str(), channel);
<a name="0"></a>      fflush(channel);
  }
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  void drawConfidenceEllipse(const double &amp;cx, const double &amp;cy,
                             const double &amp;sxx, const double &amp;sxy, const double &amp;syy,
                             const double &amp;K, Params params)</b></font>
  {
      Params msg;
      msg["action"] = "draw";
      msg["figure"] = params.pop("figure",current_fig);
      msg["shape"] = (params, "type", "ellipse",
                              "center", (Vec2d){cx,cy},
                              "covariance", (Vec4d){sxx,sxy,sxy,syy},
                              "sigma", K);
      fputs(Value(msg).toJSONString().append("\n\n").c_str(), channel);
      fflush(channel);
  }
  void drawConfidenceEllipse(const vector&lt;double&gt; &amp;center, const vector&lt;double&gt; &amp;cov,
                             const double &amp;K, Params params)
  {
      Params msg;
      msg["action"] = "draw";
      msg["figure"] = params.pop("figure",current_fig);
      msg["shape"] = (params, "type", "ellipse",
                              "center", vector&lt;Value&gt;(center.begin(),center.end()),
                              "covariance", vector&lt;Value&gt;(cov.begin(),cov.end()),
                              "sigma", K);
      fputs(Value(msg).toJSONString().append("\n\n").c_str(), channel);
      fflush(channel);
  }
  void drawBoxes(const std::vector&lt;std::vector&lt;double&gt; &gt; &amp;bounds, Params params)
  {
     Params msg;
     msg["action"] = "draw";
     msg["figure"] = params.pop("figure",current_fig);
     msg["shape"] = (params, "type", "boxes",
                             "bounds", bounds);
     fputs(Value(msg).toJSONString().append("\n\n").c_str(), channel);
     fflush(channel);
  }
  void drawBoxesUnion(const std::vector&lt;std::vector&lt;double&gt; &gt; &amp;bounds, Params params)
  {
     Params msg;
     msg["action"] = "draw";
     msg["figure"] = params.pop("figure",current_fig);
     msg["shape"] = (params, "type", "boxes union",
                             "bounds", bounds);
     fputs(Value(msg).toJSONString().append("\n\n").c_str(), channel);
     fflush(channel);
  }
  void drawLine(const std::vector&lt;std::vector&lt;double&gt; &gt; &amp;points, Params params)
  {
     Params msg;
     msg["action"] = "draw";
     msg["figure"] = params.pop("figure",current_fig);
     msg["shape"] = (params, "type", "line",
                             "points", points);
     fputs(Value(msg).toJSONString().append("\n\n").c_str(), channel);
     fflush(channel);
  }
  void drawLine(const std::vector&lt;double&gt; &amp;x, const std::vector&lt;double&gt; &amp;y, Params params)
  {
     std::vector&lt;Value&gt; points;
     std::vector&lt;double&gt;::const_iterator itx = x.begin();
     std::vector&lt;double&gt;::const_iterator ity = y.begin();
     while (itx != x.end() &amp;&amp; ity != y.end()) {
        points.push_back( (Vec2d){*itx++,*ity++} );
     }
     Params msg;
     msg["action"] = "draw";
     msg["figure"] = params.pop("figure",current_fig);
     msg["shape"] = (params, "type", "line",
                             "points", points);
     fputs(Value(msg).toJSONString().append("\n\n").c_str(), channel);
     fflush(channel);
  }
  void newGroup(const std::string &amp;name, Params params)
  {
     Params msg;
     msg["action"] = "draw";
     msg["figure"] = params.pop("figure",current_fig);
     msg["shape"] = (params, "type", "group",
                             "name", name);
     fputs(Value(msg).toJSONString().append("\n\n").c_str(), channel);
     fflush(channel);
  }
  void clearGroup(const std::string &amp;figureName, const std::string &amp;groupName)
  {
     Params msg;
     msg["action"] = "clear";
     msg["figure"] = figureName;
     msg["group"] = groupName;
     fputs(Value(msg).toJSONString().append("\n\n").c_str(), channel);
     fflush(channel);
  }
  void clearGroup(const std::string &amp;groupName)
  {
     clearGroup(current_fig, groupName);
  }
  void removeObject(const std::string &amp;figureName, const std::string &amp;objectName)
  {
     Params msg;
     msg["action"] = "delete";
     msg["figure"] = figureName;
     msg["object"] = objectName;
     fputs(Value(msg).toJSONString().append("\n\n").c_str(), channel);
     fflush(channel);
  }
  void removeObject(const std::string &amp;objectName)
  {
     removeObject(current_fig, objectName);
  }
  void setFigureProperties(const std::string &amp;figureName, const Params &amp;properties)
  {
     Params msg;
     msg["action"] = "set";
     msg["figure"] = figureName;
     msg["properties"] = properties;
     fputs(Value(msg).toJSONString().append("\n\n").c_str(), channel);
     fflush(channel);
  }
  void setFigureProperties(const Params &amp;properties)
  {
     setFigureProperties(current_fig, properties);
  }
  void setObjectProperties(const std::string &amp;figureName, const std::string &amp;objectName, const Params &amp;properties)
  {
     Params msg;
     msg["action"] = "set";
     msg["figure"] = figureName;
     msg["object"] = objectName;
     msg["properties"] = properties;
     fputs(Value(msg).toJSONString().append("\n\n").c_str(), channel);
     fflush(channel);
  }
  void setObjectProperties(const std::string &amp;objectName, const Params &amp;properties)
  {
     setObjectProperties(current_fig, objectName, properties);
  }
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
