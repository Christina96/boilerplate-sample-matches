<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for ibex_Interval.h &amp; vibes.cpp</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for ibex_Interval.h &amp; vibes.cpp
      </h3>
<h1 align="center">
        1.6%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>ibex_Interval.h (1.1100832%)<th>vibes.cpp (3.217158%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(164-216)<td><a href="#" name="0">(228-230)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>ibex_Interval.h</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/* ============================================================================
 * I B E X - Interval definition
 * ============================================================================
 * Copyright   : IMT Atlantique (FRANCE)
 * License     : This program can be distributed under the terms of the GNU LGPL.
 *               See the file COPYING.LESSER.
 *
 * Author(s)   : Gilles Chabert
 * Bug fixes   : Gilles Trombettoni, Bertrand Neveu
 * Created     : Dec 05, 2011
 * Last update : Oct 30, 2019
 * ---------------------------------------------------------------------------- */

#ifndef _IBEX_INTERVAL_H_
#define _IBEX_INTERVAL_H_

#include &lt;array&gt;
#include &lt;math.h&gt;
#include "ibex_Exception.h"

/* ========================================================*/
/* The following header file is automatically generated by
 * the compilation.
 */
#include "ibex_Setting.h"

#include "ibex_IntervalLibWrapper.h"

/** \brief NEG_INFINITY: &lt;double&gt; representation of -oo */
#define NEG_INFINITY IBEX_INTERVAL_LIB_NEG_INFINITY
/** \brief POS_INFINITY: &lt;double&gt; representation of +oo */
#define POS_INFINITY IBEX_INTERVAL_LIB_POS_INFINITY

#ifdef _MSC_VER
#include &lt;intrin.h&gt;
#define __builtin_popcount __popcnt
#define __builtin_powi(__x,__n) ((double)::pow((double)(__x),(int)(__n)))
#endif // _MSC_VER


namespace ibex {

class IntervalVector;
class IntervalMatrix;
class ExprConstant;

/** \defgroup arithmetic Interval Arithmetic */

/** \ingroup arithmetic */
/*@{*/

/**
 * \brief Sets the rounding direction mode of the FPU towards -oo.
 */
void fpu_round_down();

/**
 * \brief Sets the rounding direction mode of the FPU towards +oo.
 */
void fpu_round_up();

/**
 * \brief Sets the rounding direction mode of the nearest
 */
void fpu_round_near();

/*
 * Sets the rounding direction mode of the FPU towards zero.
 */
void fpu_round_zero();

/**
 * \brief Return the previous float
 */
double previous_float(double x);

/**
 * \brief Return the next float
 */
double next_float(double x);


/*@}*/

/**
 * \ingroup arithmetic
 *
 * \brief Interval
 *
 * This class defines the interval interface of IBEX and encapsulates an interval "itv" whose
 * type depends on the chosen implementation (currently: Gaol, Bias of filib).
 *
 * Note that some functions of the Gaol interval interface do not appear here (like "possibly relations")
 * because there are not used by ibex; while other have been introduced (like "ratio_delta"). Some
 * functions are also renamed to match more conventional use.
 *
 * Note that with filib several precision and mode are available. We choose :
 * base type = double
 * rounding_strategy = native_switched
 * interval_mode = i_mode_extended_flag
 *
 */
class Interval {
  public:
	/** \brief Create (-oo,+oo). */
    Interval();

    /** \brief Create [a,b].  */
    Interval(double a, double b);

    /** \brief Create [a,a]. */
    Interval(double a);

    /** \brief Create [a, a] from a fixed-sized array of size 1. */
    Interval(std::array&lt;double, 1&gt; array);

    /** \brief Create [a, b] from a fixed-sized array of size 2. */
    Interval(std::array&lt;double, 2&gt; array);

    /** \brief True iff *this and x are exactly the same intervals. */
    bool operator==(const Interval&amp; x) const;

    /** \brief True iff *this and x are not exactly the same intervals. */
    bool operator!=(const Interval&amp; x) const;

    /** \brief Set this interval to the empty set. */
    void set_empty();

    /** \brief Set *this to x.
     */
    Interval&amp; operator=(const Interval&amp; x);

    /** \brief Set *this to d.
     */
    Interval&amp; operator=(double x);

    /** \brief Intersection of *this and x.
     * \param x - the interval to compute the intersection with.*/
    Interval&amp; operator&amp;=(const Interval&amp; x);

    /** \brief Union of *this and x.
     * \param x - the interval to compute the hull with.*/
    Interval&amp; operator|=(const Interval&amp; x);

    /**
     * \brief Add [-rad,+rad] to *this.
     *
     * Return a reference to *this.
     */
    Interval&amp; inflate(double rad);

	/**
	 * \brief Absolute and relative inflation.
	 *
	 * [x] &lt;- mid[x] + delta*([x]-mid[x]) + chi*[-1,+1]
	 *
	 * \return *this.
	 */
	Interval&amp; inflate(double delta, double chi);

<a name="0"></a>    /** \brief Lower bound.
     *
     * Return the lower bound of *this. */
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    double lb() const;

    /** \brief Upper bound.
     *
     * Return the upper bound of *this. */
    double ub() const;

    /** \brief Midpoint.
     *
     * Returns the midpoint of *this.
     * The return point is guaranteed to be included in *this
     * but not necessarily to be the closest floating point
     * from the real midpoint.
     *
     * Cases are:
     * - \emptyset  -&gt; Quiet NaN
     * - [-oo, +oo] -&gt; midP = 0.0
     * - [-oo, b]   -&gt; midP = -MAXREAL
     * - [a, +oo]   -&gt; midP = MAXREAL
     * - [a, b]     -&gt; midP ~ a + .5*(b-a) */
    double mid() const;

    /**
     * \brief Radius.
     *
     * Return the diameter of *this.
     * By convention, 0 if *this is empty.*/
    double rad() const;

    /**
     * \brief Diameter.
     *
     * Return the diameter of *this.
     * By convention, 0 if *this is empty.*/
    double diam() const;

    /**
     * \brief Mignitude.
	 *
     * Returns the mignitude of *this:
     * &lt;lu&gt;
     * &lt;li&gt; +(lower bound)  if *this &gt; 0
     * &lt;li&gt; -(upper bound) if *this &lt; 0
     * &lt;li&gt; 0 otherwise.
     * &lt;/lu&gt; */
    double mig() const;

    /**
     * \brief Magnitude.
	 *
     * Returns the magnitude of *this:
     * mag(*this)=max(|lower bound|, |upper bound|). */
    double mag() const;</b></font>

    /**
     * \brief True iff this interval is a subset of \a x.
     *
     * \note Always return true if *this is empty.
     */
    bool is_subset(const Interval&amp; x) const;

    /**
     * \brief True iff this interval is a subset of \a x and not \a x itself.
     *
     * \note In particular, (-oo,oo) is not a strict subset of (-oo,oo)
     * and the empty set is not a strict subset of the empty set although
     * in both cases, the first is inside the interior of the second.
     */
    bool is_strict_subset(const Interval&amp; x) const;

    /**
     * \brief True iff this interval is in the interior of \a x.
     *
    * \note In particular, (-oo,oo) is in the interior of (-oo,oo)
     * and the empty set is in the interior of the empty set.
     * \note Always return true if *this is empty.
     */
    bool is_interior_subset(const Interval&amp; x) const;

    /**
     * \brief True iff this interval is in the relative interior of \a x.
     *
     * When x is degenerated, the relative interior of x is x itself
     * (it is not an open set). Otherwise, the relative interior of x
     * is the interior (in the usual meaning).
     */
    bool is_relative_interior_subset(const Interval&amp; x) const;

    /**
     * \brief True iff this interval is in the interior of \a x and different from x.
     *
     * \note In particular, (-oo,oo) is not "strictly" in the interior of (-oo,oo)
     * and the empty set is not "strictly" in the interior of the empty set.
     */
    bool is_strict_interior_subset(const Interval&amp; x) const;

    /**
     * \brief True iff this interval is a superset of \a x.
     *
     * \note Always return true if x is empty.
     */
    bool is_superset(const Interval&amp; x) const;

    /**
     * \brief True iff this interval is a superset of \a x different from x.
     *
     * \see #is_strict_subset(const Interval&amp;) const.
     */
    bool is_strict_superset(const Interval&amp; x) const;

    /**
     * \brief True iff *this contains \a d.
     *
     * \note d can also be an "open bound", i.e., infinity.
     * So this function is not restricted to a set-membership
     * interpretation.
     */
    bool contains(const double&amp; d) const;

    /**
     * \brief True iff the interior of *this contains \a d.
     *
     */
    bool interior_contains(const double&amp; d) const;

    /**
     * \brief True iff *this and \a x intersect.
     */
    bool intersects(const Interval &amp;x) const;

    /**
     * \brief True iff *this and \a x intersect and the intersection has a non-null volume.
     *
     * Equivalently, some interior points (of this or x) must belong to the intersection.
     */
    bool overlaps(const Interval &amp;x) const;

    /**
     * \brief True iff *this and \a x do not intersect.
     *
     */
    bool is_disjoint(const Interval &amp;x) const;

    /**
     * \brief True iff *this is empty.
     */
    bool is_empty() const;

    /**
     * \brief True iff *this is degenerated.
     *
     * An interval is degenerated if it is of the form [a, a]
     *
     * \note An empty interval is considered here as degenerated. */
    bool is_degenerated() const;

    /**
     * \brief True if one bound of *this is infinite.
     *
     * \note An empty interval is always bounded.
     */
    bool is_unbounded() const;

    /**
     * \brief True iff *this can be bisected into two non-degenerated intervals.
     *
     * Examples of non bisectable intervals are [0,next_float(0)] or [DBL_MAX,+oo).
     */
    bool is_bisectable() const;

    /**
     * \brief Relative Hausdorff distance between *this and x.
     *
     * The relative distance is basically distance(x)/diam(*this).
     * \see #ibex::distance (const ibex::Interval &amp;x1, const ibex::Interval &amp;x2).
     */
    double rel_distance(const Interval&amp; x) const;

    /*
     * \brief The complementary of x.
     */
    int complementary(Interval&amp; c1, Interval&amp; c2, bool compactness = true) const;

    /**
     * \brief x\y
     */
    int diff(const Interval&amp; y, Interval&amp; c1, Interval&amp; c2, bool compactness = true) const;

    /** \brief Return -*this. */
    Interval operator-() const;

    /** \brief Add \a d to *this and return the result.  */
    Interval&amp; operator+=(double d);

    /** \brief Subtract \a d to *this and return the result. */
    Interval&amp; operator-=(double d);

    /** \brief Multiply *this by \a d and return the result. */
    Interval&amp; operator*=(double d);

    /** \brief Divide *this by \a d and return the result. */
    Interval&amp; operator/=(double d);

    /** \brief Add \a x to *this and return the result. */
    Interval&amp; operator+=(const Interval&amp; x);

    /** \brief Subtract \a x to *this and return the result. */
    Interval&amp; operator-=(const Interval&amp; x);

    /** \brief Multiply *this by \a x and return the result. */
    Interval&amp; operator*=(const Interval&amp; x);

    /**
     * \brief Divide *this by \a x and return the result.
     *
     * Does better than *this=*this/x: because calculates
     * the union of *this/x as intermediate result. */
    Interval&amp; operator/=(const Interval&amp; x);

    /**
     * \brief Set this interval to the intersection of itself with the division of two others.
     *
     * \param x - the numerator
     * \param y - the divisor
     * \param out2 - In return, *this and out2 contains the lower and upper part respectively
     * of the division. If the result of the generalized division and intersection
     * is a single interval, out2 is set to the empty interval.
     * \code
     * Interval intv(-10,10);
     * Interval out2;
     * intv.div2_inter(Interval(2,3), Interval(-1,2), out2);
     * cout &lt;&lt; intv &lt;&lt; " " &lt;&lt; out2 &lt;&lt; endl;  // will display: [-10,-2] [1,10]
     * \endcode
	 *
     * \return \c true if the intersection is non empty.
     * \note Contrary to the "cset" theory, the result is empty if \a y=[0,0] (whatever \a x is).
     */
    bool div2_inter(const Interval&amp; x, const Interval&amp; y, Interval&amp; out2);

    /**
     * \brief Set this interval to the intersection of itself with the division of two others.
     */
    Interval&amp; div2_inter(const Interval&amp; x, const Interval&amp; y);

    /**
     * \brief Return diam(*this)-diam(x), for x\subseteq *this [deprecated]
     *
     * Deprecated. Kept for compatibility with ibex 1.xx.
     *
     * \pre \a x must be included in this interval.
     * \note The result may be +oo (if the set difference is infinite).
     * \note An empty interval is considered here to have a null diamater (as a degenerated interval). &lt;br&gt;
     * If either \a x or this interval is empty, then the method returns the diameter of this interval
     * (which is 0 if the latter is empty).
     */
    double delta(const Interval&amp; x) const;

    /**
     * \brief Compute the ratio of the diameter to #delta(x) [deprecated].
     *
     * Deprecated. Kept for compatibility with ibex 1.xx.
     *
     * \pre \a x must be included in this interval.
     * \note An empty interval is considered to have a null diamater (as a degenerated interval). &lt;br&gt;
     * &lt;ul&gt;&lt;li&gt;If either \a x or this interval is empty, then
     * &lt;ul&gt;&lt;li&gt;the method returns 1 (100% of reduction) if this diameter is not null,
     *     &lt;li&gt;0 otherwise (as if 0/0=0).&lt;/ul&gt;
     * &lt;li&gt;As a pure convention, the method returns \c 1 if one bound of this interval is infinite and the corresponding bound of \a x
     * is not (in particular if this interval is unbounded and \a x not). &lt;/ul&gt;
     */
    double ratiodelta(const Interval&amp; x) const;

    /**
     * \brief Bisect *this into two subintervals.
     *
     * \param ratio - says where to split (0.5=middle)
     * \pre is_bisectable() must be true.
     * \pre 0&lt;ratio&lt;1.
     */
    std::pair&lt;Interval,Interval&gt; bisect(double ratio=0.5) const;

    /** \brief pi
     *  Deprecated. Use pi().
     */
    static const Interval PI;

     /** \brief pi. */
    static const Interval&amp; pi();

    /** \brief 2*pi.
     *  Deprecated. Use two_pi().
     */
    static const Interval TWO_PI;

    /** \brief 2*pi. */
    static const Interval&amp; two_pi();

    /** \brief pi/2.
     *  Deprecated. Use half_pi().
     */
    static const Interval HALF_PI;

    /** \brief pi/2. */
    static const Interval&amp; half_pi();

    /** \brief the empty interval.
     *  Deprecated. Use empty_set().
     */
    static const Interval EMPTY_SET;

    /** \brief the empty interval. */
    static const Interval&amp; empty_set();

    /** \brief (-oo,oo).
     *  Deprecated. Use all_reals().
     */
    static const Interval ALL_REALS;

    /** \brief (-oo,oo). */
    static const Interval&amp; all_reals();

    /** \brief [0,0].
     *  Deprecated. Use zero().
     */
    static const Interval ZERO;

    /** \brief [0,0]. */
    static const Interval&amp; zero();

    /** \brief [1,1].
     *  Deprecated. Use one().
     */
    static const Interval ONE;

    /** \brief [1,1]. */
    static const Interval&amp; one();

    /** \brief [0,+oo).
     *  Deprecated. Use pos_reals().
     */
    static const Interval POS_REALS;

    /** \brief [0,+oo). */
    static const Interval&amp; pos_reals();

    /** \brief (-oo,0].
     *  Deprecated. Use neg_reals().
     */
    static const Interval NEG_REALS;

    /** \brief (-oo,0]. */
    static const Interval&amp; neg_reals();

//    friend class IntervalVector;

    typedef Interval SCALAR;
    typedef IntervalVector VECTOR;
    typedef IntervalMatrix MATRIX;

    /**
     * \brief Cast the interval to an expression
     */
    operator const ExprConstant&amp;() const;

    /* \brief Constructor from an interval [x] of wrapped type. */
    Interval(const interval_type_wrapper&amp; x);
    /* \brief Assign to an interval from a wrapper type. */
    Interval&amp; operator=(const interval_type_wrapper&amp; x);

    interval_type_wrapper itv;
};

/** \ingroup arithmetic */
/*@{*/

/** \brief Stream out \a x. */
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Interval&amp; x);

/** \brief \f$[x]_1\cap [x]_2\f$.
 * \return Interval::EMPTY if the intersection is empty. */
Interval operator&amp;(const Interval&amp; x1, const Interval&amp; x2);

/** \brief \f$\square([x]_1\cup [x]_2)\f$. */
Interval operator|(const Interval&amp; x1, const Interval&amp; x2);

/** \brief [x]+d. */
Interval operator+(const Interval&amp; x, double d);

/** \brief [x]-d. */
Interval operator-(const Interval&amp; x, double d);

/** \brief [x]*d. */
Interval operator*(const Interval&amp; x, double d);

/** \brief [x]/d. */
Interval operator/(const Interval&amp; x, double d);

/** \brief Generalized division
 *
 * The result of x/y is stored in out1 and out2. These intervals contain the lower and upper part respectively
 * of the division. If the result of the generalized division is a single interval, out2
 * is set to the empty interval. If the result is the empty set, both out1 and out2 are set to the
 * empty interval.
 *
 * \note Contrary to the "cset" theory, the result is empty if \a y=[0,0] (whatever \a x is).
 */
void div2(const Interval&amp; x, const Interval&amp; y, Interval&amp; out1, Interval&amp; out2);

/** \brief d+[x]. */
Interval operator+(double d,const Interval&amp; x);

/** \brief d-[x]. */
Interval operator-(double d, const Interval&amp; x);

/** \brief d*[x]. */
Interval operator*(double d, const Interval&amp; x);

/** \brief d/[x]. */
Interval operator/(double d, const Interval&amp; x);

/** \brief [x]_1+[x]_2. */
Interval operator+(const Interval&amp; x1, const Interval&amp; x2);

/** \brief [x]_1-[x]_2. */
Interval operator-(const Interval&amp; x1, const Interval&amp; x2);

/** \brief [x]_1*[x]_2. */
Interval operator*(const Interval&amp; x1, const Interval&amp; x2);

/** \brief [x]_1/[x]_2. */
Interval operator/(const Interval&amp; x1, const Interval&amp; x2);

/** \brief Hausdorff distance of [x]_1 and [x]_2. */
double distance(const Interval &amp;x1, const Interval &amp;x2);

/** \brief [x]^2 */
Interval sqr(const Interval&amp; x);

/** \brief sqrt{[x]} */
Interval sqrt(const Interval&amp; x);

/** \brief [x]^n. */
Interval pow(const Interval&amp; x, int n);

/** \brief [x]^d. */
Interval pow(const Interval&amp; x, double d);

/** \brief [x]^[y]. */
Interval pow(const Interval &amp;x, const Interval &amp;y);

/** \brief n^{th} root of [x]. */
Interval root(const Interval&amp; x, int n);

/** \brief exp([x]). */
Interval exp(const Interval&amp; x);

/** \brief log([x]). */
Interval log(const Interval&amp; x);

/** \brief cos([x]). */
Interval cos(const Interval&amp; x);

/** \brief sin([x]). */
Interval sin(const Interval&amp; x);

/** \brief tan([x]). */
Interval tan(const Interval&amp; x);

/** \brief acos([x]). */
Interval acos(const Interval&amp; x);

/** \brief asin([x]). */
Interval asin(const Interval&amp; x);

/** \brief atan([x]). */
Interval atan(const Interval&amp; x);

/** \brief atan2([y],[x]). */
Interval atan2(const Interval&amp; y, const Interval&amp; x);

/** \brief cosh([x]). */
Interval cosh(const Interval&amp; x);

/** \brief sinh([x]). */
Interval sinh(const Interval&amp; x);

/** \brief tanh([x]). */
Interval tanh(const Interval&amp; x);

/** \brief acosh([x]). */
Interval acosh(const Interval&amp; x);

/** \brief asinh([x]). */
Interval asinh(const Interval&amp; x);

/** \brief atanh([x]). */
Interval atanh(const Interval&amp; x);

/** \brief \f$abs([x]) = \{|x|, x\in[x]\}.\f$. */
Interval abs(const Interval &amp;x);

/** \brief Maximum of two intervals.
 *
 * Return \f$\max([x],[y]) = \{ \max\{x,y\}, x\in[x], y\in[y] \}\f$. */
Interval max(const Interval&amp; x, const Interval&amp; y);

/** \brief Minimum of two intervals.
 *
 *  Return \f$\min([x],[y]) = \{ \min\{x,y\}, x\in[x], y\in[y] \}\f$. */
Interval min(const Interval&amp; x, const Interval&amp; y);

/** \brief Sign of [x].
 *
 *  Return \f$sign([x]) = hull \{ sign{x}, x\in[x] \}\f$.
 * \remark By convention, \f$ 0\in[x] \Longrightarrow sign[x]=[-1,1]\f$. */
Interval sign(const Interval&amp; x);

/** \brief Chi of [a], [b] and [c].
 *
 *  Return \f$chi([a],[b],[c]) = 0.5*(1-\sign([a]))*[b] + 0.5*(\sign([a])+1)*[c]. \f$
 * \remark  chi([a],[b],[c]) =[b] if [a]&lt;=0, [c] if [a]&gt;0, hull \{[b], [c]\} else.  */
Interval chi(const Interval&amp; a, const Interval&amp; b, const Interval&amp; c);

/** \brief Return the largest integer interval included in x. */
Interval integer(const Interval&amp; x);

/** \brief Floor of [x]. */
Interval floor(const Interval&amp; x);

/** \brief Ceil of [x]. */
Interval ceil(const Interval&amp; x);

/**
 * \brief The saw function is x-&gt;x-round(x)
 *
 * It allows to enforce integer constraint
 * by writing saw(x)=0.
 */
Interval saw(const Interval&amp; x);

/** \brief Projection of y=x_1+x_2.
 *
 * Set ([x]_1,[x]_2) to \f$([x]_1,[x]_2])\cap\{ (x_1,x_2)\in [x]_1\times[x]_2 \ | \ \exists y\in[y],\ y=x_1+x_2\}\f$. */
bool bwd_add(const Interval&amp; y, Interval&amp; x1, Interval&amp; x2);

/** \brief Projection of y=x_1-x_2.
 *
 * Set ([x]_1,[x]_2) to \f$([x]_1,[x]_2])\cap\{ (x_1,x_2)\in [x]_1\times[x]_2 \ | \ \exists y\in[y],\ y=x_1-x_2\}\f$. */
bool bwd_sub(const Interval&amp; y, Interval&amp; x1, Interval&amp; x2);

/** \brief Projection of y=x_1*x_2.
 *
 * Set ([x]_1,[x]_2) to \f$([x]_1,[x]_2])\cap\{ (x_1,x_2)\in [x]_1\times[x]_2 \ | \ \exists y\in[y],\ y=x_1\times x_2\}\f$. */
bool bwd_mul(const Interval&amp; y, Interval&amp; x1, Interval&amp; x2);

/** \brief Projection of y=x_1/x_2.
 *
 * Set ([x]_1,[x]_2) to \f$([x]_1,[x]_2])\cap\{ (x_1,x_2)\in [x]_1\times[x]_2 \ | \ \exists y\in[y],\ y=x_1/x_2\}\f$. */
bool bwd_div(const Interval&amp; y, Interval&amp; x1, Interval&amp; x2);

/** \brief Projection of y=x^2.
 *
 * Set [x] to \f$[x]\cap \{ x\in [x] \exists y\in [y], \quad y=x^2 \}\f$. */
bool bwd_sqr(const Interval&amp; y, Interval&amp; x);

/** \brief Projection of y=sqrt{x}.
 *
 * Set [x] to \f$[x]\cap \{ x\in [x] \exists y\in [y], \quad y=sqrt{x} \}\f$. */
bool bwd_sqrt(const Interval&amp; y, Interval&amp; x);

/** \brief Projection of y=x^n.
 *
 * Set [x] to \f$[x]\cap \{ x\in [x] \exists y\in [y], \quad y=x^n \}\f$. */
bool bwd_pow(const Interval&amp; y, int n, Interval&amp; x);

/** \brief Projection of y=x_1^{x_2}.
 *
 * Set ([x]_1,[x]_2) to \f$([x]_1,[x]_2])\cap\{ (x_1,x_2)\in [x]_1\times[x]_2 \ | \ \exists y\in[y],\ y=x_1^{x_2}\}\f$. */
bool bwd_pow(const Interval&amp; y, Interval&amp; x1, Interval&amp; x2);

/** \brief Projection of the \f$y=x^{\frac{1}{n}}\f$.
 *
 * Set [x] to \f$[x]\cap \{ x\in [x] \exists y\in [y], \quad y=x^{\frac{1}{n}} \}\f$. */
bool bwd_root(const Interval&amp; y, int n, Interval&amp; x);

/** \brief Projection of y=exp(x).
 *
 * Set [x] to \f$[x]\cap \{ x\in [x] \exists y\in [y], \quad y=\exp(x) \}\f$. */
bool bwd_exp(const Interval&amp; y,  Interval&amp; x);

/** \brief Projection of y=log(x).
 *
 * Set [x] to \f$[x]\cap \{ x\in [x] \exists y\in [y], \quad y=\log(x) \}\f$. */
bool bwd_log(const Interval&amp; y,  Interval&amp; x);

/** \brief Projection of y=cos(x).
 *
 * Set [x] to \f$[x]\cap \{ x\in [x] \exists y\in [y], \quad y=\cos(x) \}\f$. */
bool bwd_cos(const Interval&amp; y,  Interval&amp; x);

/** \brief Projection of y=sin(x).
 *
 * Set [x] to \f$[x]\cap \{ x\in [x] \exists y\in [y], \quad y=\sin(x) \}\f$. */
bool bwd_sin(const Interval&amp; y,  Interval&amp; x);

/** \brief Projection of y=tan(x).
 *
 * Set [x] to \f$[x]\cap \{ x\in [x] \exists y\in [y], \quad y=\tan(x) \}\f$. */
bool bwd_tan(const Interval&amp; y,  Interval&amp; x);

/** \brief Projection of y=acos(x).
 *
 * Set [x] to \f$[x]\cap \{ x\in [x] \exists y\in [y], \quad y=\arccos(x) \}\f$. */
bool bwd_acos(const Interval&amp; y,  Interval&amp; x);

/** \brief Projection of y=asin(x).
 *
 * Set [x] to \f$[x]\cap \{ x\in [x] \exists y\in [y], \quad y=\arcsin(x) \}\f$. */
bool bwd_asin(const Interval&amp; y,  Interval&amp; x);

/** \brief Projection of y=atan(x).
 *
 * Set [x] to \f$[x]\cap \{ x\in [x] \exists y\in [y], \quad y=\arctan(x) \}\f$. */
bool bwd_atan(const Interval&amp; y,  Interval&amp; x);

/** \brief Projection of y=atan2(x_1,x_2).
 *
 * Set ([x]_1,[x]_2) to \f$([x]_1,[x]_2])\cap\{ (x_1,x_2)\in [x]_1\times[x]_2 \ | \ \exists y\in[y],\ y=atan2(x_1,x_2)\f$. */
bool bwd_atan2(const Interval&amp; y, Interval&amp; x1, Interval&amp; x2);

/** \brief Projection of y=cosh(x).
 *
 * Set [x] to \f$[x]\cap \{ x\in [x] \exists y\in [y], \quad y=\cosh(x) \}\f$. */
bool bwd_cosh(const Interval&amp; y,  Interval&amp; x);

/** \brief Projection of y=sinh(x).
 *
 * Set [x] to \f$[x]\cap \{ x\in [x] \exists y\in [y], \quad y=\sinh(x) \}\f$. */
bool bwd_sinh(const Interval&amp; y,  Interval&amp; x);

/** \brief Projection of y=tanh(x).
 *
 * Set [x] to \f$[x]\cap \{ x\in [x] \exists y\in [y], \quad y=\tanh(x) \}\f$. */
bool bwd_tanh(const Interval&amp; y,  Interval&amp; x);

/** \brief Projection of y=acosh(x).
 *
 * Set [x] to \f$[x]\cap \{ x\in [x] \exists y\in [y], \quad y=arccosh(x) \}\f$. */
bool bwd_acosh(const Interval&amp; y,  Interval&amp; x);

/** \brief Projection of y=asinh(x).
 *
 * Set [x] to \f$[x]\cap \{ x\in [x] \exists y\in [y], \quad y=arcsinh(x) \}\f$. */
bool bwd_asinh(const Interval&amp; y,  Interval&amp; x);

/** \brief Projection of y=atanh(x).
 *
 * Set [x] to \f$[x]\cap \{ x\in [x] \exists y\in [y], \quad y=arctanh(x) \}\f$. */
bool bwd_atanh(const Interval&amp; y,  Interval&amp; x);

/** \brief Projection of y=|x|.
 *
 * Set [x] to \f$[x]\cap \{ x\in [x] \exists y\in [y], \quad y=|x| \}\f$. */
bool bwd_abs(const Interval&amp; y,  Interval&amp; x);

/** \brief Projection of y=max(x_1,x_2).
 *
 * Set ([x]_1,[x]_2) to \f$([x]_1,[x]_2])\cap\{ (x_1,x_2)\in [x]_1\times[x]_2 \ | \ \exists y\in[y],\ y=\max(x_1,x_2)\}\f$. */
bool bwd_max(const Interval&amp; y, Interval&amp; x1, Interval&amp; x2);

/** \brief Projection of y=min(x_1,x_2).
 *
 * Set ([x]_1,[x]_2) to \f$([x]_1,[x]_2])\cap\{ (x_1,x_2)\in [x]_1\times[x]_2 \ | \ \exists y\in[y],\ y=\min(x_1,x_2)\}\f$. */
bool bwd_min(const Interval&amp; y, Interval&amp; x1, Interval&amp; x2);

/** \brief Projection of y=sign(x).
 *
 * Set [x] to \f$[x]\cap \{ x\in [x] \exists y\in [y], \quad y=sign(x) \}\f$. */
bool bwd_sign(const Interval&amp; y, Interval&amp; x);

/** \brief Projection of f=chi(a,b,c). */
bool bwd_chi(const Interval&amp; f, Interval&amp; a, Interval&amp; b, Interval&amp; c);

/** \brief Contract x w.r.t. y=floor(x). */
bool bwd_floor(const Interval&amp; y, Interval&amp; x);

/* \brief Contract x w.r.t. y=ceil(x). */
bool bwd_ceil(const Interval&amp; y, Interval&amp; x);

/* \brief Contract x w.r.t. y=saw(x). */
bool bwd_saw(const Interval&amp; y, Interval&amp; x);

/**
 * \brief Contract x and y w.r.t. the fact that they are equivalent modulo the period p.
 */
bool bwd_imod(Interval&amp; x, Interval&amp; y, const double&amp; p);

} // end namespace ibex

#include "ibex_IntervalLibWrapper.inl"

/*@}*/

/*============================================ features with common implementation ============================================ */

namespace ibex {

// the following functions are
// introduced to allow genericity
inline bool ___is_empty(double)             { return false; }
inline bool ___is_empty(const Interval&amp; x)  { return x.is_empty(); }
inline void ___set_empty(double)            { }
inline void ___set_empty(Interval&amp; x)       { x.set_empty(); }
inline double ___abs(double x)              { return fabs(x);}
inline Interval ___abs(const Interval&amp; x)   { return abs(x);}
inline double ___mag(double x)              { return fabs(x);}
inline double ___mag(const Interval&amp; x)     { return x.mag();}

inline Interval::Interval() : itv(NEG_INFINITY, POS_INFINITY) {

}

inline Interval::Interval(double a, double b) : itv(a,b) {
	if (a==POS_INFINITY || b==NEG_INFINITY || a&gt;b) *this=EMPTY_SET;
}

inline Interval::Interval(double a) : itv(a,a) {
	if (a==NEG_INFINITY || a==POS_INFINITY) *this=EMPTY_SET;
}

inline Interval::Interval(std::array&lt;double, 1&gt; array): Interval(array[0]) {}

inline Interval::Interval(std::array&lt;double, 2&gt; array): Interval(array[0], array[1]) {}

inline bool Interval::operator==(const Interval&amp; x) const {
	return (is_empty() &amp;&amp; x.is_empty()) || (lb()==x.lb() &amp;&amp; ub()==x.ub());
}

inline Interval&amp; Interval::operator=(double x) {
	if (x==NEG_INFINITY || x==POS_INFINITY)
		*this=EMPTY_SET;
	else
		itv = x;
	return *this;
}

inline Interval&amp; Interval::operator=(const Interval&amp; x) {
	itv = x.itv;
	return *this;
}

inline Interval&amp; Interval::inflate(double radd) {
	(*this) += Interval(-radd,radd);
	return *this;
}

inline Interval&amp; Interval::inflate(double delta, double chi) {
	double m=mid();
	(*this) = m + delta*(*this-m)+Interval(-chi,chi);
	return *this;
}


inline bool Interval::operator!=(const Interval&amp; x) const {
	return !(*this==x);
}

inline double Interval::rad() const {
	if (is_empty()) return 0;
	else if (is_unbounded()) return POS_INFINITY;
	else {
		double t = mid();
		double t1 =(t-*this).ub();
		double t2= (*this-t).ub();
		return (t1&gt;t2) ? t1 : t2;
	}
}

inline bool Interval::is_bisectable() const {
	if (is_empty()) return false;
	double m=mid();
	return (lb()&lt;m &amp;&amp; m&lt;ub());
}


inline double Interval::rel_distance(const Interval&amp; x) const {
	  double d=distance(*this,x);
	  if (d==POS_INFINITY) return 1;
	  double D=diam();
	  return (D==0 || D==POS_INFINITY) ? 0.0 : (d/D); // if diam(this)=infinity here, necessarily d=0
}

inline double distance(const Interval &amp;x1, const Interval &amp;x2) {

    if (x1.is_empty()) return x2.rad();

    if (x2.is_empty()) return x1.rad();

    if (x1.lb()==NEG_INFINITY) {
    	if (x2.lb()!=NEG_INFINITY)
    		return POS_INFINITY;
    	else if (x1.ub()==POS_INFINITY) {
    		if (x2.ub()==POS_INFINITY) return 0.0;
    		else return POS_INFINITY;
    	}
    	else if (x2.ub()==POS_INFINITY) return POS_INFINITY;
    	else return fabs(x1.ub()-x2.ub());
    }
    else if (x1.ub()==POS_INFINITY) {
    	if (x2.ub()!=POS_INFINITY)
    		return POS_INFINITY;
    	else if (x2.lb()==NEG_INFINITY)
    		return POS_INFINITY;
    	else return fabs(x1.lb()-x2.lb());
    }
    else if (x2.is_unbounded())
    	return POS_INFINITY;
    else
    	return _interval_distance_wrapper (x1.itv, x2.itv);
}

inline Interval sign(const Interval&amp; x) {
	return x.ub()&lt;0 ? Interval(-1,-1) : x.lb()&gt;0 ? Interval(1,1) : Interval(-1,1);
}

inline Interval chi(const Interval&amp; a, const Interval&amp; b, const Interval&amp; c){
	if (a.ub()&lt;=0) {
		return b;
	} else if (a.lb()&gt;0) {
		return c;
	} else {
		return b|c;
	}
}

inline Interval atan2(const Interval&amp; y, const Interval&amp; x) {

	if (y.is_empty() || x.is_empty()) return Interval::empty_set();

	// we handle the special case x=[0,0] separately
	else if (x==Interval::zero()) {
		if (y.lb()&gt;=0)
			if (y.ub()==0) return Interval::empty_set(); // atan2(0,0) is undefined.
			else return Interval::half_pi();
		else if (y.ub()&lt;=0) return -Interval::half_pi();
		else return Interval(-1,1)*Interval::half_pi();
	}

	else if (x.lb()&gt;=0) {
		return atan(y/x); // now, x.ub()&gt;0 -&gt; atan does not give an empty set
	}
	else if (x.ub()&lt;=0) {
		if (y.lb()&gt;=0)
			return atan(y/x)+Interval::pi(); // x.lb()&lt;0
		else if (y.ub()&lt;0)
			return atan(y/x)-Interval::pi();
		else
			return Interval(-1,1)*Interval::pi();
	} else {
		if (y.lb()&gt;=0)
			return atan(y/x.ub()) | (atan(y/x.lb()) + Interval::pi());
		else if (y.ub()&lt;=0){
			if(x.lb()!=NEG_INFINITY){
				if(x.ub()!=POS_INFINITY){
					return (atan(y/x.lb())-Interval::pi()) | atan(y/x.ub());
				}
				else
					return (atan(y/x.lb())-Interval::pi()) | Interval::zero();
			}
			else{
				if(x.ub()!=POS_INFINITY)
					return (-Interval::pi()) | atan(y/x.ub());
				else
					return -Interval::pi() | Interval::zero();
			}
		}
		else
			return Interval(-1,1)*Interval::pi();
	}
}

inline bool bwd_add(const Interval&amp; y, Interval&amp; x1, Interval&amp; x2) {
	if ((x1 &amp;= y-x2).is_empty()) { x2.set_empty(); return false; }
	if ((x2 &amp;= y-x1).is_empty()) { x1.set_empty(); return false; }
	return true;
}

inline bool bwd_sub(const Interval&amp; y, Interval&amp; x1, Interval&amp; x2) {
	if ((x1 &amp;= y+x2).is_empty()) { x2.set_empty(); return false; }
	if ((x2 &amp;= x1-y).is_empty()) { x1.set_empty(); return false; }
	return true;
}

inline bool bwd_div(const Interval&amp; y, Interval&amp; x1, Interval&amp; x2) {
	if ((x1 &amp;= y*x2).is_empty()) { x2.set_empty(); return false; }
	Interval tmp=y;
	bwd_mul(x1, tmp, x2);
	if (x2.is_empty()) { x1.set_empty(); return false; }
	return true;
}

inline bool bwd_sqrt(const Interval&amp; y, Interval&amp; x) {
	if (y.is_empty() || y.ub()&lt;0) {
		x.set_empty();
	} else if (y.lb()&lt;0) {
		x &amp;= sqr(Interval(0,y.ub()));
	} else  {
		x &amp;= sqr(y);
	}
	return !x.is_empty();
}

inline bool bwd_root(const Interval&amp; y, int n, Interval&amp; x) {
	x &amp;= pow(y,n);
	return !x.is_empty();
}

inline bool bwd_exp(const Interval&amp; y,  Interval&amp; x) {
	x &amp;= log(y);
	return !x.is_empty();
}

inline bool bwd_log(const Interval&amp; y,  Interval&amp; x) {
	x &amp;= exp(y);
	return !x.is_empty();
}

inline bool bwd_acos(const Interval&amp; y,  Interval&amp; x) {
	x &amp;= cos(y);
	return !x.is_empty();
}

inline bool bwd_asin(const Interval&amp; y,  Interval&amp; x) {
	x &amp;= sin(y);
	return !x.is_empty();
}

inline bool bwd_atan(const Interval&amp; y,  Interval&amp; x) {

	if (y.is_empty()) {
		x.set_empty();
		return false;
	}

	// Note: if y.ub&gt;pi/2 or y.lb&lt;-pi/2, tan(y) gives (-oo,oo).
	// so the implementation is not as simple as x &amp;= tan(y).

	Interval z=y;
	double pi2l=(Interval::pi()/2).lb();
	double pi2u=(Interval::pi()/2).ub();

	if (z.ub()&gt;=pi2l) // not pi2u. See comments below.
		if (z.lb()&gt;=pi2u)
			x.set_empty();
		else {
			if (z.lb()&gt;-pi2l) {
				// note 1: tan(z^-) can give an interval (-oo,+oo) if
				// z^- is close to -pi/2. Even in this case we keep the
				// lower bound -oo.
				//
				// note 2: if we had used z.lb()&lt;-pi2u (with pi2u&gt;pi/2)
				// instead of z.lb()&lt;-pi2l, it may be possible, in theory,
				// that the calculated lower bound is a high value close to +oo, which would be incorrect.
				//
				// note 3: if z.lb() is close to pi/2, the lower bound of tan(z.lb()) can be -oo. There
				// is nothing we can do about it (the lower bound cannot be evaluated in this case)
				//
				// note 4: tan(z.lb()) cannot be an empty set since z.lb() cannot be exactly pi/2.
				x &amp;= Interval(tan(Interval(z.lb())).lb(),POS_INFINITY);
			}
			// else do nothing
		}
	else
		if (z.ub()&lt;=-pi2u)
			x.set_empty();
		else if (z.lb()&lt;-pi2l)
			// Same comments as above.
			x &amp;= Interval(NEG_INFINITY,tan(Interval(z.ub())).ub());
		else
			x &amp;= Interval(tan(Interval(z.lb())).lb(),
					tan(Interval(z.ub())).ub());

	return !x.is_empty();
}


inline bool bwd_acosh(const Interval&amp; y,  Interval&amp; x) {
	if (y.is_empty() || y.ub()&lt;0.0) {
		x.set_empty(); return false;
	}
	else {
		x &amp;= cosh(Interval(y.lb()&lt;0?0:y.lb(),y.ub()));
		return !x.is_empty();
	}
}

inline bool bwd_asinh(const Interval&amp; y,  Interval&amp; x) {
	x &amp;= sinh(y);
	return !x.is_empty();
}

inline bool bwd_atanh(const Interval&amp; y,  Interval&amp; x) {
	x &amp;= tanh(y);
	return !x.is_empty();
}

inline bool bwd_max(const Interval&amp; y, Interval&amp; x1, Interval&amp; x2) {

	if (y.is_empty()) {
		x1.set_empty();
		x2.set_empty();
		return false;
	}

	/* ---- Disjoint intervals ---- */
	if (x2.lb()&gt;x1.ub() || y.lb()&gt;x1.ub()) {
		/* then, max(x,x2) is necessarily x2 */
		if ((x2 &amp;= y).is_empty()) { x1.set_empty(); return false;}
		else return true;
	} else if (x1.lb()&gt;x2.ub() || y.lb()&gt;x2.ub()) {
		if ((x1 &amp;= y).is_empty()) { x2.set_empty(); return false;}
		else return true;
	}
	/*------------------------------*/

	if (y.ub()&lt;x1.lb() || y.ub()&lt;x2.lb()) {
		x1.set_empty();
		x2.set_empty();
		return false; // inconsistency
	}

	/* At this point, x1, x2 and y all mutually intersect. */
	if (x1.ub()&gt;y.ub())
		x1=Interval(x1.lb(),y.ub());
	if (x2.ub()&gt;y.ub())
		x2=Interval(x2.lb(),y.ub());

	return true;
}

inline bool bwd_min(const Interval&amp; y, Interval&amp; x1, Interval&amp; x2) {

	Interval mx1=-x1;
	Interval mx2=-x2;

	if (!bwd_max(-y,mx1,mx2)) {
		x1.set_empty();
		x2.set_empty();
		return false;
	}

	x1=-mx1;
	x2=-mx2;
	return true;
}

inline bool bwd_sign(const Interval&amp; y,  Interval&amp; x) {

	if (y.is_empty()) {
		x.set_empty();
		return false;
	}

	if(y.lb()&gt;0)
		x &amp;= Interval::pos_reals();
	else if(y.ub()&lt;0)
		x &amp;= Interval::neg_reals();
	return !x.is_empty();
}


// probably not the most efficient implementation ever...
inline bool bwd_atan2(const Interval&amp; theta, Interval&amp; y, Interval&amp; x) {

	// half-plane x&gt;0
	Interval theta_xpos = theta  &amp; Interval(-1,1)*Interval::half_pi();
	// upper left quadrant
	Interval theta_xneg_ypos = theta  &amp; (Interval::half_pi() | Interval::pi());
	// lower left quadrant
	Interval theta_xneg_yneg = theta  &amp; -(Interval::half_pi() | Interval::pi());

	Interval xres= Interval::empty_set();
	Interval yres= Interval::empty_set();

	if (!theta_xpos.is_empty()) {

		Interval xpos=x &amp; Interval::pos_reals();
		Interval yall=y;

		if (theta_xneg_ypos.is_empty() || theta_xneg_yneg.is_empty()) { // otherwise, all is valid (useless to contract)
			Interval z=yall/xpos;
			bwd_atan(theta_xpos,z);
			bwd_div(z,yall,xpos);

		}
		xres |= xpos;
		yres |= yall;

		// because atan is not defined for pi/2 and -pi/2
		if (theta_xpos.lb()&gt;=Interval::half_pi().lb()) {
			xres |= (x &amp; Interval::zero());
			yres |= (y &amp; Interval::pos_reals());
		} else if (theta_xpos.ub()&lt;=-Interval::half_pi().lb()) {
			xres |= (x &amp; Interval::zero());
			yres |= (y &amp; Interval::neg_reals());
		}
	}

	if (!theta_xneg_ypos.is_empty()) {
		Interval xneg=x &amp; Interval::neg_reals();
		Interval ypos=y &amp; Interval::pos_reals();
		Interval z=ypos/xneg;
		bwd_atan(theta_xneg_ypos - Interval::pi(),z);
		bwd_div(z,ypos,xneg);
		xres |= xneg;
		yres |= ypos;	}

	if (!theta_xneg_yneg.is_empty()) {
		Interval xneg=x &amp; Interval::neg_reals();
		Interval yneg=y &amp; Interval::neg_reals();
		Interval z=yneg/xneg;
		bwd_atan(theta_xneg_yneg + Interval::pi(),z);
		bwd_div(z,yneg,xneg);
		xres |= xneg;
		yres |= yneg;
	}

	x=xres;
	y=yres;

	return !x.is_empty();
}


//inline bool bwd_atan2(const Interval&amp; theta, Interval&amp; y, Interval&amp; x) {
//
//	if (theta.is_empty()) {
//		x.set_empty(); y.set_empty();
//		return false;
//	}
//
//    //Lower half of upper right quadrant
//    if(theta.is_subset(Interval(0,M_PI/4.)))
//    {
//        x = (x&amp;Interval::pos_reals()) &amp; ( (y&amp;Interval::pos_reals()) * (1/tan(theta&amp;Interval(0,M_PI/4.))) );
//        y = (y&amp;Interval::pos_reals()) &amp; ( (x&amp;Interval::pos_reals()) * (tan(theta&amp;Interval(0,M_PI/4.))) );
//    }
//
//    //Upper half of upper right quadrant
//    else if(theta.is_subset(Interval(M_PI/4.,M_PI/2.)))
//    {
//        bwd_atan2(M_PI/2.-theta,x,y);
//    }
//
//    //Upper right quadrant
//    else if(theta.is_subset(Interval(0,M_PI/2)))
//    {
//        Interval x1=x; Interval y1=y; Interval x2=x; Interval y2=y;
//        Interval theta1(theta.lb(),M_PI/4.), theta2(M_PI/4., theta.ub());
//        bwd_atan2(theta1,y1,x1);
//        bwd_atan2(theta2,y2,x2);
//        x=x1|x2; y=y1|y2;
//    }
//
//    //Upper left quadrant
//    else if(theta.is_subset(Interval(M_PI/2,M_PI)))
//    {
//        Interval x2=-x;
//        Interval theta2=M_PI-theta;
//        bwd_atan2(theta2,y,x2);
//        x=-x2;
//    }
//
//    //Lower left quadrant
//    else if(theta.is_subset(Interval(M_PI,3*M_PI/2)))
//    {
//        Interval y2=-y;
//        Interval x2=-x;
//        Interval theta2=theta-M_PI;
//        bwd_atan2(theta2,y2,x2);
//        x=-x2; y=-y2;
//    }
//
//    //Lower right quadrant
//    else if(theta.is_subset(Interval(3*M_PI/2,2*M_PI)))
//    {
//        Interval x2=x;
//        Interval y2=-y;
//        Interval theta2=2*M_PI-theta;
//        bwd_atan2(theta2,y2,x2);
//        x=x2; y=-y2;
//    }
//
//    //Upper bissection
//    else if(theta.is_subset(Interval(0,M_PI))) {
//        Interval theta1(theta.lb(),M_PI/2), theta2(M_PI/2, theta.ub());
//        Interval x1=x; Interval y1=y; Interval x2=x; Interval y2=y;
//        if(theta.lb() != M_PI/2) bwd_atan2(theta1,y1,x1);
//        if(theta.ub() != M_PI/2) bwd_atan2(theta2,y2,x2);
//        x=x1|x2; y=y1|y2;
//    }
//
//    //Left bissection
//    else if(theta.is_subset(Interval(0,3*M_PI/2))) {
//        Interval theta1(theta.lb(),M_PI), theta2(M_PI, theta.ub());
//        Interval x1=x; Interval y1=y; Interval x2=x; Interval y2=y;
//        if(theta.lb() != M_PI) bwd_atan2(theta1,y1,x1);
//        if(theta.ub() != M_PI) bwd_atan2(theta2,y2,x2);
//        x=x1|x2; y=y1|y2;
//    }
//
//    //Lower bissection
//    else if(theta.is_subset(Interval(0,2*M_PI))) {
//        Interval theta1(theta.lb(),3*M_PI/2), theta2(3*M_PI/2, theta.ub());
//        Interval x1=x; Interval y1=y; Interval x2=x; Interval y2=y;
//        if(theta.lb() != 3*M_PI/2) bwd_atan2(theta1,y1,x1);
//        if(theta.ub() != 3*M_PI/2) bwd_atan2(theta2,y2,x2);
//        x=x1|x2; y=y1|y2;
//    }
//
//    //Theta diameter greater than 2PI then theta will be considered as [0,2PI]
//    else if (theta.diam() &gt; 2*M_PI)
//    {
//        Interval theta1(0,2*M_PI);
//        bwd_atan2(theta1,x,y);
//    }
//
//    // Modulo
//    else
//    {
//        // We separate the intervals into 4 cases as imod does not support union.
//        Interval theta1(0,M_PI/2.), theta2(M_PI/2., M_PI), theta3(M_PI, 3*M_PI/2.), theta4(3*M_PI/2., 2*M_PI);
//        Interval thetaTmp(theta);
//        bwd_imod(thetaTmp,theta1,2*M_PI);
//        thetaTmp=theta;
//        bwd_imod(thetaTmp,theta2,2*M_PI);
//        thetaTmp=theta;
//        bwd_imod(thetaTmp,theta3,2*M_PI);
//        thetaTmp=theta;
//        bwd_imod(thetaTmp,theta4,2*M_PI);
//        Interval x1=x; Interval y1=y;
//        bwd_atan2(theta1,y1,x1); // first quadrant
//        Interval x2=x; Interval y2=y;
//        bwd_atan2(theta2,y2,x2); // second quadrant
//        Interval x3=x; Interval y3=y;
//        bwd_atan2(theta3,y3,x3); // third quadrant
//        Interval x4=x; Interval y4=y;
//        bwd_atan2(theta4,y4,x4); // fourth quadrant
//        x=(x1|x2)|(x3|x4); y=(y1|y2)|(y3|y4);
//        // not_implemented("bwd_atan2 not implemented yet for theta outside [0,2*PI].");
//    }
//
//
//    return !x.is_empty() || !y.is_empty();
//}

inline bool bwd_chi(const Interval&amp; f, Interval&amp; a, Interval&amp; b, Interval&amp; c){
	if      (a.ub()&lt;=0) {if ((b &amp;= f).is_empty()) { a.set_empty(); c.set_empty(); return false; } }
	else if (a.lb()&gt;0)  {if ((c &amp;= f).is_empty()) { a.set_empty(); b.set_empty(); return false; } }

	if (f.is_disjoint(b)) {
		if ((a &amp;= Interval::pos_reals()).is_empty()) { b.set_empty(); c.set_empty(); return false; }
		if ((c &amp;= f).is_empty()) { a.set_empty(); b.set_empty(); return false; }
	}
	if (f.is_disjoint(c)) {
		if ((a &amp;= Interval::neg_reals()).is_empty()) { b.set_empty(); c.set_empty(); return false; }
		if ((b &amp;= f).is_empty()) { a.set_empty(); c.set_empty(); return false; }
	}
	return true;
}


inline bool bwd_floor(const Interval&amp; y, Interval&amp; x) {
	if (y.is_empty()) {
		x.set_empty();
		return false;
	} else {
		double r=std::floor(y.ub());
		double l=std::ceil(y.lb());
		if (r&lt;l) {
			x.set_empty();
			return false;
		}
		else {
			x &amp;= Interval(l,r) + Interval(0,1);
			return !x.is_empty();
		}
	}
}

inline bool bwd_ceil(const Interval&amp; y, Interval&amp; x) {
	if (y.is_empty()) {
		x.set_empty();
		return false;
	} else {
		double r=std::floor(y.ub());
		double l=std::ceil(y.lb());
		if (r&lt;l) {
			x.set_empty();
			return false;
		}
		else {
			x &amp;= Interval(l,r) + Interval(-1,0);
			return !x.is_empty();
		}
	}
}

// Implements interval modulo with double period:  x = y mod(p)
inline bool bwd_imod(Interval&amp; x, Interval&amp; y, const double&amp; p) {
    if (p &lt;= 0.)
    {
        ibex_error("Modulo needs a strictly positive period p.");
        return false;
    }
    if (y.diam()&gt;p || x.diam()&gt;p)
        return false;
    Interval r = (x-y)/p;
    Interval ir = integer(r);
    if (ir.is_empty()) // additional protection because an empty interval is considered degenerated.
    {
        x.set_empty(); y.set_empty();
        return false;
    }
    if (ir.is_degenerated())
        bwd_sub(ir*p,x,y);
    else if (ir.diam()==1.)
    {
        double ir1 = ir.lb();
        double ir2 = ir.ub();
        Interval x1 = x; Interval x2 = x;
        Interval y1 = y; Interval y2 = y;
        bwd_sub(Interval(ir1*p),x1,y1);
        bwd_sub(Interval(ir2*p),x2,y2);
        x = x1 | x2;
        y = y1 | y2;
    }
    else
    {
        ibex_error("Modulo diameter error.");
        return false;
    }

    return true;
}

} // end namespace ibex

#endif // _IBEX_INTERVAL_H_
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>vibes.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include "vibes.h"
#include &lt;sstream&gt;
#include &lt;cstdlib&gt;
#include &lt;cstdio&gt;
#include &lt;cassert&gt;

//
// Vibes properties key,value system implementation
//

namespace vibes {
    std::string Value::toJSONString() const {
        std::ostringstream ss;
        switch (_type) {
        case vt_integer:
            ss&lt;&lt;_integer; break;
        case vt_decimal:
            ss&lt;&lt;_decimal; break;
        case vt_string:
            ss&lt;&lt;'"'&lt;&lt;_string&lt;&lt;'"'; break;
        case vt_array:
            ss &lt;&lt; '[';
            for (std::vector&lt;Value&gt;::const_iterator it = _array.begin(); it != _array.end(); ++it) {
                if (it != _array.begin()) ss &lt;&lt; ',';
                ss &lt;&lt; it-&gt;toJSONString();
            }
            ss &lt;&lt; ']';
            break;
        case vt_object:
            ss &lt;&lt; '{' &lt;&lt; _object-&gt;toJSON() &lt;&lt; '}';
            break;
        case vt_none:
        default:
            break;
        }
        return ss.str();
    }

    std::string Params::toJSON() const {
        std::ostringstream ss;
        for(std::map&lt;std::string, Value&gt;::const_iterator it = _values.begin(); it != _values.end(); ++it)
            ss &lt;&lt; (it==_values.begin()?"":", ") &lt;&lt; "\"" &lt;&lt; it-&gt;first &lt;&lt; "\":" &lt;&lt; it-&gt;second.toJSONString();
        return ss.str();
    }

    Value Params::pop(const std::string &amp;key, const Value &amp;value_not_found) {
        KeyValueMap::iterator it = _values.find(key);
        // Return empty value if not found
        if (it == _values.end())
            return value_not_found;
        // Otherwise, return corresponding value and remove it from map
        Value val = it-&gt;second;
        _values.erase(it);
        return val;
    }
}

//
// Vibes messaging implementation
//

using namespace std;

namespace vibes
{
  //
  // Global variables and utility functions
  //

  /// Current communication file descriptor
  FILE *channel=0;

  /// Current figure name (client-maintained state)
  string current_fig="default";

  //
  // Management of connection to the Vibes server
  //

  void beginDrawing()
  {
      // Retrieve user-profile directory from envirnment variable
      char * user_dir = getenv("USERPROFILE"); // Windows
      if (!user_dir)
          user_dir = getenv("HOME"); // POSIX
      if (user_dir)
      { // Environment variable found, connect to a file in user's profile directory
          std::string file_name(user_dir);
          file_name.append("/.vibes.json");
          beginDrawing(file_name);
      }
      else
      { // Connect to a file in working directory
          beginDrawing("vibes.json");
      }
  }
  
  void beginDrawing(const std::string &amp;fileName)
  {
    channel=fopen(fileName.c_str(),"a");
  }
  
  void endDrawing()
  {
    fclose(channel);
  }

  //
  // Figure management
  //

  void newFigure(const std::string &amp;figureName)
  {
    std::string msg;
    if (!figureName.empty()) current_fig = figureName;
    msg ="{\"action\":\"new\","
          "\"figure\":\""+(figureName.empty()?current_fig:figureName)+"\"}\n\n";
    fputs(msg.c_str(),channel);
    fflush(channel);
  }
  
  void clearFigure(const std::string &amp;figureName)
  {
    std::string msg;
    msg="{\"action\":\"clear\","
         "\"figure\":\""+(figureName.empty()?current_fig:figureName)+"\"}\n\n";
    fputs(msg.c_str(),channel);
    fflush(channel);
  }

  void closeFigure(const std::string &amp;figureName)
  {
    std::string msg;
    msg="{\"action\":\"close\","
         "\"figure\":\""+(figureName.empty()?current_fig:figureName)+"\"}\n\n";
    fputs(msg.c_str(),channel);
    fflush(channel);
  }

  void saveImage(const std::string &amp;fileName, const std::string &amp;figureName)
  {
      std::string msg;
      msg="{\"action\":\"export\","
           "\"figure\":\""+(figureName.empty()?current_fig:figureName)+"\","
           "\"file\":\""+fileName+"\"}\n\n";
      fputs(msg.c_str(),channel);
      fflush(channel);
  }

  void selectFigure(const std::string &amp;figureName)
  {
     current_fig = figureName;
  }


  //
  // View settings
  //

  void axisAuto(const std::string &amp;figureName)
  {
    setFigureProperty(figureName.empty()?current_fig:figureName, "viewbox", "auto");
  }

  void axisLimits(const double &amp;x_lb, const double &amp;x_ub, const double &amp;y_lb, const double &amp;y_ub, const std::string &amp;figureName)
  {
    setFigureProperty(figureName.empty()?current_fig:figureName, "viewbox", (Vec4d){x_lb,x_ub,y_lb,y_ub});
  }

  void axisLabels(const std::string &amp;x_label, const std::string &amp;y_label, const std::string &amp;figureName)
  {
    vector&lt;string&gt; labels;
    labels.push_back(x_label);
    labels.push_back(y_label);
    axisLabels(labels, figureName);
  }

  void axisLabels(const std::vector&lt;std::string&gt; &amp;labels, const std::string &amp;figureName)
  {
    setFigureProperty( figureName.empty()?current_fig:figureName, "axislabels", labels);
  }


  //
  // Drawing functions
  //

  void drawBox(const double &amp;x_lb, const double &amp;x_ub, const double &amp;y_lb, const double &amp;y_ub, Params params)
  {
    Params msg;
    msg["action"] = "draw";
    msg["figure"] = params.pop("figure",current_fig);
    msg["shape"] = (params, "type", "box", "bounds", (Vec4d){x_lb,x_ub,y_lb,y_ub});

    fputs(Value(msg).toJSONString().append("\n\n").c_str(), channel);
    fflush(channel);
  }

  void drawBox(const vector&lt;double&gt; &amp;bounds, Params params)
  {
    assert(!bounds.empty());
    assert(bounds.size()%2 == 0);

    Params msg;
    msg["action"] = "draw";
    msg["figure"] = params.pop("figure",current_fig);
    msg["shape"] = (params, "type", "box", "bounds", vector&lt;Value&gt;(bounds.begin(),bounds.end()));

    fputs(Value(msg).toJSONString().append("\n\n").c_str(), channel);
    fflush(channel);
  }


  void drawEllipse(const double &amp;cx, const double &amp;cy, const double &amp;a, const double &amp;b, const double &amp;rot, Params params)
  {
      Params msg;
      msg["action"] = "draw";
      msg["figure"] = params.pop("figure",current_fig);
      msg["shape"] = (params, "type", "ellipse",
                              "center", (Vec2d){cx,cy},
                              "axis", (Vec2d){a,b},
                              "orientation", rot);

      fputs(Value(msg).toJSONString().append("\n\n").c_str(), channel);
<a name="0"></a>      fflush(channel);
  }

<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  void drawConfidenceEllipse(const double &amp;cx, const double &amp;cy,
                             const double &amp;sxx, const double &amp;sxy, const double &amp;syy,
                             const double &amp;K, Params params)</b></font>
  {
      Params msg;
      msg["action"] = "draw";
      msg["figure"] = params.pop("figure",current_fig);
      msg["shape"] = (params, "type", "ellipse",
                              "center", (Vec2d){cx,cy},
                              "covariance", (Vec4d){sxx,sxy,sxy,syy},
                              "sigma", K);

      fputs(Value(msg).toJSONString().append("\n\n").c_str(), channel);
      fflush(channel);
  }

  void drawConfidenceEllipse(const vector&lt;double&gt; &amp;center, const vector&lt;double&gt; &amp;cov,
                             const double &amp;K, Params params)
  {
      Params msg;
      msg["action"] = "draw";
      msg["figure"] = params.pop("figure",current_fig);
      msg["shape"] = (params, "type", "ellipse",
                              "center", vector&lt;Value&gt;(center.begin(),center.end()),
                              "covariance", vector&lt;Value&gt;(cov.begin(),cov.end()),
                              "sigma", K);

      fputs(Value(msg).toJSONString().append("\n\n").c_str(), channel);
      fflush(channel);
  }

  void drawBoxes(const std::vector&lt;std::vector&lt;double&gt; &gt; &amp;bounds, Params params)
  {
     Params msg;
     msg["action"] = "draw";
     msg["figure"] = params.pop("figure",current_fig);
     msg["shape"] = (params, "type", "boxes",
                             "bounds", bounds);

     fputs(Value(msg).toJSONString().append("\n\n").c_str(), channel);
     fflush(channel);
  }

  void drawBoxesUnion(const std::vector&lt;std::vector&lt;double&gt; &gt; &amp;bounds, Params params)
  {
     Params msg;
     msg["action"] = "draw";
     msg["figure"] = params.pop("figure",current_fig);
     msg["shape"] = (params, "type", "boxes union",
                             "bounds", bounds);

     fputs(Value(msg).toJSONString().append("\n\n").c_str(), channel);
     fflush(channel);
  }

  void drawLine(const std::vector&lt;std::vector&lt;double&gt; &gt; &amp;points, Params params)
  {
     Params msg;
     msg["action"] = "draw";
     msg["figure"] = params.pop("figure",current_fig);
     msg["shape"] = (params, "type", "line",
                             "points", points);

     fputs(Value(msg).toJSONString().append("\n\n").c_str(), channel);
     fflush(channel);
  }

  void drawLine(const std::vector&lt;double&gt; &amp;x, const std::vector&lt;double&gt; &amp;y, Params params)
  {
     // Reshape x and y into a vector of points
     std::vector&lt;Value&gt; points;
     std::vector&lt;double&gt;::const_iterator itx = x.begin();
     std::vector&lt;double&gt;::const_iterator ity = y.begin();
     while (itx != x.end() &amp;&amp; ity != y.end()) {
        points.push_back( (Vec2d){*itx++,*ity++} );
     }
     // Send message
     Params msg;
     msg["action"] = "draw";
     msg["figure"] = params.pop("figure",current_fig);
     msg["shape"] = (params, "type", "line",
                             "points", points);

     fputs(Value(msg).toJSONString().append("\n\n").c_str(), channel);
     fflush(channel);
  }


  void newGroup(const std::string &amp;name, Params params)
  {
     // Send message
     Params msg;
     msg["action"] = "draw";
     msg["figure"] = params.pop("figure",current_fig);
     msg["shape"] = (params, "type", "group",
                             "name", name);

     fputs(Value(msg).toJSONString().append("\n\n").c_str(), channel);
     fflush(channel);
  }

  void clearGroup(const std::string &amp;figureName, const std::string &amp;groupName)
  {
     Params msg;
     msg["action"] = "clear";
     msg["figure"] = figureName;
     msg["group"] = groupName;

     fputs(Value(msg).toJSONString().append("\n\n").c_str(), channel);
     fflush(channel);
  }

  void clearGroup(const std::string &amp;groupName)
  {
     clearGroup(current_fig, groupName);
  }


  void removeObject(const std::string &amp;figureName, const std::string &amp;objectName)
  {
     Params msg;
     msg["action"] = "delete";
     msg["figure"] = figureName;
     msg["object"] = objectName;

     fputs(Value(msg).toJSONString().append("\n\n").c_str(), channel);
     fflush(channel);
  }

  void removeObject(const std::string &amp;objectName)
  {
     removeObject(current_fig, objectName);
  }

  // Property modification
  void setFigureProperties(const std::string &amp;figureName, const Params &amp;properties)
  {
     // Send message
     Params msg;
     msg["action"] = "set";
     msg["figure"] = figureName;
     msg["properties"] = properties;

     fputs(Value(msg).toJSONString().append("\n\n").c_str(), channel);
     fflush(channel);
  }

  void setFigureProperties(const Params &amp;properties)
  {
     setFigureProperties(current_fig, properties);
  }

  void setObjectProperties(const std::string &amp;figureName, const std::string &amp;objectName, const Params &amp;properties)
  {
     // Send message
     Params msg;
     msg["action"] = "set";
     msg["figure"] = figureName;
     msg["object"] = objectName;
     msg["properties"] = properties;

     fputs(Value(msg).toJSONString().append("\n\n").c_str(), channel);
     fflush(channel);
  }

  void setObjectProperties(const std::string &amp;objectName, const Params &amp;properties)
  {
     setObjectProperties(current_fig, objectName, properties);
  }
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerHTML.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
