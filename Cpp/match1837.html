<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for ibex_Interval.h &amp; vibes.cpp</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for ibex_Interval.h &amp; vibes.cpp
      </h3>
<h1 align="center">
        1.6%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>ibex_Interval.h (1.1100832%)<th>vibes.cpp (3.217158%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(164-216)<td><a href="#" name="0">(228-230)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>ibex_Interval.h</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifndef _IBEX_INTERVAL_H_
2 #define _IBEX_INTERVAL_H_
3 #include &lt;array&gt;
4 #include &lt;math.h&gt;
5 #include "ibex_Exception.h"
6 #include "ibex_Setting.h"
7 #include "ibex_IntervalLibWrapper.h"
8 #define NEG_INFINITY IBEX_INTERVAL_LIB_NEG_INFINITY
9 #define POS_INFINITY IBEX_INTERVAL_LIB_POS_INFINITY
10 #ifdef _MSC_VER
11 #include &lt;intrin.h&gt;
12 #define __builtin_popcount __popcnt
13 #define __builtin_powi(__x,__n) ((double)::pow((double)(__x),(int)(__n)))
14 #endif 
15 namespace ibex {
16 class IntervalVector;
17 class IntervalMatrix;
18 class ExprConstant;
19 void fpu_round_down();
20 void fpu_round_up();
21 void fpu_round_near();
22 void fpu_round_zero();
23 double previous_float(double x);
24 double next_float(double x);
25 class Interval {
26   public:
27     Interval();
28     Interval(double a, double b);
29     Interval(double a);
30     Interval(std::array&lt;double, 1&gt; array);
31     Interval(std::array&lt;double, 2&gt; array);
32     bool operator==(const Interval&amp; x) const;
33     bool operator!=(const Interval&amp; x) const;
34     void set_empty();
35     Interval&amp; operator=(const Interval&amp; x);
36     Interval&amp; operator=(double x);
37     Interval&amp; operator&amp;=(const Interval&amp; x);
38     Interval&amp; operator|=(const Interval&amp; x);
39     Interval&amp; inflate(double rad);
40 	Interval&amp; inflate(double delta, double chi);
41 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    double lb() const;
42     double ub() const;
43     double mid() const;
44     double rad() const;
45     double diam() const;
46     double mig() const;
47     double mag() const;</b></font>
48     bool is_subset(const Interval&amp; x) const;
49     bool is_strict_subset(const Interval&amp; x) const;
50     bool is_interior_subset(const Interval&amp; x) const;
51     bool is_relative_interior_subset(const Interval&amp; x) const;
52     bool is_strict_interior_subset(const Interval&amp; x) const;
53     bool is_superset(const Interval&amp; x) const;
54     bool is_strict_superset(const Interval&amp; x) const;
55     bool contains(const double&amp; d) const;
56     bool interior_contains(const double&amp; d) const;
57     bool intersects(const Interval &amp;x) const;
58     bool overlaps(const Interval &amp;x) const;
59     bool is_disjoint(const Interval &amp;x) const;
60     bool is_empty() const;
61     bool is_degenerated() const;
62     bool is_unbounded() const;
63     bool is_bisectable() const;
64     double rel_distance(const Interval&amp; x) const;
65     int complementary(Interval&amp; c1, Interval&amp; c2, bool compactness = true) const;
66     int diff(const Interval&amp; y, Interval&amp; c1, Interval&amp; c2, bool compactness = true) const;
67     Interval operator-() const;
68     Interval&amp; operator+=(double d);
69     Interval&amp; operator-=(double d);
70     Interval&amp; operator*=(double d);
71     Interval&amp; operator/=(double d);
72     Interval&amp; operator+=(const Interval&amp; x);
73     Interval&amp; operator-=(const Interval&amp; x);
74     Interval&amp; operator*=(const Interval&amp; x);
75     Interval&amp; operator/=(const Interval&amp; x);
76     bool div2_inter(const Interval&amp; x, const Interval&amp; y, Interval&amp; out2);
77     Interval&amp; div2_inter(const Interval&amp; x, const Interval&amp; y);
78     double delta(const Interval&amp; x) const;
79     double ratiodelta(const Interval&amp; x) const;
80     std::pair&lt;Interval,Interval&gt; bisect(double ratio=0.5) const;
81     static const Interval PI;
82     static const Interval&amp; pi();
83     static const Interval TWO_PI;
84     static const Interval&amp; two_pi();
85     static const Interval HALF_PI;
86     static const Interval&amp; half_pi();
87     static const Interval EMPTY_SET;
88     static const Interval&amp; empty_set();
89     static const Interval ALL_REALS;
90     static const Interval&amp; all_reals();
91     static const Interval ZERO;
92     static const Interval&amp; zero();
93     static const Interval ONE;
94     static const Interval&amp; one();
95     static const Interval POS_REALS;
96     static const Interval&amp; pos_reals();
97     static const Interval NEG_REALS;
98     static const Interval&amp; neg_reals();
99     typedef Interval SCALAR;
100     typedef IntervalVector VECTOR;
101     typedef IntervalMatrix MATRIX;
102     operator const ExprConstant&amp;() const;
103     Interval(const interval_type_wrapper&amp; x);
104     Interval&amp; operator=(const interval_type_wrapper&amp; x);
105     interval_type_wrapper itv;
106 };
107 std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Interval&amp; x);
108 Interval operator&amp;(const Interval&amp; x1, const Interval&amp; x2);
109 Interval operator|(const Interval&amp; x1, const Interval&amp; x2);
110 Interval operator+(const Interval&amp; x, double d);
111 Interval operator-(const Interval&amp; x, double d);
112 Interval operator*(const Interval&amp; x, double d);
113 Interval operator/(const Interval&amp; x, double d);
114 void div2(const Interval&amp; x, const Interval&amp; y, Interval&amp; out1, Interval&amp; out2);
115 Interval operator+(double d,const Interval&amp; x);
116 Interval operator-(double d, const Interval&amp; x);
117 Interval operator*(double d, const Interval&amp; x);
118 Interval operator/(double d, const Interval&amp; x);
119 Interval operator+(const Interval&amp; x1, const Interval&amp; x2);
120 Interval operator-(const Interval&amp; x1, const Interval&amp; x2);
121 Interval operator*(const Interval&amp; x1, const Interval&amp; x2);
122 Interval operator/(const Interval&amp; x1, const Interval&amp; x2);
123 double distance(const Interval &amp;x1, const Interval &amp;x2);
124 Interval sqr(const Interval&amp; x);
125 Interval sqrt(const Interval&amp; x);
126 Interval pow(const Interval&amp; x, int n);
127 Interval pow(const Interval&amp; x, double d);
128 Interval pow(const Interval &amp;x, const Interval &amp;y);
129 Interval root(const Interval&amp; x, int n);
130 Interval exp(const Interval&amp; x);
131 Interval log(const Interval&amp; x);
132 Interval cos(const Interval&amp; x);
133 Interval sin(const Interval&amp; x);
134 Interval tan(const Interval&amp; x);
135 Interval acos(const Interval&amp; x);
136 Interval asin(const Interval&amp; x);
137 Interval atan(const Interval&amp; x);
138 Interval atan2(const Interval&amp; y, const Interval&amp; x);
139 Interval cosh(const Interval&amp; x);
140 Interval sinh(const Interval&amp; x);
141 Interval tanh(const Interval&amp; x);
142 Interval acosh(const Interval&amp; x);
143 Interval asinh(const Interval&amp; x);
144 Interval atanh(const Interval&amp; x);
145 Interval abs(const Interval &amp;x);
146 Interval max(const Interval&amp; x, const Interval&amp; y);
147 Interval min(const Interval&amp; x, const Interval&amp; y);
148 Interval sign(const Interval&amp; x);
149 Interval chi(const Interval&amp; a, const Interval&amp; b, const Interval&amp; c);
150 Interval integer(const Interval&amp; x);
151 Interval floor(const Interval&amp; x);
152 Interval ceil(const Interval&amp; x);
153 Interval saw(const Interval&amp; x);
154 bool bwd_add(const Interval&amp; y, Interval&amp; x1, Interval&amp; x2);
155 bool bwd_sub(const Interval&amp; y, Interval&amp; x1, Interval&amp; x2);
156 bool bwd_mul(const Interval&amp; y, Interval&amp; x1, Interval&amp; x2);
157 bool bwd_div(const Interval&amp; y, Interval&amp; x1, Interval&amp; x2);
158 bool bwd_sqr(const Interval&amp; y, Interval&amp; x);
159 bool bwd_sqrt(const Interval&amp; y, Interval&amp; x);
160 bool bwd_pow(const Interval&amp; y, int n, Interval&amp; x);
161 bool bwd_pow(const Interval&amp; y, Interval&amp; x1, Interval&amp; x2);
162 bool bwd_root(const Interval&amp; y, int n, Interval&amp; x);
163 bool bwd_exp(const Interval&amp; y,  Interval&amp; x);
164 bool bwd_log(const Interval&amp; y,  Interval&amp; x);
165 bool bwd_cos(const Interval&amp; y,  Interval&amp; x);
166 bool bwd_sin(const Interval&amp; y,  Interval&amp; x);
167 bool bwd_tan(const Interval&amp; y,  Interval&amp; x);
168 bool bwd_acos(const Interval&amp; y,  Interval&amp; x);
169 bool bwd_asin(const Interval&amp; y,  Interval&amp; x);
170 bool bwd_atan(const Interval&amp; y,  Interval&amp; x);
171 bool bwd_atan2(const Interval&amp; y, Interval&amp; x1, Interval&amp; x2);
172 bool bwd_cosh(const Interval&amp; y,  Interval&amp; x);
173 bool bwd_sinh(const Interval&amp; y,  Interval&amp; x);
174 bool bwd_tanh(const Interval&amp; y,  Interval&amp; x);
175 bool bwd_acosh(const Interval&amp; y,  Interval&amp; x);
176 bool bwd_asinh(const Interval&amp; y,  Interval&amp; x);
177 bool bwd_atanh(const Interval&amp; y,  Interval&amp; x);
178 bool bwd_abs(const Interval&amp; y,  Interval&amp; x);
179 bool bwd_max(const Interval&amp; y, Interval&amp; x1, Interval&amp; x2);
180 bool bwd_min(const Interval&amp; y, Interval&amp; x1, Interval&amp; x2);
181 bool bwd_sign(const Interval&amp; y, Interval&amp; x);
182 bool bwd_chi(const Interval&amp; f, Interval&amp; a, Interval&amp; b, Interval&amp; c);
183 bool bwd_floor(const Interval&amp; y, Interval&amp; x);
184 bool bwd_ceil(const Interval&amp; y, Interval&amp; x);
185 bool bwd_saw(const Interval&amp; y, Interval&amp; x);
186 bool bwd_imod(Interval&amp; x, Interval&amp; y, const double&amp; p);
187 } 
188 #include "ibex_IntervalLibWrapper.inl"
189 namespace ibex {
190 inline bool ___is_empty(double)             { return false; }
191 inline bool ___is_empty(const Interval&amp; x)  { return x.is_empty(); }
192 inline void ___set_empty(double)            { }
193 inline void ___set_empty(Interval&amp; x)       { x.set_empty(); }
194 inline double ___abs(double x)              { return fabs(x);}
195 inline Interval ___abs(const Interval&amp; x)   { return abs(x);}
196 inline double ___mag(double x)              { return fabs(x);}
197 inline double ___mag(const Interval&amp; x)     { return x.mag();}
198 inline Interval::Interval() : itv(NEG_INFINITY, POS_INFINITY) {
199 }
200 inline Interval::Interval(double a, double b) : itv(a,b) {
201 	if (a==POS_INFINITY || b==NEG_INFINITY || a&gt;b) *this=EMPTY_SET;
202 }
203 inline Interval::Interval(double a) : itv(a,a) {
204 	if (a==NEG_INFINITY || a==POS_INFINITY) *this=EMPTY_SET;
205 }
206 inline Interval::Interval(std::array&lt;double, 1&gt; array): Interval(array[0]) {}
207 inline Interval::Interval(std::array&lt;double, 2&gt; array): Interval(array[0], array[1]) {}
208 inline bool Interval::operator==(const Interval&amp; x) const {
209 	return (is_empty() &amp;&amp; x.is_empty()) || (lb()==x.lb() &amp;&amp; ub()==x.ub());
210 }
211 inline Interval&amp; Interval::operator=(double x) {
212 	if (x==NEG_INFINITY || x==POS_INFINITY)
213 		*this=EMPTY_SET;
214 	else
215 		itv = x;
216 	return *this;
217 }
218 inline Interval&amp; Interval::operator=(const Interval&amp; x) {
219 	itv = x.itv;
220 	return *this;
221 }
222 inline Interval&amp; Interval::inflate(double radd) {
223 	(*this) += Interval(-radd,radd);
224 	return *this;
225 }
226 inline Interval&amp; Interval::inflate(double delta, double chi) {
227 	double m=mid();
228 	(*this) = m + delta*(*this-m)+Interval(-chi,chi);
229 	return *this;
230 }
231 inline bool Interval::operator!=(const Interval&amp; x) const {
232 	return !(*this==x);
233 }
234 inline double Interval::rad() const {
235 	if (is_empty()) return 0;
236 	else if (is_unbounded()) return POS_INFINITY;
237 	else {
238 		double t = mid();
239 		double t1 =(t-*this).ub();
240 		double t2= (*this-t).ub();
241 		return (t1&gt;t2) ? t1 : t2;
242 	}
243 }
244 inline bool Interval::is_bisectable() const {
245 	if (is_empty()) return false;
246 	double m=mid();
247 	return (lb()&lt;m &amp;&amp; m&lt;ub());
248 }
249 inline double Interval::rel_distance(const Interval&amp; x) const {
250 	  double d=distance(*this,x);
251 	  if (d==POS_INFINITY) return 1;
252 	  double D=diam();
253 	  return (D==0 || D==POS_INFINITY) ? 0.0 : (d/D); }
254 inline double distance(const Interval &amp;x1, const Interval &amp;x2) {
255     if (x1.is_empty()) return x2.rad();
256     if (x2.is_empty()) return x1.rad();
257     if (x1.lb()==NEG_INFINITY) {
258     	if (x2.lb()!=NEG_INFINITY)
259     		return POS_INFINITY;
260     	else if (x1.ub()==POS_INFINITY) {
261     		if (x2.ub()==POS_INFINITY) return 0.0;
262     		else return POS_INFINITY;
263     	}
264     	else if (x2.ub()==POS_INFINITY) return POS_INFINITY;
265     	else return fabs(x1.ub()-x2.ub());
266     }
267     else if (x1.ub()==POS_INFINITY) {
268     	if (x2.ub()!=POS_INFINITY)
269     		return POS_INFINITY;
270     	else if (x2.lb()==NEG_INFINITY)
271     		return POS_INFINITY;
272     	else return fabs(x1.lb()-x2.lb());
273     }
274     else if (x2.is_unbounded())
275     	return POS_INFINITY;
276     else
277     	return _interval_distance_wrapper (x1.itv, x2.itv);
278 }
279 inline Interval sign(const Interval&amp; x) {
280 	return x.ub()&lt;0 ? Interval(-1,-1) : x.lb()&gt;0 ? Interval(1,1) : Interval(-1,1);
281 }
282 inline Interval chi(const Interval&amp; a, const Interval&amp; b, const Interval&amp; c){
283 	if (a.ub()&lt;=0) {
284 		return b;
285 	} else if (a.lb()&gt;0) {
286 		return c;
287 	} else {
288 		return b|c;
289 	}
290 }
291 inline Interval atan2(const Interval&amp; y, const Interval&amp; x) {
292 	if (y.is_empty() || x.is_empty()) return Interval::empty_set();
293 	else if (x==Interval::zero()) {
294 		if (y.lb()&gt;=0)
295 			if (y.ub()==0) return Interval::empty_set(); 			else return Interval::half_pi();
296 		else if (y.ub()&lt;=0) return -Interval::half_pi();
297 		else return Interval(-1,1)*Interval::half_pi();
298 	}
299 	else if (x.lb()&gt;=0) {
300 		return atan(y/x); 	}
301 	else if (x.ub()&lt;=0) {
302 		if (y.lb()&gt;=0)
303 			return atan(y/x)+Interval::pi(); 		else if (y.ub()&lt;0)
304 			return atan(y/x)-Interval::pi();
305 		else
306 			return Interval(-1,1)*Interval::pi();
307 	} else {
308 		if (y.lb()&gt;=0)
309 			return atan(y/x.ub()) | (atan(y/x.lb()) + Interval::pi());
310 		else if (y.ub()&lt;=0){
311 			if(x.lb()!=NEG_INFINITY){
312 				if(x.ub()!=POS_INFINITY){
313 					return (atan(y/x.lb())-Interval::pi()) | atan(y/x.ub());
314 				}
315 				else
316 					return (atan(y/x.lb())-Interval::pi()) | Interval::zero();
317 			}
318 			else{
319 				if(x.ub()!=POS_INFINITY)
320 					return (-Interval::pi()) | atan(y/x.ub());
321 				else
322 					return -Interval::pi() | Interval::zero();
323 			}
324 		}
325 		else
326 			return Interval(-1,1)*Interval::pi();
327 	}
328 }
329 inline bool bwd_add(const Interval&amp; y, Interval&amp; x1, Interval&amp; x2) {
330 	if ((x1 &amp;= y-x2).is_empty()) { x2.set_empty(); return false; }
331 	if ((x2 &amp;= y-x1).is_empty()) { x1.set_empty(); return false; }
332 	return true;
333 }
334 inline bool bwd_sub(const Interval&amp; y, Interval&amp; x1, Interval&amp; x2) {
335 	if ((x1 &amp;= y+x2).is_empty()) { x2.set_empty(); return false; }
336 	if ((x2 &amp;= x1-y).is_empty()) { x1.set_empty(); return false; }
337 	return true;
338 }
339 inline bool bwd_div(const Interval&amp; y, Interval&amp; x1, Interval&amp; x2) {
340 	if ((x1 &amp;= y*x2).is_empty()) { x2.set_empty(); return false; }
341 	Interval tmp=y;
342 	bwd_mul(x1, tmp, x2);
343 	if (x2.is_empty()) { x1.set_empty(); return false; }
344 	return true;
345 }
346 inline bool bwd_sqrt(const Interval&amp; y, Interval&amp; x) {
347 	if (y.is_empty() || y.ub()&lt;0) {
348 		x.set_empty();
349 	} else if (y.lb()&lt;0) {
350 		x &amp;= sqr(Interval(0,y.ub()));
351 	} else  {
352 		x &amp;= sqr(y);
353 	}
354 	return !x.is_empty();
355 }
356 inline bool bwd_root(const Interval&amp; y, int n, Interval&amp; x) {
357 	x &amp;= pow(y,n);
358 	return !x.is_empty();
359 }
360 inline bool bwd_exp(const Interval&amp; y,  Interval&amp; x) {
361 	x &amp;= log(y);
362 	return !x.is_empty();
363 }
364 inline bool bwd_log(const Interval&amp; y,  Interval&amp; x) {
365 	x &amp;= exp(y);
366 	return !x.is_empty();
367 }
368 inline bool bwd_acos(const Interval&amp; y,  Interval&amp; x) {
369 	x &amp;= cos(y);
370 	return !x.is_empty();
371 }
372 inline bool bwd_asin(const Interval&amp; y,  Interval&amp; x) {
373 	x &amp;= sin(y);
374 	return !x.is_empty();
375 }
376 inline bool bwd_atan(const Interval&amp; y,  Interval&amp; x) {
377 	if (y.is_empty()) {
378 		x.set_empty();
379 		return false;
380 	}
381 	Interval z=y;
382 	double pi2l=(Interval::pi()/2).lb();
383 	double pi2u=(Interval::pi()/2).ub();
384 	if (z.ub()&gt;=pi2l) 		if (z.lb()&gt;=pi2u)
385 			x.set_empty();
386 		else {
387 			if (z.lb()&gt;-pi2l) {
388 				x &amp;= Interval(tan(Interval(z.lb())).lb(),POS_INFINITY);
389 			}
390 		}
391 	else
392 		if (z.ub()&lt;=-pi2u)
393 			x.set_empty();
394 		else if (z.lb()&lt;-pi2l)
395 			x &amp;= Interval(NEG_INFINITY,tan(Interval(z.ub())).ub());
396 		else
397 			x &amp;= Interval(tan(Interval(z.lb())).lb(),
398 					tan(Interval(z.ub())).ub());
399 	return !x.is_empty();
400 }
401 inline bool bwd_acosh(const Interval&amp; y,  Interval&amp; x) {
402 	if (y.is_empty() || y.ub()&lt;0.0) {
403 		x.set_empty(); return false;
404 	}
405 	else {
406 		x &amp;= cosh(Interval(y.lb()&lt;0?0:y.lb(),y.ub()));
407 		return !x.is_empty();
408 	}
409 }
410 inline bool bwd_asinh(const Interval&amp; y,  Interval&amp; x) {
411 	x &amp;= sinh(y);
412 	return !x.is_empty();
413 }
414 inline bool bwd_atanh(const Interval&amp; y,  Interval&amp; x) {
415 	x &amp;= tanh(y);
416 	return !x.is_empty();
417 }
418 inline bool bwd_max(const Interval&amp; y, Interval&amp; x1, Interval&amp; x2) {
419 	if (y.is_empty()) {
420 		x1.set_empty();
421 		x2.set_empty();
422 		return false;
423 	}
424 	if (x2.lb()&gt;x1.ub() || y.lb()&gt;x1.ub()) {
425 		if ((x2 &amp;= y).is_empty()) { x1.set_empty(); return false;}
426 		else return true;
427 	} else if (x1.lb()&gt;x2.ub() || y.lb()&gt;x2.ub()) {
428 		if ((x1 &amp;= y).is_empty()) { x2.set_empty(); return false;}
429 		else return true;
430 	}
431 	if (y.ub()&lt;x1.lb() || y.ub()&lt;x2.lb()) {
432 		x1.set_empty();
433 		x2.set_empty();
434 		return false; 	}
435 	if (x1.ub()&gt;y.ub())
436 		x1=Interval(x1.lb(),y.ub());
437 	if (x2.ub()&gt;y.ub())
438 		x2=Interval(x2.lb(),y.ub());
439 	return true;
440 }
441 inline bool bwd_min(const Interval&amp; y, Interval&amp; x1, Interval&amp; x2) {
442 	Interval mx1=-x1;
443 	Interval mx2=-x2;
444 	if (!bwd_max(-y,mx1,mx2)) {
445 		x1.set_empty();
446 		x2.set_empty();
447 		return false;
448 	}
449 	x1=-mx1;
450 	x2=-mx2;
451 	return true;
452 }
453 inline bool bwd_sign(const Interval&amp; y,  Interval&amp; x) {
454 	if (y.is_empty()) {
455 		x.set_empty();
456 		return false;
457 	}
458 	if(y.lb()&gt;0)
459 		x &amp;= Interval::pos_reals();
460 	else if(y.ub()&lt;0)
461 		x &amp;= Interval::neg_reals();
462 	return !x.is_empty();
463 }
464 inline bool bwd_atan2(const Interval&amp; theta, Interval&amp; y, Interval&amp; x) {
465 	Interval theta_xpos = theta  &amp; Interval(-1,1)*Interval::half_pi();
466 	Interval theta_xneg_ypos = theta  &amp; (Interval::half_pi() | Interval::pi());
467 	Interval theta_xneg_yneg = theta  &amp; -(Interval::half_pi() | Interval::pi());
468 	Interval xres= Interval::empty_set();
469 	Interval yres= Interval::empty_set();
470 	if (!theta_xpos.is_empty()) {
471 		Interval xpos=x &amp; Interval::pos_reals();
472 		Interval yall=y;
473 		if (theta_xneg_ypos.is_empty() || theta_xneg_yneg.is_empty()) { 			Interval z=yall/xpos;
474 			bwd_atan(theta_xpos,z);
475 			bwd_div(z,yall,xpos);
476 		}
477 		xres |= xpos;
478 		yres |= yall;
479 		if (theta_xpos.lb()&gt;=Interval::half_pi().lb()) {
480 			xres |= (x &amp; Interval::zero());
481 			yres |= (y &amp; Interval::pos_reals());
482 		} else if (theta_xpos.ub()&lt;=-Interval::half_pi().lb()) {
483 			xres |= (x &amp; Interval::zero());
484 			yres |= (y &amp; Interval::neg_reals());
485 		}
486 	}
487 	if (!theta_xneg_ypos.is_empty()) {
488 		Interval xneg=x &amp; Interval::neg_reals();
489 		Interval ypos=y &amp; Interval::pos_reals();
490 		Interval z=ypos/xneg;
491 		bwd_atan(theta_xneg_ypos - Interval::pi(),z);
492 		bwd_div(z,ypos,xneg);
493 		xres |= xneg;
494 		yres |= ypos;	}
495 	if (!theta_xneg_yneg.is_empty()) {
496 		Interval xneg=x &amp; Interval::neg_reals();
497 		Interval yneg=y &amp; Interval::neg_reals();
498 		Interval z=yneg/xneg;
499 		bwd_atan(theta_xneg_yneg + Interval::pi(),z);
500 		bwd_div(z,yneg,xneg);
501 		xres |= xneg;
502 		yres |= yneg;
503 	}
504 	x=xres;
505 	y=yres;
506 	return !x.is_empty();
507 }
508 inline bool bwd_chi(const Interval&amp; f, Interval&amp; a, Interval&amp; b, Interval&amp; c){
509 	if      (a.ub()&lt;=0) {if ((b &amp;= f).is_empty()) { a.set_empty(); c.set_empty(); return false; } }
510 	else if (a.lb()&gt;0)  {if ((c &amp;= f).is_empty()) { a.set_empty(); b.set_empty(); return false; } }
511 	if (f.is_disjoint(b)) {
512 		if ((a &amp;= Interval::pos_reals()).is_empty()) { b.set_empty(); c.set_empty(); return false; }
513 		if ((c &amp;= f).is_empty()) { a.set_empty(); b.set_empty(); return false; }
514 	}
515 	if (f.is_disjoint(c)) {
516 		if ((a &amp;= Interval::neg_reals()).is_empty()) { b.set_empty(); c.set_empty(); return false; }
517 		if ((b &amp;= f).is_empty()) { a.set_empty(); c.set_empty(); return false; }
518 	}
519 	return true;
520 }
521 inline bool bwd_floor(const Interval&amp; y, Interval&amp; x) {
522 	if (y.is_empty()) {
523 		x.set_empty();
524 		return false;
525 	} else {
526 		double r=std::floor(y.ub());
527 		double l=std::ceil(y.lb());
528 		if (r&lt;l) {
529 			x.set_empty();
530 			return false;
531 		}
532 		else {
533 			x &amp;= Interval(l,r) + Interval(0,1);
534 			return !x.is_empty();
535 		}
536 	}
537 }
538 inline bool bwd_ceil(const Interval&amp; y, Interval&amp; x) {
539 	if (y.is_empty()) {
540 		x.set_empty();
541 		return false;
542 	} else {
543 		double r=std::floor(y.ub());
544 		double l=std::ceil(y.lb());
545 		if (r&lt;l) {
546 			x.set_empty();
547 			return false;
548 		}
549 		else {
550 			x &amp;= Interval(l,r) + Interval(-1,0);
551 			return !x.is_empty();
552 		}
553 	}
554 }
555 inline bool bwd_imod(Interval&amp; x, Interval&amp; y, const double&amp; p) {
556     if (p &lt;= 0.)
557     {
558         ibex_error("Modulo needs a strictly positive period p.");
559         return false;
560     }
561     if (y.diam()&gt;p || x.diam()&gt;p)
562         return false;
563     Interval r = (x-y)/p;
564     Interval ir = integer(r);
565     if (ir.is_empty())     {
566         x.set_empty(); y.set_empty();
567         return false;
568     }
569     if (ir.is_degenerated())
570         bwd_sub(ir*p,x,y);
571     else if (ir.diam()==1.)
572     {
573         double ir1 = ir.lb();
574         double ir2 = ir.ub();
575         Interval x1 = x; Interval x2 = x;
576         Interval y1 = y; Interval y2 = y;
577         bwd_sub(Interval(ir1*p),x1,y1);
578         bwd_sub(Interval(ir2*p),x2,y2);
579         x = x1 | x2;
580         y = y1 | y2;
581     }
582     else
583     {
584         ibex_error("Modulo diameter error.");
585         return false;
586     }
587     return true;
588 }
589 } 
#endif </pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>vibes.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "vibes.h"
2 #include &lt;sstream&gt;
3 #include &lt;cstdlib&gt;
4 #include &lt;cstdio&gt;
5 #include &lt;cassert&gt;
6 namespace vibes {
7     std::string Value::toJSONString() const {
8         std::ostringstream ss;
9         switch (_type) {
10         case vt_integer:
11             ss&lt;&lt;_integer; break;
12         case vt_decimal:
13             ss&lt;&lt;_decimal; break;
14         case vt_string:
15             ss&lt;&lt;'"'&lt;&lt;_string&lt;&lt;'"'; break;
16         case vt_array:
17             ss &lt;&lt; '[';
18             for (std::vector&lt;Value&gt;::const_iterator it = _array.begin(); it != _array.end(); ++it) {
19                 if (it != _array.begin()) ss &lt;&lt; ',';
20                 ss &lt;&lt; it-&gt;toJSONString();
21             }
22             ss &lt;&lt; ']';
23             break;
24         case vt_object:
25             ss &lt;&lt; '{' &lt;&lt; _object-&gt;toJSON() &lt;&lt; '}';
26             break;
27         case vt_none:
28         default:
29             break;
30         }
31         return ss.str();
32     }
33     std::string Params::toJSON() const {
34         std::ostringstream ss;
35         for(std::map&lt;std::string, Value&gt;::const_iterator it = _values.begin(); it != _values.end(); ++it)
36             ss &lt;&lt; (it==_values.begin()?"":", ") &lt;&lt; "\"" &lt;&lt; it-&gt;first &lt;&lt; "\":" &lt;&lt; it-&gt;second.toJSONString();
37         return ss.str();
38     }
39     Value Params::pop(const std::string &amp;key, const Value &amp;value_not_found) {
40         KeyValueMap::iterator it = _values.find(key);
41         if (it == _values.end())
42             return value_not_found;
43         Value val = it-&gt;second;
44         _values.erase(it);
45         return val;
46     }
47 }
48 using namespace std;
49 namespace vibes
50 {
51   FILE *channel=0;
52   string current_fig="default";
53   void beginDrawing()
54   {
55       char * user_dir = getenv("USERPROFILE");       if (!user_dir)
56           user_dir = getenv("HOME");       if (user_dir)
57       {           std::string file_name(user_dir);
58           file_name.append("/.vibes.json");
59           beginDrawing(file_name);
60       }
61       else
62       {           beginDrawing("vibes.json");
63       }
64   }
65   void beginDrawing(const std::string &amp;fileName)
66   {
67     channel=fopen(fileName.c_str(),"a");
68   }
69   void endDrawing()
70   {
71     fclose(channel);
72   }
73   void newFigure(const std::string &amp;figureName)
74   {
75     std::string msg;
76     if (!figureName.empty()) current_fig = figureName;
77     msg ="{\"action\":\"new\","
78           "\"figure\":\""+(figureName.empty()?current_fig:figureName)+"\"}\n\n";
79     fputs(msg.c_str(),channel);
80     fflush(channel);
81   }
82   void clearFigure(const std::string &amp;figureName)
83   {
84     std::string msg;
85     msg="{\"action\":\"clear\","
86          "\"figure\":\""+(figureName.empty()?current_fig:figureName)+"\"}\n\n";
87     fputs(msg.c_str(),channel);
88     fflush(channel);
89   }
90   void closeFigure(const std::string &amp;figureName)
91   {
92     std::string msg;
93     msg="{\"action\":\"close\","
94          "\"figure\":\""+(figureName.empty()?current_fig:figureName)+"\"}\n\n";
95     fputs(msg.c_str(),channel);
96     fflush(channel);
97   }
98   void saveImage(const std::string &amp;fileName, const std::string &amp;figureName)
99   {
100       std::string msg;
101       msg="{\"action\":\"export\","
102            "\"figure\":\""+(figureName.empty()?current_fig:figureName)+"\","
103            "\"file\":\""+fileName+"\"}\n\n";
104       fputs(msg.c_str(),channel);
105       fflush(channel);
106   }
107   void selectFigure(const std::string &amp;figureName)
108   {
109      current_fig = figureName;
110   }
111   void axisAuto(const std::string &amp;figureName)
112   {
113     setFigureProperty(figureName.empty()?current_fig:figureName, "viewbox", "auto");
114   }
115   void axisLimits(const double &amp;x_lb, const double &amp;x_ub, const double &amp;y_lb, const double &amp;y_ub, const std::string &amp;figureName)
116   {
117     setFigureProperty(figureName.empty()?current_fig:figureName, "viewbox", (Vec4d){x_lb,x_ub,y_lb,y_ub});
118   }
119   void axisLabels(const std::string &amp;x_label, const std::string &amp;y_label, const std::string &amp;figureName)
120   {
121     vector&lt;string&gt; labels;
122     labels.push_back(x_label);
123     labels.push_back(y_label);
124     axisLabels(labels, figureName);
125   }
126   void axisLabels(const std::vector&lt;std::string&gt; &amp;labels, const std::string &amp;figureName)
127   {
128     setFigureProperty( figureName.empty()?current_fig:figureName, "axislabels", labels);
129   }
130   void drawBox(const double &amp;x_lb, const double &amp;x_ub, const double &amp;y_lb, const double &amp;y_ub, Params params)
131   {
132     Params msg;
133     msg["action"] = "draw";
134     msg["figure"] = params.pop("figure",current_fig);
135     msg["shape"] = (params, "type", "box", "bounds", (Vec4d){x_lb,x_ub,y_lb,y_ub});
136     fputs(Value(msg).toJSONString().append("\n\n").c_str(), channel);
137     fflush(channel);
138   }
139   void drawBox(const vector&lt;double&gt; &amp;bounds, Params params)
140   {
141     assert(!bounds.empty());
142     assert(bounds.size()%2 == 0);
143     Params msg;
144     msg["action"] = "draw";
145     msg["figure"] = params.pop("figure",current_fig);
146     msg["shape"] = (params, "type", "box", "bounds", vector&lt;Value&gt;(bounds.begin(),bounds.end()));
147     fputs(Value(msg).toJSONString().append("\n\n").c_str(), channel);
148     fflush(channel);
149   }
150   void drawEllipse(const double &amp;cx, const double &amp;cy, const double &amp;a, const double &amp;b, const double &amp;rot, Params params)
151   {
152       Params msg;
153       msg["action"] = "draw";
154       msg["figure"] = params.pop("figure",current_fig);
155       msg["shape"] = (params, "type", "ellipse",
156                               "center", (Vec2d){cx,cy},
157                               "axis", (Vec2d){a,b},
158                               "orientation", rot);
159       fputs(Value(msg).toJSONString().append("\n\n").c_str(), channel);
160 <a name="0"></a>      fflush(channel);
161   }
162 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  void drawConfidenceEllipse(const double &amp;cx, const double &amp;cy,
163                              const double &amp;sxx, const double &amp;sxy, const double &amp;syy,
164                              const double &amp;K, Params params)</b></font>
165   {
166       Params msg;
167       msg["action"] = "draw";
168       msg["figure"] = params.pop("figure",current_fig);
169       msg["shape"] = (params, "type", "ellipse",
170                               "center", (Vec2d){cx,cy},
171                               "covariance", (Vec4d){sxx,sxy,sxy,syy},
172                               "sigma", K);
173       fputs(Value(msg).toJSONString().append("\n\n").c_str(), channel);
174       fflush(channel);
175   }
176   void drawConfidenceEllipse(const vector&lt;double&gt; &amp;center, const vector&lt;double&gt; &amp;cov,
177                              const double &amp;K, Params params)
178   {
179       Params msg;
180       msg["action"] = "draw";
181       msg["figure"] = params.pop("figure",current_fig);
182       msg["shape"] = (params, "type", "ellipse",
183                               "center", vector&lt;Value&gt;(center.begin(),center.end()),
184                               "covariance", vector&lt;Value&gt;(cov.begin(),cov.end()),
185                               "sigma", K);
186       fputs(Value(msg).toJSONString().append("\n\n").c_str(), channel);
187       fflush(channel);
188   }
189   void drawBoxes(const std::vector&lt;std::vector&lt;double&gt; &gt; &amp;bounds, Params params)
190   {
191      Params msg;
192      msg["action"] = "draw";
193      msg["figure"] = params.pop("figure",current_fig);
194      msg["shape"] = (params, "type", "boxes",
195                              "bounds", bounds);
196      fputs(Value(msg).toJSONString().append("\n\n").c_str(), channel);
197      fflush(channel);
198   }
199   void drawBoxesUnion(const std::vector&lt;std::vector&lt;double&gt; &gt; &amp;bounds, Params params)
200   {
201      Params msg;
202      msg["action"] = "draw";
203      msg["figure"] = params.pop("figure",current_fig);
204      msg["shape"] = (params, "type", "boxes union",
205                              "bounds", bounds);
206      fputs(Value(msg).toJSONString().append("\n\n").c_str(), channel);
207      fflush(channel);
208   }
209   void drawLine(const std::vector&lt;std::vector&lt;double&gt; &gt; &amp;points, Params params)
210   {
211      Params msg;
212      msg["action"] = "draw";
213      msg["figure"] = params.pop("figure",current_fig);
214      msg["shape"] = (params, "type", "line",
215                              "points", points);
216      fputs(Value(msg).toJSONString().append("\n\n").c_str(), channel);
217      fflush(channel);
218   }
219   void drawLine(const std::vector&lt;double&gt; &amp;x, const std::vector&lt;double&gt; &amp;y, Params params)
220   {
221      std::vector&lt;Value&gt; points;
222      std::vector&lt;double&gt;::const_iterator itx = x.begin();
223      std::vector&lt;double&gt;::const_iterator ity = y.begin();
224      while (itx != x.end() &amp;&amp; ity != y.end()) {
225         points.push_back( (Vec2d){*itx++,*ity++} );
226      }
227      Params msg;
228      msg["action"] = "draw";
229      msg["figure"] = params.pop("figure",current_fig);
230      msg["shape"] = (params, "type", "line",
231                              "points", points);
232      fputs(Value(msg).toJSONString().append("\n\n").c_str(), channel);
233      fflush(channel);
234   }
235   void newGroup(const std::string &amp;name, Params params)
236   {
237      Params msg;
238      msg["action"] = "draw";
239      msg["figure"] = params.pop("figure",current_fig);
240      msg["shape"] = (params, "type", "group",
241                              "name", name);
242      fputs(Value(msg).toJSONString().append("\n\n").c_str(), channel);
243      fflush(channel);
244   }
245   void clearGroup(const std::string &amp;figureName, const std::string &amp;groupName)
246   {
247      Params msg;
248      msg["action"] = "clear";
249      msg["figure"] = figureName;
250      msg["group"] = groupName;
251      fputs(Value(msg).toJSONString().append("\n\n").c_str(), channel);
252      fflush(channel);
253   }
254   void clearGroup(const std::string &amp;groupName)
255   {
256      clearGroup(current_fig, groupName);
257   }
258   void removeObject(const std::string &amp;figureName, const std::string &amp;objectName)
259   {
260      Params msg;
261      msg["action"] = "delete";
262      msg["figure"] = figureName;
263      msg["object"] = objectName;
264      fputs(Value(msg).toJSONString().append("\n\n").c_str(), channel);
265      fflush(channel);
266   }
267   void removeObject(const std::string &amp;objectName)
268   {
269      removeObject(current_fig, objectName);
270   }
271   void setFigureProperties(const std::string &amp;figureName, const Params &amp;properties)
272   {
273      Params msg;
274      msg["action"] = "set";
275      msg["figure"] = figureName;
276      msg["properties"] = properties;
277      fputs(Value(msg).toJSONString().append("\n\n").c_str(), channel);
278      fflush(channel);
279   }
280   void setFigureProperties(const Params &amp;properties)
281   {
282      setFigureProperties(current_fig, properties);
283   }
284   void setObjectProperties(const std::string &amp;figureName, const std::string &amp;objectName, const Params &amp;properties)
285   {
286      Params msg;
287      msg["action"] = "set";
288      msg["figure"] = figureName;
289      msg["object"] = objectName;
290      msg["properties"] = properties;
291      fputs(Value(msg).toJSONString().append("\n\n").c_str(), channel);
292      fflush(channel);
293   }
294   void setObjectProperties(const std::string &amp;objectName, const Params &amp;properties)
295   {
296      setObjectProperties(current_fig, objectName, properties);
297   }
298 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
