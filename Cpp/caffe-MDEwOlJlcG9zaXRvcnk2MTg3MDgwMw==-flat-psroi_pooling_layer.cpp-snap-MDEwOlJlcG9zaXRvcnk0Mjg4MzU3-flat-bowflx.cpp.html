
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 8.285004142502071%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-psroi_pooling_layer.cpp</h3>
            <pre><code>1  #include <cfloat>
2  #include <algorithm>
3  #include <string>
4  #include <utility>
5  #include <vector>
6  #include "caffe/layers/psroi_pooling_layer.hpp"
7  #include "caffe/util/math_functions.hpp"
8  #ifdef _OPENMP
9  #include <omp.h>
10  #endif
11  using std::max;
12  using std::min;
13  using std::floor;
14  using std::ceil;
15  namespace caffe {
16    template <typename Dtype>
17    void PSROIPoolingLayer<Dtype>::LayerSetUp(const vector<Blob<Dtype>*>& bottom,
18      const vector<Blob<Dtype>*>& top) {
19      PSROIPoolingParameter psroi_pooling_param =
20        this->layer_param_.psroi_pooling_param();
21      spatial_scale_ = psroi_pooling_param.spatial_scale();
22      LOG(ERROR) << "Spatial scale: " << spatial_scale_;
23      CHECK_GT(psroi_pooling_param.output_dim(), 0)
24        << "output_dim must be > 0";
25      CHECK_GT(psroi_pooling_param.group_size(), 0)
26        << "group_size must be > 0";
27      output_dim_ = psroi_pooling_param.output_dim();
28      group_size_ = psroi_pooling_param.group_size();
29      pooled_height_ = group_size_;
30      pooled_width_ = group_size_;
31    }
32    template <typename Dtype>
33    void PSROIPoolingLayer<Dtype>::Reshape(const vector<Blob<Dtype>*>& bottom,
34      const vector<Blob<Dtype>*>& top) {
35      channels_ = bottom[0]->channels();
36      CHECK_EQ(channels_, output_dim_ * group_size_ * group_size_)
37        << "input channel number does not match layer parameters";
38      height_ = bottom[0]->height();
39      width_ = bottom[0]->width();
40      top[0]->Reshape(
41        bottom[1]->num(), output_dim_, pooled_height_, pooled_width_);
42      mapping_channel_.Reshape(
43        bottom[1]->num(), output_dim_, pooled_height_, pooled_width_);
44    }
45    template <typename Dtype>
46    static void PSROIPoolingForward(
47      const int num,
48      const Dtype* bottom_data,
49      const Dtype spatial_scale,
50      const int channels,
51      const int height, const int width,
52      const int pooled_height, const int pooled_width,
53      const Dtype* bottom_rois,
54      const int output_dim,
55      const int group_size,
56      Dtype* top_data,
57      int* mapping_channel) {
58        int pixels = width * height;
59  #ifdef _OPENMP
60  	#pragma omp parallel for
61  #endif
62       for (int n = 0; n < num; ++n) {
63          int roi_add = n * 5;
64          int roi_batch_ind = bottom_rois[roi_add];
65          Dtype roi_start_w =
66            static_cast<Dtype>(round(bottom_rois[roi_add + 1])) * spatial_scale;
67          Dtype roi_start_h =
68            static_cast<Dtype>(round(bottom_rois[roi_add + 2])) * spatial_scale;
69          Dtype roi_end_w =
70            static_cast<Dtype>(round(bottom_rois[roi_add + 3]) + 1.) * spatial_scale;
71          Dtype roi_end_h =
72            static_cast<Dtype>(round(bottom_rois[roi_add + 4]) + 1.) * spatial_scale;
73          Dtype roi_width = max<Dtype>(roi_end_w - roi_start_w, 0.1);  
74          Dtype roi_height = max<Dtype>(roi_end_h - roi_start_h, 0.1);
75          Dtype bin_size_h = roi_height / static_cast<Dtype>(pooled_height);
76          Dtype bin_size_w = roi_width / static_cast<Dtype>(pooled_width);
77          int top_roi_offset = n * output_dim * pooled_height * pooled_width;
78          for (int ctop = 0; ctop < output_dim; ++ctop) {
79            int top_plane_offset = top_roi_offset + ctop * pooled_height * pooled_width;
80            for (int ph = 0; ph < pooled_height; ++ph) {
81              int top_row_offset = top_plane_offset + ph * pooled_width;
82              for (int pw = 0; pw < pooled_width; ++pw) {
83                int index = top_row_offset + pw;
84                int hstart = floor(static_cast<Dtype>(ph) * bin_size_h + roi_start_h);
85                int wstart = floor(static_cast<Dtype>(pw) * bin_size_w + roi_start_w);
86                int hend = ceil(static_cast<Dtype>(ph + 1) * bin_size_h + roi_start_h);
87                int wend = ceil(static_cast<Dtype>(pw + 1) * bin_size_w + roi_start_w);
88                hstart = min(max(hstart, 0), height);
89                hend = min(max(hend, 0), height);
90                wstart = min(max(wstart, 0), width);
91                wend = min(max(wend, 0), width);
92                bool is_empty = (hend <= hstart) || (wend <= wstart);
93                int gw = pw;
94                int gh = ph;
95                int c = (ctop * group_size + gh) * group_size + gw;
96                Dtype out_sum = 0;
97                int bottom_base_offset = (roi_batch_ind * channels + c) * pixels;
98                const Dtype *current_bottom = bottom_data + bottom_base_offset;
99                for (int h = hstart; h < hend; ++h) {
<span onclick='openModal()' class='match'>100                  int roi_row_offset = h * width;
101                  for (int w = wstart; w < wend; ++w) {
102                    int bottom_index = roi_row_offset + w;
103                    out_sum += current_bottom[bottom_index];
104                  }
</span>105                }
106                Dtype bin_area = (hend - hstart) * (wend - wstart);
107                top_data[index] = is_empty ? 0. : out_sum / bin_area;
108                mapping_channel[index] = c;
109              }
110            }
111          }
112      }
113    }
114    template <typename Dtype>
115    void PSROIPoolingLayer<Dtype>::Forward_cpu(const vector<Blob<Dtype>*>& bottom,
116      const vector<Blob<Dtype>*>& top) {
117      const Dtype* bottom_data = bottom[0]->cpu_data();
118      const Dtype* bottom_rois = bottom[1]->cpu_data();
119      Dtype* top_data = top[0]->mutable_cpu_data();
120      int* mapping_channel_ptr = mapping_channel_.mutable_cpu_data();
121      int count = top[0]->count();
122      caffe_set(count, Dtype(0), top_data);
123      caffe_set(count, -1, mapping_channel_ptr);
124      PSROIPoolingForward(bottom[1]->num(), bottom_data, spatial_scale_,
125        channels_, height_, width_, pooled_height_,
126        pooled_width_, bottom_rois, output_dim_, group_size_,
127        top_data, mapping_channel_ptr);
128    }
129    template <typename Dtype>
130      static void PSROIPoolingBackward(
131      const int num,
132      const Dtype* top_diff,
133      const int* mapping_channel,
134      const int num_rois,
135      const Dtype spatial_scale,
136      const int channels,
137      const int height, const int width,
138      const int pooled_height, const int pooled_width,
139      const int output_dim,
140      Dtype* bottom_diff,
141      const Dtype* bottom_rois) {
142      int pixels = height * width;
143  #ifdef _OPENMP
144   	#pragma omp parallel for
145  #endif
146      for (int i = 0; i < num; ++i) {
147        int pw = i % pooled_width;
148        int ph = (i / pooled_width) % pooled_height;
149        int n = i / pooled_width / pooled_height / output_dim;
150        int roi_add = n * 5;
151        int roi_batch_ind = bottom_rois[roi_add];
152        Dtype roi_start_w =
153          static_cast<Dtype>(round(bottom_rois[roi_add + 1])) * spatial_scale;
154        Dtype roi_start_h =
155          static_cast<Dtype>(round(bottom_rois[roi_add + 2])) * spatial_scale;
156        Dtype roi_end_w =
157          static_cast<Dtype>(round(bottom_rois[roi_add + 3]) + 1.) * spatial_scale;
158        Dtype roi_end_h =
159          static_cast<Dtype>(round(bottom_rois[roi_add + 4]) + 1.) * spatial_scale;
160        Dtype roi_width = max(roi_end_w - roi_start_w, (Dtype)0.1);  
161        Dtype roi_height = max(roi_end_h - roi_start_h, (Dtype)0.1);
162        Dtype bin_size_h = roi_height / static_cast<Dtype>(pooled_height);
163        Dtype bin_size_w = roi_width / static_cast<Dtype>(pooled_width);
164        int hstart = floor(static_cast<Dtype>(ph)* bin_size_h + roi_start_h);
165        int wstart = floor(static_cast<Dtype>(pw)* bin_size_w + roi_start_w);
166        int hend = ceil(static_cast<Dtype>(ph + 1) * bin_size_h + roi_start_h);
167        int wend = ceil(static_cast<Dtype>(pw + 1) * bin_size_w + roi_start_w);
168        hstart = min(max(hstart, 0), height);
169        hend = min(max(hend, 0), height);
170        wstart = min(max(wstart, 0), width);
171        wend = min(max(wend, 0), width);
172        bool is_empty = (hend <= hstart) || (wend <= wstart);
173        int c = mapping_channel[i];
174        Dtype* offset_bottom_diff = bottom_diff + (roi_batch_ind * channels + c) * pixels;
175        Dtype bin_area = (hend - hstart) * (wend - wstart);
176        Dtype diff_val = is_empty ? 0. : top_diff[i] / bin_area;
177        for (int h = hstart; h < hend; ++h) {
178          for (int w = wstart; w < wend; ++w) {
179            offset_bottom_diff[h * width + w] += diff_val;
180          }
181        }
182      }
183    }
184    template <typename Dtype>
185    void PSROIPoolingLayer<Dtype>::Backward_cpu(const vector<Blob<Dtype>*>& top,
186      const vector<bool>& propagate_down, const vector<Blob<Dtype>*>& bottom) {
187      if (!propagate_down[0]) {
188        return;
189      }
190      const Dtype* bottom_rois = bottom[1]->cpu_data();
191      const Dtype* top_diff = top[0]->cpu_diff();
192      Dtype* bottom_diff = bottom[0]->mutable_cpu_diff();
193      const int bottom_count = bottom[0]->count();
194      const int* mapping_channel_ptr = mapping_channel_.cpu_data();
195      caffe_set(bottom[1]->count(), Dtype(0), bottom[1]->mutable_cpu_diff());
196      caffe_set(bottom_count, Dtype(0), bottom_diff);
197      const int count = top[0]->count();
198      PSROIPoolingBackward(count, top_diff, mapping_channel_ptr,
199        top[0]->num(), spatial_scale_, channels_, height_, width_,
200        pooled_height_, pooled_width_, output_dim_, bottom_diff,
201        bottom_rois);
202    }
203  #ifdef CPU_ONLY
204    STUB_GPU(PSROIPoolingLayer);
205  #endif
206    INSTANTIATE_CLASS(PSROIPoolingLayer);
207    REGISTER_LAYER_CLASS(PSROIPooling);
208  }  
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-bowflx.cpp</h3>
            <pre><code>1  void TBowFl::LoadHtmlTxt(
2   PBowDocBs BowDocBs, const TStr& FPath, TIntV& NewDIdV,
3   const bool& RecurseDirP, const int& MxDocs,
4   const bool& SaveDocP, const PNotify& Notify) {
5    TStr LcNrFPath=TStr::GetNrFPath(FPath).GetLc();
6    Notify->OnStatus("Creating Bow from file-path " + FPath + " ...");
7    TFFile FFile(FPath, "", RecurseDirP);
8    TStr FNm; int Docs=0; NewDIdV.Clr();
9    while (FFile.Next(FNm)){
10      Docs++; if ((MxDocs!=-1)&&(Docs>MxDocs)){break;}
11      Notify->OnStatus(TStr::Fmt("%d\r", Docs));
12      if (TFile::Exists(FNm)) { 
13          TStr DocNm=FNm.GetLc();
14          if (DocNm.IsPrefix(LcNrFPath)){
15            DocNm=DocNm.GetSubStr(LcNrFPath.Len(), DocNm.Len()-1);}
16          TStrV CatNmV; TStr CatNm;
17          if (DocNm.IsChIn('/')){
18            TStr Str; DocNm.SplitOnCh(CatNm, '/', Str);
19          } else if (DocNm.IsChIn('\\')){
20            TStr Str; DocNm.SplitOnCh(CatNm, '\\', Str);
21          }
22          if (!CatNm.Empty()){
23            CatNmV.Add(CatNm);}
24          TStr DocStr=TStr::LoadTxt(FNm);
25          NewDIdV.Add(BowDocBs->AddHtmlDoc(DocNm, CatNmV, DocStr, SaveDocP));
26      }
27    }
28    Notify->OnStatus(TStr::Fmt("%d", Docs));
29    Notify->OnStatus("Done.");
30    BowDocBs->AssertOk();
31  }
32  PBowDocBs TBowFl::LoadHtmlTxt(
33   const TStr& FPath, const bool& RecurseDirP, const int& MxDocs,
34   const TStr& SwSetTypeNm, const TStr& StemmerTypeNm,
35   const int& MxNGramLen, const int& MnNGramFq,
36   const bool& SaveDocP, const PNotify& Notify){
37    PSwSet SwSet=TSwSet::GetSwSet(SwSetTypeNm);
38    PStemmer Stemmer=TStemmer::GetStemmer(StemmerTypeNm);
39    PNGramBs NGramBs;
40    if (!((MxNGramLen==1)&&(MnNGramFq==1))){
41      NGramBs=TNGramBs::GetNGramBsFromHtmlFPathV(
42       FPath, RecurseDirP, MxDocs,
43       MxNGramLen, MnNGramFq, SwSet, Stemmer, Notify);
44    }
45    PBowDocBs BowDocBs=TBowDocBs::New(SwSet, Stemmer, NGramBs);
46    TIntV NewDIdV; LoadHtmlTxt(BowDocBs, FPath, NewDIdV,
47        RecurseDirP, MxDocs, SaveDocP, Notify);
48    return BowDocBs;
49  }
50  PBowDocBs TBowFl::LoadFromSimMtx(const PBowSimMtx& BowSimMtx){
51    PBowDocBs BowDocBs=TBowDocBs::New();
52    int Docs=BowSimMtx->GetDocs();
53    BowDocBs->DocSpVV.Gen(Docs, 0);
54    for (int MtxDIdN=0; MtxDIdN<Docs; MtxDIdN++){
55      int MtxDId=BowSimMtx->GetMtxDId(MtxDIdN);
56      int DId=BowDocBs->DocNmToDescStrH.AddKey(TInt::GetStr(MtxDId));
57      IAssert(MtxDIdN==DId);
58      BowDocBs->DocSpVV.Add(TBowSpV::New(DId));
59      IAssert(DId==BowDocBs->DocSpVV.Len()-1);
60    }
61    BowDocBs->AssertOk();
62    return BowDocBs;
63  }
64  PBowDocBs TBowFl::LoadTabTxt(const TStr& FNm, const int& &bsol;*MxDocs*/){
65    PBowDocBs BowDocBs=TBowDocBs::New();
66    PDm Dm=TDm::LoadFile(FNm);
67    for (int AttrN=0; AttrN<Dm->GetAttrs(); AttrN++){
68      PTbVar Var=Dm->GetAttr(AttrN);
69      TStr VarNm=Var->GetNm();
70      PTbVarType VarType=Var->GetVarType();
71      EAssertRA(VarType->IsFlt(), "Attribute must be continuous", VarNm);
72      BowDocBs->WordStrToDescH.AddKey(VarNm);
73    }
74    for (int ExN=0; ExN<Dm->GetExs(); ExN++){
75      TStr DocNm=TInt::GetStr(ExN);
76      int DId=BowDocBs->DocNmToDescStrH.AddKey(DocNm);
77      BowDocBs->DocSpVV.Add(TBowSpV::New(DId)); IAssert(DId==BowDocBs->DocSpVV.Len()-1);
78      BowDocBs->DocCIdVV.Add(); IAssert(DId==BowDocBs->DocCIdVV.Len()-1);
79      TIntV& DocCIdV=BowDocBs->DocCIdVV[DId];
80      DocCIdV.Gen(Dm->GetClasses(), 0);
81      for (int ClassN=0; ClassN<Dm->GetClasses(); ClassN++){
82        TStr ValStr=Dm->GetClassValStr(ExN, ClassN);
83        int CId=BowDocBs->CatNmToFqH.AddKey(ValStr);
84        BowDocBs->CatNmToFqH[CId]++; DocCIdV.Add(CId);
85      }
86      DocCIdV.Sort();
87      PBowSpV DocSpV=BowDocBs->DocSpVV[DId];
88      DocSpV->GenMx(Dm->GetAttrs());
89      for (int AttrN=0; AttrN<Dm->GetAttrs(); AttrN++){
90        TStr WordStr=Dm->GetAttr(AttrN)->GetNm();
91        int WId=BowDocBs->WordStrToDescH.GetKeyId(WordStr);
92        TTbVal Val=Dm->GetAttrVal(ExN, AttrN);
93        double Wgt=Val.GetFlt();
94        TBowWordDesc& WordDesc=BowDocBs->WordStrToDescH[WId];
95        WordDesc.MnVal=TFlt::GetMn(WordDesc.MnVal, Wgt);
96        WordDesc.MxVal=TFlt::GetMx(WordDesc.MxVal, Wgt);
97        DocSpV->AddWIdWgt(WId, Wgt);
98      }
99      DocSpV->Sort();
100    }
101    BowDocBs->AssertOk();
102    return BowDocBs;
103  }
104  PBowDocBs TBowFl::LoadTsactTxt(const TStr& FNm, const int& MxDocs){
105    PBowDocBs BowDocBs=TBowDocBs::New();
106    PSIn SIn=TFIn::New(FNm);
107    printf("Loading %s ...\n", FNm.CStr());
108    if (!SIn->Eof()){
109      int CurDId=-1;
110      TIntH CurDocWIdToFqH(100);
111      char Ch=SIn->GetCh();
112      while ((!SIn->Eof())&&(!(('0'<=Ch)&&(Ch<='9')))){
113        Ch=SIn->GetCh();}
114      while (!SIn->Eof()){
115        if (BowDocBs->DocSpVV.Len()%1000==0){
116          printf("%d transactions read\r", BowDocBs->DocSpVV.Len());}
117        IAssert(('0'<=Ch)&&(Ch<='9'));
118        int TsactN=Ch-'0'; Ch=SIn->GetCh();
119        while (('0'<=Ch)&&(Ch<='9')){
120          TsactN=TsactN*10+Ch-'0'; Ch=SIn->GetCh();}
121        while (!(('0'<=Ch)&&(Ch<='9'))){
122          IAssert((Ch==' ')||(Ch=='\t')); Ch=SIn->GetCh();}
123        IAssert(('0'<=Ch)&&(Ch<='9'));
124        int ItemN=Ch-'0'; Ch=SIn->GetCh();
125        while (('0'<=Ch)&&(Ch<='9')){
126          ItemN=ItemN*10+Ch-'0'; Ch=SIn->GetCh();}
127        while ((!SIn->Eof())&&(!(('0'<=Ch)&&(Ch<='9')))){
128          Ch=SIn->GetCh();}
129        TStr DocNm=TInt::GetStr(TsactN);
130        int DId=BowDocBs->DocNmToDescStrH.AddKey(DocNm);
131        TStr WordStr=TInt::GetStr(ItemN);
132        int WId=BowDocBs->WordStrToDescH.AddKey(WordStr);
133        BowDocBs->WordStrToDescH[WId].Fq++;
134        if (CurDId!=DId){
135          if (CurDId!=-1){
136            if ((MxDocs!=-1)&&(BowDocBs->GetDocs()>=MxDocs-1)){break;}
137            PBowSpV NewSpV=TBowSpV::New(CurDId, CurDocWIdToFqH.Len());
138            int NewDId=BowDocBs->DocSpVV.Add(NewSpV);
139            IAssert(NewDId==CurDId);
140            for (int DocWIdN=0; DocWIdN<CurDocWIdToFqH.Len(); DocWIdN++){
141              int WId=CurDocWIdToFqH.GetKey(DocWIdN);
142              int WordFq=CurDocWIdToFqH[DocWIdN];
143              NewSpV->AddWIdWgt(WId, WordFq);
144            }
145            NewSpV->Sort();
146          }
147          CurDId=DId; CurDocWIdToFqH.Clr(false);
148        }
149        CurDocWIdToFqH.AddDat(WId)++;
150      }
151      if (CurDId!=-1){
152        PBowSpV NewSpV=TBowSpV::New(CurDId, CurDocWIdToFqH.Len());
153        BowDocBs->DocSpVV.Add(NewSpV);
154        for (int DocWIdN=0; DocWIdN<CurDocWIdToFqH.Len(); DocWIdN++){
155          int WId=CurDocWIdToFqH.GetKey(DocWIdN);
156          int WordFq=CurDocWIdToFqH[DocWIdN];
157          NewSpV->AddWIdWgt(WId, WordFq);
158        }
159        NewSpV->Sort();
160      }
161      printf("%d transactions read\n", BowDocBs->DocSpVV.Len());
162    }
163    printf("... Done.\n");
164    BowDocBs->AssertOk();
165    return BowDocBs;
166  }
167  PBowDocBs TBowFl::LoadSparseTxt(
168   const TStr& DocDefFNm, const TStr& WordDefFNm,
169   const TStr& TrainDataFNm,
170   const int& MxDocs){
171    PBowDocBs BowDocBs=TBowDocBs::New();
172    if (!DocDefFNm.Empty()){
173      PSIn SIn=TFIn::New(DocDefFNm);
174      TILx Lx(SIn, TFSet()|iloRetEoln|iloSigNum|iloExcept);
175      Lx.GetSym(syInt, syEof);
176      while (Lx.Sym==syInt){
177        int DId=Lx.Int;
178        Lx.GetSym(syColon);
179        Lx.GetSym(syQStr); TStr DocNm=Lx.Str;
180        Lx.GetSym(syEoln);
181        Lx.GetSym(syInt, syEof);
182        int NewDId=BowDocBs->DocNmToDescStrH.AddKey(DocNm);
183        EAssertR(DId==NewDId, "Document-Ids don't match.");
184      }
185    }
186    if (!WordDefFNm.Empty()){
187      PSIn SIn=TFIn::New(WordDefFNm);
188      TILx Lx(SIn, TFSet()|iloRetEoln|iloSigNum|iloExcept);
189      Lx.GetSym(syInt, syEof);
190      while (Lx.Sym==syInt){
191        int WId=Lx.Int;
192        Lx.GetSym(syColon);
193        Lx.GetSym(syQStr); TStr WordStr=Lx.Str;
194        Lx.GetSym(syEoln);
195        Lx.GetSym(syInt, syEof);
196        int NewWId=BowDocBs->WordStrToDescH.AddKey(WordStr);
197        BowDocBs->WordStrToDescH[NewWId].Fq=1;
198        EAssertR(WId==NewWId, "Word-Ids don't match.");
199      }
200    }
201    if (!TrainDataFNm.Empty()){
202      PSIn SIn=TFIn::New(TrainDataFNm);
203      TILx Lx(SIn, TFSet()|iloRetEoln|iloSigNum|iloExcept);
204      Lx.GetSym(syInt, syEof);
205      while (Lx.Sym==syInt){
206        if (BowDocBs->GetDocs()>=MxDocs){break;}
207        int DId=Lx.Int;
208        PBowSpV NewSpV=TBowSpV::New(DId);
209        int NewDId=BowDocBs->DocSpVV.Add(NewSpV);
210        EAssertR(DId==NewDId, "Document-Ids don't match.");
211        Lx.GetSym(syInt, syEoln);
212        while (Lx.Sym==syInt){
213          int WId=Lx.Int;
214          Lx.GetSym(syColon, syInt, syEoln);
215          double WordFq=1;
216          if (Lx.Sym==syColon){
217            WordFq=Lx.GetFlt();
218            Lx.GetSym(syInt, syEoln);
219          }
220          NewSpV->AddWIdWgt(WId, WordFq);
221        }
222        NewSpV->Trunc();
223        Lx.GetSym(syInt, syEof);
224      }
225    }
226    BowDocBs->AssertOk();
227    return BowDocBs;
228  }
229  PBowDocBs TBowFl::LoadSvmLightTxt(
230   const TStr& DocDefFNm, const TStr& WordDefFNm,
231   const TStr& TrainDataFNm, const TStr& TestDataFNm,
232   const int& MxDocs){
233    PBowDocBs BowDocBs=TBowDocBs::New();
234    int MOneCId=BowDocBs->CatNmToFqH.AddKey("-1");
235    int POneCId=BowDocBs->CatNmToFqH.AddKey("+1");
236    bool DocDefP=false;
237    if (!DocDefFNm.Empty()&&(TFile::Exists(DocDefFNm))){
238      PSIn SIn=TFIn::New(DocDefFNm);
239      TILx Lx(SIn, TFSet()|iloRetEoln|iloSigNum|iloExcept);
240      Lx.GetSym(syInt, syEof);
241      while (Lx.Sym==syInt){
242        int DId=Lx.Int;
243        Lx.GetSym(syColon);
244        Lx.GetSym(syQStr); TStr DocNm=Lx.Str;
245        Lx.GetSym(syEoln);
246        Lx.GetSym(syInt, syEof);
247        int NewDId=BowDocBs->DocNmToDescStrH.AddKey(DocNm);
248        EAssertR(DId==NewDId, "Document-Ids don't match.");
249      }
250      DocDefP=true;
251    }
252    if (!WordDefFNm.Empty()&&(TFile::Exists(WordDefFNm))){
253      BowDocBs->WordStrToDescH.AddDat("Undef").Fq=0; 
254      PSIn SIn=TFIn::New(WordDefFNm);
255      TILx Lx(SIn, TFSet()|iloRetEoln|iloSigNum|iloExcept);
256      Lx.GetSym(syQStr, syEof);
257      while (Lx.Sym==syQStr){
258        TStr WordStr=Lx.Str;
259        Lx.GetSym(syInt); int WId=Lx.Int;
260        Lx.GetSym(syInt); int WordFq=Lx.Int;
261        Lx.GetSym(syEoln);
262        Lx.GetSym(syQStr, syEof);
263        int NewWId=BowDocBs->WordStrToDescH.AddKey(WordStr);
264        EAssertR(WId==NewWId, "Word-Ids don't match.");
265        BowDocBs->WordStrToDescH[WId].Fq=WordFq;
266      }
267    }
268    int MxWId=-1; TIntIntH WIdToFqH;
269    if (!TrainDataFNm.Empty()){
270      PSIn SIn=TFIn::New(TrainDataFNm);
271      TILx Lx(SIn, TFSet()|iloCmtAlw|iloRetEoln|iloSigNum|iloExcept);
272      while (Lx.GetSym(syInt, syEoln, syEof)==syEoln){}
273      while (Lx.Sym==syInt){
274        TStr DocNm=TInt::GetStr(BowDocBs->GetDocs());
275        int DId;
276        if (DocDefP){
277          DId=BowDocBs->DocNmToDescStrH.GetKeyId(DocNm);
278        } else {
279          DId=BowDocBs->DocNmToDescStrH.AddKey(DocNm);
280        }
281        BowDocBs->TrainDIdV.Add(DId);
282        int CId=(Lx.Int==-1) ? MOneCId : POneCId;
283        BowDocBs->DocCIdVV.Add(); IAssert(DId==BowDocBs->DocCIdVV.Len()-1);
284        BowDocBs->DocCIdVV.Last().Gen(1, 0);
285        BowDocBs->DocCIdVV.Last().Add(CId);
286        PBowSpV SpV=TBowSpV::New(DId);
287        BowDocBs->DocSpVV.Add(SpV); IAssert(DId==BowDocBs->DocSpVV.Len()-1);
288        Lx.GetSym(syInt, syEoln);
289        while (Lx.Sym==syInt){
290          int WId=Lx.Int;
291          Lx.GetSym(syColon);
292          Lx.GetSym(syFlt); double WordFq=Lx.Flt;
293          Lx.GetSym(syInt, syEoln);
294          SpV->AddWIdWgt(WId, WordFq);
295          if (MxWId==-1){MxWId=WId;} else {MxWId=TInt::GetMx(MxWId, WId);}
296          WIdToFqH.AddDat(WId)++;
297        }
298        if (!Lx.CmtStr.Empty()){
299          TStr CmtStr=Lx.CmtStr;
300          static TStr DocNmPrefixStr="docDesc=";
301          if (CmtStr.IsPrefix(DocNmPrefixStr)){
302            TStr NewDocNm=
303             TStr("D")+CmtStr.GetSubStr(DocNmPrefixStr.Len(), CmtStr.Len()-1);
304            BowDocBs->DocNmToDescStrH.DelKey(DocNm);
305            int NewDId=BowDocBs->DocNmToDescStrH.AddKey(NewDocNm);
306            IAssert(DId==NewDId);
307          }
308        }
309        SpV->Trunc();
310        while (Lx.GetSym(syInt, syEoln, syEof)==syEoln){}
311      }
312    }
313    if (!TestDataFNm.Empty()){
314      PSIn SIn=TFIn::New(TestDataFNm);
315      TILx Lx(SIn, TFSet()|iloCmtAlw|iloRetEoln|iloSigNum|iloExcept);
316      while (Lx.GetSym(syInt, syEoln, syEof)==syEoln){}
317      while (Lx.Sym==syInt){
318        TStr DocNm=TInt::GetStr(BowDocBs->GetDocs());
319        int DId;
320        if (DocDefP){
321          DId=BowDocBs->DocNmToDescStrH.GetKeyId(DocNm);
322        } else {
323          DId=BowDocBs->DocNmToDescStrH.AddKey(DocNm);
324        }
325        BowDocBs->TestDIdV.Add(DId);
326        int CId=(Lx.Int==-1) ? MOneCId : POneCId;
327        BowDocBs->DocCIdVV.Add(); IAssert(DId==BowDocBs->DocCIdVV.Len()-1);
328        BowDocBs->DocCIdVV.Last().Gen(1, 0);
329        BowDocBs->DocCIdVV.Last().Add(CId);
330        PBowSpV SpV=TBowSpV::New(DId);
331        BowDocBs->DocSpVV.Add(SpV); IAssert(DId==BowDocBs->DocSpVV.Len()-1);
332        Lx.GetSym(syInt, syEoln);
333        while (Lx.Sym==syInt){
334          int WId=Lx.Int;
335          Lx.GetSym(syColon);
336          Lx.GetSym(syFlt); double WordFq=Lx.Flt;
337          Lx.GetSym(syInt, syEoln);
338          SpV->AddWIdWgt(WId, WordFq);
339          if (MxWId==-1){MxWId=WId;} else {MxWId=TInt::GetMx(MxWId, WId);}
340          WIdToFqH.AddDat(WId)++;
341        }
342        if (!Lx.CmtStr.Empty()){
343          TStr CmtStr=Lx.CmtStr;
344          static TStr DocNmPrefixStr="docDesc=";
345          if (CmtStr.IsPrefix(DocNmPrefixStr)){
346            TStr NewDocNm=
347             TStr("D")+CmtStr.GetSubStr(DocNmPrefixStr.Len(), CmtStr.Len()-1);
348            BowDocBs->DocNmToDescStrH.DelKey(DocNm);
349            int NewDId=BowDocBs->DocNmToDescStrH.AddKey(NewDocNm);
350            IAssert(DId==NewDId);
351          }
352        }
353        SpV->Trunc();
354        while (Lx.GetSym(syInt, syEoln, syEof)==syEoln){}
355      }
356    }
357    for (int WId=0; WId<=MxWId; WId++){
358      if (!BowDocBs->IsWId(WId)){
359        TStr WordStr=TInt::GetStr(WId, "W%d");
360        int _WId=BowDocBs->AddWordStr(WordStr);
361        IAssert(WId==_WId);
362        TInt Fq;
363        if (WIdToFqH.IsKeyGetDat(WId, Fq)){
364          BowDocBs->PutWordFq(WId, Fq);
365        }
366      }
367    }
368    BowDocBs->AssertOk();
369    return BowDocBs;
370  }
371  PBowDocBs TBowFl::LoadCpdTxt(
372   const TStr& CpdFNm, const int& MxDocs,
373   const TStr& SwSetTypeNm, const TStr& StemmerTypeNm,
374   const int& MxNGramLen, const int& MnNGramFq,
375   const bool& SaveDocP, const PNotify& Notify){
376    PSwSet SwSet=TSwSet::GetSwSet(SwSetTypeNm);
377    PStemmer Stemmer=TStemmer::GetStemmer(StemmerTypeNm);
378    PNGramBs NGramBs;
379    if (!((MxNGramLen==1)&&(MnNGramFq==1))){
380      NGramBs=TNGramBs::GetNGramBsFromCpd(
381       CpdFNm, MxDocs, MxNGramLen, MnNGramFq, SwSet, Stemmer);
382    }
383    PBowDocBs BowDocBs=TBowDocBs::New(SwSet, Stemmer, NGramBs);
384    TIntH DocWIdToFqH(100);
385    PSIn CpdSIn=TCpDoc::GetFirstCpd(CpdFNm); PCpDoc CpDoc; int Docs=0;
386    while (TCpDoc::GetNextCpd(CpdSIn, CpDoc)){
387      Docs++; if (Docs%100==0){printf("%d\r", Docs);}
388      if ((MxDocs!=-1)&&(Docs>=MxDocs)){break;}
389      TStr DocNm=CpDoc->GetDocId();
390      TStrV CatNmV;
391      for (int CatN=0; CatN<CpDoc->GetCats(); CatN++){
392        CatNmV.Add(CpDoc->GetCatNm(CatN));
393      }
394      TStr DocStr=CpDoc->GetTxtStr();
395      TStr DateStr=CpDoc->GetDateStr();
396      int DId=BowDocBs->AddHtmlDoc(DocNm, CatNmV, DocStr, SaveDocP);
397      BowDocBs->PutDateStr(DId, DateStr);
398    }
399    BowDocBs->AssertOk();
400    return BowDocBs;
401  }
402  void TBowFl::SaveCpdToLnDocTxt(const TStr& InCpdFNm, const TStr& OutLnDocFNm){
403    TFOut FOut(OutLnDocFNm); FILE* fOut=FOut.GetFileId();
404    PSIn CpdSIn=TCpDoc::GetFirstCpd(InCpdFNm); PCpDoc CpDoc; int Docs=0;
405    printf("Saving '%s' to '%s' ...\n", InCpdFNm.CStr(), OutLnDocFNm.CStr());
406    while (TCpDoc::GetNextCpd(CpdSIn, CpDoc)){
407      Docs++; if (Docs%100==0){printf("%d Docs\r", Docs);}
408      TStr DocNm=CpDoc->GetDocId();
409      DocNm=TStr::GetFNmStr(DocNm);
410      DocNm.ChangeChAll(' ', '_');
411      TStrV CatNmV;
412      for (int CatN=0; CatN<CpDoc->GetCats(); CatN++){
413        CatNmV.Add(CpDoc->GetCatNm(CatN));}
414      TChA DocChA=CpDoc->GetTxtStr();
415      DocChA.ChangeCh('\r', ' ');
416      DocChA.ChangeCh('\n', ' ');
417      fprintf(fOut, "%s", DocNm.CStr());
418      for (int CatN=0; CatN<CatNmV.Len(); CatN++){
419        fprintf(fOut, " !%s", CatNmV[CatN].CStr());}
420      fprintf(fOut, " %s\n", DocChA.CStr());
421    }
422    printf("%d Docs\nDone.\n", Docs);
423  }
424  PBowDocBs TBowFl::LoadTBsTxt(
425   const TStr& TBsFNm, const int& MxDocs,
426   const TStr& SwSetTypeNm, const TStr& StemmerTypeNm,
427   const int& MxNGramLen, const int& MnNGramFq){
428    PSwSet SwSet=TSwSet::GetSwSet(SwSetTypeNm);
429    PStemmer Stemmer=TStemmer::GetStemmer(StemmerTypeNm);
430    PNGramBs NGramBs;
431    if (!((MxNGramLen==1)&&(MnNGramFq==1))){
432      NGramBs=TNGramBs::GetNGramBsFromTBs(
433       TBsFNm, MxDocs,
434       MxNGramLen, MnNGramFq, SwSet, Stemmer);
435    }
436    PBowDocBs BowDocBs=TBowDocBs::New(SwSet, Stemmer, NGramBs);
437    TStr TxtBsNm=TBsFNm.GetFBase();
438    TStr TxtBsFPath=TBsFNm.GetFPath();
439    PTxtBs TxtBs=TTxtBs::New(TxtBsNm, TxtBsFPath, faRdOnly);
440    TBlobPt TxtBsTrvBlobPt=TxtBs->FFirstDocId(); TBlobPt TxtBsDocId; int Docs=0;
441    while (TxtBs->FNextDocId(TxtBsTrvBlobPt, TxtBsDocId)){
442      Docs++; if (Docs%100==0){printf("%d\r", Docs);}
443      if ((MxDocs!=-1)&&(Docs>=MxDocs)){break;}
444      TStr DocNm; TStr DocStr;
445      TxtBs->GetDocNmStr(TxtBsDocId, DocNm, DocStr);
446      BowDocBs->AddHtmlDoc(DocNm, TStrV(), DocStr, false);
447    }
448    BowDocBs->AssertOk();
449    return BowDocBs;
450  }
451  void TBowFl::LoadLnDocTxt(PBowDocBs BowDocBs, const TStr& LnDocFNm,
452   TIntV& NewDIdV, const bool& NamedP, const int& MxDocs, const bool& SaveDocP,
453   const PNotify& Notify) {
454    NewDIdV.Clr(); TFIn FIn(LnDocFNm); char Ch=' '; int Docs=0;
455    while (!FIn.Eof()){
456      Docs++; if ((MxDocs!=-1)&&(Docs>=MxDocs)){break;}
457      printf("%d\r", Docs);
458      TChA DocNm;
459      if (NamedP){
460        Ch=FIn.GetCh();
461        while ((!FIn.Eof())&&(Ch!='\r')&&(Ch!='\n')&&(Ch!=' ')){
462          DocNm+=Ch; Ch=FIn.GetCh();}
463        DocNm.Trunc();
464        if (DocNm.Empty()){Docs--; continue;}
465      }
466      TStrV CatNmV;
467      forever {
468        while ((!FIn.Eof())&&(Ch==' ')){Ch=FIn.GetCh();}
469        if (Ch=='!'){
470          if (!FIn.Eof()){Ch=FIn.GetCh();}
471          TChA CatNm;
472          while ((!FIn.Eof())&&(Ch!='\r')&&(Ch!='\n')&&(Ch!=' ')){
473            CatNm+=Ch; Ch=FIn.GetCh();}
474          if (!CatNm.Empty()){CatNmV.Add(CatNm);}
475        } else {
476          break;
477        }
478      }
479      TChA DocChA;
480      while ((!FIn.Eof())&&(Ch!='\r')&&(Ch!='\n')){
481        DocChA+=Ch; Ch=FIn.GetCh();}
482      if (DocNm.Empty()&&DocChA.Empty()){
483        continue;}
484      NewDIdV.Add(BowDocBs->AddHtmlDoc(DocNm, CatNmV, DocChA, SaveDocP));
485    }
486    BowDocBs->AssertOk();
487    printf("\n");
488  }
489  PBowDocBs TBowFl::LoadLnDocTxt(
490   const TStr& LnDocFNm, const bool& NamedP, const int& MxDocs,
491   const PSwSet& SwSet, const PStemmer& Stemmer,
492   const int& MxNGramLen, const int& MnNGramFq, const bool& SaveDocP,
493   const PNotify& Notify){
494    PNGramBs NGramBs;
495    if (!((MxNGramLen==1)&&(MnNGramFq==1))){
496      NGramBs=TNGramBs::GetNGramBsFromLnDoc(
497       LnDocFNm, NamedP, MxDocs,
498       MxNGramLen, MnNGramFq, SwSet, Stemmer);
499    }
500    PBowDocBs BowDocBs=TBowDocBs::New(SwSet, Stemmer, NGramBs);
501    TIntV NewDIdV; LoadLnDocTxt(BowDocBs, LnDocFNm, NewDIdV, NamedP, -1, SaveDocP, Notify);
502    return BowDocBs;
503  }
504  PBowDocBs TBowFl::LoadLnDocTxt(
505   const TStr& LnDocFNm, const bool& NamedP, const int& MxDocs,
506   const TStr& SwSetTypeNm, const TStr& StemmerTypeNm,
507   const int& MxNGramLen, const int& MnNGramFq, const bool& SaveDocP,
508     const PNotify& Notify){
509    PSwSet SwSet=TSwSet::GetSwSet(SwSetTypeNm);
510    PStemmer Stemmer=TStemmer::GetStemmer(StemmerTypeNm);
511    PNGramBs NGramBs;
512    if (!((MxNGramLen==1)&&(MnNGramFq==1))){
513      NGramBs=TNGramBs::GetNGramBsFromLnDoc(
514       LnDocFNm, NamedP, MxDocs,
515       MxNGramLen, MnNGramFq, SwSet, Stemmer);
516    }
517    PBowDocBs BowDocBs=TBowDocBs::New(SwSet, Stemmer, NGramBs);
518    TIntV NewDIdV; LoadLnDocTxt(BowDocBs, LnDocFNm, NewDIdV, NamedP, -1, SaveDocP, Notify);
519    return BowDocBs;
520  }
521  void TBowFl::SaveLnDocTxt(const PBowDocBs& BowDocBs, const TStr& FNm, const bool& UseDocStrP){
522    TFOut SOut(FNm);
523    int Docs=BowDocBs->GetDocs();
524    for (int DId=0; DId<Docs; DId++){
525      printf("%d/%d\r", DId+1, Docs);
<span onclick='openModal()' class='match'>526      TStr DocNm=TStr::GetFNmStr(BowDocBs->GetDocNm(DId));
527      SOut.PutStr(DocNm);
528      for (int CIdN=0; CIdN<BowDocBs->GetDocCIds(DId); CIdN++){
529        int CId=BowDocBs->GetDocCId(DId, CIdN);
530        TStr CatNm=TStr::GetFNmStr(BowDocBs->GetCatNm(CId));
531        SOut.PutCh(' '); SOut.PutCh('!'); SOut.PutStr(CatNm);
532      }
</span>533      if (UseDocStrP){
534        TStr DocStr=BowDocBs->GetDocStr(DId);
535        DocStr.DelChAll('\n'); DocStr.DelChAll('\r');
536        SOut.PutCh(' '); SOut.PutStr(DocStr);
537      } else {
538          int DocWIds=BowDocBs->GetDocWIds(DId);
539          int WId; double WordFq;
540          for (int DocWIdN=0; DocWIdN<DocWIds; DocWIdN++){
541            BowDocBs->GetDocWIdFq(DId, DocWIdN, WId, WordFq);
542            TStr WordStr=BowDocBs->GetWordStr(WId);
543            for (int WordFqN=0; WordFqN<WordFq; WordFqN++){
544              SOut.PutCh(' '); SOut.PutStr(WordStr);
545            }
546          }
547      }
548      SOut.PutLn();
549    }
550    printf("\n");
551  }
552  PBowDocBs TBowFl::LoadReuters21578Txt(
553   const TStr& FPath, const int& MxDocs,
554   const TStr& SwSetTypeNm, const TStr& StemmerTypeNm,
555   const int& MxNGramLen, const int& MnNGramFq, const bool& SaveDocP,
556   const PNotify& Notify){
557    PSwSet SwSet=TSwSet::GetSwSet(SwSetTypeNm);
558    PStemmer Stemmer=TStemmer::GetStemmer(StemmerTypeNm);
559    PNGramBs NGramBs;
560    if (!((MxNGramLen==1)&&(MnNGramFq==1))){
561      NGramBs=TNGramBs::GetNGramBsFromReuters21578(
562       FPath, MxDocs,
563       MxNGramLen, MnNGramFq, SwSet, Stemmer);
564    }
565    PBowDocBs BowDocBs=TBowDocBs::New(SwSet, Stemmer, NGramBs);
566    TFFile FFile(FPath, ".SGM", false); TStr FNm; int Docs=0;
567    while (FFile.Next(FNm)){
568      printf("Processing file '%s'\n", FNm.CStr());
569      TIntH DocWIdToFqH(100);
570      TXmlDocV LDocV; TXmlDoc::LoadTxt(FNm, LDocV);
571      for (int LDocN=0; LDocN<LDocV.Len(); LDocN++){
572        Docs++; if (Docs%100==0){printf("%d\r", Docs);}
573        if ((MxDocs!=-1)&&(Docs>=MxDocs)){break;}
574        PXmlDoc Doc=LDocV[LDocN];
575        PXmlTok DocTok=Doc->GetTok();
576        TStr DocNm=DocTok->GetArgVal("NEWID");
577        TStrV CatNmV;
578        TXmlTokV TopicsTokV; Doc->GetTagTokV("REUTERS|TOPICS|D", TopicsTokV);
579        for (int TopicsTokN=0; TopicsTokN<TopicsTokV.Len(); TopicsTokN++){
580          TStr CatNm=TopicsTokV[TopicsTokN]->GetTokStr(false);
581          CatNmV.Add(CatNm);
582        }
583        PXmlTok DocStrTok=Doc->GetTagTok("REUTERS|TEXT");
584        TStr DocStr=DocStrTok->GetTokStr(false);
585        int DId=BowDocBs->AddHtmlDoc(DocNm, CatNmV, DocStr, SaveDocP);
586        if ((DocTok->GetArgVal("LEWISSPLIT")=="TRAIN")&&(DocTok->GetArgVal("TOPICS")=="YES")){
587          BowDocBs->AddTrainDId(DId);}
588        if ((DocTok->GetArgVal("LEWISSPLIT")=="TEST")&&(DocTok->GetArgVal("TOPICS")=="YES")){
589          BowDocBs->AddTestDId(DId);}
590      }
591      if ((MxDocs!=-1)&&(Docs>=MxDocs)){break;}
592    }
593    BowDocBs->AssertOk();
594    return BowDocBs;
595  }
596  PBowDocBs TBowFl::LoadCiaWFBTxt(
597   const TStr& FPath, const int& MxDocs,
598   const TStr& SwSetTypeNm, const TStr& StemmerTypeNm,
599   const int& MxNGramLen, const int& MnNGramFq){
600    PCiaWFBBs CiaWFBBs=TCiaWFBBs::LoadHtml(FPath);
601    PSwSet SwSet=TSwSet::GetSwSet(SwSetTypeNm);
602    PStemmer Stemmer=TStemmer::GetStemmer(StemmerTypeNm);
603    PNGramBs NGramBs;
604    if (!((MxNGramLen==1)&&(MnNGramFq==1))){
605      TStrV HtmlStrV;
606      for (int CountryN=0; CountryN<CiaWFBBs->GetCountries(); CountryN++){
607        PCiaWFBCountry CiaWFBCountry=CiaWFBBs->GetCountry(CountryN);
608        HtmlStrV.Add(CiaWFBCountry->GetDescStr());
609      }
610      NGramBs=TNGramBs::GetNGramBsFromHtmlStrV(
611       HtmlStrV, MxNGramLen, MnNGramFq, SwSet, Stemmer);
612    }
613    PBowDocBs BowDocBs=TBowDocBs::New(SwSet, Stemmer, NGramBs);
614    for (int CountryN=0; CountryN<CiaWFBBs->GetCountries(); CountryN++){
615      PCiaWFBCountry CiaWFBCountry=CiaWFBBs->GetCountry(CountryN);
616      TStr CountryNm=CiaWFBCountry->GetCountryNm();
617      TStr DescStr=CiaWFBCountry->GetDescStr();
618      TStr CatNm=CiaWFBCountry->GetFldVal("Map references").GetTrunc();
619      TStrV CatNmV; CatNmV.Add(CatNm);
620      BowDocBs->AddHtmlDoc(CountryNm, CatNmV, DescStr, true);
621    }
622    BowDocBs->AssertOk();
623    return BowDocBs;
624  }
625  void TBowFl::SaveSparseMatlabTxt(const PBowDocBs& BowDocBs,
626      const PBowDocWgtBs& BowDocWgtBs, const TStr& FNm,
627      const TStr& CatFNm, const TIntV& _DIdV) {
628    TIntV DIdV;
629    if (_DIdV.Empty()) {
630        BowDocBs->GetAllDIdV(DIdV);
631    } else {
632        DIdV = _DIdV;
633    }
634    TFOut WdMapSOut(TStr::PutFExt(FNm, ".row-to-word-map.dat"));
635    for (int WId = 0; WId < BowDocWgtBs->GetWords(); WId++) {
636      TStr WdStr = BowDocBs->GetWordStr(WId);
637      WdMapSOut.PutStrLn(TStr::Fmt("%d %s", WId+1,  WdStr.CStr()));
638    }
639    WdMapSOut.Flush();
640    TFOut DocMapSOut(TStr::PutFExt(FNm, ".col-to-docName-map.dat"));
641    for (int DocN = 0; DocN < DIdV.Len(); DocN++) {
642      const int DId = DIdV[DocN];
643      TStr DocNm = BowDocBs->GetDocNm(DId);
644      DocMapSOut.PutStrLn(TStr::Fmt("%d %d %s", DocN, DId,  DocNm.CStr()));
645    }
646    DocMapSOut.Flush();
647    TFOut SOut(FNm);
648    for (int DocN = 0; DocN < DIdV.Len(); DocN++){
649      const int DId = DIdV[DocN];
650      PBowSpV DocSpV = BowDocWgtBs->GetSpV(DId);
651      const int DocWIds = DocSpV->GetWIds();
652      for (int DocWIdN=0; DocWIdN<DocWIds; DocWIdN++){
653        const int WId = DocSpV->GetWId(DocWIdN);
654        const double WordWgt = DocSpV->GetWgt(DocWIdN);
655        SOut.PutStrLn(TStr::Fmt("%d %d %.16f", WId+1, DocN+1, WordWgt));
656      }
657    }
658    SOut.Flush();
659    if (!CatFNm.Empty()) {
660      TFOut CatSOut(CatFNm);
661      for (int DocN = 0; DocN < DIdV.Len(); DocN++){
662        const int DId = DIdV[DocN];
663        const int DocCIds = BowDocBs->GetDocCIds(DId);
664        for (int DocCIdN=0; DocCIdN<DocCIds; DocCIdN++){
665          const int CId = BowDocBs->GetDocCId(DId, DocCIdN);
666          const double CatWgt = 1.0;
667          CatSOut.PutStrLn(TStr::Fmt("%d %d %.16f", CId+1, DocN+1, CatWgt));
668        }
669      }
670      CatSOut.Flush();
671    }
672  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-psroi_pooling_layer.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-bowflx.cpp</div>
                </div>
                <div class="column column_space"><pre><code>100                  int roi_row_offset = h * width;
101                  for (int w = wstart; w < wend; ++w) {
102                    int bottom_index = roi_row_offset + w;
103                    out_sum += current_bottom[bottom_index];
104                  }
</pre></code></div>
                <div class="column column_space"><pre><code>526      TStr DocNm=TStr::GetFNmStr(BowDocBs->GetDocNm(DId));
527      SOut.PutStr(DocNm);
528      for (int CIdN=0; CIdN<BowDocBs->GetDocCIds(DId); CIdN++){
529        int CId=BowDocBs->GetDocCId(DId, CIdN);
530        TStr CatNm=TStr::GetFNmStr(BowDocBs->GetCatNm(CId));
531        SOut.PutCh(' '); SOut.PutCh('!'); SOut.PutStr(CatNm);
532      }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    