
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 15.665399239543726%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-rolx.cpp</h3>
            <pre><code>1  #include "stdafx.h"
2  #include "Snap.h"
3  #include "rolx.h"
4  void PrintFeatures(const TIntFtrH& Features) {
5    for (TIntFtrH::TIter HI = Features.BegI(); HI < Features.EndI(); HI++) {
6      printf("%d: [", HI.GetKey()());
7      const TFtr& Feature = HI.GetDat();
8      for (int i = 0; i < Feature.Len(); ++i) {
9        if (i > 0) {
10          printf(",");
11        }
12        printf("%f", Feature[i]());
13      }
14      printf("]\n");
15    }
16  }
17  TIntFtrH CreateEmptyFeatures(const PUNGraph Graph) {
18    TIntFtrH EmptyFeatures;
19    for (TUNGraph::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++) {
20      EmptyFeatures.AddDat(TInt(NI.GetId()), TFtr());
21    }
22    return EmptyFeatures;
23  }
24  TIntFtrH CreateEmptyFeatures(const TIntFtrH& Features) {
25    TIntFtrH EmptyFeatures;
26    for (TIntFtrH::TIter HI = Features.BegI(); HI < Features.EndI(); HI++) {
27      EmptyFeatures.AddDat(HI.GetKey(), TFtr());
28    }
29    return EmptyFeatures;
30  }
31  int GetNumFeatures(const TIntFtrH& Features) {
32    return Features.BegI().GetDat().Len();
33  }
34  TFtr GetNthFeature(const TIntFtrH& Features, const int N) {
35    TFtr NthFeature;
36    IAssert(0 <= N && N < GetNumFeatures(Features));
37    for (TIntFtrH::TIter HI = Features.BegI(); HI < Features.EndI(); HI++) {
38      NthFeature.Add(HI.GetDat()[N]);
39    }
40    return NthFeature;
41  }
42  TIntFtrH ExtractFeatures(const PUNGraph Graph) {
43    TIntFtrH Features = CreateEmptyFeatures(Graph);
44    AddNeighborhoodFeatures(Graph, Features);
45    printf("finish neighborhood features\n");
46    AddRecursiveFeatures(Graph, Features);
47    printf("finish recursive features\n");
48    return Features;
49  }
50  void AddNeighborhoodFeatures(const PUNGraph Graph, TIntFtrH& Features) {
51    AddLocalFeatures(Graph, Features);
52    printf("finish local features\n");
53    AddEgonetFeatures(Graph, Features);
54    printf("finish egonet features\n");
55  }
56  void AddRecursiveFeatures(const PUNGraph Graph, TIntFtrH& Features) {
57    int SimilarityThreshold = 0;
58    TIntFtrH RetainedFeatures = Features;
59    while (true) {
60      TIntFtrH NewFeatures = GenerateRecursiveFeatures(Graph, RetainedFeatures);
61      RetainedFeatures = PruneRecursiveFeatures(Graph, Features, NewFeatures,
62          SimilarityThreshold);
63      if (0 == GetNumFeatures(RetainedFeatures)) {
64        break;
65      }
66      AppendFeatures(Features, RetainedFeatures);
67      ++SimilarityThreshold;
68      printf("recursion %d: ", SimilarityThreshold);
69      printf("current feature number %d\n", GetNumFeatures(Features));
70    }
71  }
72  void AddLocalFeatures(const PUNGraph Graph, TIntFtrH& Features) {
73    for (TUNGraph::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++) {
74      Features.GetDat(TInt(NI.GetId())).Add(NI.GetInDeg());
75    }
76  }
77  void AddEgonetFeatures(const PUNGraph Graph, TIntFtrH& Features) {
78    for (TUNGraph::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++) {
79      int NId = NI.GetId();
80      int ArndEdges;
81      PUNGraph Egonet = TSnap::GetEgonet(Graph, NId, ArndEdges);
82      Features.GetDat(NId).Add(Egonet->GetEdges());
83      Features.GetDat(NId).Add(ArndEdges);
84    }
85  }
86  TIntFtrH GenerateRecursiveFeatures(const PUNGraph Graph,
87      const TIntFtrH& CurrFeatures) {
88    const int NumCurrFeatures = GetNumFeatures(CurrFeatures);
89    if (0 == NumCurrFeatures) {
90      return CurrFeatures;
91    }
92    TIntFtrH NewFeatures = CreateEmptyFeatures(CurrFeatures);
93    for (int i = 0; i < NumCurrFeatures; ++i) {
94      for (TUNGraph::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++) {
95        float Sum = 0;
96        for (int j = 0; j < NI.GetInDeg(); ++j) {
97          int NbrNId = NI.GetInNId(j);
98          Sum += CurrFeatures.GetDat(NbrNId)[i]();
99        }
100        NewFeatures.GetDat(NI.GetId()).Add(Sum);
101        NewFeatures.GetDat(NI.GetId()).Add(0 == NI.GetInDeg()?
102            0 : (float(Sum) / NI.GetInDeg()));
103      }
104    }
105    return NewFeatures;
106  }
107  TIntFtrH PruneRecursiveFeatures(const PUNGraph Graph, const TIntFtrH& Features,
108      const TIntFtrH& NewFeatures, const int SimilarityThreshold) {
109    TIntFtrH AllFeatures = CreateEmptyFeatures(Features);
110    AppendFeatures(AllFeatures, Features);
111    AppendFeatures(AllFeatures, NewFeatures);
112    const float BinFraction = 0.5;
113    TIntFtrH LogBinFeatures = CalcVerticalLogBinning(AllFeatures, BinFraction);
114    PUNGraph FeatureGraph = BuildFeatureGraph(LogBinFeatures,
115        SimilarityThreshold);
116    return SummarizeConnectedComponents(FeatureGraph, Features, NewFeatures);
117  }
118  void AppendFeatures(TIntFtrH& DstFeatures, const TIntFtrH& SrcFeatures,
119      const int ColIdx) {
120    for (TIntFtrH::TIter HI = SrcFeatures.BegI();
121        HI < SrcFeatures.EndI();
122        HI++) {
123      const TFtr& Feature = HI.GetDat();
124      if (ColIdx >= 0) {
125        DstFeatures.GetDat(HI.GetKey()).Add(Feature[ColIdx]);
126      } else {
127        for (int i = 0; i < Feature.Len(); ++i) {
128          DstFeatures.GetDat(HI.GetKey()).Add(Feature[i]);
129        }
130      }
131    }
132  }
133  TIntFtrH CalcVerticalLogBinning(const TIntFtrH& Features,
134      const float BinFraction) {
135    const int NumFeatures = GetNumFeatures(Features);
136    TIntFtrH LogBinFeatures = CreateEmptyFeatures(Features);
137    for (int i = 0; i < NumFeatures; ++i) {
138      TVec<TInt> SortedNId = GetNIdSorted(Features, i);
139      AssignBinValue(SortedNId, BinFraction, LogBinFeatures);
140    }
141    return LogBinFeatures;
142  }
143  PUNGraph BuildFeatureGraph(const TIntFtrH& LogBinFeatures,
144      const int SimilarityThreshold) {
145    PUNGraph FeatureGraph = PUNGraph::New();
146    const int NumFeatures = GetNumFeatures(LogBinFeatures);
147    for (int i = 0; i < NumFeatures; ++i) {
148      FeatureGraph->AddNode(i);
149    }
150    for (int i = 0; i < NumFeatures; ++i) {
151      TFtr IthFeature = GetNthFeature(LogBinFeatures, i);
152      for (int j = i + 1; j < NumFeatures; ++j) {
153        TFtr JthFeature = GetNthFeature(LogBinFeatures, j);
154        if (IsSimilarFeature(IthFeature, JthFeature, SimilarityThreshold) &&
155            !FeatureGraph->IsEdge(i, j)) {
156          FeatureGraph->AddEdge(i, j);
157        }
158      }
159    }
160    return FeatureGraph;
161  }
162  TIntFtrH SummarizeConnectedComponents(const PUNGraph FeatureGraph,
163      const TIntFtrH& Features, const TIntFtrH& NewFeatures) {
164    TCnComV Wcc;
165    TSnap::GetWccs(FeatureGraph, Wcc);
166    TVec<TInt> RetainedIdx;
167    for (int i = 0; i < Wcc.Len(); ++i) {
168      RetainedIdx.Add(Wcc[i][0]);
169    }
170    RetainedIdx.Sort();
171    TIntFtrH RetainedFeatures = CreateEmptyFeatures(Features);
<span onclick='openModal()' class='match'>172    const int StartIdxNewFeatures = GetNumFeatures(Features);
173    for (int i = 0; i < RetainedIdx.Len(); ++i) {
174      const int IdxNewFeatures = RetainedIdx[i] - StartIdxNewFeatures;
</span>175      if (IdxNewFeatures >= 0) {
176        AppendFeatures(RetainedFeatures, NewFeatures, IdxNewFeatures);
177      }
178    }
179    return RetainedFeatures;
180  }
181  TVec<TInt> GetNIdSorted(const TIntFtrH& Features, const int Idx) {
182    THash<TInt, TFlt> F;
183    for (TIntFtrH::TIter HI = Features.BegI(); HI < Features.EndI(); HI++) {
184      F.AddDat(HI.GetKey(), HI.GetDat()[Idx]);
185    }
186    F.SortByDat();
187    TVec<TInt> SortedNId;
188    for (THash<TInt, TFlt>::TIter HI = F.BegI(); HI < F.EndI(); HI++) {
189      SortedNId.Add(HI.GetKey());
190    }
191    return SortedNId;
192  }
193  void AssignBinValue(const TVec<TInt>& SortedNId, const float BinFraction,
194      TIntFtrH& LogBinFeatures) {
195    int NumNodes = LogBinFeatures.Len();
196    int NumAssigned = 0;
197    int BinValue = 0;
198    while (NumAssigned < NumNodes) {
199      int NumToAssign = ceil(BinFraction * (NumNodes - NumAssigned));
200      for (int i = NumAssigned; i < NumAssigned + NumToAssign; ++i) {
201        int NId = SortedNId[i];
202        LogBinFeatures.GetDat(NId).Add(BinValue);
203      }
204      NumAssigned += NumToAssign;
205      ++BinValue;
206    }
207  }
208  bool IsSimilarFeature(const TFtr& F1, const TFtr& F2,
209      const int SimilarityThreshold) {
210    IAssert(F1.Len() == F2.Len());
211    for (int i = 0; i < F1.Len(); ++i) {
212      if (TFlt::Abs(F1[i] - F2[i]) > SimilarityThreshold) {
213        return false;
214      }
215    }
216    return true;
217  }
218  TFltVV ConvertFeatureToMatrix(const TIntFtrH& Features,
219      const TIntIntH& NodeIdMtxIdxH) {
220    const int NumNodes = Features.Len();
221    const int NumFeatures = GetNumFeatures(Features);
222    TFltVV FeaturesMtx(NumNodes, NumFeatures);
223    for (TIntFtrH::TIter HI = Features.BegI(); HI < Features.EndI(); HI++) {
224      int i = GetMtxIdx(HI.GetKey(), NodeIdMtxIdxH);
225      for (int j = 0; j < NumFeatures; ++j) {
226        FeaturesMtx(i, j) = HI.GetDat()[j];
227      }
228    }
229    return FeaturesMtx;
230  }
231  void PrintMatrix(const TFltVV& Matrix) {
232    int XDim = Matrix.GetXDim();
233    int YDim = Matrix.GetYDim();
234    printf("[");
235    for (int i = 0; i < XDim; ++i) {
236      printf("[");
237      for (int j = 0; j < YDim; ++j) {
238        if (j != 0) {
239          printf(" ");
240        }
241        printf("%f", Matrix(i, j)());
242      }
243      printf("]\n");
244    }
245    printf("]\n");
246  }
247  TFltVV CreateRandMatrix(const int XDim, const int YDim) {
248    int Seed = 13;
249    TFltVV Matrix(XDim, YDim);
250    for (int i = 0; i < XDim; ++i) {
251      for (int j = 0; j < YDim; ++j) {
252        Matrix(i, j) = (double)Seed / 10007;
253        Seed = (Seed * 1871) % 10007;
254      }
255    }
256    return Matrix;
257  }
258  bool FltIsZero(const TFlt Number) {
259    return TFlt::Abs(Number) < TFlt::Eps;
260  }
261  void CalcNonNegativeFactorization(const TFltVV& V, const int NumRoles,
262      TFltVV& W, TFltVV& H, const double Threshold) {
263    double Cost = 100, NewCost = 0;
264    int NumNodes = V.GetXDim();
265    int NumFeatures = V.GetYDim();
266    W = CreateRandMatrix(NumNodes, NumRoles);
267    H = CreateRandMatrix(NumRoles, NumFeatures);
268    TFltVV NewW(NumNodes, NumRoles);
269    TFltVV NewH(NumRoles, NumFeatures);
270    TFltVV Product(NumNodes, NumFeatures);
271    TFltV Sum(NumRoles);
272    TFltVV *PW = &W, *PH = &H, *PNewW = &NewW, *PNewH = &NewH, *Tmp;
273    while (TFlt::Abs((NewCost - Cost)/Cost) > Threshold) {
274      TLinAlg::Multiply(*PW, *PH, Product);
275      Cost = NewCost;
276      NewCost = 0;
277      for (int i = 0; i < NumNodes; i++) {
278        for (int j = 0; j < NumFeatures; j++) {
279          NewCost += V(i, j) * TMath::Log(Product(i, j)) - Product(i, j);
280        }
281      }
282      for (int i = 0; i < NumNodes; i++) {
283        for (int a = 0; a < NumRoles; a++) {
284          double SumU = 0;
285          for (int u = 0; u < NumFeatures; ++u) {
286            if (!FltIsZero(Product(i, u))) {
287              SumU += V(i, u) / Product(i, u) * PH->At(a, u);
288            }
289          }
290          PNewW->At(i, a) = PW->At(i, a) * SumU;
291        }
292      }
293      for (int i = 0; i < NumRoles; i++) {
294        Sum[i] = 0;
295      }
296      for (int i = 0; i < NumNodes; i++) {
297        for (int j = 0; j < NumRoles; j++) {
298          Sum[j] += PNewW->At(i, j);
299        }
300      }
301      for (int i = 0; i < NumNodes; i++) {
302        for (int j = 0; j < NumRoles; j++) {
303          PNewW->At(i, j) /= Sum[j];
304        }
305      }
306      for (int a = 0; a < NumRoles; a++) {
307        for (int u = 0; u < NumFeatures; u++) {
308          double SumI = 0;
309          for (int i = 0; i < NumNodes; ++i) {
310            if (!FltIsZero(Product(i, u))) {
311              SumI += PW->At(i, a) * V(i, u) / Product(i, u);
312            }
313          }
314          PNewH->At(a, u) = PH->At(a, u) * SumI;
315        }
316      }
317      Tmp = PW; PW = PNewW; PNewW = Tmp;
318      Tmp = PH; PH = PNewH; PNewH = Tmp;
319    }
320  }
321  TFlt CalcDescriptionLength(const TFltVV& V, const TFltVV& G,
322      const TFltVV& F) {
323    int B = 64;
324    int M = B * V.GetYDim() * (V.GetXDim() + F.GetYDim());
325    TFlt E = 0;
326    TFltVV GF(G.GetXDim(), F.GetYDim());
327    TLinAlg::Multiply(G, F, GF);
328    for (int i = 0; i < V.GetXDim(); ++i) {
329      for (int j = 0; j < V.GetYDim(); ++j) {
330        TFlt ValueV = V(i, j);
331        TFlt ValueGF = GF(i, j);
332        if (FltIsZero(ValueV)) {
333          E += ValueGF;
334        } else if (!FltIsZero(ValueGF)) {
335          E += ValueV * TMath::Log(ValueV / ValueGF) - ValueV + ValueGF;
336        }
337      }
338    }
339    return M + E;
340  }
341  TIntIntH CreateNodeIdMtxIdxHash(const TIntFtrH& Features) {
342    TIntIntH H;
343    TInt Idx = 0;
344    for (TIntFtrH::TIter HI = Features.BegI(); HI < Features.EndI(); HI++) {
345      H.AddDat(HI.GetKey(), Idx);
346      Idx++;
347    }
348    return H;
349  }
350  int GetMtxIdx(const TInt NodeId, const TIntIntH& NodeIdMtxIdxH) {
351    return NodeIdMtxIdxH.GetDat(NodeId)();
352  }
353  int GetNodeId(const TInt MtxId, const TIntIntH& NodeIdMtxIdxH) {
354    for (TIntIntH::TIter HI = NodeIdMtxIdxH.BegI();
355        HI < NodeIdMtxIdxH.EndI();
356        HI++) {
357      if (HI.GetDat() == MtxId) {
358        return HI.GetKey()();
359      }
360    }
361    return -1;
362  }
363  TIntIntH FindRoles(const TFltVV& G, const TIntIntH& NodeIdMtxIdxH) {
364    TIntIntH Roles;
365    for (int i = 0; i < G.GetXDim(); i++) {
366      int Role = -1;
367      TFlt Max = TFlt::Mn;
368      for (int j = 0; j < G.GetYDim(); j ++) {
369        if (G(i, j) > Max) {
370          Max = G(i, j);
371          Role = j;
372        }
373      }
374      int NodeId = GetNodeId(i, NodeIdMtxIdxH);
375      Roles.AddDat(NodeId, Role);
376    }
377    return Roles;
378  }
379  void PlotRoles(const PUNGraph Graph, const TIntIntH& Roles) {
380    TStr RoleToColor[10] = { "white", "black", "red", "green", "blue",
381        "yellow", "gold", "cyan", "magenta", "brown" };
382    TIntStrH Color;
383    for (TIntIntH::TIter HI = Roles.BegI(); HI < Roles.EndI(); HI++) {
384      Color.AddDat(HI.GetKey(), RoleToColor[HI.GetDat()].CStr());
385    }
386    TSnap::DrawGViz(Graph, gvlDot, "gviz_plot.png", "Dot", 1, Color);
387  }
388  void PrintRoles(const TIntIntH& Roles) {
389    printf("--roles (node ID: role ID)--\n");
390    printf("{\n");
391    for (TIntIntH::TIter HI = Roles.BegI(); HI < Roles.EndI(); HI++) {
392      printf("(%d: %d)\n", HI.GetKey()(), HI.GetDat()());
393    }
394    printf("}\n");
395  }
396  void FPrintMatrix(const TFltVV& Matrix, const TStr& Path) {
397    FILE *Fp;
398    Fp = fopen(Path.CStr(), "w");
399    int XDim = Matrix.GetXDim();
400    int YDim = Matrix.GetYDim();
401    for (int i = 0; i < XDim; ++i) {
402      for (int j = 0; j < YDim; ++j) {
403        if (j != 0) {
404          fprintf(Fp, " ");
405        }
406        fprintf(Fp, "%f", Matrix(i, j)());
407      }
408      fprintf(Fp, "\n");
409    }
410    fclose(Fp);
411  }
412  void FPrintNodeMappings(const TIntIntH& NodeIdMtxIdxH, const TStr& Path) {
413    FILE *Fp;
414    Fp = fopen(Path.CStr(), "w");
415    fprintf(Fp, "# mappings from the feature line numbers to node IDs\n");
416    for (int i = 0; i < NodeIdMtxIdxH.Len(); i++) {
417      int NodeId = GetNodeId(i, NodeIdMtxIdxH);
418      fprintf(Fp, "%d %d\n", i, NodeId);
419    }
420    fclose(Fp);
421  }
422  void FPrintRoles(const TIntIntH& Roles, const TStr& Path) {
423    FILE *Fp;
424    Fp = fopen(Path.CStr(), "w");
425    fprintf(Fp, "--roles (node ID role ID)--\n\n");
426    for (TIntIntH::TIter HI = Roles.BegI(); HI < Roles.EndI(); HI++) {
427      fprintf(Fp, "%d\t%d\n", HI.GetKey()(), HI.GetDat()());
428    }
429    fclose(Fp);
430  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-mag.cpp</h3>
            <pre><code>1  #include "stdafx.h"
2  #include "mag.h"
3  TRnd TMAGNodeSimple::Rnd = TRnd(0);
4  TRnd TMAGNodeBern::Rnd = TRnd(0);
5  TRnd TMAGNodeBeta::Rnd = TRnd(0);
6  const double TMAGAffMtx::NInf = -DBL_MAX;
7  TMAGAffMtx::TMAGAffMtx(const TFltV& SeedMatrix) : SeedMtx(SeedMatrix) {
8    MtxDim = (int) sqrt((double)SeedMatrix.Len());
9    IAssert(MtxDim*MtxDim == SeedMtx.Len());
10  }
11  TMAGAffMtx& TMAGAffMtx::operator = (const TMAGAffMtx& Kronecker) {
12    if (this != &Kronecker){
13      MtxDim=Kronecker.MtxDim;
14      SeedMtx=Kronecker.SeedMtx;
15    }
16    return *this;
17  }
18  bool TMAGAffMtx::IsProbMtx() const {
19    for (int i = 0; i < Len(); i++) {
20      if (At(i) < 0.0 || At(i) > 1.0) return false;
21    }
22    return true;
23  }
24  void TMAGAffMtx::SetRndMtx(TRnd& Rnd, const int& PrmMtxDim, const double& MinProb) {
25    MtxDim = PrmMtxDim;
26    SeedMtx.Gen(MtxDim*MtxDim);
27    for (int p = 0; p < SeedMtx.Len(); p++) {
28      do {
29        SeedMtx[p] = Rnd.GetUniDev();
30      } while (SeedMtx[p] < MinProb);
31    }
32  }
33  void TMAGAffMtx::SetEpsMtx(const double& Eps1, const double& Eps0, const int& Eps1Val, const int& Eps0Val) {
34    for (int i = 0; i < Len(); i++) {
35      double& Val = At(i);
36      if (Val == Eps1Val) Val = double(Eps1);
37      else if (Val == Eps0Val) Val = double(Eps0);
38    }
39  }
40  void TMAGAffMtx::AddRndNoise(TRnd& Rnd, const double& SDev) {
41    Dump("before");
42    double NewVal;
43    int c =0;
44    for (int i = 0; i < Len(); i++) {
45      for(c = 0; ((NewVal = At(i)*Rnd.GetNrmDev(1, SDev, 0.8, 1.2)) < 0.01 || NewVal>0.99) && c <1000; c++) { }
46      if (c < 999) { At(i) = NewVal; } else { printf("XXXXX\n"); }
47    }
48    Dump("after");
49  }
50  TStr TMAGAffMtx::GetMtxStr() const {
51    TChA ChA("[");
52    for (int i = 0; i < Len(); i++) {
53      ChA += TStr::Fmt("%g", At(i));
54      if ((i+1)%GetDim()==0 && (i+1<Len())) { ChA += "; "; }
55      else if (i+1<Len()) { ChA += " "; }
56    }
57    ChA += "]";
58    return TStr(ChA);
59  }
60  void TMAGAffMtx::GetLLMtx(TMAGAffMtx& LLMtx) {
61    LLMtx.GenMtx(MtxDim);
62    for (int i = 0; i < Len(); i++) {
63      if (At(i) != 0.0) { LLMtx.At(i) = log(At(i)); }
64      else { LLMtx.At(i) = NInf; }
65    }
66  }
67  void TMAGAffMtx::GetProbMtx(TMAGAffMtx& ProbMtx) {
68    ProbMtx.GenMtx(MtxDim);
69    for (int i = 0; i < Len(); i++) {
70      if (At(i) != NInf) { ProbMtx.At(i) = exp(At(i)); }
71      else { ProbMtx.At(i) = 0.0; }
72    }
73  }
74  void TMAGAffMtx::Swap(TMAGAffMtx& Mtx) {
75    ::Swap(MtxDim, Mtx.MtxDim);
76    SeedMtx.Swap(Mtx.SeedMtx);
77  }
78  double TMAGAffMtx::GetMtxSum() const {
79    double Sum = 0;
80    for (int i = 0; i < Len(); i++) {
81      Sum += At(i); }
82    return Sum;
83  }
84  double TMAGAffMtx::GetRowSum(const int& RowId) const {
85    double Sum = 0;
86    for (int c = 0; c < GetDim(); c++) {
87      Sum += At(RowId, c); }
88    return Sum;
89  }
90  double TMAGAffMtx::GetColSum(const int& ColId) const {
91    double Sum = 0;
92    for (int r = 0; r < GetDim(); r++) {
93      Sum += At(r, ColId); }
94    return Sum;
95  }
96  double TMAGAffMtx::Normalize() {
97  	double Sum = GetMtxSum();
98  	if(Sum == 0) {
99  		return 0;
100  	}
101  	for(int i = 0; i < Len(); i++) {
102  		At(i) = At(i) / Sum;
103  	}
104  	return Sum;
105  }
106  void TMAGAffMtx::Dump(const TStr& MtxNm, const bool& Sort) const {
107    if (! MtxNm.Empty()) printf("%s\n", MtxNm.CStr());
108    double Sum=0.0;
109    TFltV ValV = SeedMtx;
110    if (Sort) { ValV.Sort(false); }
111    for (int i = 0; i < ValV.Len(); i++) {
112      printf("  %10.4g", ValV[i]());
113      Sum += ValV[i];
114      if ((i+1) % GetDim() == 0) { printf("\n"); }
115    }
116    printf(" (sum:%.4f)\n", Sum);
117  }
118  double TMAGAffMtx::GetAvgAbsErr(const TMAGAffMtx& Mtx1, const TMAGAffMtx& Mtx2) {
119    TFltV P1 = Mtx1.GetMtx();
120    TFltV P2 = Mtx2.GetMtx();
121    IAssert(P1.Len() == P2.Len());
122    P1.Sort();  P2.Sort();
123    double delta = 0.0;
124    for (int i = 0; i < P1.Len(); i++) {
125      delta += fabs(P1[i] - P2[i]);
126    }
127    return delta/P1.Len();
128  }
129  double TMAGAffMtx::GetAvgFroErr(const TMAGAffMtx& Mtx1, const TMAGAffMtx& Mtx2) {
130    TFltV P1 = Mtx1.GetMtx();
131    TFltV P2 = Mtx2.GetMtx();
132    IAssert(P1.Len() == P2.Len());
133    P1.Sort();  P2.Sort();
134    double delta = 0.0;
135    for (int i = 0; i < P1.Len(); i++) {
136      delta += pow(P1[i] - P2[i], 2);
137    }
138    return sqrt(delta/P1.Len());
139  }
140  TMAGAffMtx TMAGAffMtx::GetMtx(TStr MatlabMtxStr) {
141    TStrV RowStrV, ColStrV;
142    MatlabMtxStr.ChangeChAll(',', ' ');
143    MatlabMtxStr.SplitOnAllCh(';', RowStrV);  IAssert(! RowStrV.Empty());
144    RowStrV[0].SplitOnWs(ColStrV);    IAssert(! ColStrV.Empty());
145    const int Rows = RowStrV.Len();
146    const int Cols = ColStrV.Len();
147    IAssert(Rows == Cols);
148    TMAGAffMtx Mtx(Rows);
149    for (int r = 0; r < Rows; r++) {
150      RowStrV[r].SplitOnWs(ColStrV);
151      IAssert(ColStrV.Len() == Cols);
152      for (int c = 0; c < Cols; c++) {
153        Mtx.At(r, c) = (double) ColStrV[c].GetFlt(); }
154    }
155    return Mtx;
156  }
157  TMAGAffMtx TMAGAffMtx::GetRndMtx(TRnd& Rnd, const int& Dim, const double& MinProb) {
158    TMAGAffMtx Mtx;
159    Mtx.SetRndMtx(Rnd, Dim, MinProb);
160    return Mtx;
161  }
162  void TMAGNodeSimple::AttrGen(TIntVV& AttrVV, const int& NNodes) {
163  	IAssert(Dim > 0);
164  	AttrVV.Gen(NNodes, Dim);
165  	AttrVV.PutAll(0);
166  	for(int i = 0; i < NNodes; i++) {
167  		for(int l = 0; l < Dim; l++) {
168  			if((TMAGNodeSimple::Rnd).GetUniDev() > Mu) {
169  				AttrVV.At(i, l) = 1;
170  			}
171  		}
172  	}
173  }
174  void TMAGNodeSimple::LoadTxt(const TStr& InFNm) {
175  	FILE *fp = fopen(InFNm.CStr(), "r");
176  	IAssertR(fp != NULL, "File does not exist: " + InFNm);
177  	char buf[128];
178  	char *token;
179  	TStr TokenStr;
180  	TFlt Val;
181  	token = strtok(buf, "&");
182  	token = strtok(token, " \t");
183  	TokenStr = TStr(token);
184  	Mu = TokenStr.GetFlt(Val);
185  	fclose(fp);
186  }
187  void TMAGNodeSimple::SaveTxt(TStrV& OutStrV) const {
188  	OutStrV.Gen(Dim, 0);
189  	for(int i = 0; i < Dim; i++) {
190  		OutStrV.Add(TStr::Fmt("%f", double(Mu)));
191  	}
192  }
193  TMAGNodeBern& TMAGNodeBern::operator=(const TMAGNodeBern& Dist) {
194  	MuV = Dist.MuV;
195  	Dim = Dist.Dim;
196  	return (*this);
197  }
198  void TMAGNodeBern::AttrGen(TIntVV& AttrVV, const int& NNodes) {
199  	IAssert(Dim > 0);
200  	AttrVV.Gen(NNodes, Dim);
201  	AttrVV.PutAll(0);
202  	for(int i = 0; i < NNodes; i++) {
203  		for(int l = 0; l < Dim; l++) {
204  			if((TMAGNodeBern::Rnd).GetUniDev() > MuV[l]) {
205  				AttrVV.At(i, l) = 1;
206  			}
207  		}
208  	}
209  }
210  void TMAGNodeBern::LoadTxt(const TStr& InFNm) {
211  	FILE *fp = fopen(InFNm.CStr(), "r");
212  	IAssertR(fp != NULL, "File does not exist: " + InFNm);
213  	Dim = 0;
214  	MuV.Gen(10, 0);
215  	char buf[128];
216  	char *token;
217  	TStr TokenStr;
218  	TFlt Val;
219  	while(fgets(buf, sizeof(buf), fp) != NULL) {
220  		token = strtok(buf, "&");
221  		token = strtok(token, " \t");
222  		TokenStr = TStr(token);
223  		MuV.Add(TokenStr.GetFlt(Val));
224  	}
225  	Dim = MuV.Len();
226  	fclose(fp);
227  }
228  void TMAGNodeBern::SaveTxt(TStrV& OutStrV) const {
229  	OutStrV.Gen(Dim, 0);
230  	for(int i = 0; i < Dim; i++) {
231  		OutStrV.Add(TStr::Fmt("%f", double(MuV[i])));
232  	}
233  }
234  TMAGNodeBeta& TMAGNodeBeta::operator=(const TMAGNodeBeta& Dist) {
235  	AlphaV = Dist.AlphaV;
236  	BetaV = Dist.BetaV;
237  	Dim = Dist.Dim;
238  	MuV = Dist.MuV;
239  	Dirty = Dist.Dirty;
240  	return (*this);
241  }
242  void TMAGNodeBeta::SetBeta(const int& Attr, const double& Alpha, const double& Beta) {
243  	IAssert(Attr < Dim);
244  	AlphaV[Attr] = Alpha;
245  	BetaV[Attr] = Beta;
246  	Dirty = true;
247  }
248  void TMAGNodeBeta::SetBetaV(const TFltV& _AlphaV, const TFltV& _BetaV) {
249  	IAssert(_AlphaV.Len() == _BetaV.Len());
250  	AlphaV = _AlphaV;
251  	BetaV = _BetaV;
252  	Dim = _AlphaV.Len();
253  	Dirty = true;
254  }
255  void TMAGNodeBeta::AttrGen(TIntVV& AttrVV, const int& NNodes) {
256  	IAssert(Dim > 0);
257  	AttrVV.Gen(NNodes, Dim);
258  	AttrVV.PutAll(0);
259  	for(int i = 0; i < NNodes; i++) {
260  		for(int l = 0; l < Dim; l++) {
261  			double x = TMAGNodeBeta::Rnd.GetGammaDev((int)AlphaV[l]);
262  			double y = TMAGNodeBeta::Rnd.GetGammaDev((int)BetaV[l]);
263  			MuV[l] = x / (x + y);
264  			if((TMAGNodeBeta::Rnd).GetUniDev() > MuV[l]) {
265  				AttrVV.At(i, l) = 1;
266  			}
267  		}
268  	}
269  	Dirty = false;
270  }
271  void TMAGNodeBeta::LoadTxt(const TStr& InFNm) {
272  	FILE *fp = fopen(InFNm.CStr(), "r");
273  	IAssertR(fp != NULL, "File does not exist: " + InFNm);
274  	Dim = 0;
275  	AlphaV.Gen(10, 0);
276  	BetaV.Gen(10, 0);
277  	char buf[128];
278  	char *token;
279  	TStr TokenStr;
280  	TFlt Val;
281  	while(fgets(buf, sizeof(buf), fp) != NULL) {
282  		token = strtok(buf, "&");
283  		token = strtok(token, " \t");
284  		TokenStr = TStr(token);
285  		AlphaV.Add(TokenStr.GetFlt(Val));
286  		token = strtok(NULL, " \t");
287  		TokenStr = TStr(token);
288  		BetaV.Add(TokenStr.GetFlt(Val));
289  		Dim++;
290  	}
291  	fclose(fp);
292  }
293  void TMAGNodeBeta::SaveTxt(TStrV& OutStrV) const {
294  	OutStrV.Gen(Dim, 0);
295  	for(int i = 0; i < Dim; i++) {
296  		OutStrV.Add(TStr::Fmt("%f %f", double(AlphaV[i]), double(BetaV[i])));
297  	}
298  }
299  void TMAGFitBern::SetGraph(const PNGraph& GraphPt) {
300  	Graph = GraphPt;
301  	bool NodesOk = true;
302  	for (int nid = 0; nid < Graph->GetNodes(); nid++) {
303  	if (! Graph->IsNode(nid)) { NodesOk=false; break; } }
304  	if (! NodesOk) {
305  	TIntV NIdV;  GraphPt->GetNIdV(NIdV);
306  	Graph = TSnap::GetSubGraph(GraphPt, NIdV, true);
307  	for (int nid = 0; nid < Graph->GetNodes(); nid++) {
308  	  IAssert(Graph->IsNode(nid)); }
309  	}
310  }
311  void TMAGFitBern::SetPhiVV(const TIntVV& AttrVV, const int KnownIds) {
312  	const int NNodes = Param.GetNodes();
313  	const int NAttrs = Param.GetAttrs();
314  	PhiVV.Gen(NNodes, NAttrs);
315  	KnownVV.Gen(NNodes, NAttrs);
316  	for(int l = 0; l < NAttrs; l++) {
317  		for(int i = 0; i < NNodes; i++) {
318  			if(int(AttrVV(i, l)) == 0) {
319  				PhiVV(i, l) = 0.9999;
320  			} else {
321  				PhiVV(i, l) = 0.0001;
322  			}
323  		}
324  		if(l < KnownIds) {
325  			KnownVV.PutY(l, true);
326  		} else {
327  			KnownVV.PutY(l, false);
328  		}
329  	}
330  }
331  void TMAGFitBern::SaveTxt(const TStr& FNm) {
332  	const int NNodes = Param.GetNodes();
333  	const int NAttrs = Param.GetAttrs();
334  	const TFltV MuV = GetMuV();
335  	TMAGAffMtxV MtxV;
336  	Param.GetMtxV(MtxV);
337  	FILE *fp = fopen(FNm.GetCStr(), "w");
338  	for(int l = 0; l < NAttrs; l++) {
339  		fprintf(fp, "%.4f\t", double(MuV[l]));
340  		for(int row = 0; row < 2; row++) {
341  			for(int col = 0; col < 2; col++) {
342  				fprintf(fp, " %.4f", double(MtxV[l].At(row, col)));
343  			}
344  			fprintf(fp, (row == 0) ? ";" : "\n");
345  		}
346  	}
347  	fclose(fp);
348  	fp = fopen((FNm + "f").CStr(), "w");
349  	for(int i = 0; i < NNodes; i++) {
350  		for(int l = 0; l < NAttrs; l++) {
351  			fprintf(fp, "%f ", double(PhiVV(i, l)));
352  		}
353  		fprintf(fp, "\n");
354  	}
355  	fclose(fp);
356  }
357  void TMAGFitBern::Init(const TFltV& MuV, const TMAGAffMtxV& AffMtxV) {
358  	TMAGNodeBern DistParam(MuV);
359  	Param.SetNodeAttr(DistParam);
360  	Param.SetMtxV(AffMtxV);
361  	const int NNodes = Param.GetNodes();
362  	const int NAttrs = Param.GetAttrs();
363  	PhiVV.Gen(NNodes, NAttrs);
364  	KnownVV.Gen(NNodes, NAttrs);
365  	KnownVV.PutAll(false);
366  }
367  #if 0
368  void TMAGFitBern::PerturbInit(const TFltV& MuV, const TMAGAffMtxV& AffMtxV, const double& PerturbRate) {
369  	IAssert(PerturbRate < 1.0);
370  	TFltV InitMuV = MuV;	
371  	TMAGNodeBern DistParam(InitMuV);
372  	Param.SetMtxV(AffMtxV);
373  	TRnd& Rnd = TMAGNodeBern::Rnd;
374  	TMAGAffMtxV PerturbMtxV = AffMtxV;
375  	const int NNodes = Param.GetNodes();
376  	const int NAttrs = Param.GetAttrs();
377  	for(int l = 0; l < NAttrs; l++) {
378  		double Mu = MuV[l] + PerturbRate * (Rnd.GetUniDev() - 0.5) * 2;
379  		if(Mu < 0.01) {  Mu = 0.01;  }
380  		if(Mu > 0.99) {  Mu = 0.99;  }
381  		DistParam.SetMu(l, Mu);
382  		TMAGAffMtx AffMtx(AffMtxV[l]);
383  		for(int p = 0; p < 4; p++) {
384  			AffMtx.At(p) += PerturbRate * (Rnd.GetUniDev() - 0.5) * 2;
385  			if(AffMtx.At(p) < 0.05) {  AffMtx.At(p) = 0.05;  }
386  			if(AffMtx.At(p) > 0.95) {  AffMtx.At(p) = 0.95;  }
387  		}
388  		AffMtx.At(0, 1) = AffMtx.At(1, 0);
389  		PerturbMtxV[l] = AffMtx;
390  	}
391  	printf("\n");
392  	for(int l = 0; l < NAttrs; l++) {
393  		printf("Mu = %.3f  ", DistParam.GetMu(l));
394  		printf("AffMtx = %s\n", PerturbMtxV[l].GetMtxStr().GetCStr());
395  	}
396  	Param.SetMtxV(PerturbMtxV);
397  	Param.SetNodeAttr(DistParam);
398  	PhiVV.Gen(NNodes, NAttrs);
399  	KnownVV.Gen(NNodes, NAttrs);
400  	KnownVV.PutAll(false);
401  }
402  #endif	
403  void TMAGFitBern::RandomInit(const TFltV& MuV, const TMAGAffMtxV& AffMtxV, const int& Seed) {
404  	TRnd& Rnd = TMAGNodeBern::Rnd;
405  	Rnd.PutSeed(Seed);
406  	TFltV InitMuV = MuV;	InitMuV.PutAll(0.5);
407  	TMAGNodeBern DistParam(InitMuV);
408  	Param.SetMtxV(AffMtxV);
409  	const int NNodes = Param.GetNodes();
410  	const int NAttrs = Param.GetAttrs();
411  	PhiVV.Gen(NNodes, NAttrs);
412  	KnownVV.Gen(NNodes, NAttrs);
413  	KnownVV.PutAll(false);
414  	for(int i = 0; i < NNodes; i++) {
415  		for(int l = 0; l < NAttrs; l++) {
416  			PhiVV.At(i, l) = Rnd.GetUniDev();
417  		}
418  	}
419  	TMAGAffMtxV RndMtxV = AffMtxV;
420  	for(int l = 0; l < NAttrs; l++) {
421  		for(int p = 0; p < 4; p++) {
422  			RndMtxV[l].At(p) = TMAGNodeBern::Rnd.GetUniDev();
423  			if(RndMtxV[l].At(p) < 0.1) {  RndMtxV[l].At(p) = 0.1;  }
424  			if(RndMtxV[l].At(p) > 0.9) {  RndMtxV[l].At(p) = 0.9;  }
425  		}
426  		RndMtxV[l].At(0, 1) = RndMtxV[l].At(1, 0);
427  	}
428  	printf("\n");
429  	for(int l = 0; l < NAttrs; l++) {
430  		printf("AffMtx = %s\n", RndMtxV[l].GetMtxStr().GetCStr());
431  	}
432  	Param.SetMtxV(RndMtxV);
433  	Param.SetNodeAttr(DistParam);
434  }
435  const double TMAGFitBern::GetInCoeff(const int& i, const int& j, const int& l, const int& A, const TMAGAffMtx& Theta) const {
436  	return (PhiVV.At(i, l) * Theta.At(0, A) + (1.0 - PhiVV.At(i, l)) * Theta.At(1, A));
437  }
438  const double TMAGFitBern::GetOutCoeff(const int& i, const int& j, const int& l, const int& A, const TMAGAffMtx& Theta) const {
439  	return (PhiVV.At(j, l) * Theta.At(A, 0) + (1.0 - PhiVV.At(j, l)) * Theta.At(A, 1));
440  }
441  const double TMAGFitBern::GetAvgInCoeff(const int& i, const int& AId, const int& A, const TMAGAffMtx& Theta) const {
442  	const int NNodes = Param.GetNodes();
443  	const double Mu_l = AvgPhiV[AId] / double(NNodes);
444  	return (Mu_l * Theta.At(0, A) + (1.0 - Mu_l) * Theta.At(1, A));
445  }
446  const double TMAGFitBern::GetAvgOutCoeff(const int& i, const int& AId, const int& A, const TMAGAffMtx& Theta) const {
447  	const int NNodes = Param.GetNodes();
448  	const double Mu_l = AvgPhiV[AId] / double(NNodes);
449  	return (Mu_l * Theta.At(A, 0) + (1.0 - Mu_l) * Theta.At(A, 1));
450  }
451  const double TMAGFitBern::GetProbPhi(const int& NId1, const int& NId2, const int& AId, const int& Attr1, const int& Attr2) const {
452  	double Prob1 = (Attr1 == 0) ? double(PhiVV.At(NId1, AId)) : (1.0 - PhiVV.At(NId1, AId));
453  	double Prob2 = (Attr2 == 0) ? double(PhiVV.At(NId2, AId)) : (1.0 - PhiVV.At(NId2, AId));
454  	return (Prob1 * Prob2);
455  }
456  const double TMAGFitBern::GetProbMu(const int& NId1, const int& NId2, const int& AId, const int& Attr1, const int& Attr2, const bool Left, const bool Right) const {
457  	TMAGNodeBern DistParam = Param.GetNodeAttr();
458  	double Mu = AvgPhiV[AId] / double(Param.GetNodes());
459  	double Prob1 = (Left) ? double(PhiVV.At(NId1, AId)) : double(Mu);
460  	double Prob2 = (Right)? double(PhiVV.At(NId2, AId)) : double(Mu);
461  	Prob1 = (Attr1 == 0) ? Prob1 : 1.0 - Prob1;
462  	Prob2 = (Attr2 == 0) ? Prob2 : 1.0 - Prob2;
463  	return (Prob1 * Prob2);
464  }
465  const double TMAGFitBern::GetThetaLL(const int& NId1, const int& NId2, const int& AId) const {
466  	double LL = 0.0;
467  	const TMAGAffMtx& Mtx = Param.GetMtx(AId);
468  	for(int A1 = 0; A1 < 2; A1++) {
469  		for(int A2 = 0; A2 < 2; A2++) {
470  			LL += GetProbPhi(NId1, NId2, AId, A1, A2) * Mtx.At(A1, A2);
471  		}
472  	}
473  	return log(LL);
474  }
475  const double TMAGFitBern::GetAvgThetaLL(const int& NId1, const int& NId2, const int& AId, const bool Left, const bool Right) const {
476  	double LL = 0.0;
477  	const TMAGAffMtx& Mtx = Param.GetMtx(AId);
478  	for(int A1 = 0; A1 < 2; A1++) {
479  		for(int A2 = 0; A2 < 2; A2++) {
480  			LL += GetProbMu(NId1, NId2, AId, A1, A2, Left, Right) * Mtx.At(A1, A2);
481  		}
482  	}
483  	return log(LL);
484  }
485  const double TMAGFitBern::GetSqThetaLL(const int& NId1, const int& NId2, const int& AId) const {
486  	double LL = 0.0;
487  	const TMAGAffMtx& Mtx = Param.GetMtx(AId);
488  	for(int A1 = 0; A1 < 2; A1++) {
489  		for(int A2 = 0; A2 < 2; A2++) {
490  			LL += GetProbPhi(NId1, NId2, AId, A1, A2) * Mtx.At(A1, A2) * Mtx.At(A1, A2);
491  		}
492  	}
493  	return log(LL);
494  }
495  const double TMAGFitBern::GetAvgSqThetaLL(const int& NId1, const int& NId2, const int& AId, const bool Left, const bool Right) const {
496  	double LL = 0.0;
497  	const TMAGAffMtx& Mtx = Param.GetMtx(AId);
498  	for(int A1 = 0; A1 < 2; A1++) {
499  		for(int A2 = 0; A2 < 2; A2++) {
500  			LL += GetProbMu(NId1, NId2, AId, A1, A2, Left, Right) * Mtx.At(A1, A2) * Mtx.At(A1, A2);
501  		}
502  	}
503  	return log(LL);
504  }
505  const double TMAGFitBern::GetProdLinWeight(const int& NId1, const int& NId2) const {
506  	const int NAttrs = Param.GetAttrs();
507  	double LL = 0.0;
508  	for(int l = 0; l < NAttrs; l++) {
509  		LL += GetThetaLL(NId1, NId2, l);
510  	}
511  	return LL + log(NormConst);
512  }
513  const double TMAGFitBern::GetAvgProdLinWeight(const int& NId1, const int& NId2, const bool Left, const bool Right) const {
514  	const int NAttrs = Param.GetAttrs();
515  	double LL = 0.0;
516  	for(int l = 0; l < NAttrs; l++) {
517  		LL += GetAvgThetaLL(NId1, NId2, l, Left, Right);
518  	}
519  	return LL + log(NormConst);
520  }
521  const double TMAGFitBern::GetProdSqWeight(const int& NId1, const int& NId2) const {
522  	const int NAttrs = Param.GetAttrs();
523  	double LL = 0.0;
524  	for(int l = 0; l < NAttrs; l++) {
525  		LL += GetSqThetaLL(NId1, NId2, l);
526  	}
527  	return LL + 2 * log(NormConst);
528  }
529  const double TMAGFitBern::GetAvgProdSqWeight(const int& NId1, const int& NId2, const bool Left, const bool Right) const {
530  	const int NAttrs = Param.GetAttrs();
531  	double LL = 0.0;
532  	for(int l = 0; l < NAttrs; l++) {
533  		LL += GetAvgSqThetaLL(NId1, NId2, l, Left, Right);
534  	}
535  	return LL + 2 * log(NormConst);
536  }
537  const double LogSumExp(const double LogVal1, const double LogVal2) {
538  	double MaxExp = (LogVal1 > LogVal2) ? LogVal1 : LogVal2;
539  	double Sum = exp(LogVal1 - MaxExp) + exp(LogVal2 - MaxExp);
540  	return (log(Sum) + MaxExp);
541  }
542  const double LogSumExp(const TFltV& LogValV) {
543  	const int Len = LogValV.Len();
544  	double MaxExp = -DBL_MAX;
545  	for(int i = 0; i < Len; i++) {
546  		if(MaxExp < LogValV[i]) {  MaxExp = LogValV[i];  }
547  	}
548  	double Sum = 0.0;
549  	for(int i = 0; i < Len; i++) {
550  		Sum += exp(LogValV[i] - MaxExp);
551  	}
552  	return (log(Sum) + MaxExp);
553  }
554  const double LogSumExp(const double *LogValArray, const int Len) {
555  	TFltV TmpV(Len);
556  	for(int i = 0; i < Len; i++) {  TmpV[i] = LogValArray[i];  }
557  	return LogSumExp(TmpV);
558  }
559  const double TMAGFitBern::GradPhiMI(const double& x, const int& NId, const int& AId, const double& Lambda, const double& DeltaQ, const TFltVV& CntVV) {
560  	const int NAttrs = CntVV.GetYDim();
561  	double Grad = DeltaQ - log(x) + log(1.0-x);
562  	for(int l = 0; l < NAttrs; l++) {
563  		if(l == AId) {  continue;  }
564  		const double C0 = PhiVV(NId, l);
565  		const double C1 = 1.0 - C0;
566  		Grad -= Lambda * C0 * log(CntVV(0, l) + C0 * x);
567  		Grad -= Lambda * C1 * log(CntVV(1, l) + C1 * x);
568  		Grad += Lambda * C0 * log(CntVV(2, l) + C0 * (1-x));
569  		Grad += Lambda * C1 * log(CntVV(3, l) + C1 * (1-x));
570  		Grad -= Lambda * log(CntVV(0, l) + CntVV(1, l) + x);
571  		Grad += Lambda * log(CntVV(2, l) + CntVV(3, l) + (1-x));
572  	}
573  	return Grad;
574  }
575  const double TMAGFitBern::ObjPhiMI(const double& x, const int& NId, const int& AId, const double& Lambda, const double& Q0, const double& Q1, const TFltVV& CntVV) {
576  	const int NAttrs = CntVV.GetYDim();
577  	double Val = x*(Q0 - log(x)) + (1-x)*(Q1 - log(1.0-x));
578  	for(int l = 0; l < NAttrs; l++) {
579  		if(l == AId) {  continue;  }
580  		const double C0 = PhiVV(NId, l);
581  		const double C1 = 1.0 - C0;
582  		Val -= Lambda * (CntVV(0, l) + C0 * x) * log(CntVV(0, l) + C0 * x);
583  		Val -= Lambda * (CntVV(1, l) + C1 * x) * log(CntVV(1, l) + C1 * x);
584  		Val -= Lambda * (CntVV(2, l) + C0 * (1-x)) * log(CntVV(2, l) + C0 * (1-x));
585  		Val -= Lambda * (CntVV(3, l) + C1 * (1-x)) * log(CntVV(3, l) + C1 * (1-x));
586  		Val += Lambda * (CntVV(0, l) + CntVV(1, l) + x) * log(CntVV(0, l) + CntVV(1, l) + x);
587  		Val += Lambda * (CntVV(2, l) + CntVV(3, l) + 1 - x) * log(CntVV(2, l) + CntVV(3, l) + (1-x));
588  		if(!(CntVV(0, l) > 0))	printf("CntVV(0, %d) = %.2f\n", l, double(CntVV(0, l)));
589  		if(!(CntVV(1, l) > 0))	printf("CntVV(1, %d) = %.2f\n", l, double(CntVV(1, l)));
590  		if(!(CntVV(2, l) > 0))	printf("CntVV(2, %d) = %.2f\n", l, double(CntVV(2, l)));
591  		if(!(CntVV(3, l) > 0))	printf("CntVV(3, %d) = %.2f\n", l, double(CntVV(3, l)));
592  	}
593  	return Val;
594  }
595  const double TMAGFitBern::GetEstNoEdgeLL(const int& NId, const int& AId) const {
596  	TMAGNodeBern DistParam = Param.GetNodeAttr();
597  	double LL = 0.0;
598  	return LL;
599  }
600  const double TMAGFitBern::UpdatePhi(const int& NId, const int& AId, double& Phi) {
601  	TMAGAffMtx LLTheta, Theta = Param.GetMtx(AId); 
602  	TMAGAffMtx SqTheta(Theta);
603  	const int NNodes = Param.GetNodes();
604  	Theta.GetLLMtx(LLTheta);
605  	TMAGNodeBern DistParam = Param.GetNodeAttr();
606  	const double Mu = DistParam.GetMu(AId);
607  	for(int i = 0; i < Theta.Len(); i++) {
608  		SqTheta.At(i) = SqTheta.At(i) * SqTheta.At(i);
609  	}
610  	double EdgeQ[2], NonEdgeQ[2], MaxExp[2];
611  	TFltV NonEdgeLLV[2];
612  	for(int i = 0; i < 2; i++) {
613  		EdgeQ[i] = 0.0;
614  		NonEdgeQ[i] = 0.0;
615  		MaxExp[i] = -DBL_MAX;
616  		NonEdgeLLV[i].Gen(4 * NNodes, 0);
617  	}
618  	for(int j = 0; j < NNodes; j++) {
619  		if(j == NId) {	continue;	}
620  		if(Graph->IsEdge(NId, j)) {
621  			EdgeQ[0] += GetOutCoeff(NId, j, AId, 0, LLTheta);
622  			EdgeQ[1] += GetOutCoeff(NId, j, AId, 1, LLTheta);
623  		} else {
624  			double LinW = GetProdLinWeight(NId, j) - GetThetaLL(NId, j, AId);
625  			double SqW = GetProdSqWeight(NId, j) - GetSqThetaLL(NId, j, AId);
626  			for(int i = 0; i < 2; i++) {
627  				NonEdgeLLV[i].Add(LinW + log(GetOutCoeff(NId, j, AId, i, Theta)));
628  				NonEdgeLLV[i].Add(SqW + log(GetOutCoeff(NId, j, AId, i, SqTheta)) + log(0.5));
629  			}
630  		}
631  		if(Graph->IsEdge(j, NId)) {
632  			EdgeQ[0] += GetInCoeff(j, NId, AId, 0, LLTheta);
633  			EdgeQ[1] += GetInCoeff(j, NId, AId, 1, LLTheta);
634  		} else {
635  			double LinW = GetProdLinWeight(j, NId) - GetThetaLL(j, NId, AId);
636  			double SqW = GetProdSqWeight(j, NId) - GetSqThetaLL(j, NId, AId);
637  			for(int i = 0; i < 2; i++) {
638  				NonEdgeLLV[i].Add(LinW + log(GetInCoeff(j, NId, AId, i, Theta)));
639  				NonEdgeLLV[i].Add(SqW + log(GetInCoeff(j, NId, AId, i, SqTheta)) + log(0.5));
640  			}
641  		}
642  	}
643  	NonEdgeQ[0] = LogSumExp(NonEdgeLLV[0]);
644  	NonEdgeQ[1] = LogSumExp(NonEdgeLLV[1]);
645  	double Q[2];
646  	Q[0] = log(Mu) + EdgeQ[0] - exp(NonEdgeQ[0]);
647  	Q[1] = log(1.0 - Mu) + EdgeQ[1] - exp(NonEdgeQ[1]);
648  	Phi = Q[0] - LogSumExp(Q, 2);
649  	Phi = exp(Phi);
650  	return Phi - PhiVV.At(NId, AId);
651  }
652  const double TMAGFitBern::UpdatePhiMI(const double& Lambda, const int& NId, const int& AId, double& Phi) {
653  	TMAGAffMtx LLTheta, Theta = Param.GetMtx(AId); 
654  	TMAGAffMtx SqTheta(Theta);
655  	const int NNodes = Param.GetNodes();
656  	const int NAttrs = Param.GetAttrs();
657  	Theta.GetLLMtx(LLTheta);
658  	TMAGNodeBern DistParam = Param.GetNodeAttr();
659  	const double Mu = DistParam.GetMu(AId);
660  	for(int i = 0; i < Theta.Len(); i++) {
661  		SqTheta.At(i) = SqTheta.At(i) * SqTheta.At(i);
662  	}
663  	double EdgeQ[2], NonEdgeQ[2], MaxExp[2];
664  	TFltV NonEdgeLLV[2];
665  	TFltVV CntVV(4, NAttrs);		CntVV.PutAll(0.0);
666  	for(int i = 0; i < 2; i++) {
667  		EdgeQ[i] = 0.0;
668  		NonEdgeQ[i] = 0.0;
669  		MaxExp[i] = -DBL_MAX;
670  		NonEdgeLLV[i].Gen(4 * NNodes, 0);
671  	}
672  	for(int j = 0; j < NNodes; j++) {
673  		if(j == NId) {	continue;	}
674  		for(int l = 0; l < NAttrs; l++) {
675  			if(l == AId) {  continue;  }
676  			CntVV(0, l) = CntVV(0, l) + PhiVV(j, AId) * PhiVV(j, l);
677  			CntVV(1, l) = CntVV(1, l) + PhiVV(j, AId) * (1.0-PhiVV(j, l));
678  			CntVV(2, l) = CntVV(2, l) + (1.0-PhiVV(j, AId)) * PhiVV(j, l);
679  			CntVV(3, l) = CntVV(3, l) + (1.0-PhiVV(j, AId)) * (1.0-PhiVV(j, l));
680  		}
681  		if(Graph->IsEdge(NId, j)) {
682  			EdgeQ[0] += GetOutCoeff(NId, j, AId, 0, LLTheta);
683  			EdgeQ[1] += GetOutCoeff(NId, j, AId, 1, LLTheta);
684  		} else {
685  			double LinW = GetProdLinWeight(NId, j) - GetThetaLL(NId, j, AId);
686  			double SqW = GetProdSqWeight(NId, j) - GetSqThetaLL(NId, j, AId);
687  			for(int i = 0; i < 2; i++) {
688  				NonEdgeLLV[i].Add(LinW + log(GetOutCoeff(NId, j, AId, i, Theta)));
689  				NonEdgeLLV[i].Add(SqW + log(GetOutCoeff(NId, j, AId, i, SqTheta)) + log(0.5));
690  			}
691  		}
692  		if(Graph->IsEdge(j, NId)) {
693  			EdgeQ[0] += GetInCoeff(j, NId, AId, 0, LLTheta);
694  			EdgeQ[1] += GetInCoeff(j, NId, AId, 1, LLTheta);
695  		} else {
696  			double LinW = GetProdLinWeight(j, NId) - GetThetaLL(j, NId, AId);
697  			double SqW = GetProdSqWeight(j, NId) - GetSqThetaLL(j, NId, AId);
698  			for(int i = 0; i < 2; i++) {
699  				NonEdgeLLV[i].Add(LinW + log(GetInCoeff(j, NId, AId, i, Theta)));
700  				NonEdgeLLV[i].Add(SqW + log(GetInCoeff(j, NId, AId, i, SqTheta)) + log(0.5));
701  			}
702  		}
703  	}
704  	NonEdgeQ[0] = LogSumExp(NonEdgeLLV[0]);
705  	NonEdgeQ[1] = LogSumExp(NonEdgeLLV[1]);
706  	double Q[2];
707  	Q[0] = log(Mu) + EdgeQ[0] - exp(NonEdgeQ[0]);
708  	Q[1] = log(1.0 - Mu) + EdgeQ[1] - exp(NonEdgeQ[1]);
709  	double DeltaQ = Q[0] - Q[1];
710  	double x[] = {PhiVV(NId, AId)};
711  	for(int n = 0; n < 1; n++) {
712  		double LrnRate = 0.001;
713  		for(int step = 0; step < 200; step++) {
714  			double Grad = GradPhiMI(x[n], NId, AId, Lambda, DeltaQ, CntVV);
715  			if(Grad > 0.0) {  x[n] += LrnRate;  }
716  			else {  x[n] -= LrnRate;  }
717  			if(x[n] > 0.9999) {  x[n] = 0.9999;  }
718  			if(x[n] < 0.0001) {  x[n] = 0.0001;  }
719  			LrnRate *= 0.995;
720  		}
721  	}
722  	double MaxVal = -DBL_MAX;
723  	int MaxX = -1;
724  	for(int n = 0; n < 1; n++) {
725  		double Val = ObjPhiMI(x[n], NId, AId, Lambda, Q[0], Q[1], CntVV);
726  		if(Val > MaxVal) {
727  			MaxVal = Val;
728  			MaxX = n;
729  		}
730  	}
731  	IAssert(MaxX >= 0);
732  	Phi = x[MaxX];
733  	return Phi - PhiVV.At(NId, AId);
734  }
735  const double TMAGFitBern::UpdateApxPhiMI(const double& Lambda, const int& NId, const int& AId, double& Phi, TFltVV& ProdVV) {
736  	TMAGAffMtx LLTheta, Theta = Param.GetMtx(AId); 
737  	const int NNodes = Param.GetNodes();
738  	const int NAttrs = Param.GetAttrs();
739  	Theta.GetLLMtx(LLTheta);
740  	TMAGNodeBern DistParam = Param.GetNodeAttr();
741  	const double Mu = DistParam.GetMu(AId);
742  	TMAGAffMtx SqTheta(Theta);
743  	for(int i = 0; i < Theta.Len(); i++) {
744  		SqTheta.At(i) = SqTheta.At(i) * SqTheta.At(i);
745  	}
746  	TFltV ProdV;	ProdVV.GetRow(NId, ProdV);
747  	ProdV[0] -= GetAvgThetaLL(NId, NId, AId, true, false);
748  	ProdV[1] -= GetAvgThetaLL(NId, NId, AId, false, true);
749  	ProdV[2] -= log(2.0) + GetAvgSqThetaLL(NId, NId, AId, true, false);
750  	ProdV[3] -= log(2.0) + GetAvgSqThetaLL(NId, NId, AId, false, true);
751  	double EdgeQ[2], MaxExp[2];
752  	TFltV NonEdgeLLV[2];
753  	TFltVV CntVV(4, NAttrs);		CntVV.PutAll(0.0);
754  	for(int i = 0; i < 2; i++) {
755  		EdgeQ[i] = 0.0;
756  		MaxExp[i] = -DBL_MAX;
757  		NonEdgeLLV[i].Gen(4 * NNodes, 0);
758  	}
759  	for(int F = 0; F < 2; F++) {
760  		NonEdgeLLV[F].Add(ProdV[0] + log(GetAvgOutCoeff(NId, AId, F, Theta)));
761  		NonEdgeLLV[F].Add(ProdV[1] + log(GetAvgInCoeff(NId, AId, F, Theta)));
762  		NonEdgeLLV[F].Add(ProdV[2] + log(GetAvgOutCoeff(NId, AId, F, SqTheta)));
763  		NonEdgeLLV[F].Add(ProdV[3] + log(GetAvgInCoeff(NId, AId, F, SqTheta)));
764  	}
765  	EdgeQ[0] = -(NNodes - 1) * exp(LogSumExp(NonEdgeLLV[0]));
766  	EdgeQ[1] = -(NNodes - 1) * exp(LogSumExp(NonEdgeLLV[1]));
767  	for(int l = 0; l < NAttrs; l++) {
768  		if(l == AId) {  continue;  }
769  		int BgId = (AId > l) ? AId : l;
770  		int SmId = (AId + l) - BgId;
771  		int SmL = (l < AId) ? 1 : 0;
772  		BgId *= 4;
773  		CntVV(0, l) = AvgPhiPairVV(SmId, BgId) - PhiVV(NId, AId) * PhiVV(NId, l);
774  		CntVV(1+SmL, l) = AvgPhiPairVV(SmId, BgId+1+SmL) - PhiVV(NId, AId) * (1.0-PhiVV(NId, l));
775  		CntVV(2-SmL, l) = AvgPhiPairVV(SmId, BgId+2-SmL) - (1.0-PhiVV(NId, AId)) * PhiVV(NId, l);
776  		CntVV(3, l) = AvgPhiPairVV(SmId, BgId+3) - (1.0-PhiVV(NId, AId)) * (1.0-PhiVV(NId, l));
777  	}
778  	TNGraph::TNodeI NI = Graph->GetNI(NId);
779  	for(int d = 0; d < NI.GetOutDeg(); d++) {
780  		int Out = NI.GetOutNId(d);
781  		if(NId == Out) {  continue;  }
782  		double LinW = GetProdLinWeight(NId, Out) - GetThetaLL(NId, Out, AId);
783  		double SqW = GetProdSqWeight(NId, Out) - GetSqThetaLL(NId, Out, AId);
784  		for(int F = 0; F < 2; F++) {
785  			EdgeQ[F] += GetOutCoeff(NId, Out, AId, F, LLTheta);
786  			EdgeQ[F] += exp(LinW + log(GetOutCoeff(NId, Out, AId, F, Theta)));
787  			EdgeQ[F] += 0.5 * exp(SqW + log(GetOutCoeff(NId, Out, AId, F, SqTheta)));
788  		}
789  	}
790  	for(int d = 0; d < NI.GetInDeg(); d++) {
791  		int In = NI.GetInNId(d);
792  		if(NId == In) {  continue;  }
793  		double LinW = GetProdLinWeight(In, NId) - GetThetaLL(In, NId, AId);
794  		double SqW = GetProdSqWeight(In, NId) - GetSqThetaLL(In, NId, AId);
795  		for(int F = 0; F < 2; F++) {
796  			EdgeQ[F] += GetInCoeff(In, NId, AId, F, LLTheta);
797  			EdgeQ[F] += exp(LinW + log(GetInCoeff(In, NId, AId, F, Theta)));
798  			EdgeQ[F] += 0.5 * exp(SqW + log(GetInCoeff(In, NId, AId, F, SqTheta)));
799  		}
800  	}
801  	EdgeQ[0] += log(Mu);
802  	EdgeQ[1] += log(1.0 - Mu);
803  	double DeltaQ = EdgeQ[0] - EdgeQ[1];
804  	double x[] = {PhiVV(NId, AId)};
805  	TFltV ObjValV;	ObjValV.Gen(60, 0);
806  	for(int n = 0; n < 1; n++) {
807  		double LrnRate = 0.001;
808  		for(int step = 0; step < 50; step++) {
809  			double Grad = GradPhiMI(x[n], NId, AId, Lambda, DeltaQ, CntVV);
810  			if(Grad > 0.0) {  x[n] += LrnRate;  }
811  			else {  x[n] -= LrnRate;  }
812  			if(x[n] > 0.9999) {  x[n] = 0.9999;  }
813  			if(x[n] < 0.0001) {  x[n] = 0.0001;  }
814  			if(x[n] == 0.9999 || x[n] == 0.0001) {
815  				break;
816  			}
817  			LrnRate *= 0.995;
818  		}
819  		ObjValV.Add(x[n]);
820  	}
821  	double MaxVal = -DBL_MAX;
822  	int MaxX = -1;
823  	for(int n = 0; n < ObjValV.Len(); n++) {
824  		double Val = ObjPhiMI(ObjValV[n], NId, AId, Lambda, EdgeQ[0], EdgeQ[1], CntVV);
825  		if(Val > MaxVal) {
826  			MaxVal = Val;
827  			MaxX = n;
828  		} else if(MaxX < 0) {
829  			printf("(%d, %d) : %f  Q[0] = %f  Q[1] = %f  Val = %f\n", NId, AId, double(x[n]), double(EdgeQ[0]), double(EdgeQ[1]), Val);
830  		}
831  	}
832  	IAssert(MaxX >= 0);
833  	Phi = ObjValV[MaxX];
834  	return Phi - PhiVV.At(NId, AId);
835  }
836  double TMAGFitBern::DoEStepOneIter(const TFltV& TrueMuV, TFltVV& NewPhiVV, const double& Lambda) {
837  	const int NNodes = Param.GetNodes();
838  	const int NAttrs = Param.GetAttrs();
839  	double MaxDelta = 0, L1 = 0;
840  	double Val;
841  	TFltIntIntTrV NewVal;
842  	int RndCount = 0;
843  	TFltV MuV(NAttrs);	MuV.PutAll(0.0);
844  	TIntV NIndV(NNodes), AIndV(NAttrs);
845  	NewVal.Gen(NAttrs * 2);
846  	for(int i = 0; i < NNodes; i++) {
847  		for(int l = 0; l < NAttrs * 2; l++) {
848  			const int NId = TMAGNodeBern::Rnd.GetUniDevInt(NNodes);
849  			const int AId = TMAGNodeBern::Rnd.GetUniDevInt(NAttrs);
850  			double Delta = 0.0;
851  			if(KnownVV(NId, AId)) {
852  				Val = PhiVV.At(NId, AId);
853  			} else {
854  				Delta = UpdatePhiMI(Lambda, NId, AId, Val);
855  			}
856  			NewVal[l] = TFltIntIntTr(Val, NId, AId);
857  			if(fabs(Delta) > MaxDelta) {
858  				MaxDelta = fabs(Delta);
859  			}
860  			if(Val > 0.3 && Val < 0.7) {	RndCount++;	}
861  		}
862  		for(int l = 0; l < NAttrs * 2; l++) {
863  			const int NId = NewVal[l].Val2;
864  			const int AId = NewVal[l].Val3;
865  			PhiVV.At(NId, AId) = NewVal[l].Val1;
866  		}
867  	}
868  	for(int i = 0; i < NNodes; i++) {
869  		for(int l = 0; l < NAttrs; l++) {
870  			MuV[l] = MuV[l] + PhiVV.At(i, l);
871  		}
872  	}
873  	for(int l = 0; l < NAttrs; l++) {
874  		MuV[l] = MuV[l] / double(NNodes);
875  	}
876  	TFltV SortMuV = MuV;
877  	double Avg = 0.0;
878  	SortMuV.Sort(false);
879  	for(int l = 0; l < NAttrs; l++) {
880  		printf("  F[%d] = %.3f", l, double(MuV[l]));
881  		Avg += SortMuV[l];
882  		L1 += fabs(TrueMuV[l] - SortMuV[l]);
883  	}
884  	printf("\n");
885  	printf("  Rnd = %d(%.3f)", RndCount, double(RndCount) / double(NNodes * NAttrs));
886  	printf("  Avg = %.3f\n", Avg / double(NAttrs));
887  	L1 /= double(NAttrs);
888  	return L1;
889  }
890  double TMAGFitBern::DoEStepApxOneIter(const TFltV& TrueMuV, TFltVV& NewPhiVV, const double& Lambda) {
891  	const int NNodes = Param.GetNodes();
892  	const int NAttrs = Param.GetAttrs();
893  	double MaxDelta = 0, L1 = 0;
894  	double Val;
895  	TFltIntIntTrV NewVal;
896  	int RndCount = 0;
897  	TFltV MuV(NAttrs);	MuV.PutAll(0.0);
898  	TFltVV ProdVV(NNodes, 4);	ProdVV.PutAll(0.0);
899  	TIntV NIndV(NNodes), AIndV(NAttrs);
900  	AvgPhiV.Gen(NAttrs);	AvgPhiV.PutAll(0.0);
901  	AvgPhiPairVV.Gen(NAttrs, 4*NAttrs);		AvgPhiPairVV.PutAll(0.0);
902  	for(int i = 0; i < NNodes; i++) {
903  		for(int l = 0; l < NAttrs; l++) {
904  			for(int p = l+1; p < NAttrs; p++) {
905  				int index = 4 * p;
906  				AvgPhiPairVV(l, index) += PhiVV(i, l) * PhiVV(i, p);
907  				AvgPhiPairVV(l, index+1) += PhiVV(i, l) * (1.0-PhiVV(i, p));
908  				AvgPhiPairVV(l, index+2) += (1.0-PhiVV(i, l)) * PhiVV(i, p);
909  				AvgPhiPairVV(l, index+3) += (1.0-PhiVV(i, l)) * (1.0-PhiVV(i, p));
910  			}
911  			AvgPhiV[l] += PhiVV(i, l);
912  		}
913  	}
914  	for(int i = 0; i < NNodes; i++) {
915  		ProdVV(i, 0) = GetAvgProdLinWeight(i, i, true, false);
916  		ProdVV(i, 1) = GetAvgProdLinWeight(i, i, false, true);
917  		ProdVV(i, 2) = GetAvgProdSqWeight(i, i, true, false);
918  		ProdVV(i, 3) = GetAvgProdSqWeight(i, i, false, true);
919  	}
920  	const int Iter = 3;
921  	NewVal.Gen(NAttrs * Iter);
922  	for(int i = 0; i < NNodes * Iter; i++) {
923  		for(int l = 0; l < NAttrs; l++) {
924  			const int NId = TMAGNodeBern::Rnd.GetUniDevInt(NNodes);
925  			const int AId = TMAGNodeBern::Rnd.GetUniDevInt(NAttrs);
926  			double Delta = 0.0;
927  			if(KnownVV(NId, AId)) {
928  				Val = PhiVV.At(NId, AId);
929  			} else {
930  				Delta = UpdateApxPhiMI(Lambda, NId, AId, Val, ProdVV);
931  			}
932  			NewVal[l] = TFltIntIntTr(Val, NId, AId);
933  			if(fabs(Delta) > MaxDelta) {
934  				MaxDelta = fabs(Delta);
935  			}
936  			if(Val > 0.3 && Val < 0.7) {	RndCount++;	}
937  		}
938  		for(int l = 0; l < NAttrs; l++) {
939  			const int NId = NewVal[l].Val2;
940  			const int AId = NewVal[l].Val3;
941  			ProdVV(NId, 0) -= GetAvgThetaLL(NId, NId, AId, true, false);
942  			ProdVV(NId, 1) -= GetAvgThetaLL(NId, NId, AId, false, true);
943  			ProdVV(NId, 2) -= GetAvgSqThetaLL(NId, NId, AId, true, false);
944  			ProdVV(NId, 3) -= GetAvgSqThetaLL(NId, NId, AId, false, true);
945  			for(int p = 0; p < NAttrs; p++) {
946  				if(p > AId) {
947  					int index = 4 * p;
948  					AvgPhiPairVV(AId, index) -= PhiVV(NId, AId) * PhiVV(NId, p);
949  					AvgPhiPairVV(AId, index+1) -= PhiVV(NId, AId) * (1.0-PhiVV(NId, p));
950  					AvgPhiPairVV(AId, index+2) -= (1.0-PhiVV(NId, AId)) * PhiVV(NId, p);
951  					AvgPhiPairVV(AId, index+3) -= (1.0-PhiVV(NId, AId)) * (1.0-PhiVV(NId, p));
952  				} else if (p < AId) {
953  					int index = 4 * AId;
954  					AvgPhiPairVV(p, index) -= PhiVV(NId, p) * PhiVV(NId, AId);
955  					AvgPhiPairVV(p, index+1) -= PhiVV(NId, p) * (1.0-PhiVV(NId, AId));
956  					AvgPhiPairVV(p, index+2) -= (1.0-PhiVV(NId, p)) * PhiVV(NId, AId);
957  					AvgPhiPairVV(p, index+3) -= (1.0-PhiVV(NId, p)) * (1.0-PhiVV(NId, AId));
958  				}
959  			}
960  			AvgPhiV[AId] -= PhiVV(NId, AId);
961  			PhiVV.At(NId, AId) = NewVal[l].Val1;
962  			ProdVV(NId, 0) += GetAvgThetaLL(NId, NId, AId, true, false);
963  			ProdVV(NId, 1) += GetAvgThetaLL(NId, NId, AId, false, true);
964  			ProdVV(NId, 2) += GetAvgSqThetaLL(NId, NId, AId, true, false);
965  			ProdVV(NId, 3) += GetAvgSqThetaLL(NId, NId, AId, false, true);
966  			for(int p = 0; p < NAttrs; p++) {
967  				if(p > AId) {
968  					int index = 4 * p;
969  					AvgPhiPairVV(AId, index) += PhiVV(NId, AId) * PhiVV(NId, p);
970  					AvgPhiPairVV(AId, index+1) += PhiVV(NId, AId) * (1.0-PhiVV(NId, p));
971  					AvgPhiPairVV(AId, index+2) += (1.0-PhiVV(NId, AId)) * PhiVV(NId, p);
972  					AvgPhiPairVV(AId, index+3) += (1.0-PhiVV(NId, AId)) * (1.0-PhiVV(NId, p));
973  				} else if (p < AId) {
974  					int index = 4 * AId;
975  					AvgPhiPairVV(p, index) += PhiVV(NId, p) * PhiVV(NId, AId);
976  					AvgPhiPairVV(p, index+1) += PhiVV(NId, p) * (1.0-PhiVV(NId, AId));
977  					AvgPhiPairVV(p, index+2) += (1.0-PhiVV(NId, p)) * PhiVV(NId, AId);
978  					AvgPhiPairVV(p, index+3) += (1.0-PhiVV(NId, p)) * (1.0-PhiVV(NId, AId));
979  				}
980  			}
981  			AvgPhiV[AId] += PhiVV(NId, AId);
982  		}
983  	}
984  	for(int l = 0; l < NAttrs; l++) {
985  		MuV[l] = AvgPhiV[l] / double(NNodes);
986  	}
987  	TFltV SortMuV = MuV;
988  	double Avg = 0.0;
989  	for(int l = 0; l < NAttrs; l++) {
990  		printf("  F[%d] = %.3f", l, double(MuV[l]));
991  		Avg += SortMuV[l];
992  	}
993  	printf("\n");
994  	printf("  Rnd = %d(%.3f)", RndCount, double(RndCount) / double(NNodes * NAttrs));
995  	printf("  Avg = %.3f\n", Avg / double(NAttrs));
996  	return L1;
997  }
998  double TMAGFitBern::DoEStep(const TFltV& TrueMuV, const int& NIter, double& LL, const double& Lambda) {
999  	const int NNodes = Param.GetNodes();
1000  	const int NAttrs = Param.GetAttrs();
1001  	TFltVV NewPhiVV(NNodes, NAttrs);
1002  	TFltV Delta(NIter);
1003  	for(int i = 0; i < NIter; i++) {
1004  		TExeTm IterTm;
1005  		printf("EStep iteration : %d\n", (i+1));
1006  		if(ESpeedUp) {
1007  			Delta[i] = DoEStepApxOneIter(TrueMuV, NewPhiVV, Lambda);
1008  		} else {
1009  			Delta[i] = DoEStepOneIter(TrueMuV, NewPhiVV, Lambda);
1010  		}
1011  		printf("  (Time = %s)\n", IterTm.GetTmStr());
1012  	}
1013  	printf("\n");
1014  	NewPhiVV.Clr();
1015  	return Delta.Last();
1016  }
1017  const double TMAGFitBern::UpdateMu(const int& AId) {
1018  	const int NNodes = Param.GetNodes();
1019  	TMAGNodeBern DistParam = Param.GetNodeAttr();
1020  	const double OldMu = DistParam.GetMu(AId);
1021  	double NewMu = 0.0;
1022  	for(int i = 0; i < NNodes; i++) {
1023  		NewMu += PhiVV.At(i, AId);
1024  	}
1025  	AvgPhiV[AId] = NewMu;
1026  	NewMu /= double(NNodes);
1027  	printf("      [Posterior Mu] = %.4f\n", NewMu);
1028  	double Delta = fabs(NewMu - OldMu);
1029  	DistParam.SetMu(AId, NewMu);
1030  	Param.SetNodeAttr(DistParam);
1031  	return Delta;
1032  }
1033  const void TMAGFitBern::GradAffMtx(const int& AId, const TFltVV& ProdVV, const TFltVV& SqVV, const TMAGAffMtx& CurMtx, TFltV& GradV) {
1034  	const int NNodes = Param.GetNodes();
1035  	GradV.PutAll(0.0);
1036  	for(int i = 0; i < NNodes; i++) {
1037  		for(int j = 0; j < NNodes; j++) {
1038  			double Prod = ProdVV(i, j) - GetThetaLL(i, j, AId);
1039  			double Sq = SqVV(i, j) - GetSqThetaLL(i, j, AId);
1040  			for(int p = 0; p < 4; p++) {
1041  				int Ai = p / 2;
1042  				int Aj = p % 2;
1043  				double Prob = GetProbPhi(i, j, AId, Ai, Aj);
1044  				if(Graph->IsEdge(i, j)) {
1045  					GradV[p] += Prob / CurMtx.At(p);
1046  				} else {
1047  					GradV[p] -= Prob * exp(Prod);
1048  					GradV[p] -= Prob * exp(Sq) * CurMtx.At(p);
1049  				}
1050  			}
1051  		}
1052  	}
1053  }
1054  const void TMAGFitBern::GradApxAffMtx(const int& AId, const TFltVV& ProdVV, const TFltVV& SqVV, const TMAGAffMtx& CurMtx, TFltV& GradV) {
1055  	const int NNodes = Param.GetNodes();
1056  	GradV.PutAll(0.0);
1057  	TFltV LogSumV;
1058  	for(int p = 0; p < 4; p++) {
1059  		int Ai = p / 2;
<span onclick='openModal()' class='match'>1060  		int Aj = p % 2;
1061  		LogSumV.Gen(NNodes * 4, 0);
1062  		for(int i = 0; i < NNodes; i++) {
1063  			const double LProd = ProdVV(i, 0) - GetAvgThetaLL(i, i, AId, true, false);
</span>1064  			const double LSq = SqVV(i, 0) - GetAvgSqThetaLL(i, i, AId, true, false);
1065  			const double RProd = ProdVV(i, 1) - GetAvgThetaLL(i, i, AId, false, true);
1066  			const double RSq = SqVV(i, 1) - GetAvgSqThetaLL(i, i, AId, false, true);
1067  			LogSumV.Add(LProd + log(GetProbMu(i, i, AId, Ai, Aj, true, false)));
1068  			LogSumV.Add(LSq + log(GetProbMu(i, i, AId, Ai, Aj, true, false)) + log(CurMtx.At(p)));
1069  			LogSumV.Add(RProd + log(GetProbMu(i, i, AId, Ai, Aj, false, true)));
1070  			LogSumV.Add(RSq + log(GetProbMu(i, i, AId, Ai, Aj, false, true)) + log(CurMtx.At(p)));
1071  		}
1072  		double LogSum = LogSumExp(LogSumV);
1073  		GradV[p] -= (NNodes - 1) * 0.5 * exp(LogSum);
1074  	}
1075  	for(TNGraph::TEdgeI EI = Graph->BegEI(); EI < Graph->EndEI(); EI++) {
1076  		const int NId1 = EI.GetSrcNId();
1077  		const int NId2 = EI.GetDstNId();
1078  		const double ProdOne = GetProdLinWeight(NId1, NId2) - GetThetaLL(NId1, NId2, AId);
1079  		const double SqOne = GetProdSqWeight(NId1, NId2) - GetSqThetaLL(NId1, NId2, AId);
1080  		for(int p = 0; p < 4; p++) {
1081  			int Ai = p / 2;
1082  			int Aj = p % 2;
1083  			double Prob = GetProbPhi(NId1, NId2, AId, Ai, Aj);
1084  			GradV[p] += Prob / CurMtx.At(p);
1085  			GradV[p] += Prob * exp(ProdOne);
1086  			GradV[p] += Prob * exp(SqOne) * CurMtx.At(p);
1087  		}
1088  	}
1089  #if 0
1090  	const double Prod = ProdVV(0, 0) - GetAvgThetaLL(0, 0, AId, false, false);
1091  	const double Sq = SqVV(0, 0) - GetAvgSqThetaLL(0, 0, AId, false, false);
1092  	for(int p = 0; p < 4; p++) {
1093  		int Ai = p / 2;
1094  		int Aj = p % 2;
1095  		GradV[p] -= NSq * exp(Prod) * GetProbMu(0, 0, AId, Ai, Aj, false, false);
1096  		GradV[p] -= NSq * exp(Sq) * GetProbMu(0, 0, AId, Ai, Aj, false, false) * CurMtx.At(p);
1097  	}
1098  	for(TNGraph::TEdgeI EI = Graph->BegEI(); EI < Graph->EndEI(); EI++) {
1099  		const int NId1 = EI.GetSrcNId();
1100  		const int NId2 = EI.GetDstNId();
1101  		const double ProdOne = GetProdLinWeight(NId1, NId2) - GetThetaLL(NId1, NId2, AId);
1102  		const double SqOne = GetProdSqWeight(NId1, NId2) - GetSqThetaLL(NId1, NId2, AId);
1103  		for(int p = 0; p < 4; p++) {
1104  			int Ai = p / 2;
1105  			int Aj = p % 2;
1106  			double Prob = GetProbPhi(NId1, NId2, AId, Ai, Aj);
1107  		}
1108  	}
1109  #endif
1110  }
1111  const double TMAGFitBern::UpdateAffMtx(const int& AId, const double& LrnRate, const double& MaxGrad, const double& Lambda, TFltVV& ProdVV, TFltVV& SqVV, TMAGAffMtx& NewMtx) {
1112  	double Delta = 0.0;
1113  	TMAGAffMtx AffMtx = Param.GetMtx(AId);
1114  	TFltV GradV(4);
1115  	TFltV HessV(4);
1116  	if(MSpeedUp) {
1117  		GradApxAffMtx(AId, ProdVV, SqVV, NewMtx, GradV);
1118  	} else {
1119  		GradAffMtx(AId, ProdVV, SqVV, NewMtx, GradV);
1120  	}
1121  	double Ratio = 1.0;
1122  	for(int p = 0; p < 4; p++) {
1123  		if(fabs(Ratio * LrnRate * GradV[p]) > MaxGrad) {
1124  			Ratio = MaxGrad / fabs(LrnRate * GradV[p]);
1125  		}
1126  	}
1127  	for(int p = 0; p < 4; p++) {
1128  		GradV[p] *= (Ratio * LrnRate);
1129  		NewMtx.At(p) = AffMtx.At(p) + GradV[p];
1130  		if(NewMtx.At(p) < 0.0001) {  NewMtx.At(p) = 0.0001;  }
1131  	}
1132  	printf("      [Attr = %d]\n", AId);
1133      printf("        %s  + [%f, %f; %f %f]  ----->  %s\n", (AffMtx.GetMtxStr()).GetCStr(), double(GradV[0]), double(GradV[1]), double(GradV[2]), double(GradV[3]), (NewMtx.GetMtxStr()).GetCStr());
1134  	return Delta;
1135  }
1136  void TMAGFitBern::NormalizeAffMtxV(TMAGAffMtxV& MtxV, const bool UseMu) {
1137  	const int NNodes = Param.GetNodes();
1138  	const int NAttrs = MtxV.Len();
1139  	TFltV MuV = GetMuV();
1140  	double Product = 1.0, ExpEdge = NNodes * (NNodes - 1);
1141  	TFltV SumV(NAttrs), EdgeSumV(NAttrs);
1142  	SumV.PutAll(0.0);	EdgeSumV.PutAll(0.0);
1143  	for(int l = 0; l < NAttrs; l++) {
1144  		double Mu = (UseMu) ? double(MuV[l]) : (AvgPhiV[l] / double(NNodes));
1145  		EdgeSumV[l] += Mu * Mu * MtxV[l].At(0, 0);
1146  		EdgeSumV[l] += Mu * (1.0-Mu) * MtxV[l].At(0, 1);
1147  		EdgeSumV[l] += Mu * (1.0-Mu) * MtxV[l].At(1, 0);
1148  		EdgeSumV[l] += (1.0-Mu) * (1.0-Mu) * MtxV[l].At(1, 1);
1149  		SumV[l] = SumV[l] + MtxV[l].At(0, 0);
1150  		SumV[l] = SumV[l] + MtxV[l].At(0, 1);
1151  		SumV[l] = SumV[l] + MtxV[l].At(1, 0);
1152  		SumV[l] = SumV[l] + MtxV[l].At(1, 1);
1153  		Product *= SumV[l];
1154  		ExpEdge *= EdgeSumV[l];
1155  	}
1156  	ExpEdge = Graph->GetEdges() / ExpEdge;
1157  	NormConst *= Product;
1158  	Product = 1.0;
1159  	for(int l = 0; l < NAttrs; l++) {
1160  		for(int p = 0; p < 4; p++) {
1161  			MtxV[l].At(p) = MtxV[l].At(p) * Product / SumV[l];
1162  		}
1163  	}
1164  }
1165  void TMAGFitBern::UnNormalizeAffMtxV(TMAGAffMtxV& MtxV, const bool UseMu) {
1166  	const int NNodes = Param.GetNodes();
1167  	const int NAttrs = MtxV.Len();
1168  	TFltIntPrV MaxEntV(NAttrs);
1169  	TFltV MuV = GetMuV();
1170  	NormalizeAffMtxV(MtxV, UseMu);
1171  	double ExpEdge = NNodes * (NNodes - 1);
1172  	for(int l = 0; l < NAttrs; l++) {
1173  		double Mu = MuV[l];
1174  		double EdgeSum = Mu * Mu * MtxV[l].At(0, 0);
1175  		EdgeSum += Mu * (1.0-Mu) * MtxV[l].At(0, 1);
1176  		EdgeSum += Mu * (1.0-Mu) * MtxV[l].At(1, 0);
1177  		EdgeSum += (1.0-Mu) * (1.0-Mu) * MtxV[l].At(1, 1);
1178  		ExpEdge *= EdgeSum;
1179  	}
1180  	NormConst = double(Graph->GetEdges()) / ExpEdge;
1181  	for(int l = 0; l < NAttrs; l++) {
1182  		MaxEntV[l] = TFltIntPr(-1, l);
1183  		for(int p = 0; p < 4; p++) {
1184  			if(MaxEntV[l].Val1 < MtxV[l].At(p)) {  MaxEntV[l].Val1 = MtxV[l].At(p);  }
1185  		}
1186  	}
1187  	MaxEntV.Sort(false);
1188  	for(int l = 0; l < NAttrs; l++) {
1189  		int CurId = MaxEntV[l].Val2;
1190  		double Factor = pow(NormConst, 1.0 / double(NAttrs - l));
1191  		double MaxFactor = 0.9999 / MaxEntV[l].Val1;
1192  		Factor = (Factor > MaxFactor) ? MaxFactor : Factor;
1193  		NormConst = NormConst / Factor;
1194  		for(int p = 0; p < 4; p++) {
1195  			MtxV[CurId].At(p) = MtxV[CurId].At(p) * Factor;
1196  		}
1197  	}
1198  }
1199  const void TMAGFitBern::PrepareUpdateAffMtx(TFltVV& ProdVV, TFltVV& SqVV) {
1200  	const int NNodes = Param.GetNodes();
1201  	ProdVV.Gen(NNodes, NNodes);
1202  	SqVV.Gen(NNodes, NNodes);
1203  	for(int i = 0; i < NNodes; i++) {
1204  		for(int j = 0; j < NNodes; j++) {
1205  			ProdVV(i, j) = GetProdLinWeight(i, j);
1206  			SqVV(i, j) = GetProdSqWeight(i, j);
1207  		}
1208  	}
1209  }
1210  const void TMAGFitBern::PrepareUpdateApxAffMtx(TFltVV& ProdVV, TFltVV& SqVV) {
1211  	const int NNodes = Param.GetNodes();
1212  	ProdVV.Gen(NNodes, 2);
1213  	SqVV.Gen(NNodes, 2);
1214  	for(int i = 0; i < NNodes; i++) {
1215  		ProdVV(i, 0) = GetAvgProdLinWeight(i, i, true, false);
1216  		ProdVV(i, 1) = GetAvgProdLinWeight(i, i, false, true);
1217  		SqVV(i, 0) = GetAvgProdSqWeight(i, i, true, false);
1218  		SqVV(i, 1) = GetAvgProdSqWeight(i, i, false, true);
1219  	}
1220  }
1221  const double TMAGFitBern::UpdateAffMtxV(const int& GradIter, const double& LrnRate, const double& MaxGrad, const double& Lambda, const int& NReal) {
1222  	const int NNodes = Param.GetNodes();
1223  	const int NAttrs = Param.GetAttrs();
1224  	const TMAGNodeBern DistParam = Param.GetNodeAttr();
1225  	const TFltV MuV = DistParam.GetMuV();
1226  	double Delta = 0.0;
1227  	double DecLrnRate = LrnRate, DecMaxGrad = MaxGrad;
1228  	TFltVV ProdVV(NNodes, NNodes), SqVV(NNodes, NNodes);
1229  	TMAGAffMtxV NewMtxV, OldMtxV;
1230  	Param.GetMtxV(OldMtxV);
1231  	Param.GetMtxV(NewMtxV);
1232  	for(int g = 0; g < GradIter; g++) {
1233  		if(MSpeedUp) {
1234  			PrepareUpdateApxAffMtx(ProdVV, SqVV);
1235  		} else {
1236  			PrepareUpdateAffMtx(ProdVV, SqVV);
1237  		}
1238  		printf("    [Grad step = %d]\n", (g+1));
1239  		for(int l = NReal; l < NAttrs; l++) {
1240  			UpdateAffMtx(l, DecLrnRate, DecMaxGrad, Lambda, ProdVV, SqVV, NewMtxV[l]);
1241  			Param.SetMtxV(NewMtxV);
1242  		}
1243  		DecLrnRate *= 0.97;
1244  		DecMaxGrad *= 0.97;
1245  		printf("\n");
1246  		NormalizeAffMtxV(NewMtxV, true);
1247  		Param.SetMtxV(NewMtxV);
1248  	}
1249  	NormalizeAffMtxV(NewMtxV, true);
1250  	printf( "\nFinal\n");
1251  	for(int l = 0; l < NAttrs; l++) {
1252  		printf("    [");
1253  		for(int p = 0; p < 4; p++) {
1254  			Delta += fabs(OldMtxV[l].At(p) - NewMtxV[l].At(p));
1255  			printf(" %.4f ", double(NewMtxV[l].At(p)));
1256  		}
1257  		printf("]\n");
1258  	}
1259  	Param.SetMtxV(NewMtxV);
1260  	ProdVV.Clr();		SqVV.Clr();
1261  	return Delta;
1262  }
1263  void TMAGFitBern::DoMStep(const int& GradIter, const double& LrnRate, const double& MaxGrad, const double& Lambda, const int& NReal) {
1264  	const int NAttrs = Param.GetAttrs();
1265  	double MuDelta = 0.0, AffMtxDelta = 0.0;
1266  	TExeTm ExeTm;
1267  	printf("\n");
1268  	AvgPhiV.Gen(NAttrs);	AvgPhiV.PutAll(0.0);
1269  	for(int l = 0; l < NAttrs; l++) {
1270  		MuDelta += UpdateMu(l);
1271  	}
1272  	printf("\n");
1273  	printf("  == Update Theta\n");
1274  	AffMtxDelta += UpdateAffMtxV(GradIter, LrnRate, MaxGrad, Lambda, NReal);
1275  	printf("\n");
1276  	printf("Elpased time = %s\n", ExeTm.GetTmStr());
1277  	printf("\n");
1278  }
1279  void TMAGFitBern::DoEMAlg(const int& NStep, const int& NEstep, const int& NMstep, const double& LrnRate, const double& MaxGrad, const double& Lambda, const double& ReInit, const int& NReal) {
1280  	const int NNodes = Param.GetNodes();
1281  	const int NAttrs = Param.GetAttrs();
1282  	TIntV IndexV;
1283  	double LL;
1284  	MuHisV.Gen(NStep + 1, 0);
1285  	MtxHisV.Gen(NStep + 1, 0);
1286  	LLHisV.Gen(NStep + 1, 0);
1287  	printf("--------------------------------------------\n");
1288  	printf("Before EM Iteration\n");
1289  	printf("--------------------------------------------\n");
1290  	TMAGAffMtxV InitMtxV;
1291  	TMAGNodeBern NodeAttr = Param.GetNodeAttr();
1292  	Param.GetMtxV(InitMtxV);
1293  	TFltV InitMuV = NodeAttr.GetMuV();
1294  	for(int i = 0; i < NNodes; i++) {
1295  		for(int l = 0; l < NAttrs; l++) {
1296  			if(! KnownVV(i, l)) {
1297  				PhiVV.At(i, l) = TMAGNodeBern::Rnd.GetUniDev();
1298  			}
1299  		}
1300  	}
1301  	if(Debug) {
1302  		double LL = ComputeApxLL();
1303  		MuHisV.Add(InitMuV);
1304  		MtxHisV.Add(InitMtxV);
1305  		LLHisV.Add(LL);
1306  	}
1307  	NormalizeAffMtxV(InitMtxV, true);
1308  	Param.SetMtxV(InitMtxV);
1309  	for(int n = 0; n < NStep; n++) {
1310  		printf("--------------------------------------------\n");
1311  		printf("EM Iteration : %d\n", (n+1));
1312  		printf("--------------------------------------------\n");
1313  		NodeAttr = Param.GetNodeAttr();
1314  		for(int i = 0; i < NNodes; i++) {
1315  			for(int l = 0; l < NAttrs; l++) {
1316  				if(!KnownVV(i, l) && TMAGNodeBern::Rnd.GetUniDev() < ReInit) {
1317  					PhiVV.At(i, l) = TMAGNodeBern::Rnd.GetUniDev();
1318  				}
1319  			}
1320  		}
1321  		DoEStep(InitMuV, NEstep, LL, Lambda);
1322  		Param.GetMtxV(InitMtxV);
1323  		Param.SetMtxV(InitMtxV);
1324  		DoMStep(NMstep, LrnRate, MaxGrad, Lambda, NReal);
1325  		printf("\n");
1326  		if(Debug) {
1327  			double LL = ComputeApxLL();
1328  			MuHisV.Add(InitMuV);
1329  			MtxHisV.Add(InitMtxV);
1330  			LLHisV.Add(LL);
1331  			printf("    ApxLL = %.2f (Const = %f)\n", LL, double(NormConst));
1332  		}
1333  	}
1334  	Param.GetMtxV(InitMtxV);
1335  	UnNormalizeAffMtxV(InitMtxV, true);
1336  	Param.SetMtxV(InitMtxV);
1337  }
1338  void TMAGFitBern::MakeCCDF(const TFltPrV& RawV, TFltPrV& CcdfV) {
1339  	double Total = 0.0;
1340  	CcdfV.Gen(RawV.Len(), 0);
1341  	for(int i = 0; i < RawV.Len(); i++) {
1342  		if(RawV[i].Val2 <= 0) {  continue;  }
1343  		Total += RawV[i].Val2;
1344  		CcdfV.Add(RawV[i]);
1345  		IAssert(RawV[i].Val2 > 0);
1346  	}
1347  	for(int i = 1; i < CcdfV.Len(); i++) {
1348  		CcdfV[i].Val2 += CcdfV[i-1].Val2;
1349  	}
1350  	for(int i = CcdfV.Len() - 1; i > 0; i--) {
1351  		CcdfV[i].Val2 = (Total - CcdfV[i-1].Val2) ;
1352  		if(CcdfV[i].Val2 <= 0) {  printf("CCDF = %f\n", double(CcdfV[i].Val2));}
1353  		IAssert(CcdfV[i].Val2 > 0);
1354  	}
1355  	CcdfV[0].Val2 = Total;
1356  }
1357  void TMAGFitBern::PlotProperties(const TStr& FNm) {
1358  	const int NNodes = Param.GetNodes();
1359  	const int NAttrs = Param.GetAttrs();
1360  	TMAGParam<TMAGNodeBern> MAGGen(NNodes, NAttrs);
1361  	TMAGNodeBern MAGNode = Param.GetNodeAttr();
1362  	MAGGen.SetNodeAttr(MAGNode);
1363  	TMAGAffMtxV MtxV;	Param.GetMtxV(MtxV);
1364  	MAGGen.SetMtxV(MtxV);
1365  	PNGraph TrG = new TNGraph;
1366  	*TrG = *Graph;
1367  	TIntVV AttrVV(NNodes, NAttrs);
1368  	for(int i = 0; i < NNodes; i++) {
1369  		for(int j = 0; j < NAttrs; j++) {
1370  			if(PhiVV(i, j) > TMAGNodeBern::Rnd.GetUniDev())	AttrVV(i, j) = 0;
1371  			else AttrVV(i, j) = 1;
1372  		}
1373  	}
1374  	PNGraph MAG = MAGGen.GenMAG(AttrVV, true, 10000);
1375  	printf("%d edges created for MAG...\n", MAG->GetEdges());
1376  	TSnap::DelZeroDegNodes(TrG);
1377  	TSnap::DelZeroDegNodes(MAG);
1378  	TGStatVec GS(tmuNodes, TFSet() | gsdInDeg | gsdOutDeg | gsdWcc | gsdHops | gsdClustCf | gsdSngVec | gsdSngVal | gsdTriadPart);
1379      TGnuPlot InDegP(FNm + "-InDeg"), OutDegP(FNm + "-OutDeg"), SvalP(FNm + "-Sval"), SvecP(FNm + "-Svec"), WccP(FNm + "-Wcc"), HopP(FNm + "-Hop"), TriadP(FNm + "-Triad"), CcfP(FNm + "-Ccf");;
1380      InDegP.SetXYLabel("Degree", "# of nodes");
1381      OutDegP.SetXYLabel("Degree", "# of nodes");
1382      SvalP.SetXYLabel("Rank", "Singular value");
1383      SvecP.SetXYLabel("Rank", "Primary SngVec component");
1384      WccP.SetXYLabel("Size of component", "# of components");
1385      CcfP.SetXYLabel("Degree", "Clustering coefficient");
1386      HopP.SetXYLabel("Hops", "# of node pairs");
1387      TriadP.SetXYLabel("# of triads", "# of participating nodes");
1388      InDegP.SetScale(gpsLog10XY);    InDegP.AddCmd("set key top right");
1389      OutDegP.SetScale(gpsLog10XY);   OutDegP.AddCmd("set key top right");
1390      SvalP.SetScale(gpsLog10XY);     SvalP.AddCmd("set key top right");
1391      SvecP.SetScale(gpsLog10XY);     SvecP.AddCmd("set key top right");
1392      CcfP.SetScale(gpsLog10XY);      CcfP.AddCmd("set key top right");
1393      HopP.SetScale(gpsLog10XY);      HopP.AddCmd("set key top right");
1394      TriadP.SetScale(gpsLog10XY);    TriadP.AddCmd("set key top right");
1395  	InDegP.ShowGrid(false);
1396  	OutDegP.ShowGrid(false);
1397  	SvalP.ShowGrid(false);
1398  	SvecP.ShowGrid(false);
1399  	CcfP.ShowGrid(false);
1400  	HopP.ShowGrid(false);
1401  	TriadP.ShowGrid(false);
1402  	const TStr Style[2] = {"lt 1 lw 3 lc rgb 'black'", "lt 2 lw 3 lc rgb 'red'"};
1403  	const TStr Name[2] = {"Real", "MAG"};
1404  	GS.Add(Graph, TSecTm(1), "Real Graph");
1405  	GS.Add(MAG, TSecTm(2), "MAG");
1406  	TFltPrV InDegV, OutDegV, SvalV, SvecV, HopV, WccV, CcfV, TriadV;
1407  	for(int i = 0; i < GS.Len(); i++) {
1408  		MakeCCDF(GS.At(i)->GetDistr(gsdInDeg), InDegV);
1409  		MakeCCDF(GS.At(i)->GetDistr(gsdOutDeg), OutDegV);
1410  		SvalV = GS.At(i)->GetDistr(gsdSngVal);
1411  		SvecV = GS.At(i)->GetDistr(gsdSngVec);
1412  		MakeCCDF(GS.At(i)->GetDistr(gsdClustCf), CcfV);
1413  		HopV = GS.At(i)->GetDistr(gsdHops);
1414  		MakeCCDF(GS.At(i)->GetDistr(gsdTriadPart), TriadV);
1415  		InDegP.AddPlot(InDegV, gpwLines, Name[i], Style[i]);
1416  		OutDegP.AddPlot(OutDegV, gpwLines, Name[i], Style[i]);
1417  		SvalP.AddPlot(SvalV, gpwLines, Name[i], Style[i]);
1418  		SvecP.AddPlot(SvecV, gpwLines, Name[i], Style[i]);
1419  		CcfP.AddPlot(CcfV, gpwLines, Name[i], Style[i]);
1420  		HopP.AddPlot(HopV, gpwLines, Name[i], Style[i]);
1421  		TriadP.AddPlot(TriadV, gpwLines, Name[i], Style[i]);
1422  	}
1423  	InDegP.SaveEps(30);
1424  	OutDegP.SaveEps(30);
1425  	SvalP.SaveEps(30);
1426  	SvecP.SaveEps(30);
1427  	CcfP.SaveEps(30);
1428  	HopP.SaveEps(30);
1429  	TriadP.SaveEps(30);
1430  }
1431  void TMAGFitBern::CountAttr(TFltV& EstMuV) const {
1432  	const int NNodes = PhiVV.GetXDim();
1433  	const int NAttrs = PhiVV.GetYDim();
1434  	EstMuV.Gen(NAttrs);
1435  	EstMuV.PutAll(0.0);
1436  	for(int l = 0; l < NAttrs; l++) {
1437  		for(int i = 0; i < NNodes; i++) {
1438  			EstMuV[l] = EstMuV[l] + PhiVV(i, l);
1439  		}
1440  		EstMuV[l] = EstMuV[l] / double(NNodes);
1441  	}
1442  }
1443  void TMAGFitBern::SortAttrOrdering(const TFltV& TrueMuV, TIntV& IndexV) const {
1444  	const int NAttrs = TrueMuV.Len();
1445  	TFltV EstMuV, SortedTrueMuV, SortedEstMuV, TrueIdxV, EstIdxV;
1446  	IndexV.Gen(NAttrs);
1447  	TrueIdxV.Gen(NAttrs);
1448  	EstIdxV.Gen(NAttrs);
1449  	for(int l = 0; l < NAttrs; l++) {
1450  		TrueIdxV[l] = l;
1451  		EstIdxV[l] = l;
1452  	}
1453  	CountAttr(EstMuV);
1454  	SortedTrueMuV = TrueMuV;
1455  	SortedEstMuV = EstMuV;
1456  	for(int i = 0; i < NAttrs; i++) {
1457  		if(SortedTrueMuV[i] > 0.5) {  SortedTrueMuV[i] = 1.0 - SortedTrueMuV[i];  }
1458  		if(SortedEstMuV[i] > 0.5) {  SortedEstMuV[i] = 1.0 - SortedEstMuV[i];  }
1459  	}
1460  	for(int i = 0; i < NAttrs; i++) {
1461  		for(int j = i+1; j < NAttrs; j++) {
1462  			if(SortedTrueMuV[i] < SortedTrueMuV[j]) {
1463  				SortedTrueMuV.Swap(i, j);
1464  				TrueIdxV.Swap(i, j);
1465  			}
1466  			if(SortedEstMuV[i] < SortedEstMuV[j]) {
1467  				EstIdxV.Swap((int)SortedEstMuV[i], (int)SortedEstMuV[j]);
1468  				SortedEstMuV.Swap(i, j);
1469  			}
1470  		}
1471  	}
1472  	for(int l = 0; l < NAttrs; l++) {
1473  		IndexV[l] = (int)TrueIdxV[(int)EstIdxV[l]];
1474  	}
1475  }
1476  const bool TMAGFitBern::NextPermutation(TIntV& IndexV) const {
1477  	const int NAttrs = IndexV.Len();
1478  	int Pos = NAttrs - 1;
1479  	while(Pos > 0) {
1480  		if(IndexV[Pos-1] < IndexV[Pos]) {
1481  			break;
1482  		}
1483  		Pos--;
1484  	}
1485  	if(Pos == 0) {
1486  		return false;
1487  	}
1488  	int Val = NAttrs, NewPos = -1;
1489  	for(int i = Pos; i < NAttrs; i++) {
1490  		if(IndexV[i] > IndexV[Pos - 1] && IndexV[i] < Val) {
1491  			NewPos = i;
1492  			Val = IndexV[i];
1493  		}
1494  	}
1495  	IndexV[NewPos] = IndexV[Pos - 1];
1496  	IndexV[Pos - 1] = Val;
1497  	TIntV SubIndexV;
1498      IndexV.GetSubValV(Pos, NAttrs - 1, SubIndexV);
1499  	SubIndexV.Sort(true);
1500  	for(int i = Pos; i < NAttrs; i++) {
1501  		IndexV[i] = SubIndexV[i - Pos];
1502  	}
1503  	return true;
1504  }
1505  const double TMAGFitBern::ComputeJointOneLL(const TIntVV& AttrVV) const {
1506  	double LL = 0.0;
1507  	const int NNodes = Param.GetNodes();
1508  	const int NAttrs = Param.GetAttrs();
1509  	TMAGAffMtxV MtxV(NAttrs);	Param.GetMtxV(MtxV);
1510  	const TMAGNodeBern NodeAttr = Param.GetNodeAttr();
1511  	const TFltV MuV = NodeAttr.GetMuV();
1512  	for(int l = 0; l < NAttrs; l++) {
1513  		for(int i = 0; i < MtxV[l].Len(); i++) {
1514  			MtxV[l].At(i) = log(MtxV[l].At(i));
1515  		}
1516  	}
1517  	for(int i = 0; i < NNodes; i++) {
1518  		for(int l = 0; l < NAttrs; l++) {
1519  			if(AttrVV.At(i, l) == 0) {
1520  				LL += log(MuV[l]);
1521  			} else {
1522  				LL += log(1.0 - MuV[l]);
1523  			}
1524  		}
1525  		for(int j = 0; j < NNodes; j++) {
1526  			if(i == j) {  continue;  }
1527  			double ProbLL = 0.0;
1528  			for(int l = 0; l < NAttrs; l++) {
1529  				ProbLL += MtxV[l].At(AttrVV.At(i, l), AttrVV.At(j, l));
1530  			}
1531  			if(Graph->IsEdge(i, j)) {
1532  				LL += ProbLL;
1533  			} else {
1534  				LL += log(1-exp(ProbLL));
1535  			}
1536  		}
1537  	}
1538  	return LL;
1539  }
1540  const double TMAGFitBern::ComputeJointAdjLL(const TIntVV& AttrVV) const {
1541  	double LL = 0.0;
1542  	const int NNodes = Param.GetNodes();
1543  	const int NAttrs = Param.GetAttrs();
1544  	TMAGAffMtxV MtxV(NAttrs);	Param.GetMtxV(MtxV);
1545  	const TMAGNodeBern NodeAttr = Param.GetNodeAttr();
1546  	const TFltV MuV = NodeAttr.GetMuV();
1547  	for(int l = 0; l < NAttrs; l++) {
1548  		for(int i = 0; i < MtxV[l].Len(); i++) {
1549  			MtxV[l].At(i) = log(MtxV[l].At(i));
1550  		}
1551  	}
1552  	for(int i = 0; i < NNodes; i++) {
1553  		for(int j = 0; j < NNodes; j++) {
1554  			if(i == j) {  continue;  }
1555  			double ProbLL = 0.0;
1556  			for(int l = 0; l < NAttrs; l++) {
1557  				ProbLL += MtxV[l].At(AttrVV.At(i, l), AttrVV.At(j, l));
1558  			}
1559  			if(Graph->IsEdge(i, j)) {
1560  				LL += ProbLL;
1561  			} else {
1562  				LL += log(1-exp(ProbLL));
1563  			}
1564  		}
1565  	}
1566  	return LL;
1567  }
1568  const double TMAGFitBern::ComputeJointLL(int NSample) const {
1569  	double LL = 0.0;
1570  	const int NNodes = Param.GetNodes();
1571  	const int NAttrs = Param.GetAttrs();
1572  	TRnd Rnd(2000);
1573  	TIntVV AttrVV(NNodes, NAttrs);
1574  	int count = 0;
1575  	for(int s = 0; s < NSample; s++) {
1576  		for(int i = 0; i < NNodes; i++) {
1577  			for(int l = 0; l < NAttrs; l++) {
1578  				if(Rnd.GetUniDev() <= PhiVV(i, l)) {
1579  					AttrVV.At(i, l) = 0;
1580  				} else {
1581  					AttrVV.At(i, l) = 1;
1582  				}
1583  				if(PhiVV(i, l) > 0.05 && PhiVV(i, l) < 0.95) count++;
1584  			}
1585  		}
1586  		LL += ComputeJointOneLL(AttrVV);
1587  	}
1588  	AttrVV.Clr();
1589  	return LL / double(NSample);
1590  }
1591  const double TMAGFitBern::ComputeApxLL() const {
1592  	double LL = 0.0;
1593  	const int NNodes = Param.GetNodes();
1594  	const int NAttrs = Param.GetAttrs();
1595  	TMAGNodeBern NodeAttr = Param.GetNodeAttr();
1596  	TFltV MuV = NodeAttr.GetMuV();
1597  	TMAGAffMtxV LLMtxV(NAttrs);
1598  	for(int l = 0; l < NAttrs; l++) {
1599  		for(int i = 0; i < NNodes; i++) {
1600  			LL += PhiVV(i, l) * log(MuV[l]);
1601  			LL += (1.0 - PhiVV(i, l)) * log(1.0 - MuV[l]);
1602  			LL -= PhiVV(i, l) * log(PhiVV(i, l));
1603  			LL -= (1.0 - PhiVV(i, l)) * log(1.0 - PhiVV(i, l));
1604  		}
1605  		TMAGAffMtx Theta = Param.GetMtx(l);
1606  		Theta.GetLLMtx(LLMtxV[l]);
1607  	}
1608  	for(int i = 0; i < NNodes; i++) {
1609  		for(int j = 0; j < NNodes; j++) {
1610  			if(i == j) {  continue;  }
1611  			if(Graph->IsEdge(i, j)) {
1612  				for(int l = 0; l < NAttrs; l++) {
1613  					LL += GetProbPhi(i, j, l, 0, 0) * LLMtxV[l].At(0, 0);
1614  					LL += GetProbPhi(i, j, l, 0, 1) * LLMtxV[l].At(0, 1);
1615  					LL += GetProbPhi(i, j, l, 1, 0) * LLMtxV[l].At(1, 0);
1616  					LL += GetProbPhi(i, j, l, 1, 1) * LLMtxV[l].At(1, 1);
1617  				}
1618  				LL += log(NormConst);
1619  			} else {
1620  				LL += log(1-exp(GetProdLinWeight(i, j)));
1621  			}
1622  		}
1623  	}
1624  	return LL;
1625  }
1626  const double TMAGFitBern::ComputeApxAdjLL() const {
1627  	double LL = 0.0;
1628  	const int NNodes = Param.GetNodes();
1629  	const int NAttrs = Param.GetAttrs();
1630  	TMAGNodeBern NodeAttr = Param.GetNodeAttr();
1631  	TFltV MuV = NodeAttr.GetMuV();
1632  	MuV.PutAll(0.0);
1633  	TMAGAffMtxV LLMtxV(NAttrs);
1634  	double TotalEdge = 0.0;
1635  	for(int l = 0; l < NAttrs; l++) {
1636  		TMAGAffMtx Theta = Param.GetMtx(l);
1637  		Theta.GetLLMtx(LLMtxV[l]);
1638  	}
1639  	for(int i = 0; i < NNodes; i++) {
1640  		for(int j = 0; j < NNodes; j++) {
1641  			if(i == j) {  continue;  }
1642  			if(Graph->IsEdge(i, j)) {
1643  				for(int l = 0; l < NAttrs; l++) {
1644  					LL += GetProbPhi(i, j, l, 0, 0) * LLMtxV[l].At(0, 0);
1645  					LL += GetProbPhi(i, j, l, 0, 1) * LLMtxV[l].At(0, 1);
1646  					LL += GetProbPhi(i, j, l, 1, 0) * LLMtxV[l].At(1, 0);
1647  					LL += GetProbPhi(i, j, l, 1, 1) * LLMtxV[l].At(1, 1);
1648  				}
1649  			} else {
1650  				LL += log(1-exp(GetProdLinWeight(i, j)));
1651  			}
1652  			double TempLL = 1.0;
1653  			for(int l = 0; l < NAttrs; l++) {
1654  				int Ai = (double(PhiVV(i, l)) > 0.5) ? 0 : 1;
1655  				int Aj = (double(PhiVV(j, l)) > 0.5) ? 0 : 1;
1656  				TempLL *= Param.GetMtx(l).At(Ai, Aj);
1657  			}
1658  			if(TMAGNodeBern::Rnd.GetUniDev() < TempLL) {
1659  				TotalEdge += 1.0;
1660  			}
1661  		}
1662  	}
1663  	return LL;
1664  }
1665  const double TMAGFitBern::ComputeMI(const TIntVV& AttrV, const int AId1, const int AId2) {
1666  	const int NNodes = AttrV.GetXDim();
1667  	double MI = 0.0;
1668  	double Cor = 0.0;
1669  	TFltVV Pxy(2,2);
1670  	TFltV Px(2), Py(2);
1671  	Pxy.PutAll(0.0);
1672  	Px.PutAll(0.0);
1673  	Py.PutAll(0.0);
1674  	for(int i = 0; i < NNodes; i++) {
1675  		int X = AttrV(i, AId1);
1676  		int Y = AttrV(i, AId2);
1677  		Pxy(X, Y) = Pxy(X, Y) + 1;
1678  		Px[X] = Px[X] + 1;
1679  		Py[Y] = Py[Y] + 1;
1680  		Cor += double(X * Y);
1681  	}
1682  	for(int x = 0; x < 2; x++) {
1683  		for(int y = 0; y < 2; y++) {
1684        MI += Pxy(x, y) / double(NNodes) * (log(Pxy(x, y).Val) - log(Px[x].Val) - log(Py[y].Val) + log((double)NNodes));
1685  		}
1686  	}
1687  	return MI;
1688  }
1689  const double TMAGFitBern::ComputeMI(const TFltVV& AttrV, const int AId1, const int AId2) {
1690  	const int NNodes = AttrV.GetXDim();
1691  	double MI = 0.0;
1692  	double Cor = 0.0;
1693  	TFltVV Pxy(2,2);
1694  	TFltV Px(2), Py(2);
1695  	Pxy.PutAll(0.0);
1696  	Px.PutAll(0.0);
1697  	Py.PutAll(0.0);
1698  	for(int i = 0; i < NNodes; i++) {
1699  		double X = AttrV(i, AId1);
1700  		double Y = AttrV(i, AId2);
1701  		Pxy(0, 0) = Pxy(0, 0) + X * Y;
1702  		Pxy(0, 1) = Pxy(0, 1) + X * (1 - Y);
1703  		Pxy(1, 0) = Pxy(1, 0) + (1 - X) * Y;
1704  		Pxy(1, 1) = (i+1) - Pxy(0, 0) - Pxy(0, 1) - Pxy(1, 0);
1705  		Px[0] = Px[0] + X;
1706  		Py[0] = Py[0] + Y;
1707  		Cor += double((1-X) * (1-Y));
1708  	}
1709  	Px[1] = NNodes - Px[0];
1710  	Py[1] = NNodes - Py[0];
1711  	for(int x = 0; x < 2; x++) {
1712  		for(int y = 0; y < 2; y++) {
1713  			MI += Pxy(x, y) / double(NNodes) * (log(Pxy(x, y)) - log(Px[x]) - log(Py[y]) + log(double(NNodes)));
1714  		}
1715  	}
1716  	return MI;
1717  }
1718  const double TMAGFitBern::ComputeMI(const TIntVV& AttrV) {
1719  	const int NAttrs = AttrV.GetYDim();
1720  	double MI = 0.0;
1721  	for(int l = 0; l < NAttrs; l++) {
1722  		for(int k = l+1; k < NAttrs; k++) {
1723  			MI += ComputeMI(AttrV, l, k);
1724  		}
1725  	}
1726  	return MI;
1727  }
1728  const double TMAGFitBern::ComputeMI(const TFltVV& AttrV) {
1729  	const int NAttrs = AttrV.GetYDim();
1730  	double MI = 0.0;
1731  	for(int l = 0; l < NAttrs; l++) {
1732  		for(int k = l+1; k < NAttrs; k++) {
1733  			MI += ComputeMI(AttrV, l, k);
1734  		}
1735  	}
1736  	return MI;
1737  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-rolx.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-mag.cpp</div>
                </div>
                <div class="column column_space"><pre><code>172    const int StartIdxNewFeatures = GetNumFeatures(Features);
173    for (int i = 0; i < RetainedIdx.Len(); ++i) {
174      const int IdxNewFeatures = RetainedIdx[i] - StartIdxNewFeatures;
</pre></code></div>
                <div class="column column_space"><pre><code>1060  		int Aj = p % 2;
1061  		LogSumV.Gen(NNodes * 4, 0);
1062  		for(int i = 0; i < NNodes; i++) {
1063  			const double LProd = ProdVV(i, 0) - GetAvgThetaLL(i, i, AId, true, false);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    