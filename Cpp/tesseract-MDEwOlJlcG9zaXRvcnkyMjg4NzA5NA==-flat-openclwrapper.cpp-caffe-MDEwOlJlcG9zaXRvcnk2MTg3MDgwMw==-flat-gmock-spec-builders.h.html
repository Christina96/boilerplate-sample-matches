
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 14, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-openclwrapper.cpp</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #  include "config_auto.h"
3  #endif
4  #ifdef USE_OPENCL
5  #  ifdef _WIN32
6  #    include <io.h>
7  #    include <windows.h>
8  #  else
9  #    include <sys/types.h>
10  #    include <unistd.h>
11  #  endif
12  #  include <cfloat>
13  #  include <ctime> 
14  #  include "oclkernels.h"
15  #  include "openclwrapper.h"
16  #  include "otsuthr.h"
17  #  include "thresholder.h"
18  #  if defined(WIN32) || defined(__WIN32__) || defined(_WIN32) || defined(__CYGWIN__) || \
19        defined(__MINGW32__)
20  #    define ON_WINDOWS 1
21  #    define ON_APPLE 0
22  #  elif defined(__linux__)
23  #    define ON_WINDOWS 0
24  #    define ON_APPLE 0
25  #  elif defined(__APPLE__)
26  #    define ON_WINDOWS 0
27  #    define ON_APPLE 1
28  #  else
29  #    define ON_WINDOWS 0
30  #    define ON_APPLE 0
31  #  endif
32  #  if ON_APPLE
33  #    include <mach/mach_time.h>
34  #  endif
35  #  include <cstdio>
36  #  include <cstdlib>
37  #  include <cstring> 
38  #  include <vector>
39  #  include "errcode.h" 
40  #  include "image.h"   
41  namespace tesseract {
42  GPUEnv OpenclDevice::gpuEnv;
43  bool OpenclDevice::deviceIsSelected = false;
44  ds_device OpenclDevice::selectedDevice;
45  int OpenclDevice::isInited = 0;
46  static l_int32 MORPH_BC = ASYMMETRIC_MORPH_BC;
47  static const l_uint32 lmask32[] = {
48      0x80000000, 0xc0000000, 0xe0000000, 0xf0000000, 0xf8000000, 0xfc000000, 0xfe000000, 0xff000000,
49      0xff800000, 0xffc00000, 0xffe00000, 0xfff00000, 0xfff80000, 0xfffc0000, 0xfffe0000, 0xffff0000,
50      0xffff8000, 0xffffc000, 0xffffe000, 0xfffff000, 0xfffff800, 0xfffffc00, 0xfffffe00, 0xffffff00,
51      0xffffff80, 0xffffffc0, 0xffffffe0, 0xfffffff0, 0xfffffff8, 0xfffffffc, 0xfffffffe, 0xffffffff};
52  static const l_uint32 rmask32[] = {
53      0x00000001, 0x00000003, 0x00000007, 0x0000000f, 0x0000001f, 0x0000003f, 0x0000007f, 0x000000ff,
54      0x000001ff, 0x000003ff, 0x000007ff, 0x00000fff, 0x00001fff, 0x00003fff, 0x00007fff, 0x0000ffff,
55      0x0001ffff, 0x0003ffff, 0x0007ffff, 0x000fffff, 0x001fffff, 0x003fffff, 0x007fffff, 0x00ffffff,
56      0x01ffffff, 0x03ffffff, 0x07ffffff, 0x0fffffff, 0x1fffffff, 0x3fffffff, 0x7fffffff, 0xffffffff};
57  static cl_mem pixsCLBuffer, pixdCLBuffer,
58      pixdCLIntermediate;    
59  static cl_mem pixThBuffer; 
60  static cl_int clStatus;
61  static KernelEnv rEnv;
62  #  define DS_TAG_VERSION "<version>"
63  #  define DS_TAG_VERSION_END "</version>"
64  #  define DS_TAG_DEVICE "<device>"
65  #  define DS_TAG_DEVICE_END "</device>"
66  #  define DS_TAG_SCORE "<score>"
67  #  define DS_TAG_SCORE_END "</score>"
68  #  define DS_TAG_DEVICE_TYPE "<type>"
69  #  define DS_TAG_DEVICE_TYPE_END "</type>"
70  #  define DS_TAG_DEVICE_NAME "<name>"
71  #  define DS_TAG_DEVICE_NAME_END "</name>"
72  #  define DS_TAG_DEVICE_DRIVER_VERSION "<driver>"
73  #  define DS_TAG_DEVICE_DRIVER_VERSION_END "</driver>"
74  #  define DS_DEVICE_NATIVE_CPU_STRING "native_cpu"
75  #  define DS_DEVICE_NAME_LENGTH 256
76  enum ds_evaluation_type { DS_EVALUATE_ALL, DS_EVALUATE_NEW_ONLY };
77  struct ds_profile {
78    std::vector<ds_device> devices;
79    unsigned int numDevices;
80    const char *version;
81  };
82  enum ds_status {
83    DS_SUCCESS = 0,
84    DS_INVALID_PROFILE = 1000,
85    DS_MEMORY_ERROR,
86    DS_INVALID_PERF_EVALUATOR_TYPE,
87    DS_INVALID_PERF_EVALUATOR,
88    DS_PERF_EVALUATOR_ERROR,
89    DS_FILE_ERROR,
90    DS_UNKNOWN_DEVICE_TYPE,
91    DS_PROFILE_FILE_ERROR,
92    DS_SCORE_SERIALIZER_ERROR,
93    DS_SCORE_DESERIALIZER_ERROR
94  };
95  typedef ds_status (*ds_perf_evaluator)(ds_device *device, void *data);
96  typedef ds_status (*ds_score_release)(TessDeviceScore *score);
97  static ds_status releaseDSProfile(ds_profile *profile, ds_score_release sr) {
98    ds_status status = DS_SUCCESS;
99    if (profile != nullptr) {
100      if (sr != nullptr) {
101        unsigned int i;
102        for (i = 0; i < profile->numDevices; i++) {
103          free(profile->devices[i].oclDeviceName);
104          free(profile->devices[i].oclDriverVersion);
105          status = sr(profile->devices[i].score);
106          if (status != DS_SUCCESS)
107            break;
108        }
109      }
110      delete profile;
111    }
112    return status;
113  }
114  static ds_status initDSProfile(ds_profile **p, const char *version) {
115    int numDevices;
116    cl_uint numPlatforms;
117    std::vector<cl_platform_id> platforms;
118    std::vector<cl_device_id> devices;
119    ds_status status = DS_SUCCESS;
120    unsigned int next;
121    unsigned int i;
122    if (p == nullptr)
123      return DS_INVALID_PROFILE;
124    ds_profile *profile = new ds_profile;
125    memset(profile, 0, sizeof(ds_profile));
126    clGetPlatformIDs(0, nullptr, &numPlatforms);
127    if (numPlatforms > 0) {
128      platforms.reserve(numPlatforms);
129      clGetPlatformIDs(numPlatforms, &platforms[0], nullptr);
130    }
131    numDevices = 0;
132    for (i = 0; i < numPlatforms; i++) {
133      cl_uint num;
134      clGetDeviceIDs(platforms[i], CL_DEVICE_TYPE_ALL, 0, nullptr, &num);
135      numDevices += num;
136    }
137    if (numDevices > 0) {
138      devices.reserve(numDevices);
139    }
140    profile->numDevices = numDevices + 1; 
141    profile->devices.reserve(profile->numDevices);
142    memset(&profile->devices[0], 0, profile->numDevices * sizeof(ds_device));
143    next = 0;
144    for (i = 0; i < numPlatforms; i++) {
145      cl_uint num;
146      unsigned j;
147      clGetDeviceIDs(platforms[i], CL_DEVICE_TYPE_ALL, numDevices, &devices[0], &num);
148      for (j = 0; j < num; j++, next++) {
149        char buffer[DS_DEVICE_NAME_LENGTH];
150        size_t length;
151        profile->devices[next].type = DS_DEVICE_OPENCL_DEVICE;
152        profile->devices[next].oclDeviceID = devices[j];
153        clGetDeviceInfo(profile->devices[next].oclDeviceID, CL_DEVICE_NAME, DS_DEVICE_NAME_LENGTH,
154                        &buffer, nullptr);
155        length = strlen(buffer);
156        profile->devices[next].oclDeviceName = (char *)malloc(length + 1);
157        memcpy(profile->devices[next].oclDeviceName, buffer, length + 1);
158        clGetDeviceInfo(profile->devices[next].oclDeviceID, CL_DRIVER_VERSION, DS_DEVICE_NAME_LENGTH,
159                        &buffer, nullptr);
160        length = strlen(buffer);
161        profile->devices[next].oclDriverVersion = (char *)malloc(length + 1);
162        memcpy(profile->devices[next].oclDriverVersion, buffer, length + 1);
163      }
164    }
165    profile->devices[next].type = DS_DEVICE_NATIVE_CPU;
166    profile->version = version;
167    *p = profile;
168    return status;
169  }
170  static ds_status profileDevices(ds_profile *profile, const ds_evaluation_type type,
171                                  ds_perf_evaluator evaluator, void *evaluatorData,
172                                  unsigned int *numUpdates) {
173    ds_status status = DS_SUCCESS;
174    unsigned int i;
175    unsigned int updates = 0;
176    if (profile == nullptr) {
177      return DS_INVALID_PROFILE;
178    }
179    if (evaluator == nullptr) {
180      return DS_INVALID_PERF_EVALUATOR;
181    }
182    for (i = 0; i < profile->numDevices; i++) {
183      ds_status evaluatorStatus;
184      switch (type) {
185        case DS_EVALUATE_NEW_ONLY:
186          if (profile->devices[i].score != nullptr)
187            break;
188        case DS_EVALUATE_ALL:
189          evaluatorStatus = evaluator(&profile->devices[i], evaluatorData);
190          if (evaluatorStatus != DS_SUCCESS) {
191            status = evaluatorStatus;
192            return status;
193          }
194          updates++;
195          break;
196        default:
197          return DS_INVALID_PERF_EVALUATOR_TYPE;
198          break;
199      };
200    }
201    if (numUpdates)
202      *numUpdates = updates;
203    return status;
204  }
205  static const char *findString(const char *contentStart, const char *contentEnd,
206                                const char *string) {
207    size_t stringLength;
208    const char *currentPosition;
209    const char *found = nullptr;
210    stringLength = strlen(string);
211    currentPosition = contentStart;
212    for (currentPosition = contentStart; currentPosition < contentEnd; currentPosition++) {
213      if (*currentPosition == string[0]) {
214        if (currentPosition + stringLength < contentEnd) {
215          if (strncmp(currentPosition, string, stringLength) == 0) {
216            found = currentPosition;
217            break;
218          }
219        }
220      }
221    }
222    return found;
223  }
224  static ds_status readProFile(const char *fileName, char **content, size_t *contentSize) {
225    *contentSize = 0;
226    *content = nullptr;
227    ds_status status = DS_SUCCESS;
228    FILE *input = fopen(fileName, "rb");
229    if (input == nullptr) {
230      status = DS_FILE_ERROR;
231    } else {
232      fseek(input, 0L, SEEK_END);
233      auto pos = std::ftell(input);
234      rewind(input);
235      if (pos > 0) {
236        size_t size = pos;
237        char *binary = new char[size];
238        if (fread(binary, sizeof(char), size, input) != size) {
239          status = DS_FILE_ERROR;
240          delete[] binary;
241        } else {
242          *contentSize = size;
243          *content = binary;
244        }
245      }
246      fclose(input);
247    }
248    return status;
249  }
250  typedef ds_status (*ds_score_deserializer)(ds_device *device, const uint8_t *serializedScore,
251                                             unsigned int serializedScoreSize);
252  static ds_status readProfileFromFile(ds_profile *profile, ds_score_deserializer deserializer,
253                                       const char *file) {
254    ds_status status = DS_SUCCESS;
255    char *contentStart;
256    size_t contentSize;
257    if (profile == nullptr)
258      return DS_INVALID_PROFILE;
259    status = readProFile(file, &contentStart, &contentSize);
260    if (status == DS_SUCCESS) {
261      const char *currentPosition;
262      const char *dataStart;
263      const char *dataEnd;
264      const char *contentEnd = contentStart + contentSize;
265      currentPosition = contentStart;
266      dataStart = findString(currentPosition, contentEnd, DS_TAG_VERSION);
267      if (dataStart == nullptr) {
268        status = DS_PROFILE_FILE_ERROR;
269        goto cleanup;
270      }
271      dataStart += strlen(DS_TAG_VERSION);
272      dataEnd = findString(dataStart, contentEnd, DS_TAG_VERSION_END);
273      if (dataEnd == nullptr) {
274        status = DS_PROFILE_FILE_ERROR;
275        goto cleanup;
276      }
277      size_t versionStringLength = strlen(profile->version);
278      if (versionStringLength + dataStart != dataEnd ||
279          strncmp(profile->version, dataStart, versionStringLength) != 0) {
280        status = DS_PROFILE_FILE_ERROR;
281        goto cleanup;
282      }
283      currentPosition = dataEnd + strlen(DS_TAG_VERSION_END);
284      while (1) {
285        unsigned int i;
286        const char *deviceTypeStart;
287        const char *deviceTypeEnd;
288        ds_device_type deviceType;
289        const char *deviceNameStart;
290        const char *deviceNameEnd;
291        const char *deviceScoreStart;
292        const char *deviceScoreEnd;
293        const char *deviceDriverStart;
294        const char *deviceDriverEnd;
295        dataStart = findString(currentPosition, contentEnd, DS_TAG_DEVICE);
296        if (dataStart == nullptr) {
297          break;
298        }
299        dataStart += strlen(DS_TAG_DEVICE);
300        dataEnd = findString(dataStart, contentEnd, DS_TAG_DEVICE_END);
301        if (dataEnd == nullptr) {
302          status = DS_PROFILE_FILE_ERROR;
303          goto cleanup;
304        }
305        deviceTypeStart = findString(dataStart, contentEnd, DS_TAG_DEVICE_TYPE);
306        if (deviceTypeStart == nullptr) {
307          status = DS_PROFILE_FILE_ERROR;
308          goto cleanup;
309        }
310        deviceTypeStart += strlen(DS_TAG_DEVICE_TYPE);
311        deviceTypeEnd = findString(deviceTypeStart, contentEnd, DS_TAG_DEVICE_TYPE_END);
312        if (deviceTypeEnd == nullptr) {
313          status = DS_PROFILE_FILE_ERROR;
314          goto cleanup;
315        }
316        memcpy(&deviceType, deviceTypeStart, sizeof(ds_device_type));
317        if (deviceType == DS_DEVICE_OPENCL_DEVICE) {
318          deviceNameStart = findString(dataStart, contentEnd, DS_TAG_DEVICE_NAME);
319          if (deviceNameStart == nullptr) {
320            status = DS_PROFILE_FILE_ERROR;
321            goto cleanup;
322          }
323          deviceNameStart += strlen(DS_TAG_DEVICE_NAME);
324          deviceNameEnd = findString(deviceNameStart, contentEnd, DS_TAG_DEVICE_NAME_END);
325          if (deviceNameEnd == nullptr) {
326            status = DS_PROFILE_FILE_ERROR;
327            goto cleanup;
328          }
329          deviceDriverStart = findString(dataStart, contentEnd, DS_TAG_DEVICE_DRIVER_VERSION);
330          if (deviceDriverStart == nullptr) {
331            status = DS_PROFILE_FILE_ERROR;
332            goto cleanup;
333          }
334          deviceDriverStart += strlen(DS_TAG_DEVICE_DRIVER_VERSION);
335          deviceDriverEnd =
336              findString(deviceDriverStart, contentEnd, DS_TAG_DEVICE_DRIVER_VERSION_END);
337          if (deviceDriverEnd == nullptr) {
338            status = DS_PROFILE_FILE_ERROR;
339            goto cleanup;
340          }
341          for (i = 0; i < profile->numDevices; i++) {
342            if (profile->devices[i].type == DS_DEVICE_OPENCL_DEVICE) {
343              size_t actualDeviceNameLength;
344              size_t driverVersionLength;
345              actualDeviceNameLength = strlen(profile->devices[i].oclDeviceName);
346              driverVersionLength = strlen(profile->devices[i].oclDriverVersion);
347              if (deviceNameStart + actualDeviceNameLength == deviceNameEnd &&
348                  deviceDriverStart + driverVersionLength == deviceDriverEnd &&
349                  strncmp(profile->devices[i].oclDeviceName, deviceNameStart,
350                          actualDeviceNameLength) == 0 &&
351                  strncmp(profile->devices[i].oclDriverVersion, deviceDriverStart,
352                          driverVersionLength) == 0) {
353                deviceScoreStart = findString(dataStart, contentEnd, DS_TAG_SCORE);
354                deviceScoreStart += strlen(DS_TAG_SCORE);
355                deviceScoreEnd = findString(deviceScoreStart, contentEnd, DS_TAG_SCORE_END);
356                status = deserializer(&profile->devices[i], (const unsigned char *)deviceScoreStart,
357                                      deviceScoreEnd - deviceScoreStart);
358                if (status != DS_SUCCESS) {
359                  goto cleanup;
360                }
361              }
362            }
363          }
364        } else if (deviceType == DS_DEVICE_NATIVE_CPU) {
365          for (i = 0; i < profile->numDevices; i++) {
366            if (profile->devices[i].type == DS_DEVICE_NATIVE_CPU) {
367              deviceScoreStart = findString(dataStart, contentEnd, DS_TAG_SCORE);
368              if (deviceScoreStart == nullptr) {
369                status = DS_PROFILE_FILE_ERROR;
370                goto cleanup;
371              }
372              deviceScoreStart += strlen(DS_TAG_SCORE);
373              deviceScoreEnd = findString(deviceScoreStart, contentEnd, DS_TAG_SCORE_END);
374              status = deserializer(&profile->devices[i], (const unsigned char *)deviceScoreStart,
375                                    deviceScoreEnd - deviceScoreStart);
376              if (status != DS_SUCCESS) {
377                goto cleanup;
378              }
379            }
380          }
381        }
382        currentPosition = dataEnd + strlen(DS_TAG_DEVICE_END);
383      }
384    }
385  cleanup:
386    delete[] contentStart;
387    return status;
388  }
389  typedef ds_status (*ds_score_serializer)(ds_device *device, uint8_t **serializedScore,
390                                           unsigned int *serializedScoreSize);
391  static ds_status writeProfileToFile(ds_profile *profile, ds_score_serializer serializer,
392                                      const char *file) {
393    ds_status status = DS_SUCCESS;
394    if (profile == nullptr)
395      return DS_INVALID_PROFILE;
396    FILE *profileFile = fopen(file, "wb");
397    if (profileFile == nullptr) {
398      status = DS_FILE_ERROR;
399    } else {
400      unsigned int i;
401      fwrite(DS_TAG_VERSION, sizeof(char), strlen(DS_TAG_VERSION), profileFile);
402      fwrite(profile->version, sizeof(char), strlen(profile->version), profileFile);
403      fwrite(DS_TAG_VERSION_END, sizeof(char), strlen(DS_TAG_VERSION_END), profileFile);
404      fwrite("\n", sizeof(char), 1, profileFile);
405      for (i = 0; i < profile->numDevices && status == DS_SUCCESS; i++) {
406        uint8_t *serializedScore;
407        unsigned int serializedScoreSize;
408        fwrite(DS_TAG_DEVICE, sizeof(char), strlen(DS_TAG_DEVICE), profileFile);
409        fwrite(DS_TAG_DEVICE_TYPE, sizeof(char), strlen(DS_TAG_DEVICE_TYPE), profileFile);
410        fwrite(&profile->devices[i].type, sizeof(ds_device_type), 1, profileFile);
411        fwrite(DS_TAG_DEVICE_TYPE_END, sizeof(char), strlen(DS_TAG_DEVICE_TYPE_END), profileFile);
412        switch (profile->devices[i].type) {
413          case DS_DEVICE_NATIVE_CPU: {
414          } break;
415          case DS_DEVICE_OPENCL_DEVICE: {
416            fwrite(DS_TAG_DEVICE_NAME, sizeof(char), strlen(DS_TAG_DEVICE_NAME), profileFile);
417            fwrite(profile->devices[i].oclDeviceName, sizeof(char),
418                   strlen(profile->devices[i].oclDeviceName), profileFile);
419            fwrite(DS_TAG_DEVICE_NAME_END, sizeof(char), strlen(DS_TAG_DEVICE_NAME_END), profileFile);
420            fwrite(DS_TAG_DEVICE_DRIVER_VERSION, sizeof(char), strlen(DS_TAG_DEVICE_DRIVER_VERSION),
421                   profileFile);
422            fwrite(profile->devices[i].oclDriverVersion, sizeof(char),
423                   strlen(profile->devices[i].oclDriverVersion), profileFile);
424            fwrite(DS_TAG_DEVICE_DRIVER_VERSION_END, sizeof(char),
425                   strlen(DS_TAG_DEVICE_DRIVER_VERSION_END), profileFile);
426          } break;
427          default:
428            status = DS_UNKNOWN_DEVICE_TYPE;
429            continue;
430        };
431        fwrite(DS_TAG_SCORE, sizeof(char), strlen(DS_TAG_SCORE), profileFile);
432        status = serializer(&profile->devices[i], &serializedScore, &serializedScoreSize);
433        if (status == DS_SUCCESS && serializedScore != nullptr && serializedScoreSize > 0) {
434          fwrite(serializedScore, sizeof(char), serializedScoreSize, profileFile);
435          delete[] serializedScore;
436        }
437        fwrite(DS_TAG_SCORE_END, sizeof(char), strlen(DS_TAG_SCORE_END), profileFile);
438        fwrite(DS_TAG_DEVICE_END, sizeof(char), strlen(DS_TAG_DEVICE_END), profileFile);
439        fwrite("\n", sizeof(char), 1, profileFile);
440      }
441      fclose(profileFile);
442    }
443    return status;
444  }
445  static void legalizeFileName(char *fileName) {
446    const char *invalidChars = "/\?:*\"><| "; 
447    for (unsigned i = 0; i < strlen(invalidChars); i++) {
448      char invalidStr[4];
449      invalidStr[0] = invalidChars[i];
450      invalidStr[1] = '\0';
451      for (char *pos = strstr(fileName, invalidStr); pos != nullptr;
452           pos = strstr(pos + 1, invalidStr)) {
453        pos[0] = '_';
454      }
455    }
456  }
457  static void populateGPUEnvFromDevice(GPUEnv *gpuInfo, cl_device_id device) {
458    size_t size;
459    gpuInfo->mnIsUserCreated = 1;
460    gpuInfo->mpDevID = device;
461    gpuInfo->mpArryDevsID = new cl_device_id[1];
462    gpuInfo->mpArryDevsID[0] = gpuInfo->mpDevID;
463    clStatus = clGetDeviceInfo(gpuInfo->mpDevID, CL_DEVICE_TYPE, sizeof(cl_device_type),
464                               &gpuInfo->mDevType, &size);
465    CHECK_OPENCL(clStatus, "populateGPUEnv::getDeviceInfo(TYPE)");
466    clStatus = clGetDeviceInfo(gpuInfo->mpDevID, CL_DEVICE_PLATFORM, sizeof(cl_platform_id),
467                               &gpuInfo->mpPlatformID, &size);
468    CHECK_OPENCL(clStatus, "populateGPUEnv::getDeviceInfo(PLATFORM)");
469    cl_context_properties props[3];
470    props[0] = CL_CONTEXT_PLATFORM;
471    props[1] = (cl_context_properties)gpuInfo->mpPlatformID;
472    props[2] = 0;
473    gpuInfo->mpContext = clCreateContext(props, 1, &gpuInfo->mpDevID, nullptr, nullptr, &clStatus);
474    CHECK_OPENCL(clStatus, "populateGPUEnv::createContext");
475    cl_command_queue_properties queueProperties = 0;
476    gpuInfo->mpCmdQueue =
477        clCreateCommandQueue(gpuInfo->mpContext, gpuInfo->mpDevID, queueProperties, &clStatus);
478    CHECK_OPENCL(clStatus, "populateGPUEnv::createCommandQueue");
479  }
480  int OpenclDevice::LoadOpencl() {
481  #  ifdef WIN32
482    HINSTANCE HOpenclDll = nullptr;
483    void *OpenclDll = nullptr;
484    OpenclDll = static_cast<HINSTANCE>(HOpenclDll);
485    OpenclDll = LoadLibrary("openCL.dll");
486    if (!static_cast<HINSTANCE>(OpenclDll)) {
487      fprintf(stderr, "[OD] Load opencl.dll failed!\n");
488      FreeLibrary(static_cast<HINSTANCE>(OpenclDll));
489      return 0;
490    }
491    fprintf(stderr, "[OD] Load opencl.dll successful!\n");
492  #  endif
493    return 1;
494  }
495  int OpenclDevice::SetKernelEnv(KernelEnv *envInfo) {
496    envInfo->mpkContext = gpuEnv.mpContext;
497    envInfo->mpkCmdQueue = gpuEnv.mpCmdQueue;
498    envInfo->mpkProgram = gpuEnv.mpArryPrograms[0];
499    return 1;
500  }
501  static cl_mem allocateZeroCopyBuffer(const KernelEnv &rEnv, l_uint32 *hostbuffer, size_t nElements,
502                                       cl_mem_flags flags, cl_int *pStatus) {
503    cl_mem membuffer = clCreateBuffer(rEnv.mpkContext, (cl_mem_flags)(flags),
504                                      nElements * sizeof(l_uint32), hostbuffer, pStatus);
505    return membuffer;
506  }
507  static Image mapOutputCLBuffer(const KernelEnv &rEnv, cl_mem clbuffer, Image pixd, Image pixs,
508                                int elements, cl_mem_flags flags, bool memcopy = false,
509                                bool sync = true) {
510    if (!pixd) {
511      if (memcopy) {
512        if ((pixd = pixCreateTemplate(pixs)) == nullptr)
513          tprintf("pixd not made\n");
514      } else {
515        if ((pixd = pixCreateHeader(pixGetWidth(pixs), pixGetHeight(pixs), pixGetDepth(pixs))) ==
516            nullptr)
517          tprintf("pixd not made\n");
518      }
519    }
520    l_uint32 *pValues =
521        (l_uint32 *)clEnqueueMapBuffer(rEnv.mpkCmdQueue, clbuffer, CL_TRUE, flags, 0,
522                                       elements * sizeof(l_uint32), 0, nullptr, nullptr, nullptr);
523    if (memcopy) {
524      memcpy(pixGetData(pixd), pValues, elements * sizeof(l_uint32));
525    } else {
526      pixSetData(pixd, pValues);
527    }
528    clEnqueueUnmapMemObject(rEnv.mpkCmdQueue, clbuffer, pValues, 0, nullptr, nullptr);
529    if (sync) {
530      clFinish(rEnv.mpkCmdQueue);
531    }
532    return pixd;
533  }
534  void OpenclDevice::releaseMorphCLBuffers() {
535    if (pixdCLIntermediate != nullptr)
536      clReleaseMemObject(pixdCLIntermediate);
537    if (pixsCLBuffer != nullptr)
538      clReleaseMemObject(pixsCLBuffer);
539    if (pixdCLBuffer != nullptr)
540      clReleaseMemObject(pixdCLBuffer);
541    if (pixThBuffer != nullptr)
542      clReleaseMemObject(pixThBuffer);
543    pixdCLIntermediate = pixsCLBuffer = pixdCLBuffer = pixThBuffer = nullptr;
544  }
545  int OpenclDevice::initMorphCLAllocations(l_int32 wpl, l_int32 h, Image pixs) {
546    SetKernelEnv(&rEnv);
547    if (pixThBuffer != nullptr) {
548      pixsCLBuffer = allocateZeroCopyBuffer(rEnv, nullptr, wpl * h, CL_MEM_ALLOC_HOST_PTR, &clStatus);
549      clStatus = clEnqueueCopyBuffer(rEnv.mpkCmdQueue, pixThBuffer, pixsCLBuffer, 0, 0,
550                                     sizeof(l_uint32) * wpl * h, 0, nullptr, nullptr);
551    } else {
552      l_uint32 *srcdata = reinterpret_cast<l_uint32 *>(malloc(wpl * h * sizeof(l_uint32)));
553      memcpy(srcdata, pixGetData(pixs), wpl * h * sizeof(l_uint32));
554      pixsCLBuffer = allocateZeroCopyBuffer(rEnv, srcdata, wpl * h, CL_MEM_USE_HOST_PTR, &clStatus);
555    }
556    pixdCLBuffer = allocateZeroCopyBuffer(rEnv, nullptr, wpl * h, CL_MEM_ALLOC_HOST_PTR, &clStatus);
557    pixdCLIntermediate =
558        allocateZeroCopyBuffer(rEnv, nullptr, wpl * h, CL_MEM_ALLOC_HOST_PTR, &clStatus);
559    return (int)clStatus;
560  }
561  int OpenclDevice::InitEnv() {
562  #  ifdef SAL_WIN32
563    while (1) {
564      if (1 == LoadOpencl())
565        break;
566    }
567  #  endif
568    InitOpenclRunEnv_DeviceSelection(0);
569    return 1;
570  }
571  int OpenclDevice::ReleaseOpenclRunEnv() {
572    ReleaseOpenclEnv(&gpuEnv);
573  #  ifdef SAL_WIN32
574    FreeOpenclDll();
575  #  endif
576    return 1;
577  }
578  inline int OpenclDevice::AddKernelConfig(int kCount, const char *kName) {
579    ASSERT_HOST(kCount > 0);
580    ASSERT_HOST(strlen(kName) < sizeof(gpuEnv.mArrykernelNames[kCount - 1]));
581    strcpy(gpuEnv.mArrykernelNames[kCount - 1], kName);
582    gpuEnv.mnKernelCount++;
583    return 0;
584  }
585  int OpenclDevice::RegistOpenclKernel() {
586    if (!gpuEnv.mnIsUserCreated)
587      memset(&gpuEnv, 0, sizeof(gpuEnv));
588    gpuEnv.mnFileCount = 0; 
589    gpuEnv.mnKernelCount = 0UL;
590    AddKernelConfig(1, "oclAverageSub1");
591    return 0;
592  }
593  int OpenclDevice::InitOpenclRunEnv_DeviceSelection(int argc) {
594    if (!isInited) {
595      ds_device bestDevice_DS = getDeviceSelection();
596      cl_device_id bestDevice = bestDevice_DS.oclDeviceID;
597      if (selectedDeviceIsOpenCL()) {
598        populateGPUEnvFromDevice(&gpuEnv, bestDevice);
599        gpuEnv.mnFileCount = 0; 
600        gpuEnv.mnKernelCount = 0UL;
601        CompileKernelFile(&gpuEnv, "");
602      } else {
603      }
604      isInited = 1;
605    }
606    return 0;
607  }
608  OpenclDevice::OpenclDevice() {
609  }
610  OpenclDevice::~OpenclDevice() {
611  }
612  int OpenclDevice::ReleaseOpenclEnv(GPUEnv *gpuInfo) {
613    int i = 0;
614    int clStatus = 0;
615    if (!isInited) {
616      return 1;
617    }
618    for (i = 0; i < gpuEnv.mnFileCount; i++) {
619      if (gpuEnv.mpArryPrograms[i]) {
620        clStatus = clReleaseProgram(gpuEnv.mpArryPrograms[i]);
621        CHECK_OPENCL(clStatus, "clReleaseProgram");
622        gpuEnv.mpArryPrograms[i] = nullptr;
623      }
624    }
625    if (gpuEnv.mpCmdQueue) {
626      clReleaseCommandQueue(gpuEnv.mpCmdQueue);
627      gpuEnv.mpCmdQueue = nullptr;
628    }
629    if (gpuEnv.mpContext) {
630      clReleaseContext(gpuEnv.mpContext);
631      gpuEnv.mpContext = nullptr;
632    }
633    isInited = 0;
634    gpuInfo->mnIsUserCreated = 0;
635    delete[] gpuInfo->mpArryDevsID;
636    return 1;
637  }
638  int OpenclDevice::BinaryGenerated(const char *clFileName, FILE **fhandle) {
639    unsigned int i = 0;
640    cl_int clStatus;
641    int status = 0;
642    FILE *fd = nullptr;
643    char fileName[256];
644    char cl_name[128];
645    char deviceName[1024];
646    clStatus = clGetDeviceInfo(gpuEnv.mpArryDevsID[i], CL_DEVICE_NAME, sizeof(deviceName), deviceName,
647                               nullptr);
648    CHECK_OPENCL(clStatus, "clGetDeviceInfo");
649    const char *str = strstr(clFileName, ".cl");
650    memcpy(cl_name, clFileName, str - clFileName);
651    cl_name[str - clFileName] = '\0';
652    snprintf(fileName, sizeof(fileName), "%s-%s.bin", cl_name, deviceName);
653    legalizeFileName(fileName);
654    fd = fopen(fileName, "rb");
655    status = (fd != nullptr) ? 1 : 0;
656    if (fd != nullptr) {
657      *fhandle = fd;
658    }
659    return status;
660  }
661  int OpenclDevice::CachedOfKernerPrg(const GPUEnv *gpuEnvCached, const char *clFileName) {
662    int i;
663    for (i = 0; i < gpuEnvCached->mnFileCount; i++) {
664      if (strcasecmp(gpuEnvCached->mArryKnelSrcFile[i], clFileName) == 0) {
665        if (gpuEnvCached->mpArryPrograms[i] != nullptr) {
666          return 1;
667        }
668      }
669    }
670    return 0;
671  }
672  int OpenclDevice::WriteBinaryToFile(const char *fileName, const char *birary, size_t numBytes) {
673    FILE *output = nullptr;
674    output = fopen(fileName, "wb");
675    if (output == nullptr) {
676      return 0;
677    }
678    fwrite(birary, sizeof(char), numBytes, output);
679    fclose(output);
680    return 1;
681  }
682  int OpenclDevice::GeneratBinFromKernelSource(cl_program program, const char *clFileName) {
683    unsigned int i = 0;
684    cl_int clStatus;
685    cl_uint numDevices;
686    clStatus =
687        clGetProgramInfo(program, CL_PROGRAM_NUM_DEVICES, sizeof(numDevices), &numDevices, nullptr);
688    CHECK_OPENCL(clStatus, "clGetProgramInfo");
689    std::vector<cl_device_id> mpArryDevsID(numDevices);
690    clStatus = clGetProgramInfo(program, CL_PROGRAM_DEVICES, sizeof(cl_device_id) * numDevices,
691                                &mpArryDevsID[0], nullptr);
692    CHECK_OPENCL(clStatus, "clGetProgramInfo");
693    std::vector<size_t> binarySizes(numDevices);
694    clStatus = clGetProgramInfo(program, CL_PROGRAM_BINARY_SIZES, sizeof(size_t) * numDevices,
695                                &binarySizes[0], nullptr);
696    CHECK_OPENCL(clStatus, "clGetProgramInfo");
697    std::vector<char *> binaries(numDevices);
698    for (i = 0; i < numDevices; i++) {
699      if (binarySizes[i] != 0) {
700        binaries[i] = new char[binarySizes[i]];
701      } else {
702        binaries[i] = nullptr;
703      }
704    }
705    clStatus = clGetProgramInfo(program, CL_PROGRAM_BINARIES, sizeof(char *) * numDevices,
706                                &binaries[0], nullptr);
707    CHECK_OPENCL(clStatus, "clGetProgramInfo");
708    for (i = 0; i < numDevices; i++) {
709      if (binarySizes[i] != 0) {
710        char fileName[256];
711        char cl_name[128];
712        char deviceName[1024];
713        clStatus =
714            clGetDeviceInfo(mpArryDevsID[i], CL_DEVICE_NAME, sizeof(deviceName), deviceName, nullptr);
715        CHECK_OPENCL(clStatus, "clGetDeviceInfo");
716        const char *str = strstr(clFileName, ".cl");
717        memcpy(cl_name, clFileName, str - clFileName);
718        cl_name[str - clFileName] = '\0';
719        snprintf(fileName, sizeof(fileName), "%s-%s.bin", cl_name, deviceName);
720        legalizeFileName(fileName);
721        if (!WriteBinaryToFile(fileName, binaries[i], binarySizes[i])) {
722          tprintf("[OD] write binary[%s] failed\n", fileName);
723          return 0;
724        } 
725        tprintf("[OD] write binary[%s] successfully\n", fileName);
726      }
727    }
728    for (i = 0; i < numDevices; i++) {
729      delete[] binaries[i];
730    }
731    return 1;
732  }
733  int OpenclDevice::CompileKernelFile(GPUEnv *gpuInfo, const char *buildOption) {
734    cl_int clStatus = 0;
735    const char *source;
736    size_t source_size[1];
737    int binary_status, binaryExisted, idx;
738    cl_uint numDevices;
739    FILE *fd, *fd1;
740    const char *filename = "kernel.cl";
741    if (CachedOfKernerPrg(gpuInfo, filename) == 1) {
742      return 1;
743    }
744    idx = gpuInfo->mnFileCount;
745    source = kernel_src;
746    source_size[0] = strlen(source);
747    binaryExisted = 0;
748    binaryExisted = BinaryGenerated(filename, &fd); 
749    if (binaryExisted == 1) {
750      clStatus = clGetContextInfo(gpuInfo->mpContext, CL_CONTEXT_NUM_DEVICES, sizeof(numDevices),
751                                  &numDevices, nullptr);
752      CHECK_OPENCL(clStatus, "clGetContextInfo");
753      std::vector<cl_device_id> mpArryDevsID(numDevices);
754      bool b_error = fseek(fd, 0, SEEK_END) < 0;
755      auto pos = std::ftell(fd);
756      b_error |= (pos <= 0);
757      size_t length = pos;
758      b_error |= fseek(fd, 0, SEEK_SET) < 0;
759      if (b_error) {
760        fclose(fd);
761        return 0;
762      }
763      std::vector<uint8_t> binary(length + 2);
764      memset(&binary[0], 0, length + 2);
765      b_error |= fread(&binary[0], 1, length, fd) != length;
766      fclose(fd);
767      fd = nullptr;
768      clStatus = clGetContextInfo(gpuInfo->mpContext, CL_CONTEXT_DEVICES,
769                                  sizeof(cl_device_id) * numDevices, &mpArryDevsID[0], nullptr);
770      CHECK_OPENCL(clStatus, "clGetContextInfo");
771      const uint8_t *c_binary = &binary[0];
772      gpuInfo->mpArryPrograms[idx] =
773          clCreateProgramWithBinary(gpuInfo->mpContext, numDevices, &mpArryDevsID[0], &length,
774                                    &c_binary, &binary_status, &clStatus);
775      CHECK_OPENCL(clStatus, "clCreateProgramWithBinary");
776    } else {
777      gpuInfo->mpArryPrograms[idx] =
778          clCreateProgramWithSource(gpuInfo->mpContext, 1, &source, source_size, &clStatus);
779      CHECK_OPENCL(clStatus, "clCreateProgramWithSource");
780    }
781    if (gpuInfo->mpArryPrograms[idx] == (cl_program) nullptr) {
782      return 0;
783    }
784    if (!gpuInfo->mnIsUserCreated) {
785      clStatus = clBuildProgram(gpuInfo->mpArryPrograms[idx], 1, gpuInfo->mpArryDevsID, buildOption,
786                                nullptr, nullptr);
787    } else {
788      clStatus = clBuildProgram(gpuInfo->mpArryPrograms[idx], 1, &(gpuInfo->mpDevID), buildOption,
789                                nullptr, nullptr);
790    }
791    if (clStatus != CL_SUCCESS) {
792      tprintf("BuildProgram error!\n");
793      size_t length;
794      if (!gpuInfo->mnIsUserCreated) {
795        clStatus = clGetProgramBuildInfo(gpuInfo->mpArryPrograms[idx], gpuInfo->mpArryDevsID[0],
796                                         CL_PROGRAM_BUILD_LOG, 0, nullptr, &length);
797      } else {
798        clStatus = clGetProgramBuildInfo(gpuInfo->mpArryPrograms[idx], gpuInfo->mpDevID,
799                                         CL_PROGRAM_BUILD_LOG, 0, nullptr, &length);
800      }
801      if (clStatus != CL_SUCCESS) {
802        tprintf("opencl create build log fail\n");
803        return 0;
804      }
805      std::vector<char> buildLog(length);
806      if (!gpuInfo->mnIsUserCreated) {
807        clStatus = clGetProgramBuildInfo(gpuInfo->mpArryPrograms[idx], gpuInfo->mpArryDevsID[0],
808                                         CL_PROGRAM_BUILD_LOG, length, &buildLog[0], &length);
809      } else {
810        clStatus = clGetProgramBuildInfo(gpuInfo->mpArryPrograms[idx], gpuInfo->mpDevID,
811                                         CL_PROGRAM_BUILD_LOG, length, &buildLog[0], &length);
812      }
813      if (clStatus != CL_SUCCESS) {
814        tprintf("opencl program build info fail\n");
815        return 0;
816      }
817      fd1 = fopen("kernel-build.log", "w+");
818      if (fd1 != nullptr) {
819        fwrite(&buildLog[0], sizeof(char), length, fd1);
820        fclose(fd1);
821      }
822      return 0;
823    }
824    strcpy(gpuInfo->mArryKnelSrcFile[idx], filename);
825    if (binaryExisted == 0) {
826      GeneratBinFromKernelSource(gpuInfo->mpArryPrograms[idx], filename);
827    }
828    gpuInfo->mnFileCount += 1;
829    return 1;
830  }
831  l_uint32 *OpenclDevice::pixReadFromTiffKernel(l_uint32 *tiffdata, l_int32 w, l_int32 h, l_int32 wpl,
832                                                l_uint32 *line) {
833    cl_int clStatus;
834    KernelEnv rEnv;
835    size_t globalThreads[2];
836    size_t localThreads[2];
837    int gsize;
838    cl_mem valuesCl;
839    cl_mem outputCl;
840    gsize = (w + GROUPSIZE_X - 1) / GROUPSIZE_X * GROUPSIZE_X;
841    globalThreads[0] = gsize;
842    gsize = (h + GROUPSIZE_Y - 1) / GROUPSIZE_Y * GROUPSIZE_Y;
843    globalThreads[1] = gsize;
844    localThreads[0] = GROUPSIZE_X;
845    localThreads[1] = GROUPSIZE_Y;
846    SetKernelEnv(&rEnv);
847    l_uint32 *pResult = (l_uint32 *)malloc(w * h * sizeof(l_uint32));
848    rEnv.mpkKernel = clCreateKernel(rEnv.mpkProgram, "composeRGBPixel", &clStatus);
849    CHECK_OPENCL(clStatus, "clCreateKernel composeRGBPixel");
850    valuesCl = allocateZeroCopyBuffer(rEnv, tiffdata, w * h, CL_MEM_READ_ONLY | CL_MEM_USE_HOST_PTR,
851                                      &clStatus);
852    outputCl = allocateZeroCopyBuffer(rEnv, pResult, w * h, CL_MEM_WRITE_ONLY | CL_MEM_USE_HOST_PTR,
853                                      &clStatus);
854    clStatus = clSetKernelArg(rEnv.mpkKernel, 0, sizeof(cl_mem), &valuesCl);
855    CHECK_OPENCL(clStatus, "clSetKernelArg");
856    clStatus = clSetKernelArg(rEnv.mpkKernel, 1, sizeof(w), &w);
857    CHECK_OPENCL(clStatus, "clSetKernelArg");
858    clStatus = clSetKernelArg(rEnv.mpkKernel, 2, sizeof(h), &h);
859    CHECK_OPENCL(clStatus, "clSetKernelArg");
860    clStatus = clSetKernelArg(rEnv.mpkKernel, 3, sizeof(wpl), &wpl);
861    CHECK_OPENCL(clStatus, "clSetKernelArg");
862    clStatus = clSetKernelArg(rEnv.mpkKernel, 4, sizeof(cl_mem), &outputCl);
863    CHECK_OPENCL(clStatus, "clSetKernelArg");
864    clStatus = clEnqueueNDRangeKernel(rEnv.mpkCmdQueue, rEnv.mpkKernel, 2, nullptr, globalThreads,
865                                      localThreads, 0, nullptr, nullptr);
866    CHECK_OPENCL(clStatus, "clEnqueueNDRangeKernel");
867    void *ptr = clEnqueueMapBuffer(rEnv.mpkCmdQueue, outputCl, CL_TRUE, CL_MAP_READ, 0,
868                                   w * h * sizeof(l_uint32), 0, nullptr, nullptr, &clStatus);
869    CHECK_OPENCL(clStatus, "clEnqueueMapBuffer outputCl");
870    clEnqueueUnmapMemObject(rEnv.mpkCmdQueue, outputCl, ptr, 0, nullptr, nullptr);
871    clFinish(rEnv.mpkCmdQueue);
872    return pResult;
873  }
874  static cl_int pixDilateCL_55(l_int32 wpl, l_int32 h) {
875    size_t globalThreads[2];
876    cl_mem pixtemp;
877    cl_int status;
878    int gsize;
879    size_t localThreads[2];
880    gsize = (wpl * h + GROUPSIZE_HMORX - 1) / GROUPSIZE_HMORX * GROUPSIZE_HMORX;
881    globalThreads[0] = gsize;
882    globalThreads[1] = GROUPSIZE_HMORY;
883    localThreads[0] = GROUPSIZE_HMORX;
884    localThreads[1] = GROUPSIZE_HMORY;
885    rEnv.mpkKernel = clCreateKernel(rEnv.mpkProgram, "morphoDilateHor_5x5", &status);
886    CHECK_OPENCL(status, "clCreateKernel morphoDilateHor_5x5");
887    status = clSetKernelArg(rEnv.mpkKernel, 0, sizeof(cl_mem), &pixsCLBuffer);
888    status = clSetKernelArg(rEnv.mpkKernel, 1, sizeof(cl_mem), &pixdCLBuffer);
889    status = clSetKernelArg(rEnv.mpkKernel, 2, sizeof(wpl), &wpl);
890    status = clSetKernelArg(rEnv.mpkKernel, 3, sizeof(h), &h);
891    status = clEnqueueNDRangeKernel(rEnv.mpkCmdQueue, rEnv.mpkKernel, 2, nullptr, globalThreads,
892                                    localThreads, 0, nullptr, nullptr);
893    pixtemp = pixsCLBuffer;
894    pixsCLBuffer = pixdCLBuffer;
895    pixdCLBuffer = pixtemp;
896    gsize = (wpl + GROUPSIZE_X - 1) / GROUPSIZE_X * GROUPSIZE_X;
897    globalThreads[0] = gsize;
898    gsize = (h + GROUPSIZE_Y - 1) / GROUPSIZE_Y * GROUPSIZE_Y;
899    globalThreads[1] = gsize;
900    localThreads[0] = GROUPSIZE_X;
901    localThreads[1] = GROUPSIZE_Y;
902    rEnv.mpkKernel = clCreateKernel(rEnv.mpkProgram, "morphoDilateVer_5x5", &status);
903    CHECK_OPENCL(status, "clCreateKernel morphoDilateVer_5x5");
904    status = clSetKernelArg(rEnv.mpkKernel, 0, sizeof(cl_mem), &pixsCLBuffer);
905    status = clSetKernelArg(rEnv.mpkKernel, 1, sizeof(cl_mem), &pixdCLBuffer);
906    status = clSetKernelArg(rEnv.mpkKernel, 2, sizeof(wpl), &wpl);
907    status = clSetKernelArg(rEnv.mpkKernel, 3, sizeof(h), &h);
908    status = clEnqueueNDRangeKernel(rEnv.mpkCmdQueue, rEnv.mpkKernel, 2, nullptr, globalThreads,
909                                    localThreads, 0, nullptr, nullptr);
910    return status;
911  }
912  static cl_int pixErodeCL_55(l_int32 wpl, l_int32 h) {
913    size_t globalThreads[2];
914    cl_mem pixtemp;
915    cl_int status;
916    int gsize;
917    l_uint32 fwmask, lwmask;
918    size_t localThreads[2];
919    lwmask = lmask32[31 - 2];
920    fwmask = rmask32[31 - 2];
921    gsize = (wpl * h + GROUPSIZE_HMORX - 1) / GROUPSIZE_HMORX * GROUPSIZE_HMORX;
922    globalThreads[0] = gsize;
923    globalThreads[1] = GROUPSIZE_HMORY;
924    localThreads[0] = GROUPSIZE_HMORX;
925    localThreads[1] = GROUPSIZE_HMORY;
926    rEnv.mpkKernel = clCreateKernel(rEnv.mpkProgram, "morphoErodeHor_5x5", &status);
927    CHECK_OPENCL(status, "clCreateKernel morphoErodeHor_5x5");
928    status = clSetKernelArg(rEnv.mpkKernel, 0, sizeof(cl_mem), &pixsCLBuffer);
929    status = clSetKernelArg(rEnv.mpkKernel, 1, sizeof(cl_mem), &pixdCLBuffer);
930    status = clSetKernelArg(rEnv.mpkKernel, 2, sizeof(wpl), &wpl);
931    status = clSetKernelArg(rEnv.mpkKernel, 3, sizeof(h), &h);
932    status = clEnqueueNDRangeKernel(rEnv.mpkCmdQueue, rEnv.mpkKernel, 2, nullptr, globalThreads,
933                                    localThreads, 0, nullptr, nullptr);
934    pixtemp = pixsCLBuffer;
935    pixsCLBuffer = pixdCLBuffer;
936    pixdCLBuffer = pixtemp;
937    gsize = (wpl + GROUPSIZE_X - 1) / GROUPSIZE_X * GROUPSIZE_X;
938    globalThreads[0] = gsize;
939    gsize = (h + GROUPSIZE_Y - 1) / GROUPSIZE_Y * GROUPSIZE_Y;
940    globalThreads[1] = gsize;
941    localThreads[0] = GROUPSIZE_X;
942    localThreads[1] = GROUPSIZE_Y;
943    rEnv.mpkKernel = clCreateKernel(rEnv.mpkProgram, "morphoErodeVer_5x5", &status);
944    CHECK_OPENCL(status, "clCreateKernel morphoErodeVer_5x5");
945    status = clSetKernelArg(rEnv.mpkKernel, 0, sizeof(cl_mem), &pixsCLBuffer);
946    status = clSetKernelArg(rEnv.mpkKernel, 1, sizeof(cl_mem), &pixdCLBuffer);
947    status = clSetKernelArg(rEnv.mpkKernel, 2, sizeof(wpl), &wpl);
948    status = clSetKernelArg(rEnv.mpkKernel, 3, sizeof(h), &h);
949    status = clSetKernelArg(rEnv.mpkKernel, 4, sizeof(fwmask), &fwmask);
950    status = clSetKernelArg(rEnv.mpkKernel, 5, sizeof(lwmask), &lwmask);
951    status = clEnqueueNDRangeKernel(rEnv.mpkCmdQueue, rEnv.mpkKernel, 2, nullptr, globalThreads,
952                                    localThreads, 0, nullptr, nullptr);
953    return status;
954  }
955  static cl_int pixDilateCL(l_int32 hsize, l_int32 vsize, l_int32 wpl, l_int32 h) {
956    l_int32 xp, yp, xn, yn;
957    SEL *sel;
958    size_t globalThreads[2];
959    cl_mem pixtemp;
960    cl_int status = 0;
961    int gsize;
962    size_t localThreads[2];
963    char isEven;
964    OpenclDevice::SetKernelEnv(&rEnv);
965    if (hsize == 5 && vsize == 5) {
966      status = pixDilateCL_55(wpl, h);
967      return status;
968    }
969    sel = selCreateBrick(vsize, hsize, vsize / 2, hsize / 2, SEL_HIT);
970    selFindMaxTranslations(sel, &xp, &yp, &xn, &yn);
971    selDestroy(&sel);
972    gsize = (wpl + GROUPSIZE_X - 1) / GROUPSIZE_X * GROUPSIZE_X;
973    globalThreads[0] = gsize;
974    gsize = (h + GROUPSIZE_Y - 1) / GROUPSIZE_Y * GROUPSIZE_Y;
975    globalThreads[1] = gsize;
976    localThreads[0] = GROUPSIZE_X;
977    localThreads[1] = GROUPSIZE_Y;
978    if (xp > 31 || xn > 31) {
979      rEnv.mpkKernel = clCreateKernel(rEnv.mpkProgram, "morphoDilateHor", &status);
980      CHECK_OPENCL(status, "clCreateKernel morphoDilateHor");
981      status = clSetKernelArg(rEnv.mpkKernel, 0, sizeof(cl_mem), &pixsCLBuffer);
982      status = clSetKernelArg(rEnv.mpkKernel, 1, sizeof(cl_mem), &pixdCLBuffer);
983      status = clSetKernelArg(rEnv.mpkKernel, 2, sizeof(xp), &xp);
984      status = clSetKernelArg(rEnv.mpkKernel, 3, sizeof(xn), &xn);
985      status = clSetKernelArg(rEnv.mpkKernel, 4, sizeof(wpl), &wpl);
986      status = clSetKernelArg(rEnv.mpkKernel, 5, sizeof(h), &h);
987      status = clEnqueueNDRangeKernel(rEnv.mpkCmdQueue, rEnv.mpkKernel, 2, nullptr, globalThreads,
988                                      localThreads, 0, nullptr, nullptr);
989      if (yp > 0 || yn > 0) {
990        pixtemp = pixsCLBuffer;
991        pixsCLBuffer = pixdCLBuffer;
992        pixdCLBuffer = pixtemp;
993      }
994    } else if (xp > 0 || xn > 0) {
995      rEnv.mpkKernel = clCreateKernel(rEnv.mpkProgram, "morphoDilateHor_32word", &status);
996      CHECK_OPENCL(status, "clCreateKernel morphoDilateHor_32word");
997      isEven = (xp != xn);
998      status = clSetKernelArg(rEnv.mpkKernel, 0, sizeof(cl_mem), &pixsCLBuffer);
999      status = clSetKernelArg(rEnv.mpkKernel, 1, sizeof(cl_mem), &pixdCLBuffer);
1000      status = clSetKernelArg(rEnv.mpkKernel, 2, sizeof(xp), &xp);
1001      status = clSetKernelArg(rEnv.mpkKernel, 3, sizeof(wpl), &wpl);
1002      status = clSetKernelArg(rEnv.mpkKernel, 4, sizeof(h), &h);
1003      status = clSetKernelArg(rEnv.mpkKernel, 5, sizeof(isEven), &isEven);
1004      status = clEnqueueNDRangeKernel(rEnv.mpkCmdQueue, rEnv.mpkKernel, 2, nullptr, globalThreads,
1005                                      localThreads, 0, nullptr, nullptr);
1006      if (yp > 0 || yn > 0) {
1007        pixtemp = pixsCLBuffer;
1008        pixsCLBuffer = pixdCLBuffer;
1009        pixdCLBuffer = pixtemp;
1010      }
1011    }
1012    if (yp > 0 || yn > 0) {
1013      rEnv.mpkKernel = clCreateKernel(rEnv.mpkProgram, "morphoDilateVer", &status);
1014      CHECK_OPENCL(status, "clCreateKernel morphoDilateVer");
1015      status = clSetKernelArg(rEnv.mpkKernel, 0, sizeof(cl_mem), &pixsCLBuffer);
1016      status = clSetKernelArg(rEnv.mpkKernel, 1, sizeof(cl_mem), &pixdCLBuffer);
1017      status = clSetKernelArg(rEnv.mpkKernel, 2, sizeof(yp), &yp);
1018      status = clSetKernelArg(rEnv.mpkKernel, 3, sizeof(wpl), &wpl);
1019      status = clSetKernelArg(rEnv.mpkKernel, 4, sizeof(h), &h);
1020      status = clSetKernelArg(rEnv.mpkKernel, 5, sizeof(yn), &yn);
1021      status = clEnqueueNDRangeKernel(rEnv.mpkCmdQueue, rEnv.mpkKernel, 2, nullptr, globalThreads,
1022                                      localThreads, 0, nullptr, nullptr);
1023    }
1024    return status;
1025  }
1026  static cl_int pixErodeCL(l_int32 hsize, l_int32 vsize, l_uint32 wpl, l_uint32 h) {
1027    l_int32 xp, yp, xn, yn;
1028    SEL *sel;
1029    size_t globalThreads[2];
1030    size_t localThreads[2];
1031    cl_mem pixtemp;
1032    cl_int status = 0;
1033    int gsize;
1034    char isAsymmetric = (MORPH_BC == ASYMMETRIC_MORPH_BC);
1035    l_uint32 rwmask, lwmask;
1036    char isEven;
1037    sel = selCreateBrick(vsize, hsize, vsize / 2, hsize / 2, SEL_HIT);
1038    selFindMaxTranslations(sel, &xp, &yp, &xn, &yn);
1039    selDestroy(&sel);
1040    OpenclDevice::SetKernelEnv(&rEnv);
1041    if (hsize == 5 && vsize == 5 && isAsymmetric) {
1042      status = pixErodeCL_55(wpl, h);
1043      return status;
1044    }
1045    lwmask = lmask32[31 - (xn & 31)];
1046    rwmask = rmask32[31 - (xp & 31)];
1047    gsize = (wpl + GROUPSIZE_X - 1) / GROUPSIZE_X * GROUPSIZE_X;
1048    globalThreads[0] = gsize;
1049    gsize = (h + GROUPSIZE_Y - 1) / GROUPSIZE_Y * GROUPSIZE_Y;
1050    globalThreads[1] = gsize;
1051    localThreads[0] = GROUPSIZE_X;
1052    localThreads[1] = GROUPSIZE_Y;
1053    if (xp > 31 || xn > 31) {
1054      rEnv.mpkKernel = clCreateKernel(rEnv.mpkProgram, "morphoErodeHor", &status);
1055      status = clSetKernelArg(rEnv.mpkKernel, 0, sizeof(cl_mem), &pixsCLBuffer);
1056      status = clSetKernelArg(rEnv.mpkKernel, 1, sizeof(cl_mem), &pixdCLBuffer);
1057      status = clSetKernelArg(rEnv.mpkKernel, 2, sizeof(xp), &xp);
1058      status = clSetKernelArg(rEnv.mpkKernel, 3, sizeof(xn), &xn);
1059      status = clSetKernelArg(rEnv.mpkKernel, 4, sizeof(wpl), &wpl);
1060      status = clSetKernelArg(rEnv.mpkKernel, 5, sizeof(h), &h);
1061      status = clSetKernelArg(rEnv.mpkKernel, 6, sizeof(isAsymmetric), &isAsymmetric);
1062      status = clSetKernelArg(rEnv.mpkKernel, 7, sizeof(rwmask), &rwmask);
1063      status = clSetKernelArg(rEnv.mpkKernel, 8, sizeof(lwmask), &lwmask);
1064      status = clEnqueueNDRangeKernel(rEnv.mpkCmdQueue, rEnv.mpkKernel, 2, nullptr, globalThreads,
1065                                      localThreads, 0, nullptr, nullptr);
1066      if (yp > 0 || yn > 0) {
1067        pixtemp = pixsCLBuffer;
1068        pixsCLBuffer = pixdCLBuffer;
1069        pixdCLBuffer = pixtemp;
1070      }
1071    } else if (xp > 0 || xn > 0) {
1072      rEnv.mpkKernel = clCreateKernel(rEnv.mpkProgram, "morphoErodeHor_32word", &status);
1073      isEven = (xp != xn);
1074      status = clSetKernelArg(rEnv.mpkKernel, 0, sizeof(cl_mem), &pixsCLBuffer);
1075      status = clSetKernelArg(rEnv.mpkKernel, 1, sizeof(cl_mem), &pixdCLBuffer);
1076      status = clSetKernelArg(rEnv.mpkKernel, 2, sizeof(xp), &xp);
1077      status = clSetKernelArg(rEnv.mpkKernel, 3, sizeof(wpl), &wpl);
1078      status = clSetKernelArg(rEnv.mpkKernel, 4, sizeof(h), &h);
1079      status = clSetKernelArg(rEnv.mpkKernel, 5, sizeof(isAsymmetric), &isAsymmetric);
1080      status = clSetKernelArg(rEnv.mpkKernel, 6, sizeof(rwmask), &rwmask);
1081      status = clSetKernelArg(rEnv.mpkKernel, 7, sizeof(lwmask), &lwmask);
1082      status = clSetKernelArg(rEnv.mpkKernel, 8, sizeof(isEven), &isEven);
1083      status = clEnqueueNDRangeKernel(rEnv.mpkCmdQueue, rEnv.mpkKernel, 2, nullptr, globalThreads,
1084                                      localThreads, 0, nullptr, nullptr);
1085      if (yp > 0 || yn > 0) {
1086        pixtemp = pixsCLBuffer;
1087        pixsCLBuffer = pixdCLBuffer;
1088        pixdCLBuffer = pixtemp;
1089      }
1090    }
1091    if (yp > 0 || yn > 0) {
1092      rEnv.mpkKernel = clCreateKernel(rEnv.mpkProgram, "morphoErodeVer", &status);
1093      CHECK_OPENCL(status, "clCreateKernel morphoErodeVer");
1094      status = clSetKernelArg(rEnv.mpkKernel, 0, sizeof(cl_mem), &pixsCLBuffer);
1095      status = clSetKernelArg(rEnv.mpkKernel, 1, sizeof(cl_mem), &pixdCLBuffer);
1096      status = clSetKernelArg(rEnv.mpkKernel, 2, sizeof(yp), &yp);
1097      status = clSetKernelArg(rEnv.mpkKernel, 3, sizeof(wpl), &wpl);
1098      status = clSetKernelArg(rEnv.mpkKernel, 4, sizeof(h), &h);
1099      status = clSetKernelArg(rEnv.mpkKernel, 5, sizeof(isAsymmetric), &isAsymmetric);
1100      status = clSetKernelArg(rEnv.mpkKernel, 6, sizeof(yn), &yn);
1101      status = clEnqueueNDRangeKernel(rEnv.mpkCmdQueue, rEnv.mpkKernel, 2, nullptr, globalThreads,
1102                                      localThreads, 0, nullptr, nullptr);
1103    }
1104    return status;
1105  }
1106  static cl_int pixOpenCL(l_int32 hsize, l_int32 vsize, l_int32 wpl, l_int32 h) {
1107    cl_int status;
1108    cl_mem pixtemp;
1109    status = pixErodeCL(hsize, vsize, wpl, h);
1110    pixtemp = pixsCLBuffer;
1111    pixsCLBuffer = pixdCLBuffer;
1112    pixdCLBuffer = pixtemp;
1113    status = pixDilateCL(hsize, vsize, wpl, h);
1114    return status;
1115  }
1116  static cl_int pixCloseCL(l_int32 hsize, l_int32 vsize, l_int32 wpl, l_int32 h) {
1117    cl_int status;
1118    cl_mem pixtemp;
1119    status = pixDilateCL(hsize, vsize, wpl, h);
1120    pixtemp = pixsCLBuffer;
1121    pixsCLBuffer = pixdCLBuffer;
1122    pixdCLBuffer = pixtemp;
1123    status = pixErodeCL(hsize, vsize, wpl, h);
1124    return status;
1125  }
1126  static cl_int pixSubtractCL_work(l_uint32 wpl, l_uint32 h, cl_mem buffer1, cl_mem buffer2) {
1127    cl_int status;
1128    size_t globalThreads[2];
1129    int gsize;
1130    size_t localThreads[] = {GROUPSIZE_X, GROUPSIZE_Y};
1131    gsize = (wpl + GROUPSIZE_X - 1) / GROUPSIZE_X * GROUPSIZE_X;
1132    globalThreads[0] = gsize;
1133    gsize = (h + GROUPSIZE_Y - 1) / GROUPSIZE_Y * GROUPSIZE_Y;
1134    globalThreads[1] = gsize;
1135    rEnv.mpkKernel = clCreateKernel(rEnv.mpkProgram, "pixSubtract_inplace", &status);
1136    CHECK_OPENCL(status, "clCreateKernel pixSubtract_inplace");
1137    status = clSetKernelArg(rEnv.mpkKernel, 0, sizeof(cl_mem), &buffer1);
1138    status = clSetKernelArg(rEnv.mpkKernel, 1, sizeof(cl_mem), &buffer2);
1139    status = clSetKernelArg(rEnv.mpkKernel, 2, sizeof(wpl), &wpl);
1140    status = clSetKernelArg(rEnv.mpkKernel, 3, sizeof(h), &h);
1141    status = clEnqueueNDRangeKernel(rEnv.mpkCmdQueue, rEnv.mpkKernel, 2, nullptr, globalThreads,
1142                                    localThreads, 0, nullptr, nullptr);
1143    return status;
1144  }
1145  void OpenclDevice::pixGetLinesCL(Image pixd, Image pixs, Image *pix_vline, Image *pix_hline,
1146                                   Image *pixClosed, bool getpixClosed, l_int32 close_hsize,
1147                                   l_int32 close_vsize, l_int32 open_hsize, l_int32 open_vsize,
1148                                   l_int32 line_hsize, l_int32 line_vsize) {
1149    l_uint32 wpl, h;
1150    cl_mem pixtemp;
1151    wpl = pixGetWpl(pixs);
1152    h = pixGetHeight(pixs);
1153    clStatus = pixCloseCL(close_hsize, close_vsize, wpl, h);
1154    if (getpixClosed) {
1155      *pixClosed =
1156          mapOutputCLBuffer(rEnv, pixdCLBuffer, *pixClosed, pixs, wpl * h, CL_MAP_READ, true, false);
1157    }
1158    clStatus = clEnqueueCopyBuffer(rEnv.mpkCmdQueue, pixdCLBuffer, pixdCLIntermediate, 0, 0,
1159                                   sizeof(int) * wpl * h, 0, nullptr, nullptr);
1160    pixtemp = pixsCLBuffer;
1161    pixsCLBuffer = pixdCLBuffer;
1162    pixdCLBuffer = pixtemp;
1163    clStatus = pixOpenCL(open_hsize, open_vsize, wpl, h);
1164    pixtemp = pixsCLBuffer;
1165    pixsCLBuffer = pixdCLBuffer;
1166    pixdCLBuffer = pixdCLIntermediate;
1167    pixdCLIntermediate = pixtemp;
1168    clStatus = pixSubtractCL_work(wpl, h, pixdCLBuffer, pixsCLBuffer);
1169    clStatus = clEnqueueCopyBuffer(rEnv.mpkCmdQueue, pixdCLBuffer, pixdCLIntermediate, 0, 0,
1170                                   sizeof(int) * wpl * h, 0, nullptr, nullptr);
1171    pixtemp = pixsCLBuffer;
1172    pixsCLBuffer = pixdCLBuffer;
1173    pixdCLBuffer = pixtemp;
1174    clStatus = pixOpenCL(1, line_vsize, wpl, h);
1175    *pix_vline =
1176        mapOutputCLBuffer(rEnv, pixdCLBuffer, *pix_vline, pixs, wpl * h, CL_MAP_READ, true, false);
1177    pixtemp = pixsCLBuffer;
1178    pixsCLBuffer = pixdCLIntermediate;
1179    pixdCLIntermediate = pixtemp;
1180    clStatus = pixOpenCL(line_hsize, 1, wpl, h);
1181    *pix_hline =
1182        mapOutputCLBuffer(rEnv, pixdCLBuffer, *pix_hline, pixs, wpl * h, CL_MAP_READ, true, true);
1183    return;
1184  }
1185  int OpenclDevice::HistogramRectOCL(void *imageData, int bytes_per_pixel, int bytes_per_line,
1186                                     int left, 
1187                                     int top,  
1188                                     int width, int height, int kHistogramSize,
1189                                     int *histogramAllChannels) {
1190    cl_int clStatus;
1191    int retVal = 0;
1192    KernelEnv histKern;
1193    SetKernelEnv(&histKern);
1194    KernelEnv histRedKern;
1195    SetKernelEnv(&histRedKern);
1196    cl_mem imageBuffer =
1197        clCreateBuffer(histKern.mpkContext, CL_MEM_READ_ONLY | CL_MEM_USE_HOST_PTR,
1198                       width * height * bytes_per_pixel * sizeof(char), imageData, &clStatus);
1199    CHECK_OPENCL(clStatus, "clCreateBuffer imageBuffer");
1200    int block_size = 256;
1201    cl_uint numCUs;
1202    clStatus = clGetDeviceInfo(gpuEnv.mpDevID, CL_DEVICE_MAX_COMPUTE_UNITS, sizeof(numCUs), &numCUs,
1203                               nullptr);
1204    CHECK_OPENCL(clStatus, "clCreateBuffer imageBuffer");
1205    int requestedOccupancy = 10;
1206    int numWorkGroups = numCUs * requestedOccupancy;
1207    int numThreads = block_size * numWorkGroups;
1208    size_t local_work_size[] = {static_cast<size_t>(block_size)};
1209    size_t global_work_size[] = {static_cast<size_t>(numThreads)};
1210    size_t red_global_work_size[] = {
1211        static_cast<size_t>(block_size * kHistogramSize * bytes_per_pixel)};
1212    cl_mem histogramBuffer = clCreateBuffer(
1213        histKern.mpkContext, CL_MEM_READ_WRITE | CL_MEM_USE_HOST_PTR,
1214        kHistogramSize * bytes_per_pixel * sizeof(int), histogramAllChannels, &clStatus);
1215    CHECK_OPENCL(clStatus, "clCreateBuffer histogramBuffer");
1216    int histRed = 256;
1217    int tmpHistogramBins = kHistogramSize * bytes_per_pixel * histRed;
1218    cl_mem tmpHistogramBuffer =
1219        clCreateBuffer(histKern.mpkContext, CL_MEM_READ_WRITE, tmpHistogramBins * sizeof(cl_uint),
1220                       nullptr, &clStatus);
1221    CHECK_OPENCL(clStatus, "clCreateBuffer tmpHistogramBuffer");
1222    int *zeroBuffer = new int[1];
1223    zeroBuffer[0] = 0;
1224    cl_mem atomicSyncBuffer =
1225        clCreateBuffer(histKern.mpkContext, CL_MEM_READ_WRITE | CL_MEM_COPY_HOST_PTR, sizeof(cl_int),
1226                       zeroBuffer, &clStatus);
1227    CHECK_OPENCL(clStatus, "clCreateBuffer atomicSyncBuffer");
1228    delete[] zeroBuffer;
1229    if (bytes_per_pixel == 1) {
1230      histKern.mpkKernel =
1231          clCreateKernel(histKern.mpkProgram, "kernel_HistogramRectOneChannel", &clStatus);
1232      CHECK_OPENCL(clStatus, "clCreateKernel kernel_HistogramRectOneChannel");
1233      histRedKern.mpkKernel = clCreateKernel(histRedKern.mpkProgram,
1234                                             "kernel_HistogramRectOneChannelReduction", &clStatus);
1235      CHECK_OPENCL(clStatus, "clCreateKernel kernel_HistogramRectOneChannelReduction");
1236    } else {
1237      histKern.mpkKernel =
1238          clCreateKernel(histKern.mpkProgram, "kernel_HistogramRectAllChannels", &clStatus);
1239      CHECK_OPENCL(clStatus, "clCreateKernel kernel_HistogramRectAllChannels");
1240      histRedKern.mpkKernel = clCreateKernel(histRedKern.mpkProgram,
1241                                             "kernel_HistogramRectAllChannelsReduction", &clStatus);
1242      CHECK_OPENCL(clStatus, "clCreateKernel kernel_HistogramRectAllChannelsReduction");
1243    }
1244    void *ptr;
1245    ptr = clEnqueueMapBuffer(histKern.mpkCmdQueue, tmpHistogramBuffer, CL_TRUE, CL_MAP_WRITE, 0,
1246                             tmpHistogramBins * sizeof(cl_uint), 0, nullptr, nullptr, &clStatus);
1247    CHECK_OPENCL(clStatus, "clEnqueueMapBuffer tmpHistogramBuffer");
1248    memset(ptr, 0, tmpHistogramBins * sizeof(cl_uint));
1249    clEnqueueUnmapMemObject(histKern.mpkCmdQueue, tmpHistogramBuffer, ptr, 0, nullptr, nullptr);
1250    clStatus = clSetKernelArg(histKern.mpkKernel, 0, sizeof(cl_mem), &imageBuffer);
1251    CHECK_OPENCL(clStatus, "clSetKernelArg imageBuffer");
1252    cl_uint numPixels = width * height;
1253    clStatus = clSetKernelArg(histKern.mpkKernel, 1, sizeof(cl_uint), &numPixels);
1254    CHECK_OPENCL(clStatus, "clSetKernelArg numPixels");
1255    clStatus = clSetKernelArg(histKern.mpkKernel, 2, sizeof(cl_mem), &tmpHistogramBuffer);
1256    CHECK_OPENCL(clStatus, "clSetKernelArg tmpHistogramBuffer");
1257    int n = numThreads / bytes_per_pixel;
1258    clStatus = clSetKernelArg(histRedKern.mpkKernel, 0, sizeof(cl_int), &n);
1259    CHECK_OPENCL(clStatus, "clSetKernelArg imageBuffer");
1260    clStatus = clSetKernelArg(histRedKern.mpkKernel, 1, sizeof(cl_mem), &tmpHistogramBuffer);
1261    CHECK_OPENCL(clStatus, "clSetKernelArg tmpHistogramBuffer");
1262    clStatus = clSetKernelArg(histRedKern.mpkKernel, 2, sizeof(cl_mem), &histogramBuffer);
1263    CHECK_OPENCL(clStatus, "clSetKernelArg histogramBuffer");
1264    clStatus = clEnqueueNDRangeKernel(histKern.mpkCmdQueue, histKern.mpkKernel, 1, nullptr,
1265                                      global_work_size, local_work_size, 0, nullptr, nullptr);
1266    CHECK_OPENCL(clStatus, "clEnqueueNDRangeKernel kernel_HistogramRectAllChannels");
1267    clFinish(histKern.mpkCmdQueue);
1268    if (clStatus != 0) {
1269      retVal = -1;
1270    }
1271    clStatus = clEnqueueNDRangeKernel(histRedKern.mpkCmdQueue, histRedKern.mpkKernel, 1, nullptr,
1272                                      red_global_work_size, local_work_size, 0, nullptr, nullptr);
1273    CHECK_OPENCL(clStatus, "clEnqueueNDRangeKernel kernel_HistogramRectAllChannelsReduction");
1274    clFinish(histRedKern.mpkCmdQueue);
1275    if (clStatus != 0) {
1276      retVal = -1;
1277    }
1278    ptr = clEnqueueMapBuffer(histRedKern.mpkCmdQueue, histogramBuffer, CL_TRUE, CL_MAP_READ, 0,
1279                             kHistogramSize * bytes_per_pixel * sizeof(int), 0, nullptr, nullptr,
1280                             &clStatus);
1281    CHECK_OPENCL(clStatus, "clEnqueueMapBuffer histogramBuffer");
1282    if (clStatus != 0) {
1283      retVal = -1;
1284    }
1285    clEnqueueUnmapMemObject(histRedKern.mpkCmdQueue, histogramBuffer, ptr, 0, nullptr, nullptr);
1286    clReleaseMemObject(histogramBuffer);
1287    clReleaseMemObject(imageBuffer);
1288    return retVal;
1289  }
1290  int OpenclDevice::ThresholdRectToPixOCL(unsigned char *imageData, int bytes_per_pixel,
1291                                          int bytes_per_line, int *thresholds, int *hi_values,
1292                                          Image *pix, int height, int width, int top, int left) {
1293    int retVal = 0;
1294    *pix = pixCreate(width, height, 1);
1295    uint32_t *pixData = pixGetData(*pix);
1296    int wpl = pixGetWpl(*pix);
1297    int pixSize = wpl * height * sizeof(uint32_t); 
1298    cl_int clStatus;
<span onclick='openModal()' class='match'>1299    KernelEnv rEnv;
1300    SetKernelEnv(&rEnv);
1301    int block_size = 256;
1302    cl_uint numCUs = 6;
</span>1303    clStatus = clGetDeviceInfo(gpuEnv.mpDevID, CL_DEVICE_MAX_COMPUTE_UNITS, sizeof(numCUs), &numCUs,
1304                               nullptr);
1305    CHECK_OPENCL(clStatus, "clCreateBuffer imageBuffer");
1306    int requestedOccupancy = 10;
1307    int numWorkGroups = numCUs * requestedOccupancy;
1308    int numThreads = block_size * numWorkGroups;
1309    size_t local_work_size[] = {(size_t)block_size};
1310    size_t global_work_size[] = {(size_t)numThreads};
1311    cl_mem imageBuffer =
1312        clCreateBuffer(rEnv.mpkContext, CL_MEM_READ_ONLY | CL_MEM_USE_HOST_PTR,
1313                       width * height * bytes_per_pixel * sizeof(char), imageData, &clStatus);
1314    CHECK_OPENCL(clStatus, "clCreateBuffer imageBuffer");
1315    pixThBuffer = clCreateBuffer(rEnv.mpkContext, CL_MEM_READ_WRITE | CL_MEM_USE_HOST_PTR, pixSize,
1316                                 pixData, &clStatus);
1317    CHECK_OPENCL(clStatus, "clCreateBuffer pix");
1318    cl_mem thresholdsBuffer = clCreateBuffer(rEnv.mpkContext, CL_MEM_READ_ONLY | CL_MEM_USE_HOST_PTR,
1319                                             bytes_per_pixel * sizeof(int), thresholds, &clStatus);
1320    CHECK_OPENCL(clStatus, "clCreateBuffer thresholdBuffer");
1321    cl_mem hiValuesBuffer = clCreateBuffer(rEnv.mpkContext, CL_MEM_READ_ONLY | CL_MEM_USE_HOST_PTR,
1322                                           bytes_per_pixel * sizeof(int), hi_values, &clStatus);
1323    CHECK_OPENCL(clStatus, "clCreateBuffer hiValuesBuffer");
1324    if (bytes_per_pixel == 4) {
1325      rEnv.mpkKernel = clCreateKernel(rEnv.mpkProgram, "kernel_ThresholdRectToPix", &clStatus);
1326      CHECK_OPENCL(clStatus, "clCreateKernel kernel_ThresholdRectToPix");
1327    } else {
1328      rEnv.mpkKernel =
1329          clCreateKernel(rEnv.mpkProgram, "kernel_ThresholdRectToPix_OneChan", &clStatus);
1330      CHECK_OPENCL(clStatus, "clCreateKernel kernel_ThresholdRectToPix_OneChan");
1331    }
1332    clStatus = clSetKernelArg(rEnv.mpkKernel, 0, sizeof(cl_mem), &imageBuffer);
1333    CHECK_OPENCL(clStatus, "clSetKernelArg imageBuffer");
1334    clStatus = clSetKernelArg(rEnv.mpkKernel, 1, sizeof(int), &height);
1335    CHECK_OPENCL(clStatus, "clSetKernelArg height");
1336    clStatus = clSetKernelArg(rEnv.mpkKernel, 2, sizeof(int), &width);
1337    CHECK_OPENCL(clStatus, "clSetKernelArg width");
1338    clStatus = clSetKernelArg(rEnv.mpkKernel, 3, sizeof(int), &wpl);
1339    CHECK_OPENCL(clStatus, "clSetKernelArg wpl");
1340    clStatus = clSetKernelArg(rEnv.mpkKernel, 4, sizeof(cl_mem), &thresholdsBuffer);
1341    CHECK_OPENCL(clStatus, "clSetKernelArg thresholdsBuffer");
1342    clStatus = clSetKernelArg(rEnv.mpkKernel, 5, sizeof(cl_mem), &hiValuesBuffer);
1343    CHECK_OPENCL(clStatus, "clSetKernelArg hiValuesBuffer");
1344    clStatus = clSetKernelArg(rEnv.mpkKernel, 6, sizeof(cl_mem), &pixThBuffer);
1345    CHECK_OPENCL(clStatus, "clSetKernelArg pixThBuffer");
1346    clStatus = clEnqueueNDRangeKernel(rEnv.mpkCmdQueue, rEnv.mpkKernel, 1, nullptr, global_work_size,
1347                                      local_work_size, 0, nullptr, nullptr);
1348    CHECK_OPENCL(clStatus, "clEnqueueNDRangeKernel kernel_ThresholdRectToPix");
1349    clFinish(rEnv.mpkCmdQueue);
1350    if (clStatus != 0) {
1351      tprintf("Setting return value to -1\n");
1352      retVal = -1;
1353    }
1354    void *ptr = clEnqueueMapBuffer(rEnv.mpkCmdQueue, pixThBuffer, CL_TRUE, CL_MAP_READ, 0, pixSize, 0,
1355                                   nullptr, nullptr, &clStatus);
1356    CHECK_OPENCL(clStatus, "clEnqueueMapBuffer histogramBuffer");
1357    clEnqueueUnmapMemObject(rEnv.mpkCmdQueue, pixThBuffer, ptr, 0, nullptr, nullptr);
1358    clReleaseMemObject(imageBuffer);
1359    clReleaseMemObject(thresholdsBuffer);
1360    clReleaseMemObject(hiValuesBuffer);
1361    return retVal;
1362  }
1363  struct TessScoreEvaluationInputData {
1364    int height;
1365    int width;
1366    int numChannels;
1367    unsigned char *imageData;
1368    Image pix;
1369  };
1370  static void populateTessScoreEvaluationInputData(TessScoreEvaluationInputData *input) {
1371    srand(1);
1372    int height = 3328; 
1373    int width = 2560;  
1374    int numChannels = 4;
1375    input->height = height;
1376    input->width = width;
1377    input->numChannels = numChannels;
1378    unsigned char(*imageData4)[4] = (unsigned char(*)[4])malloc(
1379        height * width * numChannels * sizeof(unsigned char)); 
1380    input->imageData = (unsigned char *)&imageData4[0];
1381    unsigned char pixelWhite[4] = {0, 0, 0, 255};
1382    unsigned char pixelBlack[4] = {255, 255, 255, 255};
1383    for (int p = 0; p < height * width; p++) {
1384      imageData4[p][0] = pixelWhite[0];
1385      imageData4[p][1] = pixelWhite[1];
1386      imageData4[p][2] = pixelWhite[2];
1387      imageData4[p][3] = pixelWhite[3];
1388    }
1389    int maxLineWidth = 64; 
1390    int numLines = 10;
1391    for (int i = 0; i < numLines; i++) {
1392      int lineWidth = rand() % maxLineWidth;
1393      int vertLinePos = lineWidth + rand() % (width - 2 * lineWidth);
1394      for (int row = vertLinePos - lineWidth / 2; row < vertLinePos + lineWidth / 2; row++) {
1395        for (int col = 0; col < height; col++) {
1396          imageData4[row * width + col][0] = pixelBlack[0];
1397          imageData4[row * width + col][1] = pixelBlack[1];
1398          imageData4[row * width + col][2] = pixelBlack[2];
1399          imageData4[row * width + col][3] = pixelBlack[3];
1400        }
1401      }
1402    }
1403    for (int i = 0; i < numLines; i++) {
1404      int lineWidth = rand() % maxLineWidth;
1405      int horLinePos = lineWidth + rand() % (height - 2 * lineWidth);
1406      for (int row = 0; row < width; row++) {
1407        for (int col = horLinePos - lineWidth / 2; col < horLinePos + lineWidth / 2;
1408             col++) { 
1409          imageData4[row * width + col][0] = pixelBlack[0];
1410          imageData4[row * width + col][1] = pixelBlack[1];
1411          imageData4[row * width + col][2] = pixelBlack[2];
1412          imageData4[row * width + col][3] = pixelBlack[3];
1413        }
1414      }
1415    }
1416    float fractionBlack = 0.1; 
1417    int numSpots = (height * width) * fractionBlack / (maxLineWidth * maxLineWidth / 2 / 2);
1418    for (int i = 0; i < numSpots; i++) {
1419      int lineWidth = rand() % maxLineWidth;
1420      int col = lineWidth + rand() % (width - 2 * lineWidth);
1421      int row = lineWidth + rand() % (height - 2 * lineWidth);
1422      for (int r = row - lineWidth / 2; r < row + lineWidth / 2; r++) {
1423        for (int c = col - lineWidth / 2; c < col + lineWidth / 2; c++) {
1424          imageData4[r * width + c][0] = pixelBlack[0];
1425          imageData4[r * width + c][1] = pixelBlack[1];
1426          imageData4[r * width + c][2] = pixelBlack[2];
1427          imageData4[r * width + c][3] = pixelBlack[3];
1428        }
1429      }
1430    }
1431    input->pix = pixCreate(input->width, input->height, 8 * input->numChannels);
1432  }
1433  struct TessDeviceScore {
1434    float time;   
1435    bool clError; 
1436    bool valid;   
1437  };
1438  static double composeRGBPixelMicroBench(GPUEnv *env, TessScoreEvaluationInputData input,
1439                                          ds_device_type type) {
1440    double time = 0;
1441  #  if ON_WINDOWS
1442    LARGE_INTEGER freq, time_funct_start, time_funct_end;
1443    QueryPerformanceFrequency(&freq);
1444  #  elif ON_APPLE
1445    mach_timebase_info_data_t info = {0, 0};
1446    mach_timebase_info(&info);
1447    long long start, stop;
1448  #  else
1449    timespec time_funct_start, time_funct_end;
1450  #  endif
1451    l_uint32 *tiffdata = (l_uint32 *)input.imageData; 
1452    if (type == DS_DEVICE_OPENCL_DEVICE) {
1453  #  if ON_WINDOWS
1454      QueryPerformanceCounter(&time_funct_start);
1455  #  elif ON_APPLE
1456      start = mach_absolute_time();
1457  #  else
1458      clock_gettime(CLOCK_MONOTONIC, &time_funct_start);
1459  #  endif
1460      OpenclDevice::gpuEnv = *env;
1461      int wpl = pixGetWpl(input.pix);
1462      OpenclDevice::pixReadFromTiffKernel(tiffdata, input.width, input.height, wpl, nullptr);
1463  #  if ON_WINDOWS
1464      QueryPerformanceCounter(&time_funct_end);
1465      time = (time_funct_end.QuadPart - time_funct_start.QuadPart) / (double)(freq.QuadPart);
1466  #  elif ON_APPLE
1467      stop = mach_absolute_time();
1468      time = ((stop - start) * (double)info.numer / info.denom) / 1.0E9;
1469  #  else
1470      clock_gettime(CLOCK_MONOTONIC, &time_funct_end);
1471      time = (time_funct_end.tv_sec - time_funct_start.tv_sec) * 1.0 +
1472             (time_funct_end.tv_nsec - time_funct_start.tv_nsec) / 1000000000.0;
1473  #  endif
1474    } else {
1475  #  if ON_WINDOWS
1476      QueryPerformanceCounter(&time_funct_start);
1477  #  elif ON_APPLE
1478      start = mach_absolute_time();
1479  #  else
1480      clock_gettime(CLOCK_MONOTONIC, &time_funct_start);
1481  #  endif
1482      Image pix = pixCreate(input.width, input.height, 32);
1483      l_uint32 *pixData = pixGetData(pix);
1484      int i, j;
1485      int idx = 0;
1486      for (i = 0; i < input.height; i++) {
1487        for (j = 0; j < input.width; j++) {
1488          l_uint32 tiffword = tiffdata[i * input.width + j];
1489          l_int32 rval = ((tiffword)&0xff);
1490          l_int32 gval = (((tiffword) >> 8) & 0xff);
1491          l_int32 bval = (((tiffword) >> 16) & 0xff);
1492          l_uint32 value = (rval << 24) | (gval << 16) | (bval << 8);
1493          pixData[idx] = value;
1494          idx++;
1495        }
1496      }
1497  #  if ON_WINDOWS
1498      QueryPerformanceCounter(&time_funct_end);
1499      time = (time_funct_end.QuadPart - time_funct_start.QuadPart) / (double)(freq.QuadPart);
1500  #  elif ON_APPLE
1501      stop = mach_absolute_time();
1502      time = ((stop - start) * (double)info.numer / info.denom) / 1.0E9;
1503  #  else
1504      clock_gettime(CLOCK_MONOTONIC, &time_funct_end);
1505      time = (time_funct_end.tv_sec - time_funct_start.tv_sec) * 1.0 +
1506             (time_funct_end.tv_nsec - time_funct_start.tv_nsec) / 1000000000.0;
1507  #  endif
1508      pix.destroy();
1509    }
1510    return time;
1511  }
1512  static double histogramRectMicroBench(GPUEnv *env, TessScoreEvaluationInputData input,
1513                                        ds_device_type type) {
1514    double time;
1515  #  if ON_WINDOWS
1516    LARGE_INTEGER freq, time_funct_start, time_funct_end;
1517    QueryPerformanceFrequency(&freq);
1518  #  elif ON_APPLE
1519    mach_timebase_info_data_t info = {0, 0};
1520    mach_timebase_info(&info);
1521    long long start, stop;
1522  #  else
1523    timespec time_funct_start, time_funct_end;
1524  #  endif
1525    const int left = 0;
1526    const int top = 0;
1527    int kHistogramSize = 256;
1528    int bytes_per_line = input.width * input.numChannels;
1529    int *histogramAllChannels = new int[kHistogramSize * input.numChannels];
1530    if (type == DS_DEVICE_OPENCL_DEVICE) {
1531  #  if ON_WINDOWS
1532      QueryPerformanceCounter(&time_funct_start);
1533  #  elif ON_APPLE
1534      start = mach_absolute_time();
1535  #  else
1536      clock_gettime(CLOCK_MONOTONIC, &time_funct_start);
1537  #  endif
1538      OpenclDevice::gpuEnv = *env;
1539      int retVal = OpenclDevice::HistogramRectOCL(input.imageData, input.numChannels, bytes_per_line,
1540                                                  left, top, input.width, input.height,
1541                                                  kHistogramSize, histogramAllChannels);
1542  #  if ON_WINDOWS
1543      QueryPerformanceCounter(&time_funct_end);
1544      time = (time_funct_end.QuadPart - time_funct_start.QuadPart) / (double)(freq.QuadPart);
1545  #  elif ON_APPLE
1546      stop = mach_absolute_time();
1547      if (retVal == 0) {
1548        time = ((stop - start) * (double)info.numer / info.denom) / 1.0E9;
1549      } else {
1550        time = FLT_MAX;
1551      }
1552  #  else
1553      clock_gettime(CLOCK_MONOTONIC, &time_funct_end);
1554      time = (time_funct_end.tv_sec - time_funct_start.tv_sec) * 1.0 +
1555             (time_funct_end.tv_nsec - time_funct_start.tv_nsec) / 1000000000.0;
1556  #  endif
1557    } else {
1558      int *histogram = new int[kHistogramSize];
1559  #  if ON_WINDOWS
1560      QueryPerformanceCounter(&time_funct_start);
1561  #  elif ON_APPLE
1562      start = mach_absolute_time();
1563  #  else
1564      clock_gettime(CLOCK_MONOTONIC, &time_funct_start);
1565  #  endif
1566      for (int ch = 0; ch < input.numChannels; ++ch) {
1567        tesseract::HistogramRect(input.pix, input.numChannels, left, top, input.width, input.height,
1568                                 histogram);
1569      }
1570  #  if ON_WINDOWS
1571      QueryPerformanceCounter(&time_funct_end);
1572      time = (time_funct_end.QuadPart - time_funct_start.QuadPart) / (double)(freq.QuadPart);
1573  #  elif ON_APPLE
1574      stop = mach_absolute_time();
1575      time = ((stop - start) * (double)info.numer / info.denom) / 1.0E9;
1576  #  else
1577      clock_gettime(CLOCK_MONOTONIC, &time_funct_end);
1578      time = (time_funct_end.tv_sec - time_funct_start.tv_sec) * 1.0 +
1579             (time_funct_end.tv_nsec - time_funct_start.tv_nsec) / 1000000000.0;
1580  #  endif
1581      delete[] histogram;
1582    }
1583    delete[] histogramAllChannels;
1584    return time;
1585  }
1586  static void ThresholdRectToPix_Native(const unsigned char *imagedata, int bytes_per_pixel,
1587                                        int bytes_per_line, const int *thresholds,
1588                                        const int *hi_values, Image *pix) {
1589    int top = 0;
1590    int left = 0;
1591    int width = pixGetWidth(*pix);
1592    int height = pixGetHeight(*pix);
1593    *pix = pixCreate(width, height, 1);
1594    uint32_t *pixdata = pixGetData(*pix);
1595    int wpl = pixGetWpl(*pix);
1596    const unsigned char *srcdata = imagedata + top * bytes_per_line + left * bytes_per_pixel;
1597    for (int y = 0; y < height; ++y) {
1598      const uint8_t *linedata = srcdata;
1599      uint32_t *pixline = pixdata + y * wpl;
1600      for (int x = 0; x < width; ++x, linedata += bytes_per_pixel) {
1601        bool white_result = true;
1602        for (int ch = 0; ch < bytes_per_pixel; ++ch) {
1603          if (hi_values[ch] >= 0 && (linedata[ch] > thresholds[ch]) == (hi_values[ch] == 0)) {
1604            white_result = false;
1605            break;
1606          }
1607        }
1608        if (white_result)
1609          CLEAR_DATA_BIT(pixline, x);
1610        else
1611          SET_DATA_BIT(pixline, x);
1612      }
1613      srcdata += bytes_per_line;
1614    }
1615  }
1616  static double thresholdRectToPixMicroBench(GPUEnv *env, TessScoreEvaluationInputData input,
1617                                             ds_device_type type) {
1618    double time;
1619  #  if ON_WINDOWS
1620    LARGE_INTEGER freq, time_funct_start, time_funct_end;
1621    QueryPerformanceFrequency(&freq);
1622  #  elif ON_APPLE
1623    mach_timebase_info_data_t info = {0, 0};
1624    mach_timebase_info(&info);
1625    long long start, stop;
1626  #  else
1627    timespec time_funct_start, time_funct_end;
1628  #  endif
1629    unsigned char pixelHi = (unsigned char)255;
1630    int thresholds[4] = {pixelHi, pixelHi, pixelHi, pixelHi};
1631    int top = 0;
1632    int left = 0;
1633    int bytes_per_line = input.width * input.numChannels;
1634    if (type == DS_DEVICE_OPENCL_DEVICE) {
1635  #  if ON_WINDOWS
1636      QueryPerformanceCounter(&time_funct_start);
1637  #  elif ON_APPLE
1638      start = mach_absolute_time();
1639  #  else
1640      clock_gettime(CLOCK_MONOTONIC, &time_funct_start);
1641  #  endif
1642      OpenclDevice::gpuEnv = *env;
1643      int hi_values[4];
1644      int retVal = OpenclDevice::ThresholdRectToPixOCL(
1645          input.imageData, input.numChannels, bytes_per_line, thresholds, hi_values, &input.pix,
1646          input.height, input.width, top, left);
1647  #  if ON_WINDOWS
1648      QueryPerformanceCounter(&time_funct_end);
1649      time = (time_funct_end.QuadPart - time_funct_start.QuadPart) / (double)(freq.QuadPart);
1650  #  elif ON_APPLE
1651      stop = mach_absolute_time();
1652      if (retVal == 0) {
1653        time = ((stop - start) * (double)info.numer / info.denom) / 1.0E9;
1654      } else {
1655        time = FLT_MAX;
1656      }
1657  #  else
1658      clock_gettime(CLOCK_MONOTONIC, &time_funct_end);
1659      time = (time_funct_end.tv_sec - time_funct_start.tv_sec) * 1.0 +
1660             (time_funct_end.tv_nsec - time_funct_start.tv_nsec) / 1000000000.0;
1661  #  endif
1662    } else {
1663      tesseract::ImageThresholder thresholder;
1664      thresholder.SetImage(input.pix);
1665  #  if ON_WINDOWS
1666      QueryPerformanceCounter(&time_funct_start);
1667  #  elif ON_APPLE
1668      start = mach_absolute_time();
1669  #  else
1670      clock_gettime(CLOCK_MONOTONIC, &time_funct_start);
1671  #  endif
1672      int hi_values[4] = {};
1673      ThresholdRectToPix_Native(input.imageData, input.numChannels, bytes_per_line, thresholds,
1674                                hi_values, &input.pix);
1675  #  if ON_WINDOWS
1676      QueryPerformanceCounter(&time_funct_end);
1677      time = (time_funct_end.QuadPart - time_funct_start.QuadPart) / (double)(freq.QuadPart);
1678  #  elif ON_APPLE
1679      stop = mach_absolute_time();
1680      time = ((stop - start) * (double)info.numer / info.denom) / 1.0E9;
1681  #  else
1682      clock_gettime(CLOCK_MONOTONIC, &time_funct_end);
1683      time = (time_funct_end.tv_sec - time_funct_start.tv_sec) * 1.0 +
1684             (time_funct_end.tv_nsec - time_funct_start.tv_nsec) / 1000000000.0;
1685  #  endif
1686    }
1687    return time;
1688  }
1689  static double getLineMasksMorphMicroBench(GPUEnv *env, TessScoreEvaluationInputData input,
1690                                            ds_device_type type) {
1691    double time = 0;
1692  #  if ON_WINDOWS
1693    LARGE_INTEGER freq, time_funct_start, time_funct_end;
1694    QueryPerformanceFrequency(&freq);
1695  #  elif ON_APPLE
1696    mach_timebase_info_data_t info = {0, 0};
1697    mach_timebase_info(&info);
1698    long long start, stop;
1699  #  else
1700    timespec time_funct_start, time_funct_end;
1701  #  endif
1702    int resolution = 300;
1703    int wpl = pixGetWpl(input.pix);
1704    int kThinLineFraction = 20;     
1705    int kMinLineLengthFraction = 4; 
1706    int max_line_width = resolution / kThinLineFraction;
1707    int min_line_length = resolution / kMinLineLengthFraction;
1708    int closing_brick = max_line_width / 3;
1709    if (type == DS_DEVICE_OPENCL_DEVICE) {
1710  #  if ON_WINDOWS
1711      QueryPerformanceCounter(&time_funct_start);
1712  #  elif ON_APPLE
1713      start = mach_absolute_time();
1714  #  else
1715      clock_gettime(CLOCK_MONOTONIC, &time_funct_start);
1716  #  endif
1717      OpenclDevice::gpuEnv = *env;
1718      OpenclDevice::initMorphCLAllocations(wpl, input.height, input.pix);
1719      Image pix_vline = nullptr, pix_hline = nullptr, pix_closed = nullptr;
1720      OpenclDevice::pixGetLinesCL(nullptr, input.pix, &pix_vline, &pix_hline, &pix_closed, true,
1721                                  closing_brick, closing_brick, max_line_width, max_line_width,
1722                                  min_line_length, min_line_length);
1723      OpenclDevice::releaseMorphCLBuffers();
1724  #  if ON_WINDOWS
1725      QueryPerformanceCounter(&time_funct_end);
1726      time = (time_funct_end.QuadPart - time_funct_start.QuadPart) / (double)(freq.QuadPart);
1727  #  elif ON_APPLE
1728      stop = mach_absolute_time();
1729      time = ((stop - start) * (double)info.numer / info.denom) / 1.0E9;
1730  #  else
1731      clock_gettime(CLOCK_MONOTONIC, &time_funct_end);
1732      time = (time_funct_end.tv_sec - time_funct_start.tv_sec) * 1.0 +
1733             (time_funct_end.tv_nsec - time_funct_start.tv_nsec) / 1000000000.0;
1734  #  endif
1735    } else {
1736  #  if ON_WINDOWS
1737      QueryPerformanceCounter(&time_funct_start);
1738  #  elif ON_APPLE
1739      start = mach_absolute_time();
1740  #  else
1741      clock_gettime(CLOCK_MONOTONIC, &time_funct_start);
1742  #  endif
1743      Image src_pix = input.pix;
1744      Image pix_closed = pixCloseBrick(nullptr, src_pix, closing_brick, closing_brick);
1745      Image pix_solid = pixOpenBrick(nullptr, pix_closed, max_line_width, max_line_width);
1746      Image pix_hollow = pixSubtract(nullptr, pix_closed, pix_solid);
1747      pix_solid.destroy();
1748      Image pix_vline = pixOpenBrick(nullptr, pix_hollow, 1, min_line_length);
1749      Image pix_hline = pixOpenBrick(nullptr, pix_hollow, min_line_length, 1);
1750      pix_hline.destroy();
1751      pix_vline.destroy();
1752      pix_hollow.destroy();
1753  #  if ON_WINDOWS
1754      QueryPerformanceCounter(&time_funct_end);
1755      time = (time_funct_end.QuadPart - time_funct_start.QuadPart) / (double)(freq.QuadPart);
1756  #  elif ON_APPLE
1757      stop = mach_absolute_time();
1758      time = ((stop - start) * (double)info.numer / info.denom) / 1.0E9;
1759  #  else
1760      clock_gettime(CLOCK_MONOTONIC, &time_funct_end);
1761      time = (time_funct_end.tv_sec - time_funct_start.tv_sec) * 1.0 +
1762             (time_funct_end.tv_nsec - time_funct_start.tv_nsec) / 1000000000.0;
1763  #  endif
1764    }
1765    return time;
1766  }
1767  static ds_status serializeScore(ds_device *device, uint8_t **serializedScore,
1768                                  unsigned int *serializedScoreSize) {
1769    *serializedScoreSize = sizeof(TessDeviceScore);
1770    *serializedScore = new uint8_t[*serializedScoreSize];
1771    memcpy(*serializedScore, device->score, *serializedScoreSize);
1772    return DS_SUCCESS;
1773  }
1774  static ds_status deserializeScore(ds_device *device, const uint8_t *serializedScore,
1775                                    unsigned int serializedScoreSize) {
1776    device->score = new TessDeviceScore;
1777    memcpy(device->score, serializedScore, serializedScoreSize);
1778    return DS_SUCCESS;
1779  }
1780  static ds_status releaseScore(TessDeviceScore *score) {
1781    delete score;
1782    return DS_SUCCESS;
1783  }
1784  static ds_status evaluateScoreForDevice(ds_device *device, void *inputData) {
1785    tprintf("\n[DS] Device: \"%s\" (%s) evaluation...\n", device->oclDeviceName,
1786            device->type == DS_DEVICE_OPENCL_DEVICE ? "OpenCL" : "Native");
1787    GPUEnv *env = nullptr;
1788    if (device->type == DS_DEVICE_OPENCL_DEVICE) {
1789      env = &OpenclDevice::gpuEnv;
1790      memset(env, 0, sizeof(*env));
1791      populateGPUEnvFromDevice(env, device->oclDeviceID);
1792      env->mnFileCount = 0; 
1793      env->mnKernelCount = 0UL;
1794      OpenclDevice::CompileKernelFile(env, "");
1795    }
1796    TessScoreEvaluationInputData *input = static_cast<TessScoreEvaluationInputData *>(inputData);
1797    double composeRGBPixelTime = composeRGBPixelMicroBench(env, *input, device->type);
1798    double histogramRectTime = histogramRectMicroBench(env, *input, device->type);
1799    double thresholdRectToPixTime = thresholdRectToPixMicroBench(env, *input, device->type);
1800    double getLineMasksMorphTime = getLineMasksMorphMicroBench(env, *input, device->type);
1801    float composeRGBPixelWeight = 1.2f;
1802    float histogramRectWeight = 2.4f;
1803    float thresholdRectToPixWeight = 4.5f;
1804    float getLineMasksMorphWeight = 5.0f;
1805    float weightedTime = composeRGBPixelWeight * composeRGBPixelTime +
1806                         histogramRectWeight * histogramRectTime +
1807                         thresholdRectToPixWeight * thresholdRectToPixTime +
1808                         getLineMasksMorphWeight * getLineMasksMorphTime;
1809    device->score = new TessDeviceScore;
1810    device->score->time = weightedTime;
1811    tprintf("[DS] Device: \"%s\" (%s) evaluated\n", device->oclDeviceName,
1812            device->type == DS_DEVICE_OPENCL_DEVICE ? "OpenCL" : "Native");
1813    tprintf("[DS]%25s: %f (w=%.1f)\n", "composeRGBPixel", composeRGBPixelTime, composeRGBPixelWeight);
1814    tprintf("[DS]%25s: %f (w=%.1f)\n", "HistogramRect", histogramRectTime, histogramRectWeight);
1815    tprintf("[DS]%25s: %f (w=%.1f)\n", "ThresholdRectToPix", thresholdRectToPixTime,
1816            thresholdRectToPixWeight);
1817    tprintf("[DS]%25s: %f (w=%.1f)\n", "getLineMasksMorph", getLineMasksMorphTime,
1818            getLineMasksMorphWeight);
1819    tprintf("[DS]%25s: %f\n", "Score", device->score->time);
1820    return DS_SUCCESS;
1821  }
1822  ds_device OpenclDevice::getDeviceSelection() {
1823    if (!deviceIsSelected) {
1824      if (1 == LoadOpencl()) {
1825        ds_status status;
1826        ds_profile *profile;
1827        status = initDSProfile(&profile, "v0.1");
1828        const char *fileName = "tesseract_opencl_profile_devices.dat";
1829        status = readProfileFromFile(profile, deserializeScore, fileName);
1830        if (status != DS_SUCCESS) {
1831          tprintf("[DS] Profile file not available (%s); performing profiling.\n", fileName);
1832          TessScoreEvaluationInputData input;
1833          populateTessScoreEvaluationInputData(&input);
1834          unsigned int numUpdates;
1835          status =
1836              profileDevices(profile, DS_EVALUATE_ALL, evaluateScoreForDevice, &input, &numUpdates);
1837          if (status == DS_SUCCESS) {
1838            status = writeProfileToFile(profile, serializeScore, fileName);
1839            if (status == DS_SUCCESS) {
1840              tprintf("[DS] Scores written to file (%s).\n", fileName);
1841            } else {
1842              tprintf(
1843                  "[DS] Error saving scores to file (%s); scores not written to "
1844                  "file.\n",
1845                  fileName);
1846            }
1847          } else {
1848            tprintf(
1849                "[DS] Unable to evaluate performance; scores not written to "
1850                "file.\n");
1851          }
1852        } else {
1853          tprintf("[DS] Profile read from file (%s).\n", fileName);
1854        }
1855        float bestTime = FLT_MAX; 
1856        int bestDeviceIdx = -1;
1857        for (unsigned d = 0; d < profile->numDevices; d++) {
1858          ds_device device = profile->devices[d];
1859          if (device.score == nullptr)
1860            continue;
1861          TessDeviceScore score = *device.score;
1862          float time = score.time;
1863          tprintf("[DS] Device[%u] %i:%s score is %f\n", d + 1, device.type, device.oclDeviceName,
1864                  time);
1865          if (time < bestTime) {
1866            bestTime = time;
1867            bestDeviceIdx = d;
1868          }
1869        }
1870        if (bestDeviceIdx >= 0) {
1871          tprintf(
1872              "[DS] Selected Device[%i]: \"%s\" (%s)\n", bestDeviceIdx + 1,
1873              profile->devices[bestDeviceIdx].oclDeviceName,
1874              profile->devices[bestDeviceIdx].type == DS_DEVICE_OPENCL_DEVICE ? "OpenCL" : "Native");
1875        }
1876        bool overridden = false;
1877        char *overrideDeviceStr = getenv("TESSERACT_OPENCL_DEVICE");
1878        if (overrideDeviceStr != nullptr) {
1879          int overrideDeviceIdx = atoi(overrideDeviceStr);
1880          if (overrideDeviceIdx > 0 && overrideDeviceIdx <= profile->numDevices) {
1881            tprintf(
1882                "[DS] Overriding Device Selection (TESSERACT_OPENCL_DEVICE=%s, "
1883                "%i)\n",
1884                overrideDeviceStr, overrideDeviceIdx);
1885            bestDeviceIdx = overrideDeviceIdx - 1;
1886            overridden = true;
1887          } else {
1888            tprintf(
1889                "[DS] Ignoring invalid TESSERACT_OPENCL_DEVICE=%s ([1,%i] are "
1890                "valid devices).\n",
1891                overrideDeviceStr, profile->numDevices);
1892          }
1893        }
1894        if (overridden) {
1895          tprintf(
1896              "[DS] Overridden Device[%i]: \"%s\" (%s)\n", bestDeviceIdx + 1,
1897              profile->devices[bestDeviceIdx].oclDeviceName,
1898              profile->devices[bestDeviceIdx].type == DS_DEVICE_OPENCL_DEVICE ? "OpenCL" : "Native");
1899        }
1900        selectedDevice = profile->devices[bestDeviceIdx];
1901        releaseDSProfile(profile, releaseScore);
1902      } else {
1903        tprintf("[DS] OpenCL runtime not available.\n");
1904        selectedDevice.type = DS_DEVICE_NATIVE_CPU;
1905        selectedDevice.oclDeviceName = "(null)";
1906        selectedDevice.score = nullptr;
1907        selectedDevice.oclDeviceID = nullptr;
1908        selectedDevice.oclDriverVersion = nullptr;
1909      }
1910      deviceIsSelected = true;
1911    }
1912    return selectedDevice;
1913  }
1914  bool OpenclDevice::selectedDeviceIsOpenCL() {
1915    ds_device device = getDeviceSelection();
1916    return (device.type == DS_DEVICE_OPENCL_DEVICE);
1917  }
1918  } 
1919  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-gmock-spec-builders.h</h3>
            <pre><code>1  #ifndef GMOCK_INCLUDE_GMOCK_GMOCK_SPEC_BUILDERS_H_
2  #define GMOCK_INCLUDE_GMOCK_GMOCK_SPEC_BUILDERS_H_
3  #include <map>
4  #include <set>
5  #include <sstream>
6  #include <string>
7  #include <vector>
8  #if GTEST_HAS_EXCEPTIONS
9  # include <stdexcept>  
10  #endif
11  #include "gmock/gmock-actions.h"
12  #include "gmock/gmock-cardinalities.h"
13  #include "gmock/gmock-matchers.h"
14  #include "gmock/internal/gmock-internal-utils.h"
15  #include "gmock/internal/gmock-port.h"
16  #include "gtest/gtest.h"
17  namespace testing {
18  class Expectation;
19  class ExpectationSet;
20  namespace internal {
21  template <typename F> class FunctionMocker;
22  class ExpectationBase;
23  template <typename F> class TypedExpectation;
24  class ExpectationTester;
25  template <typename F> class FunctionMockerBase;
26  GTEST_API_ GTEST_DECLARE_STATIC_MUTEX_(g_gmock_mutex);
27  class UntypedActionResultHolderBase;
28  class GTEST_API_ UntypedFunctionMockerBase {
29   public:
30    UntypedFunctionMockerBase();
31    virtual ~UntypedFunctionMockerBase();
32    bool VerifyAndClearExpectationsLocked()
33        GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex);
34    virtual void ClearDefaultActionsLocked()
35        GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) = 0;
36    virtual UntypedActionResultHolderBase* UntypedPerformDefaultAction(
37        const void* untyped_args,
38        const string& call_description) const = 0;
39    virtual UntypedActionResultHolderBase* UntypedPerformAction(
40        const void* untyped_action,
41        const void* untyped_args) const = 0;
42    virtual void UntypedDescribeUninterestingCall(
43        const void* untyped_args,
44        ::std::ostream* os) const
45            GTEST_LOCK_EXCLUDED_(g_gmock_mutex) = 0;
46    virtual const ExpectationBase* UntypedFindMatchingExpectation(
47        const void* untyped_args,
48        const void** untyped_action, bool* is_excessive,
49        ::std::ostream* what, ::std::ostream* why)
50            GTEST_LOCK_EXCLUDED_(g_gmock_mutex) = 0;
51    virtual void UntypedPrintArgs(const void* untyped_args,
52                                  ::std::ostream* os) const = 0;
53    void RegisterOwner(const void* mock_obj)
54        GTEST_LOCK_EXCLUDED_(g_gmock_mutex);
55    void SetOwnerAndName(const void* mock_obj, const char* name)
56        GTEST_LOCK_EXCLUDED_(g_gmock_mutex);
57    const void* MockObject() const
58        GTEST_LOCK_EXCLUDED_(g_gmock_mutex);
59    const char* Name() const
60        GTEST_LOCK_EXCLUDED_(g_gmock_mutex);
61    const UntypedActionResultHolderBase* UntypedInvokeWith(
62        const void* untyped_args)
63            GTEST_LOCK_EXCLUDED_(g_gmock_mutex);
64   protected:
65    typedef std::vector<const void*> UntypedOnCallSpecs;
66    typedef std::vector<internal::linked_ptr<ExpectationBase> >
67    UntypedExpectations;
68    Expectation GetHandleOf(ExpectationBase* exp);
69    const void* mock_obj_;  
70    const char* name_;  
71    UntypedOnCallSpecs untyped_on_call_specs_;
72    UntypedExpectations untyped_expectations_;
73  };  
74  class UntypedOnCallSpecBase {
75   public:
76    UntypedOnCallSpecBase(const char* a_file, int a_line)
77        : file_(a_file), line_(a_line), last_clause_(kNone) {}
78    const char* file() const { return file_; }
79    int line() const { return line_; }
80   protected:
81    enum Clause {
82      kNone,
83      kWith,
84      kWillByDefault
85    };
86    void AssertSpecProperty(bool property, const string& failure_message) const {
87      Assert(property, file_, line_, failure_message);
88    }
89    void ExpectSpecProperty(bool property, const string& failure_message) const {
90      Expect(property, file_, line_, failure_message);
91    }
92    const char* file_;
93    int line_;
94    Clause last_clause_;
95  };  
96  template <typename F>
97  class OnCallSpec : public UntypedOnCallSpecBase {
98   public:
99    typedef typename Function<F>::ArgumentTuple ArgumentTuple;
100    typedef typename Function<F>::ArgumentMatcherTuple ArgumentMatcherTuple;
101    OnCallSpec(const char* a_file, int a_line,
102               const ArgumentMatcherTuple& matchers)
103        : UntypedOnCallSpecBase(a_file, a_line),
104          matchers_(matchers),
105          extra_matcher_(A<const ArgumentTuple&>()) {
106    }
107    OnCallSpec& With(const Matcher<const ArgumentTuple&>& m) {
108      ExpectSpecProperty(last_clause_ < kWith,
109                         ".With() cannot appear "
110                         "more than once in an ON_CALL().");
111      last_clause_ = kWith;
112      extra_matcher_ = m;
113      return *this;
114    }
115    OnCallSpec& WillByDefault(const Action<F>& action) {
116      ExpectSpecProperty(last_clause_ < kWillByDefault,
117                         ".WillByDefault() must appear "
118                         "exactly once in an ON_CALL().");
119      last_clause_ = kWillByDefault;
120      ExpectSpecProperty(!action.IsDoDefault(),
121                         "DoDefault() cannot be used in ON_CALL().");
122      action_ = action;
123      return *this;
124    }
125    bool Matches(const ArgumentTuple& args) const {
126      return TupleMatches(matchers_, args) && extra_matcher_.Matches(args);
127    }
128    const Action<F>& GetAction() const {
129      AssertSpecProperty(last_clause_ == kWillByDefault,
130                         ".WillByDefault() must appear exactly "
131                         "once in an ON_CALL().");
132      return action_;
133    }
134   private:
135    ArgumentMatcherTuple matchers_;
136    Matcher<const ArgumentTuple&> extra_matcher_;
137    Action<F> action_;
138  };  
139  enum CallReaction {
140    kAllow,
141    kWarn,
142    kFail,
143    kDefault = kWarn  
144  };
145  }  
146  class GTEST_API_ Mock {
147   public:
148    static void AllowLeak(const void* mock_obj)
149        GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex);
150    static bool VerifyAndClearExpectations(void* mock_obj)
151        GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex);
152    static bool VerifyAndClear(void* mock_obj)
153        GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex);
154   private:
155    friend class internal::UntypedFunctionMockerBase;
156    template <typename F>
157    friend class internal::FunctionMockerBase;
158    template <typename M>
159    friend class NiceMock;
160    template <typename M>
161    friend class NaggyMock;
162    template <typename M>
163    friend class StrictMock;
164    static void AllowUninterestingCalls(const void* mock_obj)
165        GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex);
166    static void WarnUninterestingCalls(const void* mock_obj)
167        GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex);
168    static void FailUninterestingCalls(const void* mock_obj)
169        GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex);
170    static void UnregisterCallReaction(const void* mock_obj)
171        GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex);
172    static internal::CallReaction GetReactionOnUninterestingCalls(
173        const void* mock_obj)
174            GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex);
175    static bool VerifyAndClearExpectationsLocked(void* mock_obj)
176        GTEST_EXCLUSIVE_LOCK_REQUIRED_(internal::g_gmock_mutex);
177    static void ClearDefaultActionsLocked(void* mock_obj)
178        GTEST_EXCLUSIVE_LOCK_REQUIRED_(internal::g_gmock_mutex);
179    static void Register(
180        const void* mock_obj,
181        internal::UntypedFunctionMockerBase* mocker)
182            GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex);
183    static void RegisterUseByOnCallOrExpectCall(
184        const void* mock_obj, const char* file, int line)
185            GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex);
186    static void UnregisterLocked(internal::UntypedFunctionMockerBase* mocker)
187        GTEST_EXCLUSIVE_LOCK_REQUIRED_(internal::g_gmock_mutex);
188  };  
189  class GTEST_API_ Expectation {
190   public:
191    Expectation();
192    ~Expectation();
193    Expectation(internal::ExpectationBase& exp);  
194    bool operator==(const Expectation& rhs) const {
195      return expectation_base_ == rhs.expectation_base_;
196    }
197    bool operator!=(const Expectation& rhs) const { return !(*this == rhs); }
198   private:
199    friend class ExpectationSet;
200    friend class Sequence;
201    friend class ::testing::internal::ExpectationBase;
202    friend class ::testing::internal::UntypedFunctionMockerBase;
203    template <typename F>
204    friend class ::testing::internal::FunctionMockerBase;
205    template <typename F>
206    friend class ::testing::internal::TypedExpectation;
207    class Less {
208     public:
209      bool operator()(const Expectation& lhs, const Expectation& rhs) const {
210        return lhs.expectation_base_.get() < rhs.expectation_base_.get();
211      }
212    };
213    typedef ::std::set<Expectation, Less> Set;
214    Expectation(
215        const internal::linked_ptr<internal::ExpectationBase>& expectation_base);
216    const internal::linked_ptr<internal::ExpectationBase>&
217    expectation_base() const {
218      return expectation_base_;
219    }
220    internal::linked_ptr<internal::ExpectationBase> expectation_base_;
221  };
222  class ExpectationSet {
223   public:
224    typedef Expectation::Set::const_iterator const_iterator;
225    typedef Expectation::Set::value_type value_type;
226    ExpectationSet() {}
227    ExpectationSet(internal::ExpectationBase& exp) {  
228      *this += Expectation(exp);
229    }
230    ExpectationSet(const Expectation& e) {  
231      *this += e;
232    }
233    bool operator==(const ExpectationSet& rhs) const {
234      return expectations_ == rhs.expectations_;
235    }
236    bool operator!=(const ExpectationSet& rhs) const { return !(*this == rhs); }
237    ExpectationSet& operator+=(const Expectation& e) {
238      expectations_.insert(e);
239      return *this;
240    }
241    int size() const { return static_cast<int>(expectations_.size()); }
242    const_iterator begin() const { return expectations_.begin(); }
243    const_iterator end() const { return expectations_.end(); }
244   private:
245    Expectation::Set expectations_;
246  };
247  class GTEST_API_ Sequence {
248   public:
249    Sequence() : last_expectation_(new Expectation) {}
250    void AddExpectation(const Expectation& expectation) const;
251   private:
252    internal::linked_ptr<Expectation> last_expectation_;
253  };  
254  class GTEST_API_ InSequence {
255   public:
256    InSequence();
257    ~InSequence();
258   private:
259    bool sequence_created_;
260    GTEST_DISALLOW_COPY_AND_ASSIGN_(InSequence);  
261  } GTEST_ATTRIBUTE_UNUSED_;
262  namespace internal {
263  GTEST_API_ extern ThreadLocal<Sequence*> g_gmock_implicit_sequence;
264  class GTEST_API_ ExpectationBase {
265   public:
266    ExpectationBase(const char* file, int line, const string& source_text);
267    virtual ~ExpectationBase();
268    const char* file() const { return file_; }
269    int line() const { return line_; }
270    const char* source_text() const { return source_text_.c_str(); }
271    const Cardinality& cardinality() const { return cardinality_; }
272    void DescribeLocationTo(::std::ostream* os) const {
273      *os << FormatFileLocation(file(), line()) << " ";
274    }
275    void DescribeCallCountTo(::std::ostream* os) const
276        GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex);
277    virtual void MaybeDescribeExtraMatcherTo(::std::ostream* os) = 0;
278   protected:
279    friend class ::testing::Expectation;
280    friend class UntypedFunctionMockerBase;
281    enum Clause {
282      kNone,
283      kWith,
284      kTimes,
285      kInSequence,
286      kAfter,
287      kWillOnce,
288      kWillRepeatedly,
289      kRetiresOnSaturation
290    };
291    typedef std::vector<const void*> UntypedActions;
292    virtual Expectation GetHandle() = 0;
293    void AssertSpecProperty(bool property, const string& failure_message) const {
294      Assert(property, file_, line_, failure_message);
295    }
296    void ExpectSpecProperty(bool property, const string& failure_message) const {
297      Expect(property, file_, line_, failure_message);
298    }
299    void SpecifyCardinality(const Cardinality& cardinality);
300    bool cardinality_specified() const { return cardinality_specified_; }
301    void set_cardinality(const Cardinality& a_cardinality) {
302      cardinality_ = a_cardinality;
303    }
304    void RetireAllPreRequisites()
305        GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex);
306    bool is_retired() const
307        GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
308      g_gmock_mutex.AssertHeld();
309      return retired_;
310    }
311    void Retire()
312        GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
313      g_gmock_mutex.AssertHeld();
314      retired_ = true;
315    }
316    bool IsSatisfied() const
317        GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
318      g_gmock_mutex.AssertHeld();
319      return cardinality().IsSatisfiedByCallCount(call_count_);
320    }
321    bool IsSaturated() const
322        GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
323      g_gmock_mutex.AssertHeld();
324      return cardinality().IsSaturatedByCallCount(call_count_);
325    }
326    bool IsOverSaturated() const
327        GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
328      g_gmock_mutex.AssertHeld();
329      return cardinality().IsOverSaturatedByCallCount(call_count_);
330    }
331    bool AllPrerequisitesAreSatisfied() const
332        GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex);
333    void FindUnsatisfiedPrerequisites(ExpectationSet* result) const
334        GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex);
335    int call_count() const
336        GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
337      g_gmock_mutex.AssertHeld();
338      return call_count_;
339    }
340    void IncrementCallCount()
341        GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
342      g_gmock_mutex.AssertHeld();
343      call_count_++;
344    }
345    void CheckActionCountIfNotDone() const
346        GTEST_LOCK_EXCLUDED_(mutex_);
347    friend class ::testing::Sequence;
348    friend class ::testing::internal::ExpectationTester;
349    template <typename Function>
350    friend class TypedExpectation;
351    void UntypedTimes(const Cardinality& a_cardinality);
352    const char* file_;          
353    int line_;                  
354    const string source_text_;  
355    bool cardinality_specified_;
356    Cardinality cardinality_;            
357    ExpectationSet immediate_prerequisites_;
358    int call_count_;  
359    bool retired_;    
360    UntypedActions untyped_actions_;
361    bool extra_matcher_specified_;
362    bool repeated_action_specified_;  
363    bool retires_on_saturation_;
364    Clause last_clause_;
365    mutable bool action_count_checked_;  
366    mutable Mutex mutex_;  
367    GTEST_DISALLOW_ASSIGN_(ExpectationBase);
368  };  
369  template <typename F>
370  class TypedExpectation : public ExpectationBase {
371   public:
372    typedef typename Function<F>::ArgumentTuple ArgumentTuple;
373    typedef typename Function<F>::ArgumentMatcherTuple ArgumentMatcherTuple;
374    typedef typename Function<F>::Result Result;
375    TypedExpectation(FunctionMockerBase<F>* owner,
376                     const char* a_file, int a_line, const string& a_source_text,
377                     const ArgumentMatcherTuple& m)
378        : ExpectationBase(a_file, a_line, a_source_text),
379          owner_(owner),
380          matchers_(m),
381          extra_matcher_(A<const ArgumentTuple&>()),
382          repeated_action_(DoDefault()) {}
383    virtual ~TypedExpectation() {
384      CheckActionCountIfNotDone();
385      for (UntypedActions::const_iterator it = untyped_actions_.begin();
386           it != untyped_actions_.end(); ++it) {
387        delete static_cast<const Action<F>*>(*it);
388      }
389    }
390    TypedExpectation& With(const Matcher<const ArgumentTuple&>& m) {
391      if (last_clause_ == kWith) {
392        ExpectSpecProperty(false,
393                           ".With() cannot appear "
394                           "more than once in an EXPECT_CALL().");
395      } else {
396        ExpectSpecProperty(last_clause_ < kWith,
397                           ".With() must be the first "
398                           "clause in an EXPECT_CALL().");
399      }
400      last_clause_ = kWith;
401      extra_matcher_ = m;
402      extra_matcher_specified_ = true;
403      return *this;
404    }
405    TypedExpectation& Times(const Cardinality& a_cardinality) {
406      ExpectationBase::UntypedTimes(a_cardinality);
407      return *this;
408    }
409    TypedExpectation& Times(int n) {
410      return Times(Exactly(n));
411    }
412    TypedExpectation& InSequence(const Sequence& s) {
413      ExpectSpecProperty(last_clause_ <= kInSequence,
414                         ".InSequence() cannot appear after .After(),"
415                         " .WillOnce(), .WillRepeatedly(), or "
416                         ".RetiresOnSaturation().");
417      last_clause_ = kInSequence;
418      s.AddExpectation(GetHandle());
419      return *this;
420    }
421    TypedExpectation& InSequence(const Sequence& s1, const Sequence& s2) {
422      return InSequence(s1).InSequence(s2);
423    }
424    TypedExpectation& InSequence(const Sequence& s1, const Sequence& s2,
425                                 const Sequence& s3) {
426      return InSequence(s1, s2).InSequence(s3);
427    }
428    TypedExpectation& InSequence(const Sequence& s1, const Sequence& s2,
429                                 const Sequence& s3, const Sequence& s4) {
430      return InSequence(s1, s2, s3).InSequence(s4);
431    }
432    TypedExpectation& InSequence(const Sequence& s1, const Sequence& s2,
433                                 const Sequence& s3, const Sequence& s4,
434                                 const Sequence& s5) {
435      return InSequence(s1, s2, s3, s4).InSequence(s5);
436    }
437    TypedExpectation& After(const ExpectationSet& s) {
438      ExpectSpecProperty(last_clause_ <= kAfter,
439                         ".After() cannot appear after .WillOnce(),"
440                         " .WillRepeatedly(), or "
441                         ".RetiresOnSaturation().");
442      last_clause_ = kAfter;
443      for (ExpectationSet::const_iterator it = s.begin(); it != s.end(); ++it) {
444        immediate_prerequisites_ += *it;
445      }
446      return *this;
447    }
448    TypedExpectation& After(const ExpectationSet& s1, const ExpectationSet& s2) {
449      return After(s1).After(s2);
450    }
451    TypedExpectation& After(const ExpectationSet& s1, const ExpectationSet& s2,
452                            const ExpectationSet& s3) {
453      return After(s1, s2).After(s3);
454    }
455    TypedExpectation& After(const ExpectationSet& s1, const ExpectationSet& s2,
456                            const ExpectationSet& s3, const ExpectationSet& s4) {
457      return After(s1, s2, s3).After(s4);
458    }
459    TypedExpectation& After(const ExpectationSet& s1, const ExpectationSet& s2,
460                            const ExpectationSet& s3, const ExpectationSet& s4,
461                            const ExpectationSet& s5) {
462      return After(s1, s2, s3, s4).After(s5);
463    }
464    TypedExpectation& WillOnce(const Action<F>& action) {
465      ExpectSpecProperty(last_clause_ <= kWillOnce,
466                         ".WillOnce() cannot appear after "
467                         ".WillRepeatedly() or .RetiresOnSaturation().");
468      last_clause_ = kWillOnce;
469      untyped_actions_.push_back(new Action<F>(action));
470      if (!cardinality_specified()) {
471        set_cardinality(Exactly(static_cast<int>(untyped_actions_.size())));
472      }
473      return *this;
474    }
475    TypedExpectation& WillRepeatedly(const Action<F>& action) {
476      if (last_clause_ == kWillRepeatedly) {
477        ExpectSpecProperty(false,
478                           ".WillRepeatedly() cannot appear "
479                           "more than once in an EXPECT_CALL().");
480      } else {
481        ExpectSpecProperty(last_clause_ < kWillRepeatedly,
482                           ".WillRepeatedly() cannot appear "
483                           "after .RetiresOnSaturation().");
484      }
485      last_clause_ = kWillRepeatedly;
486      repeated_action_specified_ = true;
487      repeated_action_ = action;
488      if (!cardinality_specified()) {
489        set_cardinality(AtLeast(static_cast<int>(untyped_actions_.size())));
490      }
491      CheckActionCountIfNotDone();
492      return *this;
493    }
494    TypedExpectation& RetiresOnSaturation() {
495      ExpectSpecProperty(last_clause_ < kRetiresOnSaturation,
496                         ".RetiresOnSaturation() cannot appear "
497                         "more than once.");
498      last_clause_ = kRetiresOnSaturation;
499      retires_on_saturation_ = true;
500      CheckActionCountIfNotDone();
501      return *this;
502    }
503    const ArgumentMatcherTuple& matchers() const {
504      return matchers_;
505    }
506    const Matcher<const ArgumentTuple&>& extra_matcher() const {
507      return extra_matcher_;
508    }
509    const Action<F>& repeated_action() const { return repeated_action_; }
510    virtual void MaybeDescribeExtraMatcherTo(::std::ostream* os) {
511      if (extra_matcher_specified_) {
512        *os << "    Expected args: ";
513        extra_matcher_.DescribeTo(os);
514        *os << "\n";
515      }
516    }
517   private:
518    template <typename Function>
519    friend class FunctionMockerBase;
520    virtual Expectation GetHandle() {
521      return owner_->GetHandleOf(this);
522    }
523    bool Matches(const ArgumentTuple& args) const
524        GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
525      g_gmock_mutex.AssertHeld();
526      return TupleMatches(matchers_, args) && extra_matcher_.Matches(args);
527    }
528    bool ShouldHandleArguments(const ArgumentTuple& args) const
529        GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
530      g_gmock_mutex.AssertHeld();
531      CheckActionCountIfNotDone();
532      return !is_retired() && AllPrerequisitesAreSatisfied() && Matches(args);
533    }
534    void ExplainMatchResultTo(
535        const ArgumentTuple& args,
536        ::std::ostream* os) const
537            GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
538      g_gmock_mutex.AssertHeld();
539      if (is_retired()) {
540        *os << "         Expected: the expectation is active\n"
541            << "           Actual: it is retired\n";
542      } else if (!Matches(args)) {
543        if (!TupleMatches(matchers_, args)) {
544          ExplainMatchFailureTupleTo(matchers_, args, os);
545        }
546        StringMatchResultListener listener;
547        if (!extra_matcher_.MatchAndExplain(args, &listener)) {
548          *os << "    Expected args: ";
549          extra_matcher_.DescribeTo(os);
550          *os << "\n           Actual: don't match";
551          internal::PrintIfNotEmpty(listener.str(), os);
552          *os << "\n";
553        }
554      } else if (!AllPrerequisitesAreSatisfied()) {
555        *os << "         Expected: all pre-requisites are satisfied\n"
556            << "           Actual: the following immediate pre-requisites "
557            << "are not satisfied:\n";
<span onclick='openModal()' class='match'>558        ExpectationSet unsatisfied_prereqs;
559        FindUnsatisfiedPrerequisites(&unsatisfied_prereqs);
560        int i = 0;
561        for (ExpectationSet::const_iterator it = unsatisfied_prereqs.begin();
</span>562             it != unsatisfied_prereqs.end(); ++it) {
563          it->expectation_base()->DescribeLocationTo(os);
564          *os << "pre-requisite #" << i++ << "\n";
565        }
566        *os << "                   (end of pre-requisites)\n";
567      } else {
568        *os << "The call matches the expectation.\n";
569      }
570    }
571    const Action<F>& GetCurrentAction(
572        const FunctionMockerBase<F>* mocker,
573        const ArgumentTuple& args) const
574            GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
575      g_gmock_mutex.AssertHeld();
576      const int count = call_count();
577      Assert(count >= 1, __FILE__, __LINE__,
578             "call_count() is <= 0 when GetCurrentAction() is "
579             "called - this should never happen.");
580      const int action_count = static_cast<int>(untyped_actions_.size());
581      if (action_count > 0 && !repeated_action_specified_ &&
582          count > action_count) {
583        ::std::stringstream ss;
584        DescribeLocationTo(&ss);
585        ss << "Actions ran out in " << source_text() << "...\n"
586           << "Called " << count << " times, but only "
587           << action_count << " WillOnce()"
588           << (action_count == 1 ? " is" : "s are") << " specified - ";
589        mocker->DescribeDefaultActionTo(args, &ss);
590        Log(kWarning, ss.str(), 1);
591      }
592      return count <= action_count ?
593          *static_cast<const Action<F>*>(untyped_actions_[count - 1]) :
594          repeated_action();
595    }
596    const Action<F>* GetActionForArguments(
597        const FunctionMockerBase<F>* mocker,
598        const ArgumentTuple& args,
599        ::std::ostream* what,
600        ::std::ostream* why)
601            GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
602      g_gmock_mutex.AssertHeld();
603      if (IsSaturated()) {
604        IncrementCallCount();
605        *what << "Mock function called more times than expected - ";
606        mocker->DescribeDefaultActionTo(args, what);
607        DescribeCallCountTo(why);
608        return NULL;
609      }
610      IncrementCallCount();
611      RetireAllPreRequisites();
612      if (retires_on_saturation_ && IsSaturated()) {
613        Retire();
614      }
615      *what << "Mock function call matches " << source_text() <<"...\n";
616      return &(GetCurrentAction(mocker, args));
617    }
618    FunctionMockerBase<F>* const owner_;
619    ArgumentMatcherTuple matchers_;
620    Matcher<const ArgumentTuple&> extra_matcher_;
621    Action<F> repeated_action_;
622    GTEST_DISALLOW_COPY_AND_ASSIGN_(TypedExpectation);
623  };  
624  GTEST_API_ void LogWithLocation(testing::internal::LogSeverity severity,
625                                  const char* file, int line,
626                                  const string& message);
627  template <typename F>
628  class MockSpec {
629   public:
630    typedef typename internal::Function<F>::ArgumentTuple ArgumentTuple;
631    typedef typename internal::Function<F>::ArgumentMatcherTuple
632        ArgumentMatcherTuple;
633    explicit MockSpec(internal::FunctionMockerBase<F>* function_mocker)
634        : function_mocker_(function_mocker) {}
635    internal::OnCallSpec<F>& InternalDefaultActionSetAt(
636        const char* file, int line, const char* obj, const char* call) {
637      LogWithLocation(internal::kInfo, file, line,
638          string("ON_CALL(") + obj + ", " + call + ") invoked");
639      return function_mocker_->AddNewOnCallSpec(file, line, matchers_);
640    }
641    internal::TypedExpectation<F>& InternalExpectedAt(
642        const char* file, int line, const char* obj, const char* call) {
643      const string source_text(string("EXPECT_CALL(") + obj + ", " + call + ")");
644      LogWithLocation(internal::kInfo, file, line, source_text + " invoked");
645      return function_mocker_->AddNewExpectation(
646          file, line, source_text, matchers_);
647    }
648   private:
649    template <typename Function>
650    friend class internal::FunctionMocker;
651    void SetMatchers(const ArgumentMatcherTuple& matchers) {
652      matchers_ = matchers;
653    }
654    internal::FunctionMockerBase<F>* const function_mocker_;
655    ArgumentMatcherTuple matchers_;
656    GTEST_DISALLOW_ASSIGN_(MockSpec);
657  };  
658  #ifdef _MSC_VER
659  # pragma warning(push)          
660  # pragma warning(disable:4355)  
661  #endif  
662  class UntypedActionResultHolderBase {
663   public:
664    virtual ~UntypedActionResultHolderBase() {}
665    virtual void PrintAsActionResult(::std::ostream* os) const = 0;
666  };
667  template <typename T>
668  class ActionResultHolder : public UntypedActionResultHolderBase {
669   public:
670    explicit ActionResultHolder(T a_value) : value_(a_value) {}
671    T GetValueAndDelete() const {
672      T retval(value_);
673      delete this;
674      return retval;
675    }
676    virtual void PrintAsActionResult(::std::ostream* os) const {
677      *os << "\n          Returns: ";
678      UniversalPrinter<T>::Print(value_, os);
679    }
680    template <typename F>
681    static ActionResultHolder* PerformDefaultAction(
682        const FunctionMockerBase<F>* func_mocker,
683        const typename Function<F>::ArgumentTuple& args,
684        const string& call_description) {
685      return new ActionResultHolder(
686          func_mocker->PerformDefaultAction(args, call_description));
687    }
688    template <typename F>
689    static ActionResultHolder*
690    PerformAction(const Action<F>& action,
691                  const typename Function<F>::ArgumentTuple& args) {
692      return new ActionResultHolder(action.Perform(args));
693    }
694   private:
695    T value_;
696    GTEST_DISALLOW_ASSIGN_(ActionResultHolder);
697  };
698  template <>
699  class ActionResultHolder<void> : public UntypedActionResultHolderBase {
700   public:
701    void GetValueAndDelete() const { delete this; }
702    virtual void PrintAsActionResult(::std::ostream* &bsol;* os */) const {}
703    template <typename F>
704    static ActionResultHolder* PerformDefaultAction(
705        const FunctionMockerBase<F>* func_mocker,
706        const typename Function<F>::ArgumentTuple& args,
707        const string& call_description) {
708      func_mocker->PerformDefaultAction(args, call_description);
709      return NULL;
710    }
711    template <typename F>
712    static ActionResultHolder* PerformAction(
713        const Action<F>& action,
714        const typename Function<F>::ArgumentTuple& args) {
715      action.Perform(args);
716      return NULL;
717    }
718  };
719  template <typename F>
720  class FunctionMockerBase : public UntypedFunctionMockerBase {
721   public:
722    typedef typename Function<F>::Result Result;
723    typedef typename Function<F>::ArgumentTuple ArgumentTuple;
724    typedef typename Function<F>::ArgumentMatcherTuple ArgumentMatcherTuple;
725    FunctionMockerBase() : current_spec_(this) {}
726    virtual ~FunctionMockerBase()
727          GTEST_LOCK_EXCLUDED_(g_gmock_mutex) {
728      MutexLock l(&g_gmock_mutex);
729      VerifyAndClearExpectationsLocked();
730      Mock::UnregisterLocked(this);
731      ClearDefaultActionsLocked();
732    }
733    const OnCallSpec<F>* FindOnCallSpec(
734        const ArgumentTuple& args) const {
735      for (UntypedOnCallSpecs::const_reverse_iterator it
736               = untyped_on_call_specs_.rbegin();
737           it != untyped_on_call_specs_.rend(); ++it) {
738        const OnCallSpec<F>* spec = static_cast<const OnCallSpec<F>*>(*it);
739        if (spec->Matches(args))
740          return spec;
741      }
742      return NULL;
743    }
744    Result PerformDefaultAction(const ArgumentTuple& args,
745                                const string& call_description) const {
746      const OnCallSpec<F>* const spec =
747          this->FindOnCallSpec(args);
748      if (spec != NULL) {
749        return spec->GetAction().Perform(args);
750      }
751      const string message = call_description +
752          "\n    The mock function has no default action "
753          "set, and its return type has no default value set.";
754  #if GTEST_HAS_EXCEPTIONS
755      if (!DefaultValue<Result>::Exists()) {
756        throw std::runtime_error(message);
757      }
758  #else
759      Assert(DefaultValue<Result>::Exists(), "", -1, message);
760  #endif
761      return DefaultValue<Result>::Get();
762    }
763    virtual UntypedActionResultHolderBase* UntypedPerformDefaultAction(
764        const void* untyped_args,  
765        const string& call_description) const {
766      const ArgumentTuple& args =
767          *static_cast<const ArgumentTuple*>(untyped_args);
768      return ResultHolder::PerformDefaultAction(this, args, call_description);
769    }
770    virtual UntypedActionResultHolderBase* UntypedPerformAction(
771        const void* untyped_action, const void* untyped_args) const {
772      const Action<F> action = *static_cast<const Action<F>*>(untyped_action);
773      const ArgumentTuple& args =
774          *static_cast<const ArgumentTuple*>(untyped_args);
775      return ResultHolder::PerformAction(action, args);
776    }
777    virtual void ClearDefaultActionsLocked()
778        GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
779      g_gmock_mutex.AssertHeld();
780      UntypedOnCallSpecs specs_to_delete;
781      untyped_on_call_specs_.swap(specs_to_delete);
782      g_gmock_mutex.Unlock();
783      for (UntypedOnCallSpecs::const_iterator it =
784               specs_to_delete.begin();
785           it != specs_to_delete.end(); ++it) {
786        delete static_cast<const OnCallSpec<F>*>(*it);
787      }
788      g_gmock_mutex.Lock();
789    }
790   protected:
791    template <typename Function>
792    friend class MockSpec;
793    typedef ActionResultHolder<Result> ResultHolder;
794    Result InvokeWith(const ArgumentTuple& args)
795          GTEST_LOCK_EXCLUDED_(g_gmock_mutex) {
796      return static_cast<const ResultHolder*>(
797          this->UntypedInvokeWith(&args))->GetValueAndDelete();
798    }
799    OnCallSpec<F>& AddNewOnCallSpec(
800        const char* file, int line,
801        const ArgumentMatcherTuple& m)
802            GTEST_LOCK_EXCLUDED_(g_gmock_mutex) {
803      Mock::RegisterUseByOnCallOrExpectCall(MockObject(), file, line);
804      OnCallSpec<F>* const on_call_spec = new OnCallSpec<F>(file, line, m);
805      untyped_on_call_specs_.push_back(on_call_spec);
806      return *on_call_spec;
807    }
808    TypedExpectation<F>& AddNewExpectation(
809        const char* file,
810        int line,
811        const string& source_text,
812        const ArgumentMatcherTuple& m)
813            GTEST_LOCK_EXCLUDED_(g_gmock_mutex) {
814      Mock::RegisterUseByOnCallOrExpectCall(MockObject(), file, line);
815      TypedExpectation<F>* const expectation =
816          new TypedExpectation<F>(this, file, line, source_text, m);
817      const linked_ptr<ExpectationBase> untyped_expectation(expectation);
818      untyped_expectations_.push_back(untyped_expectation);
819      Sequence* const implicit_sequence = g_gmock_implicit_sequence.get();
820      if (implicit_sequence != NULL) {
821        implicit_sequence->AddExpectation(Expectation(untyped_expectation));
822      }
823      return *expectation;
824    }
825    MockSpec<F>& current_spec() { return current_spec_; }
826   private:
827    template <typename Func> friend class TypedExpectation;
828    void DescribeDefaultActionTo(const ArgumentTuple& args,
829                                 ::std::ostream* os) const {
830      const OnCallSpec<F>* const spec = FindOnCallSpec(args);
831      if (spec == NULL) {
832        *os << (internal::type_equals<Result, void>::value ?
833                "returning directly.\n" :
834                "returning default value.\n");
835      } else {
836        *os << "taking default action specified at:\n"
837            << FormatFileLocation(spec->file(), spec->line()) << "\n";
838      }
839    }
840    virtual void UntypedDescribeUninterestingCall(
841        const void* untyped_args,
842        ::std::ostream* os) const
843            GTEST_LOCK_EXCLUDED_(g_gmock_mutex) {
844      const ArgumentTuple& args =
845          *static_cast<const ArgumentTuple*>(untyped_args);
846      *os << "Uninteresting mock function call - ";
847      DescribeDefaultActionTo(args, os);
848      *os << "    Function call: " << Name();
849      UniversalPrint(args, os);
850    }
851    virtual const ExpectationBase* UntypedFindMatchingExpectation(
852        const void* untyped_args,
853        const void** untyped_action, bool* is_excessive,
854        ::std::ostream* what, ::std::ostream* why)
855            GTEST_LOCK_EXCLUDED_(g_gmock_mutex) {
856      const ArgumentTuple& args =
857          *static_cast<const ArgumentTuple*>(untyped_args);
858      MutexLock l(&g_gmock_mutex);
859      TypedExpectation<F>* exp = this->FindMatchingExpectationLocked(args);
860      if (exp == NULL) {  
861        this->FormatUnexpectedCallMessageLocked(args, what, why);
862        return NULL;
863      }
864      *is_excessive = exp->IsSaturated();
865      const Action<F>* action = exp->GetActionForArguments(this, args, what, why);
866      if (action != NULL && action->IsDoDefault())
867        action = NULL;  
868      *untyped_action = action;
869      return exp;
870    }
871    virtual void UntypedPrintArgs(const void* untyped_args,
872                                  ::std::ostream* os) const {
873      const ArgumentTuple& args =
874          *static_cast<const ArgumentTuple*>(untyped_args);
875      UniversalPrint(args, os);
876    }
877    TypedExpectation<F>* FindMatchingExpectationLocked(
878        const ArgumentTuple& args) const
879            GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
880      g_gmock_mutex.AssertHeld();
881      for (typename UntypedExpectations::const_reverse_iterator it =
882               untyped_expectations_.rbegin();
883           it != untyped_expectations_.rend(); ++it) {
884        TypedExpectation<F>* const exp =
885            static_cast<TypedExpectation<F>*>(it->get());
886        if (exp->ShouldHandleArguments(args)) {
887          return exp;
888        }
889      }
890      return NULL;
891    }
892    void FormatUnexpectedCallMessageLocked(
893        const ArgumentTuple& args,
894        ::std::ostream* os,
895        ::std::ostream* why) const
896            GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
897      g_gmock_mutex.AssertHeld();
898      *os << "\nUnexpected mock function call - ";
899      DescribeDefaultActionTo(args, os);
900      PrintTriedExpectationsLocked(args, why);
901    }
902    void PrintTriedExpectationsLocked(
903        const ArgumentTuple& args,
904        ::std::ostream* why) const
905            GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
906      g_gmock_mutex.AssertHeld();
907      const int count = static_cast<int>(untyped_expectations_.size());
908      *why << "Google Mock tried the following " << count << " "
909           << (count == 1 ? "expectation, but it didn't match" :
910               "expectations, but none matched")
911           << ":\n";
912      for (int i = 0; i < count; i++) {
913        TypedExpectation<F>* const expectation =
914            static_cast<TypedExpectation<F>*>(untyped_expectations_[i].get());
915        *why << "\n";
916        expectation->DescribeLocationTo(why);
917        if (count > 1) {
918          *why << "tried expectation #" << i << ": ";
919        }
920        *why << expectation->source_text() << "...\n";
921        expectation->ExplainMatchResultTo(args, why);
922        expectation->DescribeCallCountTo(why);
923      }
924    }
925    MockSpec<F> current_spec_;
926    GTEST_DISALLOW_COPY_AND_ASSIGN_(FunctionMockerBase);
927  };  
928  #ifdef _MSC_VER
929  # pragma warning(pop)  
930  #endif  
931  void ReportUninterestingCall(CallReaction reaction, const string& msg);
932  }  
933  using internal::MockSpec;
934  template <typename T>
935  inline const T& Const(const T& x) { return x; }
936  inline Expectation::Expectation(internal::ExpectationBase& exp)  
937      : expectation_base_(exp.GetHandle().expectation_base()) {}
938  }  
939  #define GMOCK_ON_CALL_IMPL_(obj, call) \
940      ((obj).gmock_##call).InternalDefaultActionSetAt(__FILE__, __LINE__, \
941                                                      #obj, #call)
942  #define ON_CALL(obj, call) GMOCK_ON_CALL_IMPL_(obj, call)
943  #define GMOCK_EXPECT_CALL_IMPL_(obj, call) \
944      ((obj).gmock_##call).InternalExpectedAt(__FILE__, __LINE__, #obj, #call)
945  #define EXPECT_CALL(obj, call) GMOCK_EXPECT_CALL_IMPL_(obj, call)
946  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-openclwrapper.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-gmock-spec-builders.h</div>
                </div>
                <div class="column column_space"><pre><code>1299    KernelEnv rEnv;
1300    SetKernelEnv(&rEnv);
1301    int block_size = 256;
1302    cl_uint numCUs = 6;
</pre></code></div>
                <div class="column column_space"><pre><code>558        ExpectationSet unsatisfied_prereqs;
559        FindUnsatisfiedPrerequisites(&unsatisfied_prereqs);
560        int i = 0;
561        for (ExpectationSet::const_iterator it = unsatisfied_prereqs.begin();
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    