
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 59, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-detection_output_layer.cpp</h3>
            <pre><code>1  #include &lt;algorithm&gt;
2  #include &lt;fstream&gt;  
3  #include &lt;map&gt;
4  #include &lt;string&gt;
5  #include &lt;utility&gt;
6  #include &lt;vector&gt;
7  #include &quot;boost/filesystem.hpp&quot;
8  #include &quot;boost/foreach.hpp&quot;
9  #include &quot;caffe/layers/detection_output_layer.hpp&quot;
10  namespace caffe {
11  template &lt;typename Dtype&gt;
12  void DetectionOutputLayer&lt;Dtype&gt;::LayerSetUp(const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; bottom,
13        const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; top) {
14    const DetectionOutputParameter&amp; detection_output_param =
15        this-&gt;layer_param_.detection_output_param();
16    CHECK(detection_output_param.has_num_classes()) &lt;&lt; &quot;Must specify num_classes&quot;;
17    num_classes_ = detection_output_param.num_classes();
18    share_location_ = detection_output_param.share_location();
19    num_loc_classes_ = share_location_ ? 1 : num_classes_;
20    background_label_id_ = detection_output_param.background_label_id();
21    code_type_ = detection_output_param.code_type();
22    variance_encoded_in_target_ =
23        detection_output_param.variance_encoded_in_target();
24    keep_top_k_ = detection_output_param.keep_top_k();
25    confidence_threshold_ = detection_output_param.has_confidence_threshold() ?
26        detection_output_param.confidence_threshold() : -FLT_MAX;
27    nms_threshold_ = detection_output_param.nms_param().nms_threshold();
28    CHECK_GE(nms_threshold_, 0.) &lt;&lt; &quot;nms_threshold must be non negative.&quot;;
29    eta_ = detection_output_param.nms_param().eta();
30    CHECK_GT(eta_, 0.);
31    CHECK_LE(eta_, 1.);
32    top_k_ = -1;
33    if (detection_output_param.nms_param().has_top_k()) {
34      top_k_ = detection_output_param.nms_param().top_k();
35    }
36    const SaveOutputParameter&amp; save_output_param =
37        detection_output_param.save_output_param();
38    output_directory_ = save_output_param.output_directory();
39    if (!output_directory_.empty()) {
40      if (boost::filesystem::is_directory(output_directory_)
41  #ifdef USE_MLSL
42          &amp;&amp; mn::is_root() == true
43  #endif
44         )
45        boost::filesystem::remove_all(output_directory_);
46  #ifdef USE_MLSL
47      if(mn::is_root() == true){
48  #endif
49      boost::filesystem::create_directories(output_directory_);
50      if(!boost::filesystem::is_directory(output_directory_))
51        LOG(FATAL) &lt;&lt; &quot;Failed to create directory: &quot; &lt;&lt; output_directory_;
52  #ifdef USE_MLSL
53      }
54  #endif
55    }
56    output_name_prefix_ = save_output_param.output_name_prefix();
57    need_save_ = output_directory_ == &quot;&quot; ? false : true;
58    output_format_ = save_output_param.output_format();
59    if (save_output_param.has_label_map_file()) {
60      string label_map_file = save_output_param.label_map_file();
61      if (label_map_file.empty()) {
62        LOG(WARNING) &lt;&lt; &quot;Provide label_map_file if output results to files.&quot;;
63        need_save_ = false;
64      } else {
65        LabelMap label_map;
66        CHECK(ReadProtoFromTextFile(label_map_file, &amp;label_map))
67            &lt;&lt; &quot;Failed to read label map file: &quot; &lt;&lt; label_map_file;
68        CHECK(MapLabelToName(label_map, true, &amp;label_to_name_))
69            &lt;&lt; &quot;Failed to convert label to name.&quot;;
70        CHECK(MapLabelToDisplayName(label_map, true, &amp;label_to_display_name_))
71            &lt;&lt; &quot;Failed to convert label to display name.&quot;;
72      }
73    } else {
74      need_save_ = false;
75    }
76    if (save_output_param.has_name_size_file()) {
77      string name_size_file = save_output_param.name_size_file();
78      if (name_size_file.empty()) {
79        LOG(WARNING) &lt;&lt; &quot;Provide name_size_file if output results to files.&quot;;
80        need_save_ = false;
81      } else {
82        std::ifstream infile(name_size_file.c_str());
83        CHECK(infile.good())
84            &lt;&lt; &quot;Failed to open name size file: &quot; &lt;&lt; name_size_file;
85        string name;
86        int height, width;
87        while (infile &gt;&gt; name &gt;&gt; height &gt;&gt; width) {
88          names_.push_back(name);
89          sizes_.push_back(std::make_pair(height, width));
90        }
91        infile.close();
92        if (save_output_param.has_num_test_image()) {
93          num_test_image_ = save_output_param.num_test_image();
94        } else {
95          num_test_image_ = names_.size();
96        }
97        CHECK_LE(num_test_image_, names_.size());
98      }
99    } else {
100      need_save_ = false;
101    }
102    has_resize_ = save_output_param.has_resize_param();
103    if (has_resize_) {
104      resize_param_ = save_output_param.resize_param();
105    }
106    name_count_ = 0;
107    visualize_ = detection_output_param.visualize();
108    if (visualize_) {
109      visualize_threshold_ = 0.6;
110      if (detection_output_param.has_visualize_threshold()) {
111        visualize_threshold_ = detection_output_param.visualize_threshold();
112      }
113      data_transformer_.reset(
114          new DataTransformer&lt;Dtype&gt;(this-&gt;layer_param_.transform_param(),
115                                     this-&gt;phase_));
116      data_transformer_-&gt;InitRand();
117      save_file_ = detection_output_param.save_file();
118    }
119    bbox_preds_.ReshapeLike(*(bottom[0]));
120    if (!share_location_) {
121      bbox_permute_.ReshapeLike(*(bottom[0]));
122    }
123    conf_permute_.ReshapeLike(*(bottom[1]));
124  }
125  template &lt;typename Dtype&gt;
126  void DetectionOutputLayer&lt;Dtype&gt;::Reshape(const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; bottom,
127        const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; top) {
128    if (need_save_) {
129      CHECK_LE(name_count_, names_.size());
130      if (name_count_ % num_test_image_ == 0) {
131        if (output_format_ == &quot;VOC&quot;) {
132  #ifdef USE_MLSL
133          mn::barrier();
134  #endif
135          boost::filesystem::path output_directory(output_directory_);
136          for (map&lt;int, string&gt;::iterator it = label_to_name_.begin();
137               it != label_to_name_.end(); ++it) {
138            if (it-&gt;first == background_label_id_) {
139              continue;
140            }
141            std::ofstream outfile;
142            boost::filesystem::path file(
143                output_name_prefix_ + it-&gt;second + &quot;.txt&quot;);
144            boost::filesystem::path out_file = output_directory / file;
145            outfile.open(out_file.string().c_str(), std::ofstream::out);
146          }
147        }
148      }
149    }
150    CHECK_EQ(bottom[0]-&gt;num(), bottom[1]-&gt;num());
151    if (bbox_preds_.num() != bottom[0]-&gt;num() ||
152        bbox_preds_.count(1) != bottom[0]-&gt;count(1)) {
153      bbox_preds_.ReshapeLike(*(bottom[0]));
154    }
155    if (!share_location_ &amp;&amp; (bbox_permute_.num() != bottom[0]-&gt;num() ||
156        bbox_permute_.count(1) != bottom[0]-&gt;count(1))) {
157      bbox_permute_.ReshapeLike(*(bottom[0]));
158    }
159    if (conf_permute_.num() != bottom[1]-&gt;num() ||
160        conf_permute_.count(1) != bottom[1]-&gt;count(1)) {
161      conf_permute_.ReshapeLike(*(bottom[1]));
162    }
163    num_priors_ = bottom[2]-&gt;height() / 4;
164    CHECK_EQ(num_priors_ * num_loc_classes_ * 4, bottom[0]-&gt;channels())
165        &lt;&lt; &quot;Number of priors must match number of location predictions.&quot;;
166    CHECK_EQ(num_priors_ * num_classes_, bottom[1]-&gt;channels())
167        &lt;&lt; &quot;Number of priors must match number of confidence predictions.&quot;;
168    vector&lt;int&gt; top_shape(2, 1);
169    top_shape.push_back(1);
170    top_shape.push_back(7);
171    top[0]-&gt;Reshape(top_shape);
172  }
173  template &lt;typename Dtype&gt;
174  void DetectionOutputLayer&lt;Dtype&gt;::Forward_cpu(
175      const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; bottom, const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; top) {
176    const Dtype* loc_data = bottom[0]-&gt;cpu_data();
177    const Dtype* conf_data = bottom[1]-&gt;cpu_data();
178    const Dtype* prior_data = bottom[2]-&gt;cpu_data();
179    const int num = bottom[0]-&gt;num();
180    vector&lt;LabelBBox&gt; all_loc_preds;
181    GetLocPredictions(loc_data, num, num_priors_, num_loc_classes_,
182                      share_location_, &amp;all_loc_preds);
183    vector&lt;map&lt;int, vector&lt;float&gt; &gt; &gt; all_conf_scores;
184    GetConfidenceScores(conf_data, num, num_priors_, num_classes_,
185                        &amp;all_conf_scores);
186    vector&lt;NormalizedBBox&gt; prior_bboxes(num_priors_);
187    vector&lt;vector&lt;float&gt; &gt; prior_variances(num_priors_);
188    GetPriorBBoxes(prior_data, num_priors_, &amp;prior_bboxes, &amp;prior_variances);
189    vector&lt;LabelBBox&gt; all_decode_bboxes;
190    const bool clip_bbox = false;
191    DecodeBBoxesAll(all_loc_preds, prior_bboxes, prior_variances, num,
192                    share_location_, num_loc_classes_, background_label_id_,
193                    code_type_, variance_encoded_in_target_, clip_bbox,
194                    &amp;all_decode_bboxes);
195    int num_kept = 0;
196    vector&lt;map&lt;int, vector&lt;int&gt; &gt; &gt; all_indices(num);
197  #ifdef _OPENMP
198    #pragma omp parallel for
199  #endif
200    for (int i = 0; i &lt; num; ++i) {
201      const LabelBBox&amp; decode_bboxes = all_decode_bboxes[i];
202      const map&lt;int, vector&lt;float&gt; &gt;&amp; conf_scores = all_conf_scores[i];
203      map&lt;int, vector&lt;int&gt; &gt; indices;
204      int num_det = 0;
205      for (int c = 0; c &lt; num_classes_; ++c) {
206        if (c == background_label_id_) {
207          continue;
208        }
209        if (conf_scores.find(c) == conf_scores.end()) {
210          LOG(FATAL) &lt;&lt; &quot;Could not find confidence predictions for label &quot; &lt;&lt; c;
211        }
212        const vector&lt;float&gt;&amp; scores = conf_scores.find(c)-&gt;second;
213        int label = share_location_ ? -1 : c;
214        if (decode_bboxes.find(label) == decode_bboxes.end()) {
215          LOG(FATAL) &lt;&lt; &quot;Could not find location predictions for label &quot; &lt;&lt; label;
216          continue;
217        }
218        const vector&lt;NormalizedBBox&gt;&amp; bboxes = decode_bboxes.find(label)-&gt;second;
219        ApplyNMSFast(bboxes, scores, confidence_threshold_, nms_threshold_, eta_,
220            top_k_, &amp;(indices[c]));
221        num_det += indices[c].size();
222      }
223      int num_to_add = 0;
224      if (keep_top_k_ &gt; -1 &amp;&amp; num_det &gt; keep_top_k_) {
225        vector&lt;pair&lt;float, pair&lt;int, int&gt; &gt; &gt; score_index_pairs;
226        for (map&lt;int, vector&lt;int&gt; &gt;::iterator it = indices.begin();
227             it != indices.end(); ++it) {
228          int label = it-&gt;first;
229          const vector&lt;int&gt;&amp; label_indices = it-&gt;second;
230          if (conf_scores.find(label) == conf_scores.end()) {
231            LOG(FATAL) &lt;&lt; &quot;Could not find location predictions for &quot; &lt;&lt; label;
232            continue;
233          }
234          const vector&lt;float&gt;&amp; scores = conf_scores.find(label)-&gt;second;
235          for (int j = 0; j &lt; label_indices.size(); ++j) {
236            int idx = label_indices[j];
237            CHECK_LT(idx, scores.size());
238            score_index_pairs.push_back(std::make_pair(
239                    scores[idx], std::make_pair(label, idx)));
240          }
241        }
242        std::sort(score_index_pairs.begin(), score_index_pairs.end(),
243                  SortScorePairDescend&lt;pair&lt;int, int&gt; &gt;);
244        score_index_pairs.resize(keep_top_k_);
245        map&lt;int, vector&lt;int&gt; &gt; new_indices;
246        for (int j = 0; j &lt; score_index_pairs.size(); ++j) {
247          int label = score_index_pairs[j].second.first;
248          int idx = score_index_pairs[j].second.second;
249          new_indices[label].push_back(idx);
250        }
251        all_indices[i] = new_indices;
252        num_to_add = keep_top_k_;
253      } else {
254        all_indices[i] = indices;
255        num_to_add = num_det;
256      }
257  #ifdef _OPENMP
258      #pragma omp atomic
259  #endif
260      num_kept += num_to_add;
261    }
262    vector&lt;int&gt; top_shape(2, 1);
263    top_shape.push_back(num_kept);
264    top_shape.push_back(7);
265    Dtype* top_data;
266    if (num_kept == 0) {
267      LOG(INFO) &lt;&lt; &quot;Couldn&#x27;t find any detections&quot;;
268      top_shape[2] = num;
269      top[0]-&gt;Reshape(top_shape);
270      top_data = top[0]-&gt;mutable_cpu_data();
271      caffe_set&lt;Dtype&gt;(top[0]-&gt;count(), -1, top_data);
272      for (int i = 0; i &lt; num; ++i) {
273        top_data[0] = i;
274        top_data += 7;
275      }
276    } else {
277      top[0]-&gt;Reshape(top_shape);
278      top_data = top[0]-&gt;mutable_cpu_data();
279    }
280    int count = 0;
281    boost::filesystem::path output_directory(output_directory_);
282    for (int i = 0; i &lt; num; ++i) {
283      const map&lt;int, vector&lt;float&gt; &gt;&amp; conf_scores = all_conf_scores[i];
284      const LabelBBox&amp; decode_bboxes = all_decode_bboxes[i];
285      for (map&lt;int, vector&lt;int&gt; &gt;::iterator it = all_indices[i].begin();
286           it != all_indices[i].end(); ++it) {
287        int label = it-&gt;first;
288        if (conf_scores.find(label) == conf_scores.end()) {
289          LOG(FATAL) &lt;&lt; &quot;Could not find confidence predictions for &quot; &lt;&lt; label;
290          continue;
291        }
292        const vector&lt;float&gt;&amp; scores = conf_scores.find(label)-&gt;second;
293        int loc_label = share_location_ ? -1 : label;
294        if (decode_bboxes.find(loc_label) == decode_bboxes.end()) {
295          LOG(FATAL) &lt;&lt; &quot;Could not find location predictions for &quot; &lt;&lt; loc_label;
296          continue;
297        }
298        const vector&lt;NormalizedBBox&gt;&amp; bboxes =
299            decode_bboxes.find(loc_label)-&gt;second;
300        vector&lt;int&gt;&amp; indices = it-&gt;second;
301        if (need_save_) {
302          CHECK(label_to_name_.find(label) != label_to_name_.end())
303            &lt;&lt; &quot;Cannot find label: &quot; &lt;&lt; label &lt;&lt; &quot; in the label map.&quot;;
304          CHECK_LT(name_count_, names_.size());
305        }
306        for (int j = 0; j &lt; indices.size(); ++j) {
307          int idx = indices[j];
308          top_data[count * 7] = i;
309          top_data[count * 7 + 1] = label;
310          top_data[count * 7 + 2] = scores[idx];
311          const NormalizedBBox&amp; bbox = bboxes[idx];
312          top_data[count * 7 + 3] = bbox.xmin();
313          top_data[count * 7 + 4] = bbox.ymin();
314          top_data[count * 7 + 5] = bbox.xmax();
315          top_data[count * 7 + 6] = bbox.ymax();
316          if (need_save_) {
317            NormalizedBBox out_bbox;
318            OutputBBox(bbox, sizes_[name_count_], has_resize_, resize_param_,
319                       &amp;out_bbox);
320            float score = top_data[count * 7 + 2];
321            float xmin = out_bbox.xmin();
322            float ymin = out_bbox.ymin();
323            float xmax = out_bbox.xmax();
324            float ymax = out_bbox.ymax();
325            ptree pt_xmin, pt_ymin, pt_width, pt_height;
326            pt_xmin.put&lt;float&gt;(&quot;&quot;, round(xmin * 100) / 100.);
327            pt_ymin.put&lt;float&gt;(&quot;&quot;, round(ymin * 100) / 100.);
328            pt_width.put&lt;float&gt;(&quot;&quot;, round((xmax - xmin) * 100) / 100.);
329            pt_height.put&lt;float&gt;(&quot;&quot;, round((ymax - ymin) * 100) / 100.);
330            ptree cur_bbox;
331            cur_bbox.push_back(std::make_pair(&quot;&quot;, pt_xmin));
332            cur_bbox.push_back(std::make_pair(&quot;&quot;, pt_ymin));
333            cur_bbox.push_back(std::make_pair(&quot;&quot;, pt_width));
334            cur_bbox.push_back(std::make_pair(&quot;&quot;, pt_height));
335            ptree cur_det;
336            cur_det.put(&quot;image_id&quot;, names_[name_count_]);
337            if (output_format_ == &quot;ILSVRC&quot;) {
338              cur_det.put&lt;int&gt;(&quot;category_id&quot;, label);
339            } else {
340              cur_det.put(&quot;category_id&quot;, label_to_name_[label].c_str());
341            }
342            cur_det.add_child(&quot;bbox&quot;, cur_bbox);
343            cur_det.put&lt;float&gt;(&quot;score&quot;, score);
344            detections_.push_back(std::make_pair(&quot;&quot;, cur_det));
345          }
346          ++count;
347        }
348      }
349      if (need_save_) {
350        ++name_count_;
351        if (name_count_ % num_test_image_ == 0) {
352          if (output_format_ == &quot;VOC&quot;) {
353            map&lt;string, std::ofstream*&gt; outfiles;
354            for (int c = 0; c &lt; num_classes_; ++c) {
355              if (c == background_label_id_) {
356                continue;
357              }
358              string label_name = label_to_name_[c];
359              boost::filesystem::path file(
360                  output_name_prefix_ + label_name + &quot;.txt&quot;);
361              boost::filesystem::path out_file = output_directory / file;
362              outfiles[label_name] = new std::ofstream(out_file.string().c_str(),
363                  std::ofstream::out);
364            }
365            BOOST_FOREACH(ptree::value_type &amp;det, detections_.get_child(&quot;&quot;)) {
366              ptree pt = det.second;
367              string label_name = pt.get&lt;string&gt;(&quot;category_id&quot;);
368              if (outfiles.find(label_name) == outfiles.end()) {
369                std::cout &lt;&lt; &quot;Cannot find &quot; &lt;&lt; label_name &lt;&lt; std::endl;
370                continue;
371              }
372              string image_name = pt.get&lt;string&gt;(&quot;image_id&quot;);
373              float score = pt.get&lt;float&gt;(&quot;score&quot;);
374              vector&lt;int&gt; bbox;
375              BOOST_FOREACH(ptree::value_type &amp;elem, pt.get_child(&quot;bbox&quot;)) {
376                bbox.push_back(static_cast&lt;int&gt;(elem.second.get_value&lt;float&gt;()));
377              }
378              *(outfiles[label_name]) &lt;&lt; image_name;
379              *(outfiles[label_name]) &lt;&lt; &quot; &quot; &lt;&lt; score;
380              *(outfiles[label_name]) &lt;&lt; &quot; &quot; &lt;&lt; bbox[0] &lt;&lt; &quot; &quot; &lt;&lt; bbox[1];
381              *(outfiles[label_name]) &lt;&lt; &quot; &quot; &lt;&lt; bbox[0] + bbox[2];
382              *(outfiles[label_name]) &lt;&lt; &quot; &quot; &lt;&lt; bbox[1] + bbox[3];
383              *(outfiles[label_name]) &lt;&lt; std::endl;
384            }
385            for (int c = 0; c &lt; num_classes_; ++c) {
386              if (c == background_label_id_) {
387                continue;
388              }
389              string label_name = label_to_name_[c];
390              outfiles[label_name]-&gt;flush();
391              outfiles[label_name]-&gt;close();
392              delete outfiles[label_name];
393            }
394          } else if (output_format_ == &quot;COCO&quot;) {
<span onclick='openModal()' class='match'>395            boost::filesystem::path output_directory(output_directory_);
396            boost::filesystem::path file(output_name_prefix_ + &quot;.json&quot;);
397            boost::filesystem::path out_file = output_directory / file;
398            std::ofstream outfile;
399            outfile.open(out_file.string().c_str(), std::ofstream::out);
400            boost::regex exp(&quot;\&quot;(null|true|false|-?[0-9]+(\\.[0-9]+)?)\&quot;&quot;);
</span>401            ptree output;
402            output.add_child(&quot;detections&quot;, detections_);
403            std::stringstream ss;
404            write_json(ss, output);
405            std::string rv = boost::regex_replace(ss.str(), exp, &quot;$1&quot;);
406            outfile &lt;&lt; rv.substr(rv.find(&quot;[&quot;), rv.rfind(&quot;]&quot;) - rv.find(&quot;[&quot;))
407                &lt;&lt; std::endl &lt;&lt; &quot;]&quot; &lt;&lt; std::endl;
408          } else if (output_format_ == &quot;ILSVRC&quot;) {
409            boost::filesystem::path output_directory(output_directory_);
410            boost::filesystem::path file(output_name_prefix_ + &quot;.txt&quot;);
411            boost::filesystem::path out_file = output_directory / file;
412            std::ofstream outfile;
413            outfile.open(out_file.string().c_str(), std::ofstream::out);
414            BOOST_FOREACH(ptree::value_type &amp;det, detections_.get_child(&quot;&quot;)) {
415              ptree pt = det.second;
416              int label = pt.get&lt;int&gt;(&quot;category_id&quot;);
417              string image_name = pt.get&lt;string&gt;(&quot;image_id&quot;);
418              float score = pt.get&lt;float&gt;(&quot;score&quot;);
419              vector&lt;int&gt; bbox;
420              BOOST_FOREACH(ptree::value_type &amp;elem, pt.get_child(&quot;bbox&quot;)) {
421                bbox.push_back(static_cast&lt;int&gt;(elem.second.get_value&lt;float&gt;()));
422              }
423              outfile &lt;&lt; image_name &lt;&lt; &quot; &quot; &lt;&lt; label &lt;&lt; &quot; &quot; &lt;&lt; score;
424              outfile &lt;&lt; &quot; &quot; &lt;&lt; bbox[0] &lt;&lt; &quot; &quot; &lt;&lt; bbox[1];
425              outfile &lt;&lt; &quot; &quot; &lt;&lt; bbox[0] + bbox[2];
426              outfile &lt;&lt; &quot; &quot; &lt;&lt; bbox[1] + bbox[3];
427              outfile &lt;&lt; std::endl;
428            }
429          }
430          name_count_ = 0;
431          detections_.clear();
432        }
433      }
434    }
435    if (visualize_) {
436  #ifdef USE_OPENCV
437      vector&lt;cv::Mat&gt; cv_imgs;
438      this-&gt;data_transformer_-&gt;TransformInv(bottom[3], &amp;cv_imgs);
439      vector&lt;cv::Scalar&gt; colors = GetColors(label_to_display_name_.size());
440      VisualizeBBox(cv_imgs, top[0], visualize_threshold_, colors,
441          label_to_display_name_, save_file_);
442  #endif  
443    }
444  }
445  #ifdef CPU_ONLY
446  STUB_GPU_FORWARD(DetectionOutputLayer, Forward);
447  #endif
448  INSTANTIATE_CLASS(DetectionOutputLayer);
449  REGISTER_LAYER_CLASS(DetectionOutput);
450  }  
</code></pre>
        </div>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-detection_output_layer.cpp</h3>
            <pre><code>1  #include &lt;algorithm&gt;
2  #include &lt;fstream&gt;  
3  #include &lt;map&gt;
4  #include &lt;string&gt;
5  #include &lt;utility&gt;
6  #include &lt;vector&gt;
7  #include &quot;boost/filesystem.hpp&quot;
8  #include &quot;boost/foreach.hpp&quot;
9  #include &quot;caffe/layers/detection_output_layer.hpp&quot;
10  namespace caffe {
11  template &lt;typename Dtype&gt;
12  void DetectionOutputLayer&lt;Dtype&gt;::LayerSetUp(const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; bottom,
13        const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; top) {
14    const DetectionOutputParameter&amp; detection_output_param =
15        this-&gt;layer_param_.detection_output_param();
16    CHECK(detection_output_param.has_num_classes()) &lt;&lt; &quot;Must specify num_classes&quot;;
17    num_classes_ = detection_output_param.num_classes();
18    share_location_ = detection_output_param.share_location();
19    num_loc_classes_ = share_location_ ? 1 : num_classes_;
20    background_label_id_ = detection_output_param.background_label_id();
21    code_type_ = detection_output_param.code_type();
22    variance_encoded_in_target_ =
23        detection_output_param.variance_encoded_in_target();
24    keep_top_k_ = detection_output_param.keep_top_k();
25    confidence_threshold_ = detection_output_param.has_confidence_threshold() ?
26        detection_output_param.confidence_threshold() : -FLT_MAX;
27    nms_threshold_ = detection_output_param.nms_param().nms_threshold();
28    CHECK_GE(nms_threshold_, 0.) &lt;&lt; &quot;nms_threshold must be non negative.&quot;;
29    eta_ = detection_output_param.nms_param().eta();
30    CHECK_GT(eta_, 0.);
31    CHECK_LE(eta_, 1.);
32    top_k_ = -1;
33    if (detection_output_param.nms_param().has_top_k()) {
34      top_k_ = detection_output_param.nms_param().top_k();
35    }
36    const SaveOutputParameter&amp; save_output_param =
37        detection_output_param.save_output_param();
38    output_directory_ = save_output_param.output_directory();
39    if (!output_directory_.empty()) {
40      if (boost::filesystem::is_directory(output_directory_)
41  #ifdef USE_MLSL
42          &amp;&amp; mn::is_root() == true
43  #endif
44         )
45        boost::filesystem::remove_all(output_directory_);
46  #ifdef USE_MLSL
47      if(mn::is_root() == true){
48  #endif
49      boost::filesystem::create_directories(output_directory_);
50      if(!boost::filesystem::is_directory(output_directory_))
51        LOG(FATAL) &lt;&lt; &quot;Failed to create directory: &quot; &lt;&lt; output_directory_;
52  #ifdef USE_MLSL
53      }
54  #endif
55    }
56    output_name_prefix_ = save_output_param.output_name_prefix();
57    need_save_ = output_directory_ == &quot;&quot; ? false : true;
58    output_format_ = save_output_param.output_format();
59    if (save_output_param.has_label_map_file()) {
60      string label_map_file = save_output_param.label_map_file();
61      if (label_map_file.empty()) {
62        LOG(WARNING) &lt;&lt; &quot;Provide label_map_file if output results to files.&quot;;
63        need_save_ = false;
64      } else {
65        LabelMap label_map;
66        CHECK(ReadProtoFromTextFile(label_map_file, &amp;label_map))
67            &lt;&lt; &quot;Failed to read label map file: &quot; &lt;&lt; label_map_file;
68        CHECK(MapLabelToName(label_map, true, &amp;label_to_name_))
69            &lt;&lt; &quot;Failed to convert label to name.&quot;;
70        CHECK(MapLabelToDisplayName(label_map, true, &amp;label_to_display_name_))
71            &lt;&lt; &quot;Failed to convert label to display name.&quot;;
72      }
73    } else {
74      need_save_ = false;
75    }
76    if (save_output_param.has_name_size_file()) {
77      string name_size_file = save_output_param.name_size_file();
78      if (name_size_file.empty()) {
79        LOG(WARNING) &lt;&lt; &quot;Provide name_size_file if output results to files.&quot;;
80        need_save_ = false;
81      } else {
82        std::ifstream infile(name_size_file.c_str());
83        CHECK(infile.good())
84            &lt;&lt; &quot;Failed to open name size file: &quot; &lt;&lt; name_size_file;
85        string name;
86        int height, width;
87        while (infile &gt;&gt; name &gt;&gt; height &gt;&gt; width) {
88          names_.push_back(name);
89          sizes_.push_back(std::make_pair(height, width));
90        }
91        infile.close();
92        if (save_output_param.has_num_test_image()) {
93          num_test_image_ = save_output_param.num_test_image();
94        } else {
95          num_test_image_ = names_.size();
96        }
97        CHECK_LE(num_test_image_, names_.size());
98      }
99    } else {
100      need_save_ = false;
101    }
102    has_resize_ = save_output_param.has_resize_param();
103    if (has_resize_) {
104      resize_param_ = save_output_param.resize_param();
105    }
106    name_count_ = 0;
107    visualize_ = detection_output_param.visualize();
108    if (visualize_) {
109      visualize_threshold_ = 0.6;
110      if (detection_output_param.has_visualize_threshold()) {
111        visualize_threshold_ = detection_output_param.visualize_threshold();
112      }
113      data_transformer_.reset(
114          new DataTransformer&lt;Dtype&gt;(this-&gt;layer_param_.transform_param(),
115                                     this-&gt;phase_));
116      data_transformer_-&gt;InitRand();
117      save_file_ = detection_output_param.save_file();
118    }
119    bbox_preds_.ReshapeLike(*(bottom[0]));
120    if (!share_location_) {
121      bbox_permute_.ReshapeLike(*(bottom[0]));
122    }
123    conf_permute_.ReshapeLike(*(bottom[1]));
124  }
125  template &lt;typename Dtype&gt;
126  void DetectionOutputLayer&lt;Dtype&gt;::Reshape(const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; bottom,
127        const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; top) {
128    if (need_save_) {
129      CHECK_LE(name_count_, names_.size());
130      if (name_count_ % num_test_image_ == 0) {
131        if (output_format_ == &quot;VOC&quot;) {
132  #ifdef USE_MLSL
133          mn::barrier();
134  #endif
135          boost::filesystem::path output_directory(output_directory_);
136          for (map&lt;int, string&gt;::iterator it = label_to_name_.begin();
137               it != label_to_name_.end(); ++it) {
138            if (it-&gt;first == background_label_id_) {
139              continue;
140            }
141            std::ofstream outfile;
142            boost::filesystem::path file(
143                output_name_prefix_ + it-&gt;second + &quot;.txt&quot;);
144            boost::filesystem::path out_file = output_directory / file;
145            outfile.open(out_file.string().c_str(), std::ofstream::out);
146          }
147        }
148      }
149    }
150    CHECK_EQ(bottom[0]-&gt;num(), bottom[1]-&gt;num());
151    if (bbox_preds_.num() != bottom[0]-&gt;num() ||
152        bbox_preds_.count(1) != bottom[0]-&gt;count(1)) {
153      bbox_preds_.ReshapeLike(*(bottom[0]));
154    }
155    if (!share_location_ &amp;&amp; (bbox_permute_.num() != bottom[0]-&gt;num() ||
156        bbox_permute_.count(1) != bottom[0]-&gt;count(1))) {
157      bbox_permute_.ReshapeLike(*(bottom[0]));
158    }
159    if (conf_permute_.num() != bottom[1]-&gt;num() ||
160        conf_permute_.count(1) != bottom[1]-&gt;count(1)) {
161      conf_permute_.ReshapeLike(*(bottom[1]));
162    }
163    num_priors_ = bottom[2]-&gt;height() / 4;
164    CHECK_EQ(num_priors_ * num_loc_classes_ * 4, bottom[0]-&gt;channels())
165        &lt;&lt; &quot;Number of priors must match number of location predictions.&quot;;
166    CHECK_EQ(num_priors_ * num_classes_, bottom[1]-&gt;channels())
167        &lt;&lt; &quot;Number of priors must match number of confidence predictions.&quot;;
168    vector&lt;int&gt; top_shape(2, 1);
169    top_shape.push_back(1);
170    top_shape.push_back(7);
171    top[0]-&gt;Reshape(top_shape);
172  }
173  template &lt;typename Dtype&gt;
174  void DetectionOutputLayer&lt;Dtype&gt;::Forward_cpu(
175      const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; bottom, const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; top) {
176    const Dtype* loc_data = bottom[0]-&gt;cpu_data();
177    const Dtype* conf_data = bottom[1]-&gt;cpu_data();
178    const Dtype* prior_data = bottom[2]-&gt;cpu_data();
179    const int num = bottom[0]-&gt;num();
180    vector&lt;LabelBBox&gt; all_loc_preds;
181    GetLocPredictions(loc_data, num, num_priors_, num_loc_classes_,
182                      share_location_, &amp;all_loc_preds);
183    vector&lt;map&lt;int, vector&lt;float&gt; &gt; &gt; all_conf_scores;
184    GetConfidenceScores(conf_data, num, num_priors_, num_classes_,
185                        &amp;all_conf_scores);
186    vector&lt;NormalizedBBox&gt; prior_bboxes(num_priors_);
187    vector&lt;vector&lt;float&gt; &gt; prior_variances(num_priors_);
188    GetPriorBBoxes(prior_data, num_priors_, &amp;prior_bboxes, &amp;prior_variances);
189    vector&lt;LabelBBox&gt; all_decode_bboxes;
190    const bool clip_bbox = false;
191    DecodeBBoxesAll(all_loc_preds, prior_bboxes, prior_variances, num,
192                    share_location_, num_loc_classes_, background_label_id_,
193                    code_type_, variance_encoded_in_target_, clip_bbox,
194                    &amp;all_decode_bboxes);
195    int num_kept = 0;
196    vector&lt;map&lt;int, vector&lt;int&gt; &gt; &gt; all_indices(num);
197  #ifdef _OPENMP
198    #pragma omp parallel for
199  #endif
200    for (int i = 0; i &lt; num; ++i) {
201      const LabelBBox&amp; decode_bboxes = all_decode_bboxes[i];
202      const map&lt;int, vector&lt;float&gt; &gt;&amp; conf_scores = all_conf_scores[i];
203      map&lt;int, vector&lt;int&gt; &gt; indices;
204      int num_det = 0;
205      for (int c = 0; c &lt; num_classes_; ++c) {
206        if (c == background_label_id_) {
207          continue;
208        }
209        if (conf_scores.find(c) == conf_scores.end()) {
210          LOG(FATAL) &lt;&lt; &quot;Could not find confidence predictions for label &quot; &lt;&lt; c;
211        }
212        const vector&lt;float&gt;&amp; scores = conf_scores.find(c)-&gt;second;
213        int label = share_location_ ? -1 : c;
214        if (decode_bboxes.find(label) == decode_bboxes.end()) {
215          LOG(FATAL) &lt;&lt; &quot;Could not find location predictions for label &quot; &lt;&lt; label;
216          continue;
217        }
218        const vector&lt;NormalizedBBox&gt;&amp; bboxes = decode_bboxes.find(label)-&gt;second;
219        ApplyNMSFast(bboxes, scores, confidence_threshold_, nms_threshold_, eta_,
220            top_k_, &amp;(indices[c]));
221        num_det += indices[c].size();
222      }
223      int num_to_add = 0;
224      if (keep_top_k_ &gt; -1 &amp;&amp; num_det &gt; keep_top_k_) {
225        vector&lt;pair&lt;float, pair&lt;int, int&gt; &gt; &gt; score_index_pairs;
226        for (map&lt;int, vector&lt;int&gt; &gt;::iterator it = indices.begin();
227             it != indices.end(); ++it) {
228          int label = it-&gt;first;
229          const vector&lt;int&gt;&amp; label_indices = it-&gt;second;
230          if (conf_scores.find(label) == conf_scores.end()) {
231            LOG(FATAL) &lt;&lt; &quot;Could not find location predictions for &quot; &lt;&lt; label;
232            continue;
233          }
234          const vector&lt;float&gt;&amp; scores = conf_scores.find(label)-&gt;second;
235          for (int j = 0; j &lt; label_indices.size(); ++j) {
236            int idx = label_indices[j];
237            CHECK_LT(idx, scores.size());
238            score_index_pairs.push_back(std::make_pair(
239                    scores[idx], std::make_pair(label, idx)));
240          }
241        }
242        std::sort(score_index_pairs.begin(), score_index_pairs.end(),
243                  SortScorePairDescend&lt;pair&lt;int, int&gt; &gt;);
244        score_index_pairs.resize(keep_top_k_);
245        map&lt;int, vector&lt;int&gt; &gt; new_indices;
246        for (int j = 0; j &lt; score_index_pairs.size(); ++j) {
247          int label = score_index_pairs[j].second.first;
248          int idx = score_index_pairs[j].second.second;
249          new_indices[label].push_back(idx);
250        }
251        all_indices[i] = new_indices;
252        num_to_add = keep_top_k_;
253      } else {
254        all_indices[i] = indices;
255        num_to_add = num_det;
256      }
257  #ifdef _OPENMP
258      #pragma omp atomic
259  #endif
260      num_kept += num_to_add;
261    }
262    vector&lt;int&gt; top_shape(2, 1);
263    top_shape.push_back(num_kept);
264    top_shape.push_back(7);
265    Dtype* top_data;
266    if (num_kept == 0) {
267      LOG(INFO) &lt;&lt; &quot;Couldn&#x27;t find any detections&quot;;
268      top_shape[2] = num;
269      top[0]-&gt;Reshape(top_shape);
270      top_data = top[0]-&gt;mutable_cpu_data();
271      caffe_set&lt;Dtype&gt;(top[0]-&gt;count(), -1, top_data);
272      for (int i = 0; i &lt; num; ++i) {
273        top_data[0] = i;
274        top_data += 7;
275      }
276    } else {
277      top[0]-&gt;Reshape(top_shape);
278      top_data = top[0]-&gt;mutable_cpu_data();
279    }
280    int count = 0;
281    boost::filesystem::path output_directory(output_directory_);
282    for (int i = 0; i &lt; num; ++i) {
283      const map&lt;int, vector&lt;float&gt; &gt;&amp; conf_scores = all_conf_scores[i];
284      const LabelBBox&amp; decode_bboxes = all_decode_bboxes[i];
285      for (map&lt;int, vector&lt;int&gt; &gt;::iterator it = all_indices[i].begin();
286           it != all_indices[i].end(); ++it) {
287        int label = it-&gt;first;
288        if (conf_scores.find(label) == conf_scores.end()) {
289          LOG(FATAL) &lt;&lt; &quot;Could not find confidence predictions for &quot; &lt;&lt; label;
290          continue;
291        }
292        const vector&lt;float&gt;&amp; scores = conf_scores.find(label)-&gt;second;
293        int loc_label = share_location_ ? -1 : label;
294        if (decode_bboxes.find(loc_label) == decode_bboxes.end()) {
295          LOG(FATAL) &lt;&lt; &quot;Could not find location predictions for &quot; &lt;&lt; loc_label;
296          continue;
297        }
298        const vector&lt;NormalizedBBox&gt;&amp; bboxes =
299            decode_bboxes.find(loc_label)-&gt;second;
300        vector&lt;int&gt;&amp; indices = it-&gt;second;
301        if (need_save_) {
302          CHECK(label_to_name_.find(label) != label_to_name_.end())
303            &lt;&lt; &quot;Cannot find label: &quot; &lt;&lt; label &lt;&lt; &quot; in the label map.&quot;;
304          CHECK_LT(name_count_, names_.size());
305        }
306        for (int j = 0; j &lt; indices.size(); ++j) {
307          int idx = indices[j];
308          top_data[count * 7] = i;
309          top_data[count * 7 + 1] = label;
310          top_data[count * 7 + 2] = scores[idx];
311          const NormalizedBBox&amp; bbox = bboxes[idx];
312          top_data[count * 7 + 3] = bbox.xmin();
313          top_data[count * 7 + 4] = bbox.ymin();
314          top_data[count * 7 + 5] = bbox.xmax();
315          top_data[count * 7 + 6] = bbox.ymax();
316          if (need_save_) {
317            NormalizedBBox out_bbox;
318            OutputBBox(bbox, sizes_[name_count_], has_resize_, resize_param_,
319                       &amp;out_bbox);
320            float score = top_data[count * 7 + 2];
321            float xmin = out_bbox.xmin();
322            float ymin = out_bbox.ymin();
323            float xmax = out_bbox.xmax();
324            float ymax = out_bbox.ymax();
325            ptree pt_xmin, pt_ymin, pt_width, pt_height;
326            pt_xmin.put&lt;float&gt;(&quot;&quot;, round(xmin * 100) / 100.);
327            pt_ymin.put&lt;float&gt;(&quot;&quot;, round(ymin * 100) / 100.);
328            pt_width.put&lt;float&gt;(&quot;&quot;, round((xmax - xmin) * 100) / 100.);
329            pt_height.put&lt;float&gt;(&quot;&quot;, round((ymax - ymin) * 100) / 100.);
330            ptree cur_bbox;
331            cur_bbox.push_back(std::make_pair(&quot;&quot;, pt_xmin));
332            cur_bbox.push_back(std::make_pair(&quot;&quot;, pt_ymin));
333            cur_bbox.push_back(std::make_pair(&quot;&quot;, pt_width));
334            cur_bbox.push_back(std::make_pair(&quot;&quot;, pt_height));
335            ptree cur_det;
336            cur_det.put(&quot;image_id&quot;, names_[name_count_]);
337            if (output_format_ == &quot;ILSVRC&quot;) {
338              cur_det.put&lt;int&gt;(&quot;category_id&quot;, label);
339            } else {
340              cur_det.put(&quot;category_id&quot;, label_to_name_[label].c_str());
341            }
342            cur_det.add_child(&quot;bbox&quot;, cur_bbox);
343            cur_det.put&lt;float&gt;(&quot;score&quot;, score);
344            detections_.push_back(std::make_pair(&quot;&quot;, cur_det));
345          }
346          ++count;
347        }
348      }
349      if (need_save_) {
350        ++name_count_;
351        if (name_count_ % num_test_image_ == 0) {
352          if (output_format_ == &quot;VOC&quot;) {
353            map&lt;string, std::ofstream*&gt; outfiles;
354            for (int c = 0; c &lt; num_classes_; ++c) {
355              if (c == background_label_id_) {
356                continue;
357              }
358              string label_name = label_to_name_[c];
359              boost::filesystem::path file(
360                  output_name_prefix_ + label_name + &quot;.txt&quot;);
361              boost::filesystem::path out_file = output_directory / file;
362              outfiles[label_name] = new std::ofstream(out_file.string().c_str(),
363                  std::ofstream::out);
364            }
365            BOOST_FOREACH(ptree::value_type &amp;det, detections_.get_child(&quot;&quot;)) {
366              ptree pt = det.second;
367              string label_name = pt.get&lt;string&gt;(&quot;category_id&quot;);
368              if (outfiles.find(label_name) == outfiles.end()) {
369                std::cout &lt;&lt; &quot;Cannot find &quot; &lt;&lt; label_name &lt;&lt; std::endl;
370                continue;
371              }
372              string image_name = pt.get&lt;string&gt;(&quot;image_id&quot;);
373              float score = pt.get&lt;float&gt;(&quot;score&quot;);
374              vector&lt;int&gt; bbox;
375              BOOST_FOREACH(ptree::value_type &amp;elem, pt.get_child(&quot;bbox&quot;)) {
376                bbox.push_back(static_cast&lt;int&gt;(elem.second.get_value&lt;float&gt;()));
377              }
378              *(outfiles[label_name]) &lt;&lt; image_name;
379              *(outfiles[label_name]) &lt;&lt; &quot; &quot; &lt;&lt; score;
380              *(outfiles[label_name]) &lt;&lt; &quot; &quot; &lt;&lt; bbox[0] &lt;&lt; &quot; &quot; &lt;&lt; bbox[1];
381              *(outfiles[label_name]) &lt;&lt; &quot; &quot; &lt;&lt; bbox[0] + bbox[2];
382              *(outfiles[label_name]) &lt;&lt; &quot; &quot; &lt;&lt; bbox[1] + bbox[3];
383              *(outfiles[label_name]) &lt;&lt; std::endl;
384            }
385            for (int c = 0; c &lt; num_classes_; ++c) {
386              if (c == background_label_id_) {
387                continue;
388              }
389              string label_name = label_to_name_[c];
390              outfiles[label_name]-&gt;flush();
391              outfiles[label_name]-&gt;close();
392              delete outfiles[label_name];
393            }
394          } else if (output_format_ == &quot;COCO&quot;) {
395            boost::filesystem::path output_directory(output_directory_);
396            boost::filesystem::path file(output_name_prefix_ + &quot;.json&quot;);
397            boost::filesystem::path out_file = output_directory / file;
398            std::ofstream outfile;
399            outfile.open(out_file.string().c_str(), std::ofstream::out);
400            boost::regex exp(&quot;\&quot;(null|true|false|-?[0-9]+(\\.[0-9]+)?)\&quot;&quot;);
401            ptree output;
402            output.add_child(&quot;detections&quot;, detections_);
403            std::stringstream ss;
404            write_json(ss, output);
405            std::string rv = boost::regex_replace(ss.str(), exp, &quot;$1&quot;);
406            outfile &lt;&lt; rv.substr(rv.find(&quot;[&quot;), rv.rfind(&quot;]&quot;) - rv.find(&quot;[&quot;))
407                &lt;&lt; std::endl &lt;&lt; &quot;]&quot; &lt;&lt; std::endl;
408          } else if (output_format_ == &quot;ILSVRC&quot;) {
<span onclick='openModal()' class='match'>409            boost::filesystem::path output_directory(output_directory_);
410            boost::filesystem::path file(output_name_prefix_ + &quot;.txt&quot;);
411            boost::filesystem::path out_file = output_directory / file;
412            std::ofstream outfile;
413            outfile.open(out_file.string().c_str(), std::ofstream::out);
414            BOOST_FOREACH(ptree::value_type &amp;det, detections_.get_child(&quot;&quot;)) {
</span>415              ptree pt = det.second;
416              int label = pt.get&lt;int&gt;(&quot;category_id&quot;);
417              string image_name = pt.get&lt;string&gt;(&quot;image_id&quot;);
418              float score = pt.get&lt;float&gt;(&quot;score&quot;);
419              vector&lt;int&gt; bbox;
420              BOOST_FOREACH(ptree::value_type &amp;elem, pt.get_child(&quot;bbox&quot;)) {
421                bbox.push_back(static_cast&lt;int&gt;(elem.second.get_value&lt;float&gt;()));
422              }
423              outfile &lt;&lt; image_name &lt;&lt; &quot; &quot; &lt;&lt; label &lt;&lt; &quot; &quot; &lt;&lt; score;
424              outfile &lt;&lt; &quot; &quot; &lt;&lt; bbox[0] &lt;&lt; &quot; &quot; &lt;&lt; bbox[1];
425              outfile &lt;&lt; &quot; &quot; &lt;&lt; bbox[0] + bbox[2];
426              outfile &lt;&lt; &quot; &quot; &lt;&lt; bbox[1] + bbox[3];
427              outfile &lt;&lt; std::endl;
428            }
429          }
430          name_count_ = 0;
431          detections_.clear();
432        }
433      }
434    }
435    if (visualize_) {
436  #ifdef USE_OPENCV
437      vector&lt;cv::Mat&gt; cv_imgs;
438      this-&gt;data_transformer_-&gt;TransformInv(bottom[3], &amp;cv_imgs);
439      vector&lt;cv::Scalar&gt; colors = GetColors(label_to_display_name_.size());
440      VisualizeBBox(cv_imgs, top[0], visualize_threshold_, colors,
441          label_to_display_name_, save_file_);
442  #endif  
443    }
444  }
445  #ifdef CPU_ONLY
446  STUB_GPU_FORWARD(DetectionOutputLayer, Forward);
447  #endif
448  INSTANTIATE_CLASS(DetectionOutputLayer);
449  REGISTER_LAYER_CLASS(DetectionOutput);
450  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-detection_output_layer.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-detection_output_layer.cpp</div>
                </div>
                <div class="column column_space"><pre><code>395            boost::filesystem::path output_directory(output_directory_);
396            boost::filesystem::path file(output_name_prefix_ + &quot;.json&quot;);
397            boost::filesystem::path out_file = output_directory / file;
398            std::ofstream outfile;
399            outfile.open(out_file.string().c_str(), std::ofstream::out);
400            boost::regex exp(&quot;\&quot;(null|true|false|-?[0-9]+(\\.[0-9]+)?)\&quot;&quot;);
</pre></code></div>
                <div class="column column_space"><pre><code>409            boost::filesystem::path output_directory(output_directory_);
410            boost::filesystem::path file(output_name_prefix_ + &quot;.txt&quot;);
411            boost::filesystem::path out_file = output_directory / file;
412            std::ofstream outfile;
413            outfile.open(out_file.string().c_str(), std::ofstream::out);
414            BOOST_FOREACH(ptree::value_type &amp;det, detections_.get_child(&quot;&quot;)) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    