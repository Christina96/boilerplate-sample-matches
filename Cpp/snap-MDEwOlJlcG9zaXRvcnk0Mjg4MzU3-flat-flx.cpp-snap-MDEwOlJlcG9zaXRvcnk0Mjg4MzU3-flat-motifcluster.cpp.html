
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 12.41068070703272%, Tokens: 9</h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-flx.cpp</h3>
            <pre><code>1  const int TCs::MxMask=0x0FFFFFFF;
2  TCs TCs::GetCsFromBf(char* Bf, const int& BfL){
3    TCs Cs;
4    for (int BfC=0; BfC<BfL; BfC++){Cs+=Bf[BfC];}
5    return Cs;
6  }
7  TStr TSBase::GetSNm() const {
8    return TStr(SNm.CStr());
9  }
10  TSIn::TSIn(const TStr& Str):
11    TSBase(Str.CStr()), FastMode(false){}
12  void TSIn::LoadCs(){
13    TCs CurCs=Cs; TCs TestCs;
14    Cs+=GetBf(&TestCs, sizeof(TestCs));
15    EAssertR(CurCs==TestCs, "Invalid checksum reading '"+GetSNm()+"'.");
16  }
17  void TSIn::Load(char*& CStr){
18    char Ch; Load(Ch);
19    int CStrLen=int(Ch);
20    EAssertR(CStrLen>=0, "Error reading stream '"+GetSNm()+"'.");
21    CStr=new char[CStrLen+1];
22    if (CStrLen>0){Cs+=GetBf(CStr, CStrLen);}
23    CStr[CStrLen]=TCh::NullCh;
24  }
25  const PSIn TSIn::StdIn=PSIn(new TStdIn());
26  TSOut::TSOut(const TStr& Str):
27    TSBase(Str.CStr()), MxLnLen(-1), LnLen(0){}
28  int TSOut::UpdateLnLen(const int& StrLen, const bool& ForceInLn){
29    int Cs=0;
30    if (MxLnLen!=-1){
31      if ((!ForceInLn)&&(LnLen+StrLen>MxLnLen)){Cs+=PutLn();}
32      LnLen+=StrLen;
33    }
34    return Cs;
35  }
36  int TSOut::PutMem(const TMem& Mem){
37    return PutBf(Mem(), Mem.Len());
38  }
39  int TSOut::PutCh(const char& Ch, const int& Chs){
40    int Cs=0;
41    for (int ChN=0; ChN<Chs; ChN++){Cs+=PutCh(Ch);}
42    return Cs;
43  }
44  int TSOut::PutBool(const bool& Bool){
45    return PutStr(TBool::GetStr(Bool));
46  }
47  int TSOut::PutInt(const int& Int){
48    return PutStr(TInt::GetStr(Int));
49  }
50  int TSOut::PutInt(const int& Int, char* FmtStr){
51    return PutStr(TInt::GetStr(Int, FmtStr));
52  }
53  int TSOut::PutUInt(const uint& UInt){
54    return PutStr(TUInt::GetStr(UInt));
55  }
56  int TSOut::PutUInt(const uint& UInt, char* FmtStr){
57    return PutStr(TUInt::GetStr(UInt, FmtStr));
58  }
59  int TSOut::PutFlt(const double& Flt){
60    return PutStr(TFlt::GetStr(Flt));
61  }
62  int TSOut::PutFlt(const double& Flt, char* FmtStr){
63    return PutStr(TFlt::GetStr(Flt, FmtStr));
64  }
65  int TSOut::PutStr(const char* CStr){
66    int Cs=UpdateLnLen(int(strlen(CStr)));
67    return Cs+PutBf(CStr, int(strlen(CStr)));
68  }
69  int TSOut::PutStr(const TChA& ChA){
70    int Cs=UpdateLnLen(ChA.Len());
71    return Cs+PutBf(ChA.CStr(), ChA.Len());
72  }
73  int TSOut::PutStr(const TStr& Str, char* FmtStr){
74    return PutStr(TStr::GetStr(Str, FmtStr));
75  }
76  int TSOut::PutStr(const TStr& Str, const bool& ForceInLn){
77    int Cs=UpdateLnLen(Str.Len(), ForceInLn);
78    return Cs+PutBf(Str.CStr(), Str.Len());
79  }
80  int TSOut::PutIndent(const int& IndentLev){
81    return PutCh(' ', IndentLev*2);
82  }
83  int TSOut::PutLn(const int& Lns){
84    LnLen=0; int Cs=0;
85    for (int LnN=0; LnN<Lns; LnN++){Cs+=PutCh('\n');}
86    return Cs;
87  }
88  int TSOut::PutDosLn(const int& Lns){
89    LnLen=0; int Cs=0;
90    for (int LnN=0; LnN<Lns; LnN++){Cs+=PutCh(TCh::CrCh)+PutCh(TCh::LfCh);}
91    return Cs;
92  }
93  int TSOut::PutSep(const int& NextStrLen){
94    int Cs=0;
95    if (MxLnLen==-1){
96      Cs+=PutCh(' ');
97    } else {
98      if (LnLen>0){
99        if (LnLen+1+NextStrLen>MxLnLen){Cs+=PutLn();} else {Cs+=PutCh(' ');}
100      }
101    }
102    return Cs;
103  }
104  int TSOut::PutSepLn(const int& Lns){
105    int Cs=0;
106    if (LnLen>0){Cs+=PutLn();}
107    Cs+=PutLn(Lns);
108    return Cs;
109  }
110  void TSOut::Save(const char* CStr){
111    int CStrLen=int(strlen(CStr));
112    EAssertR(CStrLen<=127, "Error writting stream '"+GetSNm()+"'.");
113    Save(char(CStrLen));
114    if (CStrLen>0){Cs+=PutBf(CStr, CStrLen);}
115  }
116  void TSOut::Save(TSIn& SIn, const int& BfL){
117    if (BfL==-1){
118      while (!SIn.Eof()){Save(SIn.GetCh());}
119    } else {
120      for (int BfC=0; BfC<BfL; BfC++){Save(SIn.GetCh());}
121    }
122  }
123  TSOut& TSOut::operator<<(TSIn& SIn) {
124    while (!SIn.Eof())
125      operator<<((char)SIn.GetCh());
126    return *this;
127  }
128  const PSOut TSOut::StdOut=PSOut(new TStdOut());
129  int TStdIn::GetBf(const void* LBf, const int& LBfL){
130    int LBfS=0;
131    for (int LBfC=0; LBfC<LBfL; LBfC++){
132      LBfS+=(((char*)LBf)[LBfC]=GetCh());}
133    return LBfS;
134  }
135  int TStdOut::PutBf(const void* LBf, const int& LBfL){
136    int LBfS=0;
137    for (int LBfC=0; LBfC<LBfL; LBfC++){
138      LBfS+=PutCh(((char*)LBf)[LBfC]);}
139    return LBfS;
140  }
141  const int TFIn::MxBfL=16*1024;
142  void TFIn::SetFPos(const int& FPos) const {
143    EAssertR(
144     fseek(FileId, FPos, SEEK_SET)==0,
145     "Error seeking into file '"+GetSNm()+"'.");
146  }
147  int TFIn::GetFPos() const {
148    const int FPos=ftell(FileId);
149    EAssertR(FPos!=-1, "Error seeking into file '"+GetSNm()+"'.");
150    return FPos;
151  }
152  int TFIn::GetFLen() const {
153    const int FPos=GetFPos();
154    EAssertR(
155     fseek(FileId, 0, SEEK_END)==0,
156     "Error seeking into file '"+GetSNm()+"'.");
157    const int FLen=GetFPos(); SetFPos(FPos);
158    return FLen;
159  }
160  void TFIn::FillBf(){
161    EAssertR(
162     (BfC==BfL)&&((BfL==-1)||(BfL==MxBfL)),
163     "Error reading file '"+GetSNm()+"'.");
164    BfL=int(fread(Bf, 1, MxBfL, FileId));
165    EAssertR((BfC!=0)||(BfL!=0), "Error reading file '"+GetSNm()+"'.");
166    BfC=0;
167  }
168  TFIn::TFIn(const TStr& FNm):
169    TSIn(FNm), FileId(NULL), Bf(NULL), BfC(0), BfL(0){
170    EAssertR(!FNm.Empty(), "Empty file-name.");
171    FileId=fopen(FNm.CStr(), "rb");
172    EAssertR(FileId!=NULL, "Can not open file '"+FNm+"'.");
173    Bf=new char[MxBfL]; BfC=BfL=-1; FillBf();
174  }
175  TFIn::TFIn(const TStr& FNm, bool& OpenedP):
176    TSIn(FNm), FileId(NULL), Bf(NULL), BfC(0), BfL(0){
177    EAssertR(!FNm.Empty(), "Empty file-name.");
178    FileId=fopen(FNm.CStr(), "rb");
179    OpenedP=(FileId!=NULL);
180    if (OpenedP){
181      Bf=new char[MxBfL]; BfC=BfL=-1; FillBf();}
182  }
183  PSIn TFIn::New(const TStr& FNm){
184    return PSIn(new TFIn(FNm));
185  }
186  PSIn TFIn::New(const TStr& FNm, bool& OpenedP){
187    return PSIn(new TFIn(FNm, OpenedP));
188  }
189  TFIn::~TFIn(){
190    if (FileId!=NULL){
191      EAssertR(fclose(FileId)==0, "Can not close file '"+GetSNm()+"'.");}
192    if (Bf!=NULL){delete[] Bf;}
193  }
194  int TFIn::GetBf(const void* LBf, const int& LBfL){
195    int LBfS=0;
196    if (BfC+LBfL>BfL){
197      for (int LBfC=0; LBfC<LBfL; LBfC++){
198        if (BfC==BfL){FillBf();}
199        LBfS+=((char*)LBf)[LBfC]=Bf[BfC++];}
200    } else {
201      for (int LBfC=0; LBfC<LBfL; LBfC++){
202        LBfS+=(((char*)LBf)[LBfC]=Bf[BfC++]);}
203    }
204    return LBfS;
205  }
206  const int TFOut::MxBfL=16*1024;;
207  void TFOut::FlushBf(){
208    EAssertR(
209     (int)fwrite(Bf, 1, BfL, FileId)==BfL,
210     "Error writting to the file '"+GetSNm()+"'.");
211    BfL=0;
212  }
213  TFOut::TFOut(const TStr& FNm, const bool& Append):
214    TSOut(FNm), FileId(NULL), Bf(NULL), BfL(0){
215    if (FNm.GetUc()=="CON"){
216      FileId=stdout;
217    } else {
218      if (Append){FileId=fopen(FNm.CStr(), "a+b");}
219      else {FileId=fopen(FNm.CStr(), "w+b");}
220      EAssertR(FileId!=NULL, "Can not open file '"+FNm+"'.");
221      Bf=new char[MxBfL]; BfL=0;
222    }
223  }
224  TFOut::TFOut(const TStr& FNm, const bool& Append, bool& OpenedP):
225    TSOut(FNm), FileId(NULL), Bf(NULL), BfL(0){
226    if (FNm.GetUc()=="CON"){
227      FileId=stdout;
228    } else {
<span onclick='openModal()' class='match'>229      if (Append){FileId=fopen(FNm.CStr(), "a+b");}
230      else {FileId=fopen(FNm.CStr(), "w+b");}
231      OpenedP=(FileId!=NULL);
</span>232      if (OpenedP){
233        Bf=new char[MxBfL]; BfL=0;}
234    }
235  }
236  PSOut TFOut::New(const TStr& FNm, const bool& Append){
237    return PSOut(new TFOut(FNm, Append));
238  }
239  PSOut TFOut::New(const TStr& FNm, const bool& Append, bool& OpenedP){
240    PSOut SOut=PSOut(new TFOut(FNm, Append, OpenedP));
241    if (OpenedP){return SOut;} else {return NULL;}
242  }
243  TFOut::~TFOut(){
244    if (FileId!=NULL){FlushBf();}
245    if (Bf!=NULL){delete[] Bf;}
246    if (FileId!=NULL){
247      EAssertR(fclose(FileId)==0, "Can not close file '"+GetSNm()+"'.");}
248  }
249  int TFOut::PutCh(const char& Ch){
250    if (BfL==MxBfL){FlushBf();}
251    return Bf[BfL++]=Ch;
252  }
253  int TFOut::PutBf(const void* LBf, const int& LBfL){
254    int LBfS=0;
255    if (BfL+LBfL>MxBfL){
256      for (int LBfC=0; LBfC<LBfL; LBfC++){
257        LBfS+=PutCh(((char*)LBf)[LBfC]);}
258    } else {
259      for (int LBfC=0; LBfC<LBfL; LBfC++){
260        LBfS+=(Bf[BfL++]=((char*)LBf)[LBfC]);}
261    }
262    return LBfS;
263  }
264  void TFOut::Flush(){
265    FlushBf();
266    EAssertR(fflush(FileId)==0, "Can not flush file '"+GetSNm()+"'.");
267  }
268  TFInOut::TFInOut(const TStr& FNm, const TFAccess& FAccess, const bool& CreateIfNo) :
269   TSBase(TSStr(FNm.CStr())), FileId(NULL) {
270    switch (FAccess){
271      case faCreate: FileId=fopen(FNm.CStr(), "w+b"); break;
272      case faUpdate: FileId=fopen(FNm.CStr(), "r+b"); break;
273      case faAppend: FileId=fopen(FNm.CStr(), "r+b");
274        if (FileId!=NULL){fseek(FileId, SEEK_END, 0);} break;
275      case faRdOnly: FileId=fopen(FNm.CStr(), "rb"); break;
276      default: Fail;
277    }
278    if ((FileId==NULL)&&(CreateIfNo)){FileId=fopen(FNm.CStr(), "w+b");}
279    IAssert(FileId!=NULL);
280  }
281  PSInOut TFInOut::New(const TStr& FNm, const TFAccess& FAccess, const bool& CreateIfNo) {
282    return PSInOut(new TFInOut(FNm, FAccess, CreateIfNo));
283  }
284  int TFInOut::GetSize() const {
285    const int FPos = GetPos();
286    IAssert(fseek(FileId, 0, SEEK_END) == 0);
287    const int FLen = GetPos();
288    IAssert(fseek(FileId, FPos, SEEK_SET) == 0);
289    return FLen;
290  }
291  int TFInOut::PutBf(const void* LBf, const int& LBfL) {
292    int LBfS = 0;
293    for (int i = 0; i < LBfL; i++) {
294      LBfS += ((char *)LBf)[i];
295    }
296    IAssert(fwrite(LBf, sizeof(char), LBfL, FileId) == (size_t) LBfL);
297    return LBfS;;
298  }
299  int TFInOut::GetBf(const void* LBf, const int& LBfL) {
300    IAssert(fread((void *)LBf, sizeof(char), LBfL, FileId) == (size_t) LBfL);
301    int LBfS = 0;
302    for (int i = 0; i < LBfL; i++) {
303      LBfS += ((char *)LBf)[i];
304    }
305    return LBfS;
306  }
307  TStr TFInOut::GetFNm() const {
308    return GetSNm();
309  }
310  TMIn::TMIn(const void* _Bf, const int& _BfL, const bool& TakeBf, const bool& _Free):
311    TSIn("Input-Memory"), Bf(NULL), BfC(0), BfL(_BfL), Free(_Free){
312    if (TakeBf){
313      Bf=(char*)_Bf;
314    } else {
315      Bf=new char[BfL]; memmove(Bf, _Bf, BfL);
316    }
317  }
318  TMIn::TMIn(TSIn& SIn):
319    TSIn("Input-Memory"), Bf(NULL), BfC(0), BfL(0){
320    BfL=SIn.Len(); Bf=new char[BfL];
321    for (int BfC=0; BfC<BfL; BfC++){Bf[BfC]=SIn.GetCh();}
322  }
323  TMIn::TMIn(const char* CStr):
324    TSIn("Input-Memory"), Bf(NULL), BfC(0), BfL(0){
325    BfL=int(strlen(CStr)); Bf=new char[BfL+1]; strcpy(Bf, CStr);
326  }
327  TMIn::TMIn(const TStr& Str):
328    TSIn("Input-Memory"), Bf(NULL), BfC(0), BfL(0){
329    BfL=Str.Len(); Bf=new char[BfL]; strncpy(Bf, Str.CStr(), BfL);
330  }
331  TMIn::TMIn(const TChA& ChA):
332    TSIn("Input-Memory"), Bf(NULL), BfC(0), BfL(0){
333    BfL=ChA.Len(); Bf=new char[BfL]; strncpy(Bf, ChA.CStr(), BfL);
334  }
335  PSIn TMIn::New(const char* CStr){
336    return PSIn(new TMIn(CStr));
337  }
338  PSIn TMIn::New(const TStr& Str){
339    return PSIn(new TMIn(Str));
340  }
341  PSIn TMIn::New(const TChA& ChA){
342    return PSIn(new TMIn(ChA));
343  }
344  char TMIn::GetCh(){
345    EAssertR(BfC<BfL, "Reading beyond the end of stream.");
346    return Bf[BfC++];
347  }
348  char TMIn::PeekCh(){
349    EAssertR(BfC<BfL, "Reading beyond the end of stream.");
350    return Bf[BfC];
351  }
352  int TMIn::GetBf(const void* LBf, const int& LBfL){
353    EAssertR(BfC+LBfL<=BfL, "Reading beyond the end of stream.");
354    int LBfS=0;
355    for (int LBfC=0; LBfC<LBfL; LBfC++){
356      LBfS+=(((char*)LBf)[LBfC]=Bf[BfC++]);}
357    return LBfS;
358  }
359  void TMOut::Resize(){
360    IAssert(OwnBf&&(BfL==MxBfL));
361    if (Bf==NULL){
362      IAssert(MxBfL==0); Bf=new char[MxBfL=1024];
363    } else {
364      MxBfL*=2; char* NewBf=new char[MxBfL];
365      memmove(NewBf, Bf, BfL); delete[] Bf; Bf=NewBf;
366    }
367  }
368  TMOut::TMOut(const int& _MxBfL):
369    TSOut("Output-Memory"),
370    Bf(NULL), BfL(0), MxBfL(0), OwnBf(true){
371    MxBfL=_MxBfL>0?_MxBfL:1024;
372    Bf=new char[MxBfL];
373  }
374  TMOut::TMOut(char* _Bf, const int& _MxBfL):
375    TSOut("Output-Memory"),
376    Bf(_Bf), BfL(0), MxBfL(_MxBfL), OwnBf(false){}
377  int TMOut::PutBf(const void* LBf, const int& LBfL){
378    int LBfS=0;
379    if (BfL+LBfL>MxBfL){
380      for (int LBfC=0; LBfC<LBfL; LBfC++){
381        LBfS+=PutCh(((char*)LBf)[LBfC]);}
382    } else {
383      for (int LBfC=0; LBfC<LBfL; LBfC++){
384        LBfS+=(Bf[BfL++]=((char*)LBf)[LBfC]);}
385    }
386    return LBfS;
387  }
388  TStr TMOut::GetAsStr() const {
389    TChA ChA(BfL);
390    for (int BfC=0; BfC<BfL; BfC++){ChA+=Bf[BfC];}
391    return ChA;
392  }
393  void TMOut::CutBf(const int& CutBfL){
394    IAssert((0<=CutBfL)&&(CutBfL<=BfL));
395    if (CutBfL==BfL){BfL=0;}
396    else {memmove(Bf, Bf+CutBfL, BfL-CutBfL); BfL=BfL-CutBfL;}
397  }
398  PSIn TMOut::GetSIn(const bool& IsCut, const int& CutBfL){
399    IAssert((CutBfL==-1)||((0<=CutBfL)));
400    int SInBfL= (CutBfL==-1) ? BfL : TInt::GetMn(BfL, CutBfL);
401    PSIn SIn;
402    if (OwnBf&&IsCut&&(SInBfL==BfL)){
403      SIn=PSIn(new TMIn(Bf, SInBfL, true));
404      Bf=NULL; BfL=MxBfL=0; OwnBf=true;
405    } else {
406      SIn=PSIn(new TMIn(Bf, SInBfL, false));
407      if (IsCut){CutBf(SInBfL);}
408    }
409    return SIn;
410  }
411  bool TMOut::IsCrLfLn() const {
412    for (int BfC=0; BfC<BfL; BfC++){
413      if ((Bf[BfC]==TCh::CrCh)&&((BfC+1<BfL)&&(Bf[BfC+1]==TCh::LfCh))){return true;}}
414    return false;
415  }
416  TStr TMOut::GetCrLfLn(){
417    IAssert(IsCrLfLn());
418    TChA Ln;
419    for (int BfC=0; BfC<BfL; BfC++){
420      char Ch=Bf[BfC];
421      if ((Ch==TCh::CrCh)&&((BfC+1<BfL)&&(Bf[BfC+1]==TCh::LfCh))){
422        Ln+=TCh::CrCh; Ln+=TCh::LfCh; CutBf(BfC+1+1); break;
423      } else {
424        Ln+=Ch;
425      }
426    }
427    return Ln;
428  }
429  bool TMOut::IsEolnLn() const {
430    for (int BfC=0; BfC<BfL; BfC++){
431      if ((Bf[BfC]==TCh::CrCh)||(Bf[BfC]==TCh::LfCh)){return true;}
432    }
433    return false;
434  }
435  TStr TMOut::GetEolnLn(const bool& DoAddEoln, const bool& DoCutBf){
436    IAssert(IsEolnLn());
437    int LnChs=0; TChA Ln;
438    for (int BfC=0; BfC<BfL; BfC++){
439      char Ch=Bf[BfC];
440      if ((Ch==TCh::CrCh)||(Ch==TCh::LfCh)){
441        LnChs++; if (DoAddEoln){Ln+=Ch;}
442        if (BfC+1<BfL){
443          char NextCh=Bf[BfC+1];
444          if (((Ch==TCh::CrCh)&&(NextCh==TCh::LfCh))||
445           ((Ch==TCh::LfCh)&&(NextCh==TCh::CrCh))){
446            LnChs++; if (DoAddEoln){Ln+=NextCh;}
447          }
448        }
449        break;
450      } else {
451        LnChs++; Ln+=Ch;
452      }
453    }
454    if (DoCutBf){
455      CutBf(LnChs);
456    }
457    return Ln;
458  }
459  void TMOut::MkEolnLn(){
460    if (!IsEolnLn()){
461      PutCh(TCh::CrCh); PutCh(TCh::LfCh);}
462  }
463  #ifndef SEEK_SET
464  #define SEEK_CUR    1
465  #define SEEK_END    2
466  #define SEEK_SET    0
467  #endif
468  void TFRnd::RefreshFPos(){
469    EAssertR(
470     fseek(FileId, 0, SEEK_CUR)==0,
471     "Error seeking into file '"+FNm+"'.");
472  }
473  TFRnd::TFRnd(const TStr& _FNm, const TFAccess& FAccess,
474   const bool& CreateIfNo, const int& _HdLen, const int& _RecLen):
475    FileId(NULL), FNm(_FNm.CStr()),
476    RecAct(false), HdLen(_HdLen), RecLen(_RecLen){
477    RecAct=(HdLen>=0)&&(RecLen>0);
478    switch (FAccess){
479      case faCreate: FileId=fopen(FNm.CStr(), "w+b"); break;
480      case faUpdate: FileId=fopen(FNm.CStr(), "r+b"); break;
481      case faAppend: FileId=fopen(FNm.CStr(), "r+b");
482        if (FileId!=NULL){fseek(FileId, SEEK_END, 0);} break;
483      case faRdOnly: FileId=fopen(FNm.CStr(), "rb"); break;
484      default: Fail;
485    }
486    if ((FileId==NULL)&&(CreateIfNo)){
487      FileId=fopen(FNm.CStr(), "w+b");}
488    EAssertR(FileId!=NULL, "Can not open file '"+_FNm+"'.");
489  }
490  TFRnd::~TFRnd(){
491    EAssertR(fclose(FileId)==0, "Can not close file '"+FNm+"'.");
492  }
493  TStr TFRnd::GetFNm() const {
494    return FNm.CStr();
495  }
496  void TFRnd::SetFPos(const int& FPos){
497    EAssertR(
498     fseek(FileId, FPos, SEEK_SET)==0,
499     "Error seeking into file '"+FNm+"'.");
500  }
501  void TFRnd::MoveFPos(const int& DFPos){
502    EAssertR(
503     fseek(FileId, DFPos, SEEK_CUR)==0,
504     "Error seeking into file '"+FNm+"'.");
505  }
506  int TFRnd::GetFPos(){
507    int FPos=ftell(FileId);
508    EAssertR(FPos!=-1, "Error seeking into file '"+FNm+"'.");
509    return FPos;
510  }
511  int TFRnd::GetFLen(){
512    int FPos=GetFPos();
513    EAssertR(
514     fseek(FileId, 0, SEEK_END)==0,
515     "Error seeking into file '"+FNm+"'.");
516    int FLen=GetFPos(); SetFPos(FPos); return FLen;
517  }
518  void TFRnd::SetRecN(const int& RecN){
519    IAssert(RecAct);
520    SetFPos(HdLen+RecN*RecLen);
521  }
522  int TFRnd::GetRecN(){
523    IAssert(RecAct);
524    int FPos=GetFPos()-HdLen;
525    EAssertR(FPos%RecLen==0, "Invalid position in file'"+FNm+"'.");
526    return FPos/RecLen;
527  }
528  int TFRnd::GetRecs(){
529    IAssert(RecAct);
530    int FLen=GetFLen()-HdLen;
531    EAssertR(FLen%RecLen==0, "Invalid length of file'"+FNm+"'.");
532    return FLen/RecLen;
533  }
534  void TFRnd::GetBf(void* Bf, const int& BfL){
535    RefreshFPos();
536    EAssertR(
537     int(fread(Bf, 1, BfL, FileId))==BfL,
538     "Error reading file '"+FNm+"'.");
539  }
540  void TFRnd::PutBf(const void* Bf, const int& BfL){
541    RefreshFPos();
542    EAssertR(
543     int(fwrite(Bf, 1, BfL, FileId))==BfL,
544     "Error writting to the file '"+FNm+"'.");
545  }
546  void TFRnd::Flush(){
547    EAssertR(fflush(FileId)==0, "Can not flush file '"+FNm+"'.");
548  }
549  void TFRnd::PutCh(const char& Ch, const int& Chs){
550    if (Chs>0){
551      char* CStr=new char[Chs];
552      for (int ChN=0; ChN<Chs; ChN++){CStr[ChN]=Ch;}
553      PutBf(CStr, Chs);
554      delete[] CStr;
555    }
556  }
557  void TFRnd::PutStr(const TStr& Str){
558    PutBf(Str.CStr(), Str.Len()+1);
559  }
560  TStr TFRnd::GetStr(const int& StrLen, bool& IsOk){
561    IsOk=false; TStr Str;
562    if (GetFPos()+StrLen+1<=GetFLen()){
563      char* CStr=new char[StrLen+1];
564      GetBf(CStr, StrLen+1);
565      if (CStr[StrLen+1-1]==TCh::NullCh){IsOk=true; Str=CStr;}
566      delete[] CStr;
567    }
568    return Str;
569  }
570  TStr TFRnd::GetStr(const int& StrLen){
571    TStr Str;
572    char* CStr=new char[StrLen+1];
573    GetBf(CStr, StrLen+1);
574    EAssertR(CStr[StrLen+1-1]==TCh::NullCh, "Error reading file '"+FNm+"'.");
575    Str=CStr;
576    delete[] CStr;
577    return Str;
578  }
579  void TFRnd::PutSIn(const PSIn& SIn, TCs& Cs){
580    int BfL=SIn->Len();
581    char* Bf=new char[BfL];
582    SIn->GetBf(Bf, BfL);
583    Cs=TCs::GetCsFromBf(Bf, BfL);
584    PutBf(Bf, BfL);
585    delete[] Bf;
586  }
587  PSIn TFRnd::GetSIn(const int& BfL, TCs& Cs){
588    char* Bf=new char[BfL];
589    GetBf(Bf, BfL);
590    Cs=TCs::GetCsFromBf(Bf, BfL);
591    PSIn SIn=PSIn(new TMIn(Bf, BfL, true));
592    return SIn;
593  }
594  TStr TFRnd::GetStrFromFAccess(const TFAccess& FAccess){
595    switch (FAccess){
596      case faCreate: return "Create";
597      case faUpdate: return "Update";
598      case faAppend: return "Append";
599      case faRdOnly: return "ReadOnly";
600      case faRestore: return "Restore";
601      default: Fail; return TStr();
602    }
603  }
604  TFAccess TFRnd::GetFAccessFromStr(const TStr& Str){
605    TStr UcStr=Str.GetUc();
606    if (UcStr=="CREATE"){return faCreate;}
607    if (UcStr=="UPDATE"){return faUpdate;}
608    if (UcStr=="APPEND"){return faAppend;}
609    if (UcStr=="READONLY"){return faRdOnly;}
610    if (UcStr=="RESTORE"){return faRestore;}
611    if (UcStr=="NEW"){return faCreate;}
612    if (UcStr=="CONT"){return faUpdate;}
613    if (UcStr=="CONTINUE"){return faUpdate;}
614    if (UcStr=="REST"){return faRestore;}
615    if (UcStr=="RESTORE"){return faRestore;}
616    return faUndef;
617  }
618  const TStr TFile::TxtFExt=".Txt";
619  const TStr TFile::HtmlFExt=".Html";
620  const TStr TFile::HtmFExt=".Htm";
621  const TStr TFile::GifFExt=".Gif";
622  const TStr TFile::JarFExt=".Jar";
623  bool TFile::Exists(const TStr& FNm){
624    bool DoExists;
625    TFIn FIn(FNm, DoExists);
626    return DoExists;
627  }
628  void TFile::Del(const TStr& FNm, const bool& ThrowExceptP){
629    if (ThrowExceptP){
630      EAssertR(
631       remove(FNm.CStr())==0,
632       "Error removing file '"+FNm+"'.");
633    } else {
634      remove(FNm.CStr());
635    }
636  }
637  void TFile::DelWc(const TStr& WcStr, const bool& RecurseDirP){
638    TStrV FNmV;
639    TFFile FFile(WcStr, RecurseDirP); TStr FNm;
640    while (FFile.Next(FNm)){
641      FNmV.Add(FNm);}
642    for (int FNmN=0; FNmN<FNmV.Len(); FNmN++){
643      Del(FNmV[FNmN], false);}
644  }
645  void TFile::Rename(const TStr& SrcFNm, const TStr& DstFNm){
646    EAssertR(
647     rename(SrcFNm.CStr(), DstFNm.CStr())==0,
648     "Error renaming file '"+SrcFNm+"' to "+DstFNm+"'.");
649  }
650  TStr TFile::GetUniqueFNm(const TStr& FNm){
651    int Cnt=1; int ch;
652    TStr NewFNm; TStr TmpFNm=FNm;
653    if (FNm.SearchCh('#') == -1) {
654      for (ch = FNm.Len()-1; ch >= 0; ch--) if (FNm[ch] == '.') break;
655      if (ch != -1) TmpFNm.InsStr(ch, ".#");
656      else TmpFNm += ".#";
657    }
658    forever{
659      NewFNm=TmpFNm;
660      NewFNm.ChangeStr("#", TStr::Fmt("%03d", Cnt)); Cnt++;
661      if (!TFile::Exists(NewFNm)){break;}
662    }
663    return NewFNm;
664  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-motifcluster.cpp</h3>
            <pre><code>1  #include "stdafx.h"
2  #include "motifcluster.h"
3  #if defined(F77_POST)
4  # define F77_NAME(name) name ## _
5  #else
6  # define F77_NAME(name) name
7  #endif
8  extern "C" {
9    void F77_NAME(dsaupd)(int *ido, char *bmat, int *n, char *which, int *nev,
10                          double *tol, double *resid, int *ncv, double *V,
11                          int *ldv, int *iparam, int *ipntr, double *workd,
12                          double *workl, int *lworkl, int *info);
13    void F77_NAME(dseupd)(int *rvec, char *HowMny, int *select, double *d,
14                          double *Z, int *ldz, double *sigma, char *bmat, int *n,
15                          char *which, int *nev, double *tol, double *resid,
16                          int *ncv, double *V, int *ldv, int *iparam, int *ipntr,
17                          double *workd, double *workl, int *lworkl, int *info);
18  }
19  static void IncrementWeight(int i, int j, WeightVH& weights) {
20    int minval = MIN(i, j);
21    int maxval = MAX(i, j);
22    THash<TInt, TInt>& edge_weights = weights[minval];
23    edge_weights(maxval) += 1;
24  }
25  MotifType MotifCluster::ParseMotifType(const TStr& motif) {
26    TStr motif_lc = motif.GetLc();
27    if      (motif_lc == "m1")          { return M1; }
28    else if (motif_lc == "m2")          { return M2; }
29    else if (motif_lc == "m3")          { return M3; }
30    else if (motif_lc == "m4")          { return M4; }
31    else if (motif_lc == "m5")          { return M5; }
32    else if (motif_lc == "m6")          { return M6; }
33    else if (motif_lc == "m7")          { return M7; }
34    else if (motif_lc == "m8")          { return M8; }
35    else if (motif_lc == "m9")          { return M9; }
36    else if (motif_lc == "m10")         { return M10; }
37    else if (motif_lc == "m11")         { return M11; }
38    else if (motif_lc == "m12")         { return M12; }
39    else if (motif_lc == "m13")         { return M13; }
40    else if (motif_lc == "bifan")       { return bifan; }
41    else if (motif_lc == "bi-fan")      { return bifan; }  
42    else if (motif_lc == "triangle")    { return triangle; }
43    else if (motif_lc == "clique3")     { return clique3; }
44    else if (motif_lc == "clique4")     { return clique4; }
45    else if (motif_lc == "clique5")     { return clique5; }
46    else if (motif_lc == "clique6")     { return clique6; }
47    else if (motif_lc == "clique7")     { return clique7; }
48    else if (motif_lc == "clique8")     { return clique8; }
49    else if (motif_lc == "clique9")     { return clique9; }
50    else if (motif_lc == "semiclique")  { return semiclique; }
51    else if (motif_lc == "semi-clique") { return semiclique; }    
52    else if (motif_lc == "edge")        { return edge; }
53    else if (motif_lc == "undir")       { return edge; }
54    else if (motif_lc == "undirected")  { return edge; }
55    else { TExcept::Throw("Unknown motif"); }
56    return edge;
57  }
58  bool MotifCluster::IsNoEdge(PNGraph graph, int u, int v) {
59    return !graph->IsEdge(u, v) && !graph->IsEdge(v, u);
60  }
61  bool MotifCluster::IsUnidirEdge(PNGraph graph, int u, int v) {
62    return graph->IsEdge(u, v) && !graph->IsEdge(v, u);
63  }
64  bool MotifCluster::IsBidirEdge(PNGraph graph, int u, int v) {
65    return graph->IsEdge(u, v) && graph->IsEdge(v, u);
66  }
67  bool MotifCluster::IsMotifM1(PNGraph graph, int u, int v, int w) {
68    return ((IsUnidirEdge(graph, u, v) && IsUnidirEdge(graph, v, w) &&
69  	   IsUnidirEdge(graph, w, u)) ||
70            (IsUnidirEdge(graph, u, w) && IsUnidirEdge(graph, w, v) &&
71  	   IsUnidirEdge(graph, v, u)));
72  }
73  bool MotifCluster::IsMotifM2(PNGraph graph, int u, int v, int w) {
74    return ((IsBidirEdge(graph, u, v) && IsUnidirEdge(graph, u, w) &&
75  	   IsUnidirEdge(graph, w, v)) ||
76            (IsBidirEdge(graph, u, v) && IsUnidirEdge(graph, w, u) &&
77  	   IsUnidirEdge(graph, v, w)) ||
78            (IsBidirEdge(graph, u, w) && IsUnidirEdge(graph, u, v) &&
79  	   IsUnidirEdge(graph, v, w)) ||
80            (IsBidirEdge(graph, u, w) && IsUnidirEdge(graph, v, u) &&
81  	   IsUnidirEdge(graph, w, v)) ||
82            (IsBidirEdge(graph, v, w) && IsUnidirEdge(graph, v, u) &&
83  	   IsUnidirEdge(graph, u, w)) ||
84            (IsBidirEdge(graph, v, w) && IsUnidirEdge(graph, u, v) &&
85  	   IsUnidirEdge(graph, w, u)));
86  }
87  bool MotifCluster::IsMotifM3(PNGraph graph, int u, int v, int w) {
88    if ((IsBidirEdge( graph, u, v) && IsBidirEdge( graph, v, w)) &&
89        (IsUnidirEdge(graph, u, w) || IsUnidirEdge(graph, w, u))) { return true; }
90    if ((IsBidirEdge( graph, u, w) && IsBidirEdge( graph, w, v)) &&
91        (IsUnidirEdge(graph, u, v) || IsUnidirEdge(graph, v, u))) { return true; }
92    if ((IsBidirEdge( graph, w, u) && IsBidirEdge( graph, u, v)) &&
93        (IsUnidirEdge(graph, w, v) || IsUnidirEdge(graph, v, w))) { return true; }
94    return false;
95  }
96  bool MotifCluster::IsMotifM4(PNGraph graph, int u, int v, int w) {
97    return IsBidirEdge(graph, u, v) && IsBidirEdge(graph, u, w) &&
98      IsBidirEdge(graph, v, w);
99  }
100  bool MotifCluster::IsMotifM5(PNGraph graph, int u, int v, int w) {
101    if ((IsUnidirEdge(graph, u, v) && IsUnidirEdge(graph, u, w)) && 
102        (IsUnidirEdge(graph, v, w) || IsUnidirEdge(graph, w, v))) { return true; }
103    if ((IsUnidirEdge(graph, v, u) && IsUnidirEdge(graph, v, w)) && 
104        (IsUnidirEdge(graph, u, w) || IsUnidirEdge(graph, w, u))) { return true; }
105    if ((IsUnidirEdge(graph, w, v) && IsUnidirEdge(graph, w, u)) && 
106        (IsUnidirEdge(graph, v, u) || IsUnidirEdge(graph, u, v))) { return true; }
107    return false;
108  }
109  bool MotifCluster::IsMotifM6(PNGraph graph, int u, int v, int w) {
110    return ((IsUnidirEdge(graph, u, v) && IsUnidirEdge(graph, u, w) &&
111  	   IsBidirEdge(graph, v, w)) ||
112            (IsUnidirEdge(graph, v, u) && IsUnidirEdge(graph, v, w) &&
113  	   IsBidirEdge(graph, u, w)) ||
114            (IsUnidirEdge(graph, w, u) && IsUnidirEdge(graph, w, v) &&
115  	   IsBidirEdge(graph, u, v)));
116  }
117  bool MotifCluster::IsMotifM7(PNGraph graph, int u, int v, int w) {
118    return ((IsUnidirEdge(graph, v, u) && IsUnidirEdge(graph, w, u) &&
119  	   IsBidirEdge(graph, v, w)) ||
120            (IsUnidirEdge(graph, u, v) && IsUnidirEdge(graph, w, v) &&
121  	   IsBidirEdge(graph, u, w)) ||
122            (IsUnidirEdge(graph, u, w) && IsUnidirEdge(graph, v, w) &&
123  	   IsBidirEdge(graph, u, v)));
124  }
125  bool MotifCluster::IsMotifM8(PNGraph graph, int center, int v, int w) {
126    return IsNoEdge(graph, v, w) && IsUnidirEdge(graph, center, v) &&
127      IsUnidirEdge(graph, center, w);
128  }
129  bool MotifCluster::IsMotifM9(PNGraph graph, int center, int v, int w) {
130    return IsNoEdge(graph, v, w) &&
131      ((IsUnidirEdge(graph, center, v) && IsUnidirEdge(graph, w, center)) ||
132       (IsUnidirEdge(graph, center, w) && IsUnidirEdge(graph, v, center)));
133  }
134  bool MotifCluster::IsMotifM10(PNGraph graph, int center, int v, int w) {
135    return IsNoEdge(graph, v, w) && IsUnidirEdge(graph, v, center) &&
136      IsUnidirEdge(graph, w, center);
137  }
138  bool MotifCluster::IsMotifM11(PNGraph graph, int center, int v, int w) {
139    return IsNoEdge(graph, v, w) &&
140      ((IsBidirEdge(graph, center, v) && IsUnidirEdge(graph, center, w)) ||
141       (IsBidirEdge(graph, center, w) && IsUnidirEdge(graph, center, v)));
142  }
143  bool MotifCluster::IsMotifM12(PNGraph graph, int center, int v, int w) {
144    return IsNoEdge(graph, v, w) &&
145      ((IsBidirEdge(graph, center, v) && IsUnidirEdge(graph, w, center)) ||
146       (IsBidirEdge(graph, center, w) && IsUnidirEdge(graph, v, center)));
147  }
148  bool MotifCluster::IsMotifM13(PNGraph graph, int center, int v, int w) {
149    return IsNoEdge(graph, v, w) && IsBidirEdge(graph, center, v)
150      && IsBidirEdge(graph, center, w);
151  }
152  void MotifCluster::DegreeOrdering(PNGraph graph, TIntV& order) {
153    int max_nodes = graph->GetMxNId() + 1;
154    TVec< TKeyDat<TInt, TInt> > degrees(max_nodes);
155    degrees.PutAll(TKeyDat<TInt, TInt>(0, 0));
156    for (TNGraph::TNodeI NI = graph->BegNI(); NI < graph->EndNI(); NI++) {
157      int src = NI.GetId();
158      int num_nbrs = NI.GetOutDeg();
159      for (int i = 0; i < NI.GetInDeg(); ++i) {
160        int dst = NI.GetInNId(i);
161        if (!NI.IsOutNId(dst)) {
162          ++num_nbrs;
163        }
164      }
165      degrees[src] = TKeyDat<TInt, TInt>(num_nbrs, src);
166    }
167    degrees.Sort();
168    order = TIntV(max_nodes);
169    for (int i = 0; i < order.Len(); ++i) {
170      order[degrees[i].Dat] = i;
171    }
172  }
173  void MotifCluster::TriangleMotifAdjacency(PNGraph graph, MotifType motif,
174                                            WeightVH& weights) {
175    TIntV order;
176    DegreeOrdering(graph, order);
177    for (TNGraph::TNodeI NI = graph->BegNI(); NI < graph->EndNI(); NI++) {
178      int src = NI.GetId();
179      int src_pos = order[src];
180      TIntV neighbors_higher;
181      for (int i = 0; i < NI.GetOutDeg(); i++) {
182        int nbr = NI.GetOutNId(i);
183        if (order[nbr] > src_pos) {
184          neighbors_higher.Add(nbr);
185        }
186      }
187      for (int i = 0; i < NI.GetInDeg(); i++) {
188        int nbr = NI.GetInNId(i);
189        if (!NI.IsOutNId(nbr) && order[nbr] > src_pos) {
190          neighbors_higher.Add(nbr);
191        }
192      }
193      for (int ind1 = 0; ind1 < neighbors_higher.Len(); ind1++) {
194        for (int ind2 = ind1 + 1; ind2 < neighbors_higher.Len(); ind2++) {
195          int dst1 = neighbors_higher[ind1];
196          int dst2 = neighbors_higher[ind2];
197          if (graph->IsEdge(dst1, dst2) || graph->IsEdge(dst2, dst1)) {
198            bool motif_occurs = false;
199            switch (motif) {
200            case M1:
201              motif_occurs = IsMotifM1(graph, src, dst1, dst2);
202              break;
203            case M2:
204              motif_occurs = IsMotifM2(graph, src, dst1, dst2);
205              break;
206            case M3:
207              motif_occurs = IsMotifM3(graph, src, dst1, dst2);
208              break;
209            case M4:
210              motif_occurs = IsMotifM4(graph, src, dst1, dst2);
211              break;
212            case M5:
213              motif_occurs = IsMotifM5(graph, src, dst1, dst2);
214              break;
215            case M6:
216              motif_occurs = IsMotifM6(graph, src, dst1, dst2);
217              break;
218            case M7:
219              motif_occurs = IsMotifM7(graph, src, dst1, dst2);
220              break;
221            default:
222              TExcept::Throw("Unknown directed triangle motif");
223            }
224            if (motif_occurs) {
225              IncrementWeight(src,  dst1, weights);
226              IncrementWeight(src,  dst2, weights);
227              IncrementWeight(dst1, dst2, weights);
228            }
229          }
230        }
231      }
232    }
233  }
234  void MotifCluster::WedgeMotifAdjacency(PNGraph graph, MotifType motif,
235                                         WeightVH& weights) {
236    for (TNGraph::TNodeI NI = graph->BegNI(); NI < graph->EndNI(); NI++) {
237      int center = NI.GetId();
238      TIntV neighbors;
239      for (int i = 0; i < NI.GetOutDeg(); i++) {
240        int nbr = NI.GetOutNId(i);
241        neighbors.Add(nbr);
242      }
243      for (int i = 0; i < NI.GetInDeg(); i++) {
244        int nbr = NI.GetInNId(i);
245        if (!NI.IsOutNId(nbr)) {
246          neighbors.Add(nbr);
247        }
248      }
249      for (int ind1 = 0; ind1 < neighbors.Len(); ind1++) {
250        for (int ind2 = ind1 + 1; ind2 < neighbors.Len(); ind2++) {
251          int dst1 = neighbors[ind1];
252          int dst2 = neighbors[ind2];
253          bool motif_occurs = false;
254          switch (motif) {
255          case M8:
256            motif_occurs = IsMotifM8(graph, center, dst1, dst2);
257            break;
258          case M9:
259            motif_occurs = IsMotifM9(graph, center, dst1, dst2);
260            break;
261          case M10:
262            motif_occurs = IsMotifM10(graph, center, dst1, dst2);
263            break;
264          case M11:
265            motif_occurs = IsMotifM11(graph, center, dst1, dst2);
266            break;
267          case M12:
268            motif_occurs = IsMotifM12(graph, center, dst1, dst2);
269            break;
270          case M13:
271            motif_occurs = IsMotifM13(graph, center, dst1, dst2);
272            break;
273          default:
274            TExcept::Throw("Unknown directed wedge motif");
275          }
276          if (motif_occurs) {
277            IncrementWeight(center, dst1, weights);
278            IncrementWeight(center, dst2, weights);
279            IncrementWeight(dst1,   dst2, weights);
280          }
281        }
282      }
283    }
284  }
285  void MotifCluster::BifanMotifAdjacency(PNGraph graph, WeightVH& weights) {
286    TIntV node_ids;
287    for (TNGraph::TNodeI NI = graph->BegNI(); NI < graph->EndNI(); NI++) {
288      node_ids.Add(NI.GetId());
289    }
290    for (int i = 0; i < node_ids.Len(); i++) {
291      for (int j = i + 1; j < node_ids.Len(); j++) {
292        int src1 = node_ids[i];
293        int src2 = node_ids[j];
294        if (IsNoEdge(graph, src1, src2)) {
295          THash<TInt, TInt> nbr_counts;
296  	TNGraph::TNodeI NI1 = graph->GetNI(src1);
297          for (int k = 0; k < NI1.GetOutDeg(); k++) {
298            int nbr = NI1.GetOutNId(k);
299            if (IsUnidirEdge(graph, src1, nbr)) {
300              nbr_counts(nbr) += 1;
301            }
302          }
303  	TNGraph::TNodeI NI2 = graph->GetNI(src2);
304          for (int k = 0; k < NI2.GetOutDeg(); k++) {
305            int nbr = NI2.GetOutNId(k);
306            if (IsUnidirEdge(graph, src2, nbr)) {
307              nbr_counts(nbr) += 1;
308            }
309          }
310          TIntV common;
311          for (THash<TInt, TInt>::TIter it = nbr_counts.BegI();
312  	     it < nbr_counts.EndI(); it++) {
313            if (it->Dat == 2) {
314              common.Add(it->Key);
315            }
316          }
317          for (int ind1 = 0; ind1 < common.Len(); ind1++) {
318            for (int ind2 = (ind1 + 1); ind2 < common.Len(); ind2++) {
319              int dst1 = common[ind1];
320              int dst2 = common[ind2];
321              if (IsNoEdge(graph, dst1, dst2)) {
322                IncrementWeight(src1, src2, weights);
323                IncrementWeight(src1, dst1, weights);
324                IncrementWeight(src1, dst2, weights);
325                IncrementWeight(src2, dst1, weights);
326                IncrementWeight(src2, dst2, weights);
327                IncrementWeight(dst1, dst2, weights);
328              }
329            }
330          }
331        }
332      }
333    }
334  }
335  void MotifCluster::SemicliqueMotifAdjacency(PUNGraph graph, WeightVH& weights) {
336    for (TUNGraph::TNodeI NI = graph->BegNI(); NI < graph->EndNI(); NI++) {  
337      int src = NI.GetId();
338      for (int j = 0; j < NI.GetDeg(); j++) {
339        int dst = NI.GetNbrNId(j);
340        if (dst <= src) { continue; }
341        TIntV common;
342        TUNGraph::TNodeI dst_NI = graph->GetNI(dst);
343        for (int k = 0; k < dst_NI.GetOutDeg(); k++) {
344          int nbr = dst_NI.GetNbrNId(k);
345          if (nbr != src && nbr != dst && NI.IsNbrNId(nbr)) {
346            common.Add(nbr);
347          }
348        }
349        for (int k = 0; k < common.Len(); k++) {
350          for (int l = k + 1; l < common.Len(); l++) {
351            int nbr1 = common[k];
352            int nbr2 = common[l];
353            if (!graph->IsEdge(nbr1, nbr2)) {
354              IncrementWeight(src, dst, weights);
355              IncrementWeight(src, nbr1, weights);
356              IncrementWeight(src, nbr2, weights);            
357              IncrementWeight(dst, nbr1, weights);
358              IncrementWeight(dst, nbr2, weights);
359              IncrementWeight(nbr1, nbr2, weights);
360            }
361          }
362        }
363      }
364    }
365  }
366  void MotifCluster::EdgeMotifAdjacency(PNGraph graph, WeightVH& weights) {
367    for (TNGraph::TEdgeI it = graph->BegEI(); it < graph->EndEI(); it++) {
368      int src = it.GetSrcNId();    
369      int dst = it.GetDstNId();
370      if (src == dst) {
371        continue;
372      }
373      if (!graph->IsEdge(dst, src) || src < dst) {
374        IncrementWeight(src, dst, weights);
375      }
376    }
377  }
378  void MotifCluster::EdgeMotifAdjacency(PUNGraph graph, WeightVH& weights) {
379    for (TUNGraph::TEdgeI it = graph->BegEI(); it < graph->EndEI(); it++) {
380      int src = it.GetSrcNId();    
381      int dst = it.GetDstNId();
382      if (src == dst) {
383        continue;
384      }
385      IncrementWeight(src, dst, weights);
386    }
387  }
388  void MotifCluster::MotifAdjacency(PNGraph graph, MotifType motif,
389  				  WeightVH& weights) {
390    weights = WeightVH(graph->GetMxNId() + 1);
391    switch (motif) {
392    case M1:
393    case M2:
394    case M3:
395    case M4:
396    case M5:
397    case M6:
398    case M7:
399      TriangleMotifAdjacency(graph, motif, weights);
400      break;
401    case M8:
402    case M9:
403    case M10:
404    case M11:
405    case M12:
406    case M13:
407      WedgeMotifAdjacency(graph, motif, weights);
408      break;    
409    case bifan:
410      BifanMotifAdjacency(graph, weights);
411      break;
412    case edge:
413      EdgeMotifAdjacency(graph, weights);
414      break;
415    default:
416      TExcept::Throw("Unknown directed motif type");
417    }
418  }
419  void MotifCluster::CliqueMotifAdjacency(PUNGraph graph, int clique_size,
420                                          WeightVH& weights) {
421    ChibaNishizekiWeighter cnw(graph);
422    cnw.Run(clique_size);
423    weights = cnw.weights();
424  }
425  void MotifCluster::MotifAdjacency(PUNGraph graph, MotifType motif,
426                                    WeightVH& weights) {
427    weights = WeightVH(graph->GetMxNId() + 1);
428    switch (motif) {
429    case triangle:
430    case clique3:
431      CliqueMotifAdjacency(graph, 3, weights);
432      break;
433    case clique4:
434      CliqueMotifAdjacency(graph, 4, weights);
435      break;
436    case clique5:
437      CliqueMotifAdjacency(graph, 5, weights);
438      break;    
439    case clique6:
440      CliqueMotifAdjacency(graph, 6, weights);
441      break;    
442    case clique7:
443      CliqueMotifAdjacency(graph, 7, weights);
444      break;    
445    case clique8:
446      CliqueMotifAdjacency(graph, 8, weights);
447      break;    
448    case clique9:
449      CliqueMotifAdjacency(graph, 9, weights);
450      break;
451    case semiclique:
452      SemicliqueMotifAdjacency(graph, weights);
453      break;
454    case edge:
455      EdgeMotifAdjacency(graph, weights);
456    default:
457      TExcept::Throw("Unknown undirected motif type");
458    }
459  }
460  void ChibaNishizekiWeighter::Initialize(int k) {
461    k_ = k;
462    C_.Clr();
463    PUNGraph kcore = TSnap::GetKCore(orig_graph_, k - 1);
464    TSnap::DelSelfEdges(kcore);
465    int max_nodes = kcore->GetMxNId();
466    for (int i = 0; i <= max_nodes; i++) {
467      if (!kcore->IsNode(i)) {
468        kcore->AddNode(i);
469      }
470    }
471    int N = kcore->GetNodes();
472    weights_ = WeightVH(N);
473    graph_ = TVec < TVec<TIntV> >(k + 2);
474    for (int i = 0; i < k + 2; ++i) {
475      graph_[i] = TVec<TIntV>(N);
476    }
477    labels_ = TIntV(N);
478    labels_.PutAll(k);
479    TVec<TIntV>& graph_k = graph_[k];
480    for (int src = 0; src < N; src++) {
481      TUNGraph::TNodeI src_it = kcore->GetNI(src);
482      int deg = src_it.GetDeg();
483      graph_k[src] = TIntV(deg);
484      for (int edge = 0; edge < deg; edge++) {
485        int dst = src_it.GetNbrNId(edge);
486        graph_k[src][edge] = dst;
487      }
488    }
489  }
490  void ChibaNishizekiWeighter::Run(int k) {
491    Initialize(k);
492    TIntV U(graph_[k].Len());
493    for (int i = 0; i < U.Len(); i++) {
494      U[i] = i;
495    }
496    CliqueEnum(k, U);
497  }
498  void ChibaNishizekiWeighter::SubgraphDegreeOrder(int k, const TIntV& U,
499                                                   TIntV& order) {
500    TVec< TKeyDat<TInt, TInt> > degs(U.Len());
501    int end_size = 0;
502    for (int i = 0; i < U.Len(); i++) {
503      int node = U[i];
504      int size = graph_[k][node].Len();
505      if (size > 0) {
506        degs[end_size] = TKeyDat<TInt, TInt>(-size, node);
507        ++end_size;
508      }
509    }
510    degs.Trunc(end_size);
511    degs.Sort();
512    order = TIntV(degs.Len());
513    for (int i = 0; i < degs.Len(); i++) {
514      order[i] = degs[i].Dat;
515    }
516  }
517  void ChibaNishizekiWeighter::UpdateWeights(const TIntV& clique) {
518    for (int i = 0; i < clique.Len(); ++i) {
519      for (int j = i + 1; j < clique.Len(); ++j) {
520        IncrementWeight(clique[i], clique[j], weights_);
521      }
522    }
523  }
524  void ChibaNishizekiWeighter::FlushCliques(const TIntV& U) {
525    for (int i = 0; i < U.Len(); i++) {
526      int node = U[i];
527      TIntV& nbrs = graph_[2][node];
528      for (int j = 0; j < nbrs.Len(); j++) {
529        int nbr = nbrs[j];
530        if (node < nbr) {
531          TIntV clique(C_.Len() + 2);
532          clique[0] = node;
533          clique[1] = nbr;
534          for (int k = 0; k < C_.Len(); k++) {
535            clique[k + 2] = C_[k];
536          }
537          UpdateWeights(clique);
538        }
539      }
540    }
541  }
542  void ChibaNishizekiWeighter::AdjustLabels(int kcurr, int klast, const TIntV& Up) {
543    for (int i = 0; i < Up.Len(); i++) {
544      int node = Up[i];
545      TIntV& nbrs_kcurr = graph_[kcurr][node];
546      TIntV& nbrs_klast = graph_[klast][node];
547      TIntV nbrs_klast_new;
548      for (int j = 0; j < nbrs_klast.Len(); j++) {
549        int nbr = nbrs_klast[j];
550        if (labels_[nbr] == kcurr) {
551          nbrs_kcurr.Add(nbr);
552        } else {
553          nbrs_klast_new.Add(nbr);
554        }
555      }
556      graph_[klast][node] = nbrs_klast_new;
557    }
558  }
559  void ChibaNishizekiWeighter::CliqueEnum(int k, const TIntV& U) {
560    if (k == 2) {
561      FlushCliques(U);
562      return;
563    }
564    TIntV order;
565    SubgraphDegreeOrder(k, U, order);
566    for (int i = 0; i < order.Len(); i++) {
567      int vi = order[i];
568      TIntV& U_prime = graph_[k][vi];
569      for (int j = 0; j < U_prime.Len(); j++) {
570        labels_[U_prime[j]] = k - 1;
571      }
572      AdjustLabels(k - 1, k, U_prime);
573      C_.Add(vi);
574      CliqueEnum(k - 1, U_prime);
575      C_.DelLast();
576      for (int j = 0; j < U_prime.Len(); j++) {
577        labels_[U_prime[j]] = k;
578      }
579      AdjustLabels(k, k - 1, U_prime);
580      labels_[vi] = k + 1;
581      AdjustLabels(k + 1, k, U_prime);
582    }
583  }
584  void MotifCluster::GetMotifCluster(PNGraph graph, MotifType motif,
585  				   TSweepCut& sweepcut, double tol,
586  				   int maxiter) {
587    WeightVH weights;
588    MotifAdjacency(graph, motif, weights);
589    SpectralCut(weights, sweepcut, tol, maxiter);
590  }
591  void MotifCluster::GetMotifCluster(PUNGraph graph, MotifType motif,
592  				   TSweepCut& sweepcut, double tol,
593  				   int maxiter) {
594    WeightVH weights;
595    MotifAdjacency(graph, motif, weights);
596    SpectralCut(weights, sweepcut, tol, maxiter);
597  }
598  double MotifCluster::NFiedlerVector(const TSparseColMatrix& W, TFltV& fvec,
599                                      double tol, int maxiter) {
600    if (W.GetRows() != W.GetCols()) {
601      TExcept::Throw("Matrix must be square.");
602    }
603    int N = W.GetCols();
604    TFltV e(N);
605    e.PutAll(1.0);
606    TFltV d(N);
607    d.PutAll(0.0);
608    W.Multiply(e, d);
609    TFltV v0(N);
610    TFltV dnorm(N);
611    for (int i = 0; i < d.Len(); i++) {
612      if (d[i] <= 0.0) {
613        TExcept::Throw("Node with zero degree.");
614      }
615      v0[i] = TMath::Sqrt(d[i]);
616      dnorm[i] = 1.0 / TMath::Sqrt(d[i]);
617    }
618    TLinAlg::Normalize(v0);
619    TVec< TIntFltKdV > L_weights(N);
620    for (int j = 0; j < N; j++) {
621      const TIntFltKdV& W_col = W.ColSpVV[j];
622      TIntFltKdV& L_col = L_weights[j];
623      for (int ind = 0; ind < W_col.Len(); ind++) {
624        int i = W_col[ind].Key;
625        double val = W_col[ind].Dat;
626        L_col.Add(TIntFltKd(i, -val * dnorm[i] * dnorm[j]));
627      }
628      L_col.Add(TIntFltKd(j, 2.0));    
629    }
630    TSparseColMatrix L(L_weights, N, N);
631    TFltV evals;
632    TFullColMatrix evecs;
633    SymeigsSmallest(L, 2, evals, evecs, tol, maxiter);
634    fvec = evecs.ColV[1];
635    for (int i = 0; i < fvec.Len(); i++) {
636      fvec[i] *= dnorm[i];
637    }
638    return evals[1] - 1;
639  }
640  static PUNGraph UnweightedGraphRepresentation(const WeightVH& weights) {
641    int num_edges = 0;
642    for (int i = 0; i < weights.Len(); i++) {
643      num_edges += weights[i].Len();
644    }
645    PUNGraph graph = TUNGraph::New(weights.Len(), num_edges);
646    for (int i = 0; i < weights.Len(); i++) {
647      graph->AddNode(i);
648    }
649    for (int i = 0; i < weights.Len(); i++) {
650      const THash<TInt, TInt>& edge_list = weights[i];
651      for (THash<TInt, TInt>::TIter it = edge_list.BegI(); it < edge_list.EndI();
652  	 it++) {    
653        graph->AddEdge(i, it->Key);
654      }
655    }
656    return graph;
657  }
658  static void MapIdsToFirstN(const TIntV& ids, THash<TInt, TInt>& id_map,
659                             TIntV& rev_id_map) {
660    id_map = THash<TInt, TInt>();
661    rev_id_map = TIntV(ids.Len());
662    for (int i = 0; i < ids.Len(); i++) {
663      int id = ids[i];
664      if (id_map.IsKey(id)) {
665        TExcept::Throw("List of ids is not unique.");
666      }
667      id_map(id) = i;
668      rev_id_map[i] = id;
669    }
670  }
671  static void Sweep(const TSparseColMatrix& W, const TFltV& fvec, TFltV& conds,
672                    TIntV& order) {
673    TVec< TKeyDat<TFlt, TInt> > fvec_inds(fvec.Len());
674    for (int i = 0; i < fvec.Len(); i++) {
675      fvec_inds[i] = TKeyDat<TFlt, TInt>(fvec[i], i);
676    }
677    fvec_inds.Sort();
678    order = TIntV(fvec.Len());
679    TIntV rank(fvec.Len());
680    for (int i = 0; i < fvec.Len(); i++) {
681      order[i] = fvec_inds[i].Dat;
682      rank[order[i]] = i;
683    }
684    conds = TFltV(order.Len() - 1);
685    double cut = 0;
686    double vol = 0;
687    double total_vol = 0;
688    for (int ind = 0; ind < order.Len(); ind++) {
689      const TIntFltKdV& nbr_weights = W.ColSpVV[ind];
690      for (TIntFltKdV::TIter it = nbr_weights.BegI(); it < nbr_weights.EndI();
691  	 it++) {
692        total_vol += it->Dat;
693      }
694    }
695    double vol_comp = total_vol;
696    for (int ind = 0; ind < order.Len() - 1; ind++) {
697      int node = order[ind];
698      const TIntFltKdV& nbr_weights = W.ColSpVV[node];
699      for (TIntFltKdV::TIter it = nbr_weights.BegI(); it < nbr_weights.EndI();
700  	 it++) {
701        int nbr = it->Key;
702        if (node == nbr) { continue; }
703        double val = it->Dat;
<span onclick='openModal()' class='match'>704        if (rank[nbr] > ind) {
705          cut += val;
706        } else {
707          cut -= val;
708        }
709        vol += val;
</span>710        vol_comp -= val;
711      }
712      double mvol = MIN(vol, vol_comp);
713      if (mvol <= 0.0) {
714        TExcept::Throw("Nonpositive set volume.");
715      }
716      conds[ind] = cut / mvol;
717    }
718  }
719  void MotifCluster::SpectralCut(const WeightVH& weights, TSweepCut& sweepcut,
720  			       double tol, int maxiter) {
721    PUNGraph graph = UnweightedGraphRepresentation(weights);
722    TCnComV components;
723    TSnap::GetWccs(graph, components);
724    int max_wcc_size = 0;
725    int max_wcc_ind = -1;
726    for (int i = 0; i < components.Len(); i++) {
727      int size = components[i].Len();
728      if (size > max_wcc_size) {
729        max_wcc_size = size;
730        max_wcc_ind = i;
731      }
732    }
733    TCnCom comp = components[max_wcc_ind];
734    sweepcut.component = comp;
735    if (comp.Len() == 1) {
736      printf("WARNING: No non-trivial connected components "
737  	   "(likely due to no instances of the motif)\n");
738      sweepcut.cond = 0;
739      sweepcut.eig = 0;
740      return;
741    }
742    THash<TInt, TInt> id_map;
743    TIntV rev_id_map;
744    MapIdsToFirstN(comp.NIdV, id_map, rev_id_map);
745    TVec<TIntFltKdV> matrix_entries(comp.Len());
746    for (int ind1 = 0; ind1 < comp.Len(); ++ind1) {
747      int c_ind = comp[ind1];
748      const THash<TInt, TInt>& edge_list = weights[c_ind];
749      int i_ind = id_map(c_ind);
750      TIntFltKdV& col = matrix_entries[i_ind];
751      for (THash<TInt, TInt>::TIter it = edge_list.BegI(); it < edge_list.EndI();
752  	 it++) {
753        int ind2 = it->Key;
754        int val = it->Dat;
755        if (comp.IsNIdIn(ind2)) {
756          int j_ind = id_map(ind2);
757          col.Add(TIntFltKd(j_ind, val));
758          matrix_entries[j_ind].Add(TIntFltKd(i_ind, val));
759        }
760      }
761    }
762    TSparseColMatrix W(matrix_entries, comp.Len(), comp.Len());
763    TFltV fvec;
764    sweepcut.eig = NFiedlerVector(W, fvec, tol, maxiter);
765    TFltV conds;
766    TIntV order;
767    Sweep(W, fvec, conds, order);
768    sweepcut.sweep_profile = conds;
769    double min_cond = 2.0;
770    int min_ind = -1;
771    for (int i = 0; i < conds.Len(); i++) {
772      double cond = conds[i];
773      if (cond < min_cond) {
774        min_cond = cond;
775        min_ind = i;
776      }
777    }
778    sweepcut.cond = min_cond;
779    TIntV cluster;
780    int start = 0;
781    int end = min_ind + 1;
782    if (end >= conds.Len() / 2) {
783      start = min_ind + 1;
784      end = conds.Len() + 1;
785    }
786    for (int i = start; i < end; i++) {
787      cluster.Add(rev_id_map[order[i]]);    
788    }
789    sweepcut.cluster = cluster;
790  }
791  void SymeigsSmallest(const TSparseColMatrix& A, int nev, TFltV& evals,
792                       TFullColMatrix& evecs, double tol, int maxiter) {
793    int mode = 1;
794    int ido = 0;
795    char bmat = 'I';
796    int n = A.GetCols();
797    char which[] = "SA";
798    double *resid = new double[n];
799    int ncv = MIN(MAX(2 * nev, 20), n - 1);
800    double *V = new double[ncv * n];
801    int ldv = n;
802    int *iparam = new int[11];
803    iparam[0] = 1;
804    iparam[2] = maxiter;
805    iparam[6] = mode;
806    int *ipntr = new int[11];
807    double *workd = new double[3 * n];
808    int lworkl = ncv * (ncv + 8);
809    double *workl = new double[lworkl];
810    int info = 0;
811    TFltV Ax(n);
812    while (true) {
813      F77_NAME(dsaupd)(&ido, &bmat, &n, &which[0], &nev, &tol, &resid[0], &ncv,
814                       &V[0], &ldv, &iparam[0], &ipntr[0], &workd[0], &workl[0],
815                       &lworkl, &info);
816      TFltV result(n);
817      result.PutAll(0.0);
818      double *load = &workd[ipntr[0] - 1];
819      for (int i = 0; i < n; i++) {
820        result[i] = load[i];
821      }
822      if (ido == 1) {
823        A.Multiply(result, Ax);
824        double *store = &workd[ipntr[1] - 1];
825        for (int i = 0; i < n; i++) {
826          store[i] = Ax[i];
827        }
828      } else if (ido == 99) {
829        break;
830      } else {
831        TExcept::Throw("ARPACK error");
832      }
833    }
834    int rvec(true);
835    char howmny = 'A';
836    int *select = new int[ncv];
837    double *d = new double[nev];
838    double sigmar = 0;
839    F77_NAME(dseupd)(&rvec, &howmny, select, &d[0], &V[0], &ldv, &sigmar, &bmat,
840                     &n, &which[0], &nev, &tol, &resid[0], &ncv, &V[0], &ldv,
841                     &iparam[0], &ipntr[0], &workd[0], &workl[0], &lworkl, &info);
842    if (info != 0) {
843      TExcept::Throw("ARPACK error");
844    }
845    TVec< TKeyDat<TFlt, TInt> > d_inds(nev);
846    for (int i = 0; i < nev; i++) {
847      d_inds[i] = TKeyDat<TFlt, TInt>(d[i], i);
848    }
849    d_inds.Sort();
850    evals = TFltV(nev);
851    evecs.ColV = TVec<TFltV>(nev);
852    for (int i = 0; i < nev; i++) {
853      double eval = d_inds[i].Key;
854      int ind = d_inds[i].Dat;
855      evals[ind] = eval;
856      TFltV& col = evecs.ColV[ind];
857      for (int j = ind * n; j < ind * n + n; j++) {
858        col.Add(V[j]);
859      }
860    }
861    evecs.RowN = n;
862    evecs.ColN = nev;
863    delete[] resid;
864    delete[] V;
865    delete[] iparam;
866    delete[] ipntr;
867    delete[] workd;
868    delete[] workl;
869    delete[] select;
870    delete[] d;
871  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-flx.cpp</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-motifcluster.cpp</div>
                <div class="column column_space"><pre><code>229      if (Append){FileId=fopen(FNm.CStr(), "a+b");}
230      else {FileId=fopen(FNm.CStr(), "w+b");}
231      OpenedP=(FileId!=NULL);
</pre></code></div>
                <div class="column column_space"><pre><code>704        if (rank[nbr] > ind) {
705          cut += val;
706        } else {
707          cut -= val;
708        }
709        vol += val;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    