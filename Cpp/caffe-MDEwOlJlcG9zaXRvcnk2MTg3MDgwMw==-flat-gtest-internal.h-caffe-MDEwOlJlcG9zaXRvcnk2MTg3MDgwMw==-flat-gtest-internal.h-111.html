
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 19, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-gtest-internal.h</h3>
            <pre><code>1  #ifndef GTEST_INCLUDE_GTEST_INTERNAL_GTEST_INTERNAL_H_
2  #define GTEST_INCLUDE_GTEST_INTERNAL_GTEST_INTERNAL_H_
3  #include &quot;gtest/internal/gtest-port.h&quot;
4  #if GTEST_OS_LINUX
5  # include &lt;stdlib.h&gt;
6  # include &lt;sys/types.h&gt;
7  # include &lt;sys/wait.h&gt;
8  # include &lt;unistd.h&gt;
9  #endif  
10  #if GTEST_HAS_EXCEPTIONS
11  # include &lt;stdexcept&gt;
12  #endif
13  #include &lt;ctype.h&gt;
14  #include &lt;float.h&gt;
15  #include &lt;string.h&gt;
16  #include &lt;iomanip&gt;
17  #include &lt;limits&gt;
18  #include &lt;set&gt;
19  #include &quot;gtest/gtest-message.h&quot;
20  #include &quot;gtest/internal/gtest-string.h&quot;
21  #include &quot;gtest/internal/gtest-filepath.h&quot;
22  #include &quot;gtest/internal/gtest-type-util.h&quot;
23  #define GTEST_CONCAT_TOKEN_(foo, bar) GTEST_CONCAT_TOKEN_IMPL_(foo, bar)
24  #define GTEST_CONCAT_TOKEN_IMPL_(foo, bar) foo ## bar
25  class ProtocolMessage;
26  namespace proto2 { class Message; }
27  namespace testing {
28  class AssertionResult;                 
29  class Message;                         
30  class Test;                            
31  class TestInfo;                        
32  class TestPartResult;                  
33  class UnitTest;                        
34  template &lt;typename T&gt;
35  ::std::string PrintToString(const T&amp; value);
36  namespace internal {
37  struct TraceInfo;                      
38  class ScopedTrace;                     
39  class TestInfoImpl;                    
40  class UnitTestImpl;                    
41  GTEST_API_ extern int g_init_gtest_count;
42  GTEST_API_ extern const char kStackTraceMarker[];
43  char IsNullLiteralHelper(Secret* p);
44  char (&amp;IsNullLiteralHelper(...))[2];  
45  #ifdef GTEST_ELLIPSIS_NEEDS_POD_
46  # define GTEST_IS_NULL_LITERAL_(x) false
47  #else
48  # define GTEST_IS_NULL_LITERAL_(x) \
49      (sizeof(::testing::internal::IsNullLiteralHelper(x)) == 1)
50  #endif  
51  GTEST_API_ std::string AppendUserMessage(
52      const std::string&amp; gtest_msg, const Message&amp; user_msg);
53  #if GTEST_HAS_EXCEPTIONS
54  class GTEST_API_ GoogleTestFailureException : public ::std::runtime_error {
55   public:
56    explicit GoogleTestFailureException(const TestPartResult&amp; failure);
57  };
58  #endif  
59  class GTEST_API_ ScopedTrace {
60   public:
61    ScopedTrace(const char* file, int line, const Message&amp; message);
62    ~ScopedTrace();
63   private:
64    GTEST_DISALLOW_COPY_AND_ASSIGN_(ScopedTrace);
65  } GTEST_ATTRIBUTE_UNUSED_;  
66  GTEST_API_ AssertionResult EqFailure(const char* expected_expression,
67                                       const char* actual_expression,
68                                       const std::string&amp; expected_value,
69                                       const std::string&amp; actual_value,
70                                       bool ignoring_case);
71  GTEST_API_ std::string GetBoolAssertionFailureMessage(
72      const AssertionResult&amp; assertion_result,
73      const char* expression_text,
74      const char* actual_predicate_value,
75      const char* expected_predicate_value);
76  template &lt;typename RawType&gt;
77  class FloatingPoint {
78   public:
79    typedef typename TypeWithSize&lt;sizeof(RawType)&gt;::UInt Bits;
80    static const size_t kBitCount = 8*sizeof(RawType);
81    static const size_t kFractionBitCount =
82      std::numeric_limits&lt;RawType&gt;::digits - 1;
83    static const size_t kExponentBitCount = kBitCount - 1 - kFractionBitCount;
84    static const Bits kSignBitMask = static_cast&lt;Bits&gt;(1) &lt;&lt; (kBitCount - 1);
85    static const Bits kFractionBitMask =
86      ~static_cast&lt;Bits&gt;(0) &gt;&gt; (kExponentBitCount + 1);
87    static const Bits kExponentBitMask = ~(kSignBitMask | kFractionBitMask);
88    static const size_t kMaxUlps = 4;
89    explicit FloatingPoint(const RawType&amp; x) { u_.value_ = x; }
90    static RawType ReinterpretBits(const Bits bits) {
91      FloatingPoint fp(0);
92      fp.u_.bits_ = bits;
93      return fp.u_.value_;
94    }
95    static RawType Infinity() {
96      return ReinterpretBits(kExponentBitMask);
97    }
98    static RawType Max();
99    const Bits &amp;bits() const { return u_.bits_; }
100    Bits exponent_bits() const { return kExponentBitMask &amp; u_.bits_; }
101    Bits fraction_bits() const { return kFractionBitMask &amp; u_.bits_; }
102    Bits sign_bit() const { return kSignBitMask &amp; u_.bits_; }
103    bool is_nan() const {
104      return (exponent_bits() == kExponentBitMask) &amp;&amp; (fraction_bits() != 0);
105    }
106    bool AlmostEquals(const FloatingPoint&amp; rhs) const {
107      if (is_nan() || rhs.is_nan()) return false;
108      return DistanceBetweenSignAndMagnitudeNumbers(u_.bits_, rhs.u_.bits_)
109          &lt;= kMaxUlps;
110    }
111   private:
112    union FloatingPointUnion {
113      RawType value_;  
114      Bits bits_;      
115    };
116    static Bits SignAndMagnitudeToBiased(const Bits &amp;sam) {
117      if (kSignBitMask &amp; sam) {
118        return ~sam + 1;
119      } else {
120        return kSignBitMask | sam;
121      }
122    }
123    static Bits DistanceBetweenSignAndMagnitudeNumbers(const Bits &amp;sam1,
124                                                       const Bits &amp;sam2) {
125      const Bits biased1 = SignAndMagnitudeToBiased(sam1);
126      const Bits biased2 = SignAndMagnitudeToBiased(sam2);
127      return (biased1 &gt;= biased2) ? (biased1 - biased2) : (biased2 - biased1);
128    }
129    FloatingPointUnion u_;
130  };
131  template &lt;&gt;
132  inline float FloatingPoint&lt;float&gt;::Max() { return FLT_MAX; }
133  template &lt;&gt;
134  inline double FloatingPoint&lt;double&gt;::Max() { return DBL_MAX; }
135  typedef FloatingPoint&lt;float&gt; Float;
136  typedef FloatingPoint&lt;double&gt; Double;
137  typedef const void* TypeId;
138  template &lt;typename T&gt;
139  class TypeIdHelper {
140   public:
141    static bool dummy_;
142  };
143  template &lt;typename T&gt;
144  bool TypeIdHelper&lt;T&gt;::dummy_ = false;
145  template &lt;typename T&gt;
146  TypeId GetTypeId() {
147    return &amp;(TypeIdHelper&lt;T&gt;::dummy_);
148  }
149  GTEST_API_ TypeId GetTestTypeId();
150  class TestFactoryBase {
151   public:
152    virtual ~TestFactoryBase() {}
153    virtual Test* CreateTest() = 0;
154   protected:
155    TestFactoryBase() {}
156   private:
157    GTEST_DISALLOW_COPY_AND_ASSIGN_(TestFactoryBase);
158  };
159  template &lt;class TestClass&gt;
160  class TestFactoryImpl : public TestFactoryBase {
161   public:
162    virtual Test* CreateTest() { return new TestClass; }
163  };
164  #if GTEST_OS_WINDOWS
165  GTEST_API_ AssertionResult IsHRESULTSuccess(const char* expr,
166                                              long hr);  
167  GTEST_API_ AssertionResult IsHRESULTFailure(const char* expr,
168                                              long hr);  
169  #endif  
170  typedef void (*SetUpTestCaseFunc)();
171  typedef void (*TearDownTestCaseFunc)();
172  GTEST_API_ TestInfo* MakeAndRegisterTestInfo(
173      const char* test_case_name,
174      const char* name,
175      const char* type_param,
176      const char* value_param,
177      TypeId fixture_class_id,
178      SetUpTestCaseFunc set_up_tc,
179      TearDownTestCaseFunc tear_down_tc,
180      TestFactoryBase* factory);
181  GTEST_API_ bool SkipPrefix(const char* prefix, const char** pstr);
182  #if GTEST_HAS_TYPED_TEST || GTEST_HAS_TYPED_TEST_P
183  class GTEST_API_ TypedTestCasePState {
184   public:
185    TypedTestCasePState() : registered_(false) {}
186    bool AddTestName(const char* file, int line, const char* case_name,
187                     const char* test_name) {
188      if (registered_) {
189        fprintf(stderr, &quot;%s Test %s must be defined before &quot;
190                &quot;REGISTER_TYPED_TEST_CASE_P(%s, ...).\n&quot;,
191                FormatFileLocation(file, line).c_str(), test_name, case_name);
192        fflush(stderr);
193        posix::Abort();
194      }
195      defined_test_names_.insert(test_name);
196      return true;
197    }
198    const char* VerifyRegisteredTestNames(
199        const char* file, int line, const char* registered_tests);
200   private:
201    bool registered_;
202    ::std::set&lt;const char*&gt; defined_test_names_;
203  };
204  inline const char* SkipComma(const char* str) {
205    const char* comma = strchr(str, &#x27;,&#x27;);
206    if (comma == NULL) {
207      return NULL;
208    }
209    while (IsSpace(*(++comma))) {}
210    return comma;
211  }
212  inline std::string GetPrefixUntilComma(const char* str) {
213    const char* comma = strchr(str, &#x27;,&#x27;);
214    return comma == NULL ? str : std::string(str, comma);
215  }
216  template &lt;GTEST_TEMPLATE_ Fixture, class TestSel, typename Types&gt;
217  class TypeParameterizedTest {
218   public:
219    static bool Register(const char* prefix, const char* case_name,
220                         const char* test_names, int index) {
221      typedef typename Types::Head Type;
222      typedef Fixture&lt;Type&gt; FixtureClass;
223      typedef typename GTEST_BIND_(TestSel, Type) TestClass;
224      MakeAndRegisterTestInfo(
225          (std::string(prefix) + (prefix[0] == &#x27;\0&#x27; ? &quot;&quot; : &quot;/&quot;) + case_name + &quot;/&quot;
226           + StreamableToString(index)).c_str(),
227          GetPrefixUntilComma(test_names).c_str(),
228          GetTypeName&lt;Type&gt;().c_str(),
229          NULL,  
230          GetTypeId&lt;FixtureClass&gt;(),
231          TestClass::SetUpTestCase,
232          TestClass::TearDownTestCase,
233          new TestFactoryImpl&lt;TestClass&gt;);
234      return TypeParameterizedTest&lt;Fixture, TestSel, typename Types::Tail&gt;
235          ::Register(prefix, case_name, test_names, index + 1);
236    }
237  };
238  template &lt;GTEST_TEMPLATE_ Fixture, class TestSel&gt;
239  class TypeParameterizedTest&lt;Fixture, TestSel, Types0&gt; {
240   public:
241    static bool Register(const char* &amp;bsol;*prefix*/, const char* &amp;bsol;*case_name*/,
242                         const char* &amp;bsol;*test_names*/, int &amp;bsol;*index*/) {
243      return true;
244    }
245  };
246  template &lt;GTEST_TEMPLATE_ Fixture, typename Tests, typename Types&gt;
247  class TypeParameterizedTestCase {
248   public:
249    static bool Register(const char* prefix, const char* case_name,
250                         const char* test_names) {
251      typedef typename Tests::Head Head;
252      TypeParameterizedTest&lt;Fixture, Head, Types&gt;::Register(
253          prefix, case_name, test_names, 0);
254      return TypeParameterizedTestCase&lt;Fixture, typename Tests::Tail, Types&gt;
255          ::Register(prefix, case_name, SkipComma(test_names));
256    }
257  };
258  template &lt;GTEST_TEMPLATE_ Fixture, typename Types&gt;
259  class TypeParameterizedTestCase&lt;Fixture, Templates0, Types&gt; {
260   public:
261    static bool Register(const char* &amp;bsol;*prefix*/, const char* &amp;bsol;*case_name*/,
262                         const char* &amp;bsol;*test_names*/) {
263      return true;
264    }
265  };
266  #endif  
267  GTEST_API_ std::string GetCurrentOsStackTraceExceptTop(
268      UnitTest* unit_test, int skip_count);
269  GTEST_API_ bool AlwaysTrue();
270  inline bool AlwaysFalse() { return !AlwaysTrue(); }
271  struct GTEST_API_ ConstCharPtr {
272    ConstCharPtr(const char* str) : value(str) {}
273    operator bool() const { return true; }
274    const char* value;
275  };
276  class GTEST_API_ Random {
277   public:
278    static const UInt32 kMaxRange = 1u &lt;&lt; 31;
279    explicit Random(UInt32 seed) : state_(seed) {}
280    void Reseed(UInt32 seed) { state_ = seed; }
281    UInt32 Generate(UInt32 range);
282   private:
283    UInt32 state_;
284    GTEST_DISALLOW_COPY_AND_ASSIGN_(Random);
285  };
286  template &lt;typename T1, typename T2&gt;
287  struct CompileAssertTypesEqual;
288  template &lt;typename T&gt;
289  struct CompileAssertTypesEqual&lt;T, T&gt; {
290  };
291  template &lt;typename T&gt;
292  struct RemoveReference { typedef T type; };  
293  template &lt;typename T&gt;
294  struct RemoveReference&lt;T&amp;&gt; { typedef T type; };  
295  #define GTEST_REMOVE_REFERENCE_(T) \
296      typename ::testing::internal::RemoveReference&lt;T&gt;::type
297  template &lt;typename T&gt;
298  struct RemoveConst { typedef T type; };  
299  template &lt;typename T&gt;
300  struct RemoveConst&lt;const T&gt; { typedef T type; };  
301  template &lt;typename T, size_t N&gt;
302  struct RemoveConst&lt;const T[N]&gt; {
303    typedef typename RemoveConst&lt;T&gt;::type type[N];
304  };
305  #if defined(_MSC_VER) &amp;&amp; _MSC_VER &lt; 1400
306  template &lt;typename T, size_t N&gt;
307  struct RemoveConst&lt;T[N]&gt; {
308    typedef typename RemoveConst&lt;T&gt;::type type[N];
309  };
310  #endif
311  #define GTEST_REMOVE_CONST_(T) \
312      typename ::testing::internal::RemoveConst&lt;T&gt;::type
313  #define GTEST_REMOVE_REFERENCE_AND_CONST_(T) \
314      GTEST_REMOVE_CONST_(GTEST_REMOVE_REFERENCE_(T))
315  template &lt;typename T&gt;
316  struct AddReference { typedef T&amp; type; };  
317  template &lt;typename T&gt;
318  struct AddReference&lt;T&amp;&gt; { typedef T&amp; type; };  
319  #define GTEST_ADD_REFERENCE_(T) \
320      typename ::testing::internal::AddReference&lt;T&gt;::type
321  #define GTEST_REFERENCE_TO_CONST_(T) \
322      GTEST_ADD_REFERENCE_(const GTEST_REMOVE_REFERENCE_(T))
323  template &lt;typename From, typename To&gt;
324  class ImplicitlyConvertible {
325   private:
326    static From MakeFrom();
327    static char Helper(To);
328    static char (&amp;Helper(...))[2];  
329   public:
330  #ifdef _MSC_VER
331  # pragma warning(push)          
332  # pragma warning(disable:4244)  
<span onclick='openModal()' class='match'>333    static const bool value =
334        sizeof(Helper(ImplicitlyConvertible::MakeFrom())) == 1;
335  # pragma warning(pop)           
</span>336  #elif defined(__BORLANDC__)
337    static const bool value = __is_convertible(From, To);
338  #else
339    static const bool value =
340        sizeof(Helper(ImplicitlyConvertible::MakeFrom())) == 1;
341  #endif  
342  };
343  template &lt;typename From, typename To&gt;
344  const bool ImplicitlyConvertible&lt;From, To&gt;::value;
345  template &lt;typename T&gt;
346  struct IsAProtocolMessage
347      : public bool_constant&lt;
348    ImplicitlyConvertible&lt;const T*, const ::ProtocolMessage*&gt;::value ||
349    ImplicitlyConvertible&lt;const T*, const ::proto2::Message*&gt;::value&gt; {
350  };
351  typedef int IsContainer;
352  template &lt;class C&gt;
353  IsContainer IsContainerTest(int &amp;bsol;* dummy */,
354                              typename C::iterator* &amp;bsol;* it */ = NULL,
355                              typename C::const_iterator* &amp;bsol;* const_it */ = NULL) {
356    return 0;
357  }
358  typedef char IsNotContainer;
359  template &lt;class C&gt;
360  IsNotContainer IsContainerTest(long &amp;bsol;* dummy */) { return &#x27;\0&#x27;; }
361  template&lt;bool&gt; struct EnableIf;
362  template&lt;&gt; struct EnableIf&lt;true&gt; { typedef void type; };  
363  template &lt;typename T, typename U&gt;
364  bool ArrayEq(const T* lhs, size_t size, const U* rhs);
365  template &lt;typename T, typename U&gt;
366  inline bool ArrayEq(const T&amp; lhs, const U&amp; rhs) { return lhs == rhs; }
367  template &lt;typename T, typename U, size_t N&gt;
368  inline bool ArrayEq(const T(&amp;lhs)[N], const U(&amp;rhs)[N]) {
369    return internal::ArrayEq(lhs, N, rhs);
370  }
371  template &lt;typename T, typename U&gt;
372  bool ArrayEq(const T* lhs, size_t size, const U* rhs) {
373    for (size_t i = 0; i != size; i++) {
374      if (!internal::ArrayEq(lhs[i], rhs[i]))
375        return false;
376    }
377    return true;
378  }
379  template &lt;typename Iter, typename Element&gt;
380  Iter ArrayAwareFind(Iter begin, Iter end, const Element&amp; elem) {
381    for (Iter it = begin; it != end; ++it) {
382      if (internal::ArrayEq(*it, elem))
383        return it;
384    }
385    return end;
386  }
387  template &lt;typename T, typename U&gt;
388  void CopyArray(const T* from, size_t size, U* to);
389  template &lt;typename T, typename U&gt;
390  inline void CopyArray(const T&amp; from, U* to) { *to = from; }
391  template &lt;typename T, typename U, size_t N&gt;
392  inline void CopyArray(const T(&amp;from)[N], U(*to)[N]) {
393    internal::CopyArray(from, N, *to);
394  }
395  template &lt;typename T, typename U&gt;
396  void CopyArray(const T* from, size_t size, U* to) {
397    for (size_t i = 0; i != size; i++) {
398      internal::CopyArray(from[i], to + i);
399    }
400  }
401  enum RelationToSource {
402    kReference,  
403    kCopy        
404  };
405  template &lt;typename Element&gt;
406  class NativeArray {
407   public:
408    typedef Element value_type;
409    typedef Element* iterator;
410    typedef const Element* const_iterator;
411    NativeArray(const Element* array, size_t count, RelationToSource relation) {
412      Init(array, count, relation);
413    }
414    NativeArray(const NativeArray&amp; rhs) {
415      Init(rhs.array_, rhs.size_, rhs.relation_to_source_);
416    }
417    ~NativeArray() {
418      static_cast&lt;void&gt;(StaticAssertTypeEqHelper&lt;Element,
419          GTEST_REMOVE_REFERENCE_AND_CONST_(Element)&gt;());
420      if (relation_to_source_ == kCopy)
421        delete[] array_;
422    }
423    size_t size() const { return size_; }
424    const_iterator begin() const { return array_; }
425    const_iterator end() const { return array_ + size_; }
426    bool operator==(const NativeArray&amp; rhs) const {
427      return size() == rhs.size() &amp;&amp;
428          ArrayEq(begin(), size(), rhs.begin());
429    }
430   private:
431    void Init(const Element* array, size_t a_size, RelationToSource relation) {
432      if (relation == kReference) {
433        array_ = array;
434      } else {
435        Element* const copy = new Element[a_size];
436        CopyArray(array, a_size, copy);
437        array_ = copy;
438      }
439      size_ = a_size;
440      relation_to_source_ = relation;
441    }
442    const Element* array_;
443    size_t size_;
444    RelationToSource relation_to_source_;
445    GTEST_DISALLOW_ASSIGN_(NativeArray);
446  };
447  }  
448  }  
449  #define GTEST_MESSAGE_AT_(file, line, message, result_type) \
450    ::testing::internal::AssertHelper(result_type, file, line, message) \
451      = ::testing::Message()
452  #define GTEST_MESSAGE_(message, result_type) \
453    GTEST_MESSAGE_AT_(__FILE__, __LINE__, message, result_type)
454  #define GTEST_FATAL_FAILURE_(message) \
455    return GTEST_MESSAGE_(message, ::testing::TestPartResult::kFatalFailure)
456  #define GTEST_NONFATAL_FAILURE_(message) \
457    GTEST_MESSAGE_(message, ::testing::TestPartResult::kNonFatalFailure)
458  #define GTEST_SUCCESS_(message) \
459    GTEST_MESSAGE_(message, ::testing::TestPartResult::kSuccess)
460  #define GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement) \
461    if (::testing::internal::AlwaysTrue()) { statement; }
462  #define GTEST_TEST_THROW_(statement, expected_exception, fail) \
463    GTEST_AMBIGUOUS_ELSE_BLOCKER_ \
464    if (::testing::internal::ConstCharPtr gtest_msg = &quot;&quot;) { \
465      bool gtest_caught_expected = false; \
466      try { \
467        GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); \
468      } \
469      catch (expected_exception const&amp;) { \
470        gtest_caught_expected = true; \
471      } \
472      catch (...) { \
473        gtest_msg.value = \
474            &quot;Expected: &quot; #statement &quot; throws an exception of type &quot; \
475            #expected_exception &quot;.\n  Actual: it throws a different type.&quot;; \
476        goto GTEST_CONCAT_TOKEN_(gtest_label_testthrow_, __LINE__); \
477      } \
478      if (!gtest_caught_expected) { \
479        gtest_msg.value = \
480            &quot;Expected: &quot; #statement &quot; throws an exception of type &quot; \
481            #expected_exception &quot;.\n  Actual: it throws nothing.&quot;; \
482        goto GTEST_CONCAT_TOKEN_(gtest_label_testthrow_, __LINE__); \
483      } \
484    } else \
485      GTEST_CONCAT_TOKEN_(gtest_label_testthrow_, __LINE__): \
486        fail(gtest_msg.value)
487  #define GTEST_TEST_NO_THROW_(statement, fail) \
488    GTEST_AMBIGUOUS_ELSE_BLOCKER_ \
489    if (::testing::internal::AlwaysTrue()) { \
490      try { \
491        GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); \
492      } \
493      catch (...) { \
494        goto GTEST_CONCAT_TOKEN_(gtest_label_testnothrow_, __LINE__); \
495      } \
496    } else \
497      GTEST_CONCAT_TOKEN_(gtest_label_testnothrow_, __LINE__): \
498        fail(&quot;Expected: &quot; #statement &quot; doesn&#x27;t throw an exception.\n&quot; \
499             &quot;  Actual: it throws.&quot;)
500  #define GTEST_TEST_ANY_THROW_(statement, fail) \
501    GTEST_AMBIGUOUS_ELSE_BLOCKER_ \
502    if (::testing::internal::AlwaysTrue()) { \
503      bool gtest_caught_any = false; \
504      try { \
505        GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); \
506      } \
507      catch (...) { \
508        gtest_caught_any = true; \
509      } \
510      if (!gtest_caught_any) { \
511        goto GTEST_CONCAT_TOKEN_(gtest_label_testanythrow_, __LINE__); \
512      } \
513    } else \
514      GTEST_CONCAT_TOKEN_(gtest_label_testanythrow_, __LINE__): \
515        fail(&quot;Expected: &quot; #statement &quot; throws an exception.\n&quot; \
516             &quot;  Actual: it doesn&#x27;t.&quot;)
517  #define GTEST_TEST_BOOLEAN_(expression, text, actual, expected, fail) \
518    GTEST_AMBIGUOUS_ELSE_BLOCKER_ \
519    if (const ::testing::AssertionResult gtest_ar_ = \
520        ::testing::AssertionResult(expression)) \
521      ; \
522    else \
523      fail(::testing::internal::GetBoolAssertionFailureMessage(\
524          gtest_ar_, text, #actual, #expected).c_str())
525  #define GTEST_TEST_NO_FATAL_FAILURE_(statement, fail) \
526    GTEST_AMBIGUOUS_ELSE_BLOCKER_ \
527    if (::testing::internal::AlwaysTrue()) { \
528      ::testing::internal::HasNewFatalFailureHelper gtest_fatal_failure_checker; \
529      GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); \
530      if (gtest_fatal_failure_checker.has_new_fatal_failure()) { \
531        goto GTEST_CONCAT_TOKEN_(gtest_label_testnofatal_, __LINE__); \
532      } \
533    } else \
534      GTEST_CONCAT_TOKEN_(gtest_label_testnofatal_, __LINE__): \
535        fail(&quot;Expected: &quot; #statement &quot; doesn&#x27;t generate new fatal &quot; \
536             &quot;failures in the current thread.\n&quot; \
537             &quot;  Actual: it does.&quot;)
538  #define GTEST_TEST_CLASS_NAME_(test_case_name, test_name) \
539    test_case_name##_##test_name##_Test
540  #define GTEST_TEST_(test_case_name, test_name, parent_class, parent_id)\
541  class GTEST_TEST_CLASS_NAME_(test_case_name, test_name) : public parent_class {\
542   public:\
543    GTEST_TEST_CLASS_NAME_(test_case_name, test_name)() {}\
544   private:\
545    virtual void TestBody();\
546    static ::testing::TestInfo* const test_info_ GTEST_ATTRIBUTE_UNUSED_;\
547    GTEST_DISALLOW_COPY_AND_ASSIGN_(\
548        GTEST_TEST_CLASS_NAME_(test_case_name, test_name));\
549  };\
550  \
551  ::testing::TestInfo* const GTEST_TEST_CLASS_NAME_(test_case_name, test_name)\
552    ::test_info_ =\
553      ::testing::internal::MakeAndRegisterTestInfo(\
554          #test_case_name, #test_name, NULL, NULL, \
555          (parent_id), \
556          parent_class::SetUpTestCase, \
557          parent_class::TearDownTestCase, \
558          new ::testing::internal::TestFactoryImpl&lt;\
559              GTEST_TEST_CLASS_NAME_(test_case_name, test_name)&gt;);\
560  void GTEST_TEST_CLASS_NAME_(test_case_name, test_name)::TestBody()
561  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-gtest-internal.h</h3>
            <pre><code>1  #ifndef GTEST_INCLUDE_GTEST_INTERNAL_GTEST_INTERNAL_H_
2  #define GTEST_INCLUDE_GTEST_INTERNAL_GTEST_INTERNAL_H_
3  #include &quot;gtest/internal/gtest-port.h&quot;
4  #if GTEST_OS_LINUX
5  # include &lt;stdlib.h&gt;
6  # include &lt;sys/types.h&gt;
7  # include &lt;sys/wait.h&gt;
8  # include &lt;unistd.h&gt;
9  #endif  
10  #if GTEST_HAS_EXCEPTIONS
11  # include &lt;stdexcept&gt;
12  #endif
13  #include &lt;ctype.h&gt;
14  #include &lt;float.h&gt;
15  #include &lt;string.h&gt;
16  #include &lt;iomanip&gt;
17  #include &lt;limits&gt;
18  #include &lt;set&gt;
19  #include &quot;gtest/gtest-message.h&quot;
20  #include &quot;gtest/internal/gtest-string.h&quot;
21  #include &quot;gtest/internal/gtest-filepath.h&quot;
22  #include &quot;gtest/internal/gtest-type-util.h&quot;
23  #define GTEST_CONCAT_TOKEN_(foo, bar) GTEST_CONCAT_TOKEN_IMPL_(foo, bar)
24  #define GTEST_CONCAT_TOKEN_IMPL_(foo, bar) foo ## bar
25  class ProtocolMessage;
26  namespace proto2 { class Message; }
27  namespace testing {
28  class AssertionResult;                 
29  class Message;                         
30  class Test;                            
31  class TestInfo;                        
32  class TestPartResult;                  
33  class UnitTest;                        
34  template &lt;typename T&gt;
35  ::std::string PrintToString(const T&amp; value);
36  namespace internal {
37  struct TraceInfo;                      
38  class ScopedTrace;                     
39  class TestInfoImpl;                    
40  class UnitTestImpl;                    
41  GTEST_API_ extern int g_init_gtest_count;
42  GTEST_API_ extern const char kStackTraceMarker[];
43  char IsNullLiteralHelper(Secret* p);
44  char (&amp;IsNullLiteralHelper(...))[2];  
45  #ifdef GTEST_ELLIPSIS_NEEDS_POD_
46  # define GTEST_IS_NULL_LITERAL_(x) false
47  #else
48  # define GTEST_IS_NULL_LITERAL_(x) \
49      (sizeof(::testing::internal::IsNullLiteralHelper(x)) == 1)
50  #endif  
51  GTEST_API_ std::string AppendUserMessage(
52      const std::string&amp; gtest_msg, const Message&amp; user_msg);
53  #if GTEST_HAS_EXCEPTIONS
54  class GTEST_API_ GoogleTestFailureException : public ::std::runtime_error {
55   public:
56    explicit GoogleTestFailureException(const TestPartResult&amp; failure);
57  };
58  #endif  
59  class GTEST_API_ ScopedTrace {
60   public:
61    ScopedTrace(const char* file, int line, const Message&amp; message);
62    ~ScopedTrace();
63   private:
64    GTEST_DISALLOW_COPY_AND_ASSIGN_(ScopedTrace);
65  } GTEST_ATTRIBUTE_UNUSED_;  
66  GTEST_API_ AssertionResult EqFailure(const char* expected_expression,
67                                       const char* actual_expression,
68                                       const std::string&amp; expected_value,
69                                       const std::string&amp; actual_value,
70                                       bool ignoring_case);
71  GTEST_API_ std::string GetBoolAssertionFailureMessage(
72      const AssertionResult&amp; assertion_result,
73      const char* expression_text,
74      const char* actual_predicate_value,
75      const char* expected_predicate_value);
76  template &lt;typename RawType&gt;
77  class FloatingPoint {
78   public:
79    typedef typename TypeWithSize&lt;sizeof(RawType)&gt;::UInt Bits;
80    static const size_t kBitCount = 8*sizeof(RawType);
81    static const size_t kFractionBitCount =
82      std::numeric_limits&lt;RawType&gt;::digits - 1;
83    static const size_t kExponentBitCount = kBitCount - 1 - kFractionBitCount;
84    static const Bits kSignBitMask = static_cast&lt;Bits&gt;(1) &lt;&lt; (kBitCount - 1);
85    static const Bits kFractionBitMask =
86      ~static_cast&lt;Bits&gt;(0) &gt;&gt; (kExponentBitCount + 1);
87    static const Bits kExponentBitMask = ~(kSignBitMask | kFractionBitMask);
88    static const size_t kMaxUlps = 4;
89    explicit FloatingPoint(const RawType&amp; x) { u_.value_ = x; }
90    static RawType ReinterpretBits(const Bits bits) {
91      FloatingPoint fp(0);
92      fp.u_.bits_ = bits;
93      return fp.u_.value_;
94    }
95    static RawType Infinity() {
96      return ReinterpretBits(kExponentBitMask);
97    }
98    static RawType Max();
99    const Bits &amp;bits() const { return u_.bits_; }
100    Bits exponent_bits() const { return kExponentBitMask &amp; u_.bits_; }
101    Bits fraction_bits() const { return kFractionBitMask &amp; u_.bits_; }
102    Bits sign_bit() const { return kSignBitMask &amp; u_.bits_; }
103    bool is_nan() const {
104      return (exponent_bits() == kExponentBitMask) &amp;&amp; (fraction_bits() != 0);
105    }
106    bool AlmostEquals(const FloatingPoint&amp; rhs) const {
107      if (is_nan() || rhs.is_nan()) return false;
108      return DistanceBetweenSignAndMagnitudeNumbers(u_.bits_, rhs.u_.bits_)
109          &lt;= kMaxUlps;
110    }
111   private:
112    union FloatingPointUnion {
113      RawType value_;  
114      Bits bits_;      
115    };
116    static Bits SignAndMagnitudeToBiased(const Bits &amp;sam) {
117      if (kSignBitMask &amp; sam) {
118        return ~sam + 1;
119      } else {
120        return kSignBitMask | sam;
121      }
122    }
123    static Bits DistanceBetweenSignAndMagnitudeNumbers(const Bits &amp;sam1,
124                                                       const Bits &amp;sam2) {
125      const Bits biased1 = SignAndMagnitudeToBiased(sam1);
126      const Bits biased2 = SignAndMagnitudeToBiased(sam2);
127      return (biased1 &gt;= biased2) ? (biased1 - biased2) : (biased2 - biased1);
128    }
129    FloatingPointUnion u_;
130  };
131  template &lt;&gt;
132  inline float FloatingPoint&lt;float&gt;::Max() { return FLT_MAX; }
133  template &lt;&gt;
134  inline double FloatingPoint&lt;double&gt;::Max() { return DBL_MAX; }
135  typedef FloatingPoint&lt;float&gt; Float;
136  typedef FloatingPoint&lt;double&gt; Double;
137  typedef const void* TypeId;
138  template &lt;typename T&gt;
139  class TypeIdHelper {
140   public:
141    static bool dummy_;
142  };
143  template &lt;typename T&gt;
144  bool TypeIdHelper&lt;T&gt;::dummy_ = false;
145  template &lt;typename T&gt;
146  TypeId GetTypeId() {
147    return &amp;(TypeIdHelper&lt;T&gt;::dummy_);
148  }
149  GTEST_API_ TypeId GetTestTypeId();
150  class TestFactoryBase {
151   public:
152    virtual ~TestFactoryBase() {}
153    virtual Test* CreateTest() = 0;
154   protected:
155    TestFactoryBase() {}
156   private:
157    GTEST_DISALLOW_COPY_AND_ASSIGN_(TestFactoryBase);
158  };
159  template &lt;class TestClass&gt;
160  class TestFactoryImpl : public TestFactoryBase {
161   public:
162    virtual Test* CreateTest() { return new TestClass; }
163  };
164  #if GTEST_OS_WINDOWS
165  GTEST_API_ AssertionResult IsHRESULTSuccess(const char* expr,
166                                              long hr);  
167  GTEST_API_ AssertionResult IsHRESULTFailure(const char* expr,
168                                              long hr);  
169  #endif  
170  typedef void (*SetUpTestCaseFunc)();
171  typedef void (*TearDownTestCaseFunc)();
172  GTEST_API_ TestInfo* MakeAndRegisterTestInfo(
173      const char* test_case_name,
174      const char* name,
175      const char* type_param,
176      const char* value_param,
177      TypeId fixture_class_id,
178      SetUpTestCaseFunc set_up_tc,
179      TearDownTestCaseFunc tear_down_tc,
180      TestFactoryBase* factory);
181  GTEST_API_ bool SkipPrefix(const char* prefix, const char** pstr);
182  #if GTEST_HAS_TYPED_TEST || GTEST_HAS_TYPED_TEST_P
183  class GTEST_API_ TypedTestCasePState {
184   public:
185    TypedTestCasePState() : registered_(false) {}
186    bool AddTestName(const char* file, int line, const char* case_name,
187                     const char* test_name) {
188      if (registered_) {
189        fprintf(stderr, &quot;%s Test %s must be defined before &quot;
190                &quot;REGISTER_TYPED_TEST_CASE_P(%s, ...).\n&quot;,
191                FormatFileLocation(file, line).c_str(), test_name, case_name);
192        fflush(stderr);
193        posix::Abort();
194      }
195      defined_test_names_.insert(test_name);
196      return true;
197    }
198    const char* VerifyRegisteredTestNames(
199        const char* file, int line, const char* registered_tests);
200   private:
201    bool registered_;
202    ::std::set&lt;const char*&gt; defined_test_names_;
203  };
204  inline const char* SkipComma(const char* str) {
205    const char* comma = strchr(str, &#x27;,&#x27;);
206    if (comma == NULL) {
207      return NULL;
208    }
209    while (IsSpace(*(++comma))) {}
210    return comma;
211  }
212  inline std::string GetPrefixUntilComma(const char* str) {
213    const char* comma = strchr(str, &#x27;,&#x27;);
214    return comma == NULL ? str : std::string(str, comma);
215  }
216  template &lt;GTEST_TEMPLATE_ Fixture, class TestSel, typename Types&gt;
217  class TypeParameterizedTest {
218   public:
219    static bool Register(const char* prefix, const char* case_name,
220                         const char* test_names, int index) {
221      typedef typename Types::Head Type;
222      typedef Fixture&lt;Type&gt; FixtureClass;
223      typedef typename GTEST_BIND_(TestSel, Type) TestClass;
224      MakeAndRegisterTestInfo(
225          (std::string(prefix) + (prefix[0] == &#x27;\0&#x27; ? &quot;&quot; : &quot;/&quot;) + case_name + &quot;/&quot;
226           + StreamableToString(index)).c_str(),
227          GetPrefixUntilComma(test_names).c_str(),
228          GetTypeName&lt;Type&gt;().c_str(),
229          NULL,  
230          GetTypeId&lt;FixtureClass&gt;(),
231          TestClass::SetUpTestCase,
232          TestClass::TearDownTestCase,
233          new TestFactoryImpl&lt;TestClass&gt;);
234      return TypeParameterizedTest&lt;Fixture, TestSel, typename Types::Tail&gt;
235          ::Register(prefix, case_name, test_names, index + 1);
236    }
237  };
238  template &lt;GTEST_TEMPLATE_ Fixture, class TestSel&gt;
239  class TypeParameterizedTest&lt;Fixture, TestSel, Types0&gt; {
240   public:
241    static bool Register(const char* &amp;bsol;*prefix*/, const char* &amp;bsol;*case_name*/,
242                         const char* &amp;bsol;*test_names*/, int &amp;bsol;*index*/) {
243      return true;
244    }
245  };
246  template &lt;GTEST_TEMPLATE_ Fixture, typename Tests, typename Types&gt;
247  class TypeParameterizedTestCase {
248   public:
249    static bool Register(const char* prefix, const char* case_name,
250                         const char* test_names) {
251      typedef typename Tests::Head Head;
252      TypeParameterizedTest&lt;Fixture, Head, Types&gt;::Register(
253          prefix, case_name, test_names, 0);
254      return TypeParameterizedTestCase&lt;Fixture, typename Tests::Tail, Types&gt;
255          ::Register(prefix, case_name, SkipComma(test_names));
256    }
257  };
258  template &lt;GTEST_TEMPLATE_ Fixture, typename Types&gt;
259  class TypeParameterizedTestCase&lt;Fixture, Templates0, Types&gt; {
260   public:
261    static bool Register(const char* &amp;bsol;*prefix*/, const char* &amp;bsol;*case_name*/,
262                         const char* &amp;bsol;*test_names*/) {
263      return true;
264    }
265  };
266  #endif  
267  GTEST_API_ std::string GetCurrentOsStackTraceExceptTop(
268      UnitTest* unit_test, int skip_count);
269  GTEST_API_ bool AlwaysTrue();
270  inline bool AlwaysFalse() { return !AlwaysTrue(); }
271  struct GTEST_API_ ConstCharPtr {
272    ConstCharPtr(const char* str) : value(str) {}
273    operator bool() const { return true; }
274    const char* value;
275  };
276  class GTEST_API_ Random {
277   public:
278    static const UInt32 kMaxRange = 1u &lt;&lt; 31;
279    explicit Random(UInt32 seed) : state_(seed) {}
280    void Reseed(UInt32 seed) { state_ = seed; }
281    UInt32 Generate(UInt32 range);
282   private:
283    UInt32 state_;
284    GTEST_DISALLOW_COPY_AND_ASSIGN_(Random);
285  };
286  template &lt;typename T1, typename T2&gt;
287  struct CompileAssertTypesEqual;
288  template &lt;typename T&gt;
289  struct CompileAssertTypesEqual&lt;T, T&gt; {
290  };
291  template &lt;typename T&gt;
292  struct RemoveReference { typedef T type; };  
293  template &lt;typename T&gt;
294  struct RemoveReference&lt;T&amp;&gt; { typedef T type; };  
295  #define GTEST_REMOVE_REFERENCE_(T) \
296      typename ::testing::internal::RemoveReference&lt;T&gt;::type
297  template &lt;typename T&gt;
298  struct RemoveConst { typedef T type; };  
299  template &lt;typename T&gt;
300  struct RemoveConst&lt;const T&gt; { typedef T type; };  
301  template &lt;typename T, size_t N&gt;
302  struct RemoveConst&lt;const T[N]&gt; {
303    typedef typename RemoveConst&lt;T&gt;::type type[N];
304  };
305  #if defined(_MSC_VER) &amp;&amp; _MSC_VER &lt; 1400
306  template &lt;typename T, size_t N&gt;
307  struct RemoveConst&lt;T[N]&gt; {
308    typedef typename RemoveConst&lt;T&gt;::type type[N];
309  };
310  #endif
311  #define GTEST_REMOVE_CONST_(T) \
312      typename ::testing::internal::RemoveConst&lt;T&gt;::type
313  #define GTEST_REMOVE_REFERENCE_AND_CONST_(T) \
314      GTEST_REMOVE_CONST_(GTEST_REMOVE_REFERENCE_(T))
315  template &lt;typename T&gt;
316  struct AddReference { typedef T&amp; type; };  
317  template &lt;typename T&gt;
318  struct AddReference&lt;T&amp;&gt; { typedef T&amp; type; };  
319  #define GTEST_ADD_REFERENCE_(T) \
320      typename ::testing::internal::AddReference&lt;T&gt;::type
321  #define GTEST_REFERENCE_TO_CONST_(T) \
322      GTEST_ADD_REFERENCE_(const GTEST_REMOVE_REFERENCE_(T))
323  template &lt;typename From, typename To&gt;
324  class ImplicitlyConvertible {
325   private:
326    static From MakeFrom();
327    static char Helper(To);
328    static char (&amp;Helper(...))[2];  
329   public:
330  #ifdef _MSC_VER
331  # pragma warning(push)          
332  # pragma warning(disable:4244)  
333    static const bool value =
334        sizeof(Helper(ImplicitlyConvertible::MakeFrom())) == 1;
335  # pragma warning(pop)           
336  #elif defined(__BORLANDC__)
337    static const bool value = __is_convertible(From, To);
338  #else
<span onclick='openModal()' class='match'>339    static const bool value =
340        sizeof(Helper(ImplicitlyConvertible::MakeFrom())) == 1;
341  #endif  
</span>342  };
343  template &lt;typename From, typename To&gt;
344  const bool ImplicitlyConvertible&lt;From, To&gt;::value;
345  template &lt;typename T&gt;
346  struct IsAProtocolMessage
347      : public bool_constant&lt;
348    ImplicitlyConvertible&lt;const T*, const ::ProtocolMessage*&gt;::value ||
349    ImplicitlyConvertible&lt;const T*, const ::proto2::Message*&gt;::value&gt; {
350  };
351  typedef int IsContainer;
352  template &lt;class C&gt;
353  IsContainer IsContainerTest(int &amp;bsol;* dummy */,
354                              typename C::iterator* &amp;bsol;* it */ = NULL,
355                              typename C::const_iterator* &amp;bsol;* const_it */ = NULL) {
356    return 0;
357  }
358  typedef char IsNotContainer;
359  template &lt;class C&gt;
360  IsNotContainer IsContainerTest(long &amp;bsol;* dummy */) { return &#x27;\0&#x27;; }
361  template&lt;bool&gt; struct EnableIf;
362  template&lt;&gt; struct EnableIf&lt;true&gt; { typedef void type; };  
363  template &lt;typename T, typename U&gt;
364  bool ArrayEq(const T* lhs, size_t size, const U* rhs);
365  template &lt;typename T, typename U&gt;
366  inline bool ArrayEq(const T&amp; lhs, const U&amp; rhs) { return lhs == rhs; }
367  template &lt;typename T, typename U, size_t N&gt;
368  inline bool ArrayEq(const T(&amp;lhs)[N], const U(&amp;rhs)[N]) {
369    return internal::ArrayEq(lhs, N, rhs);
370  }
371  template &lt;typename T, typename U&gt;
372  bool ArrayEq(const T* lhs, size_t size, const U* rhs) {
373    for (size_t i = 0; i != size; i++) {
374      if (!internal::ArrayEq(lhs[i], rhs[i]))
375        return false;
376    }
377    return true;
378  }
379  template &lt;typename Iter, typename Element&gt;
380  Iter ArrayAwareFind(Iter begin, Iter end, const Element&amp; elem) {
381    for (Iter it = begin; it != end; ++it) {
382      if (internal::ArrayEq(*it, elem))
383        return it;
384    }
385    return end;
386  }
387  template &lt;typename T, typename U&gt;
388  void CopyArray(const T* from, size_t size, U* to);
389  template &lt;typename T, typename U&gt;
390  inline void CopyArray(const T&amp; from, U* to) { *to = from; }
391  template &lt;typename T, typename U, size_t N&gt;
392  inline void CopyArray(const T(&amp;from)[N], U(*to)[N]) {
393    internal::CopyArray(from, N, *to);
394  }
395  template &lt;typename T, typename U&gt;
396  void CopyArray(const T* from, size_t size, U* to) {
397    for (size_t i = 0; i != size; i++) {
398      internal::CopyArray(from[i], to + i);
399    }
400  }
401  enum RelationToSource {
402    kReference,  
403    kCopy        
404  };
405  template &lt;typename Element&gt;
406  class NativeArray {
407   public:
408    typedef Element value_type;
409    typedef Element* iterator;
410    typedef const Element* const_iterator;
411    NativeArray(const Element* array, size_t count, RelationToSource relation) {
412      Init(array, count, relation);
413    }
414    NativeArray(const NativeArray&amp; rhs) {
415      Init(rhs.array_, rhs.size_, rhs.relation_to_source_);
416    }
417    ~NativeArray() {
418      static_cast&lt;void&gt;(StaticAssertTypeEqHelper&lt;Element,
419          GTEST_REMOVE_REFERENCE_AND_CONST_(Element)&gt;());
420      if (relation_to_source_ == kCopy)
421        delete[] array_;
422    }
423    size_t size() const { return size_; }
424    const_iterator begin() const { return array_; }
425    const_iterator end() const { return array_ + size_; }
426    bool operator==(const NativeArray&amp; rhs) const {
427      return size() == rhs.size() &amp;&amp;
428          ArrayEq(begin(), size(), rhs.begin());
429    }
430   private:
431    void Init(const Element* array, size_t a_size, RelationToSource relation) {
432      if (relation == kReference) {
433        array_ = array;
434      } else {
435        Element* const copy = new Element[a_size];
436        CopyArray(array, a_size, copy);
437        array_ = copy;
438      }
439      size_ = a_size;
440      relation_to_source_ = relation;
441    }
442    const Element* array_;
443    size_t size_;
444    RelationToSource relation_to_source_;
445    GTEST_DISALLOW_ASSIGN_(NativeArray);
446  };
447  }  
448  }  
449  #define GTEST_MESSAGE_AT_(file, line, message, result_type) \
450    ::testing::internal::AssertHelper(result_type, file, line, message) \
451      = ::testing::Message()
452  #define GTEST_MESSAGE_(message, result_type) \
453    GTEST_MESSAGE_AT_(__FILE__, __LINE__, message, result_type)
454  #define GTEST_FATAL_FAILURE_(message) \
455    return GTEST_MESSAGE_(message, ::testing::TestPartResult::kFatalFailure)
456  #define GTEST_NONFATAL_FAILURE_(message) \
457    GTEST_MESSAGE_(message, ::testing::TestPartResult::kNonFatalFailure)
458  #define GTEST_SUCCESS_(message) \
459    GTEST_MESSAGE_(message, ::testing::TestPartResult::kSuccess)
460  #define GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement) \
461    if (::testing::internal::AlwaysTrue()) { statement; }
462  #define GTEST_TEST_THROW_(statement, expected_exception, fail) \
463    GTEST_AMBIGUOUS_ELSE_BLOCKER_ \
464    if (::testing::internal::ConstCharPtr gtest_msg = &quot;&quot;) { \
465      bool gtest_caught_expected = false; \
466      try { \
467        GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); \
468      } \
469      catch (expected_exception const&amp;) { \
470        gtest_caught_expected = true; \
471      } \
472      catch (...) { \
473        gtest_msg.value = \
474            &quot;Expected: &quot; #statement &quot; throws an exception of type &quot; \
475            #expected_exception &quot;.\n  Actual: it throws a different type.&quot;; \
476        goto GTEST_CONCAT_TOKEN_(gtest_label_testthrow_, __LINE__); \
477      } \
478      if (!gtest_caught_expected) { \
479        gtest_msg.value = \
480            &quot;Expected: &quot; #statement &quot; throws an exception of type &quot; \
481            #expected_exception &quot;.\n  Actual: it throws nothing.&quot;; \
482        goto GTEST_CONCAT_TOKEN_(gtest_label_testthrow_, __LINE__); \
483      } \
484    } else \
485      GTEST_CONCAT_TOKEN_(gtest_label_testthrow_, __LINE__): \
486        fail(gtest_msg.value)
487  #define GTEST_TEST_NO_THROW_(statement, fail) \
488    GTEST_AMBIGUOUS_ELSE_BLOCKER_ \
489    if (::testing::internal::AlwaysTrue()) { \
490      try { \
491        GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); \
492      } \
493      catch (...) { \
494        goto GTEST_CONCAT_TOKEN_(gtest_label_testnothrow_, __LINE__); \
495      } \
496    } else \
497      GTEST_CONCAT_TOKEN_(gtest_label_testnothrow_, __LINE__): \
498        fail(&quot;Expected: &quot; #statement &quot; doesn&#x27;t throw an exception.\n&quot; \
499             &quot;  Actual: it throws.&quot;)
500  #define GTEST_TEST_ANY_THROW_(statement, fail) \
501    GTEST_AMBIGUOUS_ELSE_BLOCKER_ \
502    if (::testing::internal::AlwaysTrue()) { \
503      bool gtest_caught_any = false; \
504      try { \
505        GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); \
506      } \
507      catch (...) { \
508        gtest_caught_any = true; \
509      } \
510      if (!gtest_caught_any) { \
511        goto GTEST_CONCAT_TOKEN_(gtest_label_testanythrow_, __LINE__); \
512      } \
513    } else \
514      GTEST_CONCAT_TOKEN_(gtest_label_testanythrow_, __LINE__): \
515        fail(&quot;Expected: &quot; #statement &quot; throws an exception.\n&quot; \
516             &quot;  Actual: it doesn&#x27;t.&quot;)
517  #define GTEST_TEST_BOOLEAN_(expression, text, actual, expected, fail) \
518    GTEST_AMBIGUOUS_ELSE_BLOCKER_ \
519    if (const ::testing::AssertionResult gtest_ar_ = \
520        ::testing::AssertionResult(expression)) \
521      ; \
522    else \
523      fail(::testing::internal::GetBoolAssertionFailureMessage(\
524          gtest_ar_, text, #actual, #expected).c_str())
525  #define GTEST_TEST_NO_FATAL_FAILURE_(statement, fail) \
526    GTEST_AMBIGUOUS_ELSE_BLOCKER_ \
527    if (::testing::internal::AlwaysTrue()) { \
528      ::testing::internal::HasNewFatalFailureHelper gtest_fatal_failure_checker; \
529      GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); \
530      if (gtest_fatal_failure_checker.has_new_fatal_failure()) { \
531        goto GTEST_CONCAT_TOKEN_(gtest_label_testnofatal_, __LINE__); \
532      } \
533    } else \
534      GTEST_CONCAT_TOKEN_(gtest_label_testnofatal_, __LINE__): \
535        fail(&quot;Expected: &quot; #statement &quot; doesn&#x27;t generate new fatal &quot; \
536             &quot;failures in the current thread.\n&quot; \
537             &quot;  Actual: it does.&quot;)
538  #define GTEST_TEST_CLASS_NAME_(test_case_name, test_name) \
539    test_case_name##_##test_name##_Test
540  #define GTEST_TEST_(test_case_name, test_name, parent_class, parent_id)\
541  class GTEST_TEST_CLASS_NAME_(test_case_name, test_name) : public parent_class {\
542   public:\
543    GTEST_TEST_CLASS_NAME_(test_case_name, test_name)() {}\
544   private:\
545    virtual void TestBody();\
546    static ::testing::TestInfo* const test_info_ GTEST_ATTRIBUTE_UNUSED_;\
547    GTEST_DISALLOW_COPY_AND_ASSIGN_(\
548        GTEST_TEST_CLASS_NAME_(test_case_name, test_name));\
549  };\
550  \
551  ::testing::TestInfo* const GTEST_TEST_CLASS_NAME_(test_case_name, test_name)\
552    ::test_info_ =\
553      ::testing::internal::MakeAndRegisterTestInfo(\
554          #test_case_name, #test_name, NULL, NULL, \
555          (parent_id), \
556          parent_class::SetUpTestCase, \
557          parent_class::TearDownTestCase, \
558          new ::testing::internal::TestFactoryImpl&lt;\
559              GTEST_TEST_CLASS_NAME_(test_case_name, test_name)&gt;);\
560  void GTEST_TEST_CLASS_NAME_(test_case_name, test_name)::TestBody()
561  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-gtest-internal.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-gtest-internal.h</div>
                </div>
                <div class="column column_space"><pre><code>333    static const bool value =
334        sizeof(Helper(ImplicitlyConvertible::MakeFrom())) == 1;
335  # pragma warning(pop)           
</pre></code></div>
                <div class="column column_space"><pre><code>339    static const bool value =
340        sizeof(Helper(ImplicitlyConvertible::MakeFrom())) == 1;
341  #endif  
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    