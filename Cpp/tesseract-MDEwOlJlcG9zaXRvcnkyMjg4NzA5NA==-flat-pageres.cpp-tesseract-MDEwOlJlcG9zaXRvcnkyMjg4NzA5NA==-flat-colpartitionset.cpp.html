
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 15, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-pageres.cpp</h3>
            <pre><code>1  #include "pageres.h"
2  #include "blamer.h"   
3  #include "blobs.h"    
4  #include "boxword.h"  
5  #include "errcode.h"  
6  #include "ocrblock.h" 
7  #include "ocrrow.h"   
8  #include "pdblock.h"  
9  #include "polyblk.h"  
10  #include "seam.h"     
11  #include "stepblob.h" 
12  #include "tprintf.h"  
13  #include <tesseract/publictypes.h> 
14  #include <cassert> 
15  #include <cstdint> 
16  #include <cstring> 
17  struct Pix;
18  namespace tesseract {
19  static const double kStopperAmbiguityThresholdGain = 8.0;
20  static const double kStopperAmbiguityThresholdOffset = 1.5;
21  const int kWordrecMaxNumJoinChunks = 4;
22  const double kMaxWordSizeRatio = 1.25;
23  const double kMaxLineSizeRatio = 1.25;
24  const double kMaxWordGapRatio = 2.0;
25  static double StopperAmbigThreshold(double f1, double f2) {
26    return (f2 - f1) * kStopperAmbiguityThresholdGain -
27           kStopperAmbiguityThresholdOffset;
28  }
29  PAGE_RES::PAGE_RES(bool merge_similar_words, BLOCK_LIST *the_block_list,
30                     WERD_CHOICE **prev_word_best_choice_ptr) {
31    Init();
32    BLOCK_IT block_it(the_block_list);
33    BLOCK_RES_IT block_res_it(&block_res_list);
34    for (block_it.mark_cycle_pt(); !block_it.cycled_list(); block_it.forward()) {
35      block_res_it.add_to_end(
36          new BLOCK_RES(merge_similar_words, block_it.data()));
37    }
38    prev_word_best_choice = prev_word_best_choice_ptr;
39  }
40  BLOCK_RES::BLOCK_RES(bool merge_similar_words, BLOCK *the_block) {
41    ROW_IT row_it(the_block->row_list());
<span onclick='openModal()' class='match'>42    ROW_RES_IT row_res_it(&row_res_list);
43    char_count = 0;
44    rej_count = 0;
45    font_class = -1; 
</span>46    x_height = -1.0;
47    font_assigned = false;
48    row_count = 0;
49    block = the_block;
50    for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
51      row_res_it.add_to_end(new ROW_RES(merge_similar_words, row_it.data()));
52    }
53  }
54  ROW_RES::ROW_RES(bool merge_similar_words, ROW *the_row) {
55    WERD_IT word_it(the_row->word_list());
56    WERD_RES_IT word_res_it(&word_res_list);
57    WERD_RES *combo = nullptr; 
58    WERD *copy_word;
59    char_count = 0;
60    rej_count = 0;
61    whole_word_rej_count = 0;
62    row = the_row;
63    bool add_next_word = false;
64    TBOX union_box;
65    float line_height =
66        the_row->x_height() + the_row->ascenders() - the_row->descenders();
67    for (word_it.mark_cycle_pt(); !word_it.cycled_list(); word_it.forward()) {
68      auto *word_res = new WERD_RES(word_it.data());
69      word_res->x_height = the_row->x_height();
70      if (add_next_word) {
71        ASSERT_HOST(combo != nullptr);
72        word_res->part_of_combo = true;
73        combo->copy_on(word_res);
74      } else if (merge_similar_words) {
75        union_box = word_res->word->bounding_box();
76        add_next_word = !word_res->word->flag(W_REP_CHAR) &&
77                        union_box.height() <= line_height * kMaxWordSizeRatio;
78        word_res->odd_size = !add_next_word;
79      }
80      WERD *next_word = word_it.data_relative(1);
81      if (merge_similar_words) {
82        if (add_next_word && !next_word->flag(W_REP_CHAR)) {
83          TBOX next_box = next_word->bounding_box();
84          int prev_right = union_box.right();
85          union_box += next_box;
86          if (next_box.height() > line_height * kMaxWordSizeRatio ||
87              union_box.height() > line_height * kMaxLineSizeRatio ||
88              next_box.left() > prev_right + line_height * kMaxWordGapRatio) {
89            add_next_word = false;
90          }
91        }
92        next_word->set_flag(W_FUZZY_NON, add_next_word);
93      } else {
94        add_next_word = next_word->flag(W_FUZZY_NON);
95      }
96      if (add_next_word) {
97        if (combo == nullptr) {
98          copy_word = new WERD;
99          *copy_word = *(word_it.data()); 
100          combo = new WERD_RES(copy_word);
101          combo->x_height = the_row->x_height();
102          combo->combination = true;
103          word_res_it.add_to_end(combo);
104        }
105        word_res->part_of_combo = true;
106      } else {
107        combo = nullptr;
108      }
109      word_res_it.add_to_end(word_res);
110    }
111  }
112  WERD_RES &WERD_RES::operator=(const WERD_RES &source) {
113    this->ELIST_LINK::operator=(source);
114    Clear();
115    if (source.combination) {
116      word = new WERD;
117      *word = *(source.word); 
118    } else {
119      word = source.word; 
120    }
121    if (source.bln_boxes != nullptr) {
122      bln_boxes = new tesseract::BoxWord(*source.bln_boxes);
123    }
124    if (source.chopped_word != nullptr) {
125      chopped_word = new TWERD(*source.chopped_word);
126    }
127    if (source.rebuild_word != nullptr) {
128      rebuild_word = new TWERD(*source.rebuild_word);
129    }
130    blob_row = source.blob_row;
131    denorm = source.denorm;
132    if (source.box_word != nullptr) {
133      box_word = new tesseract::BoxWord(*source.box_word);
134    }
135    best_state = source.best_state;
136    correct_text = source.correct_text;
137    blob_widths = source.blob_widths;
138    blob_gaps = source.blob_gaps;
139    WERD_CHOICE_IT wc_it(const_cast<WERD_CHOICE_LIST *>(&source.best_choices));
140    WERD_CHOICE_IT wc_dest_it(&best_choices);
141    for (wc_it.mark_cycle_pt(); !wc_it.cycled_list(); wc_it.forward()) {
142      const WERD_CHOICE *choice = wc_it.data();
143      wc_dest_it.add_after_then_move(new WERD_CHOICE(*choice));
144    }
145    if (!wc_dest_it.empty()) {
146      wc_dest_it.move_to_first();
147      best_choice = wc_dest_it.data();
148    } else {
149      best_choice = nullptr;
150    }
151    if (source.raw_choice != nullptr) {
152      raw_choice = new WERD_CHOICE(*source.raw_choice);
153    } else {
154      raw_choice = nullptr;
155    }
156    if (source.ep_choice != nullptr) {
157      ep_choice = new WERD_CHOICE(*source.ep_choice);
158    } else {
159      ep_choice = nullptr;
160    }
161    reject_map = source.reject_map;
162    combination = source.combination;
163    part_of_combo = source.part_of_combo;
164    CopySimpleFields(source);
165    if (source.blamer_bundle != nullptr) {
166      blamer_bundle = new BlamerBundle(*(source.blamer_bundle));
167    }
168    return *this;
169  }
170  void WERD_RES::CopySimpleFields(const WERD_RES &source) {
171    tess_failed = source.tess_failed;
172    tess_accepted = source.tess_accepted;
173    tess_would_adapt = source.tess_would_adapt;
174    done = source.done;
175    unlv_crunch_mode = source.unlv_crunch_mode;
176    small_caps = source.small_caps;
177    odd_size = source.odd_size;
178    fontinfo = source.fontinfo;
179    fontinfo2 = source.fontinfo2;
180    fontinfo_id_count = source.fontinfo_id_count;
181    fontinfo_id2_count = source.fontinfo_id2_count;
182    x_height = source.x_height;
183    caps_height = source.caps_height;
184    baseline_shift = source.baseline_shift;
185    guessed_x_ht = source.guessed_x_ht;
186    guessed_caps_ht = source.guessed_caps_ht;
187    reject_spaces = source.reject_spaces;
188    uch_set = source.uch_set;
189    tesseract = source.tesseract;
190  }
191  void WERD_RES::InitForRetryRecognition(const WERD_RES &source) {
192    word = source.word;
193    CopySimpleFields(source);
194    if (source.blamer_bundle != nullptr) {
195      blamer_bundle = new BlamerBundle();
196      blamer_bundle->CopyTruth(*source.blamer_bundle);
197    }
198  }
199  bool WERD_RES::SetupForRecognition(const UNICHARSET &unicharset_in,
200                                     tesseract::Tesseract *tess, Image pix,
201                                     int norm_mode, const TBOX *norm_box,
202                                     bool numeric_mode, bool use_body_size,
203                                     bool allow_detailed_fx, ROW *row,
204                                     const BLOCK *block) {
205    auto norm_mode_hint = static_cast<tesseract::OcrEngineMode>(norm_mode);
206    tesseract = tess;
207    POLY_BLOCK *pb = block != nullptr ? block->pdblk.poly_block() : nullptr;
208    if ((norm_mode_hint != tesseract::OEM_LSTM_ONLY &&
209         word->cblob_list()->empty()) ||
210        (pb != nullptr && !pb->IsText())) {
211      SetupFake(unicharset_in);
212      word->set_flag(W_REP_CHAR, false);
213      return false;
214    }
215    ClearResults();
216    SetupWordScript(unicharset_in);
217    chopped_word = TWERD::PolygonalCopy(allow_detailed_fx, word);
218    float word_xheight =
219        use_body_size && row != nullptr && row->body_size() > 0.0f
220            ? row->body_size()
221            : x_height;
222    chopped_word->BLNormalize(block, row, pix, word->flag(W_INVERSE),
223                              word_xheight, baseline_shift, numeric_mode,
224                              norm_mode_hint, norm_box, &denorm);
225    blob_row = row;
226    SetupBasicsFromChoppedWord(unicharset_in);
227    SetupBlamerBundle();
228    int num_blobs = chopped_word->NumBlobs();
229    ratings = new MATRIX(num_blobs, kWordrecMaxNumJoinChunks);
230    tess_failed = false;
231    return true;
232  }
233  void WERD_RES::SetupBasicsFromChoppedWord(const UNICHARSET &unicharset_in) {
234    bln_boxes = tesseract::BoxWord::CopyFromNormalized(chopped_word);
235    start_seam_list(chopped_word, &seam_array);
236    SetupBlobWidthsAndGaps();
237    ClearWordChoices();
238  }
239  void WERD_RES::SetupFake(const UNICHARSET &unicharset_in) {
240    ClearResults();
241    SetupWordScript(unicharset_in);
242    chopped_word = new TWERD;
243    rebuild_word = new TWERD;
244    bln_boxes = new tesseract::BoxWord;
245    box_word = new tesseract::BoxWord;
246    int blob_count = word->cblob_list()->length();
247    if (blob_count > 0) {
248      auto **fake_choices = new BLOB_CHOICE *[blob_count];
249      C_BLOB_IT b_it(word->cblob_list());
250      int blob_id = 0;
251      for (b_it.mark_cycle_pt(); !b_it.cycled_list(); b_it.forward()) {
252        TBOX box = b_it.data()->bounding_box();
253        box_word->InsertBox(box_word->length(), box);
254        fake_choices[blob_id++] = new BLOB_CHOICE;
255      }
256      FakeClassifyWord(blob_count, fake_choices);
257      delete[] fake_choices;
258    } else {
259      auto *word = new WERD_CHOICE(&unicharset_in);
260      word->make_bad();
261      LogNewRawChoice(word);
262      LogNewCookedChoice(1, false, word);
263    }
264    tess_failed = true;
265    done = true;
266  }
267  void WERD_RES::SetupWordScript(const UNICHARSET &uch) {
268    uch_set = &uch;
269    int script = uch.default_sid();
270    word->set_script_id(script);
271    word->set_flag(W_SCRIPT_HAS_XHEIGHT, uch.script_has_xheight());
272    word->set_flag(W_SCRIPT_IS_LATIN, script == uch.latin_sid());
273  }
274  void WERD_RES::SetupBlamerBundle() {
275    if (blamer_bundle != nullptr) {
276      blamer_bundle->SetupNormTruthWord(denorm);
277    }
278  }
279  void WERD_RES::SetupBlobWidthsAndGaps() {
280    blob_widths.clear();
281    blob_gaps.clear();
282    int num_blobs = chopped_word->NumBlobs();
283    for (int b = 0; b < num_blobs; ++b) {
284      TBLOB *blob = chopped_word->blobs[b];
285      TBOX box = blob->bounding_box();
286      blob_widths.push_back(box.width());
287      if (b + 1 < num_blobs) {
288        blob_gaps.push_back(chopped_word->blobs[b + 1]->bounding_box().left() -
289                            box.right());
290      }
291    }
292  }
293  void WERD_RES::InsertSeam(int blob_number, SEAM *seam) {
294    seam->PrepareToInsertSeam(seam_array, chopped_word->blobs, blob_number, true);
295    seam_array.insert(seam_array.begin() + blob_number, seam);
296    if (ratings != nullptr) {
297      ratings = ratings->ConsumeAndMakeBigger(blob_number);
298      if (raw_choice != nullptr) {
299        raw_choice->UpdateStateForSplit(blob_number);
300      }
301      WERD_CHOICE_IT wc_it(&best_choices);
302      for (wc_it.mark_cycle_pt(); !wc_it.cycled_list(); wc_it.forward()) {
303        WERD_CHOICE *choice = wc_it.data();
304        choice->UpdateStateForSplit(blob_number);
305      }
306      SetupBlobWidthsAndGaps();
307    }
308  }
309  bool WERD_RES::AlternativeChoiceAdjustmentsWorseThan(float threshold) const {
310    WERD_CHOICE_IT wc_it(const_cast<WERD_CHOICE_LIST *>(&best_choices));
311    for (wc_it.forward(); !wc_it.at_first(); wc_it.forward()) {
312      WERD_CHOICE *choice = wc_it.data();
313      if (choice->adjust_factor() <= threshold) {
314        return false;
315      }
316    }
317    return true;
318  }
319  bool WERD_RES::IsAmbiguous() {
320    return !best_choices.singleton() || best_choice->dangerous_ambig_found();
321  }
322  bool WERD_RES::StatesAllValid() {
323    unsigned ratings_dim = ratings->dimension();
324    if (raw_choice->TotalOfStates() != ratings_dim) {
325      tprintf("raw_choice has total of states = %u vs ratings dim of %u\n",
326              raw_choice->TotalOfStates(), ratings_dim);
327      return false;
328    }
329    WERD_CHOICE_IT it(&best_choices);
330    unsigned index = 0;
331    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward(), ++index) {
332      WERD_CHOICE *choice = it.data();
333      if (choice->TotalOfStates() != ratings_dim) {
334        tprintf("Cooked #%u has total of states = %u vs ratings dim of %u\n",
335                index, choice->TotalOfStates(), ratings_dim);
336        return false;
337      }
338    }
339    return true;
340  }
341  void WERD_RES::DebugWordChoices(bool debug, const char *word_to_debug) {
342    if (debug || (word_to_debug != nullptr && *word_to_debug != '\0' &&
343                  best_choice != nullptr &&
344                  best_choice->unichar_string() == std::string(word_to_debug))) {
345      if (raw_choice != nullptr) {
346        raw_choice->print("\nBest Raw Choice");
347      }
348      WERD_CHOICE_IT it(&best_choices);
349      int index = 0;
350      for (it.mark_cycle_pt(); !it.cycled_list(); it.forward(), ++index) {
351        WERD_CHOICE *choice = it.data();
352        std::string label;
353        label += "\nCooked Choice #" + std::to_string(index);
354        choice->print(label.c_str());
355      }
356    }
357  }
358  void WERD_RES::DebugTopChoice(const char *msg) const {
359    tprintf("Best choice: accepted=%d, adaptable=%d, done=%d : ", tess_accepted,
360            tess_would_adapt, done);
361    if (best_choice == nullptr) {
362      tprintf("<Null choice>\n");
363    } else {
364      best_choice->print(msg);
365    }
366  }
367  void WERD_RES::FilterWordChoices(int debug_level) {
368    if (best_choice == nullptr || best_choices.singleton()) {
369      return;
370    }
371    if (debug_level >= 2) {
372      best_choice->print("\nFiltering against best choice");
373    }
374    WERD_CHOICE_IT it(&best_choices);
375    int index = 0;
376    for (it.forward(); !it.at_first(); it.forward(), ++index) {
377      WERD_CHOICE *choice = it.data();
378      float threshold = StopperAmbigThreshold(best_choice->adjust_factor(),
379                                              choice->adjust_factor());
380      unsigned i = 0, j = 0, chunk = 0;
381      auto choice_chunk = choice->state(0), best_chunk = best_choice->state(0);
382      while (i < choice->length() && j < best_choice->length()) {
383        if (choice->unichar_id(i) != best_choice->unichar_id(j) &&
384            choice->certainty(i) - best_choice->certainty(j) < threshold) {
385          if (debug_level >= 2) {
386            choice->print("WorstCertaintyDiffWorseThan");
387            tprintf(
388                "i %u j %u Choice->Blob[i].Certainty %.4g"
389                " WorstOtherChoiceCertainty %g Threshold %g\n",
390                i, j, choice->certainty(i), best_choice->certainty(j), threshold);
391            tprintf("Discarding bad choice #%d\n", index);
392          }
393          delete it.extract();
394          break;
395        }
396        ++chunk;
397        while (choice_chunk < chunk && ++i < choice->length()) {
398          choice_chunk += choice->state(i);
399        }
400        while (best_chunk < chunk && ++j < best_choice->length()) {
401          best_chunk += best_choice->state(j);
402        }
403      }
404    }
405  }
406  void WERD_RES::ComputeAdaptionThresholds(float certainty_scale,
407                                           float min_rating, float max_rating,
408                                           float rating_margin,
409                                           float *thresholds) {
410    int chunk = 0;
411    int end_chunk = best_choice->state(0);
412    int end_raw_chunk = raw_choice->state(0);
413    int raw_blob = 0;
414    for (unsigned i = 0; i < best_choice->length(); i++, thresholds++) {
415      float avg_rating = 0.0f;
416      int num_error_chunks = 0;
417      while (chunk < end_chunk) {
418        if (chunk >= end_raw_chunk) {
419          ++raw_blob;
420          end_raw_chunk += raw_choice->state(raw_blob);
421        }
422        if (best_choice->unichar_id(i) != raw_choice->unichar_id(raw_blob)) {
423          avg_rating += raw_choice->certainty(raw_blob);
424          ++num_error_chunks;
425        }
426        ++chunk;
427      }
428      if (num_error_chunks > 0) {
429        avg_rating /= num_error_chunks;
430        *thresholds = (avg_rating / -certainty_scale) * (1.0 - rating_margin);
431      } else {
432        *thresholds = max_rating;
433      }
434      if (*thresholds > max_rating) {
435        *thresholds = max_rating;
436      }
437      if (*thresholds < min_rating) {
438        *thresholds = min_rating;
439      }
440    }
441  }
442  bool WERD_RES::LogNewRawChoice(WERD_CHOICE *word_choice) {
443    if (raw_choice == nullptr || word_choice->rating() < raw_choice->rating()) {
444      delete raw_choice;
445      raw_choice = new WERD_CHOICE(*word_choice);
446      raw_choice->set_permuter(TOP_CHOICE_PERM);
447      return true;
448    }
449    return false;
450  }
451  bool WERD_RES::LogNewCookedChoice(int max_num_choices, bool debug,
452                                    WERD_CHOICE *word_choice) {
453    if (best_choice != nullptr) {
454      float max_certainty_delta = StopperAmbigThreshold(
455          best_choice->adjust_factor(), word_choice->adjust_factor());
456      if (max_certainty_delta > -kStopperAmbiguityThresholdOffset) {
457        max_certainty_delta = -kStopperAmbiguityThresholdOffset;
458      }
459      if (word_choice->certainty() - best_choice->certainty() <
460          max_certainty_delta) {
461        if (debug) {
462          std::string bad_string;
463          word_choice->string_and_lengths(&bad_string, nullptr);
464          tprintf(
465              "Discarding choice \"%s\" with an overly low certainty"
466              " %.3f vs best choice certainty %.3f (Threshold: %.3f)\n",
467              bad_string.c_str(), word_choice->certainty(),
468              best_choice->certainty(),
469              max_certainty_delta + best_choice->certainty());
470        }
471        delete word_choice;
472        return false;
473      }
474    }
475    WERD_CHOICE_IT it(&best_choices);
476    const std::string &new_str = word_choice->unichar_string();
477    bool inserted = false;
478    int num_choices = 0;
479    if (!it.empty()) {
480      do {
481        WERD_CHOICE *choice = it.data();
482        if (choice->rating() > word_choice->rating() && !inserted) {
483          it.add_before_stay_put(word_choice);
484          inserted = true;
485          if (num_choices == 0) {
486            best_choice = word_choice; 
487          }
488          ++num_choices;
489        }
490        if (choice->unichar_string() == new_str) {
491          if (inserted) {
492            delete it.extract();
493          } else {
494            if (debug) {
495              tprintf("Discarding duplicate choice \"%s\", rating %g vs %g\n",
496                      new_str.c_str(), word_choice->rating(), choice->rating());
497            }
498            delete word_choice;
499            return false;
500          }
501        } else {
502          ++num_choices;
503          if (num_choices > max_num_choices) {
504            delete it.extract();
505          }
506        }
507        it.forward();
508      } while (!it.at_first());
509    }
510    if (!inserted && num_choices < max_num_choices) {
511      it.add_to_end(word_choice);
512      inserted = true;
513      if (num_choices == 0) {
514        best_choice = word_choice; 
515      }
516    }
517    if (debug) {
518      if (inserted) {
519        tprintf("New %s", best_choice == word_choice ? "Best" : "Secondary");
520      } else {
521        tprintf("Poor");
522      }
523      word_choice->print(" Word Choice");
524    }
525    if (!inserted) {
526      delete word_choice;
527      return false;
528    }
529    return true;
530  }
531  template <class T>
532  static void MovePointerData(T **dest, T **src) {
533    delete *dest;
534    *dest = *src;
535    *src = nullptr;
536  }
537  void WERD_RES::PrintBestChoices() const {
538    std::string alternates_str;
539    WERD_CHOICE_IT it(const_cast<WERD_CHOICE_LIST *>(&best_choices));
540    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
541      if (!it.at_first()) {
542        alternates_str += "\", \"";
543      }
544      alternates_str += it.data()->unichar_string();
545    }
546    tprintf("Alternates for \"%s\": {\"%s\"}\n",
547            best_choice->unichar_string().c_str(), alternates_str.c_str());
548  }
549  int WERD_RES::GetBlobsWidth(int start_blob, int last_blob) const {
550    int result = 0;
551    for (int b = start_blob; b <= last_blob; ++b) {
552      result += blob_widths[b];
553      if (b < last_blob) {
554        result += blob_gaps[b];
555      }
556    }
557    return result;
558  }
559  int WERD_RES::GetBlobsGap(unsigned blob_index) const {
560    if (blob_index >= blob_gaps.size()) {
561      return 0;
562    }
563    return blob_gaps[blob_index];
564  }
565  BLOB_CHOICE *WERD_RES::GetBlobChoice(unsigned index) const {
566    if (index >= best_choice->length()) {
567      return nullptr;
568    }
569    BLOB_CHOICE_LIST *choices = GetBlobChoices(index);
570    return FindMatchingChoice(best_choice->unichar_id(index), choices);
571  }
572  BLOB_CHOICE_LIST *WERD_RES::GetBlobChoices(int index) const {
573    return best_choice->blob_choices(index, ratings);
574  }
575  void WERD_RES::ConsumeWordResults(WERD_RES *word) {
576    denorm = word->denorm;
577    blob_row = word->blob_row;
578    MovePointerData(&chopped_word, &word->chopped_word);
579    MovePointerData(&rebuild_word, &word->rebuild_word);
580    MovePointerData(&box_word, &word->box_word);
581    for (auto data : seam_array) {
582      delete data;
583    }
584    seam_array = word->seam_array;
585    word->seam_array.clear();
586    best_state = word->best_state;
587    word->best_state.clear();
588    correct_text = word->correct_text;
589    word->correct_text.clear();
590    blob_widths = word->blob_widths;
591    word->blob_widths.clear();
592    blob_gaps = word->blob_gaps;
593    word->blob_gaps.clear();
594    if (ratings != nullptr) {
595      ratings->delete_matrix_pointers();
596    }
597    MovePointerData(&ratings, &word->ratings);
598    best_choice = word->best_choice;
599    MovePointerData(&raw_choice, &word->raw_choice);
600    best_choices.clear();
601    WERD_CHOICE_IT wc_it(&best_choices);
602    wc_it.add_list_after(&word->best_choices);
603    reject_map = word->reject_map;
604    if (word->blamer_bundle != nullptr) {
605      assert(blamer_bundle != nullptr);
606      blamer_bundle->CopyResults(*(word->blamer_bundle));
607    }
608    CopySimpleFields(*word);
609  }
610  void WERD_RES::ReplaceBestChoice(WERD_CHOICE *choice) {
611    best_choice = choice;
612    RebuildBestState();
613    SetupBoxWord();
614    reject_map.initialise(best_state.size());
615    done = tess_accepted = tess_would_adapt = true;
616    SetScriptPositions();
617  }
618  void WERD_RES::RebuildBestState() {
619    ASSERT_HOST(best_choice != nullptr);
620    delete rebuild_word;
621    rebuild_word = new TWERD;
622    if (seam_array.empty()) {
623      start_seam_list(chopped_word, &seam_array);
624    }
625    best_state.clear();
626    int start = 0;
627    for (unsigned i = 0; i < best_choice->length(); ++i) {
628      int length = best_choice->state(i);
629      best_state.push_back(length);
630      if (length > 1) {
631        SEAM::JoinPieces(seam_array, chopped_word->blobs, start,
632                         start + length - 1);
633      }
634      TBLOB *blob = chopped_word->blobs[start];
635      rebuild_word->blobs.push_back(new TBLOB(*blob));
636      if (length > 1) {
637        SEAM::BreakPieces(seam_array, chopped_word->blobs, start,
638                          start + length - 1);
639      }
640      start += length;
641    }
642  }
643  void WERD_RES::CloneChoppedToRebuild() {
644    delete rebuild_word;
645    rebuild_word = new TWERD(*chopped_word);
646    SetupBoxWord();
647    auto word_len = box_word->length();
648    best_state.reserve(word_len);
649    correct_text.reserve(word_len);
650    for (unsigned i = 0; i < word_len; ++i) {
651      best_state.push_back(1);
652      correct_text.emplace_back("");
653    }
654  }
655  void WERD_RES::SetupBoxWord() {
656    delete box_word;
657    rebuild_word->ComputeBoundingBoxes();
658    box_word = tesseract::BoxWord::CopyFromNormalized(rebuild_word);
659    box_word->ClipToOriginalWord(denorm.block(), word);
660  }
661  void WERD_RES::SetScriptPositions() {
662    best_choice->SetScriptPositions(small_caps, chopped_word);
663  }
664  void WERD_RES::SetAllScriptPositions(tesseract::ScriptPos position) {
665    raw_choice->SetAllScriptPositions(position);
666    WERD_CHOICE_IT wc_it(&best_choices);
667    for (wc_it.mark_cycle_pt(); !wc_it.cycled_list(); wc_it.forward()) {
668      wc_it.data()->SetAllScriptPositions(position);
669    }
670  }
671  void WERD_RES::FakeClassifyWord(unsigned blob_count, BLOB_CHOICE **choices) {
672    ASSERT_HOST(box_word != nullptr);
673    ASSERT_HOST(blob_count == box_word->length());
674    ClearWordChoices();
675    ClearRatings();
676    ratings = new MATRIX(blob_count, 1);
677    for (unsigned c = 0; c < blob_count; ++c) {
678      auto *choice_list = new BLOB_CHOICE_LIST;
679      BLOB_CHOICE_IT choice_it(choice_list);
680      choice_it.add_after_then_move(choices[c]);
681      ratings->put(c, c, choice_list);
682    }
683    FakeWordFromRatings(TOP_CHOICE_PERM);
684    reject_map.initialise(blob_count);
685    best_state.clear();
686    best_state.resize(blob_count, 1);
687    done = true;
688  }
689  void WERD_RES::FakeWordFromRatings(PermuterType permuter) {
690    int num_blobs = ratings->dimension();
691    auto *word_choice = new WERD_CHOICE(uch_set, num_blobs);
692    word_choice->set_permuter(permuter);
693    for (int b = 0; b < num_blobs; ++b) {
694      UNICHAR_ID unichar_id = UNICHAR_SPACE;
695      float rating = WERD_CHOICE::kBadRating;
696      float certainty = -FLT_MAX;
697      BLOB_CHOICE_LIST *choices = ratings->get(b, b);
698      if (choices != nullptr && !choices->empty()) {
699        BLOB_CHOICE_IT bc_it(choices);
700        BLOB_CHOICE *choice = bc_it.data();
701        unichar_id = choice->unichar_id();
702        rating = choice->rating();
703        certainty = choice->certainty();
704      }
705      word_choice->append_unichar_id_space_allocated(unichar_id, 1, rating,
706                                                     certainty);
707    }
708    LogNewRawChoice(word_choice);
709    LogNewCookedChoice(1, false, word_choice);
710  }
711  void WERD_RES::BestChoiceToCorrectText() {
712    correct_text.clear();
713    ASSERT_HOST(best_choice != nullptr);
714    for (unsigned i = 0; i < best_choice->length(); ++i) {
715      UNICHAR_ID choice_id = best_choice->unichar_id(i);
716      const char *blob_choice = uch_set->id_to_unichar(choice_id);
717      correct_text.emplace_back(blob_choice);
718    }
719  }
720  bool WERD_RES::ConditionalBlobMerge(
721      const std::function<UNICHAR_ID(UNICHAR_ID, UNICHAR_ID)> &class_cb,
722      const std::function<bool(const TBOX &, const TBOX &)> &box_cb) {
723    ASSERT_HOST(best_choice->empty() || ratings != nullptr);
724    bool modified = false;
725    for (unsigned i = 0; i + 1 < best_choice->length(); ++i) {
726      UNICHAR_ID new_id =
727          class_cb(best_choice->unichar_id(i), best_choice->unichar_id(i + 1));
728      if (new_id != INVALID_UNICHAR_ID &&
729          (box_cb == nullptr ||
730           box_cb(box_word->BlobBox(i), box_word->BlobBox(i + 1)))) {
731        best_choice->set_unichar_id(new_id, i);
732        modified = true;
733        MergeAdjacentBlobs(i);
734        const MATRIX_COORD &coord = best_choice->MatrixCoord(i);
735        if (!coord.Valid(*ratings)) {
736          ratings->IncreaseBandSize(coord.row + 1 - coord.col);
737        }
738        BLOB_CHOICE_LIST *blob_choices = GetBlobChoices(i);
739        if (FindMatchingChoice(new_id, blob_choices) == nullptr) {
740          auto *blob_choice = new BLOB_CHOICE;
741          blob_choice->set_unichar_id(new_id);
742          BLOB_CHOICE_IT bc_it(blob_choices);
743          bc_it.add_before_then_move(blob_choice);
744        }
745      }
746    }
747    return modified;
748  }
749  void WERD_RES::MergeAdjacentBlobs(unsigned index) {
750    if (reject_map.length() == best_choice->length()) {
751      reject_map.remove_pos(index);
752    }
753    best_choice->remove_unichar_id(index + 1);
754    rebuild_word->MergeBlobs(index, index + 2);
755    box_word->MergeBoxes(index, index + 2);
756    if (index + 1 < best_state.size()) {
757      best_state[index] += best_state[index + 1];
758      best_state.erase(best_state.begin() + index + 1);
759    }
760  }
761  static int is_simple_quote(const char *signed_str, int length) {
762    const auto *str = reinterpret_cast<const unsigned char *>(signed_str);
763    return (length == 1 && (*str == '\'' || *str == '`')) ||
764           (length == 3 &&
765            ((*str == 0xe2 && *(str + 1) == 0x80 && *(str + 2) == 0x98) ||
766             (*str == 0xe2 && *(str + 1) == 0x80 && *(str + 2) == 0x99)));
767  }
768  UNICHAR_ID WERD_RES::BothQuotes(UNICHAR_ID id1, UNICHAR_ID id2) {
769    const char *ch = uch_set->id_to_unichar(id1);
770    const char *next_ch = uch_set->id_to_unichar(id2);
771    if (is_simple_quote(ch, strlen(ch)) &&
772        is_simple_quote(next_ch, strlen(next_ch))) {
773      return uch_set->unichar_to_id("\"");
774    }
775    return INVALID_UNICHAR_ID;
776  }
777  void WERD_RES::fix_quotes() {
778    if (!uch_set->contains_unichar("\"") ||
779        !uch_set->get_enabled(uch_set->unichar_to_id("\""))) {
780      return; 
781    }
782    using namespace std::placeholders; 
783    ConditionalBlobMerge(std::bind(&WERD_RES::BothQuotes, this, _1, _2), nullptr);
784  }
785  UNICHAR_ID WERD_RES::BothHyphens(UNICHAR_ID id1, UNICHAR_ID id2) {
786    const char *ch = uch_set->id_to_unichar(id1);
787    const char *next_ch = uch_set->id_to_unichar(id2);
788    if (strlen(ch) == 1 && strlen(next_ch) == 1 && (*ch == '-' || *ch == '~') &&
789        (*next_ch == '-' || *next_ch == '~')) {
790      return uch_set->unichar_to_id("-");
791    }
792    return INVALID_UNICHAR_ID;
793  }
794  bool WERD_RES::HyphenBoxesOverlap(const TBOX &box1, const TBOX &box2) {
795    return box1.right() >= box2.left();
796  }
797  void WERD_RES::fix_hyphens() {
798    if (!uch_set->contains_unichar("-") ||
799        !uch_set->get_enabled(uch_set->unichar_to_id("-"))) {
800      return; 
801    }
802    using namespace std::placeholders; 
803    ConditionalBlobMerge(std::bind(&WERD_RES::BothHyphens, this, _1, _2),
804                         std::bind(&WERD_RES::HyphenBoxesOverlap, this, _1, _2));
805  }
806  UNICHAR_ID WERD_RES::BothSpaces(UNICHAR_ID id1, UNICHAR_ID id2) {
807    if (id1 == id2 && id1 == uch_set->unichar_to_id(" ")) {
808      return id1;
809    } else {
810      return INVALID_UNICHAR_ID;
811    }
812  }
813  void WERD_RES::merge_tess_fails() {
814    using namespace std::placeholders; 
815    if (ConditionalBlobMerge(std::bind(&WERD_RES::BothSpaces, this, _1, _2),
816                             nullptr)) {
817      unsigned len = best_choice->length();
818      ASSERT_HOST(reject_map.length() == len);
819      ASSERT_HOST(box_word->length() == len);
820    }
821  }
822  bool WERD_RES::PiecesAllNatural(int start, int count) const {
823    for (int index = start; index < start + count - 1; ++index) {
824      if (index >= 0 && static_cast<size_t>(index) < seam_array.size()) {
825        SEAM *seam = seam_array[index];
826        if (seam != nullptr && seam->HasAnySplits()) {
827          return false;
828        }
829      }
830    }
831    return true;
832  }
833  WERD_RES::~WERD_RES() {
834    Clear();
835  }
836  void WERD_RES::Clear() {
837    if (combination) {
838      delete word;
839    }
840    word = nullptr;
841    delete blamer_bundle;
842    blamer_bundle = nullptr;
843    ClearResults();
844  }
845  void WERD_RES::ClearResults() {
846    done = false;
847    fontinfo = nullptr;
848    fontinfo2 = nullptr;
849    fontinfo_id_count = 0;
850    fontinfo_id2_count = 0;
851    delete bln_boxes;
852    bln_boxes = nullptr;
853    blob_row = nullptr;
854    delete chopped_word;
855    chopped_word = nullptr;
856    delete rebuild_word;
857    rebuild_word = nullptr;
858    delete box_word;
859    box_word = nullptr;
860    best_state.clear();
861    correct_text.clear();
862    for (auto data : seam_array) {
863      delete data;
864    }
865    seam_array.clear();
866    blob_widths.clear();
867    blob_gaps.clear();
868    ClearRatings();
869    ClearWordChoices();
870    if (blamer_bundle != nullptr) {
871      blamer_bundle->ClearResults();
872    }
873  }
874  void WERD_RES::ClearWordChoices() {
875    best_choice = nullptr;
876    delete raw_choice;
877    raw_choice = nullptr;
878    best_choices.clear();
879    delete ep_choice;
880    ep_choice = nullptr;
881  }
882  void WERD_RES::ClearRatings() {
883    if (ratings != nullptr) {
884      ratings->delete_matrix_pointers();
885      delete ratings;
886      ratings = nullptr;
887    }
888  }
889  int PAGE_RES_IT::cmp(const PAGE_RES_IT &other) const {
890    ASSERT_HOST(page_res == other.page_res);
891    if (other.block_res == nullptr) {
892      if (block_res == nullptr) {
893        return 0;
894      }
895      return -1;
896    }
897    if (block_res == nullptr) {
898      return 1; 
899    }
900    if (block_res == other.block_res) {
901      if (other.row_res == nullptr || row_res == nullptr) {
902        return 0;
903      }
904      if (row_res == other.row_res) {
905        ASSERT_HOST(other.word_res != nullptr && word_res != nullptr);
906        if (word_res == other.word_res) {
907          return 0;
908        }
909        WERD_RES_IT word_res_it(&row_res->word_res_list);
910        for (word_res_it.mark_cycle_pt(); !word_res_it.cycled_list();
911             word_res_it.forward()) {
912          if (word_res_it.data() == word_res) {
913            return -1;
914          } else if (word_res_it.data() == other.word_res) {
915            return 1;
916          }
917        }
918        ASSERT_HOST("Error: Incomparable PAGE_RES_ITs" == nullptr);
919      }
920      ROW_RES_IT row_res_it(&block_res->row_res_list);
921      for (row_res_it.mark_cycle_pt(); !row_res_it.cycled_list();
922           row_res_it.forward()) {
923        if (row_res_it.data() == row_res) {
924          return -1;
925        } else if (row_res_it.data() == other.row_res) {
926          return 1;
927        }
928      }
929      ASSERT_HOST("Error: Incomparable PAGE_RES_ITs" == nullptr);
930    }
931    BLOCK_RES_IT block_res_it(&page_res->block_res_list);
932    for (block_res_it.mark_cycle_pt(); !block_res_it.cycled_list();
933         block_res_it.forward()) {
934      if (block_res_it.data() == block_res) {
935        return -1;
936      } else if (block_res_it.data() == other.block_res) {
937        return 1;
938      }
939    }
940    ASSERT_HOST("Error: Incomparable PAGE_RES_ITs" == nullptr);
941    return 0;
942  }
943  WERD_RES *PAGE_RES_IT::InsertSimpleCloneWord(const WERD_RES &clone_res,
944                                               WERD *new_word) {
945    auto *new_res = new WERD_RES(new_word);
946    new_res->CopySimpleFields(clone_res);
947    new_res->combination = true;
948    WERD_RES_IT wr_it(&row()->word_res_list);
949    for (wr_it.mark_cycle_pt(); !wr_it.cycled_list(); wr_it.forward()) {
950      WERD_RES *word = wr_it.data();
951      if (word == word_res) {
952        break;
953      }
954    }
955    ASSERT_HOST(!wr_it.cycled_list());
956    wr_it.add_before_then_move(new_res);
957    if (wr_it.at_first()) {
958      ResetWordIterator();
959    }
960    return new_res;
961  }
962  static void ComputeBlobEnds(const WERD_RES &word, const TBOX &clip_box,
963                              C_BLOB_LIST *next_word_blobs,
964                              std::vector<int> *blob_ends) {
965    C_BLOB_IT blob_it(word.word->cblob_list());
966    for (int length : word.best_state) {
967      TBOX blob_box = blob_it.data()->bounding_box();
968      blob_it.forward();
969      for (int b = 1; b < length; ++b) {
970        blob_box += blob_it.data()->bounding_box();
971        blob_it.forward();
972      }
973      int blob_end = INT32_MAX;
974      if (!blob_it.at_first() || next_word_blobs != nullptr) {
975        if (blob_it.at_first()) {
976          blob_it.set_to_list(next_word_blobs);
977        }
978        blob_end = (blob_box.right() + blob_it.data()->bounding_box().left()) / 2;
979      }
980      blob_end = ClipToRange<int>(blob_end, clip_box.left(), clip_box.right());
981      blob_ends->push_back(blob_end);
982    }
983    blob_ends->back() = clip_box.right();
984  }
985  static TBOX ComputeWordBounds(const tesseract::PointerVector<WERD_RES> &words,
986                                int w_index, TBOX prev_box, WERD_RES_IT w_it) {
987    constexpr int kSignificantOverlapFraction = 4;
988    TBOX clipped_box;
989    TBOX current_box = words[w_index]->word->bounding_box();
990    TBOX next_box;
991    if (static_cast<size_t>(w_index + 1) < words.size() &&
992        words[w_index + 1] != nullptr && words[w_index + 1]->word != nullptr) {
993      next_box = words[w_index + 1]->word->bounding_box();
994    }
995    for (w_it.forward(); !w_it.at_first() && w_it.data()->part_of_combo;
996         w_it.forward()) {
997      if (w_it.data() == nullptr || w_it.data()->word == nullptr) {
998        continue;
999      }
1000      TBOX w_box = w_it.data()->word->bounding_box();
1001      int height_limit = std::min<int>(w_box.height(), w_box.width() / 2);
1002      int width_limit = w_box.width() / kSignificantOverlapFraction;
1003      int min_significant_overlap = std::max(height_limit, width_limit);
1004      int overlap = w_box.intersection(current_box).width();
1005      int prev_overlap = w_box.intersection(prev_box).width();
1006      int next_overlap = w_box.intersection(next_box).width();
1007      if (overlap > min_significant_overlap) {
1008        if (prev_overlap > min_significant_overlap) {
1009          clipped_box.set_left(current_box.left());
1010        } else if (next_overlap > min_significant_overlap) {
1011          clipped_box.set_right(current_box.right());
1012        } else {
1013          clipped_box += w_box;
1014        }
1015      }
1016    }
1017    if (clipped_box.height() <= 0) {
1018      clipped_box.set_top(current_box.top());
1019      clipped_box.set_bottom(current_box.bottom());
1020    }
1021    if (clipped_box.width() <= 0) {
1022      clipped_box = current_box;
1023    }
1024    return clipped_box;
1025  }
1026  static TBOX MoveAndClipBlob(C_BLOB_IT *src_it, C_BLOB_IT *dest_it,
1027                              const TBOX &clip_box) {
1028    C_BLOB *src_blob = src_it->extract();
1029    TBOX box = src_blob->bounding_box();
1030    if (!clip_box.contains(box)) {
1031      int left =
1032          ClipToRange<int>(box.left(), clip_box.left(), clip_box.right() - 1);
1033      int right =
1034          ClipToRange<int>(box.right(), clip_box.left() + 1, clip_box.right());
1035      int top =
1036          ClipToRange<int>(box.top(), clip_box.bottom() + 1, clip_box.top());
1037      int bottom =
1038          ClipToRange<int>(box.bottom(), clip_box.bottom(), clip_box.top() - 1);
1039      box = TBOX(left, bottom, right, top);
1040      delete src_blob;
1041      src_blob = C_BLOB::FakeBlob(box);
1042    }
1043    dest_it->add_after_then_move(src_blob);
1044    return box;
1045  }
1046  void PAGE_RES_IT::ReplaceCurrentWord(
1047      tesseract::PointerVector<WERD_RES> *words) {
1048    if (words->empty()) {
1049      DeleteCurrentWord();
1050      return;
1051    }
1052    WERD_RES *input_word = word();
1053    if (input_word->word->flag(W_BOL)) {
1054      (*words)[0]->word->set_flag(W_BOL, true);
1055    } else {
1056      (*words)[0]->word->set_blanks(input_word->word->space());
1057    }
1058    words->back()->word->set_flag(W_EOL, input_word->word->flag(W_EOL));
1059    WERD_IT w_it(row()->row->word_list());
1060    if (!input_word->combination) {
1061      for (w_it.mark_cycle_pt(); !w_it.cycled_list(); w_it.forward()) {
1062        WERD *word = w_it.data();
1063        if (word == input_word->word) {
1064          break;
1065        }
1066      }
1067      ASSERT_HOST(!w_it.cycled_list());
1068    }
1069    WERD_RES_IT wr_it(&row()->word_res_list);
1070    for (wr_it.mark_cycle_pt(); !wr_it.cycled_list(); wr_it.forward()) {
1071      WERD_RES *word = wr_it.data();
1072      if (word == input_word) {
1073        break;
1074      }
1075    }
1076    ASSERT_HOST(!wr_it.cycled_list());
1077    C_BLOB_IT src_b_it(input_word->word->cblob_list());
1078    src_b_it.sort(&C_BLOB::SortByXMiddle);
1079    C_BLOB_IT rej_b_it(input_word->word->rej_cblob_list());
1080    rej_b_it.sort(&C_BLOB::SortByXMiddle);
1081    TBOX clip_box;
1082    for (size_t w = 0; w < words->size(); ++w) {
1083      WERD_RES *word_w = (*words)[w];
1084      clip_box = ComputeWordBounds(*words, w, clip_box, wr_it_of_current_word);
1085      std::vector<int> blob_ends;
1086      C_BLOB_LIST *next_word_blobs =
1087          w + 1 < words->size() ? (*words)[w + 1]->word->cblob_list() : nullptr;
1088      ComputeBlobEnds(*word_w, clip_box, next_word_blobs, &blob_ends);
1089      C_BLOB_LIST fake_blobs;
1090      C_BLOB_IT fake_b_it(&fake_blobs);
1091      fake_b_it.add_list_after(word_w->word->cblob_list());
1092      fake_b_it.move_to_first();
1093      word_w->word->cblob_list()->clear();
1094      C_BLOB_IT dest_it(word_w->word->cblob_list());
1095      auto *box_word = new tesseract::BoxWord;
1096      for (size_t i = 0; i < blob_ends.size(); ++i, fake_b_it.forward()) {
1097        int end_x = blob_ends[i];
1098        TBOX blob_box;
1099        while (!src_b_it.empty() &&
1100               src_b_it.data()->bounding_box().x_middle() < end_x) {
1101          blob_box += MoveAndClipBlob(&src_b_it, &dest_it, clip_box);
1102          src_b_it.forward();
1103        }
1104        while (!rej_b_it.empty() &&
1105               rej_b_it.data()->bounding_box().x_middle() < end_x) {
1106          blob_box += MoveAndClipBlob(&rej_b_it, &dest_it, clip_box);
1107          rej_b_it.forward();
1108        }
1109        if (blob_box.null_box()) {
1110          blob_box = MoveAndClipBlob(&fake_b_it, &dest_it, clip_box);
1111        }
1112        box_word->InsertBox(i, blob_box);
1113      }
1114      delete word_w->box_word;
1115      word_w->box_word = box_word;
1116      if (!input_word->combination) {
1117        w_it.add_before_stay_put(word_w->word);
1118        word_w->combination = false;
1119      }
1120      (*words)[w] = nullptr; 
1121      wr_it.add_before_stay_put(word_w);
1122    }
1123    words->clear();
1124    if (!input_word->combination) {
1125      delete w_it.extract();
1126    }
1127    delete wr_it.extract();
1128    ResetWordIterator();
1129  }
1130  void PAGE_RES_IT::DeleteCurrentWord() {
1131    ASSERT_HOST(!word_res->part_of_combo);
1132    if (!word_res->combination) {
1133      WERD_IT w_it(row()->row->word_list());
1134      for (w_it.mark_cycle_pt(); !w_it.cycled_list(); w_it.forward()) {
1135        if (w_it.data() == word_res->word) {
1136          break;
1137        }
1138      }
1139      ASSERT_HOST(!w_it.cycled_list());
1140      delete w_it.extract();
1141    }
1142    WERD_RES_IT wr_it(&row()->word_res_list);
1143    for (wr_it.mark_cycle_pt(); !wr_it.cycled_list(); wr_it.forward()) {
1144      if (wr_it.data() == word_res) {
1145        word_res = nullptr;
1146        break;
1147      }
1148    }
1149    ASSERT_HOST(!wr_it.cycled_list());
1150    delete wr_it.extract();
1151    ResetWordIterator();
1152  }
1153  void PAGE_RES_IT::MakeCurrentWordFuzzy() {
1154    WERD *real_word = word_res->word;
1155    if (!real_word->flag(W_FUZZY_SP) && !real_word->flag(W_FUZZY_NON)) {
1156      real_word->set_flag(W_FUZZY_SP, true);
1157      if (word_res->combination) {
1158        WERD_RES_IT wr_it(&row()->word_res_list);
1159        for (wr_it.mark_cycle_pt();
1160             !wr_it.cycled_list() && wr_it.data() != word_res; wr_it.forward()) {
1161        }
1162        wr_it.forward();
1163        ASSERT_HOST(wr_it.data()->part_of_combo);
1164        real_word = wr_it.data()->word;
1165        ASSERT_HOST(!real_word->flag(W_FUZZY_SP) &&
1166                    !real_word->flag(W_FUZZY_NON));
1167        real_word->set_flag(W_FUZZY_SP, true);
1168      }
1169    }
1170  }
1171  WERD_RES *PAGE_RES_IT::start_page(bool empty_ok) {
1172    block_res_it.set_to_list(&page_res->block_res_list);
1173    block_res_it.mark_cycle_pt();
1174    prev_block_res = nullptr;
1175    prev_row_res = nullptr;
1176    prev_word_res = nullptr;
1177    block_res = nullptr;
1178    row_res = nullptr;
1179    word_res = nullptr;
1180    next_block_res = nullptr;
1181    next_row_res = nullptr;
1182    next_word_res = nullptr;
1183    internal_forward(true, empty_ok);
1184    return internal_forward(false, empty_ok);
1185  }
1186  void PAGE_RES_IT::ResetWordIterator() {
1187    if (row_res == next_row_res) {
1188      word_res_it.move_to_first();
1189      for (word_res_it.mark_cycle_pt();
1190           !word_res_it.cycled_list() && word_res_it.data() != next_word_res;
1191           word_res_it.forward()) {
1192        if (!word_res_it.data()->part_of_combo) {
1193          if (prev_row_res == row_res) {
1194            prev_word_res = word_res;
1195          }
1196          word_res = word_res_it.data();
1197        }
1198      }
1199      ASSERT_HOST(!word_res_it.cycled_list());
1200      wr_it_of_next_word = word_res_it;
1201      word_res_it.forward();
1202    } else {
1203      WERD_RES_IT wr_it(&row_res->word_res_list);
1204      for (wr_it.mark_cycle_pt(); !wr_it.cycled_list(); wr_it.forward()) {
1205        if (!wr_it.data()->part_of_combo) {
1206          if (prev_row_res == row_res) {
1207            prev_word_res = word_res;
1208          }
1209          word_res = wr_it.data();
1210        }
1211      }
1212    }
1213  }
1214  WERD_RES *PAGE_RES_IT::internal_forward(bool new_block, bool empty_ok) {
1215    bool new_row = false;
1216    prev_block_res = block_res;
1217    prev_row_res = row_res;
1218    prev_word_res = word_res;
1219    block_res = next_block_res;
1220    row_res = next_row_res;
1221    word_res = next_word_res;
1222    wr_it_of_current_word = wr_it_of_next_word;
1223    next_block_res = nullptr;
1224    next_row_res = nullptr;
1225    next_word_res = nullptr;
1226    while (!block_res_it.cycled_list()) {
1227      if (new_block) {
1228        new_block = false;
1229        row_res_it.set_to_list(&block_res_it.data()->row_res_list);
1230        row_res_it.mark_cycle_pt();
1231        if (row_res_it.empty() && empty_ok) {
1232          next_block_res = block_res_it.data();
1233          break;
1234        }
1235        new_row = true;
1236      }
1237      while (!row_res_it.cycled_list()) {
1238        if (new_row) {
1239          new_row = false;
1240          word_res_it.set_to_list(&row_res_it.data()->word_res_list);
1241          word_res_it.mark_cycle_pt();
1242        }
1243        while (!word_res_it.cycled_list() && word_res_it.data()->part_of_combo) {
1244          word_res_it.forward();
1245        }
1246        if (!word_res_it.cycled_list()) {
1247          next_block_res = block_res_it.data();
1248          next_row_res = row_res_it.data();
1249          next_word_res = word_res_it.data();
1250          wr_it_of_next_word = word_res_it;
1251          word_res_it.forward();
1252          goto foundword;
1253        }
1254        row_res_it.forward();
1255        new_row = true;
1256      }
1257      block_res_it.forward();
1258      new_block = true;
1259    }
1260  foundword:
1261    if (page_res != nullptr && page_res->prev_word_best_choice != nullptr) {
1262      *page_res->prev_word_best_choice = (new_block || prev_word_res == nullptr)
1263                                             ? nullptr
1264                                             : prev_word_res->best_choice;
1265    }
1266    return word_res;
1267  }
1268  WERD_RES *PAGE_RES_IT::restart_row() {
1269    ROW_RES *row = this->row();
1270    if (!row) {
1271      return nullptr;
1272    }
1273    for (restart_page(); this->row() != row; forward()) {
1274    }
1275    return word();
1276  }
1277  WERD_RES *PAGE_RES_IT::forward_paragraph() {
1278    while (block_res == next_block_res &&
1279           (next_row_res != nullptr && next_row_res->row != nullptr &&
1280            row_res->row->para() == next_row_res->row->para())) {
1281      internal_forward(false, true);
1282    }
1283    return internal_forward(false, true);
1284  }
1285  WERD_RES *PAGE_RES_IT::forward_block() {
1286    while (block_res == next_block_res) {
1287      internal_forward(false, true);
1288    }
1289    return internal_forward(false, true);
1290  }
1291  void PAGE_RES_IT::rej_stat_word() {
1292    int16_t chars_in_word;
1293    int16_t rejects_in_word = 0;
1294    chars_in_word = word_res->reject_map.length();
1295    page_res->char_count += chars_in_word;
1296    block_res->char_count += chars_in_word;
1297    row_res->char_count += chars_in_word;
1298    rejects_in_word = word_res->reject_map.reject_count();
1299    page_res->rej_count += rejects_in_word;
1300    block_res->rej_count += rejects_in_word;
1301    row_res->rej_count += rejects_in_word;
1302    if (chars_in_word == rejects_in_word) {
1303      row_res->whole_word_rej_count += rejects_in_word;
1304    }
1305  }
1306  } 
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-colpartitionset.cpp</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #  include "config_auto.h"
3  #endif
4  #include "colpartitionset.h"
5  #include "tablefind.h"
6  #include "workingpartset.h"
7  namespace tesseract {
8  const double kMinColumnWidth = 2.0 / 3;
9  ColPartitionSet::ColPartitionSet(ColPartition_LIST *partitions) {
10    ColPartition_IT it(&parts_);
11    it.add_list_after(partitions);
12    ComputeCoverage();
13  }
14  ColPartitionSet::ColPartitionSet(ColPartition *part) {
15    ColPartition_IT it(&parts_);
16    it.add_after_then_move(part);
17    ComputeCoverage();
18  }
19  int ColPartitionSet::GoodColumnCount() const {
20    int num_good_cols = 0;
21    ColPartition_IT it(const_cast<ColPartition_LIST *>(&parts_));
22    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
23      if (it.data()->good_width()) {
24        ++num_good_cols;
25      }
26    }
27    return num_good_cols;
28  }
29  ColPartition *ColPartitionSet::GetColumnByIndex(int index) {
30    ColPartition_IT it(&parts_);
31    it.mark_cycle_pt();
32    for (int i = 0; i < index && !it.cycled_list(); ++i, it.forward()) {
33      ;
34    }
35    if (it.cycled_list()) {
36      return nullptr;
37    }
38    return it.data();
39  }
40  ColPartition *ColPartitionSet::ColumnContaining(int x, int y) {
41    ColPartition_IT it(&parts_);
42    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
43      ColPartition *part = it.data();
44      if (part->ColumnContains(x, y)) {
45        return part;
46      }
47    }
48    return nullptr;
49  }
50  void ColPartitionSet::RelinquishParts() {
51    ColPartition_IT it(&parts_);
52    while (!it.empty()) {
53      it.extract();
54      it.forward();
55    }
56  }
57  void ColPartitionSet::ImproveColumnCandidate(const WidthCallback &cb,
58                                               PartSetVector *src_sets) {
59    int set_size = src_sets->size();
60    for (int i = 0; i < set_size; ++i) {
61      ColPartitionSet *column_set = src_sets->at(i);
62      if (column_set == nullptr) {
63        continue;
64      }
65      ColPartition_IT part_it(&parts_);
66      ASSERT_HOST(!part_it.empty());
67      int prev_right = INT32_MIN;
68      part_it.mark_cycle_pt();
69      ColPartition_IT col_it(&column_set->parts_);
70      for (col_it.mark_cycle_pt(); !col_it.cycled_list(); col_it.forward()) {
71        ColPartition *col_part = col_it.data();
72        if (col_part->blob_type() < BRT_UNKNOWN) {
73          continue; 
74        }
75        int col_left = col_part->left_key();
76        int col_right = col_part->right_key();
77        ColPartition *part = part_it.data();
78        while (!part_it.at_last() && part->right_key() < col_left) {
79          prev_right = part->right_key();
80          part_it.forward();
81          part = part_it.data();
82        }
83        int part_left = part->left_key();
84        int part_right = part->right_key();
85        if (part_right < col_left || col_right < part_left) {
86          AddPartition(col_part->ShallowCopy(), &part_it);
87          continue;
88        }
89        bool part_width_ok = cb(part->KeyWidth(part_left, part_right));
90        if (col_left < part_left && col_left > prev_right) {
91          int col_box_left = col_part->BoxLeftKey();
92          bool tab_width_ok = cb(part->KeyWidth(col_left, part_right));
93          bool box_width_ok = cb(part->KeyWidth(col_box_left, part_right));
94          if (tab_width_ok || (!part_width_ok)) {
95            part->CopyLeftTab(*col_part, false);
96            part->SetColumnGoodness(cb);
97          } else if (col_box_left < part_left &&
98                     (box_width_ok || !part_width_ok)) {
99            part->CopyLeftTab(*col_part, true);
100            part->SetColumnGoodness(cb);
101          }
102          part_left = part->left_key();
103        }
104        if (col_right > part_right &&
105            (part_it.at_last() ||
106             part_it.data_relative(1)->left_key() > col_right)) {
107          int col_box_right = col_part->BoxRightKey();
108          bool tab_width_ok = cb(part->KeyWidth(part_left, col_right));
109          bool box_width_ok = cb(part->KeyWidth(part_left, col_box_right));
110          if (tab_width_ok || (!part_width_ok)) {
111            part->CopyRightTab(*col_part, false);
112            part->SetColumnGoodness(cb);
113          } else if (col_box_right > part_right &&
114                     (box_width_ok || !part_width_ok)) {
115            part->CopyRightTab(*col_part, true);
116            part->SetColumnGoodness(cb);
117          }
118        }
119      }
120    }
121    ComputeCoverage();
122  }
123  void ColPartitionSet::AddToColumnSetsIfUnique(PartSetVector *column_sets,
124                                                const WidthCallback &cb) {
125    bool debug = TabFind::WithinTestRegion(2, bounding_box_.left(),
126                                           bounding_box_.bottom());
127    if (debug) {
128      tprintf("Considering new column candidate:\n");
129      Print();
130    }
131    if (!LegalColumnCandidate()) {
132      if (debug) {
133        tprintf("Not a legal column candidate:\n");
134        Print();
135      }
136      delete this;
137      return;
138    }
139    for (unsigned i = 0; i < column_sets->size(); ++i) {
140      ColPartitionSet *columns = column_sets->at(i);
141      bool better = good_coverage_ > columns->good_coverage_;
142      if (good_coverage_ == columns->good_coverage_) {
143        better = good_column_count_ > columns->good_column_count_;
144        if (good_column_count_ == columns->good_column_count_) {
145          better = bad_coverage_ > columns->bad_coverage_;
146        }
147      }
148      if (better) {
149        if (debug) {
150          tprintf("Good one\n");
151        }
152        column_sets->insert(column_sets->begin() + i, this);
153        return;
154      }
155      if (columns->CompatibleColumns(false, this, cb)) {
156        if (debug) {
157          tprintf("Duplicate\n");
158        }
159        delete this;
160        return; 
161      }
162    }
163    if (debug) {
164      tprintf("Added to end\n");
165    }
166    column_sets->push_back(this);
167  }
168  bool ColPartitionSet::CompatibleColumns(bool debug, ColPartitionSet *other,
169                                          const WidthCallback &cb) {
170    if (debug) {
171      tprintf("CompatibleColumns testing compatibility\n");
172      Print();
173      other->Print();
174    }
175    if (other->parts_.empty()) {
176      if (debug) {
177        tprintf("CompatibleColumns true due to empty other\n");
178      }
179      return true;
180    }
181    ColPartition_IT it(&other->parts_);
182    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
183      ColPartition *part = it.data();
184      if (part->blob_type() < BRT_UNKNOWN) {
185        if (debug) {
186          tprintf("CompatibleColumns ignoring image partition\n");
187          part->Print();
188        }
189        continue; 
190      }
191      int y = part->MidY();
192      int left = part->bounding_box().left();
193      int right = part->bounding_box().right();
194      ColPartition *left_col = ColumnContaining(left, y);
195      ColPartition *right_col = ColumnContaining(right, y);
196      if (right_col == nullptr || left_col == nullptr) {
197        if (debug) {
198          tprintf("CompatibleColumns false due to partition edge outside\n");
199          part->Print();
200        }
201        return false; 
202      }
203      if (right_col != left_col && cb(right - left)) {
204        if (debug) {
205          tprintf("CompatibleColumns false due to good width in multiple cols\n");
206          part->Print();
207        }
208        return false; 
209      }
210      ColPartition_IT it2 = it;
211      while (!it2.at_last()) {
212        it2.forward();
213        ColPartition *next_part = it2.data();
214        if (!BLOBNBOX::IsTextType(next_part->blob_type())) {
215          continue; 
216        }
217        int next_left = next_part->bounding_box().left();
218        if (next_left == right) {
219          break; 
220        }
221        ColPartition *next_left_col = ColumnContaining(next_left, y);
222        if (right_col == next_left_col) {
223          if (part->good_width() && next_part->good_width()) {
224            if (debug) {
225              int next_right = next_part->bounding_box().right();
226              tprintf("CompatibleColumns false due to 2 parts of good width\n");
227              tprintf("part1 %d-%d, part2 %d-%d\n", left, right, next_left,
228                      next_right);
229              right_col->Print();
230            }
231            return false;
232          }
233        }
234        break;
235      }
236    }
237    if (debug) {
238      tprintf("CompatibleColumns true!\n");
239    }
240    return true;
241  }
242  int ColPartitionSet::UnmatchedWidth(ColPartitionSet *part_set) {
243    int total_width = 0;
244    ColPartition_IT it(&part_set->parts_);
245    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
246      ColPartition *part = it.data();
247      if (!BLOBNBOX::IsTextType(part->blob_type())) {
248        continue; 
249      }
250      int y = part->MidY();
251      BLOBNBOX_C_IT box_it(part->boxes());
252      for (box_it.mark_cycle_pt(); !box_it.cycled_list(); box_it.forward()) {
253        const TBOX &box = it.data()->bounding_box();
254        int x = (box.left() + box.right()) / 2;
255        ColPartition *col = ColumnContaining(x, y);
256        if (col == nullptr) {
257          total_width += box.width();
258        }
259      }
260    }
261    return total_width;
262  }
263  bool ColPartitionSet::LegalColumnCandidate() {
264    ColPartition_IT it(&parts_);
265    if (it.empty()) {
266      return false;
267    }
268    bool any_text_parts = false;
269    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
270      ColPartition *part = it.data();
271      if (BLOBNBOX::IsTextType(part->blob_type())) {
272        if (!part->IsLegal()) {
273          return false; 
274        }
275        any_text_parts = true;
276      }
277      if (!it.at_last()) {
278        ColPartition *next_part = it.data_relative(1);
279        if (next_part->left_key() < part->right_key()) {
280          return false;
281        }
282      }
283    }
284    return any_text_parts;
285  }
286  ColPartitionSet *ColPartitionSet::Copy(bool good_only) {
287    ColPartition_LIST copy_parts;
288    ColPartition_IT src_it(&parts_);
289    ColPartition_IT dest_it(&copy_parts);
290    for (src_it.mark_cycle_pt(); !src_it.cycled_list(); src_it.forward()) {
291      ColPartition *part = src_it.data();
292      if (BLOBNBOX::IsTextType(part->blob_type()) &&
293          (!good_only || part->good_width() || part->good_column())) {
294        dest_it.add_after_then_move(part->ShallowCopy());
295      }
296    }
297    if (dest_it.empty()) {
298      return nullptr;
299    }
300    return new ColPartitionSet(&copy_parts);
301  }
302  void ColPartitionSet::GetColumnBoxes(int y_bottom, int y_top,
303                                       ColSegment_LIST *segments) {
304    ColPartition_IT it(&parts_);
305    ColSegment_IT col_it(segments);
306    col_it.move_to_last();
307    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
308      ColPartition *part = it.data();
309      ICOORD bot_left(part->LeftAtY(y_top), y_bottom);
310      ICOORD top_right(part->RightAtY(y_bottom), y_top);
311      auto *col_seg = new ColSegment();
312      col_seg->InsertBox(TBOX(bot_left, top_right));
313      col_it.add_after_then_move(col_seg);
314    }
315  }
316  #ifndef GRAPHICS_DISABLED
317  void ColPartitionSet::DisplayColumnEdges(int y_bottom, int y_top,
318                                           ScrollView *win) {
319    ColPartition_IT it(&parts_);
320    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
321      ColPartition *part = it.data();
322      win->Line(part->LeftAtY(y_top), y_top, part->LeftAtY(y_bottom), y_bottom);
323      win->Line(part->RightAtY(y_top), y_top, part->RightAtY(y_bottom), y_bottom);
324    }
325  }
326  #endif 
327  ColumnSpanningType ColPartitionSet::SpanningType(
328      int resolution, int left, int right, int height, int y, int left_margin,
329      int right_margin, int *first_col, int *last_col, int *first_spanned_col) {
330    *first_col = -1;
331    *last_col = -1;
332    *first_spanned_col = -1;
333    int margin_columns = 0;
334    ColPartition_IT it(&parts_);
335    int col_index = 1;
336    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward(), col_index += 2) {
337      ColPartition *part = it.data();
338      if (part->ColumnContains(left, y) ||
339          (it.at_first() && part->ColumnContains(left + height, y))) {
340        *first_col = col_index;
341        if (part->ColumnContains(right, y) ||
342            (it.at_last() && part->ColumnContains(right - height, y))) {
343          *last_col = col_index;
344          return CST_FLOWING;
345        }
346        if (left_margin <= part->LeftAtY(y)) {
347          *first_spanned_col = col_index;
348          margin_columns = 1;
349        }
350      } else if (part->ColumnContains(right, y) ||
351                 (it.at_last() && part->ColumnContains(right - height, y))) {
352        if (*first_col < 0) {
353          *first_col = col_index - 1;
354        }
355        if (right_margin >= part->RightAtY(y)) {
356          if (margin_columns == 0) {
357            *first_spanned_col = col_index;
358          }
359          ++margin_columns;
360        }
361        *last_col = col_index;
362        break;
363      } else if (left < part->LeftAtY(y) && right > part->RightAtY(y)) {
364        if (*first_col < 0) {
365          *first_col = col_index - 1;
366        }
367        if (margin_columns == 0) {
368          *first_spanned_col = col_index;
369        }
370        *last_col = col_index;
371      } else if (right < part->LeftAtY(y)) {
372        *last_col = col_index - 1;
373        if (*first_col < 0) {
374          *first_col = col_index - 1;
375        }
376        break;
377      }
378    }
379    if (*first_col < 0) {
380      *first_col = col_index - 1; 
381    }
382    if (*last_col < 0) {
383      *last_col = col_index - 1; 
384    }
385    ASSERT_HOST(*first_col >= 0 && *last_col >= 0);
386    ASSERT_HOST(*first_col <= *last_col);
387    if (*first_col == *last_col && right - left < kMinColumnWidth * resolution) {
388      return CST_NOISE;
389    } else if (margin_columns <= 1) {
390      if (margin_columns == 1 && parts_.singleton()) {
391        return CST_HEADING;
392      }
393      return CST_PULLOUT;
394    }
395    return CST_HEADING;
396  }
397  void ColPartitionSet::ChangeWorkColumns(const ICOORD &bleft,
398                                          const ICOORD &tright, int resolution,
399                                          ColPartition_LIST *used_parts,
400                                          WorkingPartSet_LIST *working_set_list) {
401    WorkingPartSet_LIST work_src;
402    WorkingPartSet_IT src_it(&work_src);
403    src_it.add_list_after(working_set_list);
404    src_it.move_to_first();
405    WorkingPartSet_IT dest_it(working_set_list);
406    BLOCK_LIST completed_blocks;
407    TO_BLOCK_LIST to_blocks;
408    WorkingPartSet *first_new_set = nullptr;
409    WorkingPartSet *working_set = nullptr;
410    ColPartition_IT col_it(&parts_);
411    for (col_it.mark_cycle_pt(); !col_it.cycled_list(); col_it.forward()) {
412      ColPartition *column = col_it.data();
413      while (!src_it.empty() &&
414             ((working_set = src_it.data())->column() == nullptr ||
415              working_set->column()->right_key() <= column->left_key())) {
416        src_it.extract();
417        working_set->ExtractCompletedBlocks(bleft, tright, resolution, used_parts,
418                                            &completed_blocks, &to_blocks);
419        delete working_set;
420        src_it.forward();
421      }
422      working_set = new WorkingPartSet(nullptr);
423      dest_it.add_after_then_move(working_set);
424      if (first_new_set == nullptr) {
425        first_new_set = working_set;
426      }
427      working_set = src_it.empty() ? nullptr : src_it.data();
428      if (working_set != nullptr &&
429          working_set->column()->MatchingColumns(*column)) {
430        working_set->set_column(column);
431        dest_it.add_after_then_move(src_it.extract());
432        src_it.forward();
433        first_new_set->InsertCompletedBlocks(&completed_blocks, &to_blocks);
434        first_new_set = nullptr;
435      } else {
436        working_set = new WorkingPartSet(column);
437        dest_it.add_after_then_move(working_set);
438      }
439    }
440    while (!src_it.empty()) {
441      working_set = src_it.extract();
442      working_set->ExtractCompletedBlocks(bleft, tright, resolution, used_parts,
443                                          &completed_blocks, &to_blocks);
444      delete working_set;
445      src_it.forward();
446    }
447    working_set = new WorkingPartSet(nullptr);
448    dest_it.add_after_then_move(working_set);
449    if (first_new_set == nullptr) {
450      first_new_set = working_set;
451    }
452    first_new_set->InsertCompletedBlocks(&completed_blocks, &to_blocks);
453  }
454  void ColPartitionSet::AccumulateColumnWidthsAndGaps(int *total_width,
455                                                      int *width_samples,
456                                                      int *total_gap,
457                                                      int *gap_samples) {
458    ColPartition_IT it(&parts_);
459    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
460      ColPartition *part = it.data();
461      *total_width += part->ColumnWidth();
462      ++*width_samples;
463      if (!it.at_last()) {
464        ColPartition *next_part = it.data_relative(1);
465        int part_left = part->right_key();
466        int part_right = next_part->left_key();
467        int gap = part->KeyWidth(part_left, part_right);
468        *total_gap += gap;
469        ++*gap_samples;
470      }
471    }
472  }
473  void ColPartitionSet::Print() {
474    ColPartition_IT it(&parts_);
475    tprintf(
476        "Partition set of %d parts, %d good, coverage=%d+%d"
477        " (%d,%d)->(%d,%d)\n",
478        it.length(), good_column_count_, good_coverage_, bad_coverage_,
479        bounding_box_.left(), bounding_box_.bottom(), bounding_box_.right(),
480        bounding_box_.top());
481    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
482      ColPartition *part = it.data();
483      part->Print();
484    }
485  }
486  void ColPartitionSet::AddPartition(ColPartition *new_part,
487                                     ColPartition_IT *it) {
488    AddPartitionCoverageAndBox(*new_part);
489    int new_right = new_part->right_key();
490    if (it->data()->left_key() >= new_right) {
491      it->add_before_stay_put(new_part);
492    } else {
493      it->add_after_stay_put(new_part);
494    }
495  }
496  void ColPartitionSet::ComputeCoverage() {
<span onclick='openModal()' class='match'>497    ColPartition_IT it(&parts_);
498    good_column_count_ = 0;
499    good_coverage_ = 0;
500    bad_coverage_ = 0;
</span>501    bounding_box_ = TBOX();
502    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
503      ColPartition *part = it.data();
504      AddPartitionCoverageAndBox(*part);
505    }
506  }
507  void ColPartitionSet::AddPartitionCoverageAndBox(const ColPartition &part) {
508    bounding_box_ += part.bounding_box();
509    int coverage = part.ColumnWidth();
510    if (part.good_width()) {
511      good_coverage_ += coverage;
512      good_column_count_ += 2;
513    } else {
514      if (part.blob_type() < BRT_UNKNOWN) {
515        coverage /= 2;
516      }
517      if (part.good_column()) {
518        ++good_column_count_;
519      }
520      bad_coverage_ += coverage;
521    }
522  }
523  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-pageres.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-colpartitionset.cpp</div>
                </div>
                <div class="column column_space"><pre><code>42    ROW_RES_IT row_res_it(&row_res_list);
43    char_count = 0;
44    rej_count = 0;
45    font_class = -1; 
</pre></code></div>
                <div class="column column_space"><pre><code>497    ColPartition_IT it(&parts_);
498    good_column_count_ = 0;
499    good_coverage_ = 0;
500    bad_coverage_ = 0;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    