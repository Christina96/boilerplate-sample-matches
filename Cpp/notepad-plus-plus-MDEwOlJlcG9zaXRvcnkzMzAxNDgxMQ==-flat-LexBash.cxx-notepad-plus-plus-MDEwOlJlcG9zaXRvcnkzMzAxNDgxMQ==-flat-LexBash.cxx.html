
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 22, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexBash.cxx</h3>
            <pre><code>1  #include <cstdlib>
2  #include <cassert>
3  #include <cstring>
4  #include <cstdio>
5  #include <cstdarg>
6  #include <string>
7  #include <string_view>
8  #include <vector>
9  #include <map>
10  #include <functional>
11  #include "ILexer.h"
12  #include "Scintilla.h"
13  #include "SciLexer.h"
14  #include "StringCopy.h"
15  #include "WordList.h"
16  #include "LexAccessor.h"
17  #include "StyleContext.h"
18  #include "CharacterSet.h"
19  #include "LexerModule.h"
20  #include "OptionSet.h"
21  #include "SubStyles.h"
22  #include "DefaultLexer.h"
23  using namespace Scintilla;
24  using namespace Lexilla;
25  namespace {
26  #define HERE_DELIM_MAX			256
27  #undef PEDANTIC_OCTAL
28  #define BASH_BASE_ERROR			65
29  #define BASH_BASE_DECIMAL		66
30  #define BASH_BASE_HEX			67
31  #ifdef PEDANTIC_OCTAL
32  #define BASH_BASE_OCTAL			68
33  #define	BASH_BASE_OCTAL_ERROR	69
34  #endif
35  enum class CmdState {
36  	Body,
37  	Start,
38  	Word,
39  	Test,
40  	Arithmetic,
41  	Delimiter,
42  };
<span onclick='openModal()' class='match'>43  enum class TestExprType {
44  	Test,			
45  	DoubleBracket,	
46  	SingleBracket,	
47  };
48  enum class CommandSubstitution {
49  	Backtick,
50  	Inside,
51  	InsideTrack,
52  };
</span>53  enum class QuoteStyle {
54  	Literal,		
55  	CString,		
56  	String,			
57  	LString,		
58  	HereDoc,		
59  	Backtick,		
60  	Parameter,		
61  	Command,		
62  	CommandInside,	
63  	Arithmetic,		
64  };
65  #define BASH_QUOTE_STACK_MAX	7
66  constexpr int commandSubstitutionFlag = 0x40;
67  constexpr int MaskCommand(int state) noexcept {
68  	return state & ~commandSubstitutionFlag;
69  }
70  constexpr int translateBashDigit(int ch) noexcept {
71  	if (ch >= '0' && ch <= '9') {
72  		return ch - '0';
73  	} else if (ch >= 'a' && ch <= 'z') {
74  		return ch - 'a' + 10;
75  	} else if (ch >= 'A' && ch <= 'Z') {
76  		return ch - 'A' + 36;
77  	} else if (ch == '@') {
78  		return 62;
79  	} else if (ch == '_') {
80  		return 63;
81  	}
82  	return BASH_BASE_ERROR;
83  }
84  int getBashNumberBase(char *s) noexcept {
85  	int i = 0;
86  	int base = 0;
87  	while (*s) {
88  		base = base * 10 + (*s++ - '0');
89  		i++;
90  	}
91  	if (base > 64 || i > 2) {
92  		return BASH_BASE_ERROR;
93  	}
94  	return base;
95  }
96  constexpr int opposite(int ch) noexcept {
97  	if (ch == '(') return ')';
98  	if (ch == '[') return ']';
99  	if (ch == '{') return '}';
100  	if (ch == '<') return '>';
101  	return ch;
102  }
103  int GlobScan(StyleContext &sc) {
104  	int c = 0;
105  	int sLen = 0;
106  	int pCount = 0;
107  	int hash = 0;
108  	while ((c = sc.GetRelativeCharacter(++sLen)) != 0) {
109  		if (IsASpace(c)) {
110  			return 0;
111  		} else if (c == '\'' || c == '\"') {
112  			if (hash != 2) return 0;
113  		} else if (c == '#' && hash == 0) {
114  			hash = (sLen == 1) ? 2:1;
115  		} else if (c == '(') {
116  			pCount++;
117  		} else if (c == ')') {
118  			if (pCount == 0) {
119  				if (hash) return sLen;
120  				return 0;
121  			}
122  			pCount--;
123  		}
124  	}
125  	return 0;
126  }
127  bool IsCommentLine(Sci_Position line, LexAccessor &styler) {
128  	const Sci_Position pos = styler.LineStart(line);
129  	const Sci_Position eol_pos = styler.LineStart(line + 1) - 1;
130  	for (Sci_Position i = pos; i < eol_pos; i++) {
131  		const char ch = styler[i];
132  		if (ch == '#')
133  			return true;
134  		else if (ch != ' ' && ch != '\t')
135  			return false;
136  	}
137  	return false;
138  }
139  struct OptionsBash {
140  	bool fold = false;
141  	bool foldComment = false;
142  	bool foldCompact = true;
143  	bool stylingInsideString = false;
144  	bool stylingInsideBackticks = false;
145  	bool stylingInsideParameter = false;
146  	bool stylingInsideHeredoc = false;
147  	int commandSubstitution = static_cast<int>(CommandSubstitution::Backtick);
148  	[[nodiscard]] bool stylingInside(int state) const noexcept {
149  		switch (state) {
150  		case SCE_SH_STRING:
151  			return stylingInsideString;
152  		case SCE_SH_BACKTICKS:
153  			return stylingInsideBackticks;
154  		case SCE_SH_PARAM:
155  			return stylingInsideParameter;
156  		case SCE_SH_HERE_Q:
157  			return stylingInsideHeredoc;
158  		default:
159  			return false;
160  		}
161  	}
162  };
163  const char * const bashWordListDesc[] = {
164  	"Keywords",
165  	nullptr
166  };
167  struct OptionSetBash : public OptionSet<OptionsBash> {
168  	OptionSetBash() {
169  		DefineProperty("fold", &OptionsBash::fold);
170  		DefineProperty("fold.comment", &OptionsBash::foldComment);
171  		DefineProperty("fold.compact", &OptionsBash::foldCompact);
172  		DefineProperty("lexer.bash.styling.inside.string", &OptionsBash::stylingInsideString,
173  			"Set this property to 1 to highlight shell expansions inside string.");
174  		DefineProperty("lexer.bash.styling.inside.backticks", &OptionsBash::stylingInsideBackticks,
175  			"Set this property to 1 to highlight shell expansions inside backticks.");
176  		DefineProperty("lexer.bash.styling.inside.parameter", &OptionsBash::stylingInsideParameter,
177  			"Set this property to 1 to highlight shell expansions inside ${} parameter expansion.");
178  		DefineProperty("lexer.bash.styling.inside.heredoc", &OptionsBash::stylingInsideHeredoc,
179  			"Set this property to 1 to highlight shell expansions inside here document.");
180  		DefineProperty("lexer.bash.command.substitution", &OptionsBash::commandSubstitution,
181  			"Set how to highlight $() command substitution. "
182  			"0 (the default) highlighted as backticks. "
183  			"1 highlighted inside. "
184  			"2 highlighted inside with extra scope tracking.");
185  		DefineWordListSets(bashWordListDesc);
186  	}
187  };
188  class QuoteCls {	
189  public:
190  	int Count = 0;
191  	int Up = '\0';
192  	int Down = '\0';
193  	QuoteStyle Style = QuoteStyle::Literal;
194  	int Outer = SCE_SH_DEFAULT;
195  	void Clear() noexcept {
196  		Count = 0;
197  		Up	  = '\0';
198  		Down  = '\0';
199  		Style = QuoteStyle::Literal;
200  		Outer = SCE_SH_DEFAULT;
201  	}
202  	void Start(int u, QuoteStyle s, int outer) noexcept {
203  		Count = 1;
204  		Up    = u;
205  		Down  = opposite(Up);
206  		Style = s;
207  		Outer = outer;
208  	}
209  };
210  class QuoteStackCls {	
211  public:
212  	int Depth = 0;
213  	int State = SCE_SH_DEFAULT;
214  	CommandSubstitution commandSubstitution = CommandSubstitution::Backtick;
215  	int insideCommand = 0;
216  	QuoteCls Current;
217  	QuoteCls Stack[BASH_QUOTE_STACK_MAX];
218  	[[nodiscard]] bool Empty() const noexcept {
219  		return Current.Up == '\0';
220  	}
221  	void Start(int u, QuoteStyle s, int outer) noexcept {
222  		if (Empty()) {
223  			Current.Start(u, s, outer);
224  		} else {
225  			Push(u, s, outer);
226  		}
227  	}
228  	void Push(int u, QuoteStyle s, int outer) noexcept {
229  		if (Depth >= BASH_QUOTE_STACK_MAX) {
230  			return;
231  		}
232  		Stack[Depth] = Current;
233  		Depth++;
234  		Current.Start(u, s, outer);
235  	}
236  	void Pop() noexcept {
237  		if (Depth == 0) {
238  			Clear();
239  			return;
240  		}
241  		if (insideCommand != 0) {
242  			insideCommand = 0;
243  			for (int i = 0; i < Depth; i++) {
244  				if (Stack[i].Style == QuoteStyle::CommandInside) {
245  					insideCommand = commandSubstitutionFlag;
246  					break;
247  				}
248  			}
249  		}
250  		Depth--;
251  		Current = Stack[Depth];
252  	}
253  	void Clear() noexcept {
254  		Depth = 0;
255  		State = SCE_SH_DEFAULT;
256  		insideCommand = 0;
257  		Current.Clear();
258  	}
259  	bool CountDown(StyleContext &sc, CmdState &cmdState) {
260  		Current.Count--;
261  		if (Current.Count == 1 && sc.Match(')', ')')) {
262  			Current.Count--;
263  			sc.Forward();
264  		}
265  		if (Current.Count == 0) {
266  			cmdState = CmdState::Body;
267  			const int outer = Current.Outer;
268  			Pop();
269  			sc.ForwardSetState(outer | insideCommand);
270  			return true;
271  		}
272  		return false;
273  	}
274  	void Expand(StyleContext &sc, CmdState &cmdState, bool stylingInside) {
275  		const int state = sc.state;
276  		QuoteStyle style = QuoteStyle::Literal;
277  		State = state;
278  		sc.SetState(SCE_SH_SCALAR);
279  		sc.Forward();
280  		if (sc.ch == '{') {
281  			style = QuoteStyle::Parameter;
282  			sc.ChangeState(SCE_SH_PARAM);
283  		} else if (sc.ch == '\'') {
284  			style = QuoteStyle::CString;
285  			sc.ChangeState(SCE_SH_STRING);
286  		} else if (sc.ch == '"') {
287  			style = QuoteStyle::LString;
288  			sc.ChangeState(SCE_SH_STRING);
289  		} else if (sc.ch == '(' || sc.ch == '[') {
290  			if (sc.ch == '[' || sc.chNext == '(') {
291  				style = QuoteStyle::Arithmetic;
292  				cmdState = CmdState::Arithmetic;
293  				sc.ChangeState(SCE_SH_OPERATOR);
294  			} else {
295  				if (stylingInside && commandSubstitution >= CommandSubstitution::Inside) {
296  					style = QuoteStyle::CommandInside;
297  					cmdState = CmdState::Delimiter;
298  					sc.ChangeState(SCE_SH_OPERATOR);
299  					if (commandSubstitution == CommandSubstitution::InsideTrack) {
300  						insideCommand = commandSubstitutionFlag;
301  					}
302  				} else {
303  					style = QuoteStyle::Command;
304  					sc.ChangeState(SCE_SH_BACKTICKS);
305  				}
306  			}
307  			if (sc.Match('(', '(') && state == SCE_SH_DEFAULT && Depth == 0) {
308  				style = QuoteStyle::Literal;
309  			}
310  		} else if (sc.ch == '`') {	
311  			style = QuoteStyle::Backtick;
312  			sc.ChangeState(SCE_SH_BACKTICKS);
313  		} else {
314  		}
315  		if (!stylingInside) {
316  			sc.ChangeState(state);
317  		} else {
318  			sc.ChangeState(sc.state | insideCommand);
319  		}
320  		if (style != QuoteStyle::Literal) {
321  			Start(sc.ch, style, state);
322  			sc.Forward();
323  		}
324  	}
325  };
326  const char styleSubable[] = { SCE_SH_IDENTIFIER, SCE_SH_SCALAR, 0 };
327  const LexicalClass lexicalClasses[] = {
328  	0, "SCE_SH_DEFAULT", "default", "White space",
329  	1, "SCE_SH_ERROR", "error", "Error",
330  	2, "SCE_SH_COMMENTLINE", "comment line", "Line comment: #",
331  	3, "SCE_SH_NUMBER", "literal numeric", "Number",
332  	4, "SCE_SH_WORD", "keyword", "Keyword",
333  	5, "SCE_SH_STRING", "literal string", "String",
334  	6, "SCE_SH_CHARACTER", "literal string", "Single quoted string",
335  	7, "SCE_SH_OPERATOR", "operator", "Operators",
336  	8, "SCE_SH_IDENTIFIER", "identifier", "Identifiers",
337  	9, "SCE_SH_SCALAR", "identifier", "Scalar variable",
338  	10, "SCE_SH_PARAM", "identifier", "Parameter",
339  	11, "SCE_SH_BACKTICKS", "literal string", "Backtick quoted command",
340  	12, "SCE_SH_HERE_DELIM", "operator", "Heredoc delimiter",
341  	13, "SCE_SH_HERE_Q", "literal string", "Heredoc quoted string",
342  };
343  }
344  class LexerBash final : public DefaultLexer {
345  	WordList keywords;
346  	WordList cmdDelimiter;
347  	WordList bashStruct;
348  	WordList bashStruct_in;
349  	OptionsBash options;
350  	OptionSetBash osBash;
351  	enum { ssIdentifier, ssScalar };
352  	SubStyles subStyles;
353  public:
354  	LexerBash() :
355  		DefaultLexer("bash", SCLEX_BASH, lexicalClasses, ELEMENTS(lexicalClasses)),
356  		subStyles(styleSubable, 0x80, 0x40, 0) {
357  		cmdDelimiter.Set("| || |& & && ; ;; ( ) { }");
358  		bashStruct.Set("if elif fi while until else then do done esac eval");
359  		bashStruct_in.Set("for case select");
360  	}
361  	void SCI_METHOD Release() override {
362  		delete this;
363  	}
364  	int SCI_METHOD Version() const override {
365  		return lvRelease5;
366  	}
367  	const char * SCI_METHOD PropertyNames() override {
368  		return osBash.PropertyNames();
369  	}
370  	int SCI_METHOD PropertyType(const char* name) override {
371  		return osBash.PropertyType(name);
372  	}
373  	const char * SCI_METHOD DescribeProperty(const char *name) override {
374  		return osBash.DescribeProperty(name);
375  	}
376  	Sci_Position SCI_METHOD PropertySet(const char *key, const char *val) override;
377  	const char * SCI_METHOD PropertyGet(const char* key) override {
378  		return osBash.PropertyGet(key);
379  	}
380  	const char * SCI_METHOD DescribeWordListSets() override {
381  		return osBash.DescribeWordListSets();
382  	}
383  	Sci_Position SCI_METHOD WordListSet(int n, const char *wl) override;
384  	void SCI_METHOD Lex(Sci_PositionU startPos, Sci_Position length, int initStyle, IDocument *pAccess) override;
385  	void SCI_METHOD Fold(Sci_PositionU startPos, Sci_Position length, int initStyle, IDocument *pAccess) override;
386  	void * SCI_METHOD PrivateCall(int, void *) override {
387  		return nullptr;
388  	}
389  	int SCI_METHOD AllocateSubStyles(int styleBase, int numberStyles) override {
390  		return subStyles.Allocate(styleBase, numberStyles);
391  	}
392  	int SCI_METHOD SubStylesStart(int styleBase) override {
393  		return subStyles.Start(styleBase);
394  	}
395  	int SCI_METHOD SubStylesLength(int styleBase) override {
396  		return subStyles.Length(styleBase);
397  	}
398  	int SCI_METHOD StyleFromSubStyle(int subStyle) override {
399  		const int styleBase = subStyles.BaseStyle(subStyle);
400  		return styleBase;
401  	}
402  	int SCI_METHOD PrimaryStyleFromStyle(int style) override {
403  		return style;
404  	}
405  	void SCI_METHOD FreeSubStyles() override {
406  		subStyles.Free();
407  	}
408  	void SCI_METHOD SetIdentifiers(int style, const char *identifiers) override {
409  		subStyles.SetIdentifiers(style, identifiers);
410  	}
411  	int SCI_METHOD DistanceToSecondaryStyles() override {
412  		return 0;
413  	}
414  	const char *SCI_METHOD GetSubStyleBases() override {
415  		return styleSubable;
416  	}
417  	static ILexer5 *LexerFactoryBash() {
418  		return new LexerBash();
419  	}
420  };
421  Sci_Position SCI_METHOD LexerBash::PropertySet(const char *key, const char *val) {
422  	if (osBash.PropertySet(&options, key, val)) {
423  		return 0;
424  	}
425  	return -1;
426  }
427  Sci_Position SCI_METHOD LexerBash::WordListSet(int n, const char *wl) {
428  	WordList *wordListN = nullptr;
429  	switch (n) {
430  	case 0:
431  		wordListN = &keywords;
432  		break;
433  	}
434  	Sci_Position firstModification = -1;
435  	if (wordListN) {
436  		if (wordListN->Set(wl)) {
437  			firstModification = 0;
438  		}
439  	}
440  	return firstModification;
441  }
442  void SCI_METHOD LexerBash::Lex(Sci_PositionU startPos, Sci_Position length, int initStyle, IDocument *pAccess) {
443  	const CharacterSet setWordStart(CharacterSet::setAlpha, "_");
444  	const CharacterSet setWord(CharacterSet::setAlphaNum, "._+-");
445  	CharacterSet setMetaCharacter(CharacterSet::setNone, "|&;()<> \t\r\n");
446  	setMetaCharacter.Add(0);
447  	const CharacterSet setBashOperator(CharacterSet::setNone, "^&%()-+=|{}[]:;>,*/<?!.~@");
448  	const CharacterSet setSingleCharOp(CharacterSet::setNone, "rwxoRWXOezsfdlpSbctugkTBMACahGLNn");
449  	const CharacterSet setParam(CharacterSet::setAlphaNum, "_");
450  	const CharacterSet setHereDoc(CharacterSet::setAlpha, "_\\-+!%*,./:?@[]^`{}~");
451  	const CharacterSet setHereDoc2(CharacterSet::setAlphaNum, "_-+!%*,./:=?@[]^`{}~");
452  	const CharacterSet setLeftShift(CharacterSet::setDigits, "$");
453  	class HereDocCls {	
454  	public:
455  		int State = 0;			
456  		int Quote = '\0';		
457  		bool Quoted = false;		
458  		bool Escaped = false;		
459  		bool Indent = false;		
460  		int DelimiterLength = 0;	
461  		char Delimiter[HERE_DELIM_MAX]{};	
462  		HereDocCls() noexcept = default;
463  		void Append(int ch) {
464  			Delimiter[DelimiterLength++] = static_cast<char>(ch);
465  			Delimiter[DelimiterLength] = '\0';
466  		}
467  	};
468  	HereDocCls HereDoc;
469  	QuoteStackCls QuoteStack;
470  	QuoteStack.commandSubstitution = static_cast<CommandSubstitution>(options.commandSubstitution);
471  	const WordClassifier &classifierIdentifiers = subStyles.Classifier(SCE_SH_IDENTIFIER);
472  	const WordClassifier &classifierScalars = subStyles.Classifier(SCE_SH_SCALAR);
473  	int numBase = 0;
474  	int digit = 0;
475  	const Sci_PositionU endPos = startPos + length;
476  	CmdState cmdState = CmdState::Start;
477  	TestExprType testExprType = TestExprType::Test;
478  	LexAccessor styler(pAccess);
479  	Sci_Position ln = styler.GetLine(startPos);
480  	if (ln > 0 && startPos == static_cast<Sci_PositionU>(styler.LineStart(ln)))
481  		ln--;
482  	for (;;) {
483  		startPos = styler.LineStart(ln);
484  		if (ln == 0 || styler.GetLineState(ln) == static_cast<int>(CmdState::Start))
485  			break;
486  		ln--;
487  	}
488  	initStyle = SCE_SH_DEFAULT;
489  	StyleContext sc(startPos, endPos - startPos, initStyle, styler);
490  	while (sc.More()) {
491  		if (sc.atLineStart) {
492  			if (MaskCommand(sc.state) == SCE_SH_STRING
493  			 || MaskCommand(sc.state) == SCE_SH_BACKTICKS
494  			 || MaskCommand(sc.state) == SCE_SH_CHARACTER
495  			 || MaskCommand(sc.state) == SCE_SH_HERE_Q
496  			 || MaskCommand(sc.state) == SCE_SH_COMMENTLINE
497  			 || MaskCommand(sc.state) == SCE_SH_PARAM) {
498  				styler.SetLineState(sc.currentLine, static_cast<int>(CmdState::Body));
499  			} else {
500  				if (sc.currentLine > 0) {
501  					if ((sc.GetRelative(-3) == '\\' && sc.GetRelative(-2) == '\r' && sc.chPrev == '\n')
502  					 || sc.GetRelative(-2) == '\\') {	
503  					} else
504  						cmdState = CmdState::Start;
505  				}
506  				const CmdState state = QuoteStack.Empty() ? cmdState : CmdState::Body;
507  				styler.SetLineState(sc.currentLine, static_cast<int>(state));
508  			}
509  		}
510  		CmdState cmdStateNew = CmdState::Body;
511  		if (cmdState == CmdState::Test || cmdState == CmdState::Arithmetic || cmdState == CmdState::Word)
512  			cmdStateNew = cmdState;
513  		const int stylePrev = MaskCommand(sc.state);
514  		const int insideCommand = QuoteStack.insideCommand;
515  		switch (MaskCommand(sc.state)) {
516  			case SCE_SH_OPERATOR:
517  				sc.SetState(SCE_SH_DEFAULT | insideCommand);
518  				if (cmdState == CmdState::Delimiter)		
519  					cmdStateNew = CmdState::Start;
520  				else if (sc.chPrev == '\\')			
521  					cmdStateNew = cmdState;
522  				break;
523  			case SCE_SH_WORD:
524  				if (!setWord.Contains(sc.ch)) {
525  					char s[500];
526  					sc.GetCurrent(s, sizeof(s));
527  					int identifierStyle = SCE_SH_IDENTIFIER | insideCommand;
528  					const int subStyle = classifierIdentifiers.ValueFor(s);
529  					if (subStyle >= 0) {
530  						identifierStyle = subStyle | insideCommand;
531  					}
532  					char s2[10];
533  					s2[0] = static_cast<char>(sc.ch);
534  					s2[1] = '\0';
535  					const bool keywordEnds = IsASpace(sc.ch) || cmdDelimiter.InList(s2);
536  					if (cmdState == CmdState::Word) {
537  						if (strcmp(s, "in") == 0 && keywordEnds)
538  							cmdStateNew = CmdState::Body;
539  						else if (strcmp(s, "do") == 0 && keywordEnds)
540  							cmdStateNew = CmdState::Start;
541  						else
542  							sc.ChangeState(identifierStyle);
543  						sc.SetState(SCE_SH_DEFAULT | insideCommand);
544  						break;
545  					}
546  					if (strcmp(s, "test") == 0) {
547  						if (cmdState == CmdState::Start && keywordEnds) {
548  							cmdStateNew = CmdState::Test;
549  							testExprType = TestExprType::Test;
550  						} else
551  							sc.ChangeState(identifierStyle);
552  					}
553  					else if (bashStruct.InList(s)) {
554  						if (cmdState == CmdState::Start && keywordEnds)
555  							cmdStateNew = CmdState::Start;
556  						else
557  							sc.ChangeState(identifierStyle);
558  					}
559  					else if (bashStruct_in.InList(s)) {
560  						if (cmdState == CmdState::Start && keywordEnds)
561  							cmdStateNew = CmdState::Word;
562  						else
563  							sc.ChangeState(identifierStyle);
564  					}
565  					else if (s[0] == '-') {
566  						if (cmdState != CmdState::Test)
567  							sc.ChangeState(identifierStyle);
568  					}
569  					else if (cmdState != CmdState::Start
570  						  || !(keywords.InList(s) && keywordEnds)) {
571  						sc.ChangeState(identifierStyle);
572  					}
573  					sc.SetState(SCE_SH_DEFAULT | insideCommand);
574  				}
575  				break;
576  			case SCE_SH_IDENTIFIER:
577  				if (sc.chPrev == '\\' || !setWord.Contains(sc.ch) ||
578  					  (cmdState == CmdState::Arithmetic && !setWordStart.Contains(sc.ch))) {
579  					char s[500];
580  					sc.GetCurrent(s, sizeof(s));
581  					const int subStyle = classifierIdentifiers.ValueFor(s);
582  					if (subStyle >= 0) {
583  						sc.ChangeState(subStyle | insideCommand);
584  					}
585  					if (sc.chPrev == '\\') {	
586  						sc.Forward();
587  					}
588  					sc.SetState(SCE_SH_DEFAULT | insideCommand);
589  				}
590  				break;
591  			case SCE_SH_NUMBER:
592  				digit = translateBashDigit(sc.ch);
593  				if (numBase == BASH_BASE_DECIMAL) {
594  					if (sc.ch == '#') {
595  						char s[10];
596  						sc.GetCurrent(s, sizeof(s));
597  						numBase = getBashNumberBase(s);
598  						if (numBase != BASH_BASE_ERROR)
599  							break;
600  					} else if (IsADigit(sc.ch))
601  						break;
602  				} else if (numBase == BASH_BASE_HEX) {
603  					if (IsADigit(sc.ch, 16))
604  						break;
605  #ifdef PEDANTIC_OCTAL
606  				} else if (numBase == BASH_BASE_OCTAL ||
607  						   numBase == BASH_BASE_OCTAL_ERROR) {
608  					if (digit <= 7)
609  						break;
610  					if (digit <= 9) {
611  						numBase = BASH_BASE_OCTAL_ERROR;
612  						break;
613  					}
614  #endif
615  				} else if (numBase == BASH_BASE_ERROR) {
616  					if (digit <= 9)
617  						break;
618  				} else {	
619  					if (digit != BASH_BASE_ERROR) {
620  						if (numBase <= 36) {
621  							if (digit >= 36) digit -= 26;
622  						}
623  						if (digit < numBase)
624  							break;
625  						if (digit <= 9) {
626  							numBase = BASH_BASE_ERROR;
627  							break;
628  						}
629  					}
630  				}
631  				if (numBase == BASH_BASE_ERROR
632  #ifdef PEDANTIC_OCTAL
633  					|| numBase == BASH_BASE_OCTAL_ERROR
634  #endif
635  				) {
636  					sc.ChangeState(SCE_SH_ERROR | insideCommand);
637  				}
638  				sc.SetState(SCE_SH_DEFAULT | insideCommand);
639  				break;
640  			case SCE_SH_COMMENTLINE:
641  				if (sc.MatchLineEnd() && sc.chPrev != '\\') {
642  					sc.SetState(SCE_SH_DEFAULT | insideCommand);
643  				}
644  				break;
645  			case SCE_SH_HERE_DELIM:
646  				if (HereDoc.State == 0) { 
647  					HereDoc.Quote = sc.chNext;
648  					HereDoc.Quoted = false;
649  					HereDoc.Escaped = false;
650  					HereDoc.DelimiterLength = 0;
651  					HereDoc.Delimiter[HereDoc.DelimiterLength] = '\0';
652  					if (sc.chNext == '\'' || sc.chNext == '\"') {	
653  						sc.Forward();
654  						HereDoc.Quoted = true;
655  						HereDoc.State = 1;
656  					} else if (setHereDoc.Contains(sc.chNext) ||
657  					           (sc.chNext == '=' && cmdState != CmdState::Arithmetic)) {
658  						HereDoc.State = 1;
659  					} else if (sc.chNext == '<') {	
660  						sc.Forward();
661  						sc.ForwardSetState(SCE_SH_DEFAULT | insideCommand);
662  					} else if (IsASpace(sc.chNext)) {
663  					} else if (setLeftShift.Contains(sc.chNext) ||
664  					           (sc.chNext == '=' && cmdState == CmdState::Arithmetic)) {
665  						sc.ChangeState(SCE_SH_OPERATOR | insideCommand);
666  						sc.ForwardSetState(SCE_SH_DEFAULT | insideCommand);
667  					} else {
668  						HereDoc.State = 1;
669  					}
670  				} else if (HereDoc.State == 1) { 
671  					if ((HereDoc.Quote == '\'' && sc.ch != HereDoc.Quote) ||
672  					    (HereDoc.Quoted && sc.ch != HereDoc.Quote && sc.ch != '\\') ||
673  					    (HereDoc.Quote != '\'' && sc.chPrev == '\\') ||
674  					    (setHereDoc2.Contains(sc.ch))) {
675  						HereDoc.Append(sc.ch);
676  					} else if (HereDoc.Quoted && sc.ch == HereDoc.Quote) {	
677  						sc.ForwardSetState(SCE_SH_DEFAULT);
678  					} else if (sc.ch == '\\') {
679  						HereDoc.Escaped = true;
680  						if (HereDoc.Quoted && sc.chNext != HereDoc.Quote && sc.chNext != '\\') {
681  							HereDoc.Append(sc.ch);
682  						} else {
683  						}
684  					} else if (!HereDoc.Quoted) {
685  						sc.SetState(SCE_SH_DEFAULT | insideCommand);
686  					}
687  					if (HereDoc.DelimiterLength >= HERE_DELIM_MAX - 1) {	
688  						sc.SetState(SCE_SH_ERROR | insideCommand);
689  						HereDoc.State = 0;
690  					}
691  				}
692  				break;
693  			case SCE_SH_SCALAR:	
694  				if (!setParam.Contains(sc.ch)) {
695  					char s[500];
696  					sc.GetCurrent(s, sizeof(s));
697  					const int subStyle = classifierScalars.ValueFor(&s[1]); 
698  					if (subStyle >= 0) {
699  						sc.ChangeState(subStyle | insideCommand);
700  					}
701  					if (sc.LengthCurrent() == 1) {
702  						sc.Forward();
703  					}
704  					sc.SetState(QuoteStack.State | insideCommand);
705  					continue;
706  				}
707  				break;
708  			case SCE_SH_HERE_Q:
709  				if (sc.atLineStart && QuoteStack.Current.Style == QuoteStyle::HereDoc) {
710  					sc.SetState(SCE_SH_HERE_Q | insideCommand);
711  					if (HereDoc.Indent) { 
712  						while (sc.ch == '\t') {
713  							sc.Forward();
714  						}
715  					}
716  					if ((static_cast<Sci_Position>(sc.currentPos + HereDoc.DelimiterLength) == sc.lineEnd) &&
717  						(HereDoc.DelimiterLength == 0 || sc.Match(HereDoc.Delimiter))) {
718  						while (!sc.MatchLineEnd()) {
719  							sc.Forward();
720  						}
721  						QuoteStack.Pop();
722  						sc.SetState(SCE_SH_DEFAULT | QuoteStack.insideCommand);
723  						break;
724  					}
725  				}
726  				if (HereDoc.Quoted || HereDoc.Escaped) {
727  					break;
728  				}
729  				[[fallthrough]];
730  			case SCE_SH_STRING:	
731  			case SCE_SH_PARAM: 
732  			case SCE_SH_BACKTICKS:
733  				if (sc.ch == '\\') {
734  					if (QuoteStack.Current.Style != QuoteStyle::Literal)
735  						sc.Forward();
736  				} else if (sc.ch == QuoteStack.Current.Down) {
737  					if (QuoteStack.CountDown(sc, cmdState)) {
738  						continue;
739  					}
740  				} else if (sc.ch == QuoteStack.Current.Up) {
741  					QuoteStack.Current.Count++;
742  				} else {
743  					if (QuoteStack.Current.Style == QuoteStyle::String ||
744  						QuoteStack.Current.Style == QuoteStyle::HereDoc ||
745  						QuoteStack.Current.Style == QuoteStyle::LString
746  					) {	
747  						const bool stylingInside = options.stylingInside(MaskCommand(sc.state));
748  						if (sc.ch == '`') {
749  							QuoteStack.Push(sc.ch, QuoteStyle::Backtick, sc.state);
750  							if (stylingInside) {
751  								sc.SetState(SCE_SH_BACKTICKS | insideCommand);
752  							}
753  						} else if (sc.ch == '$') {
754  							QuoteStack.Expand(sc, cmdState, stylingInside);
755  							continue;
756  						}
757  					} else if (QuoteStack.Current.Style == QuoteStyle::Command ||
758  							   QuoteStack.Current.Style == QuoteStyle::Parameter ||
759  							   QuoteStack.Current.Style == QuoteStyle::Backtick
760  					) {	
761  						const bool stylingInside = options.stylingInside(MaskCommand(sc.state));
762  						if (sc.ch == '\'') {
763  							if (stylingInside) {
764  								QuoteStack.State = sc.state;
765  								sc.SetState(SCE_SH_CHARACTER | insideCommand);
766  							} else {
767  								QuoteStack.Push(sc.ch, QuoteStyle::Literal, sc.state);
768  							}
769  						} else if (sc.ch == '\"') {
770  							QuoteStack.Push(sc.ch, QuoteStyle::String, sc.state);
771  							if (stylingInside) {
772  								sc.SetState(SCE_SH_STRING | insideCommand);
773  							}
774  						} else if (sc.ch == '`') {
775  							QuoteStack.Push(sc.ch, QuoteStyle::Backtick, sc.state);
776  							if (stylingInside) {
777  								sc.SetState(SCE_SH_BACKTICKS | insideCommand);
778  							}
779  						} else if (sc.ch == '$') {
780  							QuoteStack.Expand(sc, cmdState, stylingInside);
781  							continue;
782  						}
783  					}
784  				}
785  				break;
786  			case SCE_SH_CHARACTER: 
787  				if (sc.ch == '\'') {
788  					sc.ForwardSetState(QuoteStack.State | insideCommand);
789  					continue;
790  				}
791  				break;
792  		}
793  		if (HereDoc.State == 1 && sc.MatchLineEnd()) {
794  			HereDoc.State = 2;
795  			if (HereDoc.Quoted) {
796  				if (MaskCommand(sc.state) == SCE_SH_HERE_DELIM) {
797  					sc.ChangeState(SCE_SH_ERROR | insideCommand);
798  					sc.SetState(SCE_SH_DEFAULT | insideCommand);
799  				} else {
800  					sc.SetState(SCE_SH_HERE_Q | insideCommand);
801  					QuoteStack.Start(-1, QuoteStyle::HereDoc, SCE_SH_DEFAULT);
802  				}
803  			} else if (HereDoc.DelimiterLength == 0) {
804  				sc.ChangeState(SCE_SH_ERROR | insideCommand);
805  				sc.SetState(SCE_SH_DEFAULT | insideCommand);
806  			} else {
807  				sc.SetState(SCE_SH_HERE_Q | insideCommand);
808  				QuoteStack.Start(-1, QuoteStyle::HereDoc, SCE_SH_DEFAULT);
809  			}
810  		}
811  		if (stylePrev != SCE_SH_DEFAULT && MaskCommand(sc.state) == SCE_SH_DEFAULT) {
812  			cmdState = cmdStateNew;
813  		}
814  		if (MaskCommand(sc.state) == SCE_SH_DEFAULT) {
815  			if (sc.ch == '\\') {
816  				sc.SetState(SCE_SH_IDENTIFIER | insideCommand);
817  				if (sc.chNext == '\r' || sc.chNext == '\n')
818  					sc.SetState(SCE_SH_OPERATOR | insideCommand);
819  			} else if (IsADigit(sc.ch)) {
820  				sc.SetState(SCE_SH_NUMBER | insideCommand);
821  				numBase = BASH_BASE_DECIMAL;
822  				if (sc.ch == '0') {	
823  					if (sc.chNext == 'x' || sc.chNext == 'X') {
824  						numBase = BASH_BASE_HEX;
825  						sc.Forward();
826  					} else if (IsADigit(sc.chNext)) {
827  #ifdef PEDANTIC_OCTAL
828  						numBase = BASH_BASE_OCTAL;
829  #else
830  						numBase = BASH_BASE_HEX;
831  #endif
832  					}
833  				}
834  			} else if (setWordStart.Contains(sc.ch)) {
835  				sc.SetState(SCE_SH_WORD | insideCommand);
836  			} else if (sc.ch == '#') {
837  				if (stylePrev != SCE_SH_WORD && stylePrev != SCE_SH_IDENTIFIER &&
838  					(sc.currentPos == 0 || setMetaCharacter.Contains(sc.chPrev))) {
839  					sc.SetState(SCE_SH_COMMENTLINE | insideCommand);
840  				} else {
841  					sc.SetState(SCE_SH_WORD | insideCommand);
842  				}
843  				if (cmdState == CmdState::Arithmetic) {
844  					if (sc.chPrev == '[') {	
845  						sc.SetState(SCE_SH_WORD | insideCommand);
846  						if (sc.chNext == '#') {
847  							sc.Forward();
848  						}
849  					} else if (sc.Match("##^") && IsUpperCase(sc.GetRelative(3))) {	
850  						sc.SetState(SCE_SH_IDENTIFIER | insideCommand);
851  						sc.Forward(3);
852  					} else if (sc.chNext == '#' && !IsASpace(sc.GetRelative(2))) {	
853  						sc.SetState(SCE_SH_IDENTIFIER | insideCommand);
854  						sc.Forward(2);
855  					} else if (setWordStart.Contains(sc.chNext)) {	
856  						sc.SetState(SCE_SH_IDENTIFIER | insideCommand);
857  					}
858  				}
859  			} else if (sc.ch == '\"') {
860  				sc.SetState(SCE_SH_STRING | insideCommand);
861  				QuoteStack.Start(sc.ch, QuoteStyle::String, SCE_SH_DEFAULT);
862  			} else if (sc.ch == '\'') {
863  				QuoteStack.State = SCE_SH_DEFAULT;
864  				sc.SetState(SCE_SH_CHARACTER | insideCommand);
865  			} else if (sc.ch == '`') {
866  				sc.SetState(SCE_SH_BACKTICKS | insideCommand);
867  				QuoteStack.Start(sc.ch, QuoteStyle::Backtick, SCE_SH_DEFAULT);
868  			} else if (sc.ch == '$') {
869  				QuoteStack.Expand(sc, cmdState, true);
870  				continue;
871  			} else if (cmdState != CmdState::Arithmetic && sc.Match('<', '<')) {
872  				sc.SetState(SCE_SH_HERE_DELIM | insideCommand);
873  				HereDoc.State = 0;
874  				if (sc.GetRelative(2) == '-') {	
875  					HereDoc.Indent = true;
876  					sc.Forward();
877  				} else {
878  					HereDoc.Indent = false;
879  				}
880  			} else if (sc.ch == '-'	&&	
881  					   setSingleCharOp.Contains(sc.chNext) &&
882  					   !setWord.Contains(sc.GetRelative(2)) &&
883  					   IsASpace(sc.chPrev)) {
884  				sc.SetState(SCE_SH_WORD | insideCommand);
885  				sc.Forward();
886  			} else if (setBashOperator.Contains(sc.ch)) {
887  				bool isCmdDelim = false;
888  				sc.SetState(SCE_SH_OPERATOR | insideCommand);
889  				if (QuoteStack.Current.Style == QuoteStyle::Arithmetic || QuoteStack.Current.Style == QuoteStyle::CommandInside) {
890  					if (sc.ch == QuoteStack.Current.Down) {
891  						if (QuoteStack.CountDown(sc, cmdState)) {
892  							continue;
893  						}
894  					} else if (sc.ch == QuoteStack.Current.Up) {
895  						QuoteStack.Current.Count++;
896  					}
897  				}
898  				if (cmdState != CmdState::Arithmetic && sc.ch == '(' && sc.chNext != '(') {
899  					const int i = GlobScan(sc);
900  					if (i > 1) {
901  						sc.SetState(SCE_SH_IDENTIFIER | insideCommand);
902  						sc.Forward(i + 1);
903  						continue;
904  					}
905  				}
906  				if (cmdState == CmdState::Start
907  				 || cmdState == CmdState::Body) {
908  					if (sc.Match('(', '(')) {
909  						cmdState = CmdState::Arithmetic;
910  						sc.Forward();
911  					} else if (sc.Match('[', '[') && IsASpace(sc.GetRelative(2))) {
912  						cmdState = CmdState::Test;
913  						testExprType = TestExprType::DoubleBracket;
914  						sc.Forward();
915  					} else if (sc.ch == '[' && IsASpace(sc.chNext)) {
916  						cmdState = CmdState::Test;
917  						testExprType = TestExprType::SingleBracket;
918  					}
919  				}
920  				if (cmdState == CmdState::Word && sc.Match('(', '(')) {
921  					cmdState = CmdState::Arithmetic;
922  					sc.Forward(2);
923  					continue;
924  				}
925  				if (cmdState == CmdState::Start
926  				 || cmdState == CmdState::Body
927  				 || cmdState == CmdState::Word
928  				 || (cmdState == CmdState::Test && testExprType == TestExprType::Test)) {
929  					char s[10];
930  					s[0] = static_cast<char>(sc.ch);
931  					if (setBashOperator.Contains(sc.chNext)) {
932  						s[1] = static_cast<char>(sc.chNext);
933  						s[2] = '\0';
934  						isCmdDelim = cmdDelimiter.InList(s);
935  						if (isCmdDelim)
936  							sc.Forward();
937  					}
938  					if (!isCmdDelim) {
939  						s[1] = '\0';
940  						isCmdDelim = cmdDelimiter.InList(s);
941  					}
942  					if (isCmdDelim) {
943  						cmdState = CmdState::Delimiter;
944  						sc.Forward();
945  						continue;
946  					}
947  				}
948  				if (cmdState == CmdState::Arithmetic && sc.Match(')', ')')) {
949  					cmdState = CmdState::Body;
950  					sc.Forward();
951  				} else if (cmdState == CmdState::Test && IsASpace(sc.chPrev)) {
952  					if (sc.Match(']', ']') && testExprType == TestExprType::DoubleBracket) {
953  						sc.Forward();
954  						cmdState = CmdState::Body;
955  					} else if (sc.ch == ']' && testExprType == TestExprType::SingleBracket) {
956  						cmdState = CmdState::Body;
957  					}
958  				}
959  			}
960  		}
961  		sc.Forward();
962  	}
963  	sc.Complete();
964  	if (MaskCommand(sc.state) == SCE_SH_HERE_Q) {
965  		styler.ChangeLexerState(sc.currentPos, styler.Length());
966  	}
967  	sc.Complete();
968  }
969  void SCI_METHOD LexerBash::Fold(Sci_PositionU startPos, Sci_Position length, int, IDocument *pAccess) {
970  	if(!options.fold)
971  		return;
972  	LexAccessor styler(pAccess);
973  	const Sci_PositionU endPos = startPos + length;
974  	int visibleChars = 0;
975  	int skipHereCh = 0;
976  	Sci_Position lineCurrent = styler.GetLine(startPos);
977  	int levelPrev = styler.LevelAt(lineCurrent) & SC_FOLDLEVELNUMBERMASK;
978  	int levelCurrent = levelPrev;
979  	char chNext = styler[startPos];
980  	int styleNext = MaskCommand(styler.StyleIndexAt(startPos));
981  	char word[8] = { '\0' }; 
982  	unsigned int wordlen = 0;
983  	for (Sci_PositionU i = startPos; i < endPos; i++) {
984  		const char ch = chNext;
985  		chNext = styler.SafeGetCharAt(i + 1);
986  		const int style = styleNext;
987  		styleNext = MaskCommand(styler.StyleIndexAt(i + 1));
988  		const bool atEOL = (ch == '\r' && chNext != '\n') || (ch == '\n');
989  		if (options.foldComment && atEOL && IsCommentLine(lineCurrent, styler))
990  		{
991  			if (!IsCommentLine(lineCurrent - 1, styler)
992  				&& IsCommentLine(lineCurrent + 1, styler))
993  				levelCurrent++;
994  			else if (IsCommentLine(lineCurrent - 1, styler)
995  					 && !IsCommentLine(lineCurrent + 1, styler))
996  				levelCurrent--;
997  		}
998  		if (style == SCE_SH_WORD) {
999  			if ((wordlen + 1) < sizeof(word))
1000  				word[wordlen++] = ch;
1001  			if (styleNext != style) {
1002  				word[wordlen] = '\0';
1003  				wordlen = 0;
1004  				if (strcmp(word, "if") == 0 || strcmp(word, "case") == 0 || strcmp(word, "do") == 0) {
1005  					levelCurrent++;
1006  				} else if (strcmp(word, "fi") == 0 || strcmp(word, "esac") == 0 || strcmp(word, "done") == 0) {
1007  					levelCurrent--;
1008  				}
1009  			}
1010  		}
1011  		if (style == SCE_SH_OPERATOR) {
1012  			if (ch == '{') {
1013  				levelCurrent++;
1014  			} else if (ch == '}') {
1015  				levelCurrent--;
1016  			}
1017  		}
1018  		if (style == SCE_SH_HERE_DELIM) {
1019  			if (ch == '<' && chNext == '<') {
1020  				if (styler.SafeGetCharAt(i + 2) == '<') {
1021  					skipHereCh = 1;
1022  				} else {
1023  					if (skipHereCh == 0) {
1024  						levelCurrent++;
1025  					} else {
1026  						skipHereCh = 0;
1027  					}
1028  				}
1029  			}
1030  		} else if (style == SCE_SH_HERE_Q && styler.StyleAt(i+1) == SCE_SH_DEFAULT) {
1031  			levelCurrent--;
1032  		}
1033  		if (atEOL) {
1034  			int lev = levelPrev;
1035  			if (visibleChars == 0 && options.foldCompact)
1036  				lev |= SC_FOLDLEVELWHITEFLAG;
1037  			if ((levelCurrent > levelPrev) && (visibleChars > 0))
1038  				lev |= SC_FOLDLEVELHEADERFLAG;
1039  			if (lev != styler.LevelAt(lineCurrent)) {
1040  				styler.SetLevel(lineCurrent, lev);
1041  			}
1042  			lineCurrent++;
1043  			levelPrev = levelCurrent;
1044  			visibleChars = 0;
1045  		}
1046  		if (!isspacechar(ch))
1047  			visibleChars++;
1048  	}
1049  	const int flagsNext = styler.LevelAt(lineCurrent) & ~SC_FOLDLEVELNUMBERMASK;
1050  	styler.SetLevel(lineCurrent, levelPrev | flagsNext);
1051  }
1052  LexerModule lmBash(SCLEX_BASH, LexerBash::LexerFactoryBash, "bash", bashWordListDesc);
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexBash.cxx</h3>
            <pre><code>1  #include <cstdlib>
2  #include <cassert>
3  #include <cstring>
4  #include <cstdio>
5  #include <cstdarg>
6  #include <string>
7  #include <string_view>
8  #include <vector>
9  #include <map>
10  #include <functional>
11  #include "ILexer.h"
12  #include "Scintilla.h"
13  #include "SciLexer.h"
14  #include "StringCopy.h"
15  #include "WordList.h"
16  #include "LexAccessor.h"
17  #include "StyleContext.h"
18  #include "CharacterSet.h"
19  #include "LexerModule.h"
20  #include "OptionSet.h"
21  #include "SubStyles.h"
22  #include "DefaultLexer.h"
23  using namespace Scintilla;
24  using namespace Lexilla;
25  namespace {
26  #define HERE_DELIM_MAX			256
27  #undef PEDANTIC_OCTAL
28  #define BASH_BASE_ERROR			65
29  #define BASH_BASE_DECIMAL		66
30  #define BASH_BASE_HEX			67
31  #ifdef PEDANTIC_OCTAL
32  #define BASH_BASE_OCTAL			68
33  #define	BASH_BASE_OCTAL_ERROR	69
34  #endif
35  enum class CmdState {
36  	Body,
37  	Start,
38  	Word,
39  	Test,
40  	Arithmetic,
41  	Delimiter,
42  };
43  enum class TestExprType {
44  	Test,			
45  	DoubleBracket,	
46  	SingleBracket,	
47  };
<span onclick='openModal()' class='match'>48  enum class CommandSubstitution {
49  	Backtick,
50  	Inside,
51  	InsideTrack,
52  };
53  enum class QuoteStyle {
54  	Literal,		
55  	CString,		
56  	String,			
57  	LString,		
</span>58  	HereDoc,		
59  	Backtick,		
60  	Parameter,		
61  	Command,		
62  	CommandInside,	
63  	Arithmetic,		
64  };
65  #define BASH_QUOTE_STACK_MAX	7
66  constexpr int commandSubstitutionFlag = 0x40;
67  constexpr int MaskCommand(int state) noexcept {
68  	return state & ~commandSubstitutionFlag;
69  }
70  constexpr int translateBashDigit(int ch) noexcept {
71  	if (ch >= '0' && ch <= '9') {
72  		return ch - '0';
73  	} else if (ch >= 'a' && ch <= 'z') {
74  		return ch - 'a' + 10;
75  	} else if (ch >= 'A' && ch <= 'Z') {
76  		return ch - 'A' + 36;
77  	} else if (ch == '@') {
78  		return 62;
79  	} else if (ch == '_') {
80  		return 63;
81  	}
82  	return BASH_BASE_ERROR;
83  }
84  int getBashNumberBase(char *s) noexcept {
85  	int i = 0;
86  	int base = 0;
87  	while (*s) {
88  		base = base * 10 + (*s++ - '0');
89  		i++;
90  	}
91  	if (base > 64 || i > 2) {
92  		return BASH_BASE_ERROR;
93  	}
94  	return base;
95  }
96  constexpr int opposite(int ch) noexcept {
97  	if (ch == '(') return ')';
98  	if (ch == '[') return ']';
99  	if (ch == '{') return '}';
100  	if (ch == '<') return '>';
101  	return ch;
102  }
103  int GlobScan(StyleContext &sc) {
104  	int c = 0;
105  	int sLen = 0;
106  	int pCount = 0;
107  	int hash = 0;
108  	while ((c = sc.GetRelativeCharacter(++sLen)) != 0) {
109  		if (IsASpace(c)) {
110  			return 0;
111  		} else if (c == '\'' || c == '\"') {
112  			if (hash != 2) return 0;
113  		} else if (c == '#' && hash == 0) {
114  			hash = (sLen == 1) ? 2:1;
115  		} else if (c == '(') {
116  			pCount++;
117  		} else if (c == ')') {
118  			if (pCount == 0) {
119  				if (hash) return sLen;
120  				return 0;
121  			}
122  			pCount--;
123  		}
124  	}
125  	return 0;
126  }
127  bool IsCommentLine(Sci_Position line, LexAccessor &styler) {
128  	const Sci_Position pos = styler.LineStart(line);
129  	const Sci_Position eol_pos = styler.LineStart(line + 1) - 1;
130  	for (Sci_Position i = pos; i < eol_pos; i++) {
131  		const char ch = styler[i];
132  		if (ch == '#')
133  			return true;
134  		else if (ch != ' ' && ch != '\t')
135  			return false;
136  	}
137  	return false;
138  }
139  struct OptionsBash {
140  	bool fold = false;
141  	bool foldComment = false;
142  	bool foldCompact = true;
143  	bool stylingInsideString = false;
144  	bool stylingInsideBackticks = false;
145  	bool stylingInsideParameter = false;
146  	bool stylingInsideHeredoc = false;
147  	int commandSubstitution = static_cast<int>(CommandSubstitution::Backtick);
148  	[[nodiscard]] bool stylingInside(int state) const noexcept {
149  		switch (state) {
150  		case SCE_SH_STRING:
151  			return stylingInsideString;
152  		case SCE_SH_BACKTICKS:
153  			return stylingInsideBackticks;
154  		case SCE_SH_PARAM:
155  			return stylingInsideParameter;
156  		case SCE_SH_HERE_Q:
157  			return stylingInsideHeredoc;
158  		default:
159  			return false;
160  		}
161  	}
162  };
163  const char * const bashWordListDesc[] = {
164  	"Keywords",
165  	nullptr
166  };
167  struct OptionSetBash : public OptionSet<OptionsBash> {
168  	OptionSetBash() {
169  		DefineProperty("fold", &OptionsBash::fold);
170  		DefineProperty("fold.comment", &OptionsBash::foldComment);
171  		DefineProperty("fold.compact", &OptionsBash::foldCompact);
172  		DefineProperty("lexer.bash.styling.inside.string", &OptionsBash::stylingInsideString,
173  			"Set this property to 1 to highlight shell expansions inside string.");
174  		DefineProperty("lexer.bash.styling.inside.backticks", &OptionsBash::stylingInsideBackticks,
175  			"Set this property to 1 to highlight shell expansions inside backticks.");
176  		DefineProperty("lexer.bash.styling.inside.parameter", &OptionsBash::stylingInsideParameter,
177  			"Set this property to 1 to highlight shell expansions inside ${} parameter expansion.");
178  		DefineProperty("lexer.bash.styling.inside.heredoc", &OptionsBash::stylingInsideHeredoc,
179  			"Set this property to 1 to highlight shell expansions inside here document.");
180  		DefineProperty("lexer.bash.command.substitution", &OptionsBash::commandSubstitution,
181  			"Set how to highlight $() command substitution. "
182  			"0 (the default) highlighted as backticks. "
183  			"1 highlighted inside. "
184  			"2 highlighted inside with extra scope tracking.");
185  		DefineWordListSets(bashWordListDesc);
186  	}
187  };
188  class QuoteCls {	
189  public:
190  	int Count = 0;
191  	int Up = '\0';
192  	int Down = '\0';
193  	QuoteStyle Style = QuoteStyle::Literal;
194  	int Outer = SCE_SH_DEFAULT;
195  	void Clear() noexcept {
196  		Count = 0;
197  		Up	  = '\0';
198  		Down  = '\0';
199  		Style = QuoteStyle::Literal;
200  		Outer = SCE_SH_DEFAULT;
201  	}
202  	void Start(int u, QuoteStyle s, int outer) noexcept {
203  		Count = 1;
204  		Up    = u;
205  		Down  = opposite(Up);
206  		Style = s;
207  		Outer = outer;
208  	}
209  };
210  class QuoteStackCls {	
211  public:
212  	int Depth = 0;
213  	int State = SCE_SH_DEFAULT;
214  	CommandSubstitution commandSubstitution = CommandSubstitution::Backtick;
215  	int insideCommand = 0;
216  	QuoteCls Current;
217  	QuoteCls Stack[BASH_QUOTE_STACK_MAX];
218  	[[nodiscard]] bool Empty() const noexcept {
219  		return Current.Up == '\0';
220  	}
221  	void Start(int u, QuoteStyle s, int outer) noexcept {
222  		if (Empty()) {
223  			Current.Start(u, s, outer);
224  		} else {
225  			Push(u, s, outer);
226  		}
227  	}
228  	void Push(int u, QuoteStyle s, int outer) noexcept {
229  		if (Depth >= BASH_QUOTE_STACK_MAX) {
230  			return;
231  		}
232  		Stack[Depth] = Current;
233  		Depth++;
234  		Current.Start(u, s, outer);
235  	}
236  	void Pop() noexcept {
237  		if (Depth == 0) {
238  			Clear();
239  			return;
240  		}
241  		if (insideCommand != 0) {
242  			insideCommand = 0;
243  			for (int i = 0; i < Depth; i++) {
244  				if (Stack[i].Style == QuoteStyle::CommandInside) {
245  					insideCommand = commandSubstitutionFlag;
246  					break;
247  				}
248  			}
249  		}
250  		Depth--;
251  		Current = Stack[Depth];
252  	}
253  	void Clear() noexcept {
254  		Depth = 0;
255  		State = SCE_SH_DEFAULT;
256  		insideCommand = 0;
257  		Current.Clear();
258  	}
259  	bool CountDown(StyleContext &sc, CmdState &cmdState) {
260  		Current.Count--;
261  		if (Current.Count == 1 && sc.Match(')', ')')) {
262  			Current.Count--;
263  			sc.Forward();
264  		}
265  		if (Current.Count == 0) {
266  			cmdState = CmdState::Body;
267  			const int outer = Current.Outer;
268  			Pop();
269  			sc.ForwardSetState(outer | insideCommand);
270  			return true;
271  		}
272  		return false;
273  	}
274  	void Expand(StyleContext &sc, CmdState &cmdState, bool stylingInside) {
275  		const int state = sc.state;
276  		QuoteStyle style = QuoteStyle::Literal;
277  		State = state;
278  		sc.SetState(SCE_SH_SCALAR);
279  		sc.Forward();
280  		if (sc.ch == '{') {
281  			style = QuoteStyle::Parameter;
282  			sc.ChangeState(SCE_SH_PARAM);
283  		} else if (sc.ch == '\'') {
284  			style = QuoteStyle::CString;
285  			sc.ChangeState(SCE_SH_STRING);
286  		} else if (sc.ch == '"') {
287  			style = QuoteStyle::LString;
288  			sc.ChangeState(SCE_SH_STRING);
289  		} else if (sc.ch == '(' || sc.ch == '[') {
290  			if (sc.ch == '[' || sc.chNext == '(') {
291  				style = QuoteStyle::Arithmetic;
292  				cmdState = CmdState::Arithmetic;
293  				sc.ChangeState(SCE_SH_OPERATOR);
294  			} else {
295  				if (stylingInside && commandSubstitution >= CommandSubstitution::Inside) {
296  					style = QuoteStyle::CommandInside;
297  					cmdState = CmdState::Delimiter;
298  					sc.ChangeState(SCE_SH_OPERATOR);
299  					if (commandSubstitution == CommandSubstitution::InsideTrack) {
300  						insideCommand = commandSubstitutionFlag;
301  					}
302  				} else {
303  					style = QuoteStyle::Command;
304  					sc.ChangeState(SCE_SH_BACKTICKS);
305  				}
306  			}
307  			if (sc.Match('(', '(') && state == SCE_SH_DEFAULT && Depth == 0) {
308  				style = QuoteStyle::Literal;
309  			}
310  		} else if (sc.ch == '`') {	
311  			style = QuoteStyle::Backtick;
312  			sc.ChangeState(SCE_SH_BACKTICKS);
313  		} else {
314  		}
315  		if (!stylingInside) {
316  			sc.ChangeState(state);
317  		} else {
318  			sc.ChangeState(sc.state | insideCommand);
319  		}
320  		if (style != QuoteStyle::Literal) {
321  			Start(sc.ch, style, state);
322  			sc.Forward();
323  		}
324  	}
325  };
326  const char styleSubable[] = { SCE_SH_IDENTIFIER, SCE_SH_SCALAR, 0 };
327  const LexicalClass lexicalClasses[] = {
328  	0, "SCE_SH_DEFAULT", "default", "White space",
329  	1, "SCE_SH_ERROR", "error", "Error",
330  	2, "SCE_SH_COMMENTLINE", "comment line", "Line comment: #",
331  	3, "SCE_SH_NUMBER", "literal numeric", "Number",
332  	4, "SCE_SH_WORD", "keyword", "Keyword",
333  	5, "SCE_SH_STRING", "literal string", "String",
334  	6, "SCE_SH_CHARACTER", "literal string", "Single quoted string",
335  	7, "SCE_SH_OPERATOR", "operator", "Operators",
336  	8, "SCE_SH_IDENTIFIER", "identifier", "Identifiers",
337  	9, "SCE_SH_SCALAR", "identifier", "Scalar variable",
338  	10, "SCE_SH_PARAM", "identifier", "Parameter",
339  	11, "SCE_SH_BACKTICKS", "literal string", "Backtick quoted command",
340  	12, "SCE_SH_HERE_DELIM", "operator", "Heredoc delimiter",
341  	13, "SCE_SH_HERE_Q", "literal string", "Heredoc quoted string",
342  };
343  }
344  class LexerBash final : public DefaultLexer {
345  	WordList keywords;
346  	WordList cmdDelimiter;
347  	WordList bashStruct;
348  	WordList bashStruct_in;
349  	OptionsBash options;
350  	OptionSetBash osBash;
351  	enum { ssIdentifier, ssScalar };
352  	SubStyles subStyles;
353  public:
354  	LexerBash() :
355  		DefaultLexer("bash", SCLEX_BASH, lexicalClasses, ELEMENTS(lexicalClasses)),
356  		subStyles(styleSubable, 0x80, 0x40, 0) {
357  		cmdDelimiter.Set("| || |& & && ; ;; ( ) { }");
358  		bashStruct.Set("if elif fi while until else then do done esac eval");
359  		bashStruct_in.Set("for case select");
360  	}
361  	void SCI_METHOD Release() override {
362  		delete this;
363  	}
364  	int SCI_METHOD Version() const override {
365  		return lvRelease5;
366  	}
367  	const char * SCI_METHOD PropertyNames() override {
368  		return osBash.PropertyNames();
369  	}
370  	int SCI_METHOD PropertyType(const char* name) override {
371  		return osBash.PropertyType(name);
372  	}
373  	const char * SCI_METHOD DescribeProperty(const char *name) override {
374  		return osBash.DescribeProperty(name);
375  	}
376  	Sci_Position SCI_METHOD PropertySet(const char *key, const char *val) override;
377  	const char * SCI_METHOD PropertyGet(const char* key) override {
378  		return osBash.PropertyGet(key);
379  	}
380  	const char * SCI_METHOD DescribeWordListSets() override {
381  		return osBash.DescribeWordListSets();
382  	}
383  	Sci_Position SCI_METHOD WordListSet(int n, const char *wl) override;
384  	void SCI_METHOD Lex(Sci_PositionU startPos, Sci_Position length, int initStyle, IDocument *pAccess) override;
385  	void SCI_METHOD Fold(Sci_PositionU startPos, Sci_Position length, int initStyle, IDocument *pAccess) override;
386  	void * SCI_METHOD PrivateCall(int, void *) override {
387  		return nullptr;
388  	}
389  	int SCI_METHOD AllocateSubStyles(int styleBase, int numberStyles) override {
390  		return subStyles.Allocate(styleBase, numberStyles);
391  	}
392  	int SCI_METHOD SubStylesStart(int styleBase) override {
393  		return subStyles.Start(styleBase);
394  	}
395  	int SCI_METHOD SubStylesLength(int styleBase) override {
396  		return subStyles.Length(styleBase);
397  	}
398  	int SCI_METHOD StyleFromSubStyle(int subStyle) override {
399  		const int styleBase = subStyles.BaseStyle(subStyle);
400  		return styleBase;
401  	}
402  	int SCI_METHOD PrimaryStyleFromStyle(int style) override {
403  		return style;
404  	}
405  	void SCI_METHOD FreeSubStyles() override {
406  		subStyles.Free();
407  	}
408  	void SCI_METHOD SetIdentifiers(int style, const char *identifiers) override {
409  		subStyles.SetIdentifiers(style, identifiers);
410  	}
411  	int SCI_METHOD DistanceToSecondaryStyles() override {
412  		return 0;
413  	}
414  	const char *SCI_METHOD GetSubStyleBases() override {
415  		return styleSubable;
416  	}
417  	static ILexer5 *LexerFactoryBash() {
418  		return new LexerBash();
419  	}
420  };
421  Sci_Position SCI_METHOD LexerBash::PropertySet(const char *key, const char *val) {
422  	if (osBash.PropertySet(&options, key, val)) {
423  		return 0;
424  	}
425  	return -1;
426  }
427  Sci_Position SCI_METHOD LexerBash::WordListSet(int n, const char *wl) {
428  	WordList *wordListN = nullptr;
429  	switch (n) {
430  	case 0:
431  		wordListN = &keywords;
432  		break;
433  	}
434  	Sci_Position firstModification = -1;
435  	if (wordListN) {
436  		if (wordListN->Set(wl)) {
437  			firstModification = 0;
438  		}
439  	}
440  	return firstModification;
441  }
442  void SCI_METHOD LexerBash::Lex(Sci_PositionU startPos, Sci_Position length, int initStyle, IDocument *pAccess) {
443  	const CharacterSet setWordStart(CharacterSet::setAlpha, "_");
444  	const CharacterSet setWord(CharacterSet::setAlphaNum, "._+-");
445  	CharacterSet setMetaCharacter(CharacterSet::setNone, "|&;()<> \t\r\n");
446  	setMetaCharacter.Add(0);
447  	const CharacterSet setBashOperator(CharacterSet::setNone, "^&%()-+=|{}[]:;>,*/<?!.~@");
448  	const CharacterSet setSingleCharOp(CharacterSet::setNone, "rwxoRWXOezsfdlpSbctugkTBMACahGLNn");
449  	const CharacterSet setParam(CharacterSet::setAlphaNum, "_");
450  	const CharacterSet setHereDoc(CharacterSet::setAlpha, "_\\-+!%*,./:?@[]^`{}~");
451  	const CharacterSet setHereDoc2(CharacterSet::setAlphaNum, "_-+!%*,./:=?@[]^`{}~");
452  	const CharacterSet setLeftShift(CharacterSet::setDigits, "$");
453  	class HereDocCls {	
454  	public:
455  		int State = 0;			
456  		int Quote = '\0';		
457  		bool Quoted = false;		
458  		bool Escaped = false;		
459  		bool Indent = false;		
460  		int DelimiterLength = 0;	
461  		char Delimiter[HERE_DELIM_MAX]{};	
462  		HereDocCls() noexcept = default;
463  		void Append(int ch) {
464  			Delimiter[DelimiterLength++] = static_cast<char>(ch);
465  			Delimiter[DelimiterLength] = '\0';
466  		}
467  	};
468  	HereDocCls HereDoc;
469  	QuoteStackCls QuoteStack;
470  	QuoteStack.commandSubstitution = static_cast<CommandSubstitution>(options.commandSubstitution);
471  	const WordClassifier &classifierIdentifiers = subStyles.Classifier(SCE_SH_IDENTIFIER);
472  	const WordClassifier &classifierScalars = subStyles.Classifier(SCE_SH_SCALAR);
473  	int numBase = 0;
474  	int digit = 0;
475  	const Sci_PositionU endPos = startPos + length;
476  	CmdState cmdState = CmdState::Start;
477  	TestExprType testExprType = TestExprType::Test;
478  	LexAccessor styler(pAccess);
479  	Sci_Position ln = styler.GetLine(startPos);
480  	if (ln > 0 && startPos == static_cast<Sci_PositionU>(styler.LineStart(ln)))
481  		ln--;
482  	for (;;) {
483  		startPos = styler.LineStart(ln);
484  		if (ln == 0 || styler.GetLineState(ln) == static_cast<int>(CmdState::Start))
485  			break;
486  		ln--;
487  	}
488  	initStyle = SCE_SH_DEFAULT;
489  	StyleContext sc(startPos, endPos - startPos, initStyle, styler);
490  	while (sc.More()) {
491  		if (sc.atLineStart) {
492  			if (MaskCommand(sc.state) == SCE_SH_STRING
493  			 || MaskCommand(sc.state) == SCE_SH_BACKTICKS
494  			 || MaskCommand(sc.state) == SCE_SH_CHARACTER
495  			 || MaskCommand(sc.state) == SCE_SH_HERE_Q
496  			 || MaskCommand(sc.state) == SCE_SH_COMMENTLINE
497  			 || MaskCommand(sc.state) == SCE_SH_PARAM) {
498  				styler.SetLineState(sc.currentLine, static_cast<int>(CmdState::Body));
499  			} else {
500  				if (sc.currentLine > 0) {
501  					if ((sc.GetRelative(-3) == '\\' && sc.GetRelative(-2) == '\r' && sc.chPrev == '\n')
502  					 || sc.GetRelative(-2) == '\\') {	
503  					} else
504  						cmdState = CmdState::Start;
505  				}
506  				const CmdState state = QuoteStack.Empty() ? cmdState : CmdState::Body;
507  				styler.SetLineState(sc.currentLine, static_cast<int>(state));
508  			}
509  		}
510  		CmdState cmdStateNew = CmdState::Body;
511  		if (cmdState == CmdState::Test || cmdState == CmdState::Arithmetic || cmdState == CmdState::Word)
512  			cmdStateNew = cmdState;
513  		const int stylePrev = MaskCommand(sc.state);
514  		const int insideCommand = QuoteStack.insideCommand;
515  		switch (MaskCommand(sc.state)) {
516  			case SCE_SH_OPERATOR:
517  				sc.SetState(SCE_SH_DEFAULT | insideCommand);
518  				if (cmdState == CmdState::Delimiter)		
519  					cmdStateNew = CmdState::Start;
520  				else if (sc.chPrev == '\\')			
521  					cmdStateNew = cmdState;
522  				break;
523  			case SCE_SH_WORD:
524  				if (!setWord.Contains(sc.ch)) {
525  					char s[500];
526  					sc.GetCurrent(s, sizeof(s));
527  					int identifierStyle = SCE_SH_IDENTIFIER | insideCommand;
528  					const int subStyle = classifierIdentifiers.ValueFor(s);
529  					if (subStyle >= 0) {
530  						identifierStyle = subStyle | insideCommand;
531  					}
532  					char s2[10];
533  					s2[0] = static_cast<char>(sc.ch);
534  					s2[1] = '\0';
535  					const bool keywordEnds = IsASpace(sc.ch) || cmdDelimiter.InList(s2);
536  					if (cmdState == CmdState::Word) {
537  						if (strcmp(s, "in") == 0 && keywordEnds)
538  							cmdStateNew = CmdState::Body;
539  						else if (strcmp(s, "do") == 0 && keywordEnds)
540  							cmdStateNew = CmdState::Start;
541  						else
542  							sc.ChangeState(identifierStyle);
543  						sc.SetState(SCE_SH_DEFAULT | insideCommand);
544  						break;
545  					}
546  					if (strcmp(s, "test") == 0) {
547  						if (cmdState == CmdState::Start && keywordEnds) {
548  							cmdStateNew = CmdState::Test;
549  							testExprType = TestExprType::Test;
550  						} else
551  							sc.ChangeState(identifierStyle);
552  					}
553  					else if (bashStruct.InList(s)) {
554  						if (cmdState == CmdState::Start && keywordEnds)
555  							cmdStateNew = CmdState::Start;
556  						else
557  							sc.ChangeState(identifierStyle);
558  					}
559  					else if (bashStruct_in.InList(s)) {
560  						if (cmdState == CmdState::Start && keywordEnds)
561  							cmdStateNew = CmdState::Word;
562  						else
563  							sc.ChangeState(identifierStyle);
564  					}
565  					else if (s[0] == '-') {
566  						if (cmdState != CmdState::Test)
567  							sc.ChangeState(identifierStyle);
568  					}
569  					else if (cmdState != CmdState::Start
570  						  || !(keywords.InList(s) && keywordEnds)) {
571  						sc.ChangeState(identifierStyle);
572  					}
573  					sc.SetState(SCE_SH_DEFAULT | insideCommand);
574  				}
575  				break;
576  			case SCE_SH_IDENTIFIER:
577  				if (sc.chPrev == '\\' || !setWord.Contains(sc.ch) ||
578  					  (cmdState == CmdState::Arithmetic && !setWordStart.Contains(sc.ch))) {
579  					char s[500];
580  					sc.GetCurrent(s, sizeof(s));
581  					const int subStyle = classifierIdentifiers.ValueFor(s);
582  					if (subStyle >= 0) {
583  						sc.ChangeState(subStyle | insideCommand);
584  					}
585  					if (sc.chPrev == '\\') {	
586  						sc.Forward();
587  					}
588  					sc.SetState(SCE_SH_DEFAULT | insideCommand);
589  				}
590  				break;
591  			case SCE_SH_NUMBER:
592  				digit = translateBashDigit(sc.ch);
593  				if (numBase == BASH_BASE_DECIMAL) {
594  					if (sc.ch == '#') {
595  						char s[10];
596  						sc.GetCurrent(s, sizeof(s));
597  						numBase = getBashNumberBase(s);
598  						if (numBase != BASH_BASE_ERROR)
599  							break;
600  					} else if (IsADigit(sc.ch))
601  						break;
602  				} else if (numBase == BASH_BASE_HEX) {
603  					if (IsADigit(sc.ch, 16))
604  						break;
605  #ifdef PEDANTIC_OCTAL
606  				} else if (numBase == BASH_BASE_OCTAL ||
607  						   numBase == BASH_BASE_OCTAL_ERROR) {
608  					if (digit <= 7)
609  						break;
610  					if (digit <= 9) {
611  						numBase = BASH_BASE_OCTAL_ERROR;
612  						break;
613  					}
614  #endif
615  				} else if (numBase == BASH_BASE_ERROR) {
616  					if (digit <= 9)
617  						break;
618  				} else {	
619  					if (digit != BASH_BASE_ERROR) {
620  						if (numBase <= 36) {
621  							if (digit >= 36) digit -= 26;
622  						}
623  						if (digit < numBase)
624  							break;
625  						if (digit <= 9) {
626  							numBase = BASH_BASE_ERROR;
627  							break;
628  						}
629  					}
630  				}
631  				if (numBase == BASH_BASE_ERROR
632  #ifdef PEDANTIC_OCTAL
633  					|| numBase == BASH_BASE_OCTAL_ERROR
634  #endif
635  				) {
636  					sc.ChangeState(SCE_SH_ERROR | insideCommand);
637  				}
638  				sc.SetState(SCE_SH_DEFAULT | insideCommand);
639  				break;
640  			case SCE_SH_COMMENTLINE:
641  				if (sc.MatchLineEnd() && sc.chPrev != '\\') {
642  					sc.SetState(SCE_SH_DEFAULT | insideCommand);
643  				}
644  				break;
645  			case SCE_SH_HERE_DELIM:
646  				if (HereDoc.State == 0) { 
647  					HereDoc.Quote = sc.chNext;
648  					HereDoc.Quoted = false;
649  					HereDoc.Escaped = false;
650  					HereDoc.DelimiterLength = 0;
651  					HereDoc.Delimiter[HereDoc.DelimiterLength] = '\0';
652  					if (sc.chNext == '\'' || sc.chNext == '\"') {	
653  						sc.Forward();
654  						HereDoc.Quoted = true;
655  						HereDoc.State = 1;
656  					} else if (setHereDoc.Contains(sc.chNext) ||
657  					           (sc.chNext == '=' && cmdState != CmdState::Arithmetic)) {
658  						HereDoc.State = 1;
659  					} else if (sc.chNext == '<') {	
660  						sc.Forward();
661  						sc.ForwardSetState(SCE_SH_DEFAULT | insideCommand);
662  					} else if (IsASpace(sc.chNext)) {
663  					} else if (setLeftShift.Contains(sc.chNext) ||
664  					           (sc.chNext == '=' && cmdState == CmdState::Arithmetic)) {
665  						sc.ChangeState(SCE_SH_OPERATOR | insideCommand);
666  						sc.ForwardSetState(SCE_SH_DEFAULT | insideCommand);
667  					} else {
668  						HereDoc.State = 1;
669  					}
670  				} else if (HereDoc.State == 1) { 
671  					if ((HereDoc.Quote == '\'' && sc.ch != HereDoc.Quote) ||
672  					    (HereDoc.Quoted && sc.ch != HereDoc.Quote && sc.ch != '\\') ||
673  					    (HereDoc.Quote != '\'' && sc.chPrev == '\\') ||
674  					    (setHereDoc2.Contains(sc.ch))) {
675  						HereDoc.Append(sc.ch);
676  					} else if (HereDoc.Quoted && sc.ch == HereDoc.Quote) {	
677  						sc.ForwardSetState(SCE_SH_DEFAULT);
678  					} else if (sc.ch == '\\') {
679  						HereDoc.Escaped = true;
680  						if (HereDoc.Quoted && sc.chNext != HereDoc.Quote && sc.chNext != '\\') {
681  							HereDoc.Append(sc.ch);
682  						} else {
683  						}
684  					} else if (!HereDoc.Quoted) {
685  						sc.SetState(SCE_SH_DEFAULT | insideCommand);
686  					}
687  					if (HereDoc.DelimiterLength >= HERE_DELIM_MAX - 1) {	
688  						sc.SetState(SCE_SH_ERROR | insideCommand);
689  						HereDoc.State = 0;
690  					}
691  				}
692  				break;
693  			case SCE_SH_SCALAR:	
694  				if (!setParam.Contains(sc.ch)) {
695  					char s[500];
696  					sc.GetCurrent(s, sizeof(s));
697  					const int subStyle = classifierScalars.ValueFor(&s[1]); 
698  					if (subStyle >= 0) {
699  						sc.ChangeState(subStyle | insideCommand);
700  					}
701  					if (sc.LengthCurrent() == 1) {
702  						sc.Forward();
703  					}
704  					sc.SetState(QuoteStack.State | insideCommand);
705  					continue;
706  				}
707  				break;
708  			case SCE_SH_HERE_Q:
709  				if (sc.atLineStart && QuoteStack.Current.Style == QuoteStyle::HereDoc) {
710  					sc.SetState(SCE_SH_HERE_Q | insideCommand);
711  					if (HereDoc.Indent) { 
712  						while (sc.ch == '\t') {
713  							sc.Forward();
714  						}
715  					}
716  					if ((static_cast<Sci_Position>(sc.currentPos + HereDoc.DelimiterLength) == sc.lineEnd) &&
717  						(HereDoc.DelimiterLength == 0 || sc.Match(HereDoc.Delimiter))) {
718  						while (!sc.MatchLineEnd()) {
719  							sc.Forward();
720  						}
721  						QuoteStack.Pop();
722  						sc.SetState(SCE_SH_DEFAULT | QuoteStack.insideCommand);
723  						break;
724  					}
725  				}
726  				if (HereDoc.Quoted || HereDoc.Escaped) {
727  					break;
728  				}
729  				[[fallthrough]];
730  			case SCE_SH_STRING:	
731  			case SCE_SH_PARAM: 
732  			case SCE_SH_BACKTICKS:
733  				if (sc.ch == '\\') {
734  					if (QuoteStack.Current.Style != QuoteStyle::Literal)
735  						sc.Forward();
736  				} else if (sc.ch == QuoteStack.Current.Down) {
737  					if (QuoteStack.CountDown(sc, cmdState)) {
738  						continue;
739  					}
740  				} else if (sc.ch == QuoteStack.Current.Up) {
741  					QuoteStack.Current.Count++;
742  				} else {
743  					if (QuoteStack.Current.Style == QuoteStyle::String ||
744  						QuoteStack.Current.Style == QuoteStyle::HereDoc ||
745  						QuoteStack.Current.Style == QuoteStyle::LString
746  					) {	
747  						const bool stylingInside = options.stylingInside(MaskCommand(sc.state));
748  						if (sc.ch == '`') {
749  							QuoteStack.Push(sc.ch, QuoteStyle::Backtick, sc.state);
750  							if (stylingInside) {
751  								sc.SetState(SCE_SH_BACKTICKS | insideCommand);
752  							}
753  						} else if (sc.ch == '$') {
754  							QuoteStack.Expand(sc, cmdState, stylingInside);
755  							continue;
756  						}
757  					} else if (QuoteStack.Current.Style == QuoteStyle::Command ||
758  							   QuoteStack.Current.Style == QuoteStyle::Parameter ||
759  							   QuoteStack.Current.Style == QuoteStyle::Backtick
760  					) {	
761  						const bool stylingInside = options.stylingInside(MaskCommand(sc.state));
762  						if (sc.ch == '\'') {
763  							if (stylingInside) {
764  								QuoteStack.State = sc.state;
765  								sc.SetState(SCE_SH_CHARACTER | insideCommand);
766  							} else {
767  								QuoteStack.Push(sc.ch, QuoteStyle::Literal, sc.state);
768  							}
769  						} else if (sc.ch == '\"') {
770  							QuoteStack.Push(sc.ch, QuoteStyle::String, sc.state);
771  							if (stylingInside) {
772  								sc.SetState(SCE_SH_STRING | insideCommand);
773  							}
774  						} else if (sc.ch == '`') {
775  							QuoteStack.Push(sc.ch, QuoteStyle::Backtick, sc.state);
776  							if (stylingInside) {
777  								sc.SetState(SCE_SH_BACKTICKS | insideCommand);
778  							}
779  						} else if (sc.ch == '$') {
780  							QuoteStack.Expand(sc, cmdState, stylingInside);
781  							continue;
782  						}
783  					}
784  				}
785  				break;
786  			case SCE_SH_CHARACTER: 
787  				if (sc.ch == '\'') {
788  					sc.ForwardSetState(QuoteStack.State | insideCommand);
789  					continue;
790  				}
791  				break;
792  		}
793  		if (HereDoc.State == 1 && sc.MatchLineEnd()) {
794  			HereDoc.State = 2;
795  			if (HereDoc.Quoted) {
796  				if (MaskCommand(sc.state) == SCE_SH_HERE_DELIM) {
797  					sc.ChangeState(SCE_SH_ERROR | insideCommand);
798  					sc.SetState(SCE_SH_DEFAULT | insideCommand);
799  				} else {
800  					sc.SetState(SCE_SH_HERE_Q | insideCommand);
801  					QuoteStack.Start(-1, QuoteStyle::HereDoc, SCE_SH_DEFAULT);
802  				}
803  			} else if (HereDoc.DelimiterLength == 0) {
804  				sc.ChangeState(SCE_SH_ERROR | insideCommand);
805  				sc.SetState(SCE_SH_DEFAULT | insideCommand);
806  			} else {
807  				sc.SetState(SCE_SH_HERE_Q | insideCommand);
808  				QuoteStack.Start(-1, QuoteStyle::HereDoc, SCE_SH_DEFAULT);
809  			}
810  		}
811  		if (stylePrev != SCE_SH_DEFAULT && MaskCommand(sc.state) == SCE_SH_DEFAULT) {
812  			cmdState = cmdStateNew;
813  		}
814  		if (MaskCommand(sc.state) == SCE_SH_DEFAULT) {
815  			if (sc.ch == '\\') {
816  				sc.SetState(SCE_SH_IDENTIFIER | insideCommand);
817  				if (sc.chNext == '\r' || sc.chNext == '\n')
818  					sc.SetState(SCE_SH_OPERATOR | insideCommand);
819  			} else if (IsADigit(sc.ch)) {
820  				sc.SetState(SCE_SH_NUMBER | insideCommand);
821  				numBase = BASH_BASE_DECIMAL;
822  				if (sc.ch == '0') {	
823  					if (sc.chNext == 'x' || sc.chNext == 'X') {
824  						numBase = BASH_BASE_HEX;
825  						sc.Forward();
826  					} else if (IsADigit(sc.chNext)) {
827  #ifdef PEDANTIC_OCTAL
828  						numBase = BASH_BASE_OCTAL;
829  #else
830  						numBase = BASH_BASE_HEX;
831  #endif
832  					}
833  				}
834  			} else if (setWordStart.Contains(sc.ch)) {
835  				sc.SetState(SCE_SH_WORD | insideCommand);
836  			} else if (sc.ch == '#') {
837  				if (stylePrev != SCE_SH_WORD && stylePrev != SCE_SH_IDENTIFIER &&
838  					(sc.currentPos == 0 || setMetaCharacter.Contains(sc.chPrev))) {
839  					sc.SetState(SCE_SH_COMMENTLINE | insideCommand);
840  				} else {
841  					sc.SetState(SCE_SH_WORD | insideCommand);
842  				}
843  				if (cmdState == CmdState::Arithmetic) {
844  					if (sc.chPrev == '[') {	
845  						sc.SetState(SCE_SH_WORD | insideCommand);
846  						if (sc.chNext == '#') {
847  							sc.Forward();
848  						}
849  					} else if (sc.Match("##^") && IsUpperCase(sc.GetRelative(3))) {	
850  						sc.SetState(SCE_SH_IDENTIFIER | insideCommand);
851  						sc.Forward(3);
852  					} else if (sc.chNext == '#' && !IsASpace(sc.GetRelative(2))) {	
853  						sc.SetState(SCE_SH_IDENTIFIER | insideCommand);
854  						sc.Forward(2);
855  					} else if (setWordStart.Contains(sc.chNext)) {	
856  						sc.SetState(SCE_SH_IDENTIFIER | insideCommand);
857  					}
858  				}
859  			} else if (sc.ch == '\"') {
860  				sc.SetState(SCE_SH_STRING | insideCommand);
861  				QuoteStack.Start(sc.ch, QuoteStyle::String, SCE_SH_DEFAULT);
862  			} else if (sc.ch == '\'') {
863  				QuoteStack.State = SCE_SH_DEFAULT;
864  				sc.SetState(SCE_SH_CHARACTER | insideCommand);
865  			} else if (sc.ch == '`') {
866  				sc.SetState(SCE_SH_BACKTICKS | insideCommand);
867  				QuoteStack.Start(sc.ch, QuoteStyle::Backtick, SCE_SH_DEFAULT);
868  			} else if (sc.ch == '$') {
869  				QuoteStack.Expand(sc, cmdState, true);
870  				continue;
871  			} else if (cmdState != CmdState::Arithmetic && sc.Match('<', '<')) {
872  				sc.SetState(SCE_SH_HERE_DELIM | insideCommand);
873  				HereDoc.State = 0;
874  				if (sc.GetRelative(2) == '-') {	
875  					HereDoc.Indent = true;
876  					sc.Forward();
877  				} else {
878  					HereDoc.Indent = false;
879  				}
880  			} else if (sc.ch == '-'	&&	
881  					   setSingleCharOp.Contains(sc.chNext) &&
882  					   !setWord.Contains(sc.GetRelative(2)) &&
883  					   IsASpace(sc.chPrev)) {
884  				sc.SetState(SCE_SH_WORD | insideCommand);
885  				sc.Forward();
886  			} else if (setBashOperator.Contains(sc.ch)) {
887  				bool isCmdDelim = false;
888  				sc.SetState(SCE_SH_OPERATOR | insideCommand);
889  				if (QuoteStack.Current.Style == QuoteStyle::Arithmetic || QuoteStack.Current.Style == QuoteStyle::CommandInside) {
890  					if (sc.ch == QuoteStack.Current.Down) {
891  						if (QuoteStack.CountDown(sc, cmdState)) {
892  							continue;
893  						}
894  					} else if (sc.ch == QuoteStack.Current.Up) {
895  						QuoteStack.Current.Count++;
896  					}
897  				}
898  				if (cmdState != CmdState::Arithmetic && sc.ch == '(' && sc.chNext != '(') {
899  					const int i = GlobScan(sc);
900  					if (i > 1) {
901  						sc.SetState(SCE_SH_IDENTIFIER | insideCommand);
902  						sc.Forward(i + 1);
903  						continue;
904  					}
905  				}
906  				if (cmdState == CmdState::Start
907  				 || cmdState == CmdState::Body) {
908  					if (sc.Match('(', '(')) {
909  						cmdState = CmdState::Arithmetic;
910  						sc.Forward();
911  					} else if (sc.Match('[', '[') && IsASpace(sc.GetRelative(2))) {
912  						cmdState = CmdState::Test;
913  						testExprType = TestExprType::DoubleBracket;
914  						sc.Forward();
915  					} else if (sc.ch == '[' && IsASpace(sc.chNext)) {
916  						cmdState = CmdState::Test;
917  						testExprType = TestExprType::SingleBracket;
918  					}
919  				}
920  				if (cmdState == CmdState::Word && sc.Match('(', '(')) {
921  					cmdState = CmdState::Arithmetic;
922  					sc.Forward(2);
923  					continue;
924  				}
925  				if (cmdState == CmdState::Start
926  				 || cmdState == CmdState::Body
927  				 || cmdState == CmdState::Word
928  				 || (cmdState == CmdState::Test && testExprType == TestExprType::Test)) {
929  					char s[10];
930  					s[0] = static_cast<char>(sc.ch);
931  					if (setBashOperator.Contains(sc.chNext)) {
932  						s[1] = static_cast<char>(sc.chNext);
933  						s[2] = '\0';
934  						isCmdDelim = cmdDelimiter.InList(s);
935  						if (isCmdDelim)
936  							sc.Forward();
937  					}
938  					if (!isCmdDelim) {
939  						s[1] = '\0';
940  						isCmdDelim = cmdDelimiter.InList(s);
941  					}
942  					if (isCmdDelim) {
943  						cmdState = CmdState::Delimiter;
944  						sc.Forward();
945  						continue;
946  					}
947  				}
948  				if (cmdState == CmdState::Arithmetic && sc.Match(')', ')')) {
949  					cmdState = CmdState::Body;
950  					sc.Forward();
951  				} else if (cmdState == CmdState::Test && IsASpace(sc.chPrev)) {
952  					if (sc.Match(']', ']') && testExprType == TestExprType::DoubleBracket) {
953  						sc.Forward();
954  						cmdState = CmdState::Body;
955  					} else if (sc.ch == ']' && testExprType == TestExprType::SingleBracket) {
956  						cmdState = CmdState::Body;
957  					}
958  				}
959  			}
960  		}
961  		sc.Forward();
962  	}
963  	sc.Complete();
964  	if (MaskCommand(sc.state) == SCE_SH_HERE_Q) {
965  		styler.ChangeLexerState(sc.currentPos, styler.Length());
966  	}
967  	sc.Complete();
968  }
969  void SCI_METHOD LexerBash::Fold(Sci_PositionU startPos, Sci_Position length, int, IDocument *pAccess) {
970  	if(!options.fold)
971  		return;
972  	LexAccessor styler(pAccess);
973  	const Sci_PositionU endPos = startPos + length;
974  	int visibleChars = 0;
975  	int skipHereCh = 0;
976  	Sci_Position lineCurrent = styler.GetLine(startPos);
977  	int levelPrev = styler.LevelAt(lineCurrent) & SC_FOLDLEVELNUMBERMASK;
978  	int levelCurrent = levelPrev;
979  	char chNext = styler[startPos];
980  	int styleNext = MaskCommand(styler.StyleIndexAt(startPos));
981  	char word[8] = { '\0' }; 
982  	unsigned int wordlen = 0;
983  	for (Sci_PositionU i = startPos; i < endPos; i++) {
984  		const char ch = chNext;
985  		chNext = styler.SafeGetCharAt(i + 1);
986  		const int style = styleNext;
987  		styleNext = MaskCommand(styler.StyleIndexAt(i + 1));
988  		const bool atEOL = (ch == '\r' && chNext != '\n') || (ch == '\n');
989  		if (options.foldComment && atEOL && IsCommentLine(lineCurrent, styler))
990  		{
991  			if (!IsCommentLine(lineCurrent - 1, styler)
992  				&& IsCommentLine(lineCurrent + 1, styler))
993  				levelCurrent++;
994  			else if (IsCommentLine(lineCurrent - 1, styler)
995  					 && !IsCommentLine(lineCurrent + 1, styler))
996  				levelCurrent--;
997  		}
998  		if (style == SCE_SH_WORD) {
999  			if ((wordlen + 1) < sizeof(word))
1000  				word[wordlen++] = ch;
1001  			if (styleNext != style) {
1002  				word[wordlen] = '\0';
1003  				wordlen = 0;
1004  				if (strcmp(word, "if") == 0 || strcmp(word, "case") == 0 || strcmp(word, "do") == 0) {
1005  					levelCurrent++;
1006  				} else if (strcmp(word, "fi") == 0 || strcmp(word, "esac") == 0 || strcmp(word, "done") == 0) {
1007  					levelCurrent--;
1008  				}
1009  			}
1010  		}
1011  		if (style == SCE_SH_OPERATOR) {
1012  			if (ch == '{') {
1013  				levelCurrent++;
1014  			} else if (ch == '}') {
1015  				levelCurrent--;
1016  			}
1017  		}
1018  		if (style == SCE_SH_HERE_DELIM) {
1019  			if (ch == '<' && chNext == '<') {
1020  				if (styler.SafeGetCharAt(i + 2) == '<') {
1021  					skipHereCh = 1;
1022  				} else {
1023  					if (skipHereCh == 0) {
1024  						levelCurrent++;
1025  					} else {
1026  						skipHereCh = 0;
1027  					}
1028  				}
1029  			}
1030  		} else if (style == SCE_SH_HERE_Q && styler.StyleAt(i+1) == SCE_SH_DEFAULT) {
1031  			levelCurrent--;
1032  		}
1033  		if (atEOL) {
1034  			int lev = levelPrev;
1035  			if (visibleChars == 0 && options.foldCompact)
1036  				lev |= SC_FOLDLEVELWHITEFLAG;
1037  			if ((levelCurrent > levelPrev) && (visibleChars > 0))
1038  				lev |= SC_FOLDLEVELHEADERFLAG;
1039  			if (lev != styler.LevelAt(lineCurrent)) {
1040  				styler.SetLevel(lineCurrent, lev);
1041  			}
1042  			lineCurrent++;
1043  			levelPrev = levelCurrent;
1044  			visibleChars = 0;
1045  		}
1046  		if (!isspacechar(ch))
1047  			visibleChars++;
1048  	}
1049  	const int flagsNext = styler.LevelAt(lineCurrent) & ~SC_FOLDLEVELNUMBERMASK;
1050  	styler.SetLevel(lineCurrent, levelPrev | flagsNext);
1051  }
1052  LexerModule lmBash(SCLEX_BASH, LexerBash::LexerFactoryBash, "bash", bashWordListDesc);
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexBash.cxx</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexBash.cxx</div>
                </div>
                <div class="column column_space"><pre><code>43  enum class TestExprType {
44  	Test,			
45  	DoubleBracket,	
46  	SingleBracket,	
47  };
48  enum class CommandSubstitution {
49  	Backtick,
50  	Inside,
51  	InsideTrack,
52  };
</pre></code></div>
                <div class="column column_space"><pre><code>48  enum class CommandSubstitution {
49  	Backtick,
50  	Inside,
51  	InsideTrack,
52  };
53  enum class QuoteStyle {
54  	Literal,		
55  	CString,		
56  	String,			
57  	LString,		
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    