
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 25, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-cord_ring_reader_test.cc</h3>
            <pre><code>1  #include <cstdlib>
2  #include <ctime>
3  #include <memory>
4  #include <random>
5  #include <sstream>
6  #include "gmock/gmock.h"
7  #include "gtest/gtest.h"
8  #include "absl/debugging/leak_check.h"
9  #include "absl/strings/internal/cord_internal.h"
10  #include "absl/strings/internal/cord_rep_ring.h"
11  #include "absl/strings/internal/cord_rep_ring_reader.h"
12  #include "absl/strings/string_view.h"
13  namespace absl {
14  ABSL_NAMESPACE_BEGIN
15  namespace cord_internal {
16  namespace {
17  using testing::Eq;
18  CordRep* MakeFlat(absl::string_view s) {
19    CordRepFlat* flat = CordRepFlat::New(s.length());
20    memcpy(flat->Data(), s.data(), s.length());
21    flat->length = s.length();
22    return flat;
23  }
24  CordRepRing* FromFlats(Span<absl::string_view const> flats) {
25    CordRepRing* ring = CordRepRing::Create(MakeFlat(flats[0]), flats.size() - 1);
26    for (int i = 1; i < flats.size(); ++i) {
27      ring = CordRepRing::Append(ring, MakeFlat(flats[i]));
28    }
29    return ring;
30  }
31  std::array<absl::string_view, 12> TestFlats() {
32    return {"abcdefghij", "klmnopqrst", "uvwxyz",     "ABCDEFGHIJ",
33            "KLMNOPQRST", "UVWXYZ",     "1234567890", "~!@#$%^&*()_",
34            "+-=",        "[]\\{}|;':", ",/<>?",      "."};
35  }
36  TEST(CordRingReaderTest, DefaultInstance) {
37    CordRepRingReader reader;
<span onclick='openModal()' class='match'>38    EXPECT_FALSE(static_cast<bool>(reader));
39    EXPECT_THAT(reader.ring(), Eq(nullptr));
40  #ifndef NDEBUG
</span>41    EXPECT_DEATH_IF_SUPPORTED(reader.length(), ".*");
42    EXPECT_DEATH_IF_SUPPORTED(reader.consumed(), ".*");
43    EXPECT_DEATH_IF_SUPPORTED(reader.remaining(), ".*");
44    EXPECT_DEATH_IF_SUPPORTED(reader.Next(), ".*");
45    EXPECT_DEATH_IF_SUPPORTED(reader.Seek(0), ".*");
46  #endif
47  }
48  TEST(CordRingReaderTest, Reset) {
49    CordRepRingReader reader;
50    auto flats = TestFlats();
51    CordRepRing* ring = FromFlats(flats);
52    absl::string_view first = reader.Reset(ring);
53    EXPECT_THAT(first, Eq(flats[0]));
54    EXPECT_TRUE(static_cast<bool>(reader));
55    EXPECT_THAT(reader.ring(), Eq(ring));
56    EXPECT_THAT(reader.index(), Eq(ring->head()));
57    EXPECT_THAT(reader.node(), Eq(ring->entry_child(ring->head())));
58    EXPECT_THAT(reader.length(), Eq(ring->length));
59    EXPECT_THAT(reader.consumed(), Eq(flats[0].length()));
60    EXPECT_THAT(reader.remaining(), Eq(ring->length - reader.consumed()));
61    reader.Reset();
62    EXPECT_FALSE(static_cast<bool>(reader));
63    EXPECT_THAT(reader.ring(), Eq(nullptr));
64    CordRep::Unref(ring);
65  }
66  TEST(CordRingReaderTest, Next) {
67    CordRepRingReader reader;
68    auto flats = TestFlats();
69    CordRepRing* ring = FromFlats(flats);
70    CordRepRing::index_type head = ring->head();
71    reader.Reset(ring);
72    size_t consumed = reader.consumed();
73    size_t remaining = reader.remaining();
74    for (int i = 1; i < flats.size(); ++i) {
75      CordRepRing::index_type index = ring->advance(head, i);
76      consumed += flats[i].length();
77      remaining -= flats[i].length();
78      absl::string_view next = reader.Next();
79      ASSERT_THAT(next, Eq(flats[i]));
80      ASSERT_THAT(reader.index(), Eq(index));
81      ASSERT_THAT(reader.node(), Eq(ring->entry_child(index)));
82      ASSERT_THAT(reader.consumed(), Eq(consumed));
83      ASSERT_THAT(reader.remaining(), Eq(remaining));
84    }
85  #ifndef NDEBUG
86    EXPECT_DEATH_IF_SUPPORTED(reader.Next(), ".*");
87  #endif
88    CordRep::Unref(ring);
89  }
90  TEST(CordRingReaderTest, SeekForward) {
91    CordRepRingReader reader;
92    auto flats = TestFlats();
93    CordRepRing* ring = FromFlats(flats);
94    CordRepRing::index_type head = ring->head();
95    reader.Reset(ring);
96    size_t consumed = 0;
97    size_t remaining = ring->length;
98    for (int i = 0; i < flats.size(); ++i) {
99      CordRepRing::index_type index = ring->advance(head, i);
100      size_t offset = consumed;
101      consumed += flats[i].length();
102      remaining -= flats[i].length();
103      for (int off = 0; off < flats[i].length(); ++off) {
104        absl::string_view chunk = reader.Seek(offset + off);
105        ASSERT_THAT(chunk, Eq(flats[i].substr(off)));
106        ASSERT_THAT(reader.index(), Eq(index));
107        ASSERT_THAT(reader.node(), Eq(ring->entry_child(index)));
108        ASSERT_THAT(reader.consumed(), Eq(consumed));
109        ASSERT_THAT(reader.remaining(), Eq(remaining));
110      }
111    }
112    CordRep::Unref(ring);
113  }
114  TEST(CordRingReaderTest, SeekBackward) {
115    CordRepRingReader reader;
116    auto flats = TestFlats();
117    CordRepRing* ring = FromFlats(flats);
118    CordRepRing::index_type head = ring->head();
119    reader.Reset(ring);
120    size_t consumed = ring->length;
121    size_t remaining = 0;
122    for (int i = flats.size() - 1; i >= 0; --i) {
123      CordRepRing::index_type index = ring->advance(head, i);
124      size_t offset = consumed - flats[i].length();
125      for (int off = 0; off < flats[i].length(); ++off) {
126        absl::string_view chunk = reader.Seek(offset + off);
127        ASSERT_THAT(chunk, Eq(flats[i].substr(off)));
128        ASSERT_THAT(reader.index(), Eq(index));
129        ASSERT_THAT(reader.node(), Eq(ring->entry_child(index)));
130        ASSERT_THAT(reader.consumed(), Eq(consumed));
131        ASSERT_THAT(reader.remaining(), Eq(remaining));
132      }
133      consumed -= flats[i].length();
134      remaining += flats[i].length();
135    }
136  #ifndef NDEBUG
137    EXPECT_DEATH_IF_SUPPORTED(reader.Seek(ring->length), ".*");
138  #endif
139    CordRep::Unref(ring);
140  }
141  }  
142  }  
143  ABSL_NAMESPACE_END
144  }  
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-cord_ring_reader_test.cc</h3>
            <pre><code>1  #include <cstdlib>
2  #include <ctime>
3  #include <memory>
4  #include <random>
5  #include <sstream>
6  #include "gmock/gmock.h"
7  #include "gtest/gtest.h"
8  #include "absl/debugging/leak_check.h"
9  #include "absl/strings/internal/cord_internal.h"
10  #include "absl/strings/internal/cord_rep_ring.h"
11  #include "absl/strings/internal/cord_rep_ring_reader.h"
12  #include "absl/strings/string_view.h"
13  namespace absl {
14  ABSL_NAMESPACE_BEGIN
15  namespace cord_internal {
16  namespace {
17  using testing::Eq;
18  CordRep* MakeFlat(absl::string_view s) {
19    CordRepFlat* flat = CordRepFlat::New(s.length());
20    memcpy(flat->Data(), s.data(), s.length());
21    flat->length = s.length();
22    return flat;
23  }
24  CordRepRing* FromFlats(Span<absl::string_view const> flats) {
25    CordRepRing* ring = CordRepRing::Create(MakeFlat(flats[0]), flats.size() - 1);
26    for (int i = 1; i < flats.size(); ++i) {
27      ring = CordRepRing::Append(ring, MakeFlat(flats[i]));
28    }
29    return ring;
30  }
31  std::array<absl::string_view, 12> TestFlats() {
32    return {"abcdefghij", "klmnopqrst", "uvwxyz",     "ABCDEFGHIJ",
33            "KLMNOPQRST", "UVWXYZ",     "1234567890", "~!@#$%^&*()_",
34            "+-=",        "[]\\{}|;':", ",/<>?",      "."};
35  }
36  TEST(CordRingReaderTest, DefaultInstance) {
37    CordRepRingReader reader;
<span onclick='openModal()' class='match'>38    EXPECT_FALSE(static_cast<bool>(reader));
39    EXPECT_THAT(reader.ring(), Eq(nullptr));
40  #ifndef NDEBUG
</span>41    EXPECT_DEATH_IF_SUPPORTED(reader.length(), ".*");
42    EXPECT_DEATH_IF_SUPPORTED(reader.consumed(), ".*");
43    EXPECT_DEATH_IF_SUPPORTED(reader.remaining(), ".*");
44    EXPECT_DEATH_IF_SUPPORTED(reader.Next(), ".*");
45    EXPECT_DEATH_IF_SUPPORTED(reader.Seek(0), ".*");
46  #endif
47  }
48  TEST(CordRingReaderTest, Reset) {
49    CordRepRingReader reader;
50    auto flats = TestFlats();
51    CordRepRing* ring = FromFlats(flats);
52    absl::string_view first = reader.Reset(ring);
53    EXPECT_THAT(first, Eq(flats[0]));
54    EXPECT_TRUE(static_cast<bool>(reader));
55    EXPECT_THAT(reader.ring(), Eq(ring));
56    EXPECT_THAT(reader.index(), Eq(ring->head()));
57    EXPECT_THAT(reader.node(), Eq(ring->entry_child(ring->head())));
58    EXPECT_THAT(reader.length(), Eq(ring->length));
59    EXPECT_THAT(reader.consumed(), Eq(flats[0].length()));
60    EXPECT_THAT(reader.remaining(), Eq(ring->length - reader.consumed()));
61    reader.Reset();
62    EXPECT_FALSE(static_cast<bool>(reader));
63    EXPECT_THAT(reader.ring(), Eq(nullptr));
64    CordRep::Unref(ring);
65  }
66  TEST(CordRingReaderTest, Next) {
67    CordRepRingReader reader;
68    auto flats = TestFlats();
69    CordRepRing* ring = FromFlats(flats);
70    CordRepRing::index_type head = ring->head();
71    reader.Reset(ring);
72    size_t consumed = reader.consumed();
73    size_t remaining = reader.remaining();
74    for (int i = 1; i < flats.size(); ++i) {
75      CordRepRing::index_type index = ring->advance(head, i);
76      consumed += flats[i].length();
77      remaining -= flats[i].length();
78      absl::string_view next = reader.Next();
79      ASSERT_THAT(next, Eq(flats[i]));
80      ASSERT_THAT(reader.index(), Eq(index));
81      ASSERT_THAT(reader.node(), Eq(ring->entry_child(index)));
82      ASSERT_THAT(reader.consumed(), Eq(consumed));
83      ASSERT_THAT(reader.remaining(), Eq(remaining));
84    }
85  #ifndef NDEBUG
86    EXPECT_DEATH_IF_SUPPORTED(reader.Next(), ".*");
87  #endif
88    CordRep::Unref(ring);
89  }
90  TEST(CordRingReaderTest, SeekForward) {
91    CordRepRingReader reader;
92    auto flats = TestFlats();
93    CordRepRing* ring = FromFlats(flats);
94    CordRepRing::index_type head = ring->head();
95    reader.Reset(ring);
96    size_t consumed = 0;
97    size_t remaining = ring->length;
98    for (int i = 0; i < flats.size(); ++i) {
99      CordRepRing::index_type index = ring->advance(head, i);
100      size_t offset = consumed;
101      consumed += flats[i].length();
102      remaining -= flats[i].length();
103      for (int off = 0; off < flats[i].length(); ++off) {
104        absl::string_view chunk = reader.Seek(offset + off);
105        ASSERT_THAT(chunk, Eq(flats[i].substr(off)));
106        ASSERT_THAT(reader.index(), Eq(index));
107        ASSERT_THAT(reader.node(), Eq(ring->entry_child(index)));
108        ASSERT_THAT(reader.consumed(), Eq(consumed));
109        ASSERT_THAT(reader.remaining(), Eq(remaining));
110      }
111    }
112    CordRep::Unref(ring);
113  }
114  TEST(CordRingReaderTest, SeekBackward) {
115    CordRepRingReader reader;
116    auto flats = TestFlats();
117    CordRepRing* ring = FromFlats(flats);
118    CordRepRing::index_type head = ring->head();
119    reader.Reset(ring);
120    size_t consumed = ring->length;
121    size_t remaining = 0;
122    for (int i = flats.size() - 1; i >= 0; --i) {
123      CordRepRing::index_type index = ring->advance(head, i);
124      size_t offset = consumed - flats[i].length();
125      for (int off = 0; off < flats[i].length(); ++off) {
126        absl::string_view chunk = reader.Seek(offset + off);
127        ASSERT_THAT(chunk, Eq(flats[i].substr(off)));
128        ASSERT_THAT(reader.index(), Eq(index));
129        ASSERT_THAT(reader.node(), Eq(ring->entry_child(index)));
130        ASSERT_THAT(reader.consumed(), Eq(consumed));
131        ASSERT_THAT(reader.remaining(), Eq(remaining));
132      }
133      consumed -= flats[i].length();
134      remaining += flats[i].length();
135    }
136  #ifndef NDEBUG
137    EXPECT_DEATH_IF_SUPPORTED(reader.Seek(ring->length), ".*");
138  #endif
139    CordRep::Unref(ring);
140  }
141  }  
142  }  
143  ABSL_NAMESPACE_END
144  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-cord_ring_reader_test.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-cord_ring_reader_test.cc</div>
                </div>
                <div class="column column_space"><pre><code>38    EXPECT_FALSE(static_cast<bool>(reader));
39    EXPECT_THAT(reader.ring(), Eq(nullptr));
40  #ifndef NDEBUG
</pre></code></div>
                <div class="column column_space"><pre><code>38    EXPECT_FALSE(static_cast<bool>(reader));
39    EXPECT_THAT(reader.ring(), Eq(nullptr));
40  #ifndef NDEBUG
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    