
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 10.286458333333332%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-fa.cpp</h3>
            <pre><code>1  #include "fa.h"
2  PFaTrans TFaTrans::LoadCustomXml(const PXmlTok& XmlTok){
3    IAssert(XmlTok->IsTag("Trans"));
4    TStr MsgNm=XmlTok->GetArgVal("Msg");
5    TStr DstStateNm=XmlTok->GetArgVal("DstState");
6    TStr ScriptStr;
7    if (XmlTok->IsSubTag("Script")){
8      ScriptStr=XmlTok->GetTagTok("Script")->GetTokStr(false);}
9    PFaTrans Trans=TFaTrans::New(MsgNm, DstStateNm, ScriptStr);
10    return Trans;
11  }
<span onclick='openModal()' class='match'>12  void TFaTrans::_ChangeStateNm(const TStr& OldStateNm, const TStr& NewStateNm){
13    if (SrcStateNm==OldStateNm){SrcStateNm=NewStateNm;}
14    if (DstStateNm==OldStateNm){DstStateNm=NewStateNm;}
15  }
</span>16  PFaState TFaState::LoadCustomXml(const PXmlTok& XmlTok){
17    IAssert(XmlTok->IsTag("State"));
18    TStr Nm=XmlTok->GetArgVal("Nm");
19    TStr ScriptStr;
20    if (XmlTok->IsSubTag("Script")){
21      ScriptStr=XmlTok->GetTagTok("Script")->GetTokStr(false);}
22    TXmlTokV TransTokV; XmlTok->GetTagTokV("Trans", TransTokV);
23    TFaTransV TransV;
24    for (int TransN=0; TransN<TransTokV.Len(); TransN++){
25      PFaTrans Trans=TFaTrans::LoadCustomXml(TransTokV[TransN]);
26      TransV.Add(Trans);
27    }
28    PFaState State=TFaState::New(Nm, ScriptStr);
29    for (int TransN=0; TransN<TransV.Len(); TransN++){
30      State->AddTrans(TransV[TransN]);}
31    return State;
32  }
33  void TFaState::_ChangeStateNm(const TStr& OldStateNm, const TStr& NewStateNm){
34    if (Nm==OldStateNm){Nm=NewStateNm;}
35    for (int TransN=0; TransN<FaTransV.Len(); TransN++){
36      FaTransV[TransN]->_ChangeStateNm(OldStateNm, NewStateNm);}
37  }
38  bool TFaState::IsTransTo(const TStr& StateNm) const {
39    for (int TransN=0; TransN<FaTransV.Len(); TransN++){
40      if (FaTransV[TransN]->GetDstStateNm()==StateNm){return true;}
41    }
42    return false;
43  }
44  void TFaState::DelTrans(const PFaTrans& Trans){
45    for (int TransN=FaTransV.Len()-1; TransN>=0; TransN--){
46      if (FaTransV[TransN]()==Trans()){
47        FaTransV.Del(TransN);}
48    }
49  }
50  void TFaState::DelTransIfDstState(const TStr& DstStateNm){
51    for (int TransN=FaTransV.Len()-1; TransN>=0; TransN--){
52      if (FaTransV[TransN]->GetDstStateNm()==DstStateNm){
53        FaTransV.Del(TransN);}
54    }
55  }
56  TStr TFaDef::GetNewStateNm() const {
57    int StateN=0;
58    while (IsState(TInt::GetStr(StateN, "State%d"))){StateN++;}
59    return TInt::GetStr(StateN, "State%d");
60  }
61  void TFaDef::ChangeStateNm(const TStr& OldStateNm, const TStr& NewStateNm){
62    if (OldStateNm==NewStateNm){return;}
63    PFaState State=GetState(OldStateNm);
64    IAssert(!IsState(NewStateNm));
65    IAssert(State()!=GetStartState()());
66    IAssert(State()!=GetEndState()());
67    TFaStateV StateV; GetStateV(StateV);
68    for (int StateN=0; StateN<StateV.Len(); StateN++){
69      StateV[StateN]->_ChangeStateNm(OldStateNm, NewStateNm);}
70    for (int TransN=0; TransN<GlobalTransV.Len(); TransN++){
71      GlobalTransV[TransN]->_ChangeStateNm(OldStateNm, NewStateNm);}
72    NmToFaStateH.DelKey(OldStateNm);
73    NmToFaStateH.AddDat(State->GetNm(), State);
74  }
75  void TFaDef::DelState(const TStr& StateNm){
76    IAssert(StateNm!=GetStartState()->GetNm());
77    IAssert(StateNm!=GetEndState()->GetNm());
78    PFaState State=GetState(StateNm);
79    TFaStateV StateV; GetStateV(StateV);
80    for (int StateN=0; StateN<StateV.Len(); StateN++){
81      StateV[StateN]->DelTransIfDstState(StateNm);}
82    for (int TransN=GlobalTransV.Len()-1; TransN>=0; TransN--){
83      PFaTrans Trans=GlobalTransV[TransN];
84      if ((Trans->GetSrcStateNm()==StateNm)||(Trans->GetDstStateNm()==StateNm)){
85        GlobalTransV.Del(TransN);}
86    }
87    NmToFaStateH.DelKey(StateNm);
88  }
89  TStr TFaDef::GetStateNmAtXY(const double& X, const double& Y) const {
90    TFaStateV StateV; GetStateV(StateV);
91    for (int StateN=StateV.Len()-1; StateN>=0; StateN--){
92      if (StateV[StateN]->GetRect().IsXYIn(X, Y)){
93        return StateV[StateN]->GetNm();}
94    }
95    return "";
96  }
97  void TFaDef::DelTrans(const PFaTrans& Trans){
98    TFaStateV StateV; GetStateV(StateV);
99    for (int StateN=0; StateN<StateV.Len(); StateN++){
100      StateV[StateN]->DelTrans(Trans);}
101    for (int TransN=GlobalTransV.Len()-1; TransN>=0; TransN--){
102      if (GlobalTransV[TransN]()==Trans()){
103        GlobalTransV.Del(TransN);}
104    }
105  }
106  PFaTrans TFaDef::GetTransAtXY(const double& X, const double& Y) const {
107    TFaStateV StateV; GetStateV(StateV);
108    for (int StateN=0; StateN<StateV.Len(); StateN++){
109      PFaState SrcFaState=StateV[StateN];
110      for (int TransN=0; TransN<SrcFaState->GetTranss(); TransN++){
111        PFaTrans FaTrans=SrcFaState->GetTrans(TransN);
112        if (FaTrans->GetRect().IsXYIn(X, Y)){return FaTrans;}
113      }
114    }
115    return NULL;
116  }
117  const TStr TFaDef::FaDefVerStr="Automaton Definition / 09.03.2004";
118  const TStr TFaDef::DfFNm="Automaton.Xml";
119  const TStr TFaDef::FExt=".Xml";
120  PFaDef TFaDef::LoadBin(const TStr& FNm){
121    PSIn SIn=TFIn::New(FNm);
122    char* VerCStr;
123    SIn->Load(VerCStr, FaDefVerStr.Len(), FaDefVerStr.Len());
124    if (FaDefVerStr!=VerCStr){
125      TExcept::Throw("Invalid version of Faulation Definition file.");}
126    return TFaDef::Load(*SIn);
127  }
128  void TFaDef::SaveBin(const TStr& FNm) const {
129    PSOut SOut=TFOut::New(FNm);
130    SOut->Save(FaDefVerStr.CStr(), FaDefVerStr.Len());
131    Save(*SOut);
132  }
133  PFaDef TFaDef::LoadXml(const TStr& FNm){
134    PFaDef FaDef=TFaDef::New();
135    XLoadFromFile(FNm, "FaDef", *FaDef);
136    return FaDef;
137  }
138  void TFaDef::SaveXml(const TStr& FNm){
139    PSOut SOut=TFOut::New(FNm);
140    SaveXml(*SOut, "FaDef");
141  }
142  PFaDef TFaDef::LoadCustomXml(const TStr& FNm){
143    PFaDef FaDef=TFaDef::New();
144    PXmlDoc XmlDoc=TXmlDoc::LoadTxt(FNm);
145    TXmlTokV GlobalTransTokV;
146    XmlDoc->GetTagTokV("FinAut|Trans", GlobalTransTokV);
147    for (int TransN=0; TransN<GlobalTransTokV.Len(); TransN++){
148      PFaTrans Trans=TFaTrans::LoadCustomXml(GlobalTransTokV[TransN]);
149      FaDef->AddGlobalTrans(Trans);
150    }
151    TXmlTokV StateTokV; XmlDoc->GetTagTokV("FinAut|State", StateTokV);
152    for (int StateN=0; StateN<StateTokV.Len(); StateN++){
153      PFaState State=TFaState::LoadCustomXml(StateTokV[StateN]);
154      FaDef->AddState(State);
155    }
156    TStr StartStateNm=XmlDoc->GetTagVal("StartState", false);
157    FaDef->PutStartState(FaDef->GetState(StartStateNm));
158    TStr EndStateNm=XmlDoc->GetTagVal("EndState", false);
159    FaDef->PutEndState(FaDef->GetState(EndStateNm));
160    return FaDef;
161  }
162  void TFaExpEnv::PutVarVal(const TStr& VarNm, const PExpVal& ExpVal){
163    VarNmToValH.AddDat(VarNm.GetUc(), ExpVal);
164  }
165  PExpVal TFaExpEnv::GetVarVal(const TStr& VarNm, bool& IsVar){
166    int VarNmToValP;
167    if (VarNmToValH.IsKey(VarNm.GetUc(), VarNmToValP)){
168      IsVar=true; return VarNmToValH[VarNmToValP];
169    } else {
170      printf("Variable '%s' does not exist\n", VarNm.CStr());
171      IsVar=false; return TExpVal::GetUndefExpVal();
172    }
173  }
174  PExpVal TFaExpEnv::GetFuncVal(
175   const TStr& FuncNm, const TExpValV& ArgValV, bool& IsFunc){
176    IsFunc=true; PExpVal ExpVal=TExpVal::GetUndefExpVal();
177    if (TExpEnv::IsFuncOk("Assign", efatStrAny, FuncNm, ArgValV)){
178      TStr VarNm=ArgValV[0]->GetStrVal();
179      PutVarVal(VarNm, ArgValV[1]);
180    } else
181    if (TExpEnv::IsFuncOk("OnProb", efatFlt, FuncNm, ArgValV)){
182      double RqPrb=ArgValV[0]->GetFltVal();
183      double Prb=GetVarVal("_Prb")->GetFltVal();
184      double PrbUsed=GetVarVal("_PrbUsed")->GetFltVal();
185      bool Ok=(PrbUsed<=Prb)&&(Prb<PrbUsed+RqPrb);
186      PutVarVal("_PrbUsed", TExpVal::New(PrbUsed+RqPrb));
187      ExpVal=TExpVal::New(double(Ok)); IsFunc=true;
188    } else
189    if (TExpEnv::IsFuncOk("AfterTime", efatFlt, FuncNm, ArgValV)){
190      double MxSecs=ArgValV[0]->GetFltVal();
191      TSecTm StartStateTm=FaExe->GetActStateStartTm();
192      bool Ok=TSecTm::GetDSecs(StartStateTm, TSecTm::GetCurTm())>MxSecs;
193      ExpVal=TExpVal::New(double(Ok)); IsFunc=true;
194    } else
195    if (TExpEnv::IsFuncOk("SendMsg", efatStr, FuncNm, ArgValV)){
196      TStr MsgNm=ArgValV[0]->GetStrVal();
197      PFaMsg Msg=TFaMsg::New(MsgNm);
198      FaExe->PushMsg(Msg);
199    } else
200    if (TExpEnv::IsFuncOk("SaveMsgArg", efatStrFlt, FuncNm, ArgValV)){
201      TStr VarNm=ArgValV[0]->GetStrVal();
202      int ArgN=ArgValV[1]->GetFltValAsInt()-1;
203      PFaMsg Msg=FaExe->GetLastMsg();
204      if ((!Msg.Empty())&&(0<=ArgN)&&(ArgN<Msg->GetArgs())){
205        TStr MsgArgValStr=Msg->GetArgVal(ArgN);
206        PExpVal ExpVal=TExpVal::New(MsgArgValStr);
207        PutVarVal(VarNm, ExpVal);
208        printf("Assign '%s'='%s'\n", VarNm.CStr(), MsgArgValStr.CStr());
209      }
210    } else
211    if (TExpEnv::IsFuncOk("SaveMsgArg", efatStr, FuncNm, ArgValV)){
212      TStr VarNm=ArgValV[0]->GetStrVal();
213      int ArgN=0;
214      PFaMsg Msg=FaExe->GetLastMsg();
215      if ((!Msg.Empty())&&(0<=ArgN)&&(ArgN<Msg->GetArgs())){
216        TStr MsgArgValStr=Msg->GetArgVal(ArgN);
217        PExpVal ExpVal=TExpVal::New(MsgArgValStr);
218        PutVarVal(VarNm, ExpVal);
219        printf("Assign '%s'='%s'\n", VarNm.CStr(), MsgArgValStr.CStr());
220      }
221    } else
222    if (TExpEnv::IsFuncOk("PlayIntro", efatStr, FuncNm, ArgValV)){
223      TStr CallNumStr=ArgValV[0]->GetStrVal();
224      printf(".....Playing Intro for '%s'.....\n", CallNumStr.CStr());
225    } else
226    if (TExpEnv::IsFuncOk("PlayCm", efatStrStr, FuncNm, ArgValV)){
227      TStr CallNumStr=ArgValV[0]->GetStrVal();
228      TStr CmNm=ArgValV[1]->GetStrVal();
229      printf(".....Playing Command '%s' for '%s'.....\n",
230       CmNm.CStr(), CallNumStr.CStr());
231    } else {
232      printf("Bad env. function call %s/%d\n", FuncNm.CStr(), ArgValV.Len());
233      IsFunc=false;
234    }
235    return ExpVal;
236  }
237  PExpVal TFaExe::EvalExpStr(const TStr& ExpStr){
238    bool Ok; TStr MsgStr; bool DbgP; TStr DbgStr; PExpVal ExpVal;
239    PExp Exp=TExp::LoadTxt(ExpStr, Ok, MsgStr);
240    if (Ok){
241      ExpVal=Exp->Eval(Ok, MsgStr, DbgP, DbgStr, ExpEnv);
242      if (!Ok){Notify->OnNotify(ntErr, MsgStr);}
243    } else {
244      Notify->OnNotify(ntErr, MsgStr);
245      ExpVal=TExpVal::GetUndefExpVal();
246    }
247    return ExpVal;
248  }
249  TFaExe::TFaExe(const PFaDef& _FaDef, const PNotify& _Notify):
250    FaDef(_FaDef), Notify(_Notify),
251    ActState(FaDef->GetStartState()), ActTrans(),
252    ActStateStartTm(TSecTm::GetCurTm()), MsgQ(),
253    ExpEnv(TFaExpEnv::New(this)),
254    LastMsg(){
255    Notify->OnNotify(ntInfo, TStr("Starting at state: ")+ActState->GetNm());
256    if (!ActState->GetScriptStr().Empty()){
257      EvalExpStr(ActState->GetScriptStr());
258    }
259  }
260  TFaExe::~TFaExe(){
261    Notify->OnNotify(ntInfo, TStr("Terminating at state: ")+ActState->GetNm());
262  }
263  void TFaExe::ExeStep(){
264    double Prb=ExpEnv->GetRnd().GetUniDev();
265    ExpEnv->PutVarVal("_Prb", TExpVal::New(Prb));
266    ExpEnv->PutVarVal("_PrbUsed", TExpVal::New(0));
267    TFaTransV EmptyTransV; TFaTransV CondTransV;
268    for (int TransN=0; TransN<ActState->GetTranss(); TransN++){
269      PFaTrans Trans=ActState->GetTrans(TransN);
270      if (Trans->GetCondStr().GetTrunc().Empty()){EmptyTransV.Add(Trans);}
271      else {CondTransV.Add(Trans);}
272    }
273    PFaState NewActState; ActTrans=NULL;
274    for (int CondTransN=0; CondTransN<CondTransV.Len(); CondTransN++){
275      PFaTrans CondTrans=CondTransV[CondTransN];
276      PExpVal ExpVal=EvalExpStr(CondTrans->GetCondStr());
277      if (ExpVal->GetFltVal()!=0){
278        ActTrans=CondTrans;
279        TStr NewActStateNm=CondTransV[CondTransN]->GetDstStateNm();
280        if (FaDef->IsState(NewActStateNm)){
281          NewActState=FaDef->GetState(NewActStateNm);
282        } else {
283          Notify->OnNotify(ntErr, TStr("Invalid state name (")+NewActStateNm+")");
284        }
285        break;
286      }
287    }
288    if (NewActState.Empty()){
289      if (EmptyTransV.Len()>0){
290        ActTrans=EmptyTransV[0];
291        TStr NewActStateNm=ActTrans->GetDstStateNm();
292        if (FaDef->IsState(NewActStateNm)){
293          NewActState=FaDef->GetState(NewActStateNm);
294        } else {
295          Notify->OnNotify(ntErr, TStr("Invalid state name (")+NewActStateNm+")");
296        }
297      }
298    }
299    TStr OldStateNm=ActState->GetNm();
300    if (!NewActState.Empty()){
301      ActState=NewActState; ActStateStartTm=TSecTm::GetCurTm();
302      if (!ActState->GetScriptStr().Empty()){
303        EvalExpStr(ActState->GetScriptStr());
304      }
305      TStr NewStateNm=ActState->GetNm();
306      Notify->OnNotify(ntInfo, TStr("Transition: ")+OldStateNm+" -> "+NewStateNm);
307    }
308  }
309  void TFaExe::SendMsg(const PFaMsg& Msg){
310    if (!Msg.Empty()){
311      MsgQ.Push(Msg);}
312    while ((ActState()!=FaDef->GetEndState()())&&(!MsgQ.Empty())){
313      if (!MsgQ.Empty()){
314        LastMsg=MsgQ.Top(); MsgQ.Pop();
315        printf("Msg: '%s'\n", LastMsg->GetNm()());
316        PFaTrans Trans;/&bsol;**=FaDef->GetTrans(State, LastMsg);
317        if (!Trans.Empty()){
318          if (!Trans->GetScriptStr().Empty()){
319            bool Ok; TStr MsgStr;
320            TExp::LoadAndEvalExpL(Trans->GetScriptStr(), Ok, MsgStr, ExpEnv);
321          }
322          ActState=FaDef->GetState(Trans->GetDstStateNm());
323          if (!ActState->GetScriptStr().Empty()){
324            bool Ok; TStr MsgStr;
325            TExp::LoadAndEvalExpL(ActState->GetScriptStr(), Ok, MsgStr, ExpEnv);
326          }
327        } else {
328          printf("No transition for Msg: '%s'\n", LastMsg->GetNm()());
329        }
330      }
331      printf("State: '%s'\n", ActState->GetNm().CStr());
332    }
333  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-soap.cpp</h3>
            <pre><code>1  void TSoapTb::Append(const PSoapTb& SoapTb){
2    for (int RowN=0; RowN<SoapTb->GetRows(); RowN++){
3      AddRow();
4      for (int ColN=0; ColN<SoapTb->GetCols(); ColN++){
5        TStr ColNm, ColVal;
6        if (SoapTb->IsGetColNmVal(RowN, ColN, ColNm, ColVal)){
7          AddVal(ColNm, ColVal);
8        }
9      }
10    }
11  }
12  void TSoapTb::GetValV(const int& ColN, TStrV& ValStrV) const {
13    ValStrV.Clr();
14    int Rows=GetRows();
15    for (int RowN=0; RowN<Rows; RowN++){
16      ValStrV.Add(GetVal(RowN, ColN));
17    }
18  }
19  void TSoapTb::GetValPrV(const int& ColN1, const int& ColN2, TStrPrV& ValStrPrV) const {
20    ValStrPrV.Clr();
21    int Rows=GetRows();
22    for (int RowN=0; RowN<Rows; RowN++){
23      ValStrPrV.Add(TStrPr(GetVal(RowN, ColN1), GetVal(RowN, ColN2)));
24    }
25  }
26  int TSoapTb::GetRowN(const TStr& WhereColNm, const TStr& WhereValStr) const {
27    int Rows=GetRows();
28    for (int RowN=0; RowN<Rows; RowN++){
29      int RowVals=GetRowVals(RowN);
30      TStr ColNm; TStr ValStr;
31      for (int ValN=0; ValN<RowVals; ValN++){
32        GetColNmVal(RowN, ValN, ColNm, ValStr);
33        if ((ColNm==WhereColNm)&&(ValStr==WhereValStr)){
34          return RowN;
35        }
36      }
37    }
38    return -1;
39  }
40  void TSoapTb::SelectValStrV(const TStr& SelColNm, TStrV& SelValStrV,
41   const TStr& WhereColNm, const TStr& WhereValStr) const {
42    SelValStrV.Clr();
43    int Rows=GetRows();
44    for (int RowN=0; RowN<Rows; RowN++){
45      int RowVals=GetRowVals(RowN);
46      TStr ColNm; TStr ValStr;
47      TStr CurSelValStr; TStr CurWhereValStr;
<span onclick='openModal()' class='match'>48      for (int ValN=0; ValN<RowVals; ValN++){
49        GetColNmVal(RowN, ValN, ColNm, ValStr);
50        if (ColNm==SelColNm){CurSelValStr=ValStr;}
51        if (ColNm==WhereColNm){CurWhereValStr=ValStr;}
52      }
</span>53      if (CurWhereValStr==WhereValStr){
54        SelValStrV.Add(CurSelValStr);
55      }
56    }
57  }
58  void TSoapTb::SelectValStrV(const TStr& SelColNm, TStrV& SelValStrV,
59   const TStr& WhereColNm1, const TStr& WhereValStr1,
60   const TStr& WhereColNm2, const TStr& WhereValStr2) const {
61    SelValStrV.Clr();
62    int Rows=GetRows();
63    for (int RowN=0; RowN<Rows; RowN++){
64      int RowVals=GetRowVals(RowN);
65      TStr ColNm; TStr ValStr;
66      TStr CurSelValStr; TStr CurWhereValStr1; TStr CurWhereValStr2;
67      for (int ValN=0; ValN<RowVals; ValN++){
68        GetColNmVal(RowN, ValN, ColNm, ValStr);
69        if (ColNm==SelColNm){
70          CurSelValStr=ValStr;}
71        if (ColNm==WhereColNm1){
72          CurWhereValStr1=ValStr;}
73        if (ColNm==WhereColNm2){
74          CurWhereValStr2=ValStr;}
75      }
76      if ((CurWhereValStr1==WhereValStr1)&&(CurWhereValStr2==WhereValStr2)){
77        SelValStrV.Add(CurSelValStr);
78      }
79    }
80  }
81  void TSoapTb::SelectValStr(const TStr& SelColNm, TStr& SelValStr,
82   const TStr& WhereColNm1, const TStr& WhereValStr1,
83   const TStr& WhereColNm2, const TStr& WhereValStr2) const {
84    TStrV SelValStrV;
85    SelectValStrV(SelColNm, SelValStrV, WhereColNm1, WhereValStr1, WhereColNm2, WhereValStr2);
86    if (SelValStrV.Empty()){SelValStr="";}
87    else {SelValStr=SelValStrV[0];}
88  }
89  void TSoapTb::SelectValStr(const TStr& SelColNm, TStr& SelValStr,
90   const TStr& WhereColNm, const TStr& WhereValStr) const {
91    TStrV SelValStrV;
92    SelectValStrV(SelColNm, SelValStrV, WhereColNm, WhereValStr);
93    if (SelValStrV.Empty()){SelValStr="";}
94    else {SelValStr=SelValStrV[0];}
95  }
96  void TSoapTb::Dump(const TStr& FNm) const {
97    TStr D;
98    for (int ColN=0; ColN<GetCols(); ColN++){
99      D+="C"+TInt::GetStr(ColN)+":["+GetColNm(ColN)+"]";}
100    D+="\n";
101    for (int RowN=0; RowN<GetRows(); RowN++){
102      D+="R"+TInt::GetStr(RowN)+":";
103      int Vals=GetRowVals(RowN); TStr ColNm; TStr ValStr;
104      for (int ValN=0; ValN<Vals; ValN++){
105        GetColNmVal(RowN, ValN, ColNm, ValStr);
106        D+=" ["+ColNm+":"+ValStr+"]";
107      }
108      D+="\n";
109    }
110    TFOut F(FNm); F.PutStr(D);
111  }
112  TSoapEnv::TSoapEnv(const TStrPrV& FldNmValPrV):
113    FldNmToValH(), FldNmToValVH(), FldNmToSoapTbH(){
114    int Flds=FldNmValPrV.Len(); int FldN=0;
115    while (FldN<Flds){
116      if (TSoap::IsVecFld(FldN, FldNmValPrV)){
117        TStr FldNm; TStrV FldValV;
118        FldN=TSoap::GetVecFld(FldN, FldNm, FldValV, FldNmValPrV);
119        FldNmToValVH.AddDat(FldNm, FldValV);
120      } else
121      if (TSoap::IsTbFld(FldN, FldNmValPrV)){
122        TStr FldNm; PSoapTb SoapTb;
123        FldN=TSoap::GetTbFld(FldN, FldNm, SoapTb, FldNmValPrV);
124        FldNmToSoapTbH.AddDat(FldNm, SoapTb);
125      } else {
126        TStr FldNm=FldNmValPrV[FldN].Val1;
127        TStr FldVal=FldNmValPrV[FldN].Val2;
128        FldNmToValH.AddDat(FldNm, FldVal);
129        FldN++;
130      }
131    }
132  }
133  void TSoapEnv::CopySoapTbH(const TSoapEnv& SoapEnv){
134    FldNmToSoapTbH.Clr();
135    int KeyId=SoapEnv.FldNmToSoapTbH.FFirstKeyId();
136    while (SoapEnv.FldNmToSoapTbH.FNextKeyId(KeyId)){
137      TStr TbNm; PSoapTb SrcSoapTb;
138      SoapEnv.FldNmToSoapTbH.GetKeyDat(KeyId, TbNm, SrcSoapTb);
139      PSoapTb DestSoapTb=PSoapTb(new TSoapTb(*SrcSoapTb));
140      FldNmToSoapTbH.AddDat(TbNm, DestSoapTb);
141    }
142  }
143  void TSoapEnv::MergeSoapEnv(const PSoapEnv& SoapEnv, const bool& AppendSoapTbP){
144    {int KeyId=SoapEnv->FldNmToValH.FFirstKeyId();
145    while (SoapEnv->FldNmToValH.FNextKeyId(KeyId)){
146      TStr FldNm=SoapEnv->FldNmToValH.GetKey(KeyId);
147      TStr FldVal=SoapEnv->FldNmToValH[KeyId];
148      FldNmToValH.AddDat(FldNm, FldVal);
149    }}
150    {int KeyId=SoapEnv->FldNmToValVH.FFirstKeyId();
151    while (SoapEnv->FldNmToValVH.FNextKeyId(KeyId)){
152      TStr FldNm=SoapEnv->FldNmToValVH.GetKey(KeyId);
153      TStrV& FldValV=SoapEnv->FldNmToValVH[KeyId];
154      FldNmToValVH.AddDat(FldNm, FldValV);
155    }}
156    {int KeyId=SoapEnv->FldNmToSoapTbH.FFirstKeyId();
157    while (SoapEnv->FldNmToSoapTbH.FNextKeyId(KeyId)){
158      TStr FldNm=SoapEnv->FldNmToSoapTbH.GetKey(KeyId);
159      PSoapTb SoapTb=SoapEnv->FldNmToSoapTbH[KeyId];
160      if (AppendSoapTbP&&FldNmToSoapTbH.IsKey(FldNm)){
161        FldNmToSoapTbH.GetDat(FldNm)->Append(SoapTb);
162      } else {
163        FldNmToSoapTbH.AddDat(FldNm, SoapTb);
164      }
165    }}
166  }
167  void TSoapEnv::AddFlattened(TStrPrV& FldNmValPrV) const {
168    for (int FldN=0; FldN<FldNmToValH.Len(); FldN++){
169      TStr FldNm=FldNmToValH.GetKey(FldN);
170      TStr FldVal=FldNmToValH[FldN];
171      FldNmValPrV.Add(TStrPr(FldNm, FldVal));
172    }
173    for (int FldN=0; FldN<FldNmToValVH.Len(); FldN++){
174      TStr FldNm=FldNmToValVH.GetKey(FldN);
175      const TStrV& FldValV=FldNmToValVH[FldN];
176      TSoap::AddVecFld(FldNm, FldValV, FldNmValPrV);
177    }
178    for (int FldN=0; FldN<FldNmToSoapTbH.Len(); FldN++){
179      TStr FldNm=FldNmToSoapTbH.GetKey(FldN);
180      PSoapTb SoapTb=FldNmToSoapTbH[FldN];
181      TSoap::AddTbFld(FldNm, SoapTb, FldNmValPrV);
182    }
183  }
184  const TStr TSoap::ResponseStr="Response";
185  const TStr TSoap::VersionMismatchCodeNm="env:VersionMismatch";
186  const TStr TSoap::MustUnderstandCodeNm="env:MustUnderstand";
187  const TStr TSoap::DataEncodingUnknownCodeNm="env:DataEncodingUnknown";
188  const TStr TSoap::SenderCodeNm="env:Sender";
189  const TStr TSoap::ReceiverCodeNm="env:Receiver";
190  void TSoap::GetFromXmlStr(
191   const TStr& XmlStr, const bool& RespP,
192   TBool& Ok, bool& FaultP,
193   TStr& FuncNm, TStrPrV& FldNmValPrV,
194   TStr& FaultCodeNm, TStr& FaultReasonStr){
195    Ok=false; FaultP=true;
196    FuncNm=""; FldNmValPrV.Clr();
197    FaultCodeNm=""; FaultReasonStr="";
198    PSIn SIn=TStrIn::New(XmlStr);
199    PXmlDoc XmlDoc=TXmlDoc::LoadTxt(SIn);
200    if (XmlDoc->IsOk()){
201      PXmlTok EnvTok=XmlDoc->GetTok();
202      if (EnvTok->IsTag("env:Envelope")){
203        PXmlTok BodyTok;
204        if (EnvTok->IsSubTag("env:Body", BodyTok)){
205          PXmlTok FaultTok;
206          if (RespP&&(BodyTok->IsSubTag("env:Fault", FaultTok))){
207            FaultP=true;
208            FaultCodeNm=FaultTok->GetTagTokStr("env:Code|env:Value");
209            FaultReasonStr=FaultTok->GetTagTokStr("env:Reason|env:Text");
210            Ok=(!FaultCodeNm.Empty());
211          } else {
212            PXmlTok FuncTok;
213            for (int TokN=0; TokN<BodyTok->GetSubToks(); TokN++){
214              PXmlTok Tok=BodyTok->GetSubTok(TokN);
215              if (Tok->IsTag()){
216                TStr TagNm=Tok->GetTagNm();
217                if (RespP){
218                  if (TagNm.IsSuffix(TSoap::ResponseStr)){
219                    Ok=true; FaultP=false;
220                    FuncTok=Tok;
221                    FuncNm=TagNm.GetSubStr(0,
222                     TagNm.Len()-1-TStr(TSoap::ResponseStr).Len());
223                    break;
224                  }
225                } else {
226                  Ok=true; FaultP=false;
227                  FuncTok=Tok;
228                  FuncNm=TagNm;
229                }
230              }
231            }
232            if (!FuncTok.Empty()){
233              for (int TokN=0; TokN<FuncTok->GetSubToks(); TokN++){
234                PXmlTok FldTok=FuncTok->GetSubTok(TokN);
235                if (FldTok->IsTag()){
236                  TStr FldNm=FldTok->GetTagNm();
237                  TStr FldVal=FldTok->GetTagTokStr("");
238                  FldNmValPrV.Add(TStrPr(FldNm, FldVal));
239                }
240              }
241            }
242          }
243        }
244      }
245    }
246  }
247  TStr TSoap::GetUrlPathStr(
248   const TStr& FuncNm, const bool& RespP,
249   const TStrPrV& FldNmValPrV){
250    TChA ChA;
251    TStr UrlFuncNm=TUrl::GetUrlSearchStr(FuncNm);
252    ChA+=UrlFuncNm; if (RespP){ChA+="Response";} ChA+="?";
253    for (int FldN=0; FldN<FldNmValPrV.Len(); FldN++){
254      if (FldN>0){ChA+='&';}
255      TStr UrlFldNm=TUrl::GetUrlSearchStr(FldNmValPrV[FldN].Val1);
256      TStr UrlFldVal=TUrl::GetUrlSearchStr(FldNmValPrV[FldN].Val2);
257      ChA+=UrlFldNm; ChA+="="; ChA+=UrlFldVal;
258    }
259    return ChA;
260  }
261  TStr TSoap::GetUrlPathStr(
262   const TStr& FuncNm, const bool& RespP,
263   const TStr& FldNm1, const TStr& FldVal1,
264   const TStr& FldNm2, const TStr& FldVal2){
265    TStrPrV FldNmValPrV(2, 0);
266    if (!FldNm1.Empty()){
267      FldNmValPrV.Add(TStrPr(FldNm1, FldVal1));}
268    if (!FldNm2.Empty()){
269      FldNmValPrV.Add(TStrPr(FldNm2, FldVal2));}
270    return GetUrlPathStr(FuncNm, RespP, FldNmValPrV);
271  }
272  TStr TSoap::GetXmlStr(
273   const TStr& FuncNm, const bool& RespP,
274   const TStrPrV& FldNmValPrV){
275    TStr FuncXmlNm=FuncNm.GetTrunc(); 
276    TChA ChA;
277    ChA+="<?xml version='1.0' ?>\n";
278    ChA+="<env:Envelope xmlns:env=\"http:&bsol;&bsol;www.w3.org/2003/05/soap-envelope\">\n";
279    ChA+="  <env:Body>\n";
280    ChA+="    <"; ChA+=FuncXmlNm; if (RespP){ChA+="Response";} ChA+=">\n";
281    for (int FldN=0; FldN<FldNmValPrV.Len(); FldN++){
282      TStr FldNm=FldNmValPrV[FldN].Val1.GetTrunc(); 
283      TStr FldVal=TXmlLx::GetXmlStrFromPlainStr(FldNmValPrV[FldN].Val2);
284      ChA+="      <"; ChA+=FldNm; ChA+=">";
285      ChA+=FldVal;
286      ChA+="</"; ChA+=FldNm;ChA+=">\n";
287    }
288    ChA+="    </"; ChA+=FuncXmlNm; if (RespP){ChA+="Response";} ChA+=">\n";
289    ChA+="  </env:Body>\n";
290    ChA+="</env:Envelope>\n";
291    return ChA;
292  }
293  TStr TSoap::GetXmlStr(
294   const TStr& FuncNm, const bool& RespP){
295    TStrPrV FldNmValPrV;
296    return GetXmlStr(FuncNm, RespP, FldNmValPrV);
297  }
298  TStr TSoap::GetXmlStr(
299   const TStr& FuncNm, const bool& RespP,
300   const TStr& FldNm, const TStr& FldVal){
301    TStrPrV FldNmValPrV;
302    FldNmValPrV.Add(TStrPr(FldNm, FldVal));
303    return GetXmlStr(FuncNm, RespP, FldNmValPrV);
304  }
305  TStr TSoap::GetXmlStr(
306   const TStr& FuncNm, const bool& RespP,
307   const TStr& FldNm1, const TStr& FldVal1,
308   const TStr& FldNm2, const TStr& FldVal2){
309    TStrPrV FldNmValPrV;
310    FldNmValPrV.Add(TStrPr(FldNm1, FldVal1));
311    FldNmValPrV.Add(TStrPr(FldNm2, FldVal2));
312    return GetXmlStr(FuncNm, RespP, FldNmValPrV);
313  }
314  TStr TSoap::GetFaultXmlStr(const TStr& CodeNm, const TStr& ReasonStr){
315    TStr ReasonXmlStr=TXmlLx::GetXmlStrFromPlainStr(ReasonStr);
316    TChA ChA;
317    ChA+="<?xml version='1.0' ?>\n";
318    ChA+="<env:Envelope\n";
319    ChA+=" xmlns:env=\"http:&bsol;&bsol;www.w3.org/2003/05/soap-envelope\"\n";
320    ChA+=" xmlns:rpc='http:&bsol;&bsol;www.w3.org/2003/05/soap-rpc'>\n";
321    ChA+="  <env:Body>\n";
322    ChA+="    <env:Fault>\n";
323    ChA+="      <env:Code>\n";
324    ChA+="        <env:Value>"; ChA+=CodeNm; ChA+="</env:Value>\n";
325    ChA+="      </env:Code>\n";
326    ChA+="      <env:Reason>\n";
327    ChA+="        <env:Text>"; ChA+=ReasonXmlStr; ChA+="</env:Text>\n";
328    ChA+="      </env:Reason>\n";
329    ChA+="    </env:Fault>\n";
330    ChA+="  </env:Body>\n";
331    ChA+="</env:Envelope>";
332    return ChA;
333  }
334  bool TSoap::IsVecFld(const int& FldN, const TStrPrV& FldNmValPrV){
335    return FldNmValPrV[FldN].Val1.IsSuffix("_VecBeg");
336  }
337  bool TSoap::IsVecFld(const TStr& FldNm, const TStrPrV& FldNmValPrV){
338    TStr VecBeg_FldNm=FldNm+"_VecBeg";
339    int Flds=FldNmValPrV.Len();
340    for (int FldN=0; FldN<Flds; FldN++){
341      if (FldNmValPrV[FldN].Val1==VecBeg_FldNm){return true;}
342    }
343    return false;
344  }
345  void TSoap::AddVecFld(const TStr& FldNm, const TStrV& FldValV, TStrPrV& FldNmValPrV){
346    FldNmValPrV.Add(TStrPr(FldNm+"_VecBeg", TInt::GetStr(FldValV.Len())));
347    for (int ValN=0; ValN<FldValV.Len(); ValN++){
348      FldNmValPrV.Add(TStrPr(FldNm+"_"+TInt::GetStr(ValN), FldValV[ValN]));
349    }
350    FldNmValPrV.Add(TStrPr(FldNm+"_VecEnd", TInt::GetStr(FldValV.Len())));
351  }
352  void TSoap::GetVecFld(const TStr& FldNm, TStrV& FldValV, const TStrPrV& FldNmValPrV){
353    TStr VecBeg_FldNm=FldNm+"_VecBeg";
354    int Flds=FldNmValPrV.Len(); int FldN=0;
355    while (FldN<Flds){
356      if (FldNmValPrV[FldN].Val1==VecBeg_FldNm){break;}
357      FldN++;
358    }
359    if (FldN==Flds){
360      FldValV.Clr();
361    } else {
362      TStr _FldNm; GetVecFld(FldN, _FldNm, FldValV, FldNmValPrV);
363    }
364  }
365  int TSoap::GetVecFld(
366   const int& _FldN, TStr& FldNm, TStrV& FldValV, const TStrPrV& FldNmValPrV){
367    IAssert(IsVecFld(_FldN, FldNmValPrV));
368    int Flds=FldNmValPrV.Len();
369    int FldN=_FldN;
370    FldNm=FldNmValPrV[FldN].Val1;
371    FldNm=FldNm.GetSubStr(0, FldNm.Len()-TStr("_VecBeg").Len()-1);
372    TStr VecEnd_FldNm=FldNm+"_VecEnd";
373    FldValV.Clr(); FldN++;
374    while (FldN<Flds){
375      if (FldNmValPrV[FldN].Val1==VecEnd_FldNm){FldN++; break;}
376      else {FldValV.Add(FldNmValPrV[FldN].Val2);}
377      FldN++;
378    }
379    return FldN;
380  }
381  bool TSoap::IsTbFld(const int& FldN, const TStrPrV& FldNmValPrV){
382    return FldNmValPrV[FldN].Val1.IsSuffix("_TbBeg");
383  }
384  bool TSoap::IsTbFld(const TStr& FldNm, const TStrPrV& FldNmValPrV){
385    TStr BTbFldNm=FldNm+"_TbBeg";
386    int Flds=FldNmValPrV.Len();
387    for (int FldN=0; FldN<Flds; FldN++){
388      if (FldNmValPrV[FldN].Val1==BTbFldNm){return true;}
389    }
390    return false;
391  }
392  void TSoap::AddTbFld(const TStr& TbFldNm, const PSoapTb& SoapTb, TStrPrV& FldNmValPrV){
393    int Rows=SoapTb->GetRows();
394    FldNmValPrV.Add(TStrPr(TbFldNm+"_TbBeg", TInt::GetStr(SoapTb->GetRows())));
395    for (int RowN=0; RowN<Rows; RowN++){
396      FldNmValPrV.Add(TStrPr(TbFldNm+"_TbRowBeg_"+TInt::GetStr(RowN), TStr()));
397      int RowVals=SoapTb->GetRowVals(RowN); TStr ColNm; TStr ValStr;
398      for (int RowValN=0; RowValN<RowVals; RowValN++){
399        SoapTb->GetColNmVal(RowN, RowValN, ColNm, ValStr);
400        FldNmValPrV.Add(TStrPr(TbFldNm+"_"+ColNm+"_"+TInt::GetStr(RowN), ValStr));
401      }
402      FldNmValPrV.Add(TStrPr(TbFldNm+"_TbRowEnd_"+TInt::GetStr(RowN), TStr()));
403    }
404    FldNmValPrV.Add(TStrPr(TbFldNm+"_TbEnd", TInt::GetStr(SoapTb->GetRows())));
405  }
406  void TSoap::GetTbFld(const TStr& TbFldNm, PSoapTb& SoapTb, const TStrPrV& FldNmValPrV){
407    TStr TbBeg_FldNm=TbFldNm+"_TbBeg";
408    int Flds=FldNmValPrV.Len(); int FldN=0;
409    while (FldN<Flds){
410      if (FldNmValPrV[FldN].Val1==TbBeg_FldNm){break;}
411      FldN++;
412    }
413    if (FldN==Flds){
414      SoapTb=TSoapTb::New();
415    } else {
416      TStr _FldNm; GetTbFld(FldN, _FldNm, SoapTb, FldNmValPrV);
417    }
418  }
419  int TSoap::GetTbFld(
420   const int& _FldN, TStr& TbFldNm, PSoapTb& SoapTb, const TStrPrV& FldNmValPrV){
421    IAssert(IsTbFld(_FldN, FldNmValPrV));
422    int Flds=FldNmValPrV.Len();
423    int FldN=_FldN;
424    TbFldNm=FldNmValPrV[FldN].Val1;
425    TbFldNm=TbFldNm.GetSubStr(0, TbFldNm.Len()-TStr("_TbBeg").Len()-1);
426    TStr TbEnd_FldNm=TbFldNm+"_TbEnd";
427    TStr TbRowBeg_FldNm=TbFldNm+"_TbRowBeg_"; 
428    TStr TbRowEnd_FldNm=TbFldNm+"_TbRowEnd_";
429    SoapTb=TSoapTb::New(); FldN++;
430    while (FldN<Flds){
431      TStr FldNm=FldNmValPrV[FldN].Val1;
432      TStr FldVal=FldNmValPrV[FldN].Val2;
433      if (FldNm==TbEnd_FldNm){FldN++; break;}
434      else if (FldNm.IsStrIn(TbRowBeg_FldNm)){SoapTb->AddRow();}
435      else if (FldNm.IsStrIn(TbRowEnd_FldNm)){}
436      else {
437        TStr FNmPrefix=TbFldNm+"_";
438        TStr FNmSuffix="_"+TInt::GetStr(SoapTb->GetRows()-1);
439        if (FldNm.IsPrefix(FNmPrefix)&&FldNm.IsSuffix(FNmSuffix)){
440          FldNm=FldNm.GetSubStr(FNmPrefix.Len(), FldNm.Len()-1-FNmSuffix.Len());
441        } else {WarnNotify("Invalid Field-Name Prefix/Suffix in Soap Table "+TbFldNm);}
442        SoapTb->AddVal(FldNm, FldVal);
443      }
444      FldN++;
445    }
446    return FldN;
447  }
448  PSoapRq TSoapRq::New(const TStr& FuncNm,
449   const TStr& FldNm, const TStr& FldVal){
450    PSoapRq SoapRq=TSoapRq::New(FuncNm);
451    SoapRq->AddFldNmVal(FldNm, FldVal);
452    return SoapRq;
453  }
454  PSoapRq TSoapRq::New(const TStr& FuncNm,
455   const TStr& FldNm1, const TStr& FldVal1,
456   const TStr& FldNm2, const TStr& FldVal2){
457    PSoapRq SoapRq=TSoapRq::New(FuncNm);
458    SoapRq->AddFldNmVal(FldNm1, FldVal1);
459    SoapRq->AddFldNmVal(FldNm2, FldVal2);
460    return SoapRq;
461  }
462  PSoapRq TSoapRq::New(const TStr& FuncNm,
463   const TStr& FldNm1, const TStr& FldVal1,
464   const TStr& FldNm2, const TStr& FldVal2,
465   const TStr& FldNm3, const TStr& FldVal3){
466    PSoapRq SoapRq=TSoapRq::New(FuncNm);
467    SoapRq->AddFldNmVal(FldNm1, FldVal1);
468    SoapRq->AddFldNmVal(FldNm2, FldVal2);
469    SoapRq->AddFldNmVal(FldNm3, FldVal3);
470    return SoapRq;
471  }
472  PSoapRq TSoapRq::New(const TStr& FuncNm,
473   const TStr& FldNm1, const TStr& FldVal1,
474   const TStr& FldNm2, const TStr& FldVal2,
475   const TStr& FldNm3, const TStr& FldVal3,
476   const TStr& FldNm4, const TStr& FldVal4){
477    PSoapRq SoapRq=TSoapRq::New(FuncNm);
478    SoapRq->AddFldNmVal(FldNm1, FldVal1);
479    SoapRq->AddFldNmVal(FldNm2, FldVal2);
480    SoapRq->AddFldNmVal(FldNm3, FldVal3);
481    SoapRq->AddFldNmVal(FldNm4, FldVal4);
482    return SoapRq;
483  }
484  PSoapRq TSoapRq::New(const TStr& FuncNm,
485   const TStr& FldNm1, const TStr& FldVal1,
486   const TStr& FldNm2, const TStr& FldVal2,
487   const TStr& FldNm3, const TStr& FldVal3,
488   const TStr& FldNm4, const TStr& FldVal4,
489   const TStr& FldNm5, const TStr& FldVal5){
490    PSoapRq SoapRq=TSoapRq::New(FuncNm);
491    SoapRq->AddFldNmVal(FldNm1, FldVal1);
492    SoapRq->AddFldNmVal(FldNm2, FldVal2);
493    SoapRq->AddFldNmVal(FldNm3, FldVal3);
494    SoapRq->AddFldNmVal(FldNm4, FldVal4);
495    SoapRq->AddFldNmVal(FldNm5, FldVal5);
496    return SoapRq;
497  }
498  void TSoapRq::AddFldNmVal(const TStr& FldNm, const TStr& FldVal){
499    for (int FldN=0; FldN<FldNmValPrV.Len(); FldN++){
500      if (FldNmValPrV[FldN].Val1==FldNm){
501        FldNmValPrV[FldN].Val2=FldVal; return;
502      }
503    }
504    FldNmValPrV.Add(TStrPr(FldNm, FldVal));
505  }
506  bool TSoapRq::IsFldNm(const TStr& FldNm) const {
507    int Flds=GetFlds();
508    TStr _FldNm; TStr FldVal;
509    for (int FldN=0; FldN<Flds; FldN++){
510      GetFldNmVal(FldN, _FldNm, FldVal);
511      if (FldNm==_FldNm){return true;}
512    }
513    return false;
514  }
515  bool TSoapRq::IsFldNmVal(const TStr& FldNm, const TStr& FldVal) const {
516    int Flds=GetFlds();
517    TStr _FldNm; TStr _FldVal;
518    for (int FldN=0; FldN<Flds; FldN++){
519      GetFldNmVal(FldN, _FldNm, _FldVal);
520      if ((FldNm==_FldNm)&&(FldVal==_FldVal)){return true;}
521    }
522    return false;
523  }
524  TStr TSoapRq::GetFldVal(const TStr& FldNm) const {
525    int Flds=GetFlds();
526    TStr _FldNm; TStr FldVal;
527    for (int FldN=0; FldN<Flds; FldN++){
528      GetFldNmVal(FldN, _FldNm, FldVal);
529      if (FldNm==_FldNm){return FldVal;}
530    }
531    return "";
532  }
533  TSoapRq::TSoapRq(const PHttpRq& HttpRq):
534    Ok(false){
535    if (HttpRq->IsOk()){
536      if (HttpRq->IsContType(THttp::AppSoapXmlFldVal)){
537        TStr XmlStr=HttpRq->GetBodyAsStr();
538        bool _FaultP; TStr _FaultCodeNm; TStr _FaultReasonStr;
539        TSoap::GetFromXmlStr(
540         XmlStr, false, Ok, _FaultP,
541         FuncNm, FldNmValPrV, _FaultCodeNm, _FaultReasonStr);
542      } else {
543        PUrl Url=HttpRq->GetUrl();
544        if (Url->GetPathSegs()>0){
545          FuncNm=Url->GetPathSeg(Url->GetPathSegs()-1);}
546        if (FuncNm.Empty()){
547          FuncNm="Info";
548        } else {
549          PUrlEnv UrlEnv=HttpRq->GetUrlEnv();
550          for (int KeyN=0; KeyN<UrlEnv->GetKeys(); KeyN++){
551            TStr FldNm=UrlEnv->GetKeyNm(KeyN);
552            TStr FldVal=UrlEnv->GetVal(FldNm);
553            FldNmValPrV.Add(TStrPr(FldNm, FldVal));
554          }
555        }
556        Ok=true;
557      }
558    }
559  }
560  TSoapResp::TSoapResp(const PHttpResp& HttpResp):
561    Ok(false){
562    if (HttpResp->IsOk()){
563      if (HttpResp->IsContType(THttp::AppSoapXmlFldVal)){
564        TStr XmlStr=HttpResp->GetBodyAsStr();
565        TSoap::GetFromXmlStr(
566         XmlStr, true, Ok, FaultP,
567         FuncNm, FldNmValPrV, FaultCodeNm, FaultReasonStr);
568      }
569    }
570  }
571  void TSoapResp::AddFldNmVal(const TStr& FldNm, const TStr& FldVal){
572    for (int FldN=0; FldN<FldNmValPrV.Len(); FldN++){
573      if (FldNmValPrV[FldN].Val1==FldNm){
574        FldNmValPrV[FldN].Val2=FldVal; return;
575      }
576    }
577    FldNmValPrV.Add(TStrPr(FldNm, FldVal));
578  }
579  void TSoapResp::GetFldNmValKdV(TStrKdV& FldNmValKdV) const {
580    FldNmValKdV.Clr();
581    for (int FldN=0; FldN<GetFlds(); FldN++){
582      TStr FldNm; TStr FldVal; GetFldNmVal(FldN, FldNm, FldVal);
583      FldNmValKdV.Add(TStrKd(FldNm, FldVal));
584    }
585  }
586  bool TSoapResp::IsFldNm(const TStr& FldNm) const {
587    int Flds=GetFlds();
588    TStr _FldNm; TStr FldVal;
589    for (int FldN=0; FldN<Flds; FldN++){
590      GetFldNmVal(FldN, _FldNm, FldVal);
591      if (FldNm==_FldNm){return true;}
592    }
593    return false;
594  }
595  TStr TSoapResp::GetFldVal(const TStr& FldNm) const {
596    int Flds=GetFlds();
597    TStr _FldNm; TStr FldVal;
598    for (int FldN=0; FldN<Flds; FldN++){
599      GetFldNmVal(FldN, _FldNm, FldVal);
600      if (FldNm==_FldNm){return FldVal;}
601    }
602    return "";
603  }
604  TStr TSoapResp::GetRespStr() const {
605    if (IsOk()){
606      if (IsResult()){
607        return GetRespStr(FuncNm, FldNmValPrV);
608      } else {
609        return GetFaultRespStr(FaultCodeNm, FaultReasonStr);
610      }
611    } else {
612      return GetFaultRespStr(TSoap::DataEncodingUnknownCodeNm, "Unknown Error.");
613    }
614  }
615  TStr TSoapResp::GetAsUrlPathStr() const {
616    if (IsResult()){
617      return TSoap::GetUrlPathStr(FuncNm, true, FldNmValPrV);
618    } else
619    if (IsFault()){
620      return TSoap::GetUrlPathStr("Fault", true,
621       "FaultCode", GetFaultCodeNm(),
622       "FaultReason", GetFaultReasonStr());
623    } else {
624      return TSoap::GetUrlPathStr("Fault", true);
625    }
626  }
627  PHttpResp TSoapResp::GetHttpResp(const TStr& FuncNm,
628   const TStr& FldNm1, const TStr& FldVal1,
629   const TStr& FldNm2, const TStr& FldVal2,
630   const TStr& FldNm3, const TStr& FldVal3){
631    PSoapResp SoapResp=TSoapResp::New(FuncNm);
632    SoapResp->AddFldNmVal(FldNm1, FldVal1);
633    SoapResp->AddFldNmVal(FldNm2, FldVal2);
634    SoapResp->AddFldNmVal(FldNm3, FldVal3);
635    return SoapResp->GetHttpResp();
636  }
637  PHttpResp TSoapResp::GetHttpResp(const TStr& FuncNm,
638   const TStr& FldNm1, const TStr& FldVal1,
639   const TStr& FldNm2, const TStr& FldVal2,
640   const TStr& FldNm3, const TStr& FldVal3,
641   const TStr& FldNm4, const TStr& FldVal4){
642    PSoapResp SoapResp=TSoapResp::New(FuncNm);
643    SoapResp->AddFldNmVal(FldNm1, FldVal1);
644    SoapResp->AddFldNmVal(FldNm2, FldVal2);
645    SoapResp->AddFldNmVal(FldNm3, FldVal3);
646    SoapResp->AddFldNmVal(FldNm4, FldVal4);
647    return SoapResp->GetHttpResp();
648  }
649  PHttpResp TSoapResp::GetHttpResp(const TStr& FuncNm,
650   const TStr& FldNm1, const TStr& FldVal1,
651   const TStr& FldNm2, const TStr& FldVal2,
652   const TStr& FldNm3, const TStr& FldVal3,
653   const TStr& FldNm4, const TStr& FldVal4,
654   const TStr& FldNm5, const TStr& FldVal5){
655    PSoapResp SoapResp=TSoapResp::New(FuncNm);
656    SoapResp->AddFldNmVal(FldNm1, FldVal1);
657    SoapResp->AddFldNmVal(FldNm2, FldVal2);
658    SoapResp->AddFldNmVal(FldNm3, FldVal3);
659    SoapResp->AddFldNmVal(FldNm4, FldVal4);
660    SoapResp->AddFldNmVal(FldNm5, FldVal5);
661    return SoapResp->GetHttpResp();
662  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-fa.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-soap.cpp</div>
                </div>
                <div class="column column_space"><pre><code>12  void TFaTrans::_ChangeStateNm(const TStr& OldStateNm, const TStr& NewStateNm){
13    if (SrcStateNm==OldStateNm){SrcStateNm=NewStateNm;}
14    if (DstStateNm==OldStateNm){DstStateNm=NewStateNm;}
15  }
</pre></code></div>
                <div class="column column_space"><pre><code>48      for (int ValN=0; ValN<RowVals; ValN++){
49        GetColNmVal(RowN, ValN, ColNm, ValStr);
50        if (ColNm==SelColNm){CurSelValStr=ValStr;}
51        if (ColNm==WhereColNm){CurWhereValStr=ValStr;}
52      }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    