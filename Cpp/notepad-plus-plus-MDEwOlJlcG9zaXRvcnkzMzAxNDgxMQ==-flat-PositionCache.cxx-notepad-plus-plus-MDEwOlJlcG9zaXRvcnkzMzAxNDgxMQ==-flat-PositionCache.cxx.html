
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 14, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-PositionCache.cxx</h3>
            <pre><code>1  #include <cstddef>
2  #include <cstdlib>
3  #include <cstdint>
4  #include <cstring>
5  #include <cmath>
6  #include <stdexcept>
7  #include <string>
8  #include <string_view>
9  #include <vector>
10  #include <map>
11  #include <set>
12  #include <optional>
13  #include <algorithm>
14  #include <iterator>
15  #include <memory>
16  #include <mutex>
17  #include "ScintillaTypes.h"
18  #include "ScintillaMessages.h"
19  #include "ILoader.h"
20  #include "ILexer.h"
21  #include "Debugging.h"
22  #include "Geometry.h"
23  #include "Platform.h"
24  #include "CharacterType.h"
25  #include "CharacterCategoryMap.h"
26  #include "Position.h"
27  #include "UniqueString.h"
28  #include "SplitVector.h"
29  #include "Partitioning.h"
30  #include "RunStyles.h"
31  #include "ContractionState.h"
32  #include "CellBuffer.h"
33  #include "KeyMap.h"
34  #include "Indicator.h"
35  #include "LineMarker.h"
36  #include "Style.h"
37  #include "ViewStyle.h"
38  #include "CharClassify.h"
39  #include "Decoration.h"
40  #include "CaseFolder.h"
41  #include "Document.h"
42  #include "UniConversion.h"
43  #include "DBCS.h"
44  #include "Selection.h"
45  #include "PositionCache.h"
46  using namespace Scintilla;
47  using namespace Scintilla::Internal;
48  void BidiData::Resize(size_t maxLineLength_) {
49  	stylesFonts.resize(maxLineLength_ + 1);
50  	widthReprs.resize(maxLineLength_ + 1);
51  }
52  LineLayout::LineLayout(Sci::Line lineNumber_, int maxLineLength_) :
53  	lenLineStarts(0),
54  	lineNumber(lineNumber_),
55  	maxLineLength(-1),
56  	numCharsInLine(0),
57  	numCharsBeforeEOL(0),
58  	validity(ValidLevel::invalid),
59  	xHighlightGuide(0),
60  	highlightColumn(false),
61  	containsCaret(false),
62  	edgeColumn(0),
63  	bracePreviousStyles{},
64  	widthLine(wrapWidthInfinite),
65  	lines(1),
66  	wrapIndent(0) {
67  	Resize(maxLineLength_);
68  }
69  LineLayout::~LineLayout() {
70  	Free();
71  }
72  void LineLayout::Resize(int maxLineLength_) {
73  	if (maxLineLength_ > maxLineLength) {
74  		Free();
75  		const size_t lineAllocation = maxLineLength_ + 1;
76  		chars = std::make_unique<char[]>(lineAllocation);
77  		styles = std::make_unique<unsigned char []>(lineAllocation);
78  		positions = std::make_unique<XYPOSITION []>(lineAllocation + 1);
79  		if (bidiData) {
80  			bidiData->Resize(maxLineLength_);
81  		}
82  		maxLineLength = maxLineLength_;
83  	}
84  }
85  void LineLayout::ReSet(Sci::Line lineNumber_, Sci::Position maxLineLength_) {
86  	lineNumber = lineNumber_;
87  	Resize(static_cast<int>(maxLineLength_));
88  	lines = 0;
89  	Invalidate(ValidLevel::invalid);
90  }
91  void LineLayout::EnsureBidiData() {
92  	if (!bidiData) {
93  		bidiData = std::make_unique<BidiData>();
94  		bidiData->Resize(maxLineLength);
95  	}
96  }
97  void LineLayout::Free() noexcept {
98  	chars.reset();
99  	styles.reset();
100  	positions.reset();
101  	lineStarts.reset();
102  	lenLineStarts = 0;
103  	bidiData.reset();
104  }
105  void LineLayout::ClearPositions() {
106  	std::fill(&positions[0], &positions[maxLineLength + 2], 0.0f);
107  }
108  void LineLayout::Invalidate(ValidLevel validity_) noexcept {
109  	if (validity > validity_)
110  		validity = validity_;
111  }
112  Sci::Line LineLayout::LineNumber() const noexcept {
113  	return lineNumber;
114  }
115  bool LineLayout::CanHold(Sci::Line lineDoc, int lineLength_) const noexcept {
116  	return (lineNumber == lineDoc) && (lineLength_ <= maxLineLength);
117  }
118  int LineLayout::LineStart(int line) const noexcept {
119  	if (line <= 0) {
120  		return 0;
121  	} else if ((line >= lines) || !lineStarts) {
122  		return numCharsInLine;
123  	} else {
124  		return lineStarts[line];
125  	}
126  }
127  int LineLayout::LineLength(int line) const noexcept {
128  	if (!lineStarts) {
129  		return numCharsInLine;
130  	} if (line >= lines - 1) {
131  		return numCharsInLine - lineStarts[line];
132  	} else {
133  		return lineStarts[line + 1] - lineStarts[line];
134  	}
135  }
136  int LineLayout::LineLastVisible(int line, Scope scope) const noexcept {
137  	if (line < 0) {
138  		return 0;
139  	} else if ((line >= lines-1) || !lineStarts) {
140  		return scope == Scope::visibleOnly ? numCharsBeforeEOL : numCharsInLine;
141  	} else {
142  		return lineStarts[line+1];
143  	}
144  }
145  Range LineLayout::SubLineRange(int subLine, Scope scope) const noexcept {
146  	return Range(LineStart(subLine), LineLastVisible(subLine, scope));
147  }
148  bool LineLayout::InLine(int offset, int line) const noexcept {
149  	return ((offset >= LineStart(line)) && (offset < LineStart(line + 1))) ||
150  		((offset == numCharsInLine) && (line == (lines-1)));
151  }
152  int LineLayout::SubLineFromPosition(int posInLine, PointEnd pe) const noexcept {
153  	if (!lineStarts || (posInLine > maxLineLength)) {
154  		return lines - 1;
155  	}
156  	for (int line = 0; line < lines; line++) {
157  		if (FlagSet(pe, PointEnd::subLineEnd)) {
158  			if (lineStarts[line + 1] <= posInLine + 1)
159  				return line;
160  		} else {
161  			if (lineStarts[line + 1] <= posInLine)
162  				return line;
163  		}
164  	}
165  	return lines - 1;
166  }
167  void LineLayout::AddLineStart(Sci::Position start) {
168  	lines++;
169  	if (lines >= lenLineStarts) {
170  		const int newMaxLines = lines + 20;
171  		std::unique_ptr<int[]> newLineStarts = std::make_unique<int[]>(newMaxLines);
172  		if (lenLineStarts) {
173  			std::copy(lineStarts.get(), lineStarts.get() + lenLineStarts, newLineStarts.get());
174  		}
175  		lineStarts = std::move(newLineStarts);
176  		lenLineStarts = newMaxLines;
177  	}
178  	lineStarts[lines] = static_cast<int>(start);
179  }
180  void LineLayout::SetBracesHighlight(Range rangeLine, const Sci::Position braces[],
181                                      char bracesMatchStyle, int xHighlight, bool ignoreStyle) {
182  	if (!ignoreStyle && rangeLine.ContainsCharacter(braces[0])) {
183  		const Sci::Position braceOffset = braces[0] - rangeLine.start;
184  		if (braceOffset < numCharsInLine) {
185  			bracePreviousStyles[0] = styles[braceOffset];
186  			styles[braceOffset] = bracesMatchStyle;
187  		}
188  	}
189  	if (!ignoreStyle && rangeLine.ContainsCharacter(braces[1])) {
190  		const Sci::Position braceOffset = braces[1] - rangeLine.start;
191  		if (braceOffset < numCharsInLine) {
192  			bracePreviousStyles[1] = styles[braceOffset];
193  			styles[braceOffset] = bracesMatchStyle;
194  		}
195  	}
196  	if ((braces[0] >= rangeLine.start && braces[1] <= rangeLine.end) ||
197  	        (braces[1] >= rangeLine.start && braces[0] <= rangeLine.end)) {
198  		xHighlightGuide = xHighlight;
199  	}
200  }
201  void LineLayout::RestoreBracesHighlight(Range rangeLine, const Sci::Position braces[], bool ignoreStyle) {
202  	if (!ignoreStyle && rangeLine.ContainsCharacter(braces[0])) {
203  		const Sci::Position braceOffset = braces[0] - rangeLine.start;
204  		if (braceOffset < numCharsInLine) {
205  			styles[braceOffset] = bracePreviousStyles[0];
206  		}
207  	}
208  	if (!ignoreStyle && rangeLine.ContainsCharacter(braces[1])) {
209  		const Sci::Position braceOffset = braces[1] - rangeLine.start;
210  		if (braceOffset < numCharsInLine) {
211  			styles[braceOffset] = bracePreviousStyles[1];
212  		}
213  	}
214  	xHighlightGuide = 0;
215  }
216  int LineLayout::FindBefore(XYPOSITION x, Range range) const noexcept {
217  	Sci::Position lower = range.start;
218  	Sci::Position upper = range.end;
219  	do {
220  		const Sci::Position middle = (upper + lower + 1) / 2; 	
221  		const XYPOSITION posMiddle = positions[middle];
222  		if (x < posMiddle) {
223  			upper = middle - 1;
224  		} else {
225  			lower = middle;
226  		}
227  	} while (lower < upper);
228  	return static_cast<int>(lower);
229  }
230  int LineLayout::FindPositionFromX(XYPOSITION x, Range range, bool charPosition) const noexcept {
231  	int pos = FindBefore(x, range);
232  	while (pos < range.end) {
233  		if (charPosition) {
234  			if (x < (positions[pos + 1])) {
235  				return pos;
236  			}
237  		} else {
238  			if (x < ((positions[pos] + positions[pos + 1]) / 2)) {
239  				return pos;
240  			}
241  		}
242  		pos++;
243  	}
244  	return static_cast<int>(range.end);
245  }
246  Point LineLayout::PointFromPosition(int posInLine, int lineHeight, PointEnd pe) const noexcept {
247  	Point pt;
248  	if (posInLine > maxLineLength) {
249  		pt.x = positions[maxLineLength] - positions[LineStart(lines)];
250  	}
251  	for (int subLine = 0; subLine < lines; subLine++) {
252  		const Range rangeSubLine = SubLineRange(subLine, Scope::visibleOnly);
253  		if (posInLine >= rangeSubLine.start) {
254  			pt.y = static_cast<XYPOSITION>(subLine*lineHeight);
255  			if (posInLine <= rangeSubLine.end) {
256  				pt.x = positions[posInLine] - positions[rangeSubLine.start];
257  				if (rangeSubLine.start != 0)	
258  					pt.x += wrapIndent;
259  				if (FlagSet(pe, PointEnd::subLineEnd))	
260  					break;
261  			} else if (FlagSet(pe, PointEnd::lineEnd) && (subLine == (lines-1))) {
262  				pt.x = positions[numCharsInLine] - positions[rangeSubLine.start];
263  				if (rangeSubLine.start != 0)	
264  					pt.x += wrapIndent;
265  			}
266  		} else {
267  			break;
268  		}
269  	}
270  	return pt;
271  }
272  XYPOSITION LineLayout::XInLine(Sci::Position index) const noexcept {
273  	if (index <= numCharsInLine) {
274  		return positions[index];
275  	}
276  	return positions[numCharsInLine] + 1.0;
277  }
278  Interval LineLayout::Span(int start, int end) const noexcept {
279  	return { positions[start], positions[end] };
280  }
281  Interval LineLayout::SpanByte(int index) const noexcept {
282  	return Span(index, index+1);
283  }
284  int LineLayout::EndLineStyle() const noexcept {
285  	return styles[numCharsBeforeEOL > 0 ? numCharsBeforeEOL-1 : 0];
286  }
287  void LineLayout::WrapLine(const Document *pdoc, Sci::Position posLineStart, Wrap wrapState, XYPOSITION wrapWidth) {
288  	auto CharacterBoundary = [=](Sci::Position i, Sci::Position moveDir) noexcept -> Sci::Position {
289  		return pdoc->MovePositionOutsideChar(i + posLineStart, moveDir) - posLineStart;
290  	};
291  	lines = 0;
292  	Sci::Position lastLineStart = 0;
293  	XYPOSITION startOffset = wrapWidth;
294  	Sci::Position p = 0;
295  	while (p < numCharsInLine) {
296  		while (p < numCharsInLine && positions[p + 1] < startOffset) {
297  			p++;
298  		}
299  		if (p < numCharsInLine) {
300  			Sci::Position lastGoodBreak = p;
301  			if (p > 0) {
302  				lastGoodBreak = CharacterBoundary(p, -1);
303  			}
304  			if (wrapState != Wrap::Char) {
305  				Sci::Position pos = lastGoodBreak;
306  				while (pos > lastLineStart) {
307  					if (wrapState != Wrap::WhiteSpace && (styles[pos - 1] != styles[pos])) {
308  						break;
309  					}
310  					if (IsBreakSpace(chars[pos - 1]) && !IsBreakSpace(chars[pos])) {
311  						break;
312  					}
313  					pos = CharacterBoundary(pos - 1, -1);
314  				}
315  				if (pos > lastLineStart) {
316  					lastGoodBreak = pos;
317  				}
318  			}
319  			if (lastGoodBreak == lastLineStart) {
320  				if (p > 0) {
321  					lastGoodBreak = CharacterBoundary(p, -1);
322  				}
323  				if (lastGoodBreak == lastLineStart) {
324  					lastGoodBreak = CharacterBoundary(lastGoodBreak + 1, 1);
325  				}
326  			}
327  			lastLineStart = lastGoodBreak;
328  			AddLineStart(lastLineStart);
329  			startOffset = positions[lastLineStart];
330  			startOffset += wrapWidth - wrapIndent;
331  			p = lastLineStart + 1;
332  		}
333  	}
334  	lines++;
335  }
336  ScreenLine::ScreenLine(
337  	const LineLayout *ll_,
338  	int subLine,
339  	const ViewStyle &vs,
340  	XYPOSITION width_,
341  	int tabWidthMinimumPixels_) :
342  	ll(ll_),
343  	start(ll->LineStart(subLine)),
344  	len(ll->LineLength(subLine)),
345  	width(width_),
346  	height(static_cast<float>(vs.lineHeight)),
347  	ctrlCharPadding(vs.ctrlCharPadding),
348  	tabWidth(vs.tabWidth),
349  	tabWidthMinimumPixels(tabWidthMinimumPixels_) {
350  }
351  ScreenLine::~ScreenLine() {
352  }
353  std::string_view ScreenLine::Text() const {
354  	return std::string_view(&ll->chars[start], len);
355  }
356  size_t ScreenLine::Length() const {
357  	return len;
358  }
359  size_t ScreenLine::RepresentationCount() const {
360  	return std::count_if(&ll->bidiData->widthReprs[start],
361  		&ll->bidiData->widthReprs[start + len],
362  		[](XYPOSITION w) noexcept { return w > 0.0f; });
363  }
364  XYPOSITION ScreenLine::Width() const {
365  	return width;
366  }
367  XYPOSITION ScreenLine::Height() const {
368  	return height;
369  }
370  XYPOSITION ScreenLine::TabWidth() const {
371  	return tabWidth;
372  }
373  XYPOSITION ScreenLine::TabWidthMinimumPixels() const {
374  	return static_cast<XYPOSITION>(tabWidthMinimumPixels);
375  }
376  const Font *ScreenLine::FontOfPosition(size_t position) const {
377  	return ll->bidiData->stylesFonts[start + position].get();
378  }
379  XYPOSITION ScreenLine::RepresentationWidth(size_t position) const {
380  	return ll->bidiData->widthReprs[start + position];
381  }
382  XYPOSITION ScreenLine::TabPositionAfter(XYPOSITION xPosition) const {
383  	return (std::floor((xPosition + TabWidthMinimumPixels()) / TabWidth()) + 1) * TabWidth();
384  }
385  bool SignificantLines::LineMayCache(Sci::Line line) const noexcept {
386  	switch (level) {
387  	case LineCache::None:
388  		return false;
389  	case LineCache::Caret:
390  		return line == lineCaret;
391  	case LineCache::Page:
392  		return (std::abs(line - lineCaret) < linesOnScreen) ||
393  			((line >= lineTop) && (line <= (lineTop + linesOnScreen)));
394  	case LineCache::Document:
395  	default:
396  		return true;
397  	}
398  }
399  LineLayoutCache::LineLayoutCache() :
400  	level(LineCache::None),
401  	allInvalidated(false), styleClock(-1) {
402  }
403  LineLayoutCache::~LineLayoutCache() = default;
404  namespace {
405  constexpr size_t AlignUp(size_t value, size_t alignment) noexcept {
406  	return ((value - 1) / alignment + 1) * alignment;
407  }
408  constexpr size_t alignmentLLC = 20;
409  constexpr bool GraphicASCII(char ch) noexcept {
410  	return ch >= ' ' && ch <= '~';
411  }
412  bool AllGraphicASCII(std::string_view text) {
413  	return std::all_of(text.cbegin(), text.cend(), GraphicASCII);
414  }
415  }
416  size_t LineLayoutCache::EntryForLine(Sci::Line line) const noexcept {
417  	switch (level) {
418  	case LineCache::None:
419  		return 0;
420  	case LineCache::Caret:
421  		return 0;
422  	case LineCache::Page:
423  		return 1 + (line % (cache.size() - 1));
424  	case LineCache::Document:
425  		return line;
426  	}
427  	return 0;
428  }
429  void LineLayoutCache::AllocateForLevel(Sci::Line linesOnScreen, Sci::Line linesInDoc) {
430  	size_t lengthForLevel = 0;
431  	if (level == LineCache::Caret) {
432  		lengthForLevel = 1;
433  	} else if (level == LineCache::Page) {
434  		lengthForLevel = AlignUp(linesOnScreen + 1, alignmentLLC);
435  	} else if (level == LineCache::Document) {
436  		lengthForLevel = AlignUp(linesInDoc, alignmentLLC);
437  	}
438  	if (lengthForLevel != cache.size()) {
439  		allInvalidated = false;
440  		cache.resize(lengthForLevel);
441  		if (level == LineCache::Page) {
442  			for (size_t i = 1; i < cache.size();) {
443  				size_t increment = 1;
444  				if (cache[i]) {
445  					const size_t posForLine = EntryForLine(cache[i]->LineNumber());
446  					if (posForLine != i) {
447  						if (cache[posForLine]) {
448  							if (EntryForLine(cache[posForLine]->LineNumber()) == posForLine) {
449  								cache[i].reset();	
450  							} else {
451  								std::swap(cache[i], cache[posForLine]);
452  								increment = 0;
453  							}
454  						} else {
455  							cache[posForLine] = std::move(cache[i]);
456  						}
457  					}
458  				}
459  				i += increment;
460  			}
461  #ifdef CHECK_LLC
462  			for (size_t i = 1; i < cache.size(); i++) {
463  				if (cache[i]) {
464  					PLATFORM_ASSERT(EntryForLine(cache[i]->LineNumber()) == i);
465  				}
466  			}
467  #endif
468  		}
469  	}
470  	PLATFORM_ASSERT(cache.size() == lengthForLevel);
471  }
472  void LineLayoutCache::Deallocate() noexcept {
473  	cache.clear();
474  }
475  void LineLayoutCache::Invalidate(LineLayout::ValidLevel validity_) noexcept {
476  	if (!cache.empty() && !allInvalidated) {
477  		for (const std::shared_ptr<LineLayout> &ll : cache) {
478  			if (ll) {
479  				ll->Invalidate(validity_);
480  			}
481  		}
482  		if (validity_ == LineLayout::ValidLevel::invalid) {
483  			allInvalidated = true;
484  		}
485  	}
486  }
487  void LineLayoutCache::SetLevel(LineCache level_) noexcept {
488  	if (level != level_) {
489  		level = level_;
490  		allInvalidated = false;
491  		cache.clear();
492  	}
493  }
494  std::shared_ptr<LineLayout> LineLayoutCache::Retrieve(Sci::Line lineNumber, Sci::Line lineCaret, int maxChars, int styleClock_,
495                                        Sci::Line linesOnScreen, Sci::Line linesInDoc) {
496  	AllocateForLevel(linesOnScreen, linesInDoc);
497  	if (styleClock != styleClock_) {
498  		Invalidate(LineLayout::ValidLevel::checkTextAndStyle);
499  		styleClock = styleClock_;
500  	}
501  	allInvalidated = false;
<span onclick='openModal()' class='match'>502  	size_t pos = 0;
503  	if (level == LineCache::Page) {
504  		if (!(cache[0] && (cache[0]->LineNumber() == lineNumber))) {
</span>505  			const size_t posForLine = EntryForLine(lineNumber);
506  			if (lineNumber == lineCaret) {
507  				if (cache[0]) {
508  					const size_t posNewForEntry0 = EntryForLine(cache[0]->LineNumber());
509  					if (posForLine == posNewForEntry0) {
510  						std::swap(cache[0], cache[posNewForEntry0]);
511  					} else {
512  						cache[posNewForEntry0] = std::move(cache[0]);
513  					}
514  				}
515  				if (cache[posForLine] && (cache[posForLine]->LineNumber() == lineNumber)) {
516  					cache[0] = std::move(cache[posForLine]);
517  				}
518  			} else {
519  				pos = posForLine;
520  			}
521  		}
522  	} else if (level == LineCache::Document) {
523  		pos = lineNumber;
524  	}
525  	if (pos < cache.size()) {
526  		if (cache[pos] && !cache[pos]->CanHold(lineNumber, maxChars)) {
527  			cache[pos].reset();
528  		}
529  		if (!cache[pos]) {
530  			cache[pos] = std::make_shared<LineLayout>(lineNumber, maxChars);
531  		}
532  #ifdef CHECK_LLC
533  		std::vector<bool> linesInCache(linesInDoc);
534  		for (const auto &entry : cache) {
535  			if (entry) {
536  				PLATFORM_ASSERT(!linesInCache[entry->LineNumber()]);
537  				linesInCache[entry->LineNumber()] = true;
538  			}
539  		}
540  #endif
541  		return cache[pos];
542  	}
543  	return std::make_shared<LineLayout>(lineNumber, maxChars);
544  }
545  namespace {
546  constexpr unsigned int KeyFromString(std::string_view charBytes) noexcept {
547  	PLATFORM_ASSERT(charBytes.length() <= 4);
548  	unsigned int k=0;
549  	for (const unsigned char uc : charBytes) {
550  		k = k * 0x100 + uc;
551  	}
552  	return k;
553  }
554  constexpr unsigned int representationKeyCrLf = KeyFromString("\r\n");
555  const char *const repsC0[] = {
556  	"NUL", "SOH", "STX", "ETX", "EOT", "ENQ", "ACK", "BEL",
557  	"BS", "HT", "LF", "VT", "FF", "CR", "SO", "SI",
558  	"DLE", "DC1", "DC2", "DC3", "DC4", "NAK", "SYN", "ETB",
559  	"CAN", "EM", "SUB", "ESC", "FS", "GS", "RS", "US"
560  };
561  const char *const repsC1[] = {
562  	"PAD", "HOP", "BPH", "NBH", "IND", "NEL", "SSA", "ESA",
563  	"HTS", "HTJ", "VTS", "PLD", "PLU", "RI", "SS2", "SS3",
564  	"DCS", "PU1", "PU2", "STS", "CCH", "MW", "SPA", "EPA",
565  	"SOS", "SGCI", "SCI", "CSI", "ST", "OSC", "PM", "APC"
566  };
567  }
568  namespace Scintilla::Internal {
569  const char *ControlCharacterString(unsigned char ch) noexcept {
570  	if (ch < std::size(repsC0)) {
571  		return repsC0[ch];
572  	} else {
573  		return "BAD";
574  	}
575  }
576  void Hexits(char *hexits, int ch) noexcept {
577  	hexits[0] = 'x';
578  	hexits[1] = "0123456789ABCDEF"[ch / 0x10];
579  	hexits[2] = "0123456789ABCDEF"[ch % 0x10];
580  	hexits[3] = 0;
581  }
582  }
583  void SpecialRepresentations::SetRepresentation(std::string_view charBytes, std::string_view value) {
584  	if ((charBytes.length() <= 4) && (value.length() <= Representation::maxLength)) {
585  		const unsigned int key = KeyFromString(charBytes);
586  		const bool inserted = mapReprs.insert_or_assign(key, Representation(value)).second;
587  		if (inserted) {
588  			const unsigned char ucStart = charBytes.empty() ? 0 : charBytes[0];
589  			startByteHasReprs[ucStart]++;
590  			if (key > maxKey) {
591  				maxKey = key;
592  			}
593  			if (key == representationKeyCrLf) {
594  				crlf = true;
595  			}
596  		}
597  	}
598  }
599  void SpecialRepresentations::SetRepresentationAppearance(std::string_view charBytes, RepresentationAppearance appearance) {
600  	if (charBytes.length() <= 4) {
601  		const unsigned int key = KeyFromString(charBytes);
602  		const MapRepresentation::iterator it = mapReprs.find(key);
603  		if (it == mapReprs.end()) {
604  			return;
605  		}
606  		it->second.appearance = appearance;
607  	}
608  }
609  void SpecialRepresentations::SetRepresentationColour(std::string_view charBytes, ColourRGBA colour) {
610  	if (charBytes.length() <= 4) {
611  		const unsigned int key = KeyFromString(charBytes);
612  		const MapRepresentation::iterator it = mapReprs.find(key);
613  		if (it == mapReprs.end()) {
614  			return;
615  		}
616  		it->second.appearance = it->second.appearance | RepresentationAppearance::Colour;
617  		it->second.colour = colour;
618  	}
619  }
620  void SpecialRepresentations::ClearRepresentation(std::string_view charBytes) {
621  	if (charBytes.length() <= 4) {
622  		const unsigned int key = KeyFromString(charBytes);
623  		const MapRepresentation::iterator it = mapReprs.find(key);
624  		if (it != mapReprs.end()) {
625  			mapReprs.erase(it);
626  			const unsigned char ucStart = charBytes.empty() ? 0 : charBytes[0];
627  			startByteHasReprs[ucStart]--;
628  			if (key == maxKey && startByteHasReprs[ucStart] == 0) {
629  				maxKey = mapReprs.empty() ? 0 : mapReprs.crbegin()->first;
630  			}
631  			if (key == representationKeyCrLf) {
632  				crlf = false;
633  			}
634  		}
635  	}
636  }
637  const Representation *SpecialRepresentations::GetRepresentation(std::string_view charBytes) const {
638  	const unsigned int key = KeyFromString(charBytes);
639  	if (key > maxKey) {
640  		return nullptr;
641  	}
642  	const MapRepresentation::const_iterator it = mapReprs.find(key);
643  	if (it != mapReprs.end()) {
644  		return &(it->second);
645  	}
646  	return nullptr;
647  }
648  const Representation *SpecialRepresentations::RepresentationFromCharacter(std::string_view charBytes) const {
649  	if (charBytes.length() <= 4) {
650  		const unsigned char ucStart = charBytes.empty() ? 0 : charBytes[0];
651  		if (!startByteHasReprs[ucStart])
652  			return nullptr;
653  		return GetRepresentation(charBytes);
654  	}
655  	return nullptr;
656  }
657  void SpecialRepresentations::Clear() {
658  	mapReprs.clear();
659  	constexpr unsigned short none = 0;
660  	std::fill(startByteHasReprs, std::end(startByteHasReprs), none);
661  	maxKey = 0;
662  	crlf = false;
663  }
664  void SpecialRepresentations::SetDefaultRepresentations(int dbcsCodePage) {
665  	Clear();
666  	for (size_t j = 0; j < std::size(repsC0); j++) {
667  		const char c[2] = { static_cast<char>(j), 0 };
668  		SetRepresentation(std::string_view(c, 1), repsC0[j]);
669  	}
670  	SetRepresentation("\x7f", "DEL");
671  	if (CpUtf8 == dbcsCodePage) {
672  		for (size_t j = 0; j < std::size(repsC1); j++) {
673  			const char c1[3] = { '\xc2',  static_cast<char>(0x80 + j), 0 };
674  			SetRepresentation(c1, repsC1[j]);
675  		}
676  		SetRepresentation("\xe2\x80\xa8", "LS");
677  		SetRepresentation("\xe2\x80\xa9", "PS");
678  	}
679  	if (dbcsCodePage) {
680  		for (int k = 0x80; k < 0x100; k++) {
681  			if ((CpUtf8 == dbcsCodePage) || !IsDBCSValidSingleByte(dbcsCodePage, k)) {
682  				const char hiByte[2] = { static_cast<char>(k), 0 };
683  				char hexits[4];
684  				Hexits(hexits, k);
685  				SetRepresentation(hiByte, hexits);
686  			}
687  		}
688  	}
689  }
690  void BreakFinder::Insert(Sci::Position val) {
691  	const int posInLine = static_cast<int>(val);
692  	if (posInLine > nextBreak) {
693  		const std::vector<int>::iterator it = std::lower_bound(selAndEdge.begin(), selAndEdge.end(), posInLine);
694  		if (it == selAndEdge.end()) {
695  			selAndEdge.push_back(posInLine);
696  		} else if (*it != posInLine) {
697  			selAndEdge.insert(it, 1, posInLine);
698  		}
699  	}
700  }
701  BreakFinder::BreakFinder(const LineLayout *ll_, const Selection *psel, Range lineRange_, Sci::Position posLineStart,
702  	XYPOSITION xStart, BreakFor breakFor, const Document *pdoc_, const SpecialRepresentations *preprs_, const ViewStyle *pvsDraw) :
703  	ll(ll_),
704  	lineRange(lineRange_),
705  	nextBreak(static_cast<int>(lineRange_.start)),
706  	saeCurrentPos(0),
707  	saeNext(0),
708  	subBreak(-1),
709  	pdoc(pdoc_),
710  	encodingFamily(pdoc_->CodePageFamily()),
711  	preprs(preprs_) {
712  	if (xStart > 0.0f)
713  		nextBreak = ll->FindBefore(xStart, lineRange);
714  	while ((nextBreak > lineRange.start) && (ll->styles[nextBreak] == ll->styles[nextBreak - 1])) {
715  		nextBreak--;
716  	}
717  	if (FlagSet(breakFor, BreakFor::Selection)) {
718  		const SelectionPosition posStart(posLineStart);
719  		const SelectionPosition posEnd(posLineStart + lineRange.end);
720  		const SelectionSegment segmentLine(posStart, posEnd);
721  		for (size_t r=0; r<psel->Count(); r++) {
722  			const SelectionSegment portion = psel->Range(r).Intersect(segmentLine);
723  			if (!(portion.start == portion.end)) {
724  				if (portion.start.IsValid())
725  					Insert(portion.start.Position() - posLineStart);
726  				if (portion.end.IsValid())
727  					Insert(portion.end.Position() - posLineStart);
728  			}
729  		}
730  		if (FlagSet(pvsDraw->caret.style, CaretStyle::Curses) && !psel->RangeMain().Empty()) {
731  			const Sci::Position caretPos = psel->RangeMain().caret.Position();
732  			const Sci::Position anchorPos = psel->RangeMain().anchor.Position();
733  			if (caretPos < anchorPos) {
734  				const Sci::Position nextPos = pdoc->MovePositionOutsideChar(caretPos + 1, 1);
735  				Insert(nextPos - posLineStart);
736  			} else if (caretPos > anchorPos && pvsDraw->DrawCaretInsideSelection(false, false)) {
737  				const Sci::Position prevPos = pdoc->MovePositionOutsideChar(caretPos - 1, -1);
738  				if (prevPos > anchorPos)
739  					Insert(prevPos - posLineStart);
740  			}
741  		}
742  	}
743  	if (FlagSet(breakFor, BreakFor::Foreground) && pvsDraw->indicatorsSetFore) {
744  		for (const IDecoration *deco : pdoc->decorations->View()) {
745  			if (pvsDraw->indicators[deco->Indicator()].OverridesTextFore()) {
746  				Sci::Position startPos = deco->EndRun(posLineStart);
747  				while (startPos < (posLineStart + lineRange.end)) {
748  					Insert(startPos - posLineStart);
749  					startPos = deco->EndRun(startPos);
750  				}
751  			}
752  		}
753  	}
754  	Insert(ll->edgeColumn);
755  	Insert(lineRange.end);
756  	saeNext = (!selAndEdge.empty()) ? selAndEdge[0] : -1;
757  }
758  BreakFinder::~BreakFinder() noexcept = default;
759  TextSegment BreakFinder::Next() {
760  	if (subBreak < 0) {
761  		const int prev = nextBreak;
762  		const Representation *repr = nullptr;
763  		while (nextBreak < lineRange.end) {
764  			int charWidth = 1;
765  			const char * const chars = &ll->chars[nextBreak];
766  			const unsigned char ch = chars[0];
767  			bool characterStyleConsistent = true;	
768  			if (!UTF8IsAscii(ch) && encodingFamily != EncodingFamily::eightBit) {
769  				if (encodingFamily == EncodingFamily::unicode) {
770  					charWidth = UTF8DrawBytes(chars, lineRange.end - nextBreak);
771  				} else {
772  					charWidth = pdoc->DBCSDrawBytes(std::string_view(chars, lineRange.end - nextBreak));
773  				}
774  				for (int trail = 1; trail < charWidth; trail++) {
775  					if (ll->styles[nextBreak] != ll->styles[nextBreak + trail]) {
776  						characterStyleConsistent = false;
777  					}
778  				}
779  			}
780  			if (!characterStyleConsistent) {
781  				if (nextBreak == prev) {
782  					charWidth = 1;
783  				} else {
784  					break;
785  				}
786  			}
787  			repr = nullptr;
788  			if (preprs->MayContain(ch)) {
789  				if (ch == '\r' && preprs->ContainsCrLf() && chars[1] == '\n') {
790  					charWidth = 2;
791  				}
792  				repr = preprs->GetRepresentation(std::string_view(chars, charWidth));
793  			}
794  			if (((nextBreak > 0) && (ll->styles[nextBreak] != ll->styles[nextBreak - 1])) ||
795  					repr ||
796  					(nextBreak == saeNext)) {
797  				while ((nextBreak >= saeNext) && (saeNext < lineRange.end)) {
798  					saeCurrentPos++;
799  					saeNext = static_cast<int>((saeCurrentPos < selAndEdge.size()) ? selAndEdge[saeCurrentPos] : lineRange.end);
800  				}
801  				if ((nextBreak > prev) || repr) {
802  					if (nextBreak == prev) {
803  						nextBreak += charWidth;
804  					} else {
805  						repr = nullptr;	
806  					}
807  					break;
808  				}
809  			}
810  			nextBreak += charWidth;
811  		}
812  		const int lengthSegment = nextBreak - prev;
813  		if (lengthSegment < lengthStartSubdivision) {
814  			return TextSegment(prev, lengthSegment, repr);
815  		}
816  		subBreak = prev;
817  	}
818  	const int startSegment = subBreak;
819  	const int remaining = nextBreak - startSegment;
820  	int lengthSegment = remaining;
821  	if (lengthSegment > lengthEachSubdivision) {
822  		lengthSegment = static_cast<int>(pdoc->SafeSegment(std::string_view(&ll->chars[startSegment], lengthEachSubdivision)));
823  	}
824  	if (lengthSegment < remaining) {
825  		subBreak += lengthSegment;
826  	} else {
827  		subBreak = -1;
828  	}
829  	return TextSegment(startSegment, lengthSegment);
830  }
831  bool BreakFinder::More() const noexcept {
832  	return (subBreak >= 0) || (nextBreak < lineRange.end);
833  }
834  class PositionCacheEntry {
835  	uint16_t styleNumber;
836  	uint16_t len;
837  	uint16_t clock;
838  	bool unicode;
839  	std::unique_ptr<XYPOSITION[]> positions;
840  public:
841  	PositionCacheEntry() noexcept;
842  	PositionCacheEntry(const PositionCacheEntry &);
843  	PositionCacheEntry(PositionCacheEntry &&) noexcept = default;
844  	void operator=(const PositionCacheEntry &) = delete;
845  	void operator=(PositionCacheEntry &&) = delete;
846  	~PositionCacheEntry();
847  	void Set(unsigned int styleNumber_, bool unicode_, std::string_view sv, const XYPOSITION *positions_, uint16_t clock_);
848  	void Clear() noexcept;
849  	bool Retrieve(unsigned int styleNumber_, bool unicode_, std::string_view sv, XYPOSITION *positions_) const noexcept;
850  	static size_t Hash(unsigned int styleNumber_, bool unicode_, std::string_view sv) noexcept;
851  	bool NewerThan(const PositionCacheEntry &other) const noexcept;
852  	void ResetClock() noexcept;
853  };
854  class PositionCache : public IPositionCache {
855  	std::vector<PositionCacheEntry> pces;
856  	std::mutex mutex;
857  	uint16_t clock;
858  	bool allClear;
859  public:
860  	PositionCache();
861  	PositionCache(const PositionCache &) = delete;
862  	PositionCache(PositionCache &&) = delete;
863  	void operator=(const PositionCache &) = delete;
864  	void operator=(PositionCache &&) = delete;
865  	~PositionCache() override = default;
866  	void Clear() noexcept override;
867  	void SetSize(size_t size_) override;
868  	size_t GetSize() const noexcept override;
869  	void MeasureWidths(Surface *surface, const ViewStyle &vstyle, unsigned int styleNumber,
870  		bool unicode, std::string_view sv, XYPOSITION *positions, bool needsLocking) override;
871  };
872  PositionCacheEntry::PositionCacheEntry() noexcept :
873  	styleNumber(0), len(0), clock(0), unicode(false) {
874  }
875  PositionCacheEntry::PositionCacheEntry(const PositionCacheEntry &other) :
876  	styleNumber(other.styleNumber), len(other.len), clock(other.clock), unicode(other.unicode) {
877  	if (other.positions) {
878  		const size_t lenData = len + (len / sizeof(XYPOSITION)) + 1;
879  		positions = std::make_unique<XYPOSITION[]>(lenData);
880  		memcpy(positions.get(), other.positions.get(), lenData * sizeof(XYPOSITION));
881  	}
882  }
883  void PositionCacheEntry::Set(unsigned int styleNumber_, bool unicode_, std::string_view sv,
884  	const XYPOSITION *positions_, uint16_t clock_) {
885  	Clear();
886  	styleNumber = static_cast<uint16_t>(styleNumber_);
887  	len = static_cast<uint16_t>(sv.length());
888  	clock = clock_;
889  	unicode = unicode_;
890  	if (sv.data() && positions_) {
891  		positions = std::make_unique<XYPOSITION[]>(len + (len / sizeof(XYPOSITION)) + 1);
892  		for (unsigned int i=0; i<len; i++) {
893  			positions[i] = positions_[i];
894  		}
895  		memcpy(&positions[len], sv.data(), sv.length());
896  	}
897  }
898  PositionCacheEntry::~PositionCacheEntry() {
899  	Clear();
900  }
901  void PositionCacheEntry::Clear() noexcept {
902  	positions.reset();
903  	styleNumber = 0;
904  	len = 0;
905  	clock = 0;
906  }
907  bool PositionCacheEntry::Retrieve(unsigned int styleNumber_, bool unicode_, std::string_view sv, XYPOSITION *positions_) const noexcept {
908  	if ((styleNumber == styleNumber_) && (unicode == unicode_) && (len == sv.length()) &&
909  		(memcmp(&positions[len], sv.data(), sv.length())== 0)) {
910  		for (unsigned int i=0; i<len; i++) {
911  			positions_[i] = positions[i];
912  		}
913  		return true;
914  	} else {
915  		return false;
916  	}
917  }
918  size_t PositionCacheEntry::Hash(unsigned int styleNumber_, bool unicode_, std::string_view sv) noexcept {
919  	const size_t h1 = std::hash<std::string_view>{}(sv);
920  	const size_t h2 = std::hash<unsigned int>{}(styleNumber_);
921  	return h1 ^ (h2 << 1) ^ static_cast<size_t>(unicode_);
922  }
923  bool PositionCacheEntry::NewerThan(const PositionCacheEntry &other) const noexcept {
924  	return clock > other.clock;
925  }
926  void PositionCacheEntry::ResetClock() noexcept {
927  	if (clock > 0) {
928  		clock = 1;
929  	}
930  }
931  PositionCache::PositionCache() {
932  	clock = 1;
933  	pces.resize(0x400);
934  	allClear = true;
935  }
936  void PositionCache::Clear() noexcept {
937  	if (!allClear) {
938  		for (PositionCacheEntry &pce : pces) {
939  			pce.Clear();
940  		}
941  	}
942  	clock = 1;
943  	allClear = true;
944  }
945  void PositionCache::SetSize(size_t size_) {
946  	Clear();
947  	pces.resize(size_);
948  }
949  size_t PositionCache::GetSize() const noexcept {
950  	return pces.size();
951  }
952  void PositionCache::MeasureWidths(Surface *surface, const ViewStyle &vstyle, unsigned int styleNumber,
953  	bool unicode, std::string_view sv, XYPOSITION *positions, bool needsLocking) {
954  	const Style &style = vstyle.styles[styleNumber];
955  	if (style.monospaceASCII) {
956  		if (AllGraphicASCII(sv)) {
957  			const XYPOSITION monospaceCharacterWidth = style.monospaceCharacterWidth;
958  			for (size_t i = 0; i < sv.length(); i++) {
959  				positions[i] = monospaceCharacterWidth * (i+1);
960  			}
961  			return;
962  		}
963  	}
964  	size_t probe = pces.size();	
965  	if ((!pces.empty()) && (sv.length() < 30)) {
966  		const size_t hashValue = PositionCacheEntry::Hash(styleNumber, unicode, sv);
967  		probe = hashValue % pces.size();
968  		std::unique_lock<std::mutex> guard(mutex, std::defer_lock);
969  		if (needsLocking) {
970  			guard.lock();
971  		}
972  		if (pces[probe].Retrieve(styleNumber, unicode, sv, positions)) {
973  			return;
974  		}
975  		const size_t probe2 = (hashValue * 37) % pces.size();
976  		if (pces[probe2].Retrieve(styleNumber, unicode, sv, positions)) {
977  			return;
978  		}
979  		if (pces[probe].NewerThan(pces[probe2])) {
980  			probe = probe2;
981  		}
982  	}
983  	const Font *fontStyle = style.font.get();
984  	if (unicode) {
985  		surface->MeasureWidthsUTF8(fontStyle, sv, positions);
986  	} else {
987  		surface->MeasureWidths(fontStyle, sv, positions);
988  	}
989  	if (probe < pces.size()) {
990  		std::unique_lock<std::mutex> guard(mutex, std::defer_lock);
991  		if (needsLocking) {
992  			guard.lock();
993  		}
994  		clock++;
995  		if (clock > 60000) {
996  			for (PositionCacheEntry &pce : pces) {
997  				pce.ResetClock();
998  			}
999  			clock = 2;
1000  		}
1001  		allClear = false;
1002  		pces[probe].Set(styleNumber, unicode, sv, positions, clock);
1003  	}
1004  }
1005  std::unique_ptr<IPositionCache> Scintilla::Internal::CreatePositionCache() {
1006  	return std::make_unique<PositionCache>();
1007  }
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-PositionCache.cxx</h3>
            <pre><code>1  #include <cstddef>
2  #include <cstdlib>
3  #include <cstdint>
4  #include <cstring>
5  #include <cmath>
6  #include <stdexcept>
7  #include <string>
8  #include <string_view>
9  #include <vector>
10  #include <map>
11  #include <set>
12  #include <optional>
13  #include <algorithm>
14  #include <iterator>
15  #include <memory>
16  #include <mutex>
17  #include "ScintillaTypes.h"
18  #include "ScintillaMessages.h"
19  #include "ILoader.h"
20  #include "ILexer.h"
21  #include "Debugging.h"
22  #include "Geometry.h"
23  #include "Platform.h"
24  #include "CharacterType.h"
25  #include "CharacterCategoryMap.h"
26  #include "Position.h"
27  #include "UniqueString.h"
28  #include "SplitVector.h"
29  #include "Partitioning.h"
30  #include "RunStyles.h"
31  #include "ContractionState.h"
32  #include "CellBuffer.h"
33  #include "KeyMap.h"
34  #include "Indicator.h"
35  #include "LineMarker.h"
36  #include "Style.h"
37  #include "ViewStyle.h"
38  #include "CharClassify.h"
39  #include "Decoration.h"
40  #include "CaseFolder.h"
41  #include "Document.h"
42  #include "UniConversion.h"
43  #include "DBCS.h"
44  #include "Selection.h"
45  #include "PositionCache.h"
46  using namespace Scintilla;
47  using namespace Scintilla::Internal;
48  void BidiData::Resize(size_t maxLineLength_) {
49  	stylesFonts.resize(maxLineLength_ + 1);
50  	widthReprs.resize(maxLineLength_ + 1);
51  }
52  LineLayout::LineLayout(Sci::Line lineNumber_, int maxLineLength_) :
53  	lenLineStarts(0),
54  	lineNumber(lineNumber_),
55  	maxLineLength(-1),
56  	numCharsInLine(0),
57  	numCharsBeforeEOL(0),
58  	validity(ValidLevel::invalid),
59  	xHighlightGuide(0),
60  	highlightColumn(false),
61  	containsCaret(false),
62  	edgeColumn(0),
63  	bracePreviousStyles{},
64  	widthLine(wrapWidthInfinite),
65  	lines(1),
66  	wrapIndent(0) {
67  	Resize(maxLineLength_);
68  }
69  LineLayout::~LineLayout() {
70  	Free();
71  }
72  void LineLayout::Resize(int maxLineLength_) {
73  	if (maxLineLength_ > maxLineLength) {
74  		Free();
75  		const size_t lineAllocation = maxLineLength_ + 1;
76  		chars = std::make_unique<char[]>(lineAllocation);
77  		styles = std::make_unique<unsigned char []>(lineAllocation);
78  		positions = std::make_unique<XYPOSITION []>(lineAllocation + 1);
79  		if (bidiData) {
80  			bidiData->Resize(maxLineLength_);
81  		}
82  		maxLineLength = maxLineLength_;
83  	}
84  }
85  void LineLayout::ReSet(Sci::Line lineNumber_, Sci::Position maxLineLength_) {
86  	lineNumber = lineNumber_;
87  	Resize(static_cast<int>(maxLineLength_));
88  	lines = 0;
89  	Invalidate(ValidLevel::invalid);
90  }
91  void LineLayout::EnsureBidiData() {
92  	if (!bidiData) {
93  		bidiData = std::make_unique<BidiData>();
94  		bidiData->Resize(maxLineLength);
95  	}
96  }
97  void LineLayout::Free() noexcept {
98  	chars.reset();
99  	styles.reset();
100  	positions.reset();
101  	lineStarts.reset();
102  	lenLineStarts = 0;
103  	bidiData.reset();
104  }
105  void LineLayout::ClearPositions() {
106  	std::fill(&positions[0], &positions[maxLineLength + 2], 0.0f);
107  }
108  void LineLayout::Invalidate(ValidLevel validity_) noexcept {
109  	if (validity > validity_)
110  		validity = validity_;
111  }
112  Sci::Line LineLayout::LineNumber() const noexcept {
113  	return lineNumber;
114  }
115  bool LineLayout::CanHold(Sci::Line lineDoc, int lineLength_) const noexcept {
116  	return (lineNumber == lineDoc) && (lineLength_ <= maxLineLength);
117  }
118  int LineLayout::LineStart(int line) const noexcept {
119  	if (line <= 0) {
120  		return 0;
121  	} else if ((line >= lines) || !lineStarts) {
122  		return numCharsInLine;
123  	} else {
124  		return lineStarts[line];
125  	}
126  }
127  int LineLayout::LineLength(int line) const noexcept {
128  	if (!lineStarts) {
129  		return numCharsInLine;
130  	} if (line >= lines - 1) {
131  		return numCharsInLine - lineStarts[line];
132  	} else {
133  		return lineStarts[line + 1] - lineStarts[line];
134  	}
135  }
136  int LineLayout::LineLastVisible(int line, Scope scope) const noexcept {
137  	if (line < 0) {
138  		return 0;
139  	} else if ((line >= lines-1) || !lineStarts) {
140  		return scope == Scope::visibleOnly ? numCharsBeforeEOL : numCharsInLine;
141  	} else {
142  		return lineStarts[line+1];
143  	}
144  }
145  Range LineLayout::SubLineRange(int subLine, Scope scope) const noexcept {
146  	return Range(LineStart(subLine), LineLastVisible(subLine, scope));
147  }
148  bool LineLayout::InLine(int offset, int line) const noexcept {
149  	return ((offset >= LineStart(line)) && (offset < LineStart(line + 1))) ||
150  		((offset == numCharsInLine) && (line == (lines-1)));
151  }
152  int LineLayout::SubLineFromPosition(int posInLine, PointEnd pe) const noexcept {
153  	if (!lineStarts || (posInLine > maxLineLength)) {
154  		return lines - 1;
155  	}
156  	for (int line = 0; line < lines; line++) {
157  		if (FlagSet(pe, PointEnd::subLineEnd)) {
158  			if (lineStarts[line + 1] <= posInLine + 1)
159  				return line;
160  		} else {
161  			if (lineStarts[line + 1] <= posInLine)
162  				return line;
163  		}
164  	}
165  	return lines - 1;
166  }
167  void LineLayout::AddLineStart(Sci::Position start) {
168  	lines++;
169  	if (lines >= lenLineStarts) {
170  		const int newMaxLines = lines + 20;
171  		std::unique_ptr<int[]> newLineStarts = std::make_unique<int[]>(newMaxLines);
172  		if (lenLineStarts) {
173  			std::copy(lineStarts.get(), lineStarts.get() + lenLineStarts, newLineStarts.get());
174  		}
175  		lineStarts = std::move(newLineStarts);
176  		lenLineStarts = newMaxLines;
177  	}
178  	lineStarts[lines] = static_cast<int>(start);
179  }
180  void LineLayout::SetBracesHighlight(Range rangeLine, const Sci::Position braces[],
181                                      char bracesMatchStyle, int xHighlight, bool ignoreStyle) {
182  	if (!ignoreStyle && rangeLine.ContainsCharacter(braces[0])) {
183  		const Sci::Position braceOffset = braces[0] - rangeLine.start;
184  		if (braceOffset < numCharsInLine) {
185  			bracePreviousStyles[0] = styles[braceOffset];
186  			styles[braceOffset] = bracesMatchStyle;
187  		}
188  	}
189  	if (!ignoreStyle && rangeLine.ContainsCharacter(braces[1])) {
190  		const Sci::Position braceOffset = braces[1] - rangeLine.start;
191  		if (braceOffset < numCharsInLine) {
192  			bracePreviousStyles[1] = styles[braceOffset];
193  			styles[braceOffset] = bracesMatchStyle;
194  		}
195  	}
196  	if ((braces[0] >= rangeLine.start && braces[1] <= rangeLine.end) ||
197  	        (braces[1] >= rangeLine.start && braces[0] <= rangeLine.end)) {
198  		xHighlightGuide = xHighlight;
199  	}
200  }
201  void LineLayout::RestoreBracesHighlight(Range rangeLine, const Sci::Position braces[], bool ignoreStyle) {
202  	if (!ignoreStyle && rangeLine.ContainsCharacter(braces[0])) {
203  		const Sci::Position braceOffset = braces[0] - rangeLine.start;
204  		if (braceOffset < numCharsInLine) {
205  			styles[braceOffset] = bracePreviousStyles[0];
206  		}
207  	}
208  	if (!ignoreStyle && rangeLine.ContainsCharacter(braces[1])) {
209  		const Sci::Position braceOffset = braces[1] - rangeLine.start;
210  		if (braceOffset < numCharsInLine) {
211  			styles[braceOffset] = bracePreviousStyles[1];
212  		}
213  	}
214  	xHighlightGuide = 0;
215  }
216  int LineLayout::FindBefore(XYPOSITION x, Range range) const noexcept {
217  	Sci::Position lower = range.start;
218  	Sci::Position upper = range.end;
219  	do {
220  		const Sci::Position middle = (upper + lower + 1) / 2; 	
221  		const XYPOSITION posMiddle = positions[middle];
222  		if (x < posMiddle) {
223  			upper = middle - 1;
224  		} else {
225  			lower = middle;
226  		}
227  	} while (lower < upper);
228  	return static_cast<int>(lower);
229  }
230  int LineLayout::FindPositionFromX(XYPOSITION x, Range range, bool charPosition) const noexcept {
231  	int pos = FindBefore(x, range);
232  	while (pos < range.end) {
233  		if (charPosition) {
234  			if (x < (positions[pos + 1])) {
235  				return pos;
236  			}
237  		} else {
238  			if (x < ((positions[pos] + positions[pos + 1]) / 2)) {
239  				return pos;
240  			}
241  		}
242  		pos++;
243  	}
244  	return static_cast<int>(range.end);
245  }
246  Point LineLayout::PointFromPosition(int posInLine, int lineHeight, PointEnd pe) const noexcept {
247  	Point pt;
248  	if (posInLine > maxLineLength) {
249  		pt.x = positions[maxLineLength] - positions[LineStart(lines)];
250  	}
251  	for (int subLine = 0; subLine < lines; subLine++) {
252  		const Range rangeSubLine = SubLineRange(subLine, Scope::visibleOnly);
253  		if (posInLine >= rangeSubLine.start) {
254  			pt.y = static_cast<XYPOSITION>(subLine*lineHeight);
255  			if (posInLine <= rangeSubLine.end) {
256  				pt.x = positions[posInLine] - positions[rangeSubLine.start];
257  				if (rangeSubLine.start != 0)	
258  					pt.x += wrapIndent;
259  				if (FlagSet(pe, PointEnd::subLineEnd))	
260  					break;
261  			} else if (FlagSet(pe, PointEnd::lineEnd) && (subLine == (lines-1))) {
262  				pt.x = positions[numCharsInLine] - positions[rangeSubLine.start];
263  				if (rangeSubLine.start != 0)	
264  					pt.x += wrapIndent;
265  			}
266  		} else {
267  			break;
268  		}
269  	}
270  	return pt;
271  }
272  XYPOSITION LineLayout::XInLine(Sci::Position index) const noexcept {
273  	if (index <= numCharsInLine) {
274  		return positions[index];
275  	}
276  	return positions[numCharsInLine] + 1.0;
277  }
278  Interval LineLayout::Span(int start, int end) const noexcept {
279  	return { positions[start], positions[end] };
280  }
281  Interval LineLayout::SpanByte(int index) const noexcept {
282  	return Span(index, index+1);
283  }
284  int LineLayout::EndLineStyle() const noexcept {
285  	return styles[numCharsBeforeEOL > 0 ? numCharsBeforeEOL-1 : 0];
286  }
287  void LineLayout::WrapLine(const Document *pdoc, Sci::Position posLineStart, Wrap wrapState, XYPOSITION wrapWidth) {
288  	auto CharacterBoundary = [=](Sci::Position i, Sci::Position moveDir) noexcept -> Sci::Position {
289  		return pdoc->MovePositionOutsideChar(i + posLineStart, moveDir) - posLineStart;
290  	};
291  	lines = 0;
292  	Sci::Position lastLineStart = 0;
293  	XYPOSITION startOffset = wrapWidth;
294  	Sci::Position p = 0;
295  	while (p < numCharsInLine) {
296  		while (p < numCharsInLine && positions[p + 1] < startOffset) {
297  			p++;
298  		}
299  		if (p < numCharsInLine) {
300  			Sci::Position lastGoodBreak = p;
301  			if (p > 0) {
302  				lastGoodBreak = CharacterBoundary(p, -1);
303  			}
304  			if (wrapState != Wrap::Char) {
305  				Sci::Position pos = lastGoodBreak;
306  				while (pos > lastLineStart) {
307  					if (wrapState != Wrap::WhiteSpace && (styles[pos - 1] != styles[pos])) {
308  						break;
309  					}
310  					if (IsBreakSpace(chars[pos - 1]) && !IsBreakSpace(chars[pos])) {
311  						break;
312  					}
313  					pos = CharacterBoundary(pos - 1, -1);
314  				}
315  				if (pos > lastLineStart) {
316  					lastGoodBreak = pos;
317  				}
318  			}
319  			if (lastGoodBreak == lastLineStart) {
320  				if (p > 0) {
321  					lastGoodBreak = CharacterBoundary(p, -1);
322  				}
323  				if (lastGoodBreak == lastLineStart) {
324  					lastGoodBreak = CharacterBoundary(lastGoodBreak + 1, 1);
325  				}
326  			}
327  			lastLineStart = lastGoodBreak;
328  			AddLineStart(lastLineStart);
329  			startOffset = positions[lastLineStart];
330  			startOffset += wrapWidth - wrapIndent;
331  			p = lastLineStart + 1;
332  		}
333  	}
334  	lines++;
335  }
336  ScreenLine::ScreenLine(
337  	const LineLayout *ll_,
338  	int subLine,
339  	const ViewStyle &vs,
340  	XYPOSITION width_,
341  	int tabWidthMinimumPixels_) :
342  	ll(ll_),
343  	start(ll->LineStart(subLine)),
344  	len(ll->LineLength(subLine)),
345  	width(width_),
346  	height(static_cast<float>(vs.lineHeight)),
347  	ctrlCharPadding(vs.ctrlCharPadding),
348  	tabWidth(vs.tabWidth),
349  	tabWidthMinimumPixels(tabWidthMinimumPixels_) {
350  }
351  ScreenLine::~ScreenLine() {
352  }
353  std::string_view ScreenLine::Text() const {
354  	return std::string_view(&ll->chars[start], len);
355  }
356  size_t ScreenLine::Length() const {
357  	return len;
358  }
359  size_t ScreenLine::RepresentationCount() const {
360  	return std::count_if(&ll->bidiData->widthReprs[start],
361  		&ll->bidiData->widthReprs[start + len],
362  		[](XYPOSITION w) noexcept { return w > 0.0f; });
363  }
364  XYPOSITION ScreenLine::Width() const {
365  	return width;
366  }
367  XYPOSITION ScreenLine::Height() const {
368  	return height;
369  }
370  XYPOSITION ScreenLine::TabWidth() const {
371  	return tabWidth;
372  }
373  XYPOSITION ScreenLine::TabWidthMinimumPixels() const {
374  	return static_cast<XYPOSITION>(tabWidthMinimumPixels);
375  }
376  const Font *ScreenLine::FontOfPosition(size_t position) const {
377  	return ll->bidiData->stylesFonts[start + position].get();
378  }
379  XYPOSITION ScreenLine::RepresentationWidth(size_t position) const {
380  	return ll->bidiData->widthReprs[start + position];
381  }
382  XYPOSITION ScreenLine::TabPositionAfter(XYPOSITION xPosition) const {
383  	return (std::floor((xPosition + TabWidthMinimumPixels()) / TabWidth()) + 1) * TabWidth();
384  }
385  bool SignificantLines::LineMayCache(Sci::Line line) const noexcept {
386  	switch (level) {
387  	case LineCache::None:
388  		return false;
389  	case LineCache::Caret:
390  		return line == lineCaret;
391  	case LineCache::Page:
392  		return (std::abs(line - lineCaret) < linesOnScreen) ||
393  			((line >= lineTop) && (line <= (lineTop + linesOnScreen)));
394  	case LineCache::Document:
395  	default:
396  		return true;
397  	}
398  }
399  LineLayoutCache::LineLayoutCache() :
400  	level(LineCache::None),
401  	allInvalidated(false), styleClock(-1) {
402  }
403  LineLayoutCache::~LineLayoutCache() = default;
404  namespace {
405  constexpr size_t AlignUp(size_t value, size_t alignment) noexcept {
406  	return ((value - 1) / alignment + 1) * alignment;
407  }
408  constexpr size_t alignmentLLC = 20;
409  constexpr bool GraphicASCII(char ch) noexcept {
410  	return ch >= ' ' && ch <= '~';
411  }
412  bool AllGraphicASCII(std::string_view text) {
413  	return std::all_of(text.cbegin(), text.cend(), GraphicASCII);
414  }
415  }
416  size_t LineLayoutCache::EntryForLine(Sci::Line line) const noexcept {
417  	switch (level) {
418  	case LineCache::None:
419  		return 0;
420  	case LineCache::Caret:
421  		return 0;
422  	case LineCache::Page:
423  		return 1 + (line % (cache.size() - 1));
424  	case LineCache::Document:
425  		return line;
426  	}
427  	return 0;
428  }
429  void LineLayoutCache::AllocateForLevel(Sci::Line linesOnScreen, Sci::Line linesInDoc) {
<span onclick='openModal()' class='match'>430  	size_t lengthForLevel = 0;
431  	if (level == LineCache::Caret) {
432  		lengthForLevel = 1;
</span>433  	} else if (level == LineCache::Page) {
434  		lengthForLevel = AlignUp(linesOnScreen + 1, alignmentLLC);
435  	} else if (level == LineCache::Document) {
436  		lengthForLevel = AlignUp(linesInDoc, alignmentLLC);
437  	}
438  	if (lengthForLevel != cache.size()) {
439  		allInvalidated = false;
440  		cache.resize(lengthForLevel);
441  		if (level == LineCache::Page) {
442  			for (size_t i = 1; i < cache.size();) {
443  				size_t increment = 1;
444  				if (cache[i]) {
445  					const size_t posForLine = EntryForLine(cache[i]->LineNumber());
446  					if (posForLine != i) {
447  						if (cache[posForLine]) {
448  							if (EntryForLine(cache[posForLine]->LineNumber()) == posForLine) {
449  								cache[i].reset();	
450  							} else {
451  								std::swap(cache[i], cache[posForLine]);
452  								increment = 0;
453  							}
454  						} else {
455  							cache[posForLine] = std::move(cache[i]);
456  						}
457  					}
458  				}
459  				i += increment;
460  			}
461  #ifdef CHECK_LLC
462  			for (size_t i = 1; i < cache.size(); i++) {
463  				if (cache[i]) {
464  					PLATFORM_ASSERT(EntryForLine(cache[i]->LineNumber()) == i);
465  				}
466  			}
467  #endif
468  		}
469  	}
470  	PLATFORM_ASSERT(cache.size() == lengthForLevel);
471  }
472  void LineLayoutCache::Deallocate() noexcept {
473  	cache.clear();
474  }
475  void LineLayoutCache::Invalidate(LineLayout::ValidLevel validity_) noexcept {
476  	if (!cache.empty() && !allInvalidated) {
477  		for (const std::shared_ptr<LineLayout> &ll : cache) {
478  			if (ll) {
479  				ll->Invalidate(validity_);
480  			}
481  		}
482  		if (validity_ == LineLayout::ValidLevel::invalid) {
483  			allInvalidated = true;
484  		}
485  	}
486  }
487  void LineLayoutCache::SetLevel(LineCache level_) noexcept {
488  	if (level != level_) {
489  		level = level_;
490  		allInvalidated = false;
491  		cache.clear();
492  	}
493  }
494  std::shared_ptr<LineLayout> LineLayoutCache::Retrieve(Sci::Line lineNumber, Sci::Line lineCaret, int maxChars, int styleClock_,
495                                        Sci::Line linesOnScreen, Sci::Line linesInDoc) {
496  	AllocateForLevel(linesOnScreen, linesInDoc);
497  	if (styleClock != styleClock_) {
498  		Invalidate(LineLayout::ValidLevel::checkTextAndStyle);
499  		styleClock = styleClock_;
500  	}
501  	allInvalidated = false;
502  	size_t pos = 0;
503  	if (level == LineCache::Page) {
504  		if (!(cache[0] && (cache[0]->LineNumber() == lineNumber))) {
505  			const size_t posForLine = EntryForLine(lineNumber);
506  			if (lineNumber == lineCaret) {
507  				if (cache[0]) {
508  					const size_t posNewForEntry0 = EntryForLine(cache[0]->LineNumber());
509  					if (posForLine == posNewForEntry0) {
510  						std::swap(cache[0], cache[posNewForEntry0]);
511  					} else {
512  						cache[posNewForEntry0] = std::move(cache[0]);
513  					}
514  				}
515  				if (cache[posForLine] && (cache[posForLine]->LineNumber() == lineNumber)) {
516  					cache[0] = std::move(cache[posForLine]);
517  				}
518  			} else {
519  				pos = posForLine;
520  			}
521  		}
522  	} else if (level == LineCache::Document) {
523  		pos = lineNumber;
524  	}
525  	if (pos < cache.size()) {
526  		if (cache[pos] && !cache[pos]->CanHold(lineNumber, maxChars)) {
527  			cache[pos].reset();
528  		}
529  		if (!cache[pos]) {
530  			cache[pos] = std::make_shared<LineLayout>(lineNumber, maxChars);
531  		}
532  #ifdef CHECK_LLC
533  		std::vector<bool> linesInCache(linesInDoc);
534  		for (const auto &entry : cache) {
535  			if (entry) {
536  				PLATFORM_ASSERT(!linesInCache[entry->LineNumber()]);
537  				linesInCache[entry->LineNumber()] = true;
538  			}
539  		}
540  #endif
541  		return cache[pos];
542  	}
543  	return std::make_shared<LineLayout>(lineNumber, maxChars);
544  }
545  namespace {
546  constexpr unsigned int KeyFromString(std::string_view charBytes) noexcept {
547  	PLATFORM_ASSERT(charBytes.length() <= 4);
548  	unsigned int k=0;
549  	for (const unsigned char uc : charBytes) {
550  		k = k * 0x100 + uc;
551  	}
552  	return k;
553  }
554  constexpr unsigned int representationKeyCrLf = KeyFromString("\r\n");
555  const char *const repsC0[] = {
556  	"NUL", "SOH", "STX", "ETX", "EOT", "ENQ", "ACK", "BEL",
557  	"BS", "HT", "LF", "VT", "FF", "CR", "SO", "SI",
558  	"DLE", "DC1", "DC2", "DC3", "DC4", "NAK", "SYN", "ETB",
559  	"CAN", "EM", "SUB", "ESC", "FS", "GS", "RS", "US"
560  };
561  const char *const repsC1[] = {
562  	"PAD", "HOP", "BPH", "NBH", "IND", "NEL", "SSA", "ESA",
563  	"HTS", "HTJ", "VTS", "PLD", "PLU", "RI", "SS2", "SS3",
564  	"DCS", "PU1", "PU2", "STS", "CCH", "MW", "SPA", "EPA",
565  	"SOS", "SGCI", "SCI", "CSI", "ST", "OSC", "PM", "APC"
566  };
567  }
568  namespace Scintilla::Internal {
569  const char *ControlCharacterString(unsigned char ch) noexcept {
570  	if (ch < std::size(repsC0)) {
571  		return repsC0[ch];
572  	} else {
573  		return "BAD";
574  	}
575  }
576  void Hexits(char *hexits, int ch) noexcept {
577  	hexits[0] = 'x';
578  	hexits[1] = "0123456789ABCDEF"[ch / 0x10];
579  	hexits[2] = "0123456789ABCDEF"[ch % 0x10];
580  	hexits[3] = 0;
581  }
582  }
583  void SpecialRepresentations::SetRepresentation(std::string_view charBytes, std::string_view value) {
584  	if ((charBytes.length() <= 4) && (value.length() <= Representation::maxLength)) {
585  		const unsigned int key = KeyFromString(charBytes);
586  		const bool inserted = mapReprs.insert_or_assign(key, Representation(value)).second;
587  		if (inserted) {
588  			const unsigned char ucStart = charBytes.empty() ? 0 : charBytes[0];
589  			startByteHasReprs[ucStart]++;
590  			if (key > maxKey) {
591  				maxKey = key;
592  			}
593  			if (key == representationKeyCrLf) {
594  				crlf = true;
595  			}
596  		}
597  	}
598  }
599  void SpecialRepresentations::SetRepresentationAppearance(std::string_view charBytes, RepresentationAppearance appearance) {
600  	if (charBytes.length() <= 4) {
601  		const unsigned int key = KeyFromString(charBytes);
602  		const MapRepresentation::iterator it = mapReprs.find(key);
603  		if (it == mapReprs.end()) {
604  			return;
605  		}
606  		it->second.appearance = appearance;
607  	}
608  }
609  void SpecialRepresentations::SetRepresentationColour(std::string_view charBytes, ColourRGBA colour) {
610  	if (charBytes.length() <= 4) {
611  		const unsigned int key = KeyFromString(charBytes);
612  		const MapRepresentation::iterator it = mapReprs.find(key);
613  		if (it == mapReprs.end()) {
614  			return;
615  		}
616  		it->second.appearance = it->second.appearance | RepresentationAppearance::Colour;
617  		it->second.colour = colour;
618  	}
619  }
620  void SpecialRepresentations::ClearRepresentation(std::string_view charBytes) {
621  	if (charBytes.length() <= 4) {
622  		const unsigned int key = KeyFromString(charBytes);
623  		const MapRepresentation::iterator it = mapReprs.find(key);
624  		if (it != mapReprs.end()) {
625  			mapReprs.erase(it);
626  			const unsigned char ucStart = charBytes.empty() ? 0 : charBytes[0];
627  			startByteHasReprs[ucStart]--;
628  			if (key == maxKey && startByteHasReprs[ucStart] == 0) {
629  				maxKey = mapReprs.empty() ? 0 : mapReprs.crbegin()->first;
630  			}
631  			if (key == representationKeyCrLf) {
632  				crlf = false;
633  			}
634  		}
635  	}
636  }
637  const Representation *SpecialRepresentations::GetRepresentation(std::string_view charBytes) const {
638  	const unsigned int key = KeyFromString(charBytes);
639  	if (key > maxKey) {
640  		return nullptr;
641  	}
642  	const MapRepresentation::const_iterator it = mapReprs.find(key);
643  	if (it != mapReprs.end()) {
644  		return &(it->second);
645  	}
646  	return nullptr;
647  }
648  const Representation *SpecialRepresentations::RepresentationFromCharacter(std::string_view charBytes) const {
649  	if (charBytes.length() <= 4) {
650  		const unsigned char ucStart = charBytes.empty() ? 0 : charBytes[0];
651  		if (!startByteHasReprs[ucStart])
652  			return nullptr;
653  		return GetRepresentation(charBytes);
654  	}
655  	return nullptr;
656  }
657  void SpecialRepresentations::Clear() {
658  	mapReprs.clear();
659  	constexpr unsigned short none = 0;
660  	std::fill(startByteHasReprs, std::end(startByteHasReprs), none);
661  	maxKey = 0;
662  	crlf = false;
663  }
664  void SpecialRepresentations::SetDefaultRepresentations(int dbcsCodePage) {
665  	Clear();
666  	for (size_t j = 0; j < std::size(repsC0); j++) {
667  		const char c[2] = { static_cast<char>(j), 0 };
668  		SetRepresentation(std::string_view(c, 1), repsC0[j]);
669  	}
670  	SetRepresentation("\x7f", "DEL");
671  	if (CpUtf8 == dbcsCodePage) {
672  		for (size_t j = 0; j < std::size(repsC1); j++) {
673  			const char c1[3] = { '\xc2',  static_cast<char>(0x80 + j), 0 };
674  			SetRepresentation(c1, repsC1[j]);
675  		}
676  		SetRepresentation("\xe2\x80\xa8", "LS");
677  		SetRepresentation("\xe2\x80\xa9", "PS");
678  	}
679  	if (dbcsCodePage) {
680  		for (int k = 0x80; k < 0x100; k++) {
681  			if ((CpUtf8 == dbcsCodePage) || !IsDBCSValidSingleByte(dbcsCodePage, k)) {
682  				const char hiByte[2] = { static_cast<char>(k), 0 };
683  				char hexits[4];
684  				Hexits(hexits, k);
685  				SetRepresentation(hiByte, hexits);
686  			}
687  		}
688  	}
689  }
690  void BreakFinder::Insert(Sci::Position val) {
691  	const int posInLine = static_cast<int>(val);
692  	if (posInLine > nextBreak) {
693  		const std::vector<int>::iterator it = std::lower_bound(selAndEdge.begin(), selAndEdge.end(), posInLine);
694  		if (it == selAndEdge.end()) {
695  			selAndEdge.push_back(posInLine);
696  		} else if (*it != posInLine) {
697  			selAndEdge.insert(it, 1, posInLine);
698  		}
699  	}
700  }
701  BreakFinder::BreakFinder(const LineLayout *ll_, const Selection *psel, Range lineRange_, Sci::Position posLineStart,
702  	XYPOSITION xStart, BreakFor breakFor, const Document *pdoc_, const SpecialRepresentations *preprs_, const ViewStyle *pvsDraw) :
703  	ll(ll_),
704  	lineRange(lineRange_),
705  	nextBreak(static_cast<int>(lineRange_.start)),
706  	saeCurrentPos(0),
707  	saeNext(0),
708  	subBreak(-1),
709  	pdoc(pdoc_),
710  	encodingFamily(pdoc_->CodePageFamily()),
711  	preprs(preprs_) {
712  	if (xStart > 0.0f)
713  		nextBreak = ll->FindBefore(xStart, lineRange);
714  	while ((nextBreak > lineRange.start) && (ll->styles[nextBreak] == ll->styles[nextBreak - 1])) {
715  		nextBreak--;
716  	}
717  	if (FlagSet(breakFor, BreakFor::Selection)) {
718  		const SelectionPosition posStart(posLineStart);
719  		const SelectionPosition posEnd(posLineStart + lineRange.end);
720  		const SelectionSegment segmentLine(posStart, posEnd);
721  		for (size_t r=0; r<psel->Count(); r++) {
722  			const SelectionSegment portion = psel->Range(r).Intersect(segmentLine);
723  			if (!(portion.start == portion.end)) {
724  				if (portion.start.IsValid())
725  					Insert(portion.start.Position() - posLineStart);
726  				if (portion.end.IsValid())
727  					Insert(portion.end.Position() - posLineStart);
728  			}
729  		}
730  		if (FlagSet(pvsDraw->caret.style, CaretStyle::Curses) && !psel->RangeMain().Empty()) {
731  			const Sci::Position caretPos = psel->RangeMain().caret.Position();
732  			const Sci::Position anchorPos = psel->RangeMain().anchor.Position();
733  			if (caretPos < anchorPos) {
734  				const Sci::Position nextPos = pdoc->MovePositionOutsideChar(caretPos + 1, 1);
735  				Insert(nextPos - posLineStart);
736  			} else if (caretPos > anchorPos && pvsDraw->DrawCaretInsideSelection(false, false)) {
737  				const Sci::Position prevPos = pdoc->MovePositionOutsideChar(caretPos - 1, -1);
738  				if (prevPos > anchorPos)
739  					Insert(prevPos - posLineStart);
740  			}
741  		}
742  	}
743  	if (FlagSet(breakFor, BreakFor::Foreground) && pvsDraw->indicatorsSetFore) {
744  		for (const IDecoration *deco : pdoc->decorations->View()) {
745  			if (pvsDraw->indicators[deco->Indicator()].OverridesTextFore()) {
746  				Sci::Position startPos = deco->EndRun(posLineStart);
747  				while (startPos < (posLineStart + lineRange.end)) {
748  					Insert(startPos - posLineStart);
749  					startPos = deco->EndRun(startPos);
750  				}
751  			}
752  		}
753  	}
754  	Insert(ll->edgeColumn);
755  	Insert(lineRange.end);
756  	saeNext = (!selAndEdge.empty()) ? selAndEdge[0] : -1;
757  }
758  BreakFinder::~BreakFinder() noexcept = default;
759  TextSegment BreakFinder::Next() {
760  	if (subBreak < 0) {
761  		const int prev = nextBreak;
762  		const Representation *repr = nullptr;
763  		while (nextBreak < lineRange.end) {
764  			int charWidth = 1;
765  			const char * const chars = &ll->chars[nextBreak];
766  			const unsigned char ch = chars[0];
767  			bool characterStyleConsistent = true;	
768  			if (!UTF8IsAscii(ch) && encodingFamily != EncodingFamily::eightBit) {
769  				if (encodingFamily == EncodingFamily::unicode) {
770  					charWidth = UTF8DrawBytes(chars, lineRange.end - nextBreak);
771  				} else {
772  					charWidth = pdoc->DBCSDrawBytes(std::string_view(chars, lineRange.end - nextBreak));
773  				}
774  				for (int trail = 1; trail < charWidth; trail++) {
775  					if (ll->styles[nextBreak] != ll->styles[nextBreak + trail]) {
776  						characterStyleConsistent = false;
777  					}
778  				}
779  			}
780  			if (!characterStyleConsistent) {
781  				if (nextBreak == prev) {
782  					charWidth = 1;
783  				} else {
784  					break;
785  				}
786  			}
787  			repr = nullptr;
788  			if (preprs->MayContain(ch)) {
789  				if (ch == '\r' && preprs->ContainsCrLf() && chars[1] == '\n') {
790  					charWidth = 2;
791  				}
792  				repr = preprs->GetRepresentation(std::string_view(chars, charWidth));
793  			}
794  			if (((nextBreak > 0) && (ll->styles[nextBreak] != ll->styles[nextBreak - 1])) ||
795  					repr ||
796  					(nextBreak == saeNext)) {
797  				while ((nextBreak >= saeNext) && (saeNext < lineRange.end)) {
798  					saeCurrentPos++;
799  					saeNext = static_cast<int>((saeCurrentPos < selAndEdge.size()) ? selAndEdge[saeCurrentPos] : lineRange.end);
800  				}
801  				if ((nextBreak > prev) || repr) {
802  					if (nextBreak == prev) {
803  						nextBreak += charWidth;
804  					} else {
805  						repr = nullptr;	
806  					}
807  					break;
808  				}
809  			}
810  			nextBreak += charWidth;
811  		}
812  		const int lengthSegment = nextBreak - prev;
813  		if (lengthSegment < lengthStartSubdivision) {
814  			return TextSegment(prev, lengthSegment, repr);
815  		}
816  		subBreak = prev;
817  	}
818  	const int startSegment = subBreak;
819  	const int remaining = nextBreak - startSegment;
820  	int lengthSegment = remaining;
821  	if (lengthSegment > lengthEachSubdivision) {
822  		lengthSegment = static_cast<int>(pdoc->SafeSegment(std::string_view(&ll->chars[startSegment], lengthEachSubdivision)));
823  	}
824  	if (lengthSegment < remaining) {
825  		subBreak += lengthSegment;
826  	} else {
827  		subBreak = -1;
828  	}
829  	return TextSegment(startSegment, lengthSegment);
830  }
831  bool BreakFinder::More() const noexcept {
832  	return (subBreak >= 0) || (nextBreak < lineRange.end);
833  }
834  class PositionCacheEntry {
835  	uint16_t styleNumber;
836  	uint16_t len;
837  	uint16_t clock;
838  	bool unicode;
839  	std::unique_ptr<XYPOSITION[]> positions;
840  public:
841  	PositionCacheEntry() noexcept;
842  	PositionCacheEntry(const PositionCacheEntry &);
843  	PositionCacheEntry(PositionCacheEntry &&) noexcept = default;
844  	void operator=(const PositionCacheEntry &) = delete;
845  	void operator=(PositionCacheEntry &&) = delete;
846  	~PositionCacheEntry();
847  	void Set(unsigned int styleNumber_, bool unicode_, std::string_view sv, const XYPOSITION *positions_, uint16_t clock_);
848  	void Clear() noexcept;
849  	bool Retrieve(unsigned int styleNumber_, bool unicode_, std::string_view sv, XYPOSITION *positions_) const noexcept;
850  	static size_t Hash(unsigned int styleNumber_, bool unicode_, std::string_view sv) noexcept;
851  	bool NewerThan(const PositionCacheEntry &other) const noexcept;
852  	void ResetClock() noexcept;
853  };
854  class PositionCache : public IPositionCache {
855  	std::vector<PositionCacheEntry> pces;
856  	std::mutex mutex;
857  	uint16_t clock;
858  	bool allClear;
859  public:
860  	PositionCache();
861  	PositionCache(const PositionCache &) = delete;
862  	PositionCache(PositionCache &&) = delete;
863  	void operator=(const PositionCache &) = delete;
864  	void operator=(PositionCache &&) = delete;
865  	~PositionCache() override = default;
866  	void Clear() noexcept override;
867  	void SetSize(size_t size_) override;
868  	size_t GetSize() const noexcept override;
869  	void MeasureWidths(Surface *surface, const ViewStyle &vstyle, unsigned int styleNumber,
870  		bool unicode, std::string_view sv, XYPOSITION *positions, bool needsLocking) override;
871  };
872  PositionCacheEntry::PositionCacheEntry() noexcept :
873  	styleNumber(0), len(0), clock(0), unicode(false) {
874  }
875  PositionCacheEntry::PositionCacheEntry(const PositionCacheEntry &other) :
876  	styleNumber(other.styleNumber), len(other.len), clock(other.clock), unicode(other.unicode) {
877  	if (other.positions) {
878  		const size_t lenData = len + (len / sizeof(XYPOSITION)) + 1;
879  		positions = std::make_unique<XYPOSITION[]>(lenData);
880  		memcpy(positions.get(), other.positions.get(), lenData * sizeof(XYPOSITION));
881  	}
882  }
883  void PositionCacheEntry::Set(unsigned int styleNumber_, bool unicode_, std::string_view sv,
884  	const XYPOSITION *positions_, uint16_t clock_) {
885  	Clear();
886  	styleNumber = static_cast<uint16_t>(styleNumber_);
887  	len = static_cast<uint16_t>(sv.length());
888  	clock = clock_;
889  	unicode = unicode_;
890  	if (sv.data() && positions_) {
891  		positions = std::make_unique<XYPOSITION[]>(len + (len / sizeof(XYPOSITION)) + 1);
892  		for (unsigned int i=0; i<len; i++) {
893  			positions[i] = positions_[i];
894  		}
895  		memcpy(&positions[len], sv.data(), sv.length());
896  	}
897  }
898  PositionCacheEntry::~PositionCacheEntry() {
899  	Clear();
900  }
901  void PositionCacheEntry::Clear() noexcept {
902  	positions.reset();
903  	styleNumber = 0;
904  	len = 0;
905  	clock = 0;
906  }
907  bool PositionCacheEntry::Retrieve(unsigned int styleNumber_, bool unicode_, std::string_view sv, XYPOSITION *positions_) const noexcept {
908  	if ((styleNumber == styleNumber_) && (unicode == unicode_) && (len == sv.length()) &&
909  		(memcmp(&positions[len], sv.data(), sv.length())== 0)) {
910  		for (unsigned int i=0; i<len; i++) {
911  			positions_[i] = positions[i];
912  		}
913  		return true;
914  	} else {
915  		return false;
916  	}
917  }
918  size_t PositionCacheEntry::Hash(unsigned int styleNumber_, bool unicode_, std::string_view sv) noexcept {
919  	const size_t h1 = std::hash<std::string_view>{}(sv);
920  	const size_t h2 = std::hash<unsigned int>{}(styleNumber_);
921  	return h1 ^ (h2 << 1) ^ static_cast<size_t>(unicode_);
922  }
923  bool PositionCacheEntry::NewerThan(const PositionCacheEntry &other) const noexcept {
924  	return clock > other.clock;
925  }
926  void PositionCacheEntry::ResetClock() noexcept {
927  	if (clock > 0) {
928  		clock = 1;
929  	}
930  }
931  PositionCache::PositionCache() {
932  	clock = 1;
933  	pces.resize(0x400);
934  	allClear = true;
935  }
936  void PositionCache::Clear() noexcept {
937  	if (!allClear) {
938  		for (PositionCacheEntry &pce : pces) {
939  			pce.Clear();
940  		}
941  	}
942  	clock = 1;
943  	allClear = true;
944  }
945  void PositionCache::SetSize(size_t size_) {
946  	Clear();
947  	pces.resize(size_);
948  }
949  size_t PositionCache::GetSize() const noexcept {
950  	return pces.size();
951  }
952  void PositionCache::MeasureWidths(Surface *surface, const ViewStyle &vstyle, unsigned int styleNumber,
953  	bool unicode, std::string_view sv, XYPOSITION *positions, bool needsLocking) {
954  	const Style &style = vstyle.styles[styleNumber];
955  	if (style.monospaceASCII) {
956  		if (AllGraphicASCII(sv)) {
957  			const XYPOSITION monospaceCharacterWidth = style.monospaceCharacterWidth;
958  			for (size_t i = 0; i < sv.length(); i++) {
959  				positions[i] = monospaceCharacterWidth * (i+1);
960  			}
961  			return;
962  		}
963  	}
964  	size_t probe = pces.size();	
965  	if ((!pces.empty()) && (sv.length() < 30)) {
966  		const size_t hashValue = PositionCacheEntry::Hash(styleNumber, unicode, sv);
967  		probe = hashValue % pces.size();
968  		std::unique_lock<std::mutex> guard(mutex, std::defer_lock);
969  		if (needsLocking) {
970  			guard.lock();
971  		}
972  		if (pces[probe].Retrieve(styleNumber, unicode, sv, positions)) {
973  			return;
974  		}
975  		const size_t probe2 = (hashValue * 37) % pces.size();
976  		if (pces[probe2].Retrieve(styleNumber, unicode, sv, positions)) {
977  			return;
978  		}
979  		if (pces[probe].NewerThan(pces[probe2])) {
980  			probe = probe2;
981  		}
982  	}
983  	const Font *fontStyle = style.font.get();
984  	if (unicode) {
985  		surface->MeasureWidthsUTF8(fontStyle, sv, positions);
986  	} else {
987  		surface->MeasureWidths(fontStyle, sv, positions);
988  	}
989  	if (probe < pces.size()) {
990  		std::unique_lock<std::mutex> guard(mutex, std::defer_lock);
991  		if (needsLocking) {
992  			guard.lock();
993  		}
994  		clock++;
995  		if (clock > 60000) {
996  			for (PositionCacheEntry &pce : pces) {
997  				pce.ResetClock();
998  			}
999  			clock = 2;
1000  		}
1001  		allClear = false;
1002  		pces[probe].Set(styleNumber, unicode, sv, positions, clock);
1003  	}
1004  }
1005  std::unique_ptr<IPositionCache> Scintilla::Internal::CreatePositionCache() {
1006  	return std::make_unique<PositionCache>();
1007  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-PositionCache.cxx</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-PositionCache.cxx</div>
                </div>
                <div class="column column_space"><pre><code>502  	size_t pos = 0;
503  	if (level == LineCache::Page) {
504  		if (!(cache[0] && (cache[0]->LineNumber() == lineNumber))) {
</pre></code></div>
                <div class="column column_space"><pre><code>430  	size_t lengthForLevel = 0;
431  	if (level == LineCache::Caret) {
432  		lengthForLevel = 1;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    