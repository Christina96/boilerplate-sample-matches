
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 5.6567957479119215%, Tokens: 11</h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-linefind.cpp</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #  include "config_auto.h"
3  #endif
4  #include "alignedblob.h"
5  #include "blobbox.h"
6  #include "crakedge.h" 
7  #include "edgblob.h"
8  #include "linefind.h"
9  #include "tabvector.h"
10  #if defined(USE_OPENCL)
11  #  include "openclwrapper.h" 
12  #endif
13  #include <algorithm>
14  namespace tesseract {
15  const int kThinLineFraction = 20;
16  const int kMinLineLengthFraction = 4;
17  const int kCrackSpacing = 100;
18  const int kLineFindGridSize = 50;
19  const int kMinThickLineWidth = 12;
20  const int kMaxLineResidue = 6;
21  const double kThickLengthMultiple = 0.75;
22  const double kMaxNonLineDensity = 0.25;
23  const double kMaxStaveHeight = 1.0;
24  const double kMinMusicPixelFraction = 0.75;
25  static void RemoveUnusedLineSegments(bool horizontal_lines, BLOBNBOX_LIST *line_bblobs,
26                                       Image line_pix) {
27    int height = pixGetHeight(line_pix);
28    BLOBNBOX_IT bbox_it(line_bblobs);
29    for (bbox_it.mark_cycle_pt(); !bbox_it.cycled_list(); bbox_it.forward()) {
30      BLOBNBOX *blob = bbox_it.data();
31      if (blob->left_tab_type() != TT_VLINE) {
32        const TBOX &box = blob->bounding_box();
33        Box *pixbox = nullptr;
34        if (horizontal_lines) {
35          pixbox = boxCreate(box.bottom(), height - box.right(), box.height(), box.width());
36        } else {
37          pixbox = boxCreate(box.left(), height - box.top(), box.width(), box.height());
38        }
39        pixClearInRect(line_pix, pixbox);
40        boxDestroy(&pixbox);
41      }
42    }
43  }
44  static void SubtractLinesAndResidue(Image line_pix, Image non_line_pix,
45                                      Image src_pix) {
46    pixSubtract(src_pix, src_pix, line_pix);
47    Image residue_pix = pixSubtract(nullptr, src_pix, non_line_pix);
48    Image fat_line_pix = pixDilateBrick(nullptr, line_pix, 3, 3);
49    pixSeedfillBinary(fat_line_pix, fat_line_pix, residue_pix, 8);
50    pixSubtract(src_pix, src_pix, fat_line_pix);
51    fat_line_pix.destroy();
52    residue_pix.destroy();
53  }
54  static int MaxStrokeWidth(Image pix) {
55    Image dist_pix = pixDistanceFunction(pix, 4, 8, L_BOUNDARY_BG);
56    int width = pixGetWidth(dist_pix);
57    int height = pixGetHeight(dist_pix);
58    int wpl = pixGetWpl(dist_pix);
59    l_uint32 *data = pixGetData(dist_pix);
60    int max_dist = 0;
61    for (int y = 0; y < height; ++y) {
62      for (int x = 0; x < width; ++x) {
63        int pixel = GET_DATA_BYTE(data, x);
64        if (pixel > max_dist) {
65          max_dist = pixel;
66        }
67      }
68      data += wpl;
69    }
70    dist_pix.destroy();
71    return max_dist * 2;
72  }
73  static int NumTouchingIntersections(Box *line_box, Image intersection_pix) {
74    if (intersection_pix == nullptr) {
75      return 0;
76    }
77    Image rect_pix = pixClipRectangle(intersection_pix, line_box, nullptr);
78    Boxa *boxa = pixConnComp(rect_pix, nullptr, 8);
79    rect_pix.destroy();
80    if (boxa == nullptr) {
81      return false;
82    }
83    int result = boxaGetCount(boxa);
84    boxaDestroy(&boxa);
85    return result;
86  }
87  static int CountPixelsAdjacentToLine(int line_width, Box *line_box, Image nonline_pix) {
88    l_int32 x, y, box_width, box_height;
89    boxGetGeometry(line_box, &x, &y, &box_width, &box_height);
90    if (box_width > box_height) {
91      int bottom = std::min(pixGetHeight(nonline_pix), y + box_height + line_width);
92      y = std::max(0, y - line_width);
93      box_height = bottom - y;
94    } else {
95      int right = std::min(pixGetWidth(nonline_pix), x + box_width + line_width);
96      x = std::max(0, x - line_width);
97      box_width = right - x;
98    }
99    Box *box = boxCreate(x, y, box_width, box_height);
100    Image rect_pix = pixClipRectangle(nonline_pix, box, nullptr);
101    boxDestroy(&box);
102    l_int32 result;
103    pixCountPixels(rect_pix, &result, nullptr);
104    rect_pix.destroy();
105    return result;
106  }
107  static int FilterFalsePositives(int resolution, Image nonline_pix, Image intersection_pix,
108                                  Image line_pix) {
109    int min_thick_length = static_cast<int>(resolution * kThickLengthMultiple);
110    Pixa *pixa = nullptr;
111    Boxa *boxa = pixConnComp(line_pix, &pixa, 8);
112    int nboxes = boxaGetCount(boxa);
113    int remaining_boxes = nboxes;
114    for (int i = 0; i < nboxes; ++i) {
115      Box *box = boxaGetBox(boxa, i, L_CLONE);
116      l_int32 x, y, box_width, box_height;
117      boxGetGeometry(box, &x, &y, &box_width, &box_height);
118      Image comp_pix = pixaGetPix(pixa, i, L_CLONE);
119      int max_width = MaxStrokeWidth(comp_pix);
120      comp_pix.destroy();
121      bool bad_line = false;
122      if (box_width >= kMinThickLineWidth && box_height >= kMinThickLineWidth &&
123          box_width < min_thick_length && box_height < min_thick_length &&
124          max_width > kMinThickLineWidth) {
125        bad_line = true;
126      }
127      if (!bad_line && (NumTouchingIntersections(box, intersection_pix) < 2)) {
128        int nonline_count = CountPixelsAdjacentToLine(max_width, box, nonline_pix);
129        if (nonline_count > box_height * box_width * kMaxNonLineDensity) {
130          bad_line = true;
131        }
132      }
133      if (bad_line) {
134        pixClearInRect(line_pix, box);
135        --remaining_boxes;
136      }
137      boxDestroy(&box);
138    }
139    pixaDestroy(&pixa);
140    boxaDestroy(&boxa);
141    return remaining_boxes;
142  }
143  static void ConvertBoxaToBlobs(int image_width, int image_height, Boxa **boxes,
144                                 C_BLOB_LIST *blobs) {
145    C_OUTLINE_LIST outlines;
146    C_OUTLINE_IT ol_it = &outlines;
147    int nboxes = boxaGetCount(*boxes);
148    for (int i = 0; i < nboxes; ++i) {
149      l_int32 x, y, width, height;
150      boxaGetBoxGeometry(*boxes, i, &x, &y, &width, &height);
151      ICOORD top_left(x, y);
152      ICOORD bot_right(x + width, y + height);
153      CRACKEDGE startpt;
154      startpt.pos = top_left;
155      auto *outline = new C_OUTLINE(&startpt, top_left, bot_right, 0);
156      ol_it.add_after_then_move(outline);
157    }
158    BLOCK block;
159    ICOORD page_tl(0, 0);
160    ICOORD page_br(image_width, image_height);
161    outlines_to_blobs(&block, page_tl, page_br, &outlines);
162    C_BLOB_IT blob_it(blobs);
163    blob_it.add_list_after(block.blob_list());
164    boxaDestroy(boxes);
165  }
166  static void GetLineBoxes(bool horizontal_lines, Image pix_lines, Image pix_intersections,
167                           C_BLOB_LIST *line_cblobs, BLOBNBOX_LIST *line_bblobs) {
168    int wpl = pixGetWpl(pix_lines);
169    int width = pixGetWidth(pix_lines);
170    int height = pixGetHeight(pix_lines);
171    l_uint32 *data = pixGetData(pix_lines);
172    if (horizontal_lines) {
<span onclick='openModal()' class='match'>173      for (int y = 0; y < height; ++y, data += wpl) {
174        for (int x = kCrackSpacing; x < width; x += kCrackSpacing) {
175          CLEAR_DATA_BIT(data, x);
176        }
177      }
178    } else {
</span>179      for (int y = kCrackSpacing; y < height; y += kCrackSpacing) {
180        memset(data + wpl * y, 0, wpl * sizeof(*data));
181      }
182    }
183    Boxa *boxa = pixConnComp(pix_lines, nullptr, 8);
184    ConvertBoxaToBlobs(width, height, &boxa, line_cblobs);
185    C_BLOB_IT blob_it(line_cblobs);
186    BLOBNBOX_IT bbox_it(line_bblobs);
187    for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
188      C_BLOB *cblob = blob_it.data();
189      auto *bblob = new BLOBNBOX(cblob);
190      bbox_it.add_to_end(bblob);
191      const TBOX &bbox = bblob->bounding_box();
192      Box *box = boxCreate(bbox.left(), bbox.bottom(), bbox.width(), bbox.height());
193      bblob->set_line_crossings(NumTouchingIntersections(box, pix_intersections));
194      boxDestroy(&box);
195      if (horizontal_lines) {
196        TBOX new_box(height - bbox.top(), bbox.left(), height - bbox.bottom(), bbox.right());
197        bblob->set_bounding_box(new_box);
198      } else {
199        TBOX new_box(bbox.left(), height - bbox.top(), bbox.right(), height - bbox.bottom());
200        bblob->set_bounding_box(new_box);
201      }
202    }
203  }
204  static void FindLineVectors(const ICOORD &bleft, const ICOORD &tright,
205                              BLOBNBOX_LIST *line_bblobs, int *vertical_x, int *vertical_y,
206                              TabVector_LIST *vectors) {
207    BLOBNBOX_IT bbox_it(line_bblobs);
208    int b_count = 0;
209    AlignedBlob blob_grid(kLineFindGridSize, bleft, tright);
210    for (bbox_it.mark_cycle_pt(); !bbox_it.cycled_list(); bbox_it.forward()) {
211      BLOBNBOX *bblob = bbox_it.data();
212      bblob->set_left_tab_type(TT_MAYBE_ALIGNED);
213      bblob->set_left_rule(bleft.x());
214      bblob->set_right_rule(tright.x());
215      bblob->set_left_crossing_rule(bleft.x());
216      bblob->set_right_crossing_rule(tright.x());
217      blob_grid.InsertBBox(false, true, bblob);
218      ++b_count;
219    }
220    if (b_count == 0) {
221      return;
222    }
223    BlobGridSearch lsearch(&blob_grid);
224    BLOBNBOX *bbox;
225    TabVector_IT vector_it(vectors);
226    *vertical_x = 0;
227    *vertical_y = 1;
228    lsearch.StartFullSearch();
229    while ((bbox = lsearch.NextFullSearch()) != nullptr) {
230      if (bbox->left_tab_type() == TT_MAYBE_ALIGNED) {
231        const TBOX &box = bbox->bounding_box();
232        if (AlignedBlob::WithinTestRegion(2, box.left(), box.bottom())) {
233          tprintf("Finding line vector starting at bbox (%d,%d)\n", box.left(), box.bottom());
234        }
235        AlignedBlobParams align_params(*vertical_x, *vertical_y, box.width());
236        TabVector *vector =
237            blob_grid.FindVerticalAlignment(align_params, bbox, vertical_x, vertical_y);
238        if (vector != nullptr) {
239          vector->Freeze();
240          vector_it.add_to_end(vector);
241        }
242      }
243    }
244  }
245  static Image FilterMusic(int resolution, Image pix_closed, Image pix_vline, Image pix_hline,
246                          bool &v_empty, bool &h_empty) {
247    int max_stave_height = static_cast<int>(resolution * kMaxStaveHeight);
248    Image intersection_pix = pix_vline & pix_hline;
249    Boxa *boxa = pixConnComp(pix_vline, nullptr, 8);
250    int nboxes = boxaGetCount(boxa);
251    Image music_mask = nullptr;
252    for (int i = 0; i < nboxes; ++i) {
253      Box *box = boxaGetBox(boxa, i, L_CLONE);
254      l_int32 x, y, box_width, box_height;
255      boxGetGeometry(box, &x, &y, &box_width, &box_height);
256      int joins = NumTouchingIntersections(box, intersection_pix);
257      if (joins >= 5 && (joins - 1) * max_stave_height >= 4 * box_height) {
258        if (music_mask == nullptr) {
259          music_mask = pixCreate(pixGetWidth(pix_vline), pixGetHeight(pix_vline), 1);
260        }
261        pixSetInRect(music_mask, box);
262      }
263      boxDestroy(&box);
264    }
265    boxaDestroy(&boxa);
266    intersection_pix.destroy();
267    if (music_mask != nullptr) {
268      pixSeedfillBinary(music_mask, music_mask, pix_closed, 8);
269      Boxa *boxa = pixConnComp(music_mask, nullptr, 8);
270      int nboxes = boxaGetCount(boxa);
271      for (int i = 0; i < nboxes; ++i) {
272        Box *box = boxaGetBox(boxa, i, L_CLONE);
273        Image rect_pix = pixClipRectangle(music_mask, box, nullptr);
274        l_int32 music_pixels;
275        pixCountPixels(rect_pix, &music_pixels, nullptr);
276        rect_pix.destroy();
277        rect_pix = pixClipRectangle(pix_closed, box, nullptr);
278        l_int32 all_pixels;
279        pixCountPixels(rect_pix, &all_pixels, nullptr);
280        rect_pix.destroy();
281        if (music_pixels < kMinMusicPixelFraction * all_pixels) {
282          pixClearInRect(music_mask, box);
283        }
284        boxDestroy(&box);
285      }
286      boxaDestroy(&boxa);
287      if (music_mask.isZero()) {
288        music_mask.destroy();
289      } else {
290        pixSubtract(pix_vline, pix_vline, music_mask);
291        pixSubtract(pix_hline, pix_hline, music_mask);
292        v_empty = pix_vline.isZero();
293        h_empty = pix_hline.isZero();
294      }
295    }
296    return music_mask;
297  }
298  static void GetLineMasks(int resolution, Image src_pix, Image *pix_vline, Image *pix_non_vline,
299                           Image *pix_hline, Image *pix_non_hline, Image *pix_intersections,
300                           Image *pix_music_mask, Pixa *pixa_display) {
301    Image pix_closed = nullptr;
302    Image pix_hollow = nullptr;
303    int max_line_width = resolution / kThinLineFraction;
304    int min_line_length = resolution / kMinLineLengthFraction;
305    if (pixa_display != nullptr) {
306      tprintf("Image resolution = %d, max line width = %d, min length=%d\n", resolution,
307              max_line_width, min_line_length);
308    }
309    int closing_brick = max_line_width / 3;
310  #ifdef USE_OPENCL
311    if (OpenclDevice::selectedDeviceIsOpenCL()) {
312      int clStatus =
313          OpenclDevice::initMorphCLAllocations(pixGetWpl(src_pix), pixGetHeight(src_pix), src_pix);
314      bool getpixclosed = pix_music_mask != nullptr;
315      OpenclDevice::pixGetLinesCL(nullptr, src_pix, pix_vline, pix_hline, &pix_closed, getpixclosed,
316                                  closing_brick, closing_brick, max_line_width, max_line_width,
317                                  min_line_length, min_line_length);
318    } else {
319  #endif
320      pix_closed = pixCloseBrick(nullptr, src_pix, closing_brick, closing_brick);
321      if (pixa_display != nullptr) {
322        pixaAddPix(pixa_display, pix_closed, L_CLONE);
323      }
324      Image pix_solid = pixOpenBrick(nullptr, pix_closed, max_line_width, max_line_width);
325      if (pixa_display != nullptr) {
326        pixaAddPix(pixa_display, pix_solid, L_CLONE);
327      }
328      pix_hollow = pixSubtract(nullptr, pix_closed, pix_solid);
329      pix_solid.destroy();
330      if (pixa_display != nullptr) {
331        pixaAddPix(pixa_display, pix_hollow, L_CLONE);
332      }
333      *pix_vline = pixOpenBrick(nullptr, pix_hollow, 1, min_line_length);
334      *pix_hline = pixOpenBrick(nullptr, pix_hollow, min_line_length, 1);
335      pix_hollow.destroy();
336  #ifdef USE_OPENCL
337    }
338  #endif
339    bool v_empty = pix_vline->isZero();
340    bool h_empty = pix_hline->isZero();
341    if (pix_music_mask != nullptr) {
342      if (!v_empty && !h_empty) {
343        *pix_music_mask =
344            FilterMusic(resolution, pix_closed, *pix_vline, *pix_hline, v_empty, h_empty);
345      } else {
346        *pix_music_mask = nullptr;
347      }
348    }
349    pix_closed.destroy();
350    Image pix_nonlines = nullptr;
351    *pix_intersections = nullptr;
352    Image extra_non_hlines = nullptr;
353    if (!v_empty) {
354      pix_nonlines = pixSubtract(nullptr, src_pix, *pix_vline);
355      if (!h_empty) {
356        pixSubtract(pix_nonlines, pix_nonlines, *pix_hline);
357        *pix_intersections = *pix_vline & *pix_hline;
358        extra_non_hlines = pixSubtract(nullptr, *pix_vline, *pix_intersections);
359      }
360      *pix_non_vline = pixErodeBrick(nullptr, pix_nonlines, kMaxLineResidue, 1);
361      pixSeedfillBinary(*pix_non_vline, *pix_non_vline, pix_nonlines, 8);
362      if (!h_empty) {
363        *pix_non_vline |= *pix_hline;
364        pixSubtract(*pix_non_vline, *pix_non_vline, *pix_intersections);
365      }
366      if (!FilterFalsePositives(resolution, *pix_non_vline, *pix_intersections, *pix_vline)) {
367        pix_vline->destroy(); 
368      }
369    } else {
370      pix_vline->destroy();
371      *pix_non_vline = nullptr;
372      if (!h_empty) {
373        pix_nonlines = pixSubtract(nullptr, src_pix, *pix_hline);
374      }
375    }
376    if (h_empty) {
377      pix_hline->destroy();
378      *pix_non_hline = nullptr;
379      if (v_empty) {
380        return;
381      }
382    } else {
383      *pix_non_hline = pixErodeBrick(nullptr, pix_nonlines, 1, kMaxLineResidue);
384      pixSeedfillBinary(*pix_non_hline, *pix_non_hline, pix_nonlines, 8);
385      if (extra_non_hlines != nullptr) {
386        *pix_non_hline |= extra_non_hlines;
387        extra_non_hlines.destroy();
388      }
389      if (!FilterFalsePositives(resolution, *pix_non_hline, *pix_intersections, *pix_hline)) {
390        pix_hline->destroy(); 
391      }
392    }
393    if (pixa_display != nullptr) {
394      if (*pix_vline != nullptr) {
395        pixaAddPix(pixa_display, *pix_vline, L_CLONE);
396      }
397      if (*pix_hline != nullptr) {
398        pixaAddPix(pixa_display, *pix_hline, L_CLONE);
399      }
400      if (pix_nonlines != nullptr) {
401        pixaAddPix(pixa_display, pix_nonlines, L_CLONE);
402      }
403      if (*pix_non_vline != nullptr) {
404        pixaAddPix(pixa_display, *pix_non_vline, L_CLONE);
405      }
406      if (*pix_non_hline != nullptr) {
407        pixaAddPix(pixa_display, *pix_non_hline, L_CLONE);
408      }
409      if (*pix_intersections != nullptr) {
410        pixaAddPix(pixa_display, *pix_intersections, L_CLONE);
411      }
412      if (pix_music_mask != nullptr && *pix_music_mask != nullptr) {
413        pixaAddPix(pixa_display, *pix_music_mask, L_CLONE);
414      }
415    }
416    pix_nonlines.destroy();
417  }
418  static void FindAndRemoveVLines(Image pix_intersections, int *vertical_x,
419                                  int *vertical_y, Image *pix_vline, Image pix_non_vline,
420                                  Image src_pix, TabVector_LIST *vectors) {
421    if (pix_vline == nullptr || *pix_vline == nullptr) {
422      return;
423    }
424    C_BLOB_LIST line_cblobs;
425    BLOBNBOX_LIST line_bblobs;
426    GetLineBoxes(false, *pix_vline, pix_intersections, &line_cblobs, &line_bblobs);
427    int width = pixGetWidth(src_pix);
428    int height = pixGetHeight(src_pix);
429    ICOORD bleft(0, 0);
430    ICOORD tright(width, height);
431    FindLineVectors(bleft, tright, &line_bblobs, vertical_x, vertical_y, vectors);
432    if (!vectors->empty()) {
433      RemoveUnusedLineSegments(false, &line_bblobs, *pix_vline);
434      SubtractLinesAndResidue(*pix_vline, pix_non_vline, src_pix);
435      ICOORD vertical;
436      vertical.set_with_shrink(*vertical_x, *vertical_y);
437      TabVector::MergeSimilarTabVectors(vertical, vectors, nullptr);
438    } else {
439      pix_vline->destroy();
440    }
441  }
442  static void FindAndRemoveHLines(Image pix_intersections, int vertical_x,
443                                  int vertical_y, Image *pix_hline, Image pix_non_hline,
444                                  Image src_pix, TabVector_LIST *vectors) {
445    if (pix_hline == nullptr || *pix_hline == nullptr) {
446      return;
447    }
448    C_BLOB_LIST line_cblobs;
449    BLOBNBOX_LIST line_bblobs;
450    GetLineBoxes(true, *pix_hline, pix_intersections, &line_cblobs, &line_bblobs);
451    int width = pixGetWidth(src_pix);
452    int height = pixGetHeight(src_pix);
453    ICOORD bleft(0, 0);
454    ICOORD tright(height, width);
455    FindLineVectors(bleft, tright, &line_bblobs, &vertical_x, &vertical_y, vectors);
456    if (!vectors->empty()) {
457      RemoveUnusedLineSegments(true, &line_bblobs, *pix_hline);
458      SubtractLinesAndResidue(*pix_hline, pix_non_hline, src_pix);
459      ICOORD vertical;
460      vertical.set_with_shrink(vertical_x, vertical_y);
461      TabVector::MergeSimilarTabVectors(vertical, vectors, nullptr);
462      TabVector_IT h_it(vectors);
463      for (h_it.mark_cycle_pt(); !h_it.cycled_list(); h_it.forward()) {
464        h_it.data()->XYFlip();
465      }
466    } else {
467      pix_hline->destroy();
468    }
469  }
470  void LineFinder::FindAndRemoveLines(int resolution, bool debug, Image pix, int *vertical_x,
471                                      int *vertical_y, Image *pix_music_mask, TabVector_LIST *v_lines,
472                                      TabVector_LIST *h_lines) {
473    if (pix == nullptr || vertical_x == nullptr || vertical_y == nullptr) {
474      tprintf("Error in parameters for LineFinder::FindAndRemoveLines\n");
475      return;
476    }
477    Image pix_vline = nullptr;
478    Image pix_non_vline = nullptr;
479    Image pix_hline = nullptr;
480    Image pix_non_hline = nullptr;
481    Image pix_intersections = nullptr;
482    Pixa *pixa_display = debug ? pixaCreate(0) : nullptr;
483    GetLineMasks(resolution, pix, &pix_vline, &pix_non_vline, &pix_hline, &pix_non_hline,
484                 &pix_intersections, pix_music_mask, pixa_display);
485    FindAndRemoveVLines(pix_intersections, vertical_x, vertical_y, &pix_vline,
486                        pix_non_vline, pix, v_lines);
487    pix_intersections.destroy();
488    if (pix_hline != nullptr) {
489      if (pix_vline != nullptr) {
490        pix_intersections = pix_vline & pix_hline;
491      }
492      if (!FilterFalsePositives(resolution, pix_non_hline, pix_intersections, pix_hline)) {
493        pix_hline.destroy();
494      }
495    }
496    FindAndRemoveHLines(pix_intersections, *vertical_x, *vertical_y, &pix_hline,
497                        pix_non_hline, pix, h_lines);
498    if (pixa_display != nullptr && pix_vline != nullptr) {
499      pixaAddPix(pixa_display, pix_vline, L_CLONE);
500    }
501    if (pixa_display != nullptr && pix_hline != nullptr) {
502      pixaAddPix(pixa_display, pix_hline, L_CLONE);
503    }
504    pix_intersections.destroy();
505    if (pix_vline != nullptr && pix_hline != nullptr) {
506      pix_intersections = pix_vline & pix_hline;
507      Image pix_join_residue = pixDilateBrick(nullptr, pix_intersections, 5, 5);
508      pixSeedfillBinary(pix_join_residue, pix_join_residue, pix, 8);
509      pixSubtract(pix, pix, pix_join_residue);
510      pix_join_residue.destroy();
511    }
512    if (pix_music_mask != nullptr && *pix_music_mask != nullptr) {
513      if (pixa_display != nullptr) {
514        pixaAddPix(pixa_display, *pix_music_mask, L_CLONE);
515      }
516      pixSubtract(pix, pix, *pix_music_mask);
517    }
518    if (pixa_display != nullptr) {
519      pixaAddPix(pixa_display, pix, L_CLONE);
520    }
521    pix_vline.destroy();
522    pix_non_vline.destroy();
523    pix_hline.destroy();
524    pix_non_hline.destroy();
525    pix_intersections.destroy();
526    if (pixa_display != nullptr) {
527      pixaConvertToPdf(pixa_display, resolution, 1.0f, 0, 0, "LineFinding", "vhlinefinding.pdf");
528      pixaDestroy(&pixa_display);
529    }
530  }
531  } 
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-memes.cpp</h3>
            <pre><code>1  #include "stdafx.h"
2  #include "memes.h"
3  int TQuote::GetFq() const {
4    int fq=0;
5    for(int i=0; i<TmUrlCntV.Len(); i++) {
6      fq+=TmUrlCntV[i].Cnt(); }
7    return fq;
8  }
9  int TQuote::GetFq(const TSecTm& BegTm, const TSecTm& EndTm) const {
10    int fq=0;
11    for(int i=0; i<TmUrlCntV.Len(); i++) {
12      if (TmUrlCntV[i].Tm() >= BegTm && TmUrlCntV[i].Tm() < EndTm) {
13        fq += TmUrlCntV[i].Cnt(); } 
14    }
15    return fq;
16  }
17  int TQuote::GetDoms(const TQuoteBs& QtBs) const {
18    THashSet<TChA> DomSet;
19    for (int u = 0; u < TmUrlCntV.Len(); u++) {
20      DomSet.AddKey(TStrUtil::GetDomNm(QtBs.GetStr(TmUrlCntV[u].UrlId())));
21    }
22    return DomSet.Len();
23  }
24  int TQuote::GetFq(const TUrlTy& UrlTy, const TQuoteBs& QtBs) const {
25    int fq=0;
26    for(int i=0; i<TmUrlCntV.Len(); i++) {
27      if (UrlTy==utUndef || QtBs.GetUrlTy(TmUrlCntV[i].UrlId())==UrlTy) {
28        fq += TmUrlCntV[i].Cnt(); } 
29    }
30    return fq;
31  }
32  int TQuote::GetFq(const TSecTm& BegTm, const TSecTm& EndTm, const TUrlTy& UrlTy, const TQuoteBs& QtBs) const {
33    int fq=0;
34    for(int i=0; i<TmUrlCntV.Len(); i++) {
35      if (TmUrlCntV[i].Tm() >= BegTm && TmUrlCntV[i].Tm() <= EndTm &&
36       (UrlTy==utUndef || QtBs.GetUrlTy(TmUrlCntV[i].UrlId())==UrlTy)) {
37        fq+=1; }
38    }
39    return fq;
40  }
41  int TQuote::GetUrls(const TSecTm& BegTm, const TSecTm& EndTm, const TUrlTy& UrlTy, const TQuoteBs& QtBs) const {
42    int urls=0;
43    for(int i=0; i<TmUrlCntV.Len(); i++) {
44      if (TmUrlCntV[i].Tm() >= BegTm && TmUrlCntV[i].Tm() < EndTm &&
45       (UrlTy==utUndef || QtBs.GetUrlTy(TmUrlCntV[i].UrlId())==UrlTy)) {
46        urls+=1; }
47    }
48    return urls;
49  }
50  TSecTm TQuote::GetPeakTm(const TTmUnit& TmUnit, const TSecTm& AfterTm) const {
51    TInt FreqAtPeak;
52    return GetPeakTm(TmUnit, AfterTm, FreqAtPeak);
53  }
54  TSecTm TQuote::GetPeakTm(const TTmUnit& TmUnit, const TSecTm& AfterTm, TInt& FreqAtPeak) const {
55    const TSecTm After = AfterTm.Round(TmUnit);
56    THash<TSecTm, TInt> TmFqH;
57    for(int i=0; i<TmUrlCntV.Len(); i++) {
58      if (TmUrlCntV[i].Tm().Round(TmUnit) >= After) {
59        TmFqH.AddDat(TmUrlCntV[i].Tm().Round(TmUnit)) += TmUrlCntV[i].Cnt(); }
60    }
61    if (TmFqH.Empty()) {
62      FreqAtPeak = 0;
63      return GetPeakTm(TmUnit, TSecTm(1));
64    }
65    TmFqH.SortByDat(false);
66    FreqAtPeak = TmFqH[0];
67    return TmFqH.GetKey(0);
68  }
69  TSecTm TQuote::GetPeakTm(const TTmUnit& TmUnit, const TSecTm& AfterTm, const TUrlTy& UrlTy, const TQuoteBs& QtBs) const {
70    const TSecTm After = AfterTm.Round(TmUnit);
71    THash<TSecTm, TInt> TmFqH;
72    for(int i=0; i<TmUrlCntV.Len(); i++) {
73      if (TmUrlCntV[i].Tm().Round(TmUnit) >= After && (UrlTy==utUndef || QtBs.GetUrlTy(TmUrlCntV[i].UrlId())==UrlTy)) {
74        TmFqH.AddDat(TmUrlCntV[i].Tm().Round(TmUnit)) += TmUrlCntV[i].Cnt(); } 
75    }
76    if (TmFqH.Empty()) {
77      return GetPeakTm(TmUnit, TSecTm(1)); }
78    TmFqH.SortByDat(false);
79    return TmFqH.GetKey(0);
80  }
81  TSecTm TQuote::GetMeanTm(const TTmUnit& TmUnit, const TUrlTy& UrlTy, const TQuoteBs& QtBs, const TSecTm& AfterTm) const {
82    const TSecTm After = AfterTm.Round(TmUnit);
83    double MeanTm = 0;
84    int Cnt = 0;
85    for(int i=0; i<TmUrlCntV.Len(); i++) {
86      if (TmUrlCntV[i].Tm().Round(TmUnit) >= After && (UrlTy==utUndef || QtBs.GetUrlTy(TmUrlCntV[i].UrlId())==UrlTy)) {
87        MeanTm += TmUrlCntV[i].Tm().Round(TmUnit) * TmUrlCntV[i].Cnt();
88        Cnt += TmUrlCntV[i].Cnt();
89      }
90    }
91    return TSecTm(uint(MeanTm/double(Cnt))).Round(TmUnit);
92  }
93  TSecTm TQuote::GetMedianTm(const TTmUnit& TmUnit, const TUrlTy& UrlTy, const TQuoteBs& QtBs, const TSecTm& AfterTm) const {
94    const TSecTm After = AfterTm.Round(TmUnit);
95    TMom Mom;
96    for(int i=0; i<TmUrlCntV.Len(); i++) {
97      if (TmUrlCntV[i].Tm().Round(TmUnit) >= After && (UrlTy==utUndef || QtBs.GetUrlTy(TmUrlCntV[i].UrlId())==UrlTy)) {
98        Mom.Add(TmUrlCntV[i].Tm().Round(TmUnit).GetAbsSecs(), TmUrlCntV[i].Cnt());
99      }
100    }
101    Mom.Def();
102    return TSecTm(uint(Mom.GetMedian())).Round(TmUnit);
103  }
104  bool TQuote::IsSinglePeak(const TTmUnit& TmUnit, const TSecTm& AfterTm, const TUrlTy& UrlTy, const TQuoteBs& QtBs) const {
105    const double PeakThresh = 0.4;
106    TTmFltPrV FqOtV, SmoothV;
107    GetFqOt(FqOtV, TmUnit, UrlTy, QtBs);
108    TQuote::GetSmoothFqOt(SmoothV, FqOtV, TmUnit, 48, 1.2, AfterTm); 
109    SmoothV.Swap(FqOtV);
110    double MaxVal=0;
111    int maxI=0, maxL=0, maxR=0;
112    for (int i = 0; i < FqOtV.Len(); i++) {
113      if (MaxVal < FqOtV[i].Val2) {
114        MaxVal = FqOtV[i].Val2;  maxI=i; }
115    }
116    MaxVal *= PeakThresh;
117    for (maxL = maxI; maxL>0 && FqOtV[maxL].Val2 > MaxVal; maxL--) { }
118    for (maxR = maxI; maxR<FqOtV.Len() && FqOtV[maxR].Val2 > MaxVal; maxR++) { }
119    if (maxR-maxL > 100) { return false; }
120    for (int i = maxR; i < FqOtV.Len(); i++) {
121      if (FqOtV[i].Val2 > MaxVal) { return false; }
122    }
123    for (int i = maxL; i >= 0; i--) {
124      if (FqOtV[i].Val2 > MaxVal) { return false; }
125    }
126    return true;
127  }
128  void TQuote::GetFqOt(TTmFltPrV& RawFqOtV, const TTmUnit& TmUnit) const {
129    THash<TSecTm, TFlt> TmCntH;
130    for (int i = 0; i < TmUrlCntV.Len(); i++) {
131      TmCntH.AddDat(TmUrlCntV[i].Tm().Round(TmUnit)) += TmUrlCntV[i].Cnt();
132    }
133    TmCntH.SortByKey();
134    TmCntH.GetKeyDatPrV(RawFqOtV);
135  }
136  void TQuote::GetFqOt(TTmFltPrV& RawFqOtV, const TTmUnit& TmUnit, const TUrlTy& UrlTy, const TQuoteBs& QtBs) const {
137    THash<TSecTm, TFlt> TmCntH;
138    for (int i = 0; i < TmUrlCntV.Len(); i++) {
139      if (UrlTy==utUndef || QtBs.GetUrlTy(TmUrlCntV[i].UrlId())==UrlTy) {
140        TmCntH.AddDat(TmUrlCntV[i].Tm().Round(TmUnit)) += TmUrlCntV[i].Cnt();
141      }
142    }
143    TmCntH.SortByKey();
144    TmCntH.GetKeyDatPrV(RawFqOtV);
145  }
146  void TQuote::GetFqOt(TTmFltPrV& RawFqOtV, const TTmUnit& TmUnit, const TSecTm& BegTm, const TSecTm& EndTm) const {
147    const TSecTm RBegTm = BegTm.Round(TmUnit);
148    const TSecTm REndTm = EndTm.Round(TmUnit);
149    THash<TSecTm, TFlt> TmCntH;
150    for (int i = 0; i < TmUrlCntV.Len(); i++) {
151      const TSecTm Tm = TmUrlCntV[i].Tm().Round(TmUnit);
152      if (Tm >= RBegTm && Tm <= REndTm) {
153        TmCntH.AddDat(Tm) += TmUrlCntV[i].Cnt();
154      }
155    }
156    TmCntH.SortByKey();
157    TmCntH.GetKeyDatPrV(RawFqOtV);
158  }
159  void TQuote::GetFqOt(TTmFltPrV& RawFqOtV, const TTmUnit& TmUnit, const TSecTm& BegTm, const TSecTm& EndTm, const TUrlTy& UrlTy, const TQuoteBs& QtBs) const {
160    const TSecTm RBegTm = BegTm.Round(TmUnit);
161    const TSecTm REndTm = EndTm.Round(TmUnit);
162    THash<TSecTm, TFlt> TmCntH;
163    for (int i = 0; i < TmUrlCntV.Len(); i++) {
164      const TSecTm Tm = TmUrlCntV[i].Tm().Round(TmUnit);
165      if (Tm >= RBegTm && Tm <= REndTm && (UrlTy==utUndef || QtBs.GetUrlTy(TmUrlCntV[i].UrlId())==UrlTy)) {
166        TmCntH.AddDat(Tm) += TmUrlCntV[i].Cnt();
167      }
168    }
169    TmCntH.SortByKey();
170    TmCntH.GetKeyDatPrV(RawFqOtV);
171  }
172  void TQuote::GetSmoothFqOt(TTmFltPrV& FqOtV, const TTmUnit& TmUnit, const int& WndSz, const double& Smooth, const TSecTm& BegTm, const TSecTm& EndTm) const {
173    TTmFltPrV RawFqOtV;
174    GetFqOt(RawFqOtV, TmUnit, BegTm, EndTm);
175    GetSmoothFqOt(FqOtV, RawFqOtV, TmUnit, WndSz, Smooth, BegTm, EndTm);
176  }
177  void TQuote::GetSmoothFqOt(TTmFltPrV& SmoothFqOtV, const TTmFltPrV& RawFqOtV, const TTmUnit& TmUnit, const int& WndSz, const double& Smooth, const TSecTm& BegTm, const TSecTm& EndTm) {
178    const int TmUnitSecs = TTmInfo::GetTmUnitSecs(TmUnit);
179    const int HalfWndSecs = (WndSz/2)*TmUnitSecs;
180    double FullNormConst = 1;
181    for (int j = 1; j <= WndSz/2; j++) {
182      FullNormConst += 2*pow(Smooth, -j); }
183    THash<TSecTm, TFlt> TmCntH;
184    for (int i = 0; i < RawFqOtV.Len(); i++) {
185      const TSecTm Tm = RawFqOtV[i].Val1;
186      double NormConst = FullNormConst;
187      if (Tm < BegTm+HalfWndSecs || Tm+HalfWndSecs > EndTm) {
188        NormConst = 1;
189        for (int j = 1; j <= WndSz/2; j++) {
190          if (Tm >= BegTm+j*TmUnitSecs) { NormConst += pow(Smooth, -j);  }
191          if (Tm+j*TmUnitSecs <= EndTm) { NormConst += pow(Smooth, -j);  }
192      } }
193      const double NormFq = RawFqOtV[i].Val2 / NormConst;
194      for (int j = 1; j <= WndSz/2; j++) {
195        const int Off = j*TmUnitSecs;
196        if (Tm+Off <= EndTm) {
197          TmCntH.AddDat(TSecTm(Tm+Off).Round(TmUnit)) += NormFq * pow(Smooth, -j); }
198        if (Tm >= BegTm + Off) {
199          TmCntH.AddDat(TSecTm(Tm-Off).Round(TmUnit)) += NormFq * pow(Smooth, -j); }
200      }
201      TmCntH.AddDat(Tm.Round(TmUnit)) += NormFq;
202    }
203    TmCntH.SortByKey();
204    TmCntH.GetKeyDatPrV(SmoothFqOtV);
205  }
206  TStr TQuote::GetDesc() const {
207    return TStr::Fmt("#:%d U:%d  %s", GetFq(), GetUrls(), QtStr.CStr());
208  }
209  void TQuote::PlotOverTm(const TStr& OutFNm) {
210    TFltFltH HrCntH;
211    TmUrlCntV.Sort();
212    if (TmUrlCntV.Empty()) { return; }
213    for (int i = 0; i < TmUrlCntV.Len(); i++) {
214      double Hr = TSecTm(TmUrlCntV[i].Tm()-TmUrlCntV[0].Tm()).Round(tmu6Hour)/(24*3600.0);
215      HrCntH.AddDat(Hr) += TmUrlCntV[i].Cnt();
216    }
217    HrCntH.SortByKey();
218    TGnuPlot::PlotValCntH(HrCntH, OutFNm, TStr::Fmt("%d occurences, %d urls: %s", GetFq(), GetUrls(), QtStr.CStr()),
219      TStr::Fmt("Time [days] from %s", TmUrlCntV[0].Tm().GetYmdTmStr().CStr()), "Frequency");
220  }
221  void TQuote::LoadQtV(const TStr& InFNm, TVec<TQuote>& QtV) {
222    PSIn SIn = TZipIn::IsZipFNm(InFNm) ? TZipIn::New(InFNm) : TFIn::New(InFNm);
223    QtV.Clr(false);
224    while (! SIn->Eof()) {
225      QtV.Add();
226      QtV.Last().Load(*SIn);
227    }
228  }
229  TQuoteBs::TQuoteBs(TSIn& SIn) : StrQtIdH(SIn), QuoteH(SIn), UrlInDegH(SIn), UrlTyH(SIn) {
230    if (! SIn.Eof()) { ClustQtIdVH.Load(SIn); }
231    TIntSet CIdSet;
<span onclick='openModal()' class='match'>232    for (int q = 0; q < ClustQtIdVH.Len(); q++) {
233      CIdSet.AddKey(ClustQtIdVH.GetKey(q));
234      for (int c = 0; c < ClustQtIdVH[q].Len(); c++) {
235        CIdSet.AddKey(ClustQtIdVH[q][c]); } 
236      CIdSet.GetKeyV(ClustQtIdVH[q]);
237      ClustQtIdVH[q].Sort();
238      CIdSet.Clr(false);
239    }
240    Dump();
241  }
</span>242  void TQuoteBs::Save(TSOut& SOut) const {
243    StrQtIdH.Save(SOut);
244    QuoteH.Save(SOut);
245    UrlInDegH.Save(SOut);
246    UrlTyH.Save(SOut);
247    ClustQtIdVH.Save(SOut);
248  }
249  PQuoteBs TQuoteBs::New() {
250    return PQuoteBs(new TQuoteBs());
251  }
252  PQuoteBs TQuoteBs::Load(TSIn& SIn) {
253    printf("loading %s...", SIn.GetSNm().CStr());
254    return PQuoteBs(new TQuoteBs(SIn));
255  }
256  void TQuoteBs::GetQtIdV(TIntV& QtIdV) const {
257    QtIdV.Clr();
258    for (int q = 0; q < QuoteH.Len(); q++) {
259      QtIdV.Add(QuoteH.GetKey(q)); }
260  }
261  TUrlTy TQuoteBs::GetUrlTy(const int& UrlId) const {
262    if (UrlTyH.IsKey(UrlId)) {
263      return (TUrlTy) UrlTyH.GetDat(UrlId).Val; } 
264    return utBlog; 
265  }
266  void TQuoteBs::SetUrlTy(const TStr& InFNm, const TUrlTy& SetTy) {
267    printf("Set url type\n");
268    TStrHash<TIntV> DomUrlV; 
269    for (int q = 0; q < Len(); q++) {
270      const TQuote::TTmUrlCntV& V = GetQtN(q).TmUrlCntV;
271      for (int u = 0; u < V.Len(); u++) {
272        const TChA Url = GetStr(V[u].UrlId());
273        DomUrlV.AddDat(TStrUtil::GetDomNm(Url).CStr()).Add(V[u].UrlId());
274      }
275    }
276    printf("  %d domains\n", DomUrlV.Len());
277    TStrV TyUrlV; TStr Ln;
278    if (! TFile::Exists(InFNm)) {
279      printf("!!! %s does not exist\n", InFNm.CStr());
280      return;
281    }
282    for (TFIn FIn(InFNm); FIn.GetNextLn(Ln); ) { TyUrlV.Add(Ln.GetTrunc()); }
283    printf("  %d domains with type label loaded\n", TyUrlV.Len());
284    int NDomSet=0, NUrlSet=0;
285    TExeTm ExeTm;
286    for (int d = 0; d < DomUrlV.Len(); d++) {
287      for (int u = 0; u < TyUrlV.Len(); u++) {
288        if (strstr(DomUrlV.GetKey(d), TyUrlV[u].CStr()) != NULL) {
289          const TIntV& urlV = DomUrlV[d];
290          for (int i = 0; i < urlV.Len(); i++) {
291            UrlTyH.AddDat(urlV[i], SetTy); }
292          NDomSet++;  NUrlSet+=urlV.Len();
293          break;
294        }
295      }
296      if (d % 1000 == 0) { printf("  %d/%d: labeled %d doms, %d urls [%s]\n", d, DomUrlV.Len(), NDomSet, NUrlSet, ExeTm.GetStr()); }
297    }
298    printf("  labeled %d doms, %d urls [%s]\n", NDomSet, NUrlSet, ExeTm.GetStr());
299    printf("  %d total labeled urls\n", UrlTyH.Len());
300  }
301  bool AppearsAt(const TIntSet& UrlSet, const TQuote& Q) {
302    for (int u = 0; u < Q.GetUrls(); u++) {
303      if (UrlSet.IsKey(Q.GetUrlId(u))) { return true; }
304    }
305    return false;
306  }
307  void TQuoteBs::GetQtIdVByFq(TIntV& QtIdV, const int& MinWrdLen, const int& MinQtFq, const bool& OnlyClustRoots, const TStr& HasWord, const TStr& AppearsAtUrl, const TUrlTy& OnlyCountTy, const TSecTm& BegTm, const TSecTm& EndTm) const {
308    printf("Get top quotes from %d quotes\n", QuoteH.Len());
309    printf("  %s -- %s\n", BegTm.GetYmdTmStr().CStr(), EndTm.GetYmdTmStr().CStr());
310    TIntPrV FqQtIdV;
311    int words=0, minFq=0, hasWord=0;
312    TIntSet CSet, QSet;
313    TIntSet UrlSet;
314    if (! AppearsAtUrl.Empty()) {
315      for (int q = 0; q < QuoteH.Len(); q++) {
316        const TQuote& Q = GetQtN(q);
317        TQuote::TTmUrlCntV TmUrlCntV(Q.GetUrls(), 0);
318        for (int u = 0; u < Q.GetUrls(); u++) {
319          if (UrlSet.IsKey(Q.GetUrlId(u))) {
320            TmUrlCntV.Add(Q.TmUrlCntV[u]);
321            continue; }
322          if (strstr(GetStr(Q.GetUrlId(u)), AppearsAtUrl.CStr())!=NULL) {
323            TmUrlCntV.Add(Q.TmUrlCntV[u]);
324            UrlSet.AddKey(Q.GetUrlId(u)); } 
325        }
326        TQuote* QPt = (TQuote*) &(QuoteH[q]);
327        QPt->TmUrlCntV = TmUrlCntV; 
328      }
329    }
330    printf("done.");
331    for (int q = 0; q < QuoteH.Len(); q++) {
332      const TQuote& Qt = GetQtN(q);
333      if (TStrUtil::CountWords(Qt.QtStr.CStr()) < MinWrdLen) { words++;  continue; }
334      if ((! HasWord.Empty()) && Qt.QtStr.SearchStr(HasWord)==-1) { hasWord++;  continue; }
335      int Fq = 0;
336      if (OnlyClustRoots && Qt.GetTy() == qtRoot) {
337        IAssert(Qt.GetCId() == GetQtId(q));
338        IAssert(! CSet.IsKey(Qt.GetCId()));  CSet.AddKey(Qt.GetCId());
339        if ((! HasWord.Empty()) && GetQt(GetCentrQtId(Qt.GetCId())).GetStr().SearchStr(HasWord)==-1) { hasWord++; continue; } 
340        TQuote CentrQt;  GetMergedClustQt(Qt.GetCId(), CentrQt, true); 
341        if (! UrlSet.Empty() && ! AppearsAt(UrlSet, CentrQt)) { continue; }
342        Fq = CentrQt.GetFq(BegTm, EndTm, OnlyCountTy, *this);
343        if (Fq < MinQtFq) { minFq++; continue; }
344        const int Doms = CentrQt.GetDoms(*this);
345        if (Doms < 3 || 5*Doms < CentrQt.GetUrls()) { continue; }
346      }
347      else {
348        if (! UrlSet.Empty() && ! AppearsAt(UrlSet, Qt)) { continue; }
349        Fq = Qt.GetFq(BegTm, EndTm, OnlyCountTy, *this);
350        if (Fq < MinQtFq) { minFq++; continue; }
351        const int Doms = Qt.GetDoms(*this);
352        if (Doms < 3 || 4*Doms < Qt.GetUrls()) { continue; }
353      }
354      IAssert(! QSet.IsKey(GetQtId(q))); QSet.AddKey(GetQtId(q));
355      FqQtIdV.Add(TIntPr(Fq, GetQtId(q)));
356    }
357    printf("  skip %d : word len < %d\n", words, MinWrdLen);
358    printf("  skip %d : qt fq < %d\n", minFq, MinQtFq);
359    if (! HasWord.Empty()) { printf("  skip %d : not containing '%s'\n", hasWord, HasWord.CStr()); }
360    printf("  remaining %d quotes\n", FqQtIdV.Len());
361    FqQtIdV.Sort(false);
362    QtIdV.Clr(false);
363    TIntSet SeenSet;
364    for (int i = 0; i < FqQtIdV.Len(); i++) {
365      if (i < 100) { printf(" fq:%d", FqQtIdV[i].Val1()); }
366      const int qid = FqQtIdV[i].Val2;
367      if (! SeenSet.IsKey(qid)) {
368        QtIdV.Add(qid);
369        SeenSet.AddKey(qid);
370        if (GetQt(qid).GetTy()==qtRoot || GetQt(qid).GetTy()==qtCentr) {
371          const TIntV& ClustV = GetClust(GetQt(qid).GetCId());
372          for (int c = 0; c < ClustV.Len(); c++) { SeenSet.AddKey(ClustV[c]); }
373        }
374      }
375    }
376    printf("  return %d quotes\n", QtIdV.Len());
377  }
378  int AppearsAtDom(const TQuote& CentrQt, const TIntSet& GoodDom, const TIntH& UrlDomH) {
379    int DomCnt = 0;
380    for (int u = 0; u < CentrQt.GetUrls(); u++) {
381      const int U = CentrQt.GetUrlId(u);
382      IAssert(UrlDomH.IsKey(U));
383      if (GoodDom.IsKey(UrlDomH.GetDat(U))) { 
384        DomCnt++; }
385    }
386    return DomCnt;
387  }
388  void TQuoteBs::GetQtIdVByFq(TIntV& QtIdV, const int& MinWrdLen, const int& MinQtFq, const TStrV& FromDomains,
389                              const bool& OnlyClustRoots, const TStr& HasWord, int MinDoms) const {
390    printf("Get top quotes from %d quotes appearing at %d domains\n", QuoteH.Len(), FromDomains.Len());
391    TIntPrV FqQtIdV;
392    TIntH UrlDomH;
393    TStrSet DomainSet;
394    TIntSet QSet;
395    for (int q = 0; q < QuoteH.Len(); q++) {
396      const TQuote& Q = GetQtN(q);
397      for (int u = 0; u < Q.GetUrls(); u++) {
398        const int U = Q.GetUrlId(u);
399        const int D = DomainSet.AddKey(TStrUtil::GetDomNm2(GetStr(U)));
400        UrlDomH.AddDat(U, D);
401      }
402    }
403    TIntSet GoodDom;
404    for (int d = 0; d < DomainSet.Len(); d++) {
405      for (int f = 0; f < FromDomains.Len(); f++) {
406        if (DomainSet[d].SearchStr(FromDomains[f]) != -1) {
407          GoodDom.AddKey(d); break; }
408      }
409    }
410    printf("%d total domains\n", DomainSet.Len());
411    printf("%d from domains\n", FromDomains.Len());
412    printf("%d good domains\n", GoodDom.Len());
413    printf("done.\n\n");
414    const TSecTm BegTm(1), EndTm(TSecTm::GetCurTm());
415    for (int q = 0; q < QuoteH.Len(); q++) {
416      const TQuote& Qt = GetQtN(q);
417      if (TStrUtil::CountWords(Qt.QtStr.CStr()) < MinWrdLen) { continue; }
418      if ((! HasWord.Empty()) && Qt.QtStr.SearchStr(HasWord)==-1) { continue; }
419      int Fq = 0;
420      if (Qt.GetTy() == qtRoot) {
421        TQuote CentrQt;
422        GetMergedClustQt(Qt.GetCId(), CentrQt, true); 
423        if (AppearsAtDom(CentrQt, GoodDom, UrlDomH) < MinDoms) { continue; }
424        Fq = CentrQt.GetFq(BegTm, EndTm, utUndef, *this);
425        if (Fq < MinQtFq) { continue; }
426        const int Doms = CentrQt.GetDoms(*this);
427        if (Doms < 3 || 5*Doms < CentrQt.GetUrls()) { continue; }
428      }
429      else if (! OnlyClustRoots) {
430        if (AppearsAtDom(Qt, GoodDom, UrlDomH) < MinDoms) { continue; }
431        Fq = Qt.GetFq(BegTm, EndTm, utUndef, *this);
432        if (Fq < MinQtFq) { continue; }
433        const int Doms = Qt.GetDoms(*this);
434        if (Doms < 3 || 4*Doms < Qt.GetUrls()) { continue; }
435      }
436      IAssert(! QSet.IsKey(GetQtId(q))); QSet.AddKey(GetQtId(q));
437      FqQtIdV.Add(TIntPr(Fq, GetQtId(q)));
438    }
439    printf("  remaining %d quotes\n", FqQtIdV.Len());
440    FqQtIdV.Sort(false);
441    QtIdV.Clr(false);
442    TIntSet SeenSet;
443    for (int i = 0; i < FqQtIdV.Len(); i++) {
444      const int qid = FqQtIdV[i].Val2;
445      if (! SeenSet.IsKey(qid)) {
446        QtIdV.Add(qid);
447        SeenSet.AddKey(qid);
448        if (GetQt(qid).GetTy()==qtRoot || GetQt(qid).GetTy()==qtCentr) {
449          const TIntV& ClustV = GetClust(GetQt(qid).GetCId());
450          for (int c = 0; c < ClustV.Len(); c++) { SeenSet.AddKey(ClustV[c]); }
451        }
452      }
453    }
454    printf("  return %d quotes\n", QtIdV.Len());
455  }
456  void TQuoteBs::GetQtIdVByTm(const int& WndSzHr, const int& StepHr, const int& MinWrdLen, const int& MinQtFq, const int& TakePerStep) const {
457    const TTmUnit TmUnit = tmu4Hour;
458    TSecTm MinTm, MaxTm;  GetMinMaxTm(MinTm, MaxTm);
459    MinTm=MinTm.Round(TmUnit); MaxTm=MaxTm.Round(TmUnit);
460    printf("Dataset span %s -- %s\n", MinTm.GetStr().CStr(), MaxTm.GetStr().CStr());
461    printf("  time window %dh, step size %dh, min wrd len %d, take top %d per step\n", WndSzHr, StepHr, MinWrdLen, TakePerStep);
462    TIntSet TopQtIdSet;
463    TIntV TopQtIdV;
464    int cnt=0;
465    FILE *F = fopen("top_qts_per_time_unit.txt", "wt");
466    for (TSecTm Tm=MinTm; Tm <= MaxTm; Tm += StepHr*3600, cnt++) {
467      GetQtIdVByFq(TopQtIdV, MinWrdLen, MinQtFq, true, "", "", utUndef, TSecTm(Tm), TSecTm(Tm+StepHr*3600));
468      fprintf(F,"week of: %s\n", Tm.GetYmdTmStr().CStr());
469      for (int q = 0, j=0; q < TopQtIdV.Len() && j<3; q++) {
470        if (! TopQtIdSet.IsKey(TopQtIdV[q])) {
471          fprintf(F, "%s\t%d\n", GetQt(GetCentrQtId(TopQtIdV[q])).GetStr().CStr(), GetClustFq(TopQtIdV[q]));
472          j++; }
473        TopQtIdSet.AddKey(TopQtIdV[q]);
474      }
475      fprintf(F, "\n");
476    }
477    fclose(F);
478    printf("  done %d quotes\n", TopQtIdSet.Len());
479  }
480  void TQuoteBs::GetCIdVByFq(TIntV& CIdV, const int& MinClFq, const TStr& RootHasWord, const TUrlTy& OnlyCountTy, const bool& OnlyAfterRoot, const TSecTm& BegTm, const TSecTm& EndTm) const {
481    printf("Get top clusters from %d clusters\n", GetClusts());
482    TIntPrV FqCIdV;
483    for (int c = 0; c < GetClusts(); c++) {
484      const int CId = GetCId(c);
485      if ( ! IsQtId(CId)) { printf("!!! %d:%d\n", c, CId); continue; }
486      IAssert(GetQt(CId).GetTy()==qtRoot);
487      const int CentrQId = GetCentrQtId(CId);
488      if (CentrQId == -1) { continue; }
489      if ((! RootHasWord.Empty()) && GetQt(CentrQId).GetStr().SearchStr(RootHasWord)==-1) { continue; } 
490      TQuote CentrQt;  GetMergedClustQt(CId, CentrQt, OnlyAfterRoot); 
491      const int Fq = CentrQt.GetFq(BegTm, EndTm, OnlyCountTy, *this);
492      if (Fq < MinClFq) { continue; }
493      FqCIdV.Add(TIntPr(Fq, CId));
494    }
495    printf("  remaining %d clusters\n", FqCIdV.Len());
496    FqCIdV.Sort(false);
497    CIdV.Clr(false);
498    for (int i = 0; i < FqCIdV.Len(); i++) {
499      CIdV.Add(FqCIdV[i].Val2); }
500  }
501  void TQuoteBs::GetMinMaxTm(TSecTm& MinTm, TSecTm& MaxTm) const {
502    MinTm = MaxTm = TSecTm();
503    for (int q = 0; q < QuoteH.Len(); q++) {
504      const TQuote::TTmUrlCntV& V = QuoteH[q].TmUrlCntV;
505      if (V.Empty()) { continue; }
506      if (! MinTm.IsDef() || MinTm > V[0].Tm()) {
507        MinTm = V[0].Tm(); }
508      if (! MaxTm.IsDef() || MaxTm < V[0].Tm()) {
509        MaxTm = V[0].Tm(); }
510    }
511  }
512  void TQuoteBs::GetMinMaxTm(const TIntV& QtIdV, TSecTm& MinTm, TSecTm&MaxTm) const {
513    MinTm = MaxTm = TSecTm();
514    for (int q = 0; q < QtIdV.Len(); q++) {
515      const TQuote::TTmUrlCntV& V = GetQt(QtIdV[q]).TmUrlCntV;
516      if (V.Empty()) { continue; }
517      if (! MinTm.IsDef() || MinTm > V[0].Tm()) {
518        MinTm = V[0].Tm(); }
519      if (! MaxTm.IsDef() || MaxTm < V[0].Tm()) {
520        MaxTm = V[0].Tm(); }
521    }
522  }
523  void TQuoteBs::GetQtPageUrl(const TIntV& QtIdV, TIntH& QtUrlIdH) const {
524    THash<TChA, TInt> DomQtCntH;
525    for (int q = 0; q < Len(); q++) {
526      const TQuote& Q = GetQtN(q);
527      for (int u = 0; u < Q.GetUrls(); u++) {
528        DomQtCntH.AddDat(TStrUtil::GetDomNm(GetStr(Q.TmUrlCntV[u].UrlId()))) += Q.TmUrlCntV[u].Cnt(); }
529    }
530    const TStr StopList = "blog.myspace.com|www.newsmeat.com|us.rd.yahoo.com|www.startribune.com|"
531      "news.originalsignal.com|uk.news.yahoo.com|ap.google.com|www.cnn.com|www.opednews.com";
532    TStrV StopListV; StopList.SplitOnAllCh('|', StopListV);
533    for (int s = 0; s < StopListV.Len(); s++) {
534      DomQtCntH.AddDat(StopListV[s]) = 1; }
535    DomQtCntH.SortByDat(false);
536    QtUrlIdH.Clr(false);
537    for (int q = 0; q < QtIdV.Len(); q++) {
538      const TQuote& Q = GetQt(QtIdV[q]);
539      int DomFq=0, BestUrlId=0;
540      for (int u = 0; u < Q.TmUrlCntV.Len(); u++) {
541        const TChA Dom = TStrUtil::GetDomNm(GetStr(Q.TmUrlCntV[u].UrlId()));
542        if (DomFq < DomQtCntH.GetDat(Dom)) {
543          DomFq = DomQtCntH.GetDat(Dom);
544          BestUrlId = Q.TmUrlCntV[u].UrlId();
545        }
546      }
547      QtUrlIdH.AddDat(QtIdV[q], BestUrlId);
548    }
549  }
550  void TQuoteBs::AddQuote(const TQuote& Quote, const TQuoteBs& CurQtBs) {
551    const int QtId = CurQtBs.GetQtId(Quote.GetStr().CStr());
552    TQuote& Qt = QuoteH.AddDat(QtId);
553    StrQtIdH.AddDat(Quote.GetStr().CStr(), QtId);
554    Qt.QtCIdTy = TQuote::TQtIdTy(Quote.GetCId(), Quote.GetTy());
555    Qt.QtStr = Quote.QtStr;
556    Qt.TmUrlCntV = Quote.TmUrlCntV;
557    for (int u = 0; u < Qt.TmUrlCntV.Len(); u++) {
558      Qt.TmUrlCntV[u].SetUrlId(AddStr(CurQtBs.GetStr(Quote.TmUrlCntV[u].UrlId())));
559    }
560  }
561  void TQuoteBs::AddQuote(const TVec<TChA>& QuoteV, const TVec<TChA>& LinkV, const TChA& PostUrlStr, const TSecTm& PubTm, const int& MinQtWrdLen) {
562    TIntH QtCntH; 
563    for (int q = 0; q < QuoteV.Len(); q++) {
564      if (TStrUtil::CountWords(QuoteV[q].CStr()) < MinQtWrdLen) { continue; } 
565      int QtId = GetQtId(QuoteV[q].CStr());
566      if (QtId == -1) { 
567        IAssert(! IsStr(QuoteV[q].CStr()));
568        QtId = QuoteH.Len();
569        TQuote& Qt = QuoteH.AddDat(QtId);
570        Qt.QtCIdTy = TQuote::TQtIdTy(QtId, qtQuote);
571        Qt.QtStr = QuoteV[q];
572        StrQtIdH.AddDat(QuoteV[q].CStr(), QtId);
573      } else { IAssert(IsStr(QuoteV[q].CStr())); }
574      IAssert(IsQtId(QtId));
575      QtCntH.AddDat(QtId) += 1; 
576    }
577    if (QtCntH.Len() > 0) {
578      const int PostUrlId = AddStr(PostUrlStr);
579      for (int i = 0; i < QtCntH.Len(); i++) {
580        QuoteH.GetDat(QtCntH.GetKey(i)).TmUrlCntV.Add(TQuote::TTmUrlCnt(PubTm, PostUrlId, QtCntH[i]));
581      }
582    }
583    const TChA PostDomain = TStrUtil::GetDomNm(PostUrlStr);
584    for (int l = 0; l < LinkV.Len(); l++) {
585      const TChA& Url = LinkV[l];
586      if (TStrUtil::GetDomNm(Url) == PostDomain) { continue; } 
587      if (IsStr(Url.CStr())) { UrlInDegH.AddDat(GetStrId(Url.CStr())) += 1; }
588    }
589  }
590  PQuoteBs TQuoteBs::GetQuoteBs(const TIntV& QtIdV) const {
591    PQuoteBs _NewQtBs = TQuoteBs::New();
592    TQuoteBs& NewQtBs = *_NewQtBs;
593    for (int q = 0; q < QtIdV.Len(); q++) {
594      const TQuote& Qt = GetQt(QtIdV[q]);
595      NewQtBs.AddQuote(Qt, *this);
596    }
597    for (int u = 0; u < UrlInDegH.Len(); u++) {
598      const char* UrlStr = GetStr(UrlInDegH.GetKey(u));
599      if (NewQtBs.IsStr(UrlStr)) {
600        NewQtBs.UrlInDegH.AddDat(NewQtBs.GetStrId(UrlStr), UrlInDegH[u]); }
601    }
602    for (int t = 0; t < UrlTyH.Len(); t++) {
603      const char* UrlStr = GetStr(UrlTyH.GetKey(t));
604      if (NewQtBs.IsStr(UrlStr)) {
605        NewQtBs.UrlTyH.AddDat(NewQtBs.GetStrId(UrlStr), UrlTyH[t]); }
606    }
607    for (int c = 0; c < GetClusts(); c++) {
608      const int CId = GetCId(c);
609      if ( ! IsQtId(CId)) { printf("!!! %d:%d\n", c, CId); continue; }
610      const TIntV& CQtIdV = GetClust(CId);
611      if (NewQtBs.IsQtId(CId)) {
612        IAssert(! NewQtBs.ClustQtIdVH.IsKey(CId));
613        TIntV& CIdV = NewQtBs.ClustQtIdVH.AddDat(CId);
614        for (int i = 0; i < CQtIdV.Len(); i++) {
615          if (NewQtBs.IsQtId(CQtIdV[i])) { CIdV.Add(CQtIdV[i]); }
616        }
617        IAssert(CIdV.Len() > 0);
618      }
619    }
620    return _NewQtBs;
621  }
622  int TQuoteBs::GetQtsInClust() const {
623    int qts = 0;
624    for (int q = 0; q < ClustQtIdVH.Len(); q++) {
625      qts += ClustQtIdVH[q].Len();
626    }
627    return qts;
628  }
629  int TQuoteBs::GetClustFq(const int& CId) const {
630    int fq = 0;
631    TIntSet S;
632    const TIntV& ClustV = ClustQtIdVH.GetDat(CId);
633    for (int c = 0; c < ClustV.Len(); c++) {
634      fq += GetQt(ClustV[c]).GetFq();
635      IAssert(! S.IsKey(ClustV[c]));
636      S.AddKey((ClustV[c]));
637    }
638    return fq;
639  }
640  int TQuoteBs::GetClustFq(const int& CId, const TUrlTy& UrlTy) const {
641    int fq = 0;
642    const TIntV& ClustV = ClustQtIdVH.GetDat(CId);
643    for (int c = 0; c < ClustV.Len(); c++) {
644      fq += GetQt(ClustV[c]).GetFq(UrlTy, *this);
645    }
646    return fq;
647  }
648  int TQuoteBs::GetCentrQtId(const int& CId) const {
649    return GetCentrQtId(GetClust(CId));
650  }
651  int TQuoteBs::GetCentrQtId(const TIntV& ClustV) const {
652    TIntPrV QtFqIdV;
653    for (int c = 0; c < ClustV.Len(); c++) {
654      if (! IsQtId(ClustV[c])) { continue; }
655      const TQuote& Q = GetQt(ClustV[c]);
656      QtFqIdV.Add(TIntPr(Q.GetUrls(), ClustV[c]));
657    }
658    if (QtFqIdV.Empty()) { return -1; }
659    QtFqIdV.Sort(false);
660    const TStr FqStr = GetQt(QtFqIdV[0].Val2).GetStr(); 
661    for (int c = 0; c < QtFqIdV.Len(); c++) {
662      IAssert(IsQtId(QtFqIdV[c].Val2));
663      const TQuote& Q = GetQt(QtFqIdV[c].Val2);
664      const int Words = TStrUtil::CountWords(Q.GetStr().CStr());
665      if (Words >= 6 && Words < 50 && strstr(Q.GetStr().CStr(), FqStr.CStr())!=NULL) {
666        return QtFqIdV[c].Val2; }
667    }
668    return QtFqIdV[0].Val2;
669  }
670  void TQuoteBs::GetMergedClustQt(const int& CId, TQuote& NewQt, const bool& OnlyAfterBegTm) const {
671    const TIntV& ClustV = GetClust(CId);
672    GetMergedClustQt(ClustV, NewQt, OnlyAfterBegTm);
673  }
674  void TQuoteBs::GetMergedClustQt(const TIntV& ClustV, TQuote& NewQt, const bool& OnlyAfterBegTm) const {
675    const int CentrQtId = GetCentrQtId(ClustV);
676    const TSecTm BegTm = OnlyAfterBegTm ? GetClustBegTm(ClustV, CentrQtId) : TSecTm(1);
677    THash<TPair<TSecTm, TInt>, TInt> TmUrlCntH;
678    for (int c = 0; c < ClustV.Len(); c++) {
679      const TQuote& Q = GetQt(ClustV[c]);
680      for (int u = 0; u < Q.TmUrlCntV.Len(); u++) {
681        if (Q.TmUrlCntV[u].Tm() >= BegTm) {
682          TmUrlCntH.AddDat(TPair<TSecTm, TInt>(Q.TmUrlCntV[u].Tm(), Q.TmUrlCntV[u].UrlId())) += Q.TmUrlCntV[u].Cnt(); }
683      }
684    }
685    NewQt.QtCIdTy = TQuote::TQtIdTy(-1, qtCentr);
686    NewQt.QtStr = GetQt(CentrQtId).GetStr(); 
687    if (! TmUrlCntH.Empty()) {
688      NewQt.TmUrlCntV.Gen(TmUrlCntH.Len(), 0);
689      for (int u = 0; u < TmUrlCntH.Len(); u++) {
690        NewQt.TmUrlCntV.Add(TQuote::TTmUrlCnt(TmUrlCntH.GetKey(u).Val1, TmUrlCntH.GetKey(u).Val2(), TmUrlCntH[u]()));
691      }
692      NewQt.TmUrlCntV.Sort();
693    }
694  }
695  TSecTm TQuoteBs::GetClustBegTm(const int& CId, const int& CentrQtId) const {
696    const TIntV& ClustV = GetClust(CId);
697    return GetClustBegTm(ClustV, CentrQtId);
698  }
699  TSecTm TQuoteBs::GetClustBegTm(const TIntV& ClustV, const int& CentrQtId) const {
700    TStrHash<TInt> StrH;
701    TIntV CntrWIdV, WIdV;
702    int WIdV1Start, WIdV2Start, SkipId;
703    TStrUtil::GetAddWIdV(StrH, GetQt(CentrQtId).GetStr().CStr(), CntrWIdV);
704    TSecTm BegTm = TSecTm::GetCurTm();
705    for (int c = 0; c < ClustV.Len(); c++) {
706      TStrUtil::GetAddWIdV(StrH, GetQt(ClustV[c]).GetStr().CStr(), WIdV);
707      if (WIdV.Len() < CntrWIdV.Len()) { continue; }
708      const int Overlap = LongestCmnSubSq(CntrWIdV, WIdV, WIdV1Start, WIdV2Start, SkipId);
709      if (Overlap >= CntrWIdV.Len() && SkipId==0) { 
710        if (GetQt(ClustV[c]).TmUrlCntV.Empty()) { continue; }
711        BegTm = TMath::Mn(BegTm, GetQt(ClustV[c]).TmUrlCntV[0].Tm()); 
712      }
713    }
714    return BegTm;
715  }
716  int TQuoteBs::LongestCmnSubSq(const TIntV& WIdV1, const TIntV& WIdV2, int& WIdV1Start, int& WIdV2Start, int& SkipId) {
717    const TIntV& V1 = WIdV1.Len()>WIdV2.Len() ? WIdV1:WIdV2; 
718    const TIntV& V2 = WIdV1.Len()>WIdV2.Len() ? WIdV2:WIdV1; 
719    const int V1Len = V1.Len();
720    const int V2Len = V2.Len();
721    static THash<TInt, TIntV> WIdPosH;
722    static THashSet<TInt> V2WIdSet;
723    V2WIdSet.Clr(false);
724    for (int i=0; i < WIdPosH.Len(); i++) { WIdPosH[i].Clr(false); }
725    WIdPosH.Clr(false, -1, false);
726    WIdV1Start = WIdV2Start = SkipId = 0;
727    for (int i = 0; i < V2Len; i++) { 
728      V2WIdSet.AddKey(V2[i]); }
729    for (int i = 0; i < V1Len; i++) { 
730      if (V2WIdSet.IsKey(V1[i])) { WIdPosH.AddDat(V1[i]).Add(i); } }
731    {const int cmnWords = WIdPosH.Len();
732    if (cmnWords < V2WIdSet.Len()) {
733      if (cmnWords < 4) { return 0; }
734      else if (V2Len >= 5 && cmnWords < 5) { return 0; }
735      else if (V2Len > 6 && (2*cmnWords < V2Len && cmnWords < 10)) { return 0; } }
736    }
737    int MaxLen = 0;
738    for (int w = 0; w < V2Len; w++) { 
739      const int wid = V2[w];
740      if (! WIdPosH.IsKey(wid)) { continue; }
741      const TIntV& OccV = WIdPosH.GetDat(wid);
742      for (int o = 0; o < OccV.Len(); o++) {
743        const int beg = OccV[o];
744        int cnt = 0, tmp = 0;
745        while (w+cnt < V2Len && beg+cnt < V1Len && V2[w+cnt]==V1[beg+cnt]) { cnt++; tmp=0; }           
746        while (beg+1+cnt < V1Len && w+cnt < V2Len && V2[w+cnt]==V1[beg+cnt+1]) { cnt++; tmp=-1; }      
747        while (beg+cnt+1 < V1Len && w+cnt+1 < V2Len && V2[w+cnt+1]==V1[beg+cnt+1]) {  cnt++; tmp=-2;}  
748        while (beg+cnt < V1Len && w+cnt+1 < V2Len && V2[w+cnt+1]==V1[beg+cnt]) { cnt++; tmp=-3;}       
749        if (MaxLen < cnt) { MaxLen = cnt; SkipId=tmp; WIdV1Start = beg;  WIdV2Start = w; }
750        IAssert(cnt >= 1);
751      }
752    }
753    if (! (WIdV1.Len()>WIdV2.Len())) {
754      int tmp=WIdV1Start; WIdV1Start=WIdV2Start; WIdV2Start=tmp;
755    }
756    return MaxLen;
757  }
758  void TQuoteBs::CreateClusters(const TVec<TIntV>& ClustV) {
759    TIntV CIdV;
760    ClustQtIdVH.Clr();
761    printf("len %d\n", Len());
762    for (int q = 0; q < Len(); q++) {
763      TQuote& Q = GetQt(q);
764      Q.QtCIdTy = TQuote::TQtIdTy(q, qtQuote);
765    }
766    TIntH SeenNId;
767    for (int c = 0; c < ClustV.Len(); c++) {
768      if (ClustV[c].Len() < 3) { continue; } 
769      const int CentrQtId = GetCentrQtId(ClustV[c]);
770      if (CentrQtId == -1) {
771        printf("Cluster %d of size %d has no root!!!\n", c, ClustV[c].Len());
772        for (int i = 0; i < ClustV[c].Len(); i++) {
773          printf("  %d%c", ClustV[c][i].Val, IsQtId(ClustV[c][i])?'t':'f'); } printf("\n");
774        continue;
775      }
776      IAssert(! SeenNId.IsKey(CentrQtId));
777      SeenNId.AddKey(CentrQtId);
778      TQuote& Q = GetQt(CentrQtId);
779      if (Q.GetTy() != qtQuote) { printf("  %d", Q.GetTy()); }
780      IAssert(! ClustQtIdVH.IsKey(CentrQtId));
781      Q.QtCIdTy = TQuote::TQtIdTy(CentrQtId, qtRoot);
782      ClustQtIdVH.AddDat(CentrQtId, ClustV[c]);
783      for (int q = 0; q < ClustV[c].Len(); q++) {
784        if (ClustV[c][q] == CentrQtId) { continue; }
785        IAssert(! SeenNId.IsKey(ClustV[c][q]));
786        SeenNId.AddKey(ClustV[c][q]);
787        TQuote& Q2 = GetQt(ClustV[c][q]);
788        Q2.QtCIdTy = TQuote::TQtIdTy(CentrQtId, qtInClust);
789      }
790    }
791  }
792  void TQuoteBs::ClusterQts(const int& MinRootWrdLen, const int& MinQtFq, const TStr& OutFNmPref, const TStrV& BlackListV) {
793    printf("Cluster quotes with min Fq >= %d: %d total quotes\n", MinQtFq, Len());
794    TExeTm ExeTm;
795    TStrHash<TInt> StrH;
796    TVec<TPair<TInt, TIntV> > QWIdVV;  
797    { TIntPrV LenQIdV;  TIntV QWIdV;
798    printf("sort qid by len\n");
799    TStrHash<TInt> BlackListH;
800    for (int i = 0; i < BlackListV.Len(); i++) { BlackListH.AddDatId(BlackListV[i].GetTrunc()); }
801    printf("blacklist len: %d\n", BlackListH.Len());
802    for (int q1 = 0; q1 < Len(); q1++) {
803      const TQuote& Q = GetQtN(q1);
804      const int Doms = Q.GetDoms(*this);
805      if ((Q.GetTy()==qtQuote || Q.GetTy()==qtRoot) && Doms>1 && Doms*4>Q.GetUrls()
806        && Q.GetFq() >= MinQtFq && (! BlackListH.IsKey(Q.GetStr().CStr()))) { 
807          LenQIdV.Add(TIntPr(TStrUtil::CountWords(Q.QtStr.CStr()), GetQtId(q1))); }
808    }
809    printf("sort %d candidates\n", LenQIdV.Len());
810    LenQIdV.Sort(false);
811    printf("get word id vectors\n");
812    for (int q1 = 0; q1 < LenQIdV.Len(); q1++) {
813      TStrUtil::GetAddWIdV(StrH, GetQt(LenQIdV[q1].Val2).QtStr.CStr(), QWIdV);
814      QWIdVV.Add(TPair<TInt, TIntV>(LenQIdV[q1].Val2, QWIdV));
815    } }
816    printf("  %d root quotes\n", ClustQtIdVH.Len());
817    printf("  %d quotes to merge\n", QWIdVV.Len());
818    int NMergers=0;
819    FILE *F = fopen(TStr(OutFNmPref+"-merged.txt").CStr(), "wt");
820    const int ClusterQ=QWIdVV.Len();
821    for (int q1 = 0; q1 < ClusterQ; q1++) {
822      if (QWIdVV[q1].Val2.Len() < MinRootWrdLen) { continue; } 
823      const int Qt1Id = QWIdVV[q1].Val1;
824      for (int q2 = q1+1; q2 < ClusterQ; q2++) {
825        int idx1=0, idx2=0, SkipTy=0;
826        bool DoMerge = false;
827        const int ShortLen = TMath::Mn(QWIdVV[q1].Val2.Len(), QWIdVV[q2].Val2.Len());
828        if (ShortLen == 0) { continue; }
829        const int Overlap = LongestCmnSubSq(QWIdVV[q1].Val2, QWIdVV[q2].Val2, idx1, idx2, SkipTy);
830        if (ShortLen == 4 && Overlap == 4 &bsol;*&& SkipTy==0*/) { DoMerge=true; } 
831        else if (ShortLen == 5 && Overlap == 5 &bsol;*&& SkipTy==0*/) { DoMerge=true; } 
832        else if ((ShortLen == 6 && Overlap >= 5 &bsol;*&& SkipTy==0) || (ShortLen == 6 && Overlap == 5*/)) { DoMerge=true; }
833        else if (Overlap/double(ShortLen+3) > 0.5 || Overlap > 10) { DoMerge=true; }
834        if (DoMerge == true) {
835          NMergers++;
836          const int Qt2Id = QWIdVV[q2].Val1;
837          TQuote& Q1 = GetQt(Qt1Id);
838          TQuote& Q2 = GetQt(Qt2Id);
839          if (Q1.GetTy() != qtRoot) { 
840            IAssert(Q1.GetTy() == qtQuote);
841            IAssert(! ClustQtIdVH.IsKey(Qt1Id));
842            ClustQtIdVH.AddDat(Qt1Id).Add(Qt1Id);
843            Q1.QtCIdTy = TQuote::TQtIdTy(Qt1Id, qtRoot);
844          } else { IAssert(Q1.GetTy() == qtRoot); }
845          if (Q2.GetTy() == qtRoot) { 
846            for (int c = 0; c < ClustQtIdVH.GetDat(Qt2Id).Len(); c++) {
847              ClustQtIdVH.AddDat(Qt1Id).Add(ClustQtIdVH.GetDat(Qt2Id)[c]); }
848            Q2.QtCIdTy = TQuote::TQtIdTy(Qt1Id, qtInClust);
849            ClustQtIdVH.DelKey(Qt2Id);
850            IAssert(ClustQtIdVH.AddDat(Qt1Id).IsIn(Qt2Id));
851          } else {
852            IAssert(Q2.GetTy() == qtQuote);
853            Q2.QtCIdTy = TQuote::TQtIdTy(Qt1Id, qtInClust);
854            ClustQtIdVH.AddDat(Qt1Id).Add(Qt2Id);
855          }
856          QWIdVV[q2].Val2.Clr(true); 
857          { TStr Str= "    :"; if(SkipTy==-1){Str="long=";} else if(SkipTy==-2){Str="both=";} else if(SkipTy==-3){Str="shrt=";}
858          if (Str.Len()>0) { printf("%c", Str[0]); }
859          if (ClustQtIdVH.GetDat(Qt1Id).Len() == 2) { fprintf(F, "\n[%d] %s \t%d\n", TStrUtil::CountWords(Q1.QtStr.CStr()), Q1.QtStr.CStr(), Q1.GetFq()); }
860          fprintf(F, "%s%d [%d] %s \t%d\n", Str.CStr(), Overlap, TStrUtil::CountWords(Q2.QtStr.CStr()), Q2.QtStr.CStr(), Q2.GetFq()); }
861        }
862      }
863      if (ClustQtIdVH.IsKey(Qt1Id)) {
864        ClustQtIdVH.GetDat(Qt1Id).Pack();
865        ClustQtIdVH.GetDat(Qt1Id).Sort();
866        QWIdVV[q1].Val2.Clr(true);
867      }
868      if (q1>0 && q1 % 100 == 0) {
869        printf("\r  %d/%d: %d merged [%s]  ", q1, ClusterQ, NMergers, ExeTm.GetStr());
870        if (q1 % 1000 == 0) { printf("save.\n");  fflush(F);
871          TFOut FOut(OutFNmPref+"-QtBs.ClustQtIdVH"); ClustQtIdVH.Save(FOut); }
872      }
873    }
874    fclose(F);
875    printf("\n%d quotes, %d clusters [%s]\n\n.", NMergers, ClustQtIdVH.Len(), ExeTm.GetStr());
876  }
877  void TQuoteBs::ResetClusters() {
878    ClustQtIdVH.Clr();
879    for (int q = 0; q < Len(); q++) {
880      GetQtN(q).QtCIdTy = TQuote::TQtIdTy(GetQtId(q), qtQuote);
881    }
882  }
883  void TQuoteBs::ReassignToClust(const int& QtId, const int& NewCId) {
884    const int QtCl = GetQt(QtId).GetCId();
885    printf("assign %d from clust %d to %d\n", QtId, QtCl, NewCId);
886    if (QtCl != QtId) {
887      ClustQtIdVH.GetDat(QtCl).DelIfIn(QtId); }
888    GetQt(QtId).QtCIdTy = TQuote::TQtIdTy(NewCId, qtInClust);
889    ClustQtIdVH.AddDat(NewCId).Add(QtId);
890  }
891  void TQuoteBs::Mergec2Clusters(const int& ParentCId, const int& ChildCId) {
892    IAssert(IsClust(ParentCId) && IsClust(ChildCId));
893    printf("merging %d (fq: %d) to %d (%d fq)\n", ChildCId, GetClustFq(ChildCId), ParentCId, GetClustFq(ParentCId));
894    TIntSet ClustSet;
895    { const TIntV& ClustV = GetClust(ParentCId);
896    for (int c = 0; c < ClustV.Len(); c++) {
897      ClustSet.AddKey(ClustV[c]); } }
898    { const TIntV& ClustV = GetClust(ChildCId);
899    for (int c = 0; c < ClustV.Len(); c++) {
900      ClustSet.AddKey(ClustV[c]); } }
901    ClustSet.GetKeyV(ClustQtIdVH.GetDat(ParentCId));
902    GetQt(ChildCId).QtCIdTy = TQuote::TQtIdTy(ChildCId, qtInClust);
903    ClustQtIdVH.DelKey(ChildCId);
904    ClustQtIdVH.Defrag();
905  }
906  PClustNet TQuoteBs::GetClustNet(const int& MinQtFq, const TStr& OutFNmPref) const {
907    printf("Cluster quotes with Fq >= %d: %d total quotes\n", MinQtFq, Len());
908    TExeTm ExeTm;
909    TStrHash<TInt> StrH;
910    FILE *F = fopen(TStr(OutFNmPref+"-candidates.txt").CStr(), "wt");
911    THash<TInt, TIntV> QWIdVH;  
912    { TIntPrV LenQIdV;  TIntV QWIdV;
913    printf("sort qid by len\n");
914    for (int q1 = 0; q1 < Len(); q1++) {
915      const TQuote& Q = GetQtN(q1);
916      const int Doms = Q.GetDoms(*this);
917      if ((Q.GetTy()!=qtCentr) && Doms>1 && Doms*4 > Q.GetUrls() && Q.GetFq() >= MinQtFq) { 
918        LenQIdV.Add(TIntPr(TStrUtil::CountWords(Q.QtStr.CStr()), GetQtId(q1)));
919      }
920    }
921    printf("sort %d candidates by word length\n", LenQIdV.Len());
922    LenQIdV.Sort(false);
923    for (int q1 = 0; q1 < LenQIdV.Len(); q1++) {
924      TStrUtil::GetAddWIdV(StrH, GetQt(LenQIdV[q1].Val2).QtStr.CStr(), QWIdV);
925      QWIdVH.AddDat(LenQIdV[q1].Val2, QWIdV);
926      fprintf(F, "%s\n", GetQt(LenQIdV[q1].Val2).QtStr.CStr());
927    } }
928    printf("  %d root quotes\n", ClustQtIdVH.Len());
929    printf("  %d quotes to merge\n", QWIdVH.Len());
930    const int ClusterQ=QWIdVH.Len();
931    PClustNet ClustNet = TClustNet::New();
932    TIntH NIdDepthH;
933    TIntSet SeenQtIdSet;
934    int NMerges=0, idx1=0, idx2=0, SkipTy=0; 
935    for (int q1 = 0; q1 < ClusterQ; q1++) { 
936      SeenQtIdSet.Clr(false);
937      const int Qt1Id = QWIdVH.GetKey(q1);
938      for (int q2 = q1-1; q2 >= 0; q2--) { 
939        const int Qt2Id = QWIdVH.GetKey(q2);
940        if (SeenQtIdSet.IsKey(Qt2Id)) { continue; }
941        bool DoMerge = false;
942        const int Overlap = LongestCmnSubSq(QWIdVH[q1], QWIdVH[q2], idx1, idx2, SkipTy);
943        const int ShortLen = QWIdVH[q1].Len(); IAssert(QWIdVH[q1].Len()<= QWIdVH[q2].Len());
944        if (ShortLen == 4 && Overlap == 4) { DoMerge=true; } 
945        else if (ShortLen == 5 && Overlap == 5) { DoMerge=true; } 
946        else if (ShortLen == 6 && Overlap >= 5) { DoMerge=true; }
947        else if (Overlap/double(ShortLen+3) > 0.5 || Overlap > 10) { DoMerge=true; }
948        if (DoMerge==true) { NMerges++;
949          if (! ClustNet->IsNode(Qt1Id)) { ClustNet->AddNode(Qt1Id, GetQt(Qt1Id)); }
950          if (! ClustNet->IsNode(Qt2Id)) { ClustNet->AddNode(Qt2Id, GetQt(Qt2Id)); }
951          ClustNet->AddEdge(Qt1Id, Qt2Id);
952          SeenQtIdSet.AddKey(Qt1Id);  SeenQtIdSet.AddKey(Qt2Id);
953          fprintf(F, "%d Merge\t%d\t%d\ttree\t%d\n\t%s\n\t%s\n", q1, QWIdVH[q1].Len(), QWIdVH[q2].Len(), NIdDepthH.Len(), GetQt(Qt2Id).GetStr().CStr(), GetQt(Qt1Id).GetStr().CStr());
954          fflush(F);
955        }
956      }
957      if (q1>0 && q1 % 100 == 0) {
958        printf("\r  %d/%d: %d merged [%s]  ", q1, ClusterQ, NMerges, ExeTm.GetStr());
959        if (q1 % 1000 == 0) {
960          printf("save: %d merges, %d nodes, %d edges in ClustNet [%s]\n.", NMerges, ClustNet->GetNodes(), ClustNet->GetEdges(), ExeTm.GetStr());
961          TFOut FOut(OutFNmPref+".ClustNet"); ClustNet->Save(FOut); }
962      }
963    }
964    fclose(F);
965    printf("\n%d merges, %d nodes, %d edges in ClustNet [%s]\n\n.", NMerges, ClustNet->GetNodes(), ClustNet->GetEdges(), ExeTm.GetStr());
966    return ClustNet;
967  }
968  void TQuoteBs::AddMergedQtsToQtBs() {
969    printf("merge quote clusters and add them to the quote base\n");
970    TQuote MergedQt;
971    int toDel = ClustQtIdVH.Len();
972    for (int q = 0; q < QuoteH.Len(); q++) {
973      if (QuoteH[q].GetFq() == 1) { QuoteH.DelKeyId(q); toDel--; }
974      if (toDel == 0) { break; }
975    }
976    for (int q = 0; q < ClustQtIdVH.Len(); q++) {
977      GetMergedClustQt(ClustQtIdVH.GetKey(q), MergedQt);
978      IAssert(MergedQt.TmUrlCntV.Len() > 0); 
979      QuoteH.AddDat(QuoteH.Len(), MergedQt); 
980    }
981    printf("IsKeyIdEqKeyN: %s\n", QuoteH.IsKeyIdEqKeyN()?"T":"F");
982  }
983  PQuoteBs TQuoteBs::GetMergeClusters(const bool& OnlyClusters) const {
984    printf("Merging clusters into single quotes:\n");
985    PQuoteBs NewQtBs = TQuoteBs::New();
986    TQuote MergedQt;
987    printf("  %d quotes total\n", Len());
988    printf("  %d clusters\n", ClustQtIdVH.Len());
989    TIntSet SeenQtIdSet;
990    for (int q = 0; q < ClustQtIdVH.Len(); q++) {
991      GetMergedClustQt(ClustQtIdVH.GetKey(q), MergedQt);
992      IAssert(MergedQt.TmUrlCntV.Len() >0);
993      NewQtBs->AddQuote(MergedQt, *this);
994      const TIntV& ClustQtIdV = ClustQtIdVH[q];
995      for (int c = 0; c < ClustQtIdV.Len(); c++) {
996        const int qid = ClustQtIdV[c];
997        IAssert(! SeenQtIdSet.IsKey(qid)); 
998        SeenQtIdSet.AddKey(qid);
999      }
1000    }
1001    if (! OnlyClusters) {
1002      for (int q = 0; q < Len(); q++) {
1003        const TQuote& Q = GetQtN(q);
1004        if (! SeenQtIdSet.IsKey(GetQtId(q))) {
1005          NewQtBs->AddQuote(Q, *this); }
1006      }
1007    }
1008    printf("  %d quotes in new Quotes base\n", NewQtBs->Len());
1009    return NewQtBs;
1010  }
1011  void TQuoteBs::GetTopQtDoms(TStrIntPrV& DomCntV, const int& TakeNClust, const int& MinClFq, const TStr& RootHasWord, const TUrlTy& OnlyCountTy) const {
1012    TIntV CIdV;
1013    GetCIdVByFq(CIdV, MinClFq, RootHasWord, OnlyCountTy);
1014    THash<TStr, TInt> DomCntH;
1015    for (int c = 0; c < TMath::Mn(CIdV.Len(), TakeNClust); c++) {
1016      const TIntV& ClustV = GetClust(CIdV[c]);
1017      for (int q = 0; q < ClustV.Len(); q++) {
1018        const TQuote& Q = GetQt(ClustV[q]);
1019        for (int u = 0; u < Q.TmUrlCntV.Len(); u++) {
1020          DomCntH.AddDat(TStrUtil::GetDomNm(GetStr(Q.TmUrlCntV[u].UrlId()))) += 1;
1021        }
1022      }
1023    }
1024    DomCntH.SortByDat(false);
1025    DomCntH.GetKeyDatPrV(DomCntV);
1026  }
1027  void TQuoteBs::TopDomsByLag(const TTmUnit& TmUnit, const int& TakeNDoms, const int& TakeNClusts, const int& Thresh) const {
1028    THash<TStr, TMom> DomLagH;
1029    TIntV CIdV;  GetCIdVByFq(CIdV, 10, "", utUndef);
1030    TStrIntPrV DomCntV;  GetTopQtDoms(DomCntV, TakeNClusts, 10, "", utUndef);
1031    printf("Take %d clusters, %d domains", TakeNClusts, TakeNDoms);
1032    for (int d = 0; d < TMath::Mn(TakeNDoms, DomCntV.Len()); d++) {
1033      DomLagH.AddDat(DomCntV[d].Val1);
1034      printf("%d\t%s\n", DomCntV[d].Val2(), DomCntV[d].Val1.CStr());
1035    }
1036    int NQuotes=0;
1037    for (int c = 0; c < TMath::Mn(CIdV.Len(), TakeNClusts); c++) {
1038      TQuote Q;  GetMergedClustQt(CIdV[c], Q, false);
1039      const TSecTm MedTm = Q.GetMedianTm(TmUnit, utUndef, *this).Round(TmUnit);
1040      TStrSet DomSet;
1041      for (int u = 0; u < Q.TmUrlCntV.Len(); u++) {
1042        IAssert(IsStrId(Q.TmUrlCntV[u].UrlId()));
1043        const TStr Dom = TStrUtil::GetDomNm(GetStr(Q.TmUrlCntV[u].UrlId()));
1044        if (DomSet.IsKey(Dom)) { continue; } 
1045        if (! DomLagH.IsKey(Dom)) { continue; }
1046        DomLagH.AddDat(Dom).Add((int(Q.TmUrlCntV[u].Tm().Round(TmUnit))-int(MedTm))/3600.0);
1047        DomSet.AddKey(Dom);
1048      }
1049      NQuotes += GetClust(CIdV[c]).Len();
1050    }
1051    FILE *F = fopen(TStr::Fmt("domsByLag-clust%d.tab", TakeNClusts).CStr(), "wt");
1052    fprintf(F, "Top clusters: %d, total quotes in top clusters: %d\n", TakeNClusts, NQuotes);
1053    TFltFltStrTrV MedLagDomV;
1054    for (int i = 0; i < DomLagH.Len(); i++) {
1055      DomLagH[i].Def();
1056      MedLagDomV.Add(TFltFltStrTr(DomLagH[i].GetMedian(), DomLagH[i].GetVals(), DomLagH.GetKey(i)));
1057    }
1058    MedLagDomV.Sort();
1059    fprintf(F, "AGGREGATE PEAK\nTop domains with least lag (out of top %d considered) that mention at least 10 pct of top %d quotes (clusters) :\n", TakeNDoms, TakeNClusts);
1060    for (int i = 0; i < MedLagDomV.Len(); i++) {
1061      if (MedLagDomV[i].Val2() < Thresh*TakeNClusts/100.0) { continue; }
1062      fprintf(F, "%g\t%g\t%s\n", MedLagDomV[i].Val1(), MedLagDomV[i].Val2(), MedLagDomV[i].Val3.CStr());
1063    }
1064    fclose(F);
1065  }
1066  void TQuoteBs::PlotQtFqCnt(const TStr& OutFNmPref) const {
1067    TIntH UrlCntH, DomCntH, CntFqH;
1068    THashSet<TChA> DomSet;
1069    for (int q = 0; q < QuoteH.Len(); q++) {
1070      const TQuote& Q = GetQtN(q);
1071      UrlCntH.AddDat(Q.GetUrls()) += 1;
1072      CntFqH.AddDat(Q.GetFq()) += 1;
1073      DomSet.Clr(false);
1074      for (int u = 0; u < Q.GetUrls(); u++) {
1075        DomSet.AddKey(TStrUtil::GetDomNm(GetStr(Q.TmUrlCntV[u].UrlId()))); }
1076      DomCntH.AddDat(DomSet.Len()) += 1;
1077    }
1078    TGnuPlot::PlotValCntH(UrlCntH, OutFNmPref+"-url", "", "number of urls quote appears at", "count", gpsLog10XY);
1079    TGnuPlot::PlotValCntH(DomCntH, OutFNmPref+"-dom", "", "number of domains quote appears at", "count", gpsLog10XY);
1080    TGnuPlot::PlotValCntH(CntFqH, OutFNmPref+"-fq", "", "number of times quote appears", "count", gpsLog10XY);
1081  }
1082  void TQuoteBs::PlotQtMediaVsBlogFq(const int& QtId, const TStr& OutFNmPref) const {
1083    TQuote::TTmFltPrV BlogFqV, MediaFqV, SmoothV;
1084    TFltPrV FqV;
1085    const TQuote& ClQt = GetQt(QtId);
1086    ClQt.GetFqOt(BlogFqV, tmu4Hour, utBlog, *this);
1087    ClQt.GetFqOt(MediaFqV, tmu4Hour, utMedia, *this);
1088    const TSecTm MinTm = ClQt.TmUrlCntV[0].Tm().Round(tmuDay);
1089    TGnuPlot GP("mediaVsBlogs-"+OutFNmPref, TStr::Fmt("%s. b:%d m:%d u:%d d:%d", ClQt.GetStr().CStr(),
1090      ClQt.GetFq(utBlog, *this), ClQt.GetFq(utMedia, *this), ClQt.GetUrls(), ClQt.GetDoms(*this)));
1091    TQuote::GetSmoothFqOt(SmoothV, BlogFqV, tmu4Hour, 24, 1.2, MinTm);
1092    for (int i = 0; i < SmoothV.Len(); i++) {
1093      FqV.Add(TFltPr(double(SmoothV[i].Val1-MinTm)/(24.0*3600.0), SmoothV[i].Val2())); }
1094    GP.AddPlot(FqV, gpwLines, "Blog frequency");
1095    TQuote::GetSmoothFqOt(SmoothV, MediaFqV, tmu4Hour, 24, 1.2, MinTm);
1096    FqV.Clr();
1097    for (int i = 0; i < SmoothV.Len(); i++) {
1098      IAssert(SmoothV[i].Val1>=MinTm);
1099      FqV.Add(TFltPr(double(SmoothV[i].Val1-MinTm)/(24.0*3600.0)*(54.0/46.0), SmoothV[i].Val2()));
1100    }
1101    GP.AddPlot(FqV, gpwLines, "Media frequency");
1102    GP.SetXYLabel(TStr::Fmt("time [days] since %s", MinTm.GetYmdTmStr().CStr()), "Quote frequency (normalized for the baseline 46 vs 54)");
1103    GP.SavePng();
1104  }
1105  int NormMaxTo1(const TQuote::TTmFltPrV& TmFqV, TFltPrV& OutV, const TSecTm& BegTm) {
1106    int Idx=0;
1107    double MaxVal=0;
1108    for (int i = 0; i < TmFqV.Len(); i++) {
1109      if (MaxVal < TmFqV[i].Val2) {
1110        MaxVal=TmFqV[i].Val2; Idx = i; }
1111    }
1112    OutV.Gen(TmFqV.Len(), 0);
1113    for (int i = 0; i < TmFqV.Len(); i++) {
1114      OutV.Add(TFltPr(double(TmFqV[i].Val1-BegTm)/(24.0*3600.0), TmFqV[i].Val2())); 
1115    }
1116    return Idx;
1117  }
1118  void TQuoteBs::PlotClustMediaVsBlogFq(const int& CId, const TStr& OutFNmPref) const {
1119    const TTmUnit TmUnit = tmu4Hour;
1120    TQuote::TTmFltPrV BlogFqV, MediaFqV, AllFqV, SmoothV;
1121    TFltPrV FqV, RawFqV;
1122    TQuote ClQt;
1123    GetMergedClustQt(CId, ClQt, false);
1124    ClQt.GetFqOt(BlogFqV, TmUnit, utBlog, *this);
1125    ClQt.GetFqOt(MediaFqV, TmUnit, utMedia, *this);
1126    const TSecTm MinTm = ClQt.TmUrlCntV[0].Tm().Round(tmuDay);
1127    const TSecTm  MediaPeak = ClQt.GetPeakTm(TmUnit, TSecTm(1), utMedia, *this);
1128    const TSecTm BlogPeak = ClQt.GetPeakTm(TmUnit, TSecTm(1), utBlog, *this);
1129    const int Lag = (int(BlogPeak.Round(TmUnit))-int(MediaPeak.Round(TmUnit)))/3600;
1130    const bool Is1Peak = ClQt.IsSinglePeak(TmUnit, TSecTm(1), utUndef, *this);
1131    TGnuPlot GP("mediaVsBlogs-"+OutFNmPref, TStr::Fmt("%s. b:%d m:%d u:%d d:%d", Is1Peak?"SINGLE PEAK": "MORE PEAKS", 
1132      Lag, ClQt.GetFq(utBlog, *this), ClQt.GetFq(utMedia, *this), ClQt.GetUrls(), ClQt.GetDoms(*this)));
1133    int mx = NormMaxTo1(BlogFqV, RawFqV, MinTm);
1134    TQuote::GetSmoothFqOt(SmoothV, BlogFqV, TmUnit, 2*24, 1.2, MinTm);
1135    mx = NormMaxTo1(SmoothV, FqV, MinTm);
1136    GP.AddPlot(FqV, gpwLines, TStr::Fmt("SMOOTH Blog : max %s", SmoothV[mx].Val1.GetYmdTmStr().CStr()), "pt 7 ps 1");
1137    const TSecTm SmBlog = SmoothV[mx].Val1;
1138    mx = NormMaxTo1(MediaFqV, RawFqV, MinTm);
1139    TQuote::GetSmoothFqOt(SmoothV, MediaFqV, TmUnit, 2*24, 1.2, MinTm);
1140    mx = NormMaxTo1(SmoothV, FqV, MinTm);
1141    const TSecTm SmMed = SmoothV[mx].Val1;
1142    const int SmLag = (int(SmBlog.Round(TmUnit))-int(SmMed.Round(TmUnit)))/3600;
1143    GP.AddPlot(FqV, gpwLines, TStr::Fmt("SMOOTH Media is behind: %dh, smooth: %dh.", -Lag, -SmLag), "pt 5 ps 1");
1144    GP.SetXYLabel(TStr::Fmt("time [days] since %s", MinTm.GetYmdTmStr().CStr()), "Cluster frequency (normalized for the baseline 46 vs 54)");
1145    GP.AddCmd("set xtics 10");
1146    GP.AddCmd("set mxtics 10");
1147    GP.SavePng();
1148  }
1149  void TQuoteBs::PlotMediaVsBlogLag(const TTmUnit& TmUnit, const bool& TakeClusters, const int& TakeN, const TStr& OutFNmPref) const {
1150    TQuote Qt;  TIntV IdV;
1151    TMom LagMom1d, LagMom2d, LagMom3d, LagMom4d, LagMom7d;
1152    TFltFltH LagCntH, LagBCntH, LagMCntH;
1153    int Cnt=0;
1154    if (TakeClusters) { GetCIdVByFq(IdV, 10, "", utUndef, false); }
1155    else { GetQtIdVByFq(IdV, 8, 10, false, "", "", utUndef); }
1156    for (int c = 0; c < TakeN; c++) {
1157      if (TakeClusters) { GetMergedClustQt(IdV[c], Qt, false); }
1158      else { Qt = GetQt(IdV[c]); }
1159      const TSecTm  AllPeak = Qt.GetMedianTm(TmUnit, utUndef, *this);
1160      const TSecTm BlogPeak = Qt.GetMedianTm(TmUnit, utBlog, *this);
1161      const TSecTm  MediaPeak = Qt.GetMedianTm(TmUnit, utMedia, *this);
1162      const double Lag = (int(BlogPeak.Round(TmUnit))-int(MediaPeak.Round(TmUnit)))/3600.0;
1163      const double Lag1 = (int(BlogPeak.Round(TmUnit))-int(AllPeak.Round(TmUnit)))/3600.0;
1164      const double Lag2 = (int(MediaPeak.Round(TmUnit))-int(AllPeak.Round(TmUnit)))/3600.0;
1165      if (fabs(Lag) < 1*24) { LagMom1d.Add(Lag); }
1166      if (fabs(Lag) < 2*24) { LagMom2d.Add(Lag); }
1167      if (fabs(Lag) < 3*24) { LagMom3d.Add(Lag); }
1168      if (fabs(Lag) < 4*24) { LagMom4d.Add(Lag); }
1169      if (fabs(Lag) < 7*24) { LagMom7d.Add(Lag); }
1170      LagCntH.AddDat(Lag) += 1;
1171      LagBCntH.AddDat(Lag1) += 1;
1172      LagMCntH.AddDat(Lag2) += 1;
1173      Cnt++;
1174    }
1175    TFltPrV PrV;
1176    LagMom1d.Def();  LagMom2d.Def();  LagMom3d.Def();  LagMom4d.Def();  LagMom7d.Def();
1177    { TGnuPlot GP("lagBlogsVsMedia-"+OutFNmPref, TStr::Fmt("Lag: 1D: %.2f %g;   2D: %.2f  %g;   3D: %.2f  %g;   4D: %.2f  %g;   7D: %.2f  %g",
1178      LagMom1d.GetMean(), LagMom1d.GetMedian(), LagMom2d.GetMean(), LagMom2d.GetMedian(), LagMom3d.GetMean(), LagMom3d.GetMedian(),
1179      LagMom4d.GetMean(), LagMom4d.GetMedian(), LagMom7d.GetMean(), LagMom7d.GetMedian()), true);
1180    LagBCntH.GetKeyDatPrV(PrV); PrV.Sort(); GP.AddPlot(PrV, gpwLinesPoints, TStr::Fmt("%s. b:%d m:%d u:%d d:%d BLOG", Qt.GetStr().CStr(),
1181      Qt.GetFq(utBlog, *this), Qt.GetFq(utMedia, *this), Qt.GetUrls(), Qt.GetDoms(*this)));
1182    LagMCntH.GetKeyDatPrV(PrV); PrV.Sort(); GP.AddPlot(PrV, gpwLinesPoints, TStr::Fmt("%s. b:%d m:%d u:%d d:%d MEDIA", Qt.GetStr().CStr(),
1183      Qt.GetFq(utBlog, *this), Qt.GetFq(utMedia, *this), Qt.GetUrls(), Qt.GetDoms(*this)));
1184    GP.AddCmd("set xrange[-24:24]\nset mxtics 5\nset xtics 5");
1185    GP.SetXYLabel("media lag in hours (+: news lag, -: news lead)", "count");
1186    GP.SavePng(); }
1187    printf("\nTake top %d clusters. TmUnit: %s\n", TakeN, TTmInfo::GetTmUnitStr(TmUnit).CStr());
1188    printf("  1d:\tavg:\t%f\tmed:\t%f\n", LagMom1d.GetMean(), LagMom1d.GetMedian());
1189    printf("  2d:\tavg:\t%f\tmed:\t%f\n", LagMom2d.GetMean(), LagMom2d.GetMedian());
1190    printf("  3d:\tavg:\t%f\tmed:\t%f\n", LagMom3d.GetMean(), LagMom3d.GetMedian());
1191    printf("  4d:\tavg:\t%f\tmed:\t%f\n", LagMom4d.GetMean(), LagMom4d.GetMedian());
1192    printf("  7d:\tavg:\t%f\tmed:\t%f\n", LagMom7d.GetMean(), LagMom7d.GetMedian());
1193  }
1194  void TQuoteBs::PlotFqDecay(const TTmUnit& TmUnit, const bool& TakeClusters, const TUrlTy& CntUrlTy, const int& PlotN, const int& MinValsPerTm, const TStr& OutFNmPref) const {
1195    THash<TFlt, TMom> MomH;
1196    TQuote Qt;
1197    TIntV IdV;
1198    TGnuPlot GP("decay-"+OutFNmPref);
1199    if (TakeClusters) { GetCIdVByFq(IdV, 10, "", CntUrlTy, false); }
1200    else { GetQtIdVByFq(IdV, 8, 10, false, "", "", CntUrlTy); }
1201    for (int c = 0; c < PlotN; c++) {
1202      if (TakeClusters) { GetMergedClustQt(IdV[c], Qt, false); }
1203      else { Qt = GetQt(IdV[c]); }
1204      TQuote::TTmFltPrV QtV;  TFltPrV TmV;
1205      Qt.GetFqOt(QtV, TmUnit);
1206      int pos=0;  double val=0.0;
1207      for (int i = 0; i < QtV.Len(); i++) {
1208        if (val < QtV[i].Val2) { pos = i;  val = QtV[i].Val2; }
1209      }
1210      const double PeakVal = val;
1211      const TSecTm PeakTm = QtV[pos].Val1;
1212      for (int i = 0; i < QtV.Len(); i++) {
1213        TmV.Add(TFltPr((double(QtV[i].Val1)-double(PeakTm))/(24.0*3600), QtV[i].Val2/PeakVal));
1214        MomH.AddDat(TmV.Last().Val1).Add(TmV.Last().Val2);
1215      }
1216      const TStr Label = "";
1217    }
1218    TFltPrV AvgV, MedV;
1219    MomH.SortByKey();
1220    for (int i = 0; i < MomH.Len(); i++) {
1221      MomH[i].Def();
1222      if (MomH[i].GetVals()< MinValsPerTm) { printf("."); continue; }
1223      AvgV.Add(TFltPr(MomH.GetKey(i), MomH[i].GetMean()));
1224      MedV.Add(TFltPr(MomH.GetKey(i), MomH[i].GetMedian()));
1225    }
1226    GP.AddPlot(AvgV, gpwLines, "Average", "lt 2 lw 2");
1227    GP.AddPlot(MedV, gpwLines, TStr::Fmt("Median (last qt: %d %d %d)", Qt.GetFq(), Qt.GetUrls(), Qt.GetDoms(*this)), "lt 1 lw 2");
1228    GP.SetXYLabel("time [days]", "count");
1229    GP.AddCmd("set mxtics 6");
1230    GP.AddCmd("set xtics 1");
1231    GP.AddCmd("set yrange [0:1]");
1232    GP.AddCmd("set xrange [-5:5]");
1233    GP.AddCmd("set yzeroaxis lt -1");
1234    GP.SavePng();
1235  }
1236  void NormPeakAt1(THash<TInt, TFlt>& H) {
1237    double PeakFq=1;
1238    for (int i = 0; i < H.Len(); i++) {
1239      PeakFq=TMath::Mx((double)H[i], PeakFq); }
1240    for (int i = 0; i < H.Len(); i++) {
1241      H[i]/=PeakFq; }
1242  }
1243  void TQuoteBs::PlotBlogVsMediaFqOt(const TTmUnit& TmUnit, const bool& TakeClusters, int PlotN, const TStr& OutFNmPref) const {
1244    THash<TInt, TFlt> Peak1AllH, Peak2AllH, Peak3AllH;
1245    THash<TInt, TFlt> Peak1MedH, Peak2MedH, Peak3MedH;
1246    THash<TInt, TFlt> Peak1BlogH, Peak2BlogH, Peak3BlogH;
1247    TQuote Qt;
1248    TIntV IdV;
1249    TInt FqAtPeak;
1250    if (TakeClusters) { GetCIdVByFq(IdV, 100, "", utUndef, false); }
1251    else { GetQtIdVByFq(IdV, 8, 10, false, "", "", utUndef); }
1252    for (int c = 0; c < TMath::Mn(PlotN, IdV.Len()); c++) {
1253      if (TakeClusters) { GetMergedClustQt(IdV[c], Qt, false); }
1254      else { Qt = GetQt(IdV[c]); }
1255      if (! Qt.IsSinglePeak(TmUnit, TSecTm(0), utUndef, *this)) { PlotN++; printf("."); continue; }
1256      TQuote::TTmFltPrV AllFqV, BlogFqV, MedFqV;  TFltPrV TmV;
1257      const double Peak1 = Qt.GetPeakTm(TmUnit, TSecTm(1), FqAtPeak).GetAbsSecs(); 
1258      const double Peak2 = Qt.GetMeanTm(TmUnit, utUndef, *this).GetAbsSecs();    
1259      const double Peak3 = Qt.GetMedianTm(TmUnit, utUndef, *this).GetAbsSecs();  
1260      double PeakFq = FqAtPeak;
1261      Qt.GetFqOt(AllFqV, TmUnit, utUndef, *this);
1262      Qt.GetFqOt(MedFqV, TmUnit, utMedia, *this);
1263      Qt.GetFqOt(BlogFqV, TmUnit, utBlog, *this);
1264      PeakFq=1;
1265      for (int i = 0; i < MedFqV.Len(); i++) { PeakFq=TMath::Mx((double)MedFqV[i].Val2(), PeakFq); }
1266      for (int i = 0; i < MedFqV.Len(); i++) {
1267        const int T1 = (int) TMath::Round((double(MedFqV[i].Val1.GetAbsSecs())-Peak1)/(3600.0));
1268        const int T2 = (int) TMath::Round((double(MedFqV[i].Val1.GetAbsSecs())-Peak2)/(3600.0));
1269        const int T3 = (int) TMath::Round((double(MedFqV[i].Val1.GetAbsSecs())-Peak3)/(3600.0));
1270        Peak1MedH.AddDat(T1) += MedFqV[i].Val2/PeakFq;
1271        Peak2MedH.AddDat(T2) += MedFqV[i].Val2/PeakFq;
1272        Peak3MedH.AddDat(T3) += MedFqV[i].Val2/PeakFq;
1273      }
1274      PeakFq=1;
1275      for (int i = 0; i < BlogFqV.Len(); i++) { PeakFq=TMath::Mx((double)BlogFqV[i].Val2(), PeakFq); }
1276      for (int i = 0; i < BlogFqV.Len(); i++) {
1277        const int T1 = (int) TMath::Round((double(BlogFqV[i].Val1.GetAbsSecs())-Peak1)/(3600.0));
1278        const int T2 = (int) TMath::Round((double(BlogFqV[i].Val1.GetAbsSecs())-Peak2)/(3600.0));
1279        const int T3 = (int) TMath::Round((double(BlogFqV[i].Val1.GetAbsSecs())-Peak3)/(3600.0));
1280        Peak1BlogH.AddDat(T1) += BlogFqV[i].Val2/PeakFq;
1281        Peak2BlogH.AddDat(T2) += BlogFqV[i].Val2/PeakFq;
1282        Peak3BlogH.AddDat(T3) += BlogFqV[i].Val2/PeakFq;
1283      }
1284    }
1285    NormPeakAt1(Peak1AllH); NormPeakAt1(Peak2AllH); NormPeakAt1(Peak3AllH);
1286    NormPeakAt1(Peak1MedH); NormPeakAt1(Peak2MedH); NormPeakAt1(Peak3MedH);
1287    NormPeakAt1(Peak1BlogH); NormPeakAt1(Peak2BlogH); NormPeakAt1(Peak3BlogH);
1288    TGnuPlot::PlotValCntH(Peak1AllH, "ALL", Peak1MedH, "MEDIA", Peak1BlogH, "BLOG", "peakMax-"+OutFNmPref, "Max is the peak", "Time [h]", "Count (sum of frequencies of all quotes)");
1289    TGnuPlot::PlotValCntH(Peak3AllH, "ALL", Peak3MedH, "MEDIA", Peak3BlogH, "BLOG", "peakMed-"+OutFNmPref, "Median is the peak", "Time [h]", "Count (sum of frequencies of all quotes)");
1290  }
1291  void TQuoteBs::PlotBlogFracOt(const TTmUnit& TmUnit, const bool& TakeClusters, const int& PlotN, const TStr& OutFNmPref) const {
1292    TQuote Qt;
1293    TIntV IdV;
1294    THash<TFlt, TMom> TmMomH;
1295    THash<TFlt, TFltPr> TmBmH;
1296    if (TakeClusters) { GetCIdVByFq(IdV, 10, "", utUndef, false); }
1297    else { GetQtIdVByFq(IdV, 8, 10, false, "", "", utUndef); }
1298    for (int c = 0; c < PlotN; c++) {
1299      if (TakeClusters) { GetMergedClustQt(IdV[c], Qt, false); }
1300      else { Qt = GetQt(IdV[c]); }
1301      TQuote::TTmFltPrV MedQtV, BlgQtV;
1302      Qt.GetFqOt(MedQtV, TmUnit, utMedia, *this);
1303      Qt.GetFqOt(BlgQtV, TmUnit, utBlog, *this);
1304      TFltPrV FracV;
1305      const int PeakTm = Qt.GetPeakTm(TmUnit, TSecTm(1), utUndef, *this);
1306      for (int m=0, b=0; m < MedQtV.Len(); m++) {
1307        while (b<BlgQtV.Len() && BlgQtV[b].Val1 < MedQtV[m].Val1) { b++; }
1308        if (b<BlgQtV.Len() && BlgQtV[b].Val1 == MedQtV[m].Val1) {
1309          const double Tm = (int(MedQtV[m].Val1.Round(TmUnit))-PeakTm)/(24*3600.0);
1310            const double Frac = BlgQtV[b].Val2/double(BlgQtV[b].Val2+MedQtV[m].Val2);
1311            FracV.Add(TFltPr(Tm, Frac));
1312            TmMomH.AddDat(Tm).Add(Frac);
1313          TFltPr& BM = TmBmH.AddDat(Tm);
1314          BM.Val1+= BlgQtV[b].Val2;
1315          BM.Val2+= MedQtV[m].Val2;
1316        }
1317      }
1318    }
1319    { TFltPrV PrV;
1320    for (int b = 0; b < TmMomH.Len(); b++) {
1321      TmMomH[b].Def();
1322      PrV.Add(TFltPr(TmMomH.GetKey(b), TmMomH[b].GetMean())); }
1323    TGnuPlot GP(TStr::Fmt("fqFracA-%s", OutFNmPref.CStr()));
1324    PrV.Sort();  GP.AddPlot(PrV, gpwLinesPoints);
1325    GP.AddCmd("set xrange [-7:7]\nset yzeroaxis lt -1"); GP.SavePng(); }
1326    { TFltPrV PrV;
1327    for (int b = 0; b < TmMomH.Len(); b++) {
1328      PrV.Add(TFltPr(TmMomH.GetKey(b), TmMomH[b].GetMedian())); }
1329    TGnuPlot GP(TStr::Fmt("fqFracM-%s", OutFNmPref.CStr()));
1330    PrV.Sort();  GP.AddPlot(PrV, gpwLinesPoints);
1331    GP.AddCmd("set xrange [-7:7]\nset yzeroaxis lt -1"); GP.SavePng(); }
1332    { TFltPrV PrV;
1333    for (int b = 0; b < TmBmH.Len(); b++) {
1334      PrV.Add(TFltPr(TmBmH.GetKey(b), TmBmH[b].Val1/(TmBmH[b].Val1+TmBmH[b].Val2))); }
1335    TGnuPlot GP(TStr::Fmt("fqFracS-%s", OutFNmPref.CStr()));
1336    PrV.Sort(); GP.AddPlot(PrV, gpwLinesPoints);
1337    GP.AddCmd("set xrange [-7:7]\nset yzeroaxis lt -1"); GP.SavePng(); }
1338  }
1339  void TQuoteBs::PlotPopularityCnt(const bool& TakeClusters, const TUrlTy& UrlTy, const int& PlotN, const TStr& OutFNmPref) const {
1340    TIntV IdV;
1341    TIntH FqCntH;
1342    TQuote Qt;
1343    for (int c = 0; c < Len(); c++) {
1344      const TQuote& Qt = GetQtN(c);
1345      if (Qt.GetStr().IsStrIn("lipstick") && Qt.GetStr().IsStrIn("pig")) {
1346        FqCntH.AddDat(Qt.GetFq(UrlTy, *this)) += 1; }
1347    }
1348    TIntPrV FqCntV, CdfV;
1349    FqCntH.GetKeyDatPrV(FqCntV);  FqCntV.Sort();
1350    TGUtil::GetCCdf(FqCntV, CdfV);
1351    TGnuPlot::PlotValV(FqCntV, "pop-"+OutFNmPref, "", "total frequency", "count", gpsLog10XY);
1352    TGnuPlot::PlotValV(CdfV, "popCDF-"+OutFNmPref+"", "", "total frequency", "NCDF", gpsLog10XY);
1353  }
1354  void TQuoteBs::PlotEmptyY(const TTmUnit& TmUnit, const bool& TakeClusters, const int& PlotN, const TStr& OutFNmPref) const {
1355    TQuote Qt;
1356    TIntV IdV;
1357    THash<TInt, TInt> TmCumCntH;
1358    int MaxY=0;
1359    if (TakeClusters) { GetCIdVByFq(IdV, 10, "", utUndef, false); }
1360    else { GetQtIdVByFq(IdV, 8, 10, false, "", "", utUndef); }
1361    for (int c = 0; c < PlotN; c++) {
1362      if (TakeClusters) { GetMergedClustQt(IdV[c], Qt, false); }
1363      else { Qt = GetQt(IdV[c]); }
1364      TQuote::TTmFltPrV QtV;
1365      Qt.GetFqOt(QtV, TmUnit);
1366      for (int i = 0; i < QtV.Len(); i++) {
1367        const int Tm = QtV[i].Val1.Round(tmu1Hour)/3600;
1368        TInt& CumCnt = TmCumCntH.AddDat(Tm);
1369        CumCnt += (int) QtV[i].Val2;
1370        MaxY = TMath::Mx(CumCnt(), MaxY);
1371      }
1372    }
1373    TmCumCntH.SortByKey(true);
1374    const int BegHr = TmCumCntH.GetKey(0);
1375    THash<TFlt, TFlt> EmptyH;
1376    TFltPrV TmV;
1377    for (int t = 0; t < TmCumCntH.Len(); t++) {
1378      printf("%d  ", TmCumCntH[t]());
1379      for (int y = TmCumCntH[t]; y < MaxY; y+=1) {
1380        EmptyH.AddDat(y) += 1; }
1381      TmV.Add(TFltPr((TmCumCntH.GetKey(t)-BegHr)/24.0, TmCumCntH[t].Val));
1382    }
1383    EmptyH.SortByKey(false);
1384    TFltPrV EmptyV;
1385    EmptyV.Add(TFltPr(EmptyH.GetKey(0), EmptyH[0]));
1386    for (int i = 1; i < EmptyH.Len(); i++) {
1387      EmptyV.Add(TFltPr(EmptyH.GetKey(i), EmptyH[i]+EmptyV.Last().Val2));
1388    }
1389    TGnuPlot::PlotValCntH(EmptyH, "emptyF-"+OutFNmPref+"-d", "Amount of empty area above the cummulative query-frequency curve", "y value", "area at y");
1390    TGnuPlot::PlotValV(EmptyV, "emptyF-"+OutFNmPref+"-c", "Amount of empty area above the cummulative query-frequency curve", "y value", "area above y");
1391    TGnuPlot::PlotValV(TmV, "emptyF1"+OutFNmPref, "Cummulative query frequency over time", "time (days)", "frequency");
1392  }
1393  PNGraph TQuoteBs::GetQuotePostNet(const TStr& DatasetFNm) const {
1394    PNGraph Graph = TNGraph::New();
1395    for (TMemesDataLoader Memes(DatasetFNm); Memes.LoadNext(); ) {
1396      if (Memes.MemeV.Empty()) { continue; }
1397      if (! IsStr(Memes.PostUrlStr.CStr())) { continue; }
1398      const int SrcNId = GetStrId(Memes.PostUrlStr.CStr());
1399      for (int u = 0; u < Memes.LinkV.Len(); u++) {
1400        if (! IsStr(Memes.LinkV[u].CStr())) { continue; }
1401        const int DstNId = GetStrId(Memes.LinkV[u].CStr());
1402        if (! Graph->IsNode(SrcNId)) { Graph->AddNode(SrcNId); }
1403        if (! Graph->IsNode(DstNId)) { Graph->AddNode(DstNId); }
1404        Graph->AddEdge(SrcNId, DstNId);
1405      }
1406    }
1407    TSnap::PrintInfo(Graph);
1408    return Graph;
1409  }
1410  PQtDomNet TQuoteBs::GetQuoteDomNet(const PNGraph& PostGraph, const int& CId) const {
1411    TQuote Qt;  GetMergedClustQt(CId, Qt, false);
1412    PQtDomNet DomG = TQtDomNet::New();
1413    TIntSet UrlSet;
1414    for (int i = 0; i < Qt.GetTimes(); i++) { UrlSet.AddKey(Qt.GetUrlId(i)); }
1415    TStrSet DomH;
1416    for (int i = 0; i < Qt.GetTimes(); i++) {
1417      const int url = Qt.GetUrlId(i);
1418      if (! PostGraph->IsNode(url)) { continue; }
1419      const int dom = DomH.AddKey(TStrUtil::GetDomNm2(GetStr(url)));
1420      TNGraph::TNodeI NI = PostGraph->GetNI(url);
1421      for (int o = 0; o < NI.GetOutDeg(); o++) {
1422        if (! UrlSet.IsKey(NI.GetOutNId(o))) { continue; }
1423        const int url2 = NI.GetOutNId(o);
1424        const int dom2 = DomH.AddKey(TStrUtil::GetDomNm2(GetStr(url2)));
1425        if (dom==dom2) { continue; }
1426        if (! DomG->IsNode(dom)) {
1427          DomG->AddNode(dom, TPair<TStr, TInt>(DomH[dom], GetUrlTy(url))); }
1428        if (! DomG->IsNode(dom2)) {
1429          DomG->AddNode(dom2, TPair<TStr, TInt>(DomH[dom2], GetUrlTy(url2))); }
1430        if (DomG->IsEdge(dom, dom2)) {
1431          DomG->GetEDat(dom, dom2) += 1; }
1432        else {
1433          DomG->AddEdge(dom, dom2, 1); }
1434      }
1435    }
1436    return DomG;
1437  }
1438  void TQuoteBs::SaveQuotes(const int& MinQtFq, const TStr& OutFNm) const {
1439    TIntV QtIdV;
1440    GetQtIdVByFq(QtIdV, 0, MinQtFq);
1441    SaveQuotes(QtIdV, OutFNm);
1442  }
1443  void TQuoteBs::SaveQuotes(const TIntV& QtIdV, const TStr& OutFNm) const {
1444    TIntSet QtIdSet;
1445    FILE *F = fopen(OutFNm.CStr(), "wt");
1446    printf("saving %d quotes\n", QtIdV.Len());
1447    fprintf(F, "#Freq\tUrls\tDomains\tQuote\n");
1448    for (int q = 0; q < QtIdV.Len(); q++) {
1449      const int QtId = QtIdV[q];
1450      if (QtIdSet.IsKey(QtId)) { continue; } 
1451      QtIdSet.AddKey(QtId);
1452      const TQuote& Q = GetQt(QtId);
1453    fprintf(F, "%d\t%d\t%d\t%s\n", Q.GetFq(), Q.GetUrls(), Q.GetDoms(*this), Q.QtStr.CStr());
1454      if (Q.GetTy() == qtRoot || Q.GetTy() == qtCentr) { 
1455        IAssert(ClustQtIdVH.IsKey(Q.GetCId()));
1456        const TIntV& ClustV = ClustQtIdVH.GetDat(Q.GetCId());
1457        for (int i = 0; i < ClustV.Len(); i++) {
1458          const TQuote& Q1 = GetQt(ClustV[i]);
1459          fprintf(F, "\t[%d] %d=%d %s\t%d\t%d\t%d\n", TStrUtil::CountWords(Q1.QtStr.CStr()),
1460            ClustV[i](), Q1.GetCId(), Q1.QtStr.CStr(), Q1.GetFq(), Q1.GetUrls(), Q1.GetDoms(*this));
1461          QtIdSet.AddKey(ClustV[i]);
1462        }
1463      }
1464    }
1465    fclose(F);
1466  }
1467  void TQuoteBs::SaveClusters(const TStr& OutFNm, const bool& SkipUrls) const {
1468    TIntPrV FqCIdV;
1469    TIntH ClSzCntH, ClFqCntH;
1470    for (int c = 0; c < GetClusts(); c++) {
1471      const int CId = GetCId(c);
1472      if ( ! IsQtId(CId)) { printf("!!! %d:%d\n", c, CId); continue; }
1473      FqCIdV.Add(TIntPr(GetClustFq(CId), CId));
1474      ClSzCntH.AddDat(GetClust(CId).Len()) += 1;
1475      ClFqCntH.AddDat(GetClustFq(CId)) += 1;
1476    }
1477    TGnuPlot::PlotValCntH(ClSzCntH, OutFNm+"-clSz", TStr::Fmt("%d clusters", GetClusts()), "Number of quotes in the cluster", "Number of clusters", gpsLog);
1478    TGnuPlot::PlotValCntH(ClFqCntH, OutFNm+"-clFq", TStr::Fmt("%d clusters", GetClusts()), "Volume of quotes in the cluster", "Number of clusters", gpsLog, false, gpwLinesPoints, false, false);
1479    TGnuPlot::PlotValCntH(ClFqCntH, OutFNm+"-clFqB", TStr::Fmt("%d clusters", GetClusts()), "Volume of quotes in the cluster", "Number of clusters", gpsLog, false, gpwLinesPoints, false, true);
1480    FqCIdV.Sort(false);
1481    TIntPrV QtFqV;
1482    FILE *F = fopen(TStr::Fmt("%s-clust.txt", OutFNm.CStr()).CStr(), "wt");
1483    fprintf(F, "format:\n<ClSz>\t<TotFq>\t<Root>\t<ClusterId>\n");
1484    fprintf(F, "\t<QtFq>\t<Urls>\t<QtStr>\t<QuteId>\n");
1485    fprintf(F, "\t\t<Tm>\t<Fq>\t<UrlTy>\t<Url>\n\n");
1486    for (int c = 0; c < FqCIdV.Len(); c++) {
1487      const int CId = FqCIdV[c].Val2;
1488      const TIntV& ClustV = GetClust(CId);
1489      fprintf(F, "\n%d\t%d\t%s\t%d\n", ClustV.Len(), FqCIdV[c].Val1(), GetQt(CId).GetStr().CStr(), CId);
1490      QtFqV.Clr(false);
1491      for (int q = 0; q < ClustV.Len(); q++) {
1492        IAssert(IsQtId(ClustV[q]));
1493        QtFqV.Add(TIntPr(GetQt(ClustV[q]).GetUrls(), ClustV[q])); }
1494      QtFqV.Sort(false);
1495      for (int q = 0; q < QtFqV.Len(); q++) {
1496        IAssert(IsQtId(QtFqV[q].Val2));
1497        const TQuote& Qt = GetQt(QtFqV[q].Val2);
1498        if ((! SkipUrls) && q > 0) { fprintf(F, "\n"); }
1499        fprintf(F, "\t%d\t%d\t%s\t%d\n", Qt.GetFq(), Qt.GetUrls(), Qt.GetStr().CStr(), QtFqV[q].Val2());
1500        if (! SkipUrls) {
1501          for (int u = 0; u < Qt.GetUrls(); u++) {
1502            fprintf(F, "\t\t%s\t%d\t%s\t%s\n", Qt.TmUrlCntV[u].Tm().GetYmdTmStr().CStr(), Qt.TmUrlCntV[u].Cnt(),
1503              GetUrlTy(Qt.TmUrlCntV[u].UrlId())==utMedia?"M":"B", GetStr(Qt.TmUrlCntV[u].UrlId())); }
1504        }
1505      }
1506    }
1507    fclose(F);
1508  }
1509  void TQuoteBs::SaveClusters(const TIntV& QtIdV, const TStr& OutFNm, const bool& SkipUrls) const {
1510    FILE *F = fopen(TStr::Fmt("%s-clust.txt", OutFNm.CStr()).CStr(), "wt");
1511    fprintf(F, "format:\n<ClSz>\t<TotFq>\t<Root>\t<ClusterId>\n");
1512    fprintf(F, "\t<QtFq>\t<Urls>\t<QtStr>\t<QuteId>\n");
1513    fprintf(F, "\t\t<Tm>\t<Fq>\t<UrlTy>\t<Url>\n\n");
1514    for (int c = 0; c < QtIdV.Len(); c++) {
1515      int CId = QtIdV[c];
1516      if (! IsClust(CId)) { CId = GetQt(CId).GetCId(); }
1517      const TIntV& ClustV = GetClust(CId);
1518      fprintf(F, "\n%d\t%d\t%s\t%d\n", ClustV.Len(), GetClustFq(CId), GetQt(CId).GetStr().CStr(), CId);
1519      for (int q = 0; q < ClustV.Len(); q++) {
1520        const TQuote& Qt = GetQt(ClustV[q]);
1521        if ((! SkipUrls) && q > 0) { fprintf(F, "\n"); }
1522        fprintf(F, "\t%d\t%d\t%s\t%d\n", Qt.GetFq(), Qt.GetUrls(), Qt.GetStr().CStr(), ClustV[q]());
1523        if (! SkipUrls) {
1524          for (int u = 0; u < Qt.GetUrls(); u++) {
1525            fprintf(F, "\t\t%s\t%d\t%s\t%s\n", Qt.TmUrlCntV[u].Tm().GetYmdTmStr().CStr(), Qt.TmUrlCntV[u].Cnt(),
1526              GetUrlTy(Qt.TmUrlCntV[u].UrlId())==utMedia?"M":"B", GetStr(Qt.TmUrlCntV[u].UrlId())); }
1527        }
1528      }
1529    }
1530    fclose(F);
1531  }
1532  void TQuoteBs::SaveBigBlogMassQt(const TStr& OutFNm) const {
1533    const TTmUnit TmUnit = tmuDay;
1534    const bool TakeClusters = true;
1535    TIntV IdV;
1536    TQuote Qt;
1537    int Candidates=0;
1538    if (TakeClusters) { GetCIdVByFq(IdV, 10, "", utUndef, false); }
1539    else { GetQtIdVByFq(IdV, 8, 10, false, "", "", utUndef); }
1540    TVec<TPair<TFlt, TStr> > ScoreV;
1541    for (int c = 0; c < IdV.Len(); c++) {
1542      if (TakeClusters) { GetMergedClustQt(IdV[c], Qt, false); }
1543      else { Qt = GetQt(IdV[c]); }
1544      const int MediaPeak = Qt.GetPeakTm(TmUnit, TSecTm(1), utMedia, *this); 
1545      const double BlogFq = Qt.GetUrls(TSecTm(MediaPeak-21*24*3600), TSecTm(MediaPeak-7*24*3600), utBlog, *this);  
1546      const double TotFq = Qt.GetUrls();
1547      if (BlogFq < 10) { continue; }
1548      Candidates++;
1549      if (BlogFq < TotFq*0.15 || BlogFq > TotFq*0.75) { continue; }
1550      ScoreV.Add(TFltStrPr(TotFq, TStr::Fmt("%g\t%g\t%s", BlogFq, TotFq, Qt.GetStr().CStr())));
1551    }
1552    printf("Considered: %d quotes\n", IdV.Len());
1553    printf("            %d candidates\n", Candidates);
1554    printf("            %d selected\n", ScoreV.Len());
1555    ScoreV.Sort(false);
1556    FILE *F = fopen(TStr::Fmt("%s.txt", OutFNm.CStr()).CStr(), "wt");
1557    fprintf(F, "total %d items\n", IdV.Len());
1558    fprintf(F, "items above blog threshdolg %d\n", ScoreV.Len());
1559    fprintf(F, "counts are numbers of urls (not actually number of occurences)\n");
1560    fprintf(F, "\nblog\ttotal\tQuote\n");
1561    for (int i = 0; i < ScoreV.Len(); i++) {
1562      fprintf(F, "%s\n", ScoreV[i].Val2.CStr());
1563    }
1564    fclose(F);
1565  }
1566  void TQuoteBs::SaveForFlash(const TIntV& QtIdV, const TStr& OutFNm, const TTmUnit& TmUnit, int SaveN, const TSecTm& BegTm, const TSecTm& EndTm, const TUrlTy& OnlyCountTy) const {
1567    const int TmUnitSecs = TTmInfo::GetTmUnitSecs(TmUnit);
1568    TVec<TQuad<TFlt, TInt, TInt, TQuote::TTmFltPrV> > QtInfoV, QtInfoV2; 
1569    TQuote::TTmFltPrV FqV, SmoothFqV;
1570    TIntV VizQtIdV;
1571    if (SaveN == -1) { SaveN = TInt::Mx; }
1572    TSecTm MinTm=TSecTm(TInt::Mx-1), MaxTm=TSecTm(1);
1573    printf("Saving top %d out of %d quotes\n", SaveN, QtIdV.Len());
1574    THash<TInt, TIntPr> WeekPeakQtIdH; 
1575    for (int q = 0; q < QtIdV.Len() && QtInfoV2.Len() < (SaveN+100); q++) { 
1576      const TQuote& Qt = GetQt(QtIdV[q]);
1577      if (Qt.GetTy() == qtQuote) {
1578        Qt.GetFqOt(FqV, TmUnit, BegTm, EndTm, OnlyCountTy, *this);
1579        if (FqV.Empty()) { continue; }
1580        QtInfoV2.Add(TQuad<TFlt, TInt, TInt, TQuote::TTmFltPrV>((double)Qt.GetPeakTm(TmUnit, BegTm)+1e-6*Qt.GetUrls(), QtIdV[q], Qt.GetFq(), FqV));
1581        MinTm = TMath::Mn(MinTm, FqV[0].Val1);
1582        MaxTm = TMath::Mx(MaxTm, FqV.Last().Val1);
1583        VizQtIdV.Add(QtIdV[q]);
1584        TInt PeakFq;
1585        const int PeakTm = Qt.GetPeakTm(tmuWeek, BegTm, PeakFq).GetAbsSecs();
1586        if (! WeekPeakQtIdH.IsKey(PeakTm)) {
1587          WeekPeakQtIdH.AddDat(PeakTm, TIntPr(PeakFq, QtInfoV2.Len()-1)); }
1588        else if (WeekPeakQtIdH.GetDat(PeakTm).Val1<PeakFq) {
1589          WeekPeakQtIdH.AddDat(PeakTm, TIntPr(PeakFq, QtInfoV2.Len()-1)); }
1590      } else { 
1591        const int CId = Qt.GetCId();
1592        if (! ClustQtIdVH.IsKey(CId)) { continue; }
1593        const int CentrQtId = GetCentrQtId(CId);
1594        TQuote CentrQt;  GetMergedClustQt(CId, CentrQt, true);
1595        CentrQt.GetFqOt(FqV, TmUnit, BegTm, EndTm, OnlyCountTy, *this);
1596        if (FqV.Empty()) { continue; }
1597        QtInfoV2.Add(TQuad<TFlt, TInt, TInt, TQuote::TTmFltPrV>((double)CentrQt.GetPeakTm(TmUnit, BegTm)+1e-6*CentrQt.GetUrls(), CentrQtId, GetClustFq(CId), FqV));
1598        TInt PeakFq;
1599        const int PeakTm = CentrQt.GetPeakTm(tmuWeek, BegTm, PeakFq).GetAbsSecs();
1600        if (! WeekPeakQtIdH.IsKey(PeakTm)) {
1601          WeekPeakQtIdH.AddDat(PeakTm, TIntPr(PeakFq, QtInfoV2.Len()-1)); }
1602        else if (WeekPeakQtIdH.GetDat(PeakTm).Val1<PeakFq) {
1603          WeekPeakQtIdH.AddDat(PeakTm, TIntPr(PeakFq, QtInfoV2.Len()-1)); }
1604        MinTm = TMath::Mn(MinTm, FqV[0].Val1);
1605        MaxTm = TMath::Mx(MaxTm, FqV.Last().Val1);
1606        VizQtIdV.Add(CentrQtId);
1607      } /&bsol;*/
1608    }
1609    { TIntSet QtIdSet;
1610    for (int i = 0; i < WeekPeakQtIdH.Len(); i++) {
1611    }
1612    QtInfoV.Clr(true);
1613    for (int i = 0; i < TMath::Mn(SaveN, QtInfoV2.Len()); i++) {
1614      if (QtIdSet.IsKey(i)) { continue; }
1615      QtInfoV.Add(QtInfoV2[i]);
1616    printf("%d  ", (int) QtInfoV2[i].Val3()); 
1617      if (QtInfoV.Len() > SaveN) { break; }
1618    } } 
1619    THash<TSecTm, TIntFltH> TmCntH; 
1620    for (int i = 0; i < QtInfoV.Len(); i++) {
1621      const TQuote::TTmFltPrV& FqV = QtInfoV[i].Val4;
1622      for (int t = 0; t < FqV.Len(); t++) {
1623        TmCntH.AddDat(FqV[t].Val1).AddDat(i, FqV[t].Val2); }
1624    }
1625    for (int i = 0; i < TmCntH.Len(); i++) {
1626      TmCntH[i].SortByDat(false); }
1627    const int K = 10;
1628    const int Slack = 3*24*3600; 
1629    THash<TInt, TSecTm> QtLastTopH; 
1630    for (int i = 0; i < TmCntH.Len(); i++) {
1631      TIntFltH& TmH = TmCntH[i];
1632      for (int j = 0; j < TMath::Mn(K, TmH.Len()); j++) {
1633        QtLastTopH.AddDat(TmH.GetKey(j), TmCntH.GetKey(i));
1634      }
1635    }
1636    for (int i = 0; i < QtInfoV.Len(); i++) {
1637      TQuote::TTmFltPrV& FqV = QtInfoV[i].Val4;
1638      const TSecTm LastTime = QtLastTopH.GetDat(i);
1639      int x = 0; for (x = 0; x < FqV.Len() && FqV[x].Val1 <= LastTime+Slack; x++) { }
1640      if (x < FqV.Len()) { FqV.Del(x, FqV.Len()-1); }
1641    } 
1642    printf("save from %d quotes\n", QtInfoV.Len());
1643    QtInfoV.Sort();
1644    TIntH QtIdUrlH;  GetQtPageUrl(VizQtIdV, QtIdUrlH);
1645    FILE *F = fopen(TStr::Fmt("qtOt-%sQ.tab", OutFNm.CStr()).CStr(), "wt");
1646    fprintf(F, "QuoteId\tQuote\tUrl\tTotalVol\n");
1647    for (int i = 0; i < TMath::Mn(SaveN, QtInfoV.Len()); i++) {
1648      fprintf(F, "%d\t%s\t%s\t%d\n", SaveN-i, GetQt(QtInfoV[i].Val2).QtStr.CStr(), GetStr(QtIdUrlH.GetDat(QtInfoV[i].Val2)), (int) QtInfoV[i].Val3);
1649    }
1650    fclose(F);
1651    printf("saveT\n");
1652    F = fopen(TStr::Fmt("qtOt-%sT.tab", OutFNm.CStr()).CStr(), "wt");
1653    fprintf(F, "Time\tQuoteId\tSmoothFreq\tRawFreq\n");
1654    for (int i = 0; i < TMath::Mn(SaveN, QtInfoV.Len()); i++) {
1655      const TQuote::TTmFltPrV RawFqV = QtInfoV[i].Val4;
1656      TQuote::GetSmoothFqOt(SmoothFqV, RawFqV, TmUnit, 6*24*3600/TmUnitSecs, 1.05, MinTm, MaxTm);  
1657      IAssert(SmoothFqV.Len() >= RawFqV.Len());
1658      for (int d=0, ds = 0; ds < SmoothFqV.Len(); ds++) {
1659        if (TmUnit == tmuDay) { fprintf(F, "%s", SmoothFqV[ds].Val1.GetDtYmdStr().CStr()); }
1660        else { fprintf(F, "%s_%02d", SmoothFqV[ds].Val1.GetDtYmdStr().CStr(), SmoothFqV[ds].Val1.GetHourN()); }
1661        fprintf(F, "\t%d\t%.2f", SaveN-i, SmoothFqV[ds].Val2());
1662        if (d < RawFqV.Len() && SmoothFqV[ds].Val1 == RawFqV[d].Val1) { fprintf(F, "\t%.0f", RawFqV[d].Val2()); d++; } else { fprintf(F, "\t0"); }
1663        fprintf(F, "\n");
1664      }
1665    }
1666    fclose(F);
1667    printf("done.\n");
1668  }
1669  void TQuoteBs::SaveDomainStat(const TStr& OutFNm, const int& MinCnt) const {
1670    THash<TInt, TInt> MedOt, BlogOt, AllOt;
1671    int MedCnt=0, BlogCnt=0, AllCnt=0;
1672    TSecTm BegTm(2008,7,31,0,0,0);
1673    THash<TStr, TIntPr> DomCntH;
1674    for (int q = 0; q < QuoteH.Len(); q++) {
1675      const TQuote& Q = QuoteH[q];
1676      for (int u = 0; u < Q.GetUrls(); u++) {
1677        const int Day = TSecTm(Q.GetTm(u)-BegTm).GetInUnits(tmuDay);
1678        AllOt.AddDat(Day) += 1;  AllCnt++;
1679        if (GetUrlTy(Q.GetUrlId(u)) ==  utMedia) { MedOt.AddDat(Day) += 1;  MedCnt++;}
1680        else { BlogOt.AddDat(Day) += 1;  BlogCnt++; }
1681        TStr Dom = TStrUtil::GetDomNm2(GetStr(Q.GetUrlId(u)));
1682        DomCntH.AddDat(Dom).Val1 += 1;
1683        DomCntH.AddDat(Dom).Val2 += Q.GetCnt(u);
1684      }
1685    }
1686    TGnuPlot::PlotValCntH(AllOt, "ALL", MedOt, "MEDIA", BlogOt, "BLOGS", "overTm-"+OutFNm, TStr::Fmt("Quote freq over time: A:%d M:%d B:%d", AllCnt, MedCnt, BlogCnt),
1687      "Time [days]", "Number of quote mentions");
1688    DomCntH.SortByDat(false);
1689    FILE *F = fopen(TStr::Fmt("domains-%s.tab", OutFNm.CStr()).CStr(), "wt");
1690    fprintf(F, "# %d domains, total mentions:\tAll:%d\tMedia:%d\tBlogs:%d", DomCntH.Len(), AllCnt, MedCnt, BlogCnt);
1691    fprintf(F, "#Domain\tNumber of quotes mentioned\tNumber of mentions\n");
1692    for (int d = 0; d < DomCntH.Len(); d++) {
1693      fprintf(F, "%s\t%d\t%d\n", DomCntH.GetKey(d).CStr(), DomCntH[d].Val1(), DomCntH[d].Val2());
1694    }
1695    fclose(F);
1696  }
1697  void TQuoteBs::Dump(const bool& Fast) const {
1698    printf("Quote base:\n");
1699    if (! Fast) {
1700      TSecTm MinTm, MaxTm; GetMinMaxTm(MinTm, MaxTm);
1701      printf("  %s -- %s\n", MinTm.GetYmdTmStr().CStr(), MaxTm.GetYmdTmStr().CStr());
1702      int totCnt=0, totVol=0;
1703      for (int q = 0; q < QuoteH.Len(); q++) {
1704        const TQuote::TTmUrlCntV& V = QuoteH[q].TmUrlCntV;
1705        totCnt += V.Len();
1706        for (int u = 0; u < V.Len(); u++) {
1707          totVol += V[u].Cnt();
1708        }
1709      }
1710      printf("  %d number of posts mentioning quotes\n", totCnt);
1711      printf("  %d number of mentions\n", totVol);
1712    }
1713    printf("  %d quotes\n", Len());
1714    printf("  %d strings (quotes+urls, no domains)\n", StrQtIdH.Len());
1715    printf("  %d clusters\n", ClustQtIdVH.Len());
1716    printf("  %d quotes in clusters\n", GetQtsInClust());
1717    printf("  %d urls with type\n\n", UrlTyH.Len());
1718  }
1719  PQuoteBs TQuoteBs::FindQtInTxtQBs(const TStr& InBinFNmWc, const TStrV& QuoteStrV) {
1720    THashSet<TMd5Sig> SeenUrlH; 
1721    PQuoteBs QtBsPt = TQuoteBs::New();
1722    TQuoteBs& QtBs = *QtBsPt;
1723    TStrHash<TInt> StrH;
1724    TVec<TIntV> QtWIdVV;
1725    TVec<TIntV> QtSkipLenVV; 
1726    for (int q = 0; q < QuoteStrV.Len(); q++) {
1727      const int QId = QtBs.QuoteH.Len(); 
1728      TQuote& Qt = QtBs.QuoteH.AddDat(QId);
1729      Qt.QtCIdTy = TQuote::TQtIdTy(QId, qtQuote);
1730      Qt.QtStr = QuoteStrV[q];
1731      QtWIdVV.Add();  QtSkipLenVV.Add();
1732      TStrUtil::GetAddWIdV(StrH, QuoteStrV[q].CStr(), QtWIdVV.Last());
1733      TIntV& WIdV = QtWIdVV.Last();
1734      TIntV& SkipV = QtSkipLenVV.Last();
1735      SkipV.Add(1);
1736      for (int w = 1; w < WIdV.Len(); w++) {
1737        int skipLen = 1;
1738        while (w-skipLen >= 0 && WIdV[w-skipLen] != WIdV[w]) { skipLen++; }
1739        SkipV.Add(skipLen);
1740      }
1741    }
1742    TInt WId;
1743    TIntV TxtWIdV;
1744    TVec<char *> WrdV;
1745    TQuoteLoader QL(InBinFNmWc);
1746    while (QL.Next()) {
1747      if (SeenUrlH.IsKey(TMd5Sig(QL.PostUrlStr))) { continue; }
1748      SeenUrlH.AddKey(TMd5Sig(QL.PostUrlStr));
1749      TxtWIdV.Clr();  WrdV.Clr(false);
1750      { TStrUtil::SplitWords(QL.ContentStr, WrdV);
1751      for (int w = 0; w < WrdV.Len(); w++) {
1752        if (StrH.IsKeyGetDat(WrdV[w], WId)) { TxtWIdV.Add(WId); }
1753        else if (TxtWIdV.Len()>0 && TxtWIdV.Last()!=-1) { TxtWIdV.Add(-1); }
1754      } }
1755      for (int q = 0; q < QtWIdVV.Len(); q++) {
1756        const TIntV& QWIdV = QtWIdVV[q];
1757        const TIntV& SkipV = QtSkipLenVV[q];
1758        int cnt = 0;
1759        for (int w = 0; w < TxtWIdV.Len()-QWIdV.Len(); ) {
1760          int len = 0;
1761          while (len < QWIdV.Len() && TxtWIdV[w+len] == QWIdV[len]) { len++; }
1762          if (len == QWIdV.Len()) { cnt+=1;  w+=len; }
1763          else { w += SkipV[len]; }
1764        }
1765        if (cnt > 0) {
1766          QtBs.GetQtN(q).TmUrlCntV.Add(TQuote::TTmUrlCnt(QL.PubTm, QtBs.AddStr(QL.PostUrlStr), cnt));
1767          if (cnt > 255) { printf("*"); }
1768        }
1769      }
1770    }
1771    for (int i = 0; i < QtBs.Len(); i++) { QtBs.QuoteH[i].TmUrlCntV.Sort(); }
1772    return QtBsPt;
1773  }
1774  #ifdef false
1775  void TQuoteBs::BuildQtSubSeqCounts(TIntV& QtIdV, const TStr& OutFNm) {
1776  }
1777  void TQuoteBs::PlotQtFqOverTm(const TIntV& QtIdV, const TStr& OutFNm, int PlotN) const {
1778    TSecTm MinTm, MaxTm;  GetMinMaxTm(MinTm, MaxTm);
1779    TGnuPlot GP("fqOT."+OutFNm);
1780    TFltPrV HrFqV;
1781    if (PlotN == -1) { PlotN = TInt::Mx; }
1782    for (int i = 0; i < TMath::Mn(PlotN, QtIdV.Len()); i++) {
1783      const TQuote& Qt = GetQt(QtIdV[i]);
1784      Qt.GetSmoothFqOverTm(HrFqV, tmu1Hour, MinTm, 12, 1.2);
1785      for (int h = 0; h < HrFqV.Len(); h++) {
1786        HrFqV[h].Val1 = TMath::Round(HrFqV[h].Val1/24.0, 2);
1787      }
1788      GP.AddPlot(HrFqV, gpwLines, TStrUtil::GetShorStr(Qt.QtStr), "lt 1");
1789    }
1790    GP.SetXYLabel("Time [days]", "Frequency");
1791    GP.AddCmd("set nokey");
1792    GP.SavePng("fqOT."+OutFNm+".png", -1, -1, "", "set terminal png small size 3000,600");
1793    GP.AddCmd("set size 2,0.5");
1794    GP.SaveEps(10);
1795  }
1796  void TQuoteBs::PlotQtCumFqOverTm(const TIntV& QtIdV, const TStr& OutFNm, int PlotN) const {
1797    const int TmuSecs = TTmInfo::GetTmUnitSecs(tmu1Hour);
1798    TSecTm MinTm, MaxTm;  GetMinMaxTm(MinTm, MaxTm);
1799    const TSecTm StartTm = MinTm.Round(tmu1Hour);
1800    const TSecTm EndTm = MaxTm.Round(tmu1Hour);
1801    TQuote::TTmFltPrV HrFqV;
1802    TFltFltH SumCntH;
1803    for (TSecTm Tm = StartTm; Tm <= MaxTm.Round(tmu1Hour); Tm += TmuSecs) {
1804      SumCntH.AddDat(double(Tm-StartTm)/(24.0*3600.0)) = 0;
1805    }
1806    TGnuPlot GP("cfqOT."+OutFNm);
1807    if (PlotN == -1) { PlotN = TInt::Mx; }
1808    for (int i = 0; i < TMath::Mn(PlotN, QtIdV.Len()); i++) {
1809      const TQuote& Qt = GetQt(QtIdV[i]);
1810      Qt.GetSmoothFqOverTm(HrFqV, tmu1Hour, 48, 1.2);
1811      for (int h = 0; h < HrFqV.Len(); h++) {
1812        const TSecTm roundTm = HrFqV[h].Val1.Round(tmu1Hour);
1813        if (roundTm >= StartTm && roundTm<=EndTm) {
1814          SumCntH.AddDat(double(roundTm-StartTm)/(24.0*3600.0)) += HrFqV[h].Val2;
1815        }
1816      }
1817      GP.AddPlot(SumCntH, gpwLines, TStrUtil::GetShorStr(Qt.QtStr, 100).CStr());
1818    }
1819    GP.SetXYLabel(TStr::Fmt("Time [days] since %s", StartTm.GetYmdTmStr().CStr()), "Stacked frequency");
1820    GP.AddCmd("set notitle");
1821    GP.AddCmd("set nogrid");
1822    GP.AddCmd("set mxtics 4");
1823    GP.SavePng("cfqOT."+OutFNm+".png", -1, -1, "", "set terminal png small size 1000,600");
1824  }
1825  void TQuoteBs::PlotQtCumFqOverTm1(const TIntV& QtIdV, const TStr& OutFNm, int PlotN) const {
1826    TSecTm MinTm, MaxTm;  GetMinMaxTm(MinTm, MaxTm);
1827    TGnuPlot GP("cfqOT."+OutFNm);
1828    TFltPrV HrFqV, HrCFqV;
1829    TFltFltH SumCntH;
1830    if (PlotN == -1) { PlotN = TInt::Mx; }
1831    for (int i = 0; i < TMath::Mn(PlotN, QtIdV.Len()); i++) {
1832      const TQuote& Qt = GetQt(QtIdV[i]);
1833      Qt.GetSmoothFqOverTm(HrFqV, tmu1Hour, MinTm, 12, 1.2);
1834      HrCFqV.Clr(false);
1835      for (int h = 0; h < HrFqV.Len(); h++) {
1836        const double hr = TMath::Round(HrFqV[h].Val1/24.0+0.001, 2);
1837        SumCntH.AddDat(hr) += HrFqV[h].Val2;
1838      }
1839      GP.AddPlot(SumCntH, gpwLines, TStrUtil::GetShorStr(Qt.QtStr).CStr(), "lt 1");
1840    }
1841    GP.SetXYLabel("Time [days]", "Stacked frequency");
1842    GP.AddCmd("set nokey");
1843    GP.AddCmd("set notitle");
1844    GP.AddCmd("set nogrid");
1845    GP.AddCmd("set mxtics 5");
1846    GP.AddCmd("set xtics 5");
1847    GP.SavePng("cfqOT."+OutFNm+".png", -1, -1, "", "set terminal png small size 3000,600");
1848    GP.AddCmd("set size 2,0.5");
1849    GP.SaveEps(8);
1850  }
1851  void TQuoteBs::SaveForMatlab(const TIntV& QtIdV, const TStr& OutFNm, int SaveN) const {
1852    const TTmUnit TmUnit = tmu1Hour;
1853    TSecTm MinTm, MaxTm;  GetMinMaxTm(MinTm, MaxTm);
1854    THash<TInt, TFlt> TmCntH;
1855    TVec<TFltV> TmQtFqV;
1856    const int MinTmUnit = MinTm.GetInUnits(TmUnit);
1857    for (uint i = MinTmUnit; i <= MaxTm.GetInUnits(TmUnit); i++) {
1858      TmCntH.AddDat(i, 0);  TmQtFqV.Add();
1859      TmQtFqV.Last().Add(i-MinTmUnit+1); 
1860    }
1861    TQuote::TTmFltPrV DayFqV;
1862    if (SaveN == -1) { SaveN = TInt::Mx; }
1863    for (int i = 0; i < TMath::Mn(SaveN, QtIdV.Len()); i++) {
1864      const TQuote& Qt = GetQt(QtIdV[i]);
1865      Qt.GetSmoothFqOverTm(DayFqV, TmUnit, 48, 1.2);
1866      for (int d = 0; d < TmCntH.Len(); d++) { TmCntH[d] = 0; }
1867      for (int d = 0; d < DayFqV.Len(); d++) {
1868        const int T = DayFqV[d].Val1.GetInUnits(TmUnit);
1869        if (TmCntH.IsKey(T)) {
1870          TmCntH.AddDat(T) += DayFqV[d].Val2; }
1871      }
1872      for (int d = 0; d < TmCntH.Len(); d++) {
1873        TmQtFqV[d].Add(TmCntH[d]); }
1874    }
1875    FILE *F = fopen(TStr::Fmt("qtFqOtMATLAB-%s.tab", OutFNm.CStr()).CStr(), "wt");
1876    for (int d = 0; d < TmQtFqV.Len(); d++) {
1877      fprintf(F, "%g", TmQtFqV[d][0]());
1878      for (int q = 1; q < TmQtFqV[d].Len(); q++) {
1879        fprintf(F, "\t%g", TmQtFqV[d][q]()); }
1880      fprintf(F, "\n");
1881    }
1882    fclose(F);
1883  }
1884  void TQuoteBs::SaveQtTmUrlTxt(const TIntV& QtIdV, const TStr& OutFNm, int SaveN) const {
1885    if (SaveN == -1) { SaveN = TInt::Mx; }
1886    SaveN = TMath::Mn(SaveN, QtIdV.Len());
1887    FILE *F = fopen(OutFNm.CStr(), "wt");
1888    for (int q = 0; q < QtIdV.Len(); q++) {
1889      const TQuote& Qt = GetQt(QtIdV[q]);
1890      fprintf(F, "%s\t%d\n", Qt.QtStr.CStr(), Qt.GetFq());
1891      for (int u = 0; u < Qt.GetUrls(); u++) {
1892        fprintf(F, "\t%s\t%s\n", Qt.TmUrlCntV[u].Val1.GetYmdTmStr().CStr(), GetStr(Qt.TmUrlCntV[u].Val2));
1893      }
1894      fprintf(F, "\n");
1895    }
1896    fclose(F);
1897  }
1898  void TQuoteBs::PlotSubQtOverTm(const int& QtId, const TStr& OutFNm) const {
1899    TIntV PlotQtV;
1900    const TQuote Qt = GetQt(QtId);
1901    PlotQtV.Add(QtId);
1902    TIntV WrdBegV; WrdBegV.Add(0);
1903    for (int i = 1; i < Qt.QtStr.Len()-1; i++) {
1904      if (TCh::IsAlNum(Qt.QtStr.GetCh(i)) && TCh::IsWs(Qt.QtStr.GetCh(i-1))) { WrdBegV.Add(i); }
1905    }
1906    TInt subQtId;
1907    WrdBegV.Add(Qt.QtStr.Len()+1); 
1908    const int QtWords = TStrUtil::CountWords(Qt.QtStr.CStr());
1909    for (int WndSz = 5; WndSz < QtWords; WndSz++) {
1910      for (int word = 0; word < QtWords-WndSz; word++) {
1911        const TStr SubQtStr = Qt.QtStr.GetSubStr(WrdBegV[word], WrdBegV[word+WndSz]-2);
1912        if (StrH.IsKeyGetDat(SubQtStr, subQtId) && QuoteH.IsKey(subQtId) && subQtId!=QtId) { PlotQtV.Add(subQtId); printf("."); }
1913      }
1914    }
1915    TGnuPlot GP(OutFNm, TStr::Fmt("%d occurences, %d urls, %d domains: %s", Qt.GetFq(), Qt.GetUrls(), Qt.GetDoms(), Qt.QtStr.CStr()));
1916    TFltPrV HrFqV;
1917    for (int i = 0; i < PlotQtV.Len(); i++) {
1918      const TQuote& subQt = QuoteH.GetDat(PlotQtV[i]);
1919      subQt.GetSmoothFqOverTm(HrFqV, tmu1Hour);
1920      GP.AddPlot(HrFqV, gpwLines, subQt.QtStr.CStr());
1921    }
1922    GP.SetXYLabel("Time [hours]", "Frequency");
1923    GP.SavePng(OutFNm+".png", -1, -1, "", "set terminal png small size 1000,800");
1924  }
1925  void TQuoteBs::PlotTopQuotesOverTm(const int& StepSecs, const int& IntervalSecs, const int& TakeNPerStep, const TStr& OutFNm) const {
1926    TSecTm MinTm, MaxTm;  GetMinMaxTm(MinTm, MaxTm);
1927    printf("Dataset span %s -- %s\n", MinTm.GetStr().CStr(), MaxTm.GetStr().CStr());
1928    TIntSet TopQtIdSet;
1929    int cnt=0;
1930    TIntV TopQtIdV;
1931    for (TSecTm Tm(MinTm); Tm < MaxTm; Tm += StepSecs, cnt++) {
1932      FailR("TopQuotesOverTm: take top quotes from each day");
1933      for (int q = 0; q < TopQtIdV.Len(); q++) { TopQtIdSet.AddKey(TopQtIdV[q]); }
1934    }
1935    printf("\n%d time steps total, %d quotes per step: %d total quotes\n", cnt, TakeNPerStep, TopQtIdSet.Len());
1936    printf("%s   %d\n", MinTm.Round(tmuDay).GetStr().CStr(), MinTm.Round(tmuDay).GetInUnits(tmu1Hour));
1937    TFltPrV FqOverTm;
1938    TGnuPlot GP(TStr("topQtOverTm.")+OutFNm, "");
1939    TFOut FOut(OutFNm+TStr(".Quote"));
1940    for (int q = 0; q < TopQtIdSet.Len(); q++) {
1941      const TQuote& Q = QuoteH.GetDat(TopQtIdSet[q]);
1942      Q.Save(FOut);
1943      Q.GetSmoothFqOverTm(FqOverTm, tmu1Hour, MinTm.Round(tmuDay));
1944      GP.AddPlot(FqOverTm, gpwLines, Q.QtStr);
1945    }
1946    GP.AddCmd("set xtics 24"); GP.AddCmd("set mxtics 4");
1947    GP.SetXYLabel(TStr("time [hours] from "+MinTm.Round(tmuDay).GetStr()), "frequency");
1948    GP.SavePng(TStr("topQtOverTm.")+OutFNm+TStr(".png"), -1, -1, "", "set terminal png small size 2000,800");
1949  }
1950  PQuoteBs TQuoteBs::BuildQuoteBs(const TStr& InBinFNmWc, const int& MinQtWrdLen) {
1951    PQuoteBs QBsPt = TQuoteBs::New(InBinFNmWc);
1952    QBsPt->AddToQuoteBs(InBinFNmWc, MinQtWrdLen);
1953    return QBsPt;
1954  }
1955  #endif
1956  PClustNet TClustNet::GetSubGraph(const TIntV& NIdV) const {
1957    PClustNet NewNetPt = TClustNet::New();
1958    TClustNet& NewNet = *NewNetPt;
1959    NewNet.Reserve(NIdV.Len(), -1);
1960    int node, edge;
1961    TClustNet::TNodeI NI;
1962    for (node = 0; node < NIdV.Len(); node++) {
1963      NewNet.AddNode(NIdV[node], GetNDat(NIdV[node])); 
1964    }
1965    for (node = 0; node < NIdV.Len(); node++) {
1966      NI = GetNI(NIdV[node]);
1967      const int SrcNId = NI.GetId();
1968      for (edge = 0; edge < NI.GetOutDeg(); edge++) {
1969        const int OutNId = NI.GetOutNId(edge);
1970        if (NewNet.IsNode(OutNId)) {
1971          NewNet.AddEdge(SrcNId, OutNId); }
1972      }
1973    }
1974    NewNet.Defrag();
1975    return NewNetPt;
1976  }
1977  void TClustNet::AddLink(const TQuote& SrcQt, const TQuote& DstQt) {
1978    const int Qt1Id = SrcQt.GetCId();
1979    const int Qt2Id = DstQt.GetCId();
1980    if (! IsNode(Qt1Id)) {
1981      AddNode(Qt1Id, SrcQt); }
1982    if (! IsNode(Qt2Id)) {
1983      AddNode(Qt2Id, DstQt); }
1984    if (! IsEdge(Qt2Id, Qt1Id)) {
1985      AddEdge(Qt1Id, Qt2Id);
1986    }
1987  }
1988  PClustNet TClustNet::GetSubGraph(const int& MinQtWords, const int& MaxQtWords, const int& MinFq) const {
1989    TIntV NIdV;
1990    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
1991      const int Wrds = TStrUtil::CountWords(NI().GetStr().CStr());
1992      if (NI().GetFq() >= MinFq &&  Wrds >= MinQtWords && Wrds <= MaxQtWords) {
1993        NIdV.Add(NI.GetId()); }
1994    }
1995    return GetSubGraph(NIdV);
1996  }
1997  void TClustNet::RecalcEdges(const double& MinOverlapFrac) {
1998    printf("Recalculating edges...\n");
1999    TIntPrV DelEdgeV;
2000    TStrHash<TInt> StrH(Mega(1), true);
2001    int WIdV1Start, WIdV2Start, SkipTy;
2002    TIntV WIdV1, WIdV2;
2003    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
2004      const TStr Q1 = NI().GetStr();
2005      TStrUtil::GetAddWIdV(StrH, Q1.CStr(), WIdV1);
2006      for (int e = 0; e < NI.GetOutDeg(); e++) {
2007        const TStr Q2 = NI.GetOutNDat(e).GetStr();
2008        TStrUtil::GetAddWIdV(StrH, Q2.CStr(), WIdV2);
2009        const int Overlap = TQuoteBs::LongestCmnSubSq(WIdV1, WIdV2, WIdV1Start, WIdV2Start, SkipTy);
2010        const int ShortLen = TMath::Mn(WIdV1.Len(), WIdV2.Len());
2011        const int LongLen = TMath::Mx(WIdV1.Len(), WIdV2.Len());
2012        IAssert(Overlap<=ShortLen);
2013        if (2*ShortLen>LongLen && Overlap/double(ShortLen) > MinOverlapFrac) { continue; }
2014        DelEdgeV.Add(TIntPr(NI.GetId(), NI.GetOutNId(e)));
2015      }
2016    }
2017    printf("Deleting %d/%d (%.4f) edges\n", DelEdgeV.Len(), GetEdges(), DelEdgeV.Len()/double(GetEdges()));
2018    for (int i = 0; i < DelEdgeV.Len(); i++) {
2019      DelEdge(DelEdgeV[i].Val1, DelEdgeV[i].Val2);
2020    }
2021  }
2022  void TClustNet::MakeClusters(const TIntPrV& KeepEdgeV) {
2023    PUNGraph G = TUNGraph::New();
2024    for (int e = 0; e < KeepEdgeV.Len(); e++) {
2025      if (! G->IsNode(KeepEdgeV[e].Val1)) {
2026        G->AddNode(KeepEdgeV[e].Val1); }
2027      if (! G->IsNode(KeepEdgeV[e].Val2)) {
2028        G->AddNode(KeepEdgeV[e].Val2); }
2029      G->AddEdge(KeepEdgeV[e].Val1, KeepEdgeV[e].Val2);
2030    }
2031    TCnComV CnComV;
2032    TSnap::GetWccs(G, CnComV);
2033    TIntH NIdCcIdH(GetNodes());
2034    for (int c = 0; c < CnComV.Len(); c++) {
2035      const TIntV& NIdV = CnComV[c].NIdV;
2036      for (int n = 0; n < NIdV.Len(); n++) {
2037        NIdCcIdH.AddDat(NIdV[n], c);
2038      }
2039    }
2040    TIntPrV DelEdgeV;
2041    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
2042      const int ccid1 = NIdCcIdH.IsKey(EI.GetSrcNId()) ? NIdCcIdH.GetDat(EI.GetSrcNId()).Val : -1;
2043      const int ccid2 = NIdCcIdH.IsKey(EI.GetDstNId()) ? NIdCcIdH.GetDat(EI.GetDstNId()).Val : -1;
2044      if (ccid1 != ccid2 && ccid1!=-1 && ccid2!=-1) {
2045        DelEdgeV.Add(TIntPr(EI.GetSrcNId(), EI.GetDstNId())); }
2046    }
2047    const int Edges = GetEdges();
2048    printf("Deleting %d out of %d  (%f) edges\n", DelEdgeV.Len(), Edges, DelEdgeV.Len()/double(Edges));
2049    for (int d = 0; d < DelEdgeV.Len(); d++) {
2050      DelEdge(DelEdgeV[d].Val1, DelEdgeV[d].Val2);
2051    }
2052  }
2053  void TClustNet::KeepOnlyTree(const TIntPrV& KeepEdgeV) {
2054    TIntPrSet EdgeSet(KeepEdgeV.Len());
2055    for (int i = 0; i < KeepEdgeV.Len(); i++) {
2056      EdgeSet.AddKey(TIntPr(TMath::Mn(KeepEdgeV[i].Val1, KeepEdgeV[i].Val2),
2057        TMath::Mx(KeepEdgeV[i].Val1, KeepEdgeV[i].Val2)));
2058    }
2059    TIntPrSet DelEdgeV;
2060    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
2061      const int N1 = TMath::Mn(EI.GetSrcNId(), EI.GetDstNId());
2062      const int N2 = TMath::Mx(EI.GetSrcNId(), EI.GetDstNId());
2063      if (! EdgeSet.IsKey(TIntPr(N1, N2))) {
2064        DelEdgeV.AddKey(TIntPr(N1, N2)); }
2065    }
2066    printf("deleting %d edges\n", DelEdgeV.Len());
2067    for (int d = 0; d < DelEdgeV.Len(); d++) {
2068      DelEdge(DelEdgeV[d].Val1, DelEdgeV[d].Val2);
2069    }
2070  }
2071  void TClustNet::GetClusters(TVec<TIntV>& QtNIdV) const {
2072    TCnComV CnComV;
2073    TSnap::GetWccs(GetThis(), CnComV);
2074    CnComV.Sort(false);
2075    QtNIdV.Clr(false);
2076    TIntSet SeenSet;
2077    for (int i = 0; i < CnComV.Len(); i++) {
2078      for (int n = 0; n < CnComV[i].NIdV.Len(); n++) {
2079        IAssert(! SeenSet.IsKey(CnComV[i].NIdV[n]));
2080        SeenSet.AddKey(CnComV[i].NIdV[n]);
2081      }
2082      QtNIdV.Add(CnComV[i].NIdV);
2083    }
2084  }
2085  void TClustNet::GetMergedClustQt(const TIntV& QtIdV, TQuote& NewQt) const {
2086    int CentrQtId=-1, MxFq=0;
2087    THash<TPair<TSecTm, TInt>, TInt> TmUrlCntH;
2088    for (int c = 0; c < QtIdV.Len(); c++) {
2089      const TQuote& Q = GetNDat(QtIdV[c]);
2090      IAssert(Q.GetId() == QtIdV[c]);
2091      for (int t = 0; t < Q.GetTimes(); t++) {
2092        TmUrlCntH.AddDat(TPair<TSecTm, TInt>(Q.GetTm(t), Q.GetUrlId(t))) += Q.GetCnt(t);
2093      }
2094      if (MxFq < Q.GetFq()) {
2095        MxFq = Q.GetFq();
2096        CentrQtId = Q.GetId();
2097      }
2098    }
2099    NewQt.QtCIdTy = TQuote::TQtIdTy(-1, qtCentr);
2100    NewQt.QtStr = GetNDat(CentrQtId).GetStr(); 
2101    NewQt.TmUrlCntV.Gen(TmUrlCntH.Len(), 0);
2102    for (int u = 0; u < TmUrlCntH.Len(); u++) {
2103      NewQt.TmUrlCntV.Add(TQuote::TTmUrlCnt(TmUrlCntH.GetKey(u).Val1, TmUrlCntH.GetKey(u).Val2(), TmUrlCntH[u]()));
2104    }
2105    NewQt.TmUrlCntV.Sort();
2106  }
2107  int TClustNet::EvalPhraseClusters(const TIntPrV& KeepEdgeV, const bool& dump) const {
2108    PNGraph G = TNGraph::New();
2109    for (int e = 0; e < KeepEdgeV.Len(); e++) {
2110      if (! G->IsNode(KeepEdgeV[e].Val1)) {
2111        G->AddNode(KeepEdgeV[e].Val1); }
2112      if (! G->IsNode(KeepEdgeV[e].Val2)) {
2113        G->AddNode(KeepEdgeV[e].Val2); }
2114      G->AddEdge(KeepEdgeV[e].Val1, KeepEdgeV[e].Val2);
2115    }
2116    TCnComV CnComV;
2117    TSnap::GetWccs(G, CnComV);
2118    G = TSnap::ConvertGraph<PNGraph>(TPt<TClustNet>((TClustNet*) this));
2119    int TotEdges=0, EdgesInBigClust=0;
2120    int TotNodes=0, NodesInBigClust=0;
2121    int BigClust=0;
2122    for (int cc = 0; cc < CnComV.Len(); cc++) {
2123      if (CnComV[cc].NIdV.Len() < 3) { continue; }
2124      PNGraph CC = TSnap::GetSubGraph(G, CnComV[cc].NIdV);
2125      TotEdges += CC->GetEdges();
2126      TotNodes += CC->GetNodes()-1;
2127      if (CC->GetNodes() > 10) {
2128        EdgesInBigClust += CC->GetEdges();
2129        NodesInBigClust += CC->GetNodes()-1;
2130        BigClust++;
2131      }
2132    }
2133    if (dump) {
2134      printf("                                all\tbig(>10)\n");
2135      printf("  Number of clusters:           %d\t%d\n", CnComV.Len(), BigClust);
2136      printf("  Total edges inside clusters:  %d\t%d\n", TotEdges, TotEdges-TotNodes);
2137      printf("  Total edges deleted:          %d\t%d\n", GetEdges()-TotEdges, GetEdges()-TotEdges-TotNodes);
2138      printf("  Total edges in big clusters:  %d\t%d\n", EdgesInBigClust, EdgesInBigClust-NodesInBigClust);
2139    }
2140    return TotEdges-TotNodes;
2141  }
2142  void TClustNet::ClustKeepSingleEdge(const int& MethodId) const {
2143    TIntPrV KeepEdgeV;
2144    ClustKeepSingleEdge(MethodId, KeepEdgeV);
2145  }
2146  void TClustNet::ClustKeepSingleEdge(const int& MethodId, TIntPrV& KeepEdgeV) const {
2147    PNGraph G = TSnap::ConvertGraph<PNGraph>(TPt<TClustNet>((TClustNet*) this));
2148    KeepEdgeV.Clr(false);
2149    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
2150      IAssert(NI.GetId() == NI().GetId());
2151      int EdgeToKeep = -1, BestVal=0;
2152      for (int e = 0; e < NI.GetOutDeg(); e++) {
2153        if (MethodId==1 && NI.GetOutNDat(e).GetFq() > BestVal) { EdgeToKeep=e; BestVal=NI.GetOutNDat(e).GetFq(); }
2154        if (MethodId==2 && NI.GetOutNDat(e).GetStr().Len() > BestVal) { EdgeToKeep=e; BestVal=NI.GetOutNDat(e).GetStr().Len(); }
2155        if (MethodId==3 && NI.GetOutNDat(e).GetStr().Len() < BestVal ||BestVal==0) { EdgeToKeep=e; BestVal=NI.GetOutNDat(e).GetStr().Len(); }
2156      }
2157      if (MethodId==4 && NI.GetOutDeg()>0) {
2158        EdgeToKeep = TInt::Rnd.GetUniDevInt(NI.GetOutDeg()); }
2159      if (EdgeToKeep!=-1) {
2160        KeepEdgeV.Add(TIntPr(NI.GetId(), NI.GetOutNId(EdgeToKeep))); }
2161    }
2162    if (MethodId==1) { printf("Keep edge to most frequent quote:\n"); }
2163    if (MethodId==2) { printf("Keep edge to longest quote:\n"); }
2164    if (MethodId==3) { printf("Keep edge to shortest quote:\n"); }
2165    if (MethodId==4) { printf("Keep random edge:\n"); }
2166    EvalPhraseClusters(KeepEdgeV);
2167  }
2168  void TClustNet::ClustGreedyTopDown() const {
2169    TIntPrV KeepEdgeV;
2170    ClustGreedyTopDown(KeepEdgeV);
2171  }
2172  void TClustNet::ClustGreedyTopDown(TIntPrV& KeepEdgeV) const {
2173    TIntH NIdOutDegH;
2174    TIntH NIdClustH;
2175    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
2176      NIdOutDegH.AddDat(NI.GetId(), NI.GetOutDeg());
2177      if (NI.GetOutDeg() == 0) {
2178        NIdClustH.AddDat(NI.GetId(), NI.GetId()); }
2179    }
2180    printf("%d root nodes\n", NIdClustH.Len());
2181    printf("%d nodes\n", NIdOutDegH.Len());
2182    NIdOutDegH.SortByDat(true);
2183    THash<TInt, TIntPr> ClustCntH;
2184    KeepEdgeV.Clr(false);
2185    while (NIdOutDegH.Len() > 0 && NIdOutDegH[0] == 0) {
2186      for (int i = 0; i < NIdOutDegH.Len() && NIdOutDegH[i] == 0; i++) {
2187        IAssert(IsNode(NIdOutDegH.GetKey(i)));
2188        const TNodeI NI = GetNI(NIdOutDegH.GetKey(i));
2189        for (int e = 0; e < NI.GetInDeg(); e++) {
2190          NIdOutDegH.GetDat(NI.GetInNId(e)) -= 1; }
2191        ClustCntH.Clr(false);
2192        for (int e = 0; e < NI.GetOutDeg(); e++) {
2193          IAssert(NIdClustH.IsKey(NI.GetOutNId(e)));
2194          ClustCntH.AddDat(NIdClustH.GetDat(NI.GetOutNId(e))).Val1 += 1; 
2195          ClustCntH.AddDat(NIdClustH.GetDat(NI.GetOutNId(e))).Val2 = NI.GetOutNId(e);
2196        }
2197        ClustCntH.SortByDat(false);
2198        if (ClustCntH.Len() > 0) {
2199          const int NId = NI.GetId();
2200          const int NId2 = ClustCntH[0].Val2;
2201          const int CId = NIdClustH.GetDat(NId2);
2202          KeepEdgeV.Add(TIntPr(NId, NId2)); 
2203          NIdClustH.AddDat(NId, CId); 
2204        }
2205        NIdOutDegH[i] = TInt::Mx;
2206      }
2207      NIdOutDegH.SortByDat(true);
2208    }
2209    printf("Greedy top down approach:\n");
2210    EvalPhraseClusters(KeepEdgeV);
2211  }
2212  void TClustNet::ClustGreedyRandom() const {
2213    printf("Greedy random:\n");
2214    THash<TInt, TIntV> OutNIdV;
2215    THash<TInt, TInt> EdgeH;
2216    TIntPrV KeepEdgeV;
2217    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
2218      if (NI.GetOutDeg() > 0) {
2219        EdgeH.AddDat(NI.GetId()) = NI.GetOutNId(TInt::Rnd.GetUniDevInt(NI.GetOutDeg()));
2220        if (NI.GetOutDeg() > 1) {
2221          for (int e = 0; e < NI.GetOutDeg(); e++) {
2222            OutNIdV.AddDat(NI.GetId()).Add(NI.GetOutNId(e)); }
2223        }
2224      }
2225    }
2226    { TIntH NIdOutDegH;
2227    TIntH NIdClustH;
2228    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
2229      NIdOutDegH.AddDat(NI.GetId()) = NI.GetOutDeg();
2230      if (NI.GetOutDeg() == 0) {
2231        NIdClustH.AddDat(NI.GetId(), NI.GetId()); }
2232    }
2233    NIdOutDegH.SortByDat(true);
2234    THash<TInt, TIntPr> ClustCntH;
2235    while (NIdOutDegH.Len() > 0 && NIdOutDegH[0] == 0) {
2236      for (int i = 0; i < NIdOutDegH.Len() && NIdOutDegH[i] == 0; i++) {
2237        const TNodeI NI = GetNI(NIdOutDegH.GetKey(i));
2238        for (int e = 0; e < NI.GetInDeg(); e++) {
2239          NIdOutDegH.GetDat(NI.GetInNId(e)) -= 1; }
2240        ClustCntH.Clr(false);
2241        for (int e = 0; e < NI.GetOutDeg(); e++) {
2242          ClustCntH.AddDat(NIdClustH.GetDat(NI.GetOutNId(e))).Val1 += 1;
2243          ClustCntH.AddDat(NIdClustH.GetDat(NI.GetOutNId(e))).Val2 = NI.GetOutNId(e);
2244        }
2245        ClustCntH.SortByDat(false);
2246        if (ClustCntH.Len() > 0) {
2247          KeepEdgeV.Add(TIntPr(NI.GetId(), ClustCntH[0].Val2));
2248        }
2249        NIdOutDegH[i] = TInt::Mx;
2250      }
2251      NIdOutDegH.SortByDat(true);
2252    } }
2253    printf("%d\n", EdgeH.Len());
2254    for (int e = 0; e < KeepEdgeV.Len(); e++) {
2255      EdgeH.AddDat(KeepEdgeV[e].Val1) = KeepEdgeV[e].Val2;
2256    }
2257    printf("%d\n", EdgeH.Len());
2258    EdgeH.GetKeyDatPrV(KeepEdgeV);
2259    int CurScore = EvalPhraseClusters(KeepEdgeV);
2260    while (true) {
2261        const int RndNId = OutNIdV.GetKey(TInt::Rnd.GetUniDevInt(OutNIdV.Len()));
2262        const int RndEdge = OutNIdV.GetDat(RndNId)[TInt::Rnd.GetUniDevInt(OutNIdV.GetDat(RndNId).Len())];
2263        const int id = EdgeH.GetKeyId(RndNId);  IAssert(KeepEdgeV[id].Val1 == RndNId);
2264        if (KeepEdgeV[id].Val2 == RndEdge) { continue; } 
2265        const int OldE = KeepEdgeV[id].Val2;
2266        KeepEdgeV[id].Val2 = RndEdge;
2267      const int NewScore = EvalPhraseClusters(KeepEdgeV, false);
2268      if (NewScore > CurScore &bsol;*|| TInt::Rnd.GetUniDev() < 0.1*/) {
2269        printf("%6d --> %6d\n", CurScore, NewScore);
2270        CurScore = NewScore;
2271      }
2272      else {  KeepEdgeV[id].Val2 = OldE; } 
2273    }
2274  }
2275  TChA InsertLineBreaks(const TChA& ChA, const int& BreakAtPost) {
2276    TChA Tmp = ChA, Out;
2277    int Lines = 1;
2278    TVec<char*> WrdV;
2279    TStrUtil::SplitWords(Tmp, WrdV);
2280    for (int w = 0; w < WrdV.Len(); w++) {
2281      if (Out.Len() + (int)strlen(WrdV[w]) > Lines*BreakAtPost) {
2282        Lines++; Out+="\\n"; }
2283      Out += WrdV[w];
2284      Out += " ";
2285    }
2286    return Out;
2287  }
2288  void TClustNet::DrawNet(const TStr& OutFNm, const int& SaveTopN) const {
2289    TCnComV CnComV;
2290    TSnap::GetWccs(GetThis(), CnComV);
2291    CnComV.Sort(false);
2292    for (int Comp = 0; Comp<TMath::Mn(SaveTopN, CnComV.Len()); Comp++) {
2293      if (CnComV[Comp].Len() < 5) { continue; }
2294      TPt<TNet> SubNet = TSnap::GetSubGraph(TPt<TNet>((TClustNet*) this), CnComV[Comp].NIdV);
2295      printf("draw: %d nodes, %d edges\n", SubNet->GetNodes(), SubNet->GetEdges());
2296      FILE *F = fopen(TStr::Fmt("%s-c%02d.dot", OutFNm.CStr(), Comp).CStr(), "wt");
2297      fprintf(F, "digraph G { &bsol;*%d nodes, %d edges*/\n", SubNet->GetNodes(), SubNet->GetEdges());
2298      fprintf(F, "  graph [splines=true overlap=false rankdir=LR]\n");
2299      fprintf(F, "  node  [shape=box, fontsize=14]\n");
2300      for (TNet::TNodeI NI = SubNet->BegNI(); NI < SubNet->EndNI(); NI++) {
2301        fprintf(F, "  %d [label=\"%s (%d, %d)\"];\n", NI.GetId(), InsertLineBreaks(NI().GetStr(), 80).CStr(), NI().GetFq(), NI().GetUrls());
2302      }
2303      for (TNet::TEdgeI EI = SubNet->BegEI(); EI < SubNet->EndEI(); EI++) {
2304        fprintf(F, "  %d -> %d;\n", EI.GetSrcNId(), EI.GetDstNId());
2305      }
2306      fprintf(F, "}\n");
2307      fclose(F);
2308      TGraphViz::DoLayout(TStr::Fmt("%s-c%02d.dot", OutFNm.CStr(), Comp), TStr::Fmt("%s-c%02d.ps", OutFNm.CStr(), Comp), gvlDot);
2309      TSnap::SavePajek(SubNet, TStr::Fmt("%s-c%02d.net", OutFNm.CStr(), Comp));
2310    }
2311  }
2312  void TClustNet::DumpNodes(const TStr& OutFNm, const int& SaveTopN) const {
2313    TIntV NIdV;  GetNIdV(NIdV);
2314    TIntH NIdCompSzH;
2315    { TCnComV CnComV;
2316    TSnap::GetWccs(GetThis(), CnComV);
2317    for (int c = 0; c < CnComV.Len(); c++) {
2318      for (int n = 0; n < CnComV[c].NIdV.Len(); n++) {
2319        NIdCompSzH.AddDat(CnComV[c].NIdV[n], CnComV[c].Len());
2320      }
2321    } }
2322    TIntPrV FqNIdV;
2323    for (int n = 0; n < NIdV.Len(); n++) {
2324      FqNIdV.Add(TIntPr(GetNDat(NIdV[n]).GetFq(), NIdV[n]));
2325    }
2326    FqNIdV.Sort(false);
2327    FILE *F = fopen(TStr::Fmt("nodes-%s.txt", OutFNm.CStr()).CStr(), "wt");
2328    fprintf(F, "#Freq\tClustSz\tQuote\n");
2329    for (int i = 0; i < FqNIdV.Len(); i++) {
2330      const TQuote& Q = GetNDat(FqNIdV[i].Val2);
2331      fprintf(F, "%d\t%d\t%s\n", Q.GetFq(), NIdCompSzH.GetDat(FqNIdV[i].Val2).Val, Q.GetStr().CStr());
2332    }
2333  }
2334  void TClustNet::DumpClusters(const TStr& OutFNm, int SaveTopN) const {
2335    TCnComV CnComV;
2336    TSnap::GetWccs(GetThis(), CnComV); 
2337    CnComV.Sort(false);
2338    FILE *F = fopen(TStr::Fmt("clust-%s.txt", OutFNm.CStr()).CStr(), "wt");
2339    if (SaveTopN==-1) { SaveTopN=TInt::Mx; }
2340    for (int Comp = 0; Comp<TMath::Mn(SaveTopN, CnComV.Len()); Comp++) {
2341      const TIntV& NIdV = CnComV[Comp].NIdV;
2342      TIntPrV FqNIdV;
2343      int SumFq=0;
2344      for (int n = 0; n < NIdV.Len(); n++) {
2345        FqNIdV.Add(TIntPr(GetNDat(NIdV[n]).GetFq(), NIdV[n]));
2346        SumFq += GetNDat(NIdV[n]).GetFq();
2347      }
2348      FqNIdV.Sort(false);
2349      fprintf(F, "%d quotes, total freq %d\n", FqNIdV.Len(), SumFq);
2350      for (int i = 0; i < FqNIdV.Len(); i++) {
2351        const TQuote& Q = GetNDat(FqNIdV[i].Val2);
2352        fprintf(F, "%d\t%s\n", Q.GetFq(), Q.GetStr().CStr());
2353      }
2354      fprintf(F, "\n");
2355    }
2356  }
2357  void TClustNet::DumpClustersByVol(const TStr& OutFNm, const int& MinClustSz, const int& MinVolume) const {
2358    TCnComV CnComV;
2359    TSnap::GetWccs(GetThis(), CnComV);
2360    CnComV.Sort(false);
2361    TIntPrV FqClustV;
2362    TIntH ClSzH, ClFqH;
2363    int FqMore1k=0;
2364    for (int Comp = 0; Comp < CnComV.Len(); Comp++) {
2365      const TIntV& NIdV = CnComV[Comp].NIdV;
2366      if (NIdV.Len() < MinClustSz) { continue; } 
2367      int SumFq=0;
2368      for (int n = 0; n < NIdV.Len(); n++) {
2369        SumFq += GetNDat(NIdV[n]).GetFq(); }
2370      FqClustV.Add(TIntPr(SumFq, Comp));
2371      ClFqH.AddDat(SumFq) += 1;
2372      ClSzH.AddDat(NIdV.Len()) += 1;
2373      if (SumFq>500) { FqMore1k++; }
2374    }
2375    FqClustV.Sort(false);
2376    FILE *F = fopen(TStr::Fmt("clustFq-%s.txt", OutFNm.CStr()).CStr(), "wt");
2377    fprintf(F, "Cluster network:\n%d nodes\n%d edges\n%d clusters\n%d big clusters (>=%d)\n",
2378      GetNodes(), GetEdges(), CnComV.Len(), FqClustV.Len(), MinClustSz);
2379    for (int c = 0; c < FqClustV.Len(); c++) {
2380      const TIntV& NIdV = CnComV[FqClustV[c].Val2].NIdV;
2381      TIntPrV FqNIdV;
2382      int SumFq=0;
2383      for (int n = 0; n < NIdV.Len(); n++) {
2384        FqNIdV.Add(TIntPr(GetNDat(NIdV[n]).GetFq(), NIdV[n]));
2385        SumFq += GetNDat(NIdV[n]).GetFq();
2386      }
2387      if (SumFq < MinVolume) { continue; }
2388      FqNIdV.Sort(false);
2389      fprintf(F, "%d\t%d items\t%d totFq\n", c, FqNIdV.Len(), SumFq);
2390      for (int i = 0; i < FqNIdV.Len(); i++) {
2391        const TQuote& Q = GetNDat(FqNIdV[i].Val2);
2392        fprintf(F, "\t%d\t%s\n", Q.GetFq(), Q.GetStr().CStr());
2393      }
2394      fprintf(F, "\n");
2395    }
2396    TGnuPlot::PlotValCntH(ClFqH, "clVol."+OutFNm, TStr::Fmt("%s. %d nodes, %d edges, %d clusters, %d big clusters (>=%d), %d with vol>500",
2397      OutFNm.CStr(), GetNodes(), GetEdges(), CnComV.Len(), FqClustV.Len(), MinClustSz, FqMore1k), "Cluster volume", "Count", gpsLog);
2398    TGnuPlot::PlotValCntH(ClSzH, "clSz."+OutFNm, TStr::Fmt("%s. %d nodes, %d edges, %d clusters, %d big clusters (>=%d), %d with vol>500",
2399      OutFNm.CStr(), GetNodes(), GetEdges(), CnComV.Len(), FqClustV.Len(), MinClustSz, FqMore1k), "Cluster size", "Count", gpsLog);
2400  }
2401  void BuildPhraseInvertIdx(const PQuoteBs& QtBs, TStrHash<TInt>& WordIdH, THash<TInt, TIntV>& WIdQtIdVH) {
2402    printf("build quote word inverted index\n");
2403    TIntV WIdV;
2404    TIntSet WIdSet;
2405    for (int q = 0; q < QtBs->Len(); q++) {
2406      const TQuote& Q = QtBs->GetQtN(q);
2407      TStrUtil::GetAddWIdV(WordIdH, Q.GetStr().CStr(), WIdV);
2408      const int Doms = Q.GetDoms(*QtBs);
2409      if (! (Doms>1 && Doms*4 > Q.GetUrls() && Q.GetFq() >= 5)) { 
2410        continue;
2411      }
2412      WIdSet.Clr(false); 
2413      for (int w = 0; w < WIdV.Len(); w++) {
2414        WIdSet.AddKey(WIdV[w]);
2415      }
2416      for (int w = 0; w < WIdSet.Len(); w++) {
2417        WIdQtIdVH.AddDat(WIdSet[w]).Add(q);
2418      }
2419    }
2420    for (int i = 0; i < WIdQtIdVH.Len(); i++) {
2421      WIdQtIdVH[i].Pack();
2422    }
2423    printf("done.\n");
2424  }
2425  bool IsLinkPhrases(const PQuoteBs& QtBs, const int& QtN1, const int& QtN2, TStrHash<TInt>& WordIdH, THash<TInt, TIntV>& QtToWordIdVH) {
2426    if (! QtToWordIdVH.IsKey(QtN1)) {
2427      TIntV WIdV;
2428      TStrUtil::GetWIdV(WordIdH, QtBs->GetQtN(QtN1).GetStr().CStr(), WIdV);
2429      WIdV.Pack();
2430      QtToWordIdVH.AddDat(QtN1, WIdV);
2431    }
2432    if (! QtToWordIdVH.IsKey(QtN2)) {
2433      TIntV WIdV;
2434      TStrUtil::GetWIdV(WordIdH, QtBs->GetQtN(QtN2).GetStr().CStr(), WIdV);
2435      WIdV.Pack();
2436      QtToWordIdVH.AddDat(QtN2, WIdV);
2437    }
2438    int idx1=0, idx2=0, SkipTy=0;
2439    const TIntV& WIdV1 = QtToWordIdVH.GetDat(QtN1);
2440    const TIntV& WIdV2 = QtToWordIdVH.GetDat(QtN2);
2441    const int ShortLen = TMath::Mn(WIdV1.Len(), WIdV2.Len());
2442    const int Overlap = TQuoteBs::LongestCmnSubSq(WIdV1, WIdV2, idx1, idx2, SkipTy);
2443    bool DoMerge = false;
2444    if (ShortLen <= 5 && Overlap == ShortLen &bsol;*&& SkipTy==0*/) { DoMerge=true; } 
2445    else if ((ShortLen == 6 && Overlap >= 5 &bsol;*&& SkipTy==0) || (ShortLen == 6 && Overlap == 5*/)) { DoMerge=true; }
2446    else if (Overlap/double(ShortLen+3) > 0.5 || Overlap > 10) { DoMerge=true; }
2447    return DoMerge;
2448  }
2449  PClustNet TClustNet::GetFromQtBs(const PQuoteBs& QtBs, int MinQtFq, int MnWrdLen) {
2450    TStrHash<TInt> WordIdH;
2451    THash<TInt, TIntV> WIdQtIdVH; 
2452    BuildPhraseInvertIdx(QtBs, WordIdH, WIdQtIdVH);
2453    PClustNet Net = TClustNet::New();
2454    TVec<int> QtSharCnt(QtBs->Len()), QtWrdLen(QtBs->Len());
2455    THash<TInt, TIntV> QtToWordIdVH;   
2456    TIntV WIdV;
2457    TIntH CandLenH, LinkLenH;
2458    THash<TInt, TIntH> QtLenCandH, QtLenLinkH;
2459    int AllCand=0, AllLinks=0;
2460    TExeTm ExeTm;
2461    for (int qt = 0; qt < QtBs->Len(); qt++) {
2462      QtWrdLen[qt] = TStrUtil::CountWords(QtBs->GetQtN(qt).GetStr().CStr());
2463    }
2464    const int QtBsLen = QtBs->Len();
2465    for (int qt = 0; qt < QtBs->Len(); qt++) {
2466      const TQuote& Q = QtBs->GetQtN(qt);
2467      const int Doms = Q.GetDoms(*QtBs);
2468    if (! (Doms>1 && Doms*4 > Q.GetUrls() && Q.GetFq() >= MinQtFq &&
2469      TStrUtil::CountWords(Q.GetStr())>=MnWrdLen)) {
2470        continue; }
2471      memset(QtSharCnt.BegI(), 0, sizeof(int)*QtSharCnt.Len());
2472      TStrUtil::GetWIdV(WordIdH, Q.GetStr().CStr(), WIdV);
2473      if (! QtToWordIdVH.IsKey(qt)) {
2474        WIdV.Pack();
2475        QtToWordIdVH.AddDat(qt, WIdV);
2476      }
2477      for (int w = 0; w < WIdV.Len(); w++) {
2478        IAssert(WIdQtIdVH.IsKey(WIdV[w]));
2479        const TIntV& QtIdV = WIdQtIdVH.GetDat(WIdV[w]);
2480        for (int q = 0; q < QtIdV.Len(); q++) {
2481          QtSharCnt[QtIdV[q]] += 1;
2482        }
2483      }
2484      const int W = WIdV.Len();
2485      int Candidates = 0, Links = 0, MinSharedWords = W-3;
2486      if (W <= 5) { MinSharedWords = W-1; }
2487      else if (W <= 10) { MinSharedWords = W-2; }
2488      for (int q = 0; q < QtSharCnt.Len(); q++) {
2489        if (QtSharCnt[q] >= MinSharedWords && (QtWrdLen[q] >= W || QtWrdLen[q] > 20)) {
2490          const TQuote& Qt2 = QtBs->GetQtN(q);
2491          if (Doms>1 && Doms*4 > Q.GetUrls() && Q.GetFq() >= MinQtFq) { 
2492            if (IsLinkPhrases(QtBs, qt, q, WordIdH, QtToWordIdVH)) {    
2493              Net->AddLink(Q, Qt2);
2494              Links++;
2495            }
2496          }
2497          Candidates++;
2498        }
2499      }
2500      AllCand += Candidates;
2501      AllLinks += Links;
2502      CandLenH.AddDat(Candidates) += 1;
2503      LinkLenH.AddDat(Links) += 1;
2504      if (W < 21) {
2505        QtLenCandH.AddDat(W).AddDat(Candidates) += 1;
2506        QtLenLinkH.AddDat(W).AddDat(Links) += 1;
2507      }
2508      if (qt % 1000 == 0 || qt==QtBsLen-1) {
2509        printf("\r%d  %s    allCands: %d    allLinks: %d    nodes:%d", qt, ExeTm.GetStr(), AllCand, AllLinks, Net->GetNodes());
2510        if (qt % 100000 == 0 || qt==QtBsLen-1) {
2511          TGnuPlot::PlotValCntH(CandLenH, "qtNet-NCand", "Number of candidate links for each quote (candidate has at most 2*words)",
2512            "ClustNet: number of candidate quotes to create link to", "Count", gpsLog);
2513          TGnuPlot::PlotValCntH(LinkLenH, "qtNet-NLink", "Number of links for each quote (candidate has at most 2*words)",
2514            "ClustNet: number of out-links of a quote", "Count", gpsLog);
2515        }
2516      }
2517    }
2518    printf("done.\n");
2519    TGnuPlot::PlotValCntH(CandLenH, "qtNet-NCand", "Number of candidate links for each quote (candidate has at most 2*words)",
2520      "ClustNet: number of candidate quotes to create link to", "Count", gpsLog);
2521    TGnuPlot::PlotValCntH(LinkLenH, "qtNet-NLink", "Number of links for each quote (candidate has at most 2*words)",
2522      "ClustNet: number of out-links of a quote", "Count", gpsLog);
2523    return Net;
2524  }
2525  void TQuoteLoader::Clr() {
2526    PostTitleStr.Clr();
2527    PostUrlStr.Clr();
2528    PubTm = TSecTm();
2529    BlogUrlStr.Clr();
2530    BlogTitleStr.Clr();
2531    ContentStr.Clr();
2532    QuoteV.Clr(false);
2533    LinkV.Clr(false);
2534  }
2535  bool TQuoteLoader::LoadItem(TXmlLx& XmlLx) {
2536    static const TSecTm BegOfTm(2008,8,30, 0, 0, 0);
2537    Clr();
2538    try {
2539      EAssert(XmlLx.TagNm == "post");
2540      const TChA T = TStrUtil::GetXmlTagVal(XmlLx, "pubDate");
2541      PubTm = TSecTm(atoi(T.GetSubStr(0,3).CStr()), atoi(T.GetSubStr(5,6).CStr()), atoi(T.GetSubStr(8,9).CStr()),
2542        atoi(T.GetSubStr(11,12).CStr()), atoi(T.GetSubStr(14,15).CStr()), atoi(T.GetSubStr(17,18).CStr()));
2543      EAssert(PubTm > BegOfTm);
2544      PostUrlStr = TStrUtil::GetXmlTagVal(XmlLx, "postUrl");
2545      PostTitleStr = TStrUtil::GetXmlTagVal(XmlLx, "postTitle");
2546      BlogUrlStr = TStrUtil::GetXmlTagVal(XmlLx, "blogUrl");
2547      BlogTitleStr = TStrUtil::GetXmlTagVal(XmlLx, "blogTitle");
2548      ContentStr = TStrUtil::GetXmlTagVal(XmlLx, "content");
2549      while (XmlLx.GetSym()==xsySTag && XmlLx.TagNm=="q") {
2550        EAssert(XmlLx.GetSym() == xsyStr);
2551        QuoteV.Add(XmlLx.TxtChA);
2552        EAssert(XmlLx.GetSym() == xsyETag && XmlLx.TagNm=="q");
2553      }
2554    }
2555    catch (PExcept Except){
2556      ErrNotify(Except->GetStr());
2557      Fail;  return false;
2558    }
2559    return true;
2560  }
2561  void TQuoteLoader::Save(TSOut& SOut) const {
2562    PubTm.Save(SOut);
2563    PostUrlStr.Save(SOut);
2564    PostTitleStr.Save(SOut);
2565    BlogUrlStr.Save(SOut);
2566    BlogTitleStr.Save(SOut);
2567    ContentStr.Save(SOut);
2568    QuoteV.Save(SOut);
2569    LinkV.Save(SOut);
2570  }
2571  void TQuoteLoader::Load(TSIn& SIn) {
2572    PubTm.Load(SIn);
2573    PostUrlStr.Load(SIn);
2574    PostTitleStr.Load(SIn);
2575    BlogUrlStr.Load(SIn);
2576    BlogTitleStr.Load(SIn);
2577    ContentStr.Load(SIn);
2578    QuoteV.Load(SIn);
2579    LinkV.Load(SIn);
2580  }
2581  bool TQuoteLoader::Next() {
2582    if (SIn.Empty() || SIn->Eof()) {
2583      printf("  new file");
2584      if (! FFile.Next(CurFNm)) { return false; }
2585      printf(" %s\n", CurFNm.GetFMid().CStr());
2586      SIn = TZipIn::IsZipExt(CurFNm.GetFExt()) ? PSIn(new TZipIn(CurFNm)) : PSIn(new TFIn(CurFNm));
2587      StartProcFile(CurFNm);
2588    }
2589    Load(*SIn);
2590    if (++PostCnt % Kilo(10) == 0) { printf("\r  %dk [%s]  ", PostCnt/Kilo(1), ExeTm.GetStr()); }
2591    return true;
2592  }
2593  void TQuoteLoader::ProcessPosts(const bool& IsXml, int LoadN) {
2594    TExeTm ExeTm, TotalTm;
2595    StartProcess();
2596    if (LoadN < 0) { LoadN = TInt::Mx; }
2597    int FilePostCnt=0;
2598    for (int f = 1; FFile.Next(CurFNm); f++) {
2599      printf("*** FILE:  %s\n", CurFNm.GetFMid().CStr());
2600      SIn = TZipIn::IsZipExt(CurFNm.GetFExt()) ? PSIn(new TZipIn(CurFNm)) : PSIn(new TFIn(CurFNm));
2601      if (IsXml) {
2602        TXmlLx XmlLx(SIn, xspTruncate);
2603        StartProcFile(CurFNm);
2604        for (FilePostCnt=0; XmlLx.GetSym() != xsyEof; FilePostCnt++, PostCnt++) {
2605          if (! (XmlLx.Sym==xsySTag && XmlLx.TagNm=="post")) {
2606            while (XmlLx.GetSym()!=xsyEof && ! (XmlLx.Sym==xsySTag && XmlLx.TagNm=="post")) { }
2607            if (XmlLx.Sym == xsyEof) { break; }
2608          }
2609          const bool IsGoodPost = LoadItem(XmlLx);
2610          ProcessPost(IsGoodPost);
2611          if (PostCnt % Kilo(1) == 0) {
2612            printf("\r%dk [%s] ", PostCnt/Kilo(1), ExeTm.GetStr()); }
2613          if (PostCnt >= LoadN) { break; }
2614        }
2615      } else {
2616        FilePostCnt = 0;
2617        while (! SIn->Eof()) {
2618          Load(*SIn);  FilePostCnt++;  PostCnt++;
2619          ProcessPost(true);
2620          if (PostCnt % Kilo(10) == 0) {
2621            printf("\r%dk [%s] ", PostCnt/Kilo(1), ExeTm.GetStr()); }
2622          if (PostCnt >= LoadN) { break; }
2623        }
2624      }
2625      printf("\n================================================================\n");
2626      printf("  file:  %s\n", CurFNm.GetFMid().CStr());
2627      printf("  time:  %s   ", ExeTm.GetStr());
2628      printf("total: %s [%s]\n", TotalTm.GetStr(), TExeTm::GetCurTm());
2629      printf("  posts: %d   total: %d\n", FilePostCnt, PostCnt);
2630      EndProcFile(CurFNm);
2631      fflush(stdout);  ExeTm.Tick();
2632      if (PostCnt >= LoadN) { break; }
2633    }
2634    EndProcess(PostCnt);
2635  }
2636  bool TMemesDataLoader::GetNextFile() {
2637    TStr FNm;
2638    if (! FFile.Empty()) {
2639      if (! FFile->Next(FNm)) { return false; }
2640      printf("NEXT-FL:  %s :\t%s\n", FNm.GetFBase().CStr(), TExeTm::GetCurTm());
2641    } else {
2642      IAssert(! InFNmF.Empty());
2643      if (InFNmF->Eof()) { return false; }
2644    while (! InFNmF->Eof() && InFNmF->GetNextLn(FNm) && FNm.Empty()) { }
2645      printf("NEXT-LN:  %s :\t%s\n", FNm.GetFBase().CStr(), TExeTm::GetCurTm());
2646    }
2647    if (FNm.Empty()) { return false; }
2648    if (TZipIn::IsZipExt(FNm.GetFExt())) {
2649      SInPt = TZipIn::New(FNm); }
2650    else {
2651      SInPt = TFIn::New(FNm); }  LineCnt = 0;
2652    return true;
2653  }
2654  void TMemesDataLoader::Clr() {
2655    PostUrlStr.Clr();
2656    ContentStr.Clr();
2657    PubTm = TSecTm();
2658    MemeV.Clr(false);
2659    MemePosV.Clr(false);
2660    LinkV.Clr(false);
2661    LinkPosV.Clr(false);
2662  }
2663  bool TMemesDataLoader::LoadNext() {
2664    Clr();
2665    if (SInPt.Empty() || SInPt->Eof()) {
2666      if (! GetNextFile()) { return false; }
2667    }
2668    TSIn& SIn = *SInPt;
2669    CurLn.Clr();
2670    while (SIn.GetNextLn(CurLn) && (CurLn.Empty() || (CurLn[0]!='U' || CurLn[1]!='\t'))) { 
2671      printf("L: %s\n", CurLn.CStr()); LineCnt++; }
2672    LineCnt++;
2673    if (CurLn.Empty()) { return LoadNext(); }
2674    IAssertR((! CurLn.Empty()) && CurLn[0]=='U' && CurLn[1]=='\t', 
2675      TStr::Fmt("ERROR1: %s [line %llu]: '%s'\n", SIn.GetSNm().CStr(), LineCnt, CurLn.CStr()).CStr());
2676    PostUrlStr = CurLn.CStr()+2;
2677    while (SIn.GetNextLn(CurLn) && (CurLn.Empty() || (CurLn[0]!='D' || CurLn[1]!='\t'))) { LineCnt++; }
2678    IAssertR((! CurLn.Empty()) && CurLn[0]=='D', 
2679      TStr::Fmt("ERROR2: %s [line %llu]: '%s'\n", SIn.GetSNm().CStr(), LineCnt, CurLn.CStr()).CStr());  LineCnt++;
2680    try {
2681      PubTm = TSecTm::GetDtTmFromStr(CurLn);
2682    } catch (PExcept Except){ PubTm = 1; ErrNotify(Except->GetStr());
2683      printf("ERROR3: %s [line %llu]: '%s'\n", SIn.GetSNm().CStr(), LineCnt, CurLn.CStr()); 
2684    }
2685    IAssertR(SIn.GetNextLn(CurLn) && (! CurLn.Empty()) && (CurLn[0]=='C' || CurLn[0]=='T'), 
2686      TStr::Fmt("ERROR4: %s [line %llu]: '%s'\n", SIn.GetSNm().CStr(), LineCnt, CurLn.CStr()).CStr());  LineCnt++;
2687    if (CurLn[0] == 'T') { 
2688      IAssertR(SIn.GetNextLn(CurLn) && (! CurLn.Empty()) && CurLn[0]=='C', 
2689        TStr::Fmt("ERROR5: %s [line %llu]: '%s'\n", SIn.GetSNm().CStr(), LineCnt, CurLn.CStr()).CStr());  LineCnt++; }
2690    ContentStr = CurLn.CStr()+2;
2691    while (SIn.GetNextLn(CurLn)) {  LineCnt++;
2692      if (CurLn.Empty() || CurLn[0]!='L') { break; }
2693      int linkb=2;
2694      while (CurLn[linkb]!='\t') { linkb++; }
2695      CurLn[linkb]=0;
2696      LinkV.Add(CurLn.CStr()+linkb+1);
2697      LinkPosV.Add(atoi(CurLn.CStr()+2));
2698    }
2699    do {
2700      if (CurLn.Empty() || CurLn[0]!='Q') { break; }
2701      int qb1=2;      while (CurLn[qb1]!='\t') { qb1++; }
2702      int qb2=qb1+1;  while (CurLn[qb2]!='\t') { qb2++; }
2703      CurLn[qb1]=0;  CurLn[qb2]=0;
2704      MemeV.Add(CurLn.CStr()+qb2+1);
2705      MemePosV.Add(TIntPr(atoi(CurLn.CStr()+2), atoi(CurLn.CStr()+qb1+1)));
2706      LineCnt++;
2707    } while (SIn.GetNextLn(CurLn));
2708    return true;
2709  }
2710  void TMemesDataLoader::SaveTxt(TSOut& SOut) const {
2711  }
2712  void TMemesDataLoader::Dump(const bool& DumpAll) const {
2713  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-linefind.cpp</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-memes.cpp</div>
                <div class="column column_space"><pre><code>173      for (int y = 0; y < height; ++y, data += wpl) {
174        for (int x = kCrackSpacing; x < width; x += kCrackSpacing) {
175          CLEAR_DATA_BIT(data, x);
176        }
177      }
178    } else {
</pre></code></div>
                <div class="column column_space"><pre><code>232    for (int q = 0; q < ClustQtIdVH.Len(); q++) {
233      CIdSet.AddKey(ClustQtIdVH.GetKey(q));
234      for (int c = 0; c < ClustQtIdVH[q].Len(); c++) {
235        CIdSet.AddKey(ClustQtIdVH[q][c]); } 
236      CIdSet.GetKeyV(ClustQtIdVH[q]);
237      ClustQtIdVH[q].Sort();
238      CIdSet.Clr(false);
239    }
240    Dump();
241  }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    