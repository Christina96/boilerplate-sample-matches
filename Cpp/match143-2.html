<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for basics.h & component.h</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for basics.h & component.h
      </h3>
      <h1 align="center">
        7.0%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>basics.h (19.23077%)<TH>component.h (4.3436294%)<TH>Tokens
<TR onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match143-0.html#0',2,'match143-1.html#0',3)" NAME="0">(193-209)<TD><A HREF="javascript:ZweiFrames('match143-0.html#0',2,'match143-1.html#0',3)" NAME="0">(562-586)</A><TD ALIGN=center><FONT COLOR="#ff0000">21</FONT>
<TR onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match143-0.html#1',2,'match143-1.html#1',3)" NAME="1">(113-124)<TD><A HREF="javascript:ZweiFrames('match143-0.html#1',2,'match143-1.html#1',3)" NAME="1">(720-732)</A><TD ALIGN=center><FONT COLOR="#910000">12</FONT>
<TR onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match143-0.html#2',2,'match143-1.html#2',3)" NAME="2">(97-108)<TD><A HREF="javascript:ZweiFrames('match143-0.html#2',2,'match143-1.html#2',3)" NAME="2">(59-70)</A><TD ALIGN=center><FONT COLOR="#910000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>basics.h</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
1 #ifndef FRUIT_META_BASICS_H
2 #define FRUIT_META_BASICS_H
3 #include &lt;functional&gt;
4 namespace fruit {
5 namespace impl {
6 namespace meta {
7 template &lt;typename T&gt;
8 struct Type {
9   using type = T;
10 };
11 template &lt;bool b&gt;
12 struct Bool {
13   static constexpr bool value = b;
14 };
15 template &lt;int n&gt;
16 struct Int {
17   static constexpr int value = n;
18 };
19 template &lt;typename N&gt;
20 constexpr int getIntValue() {
21   return N::value;
22 }
23 struct None {};
24 struct If {};
25 struct PropagateError {};
26 template &lt;typename ErrorTag, typename... ErrorArgs&gt;
27 struct Error {};
28 struct Catch {};
29 struct CatchAll {};
30 struct Call {
31   template &lt;typename F, typename... Args&gt;
32   struct apply : public F::template apply&lt;Args...&gt; {};
33 };
34 template &lt;typename WrappedType&gt;
35 using UnwrapType = typename WrappedType::type;
36 template &lt;typename WrappedType&gt;
37 struct TypeUnwrapper {
38   using type = UnwrapType&lt;WrappedType&gt;;
39 };
40 <A NAME="2"></A>struct And {
41   template &lt;typename... MetaExprs&gt;
42 <FONT color="#980517"><A HREF="javascript:ZweiFrames('match143-1.html#2',3,'match143-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>  struct apply {
43     using type = Bool&lt;true&gt;;
44   };
45   template &lt;typename MetaExpr&gt;
46   struct apply&lt;MetaExpr&gt; {
47     using type = MetaExpr;
48   };
49   template &lt;typename MetaExpr, typename MetaExpr2&gt;
50   struct apply&lt;MetaExpr, MetaExpr2&gt; {
51     using type = If(MetaExpr, MetaExpr2, Bool&lt;false&gt;);</B></FONT>
52   };
53 <A NAME="1"></A>
54   template &lt;typename MetaExpr, typename MetaExpr2, typename... MetaExprs&gt;
55   struct apply&lt;MetaExpr, MetaExpr2, MetaExprs...&gt; {
56 <FONT color="#f63526"><A HREF="javascript:ZweiFrames('match143-1.html#1',3,'match143-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>    using type = If(MetaExpr, If(MetaExpr2, And(MetaExprs...), Bool&lt;false&gt;), Bool&lt;false&gt;);
57   };
58 };
59 struct Or {
60   template &lt;typename... MetaExprs&gt;
61   struct apply {
62     using type = Bool&lt;false&gt;;
63   };
64   template &lt;typename MetaExpr&gt;</B></FONT>
65   struct apply&lt;MetaExpr&gt; {
66     using type = MetaExpr;
67   };
68   template &lt;typename MetaExpr, typename MetaExpr2&gt;
69   struct apply&lt;MetaExpr, MetaExpr2&gt; {
70     using type = If(MetaExpr, Bool&lt;true&gt;, MetaExpr2);
71   };
72   template &lt;typename MetaExpr, typename MetaExpr2, typename... MetaExprs&gt;
73   struct apply&lt;MetaExpr, MetaExpr2, MetaExprs...&gt; {
74     using type = If(MetaExpr, Bool&lt;true&gt;, If(MetaExpr2, Bool&lt;true&gt;, Or(MetaExprs...)));
75   };
76 };
77 struct DeferArgs {
78   template &lt;typename F&gt;
79   struct apply {
80     struct type {
81       template &lt;typename... Args&gt;
82       struct apply {
83         struct type {
84           template &lt;typename... MoreArgs&gt;
85           struct apply {
86             using type = F(Args..., MoreArgs...);
87           };
88         };
89       };
90     };
91   };
92 };
93 struct PartialCall {
94   template &lt;typename F, typename... Args&gt;
95   struct apply {
96     struct type {
97       template &lt;typename... MoreArgs&gt;
98       struct apply {
99         using type = F(Args..., MoreArgs...);
100       };
101     };
102   };
103 };
104 struct IsSame {
105   template &lt;typename T, typename U&gt;
106   struct apply {
107 <A NAME="0"></A>    using type = Bool&lt;false&gt;;
108   };
109 <FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match143-1.html#0',3,'match143-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>  template &lt;typename T&gt;
110   struct apply&lt;T, T&gt; {
111     using type = Bool&lt;true&gt;;
112   };
113 };
114 struct Not {
115   template &lt;typename B&gt;
116   struct apply {
117     using type = Bool&lt;!B::value&gt;;
118   };
119 };
120 struct IsNone {
121   template &lt;typename T&gt;
122   struct apply {
123     using type = Bool&lt;false&gt;;</B></FONT>
124   };
125 };
126 template &lt;&gt;
127 struct IsNone::apply&lt;None&gt; {
128   using type = Bool&lt;true&gt;;
129 };
130 template &lt;typename T&gt;
131 using Id = T;
132 struct Identity {
133   template &lt;typename T&gt;
134   struct apply {
135     using type = T;
136   };
137 };
138 template &lt;typename T&gt;
139 struct DebugTypeHelper {
140   static_assert(sizeof(T*) * 0 != 0, &quot;&quot;);
141   using type = T;
142 };
143 template &lt;typename T&gt;
144 using DebugType = typename DebugTypeHelper&lt;T&gt;::type;
145 } } } 
#endif </PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>component.h</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
1 #ifndef FRUIT_META_COMPONENT_H
2 #define FRUIT_META_COMPONENT_H
3 #include &lt;fruit/fruit_forward_decls.h&gt;
4 #include &lt;fruit/impl/fruit_internal_forward_decls.h&gt;
5 #include &lt;fruit/impl/injection_debug_errors.h&gt;
6 #include &lt;fruit/impl/meta/algos.h&gt;
7 #include &lt;fruit/impl/meta/errors.h&gt;
8 #include &lt;fruit/impl/meta/list.h&gt;
9 #include &lt;fruit/impl/meta/map.h&gt;
10 #include &lt;fruit/impl/meta/metaprogramming.h&gt;
11 #include &lt;fruit/impl/meta/numeric_operations.h&gt;
12 #include &lt;fruit/impl/meta/proof_trees.h&gt;
13 #include &lt;fruit/impl/meta/set.h&gt;
14 #include &lt;fruit/impl/meta/signatures.h&gt;
15 #include &lt;fruit/impl/meta/wrappers.h&gt;
16 #include &lt;memory&gt;
17 #include &lt;type_traits&gt;
18 namespace fruit {
19 namespace impl {
20 namespace meta {
21 struct GetClassForType {
22   template &lt;typename T&gt;
23   struct apply;
24   template &lt;typename T&gt;
25   struct apply&lt;Type&lt;T&gt;&gt; {
26     using type = Type&lt;T&gt;;
27 <A NAME="2"></A>  };
28   template &lt;typename T&gt;
29 <FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match143-0.html#2',2,'match143-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>  struct apply&lt;Type&lt;const T&gt;&gt; {
30     using type = Type&lt;T&gt;;
31   };
32   template &lt;typename T&gt;
33   struct apply&lt;Type&lt;T*&gt;&gt; {
34     using type = Type&lt;T&gt;;
35   };
36   template &lt;typename T&gt;
37   struct apply&lt;Type&lt;T&amp;&gt;&gt; {
38     using type = Type&lt;T&gt;;</B></FONT>
39   };
40   template &lt;typename T&gt;
41   struct apply&lt;Type&lt;const T*&gt;&gt; {
42     using type = Type&lt;T&gt;;
43   };
44   template &lt;typename T&gt;
45   struct apply&lt;Type&lt;const T&amp;&gt;&gt; {
46     using type = Type&lt;T&gt;;
47   };
48   template &lt;typename T&gt;
49   struct apply&lt;Type&lt;std::shared_ptr&lt;T&gt;&gt;&gt; {
50     using type = Type&lt;T&gt;;
51   };
52   template &lt;typename T&gt;
53   struct apply&lt;Type&lt;Assisted&lt;T&gt;&gt;&gt; {
54     using type = None;
55   };
56   template &lt;typename T&gt;
57   struct apply&lt;Type&lt;Provider&lt;T&gt;&gt;&gt; {
58     using type = Type&lt;T&gt;;
59   };
60   template &lt;typename T&gt;
61   struct apply&lt;Type&lt;Provider&lt;const T&gt;&gt;&gt; {
62     using type = Type&lt;T&gt;;
63   };
64   template &lt;typename Annotation, typename T&gt;
65   struct apply&lt;Type&lt;fruit::Annotated&lt;Annotation, T&gt;&gt;&gt; {
66     using type = Type&lt;T&gt;;
67   };
68 };
69 struct GetClassForTypeVector {
70   template &lt;typename V&gt;
71   struct apply {
72     using type = TransformVector(V, GetClassForType);
73   };
74 };
75 struct NormalizeType {
76   template &lt;typename T&gt;
77   struct apply;
78   template &lt;typename T&gt;
79   struct apply&lt;Type&lt;T&gt;&gt; {
80     using type = Type&lt;T&gt;;
81   };
82   template &lt;typename T&gt;
83   struct apply&lt;Type&lt;const T&gt;&gt; {
84     using type = Type&lt;T&gt;;
85   };
86   template &lt;typename T&gt;
87   struct apply&lt;Type&lt;T*&gt;&gt; {
88     using type = Type&lt;T&gt;;
89   };
90   template &lt;typename T&gt;
91   struct apply&lt;Type&lt;T&amp;&gt;&gt; {
92     using type = Type&lt;T&gt;;
93   };
94   template &lt;typename T&gt;
95   struct apply&lt;Type&lt;const T*&gt;&gt; {
96     using type = Type&lt;T&gt;;
97   };
98   template &lt;typename T&gt;
99   struct apply&lt;Type&lt;const T&amp;&gt;&gt; {
100     using type = Type&lt;T&gt;;
101   };
102   template &lt;typename T&gt;
103   struct apply&lt;Type&lt;std::shared_ptr&lt;T&gt;&gt;&gt; {
104     using type = Type&lt;T&gt;;
105   };
106   template &lt;typename T&gt;
107   struct apply&lt;Type&lt;Assisted&lt;T&gt;&gt;&gt; {
108     using type = None;
109   };
110   template &lt;typename T&gt;
111   struct apply&lt;Type&lt;Provider&lt;T&gt;&gt;&gt; {
112     using type = Type&lt;T&gt;;
113   };
114   template &lt;typename T&gt;
115   struct apply&lt;Type&lt;Provider&lt;const T&gt;&gt;&gt; {
116     using type = Type&lt;T&gt;;
117   };
118   template &lt;typename Annotation, typename T&gt;
119   struct apply&lt;Type&lt;fruit::Annotated&lt;Annotation, T&gt;&gt;&gt; {
120     using type = Type&lt;fruit::Annotated&lt;Annotation, UnwrapType&lt;Eval&lt;NormalizeType(Type&lt;T&gt;)&gt;&gt;&gt;&gt;;
121   };
122 };
123 struct NormalizeUntilStable {
124   template &lt;typename T&gt;
125   struct apply {
126     using type = If(IsSame(NormalizeType(T), T), T, NormalizeUntilStable(NormalizeType(T)));
127   };
128 };
129 struct NormalizeTypeVector {
130   template &lt;typename V&gt;
131   struct apply {
132     using type = TransformVector(V, NormalizeType);
133   };
134 };
135 struct TypeInjectionRequiresNonConstBinding {
136   template &lt;typename T&gt;
137   struct apply;
138   template &lt;typename T&gt;
139   struct apply&lt;Type&lt;T&gt;&gt; {
140     using type = Bool&lt;false&gt;;
141   };
142   template &lt;typename T&gt;
143   struct apply&lt;Type&lt;const T&gt;&gt; {
144     using type = Bool&lt;false&gt;;
145   };
146   template &lt;typename T&gt;
147   struct apply&lt;Type&lt;T*&gt;&gt; {
148     using type = Bool&lt;true&gt;;
149   };
150   template &lt;typename T&gt;
151   struct apply&lt;Type&lt;T&amp;&gt;&gt; {
152     using type = Bool&lt;true&gt;;
153   };
154   template &lt;typename T&gt;
155   struct apply&lt;Type&lt;const T*&gt;&gt; {
156     using type = Bool&lt;false&gt;;
157   };
158   template &lt;typename T&gt;
159   struct apply&lt;Type&lt;const T&amp;&gt;&gt; {
160     using type = Bool&lt;false&gt;;
161   };
162   template &lt;typename T&gt;
163   struct apply&lt;Type&lt;std::shared_ptr&lt;T&gt;&gt;&gt; {
164     using type = Bool&lt;true&gt;;
165   };
166   template &lt;typename T&gt;
167   struct apply&lt;Type&lt;Assisted&lt;T&gt;&gt;&gt; {
168     using type = Bool&lt;false&gt;;
169   };
170   template &lt;typename T&gt;
171   struct apply&lt;Type&lt;Provider&lt;T&gt;&gt;&gt; {
172     using type = Bool&lt;true&gt;;
173   };
174   template &lt;typename T&gt;
175   struct apply&lt;Type&lt;Provider&lt;const T&gt;&gt;&gt; {
176     using type = Bool&lt;false&gt;;
177   };
178   template &lt;typename Annotation, typename T&gt;
179   struct apply&lt;Type&lt;fruit::Annotated&lt;Annotation, T&gt;&gt;&gt; {
180     using type = TypeInjectionRequiresNonConstBinding(Type&lt;T&gt;);
181   };
182 };
183 struct CopyAnnotation {
184   template &lt;typename AnnotatedT, typename U&gt;
185   struct apply;
186   template &lt;typename T, typename U&gt;
187   struct apply {
188     using type = U;
189   };
190   template &lt;typename Annotation, typename T, typename U&gt;
191   struct apply&lt;Type&lt;fruit::Annotated&lt;Annotation, T&gt;&gt;, Type&lt;U&gt;&gt; {
192     using type = Type&lt;fruit::Annotated&lt;Annotation, U&gt;&gt;;
193   };
194 };
195 struct IsValidSignature {
196   template &lt;typename Signature&gt;
197   struct apply {
198     using type = Bool&lt;false&gt;;
199   };
200   template &lt;typename T, typename... Args&gt;
201   struct apply&lt;Type&lt;T(Args...)&gt;&gt; {
202     using type = Bool&lt;true&gt;;
203   };
204 };
205 struct RemoveAnnotations {
206   template &lt;typename T&gt;
207   struct apply;
208   template &lt;typename T&gt;
209   struct apply&lt;Type&lt;T&gt;&gt; {
210     using type = Type&lt;T&gt;;
211   };
212   template &lt;typename Annotation, typename T&gt;
213   struct apply&lt;Type&lt;fruit::Annotated&lt;Annotation, T&gt;&gt;&gt; {
214     using type = Type&lt;T&gt;;
215   };
216 };
217 struct RemoveAnnotationsFromSignature {
218   template &lt;typename AnnotatedSignature&gt;
219   struct apply {
220     using type = ConstructError(NotASignatureErrorTag, AnnotatedSignature);
221   };
222   template &lt;typename AnnotatedT, typename... AnnotatedArgs&gt;
223   struct apply&lt;Type&lt;AnnotatedT(AnnotatedArgs...)&gt;&gt; {
224     using type = ConsSignature(RemoveAnnotations(Type&lt;AnnotatedT&gt;), Id&lt;RemoveAnnotations(Type&lt;AnnotatedArgs&gt;)&gt;...);
225   };
226 };
227 struct RemoveAnnotationsFromVector {
228   template &lt;typename V&gt;
229   struct apply {
230     using type = TransformVector(V, RemoveAnnotations);
231   };
232 };
233 struct AddPointerInAnnotatedType {
234   template &lt;typename T&gt;
235   struct apply;
236   template &lt;typename T&gt;
237   struct apply&lt;Type&lt;T&gt;&gt; {
238     using type = Type&lt;T*&gt;;
239   };
240   template &lt;typename Annotation, typename T&gt;
241   struct apply&lt;Type&lt;fruit::Annotated&lt;Annotation, T&gt;&gt;&gt; {
242     using type = Type&lt;fruit::Annotated&lt;Annotation, T*&gt;&gt;;
243   };
244 };
245 struct RemoveNonAssisted {
246   template &lt;typename V&gt;
247   struct apply {
248     struct Helper {
249       template &lt;typename CurrentResult, typename T&gt;
250       struct apply {
251         using type = CurrentResult;
252       };
253       template &lt;typename CurrentResult, typename T&gt;
254       struct apply&lt;CurrentResult, Type&lt;Assisted&lt;T&gt;&gt;&gt; {
255         using type = PushBack(CurrentResult, Type&lt;T&gt;);
256       };
257     };
258     using type = FoldVector(V, Helper, Vector&lt;&gt;);
259   };
260 };
261 struct RemoveAssisted {
262   template &lt;typename V&gt;
263   struct apply {
264     struct Helper {
265       template &lt;typename CurrentResult, typename T&gt;
266       struct apply {
267         using type = PushBack(CurrentResult, T);
268       };
269       template &lt;typename CurrentResult, typename T&gt;
270       struct apply&lt;CurrentResult, Type&lt;Assisted&lt;T&gt;&gt;&gt; {
271         using type = CurrentResult;
272       };
273     };
274     using type = FoldVector(V, Helper, Vector&lt;&gt;);
275   };
276 };
277 struct UnlabelAssistedSingleType {
278   template &lt;typename T&gt;
279   struct apply;
280   template &lt;typename T&gt;
281   struct apply&lt;Type&lt;T&gt;&gt; {
282     using type = Type&lt;T&gt;;
283   };
284   template &lt;typename T&gt;
285   struct apply&lt;Type&lt;Assisted&lt;T&gt;&gt;&gt; {
286     using type = Type&lt;T&gt;;
287   };
288 };
289 struct UnlabelAssisted {
290   template &lt;typename V&gt;
291   struct apply {
292     using type = TransformVector(V, UnlabelAssistedSingleType);
293   };
294 };
295 struct RequiredLambdaArgsForAssistedFactory {
296   template &lt;typename AnnotatedSignature&gt;
297   struct apply {
298     using type = RemoveAnnotationsFromVector(UnlabelAssisted(SignatureArgs(AnnotatedSignature)));
299   };
300 };
301 struct RequiredLambdaSignatureForAssistedFactory {
302   template &lt;typename AnnotatedSignature&gt;
303   struct apply {
304     using type = ConsSignatureWithVector(RemoveAnnotations(SignatureType(AnnotatedSignature)),
305                                          RequiredLambdaArgsForAssistedFactory(AnnotatedSignature));
306   };
307 };
308 struct InjectedFunctionArgsForAssistedFactory {
309   template &lt;typename AnnotatedSignature&gt;
310   struct apply {
311     using type = RemoveNonAssisted(SignatureArgs(AnnotatedSignature));
312   };
313 };
314 struct InjectedSignatureForAssistedFactory {
315   template &lt;typename AnnotatedSignature&gt;
316   struct apply {
317     using type = ConsSignatureWithVector(RemoveAnnotations(SignatureType(AnnotatedSignature)),
318                                          InjectedFunctionArgsForAssistedFactory(AnnotatedSignature));
319   };
320 };
321 struct IsAssisted {
322   template &lt;typename T&gt;
323   struct apply {
324     using type = Bool&lt;false&gt;;
325   };
326   template &lt;typename T&gt;
327   struct apply&lt;Type&lt;Assisted&lt;T&gt;&gt;&gt; {
328     using type = Bool&lt;true&gt;;
329   };
330 };
331 struct NumAssisted {
332   template &lt;typename V&gt;
333   struct apply;
334   template &lt;typename... Types&gt;
335   struct apply&lt;Vector&lt;Types...&gt;&gt; {
336     using type = SumAll(typename IsAssisted::apply&lt;Types&gt;::type...);
337   };
338 };
339 struct NumAssistedBefore {
340   template &lt;typename Index, typename V&gt;
341   struct apply;
342   template &lt;typename V&gt;
343   struct apply&lt;Int&lt;0&gt;, V&gt; {
344     using type = Int&lt;0&gt;;
345   };
346   template &lt;int n, typename V&gt;
347   struct apply&lt;Int&lt;n&gt;, V&gt; {
348     using N = Int&lt;n&gt;;
349     using type = Minus(NumAssisted(V), NumAssisted(VectorRemoveFirstN(V, N)));
350   };
351 };
352 struct HasInjectAnnotation {
353   template &lt;typename C&gt;
354   struct apply;
355   template &lt;typename C&gt;
356   struct apply&lt;Type&lt;C&gt;&gt; {
357     template &lt;typename C1&gt;
358     static Bool&lt;true&gt; test(typename C1::Inject*);
359     template &lt;typename&gt;
360     static Bool&lt;false&gt; test(...);
361     using type = decltype(test&lt;C&gt;(nullptr));
362   };
363 };
364 struct DoGetInjectAnnotation {
365   template &lt;typename C&gt;
366   struct apply;
367   template &lt;typename C&gt;
368   struct apply&lt;Type&lt;C&gt;&gt; {
369     using type = Type&lt;typename C::Inject&gt;;
370   };
371 };
372 struct GetInjectAnnotation {
373   template &lt;typename AnnotatedC&gt;
374   struct apply {
375     using C = RemoveAnnotations(AnnotatedC);
376     using DecoratedS = DoGetInjectAnnotation(C);
377     using SResult = SignatureType(DecoratedS);
378     using AnnotatedSArgs = SignatureArgs(DecoratedS);
379     using SArgs = RemoveAnnotationsFromVector(UnlabelAssisted(AnnotatedSArgs));
380     using AnnotatedDecoratedS = ConsSignatureWithVector(AnnotatedC, AnnotatedSArgs);
381     using type = If(IsAbstract(C), ConstructError(CannotConstructAbstractClassErrorTag, C),
382                     If(Not(IsValidSignature(DecoratedS)),
383                        ConstructError(InjectTypedefNotASignatureErrorTag, C, DecoratedS),
384                        If(Not(IsSame(SResult, RemoveAnnotations(SResult))),
385                           ConstructError(InjectTypedefWithAnnotationErrorTag, C),
386                           If(Not(IsSame(C, SResult)), ConstructError(InjectTypedefForWrongClassErrorTag, C, SResult),
387                              If(Not(IsConstructibleWithVector(C, SArgs)),
388                                 ConstructError(NoConstructorMatchingInjectSignatureErrorTag, C,
389                                                ConsSignatureWithVector(SResult, SArgs)),
390                                 AnnotatedDecoratedS)))));
391   };
392 };
393 template &lt;typename RsSupersetParam, typename PsParam, typename NonConstRsPsParam,
394 #if !FRUIT_NO_LOOP_CHECK
395           typename DepsParam,
396 #endif
397           typename InterfaceBindingsParam, typename DeferredBindingFunctorsParam&gt;
398 struct Comp {
399   using RsSuperset = RsSupersetParam;
400   using Ps = PsParam;
401   using NonConstRsPs = NonConstRsPsParam;
402 #if !FRUIT_NO_LOOP_CHECK
403   using Deps = DepsParam;
404 #endif
405   using InterfaceBindings = InterfaceBindingsParam;
406   using DeferredBindingFunctors = DeferredBindingFunctorsParam;
407 };
408 <A NAME="0"></A>struct ConsComp {
409 <FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match143-0.html#0',2,'match143-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>  template &lt;typename RsSupersetParam, typename PsParam, typename NonConstRsPsParam,
410 #if !FRUIT_NO_LOOP_CHECK
411             typename DepsParam,
412 #endif
413             typename InterfaceBindingsParam, typename DeferredBindingFunctorsParam&gt;
414   struct apply {
415     using type = Comp&lt;RsSupersetParam, PsParam, NonConstRsPsParam,
416 #if !FRUIT_NO_LOOP_CHECK
417                       DepsParam,
418 #endif
419                       InterfaceBindingsParam, DeferredBindingFunctorsParam&gt;;
420   };
421 };
422 struct GetComponentDeps {
423   template &lt;typename Comp&gt;
424   struct apply {
425     using type = typename Comp::Deps;
426   };
427 };
428 struct GetComponentPs {
429   template &lt;typename Comp&gt;
430   struct apply {
431     using type = typename Comp::Ps;</B></FONT>
432   };
433 };
434 struct GetComponentRsSuperset {
435   template &lt;typename Comp&gt;
436   struct apply {
437     using type = typename Comp::RsSuperset;
438   };
439 };
440 struct GetComponentNonConstRsPs {
441   template &lt;typename Comp&gt;
442   struct apply {
443     using type = typename Comp::NonConstRsPs;
444   };
445 };
446 struct IsInjectableBareType {
447   template &lt;typename T&gt;
448   struct apply;
449   template &lt;typename T&gt;
450   struct apply&lt;Type&lt;T&gt;&gt; {
451     using type = Bool&lt;std::is_arithmetic&lt;T&gt;::value || std::is_class&lt;T&gt;::value || std::is_enum&lt;T&gt;::value&gt;;
452   };
453   template &lt;typename Annotation, typename T&gt;
454   struct apply&lt;Type&lt;fruit::Annotated&lt;Annotation, T&gt;&gt;&gt; {
455     using type = Bool&lt;false&gt;;
456   };
457   template &lt;typename T&gt;
458   struct apply&lt;Type&lt;std::shared_ptr&lt;T&gt;&gt;&gt; {
459     using type = Bool&lt;false&gt;;
460   };
461 };
462 struct IsInjectableType {
463   template &lt;typename T&gt;
464   struct apply {
465     using type = IsInjectableBareType(NormalizeType(T));
466   };
467 };
468 struct CheckInjectableType {
469   template &lt;typename T&gt;
470   struct apply {
471     using type = If(Not(IsInjectableType(T)), ConstructError(NonInjectableTypeErrorTag, T), None);
472   };
473 };
474 struct CheckInjectableTypeVector {
475   struct Helper {
476     template &lt;typename CurrentResult, typename T&gt;
477     struct apply {
478       using type = PropagateError(CheckInjectableType(T), CurrentResult);
479     };
480   };
481   template &lt;typename V&gt;
482   struct apply {
483     using type = FoldVector(V, Helper, None);
484   };
485 };
486 struct CheckNormalizedTypes {
487   template &lt;typename V&gt;
488   struct apply;
489   template &lt;typename... Types&gt;
490   struct apply&lt;Vector&lt;Type&lt;Types&gt;...&gt;&gt; {
491     struct Helper {
492       template &lt;typename CurrentResult, typename T&gt;
493       struct apply {
494         using NormalizedType = NormalizeType(T);
495         using type = PropagateError(CheckInjectableType(RemoveAnnotations(NormalizeUntilStable(T))),
496                                     If(Not(IsSame(NormalizeType(T), T)),
497                                        ConstructError(NonClassTypeErrorTag, RemoveAnnotations(T),
498                                                       RemoveAnnotations(NormalizeUntilStable(T))),
499                                        CurrentResult));
500       };
501     };
502     using type = Fold(Helper, None, Type&lt;Types&gt;...);
503   };
504 };
505 struct CheckNotAnnotatedTypes {
506   template &lt;typename V&gt;
507   struct apply;
508   template &lt;typename... Types&gt;
509   struct apply&lt;Vector&lt;Type&lt;Types&gt;...&gt;&gt; {
510     struct Helper {
511       template &lt;typename CurrentResult, typename T&gt;
512       struct apply {
513         using TypeWithoutAnnotations = RemoveAnnotations(T);
514         using type = If(Not(IsSame(TypeWithoutAnnotations, T)),
515                         ConstructError(AnnotatedTypeErrorTag, T, TypeWithoutAnnotations), CurrentResult);
516       };
517     };
518     using type = Fold(Helper, None, Type&lt;Types&gt;...);
519   };
520 };
521 struct CheckNoRequiredTypesInComponentArguments {
522   template &lt;typename V&gt;
523   struct apply;
524   template &lt;typename... Types&gt;
525   struct apply&lt;Vector&lt;Types...&gt;&gt; {
526     using type = None;
527   };
528   template &lt;typename T, typename... OtherTypes&gt;
529   struct apply&lt;Vector&lt;Type&lt;T&gt;, OtherTypes...&gt;&gt; {
530     using type = CheckNoRequiredTypesInComponentArguments(Vector&lt;OtherTypes...&gt;);
531   };
532 <A NAME="1"></A>
533   template &lt;typename... RequiredArgs, typename... OtherTypes&gt;
534   struct apply&lt;Vector&lt;Type&lt;fruit::Required&lt;RequiredArgs...&gt;&gt;, OtherTypes...&gt;&gt; {
535 <FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match143-0.html#1',2,'match143-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>    using type = ConstructError(RequiredTypesInComponentArgumentsErrorTag, Type&lt;fruit::Required&lt;RequiredArgs...&gt;&gt;);
536   };
537 };
538 struct CheckNoRequiredTypesInInjectorArguments {
539   template &lt;typename... Types&gt;
540   struct apply {
541     using type = None;
542   };
543   template &lt;typename T, typename... Types&gt;</B></FONT>
544   struct apply&lt;T, Types...&gt; {
545     using type = CheckNoRequiredTypesInInjectorArguments(Types...);
546   };
547   template &lt;typename... RequiredArgs, typename... Types&gt;
548   struct apply&lt;Type&lt;fruit::Required&lt;RequiredArgs...&gt;&gt;, Types...&gt; {
549     using type = ConstructError(InjectorWithRequirementsErrorTag, Type&lt;RequiredArgs&gt;...);
550   };
551 };
552 struct CheckNoRepeatedTypes {
553   template &lt;typename V&gt;
554   struct apply;
555   template &lt;typename... Types&gt;
556   struct apply&lt;Vector&lt;Types...&gt;&gt; {
557     using type = If(HasDuplicates(Vector&lt;Types...&gt;), ConstructError(RepeatedTypesErrorTag, Types...), None);
558   };
559 };
560 struct RemoveConstFromType {
561   template &lt;typename T&gt;
562   struct apply;
563   template &lt;typename T&gt;
564   struct apply&lt;Type&lt;T&gt;&gt; {
565     using type = Type&lt;T&gt;;
566   };
567   template &lt;typename T&gt;
568   struct apply&lt;Type&lt;const T&gt;&gt; {
569     using type = Type&lt;T&gt;;
570   };
571   template &lt;typename Annotation, typename T&gt;
572   struct apply&lt;Type&lt;fruit::Annotated&lt;Annotation, T&gt;&gt;&gt; {
573     using type = Type&lt;fruit::Annotated&lt;Annotation, T&gt;&gt;;
574   };
575   template &lt;typename Annotation, typename T&gt;
576   struct apply&lt;Type&lt;fruit::Annotated&lt;Annotation, const T&gt;&gt;&gt; {
577     using type = Type&lt;fruit::Annotated&lt;Annotation, T&gt;&gt;;
578   };
579 };
580 struct RemoveConstFromTypes {
581   template &lt;typename V&gt;
582   struct apply;
583   template &lt;typename... Types&gt;
584   struct apply&lt;Vector&lt;Types...&gt;&gt; {
585     using type = ConsVector(Id&lt;RemoveConstFromType(Types)&gt;...);
586   };
587 };
588 struct RemoveConstTypes {
589   struct Helper {
590     template &lt;typename Acc, typename T&gt;
591     struct apply;
592     template &lt;typename... AccContent, typename T&gt;
593     struct apply&lt;Vector&lt;AccContent...&gt;, Type&lt;const T&gt;&gt; {
594       using type = Vector&lt;AccContent...&gt;;
595     };
596     template &lt;typename... AccContent, typename T&gt;
597     struct apply&lt;Vector&lt;AccContent...&gt;, Type&lt;T&gt;&gt; {
598       using type = Vector&lt;AccContent..., Type&lt;T&gt;&gt;;
599     };
600     template &lt;typename... AccContent, typename Annotation, typename T&gt;
601     struct apply&lt;Vector&lt;AccContent...&gt;, Type&lt;fruit::Annotated&lt;Annotation, const T&gt;&gt;&gt; {
602       using type = Vector&lt;AccContent...&gt;;
603     };
604     template &lt;typename... AccContent, typename Annotation, typename T&gt;
605     struct apply&lt;Vector&lt;AccContent...&gt;, Type&lt;fruit::Annotated&lt;Annotation, T&gt;&gt;&gt; {
606       using type = Vector&lt;AccContent..., Type&lt;fruit::Annotated&lt;Annotation, T&gt;&gt;&gt;;
607     };
608   };
609   template &lt;typename V&gt;
610   struct apply {
611     using type = FoldVector(V, Helper, Vector&lt;&gt;);
612   };
613 };
614 struct NormalizedNonConstTypesIn {
615   struct Helper {
616     template &lt;typename Acc, typename T&gt;
617     struct apply {
618       using type = If(TypeInjectionRequiresNonConstBinding(T), PushBack(Acc, NormalizeType(T)), Acc);
619     };
620   };
621   template &lt;typename V&gt;
622   struct apply {
623     using type = FoldVector(V, Helper, Vector&lt;&gt;);
624   };
625 };
626 struct ConstructComponentImpl {
627   template &lt;typename... Ps&gt;
628   struct apply {
629     using type = PropagateError(
630         CheckNoRepeatedTypes(RemoveConstFromTypes(Vector&lt;Ps...&gt;)),
631         PropagateError(CheckNormalizedTypes(RemoveConstFromTypes(Vector&lt;Ps...&gt;)),
632                        PropagateError(CheckNoRequiredTypesInComponentArguments(Vector&lt;Ps...&gt;),
633                                       ConsComp(EmptySet, VectorToSetUnchecked(RemoveConstFromTypes(Vector&lt;Ps...&gt;)),
634                                                RemoveConstTypes(Vector&lt;Ps...&gt;),
635 #if !FRUIT_NO_LOOP_CHECK
636                                                Vector&lt;Pair&lt;Ps, Vector&lt;&gt;&gt;...&gt;,
637 #endif
638                                                Vector&lt;&gt;, EmptyList))));
639   };
640   template &lt;typename... Rs, typename... Ps&gt;
641   struct apply&lt;Type&lt;Required&lt;Rs...&gt;&gt;, Ps...&gt; {
642     using type1 = PropagateError(
643         CheckNoRepeatedTypes(RemoveConstFromTypes(Vector&lt;Type&lt;Rs&gt;..., Ps...&gt;)),
644         PropagateError(CheckNormalizedTypes(RemoveConstFromTypes(Vector&lt;Type&lt;Rs&gt;..., Ps...&gt;)),
645                        PropagateError(CheckNoRequiredTypesInComponentArguments(Vector&lt;Ps...&gt;),
646                                       ConsComp(VectorToSetUnchecked(RemoveConstFromTypes(Vector&lt;Type&lt;Rs&gt;...&gt;)),
647                                                VectorToSetUnchecked(RemoveConstFromTypes(Vector&lt;Ps...&gt;)),
648                                                RemoveConstTypes(Vector&lt;Type&lt;Rs&gt;..., Ps...&gt;),
649 #if !FRUIT_NO_LOOP_CHECK
650                                                Vector&lt;Pair&lt;Ps, Vector&lt;Type&lt;Rs&gt;...&gt;&gt;...&gt;,
651 #endif
652                                                Vector&lt;&gt;, EmptyList))));
653 #if !FRUIT_NO_LOOP_CHECK &amp;&amp; FRUIT_EXTRA_DEBUG
654     using Loop = ProofForestFindLoop(GetComponentDeps(type1));
655     using type = If(IsNone(Loop), type1, ConstructErrorWithArgVector(SelfLoopErrorTag, Loop));
656 #else      using type = type1;
657 #endif   };
658 };
659 struct CheckTypesNotProvidedAsConst {
660   template &lt;typename Comp, typename V&gt;
661   struct apply {
662     struct Helper {
663       template &lt;typename Acc, typename T&gt;
664       struct apply {
665         using type = If(And(IsInSet(T, typename Comp::Ps), Not(IsInSet(T, typename Comp::NonConstRsPs))),
666                         ConstructError(NonConstBindingRequiredButConstBindingProvidedErrorTag, T), Acc);
667       };
668     };
669     using type = FoldVector(V, Helper, None);
670   };
671 };
672 struct AddRequirements {
673   template &lt;typename Comp, typename NewRequirementsVector, typename NewNonConstRequirementsVector&gt;
674   struct apply {
675     using Comp1 = ConsComp(FoldVector(NewRequirementsVector, AddToSet, typename Comp::RsSuperset), typename Comp::Ps,
676                            FoldVector(NewNonConstRequirementsVector, AddToSet, typename Comp::NonConstRsPs),
677 #if !FRUIT_NO_LOOP_CHECK
678                            typename Comp::Deps,
679 #endif
680                            typename Comp::InterfaceBindings, typename Comp::DeferredBindingFunctors);
681     using type = PropagateError(CheckTypesNotProvidedAsConst(Comp, NewNonConstRequirementsVector), Comp1);
682   };
683 };
684 struct AddProvidedTypeIgnoringInterfaceBindings {
685   template &lt;typename Comp, typename C, typename IsNonConst, typename CRequirements, typename CNonConstRequirements&gt;
686   struct apply {
687     using Comp1 = ConsComp(
688         FoldVector(CRequirements, AddToSet, typename Comp::RsSuperset), AddToSetUnchecked(typename Comp::Ps, C),
689         If(IsNonConst, AddToSetUnchecked(FoldVector(CNonConstRequirements, AddToSet, typename Comp::NonConstRsPs), C),
690            FoldVector(CNonConstRequirements, AddToSet, typename Comp::NonConstRsPs)),
691 #if !FRUIT_NO_LOOP_CHECK
692         PushFront(typename Comp::Deps, Pair&lt;C, CRequirements&gt;),
693 #endif
694         typename Comp::InterfaceBindings, typename Comp::DeferredBindingFunctors);
695     using type = If(IsInSet(C, typename Comp::Ps), ConstructError(TypeAlreadyBoundErrorTag, C),
696                     PropagateError(CheckTypesNotProvidedAsConst(Comp, CNonConstRequirements), Comp1));
697   };
698 };
699 struct AddProvidedType {
700   template &lt;typename Comp, typename C, typename IsNonConst, typename CRequirements, typename CNonConstRequirements&gt;
701   struct apply {
702     using type = If(Not(IsNone(FindInMap(typename Comp::InterfaceBindings, C))),
703                     ConstructError(TypeAlreadyBoundErrorTag, C),
704                     AddProvidedTypeIgnoringInterfaceBindings(Comp, C, IsNonConst, CRequirements,
705                                                              CNonConstRequirements));
706   };
707 };
708 struct AddDeferredBinding {
709   template &lt;typename Comp, typename DeferredBinding&gt;
710   struct apply {
711     using new_DeferredBindingFunctors = Cons&lt;DeferredBinding, typename Comp::DeferredBindingFunctors&gt;;
712     using type = ConsComp(typename Comp::RsSuperset, typename Comp::Ps, typename Comp::NonConstRsPs,
713 #if !FRUIT_NO_LOOP_CHECK
714                           typename Comp::Deps,
715 #endif
716                           typename Comp::InterfaceBindings, new_DeferredBindingFunctors);
717   };
718 };
719 struct CheckNoLoopInDeps {
720   template &lt;typename Comp&gt;
721   struct apply {
722     using Loop = ProofForestFindLoop(typename Comp::Deps);
723     using type = If(IsNone(Loop), Bool&lt;true&gt;, ConstructErrorWithArgVector(SelfLoopErrorTag, Loop));
724   };
725 };
726 #if FRUIT_EXTRA_DEBUG || FRUIT_IN_META_TEST
727 struct CheckComponentEntails {
728   template &lt;typename Comp, typename EntailedComp&gt;
729   struct apply {
730     using CompRs = SetDifference(typename Comp::RsSuperset, typename Comp::Ps);
731     using EntailedCompRs = SetDifference(typename EntailedComp::RsSuperset, typename EntailedComp::Ps);
732     using CommonRs = SetIntersection(CompRs, EntailedCompRs);
733     using CommonPs = SetIntersection(typename Comp::Ps, typename EntailedComp::Ps);
734     using type =
735         If(Not(IsContained(typename EntailedComp::Ps, typename Comp::Ps)),
736            ConstructErrorWithArgVector(ComponentDoesNotEntailDueToProvidesErrorTag,
737                                        SetToVector(SetDifference(typename EntailedComp::Ps, typename Comp::Ps))),
738            If(Not(IsVectorContained(typename EntailedComp::InterfaceBindings, typename Comp::InterfaceBindings)),
739               ConstructErrorWithArgVector(ComponentDoesNotEntailDueToInterfaceBindingsErrorTag,
740                                           SetToVector(SetDifference(typename EntailedComp::InterfaceBindings,
741                                                                     typename Comp::InterfaceBindings))),
742               If(Not(IsContained(CompRs, EntailedCompRs)),
743                  ConstructErrorWithArgVector(ComponentDoesNotEntailDueToRequirementsErrorTag,
744                                              SetToVector(SetDifference(CompRs, EntailedCompRs))),
745                  If(Not(IsContained(SetIntersection(CommonRs, typename Comp::NonConstRsPs),
746                                     typename EntailedComp::NonConstRsPs)),
747                     ConstructErrorWithArgVector(ComponentDoesNotEntailDueToDifferentConstnessOfRequirementsErrorTag,
748                                                 SetToVector(SetDifference(SetIntersection(CommonRs,
749                                                                                           typename Comp::NonConstRsPs),
750                                                                           typename EntailedComp::NonConstRsPs))),
751                     If(Not(IsContained(SetIntersection(CommonPs, typename EntailedComp::NonConstRsPs),
752                                        typename Comp::NonConstRsPs)),
753                        ConstructErrorWithArgVector(
754                            ComponentDoesNotEntailDueToDifferentConstnessOfProvidesErrorTag,
755                            SetToVector(SetDifference(SetIntersection(CommonPs, typename EntailedComp::NonConstRsPs),
756                                                      typename Comp::NonConstRsPs))),
757                        Bool&lt;true&gt;)))));
758     static_assert(true || sizeof(typename CheckIfError&lt;Eval&lt;type&gt;&gt;::type), &quot;&quot;);
759   };
760 };
761 #endif 
762 struct ConstructNoBindingFoundError {
763   template &lt;typename AnnotatedC&gt;
764   struct apply {
765     using type = If(IsAbstract(RemoveAnnotations(AnnotatedC)),
766                     ConstructError(NoBindingFoundForAbstractClassErrorTag, AnnotatedC, RemoveAnnotations(AnnotatedC)),
767                     ConstructError(NoBindingFoundErrorTag, AnnotatedC));
768   };
769 };
770 } } } 
#endif </PRE>
</div>
  </div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
