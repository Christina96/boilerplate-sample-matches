<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for basics.h & component.h</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for basics.h & component.h
      </h3>
      <h1 align="center">
        7.0%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>basics.h (19.23077%)<TH>component.h (4.3436294%)<TH>Tokens
<TR onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match143-0.html#0',2,'match143-1.html#0',3)" NAME="0">(193-209)<TD><A HREF="javascript:ZweiFrames('match143-0.html#0',2,'match143-1.html#0',3)" NAME="0">(562-586)</A><TD ALIGN=center><FONT COLOR="#ff0000">21</FONT>
<TR onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match143-0.html#1',2,'match143-1.html#1',3)" NAME="1">(113-124)<TD><A HREF="javascript:ZweiFrames('match143-0.html#1',2,'match143-1.html#1',3)" NAME="1">(720-732)</A><TD ALIGN=center><FONT COLOR="#910000">12</FONT>
<TR onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match143-0.html#2',2,'match143-1.html#2',3)" NAME="2">(97-108)<TD><A HREF="javascript:ZweiFrames('match143-0.html#2',2,'match143-1.html#2',3)" NAME="2">(59-70)</A><TD ALIGN=center><FONT COLOR="#910000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>basics.h</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
#ifndef FRUIT_META_BASICS_H
#define FRUIT_META_BASICS_H
#include &lt;functional&gt;
namespace fruit {
namespace impl {
namespace meta {
template &lt;typename T&gt;
struct Type {
  using type = T;
};
template &lt;bool b&gt;
struct Bool {
  static constexpr bool value = b;
};
template &lt;int n&gt;
struct Int {
  static constexpr int value = n;
};
template &lt;typename N&gt;
constexpr int getIntValue() {
  return N::value;
}
struct None {};
struct If {};
struct PropagateError {};
template &lt;typename ErrorTag, typename... ErrorArgs&gt;
struct Error {};
struct Catch {};
struct CatchAll {};
struct Call {
  template &lt;typename F, typename... Args&gt;
  struct apply : public F::template apply&lt;Args...&gt; {};
};
template &lt;typename WrappedType&gt;
using UnwrapType = typename WrappedType::type;
template &lt;typename WrappedType&gt;
struct TypeUnwrapper {
  using type = UnwrapType&lt;WrappedType&gt;;
};
<A NAME="2"></A>struct And {
  template &lt;typename... MetaExprs&gt;
<FONT color="#980517"><A HREF="javascript:ZweiFrames('match143-1.html#2',3,'match143-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>  struct apply {
    using type = Bool&lt;true&gt;;
  };
  template &lt;typename MetaExpr&gt;
  struct apply&lt;MetaExpr&gt; {
    using type = MetaExpr;
  };
  template &lt;typename MetaExpr, typename MetaExpr2&gt;
  struct apply&lt;MetaExpr, MetaExpr2&gt; {
    using type = If(MetaExpr, MetaExpr2, Bool&lt;false&gt;);</B></FONT>
  };
<A NAME="1"></A>
  template &lt;typename MetaExpr, typename MetaExpr2, typename... MetaExprs&gt;
  struct apply&lt;MetaExpr, MetaExpr2, MetaExprs...&gt; {
<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match143-1.html#1',3,'match143-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>    using type = If(MetaExpr, If(MetaExpr2, And(MetaExprs...), Bool&lt;false&gt;), Bool&lt;false&gt;);
  };
};
struct Or {
  template &lt;typename... MetaExprs&gt;
  struct apply {
    using type = Bool&lt;false&gt;;
  };
  template &lt;typename MetaExpr&gt;</B></FONT>
  struct apply&lt;MetaExpr&gt; {
    using type = MetaExpr;
  };
  template &lt;typename MetaExpr, typename MetaExpr2&gt;
  struct apply&lt;MetaExpr, MetaExpr2&gt; {
    using type = If(MetaExpr, Bool&lt;true&gt;, MetaExpr2);
  };
  template &lt;typename MetaExpr, typename MetaExpr2, typename... MetaExprs&gt;
  struct apply&lt;MetaExpr, MetaExpr2, MetaExprs...&gt; {
    using type = If(MetaExpr, Bool&lt;true&gt;, If(MetaExpr2, Bool&lt;true&gt;, Or(MetaExprs...)));
  };
};
struct DeferArgs {
  template &lt;typename F&gt;
  struct apply {
    struct type {
      template &lt;typename... Args&gt;
      struct apply {
        struct type {
          template &lt;typename... MoreArgs&gt;
          struct apply {
            using type = F(Args..., MoreArgs...);
          };
        };
      };
    };
  };
};
struct PartialCall {
  template &lt;typename F, typename... Args&gt;
  struct apply {
    struct type {
      template &lt;typename... MoreArgs&gt;
      struct apply {
        using type = F(Args..., MoreArgs...);
      };
    };
  };
};
struct IsSame {
  template &lt;typename T, typename U&gt;
  struct apply {
<A NAME="0"></A>    using type = Bool&lt;false&gt;;
  };
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match143-1.html#0',3,'match143-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>  template &lt;typename T&gt;
  struct apply&lt;T, T&gt; {
    using type = Bool&lt;true&gt;;
  };
};
struct Not {
  template &lt;typename B&gt;
  struct apply {
    using type = Bool&lt;!B::value&gt;;
  };
};
struct IsNone {
  template &lt;typename T&gt;
  struct apply {
    using type = Bool&lt;false&gt;;</B></FONT>
  };
};
template &lt;&gt;
struct IsNone::apply&lt;None&gt; {
  using type = Bool&lt;true&gt;;
};
template &lt;typename T&gt;
using Id = T;
struct Identity {
  template &lt;typename T&gt;
  struct apply {
    using type = T;
  };
};
template &lt;typename T&gt;
struct DebugTypeHelper {
  static_assert(sizeof(T*) * 0 != 0, &quot;&quot;);
  using type = T;
};
template &lt;typename T&gt;
using DebugType = typename DebugTypeHelper&lt;T&gt;::type;
} } } 
#endif </PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>component.h</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
#ifndef FRUIT_META_COMPONENT_H
#define FRUIT_META_COMPONENT_H
#include &lt;fruit/fruit_forward_decls.h&gt;
#include &lt;fruit/impl/fruit_internal_forward_decls.h&gt;
#include &lt;fruit/impl/injection_debug_errors.h&gt;
#include &lt;fruit/impl/meta/algos.h&gt;
#include &lt;fruit/impl/meta/errors.h&gt;
#include &lt;fruit/impl/meta/list.h&gt;
#include &lt;fruit/impl/meta/map.h&gt;
#include &lt;fruit/impl/meta/metaprogramming.h&gt;
#include &lt;fruit/impl/meta/numeric_operations.h&gt;
#include &lt;fruit/impl/meta/proof_trees.h&gt;
#include &lt;fruit/impl/meta/set.h&gt;
#include &lt;fruit/impl/meta/signatures.h&gt;
#include &lt;fruit/impl/meta/wrappers.h&gt;
#include &lt;memory&gt;
#include &lt;type_traits&gt;
namespace fruit {
namespace impl {
namespace meta {
struct GetClassForType {
  template &lt;typename T&gt;
  struct apply;
  template &lt;typename T&gt;
  struct apply&lt;Type&lt;T&gt;&gt; {
    using type = Type&lt;T&gt;;
<A NAME="2"></A>  };
  template &lt;typename T&gt;
<FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match143-0.html#2',2,'match143-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>  struct apply&lt;Type&lt;const T&gt;&gt; {
    using type = Type&lt;T&gt;;
  };
  template &lt;typename T&gt;
  struct apply&lt;Type&lt;T*&gt;&gt; {
    using type = Type&lt;T&gt;;
  };
  template &lt;typename T&gt;
  struct apply&lt;Type&lt;T&amp;&gt;&gt; {
    using type = Type&lt;T&gt;;</B></FONT>
  };
  template &lt;typename T&gt;
  struct apply&lt;Type&lt;const T*&gt;&gt; {
    using type = Type&lt;T&gt;;
  };
  template &lt;typename T&gt;
  struct apply&lt;Type&lt;const T&amp;&gt;&gt; {
    using type = Type&lt;T&gt;;
  };
  template &lt;typename T&gt;
  struct apply&lt;Type&lt;std::shared_ptr&lt;T&gt;&gt;&gt; {
    using type = Type&lt;T&gt;;
  };
  template &lt;typename T&gt;
  struct apply&lt;Type&lt;Assisted&lt;T&gt;&gt;&gt; {
    using type = None;
  };
  template &lt;typename T&gt;
  struct apply&lt;Type&lt;Provider&lt;T&gt;&gt;&gt; {
    using type = Type&lt;T&gt;;
  };
  template &lt;typename T&gt;
  struct apply&lt;Type&lt;Provider&lt;const T&gt;&gt;&gt; {
    using type = Type&lt;T&gt;;
  };
  template &lt;typename Annotation, typename T&gt;
  struct apply&lt;Type&lt;fruit::Annotated&lt;Annotation, T&gt;&gt;&gt; {
    using type = Type&lt;T&gt;;
  };
};
struct GetClassForTypeVector {
  template &lt;typename V&gt;
  struct apply {
    using type = TransformVector(V, GetClassForType);
  };
};
struct NormalizeType {
  template &lt;typename T&gt;
  struct apply;
  template &lt;typename T&gt;
  struct apply&lt;Type&lt;T&gt;&gt; {
    using type = Type&lt;T&gt;;
  };
  template &lt;typename T&gt;
  struct apply&lt;Type&lt;const T&gt;&gt; {
    using type = Type&lt;T&gt;;
  };
  template &lt;typename T&gt;
  struct apply&lt;Type&lt;T*&gt;&gt; {
    using type = Type&lt;T&gt;;
  };
  template &lt;typename T&gt;
  struct apply&lt;Type&lt;T&amp;&gt;&gt; {
    using type = Type&lt;T&gt;;
  };
  template &lt;typename T&gt;
  struct apply&lt;Type&lt;const T*&gt;&gt; {
    using type = Type&lt;T&gt;;
  };
  template &lt;typename T&gt;
  struct apply&lt;Type&lt;const T&amp;&gt;&gt; {
    using type = Type&lt;T&gt;;
  };
  template &lt;typename T&gt;
  struct apply&lt;Type&lt;std::shared_ptr&lt;T&gt;&gt;&gt; {
    using type = Type&lt;T&gt;;
  };
  template &lt;typename T&gt;
  struct apply&lt;Type&lt;Assisted&lt;T&gt;&gt;&gt; {
    using type = None;
  };
  template &lt;typename T&gt;
  struct apply&lt;Type&lt;Provider&lt;T&gt;&gt;&gt; {
    using type = Type&lt;T&gt;;
  };
  template &lt;typename T&gt;
  struct apply&lt;Type&lt;Provider&lt;const T&gt;&gt;&gt; {
    using type = Type&lt;T&gt;;
  };
  template &lt;typename Annotation, typename T&gt;
  struct apply&lt;Type&lt;fruit::Annotated&lt;Annotation, T&gt;&gt;&gt; {
    using type = Type&lt;fruit::Annotated&lt;Annotation, UnwrapType&lt;Eval&lt;NormalizeType(Type&lt;T&gt;)&gt;&gt;&gt;&gt;;
  };
};
struct NormalizeUntilStable {
  template &lt;typename T&gt;
  struct apply {
    using type = If(IsSame(NormalizeType(T), T), T, NormalizeUntilStable(NormalizeType(T)));
  };
};
struct NormalizeTypeVector {
  template &lt;typename V&gt;
  struct apply {
    using type = TransformVector(V, NormalizeType);
  };
};
struct TypeInjectionRequiresNonConstBinding {
  template &lt;typename T&gt;
  struct apply;
  template &lt;typename T&gt;
  struct apply&lt;Type&lt;T&gt;&gt; {
    using type = Bool&lt;false&gt;;
  };
  template &lt;typename T&gt;
  struct apply&lt;Type&lt;const T&gt;&gt; {
    using type = Bool&lt;false&gt;;
  };
  template &lt;typename T&gt;
  struct apply&lt;Type&lt;T*&gt;&gt; {
    using type = Bool&lt;true&gt;;
  };
  template &lt;typename T&gt;
  struct apply&lt;Type&lt;T&amp;&gt;&gt; {
    using type = Bool&lt;true&gt;;
  };
  template &lt;typename T&gt;
  struct apply&lt;Type&lt;const T*&gt;&gt; {
    using type = Bool&lt;false&gt;;
  };
  template &lt;typename T&gt;
  struct apply&lt;Type&lt;const T&amp;&gt;&gt; {
    using type = Bool&lt;false&gt;;
  };
  template &lt;typename T&gt;
  struct apply&lt;Type&lt;std::shared_ptr&lt;T&gt;&gt;&gt; {
    using type = Bool&lt;true&gt;;
  };
  template &lt;typename T&gt;
  struct apply&lt;Type&lt;Assisted&lt;T&gt;&gt;&gt; {
    using type = Bool&lt;false&gt;;
  };
  template &lt;typename T&gt;
  struct apply&lt;Type&lt;Provider&lt;T&gt;&gt;&gt; {
    using type = Bool&lt;true&gt;;
  };
  template &lt;typename T&gt;
  struct apply&lt;Type&lt;Provider&lt;const T&gt;&gt;&gt; {
    using type = Bool&lt;false&gt;;
  };
  template &lt;typename Annotation, typename T&gt;
  struct apply&lt;Type&lt;fruit::Annotated&lt;Annotation, T&gt;&gt;&gt; {
    using type = TypeInjectionRequiresNonConstBinding(Type&lt;T&gt;);
  };
};
struct CopyAnnotation {
  template &lt;typename AnnotatedT, typename U&gt;
  struct apply;
  template &lt;typename T, typename U&gt;
  struct apply {
    using type = U;
  };
  template &lt;typename Annotation, typename T, typename U&gt;
  struct apply&lt;Type&lt;fruit::Annotated&lt;Annotation, T&gt;&gt;, Type&lt;U&gt;&gt; {
    using type = Type&lt;fruit::Annotated&lt;Annotation, U&gt;&gt;;
  };
};
struct IsValidSignature {
  template &lt;typename Signature&gt;
  struct apply {
    using type = Bool&lt;false&gt;;
  };
  template &lt;typename T, typename... Args&gt;
  struct apply&lt;Type&lt;T(Args...)&gt;&gt; {
    using type = Bool&lt;true&gt;;
  };
};
struct RemoveAnnotations {
  template &lt;typename T&gt;
  struct apply;
  template &lt;typename T&gt;
  struct apply&lt;Type&lt;T&gt;&gt; {
    using type = Type&lt;T&gt;;
  };
  template &lt;typename Annotation, typename T&gt;
  struct apply&lt;Type&lt;fruit::Annotated&lt;Annotation, T&gt;&gt;&gt; {
    using type = Type&lt;T&gt;;
  };
};
struct RemoveAnnotationsFromSignature {
  template &lt;typename AnnotatedSignature&gt;
  struct apply {
    using type = ConstructError(NotASignatureErrorTag, AnnotatedSignature);
  };
  template &lt;typename AnnotatedT, typename... AnnotatedArgs&gt;
  struct apply&lt;Type&lt;AnnotatedT(AnnotatedArgs...)&gt;&gt; {
    using type = ConsSignature(RemoveAnnotations(Type&lt;AnnotatedT&gt;), Id&lt;RemoveAnnotations(Type&lt;AnnotatedArgs&gt;)&gt;...);
  };
};
struct RemoveAnnotationsFromVector {
  template &lt;typename V&gt;
  struct apply {
    using type = TransformVector(V, RemoveAnnotations);
  };
};
struct AddPointerInAnnotatedType {
  template &lt;typename T&gt;
  struct apply;
  template &lt;typename T&gt;
  struct apply&lt;Type&lt;T&gt;&gt; {
    using type = Type&lt;T*&gt;;
  };
  template &lt;typename Annotation, typename T&gt;
  struct apply&lt;Type&lt;fruit::Annotated&lt;Annotation, T&gt;&gt;&gt; {
    using type = Type&lt;fruit::Annotated&lt;Annotation, T*&gt;&gt;;
  };
};
struct RemoveNonAssisted {
  template &lt;typename V&gt;
  struct apply {
    struct Helper {
      template &lt;typename CurrentResult, typename T&gt;
      struct apply {
        using type = CurrentResult;
      };
      template &lt;typename CurrentResult, typename T&gt;
      struct apply&lt;CurrentResult, Type&lt;Assisted&lt;T&gt;&gt;&gt; {
        using type = PushBack(CurrentResult, Type&lt;T&gt;);
      };
    };
    using type = FoldVector(V, Helper, Vector&lt;&gt;);
  };
};
struct RemoveAssisted {
  template &lt;typename V&gt;
  struct apply {
    struct Helper {
      template &lt;typename CurrentResult, typename T&gt;
      struct apply {
        using type = PushBack(CurrentResult, T);
      };
      template &lt;typename CurrentResult, typename T&gt;
      struct apply&lt;CurrentResult, Type&lt;Assisted&lt;T&gt;&gt;&gt; {
        using type = CurrentResult;
      };
    };
    using type = FoldVector(V, Helper, Vector&lt;&gt;);
  };
};
struct UnlabelAssistedSingleType {
  template &lt;typename T&gt;
  struct apply;
  template &lt;typename T&gt;
  struct apply&lt;Type&lt;T&gt;&gt; {
    using type = Type&lt;T&gt;;
  };
  template &lt;typename T&gt;
  struct apply&lt;Type&lt;Assisted&lt;T&gt;&gt;&gt; {
    using type = Type&lt;T&gt;;
  };
};
struct UnlabelAssisted {
  template &lt;typename V&gt;
  struct apply {
    using type = TransformVector(V, UnlabelAssistedSingleType);
  };
};
struct RequiredLambdaArgsForAssistedFactory {
  template &lt;typename AnnotatedSignature&gt;
  struct apply {
    using type = RemoveAnnotationsFromVector(UnlabelAssisted(SignatureArgs(AnnotatedSignature)));
  };
};
struct RequiredLambdaSignatureForAssistedFactory {
  template &lt;typename AnnotatedSignature&gt;
  struct apply {
    using type = ConsSignatureWithVector(RemoveAnnotations(SignatureType(AnnotatedSignature)),
                                         RequiredLambdaArgsForAssistedFactory(AnnotatedSignature));
  };
};
struct InjectedFunctionArgsForAssistedFactory {
  template &lt;typename AnnotatedSignature&gt;
  struct apply {
    using type = RemoveNonAssisted(SignatureArgs(AnnotatedSignature));
  };
};
struct InjectedSignatureForAssistedFactory {
  template &lt;typename AnnotatedSignature&gt;
  struct apply {
    using type = ConsSignatureWithVector(RemoveAnnotations(SignatureType(AnnotatedSignature)),
                                         InjectedFunctionArgsForAssistedFactory(AnnotatedSignature));
  };
};
struct IsAssisted {
  template &lt;typename T&gt;
  struct apply {
    using type = Bool&lt;false&gt;;
  };
  template &lt;typename T&gt;
  struct apply&lt;Type&lt;Assisted&lt;T&gt;&gt;&gt; {
    using type = Bool&lt;true&gt;;
  };
};
struct NumAssisted {
  template &lt;typename V&gt;
  struct apply;
  template &lt;typename... Types&gt;
  struct apply&lt;Vector&lt;Types...&gt;&gt; {
    using type = SumAll(typename IsAssisted::apply&lt;Types&gt;::type...);
  };
};
struct NumAssistedBefore {
  template &lt;typename Index, typename V&gt;
  struct apply;
  template &lt;typename V&gt;
  struct apply&lt;Int&lt;0&gt;, V&gt; {
    using type = Int&lt;0&gt;;
  };
  template &lt;int n, typename V&gt;
  struct apply&lt;Int&lt;n&gt;, V&gt; {
    using N = Int&lt;n&gt;;
    using type = Minus(NumAssisted(V), NumAssisted(VectorRemoveFirstN(V, N)));
  };
};
struct HasInjectAnnotation {
  template &lt;typename C&gt;
  struct apply;
  template &lt;typename C&gt;
  struct apply&lt;Type&lt;C&gt;&gt; {
    template &lt;typename C1&gt;
    static Bool&lt;true&gt; test(typename C1::Inject*);
    template &lt;typename&gt;
    static Bool&lt;false&gt; test(...);
    using type = decltype(test&lt;C&gt;(nullptr));
  };
};
struct DoGetInjectAnnotation {
  template &lt;typename C&gt;
  struct apply;
  template &lt;typename C&gt;
  struct apply&lt;Type&lt;C&gt;&gt; {
    using type = Type&lt;typename C::Inject&gt;;
  };
};
struct GetInjectAnnotation {
  template &lt;typename AnnotatedC&gt;
  struct apply {
    using C = RemoveAnnotations(AnnotatedC);
    using DecoratedS = DoGetInjectAnnotation(C);
    using SResult = SignatureType(DecoratedS);
    using AnnotatedSArgs = SignatureArgs(DecoratedS);
    using SArgs = RemoveAnnotationsFromVector(UnlabelAssisted(AnnotatedSArgs));
    using AnnotatedDecoratedS = ConsSignatureWithVector(AnnotatedC, AnnotatedSArgs);
    using type = If(IsAbstract(C), ConstructError(CannotConstructAbstractClassErrorTag, C),
                    If(Not(IsValidSignature(DecoratedS)),
                       ConstructError(InjectTypedefNotASignatureErrorTag, C, DecoratedS),
                       If(Not(IsSame(SResult, RemoveAnnotations(SResult))),
                          ConstructError(InjectTypedefWithAnnotationErrorTag, C),
                          If(Not(IsSame(C, SResult)), ConstructError(InjectTypedefForWrongClassErrorTag, C, SResult),
                             If(Not(IsConstructibleWithVector(C, SArgs)),
                                ConstructError(NoConstructorMatchingInjectSignatureErrorTag, C,
                                               ConsSignatureWithVector(SResult, SArgs)),
                                AnnotatedDecoratedS)))));
  };
};
template &lt;typename RsSupersetParam, typename PsParam, typename NonConstRsPsParam,
#if !FRUIT_NO_LOOP_CHECK
          typename DepsParam,
#endif
          typename InterfaceBindingsParam, typename DeferredBindingFunctorsParam&gt;
struct Comp {
  using RsSuperset = RsSupersetParam;
  using Ps = PsParam;
  using NonConstRsPs = NonConstRsPsParam;
#if !FRUIT_NO_LOOP_CHECK
  using Deps = DepsParam;
#endif
  using InterfaceBindings = InterfaceBindingsParam;
  using DeferredBindingFunctors = DeferredBindingFunctorsParam;
};
<A NAME="0"></A>struct ConsComp {
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match143-0.html#0',2,'match143-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>  template &lt;typename RsSupersetParam, typename PsParam, typename NonConstRsPsParam,
#if !FRUIT_NO_LOOP_CHECK
            typename DepsParam,
#endif
            typename InterfaceBindingsParam, typename DeferredBindingFunctorsParam&gt;
  struct apply {
    using type = Comp&lt;RsSupersetParam, PsParam, NonConstRsPsParam,
#if !FRUIT_NO_LOOP_CHECK
                      DepsParam,
#endif
                      InterfaceBindingsParam, DeferredBindingFunctorsParam&gt;;
  };
};
struct GetComponentDeps {
  template &lt;typename Comp&gt;
  struct apply {
    using type = typename Comp::Deps;
  };
};
struct GetComponentPs {
  template &lt;typename Comp&gt;
  struct apply {
    using type = typename Comp::Ps;</B></FONT>
  };
};
struct GetComponentRsSuperset {
  template &lt;typename Comp&gt;
  struct apply {
    using type = typename Comp::RsSuperset;
  };
};
struct GetComponentNonConstRsPs {
  template &lt;typename Comp&gt;
  struct apply {
    using type = typename Comp::NonConstRsPs;
  };
};
struct IsInjectableBareType {
  template &lt;typename T&gt;
  struct apply;
  template &lt;typename T&gt;
  struct apply&lt;Type&lt;T&gt;&gt; {
    using type = Bool&lt;std::is_arithmetic&lt;T&gt;::value || std::is_class&lt;T&gt;::value || std::is_enum&lt;T&gt;::value&gt;;
  };
  template &lt;typename Annotation, typename T&gt;
  struct apply&lt;Type&lt;fruit::Annotated&lt;Annotation, T&gt;&gt;&gt; {
    using type = Bool&lt;false&gt;;
  };
  template &lt;typename T&gt;
  struct apply&lt;Type&lt;std::shared_ptr&lt;T&gt;&gt;&gt; {
    using type = Bool&lt;false&gt;;
  };
};
struct IsInjectableType {
  template &lt;typename T&gt;
  struct apply {
    using type = IsInjectableBareType(NormalizeType(T));
  };
};
struct CheckInjectableType {
  template &lt;typename T&gt;
  struct apply {
    using type = If(Not(IsInjectableType(T)), ConstructError(NonInjectableTypeErrorTag, T), None);
  };
};
struct CheckInjectableTypeVector {
  struct Helper {
    template &lt;typename CurrentResult, typename T&gt;
    struct apply {
      using type = PropagateError(CheckInjectableType(T), CurrentResult);
    };
  };
  template &lt;typename V&gt;
  struct apply {
    using type = FoldVector(V, Helper, None);
  };
};
struct CheckNormalizedTypes {
  template &lt;typename V&gt;
  struct apply;
  template &lt;typename... Types&gt;
  struct apply&lt;Vector&lt;Type&lt;Types&gt;...&gt;&gt; {
    struct Helper {
      template &lt;typename CurrentResult, typename T&gt;
      struct apply {
        using NormalizedType = NormalizeType(T);
        using type = PropagateError(CheckInjectableType(RemoveAnnotations(NormalizeUntilStable(T))),
                                    If(Not(IsSame(NormalizeType(T), T)),
                                       ConstructError(NonClassTypeErrorTag, RemoveAnnotations(T),
                                                      RemoveAnnotations(NormalizeUntilStable(T))),
                                       CurrentResult));
      };
    };
    using type = Fold(Helper, None, Type&lt;Types&gt;...);
  };
};
struct CheckNotAnnotatedTypes {
  template &lt;typename V&gt;
  struct apply;
  template &lt;typename... Types&gt;
  struct apply&lt;Vector&lt;Type&lt;Types&gt;...&gt;&gt; {
    struct Helper {
      template &lt;typename CurrentResult, typename T&gt;
      struct apply {
        using TypeWithoutAnnotations = RemoveAnnotations(T);
        using type = If(Not(IsSame(TypeWithoutAnnotations, T)),
                        ConstructError(AnnotatedTypeErrorTag, T, TypeWithoutAnnotations), CurrentResult);
      };
    };
    using type = Fold(Helper, None, Type&lt;Types&gt;...);
  };
};
struct CheckNoRequiredTypesInComponentArguments {
  template &lt;typename V&gt;
  struct apply;
  template &lt;typename... Types&gt;
  struct apply&lt;Vector&lt;Types...&gt;&gt; {
    using type = None;
  };
  template &lt;typename T, typename... OtherTypes&gt;
  struct apply&lt;Vector&lt;Type&lt;T&gt;, OtherTypes...&gt;&gt; {
    using type = CheckNoRequiredTypesInComponentArguments(Vector&lt;OtherTypes...&gt;);
  };
<A NAME="1"></A>
  template &lt;typename... RequiredArgs, typename... OtherTypes&gt;
  struct apply&lt;Vector&lt;Type&lt;fruit::Required&lt;RequiredArgs...&gt;&gt;, OtherTypes...&gt;&gt; {
<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match143-0.html#1',2,'match143-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>    using type = ConstructError(RequiredTypesInComponentArgumentsErrorTag, Type&lt;fruit::Required&lt;RequiredArgs...&gt;&gt;);
  };
};
struct CheckNoRequiredTypesInInjectorArguments {
  template &lt;typename... Types&gt;
  struct apply {
    using type = None;
  };
  template &lt;typename T, typename... Types&gt;</B></FONT>
  struct apply&lt;T, Types...&gt; {
    using type = CheckNoRequiredTypesInInjectorArguments(Types...);
  };
  template &lt;typename... RequiredArgs, typename... Types&gt;
  struct apply&lt;Type&lt;fruit::Required&lt;RequiredArgs...&gt;&gt;, Types...&gt; {
    using type = ConstructError(InjectorWithRequirementsErrorTag, Type&lt;RequiredArgs&gt;...);
  };
};
struct CheckNoRepeatedTypes {
  template &lt;typename V&gt;
  struct apply;
  template &lt;typename... Types&gt;
  struct apply&lt;Vector&lt;Types...&gt;&gt; {
    using type = If(HasDuplicates(Vector&lt;Types...&gt;), ConstructError(RepeatedTypesErrorTag, Types...), None);
  };
};
struct RemoveConstFromType {
  template &lt;typename T&gt;
  struct apply;
  template &lt;typename T&gt;
  struct apply&lt;Type&lt;T&gt;&gt; {
    using type = Type&lt;T&gt;;
  };
  template &lt;typename T&gt;
  struct apply&lt;Type&lt;const T&gt;&gt; {
    using type = Type&lt;T&gt;;
  };
  template &lt;typename Annotation, typename T&gt;
  struct apply&lt;Type&lt;fruit::Annotated&lt;Annotation, T&gt;&gt;&gt; {
    using type = Type&lt;fruit::Annotated&lt;Annotation, T&gt;&gt;;
  };
  template &lt;typename Annotation, typename T&gt;
  struct apply&lt;Type&lt;fruit::Annotated&lt;Annotation, const T&gt;&gt;&gt; {
    using type = Type&lt;fruit::Annotated&lt;Annotation, T&gt;&gt;;
  };
};
struct RemoveConstFromTypes {
  template &lt;typename V&gt;
  struct apply;
  template &lt;typename... Types&gt;
  struct apply&lt;Vector&lt;Types...&gt;&gt; {
    using type = ConsVector(Id&lt;RemoveConstFromType(Types)&gt;...);
  };
};
struct RemoveConstTypes {
  struct Helper {
    template &lt;typename Acc, typename T&gt;
    struct apply;
    template &lt;typename... AccContent, typename T&gt;
    struct apply&lt;Vector&lt;AccContent...&gt;, Type&lt;const T&gt;&gt; {
      using type = Vector&lt;AccContent...&gt;;
    };
    template &lt;typename... AccContent, typename T&gt;
    struct apply&lt;Vector&lt;AccContent...&gt;, Type&lt;T&gt;&gt; {
      using type = Vector&lt;AccContent..., Type&lt;T&gt;&gt;;
    };
    template &lt;typename... AccContent, typename Annotation, typename T&gt;
    struct apply&lt;Vector&lt;AccContent...&gt;, Type&lt;fruit::Annotated&lt;Annotation, const T&gt;&gt;&gt; {
      using type = Vector&lt;AccContent...&gt;;
    };
    template &lt;typename... AccContent, typename Annotation, typename T&gt;
    struct apply&lt;Vector&lt;AccContent...&gt;, Type&lt;fruit::Annotated&lt;Annotation, T&gt;&gt;&gt; {
      using type = Vector&lt;AccContent..., Type&lt;fruit::Annotated&lt;Annotation, T&gt;&gt;&gt;;
    };
  };
  template &lt;typename V&gt;
  struct apply {
    using type = FoldVector(V, Helper, Vector&lt;&gt;);
  };
};
struct NormalizedNonConstTypesIn {
  struct Helper {
    template &lt;typename Acc, typename T&gt;
    struct apply {
      using type = If(TypeInjectionRequiresNonConstBinding(T), PushBack(Acc, NormalizeType(T)), Acc);
    };
  };
  template &lt;typename V&gt;
  struct apply {
    using type = FoldVector(V, Helper, Vector&lt;&gt;);
  };
};
struct ConstructComponentImpl {
  template &lt;typename... Ps&gt;
  struct apply {
    using type = PropagateError(
        CheckNoRepeatedTypes(RemoveConstFromTypes(Vector&lt;Ps...&gt;)),
        PropagateError(CheckNormalizedTypes(RemoveConstFromTypes(Vector&lt;Ps...&gt;)),
                       PropagateError(CheckNoRequiredTypesInComponentArguments(Vector&lt;Ps...&gt;),
                                      ConsComp(EmptySet, VectorToSetUnchecked(RemoveConstFromTypes(Vector&lt;Ps...&gt;)),
                                               RemoveConstTypes(Vector&lt;Ps...&gt;),
#if !FRUIT_NO_LOOP_CHECK
                                               Vector&lt;Pair&lt;Ps, Vector&lt;&gt;&gt;...&gt;,
#endif
                                               Vector&lt;&gt;, EmptyList))));
  };
  template &lt;typename... Rs, typename... Ps&gt;
  struct apply&lt;Type&lt;Required&lt;Rs...&gt;&gt;, Ps...&gt; {
    using type1 = PropagateError(
        CheckNoRepeatedTypes(RemoveConstFromTypes(Vector&lt;Type&lt;Rs&gt;..., Ps...&gt;)),
        PropagateError(CheckNormalizedTypes(RemoveConstFromTypes(Vector&lt;Type&lt;Rs&gt;..., Ps...&gt;)),
                       PropagateError(CheckNoRequiredTypesInComponentArguments(Vector&lt;Ps...&gt;),
                                      ConsComp(VectorToSetUnchecked(RemoveConstFromTypes(Vector&lt;Type&lt;Rs&gt;...&gt;)),
                                               VectorToSetUnchecked(RemoveConstFromTypes(Vector&lt;Ps...&gt;)),
                                               RemoveConstTypes(Vector&lt;Type&lt;Rs&gt;..., Ps...&gt;),
#if !FRUIT_NO_LOOP_CHECK
                                               Vector&lt;Pair&lt;Ps, Vector&lt;Type&lt;Rs&gt;...&gt;&gt;...&gt;,
#endif
                                               Vector&lt;&gt;, EmptyList))));
#if !FRUIT_NO_LOOP_CHECK &amp;&amp; FRUIT_EXTRA_DEBUG
    using Loop = ProofForestFindLoop(GetComponentDeps(type1));
    using type = If(IsNone(Loop), type1, ConstructErrorWithArgVector(SelfLoopErrorTag, Loop));
#else      using type = type1;
#endif   };
};
struct CheckTypesNotProvidedAsConst {
  template &lt;typename Comp, typename V&gt;
  struct apply {
    struct Helper {
      template &lt;typename Acc, typename T&gt;
      struct apply {
        using type = If(And(IsInSet(T, typename Comp::Ps), Not(IsInSet(T, typename Comp::NonConstRsPs))),
                        ConstructError(NonConstBindingRequiredButConstBindingProvidedErrorTag, T), Acc);
      };
    };
    using type = FoldVector(V, Helper, None);
  };
};
struct AddRequirements {
  template &lt;typename Comp, typename NewRequirementsVector, typename NewNonConstRequirementsVector&gt;
  struct apply {
    using Comp1 = ConsComp(FoldVector(NewRequirementsVector, AddToSet, typename Comp::RsSuperset), typename Comp::Ps,
                           FoldVector(NewNonConstRequirementsVector, AddToSet, typename Comp::NonConstRsPs),
#if !FRUIT_NO_LOOP_CHECK
                           typename Comp::Deps,
#endif
                           typename Comp::InterfaceBindings, typename Comp::DeferredBindingFunctors);
    using type = PropagateError(CheckTypesNotProvidedAsConst(Comp, NewNonConstRequirementsVector), Comp1);
  };
};
struct AddProvidedTypeIgnoringInterfaceBindings {
  template &lt;typename Comp, typename C, typename IsNonConst, typename CRequirements, typename CNonConstRequirements&gt;
  struct apply {
    using Comp1 = ConsComp(
        FoldVector(CRequirements, AddToSet, typename Comp::RsSuperset), AddToSetUnchecked(typename Comp::Ps, C),
        If(IsNonConst, AddToSetUnchecked(FoldVector(CNonConstRequirements, AddToSet, typename Comp::NonConstRsPs), C),
           FoldVector(CNonConstRequirements, AddToSet, typename Comp::NonConstRsPs)),
#if !FRUIT_NO_LOOP_CHECK
        PushFront(typename Comp::Deps, Pair&lt;C, CRequirements&gt;),
#endif
        typename Comp::InterfaceBindings, typename Comp::DeferredBindingFunctors);
    using type = If(IsInSet(C, typename Comp::Ps), ConstructError(TypeAlreadyBoundErrorTag, C),
                    PropagateError(CheckTypesNotProvidedAsConst(Comp, CNonConstRequirements), Comp1));
  };
};
struct AddProvidedType {
  template &lt;typename Comp, typename C, typename IsNonConst, typename CRequirements, typename CNonConstRequirements&gt;
  struct apply {
    using type = If(Not(IsNone(FindInMap(typename Comp::InterfaceBindings, C))),
                    ConstructError(TypeAlreadyBoundErrorTag, C),
                    AddProvidedTypeIgnoringInterfaceBindings(Comp, C, IsNonConst, CRequirements,
                                                             CNonConstRequirements));
  };
};
struct AddDeferredBinding {
  template &lt;typename Comp, typename DeferredBinding&gt;
  struct apply {
    using new_DeferredBindingFunctors = Cons&lt;DeferredBinding, typename Comp::DeferredBindingFunctors&gt;;
    using type = ConsComp(typename Comp::RsSuperset, typename Comp::Ps, typename Comp::NonConstRsPs,
#if !FRUIT_NO_LOOP_CHECK
                          typename Comp::Deps,
#endif
                          typename Comp::InterfaceBindings, new_DeferredBindingFunctors);
  };
};
struct CheckNoLoopInDeps {
  template &lt;typename Comp&gt;
  struct apply {
    using Loop = ProofForestFindLoop(typename Comp::Deps);
    using type = If(IsNone(Loop), Bool&lt;true&gt;, ConstructErrorWithArgVector(SelfLoopErrorTag, Loop));
  };
};
#if FRUIT_EXTRA_DEBUG || FRUIT_IN_META_TEST
struct CheckComponentEntails {
  template &lt;typename Comp, typename EntailedComp&gt;
  struct apply {
    using CompRs = SetDifference(typename Comp::RsSuperset, typename Comp::Ps);
    using EntailedCompRs = SetDifference(typename EntailedComp::RsSuperset, typename EntailedComp::Ps);
    using CommonRs = SetIntersection(CompRs, EntailedCompRs);
    using CommonPs = SetIntersection(typename Comp::Ps, typename EntailedComp::Ps);
    using type =
        If(Not(IsContained(typename EntailedComp::Ps, typename Comp::Ps)),
           ConstructErrorWithArgVector(ComponentDoesNotEntailDueToProvidesErrorTag,
                                       SetToVector(SetDifference(typename EntailedComp::Ps, typename Comp::Ps))),
           If(Not(IsVectorContained(typename EntailedComp::InterfaceBindings, typename Comp::InterfaceBindings)),
              ConstructErrorWithArgVector(ComponentDoesNotEntailDueToInterfaceBindingsErrorTag,
                                          SetToVector(SetDifference(typename EntailedComp::InterfaceBindings,
                                                                    typename Comp::InterfaceBindings))),
              If(Not(IsContained(CompRs, EntailedCompRs)),
                 ConstructErrorWithArgVector(ComponentDoesNotEntailDueToRequirementsErrorTag,
                                             SetToVector(SetDifference(CompRs, EntailedCompRs))),
                 If(Not(IsContained(SetIntersection(CommonRs, typename Comp::NonConstRsPs),
                                    typename EntailedComp::NonConstRsPs)),
                    ConstructErrorWithArgVector(ComponentDoesNotEntailDueToDifferentConstnessOfRequirementsErrorTag,
                                                SetToVector(SetDifference(SetIntersection(CommonRs,
                                                                                          typename Comp::NonConstRsPs),
                                                                          typename EntailedComp::NonConstRsPs))),
                    If(Not(IsContained(SetIntersection(CommonPs, typename EntailedComp::NonConstRsPs),
                                       typename Comp::NonConstRsPs)),
                       ConstructErrorWithArgVector(
                           ComponentDoesNotEntailDueToDifferentConstnessOfProvidesErrorTag,
                           SetToVector(SetDifference(SetIntersection(CommonPs, typename EntailedComp::NonConstRsPs),
                                                     typename Comp::NonConstRsPs))),
                       Bool&lt;true&gt;)))));
    static_assert(true || sizeof(typename CheckIfError&lt;Eval&lt;type&gt;&gt;::type), &quot;&quot;);
  };
};
#endif 
struct ConstructNoBindingFoundError {
  template &lt;typename AnnotatedC&gt;
  struct apply {
    using type = If(IsAbstract(RemoveAnnotations(AnnotatedC)),
                    ConstructError(NoBindingFoundForAbstractClassErrorTag, AnnotatedC, RemoveAnnotations(AnnotatedC)),
                    ConstructError(NoBindingFoundErrorTag, AnnotatedC));
  };
};
} } } 
#endif </PRE>
</div>
  </div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
