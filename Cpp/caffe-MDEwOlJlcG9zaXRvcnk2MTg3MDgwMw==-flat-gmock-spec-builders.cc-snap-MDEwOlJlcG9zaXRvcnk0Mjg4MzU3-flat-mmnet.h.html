
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 1.060695344725987%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-gmock-spec-builders.cc</h3>
            <pre><code>1  #include "gmock/gmock-spec-builders.h"
2  #include <stdlib.h>
3  #include <iostream>  
4  #include <map>
5  #include <set>
6  #include <string>
7  #include "gmock/gmock.h"
8  #include "gtest/gtest.h"
9  #if GTEST_OS_CYGWIN || GTEST_OS_LINUX || GTEST_OS_MAC
10  # include <unistd.h>  
11  #endif
12  namespace testing {
13  namespace internal {
14  GTEST_API_ GTEST_DEFINE_STATIC_MUTEX_(g_gmock_mutex);
15  GTEST_API_ void LogWithLocation(testing::internal::LogSeverity severity,
16                                  const char* file, int line,
17                                  const string& message) {
18    ::std::ostringstream s;
19    s << file << ":" << line << ": " << message << ::std::endl;
20    Log(severity, s.str(), 0);
21  }
22  ExpectationBase::ExpectationBase(const char* a_file,
23                                   int a_line,
24                                   const string& a_source_text)
25      : file_(a_file),
26        line_(a_line),
27        source_text_(a_source_text),
28        cardinality_specified_(false),
29        cardinality_(Exactly(1)),
30        call_count_(0),
31        retired_(false),
32        extra_matcher_specified_(false),
33        repeated_action_specified_(false),
34        retires_on_saturation_(false),
35        last_clause_(kNone),
36        action_count_checked_(false) {}
37  ExpectationBase::~ExpectationBase() {}
38  void ExpectationBase::SpecifyCardinality(const Cardinality& a_cardinality) {
39    cardinality_specified_ = true;
40    cardinality_ = a_cardinality;
41  }
42  void ExpectationBase::RetireAllPreRequisites()
43      GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
44    if (is_retired()) {
45      return;
46    }
47    for (ExpectationSet::const_iterator it = immediate_prerequisites_.begin();
48         it != immediate_prerequisites_.end(); ++it) {
49      ExpectationBase* const prerequisite = it->expectation_base().get();
50      if (!prerequisite->is_retired()) {
51        prerequisite->RetireAllPreRequisites();
52        prerequisite->Retire();
53      }
54    }
55  }
56  bool ExpectationBase::AllPrerequisitesAreSatisfied() const
57      GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
58    g_gmock_mutex.AssertHeld();
59    for (ExpectationSet::const_iterator it = immediate_prerequisites_.begin();
60         it != immediate_prerequisites_.end(); ++it) {
61      if (!(it->expectation_base()->IsSatisfied()) ||
62          !(it->expectation_base()->AllPrerequisitesAreSatisfied()))
63        return false;
64    }
65    return true;
66  }
67  void ExpectationBase::FindUnsatisfiedPrerequisites(ExpectationSet* result) const
68      GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
69    g_gmock_mutex.AssertHeld();
70    for (ExpectationSet::const_iterator it = immediate_prerequisites_.begin();
71         it != immediate_prerequisites_.end(); ++it) {
72      if (it->expectation_base()->IsSatisfied()) {
73        if (it->expectation_base()->call_count_ == 0) {
74          it->expectation_base()->FindUnsatisfiedPrerequisites(result);
75        }
76      } else {
77        *result += *it;
78      }
79    }
80  }
81  void ExpectationBase::DescribeCallCountTo(::std::ostream* os) const
82      GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
83    g_gmock_mutex.AssertHeld();
84    *os << "         Expected: to be ";
85    cardinality().DescribeTo(os);
86    *os << "\n           Actual: ";
87    Cardinality::DescribeActualCallCountTo(call_count(), os);
88    *os << " - " << (IsOverSaturated() ? "over-saturated" :
89                     IsSaturated() ? "saturated" :
90                     IsSatisfied() ? "satisfied" : "unsatisfied")
91        << " and "
92        << (is_retired() ? "retired" : "active");
93  }
94  void ExpectationBase::CheckActionCountIfNotDone() const
95      GTEST_LOCK_EXCLUDED_(mutex_) {
96    bool should_check = false;
97    {
98      MutexLock l(&mutex_);
99      if (!action_count_checked_) {
100        action_count_checked_ = true;
101        should_check = true;
102      }
103    }
104    if (should_check) {
105      if (!cardinality_specified_) {
106        return;
107      }
108      const int action_count = static_cast<int>(untyped_actions_.size());
109      const int upper_bound = cardinality().ConservativeUpperBound();
110      const int lower_bound = cardinality().ConservativeLowerBound();
111      bool too_many;  
112      if (action_count > upper_bound ||
113          (action_count == upper_bound && repeated_action_specified_)) {
114        too_many = true;
115      } else if (0 < action_count && action_count < lower_bound &&
116                 !repeated_action_specified_) {
117        too_many = false;
118      } else {
119        return;
120      }
121      ::std::stringstream ss;
122      DescribeLocationTo(&ss);
123      ss << "Too " << (too_many ? "many" : "few")
124         << " actions specified in " << source_text() << "...\n"
125         << "Expected to be ";
126      cardinality().DescribeTo(&ss);
127      ss << ", but has " << (too_many ? "" : "only ")
128         << action_count << " WillOnce()"
129         << (action_count == 1 ? "" : "s");
130      if (repeated_action_specified_) {
131        ss << " and a WillRepeatedly()";
132      }
133      ss << ".";
134      Log(kWarning, ss.str(), -1);  
135    }
136  }
137  void ExpectationBase::UntypedTimes(const Cardinality& a_cardinality) {
138    if (last_clause_ == kTimes) {
139      ExpectSpecProperty(false,
140                         ".Times() cannot appear "
141                         "more than once in an EXPECT_CALL().");
142    } else {
143      ExpectSpecProperty(last_clause_ < kTimes,
144                         ".Times() cannot appear after "
145                         ".InSequence(), .WillOnce(), .WillRepeatedly(), "
146                         "or .RetiresOnSaturation().");
147    }
148    last_clause_ = kTimes;
149    SpecifyCardinality(a_cardinality);
150  }
151  GTEST_API_ ThreadLocal<Sequence*> g_gmock_implicit_sequence;
152  void ReportUninterestingCall(CallReaction reaction, const string& msg) {
153    switch (reaction) {
154      case kAllow:
155        Log(kInfo, msg, 3);
156        break;
157      case kWarn:
158        Log(kWarning, msg, 3);
159        break;
160      default:  
161        Expect(false, NULL, -1, msg);
162    }
163  }
164  UntypedFunctionMockerBase::UntypedFunctionMockerBase()
165      : mock_obj_(NULL), name_("") {}
166  UntypedFunctionMockerBase::~UntypedFunctionMockerBase() {}
167  void UntypedFunctionMockerBase::RegisterOwner(const void* mock_obj)
168      GTEST_LOCK_EXCLUDED_(g_gmock_mutex) {
169    {
170      MutexLock l(&g_gmock_mutex);
171      mock_obj_ = mock_obj;
172    }
173    Mock::Register(mock_obj, this);
174  }
175  void UntypedFunctionMockerBase::SetOwnerAndName(const void* mock_obj,
176                                                  const char* name)
177      GTEST_LOCK_EXCLUDED_(g_gmock_mutex) {
178    MutexLock l(&g_gmock_mutex);
179    mock_obj_ = mock_obj;
180    name_ = name;
181  }
182  const void* UntypedFunctionMockerBase::MockObject() const
183      GTEST_LOCK_EXCLUDED_(g_gmock_mutex) {
184    const void* mock_obj;
185    {
186      MutexLock l(&g_gmock_mutex);
187      Assert(mock_obj_ != NULL, __FILE__, __LINE__,
188             "MockObject() must not be called before RegisterOwner() or "
189             "SetOwnerAndName() has been called.");
190      mock_obj = mock_obj_;
191    }
192    return mock_obj;
193  }
194  const char* UntypedFunctionMockerBase::Name() const
195      GTEST_LOCK_EXCLUDED_(g_gmock_mutex) {
196    const char* name;
197    {
198      MutexLock l(&g_gmock_mutex);
199      Assert(name_ != NULL, __FILE__, __LINE__,
200             "Name() must not be called before SetOwnerAndName() has "
201             "been called.");
202      name = name_;
203    }
204    return name;
205  }
206  const UntypedActionResultHolderBase*
207  UntypedFunctionMockerBase::UntypedInvokeWith(const void* const untyped_args)
208      GTEST_LOCK_EXCLUDED_(g_gmock_mutex) {
209    if (untyped_expectations_.size() == 0) {
210      const CallReaction reaction =
211          Mock::GetReactionOnUninterestingCalls(MockObject());
212      const bool need_to_report_uninteresting_call =
213          reaction == kAllow ? LogIsVisible(kInfo) :
214          reaction == kWarn ? LogIsVisible(kWarning) :
215          true;
216      if (!need_to_report_uninteresting_call) {
217        return this->UntypedPerformDefaultAction(untyped_args, "");
218      }
219      ::std::stringstream ss;
220      this->UntypedDescribeUninterestingCall(untyped_args, &ss);
221      const UntypedActionResultHolderBase* const result =
222          this->UntypedPerformDefaultAction(untyped_args, ss.str());
223      if (result != NULL)
224        result->PrintAsActionResult(&ss);
225      ReportUninterestingCall(reaction, ss.str());
226      return result;
227    }
228    bool is_excessive = false;
229    ::std::stringstream ss;
230    ::std::stringstream why;
231    ::std::stringstream loc;
232    const void* untyped_action = NULL;
233    const ExpectationBase* const untyped_expectation =
234        this->UntypedFindMatchingExpectation(
235            untyped_args, &untyped_action, &is_excessive,
236            &ss, &why);
237    const bool found = untyped_expectation != NULL;
238    const bool need_to_report_call =
239        !found || is_excessive || LogIsVisible(kInfo);
240    if (!need_to_report_call) {
241      return
242          untyped_action == NULL ?
243          this->UntypedPerformDefaultAction(untyped_args, "") :
244          this->UntypedPerformAction(untyped_action, untyped_args);
245    }
246    ss << "    Function call: " << Name();
247    this->UntypedPrintArgs(untyped_args, &ss);
248    if (found && !is_excessive) {
249      untyped_expectation->DescribeLocationTo(&loc);
250    }
251    const UntypedActionResultHolderBase* const result =
252        untyped_action == NULL ?
253        this->UntypedPerformDefaultAction(untyped_args, ss.str()) :
254        this->UntypedPerformAction(untyped_action, untyped_args);
255    if (result != NULL)
256      result->PrintAsActionResult(&ss);
257    ss << "\n" << why.str();
258    if (!found) {
259      Expect(false, NULL, -1, ss.str());
260    } else if (is_excessive) {
261      Expect(false, untyped_expectation->file(),
262             untyped_expectation->line(), ss.str());
263    } else {
264      Log(kInfo, loc.str() + ss.str(), 2);
265    }
266    return result;
267  }
268  Expectation UntypedFunctionMockerBase::GetHandleOf(ExpectationBase* exp) {
269    for (UntypedExpectations::const_iterator it =
270             untyped_expectations_.begin();
271         it != untyped_expectations_.end(); ++it) {
272      if (it->get() == exp) {
273        return Expectation(*it);
274      }
275    }
276    Assert(false, __FILE__, __LINE__, "Cannot find expectation.");
277    return Expectation();
278  }
279  bool UntypedFunctionMockerBase::VerifyAndClearExpectationsLocked()
280      GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
281    g_gmock_mutex.AssertHeld();
282    bool expectations_met = true;
283    for (UntypedExpectations::const_iterator it =
284             untyped_expectations_.begin();
285         it != untyped_expectations_.end(); ++it) {
286      ExpectationBase* const untyped_expectation = it->get();
287      if (untyped_expectation->IsOverSaturated()) {
288        expectations_met = false;
289      } else if (!untyped_expectation->IsSatisfied()) {
290        expectations_met = false;
291        ::std::stringstream ss;
292        ss  << "Actual function call count doesn't match "
293            << untyped_expectation->source_text() << "...\n";
294        untyped_expectation->MaybeDescribeExtraMatcherTo(&ss);
295        untyped_expectation->DescribeCallCountTo(&ss);
296        Expect(false, untyped_expectation->file(),
297               untyped_expectation->line(), ss.str());
298      }
299    }
300    UntypedExpectations expectations_to_delete;
301    untyped_expectations_.swap(expectations_to_delete);
302    g_gmock_mutex.Unlock();
303    expectations_to_delete.clear();
304    g_gmock_mutex.Lock();
305    return expectations_met;
306  }
307  }  
308  namespace {
309  typedef std::set<internal::UntypedFunctionMockerBase*> FunctionMockers;
310  struct MockObjectState {
311    MockObjectState()
312        : first_used_file(NULL), first_used_line(-1), leakable(false) {}
313    const char* first_used_file;
314    int first_used_line;
315    ::std::string first_used_test_case;
316    ::std::string first_used_test;
317    bool leakable;  
318    FunctionMockers function_mockers;  
319  };
320  class MockObjectRegistry {
321   public:
322    typedef std::map<const void*, MockObjectState> StateMap;
323    ~MockObjectRegistry() {
324      if (!GMOCK_FLAG(catch_leaked_mocks))
325        return;
326      int leaked_count = 0;
327      for (StateMap::const_iterator it = states_.begin(); it != states_.end();
328           ++it) {
329        if (it->second.leakable)  
330          continue;
331        std::cout << "\n";
332        const MockObjectState& state = it->second;
333        std::cout << internal::FormatFileLocation(state.first_used_file,
334                                                  state.first_used_line);
335        std::cout << " ERROR: this mock object";
336        if (state.first_used_test != "") {
337          std::cout << " (used in test " << state.first_used_test_case << "."
338               << state.first_used_test << ")";
339        }
340        std::cout << " should be deleted but never is. Its address is @"
341             << it->first << ".";
342        leaked_count++;
343      }
344      if (leaked_count > 0) {
345        std::cout << "\nERROR: " << leaked_count
346             << " leaked mock " << (leaked_count == 1 ? "object" : "objects")
347             << " found at program exit.\n";
348        std::cout.flush();
349        ::std::cerr.flush();
350        _exit(1);  
351      }
352    }
353    StateMap& states() { return states_; }
354   private:
355    StateMap states_;
356  };
357  MockObjectRegistry g_mock_object_registry;
358  std::map<const void*, internal::CallReaction> g_uninteresting_call_reaction;
359  void SetReactionOnUninterestingCalls(const void* mock_obj,
360                                       internal::CallReaction reaction)
361      GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex) {
362    internal::MutexLock l(&internal::g_gmock_mutex);
363    g_uninteresting_call_reaction[mock_obj] = reaction;
364  }
365  }  
366  void Mock::AllowUninterestingCalls(const void* mock_obj)
367      GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex) {
368    SetReactionOnUninterestingCalls(mock_obj, internal::kAllow);
369  }
370  void Mock::WarnUninterestingCalls(const void* mock_obj)
371      GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex) {
372    SetReactionOnUninterestingCalls(mock_obj, internal::kWarn);
373  }
374  void Mock::FailUninterestingCalls(const void* mock_obj)
375      GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex) {
376    SetReactionOnUninterestingCalls(mock_obj, internal::kFail);
377  }
378  void Mock::UnregisterCallReaction(const void* mock_obj)
379      GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex) {
380    internal::MutexLock l(&internal::g_gmock_mutex);
381    g_uninteresting_call_reaction.erase(mock_obj);
382  }
383  internal::CallReaction Mock::GetReactionOnUninterestingCalls(
384      const void* mock_obj)
385          GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex) {
386    internal::MutexLock l(&internal::g_gmock_mutex);
387    return (g_uninteresting_call_reaction.count(mock_obj) == 0) ?
388        internal::kDefault : g_uninteresting_call_reaction[mock_obj];
389  }
390  void Mock::AllowLeak(const void* mock_obj)
391      GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex) {
392    internal::MutexLock l(&internal::g_gmock_mutex);
393    g_mock_object_registry.states()[mock_obj].leakable = true;
394  }
395  bool Mock::VerifyAndClearExpectations(void* mock_obj)
396      GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex) {
397    internal::MutexLock l(&internal::g_gmock_mutex);
398    return VerifyAndClearExpectationsLocked(mock_obj);
399  }
400  bool Mock::VerifyAndClear(void* mock_obj)
401      GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex) {
402    internal::MutexLock l(&internal::g_gmock_mutex);
403    ClearDefaultActionsLocked(mock_obj);
404    return VerifyAndClearExpectationsLocked(mock_obj);
405  }
406  bool Mock::VerifyAndClearExpectationsLocked(void* mock_obj)
407      GTEST_EXCLUSIVE_LOCK_REQUIRED_(internal::g_gmock_mutex) {
408    internal::g_gmock_mutex.AssertHeld();
409    if (g_mock_object_registry.states().count(mock_obj) == 0) {
410      return true;
411    }
412    bool expectations_met = true;
413    FunctionMockers& mockers =
414        g_mock_object_registry.states()[mock_obj].function_mockers;
415    for (FunctionMockers::const_iterator it = mockers.begin();
416         it != mockers.end(); ++it) {
417      if (!(*it)->VerifyAndClearExpectationsLocked()) {
418        expectations_met = false;
419      }
420    }
421    return expectations_met;
422  }
423  void Mock::Register(const void* mock_obj,
424                      internal::UntypedFunctionMockerBase* mocker)
425      GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex) {
426    internal::MutexLock l(&internal::g_gmock_mutex);
427    g_mock_object_registry.states()[mock_obj].function_mockers.insert(mocker);
428  }
429  void Mock::RegisterUseByOnCallOrExpectCall(const void* mock_obj,
430                                             const char* file, int line)
431      GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex) {
432    internal::MutexLock l(&internal::g_gmock_mutex);
433    MockObjectState& state = g_mock_object_registry.states()[mock_obj];
434    if (state.first_used_file == NULL) {
435      state.first_used_file = file;
436      state.first_used_line = line;
437      const TestInfo* const test_info =
438          UnitTest::GetInstance()->current_test_info();
439      if (test_info != NULL) {
440        state.first_used_test_case = test_info->test_case_name();
441        state.first_used_test = test_info->name();
442      }
443    }
444  }
445  void Mock::UnregisterLocked(internal::UntypedFunctionMockerBase* mocker)
446      GTEST_EXCLUSIVE_LOCK_REQUIRED_(internal::g_gmock_mutex) {
447    internal::g_gmock_mutex.AssertHeld();
448    for (MockObjectRegistry::StateMap::iterator it =
449             g_mock_object_registry.states().begin();
450         it != g_mock_object_registry.states().end(); ++it) {
451      FunctionMockers& mockers = it->second.function_mockers;
452      if (mockers.erase(mocker) > 0) {
453        if (mockers.empty()) {
454          g_mock_object_registry.states().erase(it);
455        }
456        return;
457      }
458    }
459  }
460  void Mock::ClearDefaultActionsLocked(void* mock_obj)
461      GTEST_EXCLUSIVE_LOCK_REQUIRED_(internal::g_gmock_mutex) {
462    internal::g_gmock_mutex.AssertHeld();
463    if (g_mock_object_registry.states().count(mock_obj) == 0) {
464      return;
465    }
466    FunctionMockers& mockers =
467        g_mock_object_registry.states()[mock_obj].function_mockers;
468    for (FunctionMockers::const_iterator it = mockers.begin();
<span onclick='openModal()' class='match'>469         it != mockers.end(); ++it) {
470      (*it)->ClearDefaultActionsLocked();
471    }
472  }
473  Expectation::Expectation() {}
474  Expectation::Expectation(
475      const internal::linked_ptr<internal::ExpectationBase>& an_expectation_base)
476      : expectation_base_(an_expectation_base) {}
477  Expectation::~Expectation() {}
</span>478  void Sequence::AddExpectation(const Expectation& expectation) const {
479    if (*last_expectation_ != expectation) {
480      if (last_expectation_->expectation_base() != NULL) {
481        expectation.expectation_base()->immediate_prerequisites_
482            += *last_expectation_;
483      }
484      *last_expectation_ = expectation;
485    }
486  }
487  InSequence::InSequence() {
488    if (internal::g_gmock_implicit_sequence.get() == NULL) {
489      internal::g_gmock_implicit_sequence.set(new Sequence);
490      sequence_created_ = true;
491    } else {
492      sequence_created_ = false;
493    }
494  }
495  InSequence::~InSequence() {
496    if (sequence_created_) {
497      delete internal::g_gmock_implicit_sequence.get();
498      internal::g_gmock_implicit_sequence.set(NULL);
499    }
500  }
501  }  
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-mmnet.h</h3>
            <pre><code>1  #ifndef MMNET_H
2  #define MMNET_H
3  class TMMNet;
4  typedef TPt<TMMNet> PMMNet;
5  class TModeNet;
6  class TCrossNet;
7  class TModeNet : public TNEANet {
8  public:
9    typedef TModeNet TNetMM;
10  public:
11    class TNodeI : public TNEANet::TNodeI {
12    public:
13      TNodeI() : TNEANet::TNodeI() { }
14      TNodeI(const THashIter& NodeHIter, const TModeNet* GraphPt) : TNEANet::TNodeI(NodeHIter, GraphPt) { }
15      TNodeI(const TNodeI& NodeI) : TNEANet::TNodeI(NodeI) { }
16      TNodeI& operator = (const TNodeI& NodeI) { NodeHI = NodeI.NodeHI; Graph=NodeI.Graph; return *this; }
17      TNodeI& operator++ (int) { NodeHI++; return *this; }
18      bool operator < (const TNodeI& NodeI) const { return NodeHI < NodeI.NodeHI; }
19      bool operator == (const TNodeI& NodeI) const { return NodeHI == NodeI.NodeHI; }
20      void GetNeighborsByCrossNet(TStr& Name, TIntV& Neighbors, const bool isOutEId=false) {
21          const TModeNet *TMGraph = static_cast<const TModeNet *>(Graph); TMGraph->GetNeighborsByCrossNet(GetId(), Name, Neighbors, isOutEId); }
22      void GetCrossNetNames(TStrV& Names) { const TModeNet *TMGraph = static_cast<const TModeNet *>(Graph); TMGraph->GetCrossNetNames(Names); }
23      friend class TModeNet;
24    };
25  private:
26    TInt ModeId;
27    TMMNet *MMNet; 
28    THash<TStr, TBool> NeighborTypes; 
29  public:
30    TModeNet() : TNEANet(), ModeId(-1), MMNet(), NeighborTypes() { }
31    TModeNet(const int& TypeId) : TNEANet(), ModeId(TypeId), MMNet(), NeighborTypes() { }
32    explicit TModeNet(const int& Nodes, const int& Edges) : TNEANet(Nodes, Edges),
33      ModeId(-1), MMNet(), NeighborTypes(){ }
34    explicit TModeNet(const int& Nodes, const int& Edges, const int& TypeId) : TNEANet(Nodes, Edges),
35      ModeId(TypeId), MMNet(), NeighborTypes() { }
36    TModeNet(const TModeNet& Graph) :  TNEANet(true, Graph), ModeId(Graph.ModeId), MMNet(Graph.MMNet), NeighborTypes(Graph.NeighborTypes) { }
37    TModeNet(TSIn& SIn) : TNEANet(SIn), ModeId(SIn), MMNet(), NeighborTypes(SIn) { }
38  private:
39    TModeNet(const TModeNet& Graph, bool isSubModeGraph) : TNEANet(Graph, isSubModeGraph), ModeId(Graph.ModeId), MMNet(), NeighborTypes() {}
40  public:
41    void Save(TSOut& SOut) const {
42      TNEANet::Save(SOut); ModeId.Save(SOut); NeighborTypes.Save(SOut); SOut.Flush(); }
43    void LoadShM(TShMIn & ShMIn) {
44      TNEANet::LoadNetworkShM(ShMIn);
45      ModeId = TInt(ShMIn);
46      MMNet = NULL;
47      NeighborTypes.LoadShM(ShMIn);
48    }
49    void DelNode(const int& NId);
50    void GetCrossNetNames(TStrV& Names) const { NeighborTypes.GetKeyV(Names); }
51    void GetNeighborsByCrossNet(const int& NId, TStr& Name, TIntV& Neighbors, const bool isOutEId=false) const;
52    TNodeI BegMMNI() const { return TNodeI(NodeH.BegI(), this); }
53    TNodeI EndMMNI() const { return TNodeI(NodeH.EndI(), this); }
54    TNodeI GetMMNI(const int& NId) const { return TNodeI(NodeH.GetI(NId), this); }
55    void Clr();
56    TModeNet& operator = (const TModeNet& Graph) { 
57      if (this!=&Graph) {
58        MxNId=Graph.MxNId; MxEId=Graph.MxEId; NodeH=Graph.NodeH; EdgeH=Graph.EdgeH;
59        KeyToIndexTypeN=Graph.KeyToIndexTypeN; KeyToIndexTypeE=Graph.KeyToIndexTypeE;
60        KeyToDenseN = Graph.KeyToDenseN; KeyToDenseE = Graph.KeyToDenseE;
61        IntDefaultsN=Graph.IntDefaultsN; IntDefaultsE=Graph.IntDefaultsE; StrDefaultsN=Graph.StrDefaultsN; StrDefaultsE=Graph.StrDefaultsE;
62        FltDefaultsN=Graph.FltDefaultsN; FltDefaultsE=Graph.FltDefaultsE; VecOfIntVecsN=Graph.VecOfIntVecsN; VecOfIntVecsE=Graph.VecOfIntVecsE;
63        VecOfStrVecsN=Graph.VecOfStrVecsN; VecOfStrVecsE=Graph.VecOfStrVecsE; VecOfFltVecsN=Graph.VecOfFltVecsN; VecOfFltVecsE=Graph.VecOfFltVecsE;
64        VecOfIntVecVecsN=Graph.VecOfIntVecVecsN; VecOfIntVecVecsE=Graph.VecOfIntVecVecsE; 
65        VecOfIntHashVecsN = Graph.VecOfIntHashVecsN; VecOfIntHashVecsE = Graph.VecOfIntHashVecsE; SAttrN=Graph.SAttrN; SAttrE=Graph.SAttrE;
66        ModeId=Graph.ModeId; MMNet=Graph.MMNet; NeighborTypes=Graph.NeighborTypes;
67      }
68      return *this; 
69    }
70  private:
71    int AddNeighbor(const int& NId, const int& EId, const bool outEdge, const int linkId, const bool sameMode, bool isDir);
72    int AddNeighbor(const int& NId, const int& EId, const bool outEdge, const TStr& linkName, const bool sameMode, bool isDir);
73    int DelNeighbor(const int& NId, const int& EId, bool outEdge, const TStr& CrossName, const bool sameMode, bool isDir);
74    int DelNeighbor(const int& NId, const int& EId, bool outEdge, const TInt& linkId, const bool sameMode, bool isDir);
75    TStr GetNeighborCrossName(const TStr& CrossName, bool isOutEdge, const bool sameMode, bool isDir) const;
76    void SetParentPointer(TMMNet* parent);
77    int AddNbrType(const TStr& CrossName, const bool sameMode, bool isDir);
78    int AddIntVAttrByVecN(const TStr& attr, TVec<TIntV>& Attrs, TBool UseDense=true);
79    int AddIntVAttrByHashN(const TStr& attr, THash<TInt, TIntV>& Attrs);
80    void RemoveCrossNets(TModeNet& Result, TStrV& CrossNets);
81    int DelNbrType(const TStr& CrossName);
82    int GetAttrTypeN(const TStr& attr) const;
83    void ClrNbr(const TStr& CrossNetName, const bool& outEdge, const bool& sameMode, bool& isDir);
84  public:
85    friend class TMMNet;
86    friend class TCrossNet;
87  };
88  class TCrossNet {
89  public:
90    class TCrossEdge {
91    private:
92      TInt EId;
93      TInt SrcNId, DstNId;
94    public:
95      TCrossEdge() : EId(-1), SrcNId(-1), DstNId(-1) { }
96      TCrossEdge(const int& Id, const int& SourceNId, const int& DestNId) :
97        EId(Id), SrcNId(SourceNId), DstNId(DestNId) { }
98      TCrossEdge(const TCrossEdge& MultiEdge) : EId(MultiEdge.EId), SrcNId(MultiEdge.SrcNId),
99          DstNId(MultiEdge.DstNId) { }
100      TCrossEdge(TSIn& SIn) : EId(SIn), SrcNId(SIn), DstNId(SIn) { }
101      void Save(TSOut& SOut) const { EId.Save(SOut); SrcNId.Save(SOut); DstNId.Save(SOut); }
102      int GetId() const { return EId; }
103      int GetSrcNId() const { return SrcNId; }
104      int GetDstNId() const { return DstNId; }
105      size_t GetMemUsed() const { return EId.GetMemUsed() + SrcNId.GetMemUsed() + DstNId.GetMemUsed(); }
106      friend class TCrossNet;
107    };
108    class TCrossEdgeI {
109    private:
110      typedef THash<TInt, TCrossEdge>::TIter THashIter;
111      THashIter CrossHI;
112      const TCrossNet *Graph;
113    public:
114      TCrossEdgeI() : CrossHI(), Graph(NULL) { }
115      TCrossEdgeI(const THashIter& CrossHIter, const TCrossNet *GraphPt) : CrossHI(CrossHIter), Graph(GraphPt) { }
116      TCrossEdgeI(const TCrossEdgeI& EdgeI) : CrossHI(EdgeI.CrossHI), Graph(EdgeI.Graph) { }
117      TCrossEdgeI& operator = (const TCrossEdgeI& EdgeI) { if (this!=&EdgeI) { CrossHI=EdgeI.CrossHI; Graph=EdgeI.Graph; }  return *this; }
118      TCrossEdgeI& operator++ (int) { CrossHI++; return *this; }
119      bool operator < (const TCrossEdgeI& EdgeI) const { return CrossHI < EdgeI.CrossHI; }
120      bool operator == (const TCrossEdgeI& EdgeI) const { return CrossHI == EdgeI.CrossHI; }
121      int GetId() const { return CrossHI.GetDat().GetId(); }
122      int GetSrcNId() const { return CrossHI.GetDat().GetSrcNId(); }
123      int GetDstNId() const { return CrossHI.GetDat().GetDstNId(); }
124      int GetSrcModeId() const { return Graph->GetMode1(); }
125      int GetDstModeId() const { return Graph->GetMode2(); }
126      bool IsDirected() const { return Graph->IsDirected(); }
127      friend class TCrossNet;
128    };
129    class TAIntI {
130    private:
131      typedef TIntV::TIter TIntVecIter;
132      TIntVecIter HI;
133      TStr attr;
134      const TCrossNet *Graph;
135    public:
136      TAIntI() : HI(), attr(), Graph(NULL) { }
137      TAIntI(const TIntVecIter& HIter, TStr attribute, const TCrossNet* GraphPt) : HI(HIter), attr(), Graph(GraphPt) { attr = attribute; }
138      TAIntI(const TAIntI& I) : HI(I.HI), attr(I.attr), Graph(I.Graph) { }
139      TAIntI& operator = (const TAIntI& I) { HI = I.HI; Graph=I.Graph; attr = I.attr; return *this; }
140      bool operator < (const TAIntI& I) const { return HI < I.HI; }
141      bool operator == (const TAIntI& I) const { return HI == I.HI; }
142      TInt GetDat() const { return HI[0]; }
143      bool IsDeleted() const { return GetDat() == Graph->GetIntAttrDefaultE(attr); };
144      TAIntI& operator++(int) { HI++; return *this; }
145      friend class TCrossNet;
146    };
147    class TAStrI {
148    private:
149      typedef TStrV::TIter TStrVecIter;
150      TStrVecIter HI;
151      TStr attr;
152      const TCrossNet *Graph;
153    public:
154      TAStrI() : HI(), attr(), Graph(NULL) { }
155      TAStrI(const TStrVecIter& HIter, TStr attribute, const TCrossNet* GraphPt) : HI(HIter), attr(), Graph(GraphPt) { attr = attribute; }
156      TAStrI(const TAStrI& I) : HI(I.HI), attr(I.attr), Graph(I.Graph) { }
157      TAStrI& operator = (const TAStrI& I) { HI = I.HI; Graph=I.Graph; attr = I.attr; return *this; }
158      bool operator < (const TAStrI& I) const { return HI < I.HI; }
159      bool operator == (const TAStrI& I) const { return HI == I.HI; }
160      TStr GetDat() const { return HI[0]; }
161      bool IsDeleted() const { return GetDat() == Graph->GetStrAttrDefaultE(attr); };
162      TAStrI& operator++(int) { HI++; return *this; }
163      friend class TCrossNet;
164    };
165    class TAFltI {
166    private:
167      typedef TFltV::TIter TFltVecIter;
168      TFltVecIter HI;
169      TStr attr;
170      const TCrossNet *Graph;
171    public:
172      TAFltI() : HI(), attr(), Graph(NULL) { }
173      TAFltI(const TFltVecIter& HIter, TStr attribute, const TCrossNet* GraphPt) : HI(HIter), attr(), Graph(GraphPt) { attr = attribute; }
174      TAFltI(const TAFltI& I) : HI(I.HI), attr(I.attr), Graph(I.Graph) { }
175      TAFltI& operator = (const TAFltI& I) { HI = I.HI; Graph=I.Graph; attr = I.attr; return *this; }
176      bool operator < (const TAFltI& I) const { return HI < I.HI; }
177      bool operator == (const TAFltI& I) const { return HI == I.HI; }
178      TFlt GetDat() const { return HI[0]; }
179      bool IsDeleted() const { return GetDat() == Graph->GetFltAttrDefaultE(attr); };
180      TAFltI& operator++(int) { HI++; return *this; }
181      friend class TCrossNet;
182    };
183  private:
184    class TLoadVecInit {
185    public:
186      TLoadVecInit() {}
187      template<typename TElem>
188      void operator() (TVec<TElem>* Node, TShMIn& ShMIn) {
189        Node->LoadShM(ShMIn);
190      }
191    };
192  private:
193    THash<TInt,TCrossEdge> CrossH; 
194    TInt MxEId;
195    TInt Mode1; 
196    TInt Mode2; 
197    TBool IsDirect;
198    TInt CrossNetId;
199    TMMNet* Net;
200    TStrIntPrH KeyToIndexTypeE;
201    THash<TStr, TInt> IntDefaultsE;
202    THash<TStr, TStr> StrDefaultsE;
203    THash<TStr, TFlt> FltDefaultsE;
204    TVec<TIntV> VecOfIntVecsE;
205    TVec<TStrV> VecOfStrVecsE;
206    TVec<TFltV> VecOfFltVecsE;
207    enum { IntType, StrType, FltType };
208  public:
209    TCrossNet() : CrossH(), MxEId(0), Mode1(-1), Mode2(-1), IsDirect(), CrossNetId(), Net(), KeyToIndexTypeE(), IntDefaultsE(), StrDefaultsE(),
210      FltDefaultsE(), VecOfIntVecsE(), VecOfStrVecsE(), VecOfFltVecsE() {}
211    TCrossNet(TInt MId1, TInt MId2, TInt LId) : CrossH(), MxEId(0), Mode1(MId1), Mode2(MId2), IsDirect(true),CrossNetId(LId), Net(),
212      KeyToIndexTypeE(), IntDefaultsE(), StrDefaultsE(), FltDefaultsE(), VecOfIntVecsE(), VecOfStrVecsE(), VecOfFltVecsE() {}
213    TCrossNet(TInt MId1, TInt MId2, TBool IsDir, TInt LId) : CrossH(), MxEId(0), Mode1(MId1), Mode2(MId2), IsDirect(IsDir),CrossNetId(LId), Net(),
214      KeyToIndexTypeE(), IntDefaultsE(), StrDefaultsE(), FltDefaultsE(), VecOfIntVecsE(), VecOfStrVecsE(), VecOfFltVecsE() {}
215    TCrossNet(TSIn& SIn) : CrossH(SIn), MxEId(SIn), Mode1(SIn), Mode2(SIn), IsDirect(SIn), CrossNetId(SIn), Net(),
216      KeyToIndexTypeE(SIn), IntDefaultsE(SIn), StrDefaultsE(SIn), FltDefaultsE(SIn), VecOfIntVecsE(SIn), VecOfStrVecsE(SIn), VecOfFltVecsE(SIn) {}
217    TCrossNet(const TCrossNet& OtherTCrossNet) : CrossH(OtherTCrossNet.CrossH), MxEId(OtherTCrossNet.MxEId), Mode1(OtherTCrossNet.Mode1),
218      Mode2(OtherTCrossNet.Mode2), IsDirect(OtherTCrossNet.IsDirect), CrossNetId(OtherTCrossNet.CrossNetId),Net(OtherTCrossNet.Net), KeyToIndexTypeE(OtherTCrossNet.KeyToIndexTypeE), 
219      IntDefaultsE(OtherTCrossNet.IntDefaultsE), StrDefaultsE(OtherTCrossNet.StrDefaultsE), FltDefaultsE(OtherTCrossNet.FltDefaultsE), VecOfIntVecsE(OtherTCrossNet.VecOfIntVecsE),
220      VecOfStrVecsE(OtherTCrossNet.VecOfStrVecsE), VecOfFltVecsE(OtherTCrossNet.VecOfFltVecsE) {}
221    TCrossNet& operator=(const TCrossNet& OtherTCrossNet) {
222      CrossH = OtherTCrossNet.CrossH;
223      MxEId = OtherTCrossNet.MxEId;
224      Mode1 = OtherTCrossNet.Mode1;
225      Mode2 = OtherTCrossNet.Mode2;
226      CrossNetId = OtherTCrossNet.CrossNetId;
227      IsDirect = OtherTCrossNet.IsDirect;
228      Net = OtherTCrossNet.Net;
229      KeyToIndexTypeE = OtherTCrossNet.KeyToIndexTypeE;
230      IntDefaultsE = OtherTCrossNet.IntDefaultsE;
231      StrDefaultsE = OtherTCrossNet.StrDefaultsE;
232      FltDefaultsE = OtherTCrossNet.FltDefaultsE;
233      VecOfIntVecsE = OtherTCrossNet.VecOfIntVecsE;
234      VecOfStrVecsE = OtherTCrossNet.VecOfStrVecsE;
235      VecOfFltVecsE = OtherTCrossNet.VecOfFltVecsE;
236      return *this;
237    }
238  private:
239    void SetParentPointer(TMMNet* parent);
240    TInt GetIntAttrDefaultE(const TStr& attribute) const { return IntDefaultsE.IsKey(attribute) ? IntDefaultsE.GetDat(attribute) : (TInt) TInt::Mn; }
241    TStr GetStrAttrDefaultE(const TStr& attribute) const { return StrDefaultsE.IsKey(attribute) ? StrDefaultsE.GetDat(attribute) : (TStr) TStr::GetNullStr(); }
242    TFlt GetFltAttrDefaultE(const TStr& attribute) const { return FltDefaultsE.IsKey(attribute) ? FltDefaultsE.GetDat(attribute) : (TFlt) TFlt::Mn; }
243    int GetAttrTypeE(const TStr& attr) const;
244    TCrossEdge& GetEdge(int eid) { return CrossH[eid]; }
245  public:
246    bool IsEdge(const int& EId) const { return CrossH.IsKey(EId); }
247    int GetMxEId() const { return MxEId; }
248    int GetEdges() const { return CrossH.Len(); }
249    void Clr();
250    int AddEdge(const int& sourceNId, const int& destNId, int EId=-1);
251    TCrossEdgeI GetEdgeI(const int& EId) const { return TCrossEdgeI(CrossH.GetI(EId), this); }
252    TCrossEdgeI BegEdgeI() const { return TCrossEdgeI(CrossH.BegI(), this); }
253    TCrossEdgeI EndEdgeI() const { return TCrossEdgeI(CrossH.EndI(), this); }
254    int DelEdge(const int& EId);
255    int GetMode1() const { return Mode1; }
256    int GetMode2() const {return Mode2; }
257    void Save(TSOut& SOut) const { CrossH.Save(SOut); MxEId.Save(SOut); Mode1.Save(SOut); Mode2.Save(SOut); IsDirect.Save(SOut); CrossNetId.Save(SOut); 
258      KeyToIndexTypeE.Save(SOut); IntDefaultsE.Save(SOut); StrDefaultsE.Save(SOut); FltDefaultsE.Save(SOut); VecOfIntVecsE.Save(SOut);
259      VecOfStrVecsE.Save(SOut); VecOfFltVecsE.Save(SOut); SOut.Flush(); }
260    void LoadShM(TShMIn& ShMIn) {
261      CrossH.LoadShM(ShMIn);
262      MxEId = TInt(ShMIn);
263      Mode1 = TInt(ShMIn);
264      Mode2 = TInt(ShMIn);
265      IsDirect = TBool(ShMIn);
266      CrossNetId = TInt(ShMIn);
267      Net = NULL;
268      KeyToIndexTypeE.LoadShM(ShMIn);
269      IntDefaultsE.LoadShM(ShMIn);
270      StrDefaultsE.LoadShM(ShMIn);
271      FltDefaultsE.LoadShM(ShMIn);
272      TLoadVecInit VecFn;
273      VecOfIntVecsE.LoadShM(ShMIn, VecFn);
274      VecOfStrVecsE.Load(ShMIn);
275      VecOfFltVecsE.Load(ShMIn);
276    }
277    bool IsDirected() const { return IsDirect;}
278    void AttrNameEI(const TInt& EId, TStrV& Names) const {
279      AttrNameEI(EId, KeyToIndexTypeE.BegI(), Names);}
280    void AttrNameEI(const TInt& EId, TStrIntPrH::TIter CrossHI, TStrV& Names) const;
281    void AttrValueEI(const TInt& EId, TStrV& Values) const {
282      AttrValueEI(EId, KeyToIndexTypeE.BegI(), Values);}
283    void AttrValueEI(const TInt& EId, TStrIntPrH::TIter CrossHI, TStrV& Values) const;
284    void IntAttrNameEI(const TInt& EId, TStrV& Names) const {
285      IntAttrNameEI(EId, KeyToIndexTypeE.BegI(), Names);}
286    void IntAttrNameEI(const TInt& EId, TStrIntPrH::TIter CrossHI, TStrV& Names) const;
287    void IntAttrValueEI(const TInt& EId, TIntV& Values) const {
288      IntAttrValueEI(EId, KeyToIndexTypeE.BegI(), Values);}
289    void IntAttrValueEI(const TInt& EId, TStrIntPrH::TIter CrossHI, TIntV& Values) const;
290    void StrAttrNameEI(const TInt& EId, TStrV& Names) const {
291      StrAttrNameEI(EId, KeyToIndexTypeE.BegI(), Names);}
292    void StrAttrNameEI(const TInt& EId, TStrIntPrH::TIter CrossHI, TStrV& Names) const;
293    void StrAttrValueEI(const TInt& EId, TStrV& Values) const {
294      StrAttrValueEI(EId, KeyToIndexTypeE.BegI(), Values);}
295    void StrAttrValueEI(const TInt& EId, TStrIntPrH::TIter CrossHI, TStrV& Values) const;
296    void FltAttrNameEI(const TInt& EId, TStrV& Names) const {
297      FltAttrNameEI(EId, KeyToIndexTypeE.BegI(), Names);}
298    void FltAttrNameEI(const TInt& EId, TStrIntPrH::TIter CrossHI, TStrV& Names) const;
299    void FltAttrValueEI(const TInt& EId, TFltV& Values) const {
300      FltAttrValueEI(EId, KeyToIndexTypeE.BegI(), Values);}
301    void FltAttrValueEI(const TInt& EId, TStrIntPrH::TIter CrossHI, TFltV& Values) const;
302    int AddIntAttrDatE(const TCrossEdgeI& EdgeI, const TInt& value, const TStr& attr) { return AddIntAttrDatE(EdgeI.GetId(), value, attr); }
303    int AddIntAttrDatE(const int& EId, const TInt& value, const TStr& attr);
304    int AddStrAttrDatE(const TCrossEdgeI& EdgeI, const TStr& value, const TStr& attr) { return AddStrAttrDatE(EdgeI.GetId(), value, attr); }
305    int AddStrAttrDatE(const int& EId, const TStr& value, const TStr& attr);
306    int AddFltAttrDatE(const TCrossEdgeI& EdgeI, const TFlt& value, const TStr& attr) { return AddFltAttrDatE(EdgeI.GetId(), value, attr); }
307    int AddFltAttrDatE(const int& EId, const TFlt& value, const TStr& attr);
308    TInt GetIntAttrDatE(const TCrossEdgeI& EdgeI, const TStr& attr) { return GetIntAttrDatE(EdgeI.GetId(), attr); }
309    TInt GetIntAttrDatE(const int& EId, const TStr& attr);
310    TStr GetStrAttrDatE(const TCrossEdgeI& EdgeI, const TStr& attr) { return GetStrAttrDatE(EdgeI.GetId(), attr); }
311    TStr GetStrAttrDatE(const int& EId, const TStr& attr);
312    TFlt GetFltAttrDatE(const TCrossEdgeI& EdgeI, const TStr& attr) { return GetFltAttrDatE(EdgeI.GetId(), attr); }
313    TFlt GetFltAttrDatE(const int& EId, const TStr& attr);
314    TAIntI BegEAIntI(const TStr& attr) const {
315      return TAIntI(VecOfIntVecsE[KeyToIndexTypeE.GetDat(attr).Val2].BegI(), attr, this);
316    }
317    TAIntI EndEAIntI(const TStr& attr) const {
318      return TAIntI(VecOfIntVecsE[KeyToIndexTypeE.GetDat(attr).Val2].EndI(), attr, this);
319    }
320    TAIntI GetEAIntI(const TStr& attr, const int& EId) const {
321      return TAIntI(VecOfIntVecsE[KeyToIndexTypeE.GetDat(attr).Val2].GetI(CrossH.GetKeyId(EId)), attr, this);
322    }
323    TAStrI BegEAStrI(const TStr& attr) const {
324      return TAStrI(VecOfStrVecsE[KeyToIndexTypeE.GetDat(attr).Val2].BegI(), attr, this);   }
325    TAStrI EndEAStrI(const TStr& attr) const {
326      return TAStrI(VecOfStrVecsE[KeyToIndexTypeE.GetDat(attr).Val2].EndI(), attr, this);
327    }
328    TAStrI GetEAStrI(const TStr& attr, const int& EId) const {
329      return TAStrI(VecOfStrVecsE[KeyToIndexTypeE.GetDat(attr).Val2].GetI(CrossH.GetKeyId(EId)), attr, this);
330    }
331    TAFltI BegEAFltI(const TStr& attr) const {
332      return TAFltI(VecOfFltVecsE[KeyToIndexTypeE.GetDat(attr).Val2].BegI(), attr, this);
333    }
334    TAFltI EndEAFltI(const TStr& attr) const {
335      return TAFltI(VecOfFltVecsE[KeyToIndexTypeE.GetDat(attr).Val2].EndI(), attr, this);
336    }
337    TAFltI GetEAFltI(const TStr& attr, const int& EId) const {
338      return TAFltI(VecOfFltVecsE[KeyToIndexTypeE.GetDat(attr).Val2].GetI(CrossH.GetKeyId(EId)), attr, this);
339    }
340    int DelAttrDatE(const TCrossEdgeI& EdgeI, const TStr& attr) { return DelAttrDatE(EdgeI.GetId(), attr); } 
341    int DelAttrDatE(const int& EId, const TStr& attr); 
342    int AddIntAttrE(const TStr& attr, TInt defaultValue=TInt::Mn);
343    int AddStrAttrE(const TStr& attr, TStr defaultValue=TStr::GetNullStr());
344    int AddFltAttrE(const TStr& attr, TFlt defaultValue=TFlt::Mn);
345    int DelAttrE(const TStr& attr);
346    bool IsAttrDeletedE(const int& EId, const TStr& attr) const;
347    bool IsIntAttrDeletedE(const int& EId, const TStr& attr) const;
348    bool IsStrAttrDeletedE(const int& EId, const TStr& attr) const;
349    bool IsFltAttrDeletedE(const int& EId, const TStr& attr) const;
350    bool EdgeAttrIsDeleted(const int& EId, const TStrIntPrH::TIter& CrossHI) const;
351    bool EdgeAttrIsIntDeleted(const int& EId, const TStrIntPrH::TIter& CrossHI) const;
352    bool EdgeAttrIsStrDeleted(const int& EId, const TStrIntPrH::TIter& CrossHI) const;
353    bool EdgeAttrIsFltDeleted(const int& EId, const TStrIntPrH::TIter& CrossHI) const;
354    TStr GetEdgeAttrValue(const int& EId, const TStrIntPrH::TIter& CrossHI) const;
355    friend class TMMNet;
356    friend class TModeNet;
357  };
358  class TMMNet {
359  public:
360    class TModeNetI {
361    protected:
362      typedef THash<TInt, TModeNet>::TIter THashIter;
363      THashIter ModeNetHI;
364      const TMMNet *Graph;
365    public:
366      TModeNetI() : ModeNetHI(), Graph(NULL) { }
367      TModeNetI(const THashIter& ModeNetHIter, const TMMNet* GraphPt) : ModeNetHI(ModeNetHIter), Graph(GraphPt) { }
368      TModeNetI(const TModeNetI& ModeNetI) : ModeNetHI(ModeNetI.ModeNetHI), Graph(ModeNetI.Graph) { }
369      TModeNetI& operator = (const TModeNetI& ModeNetI) { ModeNetHI = ModeNetI.ModeNetHI; Graph=ModeNetI.Graph; return *this; }
370      TModeNetI& operator++ (int) { ModeNetHI++; return *this; }
371      bool operator < (const TModeNetI& ModeNetI) const { return ModeNetHI < ModeNetI.ModeNetHI; }
372      bool operator == (const TModeNetI& ModeNetI) const { return ModeNetHI == ModeNetI.ModeNetHI; }
373      int GetModeId() { return ModeNetHI.GetKey(); }
374      TStr GetModeName() { return Graph->GetModeName(ModeNetHI.GetKey()); }
375      TModeNet& GetModeNet() { return Graph->GetModeNetById(GetModeId()); }
376      friend class TMMNet;
377    };
378    class TCrossNetI {
379    protected:
380      typedef THash<TInt, TCrossNet>::TIter THashIter;
381      THashIter CrossNetHI;
382      const TMMNet *Graph;
383    public:
384      TCrossNetI() : CrossNetHI(), Graph(NULL) { }
385      TCrossNetI(const THashIter& CrossNetHIter, const TMMNet* GraphPt) : CrossNetHI(CrossNetHIter), Graph(GraphPt) { }
386      TCrossNetI(const TCrossNetI& CrossNetI) : CrossNetHI(CrossNetI.CrossNetHI), Graph(CrossNetI.Graph) { }
387      TCrossNetI& operator = (const TCrossNetI& CrossNetI) { CrossNetHI = CrossNetI.CrossNetHI; Graph=CrossNetI.Graph; return *this; }
388      TCrossNetI& operator++ (int) { CrossNetHI++; return *this; }
389      bool operator < (const TCrossNetI& CrossNetI) const { return CrossNetHI < CrossNetI.CrossNetHI; }
390      bool operator == (const TCrossNetI& CrossNetI) const { return CrossNetHI == CrossNetI.CrossNetHI; }
391      int GetCrossId() { return CrossNetHI.GetKey(); }
392      TStr GetCrossName() { return Graph->GetCrossName(CrossNetHI.GetKey()); }
393      TCrossNet& GetCrossNet() { return Graph->GetCrossNetById(GetCrossId()); }
394      friend class TMMNet;
395    };
396  public:
397    TCRef CRef; 
398  private:
399    TInt MxModeId; 
400    TInt MxCrossNetId; 
401    THash<TInt, TModeNet> TModeNetH;
402    THash<TInt, TCrossNet> TCrossNetH;
403    THash<TInt,TStr> ModeIdToNameH;
404    THash<TStr,TInt> ModeNameToIdH;
405    THash<TInt,TStr> CrossIdToNameH;
406    THash<TStr,TInt> CrossNameToIdH;
407  public:
408    friend class TCrossNet;
409    friend class TModeNet;
410  private:
411    class TModeNetInit {
412    public:
413      TModeNetInit() {}
414      void operator() (TModeNet* Node, TShMIn& ShMIn) { Node->LoadShM(ShMIn);}
415    };
416    class TCrossNetInit {
417    public:
418      TCrossNetInit() {}
<span onclick='openModal()' class='match'>419      void operator() (TCrossNet* Node, TShMIn& ShMIn) { Node->LoadShM(ShMIn);}
420    };
421  private:
422    void LoadNetworkShM(TShMIn& ShMIn);
423  public:
424    TMMNet() : CRef(), MxModeId(0), MxCrossNetId(0), TModeNetH(), TCrossNetH(), ModeIdToNameH(), ModeNameToIdH(), CrossIdToNameH(), CrossNameToIdH() {}
425    TMMNet(const TMMNet& OtherTMMNet) : MxModeId(OtherTMMNet.MxModeId), MxCrossNetId(OtherTMMNet.MxCrossNetId), TModeNetH(OtherTMMNet.TModeNetH), 
426      TCrossNetH(OtherTMMNet.TCrossNetH), ModeIdToNameH(OtherTMMNet.ModeIdToNameH), ModeNameToIdH(OtherTMMNet.ModeNameToIdH), CrossIdToNameH(OtherTMMNet.CrossIdToNameH), CrossNameToIdH(OtherTMMNet.CrossNameToIdH) {}
427    TMMNet(TSIn& SIn) : MxModeId(SIn), MxCrossNetId(SIn), TModeNetH(SIn), TCrossNetH(SIn), ModeIdToNameH(SIn), ModeNameToIdH(SIn), CrossIdToNameH(SIn), CrossNameToIdH(SIn) { 
</span>428      for (THash<TInt, TModeNet>::TIter it = TModeNetH.BegI(); it < TModeNetH.EndI(); it++) {
429        it.GetDat().SetParentPointer(this);
430      }
431      for (THash<TInt, TCrossNet>::TIter it = TCrossNetH.BegI(); it < TCrossNetH.EndI(); it++) {
432        it.GetDat().SetParentPointer(this);
433      }
434    }
435    int AddModeNet(const TStr& ModeName);
436    int DelModeNet(const TInt& ModeId); 
437    int DelModeNet(const TStr& ModeName);
438    int AddCrossNet(const TStr& ModeName1, const TStr& ModeName2, const TStr& CrossNetName, bool isDir=true);
439    int AddCrossNet(const TInt& ModeId1, const TInt& ModeId2, const TStr& CrossNetName, bool isDir=true);
440    int DelCrossNet(const TInt& CrossNetId);
441    int DelCrossNet(const TStr& CrossNet);
442    void Save(TSOut& SOut) const { MxModeId.Save(SOut); MxCrossNetId.Save(SOut); TModeNetH.Save(SOut); 
443      TCrossNetH.Save(SOut); ModeIdToNameH.Save(SOut); ModeNameToIdH.Save(SOut); CrossIdToNameH.Save(SOut);
444      CrossNameToIdH.Save(SOut); SOut.Flush(); }
445    static PMMNet Load(TSIn& SIn) { return PMMNet(new TMMNet(SIn)); }
446    static PMMNet LoadShM(TShMIn& ShMIn) {
447      TMMNet* Network = new TMMNet();
448      Network->LoadNetworkShM(ShMIn);
449      return PMMNet(Network);
450    }
451    static PMMNet New() { return PMMNet(new TMMNet()); }
452    void ConvertToSparse() {
453      for (THash<TInt, TModeNet>::TIter it = TModeNetH.BegI(); it < TModeNetH.EndI(); it++) {
454        it.GetDat().ConvertToSparse();
455      }
456    }
457    int GetModeId(const TStr& ModeName) const { if (ModeNameToIdH.IsKey(ModeName)) { return ModeNameToIdH.GetDat(ModeName); } else { return -1; }  }
458    TStr GetModeName(const TInt& ModeId) const { if (ModeIdToNameH.IsKey(ModeId)) { return ModeIdToNameH.GetDat(ModeId); } else {return TStr::GetNullStr();} }
459    int GetCrossId(const TStr& CrossName) const { if (CrossNameToIdH.IsKey(CrossName)) { return CrossNameToIdH.GetDat(CrossName); } else { return -1; }   }
460    TStr GetCrossName(const TInt& CrossId) const { if (CrossIdToNameH.IsKey(CrossId)) { return CrossIdToNameH.GetDat(CrossId); } else { return TStr::GetNullStr(); }  }
461    TModeNet& GetModeNetByName(const TStr& ModeName) const;
462    TModeNet& GetModeNetById(const TInt& ModeId) const;
463    TCrossNet& GetCrossNetByName(const TStr& CrossName) const;
464    TCrossNet& GetCrossNetById(const TInt& CrossId) const;
465    TCrossNetI GetCrossNetI(const int& Id) const { return TCrossNetI(TCrossNetH.GetI(Id), this); }
466    TCrossNetI BegCrossNetI() const { return TCrossNetI(TCrossNetH.BegI(), this); }
467    TCrossNetI EndCrossNetI() const { return TCrossNetI(TCrossNetH.EndI(), this); }
468    TModeNetI GetModeNetI(const int& Id) const { return TModeNetI(TModeNetH.GetI(Id), this); }
469    TModeNetI BegModeNetI() const { return TModeNetI(TModeNetH.BegI(), this); }
470    TModeNetI EndModeNetI() const { return TModeNetI(TModeNetH.EndI(), this); }
471    int GetModeNets() { return TModeNetH.Len(); }
472    int GetCrossNets() { return TCrossNetH.Len(); }
473    PMMNet GetSubgraphByCrossNet(TStrV& CrossNetTypes);
474    PMMNet GetSubgraphByModeNet(TStrV& ModeNetTypes);
475    PNEANet ToNetwork(TIntV& CrossNetTypes, TIntStrStrTrV& NodeAttrMap, TVec<TTriple<TInt, TStr, TStr> >& EdgeAttrMap);
476    PNEANet ToNetwork2(TIntV& CrossNetTypes, TIntStrPrVH& NodeAttrMap, THash<TInt, TVec<TPair<TStr, TStr> > >& EdgeAttrMap);
477    #ifdef GCC_ATOMIC
478    PNEANetMP ToNetworkMP(TStrV& CrossNetNames);
479    #endif 
480  private:
481    void ClrNbr(const TInt& ModeId, const TInt& CrossNetId, const bool& outEdge, const bool& sameMode, bool& isDir);
482    int AddMode(const TStr& ModeName, const TInt& ModeId, const TModeNet& ModeNet);
483    int AddCrossNet(const TStr& CrossNetName, const TInt& CrossNetId, const TCrossNet& CrossNet);
484    int AddNodeAttributes(PNEANet& NewNet, TModeNet& Net, TVec<TPair<TStr, TStr> >& Attrs, int ModeId, int oldId, int NId);
485    int AddEdgeAttributes(PNEANet& NewNet, TCrossNet& Net, TVec<TPair<TStr, TStr> >& Attrs, int CrossId, int oldId, int EId);
486    void GetPartitionRanges(TIntPrV& Partitions, const TInt& NumPartitions, const TInt& MxVal) const;
487  };
488  namespace TSnap {
489  template <> struct IsMultiGraph<TModeNet> { enum { Val = 1 }; };
490  template <> struct IsDirected<TModeNet> { enum { Val = 1 }; };
491  }
492  #endif 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-gmock-spec-builders.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-mmnet.h</div>
                </div>
                <div class="column column_space"><pre><code>469         it != mockers.end(); ++it) {
470      (*it)->ClearDefaultActionsLocked();
471    }
472  }
473  Expectation::Expectation() {}
474  Expectation::Expectation(
475      const internal::linked_ptr<internal::ExpectationBase>& an_expectation_base)
476      : expectation_base_(an_expectation_base) {}
477  Expectation::~Expectation() {}
</pre></code></div>
                <div class="column column_space"><pre><code>419      void operator() (TCrossNet* Node, TShMIn& ShMIn) { Node->LoadShM(ShMIn);}
420    };
421  private:
422    void LoadNetworkShM(TShMIn& ShMIn);
423  public:
424    TMMNet() : CRef(), MxModeId(0), MxCrossNetId(0), TModeNetH(), TCrossNetH(), ModeIdToNameH(), ModeNameToIdH(), CrossIdToNameH(), CrossNameToIdH() {}
425    TMMNet(const TMMNet& OtherTMMNet) : MxModeId(OtherTMMNet.MxModeId), MxCrossNetId(OtherTMMNet.MxCrossNetId), TModeNetH(OtherTMMNet.TModeNetH), 
426      TCrossNetH(OtherTMMNet.TCrossNetH), ModeIdToNameH(OtherTMMNet.ModeIdToNameH), ModeNameToIdH(OtherTMMNet.ModeNameToIdH), CrossIdToNameH(OtherTMMNet.CrossIdToNameH), CrossNameToIdH(OtherTMMNet.CrossNameToIdH) {}
427    TMMNet(TSIn& SIn) : MxModeId(SIn), MxCrossNetId(SIn), TModeNetH(SIn), TCrossNetH(SIn), ModeIdToNameH(SIn), ModeNameToIdH(SIn), CrossIdToNameH(SIn), CrossNameToIdH(SIn) { 
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    