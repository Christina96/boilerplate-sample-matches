
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 15, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-nlpwinlf.cpp</h3>
            <pre><code>1  #include "nlpwinlf.h"
2  void TLfSubst::GetLfSubstV(TLfSubstV& LfSubstV){
3    LfSubstV.Clr();
4    { 
5    PLfSubst LfSubst=TLfSubst::New("He"); LfSubstV.Add(LfSubst);
6    LfSubst->AddTarget("he"); LfSubst->AddTarget("him");
7    LfSubst->AddTarget("his"); LfSubst->AddTarget("himself");
8    LfSubst->AddSelBit("Masc");
9    LfSubst->AddSelBit("Sing");
10    LfSubst->AddSelBit("Humn");
11    }
12    { 
13    PLfSubst LfSubst=TLfSubst::New("She"); LfSubstV.Add(LfSubst);
14    LfSubst->AddTarget("she"); LfSubst->AddTarget("her");
15    LfSubst->AddTarget("hers"); LfSubst->AddTarget("herself");
16    LfSubst->AddSelBit("Fem");
17    LfSubst->AddSelBit("Sing");
18    LfSubst->AddSelBit("Humn");
19    }
20    { 
21    PLfSubst LfSubst=TLfSubst::New("Name"); LfSubstV.Add(LfSubst);
22    LfSubst->AddSelBit("Sing");
23    LfSubst->AddSelBit("PrprN");
24    }
25    { 
26    PLfSubst LfSubst=TLfSubst::New("They"); LfSubstV.Add(LfSubst);
27    LfSubst->AddTarget("they"); LfSubst->AddTarget("their");
28    LfSubst->AddSelBit("Plur");
29    LfSubst->AddSelBit("Humn");
30    }
31  }
32  void TLfSubst::Dump(const bool& DumpP, const TLfSubstV& LfSubstV){
33    if (!DumpP){return;}
34    printf("---Start-----Substitutions-------\n");
35    for (int LfSubstN=0; LfSubstN<LfSubstV.Len(); LfSubstN++){
36      PLfSubst LfSubst=LfSubstV[LfSubstN];
37      printf("%s : %s\n", LfSubst->SubstId.CStr(), LfSubst->SubstStr.CStr());
38    }
39    printf("---End-------Substitutions-------\n");
40  }
41  bool TLfAliasBs::IsGenericWord(const TStr& WordStr) const {
42    if (WordStr.IsChIn('.')){return true;}
43    if (SwSet->IsIn(WordStr)){return true;}
44    if (WordStr=="PRESIDENT"){return true;}
45    if (WordStr=="JUSTICE"){return true;}
46    if (WordStr=="JUDGE"){return true;}
47    if (WordStr=="NIGHT"){return true;}
48    if (WordStr=="U.S."){return true;}
49    if (WordStr=="SOUTH"){return true;}
50    if (WordStr=="NORTH"){return true;}
51    if (WordStr=="WEST"){return true;}
52    if (WordStr=="EAST"){return true;}
53    return false;
54  }
55  void TLfAliasBs::PutAliasStr(const TStr& SrcStr, const TStr& SubstId, TStr& DstStr){
56    TStr SrcUcStr=SrcStr.GetUc();
57    TStrV SrcUcStrV; SrcUcStr.SplitOnWs(SrcUcStrV);
58    for (int SrcUcStrN=0; SrcUcStrN<SrcUcStrV.Len(); SrcUcStrN++){
59      if (IsGenericWord(SrcUcStrV[SrcUcStrN])){
60        SrcUcStrV[SrcUcStrN]="";}
61    }
62    SrcUcStrV.DelAll("");
63    SrcUcStrV.Sort();
64    if (WordStrVToAliasStrH.IsKey(SrcUcStrV)){
65      DstStr=WordStrVToAliasStrH.GetDat(SrcUcStrV);
66      WordStrVToAliasH.GetDat(SrcUcStrV).IncFq();
67    } else {
68      for (int WAStrP=0; WAStrP<WordStrVToAliasStrH.Len(); WAStrP++){
69        TStrV& WordUcStrV=WordStrVToAliasStrH.GetKey(WAStrP);
70        TStr AliasStr=WordStrVToAliasStrH[WAStrP];
71        TStrV IntrsWordStrV; WordUcStrV.Intrs(SrcUcStrV, IntrsWordStrV);
72        if (IntrsWordStrV.Len()>0){
73          AddAlias(SrcUcStrV, SubstId, AliasStr);
74          DstStr=AliasStr;
75          return;
76        }
77      }
78      AddAlias(SrcUcStrV, SubstId, SrcStr);
79      DstStr=SrcStr;
80    }
81  }
82  void TLfAliasBs::UpdateLfSubstV(const TStr& AliasStr, const TLfSubstV& LfSubstV) const {
83    for (int WToAN=0; WToAN<WordStrVToAliasStrH.Len(); WToAN++){
84      if (WordStrVToAliasStrH[WToAN]==AliasStr){
85        TStrV& WordStrV=WordStrVToAliasStrH.GetKey(WToAN);
86        TStr SubstId=WordStrVToAliasH.GetDat(WordStrV).GetSubstId();
87        for (int LfSubstN=0; LfSubstN<LfSubstV.Len(); LfSubstN++){
88          if (LfSubstV[LfSubstN]->SubstId==SubstId){
89            LfSubstV[LfSubstN]->SubstStr=AliasStr;
90          }
91        }
92      }
93    }
94  }
95  void TLfAliasBs::AddAlias(
96   const TStrV& WordStrV, const TStr& SubstId, const TStr& AliasStr){
97    WordStrVToAliasStrH.AddDat(WordStrV, AliasStr);
98    IAssert(!WordStrVToAliasH.IsKey(WordStrV));
99    TLfAlias LfAlias(SubstId);
100    LfAlias.IncFq();
101    WordStrVToAliasH.AddDat(WordStrV, LfAlias);
102  }
103  void TLfAliasBs::MergeAliasBs(const PLfAliasBs& LfAliasBs){
104    int MnAliasFq=2;
105    int MnIntrsLen=2;
106    for (int NewWordStrVN=0; NewWordStrVN<LfAliasBs->WordStrVToAliasH.Len(); NewWordStrVN++){
107      TStrV& NewWordStrV=LfAliasBs->WordStrVToAliasH.GetKey(NewWordStrVN);
108      TStr NewAliasStr=LfAliasBs->WordStrVToAliasStrH.GetDat(NewWordStrV);
109      int NewAliasFq=LfAliasBs->WordStrVToAliasH[NewWordStrVN].GetFq();
110      if (NewAliasFq>=MnAliasFq){
111        if (WordStrVToAliasH.IsKey(NewWordStrV)){
<span onclick='openModal()' class='match'>112          WordStrVToAliasH.GetDat(NewWordStrV).IncFq(NewAliasFq);
113        } else {
114          TIntKdV IntrsLen_OldWordStrVNV;
</span>115          for (int OldWordStrVN=0; OldWordStrVN<WordStrVToAliasH.Len(); OldWordStrVN++){
116            TStrV& OldWordStrV=WordStrVToAliasH.GetKey(OldWordStrVN);
117            TStr OldAliasStr=WordStrVToAliasStrH.GetDat(OldWordStrV);
118            TStrV IntrsWordStrV; NewWordStrV.Intrs(OldWordStrV, IntrsWordStrV);
119            if (IntrsWordStrV.Len()>0){
120              IntrsLen_OldWordStrVNV.Add(TIntKd(IntrsWordStrV.Len(), OldWordStrVN));
121            }
122          }
123          IntrsLen_OldWordStrVNV.Sort(false);
124          if (IntrsLen_OldWordStrVNV.Len()==0){
125            TLfAlias NewLfAlias(LfAliasBs->WordStrVToAliasH[NewWordStrVN]);
126            WordStrVToAliasH.AddDat(NewWordStrV, NewLfAlias);
127            WordStrVToAliasStrH.AddDat(NewWordStrV, NewAliasStr);
128          } else
129          if (IntrsLen_OldWordStrVNV.Len()>=MnIntrsLen){
130            int OldWordStrVN=IntrsLen_OldWordStrVNV[0].Dat;
131            TStrV& OldWordStrV=WordStrVToAliasH.GetKey(OldWordStrVN);
132            TStr OldAliasStr=WordStrVToAliasStrH.GetDat(OldWordStrV);
133            TLfAlias NewLfAlias(LfAliasBs->WordStrVToAliasH[NewWordStrVN]);
134            WordStrVToAliasH.AddDat(NewWordStrV, NewLfAlias);
135            WordStrVToAliasStrH.AddDat(NewWordStrV, OldAliasStr);
136          }
137        }
138      }
139    }
140  }
141  void TLfAliasBs::Dump(const bool& DumpP, const int& MnAliasFq) const {
142    if (!DumpP){return;}
143    printf("Alias-Base\n");
144    TStrStrVPrV AliasStrWordStrVV;
145    WordStrVToAliasStrH.GetDatKeyPrV(AliasStrWordStrVV);
146    AliasStrWordStrVV.Sort();
147    for (int AliasN=0; AliasN<AliasStrWordStrVV.Len(); AliasN++){
148      TStr AliasStr=AliasStrWordStrVV[AliasN].Val1;
149      TStrV& WordStrV=AliasStrWordStrVV[AliasN].Val2;
150      TStr SubstId=WordStrVToAliasH.GetDat(WordStrV).GetSubstId();
151      int Fq=WordStrVToAliasH.GetDat(WordStrV).GetFq();
152      if ((MnAliasFq==-1)||(Fq>=MnAliasFq)){
153        printf("%s :", AliasStr.CStr());
154        for (int WordN=0; WordN<WordStrV.Len(); WordN++){
155          printf(" %s", WordStrV[WordN].CStr());}
156        printf(" [%s/%d]\n", SubstId.CStr(), Fq);
157      }
158    }
159    printf("======================\n");
160  }
161  TStrH TLfSpo::UnusableWordStrH;
162  bool TLfSpo::IsUsable() const {
163    if (UnusableWordStrH.Empty()){
164      UnusableWordStrH.AddKey(";");
165      UnusableWordStrH.AddKey(",");
166      UnusableWordStrH.AddKey("_");
167      UnusableWordStrH.AddKey("BEEN");
168      UnusableWordStrH.AddKey("ARE");
169      UnusableWordStrH.AddKey("AREN'T");
170      UnusableWordStrH.AddKey("IS");
171      UnusableWordStrH.AddKey("DID");
172      UnusableWordStrH.AddKey("WAS");
173      UnusableWordStrH.AddKey("WERE");
174      UnusableWordStrH.AddKey("IT");
175      UnusableWordStrH.AddKey("WE");
176      UnusableWordStrH.AddKey("I");
177      UnusableWordStrH.AddKey("YOU");
178      UnusableWordStrH.AddKey("AND");
179      UnusableWordStrH.AddKey("OR");
180      UnusableWordStrH.AddKey("HE");
181      UnusableWordStrH.AddKey("SHE");
182      UnusableWordStrH.AddKey("THIS");
183    }
184    TStr UcSubjStr=SubjStr.GetUc();
185    TStr UcObjStr=ObjStr.GetUc();
186    if ((UnusableWordStrH.IsKey(UcSubjStr))||(UnusableWordStrH.IsKey(UcObjStr))){
187      return false;
188    } else {
189      return true;
190    }
191  }
192  TStr TLfSpo::GetSent() const {
193    TChA SentChA;
194    SentChA+=SubjStr;
195    SentChA+=' ';
196    SentChA+=PredStr;
197    SentChA+=' ';
198    SentChA+=ObjStr;
199    if (SentChA.Len()>0){SentChA.PutCh(0, toupper(SentChA[0]));}
200    if ((SentChA.Len()>0)&&(SentChA.LastCh()!='.')){SentChA+='.';}
201    return SentChA;
202  }
203  TStr TLfSpo::GetLSent() const {
204    TChA SentChA;
205    SentChA+=LSubjStr;
206    SentChA+=' ';
207    SentChA+=PredStr;
208    SentChA+=' ';
209    SentChA+=LObjStr;
210    if (SentChA.Len()>0){
211      SentChA.PutCh(0, toupper(SentChA[0]));}
212    if (SentChA.Len()>0){
213      if ((SentChA.LastCh()==',')||(SentChA.LastCh()==';')){
214        SentChA.PutCh(SentChA.Len()-1, '.');
215      } else
216      if (SentChA.LastCh()!='.'){
217        SentChA+='.';
218      }
219    }
220    return SentChA;
221  }
222  bool TLfTree::IsSubLfTree(const TStr& SelLfTypeNm, const TStr& SelHeadTypeNm,
223   TStr& SubHeadStr, TStr& SubSentStr, PLfTree& SubLfTree) const {
224    for (int ObjLfTreeN=0; ObjLfTreeN<SubLfTreeV.Len(); ObjLfTreeN++){
225      SubLfTree=SubLfTreeV[ObjLfTreeN];
226      if ((!SelLfTypeNm.Empty())&&(SubLfTree->LfTypeNm!=SelLfTypeNm)){continue;}
227      if ((!SelHeadTypeNm.Empty())&&(SubLfTree->HeadTypeNm!=SelHeadTypeNm)){continue;}
228      SubHeadStr=SubLfTree->GetHeadOrSubstStr();
229      SubSentStr=SubLfTree->GetArSentStr();
230      return true;
231    }
232    SubHeadStr=""; SubSentStr=""; SubLfTree=NULL;
233    return false;
234  }
235  bool TLfTree::IsSubLfTree(const TStr& SelLfTypeNm, const TStr& SelHeadTypeNm,
236   TStr& SubHeadStr, TStr& SubSentStr) const {
237    PLfTree SubLfTree;
238    return IsSubLfTree(SelLfTypeNm, SelHeadTypeNm, SubHeadStr, SubSentStr, SubLfTree);
239  }
240  void TLfTree::GetLfSpoV(
241   TLfSpoV& LfSpoV, const int& MxLev,
242   const TStr& UpSubjStr, const TStr& UpLSubjStr) const {
243    if ((MxLev!=-1)&&(Lev>MxLev)){return;}
244    TStr NextUpSubjStr; TStr NextUpLSubjStr;
245    if (LfTypeNm=="Dsub"){
246      NextUpSubjStr=GetHeadOrSubstStr(); NextUpLSubjStr=GetArSentStr();
247    }
248    if (HeadTypeNm!="VERB"){
249      if (LfTypeNm=="Dobj"){&bsol;*NextUpObjStr=GetHeadOrSubstStr();*/}
250      else if (LfTypeNm=="Dind"){&bsol;*NextUpObjStr=GetHeadOrSubstStr();*/}
251    }
252    if (HeadTypeNm=="VERB"){
253      TStr PredStr=GetHeadOrSubstStr();
254      TStr SubjStr; TStr LSubjStr; PLfTree SubjLfTree;
255      if (IsSubLfTree("Dsub", "", SubjStr, LSubjStr, SubjLfTree)){
256        NextUpSubjStr=SubjStr; NextUpLSubjStr=LSubjStr;
257      }
258      TStr ObjStr; TStr LObjStr; PLfTree ObjLfTree;
259      if (IsSubLfTree("Dobj", "", ObjStr, LObjStr, ObjLfTree)){
260      } else
261      if (IsSubLfTree("Dind", "", ObjStr, LObjStr, ObjLfTree)){
262      }
263      if ((!ObjLfTree.Empty())&&(ObjLfTree->HeadTypeNm=="VERB")){
264        TStr SubSubjStr; TStr SubLSubjStr;
265        if (ObjLfTree->IsSubLfTree("Dsub", "", SubSubjStr, SubLSubjStr)){
266          ObjStr=SubSubjStr+" "+ObjStr;}
267        TStr SubObjStr; TStr SubLObjStr; PLfTree SubObjLfTree;
268        if (ObjLfTree->IsSubLfTree("Dobj", "NOUN", SubObjStr, SubLObjStr, SubObjLfTree)){
269          ObjStr=ObjStr+" "+SubObjStr; NextUpSubjStr=""; NextUpLSubjStr="";
270        } else
271        if (ObjLfTree->IsSubLfTree("Dind", "NOUN", SubObjStr, SubLObjStr, SubObjLfTree)){
272          ObjStr=ObjStr+" "+SubObjStr; NextUpSubjStr=""; NextUpLSubjStr="";
273        }
274        ObjLfTree=SubObjLfTree;
275        if (!ObjLfTree.Empty()){
276        }
277      }
278      if ((!SubjLfTree.Empty())&&(!ObjLfTree.Empty())){
279        LfSpoV.Add(TLfSpo::New(LSubjStr, SubjStr, PredStr, ObjStr, LObjStr));
280      }
281      if ((!UpSubjStr.Empty())&&(SubjLfTree.Empty())&&(!ObjLfTree.Empty())){
282        LfSpoV.Add(TLfSpo::New(UpLSubjStr, UpSubjStr, PredStr, ObjStr, LObjStr));
283      }
284    }
285    for (int SubLfTreeN=0; SubLfTreeN<SubLfTreeV.Len(); SubLfTreeN++){
286      PLfTree SubLfTree=SubLfTreeV[SubLfTreeN];
287      SubLfTree->GetLfSpoV(LfSpoV, MxLev, NextUpSubjStr, NextUpLSubjStr);
288    }
289  }
290  void TLfTree::GetLfSpoV(TLfSpoV& LfSpoV, const int& MxLev) const {
291    GetLfSpoV(LfSpoV, MxLev, "", "");
292  }
293  void TLfTree::PutSubst(
294   const TLfSubstV& LfSubstV, const PLfAliasBs& LfAliasBs,
295   TStrPrV& HeadStrSubstStrPrV, const bool& DumpP){
296    TStr HeadUcStr=HeadStr.GetUc();
297    for (int LfSubstN=0; LfSubstN<LfSubstV.Len(); LfSubstN++){
298      PLfSubst LfSubst=LfSubstV[LfSubstN];
299      if ((!BitNmV.Empty())&&(!LfSubst->SelBitNmV.Empty())){
300        bool BitMatchP=true;
301        for (int SelBitN=0; SelBitN<LfSubst->SelBitNmV.Len(); SelBitN++){
302          int BitN=0;
303          while ((BitN<BitNmV.Len())&&(LfSubst->SelBitNmV[SelBitN]!=BitNmV[BitN])){BitN++;}
304          if (BitN==BitNmV.Len()){BitMatchP=false; break;}
305        }
306        if (BitMatchP){
307          if (!LfSubst->TargetStrV.IsIn(HeadUcStr)){
308            LfAliasBs->PutAliasStr(HeadStr, LfSubst->SubstId, LfSubst->SubstStr);
309            LfAliasBs->UpdateLfSubstV(LfSubst->SubstStr, LfSubstV);
310            HeadSubstStr=LfSubst->SubstStr;
311            HeadStrSubstStrPrV.Add(TStrPr(HeadStr, LfSubst->SubstStr));
312            if (DumpP){
313              printf("New substitution for '%s': '%s' (from '%s')\n",
314               LfSubst->SubstId.CStr(), LfSubst->SubstStr.CStr(), HeadStr.CStr());
315            }
316          }
317        }
318      }
319      if ((!LfSubst->SubstStr.Empty())&&(LfSubst->TargetStrV.IsIn(HeadUcStr))){
320        HeadSubstStr=LfSubst->SubstStr;
321        HeadStrSubstStrPrV.Add(TStrPr(HeadStr, LfSubst->SubstStr));
322        if (DumpP){
323          printf("Substitute head: '%s' --> '%s'\n",
324           HeadStr.CStr(), LfSubst->SubstStr.CStr());
325        }
326      }
327    }
328    for (int SubLfTreeN=0; SubLfTreeN<SubLfTreeV.Len(); SubLfTreeN++){
329      SubLfTreeV[SubLfTreeN]->PutSubst(
330       LfSubstV, LfAliasBs, HeadStrSubstStrPrV, DumpP);
331    }
332    ArSentStr=TLfDoc::GenArSentStr(SentStr, HeadStrSubstStrPrV, false);
333  }
334  void TLfTree::ClrSubst(){
335    HeadSubstStr="";
336    for (int SubLfTreeN=0; SubLfTreeN<SubLfTreeV.Len(); SubLfTreeN++){
337      SubLfTreeV[SubLfTreeN]->ClrSubst();
338    }
339  }
340  PLfTree TLfTree::GetLfTree(const PXmlTok& TreeTok, const int& Lev){
341    if (!TreeTok.Empty()){
342      PLfTree LfTree=TLfTree::New();
343      LfTree->SentStr=TreeTok->GetArgVal("String", "");
344      LfTree->LfTypeNm=TreeTok->GetTagNm();
345      LfTree->Lev=Lev;
346      LfTree->HeadStr=TreeTok->GetArgVal("Head", "");
347      LfTree->HeadTypeNm=TreeTok->GetArgVal("HeadSegType", "");
348      PXmlTok BitsTok;
349      if (TreeTok->IsTagTok("Bits", BitsTok)){
350        int BitToks=BitsTok->GetSubToks();
351        for (int BitTokN=0; BitTokN<BitToks; BitTokN++){
352          PXmlTok BitTok=BitsTok->GetSubTok(BitTokN);
353          if (BitTok->IsTag()){
354            LfTree->BitNmV.Add(BitTok->GetTagNm());
355          }
356        }
357      }
358      int SubTrees=TreeTok->GetSubToks();
359      for (int SubTreeN=0; SubTreeN<SubTrees; SubTreeN++){
360        PXmlTok SubTreeTok=TreeTok->GetSubTok(SubTreeN);
361        PLfTree SubLfTree=GetLfTree(SubTreeTok, Lev+1);
362        if (!SubLfTree.Empty()){
363          LfTree->SubLfTreeV.Add(SubLfTree);}
364      }
365      return LfTree;
366    } else {
367      return NULL;
368    }
369  }
370  void TLfTree::Dump(){
371    if (LfTypeNm=="Bits"){return;}
372    for (int LevN=0; LevN<Lev; LevN++){printf("  ");}
373    if (HeadSubstStr.Empty()){
374      printf("%s:%s/%s\n", HeadStr.CStr(), HeadTypeNm.CStr(), LfTypeNm.CStr());
375    } else {
376      printf("%s[%s]:%s/%s\n",
377       HeadStr.CStr(), HeadSubstStr.CStr(), HeadTypeNm.CStr(), LfTypeNm.CStr());
378    }
379    for (int SubLfTreeN=0; SubLfTreeN<SubLfTreeV.Len(); SubLfTreeN++){
380      SubLfTreeV[SubLfTreeN]->Dump();
381    }
382  }
383  TStr TLfDoc::GenArSentStr(
384   const TStr& SentStr, const TStrPrV& HeadStrSubstStrPrV, const bool& PhraseP){
385    if (HeadStrSubstStrPrV.Empty()){return SentStr;}
386    TStr ArSentStr=SentStr;
387    TStrV UsedSubstStrV;
388    int SentSearchChN=0;
389    for (int HSPrN=0; HSPrN<HeadStrSubstStrPrV.Len(); HSPrN++){
390      TStr HeadStr=HeadStrSubstStrPrV[HSPrN].Val1;
391      TStr SubstStr=HeadStrSubstStrPrV[HSPrN].Val2;
392      if (HeadStr==SubstStr){continue;}
393      if (PhraseP){
394        SubstStr.ChangeChAll(' ', '_');
395        SubstStr.ChangeChAll('.', '_');
396        SubstStr.ChangeChAll(',', '_');
397      }
398      int PrevSentSearchChN=SentSearchChN;
399      forever{
400        SentSearchChN=ArSentStr.SearchStr(HeadStr, SentSearchChN);
401        if (SentSearchChN==-1){break;}
402        char PrevCh=TCh::NullCh;
403        char NextCh=TCh::NullCh;
404        if (SentSearchChN>0){PrevCh=ArSentStr[SentSearchChN-1];}
405        if (SentSearchChN+HeadStr.Len()<ArSentStr.Len()){
406          NextCh=ArSentStr[SentSearchChN+HeadStr.Len()];}
407        if ((!TCh::IsAlpha(PrevCh))&&(!TCh::IsAlpha(NextCh))){break;}
408        else {SentSearchChN++;}
409      }
410      if (SentSearchChN==-1){
411        SentSearchChN=PrevSentSearchChN;
412      } else {
413        if (!UsedSubstStrV.IsIn(SubstStr)){
414          ArSentStr.ChangeStr(HeadStr, SubstStr, SentSearchChN);
415          SentSearchChN+=SubstStr.Len();
416          UsedSubstStrV.Add(SubstStr);
417        }
418      }
419    }
420    {for (int HSPrN=0; HSPrN<HeadStrSubstStrPrV.Len(); HSPrN++){
421      TStr HeadStr=HeadStrSubstStrPrV[HSPrN].Val1;
422      TStr SubstStr=HeadStrSubstStrPrV[HSPrN].Val2;
423      if (HeadStr!=SubstStr){continue;}
424      if (!HeadStr.IsChIn(' ')){continue;}
425      if (PhraseP){
426        SubstStr.ChangeChAll(' ', '_');
427        SubstStr.ChangeChAll('.', '_');
428        SubstStr.ChangeChAll(',', '_');
429      }
430      int SentSearchChN=0;
431      forever{
432        SentSearchChN=ArSentStr.SearchStr(HeadStr, SentSearchChN);
433        if (SentSearchChN==-1){break;}
434        char PrevCh=TCh::NullCh;
435        char NextCh=TCh::NullCh;
436        if (SentSearchChN>0){PrevCh=ArSentStr[SentSearchChN-1];}
437        if (SentSearchChN+HeadStr.Len()<ArSentStr.Len()){
438          NextCh=ArSentStr[SentSearchChN+HeadStr.Len()];}
439        if ((!TCh::IsAlpha(PrevCh))&&(!TCh::IsAlpha(NextCh))){break;}
440        else {SentSearchChN++;}
441      }
442      if (SentSearchChN!=-1){
443        if (!UsedSubstStrV.IsIn(SubstStr)){
444          ArSentStr.ChangeStr(HeadStr, SubstStr, SentSearchChN);
445          UsedSubstStrV.Add(SubstStr);
446        }
447      }
448    }}
449    return ArSentStr;
450  }
451  void TLfDoc::GenHeadsSubst(const PLfAliasBs& CtxLfAliasBs, const bool& DumpP){
452    TLfSubstV LfSubstV; TLfSubst::GetLfSubstV(LfSubstV);
453    PLfAliasBs LfAliasBs=CtxLfAliasBs;
454    if (LfAliasBs.Empty()){
455      LfAliasBs=TLfAliasBs::New();}
456    int Sents=GetSents();
457    for (int SentN=0; SentN<Sents; SentN++){
458      TStr SentStr=GetSentStr(SentN);
459      if (DumpP){
460        printf("=================================\n");
461        printf("Sentence %d: %s\n", SentN, SentStr.CStr());
462        printf("-----------------\n");
463      }
464      PLfTree SentLfTree=GetSentLfTree(SentN);
465      TStrPrV HeadStrSubstStrPrV;
466      SentLfTree->PutSubst(LfSubstV, LfAliasBs, HeadStrSubstStrPrV, DumpP);
467      TStr ArSentStr=GenArSentStr(SentStr, HeadStrSubstStrPrV, true);
468      SentStrArSentStrPrV[SentN].Val2=ArSentStr;
469      if (DumpP){
470        printf("-----------------\n");
471        printf("ArSentence %d: %s\n", SentN, ArSentStr.CStr());
472      }
473      TLfSubst::Dump(DumpP, LfSubstV);
474      LfAliasBs->Dump(DumpP);
475    }
476  }
477  void TLfDoc::ClrHeadsSubst(){
478    int Sents=GetSents();
479    for (int SentN=0; SentN<Sents; SentN++){
480      PLfTree SentLfTree=GetSentLfTree(SentN);
481      SentLfTree->ClrSubst();
482    }
483  }
484  void TLfDoc::Dump(const int& DumpSentN) const {
485    printf("=========================\n");
486    printf("Document: '%s'\n", DocId.CStr());
487    for (int SentN=0; SentN<GetSents(); SentN++){
488      if ((SentN!=-1)&&(SentN!=DumpSentN)){continue;}
489      printf("-------------------------\n");
490      printf("Sentence[%d]: %s\n", SentN, GetSentStr(SentN).CStr());
491      printf("ArSenten[%d]: %s\n", SentN, GetArSentStr(SentN).CStr());
492      printf("-------------------------\n");
493      GetSentLfTree(SentN)->Dump();
494    }
495    printf("=========================\n");
496  }
497  PLfDoc TLfDocBs::GetLfDoc(const TStr& DocId) const {
498    int LfDocs=GetLfDocs();
499    for (int LfDocN=0; LfDocN<LfDocs; LfDocN++){
500      if (GetLfDoc(LfDocN)->DocId==DocId){
501        return GetLfDoc(LfDocN);
502      }
503    }
504    return NULL;
505  }
506  void TLfDocBs::GenHeadsSubst(const bool& DumpP){
507    int LfDocs=GetLfDocs();
508    for (int LfDocN=0; LfDocN<LfDocs; LfDocN++){
509      GetLfDoc(LfDocN)->GenHeadsSubst(NULL, DumpP);
510    }
511  }
512  void TLfDocBs::GenHeadsSubst(const TStrV& DocIdV, const bool& DumpP){
513    TLfAliasBsV LfAliasBsV;
514    for (int DocIdN=0; DocIdN<DocIdV.Len(); DocIdN++){
515      TStr DocId=DocIdV[DocIdN]; PLfDoc LfDoc;
516      if (IsLfDoc(DocId, LfDoc)){
517        PLfAliasBs LfAliasBs=TLfAliasBs::New();
518        LfDoc->GenHeadsSubst(LfAliasBs, false);
519        LfAliasBsV.Add(LfAliasBs);
520      }
521    }
522    PLfAliasBs TopLfAliasBs=TLfAliasBs::New();
523    for (int LfAliasBsN=0; LfAliasBsN<LfAliasBsV.Len(); LfAliasBsN++){
524      TopLfAliasBs->MergeAliasBs(LfAliasBsV[LfAliasBsN]);
525    }
526    TopLfAliasBs->Dump(DumpP);
527    for (int DocIdN=0; DocIdN<DocIdV.Len(); DocIdN++){
528      TStr DocId=DocIdV[DocIdN]; PLfDoc LfDoc;
529      if (IsLfDoc(DocId, LfDoc)){
530        LfDoc->ClrHeadsSubst();
531        PLfAliasBs LfAliasBs=TLfAliasBs::New(TopLfAliasBs);
532        LfDoc->GenHeadsSubst(LfAliasBs, false);
533      }
534    }
535  }
536  void TLfDocBs::GetCompClV(const PXmlTok& XmlTok, TStrV& CompClStrV) const {
537    if (XmlTok->IsTag("NP")&&XmlTok->IsArg("name")){
538      if (XmlTok->GetArgVal("name").IsPrefix("COMPCL")){
539        TStr CompClStr=XmlTok->GetArgVal("String");
540        CompClStrV.AddMerged(CompClStr);
541        return;
542      }
543    }
544    int SubToks=XmlTok->GetSubToks();
545    for (int SubTokN=0; SubTokN<SubToks; SubTokN++){
546      GetCompClV(XmlTok->GetSubTok(SubTokN), CompClStrV);
547    }
548  }
549  PLfDocBs TLfDocBs::LoadXml(const TStr& FNm, const bool& DumpP){
550    PLfDocBs LfDocBs=TLfDocBs::New();
551    PSIn XmlSIn=TFIn::New(FNm);
552    TXmlDoc::SkipTopTag(XmlSIn);
553    PXmlDoc XmlDoc; int XmlDocs=0;
554    forever{
555      XmlDocs++; printf("%d\r", XmlDocs);
556      XmlDoc=TXmlDoc::LoadTxt(XmlSIn);
557      if (!XmlDoc->IsOk()){break;}
558      PXmlTok DocTok=XmlDoc->GetTok();
559      IAssert(DocTok->IsTag("DOCUMENT"));
560      TStr DocId=DocTok->GetArgVal("NO");
561      printf("%s: ", DocId.CStr());
562      PLfDoc LfDoc=TLfDoc::New(DocId);
563      LfDocBs->AddLfDoc(LfDoc);
564      int SentToks=DocTok->GetSubToks();
565      for (int SentTokN=0; SentTokN<SentToks; SentTokN++){
566        PXmlTok SentTok=DocTok->GetSubTok(SentTokN);
567        if (!SentTok->IsTag("SENTENCE")){continue;}
568        TStr SentId=SentTok->GetArgVal("ID");
569        printf("[%d]", SentId.GetInt());
570        PXmlTok LfTok=SentTok->GetTagTok("NLP|LogicalForm");
571        TStr SentStr; PLfTree SentLfTree;
572        if (!LfTok.Empty()){
573          SentStr=LfTok->GetArgVal("String");
574          PXmlTok SentTreeTok=SentTok->GetTagTok("NLP|LogicalForm|Sentence");
575          SentLfTree=TLfTree::GetLfTree(SentTreeTok);
576          if (SentLfTree.Empty()){SentLfTree=TLfTree::New();}
577        } else {
578          SentLfTree=TLfTree::New();
579        }
580        LfDoc->AddSent(SentStr, SentLfTree);
581        IAssert(SentId.GetInt()==LfDoc->GetSents()-1);
582      }
583      printf("\n");
584      if (DumpP){LfDoc->Dump();}
585    }
586    return LfDocBs;
587  }
588  PLfDocBs TLfDocBs::LoadBinSet(const TStr& FPath, const TStr& FExt){
589    printf("Loading Logical-Form-Binary-Set...\n");
590    PLfDocBs LfDocBs=TLfDocBs::New();
591    TFFile FFile(FPath, FExt, true); TStr FNm;
592    while (FFile.Next(FNm)){
593      printf("%s\n", FNm.CStr());
594      PLfDocBs LocLfDocBs=TLfDocBs::LoadBin(FNm);
595      LfDocBs->AddLfDocBs(LocLfDocBs);
596    }
597    printf("Done.\n");
598    return LfDocBs;
599  }
600  void TLfDocBs::ConvXmlToLdb(const TStr& FNm, const bool& DumpP){
601    printf("%s\n", FNm.CStr());
602    PLfDocBs LfDocBs=TLfDocBs::LoadXml(FNm, DumpP);
603    LfDocBs->SaveBin(TStr::PutFExt(FNm, ".Ldb"));
604  }
605  void TLfDocBs::ConvSetXmlToLdb(const TStr& FPath, const bool& DumpP){
606    TFFile FFile(FPath, ".xml", false); TStr FNm;
607    while (FFile.Next(FNm)){
608      ConvXmlToLdb(FNm, DumpP);
609    }
610  }
611  void TLfDocBs::Dump() const {
612    for (int LfDocN=0; LfDocN<GetLfDocs(); LfDocN++){
613      GetLfDoc(LfDocN)->Dump();
614    }
615  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-table.h</h3>
            <pre><code>1  #ifndef TABLE_H
2  #define TABLE_H
3  typedef enum {NOT, AND, OR, NOP} TPredOp; 
4  typedef enum {LT = 0, LTE, EQ, NEQ, GTE, GT, SUBSTR, SUPERSTR} TPredComp; 
5  class TAtomicPredicate;
6  class TPredicateNode;
7  class TPredicate;
8  class TAtomicPredicate {
9    private:
10      TAttrType Type; 
11      TBool IsConst; 
12      TPredComp Compare; 
13      TStr Lvar; 
14      TStr Rvar; 
15      TInt IntConst; 
16      TFlt FltConst; 
17      TStr StrConst; 
18    public:
19      TAtomicPredicate() : Type(atInt), IsConst(true), 
20        Compare(EQ), Lvar(""), Rvar(""), 
21        IntConst(0), FltConst(0), StrConst("") {}
22      TAtomicPredicate(TAttrType Typ, TBool IsCnst, TPredComp Cmp, TStr L, TStr R, 
23      TInt ICnst, TFlt FCnst, TStr SCnst) : Type(Typ), IsConst(IsCnst), 
24        Compare(Cmp), Lvar(L), Rvar(R), IntConst(ICnst), FltConst(FCnst),
25        StrConst(SCnst) {}
26      TAtomicPredicate(TAttrType Typ, TBool IsCnst, TPredComp Cmp, TStr L, TStr R) :
27        Type(Typ), IsConst(IsCnst), Compare(Cmp), Lvar(L), Rvar(R), IntConst(0), 
28        FltConst(0), StrConst("") {}
29      friend class TPredicate;
30  		friend class TPredicateNode;
31  };
32  class TPredicateNode {
33  	public:
34  		TPredOp Op; 
35  		TBool Result; 
36  		TAtomicPredicate Atom; 
37  		TPredicateNode* Parent; 
38  		TPredicateNode* Left; 
39  		TPredicateNode* Right; 
40  		TPredicateNode(): Op(NOP), Result(false), Atom(), Parent(NULL), Left(NULL), 
41  			Right(NULL) {}
42  		TPredicateNode(const TAtomicPredicate& A): Op(NOP), Result(false), Atom(A), 
43  			Parent(NULL), Left(NULL), Right(NULL) {}
44  		TPredicateNode(TPredOp Opr): Op(Opr), Result(false), Atom(), Parent(NULL), 
45  			Left(NULL), Right(NULL) {}
46  		TPredicateNode(const TPredicateNode& P): Op(P.Op), Result(P.Result), Atom(P.Atom), 
47  			Parent(P.Parent), Left(P.Left), Right(P.Right) {}
48  		void AddLeftChild(TPredicateNode* Child) { Left = Child; Child->Parent = this; }
49  		void AddRightChild(TPredicateNode* Child) { Right = Child; Child->Parent = this; }
50  		void GetVariables(TStrV& Variables);
51  		friend class TPredicate;
52  };
53  class TPredicate {
54  	protected:
55  		THash<TStr, TInt> IntVars; 
56  		THash<TStr, TFlt> FltVars; 
57  		THash<TStr, TStr> StrVars; 
58  		TPredicateNode* Root; 
59  	public:
60  		TPredicate() : IntVars(), FltVars(), StrVars() {}
61  		TPredicate(TPredicateNode* R) : IntVars(), FltVars(), StrVars(), Root(R) {}
62  		TPredicate(const TPredicate& Pred) : IntVars(Pred.IntVars), FltVars(Pred.FltVars), StrVars(Pred.StrVars), Root(Pred.Root) {}
63  		void GetVariables(TStrV& Variables);
64  		void SetIntVal(TStr VarName, TInt VarVal) { IntVars.AddDat(VarName, VarVal); }
65  		void SetFltVal(TStr VarName, TFlt VarVal) { FltVars.AddDat(VarName, VarVal); }
66  		void SetStrVal(TStr VarName, TStr VarVal) { StrVars.AddDat(VarName, VarVal); }
67  		TBool Eval();
68  		TBool EvalAtomicPredicate(const TAtomicPredicate& Atom);
69  		template <class T>
70  		static TBool EvalAtom(T Val1, T Val2, TPredComp Cmp) {
71  			switch (Cmp) {
72  				case LT: return Val1 < Val2;
73  				case LTE: return Val1 <= Val2;
74  				case EQ: return Val1 == Val2;
75  				case NEQ: return Val1 != Val2;
76  				case GTE: return Val1 >= Val2;
77  				case GT: return Val1 > Val2;
78  				default: return false;
79  			}
80  		};
81  		static TBool EvalStrAtom(const TStr& Val1, const TStr& Val2, TPredComp Cmp) {
82  			switch (Cmp) {
83  				case LT: return Val1 < Val2;
84  				case LTE: return Val1 <= Val2;
85  				case EQ: return Val1 == Val2;
86  				case NEQ: return Val1 != Val2;
87  				case GTE: return Val1 >= Val2;
88  				case GT: return Val1 > Val2;
89  				case SUBSTR: return Val2.IsStrIn(Val1);
90  				case SUPERSTR: return Val1.IsStrIn(Val2);
91  				default: return false;
92  			}
93  		}
94  };
95  class TTable;
96  class TTableContext;
97  typedef TPt<TTable> PTable;
98  typedef TPair<TIntV, TFltV> TGroupKey;
99  typedef enum {L1Norm, L2Norm, Jaccard, Haversine} TSimType;
100  #if 0
101  class TMetric {
102  protected:
103    TStr MetricName; 
104  public:
105    TMetric(TStr Name) : MetricName(Name) {}
106    TStr GetName();
107    virtual TFlt NumDist(TFlt,TFlt) { return -1; }
108    virtual TFlt StrDist(TStr,TStr) { return -1; }
109  };
110  class TEuclideanMetric: public TMetric {
111  public:
112    TEuclideanMetric(TStr Name) : TMetric(Name) {}
113    TFlt NumDist(TFlt x1,TFlt x2) { return fabs(x1-x2); }
114  };
115  #endif
116  class TTableContext {
117  protected:
118    TStrHash<TInt, TBigStrPool> StringVals; 
119    friend class TTable;
120  public:
121    TTableContext() {}
122    TTableContext(TSIn& SIn): StringVals(SIn) {}
123    void Load(TSIn& SIn) { StringVals.Load(SIn); }
124    void LoadShM(TShMIn& ShMIn) {
125      StringVals.LoadShM(ShMIn, true);
126    }
127    void Save(TSOut& SOut) { StringVals.Save(SOut); }
128    TInt AddStr(const TStr& Key) {
129      TInt KeyId = TInt(StringVals.AddKey(Key));
130      return(KeyId);
131    }
132    TStr GetStr(const TInt& KeyId) const {
133      return StringVals.GetKey(KeyId);
134    }
135  };
136  class TPrimitive {
137  private:
138    TInt IntVal;
139    TFlt FltVal;
140    TStr StrVal;
141    TAttrType AttrType;
142  public:
143    TPrimitive() : IntVal(-1), FltVal(-1), StrVal(""), AttrType(atInt) {}
144    TPrimitive(const TInt& Val) : IntVal(Val), FltVal(-1), StrVal(""), AttrType(atInt) {}
145    TPrimitive(const TFlt& Val) : IntVal(-1), FltVal(Val), StrVal(""), AttrType(atFlt) {}
146    TPrimitive(const TStr& Val) : IntVal(-1), FltVal(-1), StrVal(Val.CStr()), AttrType(atStr) {}
147    TPrimitive(const TPrimitive& Prim) : IntVal(Prim.IntVal), FltVal(Prim.FltVal),
148      StrVal(Prim.StrVal.CStr()), AttrType(Prim.AttrType) {}
149    TInt GetInt() const { return IntVal; }
150    TFlt GetFlt() const { return FltVal; }
151    TStr GetStr() const { return StrVal; }
152    TAttrType GetType() const { return AttrType; }
153  };
154  class TTableRow {
155  protected:
156    TIntV IntVals; 
157    TFltV FltVals; 
158    TStrV StrVals; 
159  public:
160    TTableRow() {}
161    void AddInt(const TInt& Val) { IntVals.Add(Val); }
162    void AddFlt(const TFlt& Val) { FltVals.Add(Val); }
163    void AddStr(const TStr& Val) { StrVals.Add(Val); }
164    TIntV GetIntVals() const { return IntVals; }
165    TFltV GetFltVals() const { return FltVals; }
166    TStrV GetStrVals() const { return StrVals; }
167  };
168  typedef enum {aaMin, aaMax, aaFirst, aaLast, aaMean, aaMedian, aaSum, aaCount} TAttrAggr;
169  typedef enum {aoAdd, aoSub, aoMul, aoDiv, aoMod, aoMin, aoMax} TArithOp;
170  typedef TVec<TPair<TStr, TAttrType> > Schema;
171  class GroupStmt{
172  protected:
173  	TStrV GroupByAttrs;
174  	TBool Ordered;
175  	TBool UsePhysicalRowIds;
176  	TBool Valid;
177  public:
178  	GroupStmt(): GroupByAttrs(TStrV()), Ordered(true), UsePhysicalRowIds(true), Valid(true){}
179  	GroupStmt(const TStrV& Attrs): GroupByAttrs(Attrs), Ordered(true), UsePhysicalRowIds(true), Valid(true){}
180  	GroupStmt(const TStrV& Attrs, TBool ordered, TBool physical): GroupByAttrs(Attrs), Ordered(ordered), UsePhysicalRowIds(physical), Valid(true){}
181  	GroupStmt(const GroupStmt& stmt): GroupByAttrs(stmt.GroupByAttrs), Ordered(stmt.Ordered), UsePhysicalRowIds(stmt.UsePhysicalRowIds), Valid(stmt.Valid){}
182  	TBool UsePhysicalIds(){return UsePhysicalRowIds;}
183  	TBool operator ==(const GroupStmt& stmt) const{
184  		if(stmt.Ordered != Ordered || stmt.UsePhysicalRowIds != UsePhysicalRowIds){ return false;}
185  		if(stmt.GroupByAttrs.Len() != GroupByAttrs.Len()){ return false;}
186  		for(int i = 0; i < GroupByAttrs.Len(); i++){
187  			if(stmt.GroupByAttrs[i] != GroupByAttrs[i]){ return false;}
188  		}
189  		return true;
190  	}
191  	TBool IsValid(){ return Valid;}
192  	void Invalidate(){ Valid = false;}
193  	TBool IncludesAttr(const TStr& Attr){
194  		for(int i = 0; i < GroupByAttrs.Len(); i++){
195  			if(GroupByAttrs[i] == Attr){ return true;}
196  		}
197  		return false;
198  	}
199  	TSize GetMemUsed() const{
200  		TSize sz = 3 * sizeof(TBool);
201  		sz += GroupByAttrs.GetMemUsed();
202  		for(int i = 0; i < GroupByAttrs.Len(); i++){
203  			sz += GroupByAttrs[i].GetMemUsed();
204  		}
205  		return sz;
206  	}
207  	int GetPrimHashCd() const{
208  		int hc1 = GroupByAttrs.GetPrimHashCd();
209  		TTriple<TBool,TBool,TBool> flags;
210  		int hc2 = flags.GetPrimHashCd();
211  		return TPairHashImpl::GetHashCd(hc1, hc2);
212  	}
213  	int GetSecHashCd() const{
214  		int hc1 = GroupByAttrs.GetSecHashCd();
215  		TTriple<TBool,TBool,TBool> flags;
216  		int hc2 = flags.GetSecHashCd();
217  		return TPairHashImpl::GetHashCd(hc1, hc2);
218  	}
219  	void Print(){
220  		for(int i = 0; i < GroupByAttrs.Len(); i++){
221  			printf("%s ", GroupByAttrs[i].CStr());
222  		}
223  		printf("Ordered: %d, UsePhysicalRows: %d, Valid: %d\n", Ordered.Val, UsePhysicalRowIds.Val, Valid.Val);
224  	}
225  };
226  class TRowIterator{
227    TInt CurrRowIdx; 
228    const TTable* Table; 
229  public:
230    TRowIterator(): CurrRowIdx(0), Table(NULL) {}
231    TRowIterator(TInt RowIdx, const TTable* TablePtr): CurrRowIdx(RowIdx), Table(TablePtr) {}
232    TRowIterator(const TRowIterator& RowI): CurrRowIdx(RowI.CurrRowIdx), Table(RowI.Table) {}
233    TRowIterator& operator++(int);
234    TRowIterator& Next();
235    bool operator < (const TRowIterator& RowI) const;
236    bool operator == (const TRowIterator& RowI) const;
237    TInt GetRowIdx() const;
238    TInt GetIntAttr(TInt ColIdx) const;
239    TFlt GetFltAttr(TInt ColIdx) const;
240    TStr GetStrAttr(TInt ColIdx) const;
241    TInt GetStrMapById(TInt ColIdx) const;
242    TInt GetIntAttr(const TStr& Col) const;
243    TFlt GetFltAttr(const TStr& Col) const;
244    TStr GetStrAttr(const TStr& Col) const;
245    TInt GetStrMapByName(const TStr& Col) const;
246    TBool CompareAtomicConst(TInt ColIdx, const TPrimitive& Val, TPredComp Cmp);
247    TBool CompareAtomicConstTStr(TInt ColIdx, const  TStr& Val, TPredComp Cmp);
248  };
249  class TRowIteratorWithRemove {
250    TInt CurrRowIdx; 
251    TTable* Table; 
252    TBool Start;	
253  public:
254    TRowIteratorWithRemove(): CurrRowIdx(0), Table(NULL), Start(true) {}
255    TRowIteratorWithRemove(TInt RowIdx, TTable* TablePtr);
256    TRowIteratorWithRemove(TInt RowIdx, TTable* TablePtr, TBool IsStart) : CurrRowIdx(RowIdx),
257      Table(TablePtr), Start(IsStart) {}
258    TRowIteratorWithRemove(const TRowIteratorWithRemove& RowI) : CurrRowIdx(RowI.CurrRowIdx),
259      Table(RowI.Table), Start(RowI.Start) {}
260    TRowIteratorWithRemove& operator++(int);
261    TRowIteratorWithRemove& Next();
262    bool operator < (const TRowIteratorWithRemove& RowI) const;
263    bool operator == (const TRowIteratorWithRemove& RowI) const;
264    TInt GetRowIdx() const;
265    TInt GetNextRowIdx() const;
266    TInt GetNextIntAttr(TInt ColIdx) const;
267    TFlt GetNextFltAttr(TInt ColIdx) const;
268    TStr GetNextStrAttr(TInt ColIdx) const;
269    TInt GetNextIntAttr(const TStr& Col) const;
270    TFlt GetNextFltAttr(const TStr& Col) const;
271    TStr GetNextStrAttr(const TStr& Col) const;
272    TBool IsFirst() const;
273    void RemoveNext();
274    TBool CompareAtomicConst(TInt ColIdx, const TPrimitive& Val, TPredComp Cmp);
275  };
276  class TTableIterator {
277    TVec<PTable> PTableV; 
278    TInt CurrTableIdx; 
279  public:
280    TTableIterator(TVec<PTable>& PTableV): PTableV(PTableV), CurrTableIdx(0) {}
281    PTable Next() { return PTableV[CurrTableIdx++]; }
282    bool HasNext() { return CurrTableIdx < PTableV.Len(); }
283  };
284  namespace TSnap {
285  	template<class PGraph> PGraph ToGraph(PTable Table,
286      const TStr& SrcCol, const TStr& DstCol, TAttrAggr AggrPolicy);
287    template<class PGraph> PGraph ToNetwork(PTable Table,
288      const TStr& SrcCol, const TStr& DstCol,
289      TStrV& SrcAttrs, TStrV& DstAttrs, TStrV& EdgeAttrs,
290      TAttrAggr AggrPolicy);
291    template<class PGraph> PGraph ToNetwork(PTable Table,
292      const TStr& SrcCol, const TStr& DstCol, TAttrAggr AggrPolicy);
293    template<class PGraph> PGraph ToNetwork(PTable Table,
294      const TStr& SrcCol, const TStr& DstCol,
295      TStrV& EdgeAttrV,
296      TAttrAggr AggrPolicy);
297    template<class PGraph> PGraph ToNetwork(PTable Table,
298      const TStr& SrcCol, const TStr& DstCol,
299      TStrV& EdgeAttrV, PTable NodeTable, const TStr& NodeCol, TStrV& NodeAttrV,
300      TAttrAggr AggrPolicy);
301    int LoadCrossNet(TCrossNet& Graph, PTable Table,
302      const TStr& SrcCol, const TStr& DstCol,
303      TStrV& EdgeAttrV);
304    int LoadMode(TModeNet& Graph, PTable Table, const TStr& NCol,
305      TStrV& NodeAttrV);
306  #ifdef GCC_ATOMIC
307    template<class PGraphMP> PGraphMP ToGraphMP(PTable Table,
308      const TStr& SrcCol, const TStr& DstCol);
309    template<class PGraphMP> PGraphMP ToGraphMP3(PTable Table,
310      const TStr& SrcCol, const TStr& DstCol);
311    template<class PGraphMP> PGraphMP ToNetworkMP(PTable Table, const TStr& SrcCol, const TStr& DstCol,
312  		  TStrV& SrcAttrs, TStrV& DstAttrs, TStrV& EdgeAttrs, TAttrAggr AggrPolicy);
313    template<class PGraphMP> PGraphMP ToNetworkMP2(PTable Table, const TStr& SrcCol, const TStr& DstCol,
314  		  TStrV& SrcAttrs, TStrV& DstAttrs, TStrV& EdgeAttrs, TAttrAggr AggrPolicy);
315    template<class PGraphMP> PGraphMP ToNetworkMP(PTable Table, const TStr& SrcCol, const TStr& DstCol,
316  		  TStrV& EdgeAttrV, TAttrAggr AggrPolicy);
317    template<class PGraphMP> PGraphMP ToNetworkMP(PTable Table, const TStr& SrcCol, const TStr& DstCol,
318  		  TAttrAggr AggrPolicy);
319    template<class PGraphMP> PGraphMP ToNetworkMP(PTable Table, const TStr& SrcCol, const TStr& DstCol,
320  		  TStrV& EdgeAttrV, PTable NodeTable, const TStr& NodeCol, TStrV& NodeAttrV, TAttrAggr AggrPolicy);
321  #endif 
322  }
323  class TTable {
324  protected:
325    static const TInt Last; 
326    static const TInt Invalid; 
327    static TInt UseMP; 
328  public:
329    template<class PGraph> friend PGraph TSnap::ToGraph(PTable Table,
330      const TStr& SrcCol, const TStr& DstCol, TAttrAggr AggrPolicy);
331    template<class PGraph> friend PGraph TSnap::ToNetwork(PTable Table,
332      const TStr& SrcCol, const TStr& DstCol,
333      TStrV& SrcAttrs, TStrV& DstAttrs, TStrV& EdgeAttrs,
334      TAttrAggr AggrPolicy);
335    template<class PGraph> friend PGraph TSnap::ToNetwork(PTable Table,
336      const TStr& SrcCol, const TStr& DstCol,
337      TAttrAggr AggrPolicy);
338    template<class PGraph> friend PGraph TSnap::ToNetwork(PTable Table,
339      const TStr& SrcCol, const TStr& DstCol,
340      TStrV& EdgeAttrV,
341      TAttrAggr AggrPolicy);
342    template<class PGraph> friend PGraph TSnap::ToNetwork(PTable Table,
343      const TStr& SrcCol, const TStr& DstCol,
344      TStrV& EdgeAttrV, PTable NodeTable, const TStr& NodeCol, TStrV& NodeAttrV,
345      TAttrAggr AggrPolicy);
346    friend int TSnap::LoadCrossNet(TCrossNet& Graph, PTable Table,
347        const TStr& SrcCol, const TStr& DstCol,
348        TStrV& EdgeAttrV);
349    friend int TSnap::LoadMode(TModeNet& Graph, PTable Table,
350        const TStr& NCol, TStrV& NodeAttrV); 
351  #ifdef GCC_ATOMIC
352    template<class PGraphMP> friend PGraphMP TSnap::ToGraphMP(PTable Table, const TStr& SrcCol, const TStr& DstCol);
353    template<class PGraphMP> friend PGraphMP TSnap::ToGraphMP3(PTable Table, const TStr& SrcCol, const TStr& DstCol);
354    template<class PGraphMP> friend PGraphMP TSnap::ToNetworkMP(PTable Table, const TStr& SrcCol, const TStr& DstCol, TStrV& SrcAttrs, TStrV& DstAttrs, TStrV& EdgeAttrs, TAttrAggr AggrPolicy);
355    template<class PGraphMP> friend PGraphMP TSnap::ToNetworkMP2(PTable Table, const TStr& SrcCol, const TStr& DstCol,  TStrV& SrcAttrs, TStrV& DstAttrs, TStrV& EdgeAttrs, TAttrAggr AggrPolicy);
356    template<class PGraphMP> friend PGraphMP TSnap::ToNetworkMP(PTable Table, const TStr& SrcCol, const TStr& DstCol, TStrV& EdgeAttrV, TAttrAggr AggrPolicy);
357    template<class PGraphMP> friend PGraphMP TSnap::ToNetworkMP(PTable Table, const TStr& SrcCol, const TStr& DstCol, TAttrAggr AggrPolicy);
358    template<class PGraphMP> friend PGraphMP TSnap::ToNetworkMP(PTable Table, const TStr& SrcCol, const TStr& DstCol,
359  		  TStrV& EdgeAttrV, PTable NodeTable, const TStr& NodeCol, TStrV& NodeAttrV, TAttrAggr AggrPolicy);
360  #endif 
361    static void SetMP(TInt Value) { UseMP = Value; }
362    static TInt GetMP() { return UseMP; }
363    static TStr NormalizeColName(const TStr& ColName) {
364      TStr Result = ColName;
365      int RLen = Result.Len();
366      if (RLen == 0) { return Result; }
367      if (Result.GetCh(0) == '_') { return Result; }
368      if (RLen >= 2  &&  Result.GetCh(RLen-2) == '-') { return Result; }
369      return Result + "-1";
370    }
371    static TStrV NormalizeColNameV(const TStrV& Cols) {
372      TStrV NCols;
373      for (TInt i = 0; i < Cols.Len(); i++) { NCols.Add(NormalizeColName(Cols[i])); }
374      return NCols;
375    }
376  protected:
377    TTableContext* Context;  
378    Schema Sch; 
379    TCRef CRef;
380    TInt NumRows; 
381    TInt NumValidRows; 
382    TInt FirstValidRow; 
383    TInt LastValidRow; 
384    TIntV Next; 
385    TVec<TIntV> IntCols; 
386    TVec<TFltV> FltCols; 
387    TVec<TIntV> StrColMaps; 
388    THash<TStr,TPair<TAttrType,TInt> > ColTypeMap; 
389    TStr IdColName; 
390    TIntIntH RowIdMap; 
391    THash<TStr, THash<TInt, TIntV> > IntColIndexes; 
392    THash<TStr, THash<TInt, TIntV> > StrMapColIndexes; 
393    THash<TStr, THash<TFlt, TIntV> > FltColIndexes; 
394    THash<TStr, GroupStmt > GroupStmtNames; 
395    THash<GroupStmt, THash<TInt, TGroupKey> >GroupIDMapping; 
396    THash<GroupStmt, THash<TGroupKey, TIntV> >GroupMapping; 
397    void InvalidatePhysicalGroupings(); 
398    void InvalidateAffectedGroupings(const TStr& Attr); 
399    TStr SrcCol; 
400    TStr DstCol; 
401    TStrV EdgeAttrV; 
402    TStrV SrcNodeAttrV; 
403    TStrV DstNodeAttrV; 
404    TStrTrV CommonNodeAttrs; 
405    TVec<TIntV> RowIdBuckets; 
406    TInt CurrBucket; 
407    TAttrAggr AggrPolicy; 
408    TInt IsNextDirty; 
409  public:
410    void AddIntCol(const TStr& ColName);
411    void AddFltCol(const TStr& ColName);
412    void AddStrCol(const TStr& ColName);
413  protected:
414    void IncrementNext();
415    void ClassifyAux(const TIntV& SelectedRows, const TStr& LabelName,
416     const TInt& PositiveLabel = 1, const TInt& NegativeLabel=  0);
417    const char* GetContextKey(TInt Val) const {
418  	  return Context->StringVals.GetKey(Val);
419    }
420    TStr GetStrValIdx(TInt ColIdx, TInt RowIdx) const {
421      return TStr(Context->StringVals.GetKey(StrColMaps[ColIdx][RowIdx]));
422    }
423    void AddStrVal(const TInt& ColIdx, const TStr& Val);
424    void AddStrVal(const TStr& Col, const TStr& Val);
425    TStr GetIdColName() const { return IdColName; }
426    TStr GetSchemaColName(TInt Idx) const { return Sch[Idx].Val1; }
427    TAttrType GetSchemaColType(TInt Idx) const { return Sch[Idx].Val2; }
428    void AddSchemaCol(const TStr& ColName, TAttrType ColType) {
429      TStr NColName = NormalizeColName(ColName);
430      Sch.Add(TPair<TStr,TAttrType>(NColName, ColType));
431    }
432    TBool IsColName(const TStr& ColName) const {
433      TStr NColName = NormalizeColName(ColName);
434      return ColTypeMap.IsKey(NColName);
435    }
436    void AddColType(const TStr& ColName, TPair<TAttrType,TInt> ColType) {
437      TStr NColName = NormalizeColName(ColName);
438      ColTypeMap.AddDat(NColName, ColType);
439    }
440    void AddColType(const TStr& ColName, TAttrType ColType, TInt Index) {
441      TStr NColName = NormalizeColName(ColName);
442      AddColType(NColName, TPair<TAttrType,TInt>(ColType, Index));
443    }
444    void DelColType(const TStr& ColName) {
445      TStr NColName = NormalizeColName(ColName);
446      ColTypeMap.DelKey(NColName);
447    }
448    TPair<TAttrType, TInt> GetColTypeMap(const TStr& ColName) const {
449      TStr NColName = NormalizeColName(ColName);
450      return ColTypeMap.GetDat(NColName);
451    }
452    TStr RenumberColName(const TStr& ColName) const;
453    TStr DenormalizeColName(const TStr& ColName) const;
454    Schema DenormalizeSchema() const;
455    TBool IsAttr(const TStr& Attr);
456    void AddTable(const TTable& T);
457    void ConcatTable(const PTable& T) {AddTable(*T); Reindex(); }
458    void AddRowI(const TRowIterator& RI);
459    void AddRowV(const TIntV& IntVals, const TFltV& FltVals, const TStrV& StrVals);
460    void AddGraphAttribute(const TStr& Attr, TBool IsEdge, TBool IsSrc, TBool IsDst);
461    void AddGraphAttributeV(TStrV& Attrs, TBool IsEdge, TBool IsSrc, TBool IsDst);
462    void CheckAndAddIntNode(PNEANet Graph, THashSet<TInt>& NodeVals, TInt NodeId);
463    template<class T> TInt CheckAndAddFltNode(T Graph, THash<TFlt, TInt>& NodeVals, TFlt FNodeVal);
464    void AddEdgeAttributes(PNEANet& Graph, int RowId);
465    void AddNodeAttributes(TInt NId, TStrV NodeAttrV, TInt RowId,
466     THash<TInt, TStrIntVH>& NodeIntAttrs, THash<TInt, TStrFltVH>& NodeFltAttrs,
467     THash<TInt, TStrStrVH>& NodeStrAttrs);
468    PNEANet BuildGraph(const TIntV& RowIds, TAttrAggr AggrPolicy);
469    void InitRowIdBuckets(int NumBuckets);
470    void FillBucketsByWindow(TStr SplitAttr, TInt JumpSize, TInt WindowSize,
471     TInt StartVal, TInt EndVal);
472    void FillBucketsByInterval(TStr SplitAttr, TIntPrV SplitIntervals);
473    TVec<PNEANet> GetGraphsFromSequence(TAttrAggr AggrPolicy);
474    PNEANet GetFirstGraphFromSequence(TAttrAggr AggrPolicy);
475    PNEANet GetNextGraphFromSequence();
476    template <class T> T AggregateVector(TVec<T>& V, TAttrAggr Policy);
477    void GroupingSanityCheck(const TStr& GroupBy, const TAttrType& AttrType) const;
478    template <class T> void GroupByIntCol(const TStr& GroupBy, T& Grouping, 
479      const TIntV& IndexSet, TBool All, TBool UsePhysicalIds = true) const;
480  #ifdef GCC_ATOMIC
481    public:	
482    void GroupByIntColMP(const TStr& GroupBy, THashMP<TInt, TIntV>& Grouping, TBool UsePhysicalIds = true) const;
483  #endif 
484    protected:
485    template <class T> void GroupByFltCol(const TStr& GroupBy, T& Grouping, 
486      const TIntV& IndexSet, TBool All, TBool UsePhysicalIds = true) const;
487    template <class T> void GroupByStrCol(const TStr& GroupBy, T& Grouping, 
488      const TIntV& IndexSet, TBool All, TBool UsePhysicalIds = true) const;
489    template <class T> void UpdateGrouping(THash<T,TIntV>& Grouping, T Key, TInt Val) const;
490  #ifdef GCC_ATOMIC
491    template <class T> void UpdateGrouping(THashMP<T,TIntV>& Grouping, T Key, TInt Val) const;
492  #endif 
493    void PrintGrouping(const THash<TGroupKey, TIntV>& Grouping) const;
494    inline TInt CompareRows(TInt R1, TInt R2, const TAttrType& CompareByType,
495     const TInt& CompareByIndex, TBool Asc = true);
496    inline TInt CompareRows(TInt R1, TInt R2, const TVec<TAttrType>& CompareByTypes,
497     const TIntV& CompareByIndices, TBool Asc = true);
498    TInt GetPivot(TIntV& V, TInt StartIdx, TInt EndIdx, const TVec<TAttrType>& SortByTypes,
499     const TIntV& SortByIndices, TBool Asc);
500    TInt Partition(TIntV& V, TInt StartIdx, TInt EndIdx, const TVec<TAttrType>& SortByTypes,
501     const TIntV& SortByIndices, TBool Asc);
502    void ISort(TIntV& V, TInt StartIdx, TInt EndIdx, const TVec<TAttrType>& SortByTypes,
503     const TIntV& SortByIndices, TBool Asc = true);
504    void QSort(TIntV& V, TInt StartIdx, TInt EndIdx, const TVec<TAttrType>& SortByTypes,
505     const TIntV& SortByIndices, TBool Asc = true);
506    void Merge(TIntV& V, TInt Idx1, TInt Idx2, TInt Idx3, const TVec<TAttrType>& SortByTypes,
507      const TIntV& SortByIndices, TBool Asc = true);
508  #ifdef USE_OPENMP
509    void QSortPar(TIntV& V, const TVec<TAttrType>& SortByTypes, const TIntV& SortByIndices,
510      TBool Asc = true);
511  #endif 
512    bool IsRowValid(TInt RowIdx) const{ return Next[RowIdx] != Invalid;}
513    TInt GetLastValidRowIdx();
514    void RemoveFirstRow();
515    void RemoveRow(TInt RowIdx, TInt PrevRowIdx);
516    void KeepSortedRows(const TIntV& KeepV);
517    void SetFirstValidRow() {
518      for (int i = 0; i < Next.Len(); i++) {
519        if(Next[i] != TTable::Invalid) { FirstValidRow = i; return;}
520      }
521      TExcept::Throw("SetFirstValidRow: Table is empty");
522    }
523    PTable InitializeJointTable(const TTable& Table);
524    void AddJointRow(const TTable& T1, const TTable& T2, TInt RowIdx1, TInt RowIdx2);
525    void ThresholdJoinInputCorrectness(const TStr& KeyCol1, const TStr& JoinCol1, const TTable& Table, 
526      const TStr& KeyCol2, const TStr& JoinCol2);
527    void ThresholdJoinCountCollisions(const TTable& TB, const TTable& TS, 
528      const TIntIntVH& T, TInt JoinColIdxB, TInt KeyColIdxB, TInt KeyColIdxS, 
529      THash<TIntPr,TIntTr>& Counters, TBool ThisIsSmaller, TAttrType JoinColType, TAttrType KeyType);
530    PTable ThresholdJoinOutputTable(const THash<TIntPr,TIntTr>& Counters, TInt Threshold, const TTable& Table);
531    void ThresholdJoinCountPerJoinKeyCollisions(const TTable& TB, const TTable& TS, 
532      const TIntIntVH& T, TInt JoinColIdxB, TInt KeyColIdxB, TInt KeyColIdxS, 
533      THash<TIntTr,TIntTr>& Counters, TBool ThisIsSmaller, TAttrType JoinColType, TAttrType KeyType);
534    PTable ThresholdJoinPerJoinKeyOutputTable(const THash<TIntTr,TIntTr>& Counters, TInt Threshold, const TTable& Table);
535    void ResizeTable(int RowCount);
536    int GetEmptyRowsStart(int NewRows);
537    void AddSelectedRows(const TTable& Table, const TIntV& RowIDs);
538    void AddNRows(int NewRows, const TVec<TIntV>& IntColsP, const TVec<TFltV>& FltColsP,
539     const TVec<TIntV>& StrColMapsP);
540  #ifdef USE_OPENMP
541    void AddNJointRowsMP(const TTable& T1, const TTable& T2, const TVec<TIntPrV>& JointRowIDSet);
542  #endif 
543    void UpdateTableForNewRow();
544  #ifdef GCC_ATOMIC
545    static void LoadSSPar(PTable& NewTable, const Schema& S, const TStr& InFNm, const TIntV& RelevantCols, const char& Separator, TBool HasTitleLine);
546  #endif 
547    static void LoadSSSeq(PTable& NewTable, const Schema& S, const TStr& InFNm, const TIntV& RelevantCols, const char& Separator, TBool HasTitleLine);
548    void GroupAux(const TStrV& GroupBy, THash<TGroupKey, TPair<TInt, TIntV> >& Grouping, 
549     TBool Ordered, const TStr& GroupColName, TBool KeepUnique, TIntV& UniqueVec, TBool UsePhysicalIds = true);
550  #ifdef USE_OPENMP
551  #endif 
552    void StoreGroupCol(const TStr& GroupColName, const TVec<TPair<TInt, TInt> >& GroupAndRowIds);
553    void Reindex();
554    void AddIdColumn(const TStr& IdColName);
555    static TInt CompareKeyVal(const TInt& K1, const TInt& V1, const TInt& K2, const TInt& V2);
556    static TInt CheckSortedKeyVal(TIntV& Key, TIntV& Val, TInt Start, TInt End);
557    static void ISortKeyVal(TIntV& Key, TIntV& Val, TInt Start, TInt End);
558    static TInt GetPivotKeyVal(TIntV& Key, TIntV& Val, TInt Start, TInt End);
559    static TInt PartitionKeyVal(TIntV& Key, TIntV& Val, TInt Start, TInt End);
560    static void QSortKeyVal(TIntV& Key, TIntV& Val, TInt Start, TInt End);
561    void GetCollidingRows(const TTable& T, THashSet<TInt>& Collisions);
562  private:
563    class TLoadVecInit {
564    public:
565      TLoadVecInit() {}
566      template<typename TElem>
567      void operator() (TVec<TElem>* Node, TShMIn& ShMIn) {Node->LoadShM(ShMIn);}
568    };
569  private:
570    void GenerateColTypeMap(THash<TStr,TPair<TInt,TInt> > & ColTypeIntMap);
571    void LoadTableShM(TShMIn& ShMIn, TTableContext* ContextTable);
572  public:
573    TTable();
574    TTable(TTableContext* Context);
575    TTable(const Schema& S, TTableContext* Context);
576    TTable(TSIn& SIn, TTableContext* Context);
577    TTable(const THash<TInt,TInt>& H, const TStr& Col1, const TStr& Col2,
578     TTableContext* Context, const TBool IsStrKeys = false);
579    TTable(const THash<TInt,TFlt>& H, const TStr& Col1, const TStr& Col2,
580     TTableContext* Context, const TBool IsStrKeys = false);
581    TTable(const TTable& Table): Context(Table.Context), Sch(Table.Sch),
582      NumRows(Table.NumRows), NumValidRows(Table.NumValidRows), FirstValidRow(Table.FirstValidRow),
583      LastValidRow(Table.LastValidRow), Next(Table.Next), IntCols(Table.IntCols),
584      FltCols(Table.FltCols), StrColMaps(Table.StrColMaps), ColTypeMap(Table.ColTypeMap),
585      IdColName(Table.IdColName), RowIdMap(Table.RowIdMap), GroupStmtNames(Table.GroupStmtNames),
586      GroupIDMapping(Table.GroupIDMapping), GroupMapping(Table.GroupMapping),
587      SrcCol(Table.SrcCol), DstCol(Table.DstCol),
588      EdgeAttrV(Table.EdgeAttrV), SrcNodeAttrV(Table.SrcNodeAttrV),
589      DstNodeAttrV(Table.DstNodeAttrV), CommonNodeAttrs(Table.CommonNodeAttrs),
590      IsNextDirty(Table.IsNextDirty) {}
591    TTable(const TTable& Table, const TIntV& RowIds);
592    static PTable New() { return new TTable(); }
593    static PTable New(TTableContext* Context) { return new TTable(Context); }
594    static PTable New(const Schema& S, TTableContext* Context) {
595      return new TTable(S, Context);
596    }
597    static PTable New(const THash<TInt,TInt>& H, const TStr& Col1,
598     const TStr& Col2, TTableContext* Context, const TBool IsStrKeys = false) {
599      return new TTable(H, Col1, Col2, Context, IsStrKeys);
600    }
601    static PTable New(const THash<TInt,TFlt>& H, const TStr& Col1,
602     const TStr& Col2, TTableContext* Context, const TBool IsStrKeys = false) {
603      return new TTable(H, Col1, Col2, Context, IsStrKeys);
604    }
605    static PTable New(const PTable Table) { return new TTable(*Table); }
606    static void GetSchema(const TStr& InFNm, Schema& S, const char& Separator = '\t');
607    static PTable LoadSS(const Schema& S, const TStr& InFNm, TTableContext* Context,
608     const char& Separator = '\t', TBool HasTitleLine = false);
609    static PTable LoadSS(const Schema& S, const TStr& InFNm, TTableContext* Context,
610     const TIntV& RelevantCols, const char& Separator = '\t', TBool HasTitleLine = false);
611    void SaveSS(const TStr& OutFNm);
612    void SaveBin(const TStr& OutFNm);
613    static PTable Load(TSIn& SIn, TTableContext* Context){ return new TTable(SIn, Context);}
614    static PTable LoadShM(TShMIn& ShMIn, TTableContext* Context) {
615      TTable* Table = new TTable();
616      Table->LoadTableShM(ShMIn, Context);
617      return PTable(Table);
618    }
619    void Save(TSOut& SOut);
620    void Dump(FILE *OutF=stdout) const;
621    static PTable TableFromHashMap(const THash<TInt,TInt>& H, const TStr& Col1, const TStr& Col2,
622     TTableContext* Context, const TBool IsStrKeys = false) {
623      PTable T = New(H, Col1, Col2, Context, IsStrKeys);
624      T->InitIds();
625      return T;
626    }
627    static PTable TableFromHashMap(const THash<TInt,TFlt>& H, const TStr& Col1, const TStr& Col2,
628     TTableContext* Context, const TBool IsStrKeys = false) {
629      PTable T = New(H, Col1, Col2, Context, IsStrKeys);
630      T->InitIds();
631      return T;
632    }
633    void AddRow(const TTableRow& Row) { AddRowV(Row.GetIntVals(), Row.GetFltVals(), Row.GetStrVals()); };
634    TTableContext* GetContext() {
635      return Context;
636    }
637    TTableContext* ChangeContext(TTableContext* Context);
638    TInt GetColIdx(const TStr& ColName) const {
639      TStr NColName = NormalizeColName(ColName);
640      return ColTypeMap.IsKey(NColName) ? ColTypeMap.GetDat(NColName).Val2 : TInt(-1);
641    }
642    TInt GetIntVal(const TStr& ColName, const TInt& RowIdx) {
643      return IntCols[GetColIdx(ColName)][RowIdx];
644    }
645    TFlt GetFltVal(const TStr& ColName, const TInt& RowIdx) {
646      return FltCols[GetColIdx(ColName)][RowIdx];
647    }
648    TStr GetStrVal(const TStr& ColName, const TInt& RowIdx) const {
649      return GetStrValIdx(GetColIdx(ColName), RowIdx);
650    }
651    TInt GetStrMapById(TInt ColIdx, TInt RowIdx) const {
652      return StrColMaps[ColIdx][RowIdx];
653    }
654    TInt GetStrMapByName(const TStr& ColName, TInt RowIdx) const {
655      return StrColMaps[GetColIdx(ColName)][RowIdx];
656    }
657    TStr GetStrValById(TInt ColIdx, TInt RowIdx) const {
658      return GetStrValIdx(ColIdx, RowIdx);
659    }
660    TStr GetStrValByName(const TStr& ColName, const TInt& RowIdx) const {
661      return GetStrVal(ColName, RowIdx);
662    }
663    TIntV GetIntRowIdxByVal(const TStr& ColName, const TInt& Val) const;
664    TIntV GetStrRowIdxByMap(const TStr& ColName, const TInt& Map) const;
665    TIntV GetFltRowIdxByVal(const TStr& ColName, const TFlt& Val) const;
666    TInt RequestIndexInt(const TStr& ColName);
667    TInt RequestIndexFlt(const TStr& ColName);
668    TInt RequestIndexStrMap(const TStr& ColName);
669    TStr GetStr(const TInt& KeyId) const {
670      return Context->StringVals.GetKey(KeyId);
671    }
672    TInt GetIntValAtRowIdx(const TInt& ColIdx, const TInt& RowIdx) {
673      return IntCols[ColIdx][RowIdx];
674    }
675    TFlt GetFltValAtRowIdx(const TInt& ColIdx, const TInt& RowIdx) {
676      return FltCols[ColIdx][RowIdx];
677    }
678    Schema GetSchema() { return DenormalizeSchema(); }
679    TVec<PNEANet> ToGraphSequence(TStr SplitAttr, TAttrAggr AggrPolicy,
680      TInt WindowSize, TInt JumpSize, TInt StartVal = TInt::Mn, TInt EndVal = TInt::Mx);
681    TVec<PNEANet> ToVarGraphSequence(TStr SplitAttr, TAttrAggr AggrPolicy, TIntPrV SplitIntervals);
682    TVec<PNEANet> ToGraphPerGroup(TStr GroupAttr, TAttrAggr AggrPolicy);
683    PNEANet ToGraphSequenceIterator(TStr SplitAttr, TAttrAggr AggrPolicy,
684      TInt WindowSize, TInt JumpSize, TInt StartVal = TInt::Mn, TInt EndVal = TInt::Mx);
685    PNEANet ToVarGraphSequenceIterator(TStr SplitAttr, TAttrAggr AggrPolicy, TIntPrV SplitIntervals);
686    PNEANet ToGraphPerGroupIterator(TStr GroupAttr, TAttrAggr AggrPolicy);
687    PNEANet NextGraphIterator();
688    TBool IsLastGraphOfSequence();
689  	TStr GetSrcCol() const { return SrcCol; }
690    void SetSrcCol(const TStr& Src) {
691      if (!IsColName(Src)) { TExcept::Throw(Src + ": no such column"); }
692      SrcCol = NormalizeColName(Src);
693    }
694  	TStr GetDstCol() const { return DstCol; }
695    void SetDstCol(const TStr& Dst) {
696      if (!IsColName(Dst)) { TExcept::Throw(Dst + ": no such column"); }
697      DstCol = NormalizeColName(Dst);
698    }
699    void AddEdgeAttr(const TStr& Attr) { AddGraphAttribute(Attr, true, false, false); }
700    void AddEdgeAttr(TStrV& Attrs) { AddGraphAttributeV(Attrs, true, false, false); }
701    void AddSrcNodeAttr(const TStr& Attr) { AddGraphAttribute(Attr, false, true, false); }
702    void AddSrcNodeAttr(TStrV& Attrs) { AddGraphAttributeV(Attrs, false, true, false); }
703    void AddDstNodeAttr(const TStr& Attr) { AddGraphAttribute(Attr, false, false, true); }
704    void AddDstNodeAttr(TStrV& Attrs) { AddGraphAttributeV(Attrs, false, false, true); }
705    void AddNodeAttr(const TStr& Attr) { AddSrcNodeAttr(Attr); AddDstNodeAttr(Attr); }
706    void AddNodeAttr(TStrV& Attrs) { AddSrcNodeAttr(Attrs); AddDstNodeAttr(Attrs); }
707    void SetCommonNodeAttrs(const TStr& SrcAttr, const TStr& DstAttr, const TStr& CommonAttrName){
708      CommonNodeAttrs.Add(TStrTr(NormalizeColName(SrcAttr), NormalizeColName(DstAttr), NormalizeColName(CommonAttrName)));
709    }
710    TStrV GetSrcNodeIntAttrV() const;
711    TStrV GetDstNodeIntAttrV() const;
712    TStrV GetEdgeIntAttrV() const;
713  	TStrV GetSrcNodeFltAttrV() const;
714    TStrV GetDstNodeFltAttrV() const;
715  	TStrV GetEdgeFltAttrV() const;
716  	TStrV GetSrcNodeStrAttrV() const;
717    TStrV GetDstNodeStrAttrV() const;
718  	TStrV GetEdgeStrAttrV() const;
719    static PTable GetNodeTable(const PNEANet& Network, TTableContext* Context);
720    static PTable GetEdgeTable(const PNEANet& Network, TTableContext* Context);
721  #ifdef USE_OPENMP
722    static PTable GetEdgeTablePN(const PNGraphMP& Network, TTableContext* Context);
723  #endif 
724    static PTable GetFltNodePropertyTable(const PNEANet& Network, const TIntFltH& Property,
725     const TStr& NodeAttrName, const TAttrType& NodeAttrType, const TStr& PropertyAttrName,
726     TTableContext* Context);
727  	TAttrType GetColType(const TStr& ColName) const {
728      TStr NColName = NormalizeColName(ColName);
729      return ColTypeMap.GetDat(NColName).Val1;
730    }
731    TInt GetNumRows() const { return NumRows;}
732    TInt GetNumValidRows() const { return NumValidRows;}
733    THash<TInt, TInt> GetRowIdMap() const { return RowIdMap;}
734    TRowIterator BegRI() const { return TRowIterator(FirstValidRow, this);}
735    TRowIterator EndRI() const { return TRowIterator(TTable::Last, this);}
736    TRowIteratorWithRemove BegRIWR(){ return TRowIteratorWithRemove(FirstValidRow, this);}
737    TRowIteratorWithRemove EndRIWR(){ return TRowIteratorWithRemove(TTable::Last, this);}
738    void GetPartitionRanges(TIntPrV& Partitions, TInt NumPartitions) const;
739    void Rename(const TStr& Column, const TStr& NewLabel);
740    void Unique(const TStr& Col);
741  	void Unique(const TStrV& Cols, TBool Ordered = true);
742  	void Select(TPredicate& Predicate, TIntV& SelectedRows, TBool Remove = true);
743    void Select(TPredicate& Predicate) {
744      TIntV SelectedRows;
745      Select(Predicate, SelectedRows, true);
746    }
747    void Classify(TPredicate& Predicate, const TStr& LabelName, const TInt& PositiveLabel = 1,
748     const TInt& NegativeLabel = 0);
749    void SelectAtomic(const TStr& Col1, const TStr& Col2, TPredComp Cmp,
750     TIntV& SelectedRows, TBool Remove = true);
751    void SelectAtomic(const TStr& Col1, const TStr& Col2, TPredComp Cmp) {
752      TIntV SelectedRows;
753      SelectAtomic(Col1, Col2, Cmp, SelectedRows, true);
754    }
755    void ClassifyAtomic(const TStr& Col1, const TStr& Col2, TPredComp Cmp,
756     const TStr& LabelName, const TInt& PositiveLabel = 1, const TInt& NegativeLabel = 0);
757    void SelectAtomicConst(const TStr& Col, const TPrimitive& Val, TPredComp Cmp,
758     TIntV& SelectedRows, PTable& SelectedTable, TBool Remove = true, TBool Table = true);
759    template <class T>
760    void SelectAtomicConst(const TStr& Col, const T& Val, TPredComp Cmp) {
761      TIntV SelectedRows;
762      PTable SelectedTable;
763      SelectAtomicConst(Col, TPrimitive(Val), Cmp, SelectedRows, SelectedTable, true, false);
764    }
765    template <class T>
766    void SelectAtomicConst(const TStr& Col, const T& Val, TPredComp Cmp, PTable& SelectedTable) {
767      TIntV SelectedRows;
768      SelectAtomicConst(Col, TPrimitive(Val), Cmp, SelectedRows, SelectedTable, false, true);
769    }
770    template <class T>
771    void ClassifyAtomicConst(const TStr& Col, const T& Val, TPredComp Cmp,
772     const TStr& LabelName, const TInt& PositiveLabel = 1, const TInt& NegativeLabel = 0) {
773      TIntV SelectedRows;
774      PTable SelectedTable;
775      SelectAtomicConst(Col, TPrimitive(Val), Cmp, SelectedRows, SelectedTable, false, false);
776      ClassifyAux(SelectedRows, LabelName, PositiveLabel, NegativeLabel);
777    }
778    void SelectAtomicIntConst(const TStr& Col, const TInt& Val, TPredComp Cmp) {
779      SelectAtomicConst(Col, Val, Cmp);
780    }
781    void SelectAtomicIntConst(const TStr& Col, const TInt& Val, TPredComp Cmp, PTable& SelectedTable) {
782      SelectAtomicConst(Col, Val, Cmp, SelectedTable);
783    }
784    void SelectAtomicStrConst(const TStr& Col, const TStr& Val, TPredComp Cmp) {
785      SelectAtomicConst(Col, Val, Cmp);
786    }
787    void SelectAtomicStrConst(const TStr& Col, const TStr& Val, TPredComp Cmp, PTable& SelectedTable) {
788      SelectAtomicConst(Col, Val, Cmp, SelectedTable);
789    }
790    void SelectAtomicFltConst(const TStr& Col, const TFlt& Val, TPredComp Cmp) {
791      SelectAtomicConst(Col, Val, Cmp);
792    }
793    void SelectAtomicFltConst(const TStr& Col, const TFlt& Val, TPredComp Cmp, PTable& SelectedTable) {
794      SelectAtomicConst(Col, Val, Cmp, SelectedTable);
795    }
796    void Group(const TStrV& GroupBy, const TStr& GroupColName, TBool Ordered = true, TBool UsePhysicalIds = true);
797    void Count(const TStr& CountColName, const TStr& Col);
798    void Order(const TStrV& OrderBy, TStr OrderColName = "", TBool ResetRankByMSC = false, TBool Asc = true);
799    void Aggregate(const TStrV& GroupByAttrs, TAttrAggr AggOp, const TStr& ValAttr,
800     const TStr& ResAttr, TBool Ordered = true);
801    void AggregateCols(const TStrV& AggrAttrs, TAttrAggr AggOp, const TStr& ResAttr);
802    TVec<PTable> SpliceByGroup(const TStrV& GroupByAttrs, TBool Ordered = true);
803    PTable Join(const TStr& Col1, const TTable& Table, const TStr& Col2);
804    PTable Join(const TStr& Col1, const PTable& Table, const TStr& Col2) {
805      return Join(Col1, *Table, Col2);
806    }
807    PTable ThresholdJoin(const TStr& KeyCol1, const TStr& JoinCol1, const TTable& Table, const TStr& KeyCol2, const TStr& JoinCol2, TInt Threshold, TBool PerJoinKey = false);
808    PTable SelfJoin(const TStr& Col) { return Join(Col, *this, Col); }
809    PTable SelfSimJoin(const TStrV& Cols, const TStr& DistanceColName, const TSimType& SimType, const TFlt& Threshold) { return SimJoin(Cols, *this, Cols, DistanceColName, SimType, Threshold); }
810  	PTable SelfSimJoinPerGroup(const TStr& GroupAttr, const TStr& SimCol, const TStr& DistanceColName, const TSimType& SimType, const TFlt& Threshold);
811  	PTable SelfSimJoinPerGroup(const TStrV& GroupBy, const TStr& SimCol, const TStr& DistanceColName, const TSimType& SimType, const TFlt& Threshold);
812  	PTable SimJoin(const TStrV& Cols1, const TTable& Table, const TStrV& Cols2, const TStr& DistanceColName, const TSimType& SimType, const TFlt& Threshold);
813    void SelectFirstNRows(const TInt& N);
814    void Defrag();
815    void StoreIntCol(const TStr& ColName, const TIntV& ColVals);
816    void StoreFltCol(const TStr& ColName, const TFltV& ColVals);
817    void StoreStrCol(const TStr& ColName, const TStrV& ColVals);
818    void UpdateFltFromTable(const TStr& KeyAttr, const TStr& UpdateAttr, const TTable& Table, 
819    	const TStr& FKeyAttr, const TStr& ReadAttr, TFlt DefaultFltVal = 0.0);
820  #ifdef GCC_ATOMIC
821    void UpdateFltFromTableMP(const TStr& KeyAttr, const TStr& UpdateAttr, const TTable& Table, 
822    	const TStr& FKeyAttr, const TStr& ReadAttr, TFlt DefaultFltVal = 0.0);
823    void SetFltColToConstMP(TInt UpdateColIdx, TFlt DefaultFltVal);
824  #endif 
825    PTable Union(const TTable& Table);
826    PTable Union(const PTable& Table) { return Union(*Table); };
827    PTable UnionAll(const TTable& Table);
828    PTable UnionAll(const PTable& Table) { return UnionAll(*Table); };
829    void UnionAllInPlace(const TTable& Table);
830    void UnionAllInPlace(const PTable& Table) { return UnionAllInPlace(*Table); };
831    PTable Intersection(const TTable& Table);
832    PTable Intersection(const PTable& Table) { return Intersection(*Table); };
833    PTable Minus(TTable& Table);
834    PTable Minus(const PTable& Table) { return Minus(*Table); };
835    PTable Project(const TStrV& ProjectCols);
836    void ProjectInPlace(const TStrV& ProjectCols);
837    void ColGenericOp(const TStr& Attr1, const TStr& Attr2, const TStr& ResAttr, TArithOp op);
838  #ifdef USE_OPENMP
839    void ColGenericOpMP(TInt ArgColIdx1, TInt ArgColIdx2, TAttrType ArgType1, TAttrType ArgType2, TInt ResColIdx, TArithOp op);
840  #endif 
841    void ColAdd(const TStr& Attr1, const TStr& Attr2, const TStr& ResultAttrName="");
842    void ColSub(const TStr& Attr1, const TStr& Attr2, const TStr& ResultAttrName="");
843    void ColMul(const TStr& Attr1, const TStr& Attr2, const TStr& ResultAttrName="");
844    void ColDiv(const TStr& Attr1, const TStr& Attr2, const TStr& ResultAttrName="");
845    void ColMod(const TStr& Attr1, const TStr& Attr2, const TStr& ResultAttrName="");
846    void ColMin(const TStr& Attr1, const TStr& Attr2, const TStr& ResultAttrName="");
847    void ColMax(const TStr& Attr1, const TStr& Attr2, const TStr& ResultAttrName="");
848    void ColGenericOp(const TStr& Attr1, TTable& Table, const TStr& Attr2, const TStr& ResAttr,
849      TArithOp op, TBool AddToFirstTable);
850    void ColAdd(const TStr& Attr1, TTable& Table, const TStr& Attr2, const TStr& ResAttr="",
851      TBool AddToFirstTable=true);
852    void ColSub(const TStr& Attr1, TTable& Table, const TStr& Attr2, const TStr& ResAttr="",
853      TBool AddToFirstTable=true);
854    void ColMul(const TStr& Attr1, TTable& Table, const TStr& Attr2, const TStr& ResAttr="",
855      TBool AddToFirstTable=true);
856    void ColDiv(const TStr& Attr1, TTable& Table, const TStr& Attr2, const TStr& ResAttr="",
857      TBool AddToFirstTable=true);
858    void ColMod(const TStr& Attr1, TTable& Table, const TStr& Attr2, const TStr& ResAttr="",
859      TBool AddToFirstTable=true);
860    void ColGenericOp(const TStr& Attr1, const TFlt& Num, const TStr& ResAttr, TArithOp op, const TBool floatCast);
861  #ifdef USE_OPENMP
862    void ColGenericOpMP(const TInt& ColIdx1, const TInt& ColIdx2, TAttrType ArgType, const TFlt& Num, TArithOp op, TBool ShouldCast);
863  #endif 
864    void ColAdd(const TStr& Attr1, const TFlt& Num, const TStr& ResultAttrName="", const TBool floatCast=false);
865    void ColSub(const TStr& Attr1, const TFlt& Num, const TStr& ResultAttrName="", const TBool floatCast=false);
866    void ColMul(const TStr& Attr1, const TFlt& Num, const TStr& ResultAttrName="", const TBool floatCast=false);
867    void ColDiv(const TStr& Attr1, const TFlt& Num, const TStr& ResultAttrName="", const TBool floatCast=false);
868    void ColMod(const TStr& Attr1, const TFlt& Num, const TStr& ResultAttrName="", const TBool floatCast=false);
869    void ColConcat(const TStr& Attr1, const TStr& Attr2, const TStr& Sep = "", const TStr& ResAttr="");
870    void ColConcat(const TStr& Attr1, TTable& Table, const TStr& Attr2, const TStr& Sep = "", const TStr& ResAttr="",
871      TBool AddToFirstTable=true);
872    void ColConcatConst(const TStr& Attr1, const TStr& Val, const TStr& Sep = "", const TStr& ResAttr="");
873    void ReadIntCol(const TStr& ColName, TIntV& Result) const;
874    void ReadFltCol(const TStr& ColName, TFltV& Result) const;
875    void ReadStrCol(const TStr& ColName, TStrV& Result) const;
876    void InitIds();
877    PTable IsNextK(const TStr& OrderCol, TInt K, const TStr& GroupBy, const TStr& RankColName = "");
878    void PrintSize();
879    void PrintContextSize();
880    TSize GetMemUsedKB();
881    TSize GetContextMemUsedKB();
882    friend class TPt<TTable>;
883    friend class TRowIterator;
884    friend class TRowIteratorWithRemove;
885  };
886  typedef TPair<TStr,TAttrType> TStrTypPr;
887  template<class T>
888  TInt TTable::CheckAndAddFltNode(T Graph, THash<TFlt, TInt>& NodeVals, TFlt FNodeVal) {
889    if (!NodeVals.IsKey(FNodeVal)) {
890      TInt NodeVal = NodeVals.Len();
891      Graph->AddNode(NodeVal);
892      NodeVals.AddKey(FNodeVal);
893      NodeVals.AddDat(FNodeVal, NodeVal);
894      return NodeVal;
895    } else { return NodeVals.GetDat(FNodeVal); }
896  }
897  template <class T>
898  T TTable::AggregateVector(TVec<T>& V, TAttrAggr Policy) {
899    switch (Policy) {
900      case aaMin: {
901        T Res = V[0];
902        for (TInt i = 1; i < V.Len(); i++) {
903          if (V[i] < Res) { Res = V[i]; }
904        }
905        return Res;
906      }
907      case aaMax: {
908        T Res = V[0];
909        for (TInt i = 1; i < V.Len(); i++) {
910          if (V[i] > Res) { Res = V[i]; }
911        }
912        return Res;
913      }
914      case aaFirst: {
915        return V[0];
916      }
917      case aaLast:{
918        return V[V.Len()-1];
919      }
920      case aaSum: {
921        T Res = V[0];
922        for (TInt i = 1; i < V.Len(); i++) {
923          Res = Res + V[i];
924        }
925        return Res;
926      }
927      case aaMean: {
928        T Res = V[0];
929        for (TInt i = 1; i < V.Len(); i++) {
930          Res = Res + V[i];
931        }
932        Res = Res / V.Len();
933        return Res;
934      }
935      case aaMedian: {
936        V.Sort();
937        return V[V.Len()/2];
938      }
939      case aaCount: {
940        return V[0];
941      }
942    }
943    T ShouldNotComeHere;
944    return ShouldNotComeHere;
945  }
946  template <class T>
947  void TTable::GroupByIntCol(const TStr& GroupBy, T& Grouping, 
948   const TIntV& IndexSet, TBool All, TBool UsePhysicalIds) const {
949    TInt IdColIdx = GetColIdx(IdColName);
950    if(!UsePhysicalIds && IdColIdx < 0){
951    	TExcept::Throw("Grouping: Either use physical row ids, or have an id column");
952    }
953    GroupingSanityCheck(GroupBy, atInt);
954    if (All) {
955      for (TRowIterator it = BegRI(); it < EndRI(); it++) {
956        TInt idx = UsePhysicalIds ? it.GetRowIdx() : it.GetIntAttr(IdColIdx);
957        UpdateGrouping<TInt>(Grouping, it.GetIntAttr(GroupBy), idx);
958      }
959    } else {
960      for (TInt i = 0; i < IndexSet.Len(); i++) {
961        if (IsRowValid(IndexSet[i])) {
962          TInt RowIdx = IndexSet[i];
963          const TIntV& Col = IntCols[GetColIdx(GroupBy)];
964          TInt idx = UsePhysicalIds ? RowIdx : IntCols[IdColIdx][RowIdx];       
965          UpdateGrouping<TInt>(Grouping, Col[RowIdx], idx);
966        }
967      }
968    }
969  }
970  template <class T>
971  void TTable::GroupByFltCol(const TStr& GroupBy, T& Grouping, 
972   const TIntV& IndexSet, TBool All, TBool UsePhysicalIds) const {
973    TInt IdColIdx = GetColIdx(IdColName);
974    if(!UsePhysicalIds && IdColIdx < 0){
975    	TExcept::Throw("Grouping: Either use physical row ids, or have an id column");
976    }
977    GroupingSanityCheck(GroupBy, atFlt);
978    if (All) {
979      for (TRowIterator it = BegRI(); it < EndRI(); it++) {
980        TInt idx = UsePhysicalIds ? it.GetRowIdx() : it.GetIntAttr(IdColIdx);
981        UpdateGrouping<TFlt>(Grouping, it.GetFltAttr(GroupBy), idx);
982      }
983    } else {
984      for (TInt i = 0; i < IndexSet.Len(); i++) {
985        if (IsRowValid(IndexSet[i])) {
986          TInt RowIdx = IndexSet[i];
987          const TFltV& Col = FltCols[GetColIdx(GroupBy)];   
988          TInt idx = UsePhysicalIds ? RowIdx : IntCols[IdColIdx][RowIdx];     
989          UpdateGrouping<TFlt>(Grouping, Col[RowIdx], idx);
990        }
991      }
992    }
993  }
994  template <class T>
995  void TTable::GroupByStrCol(const TStr& GroupBy, T& Grouping, 
996   const TIntV& IndexSet, TBool All, TBool UsePhysicalIds) const {
997    TInt IdColIdx = GetColIdx(IdColName);
998    if(!UsePhysicalIds && IdColIdx < 0){
999    	TExcept::Throw("Grouping: Either use physical row ids, or have an id column");
1000    }
1001    GroupingSanityCheck(GroupBy, atStr);
1002    if (All) {
1003      for (TRowIterator it = BegRI(); it < EndRI(); it++) {
1004        TInt idx = UsePhysicalIds ? it.GetRowIdx() : it.GetIntAttr(IdColIdx);
1005        UpdateGrouping<TInt>(Grouping, it.GetStrMapByName(GroupBy), idx);
1006      }
1007    } else {
1008      for (TInt i = 0; i < IndexSet.Len(); i++) {
1009        if (IsRowValid(IndexSet[i])) {
1010          TInt RowIdx = IndexSet[i];
1011          TInt ColIdx = GetColIdx(GroupBy);
1012          TInt idx = UsePhysicalIds ? RowIdx : IntCols[IdColIdx][RowIdx];  
1013          UpdateGrouping<TInt>(Grouping, StrColMaps[ColIdx][RowIdx], idx);
1014        }
1015      }
1016    }
1017  }
1018  template <class T>
1019  void TTable::UpdateGrouping(THash<T,TIntV>& Grouping, T Key, TInt Val) const{
1020    if (Grouping.IsKey(Key)) {
1021      Grouping.GetDat(Key).Add(Val);
1022    } else {
1023      TIntV NewGroup;
1024      NewGroup.Add(Val);
1025      Grouping.AddDat(Key, NewGroup);
1026    }
1027  }
1028  #ifdef GCC_ATOMIC
1029  template <class T>
1030  void TTable::UpdateGrouping(THashMP<T,TIntV>& Grouping, T Key, TInt Val) const{
1031    if (Grouping.IsKey(Key)) {
<span onclick='openModal()' class='match'>1032      Grouping.GetDat(Key).Add(Val);
1033    } else {
1034      TIntV NewGroup;
</span>1035      NewGroup.Add(Val);
1036      Grouping.AddDat(Key, NewGroup);
1037    }
1038  }
1039  #endif 
1040  #endif 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-nlpwinlf.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-table.h</div>
                </div>
                <div class="column column_space"><pre><code>112          WordStrVToAliasH.GetDat(NewWordStrV).IncFq(NewAliasFq);
113        } else {
114          TIntKdV IntrsLen_OldWordStrVNV;
</pre></code></div>
                <div class="column column_space"><pre><code>1032      Grouping.GetDat(Key).Add(Val);
1033    } else {
1034      TIntV NewGroup;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    