
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 15, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-cord.h</h3>
            <pre><code>1  #ifndef ABSL_STRINGS_CORD_H_
2  #define ABSL_STRINGS_CORD_H_
3  #include <algorithm>
4  #include <cstddef>
5  #include <cstdint>
6  #include <cstring>
7  #include <iosfwd>
8  #include <iterator>
9  #include <string>
10  #include <type_traits>
11  #include "absl/base/attributes.h"
12  #include "absl/base/config.h"
13  #include "absl/base/internal/endian.h"
14  #include "absl/base/internal/per_thread_tls.h"
15  #include "absl/base/macros.h"
16  #include "absl/base/port.h"
17  #include "absl/container/inlined_vector.h"
18  #include "absl/crc/internal/crc_cord_state.h"
19  #include "absl/functional/function_ref.h"
20  #include "absl/meta/type_traits.h"
21  #include "absl/strings/cord_analysis.h"
22  #include "absl/strings/cord_buffer.h"
23  #include "absl/strings/internal/cord_data_edge.h"
24  #include "absl/strings/internal/cord_internal.h"
25  #include "absl/strings/internal/cord_rep_btree.h"
26  #include "absl/strings/internal/cord_rep_btree_reader.h"
27  #include "absl/strings/internal/cord_rep_crc.h"
28  #include "absl/strings/internal/cord_rep_ring.h"
29  #include "absl/strings/internal/cordz_functions.h"
30  #include "absl/strings/internal/cordz_info.h"
31  #include "absl/strings/internal/cordz_statistics.h"
32  #include "absl/strings/internal/cordz_update_scope.h"
33  #include "absl/strings/internal/cordz_update_tracker.h"
34  #include "absl/strings/internal/resize_uninitialized.h"
35  #include "absl/strings/internal/string_constant.h"
36  #include "absl/strings/string_view.h"
37  #include "absl/types/optional.h"
38  namespace absl {
39  ABSL_NAMESPACE_BEGIN
40  class Cord;
41  class CordTestPeer;
42  template <typename Releaser>
43  Cord MakeCordFromExternal(absl::string_view, Releaser&&);
44  void CopyCordToString(const Cord& src, std::string* dst);
45  enum class CordMemoryAccounting {
46    kTotal,
47    kFairShare,
48  };
49  class Cord {
50   private:
51    template <typename T>
52    using EnableIfString =
53        absl::enable_if_t<std::is_same<T, std::string>::value, int>;
54   public:
55    constexpr Cord() noexcept;
56    Cord(const Cord& src);
57    Cord(Cord&& src) noexcept;
58    Cord& operator=(const Cord& x);
59    Cord& operator=(Cord&& x) noexcept;
60    explicit Cord(absl::string_view src);
61    Cord& operator=(absl::string_view src);
62    template <typename T, EnableIfString<T> = 0>
63    explicit Cord(T&& src);
64    template <typename T, EnableIfString<T> = 0>
65    Cord& operator=(T&& src);
66    ~Cord() {
67      if (contents_.is_tree()) DestroyCordSlow();
68    }
69    template <typename Releaser>
70    friend Cord MakeCordFromExternal(absl::string_view data, Releaser&& releaser);
71    ABSL_ATTRIBUTE_REINITIALIZES void Clear();
72    void Append(const Cord& src);
73    void Append(Cord&& src);
74    void Append(absl::string_view src);
75    template <typename T, EnableIfString<T> = 0>
76    void Append(T&& src);
77    void Append(CordBuffer buffer);
78    CordBuffer GetAppendBuffer(size_t capacity, size_t min_capacity = 16);
79    CordBuffer GetCustomAppendBuffer(size_t block_size, size_t capacity,
80                                     size_t min_capacity = 16);
81    void Prepend(const Cord& src);
82    void Prepend(absl::string_view src);
83    template <typename T, EnableIfString<T> = 0>
84    void Prepend(T&& src);
85    void Prepend(CordBuffer buffer);
86    void RemovePrefix(size_t n);
87    void RemoveSuffix(size_t n);
88    Cord Subcord(size_t pos, size_t new_size) const;
89    void swap(Cord& other) noexcept;
90    friend void swap(Cord& x, Cord& y) noexcept { x.swap(y); }
91    size_t size() const;
92    bool empty() const;
93    size_t EstimatedMemoryUsage(CordMemoryAccounting accounting_method =
94                                    CordMemoryAccounting::kTotal) const;
95    int Compare(absl::string_view rhs) const;
96    int Compare(const Cord& rhs) const;
97    bool StartsWith(const Cord& rhs) const;
98    bool StartsWith(absl::string_view rhs) const;
99    bool EndsWith(absl::string_view rhs) const;
100    bool EndsWith(const Cord& rhs) const;
101    explicit operator std::string() const;
102    friend void CopyCordToString(const Cord& src, std::string* dst);
103    class CharIterator;
104    class ChunkIterator {
105     public:
106      using iterator_category = std::input_iterator_tag;
107      using value_type = absl::string_view;
108      using difference_type = ptrdiff_t;
109      using pointer = const value_type*;
110      using reference = value_type;
111      ChunkIterator() = default;
112      ChunkIterator& operator++();
113      ChunkIterator operator++(int);
114      bool operator==(const ChunkIterator& other) const;
115      bool operator!=(const ChunkIterator& other) const;
116      reference operator*() const;
117      pointer operator->() const;
118      friend class Cord;
119      friend class CharIterator;
120     private:
121      using CordRep = absl::cord_internal::CordRep;
122      using CordRepBtree = absl::cord_internal::CordRepBtree;
123      using CordRepBtreeReader = absl::cord_internal::CordRepBtreeReader;
124      explicit ChunkIterator(cord_internal::CordRep* tree);
125      explicit ChunkIterator(const Cord* cord);
126      void InitTree(cord_internal::CordRep* tree);
127      void RemoveChunkPrefix(size_t n);
128      Cord AdvanceAndReadBytes(size_t n);
129      void AdvanceBytes(size_t n);
130      ChunkIterator& AdvanceBtree();
131      void AdvanceBytesBtree(size_t n);
132      absl::string_view current_chunk_;
133      absl::cord_internal::CordRep* current_leaf_ = nullptr;
134      size_t bytes_remaining_ = 0;
135      CordRepBtreeReader btree_reader_;
136    };
137    ChunkIterator chunk_begin() const;
138    ChunkIterator chunk_end() const;
139    class ChunkRange {
140     public:
141      using value_type = absl::string_view;
142      using reference = value_type&;
143      using const_reference = const value_type&;
144      using iterator = ChunkIterator;
145      using const_iterator = ChunkIterator;
146      explicit ChunkRange(const Cord* cord) : cord_(cord) {}
147      ChunkIterator begin() const;
148      ChunkIterator end() const;
149     private:
150      const Cord* cord_;
151    };
152    ChunkRange Chunks() const;
153    class CharIterator {
154     public:
155      using iterator_category = std::input_iterator_tag;
156      using value_type = char;
157      using difference_type = ptrdiff_t;
158      using pointer = const char*;
159      using reference = const char&;
160      CharIterator() = default;
161      CharIterator& operator++();
162      CharIterator operator++(int);
163      bool operator==(const CharIterator& other) const;
164      bool operator!=(const CharIterator& other) const;
165      reference operator*() const;
166      pointer operator->() const;
167      friend Cord;
168     private:
169      explicit CharIterator(const Cord* cord) : chunk_iterator_(cord) {}
170      ChunkIterator chunk_iterator_;
171    };
172    static Cord AdvanceAndRead(CharIterator* it, size_t n_bytes);
173    static void Advance(CharIterator* it, size_t n_bytes);
174    static absl::string_view ChunkRemaining(const CharIterator& it);
175    CharIterator char_begin() const;
176    CharIterator char_end() const;
177    class CharRange {
178     public:
179      using value_type = char;
180      using reference = value_type&;
181      using const_reference = const value_type&;
182      using iterator = CharIterator;
183      using const_iterator = CharIterator;
184      explicit CharRange(const Cord* cord) : cord_(cord) {}
185      CharIterator begin() const;
186      CharIterator end() const;
187     private:
188      const Cord* cord_;
189    };
190    CharRange Chars() const;
191    char operator[](size_t i) const;
192    absl::optional<absl::string_view> TryFlat() const;
193    absl::string_view Flatten();
194    friend void AbslFormatFlush(absl::Cord* cord, absl::string_view part) {
195      cord->Append(part);
196    }
197    void SetExpectedChecksum(uint32_t crc);
198    absl::optional<uint32_t> ExpectedChecksum() const;
199    template <typename H>
200    friend H AbslHashValue(H hash_state, const absl::Cord& c) {
201      absl::optional<absl::string_view> maybe_flat = c.TryFlat();
202      if (maybe_flat.has_value()) {
203        return H::combine(std::move(hash_state), *maybe_flat);
204      }
205      return c.HashFragmented(std::move(hash_state));
206    }
207    template <typename T>
208    constexpr Cord(strings_internal::StringConstant<T>);
209   private:
210    using CordRep = absl::cord_internal::CordRep;
211    using CordRepFlat = absl::cord_internal::CordRepFlat;
212    using CordzInfo = cord_internal::CordzInfo;
213    using CordzUpdateScope = cord_internal::CordzUpdateScope;
214    using CordzUpdateTracker = cord_internal::CordzUpdateTracker;
215    using InlineData = cord_internal::InlineData;
216    using MethodIdentifier = CordzUpdateTracker::MethodIdentifier;
217    explicit Cord(absl::string_view src, MethodIdentifier method);
218    friend class CordTestPeer;
219    friend bool operator==(const Cord& lhs, const Cord& rhs);
220    friend bool operator==(const Cord& lhs, absl::string_view rhs);
221    friend const CordzInfo* GetCordzInfoForTesting(const Cord& cord);
222    void ForEachChunk(absl::FunctionRef<void(absl::string_view)>) const;
223    absl::string_view FlattenSlowPath();
224    class InlineRep {
225     public:
226      static constexpr unsigned char kMaxInline = cord_internal::kMaxInline;
227      static_assert(kMaxInline >= sizeof(absl::cord_internal::CordRep*), "");
228      constexpr InlineRep() : data_() {}
229      explicit InlineRep(InlineData::DefaultInitType init) : data_(init) {}
230      InlineRep(const InlineRep& src);
231      InlineRep(InlineRep&& src);
232      InlineRep& operator=(const InlineRep& src);
233      InlineRep& operator=(InlineRep&& src) noexcept;
234      explicit constexpr InlineRep(absl::string_view sv, CordRep* rep);
235      void Swap(InlineRep* rhs);
236      bool empty() const;
237      size_t size() const;
238      const char* data() const;  
239      void set_data(const char* data, size_t n);  
240      char* set_data(size_t n);                   
241      absl::cord_internal::CordRep* tree() const;
242      absl::cord_internal::CordRep* as_tree() const;
243      const char* as_chars() const;
244      absl::cord_internal::CordRep* clear();
245      void reduce_size(size_t n);    
246      void remove_prefix(size_t n);  
247      void AppendArray(absl::string_view src, MethodIdentifier method);
248      absl::string_view FindFlatStartPiece() const;
249      CordRepFlat* MakeFlatWithExtraCapacity(size_t extra);
250      void SetTree(CordRep* rep, const CordzUpdateScope& scope);
251      void SetTreeOrEmpty(CordRep* rep, const CordzUpdateScope& scope);
252      void EmplaceTree(CordRep* rep, MethodIdentifier method);
253      void EmplaceTree(CordRep* rep, const InlineData& parent,
254                       MethodIdentifier method);
255      void CommitTree(const CordRep* old_rep, CordRep* rep,
256                      const CordzUpdateScope& scope, MethodIdentifier method);
257      void AppendTreeToInlined(CordRep* tree, MethodIdentifier method);
258      void AppendTreeToTree(CordRep* tree, MethodIdentifier method);
259      void AppendTree(CordRep* tree, MethodIdentifier method);
260      void PrependTreeToInlined(CordRep* tree, MethodIdentifier method);
261      void PrependTreeToTree(CordRep* tree, MethodIdentifier method);
262      void PrependTree(CordRep* tree, MethodIdentifier method);
263      bool IsSame(const InlineRep& other) const { return data_ == other.data_; }
264      void CopyTo(std::string* dst) const {
265        absl::strings_internal::STLStringResizeUninitialized(dst, kMaxInline);
266        data_.copy_max_inline_to(&(*dst)[0]);
267        dst->erase(inline_size());
268      }
269      void CopyToArray(char* dst) const;
270      bool is_tree() const { return data_.is_tree(); }
271      bool is_profiled() const { return data_.is_tree() && data_.is_profiled(); }
272      size_t remaining_inline_capacity() const {
273        return data_.is_tree() ? 0 : kMaxInline - data_.inline_size();
274      }
275      absl::cord_internal::CordzInfo* cordz_info() const {
276        return data_.cordz_info();
277      }
278      void set_cordz_info(cord_internal::CordzInfo* cordz_info) {
279        assert(cordz_info != nullptr);
280        data_.set_cordz_info(cordz_info);
281      }
282      void clear_cordz_info() { data_.clear_cordz_info(); }
283     private:
284      friend class Cord;
285      void AssignSlow(const InlineRep& src);
286      void UnrefTree();
287      void ResetToEmpty() { data_ = {}; }
288      void set_inline_size(size_t size) { data_.set_inline_size(size); }
289      size_t inline_size() const { return data_.inline_size(); }
290      void MaybeRemoveEmptyCrcNode();
291      cord_internal::InlineData data_;
292    };
293    InlineRep contents_;
294    static bool GetFlatAux(absl::cord_internal::CordRep* rep,
295                           absl::string_view* fragment);
296    static void ForEachChunkAux(
297        absl::cord_internal::CordRep* rep,
298        absl::FunctionRef<void(absl::string_view)> callback);
299    void DestroyCordSlow();
300    void CopyToArraySlowPath(char* dst) const;
301    int CompareSlowPath(absl::string_view rhs, size_t compared_size,
302                        size_t size_to_compare) const;
303    int CompareSlowPath(const Cord& rhs, size_t compared_size,
304                        size_t size_to_compare) const;
305    bool EqualsImpl(absl::string_view rhs, size_t size_to_compare) const;
306    bool EqualsImpl(const Cord& rhs, size_t size_to_compare) const;
307    int CompareImpl(const Cord& rhs) const;
308    template <typename ResultType, typename RHS>
309    friend ResultType GenericCompare(const Cord& lhs, const RHS& rhs,
310                                     size_t size_to_compare);
311    static absl::string_view GetFirstChunk(const Cord& c);
312    static absl::string_view GetFirstChunk(absl::string_view sv);
313    absl::cord_internal::CordRep* TakeRep() const&;
314    absl::cord_internal::CordRep* TakeRep() &&;
315    template <typename C>
316    void AppendImpl(C&& src);
317    void AppendPrecise(absl::string_view src, MethodIdentifier method);
318    void PrependPrecise(absl::string_view src, MethodIdentifier method);
319    CordBuffer GetAppendBufferSlowPath(size_t block_size, size_t capacity,
320                                       size_t min_capacity);
321    void PrependArray(absl::string_view src, MethodIdentifier method);
322    Cord& AssignLargeString(std::string&& src);
323    template <typename H>
324    H HashFragmented(H hash_state) const {
325      typename H::AbslInternalPiecewiseCombiner combiner;
326      ForEachChunk([&combiner, &hash_state](absl::string_view chunk) {
327        hash_state = combiner.add_buffer(std::move(hash_state), chunk.data(),
328                                         chunk.size());
329      });
330      return H::combine(combiner.finalize(std::move(hash_state)), size());
331    }
332    friend class CrcCord;
333    void SetCrcCordState(crc_internal::CrcCordState state);
334    const crc_internal::CrcCordState* MaybeGetCrcCordState() const;
335  };
336  ABSL_NAMESPACE_END
337  }  
338  namespace absl {
339  ABSL_NAMESPACE_BEGIN
340  extern std::ostream& operator<<(std::ostream& out, const Cord& cord);
341  namespace cord_internal {
342  void InitializeCordRepExternal(absl::string_view data, CordRepExternal* rep);
343  template <typename Releaser>
344  CordRep* NewExternalRep(absl::string_view data, Releaser&& releaser) {
345    assert(!data.empty());
346    using ReleaserType = absl::decay_t<Releaser>;
347    CordRepExternal* rep = new CordRepExternalImpl<ReleaserType>(
348        std::forward<Releaser>(releaser), 0);
349    InitializeCordRepExternal(data, rep);
350    return rep;
351  }
352  inline CordRep* NewExternalRep(absl::string_view data,
353                                 void (&releaser)(absl::string_view)) {
354    return NewExternalRep(data, &releaser);
355  }
356  }  
357  template <typename Releaser>
358  Cord MakeCordFromExternal(absl::string_view data, Releaser&& releaser) {
359    Cord cord;
360    if (ABSL_PREDICT_TRUE(!data.empty())) {
361      cord.contents_.EmplaceTree(::absl::cord_internal::NewExternalRep(
362                                     data, std::forward<Releaser>(releaser)),
363                                 Cord::MethodIdentifier::kMakeCordFromExternal);
364    } else {
365      using ReleaserType = absl::decay_t<Releaser>;
366      cord_internal::InvokeReleaser(
367          cord_internal::Rank0{}, ReleaserType(std::forward<Releaser>(releaser)),
368          data);
369    }
370    return cord;
371  }
372  constexpr Cord::InlineRep::InlineRep(absl::string_view sv, CordRep* rep)
373      : data_(sv, rep) {}
374  inline Cord::InlineRep::InlineRep(const Cord::InlineRep& src)
375      : data_(InlineData::kDefaultInit) {
376    if (CordRep* tree = src.tree()) {
377      EmplaceTree(CordRep::Ref(tree), src.data_,
378                  CordzUpdateTracker::kConstructorCord);
379    } else {
380      data_ = src.data_;
381    }
382  }
383  inline Cord::InlineRep::InlineRep(Cord::InlineRep&& src) : data_(src.data_) {
384    src.ResetToEmpty();
385  }
386  inline Cord::InlineRep& Cord::InlineRep::operator=(const Cord::InlineRep& src) {
387    if (this == &src) {
388      return *this;
389    }
390    if (!is_tree() && !src.is_tree()) {
391      data_ = src.data_;
392      return *this;
393    }
394    AssignSlow(src);
395    return *this;
396  }
397  inline Cord::InlineRep& Cord::InlineRep::operator=(
398      Cord::InlineRep&& src) noexcept {
399    if (is_tree()) {
400      UnrefTree();
401    }
402    data_ = src.data_;
403    src.ResetToEmpty();
404    return *this;
405  }
406  inline void Cord::InlineRep::Swap(Cord::InlineRep* rhs) {
407    if (rhs == this) {
408      return;
409    }
410    std::swap(data_, rhs->data_);
411  }
412  inline const char* Cord::InlineRep::data() const {
413    return is_tree() ? nullptr : data_.as_chars();
414  }
415  inline const char* Cord::InlineRep::as_chars() const {
416    assert(!data_.is_tree());
417    return data_.as_chars();
418  }
419  inline absl::cord_internal::CordRep* Cord::InlineRep::as_tree() const {
420    assert(data_.is_tree());
421    return data_.as_tree();
422  }
423  inline absl::cord_internal::CordRep* Cord::InlineRep::tree() const {
424    if (is_tree()) {
425      return as_tree();
426    } else {
427      return nullptr;
428    }
429  }
430  inline bool Cord::InlineRep::empty() const { return data_.is_empty(); }
431  inline size_t Cord::InlineRep::size() const {
432    return is_tree() ? as_tree()->length : inline_size();
433  }
434  inline cord_internal::CordRepFlat* Cord::InlineRep::MakeFlatWithExtraCapacity(
435      size_t extra) {
436    static_assert(cord_internal::kMinFlatLength >= sizeof(data_), "");
437    size_t len = data_.inline_size();
438    auto* result = CordRepFlat::New(len + extra);
439    result->length = len;
440    data_.copy_max_inline_to(result->Data());
441    return result;
442  }
443  inline void Cord::InlineRep::EmplaceTree(CordRep* rep,
444                                           MethodIdentifier method) {
445    assert(rep);
446    data_.make_tree(rep);
447    CordzInfo::MaybeTrackCord(data_, method);
448  }
449  inline void Cord::InlineRep::EmplaceTree(CordRep* rep, const InlineData& parent,
450                                           MethodIdentifier method) {
451    data_.make_tree(rep);
452    CordzInfo::MaybeTrackCord(data_, parent, method);
453  }
454  inline void Cord::InlineRep::SetTree(CordRep* rep,
455                                       const CordzUpdateScope& scope) {
456    assert(rep);
457    assert(data_.is_tree());
458    data_.set_tree(rep);
459    scope.SetCordRep(rep);
460  }
461  inline void Cord::InlineRep::SetTreeOrEmpty(CordRep* rep,
462                                              const CordzUpdateScope& scope) {
463    assert(data_.is_tree());
464    if (rep) {
465      data_.set_tree(rep);
466    } else {
467      data_ = {};
468    }
469    scope.SetCordRep(rep);
470  }
471  inline void Cord::InlineRep::CommitTree(const CordRep* old_rep, CordRep* rep,
472                                          const CordzUpdateScope& scope,
473                                          MethodIdentifier method) {
474    if (old_rep) {
475      SetTree(rep, scope);
476    } else {
477      EmplaceTree(rep, method);
478    }
479  }
480  inline absl::cord_internal::CordRep* Cord::InlineRep::clear() {
481    if (is_tree()) {
482      CordzInfo::MaybeUntrackCord(cordz_info());
483    }
484    absl::cord_internal::CordRep* result = tree();
485    ResetToEmpty();
486    return result;
487  }
488  inline void Cord::InlineRep::CopyToArray(char* dst) const {
489    assert(!is_tree());
490    size_t n = inline_size();
491    assert(n != 0);
<span onclick='openModal()' class='match'>492    cord_internal::SmallMemmove(dst, data_.as_chars(), n);
493  }
</span>494  inline void Cord::InlineRep::MaybeRemoveEmptyCrcNode() {
495    CordRep* rep = tree();
496    if (rep == nullptr || ABSL_PREDICT_TRUE(rep->length > 0)) {
497      return;
498    }
499    assert(rep->IsCrc());
500    assert(rep->crc()->child == nullptr);
501    CordzInfo::MaybeUntrackCord(cordz_info());
502    CordRep::Unref(rep);
503    ResetToEmpty();
504  }
505  constexpr inline Cord::Cord() noexcept {}
506  inline Cord::Cord(absl::string_view src)
507      : Cord(src, CordzUpdateTracker::kConstructorString) {}
508  template <typename T>
509  constexpr Cord::Cord(strings_internal::StringConstant<T>)
510      : contents_(strings_internal::StringConstant<T>::value,
511                  strings_internal::StringConstant<T>::value.size() <=
512                          cord_internal::kMaxInline
513                      ? nullptr
514                      : &cord_internal::ConstInitExternalStorage<
515                            strings_internal::StringConstant<T>>::value) {}
516  inline Cord& Cord::operator=(const Cord& x) {
517    contents_ = x.contents_;
518    return *this;
519  }
520  template <typename T, Cord::EnableIfString<T>>
521  Cord& Cord::operator=(T&& src) {
522    if (src.size() <= cord_internal::kMaxBytesToCopy) {
523      return operator=(absl::string_view(src));
524    } else {
525      return AssignLargeString(std::forward<T>(src));
526    }
527  }
528  inline Cord::Cord(const Cord& src) : contents_(src.contents_) {}
529  inline Cord::Cord(Cord&& src) noexcept : contents_(std::move(src.contents_)) {}
530  inline void Cord::swap(Cord& other) noexcept {
531    contents_.Swap(&other.contents_);
532  }
533  inline Cord& Cord::operator=(Cord&& x) noexcept {
534    contents_ = std::move(x.contents_);
535    return *this;
536  }
537  extern template Cord::Cord(std::string&& src);
538  inline size_t Cord::size() const {
539    return contents_.size();
540  }
541  inline bool Cord::empty() const { return size() == 0; }
542  inline size_t Cord::EstimatedMemoryUsage(
543      CordMemoryAccounting accounting_method) const {
544    size_t result = sizeof(Cord);
545    if (const absl::cord_internal::CordRep* rep = contents_.tree()) {
546      if (accounting_method == CordMemoryAccounting::kFairShare) {
547        result += cord_internal::GetEstimatedFairShareMemoryUsage(rep);
548      } else {
549        result += cord_internal::GetEstimatedMemoryUsage(rep);
550      }
551    }
552    return result;
553  }
554  inline absl::optional<absl::string_view> Cord::TryFlat() const {
555    absl::cord_internal::CordRep* rep = contents_.tree();
556    if (rep == nullptr) {
557      return absl::string_view(contents_.data(), contents_.size());
558    }
559    absl::string_view fragment;
560    if (GetFlatAux(rep, &fragment)) {
561      return fragment;
562    }
563    return absl::nullopt;
564  }
565  inline absl::string_view Cord::Flatten() {
566    absl::cord_internal::CordRep* rep = contents_.tree();
567    if (rep == nullptr) {
568      return absl::string_view(contents_.data(), contents_.size());
569    } else {
570      absl::string_view already_flat_contents;
571      if (GetFlatAux(rep, &already_flat_contents)) {
572        return already_flat_contents;
573      }
574    }
575    return FlattenSlowPath();
576  }
577  inline void Cord::Append(absl::string_view src) {
578    contents_.AppendArray(src, CordzUpdateTracker::kAppendString);
579  }
580  inline void Cord::Prepend(absl::string_view src) {
581    PrependArray(src, CordzUpdateTracker::kPrependString);
582  }
583  inline void Cord::Append(CordBuffer buffer) {
584    if (ABSL_PREDICT_FALSE(buffer.length() == 0)) return;
585    absl::string_view short_value;
586    if (CordRep* rep = buffer.ConsumeValue(short_value)) {
587      contents_.AppendTree(rep, CordzUpdateTracker::kAppendCordBuffer);
588    } else {
589      AppendPrecise(short_value, CordzUpdateTracker::kAppendCordBuffer);
590    }
591  }
592  inline void Cord::Prepend(CordBuffer buffer) {
593    if (ABSL_PREDICT_FALSE(buffer.length() == 0)) return;
594    absl::string_view short_value;
595    if (CordRep* rep = buffer.ConsumeValue(short_value)) {
596      contents_.PrependTree(rep, CordzUpdateTracker::kPrependCordBuffer);
597    } else {
598      PrependPrecise(short_value, CordzUpdateTracker::kPrependCordBuffer);
599    }
600  }
601  inline CordBuffer Cord::GetAppendBuffer(size_t capacity, size_t min_capacity) {
602    if (empty()) return CordBuffer::CreateWithDefaultLimit(capacity);
603    return GetAppendBufferSlowPath(0, capacity, min_capacity);
604  }
605  inline CordBuffer Cord::GetCustomAppendBuffer(size_t block_size,
606                                                size_t capacity,
607                                                size_t min_capacity) {
608    if (empty()) {
609      return block_size ? CordBuffer::CreateWithCustomLimit(block_size, capacity)
610                        : CordBuffer::CreateWithDefaultLimit(capacity);
611    }
612    return GetAppendBufferSlowPath(block_size, capacity, min_capacity);
613  }
614  extern template void Cord::Append(std::string&& src);
615  extern template void Cord::Prepend(std::string&& src);
616  inline int Cord::Compare(const Cord& rhs) const {
617    if (!contents_.is_tree() && !rhs.contents_.is_tree()) {
618      return contents_.data_.Compare(rhs.contents_.data_);
619    }
620    return CompareImpl(rhs);
621  }
622  inline bool Cord::StartsWith(const Cord& rhs) const {
623    if (contents_.IsSame(rhs.contents_)) return true;
624    size_t rhs_size = rhs.size();
625    if (size() < rhs_size) return false;
626    return EqualsImpl(rhs, rhs_size);
627  }
628  inline bool Cord::StartsWith(absl::string_view rhs) const {
629    size_t rhs_size = rhs.size();
630    if (size() < rhs_size) return false;
631    return EqualsImpl(rhs, rhs_size);
632  }
633  inline void Cord::ChunkIterator::InitTree(cord_internal::CordRep* tree) {
634    tree = cord_internal::SkipCrcNode(tree);
635    if (tree->tag == cord_internal::BTREE) {
636      current_chunk_ = btree_reader_.Init(tree->btree());
637    } else {
638      current_leaf_ = tree;
639      current_chunk_ = cord_internal::EdgeData(tree);
640    }
641  }
642  inline Cord::ChunkIterator::ChunkIterator(cord_internal::CordRep* tree) {
643    bytes_remaining_ = tree->length;
644    InitTree(tree);
645  }
646  inline Cord::ChunkIterator::ChunkIterator(const Cord* cord) {
647    if (CordRep* tree = cord->contents_.tree()) {
648      bytes_remaining_ = tree->length;
649      if (ABSL_PREDICT_TRUE(bytes_remaining_ != 0)) {
650        InitTree(tree);
651      } else {
652        current_chunk_ = {};
653      }
654    } else {
655      bytes_remaining_ = cord->contents_.inline_size();
656      current_chunk_ = {cord->contents_.data(), bytes_remaining_};
657    }
658  }
659  inline Cord::ChunkIterator& Cord::ChunkIterator::AdvanceBtree() {
660    current_chunk_ = btree_reader_.Next();
661    return *this;
662  }
663  inline void Cord::ChunkIterator::AdvanceBytesBtree(size_t n) {
664    assert(n >= current_chunk_.size());
665    bytes_remaining_ -= n;
666    if (bytes_remaining_) {
667      if (n == current_chunk_.size()) {
668        current_chunk_ = btree_reader_.Next();
669      } else {
670        size_t offset = btree_reader_.length() - bytes_remaining_;
671        current_chunk_ = btree_reader_.Seek(offset);
672      }
673    } else {
674      current_chunk_ = {};
675    }
676  }
677  inline Cord::ChunkIterator& Cord::ChunkIterator::operator++() {
678    ABSL_HARDENING_ASSERT(bytes_remaining_ > 0 &&
679                          "Attempted to iterate past `end()`");
680    assert(bytes_remaining_ >= current_chunk_.size());
681    bytes_remaining_ -= current_chunk_.size();
682    if (bytes_remaining_ > 0) {
683      if (btree_reader_) {
684        return AdvanceBtree();
685      } else {
686        assert(!current_chunk_.empty());  
687      }
688      current_chunk_ = {};
689    }
690    return *this;
691  }
692  inline Cord::ChunkIterator Cord::ChunkIterator::operator++(int) {
693    ChunkIterator tmp(*this);
694    operator++();
695    return tmp;
696  }
697  inline bool Cord::ChunkIterator::operator==(const ChunkIterator& other) const {
698    return bytes_remaining_ == other.bytes_remaining_;
699  }
700  inline bool Cord::ChunkIterator::operator!=(const ChunkIterator& other) const {
701    return !(*this == other);
702  }
703  inline Cord::ChunkIterator::reference Cord::ChunkIterator::operator*() const {
704    ABSL_HARDENING_ASSERT(bytes_remaining_ != 0);
705    return current_chunk_;
706  }
707  inline Cord::ChunkIterator::pointer Cord::ChunkIterator::operator->() const {
708    ABSL_HARDENING_ASSERT(bytes_remaining_ != 0);
709    return &current_chunk_;
710  }
711  inline void Cord::ChunkIterator::RemoveChunkPrefix(size_t n) {
712    assert(n < current_chunk_.size());
713    current_chunk_.remove_prefix(n);
714    bytes_remaining_ -= n;
715  }
716  inline void Cord::ChunkIterator::AdvanceBytes(size_t n) {
717    assert(bytes_remaining_ >= n);
718    if (ABSL_PREDICT_TRUE(n < current_chunk_.size())) {
719      RemoveChunkPrefix(n);
720    } else if (n != 0) {
721      if (btree_reader_) {
722        AdvanceBytesBtree(n);
723      } else {
724        bytes_remaining_ = 0;
725      }
726    }
727  }
728  inline Cord::ChunkIterator Cord::chunk_begin() const {
729    return ChunkIterator(this);
730  }
731  inline Cord::ChunkIterator Cord::chunk_end() const { return ChunkIterator(); }
732  inline Cord::ChunkIterator Cord::ChunkRange::begin() const {
733    return cord_->chunk_begin();
734  }
735  inline Cord::ChunkIterator Cord::ChunkRange::end() const {
736    return cord_->chunk_end();
737  }
738  inline Cord::ChunkRange Cord::Chunks() const { return ChunkRange(this); }
739  inline Cord::CharIterator& Cord::CharIterator::operator++() {
740    if (ABSL_PREDICT_TRUE(chunk_iterator_->size() > 1)) {
741      chunk_iterator_.RemoveChunkPrefix(1);
742    } else {
743      ++chunk_iterator_;
744    }
745    return *this;
746  }
747  inline Cord::CharIterator Cord::CharIterator::operator++(int) {
748    CharIterator tmp(*this);
749    operator++();
750    return tmp;
751  }
752  inline bool Cord::CharIterator::operator==(const CharIterator& other) const {
753    return chunk_iterator_ == other.chunk_iterator_;
754  }
755  inline bool Cord::CharIterator::operator!=(const CharIterator& other) const {
756    return !(*this == other);
757  }
758  inline Cord::CharIterator::reference Cord::CharIterator::operator*() const {
759    return *chunk_iterator_->data();
760  }
761  inline Cord::CharIterator::pointer Cord::CharIterator::operator->() const {
762    return chunk_iterator_->data();
763  }
764  inline Cord Cord::AdvanceAndRead(CharIterator* it, size_t n_bytes) {
765    assert(it != nullptr);
766    return it->chunk_iterator_.AdvanceAndReadBytes(n_bytes);
767  }
768  inline void Cord::Advance(CharIterator* it, size_t n_bytes) {
769    assert(it != nullptr);
770    it->chunk_iterator_.AdvanceBytes(n_bytes);
771  }
772  inline absl::string_view Cord::ChunkRemaining(const CharIterator& it) {
773    return *it.chunk_iterator_;
774  }
775  inline Cord::CharIterator Cord::char_begin() const {
776    return CharIterator(this);
777  }
778  inline Cord::CharIterator Cord::char_end() const { return CharIterator(); }
779  inline Cord::CharIterator Cord::CharRange::begin() const {
780    return cord_->char_begin();
781  }
782  inline Cord::CharIterator Cord::CharRange::end() const {
783    return cord_->char_end();
784  }
785  inline Cord::CharRange Cord::Chars() const { return CharRange(this); }
786  inline void Cord::ForEachChunk(
787      absl::FunctionRef<void(absl::string_view)> callback) const {
788    absl::cord_internal::CordRep* rep = contents_.tree();
789    if (rep == nullptr) {
790      callback(absl::string_view(contents_.data(), contents_.size()));
791    } else {
792      ForEachChunkAux(rep, callback);
793    }
794  }
795  inline bool operator==(const Cord& lhs, const Cord& rhs) {
796    if (lhs.contents_.IsSame(rhs.contents_)) return true;
797    size_t rhs_size = rhs.size();
798    if (lhs.size() != rhs_size) return false;
799    return lhs.EqualsImpl(rhs, rhs_size);
800  }
801  inline bool operator!=(const Cord& x, const Cord& y) { return !(x == y); }
802  inline bool operator<(const Cord& x, const Cord& y) { return x.Compare(y) < 0; }
803  inline bool operator>(const Cord& x, const Cord& y) { return x.Compare(y) > 0; }
804  inline bool operator<=(const Cord& x, const Cord& y) {
805    return x.Compare(y) <= 0;
806  }
807  inline bool operator>=(const Cord& x, const Cord& y) {
808    return x.Compare(y) >= 0;
809  }
810  inline bool operator==(const Cord& lhs, absl::string_view rhs) {
811    size_t lhs_size = lhs.size();
812    size_t rhs_size = rhs.size();
813    if (lhs_size != rhs_size) return false;
814    return lhs.EqualsImpl(rhs, rhs_size);
815  }
816  inline bool operator==(absl::string_view x, const Cord& y) { return y == x; }
817  inline bool operator!=(const Cord& x, absl::string_view y) { return !(x == y); }
818  inline bool operator!=(absl::string_view x, const Cord& y) { return !(x == y); }
819  inline bool operator<(const Cord& x, absl::string_view y) {
820    return x.Compare(y) < 0;
821  }
822  inline bool operator<(absl::string_view x, const Cord& y) {
823    return y.Compare(x) > 0;
824  }
825  inline bool operator>(const Cord& x, absl::string_view y) { return y < x; }
826  inline bool operator>(absl::string_view x, const Cord& y) { return y < x; }
827  inline bool operator<=(const Cord& x, absl::string_view y) { return !(y < x); }
828  inline bool operator<=(absl::string_view x, const Cord& y) { return !(y < x); }
829  inline bool operator>=(const Cord& x, absl::string_view y) { return !(x < y); }
830  inline bool operator>=(absl::string_view x, const Cord& y) { return !(x < y); }
831  namespace strings_internal {
832  class CordTestAccess {
833   public:
834    static size_t FlatOverhead();
835    static size_t MaxFlatLength();
836    static size_t SizeofCordRepExternal();
837    static size_t SizeofCordRepSubstring();
838    static size_t FlatTagToLength(uint8_t tag);
839    static uint8_t LengthToTag(size_t s);
840  };
841  }  
842  ABSL_NAMESPACE_END
843  }  
844  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-memes.cpp</h3>
            <pre><code>1  #include "stdafx.h"
2  #include "memes.h"
3  int TQuote::GetFq() const {
4    int fq=0;
5    for(int i=0; i<TmUrlCntV.Len(); i++) {
6      fq+=TmUrlCntV[i].Cnt(); }
7    return fq;
8  }
9  int TQuote::GetFq(const TSecTm& BegTm, const TSecTm& EndTm) const {
10    int fq=0;
11    for(int i=0; i<TmUrlCntV.Len(); i++) {
12      if (TmUrlCntV[i].Tm() >= BegTm && TmUrlCntV[i].Tm() < EndTm) {
13        fq += TmUrlCntV[i].Cnt(); } 
14    }
15    return fq;
16  }
17  int TQuote::GetDoms(const TQuoteBs& QtBs) const {
18    THashSet<TChA> DomSet;
19    for (int u = 0; u < TmUrlCntV.Len(); u++) {
20      DomSet.AddKey(TStrUtil::GetDomNm(QtBs.GetStr(TmUrlCntV[u].UrlId())));
21    }
22    return DomSet.Len();
23  }
24  int TQuote::GetFq(const TUrlTy& UrlTy, const TQuoteBs& QtBs) const {
25    int fq=0;
26    for(int i=0; i<TmUrlCntV.Len(); i++) {
27      if (UrlTy==utUndef || QtBs.GetUrlTy(TmUrlCntV[i].UrlId())==UrlTy) {
28        fq += TmUrlCntV[i].Cnt(); } 
29    }
30    return fq;
31  }
32  int TQuote::GetFq(const TSecTm& BegTm, const TSecTm& EndTm, const TUrlTy& UrlTy, const TQuoteBs& QtBs) const {
33    int fq=0;
34    for(int i=0; i<TmUrlCntV.Len(); i++) {
35      if (TmUrlCntV[i].Tm() >= BegTm && TmUrlCntV[i].Tm() <= EndTm &&
36       (UrlTy==utUndef || QtBs.GetUrlTy(TmUrlCntV[i].UrlId())==UrlTy)) {
37        fq+=1; }
38    }
39    return fq;
40  }
41  int TQuote::GetUrls(const TSecTm& BegTm, const TSecTm& EndTm, const TUrlTy& UrlTy, const TQuoteBs& QtBs) const {
42    int urls=0;
43    for(int i=0; i<TmUrlCntV.Len(); i++) {
44      if (TmUrlCntV[i].Tm() >= BegTm && TmUrlCntV[i].Tm() < EndTm &&
45       (UrlTy==utUndef || QtBs.GetUrlTy(TmUrlCntV[i].UrlId())==UrlTy)) {
46        urls+=1; }
47    }
48    return urls;
49  }
50  TSecTm TQuote::GetPeakTm(const TTmUnit& TmUnit, const TSecTm& AfterTm) const {
51    TInt FreqAtPeak;
52    return GetPeakTm(TmUnit, AfterTm, FreqAtPeak);
53  }
54  TSecTm TQuote::GetPeakTm(const TTmUnit& TmUnit, const TSecTm& AfterTm, TInt& FreqAtPeak) const {
55    const TSecTm After = AfterTm.Round(TmUnit);
56    THash<TSecTm, TInt> TmFqH;
57    for(int i=0; i<TmUrlCntV.Len(); i++) {
58      if (TmUrlCntV[i].Tm().Round(TmUnit) >= After) {
59        TmFqH.AddDat(TmUrlCntV[i].Tm().Round(TmUnit)) += TmUrlCntV[i].Cnt(); }
60    }
61    if (TmFqH.Empty()) {
62      FreqAtPeak = 0;
63      return GetPeakTm(TmUnit, TSecTm(1));
64    }
65    TmFqH.SortByDat(false);
66    FreqAtPeak = TmFqH[0];
67    return TmFqH.GetKey(0);
68  }
69  TSecTm TQuote::GetPeakTm(const TTmUnit& TmUnit, const TSecTm& AfterTm, const TUrlTy& UrlTy, const TQuoteBs& QtBs) const {
70    const TSecTm After = AfterTm.Round(TmUnit);
71    THash<TSecTm, TInt> TmFqH;
72    for(int i=0; i<TmUrlCntV.Len(); i++) {
73      if (TmUrlCntV[i].Tm().Round(TmUnit) >= After && (UrlTy==utUndef || QtBs.GetUrlTy(TmUrlCntV[i].UrlId())==UrlTy)) {
74        TmFqH.AddDat(TmUrlCntV[i].Tm().Round(TmUnit)) += TmUrlCntV[i].Cnt(); } 
75    }
76    if (TmFqH.Empty()) {
77      return GetPeakTm(TmUnit, TSecTm(1)); }
78    TmFqH.SortByDat(false);
79    return TmFqH.GetKey(0);
80  }
81  TSecTm TQuote::GetMeanTm(const TTmUnit& TmUnit, const TUrlTy& UrlTy, const TQuoteBs& QtBs, const TSecTm& AfterTm) const {
82    const TSecTm After = AfterTm.Round(TmUnit);
83    double MeanTm = 0;
84    int Cnt = 0;
85    for(int i=0; i<TmUrlCntV.Len(); i++) {
86      if (TmUrlCntV[i].Tm().Round(TmUnit) >= After && (UrlTy==utUndef || QtBs.GetUrlTy(TmUrlCntV[i].UrlId())==UrlTy)) {
87        MeanTm += TmUrlCntV[i].Tm().Round(TmUnit) * TmUrlCntV[i].Cnt();
88        Cnt += TmUrlCntV[i].Cnt();
89      }
90    }
91    return TSecTm(uint(MeanTm/double(Cnt))).Round(TmUnit);
92  }
93  TSecTm TQuote::GetMedianTm(const TTmUnit& TmUnit, const TUrlTy& UrlTy, const TQuoteBs& QtBs, const TSecTm& AfterTm) const {
94    const TSecTm After = AfterTm.Round(TmUnit);
95    TMom Mom;
96    for(int i=0; i<TmUrlCntV.Len(); i++) {
97      if (TmUrlCntV[i].Tm().Round(TmUnit) >= After && (UrlTy==utUndef || QtBs.GetUrlTy(TmUrlCntV[i].UrlId())==UrlTy)) {
98        Mom.Add(TmUrlCntV[i].Tm().Round(TmUnit).GetAbsSecs(), TmUrlCntV[i].Cnt());
99      }
100    }
101    Mom.Def();
102    return TSecTm(uint(Mom.GetMedian())).Round(TmUnit);
103  }
104  bool TQuote::IsSinglePeak(const TTmUnit& TmUnit, const TSecTm& AfterTm, const TUrlTy& UrlTy, const TQuoteBs& QtBs) const {
105    const double PeakThresh = 0.4;
106    TTmFltPrV FqOtV, SmoothV;
107    GetFqOt(FqOtV, TmUnit, UrlTy, QtBs);
108    TQuote::GetSmoothFqOt(SmoothV, FqOtV, TmUnit, 48, 1.2, AfterTm); 
109    SmoothV.Swap(FqOtV);
110    double MaxVal=0;
111    int maxI=0, maxL=0, maxR=0;
112    for (int i = 0; i < FqOtV.Len(); i++) {
113      if (MaxVal < FqOtV[i].Val2) {
114        MaxVal = FqOtV[i].Val2;  maxI=i; }
115    }
116    MaxVal *= PeakThresh;
117    for (maxL = maxI; maxL>0 && FqOtV[maxL].Val2 > MaxVal; maxL--) { }
118    for (maxR = maxI; maxR<FqOtV.Len() && FqOtV[maxR].Val2 > MaxVal; maxR++) { }
119    if (maxR-maxL > 100) { return false; }
120    for (int i = maxR; i < FqOtV.Len(); i++) {
121      if (FqOtV[i].Val2 > MaxVal) { return false; }
122    }
123    for (int i = maxL; i >= 0; i--) {
124      if (FqOtV[i].Val2 > MaxVal) { return false; }
125    }
126    return true;
127  }
128  void TQuote::GetFqOt(TTmFltPrV& RawFqOtV, const TTmUnit& TmUnit) const {
129    THash<TSecTm, TFlt> TmCntH;
130    for (int i = 0; i < TmUrlCntV.Len(); i++) {
131      TmCntH.AddDat(TmUrlCntV[i].Tm().Round(TmUnit)) += TmUrlCntV[i].Cnt();
132    }
133    TmCntH.SortByKey();
134    TmCntH.GetKeyDatPrV(RawFqOtV);
135  }
136  void TQuote::GetFqOt(TTmFltPrV& RawFqOtV, const TTmUnit& TmUnit, const TUrlTy& UrlTy, const TQuoteBs& QtBs) const {
137    THash<TSecTm, TFlt> TmCntH;
138    for (int i = 0; i < TmUrlCntV.Len(); i++) {
139      if (UrlTy==utUndef || QtBs.GetUrlTy(TmUrlCntV[i].UrlId())==UrlTy) {
140        TmCntH.AddDat(TmUrlCntV[i].Tm().Round(TmUnit)) += TmUrlCntV[i].Cnt();
141      }
142    }
143    TmCntH.SortByKey();
144    TmCntH.GetKeyDatPrV(RawFqOtV);
145  }
146  void TQuote::GetFqOt(TTmFltPrV& RawFqOtV, const TTmUnit& TmUnit, const TSecTm& BegTm, const TSecTm& EndTm) const {
147    const TSecTm RBegTm = BegTm.Round(TmUnit);
148    const TSecTm REndTm = EndTm.Round(TmUnit);
149    THash<TSecTm, TFlt> TmCntH;
150    for (int i = 0; i < TmUrlCntV.Len(); i++) {
151      const TSecTm Tm = TmUrlCntV[i].Tm().Round(TmUnit);
152      if (Tm >= RBegTm && Tm <= REndTm) {
153        TmCntH.AddDat(Tm) += TmUrlCntV[i].Cnt();
154      }
155    }
156    TmCntH.SortByKey();
157    TmCntH.GetKeyDatPrV(RawFqOtV);
158  }
159  void TQuote::GetFqOt(TTmFltPrV& RawFqOtV, const TTmUnit& TmUnit, const TSecTm& BegTm, const TSecTm& EndTm, const TUrlTy& UrlTy, const TQuoteBs& QtBs) const {
160    const TSecTm RBegTm = BegTm.Round(TmUnit);
161    const TSecTm REndTm = EndTm.Round(TmUnit);
162    THash<TSecTm, TFlt> TmCntH;
163    for (int i = 0; i < TmUrlCntV.Len(); i++) {
164      const TSecTm Tm = TmUrlCntV[i].Tm().Round(TmUnit);
165      if (Tm >= RBegTm && Tm <= REndTm && (UrlTy==utUndef || QtBs.GetUrlTy(TmUrlCntV[i].UrlId())==UrlTy)) {
166        TmCntH.AddDat(Tm) += TmUrlCntV[i].Cnt();
167      }
168    }
169    TmCntH.SortByKey();
170    TmCntH.GetKeyDatPrV(RawFqOtV);
171  }
172  void TQuote::GetSmoothFqOt(TTmFltPrV& FqOtV, const TTmUnit& TmUnit, const int& WndSz, const double& Smooth, const TSecTm& BegTm, const TSecTm& EndTm) const {
173    TTmFltPrV RawFqOtV;
174    GetFqOt(RawFqOtV, TmUnit, BegTm, EndTm);
175    GetSmoothFqOt(FqOtV, RawFqOtV, TmUnit, WndSz, Smooth, BegTm, EndTm);
176  }
177  void TQuote::GetSmoothFqOt(TTmFltPrV& SmoothFqOtV, const TTmFltPrV& RawFqOtV, const TTmUnit& TmUnit, const int& WndSz, const double& Smooth, const TSecTm& BegTm, const TSecTm& EndTm) {
178    const int TmUnitSecs = TTmInfo::GetTmUnitSecs(TmUnit);
179    const int HalfWndSecs = (WndSz/2)*TmUnitSecs;
180    double FullNormConst = 1;
181    for (int j = 1; j <= WndSz/2; j++) {
182      FullNormConst += 2*pow(Smooth, -j); }
183    THash<TSecTm, TFlt> TmCntH;
184    for (int i = 0; i < RawFqOtV.Len(); i++) {
185      const TSecTm Tm = RawFqOtV[i].Val1;
186      double NormConst = FullNormConst;
187      if (Tm < BegTm+HalfWndSecs || Tm+HalfWndSecs > EndTm) {
188        NormConst = 1;
189        for (int j = 1; j <= WndSz/2; j++) {
190          if (Tm >= BegTm+j*TmUnitSecs) { NormConst += pow(Smooth, -j);  }
191          if (Tm+j*TmUnitSecs <= EndTm) { NormConst += pow(Smooth, -j);  }
192      } }
193      const double NormFq = RawFqOtV[i].Val2 / NormConst;
194      for (int j = 1; j <= WndSz/2; j++) {
195        const int Off = j*TmUnitSecs;
196        if (Tm+Off <= EndTm) {
197          TmCntH.AddDat(TSecTm(Tm+Off).Round(TmUnit)) += NormFq * pow(Smooth, -j); }
198        if (Tm >= BegTm + Off) {
199          TmCntH.AddDat(TSecTm(Tm-Off).Round(TmUnit)) += NormFq * pow(Smooth, -j); }
200      }
201      TmCntH.AddDat(Tm.Round(TmUnit)) += NormFq;
202    }
203    TmCntH.SortByKey();
204    TmCntH.GetKeyDatPrV(SmoothFqOtV);
205  }
206  TStr TQuote::GetDesc() const {
207    return TStr::Fmt("#:%d U:%d  %s", GetFq(), GetUrls(), QtStr.CStr());
208  }
209  void TQuote::PlotOverTm(const TStr& OutFNm) {
210    TFltFltH HrCntH;
211    TmUrlCntV.Sort();
212    if (TmUrlCntV.Empty()) { return; }
213    for (int i = 0; i < TmUrlCntV.Len(); i++) {
214      double Hr = TSecTm(TmUrlCntV[i].Tm()-TmUrlCntV[0].Tm()).Round(tmu6Hour)/(24*3600.0);
215      HrCntH.AddDat(Hr) += TmUrlCntV[i].Cnt();
216    }
217    HrCntH.SortByKey();
218    TGnuPlot::PlotValCntH(HrCntH, OutFNm, TStr::Fmt("%d occurences, %d urls: %s", GetFq(), GetUrls(), QtStr.CStr()),
219      TStr::Fmt("Time [days] from %s", TmUrlCntV[0].Tm().GetYmdTmStr().CStr()), "Frequency");
220  }
221  void TQuote::LoadQtV(const TStr& InFNm, TVec<TQuote>& QtV) {
222    PSIn SIn = TZipIn::IsZipFNm(InFNm) ? TZipIn::New(InFNm) : TFIn::New(InFNm);
223    QtV.Clr(false);
224    while (! SIn->Eof()) {
225      QtV.Add();
226      QtV.Last().Load(*SIn);
227    }
228  }
229  TQuoteBs::TQuoteBs(TSIn& SIn) : StrQtIdH(SIn), QuoteH(SIn), UrlInDegH(SIn), UrlTyH(SIn) {
230    if (! SIn.Eof()) { ClustQtIdVH.Load(SIn); }
231    TIntSet CIdSet;
232    for (int q = 0; q < ClustQtIdVH.Len(); q++) {
233      CIdSet.AddKey(ClustQtIdVH.GetKey(q));
234      for (int c = 0; c < ClustQtIdVH[q].Len(); c++) {
235        CIdSet.AddKey(ClustQtIdVH[q][c]); } 
236      CIdSet.GetKeyV(ClustQtIdVH[q]);
237      ClustQtIdVH[q].Sort();
238      CIdSet.Clr(false);
239    }
240    Dump();
241  }
242  void TQuoteBs::Save(TSOut& SOut) const {
243    StrQtIdH.Save(SOut);
244    QuoteH.Save(SOut);
245    UrlInDegH.Save(SOut);
246    UrlTyH.Save(SOut);
247    ClustQtIdVH.Save(SOut);
248  }
249  PQuoteBs TQuoteBs::New() {
250    return PQuoteBs(new TQuoteBs());
251  }
252  PQuoteBs TQuoteBs::Load(TSIn& SIn) {
253    printf("loading %s...", SIn.GetSNm().CStr());
254    return PQuoteBs(new TQuoteBs(SIn));
255  }
256  void TQuoteBs::GetQtIdV(TIntV& QtIdV) const {
257    QtIdV.Clr();
258    for (int q = 0; q < QuoteH.Len(); q++) {
259      QtIdV.Add(QuoteH.GetKey(q)); }
260  }
261  TUrlTy TQuoteBs::GetUrlTy(const int& UrlId) const {
262    if (UrlTyH.IsKey(UrlId)) {
263      return (TUrlTy) UrlTyH.GetDat(UrlId).Val; } 
264    return utBlog; 
265  }
266  void TQuoteBs::SetUrlTy(const TStr& InFNm, const TUrlTy& SetTy) {
267    printf("Set url type\n");
268    TStrHash<TIntV> DomUrlV; 
269    for (int q = 0; q < Len(); q++) {
270      const TQuote::TTmUrlCntV& V = GetQtN(q).TmUrlCntV;
271      for (int u = 0; u < V.Len(); u++) {
272        const TChA Url = GetStr(V[u].UrlId());
273        DomUrlV.AddDat(TStrUtil::GetDomNm(Url).CStr()).Add(V[u].UrlId());
274      }
275    }
276    printf("  %d domains\n", DomUrlV.Len());
277    TStrV TyUrlV; TStr Ln;
278    if (! TFile::Exists(InFNm)) {
279      printf("!!! %s does not exist\n", InFNm.CStr());
280      return;
281    }
282    for (TFIn FIn(InFNm); FIn.GetNextLn(Ln); ) { TyUrlV.Add(Ln.GetTrunc()); }
283    printf("  %d domains with type label loaded\n", TyUrlV.Len());
284    int NDomSet=0, NUrlSet=0;
285    TExeTm ExeTm;
286    for (int d = 0; d < DomUrlV.Len(); d++) {
287      for (int u = 0; u < TyUrlV.Len(); u++) {
288        if (strstr(DomUrlV.GetKey(d), TyUrlV[u].CStr()) != NULL) {
289          const TIntV& urlV = DomUrlV[d];
290          for (int i = 0; i < urlV.Len(); i++) {
291            UrlTyH.AddDat(urlV[i], SetTy); }
292          NDomSet++;  NUrlSet+=urlV.Len();
293          break;
294        }
295      }
296      if (d % 1000 == 0) { printf("  %d/%d: labeled %d doms, %d urls [%s]\n", d, DomUrlV.Len(), NDomSet, NUrlSet, ExeTm.GetStr()); }
297    }
298    printf("  labeled %d doms, %d urls [%s]\n", NDomSet, NUrlSet, ExeTm.GetStr());
299    printf("  %d total labeled urls\n", UrlTyH.Len());
300  }
301  bool AppearsAt(const TIntSet& UrlSet, const TQuote& Q) {
302    for (int u = 0; u < Q.GetUrls(); u++) {
303      if (UrlSet.IsKey(Q.GetUrlId(u))) { return true; }
304    }
305    return false;
306  }
307  void TQuoteBs::GetQtIdVByFq(TIntV& QtIdV, const int& MinWrdLen, const int& MinQtFq, const bool& OnlyClustRoots, const TStr& HasWord, const TStr& AppearsAtUrl, const TUrlTy& OnlyCountTy, const TSecTm& BegTm, const TSecTm& EndTm) const {
308    printf("Get top quotes from %d quotes\n", QuoteH.Len());
309    printf("  %s -- %s\n", BegTm.GetYmdTmStr().CStr(), EndTm.GetYmdTmStr().CStr());
310    TIntPrV FqQtIdV;
311    int words=0, minFq=0, hasWord=0;
312    TIntSet CSet, QSet;
313    TIntSet UrlSet;
314    if (! AppearsAtUrl.Empty()) {
315      for (int q = 0; q < QuoteH.Len(); q++) {
316        const TQuote& Q = GetQtN(q);
317        TQuote::TTmUrlCntV TmUrlCntV(Q.GetUrls(), 0);
318        for (int u = 0; u < Q.GetUrls(); u++) {
319          if (UrlSet.IsKey(Q.GetUrlId(u))) {
320            TmUrlCntV.Add(Q.TmUrlCntV[u]);
321            continue; }
322          if (strstr(GetStr(Q.GetUrlId(u)), AppearsAtUrl.CStr())!=NULL) {
323            TmUrlCntV.Add(Q.TmUrlCntV[u]);
324            UrlSet.AddKey(Q.GetUrlId(u)); } 
325        }
326        TQuote* QPt = (TQuote*) &(QuoteH[q]);
327        QPt->TmUrlCntV = TmUrlCntV; 
328      }
329    }
330    printf("done.");
331    for (int q = 0; q < QuoteH.Len(); q++) {
332      const TQuote& Qt = GetQtN(q);
333      if (TStrUtil::CountWords(Qt.QtStr.CStr()) < MinWrdLen) { words++;  continue; }
334      if ((! HasWord.Empty()) && Qt.QtStr.SearchStr(HasWord)==-1) { hasWord++;  continue; }
335      int Fq = 0;
336      if (OnlyClustRoots && Qt.GetTy() == qtRoot) {
337        IAssert(Qt.GetCId() == GetQtId(q));
338        IAssert(! CSet.IsKey(Qt.GetCId()));  CSet.AddKey(Qt.GetCId());
339        if ((! HasWord.Empty()) && GetQt(GetCentrQtId(Qt.GetCId())).GetStr().SearchStr(HasWord)==-1) { hasWord++; continue; } 
340        TQuote CentrQt;  GetMergedClustQt(Qt.GetCId(), CentrQt, true); 
341        if (! UrlSet.Empty() && ! AppearsAt(UrlSet, CentrQt)) { continue; }
342        Fq = CentrQt.GetFq(BegTm, EndTm, OnlyCountTy, *this);
343        if (Fq < MinQtFq) { minFq++; continue; }
344        const int Doms = CentrQt.GetDoms(*this);
345        if (Doms < 3 || 5*Doms < CentrQt.GetUrls()) { continue; }
346      }
347      else {
348        if (! UrlSet.Empty() && ! AppearsAt(UrlSet, Qt)) { continue; }
349        Fq = Qt.GetFq(BegTm, EndTm, OnlyCountTy, *this);
350        if (Fq < MinQtFq) { minFq++; continue; }
351        const int Doms = Qt.GetDoms(*this);
352        if (Doms < 3 || 4*Doms < Qt.GetUrls()) { continue; }
353      }
354      IAssert(! QSet.IsKey(GetQtId(q))); QSet.AddKey(GetQtId(q));
355      FqQtIdV.Add(TIntPr(Fq, GetQtId(q)));
356    }
357    printf("  skip %d : word len < %d\n", words, MinWrdLen);
358    printf("  skip %d : qt fq < %d\n", minFq, MinQtFq);
359    if (! HasWord.Empty()) { printf("  skip %d : not containing '%s'\n", hasWord, HasWord.CStr()); }
360    printf("  remaining %d quotes\n", FqQtIdV.Len());
361    FqQtIdV.Sort(false);
362    QtIdV.Clr(false);
363    TIntSet SeenSet;
364    for (int i = 0; i < FqQtIdV.Len(); i++) {
365      if (i < 100) { printf(" fq:%d", FqQtIdV[i].Val1()); }
366      const int qid = FqQtIdV[i].Val2;
367      if (! SeenSet.IsKey(qid)) {
368        QtIdV.Add(qid);
369        SeenSet.AddKey(qid);
370        if (GetQt(qid).GetTy()==qtRoot || GetQt(qid).GetTy()==qtCentr) {
371          const TIntV& ClustV = GetClust(GetQt(qid).GetCId());
372          for (int c = 0; c < ClustV.Len(); c++) { SeenSet.AddKey(ClustV[c]); }
373        }
374      }
375    }
376    printf("  return %d quotes\n", QtIdV.Len());
377  }
378  int AppearsAtDom(const TQuote& CentrQt, const TIntSet& GoodDom, const TIntH& UrlDomH) {
379    int DomCnt = 0;
380    for (int u = 0; u < CentrQt.GetUrls(); u++) {
381      const int U = CentrQt.GetUrlId(u);
382      IAssert(UrlDomH.IsKey(U));
383      if (GoodDom.IsKey(UrlDomH.GetDat(U))) { 
384        DomCnt++; }
385    }
386    return DomCnt;
387  }
388  void TQuoteBs::GetQtIdVByFq(TIntV& QtIdV, const int& MinWrdLen, const int& MinQtFq, const TStrV& FromDomains,
389                              const bool& OnlyClustRoots, const TStr& HasWord, int MinDoms) const {
390    printf("Get top quotes from %d quotes appearing at %d domains\n", QuoteH.Len(), FromDomains.Len());
391    TIntPrV FqQtIdV;
392    TIntH UrlDomH;
393    TStrSet DomainSet;
394    TIntSet QSet;
395    for (int q = 0; q < QuoteH.Len(); q++) {
396      const TQuote& Q = GetQtN(q);
397      for (int u = 0; u < Q.GetUrls(); u++) {
398        const int U = Q.GetUrlId(u);
399        const int D = DomainSet.AddKey(TStrUtil::GetDomNm2(GetStr(U)));
400        UrlDomH.AddDat(U, D);
401      }
402    }
403    TIntSet GoodDom;
404    for (int d = 0; d < DomainSet.Len(); d++) {
405      for (int f = 0; f < FromDomains.Len(); f++) {
406        if (DomainSet[d].SearchStr(FromDomains[f]) != -1) {
407          GoodDom.AddKey(d); break; }
408      }
409    }
410    printf("%d total domains\n", DomainSet.Len());
411    printf("%d from domains\n", FromDomains.Len());
412    printf("%d good domains\n", GoodDom.Len());
413    printf("done.\n\n");
414    const TSecTm BegTm(1), EndTm(TSecTm::GetCurTm());
415    for (int q = 0; q < QuoteH.Len(); q++) {
416      const TQuote& Qt = GetQtN(q);
417      if (TStrUtil::CountWords(Qt.QtStr.CStr()) < MinWrdLen) { continue; }
418      if ((! HasWord.Empty()) && Qt.QtStr.SearchStr(HasWord)==-1) { continue; }
419      int Fq = 0;
420      if (Qt.GetTy() == qtRoot) {
421        TQuote CentrQt;
422        GetMergedClustQt(Qt.GetCId(), CentrQt, true); 
423        if (AppearsAtDom(CentrQt, GoodDom, UrlDomH) < MinDoms) { continue; }
424        Fq = CentrQt.GetFq(BegTm, EndTm, utUndef, *this);
425        if (Fq < MinQtFq) { continue; }
426        const int Doms = CentrQt.GetDoms(*this);
427        if (Doms < 3 || 5*Doms < CentrQt.GetUrls()) { continue; }
428      }
429      else if (! OnlyClustRoots) {
430        if (AppearsAtDom(Qt, GoodDom, UrlDomH) < MinDoms) { continue; }
431        Fq = Qt.GetFq(BegTm, EndTm, utUndef, *this);
432        if (Fq < MinQtFq) { continue; }
433        const int Doms = Qt.GetDoms(*this);
434        if (Doms < 3 || 4*Doms < Qt.GetUrls()) { continue; }
435      }
436      IAssert(! QSet.IsKey(GetQtId(q))); QSet.AddKey(GetQtId(q));
437      FqQtIdV.Add(TIntPr(Fq, GetQtId(q)));
438    }
439    printf("  remaining %d quotes\n", FqQtIdV.Len());
440    FqQtIdV.Sort(false);
441    QtIdV.Clr(false);
442    TIntSet SeenSet;
443    for (int i = 0; i < FqQtIdV.Len(); i++) {
444      const int qid = FqQtIdV[i].Val2;
445      if (! SeenSet.IsKey(qid)) {
446        QtIdV.Add(qid);
447        SeenSet.AddKey(qid);
448        if (GetQt(qid).GetTy()==qtRoot || GetQt(qid).GetTy()==qtCentr) {
449          const TIntV& ClustV = GetClust(GetQt(qid).GetCId());
450          for (int c = 0; c < ClustV.Len(); c++) { SeenSet.AddKey(ClustV[c]); }
451        }
452      }
453    }
454    printf("  return %d quotes\n", QtIdV.Len());
455  }
456  void TQuoteBs::GetQtIdVByTm(const int& WndSzHr, const int& StepHr, const int& MinWrdLen, const int& MinQtFq, const int& TakePerStep) const {
457    const TTmUnit TmUnit = tmu4Hour;
458    TSecTm MinTm, MaxTm;  GetMinMaxTm(MinTm, MaxTm);
459    MinTm=MinTm.Round(TmUnit); MaxTm=MaxTm.Round(TmUnit);
460    printf("Dataset span %s -- %s\n", MinTm.GetStr().CStr(), MaxTm.GetStr().CStr());
461    printf("  time window %dh, step size %dh, min wrd len %d, take top %d per step\n", WndSzHr, StepHr, MinWrdLen, TakePerStep);
462    TIntSet TopQtIdSet;
463    TIntV TopQtIdV;
464    int cnt=0;
465    FILE *F = fopen("top_qts_per_time_unit.txt", "wt");
466    for (TSecTm Tm=MinTm; Tm <= MaxTm; Tm += StepHr*3600, cnt++) {
467      GetQtIdVByFq(TopQtIdV, MinWrdLen, MinQtFq, true, "", "", utUndef, TSecTm(Tm), TSecTm(Tm+StepHr*3600));
468      fprintf(F,"week of: %s\n", Tm.GetYmdTmStr().CStr());
469      for (int q = 0, j=0; q < TopQtIdV.Len() && j<3; q++) {
470        if (! TopQtIdSet.IsKey(TopQtIdV[q])) {
471          fprintf(F, "%s\t%d\n", GetQt(GetCentrQtId(TopQtIdV[q])).GetStr().CStr(), GetClustFq(TopQtIdV[q]));
472          j++; }
473        TopQtIdSet.AddKey(TopQtIdV[q]);
474      }
475      fprintf(F, "\n");
476    }
477    fclose(F);
478    printf("  done %d quotes\n", TopQtIdSet.Len());
479  }
480  void TQuoteBs::GetCIdVByFq(TIntV& CIdV, const int& MinClFq, const TStr& RootHasWord, const TUrlTy& OnlyCountTy, const bool& OnlyAfterRoot, const TSecTm& BegTm, const TSecTm& EndTm) const {
481    printf("Get top clusters from %d clusters\n", GetClusts());
482    TIntPrV FqCIdV;
483    for (int c = 0; c < GetClusts(); c++) {
484      const int CId = GetCId(c);
485      if ( ! IsQtId(CId)) { printf("!!! %d:%d\n", c, CId); continue; }
486      IAssert(GetQt(CId).GetTy()==qtRoot);
487      const int CentrQId = GetCentrQtId(CId);
488      if (CentrQId == -1) { continue; }
489      if ((! RootHasWord.Empty()) && GetQt(CentrQId).GetStr().SearchStr(RootHasWord)==-1) { continue; } 
490      TQuote CentrQt;  GetMergedClustQt(CId, CentrQt, OnlyAfterRoot); 
491      const int Fq = CentrQt.GetFq(BegTm, EndTm, OnlyCountTy, *this);
492      if (Fq < MinClFq) { continue; }
493      FqCIdV.Add(TIntPr(Fq, CId));
494    }
495    printf("  remaining %d clusters\n", FqCIdV.Len());
496    FqCIdV.Sort(false);
497    CIdV.Clr(false);
498    for (int i = 0; i < FqCIdV.Len(); i++) {
499      CIdV.Add(FqCIdV[i].Val2); }
500  }
501  void TQuoteBs::GetMinMaxTm(TSecTm& MinTm, TSecTm& MaxTm) const {
502    MinTm = MaxTm = TSecTm();
503    for (int q = 0; q < QuoteH.Len(); q++) {
504      const TQuote::TTmUrlCntV& V = QuoteH[q].TmUrlCntV;
505      if (V.Empty()) { continue; }
506      if (! MinTm.IsDef() || MinTm > V[0].Tm()) {
507        MinTm = V[0].Tm(); }
508      if (! MaxTm.IsDef() || MaxTm < V[0].Tm()) {
509        MaxTm = V[0].Tm(); }
510    }
511  }
512  void TQuoteBs::GetMinMaxTm(const TIntV& QtIdV, TSecTm& MinTm, TSecTm&MaxTm) const {
513    MinTm = MaxTm = TSecTm();
514    for (int q = 0; q < QtIdV.Len(); q++) {
515      const TQuote::TTmUrlCntV& V = GetQt(QtIdV[q]).TmUrlCntV;
516      if (V.Empty()) { continue; }
517      if (! MinTm.IsDef() || MinTm > V[0].Tm()) {
518        MinTm = V[0].Tm(); }
519      if (! MaxTm.IsDef() || MaxTm < V[0].Tm()) {
520        MaxTm = V[0].Tm(); }
521    }
522  }
523  void TQuoteBs::GetQtPageUrl(const TIntV& QtIdV, TIntH& QtUrlIdH) const {
524    THash<TChA, TInt> DomQtCntH;
525    for (int q = 0; q < Len(); q++) {
526      const TQuote& Q = GetQtN(q);
527      for (int u = 0; u < Q.GetUrls(); u++) {
528        DomQtCntH.AddDat(TStrUtil::GetDomNm(GetStr(Q.TmUrlCntV[u].UrlId()))) += Q.TmUrlCntV[u].Cnt(); }
529    }
530    const TStr StopList = "blog.myspace.com|www.newsmeat.com|us.rd.yahoo.com|www.startribune.com|"
531      "news.originalsignal.com|uk.news.yahoo.com|ap.google.com|www.cnn.com|www.opednews.com";
532    TStrV StopListV; StopList.SplitOnAllCh('|', StopListV);
533    for (int s = 0; s < StopListV.Len(); s++) {
534      DomQtCntH.AddDat(StopListV[s]) = 1; }
535    DomQtCntH.SortByDat(false);
536    QtUrlIdH.Clr(false);
537    for (int q = 0; q < QtIdV.Len(); q++) {
538      const TQuote& Q = GetQt(QtIdV[q]);
539      int DomFq=0, BestUrlId=0;
540      for (int u = 0; u < Q.TmUrlCntV.Len(); u++) {
541        const TChA Dom = TStrUtil::GetDomNm(GetStr(Q.TmUrlCntV[u].UrlId()));
542        if (DomFq < DomQtCntH.GetDat(Dom)) {
543          DomFq = DomQtCntH.GetDat(Dom);
544          BestUrlId = Q.TmUrlCntV[u].UrlId();
545        }
546      }
547      QtUrlIdH.AddDat(QtIdV[q], BestUrlId);
548    }
549  }
550  void TQuoteBs::AddQuote(const TQuote& Quote, const TQuoteBs& CurQtBs) {
551    const int QtId = CurQtBs.GetQtId(Quote.GetStr().CStr());
552    TQuote& Qt = QuoteH.AddDat(QtId);
553    StrQtIdH.AddDat(Quote.GetStr().CStr(), QtId);
554    Qt.QtCIdTy = TQuote::TQtIdTy(Quote.GetCId(), Quote.GetTy());
555    Qt.QtStr = Quote.QtStr;
556    Qt.TmUrlCntV = Quote.TmUrlCntV;
557    for (int u = 0; u < Qt.TmUrlCntV.Len(); u++) {
558      Qt.TmUrlCntV[u].SetUrlId(AddStr(CurQtBs.GetStr(Quote.TmUrlCntV[u].UrlId())));
559    }
560  }
561  void TQuoteBs::AddQuote(const TVec<TChA>& QuoteV, const TVec<TChA>& LinkV, const TChA& PostUrlStr, const TSecTm& PubTm, const int& MinQtWrdLen) {
562    TIntH QtCntH; 
563    for (int q = 0; q < QuoteV.Len(); q++) {
564      if (TStrUtil::CountWords(QuoteV[q].CStr()) < MinQtWrdLen) { continue; } 
565      int QtId = GetQtId(QuoteV[q].CStr());
566      if (QtId == -1) { 
567        IAssert(! IsStr(QuoteV[q].CStr()));
568        QtId = QuoteH.Len();
569        TQuote& Qt = QuoteH.AddDat(QtId);
570        Qt.QtCIdTy = TQuote::TQtIdTy(QtId, qtQuote);
571        Qt.QtStr = QuoteV[q];
572        StrQtIdH.AddDat(QuoteV[q].CStr(), QtId);
573      } else { IAssert(IsStr(QuoteV[q].CStr())); }
574      IAssert(IsQtId(QtId));
575      QtCntH.AddDat(QtId) += 1; 
576    }
577    if (QtCntH.Len() > 0) {
578      const int PostUrlId = AddStr(PostUrlStr);
579      for (int i = 0; i < QtCntH.Len(); i++) {
580        QuoteH.GetDat(QtCntH.GetKey(i)).TmUrlCntV.Add(TQuote::TTmUrlCnt(PubTm, PostUrlId, QtCntH[i]));
581      }
582    }
583    const TChA PostDomain = TStrUtil::GetDomNm(PostUrlStr);
584    for (int l = 0; l < LinkV.Len(); l++) {
585      const TChA& Url = LinkV[l];
586      if (TStrUtil::GetDomNm(Url) == PostDomain) { continue; } 
587      if (IsStr(Url.CStr())) { UrlInDegH.AddDat(GetStrId(Url.CStr())) += 1; }
588    }
589  }
590  PQuoteBs TQuoteBs::GetQuoteBs(const TIntV& QtIdV) const {
591    PQuoteBs _NewQtBs = TQuoteBs::New();
592    TQuoteBs& NewQtBs = *_NewQtBs;
593    for (int q = 0; q < QtIdV.Len(); q++) {
594      const TQuote& Qt = GetQt(QtIdV[q]);
595      NewQtBs.AddQuote(Qt, *this);
596    }
597    for (int u = 0; u < UrlInDegH.Len(); u++) {
598      const char* UrlStr = GetStr(UrlInDegH.GetKey(u));
599      if (NewQtBs.IsStr(UrlStr)) {
600        NewQtBs.UrlInDegH.AddDat(NewQtBs.GetStrId(UrlStr), UrlInDegH[u]); }
601    }
602    for (int t = 0; t < UrlTyH.Len(); t++) {
603      const char* UrlStr = GetStr(UrlTyH.GetKey(t));
604      if (NewQtBs.IsStr(UrlStr)) {
605        NewQtBs.UrlTyH.AddDat(NewQtBs.GetStrId(UrlStr), UrlTyH[t]); }
606    }
607    for (int c = 0; c < GetClusts(); c++) {
608      const int CId = GetCId(c);
609      if ( ! IsQtId(CId)) { printf("!!! %d:%d\n", c, CId); continue; }
610      const TIntV& CQtIdV = GetClust(CId);
611      if (NewQtBs.IsQtId(CId)) {
612        IAssert(! NewQtBs.ClustQtIdVH.IsKey(CId));
613        TIntV& CIdV = NewQtBs.ClustQtIdVH.AddDat(CId);
614        for (int i = 0; i < CQtIdV.Len(); i++) {
615          if (NewQtBs.IsQtId(CQtIdV[i])) { CIdV.Add(CQtIdV[i]); }
616        }
617        IAssert(CIdV.Len() > 0);
618      }
619    }
620    return _NewQtBs;
621  }
622  int TQuoteBs::GetQtsInClust() const {
623    int qts = 0;
624    for (int q = 0; q < ClustQtIdVH.Len(); q++) {
625      qts += ClustQtIdVH[q].Len();
626    }
627    return qts;
628  }
629  int TQuoteBs::GetClustFq(const int& CId) const {
630    int fq = 0;
631    TIntSet S;
632    const TIntV& ClustV = ClustQtIdVH.GetDat(CId);
633    for (int c = 0; c < ClustV.Len(); c++) {
634      fq += GetQt(ClustV[c]).GetFq();
635      IAssert(! S.IsKey(ClustV[c]));
636      S.AddKey((ClustV[c]));
637    }
638    return fq;
639  }
640  int TQuoteBs::GetClustFq(const int& CId, const TUrlTy& UrlTy) const {
641    int fq = 0;
642    const TIntV& ClustV = ClustQtIdVH.GetDat(CId);
643    for (int c = 0; c < ClustV.Len(); c++) {
644      fq += GetQt(ClustV[c]).GetFq(UrlTy, *this);
645    }
646    return fq;
647  }
648  int TQuoteBs::GetCentrQtId(const int& CId) const {
649    return GetCentrQtId(GetClust(CId));
650  }
651  int TQuoteBs::GetCentrQtId(const TIntV& ClustV) const {
652    TIntPrV QtFqIdV;
653    for (int c = 0; c < ClustV.Len(); c++) {
654      if (! IsQtId(ClustV[c])) { continue; }
655      const TQuote& Q = GetQt(ClustV[c]);
656      QtFqIdV.Add(TIntPr(Q.GetUrls(), ClustV[c]));
657    }
658    if (QtFqIdV.Empty()) { return -1; }
659    QtFqIdV.Sort(false);
660    const TStr FqStr = GetQt(QtFqIdV[0].Val2).GetStr(); 
661    for (int c = 0; c < QtFqIdV.Len(); c++) {
662      IAssert(IsQtId(QtFqIdV[c].Val2));
663      const TQuote& Q = GetQt(QtFqIdV[c].Val2);
664      const int Words = TStrUtil::CountWords(Q.GetStr().CStr());
665      if (Words >= 6 && Words < 50 && strstr(Q.GetStr().CStr(), FqStr.CStr())!=NULL) {
666        return QtFqIdV[c].Val2; }
667    }
668    return QtFqIdV[0].Val2;
669  }
670  void TQuoteBs::GetMergedClustQt(const int& CId, TQuote& NewQt, const bool& OnlyAfterBegTm) const {
671    const TIntV& ClustV = GetClust(CId);
672    GetMergedClustQt(ClustV, NewQt, OnlyAfterBegTm);
673  }
674  void TQuoteBs::GetMergedClustQt(const TIntV& ClustV, TQuote& NewQt, const bool& OnlyAfterBegTm) const {
675    const int CentrQtId = GetCentrQtId(ClustV);
676    const TSecTm BegTm = OnlyAfterBegTm ? GetClustBegTm(ClustV, CentrQtId) : TSecTm(1);
677    THash<TPair<TSecTm, TInt>, TInt> TmUrlCntH;
678    for (int c = 0; c < ClustV.Len(); c++) {
679      const TQuote& Q = GetQt(ClustV[c]);
680      for (int u = 0; u < Q.TmUrlCntV.Len(); u++) {
681        if (Q.TmUrlCntV[u].Tm() >= BegTm) {
682          TmUrlCntH.AddDat(TPair<TSecTm, TInt>(Q.TmUrlCntV[u].Tm(), Q.TmUrlCntV[u].UrlId())) += Q.TmUrlCntV[u].Cnt(); }
683      }
684    }
685    NewQt.QtCIdTy = TQuote::TQtIdTy(-1, qtCentr);
686    NewQt.QtStr = GetQt(CentrQtId).GetStr(); 
687    if (! TmUrlCntH.Empty()) {
688      NewQt.TmUrlCntV.Gen(TmUrlCntH.Len(), 0);
689      for (int u = 0; u < TmUrlCntH.Len(); u++) {
690        NewQt.TmUrlCntV.Add(TQuote::TTmUrlCnt(TmUrlCntH.GetKey(u).Val1, TmUrlCntH.GetKey(u).Val2(), TmUrlCntH[u]()));
691      }
692      NewQt.TmUrlCntV.Sort();
693    }
694  }
695  TSecTm TQuoteBs::GetClustBegTm(const int& CId, const int& CentrQtId) const {
696    const TIntV& ClustV = GetClust(CId);
697    return GetClustBegTm(ClustV, CentrQtId);
698  }
699  TSecTm TQuoteBs::GetClustBegTm(const TIntV& ClustV, const int& CentrQtId) const {
700    TStrHash<TInt> StrH;
701    TIntV CntrWIdV, WIdV;
702    int WIdV1Start, WIdV2Start, SkipId;
703    TStrUtil::GetAddWIdV(StrH, GetQt(CentrQtId).GetStr().CStr(), CntrWIdV);
704    TSecTm BegTm = TSecTm::GetCurTm();
705    for (int c = 0; c < ClustV.Len(); c++) {
706      TStrUtil::GetAddWIdV(StrH, GetQt(ClustV[c]).GetStr().CStr(), WIdV);
707      if (WIdV.Len() < CntrWIdV.Len()) { continue; }
708      const int Overlap = LongestCmnSubSq(CntrWIdV, WIdV, WIdV1Start, WIdV2Start, SkipId);
709      if (Overlap >= CntrWIdV.Len() && SkipId==0) { 
710        if (GetQt(ClustV[c]).TmUrlCntV.Empty()) { continue; }
711        BegTm = TMath::Mn(BegTm, GetQt(ClustV[c]).TmUrlCntV[0].Tm()); 
712      }
713    }
714    return BegTm;
715  }
716  int TQuoteBs::LongestCmnSubSq(const TIntV& WIdV1, const TIntV& WIdV2, int& WIdV1Start, int& WIdV2Start, int& SkipId) {
717    const TIntV& V1 = WIdV1.Len()>WIdV2.Len() ? WIdV1:WIdV2; 
718    const TIntV& V2 = WIdV1.Len()>WIdV2.Len() ? WIdV2:WIdV1; 
719    const int V1Len = V1.Len();
720    const int V2Len = V2.Len();
721    static THash<TInt, TIntV> WIdPosH;
722    static THashSet<TInt> V2WIdSet;
723    V2WIdSet.Clr(false);
724    for (int i=0; i < WIdPosH.Len(); i++) { WIdPosH[i].Clr(false); }
725    WIdPosH.Clr(false, -1, false);
726    WIdV1Start = WIdV2Start = SkipId = 0;
727    for (int i = 0; i < V2Len; i++) { 
728      V2WIdSet.AddKey(V2[i]); }
729    for (int i = 0; i < V1Len; i++) { 
730      if (V2WIdSet.IsKey(V1[i])) { WIdPosH.AddDat(V1[i]).Add(i); } }
731    {const int cmnWords = WIdPosH.Len();
732    if (cmnWords < V2WIdSet.Len()) {
733      if (cmnWords < 4) { return 0; }
734      else if (V2Len >= 5 && cmnWords < 5) { return 0; }
735      else if (V2Len > 6 && (2*cmnWords < V2Len && cmnWords < 10)) { return 0; } }
736    }
737    int MaxLen = 0;
738    for (int w = 0; w < V2Len; w++) { 
739      const int wid = V2[w];
740      if (! WIdPosH.IsKey(wid)) { continue; }
741      const TIntV& OccV = WIdPosH.GetDat(wid);
742      for (int o = 0; o < OccV.Len(); o++) {
743        const int beg = OccV[o];
744        int cnt = 0, tmp = 0;
745        while (w+cnt < V2Len && beg+cnt < V1Len && V2[w+cnt]==V1[beg+cnt]) { cnt++; tmp=0; }           
746        while (beg+1+cnt < V1Len && w+cnt < V2Len && V2[w+cnt]==V1[beg+cnt+1]) { cnt++; tmp=-1; }      
747        while (beg+cnt+1 < V1Len && w+cnt+1 < V2Len && V2[w+cnt+1]==V1[beg+cnt+1]) {  cnt++; tmp=-2;}  
748        while (beg+cnt < V1Len && w+cnt+1 < V2Len && V2[w+cnt+1]==V1[beg+cnt]) { cnt++; tmp=-3;}       
749        if (MaxLen < cnt) { MaxLen = cnt; SkipId=tmp; WIdV1Start = beg;  WIdV2Start = w; }
750        IAssert(cnt >= 1);
751      }
752    }
753    if (! (WIdV1.Len()>WIdV2.Len())) {
754      int tmp=WIdV1Start; WIdV1Start=WIdV2Start; WIdV2Start=tmp;
755    }
756    return MaxLen;
757  }
758  void TQuoteBs::CreateClusters(const TVec<TIntV>& ClustV) {
759    TIntV CIdV;
760    ClustQtIdVH.Clr();
761    printf("len %d\n", Len());
762    for (int q = 0; q < Len(); q++) {
763      TQuote& Q = GetQt(q);
764      Q.QtCIdTy = TQuote::TQtIdTy(q, qtQuote);
765    }
766    TIntH SeenNId;
767    for (int c = 0; c < ClustV.Len(); c++) {
768      if (ClustV[c].Len() < 3) { continue; } 
769      const int CentrQtId = GetCentrQtId(ClustV[c]);
770      if (CentrQtId == -1) {
771        printf("Cluster %d of size %d has no root!!!\n", c, ClustV[c].Len());
772        for (int i = 0; i < ClustV[c].Len(); i++) {
773          printf("  %d%c", ClustV[c][i].Val, IsQtId(ClustV[c][i])?'t':'f'); } printf("\n");
774        continue;
775      }
776      IAssert(! SeenNId.IsKey(CentrQtId));
777      SeenNId.AddKey(CentrQtId);
778      TQuote& Q = GetQt(CentrQtId);
779      if (Q.GetTy() != qtQuote) { printf("  %d", Q.GetTy()); }
780      IAssert(! ClustQtIdVH.IsKey(CentrQtId));
781      Q.QtCIdTy = TQuote::TQtIdTy(CentrQtId, qtRoot);
782      ClustQtIdVH.AddDat(CentrQtId, ClustV[c]);
783      for (int q = 0; q < ClustV[c].Len(); q++) {
784        if (ClustV[c][q] == CentrQtId) { continue; }
785        IAssert(! SeenNId.IsKey(ClustV[c][q]));
786        SeenNId.AddKey(ClustV[c][q]);
787        TQuote& Q2 = GetQt(ClustV[c][q]);
788        Q2.QtCIdTy = TQuote::TQtIdTy(CentrQtId, qtInClust);
789      }
790    }
791  }
792  void TQuoteBs::ClusterQts(const int& MinRootWrdLen, const int& MinQtFq, const TStr& OutFNmPref, const TStrV& BlackListV) {
793    printf("Cluster quotes with min Fq >= %d: %d total quotes\n", MinQtFq, Len());
794    TExeTm ExeTm;
795    TStrHash<TInt> StrH;
796    TVec<TPair<TInt, TIntV> > QWIdVV;  
797    { TIntPrV LenQIdV;  TIntV QWIdV;
798    printf("sort qid by len\n");
799    TStrHash<TInt> BlackListH;
800    for (int i = 0; i < BlackListV.Len(); i++) { BlackListH.AddDatId(BlackListV[i].GetTrunc()); }
801    printf("blacklist len: %d\n", BlackListH.Len());
802    for (int q1 = 0; q1 < Len(); q1++) {
803      const TQuote& Q = GetQtN(q1);
804      const int Doms = Q.GetDoms(*this);
805      if ((Q.GetTy()==qtQuote || Q.GetTy()==qtRoot) && Doms>1 && Doms*4>Q.GetUrls()
806        && Q.GetFq() >= MinQtFq && (! BlackListH.IsKey(Q.GetStr().CStr()))) { 
807          LenQIdV.Add(TIntPr(TStrUtil::CountWords(Q.QtStr.CStr()), GetQtId(q1))); }
808    }
809    printf("sort %d candidates\n", LenQIdV.Len());
810    LenQIdV.Sort(false);
811    printf("get word id vectors\n");
812    for (int q1 = 0; q1 < LenQIdV.Len(); q1++) {
813      TStrUtil::GetAddWIdV(StrH, GetQt(LenQIdV[q1].Val2).QtStr.CStr(), QWIdV);
814      QWIdVV.Add(TPair<TInt, TIntV>(LenQIdV[q1].Val2, QWIdV));
815    } }
816    printf("  %d root quotes\n", ClustQtIdVH.Len());
817    printf("  %d quotes to merge\n", QWIdVV.Len());
818    int NMergers=0;
819    FILE *F = fopen(TStr(OutFNmPref+"-merged.txt").CStr(), "wt");
820    const int ClusterQ=QWIdVV.Len();
821    for (int q1 = 0; q1 < ClusterQ; q1++) {
822      if (QWIdVV[q1].Val2.Len() < MinRootWrdLen) { continue; } 
823      const int Qt1Id = QWIdVV[q1].Val1;
824      for (int q2 = q1+1; q2 < ClusterQ; q2++) {
825        int idx1=0, idx2=0, SkipTy=0;
826        bool DoMerge = false;
827        const int ShortLen = TMath::Mn(QWIdVV[q1].Val2.Len(), QWIdVV[q2].Val2.Len());
828        if (ShortLen == 0) { continue; }
829        const int Overlap = LongestCmnSubSq(QWIdVV[q1].Val2, QWIdVV[q2].Val2, idx1, idx2, SkipTy);
830        if (ShortLen == 4 && Overlap == 4 &bsol;*&& SkipTy==0*/) { DoMerge=true; } 
831        else if (ShortLen == 5 && Overlap == 5 &bsol;*&& SkipTy==0*/) { DoMerge=true; } 
832        else if ((ShortLen == 6 && Overlap >= 5 &bsol;*&& SkipTy==0) || (ShortLen == 6 && Overlap == 5*/)) { DoMerge=true; }
833        else if (Overlap/double(ShortLen+3) > 0.5 || Overlap > 10) { DoMerge=true; }
834        if (DoMerge == true) {
835          NMergers++;
836          const int Qt2Id = QWIdVV[q2].Val1;
837          TQuote& Q1 = GetQt(Qt1Id);
838          TQuote& Q2 = GetQt(Qt2Id);
839          if (Q1.GetTy() != qtRoot) { 
840            IAssert(Q1.GetTy() == qtQuote);
841            IAssert(! ClustQtIdVH.IsKey(Qt1Id));
842            ClustQtIdVH.AddDat(Qt1Id).Add(Qt1Id);
843            Q1.QtCIdTy = TQuote::TQtIdTy(Qt1Id, qtRoot);
844          } else { IAssert(Q1.GetTy() == qtRoot); }
845          if (Q2.GetTy() == qtRoot) { 
846            for (int c = 0; c < ClustQtIdVH.GetDat(Qt2Id).Len(); c++) {
847              ClustQtIdVH.AddDat(Qt1Id).Add(ClustQtIdVH.GetDat(Qt2Id)[c]); }
848            Q2.QtCIdTy = TQuote::TQtIdTy(Qt1Id, qtInClust);
849            ClustQtIdVH.DelKey(Qt2Id);
850            IAssert(ClustQtIdVH.AddDat(Qt1Id).IsIn(Qt2Id));
851          } else {
852            IAssert(Q2.GetTy() == qtQuote);
853            Q2.QtCIdTy = TQuote::TQtIdTy(Qt1Id, qtInClust);
854            ClustQtIdVH.AddDat(Qt1Id).Add(Qt2Id);
855          }
856          QWIdVV[q2].Val2.Clr(true); 
857          { TStr Str= "    :"; if(SkipTy==-1){Str="long=";} else if(SkipTy==-2){Str="both=";} else if(SkipTy==-3){Str="shrt=";}
858          if (Str.Len()>0) { printf("%c", Str[0]); }
859          if (ClustQtIdVH.GetDat(Qt1Id).Len() == 2) { fprintf(F, "\n[%d] %s \t%d\n", TStrUtil::CountWords(Q1.QtStr.CStr()), Q1.QtStr.CStr(), Q1.GetFq()); }
860          fprintf(F, "%s%d [%d] %s \t%d\n", Str.CStr(), Overlap, TStrUtil::CountWords(Q2.QtStr.CStr()), Q2.QtStr.CStr(), Q2.GetFq()); }
861        }
862      }
863      if (ClustQtIdVH.IsKey(Qt1Id)) {
864        ClustQtIdVH.GetDat(Qt1Id).Pack();
865        ClustQtIdVH.GetDat(Qt1Id).Sort();
866        QWIdVV[q1].Val2.Clr(true);
867      }
868      if (q1>0 && q1 % 100 == 0) {
869        printf("\r  %d/%d: %d merged [%s]  ", q1, ClusterQ, NMergers, ExeTm.GetStr());
870        if (q1 % 1000 == 0) { printf("save.\n");  fflush(F);
871          TFOut FOut(OutFNmPref+"-QtBs.ClustQtIdVH"); ClustQtIdVH.Save(FOut); }
872      }
873    }
874    fclose(F);
875    printf("\n%d quotes, %d clusters [%s]\n\n.", NMergers, ClustQtIdVH.Len(), ExeTm.GetStr());
876  }
877  void TQuoteBs::ResetClusters() {
878    ClustQtIdVH.Clr();
879    for (int q = 0; q < Len(); q++) {
880      GetQtN(q).QtCIdTy = TQuote::TQtIdTy(GetQtId(q), qtQuote);
881    }
882  }
883  void TQuoteBs::ReassignToClust(const int& QtId, const int& NewCId) {
884    const int QtCl = GetQt(QtId).GetCId();
885    printf("assign %d from clust %d to %d\n", QtId, QtCl, NewCId);
886    if (QtCl != QtId) {
887      ClustQtIdVH.GetDat(QtCl).DelIfIn(QtId); }
888    GetQt(QtId).QtCIdTy = TQuote::TQtIdTy(NewCId, qtInClust);
889    ClustQtIdVH.AddDat(NewCId).Add(QtId);
890  }
891  void TQuoteBs::Mergec2Clusters(const int& ParentCId, const int& ChildCId) {
892    IAssert(IsClust(ParentCId) && IsClust(ChildCId));
893    printf("merging %d (fq: %d) to %d (%d fq)\n", ChildCId, GetClustFq(ChildCId), ParentCId, GetClustFq(ParentCId));
894    TIntSet ClustSet;
895    { const TIntV& ClustV = GetClust(ParentCId);
896    for (int c = 0; c < ClustV.Len(); c++) {
897      ClustSet.AddKey(ClustV[c]); } }
898    { const TIntV& ClustV = GetClust(ChildCId);
899    for (int c = 0; c < ClustV.Len(); c++) {
900      ClustSet.AddKey(ClustV[c]); } }
901    ClustSet.GetKeyV(ClustQtIdVH.GetDat(ParentCId));
902    GetQt(ChildCId).QtCIdTy = TQuote::TQtIdTy(ChildCId, qtInClust);
903    ClustQtIdVH.DelKey(ChildCId);
904    ClustQtIdVH.Defrag();
905  }
906  PClustNet TQuoteBs::GetClustNet(const int& MinQtFq, const TStr& OutFNmPref) const {
907    printf("Cluster quotes with Fq >= %d: %d total quotes\n", MinQtFq, Len());
908    TExeTm ExeTm;
909    TStrHash<TInt> StrH;
910    FILE *F = fopen(TStr(OutFNmPref+"-candidates.txt").CStr(), "wt");
911    THash<TInt, TIntV> QWIdVH;  
912    { TIntPrV LenQIdV;  TIntV QWIdV;
913    printf("sort qid by len\n");
914    for (int q1 = 0; q1 < Len(); q1++) {
915      const TQuote& Q = GetQtN(q1);
916      const int Doms = Q.GetDoms(*this);
917      if ((Q.GetTy()!=qtCentr) && Doms>1 && Doms*4 > Q.GetUrls() && Q.GetFq() >= MinQtFq) { 
918        LenQIdV.Add(TIntPr(TStrUtil::CountWords(Q.QtStr.CStr()), GetQtId(q1)));
919      }
920    }
921    printf("sort %d candidates by word length\n", LenQIdV.Len());
922    LenQIdV.Sort(false);
923    for (int q1 = 0; q1 < LenQIdV.Len(); q1++) {
924      TStrUtil::GetAddWIdV(StrH, GetQt(LenQIdV[q1].Val2).QtStr.CStr(), QWIdV);
925      QWIdVH.AddDat(LenQIdV[q1].Val2, QWIdV);
926      fprintf(F, "%s\n", GetQt(LenQIdV[q1].Val2).QtStr.CStr());
927    } }
928    printf("  %d root quotes\n", ClustQtIdVH.Len());
929    printf("  %d quotes to merge\n", QWIdVH.Len());
930    const int ClusterQ=QWIdVH.Len();
931    PClustNet ClustNet = TClustNet::New();
932    TIntH NIdDepthH;
933    TIntSet SeenQtIdSet;
934    int NMerges=0, idx1=0, idx2=0, SkipTy=0; 
935    for (int q1 = 0; q1 < ClusterQ; q1++) { 
936      SeenQtIdSet.Clr(false);
937      const int Qt1Id = QWIdVH.GetKey(q1);
938      for (int q2 = q1-1; q2 >= 0; q2--) { 
939        const int Qt2Id = QWIdVH.GetKey(q2);
940        if (SeenQtIdSet.IsKey(Qt2Id)) { continue; }
941        bool DoMerge = false;
942        const int Overlap = LongestCmnSubSq(QWIdVH[q1], QWIdVH[q2], idx1, idx2, SkipTy);
943        const int ShortLen = QWIdVH[q1].Len(); IAssert(QWIdVH[q1].Len()<= QWIdVH[q2].Len());
944        if (ShortLen == 4 && Overlap == 4) { DoMerge=true; } 
945        else if (ShortLen == 5 && Overlap == 5) { DoMerge=true; } 
946        else if (ShortLen == 6 && Overlap >= 5) { DoMerge=true; }
947        else if (Overlap/double(ShortLen+3) > 0.5 || Overlap > 10) { DoMerge=true; }
948        if (DoMerge==true) { NMerges++;
949          if (! ClustNet->IsNode(Qt1Id)) { ClustNet->AddNode(Qt1Id, GetQt(Qt1Id)); }
950          if (! ClustNet->IsNode(Qt2Id)) { ClustNet->AddNode(Qt2Id, GetQt(Qt2Id)); }
951          ClustNet->AddEdge(Qt1Id, Qt2Id);
952          SeenQtIdSet.AddKey(Qt1Id);  SeenQtIdSet.AddKey(Qt2Id);
953          fprintf(F, "%d Merge\t%d\t%d\ttree\t%d\n\t%s\n\t%s\n", q1, QWIdVH[q1].Len(), QWIdVH[q2].Len(), NIdDepthH.Len(), GetQt(Qt2Id).GetStr().CStr(), GetQt(Qt1Id).GetStr().CStr());
954          fflush(F);
955        }
956      }
957      if (q1>0 && q1 % 100 == 0) {
958        printf("\r  %d/%d: %d merged [%s]  ", q1, ClusterQ, NMerges, ExeTm.GetStr());
959        if (q1 % 1000 == 0) {
960          printf("save: %d merges, %d nodes, %d edges in ClustNet [%s]\n.", NMerges, ClustNet->GetNodes(), ClustNet->GetEdges(), ExeTm.GetStr());
961          TFOut FOut(OutFNmPref+".ClustNet"); ClustNet->Save(FOut); }
962      }
963    }
964    fclose(F);
965    printf("\n%d merges, %d nodes, %d edges in ClustNet [%s]\n\n.", NMerges, ClustNet->GetNodes(), ClustNet->GetEdges(), ExeTm.GetStr());
966    return ClustNet;
967  }
968  void TQuoteBs::AddMergedQtsToQtBs() {
969    printf("merge quote clusters and add them to the quote base\n");
970    TQuote MergedQt;
971    int toDel = ClustQtIdVH.Len();
972    for (int q = 0; q < QuoteH.Len(); q++) {
973      if (QuoteH[q].GetFq() == 1) { QuoteH.DelKeyId(q); toDel--; }
974      if (toDel == 0) { break; }
975    }
976    for (int q = 0; q < ClustQtIdVH.Len(); q++) {
977      GetMergedClustQt(ClustQtIdVH.GetKey(q), MergedQt);
978      IAssert(MergedQt.TmUrlCntV.Len() > 0); 
979      QuoteH.AddDat(QuoteH.Len(), MergedQt); 
980    }
981    printf("IsKeyIdEqKeyN: %s\n", QuoteH.IsKeyIdEqKeyN()?"T":"F");
982  }
983  PQuoteBs TQuoteBs::GetMergeClusters(const bool& OnlyClusters) const {
984    printf("Merging clusters into single quotes:\n");
985    PQuoteBs NewQtBs = TQuoteBs::New();
986    TQuote MergedQt;
987    printf("  %d quotes total\n", Len());
988    printf("  %d clusters\n", ClustQtIdVH.Len());
989    TIntSet SeenQtIdSet;
990    for (int q = 0; q < ClustQtIdVH.Len(); q++) {
991      GetMergedClustQt(ClustQtIdVH.GetKey(q), MergedQt);
992      IAssert(MergedQt.TmUrlCntV.Len() >0);
993      NewQtBs->AddQuote(MergedQt, *this);
994      const TIntV& ClustQtIdV = ClustQtIdVH[q];
995      for (int c = 0; c < ClustQtIdV.Len(); c++) {
996        const int qid = ClustQtIdV[c];
997        IAssert(! SeenQtIdSet.IsKey(qid)); 
998        SeenQtIdSet.AddKey(qid);
999      }
1000    }
1001    if (! OnlyClusters) {
1002      for (int q = 0; q < Len(); q++) {
1003        const TQuote& Q = GetQtN(q);
1004        if (! SeenQtIdSet.IsKey(GetQtId(q))) {
1005          NewQtBs->AddQuote(Q, *this); }
1006      }
1007    }
1008    printf("  %d quotes in new Quotes base\n", NewQtBs->Len());
1009    return NewQtBs;
1010  }
1011  void TQuoteBs::GetTopQtDoms(TStrIntPrV& DomCntV, const int& TakeNClust, const int& MinClFq, const TStr& RootHasWord, const TUrlTy& OnlyCountTy) const {
1012    TIntV CIdV;
1013    GetCIdVByFq(CIdV, MinClFq, RootHasWord, OnlyCountTy);
1014    THash<TStr, TInt> DomCntH;
1015    for (int c = 0; c < TMath::Mn(CIdV.Len(), TakeNClust); c++) {
1016      const TIntV& ClustV = GetClust(CIdV[c]);
1017      for (int q = 0; q < ClustV.Len(); q++) {
1018        const TQuote& Q = GetQt(ClustV[q]);
1019        for (int u = 0; u < Q.TmUrlCntV.Len(); u++) {
1020          DomCntH.AddDat(TStrUtil::GetDomNm(GetStr(Q.TmUrlCntV[u].UrlId()))) += 1;
1021        }
1022      }
1023    }
1024    DomCntH.SortByDat(false);
1025    DomCntH.GetKeyDatPrV(DomCntV);
1026  }
1027  void TQuoteBs::TopDomsByLag(const TTmUnit& TmUnit, const int& TakeNDoms, const int& TakeNClusts, const int& Thresh) const {
1028    THash<TStr, TMom> DomLagH;
1029    TIntV CIdV;  GetCIdVByFq(CIdV, 10, "", utUndef);
1030    TStrIntPrV DomCntV;  GetTopQtDoms(DomCntV, TakeNClusts, 10, "", utUndef);
1031    printf("Take %d clusters, %d domains", TakeNClusts, TakeNDoms);
1032    for (int d = 0; d < TMath::Mn(TakeNDoms, DomCntV.Len()); d++) {
1033      DomLagH.AddDat(DomCntV[d].Val1);
1034      printf("%d\t%s\n", DomCntV[d].Val2(), DomCntV[d].Val1.CStr());
1035    }
1036    int NQuotes=0;
1037    for (int c = 0; c < TMath::Mn(CIdV.Len(), TakeNClusts); c++) {
1038      TQuote Q;  GetMergedClustQt(CIdV[c], Q, false);
1039      const TSecTm MedTm = Q.GetMedianTm(TmUnit, utUndef, *this).Round(TmUnit);
1040      TStrSet DomSet;
1041      for (int u = 0; u < Q.TmUrlCntV.Len(); u++) {
1042        IAssert(IsStrId(Q.TmUrlCntV[u].UrlId()));
1043        const TStr Dom = TStrUtil::GetDomNm(GetStr(Q.TmUrlCntV[u].UrlId()));
1044        if (DomSet.IsKey(Dom)) { continue; } 
1045        if (! DomLagH.IsKey(Dom)) { continue; }
1046        DomLagH.AddDat(Dom).Add((int(Q.TmUrlCntV[u].Tm().Round(TmUnit))-int(MedTm))/3600.0);
1047        DomSet.AddKey(Dom);
1048      }
1049      NQuotes += GetClust(CIdV[c]).Len();
1050    }
1051    FILE *F = fopen(TStr::Fmt("domsByLag-clust%d.tab", TakeNClusts).CStr(), "wt");
1052    fprintf(F, "Top clusters: %d, total quotes in top clusters: %d\n", TakeNClusts, NQuotes);
1053    TFltFltStrTrV MedLagDomV;
1054    for (int i = 0; i < DomLagH.Len(); i++) {
1055      DomLagH[i].Def();
1056      MedLagDomV.Add(TFltFltStrTr(DomLagH[i].GetMedian(), DomLagH[i].GetVals(), DomLagH.GetKey(i)));
1057    }
1058    MedLagDomV.Sort();
1059    fprintf(F, "AGGREGATE PEAK\nTop domains with least lag (out of top %d considered) that mention at least 10 pct of top %d quotes (clusters) :\n", TakeNDoms, TakeNClusts);
1060    for (int i = 0; i < MedLagDomV.Len(); i++) {
1061      if (MedLagDomV[i].Val2() < Thresh*TakeNClusts/100.0) { continue; }
1062      fprintf(F, "%g\t%g\t%s\n", MedLagDomV[i].Val1(), MedLagDomV[i].Val2(), MedLagDomV[i].Val3.CStr());
1063    }
1064    fclose(F);
1065  }
1066  void TQuoteBs::PlotQtFqCnt(const TStr& OutFNmPref) const {
1067    TIntH UrlCntH, DomCntH, CntFqH;
1068    THashSet<TChA> DomSet;
1069    for (int q = 0; q < QuoteH.Len(); q++) {
1070      const TQuote& Q = GetQtN(q);
1071      UrlCntH.AddDat(Q.GetUrls()) += 1;
1072      CntFqH.AddDat(Q.GetFq()) += 1;
1073      DomSet.Clr(false);
1074      for (int u = 0; u < Q.GetUrls(); u++) {
1075        DomSet.AddKey(TStrUtil::GetDomNm(GetStr(Q.TmUrlCntV[u].UrlId()))); }
1076      DomCntH.AddDat(DomSet.Len()) += 1;
1077    }
1078    TGnuPlot::PlotValCntH(UrlCntH, OutFNmPref+"-url", "", "number of urls quote appears at", "count", gpsLog10XY);
1079    TGnuPlot::PlotValCntH(DomCntH, OutFNmPref+"-dom", "", "number of domains quote appears at", "count", gpsLog10XY);
1080    TGnuPlot::PlotValCntH(CntFqH, OutFNmPref+"-fq", "", "number of times quote appears", "count", gpsLog10XY);
1081  }
1082  void TQuoteBs::PlotQtMediaVsBlogFq(const int& QtId, const TStr& OutFNmPref) const {
1083    TQuote::TTmFltPrV BlogFqV, MediaFqV, SmoothV;
1084    TFltPrV FqV;
1085    const TQuote& ClQt = GetQt(QtId);
1086    ClQt.GetFqOt(BlogFqV, tmu4Hour, utBlog, *this);
1087    ClQt.GetFqOt(MediaFqV, tmu4Hour, utMedia, *this);
1088    const TSecTm MinTm = ClQt.TmUrlCntV[0].Tm().Round(tmuDay);
1089    TGnuPlot GP("mediaVsBlogs-"+OutFNmPref, TStr::Fmt("%s. b:%d m:%d u:%d d:%d", ClQt.GetStr().CStr(),
1090      ClQt.GetFq(utBlog, *this), ClQt.GetFq(utMedia, *this), ClQt.GetUrls(), ClQt.GetDoms(*this)));
1091    TQuote::GetSmoothFqOt(SmoothV, BlogFqV, tmu4Hour, 24, 1.2, MinTm);
1092    for (int i = 0; i < SmoothV.Len(); i++) {
1093      FqV.Add(TFltPr(double(SmoothV[i].Val1-MinTm)/(24.0*3600.0), SmoothV[i].Val2())); }
1094    GP.AddPlot(FqV, gpwLines, "Blog frequency");
1095    TQuote::GetSmoothFqOt(SmoothV, MediaFqV, tmu4Hour, 24, 1.2, MinTm);
1096    FqV.Clr();
1097    for (int i = 0; i < SmoothV.Len(); i++) {
1098      IAssert(SmoothV[i].Val1>=MinTm);
1099      FqV.Add(TFltPr(double(SmoothV[i].Val1-MinTm)/(24.0*3600.0)*(54.0/46.0), SmoothV[i].Val2()));
1100    }
1101    GP.AddPlot(FqV, gpwLines, "Media frequency");
1102    GP.SetXYLabel(TStr::Fmt("time [days] since %s", MinTm.GetYmdTmStr().CStr()), "Quote frequency (normalized for the baseline 46 vs 54)");
1103    GP.SavePng();
1104  }
1105  int NormMaxTo1(const TQuote::TTmFltPrV& TmFqV, TFltPrV& OutV, const TSecTm& BegTm) {
1106    int Idx=0;
1107    double MaxVal=0;
1108    for (int i = 0; i < TmFqV.Len(); i++) {
1109      if (MaxVal < TmFqV[i].Val2) {
1110        MaxVal=TmFqV[i].Val2; Idx = i; }
1111    }
1112    OutV.Gen(TmFqV.Len(), 0);
1113    for (int i = 0; i < TmFqV.Len(); i++) {
1114      OutV.Add(TFltPr(double(TmFqV[i].Val1-BegTm)/(24.0*3600.0), TmFqV[i].Val2())); 
1115    }
1116    return Idx;
1117  }
1118  void TQuoteBs::PlotClustMediaVsBlogFq(const int& CId, const TStr& OutFNmPref) const {
1119    const TTmUnit TmUnit = tmu4Hour;
1120    TQuote::TTmFltPrV BlogFqV, MediaFqV, AllFqV, SmoothV;
1121    TFltPrV FqV, RawFqV;
1122    TQuote ClQt;
1123    GetMergedClustQt(CId, ClQt, false);
1124    ClQt.GetFqOt(BlogFqV, TmUnit, utBlog, *this);
1125    ClQt.GetFqOt(MediaFqV, TmUnit, utMedia, *this);
1126    const TSecTm MinTm = ClQt.TmUrlCntV[0].Tm().Round(tmuDay);
1127    const TSecTm  MediaPeak = ClQt.GetPeakTm(TmUnit, TSecTm(1), utMedia, *this);
1128    const TSecTm BlogPeak = ClQt.GetPeakTm(TmUnit, TSecTm(1), utBlog, *this);
1129    const int Lag = (int(BlogPeak.Round(TmUnit))-int(MediaPeak.Round(TmUnit)))/3600;
1130    const bool Is1Peak = ClQt.IsSinglePeak(TmUnit, TSecTm(1), utUndef, *this);
1131    TGnuPlot GP("mediaVsBlogs-"+OutFNmPref, TStr::Fmt("%s. b:%d m:%d u:%d d:%d", Is1Peak?"SINGLE PEAK": "MORE PEAKS", 
1132      Lag, ClQt.GetFq(utBlog, *this), ClQt.GetFq(utMedia, *this), ClQt.GetUrls(), ClQt.GetDoms(*this)));
1133    int mx = NormMaxTo1(BlogFqV, RawFqV, MinTm);
1134    TQuote::GetSmoothFqOt(SmoothV, BlogFqV, TmUnit, 2*24, 1.2, MinTm);
1135    mx = NormMaxTo1(SmoothV, FqV, MinTm);
1136    GP.AddPlot(FqV, gpwLines, TStr::Fmt("SMOOTH Blog : max %s", SmoothV[mx].Val1.GetYmdTmStr().CStr()), "pt 7 ps 1");
1137    const TSecTm SmBlog = SmoothV[mx].Val1;
1138    mx = NormMaxTo1(MediaFqV, RawFqV, MinTm);
1139    TQuote::GetSmoothFqOt(SmoothV, MediaFqV, TmUnit, 2*24, 1.2, MinTm);
1140    mx = NormMaxTo1(SmoothV, FqV, MinTm);
1141    const TSecTm SmMed = SmoothV[mx].Val1;
1142    const int SmLag = (int(SmBlog.Round(TmUnit))-int(SmMed.Round(TmUnit)))/3600;
1143    GP.AddPlot(FqV, gpwLines, TStr::Fmt("SMOOTH Media is behind: %dh, smooth: %dh.", -Lag, -SmLag), "pt 5 ps 1");
1144    GP.SetXYLabel(TStr::Fmt("time [days] since %s", MinTm.GetYmdTmStr().CStr()), "Cluster frequency (normalized for the baseline 46 vs 54)");
1145    GP.AddCmd("set xtics 10");
1146    GP.AddCmd("set mxtics 10");
1147    GP.SavePng();
1148  }
1149  void TQuoteBs::PlotMediaVsBlogLag(const TTmUnit& TmUnit, const bool& TakeClusters, const int& TakeN, const TStr& OutFNmPref) const {
1150    TQuote Qt;  TIntV IdV;
1151    TMom LagMom1d, LagMom2d, LagMom3d, LagMom4d, LagMom7d;
1152    TFltFltH LagCntH, LagBCntH, LagMCntH;
1153    int Cnt=0;
1154    if (TakeClusters) { GetCIdVByFq(IdV, 10, "", utUndef, false); }
1155    else { GetQtIdVByFq(IdV, 8, 10, false, "", "", utUndef); }
1156    for (int c = 0; c < TakeN; c++) {
1157      if (TakeClusters) { GetMergedClustQt(IdV[c], Qt, false); }
1158      else { Qt = GetQt(IdV[c]); }
1159      const TSecTm  AllPeak = Qt.GetMedianTm(TmUnit, utUndef, *this);
1160      const TSecTm BlogPeak = Qt.GetMedianTm(TmUnit, utBlog, *this);
1161      const TSecTm  MediaPeak = Qt.GetMedianTm(TmUnit, utMedia, *this);
1162      const double Lag = (int(BlogPeak.Round(TmUnit))-int(MediaPeak.Round(TmUnit)))/3600.0;
1163      const double Lag1 = (int(BlogPeak.Round(TmUnit))-int(AllPeak.Round(TmUnit)))/3600.0;
1164      const double Lag2 = (int(MediaPeak.Round(TmUnit))-int(AllPeak.Round(TmUnit)))/3600.0;
1165      if (fabs(Lag) < 1*24) { LagMom1d.Add(Lag); }
1166      if (fabs(Lag) < 2*24) { LagMom2d.Add(Lag); }
1167      if (fabs(Lag) < 3*24) { LagMom3d.Add(Lag); }
1168      if (fabs(Lag) < 4*24) { LagMom4d.Add(Lag); }
1169      if (fabs(Lag) < 7*24) { LagMom7d.Add(Lag); }
1170      LagCntH.AddDat(Lag) += 1;
1171      LagBCntH.AddDat(Lag1) += 1;
1172      LagMCntH.AddDat(Lag2) += 1;
1173      Cnt++;
1174    }
1175    TFltPrV PrV;
1176    LagMom1d.Def();  LagMom2d.Def();  LagMom3d.Def();  LagMom4d.Def();  LagMom7d.Def();
1177    { TGnuPlot GP("lagBlogsVsMedia-"+OutFNmPref, TStr::Fmt("Lag: 1D: %.2f %g;   2D: %.2f  %g;   3D: %.2f  %g;   4D: %.2f  %g;   7D: %.2f  %g",
1178      LagMom1d.GetMean(), LagMom1d.GetMedian(), LagMom2d.GetMean(), LagMom2d.GetMedian(), LagMom3d.GetMean(), LagMom3d.GetMedian(),
1179      LagMom4d.GetMean(), LagMom4d.GetMedian(), LagMom7d.GetMean(), LagMom7d.GetMedian()), true);
1180    LagBCntH.GetKeyDatPrV(PrV); PrV.Sort(); GP.AddPlot(PrV, gpwLinesPoints, TStr::Fmt("%s. b:%d m:%d u:%d d:%d BLOG", Qt.GetStr().CStr(),
1181      Qt.GetFq(utBlog, *this), Qt.GetFq(utMedia, *this), Qt.GetUrls(), Qt.GetDoms(*this)));
1182    LagMCntH.GetKeyDatPrV(PrV); PrV.Sort(); GP.AddPlot(PrV, gpwLinesPoints, TStr::Fmt("%s. b:%d m:%d u:%d d:%d MEDIA", Qt.GetStr().CStr(),
1183      Qt.GetFq(utBlog, *this), Qt.GetFq(utMedia, *this), Qt.GetUrls(), Qt.GetDoms(*this)));
1184    GP.AddCmd("set xrange[-24:24]\nset mxtics 5\nset xtics 5");
1185    GP.SetXYLabel("media lag in hours (+: news lag, -: news lead)", "count");
1186    GP.SavePng(); }
1187    printf("\nTake top %d clusters. TmUnit: %s\n", TakeN, TTmInfo::GetTmUnitStr(TmUnit).CStr());
1188    printf("  1d:\tavg:\t%f\tmed:\t%f\n", LagMom1d.GetMean(), LagMom1d.GetMedian());
1189    printf("  2d:\tavg:\t%f\tmed:\t%f\n", LagMom2d.GetMean(), LagMom2d.GetMedian());
1190    printf("  3d:\tavg:\t%f\tmed:\t%f\n", LagMom3d.GetMean(), LagMom3d.GetMedian());
1191    printf("  4d:\tavg:\t%f\tmed:\t%f\n", LagMom4d.GetMean(), LagMom4d.GetMedian());
1192    printf("  7d:\tavg:\t%f\tmed:\t%f\n", LagMom7d.GetMean(), LagMom7d.GetMedian());
1193  }
1194  void TQuoteBs::PlotFqDecay(const TTmUnit& TmUnit, const bool& TakeClusters, const TUrlTy& CntUrlTy, const int& PlotN, const int& MinValsPerTm, const TStr& OutFNmPref) const {
1195    THash<TFlt, TMom> MomH;
1196    TQuote Qt;
1197    TIntV IdV;
1198    TGnuPlot GP("decay-"+OutFNmPref);
1199    if (TakeClusters) { GetCIdVByFq(IdV, 10, "", CntUrlTy, false); }
1200    else { GetQtIdVByFq(IdV, 8, 10, false, "", "", CntUrlTy); }
1201    for (int c = 0; c < PlotN; c++) {
1202      if (TakeClusters) { GetMergedClustQt(IdV[c], Qt, false); }
1203      else { Qt = GetQt(IdV[c]); }
1204      TQuote::TTmFltPrV QtV;  TFltPrV TmV;
1205      Qt.GetFqOt(QtV, TmUnit);
1206      int pos=0;  double val=0.0;
1207      for (int i = 0; i < QtV.Len(); i++) {
1208        if (val < QtV[i].Val2) { pos = i;  val = QtV[i].Val2; }
1209      }
1210      const double PeakVal = val;
1211      const TSecTm PeakTm = QtV[pos].Val1;
1212      for (int i = 0; i < QtV.Len(); i++) {
1213        TmV.Add(TFltPr((double(QtV[i].Val1)-double(PeakTm))/(24.0*3600), QtV[i].Val2/PeakVal));
1214        MomH.AddDat(TmV.Last().Val1).Add(TmV.Last().Val2);
1215      }
1216      const TStr Label = "";
1217    }
1218    TFltPrV AvgV, MedV;
1219    MomH.SortByKey();
1220    for (int i = 0; i < MomH.Len(); i++) {
1221      MomH[i].Def();
1222      if (MomH[i].GetVals()< MinValsPerTm) { printf("."); continue; }
1223      AvgV.Add(TFltPr(MomH.GetKey(i), MomH[i].GetMean()));
1224      MedV.Add(TFltPr(MomH.GetKey(i), MomH[i].GetMedian()));
1225    }
1226    GP.AddPlot(AvgV, gpwLines, "Average", "lt 2 lw 2");
1227    GP.AddPlot(MedV, gpwLines, TStr::Fmt("Median (last qt: %d %d %d)", Qt.GetFq(), Qt.GetUrls(), Qt.GetDoms(*this)), "lt 1 lw 2");
1228    GP.SetXYLabel("time [days]", "count");
1229    GP.AddCmd("set mxtics 6");
1230    GP.AddCmd("set xtics 1");
1231    GP.AddCmd("set yrange [0:1]");
1232    GP.AddCmd("set xrange [-5:5]");
1233    GP.AddCmd("set yzeroaxis lt -1");
1234    GP.SavePng();
1235  }
1236  void NormPeakAt1(THash<TInt, TFlt>& H) {
1237    double PeakFq=1;
1238    for (int i = 0; i < H.Len(); i++) {
1239      PeakFq=TMath::Mx((double)H[i], PeakFq); }
1240    for (int i = 0; i < H.Len(); i++) {
1241      H[i]/=PeakFq; }
1242  }
1243  void TQuoteBs::PlotBlogVsMediaFqOt(const TTmUnit& TmUnit, const bool& TakeClusters, int PlotN, const TStr& OutFNmPref) const {
1244    THash<TInt, TFlt> Peak1AllH, Peak2AllH, Peak3AllH;
1245    THash<TInt, TFlt> Peak1MedH, Peak2MedH, Peak3MedH;
1246    THash<TInt, TFlt> Peak1BlogH, Peak2BlogH, Peak3BlogH;
1247    TQuote Qt;
1248    TIntV IdV;
1249    TInt FqAtPeak;
1250    if (TakeClusters) { GetCIdVByFq(IdV, 100, "", utUndef, false); }
1251    else { GetQtIdVByFq(IdV, 8, 10, false, "", "", utUndef); }
1252    for (int c = 0; c < TMath::Mn(PlotN, IdV.Len()); c++) {
1253      if (TakeClusters) { GetMergedClustQt(IdV[c], Qt, false); }
1254      else { Qt = GetQt(IdV[c]); }
1255      if (! Qt.IsSinglePeak(TmUnit, TSecTm(0), utUndef, *this)) { PlotN++; printf("."); continue; }
1256      TQuote::TTmFltPrV AllFqV, BlogFqV, MedFqV;  TFltPrV TmV;
1257      const double Peak1 = Qt.GetPeakTm(TmUnit, TSecTm(1), FqAtPeak).GetAbsSecs(); 
1258      const double Peak2 = Qt.GetMeanTm(TmUnit, utUndef, *this).GetAbsSecs();    
1259      const double Peak3 = Qt.GetMedianTm(TmUnit, utUndef, *this).GetAbsSecs();  
1260      double PeakFq = FqAtPeak;
1261      Qt.GetFqOt(AllFqV, TmUnit, utUndef, *this);
1262      Qt.GetFqOt(MedFqV, TmUnit, utMedia, *this);
1263      Qt.GetFqOt(BlogFqV, TmUnit, utBlog, *this);
1264      PeakFq=1;
1265      for (int i = 0; i < MedFqV.Len(); i++) { PeakFq=TMath::Mx((double)MedFqV[i].Val2(), PeakFq); }
1266      for (int i = 0; i < MedFqV.Len(); i++) {
1267        const int T1 = (int) TMath::Round((double(MedFqV[i].Val1.GetAbsSecs())-Peak1)/(3600.0));
1268        const int T2 = (int) TMath::Round((double(MedFqV[i].Val1.GetAbsSecs())-Peak2)/(3600.0));
1269        const int T3 = (int) TMath::Round((double(MedFqV[i].Val1.GetAbsSecs())-Peak3)/(3600.0));
1270        Peak1MedH.AddDat(T1) += MedFqV[i].Val2/PeakFq;
1271        Peak2MedH.AddDat(T2) += MedFqV[i].Val2/PeakFq;
1272        Peak3MedH.AddDat(T3) += MedFqV[i].Val2/PeakFq;
1273      }
1274      PeakFq=1;
1275      for (int i = 0; i < BlogFqV.Len(); i++) { PeakFq=TMath::Mx((double)BlogFqV[i].Val2(), PeakFq); }
1276      for (int i = 0; i < BlogFqV.Len(); i++) {
1277        const int T1 = (int) TMath::Round((double(BlogFqV[i].Val1.GetAbsSecs())-Peak1)/(3600.0));
1278        const int T2 = (int) TMath::Round((double(BlogFqV[i].Val1.GetAbsSecs())-Peak2)/(3600.0));
1279        const int T3 = (int) TMath::Round((double(BlogFqV[i].Val1.GetAbsSecs())-Peak3)/(3600.0));
1280        Peak1BlogH.AddDat(T1) += BlogFqV[i].Val2/PeakFq;
1281        Peak2BlogH.AddDat(T2) += BlogFqV[i].Val2/PeakFq;
1282        Peak3BlogH.AddDat(T3) += BlogFqV[i].Val2/PeakFq;
1283      }
1284    }
1285    NormPeakAt1(Peak1AllH); NormPeakAt1(Peak2AllH); NormPeakAt1(Peak3AllH);
1286    NormPeakAt1(Peak1MedH); NormPeakAt1(Peak2MedH); NormPeakAt1(Peak3MedH);
1287    NormPeakAt1(Peak1BlogH); NormPeakAt1(Peak2BlogH); NormPeakAt1(Peak3BlogH);
1288    TGnuPlot::PlotValCntH(Peak1AllH, "ALL", Peak1MedH, "MEDIA", Peak1BlogH, "BLOG", "peakMax-"+OutFNmPref, "Max is the peak", "Time [h]", "Count (sum of frequencies of all quotes)");
1289    TGnuPlot::PlotValCntH(Peak3AllH, "ALL", Peak3MedH, "MEDIA", Peak3BlogH, "BLOG", "peakMed-"+OutFNmPref, "Median is the peak", "Time [h]", "Count (sum of frequencies of all quotes)");
1290  }
1291  void TQuoteBs::PlotBlogFracOt(const TTmUnit& TmUnit, const bool& TakeClusters, const int& PlotN, const TStr& OutFNmPref) const {
1292    TQuote Qt;
1293    TIntV IdV;
1294    THash<TFlt, TMom> TmMomH;
1295    THash<TFlt, TFltPr> TmBmH;
1296    if (TakeClusters) { GetCIdVByFq(IdV, 10, "", utUndef, false); }
1297    else { GetQtIdVByFq(IdV, 8, 10, false, "", "", utUndef); }
1298    for (int c = 0; c < PlotN; c++) {
1299      if (TakeClusters) { GetMergedClustQt(IdV[c], Qt, false); }
1300      else { Qt = GetQt(IdV[c]); }
1301      TQuote::TTmFltPrV MedQtV, BlgQtV;
1302      Qt.GetFqOt(MedQtV, TmUnit, utMedia, *this);
1303      Qt.GetFqOt(BlgQtV, TmUnit, utBlog, *this);
1304      TFltPrV FracV;
1305      const int PeakTm = Qt.GetPeakTm(TmUnit, TSecTm(1), utUndef, *this);
1306      for (int m=0, b=0; m < MedQtV.Len(); m++) {
1307        while (b<BlgQtV.Len() && BlgQtV[b].Val1 < MedQtV[m].Val1) { b++; }
1308        if (b<BlgQtV.Len() && BlgQtV[b].Val1 == MedQtV[m].Val1) {
1309          const double Tm = (int(MedQtV[m].Val1.Round(TmUnit))-PeakTm)/(24*3600.0);
1310            const double Frac = BlgQtV[b].Val2/double(BlgQtV[b].Val2+MedQtV[m].Val2);
1311            FracV.Add(TFltPr(Tm, Frac));
1312            TmMomH.AddDat(Tm).Add(Frac);
1313          TFltPr& BM = TmBmH.AddDat(Tm);
1314          BM.Val1+= BlgQtV[b].Val2;
1315          BM.Val2+= MedQtV[m].Val2;
1316        }
1317      }
1318    }
1319    { TFltPrV PrV;
1320    for (int b = 0; b < TmMomH.Len(); b++) {
1321      TmMomH[b].Def();
1322      PrV.Add(TFltPr(TmMomH.GetKey(b), TmMomH[b].GetMean())); }
1323    TGnuPlot GP(TStr::Fmt("fqFracA-%s", OutFNmPref.CStr()));
1324    PrV.Sort();  GP.AddPlot(PrV, gpwLinesPoints);
1325    GP.AddCmd("set xrange [-7:7]\nset yzeroaxis lt -1"); GP.SavePng(); }
1326    { TFltPrV PrV;
1327    for (int b = 0; b < TmMomH.Len(); b++) {
1328      PrV.Add(TFltPr(TmMomH.GetKey(b), TmMomH[b].GetMedian())); }
1329    TGnuPlot GP(TStr::Fmt("fqFracM-%s", OutFNmPref.CStr()));
1330    PrV.Sort();  GP.AddPlot(PrV, gpwLinesPoints);
1331    GP.AddCmd("set xrange [-7:7]\nset yzeroaxis lt -1"); GP.SavePng(); }
1332    { TFltPrV PrV;
1333    for (int b = 0; b < TmBmH.Len(); b++) {
1334      PrV.Add(TFltPr(TmBmH.GetKey(b), TmBmH[b].Val1/(TmBmH[b].Val1+TmBmH[b].Val2))); }
1335    TGnuPlot GP(TStr::Fmt("fqFracS-%s", OutFNmPref.CStr()));
1336    PrV.Sort(); GP.AddPlot(PrV, gpwLinesPoints);
1337    GP.AddCmd("set xrange [-7:7]\nset yzeroaxis lt -1"); GP.SavePng(); }
1338  }
1339  void TQuoteBs::PlotPopularityCnt(const bool& TakeClusters, const TUrlTy& UrlTy, const int& PlotN, const TStr& OutFNmPref) const {
1340    TIntV IdV;
1341    TIntH FqCntH;
1342    TQuote Qt;
1343    for (int c = 0; c < Len(); c++) {
1344      const TQuote& Qt = GetQtN(c);
1345      if (Qt.GetStr().IsStrIn("lipstick") && Qt.GetStr().IsStrIn("pig")) {
1346        FqCntH.AddDat(Qt.GetFq(UrlTy, *this)) += 1; }
1347    }
1348    TIntPrV FqCntV, CdfV;
1349    FqCntH.GetKeyDatPrV(FqCntV);  FqCntV.Sort();
1350    TGUtil::GetCCdf(FqCntV, CdfV);
1351    TGnuPlot::PlotValV(FqCntV, "pop-"+OutFNmPref, "", "total frequency", "count", gpsLog10XY);
1352    TGnuPlot::PlotValV(CdfV, "popCDF-"+OutFNmPref+"", "", "total frequency", "NCDF", gpsLog10XY);
1353  }
1354  void TQuoteBs::PlotEmptyY(const TTmUnit& TmUnit, const bool& TakeClusters, const int& PlotN, const TStr& OutFNmPref) const {
1355    TQuote Qt;
1356    TIntV IdV;
1357    THash<TInt, TInt> TmCumCntH;
1358    int MaxY=0;
1359    if (TakeClusters) { GetCIdVByFq(IdV, 10, "", utUndef, false); }
1360    else { GetQtIdVByFq(IdV, 8, 10, false, "", "", utUndef); }
1361    for (int c = 0; c < PlotN; c++) {
1362      if (TakeClusters) { GetMergedClustQt(IdV[c], Qt, false); }
1363      else { Qt = GetQt(IdV[c]); }
1364      TQuote::TTmFltPrV QtV;
1365      Qt.GetFqOt(QtV, TmUnit);
1366      for (int i = 0; i < QtV.Len(); i++) {
1367        const int Tm = QtV[i].Val1.Round(tmu1Hour)/3600;
1368        TInt& CumCnt = TmCumCntH.AddDat(Tm);
1369        CumCnt += (int) QtV[i].Val2;
1370        MaxY = TMath::Mx(CumCnt(), MaxY);
1371      }
1372    }
1373    TmCumCntH.SortByKey(true);
1374    const int BegHr = TmCumCntH.GetKey(0);
1375    THash<TFlt, TFlt> EmptyH;
1376    TFltPrV TmV;
1377    for (int t = 0; t < TmCumCntH.Len(); t++) {
1378      printf("%d  ", TmCumCntH[t]());
1379      for (int y = TmCumCntH[t]; y < MaxY; y+=1) {
1380        EmptyH.AddDat(y) += 1; }
1381      TmV.Add(TFltPr((TmCumCntH.GetKey(t)-BegHr)/24.0, TmCumCntH[t].Val));
1382    }
1383    EmptyH.SortByKey(false);
1384    TFltPrV EmptyV;
1385    EmptyV.Add(TFltPr(EmptyH.GetKey(0), EmptyH[0]));
1386    for (int i = 1; i < EmptyH.Len(); i++) {
1387      EmptyV.Add(TFltPr(EmptyH.GetKey(i), EmptyH[i]+EmptyV.Last().Val2));
1388    }
1389    TGnuPlot::PlotValCntH(EmptyH, "emptyF-"+OutFNmPref+"-d", "Amount of empty area above the cummulative query-frequency curve", "y value", "area at y");
1390    TGnuPlot::PlotValV(EmptyV, "emptyF-"+OutFNmPref+"-c", "Amount of empty area above the cummulative query-frequency curve", "y value", "area above y");
1391    TGnuPlot::PlotValV(TmV, "emptyF1"+OutFNmPref, "Cummulative query frequency over time", "time (days)", "frequency");
1392  }
1393  PNGraph TQuoteBs::GetQuotePostNet(const TStr& DatasetFNm) const {
1394    PNGraph Graph = TNGraph::New();
1395    for (TMemesDataLoader Memes(DatasetFNm); Memes.LoadNext(); ) {
1396      if (Memes.MemeV.Empty()) { continue; }
1397      if (! IsStr(Memes.PostUrlStr.CStr())) { continue; }
1398      const int SrcNId = GetStrId(Memes.PostUrlStr.CStr());
1399      for (int u = 0; u < Memes.LinkV.Len(); u++) {
1400        if (! IsStr(Memes.LinkV[u].CStr())) { continue; }
1401        const int DstNId = GetStrId(Memes.LinkV[u].CStr());
1402        if (! Graph->IsNode(SrcNId)) { Graph->AddNode(SrcNId); }
1403        if (! Graph->IsNode(DstNId)) { Graph->AddNode(DstNId); }
1404        Graph->AddEdge(SrcNId, DstNId);
1405      }
1406    }
1407    TSnap::PrintInfo(Graph);
1408    return Graph;
1409  }
1410  PQtDomNet TQuoteBs::GetQuoteDomNet(const PNGraph& PostGraph, const int& CId) const {
1411    TQuote Qt;  GetMergedClustQt(CId, Qt, false);
1412    PQtDomNet DomG = TQtDomNet::New();
1413    TIntSet UrlSet;
1414    for (int i = 0; i < Qt.GetTimes(); i++) { UrlSet.AddKey(Qt.GetUrlId(i)); }
1415    TStrSet DomH;
1416    for (int i = 0; i < Qt.GetTimes(); i++) {
1417      const int url = Qt.GetUrlId(i);
1418      if (! PostGraph->IsNode(url)) { continue; }
1419      const int dom = DomH.AddKey(TStrUtil::GetDomNm2(GetStr(url)));
1420      TNGraph::TNodeI NI = PostGraph->GetNI(url);
1421      for (int o = 0; o < NI.GetOutDeg(); o++) {
1422        if (! UrlSet.IsKey(NI.GetOutNId(o))) { continue; }
1423        const int url2 = NI.GetOutNId(o);
1424        const int dom2 = DomH.AddKey(TStrUtil::GetDomNm2(GetStr(url2)));
1425        if (dom==dom2) { continue; }
1426        if (! DomG->IsNode(dom)) {
1427          DomG->AddNode(dom, TPair<TStr, TInt>(DomH[dom], GetUrlTy(url))); }
1428        if (! DomG->IsNode(dom2)) {
1429          DomG->AddNode(dom2, TPair<TStr, TInt>(DomH[dom2], GetUrlTy(url2))); }
1430        if (DomG->IsEdge(dom, dom2)) {
1431          DomG->GetEDat(dom, dom2) += 1; }
1432        else {
1433          DomG->AddEdge(dom, dom2, 1); }
1434      }
1435    }
1436    return DomG;
1437  }
1438  void TQuoteBs::SaveQuotes(const int& MinQtFq, const TStr& OutFNm) const {
1439    TIntV QtIdV;
1440    GetQtIdVByFq(QtIdV, 0, MinQtFq);
1441    SaveQuotes(QtIdV, OutFNm);
1442  }
1443  void TQuoteBs::SaveQuotes(const TIntV& QtIdV, const TStr& OutFNm) const {
1444    TIntSet QtIdSet;
1445    FILE *F = fopen(OutFNm.CStr(), "wt");
1446    printf("saving %d quotes\n", QtIdV.Len());
1447    fprintf(F, "#Freq\tUrls\tDomains\tQuote\n");
1448    for (int q = 0; q < QtIdV.Len(); q++) {
1449      const int QtId = QtIdV[q];
1450      if (QtIdSet.IsKey(QtId)) { continue; } 
1451      QtIdSet.AddKey(QtId);
1452      const TQuote& Q = GetQt(QtId);
1453    fprintf(F, "%d\t%d\t%d\t%s\n", Q.GetFq(), Q.GetUrls(), Q.GetDoms(*this), Q.QtStr.CStr());
1454      if (Q.GetTy() == qtRoot || Q.GetTy() == qtCentr) { 
1455        IAssert(ClustQtIdVH.IsKey(Q.GetCId()));
1456        const TIntV& ClustV = ClustQtIdVH.GetDat(Q.GetCId());
1457        for (int i = 0; i < ClustV.Len(); i++) {
1458          const TQuote& Q1 = GetQt(ClustV[i]);
1459          fprintf(F, "\t[%d] %d=%d %s\t%d\t%d\t%d\n", TStrUtil::CountWords(Q1.QtStr.CStr()),
1460            ClustV[i](), Q1.GetCId(), Q1.QtStr.CStr(), Q1.GetFq(), Q1.GetUrls(), Q1.GetDoms(*this));
1461          QtIdSet.AddKey(ClustV[i]);
1462        }
1463      }
1464    }
1465    fclose(F);
1466  }
1467  void TQuoteBs::SaveClusters(const TStr& OutFNm, const bool& SkipUrls) const {
1468    TIntPrV FqCIdV;
1469    TIntH ClSzCntH, ClFqCntH;
1470    for (int c = 0; c < GetClusts(); c++) {
1471      const int CId = GetCId(c);
1472      if ( ! IsQtId(CId)) { printf("!!! %d:%d\n", c, CId); continue; }
1473      FqCIdV.Add(TIntPr(GetClustFq(CId), CId));
1474      ClSzCntH.AddDat(GetClust(CId).Len()) += 1;
1475      ClFqCntH.AddDat(GetClustFq(CId)) += 1;
1476    }
1477    TGnuPlot::PlotValCntH(ClSzCntH, OutFNm+"-clSz", TStr::Fmt("%d clusters", GetClusts()), "Number of quotes in the cluster", "Number of clusters", gpsLog);
1478    TGnuPlot::PlotValCntH(ClFqCntH, OutFNm+"-clFq", TStr::Fmt("%d clusters", GetClusts()), "Volume of quotes in the cluster", "Number of clusters", gpsLog, false, gpwLinesPoints, false, false);
1479    TGnuPlot::PlotValCntH(ClFqCntH, OutFNm+"-clFqB", TStr::Fmt("%d clusters", GetClusts()), "Volume of quotes in the cluster", "Number of clusters", gpsLog, false, gpwLinesPoints, false, true);
1480    FqCIdV.Sort(false);
1481    TIntPrV QtFqV;
1482    FILE *F = fopen(TStr::Fmt("%s-clust.txt", OutFNm.CStr()).CStr(), "wt");
1483    fprintf(F, "format:\n<ClSz>\t<TotFq>\t<Root>\t<ClusterId>\n");
1484    fprintf(F, "\t<QtFq>\t<Urls>\t<QtStr>\t<QuteId>\n");
1485    fprintf(F, "\t\t<Tm>\t<Fq>\t<UrlTy>\t<Url>\n\n");
1486    for (int c = 0; c < FqCIdV.Len(); c++) {
1487      const int CId = FqCIdV[c].Val2;
1488      const TIntV& ClustV = GetClust(CId);
1489      fprintf(F, "\n%d\t%d\t%s\t%d\n", ClustV.Len(), FqCIdV[c].Val1(), GetQt(CId).GetStr().CStr(), CId);
1490      QtFqV.Clr(false);
1491      for (int q = 0; q < ClustV.Len(); q++) {
1492        IAssert(IsQtId(ClustV[q]));
1493        QtFqV.Add(TIntPr(GetQt(ClustV[q]).GetUrls(), ClustV[q])); }
1494      QtFqV.Sort(false);
1495      for (int q = 0; q < QtFqV.Len(); q++) {
1496        IAssert(IsQtId(QtFqV[q].Val2));
1497        const TQuote& Qt = GetQt(QtFqV[q].Val2);
1498        if ((! SkipUrls) && q > 0) { fprintf(F, "\n"); }
1499        fprintf(F, "\t%d\t%d\t%s\t%d\n", Qt.GetFq(), Qt.GetUrls(), Qt.GetStr().CStr(), QtFqV[q].Val2());
1500        if (! SkipUrls) {
1501          for (int u = 0; u < Qt.GetUrls(); u++) {
1502            fprintf(F, "\t\t%s\t%d\t%s\t%s\n", Qt.TmUrlCntV[u].Tm().GetYmdTmStr().CStr(), Qt.TmUrlCntV[u].Cnt(),
1503              GetUrlTy(Qt.TmUrlCntV[u].UrlId())==utMedia?"M":"B", GetStr(Qt.TmUrlCntV[u].UrlId())); }
1504        }
1505      }
1506    }
1507    fclose(F);
1508  }
1509  void TQuoteBs::SaveClusters(const TIntV& QtIdV, const TStr& OutFNm, const bool& SkipUrls) const {
1510    FILE *F = fopen(TStr::Fmt("%s-clust.txt", OutFNm.CStr()).CStr(), "wt");
1511    fprintf(F, "format:\n<ClSz>\t<TotFq>\t<Root>\t<ClusterId>\n");
1512    fprintf(F, "\t<QtFq>\t<Urls>\t<QtStr>\t<QuteId>\n");
1513    fprintf(F, "\t\t<Tm>\t<Fq>\t<UrlTy>\t<Url>\n\n");
1514    for (int c = 0; c < QtIdV.Len(); c++) {
1515      int CId = QtIdV[c];
1516      if (! IsClust(CId)) { CId = GetQt(CId).GetCId(); }
1517      const TIntV& ClustV = GetClust(CId);
1518      fprintf(F, "\n%d\t%d\t%s\t%d\n", ClustV.Len(), GetClustFq(CId), GetQt(CId).GetStr().CStr(), CId);
1519      for (int q = 0; q < ClustV.Len(); q++) {
1520        const TQuote& Qt = GetQt(ClustV[q]);
1521        if ((! SkipUrls) && q > 0) { fprintf(F, "\n"); }
1522        fprintf(F, "\t%d\t%d\t%s\t%d\n", Qt.GetFq(), Qt.GetUrls(), Qt.GetStr().CStr(), ClustV[q]());
1523        if (! SkipUrls) {
1524          for (int u = 0; u < Qt.GetUrls(); u++) {
1525            fprintf(F, "\t\t%s\t%d\t%s\t%s\n", Qt.TmUrlCntV[u].Tm().GetYmdTmStr().CStr(), Qt.TmUrlCntV[u].Cnt(),
1526              GetUrlTy(Qt.TmUrlCntV[u].UrlId())==utMedia?"M":"B", GetStr(Qt.TmUrlCntV[u].UrlId())); }
1527        }
1528      }
1529    }
1530    fclose(F);
1531  }
1532  void TQuoteBs::SaveBigBlogMassQt(const TStr& OutFNm) const {
1533    const TTmUnit TmUnit = tmuDay;
1534    const bool TakeClusters = true;
1535    TIntV IdV;
1536    TQuote Qt;
1537    int Candidates=0;
1538    if (TakeClusters) { GetCIdVByFq(IdV, 10, "", utUndef, false); }
1539    else { GetQtIdVByFq(IdV, 8, 10, false, "", "", utUndef); }
1540    TVec<TPair<TFlt, TStr> > ScoreV;
1541    for (int c = 0; c < IdV.Len(); c++) {
1542      if (TakeClusters) { GetMergedClustQt(IdV[c], Qt, false); }
1543      else { Qt = GetQt(IdV[c]); }
1544      const int MediaPeak = Qt.GetPeakTm(TmUnit, TSecTm(1), utMedia, *this); 
1545      const double BlogFq = Qt.GetUrls(TSecTm(MediaPeak-21*24*3600), TSecTm(MediaPeak-7*24*3600), utBlog, *this);  
1546      const double TotFq = Qt.GetUrls();
1547      if (BlogFq < 10) { continue; }
1548      Candidates++;
1549      if (BlogFq < TotFq*0.15 || BlogFq > TotFq*0.75) { continue; }
1550      ScoreV.Add(TFltStrPr(TotFq, TStr::Fmt("%g\t%g\t%s", BlogFq, TotFq, Qt.GetStr().CStr())));
1551    }
1552    printf("Considered: %d quotes\n", IdV.Len());
1553    printf("            %d candidates\n", Candidates);
1554    printf("            %d selected\n", ScoreV.Len());
1555    ScoreV.Sort(false);
1556    FILE *F = fopen(TStr::Fmt("%s.txt", OutFNm.CStr()).CStr(), "wt");
1557    fprintf(F, "total %d items\n", IdV.Len());
1558    fprintf(F, "items above blog threshdolg %d\n", ScoreV.Len());
1559    fprintf(F, "counts are numbers of urls (not actually number of occurences)\n");
1560    fprintf(F, "\nblog\ttotal\tQuote\n");
1561    for (int i = 0; i < ScoreV.Len(); i++) {
1562      fprintf(F, "%s\n", ScoreV[i].Val2.CStr());
1563    }
1564    fclose(F);
1565  }
1566  void TQuoteBs::SaveForFlash(const TIntV& QtIdV, const TStr& OutFNm, const TTmUnit& TmUnit, int SaveN, const TSecTm& BegTm, const TSecTm& EndTm, const TUrlTy& OnlyCountTy) const {
1567    const int TmUnitSecs = TTmInfo::GetTmUnitSecs(TmUnit);
1568    TVec<TQuad<TFlt, TInt, TInt, TQuote::TTmFltPrV> > QtInfoV, QtInfoV2; 
1569    TQuote::TTmFltPrV FqV, SmoothFqV;
1570    TIntV VizQtIdV;
1571    if (SaveN == -1) { SaveN = TInt::Mx; }
1572    TSecTm MinTm=TSecTm(TInt::Mx-1), MaxTm=TSecTm(1);
1573    printf("Saving top %d out of %d quotes\n", SaveN, QtIdV.Len());
1574    THash<TInt, TIntPr> WeekPeakQtIdH; 
1575    for (int q = 0; q < QtIdV.Len() && QtInfoV2.Len() < (SaveN+100); q++) { 
1576      const TQuote& Qt = GetQt(QtIdV[q]);
1577      if (Qt.GetTy() == qtQuote) {
1578        Qt.GetFqOt(FqV, TmUnit, BegTm, EndTm, OnlyCountTy, *this);
1579        if (FqV.Empty()) { continue; }
1580        QtInfoV2.Add(TQuad<TFlt, TInt, TInt, TQuote::TTmFltPrV>((double)Qt.GetPeakTm(TmUnit, BegTm)+1e-6*Qt.GetUrls(), QtIdV[q], Qt.GetFq(), FqV));
1581        MinTm = TMath::Mn(MinTm, FqV[0].Val1);
1582        MaxTm = TMath::Mx(MaxTm, FqV.Last().Val1);
1583        VizQtIdV.Add(QtIdV[q]);
1584        TInt PeakFq;
1585        const int PeakTm = Qt.GetPeakTm(tmuWeek, BegTm, PeakFq).GetAbsSecs();
1586        if (! WeekPeakQtIdH.IsKey(PeakTm)) {
1587          WeekPeakQtIdH.AddDat(PeakTm, TIntPr(PeakFq, QtInfoV2.Len()-1)); }
1588        else if (WeekPeakQtIdH.GetDat(PeakTm).Val1<PeakFq) {
1589          WeekPeakQtIdH.AddDat(PeakTm, TIntPr(PeakFq, QtInfoV2.Len()-1)); }
1590      } else { 
1591        const int CId = Qt.GetCId();
1592        if (! ClustQtIdVH.IsKey(CId)) { continue; }
1593        const int CentrQtId = GetCentrQtId(CId);
1594        TQuote CentrQt;  GetMergedClustQt(CId, CentrQt, true);
1595        CentrQt.GetFqOt(FqV, TmUnit, BegTm, EndTm, OnlyCountTy, *this);
1596        if (FqV.Empty()) { continue; }
1597        QtInfoV2.Add(TQuad<TFlt, TInt, TInt, TQuote::TTmFltPrV>((double)CentrQt.GetPeakTm(TmUnit, BegTm)+1e-6*CentrQt.GetUrls(), CentrQtId, GetClustFq(CId), FqV));
1598        TInt PeakFq;
1599        const int PeakTm = CentrQt.GetPeakTm(tmuWeek, BegTm, PeakFq).GetAbsSecs();
1600        if (! WeekPeakQtIdH.IsKey(PeakTm)) {
1601          WeekPeakQtIdH.AddDat(PeakTm, TIntPr(PeakFq, QtInfoV2.Len()-1)); }
1602        else if (WeekPeakQtIdH.GetDat(PeakTm).Val1<PeakFq) {
1603          WeekPeakQtIdH.AddDat(PeakTm, TIntPr(PeakFq, QtInfoV2.Len()-1)); }
1604        MinTm = TMath::Mn(MinTm, FqV[0].Val1);
1605        MaxTm = TMath::Mx(MaxTm, FqV.Last().Val1);
1606        VizQtIdV.Add(CentrQtId);
1607      } /&bsol;*/
1608    }
1609    { TIntSet QtIdSet;
1610    for (int i = 0; i < WeekPeakQtIdH.Len(); i++) {
1611    }
1612    QtInfoV.Clr(true);
1613    for (int i = 0; i < TMath::Mn(SaveN, QtInfoV2.Len()); i++) {
1614      if (QtIdSet.IsKey(i)) { continue; }
1615      QtInfoV.Add(QtInfoV2[i]);
1616    printf("%d  ", (int) QtInfoV2[i].Val3()); 
1617      if (QtInfoV.Len() > SaveN) { break; }
1618    } } 
1619    THash<TSecTm, TIntFltH> TmCntH; 
1620    for (int i = 0; i < QtInfoV.Len(); i++) {
1621      const TQuote::TTmFltPrV& FqV = QtInfoV[i].Val4;
1622      for (int t = 0; t < FqV.Len(); t++) {
1623        TmCntH.AddDat(FqV[t].Val1).AddDat(i, FqV[t].Val2); }
1624    }
1625    for (int i = 0; i < TmCntH.Len(); i++) {
1626      TmCntH[i].SortByDat(false); }
1627    const int K = 10;
1628    const int Slack = 3*24*3600; 
1629    THash<TInt, TSecTm> QtLastTopH; 
1630    for (int i = 0; i < TmCntH.Len(); i++) {
1631      TIntFltH& TmH = TmCntH[i];
1632      for (int j = 0; j < TMath::Mn(K, TmH.Len()); j++) {
1633        QtLastTopH.AddDat(TmH.GetKey(j), TmCntH.GetKey(i));
1634      }
1635    }
1636    for (int i = 0; i < QtInfoV.Len(); i++) {
1637      TQuote::TTmFltPrV& FqV = QtInfoV[i].Val4;
1638      const TSecTm LastTime = QtLastTopH.GetDat(i);
1639      int x = 0; for (x = 0; x < FqV.Len() && FqV[x].Val1 <= LastTime+Slack; x++) { }
1640      if (x < FqV.Len()) { FqV.Del(x, FqV.Len()-1); }
1641    } 
1642    printf("save from %d quotes\n", QtInfoV.Len());
1643    QtInfoV.Sort();
1644    TIntH QtIdUrlH;  GetQtPageUrl(VizQtIdV, QtIdUrlH);
1645    FILE *F = fopen(TStr::Fmt("qtOt-%sQ.tab", OutFNm.CStr()).CStr(), "wt");
1646    fprintf(F, "QuoteId\tQuote\tUrl\tTotalVol\n");
1647    for (int i = 0; i < TMath::Mn(SaveN, QtInfoV.Len()); i++) {
1648      fprintf(F, "%d\t%s\t%s\t%d\n", SaveN-i, GetQt(QtInfoV[i].Val2).QtStr.CStr(), GetStr(QtIdUrlH.GetDat(QtInfoV[i].Val2)), (int) QtInfoV[i].Val3);
1649    }
1650    fclose(F);
1651    printf("saveT\n");
1652    F = fopen(TStr::Fmt("qtOt-%sT.tab", OutFNm.CStr()).CStr(), "wt");
1653    fprintf(F, "Time\tQuoteId\tSmoothFreq\tRawFreq\n");
1654    for (int i = 0; i < TMath::Mn(SaveN, QtInfoV.Len()); i++) {
1655      const TQuote::TTmFltPrV RawFqV = QtInfoV[i].Val4;
1656      TQuote::GetSmoothFqOt(SmoothFqV, RawFqV, TmUnit, 6*24*3600/TmUnitSecs, 1.05, MinTm, MaxTm);  
1657      IAssert(SmoothFqV.Len() >= RawFqV.Len());
1658      for (int d=0, ds = 0; ds < SmoothFqV.Len(); ds++) {
1659        if (TmUnit == tmuDay) { fprintf(F, "%s", SmoothFqV[ds].Val1.GetDtYmdStr().CStr()); }
1660        else { fprintf(F, "%s_%02d", SmoothFqV[ds].Val1.GetDtYmdStr().CStr(), SmoothFqV[ds].Val1.GetHourN()); }
1661        fprintf(F, "\t%d\t%.2f", SaveN-i, SmoothFqV[ds].Val2());
1662        if (d < RawFqV.Len() && SmoothFqV[ds].Val1 == RawFqV[d].Val1) { fprintf(F, "\t%.0f", RawFqV[d].Val2()); d++; } else { fprintf(F, "\t0"); }
1663        fprintf(F, "\n");
1664      }
1665    }
1666    fclose(F);
1667    printf("done.\n");
1668  }
1669  void TQuoteBs::SaveDomainStat(const TStr& OutFNm, const int& MinCnt) const {
1670    THash<TInt, TInt> MedOt, BlogOt, AllOt;
1671    int MedCnt=0, BlogCnt=0, AllCnt=0;
1672    TSecTm BegTm(2008,7,31,0,0,0);
1673    THash<TStr, TIntPr> DomCntH;
1674    for (int q = 0; q < QuoteH.Len(); q++) {
1675      const TQuote& Q = QuoteH[q];
1676      for (int u = 0; u < Q.GetUrls(); u++) {
1677        const int Day = TSecTm(Q.GetTm(u)-BegTm).GetInUnits(tmuDay);
1678        AllOt.AddDat(Day) += 1;  AllCnt++;
1679        if (GetUrlTy(Q.GetUrlId(u)) ==  utMedia) { MedOt.AddDat(Day) += 1;  MedCnt++;}
1680        else { BlogOt.AddDat(Day) += 1;  BlogCnt++; }
1681        TStr Dom = TStrUtil::GetDomNm2(GetStr(Q.GetUrlId(u)));
1682        DomCntH.AddDat(Dom).Val1 += 1;
1683        DomCntH.AddDat(Dom).Val2 += Q.GetCnt(u);
1684      }
1685    }
1686    TGnuPlot::PlotValCntH(AllOt, "ALL", MedOt, "MEDIA", BlogOt, "BLOGS", "overTm-"+OutFNm, TStr::Fmt("Quote freq over time: A:%d M:%d B:%d", AllCnt, MedCnt, BlogCnt),
1687      "Time [days]", "Number of quote mentions");
1688    DomCntH.SortByDat(false);
1689    FILE *F = fopen(TStr::Fmt("domains-%s.tab", OutFNm.CStr()).CStr(), "wt");
1690    fprintf(F, "# %d domains, total mentions:\tAll:%d\tMedia:%d\tBlogs:%d", DomCntH.Len(), AllCnt, MedCnt, BlogCnt);
1691    fprintf(F, "#Domain\tNumber of quotes mentioned\tNumber of mentions\n");
1692    for (int d = 0; d < DomCntH.Len(); d++) {
1693      fprintf(F, "%s\t%d\t%d\n", DomCntH.GetKey(d).CStr(), DomCntH[d].Val1(), DomCntH[d].Val2());
1694    }
1695    fclose(F);
1696  }
1697  void TQuoteBs::Dump(const bool& Fast) const {
1698    printf("Quote base:\n");
1699    if (! Fast) {
1700      TSecTm MinTm, MaxTm; GetMinMaxTm(MinTm, MaxTm);
1701      printf("  %s -- %s\n", MinTm.GetYmdTmStr().CStr(), MaxTm.GetYmdTmStr().CStr());
1702      int totCnt=0, totVol=0;
1703      for (int q = 0; q < QuoteH.Len(); q++) {
1704        const TQuote::TTmUrlCntV& V = QuoteH[q].TmUrlCntV;
1705        totCnt += V.Len();
1706        for (int u = 0; u < V.Len(); u++) {
1707          totVol += V[u].Cnt();
1708        }
1709      }
1710      printf("  %d number of posts mentioning quotes\n", totCnt);
1711      printf("  %d number of mentions\n", totVol);
1712    }
1713    printf("  %d quotes\n", Len());
1714    printf("  %d strings (quotes+urls, no domains)\n", StrQtIdH.Len());
1715    printf("  %d clusters\n", ClustQtIdVH.Len());
1716    printf("  %d quotes in clusters\n", GetQtsInClust());
1717    printf("  %d urls with type\n\n", UrlTyH.Len());
1718  }
1719  PQuoteBs TQuoteBs::FindQtInTxtQBs(const TStr& InBinFNmWc, const TStrV& QuoteStrV) {
1720    THashSet<TMd5Sig> SeenUrlH; 
1721    PQuoteBs QtBsPt = TQuoteBs::New();
1722    TQuoteBs& QtBs = *QtBsPt;
1723    TStrHash<TInt> StrH;
1724    TVec<TIntV> QtWIdVV;
1725    TVec<TIntV> QtSkipLenVV; 
1726    for (int q = 0; q < QuoteStrV.Len(); q++) {
1727      const int QId = QtBs.QuoteH.Len(); 
1728      TQuote& Qt = QtBs.QuoteH.AddDat(QId);
1729      Qt.QtCIdTy = TQuote::TQtIdTy(QId, qtQuote);
1730      Qt.QtStr = QuoteStrV[q];
1731      QtWIdVV.Add();  QtSkipLenVV.Add();
1732      TStrUtil::GetAddWIdV(StrH, QuoteStrV[q].CStr(), QtWIdVV.Last());
1733      TIntV& WIdV = QtWIdVV.Last();
1734      TIntV& SkipV = QtSkipLenVV.Last();
1735      SkipV.Add(1);
1736      for (int w = 1; w < WIdV.Len(); w++) {
1737        int skipLen = 1;
1738        while (w-skipLen >= 0 && WIdV[w-skipLen] != WIdV[w]) { skipLen++; }
1739        SkipV.Add(skipLen);
1740      }
1741    }
1742    TInt WId;
1743    TIntV TxtWIdV;
1744    TVec<char *> WrdV;
1745    TQuoteLoader QL(InBinFNmWc);
1746    while (QL.Next()) {
1747      if (SeenUrlH.IsKey(TMd5Sig(QL.PostUrlStr))) { continue; }
1748      SeenUrlH.AddKey(TMd5Sig(QL.PostUrlStr));
1749      TxtWIdV.Clr();  WrdV.Clr(false);
1750      { TStrUtil::SplitWords(QL.ContentStr, WrdV);
1751      for (int w = 0; w < WrdV.Len(); w++) {
1752        if (StrH.IsKeyGetDat(WrdV[w], WId)) { TxtWIdV.Add(WId); }
1753        else if (TxtWIdV.Len()>0 && TxtWIdV.Last()!=-1) { TxtWIdV.Add(-1); }
1754      } }
1755      for (int q = 0; q < QtWIdVV.Len(); q++) {
1756        const TIntV& QWIdV = QtWIdVV[q];
1757        const TIntV& SkipV = QtSkipLenVV[q];
1758        int cnt = 0;
1759        for (int w = 0; w < TxtWIdV.Len()-QWIdV.Len(); ) {
1760          int len = 0;
1761          while (len < QWIdV.Len() && TxtWIdV[w+len] == QWIdV[len]) { len++; }
1762          if (len == QWIdV.Len()) { cnt+=1;  w+=len; }
1763          else { w += SkipV[len]; }
1764        }
1765        if (cnt > 0) {
1766          QtBs.GetQtN(q).TmUrlCntV.Add(TQuote::TTmUrlCnt(QL.PubTm, QtBs.AddStr(QL.PostUrlStr), cnt));
1767          if (cnt > 255) { printf("*"); }
1768        }
1769      }
1770    }
1771    for (int i = 0; i < QtBs.Len(); i++) { QtBs.QuoteH[i].TmUrlCntV.Sort(); }
1772    return QtBsPt;
1773  }
1774  #ifdef false
1775  void TQuoteBs::BuildQtSubSeqCounts(TIntV& QtIdV, const TStr& OutFNm) {
1776  }
1777  void TQuoteBs::PlotQtFqOverTm(const TIntV& QtIdV, const TStr& OutFNm, int PlotN) const {
1778    TSecTm MinTm, MaxTm;  GetMinMaxTm(MinTm, MaxTm);
1779    TGnuPlot GP("fqOT."+OutFNm);
1780    TFltPrV HrFqV;
1781    if (PlotN == -1) { PlotN = TInt::Mx; }
1782    for (int i = 0; i < TMath::Mn(PlotN, QtIdV.Len()); i++) {
1783      const TQuote& Qt = GetQt(QtIdV[i]);
1784      Qt.GetSmoothFqOverTm(HrFqV, tmu1Hour, MinTm, 12, 1.2);
1785      for (int h = 0; h < HrFqV.Len(); h++) {
1786        HrFqV[h].Val1 = TMath::Round(HrFqV[h].Val1/24.0, 2);
1787      }
1788      GP.AddPlot(HrFqV, gpwLines, TStrUtil::GetShorStr(Qt.QtStr), "lt 1");
1789    }
1790    GP.SetXYLabel("Time [days]", "Frequency");
1791    GP.AddCmd("set nokey");
1792    GP.SavePng("fqOT."+OutFNm+".png", -1, -1, "", "set terminal png small size 3000,600");
1793    GP.AddCmd("set size 2,0.5");
1794    GP.SaveEps(10);
1795  }
1796  void TQuoteBs::PlotQtCumFqOverTm(const TIntV& QtIdV, const TStr& OutFNm, int PlotN) const {
1797    const int TmuSecs = TTmInfo::GetTmUnitSecs(tmu1Hour);
1798    TSecTm MinTm, MaxTm;  GetMinMaxTm(MinTm, MaxTm);
1799    const TSecTm StartTm = MinTm.Round(tmu1Hour);
1800    const TSecTm EndTm = MaxTm.Round(tmu1Hour);
1801    TQuote::TTmFltPrV HrFqV;
1802    TFltFltH SumCntH;
1803    for (TSecTm Tm = StartTm; Tm <= MaxTm.Round(tmu1Hour); Tm += TmuSecs) {
1804      SumCntH.AddDat(double(Tm-StartTm)/(24.0*3600.0)) = 0;
1805    }
1806    TGnuPlot GP("cfqOT."+OutFNm);
1807    if (PlotN == -1) { PlotN = TInt::Mx; }
1808    for (int i = 0; i < TMath::Mn(PlotN, QtIdV.Len()); i++) {
1809      const TQuote& Qt = GetQt(QtIdV[i]);
1810      Qt.GetSmoothFqOverTm(HrFqV, tmu1Hour, 48, 1.2);
1811      for (int h = 0; h < HrFqV.Len(); h++) {
1812        const TSecTm roundTm = HrFqV[h].Val1.Round(tmu1Hour);
1813        if (roundTm >= StartTm && roundTm<=EndTm) {
1814          SumCntH.AddDat(double(roundTm-StartTm)/(24.0*3600.0)) += HrFqV[h].Val2;
1815        }
1816      }
1817      GP.AddPlot(SumCntH, gpwLines, TStrUtil::GetShorStr(Qt.QtStr, 100).CStr());
1818    }
1819    GP.SetXYLabel(TStr::Fmt("Time [days] since %s", StartTm.GetYmdTmStr().CStr()), "Stacked frequency");
1820    GP.AddCmd("set notitle");
1821    GP.AddCmd("set nogrid");
1822    GP.AddCmd("set mxtics 4");
1823    GP.SavePng("cfqOT."+OutFNm+".png", -1, -1, "", "set terminal png small size 1000,600");
1824  }
1825  void TQuoteBs::PlotQtCumFqOverTm1(const TIntV& QtIdV, const TStr& OutFNm, int PlotN) const {
1826    TSecTm MinTm, MaxTm;  GetMinMaxTm(MinTm, MaxTm);
1827    TGnuPlot GP("cfqOT."+OutFNm);
1828    TFltPrV HrFqV, HrCFqV;
1829    TFltFltH SumCntH;
1830    if (PlotN == -1) { PlotN = TInt::Mx; }
1831    for (int i = 0; i < TMath::Mn(PlotN, QtIdV.Len()); i++) {
1832      const TQuote& Qt = GetQt(QtIdV[i]);
1833      Qt.GetSmoothFqOverTm(HrFqV, tmu1Hour, MinTm, 12, 1.2);
1834      HrCFqV.Clr(false);
1835      for (int h = 0; h < HrFqV.Len(); h++) {
1836        const double hr = TMath::Round(HrFqV[h].Val1/24.0+0.001, 2);
1837        SumCntH.AddDat(hr) += HrFqV[h].Val2;
1838      }
1839      GP.AddPlot(SumCntH, gpwLines, TStrUtil::GetShorStr(Qt.QtStr).CStr(), "lt 1");
1840    }
1841    GP.SetXYLabel("Time [days]", "Stacked frequency");
1842    GP.AddCmd("set nokey");
1843    GP.AddCmd("set notitle");
1844    GP.AddCmd("set nogrid");
1845    GP.AddCmd("set mxtics 5");
1846    GP.AddCmd("set xtics 5");
1847    GP.SavePng("cfqOT."+OutFNm+".png", -1, -1, "", "set terminal png small size 3000,600");
1848    GP.AddCmd("set size 2,0.5");
1849    GP.SaveEps(8);
1850  }
1851  void TQuoteBs::SaveForMatlab(const TIntV& QtIdV, const TStr& OutFNm, int SaveN) const {
1852    const TTmUnit TmUnit = tmu1Hour;
1853    TSecTm MinTm, MaxTm;  GetMinMaxTm(MinTm, MaxTm);
1854    THash<TInt, TFlt> TmCntH;
1855    TVec<TFltV> TmQtFqV;
1856    const int MinTmUnit = MinTm.GetInUnits(TmUnit);
1857    for (uint i = MinTmUnit; i <= MaxTm.GetInUnits(TmUnit); i++) {
1858      TmCntH.AddDat(i, 0);  TmQtFqV.Add();
1859      TmQtFqV.Last().Add(i-MinTmUnit+1); 
1860    }
1861    TQuote::TTmFltPrV DayFqV;
1862    if (SaveN == -1) { SaveN = TInt::Mx; }
1863    for (int i = 0; i < TMath::Mn(SaveN, QtIdV.Len()); i++) {
1864      const TQuote& Qt = GetQt(QtIdV[i]);
1865      Qt.GetSmoothFqOverTm(DayFqV, TmUnit, 48, 1.2);
1866      for (int d = 0; d < TmCntH.Len(); d++) { TmCntH[d] = 0; }
1867      for (int d = 0; d < DayFqV.Len(); d++) {
1868        const int T = DayFqV[d].Val1.GetInUnits(TmUnit);
1869        if (TmCntH.IsKey(T)) {
1870          TmCntH.AddDat(T) += DayFqV[d].Val2; }
1871      }
1872      for (int d = 0; d < TmCntH.Len(); d++) {
1873        TmQtFqV[d].Add(TmCntH[d]); }
1874    }
1875    FILE *F = fopen(TStr::Fmt("qtFqOtMATLAB-%s.tab", OutFNm.CStr()).CStr(), "wt");
1876    for (int d = 0; d < TmQtFqV.Len(); d++) {
1877      fprintf(F, "%g", TmQtFqV[d][0]());
1878      for (int q = 1; q < TmQtFqV[d].Len(); q++) {
1879        fprintf(F, "\t%g", TmQtFqV[d][q]()); }
1880      fprintf(F, "\n");
1881    }
1882    fclose(F);
1883  }
1884  void TQuoteBs::SaveQtTmUrlTxt(const TIntV& QtIdV, const TStr& OutFNm, int SaveN) const {
1885    if (SaveN == -1) { SaveN = TInt::Mx; }
1886    SaveN = TMath::Mn(SaveN, QtIdV.Len());
1887    FILE *F = fopen(OutFNm.CStr(), "wt");
1888    for (int q = 0; q < QtIdV.Len(); q++) {
1889      const TQuote& Qt = GetQt(QtIdV[q]);
1890      fprintf(F, "%s\t%d\n", Qt.QtStr.CStr(), Qt.GetFq());
1891      for (int u = 0; u < Qt.GetUrls(); u++) {
1892        fprintf(F, "\t%s\t%s\n", Qt.TmUrlCntV[u].Val1.GetYmdTmStr().CStr(), GetStr(Qt.TmUrlCntV[u].Val2));
1893      }
1894      fprintf(F, "\n");
1895    }
1896    fclose(F);
1897  }
1898  void TQuoteBs::PlotSubQtOverTm(const int& QtId, const TStr& OutFNm) const {
1899    TIntV PlotQtV;
1900    const TQuote Qt = GetQt(QtId);
1901    PlotQtV.Add(QtId);
1902    TIntV WrdBegV; WrdBegV.Add(0);
1903    for (int i = 1; i < Qt.QtStr.Len()-1; i++) {
1904      if (TCh::IsAlNum(Qt.QtStr.GetCh(i)) && TCh::IsWs(Qt.QtStr.GetCh(i-1))) { WrdBegV.Add(i); }
1905    }
1906    TInt subQtId;
1907    WrdBegV.Add(Qt.QtStr.Len()+1); 
1908    const int QtWords = TStrUtil::CountWords(Qt.QtStr.CStr());
1909    for (int WndSz = 5; WndSz < QtWords; WndSz++) {
1910      for (int word = 0; word < QtWords-WndSz; word++) {
1911        const TStr SubQtStr = Qt.QtStr.GetSubStr(WrdBegV[word], WrdBegV[word+WndSz]-2);
1912        if (StrH.IsKeyGetDat(SubQtStr, subQtId) && QuoteH.IsKey(subQtId) && subQtId!=QtId) { PlotQtV.Add(subQtId); printf("."); }
1913      }
1914    }
1915    TGnuPlot GP(OutFNm, TStr::Fmt("%d occurences, %d urls, %d domains: %s", Qt.GetFq(), Qt.GetUrls(), Qt.GetDoms(), Qt.QtStr.CStr()));
1916    TFltPrV HrFqV;
1917    for (int i = 0; i < PlotQtV.Len(); i++) {
1918      const TQuote& subQt = QuoteH.GetDat(PlotQtV[i]);
1919      subQt.GetSmoothFqOverTm(HrFqV, tmu1Hour);
1920      GP.AddPlot(HrFqV, gpwLines, subQt.QtStr.CStr());
1921    }
1922    GP.SetXYLabel("Time [hours]", "Frequency");
1923    GP.SavePng(OutFNm+".png", -1, -1, "", "set terminal png small size 1000,800");
1924  }
1925  void TQuoteBs::PlotTopQuotesOverTm(const int& StepSecs, const int& IntervalSecs, const int& TakeNPerStep, const TStr& OutFNm) const {
1926    TSecTm MinTm, MaxTm;  GetMinMaxTm(MinTm, MaxTm);
1927    printf("Dataset span %s -- %s\n", MinTm.GetStr().CStr(), MaxTm.GetStr().CStr());
1928    TIntSet TopQtIdSet;
1929    int cnt=0;
1930    TIntV TopQtIdV;
1931    for (TSecTm Tm(MinTm); Tm < MaxTm; Tm += StepSecs, cnt++) {
1932      FailR("TopQuotesOverTm: take top quotes from each day");
1933      for (int q = 0; q < TopQtIdV.Len(); q++) { TopQtIdSet.AddKey(TopQtIdV[q]); }
1934    }
1935    printf("\n%d time steps total, %d quotes per step: %d total quotes\n", cnt, TakeNPerStep, TopQtIdSet.Len());
1936    printf("%s   %d\n", MinTm.Round(tmuDay).GetStr().CStr(), MinTm.Round(tmuDay).GetInUnits(tmu1Hour));
1937    TFltPrV FqOverTm;
1938    TGnuPlot GP(TStr("topQtOverTm.")+OutFNm, "");
1939    TFOut FOut(OutFNm+TStr(".Quote"));
1940    for (int q = 0; q < TopQtIdSet.Len(); q++) {
1941      const TQuote& Q = QuoteH.GetDat(TopQtIdSet[q]);
1942      Q.Save(FOut);
1943      Q.GetSmoothFqOverTm(FqOverTm, tmu1Hour, MinTm.Round(tmuDay));
1944      GP.AddPlot(FqOverTm, gpwLines, Q.QtStr);
1945    }
1946    GP.AddCmd("set xtics 24"); GP.AddCmd("set mxtics 4");
1947    GP.SetXYLabel(TStr("time [hours] from "+MinTm.Round(tmuDay).GetStr()), "frequency");
1948    GP.SavePng(TStr("topQtOverTm.")+OutFNm+TStr(".png"), -1, -1, "", "set terminal png small size 2000,800");
1949  }
1950  PQuoteBs TQuoteBs::BuildQuoteBs(const TStr& InBinFNmWc, const int& MinQtWrdLen) {
1951    PQuoteBs QBsPt = TQuoteBs::New(InBinFNmWc);
1952    QBsPt->AddToQuoteBs(InBinFNmWc, MinQtWrdLen);
1953    return QBsPt;
1954  }
1955  #endif
1956  PClustNet TClustNet::GetSubGraph(const TIntV& NIdV) const {
1957    PClustNet NewNetPt = TClustNet::New();
1958    TClustNet& NewNet = *NewNetPt;
1959    NewNet.Reserve(NIdV.Len(), -1);
1960    int node, edge;
1961    TClustNet::TNodeI NI;
1962    for (node = 0; node < NIdV.Len(); node++) {
1963      NewNet.AddNode(NIdV[node], GetNDat(NIdV[node])); 
1964    }
1965    for (node = 0; node < NIdV.Len(); node++) {
1966      NI = GetNI(NIdV[node]);
1967      const int SrcNId = NI.GetId();
1968      for (edge = 0; edge < NI.GetOutDeg(); edge++) {
1969        const int OutNId = NI.GetOutNId(edge);
1970        if (NewNet.IsNode(OutNId)) {
1971          NewNet.AddEdge(SrcNId, OutNId); }
1972      }
1973    }
1974    NewNet.Defrag();
1975    return NewNetPt;
1976  }
1977  void TClustNet::AddLink(const TQuote& SrcQt, const TQuote& DstQt) {
1978    const int Qt1Id = SrcQt.GetCId();
1979    const int Qt2Id = DstQt.GetCId();
1980    if (! IsNode(Qt1Id)) {
1981      AddNode(Qt1Id, SrcQt); }
1982    if (! IsNode(Qt2Id)) {
1983      AddNode(Qt2Id, DstQt); }
1984    if (! IsEdge(Qt2Id, Qt1Id)) {
1985      AddEdge(Qt1Id, Qt2Id);
1986    }
1987  }
1988  PClustNet TClustNet::GetSubGraph(const int& MinQtWords, const int& MaxQtWords, const int& MinFq) const {
1989    TIntV NIdV;
1990    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
1991      const int Wrds = TStrUtil::CountWords(NI().GetStr().CStr());
1992      if (NI().GetFq() >= MinFq &&  Wrds >= MinQtWords && Wrds <= MaxQtWords) {
1993        NIdV.Add(NI.GetId()); }
1994    }
1995    return GetSubGraph(NIdV);
1996  }
1997  void TClustNet::RecalcEdges(const double& MinOverlapFrac) {
1998    printf("Recalculating edges...\n");
1999    TIntPrV DelEdgeV;
2000    TStrHash<TInt> StrH(Mega(1), true);
2001    int WIdV1Start, WIdV2Start, SkipTy;
2002    TIntV WIdV1, WIdV2;
2003    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
2004      const TStr Q1 = NI().GetStr();
2005      TStrUtil::GetAddWIdV(StrH, Q1.CStr(), WIdV1);
2006      for (int e = 0; e < NI.GetOutDeg(); e++) {
2007        const TStr Q2 = NI.GetOutNDat(e).GetStr();
<span onclick='openModal()' class='match'>2008        TStrUtil::GetAddWIdV(StrH, Q2.CStr(), WIdV2);
2009        const int Overlap = TQuoteBs::LongestCmnSubSq(WIdV1, WIdV2, WIdV1Start, WIdV2Start, SkipTy);
</span>2010        const int ShortLen = TMath::Mn(WIdV1.Len(), WIdV2.Len());
2011        const int LongLen = TMath::Mx(WIdV1.Len(), WIdV2.Len());
2012        IAssert(Overlap<=ShortLen);
2013        if (2*ShortLen>LongLen && Overlap/double(ShortLen) > MinOverlapFrac) { continue; }
2014        DelEdgeV.Add(TIntPr(NI.GetId(), NI.GetOutNId(e)));
2015      }
2016    }
2017    printf("Deleting %d/%d (%.4f) edges\n", DelEdgeV.Len(), GetEdges(), DelEdgeV.Len()/double(GetEdges()));
2018    for (int i = 0; i < DelEdgeV.Len(); i++) {
2019      DelEdge(DelEdgeV[i].Val1, DelEdgeV[i].Val2);
2020    }
2021  }
2022  void TClustNet::MakeClusters(const TIntPrV& KeepEdgeV) {
2023    PUNGraph G = TUNGraph::New();
2024    for (int e = 0; e < KeepEdgeV.Len(); e++) {
2025      if (! G->IsNode(KeepEdgeV[e].Val1)) {
2026        G->AddNode(KeepEdgeV[e].Val1); }
2027      if (! G->IsNode(KeepEdgeV[e].Val2)) {
2028        G->AddNode(KeepEdgeV[e].Val2); }
2029      G->AddEdge(KeepEdgeV[e].Val1, KeepEdgeV[e].Val2);
2030    }
2031    TCnComV CnComV;
2032    TSnap::GetWccs(G, CnComV);
2033    TIntH NIdCcIdH(GetNodes());
2034    for (int c = 0; c < CnComV.Len(); c++) {
2035      const TIntV& NIdV = CnComV[c].NIdV;
2036      for (int n = 0; n < NIdV.Len(); n++) {
2037        NIdCcIdH.AddDat(NIdV[n], c);
2038      }
2039    }
2040    TIntPrV DelEdgeV;
2041    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
2042      const int ccid1 = NIdCcIdH.IsKey(EI.GetSrcNId()) ? NIdCcIdH.GetDat(EI.GetSrcNId()).Val : -1;
2043      const int ccid2 = NIdCcIdH.IsKey(EI.GetDstNId()) ? NIdCcIdH.GetDat(EI.GetDstNId()).Val : -1;
2044      if (ccid1 != ccid2 && ccid1!=-1 && ccid2!=-1) {
2045        DelEdgeV.Add(TIntPr(EI.GetSrcNId(), EI.GetDstNId())); }
2046    }
2047    const int Edges = GetEdges();
2048    printf("Deleting %d out of %d  (%f) edges\n", DelEdgeV.Len(), Edges, DelEdgeV.Len()/double(Edges));
2049    for (int d = 0; d < DelEdgeV.Len(); d++) {
2050      DelEdge(DelEdgeV[d].Val1, DelEdgeV[d].Val2);
2051    }
2052  }
2053  void TClustNet::KeepOnlyTree(const TIntPrV& KeepEdgeV) {
2054    TIntPrSet EdgeSet(KeepEdgeV.Len());
2055    for (int i = 0; i < KeepEdgeV.Len(); i++) {
2056      EdgeSet.AddKey(TIntPr(TMath::Mn(KeepEdgeV[i].Val1, KeepEdgeV[i].Val2),
2057        TMath::Mx(KeepEdgeV[i].Val1, KeepEdgeV[i].Val2)));
2058    }
2059    TIntPrSet DelEdgeV;
2060    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
2061      const int N1 = TMath::Mn(EI.GetSrcNId(), EI.GetDstNId());
2062      const int N2 = TMath::Mx(EI.GetSrcNId(), EI.GetDstNId());
2063      if (! EdgeSet.IsKey(TIntPr(N1, N2))) {
2064        DelEdgeV.AddKey(TIntPr(N1, N2)); }
2065    }
2066    printf("deleting %d edges\n", DelEdgeV.Len());
2067    for (int d = 0; d < DelEdgeV.Len(); d++) {
2068      DelEdge(DelEdgeV[d].Val1, DelEdgeV[d].Val2);
2069    }
2070  }
2071  void TClustNet::GetClusters(TVec<TIntV>& QtNIdV) const {
2072    TCnComV CnComV;
2073    TSnap::GetWccs(GetThis(), CnComV);
2074    CnComV.Sort(false);
2075    QtNIdV.Clr(false);
2076    TIntSet SeenSet;
2077    for (int i = 0; i < CnComV.Len(); i++) {
2078      for (int n = 0; n < CnComV[i].NIdV.Len(); n++) {
2079        IAssert(! SeenSet.IsKey(CnComV[i].NIdV[n]));
2080        SeenSet.AddKey(CnComV[i].NIdV[n]);
2081      }
2082      QtNIdV.Add(CnComV[i].NIdV);
2083    }
2084  }
2085  void TClustNet::GetMergedClustQt(const TIntV& QtIdV, TQuote& NewQt) const {
2086    int CentrQtId=-1, MxFq=0;
2087    THash<TPair<TSecTm, TInt>, TInt> TmUrlCntH;
2088    for (int c = 0; c < QtIdV.Len(); c++) {
2089      const TQuote& Q = GetNDat(QtIdV[c]);
2090      IAssert(Q.GetId() == QtIdV[c]);
2091      for (int t = 0; t < Q.GetTimes(); t++) {
2092        TmUrlCntH.AddDat(TPair<TSecTm, TInt>(Q.GetTm(t), Q.GetUrlId(t))) += Q.GetCnt(t);
2093      }
2094      if (MxFq < Q.GetFq()) {
2095        MxFq = Q.GetFq();
2096        CentrQtId = Q.GetId();
2097      }
2098    }
2099    NewQt.QtCIdTy = TQuote::TQtIdTy(-1, qtCentr);
2100    NewQt.QtStr = GetNDat(CentrQtId).GetStr(); 
2101    NewQt.TmUrlCntV.Gen(TmUrlCntH.Len(), 0);
2102    for (int u = 0; u < TmUrlCntH.Len(); u++) {
2103      NewQt.TmUrlCntV.Add(TQuote::TTmUrlCnt(TmUrlCntH.GetKey(u).Val1, TmUrlCntH.GetKey(u).Val2(), TmUrlCntH[u]()));
2104    }
2105    NewQt.TmUrlCntV.Sort();
2106  }
2107  int TClustNet::EvalPhraseClusters(const TIntPrV& KeepEdgeV, const bool& dump) const {
2108    PNGraph G = TNGraph::New();
2109    for (int e = 0; e < KeepEdgeV.Len(); e++) {
2110      if (! G->IsNode(KeepEdgeV[e].Val1)) {
2111        G->AddNode(KeepEdgeV[e].Val1); }
2112      if (! G->IsNode(KeepEdgeV[e].Val2)) {
2113        G->AddNode(KeepEdgeV[e].Val2); }
2114      G->AddEdge(KeepEdgeV[e].Val1, KeepEdgeV[e].Val2);
2115    }
2116    TCnComV CnComV;
2117    TSnap::GetWccs(G, CnComV);
2118    G = TSnap::ConvertGraph<PNGraph>(TPt<TClustNet>((TClustNet*) this));
2119    int TotEdges=0, EdgesInBigClust=0;
2120    int TotNodes=0, NodesInBigClust=0;
2121    int BigClust=0;
2122    for (int cc = 0; cc < CnComV.Len(); cc++) {
2123      if (CnComV[cc].NIdV.Len() < 3) { continue; }
2124      PNGraph CC = TSnap::GetSubGraph(G, CnComV[cc].NIdV);
2125      TotEdges += CC->GetEdges();
2126      TotNodes += CC->GetNodes()-1;
2127      if (CC->GetNodes() > 10) {
2128        EdgesInBigClust += CC->GetEdges();
2129        NodesInBigClust += CC->GetNodes()-1;
2130        BigClust++;
2131      }
2132    }
2133    if (dump) {
2134      printf("                                all\tbig(>10)\n");
2135      printf("  Number of clusters:           %d\t%d\n", CnComV.Len(), BigClust);
2136      printf("  Total edges inside clusters:  %d\t%d\n", TotEdges, TotEdges-TotNodes);
2137      printf("  Total edges deleted:          %d\t%d\n", GetEdges()-TotEdges, GetEdges()-TotEdges-TotNodes);
2138      printf("  Total edges in big clusters:  %d\t%d\n", EdgesInBigClust, EdgesInBigClust-NodesInBigClust);
2139    }
2140    return TotEdges-TotNodes;
2141  }
2142  void TClustNet::ClustKeepSingleEdge(const int& MethodId) const {
2143    TIntPrV KeepEdgeV;
2144    ClustKeepSingleEdge(MethodId, KeepEdgeV);
2145  }
2146  void TClustNet::ClustKeepSingleEdge(const int& MethodId, TIntPrV& KeepEdgeV) const {
2147    PNGraph G = TSnap::ConvertGraph<PNGraph>(TPt<TClustNet>((TClustNet*) this));
2148    KeepEdgeV.Clr(false);
2149    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
2150      IAssert(NI.GetId() == NI().GetId());
2151      int EdgeToKeep = -1, BestVal=0;
2152      for (int e = 0; e < NI.GetOutDeg(); e++) {
2153        if (MethodId==1 && NI.GetOutNDat(e).GetFq() > BestVal) { EdgeToKeep=e; BestVal=NI.GetOutNDat(e).GetFq(); }
2154        if (MethodId==2 && NI.GetOutNDat(e).GetStr().Len() > BestVal) { EdgeToKeep=e; BestVal=NI.GetOutNDat(e).GetStr().Len(); }
2155        if (MethodId==3 && NI.GetOutNDat(e).GetStr().Len() < BestVal ||BestVal==0) { EdgeToKeep=e; BestVal=NI.GetOutNDat(e).GetStr().Len(); }
2156      }
2157      if (MethodId==4 && NI.GetOutDeg()>0) {
2158        EdgeToKeep = TInt::Rnd.GetUniDevInt(NI.GetOutDeg()); }
2159      if (EdgeToKeep!=-1) {
2160        KeepEdgeV.Add(TIntPr(NI.GetId(), NI.GetOutNId(EdgeToKeep))); }
2161    }
2162    if (MethodId==1) { printf("Keep edge to most frequent quote:\n"); }
2163    if (MethodId==2) { printf("Keep edge to longest quote:\n"); }
2164    if (MethodId==3) { printf("Keep edge to shortest quote:\n"); }
2165    if (MethodId==4) { printf("Keep random edge:\n"); }
2166    EvalPhraseClusters(KeepEdgeV);
2167  }
2168  void TClustNet::ClustGreedyTopDown() const {
2169    TIntPrV KeepEdgeV;
2170    ClustGreedyTopDown(KeepEdgeV);
2171  }
2172  void TClustNet::ClustGreedyTopDown(TIntPrV& KeepEdgeV) const {
2173    TIntH NIdOutDegH;
2174    TIntH NIdClustH;
2175    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
2176      NIdOutDegH.AddDat(NI.GetId(), NI.GetOutDeg());
2177      if (NI.GetOutDeg() == 0) {
2178        NIdClustH.AddDat(NI.GetId(), NI.GetId()); }
2179    }
2180    printf("%d root nodes\n", NIdClustH.Len());
2181    printf("%d nodes\n", NIdOutDegH.Len());
2182    NIdOutDegH.SortByDat(true);
2183    THash<TInt, TIntPr> ClustCntH;
2184    KeepEdgeV.Clr(false);
2185    while (NIdOutDegH.Len() > 0 && NIdOutDegH[0] == 0) {
2186      for (int i = 0; i < NIdOutDegH.Len() && NIdOutDegH[i] == 0; i++) {
2187        IAssert(IsNode(NIdOutDegH.GetKey(i)));
2188        const TNodeI NI = GetNI(NIdOutDegH.GetKey(i));
2189        for (int e = 0; e < NI.GetInDeg(); e++) {
2190          NIdOutDegH.GetDat(NI.GetInNId(e)) -= 1; }
2191        ClustCntH.Clr(false);
2192        for (int e = 0; e < NI.GetOutDeg(); e++) {
2193          IAssert(NIdClustH.IsKey(NI.GetOutNId(e)));
2194          ClustCntH.AddDat(NIdClustH.GetDat(NI.GetOutNId(e))).Val1 += 1; 
2195          ClustCntH.AddDat(NIdClustH.GetDat(NI.GetOutNId(e))).Val2 = NI.GetOutNId(e);
2196        }
2197        ClustCntH.SortByDat(false);
2198        if (ClustCntH.Len() > 0) {
2199          const int NId = NI.GetId();
2200          const int NId2 = ClustCntH[0].Val2;
2201          const int CId = NIdClustH.GetDat(NId2);
2202          KeepEdgeV.Add(TIntPr(NId, NId2)); 
2203          NIdClustH.AddDat(NId, CId); 
2204        }
2205        NIdOutDegH[i] = TInt::Mx;
2206      }
2207      NIdOutDegH.SortByDat(true);
2208    }
2209    printf("Greedy top down approach:\n");
2210    EvalPhraseClusters(KeepEdgeV);
2211  }
2212  void TClustNet::ClustGreedyRandom() const {
2213    printf("Greedy random:\n");
2214    THash<TInt, TIntV> OutNIdV;
2215    THash<TInt, TInt> EdgeH;
2216    TIntPrV KeepEdgeV;
2217    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
2218      if (NI.GetOutDeg() > 0) {
2219        EdgeH.AddDat(NI.GetId()) = NI.GetOutNId(TInt::Rnd.GetUniDevInt(NI.GetOutDeg()));
2220        if (NI.GetOutDeg() > 1) {
2221          for (int e = 0; e < NI.GetOutDeg(); e++) {
2222            OutNIdV.AddDat(NI.GetId()).Add(NI.GetOutNId(e)); }
2223        }
2224      }
2225    }
2226    { TIntH NIdOutDegH;
2227    TIntH NIdClustH;
2228    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
2229      NIdOutDegH.AddDat(NI.GetId()) = NI.GetOutDeg();
2230      if (NI.GetOutDeg() == 0) {
2231        NIdClustH.AddDat(NI.GetId(), NI.GetId()); }
2232    }
2233    NIdOutDegH.SortByDat(true);
2234    THash<TInt, TIntPr> ClustCntH;
2235    while (NIdOutDegH.Len() > 0 && NIdOutDegH[0] == 0) {
2236      for (int i = 0; i < NIdOutDegH.Len() && NIdOutDegH[i] == 0; i++) {
2237        const TNodeI NI = GetNI(NIdOutDegH.GetKey(i));
2238        for (int e = 0; e < NI.GetInDeg(); e++) {
2239          NIdOutDegH.GetDat(NI.GetInNId(e)) -= 1; }
2240        ClustCntH.Clr(false);
2241        for (int e = 0; e < NI.GetOutDeg(); e++) {
2242          ClustCntH.AddDat(NIdClustH.GetDat(NI.GetOutNId(e))).Val1 += 1;
2243          ClustCntH.AddDat(NIdClustH.GetDat(NI.GetOutNId(e))).Val2 = NI.GetOutNId(e);
2244        }
2245        ClustCntH.SortByDat(false);
2246        if (ClustCntH.Len() > 0) {
2247          KeepEdgeV.Add(TIntPr(NI.GetId(), ClustCntH[0].Val2));
2248        }
2249        NIdOutDegH[i] = TInt::Mx;
2250      }
2251      NIdOutDegH.SortByDat(true);
2252    } }
2253    printf("%d\n", EdgeH.Len());
2254    for (int e = 0; e < KeepEdgeV.Len(); e++) {
2255      EdgeH.AddDat(KeepEdgeV[e].Val1) = KeepEdgeV[e].Val2;
2256    }
2257    printf("%d\n", EdgeH.Len());
2258    EdgeH.GetKeyDatPrV(KeepEdgeV);
2259    int CurScore = EvalPhraseClusters(KeepEdgeV);
2260    while (true) {
2261        const int RndNId = OutNIdV.GetKey(TInt::Rnd.GetUniDevInt(OutNIdV.Len()));
2262        const int RndEdge = OutNIdV.GetDat(RndNId)[TInt::Rnd.GetUniDevInt(OutNIdV.GetDat(RndNId).Len())];
2263        const int id = EdgeH.GetKeyId(RndNId);  IAssert(KeepEdgeV[id].Val1 == RndNId);
2264        if (KeepEdgeV[id].Val2 == RndEdge) { continue; } 
2265        const int OldE = KeepEdgeV[id].Val2;
2266        KeepEdgeV[id].Val2 = RndEdge;
2267      const int NewScore = EvalPhraseClusters(KeepEdgeV, false);
2268      if (NewScore > CurScore &bsol;*|| TInt::Rnd.GetUniDev() < 0.1*/) {
2269        printf("%6d --> %6d\n", CurScore, NewScore);
2270        CurScore = NewScore;
2271      }
2272      else {  KeepEdgeV[id].Val2 = OldE; } 
2273    }
2274  }
2275  TChA InsertLineBreaks(const TChA& ChA, const int& BreakAtPost) {
2276    TChA Tmp = ChA, Out;
2277    int Lines = 1;
2278    TVec<char*> WrdV;
2279    TStrUtil::SplitWords(Tmp, WrdV);
2280    for (int w = 0; w < WrdV.Len(); w++) {
2281      if (Out.Len() + (int)strlen(WrdV[w]) > Lines*BreakAtPost) {
2282        Lines++; Out+="\\n"; }
2283      Out += WrdV[w];
2284      Out += " ";
2285    }
2286    return Out;
2287  }
2288  void TClustNet::DrawNet(const TStr& OutFNm, const int& SaveTopN) const {
2289    TCnComV CnComV;
2290    TSnap::GetWccs(GetThis(), CnComV);
2291    CnComV.Sort(false);
2292    for (int Comp = 0; Comp<TMath::Mn(SaveTopN, CnComV.Len()); Comp++) {
2293      if (CnComV[Comp].Len() < 5) { continue; }
2294      TPt<TNet> SubNet = TSnap::GetSubGraph(TPt<TNet>((TClustNet*) this), CnComV[Comp].NIdV);
2295      printf("draw: %d nodes, %d edges\n", SubNet->GetNodes(), SubNet->GetEdges());
2296      FILE *F = fopen(TStr::Fmt("%s-c%02d.dot", OutFNm.CStr(), Comp).CStr(), "wt");
2297      fprintf(F, "digraph G { &bsol;*%d nodes, %d edges*/\n", SubNet->GetNodes(), SubNet->GetEdges());
2298      fprintf(F, "  graph [splines=true overlap=false rankdir=LR]\n");
2299      fprintf(F, "  node  [shape=box, fontsize=14]\n");
2300      for (TNet::TNodeI NI = SubNet->BegNI(); NI < SubNet->EndNI(); NI++) {
2301        fprintf(F, "  %d [label=\"%s (%d, %d)\"];\n", NI.GetId(), InsertLineBreaks(NI().GetStr(), 80).CStr(), NI().GetFq(), NI().GetUrls());
2302      }
2303      for (TNet::TEdgeI EI = SubNet->BegEI(); EI < SubNet->EndEI(); EI++) {
2304        fprintf(F, "  %d -> %d;\n", EI.GetSrcNId(), EI.GetDstNId());
2305      }
2306      fprintf(F, "}\n");
2307      fclose(F);
2308      TGraphViz::DoLayout(TStr::Fmt("%s-c%02d.dot", OutFNm.CStr(), Comp), TStr::Fmt("%s-c%02d.ps", OutFNm.CStr(), Comp), gvlDot);
2309      TSnap::SavePajek(SubNet, TStr::Fmt("%s-c%02d.net", OutFNm.CStr(), Comp));
2310    }
2311  }
2312  void TClustNet::DumpNodes(const TStr& OutFNm, const int& SaveTopN) const {
2313    TIntV NIdV;  GetNIdV(NIdV);
2314    TIntH NIdCompSzH;
2315    { TCnComV CnComV;
2316    TSnap::GetWccs(GetThis(), CnComV);
2317    for (int c = 0; c < CnComV.Len(); c++) {
2318      for (int n = 0; n < CnComV[c].NIdV.Len(); n++) {
2319        NIdCompSzH.AddDat(CnComV[c].NIdV[n], CnComV[c].Len());
2320      }
2321    } }
2322    TIntPrV FqNIdV;
2323    for (int n = 0; n < NIdV.Len(); n++) {
2324      FqNIdV.Add(TIntPr(GetNDat(NIdV[n]).GetFq(), NIdV[n]));
2325    }
2326    FqNIdV.Sort(false);
2327    FILE *F = fopen(TStr::Fmt("nodes-%s.txt", OutFNm.CStr()).CStr(), "wt");
2328    fprintf(F, "#Freq\tClustSz\tQuote\n");
2329    for (int i = 0; i < FqNIdV.Len(); i++) {
2330      const TQuote& Q = GetNDat(FqNIdV[i].Val2);
2331      fprintf(F, "%d\t%d\t%s\n", Q.GetFq(), NIdCompSzH.GetDat(FqNIdV[i].Val2).Val, Q.GetStr().CStr());
2332    }
2333  }
2334  void TClustNet::DumpClusters(const TStr& OutFNm, int SaveTopN) const {
2335    TCnComV CnComV;
2336    TSnap::GetWccs(GetThis(), CnComV); 
2337    CnComV.Sort(false);
2338    FILE *F = fopen(TStr::Fmt("clust-%s.txt", OutFNm.CStr()).CStr(), "wt");
2339    if (SaveTopN==-1) { SaveTopN=TInt::Mx; }
2340    for (int Comp = 0; Comp<TMath::Mn(SaveTopN, CnComV.Len()); Comp++) {
2341      const TIntV& NIdV = CnComV[Comp].NIdV;
2342      TIntPrV FqNIdV;
2343      int SumFq=0;
2344      for (int n = 0; n < NIdV.Len(); n++) {
2345        FqNIdV.Add(TIntPr(GetNDat(NIdV[n]).GetFq(), NIdV[n]));
2346        SumFq += GetNDat(NIdV[n]).GetFq();
2347      }
2348      FqNIdV.Sort(false);
2349      fprintf(F, "%d quotes, total freq %d\n", FqNIdV.Len(), SumFq);
2350      for (int i = 0; i < FqNIdV.Len(); i++) {
2351        const TQuote& Q = GetNDat(FqNIdV[i].Val2);
2352        fprintf(F, "%d\t%s\n", Q.GetFq(), Q.GetStr().CStr());
2353      }
2354      fprintf(F, "\n");
2355    }
2356  }
2357  void TClustNet::DumpClustersByVol(const TStr& OutFNm, const int& MinClustSz, const int& MinVolume) const {
2358    TCnComV CnComV;
2359    TSnap::GetWccs(GetThis(), CnComV);
2360    CnComV.Sort(false);
2361    TIntPrV FqClustV;
2362    TIntH ClSzH, ClFqH;
2363    int FqMore1k=0;
2364    for (int Comp = 0; Comp < CnComV.Len(); Comp++) {
2365      const TIntV& NIdV = CnComV[Comp].NIdV;
2366      if (NIdV.Len() < MinClustSz) { continue; } 
2367      int SumFq=0;
2368      for (int n = 0; n < NIdV.Len(); n++) {
2369        SumFq += GetNDat(NIdV[n]).GetFq(); }
2370      FqClustV.Add(TIntPr(SumFq, Comp));
2371      ClFqH.AddDat(SumFq) += 1;
2372      ClSzH.AddDat(NIdV.Len()) += 1;
2373      if (SumFq>500) { FqMore1k++; }
2374    }
2375    FqClustV.Sort(false);
2376    FILE *F = fopen(TStr::Fmt("clustFq-%s.txt", OutFNm.CStr()).CStr(), "wt");
2377    fprintf(F, "Cluster network:\n%d nodes\n%d edges\n%d clusters\n%d big clusters (>=%d)\n",
2378      GetNodes(), GetEdges(), CnComV.Len(), FqClustV.Len(), MinClustSz);
2379    for (int c = 0; c < FqClustV.Len(); c++) {
2380      const TIntV& NIdV = CnComV[FqClustV[c].Val2].NIdV;
2381      TIntPrV FqNIdV;
2382      int SumFq=0;
2383      for (int n = 0; n < NIdV.Len(); n++) {
2384        FqNIdV.Add(TIntPr(GetNDat(NIdV[n]).GetFq(), NIdV[n]));
2385        SumFq += GetNDat(NIdV[n]).GetFq();
2386      }
2387      if (SumFq < MinVolume) { continue; }
2388      FqNIdV.Sort(false);
2389      fprintf(F, "%d\t%d items\t%d totFq\n", c, FqNIdV.Len(), SumFq);
2390      for (int i = 0; i < FqNIdV.Len(); i++) {
2391        const TQuote& Q = GetNDat(FqNIdV[i].Val2);
2392        fprintf(F, "\t%d\t%s\n", Q.GetFq(), Q.GetStr().CStr());
2393      }
2394      fprintf(F, "\n");
2395    }
2396    TGnuPlot::PlotValCntH(ClFqH, "clVol."+OutFNm, TStr::Fmt("%s. %d nodes, %d edges, %d clusters, %d big clusters (>=%d), %d with vol>500",
2397      OutFNm.CStr(), GetNodes(), GetEdges(), CnComV.Len(), FqClustV.Len(), MinClustSz, FqMore1k), "Cluster volume", "Count", gpsLog);
2398    TGnuPlot::PlotValCntH(ClSzH, "clSz."+OutFNm, TStr::Fmt("%s. %d nodes, %d edges, %d clusters, %d big clusters (>=%d), %d with vol>500",
2399      OutFNm.CStr(), GetNodes(), GetEdges(), CnComV.Len(), FqClustV.Len(), MinClustSz, FqMore1k), "Cluster size", "Count", gpsLog);
2400  }
2401  void BuildPhraseInvertIdx(const PQuoteBs& QtBs, TStrHash<TInt>& WordIdH, THash<TInt, TIntV>& WIdQtIdVH) {
2402    printf("build quote word inverted index\n");
2403    TIntV WIdV;
2404    TIntSet WIdSet;
2405    for (int q = 0; q < QtBs->Len(); q++) {
2406      const TQuote& Q = QtBs->GetQtN(q);
2407      TStrUtil::GetAddWIdV(WordIdH, Q.GetStr().CStr(), WIdV);
2408      const int Doms = Q.GetDoms(*QtBs);
2409      if (! (Doms>1 && Doms*4 > Q.GetUrls() && Q.GetFq() >= 5)) { 
2410        continue;
2411      }
2412      WIdSet.Clr(false); 
2413      for (int w = 0; w < WIdV.Len(); w++) {
2414        WIdSet.AddKey(WIdV[w]);
2415      }
2416      for (int w = 0; w < WIdSet.Len(); w++) {
2417        WIdQtIdVH.AddDat(WIdSet[w]).Add(q);
2418      }
2419    }
2420    for (int i = 0; i < WIdQtIdVH.Len(); i++) {
2421      WIdQtIdVH[i].Pack();
2422    }
2423    printf("done.\n");
2424  }
2425  bool IsLinkPhrases(const PQuoteBs& QtBs, const int& QtN1, const int& QtN2, TStrHash<TInt>& WordIdH, THash<TInt, TIntV>& QtToWordIdVH) {
2426    if (! QtToWordIdVH.IsKey(QtN1)) {
2427      TIntV WIdV;
2428      TStrUtil::GetWIdV(WordIdH, QtBs->GetQtN(QtN1).GetStr().CStr(), WIdV);
2429      WIdV.Pack();
2430      QtToWordIdVH.AddDat(QtN1, WIdV);
2431    }
2432    if (! QtToWordIdVH.IsKey(QtN2)) {
2433      TIntV WIdV;
2434      TStrUtil::GetWIdV(WordIdH, QtBs->GetQtN(QtN2).GetStr().CStr(), WIdV);
2435      WIdV.Pack();
2436      QtToWordIdVH.AddDat(QtN2, WIdV);
2437    }
2438    int idx1=0, idx2=0, SkipTy=0;
2439    const TIntV& WIdV1 = QtToWordIdVH.GetDat(QtN1);
2440    const TIntV& WIdV2 = QtToWordIdVH.GetDat(QtN2);
2441    const int ShortLen = TMath::Mn(WIdV1.Len(), WIdV2.Len());
2442    const int Overlap = TQuoteBs::LongestCmnSubSq(WIdV1, WIdV2, idx1, idx2, SkipTy);
2443    bool DoMerge = false;
2444    if (ShortLen <= 5 && Overlap == ShortLen &bsol;*&& SkipTy==0*/) { DoMerge=true; } 
2445    else if ((ShortLen == 6 && Overlap >= 5 &bsol;*&& SkipTy==0) || (ShortLen == 6 && Overlap == 5*/)) { DoMerge=true; }
2446    else if (Overlap/double(ShortLen+3) > 0.5 || Overlap > 10) { DoMerge=true; }
2447    return DoMerge;
2448  }
2449  PClustNet TClustNet::GetFromQtBs(const PQuoteBs& QtBs, int MinQtFq, int MnWrdLen) {
2450    TStrHash<TInt> WordIdH;
2451    THash<TInt, TIntV> WIdQtIdVH; 
2452    BuildPhraseInvertIdx(QtBs, WordIdH, WIdQtIdVH);
2453    PClustNet Net = TClustNet::New();
2454    TVec<int> QtSharCnt(QtBs->Len()), QtWrdLen(QtBs->Len());
2455    THash<TInt, TIntV> QtToWordIdVH;   
2456    TIntV WIdV;
2457    TIntH CandLenH, LinkLenH;
2458    THash<TInt, TIntH> QtLenCandH, QtLenLinkH;
2459    int AllCand=0, AllLinks=0;
2460    TExeTm ExeTm;
2461    for (int qt = 0; qt < QtBs->Len(); qt++) {
2462      QtWrdLen[qt] = TStrUtil::CountWords(QtBs->GetQtN(qt).GetStr().CStr());
2463    }
2464    const int QtBsLen = QtBs->Len();
2465    for (int qt = 0; qt < QtBs->Len(); qt++) {
2466      const TQuote& Q = QtBs->GetQtN(qt);
2467      const int Doms = Q.GetDoms(*QtBs);
2468    if (! (Doms>1 && Doms*4 > Q.GetUrls() && Q.GetFq() >= MinQtFq &&
2469      TStrUtil::CountWords(Q.GetStr())>=MnWrdLen)) {
2470        continue; }
2471      memset(QtSharCnt.BegI(), 0, sizeof(int)*QtSharCnt.Len());
2472      TStrUtil::GetWIdV(WordIdH, Q.GetStr().CStr(), WIdV);
2473      if (! QtToWordIdVH.IsKey(qt)) {
2474        WIdV.Pack();
2475        QtToWordIdVH.AddDat(qt, WIdV);
2476      }
2477      for (int w = 0; w < WIdV.Len(); w++) {
2478        IAssert(WIdQtIdVH.IsKey(WIdV[w]));
2479        const TIntV& QtIdV = WIdQtIdVH.GetDat(WIdV[w]);
2480        for (int q = 0; q < QtIdV.Len(); q++) {
2481          QtSharCnt[QtIdV[q]] += 1;
2482        }
2483      }
2484      const int W = WIdV.Len();
2485      int Candidates = 0, Links = 0, MinSharedWords = W-3;
2486      if (W <= 5) { MinSharedWords = W-1; }
2487      else if (W <= 10) { MinSharedWords = W-2; }
2488      for (int q = 0; q < QtSharCnt.Len(); q++) {
2489        if (QtSharCnt[q] >= MinSharedWords && (QtWrdLen[q] >= W || QtWrdLen[q] > 20)) {
2490          const TQuote& Qt2 = QtBs->GetQtN(q);
2491          if (Doms>1 && Doms*4 > Q.GetUrls() && Q.GetFq() >= MinQtFq) { 
2492            if (IsLinkPhrases(QtBs, qt, q, WordIdH, QtToWordIdVH)) {    
2493              Net->AddLink(Q, Qt2);
2494              Links++;
2495            }
2496          }
2497          Candidates++;
2498        }
2499      }
2500      AllCand += Candidates;
2501      AllLinks += Links;
2502      CandLenH.AddDat(Candidates) += 1;
2503      LinkLenH.AddDat(Links) += 1;
2504      if (W < 21) {
2505        QtLenCandH.AddDat(W).AddDat(Candidates) += 1;
2506        QtLenLinkH.AddDat(W).AddDat(Links) += 1;
2507      }
2508      if (qt % 1000 == 0 || qt==QtBsLen-1) {
2509        printf("\r%d  %s    allCands: %d    allLinks: %d    nodes:%d", qt, ExeTm.GetStr(), AllCand, AllLinks, Net->GetNodes());
2510        if (qt % 100000 == 0 || qt==QtBsLen-1) {
2511          TGnuPlot::PlotValCntH(CandLenH, "qtNet-NCand", "Number of candidate links for each quote (candidate has at most 2*words)",
2512            "ClustNet: number of candidate quotes to create link to", "Count", gpsLog);
2513          TGnuPlot::PlotValCntH(LinkLenH, "qtNet-NLink", "Number of links for each quote (candidate has at most 2*words)",
2514            "ClustNet: number of out-links of a quote", "Count", gpsLog);
2515        }
2516      }
2517    }
2518    printf("done.\n");
2519    TGnuPlot::PlotValCntH(CandLenH, "qtNet-NCand", "Number of candidate links for each quote (candidate has at most 2*words)",
2520      "ClustNet: number of candidate quotes to create link to", "Count", gpsLog);
2521    TGnuPlot::PlotValCntH(LinkLenH, "qtNet-NLink", "Number of links for each quote (candidate has at most 2*words)",
2522      "ClustNet: number of out-links of a quote", "Count", gpsLog);
2523    return Net;
2524  }
2525  void TQuoteLoader::Clr() {
2526    PostTitleStr.Clr();
2527    PostUrlStr.Clr();
2528    PubTm = TSecTm();
2529    BlogUrlStr.Clr();
2530    BlogTitleStr.Clr();
2531    ContentStr.Clr();
2532    QuoteV.Clr(false);
2533    LinkV.Clr(false);
2534  }
2535  bool TQuoteLoader::LoadItem(TXmlLx& XmlLx) {
2536    static const TSecTm BegOfTm(2008,8,30, 0, 0, 0);
2537    Clr();
2538    try {
2539      EAssert(XmlLx.TagNm == "post");
2540      const TChA T = TStrUtil::GetXmlTagVal(XmlLx, "pubDate");
2541      PubTm = TSecTm(atoi(T.GetSubStr(0,3).CStr()), atoi(T.GetSubStr(5,6).CStr()), atoi(T.GetSubStr(8,9).CStr()),
2542        atoi(T.GetSubStr(11,12).CStr()), atoi(T.GetSubStr(14,15).CStr()), atoi(T.GetSubStr(17,18).CStr()));
2543      EAssert(PubTm > BegOfTm);
2544      PostUrlStr = TStrUtil::GetXmlTagVal(XmlLx, "postUrl");
2545      PostTitleStr = TStrUtil::GetXmlTagVal(XmlLx, "postTitle");
2546      BlogUrlStr = TStrUtil::GetXmlTagVal(XmlLx, "blogUrl");
2547      BlogTitleStr = TStrUtil::GetXmlTagVal(XmlLx, "blogTitle");
2548      ContentStr = TStrUtil::GetXmlTagVal(XmlLx, "content");
2549      while (XmlLx.GetSym()==xsySTag && XmlLx.TagNm=="q") {
2550        EAssert(XmlLx.GetSym() == xsyStr);
2551        QuoteV.Add(XmlLx.TxtChA);
2552        EAssert(XmlLx.GetSym() == xsyETag && XmlLx.TagNm=="q");
2553      }
2554    }
2555    catch (PExcept Except){
2556      ErrNotify(Except->GetStr());
2557      Fail;  return false;
2558    }
2559    return true;
2560  }
2561  void TQuoteLoader::Save(TSOut& SOut) const {
2562    PubTm.Save(SOut);
2563    PostUrlStr.Save(SOut);
2564    PostTitleStr.Save(SOut);
2565    BlogUrlStr.Save(SOut);
2566    BlogTitleStr.Save(SOut);
2567    ContentStr.Save(SOut);
2568    QuoteV.Save(SOut);
2569    LinkV.Save(SOut);
2570  }
2571  void TQuoteLoader::Load(TSIn& SIn) {
2572    PubTm.Load(SIn);
2573    PostUrlStr.Load(SIn);
2574    PostTitleStr.Load(SIn);
2575    BlogUrlStr.Load(SIn);
2576    BlogTitleStr.Load(SIn);
2577    ContentStr.Load(SIn);
2578    QuoteV.Load(SIn);
2579    LinkV.Load(SIn);
2580  }
2581  bool TQuoteLoader::Next() {
2582    if (SIn.Empty() || SIn->Eof()) {
2583      printf("  new file");
2584      if (! FFile.Next(CurFNm)) { return false; }
2585      printf(" %s\n", CurFNm.GetFMid().CStr());
2586      SIn = TZipIn::IsZipExt(CurFNm.GetFExt()) ? PSIn(new TZipIn(CurFNm)) : PSIn(new TFIn(CurFNm));
2587      StartProcFile(CurFNm);
2588    }
2589    Load(*SIn);
2590    if (++PostCnt % Kilo(10) == 0) { printf("\r  %dk [%s]  ", PostCnt/Kilo(1), ExeTm.GetStr()); }
2591    return true;
2592  }
2593  void TQuoteLoader::ProcessPosts(const bool& IsXml, int LoadN) {
2594    TExeTm ExeTm, TotalTm;
2595    StartProcess();
2596    if (LoadN < 0) { LoadN = TInt::Mx; }
2597    int FilePostCnt=0;
2598    for (int f = 1; FFile.Next(CurFNm); f++) {
2599      printf("*** FILE:  %s\n", CurFNm.GetFMid().CStr());
2600      SIn = TZipIn::IsZipExt(CurFNm.GetFExt()) ? PSIn(new TZipIn(CurFNm)) : PSIn(new TFIn(CurFNm));
2601      if (IsXml) {
2602        TXmlLx XmlLx(SIn, xspTruncate);
2603        StartProcFile(CurFNm);
2604        for (FilePostCnt=0; XmlLx.GetSym() != xsyEof; FilePostCnt++, PostCnt++) {
2605          if (! (XmlLx.Sym==xsySTag && XmlLx.TagNm=="post")) {
2606            while (XmlLx.GetSym()!=xsyEof && ! (XmlLx.Sym==xsySTag && XmlLx.TagNm=="post")) { }
2607            if (XmlLx.Sym == xsyEof) { break; }
2608          }
2609          const bool IsGoodPost = LoadItem(XmlLx);
2610          ProcessPost(IsGoodPost);
2611          if (PostCnt % Kilo(1) == 0) {
2612            printf("\r%dk [%s] ", PostCnt/Kilo(1), ExeTm.GetStr()); }
2613          if (PostCnt >= LoadN) { break; }
2614        }
2615      } else {
2616        FilePostCnt = 0;
2617        while (! SIn->Eof()) {
2618          Load(*SIn);  FilePostCnt++;  PostCnt++;
2619          ProcessPost(true);
2620          if (PostCnt % Kilo(10) == 0) {
2621            printf("\r%dk [%s] ", PostCnt/Kilo(1), ExeTm.GetStr()); }
2622          if (PostCnt >= LoadN) { break; }
2623        }
2624      }
2625      printf("\n================================================================\n");
2626      printf("  file:  %s\n", CurFNm.GetFMid().CStr());
2627      printf("  time:  %s   ", ExeTm.GetStr());
2628      printf("total: %s [%s]\n", TotalTm.GetStr(), TExeTm::GetCurTm());
2629      printf("  posts: %d   total: %d\n", FilePostCnt, PostCnt);
2630      EndProcFile(CurFNm);
2631      fflush(stdout);  ExeTm.Tick();
2632      if (PostCnt >= LoadN) { break; }
2633    }
2634    EndProcess(PostCnt);
2635  }
2636  bool TMemesDataLoader::GetNextFile() {
2637    TStr FNm;
2638    if (! FFile.Empty()) {
2639      if (! FFile->Next(FNm)) { return false; }
2640      printf("NEXT-FL:  %s :\t%s\n", FNm.GetFBase().CStr(), TExeTm::GetCurTm());
2641    } else {
2642      IAssert(! InFNmF.Empty());
2643      if (InFNmF->Eof()) { return false; }
2644    while (! InFNmF->Eof() && InFNmF->GetNextLn(FNm) && FNm.Empty()) { }
2645      printf("NEXT-LN:  %s :\t%s\n", FNm.GetFBase().CStr(), TExeTm::GetCurTm());
2646    }
2647    if (FNm.Empty()) { return false; }
2648    if (TZipIn::IsZipExt(FNm.GetFExt())) {
2649      SInPt = TZipIn::New(FNm); }
2650    else {
2651      SInPt = TFIn::New(FNm); }  LineCnt = 0;
2652    return true;
2653  }
2654  void TMemesDataLoader::Clr() {
2655    PostUrlStr.Clr();
2656    ContentStr.Clr();
2657    PubTm = TSecTm();
2658    MemeV.Clr(false);
2659    MemePosV.Clr(false);
2660    LinkV.Clr(false);
2661    LinkPosV.Clr(false);
2662  }
2663  bool TMemesDataLoader::LoadNext() {
2664    Clr();
2665    if (SInPt.Empty() || SInPt->Eof()) {
2666      if (! GetNextFile()) { return false; }
2667    }
2668    TSIn& SIn = *SInPt;
2669    CurLn.Clr();
2670    while (SIn.GetNextLn(CurLn) && (CurLn.Empty() || (CurLn[0]!='U' || CurLn[1]!='\t'))) { 
2671      printf("L: %s\n", CurLn.CStr()); LineCnt++; }
2672    LineCnt++;
2673    if (CurLn.Empty()) { return LoadNext(); }
2674    IAssertR((! CurLn.Empty()) && CurLn[0]=='U' && CurLn[1]=='\t', 
2675      TStr::Fmt("ERROR1: %s [line %llu]: '%s'\n", SIn.GetSNm().CStr(), LineCnt, CurLn.CStr()).CStr());
2676    PostUrlStr = CurLn.CStr()+2;
2677    while (SIn.GetNextLn(CurLn) && (CurLn.Empty() || (CurLn[0]!='D' || CurLn[1]!='\t'))) { LineCnt++; }
2678    IAssertR((! CurLn.Empty()) && CurLn[0]=='D', 
2679      TStr::Fmt("ERROR2: %s [line %llu]: '%s'\n", SIn.GetSNm().CStr(), LineCnt, CurLn.CStr()).CStr());  LineCnt++;
2680    try {
2681      PubTm = TSecTm::GetDtTmFromStr(CurLn);
2682    } catch (PExcept Except){ PubTm = 1; ErrNotify(Except->GetStr());
2683      printf("ERROR3: %s [line %llu]: '%s'\n", SIn.GetSNm().CStr(), LineCnt, CurLn.CStr()); 
2684    }
2685    IAssertR(SIn.GetNextLn(CurLn) && (! CurLn.Empty()) && (CurLn[0]=='C' || CurLn[0]=='T'), 
2686      TStr::Fmt("ERROR4: %s [line %llu]: '%s'\n", SIn.GetSNm().CStr(), LineCnt, CurLn.CStr()).CStr());  LineCnt++;
2687    if (CurLn[0] == 'T') { 
2688      IAssertR(SIn.GetNextLn(CurLn) && (! CurLn.Empty()) && CurLn[0]=='C', 
2689        TStr::Fmt("ERROR5: %s [line %llu]: '%s'\n", SIn.GetSNm().CStr(), LineCnt, CurLn.CStr()).CStr());  LineCnt++; }
2690    ContentStr = CurLn.CStr()+2;
2691    while (SIn.GetNextLn(CurLn)) {  LineCnt++;
2692      if (CurLn.Empty() || CurLn[0]!='L') { break; }
2693      int linkb=2;
2694      while (CurLn[linkb]!='\t') { linkb++; }
2695      CurLn[linkb]=0;
2696      LinkV.Add(CurLn.CStr()+linkb+1);
2697      LinkPosV.Add(atoi(CurLn.CStr()+2));
2698    }
2699    do {
2700      if (CurLn.Empty() || CurLn[0]!='Q') { break; }
2701      int qb1=2;      while (CurLn[qb1]!='\t') { qb1++; }
2702      int qb2=qb1+1;  while (CurLn[qb2]!='\t') { qb2++; }
2703      CurLn[qb1]=0;  CurLn[qb2]=0;
2704      MemeV.Add(CurLn.CStr()+qb2+1);
2705      MemePosV.Add(TIntPr(atoi(CurLn.CStr()+2), atoi(CurLn.CStr()+qb1+1)));
2706      LineCnt++;
2707    } while (SIn.GetNextLn(CurLn));
2708    return true;
2709  }
2710  void TMemesDataLoader::SaveTxt(TSOut& SOut) const {
2711  }
2712  void TMemesDataLoader::Dump(const bool& DumpAll) const {
2713  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-cord.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-memes.cpp</div>
                </div>
                <div class="column column_space"><pre><code>492    cord_internal::SmallMemmove(dst, data_.as_chars(), n);
493  }
</pre></code></div>
                <div class="column column_space"><pre><code>2008        TStrUtil::GetAddWIdV(StrH, Q2.CStr(), WIdV2);
2009        const int Overlap = TQuoteBs::LongestCmnSubSq(WIdV1, WIdV2, WIdV1Start, WIdV2Start, SkipTy);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    