
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 16, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-statusor_test.cc</h3>
            <pre><code>1  #include &quot;absl/status/statusor.h&quot;
2  #include &lt;array&gt;
3  #include &lt;initializer_list&gt;
4  #include &lt;memory&gt;
5  #include &lt;string&gt;
6  #include &lt;type_traits&gt;
7  #include &lt;utility&gt;
8  #include &quot;gmock/gmock.h&quot;
9  #include &quot;gtest/gtest.h&quot;
10  #include &quot;absl/base/casts.h&quot;
11  #include &quot;absl/memory/memory.h&quot;
12  #include &quot;absl/status/status.h&quot;
13  #include &quot;absl/strings/string_view.h&quot;
14  #include &quot;absl/types/any.h&quot;
15  #include &quot;absl/utility/utility.h&quot;
16  namespace {
17  using ::testing::AllOf;
18  using ::testing::AnyWith;
19  using ::testing::ElementsAre;
20  using ::testing::Field;
21  using ::testing::HasSubstr;
22  using ::testing::Ne;
23  using ::testing::Not;
24  using ::testing::Pointee;
25  using ::testing::VariantWith;
26  #ifdef GTEST_HAS_STATUS_MATCHERS
27  using ::testing::status::IsOk;
28  using ::testing::status::IsOkAndHolds;
29  #else  
30  inline const ::absl::Status&amp; GetStatus(const ::absl::Status&amp; status) {
31    return status;
32  }
33  template &lt;typename T&gt;
34  inline const ::absl::Status&amp; GetStatus(const ::absl::StatusOr&lt;T&gt;&amp; status) {
35    return status.status();
36  }
37  template &lt;typename StatusOrType&gt;
38  class IsOkAndHoldsMatcherImpl
39      : public ::testing::MatcherInterface&lt;StatusOrType&gt; {
40   public:
41    typedef
42        typename std::remove_reference&lt;StatusOrType&gt;::type::value_type value_type;
43    template &lt;typename InnerMatcher&gt;
44    explicit IsOkAndHoldsMatcherImpl(InnerMatcher&amp;&amp; inner_matcher)
45        : inner_matcher_(::testing::SafeMatcherCast&lt;const value_type&amp;&gt;(
46              std::forward&lt;InnerMatcher&gt;(inner_matcher))) {}
47    void DescribeTo(std::ostream* os) const override {
48      *os &lt;&lt; &quot;is OK and has a value that &quot;;
49      inner_matcher_.DescribeTo(os);
50    }
51    void DescribeNegationTo(std::ostream* os) const override {
52      *os &lt;&lt; &quot;isn&#x27;t OK or has a value that &quot;;
53      inner_matcher_.DescribeNegationTo(os);
54    }
55    bool MatchAndExplain(
56        StatusOrType actual_value,
57        ::testing::MatchResultListener* result_listener) const override {
58      if (!actual_value.ok()) {
59        *result_listener &lt;&lt; &quot;which has status &quot; &lt;&lt; actual_value.status();
60        return false;
61      }
62      ::testing::StringMatchResultListener inner_listener;
63      const bool matches =
64          inner_matcher_.MatchAndExplain(*actual_value, &amp;inner_listener);
65      const std::string inner_explanation = inner_listener.str();
66      if (!inner_explanation.empty()) {
67        *result_listener &lt;&lt; &quot;which contains value &quot;
68                         &lt;&lt; ::testing::PrintToString(*actual_value) &lt;&lt; &quot;, &quot;
69                         &lt;&lt; inner_explanation;
70      }
71      return matches;
72    }
73   private:
74    const ::testing::Matcher&lt;const value_type&amp;&gt; inner_matcher_;
75  };
76  template &lt;typename InnerMatcher&gt;
77  class IsOkAndHoldsMatcher {
78   public:
79    explicit IsOkAndHoldsMatcher(InnerMatcher inner_matcher)
80        : inner_matcher_(std::move(inner_matcher)) {}
81    template &lt;typename StatusOrType&gt;
82    operator ::testing::Matcher&lt;StatusOrType&gt;() const {  
83      return ::testing::Matcher&lt;StatusOrType&gt;(
84          new IsOkAndHoldsMatcherImpl&lt;const StatusOrType&amp;&gt;(inner_matcher_));
85    }
86   private:
87    const InnerMatcher inner_matcher_;
88  };
89  template &lt;typename T&gt;
90  class MonoIsOkMatcherImpl : public ::testing::MatcherInterface&lt;T&gt; {
91   public:
92    void DescribeTo(std::ostream* os) const override { *os &lt;&lt; &quot;is OK&quot;; }
93    void DescribeNegationTo(std::ostream* os) const override {
94      *os &lt;&lt; &quot;is not OK&quot;;
95    }
96    bool MatchAndExplain(T actual_value,
97                         ::testing::MatchResultListener*) const override {
98      return GetStatus(actual_value).ok();
99    }
100  };
101  class IsOkMatcher {
102   public:
103    template &lt;typename T&gt;
104    operator ::testing::Matcher&lt;T&gt;() const {  
105      return ::testing::Matcher&lt;T&gt;(new MonoIsOkMatcherImpl&lt;T&gt;());
106    }
107  };
108  #define EXPECT_OK(expression) EXPECT_THAT(expression, IsOk())
109  template &lt;typename InnerMatcher&gt;
110  IsOkAndHoldsMatcher&lt;typename std::decay&lt;InnerMatcher&gt;::type&gt; IsOkAndHolds(
111      InnerMatcher&amp;&amp; inner_matcher) {
112    return IsOkAndHoldsMatcher&lt;typename std::decay&lt;InnerMatcher&gt;::type&gt;(
113        std::forward&lt;InnerMatcher&gt;(inner_matcher));
114  }
115  inline IsOkMatcher IsOk() { return IsOkMatcher(); }
116  #endif  
117  struct CopyDetector {
118    CopyDetector() = default;
119    explicit CopyDetector(int xx) : x(xx) {}
120    CopyDetector(CopyDetector&amp;&amp; d) noexcept
121        : x(d.x), copied(false), moved(true) {}
122    CopyDetector(const CopyDetector&amp; d) : x(d.x), copied(true), moved(false) {}
123    CopyDetector&amp; operator=(const CopyDetector&amp; c) {
124      x = c.x;
125      copied = true;
126      moved = false;
127      return *this;
128    }
129    CopyDetector&amp; operator=(CopyDetector&amp;&amp; c) noexcept {
130      x = c.x;
131      copied = false;
132      moved = true;
133      return *this;
134    }
135    int x = 0;
136    bool copied = false;
137    bool moved = false;
138  };
139  testing::Matcher&lt;const CopyDetector&amp;&gt; CopyDetectorHas(int a, bool b, bool c) {
140    return AllOf(Field(&amp;CopyDetector::x, a), Field(&amp;CopyDetector::moved, b),
141                 Field(&amp;CopyDetector::copied, c));
142  }
143  class Base1 {
144   public:
145    virtual ~Base1() {}
146    int pad;
147  };
148  class Base2 {
149   public:
150    virtual ~Base2() {}
151    int yetotherpad;
152  };
153  class Derived : public Base1, public Base2 {
154   public:
155    virtual ~Derived() {}
156    int evenmorepad;
157  };
158  class CopyNoAssign {
159   public:
160    explicit CopyNoAssign(int value) : foo(value) {}
161    CopyNoAssign(const CopyNoAssign&amp; other) : foo(other.foo) {}
162    int foo;
163   private:
164    const CopyNoAssign&amp; operator=(const CopyNoAssign&amp;);
165  };
166  absl::StatusOr&lt;std::unique_ptr&lt;int&gt;&gt; ReturnUniquePtr() {
167    return absl::make_unique&lt;int&gt;(0);
168  }
169  TEST(StatusOr, ElementType) {
170    static_assert(std::is_same&lt;absl::StatusOr&lt;int&gt;::value_type, int&gt;(), &quot;&quot;);
171    static_assert(std::is_same&lt;absl::StatusOr&lt;char&gt;::value_type, char&gt;(), &quot;&quot;);
172  }
173  TEST(StatusOr, TestMoveOnlyInitialization) {
174    absl::StatusOr&lt;std::unique_ptr&lt;int&gt;&gt; thing(ReturnUniquePtr());
175    ASSERT_TRUE(thing.ok());
176    EXPECT_EQ(0, **thing);
177    int* previous = thing-&gt;get();
178    thing = ReturnUniquePtr();
179    EXPECT_TRUE(thing.ok());
180    EXPECT_EQ(0, **thing);
181    EXPECT_NE(previous, thing-&gt;get());
182  }
183  TEST(StatusOr, TestMoveOnlyValueExtraction) {
184    absl::StatusOr&lt;std::unique_ptr&lt;int&gt;&gt; thing(ReturnUniquePtr());
185    ASSERT_TRUE(thing.ok());
186    std::unique_ptr&lt;int&gt; ptr = *std::move(thing);
187    EXPECT_EQ(0, *ptr);
188    thing = std::move(ptr);
189    ptr = std::move(*thing);
<span onclick='openModal()' class='match'>190    EXPECT_EQ(0, *ptr);
191  }
192  TEST(StatusOr, TestMoveOnlyInitializationFromTemporaryByValueOrDie) {
193    std::unique_ptr&lt;int&gt; ptr(*ReturnUniquePtr());
</span>194    EXPECT_EQ(0, *ptr);
195  }
196  TEST(StatusOr, TestValueOrDieOverloadForConstTemporary) {
197    static_assert(
198        std::is_same&lt;
199            const int&amp;&amp;,
200            decltype(std::declval&lt;const absl::StatusOr&lt;int&gt;&amp;&amp;&gt;().value())&gt;(),
201        &quot;value() for const temporaries should return const T&amp;&amp;&quot;);
202  }
203  TEST(StatusOr, TestMoveOnlyConversion) {
204    absl::StatusOr&lt;std::unique_ptr&lt;const int&gt;&gt; const_thing(ReturnUniquePtr());
205    EXPECT_TRUE(const_thing.ok());
206    EXPECT_EQ(0, **const_thing);
207    const int* const_previous = const_thing-&gt;get();
208    const_thing = ReturnUniquePtr();
209    EXPECT_TRUE(const_thing.ok());
210    EXPECT_EQ(0, **const_thing);
211    EXPECT_NE(const_previous, const_thing-&gt;get());
212  }
213  TEST(StatusOr, TestMoveOnlyVector) {
214    std::vector&lt;absl::StatusOr&lt;std::unique_ptr&lt;int&gt;&gt;&gt; vec;
215    vec.push_back(ReturnUniquePtr());
216    vec.resize(2);
217    auto another_vec = std::move(vec);
218    EXPECT_EQ(0, **another_vec[0]);
219    EXPECT_EQ(absl::UnknownError(&quot;&quot;), another_vec[1].status());
220  }
221  TEST(StatusOr, TestDefaultCtor) {
222    absl::StatusOr&lt;int&gt; thing;
223    EXPECT_FALSE(thing.ok());
224    EXPECT_EQ(thing.status().code(), absl::StatusCode::kUnknown);
225  }
226  TEST(StatusOr, StatusCtorForwards) {
227    absl::Status status(absl::StatusCode::kInternal, &quot;Some error&quot;);
228    EXPECT_EQ(absl::StatusOr&lt;int&gt;(status).status().message(), &quot;Some error&quot;);
229    EXPECT_EQ(status.message(), &quot;Some error&quot;);
230    EXPECT_EQ(absl::StatusOr&lt;int&gt;(std::move(status)).status().message(),
231              &quot;Some error&quot;);
232    EXPECT_NE(status.message(), &quot;Some error&quot;);
233  }
234  TEST(BadStatusOrAccessTest, CopyConstructionWhatOk) {
235    absl::Status error =
236        absl::InternalError(&quot;some arbitrary message too big for the sso buffer&quot;);
237    absl::BadStatusOrAccess e1{error};
238    absl::BadStatusOrAccess e2{e1};
239    EXPECT_THAT(e1.what(), HasSubstr(error.ToString()));
240    EXPECT_THAT(e2.what(), HasSubstr(error.ToString()));
241  }
242  TEST(BadStatusOrAccessTest, CopyAssignmentWhatOk) {
243    absl::Status error =
244        absl::InternalError(&quot;some arbitrary message too big for the sso buffer&quot;);
245    absl::BadStatusOrAccess e1{error};
246    absl::BadStatusOrAccess e2{absl::InternalError(&quot;other&quot;)};
247    e2 = e1;
248    EXPECT_THAT(e1.what(), HasSubstr(error.ToString()));
249    EXPECT_THAT(e2.what(), HasSubstr(error.ToString()));
250  }
251  TEST(BadStatusOrAccessTest, MoveConstructionWhatOk) {
252    absl::Status error =
253        absl::InternalError(&quot;some arbitrary message too big for the sso buffer&quot;);
254    absl::BadStatusOrAccess e1{error};
255    absl::BadStatusOrAccess e2{std::move(e1)};
256    EXPECT_THAT(e2.what(), HasSubstr(error.ToString()));
257  }
258  TEST(BadStatusOrAccessTest, MoveAssignmentWhatOk) {
259    absl::Status error =
260        absl::InternalError(&quot;some arbitrary message too big for the sso buffer&quot;);
261    absl::BadStatusOrAccess e1{error};
262    absl::BadStatusOrAccess e2{absl::InternalError(&quot;other&quot;)};
263    e2 = std::move(e1);
264    EXPECT_THAT(e2.what(), HasSubstr(error.ToString()));
265  }
266  #ifdef ABSL_HAVE_EXCEPTIONS
267  #define EXPECT_DEATH_OR_THROW(statement, status_)                  \
268    EXPECT_THROW(                                                    \
269        {                                                            \
270          try {                                                      \
271            statement;                                               \
272          } catch (const absl::BadStatusOrAccess&amp; e) {               \
273            EXPECT_EQ(e.status(), status_);                          \
274            EXPECT_THAT(e.what(), HasSubstr(e.status().ToString())); \
275            throw;                                                   \
276          }                                                          \
277        },                                                           \
278        absl::BadStatusOrAccess);
279  #else  
280  #define EXPECT_DEATH_OR_THROW(statement, status) \
281    EXPECT_DEATH_IF_SUPPORTED(statement, status.ToString());
282  #endif  
283  TEST(StatusOrDeathTest, TestDefaultCtorValue) {
284    absl::StatusOr&lt;int&gt; thing;
285    EXPECT_DEATH_OR_THROW(thing.value(), absl::UnknownError(&quot;&quot;));
286    const absl::StatusOr&lt;int&gt; thing2;
287    EXPECT_DEATH_OR_THROW(thing2.value(), absl::UnknownError(&quot;&quot;));
288  }
289  TEST(StatusOrDeathTest, TestValueNotOk) {
290    absl::StatusOr&lt;int&gt; thing(absl::CancelledError());
291    EXPECT_DEATH_OR_THROW(thing.value(), absl::CancelledError());
292  }
293  TEST(StatusOrDeathTest, TestValueNotOkConst) {
294    const absl::StatusOr&lt;int&gt; thing(absl::UnknownError(&quot;&quot;));
295    EXPECT_DEATH_OR_THROW(thing.value(), absl::UnknownError(&quot;&quot;));
296  }
297  TEST(StatusOrDeathTest, TestPointerDefaultCtorValue) {
298    absl::StatusOr&lt;int*&gt; thing;
299    EXPECT_DEATH_OR_THROW(thing.value(), absl::UnknownError(&quot;&quot;));
300  }
301  TEST(StatusOrDeathTest, TestPointerValueNotOk) {
302    absl::StatusOr&lt;int*&gt; thing(absl::CancelledError());
303    EXPECT_DEATH_OR_THROW(thing.value(), absl::CancelledError());
304  }
305  TEST(StatusOrDeathTest, TestPointerValueNotOkConst) {
306    const absl::StatusOr&lt;int*&gt; thing(absl::CancelledError());
307    EXPECT_DEATH_OR_THROW(thing.value(), absl::CancelledError());
308  }
309  #if GTEST_HAS_DEATH_TEST
310  TEST(StatusOrDeathTest, TestStatusCtorStatusOk) {
311    EXPECT_DEBUG_DEATH(
312        {
313          absl::StatusOr&lt;int&gt; thing(absl::OkStatus());
314          EXPECT_FALSE(thing.ok());
315          EXPECT_EQ(thing.status().code(), absl::StatusCode::kInternal);
316        },
317        &quot;An OK status is not a valid constructor argument&quot;);
318  }
319  TEST(StatusOrDeathTest, TestPointerStatusCtorStatusOk) {
320    EXPECT_DEBUG_DEATH(
321        {
322          absl::StatusOr&lt;int*&gt; thing(absl::OkStatus());
323          EXPECT_FALSE(thing.ok());
324          EXPECT_EQ(thing.status().code(), absl::StatusCode::kInternal);
325        },
326        &quot;An OK status is not a valid constructor argument&quot;);
327  }
328  #endif
329  TEST(StatusOr, ValueAccessor) {
330    const int kIntValue = 110;
331    {
332      absl::StatusOr&lt;int&gt; status_or(kIntValue);
333      EXPECT_EQ(kIntValue, status_or.value());
334      EXPECT_EQ(kIntValue, std::move(status_or).value());
335    }
336    {
337      absl::StatusOr&lt;CopyDetector&gt; status_or(kIntValue);
338      EXPECT_THAT(status_or,
339                  IsOkAndHolds(CopyDetectorHas(kIntValue, false, false)));
340      CopyDetector copy_detector = status_or.value();
341      EXPECT_THAT(copy_detector, CopyDetectorHas(kIntValue, false, true));
342      copy_detector = std::move(status_or).value();
343      EXPECT_THAT(copy_detector, CopyDetectorHas(kIntValue, true, false));
344    }
345  }
346  TEST(StatusOr, BadValueAccess) {
347    const absl::Status kError = absl::CancelledError(&quot;message&quot;);
348    absl::StatusOr&lt;int&gt; status_or(kError);
349    EXPECT_DEATH_OR_THROW(status_or.value(), kError);
350  }
351  TEST(StatusOr, TestStatusCtor) {
352    absl::StatusOr&lt;int&gt; thing(absl::CancelledError());
353    EXPECT_FALSE(thing.ok());
354    EXPECT_EQ(thing.status().code(), absl::StatusCode::kCancelled);
355  }
356  TEST(StatusOr, TestValueCtor) {
357    const int kI = 4;
358    const absl::StatusOr&lt;int&gt; thing(kI);
359    EXPECT_TRUE(thing.ok());
360    EXPECT_EQ(kI, *thing);
361  }
362  struct Foo {
363    const int x;
364    explicit Foo(int y) : x(y) {}
365  };
366  TEST(StatusOr, InPlaceConstruction) {
367    EXPECT_THAT(absl::StatusOr&lt;Foo&gt;(absl::in_place, 10),
368                IsOkAndHolds(Field(&amp;Foo::x, 10)));
369  }
370  struct InPlaceHelper {
371    InPlaceHelper(std::initializer_list&lt;int&gt; xs, std::unique_ptr&lt;int&gt; yy)
372        : x(xs), y(std::move(yy)) {}
373    const std::vector&lt;int&gt; x;
374    std::unique_ptr&lt;int&gt; y;
375  };
376  TEST(StatusOr, InPlaceInitListConstruction) {
377    absl::StatusOr&lt;InPlaceHelper&gt; status_or(absl::in_place, {10, 11, 12},
378                                            absl::make_unique&lt;int&gt;(13));
379    EXPECT_THAT(status_or, IsOkAndHolds(AllOf(
380                               Field(&amp;InPlaceHelper::x, ElementsAre(10, 11, 12)),
381                               Field(&amp;InPlaceHelper::y, Pointee(13)))));
382  }
383  TEST(StatusOr, Emplace) {
384    absl::StatusOr&lt;Foo&gt; status_or_foo(10);
385    status_or_foo.emplace(20);
386    EXPECT_THAT(status_or_foo, IsOkAndHolds(Field(&amp;Foo::x, 20)));
387    status_or_foo = absl::InvalidArgumentError(&quot;msg&quot;);
388    EXPECT_FALSE(status_or_foo.ok());
389    EXPECT_EQ(status_or_foo.status().code(), absl::StatusCode::kInvalidArgument);
390    EXPECT_EQ(status_or_foo.status().message(), &quot;msg&quot;);
391    status_or_foo.emplace(20);
392    EXPECT_THAT(status_or_foo, IsOkAndHolds(Field(&amp;Foo::x, 20)));
393  }
394  TEST(StatusOr, EmplaceInitializerList) {
395    absl::StatusOr&lt;InPlaceHelper&gt; status_or(absl::in_place, {10, 11, 12},
396                                            absl::make_unique&lt;int&gt;(13));
397    status_or.emplace({1, 2, 3}, absl::make_unique&lt;int&gt;(4));
398    EXPECT_THAT(status_or,
399                IsOkAndHolds(AllOf(Field(&amp;InPlaceHelper::x, ElementsAre(1, 2, 3)),
400                                   Field(&amp;InPlaceHelper::y, Pointee(4)))));
401    status_or = absl::InvalidArgumentError(&quot;msg&quot;);
402    EXPECT_FALSE(status_or.ok());
403    EXPECT_EQ(status_or.status().code(), absl::StatusCode::kInvalidArgument);
404    EXPECT_EQ(status_or.status().message(), &quot;msg&quot;);
405    status_or.emplace({1, 2, 3}, absl::make_unique&lt;int&gt;(4));
406    EXPECT_THAT(status_or,
407                IsOkAndHolds(AllOf(Field(&amp;InPlaceHelper::x, ElementsAre(1, 2, 3)),
408                                   Field(&amp;InPlaceHelper::y, Pointee(4)))));
409  }
410  TEST(StatusOr, TestCopyCtorStatusOk) {
411    const int kI = 4;
412    const absl::StatusOr&lt;int&gt; original(kI);
413    const absl::StatusOr&lt;int&gt; copy(original);
414    EXPECT_OK(copy.status());
415    EXPECT_EQ(*original, *copy);
416  }
417  TEST(StatusOr, TestCopyCtorStatusNotOk) {
418    absl::StatusOr&lt;int&gt; original(absl::CancelledError());
419    absl::StatusOr&lt;int&gt; copy(original);
420    EXPECT_EQ(copy.status().code(), absl::StatusCode::kCancelled);
421  }
422  TEST(StatusOr, TestCopyCtorNonAssignable) {
423    const int kI = 4;
424    CopyNoAssign value(kI);
425    absl::StatusOr&lt;CopyNoAssign&gt; original(value);
426    absl::StatusOr&lt;CopyNoAssign&gt; copy(original);
427    EXPECT_OK(copy.status());
428    EXPECT_EQ(original-&gt;foo, copy-&gt;foo);
429  }
430  TEST(StatusOr, TestCopyCtorStatusOKConverting) {
431    const int kI = 4;
432    absl::StatusOr&lt;int&gt; original(kI);
433    absl::StatusOr&lt;double&gt; copy(original);
434    EXPECT_OK(copy.status());
435    EXPECT_DOUBLE_EQ(*original, *copy);
436  }
437  TEST(StatusOr, TestCopyCtorStatusNotOkConverting) {
438    absl::StatusOr&lt;int&gt; original(absl::CancelledError());
439    absl::StatusOr&lt;double&gt; copy(original);
440    EXPECT_EQ(copy.status(), original.status());
441  }
442  TEST(StatusOr, TestAssignmentStatusOk) {
443    {
444      const auto p = std::make_shared&lt;int&gt;(17);
445      absl::StatusOr&lt;std::shared_ptr&lt;int&gt;&gt; source(p);
446      absl::StatusOr&lt;std::shared_ptr&lt;int&gt;&gt; target;
447      target = source;
448      ASSERT_TRUE(target.ok());
449      EXPECT_OK(target.status());
450      EXPECT_EQ(p, *target);
451      ASSERT_TRUE(source.ok());
452      EXPECT_OK(source.status());
453      EXPECT_EQ(p, *source);
454    }
455    {
456      const auto p = std::make_shared&lt;int&gt;(17);
457      absl::StatusOr&lt;std::shared_ptr&lt;int&gt;&gt; source(p);
458      absl::StatusOr&lt;std::shared_ptr&lt;int&gt;&gt; target;
459      target = std::move(source);
460      ASSERT_TRUE(target.ok());
461      EXPECT_OK(target.status());
462      EXPECT_EQ(p, *target);
463      ASSERT_TRUE(source.ok());
464      EXPECT_OK(source.status());
465      EXPECT_EQ(nullptr, *source);
466    }
467  }
468  TEST(StatusOr, TestAssignmentStatusNotOk) {
469    {
470      const absl::Status expected = absl::CancelledError();
471      absl::StatusOr&lt;int&gt; source(expected);
472      absl::StatusOr&lt;int&gt; target;
473      target = source;
474      EXPECT_FALSE(target.ok());
475      EXPECT_EQ(expected, target.status());
476      EXPECT_FALSE(source.ok());
477      EXPECT_EQ(expected, source.status());
478    }
479    {
480      const absl::Status expected = absl::CancelledError();
481      absl::StatusOr&lt;int&gt; source(expected);
482      absl::StatusOr&lt;int&gt; target;
483      target = std::move(source);
484      EXPECT_FALSE(target.ok());
485      EXPECT_EQ(expected, target.status());
486      EXPECT_FALSE(source.ok());
487      EXPECT_EQ(source.status().code(), absl::StatusCode::kInternal);
488    }
489  }
490  TEST(StatusOr, TestAssignmentStatusOKConverting) {
491    {
492      const int kI = 4;
493      absl::StatusOr&lt;int&gt; source(kI);
494      absl::StatusOr&lt;double&gt; target;
495      target = source;
496      ASSERT_TRUE(target.ok());
497      EXPECT_OK(target.status());
498      EXPECT_DOUBLE_EQ(kI, *target);
499      ASSERT_TRUE(source.ok());
500      EXPECT_OK(source.status());
501      EXPECT_DOUBLE_EQ(kI, *source);
502    }
503    {
504      const auto p = new int(17);
505      absl::StatusOr&lt;std::unique_ptr&lt;int&gt;&gt; source(absl::WrapUnique(p));
506      absl::StatusOr&lt;std::shared_ptr&lt;int&gt;&gt; target;
507      target = std::move(source);
508      ASSERT_TRUE(target.ok());
509      EXPECT_OK(target.status());
510      EXPECT_EQ(p, target-&gt;get());
511      ASSERT_TRUE(source.ok());
512      EXPECT_OK(source.status());
513      EXPECT_EQ(nullptr, source-&gt;get());
514    }
515  }
516  struct A {
517    int x;
518  };
519  struct ImplicitConstructibleFromA {
520    int x;
521    bool moved;
522    ImplicitConstructibleFromA(const A&amp; a)  
523        : x(a.x), moved(false) {}
524    ImplicitConstructibleFromA(A&amp;&amp; a)  
525        : x(a.x), moved(true) {}
526  };
527  TEST(StatusOr, ImplicitConvertingConstructor) {
528    EXPECT_THAT(
529        absl::implicit_cast&lt;absl::StatusOr&lt;ImplicitConstructibleFromA&gt;&gt;(
530            absl::StatusOr&lt;A&gt;(A{11})),
531        IsOkAndHolds(AllOf(Field(&amp;ImplicitConstructibleFromA::x, 11),
532                           Field(&amp;ImplicitConstructibleFromA::moved, true))));
533    absl::StatusOr&lt;A&gt; a(A{12});
534    EXPECT_THAT(
535        absl::implicit_cast&lt;absl::StatusOr&lt;ImplicitConstructibleFromA&gt;&gt;(a),
536        IsOkAndHolds(AllOf(Field(&amp;ImplicitConstructibleFromA::x, 12),
537                           Field(&amp;ImplicitConstructibleFromA::moved, false))));
538  }
539  struct ExplicitConstructibleFromA {
540    int x;
541    bool moved;
542    explicit ExplicitConstructibleFromA(const A&amp; a) : x(a.x), moved(false) {}
543    explicit ExplicitConstructibleFromA(A&amp;&amp; a) : x(a.x), moved(true) {}
544  };
545  TEST(StatusOr, ExplicitConvertingConstructor) {
546    EXPECT_FALSE(
547        (std::is_convertible&lt;const absl::StatusOr&lt;A&gt;&amp;,
548                             absl::StatusOr&lt;ExplicitConstructibleFromA&gt;&gt;::value));
549    EXPECT_FALSE(
550        (std::is_convertible&lt;absl::StatusOr&lt;A&gt;&amp;&amp;,
551                             absl::StatusOr&lt;ExplicitConstructibleFromA&gt;&gt;::value));
552    EXPECT_THAT(
553        absl::StatusOr&lt;ExplicitConstructibleFromA&gt;(absl::StatusOr&lt;A&gt;(A{11})),
554        IsOkAndHolds(AllOf(Field(&amp;ExplicitConstructibleFromA::x, 11),
555                           Field(&amp;ExplicitConstructibleFromA::moved, true))));
556    absl::StatusOr&lt;A&gt; a(A{12});
557    EXPECT_THAT(
558        absl::StatusOr&lt;ExplicitConstructibleFromA&gt;(a),
559        IsOkAndHolds(AllOf(Field(&amp;ExplicitConstructibleFromA::x, 12),
560                           Field(&amp;ExplicitConstructibleFromA::moved, false))));
561  }
562  struct ImplicitConstructibleFromBool {
563    ImplicitConstructibleFromBool(bool y) : x(y) {}  
564    bool x = false;
565  };
566  struct ConvertibleToBool {
567    explicit ConvertibleToBool(bool y) : x(y) {}
568    operator bool() const { return x; }  
569    bool x = false;
570  };
571  TEST(StatusOr, ImplicitBooleanConstructionWithImplicitCasts) {
572    EXPECT_THAT(absl::StatusOr&lt;bool&gt;(absl::StatusOr&lt;ConvertibleToBool&gt;(true)),
573                IsOkAndHolds(true));
574    EXPECT_THAT(absl::StatusOr&lt;bool&gt;(absl::StatusOr&lt;ConvertibleToBool&gt;(false)),
575                IsOkAndHolds(false));
576    EXPECT_THAT(
577        absl::implicit_cast&lt;absl::StatusOr&lt;ImplicitConstructibleFromBool&gt;&gt;(
578            absl::StatusOr&lt;bool&gt;(false)),
579        IsOkAndHolds(Field(&amp;ImplicitConstructibleFromBool::x, false)));
580    EXPECT_FALSE((std::is_convertible&lt;
581                  absl::StatusOr&lt;ConvertibleToBool&gt;,
582                  absl::StatusOr&lt;ImplicitConstructibleFromBool&gt;&gt;::value));
583  }
584  TEST(StatusOr, BooleanConstructionWithImplicitCasts) {
585    EXPECT_THAT(absl::StatusOr&lt;bool&gt;(absl::StatusOr&lt;ConvertibleToBool&gt;(true)),
586                IsOkAndHolds(true));
587    EXPECT_THAT(absl::StatusOr&lt;bool&gt;(absl::StatusOr&lt;ConvertibleToBool&gt;(false)),
588                IsOkAndHolds(false));
589    EXPECT_THAT(
590        absl::StatusOr&lt;ImplicitConstructibleFromBool&gt;{
591            absl::StatusOr&lt;bool&gt;(false)},
592        IsOkAndHolds(Field(&amp;ImplicitConstructibleFromBool::x, false)));
593    EXPECT_THAT(
594        absl::StatusOr&lt;ImplicitConstructibleFromBool&gt;{
595            absl::StatusOr&lt;bool&gt;(absl::InvalidArgumentError(&quot;&quot;))},
596        Not(IsOk()));
597    EXPECT_THAT(
598        absl::StatusOr&lt;ImplicitConstructibleFromBool&gt;{
599            absl::StatusOr&lt;ConvertibleToBool&gt;(ConvertibleToBool{false})},
600        IsOkAndHolds(Field(&amp;ImplicitConstructibleFromBool::x, false)));
601    EXPECT_THAT(
602        absl::StatusOr&lt;ImplicitConstructibleFromBool&gt;{
603            absl::StatusOr&lt;ConvertibleToBool&gt;(absl::InvalidArgumentError(&quot;&quot;))},
604        Not(IsOk()));
605  }
606  TEST(StatusOr, ConstImplicitCast) {
607    EXPECT_THAT(absl::implicit_cast&lt;absl::StatusOr&lt;bool&gt;&gt;(
608                    absl::StatusOr&lt;const bool&gt;(true)),
609                IsOkAndHolds(true));
610    EXPECT_THAT(absl::implicit_cast&lt;absl::StatusOr&lt;bool&gt;&gt;(
611                    absl::StatusOr&lt;const bool&gt;(false)),
612                IsOkAndHolds(false));
613    EXPECT_THAT(absl::implicit_cast&lt;absl::StatusOr&lt;const bool&gt;&gt;(
614                    absl::StatusOr&lt;bool&gt;(true)),
615                IsOkAndHolds(true));
616    EXPECT_THAT(absl::implicit_cast&lt;absl::StatusOr&lt;const bool&gt;&gt;(
617                    absl::StatusOr&lt;bool&gt;(false)),
618                IsOkAndHolds(false));
619    EXPECT_THAT(absl::implicit_cast&lt;absl::StatusOr&lt;const std::string&gt;&gt;(
620                    absl::StatusOr&lt;std::string&gt;(&quot;foo&quot;)),
621                IsOkAndHolds(&quot;foo&quot;));
622    EXPECT_THAT(absl::implicit_cast&lt;absl::StatusOr&lt;std::string&gt;&gt;(
623                    absl::StatusOr&lt;const std::string&gt;(&quot;foo&quot;)),
624                IsOkAndHolds(&quot;foo&quot;));
625    EXPECT_THAT(
626        absl::implicit_cast&lt;absl::StatusOr&lt;std::shared_ptr&lt;const std::string&gt;&gt;&gt;(
627            absl::StatusOr&lt;std::shared_ptr&lt;std::string&gt;&gt;(
628                std::make_shared&lt;std::string&gt;(&quot;foo&quot;))),
629        IsOkAndHolds(Pointee(std::string(&quot;foo&quot;))));
630  }
631  TEST(StatusOr, ConstExplicitConstruction) {
632    EXPECT_THAT(absl::StatusOr&lt;bool&gt;(absl::StatusOr&lt;const bool&gt;(true)),
633                IsOkAndHolds(true));
634    EXPECT_THAT(absl::StatusOr&lt;bool&gt;(absl::StatusOr&lt;const bool&gt;(false)),
635                IsOkAndHolds(false));
636    EXPECT_THAT(absl::StatusOr&lt;const bool&gt;(absl::StatusOr&lt;bool&gt;(true)),
637                IsOkAndHolds(true));
638    EXPECT_THAT(absl::StatusOr&lt;const bool&gt;(absl::StatusOr&lt;bool&gt;(false)),
639                IsOkAndHolds(false));
640  }
641  struct ExplicitConstructibleFromInt {
642    int x;
643    explicit ExplicitConstructibleFromInt(int y) : x(y) {}
644  };
645  TEST(StatusOr, ExplicitConstruction) {
646    EXPECT_THAT(absl::StatusOr&lt;ExplicitConstructibleFromInt&gt;(10),
647                IsOkAndHolds(Field(&amp;ExplicitConstructibleFromInt::x, 10)));
648  }
649  TEST(StatusOr, ImplicitConstruction) {
650    auto status_or =
651        absl::implicit_cast&lt;absl::StatusOr&lt;absl::variant&lt;int, std::string&gt;&gt;&gt;(10);
652    EXPECT_THAT(status_or, IsOkAndHolds(VariantWith&lt;int&gt;(10)));
653  }
654  TEST(StatusOr, ImplicitConstructionFromInitliazerList) {
655    auto status_or =
656        absl::implicit_cast&lt;absl::StatusOr&lt;std::vector&lt;int&gt;&gt;&gt;({{10, 20, 30}});
657    EXPECT_THAT(status_or, IsOkAndHolds(ElementsAre(10, 20, 30)));
658  }
659  TEST(StatusOr, UniquePtrImplicitConstruction) {
660    auto status_or = absl::implicit_cast&lt;absl::StatusOr&lt;std::unique_ptr&lt;Base1&gt;&gt;&gt;(
661        absl::make_unique&lt;Derived&gt;());
662    EXPECT_THAT(status_or, IsOkAndHolds(Ne(nullptr)));
663  }
664  TEST(StatusOr, NestedStatusOrCopyAndMoveConstructorTests) {
665    absl::StatusOr&lt;absl::StatusOr&lt;CopyDetector&gt;&gt; status_or = CopyDetector(10);
666    absl::StatusOr&lt;absl::StatusOr&lt;CopyDetector&gt;&gt; status_error =
667        absl::InvalidArgumentError(&quot;foo&quot;);
668    EXPECT_THAT(status_or,
669                IsOkAndHolds(IsOkAndHolds(CopyDetectorHas(10, true, false))));
670    absl::StatusOr&lt;absl::StatusOr&lt;CopyDetector&gt;&gt; a = status_or;
671    EXPECT_THAT(a, IsOkAndHolds(IsOkAndHolds(CopyDetectorHas(10, false, true))));
672    absl::StatusOr&lt;absl::StatusOr&lt;CopyDetector&gt;&gt; a_err = status_error;
673    EXPECT_THAT(a_err, Not(IsOk()));
674    const absl::StatusOr&lt;absl::StatusOr&lt;CopyDetector&gt;&gt;&amp; cref = status_or;
675    absl::StatusOr&lt;absl::StatusOr&lt;CopyDetector&gt;&gt; b = cref;  
676    EXPECT_THAT(b, IsOkAndHolds(IsOkAndHolds(CopyDetectorHas(10, false, true))));
677    const absl::StatusOr&lt;absl::StatusOr&lt;CopyDetector&gt;&gt;&amp; cref_err = status_error;
678    absl::StatusOr&lt;absl::StatusOr&lt;CopyDetector&gt;&gt; b_err = cref_err;  
679    EXPECT_THAT(b_err, Not(IsOk()));
680    absl::StatusOr&lt;absl::StatusOr&lt;CopyDetector&gt;&gt; c = std::move(status_or);
681    EXPECT_THAT(c, IsOkAndHolds(IsOkAndHolds(CopyDetectorHas(10, true, false))));
682    absl::StatusOr&lt;absl::StatusOr&lt;CopyDetector&gt;&gt; c_err = std::move(status_error);
683    EXPECT_THAT(c_err, Not(IsOk()));
684  }
685  TEST(StatusOr, NestedStatusOrCopyAndMoveAssignment) {
686    absl::StatusOr&lt;absl::StatusOr&lt;CopyDetector&gt;&gt; status_or = CopyDetector(10);
687    absl::StatusOr&lt;absl::StatusOr&lt;CopyDetector&gt;&gt; status_error =
688        absl::InvalidArgumentError(&quot;foo&quot;);
689    absl::StatusOr&lt;absl::StatusOr&lt;CopyDetector&gt;&gt; a;
690    a = status_or;
691    EXPECT_THAT(a, IsOkAndHolds(IsOkAndHolds(CopyDetectorHas(10, false, true))));
692    a = status_error;
693    EXPECT_THAT(a, Not(IsOk()));
694    const absl::StatusOr&lt;absl::StatusOr&lt;CopyDetector&gt;&gt;&amp; cref = status_or;
695    a = cref;
696    EXPECT_THAT(a, IsOkAndHolds(IsOkAndHolds(CopyDetectorHas(10, false, true))));
697    const absl::StatusOr&lt;absl::StatusOr&lt;CopyDetector&gt;&gt;&amp; cref_err = status_error;
698    a = cref_err;
699    EXPECT_THAT(a, Not(IsOk()));
700    a = std::move(status_or);
701    EXPECT_THAT(a, IsOkAndHolds(IsOkAndHolds(CopyDetectorHas(10, true, false))));
702    a = std::move(status_error);
703    EXPECT_THAT(a, Not(IsOk()));
704  }
705  struct Copyable {
706    Copyable() {}
707    Copyable(const Copyable&amp;) {}
708    Copyable&amp; operator=(const Copyable&amp;) { return *this; }
709  };
710  struct MoveOnly {
711    MoveOnly() {}
712    MoveOnly(MoveOnly&amp;&amp;) {}
713    MoveOnly&amp; operator=(MoveOnly&amp;&amp;) { return *this; }
714  };
715  struct NonMovable {
716    NonMovable() {}
717    NonMovable(const NonMovable&amp;) = delete;
718    NonMovable(NonMovable&amp;&amp;) = delete;
719    NonMovable&amp; operator=(const NonMovable&amp;) = delete;
720    NonMovable&amp; operator=(NonMovable&amp;&amp;) = delete;
721  };
722  TEST(StatusOr, CopyAndMoveAbility) {
723    EXPECT_TRUE(std::is_copy_constructible&lt;Copyable&gt;::value);
724    EXPECT_TRUE(std::is_copy_assignable&lt;Copyable&gt;::value);
725    EXPECT_TRUE(std::is_move_constructible&lt;Copyable&gt;::value);
726    EXPECT_TRUE(std::is_move_assignable&lt;Copyable&gt;::value);
727    EXPECT_FALSE(std::is_copy_constructible&lt;MoveOnly&gt;::value);
728    EXPECT_FALSE(std::is_copy_assignable&lt;MoveOnly&gt;::value);
729    EXPECT_TRUE(std::is_move_constructible&lt;MoveOnly&gt;::value);
730    EXPECT_TRUE(std::is_move_assignable&lt;MoveOnly&gt;::value);
731    EXPECT_FALSE(std::is_copy_constructible&lt;NonMovable&gt;::value);
732    EXPECT_FALSE(std::is_copy_assignable&lt;NonMovable&gt;::value);
733    EXPECT_FALSE(std::is_move_constructible&lt;NonMovable&gt;::value);
734    EXPECT_FALSE(std::is_move_assignable&lt;NonMovable&gt;::value);
735  }
736  TEST(StatusOr, StatusOrAnyCopyAndMoveConstructorTests) {
737    absl::StatusOr&lt;absl::any&gt; status_or = CopyDetector(10);
738    absl::StatusOr&lt;absl::any&gt; status_error = absl::InvalidArgumentError(&quot;foo&quot;);
739    EXPECT_THAT(
740        status_or,
741        IsOkAndHolds(AnyWith&lt;CopyDetector&gt;(CopyDetectorHas(10, true, false))));
742    absl::StatusOr&lt;absl::any&gt; a = status_or;
743    EXPECT_THAT(
744        a, IsOkAndHolds(AnyWith&lt;CopyDetector&gt;(CopyDetectorHas(10, false, true))));
745    absl::StatusOr&lt;absl::any&gt; a_err = status_error;
746    EXPECT_THAT(a_err, Not(IsOk()));
747    const absl::StatusOr&lt;absl::any&gt;&amp; cref = status_or;
748    absl::StatusOr&lt;absl::any&gt; b = cref;  
749    EXPECT_THAT(
750        b, IsOkAndHolds(AnyWith&lt;CopyDetector&gt;(CopyDetectorHas(10, false, true))));
751    const absl::StatusOr&lt;absl::any&gt;&amp; cref_err = status_error;
752    absl::StatusOr&lt;absl::any&gt; b_err = cref_err;  
753    EXPECT_THAT(b_err, Not(IsOk()));
754    absl::StatusOr&lt;absl::any&gt; c = std::move(status_or);
755    EXPECT_THAT(
756        c, IsOkAndHolds(AnyWith&lt;CopyDetector&gt;(CopyDetectorHas(10, true, false))));
757    absl::StatusOr&lt;absl::any&gt; c_err = std::move(status_error);
758    EXPECT_THAT(c_err, Not(IsOk()));
759  }
760  TEST(StatusOr, StatusOrAnyCopyAndMoveAssignment) {
761    absl::StatusOr&lt;absl::any&gt; status_or = CopyDetector(10);
762    absl::StatusOr&lt;absl::any&gt; status_error = absl::InvalidArgumentError(&quot;foo&quot;);
763    absl::StatusOr&lt;absl::any&gt; a;
764    a = status_or;
765    EXPECT_THAT(
766        a, IsOkAndHolds(AnyWith&lt;CopyDetector&gt;(CopyDetectorHas(10, false, true))));
767    a = status_error;
768    EXPECT_THAT(a, Not(IsOk()));
769    const absl::StatusOr&lt;absl::any&gt;&amp; cref = status_or;
770    a = cref;
771    EXPECT_THAT(
772        a, IsOkAndHolds(AnyWith&lt;CopyDetector&gt;(CopyDetectorHas(10, false, true))));
773    const absl::StatusOr&lt;absl::any&gt;&amp; cref_err = status_error;
774    a = cref_err;
775    EXPECT_THAT(a, Not(IsOk()));
776    a = std::move(status_or);
777    EXPECT_THAT(
778        a, IsOkAndHolds(AnyWith&lt;CopyDetector&gt;(CopyDetectorHas(10, true, false))));
779    a = std::move(status_error);
780    EXPECT_THAT(a, Not(IsOk()));
781  }
782  TEST(StatusOr, StatusOrCopyAndMoveTestsConstructor) {
783    absl::StatusOr&lt;CopyDetector&gt; status_or(10);
784    ASSERT_THAT(status_or, IsOkAndHolds(CopyDetectorHas(10, false, false)));
785    absl::StatusOr&lt;CopyDetector&gt; a(status_or);
786    EXPECT_THAT(a, IsOkAndHolds(CopyDetectorHas(10, false, true)));
787    const absl::StatusOr&lt;CopyDetector&gt;&amp; cref = status_or;
788    absl::StatusOr&lt;CopyDetector&gt; b(cref);  
789    EXPECT_THAT(b, IsOkAndHolds(CopyDetectorHas(10, false, true)));
790    absl::StatusOr&lt;CopyDetector&gt; c(std::move(status_or));
791    EXPECT_THAT(c, IsOkAndHolds(CopyDetectorHas(10, true, false)));
792  }
793  TEST(StatusOr, StatusOrCopyAndMoveTestsAssignment) {
794    absl::StatusOr&lt;CopyDetector&gt; status_or(10);
795    ASSERT_THAT(status_or, IsOkAndHolds(CopyDetectorHas(10, false, false)));
796    absl::StatusOr&lt;CopyDetector&gt; a;
797    a = status_or;
798    EXPECT_THAT(a, IsOkAndHolds(CopyDetectorHas(10, false, true)));
799    const absl::StatusOr&lt;CopyDetector&gt;&amp; cref = status_or;
800    absl::StatusOr&lt;CopyDetector&gt; b;
801    b = cref;
802    EXPECT_THAT(b, IsOkAndHolds(CopyDetectorHas(10, false, true)));
803    absl::StatusOr&lt;CopyDetector&gt; c;
804    c = std::move(status_or);
805    EXPECT_THAT(c, IsOkAndHolds(CopyDetectorHas(10, true, false)));
806  }
807  TEST(StatusOr, AbslAnyAssignment) {
808    EXPECT_FALSE((std::is_assignable&lt;absl::StatusOr&lt;absl::any&gt;,
809                                     absl::StatusOr&lt;int&gt;&gt;::value));
810    absl::StatusOr&lt;absl::any&gt; status_or;
811    status_or = absl::InvalidArgumentError(&quot;foo&quot;);
812    EXPECT_THAT(status_or, Not(IsOk()));
813  }
814  TEST(StatusOr, ImplicitAssignment) {
815    absl::StatusOr&lt;absl::variant&lt;int, std::string&gt;&gt; status_or;
816    status_or = 10;
817    EXPECT_THAT(status_or, IsOkAndHolds(VariantWith&lt;int&gt;(10)));
818  }
819  TEST(StatusOr, SelfDirectInitAssignment) {
820    absl::StatusOr&lt;std::vector&lt;int&gt;&gt; status_or = {{10, 20, 30}};
821    status_or = *status_or;
822    EXPECT_THAT(status_or, IsOkAndHolds(ElementsAre(10, 20, 30)));
823  }
824  TEST(StatusOr, ImplicitCastFromInitializerList) {
825    absl::StatusOr&lt;std::vector&lt;int&gt;&gt; status_or = {{10, 20, 30}};
826    EXPECT_THAT(status_or, IsOkAndHolds(ElementsAre(10, 20, 30)));
827  }
828  TEST(StatusOr, UniquePtrImplicitAssignment) {
829    absl::StatusOr&lt;std::unique_ptr&lt;Base1&gt;&gt; status_or;
830    status_or = absl::make_unique&lt;Derived&gt;();
831    EXPECT_THAT(status_or, IsOkAndHolds(Ne(nullptr)));
832  }
833  TEST(StatusOr, Pointer) {
834    struct A {};
835    struct B : public A {};
836    struct C : private A {};
837    EXPECT_TRUE((std::is_constructible&lt;absl::StatusOr&lt;A*&gt;, B*&gt;::value));
838    EXPECT_TRUE((std::is_convertible&lt;B*, absl::StatusOr&lt;A*&gt;&gt;::value));
839    EXPECT_FALSE((std::is_constructible&lt;absl::StatusOr&lt;A*&gt;, C*&gt;::value));
840    EXPECT_FALSE((std::is_convertible&lt;C*, absl::StatusOr&lt;A*&gt;&gt;::value));
841  }
842  TEST(StatusOr, TestAssignmentStatusNotOkConverting) {
843    {
844      const absl::Status expected = absl::CancelledError();
845      absl::StatusOr&lt;int&gt; source(expected);
846      absl::StatusOr&lt;double&gt; target;
847      target = source;
848      EXPECT_FALSE(target.ok());
849      EXPECT_EQ(expected, target.status());
850      EXPECT_FALSE(source.ok());
851      EXPECT_EQ(expected, source.status());
852    }
853    {
854      const absl::Status expected = absl::CancelledError();
855      absl::StatusOr&lt;int&gt; source(expected);
856      absl::StatusOr&lt;double&gt; target;
857      target = std::move(source);
858      EXPECT_FALSE(target.ok());
859      EXPECT_EQ(expected, target.status());
860      EXPECT_FALSE(source.ok());
861      EXPECT_EQ(source.status().code(), absl::StatusCode::kInternal);
862    }
863  }
864  TEST(StatusOr, SelfAssignment) {
865    {
866      const std::string long_str(128, &#x27;a&#x27;);
867      absl::StatusOr&lt;std::string&gt; so = long_str;
868      so = *&amp;so;
869      ASSERT_TRUE(so.ok());
870      EXPECT_OK(so.status());
871      EXPECT_EQ(long_str, *so);
872    }
873    {
874      absl::StatusOr&lt;int&gt; so = absl::NotFoundError(&quot;taco&quot;);
875      so = *&amp;so;
876      EXPECT_FALSE(so.ok());
877      EXPECT_EQ(so.status().code(), absl::StatusCode::kNotFound);
878      EXPECT_EQ(so.status().message(), &quot;taco&quot;);
879    }
880    {
881      absl::StatusOr&lt;int&gt; so = 17;
882      auto&amp; same = so;
883      so = std::move(same);
884      ASSERT_TRUE(so.ok());
885      EXPECT_OK(so.status());
886      EXPECT_EQ(17, *so);
887    }
888    {
889      absl::StatusOr&lt;int&gt; so = absl::NotFoundError(&quot;taco&quot;);
890      auto&amp; same = so;
891      so = std::move(same);
892      EXPECT_FALSE(so.ok());
893      EXPECT_EQ(so.status().code(), absl::StatusCode::kNotFound);
894      EXPECT_EQ(so.status().message(), &quot;taco&quot;);
895    }
896    {
897      const auto raw = new int(17);
898      absl::StatusOr&lt;std::unique_ptr&lt;int&gt;&gt; so = absl::WrapUnique(raw);
899      auto&amp; same = so;
900      so = std::move(same);
901      ASSERT_TRUE(so.ok());
902      EXPECT_OK(so.status());
903      EXPECT_EQ(raw, so-&gt;get());
904    }
905    {
906      absl::StatusOr&lt;std::unique_ptr&lt;int&gt;&gt; so = absl::NotFoundError(&quot;taco&quot;);
907      auto&amp; same = so;
908      so = std::move(same);
909      EXPECT_FALSE(so.ok());
910      EXPECT_EQ(so.status().code(), absl::StatusCode::kNotFound);
911      EXPECT_EQ(so.status().message(), &quot;taco&quot;);
912    }
913  }
914  struct FromConstructibleAssignableLvalue {};
915  struct FromConstructibleAssignableRvalue {};
916  struct FromImplicitConstructibleOnly {};
917  struct FromAssignableOnly {};
918  struct MockValue {
919    MockValue(const FromConstructibleAssignableLvalue&amp;)  
920        : from_rvalue(false), assigned(false) {}
921    MockValue(FromConstructibleAssignableRvalue&amp;&amp;)  
922        : from_rvalue(true), assigned(false) {}
923    MockValue(const FromImplicitConstructibleOnly&amp;)  
924        : from_rvalue(false), assigned(false) {}
925    MockValue&amp; operator=(const FromConstructibleAssignableLvalue&amp;) {
926      from_rvalue = false;
927      assigned = true;
928      return *this;
929    }
930    MockValue&amp; operator=(FromConstructibleAssignableRvalue&amp;&amp;) {
931      from_rvalue = true;
932      assigned = true;
933      return *this;
934    }
935    MockValue&amp; operator=(const FromAssignableOnly&amp;) {
936      from_rvalue = false;
937      assigned = true;
938      return *this;
939    }
940    bool from_rvalue;
941    bool assigned;
942  };
943  TEST(StatusOr, PerfectForwardingAssignment) {
944    constexpr int kValue1 = 10, kValue2 = 20;
945    absl::StatusOr&lt;CopyDetector&gt; status_or;
946    CopyDetector lvalue(kValue1);
947    status_or = lvalue;
948    EXPECT_THAT(status_or, IsOkAndHolds(CopyDetectorHas(kValue1, false, true)));
949    status_or = CopyDetector(kValue2);
950    EXPECT_THAT(status_or, IsOkAndHolds(CopyDetectorHas(kValue2, true, false)));
951    EXPECT_TRUE(
952        (std::is_assignable&lt;absl::StatusOr&lt;MockValue&gt;&amp;,
953                            const FromConstructibleAssignableLvalue&amp;&gt;::value));
954    EXPECT_TRUE((std::is_assignable&lt;absl::StatusOr&lt;MockValue&gt;&amp;,
955                                    FromConstructibleAssignableLvalue&amp;&amp;&gt;::value));
956    EXPECT_FALSE(
957        (std::is_assignable&lt;absl::StatusOr&lt;MockValue&gt;&amp;,
958                            const FromConstructibleAssignableRvalue&amp;&gt;::value));
959    EXPECT_TRUE((std::is_assignable&lt;absl::StatusOr&lt;MockValue&gt;&amp;,
960                                    FromConstructibleAssignableRvalue&amp;&amp;&gt;::value));
961    EXPECT_TRUE(
962        (std::is_assignable&lt;absl::StatusOr&lt;MockValue&gt;&amp;,
963                            const FromImplicitConstructibleOnly&amp;&gt;::value));
964    EXPECT_FALSE((std::is_assignable&lt;absl::StatusOr&lt;MockValue&gt;&amp;,
965                                     const FromAssignableOnly&amp;&gt;::value));
966    absl::StatusOr&lt;MockValue&gt; from_lvalue(FromConstructibleAssignableLvalue{});
967    EXPECT_FALSE(from_lvalue-&gt;from_rvalue);
968    EXPECT_FALSE(from_lvalue-&gt;assigned);
969    from_lvalue = FromConstructibleAssignableLvalue{};
970    EXPECT_FALSE(from_lvalue-&gt;from_rvalue);
971    EXPECT_TRUE(from_lvalue-&gt;assigned);
972    absl::StatusOr&lt;MockValue&gt; from_rvalue(FromConstructibleAssignableRvalue{});
973    EXPECT_TRUE(from_rvalue-&gt;from_rvalue);
974    EXPECT_FALSE(from_rvalue-&gt;assigned);
975    from_rvalue = FromConstructibleAssignableRvalue{};
976    EXPECT_TRUE(from_rvalue-&gt;from_rvalue);
977    EXPECT_TRUE(from_rvalue-&gt;assigned);
978    absl::StatusOr&lt;MockValue&gt; from_implicit_constructible(
979        FromImplicitConstructibleOnly{});
980    EXPECT_FALSE(from_implicit_constructible-&gt;from_rvalue);
981    EXPECT_FALSE(from_implicit_constructible-&gt;assigned);
982    from_implicit_constructible = FromImplicitConstructibleOnly{};
983    EXPECT_FALSE(from_implicit_constructible-&gt;from_rvalue);
984    EXPECT_FALSE(from_implicit_constructible-&gt;assigned);
985  }
986  TEST(StatusOr, TestStatus) {
987    absl::StatusOr&lt;int&gt; good(4);
988    EXPECT_TRUE(good.ok());
989    absl::StatusOr&lt;int&gt; bad(absl::CancelledError());
990    EXPECT_FALSE(bad.ok());
991    EXPECT_EQ(bad.status().code(), absl::StatusCode::kCancelled);
992  }
993  TEST(StatusOr, OperatorStarRefQualifiers) {
994    static_assert(
995        std::is_same&lt;const int&amp;,
996                     decltype(*std::declval&lt;const absl::StatusOr&lt;int&gt;&amp;&gt;())&gt;(),
997        &quot;Unexpected ref-qualifiers&quot;);
998    static_assert(
999        std::is_same&lt;int&amp;, decltype(*std::declval&lt;absl::StatusOr&lt;int&gt;&amp;&gt;())&gt;(),
1000        &quot;Unexpected ref-qualifiers&quot;);
1001    static_assert(
1002        std::is_same&lt;const int&amp;&amp;,
1003                     decltype(*std::declval&lt;const absl::StatusOr&lt;int&gt;&amp;&amp;&gt;())&gt;(),
1004        &quot;Unexpected ref-qualifiers&quot;);
1005    static_assert(
1006        std::is_same&lt;int&amp;&amp;, decltype(*std::declval&lt;absl::StatusOr&lt;int&gt;&amp;&amp;&gt;())&gt;(),
1007        &quot;Unexpected ref-qualifiers&quot;);
1008  }
1009  TEST(StatusOr, OperatorStar) {
1010    const absl::StatusOr&lt;std::string&gt; const_lvalue(&quot;hello&quot;);
1011    EXPECT_EQ(&quot;hello&quot;, *const_lvalue);
1012    absl::StatusOr&lt;std::string&gt; lvalue(&quot;hello&quot;);
1013    EXPECT_EQ(&quot;hello&quot;, *lvalue);
1014    const absl::StatusOr&lt;std::string&gt; const_rvalue(&quot;hello&quot;);
1015    EXPECT_EQ(&quot;hello&quot;, *std::move(const_rvalue));  
1016    absl::StatusOr&lt;std::string&gt; rvalue(&quot;hello&quot;);
1017    EXPECT_EQ(&quot;hello&quot;, *std::move(rvalue));
1018  }
1019  TEST(StatusOr, OperatorArrowQualifiers) {
1020    static_assert(
1021        std::is_same&lt;
1022            const int*,
1023            decltype(std::declval&lt;const absl::StatusOr&lt;int&gt;&amp;&gt;().operator-&gt;())&gt;(),
1024        &quot;Unexpected qualifiers&quot;);
1025    static_assert(
1026        std::is_same&lt;
1027            int*, decltype(std::declval&lt;absl::StatusOr&lt;int&gt;&amp;&gt;().operator-&gt;())&gt;(),
1028        &quot;Unexpected qualifiers&quot;);
1029    static_assert(
1030        std::is_same&lt;
1031            const int*,
1032            decltype(std::declval&lt;const absl::StatusOr&lt;int&gt;&amp;&amp;&gt;().operator-&gt;())&gt;(),
1033        &quot;Unexpected qualifiers&quot;);
1034    static_assert(
1035        std::is_same&lt;
1036            int*, decltype(std::declval&lt;absl::StatusOr&lt;int&gt;&amp;&amp;&gt;().operator-&gt;())&gt;(),
1037        &quot;Unexpected qualifiers&quot;);
1038  }
1039  TEST(StatusOr, OperatorArrow) {
1040    const absl::StatusOr&lt;std::string&gt; const_lvalue(&quot;hello&quot;);
1041    EXPECT_EQ(std::string(&quot;hello&quot;), const_lvalue-&gt;c_str());
1042    absl::StatusOr&lt;std::string&gt; lvalue(&quot;hello&quot;);
1043    EXPECT_EQ(std::string(&quot;hello&quot;), lvalue-&gt;c_str());
1044  }
1045  TEST(StatusOr, RValueStatus) {
1046    absl::StatusOr&lt;int&gt; so(absl::NotFoundError(&quot;taco&quot;));
1047    const absl::Status s = std::move(so).status();
1048    EXPECT_EQ(s.code(), absl::StatusCode::kNotFound);
1049    EXPECT_EQ(s.message(), &quot;taco&quot;);
1050    EXPECT_FALSE(so.ok());  
1051    EXPECT_FALSE(so.status().ok());
1052    EXPECT_EQ(so.status().code(), absl::StatusCode::kInternal);
1053    EXPECT_EQ(so.status().message(), &quot;Status accessed after move.&quot;);
1054  }
1055  TEST(StatusOr, TestValue) {
1056    const int kI = 4;
1057    absl::StatusOr&lt;int&gt; thing(kI);
1058    EXPECT_EQ(kI, *thing);
1059  }
1060  TEST(StatusOr, TestValueConst) {
1061    const int kI = 4;
1062    const absl::StatusOr&lt;int&gt; thing(kI);
1063    EXPECT_EQ(kI, *thing);
1064  }
1065  TEST(StatusOr, TestPointerDefaultCtor) {
1066    absl::StatusOr&lt;int*&gt; thing;
1067    EXPECT_FALSE(thing.ok());
1068    EXPECT_EQ(thing.status().code(), absl::StatusCode::kUnknown);
1069  }
1070  TEST(StatusOr, TestPointerStatusCtor) {
1071    absl::StatusOr&lt;int*&gt; thing(absl::CancelledError());
1072    EXPECT_FALSE(thing.ok());
1073    EXPECT_EQ(thing.status().code(), absl::StatusCode::kCancelled);
1074  }
1075  TEST(StatusOr, TestPointerValueCtor) {
1076    const int kI = 4;
1077    {
1078      absl::StatusOr&lt;const int*&gt; so(&amp;kI);
1079      EXPECT_TRUE(so.ok());
1080      EXPECT_OK(so.status());
1081      EXPECT_EQ(&amp;kI, *so);
1082    }
1083    {
1084      absl::StatusOr&lt;const int*&gt; so(nullptr);
1085      EXPECT_TRUE(so.ok());
1086      EXPECT_OK(so.status());
1087      EXPECT_EQ(nullptr, *so);
1088    }
1089    {
1090      const int* const p = nullptr;
1091      absl::StatusOr&lt;const int*&gt; so(p);
1092      EXPECT_TRUE(so.ok());
1093      EXPECT_OK(so.status());
1094      EXPECT_EQ(nullptr, *so);
1095    }
1096  }
1097  TEST(StatusOr, TestPointerCopyCtorStatusOk) {
1098    const int kI = 0;
1099    absl::StatusOr&lt;const int*&gt; original(&amp;kI);
1100    absl::StatusOr&lt;const int*&gt; copy(original);
1101    EXPECT_OK(copy.status());
1102    EXPECT_EQ(*original, *copy);
1103  }
1104  TEST(StatusOr, TestPointerCopyCtorStatusNotOk) {
1105    absl::StatusOr&lt;int*&gt; original(absl::CancelledError());
1106    absl::StatusOr&lt;int*&gt; copy(original);
1107    EXPECT_EQ(copy.status().code(), absl::StatusCode::kCancelled);
1108  }
1109  TEST(StatusOr, TestPointerCopyCtorStatusOKConverting) {
1110    Derived derived;
1111    absl::StatusOr&lt;Derived*&gt; original(&amp;derived);
1112    absl::StatusOr&lt;Base2*&gt; copy(original);
1113    EXPECT_OK(copy.status());
1114    EXPECT_EQ(static_cast&lt;const Base2*&gt;(*original), *copy);
1115  }
1116  TEST(StatusOr, TestPointerCopyCtorStatusNotOkConverting) {
1117    absl::StatusOr&lt;Derived*&gt; original(absl::CancelledError());
1118    absl::StatusOr&lt;Base2*&gt; copy(original);
1119    EXPECT_EQ(copy.status().code(), absl::StatusCode::kCancelled);
1120  }
1121  TEST(StatusOr, TestPointerAssignmentStatusOk) {
1122    const int kI = 0;
1123    absl::StatusOr&lt;const int*&gt; source(&amp;kI);
1124    absl::StatusOr&lt;const int*&gt; target;
1125    target = source;
1126    EXPECT_OK(target.status());
1127    EXPECT_EQ(*source, *target);
1128  }
1129  TEST(StatusOr, TestPointerAssignmentStatusNotOk) {
1130    absl::StatusOr&lt;int*&gt; source(absl::CancelledError());
1131    absl::StatusOr&lt;int*&gt; target;
1132    target = source;
1133    EXPECT_EQ(target.status().code(), absl::StatusCode::kCancelled);
1134  }
1135  TEST(StatusOr, TestPointerAssignmentStatusOKConverting) {
1136    Derived derived;
1137    absl::StatusOr&lt;Derived*&gt; source(&amp;derived);
1138    absl::StatusOr&lt;Base2*&gt; target;
1139    target = source;
1140    EXPECT_OK(target.status());
1141    EXPECT_EQ(static_cast&lt;const Base2*&gt;(*source), *target);
1142  }
1143  TEST(StatusOr, TestPointerAssignmentStatusNotOkConverting) {
1144    absl::StatusOr&lt;Derived*&gt; source(absl::CancelledError());
1145    absl::StatusOr&lt;Base2*&gt; target;
1146    target = source;
1147    EXPECT_EQ(target.status(), source.status());
1148  }
1149  TEST(StatusOr, TestPointerStatus) {
1150    const int kI = 0;
1151    absl::StatusOr&lt;const int*&gt; good(&amp;kI);
1152    EXPECT_TRUE(good.ok());
1153    absl::StatusOr&lt;const int*&gt; bad(absl::CancelledError());
1154    EXPECT_EQ(bad.status().code(), absl::StatusCode::kCancelled);
1155  }
1156  TEST(StatusOr, TestPointerValue) {
1157    const int kI = 0;
1158    absl::StatusOr&lt;const int*&gt; thing(&amp;kI);
1159    EXPECT_EQ(&amp;kI, *thing);
1160  }
1161  TEST(StatusOr, TestPointerValueConst) {
1162    const int kI = 0;
1163    const absl::StatusOr&lt;const int*&gt; thing(&amp;kI);
1164    EXPECT_EQ(&amp;kI, *thing);
1165  }
1166  TEST(StatusOr, StatusOrVectorOfUniquePointerCanReserveAndResize) {
1167    using EvilType = std::vector&lt;std::unique_ptr&lt;int&gt;&gt;;
1168    static_assert(std::is_copy_constructible&lt;EvilType&gt;::value, &quot;&quot;);
1169    std::vector&lt;::absl::StatusOr&lt;EvilType&gt;&gt; v(5);
1170    v.reserve(v.capacity() + 10);
1171    v.resize(v.capacity() + 10);
1172  }
1173  TEST(StatusOr, ConstPayload) {
1174    absl::StatusOr&lt;const int&gt; a;
1175    absl::StatusOr&lt;const int&gt; b(a);
1176    EXPECT_FALSE(std::is_copy_assignable&lt;absl::StatusOr&lt;const int&gt;&gt;::value);
1177    absl::StatusOr&lt;const int&gt; c(std::move(a));
1178    EXPECT_FALSE(std::is_move_assignable&lt;absl::StatusOr&lt;const int&gt;&gt;::value);
1179  }
1180  TEST(StatusOr, MapToStatusOrUniquePtr) {
1181    using MapType = std::map&lt;std::string, absl::StatusOr&lt;std::unique_ptr&lt;int&gt;&gt;&gt;;
1182    MapType a;
1183    MapType b(std::move(a));
1184    a = std::move(b);
1185  }
1186  TEST(StatusOr, ValueOrOk) {
1187    const absl::StatusOr&lt;int&gt; status_or = 0;
1188    EXPECT_EQ(status_or.value_or(-1), 0);
1189  }
1190  TEST(StatusOr, ValueOrDefault) {
1191    const absl::StatusOr&lt;int&gt; status_or = absl::CancelledError();
1192    EXPECT_EQ(status_or.value_or(-1), -1);
1193  }
1194  TEST(StatusOr, MoveOnlyValueOrOk) {
1195    EXPECT_THAT(absl::StatusOr&lt;std::unique_ptr&lt;int&gt;&gt;(absl::make_unique&lt;int&gt;(0))
1196                    .value_or(absl::make_unique&lt;int&gt;(-1)),
1197                Pointee(0));
1198  }
1199  TEST(StatusOr, MoveOnlyValueOrDefault) {
1200    EXPECT_THAT(absl::StatusOr&lt;std::unique_ptr&lt;int&gt;&gt;(absl::CancelledError())
1201                    .value_or(absl::make_unique&lt;int&gt;(-1)),
1202                Pointee(-1));
1203  }
1204  static absl::StatusOr&lt;int&gt; MakeStatus() { return 100; }
1205  TEST(StatusOr, TestIgnoreError) { MakeStatus().IgnoreError(); }
1206  TEST(StatusOr, EqualityOperator) {
1207    constexpr size_t kNumCases = 4;
1208    std::array&lt;absl::StatusOr&lt;int&gt;, kNumCases&gt; group1 = {
1209        absl::StatusOr&lt;int&gt;(1), absl::StatusOr&lt;int&gt;(2),
1210        absl::StatusOr&lt;int&gt;(absl::InvalidArgumentError(&quot;msg&quot;)),
1211        absl::StatusOr&lt;int&gt;(absl::InternalError(&quot;msg&quot;))};
1212    std::array&lt;absl::StatusOr&lt;int&gt;, kNumCases&gt; group2 = {
1213        absl::StatusOr&lt;int&gt;(1), absl::StatusOr&lt;int&gt;(2),
1214        absl::StatusOr&lt;int&gt;(absl::InvalidArgumentError(&quot;msg&quot;)),
1215        absl::StatusOr&lt;int&gt;(absl::InternalError(&quot;msg&quot;))};
1216    for (size_t i = 0; i &lt; kNumCases; ++i) {
1217      for (size_t j = 0; j &lt; kNumCases; ++j) {
1218        if (i == j) {
1219          EXPECT_TRUE(group1[i] == group2[j]);
1220          EXPECT_FALSE(group1[i] != group2[j]);
1221        } else {
1222          EXPECT_FALSE(group1[i] == group2[j]);
1223          EXPECT_TRUE(group1[i] != group2[j]);
1224        }
1225      }
1226    }
1227  }
1228  struct MyType {
1229    bool operator==(const MyType&amp;) const { return true; }
1230  };
1231  enum class ConvTraits { kNone = 0, kImplicit = 1, kExplicit = 2 };
1232  template &lt;typename T, ConvTraits conv_traits = ConvTraits::kNone&gt;
1233  struct StatusOrConversionBase {};
1234  template &lt;typename T&gt;
1235  struct StatusOrConversionBase&lt;T, ConvTraits::kImplicit&gt; {
1236    operator absl::StatusOr&lt;T&gt;() const&amp; {  
1237      return absl::InvalidArgumentError(&quot;conversion to absl::StatusOr&quot;);
1238    }
1239    operator absl::StatusOr&lt;T&gt;() &amp;&amp; {  
1240      return absl::InvalidArgumentError(&quot;conversion to absl::StatusOr&quot;);
1241    }
1242  };
1243  template &lt;typename T&gt;
1244  struct StatusOrConversionBase&lt;T, ConvTraits::kExplicit&gt; {
1245    explicit operator absl::StatusOr&lt;T&gt;() const&amp; {
1246      return absl::InvalidArgumentError(&quot;conversion to absl::StatusOr&quot;);
1247    }
1248    explicit operator absl::StatusOr&lt;T&gt;() &amp;&amp; {
1249      return absl::InvalidArgumentError(&quot;conversion to absl::StatusOr&quot;);
1250    }
1251  };
1252  template &lt;typename T, ConvTraits conv_traits = ConvTraits::kNone&gt;
1253  struct ConversionBase {};
1254  template &lt;typename T&gt;
1255  struct ConversionBase&lt;T, ConvTraits::kImplicit&gt; {
1256    operator T() const&amp; { return t; }         
1257    operator T() &amp;&amp; { return std::move(t); }  
1258    T t;
1259  };
1260  template &lt;typename T&gt;
1261  struct ConversionBase&lt;T, ConvTraits::kExplicit&gt; {
1262    explicit operator T() const&amp; { return t; }
1263    explicit operator T() &amp;&amp; { return std::move(t); }
1264    T t;
1265  };
1266  template &lt;ConvTraits conv_traits = ConvTraits::kNone&gt;
1267  struct StatusConversionBase {};
1268  template &lt;&gt;
1269  struct StatusConversionBase&lt;ConvTraits::kImplicit&gt; {
1270    operator absl::Status() const&amp; {  
1271      return absl::InternalError(&quot;conversion to Status&quot;);
1272    }
1273    operator absl::Status() &amp;&amp; {  
1274      return absl::InternalError(&quot;conversion to Status&quot;);
1275    }
1276  };
1277  template &lt;&gt;
1278  struct StatusConversionBase&lt;ConvTraits::kExplicit&gt; {
1279    explicit operator absl::Status() const&amp; {  
1280      return absl::InternalError(&quot;conversion to Status&quot;);
1281    }
1282    explicit operator absl::Status() &amp;&amp; {  
1283      return absl::InternalError(&quot;conversion to Status&quot;);
1284    }
1285  };
1286  static constexpr int kConvToStatus = 1;
1287  static constexpr int kConvToStatusOr = 2;
1288  static constexpr int kConvToT = 4;
1289  static constexpr int kConvExplicit = 8;
1290  constexpr ConvTraits GetConvTraits(int bit, int config) {
1291    return (config &amp; bit) == 0
1292               ? ConvTraits::kNone
1293               : ((config &amp; kConvExplicit) == 0 ? ConvTraits::kImplicit
1294                                                : ConvTraits::kExplicit);
1295  }
1296  template &lt;typename T, int config&gt;
1297  struct CustomType
1298      : StatusOrConversionBase&lt;T, GetConvTraits(kConvToStatusOr, config)&gt;,
1299        ConversionBase&lt;T, GetConvTraits(kConvToT, config)&gt;,
1300        StatusConversionBase&lt;GetConvTraits(kConvToStatus, config)&gt; {};
1301  struct ConvertibleToAnyStatusOr {
1302    template &lt;typename T&gt;
1303    operator absl::StatusOr&lt;T&gt;() const {  
1304      return absl::InvalidArgumentError(&quot;Conversion to absl::StatusOr&quot;);
1305    }
1306  };
1307  TEST(StatusOr, ConstructionFromT) {
1308    {
1309      ConvertibleToAnyStatusOr v;
1310      absl::StatusOr&lt;ConvertibleToAnyStatusOr&gt; statusor(v);
1311      EXPECT_TRUE(statusor.ok());
1312    }
1313    {
1314      ConvertibleToAnyStatusOr v;
1315      absl::StatusOr&lt;ConvertibleToAnyStatusOr&gt; statusor = v;
1316      EXPECT_TRUE(statusor.ok());
1317    }
1318    {
1319      CustomType&lt;MyType, kConvToStatus | kConvExplicit&gt; v;
1320      absl::StatusOr&lt;CustomType&lt;MyType, kConvToStatus | kConvExplicit&gt;&gt; statusor(
1321          v);
1322      EXPECT_TRUE(statusor.ok());
1323    }
1324    {
1325      CustomType&lt;MyType, kConvToStatus | kConvExplicit&gt; v;
1326      absl::StatusOr&lt;CustomType&lt;MyType, kConvToStatus | kConvExplicit&gt;&gt; statusor =
1327          v;
1328      EXPECT_TRUE(statusor.ok());
1329    }
1330  }
1331  TEST(StatusOr, ConstructionFromTypeConvertibleToT) {
1332    {
1333      CustomType&lt;MyType, kConvToT | kConvExplicit&gt; v;
1334      absl::StatusOr&lt;MyType&gt; statusor(v);
1335      EXPECT_TRUE(statusor.ok());
1336    }
1337    {
1338      CustomType&lt;MyType, kConvToT&gt; v;
1339      absl::StatusOr&lt;MyType&gt; statusor = v;
1340      EXPECT_TRUE(statusor.ok());
1341    }
1342  }
1343  TEST(StatusOr, ConstructionFromTypeWithConversionOperatorToStatusOrT) {
1344    {
1345      CustomType&lt;MyType, kConvToStatusOr | kConvExplicit&gt; v;
1346      absl::StatusOr&lt;MyType&gt; statusor(v);
1347      EXPECT_EQ(statusor, v.operator absl::StatusOr&lt;MyType&gt;());
1348    }
1349    {
1350      CustomType&lt;MyType, kConvToT | kConvToStatusOr | kConvExplicit&gt; v;
1351      absl::StatusOr&lt;MyType&gt; statusor(v);
1352      EXPECT_EQ(statusor, v.operator absl::StatusOr&lt;MyType&gt;());
1353    }
1354    {
1355      CustomType&lt;MyType, kConvToStatusOr | kConvToStatus | kConvExplicit&gt; v;
1356      absl::StatusOr&lt;MyType&gt; statusor(v);
1357      EXPECT_EQ(statusor, v.operator absl::StatusOr&lt;MyType&gt;());
1358    }
1359    {
1360      CustomType&lt;MyType,
1361                 kConvToT | kConvToStatusOr | kConvToStatus | kConvExplicit&gt;
1362          v;
1363      absl::StatusOr&lt;MyType&gt; statusor(v);
1364      EXPECT_EQ(statusor, v.operator absl::StatusOr&lt;MyType&gt;());
1365    }
1366    {
1367      CustomType&lt;MyType, kConvToStatusOr&gt; v;
1368      absl::StatusOr&lt;MyType&gt; statusor = v;
1369      EXPECT_EQ(statusor, v.operator absl::StatusOr&lt;MyType&gt;());
1370    }
1371    {
1372      CustomType&lt;MyType, kConvToT | kConvToStatusOr&gt; v;
1373      absl::StatusOr&lt;MyType&gt; statusor = v;
1374      EXPECT_EQ(statusor, v.operator absl::StatusOr&lt;MyType&gt;());
1375    }
1376    {
1377      CustomType&lt;MyType, kConvToStatusOr | kConvToStatus&gt; v;
1378      absl::StatusOr&lt;MyType&gt; statusor = v;
1379      EXPECT_EQ(statusor, v.operator absl::StatusOr&lt;MyType&gt;());
1380    }
1381    {
1382      CustomType&lt;MyType, kConvToT | kConvToStatusOr | kConvToStatus&gt; v;
1383      absl::StatusOr&lt;MyType&gt; statusor = v;
1384      EXPECT_EQ(statusor, v.operator absl::StatusOr&lt;MyType&gt;());
1385    }
1386  }
1387  TEST(StatusOr, ConstructionFromTypeConvertibleToStatus) {
1388    {
1389      CustomType&lt;MyType, kConvToStatus | kConvExplicit&gt; v;
1390      absl::StatusOr&lt;MyType&gt; statusor(v);
1391      EXPECT_FALSE(statusor.ok());
1392      EXPECT_EQ(statusor.status(), static_cast&lt;absl::Status&gt;(v));
1393    }
1394    {
1395      CustomType&lt;MyType, kConvToT | kConvToStatus | kConvExplicit&gt; v;
1396      absl::StatusOr&lt;MyType&gt; statusor(v);
1397      EXPECT_FALSE(statusor.ok());
1398      EXPECT_EQ(statusor.status(), static_cast&lt;absl::Status&gt;(v));
1399    }
1400    {
1401      CustomType&lt;MyType, kConvToStatus&gt; v;
1402      absl::StatusOr&lt;MyType&gt; statusor = v;
1403      EXPECT_FALSE(statusor.ok());
1404      EXPECT_EQ(statusor.status(), static_cast&lt;absl::Status&gt;(v));
1405    }
1406    {
1407      CustomType&lt;MyType, kConvToT | kConvToStatus&gt; v;
1408      absl::StatusOr&lt;MyType&gt; statusor = v;
1409      EXPECT_FALSE(statusor.ok());
1410      EXPECT_EQ(statusor.status(), static_cast&lt;absl::Status&gt;(v));
1411    }
1412  }
1413  TEST(StatusOr, AssignmentFromT) {
1414    {
1415      ConvertibleToAnyStatusOr v;
1416      absl::StatusOr&lt;ConvertibleToAnyStatusOr&gt; statusor;
1417      statusor = v;
1418      EXPECT_TRUE(statusor.ok());
1419    }
1420    {
1421      CustomType&lt;MyType, kConvToStatus&gt; v;
1422      absl::StatusOr&lt;CustomType&lt;MyType, kConvToStatus&gt;&gt; statusor;
1423      statusor = v;
1424      EXPECT_TRUE(statusor.ok());
1425    }
1426  }
1427  TEST(StatusOr, AssignmentFromTypeConvertibleToT) {
1428    {
1429      CustomType&lt;MyType, kConvToT&gt; v;
1430      absl::StatusOr&lt;MyType&gt; statusor;
1431      statusor = v;
1432      EXPECT_TRUE(statusor.ok());
1433    }
1434  }
1435  TEST(StatusOr, AssignmentFromTypeWithConversionOperatortoStatusOrT) {
1436    {
1437      CustomType&lt;MyType, kConvToStatusOr&gt; v;
1438      absl::StatusOr&lt;MyType&gt; statusor;
1439      statusor = v;
1440      EXPECT_EQ(statusor, v.operator absl::StatusOr&lt;MyType&gt;());
1441    }
1442    {
1443      CustomType&lt;MyType, kConvToT | kConvToStatusOr&gt; v;
1444      absl::StatusOr&lt;MyType&gt; statusor;
1445      statusor = v;
1446      EXPECT_EQ(statusor, v.operator absl::StatusOr&lt;MyType&gt;());
1447    }
1448    {
1449      CustomType&lt;MyType, kConvToStatusOr | kConvToStatus&gt; v;
1450      absl::StatusOr&lt;MyType&gt; statusor;
1451      statusor = v;
1452      EXPECT_EQ(statusor, v.operator absl::StatusOr&lt;MyType&gt;());
1453    }
1454    {
1455      CustomType&lt;MyType, kConvToT | kConvToStatusOr | kConvToStatus&gt; v;
1456      absl::StatusOr&lt;MyType&gt; statusor;
1457      statusor = v;
1458      EXPECT_EQ(statusor, v.operator absl::StatusOr&lt;MyType&gt;());
1459    }
1460  }
1461  TEST(StatusOr, AssignmentFromTypeConvertibleToStatus) {
1462    {
1463      CustomType&lt;MyType, kConvToStatus&gt; v;
1464      absl::StatusOr&lt;MyType&gt; statusor;
1465      statusor = v;
1466      EXPECT_FALSE(statusor.ok());
1467      EXPECT_EQ(statusor.status(), static_cast&lt;absl::Status&gt;(v));
1468    }
1469    {
1470      CustomType&lt;MyType, kConvToT | kConvToStatus&gt; v;
1471      absl::StatusOr&lt;MyType&gt; statusor;
1472      statusor = v;
1473      EXPECT_FALSE(statusor.ok());
1474      EXPECT_EQ(statusor.status(), static_cast&lt;absl::Status&gt;(v));
1475    }
1476  }
1477  TEST(StatusOr, StatusAssignmentFromStatusError) {
1478    absl::StatusOr&lt;absl::Status&gt; statusor;
1479    statusor.AssignStatus(absl::CancelledError());
1480    EXPECT_FALSE(statusor.ok());
1481    EXPECT_EQ(statusor.status(), absl::CancelledError());
1482  }
1483  #if GTEST_HAS_DEATH_TEST
1484  TEST(StatusOr, StatusAssignmentFromStatusOk) {
1485    EXPECT_DEBUG_DEATH(
1486        {
1487          absl::StatusOr&lt;absl::Status&gt; statusor;
1488          statusor.AssignStatus(absl::OkStatus());
1489          EXPECT_FALSE(statusor.ok());
1490          EXPECT_EQ(statusor.status().code(), absl::StatusCode::kInternal);
1491        },
1492        &quot;An OK status is not a valid constructor argument to StatusOr&lt;T&gt;&quot;);
1493  }
1494  #endif
1495  TEST(StatusOr, StatusAssignmentFromTypeConvertibleToStatus) {
1496    CustomType&lt;MyType, kConvToStatus&gt; v;
1497    absl::StatusOr&lt;MyType&gt; statusor;
1498    statusor.AssignStatus(v);
1499    EXPECT_FALSE(statusor.ok());
1500    EXPECT_EQ(statusor.status(), static_cast&lt;absl::Status&gt;(v));
1501  }
1502  }  
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-utility_test.cc</h3>
            <pre><code>1  #include &quot;absl/utility/utility.h&quot;
2  #include &lt;memory&gt;
3  #include &lt;sstream&gt;
4  #include &lt;string&gt;
5  #include &lt;tuple&gt;
6  #include &lt;type_traits&gt;
7  #include &lt;utility&gt;
8  #include &lt;vector&gt;
9  #include &quot;gmock/gmock.h&quot;
10  #include &quot;gtest/gtest.h&quot;
11  #include &quot;absl/base/attributes.h&quot;
12  #include &quot;absl/memory/memory.h&quot;
13  #include &quot;absl/strings/str_cat.h&quot;
14  namespace {
15  #ifdef _MSC_VER
16  #pragma warning(push)
17  #pragma warning(disable : 4503)  
18  #pragma warning(disable : 4101)  
19  #endif                           
20  using ::testing::ElementsAre;
21  using ::testing::Pointee;
22  using ::testing::StaticAssertTypeEq;
23  TEST(IntegerSequenceTest, ValueType) {
24    StaticAssertTypeEq&lt;int, absl::integer_sequence&lt;int&gt;::value_type&gt;();
25    StaticAssertTypeEq&lt;char, absl::integer_sequence&lt;char&gt;::value_type&gt;();
26  }
27  TEST(IntegerSequenceTest, Size) {
28    EXPECT_EQ(0, (absl::integer_sequence&lt;int&gt;::size()));
29    EXPECT_EQ(1, (absl::integer_sequence&lt;int, 0&gt;::size()));
30    EXPECT_EQ(1, (absl::integer_sequence&lt;int, 1&gt;::size()));
31    EXPECT_EQ(2, (absl::integer_sequence&lt;int, 1, 2&gt;::size()));
32    EXPECT_EQ(3, (absl::integer_sequence&lt;int, 0, 1, 2&gt;::size()));
33    EXPECT_EQ(3, (absl::integer_sequence&lt;int, -123, 123, 456&gt;::size()));
34    constexpr size_t sz = absl::integer_sequence&lt;int, 0, 1&gt;::size();
35    EXPECT_EQ(2, sz);
36  }
37  TEST(IntegerSequenceTest, MakeIndexSequence) {
38    StaticAssertTypeEq&lt;absl::index_sequence&lt;&gt;, absl::make_index_sequence&lt;0&gt;&gt;();
39    StaticAssertTypeEq&lt;absl::index_sequence&lt;0&gt;, absl::make_index_sequence&lt;1&gt;&gt;();
40    StaticAssertTypeEq&lt;absl::index_sequence&lt;0, 1&gt;,
41                       absl::make_index_sequence&lt;2&gt;&gt;();
42    StaticAssertTypeEq&lt;absl::index_sequence&lt;0, 1, 2&gt;,
43                       absl::make_index_sequence&lt;3&gt;&gt;();
44  }
45  TEST(IntegerSequenceTest, MakeIntegerSequence) {
46    StaticAssertTypeEq&lt;absl::integer_sequence&lt;int&gt;,
47                       absl::make_integer_sequence&lt;int, 0&gt;&gt;();
48    StaticAssertTypeEq&lt;absl::integer_sequence&lt;int, 0&gt;,
49                       absl::make_integer_sequence&lt;int, 1&gt;&gt;();
50    StaticAssertTypeEq&lt;absl::integer_sequence&lt;int, 0, 1&gt;,
51                       absl::make_integer_sequence&lt;int, 2&gt;&gt;();
52    StaticAssertTypeEq&lt;absl::integer_sequence&lt;int, 0, 1, 2&gt;,
53                       absl::make_integer_sequence&lt;int, 3&gt;&gt;();
54  }
55  template &lt;typename... Ts&gt;
56  class Counter {};
57  template &lt;size_t... Is&gt;
58  void CountAll(absl::index_sequence&lt;Is...&gt;) {
59    ABSL_ATTRIBUTE_UNUSED Counter&lt;absl::make_index_sequence&lt;Is&gt;...&gt; seq;
60  }
61  TEST(IntegerSequenceTest, MakeIndexSequencePerformance) {
62    ABSL_ATTRIBUTE_UNUSED absl::make_index_sequence&lt;(1 &lt;&lt; 16) - 1&gt; seq;
63    CountAll(absl::make_index_sequence&lt;(1 &lt;&lt; 8) - 1&gt;());
64  }
65  template &lt;typename F, typename Tup, size_t... Is&gt;
66  auto ApplyFromTupleImpl(F f, const Tup&amp; tup, absl::index_sequence&lt;Is...&gt;)
67      -&gt; decltype(f(std::get&lt;Is&gt;(tup)...)) {
68    return f(std::get&lt;Is&gt;(tup)...);
69  }
70  template &lt;typename Tup&gt;
71  using TupIdxSeq = absl::make_index_sequence&lt;std::tuple_size&lt;Tup&gt;::value&gt;;
72  template &lt;typename F, typename Tup&gt;
73  auto ApplyFromTuple(F f, const Tup&amp; tup)
74      -&gt; decltype(ApplyFromTupleImpl(f, tup, TupIdxSeq&lt;Tup&gt;{})) {
75    return ApplyFromTupleImpl(f, tup, TupIdxSeq&lt;Tup&gt;{});
76  }
77  template &lt;typename T&gt;
78  std::string Fmt(const T&amp; x) {
79    std::ostringstream os;
80    os &lt;&lt; x;
81    return os.str();
82  }
83  struct PoorStrCat {
84    template &lt;typename... Args&gt;
85    std::string operator()(const Args&amp;... args) const {
86      std::string r;
87      for (const auto&amp; e : {Fmt(args)...}) r += e;
88      return r;
89    }
90  };
91  template &lt;typename Tup, size_t... Is&gt;
92  std::vector&lt;std::string&gt; TupStringVecImpl(const Tup&amp; tup,
93                                            absl::index_sequence&lt;Is...&gt;) {
94    return {Fmt(std::get&lt;Is&gt;(tup))...};
95  }
96  template &lt;typename... Ts&gt;
97  std::vector&lt;std::string&gt; TupStringVec(const std::tuple&lt;Ts...&gt;&amp; tup) {
98    return TupStringVecImpl(tup, absl::index_sequence_for&lt;Ts...&gt;());
99  }
100  TEST(MakeIndexSequenceTest, ApplyFromTupleExample) {
101    PoorStrCat f{};
102    EXPECT_EQ(&quot;12abc3.14&quot;, f(12, &quot;abc&quot;, 3.14));
103    EXPECT_EQ(&quot;12abc3.14&quot;, ApplyFromTuple(f, std::make_tuple(12, &quot;abc&quot;, 3.14)));
104  }
105  TEST(IndexSequenceForTest, Basic) {
106    StaticAssertTypeEq&lt;absl::index_sequence&lt;&gt;, absl::index_sequence_for&lt;&gt;&gt;();
107    StaticAssertTypeEq&lt;absl::index_sequence&lt;0&gt;, absl::index_sequence_for&lt;int&gt;&gt;();
108    StaticAssertTypeEq&lt;absl::index_sequence&lt;0, 1, 2, 3&gt;,
109                       absl::index_sequence_for&lt;int, void, char, int&gt;&gt;();
110  }
111  TEST(IndexSequenceForTest, Example) {
112    EXPECT_THAT(TupStringVec(std::make_tuple(12, &quot;abc&quot;, 3.14)),
113                ElementsAre(&quot;12&quot;, &quot;abc&quot;, &quot;3.14&quot;));
114  }
115  int Function(int a, int b) { return a - b; }
116  int Sink(std::unique_ptr&lt;int&gt; p) { return *p; }
117  std::unique_ptr&lt;int&gt; Factory(int n) { return absl::make_unique&lt;int&gt;(n); }
118  void NoOp() {}
119  struct ConstFunctor {
120    int operator()(int a, int b) const { return a - b; }
121  };
122  struct MutableFunctor {
123    int operator()(int a, int b) { return a - b; }
124  };
125  struct EphemeralFunctor {
126    EphemeralFunctor() {}
127    EphemeralFunctor(const EphemeralFunctor&amp;) {}
128    EphemeralFunctor(EphemeralFunctor&amp;&amp;) {}
129    int operator()(int a, int b) &amp;&amp; { return a - b; }
130  };
131  struct OverloadedFunctor {
132    OverloadedFunctor() {}
133    OverloadedFunctor(const OverloadedFunctor&amp;) {}
134    OverloadedFunctor(OverloadedFunctor&amp;&amp;) {}
135    template &lt;typename... Args&gt;
136    std::string operator()(const Args&amp;... args) &amp; {
137      return absl::StrCat(&quot;&amp;&quot;, args...);
138    }
139    template &lt;typename... Args&gt;
140    std::string operator()(const Args&amp;... args) const&amp; {
141      return absl::StrCat(&quot;const&amp;&quot;, args...);
142    }
143    template &lt;typename... Args&gt;
144    std::string operator()(const Args&amp;... args) &amp;&amp; {
145      return absl::StrCat(&quot;&amp;&amp;&quot;, args...);
146    }
147  };
148  struct Class {
149    int Method(int a, int b) { return a - b; }
150    int ConstMethod(int a, int b) const { return a - b; }
151    int member;
152  };
153  struct FlipFlop {
154    int ConstMethod() const { return member; }
155    FlipFlop operator*() const { return {-member}; }
156    int member;
157  };
158  TEST(ApplyTest, Function) {
159    EXPECT_EQ(1, absl::apply(Function, std::make_tuple(3, 2)));
160    EXPECT_EQ(1, absl::apply(&amp;Function, std::make_tuple(3, 2)));
161  }
162  TEST(ApplyTest, NonCopyableArgument) {
163    EXPECT_EQ(42, absl::apply(Sink, std::make_tuple(absl::make_unique&lt;int&gt;(42))));
164  }
165  TEST(ApplyTest, NonCopyableResult) {
166    EXPECT_THAT(absl::apply(Factory, std::make_tuple(42)), Pointee(42));
167  }
168  TEST(ApplyTest, VoidResult) { absl::apply(NoOp, std::tuple&lt;&gt;()); }
169  TEST(ApplyTest, ConstFunctor) {
170    EXPECT_EQ(1, absl::apply(ConstFunctor(), std::make_tuple(3, 2)));
171  }
172  TEST(ApplyTest, MutableFunctor) {
173    MutableFunctor f;
174    EXPECT_EQ(1, absl::apply(f, std::make_tuple(3, 2)));
175    EXPECT_EQ(1, absl::apply(MutableFunctor(), std::make_tuple(3, 2)));
176  }
177  TEST(ApplyTest, EphemeralFunctor) {
178    EphemeralFunctor f;
179    EXPECT_EQ(1, absl::apply(std::move(f), std::make_tuple(3, 2)));
180    EXPECT_EQ(1, absl::apply(EphemeralFunctor(), std::make_tuple(3, 2)));
181  }
182  TEST(ApplyTest, OverloadedFunctor) {
183    OverloadedFunctor f;
184    const OverloadedFunctor&amp; cf = f;
185    EXPECT_EQ(&quot;&amp;&quot;, absl::apply(f, std::tuple&lt;&gt;{}));
186    EXPECT_EQ(&quot;&amp; 42&quot;, absl::apply(f, std::make_tuple(&quot; 42&quot;)));
187    EXPECT_EQ(&quot;const&amp;&quot;, absl::apply(cf, std::tuple&lt;&gt;{}));
188    EXPECT_EQ(&quot;const&amp; 42&quot;, absl::apply(cf, std::make_tuple(&quot; 42&quot;)));
189    EXPECT_EQ(&quot;&amp;&amp;&quot;, absl::apply(std::move(f), std::tuple&lt;&gt;{}));
190    OverloadedFunctor f2;
191    EXPECT_EQ(&quot;&amp;&amp; 42&quot;, absl::apply(std::move(f2), std::make_tuple(&quot; 42&quot;)));
192  }
193  TEST(ApplyTest, ReferenceWrapper) {
194    ConstFunctor cf;
195    MutableFunctor mf;
196    EXPECT_EQ(1, absl::apply(std::cref(cf), std::make_tuple(3, 2)));
197    EXPECT_EQ(1, absl::apply(std::ref(cf), std::make_tuple(3, 2)));
198    EXPECT_EQ(1, absl::apply(std::ref(mf), std::make_tuple(3, 2)));
199  }
200  TEST(ApplyTest, MemberFunction) {
201    std::unique_ptr&lt;Class&gt; p(new Class);
202    std::unique_ptr&lt;const Class&gt; cp(new Class);
203    EXPECT_EQ(
204        1, absl::apply(&amp;Class::Method,
205                       std::tuple&lt;std::unique_ptr&lt;Class&gt;&amp;, int, int&gt;(p, 3, 2)));
206    EXPECT_EQ(1, absl::apply(&amp;Class::Method,
207                             std::tuple&lt;Class*, int, int&gt;(p.get(), 3, 2)));
208    EXPECT_EQ(
209        1, absl::apply(&amp;Class::Method, std::tuple&lt;Class&amp;, int, int&gt;(*p, 3, 2)));
210    EXPECT_EQ(
211        1, absl::apply(&amp;Class::ConstMethod,
212                       std::tuple&lt;std::unique_ptr&lt;Class&gt;&amp;, int, int&gt;(p, 3, 2)));
213    EXPECT_EQ(1, absl::apply(&amp;Class::ConstMethod,
214                             std::tuple&lt;Class*, int, int&gt;(p.get(), 3, 2)));
215    EXPECT_EQ(1, absl::apply(&amp;Class::ConstMethod,
216                             std::tuple&lt;Class&amp;, int, int&gt;(*p, 3, 2)));
217    EXPECT_EQ(1, absl::apply(&amp;Class::ConstMethod,
218                             std::tuple&lt;std::unique_ptr&lt;const Class&gt;&amp;, int, int&gt;(
219                                 cp, 3, 2)));
220    EXPECT_EQ(1, absl::apply(&amp;Class::ConstMethod,
221                             std::tuple&lt;const Class*, int, int&gt;(cp.get(), 3, 2)));
222    EXPECT_EQ(1, absl::apply(&amp;Class::ConstMethod,
223                             std::tuple&lt;const Class&amp;, int, int&gt;(*cp, 3, 2)));
224    EXPECT_EQ(1, absl::apply(&amp;Class::Method,
225                             std::make_tuple(absl::make_unique&lt;Class&gt;(), 3, 2)));
226    EXPECT_EQ(1, absl::apply(&amp;Class::ConstMethod,
227                             std::make_tuple(absl::make_unique&lt;Class&gt;(), 3, 2)));
228    EXPECT_EQ(
229        1, absl::apply(&amp;Class::ConstMethod,
230                       std::make_tuple(absl::make_unique&lt;const Class&gt;(), 3, 2)));
231  }
232  TEST(ApplyTest, DataMember) {
233    std::unique_ptr&lt;Class&gt; p(new Class{42});
234    std::unique_ptr&lt;const Class&gt; cp(new Class{42});
235    EXPECT_EQ(
236        42, absl::apply(&amp;Class::member, std::tuple&lt;std::unique_ptr&lt;Class&gt;&amp;&gt;(p)));
237    EXPECT_EQ(42, absl::apply(&amp;Class::member, std::tuple&lt;Class&amp;&gt;(*p)));
238    EXPECT_EQ(42, absl::apply(&amp;Class::member, std::tuple&lt;Class*&gt;(p.get())));
239    absl::apply(&amp;Class::member, std::tuple&lt;std::unique_ptr&lt;Class&gt;&amp;&gt;(p)) = 42;
240    absl::apply(&amp;Class::member, std::tuple&lt;Class*&gt;(p.get())) = 42;
241    absl::apply(&amp;Class::member, std::tuple&lt;Class&amp;&gt;(*p)) = 42;
242    EXPECT_EQ(42, absl::apply(&amp;Class::member,
243                              std::tuple&lt;std::unique_ptr&lt;const Class&gt;&amp;&gt;(cp)));
244    EXPECT_EQ(42, absl::apply(&amp;Class::member, std::tuple&lt;const Class&amp;&gt;(*cp)));
245    EXPECT_EQ(42,
246              absl::apply(&amp;Class::member, std::tuple&lt;const Class*&gt;(cp.get())));
247  }
248  TEST(ApplyTest, FlipFlop) {
249    FlipFlop obj = {42};
250    EXPECT_EQ(42, absl::apply(&amp;FlipFlop::ConstMethod, std::make_tuple(obj)));
251    EXPECT_EQ(42, absl::apply(&amp;FlipFlop::member, std::make_tuple(obj)));
252  }
253  TEST(ExchangeTest, MoveOnly) {
254    auto a = Factory(1);
255    EXPECT_EQ(1, *a);
256    auto b = absl::exchange(a, Factory(2));
257    EXPECT_EQ(2, *a);
<span onclick='openModal()' class='match'>258    EXPECT_EQ(1, *b);
259  }
260  TEST(MakeFromTupleTest, String) {
261    EXPECT_EQ(
</span>262        absl::make_from_tuple&lt;std::string&gt;(std::make_tuple(&quot;hello world&quot;, 5)),
263        &quot;hello&quot;);
264  }
265  TEST(MakeFromTupleTest, MoveOnlyParameter) {
266    struct S {
267      S(std::unique_ptr&lt;int&gt; n, std::unique_ptr&lt;int&gt; m) : value(*n + *m) {}
268      int value = 0;
269    };
270    auto tup =
271        std::make_tuple(absl::make_unique&lt;int&gt;(3), absl::make_unique&lt;int&gt;(4));
272    auto s = absl::make_from_tuple&lt;S&gt;(std::move(tup));
273    EXPECT_EQ(s.value, 7);
274  }
275  TEST(MakeFromTupleTest, NoParameters) {
276    struct S {
277      S() : value(1) {}
278      int value = 2;
279    };
280    EXPECT_EQ(absl::make_from_tuple&lt;S&gt;(std::make_tuple()).value, 1);
281  }
282  TEST(MakeFromTupleTest, Pair) {
283    EXPECT_EQ(
284        (absl::make_from_tuple&lt;std::pair&lt;bool, int&gt;&gt;(std::make_tuple(true, 17))),
285        std::make_pair(true, 17));
286  }
287  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-statusor_test.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-utility_test.cc</div>
                </div>
                <div class="column column_space"><pre><code>190    EXPECT_EQ(0, *ptr);
191  }
192  TEST(StatusOr, TestMoveOnlyInitializationFromTemporaryByValueOrDie) {
193    std::unique_ptr&lt;int&gt; ptr(*ReturnUniquePtr());
</pre></code></div>
                <div class="column column_space"><pre><code>258    EXPECT_EQ(1, *b);
259  }
260  TEST(MakeFromTupleTest, String) {
261    EXPECT_EQ(
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    