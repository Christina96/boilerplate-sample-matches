<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for string.hpp &amp; polymorphic.hpp</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for string.hpp &amp; polymorphic.hpp
      </h3>
<h1 align="center">
        5.5%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>string.hpp (34.285713%)<th>polymorphic.hpp (3.030303%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(49-55)<td><a href="#" name="0">(364-368)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>string.hpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifndef CEREAL_TYPES_STRING_HPP_
2 #define CEREAL_TYPES_STRING_HPP_
3 #include &lt;cereal/cereal.hpp&gt;
4 #include &lt;string&gt;
5 namespace cereal
6 {
7   template&lt;class Archive, class CharT, class Traits, class Alloc&gt; inline
8   typename std::enable_if&lt;traits::is_output_serializable&lt;BinaryData&lt;CharT&gt;, Archive&gt;::value, void&gt;::type
9   save(Archive &amp; ar, std::basic_string&lt;CharT, Traits, Alloc&gt; const &amp; str)
10   {
11     ar( make_size_tag( static_cast&lt;size_type&gt;(str.size()) ) );
12     ar( binary_data( str.data(), str.size() * sizeof(CharT) ) );
13 <a name="0"></a>  }
14 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  template&lt;class Archive, class CharT, class Traits, class Alloc&gt; inline
15   typename std::enable_if&lt;traits::is_input_serializable&lt;BinaryData&lt;CharT&gt;, Archive&gt;::value, void&gt;::type
16   load(Archive &amp; ar, std::basic_string&lt;CharT, Traits, Alloc&gt; &amp; str)
17   {
18     size_type size;
19     ar( make_size_tag( size ) );
20     str.resize(static_cast&lt;std::size_t&gt;(size));</b></font>
21     ar( binary_data( const_cast&lt;CharT *&gt;( str.data() ), static_cast&lt;std::size_t&gt;(size) * sizeof(CharT) ) );
22   }
23 } 
24 #endif 
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>polymorphic.hpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifndef CEREAL_TYPES_POLYMORPHIC_HPP_
2 #define CEREAL_TYPES_POLYMORPHIC_HPP_
3 #include &lt;cereal/cereal.hpp&gt;
4 #include &lt;cereal/types/memory.hpp&gt;
5 #include &lt;cereal/details/util.hpp&gt;
6 #include &lt;cereal/details/helpers.hpp&gt;
7 #include &lt;cereal/details/traits.hpp&gt;
8 #include &lt;cereal/details/polymorphic_impl.hpp&gt;
9 #ifdef _MSC_VER
10 #define STATIC_CONSTEXPR static
11 #else
12 #define STATIC_CONSTEXPR static constexpr
13 #endif
14 #define CEREAL_REGISTER_TYPE(T)                         \
15   namespace cereal {                                    \
16   namespace detail {                                    \
17   template &lt;&gt;                                           \
18   struct binding_name&lt;T&gt;                                \
19   {                                                     \
20     STATIC_CONSTEXPR char const * name() { return #T; } \
21   };                                                    \
22   } }   CEREAL_BIND_TO_ARCHIVES(T)
23 #define CEREAL_REGISTER_TYPE_WITH_NAME(T, Name)              \
24   namespace cereal {                                         \
25   namespace detail {                                         \
26   template &lt;&gt;                                                \
27   struct binding_name&lt;T&gt;                                     \
28   { STATIC_CONSTEXPR char const * name() { return Name; } }; \
29   } }   CEREAL_BIND_TO_ARCHIVES(T)
30 #ifdef _MSC_VER
31 #undef CONSTEXPR
32 #endif
33 namespace cereal
34 {
35   namespace polymorphic_detail
36   {
37     template&lt;class Archive&gt; inline
38     typename ::cereal::detail::InputBindingMap&lt;Archive&gt;::Serializers getInputBinding(Archive &amp; ar, std::uint32_t const nameid)
39     {
40       if(nameid == 0)
41       {
42         typename ::cereal::detail::InputBindingMap&lt;Archive&gt;::Serializers emptySerializers;
43         emptySerializers.shared_ptr = [](void*, std::shared_ptr&lt;void&gt; &amp; ptr) { ptr.reset(); };
44         emptySerializers.unique_ptr = [](void*, std::unique_ptr&lt;void, ::cereal::detail::EmptyDeleter&lt;void&gt;&gt; &amp; ptr) { ptr.reset( nullptr ); };
45         return emptySerializers;
46       }
47       std::string name;
48       if(nameid &amp; detail::msb_32bit)
49       {
50         ar( _CEREAL_NVP("polymorphic_name", name) );
51         ar.registerPolymorphicName(nameid, name);
52       }
53       else
54         name = ar.getPolymorphicName(nameid);
55       auto &amp; bindingMap = detail::StaticObject&lt;detail::InputBindingMap&lt;Archive&gt;&gt;::getInstance().map;
56       auto binding = bindingMap.find(name);
57       if(binding == bindingMap.end())
58         throw cereal::Exception("Trying to load an unregistered polymorphic type (" + name + ")");
59       return binding-&gt;second;
60     }
61     template&lt;class Archive, class T&gt; inline
62     typename std::enable_if&lt;(std::is_default_constructible&lt;T&gt;::value
63                              || traits::has_load_and_construct&lt;T, Archive&gt;::value)
64                              &amp;&amp; !std::is_abstract&lt;T&gt;::value, bool&gt;::type
65     serialize_wrapper(Archive &amp; ar, std::shared_ptr&lt;T&gt; &amp; ptr, std::uint32_t const nameid)
66     {
67       if(nameid &amp; detail::msb2_32bit)
68       {
69         ar( _CEREAL_NVP("ptr_wrapper", memory_detail::make_ptr_wrapper(ptr)) );
70         return true;
71       }
72       return false;
73     }
74     template&lt;class Archive, class T, class D&gt; inline
75     typename std::enable_if&lt;(std::is_default_constructible&lt;T&gt;::value
76                              || traits::has_load_and_construct&lt;T, Archive&gt;::value)
77                              &amp;&amp; !std::is_abstract&lt;T&gt;::value, bool&gt;::type
78     serialize_wrapper(Archive &amp; ar, std::unique_ptr&lt;T, D&gt; &amp; ptr, std::uint32_t const nameid)
79     {
80       if(nameid &amp; detail::msb2_32bit)
81       {
82         ar( _CEREAL_NVP("ptr_wrapper", memory_detail::make_ptr_wrapper(ptr)) );
83         return true;
84       }
85       return false;
86     }
87     template&lt;class Archive, class T&gt; inline
88     typename std::enable_if&lt;(!std::is_default_constructible&lt;T&gt;::value
89                              &amp;&amp; !traits::has_load_and_construct&lt;T, Archive&gt;::value)
90                              || std::is_abstract&lt;T&gt;::value, bool&gt;::type
91     serialize_wrapper(Archive &amp;, std::shared_ptr&lt;T&gt; &amp;, std::uint32_t const nameid)
92     {
93       if(nameid &amp; detail::msb2_32bit)
94         throw cereal::Exception("Cannot load a polymorphic type that is not default constructable and does not have a load_and_construct function");
95       return false;
96     }
97     template&lt;class Archive, class T, class D&gt; inline
98      typename std::enable_if&lt;(!std::is_default_constructible&lt;T&gt;::value
99                                &amp;&amp; !traits::has_load_and_construct&lt;T, Archive&gt;::value)
100                                || std::is_abstract&lt;T&gt;::value, bool&gt;::type
101     serialize_wrapper(Archive &amp;, std::unique_ptr&lt;T, D&gt; &amp;, std::uint32_t const nameid)
102     {
103       if(nameid &amp; detail::msb2_32bit)
104         throw cereal::Exception("Cannot load a polymorphic type that is not default constructable and does not have a load_and_construct function");
105       return false;
106     }
107   } 
108   template &lt;class Archive, class T&gt; inline
109   typename std::enable_if&lt;std::is_polymorphic&lt;T&gt;::value &amp;&amp; std::is_abstract&lt;T&gt;::value, void&gt;::type
110   save( Archive &amp; ar, std::shared_ptr&lt;T&gt; const &amp; ptr )
111   {
112     if(!ptr)
113     {
114       ar( _CEREAL_NVP("polymorphic_id", std::uint32_t(0)) );
115       return;
116     }
117     std::type_info const &amp; ptrinfo = typeid(*ptr.get());
118     auto &amp; bindingMap = detail::StaticObject&lt;detail::OutputBindingMap&lt;Archive&gt;&gt;::getInstance().map;
119     auto binding = bindingMap.find(std::type_index(ptrinfo));
120     if(binding == bindingMap.end())
121       throw cereal::Exception("Trying to save an unregistered polymorphic type (" + cereal::util::demangle(ptrinfo.name()) + ")");
122     binding-&gt;second.shared_ptr(&amp;ar, ptr.get());
123   }
124   template &lt;class Archive, class T&gt; inline
125   typename std::enable_if&lt;std::is_polymorphic&lt;T&gt;::value &amp;&amp; !std::is_abstract&lt;T&gt;::value, void&gt;::type
126   save( Archive &amp; ar, std::shared_ptr&lt;T&gt; const &amp; ptr )
127   {
128     if(!ptr)
129     {
130       ar( _CEREAL_NVP("polymorphic_id", std::uint32_t(0)) );
131       return;
132     }
133     std::type_info const &amp; ptrinfo = typeid(*ptr.get());
134     static std::type_info const &amp; tinfo = typeid(T);
135     if(ptrinfo == tinfo)
136     {
137       ar( _CEREAL_NVP("polymorphic_id", detail::msb2_32bit) );
138       ar( _CEREAL_NVP("ptr_wrapper", memory_detail::make_ptr_wrapper(ptr)) );
139       return;
140     }
141     auto &amp; bindingMap = detail::StaticObject&lt;detail::OutputBindingMap&lt;Archive&gt;&gt;::getInstance().map;
142     auto binding = bindingMap.find(std::type_index(ptrinfo));
143     if(binding == bindingMap.end())
144       throw cereal::Exception("Trying to save an unregistered polymorphic type (" + cereal::util::demangle(ptrinfo.name()) + ")");
145     binding-&gt;second.shared_ptr(&amp;ar, ptr.get());
146   }
147   template &lt;class Archive, class T&gt; inline
148   typename std::enable_if&lt;std::is_polymorphic&lt;T&gt;::value, void&gt;::type
149   load( Archive &amp; ar, std::shared_ptr&lt;T&gt; &amp; ptr )
150   {
151     std::uint32_t nameid;
152     ar( _CEREAL_NVP("polymorphic_id", nameid) );
153     if(polymorphic_detail::serialize_wrapper(ar, ptr, nameid))
154       return;
155     auto binding = polymorphic_detail::getInputBinding(ar, nameid);
156     std::shared_ptr&lt;void&gt; result;
157     binding.shared_ptr(&amp;ar, result);
158     ptr = std::static_pointer_cast&lt;T&gt;(result);
159   }
160   template &lt;class Archive, class T&gt; inline
161   typename std::enable_if&lt;std::is_polymorphic&lt;T&gt;::value, void&gt;::type
162   save( Archive &amp; ar, std::weak_ptr&lt;T&gt; const &amp; ptr )
163   {
164     auto const sptr = ptr.lock();
165     ar( _CEREAL_NVP("locked_ptr", sptr) );
166   }
167   template &lt;class Archive, class T&gt; inline
168   typename std::enable_if&lt;std::is_polymorphic&lt;T&gt;::value, void&gt;::type
169   load( Archive &amp; ar, std::weak_ptr&lt;T&gt; &amp; ptr )
170   {
171     std::shared_ptr&lt;T&gt; sptr;
172     ar( _CEREAL_NVP("locked_ptr", sptr) );
173     ptr = sptr;
174   }
175   template &lt;class Archive, class T, class D&gt; inline
176   typename std::enable_if&lt;std::is_polymorphic&lt;T&gt;::value &amp;&amp; std::is_abstract&lt;T&gt;::value, void&gt;::type
177   save( Archive &amp; ar, std::unique_ptr&lt;T, D&gt; const &amp; ptr )
178   {
179     if(!ptr)
180     {
181       ar( _CEREAL_NVP("polymorphic_id", std::uint32_t(0)) );
182       return;
183     }
184     std::type_info const &amp; ptrinfo = typeid(*ptr.get());
185     auto &amp; bindingMap = detail::StaticObject&lt;detail::OutputBindingMap&lt;Archive&gt;&gt;::getInstance().map;
186     auto binding = bindingMap.find(std::type_index(ptrinfo));
187     if(binding == bindingMap.end())
188       throw cereal::Exception("Trying to save an unregistered polymorphic type (" + cereal::util::demangle(ptrinfo.name()) + ")");
189     binding-&gt;second.unique_ptr(&amp;ar, ptr.get());
190   }
191   template &lt;class Archive, class T, class D&gt; inline
192   typename std::enable_if&lt;std::is_polymorphic&lt;T&gt;::value &amp;&amp; !std::is_abstract&lt;T&gt;::value, void&gt;::type
193   save( Archive &amp; ar, std::unique_ptr&lt;T, D&gt; const &amp; ptr )
194   {
195     if(!ptr)
196     {
197       ar( _CEREAL_NVP("polymorphic_id", std::uint32_t(0)) );
198       return;
199     }
200     std::type_info const &amp; ptrinfo = typeid(*ptr.get());
201     static std::type_info const &amp; tinfo = typeid(T);
202     if(ptrinfo == tinfo)
203     {
204       ar( _CEREAL_NVP("polymorphic_id", detail::msb2_32bit) );
205       ar( _CEREAL_NVP("ptr_wrapper", memory_detail::make_ptr_wrapper(ptr)) );
206       return;
207     }
208     auto &amp; bindingMap = detail::StaticObject&lt;detail::OutputBindingMap&lt;Archive&gt;&gt;::getInstance().map;
209     auto binding = bindingMap.find(std::type_index(ptrinfo));
210     if(binding == bindingMap.end())
211       throw cereal::Exception("Trying to save an unregistered polymorphic type (" + cereal::util::demangle(ptrinfo.name()) + ")");
212     binding-&gt;second.unique_ptr(&amp;ar, ptr.get());
213 <a name="0"></a>  }
214 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  template &lt;class Archive, class T, class D&gt; inline
215   typename std::enable_if&lt;std::is_polymorphic&lt;T&gt;::value, void&gt;::type
216   load( Archive &amp; ar, std::unique_ptr&lt;T, D&gt; &amp; ptr )
217   {
218     std::uint32_t nameid;</b></font>
219     ar( _CEREAL_NVP("polymorphic_id", nameid) );
220     if(polymorphic_detail::serialize_wrapper(ar, ptr, nameid))
221       return;
222     auto binding = polymorphic_detail::getInputBinding(ar, nameid);
223     std::unique_ptr&lt;void, ::cereal::detail::EmptyDeleter&lt;void&gt;&gt; result;
224     binding.unique_ptr(&amp;ar, result);
225     ptr.reset(static_cast&lt;T*&gt;(result.release()));
226   }
} #endif </pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
