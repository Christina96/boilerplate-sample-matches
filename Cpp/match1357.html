<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for TestInHC4Revise.cpp & TestExprLinearity.cpp</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for TestInHC4Revise.cpp & TestExprLinearity.cpp
      </h3>
      <h1 align="center">
        5.7%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>TestInHC4Revise.cpp (11.881188%)<TH>TestExprLinearity.cpp (3.821656%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match1357-0.html#0',2,'match1357-1.html#0',3)" NAME="0">(68-70)<TD><A HREF="javascript:ZweiFrames('match1357-0.html#0',2,'match1357-1.html#0',3)" NAME="0">(39-40)</A><TD ALIGN=center><FONT COLOR="#ff0000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>TestInHC4Revise.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* ============================================================================
 * I B E X - HC4Revise Tests
 * ============================================================================
 * Copyright   : Ecole des Mines de Nantes (FRANCE)
 * License     : This program can be distributed under the terms of the GNU LGPL.
 *               See the file COPYING.LESSER.
 *
 * Author(s)   : Gilles Chabert
 * Created     : Apr 03, 2012
 * ---------------------------------------------------------------------------- */

#include &quot;TestInHC4Revise.h&quot;
#include &quot;ibex_Function.h&quot;
#include &quot;ibex_Expr.h&quot;

using namespace std;

namespace ibex {

void TestInHC4Revise::add01() {

	Variable x,y;
	Function f(x,y,x+y);

	double init_xy[][2]= { {-1,1}, {-1,1} };
	IntervalVector box(2,init_xy);

	f.ibwd(Interval(0,1),box);

	CPPUNIT_ASSERT((box[0]+box[1]).is_subset(Interval(0,1)));
	check(box[0].lb()+box[1].lb(),0);
	check(box[0].ub()+box[1].ub(),1);
}


void TestInHC4Revise::add02() {

	Variable x;
	Function f(x,x+Interval(0,1));

	IntervalVector box(1,Interval(0,1));

	f.ibwd(Interval(0,1),box);

	CPPUNIT_ASSERT(box.is_empty() || // TEMPORARY WRAP
			box[0]==Interval(1,1));
}



void TestInHC4Revise::dist01() {
	Variable x(2),y(2);
	Function f(x,y,sqrt(sqr(x[0]-y[0])+sqr(x[1]-y[1])));
	IntervalVector box(4,Interval(0,4));
	double _pt[][2] = { {0.5,0.5} , {0.5,0.5} , {1.0,1.0} , {1.0,1.0} };
	IntervalVector pt(4,_pt);
	f.ibwd(Interval(0,1),box,pt);

	// check the box is inside by testing two corners
	CPPUNIT_ASSERT(f.eval(box.lb()).is_subset(Interval(0,1)));
	CPPUNIT_ASSERT(f.eval(box.ub()).is_subset(Interval(0,1)));

}

<A NAME="0"></A>void TestInHC4Revise::dist02() {
	Variable x(2);
	Function f(x,sqr(x[0])+sqr(x[1]));
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match1357-1.html#0',3,'match1357-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	double _box[][2] = { {0, 1.5}, {-1, 0.1} };
	IntervalVector box(2,_box);
	double _pt[][2] = { {1.5,1.5} , {0.1,0.1} };</B></FONT>
	IntervalVector pt(2,_pt);
	f.ibwd(Interval(1,POS_INFINITY),box,pt);

//	// check the box is inside by testing two corners
//	CPPUNIT_ASSERT(f.eval(box.lb()).is_subset(Interval(0,1)));
//	CPPUNIT_ASSERT(f.eval(box.ub()).is_subset(Interval(0,1)));

}

void TestInHC4Revise::apply01() {
	Variable x(2),y(2);
	Function f(x,y,sqrt(sqr(x[0]-y[0])+sqr(x[1]-y[1])));

	Function g(x,y,f(x,y));
	IntervalVector box(4,Interval(0,4));
	double _pt[][2] = { {0.5,0.5} , {0.5,0.5} , {1.0,1.0} , {1.0,1.0} };
	IntervalVector pt(4,_pt);
	g.ibwd(Interval(0,1),box,pt);

	// check the box is inside by testing two corners
	CPPUNIT_ASSERT(f.eval(box.lb()).is_subset(Interval(0,1)));
	CPPUNIT_ASSERT(f.eval(box.ub()).is_subset(Interval(0,1)));

}

void TestInHC4Revise::apply02() {
	Variable x(2),y(2);
	Function f(x,y,sqrt(sqr(x[0]-y[0])+sqr(x[1]-y[1])));

	IntervalVector constY(2,Interval::one());
	Function g(x, f(x,constY));
	IntervalVector box(2,Interval(0,4));
	double _pt[][2] = { {0.5,0.5} , {0.5,0.5} };
	IntervalVector pt(2,_pt);
	g.ibwd(Interval(0,1),box,pt);

	// check the box is inside by testing two corners
	CPPUNIT_ASSERT(almost_eq(g.eval(box.lb()),Interval::one(),1e-07));
	CPPUNIT_ASSERT(almost_eq(g.eval(box.ub()),Interval::one(),1e-07));
}

void TestInHC4Revise::add_mult01() {
//	Function g(&quot;x&quot;,&quot;y&quot;,&quot;x+y&quot;); //0*y&quot;);
//	Variable x,y;
//	Function f(x,y,g(x,0*y));
//	IntervalVector box(2,Interval(0,2));
//	Interval iz(0.9,1.1);
//	f.ibwd(iz,box);
//	f.cf.print();
//	cout &lt;&lt; &quot;inhc4 box=&quot; &lt;&lt; box &lt;&lt; endl;

	Function f(&quot;x&quot;,&quot;y&quot;,&quot;z&quot;,&quot;0*(x-y)+z&quot;);
	IntervalVector box(3,Interval(0,2));
	Interval iw(0.9,1.1);
	f.ibwd(iw,box);
//	f.cf.print();
//	cout &lt;&lt; &quot;inhc4 box=&quot; &lt;&lt; box &lt;&lt; endl;
}

void TestInHC4Revise::bugr900() {
	Function f(&quot;x&quot;,&quot;1+sin(x)&quot;);
	IntervalVector box(1,Interval(0,ibex::next_float(0)));
	IntervalVector pt(1,Interval::zero());
	f.ibwd(f.eval(pt),box,pt);
	CPPUNIT_ASSERT(!box.is_empty());
}

void TestInHC4Revise::issue70() {

	Function f(&quot;x&quot;,&quot;x*0.99&quot;);
	IntervalVector area(1,Interval(-10,10));
	Vector pt(1);
	pt[0]=2;

	f.ibwd(Interval::pos_reals(),area,pt);
	// we don't test exactly [0,10] because the result is actually [-0,10]
	CPPUNIT_ASSERT(area[0].lb()&gt;=0);

	//	//Function f(&quot;ox&quot;,&quot;oy&quot;,&quot;oalpha&quot;,&quot;x&quot;,&quot;y&quot;,&quot;(-(((x-ox)*sin((-oalpha)))+((y-oy)*cos(oalpha))))&quot;);
	//	Function f(&quot;ox&quot;,&quot;oy&quot;,&quot;oalpha&quot;,&quot;x&quot;,&quot;y&quot;,&quot;y*0.99&quot;);
	//	double _area[5][2]={{0, 0} , {0, 0} , {0, 0} , {-0.566920214114, -0.52921419164},{-0.3829882276, 0.394692807304}};
	//	double _pt[5]={0,0,0,-0.548067202877,0.00585228985246};
	//	IntervalVector area(5,_area);
	//	Vector pt(5,_pt);
	//
	//
	//	cout &lt;&lt; &quot;area=&quot; &lt;&lt; area &lt;&lt; endl;
	//	f.ibwd(Interval::pos_reals(),area,pt);
	//	cout &lt;&lt; &quot;area=&quot; &lt;&lt; area &lt;&lt; endl;



}


} // end namespace

</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>TestExprLinearity.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* ============================================================================
 * I B E X - Expression Linearity Tests
 * ============================================================================
 * Copyright   : IMT Atlantique (FRANCE)
 * License     : This program can be distributed under the terms of the GNU LGPL.
 *               See the file COPYING.LESSER.
 *
 * Author(s)   : Gilles Chabert
 * Created     : July 04th, 2017
 * ---------------------------------------------------------------------------- */


#include &quot;TestExprLinearity.h&quot;
#include &quot;ibex_ExprLinearity.h&quot;

using namespace std;

namespace ibex {

void TestExprLinearity::test01() {
	const ExprSymbol&amp; x=ExprSymbol::new_();
	const ExprSymbol&amp; y=ExprSymbol::new_();
	Array&lt;const ExprSymbol&gt; args(x,y);
	const ExprNode&amp; e=x;
	ExprLinearity lin(args,e);

	double _x[][2]={{1,1},{0,0},{0,0}};
	CPPUNIT_ASSERT(lin.coeff_vector(x)==IntervalVector(3,_x));
	cleanup(e,true);
}

void TestExprLinearity::test02() {
	const ExprSymbol&amp; x=ExprSymbol::new_();
	const ExprSymbol&amp; y=ExprSymbol::new_();
	Array&lt;const ExprSymbol&gt; args(x,y);
<A NAME="0"></A>	const ExprNode&amp; e=x+2*y+1;
	ExprLinearity lin(args,e);

<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1357-0.html#0',2,'match1357-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	double _x[][2]={{1,1},{0,0},{0,0}};
	double _y[][2]={{0,0},{1,1},{0,0}};</B></FONT>
	double _e[][2]={{1,1},{2,2},{1,1}};
	CPPUNIT_ASSERT(lin.coeff_vector(x)==IntervalVector(3,_x));
	CPPUNIT_ASSERT(lin.coeff_vector(y)==IntervalVector(3,_y));
	CPPUNIT_ASSERT(lin.coeff_vector(e)==IntervalVector(3,_e));
	cleanup(e,true);
}

void TestExprLinearity::test03() {
	const ExprSymbol&amp; x=ExprSymbol::new_();
	const ExprSymbol&amp; y=ExprSymbol::new_();
	Array&lt;const ExprSymbol&gt; args(x,y);
	const ExprNode&amp; e=3*x+2*y-4*x+5*y+3;
	ExprLinearity lin(args,e);

	double _x[][2]={{1,1},{0,0},{0,0}};
	double _y[][2]={{0,0},{1,1},{0,0}};
	double _e[][2]={{-1,-1},{7,7},{3,3}};
	CPPUNIT_ASSERT(lin.coeff_vector(x)==IntervalVector(3,_x));
	CPPUNIT_ASSERT(lin.coeff_vector(y)==IntervalVector(3,_y));
	CPPUNIT_ASSERT(lin.coeff_vector(e)==IntervalVector(3,_e));
	cleanup(e,true);
}

void TestExprLinearity::test04() {
	const ExprSymbol&amp; x=ExprSymbol::new_();
	const ExprSymbol&amp; y=ExprSymbol::new_();
	Array&lt;const ExprSymbol&gt; args(x,y);
	const ExprConstant&amp; c=ExprConstant::new_scalar(1);
	const ExprNode&amp; e=x+sqr(c);
	ExprLinearity lin(args,e);

	double _x[][2]={{1,1},{0,0},{0,0}};
	double _e[][2]={{1,1},{0,0},{1,1}};

	CPPUNIT_ASSERT(lin.coeff_vector(x)==IntervalVector(3,_x));
	CPPUNIT_ASSERT(lin.coeff_vector(e)==IntervalVector(3,_e));
	cleanup(e,true);
}

void TestExprLinearity::test05() {
	const ExprSymbol&amp; x=ExprSymbol::new_();
	const ExprSymbol&amp; y=ExprSymbol::new_();
	Array&lt;const ExprSymbol&gt; args(x,y);
	const ExprNode&amp; e1=2*x;
	const ExprNode&amp; e=sin(x)*e1+y;
	ExprLinearity lin(args,e);

	double _e1[][2]={{2,2},{0,0},{0,0}};
	double _e[][2]={{NEG_INFINITY,POS_INFINITY},{1,1},{0,0}};

	CPPUNIT_ASSERT(lin.coeff_vector(e1)==IntervalVector(3,_e1));
	CPPUNIT_ASSERT(lin.coeff_vector(e)==IntervalVector(3,_e));
	cleanup(e,true);
}

void TestExprLinearity::test06() {
	Matrix A=Matrix::rand(2,3);
	const ExprSymbol&amp; x=ExprSymbol::new_(Dim::col_vec(3));
	const ExprSymbol&amp; y=ExprSymbol::new_();
	Array&lt;const ExprSymbol&gt; args(x,y);
	const ExprNode&amp; e=A*x;
	ExprLinearity lin(args,e);
	IntervalMatrix dx=lin.coeff_matrix(x);
	CPPUNIT_ASSERT(dx.nb_rows()==3 &amp;&amp; dx.nb_cols()==5);
	CPPUNIT_ASSERT(dx.submatrix(0,2,0,2)==Matrix::eye(3));
	CPPUNIT_ASSERT(dx.submatrix(0,2,3,4)==Matrix::zeros(3,2));
	IntervalMatrix de=lin.coeff_matrix(e);
	CPPUNIT_ASSERT(de.nb_rows()==2 &amp;&amp; de.nb_cols()==5);
	CPPUNIT_ASSERT(de.submatrix(0,1,0,2)==A);
	CPPUNIT_ASSERT(de.submatrix(0,1,3,4)==Matrix::zeros(2,2));
	cleanup(e,true);
}

void TestExprLinearity::test07() {
	Matrix A=Matrix::rand(2,3);
	Vector b=A[1];

	const ExprSymbol&amp; x=ExprSymbol::new_(Dim::col_vec(3));
	const ExprSymbol&amp; y=ExprSymbol::new_();
	Array&lt;const ExprSymbol&gt; args(x,y);
	Array&lt;const ExprNode&gt; array(A*x,y,b);
	const ExprVector&amp; e=ExprVector::new_(array,ExprVector::COL);
	ExprLinearity lin(args,e);
	IntervalMatrix de=lin.coeff_matrix(e);
	CPPUNIT_ASSERT(de.nb_rows()==6 &amp;&amp; de.nb_cols()==5);
	CPPUNIT_ASSERT(de.submatrix(0,1,0,2)==A);
	CPPUNIT_ASSERT(de.submatrix(2,2,0,2)==Matrix::zeros(1,3));
	CPPUNIT_ASSERT(de[2][3]==Interval::one());
	CPPUNIT_ASSERT(de[2][4]==Interval::zero());
	CPPUNIT_ASSERT(de.submatrix(3,5,0,3)==Matrix::zeros(3,4));
	CPPUNIT_ASSERT(de.submatrix(3,5,4,4).col(0)==b);
	cleanup(e,true);
}

void TestExprLinearity::test08() {
	Matrix A=Matrix::rand(2,3);
	Matrix A2=Matrix::rand(2,3);
	Vector b=A.col(1);
	const ExprSymbol&amp; x=ExprSymbol::new_(Dim::col_vec(3));
	const ExprSymbol&amp; y=ExprSymbol::new_(Dim::col_vec(3));
	Array&lt;const ExprSymbol&gt; args(x,y);

	const ExprNode&amp; e=A*x+A2*y+b;
	ExprLinearity lin(args,e);
	IntervalMatrix de=lin.coeff_matrix(e);
	CPPUNIT_ASSERT(de.nb_rows()==2 &amp;&amp; de.nb_cols()==7);
	CPPUNIT_ASSERT(de.submatrix(0,1,0,2)==A);
	CPPUNIT_ASSERT(de.submatrix(0,1,3,5)==A2);
	CPPUNIT_ASSERT(de.submatrix(0,1,6,6).col(0)==b);
	cleanup(e,true);
}

void TestExprLinearity::test09() {
	const ExprSymbol&amp; x=ExprSymbol::new_(Dim::col_vec(3));
	Array&lt;const ExprNode&gt; array(3*x[0]+4*x[1]-2*x[2]+1,-x[0]+2*x[1]-x[2]-2);
	const ExprVector&amp; e=ExprVector::new_(array,ExprVector::COL);
	ExprLinearity lin(x,e);
	IntervalMatrix de=lin.coeff_matrix(e);

	double _de[8]={3,4,-2,1,-1,2,-1,-2};
	CPPUNIT_ASSERT(de.nb_rows()==2 &amp;&amp; de.nb_cols()==4);
	CPPUNIT_ASSERT(de==Matrix(2,4,_de));
	cleanup(e,true);
}

void TestExprLinearity::test10() {
	const ExprSymbol&amp; x=ExprSymbol::new_(Dim::col_vec(3));
	Array&lt;const ExprNode&gt; array(3*x[0]+4*x[1]-2*x[2]+1,-x[0]+2*x[1]-x[2]-2);
	Matrix A=Matrix::rand(2,3);
	Vector b=A.col(1);
	const ExprNode&amp; e=A*x + ExprVector::new_(array,ExprVector::COL) + b;
	ExprLinearity lin(x,e);
	IntervalMatrix de=lin.coeff_matrix(e);

	double _de1[6]={3,4,-2,-1,2,-1};
	double _de2[2]={1,-2};
	CPPUNIT_ASSERT(de.nb_rows()==2 &amp;&amp; de.nb_cols()==4);
	CPPUNIT_ASSERT(almost_eq(de.submatrix(0,1,0,2),(A+Matrix(2,3,_de1)),1e-10));
	CPPUNIT_ASSERT(almost_eq(de.submatrix(0,1,3,3).col(0),b+Vector(2,_de2),1e-10));
	cleanup(e,true);
}

void TestExprLinearity::test11() {
	const ExprSymbol&amp; x=ExprSymbol::new_();
	const ExprSymbol&amp; y=ExprSymbol::new_();
	Array&lt;const ExprSymbol&gt; args(x,y);
	Array&lt;const ExprNode&gt; vec1(x,ExprConstant::new_scalar(0),2*y);
	Array&lt;const ExprNode&gt; vec2(x,ExprConstant::new_scalar(0),ExprConstant::new_scalar(3));
	const ExprNode&amp; e=ExprVector::new_row(vec1)*ExprVector::new_col(vec2);
	ExprLinearity lin(args,e);
	IntervalVector de=lin.coeff_vector(e);

	CPPUNIT_ASSERT(de[0]==Interval::all_reals());
	CPPUNIT_ASSERT(de[1]==6);
	cleanup(e,true);

}


} // end namespace

</PRE>
</div>
  </div>
</body>
</html>
