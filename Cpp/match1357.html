<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for TestInHC4Revise.cpp &amp; TestExprLinearity.cpp</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for TestInHC4Revise.cpp &amp; TestExprLinearity.cpp
      </h3>
<h1 align="center">
        5.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>TestInHC4Revise.cpp (11.881188%)<th>TestExprLinearity.cpp (3.821656%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(68-70)<td><a href="#" name="0">(39-40)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>TestInHC4Revise.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "TestInHC4Revise.h"
2 #include "ibex_Function.h"
3 #include "ibex_Expr.h"
4 using namespace std;
5 namespace ibex {
6 void TestInHC4Revise::add01() {
7 	Variable x,y;
8 	Function f(x,y,x+y);
9 	double init_xy[][2]= { {-1,1}, {-1,1} };
10 	IntervalVector box(2,init_xy);
11 	f.ibwd(Interval(0,1),box);
12 	CPPUNIT_ASSERT((box[0]+box[1]).is_subset(Interval(0,1)));
13 	check(box[0].lb()+box[1].lb(),0);
14 	check(box[0].ub()+box[1].ub(),1);
15 }
16 void TestInHC4Revise::add02() {
17 	Variable x;
18 	Function f(x,x+Interval(0,1));
19 	IntervalVector box(1,Interval(0,1));
20 	f.ibwd(Interval(0,1),box);
21 	CPPUNIT_ASSERT(box.is_empty() || 			box[0]==Interval(1,1));
22 }
23 void TestInHC4Revise::dist01() {
24 	Variable x(2),y(2);
25 	Function f(x,y,sqrt(sqr(x[0]-y[0])+sqr(x[1]-y[1])));
26 	IntervalVector box(4,Interval(0,4));
27 	double _pt[][2] = { {0.5,0.5} , {0.5,0.5} , {1.0,1.0} , {1.0,1.0} };
28 	IntervalVector pt(4,_pt);
29 	f.ibwd(Interval(0,1),box,pt);
30 	CPPUNIT_ASSERT(f.eval(box.lb()).is_subset(Interval(0,1)));
31 	CPPUNIT_ASSERT(f.eval(box.ub()).is_subset(Interval(0,1)));
32 }
33 <a name="0"></a>void TestInHC4Revise::dist02() {
34 	Variable x(2);
35 	Function f(x,sqr(x[0])+sqr(x[1]));
36 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	double _box[][2] = { {0, 1.5}, {-1, 0.1} };
37 	IntervalVector box(2,_box);
38 	double _pt[][2] = { {1.5,1.5} , {0.1,0.1} };</b></font>
39 	IntervalVector pt(2,_pt);
40 	f.ibwd(Interval(1,POS_INFINITY),box,pt);
41 //	
42 }
43 void TestInHC4Revise::apply01() {
44 	Variable x(2),y(2);
45 	Function f(x,y,sqrt(sqr(x[0]-y[0])+sqr(x[1]-y[1])));
46 	Function g(x,y,f(x,y));
47 	IntervalVector box(4,Interval(0,4));
48 	double _pt[][2] = { {0.5,0.5} , {0.5,0.5} , {1.0,1.0} , {1.0,1.0} };
49 	IntervalVector pt(4,_pt);
50 	g.ibwd(Interval(0,1),box,pt);
51 	CPPUNIT_ASSERT(f.eval(box.lb()).is_subset(Interval(0,1)));
52 	CPPUNIT_ASSERT(f.eval(box.ub()).is_subset(Interval(0,1)));
53 }
54 void TestInHC4Revise::apply02() {
55 	Variable x(2),y(2);
56 	Function f(x,y,sqrt(sqr(x[0]-y[0])+sqr(x[1]-y[1])));
57 	IntervalVector constY(2,Interval::one());
58 	Function g(x, f(x,constY));
59 	IntervalVector box(2,Interval(0,4));
60 	double _pt[][2] = { {0.5,0.5} , {0.5,0.5} };
61 	IntervalVector pt(2,_pt);
62 	g.ibwd(Interval(0,1),box,pt);
63 	CPPUNIT_ASSERT(almost_eq(g.eval(box.lb()),Interval::one(),1e-07));
64 	CPPUNIT_ASSERT(almost_eq(g.eval(box.ub()),Interval::one(),1e-07));
65 }
66 void TestInHC4Revise::add_mult01() {
67 	Function f("x","y","z","0*(x-y)+z");
68 	IntervalVector box(3,Interval(0,2));
69 	Interval iw(0.9,1.1);
70 	f.ibwd(iw,box);
71 }
72 void TestInHC4Revise::bugr900() {
73 	Function f("x","1+sin(x)");
74 	IntervalVector box(1,Interval(0,ibex::next_float(0)));
75 	IntervalVector pt(1,Interval::zero());
76 	f.ibwd(f.eval(pt),box,pt);
77 	CPPUNIT_ASSERT(!box.is_empty());
78 }
79 void TestInHC4Revise::issue70() {
80 	Function f("x","x*0.99");
81 	IntervalVector area(1,Interval(-10,10));
82 	Vector pt(1);
83 	pt[0]=2;
84 	f.ibwd(Interval::pos_reals(),area,pt);
85 	CPPUNIT_ASSERT(area[0].lb()&gt;=0);
86 }
87 } 
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>TestExprLinearity.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "TestExprLinearity.h"
2 #include "ibex_ExprLinearity.h"
3 using namespace std;
4 namespace ibex {
5 void TestExprLinearity::test01() {
6 	const ExprSymbol&amp; x=ExprSymbol::new_();
7 	const ExprSymbol&amp; y=ExprSymbol::new_();
8 	Array&lt;const ExprSymbol&gt; args(x,y);
9 	const ExprNode&amp; e=x;
10 	ExprLinearity lin(args,e);
11 	double _x[][2]={{1,1},{0,0},{0,0}};
12 	CPPUNIT_ASSERT(lin.coeff_vector(x)==IntervalVector(3,_x));
13 	cleanup(e,true);
14 }
15 void TestExprLinearity::test02() {
16 	const ExprSymbol&amp; x=ExprSymbol::new_();
17 	const ExprSymbol&amp; y=ExprSymbol::new_();
18 	Array&lt;const ExprSymbol&gt; args(x,y);
19 <a name="0"></a>	const ExprNode&amp; e=x+2*y+1;
20 	ExprLinearity lin(args,e);
21 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	double _x[][2]={{1,1},{0,0},{0,0}};
22 	double _y[][2]={{0,0},{1,1},{0,0}};</b></font>
23 	double _e[][2]={{1,1},{2,2},{1,1}};
24 	CPPUNIT_ASSERT(lin.coeff_vector(x)==IntervalVector(3,_x));
25 	CPPUNIT_ASSERT(lin.coeff_vector(y)==IntervalVector(3,_y));
26 	CPPUNIT_ASSERT(lin.coeff_vector(e)==IntervalVector(3,_e));
27 	cleanup(e,true);
28 }
29 void TestExprLinearity::test03() {
30 	const ExprSymbol&amp; x=ExprSymbol::new_();
31 	const ExprSymbol&amp; y=ExprSymbol::new_();
32 	Array&lt;const ExprSymbol&gt; args(x,y);
33 	const ExprNode&amp; e=3*x+2*y-4*x+5*y+3;
34 	ExprLinearity lin(args,e);
35 	double _x[][2]={{1,1},{0,0},{0,0}};
36 	double _y[][2]={{0,0},{1,1},{0,0}};
37 	double _e[][2]={{-1,-1},{7,7},{3,3}};
38 	CPPUNIT_ASSERT(lin.coeff_vector(x)==IntervalVector(3,_x));
39 	CPPUNIT_ASSERT(lin.coeff_vector(y)==IntervalVector(3,_y));
40 	CPPUNIT_ASSERT(lin.coeff_vector(e)==IntervalVector(3,_e));
41 	cleanup(e,true);
42 }
43 void TestExprLinearity::test04() {
44 	const ExprSymbol&amp; x=ExprSymbol::new_();
45 	const ExprSymbol&amp; y=ExprSymbol::new_();
46 	Array&lt;const ExprSymbol&gt; args(x,y);
47 	const ExprConstant&amp; c=ExprConstant::new_scalar(1);
48 	const ExprNode&amp; e=x+sqr(c);
49 	ExprLinearity lin(args,e);
50 	double _x[][2]={{1,1},{0,0},{0,0}};
51 	double _e[][2]={{1,1},{0,0},{1,1}};
52 	CPPUNIT_ASSERT(lin.coeff_vector(x)==IntervalVector(3,_x));
53 	CPPUNIT_ASSERT(lin.coeff_vector(e)==IntervalVector(3,_e));
54 	cleanup(e,true);
55 }
56 void TestExprLinearity::test05() {
57 	const ExprSymbol&amp; x=ExprSymbol::new_();
58 	const ExprSymbol&amp; y=ExprSymbol::new_();
59 	Array&lt;const ExprSymbol&gt; args(x,y);
60 	const ExprNode&amp; e1=2*x;
61 	const ExprNode&amp; e=sin(x)*e1+y;
62 	ExprLinearity lin(args,e);
63 	double _e1[][2]={{2,2},{0,0},{0,0}};
64 	double _e[][2]={{NEG_INFINITY,POS_INFINITY},{1,1},{0,0}};
65 	CPPUNIT_ASSERT(lin.coeff_vector(e1)==IntervalVector(3,_e1));
66 	CPPUNIT_ASSERT(lin.coeff_vector(e)==IntervalVector(3,_e));
67 	cleanup(e,true);
68 }
69 void TestExprLinearity::test06() {
70 	Matrix A=Matrix::rand(2,3);
71 	const ExprSymbol&amp; x=ExprSymbol::new_(Dim::col_vec(3));
72 	const ExprSymbol&amp; y=ExprSymbol::new_();
73 	Array&lt;const ExprSymbol&gt; args(x,y);
74 	const ExprNode&amp; e=A*x;
75 	ExprLinearity lin(args,e);
76 	IntervalMatrix dx=lin.coeff_matrix(x);
77 	CPPUNIT_ASSERT(dx.nb_rows()==3 &amp;&amp; dx.nb_cols()==5);
78 	CPPUNIT_ASSERT(dx.submatrix(0,2,0,2)==Matrix::eye(3));
79 	CPPUNIT_ASSERT(dx.submatrix(0,2,3,4)==Matrix::zeros(3,2));
80 	IntervalMatrix de=lin.coeff_matrix(e);
81 	CPPUNIT_ASSERT(de.nb_rows()==2 &amp;&amp; de.nb_cols()==5);
82 	CPPUNIT_ASSERT(de.submatrix(0,1,0,2)==A);
83 	CPPUNIT_ASSERT(de.submatrix(0,1,3,4)==Matrix::zeros(2,2));
84 	cleanup(e,true);
85 }
86 void TestExprLinearity::test07() {
87 	Matrix A=Matrix::rand(2,3);
88 	Vector b=A[1];
89 	const ExprSymbol&amp; x=ExprSymbol::new_(Dim::col_vec(3));
90 	const ExprSymbol&amp; y=ExprSymbol::new_();
91 	Array&lt;const ExprSymbol&gt; args(x,y);
92 	Array&lt;const ExprNode&gt; array(A*x,y,b);
93 	const ExprVector&amp; e=ExprVector::new_(array,ExprVector::COL);
94 	ExprLinearity lin(args,e);
95 	IntervalMatrix de=lin.coeff_matrix(e);
96 	CPPUNIT_ASSERT(de.nb_rows()==6 &amp;&amp; de.nb_cols()==5);
97 	CPPUNIT_ASSERT(de.submatrix(0,1,0,2)==A);
98 	CPPUNIT_ASSERT(de.submatrix(2,2,0,2)==Matrix::zeros(1,3));
99 	CPPUNIT_ASSERT(de[2][3]==Interval::one());
100 	CPPUNIT_ASSERT(de[2][4]==Interval::zero());
101 	CPPUNIT_ASSERT(de.submatrix(3,5,0,3)==Matrix::zeros(3,4));
102 	CPPUNIT_ASSERT(de.submatrix(3,5,4,4).col(0)==b);
103 	cleanup(e,true);
104 }
105 void TestExprLinearity::test08() {
106 	Matrix A=Matrix::rand(2,3);
107 	Matrix A2=Matrix::rand(2,3);
108 	Vector b=A.col(1);
109 	const ExprSymbol&amp; x=ExprSymbol::new_(Dim::col_vec(3));
110 	const ExprSymbol&amp; y=ExprSymbol::new_(Dim::col_vec(3));
111 	Array&lt;const ExprSymbol&gt; args(x,y);
112 	const ExprNode&amp; e=A*x+A2*y+b;
113 	ExprLinearity lin(args,e);
114 	IntervalMatrix de=lin.coeff_matrix(e);
115 	CPPUNIT_ASSERT(de.nb_rows()==2 &amp;&amp; de.nb_cols()==7);
116 	CPPUNIT_ASSERT(de.submatrix(0,1,0,2)==A);
117 	CPPUNIT_ASSERT(de.submatrix(0,1,3,5)==A2);
118 	CPPUNIT_ASSERT(de.submatrix(0,1,6,6).col(0)==b);
119 	cleanup(e,true);
120 }
121 void TestExprLinearity::test09() {
122 	const ExprSymbol&amp; x=ExprSymbol::new_(Dim::col_vec(3));
123 	Array&lt;const ExprNode&gt; array(3*x[0]+4*x[1]-2*x[2]+1,-x[0]+2*x[1]-x[2]-2);
124 	const ExprVector&amp; e=ExprVector::new_(array,ExprVector::COL);
125 	ExprLinearity lin(x,e);
126 	IntervalMatrix de=lin.coeff_matrix(e);
127 	double _de[8]={3,4,-2,1,-1,2,-1,-2};
128 	CPPUNIT_ASSERT(de.nb_rows()==2 &amp;&amp; de.nb_cols()==4);
129 	CPPUNIT_ASSERT(de==Matrix(2,4,_de));
130 	cleanup(e,true);
131 }
132 void TestExprLinearity::test10() {
133 	const ExprSymbol&amp; x=ExprSymbol::new_(Dim::col_vec(3));
134 	Array&lt;const ExprNode&gt; array(3*x[0]+4*x[1]-2*x[2]+1,-x[0]+2*x[1]-x[2]-2);
135 	Matrix A=Matrix::rand(2,3);
136 	Vector b=A.col(1);
137 	const ExprNode&amp; e=A*x + ExprVector::new_(array,ExprVector::COL) + b;
138 	ExprLinearity lin(x,e);
139 	IntervalMatrix de=lin.coeff_matrix(e);
140 	double _de1[6]={3,4,-2,-1,2,-1};
141 	double _de2[2]={1,-2};
142 	CPPUNIT_ASSERT(de.nb_rows()==2 &amp;&amp; de.nb_cols()==4);
143 	CPPUNIT_ASSERT(almost_eq(de.submatrix(0,1,0,2),(A+Matrix(2,3,_de1)),1e-10));
144 	CPPUNIT_ASSERT(almost_eq(de.submatrix(0,1,3,3).col(0),b+Vector(2,_de2),1e-10));
145 	cleanup(e,true);
146 }
147 void TestExprLinearity::test11() {
148 	const ExprSymbol&amp; x=ExprSymbol::new_();
149 	const ExprSymbol&amp; y=ExprSymbol::new_();
150 	Array&lt;const ExprSymbol&gt; args(x,y);
151 	Array&lt;const ExprNode&gt; vec1(x,ExprConstant::new_scalar(0),2*y);
152 	Array&lt;const ExprNode&gt; vec2(x,ExprConstant::new_scalar(0),ExprConstant::new_scalar(3));
153 	const ExprNode&amp; e=ExprVector::new_row(vec1)*ExprVector::new_col(vec2);
154 	ExprLinearity lin(args,e);
155 	IntervalVector de=lin.coeff_vector(e);
156 	CPPUNIT_ASSERT(de[0]==Interval::all_reals());
157 	CPPUNIT_ASSERT(de[1]==6);
158 	cleanup(e,true);
159 }
160 } 
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
