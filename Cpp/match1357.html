<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for TestInHC4Revise.cpp &amp; TestExprLinearity.cpp</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for TestInHC4Revise.cpp &amp; TestExprLinearity.cpp
      </h3>
<h1 align="center">
        5.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>TestInHC4Revise.cpp (11.881188%)<th>TestExprLinearity.cpp (3.821656%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(68-70)<td><a href="#" name="0">(39-40)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>TestInHC4Revise.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include "TestInHC4Revise.h"
#include "ibex_Function.h"
#include "ibex_Expr.h"
using namespace std;
namespace ibex {
void TestInHC4Revise::add01() {
	Variable x,y;
	Function f(x,y,x+y);
	double init_xy[][2]= { {-1,1}, {-1,1} };
	IntervalVector box(2,init_xy);
	f.ibwd(Interval(0,1),box);
	CPPUNIT_ASSERT((box[0]+box[1]).is_subset(Interval(0,1)));
	check(box[0].lb()+box[1].lb(),0);
	check(box[0].ub()+box[1].ub(),1);
}
void TestInHC4Revise::add02() {
	Variable x;
	Function f(x,x+Interval(0,1));
	IntervalVector box(1,Interval(0,1));
	f.ibwd(Interval(0,1),box);
	CPPUNIT_ASSERT(box.is_empty() || 			box[0]==Interval(1,1));
}
void TestInHC4Revise::dist01() {
	Variable x(2),y(2);
	Function f(x,y,sqrt(sqr(x[0]-y[0])+sqr(x[1]-y[1])));
	IntervalVector box(4,Interval(0,4));
	double _pt[][2] = { {0.5,0.5} , {0.5,0.5} , {1.0,1.0} , {1.0,1.0} };
	IntervalVector pt(4,_pt);
	f.ibwd(Interval(0,1),box,pt);
	CPPUNIT_ASSERT(f.eval(box.lb()).is_subset(Interval(0,1)));
	CPPUNIT_ASSERT(f.eval(box.ub()).is_subset(Interval(0,1)));
}
<a name="0"></a>void TestInHC4Revise::dist02() {
	Variable x(2);
	Function f(x,sqr(x[0])+sqr(x[1]));
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	double _box[][2] = { {0, 1.5}, {-1, 0.1} };
	IntervalVector box(2,_box);
	double _pt[][2] = { {1.5,1.5} , {0.1,0.1} };</b></font>
	IntervalVector pt(2,_pt);
	f.ibwd(Interval(1,POS_INFINITY),box,pt);
//	
}
void TestInHC4Revise::apply01() {
	Variable x(2),y(2);
	Function f(x,y,sqrt(sqr(x[0]-y[0])+sqr(x[1]-y[1])));
	Function g(x,y,f(x,y));
	IntervalVector box(4,Interval(0,4));
	double _pt[][2] = { {0.5,0.5} , {0.5,0.5} , {1.0,1.0} , {1.0,1.0} };
	IntervalVector pt(4,_pt);
	g.ibwd(Interval(0,1),box,pt);
	CPPUNIT_ASSERT(f.eval(box.lb()).is_subset(Interval(0,1)));
	CPPUNIT_ASSERT(f.eval(box.ub()).is_subset(Interval(0,1)));
}
void TestInHC4Revise::apply02() {
	Variable x(2),y(2);
	Function f(x,y,sqrt(sqr(x[0]-y[0])+sqr(x[1]-y[1])));
	IntervalVector constY(2,Interval::one());
	Function g(x, f(x,constY));
	IntervalVector box(2,Interval(0,4));
	double _pt[][2] = { {0.5,0.5} , {0.5,0.5} };
	IntervalVector pt(2,_pt);
	g.ibwd(Interval(0,1),box,pt);
	CPPUNIT_ASSERT(almost_eq(g.eval(box.lb()),Interval::one(),1e-07));
	CPPUNIT_ASSERT(almost_eq(g.eval(box.ub()),Interval::one(),1e-07));
}
void TestInHC4Revise::add_mult01() {
	Function f("x","y","z","0*(x-y)+z");
	IntervalVector box(3,Interval(0,2));
	Interval iw(0.9,1.1);
	f.ibwd(iw,box);
}
void TestInHC4Revise::bugr900() {
	Function f("x","1+sin(x)");
	IntervalVector box(1,Interval(0,ibex::next_float(0)));
	IntervalVector pt(1,Interval::zero());
	f.ibwd(f.eval(pt),box,pt);
	CPPUNIT_ASSERT(!box.is_empty());
}
void TestInHC4Revise::issue70() {
	Function f("x","x*0.99");
	IntervalVector area(1,Interval(-10,10));
	Vector pt(1);
	pt[0]=2;
	f.ibwd(Interval::pos_reals(),area,pt);
	CPPUNIT_ASSERT(area[0].lb()&gt;=0);
}
} 
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>TestExprLinearity.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include "TestExprLinearity.h"
#include "ibex_ExprLinearity.h"
using namespace std;
namespace ibex {
void TestExprLinearity::test01() {
	const ExprSymbol&amp; x=ExprSymbol::new_();
	const ExprSymbol&amp; y=ExprSymbol::new_();
	Array&lt;const ExprSymbol&gt; args(x,y);
	const ExprNode&amp; e=x;
	ExprLinearity lin(args,e);
	double _x[][2]={{1,1},{0,0},{0,0}};
	CPPUNIT_ASSERT(lin.coeff_vector(x)==IntervalVector(3,_x));
	cleanup(e,true);
}
void TestExprLinearity::test02() {
	const ExprSymbol&amp; x=ExprSymbol::new_();
	const ExprSymbol&amp; y=ExprSymbol::new_();
	Array&lt;const ExprSymbol&gt; args(x,y);
<a name="0"></a>	const ExprNode&amp; e=x+2*y+1;
	ExprLinearity lin(args,e);
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	double _x[][2]={{1,1},{0,0},{0,0}};
	double _y[][2]={{0,0},{1,1},{0,0}};</b></font>
	double _e[][2]={{1,1},{2,2},{1,1}};
	CPPUNIT_ASSERT(lin.coeff_vector(x)==IntervalVector(3,_x));
	CPPUNIT_ASSERT(lin.coeff_vector(y)==IntervalVector(3,_y));
	CPPUNIT_ASSERT(lin.coeff_vector(e)==IntervalVector(3,_e));
	cleanup(e,true);
}
void TestExprLinearity::test03() {
	const ExprSymbol&amp; x=ExprSymbol::new_();
	const ExprSymbol&amp; y=ExprSymbol::new_();
	Array&lt;const ExprSymbol&gt; args(x,y);
	const ExprNode&amp; e=3*x+2*y-4*x+5*y+3;
	ExprLinearity lin(args,e);
	double _x[][2]={{1,1},{0,0},{0,0}};
	double _y[][2]={{0,0},{1,1},{0,0}};
	double _e[][2]={{-1,-1},{7,7},{3,3}};
	CPPUNIT_ASSERT(lin.coeff_vector(x)==IntervalVector(3,_x));
	CPPUNIT_ASSERT(lin.coeff_vector(y)==IntervalVector(3,_y));
	CPPUNIT_ASSERT(lin.coeff_vector(e)==IntervalVector(3,_e));
	cleanup(e,true);
}
void TestExprLinearity::test04() {
	const ExprSymbol&amp; x=ExprSymbol::new_();
	const ExprSymbol&amp; y=ExprSymbol::new_();
	Array&lt;const ExprSymbol&gt; args(x,y);
	const ExprConstant&amp; c=ExprConstant::new_scalar(1);
	const ExprNode&amp; e=x+sqr(c);
	ExprLinearity lin(args,e);
	double _x[][2]={{1,1},{0,0},{0,0}};
	double _e[][2]={{1,1},{0,0},{1,1}};
	CPPUNIT_ASSERT(lin.coeff_vector(x)==IntervalVector(3,_x));
	CPPUNIT_ASSERT(lin.coeff_vector(e)==IntervalVector(3,_e));
	cleanup(e,true);
}
void TestExprLinearity::test05() {
	const ExprSymbol&amp; x=ExprSymbol::new_();
	const ExprSymbol&amp; y=ExprSymbol::new_();
	Array&lt;const ExprSymbol&gt; args(x,y);
	const ExprNode&amp; e1=2*x;
	const ExprNode&amp; e=sin(x)*e1+y;
	ExprLinearity lin(args,e);
	double _e1[][2]={{2,2},{0,0},{0,0}};
	double _e[][2]={{NEG_INFINITY,POS_INFINITY},{1,1},{0,0}};
	CPPUNIT_ASSERT(lin.coeff_vector(e1)==IntervalVector(3,_e1));
	CPPUNIT_ASSERT(lin.coeff_vector(e)==IntervalVector(3,_e));
	cleanup(e,true);
}
void TestExprLinearity::test06() {
	Matrix A=Matrix::rand(2,3);
	const ExprSymbol&amp; x=ExprSymbol::new_(Dim::col_vec(3));
	const ExprSymbol&amp; y=ExprSymbol::new_();
	Array&lt;const ExprSymbol&gt; args(x,y);
	const ExprNode&amp; e=A*x;
	ExprLinearity lin(args,e);
	IntervalMatrix dx=lin.coeff_matrix(x);
	CPPUNIT_ASSERT(dx.nb_rows()==3 &amp;&amp; dx.nb_cols()==5);
	CPPUNIT_ASSERT(dx.submatrix(0,2,0,2)==Matrix::eye(3));
	CPPUNIT_ASSERT(dx.submatrix(0,2,3,4)==Matrix::zeros(3,2));
	IntervalMatrix de=lin.coeff_matrix(e);
	CPPUNIT_ASSERT(de.nb_rows()==2 &amp;&amp; de.nb_cols()==5);
	CPPUNIT_ASSERT(de.submatrix(0,1,0,2)==A);
	CPPUNIT_ASSERT(de.submatrix(0,1,3,4)==Matrix::zeros(2,2));
	cleanup(e,true);
}
void TestExprLinearity::test07() {
	Matrix A=Matrix::rand(2,3);
	Vector b=A[1];
	const ExprSymbol&amp; x=ExprSymbol::new_(Dim::col_vec(3));
	const ExprSymbol&amp; y=ExprSymbol::new_();
	Array&lt;const ExprSymbol&gt; args(x,y);
	Array&lt;const ExprNode&gt; array(A*x,y,b);
	const ExprVector&amp; e=ExprVector::new_(array,ExprVector::COL);
	ExprLinearity lin(args,e);
	IntervalMatrix de=lin.coeff_matrix(e);
	CPPUNIT_ASSERT(de.nb_rows()==6 &amp;&amp; de.nb_cols()==5);
	CPPUNIT_ASSERT(de.submatrix(0,1,0,2)==A);
	CPPUNIT_ASSERT(de.submatrix(2,2,0,2)==Matrix::zeros(1,3));
	CPPUNIT_ASSERT(de[2][3]==Interval::one());
	CPPUNIT_ASSERT(de[2][4]==Interval::zero());
	CPPUNIT_ASSERT(de.submatrix(3,5,0,3)==Matrix::zeros(3,4));
	CPPUNIT_ASSERT(de.submatrix(3,5,4,4).col(0)==b);
	cleanup(e,true);
}
void TestExprLinearity::test08() {
	Matrix A=Matrix::rand(2,3);
	Matrix A2=Matrix::rand(2,3);
	Vector b=A.col(1);
	const ExprSymbol&amp; x=ExprSymbol::new_(Dim::col_vec(3));
	const ExprSymbol&amp; y=ExprSymbol::new_(Dim::col_vec(3));
	Array&lt;const ExprSymbol&gt; args(x,y);
	const ExprNode&amp; e=A*x+A2*y+b;
	ExprLinearity lin(args,e);
	IntervalMatrix de=lin.coeff_matrix(e);
	CPPUNIT_ASSERT(de.nb_rows()==2 &amp;&amp; de.nb_cols()==7);
	CPPUNIT_ASSERT(de.submatrix(0,1,0,2)==A);
	CPPUNIT_ASSERT(de.submatrix(0,1,3,5)==A2);
	CPPUNIT_ASSERT(de.submatrix(0,1,6,6).col(0)==b);
	cleanup(e,true);
}
void TestExprLinearity::test09() {
	const ExprSymbol&amp; x=ExprSymbol::new_(Dim::col_vec(3));
	Array&lt;const ExprNode&gt; array(3*x[0]+4*x[1]-2*x[2]+1,-x[0]+2*x[1]-x[2]-2);
	const ExprVector&amp; e=ExprVector::new_(array,ExprVector::COL);
	ExprLinearity lin(x,e);
	IntervalMatrix de=lin.coeff_matrix(e);
	double _de[8]={3,4,-2,1,-1,2,-1,-2};
	CPPUNIT_ASSERT(de.nb_rows()==2 &amp;&amp; de.nb_cols()==4);
	CPPUNIT_ASSERT(de==Matrix(2,4,_de));
	cleanup(e,true);
}
void TestExprLinearity::test10() {
	const ExprSymbol&amp; x=ExprSymbol::new_(Dim::col_vec(3));
	Array&lt;const ExprNode&gt; array(3*x[0]+4*x[1]-2*x[2]+1,-x[0]+2*x[1]-x[2]-2);
	Matrix A=Matrix::rand(2,3);
	Vector b=A.col(1);
	const ExprNode&amp; e=A*x + ExprVector::new_(array,ExprVector::COL) + b;
	ExprLinearity lin(x,e);
	IntervalMatrix de=lin.coeff_matrix(e);
	double _de1[6]={3,4,-2,-1,2,-1};
	double _de2[2]={1,-2};
	CPPUNIT_ASSERT(de.nb_rows()==2 &amp;&amp; de.nb_cols()==4);
	CPPUNIT_ASSERT(almost_eq(de.submatrix(0,1,0,2),(A+Matrix(2,3,_de1)),1e-10));
	CPPUNIT_ASSERT(almost_eq(de.submatrix(0,1,3,3).col(0),b+Vector(2,_de2),1e-10));
	cleanup(e,true);
}
void TestExprLinearity::test11() {
	const ExprSymbol&amp; x=ExprSymbol::new_();
	const ExprSymbol&amp; y=ExprSymbol::new_();
	Array&lt;const ExprSymbol&gt; args(x,y);
	Array&lt;const ExprNode&gt; vec1(x,ExprConstant::new_scalar(0),2*y);
	Array&lt;const ExprNode&gt; vec2(x,ExprConstant::new_scalar(0),ExprConstant::new_scalar(3));
	const ExprNode&amp; e=ExprVector::new_row(vec1)*ExprVector::new_col(vec2);
	ExprLinearity lin(args,e);
	IntervalVector de=lin.coeff_vector(e);
	CPPUNIT_ASSERT(de[0]==Interval::all_reals());
	CPPUNIT_ASSERT(de[1]==6);
	cleanup(e,true);
}
} 
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
