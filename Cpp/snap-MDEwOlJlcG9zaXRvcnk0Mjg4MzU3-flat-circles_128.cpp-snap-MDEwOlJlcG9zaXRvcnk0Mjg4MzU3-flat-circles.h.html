
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 32, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-circles_128.cpp</h3>
            <pre><code>1  #include "stdafx.h"
2  #include "circles.h"
3  TGraphAttributes::TGraphAttributes(PUNGraph G, const char* nodeFeaturePath) :
4    G(G) {
5    FILE* f = fopen(nodeFeaturePath, "r");
6    int nNodes;
7    int nF;
8    fscanf(f, "%d %d", &nNodes, &nF);
9    nFeatures = nF;
10    for (int i = 0; i < nNodes; i++) {
11      int nid;
12      fscanf(f, "%d", &nid);
13      if (not G->IsNode(nid)) {
14        printf("Warning: %d is not a node in G.\n", nid);
15      }
16      TInt kv = nodeFeatures.AddKey(nid);
17      for (int x = 0; x < nFeatures; x++) {
18        int z = 0;
19        fscanf(f, "%d", &z);
20        if (z) {
21          nodeFeatures[kv].AddDat(x) = z;
22        }
23      }
24      if (G->IsNode(nid)) {
25        nodeIds.Add(nid);
26      }
27    }
28    fclose(f);
29    for (int i = 0; i < nodeIds.Len(); i++) {
30      TInt ni = nodeIds[i];
31      for (int j = i + 1; j < nodeIds.Len(); j++) {
32        TInt nj = nodeIds[j];
33        TInt kv = edgeFeatures.AddKey(TIntPr(ni, nj));
34        for (THashKeyDatI<TInt, TInt> it = nodeFeatures.GetDat(ni).BegI(); not it.IsEnd(); it++) {
35          TInt k = it.GetKey();
36          TInt diff = 0;
37          if (nodeFeatures.GetDat(nj).IsKey(k)) {
38            diff = abs(it.GetDat() - nodeFeatures.GetDat(nj).GetDat(k));
39          } else {
40            diff = abs(it.GetDat());
41          }
42          if (diff) {
43            edgeFeatures[kv].AddDat(k) = diff;
44          }
45        }
46        for (THashKeyDatI<TInt, TInt> it = nodeFeatures.GetDat(nj).BegI(); not it.IsEnd(); it++) {
47          TInt k = it.GetKey();
48          TInt diff = 0;
49          if (nodeFeatures.GetDat(ni).IsKey(k)) {
50            diff = abs(it.GetDat() - nodeFeatures.GetDat(ni).GetDat(k));
51          } else {
52            diff = abs(it.GetDat());
53          }
54          if (diff) {
55            edgeFeatures[kv].AddDat(k) = diff;
56          }
57        }
58      }
59    }
60  }
61  void TCluster::train(TInt outerReps, TInt gradientReps, TInt mcmcReps) {
62    TFlt increment = 1.0 / (1.0 * gd->nodeIds.Len() * gd->nodeIds.Len());
63    TRnd t;
64    for (int outerRep = 0; outerRep < outerReps; outerRep++) {
65      for (int k = 0; k < K; k++)
66        if (outerRep == 0 or chat[k].Empty() or chat[k].Len()
67            == gd->nodeIds.Len()) {
68          chat[k].Clr();
69          for (int i = 0; i < gd->nodeIds.Len(); i++)
70            if (t.GetUniDevInt(2) == 0) {
71              chat[k].AddKey(i);
72            }
73          for (int i = 0; i < gd->nFeatures; i++)
74            theta[k * gd->nFeatures + i] = 0;
<span onclick='openModal()' class='match'>75          theta[k * gd->nFeatures + t.GetUniDevInt(gd->nFeatures)] = 1.0;
76          theta[k * gd->nFeatures] = 1;
77        }
78      for (int k = 0; k < K; k++)
</span>79        chat[k] = mcmc(k, mcmcReps);
80      TFlt ll_prev = loglikelihood();
81      TFlt ll = 0;
82      for (int gradientRep = 0; gradientRep < gradientReps; gradientRep++) {
83        dl();
84        for (int i = 0; i < K * gd->nFeatures; i++) {
85          theta[i] += increment * dldt[i];
86        }
87        printf(".");
88        fflush( stdout);
89        ll = loglikelihood();
90        if (ll < ll_prev) {
91          for (int i = 0; i < K * gd->nFeatures; i++)
92            theta[i] -= increment * dldt[i];
93          ll = ll_prev;
94          break;
95        }
96        ll_prev = ll;
97      }
98      float llf = ll;
99      printf("\nIteration %d, ll = %f\n", outerRep + 1, llf);
100    }
101  }
102  TFlt inp(TIntIntH& feature, TFlt* parameter) {
103    TFlt res = 0;
104    for (THashKeyDatI<TInt, TInt> it = feature.BegI(); not it.IsEnd(); it++)
105      res += it.GetDat() * parameter[it.GetKey()];
106    return res;
107  }
108  TIntSet TCluster::mcmc(TInt k, TInt mcmcReps) {
109    TRnd t;
110    THash<TInt, TFlt> mc0;
111    THash<TInt, TFlt> mc1;
112    TVec<TInt> newLabel;
113    int csize = 0;
114    for (int i = 0; i < gd->nodeIds.Len(); i++) {
115      if (chat[k].IsKey(gd->nodeIds[i])) {
116        newLabel.Add(0);
117      } else {
118        newLabel.Add(1);
119      }
120      if (chat[k].IsKey(gd->nodeIds[i])) {
121        csize++;
122      }
123    }
124    for (THashKeyDatI<TIntPr, TIntIntH> it = gd->edgeFeatures.BegI(); not it.IsEnd(); it++) {
125      TIntPr e = it.GetKey();
126      TInt kv = gd->edgeFeatures.GetKeyId(e);
127      TInt e1 = e.Val1;
128      TInt e2 = e.Val2;
129      TBool exists = gd->G->IsEdge(e1, e2);
130      TFlt inp_ = inp(it.GetDat(), theta + k * gd->nFeatures);
131      TFlt other_ = 0;
132      for (int l = 0; l < K; l++) {
133        if (l == k) {
134          continue;
135        }
136        TFlt d = (chat[l].IsKey(e1) and chat[l].IsKey(e2)) ? 1 : -1;
137        other_ += d * inp(it.GetDat(), theta + l * gd->nFeatures);
138      }
139      TFlt c0;
140      TFlt c1;
141      if (exists) {
142        c0 = -other_ + inp_ + log(1 + exp(other_ - inp_));
143        c1 = -other_ - inp_ + log(1 + exp(other_ + inp_));
144      } else {
145        c0 = log(1 + exp(other_ - inp_));
146        c1 = log(1 + exp(other_ + inp_));
147      }
148      mc0.AddDat(kv) = -c0;
149      mc1.AddDat(kv) = -c1;
150    }
151    TFlt T1 = 1.0; 
152    for (int r = 2; r < mcmcReps + 2; r++) {
153      TFlt T = T1 / log(r);
154      for (int n = 0; n < gd->nodeIds.Len(); n++) {
155        TFlt l0 = 0;
156        TFlt l1 = 0;
157        for (int np = 0; np < gd->nodeIds.Len(); np++) {
158          if (n == np) {
159            continue;
160          }
161          TIntPr ed(gd->nodeIds[n], gd->nodeIds[np]);
162          if (ed.Val1 > ed.Val2) {
163            ed = TIntPr(ed.Val2, ed.Val1);
164          }
165          TInt kv = gd->edgeFeatures.GetKeyId(ed);
166          TFlt m0 = mc0.GetDat(kv);
167          if (newLabel[np] == 0) {
168            l0 += m0;
169            l1 += m0;
170          } else {
171            l0 += m0;
172            l1 += mc1.GetDat(kv);
173          }
174        }
175        TFlt frac = exp(l1 - l0);
176        TFlt prob = pow(frac, 1.0 / T);
177        if (t.GetUniDev() < prob) {
178          newLabel[n] = 1;
179        } else {
180          newLabel[n] = 0;
181        }
182      }
183    }
184    TIntSet res;
185    for (int i = 0; i < gd->nodeIds.Len(); i++)
186      if (newLabel[i]) {
187        res.AddKey(gd->nodeIds[i]);
188      }
189    return res;
190  }
191  void TCluster::dl(void) {
192    for (int i = 0; i < K * gd->nFeatures; i++) {
193      if (theta[i] > 0) {
194        dldt[i] = -lambda * theta[i];
195      } else {
196        dldt[i] = lambda * theta[i];
197      }
198    }
199    for (THashKeyDatI<TIntPr, TIntIntH> it = gd->edgeFeatures.BegI(); not it.IsEnd(); it++) {
200      TFlt inp_ = 0;
201      TIntPr e = it.GetKey();
202      TInt e1 = e.Val1;
203      TInt e2 = e.Val2;
204      TBool exists = gd->G->IsEdge(e1, e2);
205      for (int k = 0; k < K; k++) {
206        TFlt d = chat[k].IsKey(e1) and chat[k].IsKey(e2) ? 1 : -1;
207        inp_ += d * inp(it.GetDat(), theta + k * gd->nFeatures);
208      }
209      TFlt expinp = exp(inp_);
210      TFlt q = expinp / (1 + expinp);
211      if (q != q) {
212        q = 1; 
213      }
214      for (int k = 0; k < K; k++) {
215        TBool d_ = chat[k].IsKey(e1) and chat[k].IsKey(e2);
216        TFlt d = d_ ? 1 : -1;
217        for (THashKeyDatI<TInt, TInt> itf = it.GetDat().BegI(); not itf.IsEnd(); itf++) {
218          TInt i = itf.GetKey();
219          TInt f = itf.GetDat();
220          if (exists) {
221            dldt[k * gd->nFeatures + i] += d * f;
222          }
223          dldt[k * gd->nFeatures + i] += -d * f * q;
224        }
225      }
226    }
227  }
228  TFlt TCluster::loglikelihood(void) {
229    TFlt ll = 0;
230    for (THashKeyDatI<TIntPr, TIntIntH> it = gd->edgeFeatures.BegI(); not it.IsEnd(); it++) {
231      TFlt inp_ = 0;
232      TIntPr e = it.GetKey();
233      TInt e1 = e.Val1;
234      TInt e2 = e.Val2;
235      TBool exists = gd->G->IsEdge(e1, e2);
236      for (int k = 0; k < K; k++) {
237        TFlt d = chat[k].IsKey(e1) and chat[k].IsKey(e2) ? 1 : -1;
238        inp_ += d * inp(it.GetDat(), theta + k * gd->nFeatures);
239      }
240      if (exists) {
241        ll += inp_;
242      }
243      TFlt ll_ = log(1 + exp(inp_));
244      ll += -ll_;
245    }
246    if (ll != ll) {
247      printf("ll isnan\n");
248      exit(1);
249    }
250    return ll;
251  }
252  int main(int argc, char** argv) {
253    TInt K = 4;
254    TFlt lambda = 1;
255    PUNGraph Graph = TSnap::LoadEdgeList<PUNGraph>("fb1.edges");
256    PGraphAttributes PGA = new TGraphAttributes(Graph, "fb1.features");
257    PCluster PC = new TCluster(PGA, K, lambda);
258    PC->train(50, 100, 100);
259    TVec<TIntSet> circles = PC->getCircles();
260    for (int k = 0; k < K; k ++) {
261      printf("Circle %d:", k + 1);
262      for (THashSetKeyI<TInt> it = circles[k].BegI(); it != circles[k].EndI(); it ++) {
263        int c = it.GetKey();
264        printf(" %d", c);
265      }
266      printf("\n");
267    }
268    return 0;
269  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-circles.h</h3>
            <pre><code>1  #pragma once
2  #include "stdafx.h"
3  class TGraphAttributes {
4  public:
5    TGraphAttributes(PUNGraph G, const char* nodeFeaturePath, const char* groundtruthPath);
6    ~TGraphAttributes() {
7    }
8    PUNGraph G;
9    TInt NFeatures;
10    THash<TInt, TIntIntH> NodeFeatures;
11    THash<TIntPr, TIntIntH> EdgeFeatures;
12    TVec<TInt> NodeIDs;
13    TCRef CRef;
14    TVec<TIntSet> GroundTruth; 
15  };
16  typedef TPt<TGraphAttributes> PGraphAttributes;
17  class TCluster {
18  public:
19    TCluster(PGraphAttributes GraphAttributes, TInt K, TFlt Lambda) :
20      GraphAttributes(GraphAttributes), K(K), Lambda(Lambda) {
21      Theta = new TFlt[K * GraphAttributes->NFeatures];
22      Derivative = new TFlt[K * GraphAttributes->NFeatures];
23      for (int k = 0; k < K; k++) {
24        for (int f = 0; f < GraphAttributes->NFeatures; f++) {
25          Theta[k * GraphAttributes->NFeatures + f] = 0;
26          Derivative[k * GraphAttributes->NFeatures + f] = 0;
27        }
28        CHat.Add(TIntSet());
29      }
30    }
31    ~TCluster() {
32      delete[] Theta;
33      delete[] Derivative;
34    }
35    void Train(TInt OuterReps, TInt GradientReps, TInt MCMCReps);
36    TVec<TIntSet> GetCircles(void) {
37      return CHat;
38    }
39    TCRef CRef;
40  private:
41    TFlt* Theta; 
42    TFlt* Derivative; 
43    TVec<TIntSet> CHat; 
44    PGraphAttributes GraphAttributes; 
45    TInt K;
46    TFlt Lambda;
47    TFlt LogLikelihood();
48    TIntSet MCMC(TInt k, TInt MCMCReps);
49    void Gradient();
50  };
51  typedef TPt<TCluster> PCluster;
52  enum lossType
53  {
54    zeroOne = 0,
55    balancedError = 1,
56    fScore = 2
57  };
58  TFlt Loss(TIntSet& l, TIntSet lHat, int N, int Which)
59  {
60    if (l.Len() == 0) {
61      if (lHat.Len() == 0) {
62        return 0;
63      }
64      return 1.0;
65    }
66    if (lHat.Len() == 0) {
67      if (l.Len() == 0) {
68        return 0;
69      }
70      return 1.0;
71    }
72    TInt TruePositives = 0;
73    TInt FalsePositives = 0;
74    TInt FalseNegatives = 0;
75    TFlt LabelLoss = 0;
76    for (THashSetKeyI<TInt> it = l.BegI(); it != l.EndI(); it ++) {
77      int c = it.GetKey();
78      if (!lHat.IsKey(c)) {
79        FalseNegatives ++;
80        if (Which == zeroOne) {
81          LabelLoss += 1.0/N;
82        }
83        else if (Which == balancedError) {
84          LabelLoss += 0.5/l.Len();
85        }
86      }
87    }
88    for (THashSetKeyI<TInt> it = lHat.BegI(); it != lHat.EndI(); it ++) {
89      int c = it.GetKey();
90      if (!l.IsKey(c)) {
91        FalsePositives ++;
92        if (Which == zeroOne) {
93          LabelLoss += 1.0/N;
94        }
95        else if (Which == balancedError) {
96          LabelLoss += 0.5/(N - l.Len());
97        }
98      }
99      else {
100        TruePositives ++;
101      }
102    }
103    if ((lHat.Len() == 0 || TruePositives == 0) && Which == fScore) {
104      return 1.0;
105    }
106    TFlt precision = (1.0*TruePositives)/lHat.Len();
107    TFlt recall = (1.0*TruePositives)/l.Len();
108    if (Which == fScore) {
109      return 1 - 2 * (precision*recall) / (precision + recall);
110    }
111    return LabelLoss;
112  }
113  TGraphAttributes::TGraphAttributes(PUNGraph G, const char* NodeFeaturePath,
114                                     const char* GroundTruthPath) :
115    G(G) {
116    FILE* f = fopen(NodeFeaturePath, "r");
117    int NNodes;
118    int nF;
119    fscanf(f, "%d %d", &NNodes, &nF);
120    NFeatures = nF;
121    for (int i = 0; i < NNodes; i++) {
122      int nid;
123      fscanf(f, "%d", &nid);
124      if (!G->IsNode(nid)) {
125        printf("Warning: %d is not a node in G.\n", nid);
126      }
127      TInt kv = NodeFeatures.AddKey(nid);
128      for (int x = 0; x < nF; x++) {
129        int z = 0;
130        fscanf(f, "%d", &z);
131        if (z) {
132          NodeFeatures[kv].AddDat(x) = z;
133        }
134      }
135      if (G->IsNode(nid)) {
136        NodeIDs.Add(nid);
137      }
138    }
139    fclose(f);
140    f = fopen(GroundTruthPath, "r");
141    if (f == NULL) {
142      printf("Groundtruth file %s not found.\n", GroundTruthPath);
143    }
144    else {
145      char* CircleName = new char [1000];
146      while (fscanf(f, "%s", CircleName) == 1)
147      {
148        TIntSet Circle;
149        while (true) {
150          int nid;
151          fscanf(f, "%d", &nid);
152          Circle.AddKey(nid);
153          char c;
154          while (true) {          
155            c = fgetc(f);
156            if (c == '\n') break;
157            if (c >= '0' && c <= '9') {
158              fseek(f, -1, SEEK_CUR);
159              break;
160            }
161          }
162          if (c == '\n') break;
163        }
164        GroundTruth.Add(Circle);
165      }
166      delete [] CircleName;
167    }
168    fclose(f);
169    for (int i = 0; i < NodeIDs.Len(); i++) {
170      TInt ni = NodeIDs[i];
171      for (int j = i + 1; j < NodeIDs.Len(); j++) {
172        TInt nj = NodeIDs[j];
173        TInt kv = EdgeFeatures.AddKey(TIntPr(ni, nj));
174        for (THashKeyDatI<TInt, TInt> it = NodeFeatures.GetDat(ni).BegI();
175             !it.IsEnd(); it++) {
176          TInt k = it.GetKey();
177          TInt diff = 0;
178          if (NodeFeatures.GetDat(nj).IsKey(k)) {
179            diff = abs(it.GetDat() - NodeFeatures.GetDat(nj).GetDat(k));
180          } else {
181            diff = abs(it.GetDat());
182          }
183          if (diff) {
184            EdgeFeatures[kv].AddDat(k) = diff;
185          }
186        }
187        for (THashKeyDatI<TInt, TInt> it = NodeFeatures.GetDat(nj).BegI();
188             !it.IsEnd(); it++) {
189          TInt k = it.GetKey();
190          TInt diff = 0;
191          if (NodeFeatures.GetDat(ni).IsKey(k)) {
192            diff = abs(it.GetDat() - NodeFeatures.GetDat(ni).GetDat(k));
193          } else {
194            diff = abs(it.GetDat());
195          }
196          if (diff) {
197            EdgeFeatures[kv].AddDat(k) = diff;
198          }
199        }
200      }
201    }
202  }
203  void TCluster::Train(TInt OuterReps, TInt GradientReps, TInt MCMCReps) {
204    TFlt Increment = 1.0 / (1.0 * GraphAttributes->NodeIDs.Len() * GraphAttributes->NodeIDs.Len());
205    TRnd t;
206    for (int OuterRep = 0; OuterRep < OuterReps; OuterRep++) {
207      for (int k = 0; k < K; k++) {
208        if (OuterRep == 0 || CHat[k].Empty() || CHat[k].Len()
209            == GraphAttributes->NodeIDs.Len()) {
210          CHat[k].Clr();
211          for (int i = 0; i < GraphAttributes->NodeIDs.Len(); i++) {
212            if (t.GetUniDevInt(2) == 0) {
213              CHat[k].AddKey(GraphAttributes->NodeIDs[i]);
214            }
215          }
216          for (int i = 0; i < GraphAttributes->NFeatures; i++) {
217            Theta[k * GraphAttributes->NFeatures + i] = 0;
218          }
<span onclick='openModal()' class='match'>219          Theta[k * GraphAttributes->NFeatures + t.GetUniDevInt(GraphAttributes->NFeatures)] = 1.0;
220          Theta[k * GraphAttributes->NFeatures] = 1;
221        }
222      }
</span>223      for (int k = 0; k < K; k++) {
224        CHat[k] = MCMC(k, MCMCReps);
225      }
226      TFlt llPrevious = LogLikelihood();
227      TFlt ll = 0;
228      for (int gradientRep = 0; gradientRep < GradientReps; gradientRep++) {
229        Gradient();
230        for (int i = 0; i < K * GraphAttributes->NFeatures; i++) {
231          Theta[i] += Increment * Derivative[i];
232        }
233        printf(".");
234        fflush( stdout);
235        ll = LogLikelihood();
236        if (ll < llPrevious) {
237          for (int i = 0; i < K * GraphAttributes->NFeatures; i++) {
238            Theta[i] -= Increment * Derivative[i];
239          }
240          ll = llPrevious;
241          break;
242        }
243        llPrevious = ll;
244      }
245      printf("\nIteration %d, ll = %f\n", OuterRep + 1, (double) ll);
246    }
247  }
248  TFlt Inner(TIntIntH& Feature, TFlt* Parameter) {
249    TFlt res = 0;
250    for (THashKeyDatI<TInt, TInt> it = Feature.BegI(); !it.IsEnd(); it++) {
251      res += it.GetDat() * Parameter[it.GetKey()];
252    }
253    return res;
254  }
255  TIntSet TCluster::MCMC(TInt k, TInt MCMCReps) {
256    TRnd t;
257    THash<TInt, TFlt> CostNotIncludeHash;
258    THash<TInt, TFlt> CostIncludeHash;
259    TVec<TInt> NewLabel;
260    int csize = 0;
261    for (int i = 0; i < GraphAttributes->NodeIDs.Len(); i++) {
262      if (CHat[k].IsKey(GraphAttributes->NodeIDs[i])) {
263        NewLabel.Add(0);
264      } else {
265        NewLabel.Add(1);
266      }
267      if (CHat[k].IsKey(GraphAttributes->NodeIDs[i])) {
268        csize++;
269      }
270    }
271    for (THashKeyDatI<TIntPr, TIntIntH> it = GraphAttributes->EdgeFeatures.BegI();
272         !it.IsEnd(); it++) {
273      TIntPr e = it.GetKey();
274      TInt kv = GraphAttributes->EdgeFeatures.GetKeyId(e);
275      TInt Src = e.Val1;
276      TInt Dst = e.Val2;
277      TBool Exists = GraphAttributes->G->IsEdge(Src, Dst);
278      TFlt InnerProduct = Inner(it.GetDat(), Theta + k * GraphAttributes->NFeatures);
279      TFlt Other = 0;
280      for (int l = 0; l < K; l++) {
281        if (l == k) {
282          continue;
283        }
284        TFlt d = (CHat[l].IsKey(Src) && CHat[l].IsKey(Dst)) ? 1 : -1;
285        Other += d * Inner(it.GetDat(), Theta + l * GraphAttributes->NFeatures);
286      }
287      TFlt CostNotInclude;
288      TFlt CostInclude;
289      if (Exists) {
290        CostNotInclude = -Other + InnerProduct + log(1 + exp(Other - InnerProduct));
291        CostInclude = -Other - InnerProduct + log(1 + exp(Other + InnerProduct));
292      } else {
293        CostNotInclude = log(1 + exp(Other - InnerProduct));
294        CostInclude = log(1 + exp(Other + InnerProduct));
295      }
296      CostNotIncludeHash.AddDat(kv) = -CostNotInclude;
297      CostIncludeHash.AddDat(kv) = -CostInclude;
298    }
299    TFlt InitialTemperature = 1.0; 
300    for (int r = 2; r < MCMCReps + 2; r++) {
301      TFlt Temperature = InitialTemperature / log((double) r);
302      for (int n = 0; n < GraphAttributes->NodeIDs.Len(); n++) {
303        TFlt l0 = 0;
304        TFlt l1 = 0;
305        for (int np = 0; np < GraphAttributes->NodeIDs.Len(); np++) {
306          if (n == np) {
307            continue;
308          }
309          TIntPr ed(GraphAttributes->NodeIDs[n], GraphAttributes->NodeIDs[np]);
310          if (ed.Val1 > ed.Val2) {
311            ed = TIntPr(ed.Val2, ed.Val1);
312          }
313          TInt kv = GraphAttributes->EdgeFeatures.GetKeyId(ed);
314          TFlt m0 = CostNotIncludeHash.GetDat(kv);
315          if (NewLabel[np] == 0) {
316            l0 += m0;
317            l1 += m0;
318          } else {
319            l0 += m0;
320            l1 += CostIncludeHash.GetDat(kv);
321          }
322        }
323        TFlt LogLikelihoodDiff = exp(l1 - l0);
324        TFlt AcceptProb = pow(LogLikelihoodDiff, 1.0 / Temperature);
325        if (t.GetUniDev() < AcceptProb) {
326          NewLabel[n] = 1;
327        } else {
328          NewLabel[n] = 0;
329        }
330      }
331    }
332    TIntSet Result;
333    for (int i = 0; i < GraphAttributes->NodeIDs.Len(); i++) {
334      if (NewLabel[i]) {
335        Result.AddKey(GraphAttributes->NodeIDs[i]);
336      }
337    }
338    return Result;
339  }
340  void TCluster::Gradient(void) {
341    for (int i = 0; i < K * GraphAttributes->NFeatures; i++) {
342      if (Theta[i] > 0) {
343        Derivative[i] = -Lambda * Theta[i];
344      } else {
345        Derivative[i] = Lambda * Theta[i];
346      }
347    }
348    for (THashKeyDatI<TIntPr, TIntIntH> it = GraphAttributes->EdgeFeatures.BegI();
349         !it.IsEnd(); it++) {
350      TFlt InnerProduct = 0;
351      TIntPr Edge = it.GetKey();
352      TInt Src = Edge.Val1;
353      TInt Dst = Edge.Val2;
354      TBool Exists = GraphAttributes->G->IsEdge(Src, Dst);
355      for (int k = 0; k < K; k++) {
356        TFlt d = CHat[k].IsKey(Src) && CHat[k].IsKey(Dst) ? 1 : -1;
357        InnerProduct += d * Inner(it.GetDat(), Theta + k * GraphAttributes->NFeatures);
358      }
359      TFlt expinp = exp(InnerProduct);
360      TFlt q = expinp / (1 + expinp);
361      if (q != q) {
362        q = 1; 
363      }
364      for (int k = 0; k < K; k++) {
365        TBool d_ = CHat[k].IsKey(Src) && CHat[k].IsKey(Dst);
366        TFlt d = d_ ? 1 : -1;
367        for (THashKeyDatI<TInt, TInt> itf = it.GetDat().BegI();
368             !itf.IsEnd(); itf++) {
369          TInt i = itf.GetKey();
370          TInt f = itf.GetDat();
371          if (Exists) {
372            Derivative[k * GraphAttributes->NFeatures + i] += d * f;
373          }
374          Derivative[k * GraphAttributes->NFeatures + i] += -d * f * q;
375        }
376      }
377    }
378  }
379  TFlt TCluster::LogLikelihood(void) {
380    TFlt ll = 0;
381    for (THashKeyDatI<TIntPr, TIntIntH> it = GraphAttributes->EdgeFeatures.BegI();
382         !it.IsEnd(); it++) {
383      TFlt InnerProduct = 0;
384      TIntPr Edge = it.GetKey();
385      TInt Src = Edge.Val1;
386      TInt Dst = Edge.Val2;
387      TBool Exists = GraphAttributes->G->IsEdge(Src, Dst);
388      for (int k = 0; k < K; k++) {
389        TFlt d = CHat[k].IsKey(Src) && CHat[k].IsKey(Dst) ? 1 : -1;
390        InnerProduct += d * Inner(it.GetDat(), Theta + k * GraphAttributes->NFeatures);
391      }
392      if (Exists) {
393        ll += InnerProduct;
394      }
395      TFlt ll_ = log(1 + exp(InnerProduct));
396      ll += -ll_;
397    }
398    if (ll != ll) {
399      printf("ll isnan\n");
400      exit(1);
401    }
402    return ll;
403  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-circles_128.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-circles.h</div>
                </div>
                <div class="column column_space"><pre><code>75          theta[k * gd->nFeatures + t.GetUniDevInt(gd->nFeatures)] = 1.0;
76          theta[k * gd->nFeatures] = 1;
77        }
78      for (int k = 0; k < K; k++)
</pre></code></div>
                <div class="column column_space"><pre><code>219          Theta[k * GraphAttributes->NFeatures + t.GetUniDevInt(GraphAttributes->NFeatures)] = 1.0;
220          Theta[k * GraphAttributes->NFeatures] = 1;
221        }
222      }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    