
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 3.2490974729241873%, Tokens: 9</h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-node2vec.cpp</h3>
            <pre><code>1  #include "stdafx.h"
2  #include "n2v.h"
3  #ifdef USE_OPENMP
4  #include <omp.h>
5  #endif
6  void ParseArgs(int& argc, char* argv[], TStr& InFile, TStr& OutFile,
7   int& Dimensions, int& WalkLen, int& NumWalks, int& WinSize, int& Iter,
8   bool& Verbose, double& ParamP, double& ParamQ, bool& Directed, bool& Weighted,
9   bool& OutputWalks) {
10    Env = TEnv(argc, argv, TNotify::StdNotify);
11    Env.PrepArgs(TStr::Fmt("\nAn algorithmic framework for representational learning on graphs."));
12    InFile = Env.GetIfArgPrefixStr("-i:", "graph/karate.edgelist",
13     "Input graph path");
14    OutFile = Env.GetIfArgPrefixStr("-o:", "emb/karate.emb",
15     "Output graph path");
16    Dimensions = Env.GetIfArgPrefixInt("-d:", 128,
17     "Number of dimensions. Default is 128");
18    WalkLen = Env.GetIfArgPrefixInt("-l:", 80,
19     "Length of walk per source. Default is 80");
20    NumWalks = Env.GetIfArgPrefixInt("-r:", 10,
21     "Number of walks per source. Default is 10");
22    WinSize = Env.GetIfArgPrefixInt("-k:", 10,
23     "Context size for optimization. Default is 10");
24    Iter = Env.GetIfArgPrefixInt("-e:", 1,
25     "Number of epochs in SGD. Default is 1");
26    ParamP = Env.GetIfArgPrefixFlt("-p:", 1,
27     "Return hyperparameter. Default is 1");
28    ParamQ = Env.GetIfArgPrefixFlt("-q:", 1,
29     "Inout hyperparameter. Default is 1");
30    Verbose = Env.IsArgStr("-v", "Verbose output.");
31    Directed = Env.IsArgStr("-dr", "Graph is directed.");
32    Weighted = Env.IsArgStr("-w", "Graph is weighted.");
33    OutputWalks = Env.IsArgStr("-ow", "Output random walks instead of embeddings.");
34  }
35  void ReadGraph(TStr& InFile, bool& Directed, bool& Weighted, bool& Verbose, PWNet& InNet) {
36    TFIn FIn(InFile);
37    int64 LineCnt = 0;
38    try {
39      while (!FIn.Eof()) {
40        TStr Ln;
41        FIn.GetNextLn(Ln);
42        TStr Line, Comment;
43        Ln.SplitOnCh(Line,'#',Comment);
44        TStrV Tokens;
45        Line.SplitOnWs(Tokens);
46        if(Tokens.Len()<2){ continue; }
47        int64 SrcNId = Tokens[0].GetInt();
<span onclick='openModal()' class='match'>48        int64 DstNId = Tokens[1].GetInt();
49        double Weight = 1.0;
50        if (Weighted) { Weight = Tokens[2].GetFlt(); }
51        if (!InNet->IsNode(SrcNId)){ InNet->AddNode(SrcNId); }
</span>52        if (!InNet->IsNode(DstNId)){ InNet->AddNode(DstNId); }
53        InNet->AddEdge(SrcNId,DstNId,Weight);
54        if (!Directed){ InNet->AddEdge(DstNId,SrcNId,Weight); }
55        LineCnt++;
56      }
57      if (Verbose) { printf("Read %lld lines from %s\n", (long long)LineCnt, InFile.CStr()); }
58    } catch (PExcept Except) {
59      if (Verbose) {
60        printf("Read %lld lines from %s, then %s\n", (long long)LineCnt, InFile.CStr(),
61         Except->GetStr().CStr());
62      }
63    }
64  }
65  void WriteOutput(TStr& OutFile, TIntFltVH& EmbeddingsHV, TVVec<TInt, int64>& WalksVV,
66   bool& OutputWalks) {
67    TFOut FOut(OutFile);
68    if (OutputWalks) {
69      for (int64 i = 0; i < WalksVV.GetXDim(); i++) {
70        for (int64 j = 0; j < WalksVV.GetYDim(); j++) {
71          FOut.PutInt(WalksVV(i,j));
72  	if(j+1==WalksVV.GetYDim()) {
73            FOut.PutLn();
74  	} else {
75            FOut.PutCh(' ');
76  	}
77        }
78      }
79      return;
80    }
81    bool First = 1;
82    for (int i = EmbeddingsHV.FFirstKeyId(); EmbeddingsHV.FNextKeyId(i);) {
83      if (First) {
84        FOut.PutInt(EmbeddingsHV.Len());
85        FOut.PutCh(' ');
86        FOut.PutInt(EmbeddingsHV[i].Len());
87        FOut.PutLn();
88        First = 0;
89      }
90      FOut.PutInt(EmbeddingsHV.GetKey(i));
91      for (int64 j = 0; j < EmbeddingsHV[i].Len(); j++) {
92        FOut.PutCh(' ');
93        FOut.PutFlt(EmbeddingsHV[i][j]);
94      }
95      FOut.PutLn();
96    }
97  }
98  int main(int argc, char* argv[]) {
99    TStr InFile,OutFile;
100    int Dimensions, WalkLen, NumWalks, WinSize, Iter;
101    double ParamP, ParamQ;
102    bool Directed, Weighted, Verbose, OutputWalks;
103    ParseArgs(argc, argv, InFile, OutFile, Dimensions, WalkLen, NumWalks, WinSize,
104     Iter, Verbose, ParamP, ParamQ, Directed, Weighted, OutputWalks);
105    PWNet InNet = PWNet::New();
106    TIntFltVH EmbeddingsHV;
107    TVVec <TInt, int64> WalksVV;
108    ReadGraph(InFile, Directed, Weighted, Verbose, InNet);
109    node2vec(InNet, ParamP, ParamQ, Dimensions, WalkLen, NumWalks, WinSize, Iter, 
110     Verbose, OutputWalks, WalksVV, EmbeddingsHV);
111    WriteOutput(OutFile, EmbeddingsHV, WalksVV, OutputWalks);
112    return 0;
113  }
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-errorcounter.cpp</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #  include "config_auto.h"
3  #endif
4  #include "errorcounter.h"
5  #include "fontinfo.h"
6  #include "sampleiterator.h"
7  #include "shapeclassifier.h"
8  #include "shapetable.h"
9  #include "trainingsample.h"
10  #include "trainingsampleset.h"
11  #include "unicity_table.h"
12  #include <algorithm>
13  #include <ctime>
14  namespace tesseract {
15  const double kRatingEpsilon = 1.0 / 32;
16  double ErrorCounter::ComputeErrorRate(ShapeClassifier *classifier, int report_level,
17                                        CountTypes boosting_mode, const FontInfoTable &fontinfo_table,
18                                        const std::vector<Image > &page_images, SampleIterator *it,
19                                        double *unichar_error, double *scaled_error,
20                                        std::string *fonts_report) {
21    const int fontsize = it->sample_set()->NumFonts();
22    ErrorCounter counter(classifier->GetUnicharset(), fontsize);
23    std::vector<UnicharRating> results;
24    clock_t start = clock();
25    unsigned total_samples = 0;
26    double unscaled_error = 0.0;
27    int error_samples = report_level > 3 ? report_level * report_level : 0;
28    for (it->Begin(); !it->AtEnd(); it->Next()) {
29      TrainingSample *mutable_sample = it->MutableSample();
30      int page_index = mutable_sample->page_num();
31      Image page_pix =
32          0 <= page_index && page_index < page_images.size() ? page_images[page_index] : nullptr;
33      classifier->UnicharClassifySample(*mutable_sample, page_pix, 0, INVALID_UNICHAR_ID, &results);
34      bool debug_it = false;
35      int correct_id = mutable_sample->class_id();
36      if (counter.unicharset_.has_special_codes() &&
37          (correct_id == UNICHAR_SPACE || correct_id == UNICHAR_JOINED ||
38           correct_id == UNICHAR_BROKEN)) {
39        debug_it = counter.AccumulateJunk(report_level > 3, results, mutable_sample);
40      } else {
41        debug_it = counter.AccumulateErrors(report_level > 3, boosting_mode, fontinfo_table, results,
42                                            mutable_sample);
43      }
44      if (debug_it && error_samples > 0) {
45        tprintf("Error on sample %d: %s Classifier debug output:\n", it->GlobalSampleIndex(),
46                it->sample_set()->SampleToString(*mutable_sample).c_str());
47  #ifndef GRAPHICS_DISABLED
48        classifier->DebugDisplay(*mutable_sample, page_pix, correct_id);
49  #endif
50        --error_samples;
51      }
52      ++total_samples;
53    }
54    const double total_time = 1.0 * (clock() - start) / CLOCKS_PER_SEC;
55    unscaled_error = counter.ReportErrors(report_level, boosting_mode, fontinfo_table, *it,
56                                          unichar_error, fonts_report);
57    if (scaled_error != nullptr) {
58      *scaled_error = counter.scaled_error_;
59    }
60    if (report_level > 1 && total_samples > 0) {
61      tprintf("Errors computed in %.2fs at %.1f μs/char\n", total_time,
62              1000000.0 * total_time / total_samples);
63    }
64    return unscaled_error;
65  }
66  void ErrorCounter::DebugNewErrors(ShapeClassifier *new_classifier, ShapeClassifier *old_classifier,
67                                    CountTypes boosting_mode, const FontInfoTable &fontinfo_table,
68                                    const std::vector<Image > &page_images, SampleIterator *it) {
69    int fontsize = it->sample_set()->NumFonts();
70    ErrorCounter old_counter(old_classifier->GetUnicharset(), fontsize);
71    ErrorCounter new_counter(new_classifier->GetUnicharset(), fontsize);
72    std::vector<UnicharRating> results;
73    int total_samples = 0;
74    int error_samples = 25;
75    int total_new_errors = 0;
76    for (it->Begin(); !it->AtEnd(); it->Next()) {
77      TrainingSample *mutable_sample = it->MutableSample();
78      int page_index = mutable_sample->page_num();
79      Image page_pix =
80          0 <= page_index && page_index < page_images.size() ? page_images[page_index] : nullptr;
81      old_classifier->UnicharClassifySample(*mutable_sample, page_pix, 0, INVALID_UNICHAR_ID,
82                                            &results);
83      int correct_id = mutable_sample->class_id();
84      if (correct_id != 0 && !old_counter.AccumulateErrors(true, boosting_mode, fontinfo_table,
85                                                           results, mutable_sample)) {
86        new_classifier->UnicharClassifySample(*mutable_sample, page_pix, 0, INVALID_UNICHAR_ID,
87                                              &results);
88        if (correct_id != 0 && new_counter.AccumulateErrors(true, boosting_mode, fontinfo_table,
89                                                            results, mutable_sample)) {
90          tprintf("New Error on sample %d: Classifier debug output:\n", it->GlobalSampleIndex());
91          ++total_new_errors;
92          new_classifier->UnicharClassifySample(*mutable_sample, page_pix, 1, correct_id, &results);
93          if (results.size() > 0 && error_samples > 0) {
94  #ifndef GRAPHICS_DISABLED
95            new_classifier->DebugDisplay(*mutable_sample, page_pix, correct_id);
96  #endif
97            --error_samples;
98          }
99        }
100      }
101      ++total_samples;
102    }
103    tprintf("Total new errors = %d\n", total_new_errors);
104  }
105  ErrorCounter::ErrorCounter(const UNICHARSET &unicharset, int fontsize)
106      : scaled_error_(0.0)
107      , rating_epsilon_(kRatingEpsilon)
108      , unichar_counts_(unicharset.size(), unicharset.size(), 0)
109      , ok_score_hist_(0, 101)
110      , bad_score_hist_(0, 101)
111      , unicharset_(unicharset) {
112    Counts empty_counts;
113    font_counts_.clear();
114    font_counts_.resize(fontsize, empty_counts);
115    multi_unichar_counts_.clear();
116    multi_unichar_counts_.resize(unicharset.size(), 0);
117  }
118  bool ErrorCounter::AccumulateErrors(bool debug, CountTypes boosting_mode,
119                                      const FontInfoTable &font_table,
120                                      const std::vector<UnicharRating> &results,
121                                      TrainingSample *sample) {
122    int num_results = results.size();
123    int answer_actual_rank = -1;
124    int font_id = sample->font_id();
125    int unichar_id = sample->class_id();
126    sample->set_is_error(false);
127    if (num_results == 0) {
128      sample->set_is_error(true);
129      ++font_counts_[font_id].n[CT_REJECT];
130    } else {
131      int epsilon_rank = 0;
132      int answer_epsilon_rank = -1;
133      int num_top_answers = 0;
134      double prev_rating = results[0].rating;
135      bool joined = false;
136      bool broken = false;
137      int res_index = 0;
138      while (res_index < num_results) {
139        if (results[res_index].rating < prev_rating - rating_epsilon_) {
140          ++epsilon_rank;
141          prev_rating = results[res_index].rating;
142        }
143        if (results[res_index].unichar_id == unichar_id && answer_epsilon_rank < 0) {
144          answer_epsilon_rank = epsilon_rank;
145          answer_actual_rank = res_index;
146        }
147        if (results[res_index].unichar_id == UNICHAR_JOINED && unicharset_.has_special_codes()) {
148          joined = true;
149        } else if (results[res_index].unichar_id == UNICHAR_BROKEN &&
150                   unicharset_.has_special_codes()) {
151          broken = true;
152        } else if (epsilon_rank == 0) {
153          ++num_top_answers;
154        }
155        ++res_index;
156      }
157      if (answer_actual_rank != 0) {
158        ++font_counts_[font_id].n[CT_UNICHAR_TOPTOP_ERR];
159        if (boosting_mode == CT_UNICHAR_TOPTOP_ERR) {
160          sample->set_is_error(true);
161        }
162      }
163      if (answer_epsilon_rank == 0) {
164        ++font_counts_[font_id].n[CT_UNICHAR_TOP_OK];
165        if (num_top_answers > 1) {
166          ++font_counts_[font_id].n[CT_OK_MULTI_UNICHAR];
167          ++multi_unichar_counts_[unichar_id];
168        }
169        if (font_table.SetContainsFontProperties(font_id, results[answer_actual_rank].fonts)) {
170          if (font_table.SetContainsMultipleFontProperties(results[answer_actual_rank].fonts)) {
171            ++font_counts_[font_id].n[CT_OK_MULTI_FONT];
172          }
173        } else {
174          ++font_counts_[font_id].n[CT_FONT_ATTR_ERR];
175        }
176      } else {
177        ++font_counts_[font_id].n[CT_UNICHAR_TOP1_ERR];
178        if (boosting_mode == CT_UNICHAR_TOP1_ERR) {
179          sample->set_is_error(true);
180        }
181        ++unichar_counts_(unichar_id, results[0].unichar_id);
182        if (answer_epsilon_rank < 0 || answer_epsilon_rank >= 2) {
183          ++font_counts_[font_id].n[CT_UNICHAR_TOP2_ERR];
184          if (boosting_mode == CT_UNICHAR_TOP2_ERR) {
185            sample->set_is_error(true);
186          }
187        }
188        if (answer_epsilon_rank < 0) {
189          ++font_counts_[font_id].n[CT_UNICHAR_TOPN_ERR];
190          if (boosting_mode == CT_UNICHAR_TOPN_ERR) {
191            sample->set_is_error(true);
192          }
193          answer_epsilon_rank = epsilon_rank;
194        }
195      }
196      font_counts_[font_id].n[CT_NUM_RESULTS] += num_results;
197      font_counts_[font_id].n[CT_RANK] += answer_epsilon_rank;
198      if (joined) {
199        ++font_counts_[font_id].n[CT_OK_JOINED];
200      }
201      if (broken) {
202        ++font_counts_[font_id].n[CT_OK_BROKEN];
203      }
204    }
205    if (sample->is_error()) {
206      scaled_error_ += sample->weight();
207      if (debug) {
208        tprintf("%d results for char %s font %d :", num_results,
209                unicharset_.id_to_unichar(unichar_id), font_id);
210        for (int i = 0; i < num_results; ++i) {
211          tprintf(" %.3f : %s\n", results[i].rating,
212                  unicharset_.id_to_unichar(results[i].unichar_id));
213        }
214        return true;
215      }
216      int percent = 0;
217      if (num_results > 0) {
218        percent = IntCastRounded(results[0].rating * 100);
219      }
220      bad_score_hist_.add(percent, 1);
221    } else {
222      int percent = 0;
223      if (answer_actual_rank >= 0) {
224        percent = IntCastRounded(results[answer_actual_rank].rating * 100);
225      }
226      ok_score_hist_.add(percent, 1);
227    }
228    return false;
229  }
230  bool ErrorCounter::AccumulateJunk(bool debug, const std::vector<UnicharRating> &results,
231                                    TrainingSample *sample) {
232    const int num_results = results.size();
233    const int font_id = sample->font_id();
<span onclick='openModal()' class='match'>234    const int unichar_id = sample->class_id();
235    int percent = 0;
236    if (num_results > 0) {
237      percent = IntCastRounded(results[0].rating * 100);
238    }
239    if (num_results > 0 && results[0].unichar_id != unichar_id) {
</span>240      ++font_counts_[font_id].n[CT_ACCEPTED_JUNK];
241      sample->set_is_error(true);
242      scaled_error_ += sample->weight();
243      bad_score_hist_.add(percent, 1);
244      return debug;
245    } else {
246      ++font_counts_[font_id].n[CT_REJECTED_JUNK];
247      sample->set_is_error(false);
248      ok_score_hist_.add(percent, 1);
249    }
250    return false;
251  }
252  double ErrorCounter::ReportErrors(int report_level, CountTypes boosting_mode,
253                                    const FontInfoTable &fontinfo_table, const SampleIterator &it,
254                                    double *unichar_error, std::string *fonts_report) {
255    Counts totals;
256    int fontsize = font_counts_.size();
257    for (int f = 0; f < fontsize; ++f) {
258      totals += font_counts_[f];
259      std::string font_report;
260      if (ReportString(false, font_counts_[f], font_report)) {
261        if (fonts_report != nullptr) {
262          *fonts_report += fontinfo_table.at(f).name;
263          *fonts_report += ": ";
264          *fonts_report += font_report;
265          *fonts_report += "\n";
266        }
267        if (report_level > 2) {
268          tprintf("%s: %s\n", fontinfo_table.at(f).name, font_report.c_str());
269        }
270      }
271    }
272    std::string total_report;
273    bool any_results = ReportString(true, totals, total_report);
274    if (fonts_report != nullptr && fonts_report->empty()) {
275      *fonts_report = "NoSamplesFound: ";
276      *fonts_report += total_report;
277      *fonts_report += "\n";
278    }
279    if (report_level > 0) {
280      std::string total_report;
281      if (any_results) {
282        tprintf("TOTAL Scaled Err=%.4g%%, %s\n", scaled_error_ * 100.0, total_report.c_str());
283      }
284      if (totals.n[CT_UNICHAR_TOP1_ERR] > 0) {
285        int charsetsize = unicharset_.size();
286        int worst_uni_id = 0;
287        int worst_result_id = 0;
288        int worst_err = 0;
289        for (int u = 0; u < charsetsize; ++u) {
290          for (int v = 0; v < charsetsize; ++v) {
291            if (unichar_counts_(u, v) > worst_err) {
292              worst_err = unichar_counts_(u, v);
293              worst_uni_id = u;
294              worst_result_id = v;
295            }
296          }
297        }
298        if (worst_err > 0) {
299          tprintf("Worst error = %d:%s -> %s with %d/%d=%.2f%% errors\n", worst_uni_id,
300                  unicharset_.id_to_unichar(worst_uni_id), unicharset_.id_to_unichar(worst_result_id),
301                  worst_err, totals.n[CT_UNICHAR_TOP1_ERR],
302                  100.0 * worst_err / totals.n[CT_UNICHAR_TOP1_ERR]);
303        }
304      }
305      tprintf("Multi-unichar shape use:\n");
306      for (int u = 0; u < multi_unichar_counts_.size(); ++u) {
307        if (multi_unichar_counts_[u] > 0) {
308          tprintf("%d multiple answers for unichar: %s\n", multi_unichar_counts_[u],
309                  unicharset_.id_to_unichar(u));
310        }
311      }
312      tprintf("OK Score histogram:\n");
313      ok_score_hist_.print();
314      tprintf("ERROR Score histogram:\n");
315      bad_score_hist_.print();
316    }
317    double rates[CT_SIZE];
318    if (!ComputeRates(totals, rates)) {
319      return 0.0;
320    }
321    if (unichar_error != nullptr) {
322      *unichar_error = rates[CT_UNICHAR_TOP1_ERR];
323    }
324    return rates[boosting_mode];
325  }
326  bool ErrorCounter::ReportString(bool even_if_empty, const Counts &counts, std::string &report) {
327    double rates[CT_SIZE];
328    if (!ComputeRates(counts, rates) && !even_if_empty) {
329      return false;
330    }
331    const int kMaxExtraLength = 5; 
332    const char format_str[] =
333        "Unichar=%.4g%%[1], %.4g%%[2], %.4g%%[n], %.4g%%[T] "
334        "Mult=%.4g%%, Jn=%.4g%%, Brk=%.4g%%, Rej=%.4g%%, "
335        "FontAttr=%.4g%%, Multi=%.4g%%, "
336        "Answers=%.3g, Rank=%.3g, "
337        "OKjunk=%.4g%%, Badjunk=%.4g%%";
338    constexpr size_t max_str_len = sizeof(format_str) + kMaxExtraLength * (CT_SIZE - 1) + 1;
339    char formatted_str[max_str_len];
340    snprintf(formatted_str, max_str_len, format_str, rates[CT_UNICHAR_TOP1_ERR] * 100.0,
341             rates[CT_UNICHAR_TOP2_ERR] * 100.0, rates[CT_UNICHAR_TOPN_ERR] * 100.0,
342             rates[CT_UNICHAR_TOPTOP_ERR] * 100.0, rates[CT_OK_MULTI_UNICHAR] * 100.0,
343             rates[CT_OK_JOINED] * 100.0, rates[CT_OK_BROKEN] * 100.0, rates[CT_REJECT] * 100.0,
344             rates[CT_FONT_ATTR_ERR] * 100.0, rates[CT_OK_MULTI_FONT] * 100.0, rates[CT_NUM_RESULTS],
345             rates[CT_RANK], 100.0 * rates[CT_REJECTED_JUNK], 100.0 * rates[CT_ACCEPTED_JUNK]);
346    report = formatted_str;
347    for (int ct : counts.n) {
348      report += "\t" + std::to_string(ct);
349    }
350    return true;
351  }
352  bool ErrorCounter::ComputeRates(const Counts &counts, double rates[CT_SIZE]) {
353    const int ok_samples =
354        counts.n[CT_UNICHAR_TOP_OK] + counts.n[CT_UNICHAR_TOP1_ERR] + counts.n[CT_REJECT];
355    const int junk_samples = counts.n[CT_REJECTED_JUNK] + counts.n[CT_ACCEPTED_JUNK];
356    double denominator = static_cast<double>(std::max(ok_samples, 1));
357    for (int ct = 0; ct <= CT_RANK; ++ct) {
358      rates[ct] = counts.n[ct] / denominator;
359    }
360    denominator = static_cast<double>(std::max(junk_samples, 1));
361    for (int ct = CT_REJECTED_JUNK; ct <= CT_ACCEPTED_JUNK; ++ct) {
362      rates[ct] = counts.n[ct] / denominator;
363    }
364    return ok_samples != 0 || junk_samples != 0;
365  }
366  ErrorCounter::Counts::Counts() {
367    memset(n, 0, sizeof(n[0]) * CT_SIZE);
368  }
369  void ErrorCounter::Counts::operator+=(const Counts &other) {
370    for (int ct = 0; ct < CT_SIZE; ++ct) {
371      n[ct] += other.n[ct];
372    }
373  }
374  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-node2vec.cpp</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-errorcounter.cpp</div>
                <div class="column column_space"><pre><code>48        int64 DstNId = Tokens[1].GetInt();
49        double Weight = 1.0;
50        if (Weighted) { Weight = Tokens[2].GetFlt(); }
51        if (!InNet->IsNode(SrcNId)){ InNet->AddNode(SrcNId); }
</pre></code></div>
                <div class="column column_space"><pre><code>234    const int unichar_id = sample->class_id();
235    int percent = 0;
236    if (num_results > 0) {
237      percent = IntCastRounded(results[0].rating * 100);
238    }
239    if (num_results > 0 && results[0].unichar_id != unichar_id) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    