
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 2.5380710659898478%, Tokens: 10</h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-tprintf.cpp</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #  include "config_auto.h"
3  #endif
4  #include "tprintf.h"
5  #include "params.h"
6  #include <climits> 
7  #include <cstdarg>
8  #include <cstdio>
9  namespace tesseract {
10  #define MAX_MSG_LEN 2048
11  INT_VAR(log_level, INT_MAX, "Logging level");
12  static STRING_VAR(debug_file, "", "File to send tprintf output to");
13  void tprintf(const char *format, ...) {
14    const char *debug_file_name = debug_file.c_str();
15    static FILE *debugfp = nullptr; 
<span onclick='openModal()' class='match'>16    if (debug_file_name == nullptr) {
17      return;
18    }
19  #ifdef _WIN32
20    if (strcmp(debug_file_name, "/dev/null") == 0) {
21      debug_file_name = "nul";
22      debug_file.set_value(debug_file_name);
23    }
24  #endif
25    if (debugfp == nullptr && debug_file_name[0] != '\0') {
</span>26      debugfp = fopen(debug_file_name, "wb");
27    } else if (debugfp != nullptr && debug_file_name[0] == '\0') {
28      fclose(debugfp);
29      debugfp = nullptr;
30    }
31    va_list args;           
32    va_start(args, format); 
33    if (debugfp != nullptr) {
34      vfprintf(debugfp, format, args);
35    } else {
36      vfprintf(stderr, format, args);
37    }
38    va_end(args);
39  }
40  } 
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-baselinedetect.cpp</h3>
            <pre><code>1  #define _USE_MATH_DEFINES 
2  #ifdef HAVE_CONFIG_H
3  #  include "config_auto.h"
4  #endif
5  #include "baselinedetect.h"
6  #include <allheaders.h>
7  #include <algorithm>
8  #include <cfloat> 
9  #include <cmath>  
10  #include "blobbox.h"
11  #include "detlinefit.h"
12  #include "drawtord.h"
13  #include "helpers.h"
14  #include "linlsq.h"
15  #include "makerow.h"
16  #include "textord.h"
17  #include "tprintf.h"
18  #include "underlin.h"
19  const int kMaxDisplacementsModes = 3;
20  const int kNumSkipPoints = 3;
21  const double kMaxSkewDeviation = 1.0 / 64;
22  const double kOffsetQuantizationFactor = 3.0 / 64;
23  const double kFitHalfrangeFactor = 6.0 / 64;
24  const double kMaxBaselineError = 3.0 / 64;
25  const double kMaxBlobSizeMultiple = 1.3;
26  const double kMinFittingLinespacings = 0.25;
27  namespace tesseract {
28  BaselineRow::BaselineRow(double line_spacing, TO_ROW *to_row)
29      : blobs_(to_row->blob_list()),
30        baseline_pt1_(0.0f, 0.0f),
31        baseline_pt2_(0.0f, 0.0f),
32        baseline_error_(0.0),
33        good_baseline_(false) {
34    ComputeBoundingBox();
35    disp_quant_factor_ = kOffsetQuantizationFactor * line_spacing;
36    fit_halfrange_ = kFitHalfrangeFactor * line_spacing;
37    max_baseline_error_ = kMaxBaselineError * line_spacing;
38  }
39  void BaselineRow::SetupOldLineParameters(TO_ROW *row) const {
40    double gradient = tan(BaselineAngle());
41    float para_c = StraightYAtX(0.0);
42    row->set_line(gradient, para_c, baseline_error_);
43    row->set_parallel_line(gradient, para_c, baseline_error_);
44  }
45  void BaselineRow::Print() const {
46    tprintf("Baseline (%g,%g)->(%g,%g), angle=%g, intercept=%g\n",
47            baseline_pt1_.x(), baseline_pt1_.y(), baseline_pt2_.x(),
48            baseline_pt2_.y(), BaselineAngle(), StraightYAtX(0.0));
49    tprintf("Quant factor=%g, error=%g, good=%d, box:", disp_quant_factor_,
50            baseline_error_, good_baseline_);
51    bounding_box_.print();
52  }
53  double BaselineRow::BaselineAngle() const {
54    FCOORD baseline_dir(baseline_pt2_ - baseline_pt1_);
55    double angle = baseline_dir.angle();
56    return fmod(angle + M_PI * 1.5, M_PI) - M_PI * 0.5;
57  }
58  double BaselineRow::SpaceBetween(const BaselineRow &other) const {
59    float x = (std::max(bounding_box_.left(), other.bounding_box_.left()) +
60               std::min(bounding_box_.right(), other.bounding_box_.right())) /
61              2.0f;
62    float y = (StraightYAtX(x) + other.StraightYAtX(x)) / 2.0f;
63    FCOORD pt(x, y);
64    return PerpDistanceFromBaseline(pt) + other.PerpDistanceFromBaseline(pt);
65  }
66  double BaselineRow::PerpDisp(const FCOORD &direction) const {
67    float middle_x = (bounding_box_.left() + bounding_box_.right()) / 2.0f;
68    FCOORD middle_pos(middle_x, StraightYAtX(middle_x));
69    return direction * middle_pos / direction.length();
70  }
71  double BaselineRow::StraightYAtX(double x) const {
72    double denominator = baseline_pt2_.x() - baseline_pt1_.x();
73    if (denominator == 0.0) {
74      return (baseline_pt1_.y() + baseline_pt2_.y()) / 2.0;
75    }
76    return baseline_pt1_.y() + (x - baseline_pt1_.x()) *
77                                   (baseline_pt2_.y() - baseline_pt1_.y()) /
78                                   denominator;
79  }
80  bool BaselineRow::FitBaseline(bool use_box_bottoms) {
81    fitter_.Clear();
82    LLSQ llsq;
83    BLOBNBOX_IT blob_it(blobs_);
84    for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
85      BLOBNBOX *blob = blob_it.data();
86      if (!use_box_bottoms) {
87        blob->EstimateBaselinePosition();
88      }
89      const TBOX &box = blob->bounding_box();
90      int x_middle = (box.left() + box.right()) / 2;
91  #ifdef kDebugYCoord
92      if (box.bottom() < kDebugYCoord && box.top() > kDebugYCoord) {
93        tprintf("Box bottom = %d, baseline pos=%d for box at:", box.bottom(),
94                blob->baseline_position());
95        box.print();
96      }
97  #endif
98      fitter_.Add(ICOORD(x_middle, blob->baseline_position()), box.width() / 2);
99      llsq.add(x_middle, blob->baseline_position());
100    }
101    ICOORD pt1, pt2;
102    baseline_error_ = fitter_.Fit(&pt1, &pt2);
103    baseline_pt1_ = pt1;
104    baseline_pt2_ = pt2;
105    if (baseline_error_ > max_baseline_error_ &&
106        fitter_.SufficientPointsForIndependentFit()) {
107      double error = fitter_.Fit(kNumSkipPoints, kNumSkipPoints, &pt1, &pt2);
108      if (error < baseline_error_ / 2.0) {
109        baseline_error_ = error;
110        baseline_pt1_ = pt1;
111        baseline_pt2_ = pt2;
112      }
113    }
114    int debug = 0;
115  #ifdef kDebugYCoord
116    Print();
117    debug = bounding_box_.bottom() < kDebugYCoord &&
118                    bounding_box_.top() > kDebugYCoord
119                ? 3
120                : 2;
121  #endif
122    FCOORD direction(pt2 - pt1);
123    double target_offset = direction * pt1;
124    good_baseline_ = false;
125    FitConstrainedIfBetter(debug, direction, 0.0, target_offset);
126    double angle = BaselineAngle();
127    if (fabs(angle) > M_PI * 0.25) {
128      baseline_pt1_ = llsq.mean_point();
129      baseline_pt2_ = baseline_pt1_ + FCOORD(1.0f, llsq.m());
130      double m = llsq.m();
131      double c = llsq.c(m);
132      baseline_error_ = llsq.rms(m, c);
133      good_baseline_ = false;
134    }
135    return good_baseline_;
136  }
137  void BaselineRow::AdjustBaselineToParallel(int debug, const FCOORD &direction) {
138    SetupBlobDisplacements(direction);
139    if (displacement_modes_.empty()) {
140      return;
141    }
142  #ifdef kDebugYCoord
143    if (bounding_box_.bottom() < kDebugYCoord &&
144        bounding_box_.top() > kDebugYCoord && debug < 3)
145      debug = 3;
146  #endif
147    FitConstrainedIfBetter(debug, direction, 0.0, displacement_modes_[0]);
148  }
149  double BaselineRow::AdjustBaselineToGrid(int debug, const FCOORD &direction,
150                                           double line_spacing,
151                                           double line_offset) {
152    if (blobs_->empty()) {
153      if (debug > 1) {
154        tprintf("Row empty at:");
155        bounding_box_.print();
156      }
157      return line_offset;
158    }
159    double best_error = 0.0;
160    int best_index = -1;
161    for (unsigned i = 0; i < displacement_modes_.size(); ++i) {
162      double blob_y = displacement_modes_[i];
163      double error =
164          BaselineBlock::SpacingModelError(blob_y, line_spacing, line_offset);
165      if (debug > 1) {
166        tprintf("Mode at %g has error %g from model \n", blob_y, error);
167      }
168      if (best_index < 0 || error < best_error) {
169        best_error = error;
170        best_index = i;
171      }
172    }
173    double model_margin = max_baseline_error_ - best_error;
174    if (best_index >= 0 && model_margin > 0.0) {
175      double perp_disp = PerpDisp(direction);
176      double shift = displacement_modes_[best_index] - perp_disp;
177      if (fabs(shift) > max_baseline_error_) {
178        if (debug > 1) {
179          tprintf("Attempting linespacing model fit with mode %g to row at:",
180                  displacement_modes_[best_index]);
181          bounding_box_.print();
182        }
183        FitConstrainedIfBetter(debug, direction, model_margin,
184                               displacement_modes_[best_index]);
185      } else if (debug > 1) {
186        tprintf("Linespacing model only moves current line by %g for row at:",
187                shift);
188        bounding_box_.print();
189      }
190    } else if (debug > 1) {
191      tprintf("Linespacing model not close enough to any mode for row at:");
192      bounding_box_.print();
193    }
194    return fmod(PerpDisp(direction), line_spacing);
195  }
196  void BaselineRow::SetupBlobDisplacements(const FCOORD &direction) {
197    std::vector<double> perp_blob_dists;
198    displacement_modes_.clear();
199    double min_dist = FLT_MAX;
200    double max_dist = -FLT_MAX;
201    BLOBNBOX_IT blob_it(blobs_);
202  #ifdef kDebugYCoord
203    bool debug = false;
204  #endif
205    for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
206      BLOBNBOX *blob = blob_it.data();
207      const TBOX &box = blob->bounding_box();
208  #ifdef kDebugYCoord
209      if (box.bottom() < kDebugYCoord && box.top() > kDebugYCoord)
210        debug = true;
211  #endif
212      FCOORD blob_pos((box.left() + box.right()) / 2.0f,
213                      blob->baseline_position());
214      double offset = direction * blob_pos;
215      perp_blob_dists.push_back(offset);
216  #ifdef kDebugYCoord
217      if (debug) {
218        tprintf("Displacement %g for blob at:", offset);
219        box.print();
220      }
221  #endif
222      UpdateRange(offset, &min_dist, &max_dist);
223    }
224    STATS dist_stats(IntCastRounded(min_dist / disp_quant_factor_),
225                     IntCastRounded(max_dist / disp_quant_factor_));
226    for (double perp_blob_dist : perp_blob_dists) {
227      dist_stats.add(IntCastRounded(perp_blob_dist / disp_quant_factor_), 1);
228    }
229    std::vector<KDPairInc<float, int>> scaled_modes;
230    dist_stats.top_n_modes(kMaxDisplacementsModes, scaled_modes);
231  #ifdef kDebugYCoord
232    if (debug) {
233      for (int i = 0; i < scaled_modes.size(); ++i) {
234        tprintf("Top mode = %g * %d\n", scaled_modes[i].key * disp_quant_factor_,
235                scaled_modes[i].data());
236      }
237    }
238  #endif
239    for (auto &scaled_mode : scaled_modes) {
240      displacement_modes_.push_back(disp_quant_factor_ * scaled_mode.key());
241    }
242  }
243  void BaselineRow::FitConstrainedIfBetter(int debug, const FCOORD &direction,
244                                           double cheat_allowance,
245                                           double target_offset) {
246    double halfrange = fit_halfrange_ * direction.length();
247    double min_dist = target_offset - halfrange;
248    double max_dist = target_offset + halfrange;
249    ICOORD line_pt;
250    double new_error = fitter_.ConstrainedFit(direction, min_dist, max_dist,
251                                              debug > 2, &line_pt);
252    new_error -= cheat_allowance;
253    double old_angle = BaselineAngle();
254    double new_angle = direction.angle();
255    if (debug > 1) {
256      tprintf("Constrained error = %g, original = %g", new_error,
257              baseline_error_);
258      tprintf(" angles = %g, %g, delta=%g vs threshold %g\n", old_angle,
259              new_angle, new_angle - old_angle, kMaxSkewDeviation);
260    }
261    bool new_good_baseline =
262        new_error <= max_baseline_error_ &&
263        (cheat_allowance > 0.0 || fitter_.SufficientPointsForIndependentFit());
264    if (new_error <= baseline_error_ || (!good_baseline_ && new_good_baseline) ||
265        fabs(new_angle - old_angle) > kMaxSkewDeviation) {
266      baseline_error_ = new_error;
267      baseline_pt1_ = line_pt;
268      baseline_pt2_ = baseline_pt1_ + direction;
269      good_baseline_ = new_good_baseline;
270      if (debug > 1) {
271        tprintf("Replacing with constrained baseline, good = %d\n",
272                good_baseline_);
273      }
274    } else if (debug > 1) {
275      tprintf("Keeping old baseline\n");
276    }
277  }
278  float BaselineRow::PerpDistanceFromBaseline(const FCOORD &pt) const {
279    FCOORD baseline_vector(baseline_pt2_ - baseline_pt1_);
280    FCOORD offset_vector(pt - baseline_pt1_);
281    float distance = baseline_vector * offset_vector;
282    float sqlength = baseline_vector.sqlength();
283    if (sqlength == 0.0f) {
284      tprintf("unexpected baseline vector (0,0)\n");
285      return 0.0f;
286    }
287    return std::sqrt(distance * distance / sqlength);
288  }
289  void BaselineRow::ComputeBoundingBox() {
290    BLOBNBOX_IT it(blobs_);
291    TBOX box;
292    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
293      box += it.data()->bounding_box();
294    }
295    bounding_box_ = box;
296  }
297  BaselineBlock::BaselineBlock(int debug_level, bool non_text, TO_BLOCK *block)
298      : block_(block),
299        debug_level_(debug_level),
300        non_text_block_(non_text),
301        good_skew_angle_(false),
302        skew_angle_(0.0),
303        line_spacing_(block->line_spacing),
304        line_offset_(0.0),
305        model_error_(0.0) {
306    TO_ROW_IT row_it(block_->get_rows());
307    for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
308      row_it.data()->blob_list()->sort(blob_x_order);
309      rows_.push_back(new BaselineRow(block->line_spacing, row_it.data()));
310    }
311  }
312  double BaselineBlock::SpacingModelError(double perp_disp, double line_spacing,
313                                          double line_offset) {
314    int multiple = IntCastRounded((perp_disp - line_offset) / line_spacing);
315    double model_y = line_spacing * multiple + line_offset;
316    return fabs(perp_disp - model_y);
317  }
318  bool BaselineBlock::FitBaselinesAndFindSkew(bool use_box_bottoms) {
319    if (non_text_block_) {
320      return false;
321    }
322    std::vector<double> angles;
323    for (auto row : rows_) {
324      if (row->FitBaseline(use_box_bottoms)) {
325        double angle = row->BaselineAngle();
326        angles.push_back(angle);
327      }
328      if (debug_level_ > 1) {
329        row->Print();
330      }
331    }
332    if (!angles.empty()) {
333      skew_angle_ = MedianOfCircularValues(M_PI, angles);
334      good_skew_angle_ = true;
335    } else {
336      skew_angle_ = 0.0f;
337      good_skew_angle_ = false;
338    }
339    if (debug_level_ > 0) {
340      tprintf("Initial block skew angle = %g, good = %d\n", skew_angle_,
341              good_skew_angle_);
342    }
343    return good_skew_angle_;
344  }
345  void BaselineBlock::ParallelizeBaselines(double default_block_skew) {
<span onclick='openModal()' class='match'>346    if (non_text_block_) {
347      return;
348    }
349    if (!good_skew_angle_) {
350      skew_angle_ = default_block_skew;
351    }
352    if (debug_level_ > 0) {
</span>353      tprintf("Adjusting block to skew angle %g\n", skew_angle_);
354    }
355    FCOORD direction(cos(skew_angle_), sin(skew_angle_));
356    for (auto row : rows_) {
357      row->AdjustBaselineToParallel(debug_level_, direction);
358      if (debug_level_ > 1) {
359        row->Print();
360      }
361    }
362    if (rows_.size() < 3 || !ComputeLineSpacing()) {
363      return;
364    }
365    unsigned best_row = 0;
366    double best_error = SpacingModelError(rows_[0]->PerpDisp(direction),
367                                          line_spacing_, line_offset_);
368    for (unsigned r = 1; r < rows_.size(); ++r) {
369      double error = SpacingModelError(rows_[r]->PerpDisp(direction),
370                                       line_spacing_, line_offset_);
371      if (error < best_error) {
372        best_error = error;
373        best_row = r;
374      }
375    }
376    double offset = line_offset_;
377    for (auto r = best_row + 1; r < rows_.size(); ++r) {
378      offset = rows_[r]->AdjustBaselineToGrid(debug_level_, direction,
379                                              line_spacing_, offset);
380    }
381    offset = line_offset_;
382    for (int r = best_row - 1; r >= 0; --r) {
383      offset = rows_[r]->AdjustBaselineToGrid(debug_level_, direction,
384                                              line_spacing_, offset);
385    }
386  }
387  void BaselineBlock::SetupBlockParameters() const {
388    if (line_spacing_ > 0.0) {
389      float min_spacing =
390          std::min(block_->line_spacing, static_cast<float>(line_spacing_));
391      if (min_spacing < block_->line_size) {
392        block_->line_size = min_spacing;
393      }
394      block_->line_spacing = line_spacing_;
395      block_->baseline_offset = line_offset_;
396      block_->max_blob_size = line_spacing_ * kMaxBlobSizeMultiple;
397    }
398    TO_ROW_IT row_it(block_->get_rows());
399    for (unsigned r = 0; r < rows_.size(); ++r, row_it.forward()) {
400      BaselineRow *row = rows_[r];
401      TO_ROW *to_row = row_it.data();
402      row->SetupOldLineParameters(to_row);
403    }
404  }
405  void BaselineBlock::PrepareForSplineFitting(ICOORD page_tr, bool remove_noise) {
406    if (non_text_block_) {
407      return;
408    }
409    if (remove_noise) {
410      vigorous_noise_removal(block_);
411    }
412    FCOORD rotation(1.0f, 0.0f);
413    double gradient = tan(skew_angle_);
414    separate_underlines(block_, gradient, rotation, true);
415    pre_associate_blobs(page_tr, block_, rotation, true);
416  }
417  void BaselineBlock::FitBaselineSplines(bool enable_splines,
418                                         bool show_final_rows, Textord *textord) {
419    double gradient = tan(skew_angle_);
420    FCOORD rotation(1.0f, 0.0f);
421    if (enable_splines) {
422      textord->make_spline_rows(block_, gradient, show_final_rows);
423    } else {
424      TBOX block_box = block_->block->pdblk.bounding_box();
425      TO_ROW_IT row_it = block_->get_rows();
426      for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
427        TO_ROW *row = row_it.data();
428        int32_t xstarts[2] = {block_box.left(), block_box.right()};
429        double coeffs[3] = {0.0, row->line_m(), row->line_c()};
430        row->baseline = QSPLINE(1, xstarts, coeffs);
431        textord->compute_row_xheight(row, block_->block->classify_rotation(),
432                                     row->line_m(), block_->line_size);
433      }
434    }
435    textord->compute_block_xheight(block_, gradient);
436    block_->block->set_xheight(block_->xheight);
437    if (textord_restore_underlines) { 
438      restore_underlined_blobs(block_);
439    }
440  }
441  #ifndef GRAPHICS_DISABLED
442  void BaselineBlock::DrawFinalRows(const ICOORD &page_tr) {
443    if (non_text_block_) {
444      return;
445    }
446    double gradient = tan(skew_angle_);
447    FCOORD rotation(1.0f, 0.0f);
448    int left_edge = block_->block->pdblk.bounding_box().left();
449    ScrollView *win = create_to_win(page_tr);
450    ScrollView::Color colour = ScrollView::RED;
451    TO_ROW_IT row_it = block_->get_rows();
452    for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
453      plot_parallel_row(row_it.data(), gradient, left_edge, colour, rotation);
454      colour = static_cast<ScrollView::Color>(colour + 1);
455      if (colour > ScrollView::MAGENTA) {
456        colour = ScrollView::RED;
457      }
458    }
459    plot_blob_list(win, &block_->blobs, ScrollView::MAGENTA, ScrollView::WHITE);
460    plot_blob_list(win, &block_->underlines, ScrollView::YELLOW,
461                   ScrollView::CORAL);
462    if (block_->blobs.length() > 0) {
463      tprintf("%d blobs discarded as noise\n", block_->blobs.length());
464    }
465    draw_meanlines(block_, gradient, left_edge, ScrollView::WHITE, rotation);
466  }
467  #endif 
468  void BaselineBlock::DrawPixSpline(Image pix_in) {
469    if (non_text_block_) {
470      return;
471    }
472    TO_ROW_IT row_it = block_->get_rows();
473    for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
474      row_it.data()->baseline.plot(pix_in);
475    }
476  }
477  bool BaselineBlock::ComputeLineSpacing() {
478    FCOORD direction(cos(skew_angle_), sin(skew_angle_));
479    std::vector<double> row_positions;
480    ComputeBaselinePositions(direction, &row_positions);
481    if (row_positions.size() < 2) {
482      return false;
483    }
484    EstimateLineSpacing();
485    RefineLineSpacing(row_positions);
486    double max_baseline_error = kMaxBaselineError * line_spacing_;
487    int non_trivial_gaps = 0;
488    int fitting_gaps = 0;
489    for (unsigned i = 1; i < row_positions.size(); ++i) {
490      double row_gap = fabs(row_positions[i - 1] - row_positions[i]);
491      if (row_gap > max_baseline_error) {
492        ++non_trivial_gaps;
493        if (fabs(row_gap - line_spacing_) <= max_baseline_error) {
494          ++fitting_gaps;
495        }
496      }
497    }
498    if (debug_level_ > 0) {
499      tprintf("Spacing %g, in %zu rows, %d gaps fitted out of %d non-trivial\n",
500              line_spacing_, row_positions.size(), fitting_gaps,
501              non_trivial_gaps);
502    }
503    return fitting_gaps > non_trivial_gaps * kMinFittingLinespacings;
504  }
505  void BaselineBlock::ComputeBaselinePositions(const FCOORD &direction,
506                                               std::vector<double> *positions) {
507    positions->clear();
508    for (auto row : rows_) {
509      const TBOX &row_box = row->bounding_box();
510      float x_middle = (row_box.left() + row_box.right()) / 2.0f;
511      FCOORD row_pos(x_middle, static_cast<float>(row->StraightYAtX(x_middle)));
512      float offset = direction * row_pos;
513      positions->push_back(offset);
514    }
515  }
516  void BaselineBlock::EstimateLineSpacing() {
517    std::vector<float> spacings;
518    for (unsigned r = 0; r < rows_.size(); ++r) {
519      BaselineRow *row = rows_[r];
520      if (fabs(row->BaselineAngle()) > M_PI * 0.25) {
521        continue;
522      }
523      const TBOX &row_box = row->bounding_box();
524      unsigned r2;
525      for (r2 = r + 1; r2 < rows_.size() &&
526                       !row_box.major_x_overlap(rows_[r2]->bounding_box());
527           ++r2) {
528        ;
529      }
530      if (r2 < rows_.size()) {
531        BaselineRow *row2 = rows_[r2];
532        if (fabs(row2->BaselineAngle()) > M_PI * 0.25) {
533          continue;
534        }
535        float spacing = row->SpaceBetween(*row2);
536        spacings.push_back(spacing);
537      }
538    }
539    if (!spacings.empty()) {
540      std::nth_element(spacings.begin(), spacings.begin() + spacings.size() / 2,
541                       spacings.end());
542      line_spacing_ = spacings[spacings.size() / 2];
543      if (debug_level_ > 1) {
544        tprintf("Estimate of linespacing = %g\n", line_spacing_);
545      }
546    }
547  }
548  void BaselineBlock::RefineLineSpacing(const std::vector<double> &positions) {
549    double spacings[3], offsets[3], errors[3];
550    int index_range;
551    errors[0] = FitLineSpacingModel(positions, line_spacing_, &spacings[0],
552                                    &offsets[0], &index_range);
553    if (index_range > 1) {
554      double spacing_plus = line_spacing_ / (1.0 + 1.0 / index_range);
555      errors[1] = FitLineSpacingModel(positions, spacing_plus, &spacings[1],
556                                      &offsets[1], nullptr);
557      double spacing_minus = line_spacing_ / (1.0 - 1.0 / index_range);
558      errors[2] = FitLineSpacingModel(positions, spacing_minus, &spacings[2],
559                                      &offsets[2], nullptr);
560      for (int i = 1; i <= 2; ++i) {
561        if (errors[i] < errors[0]) {
562          spacings[0] = spacings[i];
563          offsets[0] = offsets[i];
564          errors[0] = errors[i];
565        }
566      }
567    }
568    if (spacings[0] > 0.0) {
569      line_spacing_ = spacings[0];
570      line_offset_ = offsets[0];
571      model_error_ = errors[0];
572      if (debug_level_ > 0) {
573        tprintf("Final linespacing model = %g + offset %g, error %g\n",
574                line_spacing_, line_offset_, model_error_);
575      }
576    }
577  }
578  double BaselineBlock::FitLineSpacingModel(const std::vector<double> &positions,
579                                            double m_in, double *m_out,
580                                            double *c_out, int *index_delta) {
581    if (m_in == 0.0f || positions.size() < 2) {
582      *m_out = m_in;
583      *c_out = 0.0;
584      if (index_delta != nullptr) {
585        *index_delta = 0;
586      }
587      return 0.0;
588    }
589    std::vector<double> offsets;
590    offsets.reserve(positions.size());
591    for (double position : positions) {
592      offsets.push_back(fmod(position, m_in));
593    }
594    double median_offset = MedianOfCircularValues(m_in, offsets);
595    LLSQ llsq;
596    int min_index = INT32_MAX;
597    int max_index = -INT32_MAX;
598    for (double y_pos : positions) {
599      int row_index = IntCastRounded((y_pos - median_offset) / m_in);
600      UpdateRange(row_index, &min_index, &max_index);
601      llsq.add(row_index, y_pos);
602    }
603    *m_out = llsq.m();
604    offsets.clear();
605    if (*m_out != 0.0) {
606      for (double position : positions) {
607        offsets.push_back(fmod(position, *m_out));
608      }
609      if (debug_level_ > 2) {
610        for (unsigned i = 0; i < offsets.size(); ++i) {
611          tprintf("%u: %g\n", i, offsets[i]);
612        }
613      }
614      *c_out = MedianOfCircularValues(*m_out, offsets);
615    } else {
616      *c_out = 0.0;
617    }
618    if (debug_level_ > 1) {
619      tprintf("Median offset = %g, compared to mean of %g.\n", *c_out,
620              llsq.c(*m_out));
621    }
622    if (index_delta != nullptr) {
623      *index_delta = max_index - min_index;
624    }
625    double rms_error = llsq.rms(*m_out, llsq.c(*m_out));
626    if (debug_level_ > 1) {
627      tprintf("Linespacing of y=%g x + %g improved to %g x + %g, rms=%g\n", m_in,
628              median_offset, *m_out, *c_out, rms_error);
629    }
630    return rms_error;
631  }
632  BaselineDetect::BaselineDetect(int debug_level, const FCOORD &page_skew,
633                                 TO_BLOCK_LIST *blocks)
634      : page_skew_(page_skew), debug_level_(debug_level) {
635    TO_BLOCK_IT it(blocks);
636    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
637      TO_BLOCK *to_block = it.data();
638      BLOCK *block = to_block->block;
639      POLY_BLOCK *pb = block->pdblk.poly_block();
640      bool non_text = pb != nullptr && !pb->IsText();
641      blocks_.push_back(new BaselineBlock(debug_level_, non_text, to_block));
642    }
643  }
644  void BaselineDetect::ComputeStraightBaselines(bool use_box_bottoms) {
645    std::vector<double> block_skew_angles;
646    for (auto bl_block : blocks_) {
647      if (debug_level_ > 0) {
648        tprintf("Fitting initial baselines...\n");
649      }
650      if (bl_block->FitBaselinesAndFindSkew(use_box_bottoms)) {
651        block_skew_angles.push_back(bl_block->skew_angle());
652      }
653    }
654    double default_block_skew = page_skew_.angle();
655    if (!block_skew_angles.empty()) {
656      default_block_skew = MedianOfCircularValues(M_PI, block_skew_angles);
657    }
658    if (debug_level_ > 0) {
659      tprintf("Page skew angle = %g\n", default_block_skew);
660    }
661    for (auto bl_block : blocks_) {
662      bl_block->ParallelizeBaselines(default_block_skew);
663      bl_block->SetupBlockParameters(); 
664    }
665  }
666  void BaselineDetect::ComputeBaselineSplinesAndXheights(const ICOORD &page_tr,
667                                                         bool enable_splines,
668                                                         bool remove_noise,
669                                                         bool show_final_rows,
670                                                         Textord *textord) {
671    for (auto bl_block : blocks_) {
672      if (enable_splines) {
673        bl_block->PrepareForSplineFitting(page_tr, remove_noise);
674      }
675      bl_block->FitBaselineSplines(enable_splines, show_final_rows, textord);
676  #ifndef GRAPHICS_DISABLED
677      if (show_final_rows) {
678        bl_block->DrawFinalRows(page_tr);
679      }
680  #endif
681    }
682  }
683  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-tprintf.cpp</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-baselinedetect.cpp</div>
                <div class="column column_space"><pre><code>16    if (debug_file_name == nullptr) {
17      return;
18    }
19  #ifdef _WIN32
20    if (strcmp(debug_file_name, "/dev/null") == 0) {
21      debug_file_name = "nul";
22      debug_file.set_value(debug_file_name);
23    }
24  #endif
25    if (debugfp == nullptr && debug_file_name[0] != '\0') {
</pre></code></div>
                <div class="column column_space"><pre><code>346    if (non_text_block_) {
347      return;
348    }
349    if (!good_skew_angle_) {
350      skew_angle_ = default_block_skew;
351    }
352    if (debug_level_ > 0) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    