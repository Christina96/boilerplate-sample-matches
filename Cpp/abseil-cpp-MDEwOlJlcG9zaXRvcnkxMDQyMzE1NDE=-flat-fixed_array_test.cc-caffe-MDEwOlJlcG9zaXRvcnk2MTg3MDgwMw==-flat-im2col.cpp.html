
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 7.796610169491526%, Tokens: 10</h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-fixed_array_test.cc</h3>
            <pre><code>1  #include "absl/container/fixed_array.h"
2  #include <stdio.h>
3  #include <cstring>
4  #include <list>
5  #include <memory>
6  #include <numeric>
7  #include <scoped_allocator>
8  #include <stdexcept>
9  #include <string>
10  #include <vector>
11  #include "gmock/gmock.h"
12  #include "gtest/gtest.h"
13  #include "absl/base/config.h"
14  #include "absl/base/internal/exception_testing.h"
15  #include "absl/base/options.h"
16  #include "absl/container/internal/counting_allocator.h"
17  #include "absl/hash/hash_testing.h"
18  #include "absl/memory/memory.h"
19  using ::testing::ElementsAreArray;
20  namespace {
21  template <typename ArrayType>
22  static bool IsOnStack(const ArrayType& a) {
23    return a.size() <= ArrayType::inline_elements;
24  }
25  class ConstructionTester {
26   public:
27    ConstructionTester() : self_ptr_(this), value_(0) { constructions++; }
28    ~ConstructionTester() {
29      assert(self_ptr_ == this);
30      self_ptr_ = nullptr;
31      destructions++;
32    }
33    static int constructions;
34    static int destructions;
35    void CheckConstructed() { assert(self_ptr_ == this); }
36    void set(int value) { value_ = value; }
37    int get() { return value_; }
38   private:
39    ConstructionTester* self_ptr_;
40    int value_;
41  };
42  int ConstructionTester::constructions = 0;
43  int ConstructionTester::destructions = 0;
44  class ThreeInts {
45   public:
46    ThreeInts() {
47      x_ = counter;
48      y_ = counter;
49      z_ = counter;
50      ++counter;
51    }
52    static int counter;
53    int x_, y_, z_;
54  };
55  int ThreeInts::counter = 0;
56  TEST(FixedArrayTest, CopyCtor) {
57    absl::FixedArray<int, 10> on_stack(5);
58    std::iota(on_stack.begin(), on_stack.end(), 0);
59    absl::FixedArray<int, 10> stack_copy = on_stack;
60    EXPECT_THAT(stack_copy, ElementsAreArray(on_stack));
61    EXPECT_TRUE(IsOnStack(stack_copy));
62    absl::FixedArray<int, 10> allocated(15);
63    std::iota(allocated.begin(), allocated.end(), 0);
64    absl::FixedArray<int, 10> alloced_copy = allocated;
65    EXPECT_THAT(alloced_copy, ElementsAreArray(allocated));
66    EXPECT_FALSE(IsOnStack(alloced_copy));
67  }
68  TEST(FixedArrayTest, MoveCtor) {
69    absl::FixedArray<std::unique_ptr<int>, 10> on_stack(5);
70    for (int i = 0; i < 5; ++i) {
71      on_stack[i] = absl::make_unique<int>(i);
72    }
73    absl::FixedArray<std::unique_ptr<int>, 10> stack_copy = std::move(on_stack);
74    for (int i = 0; i < 5; ++i) EXPECT_EQ(*(stack_copy[i]), i);
75    EXPECT_EQ(stack_copy.size(), on_stack.size());
76    absl::FixedArray<std::unique_ptr<int>, 10> allocated(15);
77    for (int i = 0; i < 15; ++i) {
78      allocated[i] = absl::make_unique<int>(i);
79    }
80    absl::FixedArray<std::unique_ptr<int>, 10> alloced_copy =
81        std::move(allocated);
82    for (int i = 0; i < 15; ++i) EXPECT_EQ(*(alloced_copy[i]), i);
83    EXPECT_EQ(allocated.size(), alloced_copy.size());
84  }
85  TEST(FixedArrayTest, SmallObjects) {
86    {
87      absl::FixedArray<int> array(4);
88      EXPECT_TRUE(IsOnStack(array));
89    }
90    {
91      absl::FixedArray<int> array(1048576);
92      EXPECT_FALSE(IsOnStack(array));
93    }
94    {
95      absl::FixedArray<int, 100> array(100);
96      EXPECT_TRUE(IsOnStack(array));
97    }
98    {
99      absl::FixedArray<int, 100> array(101);
100      EXPECT_FALSE(IsOnStack(array));
101    }
102    {
103      absl::FixedArray<int> array1(0);
104      absl::FixedArray<char> array2(0);
105      EXPECT_LE(sizeof(array1), sizeof(array2) + 100);
106      EXPECT_LE(sizeof(array2), sizeof(array1) + 100);
107    }
108    {
109      absl::FixedArray<std::vector<int>> array(2);
110      EXPECT_EQ(0, array[0].size());
111      EXPECT_EQ(0, array[1].size());
112    }
113    {
114      ThreeInts::counter = 1;
115      absl::FixedArray<ThreeInts> array(2);
116      EXPECT_EQ(1, array[0].x_);
117      EXPECT_EQ(1, array[0].y_);
118      EXPECT_EQ(1, array[0].z_);
119      EXPECT_EQ(2, array[1].x_);
120      EXPECT_EQ(2, array[1].y_);
121      EXPECT_EQ(2, array[1].z_);
122    }
123  }
124  TEST(FixedArrayTest, AtThrows) {
125    absl::FixedArray<int> a = {1, 2, 3};
126    EXPECT_EQ(a.at(2), 3);
127    ABSL_BASE_INTERNAL_EXPECT_FAIL(a.at(3), std::out_of_range,
128                                   "failed bounds check");
129  }
130  TEST(FixedArrayTest, Hardened) {
131  #if !defined(NDEBUG) || ABSL_OPTION_HARDENED
132    absl::FixedArray<int> a = {1, 2, 3};
133    EXPECT_EQ(a[2], 3);
134    EXPECT_DEATH_IF_SUPPORTED(a[3], "");
135    EXPECT_DEATH_IF_SUPPORTED(a[-1], "");
136    absl::FixedArray<int> empty(0);
137    EXPECT_DEATH_IF_SUPPORTED(empty[0], "");
138    EXPECT_DEATH_IF_SUPPORTED(empty[-1], "");
139    EXPECT_DEATH_IF_SUPPORTED(empty.front(), "");
140    EXPECT_DEATH_IF_SUPPORTED(empty.back(), "");
141  #endif
142  }
143  TEST(FixedArrayRelationalsTest, EqualArrays) {
144    for (int i = 0; i < 10; ++i) {
145      absl::FixedArray<int, 5> a1(i);
146      std::iota(a1.begin(), a1.end(), 0);
147      absl::FixedArray<int, 5> a2(a1.begin(), a1.end());
148      EXPECT_TRUE(a1 == a2);
149      EXPECT_FALSE(a1 != a2);
150      EXPECT_TRUE(a2 == a1);
151      EXPECT_FALSE(a2 != a1);
152      EXPECT_FALSE(a1 < a2);
153      EXPECT_FALSE(a1 > a2);
154      EXPECT_FALSE(a2 < a1);
155      EXPECT_FALSE(a2 > a1);
156      EXPECT_TRUE(a1 <= a2);
157      EXPECT_TRUE(a1 >= a2);
158      EXPECT_TRUE(a2 <= a1);
159      EXPECT_TRUE(a2 >= a1);
160    }
161  }
162  TEST(FixedArrayRelationalsTest, UnequalArrays) {
163    for (int i = 1; i < 10; ++i) {
164      absl::FixedArray<int, 5> a1(i);
165      std::iota(a1.begin(), a1.end(), 0);
166      absl::FixedArray<int, 5> a2(a1.begin(), a1.end());
167      --a2[i / 2];
168      EXPECT_FALSE(a1 == a2);
169      EXPECT_TRUE(a1 != a2);
170      EXPECT_FALSE(a2 == a1);
171      EXPECT_TRUE(a2 != a1);
172      EXPECT_FALSE(a1 < a2);
173      EXPECT_TRUE(a1 > a2);
174      EXPECT_TRUE(a2 < a1);
175      EXPECT_FALSE(a2 > a1);
176      EXPECT_FALSE(a1 <= a2);
177      EXPECT_TRUE(a1 >= a2);
178      EXPECT_TRUE(a2 <= a1);
179      EXPECT_FALSE(a2 >= a1);
180    }
181  }
182  template <int stack_elements>
183  static void TestArray(int n) {
184    SCOPED_TRACE(n);
185    SCOPED_TRACE(stack_elements);
186    ConstructionTester::constructions = 0;
187    ConstructionTester::destructions = 0;
188    {
189      absl::FixedArray<ConstructionTester, stack_elements> array(n);
190      EXPECT_THAT(array.size(), n);
191      EXPECT_THAT(array.memsize(), sizeof(ConstructionTester) * n);
192      EXPECT_THAT(array.begin() + n, array.end());
193      for (int i = 0; i < n; i++) {
194        array[i].CheckConstructed();
195      }
196      EXPECT_THAT(ConstructionTester::constructions, n);
197      for (int i = 0; i < n; i++) {
198        array[i].set(i);
199      }
200      for (int i = 0; i < n; i++) {
201        EXPECT_THAT(array[i].get(), i);
202        EXPECT_THAT(array.data()[i].get(), i);
203      }
204      for (int i = 0; i < n; i++) {
205        array.data()[i].set(i + 1);
206      }
207      for (int i = 0; i < n; i++) {
208        EXPECT_THAT(array[i].get(), i + 1);
209        EXPECT_THAT(array.data()[i].get(), i + 1);
210      }
211    }  
212    EXPECT_EQ(ConstructionTester::constructions,
213              ConstructionTester::destructions);
214  }
215  template <int elements_per_inner_array, int inline_elements>
216  static void TestArrayOfArrays(int n) {
217    SCOPED_TRACE(n);
218    SCOPED_TRACE(inline_elements);
219    SCOPED_TRACE(elements_per_inner_array);
220    ConstructionTester::constructions = 0;
221    ConstructionTester::destructions = 0;
222    {
223      using InnerArray = ConstructionTester[elements_per_inner_array];
224      auto array_ptr =
225          absl::make_unique<absl::FixedArray<InnerArray, inline_elements>>(n);
226      auto& array = *array_ptr;
227      ASSERT_EQ(array.size(), n);
228      ASSERT_EQ(array.memsize(),
229                sizeof(ConstructionTester) * elements_per_inner_array * n);
230      ASSERT_EQ(array.begin() + n, array.end());
231      for (int i = 0; i < n; i++) {
232        for (int j = 0; j < elements_per_inner_array; j++) {
233          (array[i])[j].CheckConstructed();
234        }
235      }
236      ASSERT_EQ(ConstructionTester::constructions, n * elements_per_inner_array);
237      for (int i = 0; i < n; i++) {
238        for (int j = 0; j < elements_per_inner_array; j++) {
239          (array[i])[j].set(i * elements_per_inner_array + j);
240        }
241      }
<span onclick='openModal()' class='match'>242      for (int i = 0; i < n; i++) {
243        for (int j = 0; j < elements_per_inner_array; j++) {
</span>244          ASSERT_EQ((array[i])[j].get(), i * elements_per_inner_array + j);
245          ASSERT_EQ((array.data()[i])[j].get(), i * elements_per_inner_array + j);
246        }
247      }
248      for (int i = 0; i < n; i++) {
249        for (int j = 0; j < elements_per_inner_array; j++) {
250          (array.data()[i])[j].set((i + 1) * elements_per_inner_array + j);
251        }
252      }
253      for (int i = 0; i < n; i++) {
254        for (int j = 0; j < elements_per_inner_array; j++) {
255          ASSERT_EQ((array[i])[j].get(), (i + 1) * elements_per_inner_array + j);
256          ASSERT_EQ((array.data()[i])[j].get(),
257                    (i + 1) * elements_per_inner_array + j);
258        }
259      }
260    }  
261    EXPECT_EQ(ConstructionTester::constructions,
262              ConstructionTester::destructions);
263  }
264  TEST(IteratorConstructorTest, NonInline) {
265    int const kInput[] = {2, 3, 5, 7, 11, 13, 17};
266    absl::FixedArray<int, ABSL_ARRAYSIZE(kInput) - 1> const fixed(
267        kInput, kInput + ABSL_ARRAYSIZE(kInput));
268    ASSERT_EQ(ABSL_ARRAYSIZE(kInput), fixed.size());
269    for (size_t i = 0; i < ABSL_ARRAYSIZE(kInput); ++i) {
270      ASSERT_EQ(kInput[i], fixed[i]);
271    }
272  }
273  TEST(IteratorConstructorTest, Inline) {
274    int const kInput[] = {2, 3, 5, 7, 11, 13, 17};
275    absl::FixedArray<int, ABSL_ARRAYSIZE(kInput)> const fixed(
276        kInput, kInput + ABSL_ARRAYSIZE(kInput));
277    ASSERT_EQ(ABSL_ARRAYSIZE(kInput), fixed.size());
278    for (size_t i = 0; i < ABSL_ARRAYSIZE(kInput); ++i) {
279      ASSERT_EQ(kInput[i], fixed[i]);
280    }
281  }
282  TEST(IteratorConstructorTest, NonPod) {
283    char const* kInput[] = {"red",  "orange", "yellow", "green",
284                            "blue", "indigo", "violet"};
285    absl::FixedArray<std::string> const fixed(kInput,
286                                              kInput + ABSL_ARRAYSIZE(kInput));
287    ASSERT_EQ(ABSL_ARRAYSIZE(kInput), fixed.size());
288    for (size_t i = 0; i < ABSL_ARRAYSIZE(kInput); ++i) {
289      ASSERT_EQ(kInput[i], fixed[i]);
290    }
291  }
292  TEST(IteratorConstructorTest, FromEmptyVector) {
293    std::vector<int> const empty;
294    absl::FixedArray<int> const fixed(empty.begin(), empty.end());
295    EXPECT_EQ(0, fixed.size());
296    EXPECT_EQ(empty.size(), fixed.size());
297  }
298  TEST(IteratorConstructorTest, FromNonEmptyVector) {
299    int const kInput[] = {2, 3, 5, 7, 11, 13, 17};
300    std::vector<int> const items(kInput, kInput + ABSL_ARRAYSIZE(kInput));
301    absl::FixedArray<int> const fixed(items.begin(), items.end());
302    ASSERT_EQ(items.size(), fixed.size());
303    for (size_t i = 0; i < items.size(); ++i) {
304      ASSERT_EQ(items[i], fixed[i]);
305    }
306  }
307  TEST(IteratorConstructorTest, FromBidirectionalIteratorRange) {
308    int const kInput[] = {2, 3, 5, 7, 11, 13, 17};
309    std::list<int> const items(kInput, kInput + ABSL_ARRAYSIZE(kInput));
310    absl::FixedArray<int> const fixed(items.begin(), items.end());
311    EXPECT_THAT(fixed, testing::ElementsAreArray(kInput));
312  }
313  TEST(InitListConstructorTest, InitListConstruction) {
314    absl::FixedArray<int> fixed = {1, 2, 3};
315    EXPECT_THAT(fixed, testing::ElementsAreArray({1, 2, 3}));
316  }
317  TEST(FillConstructorTest, NonEmptyArrays) {
318    absl::FixedArray<int> stack_array(4, 1);
319    EXPECT_THAT(stack_array, testing::ElementsAreArray({1, 1, 1, 1}));
320    absl::FixedArray<int, 0> heap_array(4, 1);
321    EXPECT_THAT(stack_array, testing::ElementsAreArray({1, 1, 1, 1}));
322  }
323  TEST(FillConstructorTest, EmptyArray) {
324    absl::FixedArray<int> empty_fill(0, 1);
325    absl::FixedArray<int> empty_size(0);
326    EXPECT_EQ(empty_fill, empty_size);
327  }
328  TEST(FillConstructorTest, NotTriviallyCopyable) {
329    std::string str = "abcd";
330    absl::FixedArray<std::string> strings = {str, str, str, str};
331    absl::FixedArray<std::string> array(4, str);
332    EXPECT_EQ(array, strings);
333  }
334  TEST(FillConstructorTest, Disambiguation) {
335    absl::FixedArray<size_t> a(1, 2);
336    EXPECT_THAT(a, testing::ElementsAre(2));
337  }
338  TEST(FixedArrayTest, ManySizedArrays) {
339    std::vector<int> sizes;
340    for (int i = 1; i < 100; i++) sizes.push_back(i);
341    for (int i = 100; i <= 1000; i += 100) sizes.push_back(i);
342    for (int n : sizes) {
343      TestArray<0>(n);
344      TestArray<1>(n);
345      TestArray<64>(n);
346      TestArray<1000>(n);
347    }
348  }
349  TEST(FixedArrayTest, ManySizedArraysOfArraysOf1) {
350    for (int n = 1; n < 1000; n++) {
351      ASSERT_NO_FATAL_FAILURE((TestArrayOfArrays<1, 0>(n)));
352      ASSERT_NO_FATAL_FAILURE((TestArrayOfArrays<1, 1>(n)));
353      ASSERT_NO_FATAL_FAILURE((TestArrayOfArrays<1, 64>(n)));
354      ASSERT_NO_FATAL_FAILURE((TestArrayOfArrays<1, 1000>(n)));
355    }
356  }
357  TEST(FixedArrayTest, ManySizedArraysOfArraysOf2) {
358    for (int n = 1; n < 1000; n++) {
359      TestArrayOfArrays<2, 0>(n);
360      TestArrayOfArrays<2, 1>(n);
361      TestArrayOfArrays<2, 64>(n);
362      TestArrayOfArrays<2, 1000>(n);
363    }
364  }
365  TEST(FixedArrayTest, AvoidParanoidDiagnostics) {
366    absl::FixedArray<char, 32> buf(32);
367    sprintf(buf.data(), "foo");  
368  }
369  TEST(FixedArrayTest, TooBigInlinedSpace) {
370    struct TooBig {
371      char c[1 << 20];
372    };  
373    struct Data {
374      TooBig* p;
375      size_t size;
376    };
377    static_assert(sizeof(absl::FixedArray<TooBig, 0>) == sizeof(Data),
378                  "0-sized absl::FixedArray should have same size as Data.");
379    static_assert(alignof(absl::FixedArray<TooBig, 0>) == alignof(Data),
380                  "0-sized absl::FixedArray should have same alignment as Data.");
381    static_assert(sizeof(absl::FixedArray<TooBig>) == sizeof(Data),
382                  "default-sized absl::FixedArray should have same size as Data");
383    static_assert(
384        alignof(absl::FixedArray<TooBig>) == alignof(Data),
385        "default-sized absl::FixedArray should have same alignment as Data.");
386  }
387  struct PickyDelete {
388    PickyDelete() {}
389    ~PickyDelete() {}
390    void operator delete(void* p) {
391      EXPECT_TRUE(false) << __FUNCTION__;
392      ::operator delete(p);
393    }
394    void operator delete[](void* p) {
395      EXPECT_TRUE(false) << __FUNCTION__;
396      ::operator delete[](p);
397    }
398  };
399  TEST(FixedArrayTest, UsesGlobalAlloc) { absl::FixedArray<PickyDelete, 0> a(5); }
400  TEST(FixedArrayTest, Data) {
401    static const int kInput[] = {2, 3, 5, 7, 11, 13, 17};
402    absl::FixedArray<int> fa(std::begin(kInput), std::end(kInput));
403    EXPECT_EQ(fa.data(), &*fa.begin());
404    EXPECT_EQ(fa.data(), &fa[0]);
405    const absl::FixedArray<int>& cfa = fa;
406    EXPECT_EQ(cfa.data(), &*cfa.begin());
407    EXPECT_EQ(cfa.data(), &cfa[0]);
408  }
409  TEST(FixedArrayTest, Empty) {
410    absl::FixedArray<int> empty(0);
411    absl::FixedArray<int> inline_filled(1);
412    absl::FixedArray<int, 0> heap_filled(1);
413    EXPECT_TRUE(empty.empty());
414    EXPECT_FALSE(inline_filled.empty());
415    EXPECT_FALSE(heap_filled.empty());
416  }
417  TEST(FixedArrayTest, FrontAndBack) {
418    absl::FixedArray<int, 3 * sizeof(int)> inlined = {1, 2, 3};
419    EXPECT_EQ(inlined.front(), 1);
420    EXPECT_EQ(inlined.back(), 3);
421    absl::FixedArray<int, 0> allocated = {1, 2, 3};
422    EXPECT_EQ(allocated.front(), 1);
423    EXPECT_EQ(allocated.back(), 3);
424    absl::FixedArray<int> one_element = {1};
425    EXPECT_EQ(one_element.front(), one_element.back());
426  }
427  TEST(FixedArrayTest, ReverseIteratorInlined) {
428    absl::FixedArray<int, 5 * sizeof(int)> a = {0, 1, 2, 3, 4};
429    int counter = 5;
430    for (absl::FixedArray<int>::reverse_iterator iter = a.rbegin();
431         iter != a.rend(); ++iter) {
432      counter--;
433      EXPECT_EQ(counter, *iter);
434    }
435    EXPECT_EQ(counter, 0);
436    counter = 5;
437    for (absl::FixedArray<int>::const_reverse_iterator iter = a.rbegin();
438         iter != a.rend(); ++iter) {
439      counter--;
440      EXPECT_EQ(counter, *iter);
441    }
442    EXPECT_EQ(counter, 0);
443    counter = 5;
444    for (auto iter = a.crbegin(); iter != a.crend(); ++iter) {
445      counter--;
446      EXPECT_EQ(counter, *iter);
447    }
448    EXPECT_EQ(counter, 0);
449  }
450  TEST(FixedArrayTest, ReverseIteratorAllocated) {
451    absl::FixedArray<int, 0> a = {0, 1, 2, 3, 4};
452    int counter = 5;
453    for (absl::FixedArray<int>::reverse_iterator iter = a.rbegin();
454         iter != a.rend(); ++iter) {
455      counter--;
456      EXPECT_EQ(counter, *iter);
457    }
458    EXPECT_EQ(counter, 0);
459    counter = 5;
460    for (absl::FixedArray<int>::const_reverse_iterator iter = a.rbegin();
461         iter != a.rend(); ++iter) {
462      counter--;
463      EXPECT_EQ(counter, *iter);
464    }
465    EXPECT_EQ(counter, 0);
466    counter = 5;
467    for (auto iter = a.crbegin(); iter != a.crend(); ++iter) {
468      counter--;
469      EXPECT_EQ(counter, *iter);
470    }
471    EXPECT_EQ(counter, 0);
472  }
473  TEST(FixedArrayTest, Fill) {
474    absl::FixedArray<int, 5 * sizeof(int)> inlined(5);
475    int fill_val = 42;
476    inlined.fill(fill_val);
477    for (int i : inlined) EXPECT_EQ(i, fill_val);
478    absl::FixedArray<int, 0> allocated(5);
479    allocated.fill(fill_val);
480    for (int i : allocated) EXPECT_EQ(i, fill_val);
481    absl::FixedArray<int> empty(0);
482    empty.fill(fill_val);
483  }
484  #ifndef __GNUC__
485  TEST(FixedArrayTest, DefaultCtorDoesNotValueInit) {
486    using T = char;
487    constexpr auto capacity = 10;
488    using FixedArrType = absl::FixedArray<T, capacity>;
489    constexpr auto scrubbed_bits = 0x95;
490    constexpr auto length = capacity / 2;
491    alignas(FixedArrType) unsigned char buff[sizeof(FixedArrType)];
492    std::memset(std::addressof(buff), scrubbed_bits, sizeof(FixedArrType));
493    FixedArrType* arr =
494        ::new (static_cast<void*>(std::addressof(buff))) FixedArrType(length);
495    EXPECT_THAT(*arr, testing::Each(scrubbed_bits));
496    arr->~FixedArrType();
497  }
498  #endif  
499  TEST(AllocatorSupportTest, CountInlineAllocations) {
500    constexpr size_t inlined_size = 4;
501    using Alloc = absl::container_internal::CountingAllocator<int>;
502    using AllocFxdArr = absl::FixedArray<int, inlined_size, Alloc>;
503    int64_t allocated = 0;
504    int64_t active_instances = 0;
505    {
506      const int ia[] = {0, 1, 2, 3, 4, 5, 6, 7};
507      Alloc alloc(&allocated, &active_instances);
508      AllocFxdArr arr(ia, ia + inlined_size, alloc);
509      static_cast<void>(arr);
510    }
511    EXPECT_EQ(allocated, 0);
512    EXPECT_EQ(active_instances, 0);
513  }
514  TEST(AllocatorSupportTest, CountOutoflineAllocations) {
515    constexpr size_t inlined_size = 4;
516    using Alloc = absl::container_internal::CountingAllocator<int>;
517    using AllocFxdArr = absl::FixedArray<int, inlined_size, Alloc>;
518    int64_t allocated = 0;
519    int64_t active_instances = 0;
520    {
521      const int ia[] = {0, 1, 2, 3, 4, 5, 6, 7};
522      Alloc alloc(&allocated, &active_instances);
523      AllocFxdArr arr(ia, ia + ABSL_ARRAYSIZE(ia), alloc);
524      EXPECT_EQ(allocated, arr.size() * sizeof(int));
525      static_cast<void>(arr);
526    }
527    EXPECT_EQ(active_instances, 0);
528  }
529  TEST(AllocatorSupportTest, CountCopyInlineAllocations) {
530    constexpr size_t inlined_size = 4;
531    using Alloc = absl::container_internal::CountingAllocator<int>;
532    using AllocFxdArr = absl::FixedArray<int, inlined_size, Alloc>;
533    int64_t allocated1 = 0;
534    int64_t allocated2 = 0;
535    int64_t active_instances = 0;
536    Alloc alloc(&allocated1, &active_instances);
537    Alloc alloc2(&allocated2, &active_instances);
538    {
539      int initial_value = 1;
540      AllocFxdArr arr1(inlined_size / 2, initial_value, alloc);
541      EXPECT_EQ(allocated1, 0);
542      AllocFxdArr arr2(arr1, alloc2);
543      EXPECT_EQ(allocated2, 0);
544      static_cast<void>(arr1);
545      static_cast<void>(arr2);
546    }
547    EXPECT_EQ(active_instances, 0);
548  }
549  TEST(AllocatorSupportTest, CountCopyOutoflineAllocations) {
550    constexpr size_t inlined_size = 4;
551    using Alloc = absl::container_internal::CountingAllocator<int>;
552    using AllocFxdArr = absl::FixedArray<int, inlined_size, Alloc>;
553    int64_t allocated1 = 0;
554    int64_t allocated2 = 0;
555    int64_t active_instances = 0;
556    Alloc alloc(&allocated1, &active_instances);
557    Alloc alloc2(&allocated2, &active_instances);
558    {
559      int initial_value = 1;
560      AllocFxdArr arr1(inlined_size * 2, initial_value, alloc);
561      EXPECT_EQ(allocated1, arr1.size() * sizeof(int));
562      AllocFxdArr arr2(arr1, alloc2);
563      EXPECT_EQ(allocated2, inlined_size * 2 * sizeof(int));
564      static_cast<void>(arr1);
565      static_cast<void>(arr2);
566    }
567    EXPECT_EQ(active_instances, 0);
568  }
569  TEST(AllocatorSupportTest, SizeValAllocConstructor) {
570    using testing::AllOf;
571    using testing::Each;
572    using testing::SizeIs;
573    constexpr size_t inlined_size = 4;
574    using Alloc = absl::container_internal::CountingAllocator<int>;
575    using AllocFxdArr = absl::FixedArray<int, inlined_size, Alloc>;
576    {
577      auto len = inlined_size / 2;
578      auto val = 0;
579      int64_t allocated = 0;
580      AllocFxdArr arr(len, val, Alloc(&allocated));
581      EXPECT_EQ(allocated, 0);
582      EXPECT_THAT(arr, AllOf(SizeIs(len), Each(0)));
583    }
584    {
585      auto len = inlined_size * 2;
586      auto val = 0;
587      int64_t allocated = 0;
588      AllocFxdArr arr(len, val, Alloc(&allocated));
589      EXPECT_EQ(allocated, len * sizeof(int));
590      EXPECT_THAT(arr, AllOf(SizeIs(len), Each(0)));
591    }
592  }
593  TEST(AllocatorSupportTest, PropagatesStatefulAllocator) {
594    constexpr size_t inlined_size = 4;
595    using Alloc = absl::container_internal::CountingAllocator<int>;
596    using AllocFxdArr = absl::FixedArray<int, inlined_size, Alloc>;
597    auto len = inlined_size * 2;
598    auto val = 0;
599    int64_t allocated = 0;
600    AllocFxdArr arr(len, val, Alloc(&allocated));
601    EXPECT_EQ(allocated, len * sizeof(int));
602    AllocFxdArr copy = arr;
603    EXPECT_EQ(allocated, len * sizeof(int) * 2);
604  }
605  #ifdef ABSL_HAVE_ADDRESS_SANITIZER
606  TEST(FixedArrayTest, AddressSanitizerAnnotations1) {
607    absl::FixedArray<int, 32> a(10);
608    int* raw = a.data();
609    raw[0] = 0;
610    raw[9] = 0;
611    EXPECT_DEATH_IF_SUPPORTED(raw[-2] = 0, "container-overflow");
612    EXPECT_DEATH_IF_SUPPORTED(raw[-1] = 0, "container-overflow");
613    EXPECT_DEATH_IF_SUPPORTED(raw[10] = 0, "container-overflow");
614    EXPECT_DEATH_IF_SUPPORTED(raw[31] = 0, "container-overflow");
615  }
616  TEST(FixedArrayTest, AddressSanitizerAnnotations2) {
617    absl::FixedArray<char, 17> a(12);
618    char* raw = a.data();
619    raw[0] = 0;
620    raw[11] = 0;
621    EXPECT_DEATH_IF_SUPPORTED(raw[-7] = 0, "container-overflow");
622    EXPECT_DEATH_IF_SUPPORTED(raw[-1] = 0, "container-overflow");
623    EXPECT_DEATH_IF_SUPPORTED(raw[12] = 0, "container-overflow");
624    EXPECT_DEATH_IF_SUPPORTED(raw[17] = 0, "container-overflow");
625  }
626  TEST(FixedArrayTest, AddressSanitizerAnnotations3) {
627    absl::FixedArray<uint64_t, 20> a(20);
628    uint64_t* raw = a.data();
629    raw[0] = 0;
630    raw[19] = 0;
631    EXPECT_DEATH_IF_SUPPORTED(raw[-1] = 0, "container-overflow");
632    EXPECT_DEATH_IF_SUPPORTED(raw[20] = 0, "container-overflow");
633  }
634  TEST(FixedArrayTest, AddressSanitizerAnnotations4) {
635    absl::FixedArray<ThreeInts> a(10);
636    ThreeInts* raw = a.data();
637    raw[0] = ThreeInts();
638    raw[9] = ThreeInts();
639    EXPECT_DEATH_IF_SUPPORTED(raw[-1].z_ = 0, "container-overflow");
640    EXPECT_DEATH_IF_SUPPORTED(raw[10] = ThreeInts(), "container-overflow");
641    EXPECT_DEATH_IF_SUPPORTED(raw[21] = ThreeInts(), "container-overflow");
642  }
643  #endif  
644  TEST(FixedArrayTest, AbslHashValueWorks) {
645    using V = absl::FixedArray<int>;
646    std::vector<V> cases;
647    for (int i = 0; i < 10; ++i) {
648      V v(i);
649      for (int j = 0; j < i; ++j) {
650        v[j] = j;
651      }
652      cases.push_back(v);
653    }
654    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(cases));
655  }
656  }  
</code></pre>
        </div>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-im2col.cpp</h3>
            <pre><code>1  #include <vector>
2  #include "caffe/util/im2col.hpp"
3  #include "caffe/util/math_functions.hpp"
4  namespace caffe {
5  inline bool is_a_ge_zero_and_a_lt_b(int a, int b) {
6    return static_cast<unsigned>(a) < static_cast<unsigned>(b);
7  }
8  template <typename Dtype>
9  void im2col_cpu(const Dtype* data_im, const int channels,
10      const int height, const int width, const int kernel_h, const int kernel_w,
11      const int pad_h, const int pad_w,
12      const int stride_h, const int stride_w,
13      const int dilation_h, const int dilation_w,
14      Dtype* data_col) {
15  #if 0
16    const int output_h = (height + 2 * pad_h -
17      (dilation_h * (kernel_h - 1) + 1)) / stride_h + 1;
18    const int output_w = (width + 2 * pad_w -
19      (dilation_w * (kernel_w - 1) + 1)) / stride_w + 1;
20    const int channel_size = height * width;
21    for (int channel = channels; channel--; data_im += channel_size) {
22      for (int kernel_row = 0; kernel_row < kernel_h; kernel_row++) {
23        for (int kernel_col = 0; kernel_col < kernel_w; kernel_col++) {
24          int input_row = -pad_h + kernel_row * dilation_h;
25          for (int output_rows = output_h; output_rows; output_rows--) {
26            if (!is_a_ge_zero_and_a_lt_b(input_row, height)) {
27              for (int output_cols = output_w; output_cols; output_cols--) {
28                *(data_col++) = 0;
29              }
30            } else {
31              int input_col = -pad_w + kernel_col * dilation_w;
32              for (int output_col = output_w; output_col; output_col--) {
33                if (is_a_ge_zero_and_a_lt_b(input_col, width)) {
34                  *(data_col++) = data_im[input_row * width + input_col];
35                } else {
36                  *(data_col++) = 0;
37                }
38                input_col += stride_w;
39              }
40            }
41            input_row += stride_h;
42          }
43        }
44      }
45    }
46  #else
47    int dil_kernel_h = (kernel_h - 1) * dilation_h + 1;
48    int dil_kernel_w = (kernel_w - 1) * dilation_w + 1;
49    int height_col = (height + 2 * pad_h - dil_kernel_h) / stride_h + 1;
50    int width_col = (width + 2 * pad_w - dil_kernel_w) / stride_w + 1;
51    int channels_col = channels * kernel_h * kernel_w;
52    #ifdef _OPENMP
53    #pragma omp parallel for
54    #endif
55    for (int c = 0; c < channels_col; ++c) {
56      int w_offset = c % kernel_w;
57      int h_offset = (c / kernel_w) % kernel_h;
58      int c_im = c / kernel_h / kernel_w;
59      const int hc0 = h_offset * dilation_h - pad_h;
60      const int wc0 = w_offset * dilation_w - pad_w;
61      for (int h = 0; h < height_col; ++h) {
62        int h_pad = h * stride_h + hc0;
63        const int row_offset = (c * height_col + h) * width_col;
64        const int srow_offset = (c_im * height + h_pad) * width;
65        for (int w = 0; w < width_col; ++w) {
66          int w_pad = w * stride_w + wc0;
67          if ((((unsigned)h_pad) < ((unsigned)height)) && (((unsigned)w_pad) < ((unsigned)width)))
68            data_col[row_offset + w] = data_im[srow_offset + w_pad];
69          else {
70            data_col[row_offset + w] = 0.;
71          }
72        }
73      }
74    }
75  #endif
76  }
77  template <typename Dtype>
78  void im3d2col_cpu(const Dtype* data_im, const int channels,
79      const int depth, const int height, const int width,
80      const int kernel_d, const int kernel_h, const int kernel_w,
81      const int pad_d, const int pad_h, const int pad_w,
82      const int stride_d, const int stride_h, const int stride_w,
83      const int dilation_d, const int dilation_h, const int dilation_w,
84      Dtype* data_col) {
85    long dil_kernel_h = (kernel_h - 1) * dilation_h + 1;
86    long dil_kernel_w = (kernel_w - 1) * dilation_w + 1;
87    long dil_kernel_d = (kernel_d - 1) * dilation_d + 1;
88    long height_col = (height + 2 * pad_h - dil_kernel_h) / stride_h + 1;
89    long width_col = (width + 2 * pad_w - dil_kernel_w) / stride_w + 1;
90    long depth_col = (depth + 2 * pad_d - dil_kernel_d) / stride_d + 1;
91    long channels_col = channels * kernel_h * kernel_w * kernel_d;
92    #ifdef _OPENMP
93    #pragma omp parallel for
94    #endif
95    for (long c = 0; c < channels_col; ++c) {
96      long w_offset = c % kernel_w;
97      long h_offset = (c / kernel_w) % kernel_h;
98      long d_offset = (c / kernel_w / kernel_h) % kernel_d;
99      long c_im = c / kernel_h / kernel_w / kernel_d;
100      for (int d = 0; d < depth_col; ++d) {
101        long d_pad = d * stride_d - pad_d + d_offset * dilation_d;
102        for (long h = 0; h < height_col; ++h) {
103          long h_pad = h * stride_h - pad_h + h_offset * dilation_h;
104          for (long w = 0; w < width_col; ++w) {
105            long w_pad = w * stride_w - pad_w + w_offset * dilation_w;
106            if (((unsigned long)h_pad < (unsigned long)height) &&
107                ((unsigned long)w_pad < (unsigned long)width) &&
108                ((unsigned long)d_pad < (unsigned long)depth)) {
109              data_col[((c * depth_col + d) * height_col + h) * width_col + w] =
110                data_im[((c_im * depth + d_pad) * height + h_pad) * width + w_pad];
111            } else {
112              data_col[((c * depth_col + d) * height_col + h) * width_col + w] = 0.;
113            }
114          }
115        }
116      }
117    }
118  }
119  template void im2col_cpu<float>(const float* data_im, const int channels,
120      const int height, const int width, const int kernel_h, const int kernel_w,
121      const int pad_h, const int pad_w, const int stride_h,
122      const int stride_w, const int dilation_h, const int dilation_w,
123      float* data_col);
124  template void im2col_cpu<double>(const double* data_im, const int channels,
125      const int height, const int width, const int kernel_h, const int kernel_w,
126      const int pad_h, const int pad_w, const int stride_h,
127      const int stride_w, const int dilation_h, const int dilation_w,
128      double* data_col);
129  template void im3d2col_cpu<float>(const float* data_im, const int channels,
130      const int depth, const int height, const int width,
131      const int kernel_d, const int kernel_h, const int kernel_w,
132      const int pad_d, const int pad_h, const int pad_w,
133      const int stride_d, const int stride_h, const int stride_w,
134      const int dilation_d, const int dilation_h, const int dilation_w,
135      float* data_col);
136  template void im3d2col_cpu<double>(const double* data_im, const int channels,
137      const int depth, const int height, const int width,
138      const int kernel_d, const int kernel_h, const int kernel_w,
139      const int pad_d, const int pad_h, const int pad_w,
140      const int stride_d, const int stride_h, const int stride_w,
141      const int dilation_d, const int dilation_h, const int dilation_w,
142      double* data_col);
143  template <typename Dtype>
144  inline void im2col_nd_core_cpu(const Dtype* data_input, const bool im2col,
145      const int num_spatial_axes, const int* im_shape, const int* col_shape,
146      const int* kernel_shape, const int* pad, const int* stride,
147      const int* dilation, Dtype* data_output) {
148    if (!im2col) {
149      size_t im_size = im_shape[0];
150      for (int i = 0; i < num_spatial_axes; ++i) {
151        im_size *= (size_t)im_shape[1 + i];
152      }
153      caffe_set(im_size, Dtype(0), data_output);
154    }
155    int kernel_size = 1;
156    for (int i = 0; i < num_spatial_axes; ++i) {
157      kernel_size *= kernel_shape[i];
158    }
159    const int channels_col = col_shape[0];
160    vector<int> d_offset(num_spatial_axes, 0);
161    vector<int> d_iter(num_spatial_axes, 0);
162    for (int c_col = 0; c_col < channels_col; ++c_col) {
163      int offset = c_col;
164      for (int d_i = num_spatial_axes - 1; d_i >= 0; --d_i) {
165        if (d_i < num_spatial_axes - 1) {
166          offset /= kernel_shape[d_i + 1];
167        }
168        d_offset[d_i] = offset % kernel_shape[d_i];
169      }
170      for (bool incremented = true; incremented; ) {
171        int index_col = c_col;
172        int index_im = c_col / kernel_size;
173        bool is_padding = false;
174        for (int d_i = 0; d_i < num_spatial_axes; ++d_i) {
175          const int d = d_iter[d_i];
176          const int d_im = d * stride[d_i] - pad[d_i] +
177              d_offset[d_i] * dilation[d_i];
178          is_padding |= d_im < 0 || d_im >= im_shape[d_i + 1];
179          index_col *= col_shape[d_i + 1];
180          index_col += d;
181          index_im *= im_shape[d_i + 1];
182          index_im += d_im;
183        }
184        if (im2col) {
185          if (is_padding) {
186            data_output[index_col] = 0;
187          } else {
188            data_output[index_col] = data_input[index_im];
189          }
190        } else if (!is_padding) {  
191          data_output[index_im] += data_input[index_col];
192        }
193        incremented = false;
194        for (int d_i = num_spatial_axes - 1; d_i >= 0; --d_i) {
195          const int d_max = col_shape[d_i + 1];
196          DCHECK_LT(d_iter[d_i], d_max);
197          if (d_iter[d_i] == d_max - 1) {
198            d_iter[d_i] = 0;
199          } else {  
200            ++d_iter[d_i];
201            incremented = true;
202            break;
203          }
204        }
205      }  
206    }  
207  }
208  template <typename Dtype>
209  void im2col_nd_cpu(const Dtype* data_im, const int num_spatial_axes,
210      const int* im_shape, const int* col_shape,
211      const int* kernel_shape, const int* pad, const int* stride,
212      const int* dilation, Dtype* data_col) {
213    const bool kIm2Col = true;
214    im2col_nd_core_cpu(data_im, kIm2Col, num_spatial_axes, im_shape, col_shape,
215                    kernel_shape, pad, stride, dilation, data_col);
216  }
217  template void im2col_nd_cpu<float>(const float* data_im,
218      const int num_spatial_axes,
219      const int* im_shape, const int* col_shape,
220      const int* kernel_shape, const int* pad, const int* stride,
221      const int* dilation, float* data_col);
222  template void im2col_nd_cpu<double>(const double* data_im,
223      const int num_spatial_axes,
224      const int* im_shape, const int* col_shape,
225      const int* kernel_shape, const int* pad, const int* stride,
226      const int* dilation, double* data_col);
227  template <typename Dtype>
228  void col2im_cpu(const Dtype* data_col, const int channels,
229      const int height, const int width, const int kernel_h, const int kernel_w,
230      const int pad_h, const int pad_w,
231      const int stride_h, const int stride_w,
232      const int dilation_h, const int dilation_w,
233      Dtype* data_im) {
234  #if 0
235    caffe_set(height * width * channels, Dtype(0), data_im);
236    const int output_h = (height + 2 * pad_h -
237      (dilation_h * (kernel_h - 1) + 1)) / stride_h + 1;
238    const int output_w = (width + 2 * pad_w -
239      (dilation_w * (kernel_w - 1) + 1)) / stride_w + 1;
240    const int channel_size = height * width;
241    for (int channel = channels; channel--; data_im += channel_size) {
242      for (int kernel_row = 0; kernel_row < kernel_h; kernel_row++) {
243        for (int kernel_col = 0; kernel_col < kernel_w; kernel_col++) {
244          int input_row = -pad_h + kernel_row * dilation_h;
245          for (int output_rows = output_h; output_rows; output_rows--) {
246            if (!is_a_ge_zero_and_a_lt_b(input_row, height)) {
247              data_col += output_w;
248            } else {
249              int input_col = -pad_w + kernel_col * dilation_w;
250              for (int output_col = output_w; output_col; output_col--) {
251                if (is_a_ge_zero_and_a_lt_b(input_col, width)) {
252                  data_im[input_row * width + input_col] += *data_col;
253                }
254                data_col++;
255                input_col += stride_w;
256              }
257            }
258            input_row += stride_h;
259          }
260        }
261      }
262    }
263  #else
264    int dil_patch_h = (kernel_h - 1) * dilation_h + 1;
265    int dil_patch_w = (kernel_w - 1) * dilation_w + 1;
266    int height_col = (height + 2 * pad_h - dil_patch_h) / stride_h + 1;
267    int width_col = (width + 2 * pad_w - dil_patch_w) / stride_w + 1;
268    long chunk_len = kernel_h * kernel_w;
269    caffe_set((size_t)height * (size_t)width * (size_t)channels, Dtype(0), data_im);
270    #ifdef _OPENMP
271    #pragma omp parallel for if (channels > 1)
272    #endif 
<span onclick='openModal()' class='match'>273    for (int idx = 0; idx < channels; ++idx) {
274      for (int inner_idx = 0; inner_idx < chunk_len; ++inner_idx) {
</span>275        int c = idx * chunk_len + inner_idx;
276        int w_offset = c % kernel_w;
277        int h_offset = (c / kernel_w) % kernel_h;
278        int c_im = c / kernel_h / kernel_w;
279        const int hc0 = h_offset * dilation_h - pad_h;
280        const int wc0 = w_offset * dilation_w - pad_w;
281        for (int h = 0; h < height_col; ++h) {
282          for (int w = 0; w < width_col; ++w) {
283            int h_pad = h * stride_h + hc0;
284            const int srow_offset = (c_im * height + h_pad) * width;
285            const int row_offset = (c * height_col + h) * width_col;
286            int w_pad = w * stride_w + wc0;
287            if ((((unsigned)h_pad) < ((unsigned)height)) && (((unsigned)w_pad) < ((unsigned)width))) {
288              data_im[srow_offset + w_pad] += data_col[row_offset + w];
289            }
290          }
291        }
292      }
293    }
294  #endif
295  }
296  template <typename Dtype>
297  void col2im3d_cpu(const Dtype* data_col, const int channels,
298      const int depth, const int height, const int width,
299      const int kernel_d, const int kernel_h, const int kernel_w,
300      const int pad_d, const int pad_h, const int pad_w,
301      const int stride_d, const int stride_h, const int stride_w,
302      const int dilation_d, const int dilation_h, const int dilation_w,
303      Dtype* data_im) {
304    long dil_patch_h = (kernel_h - 1) * dilation_h + 1;
305    long dil_patch_w = (kernel_w - 1) * dilation_w + 1;
306    long dil_patch_d = (kernel_d - 1) * dilation_d + 1;
307    long height_col = (height + 2 * pad_h - dil_patch_h) / stride_h + 1;
308    long width_col = (width + 2 * pad_w - dil_patch_w) / stride_w + 1;
309    long depth_col = (depth + 2 * pad_d - dil_patch_d) / stride_d + 1;
310    long num_kernels = (size_t)channels * (size_t)height * (size_t)width * (size_t)depth;
311    long chunk_len = kernel_h * kernel_w * kernel_d;
312    caffe_set(num_kernels, Dtype(0), data_im);
313    #ifdef _OPENMP
314    #pragma omp parallel for if (channels > 1)
315    #endif
316    for (long c_im = 0; c_im < channels; ++c_im) {
317      for (long c = c_im * chunk_len; c < chunk_len * (c_im + 1); ++c) {
318        long w_offset = c % kernel_w;
319        long h_offset = (c / kernel_w) % kernel_h;
320        long d_offset = (c / kernel_w / kernel_h) % kernel_d;
321        long dc0 = d_offset * dilation_d - pad_d;
322        long hc0 = h_offset * dilation_h - pad_h;
323        long wc0 = w_offset * dilation_w - pad_w;
324        for (long d = 0; d < depth_col; ++d) {
325          long d_pad = d * stride_d + dc0;
326          for (long h = 0; h < height_col; ++h) {
327            long h_pad = h * stride_h + hc0;
328            for (long w = 0; w < width_col; ++w) {
329              long w_pad = w * stride_w + wc0;
330              if (((unsigned long)h_pad < (unsigned long)height) &&
331                  ((unsigned long)w_pad < (unsigned long)width) &&
332                  ((unsigned long)d_pad < (unsigned long)depth)) {
333                data_im[((c_im * depth + d_pad) * height + h_pad) * width + w_pad] +=
334                  data_col[((c * depth_col + d) * height_col + h) * width_col + w];
335              }
336            }
337          }
338        }
339      }
340    }
341  }
342  template void col2im_cpu<float>(const float* data_col, const int channels,
343      const int height, const int width, const int kernel_h, const int kernel_w,
344      const int pad_h, const int pad_w, const int stride_h,
345      const int stride_w, const int dilation_h, const int dilation_w,
346      float* data_im);
347  template void col2im_cpu<double>(const double* data_col, const int channels,
348      const int height, const int width, const int kernel_h, const int kernel_w,
349      const int pad_h, const int pad_w, const int stride_h,
350      const int stride_w, const int dilation_h, const int dilation_w,
351      double* data_im);
352  template void col2im3d_cpu<float>(const float* data_col, const int channels,
353      const int depth, const int height, const int width,
354      const int kernel_d, const int kernel_h, const int kernel_w,
355      const int pad_d, const int pad_h, const int pad_w,
356      const int stride_d, const int stride_h, const int stride_w,
357      const int dilation_d, const int dilation_h, const int dilation_w,
358      float* data_im);
359  template void col2im3d_cpu<double>(const double* data_col, const int channels,
360      const int depth, const int height, const int width,
361      const int kernel_d, const int kernel_h, const int kernel_w,
362      const int pad_d, const int pad_h, const int pad_w,
363      const int stride_d, const int stride_h, const int stride_w,
364      const int dilation_d, const int dilation_h, const int dilation_w,
365      double* data_im);
366  template <typename Dtype>
367  void col2im_nd_cpu(const Dtype* data_col, const int num_spatial_axes,
368      const int* im_shape, const int* col_shape,
369      const int* kernel_shape, const int* pad, const int* stride,
370      const int* dilation, Dtype* data_im) {
371    const bool kIm2Col = false;
372    im2col_nd_core_cpu(data_col, kIm2Col, num_spatial_axes, im_shape, col_shape,
373                       kernel_shape, pad, stride, dilation, data_im);
374  }
375  template void col2im_nd_cpu<float>(const float* data_col,
376      const int num_spatial_axes,
377      const int* im_shape, const int* col_shape,
378      const int* kernel_shape, const int* pad, const int* stride,
379      const int* dilation, float* data_im);
380  template void col2im_nd_cpu<double>(const double* data_col,
381      const int num_spatial_axes,
382      const int* im_shape, const int* col_shape,
383      const int* kernel_shape, const int* pad, const int* stride,
384      const int* dilation, double* data_im);
385  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-fixed_array_test.cc</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-im2col.cpp</div>
                <div class="column column_space"><pre><code>242      for (int i = 0; i < n; i++) {
243        for (int j = 0; j < elements_per_inner_array; j++) {
</pre></code></div>
                <div class="column column_space"><pre><code>273    for (int idx = 0; idx < channels; ++idx) {
274      for (int inner_idx = 0; inner_idx < chunk_len; ++inner_idx) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    