
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 20, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexHTML.cxx</h3>
            <pre><code>1  #include <stdlib.h>
2  #include <string.h>
3  #include <stdio.h>
4  #include <stdarg.h>
5  #include <assert.h>
6  #include <ctype.h>
7  #include <string>
8  #include <string_view>
9  #include <map>
10  #include <set>
11  #include <functional>
12  #include "ILexer.h"
13  #include "Scintilla.h"
14  #include "SciLexer.h"
15  #include "WordList.h"
16  #include "LexAccessor.h"
17  #include "Accessor.h"
18  #include "StyleContext.h"
19  #include "CharacterSet.h"
20  #include "LexerModule.h"
21  #include "OptionSet.h"
22  #include "DefaultLexer.h"
23  using namespace Scintilla;
24  using namespace Lexilla;
25  namespace {
26  #define SCE_HA_JS (SCE_HJA_START - SCE_HJ_START)
27  #define SCE_HA_VBS (SCE_HBA_START - SCE_HB_START)
28  #define SCE_HA_PYTHON (SCE_HPA_START - SCE_HP_START)
29  enum script_type { eScriptNone = 0, eScriptJS, eScriptVBS, eScriptPython, eScriptPHP, eScriptXML, eScriptSGML, eScriptSGMLblock, eScriptComment };
30  enum script_mode { eHtml = 0, eNonHtmlScript, eNonHtmlPreProc, eNonHtmlScriptPreProc };
31  inline bool IsAWordChar(const int ch) {
32  	return (ch < 0x80) && (isalnum(ch) || ch == '.' || ch == '_');
33  }
34  inline bool IsAWordStart(const int ch) {
35  	return (ch < 0x80) && (isalnum(ch) || ch == '_');
36  }
37  inline bool IsOperator(int ch) {
38  	if (IsASCII(ch) && isalnum(ch))
39  		return false;
40  	if (ch == '%' || ch == '^' || ch == '&' || ch == '*' ||
41  	        ch == '(' || ch == ')' || ch == '-' || ch == '+' ||
42  	        ch == '=' || ch == '|' || ch == '{' || ch == '}' ||
43  	        ch == '[' || ch == ']' || ch == ':' || ch == ';' ||
44  	        ch == '<' || ch == '>' || ch == ',' || ch == '/' ||
45  	        ch == '?' || ch == '!' || ch == '.' || ch == '~')
46  		return true;
47  	return false;
48  }
49  void GetTextSegment(Accessor &styler, Sci_PositionU start, Sci_PositionU end, char *s, size_t len) {
50  	Sci_PositionU i = 0;
51  	for (; (i < end - start + 1) && (i < len-1); i++) {
52  		s[i] = MakeLowerCase(styler[start + i]);
53  	}
54  	s[i] = '\0';
55  }
56  std::string GetStringSegment(Accessor &styler, Sci_PositionU start, Sci_PositionU end) {
57  	std::string s;
58  	Sci_PositionU i = 0;
59  	for (; (i < end - start + 1); i++) {
60  		s.push_back(MakeLowerCase(styler[start + i]));
61  	}
62  	return s;
63  }
64  std::string GetNextWord(Accessor &styler, Sci_PositionU start) {
65  	std::string ret;
66  	Sci_PositionU i = 0;
67  	for (; i < 200; i++) {	
68  		const char ch = styler.SafeGetCharAt(start + i);
69  		if ((i == 0) && !IsAWordStart(ch))
70  			break;
71  		if ((i > 0) && !IsAWordChar(ch))
72  			break;
73  		ret.push_back(ch);
74  	}
75  	return ret;
76  }
77  script_type segIsScriptingIndicator(Accessor &styler, Sci_PositionU start, Sci_PositionU end, script_type prevValue) {
78  	char s[100];
79  	GetTextSegment(styler, start, end, s, sizeof(s));
80  	if (strstr(s, "vbs"))
81  		return eScriptVBS;
82  	if (strstr(s, "pyth"))
83  		return eScriptPython;
84  	if (strstr(s, "javas") || strstr(s, "ecmas") || strstr(s, "module") || strstr(s, "jscr"))
85  		return eScriptJS;
86  	if (strstr(s, "php"))
87  		return eScriptPHP;
88  	if (strstr(s, "xml")) {
89  		const char *xml = strstr(s, "xml");
90  		for (const char *t=s; t<xml; t++) {
91  			if (!IsASpace(*t)) {
92  				return prevValue;
93  			}
94  		}
95  		return eScriptXML;
96  	}
97  	return prevValue;
98  }
99  int PrintScriptingIndicatorOffset(Accessor &styler, Sci_PositionU start, Sci_PositionU end) {
100  	int iResult = 0;
101  	std::string s = GetStringSegment(styler, start, end);
102  	if (0 == strncmp(s.c_str(), "php", 3)) {
103  		iResult = 3;
104  	}
105  	return iResult;
106  }
107  script_type ScriptOfState(int state) {
108  	if ((state >= SCE_HP_START) && (state <= SCE_HP_IDENTIFIER)) {
109  		return eScriptPython;
110  	} else if ((state >= SCE_HB_START) && (state <= SCE_HB_STRINGEOL)) {
111  		return eScriptVBS;
112  	} else if ((state >= SCE_HJ_START) && (state <= SCE_HJ_REGEX)) {
113  		return eScriptJS;
114  	} else if ((state >= SCE_HPHP_DEFAULT) && (state <= SCE_HPHP_COMMENTLINE)) {
115  		return eScriptPHP;
116  	} else if ((state >= SCE_H_SGML_DEFAULT) && (state < SCE_H_SGML_BLOCK_DEFAULT)) {
117  		return eScriptSGML;
118  	} else if (state == SCE_H_SGML_BLOCK_DEFAULT) {
119  		return eScriptSGMLblock;
120  	} else {
121  		return eScriptNone;
122  	}
123  }
124  int statePrintForState(int state, script_mode inScriptType) {
125  	int StateToPrint = state;
126  	if (state >= SCE_HJ_START) {
127  		if ((state >= SCE_HP_START) && (state <= SCE_HP_IDENTIFIER)) {
128  			StateToPrint = state + ((inScriptType == eNonHtmlScript) ? 0 : SCE_HA_PYTHON);
129  		} else if ((state >= SCE_HB_START) && (state <= SCE_HB_STRINGEOL)) {
130  			StateToPrint = state + ((inScriptType == eNonHtmlScript) ? 0 : SCE_HA_VBS);
131  		} else if ((state >= SCE_HJ_START) && (state <= SCE_HJ_REGEX)) {
132  			StateToPrint = state + ((inScriptType == eNonHtmlScript) ? 0 : SCE_HA_JS);
133  		}
134  	}
135  	return StateToPrint;
136  }
137  int stateForPrintState(int StateToPrint) {
138  	int state;
139  	if ((StateToPrint >= SCE_HPA_START) && (StateToPrint <= SCE_HPA_IDENTIFIER)) {
140  		state = StateToPrint - SCE_HA_PYTHON;
141  	} else if ((StateToPrint >= SCE_HBA_START) && (StateToPrint <= SCE_HBA_STRINGEOL)) {
142  		state = StateToPrint - SCE_HA_VBS;
143  	} else if ((StateToPrint >= SCE_HJA_START) && (StateToPrint <= SCE_HJA_REGEX)) {
144  		state = StateToPrint - SCE_HA_JS;
145  	} else {
146  		state = StateToPrint;
147  	}
148  	return state;
149  }
150  constexpr bool IsNumberChar(char ch) noexcept {
151  	return IsADigit(ch) || ch == '.' || ch == '-' || ch == '#';
152  }
153  inline bool isStringState(int state) {
154  	bool bResult;
155  	switch (state) {
156  	case SCE_HJ_DOUBLESTRING:
157  	case SCE_HJ_SINGLESTRING:
158  	case SCE_HJA_DOUBLESTRING:
159  	case SCE_HJA_SINGLESTRING:
160  	case SCE_HB_STRING:
161  	case SCE_HBA_STRING:
162  	case SCE_HP_STRING:
163  	case SCE_HP_CHARACTER:
164  	case SCE_HP_TRIPLE:
165  	case SCE_HP_TRIPLEDOUBLE:
166  	case SCE_HPA_STRING:
167  	case SCE_HPA_CHARACTER:
168  	case SCE_HPA_TRIPLE:
169  	case SCE_HPA_TRIPLEDOUBLE:
170  	case SCE_HPHP_HSTRING:
171  	case SCE_HPHP_SIMPLESTRING:
172  	case SCE_HPHP_HSTRING_VARIABLE:
173  	case SCE_HPHP_COMPLEX_VARIABLE:
174  		bResult = true;
175  		break;
176  	default :
177  		bResult = false;
178  		break;
179  	}
180  	return bResult;
181  }
182  inline bool stateAllowsTermination(int state) {
183  	bool allowTermination = !isStringState(state);
184  	if (allowTermination) {
185  		switch (state) {
186  		case SCE_HB_COMMENTLINE:
187  		case SCE_HPHP_COMMENT:
188  		case SCE_HP_COMMENTLINE:
189  		case SCE_HPA_COMMENTLINE:
190  			allowTermination = false;
191  		}
192  	}
193  	return allowTermination;
194  }
195  inline bool isCommentASPState(int state) {
196  	bool bResult;
197  	switch (state) {
198  	case SCE_HJ_COMMENT:
199  	case SCE_HJ_COMMENTLINE:
200  	case SCE_HJ_COMMENTDOC:
201  	case SCE_HB_COMMENTLINE:
202  	case SCE_HP_COMMENTLINE:
203  	case SCE_HPHP_COMMENT:
204  	case SCE_HPHP_COMMENTLINE:
205  		bResult = true;
206  		break;
207  	default :
208  		bResult = false;
209  		break;
210  	}
211  	return bResult;
212  }
213  bool classifyAttribHTML(script_mode inScriptType, Sci_PositionU start, Sci_PositionU end, const WordList &keywords, Accessor &styler) {
214  	char chAttr = SCE_H_ATTRIBUTEUNKNOWN;
215  	bool isLanguageType = false;
216  	if (IsNumberChar(styler[start])) {
217  		chAttr = SCE_H_NUMBER;
218  	} else {
219  		const std::string s = GetStringSegment(styler, start, end);
220  		if (keywords.InList(s.c_str()))
221  			chAttr = SCE_H_ATTRIBUTE;
222  		if (inScriptType == eNonHtmlScript) {
223  			if (s == "type" || s == "language") {
224  				isLanguageType = true;
225  			}
226  		}
227  	}
228  	if ((chAttr == SCE_H_ATTRIBUTEUNKNOWN) && !keywords)
229  		chAttr = SCE_H_ATTRIBUTE;
230  	styler.ColourTo(end, chAttr);
231  	return isLanguageType;
232  }
233  bool isHTMLCustomElement(const std::string &tag) {
234  	if (tag.length() < 2 || !IsUpperOrLowerCase(tag[0])) {
235  		return false;
236  	}
237  	if (tag.find('-') == std::string::npos) {
238  		return false;
239  	}
240  	return true;
241  }
242  int classifyTagHTML(Sci_PositionU start, Sci_PositionU end,
243                             const WordList &keywords, Accessor &styler, bool &tagDontFold,
244                      bool caseSensitive, bool isXml, bool allowScripts,
245                      const std::set<std::string> &nonFoldingTags) {
246  	std::string tag;
247  	for (Sci_PositionU cPos = start; cPos <= end; cPos++) {
248  		const char ch = styler[cPos];
249  		if (IsASpace(ch)) {
250  			break;
251  		}
252  		if ((ch != '<') && (ch != '/')) {
253  			tag.push_back(caseSensitive ? ch : MakeLowerCase(ch));
254  		}
255  	}
256  	tagDontFold = (!isXml) && (nonFoldingTags.count(tag) > 0);
257  	char chAttr = SCE_H_TAGUNKNOWN;
258  	if (!tag.empty() && (tag[0] == '!')) {
259  		chAttr = SCE_H_SGML_DEFAULT;
260  	} else if (!keywords || keywords.InList(tag.c_str())) {
261  		chAttr = SCE_H_TAG;
262  	} else if (!isXml && isHTMLCustomElement(tag)) {
263  		chAttr = SCE_H_TAG;
264  	}
265  	if (chAttr != SCE_H_TAGUNKNOWN) {
266  		styler.ColourTo(end, chAttr);
267  	}
268  	if (chAttr == SCE_H_TAG) {
269  		if (allowScripts && (tag == "script")) {
270  			bool isSelfClose = false;
271  			for (Sci_PositionU cPos = end; cPos <= end + 200; cPos++) {
272  				const char ch = styler.SafeGetCharAt(cPos, '\0');
273  				if (ch == '\0' || ch == '>')
274  					break;
275  				else if (ch == '/' && styler.SafeGetCharAt(cPos + 1, '\0') == '>') {
276  					isSelfClose = true;
277  					break;
278  				}
279  			}
280  			if (!isSelfClose)
281  				chAttr = SCE_H_SCRIPT;
282  		} else if (!isXml && (tag == "comment")) {
283  			chAttr = SCE_H_COMMENT;
284  		}
285  	}
286  	return chAttr;
287  }
288  void classifyWordHTJS(Sci_PositionU start, Sci_PositionU end,
289                               const WordList &keywords, Accessor &styler, script_mode inScriptType) {
290  	char s[30 + 1];
291  	Sci_PositionU i = 0;
292  	for (; i < end - start + 1 && i < 30; i++) {
293  		s[i] = styler[start + i];
294  	}
295  	s[i] = '\0';
296  	char chAttr = SCE_HJ_WORD;
297  	const bool wordIsNumber = IsADigit(s[0]) || ((s[0] == '.') && IsADigit(s[1]));
298  	if (wordIsNumber) {
299  		chAttr = SCE_HJ_NUMBER;
300  	} else if (keywords.InList(s)) {
301  		chAttr = SCE_HJ_KEYWORD;
302  	}
303  	styler.ColourTo(end, statePrintForState(chAttr, inScriptType));
304  }
305  int classifyWordHTVB(Sci_PositionU start, Sci_PositionU end, const WordList &keywords, Accessor &styler, script_mode inScriptType) {
306  	char chAttr = SCE_HB_IDENTIFIER;
307  	const bool wordIsNumber = IsADigit(styler[start]) || (styler[start] == '.');
308  	if (wordIsNumber) {
309  		chAttr = SCE_HB_NUMBER;
310  	} else {
311  		std::string s = GetStringSegment(styler, start, end);
312  		if (keywords.InList(s.c_str())) {
313  			chAttr = SCE_HB_WORD;
314  			if (s == "rem")
315  				chAttr = SCE_HB_COMMENTLINE;
316  		}
317  	}
318  	styler.ColourTo(end, statePrintForState(chAttr, inScriptType));
319  	if (chAttr == SCE_HB_COMMENTLINE)
320  		return SCE_HB_COMMENTLINE;
321  	else
322  		return SCE_HB_DEFAULT;
323  }
324  void classifyWordHTPy(Sci_PositionU start, Sci_PositionU end, const WordList &keywords, Accessor &styler, std::string &prevWord, script_mode inScriptType, bool isMako) {
325  	const bool wordIsNumber = IsADigit(styler[start]);
326  	std::string s;
327  	for (Sci_PositionU i = 0; i < end - start + 1 && i < 30; i++) {
328  		s.push_back(styler[start + i]);
329  	}
330  	char chAttr = SCE_HP_IDENTIFIER;
331  	if (prevWord == "class")
332  		chAttr = SCE_HP_CLASSNAME;
333  	else if (prevWord == "def")
334  		chAttr = SCE_HP_DEFNAME;
335  	else if (wordIsNumber)
336  		chAttr = SCE_HP_NUMBER;
337  	else if (keywords.InList(s.c_str()))
338  		chAttr = SCE_HP_WORD;
339  	else if (isMako && (s == "block"))
340  		chAttr = SCE_HP_WORD;
341  	styler.ColourTo(end, statePrintForState(chAttr, inScriptType));
342  	prevWord = s;
343  }
344  void classifyWordHTPHP(Sci_PositionU start, Sci_PositionU end, const WordList &keywords, Accessor &styler) {
345  	char chAttr = SCE_HPHP_DEFAULT;
346  	const bool wordIsNumber = IsADigit(styler[start]) || (styler[start] == '.' && start+1 <= end && IsADigit(styler[start+1]));
347  	if (wordIsNumber) {
348  		chAttr = SCE_HPHP_NUMBER;
349  	} else {
350  		std::string s = GetStringSegment(styler, start, end);
351  		if (keywords.InList(s.c_str()))
352  			chAttr = SCE_HPHP_WORD;
353  	}
354  	styler.ColourTo(end, chAttr);
355  }
356  bool isWordHSGML(Sci_PositionU start, Sci_PositionU end, const WordList &keywords, Accessor &styler) {
357  	std::string s;
358  	for (Sci_PositionU i = 0; i < end - start + 1 && i < 30; i++) {
359  		s.push_back(styler[start + i]);
360  	}
361  	return keywords.InList(s.c_str());
362  }
363  bool isWordCdata(Sci_PositionU start, Sci_PositionU end, Accessor &styler) {
364  	std::string s;
365  	for (Sci_PositionU i = 0; i < end - start + 1 && i < 30; i++) {
366  		s.push_back(styler[start + i]);
367  	}
368  	return s == "[CDATA[";
369  }
370  int StateForScript(script_type scriptLanguage) {
371  	int Result;
372  	switch (scriptLanguage) {
373  	case eScriptVBS:
374  		Result = SCE_HB_START;
375  		break;
376  	case eScriptPython:
377  		Result = SCE_HP_START;
378  		break;
379  	case eScriptPHP:
380  		Result = SCE_HPHP_DEFAULT;
381  		break;
382  	case eScriptXML:
383  		Result = SCE_H_TAGUNKNOWN;
384  		break;
385  	case eScriptSGML:
386  		Result = SCE_H_SGML_DEFAULT;
387  		break;
388  	case eScriptComment:
389  		Result = SCE_H_COMMENT;
390  		break;
391  	default :
392  		Result = SCE_HJ_START;
393  		break;
394  	}
395  	return Result;
396  }
397  inline bool issgmlwordchar(int ch) {
398  	return !IsASCII(ch) ||
399  		(isalnum(ch) || ch == '.' || ch == '_' || ch == ':' || ch == '!' || ch == '#' || ch == '[');
400  }
401  inline bool IsPhpWordStart(int ch) {
402  	return (IsASCII(ch) && (isalpha(ch) || (ch == '_'))) || (ch >= 0x7f);
403  }
404  inline bool IsPhpWordChar(int ch) {
405  	return IsADigit(ch) || IsPhpWordStart(ch);
406  }
407  bool InTagState(int state) {
408  	return state == SCE_H_TAG || state == SCE_H_TAGUNKNOWN ||
409  	       state == SCE_H_SCRIPT ||
410  	       state == SCE_H_ATTRIBUTE || state == SCE_H_ATTRIBUTEUNKNOWN ||
411  	       state == SCE_H_NUMBER || state == SCE_H_OTHER ||
412  	       state == SCE_H_DOUBLESTRING || state == SCE_H_SINGLESTRING;
413  }
414  bool IsCommentState(const int state) {
415  	return state == SCE_H_COMMENT || state == SCE_H_SGML_COMMENT;
416  }
417  bool IsScriptCommentState(const int state) {
418  	return state == SCE_HJ_COMMENT || state == SCE_HJ_COMMENTLINE || state == SCE_HJA_COMMENT ||
419  		   state == SCE_HJA_COMMENTLINE || state == SCE_HB_COMMENTLINE || state == SCE_HBA_COMMENTLINE;
420  }
421  bool isLineEnd(int ch) {
422  	return ch == '\r' || ch == '\n';
423  }
424  bool isMakoBlockEnd(const int ch, const int chNext, const std::string &blockType) {
425  	if (blockType.empty()) {
426  		return ((ch == '%') && (chNext == '>'));
427  	} else if ((blockType == "inherit") ||
428  			   (blockType == "namespace") ||
429  			   (blockType == "include") ||
430  			   (blockType == "page")) {
431  		return ((ch == '/') && (chNext == '>'));
432  	} else if (blockType == "%") {
433  		if (ch == '/' && isLineEnd(chNext))
434  			return true;
435  		else
436  			return isLineEnd(ch);
437  	} else if (blockType == "{") {
438  		return ch == '}';
439  	} else {
440  		return (ch == '>');
441  	}
442  }
443  bool isDjangoBlockEnd(const int ch, const int chNext, const std::string &blockType) {
444  	if (blockType.empty()) {
445  		return false;
446  	} else if (blockType == "%") {
447  		return ((ch == '%') && (chNext == '}'));
448  	} else if (blockType == "{") {
449  		return ((ch == '}') && (chNext == '}'));
450  	} else {
451  		return false;
452  	}
453  }
454  class PhpNumberState {
455  	enum NumberBase { BASE_10 = 0, BASE_2, BASE_8, BASE_16 };
456  	static constexpr const char *const digitList[] = { "_0123456789", "_01", "_01234567", "_0123456789abcdefABCDEF" };
457  	NumberBase base = BASE_10;
458  	bool decimalPart = false;
459  	bool exponentPart = false;
460  	bool invalid = false;
461  	bool finished = false;
462  	bool leadingZero = false;
463  	bool invalidBase8 = false;
464  	bool betweenDigits = false;
465  	bool decimalChar = false;
466  	bool exponentChar = false;
467  public:
468  	inline bool isInvalid() { return invalid; }
469  	inline bool isFinished() { return finished; }
470  	bool init(int ch, int chPlus1, int chPlus2) {
471  		base = BASE_10;
472  		decimalPart = false;
473  		exponentPart = false;
474  		invalid = false;
475  		finished = false;
476  		leadingZero = false;
477  		invalidBase8 = false;
478  		betweenDigits = false;
479  		decimalChar = false;
480  		exponentChar = false;
481  		if (ch == '.' && strchr(digitList[BASE_10] + !betweenDigits, chPlus1) != nullptr) {
482  			decimalPart = true;
483  			betweenDigits = true;
484  		} else if (ch == '0' && (chPlus1 == 'b' || chPlus1 == 'B')) {
485  			base = BASE_2;
486  		} else if (ch == '0' && (chPlus1 == 'o' || chPlus1 == 'O')) {
487  			base = BASE_8;
488  		} else if (ch == '0' && (chPlus1 == 'x' || chPlus1 == 'X')) {
489  			base = BASE_16;
490  		} else if (strchr(digitList[BASE_10] + !betweenDigits, ch) != nullptr) {
491  			leadingZero = ch == '0';
492  			betweenDigits = true;
493  			check(chPlus1, chPlus2);
494  			if (finished && leadingZero) {
495  				base = BASE_10;
496  			}
497  		} else {
498  			return false;
499  		}
500  		return true;
501  	}
502  	bool check(int ch, int chPlus1) {
503  		if (strchr(digitList[base] + !betweenDigits, ch) != nullptr) {
504  			if (leadingZero) {
505  				invalidBase8 = invalidBase8 || strchr(digitList[BASE_8] + !betweenDigits, ch) == nullptr;
506  			}
507  			betweenDigits = ch != '_';
508  			decimalChar = false;
509  			exponentChar = false;
510  		} else if (ch == '_') {
511  			invalid = true;
512  			betweenDigits = false;
513  			decimalChar = false;
514  		} else if (base == BASE_10 && ch == '.' && (
515  					!(decimalPart || exponentPart) || strchr(digitList[BASE_10] + !betweenDigits, chPlus1) != nullptr)
516  			  ) {
517  			invalid = invalid || !betweenDigits || decimalPart || exponentPart;
518  			decimalPart = true;
519  			betweenDigits = false;
520  			decimalChar = true;
521  			exponentChar = false;
522  		} else if (base == BASE_10 && (ch == 'e' || ch == 'E')) {
523  			invalid = invalid || !(betweenDigits || decimalChar) || exponentPart;
524  			exponentPart = true;
525  			betweenDigits = false;
526  			decimalChar = false;
527  			exponentChar = true;
528  		} else if (base == BASE_10 && (ch == '-' || ch == '+') && exponentChar) {
529  			invalid = invalid || strchr(digitList[BASE_10] + !betweenDigits, chPlus1) == nullptr;
530  			betweenDigits = false;
531  			decimalChar = false;
532  		} else if (IsPhpWordChar(ch)) {
533  			invalid = true;
534  			betweenDigits = false;
535  			decimalChar = false;
536  			exponentChar = false;
537  		} else {
538  			invalid = invalid || !(betweenDigits || decimalChar);
539  			finished = true;
540  			if (base == BASE_10 && leadingZero && !decimalPart && !exponentPart) {
541  				base = BASE_8;
542  				invalid = invalid || invalidBase8;
543  			}
544  		}
545  		return finished;
546  	}
547  };
548  bool isPHPStringState(int state) {
549  	return
550  	    (state == SCE_HPHP_HSTRING) ||
551  	    (state == SCE_HPHP_SIMPLESTRING) ||
552  	    (state == SCE_HPHP_HSTRING_VARIABLE) ||
553  	    (state == SCE_HPHP_COMPLEX_VARIABLE);
554  }
555  Sci_Position FindPhpStringDelimiter(std::string &phpStringDelimiter, Sci_Position i, const Sci_Position lengthDoc, Accessor &styler, bool &isSimpleString) {
556  	Sci_Position j;
557  	const Sci_Position beginning = i - 1;
558  	bool isQuoted = false;
559  	while (i < lengthDoc && (styler[i] == ' ' || styler[i] == '\t'))
560  		i++;
561  	char ch = styler.SafeGetCharAt(i);
562  	const char chNext = styler.SafeGetCharAt(i + 1);
563  	phpStringDelimiter.clear();
564  	if (!IsPhpWordStart(ch)) {
565  		if ((ch == '\'' || ch == '\"') && IsPhpWordStart(chNext)) {
566  			isSimpleString = ch == '\'';
567  			isQuoted = true;
568  			i++;
569  			ch = chNext;
570  		} else {
571  			return beginning;
572  		}
573  	}
574  	phpStringDelimiter.push_back(ch);
575  	i++;
576  	for (j = i; j < lengthDoc && !isLineEnd(styler[j]); j++) {
577  		if (!IsPhpWordChar(styler[j]) && isQuoted) {
578  			if (((isSimpleString && styler[j] == '\'') || (!isSimpleString && styler[j] == '\"')) && isLineEnd(styler.SafeGetCharAt(j + 1))) {
579  				isQuoted = false;
580  				j++;
581  				break;
582  			} else {
583  				phpStringDelimiter.clear();
584  				return beginning;
585  			}
586  		}
587  		phpStringDelimiter.push_back(styler[j]);
588  	}
589  	if (isQuoted) {
590  		phpStringDelimiter.clear();
591  		return beginning;
592  	}
593  	return j - 1;
594  }
595  struct OptionsHTML {
596  	int aspDefaultLanguage = eScriptJS;
597  	bool caseSensitive = false;
598  	bool allowScripts = true;
599  	bool isMako = false;
600  	bool isDjango = false;
601  	bool fold = false;
602  	bool foldHTML = false;
603  	bool foldHTMLPreprocessor = true;
604  	bool foldCompact = true;
605  	bool foldComment = false;
606  	bool foldHeredoc = false;
607  	bool foldXmlAtTagOpen = false;
608  	OptionsHTML() noexcept {
609  	}
610  };
611  const char * const htmlWordListDesc[] = {
612  	"HTML elements and attributes",
613  	"JavaScript keywords",
614  	"VBScript keywords",
615  	"Python keywords",
616  	"PHP keywords",
617  	"SGML and DTD keywords",
618  	0,
619  };
620  const char * const phpscriptWordListDesc[] = {
621  	"", 
622  	"", 
623  	"", 
624  	"", 
625  	"PHP keywords",
626  	"", 
627  	0,
628  };
629  struct OptionSetHTML : public OptionSet<OptionsHTML> {
630  	OptionSetHTML(bool isPHPScript_) {
631  		DefineProperty("asp.default.language", &OptionsHTML::aspDefaultLanguage,
632  			"Script in ASP code is initially assumed to be in JavaScript. "
633  			"To change this to VBScript set asp.default.language to 2. Python is 3.");
634  		DefineProperty("html.tags.case.sensitive", &OptionsHTML::caseSensitive,
635  			"For XML and HTML, setting this property to 1 will make tags match in a case "
636  			"sensitive way which is the expected behaviour for XML and XHTML.");
637  		DefineProperty("lexer.xml.allow.scripts", &OptionsHTML::allowScripts,
638  			"Set to 0 to disable scripts in XML.");
639  		DefineProperty("lexer.html.mako", &OptionsHTML::isMako,
640  			"Set to 1 to enable the mako template language.");
641  		DefineProperty("lexer.html.django", &OptionsHTML::isDjango,
642  			"Set to 1 to enable the django template language.");
643  		DefineProperty("fold", &OptionsHTML::fold);
644  		DefineProperty("fold.html", &OptionsHTML::foldHTML,
645  			"Folding is turned on or off for HTML and XML files with this option. "
646  			"The fold option must also be on for folding to occur.");
647  		DefineProperty("fold.html.preprocessor", &OptionsHTML::foldHTMLPreprocessor,
648  			"Folding is turned on or off for scripts embedded in HTML files with this option. "
649  			"The default is on.");
650  		DefineProperty("fold.compact", &OptionsHTML::foldCompact);
651  		DefineProperty("fold.hypertext.comment", &OptionsHTML::foldComment,
652  			"Allow folding for comments in scripts embedded in HTML. "
653  			"The default is off.");
654  		DefineProperty("fold.hypertext.heredoc", &OptionsHTML::foldHeredoc,
655  			"Allow folding for heredocs in scripts embedded in HTML. "
656  			"The default is off.");
657  		DefineProperty("fold.xml.at.tag.open", &OptionsHTML::foldXmlAtTagOpen,
658  			"Enable folding for XML at the start of open tag. "
659  			"The default is off.");
660  		DefineWordListSets(isPHPScript_ ? phpscriptWordListDesc : htmlWordListDesc);
661  	}
662  };
663  LexicalClass lexicalClassesHTML[] = {
664  	0, "SCE_H_DEFAULT", "default", "Text",
665  	1, "SCE_H_TAG", "tag", "Tags",
666  	2, "SCE_H_ERRORTAGUNKNOWN", "error tag", "Unknown Tags",
667  	3, "SCE_H_ATTRIBUTE", "attribute", "Attributes",
668  	4, "SCE_H_ATTRIBUTEUNKNOWN", "error attribute", "Unknown Attributes",
669  	5, "SCE_H_NUMBER", "literal numeric", "Numbers",
670  	6, "SCE_H_DOUBLESTRING", "literal string", "Double quoted strings",
671  	7, "SCE_H_SINGLESTRING", "literal string", "Single quoted strings",
672  	8, "SCE_H_OTHER", "tag operator", "Other inside tag, including space and '='",
673  	9, "SCE_H_COMMENT", "comment", "Comment",
674  	10, "SCE_H_ENTITY", "literal", "Entities",
675  	11, "SCE_H_TAGEND", "tag", "XML style tag ends '/>'",
676  	12, "SCE_H_XMLSTART", "identifier", "XML identifier start '<?'",
677  	13, "SCE_H_XMLEND", "identifier", "XML identifier end '?>'",
678  	14, "SCE_H_SCRIPT", "error", "Internal state which should never be visible",
679  	15, "SCE_H_ASP", "preprocessor", "ASP <% ... %>",
680  	16, "SCE_H_ASPAT", "preprocessor", "ASP <% ... %>",
681  	17, "SCE_H_CDATA", "literal", "CDATA",
682  	18, "SCE_H_QUESTION", "preprocessor", "PHP",
683  	19, "SCE_H_VALUE", "literal string", "Unquoted values",
684  	20, "SCE_H_XCCOMMENT", "comment", "JSP Comment <%-- ... --%>",
685  	21, "SCE_H_SGML_DEFAULT", "default", "SGML tags <! ... >",
686  	22, "SCE_H_SGML_COMMAND", "preprocessor", "SGML command",
687  	23, "SCE_H_SGML_1ST_PARAM", "preprocessor", "SGML 1st param",
688  	24, "SCE_H_SGML_DOUBLESTRING", "literal string", "SGML double string",
689  	25, "SCE_H_SGML_SIMPLESTRING", "literal string", "SGML single string",
690  	26, "SCE_H_SGML_ERROR", "error", "SGML error",
691  	27, "SCE_H_SGML_SPECIAL", "literal", "SGML special (#XXXX type)",
692  	28, "SCE_H_SGML_ENTITY", "literal", "SGML entity",
693  	29, "SCE_H_SGML_COMMENT", "comment", "SGML comment",
694  	30, "SCE_H_SGML_1ST_PARAM_COMMENT", "error comment", "SGML first parameter - lexer internal. It is an error if any text is in this style.",
695  	31, "SCE_H_SGML_BLOCK_DEFAULT", "default", "SGML block",
696  	32, "", "predefined", "",
697  	33, "", "predefined", "",
698  	34, "", "predefined", "",
699  	35, "", "predefined", "",
700  	36, "", "predefined", "",
701  	37, "", "predefined", "",
702  	38, "", "predefined", "",
703  	39, "", "predefined", "",
704  	40, "SCE_HJ_START", "client javascript default", "JS Start - allows eol filled background to not start on same line as SCRIPT tag",
705  	41, "SCE_HJ_DEFAULT", "client javascript default", "JS Default",
706  	42, "SCE_HJ_COMMENT", "client javascript comment", "JS Comment",
707  	43, "SCE_HJ_COMMENTLINE", "client javascript comment line", "JS Line Comment",
708  	44, "SCE_HJ_COMMENTDOC", "client javascript comment documentation", "JS Doc comment",
709  	45, "SCE_HJ_NUMBER", "client javascript literal numeric", "JS Number",
710  	46, "SCE_HJ_WORD", "client javascript identifier", "JS Word",
711  	47, "SCE_HJ_KEYWORD", "client javascript keyword", "JS Keyword",
712  	48, "SCE_HJ_DOUBLESTRING", "client javascript literal string", "JS Double quoted string",
713  	49, "SCE_HJ_SINGLESTRING", "client javascript literal string", "JS Single quoted string",
714  	50, "SCE_HJ_SYMBOLS", "client javascript operator", "JS Symbols",
715  	51, "SCE_HJ_STRINGEOL", "client javascript error literal string", "JavaScript EOL",
716  	52, "SCE_HJ_REGEX", "client javascript literal regex", "JavaScript RegEx",
717  	53, "", "unused", "",
718  	54, "", "unused", "",
719  	55, "SCE_HJA_START", "server javascript default", "JS Start - allows eol filled background to not start on same line as SCRIPT tag",
720  	56, "SCE_HJA_DEFAULT", "server javascript default", "JS Default",
721  	57, "SCE_HJA_COMMENT", "server javascript comment", "JS Comment",
722  	58, "SCE_HJA_COMMENTLINE", "server javascript comment line", "JS Line Comment",
723  	59, "SCE_HJA_COMMENTDOC", "server javascript comment documentation", "JS Doc comment",
724  	60, "SCE_HJA_NUMBER", "server javascript literal numeric", "JS Number",
725  	61, "SCE_HJA_WORD", "server javascript identifier", "JS Word",
726  	62, "SCE_HJA_KEYWORD", "server javascript keyword", "JS Keyword",
727  	63, "SCE_HJA_DOUBLESTRING", "server javascript literal string", "JS Double quoted string",
728  	64, "SCE_HJA_SINGLESTRING", "server javascript literal string", "JS Single quoted string",
729  	65, "SCE_HJA_SYMBOLS", "server javascript operator", "JS Symbols",
730  	66, "SCE_HJA_STRINGEOL", "server javascript error literal string", "JavaScript EOL",
731  	67, "SCE_HJA_REGEX", "server javascript literal regex", "JavaScript RegEx",
732  	68, "", "unused", "",
733  	69, "", "unused", "",
734  	70, "SCE_HB_START", "client basic default", "Start",
735  	71, "SCE_HB_DEFAULT", "client basic default", "Default",
736  	72, "SCE_HB_COMMENTLINE", "client basic comment line", "Comment",
737  	73, "SCE_HB_NUMBER", "client basic literal numeric", "Number",
738  	74, "SCE_HB_WORD", "client basic keyword", "KeyWord",
739  	75, "SCE_HB_STRING", "client basic literal string", "String",
740  	76, "SCE_HB_IDENTIFIER", "client basic identifier", "Identifier",
741  	77, "SCE_HB_STRINGEOL", "client basic literal string", "Unterminated string",
742  	78, "", "unused", "",
743  	79, "", "unused", "",
744  	80, "SCE_HBA_START", "server basic default", "Start",
745  	81, "SCE_HBA_DEFAULT", "server basic default", "Default",
746  	82, "SCE_HBA_COMMENTLINE", "server basic comment line", "Comment",
747  	83, "SCE_HBA_NUMBER", "server basic literal numeric", "Number",
748  	84, "SCE_HBA_WORD", "server basic keyword", "KeyWord",
749  	85, "SCE_HBA_STRING", "server basic literal string", "String",
750  	86, "SCE_HBA_IDENTIFIER", "server basic identifier", "Identifier",
751  	87, "SCE_HBA_STRINGEOL", "server basic literal string", "Unterminated string",
752  	88, "", "unused", "",
753  	89, "", "unused", "",
754  	90, "SCE_HP_START", "client python default", "Embedded Python",
755  	91, "SCE_HP_DEFAULT", "client python default", "Embedded Python",
756  	92, "SCE_HP_COMMENTLINE", "client python comment line", "Comment",
757  	93, "SCE_HP_NUMBER", "client python literal numeric", "Number",
758  	94, "SCE_HP_STRING", "client python literal string", "String",
759  	95, "SCE_HP_CHARACTER", "client python literal string character", "Single quoted string",
760  	96, "SCE_HP_WORD", "client python keyword", "Keyword",
761  	97, "SCE_HP_TRIPLE", "client python literal string", "Triple quotes",
762  	98, "SCE_HP_TRIPLEDOUBLE", "client python literal string", "Triple double quotes",
763  	99, "SCE_HP_CLASSNAME", "client python identifier", "Class name definition",
764  	100, "SCE_HP_DEFNAME", "client python identifier", "Function or method name definition",
765  	101, "SCE_HP_OPERATOR", "client python operator", "Operators",
766  	102, "SCE_HP_IDENTIFIER", "client python identifier", "Identifiers",
767  	103, "", "unused", "",
768  	104, "SCE_HPHP_COMPLEX_VARIABLE", "server php identifier", "PHP complex variable",
769  	105, "SCE_HPA_START", "server python default", "ASP Python",
770  	106, "SCE_HPA_DEFAULT", "server python default", "ASP Python",
771  	107, "SCE_HPA_COMMENTLINE", "server python comment line", "Comment",
772  	108, "SCE_HPA_NUMBER", "server python literal numeric", "Number",
773  	109, "SCE_HPA_STRING", "server python literal string", "String",
774  	110, "SCE_HPA_CHARACTER", "server python literal string character", "Single quoted string",
775  	111, "SCE_HPA_WORD", "server python keyword", "Keyword",
776  	112, "SCE_HPA_TRIPLE", "server python literal string", "Triple quotes",
777  	113, "SCE_HPA_TRIPLEDOUBLE", "server python literal string", "Triple double quotes",
778  	114, "SCE_HPA_CLASSNAME", "server python identifier", "Class name definition",
779  	115, "SCE_HPA_DEFNAME", "server python identifier", "Function or method name definition",
780  	116, "SCE_HPA_OPERATOR", "server python operator", "Operators",
781  	117, "SCE_HPA_IDENTIFIER", "server python identifier", "Identifiers",
782  	118, "SCE_HPHP_DEFAULT", "server php default", "Default",
783  	119, "SCE_HPHP_HSTRING", "server php literal string", "Double quoted String",
784  	120, "SCE_HPHP_SIMPLESTRING", "server php literal string", "Single quoted string",
785  	121, "SCE_HPHP_WORD", "server php keyword", "Keyword",
786  	122, "SCE_HPHP_NUMBER", "server php literal numeric", "Number",
787  	123, "SCE_HPHP_VARIABLE", "server php identifier", "Variable",
788  	124, "SCE_HPHP_COMMENT", "server php comment", "Comment",
789  	125, "SCE_HPHP_COMMENTLINE", "server php comment line", "One line comment",
790  	126, "SCE_HPHP_HSTRING_VARIABLE", "server php literal string identifier", "PHP variable in double quoted string",
791  	127, "SCE_HPHP_OPERATOR", "server php operator", "PHP operator",
792  };
793  LexicalClass lexicalClassesXML[] = {
794  	0, "SCE_H_DEFAULT", "default", "Default",
795  	1, "SCE_H_TAG", "tag", "Tags",
796  	2, "SCE_H_TAGUNKNOWN", "error tag", "Unknown Tags",
797  	3, "SCE_H_ATTRIBUTE", "attribute", "Attributes",
798  	4, "SCE_H_ERRORATTRIBUTEUNKNOWN", "error attribute", "Unknown Attributes",
799  	5, "SCE_H_NUMBER", "literal numeric", "Numbers",
800  	6, "SCE_H_DOUBLESTRING", "literal string", "Double quoted strings",
801  	7, "SCE_H_SINGLESTRING", "literal string", "Single quoted strings",
802  	8, "SCE_H_OTHER", "tag operator", "Other inside tag, including space and '='",
803  	9, "SCE_H_COMMENT", "comment", "Comment",
804  	10, "SCE_H_ENTITY", "literal", "Entities",
805  	11, "SCE_H_TAGEND", "tag", "XML style tag ends '/>'",
806  	12, "SCE_H_XMLSTART", "identifier", "XML identifier start '<?'",
807  	13, "SCE_H_XMLEND", "identifier", "XML identifier end '?>'",
808  	14, "", "unused", "",
809  	15, "", "unused", "",
810  	16, "", "unused", "",
811  	17, "SCE_H_CDATA", "literal", "CDATA",
812  	18, "SCE_H_QUESTION", "preprocessor", "Question",
813  	19, "SCE_H_VALUE", "literal string", "Unquoted Value",
814  	20, "", "unused", "",
815  	21, "SCE_H_SGML_DEFAULT", "default", "SGML tags <! ... >",
816  	22, "SCE_H_SGML_COMMAND", "preprocessor", "SGML command",
817  	23, "SCE_H_SGML_1ST_PARAM", "preprocessor", "SGML 1st param",
818  	24, "SCE_H_SGML_DOUBLESTRING", "literal string", "SGML double string",
819  	25, "SCE_H_SGML_SIMPLESTRING", "literal string", "SGML single string",
820  	26, "SCE_H_SGML_ERROR", "error", "SGML error",
821  	27, "SCE_H_SGML_SPECIAL", "literal", "SGML special (#XXXX type)",
822  	28, "SCE_H_SGML_ENTITY", "literal", "SGML entity",
823  	29, "SCE_H_SGML_COMMENT", "comment", "SGML comment",
824  	30, "", "unused", "",
825  	31, "SCE_H_SGML_BLOCK_DEFAULT", "default", "SGML block",
826  };
827  const char *tagsThatDoNotFold[] = {
828  	"area",
829  	"base",
830  	"basefont",
831  	"br",
832  	"col",
833  	"command",
834  	"embed",
835  	"frame",
836  	"hr",
837  	"img",
838  	"input",
839  	"isindex",
840  	"keygen",
841  	"link",
842  	"meta",
843  	"param",
844  	"source",
845  	"track",
846  	"wbr"
847  };
848  }
849  class LexerHTML : public DefaultLexer {
850  	bool isXml;
851  	bool isPHPScript;
852  	WordList keywords;
853  	WordList keywords2;
854  	WordList keywords3;
855  	WordList keywords4;
856  	WordList keywords5;
857  	WordList keywords6; 
858  	OptionsHTML options;
859  	OptionSetHTML osHTML;
860  	std::set<std::string> nonFoldingTags;
861  public:
862  	explicit LexerHTML(bool isXml_, bool isPHPScript_) :
863  		DefaultLexer(
864  			isXml_ ? "xml" : (isPHPScript_ ? "phpscript" : "hypertext"),
865  			isXml_ ? SCLEX_XML : (isPHPScript_ ? SCLEX_PHPSCRIPT : SCLEX_HTML),
866  			isXml_ ?  lexicalClassesXML : lexicalClassesHTML,
867  			isXml_ ?  std::size(lexicalClassesXML) : std::size(lexicalClassesHTML)),
868  		isXml(isXml_),
869  		isPHPScript(isPHPScript_),
870  		osHTML(isPHPScript_),
871  		nonFoldingTags(std::begin(tagsThatDoNotFold), std::end(tagsThatDoNotFold)) {
872  	}
873  	~LexerHTML() override {
874  	}
875  	void SCI_METHOD Release() override {
876  		delete this;
877  	}
878  	const char *SCI_METHOD PropertyNames() override {
879  		return osHTML.PropertyNames();
880  	}
881  	int SCI_METHOD PropertyType(const char *name) override {
882  		return osHTML.PropertyType(name);
883  	}
884  	const char *SCI_METHOD DescribeProperty(const char *name) override {
885  		return osHTML.DescribeProperty(name);
886  	}
887  	Sci_Position SCI_METHOD PropertySet(const char *key, const char *val) override;
888  	const char * SCI_METHOD PropertyGet(const char *key) override {
889  		return osHTML.PropertyGet(key);
890  	}
891  	const char *SCI_METHOD DescribeWordListSets() override {
892  		return osHTML.DescribeWordListSets();
893  	}
894  	Sci_Position SCI_METHOD WordListSet(int n, const char *wl) override;
895  	void SCI_METHOD Lex(Sci_PositionU startPos, Sci_Position length, int initStyle, IDocument *pAccess) override;
896  	static ILexer5 *LexerFactoryHTML() {
897  		return new LexerHTML(false, false);
898  	}
899  	static ILexer5 *LexerFactoryXML() {
900  		return new LexerHTML(true, false);
901  	}
902  	static ILexer5 *LexerFactoryPHPScript() {
903  		return new LexerHTML(false, true);
904  	}
905  };
906  Sci_Position SCI_METHOD LexerHTML::PropertySet(const char *key, const char *val) {
907  	if (osHTML.PropertySet(&options, key, val)) {
908  		return 0;
909  	}
910  	return -1;
911  }
912  Sci_Position SCI_METHOD LexerHTML::WordListSet(int n, const char *wl) {
913  	WordList *wordListN = 0;
914  	switch (n) {
915  	case 0:
916  		wordListN = &keywords;
917  		break;
918  	case 1:
919  		wordListN = &keywords2;
920  		break;
921  	case 2:
922  		wordListN = &keywords3;
923  		break;
924  	case 3:
925  		wordListN = &keywords4;
926  		break;
927  	case 4:
928  		wordListN = &keywords5;
929  		break;
930  	case 5:
931  		wordListN = &keywords6;
932  		break;
933  	}
934  	Sci_Position firstModification = -1;
935  	if (wordListN) {
936  		if (wordListN->Set(wl)) {
937  			firstModification = 0;
938  		}
939  	}
940  	return firstModification;
941  }
942  void SCI_METHOD LexerHTML::Lex(Sci_PositionU startPos, Sci_Position length, int initStyle, IDocument *pAccess) {
943  	Accessor styler(pAccess, nullptr);
944  	if (isPHPScript && (startPos == 0)) {
945  		initStyle = SCE_HPHP_DEFAULT;
946  	}
947  	styler.StartAt(startPos);
948  	std::string prevWord;
949  	PhpNumberState phpNumber;
950  	std::string phpStringDelimiter;
951  	int StateToPrint = initStyle;
952  	int state = stateForPrintState(StateToPrint);
953  	std::string makoBlockType;
954  	int makoComment = 0;
955  	std::string djangoBlockType;
956  	if (InTagState(state)) {
957  		while ((startPos > 0) && (InTagState(styler.StyleAt(startPos - 1)))) {
958  			const Sci_Position backLineStart = styler.LineStart(styler.GetLine(startPos-1));
959  			length += startPos - backLineStart;
960  			startPos = backLineStart;
961  		}
962  		state = SCE_H_DEFAULT;
963  	}
964  	if (isPHPStringState(state)) {
965  		while (startPos > 0 && (isPHPStringState(state) || !isLineEnd(styler[startPos - 1]))) {
966  			startPos--;
967  			length++;
968  			state = styler.StyleAt(startPos);
969  		}
970  		if (startPos == 0)
971  			state = SCE_H_DEFAULT;
972  	}
973  	styler.StartAt(startPos);
974  	switch (state) {
975  		case SCE_H_QUESTION:
976  		case SCE_H_XMLSTART:
977  		case SCE_H_XMLEND:
978  		case SCE_H_ASP:
979  			state = SCE_H_DEFAULT;
980  			break;
981  	}
982  	Sci_Position lineCurrent = styler.GetLine(startPos);
983  	int lineState;
984  	if (lineCurrent > 0) {
985  		lineState = styler.GetLineState(lineCurrent-1);
986  	} else {
987  		lineState = eScriptJS << 8;
988  		lineState |= options.aspDefaultLanguage << 4;
989  	}
990  	script_mode inScriptType = static_cast<script_mode>((lineState >> 0) & 0x03); 
991  	bool tagOpened = (lineState >> 2) & 0x01; 
992  	bool tagClosing = (lineState >> 3) & 0x01; 
993  	bool tagDontFold = false; 
994  	script_type aspScript = static_cast<script_type>((lineState >> 4) & 0x0F); 
995  	script_type clientScript = static_cast<script_type>((lineState >> 8) & 0x0F); 
996  	int beforePreProc = (lineState >> 12) & 0xFF; 
997  	bool isLanguageType = (lineState >> 20) & 1; 
998  	script_type scriptLanguage = ScriptOfState(state);
999  	if (inScriptType == eNonHtmlScript && state == SCE_H_COMMENT) {
1000  		scriptLanguage = eScriptComment;
1001  	}
1002  	script_type beforeLanguage = ScriptOfState(beforePreProc);
1003  	const bool foldHTML = options.foldHTML;
1004  	const bool fold = foldHTML && options.fold;
1005  	const bool foldHTMLPreprocessor = foldHTML && options.foldHTMLPreprocessor;
1006  	const bool foldCompact = options.foldCompact;
1007  	const bool foldComment = fold && options.foldComment;
1008  	const bool foldHeredoc = fold && options.foldHeredoc;
1009  	const bool foldXmlAtTagOpen = isXml && fold && options.foldXmlAtTagOpen;
1010  	const bool caseSensitive = options.caseSensitive;
1011  	const bool allowScripts = options.allowScripts;
1012  	const bool isMako = options.isMako;
1013  	const bool isDjango = options.isDjango;
1014  	const CharacterSet setHTMLWord(CharacterSet::setAlphaNum, ".-_:!#", true);
1015  	const CharacterSet setTagContinue(CharacterSet::setAlphaNum, ".-_:!#[", true);
1016  	const CharacterSet setAttributeContinue(CharacterSet::setAlphaNum, ".-_:!#/", true);
1017  	const CharacterSet setOKBeforeJSRE(CharacterSet::setNone, "([{=,:;!%^&*|?~");
1018  	int levelPrev = styler.LevelAt(lineCurrent) & SC_FOLDLEVELNUMBERMASK;
1019  	int levelCurrent = levelPrev;
1020  	int visibleChars = 0;
1021  	int lineStartVisibleChars = 0;
1022  	int chPrev = ' ';
1023  	int ch = ' ';
1024  	int chPrevNonWhite = ' ';
1025  	if (scriptLanguage == eScriptJS && startPos > 0) {
1026  		Sci_Position back = startPos;
1027  		int style = 0;
1028  		while (--back) {
1029  			style = styler.StyleAt(back);
1030  			if (style < SCE_HJ_DEFAULT || style > SCE_HJ_COMMENTDOC)
1031  				break;
1032  		}
1033  		if (style == SCE_HJ_SYMBOLS) {
1034  			chPrevNonWhite = static_cast<unsigned char>(styler.SafeGetCharAt(back));
1035  		}
1036  	}
1037  	styler.StartSegment(startPos);
1038  	const Sci_Position lengthDoc = startPos + length;
1039  	for (Sci_Position i = startPos; i < lengthDoc; i++) {
1040  		const int chPrev2 = chPrev;
1041  		chPrev = ch;
1042  		if (!IsASpace(ch) && state != SCE_HJ_COMMENT &&
1043  			state != SCE_HJ_COMMENTLINE && state != SCE_HJ_COMMENTDOC)
1044  			chPrevNonWhite = ch;
1045  		ch = static_cast<unsigned char>(styler[i]);
1046  		int chNext = static_cast<unsigned char>(styler.SafeGetCharAt(i + 1));
1047  		const int chNext2 = static_cast<unsigned char>(styler.SafeGetCharAt(i + 2));
1048  		if (styler.IsLeadByte(static_cast<char>(ch))) {
1049  			chPrev = ' ';
1050  			i += 1;
1051  			continue;
1052  		}
1053  		if ((!IsASpace(ch) || !foldCompact) && fold)
1054  			visibleChars++;
1055  		if (!IsASpace(ch))
1056  			lineStartVisibleChars++;
1057  		StateToPrint = statePrintForState(state, inScriptType);
1058  		if (fold) {
1059  			switch (scriptLanguage) {
1060  			case eScriptJS:
1061  			case eScriptPHP:
1062  				if (!(state == SCE_HPHP_COMMENT || state == SCE_HPHP_COMMENTLINE) &&
1063  				    !(state == SCE_HJ_REGEX || state == SCE_HJ_COMMENT || state == SCE_HJ_COMMENTLINE || state == SCE_HJ_COMMENTDOC) &&
1064  				    !isStringState(state)) {
1065  					if (ch == '#') {
1066  						Sci_Position j = i + 1;
1067  						while ((j < lengthDoc) && IsASpaceOrTab(styler.SafeGetCharAt(j))) {
1068  							j++;
1069  						}
1070  						if (styler.Match(j, "region") || styler.Match(j, "if")) {
1071  							levelCurrent++;
1072  						} else if (styler.Match(j, "end")) {
1073  							levelCurrent--;
1074  						}
1075  					} else if ((ch == '{') || (ch == '}') || (foldComment && (ch == '/') && (chNext == '*'))) {
1076  						levelCurrent += (((ch == '{') || (ch == '/')) ? 1 : -1);
1077  					}
1078  				} else if (((state == SCE_HPHP_COMMENT) || (state == SCE_HJ_COMMENT || state == SCE_HJ_COMMENTDOC)) && foldComment && (ch == '*') && (chNext == '/')) {
1079  					levelCurrent--;
1080  				}
1081  				break;
1082  			case eScriptPython:
1083  				if (state != SCE_HP_COMMENTLINE && !isMako) {
1084  					if ((ch == ':') && ((chNext == '\n') || (chNext == '\r' && chNext2 == '\n'))) {
1085  						levelCurrent++;
1086  					} else if ((ch == '\n') && !((chNext == '\r') && (chNext2 == '\n')) && (chNext != '\n')) {
1087  						int Findlevel = (levelCurrent & ~SC_FOLDLEVELBASE) * 8;
1088  						for (Sci_Position j = 0; Findlevel > 0; j++) {
1089  							const char chTmp = styler.SafeGetCharAt(i + j + 1);
1090  							if (chTmp == '\t') {
1091  								Findlevel -= 8;
1092  							} else if (chTmp == ' ') {
1093  								Findlevel--;
1094  							} else {
1095  								break;
1096  							}
1097  						}
1098  						if (Findlevel > 0) {
1099  							levelCurrent -= Findlevel / 8;
1100  							if (Findlevel % 8)
1101  								levelCurrent--;
1102  						}
1103  					}
1104  				}
1105  				break;
1106  			default:
1107  				break;
1108  			}
1109  		}
1110  		if ((ch == '\r' && chNext != '\n') || (ch == '\n')) {
1111  			if (fold) {
1112  				int lev = levelPrev;
1113  				if (visibleChars == 0)
1114  					lev |= SC_FOLDLEVELWHITEFLAG;
1115  				if ((levelCurrent > levelPrev) && (visibleChars > 0))
1116  					lev |= SC_FOLDLEVELHEADERFLAG;
1117  				styler.SetLevel(lineCurrent, lev);
1118  				visibleChars = 0;
1119  				levelPrev = levelCurrent;
1120  			}
1121  			styler.SetLineState(lineCurrent,
1122  			                    ((inScriptType & 0x03) << 0) |
1123  			                    ((tagOpened ? 1 : 0) << 2) |
1124  			                    ((tagClosing ? 1 : 0) << 3) |
1125  			                    ((aspScript & 0x0F) << 4) |
1126  			                    ((clientScript & 0x0F) << 8) |
1127  			                    ((beforePreProc & 0xFF) << 12) |
1128  			                    ((isLanguageType ? 1 : 0) << 20));
1129  			lineCurrent++;
1130  			lineStartVisibleChars = 0;
1131  		}
1132  		if (isMako && ch == '#' && chNext == '#') {
1133  			makoComment = 1;
1134  			state = SCE_HP_COMMENTLINE;
1135  		}
1136  		else if (isMako && makoComment && (ch == '\r' || ch == '\n')) {
1137  			makoComment = 0;
1138  			styler.ColourTo(i - 1, StateToPrint);
1139  			if (scriptLanguage == eScriptPython) {
1140  				state = SCE_HP_DEFAULT;
1141  			} else {
1142  				state = SCE_H_DEFAULT;
1143  			}
1144  		}
1145  		if (((ch == '\r' && chNext != '\n') || (ch == '\n')) &&
1146  			(!isMako || (makoBlockType != "%"))) {
1147  		}
1148  		else if (isMako && makoComment) {
1149  		}
1150  		else if ((inScriptType == eNonHtmlScript) && (ch == '<') && (chNext == '/')) {
1151  			switch (state) {
1152  			case SCE_H_DOUBLESTRING:
1153  			case SCE_H_SINGLESTRING:
1154  			case SCE_HJ_COMMENT:
1155  			case SCE_HJ_COMMENTDOC:
1156  			case SCE_HB_COMMENTLINE:
1157  			case SCE_HBA_COMMENTLINE:
1158  			case SCE_HJ_DOUBLESTRING:
1159  			case SCE_HJ_SINGLESTRING:
1160  			case SCE_HJ_REGEX:
1161  			case SCE_HB_STRING:
1162  			case SCE_HBA_STRING:
1163  			case SCE_HP_STRING:
1164  			case SCE_HP_TRIPLE:
1165  			case SCE_HP_TRIPLEDOUBLE:
1166  			case SCE_HPHP_HSTRING:
1167  			case SCE_HPHP_SIMPLESTRING:
1168  			case SCE_HPHP_COMMENT:
1169  			case SCE_HPHP_COMMENTLINE:
1170  				break;
1171  			default :
1172  				if (const char *tag =
1173  						state == SCE_HJ_COMMENTLINE || isXml ? "script" :
1174  						state == SCE_H_COMMENT ? "comment" : 0) {
1175  					Sci_Position j = i + 2;
1176  					int chr;
1177  					do {
1178  						chr = static_cast<int>(*tag++);
1179  					} while (chr != 0 && chr == MakeLowerCase(styler.SafeGetCharAt(j++)));
1180  					if (chr != 0) break;
1181  				}
1182  				styler.ColourTo(i - 1, StateToPrint);
1183  				state = SCE_H_TAGUNKNOWN;
1184  				inScriptType = eHtml;
1185  				scriptLanguage = eScriptNone;
1186  				clientScript = eScriptJS;
1187  				isLanguageType = false;
1188  				i += 2;
1189  				visibleChars += 2;
1190  				tagClosing = true;
1191  				if (foldXmlAtTagOpen) {
1192  					levelCurrent--;
1193  				}
1194  				continue;
1195  			}
1196  		}
1197  		else if ((state != SCE_H_ASPAT) &&
1198  		         !isPHPStringState(state) &&
1199  		         (state != SCE_HPHP_COMMENT) &&
1200  		         (state != SCE_HPHP_COMMENTLINE) &&
1201  		         (ch == '<') &&
1202  		         (chNext == '?') &&
1203  				 !IsScriptCommentState(state)) {
1204   			beforeLanguage = scriptLanguage;
1205  			scriptLanguage = segIsScriptingIndicator(styler, i + 2, i + 6, isXml ? eScriptXML : eScriptPHP);
1206  			if ((scriptLanguage != eScriptPHP) && (isStringState(state) || (state==SCE_H_COMMENT))) continue;
1207  			styler.ColourTo(i - 1, StateToPrint);
1208  			beforePreProc = state;
1209  			i++;
1210  			visibleChars++;
1211  			i += PrintScriptingIndicatorOffset(styler, styler.GetStartSegment() + 2, i + 6);
1212  			if (scriptLanguage == eScriptXML)
1213  				styler.ColourTo(i, SCE_H_XMLSTART);
1214  			else
1215  				styler.ColourTo(i, SCE_H_QUESTION);
1216  			state = StateForScript(scriptLanguage);
1217  			if (inScriptType == eNonHtmlScript)
1218  				inScriptType = eNonHtmlScriptPreProc;
1219  			else
1220  				inScriptType = eNonHtmlPreProc;
1221  			if (foldHTMLPreprocessor && (scriptLanguage != eScriptXML)) {
1222  				levelCurrent++;
1223  			}
1224  			ch = static_cast<unsigned char>(styler.SafeGetCharAt(i));
1225  			continue;
1226  		}
1227  		else if (isMako && scriptLanguage == eScriptNone && ((ch == '<' && chNext == '%') ||
1228  															 (lineStartVisibleChars == 1 && ch == '%') ||
1229  															 (lineStartVisibleChars == 1 && ch == '/' && chNext == '%') ||
1230  															 (ch == '$' && chNext == '{') ||
1231  															 (ch == '<' && chNext == '/' && chNext2 == '%'))) {
1232  			if (ch == '%' || ch == '/')
1233  				makoBlockType = "%";
1234  			else if (ch == '$')
1235  				makoBlockType = "{";
1236  			else if (chNext == '/')
1237  				makoBlockType = GetNextWord(styler, i+3);
1238  			else
1239  				makoBlockType = GetNextWord(styler, i+2);
1240  			styler.ColourTo(i - 1, StateToPrint);
1241  			beforePreProc = state;
1242  			if (inScriptType == eNonHtmlScript)
1243  				inScriptType = eNonHtmlScriptPreProc;
1244  			else
1245  				inScriptType = eNonHtmlPreProc;
1246  			if (chNext == '/') {
1247  				i += 2;
1248  				visibleChars += 2;
1249  			} else if (ch != '%') {
1250  				i++;
1251  				visibleChars++;
1252  			}
1253  			state = SCE_HP_START;
1254  			scriptLanguage = eScriptPython;
1255  			styler.ColourTo(i, SCE_H_ASP);
1256  			if (ch != '%' && ch != '$' && ch != '/') {
1257  				i += makoBlockType.length();
1258  				visibleChars += static_cast<int>(makoBlockType.length());
1259  				if (keywords4.InList(makoBlockType.c_str()))
1260  					styler.ColourTo(i, SCE_HP_WORD);
1261  				else
1262  					styler.ColourTo(i, SCE_H_TAGUNKNOWN);
1263  			}
1264  			ch = static_cast<unsigned char>(styler.SafeGetCharAt(i));
1265  			continue;
1266  		}
1267  		else if (isDjango && state != SCE_H_COMMENT && (ch == '{' && chNext == '#')) {
1268  			styler.ColourTo(i - 1, StateToPrint);
1269  			beforePreProc = state;
1270  			beforeLanguage = scriptLanguage;
1271  			if (inScriptType == eNonHtmlScript)
1272  				inScriptType = eNonHtmlScriptPreProc;
1273  			else
1274  				inScriptType = eNonHtmlPreProc;
1275  			i += 1;
1276  			visibleChars += 1;
1277  			scriptLanguage = eScriptComment;
1278  			state = SCE_H_COMMENT;
1279  			styler.ColourTo(i, SCE_H_ASP);
1280  			ch = static_cast<unsigned char>(styler.SafeGetCharAt(i));
1281  			continue;
1282  		} else if (isDjango && state == SCE_H_COMMENT && (ch == '#' && chNext == '}')) {
1283  			styler.ColourTo(i - 1, StateToPrint);
1284  			i += 1;
1285  			visibleChars += 1;
1286  			styler.ColourTo(i, SCE_H_ASP);
1287  			state = beforePreProc;
1288  			if (inScriptType == eNonHtmlScriptPreProc)
1289  				inScriptType = eNonHtmlScript;
1290  			else
1291  				inScriptType = eHtml;
1292  			scriptLanguage = beforeLanguage;
1293  			continue;
1294  		}
1295  		else if (isDjango && scriptLanguage != eScriptPython && scriptLanguage != eScriptComment && (ch == '{' && (chNext == '%' ||  chNext == '{'))) {
1296  			if (chNext == '%')
1297  				djangoBlockType = "%";
1298  			else
1299  				djangoBlockType = "{";
1300  			styler.ColourTo(i - 1, StateToPrint);
1301  			beforePreProc = state;
1302  			if (inScriptType == eNonHtmlScript)
1303  				inScriptType = eNonHtmlScriptPreProc;
1304  			else
1305  				inScriptType = eNonHtmlPreProc;
1306  			i += 1;
1307  			visibleChars += 1;
1308  			state = SCE_HP_START;
1309  			beforeLanguage = scriptLanguage;
1310  			scriptLanguage = eScriptPython;
1311  			styler.ColourTo(i, SCE_H_ASP);
1312  			ch = static_cast<unsigned char>(styler.SafeGetCharAt(i));
1313  			continue;
1314  		}
1315  		else if (!isMako && !isDjango && !isCommentASPState(state) && (ch == '<') && (chNext == '%') && !isPHPStringState(state)) {
1316  			styler.ColourTo(i - 1, StateToPrint);
1317  			beforePreProc = state;
1318  			if (inScriptType == eNonHtmlScript)
1319  				inScriptType = eNonHtmlScriptPreProc;
1320  			else
1321  				inScriptType = eNonHtmlPreProc;
1322  			if (chNext2 == '@') {
1323  				i += 2; 
1324  				visibleChars += 2;
1325  				state = SCE_H_ASPAT;
1326  				scriptLanguage = eScriptVBS;
1327  			} else if ((chNext2 == '-') && (styler.SafeGetCharAt(i + 3) == '-')) {
1328  				styler.ColourTo(i + 3, SCE_H_ASP);
1329  				state = SCE_H_XCCOMMENT;
1330  				scriptLanguage = eScriptVBS;
1331  				continue;
1332  			} else {
1333  				if (chNext2 == '=') {
1334  					i += 2; 
1335  					visibleChars += 2;
1336  				} else {
1337  					i++; 
1338  					visibleChars++;
1339  				}
1340  				state = StateForScript(aspScript);
1341  				scriptLanguage = aspScript;
1342  			}
1343  			styler.ColourTo(i, SCE_H_ASP);
1344  			if (foldHTMLPreprocessor)
1345  				levelCurrent++;
1346  			ch = static_cast<unsigned char>(styler.SafeGetCharAt(i));
1347  			continue;
1348  		}
1349  		else if (((scriptLanguage == eScriptNone) || (scriptLanguage == eScriptXML)) &&
1350  				 (chPrev == '<') &&
1351  				 (ch == '!') &&
1352  				 (StateToPrint != SCE_H_CDATA) &&
1353  				 (!isStringState(StateToPrint)) &&
1354  				 (!IsCommentState(StateToPrint)) &&
1355  				 (!IsScriptCommentState(StateToPrint))) {
1356  			beforePreProc = state;
1357  			styler.ColourTo(i - 2, StateToPrint);
1358  			if ((chNext == '-') && (chNext2 == '-')) {
1359  				state = SCE_H_COMMENT; 
1360  				styler.ColourTo(i + 2, SCE_H_COMMENT);
1361  				i += 2; 
1362  			} else if (isWordCdata(i + 1, i + 7, styler)) {
1363  				state = SCE_H_CDATA;
1364  			} else {
1365  				styler.ColourTo(i, SCE_H_SGML_DEFAULT); 
1366  				scriptLanguage = eScriptSGML;
1367  				state = SCE_H_SGML_COMMAND; 
1368  			}
1369  			if (foldHTMLPreprocessor || state == SCE_H_COMMENT || state == SCE_H_CDATA)
1370  				levelCurrent++;
1371  			continue;
1372  		}
1373  		else if (isMako &&
1374  			     ((inScriptType == eNonHtmlPreProc) || (inScriptType == eNonHtmlScriptPreProc)) &&
1375  				 (scriptLanguage != eScriptNone) && stateAllowsTermination(state) &&
1376  				 isMakoBlockEnd(ch, chNext, makoBlockType)) {
1377  			if (state == SCE_H_ASPAT) {
1378  				aspScript = segIsScriptingIndicator(styler,
1379  				                                    styler.GetStartSegment(), i - 1, aspScript);
1380  			}
1381  			if (state == SCE_HP_WORD) {
1382  				classifyWordHTPy(styler.GetStartSegment(), i - 1, keywords4, styler, prevWord, inScriptType, isMako);
1383  			} else {
1384  				styler.ColourTo(i - 1, StateToPrint);
1385  			}
1386  			if ((makoBlockType != "%") && (makoBlockType != "{") && ch != '>') {
1387  				i++;
1388  				visibleChars++;
1389  		    }
1390  			else if ((makoBlockType == "%") && ch == '/') {
1391  				i++;
1392  				visibleChars++;
1393  			}
1394  			if ((makoBlockType != "%") || ch == '/') {
1395  				styler.ColourTo(i, SCE_H_ASP);
1396  			}
1397  			state = beforePreProc;
1398  			if (inScriptType == eNonHtmlScriptPreProc)
1399  				inScriptType = eNonHtmlScript;
1400  			else
1401  				inScriptType = eHtml;
1402  			scriptLanguage = eScriptNone;
1403  			continue;
1404  		}
1405  		else if (isDjango &&
1406  			     ((inScriptType == eNonHtmlPreProc) || (inScriptType == eNonHtmlScriptPreProc)) &&
1407  				 (scriptLanguage != eScriptNone) && stateAllowsTermination(state) &&
1408  				 isDjangoBlockEnd(ch, chNext, djangoBlockType)) {
1409  			if (state == SCE_H_ASPAT) {
1410  				aspScript = segIsScriptingIndicator(styler,
1411  				                                    styler.GetStartSegment(), i - 1, aspScript);
1412  			}
1413  			if (state == SCE_HP_WORD) {
1414  				classifyWordHTPy(styler.GetStartSegment(), i - 1, keywords4, styler, prevWord, inScriptType, isMako);
1415  			} else {
1416  				styler.ColourTo(i - 1, StateToPrint);
1417  			}
1418  			i += 1;
1419  			visibleChars += 1;
1420  			styler.ColourTo(i, SCE_H_ASP);
1421  			state = beforePreProc;
1422  			if (inScriptType == eNonHtmlScriptPreProc)
1423  				inScriptType = eNonHtmlScript;
1424  			else
1425  				inScriptType = eHtml;
1426  			scriptLanguage = beforeLanguage;
1427  			continue;
1428  		}
1429  		else if ((!isMako && !isDjango && ((inScriptType == eNonHtmlPreProc) || (inScriptType == eNonHtmlScriptPreProc)) &&
1430  				  (((scriptLanguage != eScriptNone) && stateAllowsTermination(state))) &&
1431  				  (((ch == '%') || (ch == '?')) && (chNext == '>'))) ||
1432  		         ((scriptLanguage == eScriptSGML) && (ch == '>') && (state != SCE_H_SGML_COMMENT))) {
1433  			if (state == SCE_H_ASPAT) {
1434  				aspScript = segIsScriptingIndicator(styler,
1435  				                                    styler.GetStartSegment(), i - 1, aspScript);
1436  			}
1437  			switch (state) {
1438  			case SCE_HJ_WORD:
1439  				classifyWordHTJS(styler.GetStartSegment(), i - 1, keywords2, styler, inScriptType);
1440  				break;
1441  			case SCE_HB_WORD:
1442  				classifyWordHTVB(styler.GetStartSegment(), i - 1, keywords3, styler, inScriptType);
1443  				break;
1444  			case SCE_HP_WORD:
1445  				classifyWordHTPy(styler.GetStartSegment(), i - 1, keywords4, styler, prevWord, inScriptType, isMako);
1446  				break;
1447  			case SCE_HPHP_WORD:
1448  				classifyWordHTPHP(styler.GetStartSegment(), i - 1, keywords5, styler);
1449  				break;
1450  			case SCE_H_XCCOMMENT:
1451  				styler.ColourTo(i - 1, state);
1452  				break;
1453  			default :
1454  				styler.ColourTo(i - 1, StateToPrint);
1455  				break;
1456  			}
1457  			if (scriptLanguage != eScriptSGML) {
1458  				i++;
1459  				visibleChars++;
1460  			}
1461  			if (ch == '%')
1462  				styler.ColourTo(i, SCE_H_ASP);
1463  			else if (scriptLanguage == eScriptXML)
1464  				styler.ColourTo(i, SCE_H_XMLEND);
1465  			else if (scriptLanguage == eScriptSGML)
1466  				styler.ColourTo(i, SCE_H_SGML_DEFAULT);
1467  			else
1468  				styler.ColourTo(i, SCE_H_QUESTION);
1469  			state = beforePreProc;
1470  			if (inScriptType == eNonHtmlScriptPreProc)
1471  				inScriptType = eNonHtmlScript;
1472  			else
1473  				inScriptType = eHtml;
1474  			if (foldHTMLPreprocessor && (scriptLanguage != eScriptXML)) {
1475  				levelCurrent--;
1476  			}
1477  			scriptLanguage = beforeLanguage;
1478  			continue;
1479  		}
1480  		switch (state) {
1481  		case SCE_H_DEFAULT:
1482  			if (ch == '<') {
1483  				tagOpened = true;
1484  				tagClosing = (chNext == '/');
1485  				if (foldXmlAtTagOpen && !(chNext == '/' || chNext == '?' || chNext == '!' || chNext == '-' || chNext == '%')) {
1486  					levelCurrent++;
1487  				}
1488  				if (foldXmlAtTagOpen && chNext == '/') {
1489  					levelCurrent--;
1490  				}
1491  				styler.ColourTo(i - 1, StateToPrint);
1492  				if (chNext != '!')
1493  					state = SCE_H_TAGUNKNOWN;
1494  			} else if (ch == '&') {
1495  				styler.ColourTo(i - 1, SCE_H_DEFAULT);
1496  				state = SCE_H_ENTITY;
1497  			}
1498  			break;
1499  		case SCE_H_SGML_DEFAULT:
1500  		case SCE_H_SGML_BLOCK_DEFAULT:
1501  			if (ch == '\"') {
1502  				styler.ColourTo(i - 1, StateToPrint);
1503  				state = SCE_H_SGML_DOUBLESTRING;
1504  			} else if (ch == '\'') {
1505  				styler.ColourTo(i - 1, StateToPrint);
1506  				state = SCE_H_SGML_SIMPLESTRING;
1507  			} else if ((ch == '-') && (chPrev == '-')) {
1508  				if (static_cast<Sci_Position>(styler.GetStartSegment()) <= (i - 2)) {
1509  					styler.ColourTo(i - 2, StateToPrint);
1510  				}
1511  				state = SCE_H_SGML_COMMENT;
1512  			} else if (IsASCII(ch) && isalpha(ch) && (chPrev == '%')) {
1513  				styler.ColourTo(i - 2, StateToPrint);
1514  				state = SCE_H_SGML_ENTITY;
1515  			} else if (ch == '#') {
1516  				styler.ColourTo(i - 1, StateToPrint);
1517  				state = SCE_H_SGML_SPECIAL;
1518  			} else if (ch == '[') {
1519  				styler.ColourTo(i - 1, StateToPrint);
1520  				scriptLanguage = eScriptSGMLblock;
1521  				state = SCE_H_SGML_BLOCK_DEFAULT;
1522  			} else if (ch == ']') {
1523  				if (scriptLanguage == eScriptSGMLblock) {
1524  					styler.ColourTo(i, StateToPrint);
1525  					scriptLanguage = eScriptSGML;
1526  				} else {
1527  					styler.ColourTo(i - 1, StateToPrint);
1528  					styler.ColourTo(i, SCE_H_SGML_ERROR);
1529  				}
1530  				state = SCE_H_SGML_DEFAULT;
1531  			} else if (scriptLanguage == eScriptSGMLblock) {
1532  				if ((ch == '!') && (chPrev == '<')) {
1533  					styler.ColourTo(i - 2, StateToPrint);
1534  					styler.ColourTo(i, SCE_H_SGML_DEFAULT);
1535  					state = SCE_H_SGML_COMMAND;
1536  				} else if (ch == '>') {
1537  					styler.ColourTo(i - 1, StateToPrint);
1538  					styler.ColourTo(i, SCE_H_SGML_DEFAULT);
1539  				}
1540  			}
1541  			break;
1542  		case SCE_H_SGML_COMMAND:
1543  			if ((ch == '-') && (chPrev == '-')) {
1544  				styler.ColourTo(i - 2, StateToPrint);
1545  				state = SCE_H_SGML_COMMENT;
1546  			} else if (!issgmlwordchar(ch)) {
1547  				if (isWordHSGML(styler.GetStartSegment(), i - 1, keywords6, styler)) {
1548  					styler.ColourTo(i - 1, StateToPrint);
1549  					state = SCE_H_SGML_1ST_PARAM;
1550  				} else {
1551  					state = SCE_H_SGML_ERROR;
1552  				}
1553  			}
1554  			break;
1555  		case SCE_H_SGML_1ST_PARAM:
1556  			if ((ch == '-') && (chPrev == '-')) {
1557  				if (scriptLanguage == eScriptSGMLblock) {
1558  					styler.ColourTo(i - 2, SCE_H_SGML_BLOCK_DEFAULT);
1559  				} else {
1560  					styler.ColourTo(i - 2, SCE_H_SGML_DEFAULT);
1561  				}
1562  				state = SCE_H_SGML_1ST_PARAM_COMMENT;
1563  			} else if (issgmlwordchar(ch)) {
1564  				if (scriptLanguage == eScriptSGMLblock) {
1565  					styler.ColourTo(i - 1, SCE_H_SGML_BLOCK_DEFAULT);
1566  				} else {
1567  					styler.ColourTo(i - 1, SCE_H_SGML_DEFAULT);
1568  				}
1569  				int size = 1;
1570  				while (setHTMLWord.Contains(static_cast<unsigned char>(styler.SafeGetCharAt(i + size))))
1571  					size++;
1572  				styler.ColourTo(i + size - 1, StateToPrint);
1573  				i += size - 1;
1574  				visibleChars += size - 1;
1575  				ch = static_cast<unsigned char>(styler.SafeGetCharAt(i));
1576  				if (scriptLanguage == eScriptSGMLblock) {
1577  					state = SCE_H_SGML_BLOCK_DEFAULT;
1578  				} else {
1579  					state = SCE_H_SGML_DEFAULT;
1580  				}
1581  				continue;
1582  			}
1583  			break;
1584  		case SCE_H_SGML_ERROR:
1585  			if ((ch == '-') && (chPrev == '-')) {
1586  				styler.ColourTo(i - 2, StateToPrint);
1587  				state = SCE_H_SGML_COMMENT;
1588  			}
1589  			break;
1590  		case SCE_H_SGML_DOUBLESTRING:
1591  			if (ch == '\"') {
1592  				styler.ColourTo(i, StateToPrint);
1593  				state = SCE_H_SGML_DEFAULT;
1594  			}
1595  			break;
1596  		case SCE_H_SGML_SIMPLESTRING:
1597  			if (ch == '\'') {
1598  				styler.ColourTo(i, StateToPrint);
1599  				state = SCE_H_SGML_DEFAULT;
1600  			}
1601  			break;
1602  		case SCE_H_SGML_COMMENT:
1603  			if ((ch == '-') && (chPrev == '-')) {
1604  				styler.ColourTo(i, StateToPrint);
1605  				state = SCE_H_SGML_DEFAULT;
1606  			}
1607  			break;
1608  		case SCE_H_CDATA:
1609  			if ((chPrev2 == ']') && (chPrev == ']') && (ch == '>')) {
1610  				styler.ColourTo(i, StateToPrint);
1611  				state = SCE_H_DEFAULT;
1612  				levelCurrent--;
1613  			}
1614  			break;
1615  		case SCE_H_COMMENT:
1616  			if ((scriptLanguage != eScriptComment) && (chPrev2 == '-') && (chPrev == '-') && (ch == '>')) {
1617  				styler.ColourTo(i, StateToPrint);
1618  				state = SCE_H_DEFAULT;
1619  				levelCurrent--;
1620  			}
1621  			break;
1622  		case SCE_H_SGML_1ST_PARAM_COMMENT:
1623  			if ((ch == '-') && (chPrev == '-')) {
1624  				styler.ColourTo(i, SCE_H_SGML_COMMENT);
1625  				state = SCE_H_SGML_1ST_PARAM;
1626  			}
1627  			break;
1628  		case SCE_H_SGML_SPECIAL:
1629  			if (!(IsASCII(ch) && isupper(ch))) {
1630  				styler.ColourTo(i - 1, StateToPrint);
1631  				if (isalnum(ch)) {
1632  					state = SCE_H_SGML_ERROR;
1633  				} else {
1634  					state = SCE_H_SGML_DEFAULT;
1635  				}
1636  			}
1637  			break;
1638  		case SCE_H_SGML_ENTITY:
1639  			if (ch == ';') {
1640  				styler.ColourTo(i, StateToPrint);
1641  				state = SCE_H_SGML_DEFAULT;
1642  			} else if (!(IsASCII(ch) && isalnum(ch)) && ch != '-' && ch != '.') {
1643  				styler.ColourTo(i, SCE_H_SGML_ERROR);
1644  				state = SCE_H_SGML_DEFAULT;
1645  			}
1646  			break;
1647  		case SCE_H_ENTITY:
1648  			if (ch == ';') {
1649  				styler.ColourTo(i, StateToPrint);
1650  				state = SCE_H_DEFAULT;
1651  			}
1652  			if (ch != '#' && !(IsASCII(ch) && isalnum(ch))	
1653  				&& ch != '.' && ch != '-' && ch != '_' && ch != ':') { 
1654  				if (!IsASCII(ch))	
1655  					styler.ColourTo(i-1, SCE_H_TAGUNKNOWN);
1656  				else
1657  					styler.ColourTo(i, SCE_H_TAGUNKNOWN);
1658  				state = SCE_H_DEFAULT;
1659  			}
1660  			break;
1661  		case SCE_H_TAGUNKNOWN:
1662  			if (!setTagContinue.Contains(ch) && !((ch == '/') && (chPrev == '<'))) {
1663  				int eClass = classifyTagHTML(styler.GetStartSegment(),
1664  					i - 1, keywords, styler, tagDontFold, caseSensitive, isXml, allowScripts, nonFoldingTags);
1665  				if (eClass == SCE_H_SCRIPT || eClass == SCE_H_COMMENT) {
1666  					if (!tagClosing) {
1667  						inScriptType = eNonHtmlScript;
1668  						scriptLanguage = eClass == SCE_H_SCRIPT ? clientScript : eScriptComment;
1669  					} else {
1670  						scriptLanguage = eScriptNone;
1671  					}
1672  					isLanguageType = false;
1673  					eClass = SCE_H_TAG;
1674  				}
1675  				if (ch == '>') {
1676  					styler.ColourTo(i, eClass);
1677  					if (inScriptType == eNonHtmlScript) {
1678  						state = StateForScript(scriptLanguage);
1679  					} else {
1680  						state = SCE_H_DEFAULT;
1681  					}
1682  					tagOpened = false;
1683  					if (!(foldXmlAtTagOpen || tagDontFold)) {
1684  						if (tagClosing) {
1685  							levelCurrent--;
1686  						} else {
1687  							levelCurrent++;
1688  						}
1689  					}
1690  					tagClosing = false;
1691  				} else if (ch == '/' && chNext == '>') {
1692  					if (eClass == SCE_H_TAGUNKNOWN) {
1693  						styler.ColourTo(i + 1, SCE_H_TAGUNKNOWN);
1694  					} else {
1695  						styler.ColourTo(i - 1, StateToPrint);
1696  						styler.ColourTo(i + 1, SCE_H_TAGEND);
1697  					}
1698  					i++;
1699  					ch = chNext;
1700  					state = SCE_H_DEFAULT;
1701  					tagOpened = false;
1702  					if (foldXmlAtTagOpen) {
1703  						levelCurrent--;
1704  					}
1705  				} else {
1706  					if (eClass != SCE_H_TAGUNKNOWN) {
1707  						if (eClass == SCE_H_SGML_DEFAULT) {
1708  							state = SCE_H_SGML_DEFAULT;
1709  						} else {
1710  							state = SCE_H_OTHER;
1711  						}
1712  					}
1713  				}
1714  			}
1715  			break;
1716  		case SCE_H_ATTRIBUTE:
1717  			if (!setAttributeContinue.Contains(ch)) {
1718  				isLanguageType = classifyAttribHTML(inScriptType, styler.GetStartSegment(), i - 1, keywords, styler);
1719  				if (ch == '>') {
1720  					styler.ColourTo(i, SCE_H_TAG);
1721  					if (inScriptType == eNonHtmlScript) {
1722  						state = StateForScript(scriptLanguage);
1723  					} else {
1724  						state = SCE_H_DEFAULT;
1725  					}
1726  					tagOpened = false;
1727  					if (!(foldXmlAtTagOpen || tagDontFold)) {
1728  						if (tagClosing) {
1729  							levelCurrent--;
1730  						} else {
1731  							levelCurrent++;
1732  						}
1733  					}
1734  					tagClosing = false;
1735  				} else if (ch == '=') {
1736  					styler.ColourTo(i, SCE_H_OTHER);
1737  					state = SCE_H_VALUE;
1738  				} else {
1739  					state = SCE_H_OTHER;
1740  				}
1741  			}
1742  			break;
1743  		case SCE_H_OTHER:
1744  			if (ch == '>') {
1745  				styler.ColourTo(i - 1, StateToPrint);
1746  				styler.ColourTo(i, SCE_H_TAG);
1747  				if (inScriptType == eNonHtmlScript) {
1748  					state = StateForScript(scriptLanguage);
1749  				} else {
1750  					state = SCE_H_DEFAULT;
1751  				}
1752  				tagOpened = false;
1753  				if (!(foldXmlAtTagOpen || tagDontFold)) {
1754  					if (tagClosing) {
1755  						levelCurrent--;
1756  					} else {
1757  						levelCurrent++;
1758  					}
1759  				}
1760  				tagClosing = false;
1761  			} else if (ch == '\"') {
1762  				styler.ColourTo(i - 1, StateToPrint);
1763  				state = SCE_H_DOUBLESTRING;
1764  			} else if (ch == '\'') {
1765  				styler.ColourTo(i - 1, StateToPrint);
1766  				state = SCE_H_SINGLESTRING;
1767  			} else if (ch == '=') {
1768  				styler.ColourTo(i, StateToPrint);
1769  				state = SCE_H_VALUE;
1770  			} else if (ch == '/' && chNext == '>') {
1771  				styler.ColourTo(i - 1, StateToPrint);
1772  				styler.ColourTo(i + 1, SCE_H_TAGEND);
<span onclick='openModal()' class='match'>1773  				i++;
1774  				ch = chNext;
1775  				state = SCE_H_DEFAULT;
1776  				tagOpened = false;
1777  				if (foldXmlAtTagOpen) {
1778  					levelCurrent--;
</span>1779  				}
1780  			} else if (ch == '?' && chNext == '>') {
1781  				styler.ColourTo(i - 1, StateToPrint);
1782  				styler.ColourTo(i + 1, SCE_H_XMLEND);
1783  				i++;
1784  				ch = chNext;
1785  				state = SCE_H_DEFAULT;
1786  			} else if (setHTMLWord.Contains(ch)) {
1787  				styler.ColourTo(i - 1, StateToPrint);
1788  				state = SCE_H_ATTRIBUTE;
1789  			}
1790  			break;
1791  		case SCE_H_DOUBLESTRING:
1792  			if (ch == '\"') {
1793  				if (isLanguageType) {
1794  					scriptLanguage = segIsScriptingIndicator(styler, styler.GetStartSegment(), i, scriptLanguage);
1795  					clientScript = scriptLanguage;
1796  					isLanguageType = false;
1797  				}
1798  				styler.ColourTo(i, SCE_H_DOUBLESTRING);
1799  				state = SCE_H_OTHER;
1800  			}
1801  			break;
1802  		case SCE_H_SINGLESTRING:
1803  			if (ch == '\'') {
1804  				if (isLanguageType) {
1805  					scriptLanguage = segIsScriptingIndicator(styler, styler.GetStartSegment(), i, scriptLanguage);
1806  					clientScript = scriptLanguage;
1807  					isLanguageType = false;
1808  				}
1809  				styler.ColourTo(i, SCE_H_SINGLESTRING);
1810  				state = SCE_H_OTHER;
1811  			}
1812  			break;
1813  		case SCE_H_VALUE:
1814  			if (!setHTMLWord.Contains(ch)) {
1815  				if (ch == '\"' && chPrev == '=') {
1816  					state = SCE_H_DOUBLESTRING;
1817  				} else if (ch == '\'' && chPrev == '=') {
1818  					state = SCE_H_SINGLESTRING;
1819  				} else {
1820  					if (IsNumberChar(styler[styler.GetStartSegment()])) {
1821  						styler.ColourTo(i - 1, SCE_H_NUMBER);
1822  					} else {
1823  						styler.ColourTo(i - 1, StateToPrint);
1824  					}
1825  					if (ch == '>') {
1826  						styler.ColourTo(i, SCE_H_TAG);
1827  						if (inScriptType == eNonHtmlScript) {
1828  							state = StateForScript(scriptLanguage);
1829  						} else {
1830  							state = SCE_H_DEFAULT;
1831  						}
1832  						tagOpened = false;
1833  						if (!tagDontFold) {
1834  							if (tagClosing) {
1835  								levelCurrent--;
1836  							} else {
1837  								levelCurrent++;
1838  							}
1839  						}
1840  						tagClosing = false;
1841  					} else {
1842  						state = SCE_H_OTHER;
1843  					}
1844  				}
1845  			}
1846  			break;
1847  		case SCE_HJ_DEFAULT:
1848  		case SCE_HJ_START:
1849  		case SCE_HJ_SYMBOLS:
1850  			if (IsAWordStart(ch)) {
1851  				styler.ColourTo(i - 1, StateToPrint);
1852  				state = SCE_HJ_WORD;
1853  			} else if (ch == '/' && chNext == '*') {
1854  				styler.ColourTo(i - 1, StateToPrint);
1855  				if (chNext2 == '*')
1856  					state = SCE_HJ_COMMENTDOC;
1857  				else
1858  					state = SCE_HJ_COMMENT;
1859  				if (chNext2 == '/') {
1860  					i++;
1861  				}
1862  			} else if (ch == '/' && chNext == '/') {
1863  				styler.ColourTo(i - 1, StateToPrint);
1864  				state = SCE_HJ_COMMENTLINE;
1865  			} else if (ch == '/' && setOKBeforeJSRE.Contains(chPrevNonWhite)) {
1866  				styler.ColourTo(i - 1, StateToPrint);
1867  				state = SCE_HJ_REGEX;
1868  			} else if (ch == '\"') {
1869  				styler.ColourTo(i - 1, StateToPrint);
1870  				state = SCE_HJ_DOUBLESTRING;
1871  			} else if (ch == '\'') {
1872  				styler.ColourTo(i - 1, StateToPrint);
1873  				state = SCE_HJ_SINGLESTRING;
1874  			} else if ((ch == '<') && (chNext == '!') && (chNext2 == '-') &&
1875  			           styler.SafeGetCharAt(i + 3) == '-') {
1876  				styler.ColourTo(i - 1, StateToPrint);
1877  				state = SCE_HJ_COMMENTLINE;
1878  			} else if ((ch == '-') && (chNext == '-') && (chNext2 == '>')) {
1879  				styler.ColourTo(i - 1, StateToPrint);
1880  				state = SCE_HJ_COMMENTLINE;
1881  				i += 2;
1882  			} else if (IsOperator(ch)) {
1883  				styler.ColourTo(i - 1, StateToPrint);
1884  				styler.ColourTo(i, statePrintForState(SCE_HJ_SYMBOLS, inScriptType));
1885  				state = SCE_HJ_DEFAULT;
1886  			} else if ((ch == ' ') || (ch == '\t')) {
1887  				if (state == SCE_HJ_START) {
1888  					styler.ColourTo(i - 1, StateToPrint);
1889  					state = SCE_HJ_DEFAULT;
1890  				}
1891  			}
1892  			break;
1893  		case SCE_HJ_WORD:
1894  			if (!IsAWordChar(ch)) {
1895  				classifyWordHTJS(styler.GetStartSegment(), i - 1, keywords2, styler, inScriptType);
1896  				state = SCE_HJ_DEFAULT;
1897  				if (ch == '/' && chNext == '*') {
1898  					if (chNext2 == '*')
1899  						state = SCE_HJ_COMMENTDOC;
1900  					else
1901  						state = SCE_HJ_COMMENT;
1902  				} else if (ch == '/' && chNext == '/') {
1903  					state = SCE_HJ_COMMENTLINE;
1904  				} else if (ch == '\"') {
1905  					state = SCE_HJ_DOUBLESTRING;
1906  				} else if (ch == '\'') {
1907  					state = SCE_HJ_SINGLESTRING;
1908  				} else if ((ch == '-') && (chNext == '-') && (chNext2 == '>')) {
1909  					styler.ColourTo(i - 1, StateToPrint);
1910  					state = SCE_HJ_COMMENTLINE;
1911  					i += 2;
1912  				} else if (IsOperator(ch)) {
1913  					styler.ColourTo(i, statePrintForState(SCE_HJ_SYMBOLS, inScriptType));
1914  					state = SCE_HJ_DEFAULT;
1915  				}
1916  			}
1917  			break;
1918  		case SCE_HJ_COMMENT:
1919  		case SCE_HJ_COMMENTDOC:
1920  			if (ch == '/' && chPrev == '*') {
1921  				styler.ColourTo(i, StateToPrint);
1922  				state = SCE_HJ_DEFAULT;
1923  				ch = ' ';
1924  			}
1925  			break;
1926  		case SCE_HJ_COMMENTLINE:
1927  			if (ch == '\r' || ch == '\n') {
1928  				styler.ColourTo(i - 1, statePrintForState(SCE_HJ_COMMENTLINE, inScriptType));
1929  				state = SCE_HJ_DEFAULT;
1930  				ch = ' ';
1931  			}
1932  			break;
1933  		case SCE_HJ_DOUBLESTRING:
1934  			if (ch == '\\') {
1935  				if (chNext == '\"' || chNext == '\'' || chNext == '\\') {
1936  					i++;
1937  				}
1938  			} else if (ch == '\"') {
1939  				styler.ColourTo(i, statePrintForState(SCE_HJ_DOUBLESTRING, inScriptType));
1940  				state = SCE_HJ_DEFAULT;
1941  			} else if (isLineEnd(ch)) {
1942  				styler.ColourTo(i - 1, StateToPrint);
1943  				state = SCE_HJ_STRINGEOL;
1944  			}
1945  			break;
1946  		case SCE_HJ_SINGLESTRING:
1947  			if (ch == '\\') {
1948  				if (chNext == '\"' || chNext == '\'' || chNext == '\\') {
1949  					i++;
1950  				}
1951  			} else if (ch == '\'') {
1952  				styler.ColourTo(i, statePrintForState(SCE_HJ_SINGLESTRING, inScriptType));
1953  				state = SCE_HJ_DEFAULT;
1954  			} else if (isLineEnd(ch)) {
1955  				styler.ColourTo(i - 1, StateToPrint);
1956  				if (chPrev != '\\' && (chPrev2 != '\\' || chPrev != '\r' || ch != '\n')) {
1957  					state = SCE_HJ_STRINGEOL;
1958  				}
1959  			}
1960  			break;
1961  		case SCE_HJ_STRINGEOL:
1962  			if (!isLineEnd(ch)) {
1963  				styler.ColourTo(i - 1, StateToPrint);
1964  				state = SCE_HJ_DEFAULT;
1965  			} else if (!isLineEnd(chNext)) {
1966  				styler.ColourTo(i, StateToPrint);
1967  				state = SCE_HJ_DEFAULT;
1968  			}
1969  			break;
1970  		case SCE_HJ_REGEX:
1971  			if (ch == '\r' || ch == '\n' || ch == '/') {
1972  				if (ch == '/') {
1973  					while (IsASCII(chNext) && islower(chNext)) {   
1974  						i++;
1975  						ch = chNext;
1976  						chNext = static_cast<unsigned char>(styler.SafeGetCharAt(i + 1));
1977  					}
1978  				}
1979  				styler.ColourTo(i, StateToPrint);
1980  				state = SCE_HJ_DEFAULT;
1981  			} else if (ch == '\\') {
1982  				if (chNext == '\\' || chNext == '/') {
1983  					i++;
1984  					ch = chNext;
1985  					chNext = static_cast<unsigned char>(styler.SafeGetCharAt(i + 1));
1986  				}
1987  			}
1988  			break;
1989  		case SCE_HB_DEFAULT:
1990  		case SCE_HB_START:
1991  			if (IsAWordStart(ch)) {
1992  				styler.ColourTo(i - 1, StateToPrint);
1993  				state = SCE_HB_WORD;
1994  			} else if (ch == '\'') {
1995  				styler.ColourTo(i - 1, StateToPrint);
1996  				state = SCE_HB_COMMENTLINE;
1997  			} else if (ch == '\"') {
1998  				styler.ColourTo(i - 1, StateToPrint);
1999  				state = SCE_HB_STRING;
2000  			} else if ((ch == '<') && (chNext == '!') && (chNext2 == '-') &&
2001  			           styler.SafeGetCharAt(i + 3) == '-') {
2002  				styler.ColourTo(i - 1, StateToPrint);
2003  				state = SCE_HB_COMMENTLINE;
2004  			} else if (IsOperator(ch)) {
2005  				styler.ColourTo(i - 1, StateToPrint);
2006  				styler.ColourTo(i, statePrintForState(SCE_HB_DEFAULT, inScriptType));
2007  				state = SCE_HB_DEFAULT;
2008  			} else if ((ch == ' ') || (ch == '\t')) {
2009  				if (state == SCE_HB_START) {
2010  					styler.ColourTo(i - 1, StateToPrint);
2011  					state = SCE_HB_DEFAULT;
2012  				}
2013  			}
2014  			break;
2015  		case SCE_HB_WORD:
2016  			if (!IsAWordChar(ch)) {
2017  				state = classifyWordHTVB(styler.GetStartSegment(), i - 1, keywords3, styler, inScriptType);
2018  				if (state == SCE_HB_DEFAULT) {
2019  					if (ch == '\"') {
2020  						state = SCE_HB_STRING;
2021  					} else if (ch == '\'') {
2022  						state = SCE_HB_COMMENTLINE;
2023  					} else if (IsOperator(ch)) {
2024  						styler.ColourTo(i, statePrintForState(SCE_HB_DEFAULT, inScriptType));
2025  						state = SCE_HB_DEFAULT;
2026  					}
2027  				}
2028  			}
2029  			break;
2030  		case SCE_HB_STRING:
2031  			if (ch == '\"') {
2032  				styler.ColourTo(i, StateToPrint);
2033  				state = SCE_HB_DEFAULT;
2034  			} else if (ch == '\r' || ch == '\n') {
2035  				styler.ColourTo(i - 1, StateToPrint);
2036  				state = SCE_HB_STRINGEOL;
2037  			}
2038  			break;
2039  		case SCE_HB_COMMENTLINE:
2040  			if (ch == '\r' || ch == '\n') {
2041  				styler.ColourTo(i - 1, StateToPrint);
2042  				state = SCE_HB_DEFAULT;
2043  			}
2044  			break;
2045  		case SCE_HB_STRINGEOL:
2046  			if (!isLineEnd(ch)) {
2047  				styler.ColourTo(i - 1, StateToPrint);
2048  				state = SCE_HB_DEFAULT;
2049  			} else if (!isLineEnd(chNext)) {
2050  				styler.ColourTo(i, StateToPrint);
2051  				state = SCE_HB_DEFAULT;
2052  			}
2053  			break;
2054  		case SCE_HP_DEFAULT:
2055  		case SCE_HP_START:
2056  			if (IsAWordStart(ch)) {
2057  				styler.ColourTo(i - 1, StateToPrint);
2058  				state = SCE_HP_WORD;
2059  			} else if ((ch == '<') && (chNext == '!') && (chNext2 == '-') &&
2060  			           styler.SafeGetCharAt(i + 3) == '-') {
2061  				styler.ColourTo(i - 1, StateToPrint);
2062  				state = SCE_HP_COMMENTLINE;
2063  			} else if (ch == '#') {
2064  				styler.ColourTo(i - 1, StateToPrint);
2065  				state = SCE_HP_COMMENTLINE;
2066  			} else if (ch == '\"') {
2067  				styler.ColourTo(i - 1, StateToPrint);
2068  				if (chNext == '\"' && chNext2 == '\"') {
2069  					i += 2;
2070  					state = SCE_HP_TRIPLEDOUBLE;
2071  					ch = ' ';
2072  					chPrev = ' ';
2073  					chNext = static_cast<unsigned char>(styler.SafeGetCharAt(i + 1));
2074  				} else {
2075  					state = SCE_HP_STRING;
2076  				}
2077  			} else if (ch == '\'') {
2078  				styler.ColourTo(i - 1, StateToPrint);
2079  				if (chNext == '\'' && chNext2 == '\'') {
2080  					i += 2;
2081  					state = SCE_HP_TRIPLE;
2082  					ch = ' ';
2083  					chPrev = ' ';
2084  					chNext = static_cast<unsigned char>(styler.SafeGetCharAt(i + 1));
2085  				} else {
2086  					state = SCE_HP_CHARACTER;
2087  				}
2088  			} else if (IsOperator(ch)) {
2089  				styler.ColourTo(i - 1, StateToPrint);
2090  				styler.ColourTo(i, statePrintForState(SCE_HP_OPERATOR, inScriptType));
2091  			} else if ((ch == ' ') || (ch == '\t')) {
2092  				if (state == SCE_HP_START) {
2093  					styler.ColourTo(i - 1, StateToPrint);
2094  					state = SCE_HP_DEFAULT;
2095  				}
2096  			}
2097  			break;
2098  		case SCE_HP_WORD:
2099  			if (!IsAWordChar(ch)) {
2100  				classifyWordHTPy(styler.GetStartSegment(), i - 1, keywords4, styler, prevWord, inScriptType, isMako);
2101  				state = SCE_HP_DEFAULT;
2102  				if (ch == '#') {
2103  					state = SCE_HP_COMMENTLINE;
2104  				} else if (ch == '\"') {
2105  					if (chNext == '\"' && chNext2 == '\"') {
2106  						i += 2;
2107  						state = SCE_HP_TRIPLEDOUBLE;
2108  						ch = ' ';
2109  						chPrev = ' ';
2110  						chNext = static_cast<unsigned char>(styler.SafeGetCharAt(i + 1));
2111  					} else {
2112  						state = SCE_HP_STRING;
2113  					}
2114  				} else if (ch == '\'') {
2115  					if (chNext == '\'' && chNext2 == '\'') {
2116  						i += 2;
2117  						state = SCE_HP_TRIPLE;
2118  						ch = ' ';
2119  						chPrev = ' ';
2120  						chNext = static_cast<unsigned char>(styler.SafeGetCharAt(i + 1));
2121  					} else {
2122  						state = SCE_HP_CHARACTER;
2123  					}
2124  				} else if (IsOperator(ch)) {
2125  					styler.ColourTo(i, statePrintForState(SCE_HP_OPERATOR, inScriptType));
2126  				}
2127  			}
2128  			break;
2129  		case SCE_HP_COMMENTLINE:
2130  			if (ch == '\r' || ch == '\n') {
2131  				styler.ColourTo(i - 1, StateToPrint);
2132  				state = SCE_HP_DEFAULT;
2133  			}
2134  			break;
2135  		case SCE_HP_STRING:
2136  			if (ch == '\\') {
2137  				if (chNext == '\"' || chNext == '\'' || chNext == '\\') {
2138  					i++;
2139  					ch = chNext;
2140  					chNext = static_cast<unsigned char>(styler.SafeGetCharAt(i + 1));
2141  				}
2142  			} else if (ch == '\"') {
2143  				styler.ColourTo(i, StateToPrint);
2144  				state = SCE_HP_DEFAULT;
2145  			}
2146  			break;
2147  		case SCE_HP_CHARACTER:
2148  			if (ch == '\\') {
2149  				if (chNext == '\"' || chNext == '\'' || chNext == '\\') {
2150  					i++;
2151  					ch = chNext;
2152  					chNext = static_cast<unsigned char>(styler.SafeGetCharAt(i + 1));
2153  				}
2154  			} else if (ch == '\'') {
2155  				styler.ColourTo(i, StateToPrint);
2156  				state = SCE_HP_DEFAULT;
2157  			}
2158  			break;
2159  		case SCE_HP_TRIPLE:
2160  			if (ch == '\'' && chPrev == '\'' && chPrev2 == '\'') {
2161  				styler.ColourTo(i, StateToPrint);
2162  				state = SCE_HP_DEFAULT;
2163  			}
2164  			break;
2165  		case SCE_HP_TRIPLEDOUBLE:
2166  			if (ch == '\"' && chPrev == '\"' && chPrev2 == '\"') {
2167  				styler.ColourTo(i, StateToPrint);
2168  				state = SCE_HP_DEFAULT;
2169  			}
2170  			break;
2171  		case SCE_HPHP_WORD:
2172  			if (!IsPhpWordChar(ch)) {
2173  				classifyWordHTPHP(styler.GetStartSegment(), i - 1, keywords5, styler);
2174  				if (ch == '/' && chNext == '*') {
2175  					i++;
2176  					state = SCE_HPHP_COMMENT;
2177  				} else if (ch == '/' && chNext == '/') {
2178  					i++;
2179  					state = SCE_HPHP_COMMENTLINE;
2180  				} else if (ch == '#' && chNext != '[') {
2181  					state = SCE_HPHP_COMMENTLINE;
2182  				} else if (ch == '\"') {
2183  					state = SCE_HPHP_HSTRING;
2184  					phpStringDelimiter = "\"";
2185  				} else if (styler.Match(i, "<<<")) {
2186  					bool isSimpleString = false;
2187  					i = FindPhpStringDelimiter(phpStringDelimiter, i + 3, lengthDoc, styler, isSimpleString);
2188  					if (!phpStringDelimiter.empty()) {
2189  						state = (isSimpleString ? SCE_HPHP_SIMPLESTRING : SCE_HPHP_HSTRING);
2190  						if (foldHeredoc) levelCurrent++;
2191  					}
2192  				} else if (ch == '\'') {
2193  					state = SCE_HPHP_SIMPLESTRING;
2194  					phpStringDelimiter = "\'";
2195  				} else if (ch == '$' && IsPhpWordStart(chNext)) {
2196  					state = SCE_HPHP_VARIABLE;
2197  				} else if (IsOperator(ch)) {
2198  					state = SCE_HPHP_OPERATOR;
2199  				} else {
2200  					state = SCE_HPHP_DEFAULT;
2201  				}
2202  			}
2203  			break;
2204  		case SCE_HPHP_NUMBER:
2205  			if (phpNumber.check(chNext, chNext2)) {
2206  				styler.ColourTo(i, phpNumber.isInvalid() ? SCE_HPHP_DEFAULT : SCE_HPHP_NUMBER);
2207  				state = SCE_HPHP_DEFAULT;
2208  			}
2209  			break;
2210  		case SCE_HPHP_VARIABLE:
2211  			if (!IsPhpWordChar(chNext)) {
2212  				styler.ColourTo(i, SCE_HPHP_VARIABLE);
2213  				state = SCE_HPHP_DEFAULT;
2214  			}
2215  			break;
2216  		case SCE_HPHP_COMMENT:
2217  			if (ch == '/' && chPrev == '*') {
2218  				styler.ColourTo(i, StateToPrint);
2219  				state = SCE_HPHP_DEFAULT;
2220  			}
2221  			break;
2222  		case SCE_HPHP_COMMENTLINE:
2223  			if (ch == '\r' || ch == '\n') {
2224  				styler.ColourTo(i - 1, StateToPrint);
2225  				state = SCE_HPHP_DEFAULT;
2226  			}
2227  			break;
2228  		case SCE_HPHP_HSTRING:
2229  			if (ch == '\\' && ((phpStringDelimiter == "\"") || chNext == '$' || chNext == '{')) {
2230  				i++;
2231  			} else if (((ch == '{' && chNext == '$') || (ch == '$' && chNext == '{'))
2232  				&& IsPhpWordStart(chNext2)) {
2233  				styler.ColourTo(i - 1, StateToPrint);
2234  				state = SCE_HPHP_COMPLEX_VARIABLE;
2235  			} else if (ch == '$' && IsPhpWordStart(chNext)) {
2236  				styler.ColourTo(i - 1, StateToPrint);
2237  				state = SCE_HPHP_HSTRING_VARIABLE;
2238  			} else if (styler.Match(i, phpStringDelimiter.c_str())) {
2239  				if (phpStringDelimiter == "\"") {
2240  					styler.ColourTo(i, StateToPrint);
2241  					state = SCE_HPHP_DEFAULT;
2242  				} else if (lineStartVisibleChars == 1) {
2243  					const int psdLength = static_cast<int>(phpStringDelimiter.length());
2244  					if (!IsPhpWordChar(styler.SafeGetCharAt(i + psdLength))) {
2245  						i += (((i + psdLength) < lengthDoc) ? psdLength : lengthDoc) - 1;
2246  						styler.ColourTo(i, StateToPrint);
2247  						state = SCE_HPHP_DEFAULT;
2248  						if (foldHeredoc) levelCurrent--;
2249  					}
2250  				}
2251  			}
2252  			break;
2253  		case SCE_HPHP_SIMPLESTRING:
2254  			if (phpStringDelimiter == "\'") {
2255  				if (ch == '\\') {
2256  					i++;
2257  				} else if (ch == '\'') {
2258  					styler.ColourTo(i, StateToPrint);
2259  					state = SCE_HPHP_DEFAULT;
2260  				}
2261  			} else if (lineStartVisibleChars == 1 && styler.Match(i, phpStringDelimiter.c_str())) {
2262  				const int psdLength = static_cast<int>(phpStringDelimiter.length());
2263  				if (!IsPhpWordChar(styler.SafeGetCharAt(i + psdLength))) {
2264  					i += (((i + psdLength) < lengthDoc) ? psdLength : lengthDoc) - 1;
2265  					styler.ColourTo(i, StateToPrint);
2266  					state = SCE_HPHP_DEFAULT;
2267  					if (foldHeredoc) levelCurrent--;
2268  				}
2269  			}
2270  			break;
2271  		case SCE_HPHP_HSTRING_VARIABLE:
2272  			if (!IsPhpWordChar(chNext)) {
2273  				styler.ColourTo(i, StateToPrint);
2274  				state = SCE_HPHP_HSTRING;
2275  			}
2276  			break;
2277  		case SCE_HPHP_COMPLEX_VARIABLE:
2278  			if (ch == '}') {
2279  				styler.ColourTo(i, StateToPrint);
2280  				state = SCE_HPHP_HSTRING;
2281  			}
2282  			break;
2283  		case SCE_HPHP_OPERATOR:
2284  		case SCE_HPHP_DEFAULT:
2285  			styler.ColourTo(i - 1, StateToPrint);
2286  			if (phpNumber.init(ch, chNext, chNext2)) {
2287  				if (phpNumber.isFinished()) {
2288  					styler.ColourTo(i, phpNumber.isInvalid() ? SCE_HPHP_DEFAULT : SCE_HPHP_NUMBER);
2289  					state = SCE_HPHP_DEFAULT;
2290  				} else {
2291  					state = SCE_HPHP_NUMBER;
2292  				}
2293  			} else if (IsAWordStart(ch)) {
2294  				state = SCE_HPHP_WORD;
2295  			} else if (ch == '/' && chNext == '*') {
2296  				i++;
2297  				state = SCE_HPHP_COMMENT;
2298  			} else if (ch == '/' && chNext == '/') {
2299  				i++;
2300  				state = SCE_HPHP_COMMENTLINE;
2301  			} else if (ch == '#' && chNext != '[') {
2302  				state = SCE_HPHP_COMMENTLINE;
2303  			} else if (ch == '\"') {
2304  				state = SCE_HPHP_HSTRING;
2305  				phpStringDelimiter = "\"";
2306  			} else if (styler.Match(i, "<<<")) {
2307  				bool isSimpleString = false;
2308  				i = FindPhpStringDelimiter(phpStringDelimiter, i + 3, lengthDoc, styler, isSimpleString);
2309  				if (!phpStringDelimiter.empty()) {
2310  					state = (isSimpleString ? SCE_HPHP_SIMPLESTRING : SCE_HPHP_HSTRING);
2311  					if (foldHeredoc) levelCurrent++;
2312  				}
2313  			} else if (ch == '\'') {
2314  				state = SCE_HPHP_SIMPLESTRING;
2315  				phpStringDelimiter = "\'";
2316  			} else if (ch == '$' && IsPhpWordStart(chNext)) {
2317  				state = SCE_HPHP_VARIABLE;
2318  			} else if (IsOperator(ch)) {
2319  				state = SCE_HPHP_OPERATOR;
2320  			} else if ((state == SCE_HPHP_OPERATOR) && (IsASpace(ch))) {
2321  				state = SCE_HPHP_DEFAULT;
2322  			}
2323  			break;
2324  		}
2325  		const bool nonEmptySegment = i >= static_cast<Sci_Position>(styler.GetStartSegment());
2326  		if (state == SCE_HB_DEFAULT) {    
2327  			if ((ch == '\"') && (nonEmptySegment)) {
2328  				state = SCE_HB_STRING;
2329  			} else if (ch == '\'') {
2330  				state = SCE_HB_COMMENTLINE;
2331  			} else if (IsAWordStart(ch)) {
2332  				state = SCE_HB_WORD;
2333  			} else if (IsOperator(ch)) {
2334  				styler.ColourTo(i, SCE_HB_DEFAULT);
2335  			}
2336  		} else if (state == SCE_HBA_DEFAULT) {    
2337  			if ((ch == '\"') && (nonEmptySegment)) {
2338  				state = SCE_HBA_STRING;
2339  			} else if (ch == '\'') {
2340  				state = SCE_HBA_COMMENTLINE;
2341  			} else if (IsAWordStart(ch)) {
2342  				state = SCE_HBA_WORD;
2343  			} else if (IsOperator(ch)) {
2344  				styler.ColourTo(i, SCE_HBA_DEFAULT);
2345  			}
2346  		} else if (state == SCE_HJ_DEFAULT) {    
2347  			if (ch == '/' && chNext == '*') {
2348  				if (styler.SafeGetCharAt(i + 2) == '*')
2349  					state = SCE_HJ_COMMENTDOC;
2350  				else
2351  					state = SCE_HJ_COMMENT;
2352  			} else if (ch == '/' && chNext == '/') {
2353  				state = SCE_HJ_COMMENTLINE;
2354  			} else if ((ch == '\"') && (nonEmptySegment)) {
2355  				state = SCE_HJ_DOUBLESTRING;
2356  			} else if ((ch == '\'') && (nonEmptySegment)) {
2357  				state = SCE_HJ_SINGLESTRING;
2358  			} else if (IsAWordStart(ch)) {
2359  				state = SCE_HJ_WORD;
2360  			} else if (IsOperator(ch)) {
2361  				styler.ColourTo(i, statePrintForState(SCE_HJ_SYMBOLS, inScriptType));
2362  			}
2363  		}
2364  	}
2365  	switch (state) {
2366  	case SCE_HJ_WORD:
2367  		classifyWordHTJS(styler.GetStartSegment(), lengthDoc - 1, keywords2, styler, inScriptType);
2368  		break;
2369  	case SCE_HB_WORD:
2370  		classifyWordHTVB(styler.GetStartSegment(), lengthDoc - 1, keywords3, styler, inScriptType);
2371  		break;
2372  	case SCE_HP_WORD:
2373  		classifyWordHTPy(styler.GetStartSegment(), lengthDoc - 1, keywords4, styler, prevWord, inScriptType, isMako);
2374  		break;
2375  	case SCE_HPHP_WORD:
2376  		classifyWordHTPHP(styler.GetStartSegment(), lengthDoc - 1, keywords5, styler);
2377  		break;
2378  	default:
2379  		StateToPrint = statePrintForState(state, inScriptType);
2380  		if (static_cast<Sci_Position>(styler.GetStartSegment()) < lengthDoc)
2381  			styler.ColourTo(lengthDoc - 1, StateToPrint);
2382  		break;
2383  	}
2384  	if (fold) {
2385  		const int flagsNext = styler.LevelAt(lineCurrent) & ~SC_FOLDLEVELNUMBERMASK;
2386  		styler.SetLevel(lineCurrent, levelPrev | flagsNext);
2387  	}
2388  	styler.Flush();
2389  }
2390  LexerModule lmHTML(SCLEX_HTML, LexerHTML::LexerFactoryHTML, "hypertext", htmlWordListDesc);
2391  LexerModule lmXML(SCLEX_XML, LexerHTML::LexerFactoryXML, "xml", htmlWordListDesc);
2392  LexerModule lmPHPSCRIPT(SCLEX_PHPSCRIPT, LexerHTML::LexerFactoryPHPScript, "phpscript", phpscriptWordListDesc);
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexUser.cxx</h3>
            <pre><code>1  #include <string>
2  #include <map>
3  #include <vector>
4  #include <assert.h>
5  #include <windows.h>
6  #include "ILexer.h"
7  #include "LexAccessor.h"
8  #include "Accessor.h"
9  #include "StyleContext.h"
10  #include "WordList.h"
11  #include "Scintilla.h"
12  #include "SciLexer.h"
13  #include "LexerModule.h"
14  #include "PropSetSimple.h"
15  using namespace Lexilla;
16  #define CL_CURRENT  0x1
17  #define CL_PREV     0x2
18  #define CL_PREVPREV 0x4
19  #define FOLD_NONE   0
20  #define FOLD_OPEN   1
21  #define FOLD_MIDDLE 2
22  #define FOLD_CLOSE  3
23  #define COMMENTLINE_NO              0
24  #define COMMENTLINE_YES             1
25  #define COMMENTLINE_SKIP_TESTING    2
26  #define SEPARATOR_DOT      0
27  #define SEPARATOR_COMMA    1
28  #define SEPARATOR_BOTH     2
29  #define NI_OPEN     0
30  #define NI_CLOSE    1
31  #define NO_DELIMITER                    0
32  #define FORWARD_WHITESPACE_FOUND        1
33  #define FORWARD_KEYWORD_FOUND           2
34  #define SC_ISCOMMENTLINE      0x8000
35  #define MULTI_PART_LIMIT      100
36  #define PURE_LC_NONE    0   
37  #define PURE_LC_BOL     1
38  #define PURE_LC_WSP     2
39  #define EOL_DEFAULT_VALUE   0
40  #define EOL_SKIP_CHECK      1
41  #define EOL_FORCE_CHECK     2
42  #define MAPPER_TOTAL 15
43  #define FW_VECTORS_TOTAL SCE_USER_TOTAL_DELIMITERS + 9
44  const int maskMapper[MAPPER_TOTAL] =
45  {
46      SCE_USER_MASK_NESTING_OPERATORS2,
47      SCE_USER_MASK_NESTING_FOLDERS_IN_CODE2_OPEN,
48      SCE_USER_MASK_NESTING_FOLDERS_IN_CODE2_MIDDLE,
49      SCE_USER_MASK_NESTING_FOLDERS_IN_CODE2_CLOSE,
50      SCE_USER_MASK_NESTING_FOLDERS_IN_COMMENT_OPEN,
51      SCE_USER_MASK_NESTING_FOLDERS_IN_COMMENT_MIDDLE,
52      SCE_USER_MASK_NESTING_FOLDERS_IN_COMMENT_CLOSE,
53      SCE_USER_MASK_NESTING_KEYWORD1,
54      SCE_USER_MASK_NESTING_KEYWORD2,
55      SCE_USER_MASK_NESTING_KEYWORD3,
56      SCE_USER_MASK_NESTING_KEYWORD4,
57      SCE_USER_MASK_NESTING_KEYWORD5,
58      SCE_USER_MASK_NESTING_KEYWORD6,
59      SCE_USER_MASK_NESTING_KEYWORD7,
60      SCE_USER_MASK_NESTING_KEYWORD8
61  };
62  const int styleMapper[MAPPER_TOTAL] =
63  {
64      SCE_USER_STYLE_OPERATOR,
65      SCE_USER_STYLE_FOLDER_IN_CODE2,
66      SCE_USER_STYLE_FOLDER_IN_CODE2,
67      SCE_USER_STYLE_FOLDER_IN_CODE2,
68      SCE_USER_STYLE_FOLDER_IN_COMMENT,
69      SCE_USER_STYLE_FOLDER_IN_COMMENT,
70      SCE_USER_STYLE_FOLDER_IN_COMMENT,
71      SCE_USER_STYLE_KEYWORD1,
72      SCE_USER_STYLE_KEYWORD2,
73      SCE_USER_STYLE_KEYWORD3,
74      SCE_USER_STYLE_KEYWORD4,
75      SCE_USER_STYLE_KEYWORD5,
76      SCE_USER_STYLE_KEYWORD6,
77      SCE_USER_STYLE_KEYWORD7,
78      SCE_USER_STYLE_KEYWORD8
79  };
80  const int foldingtMapper[MAPPER_TOTAL] =
81  {
82      FOLD_NONE,
83      FOLD_OPEN,
84      FOLD_MIDDLE,
85      FOLD_CLOSE,
86      FOLD_OPEN,
87      FOLD_MIDDLE,
88      FOLD_CLOSE,
89      FOLD_NONE,
90      FOLD_NONE,
91      FOLD_NONE,
92      FOLD_NONE,
93      FOLD_NONE,
94      FOLD_NONE,
95      FOLD_NONE,
96      FOLD_NONE
97  };
98  using namespace std;
99  typedef vector<vector<string>> vvstring;
100  struct forwardStruct
101  {
102      vvstring * _vec;
103      int _sceID;
104      int _maskID;
105      forwardStruct(): _vec(0), _sceID(0), _maskID(0) {};    
106      forwardStruct * Set (vvstring * vec, int sceID, int maskID) {
107          _vec = vec;
108          _sceID = sceID;
109          _maskID = maskID;
110          return this;
111      }
112  }FWS;   
113  struct nestedInfo {
114      size_t _position;
115      int _nestedLevel;
116      int _index;
117      int _state;
118      int _opener;
119      nestedInfo():_position(0), _nestedLevel(0), _index(0), _state(0), _opener(0) {};
120      nestedInfo * Set (size_t position, int nestedLevel, int index, int state, int opener) {
121          _position = position;
122          _nestedLevel = nestedLevel;
123          _index = index;
124          _state = state;
125          _opener = opener;
126          return this;
127      }
128  };
129  static nestedInfo NI;   
130  struct udlKeywordsMapStruct
131  {
132      vvstring commentLineOpen, commentLineContinue, commentLineClose;
133      vvstring commentOpen, commentClose;
134      vvstring delim1Open, delim1Escape, delim1Close;
135      vvstring delim2Open, delim2Escape, delim2Close;
136      vvstring delim3Open, delim3Escape, delim3Close;
137      vvstring delim4Open, delim4Escape, delim4Close;
138      vvstring delim5Open, delim5Escape, delim5Close;
139      vvstring delim6Open, delim6Escape, delim6Close;
140      vvstring delim7Open, delim7Escape, delim7Close;
141      vvstring delim8Open, delim8Escape, delim8Close;
142      vvstring operators1;
143      vvstring foldersInCode1Open, foldersInCode1Middle, foldersInCode1Close;
144      vvstring foldersInCode2Open, foldersInCode2Middle, foldersInCode2Close;
145      vector<string> prefixTokens1;
146      vector<string> prefixTokens2;
147      vector<string> suffixTokens1;
148      vector<string> suffixTokens2;
149      vector<string> extrasTokens1;
150      vector<string> extrasTokens2;
151      vector<string> rangeTokens;
152      vector<string> negativePrefixTokens1;
153      vector<string> negativePrefixTokens2;
154      vector<string> negativeExtrasTokens2;
155  };
156  typedef map<int, udlKeywordsMapStruct> udlMapType;
157  static udlMapType udlKeywordsMap;
158  typedef map<int, vector<nestedInfo> > nestedMapType;
159  static nestedMapType nestedMap;
160  static inline bool isWhiteSpace(const int ch)
161  {
162      return (ch > 0 && ch < 0x21);
163  }
164  static inline bool isWhiteSpace2(unsigned char ch, int & nlCount, unsigned char excludeNewLine=0, unsigned char chNext=0)
165  {
166      if ((ch == '\n') || (ch == '\r' && chNext != '\n'))
167          ++nlCount;
168      if (excludeNewLine == '\b')
169          return (ch == ' ') || (ch == '\t');
170      else
171          return isWhiteSpace(ch);
172  }
173  static bool isInListForward2(vvstring * fwEndVectors[], int totalVectors, StyleContext & sc, bool ignoreCase, int forward)
174  {
175      vvstring::iterator iter1;
176      vector<string>::iterator iter2;
177      string::iterator iter3;
178      int index = 0;
179      int a = 0;
180      int b = 0;
181      for (int i=0; i<totalVectors; ++i)
182      {
183          if (fwEndVectors[i] && !fwEndVectors[i]->empty())
184          {
185              index = 0;
186              a = 0;
187              b = 0;
188              for (iter1 = fwEndVectors[i]->begin(); iter1 != fwEndVectors[i]->end(); ++iter1)
189              {
190                  iter2 = iter1->begin();
191                  for (; iter2 != iter1->end(); ++iter2)
192                  {
193                      iter3 = iter2->begin();
194                      index = 0;
195                      for (; ; ++iter3)
196                      {
197                          a = ignoreCase?toupper(*iter3):*iter3;
198                          b = ignoreCase?toupper(sc.GetRelative(forward + index++)):sc.GetRelative(forward + index++);
199                          if (a != b)
200                              break;
201                          if (iter3 != iter2->end())
202                              return true;
203                      }
204                  }
205              }
206          }
207      }
208      return false;
209  }
210  static bool isInListForward3(vector<string> * tokens, StyleContext & sc, bool ignoreCase, Sci_Position offset, size_t & moveForward)
211  {
212      moveForward = 0;
213      unsigned char a = 0;
214      unsigned char b = 0;
215      Sci_Position indexb = 0;
216      bool isFound = false;
217      vector<string>::iterator iter1;
218      string::iterator iter2;
219      for (iter1 = tokens->begin(); iter1 != tokens->end(); ++iter1)
220      {
221          a = 0;
222          b = 0;
223          indexb = 0;
224          isFound = true;
225          for (iter2 = iter1->begin(); iter2 != iter1->end(); ++iter2)
226          {
227              a = static_cast<unsigned char>(ignoreCase?toupper(*iter2):*iter2);
228              b = static_cast<unsigned char>(ignoreCase?toupper(sc.GetRelative(offset + indexb++)):sc.GetRelative(offset + indexb++));
229              if (a != b)
230              {
231                  isFound = false;
232                  break;
233              }
234          }
235          if (isFound == true)
236          {
237              moveForward += iter1->length();
238              break;
239          }
240      }
241      return isFound;
242  }
243  static inline bool IsADigit(char ch)
244  {
245      return isascii(ch) && isdigit(ch);
246  }
247  static bool IsNumber(StyleContext & sc, vector<string> * numberTokens[], vvstring * fwEndVectors[],
248                       bool ignoreCase, int  decSeparator, size_t & moveForward )
249  {
250      moveForward = 0;
251      bool hasDot = false;
252      bool hasPrefix1 = false;
253      bool hasPrefix2 = false;
254      bool hasSuffix1 = false;
255      bool hasSuffix2 = false;
256      bool hasExtras2 = false;
257      bool hasRange = false;
258      bool hasExp = false;
259      bool previousWasRange = false;
260      Sci_Position offset = 0;
261      vector<string> * prefixTokens1          = numberTokens[0];
262      vector<string> * prefixTokens2          = numberTokens[1];
263      vector<string> * extrasTokens1          = numberTokens[2];
264      vector<string> * extrasTokens2          = numberTokens[3];
265      vector<string> * suffixTokens1          = numberTokens[4];
266      vector<string> * suffixTokens2          = numberTokens[5];
267      vector<string> * rangeTokens            = numberTokens[6];
268      vector<string> * negativePrefixTokens1  = numberTokens[7];
269      vector<string> * negativePrefixTokens2  = numberTokens[8];
270      vector<string> * negativeExtrasTokens2  = numberTokens[9];
271      if (((decSeparator == SEPARATOR_BOTH || decSeparator == SEPARATOR_DOT) && sc.ch == '.') ||
272          ((decSeparator == SEPARATOR_BOTH || decSeparator == SEPARATOR_COMMA) && sc.ch == ','))
273      {
274          if (IsADigit(sc.chNext))
275          {
276              hasDot = true;
277              offset = 2;
278          }
279      }
280      else
281      {
282          vector<string>::iterator iter = prefixTokens2->begin();
283          vector<string>::iterator last = prefixTokens2->end();
284          if (sc.ch == '-')
285          {
286              iter = negativePrefixTokens2->begin();
287              last = negativePrefixTokens2->end();
288          }
289          for (; iter != last; ++iter)
290          {
291              if (ignoreCase?sc.MatchIgnoreCase2(iter->c_str()) : sc.Match(iter->c_str()))
292                  break;
293          }
294          if (iter != last)
295          {
296              size_t skipForward = 0;
297              if (isInListForward3(extrasTokens1, sc, ignoreCase, iter->length(), skipForward))
298              {
299                  offset += iter->length() + skipForward;
300                  hasPrefix2 = true;
301                  hasExp = true;  
302              }
303              else if (IsADigit(sc.GetRelative(iter->length())))
304              {
305                  offset += iter->length() + 1;
306                  hasPrefix2 = true;
307                  hasExp = true;  
308              }
309          }
310          if (hasPrefix2 == false)
311          {
312              vector<string>::iterator iter = prefixTokens1->begin();
313              vector<string>::iterator last = prefixTokens1->end();
314              if (sc.ch == '-')
315              {
316                  iter = negativePrefixTokens1->begin();
317                  last = negativePrefixTokens1->end();
318              }
319              for (; iter != last; ++iter)
320              {
321                  if (ignoreCase?sc.MatchIgnoreCase2(iter->c_str()) : sc.Match(iter->c_str()))
322                      break;
323              }
324              if (iter != last)
325              {
326                  if (IsADigit(sc.GetRelative(iter->length())))
327                  {
328                      offset += iter->length() + 1;
329                      hasPrefix1 = true;
330                      hasPrefix2 = false;     
331                      hasExp = true;          
332                  }
333              }
334          }
335          if (hasPrefix1 == false && hasPrefix2 == false)
336          {
337              vector<string>::iterator iter = extrasTokens2->begin();
338              vector<string>::iterator last = extrasTokens2->end();
339              if (sc.ch == '-')
340              {
341                  iter = negativeExtrasTokens2->begin();
342                  last = negativeExtrasTokens2->end();
343              }
344              for (; iter != last; ++iter)
345              {
346                  if (ignoreCase?sc.MatchIgnoreCase2(iter->c_str()) : sc.Match(iter->c_str()))
347                      break;
348              }
349              if (iter != last)
350              {
351                  offset += iter->length();
352                  hasExtras2 = true;
353                  hasExp = true;  
354              }
355          }
356      }
357      if (offset == 0)
358      {
359          if (IsADigit(sc.ch))
360          {
361              offset = 1;
362          }
363          else if ((sc.ch == '-' || sc.ch == '+') && IsADigit(sc.chNext) && !IsADigit(sc.chPrev))
364          {
365              offset = 2;
366          }
367          if (offset == 0)
368              return false;
369      }
370      size_t skipForward = 0;
371      for (;;)
372      {
373          skipForward = 0;
374          if (isWhiteSpace(sc.GetRelative(offset)) || isInListForward2(fwEndVectors, 12, sc, ignoreCase, offset))
375          {
376              if (hasExtras2 == true && hasSuffix1 == false)
377                  return false;
378              moveForward = offset;
379              return true;    
380          }
381          if (hasRange == false)
382          {
383              if (isInListForward3(rangeTokens, sc, ignoreCase, offset, skipForward))
384              {
385                  if (hasExtras2 == true && hasSuffix1 == false)
386                      return false;
387                  offset += skipForward;
388                  hasSuffix1 = false;
389                  hasSuffix2 = false;
390                  hasDot = false;
391                  hasRange = true;
392                  hasExp = false;
393                  hasExtras2 = false;
394                  previousWasRange = true;
395                  continue;
396              }
397          }
398          if (hasSuffix2 == true)  
399              return false;
400          if (hasPrefix2 == true)
401          {
402              if (isInListForward3(extrasTokens1, sc, ignoreCase, offset, skipForward))
403              {
404                  offset += skipForward;
405                  continue;
406              }
407          }
408          if (hasSuffix1 == false && hasPrefix1 == false && hasPrefix2 == false)
409          {
410              if (isInListForward3(suffixTokens1, sc, ignoreCase, offset, skipForward))
411              {
412                  offset += skipForward;
413                  hasExtras2 = false;
414                  hasSuffix1 = true;
415                  continue;
416              }
417              if (isInListForward3(extrasTokens2, sc, ignoreCase, offset, skipForward))
418              {
419                  offset += skipForward;
420                  hasExtras2 = true;
421                  hasExp = true;  
422                  continue;
423              }
424          }
425          if (hasSuffix2 == false)
426          {
427              if (isInListForward3(suffixTokens2, sc, ignoreCase, offset, skipForward))
428              {
429                  offset += skipForward;
430                  hasSuffix2 = true;
431                  continue;
432              }
433          }
434          if (previousWasRange == true)   
435          {                               
436              if (isInListForward3(prefixTokens2, sc, ignoreCase, offset, skipForward))
437              {
438                  offset += skipForward;
439                  hasExp = false;
440                  hasPrefix2 = true;
441                  continue;
442              }
443              if (isInListForward3(prefixTokens1, sc, ignoreCase, offset, skipForward))
444              {
445                  offset += skipForward;
446                  hasExp = false;
447                  hasPrefix1 = true;
448                  continue;
449              }
450          }
451          if (IsADigit(sc.GetRelative(offset)))
452          {
453              offset += 1;
454              continue;
455          }
456          if (hasDot == false)
457          {
458              if (((decSeparator == SEPARATOR_BOTH || decSeparator == SEPARATOR_DOT) &&
459                      (sc.GetRelative(offset) == '.'))
460                      ||
461                  ((decSeparator == SEPARATOR_BOTH || decSeparator == SEPARATOR_COMMA) &&
462                      (sc.GetRelative(offset) == ',')))
463              {
464                  if (IsADigit(sc.GetRelative(offset + 1)))
465                  {
466                      if (IsADigit(sc.GetRelative(offset - 1)) || previousWasRange == true)
467                      {
468                          offset += 2;
469                          hasDot = true;
470                          continue;
471                      }
472                  }
473              }
474          }
475          if (hasExp == false)
476          {
477              if (toupper(sc.GetRelative(offset)) == 'E') 
478              {
479                  unsigned char chPrev = sc.GetRelative(offset - 1);
480                  unsigned char chNext = sc.GetRelative(offset + 1);
481                  unsigned char chNextNext = sc.GetRelative(offset + 2);
482                  if (IsADigit(chPrev))
483                  {
484                      int move = 0;
485                      if (IsADigit(chNext))
486                      {
487                          move = 1;
488                      }
489                      else if ((chNext == '+' || chNext == '-') && IsADigit(chNextNext))
490                      {
491                          move = 2;
492                      }
493                      if (move > 0)
494                      {
495                          offset += move;
496                          hasPrefix2 = false; 
497                          hasDot    = false;
498                          hasExp    = true;
499                          continue;
500                      }
501                  }
502              }
503          }
504          return false;
505      }
506  }
507  static inline void SubGroup(const char * s, vvstring & vec, bool group=false)
508  {
509      size_t length = strlen(s);
510      char * temp = new char[length+1];
511      unsigned int index = 0;
512      vector<string> subvector;
513      unsigned int i = 0;
514      for (unsigned int j=0; j<length+1; ++j)
515          temp[j] = 0;
516      if (length >= 2 && s[0] == '(' && s[1]  == '(')
517      {
518          i = 2;
519          group = true;
520      }
521  	if (length >= 2 && s[length - 1] == ')' && s[length - 2] == ')')
522          length -= 2;
523      if (!group && *s)
524      {
525          subvector.push_back(s);
526      }
527      else
528      {
529          for (; i<length; ++i)
530          {
531              if (s[i] == ' ')
532              {
533                  if (*temp)
534                  {
535                      if (!strcmp(temp, "EOL"))
536                      {
537                          subvector.push_back("\r\n");
538                          subvector.push_back("\n");
539                          subvector.push_back("\r");
540                      }
541                      else
542                          subvector.push_back(temp);
543                      index = 0;
544                      for (unsigned int j=0; j<length; ++j)
545                          temp[j] = 0;
546                  }
547              }
548              else if (i == length-1)
549              {
550                  temp[index++] = s[i];
551                  if (*temp)
552                  {
553                      if (!strcmp(temp, "EOL"))
554                      {
555                          subvector.push_back("\r\n");
556                          subvector.push_back("\n");
557                          subvector.push_back("\r");
558                      }
559                      else
560                          subvector.push_back(temp);
561                  }
562              }
563              else
564              {
565                  temp[index++] = s[i];
566              }
567          }
568      }
569      if (!subvector.empty())
570          vec.push_back(subvector);
571      delete [] temp;
572  }
573  static inline void GenerateVector(vvstring & vec, const char * s, const char * prefix, size_t minLength)
574  {
575      size_t length = strlen(s);
576      char * temp = new char[length];
577      unsigned int index = 0;
578      bool copy = false;
579      bool inGroup = false;
580      for (unsigned int j=0; j<length; ++j)
581          temp[j] = 0;
582      vec.clear();
583      for (unsigned int i=0; i<length; ++i)
584      {
585          if (copy && !inGroup && s[i] == ' ')
586          {
587              SubGroup(temp, vec, inGroup);
588              index = 0;
589              copy = false;
590              for (unsigned int j=0; j<length; ++j)
591                  temp[j] = 0;
592          }
593          if ( (s[i] == ' ' && s[i+1] == prefix[0] && s[i+2] == prefix[1] && s[i+3] != ' ') ||
594               (   i == 0   &&   s[0] == prefix[0] &&   s[1] == prefix[1] && s[i+2] != ' ') )
595          {
596              if (i > 0)  i += 1; 
597              i += 2;             
598              copy = true;
599              if (s[i] == ' ')
600                  continue;
601              if (s[i] == '(' && s[i+1] == '(')
602                  inGroup = true;
603          }
604          if (inGroup && s[i] == ')' && s[i+1] == ')')
605              inGroup = false;
606          if (copy)
607              temp[index++] = s[i];
608      }
609      if (length)
610          SubGroup(temp, vec, inGroup);
611      vector<string> emptyVector;
612      for (size_t i = vec.size(); i < minLength; ++i)
613      {
614          vec.push_back(emptyVector);
615      }
616      delete [] temp;
617  }
618  static inline void StringToVector(char * original, vector<string> & tokenVector, bool negative=false)
619  {
620      string temp = "";
621      char * pch = original;
622      while (*pch != '\0')
623      {
624          if (*pch != ' ')
625              temp += *pch;   
626          else if (temp.size() > 0)
627          {
628              if (negative)
629                  tokenVector.push_back("-" + temp);
630              else
631                  tokenVector.push_back(temp);
632              temp = "";
633          }
634          ++pch;
635      }
636      if (temp.size() > 0)
637      {
638          if (negative)
639              tokenVector.push_back("-" + temp);
640          else
641              tokenVector.push_back(temp);
642      }
643  }
644  static inline void ReColoringCheck(Sci_PositionU & startPos, int & nestedLevel, int & initStyle, int & openIndex,
645                                     int & isCommentLine, bool & isInComment, Accessor & styler, vector<nestedInfo> & lastNestedGroup,
646                                     vector<nestedInfo> & nestedVector, &bsol;* vector<int> & foldVector, */ int & continueCommentBlock)
647  {
648      if (startPos > 0)
649      {
650          initStyle = styler.StyleAt(startPos-1); 
651          if ( (initStyle >= SCE_USER_STYLE_KEYWORD1 && initStyle < (SCE_USER_STYLE_KEYWORD1+SCE_USER_TOTAL_KEYWORD_GROUPS))    
652                || initStyle == SCE_USER_STYLE_FOLDER_IN_COMMENT
653                || initStyle == SCE_USER_STYLE_FOLDER_IN_CODE2 )
654          {
655              while (startPos > 0 && styler.StyleAt(--startPos) == initStyle);
656          }
657      }
658      if (startPos > 0)
659      {
660          char ch = 0;
661          do
662          {
663              ch = styler.SafeGetCharAt(--startPos);
664          }
665          while(ch != '\r' && ch != '\n' && startPos > 0);
666          if (startPos > 0)
667              startPos += 1;  
668      }
669      if (startPos == 0)
670      {
671          nestedVector.clear();
672          lastNestedGroup.clear();
673          initStyle = SCE_USER_STYLE_IDENTIFIER;
674          return;
675      }
676      vector<nestedInfo>::iterator iter = nestedVector.begin();
677      for (; iter != nestedVector.end(); ++iter)
678      {
679          if (iter->_position >= startPos)
680          {
681              nestedVector.erase(iter, nestedVector.end());
682              break;
683          }
684      }
685      if (!nestedVector.empty())
686      {
687          iter = --nestedVector.end();
688          lastNestedGroup.clear();
689          while (iter->_nestedLevel > 1 && iter != nestedVector.begin())
690              --iter;
691      }
692      else
693      {
694          iter = nestedVector.end();
695      }
696      vector<nestedInfo>::iterator last;
697      while (iter != nestedVector.end())
698      {
699          if (iter->_opener == NI_OPEN)
700              lastNestedGroup.push_back(*iter);
701          else if (iter->_opener == NI_CLOSE && !lastNestedGroup.empty())
702          {
703              last = --lastNestedGroup.end();
704              if (last->_opener == NI_OPEN)
705                  if (last->_nestedLevel == iter->_nestedLevel)
706                      if (last->_state == iter->_state)
707                          if (last->_index == iter->_index)
708                              lastNestedGroup.erase(last);
709          }
710          ++iter;
711      }
712      if (!lastNestedGroup.empty())
713      {
714          last = --lastNestedGroup.end();
715          initStyle = last->_state;
716          openIndex = last->_index;
717          nestedLevel = last->_nestedLevel;
718          for (; ; --last)
719          {
720              if (last->_state == SCE_USER_STYLE_COMMENT)
721              {
722                  isInComment = true;
723                  isCommentLine = COMMENTLINE_YES;
724              }
725              if (last->_state == SCE_USER_STYLE_COMMENTLINE)
726              {
727                  isCommentLine = COMMENTLINE_YES;
728              }
729              if (last == lastNestedGroup.begin())
730                  break;
731          }
732      }
733      else
734      {
735          initStyle = SCE_USER_STYLE_IDENTIFIER;
736          openIndex = -1;
737          nestedLevel = 0;
738      }
739      int lineCurrent = styler.GetLine(startPos);
740      if ((styler.LevelAt(lineCurrent) & SC_ISCOMMENTLINE) != 0)
741          continueCommentBlock |= CL_CURRENT;
742      if (lineCurrent >= 1)
743          if ((styler.LevelAt(lineCurrent - 1) & SC_ISCOMMENTLINE) != 0)
744              continueCommentBlock |= CL_PREV;
745      if (lineCurrent >= 2)
746          if ((styler.LevelAt(lineCurrent - 2) & SC_ISCOMMENTLINE) != 0)
747              if (continueCommentBlock & CL_PREV)
748                  continueCommentBlock |= CL_PREVPREV;
749  }
750  static bool isInListForward(vvstring & openVector, StyleContext & sc, bool ignoreCase, int & openIndex, size_t & skipForward)
751  {
752      skipForward = 0;
753      vector<vector<string>>::iterator iter1 = openVector.begin();
754      vector<string>::iterator iter2;
755      for (; iter1 != openVector.end(); ++iter1)
756      {
757          iter2 = iter1->begin();
758          for (; iter2 != iter1->end(); ++iter2)
759          {
760              if (ignoreCase?sc.MatchIgnoreCase2(iter2->c_str()):sc.Match(iter2->c_str()))
761              {
762                  openIndex = iter1 - openVector.begin();
763                  skipForward = iter2->length();
764                  return true;
765              }
766          }
767      }
768      return false;
769  }
770  static bool isInListBackward(WordList & list, StyleContext & sc, bool specialMode, bool ignoreCase,
771                               int & moveForward, vvstring * fwEndVectors[], int & nlCount, size_t docLength)
772  {
773      if (!list.Length())
774          return false;
775      moveForward = 0;
776      int offset = -1 * sc.LengthCurrent();   
777      unsigned char a = 0;    
778      unsigned char b = 0;    
779      unsigned char bNext = 0;
780      unsigned char wsChar = 0;
781      unsigned char firstChar = sc.GetRelative(offset);
782      int fwDelimiterFound = NO_DELIMITER;
783      int nlCountTemp = 0;
784      int indexa = 0;
785      int indexb = 0;
786      int i = list.StartAt(firstChar);
787      bool doUpperLoop = ignoreCase;
788      if (ignoreCase)
789      {
790          i = list.StartAt(tolower(firstChar));
791          if (i == -1)
792          {
793              i = list.StartAt(toupper(firstChar));
794              if (i == -1)
795                  return false;
796              doUpperLoop = false;
797          }
798      }
799      while (i >= 0)
800      {
801          while (static_cast<unsigned char>(ignoreCase?toupper(list.WordAt(i)[0]):list.WordAt(i)[0]) == (ignoreCase?toupper(firstChar):firstChar))
802          {
803              a = 0;
804              b = 0;
805              bNext = 0;
806              indexa = 0;
807              indexb = 0;
808              wsChar = 0;
809              fwDelimiterFound = NO_DELIMITER;
810              do
811              {
812                  a = static_cast<unsigned char>(ignoreCase?toupper(list.WordAt(i)[indexa++]):list.WordAt(i)[indexa++]);
813                  if (a == '\v' || a == '\b')
814                  {
815                      wsChar = a;
816                      b = sc.GetRelative(offset + indexb++);
817                      bNext = sc.GetRelative(offset + indexb);
818                      if (isWhiteSpace2(b, nlCountTemp, wsChar, bNext))
819                      {
820                          do {
821                              b = sc.GetRelative(offset + indexb++);
822                              bNext = sc.GetRelative(offset + indexb);
823                          }
824                          while((sc.currentPos + offset + indexb) <= docLength && isWhiteSpace2(b, nlCountTemp, wsChar, bNext));
825                          a = static_cast<unsigned char>(ignoreCase?toupper(list.WordAt(i)[indexa++]):list.WordAt(i)[indexa++]);
826                      }
827                      b = ignoreCase?toupper(b):b;
828                  }
829                  else
830                      b = ignoreCase?toupper(sc.GetRelative(offset + indexb++)):sc.GetRelative(offset + indexb++);
831              }
832              while (a && (a == b));
833              if (!a)
834              {
835                  --indexb;   
836                  if (wsChar)
837                  {
838                      bNext = sc.GetRelative(indexb + offset);
839                      if (isWhiteSpace(bNext))
840                          fwDelimiterFound = FORWARD_WHITESPACE_FOUND;
841                      if (fwDelimiterFound == NO_DELIMITER)
842                      {
843                          if (isInListForward2(fwEndVectors, FW_VECTORS_TOTAL, sc, ignoreCase, indexb + offset))
844                          {
845                              fwDelimiterFound = FORWARD_KEYWORD_FOUND;
846                          }
847                      }
848                      if (specialMode)
849                      {
850                          if (fwDelimiterFound == FORWARD_WHITESPACE_FOUND)    
851                          {
852                              int savedPosition = indexb;     
853                              for (;;)
854                              {
855                                  if ((sc.currentPos + offset + indexb) > docLength)
856                                      break;
857                                  if (!isWhiteSpace2(sc.GetRelative(offset + indexb), nlCountTemp, wsChar, sc.GetRelative(offset + indexb + 1)))
858                                      break;
859                                  ++indexb;
860                              }
861                              bool nextWordFound = false;
862                              while (!isWhiteSpace2(sc.GetRelative(indexb + offset, ' '), nlCountTemp, wsChar, sc.GetRelative(offset + indexb + 1, ' ')))
863                              {
864                                  if (isInListForward2(fwEndVectors, FW_VECTORS_TOTAL, sc, ignoreCase, indexb + offset))
865                                  {
866                                      break;
867                                  }
868                                  ++indexb;
869                                  nextWordFound = true;
870                              }
871                              if (nextWordFound == false)
872                                  indexb = savedPosition;
873                          }
874                      }
875                  }
876                  nlCount += nlCountTemp;
877                  moveForward = indexb + offset;  
878                  if (wsChar)
879                  {
880                      if (fwDelimiterFound != NO_DELIMITER)
881                          return true;    
882                  }
883                  else if (moveForward == 0)
884                      return true;    
885                  else if (specialMode)
886                      return true;    
887              }
888              nlCountTemp = 0;
889              ++i;
890          }
891          if (doUpperLoop)
892          {
893              i = list.StartAt(toupper(firstChar));
894              doUpperLoop = false;
895          }
896          else
897              break;
898      }
899      return false;
900  }
901  static void setBackwards(WordList * kwLists[], StyleContext & sc, bool prefixes[], bool ignoreCase,
902                           int nestedKey, vvstring * fwEndVectors[], int & levelMinCurrent,
903                           int & levelNext, int & nlCount, bool & dontMove, size_t docLength)
904  {
905      if (sc.LengthCurrent() == 0)
906          return;
907      int folding = FOLD_NONE;
908      int moveForward = 0;
909      for (int i=0; i<MAPPER_TOTAL; ++i)
910      {
911          if (nestedKey & maskMapper[i])
912          {
913              if (isInListBackward(*kwLists[i], sc, prefixes[i], ignoreCase, moveForward, fwEndVectors, nlCount, docLength))
914              {
915                  folding = foldingtMapper[i];
916                  if (moveForward > 0)
917                  {
918                      sc.Forward(moveForward);
919                      dontMove = true;
920                  }
921                  sc.ChangeState(styleMapper[i]);
922                  break;
923              }
924          }
925      }
926      if (folding == FOLD_MIDDLE)
927      {
928          levelNext--;
929          folding = FOLD_OPEN;
930      }
931      if (folding == FOLD_OPEN)
932      {
933          if (levelMinCurrent > levelNext)
934              levelMinCurrent = levelNext;
935          levelNext++;
936      }
937      else if (folding == FOLD_CLOSE)
938      {
939          levelNext--;
940      }
941  }
942  static bool isInListNested(int nestedKey, vector<forwardStruct> & forwards, StyleContext & sc,
943                             bool ignoreCase, int & openIndex, size_t & skipForward, int & newState, int pureLC,
944                             bool visibleChars, vector<string> * numberTokens[], vvstring ** numberDelims, int decSeparator)
945  {
946      int backup = openIndex;
947      vector<forwardStruct>::iterator iter = forwards.begin();
948      for (; iter != forwards.end(); ++iter)
949      {
950          if (nestedKey & iter->_maskID)
951          {
952              if ((iter->_maskID != SCE_USER_MASK_NESTING_COMMENT_LINE) ||
953                  (iter->_maskID == SCE_USER_MASK_NESTING_COMMENT_LINE &&
954                      ((pureLC == PURE_LC_NONE) ||
955                       (pureLC == PURE_LC_BOL && (sc.chPrev == '\r' || sc.chPrev == '\n')) ||
956                       (pureLC == PURE_LC_WSP && visibleChars == false))))
957              {
958                  if (isInListForward(*(iter->_vec), sc, ignoreCase, openIndex, skipForward))
959                  {
960                      newState = iter->_sceID;
961                      return true;
962                  }
963              }
964          }
965      }
966      if (nestedKey & SCE_USER_MASK_NESTING_NUMBERS)
967      {
968          if (IsNumber(sc, numberTokens, numberDelims, ignoreCase, decSeparator, skipForward))
969          {
970              newState = SCE_USER_STYLE_NUMBER;
971              return true;
972          }
973      }
974      openIndex = backup;
975      return false;
976  }
977  static void readLastNested(vector<nestedInfo> & lastNestedGroup, int & newState, int & openIndex)
978  {
979      newState = SCE_USER_STYLE_IDENTIFIER;
980      openIndex = -1;
981      if (!lastNestedGroup.empty())
982      {
983          lastNestedGroup.erase(lastNestedGroup.end()-1);
984          if (!lastNestedGroup.empty())
985          {
986              newState = (--lastNestedGroup.end())->_state;
987              openIndex = (--lastNestedGroup.end())->_index;
988          }
989      }
990  }
991  static void ColouriseUserDoc(Sci_PositionU startPos, Sci_Position length, int initStyle, WordList *kwLists[], Accessor &styler)
992  {
993      bool foldComments = styler.GetPropertyInt("userDefine.allowFoldOfComments", 0) != 0;
994      bool ignoreCase   = styler.GetPropertyInt("userDefine.isCaseIgnored",       0) != 0;
995      bool foldCompact  = styler.GetPropertyInt("userDefine.foldCompact",         0) != 0;
996      int pureLC = styler.GetPropertyInt("userDefine.forcePureLC", 0);
997      bool prefixes[MAPPER_TOTAL];
998      for (int i=0; i<MAPPER_TOTAL; ++i)    
999          prefixes[i] = false;
1000      prefixes[7]  = styler.GetPropertyInt("userDefine.prefixKeywords1", 0) != 0;
1001      prefixes[8]  = styler.GetPropertyInt("userDefine.prefixKeywords2", 0) != 0;
1002      prefixes[9]  = styler.GetPropertyInt("userDefine.prefixKeywords3", 0) != 0;
1003      prefixes[10] = styler.GetPropertyInt("userDefine.prefixKeywords4", 0) != 0;
1004      prefixes[11] = styler.GetPropertyInt("userDefine.prefixKeywords5", 0) != 0;
1005      prefixes[12] = styler.GetPropertyInt("userDefine.prefixKeywords6", 0) != 0;
1006      prefixes[13] = styler.GetPropertyInt("userDefine.prefixKeywords7", 0) != 0;
1007      prefixes[14] = styler.GetPropertyInt("userDefine.prefixKeywords8", 0) != 0;
1008      char nestingBuffer[] = "userDefine.nesting.00";     
1009      _itoa(SCE_USER_STYLE_COMMENT,       (nestingBuffer+20), 10);    int commentNesting      = styler.GetPropertyInt(nestingBuffer, 0);
1010      _itoa(SCE_USER_STYLE_COMMENTLINE,   (nestingBuffer+20), 10);    int lineCommentNesting  = styler.GetPropertyInt(nestingBuffer, 0);
1011      _itoa(SCE_USER_STYLE_DELIMITER1,    (nestingBuffer+19), 10);    int delim1Nesting       = styler.GetPropertyInt(nestingBuffer, 0);  
1012      _itoa(SCE_USER_STYLE_DELIMITER2,    (nestingBuffer+19), 10);    int delim2Nesting       = styler.GetPropertyInt(nestingBuffer, 0);  
1013      _itoa(SCE_USER_STYLE_DELIMITER3,    (nestingBuffer+19), 10);    int delim3Nesting       = styler.GetPropertyInt(nestingBuffer, 0);
1014      _itoa(SCE_USER_STYLE_DELIMITER4,    (nestingBuffer+19), 10);    int delim4Nesting       = styler.GetPropertyInt(nestingBuffer, 0);
1015      _itoa(SCE_USER_STYLE_DELIMITER5,    (nestingBuffer+19), 10);    int delim5Nesting       = styler.GetPropertyInt(nestingBuffer, 0);
1016      _itoa(SCE_USER_STYLE_DELIMITER6,    (nestingBuffer+19), 10);    int delim6Nesting       = styler.GetPropertyInt(nestingBuffer, 0);
1017      _itoa(SCE_USER_STYLE_DELIMITER7,    (nestingBuffer+19), 10);    int delim7Nesting       = styler.GetPropertyInt(nestingBuffer, 0);
1018      _itoa(SCE_USER_STYLE_DELIMITER8,    (nestingBuffer+19), 10);    int delim8Nesting       = styler.GetPropertyInt(nestingBuffer, 0);
1019      commentNesting  |= SCE_USER_MASK_NESTING_FOLDERS_IN_COMMENT_OPEN
1020                      |  SCE_USER_MASK_NESTING_FOLDERS_IN_COMMENT_MIDDLE
1021                      |  SCE_USER_MASK_NESTING_FOLDERS_IN_COMMENT_CLOSE;
1022      lineCommentNesting  |= SCE_USER_MASK_NESTING_FOLDERS_IN_COMMENT_OPEN
1023                          |  SCE_USER_MASK_NESTING_FOLDERS_IN_COMMENT_MIDDLE
1024                          |  SCE_USER_MASK_NESTING_FOLDERS_IN_COMMENT_CLOSE;
1025      const int bwNesting = SCE_USER_MASK_NESTING_KEYWORD1
1026                          | SCE_USER_MASK_NESTING_KEYWORD2
1027                          | SCE_USER_MASK_NESTING_KEYWORD3
1028                          | SCE_USER_MASK_NESTING_KEYWORD4
1029                          | SCE_USER_MASK_NESTING_KEYWORD5
1030                          | SCE_USER_MASK_NESTING_KEYWORD6
1031                          | SCE_USER_MASK_NESTING_KEYWORD7
1032                          | SCE_USER_MASK_NESTING_KEYWORD8
1033                          | SCE_USER_MASK_NESTING_OPERATORS2
1034                          | SCE_USER_MASK_NESTING_FOLDERS_IN_COMMENT_OPEN
1035                          | SCE_USER_MASK_NESTING_FOLDERS_IN_COMMENT_MIDDLE
1036                          | SCE_USER_MASK_NESTING_FOLDERS_IN_COMMENT_CLOSE
1037                          | SCE_USER_MASK_NESTING_FOLDERS_IN_CODE2_OPEN
1038                          | SCE_USER_MASK_NESTING_FOLDERS_IN_CODE2_MIDDLE
1039                          | SCE_USER_MASK_NESTING_FOLDERS_IN_CODE2_CLOSE;
1040      int currentBufferID = styler.GetPropertyInt("userDefine.currentBufferID", 0);
1041      if (nestedMap.find(currentBufferID) == nestedMap.end())
1042      {
1043          nestedMap[currentBufferID] = vector<nestedInfo>();
1044      }
1045      vector<nestedInfo> & nestedVector = nestedMap[currentBufferID];
1046      int sUdlName = styler.GetPropertyInt("userDefine.udlName", 0);
1047      if (udlKeywordsMap.find(sUdlName) == udlKeywordsMap.end())
1048      {
1049          udlKeywordsMap[sUdlName] = udlKeywordsMapStruct();
1050      }
1051      vvstring & commentLineOpen      = udlKeywordsMap[sUdlName].commentLineOpen;
1052      vvstring & commentLineContinue  = udlKeywordsMap[sUdlName].commentLineContinue;
1053      vvstring & commentLineClose     = udlKeywordsMap[sUdlName].commentLineClose;
1054      vvstring & commentOpen          = udlKeywordsMap[sUdlName].commentOpen;
1055      vvstring & commentClose         = udlKeywordsMap[sUdlName].commentClose;
1056      vvstring & delim1Open           = udlKeywordsMap[sUdlName].delim1Open;
1057      vvstring & delim1Escape         = udlKeywordsMap[sUdlName].delim1Escape;
1058      vvstring & delim1Close          = udlKeywordsMap[sUdlName].delim1Close;
1059      vvstring & delim2Open           = udlKeywordsMap[sUdlName].delim2Open;
1060      vvstring & delim2Escape         = udlKeywordsMap[sUdlName].delim2Escape;
1061      vvstring & delim2Close          = udlKeywordsMap[sUdlName].delim2Close;
1062      vvstring & delim3Open           = udlKeywordsMap[sUdlName].delim3Open;
1063      vvstring & delim3Escape         = udlKeywordsMap[sUdlName].delim3Escape;
1064      vvstring & delim3Close          = udlKeywordsMap[sUdlName].delim3Close;
1065      vvstring & delim4Open           = udlKeywordsMap[sUdlName].delim4Open;
1066      vvstring & delim4Escape         = udlKeywordsMap[sUdlName].delim4Escape;
1067      vvstring & delim4Close          = udlKeywordsMap[sUdlName].delim4Close;
1068      vvstring & delim5Open           = udlKeywordsMap[sUdlName].delim5Open;
1069      vvstring & delim5Escape         = udlKeywordsMap[sUdlName].delim5Escape;
1070      vvstring & delim5Close          = udlKeywordsMap[sUdlName].delim5Close;
1071      vvstring & delim6Open           = udlKeywordsMap[sUdlName].delim6Open;
1072      vvstring & delim6Escape         = udlKeywordsMap[sUdlName].delim6Escape;
1073      vvstring & delim6Close          = udlKeywordsMap[sUdlName].delim6Close;
1074      vvstring & delim7Open           = udlKeywordsMap[sUdlName].delim7Open;
1075      vvstring & delim7Escape         = udlKeywordsMap[sUdlName].delim7Escape;
1076      vvstring & delim7Close          = udlKeywordsMap[sUdlName].delim7Close;
1077      vvstring & delim8Open           = udlKeywordsMap[sUdlName].delim8Open;
1078      vvstring & delim8Escape         = udlKeywordsMap[sUdlName].delim8Escape;
1079      vvstring & delim8Close          = udlKeywordsMap[sUdlName].delim8Close;
1080      vvstring & operators1           = udlKeywordsMap[sUdlName].operators1;
1081      vvstring & foldersInCode1Open   = udlKeywordsMap[sUdlName].foldersInCode1Open;
1082      vvstring & foldersInCode1Middle = udlKeywordsMap[sUdlName].foldersInCode1Middle;
1083      vvstring & foldersInCode1Close  = udlKeywordsMap[sUdlName].foldersInCode1Close;
1084      vector<string> & prefixTokens1          = udlKeywordsMap[sUdlName].prefixTokens1;
1085      vector<string> & prefixTokens2          = udlKeywordsMap[sUdlName].prefixTokens2;
1086      vector<string> & extrasTokens1          = udlKeywordsMap[sUdlName].extrasTokens1;
1087      vector<string> & extrasTokens2          = udlKeywordsMap[sUdlName].extrasTokens2;
1088      vector<string> & suffixTokens1          = udlKeywordsMap[sUdlName].suffixTokens1;
1089      vector<string> & suffixTokens2          = udlKeywordsMap[sUdlName].suffixTokens2;
1090      vector<string> & rangeTokens            = udlKeywordsMap[sUdlName].rangeTokens;
1091      vector<string> & negativePrefixTokens1  = udlKeywordsMap[sUdlName].negativePrefixTokens1;
1092      vector<string> & negativePrefixTokens2  = udlKeywordsMap[sUdlName].negativePrefixTokens2;
1093      vector<string> & negativeExtrasTokens2  = udlKeywordsMap[sUdlName].negativeExtrasTokens2;
1094      if (startPos == 0)
1095      {
1096          bool equal = true;
1097          bool isMultiPart = false;
1098          bool switchPerformed = true;
1099          while (switchPerformed)
1100          {
1101              switchPerformed = false;
1102              for (int i=0; i<MAPPER_TOTAL; ++i)  
1103              {
1104                  for (int j=0; j<kwLists[i]->Length(); ++j)   
1105                  {
1106                      equal = true;
1107                      int z = 0;
1108                      for (; kwLists[i]->WordAt(j)[z]; ++z)    
1109                      {
1110                          if (kwLists[i]->WordAt(j+1)[z] == '\v' || kwLists[i]->WordAt(j+1)[z] == '\b')
1111                              isMultiPart = true;
1112                          if (kwLists[i]->WordAt(j)[z] != kwLists[i]->WordAt(j+1)[z])
1113                          {
1114                              equal = false;
1115                              break;
1116                          }
1117                      }
1118                      if (!isMultiPart)   
1119                      {
1120                          for (int k=0; kwLists[i]->WordAt(j+1)[k]; ++k)
1121                          {
1122                              if (kwLists[i]->WordAt(j+1)[k] == '\v' || kwLists[i]->WordAt(j+1)[k] == '\b')
1123                              {
1124                                  isMultiPart = true;
1125                                  break;
1126                              }
1127                          }
1128                      }
1129                      if (equal && isMultiPart && kwLists[i]->WordAt(j+1)[z])  
1130                      {
1131                          const char * temp = kwLists[i]->WordAt(j);
1132                          kwLists[i]->SetWordAt(j, kwLists[i]->WordAt(j+1));
1133                          kwLists[i]->SetWordAt(j+1, temp);
1134                          switchPerformed = true;
1135                      }
1136                  }
1137              }
1138          }
1139          const char * sFoldersInCode1Open     = styler.pprops->Get("userDefine.foldersInCode1Open");
1140          const char * sFoldersInCode1Middle   = styler.pprops->Get("userDefine.foldersInCode1Middle");
1141          const char * sFoldersInCode1Close    = styler.pprops->Get("userDefine.foldersInCode1Close");
1142          const char * sDelimiters             = styler.pprops->Get("userDefine.delimiters");
1143          const char * sOperators1             = styler.pprops->Get("userDefine.operators1");
1144          const char * sComments               = styler.pprops->Get("userDefine.comments");
1145          GenerateVector(commentLineOpen,     sComments,   "00", 0);
1146          GenerateVector(commentLineContinue, sComments,   "01", commentLineOpen.size());
1147          GenerateVector(commentLineClose,    sComments,   "02", commentLineOpen.size());
1148          GenerateVector(commentOpen,         sComments,   "03", 0);
1149          GenerateVector(commentClose,        sComments,   "04", commentOpen.size());
1150          GenerateVector(delim1Open,          sDelimiters, "00", 0);
1151          GenerateVector(delim1Escape,        sDelimiters, "01", delim1Open.size());
1152          GenerateVector(delim1Close,         sDelimiters, "02", delim1Open.size());
1153          GenerateVector(delim2Open,          sDelimiters, "03", 0);
1154          GenerateVector(delim2Escape,        sDelimiters, "04", delim2Open.size());
1155          GenerateVector(delim2Close,         sDelimiters, "05", delim2Open.size());
1156          GenerateVector(delim3Open,          sDelimiters, "06", 0);
1157          GenerateVector(delim3Escape,        sDelimiters, "07", delim3Open.size());
1158          GenerateVector(delim3Close,         sDelimiters, "08", delim3Open.size());
1159          GenerateVector(delim4Open,          sDelimiters, "09", 0);
1160          GenerateVector(delim4Escape,        sDelimiters, "10", delim4Open.size());
1161          GenerateVector(delim4Close,         sDelimiters, "11", delim4Open.size());
1162          GenerateVector(delim5Open,          sDelimiters, "12", 0);
1163          GenerateVector(delim5Escape,        sDelimiters, "13", delim5Open.size());
1164          GenerateVector(delim5Close,         sDelimiters, "14", delim5Open.size());
1165          GenerateVector(delim6Open,          sDelimiters, "15", 0);
1166          GenerateVector(delim6Escape,        sDelimiters, "16", delim6Open.size());
1167          GenerateVector(delim6Close,         sDelimiters, "17", delim6Open.size());
1168          GenerateVector(delim7Open,          sDelimiters, "18", 0);
1169          GenerateVector(delim7Escape,        sDelimiters, "19", delim7Open.size());
1170          GenerateVector(delim7Close,         sDelimiters, "20", delim7Open.size());
1171          GenerateVector(delim8Open,          sDelimiters, "21", 0);
1172          GenerateVector(delim8Escape,        sDelimiters, "22", delim8Open.size());
1173          GenerateVector(delim8Close,         sDelimiters, "23", delim8Open.size());
1174          operators1.clear();
1175          foldersInCode1Open.clear();
1176          foldersInCode1Middle.clear();
1177          foldersInCode1Close.clear();
1178          SubGroup(sFoldersInCode1Open,     foldersInCode1Open,       true);
1179          SubGroup(sFoldersInCode1Middle,   foldersInCode1Middle,     true);
1180          SubGroup(sFoldersInCode1Close,    foldersInCode1Close,      true);
1181          SubGroup(sOperators1,             operators1,               true);
1182          char * numberPrefix1        = (char *)styler.pprops->Get("userDefine.numberPrefix1");
1183          char * numberPrefix2        = (char *)styler.pprops->Get("userDefine.numberPrefix2");
1184          char * numberExtras1        = (char *)styler.pprops->Get("userDefine.numberExtras1");
1185          char * numberExtras2        = (char *)styler.pprops->Get("userDefine.numberExtras2");
1186          char * numberSuffix1        = (char *)styler.pprops->Get("userDefine.numberSuffix1");
1187          char * numberSuffix2        = (char *)styler.pprops->Get("userDefine.numberSuffix2");
1188          char * numberRange          = (char *)styler.pprops->Get("userDefine.numberRange");
1189          prefixTokens1.clear();
1190          prefixTokens2.clear();
1191          extrasTokens1.clear();
1192          extrasTokens2.clear();
1193          suffixTokens1.clear();
1194          suffixTokens2.clear();
1195          rangeTokens.clear();
1196          negativePrefixTokens1.clear();
1197          negativePrefixTokens2.clear();
1198          negativeExtrasTokens2.clear();
1199          StringToVector(numberPrefix1, prefixTokens1);
1200          StringToVector(numberPrefix1, negativePrefixTokens1, true);
1201          StringToVector(numberPrefix2, prefixTokens2);
1202          StringToVector(numberPrefix2, negativePrefixTokens2, true);
1203          StringToVector(numberExtras1, extrasTokens1);
1204          StringToVector(numberExtras2, extrasTokens2);
1205          StringToVector(numberExtras2, negativeExtrasTokens2, true);
1206          StringToVector(numberSuffix1, suffixTokens1);
1207          StringToVector(numberSuffix2, suffixTokens2);
1208          StringToVector(numberRange,   rangeTokens);
1209      }
1210      vector<forwardStruct> forwards;
1211      forwards.push_back(*FWS.Set(&delim1Open,        SCE_USER_STYLE_DELIMITER1,      SCE_USER_MASK_NESTING_DELIMITER1));
1212      forwards.push_back(*FWS.Set(&delim2Open,        SCE_USER_STYLE_DELIMITER2,      SCE_USER_MASK_NESTING_DELIMITER2));
1213      forwards.push_back(*FWS.Set(&delim3Open,        SCE_USER_STYLE_DELIMITER3,      SCE_USER_MASK_NESTING_DELIMITER3));
1214      forwards.push_back(*FWS.Set(&delim4Open,        SCE_USER_STYLE_DELIMITER4,      SCE_USER_MASK_NESTING_DELIMITER4));
1215      forwards.push_back(*FWS.Set(&delim5Open,        SCE_USER_STYLE_DELIMITER5,      SCE_USER_MASK_NESTING_DELIMITER5));
1216      forwards.push_back(*FWS.Set(&delim6Open,        SCE_USER_STYLE_DELIMITER6,      SCE_USER_MASK_NESTING_DELIMITER6));
1217      forwards.push_back(*FWS.Set(&delim7Open,        SCE_USER_STYLE_DELIMITER7,      SCE_USER_MASK_NESTING_DELIMITER7));
1218      forwards.push_back(*FWS.Set(&delim8Open,        SCE_USER_STYLE_DELIMITER8,      SCE_USER_MASK_NESTING_DELIMITER8));
1219      forwards.push_back(*FWS.Set(&commentOpen,       SCE_USER_STYLE_COMMENT,         SCE_USER_MASK_NESTING_COMMENT));
1220      forwards.push_back(*FWS.Set(&commentLineOpen,   SCE_USER_STYLE_COMMENTLINE,     SCE_USER_MASK_NESTING_COMMENT_LINE));
1221      forwards.push_back(*FWS.Set(&operators1,        SCE_USER_STYLE_OPERATOR,        SCE_USER_MASK_NESTING_OPERATORS1));
1222      vvstring * delimStart[SCE_USER_TOTAL_DELIMITERS];
1223      delimStart[0] = &delim1Open;
1224      delimStart[1] = &delim2Open;
1225      delimStart[2] = &delim3Open;
1226      delimStart[3] = &delim4Open;
1227      delimStart[4] = &delim5Open;
1228      delimStart[5] = &delim6Open;
1229      delimStart[6] = &delim7Open;
1230      delimStart[7] = &delim8Open;
1231      vvstring * fwEndVectors[FW_VECTORS_TOTAL];  
1232      fwEndVectors[0]  = &operators1;
1233      fwEndVectors[1]  = &commentLineOpen;
1234      fwEndVectors[2]  = &commentLineContinue;
1235      fwEndVectors[3]  = &commentLineClose;
1236      fwEndVectors[4]  = &commentOpen;
1237      fwEndVectors[5]  = &commentClose;
1238      fwEndVectors[6]  = &foldersInCode1Open;
1239      fwEndVectors[7]  = &foldersInCode1Middle;
1240      fwEndVectors[8]  = &foldersInCode1Close;
1241      fwEndVectors[9]  = &delim1Close;
1242      fwEndVectors[10] = &delim2Close;
1243      fwEndVectors[11] = &delim3Close;
1244      fwEndVectors[12] = &delim4Close;
1245      fwEndVectors[13] = &delim5Close;
1246      fwEndVectors[14] = &delim6Close;
1247      fwEndVectors[15] = &delim7Close;
1248      fwEndVectors[16] = &delim8Close;
1249      vvstring * delimVectors[(SCE_USER_TOTAL_DELIMITERS+2) * 2];
1250      delimVectors[0]  = &delim1Escape;
1251      delimVectors[1]  = &delim1Close;
1252      delimVectors[2]  = &delim2Escape;
1253      delimVectors[3]  = &delim2Close;
1254      delimVectors[4]  = &delim3Escape;
1255      delimVectors[5]  = &delim3Close;
1256      delimVectors[6]  = &delim4Escape;
1257      delimVectors[7]  = &delim4Close;
1258      delimVectors[8]  = &delim5Escape;
1259      delimVectors[9]  = &delim5Close;
1260      delimVectors[10] = &delim6Escape;
1261      delimVectors[11] = &delim6Close;
1262      delimVectors[12] = &delim7Escape;
1263      delimVectors[13] = &delim7Close;
1264      delimVectors[14] = &delim8Escape;
1265      delimVectors[15] = &delim8Close;
1266      delimVectors[16] = NULL;;
1267      delimVectors[17] = &commentClose;
1268      delimVectors[18] = NULL;
1269      delimVectors[19] = NULL;
1270      int delimNestings[SCE_USER_TOTAL_DELIMITERS+2];
1271      delimNestings[0] = delim1Nesting;
1272      delimNestings[1] = delim2Nesting;
1273      delimNestings[2] = delim3Nesting;
1274      delimNestings[3] = delim4Nesting;
1275      delimNestings[4] = delim5Nesting;
1276      delimNestings[5] = delim6Nesting;
1277      delimNestings[6] = delim7Nesting;
1278      delimNestings[7] = delim8Nesting;
1279      delimNestings[8] = commentNesting;
1280      delimNestings[9] = lineCommentNesting;
1281      vvstring * numberDelimSeparators[SCE_USER_TOTAL_DELIMITERS+6][SCE_USER_TOTAL_DELIMITERS+6]; 
1282      for (int i=0; i<SCE_USER_TOTAL_DELIMITERS+2; ++i)
1283      {
1284          numberDelimSeparators[i][0]  = delimVectors[i*2 + 1];
1285          numberDelimSeparators[i][1]  = (delimNestings[i] & SCE_USER_MASK_NESTING_DELIMITER1)    ? delimStart[0]    : NULL;
1286          numberDelimSeparators[i][2]  = (delimNestings[i] & SCE_USER_MASK_NESTING_DELIMITER2)    ? delimStart[1]    : NULL;
1287          numberDelimSeparators[i][3]  = (delimNestings[i] & SCE_USER_MASK_NESTING_DELIMITER3)    ? delimStart[2]    : NULL;
1288          numberDelimSeparators[i][4]  = (delimNestings[i] & SCE_USER_MASK_NESTING_DELIMITER4)    ? delimStart[3]    : NULL;
1289          numberDelimSeparators[i][5]  = (delimNestings[i] & SCE_USER_MASK_NESTING_DELIMITER5)    ? delimStart[4]    : NULL;
1290          numberDelimSeparators[i][6]  = (delimNestings[i] & SCE_USER_MASK_NESTING_DELIMITER6)    ? delimStart[5]    : NULL;
1291          numberDelimSeparators[i][7]  = (delimNestings[i] & SCE_USER_MASK_NESTING_DELIMITER7)    ? delimStart[6]    : NULL;
1292          numberDelimSeparators[i][8]  = (delimNestings[i] & SCE_USER_MASK_NESTING_DELIMITER8)    ? delimStart[7]    : NULL;
1293          numberDelimSeparators[i][9]  = (delimNestings[i] & SCE_USER_MASK_NESTING_COMMENT)       ? &commentOpen     : NULL;
1294          numberDelimSeparators[i][10] = (delimNestings[i] & SCE_USER_MASK_NESTING_COMMENT_LINE)  ? &commentLineOpen : NULL;
1295          numberDelimSeparators[i][11] = (delimNestings[i] & SCE_USER_MASK_NESTING_OPERATORS1)    ? &operators1      : NULL;
1296      }
1297      vector<string> * numberTokens[10];
1298      numberTokens[0] = &prefixTokens1;
1299      numberTokens[1] = &prefixTokens2;
1300      numberTokens[2] = &extrasTokens1;
1301      numberTokens[3] = &extrasTokens2;
1302      numberTokens[4] = &suffixTokens1;
1303      numberTokens[5] = &suffixTokens2;
1304      numberTokens[6] = &rangeTokens;
1305      numberTokens[7] = &negativePrefixTokens1;
1306      numberTokens[8] = &negativePrefixTokens2;
1307      numberTokens[9] = &negativeExtrasTokens2;
1308      int levelCurrent = SC_FOLDLEVELBASE;
1309      int lineCurrent = 0;
1310      int levelMinCurrent = 0;
1311      int levelNext = 0;
1312      int levelPrev = 0;
1313      int lev = 0;
1314      bool visibleChars = false;
1315      bool skipVisibleCheck = false;
1316      bool dontMove = false;
1317      bool finished = true;
1318      int checkEOL = EOL_DEFAULT_VALUE;
1319      int nestedLevel = 0;
1320      int openIndex = 0;
1321      size_t skipForward = 0;
1322      int prevState = 0;
1323      int isCommentLine = COMMENTLINE_NO;
1324      int isPrevLineComment = COMMENTLINE_NO;
1325      bool isInCommentBlock = false;
1326      bool isInComment = false;
1327      int newState = 0;
1328      int nlCount = 0;
1329      int continueCommentBlock = 0;
1330      int decSeparator = SEPARATOR_DOT;
1331      vector<nestedInfo> lastNestedGroup;
1332      vvstring * delimEscape = NULL;
1333      vvstring * delimClose  = NULL;
1334      vvstring ** numberDelims = NULL;
1335      int delimNesting = 0;
1336      size_t docLength = startPos + length;
1337      if (startPos == 0)
1338      {
1339          nestedVector.clear();
1340          lastNestedGroup.clear();
1341          initStyle = SCE_USER_STYLE_IDENTIFIER;
1342      }
1343      else
1344      {
1345          size_t oldStartPos = startPos;
1346          ReColoringCheck(startPos, nestedLevel, initStyle, openIndex, isCommentLine, isInComment,
1347                          styler, lastNestedGroup, nestedVector, &bsol;* foldVector, */ continueCommentBlock);
1348          length += (oldStartPos - startPos);
1349          docLength = startPos + length;
1350      }
1351      lineCurrent = styler.GetLine(startPos);
1352      if (lineCurrent > 0)
1353          levelCurrent = styler.LevelAt(lineCurrent - 1) >> 16;
1354      levelMinCurrent = levelCurrent;
1355      levelNext = levelCurrent;
1356      StyleContext sc(startPos, length, initStyle, styler);
1357      for (; finished; )
1358      {
1359          dontMove = false;
1360          checkEOL = EOL_DEFAULT_VALUE;
1361          if (sc.More() == false)
1362              finished = false;   
1363          switch (sc.state)
1364          {
1365              case SCE_USER_STYLE_DELIMITER1:
1366              case SCE_USER_STYLE_DELIMITER2:
1367              case SCE_USER_STYLE_DELIMITER3:
1368              case SCE_USER_STYLE_DELIMITER4:
1369              case SCE_USER_STYLE_DELIMITER5:
1370              case SCE_USER_STYLE_DELIMITER6:
1371              case SCE_USER_STYLE_DELIMITER7:
1372              case SCE_USER_STYLE_DELIMITER8:
1373              {
1374                  int index    = sc.state - SCE_USER_STYLE_DELIMITER1;
1375                  delimEscape  = delimVectors[index*2];
1376                  delimClose   = delimVectors[index*2 + 1];
1377                  delimNesting = delimNestings[index];
1378                  numberDelims = numberDelimSeparators[index];
1379                  prevState    = sc.state;
1380                  newState     = sc.state;
1381                  bool loopEscape = true;
1382                  vector<string>::iterator iter;
1383                  while (loopEscape == true)
1384                  {
1385                      loopEscape = false;
1386                      iter = (*delimEscape)[openIndex].begin();
1387                      for (; iter != (*delimEscape)[openIndex].end(); ++iter)
1388                      {
1389                          if (ignoreCase?sc.MatchIgnoreCase2(iter->c_str()):sc.Match(iter->c_str()))
1390                          {
1391                              sc.Forward(iter->length() + 1); 
1392                              loopEscape = true;
1393                          }
1394                      }
1395                  }
1396                  iter = (*delimClose)[openIndex].begin();
1397                  for (; iter != (*delimClose)[openIndex].end(); ++iter)
1398                  {
1399                      if (ignoreCase ? sc.MatchIgnoreCase2(iter->c_str()):sc.Match(iter->c_str()))
1400                      {
1401                          nestedVector.push_back(*NI.Set(sc.currentPos + iter->length() - 1, nestedLevel--, openIndex, sc.state, NI_CLOSE));
1402                          setBackwards(kwLists, sc, prefixes, ignoreCase, delimNesting, fwEndVectors, levelMinCurrent, levelNext, nlCount, dontMove, docLength);
1403                          sc.SetState(prevState);
1404                          readLastNested(lastNestedGroup, newState, openIndex);
1405                          if (newState != SCE_USER_STYLE_COMMENTLINE || (sc.ch != '\r' && sc.ch != '\n'))
1406                              sc.Forward(iter->length());
1407                          if (sc.atLineStart)
1408                              checkEOL = EOL_FORCE_CHECK;
1409                          else if (sc.atLineEnd)
1410                              checkEOL = EOL_SKIP_CHECK;
1411                          sc.SetState(newState);
1412                          dontMove = true;
1413                          break; 
1414                      }
1415                  }
1416                  if (prevState != newState)
1417                      break;
1418                  if (isWhiteSpace(sc.ch) && !isWhiteSpace(sc.chPrev))
1419                  {
1420                      setBackwards(kwLists, sc, prefixes, ignoreCase, delimNesting, fwEndVectors, levelMinCurrent, levelNext, nlCount, dontMove, docLength);
1421                      sc.SetState(prevState);
1422                  }
1423                  else if ((!isWhiteSpace(sc.ch) && isWhiteSpace(sc.chPrev)))
1424                  {
1425                      sc.SetState(prevState);
1426                  }
1427                  if (isInListNested(delimNesting, forwards, sc, ignoreCase, openIndex, skipForward,
1428                                      newState, pureLC, visibleChars, numberTokens, numberDelims, decSeparator))
1429                  {
1430                      setBackwards(kwLists, sc, prefixes, ignoreCase, delimNesting, fwEndVectors, levelMinCurrent, levelNext, nlCount, dontMove, docLength);
1431                      if (newState != SCE_USER_STYLE_OPERATOR && newState != SCE_USER_STYLE_NUMBER)
1432                      {
1433                          nestedVector.push_back(*NI.Set(sc.currentPos, ++nestedLevel, openIndex, newState, NI_OPEN));
1434                          lastNestedGroup.push_back(NI);
1435                      }
1436                      sc.SetState(newState);  
1437                      sc.Forward(skipForward);
1438                      sc.SetState(newState);
1439                      if (newState == SCE_USER_STYLE_OPERATOR || newState == SCE_USER_STYLE_NUMBER)
1440                          sc.ChangeState(prevState);
1441                      dontMove = true;
1442                      break;
1443                  }
1444                  break;
1445              }
1446              case SCE_USER_STYLE_COMMENT:
1447              {
1448                  numberDelims = numberDelimSeparators[SCE_USER_TOTAL_DELIMITERS];
1449                  vector<string>::iterator iter = commentClose[openIndex].begin();
1450                  for (; iter != commentClose[openIndex].end(); ++iter)
1451                  {
1452                      if (ignoreCase?sc.MatchIgnoreCase2(iter->c_str()):sc.Match(iter->c_str()))
1453                      {
1454                          nestedVector.push_back(*NI.Set(sc.currentPos + iter->length() - 1, nestedLevel--, openIndex, SCE_USER_STYLE_COMMENT, NI_CLOSE));
1455                          setBackwards(kwLists, sc, prefixes, ignoreCase, commentNesting, fwEndVectors, levelMinCurrent, levelNext, nlCount, dontMove, docLength);
1456                          sc.SetState(SCE_USER_STYLE_COMMENT);
1457                          sc.Forward(iter->length());
1458                          readLastNested(lastNestedGroup, newState, openIndex);
1459                          sc.SetState(newState);
1460                          isInComment = false;
1461                          dontMove = true;
1462                          break;
1463                      }
1464                  }
1465                  if (sc.state != SCE_USER_STYLE_COMMENT)
1466                      break;
1467                  if (isWhiteSpace(sc.ch) && !isWhiteSpace(sc.chPrev))
1468                  {
1469                      setBackwards(kwLists, sc, prefixes, ignoreCase, commentNesting, fwEndVectors, levelMinCurrent, levelNext, nlCount, dontMove, docLength);
1470                      sc.SetState(SCE_USER_STYLE_COMMENT);
1471                  }
1472                  else if (!isWhiteSpace(sc.ch) && isWhiteSpace(sc.chPrev))
1473                  {
1474                      sc.SetState(SCE_USER_STYLE_COMMENT);
1475                  }
1476                  if (isInListNested(commentNesting, forwards, sc, ignoreCase, openIndex, skipForward,
1477                                      newState, pureLC, visibleChars, numberTokens, numberDelims, decSeparator))
1478                  {
1479                      setBackwards(kwLists, sc, prefixes, ignoreCase, commentNesting, fwEndVectors, levelMinCurrent, levelNext, nlCount, dontMove, docLength);
1480                      if (newState != SCE_USER_STYLE_OPERATOR && newState != SCE_USER_STYLE_NUMBER)
1481                      {
1482                          nestedVector.push_back(*NI.Set(sc.currentPos, ++nestedLevel, openIndex, newState, NI_OPEN));
1483                          lastNestedGroup.push_back(NI);
1484                      }
1485                      sc.SetState(newState);    
1486                      sc.Forward(skipForward);
1487                      sc.SetState(newState);
1488                      if (newState == SCE_USER_STYLE_OPERATOR || newState == SCE_USER_STYLE_NUMBER)
1489                          sc.ChangeState(SCE_USER_STYLE_COMMENT);
1490                      dontMove = true;
1491                      break;
1492                  }
1493                  break;
1494              }
1495              case SCE_USER_STYLE_COMMENTLINE:
1496              {
1497                  numberDelims = numberDelimSeparators[SCE_USER_TOTAL_DELIMITERS + 1];
1498                  vector<string>::iterator iter = commentLineClose[openIndex].begin();
1499                  for (; iter != commentLineClose[openIndex].end(); ++iter)
1500                  {
1501                      if (ignoreCase?sc.MatchIgnoreCase2(iter->c_str()):sc.Match(iter->c_str()))
1502                      {
1503                          nestedVector.push_back(*NI.Set(sc.currentPos + iter->length() - 1, nestedLevel--, openIndex, SCE_USER_STYLE_COMMENTLINE, NI_CLOSE));
1504                          setBackwards(kwLists, sc, prefixes, ignoreCase, lineCommentNesting, fwEndVectors, levelMinCurrent, levelNext, nlCount, dontMove, docLength);
1505                          sc.SetState(SCE_USER_STYLE_COMMENTLINE);
1506                          sc.Forward(iter->length());
1507                          readLastNested(lastNestedGroup, newState, openIndex);
1508                          sc.SetState(newState);
1509                          dontMove = true;
1510                          break;  
1511                      }
1512                  }
1513                  if (sc.state != SCE_USER_STYLE_COMMENTLINE)
1514                      break;
1515                  if (isWhiteSpace(sc.ch) && !isWhiteSpace(sc.chPrev))
1516                  {
1517                      setBackwards(kwLists, sc, prefixes, ignoreCase, lineCommentNesting, fwEndVectors, levelMinCurrent, levelNext, nlCount, dontMove, docLength);
1518                      sc.SetState(SCE_USER_STYLE_COMMENTLINE);
1519                  }
1520                  else if (!isWhiteSpace(sc.ch) && isWhiteSpace(sc.chPrev))
1521                  {
1522                      sc.SetState(SCE_USER_STYLE_COMMENTLINE);
1523                  }
1524                  if (sc.atLineEnd)
1525                  {
1526                      bool lineContinuation = false;
1527                      int offset = 0;
1528                      if (sc.chPrev == '\r')
1529                         offset = 1;
1530                      vector<string>::iterator iter = commentLineContinue[openIndex].begin();
1531                      for (; iter != commentLineContinue[openIndex].end(); ++iter)
1532                      {
1533                          size_t length = iter->length();
1534                          if (length == 0)
1535                          {
1536                              if (!dontMove)
1537                                  sc.Forward();
1538                              continue;
1539                          }
1540                          lineContinuation = true;
1541                          for (size_t i = 0; i < length; ++i)
1542                          {
1543                              if (ignoreCase)
1544                              {
1545                                  if (toupper((*iter)[i]) != toupper(styler.SafeGetCharAt(sc.currentPos - length + i - offset, 0)))
1546                                  {
1547                                      lineContinuation = false;
1548                                      break;
1549                                  }
1550                              }
1551                              else if ((*iter)[i] != styler.SafeGetCharAt(sc.currentPos - length + i - offset, 0))
1552                              {
1553                                  lineContinuation = false;
1554                                  break;
1555                              }
1556                          }
1557                          if (lineContinuation)
1558                          {
1559                              isCommentLine = COMMENTLINE_YES;
1560                              break;  
1561                          }
1562                      }
1563                      sc.ChangeState(SCE_USER_STYLE_COMMENTLINE); 
1564                      if (!lineContinuation)
1565                      {
1566                          sc.Forward();
1567                          dontMove = true;
1568                          checkEOL = EOL_FORCE_CHECK;
1569                          nestedVector.push_back(*NI.Set(sc.currentPos - 1, nestedLevel--, openIndex, SCE_USER_STYLE_COMMENTLINE, NI_CLOSE));
1570                          readLastNested(lastNestedGroup, newState, openIndex);
1571                          sc.SetState(newState);
1572                      }
1573                      lineContinuation = false;
1574                      break;
1575                  }
1576                  if (sc.state != SCE_USER_STYLE_COMMENTLINE)
1577                      break;
1578                  if (isInListNested(lineCommentNesting, forwards, sc, ignoreCase, openIndex, skipForward,
1579                                      newState, pureLC, visibleChars, numberTokens, numberDelims, decSeparator))
1580                  {
1581                      setBackwards(kwLists, sc, prefixes, ignoreCase, lineCommentNesting, fwEndVectors, levelMinCurrent, levelNext, nlCount, dontMove, docLength);
1582                      if (newState != SCE_USER_STYLE_OPERATOR && newState != SCE_USER_STYLE_NUMBER)
1583                      {
1584                          nestedVector.push_back(*NI.Set(sc.currentPos, ++nestedLevel, openIndex, newState, NI_OPEN));
1585                          lastNestedGroup.push_back(NI);
1586                      }
1587                      sc.SetState(newState);    
1588                      sc.Forward(skipForward);
1589                      sc.SetState(newState);
1590                      if (newState == SCE_USER_STYLE_OPERATOR || newState == SCE_USER_STYLE_NUMBER)
1591                          sc.ChangeState(SCE_USER_STYLE_COMMENTLINE);
1592                      dontMove = true;
1593                      break;
1594                  }
1595                  break;
1596              }
1597              case SCE_USER_STYLE_DEFAULT:
1598              {
1599                  if (isWhiteSpace(sc.ch))
1600                  {
1601                      setBackwards(kwLists, sc, prefixes, ignoreCase, bwNesting, fwEndVectors, levelMinCurrent, levelNext, nlCount, dontMove, docLength);
1602                      sc.SetState(SCE_USER_STYLE_IDENTIFIER);
1603                      break;
1604                  }
1605                  if (!commentLineOpen.empty())
1606                  {
1607                      if ((pureLC == PURE_LC_NONE) ||
1608                          (pureLC == PURE_LC_BOL && (sc.chPrev == '\r' || sc.chPrev == '\n')) ||
1609                          (pureLC == PURE_LC_WSP && visibleChars == false) )
1610                      {
1611                          if (isInListForward(commentLineOpen, sc, ignoreCase, openIndex, skipForward))
1612                          {
1613                              if (foldComments && isCommentLine != COMMENTLINE_SKIP_TESTING)
1614                                  isCommentLine = COMMENTLINE_YES;
1615                              setBackwards(kwLists, sc, prefixes, ignoreCase, bwNesting, fwEndVectors, levelMinCurrent, levelNext, nlCount, dontMove, docLength);
1616                              sc.SetState(SCE_USER_STYLE_COMMENTLINE);
1617                              nestedVector.push_back(*NI.Set(sc.currentPos, ++nestedLevel, openIndex, SCE_USER_STYLE_COMMENTLINE, NI_OPEN));
1618                              lastNestedGroup.push_back(NI);
1619                              sc.Forward(skipForward);
1620                              sc.SetState(SCE_USER_STYLE_COMMENTLINE);
1621                              dontMove = true;
1622                              if (sc.atLineEnd)
1623                                  checkEOL = EOL_SKIP_CHECK;
1624                              break;
1625                          }
1626                      }
1627                  }
1628                  if (!commentOpen.empty())
1629                  {
1630                      if (isInListForward(commentOpen, sc, ignoreCase, openIndex, skipForward))
1631                      {
1632                          if (foldComments)
1633                          {
1634                              isInComment = true;
1635                              if (isCommentLine != COMMENTLINE_SKIP_TESTING)
1636                                  isCommentLine = COMMENTLINE_YES;
1637                          }
1638                          setBackwards(kwLists, sc, prefixes, ignoreCase, bwNesting, fwEndVectors, levelMinCurrent, levelNext, nlCount, dontMove, docLength);
1639                          sc.SetState(SCE_USER_STYLE_COMMENT);
1640                          nestedVector.push_back(*NI.Set(sc.currentPos, ++nestedLevel, openIndex, SCE_USER_STYLE_COMMENT, NI_OPEN));
1641                          lastNestedGroup.push_back(NI);
1642                          sc.Forward(skipForward);
1643                          sc.SetState(SCE_USER_STYLE_COMMENT);
1644                          dontMove = true;
1645                          if (sc.atLineEnd)
1646                              checkEOL = EOL_SKIP_CHECK;
1647                          break;
1648                      }
1649                  }
1650                  for (int i=0; i<SCE_USER_TOTAL_DELIMITERS; ++i)
1651                  {
1652                      if (!delimStart[i]->empty())
1653                      {
1654                          if (isInListForward(*delimStart[i], sc, ignoreCase, openIndex, skipForward))
1655                          {
1656                              setBackwards(kwLists, sc, prefixes, ignoreCase, bwNesting, fwEndVectors, levelMinCurrent, levelNext, nlCount, dontMove, docLength);
1657                              sc.SetState(i+SCE_USER_STYLE_DELIMITER1);
1658                              nestedVector.push_back(*NI.Set(sc.currentPos, ++nestedLevel, openIndex, i+SCE_USER_STYLE_DELIMITER1, NI_OPEN));
1659                              lastNestedGroup.push_back(NI);
1660                              sc.Forward(skipForward);
1661                              sc.SetState(i+SCE_USER_STYLE_DELIMITER1);
1662                              dontMove = true;
1663                              if (sc.atLineEnd)
1664                                  checkEOL = EOL_SKIP_CHECK;
1665                              break;  
1666                          }
1667                      }
1668                  }
1669                  if (dontMove == true)
1670                      break;  
1671                  if (!operators1.empty())
1672                  {
1673                      if (isInListForward(operators1, sc, ignoreCase, openIndex, skipForward))
1674                      {
1675                          setBackwards(kwLists, sc, prefixes, ignoreCase, bwNesting, fwEndVectors, levelMinCurrent, levelNext, nlCount, dontMove, docLength);
1676                          sc.SetState(SCE_USER_STYLE_OPERATOR);
1677                          sc.Forward(skipForward);
1678                          sc.SetState(SCE_USER_STYLE_IDENTIFIER);
1679                          dontMove = true;
1680                          if (sc.atLineEnd)
1681                              checkEOL = EOL_SKIP_CHECK;
1682                          break;
1683                      }
1684                  }
1685                  if (!foldersInCode1Open.empty())
1686                  {
1687                      if (isInListForward(foldersInCode1Open, sc, ignoreCase, openIndex, skipForward))
1688                      {
1689                          setBackwards(kwLists, sc, prefixes, ignoreCase, bwNesting, fwEndVectors, levelMinCurrent, levelNext, nlCount, dontMove, docLength);
1690                          sc.SetState(SCE_USER_STYLE_FOLDER_IN_CODE1);
1691                          sc.Forward(skipForward);
1692                          sc.SetState(SCE_USER_STYLE_IDENTIFIER);
1693                          dontMove = true;
1694                          if (sc.atLineEnd)
1695                              checkEOL = EOL_SKIP_CHECK;
1696                          if (levelMinCurrent > levelNext)
1697                              levelMinCurrent = levelNext;
1698                          levelNext++;
1699                          break;
1700                      }
1701                  }
1702                  if (!foldersInCode1Middle.empty())
1703                  {
1704                      if (isInListForward(foldersInCode1Middle, sc, ignoreCase, openIndex, skipForward))
1705                      {
1706                          setBackwards(kwLists, sc, prefixes, ignoreCase, bwNesting, fwEndVectors, levelMinCurrent, levelNext, nlCount, dontMove, docLength);
1707                          sc.SetState(SCE_USER_STYLE_FOLDER_IN_CODE1);
1708                          sc.Forward(skipForward);
1709                          sc.SetState(SCE_USER_STYLE_IDENTIFIER);
1710                          dontMove = true;
1711                          if (sc.atLineEnd)
1712                              checkEOL = EOL_SKIP_CHECK;
1713                          levelNext--;
1714                          if (levelMinCurrent > levelNext)
1715                              levelMinCurrent = levelNext;
1716                          levelNext++;
1717                          break;
1718                      }
1719                  }
1720                  if (!foldersInCode1Close.empty())
1721                  {
1722                      if (isInListForward(foldersInCode1Close, sc, ignoreCase, openIndex, skipForward))
1723                      {
1724                          setBackwards(kwLists, sc, prefixes, ignoreCase, bwNesting, fwEndVectors, levelMinCurrent, levelNext, nlCount, dontMove, docLength);
1725                          sc.SetState(SCE_USER_STYLE_FOLDER_IN_CODE1);
1726                          sc.Forward(skipForward);
1727                          sc.SetState(SCE_USER_STYLE_IDENTIFIER);
1728                          if (sc.atLineEnd)
1729                              checkEOL = EOL_SKIP_CHECK;
1730                          dontMove = true;
1731                          levelNext--;
1732                          break;
1733                      }
1734                  }
1735                  if (foldComments && isCommentLine != COMMENTLINE_SKIP_TESTING)
1736                      isCommentLine = COMMENTLINE_SKIP_TESTING;
1737                  break;
1738              }
1739              case SCE_USER_STYLE_IDENTIFIER:
1740              {
1741                  if (isWhiteSpace(sc.ch))
1742                      break;
1743                  if (IsNumber(sc, numberTokens, fwEndVectors, ignoreCase, decSeparator, skipForward))
1744                  {
1745                      sc.SetState(SCE_USER_STYLE_NUMBER);
1746                      sc.Forward(skipForward);
1747                      sc.SetState(SCE_USER_STYLE_IDENTIFIER);
1748                      if (isWhiteSpace(sc.ch))
1749                          break;
1750                  }
1751                  if (!isWhiteSpace(sc.ch))
1752                  {
1753                      sc.SetState(SCE_USER_STYLE_DEFAULT);
1754                      skipVisibleCheck = true;
1755                      dontMove = true;
1756                      break;
1757                  }
1758                  break;
1759              }
1760              default:
1761                  break;
1762          }
1763          if (foldComments)
1764              if (isInComment == false)
1765                  if (isCommentLine == COMMENTLINE_NO)
1766                      if (sc.state != SCE_USER_STYLE_COMMENTLINE)
1767                          if (sc.state != SCE_USER_STYLE_IDENTIFIER)
1768                              if (sc.state != SCE_USER_STYLE_DEFAULT)
1769                                  if (!isWhiteSpace(sc.ch))
1770                                      isCommentLine = COMMENTLINE_SKIP_TESTING;
1771          if (skipVisibleCheck == true)
1772              skipVisibleCheck = false;
1773          else if (visibleChars == false && !isWhiteSpace(sc.ch))
1774              visibleChars = true;
1775          if ((sc.atLineEnd == true && checkEOL != EOL_SKIP_CHECK) || (sc.atLineEnd == false && checkEOL == EOL_FORCE_CHECK))
1776          {
1777              if (foldComments == true)
1778              {
1779                  if (levelCurrent != levelNext)
1780                      isCommentLine = COMMENTLINE_SKIP_TESTING;
1781                  if (continueCommentBlock > 0)
1782                  {
1783                      if (continueCommentBlock & CL_PREVPREV)
1784                      {
1785                          isInCommentBlock = true;
1786                          isPrevLineComment = COMMENTLINE_YES;
1787                          if (!(continueCommentBlock & CL_CURRENT))
1788                          {
1789                              levelNext++;
1790                              levelMinCurrent++;
1791                              levelCurrent++;
1792                              levelPrev = (levelMinCurrent | levelNext << 16) | SC_ISCOMMENTLINE;
1793                          }
1794                      }
1795                      else if (continueCommentBlock & CL_PREV)
1796                      {
1797                          isPrevLineComment = COMMENTLINE_YES;
1798                          if (continueCommentBlock & CL_CURRENT)
1799                          {
1800                              levelMinCurrent--;
1801                              levelNext--;
1802                              levelCurrent--;
1803                              levelPrev = (levelMinCurrent | levelNext << 16) | SC_ISCOMMENTLINE;
1804                          }
1805                      }
1806                      continueCommentBlock = 0;
1807                  }
1808                  if (isInCommentBlock && isCommentLine != COMMENTLINE_YES && isPrevLineComment == COMMENTLINE_YES)
1809                  {
1810                      levelNext--;
1811                      levelPrev = (levelMinCurrent | levelNext << 16) | SC_ISCOMMENTLINE;
1812                      levelMinCurrent--;
1813                      isInCommentBlock = false;
1814                  }
1815                  if (!isInCommentBlock && isCommentLine == COMMENTLINE_YES && isPrevLineComment == COMMENTLINE_YES)
1816                  {
1817                      levelNext++;
1818                      levelPrev = (levelMinCurrent | levelNext << 16) | SC_FOLDLEVELHEADERFLAG | SC_ISCOMMENTLINE;
1819                      levelMinCurrent = levelNext;
1820                      isInCommentBlock = true;
1821                  }
1822                  if (levelPrev != 0)
1823                  {
1824                      styler.SetLevel(lineCurrent - 1, levelPrev);
1825                      levelPrev = 0;
1826                  }
1827              }
1828              lev = levelMinCurrent | levelNext << 16;
1829              if (foldComments && isCommentLine == COMMENTLINE_YES)
1830                  lev |= SC_ISCOMMENTLINE;
1831              if (visibleChars == false && foldCompact)
1832                  lev |= SC_FOLDLEVELWHITEFLAG;
1833              if (levelMinCurrent < levelNext)
1834                  lev |= SC_FOLDLEVELHEADERFLAG;
1835              styler.SetLevel(lineCurrent, lev);
1836              for (int i=0; i<nlCount; ++i)   
1837              {
1838                  styler.SetLevel(lineCurrent++, levelNext | levelNext << 16);
1839              }
1840              nlCount = 0;
<span onclick='openModal()' class='match'>1841              lineCurrent++;
1842              levelCurrent = levelNext;
1843              levelMinCurrent = levelCurrent;
1844              visibleChars = false;
1845              if (foldComments)
1846              {
1847                  isPrevLineComment = isCommentLine==COMMENTLINE_YES ? COMMENTLINE_YES:COMMENTLINE_NO;
</span>1848                  isCommentLine = isInComment ? COMMENTLINE_YES:COMMENTLINE_NO;
1849              }
1850          }
1851          if (!dontMove)
1852              sc.Forward();
1853      }
1854      sc.Complete();
1855  }
1856  static void FoldUserDoc(Sci_PositionU &bsol;* startPos */, Sci_Position &bsol;* length */, int &bsol;*initStyle*/, WordList *[],  Accessor & &bsol;* styler */)
1857  {
1858  }
1859  static const char * const userDefineWordLists[] = {
1860              "Primary keywords and identifiers",
1861              "Secondary keywords and identifiers",
1862              "Documentation comment keywords",
1863              "Fold header keywords",
1864              0,
1865          };
1866  LexerModule lmUserDefine(SCLEX_USER, ColouriseUserDoc, "user", FoldUserDoc, userDefineWordLists);
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexHTML.cxx</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexUser.cxx</div>
                </div>
                <div class="column column_space"><pre><code>1773  				i++;
1774  				ch = chNext;
1775  				state = SCE_H_DEFAULT;
1776  				tagOpened = false;
1777  				if (foldXmlAtTagOpen) {
1778  					levelCurrent--;
</pre></code></div>
                <div class="column column_space"><pre><code>1841              lineCurrent++;
1842              levelCurrent = levelNext;
1843              levelMinCurrent = levelCurrent;
1844              visibleChars = false;
1845              if (foldComments)
1846              {
1847                  isPrevLineComment = isCommentLine==COMMENTLINE_YES ? COMMENTLINE_YES:COMMENTLINE_NO;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    