
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 48, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-Notepad_plus.cpp</h3>
            <pre><code>1  #include <time.h>
2  #include <shlwapi.h>
3  #include <wininet.h>
4  #include "Notepad_plus.h"
5  #include "Notepad_plus_Window.h"
6  #include "CustomFileDialog.h"
7  #include "Printer.h"
8  #include "FileNameStringSplitter.h"
9  #include "lesDlgs.h"
10  #include "Utf8_16.h"
11  #include "regExtDlg.h"
12  #include "RunDlg.h"
13  #include "ShortcutMapper.h"
14  #include "preferenceDlg.h"
15  #include "TaskListDlg.h"
16  #include "xmlMatchedTagsHighlighter.h"
17  #include "EncodingMapper.h"
18  #include "ansiCharPanel.h"
19  #include "clipboardHistoryPanel.h"
20  #include "VerticalFileSwitcher.h"
21  #include "ProjectPanel.h"
22  #include "documentMap.h"
23  #include "functionListPanel.h"
24  #include "fileBrowser.h"
25  #include "Common.h"
26  #include "NppDarkMode.h"
27  using namespace std;
28  enum tb_stat {tb_saved, tb_unsaved, tb_ro, tb_monitored};
29  #define DIR_LEFT true
30  #define DIR_RIGHT false
31  int docTabIconIDs[] = { IDI_SAVED_ICON,  IDI_UNSAVED_ICON,  IDI_READONLY_ICON,  IDI_MONITORING_ICON };
32  int docTabIconIDs_darkMode[] = { IDI_SAVED_DM_ICON,  IDI_UNSAVED_DM_ICON,  IDI_READONLY_DM_ICON,  IDI_MONITORING_DM_ICON };
33  int docTabIconIDs_alt[] = { IDI_SAVED_ALT_ICON, IDI_UNSAVED_ALT_ICON, IDI_READONLY_ALT_ICON, IDI_MONITORING_ICON };
34  ToolBarButtonUnit toolBarIcons[] = {
35      {IDM_FILE_NEW,                     IDI_NEW_ICON,               IDI_NEW_ICON,                  IDI_NEW_ICON2,              IDI_NEW_ICON2,                 IDI_NEW_ICON_DM,               IDI_NEW_ICON_DM,                  IDI_NEW_ICON_DM2,              IDI_NEW_ICON_DM2,                 IDR_FILENEW},
36      {IDM_FILE_OPEN,                    IDI_OPEN_ICON,              IDI_OPEN_ICON,                 IDI_OPEN_ICON2,             IDI_OPEN_ICON2,                IDI_OPEN_ICON_DM,              IDI_OPEN_ICON_DM,                 IDI_OPEN_ICON_DM2,             IDI_OPEN_ICON_DM2,                IDR_FILEOPEN},
37      {IDM_FILE_SAVE,                    IDI_SAVE_ICON,              IDI_SAVE_DISABLE_ICON,         IDI_SAVE_ICON2,             IDI_SAVE_DISABLE_ICON2,        IDI_SAVE_ICON_DM,              IDI_SAVE_DISABLE_ICON_DM,         IDI_SAVE_ICON_DM2,             IDI_SAVE_DISABLE_ICON_DM2,        IDR_FILESAVE},
38      {IDM_FILE_SAVEALL,                 IDI_SAVEALL_ICON,           IDI_SAVEALL_DISABLE_ICON,      IDI_SAVEALL_ICON2,          IDI_SAVEALL_DISABLE_ICON2,     IDI_SAVEALL_ICON_DM,           IDI_SAVEALL_DISABLE_ICON_DM,      IDI_SAVEALL_ICON_DM2,          IDI_SAVEALL_DISABLE_ICON_DM2,     IDR_SAVEALL},
39      {IDM_FILE_CLOSE,                   IDI_CLOSE_ICON,             IDI_CLOSE_ICON,                IDI_CLOSE_ICON2,            IDI_CLOSE_ICON2,               IDI_CLOSE_ICON_DM,             IDI_CLOSE_ICON_DM,                IDI_CLOSE_ICON_DM2,            IDI_CLOSE_ICON_DM2,               IDR_CLOSEFILE},
40      {IDM_FILE_CLOSEALL,                IDI_CLOSEALL_ICON,          IDI_CLOSEALL_ICON,             IDI_CLOSEALL_ICON2,         IDI_CLOSEALL_ICON2,            IDI_CLOSEALL_ICON_DM,          IDI_CLOSEALL_ICON_DM,             IDI_CLOSEALL_ICON_DM2,         IDI_CLOSEALL_ICON_DM2,            IDR_CLOSEALL},
41      {IDM_FILE_PRINT,                   IDI_PRINT_ICON,             IDI_PRINT_ICON,                IDI_PRINT_ICON2,            IDI_PRINT_ICON2,               IDI_PRINT_ICON_DM,             IDI_PRINT_ICON_DM,                IDI_PRINT_ICON_DM2,            IDI_PRINT_ICON_DM2,               IDR_PRINT},
42      {0,                                IDI_SEPARATOR_ICON,         IDI_SEPARATOR_ICON,            IDI_SEPARATOR_ICON,         IDI_SEPARATOR_ICON,            IDI_SEPARATOR_ICON,            IDI_SEPARATOR_ICON,               IDI_SEPARATOR_ICON,            IDI_SEPARATOR_ICON,            IDI_SEPARATOR_ICON},
43      {IDM_EDIT_CUT,                     IDI_CUT_ICON,               IDI_CUT_DISABLE_ICON,          IDI_CUT_ICON2,              IDI_CUT_DISABLE_ICON2,         IDI_CUT_ICON_DM,               IDI_CUT_DISABLE_ICON_DM,          IDI_CUT_ICON_DM2,              IDI_CUT_DISABLE_ICON_DM2,         IDR_CUT},
44      {IDM_EDIT_COPY,                    IDI_COPY_ICON,              IDI_COPY_DISABLE_ICON,         IDI_COPY_ICON2,             IDI_COPY_DISABLE_ICON2,        IDI_COPY_ICON_DM,              IDI_COPY_DISABLE_ICON_DM,         IDI_COPY_ICON_DM2,             IDI_COPY_DISABLE_ICON_DM2,        IDR_COPY},
45      {IDM_EDIT_PASTE,                   IDI_PASTE_ICON,             IDI_PASTE_DISABLE_ICON,        IDI_PASTE_ICON2,            IDI_PASTE_DISABLE_ICON2,       IDI_PASTE_ICON_DM,             IDI_PASTE_DISABLE_ICON_DM,        IDI_PASTE_ICON_DM2,            IDI_PASTE_DISABLE_ICON_DM2,       IDR_PASTE},
46      {0,                                IDI_SEPARATOR_ICON,         IDI_SEPARATOR_ICON,            IDI_SEPARATOR_ICON,         IDI_SEPARATOR_ICON,            IDI_SEPARATOR_ICON,            IDI_SEPARATOR_ICON,               IDI_SEPARATOR_ICON,            IDI_SEPARATOR_ICON,            IDI_SEPARATOR_ICON},
47      {IDM_EDIT_UNDO,                    IDI_UNDO_ICON,              IDI_UNDO_DISABLE_ICON,         IDI_UNDO_ICON2,             IDI_UNDO_DISABLE_ICON2,        IDI_UNDO_ICON_DM,              IDI_UNDO_DISABLE_ICON_DM,         IDI_UNDO_ICON_DM2,             IDI_UNDO_DISABLE_ICON_DM2,        IDR_UNDO},
48      {IDM_EDIT_REDO,                    IDI_REDO_ICON,              IDI_REDO_DISABLE_ICON,         IDI_REDO_ICON2,             IDI_REDO_DISABLE_ICON2,        IDI_REDO_ICON_DM,              IDI_REDO_DISABLE_ICON_DM,         IDI_REDO_ICON_DM2,             IDI_REDO_DISABLE_ICON_DM2,        IDR_REDO},
49      {0,                                IDI_SEPARATOR_ICON,         IDI_SEPARATOR_ICON,            IDI_SEPARATOR_ICON,         IDI_SEPARATOR_ICON,            IDI_SEPARATOR_ICON,            IDI_SEPARATOR_ICON,               IDI_SEPARATOR_ICON,            IDI_SEPARATOR_ICON,            IDI_SEPARATOR_ICON},
50      {IDM_SEARCH_FIND,                  IDI_FIND_ICON,              IDI_FIND_ICON,                 IDI_FIND_ICON2,             IDI_FIND_ICON2,                IDI_FIND_ICON_DM,              IDI_FIND_ICON_DM,                 IDI_FIND_ICON_DM2,             IDI_FIND_ICON_DM2,                IDR_FIND},
51      {IDM_SEARCH_REPLACE,               IDI_REPLACE_ICON,           IDI_REPLACE_ICON,              IDI_REPLACE_ICON2,          IDI_REPLACE_ICON2,             IDI_REPLACE_ICON_DM,           IDI_REPLACE_ICON_DM,              IDI_REPLACE_ICON_DM2,          IDI_REPLACE_ICON_DM2,             IDR_REPLACE},
52      {0,                                IDI_SEPARATOR_ICON,         IDI_SEPARATOR_ICON,            IDI_SEPARATOR_ICON,         IDI_SEPARATOR_ICON,            IDI_SEPARATOR_ICON,            IDI_SEPARATOR_ICON,               IDI_SEPARATOR_ICON,            IDI_SEPARATOR_ICON,            IDI_SEPARATOR_ICON},
53      {IDM_VIEW_ZOOMIN,                  IDI_ZOOMIN_ICON,            IDI_ZOOMIN_ICON,               IDI_ZOOMIN_ICON2,           IDI_ZOOMIN_ICON2,              IDI_ZOOMIN_ICON_DM,            IDI_ZOOMIN_ICON_DM,               IDI_ZOOMIN_ICON_DM2,           IDI_ZOOMIN_ICON_DM2,              IDR_ZOOMIN},
54      {IDM_VIEW_ZOOMOUT,                 IDI_ZOOMOUT_ICON,           IDI_ZOOMOUT_ICON,              IDI_ZOOMOUT_ICON2,          IDI_ZOOMOUT_ICON2,             IDI_ZOOMOUT_ICON_DM,           IDI_ZOOMOUT_ICON_DM,              IDI_ZOOMOUT_ICON_DM2,          IDI_ZOOMOUT_ICON_DM2,             IDR_ZOOMOUT},
55      {0,                                IDI_SEPARATOR_ICON,         IDI_SEPARATOR_ICON,            IDI_SEPARATOR_ICON,         IDI_SEPARATOR_ICON,            IDI_SEPARATOR_ICON,            IDI_SEPARATOR_ICON,               IDI_SEPARATOR_ICON,            IDI_SEPARATOR_ICON,            IDI_SEPARATOR_ICON},
56      {IDM_VIEW_SYNSCROLLV,              IDI_SYNCV_ICON,             IDI_SYNCV_DISABLE_ICON,        IDI_SYNCV_ICON2,            IDI_SYNCV_DISABLE_ICON2,       IDI_SYNCV_ICON_DM,             IDI_SYNCV_DISABLE_ICON_DM,        IDI_SYNCV_ICON_DM2,            IDI_SYNCV_DISABLE_ICON_DM2,       IDR_SYNCV},
57      {IDM_VIEW_SYNSCROLLH,              IDI_SYNCH_ICON,             IDI_SYNCH_DISABLE_ICON,        IDI_SYNCH_ICON2,            IDI_SYNCH_DISABLE_ICON2,       IDI_SYNCH_ICON_DM,             IDI_SYNCH_DISABLE_ICON_DM,        IDI_SYNCH_ICON_DM2,            IDI_SYNCH_DISABLE_ICON_DM2,       IDR_SYNCH},
58      {0,                                IDI_SEPARATOR_ICON,         IDI_SEPARATOR_ICON,            IDI_SEPARATOR_ICON,         IDI_SEPARATOR_ICON,            IDI_SEPARATOR_ICON,            IDI_SEPARATOR_ICON,               IDI_SEPARATOR_ICON,            IDI_SEPARATOR_ICON,            IDI_SEPARATOR_ICON},
59      {IDM_VIEW_WRAP,                    IDI_VIEW_WRAP_ICON,         IDI_VIEW_WRAP_ICON,            IDI_VIEW_WRAP_ICON2,        IDI_VIEW_WRAP_ICON2,           IDI_VIEW_WRAP_ICON_DM,         IDI_VIEW_WRAP_ICON_DM,            IDI_VIEW_WRAP_ICON_DM2,        IDI_VIEW_WRAP_ICON_DM2,           IDR_WRAP},
60      {IDM_VIEW_ALL_CHARACTERS,          IDI_VIEW_ALL_CHAR_ICON,     IDI_VIEW_ALL_CHAR_ICON,        IDI_VIEW_ALL_CHAR_ICON2,    IDI_VIEW_ALL_CHAR_ICON2,       IDI_VIEW_ALL_CHAR_ICON_DM,     IDI_VIEW_ALL_CHAR_ICON_DM,        IDI_VIEW_ALL_CHAR_ICON_DM2,    IDI_VIEW_ALL_CHAR_ICON_DM2,       IDR_INVISIBLECHAR},
61      {IDM_VIEW_INDENT_GUIDE,            IDI_VIEW_INDENT_ICON,       IDI_VIEW_INDENT_ICON,          IDI_VIEW_INDENT_ICON2,      IDI_VIEW_INDENT_ICON2,         IDI_VIEW_INDENT_ICON_DM,       IDI_VIEW_INDENT_ICON_DM,          IDI_VIEW_INDENT_ICON_DM2,      IDI_VIEW_INDENT_ICON_DM2,         IDR_INDENTGUIDE},
62      {IDM_LANG_USER_DLG,                IDI_VIEW_UD_DLG_ICON,       IDI_VIEW_UD_DLG_ICON,          IDI_VIEW_UD_DLG_ICON2,      IDI_VIEW_UD_DLG_ICON2,         IDI_VIEW_UD_DLG_ICON_DM,       IDI_VIEW_UD_DLG_ICON_DM,          IDI_VIEW_UD_DLG_ICON_DM2,      IDI_VIEW_UD_DLG_ICON_DM2,         IDR_SHOWPANNEL},
63      {IDM_VIEW_DOC_MAP,                 IDI_VIEW_DOC_MAP_ICON,      IDI_VIEW_DOC_MAP_ICON,         IDI_VIEW_DOC_MAP_ICON2,     IDI_VIEW_DOC_MAP_ICON2,        IDI_VIEW_DOC_MAP_ICON_DM,      IDI_VIEW_DOC_MAP_ICON_DM,         IDI_VIEW_DOC_MAP_ICON_DM2,     IDI_VIEW_DOC_MAP_ICON_DM2,        IDR_DOCMAP},
64      {IDM_VIEW_DOCLIST,                 IDI_VIEW_DOCLIST_ICON,      IDI_VIEW_DOCLIST_ICON,         IDI_VIEW_DOCLIST_ICON2,     IDI_VIEW_DOCLIST_ICON2,        IDI_VIEW_DOCLIST_ICON_DM,      IDI_VIEW_DOCLIST_ICON_DM,         IDI_VIEW_DOCLIST_ICON_DM2,     IDI_VIEW_DOCLIST_ICON_DM2,        IDR_DOCLIST},
65      {IDM_VIEW_FUNC_LIST,               IDI_VIEW_FUNCLIST_ICON,     IDI_VIEW_FUNCLIST_ICON,        IDI_VIEW_FUNCLIST_ICON2,    IDI_VIEW_FUNCLIST_ICON2,       IDI_VIEW_FUNCLIST_ICON_DM,     IDI_VIEW_FUNCLIST_ICON_DM,        IDI_VIEW_FUNCLIST_ICON_DM2,    IDI_VIEW_FUNCLIST_ICON_DM2,       IDR_FUNC_LIST},
66      {IDM_VIEW_FILEBROWSER,             IDI_VIEW_FILEBROWSER_ICON,  IDI_VIEW_FILEBROWSER_ICON,     IDI_VIEW_FILEBROWSER_ICON2, IDI_VIEW_FILEBROWSER_ICON2,    IDI_VIEW_FILEBROWSER_ICON_DM,  IDI_VIEW_FILEBROWSER_ICON_DM,     IDI_VIEW_FILEBROWSER_ICON_DM2, IDI_VIEW_FILEBROWSER_ICON_DM2,    IDR_FILEBROWSER},
67      {IDM_VIEW_MONITORING,              IDI_VIEW_MONITORING_ICON,   IDI_VIEW_MONITORING_ICON,      IDI_VIEW_MONITORING_ICON2,  IDI_VIEW_MONITORING_ICON2,     IDI_VIEW_MONITORING_ICON_DM,   IDI_VIEW_MONITORING_ICON_DM,      IDI_VIEW_MONITORING_ICON_DM2,  IDI_VIEW_MONITORING_ICON_DM2,     IDR_FILEMONITORING},
68      {0,                                IDI_SEPARATOR_ICON,         IDI_SEPARATOR_ICON,            IDI_SEPARATOR_ICON,         IDI_SEPARATOR_ICON,            IDI_SEPARATOR_ICON,            IDI_SEPARATOR_ICON,               IDI_SEPARATOR_ICON,            IDI_SEPARATOR_ICON,            IDI_SEPARATOR_ICON},
69      {IDM_MACRO_STARTRECORDINGMACRO,    IDI_STARTRECORD_ICON,       IDI_STARTRECORD_DISABLE_ICON,  IDI_STARTRECORD_ICON2,      IDI_STARTRECORD_DISABLE_ICON2, IDI_STARTRECORD_ICON_DM,       IDI_STARTRECORD_DISABLE_ICON_DM,  IDI_STARTRECORD_ICON_DM2,      IDI_STARTRECORD_DISABLE_ICON_DM2, IDR_STARTRECORD},
70      {IDM_MACRO_STOPRECORDINGMACRO,     IDI_STOPRECORD_ICON,        IDI_STOPRECORD_DISABLE_ICON,   IDI_STOPRECORD_ICON2,       IDI_STOPRECORD_DISABLE_ICON2,  IDI_STOPRECORD_ICON_DM,        IDI_STOPRECORD_DISABLE_ICON_DM,   IDI_STOPRECORD_ICON_DM2,       IDI_STOPRECORD_DISABLE_ICON_DM2,  IDR_STOPRECORD},
71      {IDM_MACRO_PLAYBACKRECORDEDMACRO,  IDI_PLAYRECORD_ICON,        IDI_PLAYRECORD_DISABLE_ICON,   IDI_PLAYRECORD_ICON2,       IDI_PLAYRECORD_DISABLE_ICON2,  IDI_PLAYRECORD_ICON_DM,        IDI_PLAYRECORD_DISABLE_ICON_DM,   IDI_PLAYRECORD_ICON_DM2,       IDI_PLAYRECORD_DISABLE_ICON_DM2,  IDR_PLAYRECORD},
72      {IDM_MACRO_RUNMULTIMACRODLG,       IDI_MMPLAY_ICON,            IDI_MMPLAY_DIS_ICON,           IDI_MMPLAY_ICON2,           IDI_MMPLAY_DIS_ICON2,          IDI_MMPLAY_ICON_DM,            IDI_MMPLAY_DIS_ICON_DM,           IDI_MMPLAY_ICON_DM2,           IDI_MMPLAY_DIS_ICON_DM2,          IDR_M_PLAYRECORD},
73      {IDM_MACRO_SAVECURRENTMACRO,       IDI_SAVERECORD_ICON,        IDI_SAVERECORD_DISABLE_ICON,   IDI_SAVERECORD_ICON2,       IDI_SAVERECORD_DISABLE_ICON2,  IDI_SAVERECORD_ICON_DM,        IDI_SAVERECORD_DISABLE_ICON_DM,   IDI_SAVERECORD_ICON_DM2,       IDI_SAVERECORD_DISABLE_ICON_DM2,  IDR_SAVERECORD}
74  };
75  Notepad_plus::Notepad_plus()
76  	: _autoCompleteMain(&_mainEditView)
77  	, _autoCompleteSub(&_subEditView)
78  	, _smartHighlighter(&_findReplaceDlg)
79  {
80  	ZeroMemory(&_prevSelectedRange, sizeof(_prevSelectedRange));
81  	NppParameters& nppParam = NppParameters::getInstance();
82  	TiXmlDocumentA *nativeLangDocRootA = nppParam.getNativeLangA();
83      _nativeLangSpeaker.init(nativeLangDocRootA);
84  	LocalizationSwitcher & localizationSwitcher = nppParam.getLocalizationSwitcher();
85      const char *fn = _nativeLangSpeaker.getFileName();
86      if (fn)
87      {
88          localizationSwitcher.setFileName(fn);
89      }
90  	nppParam.setNativeLangSpeaker(&_nativeLangSpeaker);
91  	TiXmlDocument *toolIconsDocRoot = nppParam.getCustomizedToolIcons();
92  	if (toolIconsDocRoot)
93  	{
94          _toolBar.initTheme(toolIconsDocRoot);
95      }
96  	BOOL is_admin;
97  	winVer ver = nppParam.getWinVersion();
98  	if (ver >= WV_VISTA || ver == WV_UNKNOWN)
99  	{
100  		SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
101  		PSID AdministratorsGroup;
102  		is_admin = AllocateAndInitializeSid(&NtAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0, 0, 0, &AdministratorsGroup);
103  		if (is_admin)
104  		{
105  			if (!CheckTokenMembership(NULL, AdministratorsGroup, &is_admin))
106  				is_admin = FALSE;
107  			FreeSid(AdministratorsGroup);
108  		}
109  	}
110  	else
111  		is_admin = false;
112  	nppParam.setAdminMode(is_admin == TRUE);
113  	_isAdministrator = is_admin ? true : false;
114  }
115  Notepad_plus::~Notepad_plus()
116  {
117  	(NppParameters::getInstance()).destroyInstance();
118  	delete _pTrayIco;
119  	delete _pAnsiCharPanel;
120  	delete _pClipboardHistoryPanel;
121  	delete _pDocumentListPanel;
122  	delete _pProjectPanel_1;
123  	delete _pProjectPanel_2;
124  	delete _pProjectPanel_3;
125  	delete _pDocMap;
126  	delete _pFuncList;
127  	delete _pFileBrowser;
128  }
129  LRESULT Notepad_plus::init(HWND hwnd)
130  {
131  	NppParameters& nppParam = NppParameters::getInstance();
132  	NppGUI & nppGUI = nppParam.getNppGUI();
133  	_mainMenuHandle = ::GetMenu(hwnd);
134  	int langPos2BeRemoved = MENUINDEX_LANGUAGE + 1;
135  	if (nppGUI._isLangMenuCompact)
136  		langPos2BeRemoved = MENUINDEX_LANGUAGE;
137  	::RemoveMenu(_mainMenuHandle, langPos2BeRemoved, MF_BYPOSITION);
138  	_pDocTab = &_mainDocTab;
139  	_pEditView = &_mainEditView;
140  	_pNonDocTab = &_subDocTab;
141  	_pNonEditView = &_subEditView;
142  	_mainEditView.init(_pPublicInterface->getHinst(), hwnd);
143  	_subEditView.init(_pPublicInterface->getHinst(), hwnd);
144  	_fileEditView.init(_pPublicInterface->getHinst(), hwnd);
145  	MainFileManager.init(this, &_fileEditView); 
146  	nppParam.setFontList(hwnd);
147  	_mainWindowStatus = WindowMainActive;
148  	_activeView = MAIN_VIEW;
149  	const ScintillaViewParams & svp = nppParam.getSVP();
150  	int tabBarStatus = nppGUI._tabStatus;
151  	_toReduceTabBar = ((tabBarStatus & TAB_REDUCE) != 0);
152  	int iconDpiDynamicalSize = nppParam._dpiManager.scaleX(g_TabIconSize);
153  	_docTabIconList.create(iconDpiDynamicalSize, _pPublicInterface->getHinst(), docTabIconIDs, sizeof(docTabIconIDs) / sizeof(int));
154  	_docTabIconListAlt.create(iconDpiDynamicalSize, _pPublicInterface->getHinst(), docTabIconIDs_alt, sizeof(docTabIconIDs_alt) / sizeof(int));
155  	_docTabIconListDarkMode.create(iconDpiDynamicalSize, _pPublicInterface->getHinst(), docTabIconIDs_darkMode, sizeof(docTabIconIDs_darkMode) / sizeof(int));
156  	vector<IconList *> pIconListVector;
157  	pIconListVector.push_back(&_docTabIconList);        
158  	pIconListVector.push_back(&_docTabIconListAlt);     
159  	pIconListVector.push_back(&_docTabIconListDarkMode);
160  	const int tabIconSet = NppDarkMode::getTabIconSet(NppDarkMode::isEnabled());
161  	unsigned char indexDocTabIcon = 0;
162  	switch (tabIconSet)
163  	{
164  		case 0:
165  		{
166  			nppGUI._tabStatus &= ~TAB_ALTICONS;
167  			break;
168  		}
169  		case 1:
170  		{
171  			nppGUI._tabStatus |= TAB_ALTICONS;
172  			indexDocTabIcon = 1;
173  			break;
174  		}
175  		case 2:
176  		{
177  			nppGUI._tabStatus &= ~TAB_ALTICONS;
178  			indexDocTabIcon = 2;
179  			break;
180  		}
181  		default:
182  		{
183  			indexDocTabIcon = ((tabBarStatus & TAB_ALTICONS) == TAB_ALTICONS) ? 1 : (NppDarkMode::isEnabled() ? 2 : 0);
184  		}
185  	}
186  	_mainDocTab.init(_pPublicInterface->getHinst(), hwnd, &_mainEditView, pIconListVector, indexDocTabIcon);
187  	_subDocTab.init(_pPublicInterface->getHinst(), hwnd, &_subEditView, pIconListVector, indexDocTabIcon);
188  	_mainEditView.display();
189  	_invisibleEditView.init(_pPublicInterface->getHinst(), hwnd);
190  	_invisibleEditView.execute(SCI_SETUNDOCOLLECTION);
191  	_invisibleEditView.execute(SCI_EMPTYUNDOBUFFER);
192  	_invisibleEditView.wrap(false); 
193  	_mainEditView.showMargin(ScintillaEditView::_SC_MARGE_LINENUMBER, svp._lineNumberMarginShow);
194  	_subEditView.showMargin(ScintillaEditView::_SC_MARGE_LINENUMBER, svp._lineNumberMarginShow);
195  	_mainEditView.showMargin(ScintillaEditView::_SC_MARGE_SYMBOL, svp._bookMarkMarginShow);
196  	_subEditView.showMargin(ScintillaEditView::_SC_MARGE_SYMBOL, svp._bookMarkMarginShow);
197  	_mainEditView.showIndentGuideLine(svp._indentGuideLineShow);
198  	_subEditView.showIndentGuideLine(svp._indentGuideLineShow);
199  	::SendMessage(hwnd, NPPM_INTERNAL_SETCARETWIDTH, 0, 0);
200  	::SendMessage(hwnd, NPPM_INTERNAL_SETCARETBLINKRATE, 0, 0);
201  	_configStyleDlg.init(_pPublicInterface->getHinst(), hwnd);
202  	_preference.init(_pPublicInterface->getHinst(), hwnd);
203  	_pluginsAdminDlg.init(_pPublicInterface->getHinst(), hwnd);
204  	_mainEditView.setMakerStyle(svp._folderStyle);
205  	_subEditView.setMakerStyle(svp._folderStyle);
206  	_mainEditView.defineDocType(_mainEditView.getCurrentBuffer()->getLangType());
207  	_subEditView.defineDocType(_subEditView.getCurrentBuffer()->getLangType());
208  	_mainEditView.setWrapMode(svp._lineWrapMethod);
209  	_subEditView.setWrapMode(svp._lineWrapMethod);
210  	_mainEditView.execute(SCI_SETENDATLASTLINE, !svp._scrollBeyondLastLine);
211  	_subEditView.execute(SCI_SETENDATLASTLINE, !svp._scrollBeyondLastLine);
212  	if (svp._doSmoothFont)
213  	{
214  		_mainEditView.execute(SCI_SETFONTQUALITY, SC_EFF_QUALITY_LCD_OPTIMIZED);
215  		_subEditView.execute(SCI_SETFONTQUALITY, SC_EFF_QUALITY_LCD_OPTIMIZED);
216  	}
217  	_mainEditView.setBorderEdge(svp._showBorderEdge);
218  	_subEditView.setBorderEdge(svp._showBorderEdge);
219  	_mainEditView.execute(SCI_SETCARETLINEVISIBLEALWAYS, true);
220  	_subEditView.execute(SCI_SETCARETLINEVISIBLEALWAYS, true);
221  	_mainEditView.wrap(svp._doWrap);
222  	_subEditView.wrap(svp._doWrap);
223  	::SendMessage(hwnd, NPPM_INTERNAL_EDGEMULTISETSIZE, 0, 0);
224  	_mainEditView.showEOL(svp._eolShow);
225  	_subEditView.showEOL(svp._eolShow);
226  	_mainEditView.showWSAndTab(svp._whiteSpaceShow);
227  	_subEditView.showWSAndTab(svp._whiteSpaceShow);
228  	_mainEditView.showWrapSymbol(svp._wrapSymbolShow);
229  	_subEditView.showWrapSymbol(svp._wrapSymbolShow);
230  	_mainEditView.performGlobalStyles();
231  	_subEditView.performGlobalStyles();
232  	_zoomOriginalValue = _pEditView->execute(SCI_GETZOOM);
233  	_mainEditView.execute(SCI_SETZOOM, svp._zoom);
234  	_subEditView.execute(SCI_SETZOOM, svp._zoom2);
235  	::SendMessage(hwnd, NPPM_INTERNAL_SETMULTISELCTION, 0, 0);
236  	_mainEditView.execute(SCI_SETADDITIONALSELECTIONTYPING, true);
237  	_subEditView.execute(SCI_SETADDITIONALSELECTIONTYPING, true);
238  	int virtualSpaceOptions = SCVS_RECTANGULARSELECTION;
239  	if(svp._virtualSpace)
240  		virtualSpaceOptions |= SCVS_USERACCESSIBLE | SCVS_NOWRAPLINESTART;
241  	_mainEditView.execute(SCI_SETVIRTUALSPACEOPTIONS, virtualSpaceOptions);
242  	_subEditView.execute(SCI_SETVIRTUALSPACEOPTIONS, virtualSpaceOptions);
243  	_mainEditView.execute(SCI_SETMULTIPASTE, SC_MULTIPASTE_EACH);
244  	_subEditView.execute(SCI_SETMULTIPASTE, SC_MULTIPASTE_EACH);
245  	_mainEditView.execute(SCI_SETMOUSESELECTIONRECTANGULARSWITCH, true);
246  	_subEditView.execute(SCI_SETMOUSESELECTIONRECTANGULARSWITCH, true);
247  	_mainEditView.execute(SCI_SETAUTOMATICFOLD, SC_AUTOMATICFOLD_SHOW | SC_AUTOMATICFOLD_CHANGE);
248  	_subEditView.execute(SCI_SETAUTOMATICFOLD, SC_AUTOMATICFOLD_SHOW | SC_AUTOMATICFOLD_CHANGE);
249  	_mainEditView.execute(SCI_SETMARGINLEFT, 0, svp._paddingLeft);
250  	_mainEditView.execute(SCI_SETMARGINRIGHT, 0, svp._paddingRight);
251  	_subEditView.execute(SCI_SETMARGINLEFT, 0, svp._paddingLeft);
252  	_subEditView.execute(SCI_SETMARGINRIGHT, 0, svp._paddingRight);
253  	_mainEditView.execute(SCI_STYLESETCHECKMONOSPACED, STYLE_DEFAULT, true);
254  	_subEditView.execute(SCI_STYLESETCHECKMONOSPACED, STYLE_DEFAULT, true);
255  	TabBarPlus::doDragNDrop(true);
256  	const auto& hf = _mainDocTab.getFont(_toReduceTabBar);
257  	if (hf)
258  	{
259  		::SendMessage(_mainDocTab.getHSelf(), WM_SETFONT, reinterpret_cast<WPARAM>(hf), MAKELPARAM(TRUE, 0));
260  		::SendMessage(_subDocTab.getHSelf(), WM_SETFONT, reinterpret_cast<WPARAM>(hf), MAKELPARAM(TRUE, 0));
261  	}
262  	int tabDpiDynamicalHeight = nppParam._dpiManager.scaleY(_toReduceTabBar ? g_TabHeight : g_TabHeightLarge);
263  	int tabDpiDynamicalWidth = nppParam._dpiManager.scaleX(g_TabWidth);
264  	TabCtrl_SetItemSize(_mainDocTab.getHSelf(), tabDpiDynamicalWidth, tabDpiDynamicalHeight);
265  	TabCtrl_SetItemSize(_subDocTab.getHSelf(), tabDpiDynamicalWidth, tabDpiDynamicalHeight);
266  	_mainDocTab.display();
267  	TabBarPlus::doDragNDrop((tabBarStatus & TAB_DRAGNDROP) != 0);
268  	TabBarPlus::setDrawTopBar((tabBarStatus & TAB_DRAWTOPBAR) != 0);
269  	TabBarPlus::setDrawInactiveTab((tabBarStatus & TAB_DRAWINACTIVETAB) != 0);
270  	TabBarPlus::setDrawTabCloseButton((tabBarStatus & TAB_CLOSEBUTTON) != 0);
271  	TabBarPlus::setDbClk2Close((tabBarStatus & TAB_DBCLK2CLOSE) != 0);
272  	TabBarPlus::setVertical((tabBarStatus & TAB_VERTICAL) != 0);
273  	drawTabbarColoursFromStylerArray();
274  	const Style* pStyle = NppParameters::getInstance().getGlobalStylers().findByID(STYLE_DEFAULT);
275  	if (pStyle)
276  	{
277  		NppParameters::getInstance().setCurrentDefaultFgColor(pStyle->_fgColor);
278  		NppParameters::getInstance().setCurrentDefaultBgColor(pStyle->_bgColor);
279  		drawAutocompleteColoursFromTheme(pStyle->_fgColor, pStyle->_bgColor);
280  	}
281  	AutoCompletion::drawAutocomplete(_pEditView);
282  	AutoCompletion::drawAutocomplete(_pNonEditView);
283  	drawDocumentMapColoursFromStylerArray();
284  	bool isVertical = (nppGUI._splitterPos == POS_VERTICAL);
285  	int splitterSizeDyn = nppParam._dpiManager.scaleX(splitterSize);
286  	_subSplitter.init(_pPublicInterface->getHinst(), hwnd);
287  	_subSplitter.create(&_mainDocTab, &_subDocTab, splitterSizeDyn, SplitterMode::DYNAMIC, 50, isVertical);
288  	bool willBeShown = nppGUI._statusBarShow;
289  	_statusBar.init(_pPublicInterface->getHinst(), hwnd, 6);
290  	_statusBar.setPartWidth(STATUSBAR_DOC_SIZE, nppParam._dpiManager.scaleX(220));
291  	_statusBar.setPartWidth(STATUSBAR_CUR_POS, nppParam._dpiManager.scaleX(260));
292  	_statusBar.setPartWidth(STATUSBAR_EOF_FORMAT, nppParam._dpiManager.scaleX(110));
293  	_statusBar.setPartWidth(STATUSBAR_UNICODE_TYPE, nppParam._dpiManager.scaleX(120));
294  	_statusBar.setPartWidth(STATUSBAR_TYPING_MODE, nppParam._dpiManager.scaleX(30));
295  	_statusBar.display(willBeShown);
296  	_pMainWindow = &_mainDocTab;
297  	_dockingManager.init(_pPublicInterface->getHinst(), hwnd, &_pMainWindow);
298  	if (nppGUI._isMinimizedToTray && _pTrayIco == nullptr)
299  	{
300  		HICON icon = nullptr;
301  		Notepad_plus_Window::loadTrayIcon(_pPublicInterface->getHinst(), &icon);
302  		_pTrayIco = new trayIconControler(hwnd, IDI_M30ICON, NPPM_INTERNAL_MINIMIZED_TRAY, icon, TEXT(""));
303  	}
304  	checkSyncState();
305  	NppData nppData;
306  	nppData._nppHandle = hwnd;
307  	nppData._scintillaMainHandle = _mainEditView.getHSelf();
308  	nppData._scintillaSecondHandle = _subEditView.getHSelf();
309  	_scintillaCtrls4Plugins.init(_pPublicInterface->getHinst(), hwnd);
310  	_pluginsManager.init(nppData);
311  	bool enablePluginAdmin = _pluginsAdminDlg.initFromJson();
312  	_pluginsManager.loadPlugins(nppParam.getPluginRootDir(), enablePluginAdmin ? &_pluginsAdminDlg.getAvailablePluginUpdateInfoList() : nullptr, enablePluginAdmin ? &_pluginsAdminDlg.getIncompatibleList() : nullptr);
313  	_restoreButton.init(_pPublicInterface->getHinst(), hwnd);
314  	setupColorSampleBitmapsOnMainMenuItems();
315  	HMENU hMacroMenu = ::GetSubMenu(_mainMenuHandle, MENUINDEX_MACRO);
316  	size_t const macroPosBase = 6;
317  	DynamicMenu& macroMenuItems = nppParam.getMacroMenuItems();
318  	size_t nbMacroTopLevelItem = macroMenuItems.getTopLevelItemNumber();
319  	if (nbMacroTopLevelItem >= 1)
320  		::InsertMenu(hMacroMenu, macroPosBase - 1, MF_BYPOSITION, static_cast<UINT>(-1), 0);
321  	macroMenuItems.attach(hMacroMenu, macroPosBase, IDM_SETTING_SHORTCUT_MAPPER_MACRO, TEXT("Modify Shortcut/Delete Macro..."));
322  	HMENU hRunMenu = ::GetSubMenu(_mainMenuHandle, MENUINDEX_RUN);
323  	int const runPosBase = 2;
324  	DynamicMenu& runMenuItems = nppParam.getRunMenuItems();
325  	size_t nbRunTopLevelItem = runMenuItems.getTopLevelItemNumber();
326  	if (nbRunTopLevelItem >= 1)
327  		::InsertMenu(hRunMenu, runPosBase - 1, MF_BYPOSITION, static_cast<UINT>(-1), 0);
328  	runMenuItems.attach(hRunMenu, runPosBase, IDM_SETTING_SHORTCUT_MAPPER_RUN, TEXT("Modify Shortcut/Delete Command..."));
329  	if (!nppGUI._doesExistUpdater)
330  	{
331  		::DeleteMenu(_mainMenuHandle, IDM_UPDATE_NPP, MF_BYCOMMAND);
332  		::DeleteMenu(_mainMenuHandle, IDM_CONFUPDATERPROXY, MF_BYCOMMAND);
333  		HMENU hHelpMenu = ::GetSubMenu(_mainMenuHandle, MENUINDEX_HELP);
334  		if (hHelpMenu)
335  			::DeleteMenu(hHelpMenu, 7, MF_BYPOSITION); 
336  		::DrawMenuBar(hwnd);
337  	}
338  	HMENU hLangMenu = ::GetSubMenu(_mainMenuHandle, MENUINDEX_LANGUAGE);
339  	WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
340  	for (int i = 0; i < nppParam.getNbExternalLang(); ++i)
341  	{
342  		HMENU subMenu = hLangMenu;
343  		ExternalLangContainer & externalLangContainer = nppParam.getELCFromIndex(i);
344  		int nbItem = ::GetMenuItemCount(subMenu);
345  		TCHAR buffer[MAX_EXTERNAL_LEXER_NAME_LEN]{TEXT('\0')};
346  		const TCHAR* lexerNameW = wmc.char2wchar(externalLangContainer._name.c_str(), CP_ACP);
347  		int x = 0;
348  		MENUITEMINFO menuItemInfo
349  		{
350  			.cbSize = sizeof(MENUITEMINFO),
351  			.fMask = MIIM_FTYPE
352  		};
353  		for (; x < nbItem; ++x)
354  		{
355  			::GetMenuItemInfo(subMenu, x, TRUE, &menuItemInfo);
356  			if (menuItemInfo.fType & MFT_SEPARATOR)
357  			{
358  				break;
359  			}
360  		}
361  		TCHAR firstLetter = towupper(lexerNameW[0]);
362  		menuItemInfo.fMask = MIIM_SUBMENU;
363  		for (++x; x < nbItem; ++x)
364  		{
365  			::GetMenuItemInfo(subMenu, x, TRUE, &menuItemInfo);
366  			::GetMenuString(subMenu, x, buffer, MAX_EXTERNAL_LEXER_NAME_LEN, MF_BYPOSITION);
367  			if (menuItemInfo.hSubMenu && buffer[0] == firstLetter)
368  			{
369  				subMenu = menuItemInfo.hSubMenu;
370  				nbItem = ::GetMenuItemCount(subMenu);
371  				x = -1;
372  			}
373  			else if (lstrcmp(lexerNameW, buffer) < 0)
374  			{
375  				break;
376  			}
377  		}
378  		::InsertMenu(subMenu, x, MF_BYPOSITION, IDM_LANG_EXTERNAL + i, lexerNameW);
379  	}
380  	if (nppGUI._excludedLangList.size() > 0)
381  	{
382  		for (size_t i = 0, len = nppGUI._excludedLangList.size(); i < len; ++i)
383  		{
384  			int cmdID = nppParam.langTypeToCommandID(nppGUI._excludedLangList[i]._langType);
385  			const int itemSize = 256;
386  			TCHAR itemName[itemSize];
387  			::GetMenuString(hLangMenu, cmdID, itemName, itemSize, MF_BYCOMMAND);
388  			nppGUI._excludedLangList[i]._cmdID = cmdID;
389  			nppGUI._excludedLangList[i]._langName = itemName;
390  			::DeleteMenu(hLangMenu, cmdID, MF_BYCOMMAND);
391  			DrawMenuBar(hwnd);
392  		}
393  	}
394  	int udlpos = ::GetMenuItemCount(hLangMenu) - 1;
395  	for (int i = 0, len = nppParam.getNbUserLang(); i < len; ++i)
396  	{
397  		UserLangContainer & userLangContainer = nppParam.getULCFromIndex(i);
398  		::InsertMenu(hLangMenu, udlpos + i, MF_BYPOSITION, IDM_LANG_USER + i + 1, userLangContainer.getName());
399  	}
400  	HMENU hFileMenu = ::GetSubMenu(_mainMenuHandle, MENUINDEX_FILE);
401  	int nbLRFile = nppParam.getNbLRFile();
402  	_lastRecentFileList.initMenu(hFileMenu, IDM_FILEMENU_LASTONE + 1, IDM_FILEMENU_EXISTCMDPOSITION, &_accelerator, nppParam.putRecentFileInSubMenu());
403  	_lastRecentFileList.setLangEncoding(_nativeLangSpeaker.getLangEncoding());
404  	for (int i = 0; i < nbLRFile; ++i)
405  	{
406  		generic_string * stdStr = nppParam.getLRFile(i);
407  		if (!nppGUI._checkHistoryFiles || PathFileExists(stdStr->c_str()))
408  		{
409  			_lastRecentFileList.add(stdStr->c_str());
410  		}
411  	}
412  	_pluginsAdminDlg.setPluginsManager(&_pluginsManager);
413  	_pluginsManager.initMenu(_mainMenuHandle, enablePluginAdmin);
414  	::EnableMenuItem(_mainMenuHandle, IDM_FOCUS_ON_FOUND_RESULTS, MF_DISABLED | MF_GRAYED | MF_BYCOMMAND);
415  	nppParam.getContextMenuFromXmlTree(_mainMenuHandle, _pluginsManager.getMenuHandle());
416  	nppParam.getContextMenuFromXmlTree(_mainMenuHandle, _pluginsManager.getMenuHandle(), false);
417  	if (nppParam.hasCustomContextMenu())
418  	{
419  		_mainEditView.execute(SCI_USEPOPUP, FALSE);
420  		_subEditView.execute(SCI_USEPOPUP, FALSE);
421  	}
422  	_nativeLangSpeaker.changeMenuLang(_mainMenuHandle);
423  	::DrawMenuBar(hwnd);
424  	_windowsMenu.init(_mainMenuHandle);
425  	vector<MenuItemUnit> & tmp = nppParam.getContextMenuItems();
426  	size_t len = tmp.size();
427  	TCHAR menuName[menuItemStrLenMax];
428  	for (size_t i = 0; i < len; ++i)
429  	{
430  		if (tmp[i]._itemName.empty())
431  		{
432  			::GetMenuString(_mainMenuHandle, tmp[i]._cmdID, menuName, menuItemStrLenMax, MF_BYCOMMAND);
433  			tmp[i]._itemName = purgeMenuItemString(menuName);
434  		}
435  	}
436  	vector<MenuItemUnit>& tmp2 = nppParam.getTabContextMenuItems();
437  	size_t len2 = tmp2.size();
438  	for (size_t i = 0; i < len2; ++i)
439  	{
440  		if (tmp2[i]._itemName.empty())
441  		{
442  			::GetMenuString(_mainMenuHandle, tmp2[i]._cmdID, menuName, menuItemStrLenMax, MF_BYCOMMAND);
443  			tmp2[i]._itemName = purgeMenuItemString(menuName);
444  		}
445  	}
446  	updateCommandShortcuts();
447  	_nativeLangSpeaker.changeShortcutLang();
448  	nppParam.reloadPluginCmds();
449  	_accelerator.init(_mainMenuHandle, hwnd);
450  	nppParam.setAccelerator(&_accelerator);
451  	vector<HWND> scints;
452  	scints.push_back(_mainEditView.getHSelf());
453  	scints.push_back(_subEditView.getHSelf());
454  	_scintaccelerator.init(&scints, _mainMenuHandle, hwnd);
455  	nppParam.setScintillaAccelerator(&_scintaccelerator);
456  	_scintaccelerator.updateKeys();
457  	::DrawMenuBar(hwnd);
458  	const int toolbarState = NppDarkMode::getToolBarIconSet(NppDarkMode::isEnabled());
459  	if (toolbarState != -1)
460  	{
461  		nppGUI._toolBarStatus = static_cast<toolBarStatusType>(toolbarState);
462  	}
463  	toolBarStatusType tbStatus = nppGUI._toolBarStatus;
464  	willBeShown = nppGUI._toolbarShow;
465  	SCNotification scnN{};
466  	scnN.nmhdr.code = NPPN_TBMODIFICATION;
467  	scnN.nmhdr.hwndFrom = hwnd;
468  	scnN.nmhdr.idFrom = 0;
469  	_pluginsManager.notify(&scnN);
470  	_toolBar.init(_pPublicInterface->getHinst(), hwnd, tbStatus, toolBarIcons, sizeof(toolBarIcons) / sizeof(ToolBarButtonUnit));
471  	_rebarTop.init(_pPublicInterface->getHinst(), hwnd);
472  	_rebarBottom.init(_pPublicInterface->getHinst(), hwnd);
473  	_toolBar.addToRebar(&_rebarTop);
474  	_rebarTop.setIDVisible(REBAR_BAR_TOOLBAR, willBeShown);
475  	checkMacroState();
476  	_findReplaceDlg.init(_pPublicInterface->getHinst(), hwnd, &_pEditView);
477  	_findInFinderDlg.init(_pPublicInterface->getHinst(), hwnd);
478  	_incrementFindDlg.init(_pPublicInterface->getHinst(), hwnd, &_findReplaceDlg, _nativeLangSpeaker.isRTL());
479  	_incrementFindDlg.addToRebar(&_rebarBottom);
480  	_goToLineDlg.init(_pPublicInterface->getHinst(), hwnd, &_pEditView);
481  	_findCharsInRangeDlg.init(_pPublicInterface->getHinst(), hwnd, &_pEditView);
482  	_colEditorDlg.init(_pPublicInterface->getHinst(), hwnd, &_pEditView);
483  	_aboutDlg.init(_pPublicInterface->getHinst(), hwnd);
484  	_debugInfoDlg.init(_pPublicInterface->getHinst(), hwnd, _isAdministrator, _pluginsManager.getLoadedPluginNames());
485  	_runDlg.init(_pPublicInterface->getHinst(), hwnd);
486  	_runMacroDlg.init(_pPublicInterface->getHinst(), hwnd);
487  	_documentPeeker.init(_pPublicInterface->getHinst(), hwnd);
488  	_md5FromFilesDlg.init(_pPublicInterface->getHinst(), hwnd);
489  	_md5FromFilesDlg.setHashType(hash_md5);
490  	_md5FromTextDlg.init(_pPublicInterface->getHinst(), hwnd);
491  	_md5FromTextDlg.setHashType(hash_md5);
492  	_sha2FromFilesDlg.init(_pPublicInterface->getHinst(), hwnd);
493  	_sha2FromFilesDlg.setHashType(hash_sha256);
494  	_sha2FromTextDlg.init(_pPublicInterface->getHinst(), hwnd);
495  	_sha2FromTextDlg.setHashType(hash_sha256);
496  	_sha1FromFilesDlg.init(_pPublicInterface->getHinst(), hwnd);
497  	_sha1FromFilesDlg.setHashType(hash_sha1);
498  	_sha1FromTextDlg.init(_pPublicInterface->getHinst(), hwnd);
499  	_sha1FromTextDlg.setHashType(hash_sha1);
500  	_sha512FromFilesDlg.init(_pPublicInterface->getHinst(), hwnd);
501  	_sha512FromFilesDlg.setHashType(hash_sha512);
502  	_sha512FromTextDlg.init(_pPublicInterface->getHinst(), hwnd);
503  	_sha512FromTextDlg.setHashType(hash_sha512);
504  	int uddStatus = nppGUI._userDefineDlgStatus;
505  	UserDefineDialog *udd = _pEditView->getUserDefineDlg();
506  	bool uddShow = false;
507  	switch (uddStatus)
508  	{
509  		case UDD_SHOW: 
510  		{
511  			udd->doDialog(true, _nativeLangSpeaker.isRTL());
512  			_nativeLangSpeaker.changeUserDefineLang(udd);
513  			uddShow = true;
514  			break;
515  		}
516  		case UDD_DOCKED: 
517  		{
518  			_isUDDocked = true;
519  			break;
520  		}
521  		case (UDD_SHOW | UDD_DOCKED):    
522  		{
523  			udd->doDialog(true, _nativeLangSpeaker.isRTL());
524  			_nativeLangSpeaker.changeUserDefineLang(udd);
525  			::SendMessage(udd->getHSelf(), WM_COMMAND, IDC_DOCK_BUTTON, 0);
526  			uddShow = true;
527  			break;
528  		}
529  		default: 
530  			break;
531  	}
532  	checkMenuItem(IDM_LANG_USER_DLG, uddShow);
533  	_toolBar.setCheck(IDM_LANG_USER_DLG, uddShow);
534  	if (nppGUI._hideMenuRightShortcuts)
535  	{
536  		int nbRemoved = 0;
537  		const int bufferSize = 64;
538  		TCHAR buffer[bufferSize];
539  		int nbItem = GetMenuItemCount(_mainMenuHandle);
540  		for (int i = nbItem - 1; i >= 0; --i)
541  		{
542  			::GetMenuStringW(_mainMenuHandle, i, buffer, bufferSize, MF_BYPOSITION);
543  			if (lstrcmp(buffer, L"✕") == 0 || lstrcmp(buffer, L"▼") == 0 || lstrcmp(buffer, L"＋") == 0)
544  			{
545  				::RemoveMenu(_mainMenuHandle, i, MF_BYPOSITION);
546  				++nbRemoved;
547  			}
548  			if (nbRemoved == 3)
549  				break;
550  		}
551  		if (nbRemoved > 0)
552  			::DrawMenuBar(hwnd);
553  	}
554  	{
555  		const Style * pStyle = nppParam.getGlobalStylers().findByID(STYLE_DEFAULT);
556  		if (pStyle)
557  		{
558  			nppParam.setCurrentDefaultFgColor(pStyle->_fgColor);
559  			nppParam.setCurrentDefaultBgColor(pStyle->_bgColor);
560  		}
561  	}
562  	DockingManagerData& dmd = nppGUI._dockingData;
563  	_dockingManager.setDockedContSize(CONT_LEFT, nppGUI._dockingData._leftWidth);
564  	_dockingManager.setDockedContSize(CONT_RIGHT, nppGUI._dockingData._rightWidth);
565  	_dockingManager.setDockedContSize(CONT_TOP, nppGUI._dockingData._topHeight);
566  	_dockingManager.setDockedContSize(CONT_BOTTOM, nppGUI._dockingData._bottomHight);
567  	{
568  		for (size_t i = 0, len = dmd._pluginDockInfo.size(); i < len; ++i)
569  		{
570  			PluginDlgDockingInfo& pdi = dmd._pluginDockInfo[i];
571  			const bool isInternalFunc = pdi._name == NPP_INTERNAL_FUCTION_STR;
572  			bool showPanel = true;
573  			if (nppGUI._isCmdlineNosessionActivated)
574  			{
575  				const bool showProjectPanel = isInternalFunc
576  					&& nppGUI._projectPanelKeepState
577  					&& (pdi._internalID != IDM_EDIT_CLIPBOARDHISTORY_PANEL
578  						&& pdi._internalID != IDM_VIEW_DOCLIST
579  						&& pdi._internalID != IDM_EDIT_CHAR_PANEL
580  						&& pdi._internalID != IDM_VIEW_FILEBROWSER
581  						&& pdi._internalID != IDM_VIEW_DOC_MAP
582  						&& pdi._internalID != IDM_VIEW_FUNC_LIST);
583  				const bool showInternalPanel = isInternalFunc
584  					&& ((pdi._internalID == IDM_EDIT_CLIPBOARDHISTORY_PANEL && nppGUI._clipboardHistoryPanelKeepState)
585  						|| (pdi._internalID == IDM_VIEW_DOCLIST && nppGUI._docListKeepState)
586  						|| (pdi._internalID == IDM_EDIT_CHAR_PANEL && nppGUI._charPanelKeepState)
587  						|| (pdi._internalID == IDM_VIEW_FILEBROWSER && nppGUI._fileBrowserKeepState)
588  						|| (showProjectPanel)
589  						|| (pdi._internalID == IDM_VIEW_DOC_MAP && nppGUI._docMapKeepState)
590  						|| (pdi._internalID == IDM_VIEW_FUNC_LIST && nppGUI._funcListKeepState));
591  				showPanel = ((!isInternalFunc && nppGUI._pluginPanelKeepState) || showInternalPanel);
592  			}
593  			if (pdi._isVisible && showPanel)
594  			{
595  				if (isInternalFunc)
596  					_internalFuncIDs.push_back(pdi._internalID);
597  				else
598  					_pluginsManager.runPluginCommand(pdi._name.c_str(), pdi._internalID);
599  			}
600  		}
601  		for (size_t i = 0, len = dmd._containerTabInfo.size(); i < len; ++i)
602  		{
603  			ContainerTabInfo & cti = dmd._containerTabInfo[i];
604  			_dockingManager.setActiveTab(cti._cont, cti._activeTab);
605  		}
606  	}
607  	loadBufferIntoView(_mainEditView.getCurrentBufferID(), MAIN_VIEW);
608  	loadBufferIntoView(_subEditView.getCurrentBufferID(), SUB_VIEW);
609  	activateBuffer(_mainEditView.getCurrentBufferID(), MAIN_VIEW);
610  	activateBuffer(_subEditView.getCurrentBufferID(), SUB_VIEW);
611  	_mainEditView.getFocus();
612  	if (_nativeLangSpeaker.isRTL())
613  	{
614  		_mainEditView.changeTextDirection(true);
615  		_subEditView.changeTextDirection(true);
616  	}
617  	return TRUE;
618  }
619  void Notepad_plus::killAllChildren()
620  {
621  	_toolBar.destroy();
622  	_rebarTop.destroy();
623  	_rebarBottom.destroy();
624      if (_pMainSplitter)
625      {
626          _pMainSplitter->destroy();
627          delete _pMainSplitter;
628      }
629      _mainDocTab.destroy();
630      _subDocTab.destroy();
631  	_mainEditView.destroy();
632      _subEditView.destroy();
633  	_invisibleEditView.destroy();
634      _subSplitter.destroy();
635      _statusBar.destroy();
636  	_scintillaCtrls4Plugins.destroy();
637  	_dockingManager.destroy();
638  }
639  bool Notepad_plus::saveGUIParams()
640  {
641  	NppParameters& nppParams = NppParameters::getInstance();
642  	NppGUI & nppGUI = nppParams.getNppGUI();
643  	nppGUI._toolbarShow = _rebarTop.getIDVisible(REBAR_BAR_TOOLBAR);
644  	nppGUI._toolBarStatus = _toolBar.getState();
645  	nppGUI._tabStatus = (TabBarPlus::doDragNDropOrNot()?TAB_DRAWTOPBAR:0) | \
646  						(TabBarPlus::drawTopBar()?TAB_DRAGNDROP:0) | \
647  						(TabBarPlus::drawInactiveTab()?TAB_DRAWINACTIVETAB:0) | \
648  						(_toReduceTabBar?TAB_REDUCE:0) | \
649  						(TabBarPlus::drawTabCloseButton()?TAB_CLOSEBUTTON:0) | \
650  						(TabBarPlus::isDbClk2Close()?TAB_DBCLK2CLOSE:0) | \
651  						(TabBarPlus::isVertical() ? TAB_VERTICAL:0) | \
652  						(TabBarPlus::isMultiLine() ? TAB_MULTILINE:0) |\
653  						(nppGUI._tabStatus & TAB_HIDE) | \
654  						(nppGUI._tabStatus & TAB_QUITONEMPTY) | \
655  						(nppGUI._tabStatus & TAB_ALTICONS);
656  	nppGUI._splitterPos = _subSplitter.isVertical()?POS_VERTICAL:POS_HORIZOTAL;
657  	UserDefineDialog *udd = _pEditView->getUserDefineDlg();
658  	bool b = udd->isDocked();
659  	nppGUI._userDefineDlgStatus = (b?UDD_DOCKED:0) | (udd->isVisible()?UDD_SHOW:0);
660  	WINDOWPLACEMENT posInfo{};
661  	posInfo.length = sizeof(WINDOWPLACEMENT);
662  	::GetWindowPlacement(_pPublicInterface->getHSelf(), &posInfo);
663  	nppGUI._appPos.left   = posInfo.rcNormalPosition.left;
664  	nppGUI._appPos.top    = posInfo.rcNormalPosition.top;
665  	nppGUI._appPos.right  = posInfo.rcNormalPosition.right - posInfo.rcNormalPosition.left;
666  	nppGUI._appPos.bottom = posInfo.rcNormalPosition.bottom - posInfo.rcNormalPosition.top;
667  	nppGUI._isMaximized = ((IsZoomed(_pPublicInterface->getHSelf()) != 0) || (posInfo.flags & WPF_RESTORETOMAXIMIZED));
668  	if (_findReplaceDlg.getHSelf() != NULL)
669  	{
670  		::GetWindowPlacement(_findReplaceDlg.getHSelf(), &posInfo);
671  		nppGUI._findWindowPos.left = posInfo.rcNormalPosition.left;
672  		nppGUI._findWindowPos.top = posInfo.rcNormalPosition.top;
673  		nppGUI._findWindowPos.right = posInfo.rcNormalPosition.right;
674  		nppGUI._findWindowPos.bottom = posInfo.rcNormalPosition.bottom;
675  	}
676  	saveDockingParams();
677  	nppParams.createXmlTreeFromGUIParams();
678  	return true;
679  }
680  bool Notepad_plus::saveColumnEditorParams()
681  {
682  	NppParameters& nppParams = NppParameters::getInstance();
683  	return nppParams.writeColumnEditorSettings();
684  }
685  bool Notepad_plus::saveProjectPanelsParams()
686  {
687  	NppParameters& nppParams = NppParameters::getInstance();
688  	if (_pProjectPanel_1)
689  	{
690  		if (!_pProjectPanel_1->checkIfNeedSave()) return false;
691  		nppParams.setWorkSpaceFilePath(0, _pProjectPanel_1->getWorkSpaceFilePath());
692  	}
693  	if (_pProjectPanel_2)
694  	{
695  		if (!_pProjectPanel_2->checkIfNeedSave()) return false;
696  		nppParams.setWorkSpaceFilePath(1, _pProjectPanel_2->getWorkSpaceFilePath());
697  	}
698  	if (_pProjectPanel_3)
699  	{
700  		if (!_pProjectPanel_3->checkIfNeedSave()) return false;
701  		nppParams.setWorkSpaceFilePath(2, _pProjectPanel_3->getWorkSpaceFilePath());
702  	}
703  	return nppParams.writeProjectPanelsSettings();
704  }
705  bool Notepad_plus::saveFileBrowserParam()
706  {
707  	if (_pFileBrowser)
708  	{
709  		vector<generic_string> rootPaths = _pFileBrowser->getRoots();
710  		generic_string selectedItemPath = _pFileBrowser->getSelectedItemPath();
711  		return (NppParameters::getInstance()).writeFileBrowserSettings(rootPaths, selectedItemPath);
712  	}
713  	return true; 
714  }
715  void Notepad_plus::saveDockingParams()
716  {
717  	NppGUI & nppGUI = (NppParameters::getInstance()).getNppGUI();
718  	nppGUI._dockingData._leftWidth		= _dockingManager.getDockedContSize(CONT_LEFT);
719  	nppGUI._dockingData._rightWidth		= _dockingManager.getDockedContSize(CONT_RIGHT);
720  	nppGUI._dockingData._topHeight		= _dockingManager.getDockedContSize(CONT_TOP);
721  	nppGUI._dockingData._bottomHight	= _dockingManager.getDockedContSize(CONT_BOTTOM);
722  	nppGUI._dockingData._containerTabInfo.clear();
723  	vector<PluginDlgDockingInfo>	vPluginDockInfo;
724  	vector<FloatingWindowInfo>		vFloatingWindowInfo;
725  	vector<DockingCont*> vCont = _dockingManager.getContainerInfo();
726  	for (size_t i = 0, len = vCont.size(); i < len ; ++i)
727  	{
728  		vector<tTbData *>	vDataVis	= vCont[i]->getDataOfVisTb();
729  		for (size_t j = 0, len2 = vDataVis.size(); j < len2 ; ++j)
730  		{
731  			if (vDataVis[j]->pszName && vDataVis[j]->pszName[0])
732  			{
733  				PluginDlgDockingInfo pddi(vDataVis[j]->pszModuleName, vDataVis[j]->dlgID, int32_t(i), vDataVis[j]->iPrevCont, true);
734  				vPluginDockInfo.push_back(pddi);
735  			}
736  		}
737  		vector<tTbData *>	vDataAll	= vCont[i]->getDataOfAllTb();
738  		for (size_t j = 0, len3 = vDataAll.size(); j < len3 ; ++j)
739  		{
740  			if ((vDataAll[j]->pszName && vDataAll[j]->pszName[0]) && (!vCont[i]->isTbVis(vDataAll[j])))
741  			{
742  				PluginDlgDockingInfo pddi(vDataAll[j]->pszModuleName, vDataAll[j]->dlgID, int32_t(i), vDataAll[j]->iPrevCont, false);
743  				vPluginDockInfo.push_back(pddi);
744  			}
745  		}
746  		if (i >= DOCKCONT_MAX)
747  		{
748  			RECT	rc;
749  			vCont[i]->getWindowRect(rc);
750  			FloatingWindowInfo fwi(int32_t(i), rc.left, rc.top, rc.right, rc.bottom);
751  			vFloatingWindowInfo.push_back(fwi);
752  		}
753  		ContainerTabInfo act(int32_t(i), vCont[i]->getActiveTb());
754  		nppGUI._dockingData._containerTabInfo.push_back(act);
755  	}
756  	UCHAR floatContArray[50];
757  	memset(floatContArray, 0, 50);
758  	for (size_t i = 0, len4 = nppGUI._dockingData._pluginDockInfo.size(); i < len4 ; ++i)
759  	{
760  		BOOL	isStored = FALSE;
761  		for (size_t j = 0, len5 = vPluginDockInfo.size(); j < len5; ++j)
762  		{
763  			if (nppGUI._dockingData._pluginDockInfo[i] == vPluginDockInfo[j])
764  			{
765  				isStored = TRUE;
766  				break;
767  			}
768  		}
769  		if (isStored == FALSE)
770  		{
771  			int floatCont	= 0;
772  			if (nppGUI._dockingData._pluginDockInfo[i]._currContainer >= DOCKCONT_MAX)
773  				floatCont = nppGUI._dockingData._pluginDockInfo[i]._currContainer;
774  			else
775  				floatCont = nppGUI._dockingData._pluginDockInfo[i]._prevContainer;
776  			if (floatCont >= 0)
777  			{
778  				if (floatContArray[floatCont] == 0)
779  				{
780  					RECT rc;
781  					if (nppGUI._dockingData.getFloatingRCFrom(floatCont, rc))
782  					{
783  						vFloatingWindowInfo.push_back(FloatingWindowInfo(floatCont, rc.left, rc.top, rc.right, rc.bottom));
784  					}
785  					floatContArray[floatCont] = 1;
786  				}
787  			}
788  			if (i < nppGUI._dockingData._pluginDockInfo.size()) 
789  				vPluginDockInfo.push_back(nppGUI._dockingData._pluginDockInfo[i]);
790  		}
791  	}
792  	nppGUI._dockingData._pluginDockInfo = vPluginDockInfo;
793  	nppGUI._dockingData._flaotingWindowInfo = vFloatingWindowInfo;
794  }
795  void Notepad_plus::saveUserDefineLangs()
796  {
797  	(NppParameters::getInstance()).writeNeed2SaveUDL();
798  }
799  void Notepad_plus::saveShortcuts()
800  {
801  	NppParameters::getInstance().writeShortcuts();
802  }
803  void Notepad_plus::saveFindHistory()
804  {
805  	_findReplaceDlg.saveFindHistory();
806  	(NppParameters::getInstance()).writeFindHistory();
807  }
808  int Notepad_plus::getHtmlXmlEncoding(const TCHAR *fileName) const
809  {
810  	TCHAR *ext = PathFindExtension(fileName);
811  	if (*ext == '.') 
812  	{
813  		ext += 1;
814  	}
815  	else
816  	{
817  		return -1;
818  	}
819  	NppParameters& nppParamInst = NppParameters::getInstance();
820  	LangType langT = nppParamInst.getLangFromExt(ext);
821  	if ((langT != L_XML) && (langT != L_HTML))
822  		return -1;
823  	FILE *f = _wfopen(fileName, TEXT("rb"));
824  	if (!f)
825  		return -1;
826  	const int blockSize = 1024; 
827  	char data[blockSize];
828  	size_t lenFile = fread(data, 1, blockSize, f);
829  	fclose(f);
830  	_invisibleEditView.execute(SCI_CLEARALL);
831  	_invisibleEditView.execute(SCI_APPENDTEXT, lenFile, reinterpret_cast<LPARAM>(data));
832  	const char *encodingAliasRegExpr = "[a-zA-Z0-9_-]+";
833  	const size_t encodingStrLen = 128;
834  	if (langT == L_XML)
835  	{
836  		const char *xmlHeaderRegExpr = "<?xml[ \\t]+version[ \\t]*=[ \\t]*\"[^\"]+\"[ \\t]+encoding[ \\t]*=[ \\t]*\"[^\"]+\"[ \\t]*.*?>";
837          size_t startPos = 0;
838  		size_t endPos = lenFile-1;
839  		_invisibleEditView.execute(SCI_SETSEARCHFLAGS, SCFIND_REGEXP|SCFIND_POSIX);
840  		_invisibleEditView.execute(SCI_SETTARGETRANGE, startPos, endPos);
841  		auto posFound = _invisibleEditView.execute(SCI_SEARCHINTARGET, strlen(xmlHeaderRegExpr), reinterpret_cast<LPARAM>(xmlHeaderRegExpr));
842  		if (posFound >= 0)
843  		{
844              const char *encodingBlockRegExpr = "encoding[ \\t]*=[ \\t]*\"[^\".]+\"";
845  			_invisibleEditView.execute(SCI_SEARCHINTARGET, strlen(encodingBlockRegExpr), reinterpret_cast<LPARAM>(encodingBlockRegExpr));
846              const char *encodingRegExpr = "\".+\"";
847  			_invisibleEditView.execute(SCI_SEARCHINTARGET, strlen(encodingRegExpr), reinterpret_cast<LPARAM>(encodingRegExpr));
848  			_invisibleEditView.execute(SCI_SEARCHINTARGET, strlen(encodingAliasRegExpr), reinterpret_cast<LPARAM>(encodingAliasRegExpr));
849              startPos = _invisibleEditView.execute(SCI_GETTARGETSTART);
850  			endPos = _invisibleEditView.execute(SCI_GETTARGETEND);
851  			size_t len = endPos - startPos;
852  			if (len >= encodingStrLen)
853  			{
854  				return -1;
855  			}
856              char encodingStr[encodingStrLen];
857              _invisibleEditView.getText(encodingStr, startPos, endPos);
858  			EncodingMapper& em = EncodingMapper::getInstance();
859              int enc = em.getEncodingFromString(encodingStr);
860              return (enc == CP_ACP ? -1 : enc);
861  		}
862          return -1;
863  	}
864  	else 
865  	{
866  		const char *htmlHeaderRegExpr  = "<meta[ \\t]+http-equiv[ \\t]*=[ \\t\"']*Content-Type[ \\t\"']*content[ \\t]*= *[\"']text/html;[ \\t]+charset[ \\t]*=[ \\t]*.+[\"'] *&bsol;*>";
867  		const char *htmlHeaderRegExpr2 = "<meta[ \\t]+content[ \\t]*= *[\"']text/html;[ \\t]+charset[ \\t]*=[ \\t]*.+[ \\t\"']http-equiv[ \\t]*=[ \\t\"']*Content-Type[ \\t\"']*&bsol;*>";
868  		const char *charsetBlock = "charset[ \\t]*=[ \\t]*[^\"']+";
869  		const char *intermediaire = "=[ \\t]*.+";
870  		const char *encodingStrRE = "[^ \\t=]+";
871  		intptr_t startPos = 0;
872  		auto endPos = lenFile - 1;
873  		_invisibleEditView.execute(SCI_SETSEARCHFLAGS, SCFIND_REGEXP|SCFIND_POSIX);
874  		_invisibleEditView.execute(SCI_SETTARGETRANGE, startPos, endPos);
875  		auto posFound = _invisibleEditView.execute(SCI_SEARCHINTARGET, strlen(htmlHeaderRegExpr), reinterpret_cast<LPARAM>(htmlHeaderRegExpr));
876  		if (posFound < 0)
877  		{
878  			posFound = _invisibleEditView.execute(SCI_SEARCHINTARGET, strlen(htmlHeaderRegExpr2), reinterpret_cast<LPARAM>(htmlHeaderRegExpr2));
879  			if (posFound < 0)
880  				return -1;
881  		}
882  		_invisibleEditView.execute(SCI_SEARCHINTARGET, strlen(charsetBlock), reinterpret_cast<LPARAM>(charsetBlock));
883  		_invisibleEditView.execute(SCI_SEARCHINTARGET, strlen(intermediaire), reinterpret_cast<LPARAM>(intermediaire));
884  		_invisibleEditView.execute(SCI_SEARCHINTARGET, strlen(encodingStrRE), reinterpret_cast<LPARAM>(encodingStrRE));
885          startPos = _invisibleEditView.execute(SCI_GETTARGETSTART);
886  		endPos = _invisibleEditView.execute(SCI_GETTARGETEND);
887  		size_t len = endPos - startPos;
888  		if (len >= encodingStrLen)
889  		{
890  			return -1;
891  		}
892          char encodingStr[encodingStrLen];
893          _invisibleEditView.getText(encodingStr, startPos, endPos);
894  		EncodingMapper& em = EncodingMapper::getInstance();
895  		int enc = em.getEncodingFromString(encodingStr);
896          return (enc == CP_ACP ? -1 : enc);
897  	}
898  }
899  void Notepad_plus::setCodePageForInvisibleView(Buffer const *pBuffer)
900  {
901  	intptr_t detectedCp = _invisibleEditView.execute(SCI_GETCODEPAGE);
902  	intptr_t cp2set = SC_CP_UTF8;
903  	if (pBuffer->getUnicodeMode() == uni8Bit)
904  	{
905  		cp2set = (detectedCp == SC_CP_UTF8 ? CP_ACP : detectedCp);
906  	}
907  	_invisibleEditView.execute(SCI_SETCODEPAGE, cp2set);
908  }
909  bool Notepad_plus::replaceInOpenedFiles()
910  {
911  	ScintillaEditView *pOldView = _pEditView;
912  	_pEditView = &_invisibleEditView;
913  	Document oldDoc = _invisibleEditView.execute(SCI_GETDOCPOINTER);
914  	Buffer * oldBuf = _invisibleEditView.getCurrentBuffer();	
915  	Buffer * pBuf = NULL;
916  	int nbTotal = 0;
917  	const bool isEntireDoc = true;
918      if (_mainWindowStatus & WindowMainActive)
919      {
920  		for (size_t i = 0, len = _mainDocTab.nbItem(); i < len ; ++i)
921  	    {
922  			pBuf = MainFileManager.getBufferByID(_mainDocTab.getBufferByIndex(i));
923  			if (pBuf->isReadOnly())
924  				continue;
925  			_invisibleEditView.execute(SCI_SETDOCPOINTER, 0, pBuf->getDocument());
926  			setCodePageForInvisibleView(pBuf);
927  			_invisibleEditView.setCurrentBuffer(pBuf);
928  			_invisibleEditView.execute(SCI_BEGINUNDOACTION);
929  			nbTotal += _findReplaceDlg.processAll(ProcessReplaceAll, FindReplaceDlg::_env, isEntireDoc);
930  			_invisibleEditView.execute(SCI_ENDUNDOACTION);
931  		}
932  	}
933  	if (_mainWindowStatus & WindowSubActive)
934  	{
935  		for (size_t i = 0, len = _subDocTab.nbItem(); i < len; ++i)
936  		{
937  			pBuf = MainFileManager.getBufferByID(_subDocTab.getBufferByIndex(i));
938  			if (pBuf->isReadOnly())
939  				continue;
940  			_invisibleEditView.execute(SCI_SETDOCPOINTER, 0, pBuf->getDocument());
941  			setCodePageForInvisibleView(pBuf);
942  			_invisibleEditView.setCurrentBuffer(pBuf);
943  			_invisibleEditView.execute(SCI_BEGINUNDOACTION);
944  			nbTotal += _findReplaceDlg.processAll(ProcessReplaceAll, FindReplaceDlg::_env, isEntireDoc);
945  			_invisibleEditView.execute(SCI_ENDUNDOACTION);
946  		}
947  	}
948  	_invisibleEditView.execute(SCI_SETDOCPOINTER, 0, oldDoc);
949  	_invisibleEditView.setCurrentBuffer(oldBuf);
950  	_pEditView = pOldView;
951  	if (nbTotal < 0)
952  	{
953  		generic_string msg = _nativeLangSpeaker.getLocalizedStrFromID("find-status-replaceinfiles-re-malformed", TEXT("Replace in Opened Files: The regular expression is malformed."));
954  		_findReplaceDlg.setStatusbarMessage(msg, FSNotFound);
955  	}
956  	else
957  	{
958  		if (nbTotal)
959  			enableCommand(IDM_FILE_SAVEALL, true, MENU | TOOLBAR);
960  		generic_string result;
961  		if (nbTotal == 1)
962  		{
963  			result = _nativeLangSpeaker.getLocalizedStrFromID("find-status-replaceinopenedfiles-1-replaced", TEXT("Replace in Opened Files: 1 occurrence was replaced."));
964  		}
965  		else
966  		{
967  			result = _nativeLangSpeaker.getLocalizedStrFromID("find-status-replaceinopenedfiles-nb-replaced", TEXT("Replace in Opened Files: $INT_REPLACE$ occurrences were replaced."));
968  			result = stringReplace(result, TEXT("$INT_REPLACE$"), std::to_wstring(nbTotal));
969  		}
970  		_findReplaceDlg.setStatusbarMessage(result, FSMessage);
971  	}
972  	return true;
973  }
974  void Notepad_plus::wsTabConvert(spaceTab whichWay)
975  {
976  	if ((_pEditView->execute(SCI_GETSELECTIONMODE) == SC_SEL_RECTANGLE) || (_pEditView->execute(SCI_GETSELECTIONMODE) == SC_SEL_THIN))
977  		return;
978  	intptr_t tabWidth = _pEditView->execute(SCI_GETTABWIDTH);
979  	intptr_t currentPos = _pEditView->execute(SCI_GETCURRENTPOS);
980  	intptr_t currentLine = _pEditView->execute(SCI_LINEFROMPOSITION, currentPos);
981  	intptr_t currentPosInLine = currentPos - _pEditView->execute(SCI_POSITIONFROMLINE, currentLine);
982  	intptr_t startLine = 0;
983  	intptr_t endLine = _pEditView->lastZeroBasedLineNumber();
984  	intptr_t endLineCorrect = endLine;
985  	intptr_t dataLength = _pEditView->execute(SCI_GETLENGTH) + 1;
986  	intptr_t mainSelAnchor = _pEditView->execute(SCI_GETANCHOR);
987  	bool isEntireDoc = (mainSelAnchor == currentPos);
988  	auto restoreSelection = [this, mainSelAnchor, currentPos, isEntireDoc]()
989  	{
990  		if (!isEntireDoc)
991  		{
992  			_pEditView->execute(SCI_SETANCHOR, mainSelAnchor);
993  			_pEditView->execute(SCI_SETCURRENTPOS, currentPos);
994  		}
995  	};
996  	if (!isEntireDoc)
997  	{
998  		intptr_t startPos = _pEditView->execute(SCI_GETSELECTIONSTART);
999  		startLine = _pEditView->execute(SCI_LINEFROMPOSITION, startPos);
1000  		intptr_t endPos = _pEditView->execute(SCI_GETSELECTIONEND);
1001  		endLine = endLineCorrect = _pEditView->execute(SCI_LINEFROMPOSITION, endPos);
1002  		if (startPos != _pEditView->execute(SCI_POSITIONFROMLINE, startLine))
1003  			startPos = _pEditView->execute(SCI_POSITIONFROMLINE, startLine);
1004  		if (endPos == _pEditView->execute(SCI_POSITIONFROMLINE, endLine))
1005  			endLineCorrect = endLine - 1;
1006  		else if (endPos < _pEditView->execute(SCI_GETLINEENDPOSITION, endLine))
1007  			endPos = _pEditView->execute(SCI_GETLINEENDPOSITION, endLine);
1008  		dataLength = endPos - startPos + 1;
1009  		_pEditView->execute(SCI_SETSEL, startPos, endPos);
1010  	}
1011  	if (dataLength < 2)
1012  	{
1013  		restoreSelection();
1014  		return;
1015  	}
1016  	intptr_t changeDataCount = 0;
1017  	intptr_t newCurrentPos = 0;
1018  	vector<intptr_t> folding;
1019  	_pEditView->execute(SCI_BEGINUNDOACTION);
1020  	for (intptr_t idx = startLine; idx < endLineCorrect + 1; ++idx)
1021  	{
1022  		intptr_t startPos = _pEditView->execute(SCI_POSITIONFROMLINE, idx);
1023  		intptr_t endPos = _pEditView->execute(SCI_GETLINEENDPOSITION, idx);
1024  		dataLength = endPos - startPos + 1;
1025  		char * source = new char[dataLength];
1026  		if (source == NULL)
1027  			continue;
1028  		source[dataLength - 1] = '\0'; 
1029  		_pEditView->execute(SCI_SETTARGETRANGE, startPos, endPos);
1030  		_pEditView->execute(SCI_GETTARGETTEXT, 0, reinterpret_cast<LPARAM>(source));
1031  		intptr_t count = 0;
1032  		intptr_t column = 0;
1033  		intptr_t tabStop = tabWidth - 1;   
1034  		bool onlyLeading = false;
1035  		if (whichWay == tab2Space)
1036  		{
1037  			for (const char * ch = source; *ch; ++ch)
1038  			{
1039  				if (*ch == '\t')
1040  					++count;
1041  			}
1042  			if (count == 0)
1043  			{
1044  				delete [] source;
1045  				continue;
1046  			}
1047  		}
1048  		size_t newLen = dataLength + count * (tabWidth - 1) + 1;
1049  		char * destination = new char[newLen];
1050  		if (destination == NULL)
1051  		{
1052  			delete [] source;
1053  			continue;
1054  		}
1055  		char * dest = destination;
1056  		intptr_t changeDataLineCount = 0;
1057  		switch (whichWay)
1058  		{
1059  			case tab2Space:
1060  			{
1061  				for (int i = 0; source[i] != '\0'; ++i)
1062  				{
1063  					if (source[i] == '\t')
1064  					{
1065  						intptr_t insertTabs = tabWidth - (column % tabWidth);
1066  						for (int j = 0; j < insertTabs; ++j)
1067  						{
1068  							*dest++ = ' ';
1069  							changeDataCount++;
1070  							changeDataLineCount++;
1071  							if (idx == currentLine && i < currentPosInLine)
1072  								++newCurrentPos;
1073  						}
1074  						column += insertTabs;
1075  					}
1076  					else
1077  					{
1078  						*dest++ = source[i];
1079  						if (idx == currentLine && i < currentPosInLine)
1080  							++newCurrentPos;
1081  						if ((source[i] == '\n') || (source[i] == '\r'))
1082  							column = 0;
1083  						else if ((source[i] & 0xC0) != 0x80)  
1084  							++column;
1085  					}
1086  				}
1087  				*dest = '\0';
1088  				break;
1089  			}
1090  			case space2TabLeading:
1091  			{
1092  				onlyLeading = true;
1093  			}
1094  			[[fallthrough]];
1095  			case space2TabAll:
1096  			{
1097  				bool nextChar = false;
1098  				int counter = 0;
1099  				bool nonSpaceFound = false;
1100  				for (int i = 0; source[i] != '\0'; ++i)
1101  				{
1102  					if (nonSpaceFound == false)
1103  					{
1104  						while (source[i + counter] == ' ')
1105  						{
1106  							if ((column + counter) == tabStop)
1107  							{
1108  								tabStop += tabWidth;
1109  								if (counter >= 1)        
1110  								{
1111  									*dest++ = '\t';
1112  									changeDataCount++;
1113  									changeDataLineCount++;
1114  									i += counter;
1115  									column += counter + 1;
1116  									counter = 0;
1117  									nextChar = true;
1118  									if (idx == currentLine && i <= currentPosInLine)
1119  										++newCurrentPos;
1120  									break;
1121  								}
1122  								else if (source[i + 1] == ' ' || source[i + 1] == '\t')  
1123  								{
1124  									*dest++ = '\t';
1125  									changeDataCount++;
1126  									changeDataLineCount++;
1127  									i++;
1128  									column += 1;
1129  									counter = 0;
1130  									if (idx == currentLine && i <= currentPosInLine)
1131  										++newCurrentPos;
1132  								}
1133  								else       
1134  								{
1135  									*dest++ = source[i];
1136  									column += 1;
1137  									counter = 0;
1138  									nextChar = true;
1139  									if (idx == currentLine && i <= currentPosInLine)
1140  										++newCurrentPos;
1141  									break;
1142  								}
1143  							}
1144  							else
1145  								++counter;
1146  						}
1147  						if (nextChar == true)
1148  						{
1149  							nextChar = false;
1150  							continue;
1151  						}
1152  						if (source[i] == ' ' && source[i + counter] == '\t') 
1153  						{
1154  							*dest++ = '\t';
1155  							changeDataCount++;
1156  							changeDataLineCount++;
1157  							i += counter;
1158  							column = tabStop + 1;
1159  							tabStop += tabWidth;
1160  							counter = 0;
1161  							if (idx == currentLine && i <= currentPosInLine)
1162  								++newCurrentPos;
1163  							continue;
1164  						}
1165  					}
1166  					if (onlyLeading == true && nonSpaceFound == false)
1167  						nonSpaceFound = true;
1168  					if (source[i] == '\n' || source[i] == '\r')
1169  					{
1170  						*dest++ = source[i];
1171  						column = 0;
1172  						tabStop = tabWidth - 1;
1173  						nonSpaceFound = false;
1174  					}
1175  					else if (source[i] == '\t')
1176  					{
1177  						*dest++ = source[i];
1178  						column = tabStop + 1;
1179  						tabStop += tabWidth;
1180  						counter = 0;
1181  					}
1182  					else
1183  					{
1184  						*dest++ = source[i];
1185  						counter = 0;
1186  						if ((source[i] & 0xC0) != 0x80)   
1187  						{
1188  							++column;
1189  							if (column > 0 && column % tabWidth == 0)
1190  								tabStop += tabWidth;
1191  						}
1192  					}
1193  					if (idx == currentLine && i < currentPosInLine)
1194  						++newCurrentPos;
1195  				}
1196  				*dest = '\0';
1197  				break;
1198  			}
1199  		}
1200  		if ((_pEditView->execute(SCI_GETFOLDLEVEL, idx) & SC_FOLDLEVELHEADERFLAG))
1201  			if (_pEditView->execute(SCI_GETFOLDEXPANDED, idx) == 0)
1202  				folding.push_back(idx);
1203  		if (changeDataLineCount)
1204  			_pEditView->execute(SCI_REPLACETARGET, static_cast<WPARAM>(-1), reinterpret_cast<LPARAM>(destination));
1205  		delete [] source;
1206  		delete [] destination;
1207  	}
1208  	_pEditView->execute(SCI_ENDUNDOACTION);
1209  	if (changeDataCount)
1210  	{
1211  		if (!isEntireDoc)
1212  			_pEditView->execute(SCI_SETSEL, _pEditView->execute(SCI_POSITIONFROMLINE, startLine), endLineCorrect != endLine ? _pEditView->execute(SCI_POSITIONFROMLINE, endLine) : _pEditView->execute(SCI_GETLINEENDPOSITION, endLine));
1213  		else
1214  			_pEditView->execute(SCI_GOTOPOS, _pEditView->execute(SCI_POSITIONFROMLINE, currentLine) + newCurrentPos);
1215  		for (size_t i = 0; i < folding.size(); ++i)
1216  			_pEditView->fold(folding[i], false);
1217  	}
1218  	else
1219  		restoreSelection();
1220  }
1221  void Notepad_plus::doTrim(trimOp whichPart)
1222  {
1223  	FindOption env;
1224  	if (whichPart == lineHeader)
1225  	{
1226  		env._str2Search = TEXT("^[\\t ]+");
1227  	}
1228  	else if (whichPart == lineTail)
1229  	{
1230  		env._str2Search = TEXT("[\\t ]+$");
1231  	}
1232  	else if (whichPart == lineBoth)
1233  	{
1234  		env._str2Search = TEXT("^[\\t ]+|[\\t ]+$");
1235  	}
1236  	else
1237  		return;
1238  	env._str4Replace = TEXT("");
1239  	env._searchType = FindRegex;
1240  	auto mainSelAnchor = _pEditView->execute(SCI_GETANCHOR);
1241  	auto mainSelCaretPos = _pEditView->execute(SCI_GETCURRENTPOS);
1242  	bool isEntireDoc = (mainSelAnchor == mainSelCaretPos);
1243  	auto docLength = _pEditView->execute(SCI_GETLENGTH);
1244  	if ((_pEditView->execute(SCI_GETSELECTIONMODE) == SC_SEL_RECTANGLE) || (_pEditView->execute(SCI_GETSELECTIONMODE) == SC_SEL_THIN))
1245  		return;
1246  	if (!isEntireDoc)
1247  	{
1248  		env._isInSelection = !isEntireDoc;
1249  		auto startPos = _pEditView->execute(SCI_GETSELECTIONSTART);
1250  		auto startLine = _pEditView->execute(SCI_LINEFROMPOSITION, startPos);
1251  		auto endPos = _pEditView->execute(SCI_GETSELECTIONEND);
1252  		auto endLine = _pEditView->execute(SCI_LINEFROMPOSITION, endPos);
1253  		if (startPos != _pEditView->execute(SCI_POSITIONFROMLINE, startLine))
1254  			startPos = _pEditView->execute(SCI_POSITIONFROMLINE, startLine);
1255  		if (endPos != _pEditView->execute(SCI_POSITIONFROMLINE, endLine) && endPos < _pEditView->execute(SCI_GETLINEENDPOSITION, endLine))
1256  			endPos = _pEditView->execute(SCI_GETLINEENDPOSITION, endLine);
1257  		_pEditView->execute(SCI_SETSEL, startPos, endPos);
1258  	}
1259  	_findReplaceDlg.processAll(ProcessReplaceAll, &env, isEntireDoc);
1260  	if (!isEntireDoc && (docLength == _pEditView->execute(SCI_GETLENGTH)))
1261  	{
1262  		_pEditView->execute(SCI_SETANCHOR, mainSelAnchor);
1263  		_pEditView->execute(SCI_SETCURRENTPOS, mainSelCaretPos);
1264  	}
1265  }
1266  void Notepad_plus::eol2ws()
1267  {
1268  	bool isEntireDoc = (_pEditView->execute(SCI_GETANCHOR) == _pEditView->execute(SCI_GETCURRENTPOS));
1269  	if ((_pEditView->execute(SCI_GETSELECTIONMODE) == SC_SEL_RECTANGLE) || (_pEditView->execute(SCI_GETSELECTIONMODE) == SC_SEL_THIN))
1270  		return;
1271  	_pEditView->execute(isEntireDoc ? SCI_TARGETWHOLEDOCUMENT: SCI_TARGETFROMSELECTION);
1272  	_pEditView->execute(SCI_LINESJOIN);
1273  }
1274  void Notepad_plus::removeEmptyLine(bool isBlankContained)
1275  {
1276  	FindOption env;
1277  	if (isBlankContained)
1278  	{
1279  		env._str2Search = TEXT("^(?>[\\t ]*[\\r\\n]+)+");
1280  	}
1281  	else
1282  	{
1283  		env._str2Search = TEXT("^[\\r\\n]+");
1284  	}
1285  	env._str4Replace = TEXT("");
1286  	env._searchType = FindRegex;
1287  	auto mainSelStart = _pEditView->execute(SCI_GETSELECTIONSTART);
1288  	auto mainSelEnd = _pEditView->execute(SCI_GETSELECTIONEND);
1289  	auto mainSelLength = mainSelEnd - mainSelStart;
1290  	bool isEntireDoc = mainSelLength == 0;
1291  	env._isInSelection = !isEntireDoc;
1292  	_findReplaceDlg.processAll(ProcessReplaceAll, &env, isEntireDoc);
1293  	auto lastLineDoc = _pEditView->execute(SCI_GETLINECOUNT) - 1;
1294  	auto str2Search = isBlankContained ? TEXT("[\\r\\n]+^[\\t ]*$|^[\\t ]+$") : TEXT("[\\r\\n]+^$");
1295  	auto startPos = _pEditView->execute(SCI_POSITIONFROMLINE, lastLineDoc - 1);
1296  	auto endPos = _pEditView->execute(SCI_GETLENGTH);
1297  	if (!isEntireDoc)
1298  	{
1299  		startPos = _pEditView->execute(SCI_GETSELECTIONSTART);
1300  		endPos = _pEditView->execute(SCI_GETSELECTIONEND);
1301  		auto endLine = _pEditView->execute(SCI_LINEFROMPOSITION, endPos);
1302  		if (endPos != (_pEditView->execute(SCI_POSITIONFROMLINE, endLine) + _pEditView->execute(SCI_LINELENGTH, endLine)))
1303  			return;
1304  	}
1305  	_pEditView->execute(SCI_SETSEARCHFLAGS, SCFIND_REGEXP|SCFIND_POSIX);
1306  	auto posFound = _pEditView->searchInTarget(str2Search, lstrlen(str2Search), startPos, endPos);
1307  	if (posFound >= 0)
1308  		_pEditView->replaceTarget(TEXT(""), posFound, endPos);
1309  }
1310  void Notepad_plus::removeDuplicateLines()
1311  {
1312  	intptr_t mainSelAnchor = _pEditView->execute(SCI_GETANCHOR);
1313  	intptr_t mainSelCaretPos = _pEditView->execute(SCI_GETCURRENTPOS);
1314  	bool isEntireDoc = (mainSelAnchor == mainSelCaretPos);
1315  	intptr_t startLine = 0;
1316  	intptr_t endLine = _pEditView->lastZeroBasedLineNumber();
1317  	if (!isEntireDoc)
1318  	{
1319  		intptr_t startPos = _pEditView->execute(SCI_GETSELECTIONSTART);
1320  		startLine = _pEditView->execute(SCI_LINEFROMPOSITION, startPos);
1321  		intptr_t endPos = _pEditView->execute(SCI_GETSELECTIONEND);
1322  		endLine = _pEditView->execute(SCI_LINEFROMPOSITION, endPos);
1323  		if (endPos == _pEditView->execute(SCI_POSITIONFROMLINE, endLine))
1324  			endLine -= 1;
1325  	}
1326  	if (startLine == endLine)
1327  		return;
1328  	intptr_t firstMatchLineNr = 0;
1329  	intptr_t lastMatchLineNr = 0;
1330  	generic_string firstMatchLineStr;
1331  	generic_string lastMatchLineStr;
1332  	for (intptr_t i = startLine; i <= endLine; i++)
1333  	{
1334  		if (firstMatchLineStr.empty())
1335  		{
1336  			firstMatchLineNr = lastMatchLineNr = i;
1337  			firstMatchLineStr = _pEditView->getLine(i);
1338  			continue;
1339  		}
1340  		else
1341  			lastMatchLineStr = _pEditView->getLine(i);
1342  		if (firstMatchLineStr == lastMatchLineStr)
1343  		{
1344  			lastMatchLineNr = i;
1345  			if (i != endLine)
1346  				continue;
1347  		}
1348  		if (firstMatchLineNr != lastMatchLineNr)
1349  		{
1350  			intptr_t startPos = _pEditView->execute(SCI_POSITIONFROMLINE, firstMatchLineNr + 1);
1351  			intptr_t endPos = _pEditView->execute(SCI_POSITIONFROMLINE, lastMatchLineNr) + _pEditView->execute(SCI_LINELENGTH, lastMatchLineNr);
1352  			_pEditView->execute(SCI_DELETERANGE, startPos, endPos - startPos);
1353  			intptr_t removedLines = lastMatchLineNr - firstMatchLineNr;
1354  			i -= removedLines;
1355  			endLine -= removedLines;
1356  		}
1357  		firstMatchLineStr = lastMatchLineStr;
1358  		firstMatchLineNr = lastMatchLineNr = i;
1359  	}
1360  	intptr_t endLineStartPos = _pEditView->execute(SCI_POSITIONFROMLINE, endLine);
1361  	intptr_t endLineEndPos = _pEditView->execute(SCI_GETLINEENDPOSITION, endLine);
1362  	intptr_t endLineLength = _pEditView->execute(SCI_LINELENGTH, endLine);
1363  	if (endLine == _pEditView->lastZeroBasedLineNumber() && endLineLength && ((endLineEndPos - endLineStartPos) == endLineLength))
1364  	{
1365  		intptr_t prevLine = endLine - 1;
1366  		intptr_t prevLineStartPos = _pEditView->execute(SCI_POSITIONFROMLINE, prevLine);
1367  		intptr_t prevLineEndPos = _pEditView->execute(SCI_GETLINEENDPOSITION, prevLine);
1368  		intptr_t prevLineLength = _pEditView->execute(SCI_LINELENGTH, prevLine);
1369  		const generic_string endLineStr = _pEditView->getLine(endLine);
1370  		const generic_string prevLineStr = _pEditView->getGenericTextAsString(prevLineStartPos, prevLineEndPos);
1371  		if (endLineStr == prevLineStr)
1372  			_pEditView->execute(SCI_DELETERANGE, prevLineStartPos, prevLineLength);
1373  	}
1374  }
1375  void Notepad_plus::getMatchedFileNames(const TCHAR *dir, size_t level, const vector<generic_string> & patterns, vector<generic_string> & fileNames, bool isRecursive, bool isInHiddenDir)
1376  {
1377  	level++;
1378  	generic_string dirFilter(dir);
1379  	dirFilter += TEXT("*.*");
1380  	WIN32_FIND_DATA foundData;
1381  	HANDLE hFile = ::FindFirstFile(dirFilter.c_str(), &foundData);
1382  	if (hFile != INVALID_HANDLE_VALUE)
1383  	{
1384  		if (foundData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
1385  		{
1386  			if (!isInHiddenDir && (foundData.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN))
1387  			{
1388  			}
1389  			else if (isRecursive)
1390  			{
1391  				if ((OrdinalIgnoreCaseCompareStrings(foundData.cFileName, TEXT(".")) != 0) && (OrdinalIgnoreCaseCompareStrings(foundData.cFileName, TEXT("..")) != 0) &&
1392  					!matchInExcludeDirList(foundData.cFileName, patterns, level))
1393  				{
1394  					generic_string pathDir(dir);
1395  					pathDir += foundData.cFileName;
1396  					pathDir += TEXT("\\");
1397  					getMatchedFileNames(pathDir.c_str(), level, patterns, fileNames, isRecursive, isInHiddenDir);
1398  				}
1399  			}
1400  		}
1401  		else
1402  		{
1403  			if (matchInList(foundData.cFileName, patterns))
1404  			{
1405  				generic_string pathFile(dir);
1406  				pathFile += foundData.cFileName;
1407  				fileNames.push_back(pathFile.c_str());
1408  			}
1409  		}
1410  	}
1411  	while (::FindNextFile(hFile, &foundData))
1412  	{
1413  		if (foundData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
1414  		{
1415  			if (!isInHiddenDir && (foundData.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN))
1416  			{
1417  			}
1418  			else if (isRecursive)
1419  			{
1420  				if ((OrdinalIgnoreCaseCompareStrings(foundData.cFileName, TEXT(".")) != 0) && (OrdinalIgnoreCaseCompareStrings(foundData.cFileName, TEXT("..")) != 0) &&
1421  					!matchInExcludeDirList(foundData.cFileName, patterns, level))
1422  				{
1423  					generic_string pathDir(dir);
1424  					pathDir += foundData.cFileName;
1425  					pathDir += TEXT("\\");
1426  					getMatchedFileNames(pathDir.c_str(), level, patterns, fileNames, isRecursive, isInHiddenDir);
1427  				}
1428  			}
1429  		}
1430  		else
1431  		{
1432  			if (matchInList(foundData.cFileName, patterns))
1433  			{
1434  				generic_string pathFile(dir);
1435  				pathFile += foundData.cFileName;
1436  				fileNames.push_back(pathFile.c_str());
1437  			}
1438  		}
1439  	}
1440  	::FindClose(hFile);
1441  }
1442  bool Notepad_plus::createFilelistForFiles(vector<generic_string> & fileNames)
1443  {
1444  	const TCHAR *dir2Search = _findReplaceDlg.getDir2Search();
1445  	if (!dir2Search[0] || !::PathFileExists(dir2Search))
1446  	{
1447  		return false;
1448  	}
1449  	vector<generic_string> patterns2Match;
1450  	_findReplaceDlg.getAndValidatePatterns(patterns2Match);
1451  	bool isRecursive = _findReplaceDlg.isRecursive();
1452  	bool isInHiddenDir = _findReplaceDlg.isInHiddenDir();
1453  	getMatchedFileNames(dir2Search, 0, patterns2Match, fileNames, isRecursive, isInHiddenDir);
1454  	return true;
1455  }
1456  bool Notepad_plus::createFilelistForProjects(vector<generic_string> & fileNames)
1457  {
1458  	vector<generic_string> patterns2Match;
1459  	_findReplaceDlg.getAndValidatePatterns(patterns2Match);
1460  	bool somethingIsSelected = false; 
1461  	if (_findReplaceDlg.isProjectPanel_1() && _pProjectPanel_1 && !_pProjectPanel_1->isClosed())
1462  	{
1463  		_pProjectPanel_1->enumWorkSpaceFiles (NULL, patterns2Match, fileNames);
1464  		somethingIsSelected = true;
1465  	}
1466  	if (_findReplaceDlg.isProjectPanel_2() && _pProjectPanel_2 && !_pProjectPanel_2->isClosed())
1467  	{
1468  		_pProjectPanel_2->enumWorkSpaceFiles (NULL, patterns2Match, fileNames);
1469  		somethingIsSelected = true;
1470  	}
1471  	if (_findReplaceDlg.isProjectPanel_3() && _pProjectPanel_3 && !_pProjectPanel_3->isClosed())
1472  	{
1473  		_pProjectPanel_3->enumWorkSpaceFiles (NULL, patterns2Match, fileNames);
1474  		somethingIsSelected = true;
1475  	}
1476  	return somethingIsSelected;
1477  }
1478  std::mutex replaceInFiles_mutex;
1479  bool Notepad_plus::replaceInFiles()
1480  {
1481  	std::lock_guard<std::mutex> lock(replaceInFiles_mutex);
1482  	std::vector<generic_string> fileNames;
1483  	if (!createFilelistForFiles(fileNames))
1484  		return false;
1485  	return replaceInFilelist(fileNames);
1486  }
1487  bool Notepad_plus::replaceInProjects()
1488  {
1489  	std::lock_guard<std::mutex> lock(replaceInFiles_mutex);
1490  	std::vector<generic_string> fileNames;
1491  	if (!createFilelistForProjects(fileNames))
1492  		return false;
1493  	return replaceInFilelist(fileNames);
1494  }
1495  bool Notepad_plus::replaceInFilelist(std::vector<generic_string> & fileNames)
1496  {
1497  	int nbTotal = 0;
1498  	ScintillaEditView *pOldView = _pEditView;
1499  	_pEditView = &_invisibleEditView;
1500  	Document oldDoc = _invisibleEditView.execute(SCI_GETDOCPOINTER);
1501  	Buffer * oldBuf = _invisibleEditView.getCurrentBuffer();	
1502  	Progress progress(_pPublicInterface->getHinst());
1503  	size_t filesCount = fileNames.size();
1504  	size_t filesPerPercent = 1;
1505  	if (filesCount > 1)
1506  	{
1507  		if (filesCount >= 200)
1508  			filesPerPercent = filesCount / 100;
1509  		generic_string msg = _nativeLangSpeaker.getLocalizedStrFromID(
1510  			"replace-in-files-progress-title", TEXT("Replace In Files progress..."));
1511  		progress.open(_findReplaceDlg.getHSelf(), msg.c_str());
1512  	}
1513  	for (size_t i = 0, updateOnCount = filesPerPercent; i < filesCount; ++i)
1514  	{
1515  		if (progress.isCancelled()) break;
1516  		bool closeBuf = false;
1517  		BufferID id = MainFileManager.getBufferFromName(fileNames.at(i).c_str());
1518  		if (id == BUFFER_INVALID)
1519  		{
1520  			id = MainFileManager.loadFile(fileNames.at(i).c_str());
1521  			closeBuf = true;
1522  		}
1523  		if (id != BUFFER_INVALID)
1524  		{
1525  			Buffer * pBuf = MainFileManager.getBufferByID(id);
1526  			_invisibleEditView.execute(SCI_SETDOCPOINTER, 0, pBuf->getDocument());
1527  			setCodePageForInvisibleView(pBuf);
1528  			_invisibleEditView.setCurrentBuffer(pBuf);
1529  			FindersInfo findersInfo;
1530  			findersInfo._pFileName = fileNames.at(i).c_str();
1531  			int nbReplaced = _findReplaceDlg.processAll(ProcessReplaceAll, FindReplaceDlg::_env, true, &findersInfo);
1532  			nbTotal += nbReplaced;
1533  			if (nbReplaced)
1534  			{
1535  				MainFileManager.saveBuffer(id, pBuf->getFullPathName());
1536  			}
1537  			if (closeBuf)
1538  				MainFileManager.closeBuffer(id, _pEditView);
1539  		}
1540  		if (i == updateOnCount)
1541  		{
1542  			updateOnCount += filesPerPercent;
1543  			progress.setPercent(int32_t((i * 100) / filesCount), fileNames.at(i).c_str(), nbTotal);
1544  		}
1545  		else
1546  		{
1547  			progress.setInfo(fileNames.at(i).c_str(), nbTotal);
1548  		}
1549  	}
1550  	progress.close();
1551  	_invisibleEditView.execute(SCI_SETDOCPOINTER, 0, oldDoc);
1552  	_invisibleEditView.setCurrentBuffer(oldBuf);
1553  	_pEditView = pOldView;
1554  	generic_string result;
1555  	if (nbTotal == 1)
1556  	{
1557  		result = _nativeLangSpeaker.getLocalizedStrFromID("find-status-replaceinfiles-1-replaced", TEXT("Replace in Files: 1 occurrence was replaced."));
1558  	}
1559  	else
1560  	{
1561  		result = _nativeLangSpeaker.getLocalizedStrFromID("find-status-replaceinfiles-nb-replaced", TEXT("Replace in Files: $INT_REPLACE$ occurrences were replaced."));
1562  		result = stringReplace(result, TEXT("$INT_REPLACE$"), std::to_wstring(nbTotal));
1563  	}
1564  	_findReplaceDlg.setStatusbarMessage(result, FSMessage);
1565  	return true;
1566  }
1567  bool Notepad_plus::findInFinderFiles(FindersInfo *findInFolderInfo)
1568  {
1569  	int nbTotal = 0;
1570  	ScintillaEditView *pOldView = _pEditView;
1571  	_pEditView = &_invisibleEditView;
1572  	Document oldDoc = _invisibleEditView.execute(SCI_GETDOCPOINTER);
1573  	vector<generic_string> fileNames = findInFolderInfo->_pSourceFinder->getResultFilePaths();
1574  	findInFolderInfo->_pDestFinder->beginNewFilesSearch();
1575  	findInFolderInfo->_pDestFinder->addSearchLine(findInFolderInfo->_findOption._str2Search.c_str());
1576  	Progress progress(_pPublicInterface->getHinst());
1577  	size_t filesCount = fileNames.size();
1578  	size_t filesPerPercent = 1;
1579  	if (filesCount > 1)
1580  	{
1581  		if (filesCount >= 200)
1582  			filesPerPercent = filesCount / 100;
1583  		generic_string msg = _nativeLangSpeaker.getLocalizedStrFromID(
1584  			"find-in-files-progress-title", TEXT("Find In Files progress..."));
1585  		progress.open(_findReplaceDlg.getHSelf(), msg.c_str());
1586  	}
1587  	for (size_t i = 0, updateOnCount = filesPerPercent; i < filesCount; ++i)
1588  	{
1589  		if (progress.isCancelled()) break;
1590  		bool closeBuf = false;
1591  		BufferID id = MainFileManager.getBufferFromName(fileNames.at(i).c_str());
1592  		if (id == BUFFER_INVALID)
1593  		{
1594  			id = MainFileManager.loadFile(fileNames.at(i).c_str());
1595  			closeBuf = true;
1596  		}
1597  		if (id != BUFFER_INVALID)
1598  		{
1599  			Buffer * pBuf = MainFileManager.getBufferByID(id);
1600  			_invisibleEditView.execute(SCI_SETDOCPOINTER, 0, pBuf->getDocument());
1601  			setCodePageForInvisibleView(pBuf);
1602  			findInFolderInfo->_pFileName = fileNames.at(i).c_str();
1603  			nbTotal += _findReplaceDlg.processAll(ProcessFindInFinder, &(findInFolderInfo->_findOption), true, findInFolderInfo);
1604  			if (closeBuf)
1605  				MainFileManager.closeBuffer(id, _pEditView);
1606  		}
1607  		if (i == updateOnCount)
1608  		{
1609  			updateOnCount += filesPerPercent;
1610  			progress.setPercent(int32_t((i * 100) / filesCount), fileNames.at(i).c_str(), nbTotal);
1611  		}
1612  		else
1613  		{
1614  			progress.setInfo(fileNames.at(i).c_str(), nbTotal);
1615  		}
1616  	}
1617  	progress.close();
1618  	const bool searchedInSelection = false;
1619  	findInFolderInfo->_pDestFinder->finishFilesSearch(nbTotal, int(filesCount), findInFolderInfo->_findOption._isMatchLineNumber, !searchedInSelection);
1620  	_invisibleEditView.execute(SCI_SETDOCPOINTER, 0, oldDoc);
1621  	_pEditView = pOldView;
1622  	return true;
1623  }
1624  bool Notepad_plus::findInFiles()
1625  {
1626  	std::vector<generic_string> fileNames;
1627  	if (! createFilelistForFiles(fileNames))
1628  		return false;
1629  	return findInFilelist(fileNames);
1630  }
1631  bool Notepad_plus::findInProjects()
1632  {
1633  	vector<generic_string> fileNames;
1634  	if (! createFilelistForProjects(fileNames))
1635  		return false;
1636  	return findInFilelist(fileNames);
1637  }
1638  bool Notepad_plus::findInFilelist(std::vector<generic_string> & fileNames)
1639  {
1640  	int nbTotal = 0;
1641  	ScintillaEditView *pOldView = _pEditView;
1642  	_pEditView = &_invisibleEditView;
1643  	Document oldDoc = _invisibleEditView.execute(SCI_GETDOCPOINTER);
1644  	_findReplaceDlg.beginNewFilesSearch();
1645  	Progress progress(_pPublicInterface->getHinst());
1646  	size_t filesCount = fileNames.size();
1647  	size_t filesPerPercent = 1;
1648  	if (filesCount > 1)
1649  	{
1650  		if (filesCount >= 200)
1651  			filesPerPercent = filesCount / 100;
1652  		generic_string msg = _nativeLangSpeaker.getLocalizedStrFromID(
1653  			"find-in-files-progress-title", TEXT("Find In Files progress..."));
1654  		progress.open(_findReplaceDlg.getHSelf(), msg.c_str());
1655  	}
1656  	const bool isEntireDoc = true;
1657  	for (size_t i = 0, updateOnCount = filesPerPercent; i < filesCount; ++i)
1658  	{
1659  		if (progress.isCancelled()) break;
1660  		bool closeBuf = false;
1661  		BufferID id = MainFileManager.getBufferFromName(fileNames.at(i).c_str());
1662  		if (id == BUFFER_INVALID)
1663  		{
1664  			id = MainFileManager.loadFile(fileNames.at(i).c_str());
1665  			closeBuf = true;
1666  		}
1667  		if (id != BUFFER_INVALID)
1668  		{
1669  			Buffer * pBuf = MainFileManager.getBufferByID(id);
1670  			_invisibleEditView.execute(SCI_SETDOCPOINTER, 0, pBuf->getDocument());
1671  			setCodePageForInvisibleView(pBuf);
1672  			FindersInfo findersInfo;
1673  			findersInfo._pFileName = fileNames.at(i).c_str();
1674  			nbTotal += _findReplaceDlg.processAll(ProcessFindAll, FindReplaceDlg::_env, isEntireDoc, &findersInfo);
1675  			if (closeBuf)
1676  				MainFileManager.closeBuffer(id, _pEditView);
1677  		}
1678  		if (i == updateOnCount)
1679  		{
1680  			updateOnCount += filesPerPercent;
1681  			progress.setPercent(int32_t((i * 100) / filesCount), fileNames.at(i).c_str(), nbTotal);
1682  		}
1683  		else
1684  		{
1685  			progress.setInfo(fileNames.at(i).c_str(), nbTotal);
1686  		}
1687  	}
1688  	progress.close();
1689  	_findReplaceDlg.finishFilesSearch(nbTotal, int(filesCount), isEntireDoc);
1690  	_invisibleEditView.execute(SCI_SETDOCPOINTER, 0, oldDoc);
1691  	_pEditView = pOldView;
1692  	_findReplaceDlg.putFindResult(nbTotal);
1693  	if (nbTotal != 0)
1694  	{
1695  		NppParameters& nppParam = NppParameters::getInstance();
1696  		NppGUI& nppGui = nppParam.getNppGUI();
1697  		if (!nppGui._findDlgAlwaysVisible)
1698  		{
1699  			_findReplaceDlg.display(false);
1700  		}
1701  	}
1702  	return true;
1703  }
1704  bool Notepad_plus::findInOpenedFiles()
1705  {
1706  	int nbTotal = 0;
1707  	ScintillaEditView *pOldView = _pEditView;
1708  	_pEditView = &_invisibleEditView;
1709  	Document oldDoc = _invisibleEditView.execute(SCI_GETDOCPOINTER);
1710  	Buffer * pBuf = NULL;
1711  	const bool isEntireDoc = true;
1712  	_findReplaceDlg.beginNewFilesSearch();
1713  	if (_mainWindowStatus & WindowMainActive)
1714  	{
1715  		for (size_t i = 0, len = _mainDocTab.nbItem(); i < len ; ++i)
1716  		{
1717  			pBuf = MainFileManager.getBufferByID(_mainDocTab.getBufferByIndex(i));
1718  			_invisibleEditView.execute(SCI_SETDOCPOINTER, 0, pBuf->getDocument());
1719  			setCodePageForInvisibleView(pBuf);
1720  			FindersInfo findersInfo;
1721  			findersInfo._pFileName = pBuf->getFullPathName();
1722  			nbTotal += _findReplaceDlg.processAll(ProcessFindAll, FindReplaceDlg::_env, isEntireDoc, &findersInfo);
1723  		}
1724  	}
1725  	size_t nbUniqueBuffers = _mainDocTab.nbItem();
1726  	if (_mainWindowStatus & WindowSubActive)
1727  	{
1728  		for (size_t i = 0, len2 = _subDocTab.nbItem(); i < len2 ; ++i)
1729  		{
1730  			pBuf = MainFileManager.getBufferByID(_subDocTab.getBufferByIndex(i));
1731  			if (_mainDocTab.getIndexByBuffer(pBuf) != -1)
1732  			{
1733  				continue;  
1734  			}
1735  			_invisibleEditView.execute(SCI_SETDOCPOINTER, 0, pBuf->getDocument());
1736  			setCodePageForInvisibleView(pBuf);
1737  			FindersInfo findersInfo;
1738  			findersInfo._pFileName = pBuf->getFullPathName();
1739  			nbTotal += _findReplaceDlg.processAll(ProcessFindAll, FindReplaceDlg::_env, isEntireDoc, &findersInfo);
1740  			++nbUniqueBuffers;
1741  		}
1742  	}
1743  	_findReplaceDlg.finishFilesSearch(nbTotal, int(nbUniqueBuffers), isEntireDoc);
1744  	_invisibleEditView.execute(SCI_SETDOCPOINTER, 0, oldDoc);
1745  	_pEditView = pOldView;
1746  	_findReplaceDlg.putFindResult(nbTotal);
1747  	if (nbTotal != 0)
1748  	{
1749  		NppParameters& nppParam = NppParameters::getInstance();
1750  		NppGUI& nppGui = nppParam.getNppGUI();
1751  		if (!nppGui._findDlgAlwaysVisible)
1752  		{
1753  			_findReplaceDlg.display(false);
1754  		}
1755  	}
1756  	return true;
1757  }
1758  bool Notepad_plus::findInCurrentFile(bool isEntireDoc)
1759  {
1760  	int nbTotal = 0;
1761  	Buffer * pBuf = _pEditView->getCurrentBuffer();
1762  	Sci_CharacterRangeFull mainSelection = _pEditView->getSelection();  
1763  	ScintillaEditView *pOldView = _pEditView;
1764  	_pEditView = &_invisibleEditView;
1765  	Document oldDoc = _invisibleEditView.execute(SCI_GETDOCPOINTER);
1766  	_findReplaceDlg.beginNewFilesSearch();
1767  	_invisibleEditView.execute(SCI_SETDOCPOINTER, 0, pBuf->getDocument());
1768  	setCodePageForInvisibleView(pBuf);
1769  	if (!isEntireDoc)
1770  	{
1771  		auto docLength = _invisibleEditView.execute(SCI_GETLENGTH);
1772  		if ((mainSelection.cpMin > 0) || (mainSelection.cpMax < docLength))
1773  		{
1774  			_invisibleEditView.execute(SCI_SETSELECTIONSTART, mainSelection.cpMin);
1775  			_invisibleEditView.execute(SCI_SETSELECTIONEND, mainSelection.cpMax);
1776  		}
1777  		else
1778  		{
1779  			isEntireDoc = true;
1780  		}
1781  	}
1782  	FindersInfo findersInfo;
1783  	findersInfo._pFileName = pBuf->getFullPathName();
1784  	nbTotal += _findReplaceDlg.processAll(ProcessFindAll, FindReplaceDlg::_env, isEntireDoc, &findersInfo);
1785  	_findReplaceDlg.finishFilesSearch(nbTotal, 1, isEntireDoc);
1786  	_invisibleEditView.execute(SCI_SETDOCPOINTER, 0, oldDoc);
1787  	_pEditView = pOldView;
1788  	_findReplaceDlg.putFindResult(nbTotal);
1789  	if (nbTotal != 0)
1790  	{
1791  		NppParameters& nppParam = NppParameters::getInstance();
1792  		NppGUI& nppGui = nppParam.getNppGUI();
1793  		if (!nppGui._findDlgAlwaysVisible)
1794  		{
1795  			_findReplaceDlg.display(false);
1796  		}
1797  	}
1798  	return true;
1799  }
1800  void Notepad_plus::filePrint(bool showDialog)
1801  {
1802  	Printer printer;
1803  	intptr_t startPos = _pEditView->execute(SCI_GETSELECTIONSTART);
1804  	intptr_t endPos = _pEditView->execute(SCI_GETSELECTIONEND);
1805  	printer.init(_pPublicInterface->getHinst(), _pPublicInterface->getHSelf(), _pEditView, showDialog, startPos, endPos, _nativeLangSpeaker.isRTL());
1806  	printer.doPrint();
1807  }
1808  int Notepad_plus::doSaveOrNot(const TCHAR* fn, bool isMulti)
1809  {
1810  	if ((NppParameters::getInstance()).isEndSessionCritical())
1811  		return IDCANCEL; 
1812  	if (!::IsWindowVisible(_pPublicInterface->getHSelf()))
1813  	{
1814  		::ShowWindow(_pPublicInterface->getHSelf(), SW_SHOW);
1815  		::SendMessage(_pPublicInterface->getHSelf(), WM_SIZE, 0, 0);
1816  	}
1817  	if (!isMulti)
1818  	{
1819  		generic_string title, msg;
1820  		if (!_nativeLangSpeaker.getDoSaveOrNotStrings(title, msg))
1821  		{
1822  			title = TEXT("Save");
1823  			msg = TEXT("Save file \"$STR_REPLACE$\" ?");
1824  		}
1825  		msg = stringReplace(msg, TEXT("$STR_REPLACE$"), fn);
1826  		return ::MessageBox(_pPublicInterface->getHSelf(), msg.c_str(), title.c_str(), MB_YESNOCANCEL | MB_ICONQUESTION | MB_APPLMODAL);
1827  	}
1828  	DoSaveOrNotBox doSaveOrNotBox;
1829  	doSaveOrNotBox.init(_pPublicInterface->getHinst(), _pPublicInterface->getHSelf(), fn, isMulti);
1830  	doSaveOrNotBox.doDialog(_nativeLangSpeaker.isRTL());
1831  	int buttonID = doSaveOrNotBox.getClickedButtonId();
1832  	doSaveOrNotBox.destroy();
1833  	return buttonID;
1834  }
1835  int Notepad_plus::doSaveAll()
1836  {
1837  	if (!::IsWindowVisible(_pPublicInterface->getHSelf()))
1838  	{
1839  		::ShowWindow(_pPublicInterface->getHSelf(), SW_SHOW);
1840  		::SendMessage(_pPublicInterface->getHSelf(), WM_SIZE, 0, 0);
1841  	}
1842  	DoSaveAllBox doSaveAllBox;
1843  	doSaveAllBox.init(_pPublicInterface->getHinst(), _pPublicInterface->getHSelf());
1844  	doSaveAllBox.doDialog(_nativeLangSpeaker.isRTL());
1845  	int buttonID = doSaveAllBox.getClickedButtonId();
1846  	doSaveAllBox.destroy();
1847  	return buttonID;
1848  }
1849  int Notepad_plus::doReloadOrNot(const TCHAR *fn, bool dirty)
1850  {
1851  	if (dirty)
1852  		return _nativeLangSpeaker.messageBox("DoReloadOrNotAndLooseChange",
1853  			_pPublicInterface->getHSelf(),
1854  			TEXT("\"$STR_REPLACE$\"\r\rThis file has been modified by another program.\rDo you want to reload it and lose the changes made in Notepad++?"),
1855  			TEXT("Reload"),
1856  			MB_YESNO | MB_APPLMODAL | MB_ICONEXCLAMATION,
1857  			0, 
1858  			fn);
1859  	else
1860  		return _nativeLangSpeaker.messageBox("DoReloadOrNot",
1861  			_pPublicInterface->getHSelf(),
1862  			TEXT("\"$STR_REPLACE$\"\r\rThis file has been modified by another program.\rDo you want to reload it?"),
1863  			TEXT("Reload"),
1864  			MB_YESNO | MB_APPLMODAL | MB_ICONQUESTION,
1865  			0, 
1866  			fn);
1867  }
1868  int Notepad_plus::doCloseOrNot(const TCHAR *fn)
1869  {
1870  	return _nativeLangSpeaker.messageBox("DoCloseOrNot",
1871  		_pPublicInterface->getHSelf(),
1872  		TEXT("The file \"$STR_REPLACE$\" doesn't exist anymore.\rKeep this file in editor?"),
1873  		TEXT("Keep non existing file"),
1874  		MB_YESNO | MB_ICONQUESTION | MB_APPLMODAL,
1875  		0, 
1876  		fn);
1877  }
1878  int Notepad_plus::doDeleteOrNot(const TCHAR *fn)
1879  {
1880  	return _nativeLangSpeaker.messageBox("DoDeleteOrNot",
1881  		_pPublicInterface->getHSelf(),
1882  		TEXT("The file \"$STR_REPLACE$\"\rwill be moved to your Recycle Bin and this document will be closed.\rContinue?"),
1883  		TEXT("Delete file"),
1884  		MB_OKCANCEL | MB_ICONQUESTION | MB_APPLMODAL,
1885  		0, 
1886  		fn);
1887  }
1888  void Notepad_plus::enableMenu(int cmdID, bool doEnable) const
1889  {
1890  	int flag = doEnable?MF_ENABLED | MF_BYCOMMAND:MF_DISABLED | MF_GRAYED | MF_BYCOMMAND;
1891  	::EnableMenuItem(_mainMenuHandle, cmdID, flag);
1892  }
1893  void Notepad_plus::enableCommand(int cmdID, bool doEnable, int which) const
1894  {
1895  	if (which & MENU)
1896  	{
1897  		enableMenu(cmdID, doEnable);
1898  	}
1899  	if (which & TOOLBAR)
1900  	{
1901  		_toolBar.enable(cmdID, doEnable);
1902  	}
1903  }
1904  void Notepad_plus::checkClipboard()
1905  {
1906  	bool hasSelection = (_pEditView->execute(SCI_GETSELECTIONSTART) != _pEditView->execute(SCI_GETSELECTIONEND));
1907  	bool canPaste = (_pEditView->execute(SCI_CANPASTE) != 0);
1908  	enableCommand(IDM_EDIT_CUT, hasSelection, MENU | TOOLBAR);
1909  	enableCommand(IDM_EDIT_COPY, hasSelection, MENU | TOOLBAR);
1910  	enableCommand(IDM_EDIT_PASTE, canPaste, MENU | TOOLBAR);
1911  	enableCommand(IDM_EDIT_DELETE, hasSelection, MENU | TOOLBAR);
1912  	enableCommand(IDM_EDIT_UPPERCASE, hasSelection, MENU);
1913  	enableCommand(IDM_EDIT_LOWERCASE, hasSelection, MENU);
1914  	enableCommand(IDM_EDIT_PROPERCASE_FORCE, hasSelection, MENU);
1915  	enableCommand(IDM_EDIT_PROPERCASE_BLEND, hasSelection, MENU);
1916  	enableCommand(IDM_EDIT_SENTENCECASE_FORCE, hasSelection, MENU);
1917  	enableCommand(IDM_EDIT_SENTENCECASE_BLEND, hasSelection, MENU);
1918  	enableCommand(IDM_EDIT_INVERTCASE, hasSelection, MENU);
1919  	enableCommand(IDM_EDIT_RANDOMCASE, hasSelection, MENU);
1920  }
1921  void Notepad_plus::checkDocState()
1922  {
1923  	Buffer * curBuf = _pEditView->getCurrentBuffer();
1924  	bool isCurrentDirty = curBuf->isDirty();
1925  	bool isSeveralDirty = isCurrentDirty;
1926  	bool isFileExisting = PathFileExists(curBuf->getFullPathName()) != FALSE;
1927  	if (!isCurrentDirty)
1928  	{
1929  		for (size_t i = 0; i < MainFileManager.getNbBuffers(); ++i)
1930  		{
1931  			if (MainFileManager.getBufferByIndex(i)->isDirty())
1932  			{
1933  				isSeveralDirty = true;
1934  				break;
1935  			}
1936  		}
1937  	}
1938  	bool isCurrentUntitled = curBuf->isUntitled();
1939  	enableCommand(IDM_FILE_SAVE, isCurrentDirty, MENU | TOOLBAR);
1940  	enableCommand(IDM_FILE_SAVEALL, isSeveralDirty, MENU | TOOLBAR);
1941  	enableCommand(IDM_VIEW_GOTO_NEW_INSTANCE, !(isCurrentDirty || isCurrentUntitled), MENU);
1942  	enableCommand(IDM_VIEW_LOAD_IN_NEW_INSTANCE, !(isCurrentDirty || isCurrentUntitled), MENU);
1943  	bool isSysReadOnly = curBuf->getFileReadOnly();
1944  	enableCommand(IDM_EDIT_CLEARREADONLY, isSysReadOnly, MENU);
1945  	bool doEnable = !(curBuf->isMonitoringOn() || isSysReadOnly);
1946  	enableCommand(IDM_EDIT_SETREADONLY, doEnable, MENU);
1947  	bool isUserReadOnly = curBuf->getUserReadOnly();
1948  	::CheckMenuItem(_mainMenuHandle, IDM_EDIT_SETREADONLY, MF_BYCOMMAND | (isUserReadOnly ? MF_CHECKED : MF_UNCHECKED));
1949  	enableCommand(IDM_FILE_DELETE, isFileExisting, MENU);
1950  	enableCommand(IDM_FILE_OPEN_CMD, isFileExisting, MENU);
1951  	enableCommand(IDM_FILE_OPEN_FOLDER, isFileExisting, MENU);
1952  	enableCommand(IDM_FILE_RELOAD, isFileExisting, MENU);
1953  	enableCommand(IDM_FILE_OPEN_DEFAULT_VIEWER, isAssoCommandExisting(curBuf->getFullPathName()), MENU);
1954  	enableCommand(IDM_VIEW_IN_FIREFOX, isFileExisting, MENU);
1955  	enableCommand(IDM_VIEW_IN_CHROME, isFileExisting, MENU);
1956  	enableCommand(IDM_VIEW_IN_IE, isFileExisting, MENU);
1957  	enableCommand(IDM_VIEW_IN_EDGE, isFileExisting, MENU);
1958  	enableConvertMenuItems(curBuf->getEolFormat());
1959  	checkUnicodeMenuItems();
1960  	checkLangsMenu(-1);
1961  	if (_pAnsiCharPanel)
1962  		_pAnsiCharPanel->switchEncoding();
1963  	enableCommand(IDM_VIEW_MONITORING, !curBuf->isUntitled(), MENU | TOOLBAR);
1964  	checkMenuItem(IDM_VIEW_MONITORING, curBuf->isMonitoringOn());
1965  	_toolBar.setCheck(IDM_VIEW_MONITORING, curBuf->isMonitoringOn());
1966  }
1967  void Notepad_plus::checkUndoState()
1968  {
1969  	enableCommand(IDM_EDIT_UNDO, _pEditView->execute(SCI_CANUNDO) != 0, MENU | TOOLBAR);
1970  	enableCommand(IDM_EDIT_REDO, _pEditView->execute(SCI_CANREDO) != 0, MENU | TOOLBAR);
1971  }
1972  void Notepad_plus::checkMacroState()
1973  {
1974  	enableCommand(IDM_MACRO_STARTRECORDINGMACRO, !_recordingMacro, MENU | TOOLBAR);
1975  	enableCommand(IDM_MACRO_STOPRECORDINGMACRO, _recordingMacro, MENU | TOOLBAR);
1976  	enableCommand(IDM_MACRO_PLAYBACKRECORDEDMACRO, !_macro.empty() && !_recordingMacro, MENU | TOOLBAR);
1977  	enableCommand(IDM_MACRO_SAVECURRENTMACRO, !_macro.empty() && !_recordingMacro && !_recordingSaved, MENU | TOOLBAR);
1978  	enableCommand(IDM_MACRO_RUNMULTIMACRODLG, (!_macro.empty() && !_recordingMacro) || !((NppParameters::getInstance()).getMacroList()).empty(), MENU | TOOLBAR);
1979  }
1980  void Notepad_plus::checkSyncState()
1981  {
1982  	bool canDoSync = viewVisible(MAIN_VIEW) && viewVisible(SUB_VIEW);
1983  	if (!canDoSync)
1984  	{
1985  		_syncInfo._isSynScollV = false;
1986  		_syncInfo._isSynScollH = false;
1987  		checkMenuItem(IDM_VIEW_SYNSCROLLV, false);
1988  		checkMenuItem(IDM_VIEW_SYNSCROLLH, false);
1989  		_toolBar.setCheck(IDM_VIEW_SYNSCROLLV, false);
1990  		_toolBar.setCheck(IDM_VIEW_SYNSCROLLH, false);
1991  	}
1992  	enableCommand(IDM_VIEW_SYNSCROLLV, canDoSync, MENU | TOOLBAR);
1993  	enableCommand(IDM_VIEW_SYNSCROLLH, canDoSync, MENU | TOOLBAR);
1994  }
1995  void Notepad_plus::setupColorSampleBitmapsOnMainMenuItems()
1996  {
1997  	struct
1998  	{
1999  		int firstOfThisColorMenuId;
2000  		int styleIndic;
2001  		std::vector<int> sameColorMenuIds;
2002  	}
2003  	bitmapOnStyleMenuItemsInfo[] =
2004  	{
2005  		{ IDM_SEARCH_GONEXTMARKER5, SCE_UNIVERSAL_FOUND_STYLE_EXT5, { IDM_SEARCH_MARKALLEXT5, IDM_SEARCH_MARKONEEXT5, IDM_SEARCH_UNMARKALLEXT5, IDM_SEARCH_GOPREVMARKER5, IDM_SEARCH_STYLE5TOCLIP } },
2006  		{ IDM_SEARCH_GONEXTMARKER4, SCE_UNIVERSAL_FOUND_STYLE_EXT4, { IDM_SEARCH_MARKALLEXT4, IDM_SEARCH_MARKONEEXT4, IDM_SEARCH_UNMARKALLEXT4, IDM_SEARCH_GOPREVMARKER4, IDM_SEARCH_STYLE4TOCLIP } },
2007  		{ IDM_SEARCH_GONEXTMARKER3, SCE_UNIVERSAL_FOUND_STYLE_EXT3, { IDM_SEARCH_MARKALLEXT3, IDM_SEARCH_MARKONEEXT3, IDM_SEARCH_UNMARKALLEXT3, IDM_SEARCH_GOPREVMARKER3, IDM_SEARCH_STYLE3TOCLIP } },
2008  		{ IDM_SEARCH_GONEXTMARKER2, SCE_UNIVERSAL_FOUND_STYLE_EXT2, { IDM_SEARCH_MARKALLEXT2, IDM_SEARCH_MARKONEEXT2, IDM_SEARCH_UNMARKALLEXT2, IDM_SEARCH_GOPREVMARKER2, IDM_SEARCH_STYLE2TOCLIP } },
2009  		{ IDM_SEARCH_GONEXTMARKER1, SCE_UNIVERSAL_FOUND_STYLE_EXT1, { IDM_SEARCH_MARKALLEXT1, IDM_SEARCH_MARKONEEXT1, IDM_SEARCH_UNMARKALLEXT1, IDM_SEARCH_GOPREVMARKER1, IDM_SEARCH_STYLE1TOCLIP } },
2010  		{ IDM_SEARCH_GONEXTMARKER_DEF, SCE_UNIVERSAL_FOUND_STYLE, { IDM_SEARCH_GOPREVMARKER_DEF, IDM_SEARCH_MARKEDTOCLIP } }
2011  	};
2012  	for (size_t j = 0; j < sizeof(bitmapOnStyleMenuItemsInfo) / sizeof(bitmapOnStyleMenuItemsInfo[0]); ++j)
2013  	{
2014  		const Style * pStyle = NppParameters::getInstance().getMiscStylerArray().findByID(bitmapOnStyleMenuItemsInfo[j].styleIndic);
2015  		if (pStyle)
2016  		{
2017  			HBITMAP hNewBitmap = generateSolidColourMenuItemIcon(pStyle->_bgColor);
2018  			SetMenuItemBitmaps(_mainMenuHandle, bitmapOnStyleMenuItemsInfo[j].firstOfThisColorMenuId, MF_BYCOMMAND, hNewBitmap, hNewBitmap);
2019  			for (int relatedMenuId : bitmapOnStyleMenuItemsInfo[j].sameColorMenuIds)
2020  			{
2021  				SetMenuItemBitmaps(_mainMenuHandle, relatedMenuId, MF_BYCOMMAND, hNewBitmap, NULL);
2022  			}
2023  		}
2024  	}
2025  	for (int i = 0; i < 5; ++i)
2026  	{
2027  		COLORREF colour = NppDarkMode::getIndividualTabColour(i, NppDarkMode::isDarkMenuEnabled(), true);
2028  		HBITMAP hBitmap = generateSolidColourMenuItemIcon(colour);
2029  		SetMenuItemBitmaps(_mainMenuHandle, IDM_VIEW_TAB_COLOUR_1 + i, MF_BYCOMMAND, hBitmap, hBitmap);
2030  	}
2031  }
2032  bool doCheck(HMENU mainHandle, int id)
2033  {
2034  	MENUITEMINFO mii{};
2035  	mii.cbSize = sizeof(MENUITEMINFO);
2036  	mii.fMask = MIIM_SUBMENU | MIIM_FTYPE | MIIM_ID | MIIM_STATE;
2037  	bool found = false;
2038  	int count = ::GetMenuItemCount(mainHandle);
2039  	for (int i = 0; i < count; i++)
2040  	{
2041  		::GetMenuItemInfo(mainHandle, i, MF_BYPOSITION, &mii);
2042  		if (mii.fType == MFT_RADIOCHECK || mii.fType == MFT_STRING)
2043  		{
2044  			bool checked = mii.hSubMenu ? doCheck(mii.hSubMenu, id) : (mii.wID == (unsigned int)id);
2045  			if (checked)
2046  			{
2047  				::CheckMenuRadioItem(mainHandle, 0, count, i, MF_BYPOSITION);
2048  				found = true;
2049  			}
2050  			else
2051  			{
2052  				mii.fState = 0;
2053  				::SetMenuItemInfo(mainHandle, i, MF_BYPOSITION, &mii);
2054  			}
2055  		}
2056  	}
2057  	return found;
2058  }
2059  void Notepad_plus::checkLangsMenu(int id) const
2060  {
2061  	Buffer * curBuf = _pEditView->getCurrentBuffer();
2062  	if (id == -1)
2063  	{
2064  		id = (NppParameters::getInstance()).langTypeToCommandID(curBuf->getLangType());
2065  		if (id == IDM_LANG_USER)
2066  		{
2067  			if (curBuf->isUserDefineLangExt())
2068  			{
2069  				const TCHAR *userLangName = curBuf->getUserDefineLangName();
2070  				TCHAR menuLangName[menuItemStrLenMax];
2071  				for (int i = IDM_LANG_USER + 1 ; i <= IDM_LANG_USER_LIMIT ; ++i)
2072  				{
2073  					if (::GetMenuString(_mainMenuHandle, i, menuLangName, menuItemStrLenMax, MF_BYCOMMAND))
2074  					{
2075  						if (!lstrcmp(userLangName, menuLangName))
2076  						{
2077  							HMENU _langMenuHandle = ::GetSubMenu(_mainMenuHandle, MENUINDEX_LANGUAGE);
2078  							doCheck(_langMenuHandle, i);
2079  							return;
2080  						}
2081  					}
2082  				}
2083  			}
2084  		}
2085  	}
2086  	HMENU _langMenuHandle = ::GetSubMenu(_mainMenuHandle, MENUINDEX_LANGUAGE);
2087  	doCheck(_langMenuHandle, id);
2088  }
2089  generic_string Notepad_plus::getLangDesc(LangType langType, bool getName)
2090  {
2091  	NppParameters& nppParams = NppParameters::getInstance();
2092  	if ((langType >= L_EXTERNAL) && (langType < nppParams.L_END))
2093  	{
2094  		ExternalLangContainer & elc = nppParams.getELCFromIndex(langType - L_EXTERNAL);
2095  		WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
2096  		const TCHAR* lexerNameW = wmc.char2wchar(elc._name.c_str(), CP_ACP);
2097  		return generic_string(lexerNameW);
2098  	}
2099  	if (langType < L_TEXT || langType > L_EXTERNAL)
2100          langType = L_TEXT;
2101  	generic_string str2Show;
2102  	if (getName)
2103  		str2Show = ScintillaEditView::_langNameInfoArray[langType]._shortName;
2104  	else
2105  		str2Show = ScintillaEditView::_langNameInfoArray[langType]._longName;
2106  	if (langType == L_USER)
2107  	{
2108  		Buffer * currentBuf = _pEditView->getCurrentBuffer();
2109  		if (currentBuf->isUserDefineLangExt())
2110  		{
2111  			str2Show += TEXT(" - ");
2112  			str2Show += currentBuf->getUserDefineLangName();
2113  		}
2114  	}
2115  	return str2Show;
2116  }
2117  void Notepad_plus::copyMarkedLines()
2118  {
2119  	intptr_t lastLine = _pEditView->lastZeroBasedLineNumber();
2120  	generic_string globalStr = TEXT("");
2121  	for (intptr_t i = lastLine ; i >= 0 ; i--)
2122  	{
2123  		if (bookmarkPresent(i))
2124  		{
2125  			generic_string currentStr = getMarkedLine(i) + globalStr;
2126  			globalStr = currentStr;
2127  		}
2128  	}
2129  	str2Cliboard(globalStr);
2130  }
2131  std::mutex mark_mutex;
2132  void Notepad_plus::cutMarkedLines()
2133  {
2134  	std::lock_guard<std::mutex> lock(mark_mutex);
2135  	intptr_t lastLine = _pEditView->lastZeroBasedLineNumber();
2136  	generic_string globalStr = TEXT("");
2137  	_pEditView->execute(SCI_BEGINUNDOACTION);
2138  	for (intptr_t i = lastLine ; i >= 0 ; i--)
2139  	{
2140  		if (bookmarkPresent(i))
2141  		{
2142  			generic_string currentStr = getMarkedLine(i) + globalStr;
2143  			globalStr = currentStr;
2144  			deleteMarkedline(i);
2145  		}
2146  	}
2147  	_pEditView->execute(SCI_ENDUNDOACTION);
2148  	str2Cliboard(globalStr);
2149  }
2150  void Notepad_plus::deleteMarkedLines(bool isMarked)
2151  {
2152  	std::lock_guard<std::mutex> lock(mark_mutex);
2153  	intptr_t lastLine = _pEditView->lastZeroBasedLineNumber();
2154  	_pEditView->execute(SCI_BEGINUNDOACTION);
2155  	for (intptr_t i = lastLine ; i >= 0 ; i--)
2156  	{
2157  		if (bookmarkPresent(i) == isMarked)
2158  			deleteMarkedline(i);
2159  	}
2160  	_pEditView->execute(SCI_ENDUNDOACTION);
2161  }
2162  void Notepad_plus::pasteToMarkedLines()
2163  {
2164  	std::lock_guard<std::mutex> lock(mark_mutex);
2165  	int clipFormat;
2166  	clipFormat = CF_UNICODETEXT;
2167  	BOOL canPaste = ::IsClipboardFormatAvailable(clipFormat);
2168  	if (!canPaste)
2169  		return;
2170  	intptr_t lastLine = _pEditView->lastZeroBasedLineNumber();
2171  	::OpenClipboard(_pPublicInterface->getHSelf());
2172  	HANDLE clipboardData = ::GetClipboardData(clipFormat);
2173  	::GlobalSize(clipboardData);
2174  	LPVOID clipboardDataPtr = ::GlobalLock(clipboardData);
2175  	if (!clipboardDataPtr) return;
2176  	generic_string clipboardStr = (const TCHAR *)clipboardDataPtr;
2177  	::GlobalUnlock(clipboardData);
2178  	::CloseClipboard();
2179  	_pEditView->execute(SCI_BEGINUNDOACTION);
2180  	for (intptr_t i = lastLine ; i >= 0 ; i--)
2181  	{
2182  		if (bookmarkPresent(i))
2183  		{
2184  			replaceMarkedline(i, clipboardStr.c_str());
2185  		}
2186  	}
2187  	_pEditView->execute(SCI_ENDUNDOACTION);
2188  }
2189  void Notepad_plus::deleteMarkedline(size_t ln)
2190  {
2191  	intptr_t lineLen = _pEditView->execute(SCI_LINELENGTH, ln);
2192  	intptr_t lineBegin = _pEditView->execute(SCI_POSITIONFROMLINE, ln);
2193  	bookmarkDelete(ln);
2194  	TCHAR emptyString[2] = TEXT("");
2195  	_pEditView->replaceTarget(emptyString, lineBegin, lineBegin + lineLen);
2196  }
2197  void Notepad_plus::inverseMarks()
2198  {
2199  	intptr_t lastLine = _pEditView->lastZeroBasedLineNumber();
2200  	for (int i = 0 ; i <= lastLine  ; ++i)
2201  	{
2202  		if (bookmarkPresent(i))
2203  		{
2204  			bookmarkDelete(i);
2205  		}
2206  		else
2207  		{
2208  			bookmarkAdd(i);
2209  		}
2210  	}
2211  }
2212  void Notepad_plus::replaceMarkedline(size_t ln, const TCHAR *str)
2213  {
2214  	intptr_t lineBegin = _pEditView->execute(SCI_POSITIONFROMLINE, ln);
2215  	intptr_t lineEnd = _pEditView->execute(SCI_GETLINEENDPOSITION, ln);
2216  	_pEditView->replaceTarget(str, lineBegin, lineEnd);
2217  }
2218  generic_string Notepad_plus::getMarkedLine(size_t ln)
2219  {
2220  	auto lineLen = _pEditView->execute(SCI_LINELENGTH, ln);
2221  	auto lineBegin = _pEditView->execute(SCI_POSITIONFROMLINE, ln);
2222  	TCHAR * buf = new TCHAR[lineLen+1];
2223  	_pEditView->getGenericText(buf, lineLen + 1, lineBegin, lineBegin + lineLen);
2224  	generic_string line = buf;
2225  	delete [] buf;
2226  	return line;
2227  }
2228  void Notepad_plus::findMatchingBracePos(intptr_t& braceAtCaret, intptr_t& braceOpposite)
2229  {
2230  	intptr_t caretPos = _pEditView->execute(SCI_GETCURRENTPOS);
2231  	braceAtCaret = -1;
2232  	braceOpposite = -1;
2233  	TCHAR charBefore = '\0';
2234  	intptr_t lengthDoc = _pEditView->execute(SCI_GETLENGTH);
2235  	if ((lengthDoc > 0) && (caretPos > 0))
2236      {
2237  		charBefore = TCHAR(_pEditView->execute(SCI_GETCHARAT, caretPos - 1, 0));
2238  	}
2239  	if (charBefore && wcschr(L"[](){}", charBefore))
2240      {
2241  		braceAtCaret = caretPos - 1;
2242  	}
2243  	if (lengthDoc > 0  && (braceAtCaret < 0))
2244      {
2245  		TCHAR charAfter = TCHAR(_pEditView->execute(SCI_GETCHARAT, caretPos, 0));
2246  		if (charAfter && wcschr(L"[](){}", charAfter))
2247          {
2248  			braceAtCaret = caretPos;
2249  		}
2250  	}
2251  	if (braceAtCaret >= 0)
2252  		braceOpposite = _pEditView->execute(SCI_BRACEMATCH, braceAtCaret, 0);
2253  }
2254  bool Notepad_plus::braceMatch()
2255  {
2256  	Buffer* currentBuf = _pEditView->getCurrentBuffer();
2257  	if (!currentBuf->allowBraceMach())
2258  		return false;
2259  	intptr_t braceAtCaret = -1;
2260  	intptr_t braceOpposite = -1;
2261  	findMatchingBracePos(braceAtCaret, braceOpposite);
2262  	if ((braceAtCaret != -1) && (braceOpposite == -1))
2263      {
2264  		_pEditView->execute(SCI_BRACEBADLIGHT, braceAtCaret);
2265  		_pEditView->execute(SCI_SETHIGHLIGHTGUIDE, 0);
2266  	}
2267      else
2268      {
2269  		_pEditView->execute(SCI_BRACEHIGHLIGHT, braceAtCaret, braceOpposite);
2270  		if (_pEditView->isShownIndentGuide())
2271          {
2272              intptr_t columnAtCaret = _pEditView->execute(SCI_GETCOLUMN, braceAtCaret);
2273  		    intptr_t columnOpposite = _pEditView->execute(SCI_GETCOLUMN, braceOpposite);
2274  			_pEditView->execute(SCI_SETHIGHLIGHTGUIDE, (columnAtCaret < columnOpposite)?columnAtCaret:columnOpposite);
2275          }
2276      }
2277  	const bool enable = (braceAtCaret != -1) && (braceOpposite != -1);
2278      enableCommand(IDM_SEARCH_GOTOMATCHINGBRACE, enable, MENU | TOOLBAR);
2279  	enableCommand(IDM_SEARCH_SELECTMATCHINGBRACES, enable, MENU);
2280      return (braceAtCaret != -1);
2281  }
2282  void Notepad_plus::setLangStatus(LangType langType)
2283  {
2284  	_statusBar.setText(getLangDesc(langType).c_str(), STATUSBAR_DOC_TYPE);
2285  }
2286  void Notepad_plus::setDisplayFormat(EolType format)
2287  {
2288  	const TCHAR* str = TEXT("??");
2289  	switch (format)
2290  	{
2291  		case EolType::windows: str = TEXT("Windows (CR LF)"); break;
2292  		case EolType::macos:   str = TEXT("Macintosh (CR)"); break;
2293  		case EolType::unix:    str = TEXT("Unix (LF)"); break;
2294  		case EolType::unknown: str = TEXT("Unknown"); assert(false);  break;
2295  	}
2296  	_statusBar.setText(str, STATUSBAR_EOF_FORMAT);
2297  }
2298  void Notepad_plus::setUniModeText()
2299  {
2300  	Buffer *buf = _pEditView->getCurrentBuffer();
2301  	int encoding = buf->getEncoding();
2302  	UniMode um = buf->getUnicodeMode();
2303  	generic_string uniModeTextString;
2304  	if (encoding == -1)
2305  	{
2306  		switch (um)
2307  		{
2308  			case uniUTF8:
2309  				uniModeTextString = TEXT("UTF-8-BOM"); break;
2310  			case uni16BE:
2311  				uniModeTextString = TEXT("UTF-16 BE BOM"); break;
2312  			case uni16LE:
2313  				uniModeTextString = TEXT("UTF-16 LE BOM"); break;
2314  			case uni16BE_NoBOM:
2315  				uniModeTextString = TEXT("UTF-16 Big Endian"); break;
2316  			case uni16LE_NoBOM:
2317  				uniModeTextString = TEXT("UTF-16 Little Endian"); break;
2318  			case uniCookie:
2319  				uniModeTextString = TEXT("UTF-8"); break;
2320  			default :
2321  				uniModeTextString = TEXT("ANSI");
2322  		}
2323  	}
2324  	else
2325  	{
2326  		EncodingMapper& em = EncodingMapper::getInstance();
2327  		int cmdID = em.getIndexFromEncoding(encoding);
2328  		if (cmdID == -1)
2329  		{
2330  			assert(!"Encoding problem. Encoding is not added in encoding_table?");
2331  			return;
2332  		}
2333  		cmdID += IDM_FORMAT_ENCODE;
2334  		TCHAR uniModeText[menuItemStrLenMax]{};
2335  		::GetMenuString(_mainMenuHandle, cmdID, uniModeText, menuItemStrLenMax, MF_BYCOMMAND);
2336  		uniModeTextString = uniModeText;
2337  		const size_t tabPos = uniModeTextString.find_last_of('\t');
2338  		if (tabPos != generic_string::npos)
2339  			uniModeTextString.resize(tabPos);
2340  	}
2341  	_statusBar.setText(uniModeTextString.c_str(), STATUSBAR_UNICODE_TYPE);
2342  }
2343  bool isUrlSchemeStartChar(TCHAR const c)
2344  {
2345  	return ((c >= 'A') && (c <= 'Z'))
2346  		|| ((c >= 'a') && (c <= 'z'));
2347  }
2348  bool isUrlSchemeDelimiter(TCHAR const c) 
2349  {
2350  	return   ! (((c >= '0') && (c <= '9'))
2351  			 || ((c >= 'A') && (c <= 'Z'))
2352  			 || ((c >= 'a') && (c <= 'z'))
2353  			 ||  (c == '_'));
2354  }
2355  bool isUrlTextChar(TCHAR const c)
2356  {
2357  	if (c <= ' ') return false;
2358  	switch (c)
2359  	{
2360  		case '"':
2361  		case '#':
2362  		case '<':
2363  		case '>':
2364  		case '{':
2365  		case '}':
2366  		case '?':
2367  		case '\u007F':
2368  			return false;
2369  	}
2370  	return true;
2371  }
2372  bool isUrlQueryDelimiter(TCHAR const c)
2373  {
2374  	switch(c)
2375  	{
2376  		case '&':
2377  		case '+':
2378  		case '=':
2379  		case ';':
2380  			return true;
2381  	}
2382  	return false;
2383  }
2384  bool isUrlSchemeSupported(INTERNET_SCHEME s, TCHAR *url)
2385  {
2386  	switch (s)
2387  	{
2388  		case INTERNET_SCHEME_FTP:
2389  		case INTERNET_SCHEME_HTTP:
2390  		case INTERNET_SCHEME_HTTPS:
2391  		case INTERNET_SCHEME_MAILTO:
2392  		case INTERNET_SCHEME_FILE:
2393  			return true;
2394  		case INTERNET_SCHEME_PARTIAL:
2395  		case INTERNET_SCHEME_UNKNOWN:
2396  		case INTERNET_SCHEME_DEFAULT:
2397  		case INTERNET_SCHEME_GOPHER:
2398  		case INTERNET_SCHEME_NEWS:
2399  		case INTERNET_SCHEME_SOCKS:
2400  		case INTERNET_SCHEME_JAVASCRIPT:
2401  		case INTERNET_SCHEME_VBSCRIPT:
2402  		case INTERNET_SCHEME_RES:
2403  		default:
2404  			break;
2405  	}
2406  	generic_string const mySchemes = (NppParameters::getInstance()).getNppGUI()._uriSchemes + TEXT(" ");
2407  	TCHAR *p = (TCHAR *)mySchemes.c_str();
2408  	while (*p)
2409  	{
2410  		int i = 0;
2411  		while (p [i] && (p [i] != ' ')) i++;
2412  		if (i == 0) return false;
2413  		if (wcsnicmp(url, p, i) == 0) return true;
2414  		p += i;
2415  		while (*p == ' ') p++;
2416  	}
2417  	return false;
2418  }
2419  bool scanToUrlStart(TCHAR *text, int textLen, int start, int* distance, int* schemeLength)
2420  {
2421  	int p = start;
2422  	int p0 = 0;
2423  	enum {sUnknown, sScheme} s = sUnknown;
2424  	while (p < textLen)
2425  	{
2426  		switch (s)
2427  		{
2428  			case sUnknown:
2429  				if (isUrlSchemeStartChar(text [p]) && ((p == 0) || isUrlSchemeDelimiter(text [p - 1])))
2430  				{
2431  					p0 = p;
2432  					s = sScheme;
2433  				}
2434  				break;
2435  			case sScheme:
2436  				if (text [p] == ':')
2437  				{
2438  					*distance = p0 - start;
2439  					*schemeLength = p - p0 + 1;
2440  					return true;
2441  				}
2442  				if (!isUrlSchemeStartChar(text [p]))
2443  					s = sUnknown;
2444  				break;
2445  		}
2446  		p++;
2447  	}
2448  	*schemeLength = 0;
2449  	*distance = p - start;
2450  	return false;
2451  }
2452  void scanToUrlEnd(TCHAR *text, int textLen, int start, int* distance)
2453  {
2454  	int p = start;
2455  	TCHAR q = 0;
2456  	enum {sHostAndPath, sQuery, sQueryAfterDelimiter, sQueryQuotes, sQueryAfterQuotes, sFragment} s = sHostAndPath;
2457  	while (p < textLen)
2458  	{
2459  		switch (s)
2460  		{
2461  			case sHostAndPath: 
2462  				if (text [p] == '?')
2463  					s = sQuery;
2464  				else if (text [p] == '#')
2465  					s = sFragment;
2466  				else if (!isUrlTextChar (text [p]))
2467  				{
2468  					*distance = p - start;
2469  					return;
2470  				}
2471  				break;
2472  			case sQuery:
2473  				if (text [p] == '#')
2474  					s = sFragment;
2475  				else if (isUrlQueryDelimiter (text [p]))
2476  					s = sQueryAfterDelimiter;
2477  				else if (!isUrlTextChar(text [p]))
2478  				{
2479  					*distance = p - start;
2480  					return;
2481  				}
2482  				break;
2483  			case sQueryAfterDelimiter:
2484  				if ((text [p] == '\'') || (text [p] == '"') || (text [p] == '`'))
2485  				{
2486  					q = text [p];
2487  					s = sQueryQuotes;
2488  				}
2489  				else if (text [p] == '(')
2490  				{
2491  					q = ')';
2492  					s = sQueryQuotes;
2493  				}
2494  				else if (text [p] == '[')
2495  				{
2496  					q = ']';
2497  					s = sQueryQuotes;
2498  				}
2499  				else if (text [p] == '{')
2500  				{
2501  					q = '}';
2502  					s = sQueryQuotes;
2503  				}
2504  				else if (isUrlTextChar(text [p]))
2505  					s = sQuery;
2506  				else
2507  				{
2508  					*distance = p - start;
2509  					return;
2510  				}
2511  				break;
2512  			case sQueryQuotes:
2513  				if (text [p] < ' ')
2514  				{
2515  					*distance = p - start;
2516  					return;
2517  				}
2518  				if (text [p] == q)
2519  					s = sQueryAfterQuotes;
2520  				break;
2521  			case sQueryAfterQuotes:
2522  				if (isUrlQueryDelimiter (text [p]))
2523  					s = sQueryAfterDelimiter;
2524  				else
2525  				{
2526  					*distance = p - start;
2527  					return;
2528  				}
2529  				break;
2530  			case sFragment:
2531  				if (!isUrlTextChar(text [p]))
2532  				{
2533  					*distance = p - start;
2534  					return;
2535  				}
2536  				break;
2537  		}
2538  		p++;
2539  	}
2540  	*distance = p - start;
2541  }
2542  bool removeUnwantedTrailingCharFromUrl (TCHAR const *text, int* length)
2543  {
2544  	int l = *length - 1;
2545  	if (l <= 0) return false;
2546  	{ 
2547  		const TCHAR *singleChars = L".,:;?!#";
2548  		for (int i = 0; singleChars [i]; i++)
2549  			if (text [l] == singleChars [i])
2550  			{
2551  				*length = l;
2552  				return true;
2553  			}
2554  	}
2555  	{ 
2556  		const TCHAR *closingParenthesis = L")]";
2557  		const TCHAR *openingParenthesis = L"([";
2558  		for (int i = 0; closingParenthesis [i]; i++)
2559  			if (text [l] == closingParenthesis [i])
2560  			{
2561  				int count = 0;
2562  				for (int j = l - 1; j >= 0; j--)
2563  				{
2564  					if (text [j] == closingParenthesis [i])
2565  						count++;
2566  					if (text[j] == openingParenthesis[i])
2567  					{
2568  						if (count > 0)
2569  							count--;
2570  						else
2571  							return false;
2572  					}
2573  				}
2574  				if (count != 0)
2575  					return false;
2576  				*length = l;
2577  				return true;
2578  			}
2579  	}
2580  	return false;
2581  }
2582  bool isUrl(TCHAR * text, int textLen, int start, int* segmentLen)
2583  {
2584  	int dist = 0, schemeLen = 0;
2585  	if (scanToUrlStart(text, textLen, start, & dist, & schemeLen))
2586  	{
2587  		if (dist)
2588  		{
2589  			*segmentLen = dist;
2590  			return false;
2591  		}
2592  		int len = 0;
2593  		scanToUrlEnd (text, textLen, start + schemeLen, & len);
2594  		if (len)
2595  		{
2596  			len += schemeLen;
2597  			URL_COMPONENTS url;
2598  			memset (& url, 0, sizeof(url));
2599  			url.dwStructSize = sizeof(url);
2600  			bool r  = InternetCrackUrl(& text [start], len, 0, & url) && isUrlSchemeSupported(url.nScheme, & text [start]);
2601  			if (r)
2602  			{
2603  				while (removeUnwantedTrailingCharFromUrl (& text [start], & len));
2604  				*segmentLen = len;
2605  				return true;
2606  			}
2607  		}
2608  		len = 1;
2609  		int lMax = textLen - start;
2610  		while (isUrlSchemeStartChar(text[start+len]) && (len < lMax)) len++;
2611  		*segmentLen = len;
2612  		return false;
2613  	}
2614  	*segmentLen = dist;
2615  	return false;
2616  }
2617  void Notepad_plus::addHotSpot(ScintillaEditView* view)
2618  {
2619  	ScintillaEditView* pView = view ? view : _pEditView;
2620  	Buffer* currentBuf = pView->getCurrentBuffer();
2621  	int urlAction = (NppParameters::getInstance()).getNppGUI()._styleURL;
2622  	LPARAM indicStyle = (urlAction == urlNoUnderLineFg) || (urlAction == urlNoUnderLineBg) ? INDIC_HIDDEN : INDIC_PLAIN;
2623  	LPARAM indicHoverStyle = (urlAction == urlNoUnderLineBg) || (urlAction == urlUnderLineBg) ? INDIC_FULLBOX : INDIC_EXPLORERLINK;
2624  	LPARAM indicStyleCur = pView->execute(SCI_INDICGETSTYLE, URL_INDIC);
2625  	LPARAM indicHoverStyleCur = pView->execute(SCI_INDICGETHOVERSTYLE, URL_INDIC);
2626  	if ((indicStyleCur != indicStyle) || (indicHoverStyleCur != indicHoverStyle))
2627  	{
2628  		pView->execute(SCI_INDICSETSTYLE, URL_INDIC, indicStyle);
2629  		pView->execute(SCI_INDICSETHOVERSTYLE, URL_INDIC, indicHoverStyle);
2630  		pView->execute(SCI_INDICSETALPHA, URL_INDIC, 70);
2631  		pView->execute(SCI_INDICSETFLAGS, URL_INDIC, SC_INDICFLAG_VALUEFORE);
2632  	}
2633  	intptr_t startPos = 0;
2634  	intptr_t endPos = -1;
2635  	pView->getVisibleStartAndEndPosition(&startPos, &endPos);
2636  	if (startPos >= endPos) return;
2637  	pView->execute(SCI_SETINDICATORCURRENT, URL_INDIC);
2638  	if (urlAction == urlDisable || !currentBuf->allowClickableLink())
2639  	{
2640  		pView->execute(SCI_INDICATORCLEARRANGE, startPos, endPos - startPos);
2641  		return;
2642  	}
2643  	LRESULT indicFore = pView->execute(SCI_STYLEGETFORE, STYLE_DEFAULT);
2644  	pView->execute(SCI_SETINDICATORVALUE, indicFore);
2645  	UINT cp = static_cast<UINT>(pView->execute(SCI_GETCODEPAGE));
2646  	char *encodedText = new char[endPos - startPos + 1];
2647  	pView->getText(encodedText, startPos, endPos);
2648  	TCHAR *wideText = new TCHAR[endPos - startPos + 1];
2649  	int wideTextLen = MultiByteToWideChar(cp, 0, encodedText, static_cast<int>(endPos - startPos + 1), (LPWSTR) wideText, static_cast<int>(endPos - startPos + 1)) - 1;
2650  	delete[] encodedText;
2651  	if (wideTextLen > 0)
2652  	{
2653  		int startWide = 0;
2654  		int lenWide = 0;
2655  		int startEncoded = 0;
2656  		int lenEncoded = 0;
2657  		while (true)
2658  		{
2659  			bool r = isUrl(wideText, wideTextLen, startWide, & lenWide);
2660  			if (lenWide <= 0)
2661  				break;
2662  			assert ((startWide + lenWide) <= wideTextLen);
2663  			lenEncoded = WideCharToMultiByte(cp, 0, & wideText [startWide], lenWide, NULL, 0, NULL, NULL);
2664  			if (r)
2665  				pView->execute(SCI_INDICATORFILLRANGE, startEncoded + startPos, lenEncoded);
2666  			else
2667  				pView->execute(SCI_INDICATORCLEARRANGE, startEncoded + startPos, lenEncoded);
2668  			startWide += lenWide;
2669  			startEncoded += lenEncoded;
2670  			if ((startWide >= wideTextLen) || ((startEncoded + startPos) >= endPos))
2671  				break;
2672  		}
2673  		assert ((startEncoded + startPos) == endPos);
2674  		assert (startWide == wideTextLen);
2675  	}
2676  	delete[] wideText;
2677  }
2678  bool Notepad_plus::isConditionExprLine(intptr_t lineNumber)
2679  {
2680  	if (lineNumber < 0 || lineNumber > _pEditView->execute(SCI_GETLINECOUNT))
2681  		return false;
2682  	auto startPos = _pEditView->execute(SCI_POSITIONFROMLINE, lineNumber);
2683  	auto endPos = _pEditView->execute(SCI_GETLINEENDPOSITION, lineNumber);
2684  	_pEditView->execute(SCI_SETSEARCHFLAGS, SCFIND_REGEXP | SCFIND_POSIX);
2685  	_pEditView->execute(SCI_SETTARGETRANGE, startPos, endPos);
2686  	const char ifElseForWhileExpr[] = "((else[ \t]+)?if|for|while)[ \t]*[(].*[)][ \t]*|else[ \t]*";
2687  	auto posFound = _pEditView->execute(SCI_SEARCHINTARGET, strlen(ifElseForWhileExpr), reinterpret_cast<LPARAM>(ifElseForWhileExpr));
2688  	if (posFound >= 0)
2689  	{
2690  		auto end = _pEditView->execute(SCI_GETTARGETEND);
2691  		if (end == endPos)
2692  			return true;
2693  	}
2694  	return false;
2695  }
2696  intptr_t Notepad_plus::findMachedBracePos(size_t startPos, size_t endPos, char targetSymbol, char matchedSymbol)
2697  {
2698  	if (startPos == endPos)
2699  		return -1;
2700  	if (startPos > endPos) 
2701  	{
2702  		int balance = 0;
2703  		for (intptr_t i = startPos; i >= static_cast<intptr_t>(endPos); --i)
2704  		{
2705  			char aChar = static_cast<char>(_pEditView->execute(SCI_GETCHARAT, i));
2706  			if (aChar == targetSymbol)
2707  			{
2708  				if (balance == 0)
2709  					return i;
2710  				--balance;
2711  			}
2712  			else if (aChar == matchedSymbol)
2713  			{
2714  				++balance;
2715  			}
2716  		}
2717  	}
2718  	else 
2719  	{
2720  	}
2721  	return -1;
2722  }
2723  void Notepad_plus::maintainIndentation(TCHAR ch)
2724  {
2725  	intptr_t eolMode = _pEditView->execute(SCI_GETEOLMODE);
2726  	intptr_t curLine = _pEditView->getCurrentLineNumber();
2727  	intptr_t prevLine = curLine - 1;
2728  	intptr_t indentAmountPrevLine = 0;
2729  	intptr_t tabWidth = _pEditView->execute(SCI_GETTABWIDTH);
2730  	LangType type = _pEditView->getCurrentBuffer()->getLangType();
2731  	ExternalLexerAutoIndentMode autoIndentMode = ExternalLexerAutoIndentMode::Standard;
2732  	if (type >= L_EXTERNAL)
2733  	{
2734  		NppParameters& nppParam = NppParameters::getInstance();
2735  		autoIndentMode = nppParam.getELCFromIndex(type - L_EXTERNAL)._autoIndentMode;
2736  		if (autoIndentMode == ExternalLexerAutoIndentMode::Custom)
2737  			return;
2738  	}
2739  	if ((((eolMode == SC_EOL_CRLF || eolMode == SC_EOL_LF) && ch == '\n') ||
2740  		(eolMode == SC_EOL_CR && ch == '\r')) && prevLine >= 0 && _pEditView->getLineLength(prevLine) == 0)
2741  		return;
2742  	if (type == L_C || type == L_CPP || type == L_JAVA || type == L_CS || type == L_OBJC ||
2743  		type == L_PHP || type == L_JS || type == L_JAVASCRIPT || type == L_JSP || type == L_CSS || type == L_PERL || 
2744  		type == L_RUST || type == L_POWERSHELL || type == L_JSON || type == L_JSON5 || autoIndentMode == ExternalLexerAutoIndentMode::C_Like)
2745  	{
2746  		if (((eolMode == SC_EOL_CRLF || eolMode == SC_EOL_LF) && ch == '\n') ||
2747  			(eolMode == SC_EOL_CR && ch == '\r'))
2748  		{
2749  			while (prevLine >= 0 && _pEditView->getLineLength(prevLine) == 0)
2750  				prevLine--;
2751  			if (prevLine >= 0)
2752  			{
2753  				indentAmountPrevLine = _pEditView->getLineIndent(prevLine);
2754  			}
2755  			intptr_t prevPos = _pEditView->execute(SCI_GETCURRENTPOS) - (eolMode == SC_EOL_CRLF ? 3 : 2);
2756  			UCHAR prevChar = (UCHAR)_pEditView->execute(SCI_GETCHARAT, prevPos);
2757  			auto curPos = _pEditView->execute(SCI_GETCURRENTPOS);
2758  			UCHAR nextChar = (UCHAR)_pEditView->execute(SCI_GETCHARAT, curPos);
2759  			if (prevChar == '{')
2760  			{
2761  				if (nextChar == '}')
2762  				{
2763  					const char *eolChars;
2764  					if (eolMode == SC_EOL_CRLF)
2765  						eolChars = "\r\n";
2766  					else if (eolMode == SC_EOL_LF)
2767  						eolChars = "\n";
2768  					else
2769  						eolChars = "\r";
2770  					_pEditView->execute(SCI_INSERTTEXT, _pEditView->execute(SCI_GETCURRENTPOS), reinterpret_cast<LPARAM>(eolChars));
2771  					_pEditView->setLineIndent(curLine + 1, indentAmountPrevLine);
2772  				}
2773  				_pEditView->setLineIndent(curLine, indentAmountPrevLine + tabWidth);
2774  			}
2775  			else if (nextChar == '{')
2776  			{
2777  				_pEditView->setLineIndent(curLine, indentAmountPrevLine);
2778  			}
2779  			else if (type == L_PERL || type == L_RUST || type == L_POWERSHELL || type == L_JSON || type == L_JSON5)
2780  			{
2781  				_pEditView->setLineIndent(curLine, indentAmountPrevLine);
2782  			}
2783  			else if (isConditionExprLine(prevLine))
2784  			{
2785  				_pEditView->setLineIndent(curLine, indentAmountPrevLine + tabWidth);
2786  			}
2787  			else
2788  			{
2789  				if (indentAmountPrevLine > 0)
2790  				{
2791  					if (prevLine > 0 && isConditionExprLine(prevLine - 1))
2792  						_pEditView->setLineIndent(curLine, indentAmountPrevLine - tabWidth);
2793  					else
2794  						_pEditView->setLineIndent(curLine, indentAmountPrevLine);
2795  				}
2796  			}
2797  		}
2798  		else if (ch == '{')
2799  		{
2800  			auto startPos = _pEditView->execute(SCI_POSITIONFROMLINE, curLine);
2801  			LRESULT endPos = _pEditView->execute(SCI_GETCURRENTPOS);
2802  			for (LRESULT i = endPos - 2; i > 0 && i > startPos; --i)
2803  			{
2804  				UCHAR aChar = (UCHAR)_pEditView->execute(SCI_GETCHARAT, i);
2805  				if (aChar != ' ' && aChar != '\t')
2806  					return;
2807  			}
2808  			while (prevLine >= 0 && _pEditView->getLineLength(prevLine) == 0)
2809  				prevLine--;
2810  			if (prevLine >= 0)
2811  			{
2812  				indentAmountPrevLine = _pEditView->getLineIndent(prevLine);
2813  				auto startPos2 = _pEditView->execute(SCI_POSITIONFROMLINE, prevLine);
2814  				auto endPos2 = _pEditView->execute(SCI_GETLINEENDPOSITION, prevLine);
2815  				_pEditView->execute(SCI_SETSEARCHFLAGS, SCFIND_REGEXP | SCFIND_POSIX);
2816  				_pEditView->execute(SCI_SETTARGETRANGE, startPos2, endPos2);
2817  				const char braceExpr[] = "[ \t]*\\{.*";
2818  				intptr_t posFound = _pEditView->execute(SCI_SEARCHINTARGET, strlen(braceExpr), reinterpret_cast<LPARAM>(braceExpr));
2819  				if (posFound >= 0)
2820  				{
2821  					auto end = _pEditView->execute(SCI_GETTARGETEND);
2822  					if (end == endPos2)
2823  						indentAmountPrevLine += tabWidth;
2824  				}
2825  			}
2826  			_pEditView->setLineIndent(curLine, indentAmountPrevLine);
2827  		}
2828  		else if (ch == '}')
2829  		{
2830  			intptr_t startPos = _pEditView->execute(SCI_GETCURRENTPOS);
2831  			if (startPos != 0)
2832  				startPos -= 1;
2833  			intptr_t posFound = findMachedBracePos(startPos - 1, 0, '{', '}');
2834  			if (posFound == -1)
2835  				return;
2836  			intptr_t matchedPairLine = _pEditView->execute(SCI_LINEFROMPOSITION, posFound);
2837  			if (matchedPairLine == curLine)
2838  				return;
2839  			indentAmountPrevLine = _pEditView->getLineIndent(matchedPairLine);
2840  			_pEditView->setLineIndent(curLine, indentAmountPrevLine);
2841  		}
2842  	}
2843  	else 
2844  	{
2845  		if (((eolMode == SC_EOL_CRLF || eolMode == SC_EOL_LF) && ch == '\n') ||
2846  			(eolMode == SC_EOL_CR && ch == '\r'))
2847  		{
2848  			while (prevLine >= 0 && _pEditView->getLineLength(prevLine) == 0)
2849  				prevLine--;
2850  			if (prevLine >= 0)
2851  			{
2852  				indentAmountPrevLine = _pEditView->getLineIndent(prevLine);
2853  			}
2854  			if (indentAmountPrevLine > 0)
2855  			{
2856  				_pEditView->setLineIndent(curLine, indentAmountPrevLine);
2857  			}
2858  		}
2859  	}
2860  }
2861  BOOL Notepad_plus::processFindAccel(MSG *msg) const
2862  {
2863  	if (!::IsChild(_findReplaceDlg.getHSelf(), ::GetFocus()))
2864  		return FALSE;
2865  	return ::TranslateAccelerator(_findReplaceDlg.getHSelf(), _accelerator.getFindAccTable(), msg);
2866  }
2867  BOOL Notepad_plus::processIncrFindAccel(MSG *msg) const
2868  {
2869  	if (!::IsChild(_incrementFindDlg.getHSelf(), ::GetFocus()))
2870  		return FALSE;
2871  	return ::TranslateAccelerator(_incrementFindDlg.getHSelf(), _accelerator.getIncrFindAccTable(), msg);
2872  }
2873  void Notepad_plus::setLanguage(LangType langType)
2874  {
2875  	bool reset = false;
2876  	Document prev = 0;
2877  	if (bothActive())
2878  	{
2879  		if (_mainEditView.getCurrentBufferID() == _subEditView.getCurrentBufferID())
2880  		{
2881  			reset = true;
2882  			_subEditView.saveCurrentPos();
2883  			prev = _subEditView.execute(SCI_GETDOCPOINTER);
2884  			_subEditView.execute(SCI_SETDOCPOINTER, 0, 0);
2885  		}
2886  	}
2887  	if (reset)
2888  	{
2889  		_mainEditView.getCurrentBuffer()->setLangType(langType);
2890  	}
2891  	else
2892  	{
2893  		_pEditView->getCurrentBuffer()->setLangType(langType);
2894  	}
2895  	if (reset)
2896  	{
2897  		_subEditView.execute(SCI_SETDOCPOINTER, 0, prev);
2898  		_subEditView.restoreCurrentPosPreStep();
2899  	}
2900  }
2901  LangType Notepad_plus::menuID2LangType(int cmdID)
2902  {
2903  	switch (cmdID)
2904  	{
2905          case IDM_LANG_C	:
2906              return L_C;
2907          case IDM_LANG_CPP :
2908              return L_CPP;
2909          case IDM_LANG_JAVA :
2910              return L_JAVA;
2911          case IDM_LANG_CS :
2912              return L_CS;
2913          case IDM_LANG_HTML :
2914              return L_HTML;
2915          case IDM_LANG_XML :
2916              return L_XML;
2917          case IDM_LANG_JS :
2918  			return L_JAVASCRIPT;
2919  		case IDM_LANG_JSON:
2920  			return L_JSON;
2921  		case IDM_LANG_JSON5:
2922  			return L_JSON5;
2923          case IDM_LANG_PHP :
2924              return L_PHP;
2925          case IDM_LANG_ASP :
2926              return L_ASP;
2927          case IDM_LANG_JSP :
2928              return L_JSP;
2929          case IDM_LANG_CSS :
2930              return L_CSS;
2931          case IDM_LANG_LUA :
2932              return L_LUA;
2933          case IDM_LANG_PERL :
2934              return L_PERL;
2935          case IDM_LANG_PYTHON :
2936              return L_PYTHON;
2937          case IDM_LANG_PASCAL :
2938              return L_PASCAL;
2939          case IDM_LANG_BATCH :
2940              return L_BATCH;
2941          case IDM_LANG_OBJC :
2942              return L_OBJC;
2943          case IDM_LANG_VB :
2944              return L_VB;
2945          case IDM_LANG_SQL :
2946              return L_SQL;
2947          case IDM_LANG_MSSQL :
2948              return L_MSSQL;
2949          case IDM_LANG_ASCII :
2950              return L_ASCII;
2951          case IDM_LANG_TEXT :
2952              return L_TEXT;
2953          case IDM_LANG_RC :
2954              return L_RC;
2955          case IDM_LANG_MAKEFILE :
2956              return L_MAKEFILE;
2957          case IDM_LANG_INI :
2958              return L_INI;
2959          case IDM_LANG_TEX :
2960              return L_TEX;
2961          case IDM_LANG_FORTRAN :
2962              return L_FORTRAN;
2963  		case IDM_LANG_FORTRAN_77 :
2964  			return L_FORTRAN_77;
2965          case IDM_LANG_BASH :
2966              return L_BASH;
2967          case IDM_LANG_FLASH :
2968              return L_FLASH;
2969  		case IDM_LANG_NSIS :
2970              return L_NSIS;
2971  		case IDM_LANG_TCL :
2972              return L_TCL;
2973  		case IDM_LANG_LISP :
2974  			return L_LISP;
2975  		case IDM_LANG_SCHEME :
2976  			return L_SCHEME;
2977  		case IDM_LANG_ASM :
2978              return L_ASM;
2979  		case IDM_LANG_DIFF :
2980              return L_DIFF;
2981  		case IDM_LANG_PROPS :
2982              return L_PROPS;
2983  		case IDM_LANG_PS:
2984              return L_PS;
2985  		case IDM_LANG_RUBY:
2986              return L_RUBY;
2987  		case IDM_LANG_SMALLTALK:
2988              return L_SMALLTALK;
2989  		case IDM_LANG_VHDL :
2990              return L_VHDL;
2991          case IDM_LANG_KIX :
2992              return L_KIX;
2993          case IDM_LANG_CAML :
2994              return L_CAML;
2995          case IDM_LANG_ADA :
2996              return L_ADA;
2997          case IDM_LANG_VERILOG :
2998              return L_VERILOG;
2999  		case IDM_LANG_MATLAB :
3000              return L_MATLAB;
3001  		case IDM_LANG_HASKELL :
3002              return L_HASKELL;
3003          case IDM_LANG_AU3 :
3004              return L_AU3;
3005  		case IDM_LANG_INNO :
3006              return L_INNO;
3007  		case IDM_LANG_CMAKE :
3008              return L_CMAKE;
3009  		case IDM_LANG_YAML :
3010  			return L_YAML;
3011          case IDM_LANG_COBOL :
3012              return L_COBOL;
3013          case IDM_LANG_D :
3014              return L_D;
3015          case IDM_LANG_GUI4CLI :
3016              return L_GUI4CLI;
3017          case IDM_LANG_POWERSHELL :
3018              return L_POWERSHELL;
3019          case IDM_LANG_R :
3020              return L_R;
3021  		case IDM_LANG_COFFEESCRIPT :
3022              return L_COFFEESCRIPT;
3023  		case IDM_LANG_BAANC:
3024  			return L_BAANC;
3025  		case IDM_LANG_SREC :
3026              return L_SREC;
3027  		case IDM_LANG_IHEX :
3028              return L_IHEX;
3029  		case IDM_LANG_TEHEX :
3030              return L_TEHEX;
3031  		case IDM_LANG_SWIFT:
3032  			return L_SWIFT;
3033          case IDM_LANG_ASN1 :
3034              return L_ASN1;
3035          case IDM_LANG_AVS :
3036              return L_AVS;
3037          case IDM_LANG_BLITZBASIC :
3038              return L_BLITZBASIC;
3039          case IDM_LANG_PUREBASIC :
3040              return L_PUREBASIC;
3041          case IDM_LANG_FREEBASIC :
3042              return L_FREEBASIC;
3043          case IDM_LANG_CSOUND :
3044              return L_CSOUND;
3045          case IDM_LANG_ERLANG :
3046              return L_ERLANG;
3047          case IDM_LANG_ESCRIPT :
3048              return L_ESCRIPT;
3049          case IDM_LANG_FORTH :
3050              return L_FORTH;
3051          case IDM_LANG_LATEX :
3052              return L_LATEX;
3053          case IDM_LANG_MMIXAL :
3054              return L_MMIXAL;
3055          case IDM_LANG_NIM :
3056              return L_NIM;
3057          case IDM_LANG_NNCRONTAB :
3058              return L_NNCRONTAB;
3059          case IDM_LANG_OSCRIPT :
3060              return L_OSCRIPT;
3061          case IDM_LANG_REBOL :
3062              return L_REBOL;
3063          case IDM_LANG_REGISTRY :
3064              return L_REGISTRY;
3065          case IDM_LANG_RUST :
3066              return L_RUST;
3067          case IDM_LANG_SPICE :
3068              return L_SPICE;
3069          case IDM_LANG_TXT2TAGS :
3070              return L_TXT2TAGS;
3071          case IDM_LANG_VISUALPROLOG:
3072              return L_VISUALPROLOG;
3073          case IDM_LANG_TYPESCRIPT:
3074              return L_TYPESCRIPT;
3075          case IDM_LANG_GDSCRIPT:
3076              return L_GDSCRIPT;
3077          case IDM_LANG_HOLLYWOOD:
3078              return L_HOLLYWOOD;	    
3079          case IDM_LANG_USER:
3080              return L_USER;
3081  		default:
3082  		{
3083  			if (cmdID >= IDM_LANG_USER && cmdID <= IDM_LANG_USER_LIMIT)
3084  			{
3085  				return L_USER;
3086  			}
3087  			break; 
3088  		}
3089  	}
3090  	return L_EXTERNAL;
3091  }
3092  void Notepad_plus::setTitle()
3093  {
3094  	NppParameters& nppParams = NppParameters::getInstance();
3095  	const NppGUI & nppGUI = nppParams.getNppGUI();
3096  	Buffer * buf = _pEditView->getCurrentBuffer();
3097  	generic_string result = TEXT("");
3098  	if (buf->isDirty())
3099  	{
3100  		result += TEXT("*");
3101  	}
3102  	if (nppGUI._shortTitlebar)
3103  	{
3104  		result += buf->getFileName();
3105  	}
3106  	else
3107  	{
3108  		result += buf->getFullPathName();
3109  	}
3110  	result += TEXT(" - ");
3111  	result += _pPublicInterface->getClassName();
3112  	if (_isAdministrator)
3113  		result += TEXT(" [Administrator]");
3114  	generic_string tbAdd = nppParams.getTitleBarAdd();
3115  	if (!tbAdd.empty())
3116  	{
3117  		result += TEXT(" - ");
3118  		result += tbAdd;
3119  	}
3120  	::SendMessage(_pPublicInterface->getHSelf(), WM_SETTEXT, 0, reinterpret_cast<LPARAM>(result.c_str()));
3121  }
3122  void Notepad_plus::activateNextDoc(bool direction)
3123  {
3124  	int nbDoc = static_cast<int32_t>(_pDocTab->nbItem());
3125      int curIndex = _pDocTab->getCurrentTabIndex();
3126      curIndex += (direction == dirUp)?-1:1;
3127  	if (curIndex >= nbDoc)
3128  	{
3129  		if (viewVisible(otherView()))
3130  			switchEditViewTo(otherView());
3131  		curIndex = 0;
3132  	}
3133  	else if (curIndex < 0)
3134  	{
3135  		if (viewVisible(otherView()))
3136  		{
3137  			switchEditViewTo(otherView());
3138  			nbDoc = static_cast<int32_t>(_pDocTab->nbItem());
3139  		}
3140  		curIndex = nbDoc - 1;
3141  	}
3142  	BufferID id = _pDocTab->getBufferByIndex(curIndex);
3143  	activateBuffer(id, currentView());
3144  }
3145  void Notepad_plus::activateDoc(size_t pos)
3146  {
3147  	size_t nbDoc = _pDocTab->nbItem();
3148  	if (pos == static_cast<size_t>(_pDocTab->getCurrentTabIndex()))
3149  	{
3150  		Buffer * buf = _pEditView->getCurrentBuffer();
3151  		buf->increaseRecentTag();
3152  		return;
3153  	}
3154  	if (pos < nbDoc)
3155  	{
3156  		BufferID id = _pDocTab->getBufferByIndex(pos);
3157  		activateBuffer(id, currentView());
3158  	}
3159  }
3160  static const char utflen[] = {1,1,2,3};
3161  size_t Notepad_plus::getSelectedCharNumber(UniMode u)
3162  {
3163  	size_t result = 0;
3164  	size_t numSel = _pEditView->execute(SCI_GETSELECTIONS);
3165  	if (u == uniUTF8 || u == uniCookie)
3166  	{
3167  		for (size_t i = 0; i < numSel; ++i)
3168  		{
3169  			size_t line1 = _pEditView->execute(SCI_LINEFROMPOSITION, _pEditView->execute(SCI_GETSELECTIONNSTART, i));
3170  			size_t line2 = _pEditView->execute(SCI_LINEFROMPOSITION, _pEditView->execute(SCI_GETSELECTIONNEND, i));
3171  			for (size_t j = line1; j <= line2; ++j)
3172  			{
3173  				size_t stpos = _pEditView->execute(SCI_GETLINESELSTARTPOSITION, j);
3174  				if (static_cast<intptr_t>(stpos) != INVALID_POSITION)
3175  				{
3176  					size_t endpos = _pEditView->execute(SCI_GETLINESELENDPOSITION, j);
3177  					for (size_t pos = stpos; pos < endpos; ++pos)
3178  					{
3179  						unsigned char c = 0xf0 & static_cast<unsigned char>(_pEditView->execute(SCI_GETCHARAT, pos));
3180  						if (c >= 0xc0)
3181  							pos += utflen[(c & 0x30) >>  4];
3182  						++result;
3183  					}
3184  				}
3185  			}
3186  		}
3187  	}
3188  	else
3189  	{
3190  		for (size_t i = 0; i < numSel; ++i)
3191  		{
3192  			size_t stpos = _pEditView->execute(SCI_GETSELECTIONNSTART, i);
3193  			size_t endpos = _pEditView->execute(SCI_GETSELECTIONNEND, i);
3194  			result += (endpos - stpos);
3195  			size_t line1 = _pEditView->execute(SCI_LINEFROMPOSITION, stpos);
3196  			size_t line2 = _pEditView->execute(SCI_LINEFROMPOSITION, endpos);
3197  			line2 -= line1;
3198  			if (_pEditView->execute(SCI_GETEOLMODE) == SC_EOL_CRLF) line2 *= 2;
3199  			result -= line2;
3200  		}
3201  		if (u != uni8Bit && u != uni7Bit) result *= 2;
3202  	}
3203  	return result;
3204  }
3205  #ifdef _OPENMP
3206  #include <omp.h>
3207  #endif
3208  static inline size_t countUtf8Characters(unsigned char *buf, size_t pos, size_t endpos)
3209  {
3210  	size_t result = 0;
3211  	while (pos < endpos)
3212  	{
3213  		unsigned char c = buf[pos++];
3214  		if ((c&0xc0) == 0x80 
3215  			|| c == '\n' || c == '\r') continue; 
3216  		if (c >= 0xc0) 
3217  			pos += utflen[(c & 0x30) >>  4];
3218  		++result;
3219  	}
3220  	return result;
3221  }
3222  size_t Notepad_plus::getCurrentDocCharCount(UniMode u)
3223  {
3224  	if (u != uniUTF8 && u != uniCookie)
3225  	{
3226  		size_t numLines = _pEditView->execute(SCI_GETLINECOUNT);
3227  		auto result = _pEditView->execute(SCI_GETLENGTH);
3228  		size_t lines = numLines==0?0:numLines-1;
3229  		if (_pEditView->execute(SCI_GETEOLMODE) == SC_EOL_CRLF) lines *= 2;
3230  		result -= lines;
3231  		return (result < 0) ? 0 : result;
3232  	}
3233   	else
3234   	{
3235  		size_t result = 0;
3236  		size_t endpos = _pEditView->execute(SCI_GETLENGTH);
3237  		unsigned char* buf = (unsigned char*)_pEditView->execute(SCI_GETCHARACTERPOINTER); 
3238  #ifdef _OPENMP 
3239  		if (endpos > 50000) 
3240  		{
3241  			#pragma omp parallel reduction(+: result)
3242  			{
3243  				unsigned int num_threads = omp_get_num_threads();
3244  				unsigned int thread_num = omp_get_thread_num();
3245  				size_t chunk_size = endpos/num_threads;
3246  				size_t pos = chunk_size*thread_num;
3247  				size_t endpos_local = (thread_num == num_threads-1) ? endpos : pos+chunk_size;
3248  				result = countUtf8Characters(buf, pos, endpos_local);
3249  			}
3250  		}
3251  		else
3252  #endif
3253  		{
3254  			result = countUtf8Characters(buf, 0, endpos);
3255  		}
3256   		return result;
3257   	}
3258  }
3259  bool Notepad_plus::isFormatUnicode(UniMode u)
3260  {
3261  	return (u != uni8Bit && u != uni7Bit && u != uniUTF8 && u != uniCookie);
3262  }
3263  int Notepad_plus::getBOMSize(UniMode u)
3264  {
3265  	switch(u)
3266  	{
3267  		case uni16LE:
3268  		case uni16BE:
3269  			return 2;
3270  		case uniUTF8:
3271  			return 3;
3272  		default:
3273  			return 0;
3274  	}
3275  }
3276  size_t Notepad_plus::getSelectedAreas()
3277  {
3278  	size_t numSel = _pEditView->execute(SCI_GETSELECTIONS);
3279  	if (numSel == 1) 
3280  		return (_pEditView->execute(SCI_GETSELECTIONNSTART, 0) == _pEditView->execute(SCI_GETSELECTIONNEND, 0)) ? 0 : 1;
3281  	return (_pEditView->execute(SCI_SELECTIONISRECTANGLE)) ? 1 : numSel;
3282  }
3283  size_t Notepad_plus::getSelectedBytes()
3284  {
3285  	size_t numSel = _pEditView->execute(SCI_GETSELECTIONS);
3286  	size_t result = 0;
3287  	for (size_t i = 0; i < numSel; ++i)
3288  		result += (_pEditView->execute(SCI_GETSELECTIONNEND, i) - _pEditView->execute(SCI_GETSELECTIONNSTART, i));
3289  	return result;
3290  }
3291  int Notepad_plus::wordCount()
3292  {
3293      FindOption env;
3294      env._str2Search = TEXT("[^ 	\\\\.,;:!?()+\\r\\n\\-\\*/=\\]\\[{}&~\"'`|@$%<>\\^]+");
3295      env._searchType = FindRegex;
3296      return _findReplaceDlg.processAll(ProcessCountAll, &env, true);
3297  }
3298  void Notepad_plus::updateStatusBar()
3299  {
3300  	TCHAR strDocLen[256];
3301  	size_t docLen = _pEditView->getCurrentDocLen();
3302  	intptr_t nbLine = _pEditView->execute(SCI_GETLINECOUNT);
3303  	wsprintf(strDocLen, TEXT("length : %s    lines : %s"),
3304  		commafyInt(docLen).c_str(),
3305  		commafyInt(nbLine).c_str());
3306  	_statusBar.setText(strDocLen, STATUSBAR_DOC_SIZE);
3307  	TCHAR strSel[64];
3308  	size_t numSelections = _pEditView->execute(SCI_GETSELECTIONS);
3309  	if (numSelections == 1)
3310  	{
3311  		if (_pEditView->execute(SCI_GETSELECTIONEMPTY))
3312  		{
3313  			size_t currPos = _pEditView->execute(SCI_GETCURRENTPOS);
3314  			wsprintf(strSel, TEXT("Pos : %s"), commafyInt(currPos + 1).c_str());
3315  		}
3316  		else
3317  		{
3318  			const std::pair<size_t, size_t> oneSelCharsAndLines = _pEditView->getSelectedCharsAndLinesCount();
3319  			wsprintf(strSel, TEXT("Sel : %s | %s"),
3320  				commafyInt(oneSelCharsAndLines.first).c_str(),
3321  				commafyInt(oneSelCharsAndLines.second).c_str());
3322  		}
3323  	}
3324  	else if (_pEditView->execute(SCI_SELECTIONISRECTANGLE))
3325  	{
3326  		const std::pair<size_t, size_t> rectSelCharsAndLines = _pEditView->getSelectedCharsAndLinesCount();
3327  		bool sameCharCountOnEveryLine = true;
3328  		size_t maxLineCharCount = 0;
3329  		for (size_t sel = 0; sel < numSelections; ++sel)
3330  		{
3331  			size_t start = _pEditView->execute(SCI_GETSELECTIONNSTART, sel);
3332  			size_t end = _pEditView->execute(SCI_GETSELECTIONNEND, sel);
3333  			size_t lineCharCount = _pEditView->execute(SCI_COUNTCHARACTERS, start, end);
3334  			if (sel == 0)
3335  			{
3336  				maxLineCharCount = lineCharCount;
3337  			}
3338  			else 
3339  			{
3340  				if (lineCharCount != maxLineCharCount)
3341  				{
3342  					sameCharCountOnEveryLine = false;
3343  					if (lineCharCount > maxLineCharCount)
3344  					{
3345  						maxLineCharCount = lineCharCount;
3346  					}
3347  				}
3348  			}
3349  		}
3350  		wsprintf(strSel, TEXT("Sel : %sx%s %s %s"),
3351  			commafyInt(numSelections).c_str(),  
3352  			commafyInt(maxLineCharCount).c_str(),  
3353  			sameCharCountOnEveryLine ? TEXT("=") : TEXT("->"),
3354  			commafyInt(rectSelCharsAndLines.first).c_str());
3355  	}
3356  	else  
3357  	{
3358  		const int maxSelsToProcessLineCount = 99;  
3359  		const std::pair<size_t, size_t> multipleSelCharsAndLines = _pEditView->getSelectedCharsAndLinesCount(maxSelsToProcessLineCount);
3360  		wsprintf(strSel, TEXT("Sel %s : %s | %s"),
3361  			commafyInt(numSelections).c_str(),
3362  			commafyInt(multipleSelCharsAndLines.first).c_str(),
3363  			numSelections <= maxSelsToProcessLineCount ?
3364  				commafyInt(multipleSelCharsAndLines.second).c_str() :
3365  				TEXT("..."));  
3366  	}
3367  	TCHAR strLnColSel[128];
3368  	intptr_t curLN = _pEditView->getCurrentLineNumber();
3369  	intptr_t curCN = _pEditView->getCurrentColumnNumber();
3370  	wsprintf(strLnColSel, TEXT("Ln : %s    Col : %s    %s"),
3371  		commafyInt(curLN + 1).c_str(),
3372  		commafyInt(curCN + 1).c_str(),
3373  		strSel);
3374  	_statusBar.setText(strLnColSel, STATUSBAR_CUR_POS);
3375  	_statusBar.setText(_pEditView->execute(SCI_GETOVERTYPE) ? TEXT("OVR") : TEXT("INS"), STATUSBAR_TYPING_MODE);
3376  	if (_goToLineDlg.isCreated() && _goToLineDlg.isVisible())
3377  	{
3378  		_goToLineDlg.updateLinesNumbers();
3379  	}
3380  }
3381  void Notepad_plus::dropFiles(HDROP hdrop)
3382  {
3383  	if (hdrop)
3384  	{
3385  		POINT p;
3386  		::DragQueryPoint(hdrop, &p);
3387  		HWND hWin = ::ChildWindowFromPointEx(_pPublicInterface->getHSelf(), p, CWP_SKIPINVISIBLE);
3388  		if (!hWin) return;
3389  		if ((_subEditView.getHSelf() == hWin) || (_subDocTab.getHSelf() == hWin))
3390  			switchEditViewTo(SUB_VIEW);
3391  		else
3392  			switchEditViewTo(MAIN_VIEW);
3393  		int filesDropped = ::DragQueryFile(hdrop, 0xffffffff, NULL, 0);
3394  		vector<generic_string> folderPaths;
3395  		vector<generic_string> filePaths;
3396  		for (int i = 0; i < filesDropped; ++i)
3397  		{
3398  			TCHAR pathDropped[MAX_PATH];
3399  			::DragQueryFile(hdrop, i, pathDropped, MAX_PATH);
3400  			if (::PathIsDirectory(pathDropped))
3401  			{
3402  				size_t len = lstrlen(pathDropped);
3403  				if (len > 0 && pathDropped[len - 1] != TCHAR('\\'))
3404  				{
3405  					pathDropped[len] = TCHAR('\\');
3406  					pathDropped[len + 1] = TCHAR('\0');
3407  				}
3408  				folderPaths.push_back(pathDropped);
3409  			}
3410  			else
3411  			{
3412  				filePaths.push_back(pathDropped);
3413  			}
3414  		}
3415  		NppParameters& nppParam = NppParameters::getInstance();
3416  		bool isOldMode = nppParam.getNppGUI()._isFolderDroppedOpenFiles;
3417  		if (isOldMode || folderPaths.size() == 0) 
3418  		{
3419  			BufferID lastOpened = BUFFER_INVALID;
3420  			for (int i = 0; i < filesDropped; ++i)
3421  			{
3422  				TCHAR pathDropped[MAX_PATH];
3423  				::DragQueryFile(hdrop, i, pathDropped, MAX_PATH);
3424  				BufferID test = doOpen(pathDropped);
3425  				if (test != BUFFER_INVALID)
3426  					lastOpened = test;
3427  			}
3428  			if (lastOpened != BUFFER_INVALID)
3429  			{
3430  				switchToFile(lastOpened);
3431  			}
3432  		}
3433  		else if (!isOldMode && (folderPaths.size() != 0 && filePaths.size() != 0)) 
3434  		{
3435  			_nativeLangSpeaker.messageBox("DroppingFolderAsProjectModeWarning",
3436  				_pPublicInterface->getHSelf(),
3437  				TEXT("You can only drop files or folders but not both, because you're in dropping Folder as Project mode.\ryou have to enable \"Open all files of folder instead of launching Folder as Workspace on folder dropping\" in \"Default Directory\" section of Preferences dialog to make this operation work."),
3438  				TEXT("Invalid action"),
3439  				MB_OK | MB_APPLMODAL);
3440  		}
3441  		else if (!isOldMode && (folderPaths.size() != 0 && filePaths.size() == 0)) 
3442  		{
3443  			generic_string emptyStr;
3444  			launchFileBrowser(folderPaths, emptyStr);
3445  		}
3446  		::DragFinish(hdrop);
3447  		if (::IsIconic(_pPublicInterface->getHSelf()))
3448  		{
3449  			::ShowWindow(_pPublicInterface->getHSelf(), SW_RESTORE);
3450  		}
3451  		::SetForegroundWindow(_pPublicInterface->getHSelf());
3452  	}
3453  }
3454  void Notepad_plus::checkModifiedDocument(bool bCheckOnlyCurrentBuffer)
3455  {
3456  	MainFileManager.checkFilesystemChanges(bCheckOnlyCurrentBuffer);
3457  }
3458  void Notepad_plus::getMainClientRect(RECT &rc) const
3459  {
3460      _pPublicInterface->getClientRect(rc);
3461  	rc.top += _rebarTop.getHeight();
3462  	rc.bottom -= rc.top + _rebarBottom.getHeight() + _statusBar.getHeight();
3463  }
3464  void Notepad_plus::showView(int whichOne)
3465  {
3466  	if (viewVisible(whichOne))	
3467  		return;
3468  	if (_mainWindowStatus & WindowUserActive)
3469  	{
3470  		 _pMainSplitter->setWin0(&_subSplitter);
3471  		 _pMainWindow = _pMainSplitter;
3472  	}
3473  	else
3474  	{
3475  		_pMainWindow = &_subSplitter;
3476  	}
3477  	if (whichOne == MAIN_VIEW)
3478  	{
3479  		_mainEditView.display(true);
3480  		_mainDocTab.display(true);
3481  	}
3482  	else if (whichOne == SUB_VIEW)
3483  	{
3484  		_subEditView.display(true);
3485  		_subDocTab.display(true);
3486  	}
3487  	_pMainWindow->display(true);
3488  	_mainWindowStatus |= (whichOne==MAIN_VIEW)?WindowMainActive:WindowSubActive;
3489  	::SendMessage(_pPublicInterface->getHSelf(), WM_SIZE, 0, 0);
3490  }
3491  bool Notepad_plus::viewVisible(int whichOne)
3492  {
3493  	int viewToCheck = (whichOne == SUB_VIEW?WindowSubActive:WindowMainActive);
3494  	return (_mainWindowStatus & viewToCheck) != 0;
3495  }
3496  void Notepad_plus::hideCurrentView()
3497  {
3498  	hideView(currentView());
3499  }
3500  void Notepad_plus::hideView(int whichOne)
3501  {
3502  	if (!(bothActive()))	
3503  		return;
3504  	Window * windowToSet = (whichOne == MAIN_VIEW)?&_subDocTab:&_mainDocTab;
3505  	if ((_mainWindowStatus & WindowUserActive) == WindowUserActive)
3506  	{
3507  		_pMainSplitter->setWin0(windowToSet);
3508  	}
3509  	else
3510  	{
3511  		_pMainWindow = windowToSet;
3512  	}
3513  	_subSplitter.display(false);	
3514  	if (whichOne == MAIN_VIEW)
3515  	{
3516  		_mainEditView.display(false);
3517  		_mainDocTab.display(false);
3518  	}
3519  	else if (whichOne == SUB_VIEW)
3520  	{
3521  		_subEditView.display(false);
3522  		_subDocTab.display(false);
3523  	}
3524  	::SendMessage(_pPublicInterface->getHSelf(), WM_SIZE, 0, 0);
3525  	switchEditViewTo(otherFromView(whichOne));
3526  	auto viewToDisable = static_cast<UCHAR>(whichOne == SUB_VIEW ? WindowSubActive : WindowMainActive);
3527  	_mainWindowStatus &= ~viewToDisable;
3528  }
3529  bool Notepad_plus::loadStyles()
3530  {
3531  	NppParameters& nppParam = NppParameters::getInstance();
3532  	return nppParam.reloadStylers();
3533  }
3534  bool Notepad_plus::canHideView(int whichOne)
3535  {
3536  	if (!viewVisible(whichOne))
3537  		return false;	
3538  	if (!bothActive())
3539  		return false;	
3540  	DocTabView * tabToCheck = (whichOne == MAIN_VIEW)?&_mainDocTab:&_subDocTab;
<span onclick='openModal()' class='match'>3541  	Buffer * buf = MainFileManager.getBufferByID(tabToCheck->getBufferByIndex(0));
3542  	bool canHide = ((tabToCheck->nbItem() == 1) && !buf->isDirty() && buf->isUntitled());
3543  	return canHide;
3544  }
3545  bool Notepad_plus::isEmpty()
</span>3546  {
3547  	if (bothActive()) return false;
3548  	DocTabView * tabToCheck = (_mainWindowStatus & WindowMainActive) ? &_mainDocTab : &_subDocTab;
3549  	Buffer * buf = MainFileManager.getBufferByID(tabToCheck->getBufferByIndex(0));
3550  	bool isEmpty = ((tabToCheck->nbItem() == 1) && !buf->isDirty() && buf->isUntitled());
3551  	return isEmpty;
3552  }
3553  void Notepad_plus::loadBufferIntoView(BufferID id, int whichOne, bool dontClose)
3554  {
3555  	DocTabView * tabToOpen = (whichOne == MAIN_VIEW)?&_mainDocTab:&_subDocTab;
3556  	ScintillaEditView * viewToOpen = (whichOne == MAIN_VIEW)?&_mainEditView:&_subEditView;
3557  	int index = tabToOpen->getIndexByBuffer(id);
3558  	if (index != -1)	
3559  		return;
3560  	BufferID idToClose = BUFFER_INVALID;
3561  	if (!dontClose && tabToOpen->nbItem() == 1)
3562  	{
3563  		idToClose = tabToOpen->getBufferByIndex(0);
3564  		Buffer * buf = MainFileManager.getBufferByID(idToClose);
3565  		if (buf->isDirty() || !buf->isUntitled())
3566  		{
3567  			idToClose = BUFFER_INVALID;
3568  		}
3569  	}
3570  	MainFileManager.addBufferReference(id, viewToOpen);
3571  	if (idToClose != BUFFER_INVALID)
3572  	{
3573  		tabToOpen->setBuffer(0, id);	
3574  		activateBuffer(id, whichOne);	
3575  		MainFileManager.closeBuffer(idToClose, viewToOpen);	
3576  		if (_pDocumentListPanel)
3577  			_pDocumentListPanel->closeItem(idToClose, whichOne);
3578  	}
3579  	else
3580  	{
3581  		tabToOpen->addBuffer(id);
3582  	}
3583  }
3584  bool Notepad_plus::removeBufferFromView(BufferID id, int whichOne)
3585  {
3586  	DocTabView * tabToClose = (whichOne == MAIN_VIEW) ? &_mainDocTab : &_subDocTab;
3587  	ScintillaEditView * viewToClose = (whichOne == MAIN_VIEW) ? &_mainEditView : &_subEditView;
3588  	int index = tabToClose->getIndexByBuffer(id);
3589  	if (index == -1)        
3590  		return false;
3591  	Buffer * buf = MainFileManager.getBufferByID(id);
3592  	if (tabToClose->nbItem() == 1)
3593  	{
3594  		if (!buf->isDirty() && buf->isUntitled())
3595  		{
3596  			return false;
3597  		}
3598  	}
3599  	int active = tabToClose->getCurrentTabIndex();
3600  	if (active == index) 
3601  	{
3602  		if (tabToClose->nbItem() == 1)  
3603  		{
3604  			BufferID newID = MainFileManager.newEmptyDocument();
3605  			MainFileManager.addBufferReference(newID, viewToClose);
3606  			tabToClose->setBuffer(0, newID);        
3607  			activateBuffer(newID, whichOne);        
3608  		}
3609  		else
3610  		{
3611  			int toActivate = 0;
3612  			if (size_t(active) == tabToClose->nbItem() - 1) 
3613  			{
3614  				toActivate = active - 1;
3615  			}
3616  			else
3617  			{
3618  				toActivate = active;    
3619  			}
3620  			if (NppParameters::getInstance().getNppGUI()._styleMRU)
3621  			{
3622  				TaskListInfo taskListInfo;
3623  				::SendMessage(_pPublicInterface->getHSelf(), WM_GETTASKLISTINFO, reinterpret_cast<WPARAM>(&taskListInfo), 0);
3624  				size_t i, n = taskListInfo._tlfsLst.size();
3625  				for (i = 0; i < n; i++)
3626  				{
3627  					TaskLstFnStatus& tfs = taskListInfo._tlfsLst[i];
3628  					if (tfs._iView != whichOne || tfs._bufID == id)
3629  						continue;
3630  					toActivate = tfs._docIndex >= active ? tfs._docIndex - 1 : tfs._docIndex;
3631  					break;
3632  				}
3633  			}
3634  			tabToClose->deletItemAt((size_t)index); 
3635  			_isFolding = true; 
3636  			activateBuffer(tabToClose->getBufferByIndex(toActivate), whichOne);     
3637  			_isFolding = false;
3638  		}
3639  	}
3640  	else
3641  	{
3642  		tabToClose->deletItemAt((size_t)index);
3643  	}
3644  	MainFileManager.closeBuffer(id, viewToClose);
3645  	return true;
3646  }
3647  int Notepad_plus::switchEditViewTo(int gid)
3648  {
3649  	if (currentView() == gid)
3650  	{
3651  		_pEditView->getFocus();	
3652  		return gid;
3653  	}
3654  	if (!viewVisible(gid))
3655  		return currentView();	
3656  	int oldView = currentView();
3657  	int newView = otherView();
3658  	_activeView = newView;
3659  	std::swap(_pDocTab, _pNonDocTab);
3660  	std::swap(_pEditView, _pNonEditView);
3661  	_pEditView->beSwitched();
3662      _pEditView->getFocus();	
3663  	if (_pDocMap)
3664  	{
3665  		_pDocMap->initWrapMap();
3666  	}
3667  	if (NppParameters::getInstance().getNppGUI().isSnapshotMode())
3668  	{
3669  		MainFileManager.backupCurrentBuffer();
3670  	}
3671  	notifyBufferActivated(_pEditView->getCurrentBufferID(), currentView());
3672  	return oldView;
3673  }
3674  void Notepad_plus::dockUserDlg()
3675  {
3676      if (!_pMainSplitter)
3677      {
3678          _pMainSplitter = new SplitterContainer;
3679  		_pMainSplitter->init(_pPublicInterface->getHinst(), _pPublicInterface->getHSelf());
3680          Window *pWindow;
3681  		if (_mainWindowStatus & (WindowMainActive | WindowSubActive))
3682              pWindow = &_subSplitter;
3683          else
3684              pWindow = _pDocTab;
3685  		int splitterSizeDyn = NppParameters::getInstance()._dpiManager.scaleX(splitterSize);
3686          _pMainSplitter->create(pWindow, ScintillaEditView::getUserDefineDlg(), splitterSizeDyn, SplitterMode::RIGHT_FIX, 45);
3687      }
3688      if (bothActive())
3689          _pMainSplitter->setWin0(&_subSplitter);
3690      else
3691          _pMainSplitter->setWin0(_pDocTab);
3692      _pMainSplitter->display();
3693      _mainWindowStatus |= WindowUserActive;
3694      _pMainWindow = _pMainSplitter;
3695  	::SendMessage(_pPublicInterface->getHSelf(), WM_SIZE, 0, 0);
3696  }
3697  void Notepad_plus::undockUserDlg()
3698  {
3699      ::ShowWindow(_pMainSplitter->getHSelf(), SW_HIDE);
3700      if (bothActive())
3701          _pMainWindow = &_subSplitter;
3702      else
3703          _pMainWindow = _pDocTab;
3704      ::SendMessage(_pPublicInterface->getHSelf(), WM_SIZE, 0, 0);
3705      _mainWindowStatus &= ~WindowUserActive;
3706      (ScintillaEditView::getUserDefineDlg())->display();
3707  }
3708  void Notepad_plus::docOpenInNewInstance(FileTransferMode mode, int x, int y)
3709  {
3710  	BufferID bufferID = _pEditView->getCurrentBufferID();
3711  	Buffer * buf = MainFileManager.getBufferByID(bufferID);
3712  	if (buf->isUntitled() || buf->isDirty())
3713  		return;
3714  	TCHAR nppName[MAX_PATH];
3715  	::GetModuleFileName(NULL, nppName, MAX_PATH);
3716  	generic_string command = TEXT("\"");
3717  	command += nppName;
3718  	command += TEXT("\"");
3719  	command += TEXT(" \"$(FULL_CURRENT_PATH)\" -multiInst -nosession");
3720  	if (x)
3721  	{
3722  		TCHAR pX[10]{};
3723  		_itow(x, pX, 10);
3724  		command += TEXT(" -x");
3725  		command += pX;
3726  	}
3727  	if (y)
3728  	{
3729  		TCHAR pY[10]{};
3730  		_itow(y, pY, 10);
3731  		command += TEXT(" -y");
3732  		command += pY;
3733  	}
3734  	LangType lt = buf->getLangType();
3735  	if (lt != L_USER)
3736  	{
3737  		command += TEXT(" -l");
3738  		command += ScintillaEditView::_langNameInfoArray[lt]._langName;
3739  	}
3740  	command += TEXT(" -n");
3741  	command += to_wstring(_pEditView->getCurrentLineNumber() + 1);
3742  	command += TEXT(" -c");
3743  	command += to_wstring(_pEditView->getCurrentColumnNumber() + 1);
3744  	Command cmd(command);
3745  	cmd.run(_pPublicInterface->getHSelf());
3746  	if (mode == TransferMove)
3747  	{
3748  		doClose(bufferID, currentView());
3749  		if (noOpenedDoc())
3750  			::SendMessage(_pPublicInterface->getHSelf(), WM_CLOSE, 0, 0);
3751  	}
3752  }
3753  void Notepad_plus::docGotoAnotherEditView(FileTransferMode mode)
3754  {
3755  	if (mode == TransferMove)
3756  	{
3757  		if (_pDocTab->nbItem() == 1)
3758  		{
3759  			ScintillaEditView *pOtherView = NULL;
3760  			if (_pEditView == &_mainEditView)
3761  			{
3762  				pOtherView = &_subEditView;
3763  			}
3764  			else if (_pEditView == &_subEditView)
3765  			{
3766  				pOtherView = &_mainEditView;
3767  			}
3768  			else
3769  				return;
3770  			if (!pOtherView->isVisible())
3771  				return;
3772  		}
3773  	}
3774  	BufferID current = _pEditView->getCurrentBufferID();
3775  	int viewToGo = otherView();
3776  	int indexFound = _pNonDocTab->getIndexByBuffer(current);
3777  	if (indexFound != -1)	
3778  	{
3779  		activateBuffer(current, otherView());
3780  	}
3781  	else	
3782  	{
3783  		if (_pEditView->isVisible() && _pNonEditView->isVisible())
3784  		{
3785  			_pNonEditView->saveCurrentPos();
3786  		}
3787  		loadBufferIntoView(current, viewToGo);
3788  		Buffer *buf = MainFileManager.getBufferByID(current);
3789  		_pEditView->saveCurrentPos();	
3790  		buf->setPosition(buf->getPosition(_pEditView), _pNonEditView);
3791  		_pNonEditView->restoreCurrentPosPreStep();	
3792  		activateBuffer(current, viewToGo);
3793  	}
3794  	int viewToOpen = (viewToGo == SUB_VIEW?WindowSubActive:WindowMainActive);
3795  	if (!(_mainWindowStatus & viewToOpen))
3796  	{
3797  		showView(viewToGo);
3798  	}
3799  	bool monitoringWasOn = false;
3800  	if (mode == TransferMove)
3801  	{
3802  		Buffer *buf = MainFileManager.getBufferByID(current);
3803  		monitoringWasOn = buf->isMonitoringOn();
3804  		doClose(_pEditView->getCurrentBufferID(), currentView());
3805  	} 
3806  	switchEditViewTo(viewToGo);
3807  	if (monitoringWasOn)
3808  	{
3809  		command(IDM_VIEW_MONITORING);
3810  	}
3811  	if (_pDocumentListPanel != nullptr)
3812  	{
3813  		Buffer* buf = MainFileManager.getBufferByID(current);
3814  		_pDocumentListPanel->setItemColor(buf);
3815  	}
3816  }
3817  bool Notepad_plus::activateBuffer(BufferID id, int whichOne, bool forceApplyHilite)
3818  {
3819  	NppGUI& nppGui = NppParameters::getInstance().getNppGUI();
3820  	bool isSnapshotMode = nppGui.isSnapshotMode();
3821  	if (isSnapshotMode)
3822  	{
3823  		MainFileManager.backupCurrentBuffer();
3824  	}
3825  	Buffer * pBuf = MainFileManager.getBufferByID(id);
3826  	bool reload = pBuf->getNeedReload();
3827  	if (reload)
3828  	{
3829  		MainFileManager.reloadBuffer(id);
3830  		pBuf->setNeedReload(false);
3831  	}
3832  	if (whichOne == MAIN_VIEW)
3833  	{
3834  		if (_mainDocTab.activateBuffer(id))	
3835  		{
3836  			_isFolding = true;
3837  			_mainEditView.activateBuffer(id, forceApplyHilite);
3838  			_isFolding = false;
3839  		}
3840  		else
3841  			return false;
3842  	}
3843  	else
3844  	{
3845  		if (_subDocTab.activateBuffer(id))
3846  		{
3847  			_isFolding = true;
3848  			_subEditView.activateBuffer(id, forceApplyHilite);
3849  			_isFolding = false;
3850  		}
3851  		else
3852  			return false;
3853  	}
3854  	if (reload)
3855  	{
3856  		performPostReload(whichOne);
3857  	}
3858  	notifyBufferActivated(id, whichOne);
3859  	bool isCurrBuffDetection = (nppGui._fileAutoDetection & cdEnabledNew) ? true : false;
3860  	if (!reload && isCurrBuffDetection)
3861  	{
3862  		pBuf->checkFileState();
3863  	}
3864  	return true;
3865  }
3866  void Notepad_plus::performPostReload(int whichOne)
3867  {
3868  	NppParameters& nppParam = NppParameters::getInstance();
3869  	const NppGUI & nppGUI = nppParam.getNppGUI();
3870  	bool toEnd = (nppGUI._fileAutoDetection & cdGo2end) ? true : false;
3871  	if (!toEnd)
3872  		return;
3873  	if (whichOne == MAIN_VIEW)
3874  	{
3875  		_mainEditView.setPositionRestoreNeeded(false);
3876  		_mainEditView.execute(SCI_DOCUMENTEND);
3877  	}
3878  	else
3879  	{
3880  		_subEditView.setPositionRestoreNeeded(false);
3881  		_subEditView.execute(SCI_DOCUMENTEND);
3882  	}
3883  }
3884  void Notepad_plus::bookmarkNext(bool forwardScan)
3885  {
3886  	size_t lineno = _pEditView->getCurrentLineNumber();
3887  	int sci_marker = SCI_MARKERNEXT;
3888  	size_t lineStart = lineno + 1;	
3889  	intptr_t lineRetry = 0;				
3890  	if (!forwardScan)
3891      {
3892  		lineStart = lineno - 1;		
3893  		lineRetry = _pEditView->execute(SCI_GETLINECOUNT);	
3894  		sci_marker = SCI_MARKERPREVIOUS;
3895  	}
3896  	intptr_t nextLine = _pEditView->execute(sci_marker, lineStart, static_cast<LPARAM>(1 << MARK_BOOKMARK));
3897  	if (nextLine < 0)
3898  		nextLine = _pEditView->execute(sci_marker, lineRetry, static_cast<LPARAM>(1 << MARK_BOOKMARK));
3899  	if (nextLine < 0)
3900  		return;
3901      _pEditView->execute(SCI_ENSUREVISIBLEENFORCEPOLICY, nextLine);
3902  	_pEditView->execute(SCI_GOTOLINE, nextLine);
3903  }
3904  void Notepad_plus::staticCheckMenuAndTB() const
3905  {
3906  	const bool wsTabShow = _pEditView->isShownSpaceAndTab();
3907  	const bool eolShow = _pEditView->isShownEol();
3908  	const bool npcShow = _pEditView->isShownNpc();
3909  	const bool ccUniEolShow = _pEditView->isShownCcUniEol();
3910  	const bool allShow = wsTabShow && eolShow && npcShow && ccUniEolShow;
3911  	checkMenuItem(IDM_VIEW_TAB_SPACE, wsTabShow);
3912  	checkMenuItem(IDM_VIEW_EOL, eolShow);
3913  	checkMenuItem(IDM_VIEW_NPC, npcShow);
3914  	checkMenuItem(IDM_VIEW_NPC_CCUNIEOL, ccUniEolShow);
3915  	checkMenuItem(IDM_VIEW_ALL_CHARACTERS, allShow);
3916  	_toolBar.setCheck(IDM_VIEW_ALL_CHARACTERS, allShow);
3917  	bool b = _pEditView->isShownIndentGuide();
3918  	checkMenuItem(IDM_VIEW_INDENT_GUIDE, b);
3919  	_toolBar.setCheck(IDM_VIEW_INDENT_GUIDE, b);
3920  	b = _pEditView->isWrap();
3921  	checkMenuItem(IDM_VIEW_WRAP, b);
3922  	_toolBar.setCheck(IDM_VIEW_WRAP, b);
3923  	checkMenuItem(IDM_VIEW_WRAP_SYMBOL, _pEditView->isWrapSymbolVisible());
3924  }
3925  void Notepad_plus::dynamicCheckMenuAndTB() const
3926  {
3927  	enableConvertMenuItems(_pEditView->getCurrentBuffer()->getEolFormat());
3928  	checkUnicodeMenuItems();
3929  }
3930  void Notepad_plus::enableConvertMenuItems(EolType format) const
3931  {
3932  	enableCommand(IDM_FORMAT_TODOS, (format != EolType::windows), MENU);
3933  	enableCommand(IDM_FORMAT_TOUNIX, (format != EolType::unix), MENU);
3934  	enableCommand(IDM_FORMAT_TOMAC, (format != EolType::macos), MENU);
3935  }
3936  void Notepad_plus::checkUnicodeMenuItems() const
3937  {
3938  	Buffer *buf = _pEditView->getCurrentBuffer();
3939  	UniMode um = buf->getUnicodeMode();
3940  	int encoding = buf->getEncoding();
3941  	int id = -1;
3942  	switch (um)
3943  	{
3944  		case uniUTF8   : id = IDM_FORMAT_UTF_8; break;
3945  		case uni16BE   : id = IDM_FORMAT_UTF_16BE; break;
3946  		case uni16LE   : id = IDM_FORMAT_UTF_16LE; break;
3947  		case uniCookie : id = IDM_FORMAT_AS_UTF_8; break;
3948  		case uni8Bit   : id = IDM_FORMAT_ANSI; break;
3949  		case uni7Bit:
3950  		case uni16BE_NoBOM:
3951  		case uni16LE_NoBOM:
3952  		case uniEnd:
3953  		default:
3954  			break;
3955  	}
3956  	if (encoding == -1)
3957  	{
3958          HMENU _formatMenuHandle = ::GetSubMenu(_mainMenuHandle, MENUINDEX_FORMAT);
3959          doCheck(_formatMenuHandle, -1);
3960  		if (id == -1) 
3961  		{
3962  			::CheckMenuRadioItem(_mainMenuHandle, IDM_FORMAT_ANSI, IDM_FORMAT_AS_UTF_8, IDM_FORMAT_ANSI, MF_BYCOMMAND);
3963  			::CheckMenuItem(_mainMenuHandle, IDM_FORMAT_ANSI, MF_UNCHECKED | MF_BYCOMMAND);
3964  		}
3965  		else
3966  		{
3967  			::CheckMenuRadioItem(_mainMenuHandle, IDM_FORMAT_ANSI, IDM_FORMAT_AS_UTF_8, id, MF_BYCOMMAND);
3968  		}
3969  	}
3970  	else
3971  	{
3972  		EncodingMapper& em = EncodingMapper::getInstance();
3973  		int cmdID = em.getIndexFromEncoding(encoding);
3974  		if (cmdID == -1)
3975  		{
3976  			return;
3977  		}
3978  		cmdID += IDM_FORMAT_ENCODE;
3979  		::CheckMenuRadioItem(_mainMenuHandle, IDM_FORMAT_ANSI, IDM_FORMAT_AS_UTF_8, IDM_FORMAT_ANSI, MF_BYCOMMAND);
3980  		::CheckMenuItem(_mainMenuHandle, IDM_FORMAT_ANSI, MF_UNCHECKED | MF_BYCOMMAND);
3981          HMENU _formatMenuHandle = ::GetSubMenu(_mainMenuHandle, MENUINDEX_FORMAT);
3982          doCheck(_formatMenuHandle, cmdID);
3983  	}
3984  }
3985  void Notepad_plus::showAutoComp()
3986  {
3987  	bool isFromPrimary = _pEditView == &_mainEditView;
3988  	AutoCompletion * autoC = isFromPrimary?&_autoCompleteMain:&_autoCompleteSub;
3989  	autoC->showApiComplete();
3990  }
3991  void Notepad_plus::showPathCompletion()
3992  {
3993  	bool isFromPrimary = _pEditView == &_mainEditView;
3994  	AutoCompletion * autoC = isFromPrimary?&_autoCompleteMain:&_autoCompleteSub;
3995  	autoC->showPathCompletion();
3996  }
3997  void Notepad_plus::autoCompFromCurrentFile(bool autoInsert)
3998  {
3999  	bool isFromPrimary = _pEditView == &_mainEditView;
4000  	AutoCompletion * autoC = isFromPrimary?&_autoCompleteMain:&_autoCompleteSub;
4001  	autoC->showWordComplete(autoInsert);
4002  }
4003  void Notepad_plus::showFunctionComp()
4004  {
4005  	bool isFromPrimary = _pEditView == &_mainEditView;
4006  	AutoCompletion * autoC = isFromPrimary?&_autoCompleteMain:&_autoCompleteSub;
4007  	autoC->showFunctionComplete();
4008  }
4009  void Notepad_plus::showFunctionNextHint(bool isNext)
4010  {
4011  	bool isFromPrimary = _pEditView == &_mainEditView;
4012  	AutoCompletion* autoC = isFromPrimary ? &_autoCompleteMain : &_autoCompleteSub;
4013  	if (isNext)
4014  		autoC->callTipClick(2);
4015  	else
4016  		autoC->callTipClick(1);
4017  }
4018  static generic_string extractSymbol(TCHAR firstChar, TCHAR secondChar, const TCHAR *str2extract)
4019  {
4020  	bool found = false;
4021  	const size_t extractedLen = 128;
4022  	TCHAR extracted[extractedLen] = {'\0'};
4023  	for (size_t i = 0, j = 0, len = lstrlen(str2extract) ; i < len && j < extractedLen - 1; ++i)
4024  	{
4025  		if (found)
4026  		{
4027  			if (!str2extract[i] || str2extract[i] == ' ')
4028  			{
4029  				extracted[j] = '\0';
4030  				return generic_string(extracted);
4031  			}
4032  			extracted[j++] = str2extract[i];
4033  		}
4034  		else
4035  		{
4036  			if (!str2extract[i])
4037  				return TEXT("");
4038  			if (str2extract[i] == firstChar && str2extract[i+1] == secondChar)
4039  			{
4040  				found = true;
4041  				++i;
4042  			}
4043  		}
4044  	}
4045  	return  generic_string(extracted);
4046  }
4047  bool Notepad_plus::doBlockComment(comment_mode currCommentMode)
4048  {
4049  	Buffer * buf = _pEditView->getCurrentBuffer();
4050  	if (buf->isReadOnly())
4051  		return false;
4052  	const TCHAR *commentStart;
4053  	const TCHAR *commentEnd;
4054  	generic_string symbolStart;
4055  	generic_string symbolEnd;
4056  	const TCHAR *commentLineSymbol;
4057  	generic_string symbol;
4058  	bool isSingleLineAdvancedMode = false;
4059  	if (buf->getLangType() == L_USER)
4060  	{
4061  		UserLangContainer * userLangContainer = NppParameters::getInstance().getULCFromName(buf->getUserDefineLangName());
4062  		if (!userLangContainer)
4063  			return false;
4064  		symbol = extractSymbol('0', '0', userLangContainer->_keywordLists[SCE_USER_KWLIST_COMMENTS]);
4065  		commentLineSymbol = symbol.c_str();
4066  		symbolStart = extractSymbol('0', '3', userLangContainer->_keywordLists[SCE_USER_KWLIST_COMMENTS]);
4067  		commentStart = symbolStart.c_str();
4068  		symbolEnd = extractSymbol('0', '4', userLangContainer->_keywordLists[SCE_USER_KWLIST_COMMENTS]);
4069  		commentEnd = symbolEnd.c_str();
4070  	}
4071  	else
4072  	{
4073  		commentLineSymbol = buf->getCommentLineSymbol();
4074  		commentStart = buf->getCommentStart();
4075  		commentEnd = buf->getCommentEnd();
4076  	}
4077  	if ((!commentLineSymbol) || (!commentLineSymbol[0]) || (commentLineSymbol == NULL))
4078  	{
4079  		if (!(!commentStart || !commentStart[0] || commentStart == NULL || !commentEnd || !commentEnd[0] || commentEnd == NULL))
4080  		{
4081  			if (currCommentMode == cm_comment)
4082  			{
4083  				isSingleLineAdvancedMode = true;
4084  			}
4085  			else if (currCommentMode == cm_uncomment)
4086  			{
4087  				return undoStreamComment(false);
4088  			}
4089  			else if (currCommentMode == cm_toggle)
4090  			{
4091  				isSingleLineAdvancedMode = true;
4092  			}
4093  			else
4094  				return false;
4095  		}
4096  		else
4097  			return false;
4098  	}
4099  	generic_string comment;
4100  	size_t comment_length = 0;
4101  	generic_string advCommentStart;
4102  	generic_string advCommentEnd;
4103  	size_t advCommentStart_length = 0;
4104  	size_t advCommentEnd_length = 0;
4105  	const TCHAR aSpace[] { TEXT(" ") };
4106  	if (!isSingleLineAdvancedMode)
4107  	{
4108  		comment = commentLineSymbol;
4109  		if (!(buf->getLangType() == L_BAANC)) 
4110  			comment += aSpace;
4111  		comment_length = comment.length();
4112  	}
4113  	else 
4114  	{
4115  		advCommentStart = commentStart;
4116  		advCommentStart += aSpace;
4117  		advCommentEnd = aSpace;
4118  		advCommentEnd += commentEnd;
4119  		advCommentStart_length = advCommentStart.length();
4120  		advCommentEnd_length = advCommentEnd.length();
4121  	}
4122      size_t selectionStart = _pEditView->execute(SCI_GETSELECTIONSTART);
4123      size_t selectionEnd = _pEditView->execute(SCI_GETSELECTIONEND);
4124      size_t caretPosition = _pEditView->execute(SCI_GETCURRENTPOS);
4125      bool move_caret = caretPosition < selectionEnd;
4126  	intptr_t selStartLine = _pEditView->execute(SCI_LINEFROMPOSITION, selectionStart);
4127  	intptr_t selEndLine = _pEditView->execute(SCI_LINEFROMPOSITION, selectionEnd);
4128  	intptr_t lines = selEndLine - selStartLine;
4129      if ((lines > 0) && (selectionEnd == static_cast<size_t>(_pEditView->execute(SCI_POSITIONFROMLINE, selEndLine))))
4130  		selEndLine--;
4131  	int nUncomments = 0;
4132  	const bool avoidIndent = (buf->getLangType() == L_FORTRAN_77 || buf->getLangType() == L_BAANC);
4133  	const bool commentEmptyLines = (buf->getLangType() == L_BAANC);
4134      _pEditView->execute(SCI_BEGINUNDOACTION);
4135      for (intptr_t i = selStartLine; i <= selEndLine; ++i)
4136  	{
4137  		size_t lineStart = _pEditView->execute(SCI_POSITIONFROMLINE, i);
4138  		size_t lineIndent = _pEditView->execute(SCI_GETLINEINDENTPOSITION, i);
4139  		size_t lineEnd = _pEditView->execute(SCI_GETLINEENDPOSITION, i);
4140  		if (lineIndent == lineEnd && !commentEmptyLines)
4141  			continue;
4142  		if (avoidIndent)
4143  			lineIndent = lineStart;
4144  		size_t linebufferSize = lineEnd - lineIndent + 1;
4145  		TCHAR* linebuf = new TCHAR[linebufferSize];
4146  		_pEditView->getGenericText(linebuf, linebufferSize, lineIndent, lineEnd);
4147          generic_string linebufStr = linebuf;
4148  		delete [] linebuf;
4149     		if (currCommentMode != cm_comment) 
4150  		{
4151  			if (!isSingleLineAdvancedMode)
4152  			{
4153  				if (wcsnicmp(linebufStr.c_str(), comment.c_str(), !(buf->getLangType() == L_BAANC) ? comment_length - 1 : comment_length) == 0)
4154  				{
4155  					size_t len = linebufStr[comment_length - 1] == aSpace[0] ? comment_length : !(buf->getLangType() == L_BAANC) ? comment_length - 1 : comment_length;
4156  					_pEditView->execute(SCI_SETSEL, lineIndent, lineIndent + len);
4157  					_pEditView->replaceSelWith("");
4158  					if (i == selStartLine) 
4159  					{
4160  						if (selectionStart > lineIndent + len)
4161  							selectionStart -= len;
4162  						else if (selectionStart > lineIndent)
4163  							selectionStart = lineIndent;
4164  					} 
4165  					if (i == selEndLine) 
4166  					{
4167  						if (selectionEnd > lineIndent + len)
4168  							selectionEnd -= len;
4169  						else if (selectionEnd > lineIndent)
4170  						{
4171  							selectionEnd = lineIndent;
4172  							if (lineIndent == lineStart && i != selStartLine)
4173  								++selectionEnd; 
4174  						}
4175  					} 
4176  					else 
4177  						selectionEnd -= len;
4178  					++nUncomments;
4179  					continue;
4180  				}
4181  			}
4182  			else 
4183  			{
4184  				if ((wcsnicmp(linebufStr.c_str(), advCommentStart.c_str(), advCommentStart_length - 1) == 0) &&
4185  					(wcsnicmp(linebufStr.substr(linebufStr.length() - advCommentEnd_length + 1, advCommentEnd_length - 1).c_str(), advCommentEnd.substr(1, advCommentEnd_length - 1).c_str(), advCommentEnd_length - 1) == 0))
4186  				{
4187  					size_t startLen = linebufStr[advCommentStart_length - 1] == aSpace[0] ? advCommentStart_length : advCommentStart_length - 1;
4188  					size_t endLen = linebufStr[linebufStr.length() - advCommentEnd_length] == aSpace[0] ? advCommentEnd_length : advCommentEnd_length - 1;
4189  					_pEditView->execute(SCI_SETSEL, lineIndent, lineIndent + startLen);
4190  					_pEditView->replaceSelWith("");
4191  					_pEditView->execute(SCI_SETSEL, lineEnd - startLen - endLen, lineEnd - startLen);
4192  					_pEditView->replaceSelWith("");
4193  					if (i == selStartLine) 
4194  					{
4195  						if (selectionStart > lineEnd - endLen)
4196  							selectionStart = lineEnd - startLen - endLen;
4197  						else if (selectionStart > lineIndent + startLen)
4198  							selectionStart -= startLen;
4199  						else if (selectionStart > lineIndent)
4200  							selectionStart = lineIndent;
4201  					} 
4202  					if (i == selEndLine) 
4203  					{
4204  						if (selectionEnd > lineEnd)
4205  							selectionEnd -= (startLen + endLen);
4206  						else if (selectionEnd > lineEnd - endLen)
4207  							selectionEnd = lineEnd - startLen - endLen;
4208  						else if (selectionEnd > lineIndent + startLen)
4209  							selectionEnd -= startLen;
4210  						else if (selectionEnd > lineIndent)
4211  						{
4212  							selectionEnd = lineIndent;
4213  							if (lineIndent == lineStart && i != selStartLine)
4214  								++selectionEnd; 
4215  						}
4216  					} 
4217  					else 
4218  						selectionEnd -= (startLen + endLen);
4219  					++nUncomments;
4220  					continue;
4221  				}
4222  			}
4223  		} 
4224  		if (currCommentMode != cm_uncomment) 
4225  		{
4226  			if (!isSingleLineAdvancedMode)
4227  			{
4228  				_pEditView->insertGenericTextFrom(lineIndent, comment.c_str());
4229  				if (i == selStartLine) 
4230  				{
4231  					if (selectionStart >= lineIndent)
4232  						selectionStart += comment_length;
4233  				} 
4234  				if (i == selEndLine) 
4235  				{
4236  					if (selectionEnd >= lineIndent)
4237  						selectionEnd += comment_length;
4238  				} 
4239  				else 
4240  					selectionEnd += comment_length;
4241  			}
4242  			else 
4243  			{
4244  				_pEditView->insertGenericTextFrom(lineIndent, advCommentStart.c_str());
4245  				_pEditView->insertGenericTextFrom(lineEnd + advCommentStart_length, advCommentEnd.c_str());
4246  				if (i == selStartLine) 
4247  				{
4248  					if (selectionStart >= lineIndent)
4249  						selectionStart += advCommentStart_length;
4250  				} 
4251  				if (i == selEndLine) 
4252  				{
4253  					if (selectionEnd > lineEnd)
4254  						selectionEnd += (advCommentStart_length + advCommentEnd_length);
4255  					else if (selectionEnd >= lineIndent)
4256  						selectionEnd += advCommentStart_length;
4257  				} 
4258  				else 
4259  					selectionEnd += (advCommentStart_length + advCommentEnd_length);
4260  			}
4261  		} 
4262  	} 
4263      if (move_caret)
4264  	{
4265          _pEditView->execute(SCI_GOTOPOS, selectionEnd);
4266          _pEditView->execute(SCI_SETCURRENTPOS, selectionStart);
4267      }
4268  	else
4269  	{
4270          _pEditView->execute(SCI_SETSEL, selectionStart, selectionEnd);
4271      }
4272      _pEditView->execute(SCI_ENDUNDOACTION);
4273  	if ((currCommentMode == cm_uncomment) && (nUncomments == 0))
4274  	{
4275  		return undoStreamComment(false);
4276  	}
4277      return true;
4278  }
4279  bool Notepad_plus::doStreamComment()
4280  {
4281  	const TCHAR *commentStart;
4282  	const TCHAR *commentEnd;
4283  	generic_string symbolStart;
4284  	generic_string symbolEnd;
4285  	const TCHAR *commentLineSymbol;
4286  	generic_string symbol;
4287  	Buffer * buf = _pEditView->getCurrentBuffer();
4288  	if (buf->isReadOnly())
4289  		return false;
4290  	if (buf->getLangType() == L_USER)
4291  	{
4292  		UserLangContainer * userLangContainer = NppParameters::getInstance().getULCFromName(buf->getUserDefineLangName());
4293  		if (!userLangContainer)
4294  			return false;
4295  		symbol = extractSymbol('0', '0', userLangContainer->_keywordLists[SCE_USER_KWLIST_COMMENTS]);
4296  		commentLineSymbol = symbol.c_str();
4297  		symbolStart = extractSymbol('0', '3', userLangContainer->_keywordLists[SCE_USER_KWLIST_COMMENTS]);
4298  		commentStart = symbolStart.c_str();
4299  		symbolEnd = extractSymbol('0', '4', userLangContainer->_keywordLists[SCE_USER_KWLIST_COMMENTS]);
4300  		commentEnd = symbolEnd.c_str();
4301  	}
4302  	else
4303  	{
4304  		commentLineSymbol = buf->getCommentLineSymbol();
4305  		commentStart = buf->getCommentStart();
4306  		commentEnd = buf->getCommentEnd();
4307  	}
4308  	if ((!commentStart) || (!commentStart[0]) || (commentStart == NULL) || (!commentEnd) || (!commentEnd[0]) || (commentEnd == NULL))
4309  	{
4310  		if (!(!commentLineSymbol || !commentLineSymbol[0] || commentLineSymbol == NULL))
4311  			return doBlockComment(cm_comment);
4312  		else
4313  		return false;
4314  	}
4315  	generic_string start_comment(commentStart);
4316  	generic_string end_comment(commentEnd);
4317  	generic_string white_space(TEXT(" "));
4318  	start_comment += white_space;
4319  	white_space += end_comment;
4320  	end_comment = white_space;
4321  	size_t start_comment_length = start_comment.length();
4322  	size_t selectionStart = _pEditView->execute(SCI_GETSELECTIONSTART);
4323  	size_t selectionEnd = _pEditView->execute(SCI_GETSELECTIONEND);
4324  	size_t caretPosition = _pEditView->execute(SCI_GETCURRENTPOS);
4325  	bool move_caret = caretPosition < selectionEnd;
4326  	if (selectionEnd - selectionStart <= 0)
4327  	{
4328  		auto selLine = _pEditView->execute(SCI_LINEFROMPOSITION, selectionStart);
4329  		selectionStart = _pEditView->execute(SCI_GETLINEINDENTPOSITION, selLine);
4330  		selectionEnd = _pEditView->execute(SCI_GETLINEENDPOSITION, selLine);
4331  	}
4332  	_pEditView->execute(SCI_BEGINUNDOACTION);
4333  	_pEditView->insertGenericTextFrom(selectionStart, start_comment.c_str());
4334  	selectionEnd += start_comment_length;
4335  	selectionStart += start_comment_length;
4336  	_pEditView->insertGenericTextFrom(selectionEnd, end_comment.c_str());
4337  	if (move_caret)
4338  	{
4339  		_pEditView->execute(SCI_GOTOPOS, selectionEnd);
4340  		_pEditView->execute(SCI_SETCURRENTPOS, selectionStart);
4341  	}
4342  	else
4343  	{
4344  		_pEditView->execute(SCI_SETSEL, selectionStart, selectionEnd);
4345  	}
4346  	_pEditView->execute(SCI_ENDUNDOACTION);
4347  	return true;
4348  }
4349  void Notepad_plus::saveScintillasZoom()
4350  {
4351  	NppParameters& nppParam = NppParameters::getInstance();
4352  	ScintillaViewParams & svp = (ScintillaViewParams &)nppParam.getSVP();
4353  	svp._zoom = _mainEditView.execute(SCI_GETZOOM);
4354  	svp._zoom2 = _subEditView.execute(SCI_GETZOOM);
4355  }
4356  bool Notepad_plus::addCurrentMacro()
4357  {
4358  	NppParameters& nppParams = NppParameters::getInstance();
4359  	vector<MacroShortcut> & theMacros = nppParams.getMacroList();
4360  	int nbMacro = static_cast<int32_t>(theMacros.size());
4361  	DynamicMenu& macroMenu = nppParams.getMacroMenuItems();
4362  	int nbTopLevelItem = macroMenu.getTopLevelItemNumber();
4363  	int cmdID = ID_MACRO + nbMacro;
4364  	MacroShortcut ms(Shortcut(), _macro, cmdID);
4365  	ms.init(_pPublicInterface->getHinst(), _pPublicInterface->getHSelf());
4366  	if (ms.doDialog() != -1)
4367  	{
4368  		HMENU hMacroMenu = ::GetSubMenu(_mainMenuHandle, MENUINDEX_MACRO);
4369  		unsigned int posBase = macroMenu.getPosBase();
4370  		if (nbTopLevelItem == 0)
4371  		{
4372  			::InsertMenu(hMacroMenu, posBase - 1, MF_BYPOSITION, static_cast<UINT>(-1), 0);	
4373  			::InsertMenu(hMacroMenu, posBase + nbTopLevelItem + 1, MF_BYPOSITION, static_cast<UINT>(-1), 0);
4374  			NativeLangSpeaker *pNativeLangSpeaker = nppParams.getNativeLangSpeaker();
4375  			generic_string nativeLangShortcutMapperMacro = pNativeLangSpeaker->getNativeLangMenuString(IDM_SETTING_SHORTCUT_MAPPER_MACRO);
4376  			if (nativeLangShortcutMapperMacro == TEXT(""))
4377  				nativeLangShortcutMapperMacro = macroMenu.getLastCmdLabel();
4378  			::InsertMenu(hMacroMenu, posBase + nbTopLevelItem + 2, MF_BYCOMMAND, IDM_SETTING_SHORTCUT_MAPPER_MACRO, nativeLangShortcutMapperMacro.c_str());
4379          }
4380  		theMacros.push_back(ms);
4381  		macroMenu.push_back(MenuItemUnit(cmdID, string2wstring(ms.getName(), CP_UTF8)));
4382  		::InsertMenu(hMacroMenu, static_cast<UINT>(posBase + nbTopLevelItem), MF_BYPOSITION, cmdID, string2wstring(ms.toMenuItemString(), CP_UTF8).c_str());
4383  		_accelerator.updateShortcuts();
4384  		nppParams.setShortcutDirty();
4385  		return true;
4386  	}
4387  	return false;
4388  }
4389  bool Notepad_plus::switchToFile(BufferID id)
4390  {
4391  	int i = 0;
4392  	int iView = currentView();
4393  	if (id == BUFFER_INVALID)
4394  		return false;
4395  	if ((i = _pDocTab->getIndexByBuffer(id)) != -1)
4396  	{
4397  		iView = currentView();
4398  	}
4399  	else if ((i = _pNonDocTab->getIndexByBuffer(id)) != -1)
4400  	{
4401  		iView = otherView();
4402  	}
4403  	if (i != -1)
4404  	{
4405  		switchEditViewTo(iView);
4406  		activateBuffer(id, currentView());
4407  		return true;
4408  	}
4409  	return false;
4410  }
4411  void Notepad_plus::getTaskListInfo(TaskListInfo *tli)
4412  {
4413  	int currentNbDoc = static_cast<int32_t>(_pDocTab->nbItem());
4414  	int nonCurrentNbDoc = static_cast<int32_t>(_pNonDocTab->nbItem());
4415  	tli->_currentIndex = 0;
4416  	if (!viewVisible(otherView()))
4417  		nonCurrentNbDoc = 0;
4418  	for (int i = 0 ; i < currentNbDoc ; ++i)
4419  	{
4420  		BufferID bufID = _pDocTab->getBufferByIndex(i);
4421  		Buffer * b = MainFileManager.getBufferByID(bufID);
4422  		int status = b->isMonitoringOn()?tb_monitored:(b->isReadOnly()?tb_ro:(b->isDirty()?tb_unsaved:tb_saved));
4423  		tli->_tlfsLst.push_back(TaskLstFnStatus(currentView(), i, b->getFullPathName(), status, (void *)bufID, b->getDocColorId()));
4424  	}
4425  	for (int i = 0 ; i < nonCurrentNbDoc ; ++i)
4426  	{
4427  		BufferID bufID = _pNonDocTab->getBufferByIndex(i);
4428  		Buffer * b = MainFileManager.getBufferByID(bufID);
4429  		int status = b->isMonitoringOn()?tb_monitored:(b->isReadOnly()?tb_ro:(b->isDirty()?tb_unsaved:tb_saved));
4430  		tli->_tlfsLst.push_back(TaskLstFnStatus(otherView(), i, b->getFullPathName(), status, (void *)bufID, b->getDocColorId()));
4431  	}
4432  }
4433  bool Notepad_plus::goToPreviousIndicator(int indicID2Search, bool isWrap) const
4434  {
4435      auto position = _pEditView->execute(SCI_GETCURRENTPOS);
4436  	auto docLen = _pEditView->getCurrentDocLen();
4437      bool isInIndicator = _pEditView->execute(SCI_INDICATORVALUEAT, indicID2Search,  position) != 0;
4438      size_t posStart = _pEditView->execute(SCI_INDICATORSTART, indicID2Search,  position);
4439      size_t posEnd = _pEditView->execute(SCI_INDICATOREND, indicID2Search,  position);
4440  	if ((posStart == 0) && (posEnd == docLen - 1))
4441  		return false;
4442      if (posStart <= 0)
4443  	{
4444  		if (!isWrap)
4445  			return false;
4446  		isInIndicator = _pEditView->execute(SCI_INDICATORVALUEAT, indicID2Search,  docLen - 1) != 0;
4447  		posStart = _pEditView->execute(SCI_INDICATORSTART, indicID2Search,  docLen - 1);
4448  	}
4449      if (isInIndicator) 
4450      {
4451          posStart = _pEditView->execute(SCI_INDICATORSTART, indicID2Search, posStart - 1);
4452          if (posStart <= 0)
4453  		{
4454  			if (!isWrap)
4455  				return false;
4456  			posStart = _pEditView->execute(SCI_INDICATORSTART, indicID2Search,  docLen - 1);
4457  		}
4458  	}
4459      auto newPos = posStart - 1;
4460      posStart = _pEditView->execute(SCI_INDICATORSTART, indicID2Search, newPos);
4461      posEnd = _pEditView->execute(SCI_INDICATOREND, indicID2Search, newPos);
4462  	if (_pEditView->execute(SCI_INDICATORVALUEAT, indicID2Search, posStart))
4463  	{
4464  		NppGUI & nppGUI = (NppParameters::getInstance()).getNppGUI();
4465  		nppGUI._disableSmartHiliteTmp = true;
4466          auto currentline = _pEditView->execute(SCI_LINEFROMPOSITION, posEnd);
4467  	    _pEditView->execute(SCI_ENSUREVISIBLE, currentline);	
4468  		_pEditView->execute(SCI_SETSEL, posEnd, posStart);
4469  		_pEditView->execute(SCI_SCROLLCARET);
4470  		return true;
4471  	}
4472  	return false;
4473  }
4474  bool Notepad_plus::goToNextIndicator(int indicID2Search, bool isWrap) const
4475  {
4476      size_t position = _pEditView->execute(SCI_GETCURRENTPOS);
4477  	size_t docLen = _pEditView->getCurrentDocLen();
4478      bool isInIndicator = _pEditView->execute(SCI_INDICATORVALUEAT, indicID2Search,  position) != 0;
4479      size_t posStart = _pEditView->execute(SCI_INDICATORSTART, indicID2Search,  position);
4480      size_t posEnd = _pEditView->execute(SCI_INDICATOREND, indicID2Search,  position);
4481  	if ((posStart == 0) && (posEnd == docLen - 1))
4482  		return false;
4483      if (posEnd >= docLen)
4484  	{
4485  		if (!isWrap)
4486  			return false;
4487  		isInIndicator = _pEditView->execute(SCI_INDICATORVALUEAT, indicID2Search,  0) != 0;
4488  		posEnd = _pEditView->execute(SCI_INDICATOREND, indicID2Search, 0);
4489  	}
4490      if (isInIndicator) 
4491      {
4492          posEnd = _pEditView->execute(SCI_INDICATOREND, indicID2Search, posEnd);
4493          if (posEnd >= docLen)
4494  		{
4495  			if (!isWrap)
4496  				return false;
4497  			posEnd = _pEditView->execute(SCI_INDICATOREND, indicID2Search, 0);
4498  		}
4499      }
4500      auto newPos = posEnd;
4501      posStart = _pEditView->execute(SCI_INDICATORSTART, indicID2Search, newPos);
4502      posEnd = _pEditView->execute(SCI_INDICATOREND, indicID2Search, newPos);
4503  	if (_pEditView->execute(SCI_INDICATORVALUEAT, indicID2Search, posStart))
4504  	{
4505  		NppGUI & nppGUI = (NppParameters::getInstance()).getNppGUI();
4506  		nppGUI._disableSmartHiliteTmp = true;
4507          auto currentline = _pEditView->execute(SCI_LINEFROMPOSITION, posEnd);
4508  	    _pEditView->execute(SCI_ENSUREVISIBLE, currentline);	
4509  		_pEditView->execute(SCI_SETSEL, posStart, posEnd);
4510  		_pEditView->execute(SCI_SCROLLCARET);
4511  		return true;
4512  	}
4513  	return false;
4514  }
4515  void Notepad_plus::fullScreenToggle()
4516  {
4517  	if (!_beforeSpecialView._isFullScreen)	
4518  	{
4519  		_beforeSpecialView._winPlace.length = sizeof(_beforeSpecialView._winPlace);
4520  		::GetWindowPlacement(_pPublicInterface->getHSelf(), &_beforeSpecialView._winPlace);
4521  		RECT fullscreenArea{};		
4522  		fullscreenArea.top = 0;
4523  		fullscreenArea.left = 0;
4524  		fullscreenArea.right = GetSystemMetrics(SM_CXSCREEN);
4525  		fullscreenArea.bottom = GetSystemMetrics(SM_CYSCREEN);
4526  		{
4527  			HMONITOR currentMonitor;	
4528  			MONITORINFO mi{};				
4529  			currentMonitor = ::MonitorFromWindow(_pPublicInterface->getHSelf(), MONITOR_DEFAULTTONEAREST);	
4530  			mi.cbSize = sizeof(MONITORINFO);
4531  			if (::GetMonitorInfo(currentMonitor, &mi) != FALSE)
4532  			{
4533  				fullscreenArea = mi.rcMonitor;
4534  				fullscreenArea.right -= fullscreenArea.left;
4535  				fullscreenArea.bottom -= fullscreenArea.top;
4536  			}
4537  		}
4538          int bs = buttonStatus_fullscreen;
4539  		if (_beforeSpecialView._isPostIt)
4540          {
4541              bs |= buttonStatus_postit;
4542          }
4543          else
4544  		{
4545  			_beforeSpecialView._isMenuShown = ::SendMessage(_pPublicInterface->getHSelf(), NPPM_ISMENUHIDDEN, 0, 0) != TRUE;
4546  			if (_beforeSpecialView._isMenuShown)
4547  				::SendMessage(_pPublicInterface->getHSelf(), NPPM_HIDEMENU, 0, TRUE);
4548  			_rebarTop.display(false);
4549  			_rebarBottom.display(false);
4550  		}
4551          _restoreButton.setButtonStatus(bs);
4552  		::ShowWindow(_pPublicInterface->getHSelf(), SW_HIDE);
4553  		if (!_beforeSpecialView._isPostIt)
4554  		{
4555  			_beforeSpecialView._preStyle = ::SetWindowLongPtr(_pPublicInterface->getHSelf(), GWL_STYLE, WS_POPUP);
4556  			if (!_beforeSpecialView._preStyle)
4557  			{
4558  				_beforeSpecialView._preStyle = WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN;
4559  			}
4560  		}
4561  		::ShowWindow(_pPublicInterface->getHSelf(), SW_SHOW);
4562  		::SetWindowPos(_pPublicInterface->getHSelf(), HWND_TOP, fullscreenArea.left, fullscreenArea.top, fullscreenArea.right, fullscreenArea.bottom, SWP_NOZORDER|SWP_DRAWFRAME|SWP_FRAMECHANGED);
4563  		::SetForegroundWindow(_pPublicInterface->getHSelf());
4564          _restoreButton.doDialog(_nativeLangSpeaker.isRTL());
4565          RECT rect;
4566          GetWindowRect(_restoreButton.getHSelf(), &rect);
4567  	    int w = rect.right - rect.left;
4568  	    int h = rect.bottom - rect.top;
4569          RECT nppRect;
4570          GetWindowRect(_pPublicInterface->getHSelf(), &nppRect);
4571          int x = nppRect.right - w;
4572          int y = nppRect.top;
4573          ::MoveWindow(_restoreButton.getHSelf(), x, y, w, h, FALSE);
4574          _pEditView->getFocus();
4575  	}
4576  	else	
4577  	{
4578  		::ShowWindow(_pPublicInterface->getHSelf(), SW_HIDE);
4579          _restoreButton.setButtonStatus(buttonStatus_fullscreen ^ _restoreButton.getButtonStatus());
4580          _restoreButton.display(false);
4581  		if (!_beforeSpecialView._isPostIt)
4582  		{
4583  			if (_beforeSpecialView._isMenuShown)
4584  				::SendMessage(_pPublicInterface->getHSelf(), NPPM_HIDEMENU, 0, FALSE);
4585  			_rebarTop.display(true);
4586  			_rebarBottom.display(true);
4587  		}
4588  		if (!_beforeSpecialView._isPostIt)
4589  		{
4590  			::SetWindowLongPtr( _pPublicInterface->getHSelf(), GWL_STYLE, _beforeSpecialView._preStyle);
4591  			::SetWindowPos(_pPublicInterface->getHSelf(), HWND_TOP,0,0,0,0,SWP_NOMOVE|SWP_NOSIZE|SWP_NOZORDER|SWP_DRAWFRAME|SWP_FRAMECHANGED);
4592  			::ShowWindow(_pPublicInterface->getHSelf(), SW_SHOW);
4593  		}
4594  		if (_beforeSpecialView._winPlace.length)
4595  		{
4596  			if (_beforeSpecialView._winPlace.showCmd == SW_SHOWMAXIMIZED)
4597  			{
4598  				::ShowWindow(_pPublicInterface->getHSelf(), SW_SHOWMAXIMIZED);
4599  			}
4600  			else
4601  			{
4602  				::SetWindowPlacement(_pPublicInterface->getHSelf(), &_beforeSpecialView._winPlace);
4603  			}
4604  		}
4605  		else	
4606  		{
4607  			::ShowWindow(_pPublicInterface->getHSelf(), SW_SHOW);
4608  		}
4609  	}
4610  	_beforeSpecialView._isFullScreen = !_beforeSpecialView._isFullScreen;
4611  	::SendMessage(_pPublicInterface->getHSelf(), WM_SIZE, 0, 0);
4612      if (_beforeSpecialView._isPostIt)
4613      {
4614          RECT rect;
4615          GetWindowRect(_restoreButton.getHSelf(), &rect);
4616          int w = rect.right - rect.left;
4617          int h = rect.bottom - rect.top;
4618          RECT nppRect;
4619          GetWindowRect(_pPublicInterface->getHSelf(), &nppRect);
4620          int x = nppRect.right - w - w;
4621          int y = nppRect.top + 1;
4622          ::MoveWindow(_restoreButton.getHSelf(), x, y, w, h, FALSE);
4623      }
4624  }
4625  void Notepad_plus::postItToggle()
4626  {
4627  	if (!_beforeSpecialView._isPostIt)	
4628  	{
4629  		NppGUI & nppGUI = NppParameters::getInstance().getNppGUI();
4630  		{
4631  			_beforeSpecialView._isAlwaysOnTop = ::GetMenuState(_mainMenuHandle, IDM_VIEW_ALWAYSONTOP, MF_BYCOMMAND) == MF_CHECKED;
4632  			_beforeSpecialView._isTabbarShown = ::SendMessage(_pPublicInterface->getHSelf(), NPPM_ISTABBARHIDDEN, 0, 0) != TRUE;
4633  			_beforeSpecialView._isStatusbarShown = nppGUI._statusBarShow;
4634  			if (nppGUI._statusBarShow)
4635  				::SendMessage(_pPublicInterface->getHSelf(), NPPM_HIDESTATUSBAR, 0, TRUE);
4636  			if (_beforeSpecialView._isTabbarShown)
4637  				::SendMessage(_pPublicInterface->getHSelf(), NPPM_HIDETABBAR, 0, TRUE);
4638  			if (!_beforeSpecialView._isAlwaysOnTop)
4639  				::SendMessage(_pPublicInterface->getHSelf(), WM_COMMAND, IDM_VIEW_ALWAYSONTOP, 0);
4640  		}
4641          int bs = buttonStatus_postit;
4642  		if (_beforeSpecialView._isFullScreen)
4643          {
4644              bs |= buttonStatus_fullscreen;
4645          }
4646          else
4647  		{
4648  			_beforeSpecialView._isMenuShown = ::SendMessage(_pPublicInterface->getHSelf(), NPPM_ISMENUHIDDEN, 0, 0) != TRUE;
4649  			if (_beforeSpecialView._isMenuShown)
4650  				::SendMessage(_pPublicInterface->getHSelf(), NPPM_HIDEMENU, 0, TRUE);
4651  			_rebarTop.display(false);
4652  			_rebarBottom.display(false);
4653  		}
4654          _restoreButton.setButtonStatus(bs);
4655  		if (!_beforeSpecialView._isFullScreen)
4656  		{
4657  			::ShowWindow(_pPublicInterface->getHSelf(), SW_HIDE);
4658  			_beforeSpecialView._preStyle = ::SetWindowLongPtr( _pPublicInterface->getHSelf(), GWL_STYLE, WS_POPUP );
4659  			if (!_beforeSpecialView._preStyle)
4660  			{
4661  				_beforeSpecialView._preStyle = WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN;
4662  			}
4663  			::SetWindowPos(_pPublicInterface->getHSelf(), HWND_TOPMOST,0,0,0,0,SWP_NOMOVE|SWP_NOSIZE|SWP_NOZORDER|SWP_DRAWFRAME|SWP_FRAMECHANGED);
4664  			::ShowWindow(_pPublicInterface->getHSelf(), SW_SHOW);
4665  		}
4666          _restoreButton.doDialog(_nativeLangSpeaker.isRTL());
4667          RECT rect;
4668          GetWindowRect(_restoreButton.getHSelf(), &rect);
4669  	    int w = rect.right - rect.left;
4670  	    int h = rect.bottom - rect.top;
4671          RECT nppRect;
4672          GetWindowRect(_pPublicInterface->getHSelf(), &nppRect);
4673          int x = nppRect.right - w - w;
4674          int y = nppRect.top + 1;
4675          ::MoveWindow(_restoreButton.getHSelf(), x, y, w, h, FALSE);
4676          _pEditView->getFocus();
4677  	}
4678  	else	
4679  	{
4680          _restoreButton.setButtonStatus(buttonStatus_postit ^ _restoreButton.getButtonStatus());
4681          _restoreButton.display(false);
4682  		if (!_beforeSpecialView._isFullScreen)
4683  		{
4684  			if (_beforeSpecialView._isMenuShown)
4685  				::SendMessage(_pPublicInterface->getHSelf(), NPPM_HIDEMENU, 0, FALSE);
4686  			_rebarTop.display(true);
4687  			_rebarBottom.display(true);
4688  		}
4689  		if (_beforeSpecialView._isStatusbarShown)
4690  			::SendMessage(_pPublicInterface->getHSelf(), NPPM_HIDESTATUSBAR, 0, FALSE);
4691  		if (_beforeSpecialView._isTabbarShown)
4692  			::SendMessage(_pPublicInterface->getHSelf(), NPPM_HIDETABBAR, 0, FALSE);
4693  		if (!_beforeSpecialView._isAlwaysOnTop)
4694  			::SendMessage(_pPublicInterface->getHSelf(), WM_COMMAND, IDM_VIEW_ALWAYSONTOP, 0);
4695  		if (!_beforeSpecialView._isFullScreen)
4696  		{
4697  			::ShowWindow(_pPublicInterface->getHSelf(), SW_HIDE);
4698  			::SetWindowLongPtr(_pPublicInterface->getHSelf(), GWL_STYLE, _beforeSpecialView._preStyle);
4699  			::SetWindowPos(_pPublicInterface->getHSelf(), HWND_NOTOPMOST,0,0,0,0,SWP_NOMOVE|SWP_NOSIZE|SWP_NOZORDER|SWP_DRAWFRAME|SWP_FRAMECHANGED);
4700  			::ShowWindow(_pPublicInterface->getHSelf(), SW_SHOW);
4701  		}
4702  	}
4703  	_beforeSpecialView._isPostIt = !_beforeSpecialView._isPostIt;
4704  	::SendMessage(_pPublicInterface->getHSelf(), WM_SIZE, 0, 0);
4705  }
4706  void Notepad_plus::distractionFreeToggle()
4707  {
4708  	fullScreenToggle();
4709  	postItToggle();
4710  	const ScintillaViewParams& svp = NppParameters::getInstance().getSVP();
4711  	int paddingLeft = 0;
4712  	int paddingRight = 0;
4713  	if (_beforeSpecialView._isDistractionFree) 
4714  	{
4715  		if (_beforeSpecialView._was2ViewModeOn)
4716  		{
4717  			showView(otherView());
4718  			_beforeSpecialView._was2ViewModeOn = false;
4719  		}
4720  		for (auto i : _beforeSpecialView._pVisibleDockingContainers)
4721  		{
4722  			i->display();
4723  		}
4724  		_dockingManager.resize();
4725  		paddingLeft = svp._paddingLeft;
4726  		paddingRight = svp._paddingRight;
4727  		_restoreButton.setButtonStatus(0);
4728  		_restoreButton.display(false);
4729  	}
4730  	else 
4731  	{
4732  		ScintillaEditView & nonFocusedView = (otherView() == MAIN_VIEW) ? _mainEditView : _subEditView;
4733  		if (nonFocusedView.isVisible())
4734  		{
4735  			hideView(otherView());
4736  			_beforeSpecialView._was2ViewModeOn = true;
4737  		}
4738  		else
4739  		{
4740  			_beforeSpecialView._was2ViewModeOn = false;
4741  		}
4742  		std::vector<DockingCont*> & container = _dockingManager.getContainerInfo();
4743  		_beforeSpecialView._pVisibleDockingContainers.clear();
4744  		for (auto i : container)
4745  		{
4746  			if (i->isVisible())
4747  			{
4748  				_beforeSpecialView._pVisibleDockingContainers.push_back(i);
4749  			}
4750  		}
4751  		for (auto i : _beforeSpecialView._pVisibleDockingContainers)
4752  		{
4753  			i->display(false);
4754  		}
4755  		_dockingManager.resize();
4756  		paddingLeft = paddingRight = svp.getDistractionFreePadding(_pEditView->getWidth());
4757  		_restoreButton.setButtonStatus(buttonStatus_distractionFree);
4758  	}
4759  	_beforeSpecialView._isDistractionFree = !_beforeSpecialView._isDistractionFree;
4760  	_pEditView->execute(SCI_SETMARGINLEFT, 0, paddingLeft);
4761  	_pEditView->execute(SCI_SETMARGINRIGHT, 0, paddingRight);
4762  }
4763  void Notepad_plus::doSynScorll(HWND whichView)
4764  {
4765  	intptr_t column = 0;
4766  	intptr_t line = 0;
4767  	ScintillaEditView *pView;
4768  	intptr_t mainCurrentLine, subCurrentLine;
4769  	intptr_t mxoffset, sxoffset;
4770  	intptr_t pixel;
4771  	intptr_t mainColumn, subColumn;
4772  	if (whichView == _mainEditView.getHSelf())
4773  	{
4774  		if (_syncInfo._isSynScollV)
4775  		{
4776  			mainCurrentLine = _mainEditView.execute(SCI_GETFIRSTVISIBLELINE);
4777  			subCurrentLine = _subEditView.execute(SCI_GETFIRSTVISIBLELINE);
4778  			line = mainCurrentLine - _syncInfo._line - subCurrentLine;
4779  		}
4780  		if (_syncInfo._isSynScollH)
4781  		{
4782  			mxoffset = _mainEditView.execute(SCI_GETXOFFSET);
4783  			pixel = _mainEditView.execute(SCI_TEXTWIDTH, STYLE_DEFAULT, reinterpret_cast<LPARAM>("P"));
4784  			mainColumn = mxoffset/pixel;
4785  			sxoffset = _subEditView.execute(SCI_GETXOFFSET);
4786  			pixel = _subEditView.execute(SCI_TEXTWIDTH, STYLE_DEFAULT, reinterpret_cast<LPARAM>("P"));
4787  			subColumn = sxoffset/pixel;
4788  			column = mainColumn - _syncInfo._column - subColumn;
4789  		}
4790  		pView = &_subEditView;
4791  	}
4792  	else if (whichView == _subEditView.getHSelf())
4793  	{
4794  		if (_syncInfo._isSynScollV)
4795  		{
4796  			mainCurrentLine = _mainEditView.execute(SCI_GETFIRSTVISIBLELINE);
4797  			subCurrentLine = _subEditView.execute(SCI_GETFIRSTVISIBLELINE);
4798  			line = subCurrentLine + _syncInfo._line - mainCurrentLine;
4799  		}
4800  		if (_syncInfo._isSynScollH)
4801  		{
4802  			mxoffset = _mainEditView.execute(SCI_GETXOFFSET);
4803  			pixel = _mainEditView.execute(SCI_TEXTWIDTH, STYLE_DEFAULT, reinterpret_cast<LPARAM>("P"));
4804  			mainColumn = mxoffset/pixel;
4805  			sxoffset = _subEditView.execute(SCI_GETXOFFSET);
4806  			pixel = _subEditView.execute(SCI_TEXTWIDTH, STYLE_DEFAULT, reinterpret_cast<LPARAM>("P"));
4807  			subColumn = sxoffset/pixel;
4808  			column = subColumn + _syncInfo._column - mainColumn;
4809  		}
4810  		pView = &_mainEditView;
4811  	}
4812  	else
4813  		return;
4814  	pView->scroll(column, line);
4815  }
4816  bool Notepad_plus::getIntegralDockingData(tTbData & dockData, int & iCont, bool & isVisible)
4817  {
4818  	DockingManagerData & dockingData = (DockingManagerData &)(NppParameters::getInstance()).getNppGUI()._dockingData;
4819  	for (size_t i = 0, len = dockingData._pluginDockInfo.size(); i < len ; ++i)
4820  	{
4821  		const PluginDlgDockingInfo & pddi = dockingData._pluginDockInfo[i];
4822  		if (!wcsicmp(pddi._name.c_str(), dockData.pszModuleName) && (pddi._internalID == dockData.dlgID))
4823  		{
4824  			iCont				= pddi._currContainer;
4825  			isVisible			= pddi._isVisible;
4826  			dockData.iPrevCont	= pddi._prevContainer;
4827  			if (dockData.iPrevCont != -1)
4828  			{
4829  				int cont = (pddi._currContainer < DOCKCONT_MAX ? pddi._prevContainer : pddi._currContainer);
4830  				RECT rc;
4831  				if (dockingData.getFloatingRCFrom(cont, rc))
4832  					dockData.rcFloat = rc;
4833  			}
4834  			return true;
4835  		}
4836  	}
4837  	return false;
4838  }
4839  void Notepad_plus::getCurrentOpenedFiles(Session & session, bool includUntitledDoc)
4840  {
4841  	_mainEditView.saveCurrentPos();	
4842  	_subEditView.saveCurrentPos();	
4843  	session._activeView = currentView();
4844  	session._activeMainIndex = _mainDocTab.getCurrentTabIndex();
4845  	session._activeSubIndex = _subDocTab.getCurrentTabIndex();
4846  	Document oldDoc = _invisibleEditView.execute(SCI_GETDOCPOINTER);
4847  	const int nbElem = 2;
4848  	DocTabView* docTab[nbElem]{};
4849  	docTab[0] = &_mainDocTab;
4850  	docTab[1] = &_subDocTab;
4851  	for (size_t k = 0; k < nbElem; ++k)
4852  	{
4853  		for (size_t i = 0, len = docTab[k]->nbItem(); i < len ; ++i)
4854  		{
4855  			BufferID bufID = docTab[k]->getBufferByIndex(i);
4856  			ScintillaEditView *editView = k == 0 ? &_mainEditView : &_subEditView;
4857  			size_t activeIndex = k == 0 ? session._activeMainIndex : session._activeSubIndex;
4858  			vector<sessionFileInfo> *viewFiles = (vector<sessionFileInfo> *)(k == 0?&(session._mainViewFiles):&(session._subViewFiles));
4859  			Buffer * buf = MainFileManager.getBufferByID(bufID);
4860  			if (buf->isUntitled() && buf->docLength() == 0)
4861  				continue;
4862  			if (!includUntitledDoc)
4863  				if (!PathFileExists(buf->getFullPathName()))
4864  					continue;
4865  			wstring	languageName = getLangFromMenu(buf);
4866  			if (languageName.empty()) 
4867  			{
4868  				NppParameters& nppParam = NppParameters::getInstance();
4869  				const NppGUI& nppGUI = nppParam.getNppGUI();
4870  				for (size_t k = 0; k < nppGUI._excludedLangList.size(); ++k) 
4871  				{
4872  					if (buf->getLangType() == nppGUI._excludedLangList[k]._langType)
4873  					{
4874  						languageName = nppGUI._excludedLangList[k]._langName;
4875  						break;
4876  					}
4877  				}
4878  			}
4879  			const wchar_t* langName = languageName.c_str();
4880  			sessionFileInfo sfi(buf->getFullPathName(), langName, buf->getEncoding(), buf->getUserReadOnly(), buf->getPosition(editView), buf->getBackupFileName().c_str(), buf->getLastModifiedTimestamp(), buf->getMapPosition());
4881  			sfi._isMonitoring = buf->isMonitoringOn();
4882  			sfi._individualTabColour = docTab[k]->getIndividualTabColour(static_cast<int>(i));
4883  			_invisibleEditView.execute(SCI_SETDOCPOINTER, 0, buf->getDocument());
4884  			size_t maxLine = static_cast<size_t>(_invisibleEditView.execute(SCI_GETLINECOUNT));
4885  			for (size_t j = 0 ; j < maxLine ; ++j)
4886  			{
4887  				if ((_invisibleEditView.execute(SCI_MARKERGET, j) & (1 << MARK_BOOKMARK)) != 0)
4888  				{
4889  					sfi._marks.push_back(j);
4890  				}
4891  			}
4892  			if (i == activeIndex)
4893  			{
4894  				editView->getCurrentFoldStates(sfi._foldStates);
4895  			}
4896  			else
4897  			{
4898  				sfi._foldStates = buf->getHeaderLineState(editView);
4899  			}
4900  			viewFiles->push_back(sfi);
4901  		}
4902  	}
4903  	_invisibleEditView.execute(SCI_SETDOCPOINTER, 0, oldDoc);
4904  }
4905  bool Notepad_plus::str2Cliboard(const generic_string & str2cpy)
4906  {
4907  	return str2Clipboard(str2cpy, _pPublicInterface->getHSelf());
4908  }
4909  bool Notepad_plus::emergency(const generic_string& emergencySavedDir)
4910  {
4911      ::CreateDirectory(emergencySavedDir.c_str(), NULL);
4912  	return dumpFiles(emergencySavedDir.c_str(), TEXT("File"));
4913  }
4914  bool Notepad_plus::dumpFiles(const TCHAR * outdir, const TCHAR * fileprefix)
4915  {
4916  	bool somethingsaved = false;
4917  	bool somedirty = false;
4918  	TCHAR savePath[MAX_PATH] = { '\0' };
4919  	for (size_t i = 0; i < MainFileManager.getNbBuffers(); ++i)
4920  	{
4921  		Buffer * docbuf = MainFileManager.getBufferByIndex(i);
4922  		if (!docbuf->isDirty())	
4923  			continue;
4924  		else
4925  			somedirty = true;
4926  		const TCHAR * unitext = (docbuf->getUnicodeMode() != uni8Bit)?TEXT("_utf8"):TEXT("");
4927  		wsprintf(savePath, TEXT("%s\\%s%03d%s.dump"), outdir, fileprefix, static_cast<int>(i), unitext);
4928  		SavingStatus res = MainFileManager.saveBuffer(docbuf->getID(), savePath);
4929  		somethingsaved |= (res == SavingStatus::SaveOK);
4930  	}
4931  	return somethingsaved || !somedirty;
4932  }
4933  void Notepad_plus::drawTabbarColoursFromStylerArray()
4934  {
4935  	Style *stActText = getStyleFromName(TABBAR_ACTIVETEXT);
4936  	if (stActText && static_cast<long>(stActText->_fgColor) != -1)
4937  		TabBarPlus::setColour(stActText->_fgColor, TabBarPlus::activeText);
4938  	Style *stActfocusTop = getStyleFromName(TABBAR_ACTIVEFOCUSEDINDCATOR);
4939  	if (stActfocusTop && static_cast<long>(stActfocusTop->_fgColor) != -1)
4940  		TabBarPlus::setColour(stActfocusTop->_fgColor, TabBarPlus::activeFocusedTop);
4941  	Style *stActunfocusTop = getStyleFromName(TABBAR_ACTIVEUNFOCUSEDINDCATOR);
4942  	if (stActunfocusTop && static_cast<long>(stActunfocusTop->_fgColor) != -1)
4943  		TabBarPlus::setColour(stActunfocusTop->_fgColor, TabBarPlus::activeUnfocusedTop);
4944  	Style *stInact = getStyleFromName(TABBAR_INACTIVETEXT);
4945  	if (stInact && static_cast<long>(stInact->_fgColor) != -1)
4946  		TabBarPlus::setColour(stInact->_fgColor, TabBarPlus::inactiveText);
4947  	if (stInact && static_cast<long>(stInact->_bgColor) != -1)
4948  		TabBarPlus::setColour(stInact->_bgColor, TabBarPlus::inactiveBg);
4949  }
4950  void Notepad_plus::drawAutocompleteColoursFromTheme(COLORREF fgColor, COLORREF bgColor)
4951  {
4952  	if (bgColor == 0xFFFFFF)
4953  	{
4954  		COLORREF autocompleteBg = ::GetSysColor(COLOR_WINDOW);
4955  		COLORREF selectedBg = ::GetSysColor(COLOR_HIGHLIGHT);
4956  		COLORREF autocompleteText = ::GetSysColor(COLOR_WINDOWTEXT);
4957  		COLORREF selectedText = ::GetSysColor(COLOR_HIGHLIGHTTEXT);
4958  		AutoCompletion::setColour(autocompleteBg, AutoCompletion::AutocompleteColorIndex::autocompleteBg);
4959  		AutoCompletion::setColour(selectedBg, AutoCompletion::AutocompleteColorIndex::selectedBg);
4960  		AutoCompletion::setColour(autocompleteText, AutoCompletion::AutocompleteColorIndex::autocompleteText);
4961  		AutoCompletion::setColour(selectedText, AutoCompletion::AutocompleteColorIndex::selectedText);
4962  		COLORREF colourBG = bgColor;
4963  		COLORREF colourUnSel = RGB(0x80, 0x80, 0x80);
4964  		COLORREF colourSel = RGB(0, 0, 0x80);
4965  		AutoCompletion::setColour(colourBG, AutoCompletion::AutocompleteColorIndex::calltipBg);
4966  		AutoCompletion::setColour(colourUnSel, AutoCompletion::AutocompleteColorIndex::calltipText);
4967  		AutoCompletion::setColour(colourSel, AutoCompletion::AutocompleteColorIndex::calltipHighlight);
4968  		return;
4969  	}
4970  	int rbv = GetRValue(bgColor);
4971  	int gbv = GetGValue(bgColor);
4972  	int bbv = GetBValue(bgColor);
4973  	int rfv = GetRValue(fgColor);
4974  	int gfv = GetGValue(fgColor);
4975  	int bfv = GetBValue(fgColor);
4976  	COLORREF bgDarker = RGB(rbv - 20 <= 0 ? 0 : rbv - 20, gbv - 20 <= 0 ? 0 : gbv - 20, bbv - 20 <= 0 ? 0 : bbv - 20);
4977  	if (bgColor == RGB(0, 0, 0)) 
4978  		bgDarker = RGB(20, 20, 20); 
4979  	COLORREF fgDarker = RGB(rfv - 20 <= 0 ? 0 : rfv - 20, gfv - 20 <= 0 ? 0 : gfv - 20, bfv - 20 <= 0 ? 0 : bfv - 20);
4980  	COLORREF fgLigher = RGB(rfv + 20 >= 255 ? 255 : rfv + 20, gfv + 20 >= 255 ? 255 : gfv + 20, bfv + 20 >= 255 ? 255 : bfv + 20);
4981  	AutoCompletion::setColour(bgDarker, AutoCompletion::AutocompleteColorIndex::autocompleteBg);
4982  	AutoCompletion::setColour(bgColor, AutoCompletion::AutocompleteColorIndex::selectedBg);
4983  	AutoCompletion::setColour(fgDarker, AutoCompletion::AutocompleteColorIndex::autocompleteText);
4984  	AutoCompletion::setColour(fgColor, AutoCompletion::AutocompleteColorIndex::selectedText);
4985  	AutoCompletion::setColour(bgDarker, AutoCompletion::AutocompleteColorIndex::calltipBg);
4986  	AutoCompletion::setColour(fgDarker, AutoCompletion::AutocompleteColorIndex::calltipText);
4987  	AutoCompletion::setColour(fgLigher, AutoCompletion::AutocompleteColorIndex::calltipHighlight);
4988  }
4989  void Notepad_plus::drawDocumentMapColoursFromStylerArray()
4990  {
4991  	Style* docMap = getStyleFromName(VIEWZONE_DOCUMENTMAP);
4992  	if (docMap && static_cast<long>(docMap->_fgColor) != -1)
4993  		ViewZoneDlg::setColour(docMap->_fgColor, ViewZoneDlg::ViewZoneColorIndex::focus);
4994  	if (docMap && static_cast<long>(docMap->_bgColor) != -1)
4995  		ViewZoneDlg::setColour(docMap->_bgColor, ViewZoneDlg::ViewZoneColorIndex::frost);
4996  }
4997  void Notepad_plus::prepareBufferChangedDialog(Buffer * buffer)
4998  {
4999  	if (::IsIconic(_pPublicInterface->getHSelf()))
5000  		::ShowWindow(_pPublicInterface->getHSelf(), SW_RESTORE);
5001  	int index = _pDocTab->getIndexByBuffer(buffer->getID());
5002  	int iView = currentView();
5003  	if (index == -1)
5004  		iView = otherView();
5005  	activateBuffer(buffer->getID(), iView);	
5006  	auto curPos = _pEditView->execute(SCI_GETCURRENTPOS);
5007  	::PostMessage(_pEditView->getHSelf(), WM_LBUTTONDOWN, 0, 0);
5008  	::PostMessage(_pEditView->getHSelf(), WM_LBUTTONUP, 0, 0);
5009  	::PostMessage(_pEditView->getHSelf(), SCI_SETSEL, curPos, curPos);
5010  }
5011  void Notepad_plus::notifyBufferChanged(Buffer * buffer, int mask)
5012  {
5013  	NppParameters& nppParam = NppParameters::getInstance();
5014  	const NppGUI & nppGUI = nppParam.getNppGUI();
5015  	_mainEditView.bufferUpdated(buffer, mask);
5016  	_subEditView.bufferUpdated(buffer, mask);
5017  	_mainDocTab.bufferUpdated(buffer, mask);
5018  	_subDocTab.bufferUpdated(buffer, mask);
5019  	bool mainActive = (_mainEditView.getCurrentBuffer() == buffer);
5020  	bool subActive = (_subEditView.getCurrentBuffer() == buffer);
5021  	if (mask & BufferChangeStatus)
5022  	{	
5023  		switch(buffer->getStatus())
5024  		{
5025  			case DOC_UNNAMED: 	
5026  			case DOC_REGULAR: 	
5027  			{
5028  				break;
5029  			}
5030  			case DOC_MODIFIED:	
5031  			{
5032  				if (buffer->isMonitoringOn())
5033  					break;
5034  				bool autoUpdate = (nppGUI._fileAutoDetection & cdAutoUpdate) ? true : false;
5035  				if (!autoUpdate || buffer->isDirty())
5036  				{
5037  					prepareBufferChangedDialog(buffer);
5038  					if (doReloadOrNot(buffer->getFullPathName(), buffer->isDirty()) != IDYES)
5039  					{
5040  						buffer->setDirty(true);
5041  						buffer->setUnsync(true);
5042  						break;	
5043  					}
5044  				}
5045  				buffer->setLoadedDirty(false);
5046  				buffer->setUnsync(false);
5047  				doReload(buffer->getID(), false);
5048  				if (mainActive || subActive)
5049  				{
5050  					performPostReload(mainActive?MAIN_VIEW:SUB_VIEW);
5051  				}
5052  				break;
5053  			}
5054  			case DOC_NEEDRELOAD: 
5055  			{
5056  				doReload(buffer->getID(), false);
5057  				if (buffer == _mainEditView.getCurrentBuffer())
5058  				{
5059  					_mainEditView.setPositionRestoreNeeded(false);
5060  					_mainEditView.execute(SCI_DOCUMENTEND);
5061  				}
5062  				if (buffer == _subEditView.getCurrentBuffer())
5063  				{
5064  					_subEditView.setPositionRestoreNeeded(false);
5065  					_subEditView.execute(SCI_DOCUMENTEND);
5066  				}
5067  				break;
5068  			}
5069  			case DOC_DELETED: 	
5070  			{
5071  				prepareBufferChangedDialog(buffer);
5072  				SCNotification scnN{};
5073  				scnN.nmhdr.code = NPPN_FILEDELETED;
5074  				scnN.nmhdr.hwndFrom = _pPublicInterface->getHSelf();
5075  				scnN.nmhdr.idFrom = (uptr_t)buffer->getID();
5076  				_pluginsManager.notify(&scnN);
5077  				int doCloseDoc = doCloseOrNot(buffer->getFullPathName()) == IDNO;
5078  				if (doCloseDoc)
5079  				{
5080  					bool isSnapshotMode = nppGUI.isSnapshotMode();
5081  					doClose(buffer->getID(), otherView(), isSnapshotMode);
5082  					doClose(buffer->getID(), currentView(), isSnapshotMode);
5083  					return;
5084  				}
5085  				else
5086  				{
5087  					buffer->setUnsync(true);
5088  				}
5089  				break;
5090  			}
5091  		}
5092  	}
5093      if (mask & (BufferChangeReadonly))
5094  	{
5095  		checkDocState();
5096  		bool isSysReadOnly = buffer->getFileReadOnly();
5097  		bool isUserReadOnly = buffer->getUserReadOnly();
5098  		bool isDirty = buffer->isDirty();
5099  		SCNotification scnN{};
5100  		scnN.nmhdr.hwndFrom = (void *)buffer->getID();
5101  		scnN.nmhdr.idFrom = (uptr_t)  ((isSysReadOnly || isUserReadOnly? DOCSTATUS_READONLY : 0) | (isDirty ? DOCSTATUS_BUFFERDIRTY : 0));
5102  		scnN.nmhdr.code = NPPN_READONLYCHANGED;
5103  		_pluginsManager.notify(&scnN);
5104  	}
5105  	if (_pDocumentListPanel)
5106  		_pDocumentListPanel->setItemIconStatus(buffer);
5107  	if (!mainActive && !subActive)
5108  	{
5109  		return;
5110  	}
5111  	if (mask & (BufferChangeLanguage))
5112  	{
5113  		if (mainActive)
5114  			_autoCompleteMain.setLanguage(buffer->getLangType());
5115  		if (subActive)
5116  			_autoCompleteSub.setLanguage(buffer->getLangType());
5117  	}
5118  	if ((currentView() == MAIN_VIEW) && !mainActive)
5119  		return;
5120  	if ((currentView() == SUB_VIEW) && !subActive)
5121  		return;
5122  	if (mask & (BufferChangeDirty|BufferChangeFilename))
5123  	{
5124  		if (mask & BufferChangeFilename)
5125  			command(IDM_VIEW_REFRESHTABAR);
5126  		checkDocState();
5127  		setTitle();
5128  		generic_string dir(buffer->getFullPathName());
5129  		PathRemoveFileSpec(dir);
5130  		setWorkingDir(dir.c_str());
5131  	}
5132  	if (mask & (BufferChangeLanguage))
5133  	{
5134  		checkLangsMenu(-1);	
5135  		setLangStatus(buffer->getLangType());
5136  		if (_mainEditView.getCurrentBuffer() == buffer)
5137  			_autoCompleteMain.setLanguage(buffer->getLangType());
5138  		else if (_subEditView.getCurrentBuffer() == buffer)
5139  			_autoCompleteSub.setLanguage(buffer->getLangType());
5140  		SCNotification scnN{};
5141  		scnN.nmhdr.code = NPPN_LANGCHANGED;
5142  		scnN.nmhdr.hwndFrom = _pPublicInterface->getHSelf();
5143  		scnN.nmhdr.idFrom = (uptr_t)_pEditView->getCurrentBufferID();
5144  		_pluginsManager.notify(&scnN);
5145  	}
5146  	if (mask & (BufferChangeFormat|BufferChangeLanguage|BufferChangeUnicode))
5147  	{
5148  		updateStatusBar();
5149  		checkUnicodeMenuItems(&bsol;*buffer->getUnicodeMode()*/);
5150  		setUniModeText();
5151  		setDisplayFormat(buffer->getEolFormat());
5152  		enableConvertMenuItems(buffer->getEolFormat());
5153  	}
5154  	if (mask & (BufferChangeUnicode))
5155  	{
5156  		_mainEditView.maintainStateForNpc();
5157  		_subEditView.maintainStateForNpc();
5158  	}
5159  }
5160  void Notepad_plus::notifyBufferActivated(BufferID bufid, int view)
5161  {
5162  	Buffer * buf = MainFileManager.getBufferByID(bufid);
5163  	buf->increaseRecentTag();
5164  	if (view == MAIN_VIEW)
5165  	{
5166  		_autoCompleteMain.setLanguage(buf->getLangType());
5167  	}
5168  	else if (view == SUB_VIEW)
5169  	{
5170  		_autoCompleteSub.setLanguage(buf->getLangType());
5171  	}
5172  	if (view != currentView())
5173  		return;	
5174  	checkDocState();
5175  	dynamicCheckMenuAndTB();
5176  	setLangStatus(buf->getLangType());
5177  	updateStatusBar();
5178  	checkUnicodeMenuItems(&bsol;*buf->getUnicodeMode()*/);
5179  	setUniModeText();
5180  	setDisplayFormat(buf->getEolFormat());
5181  	enableConvertMenuItems(buf->getEolFormat());
5182  	generic_string dir(buf->getFullPathName());
5183  	PathRemoveFileSpec(dir);
5184  	setWorkingDir(dir.c_str());
5185  	setTitle();
5186  	::InvalidateRect(_mainDocTab.getHSelf(), NULL, FALSE);
5187  	::InvalidateRect(_subDocTab.getHSelf(), NULL, FALSE);
5188  	SCNotification scnN{};
5189  	scnN.nmhdr.code = NPPN_BUFFERACTIVATED;
5190  	scnN.nmhdr.hwndFrom = _pPublicInterface->getHSelf();
5191  	scnN.nmhdr.idFrom = (uptr_t)bufid;
5192  	_pluginsManager.notify(&scnN);
5193  	if (_pDocumentListPanel)
5194  	{
5195  		_pDocumentListPanel->activateItem(bufid, currentView());
5196  	}
5197  	if (_pDocMap && (!_pDocMap->isClosed()) && _pDocMap->isVisible())
5198  	{
5199  		_pDocMap->reloadMap();
5200  		_pDocMap->setSyntaxHiliting();
5201  	}
5202  	if (_pFuncList && (!_pFuncList->isClosed()) && _pFuncList->isVisible())
5203  	{
5204  		_pFuncList->reload();
5205  	}
5206  	_linkTriggered = true;
5207  }
5208  std::vector<generic_string> Notepad_plus::loadCommandlineParams(const TCHAR * commandLine, const CmdLineParamsDTO * pCmdParams)
5209  {
5210  	if (!commandLine || ! pCmdParams)
5211  		return std::vector<generic_string>();
5212  	NppParameters& nppParams = NppParameters::getInstance();
5213  	const NppGUI& nppGUI = nppParams.getNppGUI();
5214  	FileNameStringSplitter fnss(commandLine);
5215  	if (pCmdParams->_isSessionFile && fnss.size() == 1)
5216  	{
5217  		Session session2Load;
5218  		if (nppParams.loadSession(session2Load, fnss.getFileName(0)))
5219  		{
5220  			const bool isSnapshotMode = false;
5221  			const bool shouldLoadFileBrowser = true;
5222  			if ((nppGUI._multiInstSetting == multiInstOnSession) || (nppGUI._multiInstSetting == multiInst))
5223  				nppParams.setLoadedSessionFilePath(fnss.getFileName(0));
5224  			loadSession(session2Load, isSnapshotMode, shouldLoadFileBrowser);
5225  		}
5226  		return std::vector<generic_string>();
5227  	}
5228   	LangType lt = pCmdParams->_langType;
5229  	generic_string udl = pCmdParams->_udlName;
5230  	intptr_t lineNumber =  pCmdParams->_line2go;
5231  	intptr_t columnNumber = pCmdParams->_column2go;
5232  	intptr_t positionNumber = pCmdParams->_pos2go;
5233  	bool recursive = pCmdParams->_isRecursive;
5234  	bool readOnly = pCmdParams->_isReadOnly;
5235  	bool openFoldersAsWorkspace = pCmdParams->_openFoldersAsWorkspace;
5236  	bool monitorFiles = pCmdParams->_monitorFiles;
5237  	if (openFoldersAsWorkspace)
5238  	{
5239  		return fnss.getFileNames();
5240  	}
5241  	BufferID lastOpened = BUFFER_INVALID;
5242  	for (int i = 0, len = fnss.size(); i < len ; ++i)
5243  	{
5244  		const TCHAR *pFn = fnss.getFileName(i);
5245  		if (!pFn) return std::vector<generic_string>();
5246  		BufferID bufID = doOpen(pFn, recursive, readOnly);
5247  		if (bufID == BUFFER_INVALID)	
5248  			continue;
5249  		lastOpened = bufID;
5250  		Buffer* pBuf = MainFileManager.getBufferByID(bufID);
5251  		if (!udl.empty())
5252  		{
5253  			pBuf->setLangType(L_USER, udl.c_str());
5254  		}
5255  		else if (lt != L_EXTERNAL && lt < nppParams.L_END)
5256  		{
5257  			pBuf->setLangType(lt);
5258  		}
5259  		if (lineNumber >= 0 || positionNumber >= 0)
5260  		{
5261  			int iView = currentView();	
5262  			switchToFile(bufID);	
5263  			if (positionNumber >= 0)
5264  			{
5265  				if (positionNumber > 0)
5266  				{
5267  					auto before = _pEditView->execute(SCI_POSITIONBEFORE, positionNumber);
5268  					positionNumber = _pEditView->execute(SCI_POSITIONAFTER, before);
5269  				}
5270  				_pEditView->execute(SCI_GOTOPOS, positionNumber);
5271  			}
5272  			else if (columnNumber < 0)
5273  			{
5274  				_pEditView->execute(SCI_GOTOLINE, lineNumber - 1);
5275  			}
5276  			else
5277  			{
5278  				auto pos = _pEditView->execute(SCI_FINDCOLUMN, lineNumber - 1, columnNumber - 1);
5279  				_pEditView->execute(SCI_GOTOPOS, pos);
5280  			}
5281  			_pEditView->scrollPosToCenter(_pEditView->execute(SCI_GETCURRENTPOS));
5282  			switchEditViewTo(iView);	
5283  		}
5284  		if (monitorFiles)
5285  		{
5286  			monitoringStartOrStopAndUpdateUI(pBuf, true);
5287  			createMonitoringThread(pBuf);
5288  		}
5289  	}
5290  	if (lastOpened != BUFFER_INVALID)
5291      {
5292  		switchToFile(lastOpened);
5293  	}
5294  	return fnss.getFileNames();
5295  }
5296  void Notepad_plus::setFindReplaceFolderFilter(const TCHAR *dir, const TCHAR *filter)
5297  {
5298  	generic_string fltr;
5299  	NppParameters& nppParam = NppParameters::getInstance();
5300  	FindHistory & findHistory = nppParam.getFindHistory();
5301  	if (!dir && findHistory._isFolderFollowDoc)
5302  	{
5303  		dir = nppParam.getWorkingDir();
5304  	}
5305  	if (!filter && findHistory._isFilterFollowDoc)
5306  	{
5307  		const TCHAR *ext = NULL;
5308  		LangType lt = _pEditView->getCurrentBuffer()->getLangType();
5309  		if (lt == L_USER)
5310  		{
5311  			Buffer * buf = _pEditView->getCurrentBuffer();
5312  			UserLangContainer * userLangContainer = nppParam.getULCFromName(buf->getUserDefineLangName());
5313  			if (userLangContainer)
5314  				ext = userLangContainer->getExtention();
5315  		}
5316  		else
5317  		{
5318  			ext = nppParam.getLangExtFromLangType(lt);
5319  		}
5320  		if (ext && ext[0])
5321  		{
5322  			fltr = TEXT("");
5323  			vector<generic_string> vStr;
5324  			cutString(ext, vStr);
5325  			for (size_t i = 0 ,len = vStr.size(); i < len; ++i)
5326  			{
5327  				fltr += TEXT("*.");
5328  				fltr += vStr[i] + TEXT(" ");
5329  			}
5330  		}
5331  		else
5332  		{
5333  			fltr = TEXT("*.*");
5334  		}
5335  		filter = fltr.c_str();
5336  	}
5337  	_findReplaceDlg.setFindInFilesDirFilter(dir, filter);
5338  }
5339  vector<generic_string> Notepad_plus::addNppComponents(const TCHAR *destDir, const TCHAR *extFilterName, const TCHAR *extFilter)
5340  {
5341  	CustomFileDialog fDlg(_pPublicInterface->getHSelf());
5342  	fDlg.setExtFilter(extFilterName, extFilter);
5343      vector<generic_string> copiedFiles;
5344  	const auto& fns = fDlg.doOpenMultiFilesDlg();
5345      if (!fns.empty())
5346      {
5347  		generic_string destDirName = (NppParameters::getInstance()).getNppPath();
5348          pathAppend(destDirName, destDir);
5349          if (!::PathFileExists(destDirName.c_str()))
5350          {
5351              ::CreateDirectory(destDirName.c_str(), NULL);
5352          }
5353          destDirName += TEXT("\\");
5354          size_t sz = fns.size();
5355          for (size_t i = 0 ; i < sz ; ++i)
5356          {
5357              if (::PathFileExists(fns.at(i).c_str()))
5358              {
5359                  generic_string destName = destDirName;
5360                  destName += ::PathFindFileName(fns.at(i).c_str());
5361                  if (::CopyFile(fns.at(i).c_str(), destName.c_str(), FALSE))
5362                      copiedFiles.push_back(destName.c_str());
5363              }
5364          }
5365      }
5366      return copiedFiles;
5367  }
5368  vector<generic_string> Notepad_plus::addNppPlugins(const TCHAR *extFilterName, const TCHAR *extFilter)
5369  {
5370  	CustomFileDialog fDlg(_pPublicInterface->getHSelf());
5371      fDlg.setExtFilter(extFilterName, extFilter);
5372      vector<generic_string> copiedFiles;
5373  	const auto& fns = fDlg.doOpenMultiFilesDlg();
5374  	if (!fns.empty())
5375      {
5376  		generic_string destDirName = (NppParameters::getInstance()).getPluginRootDir();
5377          if (!::PathFileExists(destDirName.c_str()))
5378          {
5379              ::CreateDirectory(destDirName.c_str(), NULL);
5380          }
5381          size_t sz = fns.size();
5382          for (size_t i = 0 ; i < sz ; ++i)
5383          {
5384              if (::PathFileExists(fns.at(i).c_str()))
5385              {
5386                  generic_string destName = destDirName;
5387  				generic_string nameExt = ::PathFindFileName(fns.at(i).c_str());
5388  				auto pos = nameExt.find_last_of(TEXT("."));
5389  				if (pos == generic_string::npos)
5390  					continue;
5391  				generic_string name = nameExt.substr(0, pos);
5392  				pathAppend(destName, name);
5393  				if (!::PathFileExists(destName.c_str()))
5394  				{
5395  					::CreateDirectory(destName.c_str(), NULL);
5396  				}
5397  				pathAppend(destName, nameExt);
5398                  if (::CopyFile(fns.at(i).c_str(), destName.c_str(), FALSE))
5399                      copiedFiles.push_back(destName.c_str());
5400              }
5401          }
5402      }
5403      return copiedFiles;
5404  }
5405  void Notepad_plus::setWorkingDir(const TCHAR *dir)
5406  {
5407  	NppParameters& params = NppParameters::getInstance();
5408  	if (params.getNppGUI()._openSaveDir == dir_last)
5409  		return;
5410  	if (params.getNppGUI()._openSaveDir == dir_userDef)
5411  	{
5412  		params.setWorkingDir(NULL);
5413  	}
5414  	else if (dir && PathIsDirectory(dir))
5415  	{
5416  		params.setWorkingDir(dir);
5417  	}
5418  }
5419  int Notepad_plus::getLangFromMenuName(const TCHAR * langName)
5420  {
5421  	int	id	= 0;
5422  	TCHAR menuLangName[menuItemStrLenMax];
5423  	for ( int i = IDM_LANG_C; i <= IDM_LANG_USER; ++i )
5424  		if ( ::GetMenuString( _mainMenuHandle, i, menuLangName, menuItemStrLenMax, MF_BYCOMMAND ) )
5425  			if ( !lstrcmp( langName, menuLangName ) )
5426  			{
5427  				id	= i;
5428  				break;
5429  			}
5430  	if ( id == 0 )
5431  	{
5432  		for ( int i = IDM_LANG_USER + 1; i <= IDM_LANG_USER_LIMIT; ++i )
5433  			if ( ::GetMenuString( _mainMenuHandle, i, menuLangName, menuItemStrLenMax, MF_BYCOMMAND ) )
5434  				if ( !lstrcmp( langName, menuLangName ) )
5435  				{
5436  					id	= i;
5437  					break;
5438  				}
5439  	}
5440  	return id;
5441  }
5442  generic_string Notepad_plus::getLangFromMenu(const Buffer * buf)
5443  {
5444  	int	id;
5445  	generic_string userLangName;
5446  	TCHAR menuLangName[menuItemStrLenMax]{};
5447  	id = (NppParameters::getInstance()).langTypeToCommandID( buf->getLangType() );
5448  	if ( ( id != IDM_LANG_USER ) || !( buf->isUserDefineLangExt() ) )
5449  	{
5450  		::GetMenuString(_mainMenuHandle, id, menuLangName, menuItemStrLenMax, MF_BYCOMMAND);
5451  		userLangName = menuLangName;
5452  	}
5453  	else
5454  	{
5455  		userLangName = buf->getUserDefineLangName();
5456  	}
5457  	return	userLangName;
5458  }
5459  Style * Notepad_plus::getStyleFromName(const TCHAR *styleName)
5460  {
5461  	return NppParameters::getInstance().getMiscStylerArray().findByName(styleName);
5462  }
5463  bool Notepad_plus::noOpenedDoc() const
5464  {
5465  	if (_mainDocTab.isVisible() && _subDocTab.isVisible())
5466  		return false;
5467  	if (_pDocTab->nbItem() == 1)
5468  	{
5469  		BufferID buffer = _pDocTab->getBufferByIndex(0);
5470  		Buffer * buf = MainFileManager.getBufferByID(buffer);
5471  		if (!buf->isDirty() && buf->isUntitled())
5472  			return true;
5473  	}
5474  	return false;
5475  }
5476  bool Notepad_plus::reloadLang()
5477  {
5478  	NppParameters& nppParam = NppParameters::getInstance();
5479  	if (!nppParam.reloadLang())
5480  	{
5481  		return false;
5482  	}
5483  	TiXmlDocumentA *nativeLangDocRootA = nppParam.getNativeLangA();
5484  	if (!nativeLangDocRootA)
5485  	{
5486  		return false;
5487  	}
5488      _nativeLangSpeaker.init(nativeLangDocRootA, true);
5489      nppParam.reloadContextMenuFromXmlTree(_mainMenuHandle, _pluginsManager.getMenuHandle());
5490  	_nativeLangSpeaker.changeMenuLang(_mainMenuHandle);
5491      ::DrawMenuBar(_pPublicInterface->getHSelf());
5492  	vector<MenuItemUnit> & tmp = nppParam.getContextMenuItems();
5493  	size_t len = tmp.size();
5494  	TCHAR menuName[menuItemStrLenMax];
5495  	for (size_t i = 0 ; i < len ; ++i)
5496  	{
5497  		if (tmp[i]._itemName == TEXT(""))
5498  		{
5499  			::GetMenuString(_mainMenuHandle, tmp[i]._cmdID, menuName, menuItemStrLenMax, MF_BYCOMMAND);
5500  			tmp[i]._itemName = purgeMenuItemString(menuName);
5501  		}
5502  	}
5503  	updateCommandShortcuts();
5504  	_accelerator.updateFullMenu();
5505  	_scintaccelerator.updateKeys();
5506  	if (_tabPopupMenu.isCreated())
5507  	{
5508  		_nativeLangSpeaker.changeLangTabContextMenu(_tabPopupMenu.getMenuHandle());
5509  	}
5510  	if (_tabPopupDropMenu.isCreated())
5511  	{
5512  		_nativeLangSpeaker.changeLangTabDropContextMenu(_tabPopupDropMenu.getMenuHandle());
5513  	}
5514  	if (_fileSwitcherMultiFilePopupMenu.isCreated())
5515  	{
5516  	}
5517  	if (_preference.isCreated())
5518  	{
5519  		_nativeLangSpeaker.changePrefereceDlgLang(_preference);
5520  	}
5521  	if (_configStyleDlg.isCreated())
5522  	{
5523          _nativeLangSpeaker.changeConfigLang(_configStyleDlg.getHSelf());
5524  	}
5525  	if (_findReplaceDlg.isCreated())
5526  	{
5527  		_nativeLangSpeaker.changeFindReplaceDlgLang(_findReplaceDlg);
5528  	}
5529  	if (_goToLineDlg.isCreated())
5530  	{
5531  		_nativeLangSpeaker.changeDlgLang(_goToLineDlg.getHSelf(), "GoToLine");
5532  	}
5533  	if (_runDlg.isCreated())
5534  	{
5535  		_nativeLangSpeaker.changeDlgLang(_runDlg.getHSelf(), "Run");
5536  	}
5537  	if (_md5FromFilesDlg.isCreated())
5538  	{
5539  		_nativeLangSpeaker.changeDlgLang(_md5FromFilesDlg.getHSelf(), "MD5FromFilesDlg");
5540  	}
5541  	if (_md5FromTextDlg.isCreated())
5542  	{
5543  		_nativeLangSpeaker.changeDlgLang(_md5FromTextDlg.getHSelf(), "MD5FromTextDlg");
5544  	}
5545  	if (_sha2FromFilesDlg.isCreated())
5546  	{
5547  		_nativeLangSpeaker.changeDlgLang(_sha2FromFilesDlg.getHSelf(), "SHA256FromFilesDlg");
5548  	}
5549  	if (_sha2FromTextDlg.isCreated())
5550  	{
5551  		_nativeLangSpeaker.changeDlgLang(_sha2FromTextDlg.getHSelf(), "SHA256FromTextDlg");
5552  	}
5553  	if (_runMacroDlg.isCreated())
5554  	{
5555  		_nativeLangSpeaker.changeDlgLang(_runMacroDlg.getHSelf(), "MultiMacro");
5556  	}
5557  	if (_incrementFindDlg.isCreated())
5558  	{
5559  		_nativeLangSpeaker.changeDlgLang(_incrementFindDlg.getHSelf(), "IncrementalFind");
5560  	}
5561  	if (_findCharsInRangeDlg.isCreated())
5562  	{
5563  		_nativeLangSpeaker.changeDlgLang(_findCharsInRangeDlg.getHSelf(), "FindCharsInRange");
5564  	}
5565  	if (_colEditorDlg.isCreated())
5566  	{
5567          _nativeLangSpeaker.changeDlgLang(_colEditorDlg.getHSelf(), "ColumnEditor");
5568  	}
5569  	if (_pluginsAdminDlg.isCreated())
5570  	{
5571  		_nativeLangSpeaker.changePluginsAdminDlgLang(_pluginsAdminDlg);
5572  	}
5573  	UserDefineDialog *udd = _pEditView->getUserDefineDlg();
5574  	if (udd->isCreated())
5575  	{
5576  		_nativeLangSpeaker.changeUserDefineLang(udd);
5577  	}
5578  	_lastRecentFileList.setLangEncoding(_nativeLangSpeaker.getLangEncoding());
5579  	return true;
5580  }
5581  void Notepad_plus::launchClipboardHistoryPanel()
5582  {
5583  	NppParameters& nppParams = NppParameters::getInstance();
5584  	if (!_pClipboardHistoryPanel)
5585  	{
5586  		_pClipboardHistoryPanel = new ClipboardHistoryPanel();
5587  		_pClipboardHistoryPanel->init(_pPublicInterface->getHinst(), _pPublicInterface->getHSelf(), &_pEditView);
5588  		NativeLangSpeaker *pNativeSpeaker = nppParams.getNativeLangSpeaker();
5589  		bool isRTL = pNativeSpeaker->isRTL();
5590  		tTbData	data = {};
5591  		_pClipboardHistoryPanel->create(&data, isRTL);
5592  		::SendMessage(_pPublicInterface->getHSelf(), NPPM_MODELESSDIALOG, MODELESSDIALOGREMOVE, reinterpret_cast<LPARAM>(_pClipboardHistoryPanel->getHSelf()));
5593  		data.uMask = DWS_DF_CONT_RIGHT | DWS_ICONTAB | DWS_USEOWNDARKMODE;
5594  		int icoID = IDR_CLIPBOARDPANEL_ICO;
5595  		if (NppDarkMode::isEnabled())
5596  			icoID = IDR_CLIPBOARDPANEL_ICO_DM;
5597  		else if (nppParams.getNppGUI()._toolBarStatus != TB_STANDARD)
5598  			icoID = IDR_CLIPBOARDPANEL_ICO2;
5599  		data.hIconTab = (HICON)::LoadImage(_pPublicInterface->getHinst(), MAKEINTRESOURCE(icoID), IMAGE_ICON, 14, 14, LR_LOADMAP3DCOLORS | LR_LOADTRANSPARENT);
5600  		data.pszModuleName = NPP_INTERNAL_FUCTION_STR;
5601  		data.dlgID = IDM_EDIT_CLIPBOARDHISTORY_PANEL;
5602  		generic_string title_temp = pNativeSpeaker->getAttrNameStr(CH_PROJECTPANELTITLE, "ClipboardHistory", "PanelTitle");
5603  		static TCHAR title[32];
5604  		if (title_temp.length() < 32)
5605  		{
5606  			wcscpy_s(title, title_temp.c_str());
5607  			data.pszName = title;
5608  		}
5609  		::SendMessage(_pPublicInterface->getHSelf(), NPPM_DMMREGASDCKDLG, 0, reinterpret_cast<LPARAM>(&data));
5610  		COLORREF fgColor = nppParams.getCurrentDefaultFgColor();
5611  		COLORREF bgColor = nppParams.getCurrentDefaultBgColor();
5612  		_pClipboardHistoryPanel->setBackgroundColor(bgColor);
5613  		_pClipboardHistoryPanel->setForegroundColor(fgColor);
5614  	}
5615  	_pClipboardHistoryPanel->display();
5616  }
5617  void Notepad_plus::launchDocumentListPanel(bool changeFromBtnCmd)
5618  {
5619  	if (!_pDocumentListPanel)
5620  	{
5621  		NppParameters& nppParams = NppParameters::getInstance();
5622  		int tabBarStatus = nppParams.getNppGUI()._tabStatus;
5623  		_pDocumentListPanel = new VerticalFileSwitcher;
5624  		HIMAGELIST hImgLst = nullptr;
5625  		const int tabIconSet = changeFromBtnCmd ? -1 : NppDarkMode::getTabIconSet(NppDarkMode::isEnabled());
5626  		switch (tabIconSet)
5627  		{
5628  			case 0:
5629  			{
5630  				hImgLst = _docTabIconList.getHandle();
5631  				break;
5632  			}
5633  			case 1:
5634  			{
5635  				hImgLst = _docTabIconListAlt.getHandle();
5636  				break;
5637  			}
5638  			case 2:
5639  			{
5640  				hImgLst = _docTabIconListDarkMode.getHandle();
5641  				break;
5642  			}
5643  			default:
5644  				hImgLst = (((tabBarStatus & TAB_ALTICONS) == TAB_ALTICONS) ? _docTabIconListAlt.getHandle() : NppDarkMode::isEnabled() ? _docTabIconListDarkMode.getHandle() : _docTabIconList.getHandle());
5645  		}
5646  		_pDocumentListPanel->init(_pPublicInterface->getHinst(), _pPublicInterface->getHSelf(), hImgLst);
5647  		NativeLangSpeaker *pNativeSpeaker = nppParams.getNativeLangSpeaker();
5648  		bool isRTL = pNativeSpeaker->isRTL();
5649  		tTbData	data = {};
5650  		_pDocumentListPanel->create(&data, isRTL);
5651  		::SendMessage(_pPublicInterface->getHSelf(), NPPM_MODELESSDIALOG, MODELESSDIALOGREMOVE, reinterpret_cast<LPARAM>(_pDocumentListPanel->getHSelf()));
5652  		data.uMask = DWS_DF_CONT_LEFT | DWS_ICONTAB | DWS_USEOWNDARKMODE;
5653  		int icoID = IDR_DOCLIST_ICO;
5654  		if (NppDarkMode::isEnabled())
5655  			icoID = IDR_DOCLIST_ICO_DM;
5656  		else if (nppParams.getNppGUI()._toolBarStatus != TB_STANDARD)
5657  			icoID = IDR_DOCLIST_ICO2;
5658  		data.hIconTab = (HICON)::LoadImage(_pPublicInterface->getHinst(), MAKEINTRESOURCE(icoID), IMAGE_ICON, 14, 14, LR_LOADMAP3DCOLORS | LR_LOADTRANSPARENT);
5659  		data.pszModuleName = NPP_INTERNAL_FUCTION_STR;
5660  		data.dlgID = IDM_VIEW_DOCLIST;
5661  		generic_string title_temp = pNativeSpeaker->getAttrNameStr(FS_PROJECTPANELTITLE, "DocList", "PanelTitle");
5662  		static TCHAR title[32];
5663  		if (title_temp.length() < 32)
5664  		{
5665  			wcscpy_s(title, title_temp.c_str());
5666  			data.pszName = title;
5667  		}
5668  		::SendMessage(_pPublicInterface->getHSelf(), NPPM_DMMREGASDCKDLG, 0, reinterpret_cast<LPARAM>(&data));
5669  		COLORREF fgColor = nppParams.getCurrentDefaultFgColor();
5670  		COLORREF bgColor = nppParams.getCurrentDefaultBgColor();
5671  		_pDocumentListPanel->setBackgroundColor(bgColor);
5672  		_pDocumentListPanel->setForegroundColor(fgColor);
5673  	}
5674  	_pDocumentListPanel->display();
5675  }
5676  void Notepad_plus::launchAnsiCharPanel()
5677  {
5678  	if (!_pAnsiCharPanel)
5679  	{
5680  		_pAnsiCharPanel = new AnsiCharPanel();
5681  		_pAnsiCharPanel->init(_pPublicInterface->getHinst(), _pPublicInterface->getHSelf(), &_pEditView);
5682  		NppParameters& nppParams = NppParameters::getInstance();
5683  		NativeLangSpeaker *pNativeSpeaker = nppParams.getNativeLangSpeaker();
5684  		bool isRTL = pNativeSpeaker->isRTL();
5685  		tTbData	data = {};
5686  		_pAnsiCharPanel->create(&data, isRTL);
5687  		::SendMessage(_pPublicInterface->getHSelf(), NPPM_MODELESSDIALOG, MODELESSDIALOGREMOVE, reinterpret_cast<LPARAM>(_pAnsiCharPanel->getHSelf()));
5688  		data.uMask = DWS_DF_CONT_RIGHT | DWS_ICONTAB | DWS_USEOWNDARKMODE;
5689  		int icoID = IDR_ASCIIPANEL_ICO;
5690  		if (NppDarkMode::isEnabled())
5691  			icoID = IDR_ASCIIPANEL_ICO_DM;
5692  		else if (nppParams.getNppGUI()._toolBarStatus != TB_STANDARD)
5693  			icoID = IDR_ASCIIPANEL_ICO2;
5694  		data.hIconTab = (HICON)::LoadImage(_pPublicInterface->getHinst(), MAKEINTRESOURCE(icoID), IMAGE_ICON, 14, 14, LR_LOADMAP3DCOLORS | LR_LOADTRANSPARENT);
5695  		data.pszModuleName = NPP_INTERNAL_FUCTION_STR;
5696  		data.dlgID = IDM_EDIT_CHAR_PANEL;
5697  		generic_string title_temp = pNativeSpeaker->getAttrNameStr(AI_PROJECTPANELTITLE, "AsciiInsertion", "PanelTitle");
5698  		static TCHAR title[85];
5699  		if (title_temp.length() < 85)
5700  		{
5701  			wcscpy_s(title, title_temp.c_str());
5702  			data.pszName = title;
5703  		}
5704  		::SendMessage(_pPublicInterface->getHSelf(), NPPM_DMMREGASDCKDLG, 0, reinterpret_cast<LPARAM>(&data));
5705  		COLORREF fgColor = nppParams.getCurrentDefaultFgColor();
5706  		COLORREF bgColor = nppParams.getCurrentDefaultBgColor();
5707  		_pAnsiCharPanel->setBackgroundColor(bgColor);
5708  		_pAnsiCharPanel->setForegroundColor(fgColor);
5709  	}
5710  	_pAnsiCharPanel->display();
5711  }
5712  void Notepad_plus::launchFileBrowser(const vector<generic_string> & folders, const generic_string& selectedItemPath, bool fromScratch)
5713  {
5714  	if (!_pFileBrowser)
5715  	{
5716  		_pFileBrowser = new FileBrowser;
5717  		_pFileBrowser->init(_pPublicInterface->getHinst(), _pPublicInterface->getHSelf());
5718  		tTbData	data = {};
5719  		_pFileBrowser->create(&data, _nativeLangSpeaker.isRTL());
5720  		data.pszName = TEXT("ST");
5721  		NppParameters& nppParams = NppParameters::getInstance();
5722  		::SendMessage(_pPublicInterface->getHSelf(), NPPM_MODELESSDIALOG, MODELESSDIALOGREMOVE, reinterpret_cast<LPARAM>(_pFileBrowser->getHSelf()));
5723  		data.uMask = DWS_DF_CONT_LEFT | DWS_ICONTAB | DWS_USEOWNDARKMODE;
5724  		int icoID = IDR_FILEBROWSER_ICO;
5725  		if (NppDarkMode::isEnabled())
5726  			icoID = IDR_FILEBROWSER_ICO_DM;
5727  		else if (nppParams.getNppGUI()._toolBarStatus != TB_STANDARD)
5728  			icoID = IDR_FILEBROWSER_ICO2;
5729  		data.hIconTab = (HICON)::LoadImage(_pPublicInterface->getHinst(), MAKEINTRESOURCE(icoID), IMAGE_ICON, 14, 14, LR_LOADMAP3DCOLORS | LR_LOADTRANSPARENT);
5730  		data.pszModuleName = NPP_INTERNAL_FUCTION_STR;
5731  		data.dlgID = IDM_VIEW_FILEBROWSER;
5732  		NativeLangSpeaker *pNativeSpeaker = nppParams.getNativeLangSpeaker();
5733  		generic_string title_temp = pNativeSpeaker->getAttrNameStr(FB_PANELTITLE, FOLDERASWORKSPACE_NODE, "PanelTitle");
5734  		static TCHAR title[32];
5735  		if (title_temp.length() < 32)
5736  		{
5737  			wcscpy_s(title, title_temp.c_str());
5738  			data.pszName = title;
5739  		}
5740  		::SendMessage(_pPublicInterface->getHSelf(), NPPM_DMMREGASDCKDLG, 0, reinterpret_cast<LPARAM>(&data));
5741  		COLORREF fgColor = nppParams.getCurrentDefaultFgColor();
5742  		COLORREF bgColor = nppParams.getCurrentDefaultBgColor();
5743  		_pFileBrowser->setBackgroundColor(bgColor);
5744  		_pFileBrowser->setForegroundColor(fgColor);
5745  	}
5746  	if (fromScratch)
5747  	{
5748  		_pFileBrowser->deleteAllFromTree();
5749  	}
5750  	for (size_t i = 0; i <folders.size(); ++i)
5751  	{
5752  		_pFileBrowser->addRootFolder(folders[i]);
5753  	}
5754  	_pFileBrowser->display();
5755  	_pFileBrowser->selectItemFromPath(selectedItemPath);
5756  	checkMenuItem(IDM_VIEW_FILEBROWSER, true);
5757  	_toolBar.setCheck(IDM_VIEW_FILEBROWSER, true);
5758  	_pFileBrowser->setClosed(false);
5759  }
5760  void Notepad_plus::checkProjectMenuItem()
5761  {
5762  	HMENU viewMenu = ::GetSubMenu(_mainMenuHandle, MENUINDEX_VIEW);
5763  	int viewMenuCount = ::GetMenuItemCount(viewMenu);
5764  	for (int i = 0; i < viewMenuCount; i++)
5765  	{
5766  		HMENU subMenu = ::GetSubMenu(viewMenu, i);
5767  		if (subMenu)
5768  		{
5769  			int subMenuCount = ::GetMenuItemCount(subMenu);
5770  			bool found = false;
5771  			bool checked = false;
5772  			for (int j = 0; j < subMenuCount; j++)
5773  			{
5774  				UINT const ids [] = {IDM_VIEW_PROJECT_PANEL_1, IDM_VIEW_PROJECT_PANEL_2, IDM_VIEW_PROJECT_PANEL_3};
5775  				UINT id = GetMenuItemID (subMenu, j);
5776  				for (size_t k = 0; k < _countof(ids); k++)
5777  				{
5778  					if (id == ids [k])
5779  					{
5780  						found = true;
5781  						UINT s = GetMenuState(subMenu, j, MF_BYPOSITION);
5782  						if (s & MF_CHECKED)
5783  						{
5784  							checked = true;
5785  							break;
5786  						}
5787  					}
5788  				}
5789  			}
5790  			if (found)
5791  			{
5792  				CheckMenuItem(viewMenu, i, (checked ? MF_CHECKED : MF_UNCHECKED) | MF_BYPOSITION);
5793  				break;
5794  			}
5795  		}
5796  	}
5797  }
5798  void Notepad_plus::launchProjectPanel(int cmdID, ProjectPanel ** pProjPanel, int panelID)
5799  {
5800  	NppParameters& nppParam = NppParameters::getInstance();
5801  	if (!(*pProjPanel))
5802  	{
5803  		(*pProjPanel) = new ProjectPanel;
5804  		(*pProjPanel)->init(_pPublicInterface->getHinst(), _pPublicInterface->getHSelf(), panelID);
5805  		(*pProjPanel)->setWorkSpaceFilePath(nppParam.getWorkSpaceFilePath(panelID));
5806  		NativeLangSpeaker *pNativeSpeaker = nppParam.getNativeLangSpeaker();
5807  		bool isRTL = pNativeSpeaker->isRTL();
5808  		tTbData	data = {};
5809  		(*pProjPanel)->create(&data, isRTL);
5810  		data.pszName = TEXT("ST");
5811  		::SendMessage(_pPublicInterface->getHSelf(), NPPM_MODELESSDIALOG, MODELESSDIALOGREMOVE, reinterpret_cast<LPARAM>((*pProjPanel)->getHSelf()));
5812  		data.uMask = DWS_DF_CONT_LEFT | DWS_ICONTAB | DWS_USEOWNDARKMODE;
5813  		int icoID = IDR_PROJECTPANEL_ICO;
5814  		if (NppDarkMode::isEnabled())
5815  			icoID = IDR_PROJECTPANEL_ICO_DM;
5816  		else if (nppParam.getNppGUI()._toolBarStatus != TB_STANDARD)
5817  			icoID = IDR_PROJECTPANEL_ICO2;
5818  		data.hIconTab = (HICON)::LoadImage(_pPublicInterface->getHinst(), MAKEINTRESOURCE(icoID), IMAGE_ICON, 14, 14, LR_LOADMAP3DCOLORS | LR_LOADTRANSPARENT);
5819  		data.pszModuleName = NPP_INTERNAL_FUCTION_STR;
5820  		data.dlgID = cmdID;
5821  		generic_string title_no = to_wstring (panelID + 1);
5822  		generic_string title_temp = pNativeSpeaker->getAttrNameStr(PM_PROJECTPANELTITLE, "ProjectManager", "PanelTitle") + TEXT(" ") + title_no;
5823  		(*pProjPanel)->setPanelTitle(title_temp);
5824  		data.pszName = (*pProjPanel)->getPanelTitle();
5825  		::SendMessage(_pPublicInterface->getHSelf(), NPPM_DMMREGASDCKDLG, 0, reinterpret_cast<LPARAM>(&data));
5826  		COLORREF fgColor = nppParam.getCurrentDefaultFgColor();
5827  		COLORREF bgColor = nppParam.getCurrentDefaultBgColor();
5828  		(*pProjPanel)->setBackgroundColor(bgColor);
5829  		(*pProjPanel)->setForegroundColor(fgColor);
5830  	}
5831  	else
5832  	{
5833  		(*pProjPanel)->openWorkSpace(nppParam.getWorkSpaceFilePath(panelID));
5834  	}
5835  	(*pProjPanel)->display();
5836  	checkMenuItem(cmdID, true);
5837  	checkProjectMenuItem();
5838  	(*pProjPanel)->setClosed(false);
5839  }
5840  void Notepad_plus::launchDocMap()
5841  {
5842  	NppParameters& nppParam = NppParameters::getInstance();
5843  	if (!nppParam.isTransparentAvailable())
5844  	{
5845  		_nativeLangSpeaker.messageBox("PrehistoricSystemDetected",
5846  			_pPublicInterface->getHSelf(),
5847  			TEXT("It seems you still use a prehistoric system. This feature works only on a modern system, sorry."),
5848  			TEXT("Prehistoric system detected"),
5849  			MB_OK);
5850  		return;
5851  	}
5852  	if (!_pDocMap)
5853  	{
5854  		_pDocMap = new DocumentMap();
5855  		_pDocMap->init(_pPublicInterface->getHinst(), _pPublicInterface->getHSelf(), &_pEditView);
5856  		tTbData	data = {};
5857  		_pDocMap->create(&data);
5858  		::SendMessage(_pPublicInterface->getHSelf(), NPPM_MODELESSDIALOG, MODELESSDIALOGREMOVE, reinterpret_cast<LPARAM>(_pDocMap->getHSelf()));
5859  		data.uMask = DWS_DF_CONT_RIGHT | DWS_ICONTAB | DWS_USEOWNDARKMODE;
5860  		int icoID = IDR_DOCMAP_ICO;
5861  		if (NppDarkMode::isEnabled())
5862  			icoID = IDR_DOCMAP_ICO_DM;
5863  		else if (nppParam.getNppGUI()._toolBarStatus != TB_STANDARD)
5864  			icoID = IDR_DOCMAP_ICO2;
5865  		data.hIconTab = (HICON)::LoadImage(_pPublicInterface->getHinst(), MAKEINTRESOURCE(icoID), IMAGE_ICON, 14, 14, LR_LOADMAP3DCOLORS | LR_LOADTRANSPARENT);
5866  		data.pszModuleName = NPP_INTERNAL_FUCTION_STR;
5867  		data.dlgID = IDM_VIEW_DOC_MAP;
5868  		NativeLangSpeaker *pNativeSpeaker = nppParam.getNativeLangSpeaker();
5869  		generic_string title_temp = pNativeSpeaker->getAttrNameStr(DM_PANELTITLE, "DocumentMap", "PanelTitle");
5870  		static TCHAR title[32];
5871  		if (title_temp.length() < 32)
5872  		{
5873  			wcscpy_s(title, title_temp.c_str());
5874  			data.pszName = title;
5875  		}
5876  		::SendMessage(_pPublicInterface->getHSelf(), NPPM_DMMREGASDCKDLG, 0, reinterpret_cast<LPARAM>(&data));
5877  	}
5878  	_pDocMap->initWrapMap();
5879  	_pDocMap->wrapMap();
5880  	_pDocMap->display();
5881  	_pEditView->getFocus();
5882  }
5883  void Notepad_plus::launchFunctionList()
5884  {
5885  	if (!_pFuncList)
5886  	{
5887  		_pFuncList = new FunctionListPanel();
5888  		_pFuncList->init(_pPublicInterface->getHinst(), _pPublicInterface->getHSelf(), &_pEditView);
5889  		tTbData	data = {};
5890  		_pFuncList->create(&data);
5891  		::SendMessage(_pPublicInterface->getHSelf(), NPPM_MODELESSDIALOG, MODELESSDIALOGREMOVE, reinterpret_cast<LPARAM>(_pFuncList->getHSelf()));
5892  		data.uMask = DWS_DF_CONT_RIGHT | DWS_ICONTAB | DWS_USEOWNDARKMODE;
5893  		NppParameters& nppParam = NppParameters::getInstance();
5894  		int icoID = IDR_FUNC_LIST_ICO;
5895  		if (NppDarkMode::isEnabled())
5896  			icoID = IDR_FUNC_LIST_ICO_DM;
5897  		else if (nppParam.getNppGUI()._toolBarStatus != TB_STANDARD)
5898  			icoID = IDR_FUNC_LIST_ICO2;
5899  		data.hIconTab = (HICON)::LoadImage(_pPublicInterface->getHinst(), MAKEINTRESOURCE(icoID), IMAGE_ICON, 14, 14, LR_LOADMAP3DCOLORS | LR_LOADTRANSPARENT);
5900  		data.pszModuleName = NPP_INTERNAL_FUCTION_STR;
5901  		data.dlgID = IDM_VIEW_FUNC_LIST;
5902  		NativeLangSpeaker *pNativeSpeaker = nppParam.getNativeLangSpeaker();
5903  		generic_string title_temp = pNativeSpeaker->getAttrNameStr(FL_PANELTITLE, FL_FUCTIONLISTROOTNODE, "PanelTitle");
5904  		static TCHAR title[32];
5905  		if (title_temp.length() < 32)
5906  		{
5907  			wcscpy_s(title, title_temp.c_str());
5908  			data.pszName = title;
5909  		}
5910  		::SendMessage(_pPublicInterface->getHSelf(), NPPM_DMMREGASDCKDLG, 0, reinterpret_cast<LPARAM>(&data));
5911  		COLORREF fgColor = nppParam.getCurrentDefaultFgColor();
5912  		COLORREF bgColor = nppParam.getCurrentDefaultBgColor();
5913  		_pFuncList->setBackgroundColor(bgColor);
5914  		_pFuncList->setForegroundColor(fgColor);
5915  	}
5916  	_pFuncList->display();
5917  }
5918  struct TextPlayerParams
5919  {
5920  	HWND _nppHandle = nullptr;
5921  	ScintillaEditView* _pCurrentView = nullptr;
5922  	QuoteParams* _quotParams = nullptr;
5923  };
5924  struct TextTrollerParams
5925  {
5926  	ScintillaEditView *_pCurrentView;
5927  	const wchar_t*_text2display;
5928  	BufferID _targetBufID;
5929  	HANDLE _mutex;
5930  };
5931  static const QuoteParams quotes[] =
5932  {
5933  	{TEXT("Notepad++"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("The creation of Notepad++ is due to my need for a decent editor to edit the source code of Notepad++")},
5934  	{TEXT("Notepad++ #1"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("I hate reading other people's code.\nSo I wrote mine, made it as open source project, and watch others suffer.")},
5935  	{TEXT("Notepad++ #2"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Good programmers use Notepad++ to code.\nExtreme programmers use MS Word to code, in Comic Sans, center aligned.")},
5936  	{TEXT("Notepad++ #3"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("The best things in life are free.\nNotepad++ is free.\nSo Notepad++ is the best.\n")},
5937  	{TEXT("Richard Stallman"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("If I'm the Father of Open Source, it was conceived through artificial insemination using stolen sperm without my knowledge or consent.")},
5938  	{TEXT("Martin Golding"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Always code as if the guy who ends up maintaining your code will be a violent psychopath who knows where you live.")},
5939  	{TEXT("L. Peter Deutsch"), QuoteParams::slow, false, SC_CP_UTF8, L_TEXT, TEXT("To iterate is human, to recurse divine.")},
5940  	{TEXT("Seymour Cray"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("The trouble with programmers is that you can never tell what a programmer is doing until it's too late.")},
5941  	{TEXT("Brian Kernighan"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Debugging is twice as hard as writing the code in the first place. Therefore, if you write the code as cleverly as possible, you are, by definition, not smart enough to debug it.")},
5942  	{TEXT("Alan Kay"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Most software today is very much like an Egyptian pyramid with millions of bricks piled on top of each other, with no structural integrity, but just done by brute force and thousands of slaves.")},
5943  	{TEXT("Bill Gates"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Measuring programming progress by lines of code is like measuring aircraft building progress by weight.")},
5944  	{TEXT("Christopher Thompson"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Sometimes it pays to stay in bed on Monday, rather than spending the rest of the week debugging Monday's code.")},
5945  	{TEXT("Vidiu Platon"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("I don't care if it works on your machine! We are not shipping your machine!")},
5946  	{TEXT("Edward V Berard"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Walking on water and developing software from a specification are easy if both are frozen.")},
5947  	{TEXT("pixadel"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Fine, Java MIGHT be a good example of what a programming language should be like.\nBut Java applications are good examples of what applications SHOULDN'T be like.")},
5948  	{TEXT("Oktal"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("I think Microsoft named .Net so it wouldn't show up in a Unix directory listing.")},
5949  	{TEXT("Bjarne Stroustrup"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("In C++ it's harder to shoot yourself in the foot, but when you do, you blow off your whole leg.")},
5950  	{TEXT("Mosher's Law of Software Engineering"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Don't worry if it doesn't work right. If everything did, you'd be out of a job.")},
5951  	{TEXT("Bob Gray"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Writing in C or C++ is like running a chain saw with all the safety guards removed.")},
5952  	{TEXT("Roberto Waltman"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("In the one and only true way. The object-oriented version of \"Spaghetti code\" is, of course, \"Lasagna code\". (Too many layers)")},
5953  	{TEXT("Gavin Russell Baker"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("C++ : Where friends have access to your private members.")},
5954  	{TEXT("Linus Torvalds"), QuoteParams::slow, false, SC_CP_UTF8, L_TEXT, TEXT("Software is like sex: It's better when it's free.")},
5955  	{TEXT("Cult of vi"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Emacs is a great operating system, lacking only a decent editor.")},
5956  	{TEXT("Church of Emacs"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("vi has two modes - \"beep repeatedly\" and \"break everything\".")},
5957  	{TEXT("Steve Jobs"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Picasso had a saying: \"Good artists copy, great artists steal.\".\nWe have always been shameless about stealing great ideas.")},
5958  	{TEXT("brotips #1001"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Do everything for greatness, not money. Money follows greatness.")},
5959  	{TEXT("Robin Williams"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("God gave men both a penis and a brain, but unfortunately not enough blood supply to run both at the same time.")},
5960  	{TEXT("Darth Vader"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Strong people don't put others down.\nThey lift them up.")},
5961  	{TEXT("Darth Vader #2"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("You don't get to 500 million star systems without making a few enemies.")},
5962  	{TEXT("Doug Linder"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("A good programmer is someone who always looks both ways before crossing a one-way street.")},
5963  	{TEXT("Jean-Claude van Damme"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("A cookie has no soul, it's just a cookie. But before it was milk and eggs.\nAnd in eggs there's the potential for life.")},
5964  	{TEXT("Michael Feldman"), QuoteParams::slow, false, SC_CP_UTF8, L_TEXT, TEXT("Java is, in many ways, C++--.")},
5965  	{TEXT("Don Ho"), QuoteParams::slow, false, SC_CP_UTF8, L_TEXT, TEXT("Je mange donc je chie.")},
5966  	{TEXT("Don Ho #2"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("RTFM is the true path of every developer.\nBut it would happen only if there's no way out.")},
5967  	{TEXT("Don Ho #3"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Smartphone is the best invention of 21st century for avoiding the eyes contact while crossing people you know on the street.")},
5968  	{TEXT("Don Ho #4"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("Poor countries' museums vs. rich countries' museums:\nThe first show what they have left.\nThe second show what they have stolen.")},
5969  	{TEXT("Anonymous #1"), QuoteParams::slow, false, SC_CP_UTF8, L_TEXT, TEXT("An opinion without 3.14 is just an onion.")},
5970  	{TEXT("Anonymous #2"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Before sex, you help each other get naked, after sex you only dress yourself.\nMoral of the story: in life no one helps you once you're fucked.")},
5971  	{TEXT("Anonymous #3"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("I'm not totally useless. I can be used as a bad example.")},
5972  	{TEXT("Anonymous #4"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("Life is too short to remove USB safely.")},
5973  	{TEXT("Anonymous #5"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("\"SEX\" is not the answer.\nSex is the question, \"YES\" is the answer.")},
5974  	{TEXT("Anonymous #6"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Going to McDonald's for a salad is like going to a whore for a hug.")},
5975  	{TEXT("Anonymous #7"), QuoteParams::slow, false, SC_CP_UTF8, L_TEXT, TEXT("I need a six month holiday, TWICE A YEAR!")},
5976  	{TEXT("Anonymous #8"), QuoteParams::slow, false, SC_CP_UTF8, L_TEXT, TEXT("Everything is a knife if you're strong enough.")},
5977  	{TEXT("Anonymous #9"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("I'M A FUCKING ANIMAL IN BED.\nMore specifically a koala.")},
5978  	{TEXT("Anonymous #10"), QuoteParams::slow, true, SC_CP_UTF8, L_TEXT, TEXT("Etc.\n\n(Abb.) End of Thinking Capacity.\n")},
5979  	{TEXT("Anonymous #11"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("We stopped checking for monsters under our bed, when we realized they were inside us.")},
5980  	{TEXT("Anonymous #12"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("I would rather check my facebook than face my checkbook.")},
5981  	{TEXT("Anonymous #13"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Whoever says Paper beats Rock is an idiot. Next time I see someone say that I will throw a rock at them while they hold up a sheet of paper.")},
5982  	{TEXT("Anonymous #14"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("A better world is where chickens can cross the road without having their motives questioned.")},
5983  	{TEXT("Anonymous #15"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("If I didn't drink, how would my friends know I love them at 2 AM?")},
5984  	{TEXT("Anonymous #16"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Q: How do you generate a random string?\nA: Put a Windows user in front of vi, and tell him to exit.")},
5985  	{TEXT("Anonymous #17"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Pros and cons of making food.\nPros: food\nCons : making\n")},
5986  	{TEXT("Anonymous #18"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Never get into fights with ugly people, they have nothing to lose.")},
5987  	{TEXT("Anonymous #19"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("People who say they give 110%\ndon't really understand how percentages work.")},
5988  	{TEXT("Anonymous #20"), QuoteParams::slow, false, SC_CP_UTF8, L_TEXT, TEXT("Never make eye contact while eating a banana.")},
5989  	{TEXT("Anonymous #21"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("I love my sixpack so much, I protect it with a layer of fat.")},
5990  	{TEXT("Anonymous #22"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("\"It's impossible.\" said pride.\n\"It's risky.\" said experience.\n\"It's pointless.\" said reason.\n\"Give it a try.\" whispered the heart.\n...\n\"What the hell was that?!?!?!?!?!\" shouted the anus two minutes later.")},
5991  	{TEXT("Anonymous #23"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("A programmer is told to \"go to hell\".\nHe finds the worst part of that statement is the \"go to\".")},
5992  	{TEXT("Anonymous #24"), QuoteParams::slow, false, SC_CP_UTF8, L_TEXT, TEXT("An Architect's dream is an Engineer's nightmare.")},
5993  	{TEXT("Anonymous #25"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("In a way, I feel sorry for the kids of this generation.\nThey'll have parents who know how to check browser history.")},
5994  	{TEXT("Anonymous #26"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Q: What's the difference between git and github?\nA: It's the difference between porn and pornhub.\n")},
5995  	{TEXT("Anonymous #27"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("I don't have a problem with caffeine.\nI have a problem without caffeine.")},
5996  	{TEXT("Anonymous #28"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Why 6 afraid of 7?\nBecause 7 8 9 while 6 and 9 were flirting.")},
5997  	{TEXT("Anonymous #29"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("How do you comfort a JavaScript bug?\nYou console it.")},
5998  	{TEXT("Anonymous #30"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Why do Java developers wear glasses?\nBecause they don't C#.")},
5999  	{TEXT("Anonymous #31"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("A baby's laughter is one of the most beautiful sounds you will ever hear. Unless it's 3 AM. And you're home alone. And you don't have a baby.")},
6000  	{TEXT("Anonymous #32"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Two bytes meet. The first byte asks, \"You look terrible. Are you OK?\"\nThe second byte replies, \"No, just feeling a bit off.\"")},
6001  	{TEXT("Anonymous #33"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Programmer - an organism that turns coffee into software.")},
6002  	{TEXT("Anonymous #34"), QuoteParams::slow, false, SC_CP_UTF8, L_TEXT, TEXT("It's not a bug - it's an undocumented feature.")},
6003  	{TEXT("Anonymous #35"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Should array index start at 0 or 1?\nMy compromised solution is 0.5")},
6004  	{TEXT("Anonymous #36"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Every single time when I'm about to hug someone extremely sexy, I hit the mirror.")},
6005  	{TEXT("Anonymous #37"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("My software never has bugs. It just develops random features.")},
6006  	{TEXT("Anonymous #38"), QuoteParams::slow, false, SC_CP_UTF8, L_TEXT, TEXT("LISP = Lots of Irritating Silly Parentheses.")},
6007  	{TEXT("Anonymous #39"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Perl, the only language that looks the same before and after RSA encryption.")},
6008  	{TEXT("Anonymous #40"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("People ask me why, as an atheist, I still say: OH MY GOD.\nIt makes perfect sense: We say \"Oh my God\" when something is UNBELIEVABLE.")},
6009  	{TEXT("Anonymous #41"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("1. Dig a hole.\n2. Name it love.\n3. Watch people falling in love.\n")},
6010  	{TEXT("Anonymous #42"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Don't think of yourself as an ugly person.\nThink of yourself as a beautiful monkey.")},
6011  	{TEXT("Anonymous #43"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("Afraid to die alone?\nBecome a bus driver.")},
6012  	{TEXT("Anonymous #44"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("The first 5 days after the weekend are always the hardest.")},
6013  	{TEXT("Anonymous #45"), QuoteParams::slow, false, SC_CP_UTF8, L_TEXT, TEXT("Rhinos are just fat unicorns.")},
6014  	{TEXT("Anonymous #46"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Sometimes when I'm writing Javascript I want to throw up my hands and say \"this is bullshit!\"\nbut I can never remember what \"this\" refers to.")},
6015  	{TEXT("Anonymous #47"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("Kids are like farts.\nYou can only stand yours.")},
6016  	{TEXT("Anonymous #48"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("If you were born in Israel, you'd probably be Jewish.\nIf you were born in Saudi Arabia, you'd probably be Muslim.\nIf you were born in India, you'd probably be Hindu.\nBut because you were born in North America, you're Christian.\nYour faith is not inspired by some divine, constant truth.\nIt's simply geography.")},
6017  	{TEXT("Anonymous #49"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("There are 2 types of people in this world:\nPeople who say they pee in the shower, and the dirty fucking liars.")},
6018  	{TEXT("Anonymous #50"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("London 2012 Olympic Games - A bunch of countries coming across the ocean to put their flags in Britain and try to get a bunch of gold... it's like history but opposite.")},
6019  	{TEXT("Anonymous #51"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("I don't need a stable relationship,\nI just need a stable Internet connection.")},
6020  	{TEXT("Anonymous #52"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("What's the difference between religion and bullshit?\nThe bull.")},
6021  	{TEXT("Anonymous #53"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Today, as I was waiting for my girlfriend in the street, I saw a woman who looked a lot like her. I ran towards her, my arms in the air ready to give her a hug, only to realise it wasn't her. I then had to pass the woman, my arms in the air, still running. FML")},
6022  	{TEXT("Anonymous #54"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("Decimal: 1 + 1 = 2\nBinary:  1 + 1 = 10\nBoolean: 1 + 1 = 1\nJavaScript(hold my beer) : 1 + 1 = 11\n")},
6023  	{TEXT("Anonymous #55"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Don't be ashamed of who you are.\nThat's your parents job.")},
6024  	{TEXT("Anonymous #56"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Religion is like circumcision.\nIf you wait until someone is 21 to tell them about it they probably won't be interested.")},
6025  	{TEXT("Anonymous #57"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("No, no, no, I'm not insulting you.\nI'm describing you.")},
6026  	{TEXT("Anonymous #58"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("I bought a dog once. Named him \"Stay\".\n\"Come here, Stay.\"\nHe's insane now.")},
6027  	{TEXT("Anonymous #59"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("Law of Software Quality:\n	errors = (more code)²\ne = mc²")},
6028  	{TEXT("Anonymous #60"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Yesterday I named my Wifi network \"hack me if you can\"\nToday when I woke up it was changed to \"challenge accepted\".")},
6029  	{TEXT("Anonymous #61"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Your mother is so fat,\nthe recursive function computing her mass causes a stack overflow.")},
6030  	{TEXT("Anonymous #62"), QuoteParams::slow, false, SC_CP_UTF8, L_TEXT, TEXT("Oral sex makes my day, but anal sex makes my hole weak.")},
6031  	{TEXT("Anonymous #63"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("I'm not saying I am Batman, I am just saying no one has ever seen me and Batman in the same room together.")},
6032  	{TEXT("Anonymous #64"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("I took a taxi today.\nThe driver told me \"I love my job, I own this car, I've got my own business, I'm my own boss, NO ONE tells me what to do!\"\nI said \"TURN LEFT HERE\".\n")},
6033  	{TEXT("Anonymous #65"), QuoteParams::slow, false, SC_CP_UTF8, L_TEXT, TEXT("A man without God is like a fish without a bicycle.")},
6034  	{TEXT("Anonymous #66"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("I hate how spiders just sit there on the walls and act like they pay rent!")},
6035  	{TEXT("Anonymous #67"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("Whenever someone starts a sentence by saying \"I'm not racist...\"),they are about to say something super racist.")},
6036  	{TEXT("Anonymous #68"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("I'm not laughing at you, I'm laughing with you, you're just not laughing.\n")},
6037  	{TEXT("Anonymous #69"), QuoteParams::slow, false, SC_CP_UTF8, L_TEXT, TEXT("Women need a reason to have sex. Men just need a place.")},
6038  	{TEXT("Anonymous #70"), QuoteParams::slow, false, SC_CP_UTF8, L_TEXT, TEXT("If abortion is murder then are condoms kidnapping?")},
6039  	{TEXT("Anonymous #71"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Men also have feelings.\nFor example, they can feel hungry.")},
6040  	{TEXT("Anonymous #72"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Project Manager:\nA person who thinks 9 women can deliver a baby in 1 month.")},
6041  	{TEXT("Anonymous #73"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("If you try and don't succeed, cheat. Repeat until caught. Then lie.")},
6042  	{TEXT("Anonymous #74"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("Olympics is the stupidest thing.\nPeople are so proud to be competing for their country.\nThey play their stupid song and raise some dumb flags.\nI'd love to see no flags raised, no song, no mention of country.\nOnly people.")},
6043  	{TEXT("Anonymous #75"), QuoteParams::slow, false, SC_CP_UTF8, L_TEXT, TEXT("I think therefore I am\nnot religious.")},
6044  	{TEXT("Anonymous #76"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Even if being gay were a choice, so what?\nPeople choose to be assholes and they can get married.")},
6045  	{TEXT("Anonymous #77"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Governments are like diapers.\nThey should be changed often, and for the same reason.")},
6046  	{TEXT("Anonymous #78"), QuoteParams::slow, true, SC_CP_UTF8, L_TEXT, TEXT("Mathématiquement, un cocu est un entier qui partage sa moitié avec un tiers.\n")},
6047  	{TEXT("Anonymous #79"), QuoteParams::slow, false, SC_CP_UTF8, L_TEXT, TEXT("I'm a creationist.\nI believe man created God.\n")},
6048  	{TEXT("Anonymous #80"), QuoteParams::slow, true, SC_CP_UTF8, L_TEXT, TEXT("Let's eat kids.\nLet's eat, kids.\n\nUse a comma.\nSave lives.\n")},
6049  	{TEXT("Anonymous #81"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("A male engineering student was crossing a road one day when a frog called out to him and said, \"If you kiss me, I'll turn into a beautiful princess.\" He bent over, picked up the frog, and put it in his pocket.\n\nThe frog spoke up again and said, \"If you kiss me and turn me back into a beautiful princess, I will stay with you for one week.\" The engineering student took the frog out of his pocket, smiled at it; and returned it to his pocket.\n\nThe frog then cried out, \"If you kiss me and turn me back into a princess, I'll stay with you and do ANYTHING you want.\" Again the boy took the frog out, smiled at it, and put it back into his pocket.\n\nFinally, the frog asked, \"What is the matter? I've told you I'm a beautiful princess, that I'll stay with you for a week and do anything you want. Why won't you kiss me?\" The boy said, \"Look I'm an engineer. I don't have time for a girlfriend, but a talking frog is cool.\"\n")},
6050  	{TEXT("Anonymous #82"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Gamers never die.\nThey just go offline.\n")},
6051  	{TEXT("Anonymous #83"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Copy from one, it's plagiarism.\nCopy from two, it's research.\n")},
6052  	{TEXT("Anonymous #84"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Saying that Java is nice because it works on all OSes is like saying that anal sex is nice because it works on all genders.")},
6053  	{TEXT("Anonymous #85"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("Race, religion, ethnic pride and nationalism etc... does nothing but teach you how to hate people that you've never met.")},
6054  	{TEXT("Anonymous #86"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Farts are just the ghosts of the things we eat.")},
6055  	{TEXT("Anonymous #87"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("I promised I would never kill someone who had my blood.\nBut that mosquito made me break my word.")},
6056  	{TEXT("Anonymous #88"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Si un jour une chaise te dit que t'as un joli cul, tu trouveras ça bizarre mais c'est juste un compliment d'objet direct.")},
6057  	{TEXT("Anonymous #89"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("The biggest step in any relationship isn't the first kiss.\nIt's the first fart.")},
6058  	{TEXT("Anonymous #90"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Clapping:\n(verb)\nRepeatedly high-fiving yourself for someone else's accomplishments.")},
6059  	{TEXT("Anonymous #91"), QuoteParams::slow, false, SC_CP_UTF8, L_TEXT, TEXT("CV: ctrl-C, ctrl-V")},
6060  	{TEXT("Anonymous #92"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Mondays are not so bad.\nIt's your job that sucks.")},
6061  	{TEXT("Anonymous #93"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("[In a job interview]\nInterviewer: What's your greatest weakness?\nCandidate: Honesty.\nInterviewer: I don't think honesty is a weakness.\nCandidate: I don't give a fuck what you think.")},
6062  	{TEXT("Anonymous #94"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Hey, I just met you\nAnd this is crazy\nHere's my number 127.0.0.1\nPing me maybe?")},
6063  	{TEXT("Anonymous #95"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("What if the spider you killed in your house had spent his entire life thinking you were his roommate?\nEver think about that?\nNo. You only think about yourself.\n")},
6064  	{TEXT("Anonymous #96"), QuoteParams::slow, false, SC_CP_UTF8, L_TEXT, TEXT("Code for 6 minutes, debug for 6 hours.")},
6065  	{TEXT("Anonymous #97"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Real Programmers don't comment their code.\nIf it was hard to write, it should be hard to read.")},
6066  	{TEXT("Anonymous #98"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("My neighbours listen to good music.\nWhether they like it or not.")},
6067  	{TEXT("Anonymous #99"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("I've been using Vim for about 2 years now,\nmostly because I can't figure out how to exit it.")},
6068  	{TEXT("Anonymous #100"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Dear YouTube,\nI can deal with Ads.\nI can deal with Buffer.\nBut when Ads buffer, I suffer.")},
6069  	{TEXT("Anonymous #101"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("It's always sad when a man and his dick share only one brain...\nand it turns out to be the dick's.")},
6070  	{TEXT("Anonymous #102"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("If IE is brave enough to ask you to set it as your default browser,\ndon't tell me you dare not ask a girl out.")},
6071  	{TEXT("Anonymous #104"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("The main idea of \"Inception\":\nif you run a VM inside a VM inside a VM inside a VM inside a VM,\neverything will be very slow.")},
6072  	{TEXT("Anonymous #105"), QuoteParams::slow, false, SC_CP_UTF8, L_TEXT, TEXT("The best antivirus is common sense.")},
6073  	{TEXT("Anonymous #106"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("When I die, I want to go peacefully like my grandfather did, in his sleep\n- not screaming, like the passengers in his car.")},
6074  	{TEXT("Anonymous #107"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Remember, YOUR God is real.\nAll those other Gods are ridiculous, made-up nonsense.\nBut not yours.\nYour God is real. Whichever one that is.")},
6075  	{TEXT("Anonymous #108"), QuoteParams::rapid, true, SC_CP_UTF8, L_CSS, TEXT("#your-mom {\n	width: 100000000000000000000px;\n	float: nope;\n}\n")},
6076  	{TEXT("Anonymous #109"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("What's the best thing about UDP jokes?\nI don't care if you get them.")},
6077  	{TEXT("Anonymous #110"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("A programmer had a problem, so he decided to use threads.\nNow 2 has. He problems")},
6078  	{TEXT("Anonymous #111"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("I'VE NEVER BEEN VERY GOOD AT GEOGRAPHY.\nBUT I CAN NAME AT LEAST ONE CITY IN FRANCE, WHICH IS NICE.")},
6079  	{TEXT("Anonymous #112"), QuoteParams::rapid, true, SC_CP_UTF8, L_CSS, TEXT("#hulk {\n    height: 200%;\n    width: 200%;\n    color: green;\n}\n")},
6080  	{TEXT("Anonymous #113"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("A colon can completely change the meaning of a sentence. For example:\n- Jane ate her friend's sandwich.\n- Jane ate her friend's colon.")},
6081  	{TEXT("Anonymous #114"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("How can you face your problem if your problem is your face?")},
6082  	{TEXT("Anonymous #115"), QuoteParams::slow, false, SC_CP_UTF8, L_TEXT, TEXT("YOLOLO:\nYou Only LOL Once.")},
6083  	{TEXT("Anonymous #116"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Every exit is an entrance to new experiences.")},
6084  	{TEXT("Anonymous #117"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("A Native American was asked:\n\"Do you celebrate Columbus day?\"\nHe replied:\n\"I don't know, do Jews celebrate Hitler's birthday?\"")},
6085  	{TEXT("Anonymous #118"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("I love necrophilia, but i can't stand the awkward silences.")},
6086  	{TEXT("Anonymous #119"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("\"I'm gonna Google that. BING that, Bing that, sorry.\"\n- The CEO of Bing (many times per day still)")},
6087  	{TEXT("Anonymous #120"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("GRAMMAR\nThe difference between knowing your shit and knowing you're shit.")},
6088  	{TEXT("Anonymous #121"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("5 out of 6 people agree that Russian roulette is completely safe.")},
6089  	{TEXT("Anonymous #122"), QuoteParams::slow, false, SC_CP_UTF8, L_TEXT, TEXT("Nerd?\nI prefer the term \"Intellectual badass\".")},
6090  	{TEXT("Anonymous #123"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("I know every digit of π,\njust not in the right order.")},
6091  	{TEXT("Anonymous #124"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("You don't need religion to have morals.\nIf you can't determine right from wrong then you lack empathy, not religion.")},
6092  	{TEXT("Anonymous #125"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Pooping with the door opened is the meaning of true freedom.")},
6093  	{TEXT("Anonymous #126"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Social media does not make people stupid.\nIt just makes stupid people more visible.")},
6094  	{TEXT("Anonymous #127"), QuoteParams::rapid, false, SC_CP_UTF8, L_SQL, TEXT("SELECT finger\nFROM hand\nWHERE id = 2 ;\n")},
6095  	{TEXT("Anonymous #128"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("3 men are on a boat. They have 4 cigarettes, but nothing to light them with.\nSo they throw a cigarette overboard and the whole boat becomes a cigarette lighter.")},
6096  	{TEXT("Anonymous #129"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("What is the most used language in programming?\n\nProfanity\n")},
6097  	{TEXT("Anonymous #130"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("Common sense is so rare, it's kinda like a superpower...")},
6098  	{TEXT("Anonymous #131"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("The best thing about a boolean is even if you are wrong, you are only off by a bit.")},
6099  	{TEXT("Anonymous #132"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("Benchmarks don't lie, but liars do benchmarks.")},
6100  	{TEXT("Anonymous #133"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("Multitasking: Screwing up several things at once.")},
6101  	{TEXT("Anonymous #134"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Linux is user friendly.\nIt's just picky about its friends.")},
6102  	{TEXT("Anonymous #135"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Theory is when you know something, but it doesn't work.\nPractice is when something works, but you don't know why.\nProgrammers combine theory and practice: nothing works and they don't know why.")},
6103  	{TEXT("Anonymous #136"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Documentation is like sex:\nwhen it's good, it's very, very good;\nwhen it's bad, it's better than nothing.")},
6104  	{TEXT("Anonymous #137"), QuoteParams::slow, false, SC_CP_UTF8, L_TEXT, TEXT("Home is where you poop most comfortably.")},
6105  	{TEXT("Anonymous #138"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Laptop Speakers problem: too quiet for music, too loud for porn.")},
6106  	{TEXT("Anonymous #139"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Chinese food to go: $16\nGas to go get the food: $2\nDrove home just to realize they forgot one of your containers: RICELESS")},
6107  	{TEXT("Anonymous #140"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("MS Windows is like religion to most people: they are born into it, accept it as default, never consider switching to another.")},
6108  	{TEXT("Anonymous #141"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("To most religious people, the holy books are like a software license (EULA).\nNobody actually reads it. They just scroll to the bottom and click \"I agree\".")},
6109  	{TEXT("Anonymous #142"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("You are nothing but a number of days,\nwhenever each day passes then part of you has gone.")},
6110  	{TEXT("Anonymous #143"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("If 666 is evil, does that make 25.8069758011 the root of all evil?")},
6111  	{TEXT("Anonymous #144"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("I don't want to sound like a badass but\nI eject my USB drive without removing it safely.")},
6112  	{TEXT("Anonymous #145"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("feet  (noun)\na device used for finding legos in the dark")},
6113  	{TEXT("Anonymous #146"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Buy a sheep\nName it \"Relation\"\nNow you have a Relationsheep\n")},
6114  	{TEXT("Anonymous #147"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("I dig, you dig, we dig,\nhe dig, she dig, they dig...\n\nIt's not a beautiful poem,\nbut it's very deep.")},
6115  	{TEXT("Anonymous #148"), QuoteParams::rapid, false, SC_CP_UTF8, L_BASH, TEXT("# UNIX command line Russian roulette:\n[ $[ $RANDOM % 6 ] == 0 ] && rm -rf &bsol;* || echo *Click*\n")},
6116  	{TEXT("Anonymous #149"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("unzip, strip, top, less, touch, finger, grep, mount, fsck, more, yes, fsck, fsck, fsck, umount, sleep.\n\nNo, it's not porn. It's Unix.")},
6117  	{TEXT("Anonymous #150"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("To understand what recursion is, you must first understand recursion.")},
6118  	{TEXT("Anonymous #151"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Q: What's the object-oriented way to become wealthy?\nA: Inheritance.")},
6119  	{TEXT("Anonymous #152"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("A SQL query goes into a bar, walks up to two tables and asks, \"Can I join you?\"")},
6120  	{TEXT("Anonymous #153"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("You are not fat, you are just more visible.")},
6121  	{TEXT("Anonymous #154"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Minimalist\n (.   .)\n  )   (\n (  Y  )\nASCII Art")},
6122  	{TEXT("Anonymous #155"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Parallel lines have so much in common...\nIt's a shame that they'll never meet.")},
6123  	{TEXT("Anonymous #156"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Declare variables, not war.\nExecute programs, not people.")},
6124  	{TEXT("Anonymous #157"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("I can't see an end. I have no control and I don't think there's any escape. I don't even have a home anymore.\nI think it's time for a new keyboard.")},
6125  	{TEXT("Anonymous #158"), QuoteParams::slow, false, SC_CP_UTF8, L_TEXT, TEXT("6.9\nA little fun interrupted by a period.")},
6126  	{TEXT("Anonymous #159"), QuoteParams::slow, false, SC_CP_UTF8, L_TEXT, TEXT("I love anal\n-yzing all data before making assumptions.")},
6127  	{TEXT("Anonymous #160"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("So my wife said\n\"take off my shirt\".\nI did as she said and take off her shirt.\nThen she said,\n\"Take off my skirt.\"\nI took off her skirt.\n\"Take off my shoes.\"\nI took off her shoes.\n\"Now take off my bra and panties.\"\nand so I took them off.\nThen she looked at me and said\n\"I don't want to catch you wearing my things ever again.\"")},
6128  	{TEXT("Anonymous #161"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("Do you know:\nSpiders are the only web developers in the world that enjoy finding bugs.") },
6129  	{TEXT("Anonymous #162"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("Psychologist: Lie down please.\n8: No, thank you. If I do, this session will never reach the end.") },
6130  	{TEXT("Anonymous #163"), QuoteParams::slow, false, SC_CP_UTF8, L_TEXT, TEXT("I love the way the earth rotates,\nit really makes my day.") },
6131  	{TEXT("Anonymous #164"), QuoteParams::slow, false, SC_CP_UTF8, L_TEXT, TEXT("Homonyms are a waist of thyme.") },
6132  	{TEXT("Anonymous #165"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("What's the difference between a police officer and a bullet?\nWhen a bullet kills someone else, you know it's been fired.") },
6133  	{TEXT("Anonymous #166"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("What has 4 letters\nsometimes 9 letters\nbut never has 5 letters") },
6134  	{TEXT("Anonymous #167"), QuoteParams::slow, false, SC_CP_UTF8, L_TEXT, TEXT("The 'h' in \"software development\" stands for \"happiness\".") },
6135  	{TEXT("Anonymous #168"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("Never let your computer know that you are in a hurry.\nComputers can smell fear.\nThey slow down if they know that you are running out of time.") },
6136  	{TEXT("Anonymous #169"), QuoteParams::slow, false, SC_CP_UTF8, L_TEXT, TEXT("JavaScript is not a language.\nIt's a programming jokes generator.") },
6137  	{TEXT("Anonymous #170"), QuoteParams::slow, false, SC_CP_UTF8, L_TEXT, TEXT("A journalist asked Linus Torvalds what makes code bad.\nHe replied : No comment.") },
6138  	{TEXT("Anonymous #171"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("If you spell \"Nothing\" backwards, it becomes \"Gnihton\" which also means nothing.") },
6139  	{TEXT("Anonymous #172"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Programming in Javascript is like looking both ways before you cross the street, and then getting hit by an airplane.") },
6140  	{TEXT("Anonymous #173"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Q: Why do we need a backend, why not just connect front end to database???\n\nA: Yeah! And why do we eat and go to the bathroom while we can throw the food directly in the toilet? Because stuff needs to get processed. ;)\n") },
6141  	{TEXT("Anonymous #174"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Someday, once humans are extinct from covid-19. I hope whatever species rules Earth makes chicken nuggets in the shape of us, like we did for dinosaurs.") },
6142  	{TEXT("Anonymous #175"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Linkedin is basically a reversed Tinder.\nHot girls write to nerd guys and they didn't reply.") },
6143  	{TEXT("Anonymous #176"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("A vegan said to me, \"people who sell meat are gross!\"\nI said, \"people who sell fruits and vegetables are grocer.\"\n") },
6144  	{TEXT("Anonymous #177"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("Documentation is a love letter that you write to your future self.\n") },
6145  	{TEXT("Anonymous #178"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("When I die, I hope it's early in the morning so I don't have to go to work that day for no reason.\n") },
6146  	{TEXT("Anonymous #179"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("Workers play football\nManagers play tennis\nCEOs play golf\n\nHigher the function, smaller the balls.\n") },
6147  	{TEXT("Anonymous #180"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("Friends are just like trees.\nThey fall down when you hit them multiple times with an axe.\n") },
6148  	{TEXT("Anonymous #181"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("I met a magical Genie. He gave me one wish.\nI said: \"I wish I could be you.\"\nThe Genue saud: \"Weurd wush but U wull grant ut.\"\n") },
6149  	{TEXT("Anonymous #182"), QuoteParams::slow, false, SC_CP_UTF8, L_CPP, TEXT("printf(\"%s%s\", \"\\\\o/\\n| |\\n| |8=\", \"=D\\n/ \\\\\\n\");\n") },
6150  	{TEXT("Anonymous #183"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("Dear Optimist, Pessimist and Realist,\n\nWhile you guys were busy arguing about\nthe glass of water, I drank it!\n\n\n					Sincerely,\n					The Opportunist\n") },
6151  	{TEXT("Anonymous #184"), QuoteParams::slow, false, SC_CP_UTF8, L_TEXT, TEXT("Dance like nobody's watching.\nEncrypt like everyone is.\n") },
6152  	{TEXT("Anonymous #185"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("Me: \"I'm 45 years old but I've got a 19 year-old young man's body\"\nHer: \"Show me\"\nI opened the freezer to show her the body.\nShe screamed.\nMe too.\n") },
6153  	{TEXT("Anonymous #186"), QuoteParams::slow, false, SC_CP_UTF8, L_TEXT, TEXT("Everyone complains about the weather,\nbut no one wants to sacrifice a virgin to change it.\n") },
6154  	{TEXT("Anonymous #187"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("If you are alone at home and feel lonely:\nTurn off the lights, turn on the TV and watch a horror movie.\nThen you will have feeling that there are someone hidden in the kitchen, in the toilet\nand even under your bed.\n") },
6155  	{TEXT("Anonymous #188"), QuoteParams::slow, false, SC_CP_UTF8, L_TEXT, TEXT("*Knock knock*\n\"Race condition\"\n\"Who's there?\"\n") },
6156  	{TEXT("Anonymous #189"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("The two most difficult programming challenges are naming things, cache invalidation, and off-by-one errors.\n") },
6157  	{TEXT("Anonymous #190"), QuoteParams::slow, false, SC_CP_UTF8, L_TEXT, TEXT("The greatest security vulnerability in any computer system is located between the keyboard and the chair.\n") },
6158  	{TEXT("Anonymous #191"), QuoteParams::slow, false, SC_CP_UTF8, L_TEXT, TEXT("My biggest talent is always being able to tell what's in a wrapped present.\n\nIt's a gift.\n") },
6159  	{TEXT("Anonymous #192"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("You can't force someone to love you.\nBut you can lock this person in the basement and wait for him/her to develop Stockholm syndrome.\n") },
6160  	{TEXT("Anonymous #193"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("Do you know:\nthere are more airplanes in the oceans, than submarines in the sky?\n") },
6161  	{TEXT("Anonymous #194"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("If you hold a Unix shell up to your ear,\nyou might just be able to hear the C.\n") },
6162  	{TEXT("Anonymous #195"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("Why do programmers always mix up Halloween and Christmas?\nBecause Oct 31 == Dec 25\n") },
6163  	{TEXT("Anonymous #196"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("What happened to the function that ran away?\nIt never returned.\n") },
6164  	{TEXT("Anonymous #197"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("When I am tasked with sorting through a stack of résumés, I throw about half of them in the garbage.\nI do not want unlucky people working in our company.\n") },
6165  	{TEXT("Anonymous #198"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("The reason why we write SQL commands all in CAPITAL letters is because it stands for Screaming Query Language.\n") },
6166  	{TEXT("Anonymous #199"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("Fly: Hey, bug on my back, are you a mite?\nMite: I mite be.\nFly: Stupidest pun I ever heard.\nMite: What do you expect? I just made it up on the fly.\n\n") },
6167  	{TEXT("Anonymous #200"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("Me: What's the wifi password?\nBartender: You need to buy a drink first.\nMe: OK, I'll have a coke.\nBartender: Is Pepsi OK?\nMe: Sure. How much is that?\nBartender: $3.\nMe: There you go. So what's the wifi password?\nBartender: You need to buy a drink first. No spaces, all lowercase.\n\n") },
6168  	{TEXT("Anonymous #201"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("People always say software engineers are useless without computers.\nIt's not true.\nSome of them are useless even with computers.\n\n") },
6169  	{TEXT("Anonymous #202"), QuoteParams::slow , false, SC_CP_UTF8, L_TEXT, TEXT("The plural of regex is regrets.\n\n") },
6170  	{TEXT("Anonymous #203"), QuoteParams::rapid , false, SC_CP_UTF8, L_TEXT, TEXT("My gynecologist follows me on Instagram, I really do not know what else he want to see.\n\n") },
6171  	{TEXT("Anonymous #204"), QuoteParams::slow , false, SC_CP_UTF8, L_TEXT, TEXT("The greatest security vulnerability in any computer system is located between the keyboard and the chair.\n\n") },
6172  	{TEXT("Anonymous #205"), QuoteParams::slow , false, SC_CP_UTF8, L_TEXT, TEXT("Courage is knowing it might hurt, and doing it anyway.\nStupidity is the same.\nAnd that's why life is hard.\n\n") },
6173  	{TEXT("xkcd"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("Never have I felt so close to another soul\nAnd yet so helplessly alone\nAs when I Google an error\nAnd there's one result\nA thread by someone with the same problem\nAnd no answer\nLast posted to in 2003\n\n\"Who were you, DenverCoder9?\"\n\"What did you see?!\"\n\n(ref: https:&bsol;&bsol;xkcd.com/979/)") },
6174  	{TEXT("A developer"), QuoteParams::slow, false, SC_CP_UTF8, L_TEXT, TEXT("No hugs & kisses.\nOnly bugs & fixes.") },
6175  	{TEXT("Elon Musk"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("Don't set your password as your child's name.\nName your child after your password.") },
6176  	{TEXT("OOP"), QuoteParams::slow, false, SC_CP_UTF8, L_TEXT, TEXT("If you want to treat women as objects,\ndo it with class.")},
6177  	{TEXT("Internet #404"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Quote not Found")},
6178  	{TEXT("Mary Oliver"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("Someone I loved once gave me a box full of darkness.\nIt took me years to understand that this, too, was a gift.")},
6179  	{TEXT("Floor"), QuoteParams::slow, true, SC_CP_UTF8, L_TEXT, TEXT("If you fall, I will be there.")},
6180  	{TEXT("Simon Amstell"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("If you have some problem in your life and need to deal with it, then use religion, that's fine.\nI use Google.")},
6181  	{TEXT("Albert Einstein"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Only 3 things are infinite:\n1. Universe.\n2. Human Stupidity.\n3. Winrar's free trial.")},
6182  	{TEXT("Terry Pratchett"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Artificial Intelligence is no match for natural stupidity.")},
6183  	{TEXT("Stewart Brand"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Once a new technology starts rolling, if you're not part of the steamroller,\nyou're part of the road.")},
6184  	{TEXT("Sam Redwine"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Software and cathedrals are much the same - first we build them, then we pray.")},
6185  	{TEXT("Jan L. A. van de Snepscheut"),  QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("In theory, there is no difference between theory and practice. But, in practice, there is.")},
6186  	{TEXT("Jessica Gaston"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("One man's crappy software is another man's full time job.")},
6187  	{TEXT("Raymond Devos"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("Mon pied droit est jaloux de mon pied gauche. Quand l'un avance, l'autre veut le dépasser.\nEt moi, comme un imbécile, je marche !")},
6188  	{TEXT("xkcd.com"), QuoteParams::rapid, false, SC_CP_UTF8, L_C, TEXT("int getRandomNumber()\n{\n    return 4; 
6189  	{TEXT("Gandhi"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("Earth provides enough to satisfy every man's need, but not every man's greed.")},
6190  	{TEXT("R. D. Laing"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Life is a sexually transmitted disease and the mortality rate is one hundred percent.")},
6191  	{TEXT("Hustle Man"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Politicians are like sperm.\nOne in a million turn out to be an actual human being.")},
6192  	{TEXT("Mark Twain"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Censorship is telling a man he can't have a steak just because a baby can't chew it.")},
6193  	{TEXT("Friedrich Nietzsche"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("There is not enough love and goodness in the world to permit giving any of it away to imaginary beings.")},
6194  	{TEXT("Dhalsim"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("Pain is a state of mind and I don't mind your pain.")},
6195  	{TEXT("Elie Wiesel"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("Human beings can be beautiful or more beautiful,\nthey can be fat or skinny, they can be right or wrong,\nbut illegal? How can a human being be illegal?")},
6196  	{TEXT("Dennis Ritchie"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Empty your memory, with a free(), like a pointer.\nIf you cast a pointer to a integer, it becomes the integer.\nIf you cast a pointer to a struct, it becomes the struct.\nThe pointer can crash, and can overflow.\nBe a pointer my friend.")},
6197  	{TEXT("Chewbacca"), QuoteParams::slow, false, SC_CP_UTF8, L_TEXT, TEXT("Uuuuuuuuuur Ahhhhrrrrrr\nUhrrrr Ahhhhrrrrrr\nAaaarhg...")},
6198  	{TEXT("Alexandria Ocasio-Cortez"), QuoteParams::slow, false, SC_CP_UTF8, L_TEXT, TEXT("No one ever makes a billion dollars.\nYou TAKE a billion dollars.")},
6199  	{TEXT("Freddy Krueger"), QuoteParams::slow, false, SC_CP_UTF8, L_TEXT, TEXT("Never stop dreaming.\n")},
6200  	{TEXT("Word of the Day"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("DEBUGGING\n\n/diːˈbʌɡɪŋ/ noun\n\nThe classic mystery game where you are the detective, the victim and the murderer.\n\n")},
6201  	{TEXT("Ricky Gervais"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("Feel free to mock my lack of belief in any Gods.\nIt won't hurt my feelings.\nIt won't damage my faith in reason.\nAnd I won't kill you for it.")},
6202  	{TEXT("Francis bacon"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("Knowledge is power. France is bacon.\n\nWhen I was young my father said to me: \"Knowledge is power, Francis Bacon.\" I understood it as \"Knowledge is power, France is bacon.\"\n\nFor more than a decade I wondered over the meaning of the second part and what was the surreal linkage between the two. If I said the quote to someone, \"Knowledge is power, France is Bacon\", they nodded knowingly. Or someone might say, \"Knowledge is power\" and I'd finish the quote \"France is Bacon\" and they wouldn't look at me like I'd said something very odd, but thoughtfully agree. I did ask a teacher what did \"Knowledge is power, France is bacon\" mean and got a full 10-minute explanation of the \"knowledge is power\" bit but nothing on \"France is bacon\". When I prompted further explanation by saying \"France is bacon?\" in a questioning tone I just got a \"yes\". At 12 I didn't have the confidence to press it further. I just accepted it as something I'd never understand.\n\nIt wasn't until years later I saw it written down that the penny dropped.\n")},
6203  	{TEXT("Space Invaders"), QuoteParams::speedOfLight, false, SC_CP_UTF8, L_TEXT, TEXT("\n\n       ▄██▄\n     ▄██████▄           █   █  █▀▀▀\n     ██▄██▄██           █   █  █▄▄\n      ▄▀▄▄▀▄            █ █ █  █\n     ▀ ▀  ▀ ▀           ▀▀ ▀▀  ▀▀▀▀\n\n      ▀▄   ▄▀           ▄█▀▀▀  ▄█▀▀█▄  █▀▄▀█  █▀▀▀\n     ▄█▀███▀█▄          █      █    █  █ ▀ █  █▄▄\n    █ █▀▀▀▀▀█ █         █▄     █▄  ▄█  █   █  █\n       ▀▀ ▀▀             ▀▀▀▀   ▀▀▀▀   ▀   ▀  ▀▀▀▀\n\n     ▄▄█████▄▄          ▀█▀  █▀▄  █\n    ██▀▀███▀▀██          █   █ ▀▄ █\n    ▀▀██▀▀▀██▀▀          █   █  ▀▄█\n    ▄█▀ ▀▀▀ ▀█▄         ▀▀▀  ▀   ▀▀\n\n      ▄▄████▄▄          █▀▀█  █▀▀▀  ▄▀▀▄  ▄█▀▀▀  █▀▀▀\n    ▄██████████▄        █▄▄█  █▄▄   █▄▄█  █      █▄▄ \n  ▄██▄██▄██▄██▄██▄      █     █     █  █  █▄     █   \n    ▀█▀  ▀▀  ▀█▀        ▀     ▀▀▀▀  ▀  ▀   ▀▀▀▀  ▀▀▀▀\n\n") },
6204  	{TEXT("#JeSuisCharlie"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("Freedom of expression is like the air we breathe, we don't feel it, until people take it away from us.\n\nFor this reason, Je suis Charlie, not because I endorse everything they published, but because I cherish the right to speak out freely without risk even when it offends others.\nAnd no, you cannot just take someone's life for whatever he/she expressed.\n\nHence this \"Je suis Charlie\" edition.\n")}
6205  };
6206  const int nbWtf = 5;
6207  const wchar_t* wtf[nbWtf] =
6208  {
6209  	TEXT("WTF?!"),
6210  	TEXT("lol"),
6211  	TEXT("ROFL"),
6212  	TEXT("OMFG"),
6213  	TEXT("Husband is not an ATM machine!!!")
6214  };
6215  const int nbIntervalTime = 5;
6216  int intervalTimeArray[nbIntervalTime] = {30,30,30,30,200};
6217  const int nbPauseTime = 3;
6218  int pauseTimeArray[nbPauseTime] = {200,400,600};
6219  const int act_doNothing = 0;
6220  const int act_trolling = 1;
6221  const int nbAct = 30;
6222  int actionArray[nbAct] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0};
6223  const int maxRange = 200;
6224  int Notepad_plus::getRandomAction(int ranNum)
6225  {
6226  	return actionArray[ranNum % nbAct];
6227  }
6228  bool isInList(int elem, vector<int> elemList)
6229  {
6230  	for (size_t i = 0, len = elemList.size(); i < len; ++i)
6231  	{
6232  		if (elem == elemList[i])
6233  			return true;
6234  	}
6235  	return false;
6236  }
6237  DWORD WINAPI Notepad_plus::threadTextPlayer(void *params)
6238  {
6239  	srand(static_cast<UINT>(time(NULL)));
6240  	TextPlayerParams* textPlayerParams = static_cast<TextPlayerParams*>(params);
6241  	HWND hNpp = textPlayerParams->_nppHandle;
6242  	ScintillaEditView *pCurrentView = textPlayerParams->_pCurrentView;
6243  	QuoteParams* qParams = textPlayerParams->_quotParams;
6244  	const wchar_t* text2display = qParams->_quote;
6245  	bool shouldBeTrolling = qParams->_shouldBeTrolling;
6246      ::SendMessage(hNpp, NPPM_MENUCOMMAND, 0, IDM_FILE_NEW);
6247  	if (qParams->_encoding == SC_CP_UTF8)
6248  		::SendMessage(hNpp, NPPM_MENUCOMMAND, 0, IDM_FORMAT_AS_UTF_8);
6249  	else if (qParams->_encoding >= 0)
6250  		pCurrentView->execute(SCI_SETCODEPAGE, qParams->_encoding);
6251  	int langMenuId = (NppParameters::getInstance()).langTypeToCommandID(qParams->_lang);
6252  	::SendMessage(hNpp, NPPM_MENUCOMMAND, 0, langMenuId);
6253  	int x = 2, y = 1;
6254  	if (qParams->_speed == QuoteParams::slow)
6255  	{
6256  		x = 1;
6257  		y = 1;
6258  	}
6259  	else if (qParams->_speed == QuoteParams::rapid)
6260  	{
6261  		x = 2;
6262  		y = 1;
6263  	}
6264  	else if (qParams->_speed == QuoteParams::speedOfLight)
6265  	{
6266  		x = 1;
6267  		y = 0;
6268  	}
6269  	static TextTrollerParams trollerParams;
6270  	trollerParams._pCurrentView = pCurrentView;
6271  	BufferID targetBufID = pCurrentView->getCurrentBufferID();
6272  	trollerParams._targetBufID = targetBufID;
6273  	HANDLE mutex = ::CreateMutex(NULL, false, TEXT("nppTextWriter"));
6274  	trollerParams._mutex = mutex;
6275      HWND curScintilla = pCurrentView->getHSelf();
6276  	const int nbMaxTrolling = 1;
6277  	int nbTrolling = 0;
6278  	vector<int> generatedRans;
6279  	wchar_t previousChar = '\0';
6280  	for (size_t i = 0, len = lstrlen(text2display); i < len ; ++i)
6281      {
6282  		int ranNum = getRandomNumber(maxRange);
6283  		int action = act_doNothing;
6284  		if (shouldBeTrolling && (i > 20 && previousChar == ' ') && nbTrolling < nbMaxTrolling)
6285  		{
6286  			action = getRandomAction(ranNum);
6287  		}
6288  		if (action == act_trolling)
6289  		{
6290  			int wtfIndex = getRandomNumber() % nbWtf;
6291  			if (!isInList(wtfIndex, generatedRans))
6292  			{
6293  				generatedRans.push_back(wtfIndex);
6294  				++nbTrolling;
6295  				trollerParams._text2display = wtf[wtfIndex];
6296  				ReleaseMutex(mutex);
6297  				HANDLE hThread = ::CreateThread(NULL, 0, threadTextTroller, &trollerParams, 0, NULL);
6298  				int sleepTime = 1000 / x * y;
6299  				::Sleep(sleepTime);
6300  				WaitForSingleObject(mutex, INFINITE);
6301  				::CloseHandle(hThread);
6302  			}
6303  		}
6304  		if (text2display[i] == ' ' || text2display[i] == '.')
6305  		{
6306  			int sleepTime = (ranNum + pauseTimeArray[ranNum%nbPauseTime]) / x * y;
6307  			Sleep(sleepTime);
6308  		}
6309  		else
6310  		{
6311  			int sleepTime = (ranNum + intervalTimeArray[ranNum%nbIntervalTime]) / x * y;
6312  			Sleep(sleepTime);
6313  		}
6314  		BufferID currentBufID = pCurrentView->getCurrentBufferID();
6315  		if (currentBufID != targetBufID)
6316  			return TRUE;
6317  		char charToShow[4] = { '\0' };
6318  		::WideCharToMultiByte(CP_UTF8, 0, text2display + i, 1, charToShow, sizeof(charToShow), NULL, NULL);
6319  		::SendMessage(curScintilla, SCI_APPENDTEXT, strlen(charToShow), reinterpret_cast<LPARAM>(charToShow));
6320  		::SendMessage(curScintilla, SCI_GOTOPOS, ::SendMessage(curScintilla, SCI_GETLENGTH, 0, 0), 0);
6321  		previousChar = text2display[i];
6322      }
6323  	const wchar_t* quoter = qParams->_quoter;
6324  	wstring quoter_str = quoter;
6325  	size_t pos = quoter_str.find(TEXT("Anonymous"));
6326  	if (pos == string::npos)
6327  	{
6328  		::SendMessage(curScintilla, SCI_APPENDTEXT, 3, reinterpret_cast<LPARAM>("\n- "));
6329  		::SendMessage(curScintilla, SCI_GOTOPOS, ::SendMessage(curScintilla, SCI_GETLENGTH, 0, 0), 0);
6330  		for (size_t i = 0, len = lstrlen(quoter); i < len; ++i)
6331  		{
6332  			int ranNum = getRandomNumber(maxRange);
6333  			int sleepTime = (ranNum + intervalTimeArray[ranNum%nbIntervalTime]) / x * y;
6334  			Sleep(sleepTime);
6335  			BufferID currentBufID = pCurrentView->getCurrentBufferID();
6336  			if (currentBufID != targetBufID)
6337  				return TRUE;
6338  			char charToShow[4] = { '\0' };
6339  			::WideCharToMultiByte(CP_UTF8, 0, quoter + i, 1, charToShow, sizeof(charToShow), NULL, NULL);
6340  			::SendMessage(curScintilla, SCI_APPENDTEXT, 1, reinterpret_cast<LPARAM>(charToShow));
6341  			::SendMessage(curScintilla, SCI_GOTOPOS, ::SendMessage(curScintilla, SCI_GETLENGTH, 0, 0), 0);
6342  		}
6343  	}
6344      return TRUE;
6345  }
6346  DWORD WINAPI Notepad_plus::threadTextTroller(void *params)
6347  {
6348  	TextTrollerParams *textTrollerParams = static_cast<TextTrollerParams *>(params);
6349  	WaitForSingleObject(textTrollerParams->_mutex, INFINITE);
6350  	srand(static_cast<UINT>(time(NULL)));
6351  	ScintillaEditView *pCurrentView = textTrollerParams->_pCurrentView;
6352  	const wchar_t* text2display = textTrollerParams->_text2display;
6353  	HWND curScintilla = pCurrentView->getHSelf();
6354  	BufferID targetBufID = textTrollerParams->_targetBufID;
6355  	for (size_t i = 0, len = lstrlen(text2display); i < len; ++i)
6356      {
6357          int ranNum = getRandomNumber(maxRange);
6358  		if (text2display[i] == ' ' || text2display[i] == '.')
6359  			Sleep(ranNum + pauseTimeArray[ranNum%nbPauseTime]);
6360  		else
6361  			Sleep(ranNum + intervalTimeArray[ranNum%nbIntervalTime]);
6362  		BufferID currentBufID = pCurrentView->getCurrentBufferID();
6363  		if (currentBufID != targetBufID)
6364  		{
6365  			ReleaseMutex(textTrollerParams->_mutex);
6366  			return TRUE;
6367  		}
6368  		char charToShow[64] = { '\0' };
6369  		::WideCharToMultiByte(CP_UTF8, 0, text2display + i, 1, charToShow, sizeof(charToShow), NULL, NULL);
6370  		::SendMessage(curScintilla, SCI_APPENDTEXT, 1, reinterpret_cast<LPARAM>(charToShow));
6371  		::SendMessage(curScintilla, SCI_GOTOPOS, ::SendMessage(curScintilla, SCI_GETLENGTH, 0, 0), 0);
6372      }
6373  	int n = getRandomNumber();
6374  	int delMethod = n%4;
6375  	if (delMethod == 0)
6376  	{
6377  		size_t len = lstrlen(text2display);
6378  		for (size_t j = 0; j < len; ++j)
6379  		{
6380  			if (!deleteBack(pCurrentView, targetBufID))
6381  				break;
6382  		}
6383  	}
6384  	else if (delMethod == 1)
6385  	{
6386  		size_t len = lstrlen(text2display);
6387  		::SendMessage(curScintilla, SCI_GOTOPOS, ::SendMessage(curScintilla, SCI_GETLENGTH, 0, 0) - len, 0);
6388  		for (size_t j = 0; j < len; ++j)
6389  		{
6390  			if (!deleteForward(pCurrentView, targetBufID))
6391  				break;
6392  		}
6393  	}
6394  	else if (delMethod == 2)
6395  	{
6396  		for (size_t j = 0, len = lstrlen(text2display); j < len; ++j)
6397  		{
6398  			if (!selectBack(pCurrentView, targetBufID))
6399  				break;
6400  		}
6401  		int ranNum = getRandomNumber(maxRange);
6402  		::Sleep(ranNum + pauseTimeArray[ranNum%nbPauseTime]);
6403  		::SendMessage(pCurrentView->getHSelf(), SCI_DELETEBACK, 0, 0);
6404  	}
6405  	else
6406  	{
6407  		auto currentPos = ::SendMessage(pCurrentView->getHSelf(), SCI_GETSELECTIONSTART, 0, 0);
6408  		::SendMessage(pCurrentView->getHSelf(), SCI_SETSELECTION, currentPos, currentPos - lstrlen(text2display));
6409  		BufferID currentBufID = pCurrentView->getCurrentBufferID();
6410  		if (currentBufID != targetBufID)
6411  			return TRUE;
6412  		int ranNum = getRandomNumber(maxRange);
6413  		::Sleep(ranNum + pauseTimeArray[ranNum%nbPauseTime]);
6414  		::SendMessage(pCurrentView->getHSelf(), SCI_DELETEBACK, 0, 0);
6415  	}
6416  	ReleaseMutex(textTrollerParams->_mutex);
6417  	return TRUE;
6418  }
6419  bool Notepad_plus::deleteBack(ScintillaEditView *pCurrentView, BufferID targetBufID)
6420  {
6421  	int ranNum = getRandomNumber(maxRange - 100);
6422  	BufferID currentBufID = pCurrentView->getCurrentBufferID();
6423  	Sleep(ranNum);
6424  	if (currentBufID != targetBufID)
6425  		return false;
6426  	::SendMessage(pCurrentView->getHSelf(), SCI_DELETEBACK, 0, 0);
6427  	return true;
6428  }
6429  bool Notepad_plus::deleteForward(ScintillaEditView *pCurrentView, BufferID targetBufID)
6430  {
6431  	int ranNum = getRandomNumber(maxRange - 100);
6432  	BufferID currentBufID = pCurrentView->getCurrentBufferID();
6433  	Sleep(ranNum);
6434  	if (currentBufID != targetBufID)
6435  		return false;
6436  	::SendMessage(pCurrentView->getHSelf(), SCI_GOTOPOS, ::SendMessage(pCurrentView->getHSelf(), SCI_GETCURRENTPOS, 0, 0) + 1, 0);
6437  	::SendMessage(pCurrentView->getHSelf(), SCI_DELETEBACK, 0, 0);
6438  	return true;
6439  }
6440  bool Notepad_plus::selectBack(ScintillaEditView *pCurrentView, BufferID targetBufID)
6441  {
6442  	int ranNum = getRandomNumber(maxRange - 100);
6443  	BufferID currentBufID = pCurrentView->getCurrentBufferID();
6444  	auto currentPos = ::SendMessage(pCurrentView->getHSelf(), SCI_GETSELECTIONSTART, 0, 0);
6445  	auto currentAnchor = ::SendMessage(pCurrentView->getHSelf(), SCI_GETSELECTIONEND, 0, 0);
6446  	Sleep(ranNum + intervalTimeArray[ranNum%nbIntervalTime]);
6447  	if (currentBufID != targetBufID)
6448  		return false;
6449  	::SendMessage(pCurrentView->getHSelf(), SCI_SETSELECTION, currentAnchor, --currentPos);
6450  	return true;
6451  }
6452  int Notepad_plus::getQuoteIndexFrom(const wchar_t* quoter) const
6453  {
6454  	if (!quoter)
6455  		return -1;
6456  	if (wcsicmp(quoter, TEXT("Get them all!!!")) == 0)
6457  		return -2;
6458  	int nbQuote = sizeof(quotes) / sizeof(QuoteParams);
6459  	if (wcsicmp(quoter, TEXT("random")) == 0)
6460  	{
6461  		srand(static_cast<UINT>(time(NULL)));
6462  		return getRandomNumber(nbQuote);
6463  	}
6464  	for (int i = 0; i < nbQuote; ++i)
6465  	{
6466  		if (wcsicmp(quotes[i]._quoter, quoter) == 0)
6467  			return i;
6468  	}
6469  	return -1;
6470  }
6471  void Notepad_plus::showAllQuotes() const
6472  {
6473  }
6474  void Notepad_plus::showQuoteFromIndex(int index) const
6475  {
6476  	int nbQuote = sizeof(quotes) / sizeof(QuoteParams);
6477  	if (index < 0 || index >= nbQuote) return;
6478  	showQuote(&quotes[index]);
6479  }
6480  void Notepad_plus::showQuote(const QuoteParams* quote) const
6481  {
6482  	static TextPlayerParams params;
6483  	params._quotParams = const_cast<QuoteParams*>(quote);
6484  	params._nppHandle = Notepad_plus::_pPublicInterface->getHSelf();
6485  	params._pCurrentView = _pEditView;
6486  	HANDLE hThread = ::CreateThread(NULL, 0, threadTextPlayer, &params, 0, NULL);
6487  	if (hThread)
6488  		::CloseHandle(hThread);
6489  }
6490  void Notepad_plus::minimizeDialogs()
6491  {
6492  	static StaticDialog* modelessDlgs[] = {&_findReplaceDlg, &_aboutDlg, &_debugInfoDlg, &_runDlg, &_goToLineDlg, &_colEditorDlg, &_configStyleDlg,\
6493  		&_preference, &_pluginsAdminDlg, &_findCharsInRangeDlg, &_md5FromFilesDlg, &_md5FromTextDlg, &_sha2FromFilesDlg, &_sha2FromTextDlg, &_runMacroDlg};
6494  	static size_t nbModelessDlg = sizeof(modelessDlgs) / sizeof(StaticDialog*);
6495  	for (size_t i = 0; i < nbModelessDlg; ++i)
6496  	{
6497  		StaticDialog* pDlg = modelessDlgs[i];
6498  		if (pDlg->isCreated() && pDlg->isVisible())
6499  		{
6500  			pDlg->display(false);
6501  			_sysTrayHiddenHwnd.push_back(pDlg->getHSelf());
6502  		}
6503  	}
6504  }
6505  void Notepad_plus::restoreMinimizeDialogs()
6506  {
6507  	size_t nbDialogs = _sysTrayHiddenHwnd.size();
6508  	for (int i = (static_cast<int>(nbDialogs) - 1); i >= 0; i--)
6509  	{
6510  		::ShowWindow(_sysTrayHiddenHwnd[i], SW_SHOW);
6511  		_sysTrayHiddenHwnd.erase(_sysTrayHiddenHwnd.begin() + i);
6512  	}
6513  }
6514  void Notepad_plus::refreshDarkMode(bool resetStyle)
6515  {
6516  	if (resetStyle)
6517  	{
6518  		NppParameters& nppParams = NppParameters::getInstance();
6519  		::SendMessage(_pPublicInterface->getHSelf(), NPPM_SETEDITORBORDEREDGE, 0, nppParams.getSVP()._showBorderEdge);
6520  		::SendMessage(_subEditView.getHSelf(), NPPM_INTERNAL_REFRESHDARKMODE, 0, 0);
6521  		::SendMessage(_mainEditView.getHSelf(), NPPM_INTERNAL_REFRESHDARKMODE, 0, 0);
6522  		::SendMessage(_mainDocTab.getHSelf(), NPPM_INTERNAL_REFRESHDARKMODE, 0, 0);
6523  		::SendMessage(_subDocTab.getHSelf(), NPPM_INTERNAL_REFRESHDARKMODE, 0, 0);
6524  		::SendMessage(_findInFinderDlg.getHSelf(), NPPM_INTERNAL_REFRESHDARKMODE, 0, 0);
6525  		::RedrawWindow(_findInFinderDlg.getHSelf(), nullptr, nullptr, RDW_INVALIDATE | RDW_ERASE | RDW_FRAME | RDW_ALLCHILDREN);
6526  		::SendMessage(_incrementFindDlg.getHSelf(), NPPM_INTERNAL_REFRESHDARKMODE, 0, 0);
6527  		::RedrawWindow(_pPublicInterface->getHSelf(), nullptr, nullptr, RDW_INVALIDATE | RDW_ERASE | RDW_FRAME | RDW_ALLCHILDREN);
6528  		if (_pProjectPanel_1)
6529  		{
6530  			::SendMessage(_pProjectPanel_1->getHSelf(), NPPM_INTERNAL_REFRESHDARKMODE, 0, 0);
6531  		}
6532  		if (_pProjectPanel_2)
6533  		{
6534  			::SendMessage(_pProjectPanel_2->getHSelf(), NPPM_INTERNAL_REFRESHDARKMODE, 0, 0);
6535  		}
6536  		if (_pProjectPanel_3)
6537  		{
6538  			::SendMessage(_pProjectPanel_3->getHSelf(), NPPM_INTERNAL_REFRESHDARKMODE, 0, 0);
6539  		}
6540  		if (_pFuncList)
6541  		{
6542  			::SendMessage(_pFuncList->getHSelf(), NPPM_INTERNAL_REFRESHDARKMODE, 0, 0);
6543  		}
6544  		if (_pFileBrowser)
6545  		{
6546  			::SendMessage(_pFileBrowser->getHSelf(), NPPM_INTERNAL_REFRESHDARKMODE, 0, 0);
6547  		}
6548  		if (_pAnsiCharPanel)
6549  		{
6550  			::SendMessage(_pAnsiCharPanel->getHSelf(), NPPM_INTERNAL_REFRESHDARKMODE, 0, 0);
6551  		}
6552  		if (_pDocumentListPanel)
6553  		{
6554  			::SendMessage(_pDocumentListPanel->getHSelf(), NPPM_INTERNAL_REFRESHDARKMODE, 0, 0);
6555  		}
6556  		if (_pClipboardHistoryPanel)
6557  		{
6558  			::SendMessage(_pClipboardHistoryPanel->getHSelf(), NPPM_INTERNAL_REFRESHDARKMODE, 0, 0);
6559  		}
6560  		const int tabIconSet = NppDarkMode::getTabIconSet(NppDarkMode::isEnabled());
6561  		if (tabIconSet != -1)
6562  		{
6563  			_preference._generalSubDlg.setTabbarAlternateIcons(tabIconSet == 1);
6564  			::SendMessage(_pPublicInterface->getHSelf(), NPPM_INTERNAL_CHANGETABBAEICONS, static_cast<WPARAM>(false), tabIconSet);
6565  		}
6566  		else
6567  		{
6568  			const bool isChecked = _preference._generalSubDlg.isCheckedOrNot(IDC_CHECK_TAB_ALTICONS);
6569  			if (!isChecked)
6570  			{
6571  				::SendMessage(_pPublicInterface->getHSelf(), NPPM_INTERNAL_CHANGETABBAEICONS, static_cast<WPARAM>(false), NppDarkMode::isEnabled() ? 2 : 0);
6572  			}
6573  		}
6574  		const int iconState = NppDarkMode::getToolBarIconSet(NppDarkMode::isEnabled());
6575  		toolBarStatusType state = (iconState == -1) ? _toolBar.getState() : static_cast<toolBarStatusType>(iconState);
6576  		switch (state)
6577  		{
6578  			case TB_SMALL:
6579  				_toolBar.reduce();
6580  				break;
6581  			case TB_LARGE:
6582  				_toolBar.enlarge();
6583  				break;
6584  			case TB_SMALL2:
6585  				_toolBar.reduceToSet2();
6586  				break;
6587  			case TB_LARGE2:
6588  				_toolBar.enlargeToSet2();
6589  				break;
6590  			case TB_STANDARD:
6591  				_toolBar.setToBmpIcons();
6592  				break;
6593  		}
6594  		ThemeSwitcher& themeSwitcher = nppParams.getThemeSwitcher();
6595  		generic_string themePath;
6596  		generic_string themeName;
6597  		generic_string xmlFileName = NppDarkMode::getThemeName();
6598  		if (!xmlFileName.empty())
6599  		{
6600  			if (!nppParams.isLocal() || nppParams.isCloud())
6601  			{
6602  				themePath = nppParams.getUserPath();
6603  				pathAppend(themePath, TEXT("themes\\"));
6604  				pathAppend(themePath, xmlFileName);
6605  			}
6606  			if (::PathFileExists(themePath.c_str()) == FALSE || themePath.empty())
6607  			{
6608  				themePath = themeSwitcher.getThemeDirPath();
6609  				pathAppend(themePath, xmlFileName);
6610  			}
6611  			themeName = themeSwitcher.getThemeFromXmlFileName(themePath.c_str());
6612  		}
6613  		else
6614  		{
6615  			pair<generic_string, generic_string>& themeInfo = themeSwitcher.getElementFromIndex(0);
6616  			themePath = themeInfo.second;
6617  			themeName = themeSwitcher.getDefaultThemeLabel();
6618  		}
6619  		if (::PathFileExists(themePath.c_str()) == TRUE)
6620  		{
6621  			nppParams.getNppGUI()._themeName = themePath;
6622  			if (_configStyleDlg.isCreated())
6623  			{
6624  				_configStyleDlg.selectThemeByName(themeName.c_str());
6625  			}
6626  			else
6627  			{
6628  				nppParams.reloadStylers(themePath.c_str());
6629  				::SendMessage(_pPublicInterface->getHSelf(), WM_UPDATESCINTILLAS, 0, 0);
6630  			}
6631  		}
6632  		if (NppDarkMode::isExperimentalSupported())
6633  		{
6634  			NppDarkMode::allowDarkModeForApp(NppDarkMode::isEnabled());
6635  			NppDarkMode::setDarkTitleBar(_pPublicInterface->getHSelf());
6636  			::SetWindowPos(_pPublicInterface->getHSelf(), nullptr, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_FRAMECHANGED);
6637  			for (auto& docCont : _dockingManager.getContainerInfo())
6638  			{
6639  				auto hwndDocCont = docCont->getCaptionWnd();
6640  				NppDarkMode::setDarkTitleBar(hwndDocCont);
6641  				::SetWindowPos(hwndDocCont, nullptr, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_FRAMECHANGED);
6642  			}
6643  			for (auto& hwndDlg : _hModelessDlgs)
6644  			{
6645  				NppDarkMode::setDarkTitleBar(hwndDlg);
6646  				::SendMessage(hwndDlg, NPPM_INTERNAL_REFRESHDARKMODE, 0, 0);
6647  				::RedrawWindow(hwndDlg, nullptr, nullptr, RDW_INVALIDATE | RDW_ERASE | RDW_FRAME | RDW_ALLCHILDREN);
6648  				::SetWindowPos(hwndDlg, nullptr, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_FRAMECHANGED);
6649  			}
6650  			NppDarkMode::setDarkTitleBar(_findInFinderDlg.getHSelf());
6651  			::SetWindowPos(_findInFinderDlg.getHSelf(), nullptr, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_FRAMECHANGED);
6652  		}
6653  	}
6654  	else
6655  	{
6656  		for (auto& docCont : _dockingManager.getContainerInfo())
6657  		{
6658  			auto hwndDocCont = docCont->getCaptionWnd();
6659  			::RedrawWindow(hwndDocCont, nullptr, nullptr, RDW_INVALIDATE | RDW_ERASE | RDW_FRAME | RDW_ALLCHILDREN);
6660  		}
6661  		for (auto& hwndDlg : _hModelessDlgs)
6662  		{
6663  			::RedrawWindow(hwndDlg, nullptr, nullptr, RDW_INVALIDATE | RDW_ERASE | RDW_FRAME | RDW_ALLCHILDREN);
6664  		}
6665  		::RedrawWindow(_findInFinderDlg.getHSelf(), nullptr, nullptr, RDW_INVALIDATE | RDW_ERASE | RDW_FRAME | RDW_ALLCHILDREN);
6666  		::RedrawWindow(_pPublicInterface->getHSelf(), nullptr, nullptr, RDW_INVALIDATE | RDW_ERASE | RDW_FRAME | RDW_ALLCHILDREN);
6667  	}
6668  }
6669  void Notepad_plus::launchDocumentBackupTask()
6670  {
6671  	HANDLE hThread = ::CreateThread(NULL, 0, backupDocument, NULL, 0, NULL);
6672  	if (hThread)
6673  		::CloseHandle(hThread);
6674  }
6675  DWORD WINAPI Notepad_plus::backupDocument(void * &bsol;*param*/)
6676  {
6677  	bool isSnapshotMode = true;
6678  	while (isSnapshotMode)
6679  	{
6680  		NppParameters& nppParam = NppParameters::getInstance();
6681  		size_t timer = nppParam.getNppGUI()._snapshotBackupTiming;
6682  		if (timer < 1000)
6683  			timer = 1000;
6684  		::Sleep(DWORD(timer));
6685  		isSnapshotMode = nppParam.getNppGUI().isSnapshotMode();
6686  		if (!isSnapshotMode)
6687  			break;
6688  		::PostMessage(Notepad_plus_Window::gNppHWND, NPPM_INTERNAL_SAVEBACKUP, 0, 0);
6689  	}
6690  	return TRUE;
6691  }
6692  #ifdef _MSC_VER
6693  #pragma warning( disable : 4127 )
6694  #endif
6695  bool Notepad_plus::undoStreamComment(bool tryBlockComment)
6696  {
6697  	const TCHAR *commentStart;
6698  	const TCHAR *commentEnd;
6699  	const TCHAR *commentLineSymbol;
6700  	generic_string symbolStart;
6701  	generic_string symbolEnd;
6702  	generic_string symbol;
6703  	const int charbufLen = 10;
6704      TCHAR charbuf[charbufLen];
6705  	bool retVal = false;
6706  	Buffer * buf = _pEditView->getCurrentBuffer();
6707  	if (buf->isReadOnly())
6708  		return false;
6709  	if (buf->getLangType() == L_USER)
6710  	{
6711  		UserLangContainer * userLangContainer = NppParameters::getInstance().getULCFromName(buf->getUserDefineLangName());
6712  		if (!userLangContainer)
6713  			return false;
6714  		symbol = extractSymbol('0', '0', userLangContainer->_keywordLists[SCE_USER_KWLIST_COMMENTS]);
6715  		commentLineSymbol = symbol.c_str();
6716  		symbolStart = extractSymbol('0', '3', userLangContainer->_keywordLists[SCE_USER_KWLIST_COMMENTS]);
6717  		commentStart = symbolStart.c_str();
6718  		symbolEnd = extractSymbol('0', '4', userLangContainer->_keywordLists[SCE_USER_KWLIST_COMMENTS]);
6719  		commentEnd = symbolEnd.c_str();
6720  	}
6721  	else
6722  	{
6723  		commentLineSymbol = buf->getCommentLineSymbol();
6724  		commentStart = buf->getCommentStart();
6725  		commentEnd = buf->getCommentEnd();
6726  	}
6727  	if ((!commentStart) || (!commentStart[0]) || (commentStart == NULL) || (!commentEnd) || (!commentEnd[0]) || (commentEnd == NULL))
6728  	{
6729  		if (!(!commentLineSymbol || !commentLineSymbol[0] || commentLineSymbol == NULL) && tryBlockComment)
6730  			return doBlockComment(cm_uncomment);
6731  		else
6732  			return false;
6733  	}
6734  	generic_string start_comment(commentStart);
6735  	generic_string end_comment(commentEnd);
6736  	generic_string white_space(TEXT(" "));
6737  	size_t start_comment_length = start_comment.length();
6738  	size_t end_comment_length = end_comment.length();
6739  	_pEditView->execute(SCI_BEGINUNDOACTION);
6740  	do
6741  	{
6742  		auto selectionStart = _pEditView->execute(SCI_GETSELECTIONSTART);
6743  		auto selectionEnd = _pEditView->execute(SCI_GETSELECTIONEND);
6744  		auto caretPosition = _pEditView->execute(SCI_GETCURRENTPOS);
6745  		auto docLength = _pEditView->execute(SCI_GETLENGTH);
6746  		bool move_caret = caretPosition < selectionEnd;
6747  		const int iSelStart=0, iSelEnd=1;
6748  		const size_t N_CMNT = 2;
6749  		intptr_t posStartCommentBefore[N_CMNT], posEndCommentBefore[N_CMNT], posStartCommentAfter[N_CMNT], posEndCommentAfter[N_CMNT];
6750  		bool blnStartCommentBefore[N_CMNT], blnEndCommentBefore[N_CMNT], blnStartCommentAfter[N_CMNT], blnEndCommentAfter[N_CMNT];
6751  		intptr_t posStartComment, posEndComment;
6752  		intptr_t selectionStartMove, selectionEndMove;
6753  		int flags;
6754  		flags = SCFIND_WORDSTART;
6755  		_pEditView->execute(SCI_SETSEARCHFLAGS, flags);
6756  		posStartCommentBefore[iSelStart] = _pEditView->searchInTarget(start_comment.c_str(), start_comment_length, selectionStart, 0);
6757  		(posStartCommentBefore[iSelStart] == -1 ? blnStartCommentBefore[iSelStart] = false : blnStartCommentBefore[iSelStart] = true);
6758  		posEndCommentBefore[iSelStart] = _pEditView->searchInTarget(end_comment.c_str(), end_comment_length, selectionStart, 0);
6759  		(posEndCommentBefore[iSelStart] == -1 ? blnEndCommentBefore[iSelStart] = false : blnEndCommentBefore[iSelStart] = true);
6760  		posStartCommentAfter[iSelStart] = _pEditView->searchInTarget(start_comment.c_str(), start_comment_length, selectionStart, docLength);
6761  		(posStartCommentAfter[iSelStart] == -1 ? blnStartCommentAfter[iSelStart] = false : blnStartCommentAfter[iSelStart] = true);
6762  		posEndCommentAfter[iSelStart] = _pEditView->searchInTarget(end_comment.c_str(), end_comment_length, selectionStart, docLength);
6763  		(posEndCommentAfter[iSelStart] == -1 ? blnEndCommentAfter[iSelStart] = false : blnEndCommentAfter[iSelStart] = true);
6764  		if ((blnStartCommentBefore[iSelStart] && blnEndCommentAfter[iSelStart])
6765  			&& (!blnEndCommentBefore[iSelStart] || (posStartCommentBefore[iSelStart] >= posEndCommentBefore[iSelStart]))
6766  			&& (!blnStartCommentAfter[iSelStart] || (posEndCommentAfter[iSelStart] <= posStartCommentAfter[iSelStart])))
6767  		{
6768  				posStartComment = posStartCommentBefore[iSelStart];
6769  				posEndComment   = posEndCommentAfter[iSelStart];
6770  		}
6771  		else 
6772  		{
6773  			posStartCommentBefore[iSelEnd] = _pEditView->searchInTarget(start_comment.c_str(), start_comment_length, selectionEnd, 0);
6774  			(posStartCommentBefore[iSelEnd] == -1 ? blnStartCommentBefore[iSelEnd] = false : blnStartCommentBefore[iSelEnd] = true);
6775  			posEndCommentBefore[iSelEnd] = _pEditView->searchInTarget(end_comment.c_str(), end_comment_length, selectionEnd, 0);
6776  			(posEndCommentBefore[iSelEnd] == -1 ? blnEndCommentBefore[iSelEnd] = false : blnEndCommentBefore[iSelEnd] = true);
6777  			posStartCommentAfter[iSelEnd] = _pEditView->searchInTarget(start_comment.c_str(), start_comment_length, selectionEnd, docLength);
6778  			(posStartCommentAfter[iSelEnd] == -1 ? blnStartCommentAfter[iSelEnd] = false : blnStartCommentAfter[iSelEnd] = true);
6779  			posEndCommentAfter[iSelEnd] = _pEditView->searchInTarget(end_comment.c_str(), end_comment_length, selectionEnd, docLength);
6780  			(posEndCommentAfter[iSelEnd] == -1 ? blnEndCommentAfter[iSelEnd] = false : blnEndCommentAfter[iSelEnd] = true);
6781  			if ((blnStartCommentBefore[iSelEnd] && blnEndCommentAfter[iSelEnd])
6782  				&& (!blnEndCommentBefore[iSelEnd] || (posStartCommentBefore[iSelEnd] >= posEndCommentBefore[iSelEnd]))
6783  				&& (!blnStartCommentAfter[iSelEnd] || (posEndCommentAfter[iSelEnd] <= posStartCommentAfter[iSelEnd])))
6784  			{
6785  					posStartComment = posStartCommentBefore[iSelEnd];
6786  					posEndComment   = posEndCommentAfter[iSelEnd];
6787  			}
6788  			else if ( (blnStartCommentAfter[iSelStart] && (posStartCommentAfter[iSelStart] < selectionEnd))
6789  				&& (blnEndCommentBefore[iSelEnd] && (posEndCommentBefore[iSelEnd] >  selectionStart)))
6790  			{
6791  					posStartComment = posStartCommentAfter[iSelStart];
6792  					posEndComment   = posEndCommentAfter[iSelStart];
6793  			}
6794  			else
6795  			{
6796  				_pEditView->execute(SCI_ENDUNDOACTION);
6797  				return retVal;
6798  			}
6799  		}
6800  		retVal = true;
6801  		intptr_t startCommentLength = start_comment_length;
6802  		intptr_t endCommentLength = end_comment_length;
6803  		_pEditView->getGenericText(charbuf, charbufLen, posEndComment-1, posEndComment);
6804  		if (wcsncmp(charbuf, white_space.c_str(), white_space.length()) == 0)
6805  		{
6806  			endCommentLength +=1;
6807  			posEndComment-=1;
6808  		}
6809  		_pEditView->execute(SCI_BEGINUNDOACTION);
6810  		_pEditView->execute(SCI_SETSEL, posEndComment, posEndComment + endCommentLength);
6811  		_pEditView->execute(SCI_REPLACESEL, 0, reinterpret_cast<LPARAM>(""));
6812  		_pEditView->getGenericText(charbuf, charbufLen, posStartComment+startCommentLength, posStartComment+startCommentLength+1);
6813  		if (wcsncmp(charbuf, white_space.c_str(), white_space.length()) == 0)
6814  			startCommentLength +=1;
6815  		_pEditView->execute(SCI_SETSEL, posStartComment, posStartComment + startCommentLength);
6816  		_pEditView->execute(SCI_REPLACESEL, 0, reinterpret_cast<LPARAM>(""));
6817  		_pEditView->execute(SCI_ENDUNDOACTION);
6818  		if (selectionStart > posStartComment)
6819  		{
6820  			if (selectionStart >= posStartComment+startCommentLength)
6821  				selectionStartMove = -startCommentLength;
6822  			else
6823  				selectionStartMove = -selectionStart - posStartComment;
6824  		}
6825  		else
6826  			selectionStartMove = 0;
6827  		if (selectionEnd >= posEndComment+endCommentLength)
6828  			selectionEndMove = -startCommentLength+endCommentLength;
6829  		else if (selectionEnd <= posEndComment)
6830  			selectionEndMove = -startCommentLength;
6831  		else
6832  			selectionEndMove = -startCommentLength + (selectionEnd - posEndComment);
6833  		if (move_caret)
6834  		{
6835  			_pEditView->execute(SCI_GOTOPOS, selectionEnd+selectionEndMove);
6836  			_pEditView->execute(SCI_SETCURRENTPOS, selectionStart+selectionStartMove);
6837  		}
6838  		else
6839  		{
6840  			_pEditView->execute(SCI_SETSEL, selectionStart+selectionStartMove, selectionEnd+selectionEndMove);
6841  		}
6842  	}
6843  	while (1); 
6844  }
6845  void Notepad_plus::monitoringStartOrStopAndUpdateUI(Buffer* pBuf, bool isStarting)
6846  {
6847  	if (pBuf)
6848  	{
6849  		if (isStarting)
6850  			pBuf->startMonitoring();
6851  		else
6852  			pBuf->stopMonitoring();
6853  		checkMenuItem(IDM_VIEW_MONITORING, isStarting);
6854  		_toolBar.setCheck(IDM_VIEW_MONITORING, isStarting);
6855  		pBuf->setUserReadOnly(isStarting);
6856  	}
6857  }
6858  void Notepad_plus::createMonitoringThread(Buffer* pBuf)
6859  {
6860  	MonitorInfo *monitorInfo = new Notepad_plus::MonitorInfo(pBuf, _pPublicInterface->getHSelf());
6861  	HANDLE hThread = ::CreateThread(NULL, 0, monitorFileOnChange, (void *)monitorInfo, 0, NULL); 
6862  	if (hThread != nullptr)
6863  		::CloseHandle(hThread);
6864  }
6865  void Notepad_plus::updateCommandShortcuts()
6866  {
6867  	NppParameters& nppParam = NppParameters::getInstance();
6868  	vector<CommandShortcut> & shortcuts = nppParam.getUserShortcuts();
6869  	size_t len = shortcuts.size();
6870  	for (size_t i = 0; i < len; ++i)
6871  	{
6872  		CommandShortcut & csc = shortcuts[i];
6873  		unsigned long id = csc.getID();
6874  		generic_string localizedMenuName = _nativeLangSpeaker.getNativeLangMenuString(id);
6875  		generic_string menuName = localizedMenuName;
6876  		generic_string shortcutName = _nativeLangSpeaker.getShortcutNameString(id);
6877  		if (menuName.length() == 0)
6878  		{
6879  			TCHAR szMenuName[menuItemStrLenMax];
6880  			if (::GetMenuString(_mainMenuHandle, csc.getID(), szMenuName, menuItemStrLenMax, MF_BYCOMMAND))
6881  				menuName = purgeMenuItemString(szMenuName, true);
6882  			else
6883  				menuName = csc.getShortcutName();
6884  		}
6885  		if (shortcutName.length() == 0)
6886  		{
6887  			if (localizedMenuName.length() > 0)
6888  				shortcutName = localizedMenuName;
6889  			else if (csc.getShortcutName()[0])
6890  				shortcutName = csc.getShortcutName();
6891  			else
6892  				shortcutName = menuName;
6893  		}
6894  		csc.setName(wstring2string(menuName, CP_UTF8).c_str(), wstring2string(shortcutName, CP_UTF8).c_str());
6895  	}
6896  }
6897  HBITMAP Notepad_plus::generateSolidColourMenuItemIcon(COLORREF colour)
6898  {
6899  	HDC hDC = GetDC(NULL);
6900  	const int bitmapXYsize = 16;
6901  	HBITMAP hNewBitmap = CreateCompatibleBitmap(hDC, bitmapXYsize, bitmapXYsize);
6902  	HDC hDCn = CreateCompatibleDC(hDC);
6903  	HBITMAP hOldBitmap = static_cast<HBITMAP>(SelectObject(hDCn, hNewBitmap));
6904  	RECT rc = { 0, 0, bitmapXYsize, bitmapXYsize };
6905  	HBRUSH hBlackBrush = CreateSolidBrush(RGB(0,0,0));
6906  	FillRect(hDCn, &rc, hBlackBrush);
6907  	DeleteObject(hBlackBrush);
6908  	rc.left = rc.top = 1;
6909  	rc.right = rc.bottom = bitmapXYsize - 1;
6910  	HBRUSH hColorBrush = CreateSolidBrush(colour);
6911  	FillRect(hDCn, &rc, hColorBrush);
6912  	DeleteObject(hColorBrush);
6913  	SelectObject(hDCn, hOldBitmap);
6914  	DeleteDC(hDCn);
6915  	return hNewBitmap;
6916  }
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-Notepad_plus.cpp</h3>
            <pre><code>1  #include <time.h>
2  #include <shlwapi.h>
3  #include <wininet.h>
4  #include "Notepad_plus.h"
5  #include "Notepad_plus_Window.h"
6  #include "CustomFileDialog.h"
7  #include "Printer.h"
8  #include "FileNameStringSplitter.h"
9  #include "lesDlgs.h"
10  #include "Utf8_16.h"
11  #include "regExtDlg.h"
12  #include "RunDlg.h"
13  #include "ShortcutMapper.h"
14  #include "preferenceDlg.h"
15  #include "TaskListDlg.h"
16  #include "xmlMatchedTagsHighlighter.h"
17  #include "EncodingMapper.h"
18  #include "ansiCharPanel.h"
19  #include "clipboardHistoryPanel.h"
20  #include "VerticalFileSwitcher.h"
21  #include "ProjectPanel.h"
22  #include "documentMap.h"
23  #include "functionListPanel.h"
24  #include "fileBrowser.h"
25  #include "Common.h"
26  #include "NppDarkMode.h"
27  using namespace std;
28  enum tb_stat {tb_saved, tb_unsaved, tb_ro, tb_monitored};
29  #define DIR_LEFT true
30  #define DIR_RIGHT false
31  int docTabIconIDs[] = { IDI_SAVED_ICON,  IDI_UNSAVED_ICON,  IDI_READONLY_ICON,  IDI_MONITORING_ICON };
32  int docTabIconIDs_darkMode[] = { IDI_SAVED_DM_ICON,  IDI_UNSAVED_DM_ICON,  IDI_READONLY_DM_ICON,  IDI_MONITORING_DM_ICON };
33  int docTabIconIDs_alt[] = { IDI_SAVED_ALT_ICON, IDI_UNSAVED_ALT_ICON, IDI_READONLY_ALT_ICON, IDI_MONITORING_ICON };
34  ToolBarButtonUnit toolBarIcons[] = {
35      {IDM_FILE_NEW,                     IDI_NEW_ICON,               IDI_NEW_ICON,                  IDI_NEW_ICON2,              IDI_NEW_ICON2,                 IDI_NEW_ICON_DM,               IDI_NEW_ICON_DM,                  IDI_NEW_ICON_DM2,              IDI_NEW_ICON_DM2,                 IDR_FILENEW},
36      {IDM_FILE_OPEN,                    IDI_OPEN_ICON,              IDI_OPEN_ICON,                 IDI_OPEN_ICON2,             IDI_OPEN_ICON2,                IDI_OPEN_ICON_DM,              IDI_OPEN_ICON_DM,                 IDI_OPEN_ICON_DM2,             IDI_OPEN_ICON_DM2,                IDR_FILEOPEN},
37      {IDM_FILE_SAVE,                    IDI_SAVE_ICON,              IDI_SAVE_DISABLE_ICON,         IDI_SAVE_ICON2,             IDI_SAVE_DISABLE_ICON2,        IDI_SAVE_ICON_DM,              IDI_SAVE_DISABLE_ICON_DM,         IDI_SAVE_ICON_DM2,             IDI_SAVE_DISABLE_ICON_DM2,        IDR_FILESAVE},
38      {IDM_FILE_SAVEALL,                 IDI_SAVEALL_ICON,           IDI_SAVEALL_DISABLE_ICON,      IDI_SAVEALL_ICON2,          IDI_SAVEALL_DISABLE_ICON2,     IDI_SAVEALL_ICON_DM,           IDI_SAVEALL_DISABLE_ICON_DM,      IDI_SAVEALL_ICON_DM2,          IDI_SAVEALL_DISABLE_ICON_DM2,     IDR_SAVEALL},
39      {IDM_FILE_CLOSE,                   IDI_CLOSE_ICON,             IDI_CLOSE_ICON,                IDI_CLOSE_ICON2,            IDI_CLOSE_ICON2,               IDI_CLOSE_ICON_DM,             IDI_CLOSE_ICON_DM,                IDI_CLOSE_ICON_DM2,            IDI_CLOSE_ICON_DM2,               IDR_CLOSEFILE},
40      {IDM_FILE_CLOSEALL,                IDI_CLOSEALL_ICON,          IDI_CLOSEALL_ICON,             IDI_CLOSEALL_ICON2,         IDI_CLOSEALL_ICON2,            IDI_CLOSEALL_ICON_DM,          IDI_CLOSEALL_ICON_DM,             IDI_CLOSEALL_ICON_DM2,         IDI_CLOSEALL_ICON_DM2,            IDR_CLOSEALL},
41      {IDM_FILE_PRINT,                   IDI_PRINT_ICON,             IDI_PRINT_ICON,                IDI_PRINT_ICON2,            IDI_PRINT_ICON2,               IDI_PRINT_ICON_DM,             IDI_PRINT_ICON_DM,                IDI_PRINT_ICON_DM2,            IDI_PRINT_ICON_DM2,               IDR_PRINT},
42      {0,                                IDI_SEPARATOR_ICON,         IDI_SEPARATOR_ICON,            IDI_SEPARATOR_ICON,         IDI_SEPARATOR_ICON,            IDI_SEPARATOR_ICON,            IDI_SEPARATOR_ICON,               IDI_SEPARATOR_ICON,            IDI_SEPARATOR_ICON,            IDI_SEPARATOR_ICON},
43      {IDM_EDIT_CUT,                     IDI_CUT_ICON,               IDI_CUT_DISABLE_ICON,          IDI_CUT_ICON2,              IDI_CUT_DISABLE_ICON2,         IDI_CUT_ICON_DM,               IDI_CUT_DISABLE_ICON_DM,          IDI_CUT_ICON_DM2,              IDI_CUT_DISABLE_ICON_DM2,         IDR_CUT},
44      {IDM_EDIT_COPY,                    IDI_COPY_ICON,              IDI_COPY_DISABLE_ICON,         IDI_COPY_ICON2,             IDI_COPY_DISABLE_ICON2,        IDI_COPY_ICON_DM,              IDI_COPY_DISABLE_ICON_DM,         IDI_COPY_ICON_DM2,             IDI_COPY_DISABLE_ICON_DM2,        IDR_COPY},
45      {IDM_EDIT_PASTE,                   IDI_PASTE_ICON,             IDI_PASTE_DISABLE_ICON,        IDI_PASTE_ICON2,            IDI_PASTE_DISABLE_ICON2,       IDI_PASTE_ICON_DM,             IDI_PASTE_DISABLE_ICON_DM,        IDI_PASTE_ICON_DM2,            IDI_PASTE_DISABLE_ICON_DM2,       IDR_PASTE},
46      {0,                                IDI_SEPARATOR_ICON,         IDI_SEPARATOR_ICON,            IDI_SEPARATOR_ICON,         IDI_SEPARATOR_ICON,            IDI_SEPARATOR_ICON,            IDI_SEPARATOR_ICON,               IDI_SEPARATOR_ICON,            IDI_SEPARATOR_ICON,            IDI_SEPARATOR_ICON},
47      {IDM_EDIT_UNDO,                    IDI_UNDO_ICON,              IDI_UNDO_DISABLE_ICON,         IDI_UNDO_ICON2,             IDI_UNDO_DISABLE_ICON2,        IDI_UNDO_ICON_DM,              IDI_UNDO_DISABLE_ICON_DM,         IDI_UNDO_ICON_DM2,             IDI_UNDO_DISABLE_ICON_DM2,        IDR_UNDO},
48      {IDM_EDIT_REDO,                    IDI_REDO_ICON,              IDI_REDO_DISABLE_ICON,         IDI_REDO_ICON2,             IDI_REDO_DISABLE_ICON2,        IDI_REDO_ICON_DM,              IDI_REDO_DISABLE_ICON_DM,         IDI_REDO_ICON_DM2,             IDI_REDO_DISABLE_ICON_DM2,        IDR_REDO},
49      {0,                                IDI_SEPARATOR_ICON,         IDI_SEPARATOR_ICON,            IDI_SEPARATOR_ICON,         IDI_SEPARATOR_ICON,            IDI_SEPARATOR_ICON,            IDI_SEPARATOR_ICON,               IDI_SEPARATOR_ICON,            IDI_SEPARATOR_ICON,            IDI_SEPARATOR_ICON},
50      {IDM_SEARCH_FIND,                  IDI_FIND_ICON,              IDI_FIND_ICON,                 IDI_FIND_ICON2,             IDI_FIND_ICON2,                IDI_FIND_ICON_DM,              IDI_FIND_ICON_DM,                 IDI_FIND_ICON_DM2,             IDI_FIND_ICON_DM2,                IDR_FIND},
51      {IDM_SEARCH_REPLACE,               IDI_REPLACE_ICON,           IDI_REPLACE_ICON,              IDI_REPLACE_ICON2,          IDI_REPLACE_ICON2,             IDI_REPLACE_ICON_DM,           IDI_REPLACE_ICON_DM,              IDI_REPLACE_ICON_DM2,          IDI_REPLACE_ICON_DM2,             IDR_REPLACE},
52      {0,                                IDI_SEPARATOR_ICON,         IDI_SEPARATOR_ICON,            IDI_SEPARATOR_ICON,         IDI_SEPARATOR_ICON,            IDI_SEPARATOR_ICON,            IDI_SEPARATOR_ICON,               IDI_SEPARATOR_ICON,            IDI_SEPARATOR_ICON,            IDI_SEPARATOR_ICON},
53      {IDM_VIEW_ZOOMIN,                  IDI_ZOOMIN_ICON,            IDI_ZOOMIN_ICON,               IDI_ZOOMIN_ICON2,           IDI_ZOOMIN_ICON2,              IDI_ZOOMIN_ICON_DM,            IDI_ZOOMIN_ICON_DM,               IDI_ZOOMIN_ICON_DM2,           IDI_ZOOMIN_ICON_DM2,              IDR_ZOOMIN},
54      {IDM_VIEW_ZOOMOUT,                 IDI_ZOOMOUT_ICON,           IDI_ZOOMOUT_ICON,              IDI_ZOOMOUT_ICON2,          IDI_ZOOMOUT_ICON2,             IDI_ZOOMOUT_ICON_DM,           IDI_ZOOMOUT_ICON_DM,              IDI_ZOOMOUT_ICON_DM2,          IDI_ZOOMOUT_ICON_DM2,             IDR_ZOOMOUT},
55      {0,                                IDI_SEPARATOR_ICON,         IDI_SEPARATOR_ICON,            IDI_SEPARATOR_ICON,         IDI_SEPARATOR_ICON,            IDI_SEPARATOR_ICON,            IDI_SEPARATOR_ICON,               IDI_SEPARATOR_ICON,            IDI_SEPARATOR_ICON,            IDI_SEPARATOR_ICON},
56      {IDM_VIEW_SYNSCROLLV,              IDI_SYNCV_ICON,             IDI_SYNCV_DISABLE_ICON,        IDI_SYNCV_ICON2,            IDI_SYNCV_DISABLE_ICON2,       IDI_SYNCV_ICON_DM,             IDI_SYNCV_DISABLE_ICON_DM,        IDI_SYNCV_ICON_DM2,            IDI_SYNCV_DISABLE_ICON_DM2,       IDR_SYNCV},
57      {IDM_VIEW_SYNSCROLLH,              IDI_SYNCH_ICON,             IDI_SYNCH_DISABLE_ICON,        IDI_SYNCH_ICON2,            IDI_SYNCH_DISABLE_ICON2,       IDI_SYNCH_ICON_DM,             IDI_SYNCH_DISABLE_ICON_DM,        IDI_SYNCH_ICON_DM2,            IDI_SYNCH_DISABLE_ICON_DM2,       IDR_SYNCH},
58      {0,                                IDI_SEPARATOR_ICON,         IDI_SEPARATOR_ICON,            IDI_SEPARATOR_ICON,         IDI_SEPARATOR_ICON,            IDI_SEPARATOR_ICON,            IDI_SEPARATOR_ICON,               IDI_SEPARATOR_ICON,            IDI_SEPARATOR_ICON,            IDI_SEPARATOR_ICON},
59      {IDM_VIEW_WRAP,                    IDI_VIEW_WRAP_ICON,         IDI_VIEW_WRAP_ICON,            IDI_VIEW_WRAP_ICON2,        IDI_VIEW_WRAP_ICON2,           IDI_VIEW_WRAP_ICON_DM,         IDI_VIEW_WRAP_ICON_DM,            IDI_VIEW_WRAP_ICON_DM2,        IDI_VIEW_WRAP_ICON_DM2,           IDR_WRAP},
60      {IDM_VIEW_ALL_CHARACTERS,          IDI_VIEW_ALL_CHAR_ICON,     IDI_VIEW_ALL_CHAR_ICON,        IDI_VIEW_ALL_CHAR_ICON2,    IDI_VIEW_ALL_CHAR_ICON2,       IDI_VIEW_ALL_CHAR_ICON_DM,     IDI_VIEW_ALL_CHAR_ICON_DM,        IDI_VIEW_ALL_CHAR_ICON_DM2,    IDI_VIEW_ALL_CHAR_ICON_DM2,       IDR_INVISIBLECHAR},
61      {IDM_VIEW_INDENT_GUIDE,            IDI_VIEW_INDENT_ICON,       IDI_VIEW_INDENT_ICON,          IDI_VIEW_INDENT_ICON2,      IDI_VIEW_INDENT_ICON2,         IDI_VIEW_INDENT_ICON_DM,       IDI_VIEW_INDENT_ICON_DM,          IDI_VIEW_INDENT_ICON_DM2,      IDI_VIEW_INDENT_ICON_DM2,         IDR_INDENTGUIDE},
62      {IDM_LANG_USER_DLG,                IDI_VIEW_UD_DLG_ICON,       IDI_VIEW_UD_DLG_ICON,          IDI_VIEW_UD_DLG_ICON2,      IDI_VIEW_UD_DLG_ICON2,         IDI_VIEW_UD_DLG_ICON_DM,       IDI_VIEW_UD_DLG_ICON_DM,          IDI_VIEW_UD_DLG_ICON_DM2,      IDI_VIEW_UD_DLG_ICON_DM2,         IDR_SHOWPANNEL},
63      {IDM_VIEW_DOC_MAP,                 IDI_VIEW_DOC_MAP_ICON,      IDI_VIEW_DOC_MAP_ICON,         IDI_VIEW_DOC_MAP_ICON2,     IDI_VIEW_DOC_MAP_ICON2,        IDI_VIEW_DOC_MAP_ICON_DM,      IDI_VIEW_DOC_MAP_ICON_DM,         IDI_VIEW_DOC_MAP_ICON_DM2,     IDI_VIEW_DOC_MAP_ICON_DM2,        IDR_DOCMAP},
64      {IDM_VIEW_DOCLIST,                 IDI_VIEW_DOCLIST_ICON,      IDI_VIEW_DOCLIST_ICON,         IDI_VIEW_DOCLIST_ICON2,     IDI_VIEW_DOCLIST_ICON2,        IDI_VIEW_DOCLIST_ICON_DM,      IDI_VIEW_DOCLIST_ICON_DM,         IDI_VIEW_DOCLIST_ICON_DM2,     IDI_VIEW_DOCLIST_ICON_DM2,        IDR_DOCLIST},
65      {IDM_VIEW_FUNC_LIST,               IDI_VIEW_FUNCLIST_ICON,     IDI_VIEW_FUNCLIST_ICON,        IDI_VIEW_FUNCLIST_ICON2,    IDI_VIEW_FUNCLIST_ICON2,       IDI_VIEW_FUNCLIST_ICON_DM,     IDI_VIEW_FUNCLIST_ICON_DM,        IDI_VIEW_FUNCLIST_ICON_DM2,    IDI_VIEW_FUNCLIST_ICON_DM2,       IDR_FUNC_LIST},
66      {IDM_VIEW_FILEBROWSER,             IDI_VIEW_FILEBROWSER_ICON,  IDI_VIEW_FILEBROWSER_ICON,     IDI_VIEW_FILEBROWSER_ICON2, IDI_VIEW_FILEBROWSER_ICON2,    IDI_VIEW_FILEBROWSER_ICON_DM,  IDI_VIEW_FILEBROWSER_ICON_DM,     IDI_VIEW_FILEBROWSER_ICON_DM2, IDI_VIEW_FILEBROWSER_ICON_DM2,    IDR_FILEBROWSER},
67      {IDM_VIEW_MONITORING,              IDI_VIEW_MONITORING_ICON,   IDI_VIEW_MONITORING_ICON,      IDI_VIEW_MONITORING_ICON2,  IDI_VIEW_MONITORING_ICON2,     IDI_VIEW_MONITORING_ICON_DM,   IDI_VIEW_MONITORING_ICON_DM,      IDI_VIEW_MONITORING_ICON_DM2,  IDI_VIEW_MONITORING_ICON_DM2,     IDR_FILEMONITORING},
68      {0,                                IDI_SEPARATOR_ICON,         IDI_SEPARATOR_ICON,            IDI_SEPARATOR_ICON,         IDI_SEPARATOR_ICON,            IDI_SEPARATOR_ICON,            IDI_SEPARATOR_ICON,               IDI_SEPARATOR_ICON,            IDI_SEPARATOR_ICON,            IDI_SEPARATOR_ICON},
69      {IDM_MACRO_STARTRECORDINGMACRO,    IDI_STARTRECORD_ICON,       IDI_STARTRECORD_DISABLE_ICON,  IDI_STARTRECORD_ICON2,      IDI_STARTRECORD_DISABLE_ICON2, IDI_STARTRECORD_ICON_DM,       IDI_STARTRECORD_DISABLE_ICON_DM,  IDI_STARTRECORD_ICON_DM2,      IDI_STARTRECORD_DISABLE_ICON_DM2, IDR_STARTRECORD},
70      {IDM_MACRO_STOPRECORDINGMACRO,     IDI_STOPRECORD_ICON,        IDI_STOPRECORD_DISABLE_ICON,   IDI_STOPRECORD_ICON2,       IDI_STOPRECORD_DISABLE_ICON2,  IDI_STOPRECORD_ICON_DM,        IDI_STOPRECORD_DISABLE_ICON_DM,   IDI_STOPRECORD_ICON_DM2,       IDI_STOPRECORD_DISABLE_ICON_DM2,  IDR_STOPRECORD},
71      {IDM_MACRO_PLAYBACKRECORDEDMACRO,  IDI_PLAYRECORD_ICON,        IDI_PLAYRECORD_DISABLE_ICON,   IDI_PLAYRECORD_ICON2,       IDI_PLAYRECORD_DISABLE_ICON2,  IDI_PLAYRECORD_ICON_DM,        IDI_PLAYRECORD_DISABLE_ICON_DM,   IDI_PLAYRECORD_ICON_DM2,       IDI_PLAYRECORD_DISABLE_ICON_DM2,  IDR_PLAYRECORD},
72      {IDM_MACRO_RUNMULTIMACRODLG,       IDI_MMPLAY_ICON,            IDI_MMPLAY_DIS_ICON,           IDI_MMPLAY_ICON2,           IDI_MMPLAY_DIS_ICON2,          IDI_MMPLAY_ICON_DM,            IDI_MMPLAY_DIS_ICON_DM,           IDI_MMPLAY_ICON_DM2,           IDI_MMPLAY_DIS_ICON_DM2,          IDR_M_PLAYRECORD},
73      {IDM_MACRO_SAVECURRENTMACRO,       IDI_SAVERECORD_ICON,        IDI_SAVERECORD_DISABLE_ICON,   IDI_SAVERECORD_ICON2,       IDI_SAVERECORD_DISABLE_ICON2,  IDI_SAVERECORD_ICON_DM,        IDI_SAVERECORD_DISABLE_ICON_DM,   IDI_SAVERECORD_ICON_DM2,       IDI_SAVERECORD_DISABLE_ICON_DM2,  IDR_SAVERECORD}
74  };
75  Notepad_plus::Notepad_plus()
76  	: _autoCompleteMain(&_mainEditView)
77  	, _autoCompleteSub(&_subEditView)
78  	, _smartHighlighter(&_findReplaceDlg)
79  {
80  	ZeroMemory(&_prevSelectedRange, sizeof(_prevSelectedRange));
81  	NppParameters& nppParam = NppParameters::getInstance();
82  	TiXmlDocumentA *nativeLangDocRootA = nppParam.getNativeLangA();
83      _nativeLangSpeaker.init(nativeLangDocRootA);
84  	LocalizationSwitcher & localizationSwitcher = nppParam.getLocalizationSwitcher();
85      const char *fn = _nativeLangSpeaker.getFileName();
86      if (fn)
87      {
88          localizationSwitcher.setFileName(fn);
89      }
90  	nppParam.setNativeLangSpeaker(&_nativeLangSpeaker);
91  	TiXmlDocument *toolIconsDocRoot = nppParam.getCustomizedToolIcons();
92  	if (toolIconsDocRoot)
93  	{
94          _toolBar.initTheme(toolIconsDocRoot);
95      }
96  	BOOL is_admin;
97  	winVer ver = nppParam.getWinVersion();
98  	if (ver >= WV_VISTA || ver == WV_UNKNOWN)
99  	{
100  		SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
101  		PSID AdministratorsGroup;
102  		is_admin = AllocateAndInitializeSid(&NtAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0, 0, 0, &AdministratorsGroup);
103  		if (is_admin)
104  		{
105  			if (!CheckTokenMembership(NULL, AdministratorsGroup, &is_admin))
106  				is_admin = FALSE;
107  			FreeSid(AdministratorsGroup);
108  		}
109  	}
110  	else
111  		is_admin = false;
112  	nppParam.setAdminMode(is_admin == TRUE);
113  	_isAdministrator = is_admin ? true : false;
114  }
115  Notepad_plus::~Notepad_plus()
116  {
117  	(NppParameters::getInstance()).destroyInstance();
118  	delete _pTrayIco;
119  	delete _pAnsiCharPanel;
120  	delete _pClipboardHistoryPanel;
121  	delete _pDocumentListPanel;
122  	delete _pProjectPanel_1;
123  	delete _pProjectPanel_2;
124  	delete _pProjectPanel_3;
125  	delete _pDocMap;
126  	delete _pFuncList;
127  	delete _pFileBrowser;
128  }
129  LRESULT Notepad_plus::init(HWND hwnd)
130  {
131  	NppParameters& nppParam = NppParameters::getInstance();
132  	NppGUI & nppGUI = nppParam.getNppGUI();
133  	_mainMenuHandle = ::GetMenu(hwnd);
134  	int langPos2BeRemoved = MENUINDEX_LANGUAGE + 1;
135  	if (nppGUI._isLangMenuCompact)
136  		langPos2BeRemoved = MENUINDEX_LANGUAGE;
137  	::RemoveMenu(_mainMenuHandle, langPos2BeRemoved, MF_BYPOSITION);
138  	_pDocTab = &_mainDocTab;
139  	_pEditView = &_mainEditView;
140  	_pNonDocTab = &_subDocTab;
141  	_pNonEditView = &_subEditView;
142  	_mainEditView.init(_pPublicInterface->getHinst(), hwnd);
143  	_subEditView.init(_pPublicInterface->getHinst(), hwnd);
144  	_fileEditView.init(_pPublicInterface->getHinst(), hwnd);
145  	MainFileManager.init(this, &_fileEditView); 
146  	nppParam.setFontList(hwnd);
147  	_mainWindowStatus = WindowMainActive;
148  	_activeView = MAIN_VIEW;
149  	const ScintillaViewParams & svp = nppParam.getSVP();
150  	int tabBarStatus = nppGUI._tabStatus;
151  	_toReduceTabBar = ((tabBarStatus & TAB_REDUCE) != 0);
152  	int iconDpiDynamicalSize = nppParam._dpiManager.scaleX(g_TabIconSize);
153  	_docTabIconList.create(iconDpiDynamicalSize, _pPublicInterface->getHinst(), docTabIconIDs, sizeof(docTabIconIDs) / sizeof(int));
154  	_docTabIconListAlt.create(iconDpiDynamicalSize, _pPublicInterface->getHinst(), docTabIconIDs_alt, sizeof(docTabIconIDs_alt) / sizeof(int));
155  	_docTabIconListDarkMode.create(iconDpiDynamicalSize, _pPublicInterface->getHinst(), docTabIconIDs_darkMode, sizeof(docTabIconIDs_darkMode) / sizeof(int));
156  	vector<IconList *> pIconListVector;
157  	pIconListVector.push_back(&_docTabIconList);        
158  	pIconListVector.push_back(&_docTabIconListAlt);     
159  	pIconListVector.push_back(&_docTabIconListDarkMode);
160  	const int tabIconSet = NppDarkMode::getTabIconSet(NppDarkMode::isEnabled());
161  	unsigned char indexDocTabIcon = 0;
162  	switch (tabIconSet)
163  	{
164  		case 0:
165  		{
166  			nppGUI._tabStatus &= ~TAB_ALTICONS;
167  			break;
168  		}
169  		case 1:
170  		{
171  			nppGUI._tabStatus |= TAB_ALTICONS;
172  			indexDocTabIcon = 1;
173  			break;
174  		}
175  		case 2:
176  		{
177  			nppGUI._tabStatus &= ~TAB_ALTICONS;
178  			indexDocTabIcon = 2;
179  			break;
180  		}
181  		default:
182  		{
183  			indexDocTabIcon = ((tabBarStatus & TAB_ALTICONS) == TAB_ALTICONS) ? 1 : (NppDarkMode::isEnabled() ? 2 : 0);
184  		}
185  	}
186  	_mainDocTab.init(_pPublicInterface->getHinst(), hwnd, &_mainEditView, pIconListVector, indexDocTabIcon);
187  	_subDocTab.init(_pPublicInterface->getHinst(), hwnd, &_subEditView, pIconListVector, indexDocTabIcon);
188  	_mainEditView.display();
189  	_invisibleEditView.init(_pPublicInterface->getHinst(), hwnd);
190  	_invisibleEditView.execute(SCI_SETUNDOCOLLECTION);
191  	_invisibleEditView.execute(SCI_EMPTYUNDOBUFFER);
192  	_invisibleEditView.wrap(false); 
193  	_mainEditView.showMargin(ScintillaEditView::_SC_MARGE_LINENUMBER, svp._lineNumberMarginShow);
194  	_subEditView.showMargin(ScintillaEditView::_SC_MARGE_LINENUMBER, svp._lineNumberMarginShow);
195  	_mainEditView.showMargin(ScintillaEditView::_SC_MARGE_SYMBOL, svp._bookMarkMarginShow);
196  	_subEditView.showMargin(ScintillaEditView::_SC_MARGE_SYMBOL, svp._bookMarkMarginShow);
197  	_mainEditView.showIndentGuideLine(svp._indentGuideLineShow);
198  	_subEditView.showIndentGuideLine(svp._indentGuideLineShow);
199  	::SendMessage(hwnd, NPPM_INTERNAL_SETCARETWIDTH, 0, 0);
200  	::SendMessage(hwnd, NPPM_INTERNAL_SETCARETBLINKRATE, 0, 0);
201  	_configStyleDlg.init(_pPublicInterface->getHinst(), hwnd);
202  	_preference.init(_pPublicInterface->getHinst(), hwnd);
203  	_pluginsAdminDlg.init(_pPublicInterface->getHinst(), hwnd);
204  	_mainEditView.setMakerStyle(svp._folderStyle);
205  	_subEditView.setMakerStyle(svp._folderStyle);
206  	_mainEditView.defineDocType(_mainEditView.getCurrentBuffer()->getLangType());
207  	_subEditView.defineDocType(_subEditView.getCurrentBuffer()->getLangType());
208  	_mainEditView.setWrapMode(svp._lineWrapMethod);
209  	_subEditView.setWrapMode(svp._lineWrapMethod);
210  	_mainEditView.execute(SCI_SETENDATLASTLINE, !svp._scrollBeyondLastLine);
211  	_subEditView.execute(SCI_SETENDATLASTLINE, !svp._scrollBeyondLastLine);
212  	if (svp._doSmoothFont)
213  	{
214  		_mainEditView.execute(SCI_SETFONTQUALITY, SC_EFF_QUALITY_LCD_OPTIMIZED);
215  		_subEditView.execute(SCI_SETFONTQUALITY, SC_EFF_QUALITY_LCD_OPTIMIZED);
216  	}
217  	_mainEditView.setBorderEdge(svp._showBorderEdge);
218  	_subEditView.setBorderEdge(svp._showBorderEdge);
219  	_mainEditView.execute(SCI_SETCARETLINEVISIBLEALWAYS, true);
220  	_subEditView.execute(SCI_SETCARETLINEVISIBLEALWAYS, true);
221  	_mainEditView.wrap(svp._doWrap);
222  	_subEditView.wrap(svp._doWrap);
223  	::SendMessage(hwnd, NPPM_INTERNAL_EDGEMULTISETSIZE, 0, 0);
224  	_mainEditView.showEOL(svp._eolShow);
225  	_subEditView.showEOL(svp._eolShow);
226  	_mainEditView.showWSAndTab(svp._whiteSpaceShow);
227  	_subEditView.showWSAndTab(svp._whiteSpaceShow);
228  	_mainEditView.showWrapSymbol(svp._wrapSymbolShow);
229  	_subEditView.showWrapSymbol(svp._wrapSymbolShow);
230  	_mainEditView.performGlobalStyles();
231  	_subEditView.performGlobalStyles();
232  	_zoomOriginalValue = _pEditView->execute(SCI_GETZOOM);
233  	_mainEditView.execute(SCI_SETZOOM, svp._zoom);
234  	_subEditView.execute(SCI_SETZOOM, svp._zoom2);
235  	::SendMessage(hwnd, NPPM_INTERNAL_SETMULTISELCTION, 0, 0);
236  	_mainEditView.execute(SCI_SETADDITIONALSELECTIONTYPING, true);
237  	_subEditView.execute(SCI_SETADDITIONALSELECTIONTYPING, true);
238  	int virtualSpaceOptions = SCVS_RECTANGULARSELECTION;
239  	if(svp._virtualSpace)
240  		virtualSpaceOptions |= SCVS_USERACCESSIBLE | SCVS_NOWRAPLINESTART;
241  	_mainEditView.execute(SCI_SETVIRTUALSPACEOPTIONS, virtualSpaceOptions);
242  	_subEditView.execute(SCI_SETVIRTUALSPACEOPTIONS, virtualSpaceOptions);
243  	_mainEditView.execute(SCI_SETMULTIPASTE, SC_MULTIPASTE_EACH);
244  	_subEditView.execute(SCI_SETMULTIPASTE, SC_MULTIPASTE_EACH);
245  	_mainEditView.execute(SCI_SETMOUSESELECTIONRECTANGULARSWITCH, true);
246  	_subEditView.execute(SCI_SETMOUSESELECTIONRECTANGULARSWITCH, true);
247  	_mainEditView.execute(SCI_SETAUTOMATICFOLD, SC_AUTOMATICFOLD_SHOW | SC_AUTOMATICFOLD_CHANGE);
248  	_subEditView.execute(SCI_SETAUTOMATICFOLD, SC_AUTOMATICFOLD_SHOW | SC_AUTOMATICFOLD_CHANGE);
249  	_mainEditView.execute(SCI_SETMARGINLEFT, 0, svp._paddingLeft);
250  	_mainEditView.execute(SCI_SETMARGINRIGHT, 0, svp._paddingRight);
251  	_subEditView.execute(SCI_SETMARGINLEFT, 0, svp._paddingLeft);
252  	_subEditView.execute(SCI_SETMARGINRIGHT, 0, svp._paddingRight);
253  	_mainEditView.execute(SCI_STYLESETCHECKMONOSPACED, STYLE_DEFAULT, true);
254  	_subEditView.execute(SCI_STYLESETCHECKMONOSPACED, STYLE_DEFAULT, true);
255  	TabBarPlus::doDragNDrop(true);
256  	const auto& hf = _mainDocTab.getFont(_toReduceTabBar);
257  	if (hf)
258  	{
259  		::SendMessage(_mainDocTab.getHSelf(), WM_SETFONT, reinterpret_cast<WPARAM>(hf), MAKELPARAM(TRUE, 0));
260  		::SendMessage(_subDocTab.getHSelf(), WM_SETFONT, reinterpret_cast<WPARAM>(hf), MAKELPARAM(TRUE, 0));
261  	}
262  	int tabDpiDynamicalHeight = nppParam._dpiManager.scaleY(_toReduceTabBar ? g_TabHeight : g_TabHeightLarge);
263  	int tabDpiDynamicalWidth = nppParam._dpiManager.scaleX(g_TabWidth);
264  	TabCtrl_SetItemSize(_mainDocTab.getHSelf(), tabDpiDynamicalWidth, tabDpiDynamicalHeight);
265  	TabCtrl_SetItemSize(_subDocTab.getHSelf(), tabDpiDynamicalWidth, tabDpiDynamicalHeight);
266  	_mainDocTab.display();
267  	TabBarPlus::doDragNDrop((tabBarStatus & TAB_DRAGNDROP) != 0);
268  	TabBarPlus::setDrawTopBar((tabBarStatus & TAB_DRAWTOPBAR) != 0);
269  	TabBarPlus::setDrawInactiveTab((tabBarStatus & TAB_DRAWINACTIVETAB) != 0);
270  	TabBarPlus::setDrawTabCloseButton((tabBarStatus & TAB_CLOSEBUTTON) != 0);
271  	TabBarPlus::setDbClk2Close((tabBarStatus & TAB_DBCLK2CLOSE) != 0);
272  	TabBarPlus::setVertical((tabBarStatus & TAB_VERTICAL) != 0);
273  	drawTabbarColoursFromStylerArray();
274  	const Style* pStyle = NppParameters::getInstance().getGlobalStylers().findByID(STYLE_DEFAULT);
275  	if (pStyle)
276  	{
277  		NppParameters::getInstance().setCurrentDefaultFgColor(pStyle->_fgColor);
278  		NppParameters::getInstance().setCurrentDefaultBgColor(pStyle->_bgColor);
279  		drawAutocompleteColoursFromTheme(pStyle->_fgColor, pStyle->_bgColor);
280  	}
281  	AutoCompletion::drawAutocomplete(_pEditView);
282  	AutoCompletion::drawAutocomplete(_pNonEditView);
283  	drawDocumentMapColoursFromStylerArray();
284  	bool isVertical = (nppGUI._splitterPos == POS_VERTICAL);
285  	int splitterSizeDyn = nppParam._dpiManager.scaleX(splitterSize);
286  	_subSplitter.init(_pPublicInterface->getHinst(), hwnd);
287  	_subSplitter.create(&_mainDocTab, &_subDocTab, splitterSizeDyn, SplitterMode::DYNAMIC, 50, isVertical);
288  	bool willBeShown = nppGUI._statusBarShow;
289  	_statusBar.init(_pPublicInterface->getHinst(), hwnd, 6);
290  	_statusBar.setPartWidth(STATUSBAR_DOC_SIZE, nppParam._dpiManager.scaleX(220));
291  	_statusBar.setPartWidth(STATUSBAR_CUR_POS, nppParam._dpiManager.scaleX(260));
292  	_statusBar.setPartWidth(STATUSBAR_EOF_FORMAT, nppParam._dpiManager.scaleX(110));
293  	_statusBar.setPartWidth(STATUSBAR_UNICODE_TYPE, nppParam._dpiManager.scaleX(120));
294  	_statusBar.setPartWidth(STATUSBAR_TYPING_MODE, nppParam._dpiManager.scaleX(30));
295  	_statusBar.display(willBeShown);
296  	_pMainWindow = &_mainDocTab;
297  	_dockingManager.init(_pPublicInterface->getHinst(), hwnd, &_pMainWindow);
298  	if (nppGUI._isMinimizedToTray && _pTrayIco == nullptr)
299  	{
300  		HICON icon = nullptr;
301  		Notepad_plus_Window::loadTrayIcon(_pPublicInterface->getHinst(), &icon);
302  		_pTrayIco = new trayIconControler(hwnd, IDI_M30ICON, NPPM_INTERNAL_MINIMIZED_TRAY, icon, TEXT(""));
303  	}
304  	checkSyncState();
305  	NppData nppData;
306  	nppData._nppHandle = hwnd;
307  	nppData._scintillaMainHandle = _mainEditView.getHSelf();
308  	nppData._scintillaSecondHandle = _subEditView.getHSelf();
309  	_scintillaCtrls4Plugins.init(_pPublicInterface->getHinst(), hwnd);
310  	_pluginsManager.init(nppData);
311  	bool enablePluginAdmin = _pluginsAdminDlg.initFromJson();
312  	_pluginsManager.loadPlugins(nppParam.getPluginRootDir(), enablePluginAdmin ? &_pluginsAdminDlg.getAvailablePluginUpdateInfoList() : nullptr, enablePluginAdmin ? &_pluginsAdminDlg.getIncompatibleList() : nullptr);
313  	_restoreButton.init(_pPublicInterface->getHinst(), hwnd);
314  	setupColorSampleBitmapsOnMainMenuItems();
315  	HMENU hMacroMenu = ::GetSubMenu(_mainMenuHandle, MENUINDEX_MACRO);
316  	size_t const macroPosBase = 6;
317  	DynamicMenu& macroMenuItems = nppParam.getMacroMenuItems();
318  	size_t nbMacroTopLevelItem = macroMenuItems.getTopLevelItemNumber();
319  	if (nbMacroTopLevelItem >= 1)
320  		::InsertMenu(hMacroMenu, macroPosBase - 1, MF_BYPOSITION, static_cast<UINT>(-1), 0);
321  	macroMenuItems.attach(hMacroMenu, macroPosBase, IDM_SETTING_SHORTCUT_MAPPER_MACRO, TEXT("Modify Shortcut/Delete Macro..."));
322  	HMENU hRunMenu = ::GetSubMenu(_mainMenuHandle, MENUINDEX_RUN);
323  	int const runPosBase = 2;
324  	DynamicMenu& runMenuItems = nppParam.getRunMenuItems();
325  	size_t nbRunTopLevelItem = runMenuItems.getTopLevelItemNumber();
326  	if (nbRunTopLevelItem >= 1)
327  		::InsertMenu(hRunMenu, runPosBase - 1, MF_BYPOSITION, static_cast<UINT>(-1), 0);
328  	runMenuItems.attach(hRunMenu, runPosBase, IDM_SETTING_SHORTCUT_MAPPER_RUN, TEXT("Modify Shortcut/Delete Command..."));
329  	if (!nppGUI._doesExistUpdater)
330  	{
331  		::DeleteMenu(_mainMenuHandle, IDM_UPDATE_NPP, MF_BYCOMMAND);
332  		::DeleteMenu(_mainMenuHandle, IDM_CONFUPDATERPROXY, MF_BYCOMMAND);
333  		HMENU hHelpMenu = ::GetSubMenu(_mainMenuHandle, MENUINDEX_HELP);
334  		if (hHelpMenu)
335  			::DeleteMenu(hHelpMenu, 7, MF_BYPOSITION); 
336  		::DrawMenuBar(hwnd);
337  	}
338  	HMENU hLangMenu = ::GetSubMenu(_mainMenuHandle, MENUINDEX_LANGUAGE);
339  	WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
340  	for (int i = 0; i < nppParam.getNbExternalLang(); ++i)
341  	{
342  		HMENU subMenu = hLangMenu;
343  		ExternalLangContainer & externalLangContainer = nppParam.getELCFromIndex(i);
344  		int nbItem = ::GetMenuItemCount(subMenu);
345  		TCHAR buffer[MAX_EXTERNAL_LEXER_NAME_LEN]{TEXT('\0')};
346  		const TCHAR* lexerNameW = wmc.char2wchar(externalLangContainer._name.c_str(), CP_ACP);
347  		int x = 0;
348  		MENUITEMINFO menuItemInfo
349  		{
350  			.cbSize = sizeof(MENUITEMINFO),
351  			.fMask = MIIM_FTYPE
352  		};
353  		for (; x < nbItem; ++x)
354  		{
355  			::GetMenuItemInfo(subMenu, x, TRUE, &menuItemInfo);
356  			if (menuItemInfo.fType & MFT_SEPARATOR)
357  			{
358  				break;
359  			}
360  		}
361  		TCHAR firstLetter = towupper(lexerNameW[0]);
362  		menuItemInfo.fMask = MIIM_SUBMENU;
363  		for (++x; x < nbItem; ++x)
364  		{
365  			::GetMenuItemInfo(subMenu, x, TRUE, &menuItemInfo);
366  			::GetMenuString(subMenu, x, buffer, MAX_EXTERNAL_LEXER_NAME_LEN, MF_BYPOSITION);
367  			if (menuItemInfo.hSubMenu && buffer[0] == firstLetter)
368  			{
369  				subMenu = menuItemInfo.hSubMenu;
370  				nbItem = ::GetMenuItemCount(subMenu);
371  				x = -1;
372  			}
373  			else if (lstrcmp(lexerNameW, buffer) < 0)
374  			{
375  				break;
376  			}
377  		}
378  		::InsertMenu(subMenu, x, MF_BYPOSITION, IDM_LANG_EXTERNAL + i, lexerNameW);
379  	}
380  	if (nppGUI._excludedLangList.size() > 0)
381  	{
382  		for (size_t i = 0, len = nppGUI._excludedLangList.size(); i < len; ++i)
383  		{
384  			int cmdID = nppParam.langTypeToCommandID(nppGUI._excludedLangList[i]._langType);
385  			const int itemSize = 256;
386  			TCHAR itemName[itemSize];
387  			::GetMenuString(hLangMenu, cmdID, itemName, itemSize, MF_BYCOMMAND);
388  			nppGUI._excludedLangList[i]._cmdID = cmdID;
389  			nppGUI._excludedLangList[i]._langName = itemName;
390  			::DeleteMenu(hLangMenu, cmdID, MF_BYCOMMAND);
391  			DrawMenuBar(hwnd);
392  		}
393  	}
394  	int udlpos = ::GetMenuItemCount(hLangMenu) - 1;
395  	for (int i = 0, len = nppParam.getNbUserLang(); i < len; ++i)
396  	{
397  		UserLangContainer & userLangContainer = nppParam.getULCFromIndex(i);
398  		::InsertMenu(hLangMenu, udlpos + i, MF_BYPOSITION, IDM_LANG_USER + i + 1, userLangContainer.getName());
399  	}
400  	HMENU hFileMenu = ::GetSubMenu(_mainMenuHandle, MENUINDEX_FILE);
401  	int nbLRFile = nppParam.getNbLRFile();
402  	_lastRecentFileList.initMenu(hFileMenu, IDM_FILEMENU_LASTONE + 1, IDM_FILEMENU_EXISTCMDPOSITION, &_accelerator, nppParam.putRecentFileInSubMenu());
403  	_lastRecentFileList.setLangEncoding(_nativeLangSpeaker.getLangEncoding());
404  	for (int i = 0; i < nbLRFile; ++i)
405  	{
406  		generic_string * stdStr = nppParam.getLRFile(i);
407  		if (!nppGUI._checkHistoryFiles || PathFileExists(stdStr->c_str()))
408  		{
409  			_lastRecentFileList.add(stdStr->c_str());
410  		}
411  	}
412  	_pluginsAdminDlg.setPluginsManager(&_pluginsManager);
413  	_pluginsManager.initMenu(_mainMenuHandle, enablePluginAdmin);
414  	::EnableMenuItem(_mainMenuHandle, IDM_FOCUS_ON_FOUND_RESULTS, MF_DISABLED | MF_GRAYED | MF_BYCOMMAND);
415  	nppParam.getContextMenuFromXmlTree(_mainMenuHandle, _pluginsManager.getMenuHandle());
416  	nppParam.getContextMenuFromXmlTree(_mainMenuHandle, _pluginsManager.getMenuHandle(), false);
417  	if (nppParam.hasCustomContextMenu())
418  	{
419  		_mainEditView.execute(SCI_USEPOPUP, FALSE);
420  		_subEditView.execute(SCI_USEPOPUP, FALSE);
421  	}
422  	_nativeLangSpeaker.changeMenuLang(_mainMenuHandle);
423  	::DrawMenuBar(hwnd);
424  	_windowsMenu.init(_mainMenuHandle);
425  	vector<MenuItemUnit> & tmp = nppParam.getContextMenuItems();
426  	size_t len = tmp.size();
427  	TCHAR menuName[menuItemStrLenMax];
428  	for (size_t i = 0; i < len; ++i)
429  	{
430  		if (tmp[i]._itemName.empty())
431  		{
432  			::GetMenuString(_mainMenuHandle, tmp[i]._cmdID, menuName, menuItemStrLenMax, MF_BYCOMMAND);
433  			tmp[i]._itemName = purgeMenuItemString(menuName);
434  		}
435  	}
436  	vector<MenuItemUnit>& tmp2 = nppParam.getTabContextMenuItems();
437  	size_t len2 = tmp2.size();
438  	for (size_t i = 0; i < len2; ++i)
439  	{
440  		if (tmp2[i]._itemName.empty())
441  		{
442  			::GetMenuString(_mainMenuHandle, tmp2[i]._cmdID, menuName, menuItemStrLenMax, MF_BYCOMMAND);
443  			tmp2[i]._itemName = purgeMenuItemString(menuName);
444  		}
445  	}
446  	updateCommandShortcuts();
447  	_nativeLangSpeaker.changeShortcutLang();
448  	nppParam.reloadPluginCmds();
449  	_accelerator.init(_mainMenuHandle, hwnd);
450  	nppParam.setAccelerator(&_accelerator);
451  	vector<HWND> scints;
452  	scints.push_back(_mainEditView.getHSelf());
453  	scints.push_back(_subEditView.getHSelf());
454  	_scintaccelerator.init(&scints, _mainMenuHandle, hwnd);
455  	nppParam.setScintillaAccelerator(&_scintaccelerator);
456  	_scintaccelerator.updateKeys();
457  	::DrawMenuBar(hwnd);
458  	const int toolbarState = NppDarkMode::getToolBarIconSet(NppDarkMode::isEnabled());
459  	if (toolbarState != -1)
460  	{
461  		nppGUI._toolBarStatus = static_cast<toolBarStatusType>(toolbarState);
462  	}
463  	toolBarStatusType tbStatus = nppGUI._toolBarStatus;
464  	willBeShown = nppGUI._toolbarShow;
465  	SCNotification scnN{};
466  	scnN.nmhdr.code = NPPN_TBMODIFICATION;
467  	scnN.nmhdr.hwndFrom = hwnd;
468  	scnN.nmhdr.idFrom = 0;
469  	_pluginsManager.notify(&scnN);
470  	_toolBar.init(_pPublicInterface->getHinst(), hwnd, tbStatus, toolBarIcons, sizeof(toolBarIcons) / sizeof(ToolBarButtonUnit));
471  	_rebarTop.init(_pPublicInterface->getHinst(), hwnd);
472  	_rebarBottom.init(_pPublicInterface->getHinst(), hwnd);
473  	_toolBar.addToRebar(&_rebarTop);
474  	_rebarTop.setIDVisible(REBAR_BAR_TOOLBAR, willBeShown);
475  	checkMacroState();
476  	_findReplaceDlg.init(_pPublicInterface->getHinst(), hwnd, &_pEditView);
477  	_findInFinderDlg.init(_pPublicInterface->getHinst(), hwnd);
478  	_incrementFindDlg.init(_pPublicInterface->getHinst(), hwnd, &_findReplaceDlg, _nativeLangSpeaker.isRTL());
479  	_incrementFindDlg.addToRebar(&_rebarBottom);
480  	_goToLineDlg.init(_pPublicInterface->getHinst(), hwnd, &_pEditView);
481  	_findCharsInRangeDlg.init(_pPublicInterface->getHinst(), hwnd, &_pEditView);
482  	_colEditorDlg.init(_pPublicInterface->getHinst(), hwnd, &_pEditView);
483  	_aboutDlg.init(_pPublicInterface->getHinst(), hwnd);
484  	_debugInfoDlg.init(_pPublicInterface->getHinst(), hwnd, _isAdministrator, _pluginsManager.getLoadedPluginNames());
485  	_runDlg.init(_pPublicInterface->getHinst(), hwnd);
486  	_runMacroDlg.init(_pPublicInterface->getHinst(), hwnd);
487  	_documentPeeker.init(_pPublicInterface->getHinst(), hwnd);
488  	_md5FromFilesDlg.init(_pPublicInterface->getHinst(), hwnd);
489  	_md5FromFilesDlg.setHashType(hash_md5);
490  	_md5FromTextDlg.init(_pPublicInterface->getHinst(), hwnd);
491  	_md5FromTextDlg.setHashType(hash_md5);
492  	_sha2FromFilesDlg.init(_pPublicInterface->getHinst(), hwnd);
493  	_sha2FromFilesDlg.setHashType(hash_sha256);
494  	_sha2FromTextDlg.init(_pPublicInterface->getHinst(), hwnd);
495  	_sha2FromTextDlg.setHashType(hash_sha256);
496  	_sha1FromFilesDlg.init(_pPublicInterface->getHinst(), hwnd);
497  	_sha1FromFilesDlg.setHashType(hash_sha1);
498  	_sha1FromTextDlg.init(_pPublicInterface->getHinst(), hwnd);
499  	_sha1FromTextDlg.setHashType(hash_sha1);
500  	_sha512FromFilesDlg.init(_pPublicInterface->getHinst(), hwnd);
501  	_sha512FromFilesDlg.setHashType(hash_sha512);
502  	_sha512FromTextDlg.init(_pPublicInterface->getHinst(), hwnd);
503  	_sha512FromTextDlg.setHashType(hash_sha512);
504  	int uddStatus = nppGUI._userDefineDlgStatus;
505  	UserDefineDialog *udd = _pEditView->getUserDefineDlg();
506  	bool uddShow = false;
507  	switch (uddStatus)
508  	{
509  		case UDD_SHOW: 
510  		{
511  			udd->doDialog(true, _nativeLangSpeaker.isRTL());
512  			_nativeLangSpeaker.changeUserDefineLang(udd);
513  			uddShow = true;
514  			break;
515  		}
516  		case UDD_DOCKED: 
517  		{
518  			_isUDDocked = true;
519  			break;
520  		}
521  		case (UDD_SHOW | UDD_DOCKED):    
522  		{
523  			udd->doDialog(true, _nativeLangSpeaker.isRTL());
524  			_nativeLangSpeaker.changeUserDefineLang(udd);
525  			::SendMessage(udd->getHSelf(), WM_COMMAND, IDC_DOCK_BUTTON, 0);
526  			uddShow = true;
527  			break;
528  		}
529  		default: 
530  			break;
531  	}
532  	checkMenuItem(IDM_LANG_USER_DLG, uddShow);
533  	_toolBar.setCheck(IDM_LANG_USER_DLG, uddShow);
534  	if (nppGUI._hideMenuRightShortcuts)
535  	{
536  		int nbRemoved = 0;
537  		const int bufferSize = 64;
538  		TCHAR buffer[bufferSize];
539  		int nbItem = GetMenuItemCount(_mainMenuHandle);
540  		for (int i = nbItem - 1; i >= 0; --i)
541  		{
542  			::GetMenuStringW(_mainMenuHandle, i, buffer, bufferSize, MF_BYPOSITION);
543  			if (lstrcmp(buffer, L"✕") == 0 || lstrcmp(buffer, L"▼") == 0 || lstrcmp(buffer, L"＋") == 0)
544  			{
545  				::RemoveMenu(_mainMenuHandle, i, MF_BYPOSITION);
546  				++nbRemoved;
547  			}
548  			if (nbRemoved == 3)
549  				break;
550  		}
551  		if (nbRemoved > 0)
552  			::DrawMenuBar(hwnd);
553  	}
554  	{
555  		const Style * pStyle = nppParam.getGlobalStylers().findByID(STYLE_DEFAULT);
556  		if (pStyle)
557  		{
558  			nppParam.setCurrentDefaultFgColor(pStyle->_fgColor);
559  			nppParam.setCurrentDefaultBgColor(pStyle->_bgColor);
560  		}
561  	}
562  	DockingManagerData& dmd = nppGUI._dockingData;
563  	_dockingManager.setDockedContSize(CONT_LEFT, nppGUI._dockingData._leftWidth);
564  	_dockingManager.setDockedContSize(CONT_RIGHT, nppGUI._dockingData._rightWidth);
565  	_dockingManager.setDockedContSize(CONT_TOP, nppGUI._dockingData._topHeight);
566  	_dockingManager.setDockedContSize(CONT_BOTTOM, nppGUI._dockingData._bottomHight);
567  	{
568  		for (size_t i = 0, len = dmd._pluginDockInfo.size(); i < len; ++i)
569  		{
570  			PluginDlgDockingInfo& pdi = dmd._pluginDockInfo[i];
571  			const bool isInternalFunc = pdi._name == NPP_INTERNAL_FUCTION_STR;
572  			bool showPanel = true;
573  			if (nppGUI._isCmdlineNosessionActivated)
574  			{
575  				const bool showProjectPanel = isInternalFunc
576  					&& nppGUI._projectPanelKeepState
577  					&& (pdi._internalID != IDM_EDIT_CLIPBOARDHISTORY_PANEL
578  						&& pdi._internalID != IDM_VIEW_DOCLIST
579  						&& pdi._internalID != IDM_EDIT_CHAR_PANEL
580  						&& pdi._internalID != IDM_VIEW_FILEBROWSER
581  						&& pdi._internalID != IDM_VIEW_DOC_MAP
582  						&& pdi._internalID != IDM_VIEW_FUNC_LIST);
583  				const bool showInternalPanel = isInternalFunc
584  					&& ((pdi._internalID == IDM_EDIT_CLIPBOARDHISTORY_PANEL && nppGUI._clipboardHistoryPanelKeepState)
585  						|| (pdi._internalID == IDM_VIEW_DOCLIST && nppGUI._docListKeepState)
586  						|| (pdi._internalID == IDM_EDIT_CHAR_PANEL && nppGUI._charPanelKeepState)
587  						|| (pdi._internalID == IDM_VIEW_FILEBROWSER && nppGUI._fileBrowserKeepState)
588  						|| (showProjectPanel)
589  						|| (pdi._internalID == IDM_VIEW_DOC_MAP && nppGUI._docMapKeepState)
590  						|| (pdi._internalID == IDM_VIEW_FUNC_LIST && nppGUI._funcListKeepState));
591  				showPanel = ((!isInternalFunc && nppGUI._pluginPanelKeepState) || showInternalPanel);
592  			}
593  			if (pdi._isVisible && showPanel)
594  			{
595  				if (isInternalFunc)
596  					_internalFuncIDs.push_back(pdi._internalID);
597  				else
598  					_pluginsManager.runPluginCommand(pdi._name.c_str(), pdi._internalID);
599  			}
600  		}
601  		for (size_t i = 0, len = dmd._containerTabInfo.size(); i < len; ++i)
602  		{
603  			ContainerTabInfo & cti = dmd._containerTabInfo[i];
604  			_dockingManager.setActiveTab(cti._cont, cti._activeTab);
605  		}
606  	}
607  	loadBufferIntoView(_mainEditView.getCurrentBufferID(), MAIN_VIEW);
608  	loadBufferIntoView(_subEditView.getCurrentBufferID(), SUB_VIEW);
609  	activateBuffer(_mainEditView.getCurrentBufferID(), MAIN_VIEW);
610  	activateBuffer(_subEditView.getCurrentBufferID(), SUB_VIEW);
611  	_mainEditView.getFocus();
612  	if (_nativeLangSpeaker.isRTL())
613  	{
614  		_mainEditView.changeTextDirection(true);
615  		_subEditView.changeTextDirection(true);
616  	}
617  	return TRUE;
618  }
619  void Notepad_plus::killAllChildren()
620  {
621  	_toolBar.destroy();
622  	_rebarTop.destroy();
623  	_rebarBottom.destroy();
624      if (_pMainSplitter)
625      {
626          _pMainSplitter->destroy();
627          delete _pMainSplitter;
628      }
629      _mainDocTab.destroy();
630      _subDocTab.destroy();
631  	_mainEditView.destroy();
632      _subEditView.destroy();
633  	_invisibleEditView.destroy();
634      _subSplitter.destroy();
635      _statusBar.destroy();
636  	_scintillaCtrls4Plugins.destroy();
637  	_dockingManager.destroy();
638  }
639  bool Notepad_plus::saveGUIParams()
640  {
641  	NppParameters& nppParams = NppParameters::getInstance();
642  	NppGUI & nppGUI = nppParams.getNppGUI();
643  	nppGUI._toolbarShow = _rebarTop.getIDVisible(REBAR_BAR_TOOLBAR);
644  	nppGUI._toolBarStatus = _toolBar.getState();
645  	nppGUI._tabStatus = (TabBarPlus::doDragNDropOrNot()?TAB_DRAWTOPBAR:0) | \
646  						(TabBarPlus::drawTopBar()?TAB_DRAGNDROP:0) | \
647  						(TabBarPlus::drawInactiveTab()?TAB_DRAWINACTIVETAB:0) | \
648  						(_toReduceTabBar?TAB_REDUCE:0) | \
649  						(TabBarPlus::drawTabCloseButton()?TAB_CLOSEBUTTON:0) | \
650  						(TabBarPlus::isDbClk2Close()?TAB_DBCLK2CLOSE:0) | \
651  						(TabBarPlus::isVertical() ? TAB_VERTICAL:0) | \
652  						(TabBarPlus::isMultiLine() ? TAB_MULTILINE:0) |\
653  						(nppGUI._tabStatus & TAB_HIDE) | \
654  						(nppGUI._tabStatus & TAB_QUITONEMPTY) | \
655  						(nppGUI._tabStatus & TAB_ALTICONS);
656  	nppGUI._splitterPos = _subSplitter.isVertical()?POS_VERTICAL:POS_HORIZOTAL;
657  	UserDefineDialog *udd = _pEditView->getUserDefineDlg();
658  	bool b = udd->isDocked();
659  	nppGUI._userDefineDlgStatus = (b?UDD_DOCKED:0) | (udd->isVisible()?UDD_SHOW:0);
660  	WINDOWPLACEMENT posInfo{};
661  	posInfo.length = sizeof(WINDOWPLACEMENT);
662  	::GetWindowPlacement(_pPublicInterface->getHSelf(), &posInfo);
663  	nppGUI._appPos.left   = posInfo.rcNormalPosition.left;
664  	nppGUI._appPos.top    = posInfo.rcNormalPosition.top;
665  	nppGUI._appPos.right  = posInfo.rcNormalPosition.right - posInfo.rcNormalPosition.left;
666  	nppGUI._appPos.bottom = posInfo.rcNormalPosition.bottom - posInfo.rcNormalPosition.top;
667  	nppGUI._isMaximized = ((IsZoomed(_pPublicInterface->getHSelf()) != 0) || (posInfo.flags & WPF_RESTORETOMAXIMIZED));
668  	if (_findReplaceDlg.getHSelf() != NULL)
669  	{
670  		::GetWindowPlacement(_findReplaceDlg.getHSelf(), &posInfo);
671  		nppGUI._findWindowPos.left = posInfo.rcNormalPosition.left;
672  		nppGUI._findWindowPos.top = posInfo.rcNormalPosition.top;
673  		nppGUI._findWindowPos.right = posInfo.rcNormalPosition.right;
674  		nppGUI._findWindowPos.bottom = posInfo.rcNormalPosition.bottom;
675  	}
676  	saveDockingParams();
677  	nppParams.createXmlTreeFromGUIParams();
678  	return true;
679  }
680  bool Notepad_plus::saveColumnEditorParams()
681  {
682  	NppParameters& nppParams = NppParameters::getInstance();
683  	return nppParams.writeColumnEditorSettings();
684  }
685  bool Notepad_plus::saveProjectPanelsParams()
686  {
687  	NppParameters& nppParams = NppParameters::getInstance();
688  	if (_pProjectPanel_1)
689  	{
690  		if (!_pProjectPanel_1->checkIfNeedSave()) return false;
691  		nppParams.setWorkSpaceFilePath(0, _pProjectPanel_1->getWorkSpaceFilePath());
692  	}
693  	if (_pProjectPanel_2)
694  	{
695  		if (!_pProjectPanel_2->checkIfNeedSave()) return false;
696  		nppParams.setWorkSpaceFilePath(1, _pProjectPanel_2->getWorkSpaceFilePath());
697  	}
698  	if (_pProjectPanel_3)
699  	{
700  		if (!_pProjectPanel_3->checkIfNeedSave()) return false;
701  		nppParams.setWorkSpaceFilePath(2, _pProjectPanel_3->getWorkSpaceFilePath());
702  	}
703  	return nppParams.writeProjectPanelsSettings();
704  }
705  bool Notepad_plus::saveFileBrowserParam()
706  {
707  	if (_pFileBrowser)
708  	{
709  		vector<generic_string> rootPaths = _pFileBrowser->getRoots();
710  		generic_string selectedItemPath = _pFileBrowser->getSelectedItemPath();
711  		return (NppParameters::getInstance()).writeFileBrowserSettings(rootPaths, selectedItemPath);
712  	}
713  	return true; 
714  }
715  void Notepad_plus::saveDockingParams()
716  {
717  	NppGUI & nppGUI = (NppParameters::getInstance()).getNppGUI();
718  	nppGUI._dockingData._leftWidth		= _dockingManager.getDockedContSize(CONT_LEFT);
719  	nppGUI._dockingData._rightWidth		= _dockingManager.getDockedContSize(CONT_RIGHT);
720  	nppGUI._dockingData._topHeight		= _dockingManager.getDockedContSize(CONT_TOP);
721  	nppGUI._dockingData._bottomHight	= _dockingManager.getDockedContSize(CONT_BOTTOM);
722  	nppGUI._dockingData._containerTabInfo.clear();
723  	vector<PluginDlgDockingInfo>	vPluginDockInfo;
724  	vector<FloatingWindowInfo>		vFloatingWindowInfo;
725  	vector<DockingCont*> vCont = _dockingManager.getContainerInfo();
726  	for (size_t i = 0, len = vCont.size(); i < len ; ++i)
727  	{
728  		vector<tTbData *>	vDataVis	= vCont[i]->getDataOfVisTb();
729  		for (size_t j = 0, len2 = vDataVis.size(); j < len2 ; ++j)
730  		{
731  			if (vDataVis[j]->pszName && vDataVis[j]->pszName[0])
732  			{
733  				PluginDlgDockingInfo pddi(vDataVis[j]->pszModuleName, vDataVis[j]->dlgID, int32_t(i), vDataVis[j]->iPrevCont, true);
734  				vPluginDockInfo.push_back(pddi);
735  			}
736  		}
737  		vector<tTbData *>	vDataAll	= vCont[i]->getDataOfAllTb();
738  		for (size_t j = 0, len3 = vDataAll.size(); j < len3 ; ++j)
739  		{
740  			if ((vDataAll[j]->pszName && vDataAll[j]->pszName[0]) && (!vCont[i]->isTbVis(vDataAll[j])))
741  			{
742  				PluginDlgDockingInfo pddi(vDataAll[j]->pszModuleName, vDataAll[j]->dlgID, int32_t(i), vDataAll[j]->iPrevCont, false);
743  				vPluginDockInfo.push_back(pddi);
744  			}
745  		}
746  		if (i >= DOCKCONT_MAX)
747  		{
748  			RECT	rc;
749  			vCont[i]->getWindowRect(rc);
750  			FloatingWindowInfo fwi(int32_t(i), rc.left, rc.top, rc.right, rc.bottom);
751  			vFloatingWindowInfo.push_back(fwi);
752  		}
753  		ContainerTabInfo act(int32_t(i), vCont[i]->getActiveTb());
754  		nppGUI._dockingData._containerTabInfo.push_back(act);
755  	}
756  	UCHAR floatContArray[50];
757  	memset(floatContArray, 0, 50);
758  	for (size_t i = 0, len4 = nppGUI._dockingData._pluginDockInfo.size(); i < len4 ; ++i)
759  	{
760  		BOOL	isStored = FALSE;
761  		for (size_t j = 0, len5 = vPluginDockInfo.size(); j < len5; ++j)
762  		{
763  			if (nppGUI._dockingData._pluginDockInfo[i] == vPluginDockInfo[j])
764  			{
765  				isStored = TRUE;
766  				break;
767  			}
768  		}
769  		if (isStored == FALSE)
770  		{
771  			int floatCont	= 0;
772  			if (nppGUI._dockingData._pluginDockInfo[i]._currContainer >= DOCKCONT_MAX)
773  				floatCont = nppGUI._dockingData._pluginDockInfo[i]._currContainer;
774  			else
775  				floatCont = nppGUI._dockingData._pluginDockInfo[i]._prevContainer;
776  			if (floatCont >= 0)
777  			{
778  				if (floatContArray[floatCont] == 0)
779  				{
780  					RECT rc;
781  					if (nppGUI._dockingData.getFloatingRCFrom(floatCont, rc))
782  					{
783  						vFloatingWindowInfo.push_back(FloatingWindowInfo(floatCont, rc.left, rc.top, rc.right, rc.bottom));
784  					}
785  					floatContArray[floatCont] = 1;
786  				}
787  			}
788  			if (i < nppGUI._dockingData._pluginDockInfo.size()) 
789  				vPluginDockInfo.push_back(nppGUI._dockingData._pluginDockInfo[i]);
790  		}
791  	}
792  	nppGUI._dockingData._pluginDockInfo = vPluginDockInfo;
793  	nppGUI._dockingData._flaotingWindowInfo = vFloatingWindowInfo;
794  }
795  void Notepad_plus::saveUserDefineLangs()
796  {
797  	(NppParameters::getInstance()).writeNeed2SaveUDL();
798  }
799  void Notepad_plus::saveShortcuts()
800  {
801  	NppParameters::getInstance().writeShortcuts();
802  }
803  void Notepad_plus::saveFindHistory()
804  {
805  	_findReplaceDlg.saveFindHistory();
806  	(NppParameters::getInstance()).writeFindHistory();
807  }
808  int Notepad_plus::getHtmlXmlEncoding(const TCHAR *fileName) const
809  {
810  	TCHAR *ext = PathFindExtension(fileName);
811  	if (*ext == '.') 
812  	{
813  		ext += 1;
814  	}
815  	else
816  	{
817  		return -1;
818  	}
819  	NppParameters& nppParamInst = NppParameters::getInstance();
820  	LangType langT = nppParamInst.getLangFromExt(ext);
821  	if ((langT != L_XML) && (langT != L_HTML))
822  		return -1;
823  	FILE *f = _wfopen(fileName, TEXT("rb"));
824  	if (!f)
825  		return -1;
826  	const int blockSize = 1024; 
827  	char data[blockSize];
828  	size_t lenFile = fread(data, 1, blockSize, f);
829  	fclose(f);
830  	_invisibleEditView.execute(SCI_CLEARALL);
831  	_invisibleEditView.execute(SCI_APPENDTEXT, lenFile, reinterpret_cast<LPARAM>(data));
832  	const char *encodingAliasRegExpr = "[a-zA-Z0-9_-]+";
833  	const size_t encodingStrLen = 128;
834  	if (langT == L_XML)
835  	{
836  		const char *xmlHeaderRegExpr = "<?xml[ \\t]+version[ \\t]*=[ \\t]*\"[^\"]+\"[ \\t]+encoding[ \\t]*=[ \\t]*\"[^\"]+\"[ \\t]*.*?>";
837          size_t startPos = 0;
838  		size_t endPos = lenFile-1;
839  		_invisibleEditView.execute(SCI_SETSEARCHFLAGS, SCFIND_REGEXP|SCFIND_POSIX);
840  		_invisibleEditView.execute(SCI_SETTARGETRANGE, startPos, endPos);
841  		auto posFound = _invisibleEditView.execute(SCI_SEARCHINTARGET, strlen(xmlHeaderRegExpr), reinterpret_cast<LPARAM>(xmlHeaderRegExpr));
842  		if (posFound >= 0)
843  		{
844              const char *encodingBlockRegExpr = "encoding[ \\t]*=[ \\t]*\"[^\".]+\"";
845  			_invisibleEditView.execute(SCI_SEARCHINTARGET, strlen(encodingBlockRegExpr), reinterpret_cast<LPARAM>(encodingBlockRegExpr));
846              const char *encodingRegExpr = "\".+\"";
847  			_invisibleEditView.execute(SCI_SEARCHINTARGET, strlen(encodingRegExpr), reinterpret_cast<LPARAM>(encodingRegExpr));
848  			_invisibleEditView.execute(SCI_SEARCHINTARGET, strlen(encodingAliasRegExpr), reinterpret_cast<LPARAM>(encodingAliasRegExpr));
849              startPos = _invisibleEditView.execute(SCI_GETTARGETSTART);
850  			endPos = _invisibleEditView.execute(SCI_GETTARGETEND);
851  			size_t len = endPos - startPos;
852  			if (len >= encodingStrLen)
853  			{
854  				return -1;
855  			}
856              char encodingStr[encodingStrLen];
857              _invisibleEditView.getText(encodingStr, startPos, endPos);
858  			EncodingMapper& em = EncodingMapper::getInstance();
859              int enc = em.getEncodingFromString(encodingStr);
860              return (enc == CP_ACP ? -1 : enc);
861  		}
862          return -1;
863  	}
864  	else 
865  	{
866  		const char *htmlHeaderRegExpr  = "<meta[ \\t]+http-equiv[ \\t]*=[ \\t\"']*Content-Type[ \\t\"']*content[ \\t]*= *[\"']text/html;[ \\t]+charset[ \\t]*=[ \\t]*.+[\"'] *&bsol;*>";
867  		const char *htmlHeaderRegExpr2 = "<meta[ \\t]+content[ \\t]*= *[\"']text/html;[ \\t]+charset[ \\t]*=[ \\t]*.+[ \\t\"']http-equiv[ \\t]*=[ \\t\"']*Content-Type[ \\t\"']*&bsol;*>";
868  		const char *charsetBlock = "charset[ \\t]*=[ \\t]*[^\"']+";
869  		const char *intermediaire = "=[ \\t]*.+";
870  		const char *encodingStrRE = "[^ \\t=]+";
871  		intptr_t startPos = 0;
872  		auto endPos = lenFile - 1;
873  		_invisibleEditView.execute(SCI_SETSEARCHFLAGS, SCFIND_REGEXP|SCFIND_POSIX);
874  		_invisibleEditView.execute(SCI_SETTARGETRANGE, startPos, endPos);
875  		auto posFound = _invisibleEditView.execute(SCI_SEARCHINTARGET, strlen(htmlHeaderRegExpr), reinterpret_cast<LPARAM>(htmlHeaderRegExpr));
876  		if (posFound < 0)
877  		{
878  			posFound = _invisibleEditView.execute(SCI_SEARCHINTARGET, strlen(htmlHeaderRegExpr2), reinterpret_cast<LPARAM>(htmlHeaderRegExpr2));
879  			if (posFound < 0)
880  				return -1;
881  		}
882  		_invisibleEditView.execute(SCI_SEARCHINTARGET, strlen(charsetBlock), reinterpret_cast<LPARAM>(charsetBlock));
883  		_invisibleEditView.execute(SCI_SEARCHINTARGET, strlen(intermediaire), reinterpret_cast<LPARAM>(intermediaire));
884  		_invisibleEditView.execute(SCI_SEARCHINTARGET, strlen(encodingStrRE), reinterpret_cast<LPARAM>(encodingStrRE));
885          startPos = _invisibleEditView.execute(SCI_GETTARGETSTART);
886  		endPos = _invisibleEditView.execute(SCI_GETTARGETEND);
887  		size_t len = endPos - startPos;
888  		if (len >= encodingStrLen)
889  		{
890  			return -1;
891  		}
892          char encodingStr[encodingStrLen];
893          _invisibleEditView.getText(encodingStr, startPos, endPos);
894  		EncodingMapper& em = EncodingMapper::getInstance();
895  		int enc = em.getEncodingFromString(encodingStr);
896          return (enc == CP_ACP ? -1 : enc);
897  	}
898  }
899  void Notepad_plus::setCodePageForInvisibleView(Buffer const *pBuffer)
900  {
901  	intptr_t detectedCp = _invisibleEditView.execute(SCI_GETCODEPAGE);
902  	intptr_t cp2set = SC_CP_UTF8;
903  	if (pBuffer->getUnicodeMode() == uni8Bit)
904  	{
905  		cp2set = (detectedCp == SC_CP_UTF8 ? CP_ACP : detectedCp);
906  	}
907  	_invisibleEditView.execute(SCI_SETCODEPAGE, cp2set);
908  }
909  bool Notepad_plus::replaceInOpenedFiles()
910  {
911  	ScintillaEditView *pOldView = _pEditView;
912  	_pEditView = &_invisibleEditView;
913  	Document oldDoc = _invisibleEditView.execute(SCI_GETDOCPOINTER);
914  	Buffer * oldBuf = _invisibleEditView.getCurrentBuffer();	
915  	Buffer * pBuf = NULL;
916  	int nbTotal = 0;
917  	const bool isEntireDoc = true;
918      if (_mainWindowStatus & WindowMainActive)
919      {
920  		for (size_t i = 0, len = _mainDocTab.nbItem(); i < len ; ++i)
921  	    {
922  			pBuf = MainFileManager.getBufferByID(_mainDocTab.getBufferByIndex(i));
923  			if (pBuf->isReadOnly())
924  				continue;
925  			_invisibleEditView.execute(SCI_SETDOCPOINTER, 0, pBuf->getDocument());
926  			setCodePageForInvisibleView(pBuf);
927  			_invisibleEditView.setCurrentBuffer(pBuf);
928  			_invisibleEditView.execute(SCI_BEGINUNDOACTION);
929  			nbTotal += _findReplaceDlg.processAll(ProcessReplaceAll, FindReplaceDlg::_env, isEntireDoc);
930  			_invisibleEditView.execute(SCI_ENDUNDOACTION);
931  		}
932  	}
933  	if (_mainWindowStatus & WindowSubActive)
934  	{
935  		for (size_t i = 0, len = _subDocTab.nbItem(); i < len; ++i)
936  		{
937  			pBuf = MainFileManager.getBufferByID(_subDocTab.getBufferByIndex(i));
938  			if (pBuf->isReadOnly())
939  				continue;
940  			_invisibleEditView.execute(SCI_SETDOCPOINTER, 0, pBuf->getDocument());
941  			setCodePageForInvisibleView(pBuf);
942  			_invisibleEditView.setCurrentBuffer(pBuf);
943  			_invisibleEditView.execute(SCI_BEGINUNDOACTION);
944  			nbTotal += _findReplaceDlg.processAll(ProcessReplaceAll, FindReplaceDlg::_env, isEntireDoc);
945  			_invisibleEditView.execute(SCI_ENDUNDOACTION);
946  		}
947  	}
948  	_invisibleEditView.execute(SCI_SETDOCPOINTER, 0, oldDoc);
949  	_invisibleEditView.setCurrentBuffer(oldBuf);
950  	_pEditView = pOldView;
951  	if (nbTotal < 0)
952  	{
953  		generic_string msg = _nativeLangSpeaker.getLocalizedStrFromID("find-status-replaceinfiles-re-malformed", TEXT("Replace in Opened Files: The regular expression is malformed."));
954  		_findReplaceDlg.setStatusbarMessage(msg, FSNotFound);
955  	}
956  	else
957  	{
958  		if (nbTotal)
959  			enableCommand(IDM_FILE_SAVEALL, true, MENU | TOOLBAR);
960  		generic_string result;
961  		if (nbTotal == 1)
962  		{
963  			result = _nativeLangSpeaker.getLocalizedStrFromID("find-status-replaceinopenedfiles-1-replaced", TEXT("Replace in Opened Files: 1 occurrence was replaced."));
964  		}
965  		else
966  		{
967  			result = _nativeLangSpeaker.getLocalizedStrFromID("find-status-replaceinopenedfiles-nb-replaced", TEXT("Replace in Opened Files: $INT_REPLACE$ occurrences were replaced."));
968  			result = stringReplace(result, TEXT("$INT_REPLACE$"), std::to_wstring(nbTotal));
969  		}
970  		_findReplaceDlg.setStatusbarMessage(result, FSMessage);
971  	}
972  	return true;
973  }
974  void Notepad_plus::wsTabConvert(spaceTab whichWay)
975  {
976  	if ((_pEditView->execute(SCI_GETSELECTIONMODE) == SC_SEL_RECTANGLE) || (_pEditView->execute(SCI_GETSELECTIONMODE) == SC_SEL_THIN))
977  		return;
978  	intptr_t tabWidth = _pEditView->execute(SCI_GETTABWIDTH);
979  	intptr_t currentPos = _pEditView->execute(SCI_GETCURRENTPOS);
980  	intptr_t currentLine = _pEditView->execute(SCI_LINEFROMPOSITION, currentPos);
981  	intptr_t currentPosInLine = currentPos - _pEditView->execute(SCI_POSITIONFROMLINE, currentLine);
982  	intptr_t startLine = 0;
983  	intptr_t endLine = _pEditView->lastZeroBasedLineNumber();
984  	intptr_t endLineCorrect = endLine;
985  	intptr_t dataLength = _pEditView->execute(SCI_GETLENGTH) + 1;
986  	intptr_t mainSelAnchor = _pEditView->execute(SCI_GETANCHOR);
987  	bool isEntireDoc = (mainSelAnchor == currentPos);
988  	auto restoreSelection = [this, mainSelAnchor, currentPos, isEntireDoc]()
989  	{
990  		if (!isEntireDoc)
991  		{
992  			_pEditView->execute(SCI_SETANCHOR, mainSelAnchor);
993  			_pEditView->execute(SCI_SETCURRENTPOS, currentPos);
994  		}
995  	};
996  	if (!isEntireDoc)
997  	{
998  		intptr_t startPos = _pEditView->execute(SCI_GETSELECTIONSTART);
999  		startLine = _pEditView->execute(SCI_LINEFROMPOSITION, startPos);
1000  		intptr_t endPos = _pEditView->execute(SCI_GETSELECTIONEND);
1001  		endLine = endLineCorrect = _pEditView->execute(SCI_LINEFROMPOSITION, endPos);
1002  		if (startPos != _pEditView->execute(SCI_POSITIONFROMLINE, startLine))
1003  			startPos = _pEditView->execute(SCI_POSITIONFROMLINE, startLine);
1004  		if (endPos == _pEditView->execute(SCI_POSITIONFROMLINE, endLine))
1005  			endLineCorrect = endLine - 1;
1006  		else if (endPos < _pEditView->execute(SCI_GETLINEENDPOSITION, endLine))
1007  			endPos = _pEditView->execute(SCI_GETLINEENDPOSITION, endLine);
1008  		dataLength = endPos - startPos + 1;
1009  		_pEditView->execute(SCI_SETSEL, startPos, endPos);
1010  	}
1011  	if (dataLength < 2)
1012  	{
1013  		restoreSelection();
1014  		return;
1015  	}
1016  	intptr_t changeDataCount = 0;
1017  	intptr_t newCurrentPos = 0;
1018  	vector<intptr_t> folding;
1019  	_pEditView->execute(SCI_BEGINUNDOACTION);
1020  	for (intptr_t idx = startLine; idx < endLineCorrect + 1; ++idx)
1021  	{
1022  		intptr_t startPos = _pEditView->execute(SCI_POSITIONFROMLINE, idx);
1023  		intptr_t endPos = _pEditView->execute(SCI_GETLINEENDPOSITION, idx);
1024  		dataLength = endPos - startPos + 1;
1025  		char * source = new char[dataLength];
1026  		if (source == NULL)
1027  			continue;
1028  		source[dataLength - 1] = '\0'; 
1029  		_pEditView->execute(SCI_SETTARGETRANGE, startPos, endPos);
1030  		_pEditView->execute(SCI_GETTARGETTEXT, 0, reinterpret_cast<LPARAM>(source));
1031  		intptr_t count = 0;
1032  		intptr_t column = 0;
1033  		intptr_t tabStop = tabWidth - 1;   
1034  		bool onlyLeading = false;
1035  		if (whichWay == tab2Space)
1036  		{
1037  			for (const char * ch = source; *ch; ++ch)
1038  			{
1039  				if (*ch == '\t')
1040  					++count;
1041  			}
1042  			if (count == 0)
1043  			{
1044  				delete [] source;
1045  				continue;
1046  			}
1047  		}
1048  		size_t newLen = dataLength + count * (tabWidth - 1) + 1;
1049  		char * destination = new char[newLen];
1050  		if (destination == NULL)
1051  		{
1052  			delete [] source;
1053  			continue;
1054  		}
1055  		char * dest = destination;
1056  		intptr_t changeDataLineCount = 0;
1057  		switch (whichWay)
1058  		{
1059  			case tab2Space:
1060  			{
1061  				for (int i = 0; source[i] != '\0'; ++i)
1062  				{
1063  					if (source[i] == '\t')
1064  					{
1065  						intptr_t insertTabs = tabWidth - (column % tabWidth);
1066  						for (int j = 0; j < insertTabs; ++j)
1067  						{
1068  							*dest++ = ' ';
1069  							changeDataCount++;
1070  							changeDataLineCount++;
1071  							if (idx == currentLine && i < currentPosInLine)
1072  								++newCurrentPos;
1073  						}
1074  						column += insertTabs;
1075  					}
1076  					else
1077  					{
1078  						*dest++ = source[i];
1079  						if (idx == currentLine && i < currentPosInLine)
1080  							++newCurrentPos;
1081  						if ((source[i] == '\n') || (source[i] == '\r'))
1082  							column = 0;
1083  						else if ((source[i] & 0xC0) != 0x80)  
1084  							++column;
1085  					}
1086  				}
1087  				*dest = '\0';
1088  				break;
1089  			}
1090  			case space2TabLeading:
1091  			{
1092  				onlyLeading = true;
1093  			}
1094  			[[fallthrough]];
1095  			case space2TabAll:
1096  			{
1097  				bool nextChar = false;
1098  				int counter = 0;
1099  				bool nonSpaceFound = false;
1100  				for (int i = 0; source[i] != '\0'; ++i)
1101  				{
1102  					if (nonSpaceFound == false)
1103  					{
1104  						while (source[i + counter] == ' ')
1105  						{
1106  							if ((column + counter) == tabStop)
1107  							{
1108  								tabStop += tabWidth;
1109  								if (counter >= 1)        
1110  								{
1111  									*dest++ = '\t';
1112  									changeDataCount++;
1113  									changeDataLineCount++;
1114  									i += counter;
1115  									column += counter + 1;
1116  									counter = 0;
1117  									nextChar = true;
1118  									if (idx == currentLine && i <= currentPosInLine)
1119  										++newCurrentPos;
1120  									break;
1121  								}
1122  								else if (source[i + 1] == ' ' || source[i + 1] == '\t')  
1123  								{
1124  									*dest++ = '\t';
1125  									changeDataCount++;
1126  									changeDataLineCount++;
1127  									i++;
1128  									column += 1;
1129  									counter = 0;
1130  									if (idx == currentLine && i <= currentPosInLine)
1131  										++newCurrentPos;
1132  								}
1133  								else       
1134  								{
1135  									*dest++ = source[i];
1136  									column += 1;
1137  									counter = 0;
1138  									nextChar = true;
1139  									if (idx == currentLine && i <= currentPosInLine)
1140  										++newCurrentPos;
1141  									break;
1142  								}
1143  							}
1144  							else
1145  								++counter;
1146  						}
1147  						if (nextChar == true)
1148  						{
1149  							nextChar = false;
1150  							continue;
1151  						}
1152  						if (source[i] == ' ' && source[i + counter] == '\t') 
1153  						{
1154  							*dest++ = '\t';
1155  							changeDataCount++;
1156  							changeDataLineCount++;
1157  							i += counter;
1158  							column = tabStop + 1;
1159  							tabStop += tabWidth;
1160  							counter = 0;
1161  							if (idx == currentLine && i <= currentPosInLine)
1162  								++newCurrentPos;
1163  							continue;
1164  						}
1165  					}
1166  					if (onlyLeading == true && nonSpaceFound == false)
1167  						nonSpaceFound = true;
1168  					if (source[i] == '\n' || source[i] == '\r')
1169  					{
1170  						*dest++ = source[i];
1171  						column = 0;
1172  						tabStop = tabWidth - 1;
1173  						nonSpaceFound = false;
1174  					}
1175  					else if (source[i] == '\t')
1176  					{
1177  						*dest++ = source[i];
1178  						column = tabStop + 1;
1179  						tabStop += tabWidth;
1180  						counter = 0;
1181  					}
1182  					else
1183  					{
1184  						*dest++ = source[i];
1185  						counter = 0;
1186  						if ((source[i] & 0xC0) != 0x80)   
1187  						{
1188  							++column;
1189  							if (column > 0 && column % tabWidth == 0)
1190  								tabStop += tabWidth;
1191  						}
1192  					}
1193  					if (idx == currentLine && i < currentPosInLine)
1194  						++newCurrentPos;
1195  				}
1196  				*dest = '\0';
1197  				break;
1198  			}
1199  		}
1200  		if ((_pEditView->execute(SCI_GETFOLDLEVEL, idx) & SC_FOLDLEVELHEADERFLAG))
1201  			if (_pEditView->execute(SCI_GETFOLDEXPANDED, idx) == 0)
1202  				folding.push_back(idx);
1203  		if (changeDataLineCount)
1204  			_pEditView->execute(SCI_REPLACETARGET, static_cast<WPARAM>(-1), reinterpret_cast<LPARAM>(destination));
1205  		delete [] source;
1206  		delete [] destination;
1207  	}
1208  	_pEditView->execute(SCI_ENDUNDOACTION);
1209  	if (changeDataCount)
1210  	{
1211  		if (!isEntireDoc)
1212  			_pEditView->execute(SCI_SETSEL, _pEditView->execute(SCI_POSITIONFROMLINE, startLine), endLineCorrect != endLine ? _pEditView->execute(SCI_POSITIONFROMLINE, endLine) : _pEditView->execute(SCI_GETLINEENDPOSITION, endLine));
1213  		else
1214  			_pEditView->execute(SCI_GOTOPOS, _pEditView->execute(SCI_POSITIONFROMLINE, currentLine) + newCurrentPos);
1215  		for (size_t i = 0; i < folding.size(); ++i)
1216  			_pEditView->fold(folding[i], false);
1217  	}
1218  	else
1219  		restoreSelection();
1220  }
1221  void Notepad_plus::doTrim(trimOp whichPart)
1222  {
1223  	FindOption env;
1224  	if (whichPart == lineHeader)
1225  	{
1226  		env._str2Search = TEXT("^[\\t ]+");
1227  	}
1228  	else if (whichPart == lineTail)
1229  	{
1230  		env._str2Search = TEXT("[\\t ]+$");
1231  	}
1232  	else if (whichPart == lineBoth)
1233  	{
1234  		env._str2Search = TEXT("^[\\t ]+|[\\t ]+$");
1235  	}
1236  	else
1237  		return;
1238  	env._str4Replace = TEXT("");
1239  	env._searchType = FindRegex;
1240  	auto mainSelAnchor = _pEditView->execute(SCI_GETANCHOR);
1241  	auto mainSelCaretPos = _pEditView->execute(SCI_GETCURRENTPOS);
1242  	bool isEntireDoc = (mainSelAnchor == mainSelCaretPos);
1243  	auto docLength = _pEditView->execute(SCI_GETLENGTH);
1244  	if ((_pEditView->execute(SCI_GETSELECTIONMODE) == SC_SEL_RECTANGLE) || (_pEditView->execute(SCI_GETSELECTIONMODE) == SC_SEL_THIN))
1245  		return;
1246  	if (!isEntireDoc)
1247  	{
1248  		env._isInSelection = !isEntireDoc;
1249  		auto startPos = _pEditView->execute(SCI_GETSELECTIONSTART);
1250  		auto startLine = _pEditView->execute(SCI_LINEFROMPOSITION, startPos);
1251  		auto endPos = _pEditView->execute(SCI_GETSELECTIONEND);
1252  		auto endLine = _pEditView->execute(SCI_LINEFROMPOSITION, endPos);
1253  		if (startPos != _pEditView->execute(SCI_POSITIONFROMLINE, startLine))
1254  			startPos = _pEditView->execute(SCI_POSITIONFROMLINE, startLine);
1255  		if (endPos != _pEditView->execute(SCI_POSITIONFROMLINE, endLine) && endPos < _pEditView->execute(SCI_GETLINEENDPOSITION, endLine))
1256  			endPos = _pEditView->execute(SCI_GETLINEENDPOSITION, endLine);
1257  		_pEditView->execute(SCI_SETSEL, startPos, endPos);
1258  	}
1259  	_findReplaceDlg.processAll(ProcessReplaceAll, &env, isEntireDoc);
1260  	if (!isEntireDoc && (docLength == _pEditView->execute(SCI_GETLENGTH)))
1261  	{
1262  		_pEditView->execute(SCI_SETANCHOR, mainSelAnchor);
1263  		_pEditView->execute(SCI_SETCURRENTPOS, mainSelCaretPos);
1264  	}
1265  }
1266  void Notepad_plus::eol2ws()
1267  {
1268  	bool isEntireDoc = (_pEditView->execute(SCI_GETANCHOR) == _pEditView->execute(SCI_GETCURRENTPOS));
1269  	if ((_pEditView->execute(SCI_GETSELECTIONMODE) == SC_SEL_RECTANGLE) || (_pEditView->execute(SCI_GETSELECTIONMODE) == SC_SEL_THIN))
1270  		return;
1271  	_pEditView->execute(isEntireDoc ? SCI_TARGETWHOLEDOCUMENT: SCI_TARGETFROMSELECTION);
1272  	_pEditView->execute(SCI_LINESJOIN);
1273  }
1274  void Notepad_plus::removeEmptyLine(bool isBlankContained)
1275  {
1276  	FindOption env;
1277  	if (isBlankContained)
1278  	{
1279  		env._str2Search = TEXT("^(?>[\\t ]*[\\r\\n]+)+");
1280  	}
1281  	else
1282  	{
1283  		env._str2Search = TEXT("^[\\r\\n]+");
1284  	}
1285  	env._str4Replace = TEXT("");
1286  	env._searchType = FindRegex;
1287  	auto mainSelStart = _pEditView->execute(SCI_GETSELECTIONSTART);
1288  	auto mainSelEnd = _pEditView->execute(SCI_GETSELECTIONEND);
1289  	auto mainSelLength = mainSelEnd - mainSelStart;
1290  	bool isEntireDoc = mainSelLength == 0;
1291  	env._isInSelection = !isEntireDoc;
1292  	_findReplaceDlg.processAll(ProcessReplaceAll, &env, isEntireDoc);
1293  	auto lastLineDoc = _pEditView->execute(SCI_GETLINECOUNT) - 1;
1294  	auto str2Search = isBlankContained ? TEXT("[\\r\\n]+^[\\t ]*$|^[\\t ]+$") : TEXT("[\\r\\n]+^$");
1295  	auto startPos = _pEditView->execute(SCI_POSITIONFROMLINE, lastLineDoc - 1);
1296  	auto endPos = _pEditView->execute(SCI_GETLENGTH);
1297  	if (!isEntireDoc)
1298  	{
1299  		startPos = _pEditView->execute(SCI_GETSELECTIONSTART);
1300  		endPos = _pEditView->execute(SCI_GETSELECTIONEND);
1301  		auto endLine = _pEditView->execute(SCI_LINEFROMPOSITION, endPos);
1302  		if (endPos != (_pEditView->execute(SCI_POSITIONFROMLINE, endLine) + _pEditView->execute(SCI_LINELENGTH, endLine)))
1303  			return;
1304  	}
1305  	_pEditView->execute(SCI_SETSEARCHFLAGS, SCFIND_REGEXP|SCFIND_POSIX);
1306  	auto posFound = _pEditView->searchInTarget(str2Search, lstrlen(str2Search), startPos, endPos);
1307  	if (posFound >= 0)
1308  		_pEditView->replaceTarget(TEXT(""), posFound, endPos);
1309  }
1310  void Notepad_plus::removeDuplicateLines()
1311  {
1312  	intptr_t mainSelAnchor = _pEditView->execute(SCI_GETANCHOR);
1313  	intptr_t mainSelCaretPos = _pEditView->execute(SCI_GETCURRENTPOS);
1314  	bool isEntireDoc = (mainSelAnchor == mainSelCaretPos);
1315  	intptr_t startLine = 0;
1316  	intptr_t endLine = _pEditView->lastZeroBasedLineNumber();
1317  	if (!isEntireDoc)
1318  	{
1319  		intptr_t startPos = _pEditView->execute(SCI_GETSELECTIONSTART);
1320  		startLine = _pEditView->execute(SCI_LINEFROMPOSITION, startPos);
1321  		intptr_t endPos = _pEditView->execute(SCI_GETSELECTIONEND);
1322  		endLine = _pEditView->execute(SCI_LINEFROMPOSITION, endPos);
1323  		if (endPos == _pEditView->execute(SCI_POSITIONFROMLINE, endLine))
1324  			endLine -= 1;
1325  	}
1326  	if (startLine == endLine)
1327  		return;
1328  	intptr_t firstMatchLineNr = 0;
1329  	intptr_t lastMatchLineNr = 0;
1330  	generic_string firstMatchLineStr;
1331  	generic_string lastMatchLineStr;
1332  	for (intptr_t i = startLine; i <= endLine; i++)
1333  	{
1334  		if (firstMatchLineStr.empty())
1335  		{
1336  			firstMatchLineNr = lastMatchLineNr = i;
1337  			firstMatchLineStr = _pEditView->getLine(i);
1338  			continue;
1339  		}
1340  		else
1341  			lastMatchLineStr = _pEditView->getLine(i);
1342  		if (firstMatchLineStr == lastMatchLineStr)
1343  		{
1344  			lastMatchLineNr = i;
1345  			if (i != endLine)
1346  				continue;
1347  		}
1348  		if (firstMatchLineNr != lastMatchLineNr)
1349  		{
1350  			intptr_t startPos = _pEditView->execute(SCI_POSITIONFROMLINE, firstMatchLineNr + 1);
1351  			intptr_t endPos = _pEditView->execute(SCI_POSITIONFROMLINE, lastMatchLineNr) + _pEditView->execute(SCI_LINELENGTH, lastMatchLineNr);
1352  			_pEditView->execute(SCI_DELETERANGE, startPos, endPos - startPos);
1353  			intptr_t removedLines = lastMatchLineNr - firstMatchLineNr;
1354  			i -= removedLines;
1355  			endLine -= removedLines;
1356  		}
1357  		firstMatchLineStr = lastMatchLineStr;
1358  		firstMatchLineNr = lastMatchLineNr = i;
1359  	}
1360  	intptr_t endLineStartPos = _pEditView->execute(SCI_POSITIONFROMLINE, endLine);
1361  	intptr_t endLineEndPos = _pEditView->execute(SCI_GETLINEENDPOSITION, endLine);
1362  	intptr_t endLineLength = _pEditView->execute(SCI_LINELENGTH, endLine);
1363  	if (endLine == _pEditView->lastZeroBasedLineNumber() && endLineLength && ((endLineEndPos - endLineStartPos) == endLineLength))
1364  	{
1365  		intptr_t prevLine = endLine - 1;
1366  		intptr_t prevLineStartPos = _pEditView->execute(SCI_POSITIONFROMLINE, prevLine);
1367  		intptr_t prevLineEndPos = _pEditView->execute(SCI_GETLINEENDPOSITION, prevLine);
1368  		intptr_t prevLineLength = _pEditView->execute(SCI_LINELENGTH, prevLine);
1369  		const generic_string endLineStr = _pEditView->getLine(endLine);
1370  		const generic_string prevLineStr = _pEditView->getGenericTextAsString(prevLineStartPos, prevLineEndPos);
1371  		if (endLineStr == prevLineStr)
1372  			_pEditView->execute(SCI_DELETERANGE, prevLineStartPos, prevLineLength);
1373  	}
1374  }
1375  void Notepad_plus::getMatchedFileNames(const TCHAR *dir, size_t level, const vector<generic_string> & patterns, vector<generic_string> & fileNames, bool isRecursive, bool isInHiddenDir)
1376  {
1377  	level++;
1378  	generic_string dirFilter(dir);
1379  	dirFilter += TEXT("*.*");
1380  	WIN32_FIND_DATA foundData;
1381  	HANDLE hFile = ::FindFirstFile(dirFilter.c_str(), &foundData);
1382  	if (hFile != INVALID_HANDLE_VALUE)
1383  	{
1384  		if (foundData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
1385  		{
1386  			if (!isInHiddenDir && (foundData.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN))
1387  			{
1388  			}
1389  			else if (isRecursive)
1390  			{
1391  				if ((OrdinalIgnoreCaseCompareStrings(foundData.cFileName, TEXT(".")) != 0) && (OrdinalIgnoreCaseCompareStrings(foundData.cFileName, TEXT("..")) != 0) &&
1392  					!matchInExcludeDirList(foundData.cFileName, patterns, level))
1393  				{
1394  					generic_string pathDir(dir);
1395  					pathDir += foundData.cFileName;
1396  					pathDir += TEXT("\\");
1397  					getMatchedFileNames(pathDir.c_str(), level, patterns, fileNames, isRecursive, isInHiddenDir);
1398  				}
1399  			}
1400  		}
1401  		else
1402  		{
1403  			if (matchInList(foundData.cFileName, patterns))
1404  			{
1405  				generic_string pathFile(dir);
1406  				pathFile += foundData.cFileName;
1407  				fileNames.push_back(pathFile.c_str());
1408  			}
1409  		}
1410  	}
1411  	while (::FindNextFile(hFile, &foundData))
1412  	{
1413  		if (foundData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
1414  		{
1415  			if (!isInHiddenDir && (foundData.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN))
1416  			{
1417  			}
1418  			else if (isRecursive)
1419  			{
1420  				if ((OrdinalIgnoreCaseCompareStrings(foundData.cFileName, TEXT(".")) != 0) && (OrdinalIgnoreCaseCompareStrings(foundData.cFileName, TEXT("..")) != 0) &&
1421  					!matchInExcludeDirList(foundData.cFileName, patterns, level))
1422  				{
1423  					generic_string pathDir(dir);
1424  					pathDir += foundData.cFileName;
1425  					pathDir += TEXT("\\");
1426  					getMatchedFileNames(pathDir.c_str(), level, patterns, fileNames, isRecursive, isInHiddenDir);
1427  				}
1428  			}
1429  		}
1430  		else
1431  		{
1432  			if (matchInList(foundData.cFileName, patterns))
1433  			{
1434  				generic_string pathFile(dir);
1435  				pathFile += foundData.cFileName;
1436  				fileNames.push_back(pathFile.c_str());
1437  			}
1438  		}
1439  	}
1440  	::FindClose(hFile);
1441  }
1442  bool Notepad_plus::createFilelistForFiles(vector<generic_string> & fileNames)
1443  {
1444  	const TCHAR *dir2Search = _findReplaceDlg.getDir2Search();
1445  	if (!dir2Search[0] || !::PathFileExists(dir2Search))
1446  	{
1447  		return false;
1448  	}
1449  	vector<generic_string> patterns2Match;
1450  	_findReplaceDlg.getAndValidatePatterns(patterns2Match);
1451  	bool isRecursive = _findReplaceDlg.isRecursive();
1452  	bool isInHiddenDir = _findReplaceDlg.isInHiddenDir();
1453  	getMatchedFileNames(dir2Search, 0, patterns2Match, fileNames, isRecursive, isInHiddenDir);
1454  	return true;
1455  }
1456  bool Notepad_plus::createFilelistForProjects(vector<generic_string> & fileNames)
1457  {
1458  	vector<generic_string> patterns2Match;
1459  	_findReplaceDlg.getAndValidatePatterns(patterns2Match);
1460  	bool somethingIsSelected = false; 
1461  	if (_findReplaceDlg.isProjectPanel_1() && _pProjectPanel_1 && !_pProjectPanel_1->isClosed())
1462  	{
1463  		_pProjectPanel_1->enumWorkSpaceFiles (NULL, patterns2Match, fileNames);
1464  		somethingIsSelected = true;
1465  	}
1466  	if (_findReplaceDlg.isProjectPanel_2() && _pProjectPanel_2 && !_pProjectPanel_2->isClosed())
1467  	{
1468  		_pProjectPanel_2->enumWorkSpaceFiles (NULL, patterns2Match, fileNames);
1469  		somethingIsSelected = true;
1470  	}
1471  	if (_findReplaceDlg.isProjectPanel_3() && _pProjectPanel_3 && !_pProjectPanel_3->isClosed())
1472  	{
1473  		_pProjectPanel_3->enumWorkSpaceFiles (NULL, patterns2Match, fileNames);
1474  		somethingIsSelected = true;
1475  	}
1476  	return somethingIsSelected;
1477  }
1478  std::mutex replaceInFiles_mutex;
1479  bool Notepad_plus::replaceInFiles()
1480  {
1481  	std::lock_guard<std::mutex> lock(replaceInFiles_mutex);
1482  	std::vector<generic_string> fileNames;
1483  	if (!createFilelistForFiles(fileNames))
1484  		return false;
1485  	return replaceInFilelist(fileNames);
1486  }
1487  bool Notepad_plus::replaceInProjects()
1488  {
1489  	std::lock_guard<std::mutex> lock(replaceInFiles_mutex);
1490  	std::vector<generic_string> fileNames;
1491  	if (!createFilelistForProjects(fileNames))
1492  		return false;
1493  	return replaceInFilelist(fileNames);
1494  }
1495  bool Notepad_plus::replaceInFilelist(std::vector<generic_string> & fileNames)
1496  {
1497  	int nbTotal = 0;
1498  	ScintillaEditView *pOldView = _pEditView;
1499  	_pEditView = &_invisibleEditView;
1500  	Document oldDoc = _invisibleEditView.execute(SCI_GETDOCPOINTER);
1501  	Buffer * oldBuf = _invisibleEditView.getCurrentBuffer();	
1502  	Progress progress(_pPublicInterface->getHinst());
1503  	size_t filesCount = fileNames.size();
1504  	size_t filesPerPercent = 1;
1505  	if (filesCount > 1)
1506  	{
1507  		if (filesCount >= 200)
1508  			filesPerPercent = filesCount / 100;
1509  		generic_string msg = _nativeLangSpeaker.getLocalizedStrFromID(
1510  			"replace-in-files-progress-title", TEXT("Replace In Files progress..."));
1511  		progress.open(_findReplaceDlg.getHSelf(), msg.c_str());
1512  	}
1513  	for (size_t i = 0, updateOnCount = filesPerPercent; i < filesCount; ++i)
1514  	{
1515  		if (progress.isCancelled()) break;
1516  		bool closeBuf = false;
1517  		BufferID id = MainFileManager.getBufferFromName(fileNames.at(i).c_str());
1518  		if (id == BUFFER_INVALID)
1519  		{
1520  			id = MainFileManager.loadFile(fileNames.at(i).c_str());
1521  			closeBuf = true;
1522  		}
1523  		if (id != BUFFER_INVALID)
1524  		{
1525  			Buffer * pBuf = MainFileManager.getBufferByID(id);
1526  			_invisibleEditView.execute(SCI_SETDOCPOINTER, 0, pBuf->getDocument());
1527  			setCodePageForInvisibleView(pBuf);
1528  			_invisibleEditView.setCurrentBuffer(pBuf);
1529  			FindersInfo findersInfo;
1530  			findersInfo._pFileName = fileNames.at(i).c_str();
1531  			int nbReplaced = _findReplaceDlg.processAll(ProcessReplaceAll, FindReplaceDlg::_env, true, &findersInfo);
1532  			nbTotal += nbReplaced;
1533  			if (nbReplaced)
1534  			{
1535  				MainFileManager.saveBuffer(id, pBuf->getFullPathName());
1536  			}
1537  			if (closeBuf)
1538  				MainFileManager.closeBuffer(id, _pEditView);
1539  		}
1540  		if (i == updateOnCount)
1541  		{
1542  			updateOnCount += filesPerPercent;
1543  			progress.setPercent(int32_t((i * 100) / filesCount), fileNames.at(i).c_str(), nbTotal);
1544  		}
1545  		else
1546  		{
1547  			progress.setInfo(fileNames.at(i).c_str(), nbTotal);
1548  		}
1549  	}
1550  	progress.close();
1551  	_invisibleEditView.execute(SCI_SETDOCPOINTER, 0, oldDoc);
1552  	_invisibleEditView.setCurrentBuffer(oldBuf);
1553  	_pEditView = pOldView;
1554  	generic_string result;
1555  	if (nbTotal == 1)
1556  	{
1557  		result = _nativeLangSpeaker.getLocalizedStrFromID("find-status-replaceinfiles-1-replaced", TEXT("Replace in Files: 1 occurrence was replaced."));
1558  	}
1559  	else
1560  	{
1561  		result = _nativeLangSpeaker.getLocalizedStrFromID("find-status-replaceinfiles-nb-replaced", TEXT("Replace in Files: $INT_REPLACE$ occurrences were replaced."));
1562  		result = stringReplace(result, TEXT("$INT_REPLACE$"), std::to_wstring(nbTotal));
1563  	}
1564  	_findReplaceDlg.setStatusbarMessage(result, FSMessage);
1565  	return true;
1566  }
1567  bool Notepad_plus::findInFinderFiles(FindersInfo *findInFolderInfo)
1568  {
1569  	int nbTotal = 0;
1570  	ScintillaEditView *pOldView = _pEditView;
1571  	_pEditView = &_invisibleEditView;
1572  	Document oldDoc = _invisibleEditView.execute(SCI_GETDOCPOINTER);
1573  	vector<generic_string> fileNames = findInFolderInfo->_pSourceFinder->getResultFilePaths();
1574  	findInFolderInfo->_pDestFinder->beginNewFilesSearch();
1575  	findInFolderInfo->_pDestFinder->addSearchLine(findInFolderInfo->_findOption._str2Search.c_str());
1576  	Progress progress(_pPublicInterface->getHinst());
1577  	size_t filesCount = fileNames.size();
1578  	size_t filesPerPercent = 1;
1579  	if (filesCount > 1)
1580  	{
1581  		if (filesCount >= 200)
1582  			filesPerPercent = filesCount / 100;
1583  		generic_string msg = _nativeLangSpeaker.getLocalizedStrFromID(
1584  			"find-in-files-progress-title", TEXT("Find In Files progress..."));
1585  		progress.open(_findReplaceDlg.getHSelf(), msg.c_str());
1586  	}
1587  	for (size_t i = 0, updateOnCount = filesPerPercent; i < filesCount; ++i)
1588  	{
1589  		if (progress.isCancelled()) break;
1590  		bool closeBuf = false;
1591  		BufferID id = MainFileManager.getBufferFromName(fileNames.at(i).c_str());
1592  		if (id == BUFFER_INVALID)
1593  		{
1594  			id = MainFileManager.loadFile(fileNames.at(i).c_str());
1595  			closeBuf = true;
1596  		}
1597  		if (id != BUFFER_INVALID)
1598  		{
1599  			Buffer * pBuf = MainFileManager.getBufferByID(id);
1600  			_invisibleEditView.execute(SCI_SETDOCPOINTER, 0, pBuf->getDocument());
1601  			setCodePageForInvisibleView(pBuf);
1602  			findInFolderInfo->_pFileName = fileNames.at(i).c_str();
1603  			nbTotal += _findReplaceDlg.processAll(ProcessFindInFinder, &(findInFolderInfo->_findOption), true, findInFolderInfo);
1604  			if (closeBuf)
1605  				MainFileManager.closeBuffer(id, _pEditView);
1606  		}
1607  		if (i == updateOnCount)
1608  		{
1609  			updateOnCount += filesPerPercent;
1610  			progress.setPercent(int32_t((i * 100) / filesCount), fileNames.at(i).c_str(), nbTotal);
1611  		}
1612  		else
1613  		{
1614  			progress.setInfo(fileNames.at(i).c_str(), nbTotal);
1615  		}
1616  	}
1617  	progress.close();
1618  	const bool searchedInSelection = false;
1619  	findInFolderInfo->_pDestFinder->finishFilesSearch(nbTotal, int(filesCount), findInFolderInfo->_findOption._isMatchLineNumber, !searchedInSelection);
1620  	_invisibleEditView.execute(SCI_SETDOCPOINTER, 0, oldDoc);
1621  	_pEditView = pOldView;
1622  	return true;
1623  }
1624  bool Notepad_plus::findInFiles()
1625  {
1626  	std::vector<generic_string> fileNames;
1627  	if (! createFilelistForFiles(fileNames))
1628  		return false;
1629  	return findInFilelist(fileNames);
1630  }
1631  bool Notepad_plus::findInProjects()
1632  {
1633  	vector<generic_string> fileNames;
1634  	if (! createFilelistForProjects(fileNames))
1635  		return false;
1636  	return findInFilelist(fileNames);
1637  }
1638  bool Notepad_plus::findInFilelist(std::vector<generic_string> & fileNames)
1639  {
1640  	int nbTotal = 0;
1641  	ScintillaEditView *pOldView = _pEditView;
1642  	_pEditView = &_invisibleEditView;
1643  	Document oldDoc = _invisibleEditView.execute(SCI_GETDOCPOINTER);
1644  	_findReplaceDlg.beginNewFilesSearch();
1645  	Progress progress(_pPublicInterface->getHinst());
1646  	size_t filesCount = fileNames.size();
1647  	size_t filesPerPercent = 1;
1648  	if (filesCount > 1)
1649  	{
1650  		if (filesCount >= 200)
1651  			filesPerPercent = filesCount / 100;
1652  		generic_string msg = _nativeLangSpeaker.getLocalizedStrFromID(
1653  			"find-in-files-progress-title", TEXT("Find In Files progress..."));
1654  		progress.open(_findReplaceDlg.getHSelf(), msg.c_str());
1655  	}
1656  	const bool isEntireDoc = true;
1657  	for (size_t i = 0, updateOnCount = filesPerPercent; i < filesCount; ++i)
1658  	{
1659  		if (progress.isCancelled()) break;
1660  		bool closeBuf = false;
1661  		BufferID id = MainFileManager.getBufferFromName(fileNames.at(i).c_str());
1662  		if (id == BUFFER_INVALID)
1663  		{
1664  			id = MainFileManager.loadFile(fileNames.at(i).c_str());
1665  			closeBuf = true;
1666  		}
1667  		if (id != BUFFER_INVALID)
1668  		{
1669  			Buffer * pBuf = MainFileManager.getBufferByID(id);
1670  			_invisibleEditView.execute(SCI_SETDOCPOINTER, 0, pBuf->getDocument());
1671  			setCodePageForInvisibleView(pBuf);
1672  			FindersInfo findersInfo;
1673  			findersInfo._pFileName = fileNames.at(i).c_str();
1674  			nbTotal += _findReplaceDlg.processAll(ProcessFindAll, FindReplaceDlg::_env, isEntireDoc, &findersInfo);
1675  			if (closeBuf)
1676  				MainFileManager.closeBuffer(id, _pEditView);
1677  		}
1678  		if (i == updateOnCount)
1679  		{
1680  			updateOnCount += filesPerPercent;
1681  			progress.setPercent(int32_t((i * 100) / filesCount), fileNames.at(i).c_str(), nbTotal);
1682  		}
1683  		else
1684  		{
1685  			progress.setInfo(fileNames.at(i).c_str(), nbTotal);
1686  		}
1687  	}
1688  	progress.close();
1689  	_findReplaceDlg.finishFilesSearch(nbTotal, int(filesCount), isEntireDoc);
1690  	_invisibleEditView.execute(SCI_SETDOCPOINTER, 0, oldDoc);
1691  	_pEditView = pOldView;
1692  	_findReplaceDlg.putFindResult(nbTotal);
1693  	if (nbTotal != 0)
1694  	{
1695  		NppParameters& nppParam = NppParameters::getInstance();
1696  		NppGUI& nppGui = nppParam.getNppGUI();
1697  		if (!nppGui._findDlgAlwaysVisible)
1698  		{
1699  			_findReplaceDlg.display(false);
1700  		}
1701  	}
1702  	return true;
1703  }
1704  bool Notepad_plus::findInOpenedFiles()
1705  {
1706  	int nbTotal = 0;
1707  	ScintillaEditView *pOldView = _pEditView;
1708  	_pEditView = &_invisibleEditView;
1709  	Document oldDoc = _invisibleEditView.execute(SCI_GETDOCPOINTER);
1710  	Buffer * pBuf = NULL;
1711  	const bool isEntireDoc = true;
1712  	_findReplaceDlg.beginNewFilesSearch();
1713  	if (_mainWindowStatus & WindowMainActive)
1714  	{
1715  		for (size_t i = 0, len = _mainDocTab.nbItem(); i < len ; ++i)
1716  		{
1717  			pBuf = MainFileManager.getBufferByID(_mainDocTab.getBufferByIndex(i));
1718  			_invisibleEditView.execute(SCI_SETDOCPOINTER, 0, pBuf->getDocument());
1719  			setCodePageForInvisibleView(pBuf);
1720  			FindersInfo findersInfo;
1721  			findersInfo._pFileName = pBuf->getFullPathName();
1722  			nbTotal += _findReplaceDlg.processAll(ProcessFindAll, FindReplaceDlg::_env, isEntireDoc, &findersInfo);
1723  		}
1724  	}
1725  	size_t nbUniqueBuffers = _mainDocTab.nbItem();
1726  	if (_mainWindowStatus & WindowSubActive)
1727  	{
1728  		for (size_t i = 0, len2 = _subDocTab.nbItem(); i < len2 ; ++i)
1729  		{
1730  			pBuf = MainFileManager.getBufferByID(_subDocTab.getBufferByIndex(i));
1731  			if (_mainDocTab.getIndexByBuffer(pBuf) != -1)
1732  			{
1733  				continue;  
1734  			}
1735  			_invisibleEditView.execute(SCI_SETDOCPOINTER, 0, pBuf->getDocument());
1736  			setCodePageForInvisibleView(pBuf);
1737  			FindersInfo findersInfo;
1738  			findersInfo._pFileName = pBuf->getFullPathName();
1739  			nbTotal += _findReplaceDlg.processAll(ProcessFindAll, FindReplaceDlg::_env, isEntireDoc, &findersInfo);
1740  			++nbUniqueBuffers;
1741  		}
1742  	}
1743  	_findReplaceDlg.finishFilesSearch(nbTotal, int(nbUniqueBuffers), isEntireDoc);
1744  	_invisibleEditView.execute(SCI_SETDOCPOINTER, 0, oldDoc);
1745  	_pEditView = pOldView;
1746  	_findReplaceDlg.putFindResult(nbTotal);
1747  	if (nbTotal != 0)
1748  	{
1749  		NppParameters& nppParam = NppParameters::getInstance();
1750  		NppGUI& nppGui = nppParam.getNppGUI();
1751  		if (!nppGui._findDlgAlwaysVisible)
1752  		{
1753  			_findReplaceDlg.display(false);
1754  		}
1755  	}
1756  	return true;
1757  }
1758  bool Notepad_plus::findInCurrentFile(bool isEntireDoc)
1759  {
1760  	int nbTotal = 0;
1761  	Buffer * pBuf = _pEditView->getCurrentBuffer();
1762  	Sci_CharacterRangeFull mainSelection = _pEditView->getSelection();  
1763  	ScintillaEditView *pOldView = _pEditView;
1764  	_pEditView = &_invisibleEditView;
1765  	Document oldDoc = _invisibleEditView.execute(SCI_GETDOCPOINTER);
1766  	_findReplaceDlg.beginNewFilesSearch();
1767  	_invisibleEditView.execute(SCI_SETDOCPOINTER, 0, pBuf->getDocument());
1768  	setCodePageForInvisibleView(pBuf);
1769  	if (!isEntireDoc)
1770  	{
1771  		auto docLength = _invisibleEditView.execute(SCI_GETLENGTH);
1772  		if ((mainSelection.cpMin > 0) || (mainSelection.cpMax < docLength))
1773  		{
1774  			_invisibleEditView.execute(SCI_SETSELECTIONSTART, mainSelection.cpMin);
1775  			_invisibleEditView.execute(SCI_SETSELECTIONEND, mainSelection.cpMax);
1776  		}
1777  		else
1778  		{
1779  			isEntireDoc = true;
1780  		}
1781  	}
1782  	FindersInfo findersInfo;
1783  	findersInfo._pFileName = pBuf->getFullPathName();
1784  	nbTotal += _findReplaceDlg.processAll(ProcessFindAll, FindReplaceDlg::_env, isEntireDoc, &findersInfo);
1785  	_findReplaceDlg.finishFilesSearch(nbTotal, 1, isEntireDoc);
1786  	_invisibleEditView.execute(SCI_SETDOCPOINTER, 0, oldDoc);
1787  	_pEditView = pOldView;
1788  	_findReplaceDlg.putFindResult(nbTotal);
1789  	if (nbTotal != 0)
1790  	{
1791  		NppParameters& nppParam = NppParameters::getInstance();
1792  		NppGUI& nppGui = nppParam.getNppGUI();
1793  		if (!nppGui._findDlgAlwaysVisible)
1794  		{
1795  			_findReplaceDlg.display(false);
1796  		}
1797  	}
1798  	return true;
1799  }
1800  void Notepad_plus::filePrint(bool showDialog)
1801  {
1802  	Printer printer;
1803  	intptr_t startPos = _pEditView->execute(SCI_GETSELECTIONSTART);
1804  	intptr_t endPos = _pEditView->execute(SCI_GETSELECTIONEND);
1805  	printer.init(_pPublicInterface->getHinst(), _pPublicInterface->getHSelf(), _pEditView, showDialog, startPos, endPos, _nativeLangSpeaker.isRTL());
1806  	printer.doPrint();
1807  }
1808  int Notepad_plus::doSaveOrNot(const TCHAR* fn, bool isMulti)
1809  {
1810  	if ((NppParameters::getInstance()).isEndSessionCritical())
1811  		return IDCANCEL; 
1812  	if (!::IsWindowVisible(_pPublicInterface->getHSelf()))
1813  	{
1814  		::ShowWindow(_pPublicInterface->getHSelf(), SW_SHOW);
1815  		::SendMessage(_pPublicInterface->getHSelf(), WM_SIZE, 0, 0);
1816  	}
1817  	if (!isMulti)
1818  	{
1819  		generic_string title, msg;
1820  		if (!_nativeLangSpeaker.getDoSaveOrNotStrings(title, msg))
1821  		{
1822  			title = TEXT("Save");
1823  			msg = TEXT("Save file \"$STR_REPLACE$\" ?");
1824  		}
1825  		msg = stringReplace(msg, TEXT("$STR_REPLACE$"), fn);
1826  		return ::MessageBox(_pPublicInterface->getHSelf(), msg.c_str(), title.c_str(), MB_YESNOCANCEL | MB_ICONQUESTION | MB_APPLMODAL);
1827  	}
1828  	DoSaveOrNotBox doSaveOrNotBox;
1829  	doSaveOrNotBox.init(_pPublicInterface->getHinst(), _pPublicInterface->getHSelf(), fn, isMulti);
1830  	doSaveOrNotBox.doDialog(_nativeLangSpeaker.isRTL());
1831  	int buttonID = doSaveOrNotBox.getClickedButtonId();
1832  	doSaveOrNotBox.destroy();
1833  	return buttonID;
1834  }
1835  int Notepad_plus::doSaveAll()
1836  {
1837  	if (!::IsWindowVisible(_pPublicInterface->getHSelf()))
1838  	{
1839  		::ShowWindow(_pPublicInterface->getHSelf(), SW_SHOW);
1840  		::SendMessage(_pPublicInterface->getHSelf(), WM_SIZE, 0, 0);
1841  	}
1842  	DoSaveAllBox doSaveAllBox;
1843  	doSaveAllBox.init(_pPublicInterface->getHinst(), _pPublicInterface->getHSelf());
1844  	doSaveAllBox.doDialog(_nativeLangSpeaker.isRTL());
1845  	int buttonID = doSaveAllBox.getClickedButtonId();
1846  	doSaveAllBox.destroy();
1847  	return buttonID;
1848  }
1849  int Notepad_plus::doReloadOrNot(const TCHAR *fn, bool dirty)
1850  {
1851  	if (dirty)
1852  		return _nativeLangSpeaker.messageBox("DoReloadOrNotAndLooseChange",
1853  			_pPublicInterface->getHSelf(),
1854  			TEXT("\"$STR_REPLACE$\"\r\rThis file has been modified by another program.\rDo you want to reload it and lose the changes made in Notepad++?"),
1855  			TEXT("Reload"),
1856  			MB_YESNO | MB_APPLMODAL | MB_ICONEXCLAMATION,
1857  			0, 
1858  			fn);
1859  	else
1860  		return _nativeLangSpeaker.messageBox("DoReloadOrNot",
1861  			_pPublicInterface->getHSelf(),
1862  			TEXT("\"$STR_REPLACE$\"\r\rThis file has been modified by another program.\rDo you want to reload it?"),
1863  			TEXT("Reload"),
1864  			MB_YESNO | MB_APPLMODAL | MB_ICONQUESTION,
1865  			0, 
1866  			fn);
1867  }
1868  int Notepad_plus::doCloseOrNot(const TCHAR *fn)
1869  {
1870  	return _nativeLangSpeaker.messageBox("DoCloseOrNot",
1871  		_pPublicInterface->getHSelf(),
1872  		TEXT("The file \"$STR_REPLACE$\" doesn't exist anymore.\rKeep this file in editor?"),
1873  		TEXT("Keep non existing file"),
1874  		MB_YESNO | MB_ICONQUESTION | MB_APPLMODAL,
1875  		0, 
1876  		fn);
1877  }
1878  int Notepad_plus::doDeleteOrNot(const TCHAR *fn)
1879  {
1880  	return _nativeLangSpeaker.messageBox("DoDeleteOrNot",
1881  		_pPublicInterface->getHSelf(),
1882  		TEXT("The file \"$STR_REPLACE$\"\rwill be moved to your Recycle Bin and this document will be closed.\rContinue?"),
1883  		TEXT("Delete file"),
1884  		MB_OKCANCEL | MB_ICONQUESTION | MB_APPLMODAL,
1885  		0, 
1886  		fn);
1887  }
1888  void Notepad_plus::enableMenu(int cmdID, bool doEnable) const
1889  {
1890  	int flag = doEnable?MF_ENABLED | MF_BYCOMMAND:MF_DISABLED | MF_GRAYED | MF_BYCOMMAND;
1891  	::EnableMenuItem(_mainMenuHandle, cmdID, flag);
1892  }
1893  void Notepad_plus::enableCommand(int cmdID, bool doEnable, int which) const
1894  {
1895  	if (which & MENU)
1896  	{
1897  		enableMenu(cmdID, doEnable);
1898  	}
1899  	if (which & TOOLBAR)
1900  	{
1901  		_toolBar.enable(cmdID, doEnable);
1902  	}
1903  }
1904  void Notepad_plus::checkClipboard()
1905  {
1906  	bool hasSelection = (_pEditView->execute(SCI_GETSELECTIONSTART) != _pEditView->execute(SCI_GETSELECTIONEND));
1907  	bool canPaste = (_pEditView->execute(SCI_CANPASTE) != 0);
1908  	enableCommand(IDM_EDIT_CUT, hasSelection, MENU | TOOLBAR);
1909  	enableCommand(IDM_EDIT_COPY, hasSelection, MENU | TOOLBAR);
1910  	enableCommand(IDM_EDIT_PASTE, canPaste, MENU | TOOLBAR);
1911  	enableCommand(IDM_EDIT_DELETE, hasSelection, MENU | TOOLBAR);
1912  	enableCommand(IDM_EDIT_UPPERCASE, hasSelection, MENU);
1913  	enableCommand(IDM_EDIT_LOWERCASE, hasSelection, MENU);
1914  	enableCommand(IDM_EDIT_PROPERCASE_FORCE, hasSelection, MENU);
1915  	enableCommand(IDM_EDIT_PROPERCASE_BLEND, hasSelection, MENU);
1916  	enableCommand(IDM_EDIT_SENTENCECASE_FORCE, hasSelection, MENU);
1917  	enableCommand(IDM_EDIT_SENTENCECASE_BLEND, hasSelection, MENU);
1918  	enableCommand(IDM_EDIT_INVERTCASE, hasSelection, MENU);
1919  	enableCommand(IDM_EDIT_RANDOMCASE, hasSelection, MENU);
1920  }
1921  void Notepad_plus::checkDocState()
1922  {
1923  	Buffer * curBuf = _pEditView->getCurrentBuffer();
1924  	bool isCurrentDirty = curBuf->isDirty();
1925  	bool isSeveralDirty = isCurrentDirty;
1926  	bool isFileExisting = PathFileExists(curBuf->getFullPathName()) != FALSE;
1927  	if (!isCurrentDirty)
1928  	{
1929  		for (size_t i = 0; i < MainFileManager.getNbBuffers(); ++i)
1930  		{
1931  			if (MainFileManager.getBufferByIndex(i)->isDirty())
1932  			{
1933  				isSeveralDirty = true;
1934  				break;
1935  			}
1936  		}
1937  	}
1938  	bool isCurrentUntitled = curBuf->isUntitled();
1939  	enableCommand(IDM_FILE_SAVE, isCurrentDirty, MENU | TOOLBAR);
1940  	enableCommand(IDM_FILE_SAVEALL, isSeveralDirty, MENU | TOOLBAR);
1941  	enableCommand(IDM_VIEW_GOTO_NEW_INSTANCE, !(isCurrentDirty || isCurrentUntitled), MENU);
1942  	enableCommand(IDM_VIEW_LOAD_IN_NEW_INSTANCE, !(isCurrentDirty || isCurrentUntitled), MENU);
1943  	bool isSysReadOnly = curBuf->getFileReadOnly();
1944  	enableCommand(IDM_EDIT_CLEARREADONLY, isSysReadOnly, MENU);
1945  	bool doEnable = !(curBuf->isMonitoringOn() || isSysReadOnly);
1946  	enableCommand(IDM_EDIT_SETREADONLY, doEnable, MENU);
1947  	bool isUserReadOnly = curBuf->getUserReadOnly();
1948  	::CheckMenuItem(_mainMenuHandle, IDM_EDIT_SETREADONLY, MF_BYCOMMAND | (isUserReadOnly ? MF_CHECKED : MF_UNCHECKED));
1949  	enableCommand(IDM_FILE_DELETE, isFileExisting, MENU);
1950  	enableCommand(IDM_FILE_OPEN_CMD, isFileExisting, MENU);
1951  	enableCommand(IDM_FILE_OPEN_FOLDER, isFileExisting, MENU);
1952  	enableCommand(IDM_FILE_RELOAD, isFileExisting, MENU);
1953  	enableCommand(IDM_FILE_OPEN_DEFAULT_VIEWER, isAssoCommandExisting(curBuf->getFullPathName()), MENU);
1954  	enableCommand(IDM_VIEW_IN_FIREFOX, isFileExisting, MENU);
1955  	enableCommand(IDM_VIEW_IN_CHROME, isFileExisting, MENU);
1956  	enableCommand(IDM_VIEW_IN_IE, isFileExisting, MENU);
1957  	enableCommand(IDM_VIEW_IN_EDGE, isFileExisting, MENU);
1958  	enableConvertMenuItems(curBuf->getEolFormat());
1959  	checkUnicodeMenuItems();
1960  	checkLangsMenu(-1);
1961  	if (_pAnsiCharPanel)
1962  		_pAnsiCharPanel->switchEncoding();
1963  	enableCommand(IDM_VIEW_MONITORING, !curBuf->isUntitled(), MENU | TOOLBAR);
1964  	checkMenuItem(IDM_VIEW_MONITORING, curBuf->isMonitoringOn());
1965  	_toolBar.setCheck(IDM_VIEW_MONITORING, curBuf->isMonitoringOn());
1966  }
1967  void Notepad_plus::checkUndoState()
1968  {
1969  	enableCommand(IDM_EDIT_UNDO, _pEditView->execute(SCI_CANUNDO) != 0, MENU | TOOLBAR);
1970  	enableCommand(IDM_EDIT_REDO, _pEditView->execute(SCI_CANREDO) != 0, MENU | TOOLBAR);
1971  }
1972  void Notepad_plus::checkMacroState()
1973  {
1974  	enableCommand(IDM_MACRO_STARTRECORDINGMACRO, !_recordingMacro, MENU | TOOLBAR);
1975  	enableCommand(IDM_MACRO_STOPRECORDINGMACRO, _recordingMacro, MENU | TOOLBAR);
1976  	enableCommand(IDM_MACRO_PLAYBACKRECORDEDMACRO, !_macro.empty() && !_recordingMacro, MENU | TOOLBAR);
1977  	enableCommand(IDM_MACRO_SAVECURRENTMACRO, !_macro.empty() && !_recordingMacro && !_recordingSaved, MENU | TOOLBAR);
1978  	enableCommand(IDM_MACRO_RUNMULTIMACRODLG, (!_macro.empty() && !_recordingMacro) || !((NppParameters::getInstance()).getMacroList()).empty(), MENU | TOOLBAR);
1979  }
1980  void Notepad_plus::checkSyncState()
1981  {
1982  	bool canDoSync = viewVisible(MAIN_VIEW) && viewVisible(SUB_VIEW);
1983  	if (!canDoSync)
1984  	{
1985  		_syncInfo._isSynScollV = false;
1986  		_syncInfo._isSynScollH = false;
1987  		checkMenuItem(IDM_VIEW_SYNSCROLLV, false);
1988  		checkMenuItem(IDM_VIEW_SYNSCROLLH, false);
1989  		_toolBar.setCheck(IDM_VIEW_SYNSCROLLV, false);
1990  		_toolBar.setCheck(IDM_VIEW_SYNSCROLLH, false);
1991  	}
1992  	enableCommand(IDM_VIEW_SYNSCROLLV, canDoSync, MENU | TOOLBAR);
1993  	enableCommand(IDM_VIEW_SYNSCROLLH, canDoSync, MENU | TOOLBAR);
1994  }
1995  void Notepad_plus::setupColorSampleBitmapsOnMainMenuItems()
1996  {
1997  	struct
1998  	{
1999  		int firstOfThisColorMenuId;
2000  		int styleIndic;
2001  		std::vector<int> sameColorMenuIds;
2002  	}
2003  	bitmapOnStyleMenuItemsInfo[] =
2004  	{
2005  		{ IDM_SEARCH_GONEXTMARKER5, SCE_UNIVERSAL_FOUND_STYLE_EXT5, { IDM_SEARCH_MARKALLEXT5, IDM_SEARCH_MARKONEEXT5, IDM_SEARCH_UNMARKALLEXT5, IDM_SEARCH_GOPREVMARKER5, IDM_SEARCH_STYLE5TOCLIP } },
2006  		{ IDM_SEARCH_GONEXTMARKER4, SCE_UNIVERSAL_FOUND_STYLE_EXT4, { IDM_SEARCH_MARKALLEXT4, IDM_SEARCH_MARKONEEXT4, IDM_SEARCH_UNMARKALLEXT4, IDM_SEARCH_GOPREVMARKER4, IDM_SEARCH_STYLE4TOCLIP } },
2007  		{ IDM_SEARCH_GONEXTMARKER3, SCE_UNIVERSAL_FOUND_STYLE_EXT3, { IDM_SEARCH_MARKALLEXT3, IDM_SEARCH_MARKONEEXT3, IDM_SEARCH_UNMARKALLEXT3, IDM_SEARCH_GOPREVMARKER3, IDM_SEARCH_STYLE3TOCLIP } },
2008  		{ IDM_SEARCH_GONEXTMARKER2, SCE_UNIVERSAL_FOUND_STYLE_EXT2, { IDM_SEARCH_MARKALLEXT2, IDM_SEARCH_MARKONEEXT2, IDM_SEARCH_UNMARKALLEXT2, IDM_SEARCH_GOPREVMARKER2, IDM_SEARCH_STYLE2TOCLIP } },
2009  		{ IDM_SEARCH_GONEXTMARKER1, SCE_UNIVERSAL_FOUND_STYLE_EXT1, { IDM_SEARCH_MARKALLEXT1, IDM_SEARCH_MARKONEEXT1, IDM_SEARCH_UNMARKALLEXT1, IDM_SEARCH_GOPREVMARKER1, IDM_SEARCH_STYLE1TOCLIP } },
2010  		{ IDM_SEARCH_GONEXTMARKER_DEF, SCE_UNIVERSAL_FOUND_STYLE, { IDM_SEARCH_GOPREVMARKER_DEF, IDM_SEARCH_MARKEDTOCLIP } }
2011  	};
2012  	for (size_t j = 0; j < sizeof(bitmapOnStyleMenuItemsInfo) / sizeof(bitmapOnStyleMenuItemsInfo[0]); ++j)
2013  	{
2014  		const Style * pStyle = NppParameters::getInstance().getMiscStylerArray().findByID(bitmapOnStyleMenuItemsInfo[j].styleIndic);
2015  		if (pStyle)
2016  		{
2017  			HBITMAP hNewBitmap = generateSolidColourMenuItemIcon(pStyle->_bgColor);
2018  			SetMenuItemBitmaps(_mainMenuHandle, bitmapOnStyleMenuItemsInfo[j].firstOfThisColorMenuId, MF_BYCOMMAND, hNewBitmap, hNewBitmap);
2019  			for (int relatedMenuId : bitmapOnStyleMenuItemsInfo[j].sameColorMenuIds)
2020  			{
2021  				SetMenuItemBitmaps(_mainMenuHandle, relatedMenuId, MF_BYCOMMAND, hNewBitmap, NULL);
2022  			}
2023  		}
2024  	}
2025  	for (int i = 0; i < 5; ++i)
2026  	{
2027  		COLORREF colour = NppDarkMode::getIndividualTabColour(i, NppDarkMode::isDarkMenuEnabled(), true);
2028  		HBITMAP hBitmap = generateSolidColourMenuItemIcon(colour);
2029  		SetMenuItemBitmaps(_mainMenuHandle, IDM_VIEW_TAB_COLOUR_1 + i, MF_BYCOMMAND, hBitmap, hBitmap);
2030  	}
2031  }
2032  bool doCheck(HMENU mainHandle, int id)
2033  {
2034  	MENUITEMINFO mii{};
2035  	mii.cbSize = sizeof(MENUITEMINFO);
2036  	mii.fMask = MIIM_SUBMENU | MIIM_FTYPE | MIIM_ID | MIIM_STATE;
2037  	bool found = false;
2038  	int count = ::GetMenuItemCount(mainHandle);
2039  	for (int i = 0; i < count; i++)
2040  	{
2041  		::GetMenuItemInfo(mainHandle, i, MF_BYPOSITION, &mii);
2042  		if (mii.fType == MFT_RADIOCHECK || mii.fType == MFT_STRING)
2043  		{
2044  			bool checked = mii.hSubMenu ? doCheck(mii.hSubMenu, id) : (mii.wID == (unsigned int)id);
2045  			if (checked)
2046  			{
2047  				::CheckMenuRadioItem(mainHandle, 0, count, i, MF_BYPOSITION);
2048  				found = true;
2049  			}
2050  			else
2051  			{
2052  				mii.fState = 0;
2053  				::SetMenuItemInfo(mainHandle, i, MF_BYPOSITION, &mii);
2054  			}
2055  		}
2056  	}
2057  	return found;
2058  }
2059  void Notepad_plus::checkLangsMenu(int id) const
2060  {
2061  	Buffer * curBuf = _pEditView->getCurrentBuffer();
2062  	if (id == -1)
2063  	{
2064  		id = (NppParameters::getInstance()).langTypeToCommandID(curBuf->getLangType());
2065  		if (id == IDM_LANG_USER)
2066  		{
2067  			if (curBuf->isUserDefineLangExt())
2068  			{
2069  				const TCHAR *userLangName = curBuf->getUserDefineLangName();
2070  				TCHAR menuLangName[menuItemStrLenMax];
2071  				for (int i = IDM_LANG_USER + 1 ; i <= IDM_LANG_USER_LIMIT ; ++i)
2072  				{
2073  					if (::GetMenuString(_mainMenuHandle, i, menuLangName, menuItemStrLenMax, MF_BYCOMMAND))
2074  					{
2075  						if (!lstrcmp(userLangName, menuLangName))
2076  						{
2077  							HMENU _langMenuHandle = ::GetSubMenu(_mainMenuHandle, MENUINDEX_LANGUAGE);
2078  							doCheck(_langMenuHandle, i);
2079  							return;
2080  						}
2081  					}
2082  				}
2083  			}
2084  		}
2085  	}
2086  	HMENU _langMenuHandle = ::GetSubMenu(_mainMenuHandle, MENUINDEX_LANGUAGE);
2087  	doCheck(_langMenuHandle, id);
2088  }
2089  generic_string Notepad_plus::getLangDesc(LangType langType, bool getName)
2090  {
2091  	NppParameters& nppParams = NppParameters::getInstance();
2092  	if ((langType >= L_EXTERNAL) && (langType < nppParams.L_END))
2093  	{
2094  		ExternalLangContainer & elc = nppParams.getELCFromIndex(langType - L_EXTERNAL);
2095  		WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
2096  		const TCHAR* lexerNameW = wmc.char2wchar(elc._name.c_str(), CP_ACP);
2097  		return generic_string(lexerNameW);
2098  	}
2099  	if (langType < L_TEXT || langType > L_EXTERNAL)
2100          langType = L_TEXT;
2101  	generic_string str2Show;
2102  	if (getName)
2103  		str2Show = ScintillaEditView::_langNameInfoArray[langType]._shortName;
2104  	else
2105  		str2Show = ScintillaEditView::_langNameInfoArray[langType]._longName;
2106  	if (langType == L_USER)
2107  	{
2108  		Buffer * currentBuf = _pEditView->getCurrentBuffer();
2109  		if (currentBuf->isUserDefineLangExt())
2110  		{
2111  			str2Show += TEXT(" - ");
2112  			str2Show += currentBuf->getUserDefineLangName();
2113  		}
2114  	}
2115  	return str2Show;
2116  }
2117  void Notepad_plus::copyMarkedLines()
2118  {
2119  	intptr_t lastLine = _pEditView->lastZeroBasedLineNumber();
2120  	generic_string globalStr = TEXT("");
2121  	for (intptr_t i = lastLine ; i >= 0 ; i--)
2122  	{
2123  		if (bookmarkPresent(i))
2124  		{
2125  			generic_string currentStr = getMarkedLine(i) + globalStr;
2126  			globalStr = currentStr;
2127  		}
2128  	}
2129  	str2Cliboard(globalStr);
2130  }
2131  std::mutex mark_mutex;
2132  void Notepad_plus::cutMarkedLines()
2133  {
2134  	std::lock_guard<std::mutex> lock(mark_mutex);
2135  	intptr_t lastLine = _pEditView->lastZeroBasedLineNumber();
2136  	generic_string globalStr = TEXT("");
2137  	_pEditView->execute(SCI_BEGINUNDOACTION);
2138  	for (intptr_t i = lastLine ; i >= 0 ; i--)
2139  	{
2140  		if (bookmarkPresent(i))
2141  		{
2142  			generic_string currentStr = getMarkedLine(i) + globalStr;
2143  			globalStr = currentStr;
2144  			deleteMarkedline(i);
2145  		}
2146  	}
2147  	_pEditView->execute(SCI_ENDUNDOACTION);
2148  	str2Cliboard(globalStr);
2149  }
2150  void Notepad_plus::deleteMarkedLines(bool isMarked)
2151  {
2152  	std::lock_guard<std::mutex> lock(mark_mutex);
2153  	intptr_t lastLine = _pEditView->lastZeroBasedLineNumber();
2154  	_pEditView->execute(SCI_BEGINUNDOACTION);
2155  	for (intptr_t i = lastLine ; i >= 0 ; i--)
2156  	{
2157  		if (bookmarkPresent(i) == isMarked)
2158  			deleteMarkedline(i);
2159  	}
2160  	_pEditView->execute(SCI_ENDUNDOACTION);
2161  }
2162  void Notepad_plus::pasteToMarkedLines()
2163  {
2164  	std::lock_guard<std::mutex> lock(mark_mutex);
2165  	int clipFormat;
2166  	clipFormat = CF_UNICODETEXT;
2167  	BOOL canPaste = ::IsClipboardFormatAvailable(clipFormat);
2168  	if (!canPaste)
2169  		return;
2170  	intptr_t lastLine = _pEditView->lastZeroBasedLineNumber();
2171  	::OpenClipboard(_pPublicInterface->getHSelf());
2172  	HANDLE clipboardData = ::GetClipboardData(clipFormat);
2173  	::GlobalSize(clipboardData);
2174  	LPVOID clipboardDataPtr = ::GlobalLock(clipboardData);
2175  	if (!clipboardDataPtr) return;
2176  	generic_string clipboardStr = (const TCHAR *)clipboardDataPtr;
2177  	::GlobalUnlock(clipboardData);
2178  	::CloseClipboard();
2179  	_pEditView->execute(SCI_BEGINUNDOACTION);
2180  	for (intptr_t i = lastLine ; i >= 0 ; i--)
2181  	{
2182  		if (bookmarkPresent(i))
2183  		{
2184  			replaceMarkedline(i, clipboardStr.c_str());
2185  		}
2186  	}
2187  	_pEditView->execute(SCI_ENDUNDOACTION);
2188  }
2189  void Notepad_plus::deleteMarkedline(size_t ln)
2190  {
2191  	intptr_t lineLen = _pEditView->execute(SCI_LINELENGTH, ln);
2192  	intptr_t lineBegin = _pEditView->execute(SCI_POSITIONFROMLINE, ln);
2193  	bookmarkDelete(ln);
2194  	TCHAR emptyString[2] = TEXT("");
2195  	_pEditView->replaceTarget(emptyString, lineBegin, lineBegin + lineLen);
2196  }
2197  void Notepad_plus::inverseMarks()
2198  {
2199  	intptr_t lastLine = _pEditView->lastZeroBasedLineNumber();
2200  	for (int i = 0 ; i <= lastLine  ; ++i)
2201  	{
2202  		if (bookmarkPresent(i))
2203  		{
2204  			bookmarkDelete(i);
2205  		}
2206  		else
2207  		{
2208  			bookmarkAdd(i);
2209  		}
2210  	}
2211  }
2212  void Notepad_plus::replaceMarkedline(size_t ln, const TCHAR *str)
2213  {
2214  	intptr_t lineBegin = _pEditView->execute(SCI_POSITIONFROMLINE, ln);
2215  	intptr_t lineEnd = _pEditView->execute(SCI_GETLINEENDPOSITION, ln);
2216  	_pEditView->replaceTarget(str, lineBegin, lineEnd);
2217  }
2218  generic_string Notepad_plus::getMarkedLine(size_t ln)
2219  {
2220  	auto lineLen = _pEditView->execute(SCI_LINELENGTH, ln);
2221  	auto lineBegin = _pEditView->execute(SCI_POSITIONFROMLINE, ln);
2222  	TCHAR * buf = new TCHAR[lineLen+1];
2223  	_pEditView->getGenericText(buf, lineLen + 1, lineBegin, lineBegin + lineLen);
2224  	generic_string line = buf;
2225  	delete [] buf;
2226  	return line;
2227  }
2228  void Notepad_plus::findMatchingBracePos(intptr_t& braceAtCaret, intptr_t& braceOpposite)
2229  {
2230  	intptr_t caretPos = _pEditView->execute(SCI_GETCURRENTPOS);
2231  	braceAtCaret = -1;
2232  	braceOpposite = -1;
2233  	TCHAR charBefore = '\0';
2234  	intptr_t lengthDoc = _pEditView->execute(SCI_GETLENGTH);
2235  	if ((lengthDoc > 0) && (caretPos > 0))
2236      {
2237  		charBefore = TCHAR(_pEditView->execute(SCI_GETCHARAT, caretPos - 1, 0));
2238  	}
2239  	if (charBefore && wcschr(L"[](){}", charBefore))
2240      {
2241  		braceAtCaret = caretPos - 1;
2242  	}
2243  	if (lengthDoc > 0  && (braceAtCaret < 0))
2244      {
2245  		TCHAR charAfter = TCHAR(_pEditView->execute(SCI_GETCHARAT, caretPos, 0));
2246  		if (charAfter && wcschr(L"[](){}", charAfter))
2247          {
2248  			braceAtCaret = caretPos;
2249  		}
2250  	}
2251  	if (braceAtCaret >= 0)
2252  		braceOpposite = _pEditView->execute(SCI_BRACEMATCH, braceAtCaret, 0);
2253  }
2254  bool Notepad_plus::braceMatch()
2255  {
2256  	Buffer* currentBuf = _pEditView->getCurrentBuffer();
2257  	if (!currentBuf->allowBraceMach())
2258  		return false;
2259  	intptr_t braceAtCaret = -1;
2260  	intptr_t braceOpposite = -1;
2261  	findMatchingBracePos(braceAtCaret, braceOpposite);
2262  	if ((braceAtCaret != -1) && (braceOpposite == -1))
2263      {
2264  		_pEditView->execute(SCI_BRACEBADLIGHT, braceAtCaret);
2265  		_pEditView->execute(SCI_SETHIGHLIGHTGUIDE, 0);
2266  	}
2267      else
2268      {
2269  		_pEditView->execute(SCI_BRACEHIGHLIGHT, braceAtCaret, braceOpposite);
2270  		if (_pEditView->isShownIndentGuide())
2271          {
2272              intptr_t columnAtCaret = _pEditView->execute(SCI_GETCOLUMN, braceAtCaret);
2273  		    intptr_t columnOpposite = _pEditView->execute(SCI_GETCOLUMN, braceOpposite);
2274  			_pEditView->execute(SCI_SETHIGHLIGHTGUIDE, (columnAtCaret < columnOpposite)?columnAtCaret:columnOpposite);
2275          }
2276      }
2277  	const bool enable = (braceAtCaret != -1) && (braceOpposite != -1);
2278      enableCommand(IDM_SEARCH_GOTOMATCHINGBRACE, enable, MENU | TOOLBAR);
2279  	enableCommand(IDM_SEARCH_SELECTMATCHINGBRACES, enable, MENU);
2280      return (braceAtCaret != -1);
2281  }
2282  void Notepad_plus::setLangStatus(LangType langType)
2283  {
2284  	_statusBar.setText(getLangDesc(langType).c_str(), STATUSBAR_DOC_TYPE);
2285  }
2286  void Notepad_plus::setDisplayFormat(EolType format)
2287  {
2288  	const TCHAR* str = TEXT("??");
2289  	switch (format)
2290  	{
2291  		case EolType::windows: str = TEXT("Windows (CR LF)"); break;
2292  		case EolType::macos:   str = TEXT("Macintosh (CR)"); break;
2293  		case EolType::unix:    str = TEXT("Unix (LF)"); break;
2294  		case EolType::unknown: str = TEXT("Unknown"); assert(false);  break;
2295  	}
2296  	_statusBar.setText(str, STATUSBAR_EOF_FORMAT);
2297  }
2298  void Notepad_plus::setUniModeText()
2299  {
2300  	Buffer *buf = _pEditView->getCurrentBuffer();
2301  	int encoding = buf->getEncoding();
2302  	UniMode um = buf->getUnicodeMode();
2303  	generic_string uniModeTextString;
2304  	if (encoding == -1)
2305  	{
2306  		switch (um)
2307  		{
2308  			case uniUTF8:
2309  				uniModeTextString = TEXT("UTF-8-BOM"); break;
2310  			case uni16BE:
2311  				uniModeTextString = TEXT("UTF-16 BE BOM"); break;
2312  			case uni16LE:
2313  				uniModeTextString = TEXT("UTF-16 LE BOM"); break;
2314  			case uni16BE_NoBOM:
2315  				uniModeTextString = TEXT("UTF-16 Big Endian"); break;
2316  			case uni16LE_NoBOM:
2317  				uniModeTextString = TEXT("UTF-16 Little Endian"); break;
2318  			case uniCookie:
2319  				uniModeTextString = TEXT("UTF-8"); break;
2320  			default :
2321  				uniModeTextString = TEXT("ANSI");
2322  		}
2323  	}
2324  	else
2325  	{
2326  		EncodingMapper& em = EncodingMapper::getInstance();
2327  		int cmdID = em.getIndexFromEncoding(encoding);
2328  		if (cmdID == -1)
2329  		{
2330  			assert(!"Encoding problem. Encoding is not added in encoding_table?");
2331  			return;
2332  		}
2333  		cmdID += IDM_FORMAT_ENCODE;
2334  		TCHAR uniModeText[menuItemStrLenMax]{};
2335  		::GetMenuString(_mainMenuHandle, cmdID, uniModeText, menuItemStrLenMax, MF_BYCOMMAND);
2336  		uniModeTextString = uniModeText;
2337  		const size_t tabPos = uniModeTextString.find_last_of('\t');
2338  		if (tabPos != generic_string::npos)
2339  			uniModeTextString.resize(tabPos);
2340  	}
2341  	_statusBar.setText(uniModeTextString.c_str(), STATUSBAR_UNICODE_TYPE);
2342  }
2343  bool isUrlSchemeStartChar(TCHAR const c)
2344  {
2345  	return ((c >= 'A') && (c <= 'Z'))
2346  		|| ((c >= 'a') && (c <= 'z'));
2347  }
2348  bool isUrlSchemeDelimiter(TCHAR const c) 
2349  {
2350  	return   ! (((c >= '0') && (c <= '9'))
2351  			 || ((c >= 'A') && (c <= 'Z'))
2352  			 || ((c >= 'a') && (c <= 'z'))
2353  			 ||  (c == '_'));
2354  }
2355  bool isUrlTextChar(TCHAR const c)
2356  {
2357  	if (c <= ' ') return false;
2358  	switch (c)
2359  	{
2360  		case '"':
2361  		case '#':
2362  		case '<':
2363  		case '>':
2364  		case '{':
2365  		case '}':
2366  		case '?':
2367  		case '\u007F':
2368  			return false;
2369  	}
2370  	return true;
2371  }
2372  bool isUrlQueryDelimiter(TCHAR const c)
2373  {
2374  	switch(c)
2375  	{
2376  		case '&':
2377  		case '+':
2378  		case '=':
2379  		case ';':
2380  			return true;
2381  	}
2382  	return false;
2383  }
2384  bool isUrlSchemeSupported(INTERNET_SCHEME s, TCHAR *url)
2385  {
2386  	switch (s)
2387  	{
2388  		case INTERNET_SCHEME_FTP:
2389  		case INTERNET_SCHEME_HTTP:
2390  		case INTERNET_SCHEME_HTTPS:
2391  		case INTERNET_SCHEME_MAILTO:
2392  		case INTERNET_SCHEME_FILE:
2393  			return true;
2394  		case INTERNET_SCHEME_PARTIAL:
2395  		case INTERNET_SCHEME_UNKNOWN:
2396  		case INTERNET_SCHEME_DEFAULT:
2397  		case INTERNET_SCHEME_GOPHER:
2398  		case INTERNET_SCHEME_NEWS:
2399  		case INTERNET_SCHEME_SOCKS:
2400  		case INTERNET_SCHEME_JAVASCRIPT:
2401  		case INTERNET_SCHEME_VBSCRIPT:
2402  		case INTERNET_SCHEME_RES:
2403  		default:
2404  			break;
2405  	}
2406  	generic_string const mySchemes = (NppParameters::getInstance()).getNppGUI()._uriSchemes + TEXT(" ");
2407  	TCHAR *p = (TCHAR *)mySchemes.c_str();
2408  	while (*p)
2409  	{
2410  		int i = 0;
2411  		while (p [i] && (p [i] != ' ')) i++;
2412  		if (i == 0) return false;
2413  		if (wcsnicmp(url, p, i) == 0) return true;
2414  		p += i;
2415  		while (*p == ' ') p++;
2416  	}
2417  	return false;
2418  }
2419  bool scanToUrlStart(TCHAR *text, int textLen, int start, int* distance, int* schemeLength)
2420  {
2421  	int p = start;
2422  	int p0 = 0;
2423  	enum {sUnknown, sScheme} s = sUnknown;
2424  	while (p < textLen)
2425  	{
2426  		switch (s)
2427  		{
2428  			case sUnknown:
2429  				if (isUrlSchemeStartChar(text [p]) && ((p == 0) || isUrlSchemeDelimiter(text [p - 1])))
2430  				{
2431  					p0 = p;
2432  					s = sScheme;
2433  				}
2434  				break;
2435  			case sScheme:
2436  				if (text [p] == ':')
2437  				{
2438  					*distance = p0 - start;
2439  					*schemeLength = p - p0 + 1;
2440  					return true;
2441  				}
2442  				if (!isUrlSchemeStartChar(text [p]))
2443  					s = sUnknown;
2444  				break;
2445  		}
2446  		p++;
2447  	}
2448  	*schemeLength = 0;
2449  	*distance = p - start;
2450  	return false;
2451  }
2452  void scanToUrlEnd(TCHAR *text, int textLen, int start, int* distance)
2453  {
2454  	int p = start;
2455  	TCHAR q = 0;
2456  	enum {sHostAndPath, sQuery, sQueryAfterDelimiter, sQueryQuotes, sQueryAfterQuotes, sFragment} s = sHostAndPath;
2457  	while (p < textLen)
2458  	{
2459  		switch (s)
2460  		{
2461  			case sHostAndPath: 
2462  				if (text [p] == '?')
2463  					s = sQuery;
2464  				else if (text [p] == '#')
2465  					s = sFragment;
2466  				else if (!isUrlTextChar (text [p]))
2467  				{
2468  					*distance = p - start;
2469  					return;
2470  				}
2471  				break;
2472  			case sQuery:
2473  				if (text [p] == '#')
2474  					s = sFragment;
2475  				else if (isUrlQueryDelimiter (text [p]))
2476  					s = sQueryAfterDelimiter;
2477  				else if (!isUrlTextChar(text [p]))
2478  				{
2479  					*distance = p - start;
2480  					return;
2481  				}
2482  				break;
2483  			case sQueryAfterDelimiter:
2484  				if ((text [p] == '\'') || (text [p] == '"') || (text [p] == '`'))
2485  				{
2486  					q = text [p];
2487  					s = sQueryQuotes;
2488  				}
2489  				else if (text [p] == '(')
2490  				{
2491  					q = ')';
2492  					s = sQueryQuotes;
2493  				}
2494  				else if (text [p] == '[')
2495  				{
2496  					q = ']';
2497  					s = sQueryQuotes;
2498  				}
2499  				else if (text [p] == '{')
2500  				{
2501  					q = '}';
2502  					s = sQueryQuotes;
2503  				}
2504  				else if (isUrlTextChar(text [p]))
2505  					s = sQuery;
2506  				else
2507  				{
2508  					*distance = p - start;
2509  					return;
2510  				}
2511  				break;
2512  			case sQueryQuotes:
2513  				if (text [p] < ' ')
2514  				{
2515  					*distance = p - start;
2516  					return;
2517  				}
2518  				if (text [p] == q)
2519  					s = sQueryAfterQuotes;
2520  				break;
2521  			case sQueryAfterQuotes:
2522  				if (isUrlQueryDelimiter (text [p]))
2523  					s = sQueryAfterDelimiter;
2524  				else
2525  				{
2526  					*distance = p - start;
2527  					return;
2528  				}
2529  				break;
2530  			case sFragment:
2531  				if (!isUrlTextChar(text [p]))
2532  				{
2533  					*distance = p - start;
2534  					return;
2535  				}
2536  				break;
2537  		}
2538  		p++;
2539  	}
2540  	*distance = p - start;
2541  }
2542  bool removeUnwantedTrailingCharFromUrl (TCHAR const *text, int* length)
2543  {
2544  	int l = *length - 1;
2545  	if (l <= 0) return false;
2546  	{ 
2547  		const TCHAR *singleChars = L".,:;?!#";
2548  		for (int i = 0; singleChars [i]; i++)
2549  			if (text [l] == singleChars [i])
2550  			{
2551  				*length = l;
2552  				return true;
2553  			}
2554  	}
2555  	{ 
2556  		const TCHAR *closingParenthesis = L")]";
2557  		const TCHAR *openingParenthesis = L"([";
2558  		for (int i = 0; closingParenthesis [i]; i++)
2559  			if (text [l] == closingParenthesis [i])
2560  			{
2561  				int count = 0;
2562  				for (int j = l - 1; j >= 0; j--)
2563  				{
2564  					if (text [j] == closingParenthesis [i])
2565  						count++;
2566  					if (text[j] == openingParenthesis[i])
2567  					{
2568  						if (count > 0)
2569  							count--;
2570  						else
2571  							return false;
2572  					}
2573  				}
2574  				if (count != 0)
2575  					return false;
2576  				*length = l;
2577  				return true;
2578  			}
2579  	}
2580  	return false;
2581  }
2582  bool isUrl(TCHAR * text, int textLen, int start, int* segmentLen)
2583  {
2584  	int dist = 0, schemeLen = 0;
2585  	if (scanToUrlStart(text, textLen, start, & dist, & schemeLen))
2586  	{
2587  		if (dist)
2588  		{
2589  			*segmentLen = dist;
2590  			return false;
2591  		}
2592  		int len = 0;
2593  		scanToUrlEnd (text, textLen, start + schemeLen, & len);
2594  		if (len)
2595  		{
2596  			len += schemeLen;
2597  			URL_COMPONENTS url;
2598  			memset (& url, 0, sizeof(url));
2599  			url.dwStructSize = sizeof(url);
2600  			bool r  = InternetCrackUrl(& text [start], len, 0, & url) && isUrlSchemeSupported(url.nScheme, & text [start]);
2601  			if (r)
2602  			{
2603  				while (removeUnwantedTrailingCharFromUrl (& text [start], & len));
2604  				*segmentLen = len;
2605  				return true;
2606  			}
2607  		}
2608  		len = 1;
2609  		int lMax = textLen - start;
2610  		while (isUrlSchemeStartChar(text[start+len]) && (len < lMax)) len++;
2611  		*segmentLen = len;
2612  		return false;
2613  	}
2614  	*segmentLen = dist;
2615  	return false;
2616  }
2617  void Notepad_plus::addHotSpot(ScintillaEditView* view)
2618  {
2619  	ScintillaEditView* pView = view ? view : _pEditView;
2620  	Buffer* currentBuf = pView->getCurrentBuffer();
2621  	int urlAction = (NppParameters::getInstance()).getNppGUI()._styleURL;
2622  	LPARAM indicStyle = (urlAction == urlNoUnderLineFg) || (urlAction == urlNoUnderLineBg) ? INDIC_HIDDEN : INDIC_PLAIN;
2623  	LPARAM indicHoverStyle = (urlAction == urlNoUnderLineBg) || (urlAction == urlUnderLineBg) ? INDIC_FULLBOX : INDIC_EXPLORERLINK;
2624  	LPARAM indicStyleCur = pView->execute(SCI_INDICGETSTYLE, URL_INDIC);
2625  	LPARAM indicHoverStyleCur = pView->execute(SCI_INDICGETHOVERSTYLE, URL_INDIC);
2626  	if ((indicStyleCur != indicStyle) || (indicHoverStyleCur != indicHoverStyle))
2627  	{
2628  		pView->execute(SCI_INDICSETSTYLE, URL_INDIC, indicStyle);
2629  		pView->execute(SCI_INDICSETHOVERSTYLE, URL_INDIC, indicHoverStyle);
2630  		pView->execute(SCI_INDICSETALPHA, URL_INDIC, 70);
2631  		pView->execute(SCI_INDICSETFLAGS, URL_INDIC, SC_INDICFLAG_VALUEFORE);
2632  	}
2633  	intptr_t startPos = 0;
2634  	intptr_t endPos = -1;
2635  	pView->getVisibleStartAndEndPosition(&startPos, &endPos);
2636  	if (startPos >= endPos) return;
2637  	pView->execute(SCI_SETINDICATORCURRENT, URL_INDIC);
2638  	if (urlAction == urlDisable || !currentBuf->allowClickableLink())
2639  	{
2640  		pView->execute(SCI_INDICATORCLEARRANGE, startPos, endPos - startPos);
2641  		return;
2642  	}
2643  	LRESULT indicFore = pView->execute(SCI_STYLEGETFORE, STYLE_DEFAULT);
2644  	pView->execute(SCI_SETINDICATORVALUE, indicFore);
2645  	UINT cp = static_cast<UINT>(pView->execute(SCI_GETCODEPAGE));
2646  	char *encodedText = new char[endPos - startPos + 1];
2647  	pView->getText(encodedText, startPos, endPos);
2648  	TCHAR *wideText = new TCHAR[endPos - startPos + 1];
2649  	int wideTextLen = MultiByteToWideChar(cp, 0, encodedText, static_cast<int>(endPos - startPos + 1), (LPWSTR) wideText, static_cast<int>(endPos - startPos + 1)) - 1;
2650  	delete[] encodedText;
2651  	if (wideTextLen > 0)
2652  	{
2653  		int startWide = 0;
2654  		int lenWide = 0;
2655  		int startEncoded = 0;
2656  		int lenEncoded = 0;
2657  		while (true)
2658  		{
2659  			bool r = isUrl(wideText, wideTextLen, startWide, & lenWide);
2660  			if (lenWide <= 0)
2661  				break;
2662  			assert ((startWide + lenWide) <= wideTextLen);
2663  			lenEncoded = WideCharToMultiByte(cp, 0, & wideText [startWide], lenWide, NULL, 0, NULL, NULL);
2664  			if (r)
2665  				pView->execute(SCI_INDICATORFILLRANGE, startEncoded + startPos, lenEncoded);
2666  			else
2667  				pView->execute(SCI_INDICATORCLEARRANGE, startEncoded + startPos, lenEncoded);
2668  			startWide += lenWide;
2669  			startEncoded += lenEncoded;
2670  			if ((startWide >= wideTextLen) || ((startEncoded + startPos) >= endPos))
2671  				break;
2672  		}
2673  		assert ((startEncoded + startPos) == endPos);
2674  		assert (startWide == wideTextLen);
2675  	}
2676  	delete[] wideText;
2677  }
2678  bool Notepad_plus::isConditionExprLine(intptr_t lineNumber)
2679  {
2680  	if (lineNumber < 0 || lineNumber > _pEditView->execute(SCI_GETLINECOUNT))
2681  		return false;
2682  	auto startPos = _pEditView->execute(SCI_POSITIONFROMLINE, lineNumber);
2683  	auto endPos = _pEditView->execute(SCI_GETLINEENDPOSITION, lineNumber);
2684  	_pEditView->execute(SCI_SETSEARCHFLAGS, SCFIND_REGEXP | SCFIND_POSIX);
2685  	_pEditView->execute(SCI_SETTARGETRANGE, startPos, endPos);
2686  	const char ifElseForWhileExpr[] = "((else[ \t]+)?if|for|while)[ \t]*[(].*[)][ \t]*|else[ \t]*";
2687  	auto posFound = _pEditView->execute(SCI_SEARCHINTARGET, strlen(ifElseForWhileExpr), reinterpret_cast<LPARAM>(ifElseForWhileExpr));
2688  	if (posFound >= 0)
2689  	{
2690  		auto end = _pEditView->execute(SCI_GETTARGETEND);
2691  		if (end == endPos)
2692  			return true;
2693  	}
2694  	return false;
2695  }
2696  intptr_t Notepad_plus::findMachedBracePos(size_t startPos, size_t endPos, char targetSymbol, char matchedSymbol)
2697  {
2698  	if (startPos == endPos)
2699  		return -1;
2700  	if (startPos > endPos) 
2701  	{
2702  		int balance = 0;
2703  		for (intptr_t i = startPos; i >= static_cast<intptr_t>(endPos); --i)
2704  		{
2705  			char aChar = static_cast<char>(_pEditView->execute(SCI_GETCHARAT, i));
2706  			if (aChar == targetSymbol)
2707  			{
2708  				if (balance == 0)
2709  					return i;
2710  				--balance;
2711  			}
2712  			else if (aChar == matchedSymbol)
2713  			{
2714  				++balance;
2715  			}
2716  		}
2717  	}
2718  	else 
2719  	{
2720  	}
2721  	return -1;
2722  }
2723  void Notepad_plus::maintainIndentation(TCHAR ch)
2724  {
2725  	intptr_t eolMode = _pEditView->execute(SCI_GETEOLMODE);
2726  	intptr_t curLine = _pEditView->getCurrentLineNumber();
2727  	intptr_t prevLine = curLine - 1;
2728  	intptr_t indentAmountPrevLine = 0;
2729  	intptr_t tabWidth = _pEditView->execute(SCI_GETTABWIDTH);
2730  	LangType type = _pEditView->getCurrentBuffer()->getLangType();
2731  	ExternalLexerAutoIndentMode autoIndentMode = ExternalLexerAutoIndentMode::Standard;
2732  	if (type >= L_EXTERNAL)
2733  	{
2734  		NppParameters& nppParam = NppParameters::getInstance();
2735  		autoIndentMode = nppParam.getELCFromIndex(type - L_EXTERNAL)._autoIndentMode;
2736  		if (autoIndentMode == ExternalLexerAutoIndentMode::Custom)
2737  			return;
2738  	}
2739  	if ((((eolMode == SC_EOL_CRLF || eolMode == SC_EOL_LF) && ch == '\n') ||
2740  		(eolMode == SC_EOL_CR && ch == '\r')) && prevLine >= 0 && _pEditView->getLineLength(prevLine) == 0)
2741  		return;
2742  	if (type == L_C || type == L_CPP || type == L_JAVA || type == L_CS || type == L_OBJC ||
2743  		type == L_PHP || type == L_JS || type == L_JAVASCRIPT || type == L_JSP || type == L_CSS || type == L_PERL || 
2744  		type == L_RUST || type == L_POWERSHELL || type == L_JSON || type == L_JSON5 || autoIndentMode == ExternalLexerAutoIndentMode::C_Like)
2745  	{
2746  		if (((eolMode == SC_EOL_CRLF || eolMode == SC_EOL_LF) && ch == '\n') ||
2747  			(eolMode == SC_EOL_CR && ch == '\r'))
2748  		{
2749  			while (prevLine >= 0 && _pEditView->getLineLength(prevLine) == 0)
2750  				prevLine--;
2751  			if (prevLine >= 0)
2752  			{
2753  				indentAmountPrevLine = _pEditView->getLineIndent(prevLine);
2754  			}
2755  			intptr_t prevPos = _pEditView->execute(SCI_GETCURRENTPOS) - (eolMode == SC_EOL_CRLF ? 3 : 2);
2756  			UCHAR prevChar = (UCHAR)_pEditView->execute(SCI_GETCHARAT, prevPos);
2757  			auto curPos = _pEditView->execute(SCI_GETCURRENTPOS);
2758  			UCHAR nextChar = (UCHAR)_pEditView->execute(SCI_GETCHARAT, curPos);
2759  			if (prevChar == '{')
2760  			{
2761  				if (nextChar == '}')
2762  				{
2763  					const char *eolChars;
2764  					if (eolMode == SC_EOL_CRLF)
2765  						eolChars = "\r\n";
2766  					else if (eolMode == SC_EOL_LF)
2767  						eolChars = "\n";
2768  					else
2769  						eolChars = "\r";
2770  					_pEditView->execute(SCI_INSERTTEXT, _pEditView->execute(SCI_GETCURRENTPOS), reinterpret_cast<LPARAM>(eolChars));
2771  					_pEditView->setLineIndent(curLine + 1, indentAmountPrevLine);
2772  				}
2773  				_pEditView->setLineIndent(curLine, indentAmountPrevLine + tabWidth);
2774  			}
2775  			else if (nextChar == '{')
2776  			{
2777  				_pEditView->setLineIndent(curLine, indentAmountPrevLine);
2778  			}
2779  			else if (type == L_PERL || type == L_RUST || type == L_POWERSHELL || type == L_JSON || type == L_JSON5)
2780  			{
2781  				_pEditView->setLineIndent(curLine, indentAmountPrevLine);
2782  			}
2783  			else if (isConditionExprLine(prevLine))
2784  			{
2785  				_pEditView->setLineIndent(curLine, indentAmountPrevLine + tabWidth);
2786  			}
2787  			else
2788  			{
2789  				if (indentAmountPrevLine > 0)
2790  				{
2791  					if (prevLine > 0 && isConditionExprLine(prevLine - 1))
2792  						_pEditView->setLineIndent(curLine, indentAmountPrevLine - tabWidth);
2793  					else
2794  						_pEditView->setLineIndent(curLine, indentAmountPrevLine);
2795  				}
2796  			}
2797  		}
2798  		else if (ch == '{')
2799  		{
2800  			auto startPos = _pEditView->execute(SCI_POSITIONFROMLINE, curLine);
2801  			LRESULT endPos = _pEditView->execute(SCI_GETCURRENTPOS);
2802  			for (LRESULT i = endPos - 2; i > 0 && i > startPos; --i)
2803  			{
2804  				UCHAR aChar = (UCHAR)_pEditView->execute(SCI_GETCHARAT, i);
2805  				if (aChar != ' ' && aChar != '\t')
2806  					return;
2807  			}
2808  			while (prevLine >= 0 && _pEditView->getLineLength(prevLine) == 0)
2809  				prevLine--;
2810  			if (prevLine >= 0)
2811  			{
2812  				indentAmountPrevLine = _pEditView->getLineIndent(prevLine);
2813  				auto startPos2 = _pEditView->execute(SCI_POSITIONFROMLINE, prevLine);
2814  				auto endPos2 = _pEditView->execute(SCI_GETLINEENDPOSITION, prevLine);
2815  				_pEditView->execute(SCI_SETSEARCHFLAGS, SCFIND_REGEXP | SCFIND_POSIX);
2816  				_pEditView->execute(SCI_SETTARGETRANGE, startPos2, endPos2);
2817  				const char braceExpr[] = "[ \t]*\\{.*";
2818  				intptr_t posFound = _pEditView->execute(SCI_SEARCHINTARGET, strlen(braceExpr), reinterpret_cast<LPARAM>(braceExpr));
2819  				if (posFound >= 0)
2820  				{
2821  					auto end = _pEditView->execute(SCI_GETTARGETEND);
2822  					if (end == endPos2)
2823  						indentAmountPrevLine += tabWidth;
2824  				}
2825  			}
2826  			_pEditView->setLineIndent(curLine, indentAmountPrevLine);
2827  		}
2828  		else if (ch == '}')
2829  		{
2830  			intptr_t startPos = _pEditView->execute(SCI_GETCURRENTPOS);
2831  			if (startPos != 0)
2832  				startPos -= 1;
2833  			intptr_t posFound = findMachedBracePos(startPos - 1, 0, '{', '}');
2834  			if (posFound == -1)
2835  				return;
2836  			intptr_t matchedPairLine = _pEditView->execute(SCI_LINEFROMPOSITION, posFound);
2837  			if (matchedPairLine == curLine)
2838  				return;
2839  			indentAmountPrevLine = _pEditView->getLineIndent(matchedPairLine);
2840  			_pEditView->setLineIndent(curLine, indentAmountPrevLine);
2841  		}
2842  	}
2843  	else 
2844  	{
2845  		if (((eolMode == SC_EOL_CRLF || eolMode == SC_EOL_LF) && ch == '\n') ||
2846  			(eolMode == SC_EOL_CR && ch == '\r'))
2847  		{
2848  			while (prevLine >= 0 && _pEditView->getLineLength(prevLine) == 0)
2849  				prevLine--;
2850  			if (prevLine >= 0)
2851  			{
2852  				indentAmountPrevLine = _pEditView->getLineIndent(prevLine);
2853  			}
2854  			if (indentAmountPrevLine > 0)
2855  			{
2856  				_pEditView->setLineIndent(curLine, indentAmountPrevLine);
2857  			}
2858  		}
2859  	}
2860  }
2861  BOOL Notepad_plus::processFindAccel(MSG *msg) const
2862  {
2863  	if (!::IsChild(_findReplaceDlg.getHSelf(), ::GetFocus()))
2864  		return FALSE;
2865  	return ::TranslateAccelerator(_findReplaceDlg.getHSelf(), _accelerator.getFindAccTable(), msg);
2866  }
2867  BOOL Notepad_plus::processIncrFindAccel(MSG *msg) const
2868  {
2869  	if (!::IsChild(_incrementFindDlg.getHSelf(), ::GetFocus()))
2870  		return FALSE;
2871  	return ::TranslateAccelerator(_incrementFindDlg.getHSelf(), _accelerator.getIncrFindAccTable(), msg);
2872  }
2873  void Notepad_plus::setLanguage(LangType langType)
2874  {
2875  	bool reset = false;
2876  	Document prev = 0;
2877  	if (bothActive())
2878  	{
2879  		if (_mainEditView.getCurrentBufferID() == _subEditView.getCurrentBufferID())
2880  		{
2881  			reset = true;
2882  			_subEditView.saveCurrentPos();
2883  			prev = _subEditView.execute(SCI_GETDOCPOINTER);
2884  			_subEditView.execute(SCI_SETDOCPOINTER, 0, 0);
2885  		}
2886  	}
2887  	if (reset)
2888  	{
2889  		_mainEditView.getCurrentBuffer()->setLangType(langType);
2890  	}
2891  	else
2892  	{
2893  		_pEditView->getCurrentBuffer()->setLangType(langType);
2894  	}
2895  	if (reset)
2896  	{
2897  		_subEditView.execute(SCI_SETDOCPOINTER, 0, prev);
2898  		_subEditView.restoreCurrentPosPreStep();
2899  	}
2900  }
2901  LangType Notepad_plus::menuID2LangType(int cmdID)
2902  {
2903  	switch (cmdID)
2904  	{
2905          case IDM_LANG_C	:
2906              return L_C;
2907          case IDM_LANG_CPP :
2908              return L_CPP;
2909          case IDM_LANG_JAVA :
2910              return L_JAVA;
2911          case IDM_LANG_CS :
2912              return L_CS;
2913          case IDM_LANG_HTML :
2914              return L_HTML;
2915          case IDM_LANG_XML :
2916              return L_XML;
2917          case IDM_LANG_JS :
2918  			return L_JAVASCRIPT;
2919  		case IDM_LANG_JSON:
2920  			return L_JSON;
2921  		case IDM_LANG_JSON5:
2922  			return L_JSON5;
2923          case IDM_LANG_PHP :
2924              return L_PHP;
2925          case IDM_LANG_ASP :
2926              return L_ASP;
2927          case IDM_LANG_JSP :
2928              return L_JSP;
2929          case IDM_LANG_CSS :
2930              return L_CSS;
2931          case IDM_LANG_LUA :
2932              return L_LUA;
2933          case IDM_LANG_PERL :
2934              return L_PERL;
2935          case IDM_LANG_PYTHON :
2936              return L_PYTHON;
2937          case IDM_LANG_PASCAL :
2938              return L_PASCAL;
2939          case IDM_LANG_BATCH :
2940              return L_BATCH;
2941          case IDM_LANG_OBJC :
2942              return L_OBJC;
2943          case IDM_LANG_VB :
2944              return L_VB;
2945          case IDM_LANG_SQL :
2946              return L_SQL;
2947          case IDM_LANG_MSSQL :
2948              return L_MSSQL;
2949          case IDM_LANG_ASCII :
2950              return L_ASCII;
2951          case IDM_LANG_TEXT :
2952              return L_TEXT;
2953          case IDM_LANG_RC :
2954              return L_RC;
2955          case IDM_LANG_MAKEFILE :
2956              return L_MAKEFILE;
2957          case IDM_LANG_INI :
2958              return L_INI;
2959          case IDM_LANG_TEX :
2960              return L_TEX;
2961          case IDM_LANG_FORTRAN :
2962              return L_FORTRAN;
2963  		case IDM_LANG_FORTRAN_77 :
2964  			return L_FORTRAN_77;
2965          case IDM_LANG_BASH :
2966              return L_BASH;
2967          case IDM_LANG_FLASH :
2968              return L_FLASH;
2969  		case IDM_LANG_NSIS :
2970              return L_NSIS;
2971  		case IDM_LANG_TCL :
2972              return L_TCL;
2973  		case IDM_LANG_LISP :
2974  			return L_LISP;
2975  		case IDM_LANG_SCHEME :
2976  			return L_SCHEME;
2977  		case IDM_LANG_ASM :
2978              return L_ASM;
2979  		case IDM_LANG_DIFF :
2980              return L_DIFF;
2981  		case IDM_LANG_PROPS :
2982              return L_PROPS;
2983  		case IDM_LANG_PS:
2984              return L_PS;
2985  		case IDM_LANG_RUBY:
2986              return L_RUBY;
2987  		case IDM_LANG_SMALLTALK:
2988              return L_SMALLTALK;
2989  		case IDM_LANG_VHDL :
2990              return L_VHDL;
2991          case IDM_LANG_KIX :
2992              return L_KIX;
2993          case IDM_LANG_CAML :
2994              return L_CAML;
2995          case IDM_LANG_ADA :
2996              return L_ADA;
2997          case IDM_LANG_VERILOG :
2998              return L_VERILOG;
2999  		case IDM_LANG_MATLAB :
3000              return L_MATLAB;
3001  		case IDM_LANG_HASKELL :
3002              return L_HASKELL;
3003          case IDM_LANG_AU3 :
3004              return L_AU3;
3005  		case IDM_LANG_INNO :
3006              return L_INNO;
3007  		case IDM_LANG_CMAKE :
3008              return L_CMAKE;
3009  		case IDM_LANG_YAML :
3010  			return L_YAML;
3011          case IDM_LANG_COBOL :
3012              return L_COBOL;
3013          case IDM_LANG_D :
3014              return L_D;
3015          case IDM_LANG_GUI4CLI :
3016              return L_GUI4CLI;
3017          case IDM_LANG_POWERSHELL :
3018              return L_POWERSHELL;
3019          case IDM_LANG_R :
3020              return L_R;
3021  		case IDM_LANG_COFFEESCRIPT :
3022              return L_COFFEESCRIPT;
3023  		case IDM_LANG_BAANC:
3024  			return L_BAANC;
3025  		case IDM_LANG_SREC :
3026              return L_SREC;
3027  		case IDM_LANG_IHEX :
3028              return L_IHEX;
3029  		case IDM_LANG_TEHEX :
3030              return L_TEHEX;
3031  		case IDM_LANG_SWIFT:
3032  			return L_SWIFT;
3033          case IDM_LANG_ASN1 :
3034              return L_ASN1;
3035          case IDM_LANG_AVS :
3036              return L_AVS;
3037          case IDM_LANG_BLITZBASIC :
3038              return L_BLITZBASIC;
3039          case IDM_LANG_PUREBASIC :
3040              return L_PUREBASIC;
3041          case IDM_LANG_FREEBASIC :
3042              return L_FREEBASIC;
3043          case IDM_LANG_CSOUND :
3044              return L_CSOUND;
3045          case IDM_LANG_ERLANG :
3046              return L_ERLANG;
3047          case IDM_LANG_ESCRIPT :
3048              return L_ESCRIPT;
3049          case IDM_LANG_FORTH :
3050              return L_FORTH;
3051          case IDM_LANG_LATEX :
3052              return L_LATEX;
3053          case IDM_LANG_MMIXAL :
3054              return L_MMIXAL;
3055          case IDM_LANG_NIM :
3056              return L_NIM;
3057          case IDM_LANG_NNCRONTAB :
3058              return L_NNCRONTAB;
3059          case IDM_LANG_OSCRIPT :
3060              return L_OSCRIPT;
3061          case IDM_LANG_REBOL :
3062              return L_REBOL;
3063          case IDM_LANG_REGISTRY :
3064              return L_REGISTRY;
3065          case IDM_LANG_RUST :
3066              return L_RUST;
3067          case IDM_LANG_SPICE :
3068              return L_SPICE;
3069          case IDM_LANG_TXT2TAGS :
3070              return L_TXT2TAGS;
3071          case IDM_LANG_VISUALPROLOG:
3072              return L_VISUALPROLOG;
3073          case IDM_LANG_TYPESCRIPT:
3074              return L_TYPESCRIPT;
3075          case IDM_LANG_GDSCRIPT:
3076              return L_GDSCRIPT;
3077          case IDM_LANG_HOLLYWOOD:
3078              return L_HOLLYWOOD;	    
3079          case IDM_LANG_USER:
3080              return L_USER;
3081  		default:
3082  		{
3083  			if (cmdID >= IDM_LANG_USER && cmdID <= IDM_LANG_USER_LIMIT)
3084  			{
3085  				return L_USER;
3086  			}
3087  			break; 
3088  		}
3089  	}
3090  	return L_EXTERNAL;
3091  }
3092  void Notepad_plus::setTitle()
3093  {
3094  	NppParameters& nppParams = NppParameters::getInstance();
3095  	const NppGUI & nppGUI = nppParams.getNppGUI();
3096  	Buffer * buf = _pEditView->getCurrentBuffer();
3097  	generic_string result = TEXT("");
3098  	if (buf->isDirty())
3099  	{
3100  		result += TEXT("*");
3101  	}
3102  	if (nppGUI._shortTitlebar)
3103  	{
3104  		result += buf->getFileName();
3105  	}
3106  	else
3107  	{
3108  		result += buf->getFullPathName();
3109  	}
3110  	result += TEXT(" - ");
3111  	result += _pPublicInterface->getClassName();
3112  	if (_isAdministrator)
3113  		result += TEXT(" [Administrator]");
3114  	generic_string tbAdd = nppParams.getTitleBarAdd();
3115  	if (!tbAdd.empty())
3116  	{
3117  		result += TEXT(" - ");
3118  		result += tbAdd;
3119  	}
3120  	::SendMessage(_pPublicInterface->getHSelf(), WM_SETTEXT, 0, reinterpret_cast<LPARAM>(result.c_str()));
3121  }
3122  void Notepad_plus::activateNextDoc(bool direction)
3123  {
3124  	int nbDoc = static_cast<int32_t>(_pDocTab->nbItem());
3125      int curIndex = _pDocTab->getCurrentTabIndex();
3126      curIndex += (direction == dirUp)?-1:1;
3127  	if (curIndex >= nbDoc)
3128  	{
3129  		if (viewVisible(otherView()))
3130  			switchEditViewTo(otherView());
3131  		curIndex = 0;
3132  	}
3133  	else if (curIndex < 0)
3134  	{
3135  		if (viewVisible(otherView()))
3136  		{
3137  			switchEditViewTo(otherView());
3138  			nbDoc = static_cast<int32_t>(_pDocTab->nbItem());
3139  		}
3140  		curIndex = nbDoc - 1;
3141  	}
3142  	BufferID id = _pDocTab->getBufferByIndex(curIndex);
3143  	activateBuffer(id, currentView());
3144  }
3145  void Notepad_plus::activateDoc(size_t pos)
3146  {
3147  	size_t nbDoc = _pDocTab->nbItem();
3148  	if (pos == static_cast<size_t>(_pDocTab->getCurrentTabIndex()))
3149  	{
3150  		Buffer * buf = _pEditView->getCurrentBuffer();
3151  		buf->increaseRecentTag();
3152  		return;
3153  	}
3154  	if (pos < nbDoc)
3155  	{
3156  		BufferID id = _pDocTab->getBufferByIndex(pos);
3157  		activateBuffer(id, currentView());
3158  	}
3159  }
3160  static const char utflen[] = {1,1,2,3};
3161  size_t Notepad_plus::getSelectedCharNumber(UniMode u)
3162  {
3163  	size_t result = 0;
3164  	size_t numSel = _pEditView->execute(SCI_GETSELECTIONS);
3165  	if (u == uniUTF8 || u == uniCookie)
3166  	{
3167  		for (size_t i = 0; i < numSel; ++i)
3168  		{
3169  			size_t line1 = _pEditView->execute(SCI_LINEFROMPOSITION, _pEditView->execute(SCI_GETSELECTIONNSTART, i));
3170  			size_t line2 = _pEditView->execute(SCI_LINEFROMPOSITION, _pEditView->execute(SCI_GETSELECTIONNEND, i));
3171  			for (size_t j = line1; j <= line2; ++j)
3172  			{
3173  				size_t stpos = _pEditView->execute(SCI_GETLINESELSTARTPOSITION, j);
3174  				if (static_cast<intptr_t>(stpos) != INVALID_POSITION)
3175  				{
3176  					size_t endpos = _pEditView->execute(SCI_GETLINESELENDPOSITION, j);
3177  					for (size_t pos = stpos; pos < endpos; ++pos)
3178  					{
3179  						unsigned char c = 0xf0 & static_cast<unsigned char>(_pEditView->execute(SCI_GETCHARAT, pos));
3180  						if (c >= 0xc0)
3181  							pos += utflen[(c & 0x30) >>  4];
3182  						++result;
3183  					}
3184  				}
3185  			}
3186  		}
3187  	}
3188  	else
3189  	{
3190  		for (size_t i = 0; i < numSel; ++i)
3191  		{
3192  			size_t stpos = _pEditView->execute(SCI_GETSELECTIONNSTART, i);
3193  			size_t endpos = _pEditView->execute(SCI_GETSELECTIONNEND, i);
3194  			result += (endpos - stpos);
3195  			size_t line1 = _pEditView->execute(SCI_LINEFROMPOSITION, stpos);
3196  			size_t line2 = _pEditView->execute(SCI_LINEFROMPOSITION, endpos);
3197  			line2 -= line1;
3198  			if (_pEditView->execute(SCI_GETEOLMODE) == SC_EOL_CRLF) line2 *= 2;
3199  			result -= line2;
3200  		}
3201  		if (u != uni8Bit && u != uni7Bit) result *= 2;
3202  	}
3203  	return result;
3204  }
3205  #ifdef _OPENMP
3206  #include <omp.h>
3207  #endif
3208  static inline size_t countUtf8Characters(unsigned char *buf, size_t pos, size_t endpos)
3209  {
3210  	size_t result = 0;
3211  	while (pos < endpos)
3212  	{
3213  		unsigned char c = buf[pos++];
3214  		if ((c&0xc0) == 0x80 
3215  			|| c == '\n' || c == '\r') continue; 
3216  		if (c >= 0xc0) 
3217  			pos += utflen[(c & 0x30) >>  4];
3218  		++result;
3219  	}
3220  	return result;
3221  }
3222  size_t Notepad_plus::getCurrentDocCharCount(UniMode u)
3223  {
3224  	if (u != uniUTF8 && u != uniCookie)
3225  	{
3226  		size_t numLines = _pEditView->execute(SCI_GETLINECOUNT);
3227  		auto result = _pEditView->execute(SCI_GETLENGTH);
3228  		size_t lines = numLines==0?0:numLines-1;
3229  		if (_pEditView->execute(SCI_GETEOLMODE) == SC_EOL_CRLF) lines *= 2;
3230  		result -= lines;
3231  		return (result < 0) ? 0 : result;
3232  	}
3233   	else
3234   	{
3235  		size_t result = 0;
3236  		size_t endpos = _pEditView->execute(SCI_GETLENGTH);
3237  		unsigned char* buf = (unsigned char*)_pEditView->execute(SCI_GETCHARACTERPOINTER); 
3238  #ifdef _OPENMP 
3239  		if (endpos > 50000) 
3240  		{
3241  			#pragma omp parallel reduction(+: result)
3242  			{
3243  				unsigned int num_threads = omp_get_num_threads();
3244  				unsigned int thread_num = omp_get_thread_num();
3245  				size_t chunk_size = endpos/num_threads;
3246  				size_t pos = chunk_size*thread_num;
3247  				size_t endpos_local = (thread_num == num_threads-1) ? endpos : pos+chunk_size;
3248  				result = countUtf8Characters(buf, pos, endpos_local);
3249  			}
3250  		}
3251  		else
3252  #endif
3253  		{
3254  			result = countUtf8Characters(buf, 0, endpos);
3255  		}
3256   		return result;
3257   	}
3258  }
3259  bool Notepad_plus::isFormatUnicode(UniMode u)
3260  {
3261  	return (u != uni8Bit && u != uni7Bit && u != uniUTF8 && u != uniCookie);
3262  }
3263  int Notepad_plus::getBOMSize(UniMode u)
3264  {
3265  	switch(u)
3266  	{
3267  		case uni16LE:
3268  		case uni16BE:
3269  			return 2;
3270  		case uniUTF8:
3271  			return 3;
3272  		default:
3273  			return 0;
3274  	}
3275  }
3276  size_t Notepad_plus::getSelectedAreas()
3277  {
3278  	size_t numSel = _pEditView->execute(SCI_GETSELECTIONS);
3279  	if (numSel == 1) 
3280  		return (_pEditView->execute(SCI_GETSELECTIONNSTART, 0) == _pEditView->execute(SCI_GETSELECTIONNEND, 0)) ? 0 : 1;
3281  	return (_pEditView->execute(SCI_SELECTIONISRECTANGLE)) ? 1 : numSel;
3282  }
3283  size_t Notepad_plus::getSelectedBytes()
3284  {
3285  	size_t numSel = _pEditView->execute(SCI_GETSELECTIONS);
3286  	size_t result = 0;
3287  	for (size_t i = 0; i < numSel; ++i)
3288  		result += (_pEditView->execute(SCI_GETSELECTIONNEND, i) - _pEditView->execute(SCI_GETSELECTIONNSTART, i));
3289  	return result;
3290  }
3291  int Notepad_plus::wordCount()
3292  {
3293      FindOption env;
3294      env._str2Search = TEXT("[^ 	\\\\.,;:!?()+\\r\\n\\-\\*/=\\]\\[{}&~\"'`|@$%<>\\^]+");
3295      env._searchType = FindRegex;
3296      return _findReplaceDlg.processAll(ProcessCountAll, &env, true);
3297  }
3298  void Notepad_plus::updateStatusBar()
3299  {
3300  	TCHAR strDocLen[256];
3301  	size_t docLen = _pEditView->getCurrentDocLen();
3302  	intptr_t nbLine = _pEditView->execute(SCI_GETLINECOUNT);
3303  	wsprintf(strDocLen, TEXT("length : %s    lines : %s"),
3304  		commafyInt(docLen).c_str(),
3305  		commafyInt(nbLine).c_str());
3306  	_statusBar.setText(strDocLen, STATUSBAR_DOC_SIZE);
3307  	TCHAR strSel[64];
3308  	size_t numSelections = _pEditView->execute(SCI_GETSELECTIONS);
3309  	if (numSelections == 1)
3310  	{
3311  		if (_pEditView->execute(SCI_GETSELECTIONEMPTY))
3312  		{
3313  			size_t currPos = _pEditView->execute(SCI_GETCURRENTPOS);
3314  			wsprintf(strSel, TEXT("Pos : %s"), commafyInt(currPos + 1).c_str());
3315  		}
3316  		else
3317  		{
3318  			const std::pair<size_t, size_t> oneSelCharsAndLines = _pEditView->getSelectedCharsAndLinesCount();
3319  			wsprintf(strSel, TEXT("Sel : %s | %s"),
3320  				commafyInt(oneSelCharsAndLines.first).c_str(),
3321  				commafyInt(oneSelCharsAndLines.second).c_str());
3322  		}
3323  	}
3324  	else if (_pEditView->execute(SCI_SELECTIONISRECTANGLE))
3325  	{
3326  		const std::pair<size_t, size_t> rectSelCharsAndLines = _pEditView->getSelectedCharsAndLinesCount();
3327  		bool sameCharCountOnEveryLine = true;
3328  		size_t maxLineCharCount = 0;
3329  		for (size_t sel = 0; sel < numSelections; ++sel)
3330  		{
3331  			size_t start = _pEditView->execute(SCI_GETSELECTIONNSTART, sel);
3332  			size_t end = _pEditView->execute(SCI_GETSELECTIONNEND, sel);
3333  			size_t lineCharCount = _pEditView->execute(SCI_COUNTCHARACTERS, start, end);
3334  			if (sel == 0)
3335  			{
3336  				maxLineCharCount = lineCharCount;
3337  			}
3338  			else 
3339  			{
3340  				if (lineCharCount != maxLineCharCount)
3341  				{
3342  					sameCharCountOnEveryLine = false;
3343  					if (lineCharCount > maxLineCharCount)
3344  					{
3345  						maxLineCharCount = lineCharCount;
3346  					}
3347  				}
3348  			}
3349  		}
3350  		wsprintf(strSel, TEXT("Sel : %sx%s %s %s"),
3351  			commafyInt(numSelections).c_str(),  
3352  			commafyInt(maxLineCharCount).c_str(),  
3353  			sameCharCountOnEveryLine ? TEXT("=") : TEXT("->"),
3354  			commafyInt(rectSelCharsAndLines.first).c_str());
3355  	}
3356  	else  
3357  	{
3358  		const int maxSelsToProcessLineCount = 99;  
3359  		const std::pair<size_t, size_t> multipleSelCharsAndLines = _pEditView->getSelectedCharsAndLinesCount(maxSelsToProcessLineCount);
3360  		wsprintf(strSel, TEXT("Sel %s : %s | %s"),
3361  			commafyInt(numSelections).c_str(),
3362  			commafyInt(multipleSelCharsAndLines.first).c_str(),
3363  			numSelections <= maxSelsToProcessLineCount ?
3364  				commafyInt(multipleSelCharsAndLines.second).c_str() :
3365  				TEXT("..."));  
3366  	}
3367  	TCHAR strLnColSel[128];
3368  	intptr_t curLN = _pEditView->getCurrentLineNumber();
3369  	intptr_t curCN = _pEditView->getCurrentColumnNumber();
3370  	wsprintf(strLnColSel, TEXT("Ln : %s    Col : %s    %s"),
3371  		commafyInt(curLN + 1).c_str(),
3372  		commafyInt(curCN + 1).c_str(),
3373  		strSel);
3374  	_statusBar.setText(strLnColSel, STATUSBAR_CUR_POS);
3375  	_statusBar.setText(_pEditView->execute(SCI_GETOVERTYPE) ? TEXT("OVR") : TEXT("INS"), STATUSBAR_TYPING_MODE);
3376  	if (_goToLineDlg.isCreated() && _goToLineDlg.isVisible())
3377  	{
3378  		_goToLineDlg.updateLinesNumbers();
3379  	}
3380  }
3381  void Notepad_plus::dropFiles(HDROP hdrop)
3382  {
3383  	if (hdrop)
3384  	{
3385  		POINT p;
3386  		::DragQueryPoint(hdrop, &p);
3387  		HWND hWin = ::ChildWindowFromPointEx(_pPublicInterface->getHSelf(), p, CWP_SKIPINVISIBLE);
3388  		if (!hWin) return;
3389  		if ((_subEditView.getHSelf() == hWin) || (_subDocTab.getHSelf() == hWin))
3390  			switchEditViewTo(SUB_VIEW);
3391  		else
3392  			switchEditViewTo(MAIN_VIEW);
3393  		int filesDropped = ::DragQueryFile(hdrop, 0xffffffff, NULL, 0);
3394  		vector<generic_string> folderPaths;
3395  		vector<generic_string> filePaths;
3396  		for (int i = 0; i < filesDropped; ++i)
3397  		{
3398  			TCHAR pathDropped[MAX_PATH];
3399  			::DragQueryFile(hdrop, i, pathDropped, MAX_PATH);
3400  			if (::PathIsDirectory(pathDropped))
3401  			{
3402  				size_t len = lstrlen(pathDropped);
3403  				if (len > 0 && pathDropped[len - 1] != TCHAR('\\'))
3404  				{
3405  					pathDropped[len] = TCHAR('\\');
3406  					pathDropped[len + 1] = TCHAR('\0');
3407  				}
3408  				folderPaths.push_back(pathDropped);
3409  			}
3410  			else
3411  			{
3412  				filePaths.push_back(pathDropped);
3413  			}
3414  		}
3415  		NppParameters& nppParam = NppParameters::getInstance();
3416  		bool isOldMode = nppParam.getNppGUI()._isFolderDroppedOpenFiles;
3417  		if (isOldMode || folderPaths.size() == 0) 
3418  		{
3419  			BufferID lastOpened = BUFFER_INVALID;
3420  			for (int i = 0; i < filesDropped; ++i)
3421  			{
3422  				TCHAR pathDropped[MAX_PATH];
3423  				::DragQueryFile(hdrop, i, pathDropped, MAX_PATH);
3424  				BufferID test = doOpen(pathDropped);
3425  				if (test != BUFFER_INVALID)
3426  					lastOpened = test;
3427  			}
3428  			if (lastOpened != BUFFER_INVALID)
3429  			{
3430  				switchToFile(lastOpened);
3431  			}
3432  		}
3433  		else if (!isOldMode && (folderPaths.size() != 0 && filePaths.size() != 0)) 
3434  		{
3435  			_nativeLangSpeaker.messageBox("DroppingFolderAsProjectModeWarning",
3436  				_pPublicInterface->getHSelf(),
3437  				TEXT("You can only drop files or folders but not both, because you're in dropping Folder as Project mode.\ryou have to enable \"Open all files of folder instead of launching Folder as Workspace on folder dropping\" in \"Default Directory\" section of Preferences dialog to make this operation work."),
3438  				TEXT("Invalid action"),
3439  				MB_OK | MB_APPLMODAL);
3440  		}
3441  		else if (!isOldMode && (folderPaths.size() != 0 && filePaths.size() == 0)) 
3442  		{
3443  			generic_string emptyStr;
3444  			launchFileBrowser(folderPaths, emptyStr);
3445  		}
3446  		::DragFinish(hdrop);
3447  		if (::IsIconic(_pPublicInterface->getHSelf()))
3448  		{
3449  			::ShowWindow(_pPublicInterface->getHSelf(), SW_RESTORE);
3450  		}
3451  		::SetForegroundWindow(_pPublicInterface->getHSelf());
3452  	}
3453  }
3454  void Notepad_plus::checkModifiedDocument(bool bCheckOnlyCurrentBuffer)
3455  {
3456  	MainFileManager.checkFilesystemChanges(bCheckOnlyCurrentBuffer);
3457  }
3458  void Notepad_plus::getMainClientRect(RECT &rc) const
3459  {
3460      _pPublicInterface->getClientRect(rc);
3461  	rc.top += _rebarTop.getHeight();
3462  	rc.bottom -= rc.top + _rebarBottom.getHeight() + _statusBar.getHeight();
3463  }
3464  void Notepad_plus::showView(int whichOne)
3465  {
3466  	if (viewVisible(whichOne))	
3467  		return;
3468  	if (_mainWindowStatus & WindowUserActive)
3469  	{
3470  		 _pMainSplitter->setWin0(&_subSplitter);
3471  		 _pMainWindow = _pMainSplitter;
3472  	}
3473  	else
3474  	{
3475  		_pMainWindow = &_subSplitter;
3476  	}
3477  	if (whichOne == MAIN_VIEW)
3478  	{
3479  		_mainEditView.display(true);
3480  		_mainDocTab.display(true);
3481  	}
3482  	else if (whichOne == SUB_VIEW)
3483  	{
3484  		_subEditView.display(true);
3485  		_subDocTab.display(true);
3486  	}
3487  	_pMainWindow->display(true);
3488  	_mainWindowStatus |= (whichOne==MAIN_VIEW)?WindowMainActive:WindowSubActive;
3489  	::SendMessage(_pPublicInterface->getHSelf(), WM_SIZE, 0, 0);
3490  }
3491  bool Notepad_plus::viewVisible(int whichOne)
3492  {
3493  	int viewToCheck = (whichOne == SUB_VIEW?WindowSubActive:WindowMainActive);
3494  	return (_mainWindowStatus & viewToCheck) != 0;
3495  }
3496  void Notepad_plus::hideCurrentView()
3497  {
3498  	hideView(currentView());
3499  }
3500  void Notepad_plus::hideView(int whichOne)
3501  {
3502  	if (!(bothActive()))	
3503  		return;
3504  	Window * windowToSet = (whichOne == MAIN_VIEW)?&_subDocTab:&_mainDocTab;
3505  	if ((_mainWindowStatus & WindowUserActive) == WindowUserActive)
3506  	{
3507  		_pMainSplitter->setWin0(windowToSet);
3508  	}
3509  	else
3510  	{
3511  		_pMainWindow = windowToSet;
3512  	}
3513  	_subSplitter.display(false);	
3514  	if (whichOne == MAIN_VIEW)
3515  	{
3516  		_mainEditView.display(false);
3517  		_mainDocTab.display(false);
3518  	}
3519  	else if (whichOne == SUB_VIEW)
3520  	{
3521  		_subEditView.display(false);
3522  		_subDocTab.display(false);
3523  	}
3524  	::SendMessage(_pPublicInterface->getHSelf(), WM_SIZE, 0, 0);
3525  	switchEditViewTo(otherFromView(whichOne));
3526  	auto viewToDisable = static_cast<UCHAR>(whichOne == SUB_VIEW ? WindowSubActive : WindowMainActive);
3527  	_mainWindowStatus &= ~viewToDisable;
3528  }
3529  bool Notepad_plus::loadStyles()
3530  {
3531  	NppParameters& nppParam = NppParameters::getInstance();
3532  	return nppParam.reloadStylers();
3533  }
3534  bool Notepad_plus::canHideView(int whichOne)
3535  {
3536  	if (!viewVisible(whichOne))
3537  		return false;	
3538  	if (!bothActive())
3539  		return false;	
3540  	DocTabView * tabToCheck = (whichOne == MAIN_VIEW)?&_mainDocTab:&_subDocTab;
3541  	Buffer * buf = MainFileManager.getBufferByID(tabToCheck->getBufferByIndex(0));
3542  	bool canHide = ((tabToCheck->nbItem() == 1) && !buf->isDirty() && buf->isUntitled());
3543  	return canHide;
3544  }
3545  bool Notepad_plus::isEmpty()
3546  {
3547  	if (bothActive()) return false;
3548  	DocTabView * tabToCheck = (_mainWindowStatus & WindowMainActive) ? &_mainDocTab : &_subDocTab;
<span onclick='openModal()' class='match'>3549  	Buffer * buf = MainFileManager.getBufferByID(tabToCheck->getBufferByIndex(0));
3550  	bool isEmpty = ((tabToCheck->nbItem() == 1) && !buf->isDirty() && buf->isUntitled());
3551  	return isEmpty;
3552  }
3553  void Notepad_plus::loadBufferIntoView(BufferID id, int whichOne, bool dontClose)
</span>3554  {
3555  	DocTabView * tabToOpen = (whichOne == MAIN_VIEW)?&_mainDocTab:&_subDocTab;
3556  	ScintillaEditView * viewToOpen = (whichOne == MAIN_VIEW)?&_mainEditView:&_subEditView;
3557  	int index = tabToOpen->getIndexByBuffer(id);
3558  	if (index != -1)	
3559  		return;
3560  	BufferID idToClose = BUFFER_INVALID;
3561  	if (!dontClose && tabToOpen->nbItem() == 1)
3562  	{
3563  		idToClose = tabToOpen->getBufferByIndex(0);
3564  		Buffer * buf = MainFileManager.getBufferByID(idToClose);
3565  		if (buf->isDirty() || !buf->isUntitled())
3566  		{
3567  			idToClose = BUFFER_INVALID;
3568  		}
3569  	}
3570  	MainFileManager.addBufferReference(id, viewToOpen);
3571  	if (idToClose != BUFFER_INVALID)
3572  	{
3573  		tabToOpen->setBuffer(0, id);	
3574  		activateBuffer(id, whichOne);	
3575  		MainFileManager.closeBuffer(idToClose, viewToOpen);	
3576  		if (_pDocumentListPanel)
3577  			_pDocumentListPanel->closeItem(idToClose, whichOne);
3578  	}
3579  	else
3580  	{
3581  		tabToOpen->addBuffer(id);
3582  	}
3583  }
3584  bool Notepad_plus::removeBufferFromView(BufferID id, int whichOne)
3585  {
3586  	DocTabView * tabToClose = (whichOne == MAIN_VIEW) ? &_mainDocTab : &_subDocTab;
3587  	ScintillaEditView * viewToClose = (whichOne == MAIN_VIEW) ? &_mainEditView : &_subEditView;
3588  	int index = tabToClose->getIndexByBuffer(id);
3589  	if (index == -1)        
3590  		return false;
3591  	Buffer * buf = MainFileManager.getBufferByID(id);
3592  	if (tabToClose->nbItem() == 1)
3593  	{
3594  		if (!buf->isDirty() && buf->isUntitled())
3595  		{
3596  			return false;
3597  		}
3598  	}
3599  	int active = tabToClose->getCurrentTabIndex();
3600  	if (active == index) 
3601  	{
3602  		if (tabToClose->nbItem() == 1)  
3603  		{
3604  			BufferID newID = MainFileManager.newEmptyDocument();
3605  			MainFileManager.addBufferReference(newID, viewToClose);
3606  			tabToClose->setBuffer(0, newID);        
3607  			activateBuffer(newID, whichOne);        
3608  		}
3609  		else
3610  		{
3611  			int toActivate = 0;
3612  			if (size_t(active) == tabToClose->nbItem() - 1) 
3613  			{
3614  				toActivate = active - 1;
3615  			}
3616  			else
3617  			{
3618  				toActivate = active;    
3619  			}
3620  			if (NppParameters::getInstance().getNppGUI()._styleMRU)
3621  			{
3622  				TaskListInfo taskListInfo;
3623  				::SendMessage(_pPublicInterface->getHSelf(), WM_GETTASKLISTINFO, reinterpret_cast<WPARAM>(&taskListInfo), 0);
3624  				size_t i, n = taskListInfo._tlfsLst.size();
3625  				for (i = 0; i < n; i++)
3626  				{
3627  					TaskLstFnStatus& tfs = taskListInfo._tlfsLst[i];
3628  					if (tfs._iView != whichOne || tfs._bufID == id)
3629  						continue;
3630  					toActivate = tfs._docIndex >= active ? tfs._docIndex - 1 : tfs._docIndex;
3631  					break;
3632  				}
3633  			}
3634  			tabToClose->deletItemAt((size_t)index); 
3635  			_isFolding = true; 
3636  			activateBuffer(tabToClose->getBufferByIndex(toActivate), whichOne);     
3637  			_isFolding = false;
3638  		}
3639  	}
3640  	else
3641  	{
3642  		tabToClose->deletItemAt((size_t)index);
3643  	}
3644  	MainFileManager.closeBuffer(id, viewToClose);
3645  	return true;
3646  }
3647  int Notepad_plus::switchEditViewTo(int gid)
3648  {
3649  	if (currentView() == gid)
3650  	{
3651  		_pEditView->getFocus();	
3652  		return gid;
3653  	}
3654  	if (!viewVisible(gid))
3655  		return currentView();	
3656  	int oldView = currentView();
3657  	int newView = otherView();
3658  	_activeView = newView;
3659  	std::swap(_pDocTab, _pNonDocTab);
3660  	std::swap(_pEditView, _pNonEditView);
3661  	_pEditView->beSwitched();
3662      _pEditView->getFocus();	
3663  	if (_pDocMap)
3664  	{
3665  		_pDocMap->initWrapMap();
3666  	}
3667  	if (NppParameters::getInstance().getNppGUI().isSnapshotMode())
3668  	{
3669  		MainFileManager.backupCurrentBuffer();
3670  	}
3671  	notifyBufferActivated(_pEditView->getCurrentBufferID(), currentView());
3672  	return oldView;
3673  }
3674  void Notepad_plus::dockUserDlg()
3675  {
3676      if (!_pMainSplitter)
3677      {
3678          _pMainSplitter = new SplitterContainer;
3679  		_pMainSplitter->init(_pPublicInterface->getHinst(), _pPublicInterface->getHSelf());
3680          Window *pWindow;
3681  		if (_mainWindowStatus & (WindowMainActive | WindowSubActive))
3682              pWindow = &_subSplitter;
3683          else
3684              pWindow = _pDocTab;
3685  		int splitterSizeDyn = NppParameters::getInstance()._dpiManager.scaleX(splitterSize);
3686          _pMainSplitter->create(pWindow, ScintillaEditView::getUserDefineDlg(), splitterSizeDyn, SplitterMode::RIGHT_FIX, 45);
3687      }
3688      if (bothActive())
3689          _pMainSplitter->setWin0(&_subSplitter);
3690      else
3691          _pMainSplitter->setWin0(_pDocTab);
3692      _pMainSplitter->display();
3693      _mainWindowStatus |= WindowUserActive;
3694      _pMainWindow = _pMainSplitter;
3695  	::SendMessage(_pPublicInterface->getHSelf(), WM_SIZE, 0, 0);
3696  }
3697  void Notepad_plus::undockUserDlg()
3698  {
3699      ::ShowWindow(_pMainSplitter->getHSelf(), SW_HIDE);
3700      if (bothActive())
3701          _pMainWindow = &_subSplitter;
3702      else
3703          _pMainWindow = _pDocTab;
3704      ::SendMessage(_pPublicInterface->getHSelf(), WM_SIZE, 0, 0);
3705      _mainWindowStatus &= ~WindowUserActive;
3706      (ScintillaEditView::getUserDefineDlg())->display();
3707  }
3708  void Notepad_plus::docOpenInNewInstance(FileTransferMode mode, int x, int y)
3709  {
3710  	BufferID bufferID = _pEditView->getCurrentBufferID();
3711  	Buffer * buf = MainFileManager.getBufferByID(bufferID);
3712  	if (buf->isUntitled() || buf->isDirty())
3713  		return;
3714  	TCHAR nppName[MAX_PATH];
3715  	::GetModuleFileName(NULL, nppName, MAX_PATH);
3716  	generic_string command = TEXT("\"");
3717  	command += nppName;
3718  	command += TEXT("\"");
3719  	command += TEXT(" \"$(FULL_CURRENT_PATH)\" -multiInst -nosession");
3720  	if (x)
3721  	{
3722  		TCHAR pX[10]{};
3723  		_itow(x, pX, 10);
3724  		command += TEXT(" -x");
3725  		command += pX;
3726  	}
3727  	if (y)
3728  	{
3729  		TCHAR pY[10]{};
3730  		_itow(y, pY, 10);
3731  		command += TEXT(" -y");
3732  		command += pY;
3733  	}
3734  	LangType lt = buf->getLangType();
3735  	if (lt != L_USER)
3736  	{
3737  		command += TEXT(" -l");
3738  		command += ScintillaEditView::_langNameInfoArray[lt]._langName;
3739  	}
3740  	command += TEXT(" -n");
3741  	command += to_wstring(_pEditView->getCurrentLineNumber() + 1);
3742  	command += TEXT(" -c");
3743  	command += to_wstring(_pEditView->getCurrentColumnNumber() + 1);
3744  	Command cmd(command);
3745  	cmd.run(_pPublicInterface->getHSelf());
3746  	if (mode == TransferMove)
3747  	{
3748  		doClose(bufferID, currentView());
3749  		if (noOpenedDoc())
3750  			::SendMessage(_pPublicInterface->getHSelf(), WM_CLOSE, 0, 0);
3751  	}
3752  }
3753  void Notepad_plus::docGotoAnotherEditView(FileTransferMode mode)
3754  {
3755  	if (mode == TransferMove)
3756  	{
3757  		if (_pDocTab->nbItem() == 1)
3758  		{
3759  			ScintillaEditView *pOtherView = NULL;
3760  			if (_pEditView == &_mainEditView)
3761  			{
3762  				pOtherView = &_subEditView;
3763  			}
3764  			else if (_pEditView == &_subEditView)
3765  			{
3766  				pOtherView = &_mainEditView;
3767  			}
3768  			else
3769  				return;
3770  			if (!pOtherView->isVisible())
3771  				return;
3772  		}
3773  	}
3774  	BufferID current = _pEditView->getCurrentBufferID();
3775  	int viewToGo = otherView();
3776  	int indexFound = _pNonDocTab->getIndexByBuffer(current);
3777  	if (indexFound != -1)	
3778  	{
3779  		activateBuffer(current, otherView());
3780  	}
3781  	else	
3782  	{
3783  		if (_pEditView->isVisible() && _pNonEditView->isVisible())
3784  		{
3785  			_pNonEditView->saveCurrentPos();
3786  		}
3787  		loadBufferIntoView(current, viewToGo);
3788  		Buffer *buf = MainFileManager.getBufferByID(current);
3789  		_pEditView->saveCurrentPos();	
3790  		buf->setPosition(buf->getPosition(_pEditView), _pNonEditView);
3791  		_pNonEditView->restoreCurrentPosPreStep();	
3792  		activateBuffer(current, viewToGo);
3793  	}
3794  	int viewToOpen = (viewToGo == SUB_VIEW?WindowSubActive:WindowMainActive);
3795  	if (!(_mainWindowStatus & viewToOpen))
3796  	{
3797  		showView(viewToGo);
3798  	}
3799  	bool monitoringWasOn = false;
3800  	if (mode == TransferMove)
3801  	{
3802  		Buffer *buf = MainFileManager.getBufferByID(current);
3803  		monitoringWasOn = buf->isMonitoringOn();
3804  		doClose(_pEditView->getCurrentBufferID(), currentView());
3805  	} 
3806  	switchEditViewTo(viewToGo);
3807  	if (monitoringWasOn)
3808  	{
3809  		command(IDM_VIEW_MONITORING);
3810  	}
3811  	if (_pDocumentListPanel != nullptr)
3812  	{
3813  		Buffer* buf = MainFileManager.getBufferByID(current);
3814  		_pDocumentListPanel->setItemColor(buf);
3815  	}
3816  }
3817  bool Notepad_plus::activateBuffer(BufferID id, int whichOne, bool forceApplyHilite)
3818  {
3819  	NppGUI& nppGui = NppParameters::getInstance().getNppGUI();
3820  	bool isSnapshotMode = nppGui.isSnapshotMode();
3821  	if (isSnapshotMode)
3822  	{
3823  		MainFileManager.backupCurrentBuffer();
3824  	}
3825  	Buffer * pBuf = MainFileManager.getBufferByID(id);
3826  	bool reload = pBuf->getNeedReload();
3827  	if (reload)
3828  	{
3829  		MainFileManager.reloadBuffer(id);
3830  		pBuf->setNeedReload(false);
3831  	}
3832  	if (whichOne == MAIN_VIEW)
3833  	{
3834  		if (_mainDocTab.activateBuffer(id))	
3835  		{
3836  			_isFolding = true;
3837  			_mainEditView.activateBuffer(id, forceApplyHilite);
3838  			_isFolding = false;
3839  		}
3840  		else
3841  			return false;
3842  	}
3843  	else
3844  	{
3845  		if (_subDocTab.activateBuffer(id))
3846  		{
3847  			_isFolding = true;
3848  			_subEditView.activateBuffer(id, forceApplyHilite);
3849  			_isFolding = false;
3850  		}
3851  		else
3852  			return false;
3853  	}
3854  	if (reload)
3855  	{
3856  		performPostReload(whichOne);
3857  	}
3858  	notifyBufferActivated(id, whichOne);
3859  	bool isCurrBuffDetection = (nppGui._fileAutoDetection & cdEnabledNew) ? true : false;
3860  	if (!reload && isCurrBuffDetection)
3861  	{
3862  		pBuf->checkFileState();
3863  	}
3864  	return true;
3865  }
3866  void Notepad_plus::performPostReload(int whichOne)
3867  {
3868  	NppParameters& nppParam = NppParameters::getInstance();
3869  	const NppGUI & nppGUI = nppParam.getNppGUI();
3870  	bool toEnd = (nppGUI._fileAutoDetection & cdGo2end) ? true : false;
3871  	if (!toEnd)
3872  		return;
3873  	if (whichOne == MAIN_VIEW)
3874  	{
3875  		_mainEditView.setPositionRestoreNeeded(false);
3876  		_mainEditView.execute(SCI_DOCUMENTEND);
3877  	}
3878  	else
3879  	{
3880  		_subEditView.setPositionRestoreNeeded(false);
3881  		_subEditView.execute(SCI_DOCUMENTEND);
3882  	}
3883  }
3884  void Notepad_plus::bookmarkNext(bool forwardScan)
3885  {
3886  	size_t lineno = _pEditView->getCurrentLineNumber();
3887  	int sci_marker = SCI_MARKERNEXT;
3888  	size_t lineStart = lineno + 1;	
3889  	intptr_t lineRetry = 0;				
3890  	if (!forwardScan)
3891      {
3892  		lineStart = lineno - 1;		
3893  		lineRetry = _pEditView->execute(SCI_GETLINECOUNT);	
3894  		sci_marker = SCI_MARKERPREVIOUS;
3895  	}
3896  	intptr_t nextLine = _pEditView->execute(sci_marker, lineStart, static_cast<LPARAM>(1 << MARK_BOOKMARK));
3897  	if (nextLine < 0)
3898  		nextLine = _pEditView->execute(sci_marker, lineRetry, static_cast<LPARAM>(1 << MARK_BOOKMARK));
3899  	if (nextLine < 0)
3900  		return;
3901      _pEditView->execute(SCI_ENSUREVISIBLEENFORCEPOLICY, nextLine);
3902  	_pEditView->execute(SCI_GOTOLINE, nextLine);
3903  }
3904  void Notepad_plus::staticCheckMenuAndTB() const
3905  {
3906  	const bool wsTabShow = _pEditView->isShownSpaceAndTab();
3907  	const bool eolShow = _pEditView->isShownEol();
3908  	const bool npcShow = _pEditView->isShownNpc();
3909  	const bool ccUniEolShow = _pEditView->isShownCcUniEol();
3910  	const bool allShow = wsTabShow && eolShow && npcShow && ccUniEolShow;
3911  	checkMenuItem(IDM_VIEW_TAB_SPACE, wsTabShow);
3912  	checkMenuItem(IDM_VIEW_EOL, eolShow);
3913  	checkMenuItem(IDM_VIEW_NPC, npcShow);
3914  	checkMenuItem(IDM_VIEW_NPC_CCUNIEOL, ccUniEolShow);
3915  	checkMenuItem(IDM_VIEW_ALL_CHARACTERS, allShow);
3916  	_toolBar.setCheck(IDM_VIEW_ALL_CHARACTERS, allShow);
3917  	bool b = _pEditView->isShownIndentGuide();
3918  	checkMenuItem(IDM_VIEW_INDENT_GUIDE, b);
3919  	_toolBar.setCheck(IDM_VIEW_INDENT_GUIDE, b);
3920  	b = _pEditView->isWrap();
3921  	checkMenuItem(IDM_VIEW_WRAP, b);
3922  	_toolBar.setCheck(IDM_VIEW_WRAP, b);
3923  	checkMenuItem(IDM_VIEW_WRAP_SYMBOL, _pEditView->isWrapSymbolVisible());
3924  }
3925  void Notepad_plus::dynamicCheckMenuAndTB() const
3926  {
3927  	enableConvertMenuItems(_pEditView->getCurrentBuffer()->getEolFormat());
3928  	checkUnicodeMenuItems();
3929  }
3930  void Notepad_plus::enableConvertMenuItems(EolType format) const
3931  {
3932  	enableCommand(IDM_FORMAT_TODOS, (format != EolType::windows), MENU);
3933  	enableCommand(IDM_FORMAT_TOUNIX, (format != EolType::unix), MENU);
3934  	enableCommand(IDM_FORMAT_TOMAC, (format != EolType::macos), MENU);
3935  }
3936  void Notepad_plus::checkUnicodeMenuItems() const
3937  {
3938  	Buffer *buf = _pEditView->getCurrentBuffer();
3939  	UniMode um = buf->getUnicodeMode();
3940  	int encoding = buf->getEncoding();
3941  	int id = -1;
3942  	switch (um)
3943  	{
3944  		case uniUTF8   : id = IDM_FORMAT_UTF_8; break;
3945  		case uni16BE   : id = IDM_FORMAT_UTF_16BE; break;
3946  		case uni16LE   : id = IDM_FORMAT_UTF_16LE; break;
3947  		case uniCookie : id = IDM_FORMAT_AS_UTF_8; break;
3948  		case uni8Bit   : id = IDM_FORMAT_ANSI; break;
3949  		case uni7Bit:
3950  		case uni16BE_NoBOM:
3951  		case uni16LE_NoBOM:
3952  		case uniEnd:
3953  		default:
3954  			break;
3955  	}
3956  	if (encoding == -1)
3957  	{
3958          HMENU _formatMenuHandle = ::GetSubMenu(_mainMenuHandle, MENUINDEX_FORMAT);
3959          doCheck(_formatMenuHandle, -1);
3960  		if (id == -1) 
3961  		{
3962  			::CheckMenuRadioItem(_mainMenuHandle, IDM_FORMAT_ANSI, IDM_FORMAT_AS_UTF_8, IDM_FORMAT_ANSI, MF_BYCOMMAND);
3963  			::CheckMenuItem(_mainMenuHandle, IDM_FORMAT_ANSI, MF_UNCHECKED | MF_BYCOMMAND);
3964  		}
3965  		else
3966  		{
3967  			::CheckMenuRadioItem(_mainMenuHandle, IDM_FORMAT_ANSI, IDM_FORMAT_AS_UTF_8, id, MF_BYCOMMAND);
3968  		}
3969  	}
3970  	else
3971  	{
3972  		EncodingMapper& em = EncodingMapper::getInstance();
3973  		int cmdID = em.getIndexFromEncoding(encoding);
3974  		if (cmdID == -1)
3975  		{
3976  			return;
3977  		}
3978  		cmdID += IDM_FORMAT_ENCODE;
3979  		::CheckMenuRadioItem(_mainMenuHandle, IDM_FORMAT_ANSI, IDM_FORMAT_AS_UTF_8, IDM_FORMAT_ANSI, MF_BYCOMMAND);
3980  		::CheckMenuItem(_mainMenuHandle, IDM_FORMAT_ANSI, MF_UNCHECKED | MF_BYCOMMAND);
3981          HMENU _formatMenuHandle = ::GetSubMenu(_mainMenuHandle, MENUINDEX_FORMAT);
3982          doCheck(_formatMenuHandle, cmdID);
3983  	}
3984  }
3985  void Notepad_plus::showAutoComp()
3986  {
3987  	bool isFromPrimary = _pEditView == &_mainEditView;
3988  	AutoCompletion * autoC = isFromPrimary?&_autoCompleteMain:&_autoCompleteSub;
3989  	autoC->showApiComplete();
3990  }
3991  void Notepad_plus::showPathCompletion()
3992  {
3993  	bool isFromPrimary = _pEditView == &_mainEditView;
3994  	AutoCompletion * autoC = isFromPrimary?&_autoCompleteMain:&_autoCompleteSub;
3995  	autoC->showPathCompletion();
3996  }
3997  void Notepad_plus::autoCompFromCurrentFile(bool autoInsert)
3998  {
3999  	bool isFromPrimary = _pEditView == &_mainEditView;
4000  	AutoCompletion * autoC = isFromPrimary?&_autoCompleteMain:&_autoCompleteSub;
4001  	autoC->showWordComplete(autoInsert);
4002  }
4003  void Notepad_plus::showFunctionComp()
4004  {
4005  	bool isFromPrimary = _pEditView == &_mainEditView;
4006  	AutoCompletion * autoC = isFromPrimary?&_autoCompleteMain:&_autoCompleteSub;
4007  	autoC->showFunctionComplete();
4008  }
4009  void Notepad_plus::showFunctionNextHint(bool isNext)
4010  {
4011  	bool isFromPrimary = _pEditView == &_mainEditView;
4012  	AutoCompletion* autoC = isFromPrimary ? &_autoCompleteMain : &_autoCompleteSub;
4013  	if (isNext)
4014  		autoC->callTipClick(2);
4015  	else
4016  		autoC->callTipClick(1);
4017  }
4018  static generic_string extractSymbol(TCHAR firstChar, TCHAR secondChar, const TCHAR *str2extract)
4019  {
4020  	bool found = false;
4021  	const size_t extractedLen = 128;
4022  	TCHAR extracted[extractedLen] = {'\0'};
4023  	for (size_t i = 0, j = 0, len = lstrlen(str2extract) ; i < len && j < extractedLen - 1; ++i)
4024  	{
4025  		if (found)
4026  		{
4027  			if (!str2extract[i] || str2extract[i] == ' ')
4028  			{
4029  				extracted[j] = '\0';
4030  				return generic_string(extracted);
4031  			}
4032  			extracted[j++] = str2extract[i];
4033  		}
4034  		else
4035  		{
4036  			if (!str2extract[i])
4037  				return TEXT("");
4038  			if (str2extract[i] == firstChar && str2extract[i+1] == secondChar)
4039  			{
4040  				found = true;
4041  				++i;
4042  			}
4043  		}
4044  	}
4045  	return  generic_string(extracted);
4046  }
4047  bool Notepad_plus::doBlockComment(comment_mode currCommentMode)
4048  {
4049  	Buffer * buf = _pEditView->getCurrentBuffer();
4050  	if (buf->isReadOnly())
4051  		return false;
4052  	const TCHAR *commentStart;
4053  	const TCHAR *commentEnd;
4054  	generic_string symbolStart;
4055  	generic_string symbolEnd;
4056  	const TCHAR *commentLineSymbol;
4057  	generic_string symbol;
4058  	bool isSingleLineAdvancedMode = false;
4059  	if (buf->getLangType() == L_USER)
4060  	{
4061  		UserLangContainer * userLangContainer = NppParameters::getInstance().getULCFromName(buf->getUserDefineLangName());
4062  		if (!userLangContainer)
4063  			return false;
4064  		symbol = extractSymbol('0', '0', userLangContainer->_keywordLists[SCE_USER_KWLIST_COMMENTS]);
4065  		commentLineSymbol = symbol.c_str();
4066  		symbolStart = extractSymbol('0', '3', userLangContainer->_keywordLists[SCE_USER_KWLIST_COMMENTS]);
4067  		commentStart = symbolStart.c_str();
4068  		symbolEnd = extractSymbol('0', '4', userLangContainer->_keywordLists[SCE_USER_KWLIST_COMMENTS]);
4069  		commentEnd = symbolEnd.c_str();
4070  	}
4071  	else
4072  	{
4073  		commentLineSymbol = buf->getCommentLineSymbol();
4074  		commentStart = buf->getCommentStart();
4075  		commentEnd = buf->getCommentEnd();
4076  	}
4077  	if ((!commentLineSymbol) || (!commentLineSymbol[0]) || (commentLineSymbol == NULL))
4078  	{
4079  		if (!(!commentStart || !commentStart[0] || commentStart == NULL || !commentEnd || !commentEnd[0] || commentEnd == NULL))
4080  		{
4081  			if (currCommentMode == cm_comment)
4082  			{
4083  				isSingleLineAdvancedMode = true;
4084  			}
4085  			else if (currCommentMode == cm_uncomment)
4086  			{
4087  				return undoStreamComment(false);
4088  			}
4089  			else if (currCommentMode == cm_toggle)
4090  			{
4091  				isSingleLineAdvancedMode = true;
4092  			}
4093  			else
4094  				return false;
4095  		}
4096  		else
4097  			return false;
4098  	}
4099  	generic_string comment;
4100  	size_t comment_length = 0;
4101  	generic_string advCommentStart;
4102  	generic_string advCommentEnd;
4103  	size_t advCommentStart_length = 0;
4104  	size_t advCommentEnd_length = 0;
4105  	const TCHAR aSpace[] { TEXT(" ") };
4106  	if (!isSingleLineAdvancedMode)
4107  	{
4108  		comment = commentLineSymbol;
4109  		if (!(buf->getLangType() == L_BAANC)) 
4110  			comment += aSpace;
4111  		comment_length = comment.length();
4112  	}
4113  	else 
4114  	{
4115  		advCommentStart = commentStart;
4116  		advCommentStart += aSpace;
4117  		advCommentEnd = aSpace;
4118  		advCommentEnd += commentEnd;
4119  		advCommentStart_length = advCommentStart.length();
4120  		advCommentEnd_length = advCommentEnd.length();
4121  	}
4122      size_t selectionStart = _pEditView->execute(SCI_GETSELECTIONSTART);
4123      size_t selectionEnd = _pEditView->execute(SCI_GETSELECTIONEND);
4124      size_t caretPosition = _pEditView->execute(SCI_GETCURRENTPOS);
4125      bool move_caret = caretPosition < selectionEnd;
4126  	intptr_t selStartLine = _pEditView->execute(SCI_LINEFROMPOSITION, selectionStart);
4127  	intptr_t selEndLine = _pEditView->execute(SCI_LINEFROMPOSITION, selectionEnd);
4128  	intptr_t lines = selEndLine - selStartLine;
4129      if ((lines > 0) && (selectionEnd == static_cast<size_t>(_pEditView->execute(SCI_POSITIONFROMLINE, selEndLine))))
4130  		selEndLine--;
4131  	int nUncomments = 0;
4132  	const bool avoidIndent = (buf->getLangType() == L_FORTRAN_77 || buf->getLangType() == L_BAANC);
4133  	const bool commentEmptyLines = (buf->getLangType() == L_BAANC);
4134      _pEditView->execute(SCI_BEGINUNDOACTION);
4135      for (intptr_t i = selStartLine; i <= selEndLine; ++i)
4136  	{
4137  		size_t lineStart = _pEditView->execute(SCI_POSITIONFROMLINE, i);
4138  		size_t lineIndent = _pEditView->execute(SCI_GETLINEINDENTPOSITION, i);
4139  		size_t lineEnd = _pEditView->execute(SCI_GETLINEENDPOSITION, i);
4140  		if (lineIndent == lineEnd && !commentEmptyLines)
4141  			continue;
4142  		if (avoidIndent)
4143  			lineIndent = lineStart;
4144  		size_t linebufferSize = lineEnd - lineIndent + 1;
4145  		TCHAR* linebuf = new TCHAR[linebufferSize];
4146  		_pEditView->getGenericText(linebuf, linebufferSize, lineIndent, lineEnd);
4147          generic_string linebufStr = linebuf;
4148  		delete [] linebuf;
4149     		if (currCommentMode != cm_comment) 
4150  		{
4151  			if (!isSingleLineAdvancedMode)
4152  			{
4153  				if (wcsnicmp(linebufStr.c_str(), comment.c_str(), !(buf->getLangType() == L_BAANC) ? comment_length - 1 : comment_length) == 0)
4154  				{
4155  					size_t len = linebufStr[comment_length - 1] == aSpace[0] ? comment_length : !(buf->getLangType() == L_BAANC) ? comment_length - 1 : comment_length;
4156  					_pEditView->execute(SCI_SETSEL, lineIndent, lineIndent + len);
4157  					_pEditView->replaceSelWith("");
4158  					if (i == selStartLine) 
4159  					{
4160  						if (selectionStart > lineIndent + len)
4161  							selectionStart -= len;
4162  						else if (selectionStart > lineIndent)
4163  							selectionStart = lineIndent;
4164  					} 
4165  					if (i == selEndLine) 
4166  					{
4167  						if (selectionEnd > lineIndent + len)
4168  							selectionEnd -= len;
4169  						else if (selectionEnd > lineIndent)
4170  						{
4171  							selectionEnd = lineIndent;
4172  							if (lineIndent == lineStart && i != selStartLine)
4173  								++selectionEnd; 
4174  						}
4175  					} 
4176  					else 
4177  						selectionEnd -= len;
4178  					++nUncomments;
4179  					continue;
4180  				}
4181  			}
4182  			else 
4183  			{
4184  				if ((wcsnicmp(linebufStr.c_str(), advCommentStart.c_str(), advCommentStart_length - 1) == 0) &&
4185  					(wcsnicmp(linebufStr.substr(linebufStr.length() - advCommentEnd_length + 1, advCommentEnd_length - 1).c_str(), advCommentEnd.substr(1, advCommentEnd_length - 1).c_str(), advCommentEnd_length - 1) == 0))
4186  				{
4187  					size_t startLen = linebufStr[advCommentStart_length - 1] == aSpace[0] ? advCommentStart_length : advCommentStart_length - 1;
4188  					size_t endLen = linebufStr[linebufStr.length() - advCommentEnd_length] == aSpace[0] ? advCommentEnd_length : advCommentEnd_length - 1;
4189  					_pEditView->execute(SCI_SETSEL, lineIndent, lineIndent + startLen);
4190  					_pEditView->replaceSelWith("");
4191  					_pEditView->execute(SCI_SETSEL, lineEnd - startLen - endLen, lineEnd - startLen);
4192  					_pEditView->replaceSelWith("");
4193  					if (i == selStartLine) 
4194  					{
4195  						if (selectionStart > lineEnd - endLen)
4196  							selectionStart = lineEnd - startLen - endLen;
4197  						else if (selectionStart > lineIndent + startLen)
4198  							selectionStart -= startLen;
4199  						else if (selectionStart > lineIndent)
4200  							selectionStart = lineIndent;
4201  					} 
4202  					if (i == selEndLine) 
4203  					{
4204  						if (selectionEnd > lineEnd)
4205  							selectionEnd -= (startLen + endLen);
4206  						else if (selectionEnd > lineEnd - endLen)
4207  							selectionEnd = lineEnd - startLen - endLen;
4208  						else if (selectionEnd > lineIndent + startLen)
4209  							selectionEnd -= startLen;
4210  						else if (selectionEnd > lineIndent)
4211  						{
4212  							selectionEnd = lineIndent;
4213  							if (lineIndent == lineStart && i != selStartLine)
4214  								++selectionEnd; 
4215  						}
4216  					} 
4217  					else 
4218  						selectionEnd -= (startLen + endLen);
4219  					++nUncomments;
4220  					continue;
4221  				}
4222  			}
4223  		} 
4224  		if (currCommentMode != cm_uncomment) 
4225  		{
4226  			if (!isSingleLineAdvancedMode)
4227  			{
4228  				_pEditView->insertGenericTextFrom(lineIndent, comment.c_str());
4229  				if (i == selStartLine) 
4230  				{
4231  					if (selectionStart >= lineIndent)
4232  						selectionStart += comment_length;
4233  				} 
4234  				if (i == selEndLine) 
4235  				{
4236  					if (selectionEnd >= lineIndent)
4237  						selectionEnd += comment_length;
4238  				} 
4239  				else 
4240  					selectionEnd += comment_length;
4241  			}
4242  			else 
4243  			{
4244  				_pEditView->insertGenericTextFrom(lineIndent, advCommentStart.c_str());
4245  				_pEditView->insertGenericTextFrom(lineEnd + advCommentStart_length, advCommentEnd.c_str());
4246  				if (i == selStartLine) 
4247  				{
4248  					if (selectionStart >= lineIndent)
4249  						selectionStart += advCommentStart_length;
4250  				} 
4251  				if (i == selEndLine) 
4252  				{
4253  					if (selectionEnd > lineEnd)
4254  						selectionEnd += (advCommentStart_length + advCommentEnd_length);
4255  					else if (selectionEnd >= lineIndent)
4256  						selectionEnd += advCommentStart_length;
4257  				} 
4258  				else 
4259  					selectionEnd += (advCommentStart_length + advCommentEnd_length);
4260  			}
4261  		} 
4262  	} 
4263      if (move_caret)
4264  	{
4265          _pEditView->execute(SCI_GOTOPOS, selectionEnd);
4266          _pEditView->execute(SCI_SETCURRENTPOS, selectionStart);
4267      }
4268  	else
4269  	{
4270          _pEditView->execute(SCI_SETSEL, selectionStart, selectionEnd);
4271      }
4272      _pEditView->execute(SCI_ENDUNDOACTION);
4273  	if ((currCommentMode == cm_uncomment) && (nUncomments == 0))
4274  	{
4275  		return undoStreamComment(false);
4276  	}
4277      return true;
4278  }
4279  bool Notepad_plus::doStreamComment()
4280  {
4281  	const TCHAR *commentStart;
4282  	const TCHAR *commentEnd;
4283  	generic_string symbolStart;
4284  	generic_string symbolEnd;
4285  	const TCHAR *commentLineSymbol;
4286  	generic_string symbol;
4287  	Buffer * buf = _pEditView->getCurrentBuffer();
4288  	if (buf->isReadOnly())
4289  		return false;
4290  	if (buf->getLangType() == L_USER)
4291  	{
4292  		UserLangContainer * userLangContainer = NppParameters::getInstance().getULCFromName(buf->getUserDefineLangName());
4293  		if (!userLangContainer)
4294  			return false;
4295  		symbol = extractSymbol('0', '0', userLangContainer->_keywordLists[SCE_USER_KWLIST_COMMENTS]);
4296  		commentLineSymbol = symbol.c_str();
4297  		symbolStart = extractSymbol('0', '3', userLangContainer->_keywordLists[SCE_USER_KWLIST_COMMENTS]);
4298  		commentStart = symbolStart.c_str();
4299  		symbolEnd = extractSymbol('0', '4', userLangContainer->_keywordLists[SCE_USER_KWLIST_COMMENTS]);
4300  		commentEnd = symbolEnd.c_str();
4301  	}
4302  	else
4303  	{
4304  		commentLineSymbol = buf->getCommentLineSymbol();
4305  		commentStart = buf->getCommentStart();
4306  		commentEnd = buf->getCommentEnd();
4307  	}
4308  	if ((!commentStart) || (!commentStart[0]) || (commentStart == NULL) || (!commentEnd) || (!commentEnd[0]) || (commentEnd == NULL))
4309  	{
4310  		if (!(!commentLineSymbol || !commentLineSymbol[0] || commentLineSymbol == NULL))
4311  			return doBlockComment(cm_comment);
4312  		else
4313  		return false;
4314  	}
4315  	generic_string start_comment(commentStart);
4316  	generic_string end_comment(commentEnd);
4317  	generic_string white_space(TEXT(" "));
4318  	start_comment += white_space;
4319  	white_space += end_comment;
4320  	end_comment = white_space;
4321  	size_t start_comment_length = start_comment.length();
4322  	size_t selectionStart = _pEditView->execute(SCI_GETSELECTIONSTART);
4323  	size_t selectionEnd = _pEditView->execute(SCI_GETSELECTIONEND);
4324  	size_t caretPosition = _pEditView->execute(SCI_GETCURRENTPOS);
4325  	bool move_caret = caretPosition < selectionEnd;
4326  	if (selectionEnd - selectionStart <= 0)
4327  	{
4328  		auto selLine = _pEditView->execute(SCI_LINEFROMPOSITION, selectionStart);
4329  		selectionStart = _pEditView->execute(SCI_GETLINEINDENTPOSITION, selLine);
4330  		selectionEnd = _pEditView->execute(SCI_GETLINEENDPOSITION, selLine);
4331  	}
4332  	_pEditView->execute(SCI_BEGINUNDOACTION);
4333  	_pEditView->insertGenericTextFrom(selectionStart, start_comment.c_str());
4334  	selectionEnd += start_comment_length;
4335  	selectionStart += start_comment_length;
4336  	_pEditView->insertGenericTextFrom(selectionEnd, end_comment.c_str());
4337  	if (move_caret)
4338  	{
4339  		_pEditView->execute(SCI_GOTOPOS, selectionEnd);
4340  		_pEditView->execute(SCI_SETCURRENTPOS, selectionStart);
4341  	}
4342  	else
4343  	{
4344  		_pEditView->execute(SCI_SETSEL, selectionStart, selectionEnd);
4345  	}
4346  	_pEditView->execute(SCI_ENDUNDOACTION);
4347  	return true;
4348  }
4349  void Notepad_plus::saveScintillasZoom()
4350  {
4351  	NppParameters& nppParam = NppParameters::getInstance();
4352  	ScintillaViewParams & svp = (ScintillaViewParams &)nppParam.getSVP();
4353  	svp._zoom = _mainEditView.execute(SCI_GETZOOM);
4354  	svp._zoom2 = _subEditView.execute(SCI_GETZOOM);
4355  }
4356  bool Notepad_plus::addCurrentMacro()
4357  {
4358  	NppParameters& nppParams = NppParameters::getInstance();
4359  	vector<MacroShortcut> & theMacros = nppParams.getMacroList();
4360  	int nbMacro = static_cast<int32_t>(theMacros.size());
4361  	DynamicMenu& macroMenu = nppParams.getMacroMenuItems();
4362  	int nbTopLevelItem = macroMenu.getTopLevelItemNumber();
4363  	int cmdID = ID_MACRO + nbMacro;
4364  	MacroShortcut ms(Shortcut(), _macro, cmdID);
4365  	ms.init(_pPublicInterface->getHinst(), _pPublicInterface->getHSelf());
4366  	if (ms.doDialog() != -1)
4367  	{
4368  		HMENU hMacroMenu = ::GetSubMenu(_mainMenuHandle, MENUINDEX_MACRO);
4369  		unsigned int posBase = macroMenu.getPosBase();
4370  		if (nbTopLevelItem == 0)
4371  		{
4372  			::InsertMenu(hMacroMenu, posBase - 1, MF_BYPOSITION, static_cast<UINT>(-1), 0);	
4373  			::InsertMenu(hMacroMenu, posBase + nbTopLevelItem + 1, MF_BYPOSITION, static_cast<UINT>(-1), 0);
4374  			NativeLangSpeaker *pNativeLangSpeaker = nppParams.getNativeLangSpeaker();
4375  			generic_string nativeLangShortcutMapperMacro = pNativeLangSpeaker->getNativeLangMenuString(IDM_SETTING_SHORTCUT_MAPPER_MACRO);
4376  			if (nativeLangShortcutMapperMacro == TEXT(""))
4377  				nativeLangShortcutMapperMacro = macroMenu.getLastCmdLabel();
4378  			::InsertMenu(hMacroMenu, posBase + nbTopLevelItem + 2, MF_BYCOMMAND, IDM_SETTING_SHORTCUT_MAPPER_MACRO, nativeLangShortcutMapperMacro.c_str());
4379          }
4380  		theMacros.push_back(ms);
4381  		macroMenu.push_back(MenuItemUnit(cmdID, string2wstring(ms.getName(), CP_UTF8)));
4382  		::InsertMenu(hMacroMenu, static_cast<UINT>(posBase + nbTopLevelItem), MF_BYPOSITION, cmdID, string2wstring(ms.toMenuItemString(), CP_UTF8).c_str());
4383  		_accelerator.updateShortcuts();
4384  		nppParams.setShortcutDirty();
4385  		return true;
4386  	}
4387  	return false;
4388  }
4389  bool Notepad_plus::switchToFile(BufferID id)
4390  {
4391  	int i = 0;
4392  	int iView = currentView();
4393  	if (id == BUFFER_INVALID)
4394  		return false;
4395  	if ((i = _pDocTab->getIndexByBuffer(id)) != -1)
4396  	{
4397  		iView = currentView();
4398  	}
4399  	else if ((i = _pNonDocTab->getIndexByBuffer(id)) != -1)
4400  	{
4401  		iView = otherView();
4402  	}
4403  	if (i != -1)
4404  	{
4405  		switchEditViewTo(iView);
4406  		activateBuffer(id, currentView());
4407  		return true;
4408  	}
4409  	return false;
4410  }
4411  void Notepad_plus::getTaskListInfo(TaskListInfo *tli)
4412  {
4413  	int currentNbDoc = static_cast<int32_t>(_pDocTab->nbItem());
4414  	int nonCurrentNbDoc = static_cast<int32_t>(_pNonDocTab->nbItem());
4415  	tli->_currentIndex = 0;
4416  	if (!viewVisible(otherView()))
4417  		nonCurrentNbDoc = 0;
4418  	for (int i = 0 ; i < currentNbDoc ; ++i)
4419  	{
4420  		BufferID bufID = _pDocTab->getBufferByIndex(i);
4421  		Buffer * b = MainFileManager.getBufferByID(bufID);
4422  		int status = b->isMonitoringOn()?tb_monitored:(b->isReadOnly()?tb_ro:(b->isDirty()?tb_unsaved:tb_saved));
4423  		tli->_tlfsLst.push_back(TaskLstFnStatus(currentView(), i, b->getFullPathName(), status, (void *)bufID, b->getDocColorId()));
4424  	}
4425  	for (int i = 0 ; i < nonCurrentNbDoc ; ++i)
4426  	{
4427  		BufferID bufID = _pNonDocTab->getBufferByIndex(i);
4428  		Buffer * b = MainFileManager.getBufferByID(bufID);
4429  		int status = b->isMonitoringOn()?tb_monitored:(b->isReadOnly()?tb_ro:(b->isDirty()?tb_unsaved:tb_saved));
4430  		tli->_tlfsLst.push_back(TaskLstFnStatus(otherView(), i, b->getFullPathName(), status, (void *)bufID, b->getDocColorId()));
4431  	}
4432  }
4433  bool Notepad_plus::goToPreviousIndicator(int indicID2Search, bool isWrap) const
4434  {
4435      auto position = _pEditView->execute(SCI_GETCURRENTPOS);
4436  	auto docLen = _pEditView->getCurrentDocLen();
4437      bool isInIndicator = _pEditView->execute(SCI_INDICATORVALUEAT, indicID2Search,  position) != 0;
4438      size_t posStart = _pEditView->execute(SCI_INDICATORSTART, indicID2Search,  position);
4439      size_t posEnd = _pEditView->execute(SCI_INDICATOREND, indicID2Search,  position);
4440  	if ((posStart == 0) && (posEnd == docLen - 1))
4441  		return false;
4442      if (posStart <= 0)
4443  	{
4444  		if (!isWrap)
4445  			return false;
4446  		isInIndicator = _pEditView->execute(SCI_INDICATORVALUEAT, indicID2Search,  docLen - 1) != 0;
4447  		posStart = _pEditView->execute(SCI_INDICATORSTART, indicID2Search,  docLen - 1);
4448  	}
4449      if (isInIndicator) 
4450      {
4451          posStart = _pEditView->execute(SCI_INDICATORSTART, indicID2Search, posStart - 1);
4452          if (posStart <= 0)
4453  		{
4454  			if (!isWrap)
4455  				return false;
4456  			posStart = _pEditView->execute(SCI_INDICATORSTART, indicID2Search,  docLen - 1);
4457  		}
4458  	}
4459      auto newPos = posStart - 1;
4460      posStart = _pEditView->execute(SCI_INDICATORSTART, indicID2Search, newPos);
4461      posEnd = _pEditView->execute(SCI_INDICATOREND, indicID2Search, newPos);
4462  	if (_pEditView->execute(SCI_INDICATORVALUEAT, indicID2Search, posStart))
4463  	{
4464  		NppGUI & nppGUI = (NppParameters::getInstance()).getNppGUI();
4465  		nppGUI._disableSmartHiliteTmp = true;
4466          auto currentline = _pEditView->execute(SCI_LINEFROMPOSITION, posEnd);
4467  	    _pEditView->execute(SCI_ENSUREVISIBLE, currentline);	
4468  		_pEditView->execute(SCI_SETSEL, posEnd, posStart);
4469  		_pEditView->execute(SCI_SCROLLCARET);
4470  		return true;
4471  	}
4472  	return false;
4473  }
4474  bool Notepad_plus::goToNextIndicator(int indicID2Search, bool isWrap) const
4475  {
4476      size_t position = _pEditView->execute(SCI_GETCURRENTPOS);
4477  	size_t docLen = _pEditView->getCurrentDocLen();
4478      bool isInIndicator = _pEditView->execute(SCI_INDICATORVALUEAT, indicID2Search,  position) != 0;
4479      size_t posStart = _pEditView->execute(SCI_INDICATORSTART, indicID2Search,  position);
4480      size_t posEnd = _pEditView->execute(SCI_INDICATOREND, indicID2Search,  position);
4481  	if ((posStart == 0) && (posEnd == docLen - 1))
4482  		return false;
4483      if (posEnd >= docLen)
4484  	{
4485  		if (!isWrap)
4486  			return false;
4487  		isInIndicator = _pEditView->execute(SCI_INDICATORVALUEAT, indicID2Search,  0) != 0;
4488  		posEnd = _pEditView->execute(SCI_INDICATOREND, indicID2Search, 0);
4489  	}
4490      if (isInIndicator) 
4491      {
4492          posEnd = _pEditView->execute(SCI_INDICATOREND, indicID2Search, posEnd);
4493          if (posEnd >= docLen)
4494  		{
4495  			if (!isWrap)
4496  				return false;
4497  			posEnd = _pEditView->execute(SCI_INDICATOREND, indicID2Search, 0);
4498  		}
4499      }
4500      auto newPos = posEnd;
4501      posStart = _pEditView->execute(SCI_INDICATORSTART, indicID2Search, newPos);
4502      posEnd = _pEditView->execute(SCI_INDICATOREND, indicID2Search, newPos);
4503  	if (_pEditView->execute(SCI_INDICATORVALUEAT, indicID2Search, posStart))
4504  	{
4505  		NppGUI & nppGUI = (NppParameters::getInstance()).getNppGUI();
4506  		nppGUI._disableSmartHiliteTmp = true;
4507          auto currentline = _pEditView->execute(SCI_LINEFROMPOSITION, posEnd);
4508  	    _pEditView->execute(SCI_ENSUREVISIBLE, currentline);	
4509  		_pEditView->execute(SCI_SETSEL, posStart, posEnd);
4510  		_pEditView->execute(SCI_SCROLLCARET);
4511  		return true;
4512  	}
4513  	return false;
4514  }
4515  void Notepad_plus::fullScreenToggle()
4516  {
4517  	if (!_beforeSpecialView._isFullScreen)	
4518  	{
4519  		_beforeSpecialView._winPlace.length = sizeof(_beforeSpecialView._winPlace);
4520  		::GetWindowPlacement(_pPublicInterface->getHSelf(), &_beforeSpecialView._winPlace);
4521  		RECT fullscreenArea{};		
4522  		fullscreenArea.top = 0;
4523  		fullscreenArea.left = 0;
4524  		fullscreenArea.right = GetSystemMetrics(SM_CXSCREEN);
4525  		fullscreenArea.bottom = GetSystemMetrics(SM_CYSCREEN);
4526  		{
4527  			HMONITOR currentMonitor;	
4528  			MONITORINFO mi{};				
4529  			currentMonitor = ::MonitorFromWindow(_pPublicInterface->getHSelf(), MONITOR_DEFAULTTONEAREST);	
4530  			mi.cbSize = sizeof(MONITORINFO);
4531  			if (::GetMonitorInfo(currentMonitor, &mi) != FALSE)
4532  			{
4533  				fullscreenArea = mi.rcMonitor;
4534  				fullscreenArea.right -= fullscreenArea.left;
4535  				fullscreenArea.bottom -= fullscreenArea.top;
4536  			}
4537  		}
4538          int bs = buttonStatus_fullscreen;
4539  		if (_beforeSpecialView._isPostIt)
4540          {
4541              bs |= buttonStatus_postit;
4542          }
4543          else
4544  		{
4545  			_beforeSpecialView._isMenuShown = ::SendMessage(_pPublicInterface->getHSelf(), NPPM_ISMENUHIDDEN, 0, 0) != TRUE;
4546  			if (_beforeSpecialView._isMenuShown)
4547  				::SendMessage(_pPublicInterface->getHSelf(), NPPM_HIDEMENU, 0, TRUE);
4548  			_rebarTop.display(false);
4549  			_rebarBottom.display(false);
4550  		}
4551          _restoreButton.setButtonStatus(bs);
4552  		::ShowWindow(_pPublicInterface->getHSelf(), SW_HIDE);
4553  		if (!_beforeSpecialView._isPostIt)
4554  		{
4555  			_beforeSpecialView._preStyle = ::SetWindowLongPtr(_pPublicInterface->getHSelf(), GWL_STYLE, WS_POPUP);
4556  			if (!_beforeSpecialView._preStyle)
4557  			{
4558  				_beforeSpecialView._preStyle = WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN;
4559  			}
4560  		}
4561  		::ShowWindow(_pPublicInterface->getHSelf(), SW_SHOW);
4562  		::SetWindowPos(_pPublicInterface->getHSelf(), HWND_TOP, fullscreenArea.left, fullscreenArea.top, fullscreenArea.right, fullscreenArea.bottom, SWP_NOZORDER|SWP_DRAWFRAME|SWP_FRAMECHANGED);
4563  		::SetForegroundWindow(_pPublicInterface->getHSelf());
4564          _restoreButton.doDialog(_nativeLangSpeaker.isRTL());
4565          RECT rect;
4566          GetWindowRect(_restoreButton.getHSelf(), &rect);
4567  	    int w = rect.right - rect.left;
4568  	    int h = rect.bottom - rect.top;
4569          RECT nppRect;
4570          GetWindowRect(_pPublicInterface->getHSelf(), &nppRect);
4571          int x = nppRect.right - w;
4572          int y = nppRect.top;
4573          ::MoveWindow(_restoreButton.getHSelf(), x, y, w, h, FALSE);
4574          _pEditView->getFocus();
4575  	}
4576  	else	
4577  	{
4578  		::ShowWindow(_pPublicInterface->getHSelf(), SW_HIDE);
4579          _restoreButton.setButtonStatus(buttonStatus_fullscreen ^ _restoreButton.getButtonStatus());
4580          _restoreButton.display(false);
4581  		if (!_beforeSpecialView._isPostIt)
4582  		{
4583  			if (_beforeSpecialView._isMenuShown)
4584  				::SendMessage(_pPublicInterface->getHSelf(), NPPM_HIDEMENU, 0, FALSE);
4585  			_rebarTop.display(true);
4586  			_rebarBottom.display(true);
4587  		}
4588  		if (!_beforeSpecialView._isPostIt)
4589  		{
4590  			::SetWindowLongPtr( _pPublicInterface->getHSelf(), GWL_STYLE, _beforeSpecialView._preStyle);
4591  			::SetWindowPos(_pPublicInterface->getHSelf(), HWND_TOP,0,0,0,0,SWP_NOMOVE|SWP_NOSIZE|SWP_NOZORDER|SWP_DRAWFRAME|SWP_FRAMECHANGED);
4592  			::ShowWindow(_pPublicInterface->getHSelf(), SW_SHOW);
4593  		}
4594  		if (_beforeSpecialView._winPlace.length)
4595  		{
4596  			if (_beforeSpecialView._winPlace.showCmd == SW_SHOWMAXIMIZED)
4597  			{
4598  				::ShowWindow(_pPublicInterface->getHSelf(), SW_SHOWMAXIMIZED);
4599  			}
4600  			else
4601  			{
4602  				::SetWindowPlacement(_pPublicInterface->getHSelf(), &_beforeSpecialView._winPlace);
4603  			}
4604  		}
4605  		else	
4606  		{
4607  			::ShowWindow(_pPublicInterface->getHSelf(), SW_SHOW);
4608  		}
4609  	}
4610  	_beforeSpecialView._isFullScreen = !_beforeSpecialView._isFullScreen;
4611  	::SendMessage(_pPublicInterface->getHSelf(), WM_SIZE, 0, 0);
4612      if (_beforeSpecialView._isPostIt)
4613      {
4614          RECT rect;
4615          GetWindowRect(_restoreButton.getHSelf(), &rect);
4616          int w = rect.right - rect.left;
4617          int h = rect.bottom - rect.top;
4618          RECT nppRect;
4619          GetWindowRect(_pPublicInterface->getHSelf(), &nppRect);
4620          int x = nppRect.right - w - w;
4621          int y = nppRect.top + 1;
4622          ::MoveWindow(_restoreButton.getHSelf(), x, y, w, h, FALSE);
4623      }
4624  }
4625  void Notepad_plus::postItToggle()
4626  {
4627  	if (!_beforeSpecialView._isPostIt)	
4628  	{
4629  		NppGUI & nppGUI = NppParameters::getInstance().getNppGUI();
4630  		{
4631  			_beforeSpecialView._isAlwaysOnTop = ::GetMenuState(_mainMenuHandle, IDM_VIEW_ALWAYSONTOP, MF_BYCOMMAND) == MF_CHECKED;
4632  			_beforeSpecialView._isTabbarShown = ::SendMessage(_pPublicInterface->getHSelf(), NPPM_ISTABBARHIDDEN, 0, 0) != TRUE;
4633  			_beforeSpecialView._isStatusbarShown = nppGUI._statusBarShow;
4634  			if (nppGUI._statusBarShow)
4635  				::SendMessage(_pPublicInterface->getHSelf(), NPPM_HIDESTATUSBAR, 0, TRUE);
4636  			if (_beforeSpecialView._isTabbarShown)
4637  				::SendMessage(_pPublicInterface->getHSelf(), NPPM_HIDETABBAR, 0, TRUE);
4638  			if (!_beforeSpecialView._isAlwaysOnTop)
4639  				::SendMessage(_pPublicInterface->getHSelf(), WM_COMMAND, IDM_VIEW_ALWAYSONTOP, 0);
4640  		}
4641          int bs = buttonStatus_postit;
4642  		if (_beforeSpecialView._isFullScreen)
4643          {
4644              bs |= buttonStatus_fullscreen;
4645          }
4646          else
4647  		{
4648  			_beforeSpecialView._isMenuShown = ::SendMessage(_pPublicInterface->getHSelf(), NPPM_ISMENUHIDDEN, 0, 0) != TRUE;
4649  			if (_beforeSpecialView._isMenuShown)
4650  				::SendMessage(_pPublicInterface->getHSelf(), NPPM_HIDEMENU, 0, TRUE);
4651  			_rebarTop.display(false);
4652  			_rebarBottom.display(false);
4653  		}
4654          _restoreButton.setButtonStatus(bs);
4655  		if (!_beforeSpecialView._isFullScreen)
4656  		{
4657  			::ShowWindow(_pPublicInterface->getHSelf(), SW_HIDE);
4658  			_beforeSpecialView._preStyle = ::SetWindowLongPtr( _pPublicInterface->getHSelf(), GWL_STYLE, WS_POPUP );
4659  			if (!_beforeSpecialView._preStyle)
4660  			{
4661  				_beforeSpecialView._preStyle = WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN;
4662  			}
4663  			::SetWindowPos(_pPublicInterface->getHSelf(), HWND_TOPMOST,0,0,0,0,SWP_NOMOVE|SWP_NOSIZE|SWP_NOZORDER|SWP_DRAWFRAME|SWP_FRAMECHANGED);
4664  			::ShowWindow(_pPublicInterface->getHSelf(), SW_SHOW);
4665  		}
4666          _restoreButton.doDialog(_nativeLangSpeaker.isRTL());
4667          RECT rect;
4668          GetWindowRect(_restoreButton.getHSelf(), &rect);
4669  	    int w = rect.right - rect.left;
4670  	    int h = rect.bottom - rect.top;
4671          RECT nppRect;
4672          GetWindowRect(_pPublicInterface->getHSelf(), &nppRect);
4673          int x = nppRect.right - w - w;
4674          int y = nppRect.top + 1;
4675          ::MoveWindow(_restoreButton.getHSelf(), x, y, w, h, FALSE);
4676          _pEditView->getFocus();
4677  	}
4678  	else	
4679  	{
4680          _restoreButton.setButtonStatus(buttonStatus_postit ^ _restoreButton.getButtonStatus());
4681          _restoreButton.display(false);
4682  		if (!_beforeSpecialView._isFullScreen)
4683  		{
4684  			if (_beforeSpecialView._isMenuShown)
4685  				::SendMessage(_pPublicInterface->getHSelf(), NPPM_HIDEMENU, 0, FALSE);
4686  			_rebarTop.display(true);
4687  			_rebarBottom.display(true);
4688  		}
4689  		if (_beforeSpecialView._isStatusbarShown)
4690  			::SendMessage(_pPublicInterface->getHSelf(), NPPM_HIDESTATUSBAR, 0, FALSE);
4691  		if (_beforeSpecialView._isTabbarShown)
4692  			::SendMessage(_pPublicInterface->getHSelf(), NPPM_HIDETABBAR, 0, FALSE);
4693  		if (!_beforeSpecialView._isAlwaysOnTop)
4694  			::SendMessage(_pPublicInterface->getHSelf(), WM_COMMAND, IDM_VIEW_ALWAYSONTOP, 0);
4695  		if (!_beforeSpecialView._isFullScreen)
4696  		{
4697  			::ShowWindow(_pPublicInterface->getHSelf(), SW_HIDE);
4698  			::SetWindowLongPtr(_pPublicInterface->getHSelf(), GWL_STYLE, _beforeSpecialView._preStyle);
4699  			::SetWindowPos(_pPublicInterface->getHSelf(), HWND_NOTOPMOST,0,0,0,0,SWP_NOMOVE|SWP_NOSIZE|SWP_NOZORDER|SWP_DRAWFRAME|SWP_FRAMECHANGED);
4700  			::ShowWindow(_pPublicInterface->getHSelf(), SW_SHOW);
4701  		}
4702  	}
4703  	_beforeSpecialView._isPostIt = !_beforeSpecialView._isPostIt;
4704  	::SendMessage(_pPublicInterface->getHSelf(), WM_SIZE, 0, 0);
4705  }
4706  void Notepad_plus::distractionFreeToggle()
4707  {
4708  	fullScreenToggle();
4709  	postItToggle();
4710  	const ScintillaViewParams& svp = NppParameters::getInstance().getSVP();
4711  	int paddingLeft = 0;
4712  	int paddingRight = 0;
4713  	if (_beforeSpecialView._isDistractionFree) 
4714  	{
4715  		if (_beforeSpecialView._was2ViewModeOn)
4716  		{
4717  			showView(otherView());
4718  			_beforeSpecialView._was2ViewModeOn = false;
4719  		}
4720  		for (auto i : _beforeSpecialView._pVisibleDockingContainers)
4721  		{
4722  			i->display();
4723  		}
4724  		_dockingManager.resize();
4725  		paddingLeft = svp._paddingLeft;
4726  		paddingRight = svp._paddingRight;
4727  		_restoreButton.setButtonStatus(0);
4728  		_restoreButton.display(false);
4729  	}
4730  	else 
4731  	{
4732  		ScintillaEditView & nonFocusedView = (otherView() == MAIN_VIEW) ? _mainEditView : _subEditView;
4733  		if (nonFocusedView.isVisible())
4734  		{
4735  			hideView(otherView());
4736  			_beforeSpecialView._was2ViewModeOn = true;
4737  		}
4738  		else
4739  		{
4740  			_beforeSpecialView._was2ViewModeOn = false;
4741  		}
4742  		std::vector<DockingCont*> & container = _dockingManager.getContainerInfo();
4743  		_beforeSpecialView._pVisibleDockingContainers.clear();
4744  		for (auto i : container)
4745  		{
4746  			if (i->isVisible())
4747  			{
4748  				_beforeSpecialView._pVisibleDockingContainers.push_back(i);
4749  			}
4750  		}
4751  		for (auto i : _beforeSpecialView._pVisibleDockingContainers)
4752  		{
4753  			i->display(false);
4754  		}
4755  		_dockingManager.resize();
4756  		paddingLeft = paddingRight = svp.getDistractionFreePadding(_pEditView->getWidth());
4757  		_restoreButton.setButtonStatus(buttonStatus_distractionFree);
4758  	}
4759  	_beforeSpecialView._isDistractionFree = !_beforeSpecialView._isDistractionFree;
4760  	_pEditView->execute(SCI_SETMARGINLEFT, 0, paddingLeft);
4761  	_pEditView->execute(SCI_SETMARGINRIGHT, 0, paddingRight);
4762  }
4763  void Notepad_plus::doSynScorll(HWND whichView)
4764  {
4765  	intptr_t column = 0;
4766  	intptr_t line = 0;
4767  	ScintillaEditView *pView;
4768  	intptr_t mainCurrentLine, subCurrentLine;
4769  	intptr_t mxoffset, sxoffset;
4770  	intptr_t pixel;
4771  	intptr_t mainColumn, subColumn;
4772  	if (whichView == _mainEditView.getHSelf())
4773  	{
4774  		if (_syncInfo._isSynScollV)
4775  		{
4776  			mainCurrentLine = _mainEditView.execute(SCI_GETFIRSTVISIBLELINE);
4777  			subCurrentLine = _subEditView.execute(SCI_GETFIRSTVISIBLELINE);
4778  			line = mainCurrentLine - _syncInfo._line - subCurrentLine;
4779  		}
4780  		if (_syncInfo._isSynScollH)
4781  		{
4782  			mxoffset = _mainEditView.execute(SCI_GETXOFFSET);
4783  			pixel = _mainEditView.execute(SCI_TEXTWIDTH, STYLE_DEFAULT, reinterpret_cast<LPARAM>("P"));
4784  			mainColumn = mxoffset/pixel;
4785  			sxoffset = _subEditView.execute(SCI_GETXOFFSET);
4786  			pixel = _subEditView.execute(SCI_TEXTWIDTH, STYLE_DEFAULT, reinterpret_cast<LPARAM>("P"));
4787  			subColumn = sxoffset/pixel;
4788  			column = mainColumn - _syncInfo._column - subColumn;
4789  		}
4790  		pView = &_subEditView;
4791  	}
4792  	else if (whichView == _subEditView.getHSelf())
4793  	{
4794  		if (_syncInfo._isSynScollV)
4795  		{
4796  			mainCurrentLine = _mainEditView.execute(SCI_GETFIRSTVISIBLELINE);
4797  			subCurrentLine = _subEditView.execute(SCI_GETFIRSTVISIBLELINE);
4798  			line = subCurrentLine + _syncInfo._line - mainCurrentLine;
4799  		}
4800  		if (_syncInfo._isSynScollH)
4801  		{
4802  			mxoffset = _mainEditView.execute(SCI_GETXOFFSET);
4803  			pixel = _mainEditView.execute(SCI_TEXTWIDTH, STYLE_DEFAULT, reinterpret_cast<LPARAM>("P"));
4804  			mainColumn = mxoffset/pixel;
4805  			sxoffset = _subEditView.execute(SCI_GETXOFFSET);
4806  			pixel = _subEditView.execute(SCI_TEXTWIDTH, STYLE_DEFAULT, reinterpret_cast<LPARAM>("P"));
4807  			subColumn = sxoffset/pixel;
4808  			column = subColumn + _syncInfo._column - mainColumn;
4809  		}
4810  		pView = &_mainEditView;
4811  	}
4812  	else
4813  		return;
4814  	pView->scroll(column, line);
4815  }
4816  bool Notepad_plus::getIntegralDockingData(tTbData & dockData, int & iCont, bool & isVisible)
4817  {
4818  	DockingManagerData & dockingData = (DockingManagerData &)(NppParameters::getInstance()).getNppGUI()._dockingData;
4819  	for (size_t i = 0, len = dockingData._pluginDockInfo.size(); i < len ; ++i)
4820  	{
4821  		const PluginDlgDockingInfo & pddi = dockingData._pluginDockInfo[i];
4822  		if (!wcsicmp(pddi._name.c_str(), dockData.pszModuleName) && (pddi._internalID == dockData.dlgID))
4823  		{
4824  			iCont				= pddi._currContainer;
4825  			isVisible			= pddi._isVisible;
4826  			dockData.iPrevCont	= pddi._prevContainer;
4827  			if (dockData.iPrevCont != -1)
4828  			{
4829  				int cont = (pddi._currContainer < DOCKCONT_MAX ? pddi._prevContainer : pddi._currContainer);
4830  				RECT rc;
4831  				if (dockingData.getFloatingRCFrom(cont, rc))
4832  					dockData.rcFloat = rc;
4833  			}
4834  			return true;
4835  		}
4836  	}
4837  	return false;
4838  }
4839  void Notepad_plus::getCurrentOpenedFiles(Session & session, bool includUntitledDoc)
4840  {
4841  	_mainEditView.saveCurrentPos();	
4842  	_subEditView.saveCurrentPos();	
4843  	session._activeView = currentView();
4844  	session._activeMainIndex = _mainDocTab.getCurrentTabIndex();
4845  	session._activeSubIndex = _subDocTab.getCurrentTabIndex();
4846  	Document oldDoc = _invisibleEditView.execute(SCI_GETDOCPOINTER);
4847  	const int nbElem = 2;
4848  	DocTabView* docTab[nbElem]{};
4849  	docTab[0] = &_mainDocTab;
4850  	docTab[1] = &_subDocTab;
4851  	for (size_t k = 0; k < nbElem; ++k)
4852  	{
4853  		for (size_t i = 0, len = docTab[k]->nbItem(); i < len ; ++i)
4854  		{
4855  			BufferID bufID = docTab[k]->getBufferByIndex(i);
4856  			ScintillaEditView *editView = k == 0 ? &_mainEditView : &_subEditView;
4857  			size_t activeIndex = k == 0 ? session._activeMainIndex : session._activeSubIndex;
4858  			vector<sessionFileInfo> *viewFiles = (vector<sessionFileInfo> *)(k == 0?&(session._mainViewFiles):&(session._subViewFiles));
4859  			Buffer * buf = MainFileManager.getBufferByID(bufID);
4860  			if (buf->isUntitled() && buf->docLength() == 0)
4861  				continue;
4862  			if (!includUntitledDoc)
4863  				if (!PathFileExists(buf->getFullPathName()))
4864  					continue;
4865  			wstring	languageName = getLangFromMenu(buf);
4866  			if (languageName.empty()) 
4867  			{
4868  				NppParameters& nppParam = NppParameters::getInstance();
4869  				const NppGUI& nppGUI = nppParam.getNppGUI();
4870  				for (size_t k = 0; k < nppGUI._excludedLangList.size(); ++k) 
4871  				{
4872  					if (buf->getLangType() == nppGUI._excludedLangList[k]._langType)
4873  					{
4874  						languageName = nppGUI._excludedLangList[k]._langName;
4875  						break;
4876  					}
4877  				}
4878  			}
4879  			const wchar_t* langName = languageName.c_str();
4880  			sessionFileInfo sfi(buf->getFullPathName(), langName, buf->getEncoding(), buf->getUserReadOnly(), buf->getPosition(editView), buf->getBackupFileName().c_str(), buf->getLastModifiedTimestamp(), buf->getMapPosition());
4881  			sfi._isMonitoring = buf->isMonitoringOn();
4882  			sfi._individualTabColour = docTab[k]->getIndividualTabColour(static_cast<int>(i));
4883  			_invisibleEditView.execute(SCI_SETDOCPOINTER, 0, buf->getDocument());
4884  			size_t maxLine = static_cast<size_t>(_invisibleEditView.execute(SCI_GETLINECOUNT));
4885  			for (size_t j = 0 ; j < maxLine ; ++j)
4886  			{
4887  				if ((_invisibleEditView.execute(SCI_MARKERGET, j) & (1 << MARK_BOOKMARK)) != 0)
4888  				{
4889  					sfi._marks.push_back(j);
4890  				}
4891  			}
4892  			if (i == activeIndex)
4893  			{
4894  				editView->getCurrentFoldStates(sfi._foldStates);
4895  			}
4896  			else
4897  			{
4898  				sfi._foldStates = buf->getHeaderLineState(editView);
4899  			}
4900  			viewFiles->push_back(sfi);
4901  		}
4902  	}
4903  	_invisibleEditView.execute(SCI_SETDOCPOINTER, 0, oldDoc);
4904  }
4905  bool Notepad_plus::str2Cliboard(const generic_string & str2cpy)
4906  {
4907  	return str2Clipboard(str2cpy, _pPublicInterface->getHSelf());
4908  }
4909  bool Notepad_plus::emergency(const generic_string& emergencySavedDir)
4910  {
4911      ::CreateDirectory(emergencySavedDir.c_str(), NULL);
4912  	return dumpFiles(emergencySavedDir.c_str(), TEXT("File"));
4913  }
4914  bool Notepad_plus::dumpFiles(const TCHAR * outdir, const TCHAR * fileprefix)
4915  {
4916  	bool somethingsaved = false;
4917  	bool somedirty = false;
4918  	TCHAR savePath[MAX_PATH] = { '\0' };
4919  	for (size_t i = 0; i < MainFileManager.getNbBuffers(); ++i)
4920  	{
4921  		Buffer * docbuf = MainFileManager.getBufferByIndex(i);
4922  		if (!docbuf->isDirty())	
4923  			continue;
4924  		else
4925  			somedirty = true;
4926  		const TCHAR * unitext = (docbuf->getUnicodeMode() != uni8Bit)?TEXT("_utf8"):TEXT("");
4927  		wsprintf(savePath, TEXT("%s\\%s%03d%s.dump"), outdir, fileprefix, static_cast<int>(i), unitext);
4928  		SavingStatus res = MainFileManager.saveBuffer(docbuf->getID(), savePath);
4929  		somethingsaved |= (res == SavingStatus::SaveOK);
4930  	}
4931  	return somethingsaved || !somedirty;
4932  }
4933  void Notepad_plus::drawTabbarColoursFromStylerArray()
4934  {
4935  	Style *stActText = getStyleFromName(TABBAR_ACTIVETEXT);
4936  	if (stActText && static_cast<long>(stActText->_fgColor) != -1)
4937  		TabBarPlus::setColour(stActText->_fgColor, TabBarPlus::activeText);
4938  	Style *stActfocusTop = getStyleFromName(TABBAR_ACTIVEFOCUSEDINDCATOR);
4939  	if (stActfocusTop && static_cast<long>(stActfocusTop->_fgColor) != -1)
4940  		TabBarPlus::setColour(stActfocusTop->_fgColor, TabBarPlus::activeFocusedTop);
4941  	Style *stActunfocusTop = getStyleFromName(TABBAR_ACTIVEUNFOCUSEDINDCATOR);
4942  	if (stActunfocusTop && static_cast<long>(stActunfocusTop->_fgColor) != -1)
4943  		TabBarPlus::setColour(stActunfocusTop->_fgColor, TabBarPlus::activeUnfocusedTop);
4944  	Style *stInact = getStyleFromName(TABBAR_INACTIVETEXT);
4945  	if (stInact && static_cast<long>(stInact->_fgColor) != -1)
4946  		TabBarPlus::setColour(stInact->_fgColor, TabBarPlus::inactiveText);
4947  	if (stInact && static_cast<long>(stInact->_bgColor) != -1)
4948  		TabBarPlus::setColour(stInact->_bgColor, TabBarPlus::inactiveBg);
4949  }
4950  void Notepad_plus::drawAutocompleteColoursFromTheme(COLORREF fgColor, COLORREF bgColor)
4951  {
4952  	if (bgColor == 0xFFFFFF)
4953  	{
4954  		COLORREF autocompleteBg = ::GetSysColor(COLOR_WINDOW);
4955  		COLORREF selectedBg = ::GetSysColor(COLOR_HIGHLIGHT);
4956  		COLORREF autocompleteText = ::GetSysColor(COLOR_WINDOWTEXT);
4957  		COLORREF selectedText = ::GetSysColor(COLOR_HIGHLIGHTTEXT);
4958  		AutoCompletion::setColour(autocompleteBg, AutoCompletion::AutocompleteColorIndex::autocompleteBg);
4959  		AutoCompletion::setColour(selectedBg, AutoCompletion::AutocompleteColorIndex::selectedBg);
4960  		AutoCompletion::setColour(autocompleteText, AutoCompletion::AutocompleteColorIndex::autocompleteText);
4961  		AutoCompletion::setColour(selectedText, AutoCompletion::AutocompleteColorIndex::selectedText);
4962  		COLORREF colourBG = bgColor;
4963  		COLORREF colourUnSel = RGB(0x80, 0x80, 0x80);
4964  		COLORREF colourSel = RGB(0, 0, 0x80);
4965  		AutoCompletion::setColour(colourBG, AutoCompletion::AutocompleteColorIndex::calltipBg);
4966  		AutoCompletion::setColour(colourUnSel, AutoCompletion::AutocompleteColorIndex::calltipText);
4967  		AutoCompletion::setColour(colourSel, AutoCompletion::AutocompleteColorIndex::calltipHighlight);
4968  		return;
4969  	}
4970  	int rbv = GetRValue(bgColor);
4971  	int gbv = GetGValue(bgColor);
4972  	int bbv = GetBValue(bgColor);
4973  	int rfv = GetRValue(fgColor);
4974  	int gfv = GetGValue(fgColor);
4975  	int bfv = GetBValue(fgColor);
4976  	COLORREF bgDarker = RGB(rbv - 20 <= 0 ? 0 : rbv - 20, gbv - 20 <= 0 ? 0 : gbv - 20, bbv - 20 <= 0 ? 0 : bbv - 20);
4977  	if (bgColor == RGB(0, 0, 0)) 
4978  		bgDarker = RGB(20, 20, 20); 
4979  	COLORREF fgDarker = RGB(rfv - 20 <= 0 ? 0 : rfv - 20, gfv - 20 <= 0 ? 0 : gfv - 20, bfv - 20 <= 0 ? 0 : bfv - 20);
4980  	COLORREF fgLigher = RGB(rfv + 20 >= 255 ? 255 : rfv + 20, gfv + 20 >= 255 ? 255 : gfv + 20, bfv + 20 >= 255 ? 255 : bfv + 20);
4981  	AutoCompletion::setColour(bgDarker, AutoCompletion::AutocompleteColorIndex::autocompleteBg);
4982  	AutoCompletion::setColour(bgColor, AutoCompletion::AutocompleteColorIndex::selectedBg);
4983  	AutoCompletion::setColour(fgDarker, AutoCompletion::AutocompleteColorIndex::autocompleteText);
4984  	AutoCompletion::setColour(fgColor, AutoCompletion::AutocompleteColorIndex::selectedText);
4985  	AutoCompletion::setColour(bgDarker, AutoCompletion::AutocompleteColorIndex::calltipBg);
4986  	AutoCompletion::setColour(fgDarker, AutoCompletion::AutocompleteColorIndex::calltipText);
4987  	AutoCompletion::setColour(fgLigher, AutoCompletion::AutocompleteColorIndex::calltipHighlight);
4988  }
4989  void Notepad_plus::drawDocumentMapColoursFromStylerArray()
4990  {
4991  	Style* docMap = getStyleFromName(VIEWZONE_DOCUMENTMAP);
4992  	if (docMap && static_cast<long>(docMap->_fgColor) != -1)
4993  		ViewZoneDlg::setColour(docMap->_fgColor, ViewZoneDlg::ViewZoneColorIndex::focus);
4994  	if (docMap && static_cast<long>(docMap->_bgColor) != -1)
4995  		ViewZoneDlg::setColour(docMap->_bgColor, ViewZoneDlg::ViewZoneColorIndex::frost);
4996  }
4997  void Notepad_plus::prepareBufferChangedDialog(Buffer * buffer)
4998  {
4999  	if (::IsIconic(_pPublicInterface->getHSelf()))
5000  		::ShowWindow(_pPublicInterface->getHSelf(), SW_RESTORE);
5001  	int index = _pDocTab->getIndexByBuffer(buffer->getID());
5002  	int iView = currentView();
5003  	if (index == -1)
5004  		iView = otherView();
5005  	activateBuffer(buffer->getID(), iView);	
5006  	auto curPos = _pEditView->execute(SCI_GETCURRENTPOS);
5007  	::PostMessage(_pEditView->getHSelf(), WM_LBUTTONDOWN, 0, 0);
5008  	::PostMessage(_pEditView->getHSelf(), WM_LBUTTONUP, 0, 0);
5009  	::PostMessage(_pEditView->getHSelf(), SCI_SETSEL, curPos, curPos);
5010  }
5011  void Notepad_plus::notifyBufferChanged(Buffer * buffer, int mask)
5012  {
5013  	NppParameters& nppParam = NppParameters::getInstance();
5014  	const NppGUI & nppGUI = nppParam.getNppGUI();
5015  	_mainEditView.bufferUpdated(buffer, mask);
5016  	_subEditView.bufferUpdated(buffer, mask);
5017  	_mainDocTab.bufferUpdated(buffer, mask);
5018  	_subDocTab.bufferUpdated(buffer, mask);
5019  	bool mainActive = (_mainEditView.getCurrentBuffer() == buffer);
5020  	bool subActive = (_subEditView.getCurrentBuffer() == buffer);
5021  	if (mask & BufferChangeStatus)
5022  	{	
5023  		switch(buffer->getStatus())
5024  		{
5025  			case DOC_UNNAMED: 	
5026  			case DOC_REGULAR: 	
5027  			{
5028  				break;
5029  			}
5030  			case DOC_MODIFIED:	
5031  			{
5032  				if (buffer->isMonitoringOn())
5033  					break;
5034  				bool autoUpdate = (nppGUI._fileAutoDetection & cdAutoUpdate) ? true : false;
5035  				if (!autoUpdate || buffer->isDirty())
5036  				{
5037  					prepareBufferChangedDialog(buffer);
5038  					if (doReloadOrNot(buffer->getFullPathName(), buffer->isDirty()) != IDYES)
5039  					{
5040  						buffer->setDirty(true);
5041  						buffer->setUnsync(true);
5042  						break;	
5043  					}
5044  				}
5045  				buffer->setLoadedDirty(false);
5046  				buffer->setUnsync(false);
5047  				doReload(buffer->getID(), false);
5048  				if (mainActive || subActive)
5049  				{
5050  					performPostReload(mainActive?MAIN_VIEW:SUB_VIEW);
5051  				}
5052  				break;
5053  			}
5054  			case DOC_NEEDRELOAD: 
5055  			{
5056  				doReload(buffer->getID(), false);
5057  				if (buffer == _mainEditView.getCurrentBuffer())
5058  				{
5059  					_mainEditView.setPositionRestoreNeeded(false);
5060  					_mainEditView.execute(SCI_DOCUMENTEND);
5061  				}
5062  				if (buffer == _subEditView.getCurrentBuffer())
5063  				{
5064  					_subEditView.setPositionRestoreNeeded(false);
5065  					_subEditView.execute(SCI_DOCUMENTEND);
5066  				}
5067  				break;
5068  			}
5069  			case DOC_DELETED: 	
5070  			{
5071  				prepareBufferChangedDialog(buffer);
5072  				SCNotification scnN{};
5073  				scnN.nmhdr.code = NPPN_FILEDELETED;
5074  				scnN.nmhdr.hwndFrom = _pPublicInterface->getHSelf();
5075  				scnN.nmhdr.idFrom = (uptr_t)buffer->getID();
5076  				_pluginsManager.notify(&scnN);
5077  				int doCloseDoc = doCloseOrNot(buffer->getFullPathName()) == IDNO;
5078  				if (doCloseDoc)
5079  				{
5080  					bool isSnapshotMode = nppGUI.isSnapshotMode();
5081  					doClose(buffer->getID(), otherView(), isSnapshotMode);
5082  					doClose(buffer->getID(), currentView(), isSnapshotMode);
5083  					return;
5084  				}
5085  				else
5086  				{
5087  					buffer->setUnsync(true);
5088  				}
5089  				break;
5090  			}
5091  		}
5092  	}
5093      if (mask & (BufferChangeReadonly))
5094  	{
5095  		checkDocState();
5096  		bool isSysReadOnly = buffer->getFileReadOnly();
5097  		bool isUserReadOnly = buffer->getUserReadOnly();
5098  		bool isDirty = buffer->isDirty();
5099  		SCNotification scnN{};
5100  		scnN.nmhdr.hwndFrom = (void *)buffer->getID();
5101  		scnN.nmhdr.idFrom = (uptr_t)  ((isSysReadOnly || isUserReadOnly? DOCSTATUS_READONLY : 0) | (isDirty ? DOCSTATUS_BUFFERDIRTY : 0));
5102  		scnN.nmhdr.code = NPPN_READONLYCHANGED;
5103  		_pluginsManager.notify(&scnN);
5104  	}
5105  	if (_pDocumentListPanel)
5106  		_pDocumentListPanel->setItemIconStatus(buffer);
5107  	if (!mainActive && !subActive)
5108  	{
5109  		return;
5110  	}
5111  	if (mask & (BufferChangeLanguage))
5112  	{
5113  		if (mainActive)
5114  			_autoCompleteMain.setLanguage(buffer->getLangType());
5115  		if (subActive)
5116  			_autoCompleteSub.setLanguage(buffer->getLangType());
5117  	}
5118  	if ((currentView() == MAIN_VIEW) && !mainActive)
5119  		return;
5120  	if ((currentView() == SUB_VIEW) && !subActive)
5121  		return;
5122  	if (mask & (BufferChangeDirty|BufferChangeFilename))
5123  	{
5124  		if (mask & BufferChangeFilename)
5125  			command(IDM_VIEW_REFRESHTABAR);
5126  		checkDocState();
5127  		setTitle();
5128  		generic_string dir(buffer->getFullPathName());
5129  		PathRemoveFileSpec(dir);
5130  		setWorkingDir(dir.c_str());
5131  	}
5132  	if (mask & (BufferChangeLanguage))
5133  	{
5134  		checkLangsMenu(-1);	
5135  		setLangStatus(buffer->getLangType());
5136  		if (_mainEditView.getCurrentBuffer() == buffer)
5137  			_autoCompleteMain.setLanguage(buffer->getLangType());
5138  		else if (_subEditView.getCurrentBuffer() == buffer)
5139  			_autoCompleteSub.setLanguage(buffer->getLangType());
5140  		SCNotification scnN{};
5141  		scnN.nmhdr.code = NPPN_LANGCHANGED;
5142  		scnN.nmhdr.hwndFrom = _pPublicInterface->getHSelf();
5143  		scnN.nmhdr.idFrom = (uptr_t)_pEditView->getCurrentBufferID();
5144  		_pluginsManager.notify(&scnN);
5145  	}
5146  	if (mask & (BufferChangeFormat|BufferChangeLanguage|BufferChangeUnicode))
5147  	{
5148  		updateStatusBar();
5149  		checkUnicodeMenuItems(&bsol;*buffer->getUnicodeMode()*/);
5150  		setUniModeText();
5151  		setDisplayFormat(buffer->getEolFormat());
5152  		enableConvertMenuItems(buffer->getEolFormat());
5153  	}
5154  	if (mask & (BufferChangeUnicode))
5155  	{
5156  		_mainEditView.maintainStateForNpc();
5157  		_subEditView.maintainStateForNpc();
5158  	}
5159  }
5160  void Notepad_plus::notifyBufferActivated(BufferID bufid, int view)
5161  {
5162  	Buffer * buf = MainFileManager.getBufferByID(bufid);
5163  	buf->increaseRecentTag();
5164  	if (view == MAIN_VIEW)
5165  	{
5166  		_autoCompleteMain.setLanguage(buf->getLangType());
5167  	}
5168  	else if (view == SUB_VIEW)
5169  	{
5170  		_autoCompleteSub.setLanguage(buf->getLangType());
5171  	}
5172  	if (view != currentView())
5173  		return;	
5174  	checkDocState();
5175  	dynamicCheckMenuAndTB();
5176  	setLangStatus(buf->getLangType());
5177  	updateStatusBar();
5178  	checkUnicodeMenuItems(&bsol;*buf->getUnicodeMode()*/);
5179  	setUniModeText();
5180  	setDisplayFormat(buf->getEolFormat());
5181  	enableConvertMenuItems(buf->getEolFormat());
5182  	generic_string dir(buf->getFullPathName());
5183  	PathRemoveFileSpec(dir);
5184  	setWorkingDir(dir.c_str());
5185  	setTitle();
5186  	::InvalidateRect(_mainDocTab.getHSelf(), NULL, FALSE);
5187  	::InvalidateRect(_subDocTab.getHSelf(), NULL, FALSE);
5188  	SCNotification scnN{};
5189  	scnN.nmhdr.code = NPPN_BUFFERACTIVATED;
5190  	scnN.nmhdr.hwndFrom = _pPublicInterface->getHSelf();
5191  	scnN.nmhdr.idFrom = (uptr_t)bufid;
5192  	_pluginsManager.notify(&scnN);
5193  	if (_pDocumentListPanel)
5194  	{
5195  		_pDocumentListPanel->activateItem(bufid, currentView());
5196  	}
5197  	if (_pDocMap && (!_pDocMap->isClosed()) && _pDocMap->isVisible())
5198  	{
5199  		_pDocMap->reloadMap();
5200  		_pDocMap->setSyntaxHiliting();
5201  	}
5202  	if (_pFuncList && (!_pFuncList->isClosed()) && _pFuncList->isVisible())
5203  	{
5204  		_pFuncList->reload();
5205  	}
5206  	_linkTriggered = true;
5207  }
5208  std::vector<generic_string> Notepad_plus::loadCommandlineParams(const TCHAR * commandLine, const CmdLineParamsDTO * pCmdParams)
5209  {
5210  	if (!commandLine || ! pCmdParams)
5211  		return std::vector<generic_string>();
5212  	NppParameters& nppParams = NppParameters::getInstance();
5213  	const NppGUI& nppGUI = nppParams.getNppGUI();
5214  	FileNameStringSplitter fnss(commandLine);
5215  	if (pCmdParams->_isSessionFile && fnss.size() == 1)
5216  	{
5217  		Session session2Load;
5218  		if (nppParams.loadSession(session2Load, fnss.getFileName(0)))
5219  		{
5220  			const bool isSnapshotMode = false;
5221  			const bool shouldLoadFileBrowser = true;
5222  			if ((nppGUI._multiInstSetting == multiInstOnSession) || (nppGUI._multiInstSetting == multiInst))
5223  				nppParams.setLoadedSessionFilePath(fnss.getFileName(0));
5224  			loadSession(session2Load, isSnapshotMode, shouldLoadFileBrowser);
5225  		}
5226  		return std::vector<generic_string>();
5227  	}
5228   	LangType lt = pCmdParams->_langType;
5229  	generic_string udl = pCmdParams->_udlName;
5230  	intptr_t lineNumber =  pCmdParams->_line2go;
5231  	intptr_t columnNumber = pCmdParams->_column2go;
5232  	intptr_t positionNumber = pCmdParams->_pos2go;
5233  	bool recursive = pCmdParams->_isRecursive;
5234  	bool readOnly = pCmdParams->_isReadOnly;
5235  	bool openFoldersAsWorkspace = pCmdParams->_openFoldersAsWorkspace;
5236  	bool monitorFiles = pCmdParams->_monitorFiles;
5237  	if (openFoldersAsWorkspace)
5238  	{
5239  		return fnss.getFileNames();
5240  	}
5241  	BufferID lastOpened = BUFFER_INVALID;
5242  	for (int i = 0, len = fnss.size(); i < len ; ++i)
5243  	{
5244  		const TCHAR *pFn = fnss.getFileName(i);
5245  		if (!pFn) return std::vector<generic_string>();
5246  		BufferID bufID = doOpen(pFn, recursive, readOnly);
5247  		if (bufID == BUFFER_INVALID)	
5248  			continue;
5249  		lastOpened = bufID;
5250  		Buffer* pBuf = MainFileManager.getBufferByID(bufID);
5251  		if (!udl.empty())
5252  		{
5253  			pBuf->setLangType(L_USER, udl.c_str());
5254  		}
5255  		else if (lt != L_EXTERNAL && lt < nppParams.L_END)
5256  		{
5257  			pBuf->setLangType(lt);
5258  		}
5259  		if (lineNumber >= 0 || positionNumber >= 0)
5260  		{
5261  			int iView = currentView();	
5262  			switchToFile(bufID);	
5263  			if (positionNumber >= 0)
5264  			{
5265  				if (positionNumber > 0)
5266  				{
5267  					auto before = _pEditView->execute(SCI_POSITIONBEFORE, positionNumber);
5268  					positionNumber = _pEditView->execute(SCI_POSITIONAFTER, before);
5269  				}
5270  				_pEditView->execute(SCI_GOTOPOS, positionNumber);
5271  			}
5272  			else if (columnNumber < 0)
5273  			{
5274  				_pEditView->execute(SCI_GOTOLINE, lineNumber - 1);
5275  			}
5276  			else
5277  			{
5278  				auto pos = _pEditView->execute(SCI_FINDCOLUMN, lineNumber - 1, columnNumber - 1);
5279  				_pEditView->execute(SCI_GOTOPOS, pos);
5280  			}
5281  			_pEditView->scrollPosToCenter(_pEditView->execute(SCI_GETCURRENTPOS));
5282  			switchEditViewTo(iView);	
5283  		}
5284  		if (monitorFiles)
5285  		{
5286  			monitoringStartOrStopAndUpdateUI(pBuf, true);
5287  			createMonitoringThread(pBuf);
5288  		}
5289  	}
5290  	if (lastOpened != BUFFER_INVALID)
5291      {
5292  		switchToFile(lastOpened);
5293  	}
5294  	return fnss.getFileNames();
5295  }
5296  void Notepad_plus::setFindReplaceFolderFilter(const TCHAR *dir, const TCHAR *filter)
5297  {
5298  	generic_string fltr;
5299  	NppParameters& nppParam = NppParameters::getInstance();
5300  	FindHistory & findHistory = nppParam.getFindHistory();
5301  	if (!dir && findHistory._isFolderFollowDoc)
5302  	{
5303  		dir = nppParam.getWorkingDir();
5304  	}
5305  	if (!filter && findHistory._isFilterFollowDoc)
5306  	{
5307  		const TCHAR *ext = NULL;
5308  		LangType lt = _pEditView->getCurrentBuffer()->getLangType();
5309  		if (lt == L_USER)
5310  		{
5311  			Buffer * buf = _pEditView->getCurrentBuffer();
5312  			UserLangContainer * userLangContainer = nppParam.getULCFromName(buf->getUserDefineLangName());
5313  			if (userLangContainer)
5314  				ext = userLangContainer->getExtention();
5315  		}
5316  		else
5317  		{
5318  			ext = nppParam.getLangExtFromLangType(lt);
5319  		}
5320  		if (ext && ext[0])
5321  		{
5322  			fltr = TEXT("");
5323  			vector<generic_string> vStr;
5324  			cutString(ext, vStr);
5325  			for (size_t i = 0 ,len = vStr.size(); i < len; ++i)
5326  			{
5327  				fltr += TEXT("*.");
5328  				fltr += vStr[i] + TEXT(" ");
5329  			}
5330  		}
5331  		else
5332  		{
5333  			fltr = TEXT("*.*");
5334  		}
5335  		filter = fltr.c_str();
5336  	}
5337  	_findReplaceDlg.setFindInFilesDirFilter(dir, filter);
5338  }
5339  vector<generic_string> Notepad_plus::addNppComponents(const TCHAR *destDir, const TCHAR *extFilterName, const TCHAR *extFilter)
5340  {
5341  	CustomFileDialog fDlg(_pPublicInterface->getHSelf());
5342  	fDlg.setExtFilter(extFilterName, extFilter);
5343      vector<generic_string> copiedFiles;
5344  	const auto& fns = fDlg.doOpenMultiFilesDlg();
5345      if (!fns.empty())
5346      {
5347  		generic_string destDirName = (NppParameters::getInstance()).getNppPath();
5348          pathAppend(destDirName, destDir);
5349          if (!::PathFileExists(destDirName.c_str()))
5350          {
5351              ::CreateDirectory(destDirName.c_str(), NULL);
5352          }
5353          destDirName += TEXT("\\");
5354          size_t sz = fns.size();
5355          for (size_t i = 0 ; i < sz ; ++i)
5356          {
5357              if (::PathFileExists(fns.at(i).c_str()))
5358              {
5359                  generic_string destName = destDirName;
5360                  destName += ::PathFindFileName(fns.at(i).c_str());
5361                  if (::CopyFile(fns.at(i).c_str(), destName.c_str(), FALSE))
5362                      copiedFiles.push_back(destName.c_str());
5363              }
5364          }
5365      }
5366      return copiedFiles;
5367  }
5368  vector<generic_string> Notepad_plus::addNppPlugins(const TCHAR *extFilterName, const TCHAR *extFilter)
5369  {
5370  	CustomFileDialog fDlg(_pPublicInterface->getHSelf());
5371      fDlg.setExtFilter(extFilterName, extFilter);
5372      vector<generic_string> copiedFiles;
5373  	const auto& fns = fDlg.doOpenMultiFilesDlg();
5374  	if (!fns.empty())
5375      {
5376  		generic_string destDirName = (NppParameters::getInstance()).getPluginRootDir();
5377          if (!::PathFileExists(destDirName.c_str()))
5378          {
5379              ::CreateDirectory(destDirName.c_str(), NULL);
5380          }
5381          size_t sz = fns.size();
5382          for (size_t i = 0 ; i < sz ; ++i)
5383          {
5384              if (::PathFileExists(fns.at(i).c_str()))
5385              {
5386                  generic_string destName = destDirName;
5387  				generic_string nameExt = ::PathFindFileName(fns.at(i).c_str());
5388  				auto pos = nameExt.find_last_of(TEXT("."));
5389  				if (pos == generic_string::npos)
5390  					continue;
5391  				generic_string name = nameExt.substr(0, pos);
5392  				pathAppend(destName, name);
5393  				if (!::PathFileExists(destName.c_str()))
5394  				{
5395  					::CreateDirectory(destName.c_str(), NULL);
5396  				}
5397  				pathAppend(destName, nameExt);
5398                  if (::CopyFile(fns.at(i).c_str(), destName.c_str(), FALSE))
5399                      copiedFiles.push_back(destName.c_str());
5400              }
5401          }
5402      }
5403      return copiedFiles;
5404  }
5405  void Notepad_plus::setWorkingDir(const TCHAR *dir)
5406  {
5407  	NppParameters& params = NppParameters::getInstance();
5408  	if (params.getNppGUI()._openSaveDir == dir_last)
5409  		return;
5410  	if (params.getNppGUI()._openSaveDir == dir_userDef)
5411  	{
5412  		params.setWorkingDir(NULL);
5413  	}
5414  	else if (dir && PathIsDirectory(dir))
5415  	{
5416  		params.setWorkingDir(dir);
5417  	}
5418  }
5419  int Notepad_plus::getLangFromMenuName(const TCHAR * langName)
5420  {
5421  	int	id	= 0;
5422  	TCHAR menuLangName[menuItemStrLenMax];
5423  	for ( int i = IDM_LANG_C; i <= IDM_LANG_USER; ++i )
5424  		if ( ::GetMenuString( _mainMenuHandle, i, menuLangName, menuItemStrLenMax, MF_BYCOMMAND ) )
5425  			if ( !lstrcmp( langName, menuLangName ) )
5426  			{
5427  				id	= i;
5428  				break;
5429  			}
5430  	if ( id == 0 )
5431  	{
5432  		for ( int i = IDM_LANG_USER + 1; i <= IDM_LANG_USER_LIMIT; ++i )
5433  			if ( ::GetMenuString( _mainMenuHandle, i, menuLangName, menuItemStrLenMax, MF_BYCOMMAND ) )
5434  				if ( !lstrcmp( langName, menuLangName ) )
5435  				{
5436  					id	= i;
5437  					break;
5438  				}
5439  	}
5440  	return id;
5441  }
5442  generic_string Notepad_plus::getLangFromMenu(const Buffer * buf)
5443  {
5444  	int	id;
5445  	generic_string userLangName;
5446  	TCHAR menuLangName[menuItemStrLenMax]{};
5447  	id = (NppParameters::getInstance()).langTypeToCommandID( buf->getLangType() );
5448  	if ( ( id != IDM_LANG_USER ) || !( buf->isUserDefineLangExt() ) )
5449  	{
5450  		::GetMenuString(_mainMenuHandle, id, menuLangName, menuItemStrLenMax, MF_BYCOMMAND);
5451  		userLangName = menuLangName;
5452  	}
5453  	else
5454  	{
5455  		userLangName = buf->getUserDefineLangName();
5456  	}
5457  	return	userLangName;
5458  }
5459  Style * Notepad_plus::getStyleFromName(const TCHAR *styleName)
5460  {
5461  	return NppParameters::getInstance().getMiscStylerArray().findByName(styleName);
5462  }
5463  bool Notepad_plus::noOpenedDoc() const
5464  {
5465  	if (_mainDocTab.isVisible() && _subDocTab.isVisible())
5466  		return false;
5467  	if (_pDocTab->nbItem() == 1)
5468  	{
5469  		BufferID buffer = _pDocTab->getBufferByIndex(0);
5470  		Buffer * buf = MainFileManager.getBufferByID(buffer);
5471  		if (!buf->isDirty() && buf->isUntitled())
5472  			return true;
5473  	}
5474  	return false;
5475  }
5476  bool Notepad_plus::reloadLang()
5477  {
5478  	NppParameters& nppParam = NppParameters::getInstance();
5479  	if (!nppParam.reloadLang())
5480  	{
5481  		return false;
5482  	}
5483  	TiXmlDocumentA *nativeLangDocRootA = nppParam.getNativeLangA();
5484  	if (!nativeLangDocRootA)
5485  	{
5486  		return false;
5487  	}
5488      _nativeLangSpeaker.init(nativeLangDocRootA, true);
5489      nppParam.reloadContextMenuFromXmlTree(_mainMenuHandle, _pluginsManager.getMenuHandle());
5490  	_nativeLangSpeaker.changeMenuLang(_mainMenuHandle);
5491      ::DrawMenuBar(_pPublicInterface->getHSelf());
5492  	vector<MenuItemUnit> & tmp = nppParam.getContextMenuItems();
5493  	size_t len = tmp.size();
5494  	TCHAR menuName[menuItemStrLenMax];
5495  	for (size_t i = 0 ; i < len ; ++i)
5496  	{
5497  		if (tmp[i]._itemName == TEXT(""))
5498  		{
5499  			::GetMenuString(_mainMenuHandle, tmp[i]._cmdID, menuName, menuItemStrLenMax, MF_BYCOMMAND);
5500  			tmp[i]._itemName = purgeMenuItemString(menuName);
5501  		}
5502  	}
5503  	updateCommandShortcuts();
5504  	_accelerator.updateFullMenu();
5505  	_scintaccelerator.updateKeys();
5506  	if (_tabPopupMenu.isCreated())
5507  	{
5508  		_nativeLangSpeaker.changeLangTabContextMenu(_tabPopupMenu.getMenuHandle());
5509  	}
5510  	if (_tabPopupDropMenu.isCreated())
5511  	{
5512  		_nativeLangSpeaker.changeLangTabDropContextMenu(_tabPopupDropMenu.getMenuHandle());
5513  	}
5514  	if (_fileSwitcherMultiFilePopupMenu.isCreated())
5515  	{
5516  	}
5517  	if (_preference.isCreated())
5518  	{
5519  		_nativeLangSpeaker.changePrefereceDlgLang(_preference);
5520  	}
5521  	if (_configStyleDlg.isCreated())
5522  	{
5523          _nativeLangSpeaker.changeConfigLang(_configStyleDlg.getHSelf());
5524  	}
5525  	if (_findReplaceDlg.isCreated())
5526  	{
5527  		_nativeLangSpeaker.changeFindReplaceDlgLang(_findReplaceDlg);
5528  	}
5529  	if (_goToLineDlg.isCreated())
5530  	{
5531  		_nativeLangSpeaker.changeDlgLang(_goToLineDlg.getHSelf(), "GoToLine");
5532  	}
5533  	if (_runDlg.isCreated())
5534  	{
5535  		_nativeLangSpeaker.changeDlgLang(_runDlg.getHSelf(), "Run");
5536  	}
5537  	if (_md5FromFilesDlg.isCreated())
5538  	{
5539  		_nativeLangSpeaker.changeDlgLang(_md5FromFilesDlg.getHSelf(), "MD5FromFilesDlg");
5540  	}
5541  	if (_md5FromTextDlg.isCreated())
5542  	{
5543  		_nativeLangSpeaker.changeDlgLang(_md5FromTextDlg.getHSelf(), "MD5FromTextDlg");
5544  	}
5545  	if (_sha2FromFilesDlg.isCreated())
5546  	{
5547  		_nativeLangSpeaker.changeDlgLang(_sha2FromFilesDlg.getHSelf(), "SHA256FromFilesDlg");
5548  	}
5549  	if (_sha2FromTextDlg.isCreated())
5550  	{
5551  		_nativeLangSpeaker.changeDlgLang(_sha2FromTextDlg.getHSelf(), "SHA256FromTextDlg");
5552  	}
5553  	if (_runMacroDlg.isCreated())
5554  	{
5555  		_nativeLangSpeaker.changeDlgLang(_runMacroDlg.getHSelf(), "MultiMacro");
5556  	}
5557  	if (_incrementFindDlg.isCreated())
5558  	{
5559  		_nativeLangSpeaker.changeDlgLang(_incrementFindDlg.getHSelf(), "IncrementalFind");
5560  	}
5561  	if (_findCharsInRangeDlg.isCreated())
5562  	{
5563  		_nativeLangSpeaker.changeDlgLang(_findCharsInRangeDlg.getHSelf(), "FindCharsInRange");
5564  	}
5565  	if (_colEditorDlg.isCreated())
5566  	{
5567          _nativeLangSpeaker.changeDlgLang(_colEditorDlg.getHSelf(), "ColumnEditor");
5568  	}
5569  	if (_pluginsAdminDlg.isCreated())
5570  	{
5571  		_nativeLangSpeaker.changePluginsAdminDlgLang(_pluginsAdminDlg);
5572  	}
5573  	UserDefineDialog *udd = _pEditView->getUserDefineDlg();
5574  	if (udd->isCreated())
5575  	{
5576  		_nativeLangSpeaker.changeUserDefineLang(udd);
5577  	}
5578  	_lastRecentFileList.setLangEncoding(_nativeLangSpeaker.getLangEncoding());
5579  	return true;
5580  }
5581  void Notepad_plus::launchClipboardHistoryPanel()
5582  {
5583  	NppParameters& nppParams = NppParameters::getInstance();
5584  	if (!_pClipboardHistoryPanel)
5585  	{
5586  		_pClipboardHistoryPanel = new ClipboardHistoryPanel();
5587  		_pClipboardHistoryPanel->init(_pPublicInterface->getHinst(), _pPublicInterface->getHSelf(), &_pEditView);
5588  		NativeLangSpeaker *pNativeSpeaker = nppParams.getNativeLangSpeaker();
5589  		bool isRTL = pNativeSpeaker->isRTL();
5590  		tTbData	data = {};
5591  		_pClipboardHistoryPanel->create(&data, isRTL);
5592  		::SendMessage(_pPublicInterface->getHSelf(), NPPM_MODELESSDIALOG, MODELESSDIALOGREMOVE, reinterpret_cast<LPARAM>(_pClipboardHistoryPanel->getHSelf()));
5593  		data.uMask = DWS_DF_CONT_RIGHT | DWS_ICONTAB | DWS_USEOWNDARKMODE;
5594  		int icoID = IDR_CLIPBOARDPANEL_ICO;
5595  		if (NppDarkMode::isEnabled())
5596  			icoID = IDR_CLIPBOARDPANEL_ICO_DM;
5597  		else if (nppParams.getNppGUI()._toolBarStatus != TB_STANDARD)
5598  			icoID = IDR_CLIPBOARDPANEL_ICO2;
5599  		data.hIconTab = (HICON)::LoadImage(_pPublicInterface->getHinst(), MAKEINTRESOURCE(icoID), IMAGE_ICON, 14, 14, LR_LOADMAP3DCOLORS | LR_LOADTRANSPARENT);
5600  		data.pszModuleName = NPP_INTERNAL_FUCTION_STR;
5601  		data.dlgID = IDM_EDIT_CLIPBOARDHISTORY_PANEL;
5602  		generic_string title_temp = pNativeSpeaker->getAttrNameStr(CH_PROJECTPANELTITLE, "ClipboardHistory", "PanelTitle");
5603  		static TCHAR title[32];
5604  		if (title_temp.length() < 32)
5605  		{
5606  			wcscpy_s(title, title_temp.c_str());
5607  			data.pszName = title;
5608  		}
5609  		::SendMessage(_pPublicInterface->getHSelf(), NPPM_DMMREGASDCKDLG, 0, reinterpret_cast<LPARAM>(&data));
5610  		COLORREF fgColor = nppParams.getCurrentDefaultFgColor();
5611  		COLORREF bgColor = nppParams.getCurrentDefaultBgColor();
5612  		_pClipboardHistoryPanel->setBackgroundColor(bgColor);
5613  		_pClipboardHistoryPanel->setForegroundColor(fgColor);
5614  	}
5615  	_pClipboardHistoryPanel->display();
5616  }
5617  void Notepad_plus::launchDocumentListPanel(bool changeFromBtnCmd)
5618  {
5619  	if (!_pDocumentListPanel)
5620  	{
5621  		NppParameters& nppParams = NppParameters::getInstance();
5622  		int tabBarStatus = nppParams.getNppGUI()._tabStatus;
5623  		_pDocumentListPanel = new VerticalFileSwitcher;
5624  		HIMAGELIST hImgLst = nullptr;
5625  		const int tabIconSet = changeFromBtnCmd ? -1 : NppDarkMode::getTabIconSet(NppDarkMode::isEnabled());
5626  		switch (tabIconSet)
5627  		{
5628  			case 0:
5629  			{
5630  				hImgLst = _docTabIconList.getHandle();
5631  				break;
5632  			}
5633  			case 1:
5634  			{
5635  				hImgLst = _docTabIconListAlt.getHandle();
5636  				break;
5637  			}
5638  			case 2:
5639  			{
5640  				hImgLst = _docTabIconListDarkMode.getHandle();
5641  				break;
5642  			}
5643  			default:
5644  				hImgLst = (((tabBarStatus & TAB_ALTICONS) == TAB_ALTICONS) ? _docTabIconListAlt.getHandle() : NppDarkMode::isEnabled() ? _docTabIconListDarkMode.getHandle() : _docTabIconList.getHandle());
5645  		}
5646  		_pDocumentListPanel->init(_pPublicInterface->getHinst(), _pPublicInterface->getHSelf(), hImgLst);
5647  		NativeLangSpeaker *pNativeSpeaker = nppParams.getNativeLangSpeaker();
5648  		bool isRTL = pNativeSpeaker->isRTL();
5649  		tTbData	data = {};
5650  		_pDocumentListPanel->create(&data, isRTL);
5651  		::SendMessage(_pPublicInterface->getHSelf(), NPPM_MODELESSDIALOG, MODELESSDIALOGREMOVE, reinterpret_cast<LPARAM>(_pDocumentListPanel->getHSelf()));
5652  		data.uMask = DWS_DF_CONT_LEFT | DWS_ICONTAB | DWS_USEOWNDARKMODE;
5653  		int icoID = IDR_DOCLIST_ICO;
5654  		if (NppDarkMode::isEnabled())
5655  			icoID = IDR_DOCLIST_ICO_DM;
5656  		else if (nppParams.getNppGUI()._toolBarStatus != TB_STANDARD)
5657  			icoID = IDR_DOCLIST_ICO2;
5658  		data.hIconTab = (HICON)::LoadImage(_pPublicInterface->getHinst(), MAKEINTRESOURCE(icoID), IMAGE_ICON, 14, 14, LR_LOADMAP3DCOLORS | LR_LOADTRANSPARENT);
5659  		data.pszModuleName = NPP_INTERNAL_FUCTION_STR;
5660  		data.dlgID = IDM_VIEW_DOCLIST;
5661  		generic_string title_temp = pNativeSpeaker->getAttrNameStr(FS_PROJECTPANELTITLE, "DocList", "PanelTitle");
5662  		static TCHAR title[32];
5663  		if (title_temp.length() < 32)
5664  		{
5665  			wcscpy_s(title, title_temp.c_str());
5666  			data.pszName = title;
5667  		}
5668  		::SendMessage(_pPublicInterface->getHSelf(), NPPM_DMMREGASDCKDLG, 0, reinterpret_cast<LPARAM>(&data));
5669  		COLORREF fgColor = nppParams.getCurrentDefaultFgColor();
5670  		COLORREF bgColor = nppParams.getCurrentDefaultBgColor();
5671  		_pDocumentListPanel->setBackgroundColor(bgColor);
5672  		_pDocumentListPanel->setForegroundColor(fgColor);
5673  	}
5674  	_pDocumentListPanel->display();
5675  }
5676  void Notepad_plus::launchAnsiCharPanel()
5677  {
5678  	if (!_pAnsiCharPanel)
5679  	{
5680  		_pAnsiCharPanel = new AnsiCharPanel();
5681  		_pAnsiCharPanel->init(_pPublicInterface->getHinst(), _pPublicInterface->getHSelf(), &_pEditView);
5682  		NppParameters& nppParams = NppParameters::getInstance();
5683  		NativeLangSpeaker *pNativeSpeaker = nppParams.getNativeLangSpeaker();
5684  		bool isRTL = pNativeSpeaker->isRTL();
5685  		tTbData	data = {};
5686  		_pAnsiCharPanel->create(&data, isRTL);
5687  		::SendMessage(_pPublicInterface->getHSelf(), NPPM_MODELESSDIALOG, MODELESSDIALOGREMOVE, reinterpret_cast<LPARAM>(_pAnsiCharPanel->getHSelf()));
5688  		data.uMask = DWS_DF_CONT_RIGHT | DWS_ICONTAB | DWS_USEOWNDARKMODE;
5689  		int icoID = IDR_ASCIIPANEL_ICO;
5690  		if (NppDarkMode::isEnabled())
5691  			icoID = IDR_ASCIIPANEL_ICO_DM;
5692  		else if (nppParams.getNppGUI()._toolBarStatus != TB_STANDARD)
5693  			icoID = IDR_ASCIIPANEL_ICO2;
5694  		data.hIconTab = (HICON)::LoadImage(_pPublicInterface->getHinst(), MAKEINTRESOURCE(icoID), IMAGE_ICON, 14, 14, LR_LOADMAP3DCOLORS | LR_LOADTRANSPARENT);
5695  		data.pszModuleName = NPP_INTERNAL_FUCTION_STR;
5696  		data.dlgID = IDM_EDIT_CHAR_PANEL;
5697  		generic_string title_temp = pNativeSpeaker->getAttrNameStr(AI_PROJECTPANELTITLE, "AsciiInsertion", "PanelTitle");
5698  		static TCHAR title[85];
5699  		if (title_temp.length() < 85)
5700  		{
5701  			wcscpy_s(title, title_temp.c_str());
5702  			data.pszName = title;
5703  		}
5704  		::SendMessage(_pPublicInterface->getHSelf(), NPPM_DMMREGASDCKDLG, 0, reinterpret_cast<LPARAM>(&data));
5705  		COLORREF fgColor = nppParams.getCurrentDefaultFgColor();
5706  		COLORREF bgColor = nppParams.getCurrentDefaultBgColor();
5707  		_pAnsiCharPanel->setBackgroundColor(bgColor);
5708  		_pAnsiCharPanel->setForegroundColor(fgColor);
5709  	}
5710  	_pAnsiCharPanel->display();
5711  }
5712  void Notepad_plus::launchFileBrowser(const vector<generic_string> & folders, const generic_string& selectedItemPath, bool fromScratch)
5713  {
5714  	if (!_pFileBrowser)
5715  	{
5716  		_pFileBrowser = new FileBrowser;
5717  		_pFileBrowser->init(_pPublicInterface->getHinst(), _pPublicInterface->getHSelf());
5718  		tTbData	data = {};
5719  		_pFileBrowser->create(&data, _nativeLangSpeaker.isRTL());
5720  		data.pszName = TEXT("ST");
5721  		NppParameters& nppParams = NppParameters::getInstance();
5722  		::SendMessage(_pPublicInterface->getHSelf(), NPPM_MODELESSDIALOG, MODELESSDIALOGREMOVE, reinterpret_cast<LPARAM>(_pFileBrowser->getHSelf()));
5723  		data.uMask = DWS_DF_CONT_LEFT | DWS_ICONTAB | DWS_USEOWNDARKMODE;
5724  		int icoID = IDR_FILEBROWSER_ICO;
5725  		if (NppDarkMode::isEnabled())
5726  			icoID = IDR_FILEBROWSER_ICO_DM;
5727  		else if (nppParams.getNppGUI()._toolBarStatus != TB_STANDARD)
5728  			icoID = IDR_FILEBROWSER_ICO2;
5729  		data.hIconTab = (HICON)::LoadImage(_pPublicInterface->getHinst(), MAKEINTRESOURCE(icoID), IMAGE_ICON, 14, 14, LR_LOADMAP3DCOLORS | LR_LOADTRANSPARENT);
5730  		data.pszModuleName = NPP_INTERNAL_FUCTION_STR;
5731  		data.dlgID = IDM_VIEW_FILEBROWSER;
5732  		NativeLangSpeaker *pNativeSpeaker = nppParams.getNativeLangSpeaker();
5733  		generic_string title_temp = pNativeSpeaker->getAttrNameStr(FB_PANELTITLE, FOLDERASWORKSPACE_NODE, "PanelTitle");
5734  		static TCHAR title[32];
5735  		if (title_temp.length() < 32)
5736  		{
5737  			wcscpy_s(title, title_temp.c_str());
5738  			data.pszName = title;
5739  		}
5740  		::SendMessage(_pPublicInterface->getHSelf(), NPPM_DMMREGASDCKDLG, 0, reinterpret_cast<LPARAM>(&data));
5741  		COLORREF fgColor = nppParams.getCurrentDefaultFgColor();
5742  		COLORREF bgColor = nppParams.getCurrentDefaultBgColor();
5743  		_pFileBrowser->setBackgroundColor(bgColor);
5744  		_pFileBrowser->setForegroundColor(fgColor);
5745  	}
5746  	if (fromScratch)
5747  	{
5748  		_pFileBrowser->deleteAllFromTree();
5749  	}
5750  	for (size_t i = 0; i <folders.size(); ++i)
5751  	{
5752  		_pFileBrowser->addRootFolder(folders[i]);
5753  	}
5754  	_pFileBrowser->display();
5755  	_pFileBrowser->selectItemFromPath(selectedItemPath);
5756  	checkMenuItem(IDM_VIEW_FILEBROWSER, true);
5757  	_toolBar.setCheck(IDM_VIEW_FILEBROWSER, true);
5758  	_pFileBrowser->setClosed(false);
5759  }
5760  void Notepad_plus::checkProjectMenuItem()
5761  {
5762  	HMENU viewMenu = ::GetSubMenu(_mainMenuHandle, MENUINDEX_VIEW);
5763  	int viewMenuCount = ::GetMenuItemCount(viewMenu);
5764  	for (int i = 0; i < viewMenuCount; i++)
5765  	{
5766  		HMENU subMenu = ::GetSubMenu(viewMenu, i);
5767  		if (subMenu)
5768  		{
5769  			int subMenuCount = ::GetMenuItemCount(subMenu);
5770  			bool found = false;
5771  			bool checked = false;
5772  			for (int j = 0; j < subMenuCount; j++)
5773  			{
5774  				UINT const ids [] = {IDM_VIEW_PROJECT_PANEL_1, IDM_VIEW_PROJECT_PANEL_2, IDM_VIEW_PROJECT_PANEL_3};
5775  				UINT id = GetMenuItemID (subMenu, j);
5776  				for (size_t k = 0; k < _countof(ids); k++)
5777  				{
5778  					if (id == ids [k])
5779  					{
5780  						found = true;
5781  						UINT s = GetMenuState(subMenu, j, MF_BYPOSITION);
5782  						if (s & MF_CHECKED)
5783  						{
5784  							checked = true;
5785  							break;
5786  						}
5787  					}
5788  				}
5789  			}
5790  			if (found)
5791  			{
5792  				CheckMenuItem(viewMenu, i, (checked ? MF_CHECKED : MF_UNCHECKED) | MF_BYPOSITION);
5793  				break;
5794  			}
5795  		}
5796  	}
5797  }
5798  void Notepad_plus::launchProjectPanel(int cmdID, ProjectPanel ** pProjPanel, int panelID)
5799  {
5800  	NppParameters& nppParam = NppParameters::getInstance();
5801  	if (!(*pProjPanel))
5802  	{
5803  		(*pProjPanel) = new ProjectPanel;
5804  		(*pProjPanel)->init(_pPublicInterface->getHinst(), _pPublicInterface->getHSelf(), panelID);
5805  		(*pProjPanel)->setWorkSpaceFilePath(nppParam.getWorkSpaceFilePath(panelID));
5806  		NativeLangSpeaker *pNativeSpeaker = nppParam.getNativeLangSpeaker();
5807  		bool isRTL = pNativeSpeaker->isRTL();
5808  		tTbData	data = {};
5809  		(*pProjPanel)->create(&data, isRTL);
5810  		data.pszName = TEXT("ST");
5811  		::SendMessage(_pPublicInterface->getHSelf(), NPPM_MODELESSDIALOG, MODELESSDIALOGREMOVE, reinterpret_cast<LPARAM>((*pProjPanel)->getHSelf()));
5812  		data.uMask = DWS_DF_CONT_LEFT | DWS_ICONTAB | DWS_USEOWNDARKMODE;
5813  		int icoID = IDR_PROJECTPANEL_ICO;
5814  		if (NppDarkMode::isEnabled())
5815  			icoID = IDR_PROJECTPANEL_ICO_DM;
5816  		else if (nppParam.getNppGUI()._toolBarStatus != TB_STANDARD)
5817  			icoID = IDR_PROJECTPANEL_ICO2;
5818  		data.hIconTab = (HICON)::LoadImage(_pPublicInterface->getHinst(), MAKEINTRESOURCE(icoID), IMAGE_ICON, 14, 14, LR_LOADMAP3DCOLORS | LR_LOADTRANSPARENT);
5819  		data.pszModuleName = NPP_INTERNAL_FUCTION_STR;
5820  		data.dlgID = cmdID;
5821  		generic_string title_no = to_wstring (panelID + 1);
5822  		generic_string title_temp = pNativeSpeaker->getAttrNameStr(PM_PROJECTPANELTITLE, "ProjectManager", "PanelTitle") + TEXT(" ") + title_no;
5823  		(*pProjPanel)->setPanelTitle(title_temp);
5824  		data.pszName = (*pProjPanel)->getPanelTitle();
5825  		::SendMessage(_pPublicInterface->getHSelf(), NPPM_DMMREGASDCKDLG, 0, reinterpret_cast<LPARAM>(&data));
5826  		COLORREF fgColor = nppParam.getCurrentDefaultFgColor();
5827  		COLORREF bgColor = nppParam.getCurrentDefaultBgColor();
5828  		(*pProjPanel)->setBackgroundColor(bgColor);
5829  		(*pProjPanel)->setForegroundColor(fgColor);
5830  	}
5831  	else
5832  	{
5833  		(*pProjPanel)->openWorkSpace(nppParam.getWorkSpaceFilePath(panelID));
5834  	}
5835  	(*pProjPanel)->display();
5836  	checkMenuItem(cmdID, true);
5837  	checkProjectMenuItem();
5838  	(*pProjPanel)->setClosed(false);
5839  }
5840  void Notepad_plus::launchDocMap()
5841  {
5842  	NppParameters& nppParam = NppParameters::getInstance();
5843  	if (!nppParam.isTransparentAvailable())
5844  	{
5845  		_nativeLangSpeaker.messageBox("PrehistoricSystemDetected",
5846  			_pPublicInterface->getHSelf(),
5847  			TEXT("It seems you still use a prehistoric system. This feature works only on a modern system, sorry."),
5848  			TEXT("Prehistoric system detected"),
5849  			MB_OK);
5850  		return;
5851  	}
5852  	if (!_pDocMap)
5853  	{
5854  		_pDocMap = new DocumentMap();
5855  		_pDocMap->init(_pPublicInterface->getHinst(), _pPublicInterface->getHSelf(), &_pEditView);
5856  		tTbData	data = {};
5857  		_pDocMap->create(&data);
5858  		::SendMessage(_pPublicInterface->getHSelf(), NPPM_MODELESSDIALOG, MODELESSDIALOGREMOVE, reinterpret_cast<LPARAM>(_pDocMap->getHSelf()));
5859  		data.uMask = DWS_DF_CONT_RIGHT | DWS_ICONTAB | DWS_USEOWNDARKMODE;
5860  		int icoID = IDR_DOCMAP_ICO;
5861  		if (NppDarkMode::isEnabled())
5862  			icoID = IDR_DOCMAP_ICO_DM;
5863  		else if (nppParam.getNppGUI()._toolBarStatus != TB_STANDARD)
5864  			icoID = IDR_DOCMAP_ICO2;
5865  		data.hIconTab = (HICON)::LoadImage(_pPublicInterface->getHinst(), MAKEINTRESOURCE(icoID), IMAGE_ICON, 14, 14, LR_LOADMAP3DCOLORS | LR_LOADTRANSPARENT);
5866  		data.pszModuleName = NPP_INTERNAL_FUCTION_STR;
5867  		data.dlgID = IDM_VIEW_DOC_MAP;
5868  		NativeLangSpeaker *pNativeSpeaker = nppParam.getNativeLangSpeaker();
5869  		generic_string title_temp = pNativeSpeaker->getAttrNameStr(DM_PANELTITLE, "DocumentMap", "PanelTitle");
5870  		static TCHAR title[32];
5871  		if (title_temp.length() < 32)
5872  		{
5873  			wcscpy_s(title, title_temp.c_str());
5874  			data.pszName = title;
5875  		}
5876  		::SendMessage(_pPublicInterface->getHSelf(), NPPM_DMMREGASDCKDLG, 0, reinterpret_cast<LPARAM>(&data));
5877  	}
5878  	_pDocMap->initWrapMap();
5879  	_pDocMap->wrapMap();
5880  	_pDocMap->display();
5881  	_pEditView->getFocus();
5882  }
5883  void Notepad_plus::launchFunctionList()
5884  {
5885  	if (!_pFuncList)
5886  	{
5887  		_pFuncList = new FunctionListPanel();
5888  		_pFuncList->init(_pPublicInterface->getHinst(), _pPublicInterface->getHSelf(), &_pEditView);
5889  		tTbData	data = {};
5890  		_pFuncList->create(&data);
5891  		::SendMessage(_pPublicInterface->getHSelf(), NPPM_MODELESSDIALOG, MODELESSDIALOGREMOVE, reinterpret_cast<LPARAM>(_pFuncList->getHSelf()));
5892  		data.uMask = DWS_DF_CONT_RIGHT | DWS_ICONTAB | DWS_USEOWNDARKMODE;
5893  		NppParameters& nppParam = NppParameters::getInstance();
5894  		int icoID = IDR_FUNC_LIST_ICO;
5895  		if (NppDarkMode::isEnabled())
5896  			icoID = IDR_FUNC_LIST_ICO_DM;
5897  		else if (nppParam.getNppGUI()._toolBarStatus != TB_STANDARD)
5898  			icoID = IDR_FUNC_LIST_ICO2;
5899  		data.hIconTab = (HICON)::LoadImage(_pPublicInterface->getHinst(), MAKEINTRESOURCE(icoID), IMAGE_ICON, 14, 14, LR_LOADMAP3DCOLORS | LR_LOADTRANSPARENT);
5900  		data.pszModuleName = NPP_INTERNAL_FUCTION_STR;
5901  		data.dlgID = IDM_VIEW_FUNC_LIST;
5902  		NativeLangSpeaker *pNativeSpeaker = nppParam.getNativeLangSpeaker();
5903  		generic_string title_temp = pNativeSpeaker->getAttrNameStr(FL_PANELTITLE, FL_FUCTIONLISTROOTNODE, "PanelTitle");
5904  		static TCHAR title[32];
5905  		if (title_temp.length() < 32)
5906  		{
5907  			wcscpy_s(title, title_temp.c_str());
5908  			data.pszName = title;
5909  		}
5910  		::SendMessage(_pPublicInterface->getHSelf(), NPPM_DMMREGASDCKDLG, 0, reinterpret_cast<LPARAM>(&data));
5911  		COLORREF fgColor = nppParam.getCurrentDefaultFgColor();
5912  		COLORREF bgColor = nppParam.getCurrentDefaultBgColor();
5913  		_pFuncList->setBackgroundColor(bgColor);
5914  		_pFuncList->setForegroundColor(fgColor);
5915  	}
5916  	_pFuncList->display();
5917  }
5918  struct TextPlayerParams
5919  {
5920  	HWND _nppHandle = nullptr;
5921  	ScintillaEditView* _pCurrentView = nullptr;
5922  	QuoteParams* _quotParams = nullptr;
5923  };
5924  struct TextTrollerParams
5925  {
5926  	ScintillaEditView *_pCurrentView;
5927  	const wchar_t*_text2display;
5928  	BufferID _targetBufID;
5929  	HANDLE _mutex;
5930  };
5931  static const QuoteParams quotes[] =
5932  {
5933  	{TEXT("Notepad++"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("The creation of Notepad++ is due to my need for a decent editor to edit the source code of Notepad++")},
5934  	{TEXT("Notepad++ #1"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("I hate reading other people's code.\nSo I wrote mine, made it as open source project, and watch others suffer.")},
5935  	{TEXT("Notepad++ #2"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Good programmers use Notepad++ to code.\nExtreme programmers use MS Word to code, in Comic Sans, center aligned.")},
5936  	{TEXT("Notepad++ #3"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("The best things in life are free.\nNotepad++ is free.\nSo Notepad++ is the best.\n")},
5937  	{TEXT("Richard Stallman"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("If I'm the Father of Open Source, it was conceived through artificial insemination using stolen sperm without my knowledge or consent.")},
5938  	{TEXT("Martin Golding"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Always code as if the guy who ends up maintaining your code will be a violent psychopath who knows where you live.")},
5939  	{TEXT("L. Peter Deutsch"), QuoteParams::slow, false, SC_CP_UTF8, L_TEXT, TEXT("To iterate is human, to recurse divine.")},
5940  	{TEXT("Seymour Cray"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("The trouble with programmers is that you can never tell what a programmer is doing until it's too late.")},
5941  	{TEXT("Brian Kernighan"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Debugging is twice as hard as writing the code in the first place. Therefore, if you write the code as cleverly as possible, you are, by definition, not smart enough to debug it.")},
5942  	{TEXT("Alan Kay"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Most software today is very much like an Egyptian pyramid with millions of bricks piled on top of each other, with no structural integrity, but just done by brute force and thousands of slaves.")},
5943  	{TEXT("Bill Gates"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Measuring programming progress by lines of code is like measuring aircraft building progress by weight.")},
5944  	{TEXT("Christopher Thompson"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Sometimes it pays to stay in bed on Monday, rather than spending the rest of the week debugging Monday's code.")},
5945  	{TEXT("Vidiu Platon"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("I don't care if it works on your machine! We are not shipping your machine!")},
5946  	{TEXT("Edward V Berard"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Walking on water and developing software from a specification are easy if both are frozen.")},
5947  	{TEXT("pixadel"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Fine, Java MIGHT be a good example of what a programming language should be like.\nBut Java applications are good examples of what applications SHOULDN'T be like.")},
5948  	{TEXT("Oktal"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("I think Microsoft named .Net so it wouldn't show up in a Unix directory listing.")},
5949  	{TEXT("Bjarne Stroustrup"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("In C++ it's harder to shoot yourself in the foot, but when you do, you blow off your whole leg.")},
5950  	{TEXT("Mosher's Law of Software Engineering"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Don't worry if it doesn't work right. If everything did, you'd be out of a job.")},
5951  	{TEXT("Bob Gray"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Writing in C or C++ is like running a chain saw with all the safety guards removed.")},
5952  	{TEXT("Roberto Waltman"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("In the one and only true way. The object-oriented version of \"Spaghetti code\" is, of course, \"Lasagna code\". (Too many layers)")},
5953  	{TEXT("Gavin Russell Baker"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("C++ : Where friends have access to your private members.")},
5954  	{TEXT("Linus Torvalds"), QuoteParams::slow, false, SC_CP_UTF8, L_TEXT, TEXT("Software is like sex: It's better when it's free.")},
5955  	{TEXT("Cult of vi"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Emacs is a great operating system, lacking only a decent editor.")},
5956  	{TEXT("Church of Emacs"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("vi has two modes - \"beep repeatedly\" and \"break everything\".")},
5957  	{TEXT("Steve Jobs"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Picasso had a saying: \"Good artists copy, great artists steal.\".\nWe have always been shameless about stealing great ideas.")},
5958  	{TEXT("brotips #1001"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Do everything for greatness, not money. Money follows greatness.")},
5959  	{TEXT("Robin Williams"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("God gave men both a penis and a brain, but unfortunately not enough blood supply to run both at the same time.")},
5960  	{TEXT("Darth Vader"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Strong people don't put others down.\nThey lift them up.")},
5961  	{TEXT("Darth Vader #2"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("You don't get to 500 million star systems without making a few enemies.")},
5962  	{TEXT("Doug Linder"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("A good programmer is someone who always looks both ways before crossing a one-way street.")},
5963  	{TEXT("Jean-Claude van Damme"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("A cookie has no soul, it's just a cookie. But before it was milk and eggs.\nAnd in eggs there's the potential for life.")},
5964  	{TEXT("Michael Feldman"), QuoteParams::slow, false, SC_CP_UTF8, L_TEXT, TEXT("Java is, in many ways, C++--.")},
5965  	{TEXT("Don Ho"), QuoteParams::slow, false, SC_CP_UTF8, L_TEXT, TEXT("Je mange donc je chie.")},
5966  	{TEXT("Don Ho #2"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("RTFM is the true path of every developer.\nBut it would happen only if there's no way out.")},
5967  	{TEXT("Don Ho #3"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Smartphone is the best invention of 21st century for avoiding the eyes contact while crossing people you know on the street.")},
5968  	{TEXT("Don Ho #4"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("Poor countries' museums vs. rich countries' museums:\nThe first show what they have left.\nThe second show what they have stolen.")},
5969  	{TEXT("Anonymous #1"), QuoteParams::slow, false, SC_CP_UTF8, L_TEXT, TEXT("An opinion without 3.14 is just an onion.")},
5970  	{TEXT("Anonymous #2"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Before sex, you help each other get naked, after sex you only dress yourself.\nMoral of the story: in life no one helps you once you're fucked.")},
5971  	{TEXT("Anonymous #3"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("I'm not totally useless. I can be used as a bad example.")},
5972  	{TEXT("Anonymous #4"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("Life is too short to remove USB safely.")},
5973  	{TEXT("Anonymous #5"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("\"SEX\" is not the answer.\nSex is the question, \"YES\" is the answer.")},
5974  	{TEXT("Anonymous #6"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Going to McDonald's for a salad is like going to a whore for a hug.")},
5975  	{TEXT("Anonymous #7"), QuoteParams::slow, false, SC_CP_UTF8, L_TEXT, TEXT("I need a six month holiday, TWICE A YEAR!")},
5976  	{TEXT("Anonymous #8"), QuoteParams::slow, false, SC_CP_UTF8, L_TEXT, TEXT("Everything is a knife if you're strong enough.")},
5977  	{TEXT("Anonymous #9"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("I'M A FUCKING ANIMAL IN BED.\nMore specifically a koala.")},
5978  	{TEXT("Anonymous #10"), QuoteParams::slow, true, SC_CP_UTF8, L_TEXT, TEXT("Etc.\n\n(Abb.) End of Thinking Capacity.\n")},
5979  	{TEXT("Anonymous #11"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("We stopped checking for monsters under our bed, when we realized they were inside us.")},
5980  	{TEXT("Anonymous #12"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("I would rather check my facebook than face my checkbook.")},
5981  	{TEXT("Anonymous #13"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Whoever says Paper beats Rock is an idiot. Next time I see someone say that I will throw a rock at them while they hold up a sheet of paper.")},
5982  	{TEXT("Anonymous #14"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("A better world is where chickens can cross the road without having their motives questioned.")},
5983  	{TEXT("Anonymous #15"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("If I didn't drink, how would my friends know I love them at 2 AM?")},
5984  	{TEXT("Anonymous #16"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Q: How do you generate a random string?\nA: Put a Windows user in front of vi, and tell him to exit.")},
5985  	{TEXT("Anonymous #17"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Pros and cons of making food.\nPros: food\nCons : making\n")},
5986  	{TEXT("Anonymous #18"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Never get into fights with ugly people, they have nothing to lose.")},
5987  	{TEXT("Anonymous #19"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("People who say they give 110%\ndon't really understand how percentages work.")},
5988  	{TEXT("Anonymous #20"), QuoteParams::slow, false, SC_CP_UTF8, L_TEXT, TEXT("Never make eye contact while eating a banana.")},
5989  	{TEXT("Anonymous #21"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("I love my sixpack so much, I protect it with a layer of fat.")},
5990  	{TEXT("Anonymous #22"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("\"It's impossible.\" said pride.\n\"It's risky.\" said experience.\n\"It's pointless.\" said reason.\n\"Give it a try.\" whispered the heart.\n...\n\"What the hell was that?!?!?!?!?!\" shouted the anus two minutes later.")},
5991  	{TEXT("Anonymous #23"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("A programmer is told to \"go to hell\".\nHe finds the worst part of that statement is the \"go to\".")},
5992  	{TEXT("Anonymous #24"), QuoteParams::slow, false, SC_CP_UTF8, L_TEXT, TEXT("An Architect's dream is an Engineer's nightmare.")},
5993  	{TEXT("Anonymous #25"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("In a way, I feel sorry for the kids of this generation.\nThey'll have parents who know how to check browser history.")},
5994  	{TEXT("Anonymous #26"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Q: What's the difference between git and github?\nA: It's the difference between porn and pornhub.\n")},
5995  	{TEXT("Anonymous #27"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("I don't have a problem with caffeine.\nI have a problem without caffeine.")},
5996  	{TEXT("Anonymous #28"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Why 6 afraid of 7?\nBecause 7 8 9 while 6 and 9 were flirting.")},
5997  	{TEXT("Anonymous #29"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("How do you comfort a JavaScript bug?\nYou console it.")},
5998  	{TEXT("Anonymous #30"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Why do Java developers wear glasses?\nBecause they don't C#.")},
5999  	{TEXT("Anonymous #31"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("A baby's laughter is one of the most beautiful sounds you will ever hear. Unless it's 3 AM. And you're home alone. And you don't have a baby.")},
6000  	{TEXT("Anonymous #32"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Two bytes meet. The first byte asks, \"You look terrible. Are you OK?\"\nThe second byte replies, \"No, just feeling a bit off.\"")},
6001  	{TEXT("Anonymous #33"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Programmer - an organism that turns coffee into software.")},
6002  	{TEXT("Anonymous #34"), QuoteParams::slow, false, SC_CP_UTF8, L_TEXT, TEXT("It's not a bug - it's an undocumented feature.")},
6003  	{TEXT("Anonymous #35"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Should array index start at 0 or 1?\nMy compromised solution is 0.5")},
6004  	{TEXT("Anonymous #36"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Every single time when I'm about to hug someone extremely sexy, I hit the mirror.")},
6005  	{TEXT("Anonymous #37"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("My software never has bugs. It just develops random features.")},
6006  	{TEXT("Anonymous #38"), QuoteParams::slow, false, SC_CP_UTF8, L_TEXT, TEXT("LISP = Lots of Irritating Silly Parentheses.")},
6007  	{TEXT("Anonymous #39"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Perl, the only language that looks the same before and after RSA encryption.")},
6008  	{TEXT("Anonymous #40"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("People ask me why, as an atheist, I still say: OH MY GOD.\nIt makes perfect sense: We say \"Oh my God\" when something is UNBELIEVABLE.")},
6009  	{TEXT("Anonymous #41"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("1. Dig a hole.\n2. Name it love.\n3. Watch people falling in love.\n")},
6010  	{TEXT("Anonymous #42"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Don't think of yourself as an ugly person.\nThink of yourself as a beautiful monkey.")},
6011  	{TEXT("Anonymous #43"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("Afraid to die alone?\nBecome a bus driver.")},
6012  	{TEXT("Anonymous #44"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("The first 5 days after the weekend are always the hardest.")},
6013  	{TEXT("Anonymous #45"), QuoteParams::slow, false, SC_CP_UTF8, L_TEXT, TEXT("Rhinos are just fat unicorns.")},
6014  	{TEXT("Anonymous #46"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Sometimes when I'm writing Javascript I want to throw up my hands and say \"this is bullshit!\"\nbut I can never remember what \"this\" refers to.")},
6015  	{TEXT("Anonymous #47"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("Kids are like farts.\nYou can only stand yours.")},
6016  	{TEXT("Anonymous #48"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("If you were born in Israel, you'd probably be Jewish.\nIf you were born in Saudi Arabia, you'd probably be Muslim.\nIf you were born in India, you'd probably be Hindu.\nBut because you were born in North America, you're Christian.\nYour faith is not inspired by some divine, constant truth.\nIt's simply geography.")},
6017  	{TEXT("Anonymous #49"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("There are 2 types of people in this world:\nPeople who say they pee in the shower, and the dirty fucking liars.")},
6018  	{TEXT("Anonymous #50"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("London 2012 Olympic Games - A bunch of countries coming across the ocean to put their flags in Britain and try to get a bunch of gold... it's like history but opposite.")},
6019  	{TEXT("Anonymous #51"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("I don't need a stable relationship,\nI just need a stable Internet connection.")},
6020  	{TEXT("Anonymous #52"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("What's the difference between religion and bullshit?\nThe bull.")},
6021  	{TEXT("Anonymous #53"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Today, as I was waiting for my girlfriend in the street, I saw a woman who looked a lot like her. I ran towards her, my arms in the air ready to give her a hug, only to realise it wasn't her. I then had to pass the woman, my arms in the air, still running. FML")},
6022  	{TEXT("Anonymous #54"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("Decimal: 1 + 1 = 2\nBinary:  1 + 1 = 10\nBoolean: 1 + 1 = 1\nJavaScript(hold my beer) : 1 + 1 = 11\n")},
6023  	{TEXT("Anonymous #55"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Don't be ashamed of who you are.\nThat's your parents job.")},
6024  	{TEXT("Anonymous #56"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Religion is like circumcision.\nIf you wait until someone is 21 to tell them about it they probably won't be interested.")},
6025  	{TEXT("Anonymous #57"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("No, no, no, I'm not insulting you.\nI'm describing you.")},
6026  	{TEXT("Anonymous #58"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("I bought a dog once. Named him \"Stay\".\n\"Come here, Stay.\"\nHe's insane now.")},
6027  	{TEXT("Anonymous #59"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("Law of Software Quality:\n	errors = (more code)²\ne = mc²")},
6028  	{TEXT("Anonymous #60"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Yesterday I named my Wifi network \"hack me if you can\"\nToday when I woke up it was changed to \"challenge accepted\".")},
6029  	{TEXT("Anonymous #61"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Your mother is so fat,\nthe recursive function computing her mass causes a stack overflow.")},
6030  	{TEXT("Anonymous #62"), QuoteParams::slow, false, SC_CP_UTF8, L_TEXT, TEXT("Oral sex makes my day, but anal sex makes my hole weak.")},
6031  	{TEXT("Anonymous #63"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("I'm not saying I am Batman, I am just saying no one has ever seen me and Batman in the same room together.")},
6032  	{TEXT("Anonymous #64"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("I took a taxi today.\nThe driver told me \"I love my job, I own this car, I've got my own business, I'm my own boss, NO ONE tells me what to do!\"\nI said \"TURN LEFT HERE\".\n")},
6033  	{TEXT("Anonymous #65"), QuoteParams::slow, false, SC_CP_UTF8, L_TEXT, TEXT("A man without God is like a fish without a bicycle.")},
6034  	{TEXT("Anonymous #66"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("I hate how spiders just sit there on the walls and act like they pay rent!")},
6035  	{TEXT("Anonymous #67"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("Whenever someone starts a sentence by saying \"I'm not racist...\"),they are about to say something super racist.")},
6036  	{TEXT("Anonymous #68"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("I'm not laughing at you, I'm laughing with you, you're just not laughing.\n")},
6037  	{TEXT("Anonymous #69"), QuoteParams::slow, false, SC_CP_UTF8, L_TEXT, TEXT("Women need a reason to have sex. Men just need a place.")},
6038  	{TEXT("Anonymous #70"), QuoteParams::slow, false, SC_CP_UTF8, L_TEXT, TEXT("If abortion is murder then are condoms kidnapping?")},
6039  	{TEXT("Anonymous #71"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Men also have feelings.\nFor example, they can feel hungry.")},
6040  	{TEXT("Anonymous #72"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Project Manager:\nA person who thinks 9 women can deliver a baby in 1 month.")},
6041  	{TEXT("Anonymous #73"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("If you try and don't succeed, cheat. Repeat until caught. Then lie.")},
6042  	{TEXT("Anonymous #74"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("Olympics is the stupidest thing.\nPeople are so proud to be competing for their country.\nThey play their stupid song and raise some dumb flags.\nI'd love to see no flags raised, no song, no mention of country.\nOnly people.")},
6043  	{TEXT("Anonymous #75"), QuoteParams::slow, false, SC_CP_UTF8, L_TEXT, TEXT("I think therefore I am\nnot religious.")},
6044  	{TEXT("Anonymous #76"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Even if being gay were a choice, so what?\nPeople choose to be assholes and they can get married.")},
6045  	{TEXT("Anonymous #77"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Governments are like diapers.\nThey should be changed often, and for the same reason.")},
6046  	{TEXT("Anonymous #78"), QuoteParams::slow, true, SC_CP_UTF8, L_TEXT, TEXT("Mathématiquement, un cocu est un entier qui partage sa moitié avec un tiers.\n")},
6047  	{TEXT("Anonymous #79"), QuoteParams::slow, false, SC_CP_UTF8, L_TEXT, TEXT("I'm a creationist.\nI believe man created God.\n")},
6048  	{TEXT("Anonymous #80"), QuoteParams::slow, true, SC_CP_UTF8, L_TEXT, TEXT("Let's eat kids.\nLet's eat, kids.\n\nUse a comma.\nSave lives.\n")},
6049  	{TEXT("Anonymous #81"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("A male engineering student was crossing a road one day when a frog called out to him and said, \"If you kiss me, I'll turn into a beautiful princess.\" He bent over, picked up the frog, and put it in his pocket.\n\nThe frog spoke up again and said, \"If you kiss me and turn me back into a beautiful princess, I will stay with you for one week.\" The engineering student took the frog out of his pocket, smiled at it; and returned it to his pocket.\n\nThe frog then cried out, \"If you kiss me and turn me back into a princess, I'll stay with you and do ANYTHING you want.\" Again the boy took the frog out, smiled at it, and put it back into his pocket.\n\nFinally, the frog asked, \"What is the matter? I've told you I'm a beautiful princess, that I'll stay with you for a week and do anything you want. Why won't you kiss me?\" The boy said, \"Look I'm an engineer. I don't have time for a girlfriend, but a talking frog is cool.\"\n")},
6050  	{TEXT("Anonymous #82"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Gamers never die.\nThey just go offline.\n")},
6051  	{TEXT("Anonymous #83"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Copy from one, it's plagiarism.\nCopy from two, it's research.\n")},
6052  	{TEXT("Anonymous #84"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Saying that Java is nice because it works on all OSes is like saying that anal sex is nice because it works on all genders.")},
6053  	{TEXT("Anonymous #85"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("Race, religion, ethnic pride and nationalism etc... does nothing but teach you how to hate people that you've never met.")},
6054  	{TEXT("Anonymous #86"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Farts are just the ghosts of the things we eat.")},
6055  	{TEXT("Anonymous #87"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("I promised I would never kill someone who had my blood.\nBut that mosquito made me break my word.")},
6056  	{TEXT("Anonymous #88"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Si un jour une chaise te dit que t'as un joli cul, tu trouveras ça bizarre mais c'est juste un compliment d'objet direct.")},
6057  	{TEXT("Anonymous #89"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("The biggest step in any relationship isn't the first kiss.\nIt's the first fart.")},
6058  	{TEXT("Anonymous #90"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Clapping:\n(verb)\nRepeatedly high-fiving yourself for someone else's accomplishments.")},
6059  	{TEXT("Anonymous #91"), QuoteParams::slow, false, SC_CP_UTF8, L_TEXT, TEXT("CV: ctrl-C, ctrl-V")},
6060  	{TEXT("Anonymous #92"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Mondays are not so bad.\nIt's your job that sucks.")},
6061  	{TEXT("Anonymous #93"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("[In a job interview]\nInterviewer: What's your greatest weakness?\nCandidate: Honesty.\nInterviewer: I don't think honesty is a weakness.\nCandidate: I don't give a fuck what you think.")},
6062  	{TEXT("Anonymous #94"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Hey, I just met you\nAnd this is crazy\nHere's my number 127.0.0.1\nPing me maybe?")},
6063  	{TEXT("Anonymous #95"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("What if the spider you killed in your house had spent his entire life thinking you were his roommate?\nEver think about that?\nNo. You only think about yourself.\n")},
6064  	{TEXT("Anonymous #96"), QuoteParams::slow, false, SC_CP_UTF8, L_TEXT, TEXT("Code for 6 minutes, debug for 6 hours.")},
6065  	{TEXT("Anonymous #97"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Real Programmers don't comment their code.\nIf it was hard to write, it should be hard to read.")},
6066  	{TEXT("Anonymous #98"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("My neighbours listen to good music.\nWhether they like it or not.")},
6067  	{TEXT("Anonymous #99"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("I've been using Vim for about 2 years now,\nmostly because I can't figure out how to exit it.")},
6068  	{TEXT("Anonymous #100"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Dear YouTube,\nI can deal with Ads.\nI can deal with Buffer.\nBut when Ads buffer, I suffer.")},
6069  	{TEXT("Anonymous #101"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("It's always sad when a man and his dick share only one brain...\nand it turns out to be the dick's.")},
6070  	{TEXT("Anonymous #102"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("If IE is brave enough to ask you to set it as your default browser,\ndon't tell me you dare not ask a girl out.")},
6071  	{TEXT("Anonymous #104"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("The main idea of \"Inception\":\nif you run a VM inside a VM inside a VM inside a VM inside a VM,\neverything will be very slow.")},
6072  	{TEXT("Anonymous #105"), QuoteParams::slow, false, SC_CP_UTF8, L_TEXT, TEXT("The best antivirus is common sense.")},
6073  	{TEXT("Anonymous #106"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("When I die, I want to go peacefully like my grandfather did, in his sleep\n- not screaming, like the passengers in his car.")},
6074  	{TEXT("Anonymous #107"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Remember, YOUR God is real.\nAll those other Gods are ridiculous, made-up nonsense.\nBut not yours.\nYour God is real. Whichever one that is.")},
6075  	{TEXT("Anonymous #108"), QuoteParams::rapid, true, SC_CP_UTF8, L_CSS, TEXT("#your-mom {\n	width: 100000000000000000000px;\n	float: nope;\n}\n")},
6076  	{TEXT("Anonymous #109"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("What's the best thing about UDP jokes?\nI don't care if you get them.")},
6077  	{TEXT("Anonymous #110"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("A programmer had a problem, so he decided to use threads.\nNow 2 has. He problems")},
6078  	{TEXT("Anonymous #111"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("I'VE NEVER BEEN VERY GOOD AT GEOGRAPHY.\nBUT I CAN NAME AT LEAST ONE CITY IN FRANCE, WHICH IS NICE.")},
6079  	{TEXT("Anonymous #112"), QuoteParams::rapid, true, SC_CP_UTF8, L_CSS, TEXT("#hulk {\n    height: 200%;\n    width: 200%;\n    color: green;\n}\n")},
6080  	{TEXT("Anonymous #113"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("A colon can completely change the meaning of a sentence. For example:\n- Jane ate her friend's sandwich.\n- Jane ate her friend's colon.")},
6081  	{TEXT("Anonymous #114"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("How can you face your problem if your problem is your face?")},
6082  	{TEXT("Anonymous #115"), QuoteParams::slow, false, SC_CP_UTF8, L_TEXT, TEXT("YOLOLO:\nYou Only LOL Once.")},
6083  	{TEXT("Anonymous #116"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Every exit is an entrance to new experiences.")},
6084  	{TEXT("Anonymous #117"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("A Native American was asked:\n\"Do you celebrate Columbus day?\"\nHe replied:\n\"I don't know, do Jews celebrate Hitler's birthday?\"")},
6085  	{TEXT("Anonymous #118"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("I love necrophilia, but i can't stand the awkward silences.")},
6086  	{TEXT("Anonymous #119"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("\"I'm gonna Google that. BING that, Bing that, sorry.\"\n- The CEO of Bing (many times per day still)")},
6087  	{TEXT("Anonymous #120"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("GRAMMAR\nThe difference between knowing your shit and knowing you're shit.")},
6088  	{TEXT("Anonymous #121"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("5 out of 6 people agree that Russian roulette is completely safe.")},
6089  	{TEXT("Anonymous #122"), QuoteParams::slow, false, SC_CP_UTF8, L_TEXT, TEXT("Nerd?\nI prefer the term \"Intellectual badass\".")},
6090  	{TEXT("Anonymous #123"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("I know every digit of π,\njust not in the right order.")},
6091  	{TEXT("Anonymous #124"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("You don't need religion to have morals.\nIf you can't determine right from wrong then you lack empathy, not religion.")},
6092  	{TEXT("Anonymous #125"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Pooping with the door opened is the meaning of true freedom.")},
6093  	{TEXT("Anonymous #126"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Social media does not make people stupid.\nIt just makes stupid people more visible.")},
6094  	{TEXT("Anonymous #127"), QuoteParams::rapid, false, SC_CP_UTF8, L_SQL, TEXT("SELECT finger\nFROM hand\nWHERE id = 2 ;\n")},
6095  	{TEXT("Anonymous #128"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("3 men are on a boat. They have 4 cigarettes, but nothing to light them with.\nSo they throw a cigarette overboard and the whole boat becomes a cigarette lighter.")},
6096  	{TEXT("Anonymous #129"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("What is the most used language in programming?\n\nProfanity\n")},
6097  	{TEXT("Anonymous #130"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("Common sense is so rare, it's kinda like a superpower...")},
6098  	{TEXT("Anonymous #131"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("The best thing about a boolean is even if you are wrong, you are only off by a bit.")},
6099  	{TEXT("Anonymous #132"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("Benchmarks don't lie, but liars do benchmarks.")},
6100  	{TEXT("Anonymous #133"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("Multitasking: Screwing up several things at once.")},
6101  	{TEXT("Anonymous #134"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Linux is user friendly.\nIt's just picky about its friends.")},
6102  	{TEXT("Anonymous #135"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Theory is when you know something, but it doesn't work.\nPractice is when something works, but you don't know why.\nProgrammers combine theory and practice: nothing works and they don't know why.")},
6103  	{TEXT("Anonymous #136"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Documentation is like sex:\nwhen it's good, it's very, very good;\nwhen it's bad, it's better than nothing.")},
6104  	{TEXT("Anonymous #137"), QuoteParams::slow, false, SC_CP_UTF8, L_TEXT, TEXT("Home is where you poop most comfortably.")},
6105  	{TEXT("Anonymous #138"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Laptop Speakers problem: too quiet for music, too loud for porn.")},
6106  	{TEXT("Anonymous #139"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Chinese food to go: $16\nGas to go get the food: $2\nDrove home just to realize they forgot one of your containers: RICELESS")},
6107  	{TEXT("Anonymous #140"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("MS Windows is like religion to most people: they are born into it, accept it as default, never consider switching to another.")},
6108  	{TEXT("Anonymous #141"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("To most religious people, the holy books are like a software license (EULA).\nNobody actually reads it. They just scroll to the bottom and click \"I agree\".")},
6109  	{TEXT("Anonymous #142"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("You are nothing but a number of days,\nwhenever each day passes then part of you has gone.")},
6110  	{TEXT("Anonymous #143"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("If 666 is evil, does that make 25.8069758011 the root of all evil?")},
6111  	{TEXT("Anonymous #144"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("I don't want to sound like a badass but\nI eject my USB drive without removing it safely.")},
6112  	{TEXT("Anonymous #145"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("feet  (noun)\na device used for finding legos in the dark")},
6113  	{TEXT("Anonymous #146"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Buy a sheep\nName it \"Relation\"\nNow you have a Relationsheep\n")},
6114  	{TEXT("Anonymous #147"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("I dig, you dig, we dig,\nhe dig, she dig, they dig...\n\nIt's not a beautiful poem,\nbut it's very deep.")},
6115  	{TEXT("Anonymous #148"), QuoteParams::rapid, false, SC_CP_UTF8, L_BASH, TEXT("# UNIX command line Russian roulette:\n[ $[ $RANDOM % 6 ] == 0 ] && rm -rf &bsol;* || echo *Click*\n")},
6116  	{TEXT("Anonymous #149"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("unzip, strip, top, less, touch, finger, grep, mount, fsck, more, yes, fsck, fsck, fsck, umount, sleep.\n\nNo, it's not porn. It's Unix.")},
6117  	{TEXT("Anonymous #150"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("To understand what recursion is, you must first understand recursion.")},
6118  	{TEXT("Anonymous #151"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Q: What's the object-oriented way to become wealthy?\nA: Inheritance.")},
6119  	{TEXT("Anonymous #152"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("A SQL query goes into a bar, walks up to two tables and asks, \"Can I join you?\"")},
6120  	{TEXT("Anonymous #153"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("You are not fat, you are just more visible.")},
6121  	{TEXT("Anonymous #154"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Minimalist\n (.   .)\n  )   (\n (  Y  )\nASCII Art")},
6122  	{TEXT("Anonymous #155"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Parallel lines have so much in common...\nIt's a shame that they'll never meet.")},
6123  	{TEXT("Anonymous #156"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Declare variables, not war.\nExecute programs, not people.")},
6124  	{TEXT("Anonymous #157"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("I can't see an end. I have no control and I don't think there's any escape. I don't even have a home anymore.\nI think it's time for a new keyboard.")},
6125  	{TEXT("Anonymous #158"), QuoteParams::slow, false, SC_CP_UTF8, L_TEXT, TEXT("6.9\nA little fun interrupted by a period.")},
6126  	{TEXT("Anonymous #159"), QuoteParams::slow, false, SC_CP_UTF8, L_TEXT, TEXT("I love anal\n-yzing all data before making assumptions.")},
6127  	{TEXT("Anonymous #160"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("So my wife said\n\"take off my shirt\".\nI did as she said and take off her shirt.\nThen she said,\n\"Take off my skirt.\"\nI took off her skirt.\n\"Take off my shoes.\"\nI took off her shoes.\n\"Now take off my bra and panties.\"\nand so I took them off.\nThen she looked at me and said\n\"I don't want to catch you wearing my things ever again.\"")},
6128  	{TEXT("Anonymous #161"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("Do you know:\nSpiders are the only web developers in the world that enjoy finding bugs.") },
6129  	{TEXT("Anonymous #162"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("Psychologist: Lie down please.\n8: No, thank you. If I do, this session will never reach the end.") },
6130  	{TEXT("Anonymous #163"), QuoteParams::slow, false, SC_CP_UTF8, L_TEXT, TEXT("I love the way the earth rotates,\nit really makes my day.") },
6131  	{TEXT("Anonymous #164"), QuoteParams::slow, false, SC_CP_UTF8, L_TEXT, TEXT("Homonyms are a waist of thyme.") },
6132  	{TEXT("Anonymous #165"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("What's the difference between a police officer and a bullet?\nWhen a bullet kills someone else, you know it's been fired.") },
6133  	{TEXT("Anonymous #166"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("What has 4 letters\nsometimes 9 letters\nbut never has 5 letters") },
6134  	{TEXT("Anonymous #167"), QuoteParams::slow, false, SC_CP_UTF8, L_TEXT, TEXT("The 'h' in \"software development\" stands for \"happiness\".") },
6135  	{TEXT("Anonymous #168"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("Never let your computer know that you are in a hurry.\nComputers can smell fear.\nThey slow down if they know that you are running out of time.") },
6136  	{TEXT("Anonymous #169"), QuoteParams::slow, false, SC_CP_UTF8, L_TEXT, TEXT("JavaScript is not a language.\nIt's a programming jokes generator.") },
6137  	{TEXT("Anonymous #170"), QuoteParams::slow, false, SC_CP_UTF8, L_TEXT, TEXT("A journalist asked Linus Torvalds what makes code bad.\nHe replied : No comment.") },
6138  	{TEXT("Anonymous #171"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("If you spell \"Nothing\" backwards, it becomes \"Gnihton\" which also means nothing.") },
6139  	{TEXT("Anonymous #172"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Programming in Javascript is like looking both ways before you cross the street, and then getting hit by an airplane.") },
6140  	{TEXT("Anonymous #173"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Q: Why do we need a backend, why not just connect front end to database???\n\nA: Yeah! And why do we eat and go to the bathroom while we can throw the food directly in the toilet? Because stuff needs to get processed. ;)\n") },
6141  	{TEXT("Anonymous #174"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Someday, once humans are extinct from covid-19. I hope whatever species rules Earth makes chicken nuggets in the shape of us, like we did for dinosaurs.") },
6142  	{TEXT("Anonymous #175"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Linkedin is basically a reversed Tinder.\nHot girls write to nerd guys and they didn't reply.") },
6143  	{TEXT("Anonymous #176"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("A vegan said to me, \"people who sell meat are gross!\"\nI said, \"people who sell fruits and vegetables are grocer.\"\n") },
6144  	{TEXT("Anonymous #177"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("Documentation is a love letter that you write to your future self.\n") },
6145  	{TEXT("Anonymous #178"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("When I die, I hope it's early in the morning so I don't have to go to work that day for no reason.\n") },
6146  	{TEXT("Anonymous #179"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("Workers play football\nManagers play tennis\nCEOs play golf\n\nHigher the function, smaller the balls.\n") },
6147  	{TEXT("Anonymous #180"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("Friends are just like trees.\nThey fall down when you hit them multiple times with an axe.\n") },
6148  	{TEXT("Anonymous #181"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("I met a magical Genie. He gave me one wish.\nI said: \"I wish I could be you.\"\nThe Genue saud: \"Weurd wush but U wull grant ut.\"\n") },
6149  	{TEXT("Anonymous #182"), QuoteParams::slow, false, SC_CP_UTF8, L_CPP, TEXT("printf(\"%s%s\", \"\\\\o/\\n| |\\n| |8=\", \"=D\\n/ \\\\\\n\");\n") },
6150  	{TEXT("Anonymous #183"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("Dear Optimist, Pessimist and Realist,\n\nWhile you guys were busy arguing about\nthe glass of water, I drank it!\n\n\n					Sincerely,\n					The Opportunist\n") },
6151  	{TEXT("Anonymous #184"), QuoteParams::slow, false, SC_CP_UTF8, L_TEXT, TEXT("Dance like nobody's watching.\nEncrypt like everyone is.\n") },
6152  	{TEXT("Anonymous #185"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("Me: \"I'm 45 years old but I've got a 19 year-old young man's body\"\nHer: \"Show me\"\nI opened the freezer to show her the body.\nShe screamed.\nMe too.\n") },
6153  	{TEXT("Anonymous #186"), QuoteParams::slow, false, SC_CP_UTF8, L_TEXT, TEXT("Everyone complains about the weather,\nbut no one wants to sacrifice a virgin to change it.\n") },
6154  	{TEXT("Anonymous #187"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("If you are alone at home and feel lonely:\nTurn off the lights, turn on the TV and watch a horror movie.\nThen you will have feeling that there are someone hidden in the kitchen, in the toilet\nand even under your bed.\n") },
6155  	{TEXT("Anonymous #188"), QuoteParams::slow, false, SC_CP_UTF8, L_TEXT, TEXT("*Knock knock*\n\"Race condition\"\n\"Who's there?\"\n") },
6156  	{TEXT("Anonymous #189"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("The two most difficult programming challenges are naming things, cache invalidation, and off-by-one errors.\n") },
6157  	{TEXT("Anonymous #190"), QuoteParams::slow, false, SC_CP_UTF8, L_TEXT, TEXT("The greatest security vulnerability in any computer system is located between the keyboard and the chair.\n") },
6158  	{TEXT("Anonymous #191"), QuoteParams::slow, false, SC_CP_UTF8, L_TEXT, TEXT("My biggest talent is always being able to tell what's in a wrapped present.\n\nIt's a gift.\n") },
6159  	{TEXT("Anonymous #192"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("You can't force someone to love you.\nBut you can lock this person in the basement and wait for him/her to develop Stockholm syndrome.\n") },
6160  	{TEXT("Anonymous #193"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("Do you know:\nthere are more airplanes in the oceans, than submarines in the sky?\n") },
6161  	{TEXT("Anonymous #194"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("If you hold a Unix shell up to your ear,\nyou might just be able to hear the C.\n") },
6162  	{TEXT("Anonymous #195"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("Why do programmers always mix up Halloween and Christmas?\nBecause Oct 31 == Dec 25\n") },
6163  	{TEXT("Anonymous #196"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("What happened to the function that ran away?\nIt never returned.\n") },
6164  	{TEXT("Anonymous #197"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("When I am tasked with sorting through a stack of résumés, I throw about half of them in the garbage.\nI do not want unlucky people working in our company.\n") },
6165  	{TEXT("Anonymous #198"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("The reason why we write SQL commands all in CAPITAL letters is because it stands for Screaming Query Language.\n") },
6166  	{TEXT("Anonymous #199"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("Fly: Hey, bug on my back, are you a mite?\nMite: I mite be.\nFly: Stupidest pun I ever heard.\nMite: What do you expect? I just made it up on the fly.\n\n") },
6167  	{TEXT("Anonymous #200"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("Me: What's the wifi password?\nBartender: You need to buy a drink first.\nMe: OK, I'll have a coke.\nBartender: Is Pepsi OK?\nMe: Sure. How much is that?\nBartender: $3.\nMe: There you go. So what's the wifi password?\nBartender: You need to buy a drink first. No spaces, all lowercase.\n\n") },
6168  	{TEXT("Anonymous #201"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("People always say software engineers are useless without computers.\nIt's not true.\nSome of them are useless even with computers.\n\n") },
6169  	{TEXT("Anonymous #202"), QuoteParams::slow , false, SC_CP_UTF8, L_TEXT, TEXT("The plural of regex is regrets.\n\n") },
6170  	{TEXT("Anonymous #203"), QuoteParams::rapid , false, SC_CP_UTF8, L_TEXT, TEXT("My gynecologist follows me on Instagram, I really do not know what else he want to see.\n\n") },
6171  	{TEXT("Anonymous #204"), QuoteParams::slow , false, SC_CP_UTF8, L_TEXT, TEXT("The greatest security vulnerability in any computer system is located between the keyboard and the chair.\n\n") },
6172  	{TEXT("Anonymous #205"), QuoteParams::slow , false, SC_CP_UTF8, L_TEXT, TEXT("Courage is knowing it might hurt, and doing it anyway.\nStupidity is the same.\nAnd that's why life is hard.\n\n") },
6173  	{TEXT("xkcd"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("Never have I felt so close to another soul\nAnd yet so helplessly alone\nAs when I Google an error\nAnd there's one result\nA thread by someone with the same problem\nAnd no answer\nLast posted to in 2003\n\n\"Who were you, DenverCoder9?\"\n\"What did you see?!\"\n\n(ref: https:&bsol;&bsol;xkcd.com/979/)") },
6174  	{TEXT("A developer"), QuoteParams::slow, false, SC_CP_UTF8, L_TEXT, TEXT("No hugs & kisses.\nOnly bugs & fixes.") },
6175  	{TEXT("Elon Musk"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("Don't set your password as your child's name.\nName your child after your password.") },
6176  	{TEXT("OOP"), QuoteParams::slow, false, SC_CP_UTF8, L_TEXT, TEXT("If you want to treat women as objects,\ndo it with class.")},
6177  	{TEXT("Internet #404"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Quote not Found")},
6178  	{TEXT("Mary Oliver"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("Someone I loved once gave me a box full of darkness.\nIt took me years to understand that this, too, was a gift.")},
6179  	{TEXT("Floor"), QuoteParams::slow, true, SC_CP_UTF8, L_TEXT, TEXT("If you fall, I will be there.")},
6180  	{TEXT("Simon Amstell"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("If you have some problem in your life and need to deal with it, then use religion, that's fine.\nI use Google.")},
6181  	{TEXT("Albert Einstein"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Only 3 things are infinite:\n1. Universe.\n2. Human Stupidity.\n3. Winrar's free trial.")},
6182  	{TEXT("Terry Pratchett"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Artificial Intelligence is no match for natural stupidity.")},
6183  	{TEXT("Stewart Brand"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Once a new technology starts rolling, if you're not part of the steamroller,\nyou're part of the road.")},
6184  	{TEXT("Sam Redwine"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Software and cathedrals are much the same - first we build them, then we pray.")},
6185  	{TEXT("Jan L. A. van de Snepscheut"),  QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("In theory, there is no difference between theory and practice. But, in practice, there is.")},
6186  	{TEXT("Jessica Gaston"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("One man's crappy software is another man's full time job.")},
6187  	{TEXT("Raymond Devos"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("Mon pied droit est jaloux de mon pied gauche. Quand l'un avance, l'autre veut le dépasser.\nEt moi, comme un imbécile, je marche !")},
6188  	{TEXT("xkcd.com"), QuoteParams::rapid, false, SC_CP_UTF8, L_C, TEXT("int getRandomNumber()\n{\n    return 4; 
6189  	{TEXT("Gandhi"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("Earth provides enough to satisfy every man's need, but not every man's greed.")},
6190  	{TEXT("R. D. Laing"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Life is a sexually transmitted disease and the mortality rate is one hundred percent.")},
6191  	{TEXT("Hustle Man"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Politicians are like sperm.\nOne in a million turn out to be an actual human being.")},
6192  	{TEXT("Mark Twain"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Censorship is telling a man he can't have a steak just because a baby can't chew it.")},
6193  	{TEXT("Friedrich Nietzsche"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("There is not enough love and goodness in the world to permit giving any of it away to imaginary beings.")},
6194  	{TEXT("Dhalsim"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("Pain is a state of mind and I don't mind your pain.")},
6195  	{TEXT("Elie Wiesel"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("Human beings can be beautiful or more beautiful,\nthey can be fat or skinny, they can be right or wrong,\nbut illegal? How can a human being be illegal?")},
6196  	{TEXT("Dennis Ritchie"), QuoteParams::rapid, true, SC_CP_UTF8, L_TEXT, TEXT("Empty your memory, with a free(), like a pointer.\nIf you cast a pointer to a integer, it becomes the integer.\nIf you cast a pointer to a struct, it becomes the struct.\nThe pointer can crash, and can overflow.\nBe a pointer my friend.")},
6197  	{TEXT("Chewbacca"), QuoteParams::slow, false, SC_CP_UTF8, L_TEXT, TEXT("Uuuuuuuuuur Ahhhhrrrrrr\nUhrrrr Ahhhhrrrrrr\nAaaarhg...")},
6198  	{TEXT("Alexandria Ocasio-Cortez"), QuoteParams::slow, false, SC_CP_UTF8, L_TEXT, TEXT("No one ever makes a billion dollars.\nYou TAKE a billion dollars.")},
6199  	{TEXT("Freddy Krueger"), QuoteParams::slow, false, SC_CP_UTF8, L_TEXT, TEXT("Never stop dreaming.\n")},
6200  	{TEXT("Word of the Day"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("DEBUGGING\n\n/diːˈbʌɡɪŋ/ noun\n\nThe classic mystery game where you are the detective, the victim and the murderer.\n\n")},
6201  	{TEXT("Ricky Gervais"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("Feel free to mock my lack of belief in any Gods.\nIt won't hurt my feelings.\nIt won't damage my faith in reason.\nAnd I won't kill you for it.")},
6202  	{TEXT("Francis bacon"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("Knowledge is power. France is bacon.\n\nWhen I was young my father said to me: \"Knowledge is power, Francis Bacon.\" I understood it as \"Knowledge is power, France is bacon.\"\n\nFor more than a decade I wondered over the meaning of the second part and what was the surreal linkage between the two. If I said the quote to someone, \"Knowledge is power, France is Bacon\", they nodded knowingly. Or someone might say, \"Knowledge is power\" and I'd finish the quote \"France is Bacon\" and they wouldn't look at me like I'd said something very odd, but thoughtfully agree. I did ask a teacher what did \"Knowledge is power, France is bacon\" mean and got a full 10-minute explanation of the \"knowledge is power\" bit but nothing on \"France is bacon\". When I prompted further explanation by saying \"France is bacon?\" in a questioning tone I just got a \"yes\". At 12 I didn't have the confidence to press it further. I just accepted it as something I'd never understand.\n\nIt wasn't until years later I saw it written down that the penny dropped.\n")},
6203  	{TEXT("Space Invaders"), QuoteParams::speedOfLight, false, SC_CP_UTF8, L_TEXT, TEXT("\n\n       ▄██▄\n     ▄██████▄           █   █  █▀▀▀\n     ██▄██▄██           █   █  █▄▄\n      ▄▀▄▄▀▄            █ █ █  █\n     ▀ ▀  ▀ ▀           ▀▀ ▀▀  ▀▀▀▀\n\n      ▀▄   ▄▀           ▄█▀▀▀  ▄█▀▀█▄  █▀▄▀█  █▀▀▀\n     ▄█▀███▀█▄          █      █    █  █ ▀ █  █▄▄\n    █ █▀▀▀▀▀█ █         █▄     █▄  ▄█  █   █  █\n       ▀▀ ▀▀             ▀▀▀▀   ▀▀▀▀   ▀   ▀  ▀▀▀▀\n\n     ▄▄█████▄▄          ▀█▀  █▀▄  █\n    ██▀▀███▀▀██          █   █ ▀▄ █\n    ▀▀██▀▀▀██▀▀          █   █  ▀▄█\n    ▄█▀ ▀▀▀ ▀█▄         ▀▀▀  ▀   ▀▀\n\n      ▄▄████▄▄          █▀▀█  █▀▀▀  ▄▀▀▄  ▄█▀▀▀  █▀▀▀\n    ▄██████████▄        █▄▄█  █▄▄   █▄▄█  █      █▄▄ \n  ▄██▄██▄██▄██▄██▄      █     █     █  █  █▄     █   \n    ▀█▀  ▀▀  ▀█▀        ▀     ▀▀▀▀  ▀  ▀   ▀▀▀▀  ▀▀▀▀\n\n") },
6204  	{TEXT("#JeSuisCharlie"), QuoteParams::rapid, false, SC_CP_UTF8, L_TEXT, TEXT("Freedom of expression is like the air we breathe, we don't feel it, until people take it away from us.\n\nFor this reason, Je suis Charlie, not because I endorse everything they published, but because I cherish the right to speak out freely without risk even when it offends others.\nAnd no, you cannot just take someone's life for whatever he/she expressed.\n\nHence this \"Je suis Charlie\" edition.\n")}
6205  };
6206  const int nbWtf = 5;
6207  const wchar_t* wtf[nbWtf] =
6208  {
6209  	TEXT("WTF?!"),
6210  	TEXT("lol"),
6211  	TEXT("ROFL"),
6212  	TEXT("OMFG"),
6213  	TEXT("Husband is not an ATM machine!!!")
6214  };
6215  const int nbIntervalTime = 5;
6216  int intervalTimeArray[nbIntervalTime] = {30,30,30,30,200};
6217  const int nbPauseTime = 3;
6218  int pauseTimeArray[nbPauseTime] = {200,400,600};
6219  const int act_doNothing = 0;
6220  const int act_trolling = 1;
6221  const int nbAct = 30;
6222  int actionArray[nbAct] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0};
6223  const int maxRange = 200;
6224  int Notepad_plus::getRandomAction(int ranNum)
6225  {
6226  	return actionArray[ranNum % nbAct];
6227  }
6228  bool isInList(int elem, vector<int> elemList)
6229  {
6230  	for (size_t i = 0, len = elemList.size(); i < len; ++i)
6231  	{
6232  		if (elem == elemList[i])
6233  			return true;
6234  	}
6235  	return false;
6236  }
6237  DWORD WINAPI Notepad_plus::threadTextPlayer(void *params)
6238  {
6239  	srand(static_cast<UINT>(time(NULL)));
6240  	TextPlayerParams* textPlayerParams = static_cast<TextPlayerParams*>(params);
6241  	HWND hNpp = textPlayerParams->_nppHandle;
6242  	ScintillaEditView *pCurrentView = textPlayerParams->_pCurrentView;
6243  	QuoteParams* qParams = textPlayerParams->_quotParams;
6244  	const wchar_t* text2display = qParams->_quote;
6245  	bool shouldBeTrolling = qParams->_shouldBeTrolling;
6246      ::SendMessage(hNpp, NPPM_MENUCOMMAND, 0, IDM_FILE_NEW);
6247  	if (qParams->_encoding == SC_CP_UTF8)
6248  		::SendMessage(hNpp, NPPM_MENUCOMMAND, 0, IDM_FORMAT_AS_UTF_8);
6249  	else if (qParams->_encoding >= 0)
6250  		pCurrentView->execute(SCI_SETCODEPAGE, qParams->_encoding);
6251  	int langMenuId = (NppParameters::getInstance()).langTypeToCommandID(qParams->_lang);
6252  	::SendMessage(hNpp, NPPM_MENUCOMMAND, 0, langMenuId);
6253  	int x = 2, y = 1;
6254  	if (qParams->_speed == QuoteParams::slow)
6255  	{
6256  		x = 1;
6257  		y = 1;
6258  	}
6259  	else if (qParams->_speed == QuoteParams::rapid)
6260  	{
6261  		x = 2;
6262  		y = 1;
6263  	}
6264  	else if (qParams->_speed == QuoteParams::speedOfLight)
6265  	{
6266  		x = 1;
6267  		y = 0;
6268  	}
6269  	static TextTrollerParams trollerParams;
6270  	trollerParams._pCurrentView = pCurrentView;
6271  	BufferID targetBufID = pCurrentView->getCurrentBufferID();
6272  	trollerParams._targetBufID = targetBufID;
6273  	HANDLE mutex = ::CreateMutex(NULL, false, TEXT("nppTextWriter"));
6274  	trollerParams._mutex = mutex;
6275      HWND curScintilla = pCurrentView->getHSelf();
6276  	const int nbMaxTrolling = 1;
6277  	int nbTrolling = 0;
6278  	vector<int> generatedRans;
6279  	wchar_t previousChar = '\0';
6280  	for (size_t i = 0, len = lstrlen(text2display); i < len ; ++i)
6281      {
6282  		int ranNum = getRandomNumber(maxRange);
6283  		int action = act_doNothing;
6284  		if (shouldBeTrolling && (i > 20 && previousChar == ' ') && nbTrolling < nbMaxTrolling)
6285  		{
6286  			action = getRandomAction(ranNum);
6287  		}
6288  		if (action == act_trolling)
6289  		{
6290  			int wtfIndex = getRandomNumber() % nbWtf;
6291  			if (!isInList(wtfIndex, generatedRans))
6292  			{
6293  				generatedRans.push_back(wtfIndex);
6294  				++nbTrolling;
6295  				trollerParams._text2display = wtf[wtfIndex];
6296  				ReleaseMutex(mutex);
6297  				HANDLE hThread = ::CreateThread(NULL, 0, threadTextTroller, &trollerParams, 0, NULL);
6298  				int sleepTime = 1000 / x * y;
6299  				::Sleep(sleepTime);
6300  				WaitForSingleObject(mutex, INFINITE);
6301  				::CloseHandle(hThread);
6302  			}
6303  		}
6304  		if (text2display[i] == ' ' || text2display[i] == '.')
6305  		{
6306  			int sleepTime = (ranNum + pauseTimeArray[ranNum%nbPauseTime]) / x * y;
6307  			Sleep(sleepTime);
6308  		}
6309  		else
6310  		{
6311  			int sleepTime = (ranNum + intervalTimeArray[ranNum%nbIntervalTime]) / x * y;
6312  			Sleep(sleepTime);
6313  		}
6314  		BufferID currentBufID = pCurrentView->getCurrentBufferID();
6315  		if (currentBufID != targetBufID)
6316  			return TRUE;
6317  		char charToShow[4] = { '\0' };
6318  		::WideCharToMultiByte(CP_UTF8, 0, text2display + i, 1, charToShow, sizeof(charToShow), NULL, NULL);
6319  		::SendMessage(curScintilla, SCI_APPENDTEXT, strlen(charToShow), reinterpret_cast<LPARAM>(charToShow));
6320  		::SendMessage(curScintilla, SCI_GOTOPOS, ::SendMessage(curScintilla, SCI_GETLENGTH, 0, 0), 0);
6321  		previousChar = text2display[i];
6322      }
6323  	const wchar_t* quoter = qParams->_quoter;
6324  	wstring quoter_str = quoter;
6325  	size_t pos = quoter_str.find(TEXT("Anonymous"));
6326  	if (pos == string::npos)
6327  	{
6328  		::SendMessage(curScintilla, SCI_APPENDTEXT, 3, reinterpret_cast<LPARAM>("\n- "));
6329  		::SendMessage(curScintilla, SCI_GOTOPOS, ::SendMessage(curScintilla, SCI_GETLENGTH, 0, 0), 0);
6330  		for (size_t i = 0, len = lstrlen(quoter); i < len; ++i)
6331  		{
6332  			int ranNum = getRandomNumber(maxRange);
6333  			int sleepTime = (ranNum + intervalTimeArray[ranNum%nbIntervalTime]) / x * y;
6334  			Sleep(sleepTime);
6335  			BufferID currentBufID = pCurrentView->getCurrentBufferID();
6336  			if (currentBufID != targetBufID)
6337  				return TRUE;
6338  			char charToShow[4] = { '\0' };
6339  			::WideCharToMultiByte(CP_UTF8, 0, quoter + i, 1, charToShow, sizeof(charToShow), NULL, NULL);
6340  			::SendMessage(curScintilla, SCI_APPENDTEXT, 1, reinterpret_cast<LPARAM>(charToShow));
6341  			::SendMessage(curScintilla, SCI_GOTOPOS, ::SendMessage(curScintilla, SCI_GETLENGTH, 0, 0), 0);
6342  		}
6343  	}
6344      return TRUE;
6345  }
6346  DWORD WINAPI Notepad_plus::threadTextTroller(void *params)
6347  {
6348  	TextTrollerParams *textTrollerParams = static_cast<TextTrollerParams *>(params);
6349  	WaitForSingleObject(textTrollerParams->_mutex, INFINITE);
6350  	srand(static_cast<UINT>(time(NULL)));
6351  	ScintillaEditView *pCurrentView = textTrollerParams->_pCurrentView;
6352  	const wchar_t* text2display = textTrollerParams->_text2display;
6353  	HWND curScintilla = pCurrentView->getHSelf();
6354  	BufferID targetBufID = textTrollerParams->_targetBufID;
6355  	for (size_t i = 0, len = lstrlen(text2display); i < len; ++i)
6356      {
6357          int ranNum = getRandomNumber(maxRange);
6358  		if (text2display[i] == ' ' || text2display[i] == '.')
6359  			Sleep(ranNum + pauseTimeArray[ranNum%nbPauseTime]);
6360  		else
6361  			Sleep(ranNum + intervalTimeArray[ranNum%nbIntervalTime]);
6362  		BufferID currentBufID = pCurrentView->getCurrentBufferID();
6363  		if (currentBufID != targetBufID)
6364  		{
6365  			ReleaseMutex(textTrollerParams->_mutex);
6366  			return TRUE;
6367  		}
6368  		char charToShow[64] = { '\0' };
6369  		::WideCharToMultiByte(CP_UTF8, 0, text2display + i, 1, charToShow, sizeof(charToShow), NULL, NULL);
6370  		::SendMessage(curScintilla, SCI_APPENDTEXT, 1, reinterpret_cast<LPARAM>(charToShow));
6371  		::SendMessage(curScintilla, SCI_GOTOPOS, ::SendMessage(curScintilla, SCI_GETLENGTH, 0, 0), 0);
6372      }
6373  	int n = getRandomNumber();
6374  	int delMethod = n%4;
6375  	if (delMethod == 0)
6376  	{
6377  		size_t len = lstrlen(text2display);
6378  		for (size_t j = 0; j < len; ++j)
6379  		{
6380  			if (!deleteBack(pCurrentView, targetBufID))
6381  				break;
6382  		}
6383  	}
6384  	else if (delMethod == 1)
6385  	{
6386  		size_t len = lstrlen(text2display);
6387  		::SendMessage(curScintilla, SCI_GOTOPOS, ::SendMessage(curScintilla, SCI_GETLENGTH, 0, 0) - len, 0);
6388  		for (size_t j = 0; j < len; ++j)
6389  		{
6390  			if (!deleteForward(pCurrentView, targetBufID))
6391  				break;
6392  		}
6393  	}
6394  	else if (delMethod == 2)
6395  	{
6396  		for (size_t j = 0, len = lstrlen(text2display); j < len; ++j)
6397  		{
6398  			if (!selectBack(pCurrentView, targetBufID))
6399  				break;
6400  		}
6401  		int ranNum = getRandomNumber(maxRange);
6402  		::Sleep(ranNum + pauseTimeArray[ranNum%nbPauseTime]);
6403  		::SendMessage(pCurrentView->getHSelf(), SCI_DELETEBACK, 0, 0);
6404  	}
6405  	else
6406  	{
6407  		auto currentPos = ::SendMessage(pCurrentView->getHSelf(), SCI_GETSELECTIONSTART, 0, 0);
6408  		::SendMessage(pCurrentView->getHSelf(), SCI_SETSELECTION, currentPos, currentPos - lstrlen(text2display));
6409  		BufferID currentBufID = pCurrentView->getCurrentBufferID();
6410  		if (currentBufID != targetBufID)
6411  			return TRUE;
6412  		int ranNum = getRandomNumber(maxRange);
6413  		::Sleep(ranNum + pauseTimeArray[ranNum%nbPauseTime]);
6414  		::SendMessage(pCurrentView->getHSelf(), SCI_DELETEBACK, 0, 0);
6415  	}
6416  	ReleaseMutex(textTrollerParams->_mutex);
6417  	return TRUE;
6418  }
6419  bool Notepad_plus::deleteBack(ScintillaEditView *pCurrentView, BufferID targetBufID)
6420  {
6421  	int ranNum = getRandomNumber(maxRange - 100);
6422  	BufferID currentBufID = pCurrentView->getCurrentBufferID();
6423  	Sleep(ranNum);
6424  	if (currentBufID != targetBufID)
6425  		return false;
6426  	::SendMessage(pCurrentView->getHSelf(), SCI_DELETEBACK, 0, 0);
6427  	return true;
6428  }
6429  bool Notepad_plus::deleteForward(ScintillaEditView *pCurrentView, BufferID targetBufID)
6430  {
6431  	int ranNum = getRandomNumber(maxRange - 100);
6432  	BufferID currentBufID = pCurrentView->getCurrentBufferID();
6433  	Sleep(ranNum);
6434  	if (currentBufID != targetBufID)
6435  		return false;
6436  	::SendMessage(pCurrentView->getHSelf(), SCI_GOTOPOS, ::SendMessage(pCurrentView->getHSelf(), SCI_GETCURRENTPOS, 0, 0) + 1, 0);
6437  	::SendMessage(pCurrentView->getHSelf(), SCI_DELETEBACK, 0, 0);
6438  	return true;
6439  }
6440  bool Notepad_plus::selectBack(ScintillaEditView *pCurrentView, BufferID targetBufID)
6441  {
6442  	int ranNum = getRandomNumber(maxRange - 100);
6443  	BufferID currentBufID = pCurrentView->getCurrentBufferID();
6444  	auto currentPos = ::SendMessage(pCurrentView->getHSelf(), SCI_GETSELECTIONSTART, 0, 0);
6445  	auto currentAnchor = ::SendMessage(pCurrentView->getHSelf(), SCI_GETSELECTIONEND, 0, 0);
6446  	Sleep(ranNum + intervalTimeArray[ranNum%nbIntervalTime]);
6447  	if (currentBufID != targetBufID)
6448  		return false;
6449  	::SendMessage(pCurrentView->getHSelf(), SCI_SETSELECTION, currentAnchor, --currentPos);
6450  	return true;
6451  }
6452  int Notepad_plus::getQuoteIndexFrom(const wchar_t* quoter) const
6453  {
6454  	if (!quoter)
6455  		return -1;
6456  	if (wcsicmp(quoter, TEXT("Get them all!!!")) == 0)
6457  		return -2;
6458  	int nbQuote = sizeof(quotes) / sizeof(QuoteParams);
6459  	if (wcsicmp(quoter, TEXT("random")) == 0)
6460  	{
6461  		srand(static_cast<UINT>(time(NULL)));
6462  		return getRandomNumber(nbQuote);
6463  	}
6464  	for (int i = 0; i < nbQuote; ++i)
6465  	{
6466  		if (wcsicmp(quotes[i]._quoter, quoter) == 0)
6467  			return i;
6468  	}
6469  	return -1;
6470  }
6471  void Notepad_plus::showAllQuotes() const
6472  {
6473  }
6474  void Notepad_plus::showQuoteFromIndex(int index) const
6475  {
6476  	int nbQuote = sizeof(quotes) / sizeof(QuoteParams);
6477  	if (index < 0 || index >= nbQuote) return;
6478  	showQuote(&quotes[index]);
6479  }
6480  void Notepad_plus::showQuote(const QuoteParams* quote) const
6481  {
6482  	static TextPlayerParams params;
6483  	params._quotParams = const_cast<QuoteParams*>(quote);
6484  	params._nppHandle = Notepad_plus::_pPublicInterface->getHSelf();
6485  	params._pCurrentView = _pEditView;
6486  	HANDLE hThread = ::CreateThread(NULL, 0, threadTextPlayer, &params, 0, NULL);
6487  	if (hThread)
6488  		::CloseHandle(hThread);
6489  }
6490  void Notepad_plus::minimizeDialogs()
6491  {
6492  	static StaticDialog* modelessDlgs[] = {&_findReplaceDlg, &_aboutDlg, &_debugInfoDlg, &_runDlg, &_goToLineDlg, &_colEditorDlg, &_configStyleDlg,\
6493  		&_preference, &_pluginsAdminDlg, &_findCharsInRangeDlg, &_md5FromFilesDlg, &_md5FromTextDlg, &_sha2FromFilesDlg, &_sha2FromTextDlg, &_runMacroDlg};
6494  	static size_t nbModelessDlg = sizeof(modelessDlgs) / sizeof(StaticDialog*);
6495  	for (size_t i = 0; i < nbModelessDlg; ++i)
6496  	{
6497  		StaticDialog* pDlg = modelessDlgs[i];
6498  		if (pDlg->isCreated() && pDlg->isVisible())
6499  		{
6500  			pDlg->display(false);
6501  			_sysTrayHiddenHwnd.push_back(pDlg->getHSelf());
6502  		}
6503  	}
6504  }
6505  void Notepad_plus::restoreMinimizeDialogs()
6506  {
6507  	size_t nbDialogs = _sysTrayHiddenHwnd.size();
6508  	for (int i = (static_cast<int>(nbDialogs) - 1); i >= 0; i--)
6509  	{
6510  		::ShowWindow(_sysTrayHiddenHwnd[i], SW_SHOW);
6511  		_sysTrayHiddenHwnd.erase(_sysTrayHiddenHwnd.begin() + i);
6512  	}
6513  }
6514  void Notepad_plus::refreshDarkMode(bool resetStyle)
6515  {
6516  	if (resetStyle)
6517  	{
6518  		NppParameters& nppParams = NppParameters::getInstance();
6519  		::SendMessage(_pPublicInterface->getHSelf(), NPPM_SETEDITORBORDEREDGE, 0, nppParams.getSVP()._showBorderEdge);
6520  		::SendMessage(_subEditView.getHSelf(), NPPM_INTERNAL_REFRESHDARKMODE, 0, 0);
6521  		::SendMessage(_mainEditView.getHSelf(), NPPM_INTERNAL_REFRESHDARKMODE, 0, 0);
6522  		::SendMessage(_mainDocTab.getHSelf(), NPPM_INTERNAL_REFRESHDARKMODE, 0, 0);
6523  		::SendMessage(_subDocTab.getHSelf(), NPPM_INTERNAL_REFRESHDARKMODE, 0, 0);
6524  		::SendMessage(_findInFinderDlg.getHSelf(), NPPM_INTERNAL_REFRESHDARKMODE, 0, 0);
6525  		::RedrawWindow(_findInFinderDlg.getHSelf(), nullptr, nullptr, RDW_INVALIDATE | RDW_ERASE | RDW_FRAME | RDW_ALLCHILDREN);
6526  		::SendMessage(_incrementFindDlg.getHSelf(), NPPM_INTERNAL_REFRESHDARKMODE, 0, 0);
6527  		::RedrawWindow(_pPublicInterface->getHSelf(), nullptr, nullptr, RDW_INVALIDATE | RDW_ERASE | RDW_FRAME | RDW_ALLCHILDREN);
6528  		if (_pProjectPanel_1)
6529  		{
6530  			::SendMessage(_pProjectPanel_1->getHSelf(), NPPM_INTERNAL_REFRESHDARKMODE, 0, 0);
6531  		}
6532  		if (_pProjectPanel_2)
6533  		{
6534  			::SendMessage(_pProjectPanel_2->getHSelf(), NPPM_INTERNAL_REFRESHDARKMODE, 0, 0);
6535  		}
6536  		if (_pProjectPanel_3)
6537  		{
6538  			::SendMessage(_pProjectPanel_3->getHSelf(), NPPM_INTERNAL_REFRESHDARKMODE, 0, 0);
6539  		}
6540  		if (_pFuncList)
6541  		{
6542  			::SendMessage(_pFuncList->getHSelf(), NPPM_INTERNAL_REFRESHDARKMODE, 0, 0);
6543  		}
6544  		if (_pFileBrowser)
6545  		{
6546  			::SendMessage(_pFileBrowser->getHSelf(), NPPM_INTERNAL_REFRESHDARKMODE, 0, 0);
6547  		}
6548  		if (_pAnsiCharPanel)
6549  		{
6550  			::SendMessage(_pAnsiCharPanel->getHSelf(), NPPM_INTERNAL_REFRESHDARKMODE, 0, 0);
6551  		}
6552  		if (_pDocumentListPanel)
6553  		{
6554  			::SendMessage(_pDocumentListPanel->getHSelf(), NPPM_INTERNAL_REFRESHDARKMODE, 0, 0);
6555  		}
6556  		if (_pClipboardHistoryPanel)
6557  		{
6558  			::SendMessage(_pClipboardHistoryPanel->getHSelf(), NPPM_INTERNAL_REFRESHDARKMODE, 0, 0);
6559  		}
6560  		const int tabIconSet = NppDarkMode::getTabIconSet(NppDarkMode::isEnabled());
6561  		if (tabIconSet != -1)
6562  		{
6563  			_preference._generalSubDlg.setTabbarAlternateIcons(tabIconSet == 1);
6564  			::SendMessage(_pPublicInterface->getHSelf(), NPPM_INTERNAL_CHANGETABBAEICONS, static_cast<WPARAM>(false), tabIconSet);
6565  		}
6566  		else
6567  		{
6568  			const bool isChecked = _preference._generalSubDlg.isCheckedOrNot(IDC_CHECK_TAB_ALTICONS);
6569  			if (!isChecked)
6570  			{
6571  				::SendMessage(_pPublicInterface->getHSelf(), NPPM_INTERNAL_CHANGETABBAEICONS, static_cast<WPARAM>(false), NppDarkMode::isEnabled() ? 2 : 0);
6572  			}
6573  		}
6574  		const int iconState = NppDarkMode::getToolBarIconSet(NppDarkMode::isEnabled());
6575  		toolBarStatusType state = (iconState == -1) ? _toolBar.getState() : static_cast<toolBarStatusType>(iconState);
6576  		switch (state)
6577  		{
6578  			case TB_SMALL:
6579  				_toolBar.reduce();
6580  				break;
6581  			case TB_LARGE:
6582  				_toolBar.enlarge();
6583  				break;
6584  			case TB_SMALL2:
6585  				_toolBar.reduceToSet2();
6586  				break;
6587  			case TB_LARGE2:
6588  				_toolBar.enlargeToSet2();
6589  				break;
6590  			case TB_STANDARD:
6591  				_toolBar.setToBmpIcons();
6592  				break;
6593  		}
6594  		ThemeSwitcher& themeSwitcher = nppParams.getThemeSwitcher();
6595  		generic_string themePath;
6596  		generic_string themeName;
6597  		generic_string xmlFileName = NppDarkMode::getThemeName();
6598  		if (!xmlFileName.empty())
6599  		{
6600  			if (!nppParams.isLocal() || nppParams.isCloud())
6601  			{
6602  				themePath = nppParams.getUserPath();
6603  				pathAppend(themePath, TEXT("themes\\"));
6604  				pathAppend(themePath, xmlFileName);
6605  			}
6606  			if (::PathFileExists(themePath.c_str()) == FALSE || themePath.empty())
6607  			{
6608  				themePath = themeSwitcher.getThemeDirPath();
6609  				pathAppend(themePath, xmlFileName);
6610  			}
6611  			themeName = themeSwitcher.getThemeFromXmlFileName(themePath.c_str());
6612  		}
6613  		else
6614  		{
6615  			pair<generic_string, generic_string>& themeInfo = themeSwitcher.getElementFromIndex(0);
6616  			themePath = themeInfo.second;
6617  			themeName = themeSwitcher.getDefaultThemeLabel();
6618  		}
6619  		if (::PathFileExists(themePath.c_str()) == TRUE)
6620  		{
6621  			nppParams.getNppGUI()._themeName = themePath;
6622  			if (_configStyleDlg.isCreated())
6623  			{
6624  				_configStyleDlg.selectThemeByName(themeName.c_str());
6625  			}
6626  			else
6627  			{
6628  				nppParams.reloadStylers(themePath.c_str());
6629  				::SendMessage(_pPublicInterface->getHSelf(), WM_UPDATESCINTILLAS, 0, 0);
6630  			}
6631  		}
6632  		if (NppDarkMode::isExperimentalSupported())
6633  		{
6634  			NppDarkMode::allowDarkModeForApp(NppDarkMode::isEnabled());
6635  			NppDarkMode::setDarkTitleBar(_pPublicInterface->getHSelf());
6636  			::SetWindowPos(_pPublicInterface->getHSelf(), nullptr, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_FRAMECHANGED);
6637  			for (auto& docCont : _dockingManager.getContainerInfo())
6638  			{
6639  				auto hwndDocCont = docCont->getCaptionWnd();
6640  				NppDarkMode::setDarkTitleBar(hwndDocCont);
6641  				::SetWindowPos(hwndDocCont, nullptr, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_FRAMECHANGED);
6642  			}
6643  			for (auto& hwndDlg : _hModelessDlgs)
6644  			{
6645  				NppDarkMode::setDarkTitleBar(hwndDlg);
6646  				::SendMessage(hwndDlg, NPPM_INTERNAL_REFRESHDARKMODE, 0, 0);
6647  				::RedrawWindow(hwndDlg, nullptr, nullptr, RDW_INVALIDATE | RDW_ERASE | RDW_FRAME | RDW_ALLCHILDREN);
6648  				::SetWindowPos(hwndDlg, nullptr, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_FRAMECHANGED);
6649  			}
6650  			NppDarkMode::setDarkTitleBar(_findInFinderDlg.getHSelf());
6651  			::SetWindowPos(_findInFinderDlg.getHSelf(), nullptr, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_FRAMECHANGED);
6652  		}
6653  	}
6654  	else
6655  	{
6656  		for (auto& docCont : _dockingManager.getContainerInfo())
6657  		{
6658  			auto hwndDocCont = docCont->getCaptionWnd();
6659  			::RedrawWindow(hwndDocCont, nullptr, nullptr, RDW_INVALIDATE | RDW_ERASE | RDW_FRAME | RDW_ALLCHILDREN);
6660  		}
6661  		for (auto& hwndDlg : _hModelessDlgs)
6662  		{
6663  			::RedrawWindow(hwndDlg, nullptr, nullptr, RDW_INVALIDATE | RDW_ERASE | RDW_FRAME | RDW_ALLCHILDREN);
6664  		}
6665  		::RedrawWindow(_findInFinderDlg.getHSelf(), nullptr, nullptr, RDW_INVALIDATE | RDW_ERASE | RDW_FRAME | RDW_ALLCHILDREN);
6666  		::RedrawWindow(_pPublicInterface->getHSelf(), nullptr, nullptr, RDW_INVALIDATE | RDW_ERASE | RDW_FRAME | RDW_ALLCHILDREN);
6667  	}
6668  }
6669  void Notepad_plus::launchDocumentBackupTask()
6670  {
6671  	HANDLE hThread = ::CreateThread(NULL, 0, backupDocument, NULL, 0, NULL);
6672  	if (hThread)
6673  		::CloseHandle(hThread);
6674  }
6675  DWORD WINAPI Notepad_plus::backupDocument(void * &bsol;*param*/)
6676  {
6677  	bool isSnapshotMode = true;
6678  	while (isSnapshotMode)
6679  	{
6680  		NppParameters& nppParam = NppParameters::getInstance();
6681  		size_t timer = nppParam.getNppGUI()._snapshotBackupTiming;
6682  		if (timer < 1000)
6683  			timer = 1000;
6684  		::Sleep(DWORD(timer));
6685  		isSnapshotMode = nppParam.getNppGUI().isSnapshotMode();
6686  		if (!isSnapshotMode)
6687  			break;
6688  		::PostMessage(Notepad_plus_Window::gNppHWND, NPPM_INTERNAL_SAVEBACKUP, 0, 0);
6689  	}
6690  	return TRUE;
6691  }
6692  #ifdef _MSC_VER
6693  #pragma warning( disable : 4127 )
6694  #endif
6695  bool Notepad_plus::undoStreamComment(bool tryBlockComment)
6696  {
6697  	const TCHAR *commentStart;
6698  	const TCHAR *commentEnd;
6699  	const TCHAR *commentLineSymbol;
6700  	generic_string symbolStart;
6701  	generic_string symbolEnd;
6702  	generic_string symbol;
6703  	const int charbufLen = 10;
6704      TCHAR charbuf[charbufLen];
6705  	bool retVal = false;
6706  	Buffer * buf = _pEditView->getCurrentBuffer();
6707  	if (buf->isReadOnly())
6708  		return false;
6709  	if (buf->getLangType() == L_USER)
6710  	{
6711  		UserLangContainer * userLangContainer = NppParameters::getInstance().getULCFromName(buf->getUserDefineLangName());
6712  		if (!userLangContainer)
6713  			return false;
6714  		symbol = extractSymbol('0', '0', userLangContainer->_keywordLists[SCE_USER_KWLIST_COMMENTS]);
6715  		commentLineSymbol = symbol.c_str();
6716  		symbolStart = extractSymbol('0', '3', userLangContainer->_keywordLists[SCE_USER_KWLIST_COMMENTS]);
6717  		commentStart = symbolStart.c_str();
6718  		symbolEnd = extractSymbol('0', '4', userLangContainer->_keywordLists[SCE_USER_KWLIST_COMMENTS]);
6719  		commentEnd = symbolEnd.c_str();
6720  	}
6721  	else
6722  	{
6723  		commentLineSymbol = buf->getCommentLineSymbol();
6724  		commentStart = buf->getCommentStart();
6725  		commentEnd = buf->getCommentEnd();
6726  	}
6727  	if ((!commentStart) || (!commentStart[0]) || (commentStart == NULL) || (!commentEnd) || (!commentEnd[0]) || (commentEnd == NULL))
6728  	{
6729  		if (!(!commentLineSymbol || !commentLineSymbol[0] || commentLineSymbol == NULL) && tryBlockComment)
6730  			return doBlockComment(cm_uncomment);
6731  		else
6732  			return false;
6733  	}
6734  	generic_string start_comment(commentStart);
6735  	generic_string end_comment(commentEnd);
6736  	generic_string white_space(TEXT(" "));
6737  	size_t start_comment_length = start_comment.length();
6738  	size_t end_comment_length = end_comment.length();
6739  	_pEditView->execute(SCI_BEGINUNDOACTION);
6740  	do
6741  	{
6742  		auto selectionStart = _pEditView->execute(SCI_GETSELECTIONSTART);
6743  		auto selectionEnd = _pEditView->execute(SCI_GETSELECTIONEND);
6744  		auto caretPosition = _pEditView->execute(SCI_GETCURRENTPOS);
6745  		auto docLength = _pEditView->execute(SCI_GETLENGTH);
6746  		bool move_caret = caretPosition < selectionEnd;
6747  		const int iSelStart=0, iSelEnd=1;
6748  		const size_t N_CMNT = 2;
6749  		intptr_t posStartCommentBefore[N_CMNT], posEndCommentBefore[N_CMNT], posStartCommentAfter[N_CMNT], posEndCommentAfter[N_CMNT];
6750  		bool blnStartCommentBefore[N_CMNT], blnEndCommentBefore[N_CMNT], blnStartCommentAfter[N_CMNT], blnEndCommentAfter[N_CMNT];
6751  		intptr_t posStartComment, posEndComment;
6752  		intptr_t selectionStartMove, selectionEndMove;
6753  		int flags;
6754  		flags = SCFIND_WORDSTART;
6755  		_pEditView->execute(SCI_SETSEARCHFLAGS, flags);
6756  		posStartCommentBefore[iSelStart] = _pEditView->searchInTarget(start_comment.c_str(), start_comment_length, selectionStart, 0);
6757  		(posStartCommentBefore[iSelStart] == -1 ? blnStartCommentBefore[iSelStart] = false : blnStartCommentBefore[iSelStart] = true);
6758  		posEndCommentBefore[iSelStart] = _pEditView->searchInTarget(end_comment.c_str(), end_comment_length, selectionStart, 0);
6759  		(posEndCommentBefore[iSelStart] == -1 ? blnEndCommentBefore[iSelStart] = false : blnEndCommentBefore[iSelStart] = true);
6760  		posStartCommentAfter[iSelStart] = _pEditView->searchInTarget(start_comment.c_str(), start_comment_length, selectionStart, docLength);
6761  		(posStartCommentAfter[iSelStart] == -1 ? blnStartCommentAfter[iSelStart] = false : blnStartCommentAfter[iSelStart] = true);
6762  		posEndCommentAfter[iSelStart] = _pEditView->searchInTarget(end_comment.c_str(), end_comment_length, selectionStart, docLength);
6763  		(posEndCommentAfter[iSelStart] == -1 ? blnEndCommentAfter[iSelStart] = false : blnEndCommentAfter[iSelStart] = true);
6764  		if ((blnStartCommentBefore[iSelStart] && blnEndCommentAfter[iSelStart])
6765  			&& (!blnEndCommentBefore[iSelStart] || (posStartCommentBefore[iSelStart] >= posEndCommentBefore[iSelStart]))
6766  			&& (!blnStartCommentAfter[iSelStart] || (posEndCommentAfter[iSelStart] <= posStartCommentAfter[iSelStart])))
6767  		{
6768  				posStartComment = posStartCommentBefore[iSelStart];
6769  				posEndComment   = posEndCommentAfter[iSelStart];
6770  		}
6771  		else 
6772  		{
6773  			posStartCommentBefore[iSelEnd] = _pEditView->searchInTarget(start_comment.c_str(), start_comment_length, selectionEnd, 0);
6774  			(posStartCommentBefore[iSelEnd] == -1 ? blnStartCommentBefore[iSelEnd] = false : blnStartCommentBefore[iSelEnd] = true);
6775  			posEndCommentBefore[iSelEnd] = _pEditView->searchInTarget(end_comment.c_str(), end_comment_length, selectionEnd, 0);
6776  			(posEndCommentBefore[iSelEnd] == -1 ? blnEndCommentBefore[iSelEnd] = false : blnEndCommentBefore[iSelEnd] = true);
6777  			posStartCommentAfter[iSelEnd] = _pEditView->searchInTarget(start_comment.c_str(), start_comment_length, selectionEnd, docLength);
6778  			(posStartCommentAfter[iSelEnd] == -1 ? blnStartCommentAfter[iSelEnd] = false : blnStartCommentAfter[iSelEnd] = true);
6779  			posEndCommentAfter[iSelEnd] = _pEditView->searchInTarget(end_comment.c_str(), end_comment_length, selectionEnd, docLength);
6780  			(posEndCommentAfter[iSelEnd] == -1 ? blnEndCommentAfter[iSelEnd] = false : blnEndCommentAfter[iSelEnd] = true);
6781  			if ((blnStartCommentBefore[iSelEnd] && blnEndCommentAfter[iSelEnd])
6782  				&& (!blnEndCommentBefore[iSelEnd] || (posStartCommentBefore[iSelEnd] >= posEndCommentBefore[iSelEnd]))
6783  				&& (!blnStartCommentAfter[iSelEnd] || (posEndCommentAfter[iSelEnd] <= posStartCommentAfter[iSelEnd])))
6784  			{
6785  					posStartComment = posStartCommentBefore[iSelEnd];
6786  					posEndComment   = posEndCommentAfter[iSelEnd];
6787  			}
6788  			else if ( (blnStartCommentAfter[iSelStart] && (posStartCommentAfter[iSelStart] < selectionEnd))
6789  				&& (blnEndCommentBefore[iSelEnd] && (posEndCommentBefore[iSelEnd] >  selectionStart)))
6790  			{
6791  					posStartComment = posStartCommentAfter[iSelStart];
6792  					posEndComment   = posEndCommentAfter[iSelStart];
6793  			}
6794  			else
6795  			{
6796  				_pEditView->execute(SCI_ENDUNDOACTION);
6797  				return retVal;
6798  			}
6799  		}
6800  		retVal = true;
6801  		intptr_t startCommentLength = start_comment_length;
6802  		intptr_t endCommentLength = end_comment_length;
6803  		_pEditView->getGenericText(charbuf, charbufLen, posEndComment-1, posEndComment);
6804  		if (wcsncmp(charbuf, white_space.c_str(), white_space.length()) == 0)
6805  		{
6806  			endCommentLength +=1;
6807  			posEndComment-=1;
6808  		}
6809  		_pEditView->execute(SCI_BEGINUNDOACTION);
6810  		_pEditView->execute(SCI_SETSEL, posEndComment, posEndComment + endCommentLength);
6811  		_pEditView->execute(SCI_REPLACESEL, 0, reinterpret_cast<LPARAM>(""));
6812  		_pEditView->getGenericText(charbuf, charbufLen, posStartComment+startCommentLength, posStartComment+startCommentLength+1);
6813  		if (wcsncmp(charbuf, white_space.c_str(), white_space.length()) == 0)
6814  			startCommentLength +=1;
6815  		_pEditView->execute(SCI_SETSEL, posStartComment, posStartComment + startCommentLength);
6816  		_pEditView->execute(SCI_REPLACESEL, 0, reinterpret_cast<LPARAM>(""));
6817  		_pEditView->execute(SCI_ENDUNDOACTION);
6818  		if (selectionStart > posStartComment)
6819  		{
6820  			if (selectionStart >= posStartComment+startCommentLength)
6821  				selectionStartMove = -startCommentLength;
6822  			else
6823  				selectionStartMove = -selectionStart - posStartComment;
6824  		}
6825  		else
6826  			selectionStartMove = 0;
6827  		if (selectionEnd >= posEndComment+endCommentLength)
6828  			selectionEndMove = -startCommentLength+endCommentLength;
6829  		else if (selectionEnd <= posEndComment)
6830  			selectionEndMove = -startCommentLength;
6831  		else
6832  			selectionEndMove = -startCommentLength + (selectionEnd - posEndComment);
6833  		if (move_caret)
6834  		{
6835  			_pEditView->execute(SCI_GOTOPOS, selectionEnd+selectionEndMove);
6836  			_pEditView->execute(SCI_SETCURRENTPOS, selectionStart+selectionStartMove);
6837  		}
6838  		else
6839  		{
6840  			_pEditView->execute(SCI_SETSEL, selectionStart+selectionStartMove, selectionEnd+selectionEndMove);
6841  		}
6842  	}
6843  	while (1); 
6844  }
6845  void Notepad_plus::monitoringStartOrStopAndUpdateUI(Buffer* pBuf, bool isStarting)
6846  {
6847  	if (pBuf)
6848  	{
6849  		if (isStarting)
6850  			pBuf->startMonitoring();
6851  		else
6852  			pBuf->stopMonitoring();
6853  		checkMenuItem(IDM_VIEW_MONITORING, isStarting);
6854  		_toolBar.setCheck(IDM_VIEW_MONITORING, isStarting);
6855  		pBuf->setUserReadOnly(isStarting);
6856  	}
6857  }
6858  void Notepad_plus::createMonitoringThread(Buffer* pBuf)
6859  {
6860  	MonitorInfo *monitorInfo = new Notepad_plus::MonitorInfo(pBuf, _pPublicInterface->getHSelf());
6861  	HANDLE hThread = ::CreateThread(NULL, 0, monitorFileOnChange, (void *)monitorInfo, 0, NULL); 
6862  	if (hThread != nullptr)
6863  		::CloseHandle(hThread);
6864  }
6865  void Notepad_plus::updateCommandShortcuts()
6866  {
6867  	NppParameters& nppParam = NppParameters::getInstance();
6868  	vector<CommandShortcut> & shortcuts = nppParam.getUserShortcuts();
6869  	size_t len = shortcuts.size();
6870  	for (size_t i = 0; i < len; ++i)
6871  	{
6872  		CommandShortcut & csc = shortcuts[i];
6873  		unsigned long id = csc.getID();
6874  		generic_string localizedMenuName = _nativeLangSpeaker.getNativeLangMenuString(id);
6875  		generic_string menuName = localizedMenuName;
6876  		generic_string shortcutName = _nativeLangSpeaker.getShortcutNameString(id);
6877  		if (menuName.length() == 0)
6878  		{
6879  			TCHAR szMenuName[menuItemStrLenMax];
6880  			if (::GetMenuString(_mainMenuHandle, csc.getID(), szMenuName, menuItemStrLenMax, MF_BYCOMMAND))
6881  				menuName = purgeMenuItemString(szMenuName, true);
6882  			else
6883  				menuName = csc.getShortcutName();
6884  		}
6885  		if (shortcutName.length() == 0)
6886  		{
6887  			if (localizedMenuName.length() > 0)
6888  				shortcutName = localizedMenuName;
6889  			else if (csc.getShortcutName()[0])
6890  				shortcutName = csc.getShortcutName();
6891  			else
6892  				shortcutName = menuName;
6893  		}
6894  		csc.setName(wstring2string(menuName, CP_UTF8).c_str(), wstring2string(shortcutName, CP_UTF8).c_str());
6895  	}
6896  }
6897  HBITMAP Notepad_plus::generateSolidColourMenuItemIcon(COLORREF colour)
6898  {
6899  	HDC hDC = GetDC(NULL);
6900  	const int bitmapXYsize = 16;
6901  	HBITMAP hNewBitmap = CreateCompatibleBitmap(hDC, bitmapXYsize, bitmapXYsize);
6902  	HDC hDCn = CreateCompatibleDC(hDC);
6903  	HBITMAP hOldBitmap = static_cast<HBITMAP>(SelectObject(hDCn, hNewBitmap));
6904  	RECT rc = { 0, 0, bitmapXYsize, bitmapXYsize };
6905  	HBRUSH hBlackBrush = CreateSolidBrush(RGB(0,0,0));
6906  	FillRect(hDCn, &rc, hBlackBrush);
6907  	DeleteObject(hBlackBrush);
6908  	rc.left = rc.top = 1;
6909  	rc.right = rc.bottom = bitmapXYsize - 1;
6910  	HBRUSH hColorBrush = CreateSolidBrush(colour);
6911  	FillRect(hDCn, &rc, hColorBrush);
6912  	DeleteObject(hColorBrush);
6913  	SelectObject(hDCn, hOldBitmap);
6914  	DeleteDC(hDCn);
6915  	return hNewBitmap;
6916  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-Notepad_plus.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-Notepad_plus.cpp</div>
                </div>
                <div class="column column_space"><pre><code>3541  	Buffer * buf = MainFileManager.getBufferByID(tabToCheck->getBufferByIndex(0));
3542  	bool canHide = ((tabToCheck->nbItem() == 1) && !buf->isDirty() && buf->isUntitled());
3543  	return canHide;
3544  }
3545  bool Notepad_plus::isEmpty()
</pre></code></div>
                <div class="column column_space"><pre><code>3549  	Buffer * buf = MainFileManager.getBufferByID(tabToCheck->getBufferByIndex(0));
3550  	bool isEmpty = ((tabToCheck->nbItem() == 1) && !buf->isDirty() && buf->isUntitled());
3551  	return isEmpty;
3552  }
3553  void Notepad_plus::loadBufferIntoView(BufferID id, int whichOne, bool dontClose)
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    