
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 24.12818096135721%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-hldoc.h</h3>
            <pre><code>1  #ifndef HlDoc_h
2  #define HlDoc_h
3  #include "base.h"
4  #include "stopword.h"
5  #include "webold.h"
6  class THldBs;
7  typedef TPt<THldBs> PHldBs;
8  class THldWordDs{
9  private:
10    TCRef CRef;
11  public:
12    TFlt SumWordFq;
13    TIntFltKdV WordIdFqKdV;
14  public:
15    THldWordDs(const int& MxWordIds=0):
16      SumWordFq(0), WordIdFqKdV(MxWordIds, 0){}
17    ~THldWordDs(){}
18    THldWordDs(TSIn& SIn):
19      SumWordFq(SIn), WordIdFqKdV(SIn){}
20    static TPt<THldWordDs> Load(TSIn& SIn){return new THldWordDs(SIn);}
21    void Save(TSOut& SOut){
22      SumWordFq.Save(SOut); WordIdFqKdV.Save(SOut);}
23    THldWordDs& operator=(const THldWordDs& HldWordDs){
24      if (this!=&HldWordDs){
25        SumWordFq=HldWordDs.SumWordFq; WordIdFqKdV=HldWordDs.WordIdFqKdV;}
26      return *this;}
27    void AddWordIdFq(const TIntFltKd& WordIdFqKd);
28    void AddWordIdFq(const int& WordId, const double& WordFq){
29      AddWordIdFq(TIntFltKd(WordId, WordFq));}
30    bool IsWordId(const int& WordId, double& WordFq) const {
31      int WordIdFqKdN=WordIdFqKdV.SearchBin(TInt(WordId));
32      if (WordIdFqKdN==-1){return false;}
33      else {WordFq=WordIdFqKdV[WordIdFqKdN].Dat; return true;}}
34    bool IsWordId(const int& WordId) const {double WordFq;
35      return IsWordId(WordId, WordFq);}
36    double GetWordFq(const int& WordId) const {
37      return WordIdFqKdV[WordIdFqKdV.SearchBin(TInt(WordId))].Dat;}
38    double GetWordPrb(const int& WordId) const {double WordFq;
39      if (IsWordId(WordId, WordFq)){return WordFq/SumWordFq;} else {return 0;}}
40    int GetWordIds() const {return WordIdFqKdV.Len();}
41    double GetSumWordFq(){return SumWordFq;}
42    int FFirstWordId() const {return 0-1;}
43    bool FNextWordId(
44     int& WordIdN, int& WordId, double& WordFq, double& WordPrb) const;
45    void NrToSumWordFq(const double& NrSumWordFq);
46    void PowWordFq(const double& Exp);
47    void SaveTxt(const PSOut& SOut, const PHldBs& HldBs);
48    static TPt<THldWordDs> GetMerged(
49     const TPt<THldWordDs>& LWordDs, const TPt<THldWordDs>& RWordDs);
50    static TPt<THldWordDs> GetTruncByMxWords(
51     const TPt<THldWordDs>& WordDs, const int& MxWords);
52    static double GetDist(
53     const TPt<THldWordDs>& LWordDs, const TPt<THldWordDs>& RWordDs,
54     const PHldBs& HldBs);
55    static void GetHypTsEst(
56     const TPt<THldWordDs>& RefWordDs, const TPt<THldWordDs>& HypWordDs,
57     double& Precis, double& Recall, double& Dist, double& F2);
58    friend TPt<THldWordDs>;
59  };
60  typedef TPt<THldWordDs> PHldWordDs;
61  class THldWord{
62  private:
63    THldBs* HldBs;
64    TInt FirstChN;
65  public:
66    THldWord(): HldBs(NULL), FirstChN(-1){}
67    THldWord(const THldWord& HldWord):
68      HldBs(HldWord.HldBs), FirstChN(HldWord.FirstChN){}
69    THldWord(THldBs* _HldBs, const TStr& Str);
70    ~THldWord(){}
71    THldWord(TSIn& SIn): HldBs(NULL), FirstChN(SIn){}
72    void Save(TSOut& SOut){FirstChN.Save(SOut);}
73    THldWord& operator=(const THldWord& HldWord){
74      if (this!=&HldWord){HldBs=HldWord.HldBs; FirstChN=HldWord.FirstChN;}
75      return *this;}
76    bool operator==(const THldWord& HldWord) const {
77      return (GetStr()==HldWord.GetStr());}
78    bool operator<(const THldWord& HldWord) const {
79      return GetStr()<HldWord.GetStr();}
80    TStr GetStr() const;
81    int GetPrimHashCd() const {return GetStr().GetPrimHashCd();}
82    int GetSecHashCd() const {return GetStr().GetSecHashCd();}
83    friend THldBs;
84  };
85  class THlDoc{
86  private:
87    TInt HlId;
88    TInt DocId;
89    PHldWordDs HlWordDs;
90  public:
<span onclick='openModal()' class='match'>91    THlDoc(): HlId(-1), DocId(-1), HlWordDs(NULL){}
92    THlDoc(const int& _HlId, const int& _DocId, const PHldWordDs& _HlWordDs):
93      HlId(_HlId), DocId(_DocId), HlWordDs(_HlWordDs){}
</span>94    ~THlDoc(){}
95    THlDoc(TSIn& SIn):
96      HlId(SIn), DocId(SIn), HlWordDs(SIn){}
97    void Save(TSOut& SOut){
98      HlId.Save(SOut); DocId.Save(SOut); HlWordDs.Save(SOut);}
99    THlDoc& operator=(const THlDoc& HlDoc){
100      HlId=HlDoc.HlId; DocId=HlDoc.DocId; HlWordDs=HlDoc.HlWordDs; return *this;}
101    int GetHlId(){return HlId;}
102    int GetDocId(){return DocId;}
103    PHldWordDs GetHlWordDs(){return HlWordDs;}
104  };
105  class THldBs{
106  private:
107    TCRef CRef;
108  private:
109    TInt MxNGram;
110    TInt MnWordFq;
111    PSwSet SwSet;
112    THash<THldWord, TInt> WordToFqH;
113    TChA WordChAHeap;
114    TIntV WordIdVHeap;
115    THash<TInt, TStr> DocIdToUrlStrH;
116    TVec<THlDoc> HlDocV;
117    PNotify Notify;
118    void PutThisToWord();
119    TStr GetStrQStr(const TStrQ& StrQ, const int& Strs=-1);
120  public:
121    THldBs(
122     const TStrV& HlCtxStrV, const PXWebBs& WebBs,
123     const int& _MxNGram, const int& _MnWordFq,
124     const TSwSetTy& SwSetTy, const PNotify& _Notify);
125    ~THldBs(){}
126    THldBs(TSIn& SIn, const PNotify& _Notify=NULL):
127      MxNGram(SIn), MnWordFq(SIn), SwSet(SIn),
128      WordToFqH(SIn), WordChAHeap(SIn), WordIdVHeap(SIn),
129      DocIdToUrlStrH(SIn), HlDocV(SIn), Notify(_Notify){
130      SIn.LoadCs(); PutThisToWord();}
131    static TPt<THldBs> Load(TSIn& SIn){return new THldBs(SIn);}
132    void Save(TSOut& SOut){
133      MxNGram.Save(SOut); MnWordFq.Save(SOut); SwSet.Save(SOut);
134      WordToFqH.Save(SOut); WordChAHeap.Save(SOut); WordIdVHeap.Save(SOut);
135      DocIdToUrlStrH.Save(SOut); HlDocV.Save(SOut); SOut.SaveCs();}
136    THldBs& operator=(const THldBs&){Fail; return *this;}
137    int GetWords(){return WordToFqH.Len();}
138    TInt& AddWord(const TStr& WordStr);
139    int GetWordId(const TStr& WordStr);
140    TStr GetWordStr(const int& WordId){return WordToFqH.GetKey(WordId).GetStr();}
141    int GetWordFq(const int& WordId){return WordToFqH[WordId];}
142    int AddTxt(const TStr& TxtStr, const bool& DoGenDoc, const int& NGram);
143    int GetTxtLen(const int& TxtId);
144    PHldWordDs GetTxtWordDs(const int& TxtId);
145    PHldWordDs GetWordDs(const PSIn& SIn);
146    PHldWordDs GetWordDs(const TStr& Str){
147      PSIn SIn=TStrIn::New(Str); return GetWordDs(SIn);}
148    int GetHlDocs(){return HlDocV.Len();}
149    int GetHlId(const int& HlDocN){return HlDocV[HlDocN].GetHlId();}
150    int GetDocId(const int& HlDocN){return HlDocV[HlDocN].GetDocId();}
151    PHldWordDs GetHlWordDs(const int& HlDocN){
152      return HlDocV[HlDocN].GetHlWordDs();}
153    PHldWordDs GetDocWordDs(const int& HlDocN){
154      return GetTxtWordDs(HlDocV[HlDocN].GetDocId());}
155    TStr GetDocUrlStr(const int& HlDocN){
156      return DocIdToUrlStrH.GetDat(TInt(HlDocV[HlDocN].GetDocId()));}
157    void GetDistHlDocNV(
158     const int& KNNbrs, const bool& RndSel,
159     const PHldWordDs& RefHlWordDs, const TStrV& SelUrlStrV,
160     TFltIntKdV& DistHlDocNKdV);
161    PHldWordDs GetHypDocWordDs(const TFltIntKdV& DistHlDocNKdV);
162    void SaveTxt(const PSOut& SOut);
163    static TStr GetUrlStrFromHlCtxStr(const TStr& HlCtxStr);
164    friend THldWord;
165    friend TPt<THldBs>;
166  };
167  typedef TPt<THldBs> PHldBs;
168  class THldExpr{
169  public:
170    static void PutMomHd(TOLx& Lx, const TStr& VarNm);
171    static void PutMomVal(TOLx& Lx, const PMom& Mom);
172    static void Go(
173     const PSOut& SOut, const bool& PutHd, const bool& SaveTmp,
174     const TStr& HldDmNm, const int& TsRuns,
175     const TStrV& AllHlCtxStrV, const PXWebBs& DocWebBs,
176     const int& MxNGram, const int& MnWordFq, const TSwSetTy& SwSetTy,
177     const int& KNNbrs, const bool& RndSel,
178     const PNotify& Notify);
179  };
180  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-tb.h</h3>
            <pre><code>1  ClassHdTP(TTb, PTb);
2  typedef enum {
3    tsvcUndef, tsvcIgnore, tsvcLabel, tsvcClass, tsvcAttr} TTbSufixVarCat;
4  ClassTPV(TTbVarType, PTbVarType, TTbVarTypeV)
5  private:
6    TBool DefP;
7    TB32Set AlwVTSet;
8    TB32Set FixVTSet;
9    TBool DscIntP, DscOrdP;
10    TInt MnIntDsc, MxIntDsc;
11    TStrV DscToNmV;
12    TStrIntH NmToDscH;
13    TFlt MnFlt, MxFlt;
14  public:
15    TTbVarType():
16      AlwVTSet(TB32Set().Fill()), FixVTSet(),
17      DscIntP(false), DscOrdP(false),
18      MnIntDsc(0), MxIntDsc(0),
19      DscToNmV(), NmToDscH(10),
20      MnFlt(TFlt::Mx), MxFlt(TFlt::Mn){}
21    TTbVarType(TSIn& SIn):
22      DefP(SIn),
23      AlwVTSet(SIn), FixVTSet(SIn),
24      DscIntP(SIn), DscOrdP(SIn),
25      MnIntDsc(SIn), MxIntDsc(SIn),
26      DscToNmV(SIn), NmToDscH(SIn),
27      MnFlt(SIn), MxFlt(SIn){
28      Assert(DefP);}
29    static PTbVarType Load(TSIn& SIn){return new TTbVarType(SIn);}
30    void Save(TSOut& SOut){
31      Assert(DefP); DefP.Save(SOut),
32      FixVTSet.Save(SOut); AlwVTSet.Save(SOut);
33      DscIntP.Save(SOut); DscOrdP.Save(SOut);
34      MnIntDsc.Save(SOut); MxIntDsc.Save(SOut);
35      DscToNmV.Save(SOut); NmToDscH.Save(SOut);
36      MnFlt.Save(SOut); MxFlt.Save(SOut);}
37    void Def(){Assert(!DefP); DefP=true;}
38    bool IsDef() const {return DefP;}
39    TTbVarType& operator=(const TTbVarType& TbVarType){
40      Assert(!DefP); DefP=TbVarType.DefP;
41      FixVTSet=TbVarType.FixVTSet; AlwVTSet=TbVarType.AlwVTSet;
42      DscIntP=TbVarType.DscIntP; DscOrdP=TbVarType.DscOrdP;
43      MnIntDsc=TbVarType.MnIntDsc; MxIntDsc=TbVarType.MxIntDsc;
44      DscToNmV=TbVarType.DscToNmV; NmToDscH=TbVarType.NmToDscH;
45      MnFlt=TbVarType.MnFlt; MxFlt=TbVarType.MxFlt; return *this;}
46    bool operator==(const TTbVarType& TbVarType) const {
47      Assert(DefP);
48      if (this==&TbVarType){return true;}
49      return (DefP==TbVarType.DefP)&&
50       (AlwVTSet==TbVarType.AlwVTSet)&&(FixVTSet==TbVarType.FixVTSet)&&
51       (DscIntP==TbVarType.DscIntP)&&(DscOrdP==TbVarType.DscOrdP)&&
52       (MnIntDsc==TbVarType.MnIntDsc)&&(MxIntDsc==TbVarType.MxIntDsc)&&
53       (DscToNmV==TbVarType.DscToNmV)&&
54       (MnFlt==TbVarType.MnFlt)&&(MxFlt==TbVarType.MxFlt);}
55    TB32Set GetAlwVTSet() const {return AlwVTSet;}
56    void SetAlwVTSet(const TB32Set& _AlwVTSet){
57      Assert(!DefP); AlwVTSet=_AlwVTSet;}
58    TB32Set GetFixVTSet() const {return FixVTSet;}
59    void SetDscFix(const int& _MnIntDsc, const int& _MxIntDsc){
60      Assert(!DefP && !FixVTSet.In(tvtDsc) && (_MnIntDsc<=_MxIntDsc));
61      FixVTSet.Incl(tvtDsc);
62      DscIntP=true; DscOrdP=true; MnIntDsc=_MnIntDsc; MxIntDsc=_MxIntDsc;}
63    void SetDscFix(bool _DscOrd=false){
64      Assert(!DefP && !FixVTSet.In(tvtDsc) && (DscToNmV.Len()==0));
65      FixVTSet.Incl(tvtDsc);
66      DscIntP=false; DscOrdP=_DscOrd; MnIntDsc=0; MxIntDsc=0;}
67    int AddDscNm(const TStr& Str){
68      Assert(!DefP && FixVTSet.In(tvtDsc) && !DscIntP);
69      Assert(NmToDscH.GetKeyId(Str)==-1);
70      return NmToDscH.AddDat(Str, TInt(DscToNmV.Add(Str)));}
71    void SetFltFix(const double& _MnFlt, const double& _MxFlt){
72      Assert(!DefP && !FixVTSet.In(tvtFlt) && (_MnFlt<=_MxFlt));
73      FixVTSet.Incl(tvtFlt);
74      MnFlt=_MnFlt; MxFlt=_MxFlt;}
75    bool IsDsc() const {Assert(DefP);
76      return AlwVTSet.In(tvtDsc) && (FixVTSet.In(tvtDsc) || DscToNmV.Len()>0);}
77    bool IsDscInt() const {Assert(IsDsc()); return DscIntP;}
78    bool IsDscSym() const {Assert(IsDsc()); return !DscIntP;}
79    bool IsDscOrd() const {Assert(IsDsc()); return DscOrdP;}
80    int GetDscs() const {Assert(IsDsc());
81      if (DscIntP){return MxIntDsc-MnIntDsc+1;} else {return DscToNmV.Len();}}
82    int GetMnIntDsc() const {Assert(IsDscInt()); return MnIntDsc;}
83    int GetMxIntDsc() const {Assert(IsDscInt()); return MxIntDsc;}
84    TStr GetDscStr(const int& Dsc) const {return DscToNmV[Dsc];}
85    void GetDscStrV(TStrV& DscStrV) const {
86      Assert(IsDscSym()); int Dscs=GetDscs(); DscStrV.Gen(Dscs, 0);
87      for (int Dsc=0; Dsc<Dscs; Dsc++){DscStrV.Add(GetDscStr(Dsc));}}
88    bool IsFlt() const {Assert(DefP);
89      return AlwVTSet.In(tvtFlt) && (FixVTSet.In(tvtFlt) || (MnFlt<=MxFlt));}
90    double GetFltRange() const {Assert(IsFlt()); return MxFlt-MnFlt;}
91    double GetMnFlt() const {Assert(IsFlt()); return MnFlt;}
92    double GetMxFlt() const {Assert(IsFlt()); return MxFlt;}
93    TStr GetStr() const;
94    bool IsValOk(const TTbVal& Val);
95    TTbVal GetDscVal(const TStr& Str);
96    TTbVal GetDscVal(const int& Dsc);
97    TTbVal GetIntDscVal(const int& Int);
98    TTbVal GetFltVal(const double& Flt);
99    TTbVal GetVal(const TTbVal& Val);
100    double GetNrmFlt(const TTbVal& Val);
101    TStr GetValStr(const TTbVal& Val);
102    static PTbVarType GetDscBoolVarType();
103    static PTbVarType GetDscIntVarType(
104     const int& MnIntDsc, const int& MxIntDsc);
105    static PTbVarType GetDscNmVVarType(
106     const TStrV& NmV, const bool& DscOrdP=false);
107    static PTbVarType GetFltVarType(
108     const double& MnFlt=TFlt::Mn, const double& MxFlt=TFlt::Mx);
109    static TTbSufixVarCat GetSufixVarCat(const TStr& VarNm);
110    static bool IsSuffixVarNm(const PTb& Tb);
111  };
112  ClassTPV(TTbVar, PTbVar, TTbVarV)
113  private:
114    UndefCopy(TTbVar);
115  public:
116    TTbVar(){}
117    virtual ~TTbVar(){}
118    TTbVar(TSIn&){}
119    static PTbVar Load(TSIn&){Fail; return NULL;}
120    virtual void Save(TSOut&){}
121    TTbVar& operator=(const TTbVar&){return *this;}
122    bool operator==(const TTbVar& TbVar) const {
123      return (GetNm()==TbVar.GetNm())&&(GetVarType()==TbVar.GetVarType())&&
124       (GetActVTSet()==TbVar.GetActVTSet());}
125    virtual TStr GetNm() const=0;
126    virtual PTbVarType GetVarType() const=0;
127    virtual TB32Set GetActVTSet() const=0;
128    virtual void DefVarType()=0;
129    virtual TTbVal GetDscVal(const TStr& Str)=0;
130    virtual TTbVal GetDscVal(const int& Dsc)=0;
131    virtual TTbVal GetFltVal(const double& Flt)=0;
132    virtual TTbVal GetVal(const TTbVal& Val)=0;
133  };
134  ClassTPV(TTbTup, PTbTup, TTbTupV)
135  private:
136    UndefCopy(TTbTup);
137  public:
138    TTbTup(){}
139    TTbTup(TSIn&){}
140    virtual ~TTbTup(){}
141    static PTbTup Load(TSIn&){Fail; return NULL;}
142    virtual void Save(TSOut&){}
143    TTbTup& operator=(const TTbTup&){return *this;}
144    virtual void PutNm(const TStr& _Nm)=0;
145    virtual TStr GetNm()=0;
146    virtual void PutVal(int VarN, const TTbVal& Val)=0;
147    virtual TTbVal GetVal(int VarN)=0;
148  };
149  ClassTPV(TTb, PTb, TTbV)
150  private:
151    TStr Nm;
152    UndefCopyAssign(TTb);
153  public:
154    TTb(): Nm("Untitled-Table"){}
155    virtual ~TTb(){}
156    TTb(TSIn& SIn): Nm(SIn){}
157    static PTb Load(TSIn& SIn);
158    virtual void Save(TSOut& SOut){GetTypeNm(*this).Save(SOut); Nm.Save(SOut);}
159    void PutNm(const TStr& _Nm){Nm=_Nm;}
160    TStr GetNm(){return Nm;}
161    void AddTb(const PTb& Tb);
162    PTb GetSubTb(const TIntV& TupNV, const TIntV& VarNV, const PTb& Tb);
163    virtual int AddVar(const PTbVar& TbVar)=0;
164    virtual void DefVarTypes()=0;
165    virtual int GetVars()=0;
166    virtual PTbVar GetVar(const int& VarN)=0;
167    virtual int GetVarN(const TStr& Nm)=0;
168    virtual int AddTup(const TStr& Nm)=0;
169    int AddTup(){return AddTup(TStr());}
170    virtual int GetTups()=0;
171    virtual TStr GetTupNm(const int& TupN)=0;
172    virtual int GetTupN(const TStr& Nm)=0;
173    virtual void PutDsc(const int& TupN, const int& VarN, const TStr& Str)=0;
174    virtual void PutDsc(const int& TupN, const int& VarN, const int& Dsc)=0;
175    virtual void PutFlt(const int& TupN, const int& VarN, const double& Flt)=0;
176    virtual void PutVal(const int& TupN, const int& VarN, const TTbVal& Val)=0;
177    virtual TTbVal GetVal(const int& TupN, const int& VarN)=0;
178    virtual TStr GetValStr(const int& TupN, const int& VarN)=0;
179    static PTb LoadFile(const TStr& FNm, const TStr& FType, const TStr& MemRep);
180    static PTb LoadTxtSpc(const TStr& FNm, const PTb& Tb);
181    static PTb LoadTxtTab(const TStr& FNm, const PTb& Tb);
182    static PTb LoadTxtCsv(const TStr& FNm, const PTb& Tb);
183    void SaveTxt(const TStr& FNm, const bool& SaveTupNm=true);
184    void SaveAssis(const TStr& FNm);
185  };
186  class TGTbVar: public TTbVar{
187  private:
188    TStr Nm;
189    PTbVarType VarType;
190    TB32Set ActVTSet;
191  public:
192    TGTbVar(): TTbVar(), Nm(), VarType(), ActVTSet(){}
193    TGTbVar(const TStr& _Nm, const PTbVarType& _VarType):
194      TTbVar(), Nm(_Nm), VarType(_VarType), ActVTSet(){}
195    TGTbVar(TSIn& SIn):
196      TTbVar(SIn), Nm(SIn), VarType(SIn), ActVTSet(SIn){}
197    void Save(TSOut& SOut){
198      TTbVar::Save(SOut); Nm.Save(SOut); VarType.Save(SOut); ActVTSet.Save(SOut);}
199    TGTbVar& operator=(const TGTbVar& GTbVar){
200      TTbVar::operator=(GTbVar);
201      Nm=GTbVar.Nm; ActVTSet=GTbVar.ActVTSet; VarType=GTbVar.VarType;
202      return *this;}
203    TStr GetNm() const {return Nm;}
204    PTbVarType GetVarType() const {return VarType;}
205    TB32Set GetActVTSet() const {return ActVTSet;}
206    void DefVarType(){VarType->Def();}
207    TTbVal GetDscVal(const TStr& Str){
208      ActVTSet.Incl(tvtDsc); return VarType->GetDscVal(Str);}
209    TTbVal GetDscVal(const int& Dsc){
210      ActVTSet.Incl(tvtDsc); return VarType->GetDscVal(Dsc);}
211    TTbVal GetFltVal(const double& Flt){
212      ActVTSet.Incl(tvtFlt); return VarType->GetFltVal(Flt);}
213    TTbVal GetVal(const TTbVal& Val){
214      ActVTSet.Incl(Val.GetValTag()); return VarType->GetVal(Val);}
215  };
216  class TGTbTup: public TTbTup{
217    TStr Nm;
218    TTbValV ValV;
219  public:
220    TGTbTup(): TTbTup(), Nm(), ValV(){}
221    TGTbTup(const TStr& _Nm, const int& Vars): TTbTup(), Nm(_Nm), ValV(Vars){}
222    TGTbTup(TSIn& SIn): TTbTup(SIn), Nm(SIn), ValV(SIn){}
223    virtual ~TGTbTup(){}
224    void Save(TSOut& SOut){TTbTup::Save(SOut); Nm.Save(SOut); ValV.Save(SOut);}
225    TGTbTup& operator=(const TGTbTup& GTbTup){
226      TTbTup::operator=(GTbTup); Nm=GTbTup.Nm; ValV=GTbTup.ValV; return *this;}
227    void PutNm(const TStr& _Nm){Nm=_Nm;}
228    TStr GetNm(){return Nm;}
229    void PutVal(int VarN, const TTbVal& Val){ValV[VarN]=Val;}
230    TTbVal GetVal(int VarN){return ValV[VarN];}
231  };
232  class TGTb: public TTb{
233  private:
234    TTbVarV VarV;
235    TStrIntH VarNmToNH;
236    TTbTupV TupV;
237    TStrIntH TupNmToNH;
238  public:
239    TGTb(const int& MxVars=0, const int& MxTups=0):
240      TTb(), VarV(MxVars, 0), VarNmToNH(MxVars>0?MxVars:100),
241      TupV(MxTups, 0), TupNmToNH(MxTups>0?MxTups:100){}
242    TGTb(TSIn& SIn):
243      TTb(SIn), VarV(SIn), VarNmToNH(SIn),
244      TupV(SIn), TupNmToNH(SIn){SIn.LoadCs();}
245    void Save(TSOut& SOut){
246      TTb::Save(SOut); VarV.Save(SOut); VarNmToNH.Save(SOut);
247      TupV.Save(SOut); SOut.SaveCs();}
248    int AddVar(const PTbVar& TbVar);
249    void DefVarTypes();
250    int GetVars(){return VarV.Len();}
251    PTbVar GetVar(const int& VarN){return VarV[VarN];}
252    int GetVarN(const TStr& Nm){return VarNmToNH.GetDat(Nm);}
253    int AddTup(const TStr& Nm);
254    int GetTups(){return TupV.Len();}
255    TStr GetTupNm(const int& TupN){return TupV[TupN]->GetNm();}
256    int GetTupN(const TStr& Nm){return TupNmToNH.GetDat(Nm);}
257    void PutDsc(const int& TupN, const int& VarN, const TStr& Str){
258      TupV[TupN]->PutVal(VarN, VarV[VarN]->GetDscVal(Str));}
259    void PutDsc(const int& TupN, const int& VarN, const int& Dsc){
260      TupV[TupN]->PutVal(VarN, VarV[VarN]->GetDscVal(Dsc));}
<span onclick='openModal()' class='match'>261    void PutFlt(const int& TupN, const int& VarN, const double& Flt){
262      TupV[TupN]->PutVal(VarN, VarV[VarN]->GetFltVal(Flt));}
263    void PutVal(const int& TupN, const int& VarN, const TTbVal& Val){
264      TupV[TupN]->PutVal(VarN, VarV[VarN]->GetVal(Val));}
</span>265    TTbVal GetVal(const int& TupN, const int& VarN){
266      return TupV[TupN]->GetVal(VarN);}
267    TStr GetValStr(const int& TupN, const int& VarN);
268  };
269  class TBTb: public TTb{
270  private:
271    TTbVarV VarV;
272    TStrIntH VarNmToNH;
273    TTbTupV TupV;
274    TStrIntH TupNmToNH;
275  public:
276    TBTb(const int& MxVars=0, const int& MxTups=0):
277      TTb(), VarV(MxVars, 0), VarNmToNH(MxVars>0?MxVars:100),
278      TupV(MxTups, 0), TupNmToNH(MxTups>0?MxTups:100){}
279    TBTb(TSIn& SIn):
280      TTb(SIn), VarV(SIn), VarNmToNH(SIn),
281      TupV(SIn), TupNmToNH(SIn){SIn.LoadCs();}
282    void Save(TSOut& SOut){
283      TTb::Save(SOut); VarV.Save(SOut); VarNmToNH.Save(SOut);
284      TupV.Save(SOut); SOut.SaveCs();}
285    int AddVar(const PTbVar& TbVar);
286    void DefVarTypes(){}
287    int GetVars(){return VarNmToNH.Len();}
288    PTbVar GetVar(const int& &bsol;*VarN*/){Fail; return NULL;}
289    int GetVarN(const TStr& Nm){return VarNmToNH.GetKeyId(Nm);}
290    int AddTup(const TStr& Nm);
291    int GetTups(){return TupV.Len();}
292    TStr GetTupNm(const int& TupN){return TupV[TupN]->GetNm();}
293    int GetTupN(const TStr& Nm){return TupNmToNH.GetDat(Nm);}
294    void PutDsc(const int& TupN, const int& VarN, const TStr& Str){
295      TupV[TupN]->PutVal(VarN, VarV[VarN]->GetDscVal(Str));}
296    void PutDsc(const int& TupN, const int& VarN, const int& Dsc){
297      TupV[TupN]->PutVal(VarN, VarV[VarN]->GetDscVal(Dsc));}
298    void PutFlt(const int& TupN, const int& VarN, const double& Flt){
299      TupV[TupN]->PutVal(VarN, VarV[VarN]->GetFltVal(Flt));}
300    void PutVal(const int& TupN, const int& VarN, const TTbVal& Val){
301      TupV[TupN]->PutVal(VarN, VarV[VarN]->GetVal(Val));}
302    TTbVal GetVal(const int& TupN, const int& VarN){
303      return TupV[TupN]->GetVal(VarN);}
304    TStr GetValStr(const int& TupN, const int& VarN);
305  };
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-hldoc.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-tb.h</div>
                </div>
                <div class="column column_space"><pre><code>91    THlDoc(): HlId(-1), DocId(-1), HlWordDs(NULL){}
92    THlDoc(const int& _HlId, const int& _DocId, const PHldWordDs& _HlWordDs):
93      HlId(_HlId), DocId(_DocId), HlWordDs(_HlWordDs){}
</pre></code></div>
                <div class="column column_space"><pre><code>261    void PutFlt(const int& TupN, const int& VarN, const double& Flt){
262      TupV[TupN]->PutVal(VarN, VarV[VarN]->GetFltVal(Flt));}
263    void PutVal(const int& TupN, const int& VarN, const TTbVal& Val){
264      TupV[TupN]->PutVal(VarN, VarV[VarN]->GetVal(Val));}
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    