
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 31, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-any_invocable_test.cc</h3>
            <pre><code>1  #include "absl/functional/any_invocable.h"
2  #include <cstddef>
3  #include <initializer_list>
4  #include <memory>
5  #include <numeric>
6  #include <type_traits>
7  #include "gtest/gtest.h"
8  #include "absl/base/config.h"
9  #include "absl/meta/type_traits.h"
10  #include "absl/utility/utility.h"
11  static_assert(absl::internal_any_invocable::kStorageSize >= sizeof(void*),
12                "These tests assume that the small object storage is at least "
13                "the size of a pointer.");
14  namespace {
15  #if ABSL_INTERNAL_CPLUSPLUS_LANG >= 201703L
16  #define ABSL_INTERNAL_NOEXCEPT_SPEC(noex) noexcept(noex)
17  #else
18  #define ABSL_INTERNAL_NOEXCEPT_SPEC(noex)
19  #endif
20  struct _ {};
21  template <class T>
22  struct Wrapper {
23    template <class U,
24              class = absl::enable_if_t<std::is_convertible<U, T>::value>>
25    Wrapper(U&&);  
26  };
27  static_assert(std::is_constructible<Wrapper<absl::AnyInvocable<void()>>,
28                                      Wrapper<absl::AnyInvocable<void()>>>::value,
29                "");
30  template <class Qualifiers, class This>
31  struct QualifiersForThisImpl {
32    static_assert(std::is_object<This>::value, "");
33    using type =
34        absl::conditional_t<std::is_const<Qualifiers>::value, const This, This>&;
35  };
36  template <class Qualifiers, class This>
37  struct QualifiersForThisImpl<Qualifiers&, This>
38      : QualifiersForThisImpl<Qualifiers, This> {};
39  template <class Qualifiers, class This>
40  struct QualifiersForThisImpl<Qualifiers&&, This> {
41    static_assert(std::is_object<This>::value, "");
42    using type =
43        absl::conditional_t<std::is_const<Qualifiers>::value, const This, This>&&;
44  };
45  template <class Qualifiers, class This>
46  using QualifiersForThis =
47      typename QualifiersForThisImpl<Qualifiers, This>::type;
48  template <class T, class Fun>
49  struct GiveQualifiersToFunImpl;
50  template <class T, class R, class... P>
51  struct GiveQualifiersToFunImpl<T, R(P...)> {
52    using type =
53        absl::conditional_t<std::is_const<T>::value, R(P...) const, R(P...)>;
54  };
55  template <class T, class R, class... P>
56  struct GiveQualifiersToFunImpl<T&, R(P...)> {
57    using type =
58        absl::conditional_t<std::is_const<T>::value, R(P...) const&, R(P...)&>;
59  };
60  template <class T, class R, class... P>
61  struct GiveQualifiersToFunImpl<T&&, R(P...)> {
62    using type =
63        absl::conditional_t<std::is_const<T>::value, R(P...) const&&, R(P...) &&>;
64  };
65  #if defined(__cpp_noexcept_function_type)
66  template <class T, class R, class... P>
67  struct GiveQualifiersToFunImpl<T, R(P...) noexcept> {
68    using type = absl::conditional_t<std::is_const<T>::value,
69                                     R(P...) const noexcept, R(P...) noexcept>;
70  };
71  template <class T, class R, class... P>
72  struct GiveQualifiersToFunImpl<T&, R(P...) noexcept> {
73    using type =
74        absl::conditional_t<std::is_const<T>::value, R(P...) const & noexcept,
75                            R(P...) & noexcept>;
76  };
77  template <class T, class R, class... P>
78  struct GiveQualifiersToFunImpl<T&&, R(P...) noexcept> {
79    using type =
80        absl::conditional_t<std::is_const<T>::value, R(P...) const && noexcept,
81                            R(P...) && noexcept>;
82  };
83  #endif  
84  template <class T, class Fun>
85  using GiveQualifiersToFun = typename GiveQualifiersToFunImpl<T, Fun>::type;
86  enum class ObjSize { small, large };
87  template <ObjSize Size>
88  struct TypeErasedPadding;
89  template <>
90  struct TypeErasedPadding<ObjSize::small> {};
91  template <>
92  struct TypeErasedPadding<ObjSize::large> {
93    char dummy_data[absl::internal_any_invocable::kStorageSize + 1] = {};
94  };
95  struct Int {
96    Int(int v) noexcept : value(v) {}  
97  #ifndef _MSC_VER
98    Int(Int&&) noexcept {
99      std::abort();
100    }
101  #else
102    Int(Int&& v) noexcept = default;
103  #endif
104    operator int() && noexcept { return value; }  
105    int MemberFunctionAdd(int const& b, int c) noexcept {  
106      return value + b + c;
107    }
108    int value;
109  };
110  enum class Movable { no, yes, nothrow, trivial };
111  enum class NothrowCall { no, yes };
112  enum class Destructible { nothrow, trivial };
113  enum class ObjAlign : std::size_t {
114    normal = absl::internal_any_invocable::kAlignment,
115    large = absl::internal_any_invocable::kAlignment * 2,
116  };
117  template <Movable Movability, Destructible Destructibility, class Qual,
118            NothrowCall CallExceptionSpec, ObjSize Size, ObjAlign Alignment>
119  struct add;
120  #define ABSL_INTERNALS_ADD(qual)                                              \
121    template <NothrowCall CallExceptionSpec, ObjSize Size, ObjAlign Alignment>  \
122    struct alignas(static_cast<std::size_t>(Alignment))                         \
123        add<Movable::trivial, Destructible::trivial, _ qual, CallExceptionSpec, \
124            Size, Alignment> : TypeErasedPadding<Size> {                        \
125      explicit add(int state_init) : state(state_init) {}                       \
126      explicit add(std::initializer_list<int> state_init, int tail)             \
127          : state(std::accumulate(std::begin(state_init), std::end(state_init), \
128                                  0) +                                          \
129                  tail) {}                                                      \
130      add(add&& other) = default; &bsol;*NOLINT*/                                    \
131      Int operator()(int a, int b, int c) qual                                  \
132          ABSL_INTERNAL_NOEXCEPT_SPEC(CallExceptionSpec == NothrowCall::yes) {  \
133        return state + a + b + c;                                               \
134      }                                                                         \
135      int state;                                                                \
136    };                                                                          \
137                                                                                \
138    template <NothrowCall CallExceptionSpec, ObjSize Size, ObjAlign Alignment>  \
139    struct alignas(static_cast<std::size_t>(Alignment))                         \
140        add<Movable::trivial, Destructible::nothrow, _ qual, CallExceptionSpec, \
141            Size, Alignment> : TypeErasedPadding<Size> {                        \
142      explicit add(int state_init) : state(state_init) {}                       \
143      explicit add(std::initializer_list<int> state_init, int tail)             \
144          : state(std::accumulate(std::begin(state_init), std::end(state_init), \
145                                  0) +                                          \
146                  tail) {}                                                      \
147      ~add() noexcept {}                                                        \
148      add(add&& other) = default; &bsol;*NOLINT*/                                    \
149      Int operator()(int a, int b, int c) qual                                  \
150          ABSL_INTERNAL_NOEXCEPT_SPEC(CallExceptionSpec == NothrowCall::yes) {  \
151        return state + a + b + c;                                               \
152      }                                                                         \
153      int state;                                                                \
154    }
155  #define ABSL_INTERNALS_NOARG
156  ABSL_INTERNALS_ADD(ABSL_INTERNALS_NOARG);
157  #undef ABSL_INTERNALS_NOARG
158  ABSL_INTERNALS_ADD(const);
159  ABSL_INTERNALS_ADD(&);
160  ABSL_INTERNALS_ADD(const&);
161  ABSL_INTERNALS_ADD(&&);       
162  ABSL_INTERNALS_ADD(const&&);  
163  #undef ABSL_INTERNALS_ADD
164  template <Destructible Destructibility, class Qual,
165            NothrowCall CallExceptionSpec, ObjSize Size, ObjAlign Alignment>
166  struct add<Movable::no, Destructibility, Qual, CallExceptionSpec, Size,
167             Alignment> : private add<Movable::trivial, Destructibility, Qual,
168                                      CallExceptionSpec, Size, Alignment> {
169    using Base = add<Movable::trivial, Destructibility, Qual, CallExceptionSpec,
170                     Size, Alignment>;
171    explicit add(int state_init) : Base(state_init) {}
172    explicit add(std::initializer_list<int> state_init, int tail)
173        : Base(state_init, tail) {}
174    add(add&&) = delete;
175    using Base::operator();
176    using Base::state;
177  };
178  template <Destructible Destructibility, class Qual,
179            NothrowCall CallExceptionSpec, ObjSize Size, ObjAlign Alignment>
180  struct add<Movable::yes, Destructibility, Qual, CallExceptionSpec, Size,
181             Alignment> : private add<Movable::trivial, Destructibility, Qual,
182                                      CallExceptionSpec, Size, Alignment> {
183    using Base = add<Movable::trivial, Destructibility, Qual, CallExceptionSpec,
184                     Size, Alignment>;
185    explicit add(int state_init) : Base(state_init) {}
186    explicit add(std::initializer_list<int> state_init, int tail)
187        : Base(state_init, tail) {}
188    add(add&& other) noexcept(false) : Base(other.state) {}  
189    using Base::operator();
190    using Base::state;
191  };
192  template <Destructible Destructibility, class Qual,
193            NothrowCall CallExceptionSpec, ObjSize Size, ObjAlign Alignment>
194  struct add<Movable::nothrow, Destructibility, Qual, CallExceptionSpec, Size,
195             Alignment> : private add<Movable::trivial, Destructibility, Qual,
196                                      CallExceptionSpec, Size, Alignment> {
197    using Base = add<Movable::trivial, Destructibility, Qual, CallExceptionSpec,
198                     Size, Alignment>;
199    explicit add(int state_init) : Base(state_init) {}
200    explicit add(std::initializer_list<int> state_init, int tail)
201        : Base(state_init, tail) {}
202    add(add&& other) noexcept : Base(other.state) {}
203    using Base::operator();
204    using Base::state;
205  };
206  Int add_function(Int&& a, int b, int c) noexcept { return a.value + b + c; }
207  Int mult_function(Int&& a, int b, int c) noexcept { return a.value * b * c; }
208  Int square_function(Int const&& a) noexcept { return a.value * a.value; }
209  template <class Sig>
210  using AnyInvocable = absl::AnyInvocable<Sig>;
211  template <Movable Movability, Destructible Destructibility, class Qual,
212            NothrowCall CallExceptionSpec, ObjSize Size, ObjAlign Alignment>
213  struct TestParams {
214    static constexpr Movable kMovability = Movability;
215    static constexpr Destructible kDestructibility = Destructibility;
216    using Qualifiers = Qual;
217    static constexpr NothrowCall kCallExceptionSpec = CallExceptionSpec;
218    static constexpr bool kIsNoexcept = kCallExceptionSpec == NothrowCall::yes;
219    static constexpr bool kIsRvalueQualified =
220        std::is_rvalue_reference<Qual>::value;
221    static constexpr ObjSize kSize = Size;
222    static constexpr ObjAlign kAlignment = Alignment;
223    using UnqualifiedUnaryFunType = int(Int const&&)
224        ABSL_INTERNAL_NOEXCEPT_SPEC(CallExceptionSpec == NothrowCall::yes);
225    using UnaryFunType = GiveQualifiersToFun<Qualifiers, UnqualifiedUnaryFunType>;
226    using MemObjPtrType = int(Int::*);
227    using UnaryAnyInvType = AnyInvocable<UnaryFunType>;
228    using UnaryThisParamType = QualifiersForThis<Qualifiers, UnaryAnyInvType>;
229    template <class T>
230    static UnaryThisParamType ToUnaryThisParam(T&& fun) {
231      return static_cast<UnaryThisParamType>(fun);
232    }
233    using ResultType = Int;
234    using AnyInvocableFunTypeNotNoexcept = Int(Int, const int&, int);
235    using UnqualifiedFunType =
236        typename std::conditional<kIsNoexcept, Int(Int, const int&, int) noexcept,
237                                  Int(Int, const int&, int)>::type;
238    using FunType = GiveQualifiersToFun<Qualifiers, UnqualifiedFunType>;
239    using MemFunPtrType =
240        typename std::conditional<kIsNoexcept,
241                                  Int (Int::*)(const int&, int) noexcept,
242                                  Int (Int::*)(const int&, int)>::type;
243    using AnyInvType = AnyInvocable<FunType>;
244    using AddType = add<kMovability, kDestructibility, Qualifiers,
245                        kCallExceptionSpec, kSize, kAlignment>;
246    using ThisParamType = QualifiersForThis<Qualifiers, AnyInvType>;
247    template <class T>
248    static ThisParamType ToThisParam(T&& fun) {
249      return static_cast<ThisParamType>(fun);
250    }
251    using UnqualifiedVoidFunType =
252        typename std::conditional<kIsNoexcept,
253                                  void(Int, const int&, int) noexcept,
254                                  void(Int, const int&, int)>::type;
255    using VoidFunType = GiveQualifiersToFun<Qualifiers, UnqualifiedVoidFunType>;
256    using VoidAnyInvType = AnyInvocable<VoidFunType>;
257    using VoidThisParamType = QualifiersForThis<Qualifiers, VoidAnyInvType>;
258    template <class T>
259    static VoidThisParamType ToVoidThisParam(T&& fun) {
260      return static_cast<VoidThisParamType>(fun);
261    }
262    using CompatibleAnyInvocableFunType =
263        absl::conditional_t<std::is_rvalue_reference<Qual>::value,
264                            GiveQualifiersToFun<const _&&, UnqualifiedFunType>,
265                            GiveQualifiersToFun<const _&, UnqualifiedFunType>>;
266    using CompatibleAnyInvType = AnyInvocable<CompatibleAnyInvocableFunType>;
267    using IncompatibleInvocable =
268        absl::conditional_t<std::is_rvalue_reference<Qual>::value,
269                            GiveQualifiersToFun<_&, UnqualifiedFunType>(_::*),
270                            GiveQualifiersToFun<_&&, UnqualifiedFunType>(_::*)>;
271  };
272  template <class MemberPtrType>
273  struct MemberTypeOfImpl;
274  template <class Class, class T>
275  struct MemberTypeOfImpl<T(Class::*)> {
276    using type = T;
277  };
278  template <class MemberPtrType>
279  using MemberTypeOf = typename MemberTypeOfImpl<MemberPtrType>::type;
280  template <class T, class = void>
281  struct IsMemberSwappableImpl : std::false_type {
282    static constexpr bool kIsNothrow = false;
283  };
284  template <class T>
285  struct IsMemberSwappableImpl<
286      T, absl::void_t<decltype(std::declval<T&>().swap(std::declval<T&>()))>>
287      : std::true_type {
288    static constexpr bool kIsNothrow =
289        noexcept(std::declval<T&>().swap(std::declval<T&>()));
290  };
291  template <class T>
292  using IsMemberSwappable = IsMemberSwappableImpl<T>;
293  template <class T>
294  using IsNothrowMemberSwappable =
295      std::integral_constant<bool, IsMemberSwappableImpl<T>::kIsNothrow>;
296  template <class T>
297  class AnyInvTestBasic : public ::testing::Test {};
298  TYPED_TEST_SUITE_P(AnyInvTestBasic);
299  TYPED_TEST_P(AnyInvTestBasic, DefaultConstruction) {
300    using AnyInvType = typename TypeParam::AnyInvType;
301    AnyInvType fun;
302    EXPECT_FALSE(static_cast<bool>(fun));
303    EXPECT_TRUE(std::is_nothrow_default_constructible<AnyInvType>::value);
304  }
305  TYPED_TEST_P(AnyInvTestBasic, ConstructionNullptr) {
306    using AnyInvType = typename TypeParam::AnyInvType;
307    AnyInvType fun = nullptr;
308    EXPECT_FALSE(static_cast<bool>(fun));
309    EXPECT_TRUE(
310        (std::is_nothrow_constructible<AnyInvType, std::nullptr_t>::value));
311  }
312  TYPED_TEST_P(AnyInvTestBasic, ConstructionNullFunctionPtr) {
313    using AnyInvType = typename TypeParam::AnyInvType;
314    using UnqualifiedFunType = typename TypeParam::UnqualifiedFunType;
315    UnqualifiedFunType* const null_fun_ptr = nullptr;
316    AnyInvType fun = null_fun_ptr;
317    EXPECT_FALSE(static_cast<bool>(fun));
318  }
319  TYPED_TEST_P(AnyInvTestBasic, ConstructionNullMemberFunctionPtr) {
320    using AnyInvType = typename TypeParam::AnyInvType;
321    using MemFunPtrType = typename TypeParam::MemFunPtrType;
322    const MemFunPtrType null_mem_fun_ptr = nullptr;
323    AnyInvType fun = null_mem_fun_ptr;
324    EXPECT_FALSE(static_cast<bool>(fun));
325  }
326  TYPED_TEST_P(AnyInvTestBasic, ConstructionNullMemberObjectPtr) {
327    using UnaryAnyInvType = typename TypeParam::UnaryAnyInvType;
328    using MemObjPtrType = typename TypeParam::MemObjPtrType;
329    const MemObjPtrType null_mem_obj_ptr = nullptr;
330    UnaryAnyInvType fun = null_mem_obj_ptr;
331    EXPECT_FALSE(static_cast<bool>(fun));
332  }
333  TYPED_TEST_P(AnyInvTestBasic, ConstructionMemberFunctionPtr) {
334    using AnyInvType = typename TypeParam::AnyInvType;
335    AnyInvType fun = &Int::MemberFunctionAdd;
336    EXPECT_TRUE(static_cast<bool>(fun));
337    EXPECT_EQ(24, TypeParam::ToThisParam(fun)(7, 8, 9).value);
338  }
339  TYPED_TEST_P(AnyInvTestBasic, ConstructionMemberObjectPtr) {
340    using UnaryAnyInvType = typename TypeParam::UnaryAnyInvType;
341    UnaryAnyInvType fun = &Int::value;
342    EXPECT_TRUE(static_cast<bool>(fun));
343    EXPECT_EQ(13, TypeParam::ToUnaryThisParam(fun)(13));
344  }
345  TYPED_TEST_P(AnyInvTestBasic, ConstructionFunctionReferenceDecay) {
346    using AnyInvType = typename TypeParam::AnyInvType;
347    AnyInvType fun = add_function;
348    EXPECT_TRUE(static_cast<bool>(fun));
349    EXPECT_EQ(24, TypeParam::ToThisParam(fun)(7, 8, 9).value);
350  }
351  TYPED_TEST_P(AnyInvTestBasic, ConstructionCompatibleAnyInvocableEmpty) {
352    using AnyInvType = typename TypeParam::AnyInvType;
353    using CompatibleAnyInvType = typename TypeParam::CompatibleAnyInvType;
354    CompatibleAnyInvType other;
355    AnyInvType fun = std::move(other);
356    EXPECT_FALSE(static_cast<bool>(other));  
357    EXPECT_EQ(other, nullptr);               
358    EXPECT_EQ(nullptr, other);               
359    EXPECT_FALSE(static_cast<bool>(fun));
360  }
361  TYPED_TEST_P(AnyInvTestBasic, ConstructionCompatibleAnyInvocableNonempty) {
362    using AnyInvType = typename TypeParam::AnyInvType;
363    using CompatibleAnyInvType = typename TypeParam::CompatibleAnyInvType;
364    CompatibleAnyInvType other = &add_function;
365    AnyInvType fun = std::move(other);
366    EXPECT_FALSE(static_cast<bool>(other));  
367    EXPECT_EQ(other, nullptr);               
368    EXPECT_EQ(nullptr, other);               
369    EXPECT_TRUE(static_cast<bool>(fun));
370    EXPECT_EQ(24, TypeParam::ToThisParam(fun)(7, 8, 9).value);
371  }
372  TYPED_TEST_P(AnyInvTestBasic, ConversionToBool) {
373    using AnyInvType = typename TypeParam::AnyInvType;
374    {
375      AnyInvType fun;
376      EXPECT_FALSE(fun ? true : false);  
377      EXPECT_TRUE(
378          (std::is_nothrow_constructible<bool, const AnyInvType&>::value));
379      EXPECT_FALSE((std::is_convertible<const AnyInvType&, bool>::value));
380    }
381    {
382      AnyInvType fun = &add_function;
383      EXPECT_TRUE(fun ? true : false);  
384    }
385  }
386  TYPED_TEST_P(AnyInvTestBasic, Invocation) {
387    using AnyInvType = typename TypeParam::AnyInvType;
388    using FunType = typename TypeParam::FunType;
389    using AnyInvCallType = MemberTypeOf<decltype(&AnyInvType::operator())>;
390    EXPECT_TRUE((std::is_same<AnyInvCallType, FunType>::value));
391    AnyInvType fun = &add_function;
392    EXPECT_EQ(24, TypeParam::ToThisParam(fun)(7, 8, 9).value);
393  }
394  TYPED_TEST_P(AnyInvTestBasic, InPlaceConstruction) {
395    using AnyInvType = typename TypeParam::AnyInvType;
396    using AddType = typename TypeParam::AddType;
397    AnyInvType fun(absl::in_place_type<AddType>, 5);
398    EXPECT_TRUE(static_cast<bool>(fun));
399    EXPECT_EQ(29, TypeParam::ToThisParam(fun)(7, 8, 9).value);
400  }
401  TYPED_TEST_P(AnyInvTestBasic, InPlaceConstructionInitializerList) {
402    using AnyInvType = typename TypeParam::AnyInvType;
403    using AddType = typename TypeParam::AddType;
404    AnyInvType fun(absl::in_place_type<AddType>, {1, 2, 3, 4}, 5);
405    EXPECT_TRUE(static_cast<bool>(fun));
406    EXPECT_EQ(39, TypeParam::ToThisParam(fun)(7, 8, 9).value);
407  }
408  TYPED_TEST_P(AnyInvTestBasic, InPlaceNullFunPtrConstruction) {
409    using AnyInvType = typename TypeParam::AnyInvType;
410    using UnqualifiedFunType = typename TypeParam::UnqualifiedFunType;
411    AnyInvType fun(absl::in_place_type<UnqualifiedFunType*>, nullptr);
412    EXPECT_TRUE(static_cast<bool>(fun));
413  }
414  TYPED_TEST_P(AnyInvTestBasic, InPlaceNullFunPtrConstructionValueInit) {
415    using AnyInvType = typename TypeParam::AnyInvType;
416    using UnqualifiedFunType = typename TypeParam::UnqualifiedFunType;
417    AnyInvType fun(absl::in_place_type<UnqualifiedFunType*>);
418    EXPECT_TRUE(static_cast<bool>(fun));
419  }
420  TYPED_TEST_P(AnyInvTestBasic, InPlaceNullMemFunPtrConstruction) {
421    using AnyInvType = typename TypeParam::AnyInvType;
422    using MemFunPtrType = typename TypeParam::MemFunPtrType;
423    AnyInvType fun(absl::in_place_type<MemFunPtrType>, nullptr);
424    EXPECT_TRUE(static_cast<bool>(fun));
425  }
426  TYPED_TEST_P(AnyInvTestBasic, InPlaceNullMemFunPtrConstructionValueInit) {
427    using AnyInvType = typename TypeParam::AnyInvType;
428    using MemFunPtrType = typename TypeParam::MemFunPtrType;
429    AnyInvType fun(absl::in_place_type<MemFunPtrType>);
430    EXPECT_TRUE(static_cast<bool>(fun));
431  }
432  TYPED_TEST_P(AnyInvTestBasic, InPlaceNullMemObjPtrConstruction) {
433    using UnaryAnyInvType = typename TypeParam::UnaryAnyInvType;
434    using MemObjPtrType = typename TypeParam::MemObjPtrType;
435    UnaryAnyInvType fun(absl::in_place_type<MemObjPtrType>, nullptr);
436    EXPECT_TRUE(static_cast<bool>(fun));
437  }
438  TYPED_TEST_P(AnyInvTestBasic, InPlaceNullMemObjPtrConstructionValueInit) {
439    using UnaryAnyInvType = typename TypeParam::UnaryAnyInvType;
440    using MemObjPtrType = typename TypeParam::MemObjPtrType;
441    UnaryAnyInvType fun(absl::in_place_type<MemObjPtrType>);
442    EXPECT_TRUE(static_cast<bool>(fun));
443  }
444  TYPED_TEST_P(AnyInvTestBasic, InPlaceVoidCovarianceConstruction) {
445    using VoidAnyInvType = typename TypeParam::VoidAnyInvType;
446    using AddType = typename TypeParam::AddType;
447    VoidAnyInvType fun(absl::in_place_type<AddType>, 5);
448    EXPECT_TRUE(static_cast<bool>(fun));
449  }
450  TYPED_TEST_P(AnyInvTestBasic, MoveConstructionFromEmpty) {
451    using AnyInvType = typename TypeParam::AnyInvType;
452    AnyInvType source_fun;
453    AnyInvType fun(std::move(source_fun));
454    EXPECT_FALSE(static_cast<bool>(fun));
455    EXPECT_TRUE(std::is_nothrow_move_constructible<AnyInvType>::value);
456  }
457  TYPED_TEST_P(AnyInvTestBasic, MoveConstructionFromNonEmpty) {
458    using AnyInvType = typename TypeParam::AnyInvType;
459    using AddType = typename TypeParam::AddType;
460    AnyInvType source_fun(absl::in_place_type<AddType>, 5);
461    AnyInvType fun(std::move(source_fun));
462    EXPECT_TRUE(static_cast<bool>(fun));
463    EXPECT_EQ(29, TypeParam::ToThisParam(fun)(7, 8, 9).value);
464    EXPECT_TRUE(std::is_nothrow_move_constructible<AnyInvType>::value);
465  }
466  TYPED_TEST_P(AnyInvTestBasic, ComparisonWithNullptrEmpty) {
467    using AnyInvType = typename TypeParam::AnyInvType;
468    AnyInvType fun;
469    EXPECT_TRUE(fun == nullptr);
470    EXPECT_TRUE(nullptr == fun);
471    EXPECT_FALSE(fun != nullptr);
472    EXPECT_FALSE(nullptr != fun);
473  }
474  TYPED_TEST_P(AnyInvTestBasic, ComparisonWithNullptrNonempty) {
475    using AnyInvType = typename TypeParam::AnyInvType;
476    using AddType = typename TypeParam::AddType;
477    AnyInvType fun(absl::in_place_type<AddType>, 5);
478    EXPECT_FALSE(fun == nullptr);
479    EXPECT_FALSE(nullptr == fun);
480    EXPECT_TRUE(fun != nullptr);
481    EXPECT_TRUE(nullptr != fun);
482  }
483  TYPED_TEST_P(AnyInvTestBasic, ResultType) {
484    using AnyInvType = typename TypeParam::AnyInvType;
485    using ExpectedResultType = typename TypeParam::ResultType;
486    EXPECT_TRUE((std::is_same<typename AnyInvType::result_type,
487                              ExpectedResultType>::value));
488  }
489  template <class T>
490  class AnyInvTestCombinatoric : public ::testing::Test {};
491  TYPED_TEST_SUITE_P(AnyInvTestCombinatoric);
492  TYPED_TEST_P(AnyInvTestCombinatoric, MoveAssignEmptyEmptyLhsRhs) {
493    using AnyInvType = typename TypeParam::AnyInvType;
494    AnyInvType source_fun;
495    AnyInvType fun;
496    fun = std::move(source_fun);
497    EXPECT_FALSE(static_cast<bool>(fun));
498  }
499  TYPED_TEST_P(AnyInvTestCombinatoric, MoveAssignEmptyLhsNonemptyRhs) {
500    using AnyInvType = typename TypeParam::AnyInvType;
501    using AddType = typename TypeParam::AddType;
502    AnyInvType source_fun(absl::in_place_type<AddType>, 5);
503    AnyInvType fun;
504    fun = std::move(source_fun);
505    EXPECT_TRUE(static_cast<bool>(fun));
506    EXPECT_EQ(29, TypeParam::ToThisParam(fun)(7, 8, 9).value);
507  }
508  TYPED_TEST_P(AnyInvTestCombinatoric, MoveAssignNonemptyEmptyLhsRhs) {
509    using AnyInvType = typename TypeParam::AnyInvType;
510    using AddType = typename TypeParam::AddType;
511    AnyInvType source_fun;
512    AnyInvType fun(absl::in_place_type<AddType>, 5);
513    fun = std::move(source_fun);
514    EXPECT_FALSE(static_cast<bool>(fun));
515  }
516  TYPED_TEST_P(AnyInvTestCombinatoric, MoveAssignNonemptyLhsNonemptyRhs) {
517    using AnyInvType = typename TypeParam::AnyInvType;
518    using AddType = typename TypeParam::AddType;
519    AnyInvType source_fun(absl::in_place_type<AddType>, 5);
520    AnyInvType fun(absl::in_place_type<AddType>, 20);
521    fun = std::move(source_fun);
522    EXPECT_TRUE(static_cast<bool>(fun));
523    EXPECT_EQ(29, TypeParam::ToThisParam(fun)(7, 8, 9).value);
524  }
525  TYPED_TEST_P(AnyInvTestCombinatoric, SelfMoveAssignEmpty) {
526    using AnyInvType = typename TypeParam::AnyInvType;
527    AnyInvType source_fun;
528    source_fun = std::move(source_fun);
529  }
530  TYPED_TEST_P(AnyInvTestCombinatoric, SelfMoveAssignNonempty) {
531    using AnyInvType = typename TypeParam::AnyInvType;
532    using AddType = typename TypeParam::AddType;
533    AnyInvType source_fun(absl::in_place_type<AddType>, 5);
534    source_fun = std::move(source_fun);
535  }
536  TYPED_TEST_P(AnyInvTestCombinatoric, AssignNullptrEmptyLhs) {
537    using AnyInvType = typename TypeParam::AnyInvType;
538    AnyInvType fun;
539    fun = nullptr;
540    EXPECT_FALSE(static_cast<bool>(fun));
541  }
542  TYPED_TEST_P(AnyInvTestCombinatoric, AssignNullFunctionPtrEmptyLhs) {
543    using AnyInvType = typename TypeParam::AnyInvType;
544    using UnqualifiedFunType = typename TypeParam::UnqualifiedFunType;
545    UnqualifiedFunType* const null_fun_ptr = nullptr;
546    AnyInvType fun;
547    fun = null_fun_ptr;
548    EXPECT_FALSE(static_cast<bool>(fun));
549  }
550  TYPED_TEST_P(AnyInvTestCombinatoric, AssignNullMemberFunctionPtrEmptyLhs) {
551    using AnyInvType = typename TypeParam::AnyInvType;
552    using MemFunPtrType = typename TypeParam::MemFunPtrType;
553    const MemFunPtrType null_mem_fun_ptr = nullptr;
554    AnyInvType fun;
555    fun = null_mem_fun_ptr;
556    EXPECT_FALSE(static_cast<bool>(fun));
557  }
558  TYPED_TEST_P(AnyInvTestCombinatoric, AssignNullMemberObjectPtrEmptyLhs) {
559    using UnaryAnyInvType = typename TypeParam::UnaryAnyInvType;
560    using MemObjPtrType = typename TypeParam::MemObjPtrType;
561    const MemObjPtrType null_mem_obj_ptr = nullptr;
562    UnaryAnyInvType fun;
563    fun = null_mem_obj_ptr;
564    EXPECT_FALSE(static_cast<bool>(fun));
565  }
566  TYPED_TEST_P(AnyInvTestCombinatoric, AssignMemberFunctionPtrEmptyLhs) {
567    using AnyInvType = typename TypeParam::AnyInvType;
568    AnyInvType fun;
569    fun = &Int::MemberFunctionAdd;
570    EXPECT_TRUE(static_cast<bool>(fun));
571    EXPECT_EQ(24, TypeParam::ToThisParam(fun)(7, 8, 9).value);
572  }
573  TYPED_TEST_P(AnyInvTestCombinatoric, AssignMemberObjectPtrEmptyLhs) {
574    using UnaryAnyInvType = typename TypeParam::UnaryAnyInvType;
575    UnaryAnyInvType fun;
576    fun = &Int::value;
577    EXPECT_TRUE(static_cast<bool>(fun));
578    EXPECT_EQ(13, TypeParam::ToUnaryThisParam(fun)(13));
579  }
580  TYPED_TEST_P(AnyInvTestCombinatoric, AssignFunctionReferenceDecayEmptyLhs) {
581    using AnyInvType = typename TypeParam::AnyInvType;
582    AnyInvType fun;
583    fun = add_function;
584    EXPECT_TRUE(static_cast<bool>(fun));
585    EXPECT_EQ(24, TypeParam::ToThisParam(fun)(7, 8, 9).value);
586  }
587  TYPED_TEST_P(AnyInvTestCombinatoric,
588               AssignCompatibleAnyInvocableEmptyLhsEmptyRhs) {
589    using AnyInvType = typename TypeParam::AnyInvType;
590    using CompatibleAnyInvType = typename TypeParam::CompatibleAnyInvType;
591    CompatibleAnyInvType other;
592    AnyInvType fun;
593    fun = std::move(other);
594    EXPECT_FALSE(static_cast<bool>(other));  
595    EXPECT_EQ(other, nullptr);               
596    EXPECT_EQ(nullptr, other);               
597    EXPECT_FALSE(static_cast<bool>(fun));
598  }
599  TYPED_TEST_P(AnyInvTestCombinatoric,
600               AssignCompatibleAnyInvocableEmptyLhsNonemptyRhs) {
601    using AnyInvType = typename TypeParam::AnyInvType;
602    using CompatibleAnyInvType = typename TypeParam::CompatibleAnyInvType;
603    CompatibleAnyInvType other = &add_function;
604    AnyInvType fun;
605    fun = std::move(other);
606    EXPECT_FALSE(static_cast<bool>(other));  
607    EXPECT_TRUE(static_cast<bool>(fun));
608    EXPECT_EQ(24, TypeParam::ToThisParam(fun)(7, 8, 9).value);
609  }
610  TYPED_TEST_P(AnyInvTestCombinatoric, AssignNullptrNonemptyLhs) {
611    using AnyInvType = typename TypeParam::AnyInvType;
612    AnyInvType fun = &mult_function;
613    fun = nullptr;
614    EXPECT_FALSE(static_cast<bool>(fun));
615  }
616  TYPED_TEST_P(AnyInvTestCombinatoric, AssignNullFunctionPtrNonemptyLhs) {
617    using AnyInvType = typename TypeParam::AnyInvType;
618    using UnqualifiedFunType = typename TypeParam::UnqualifiedFunType;
619    UnqualifiedFunType* const null_fun_ptr = nullptr;
620    AnyInvType fun = &mult_function;
621    fun = null_fun_ptr;
622    EXPECT_FALSE(static_cast<bool>(fun));
623  }
624  TYPED_TEST_P(AnyInvTestCombinatoric, AssignNullMemberFunctionPtrNonemptyLhs) {
625    using AnyInvType = typename TypeParam::AnyInvType;
626    using MemFunPtrType = typename TypeParam::MemFunPtrType;
627    const MemFunPtrType null_mem_fun_ptr = nullptr;
628    AnyInvType fun = &mult_function;
629    fun = null_mem_fun_ptr;
630    EXPECT_FALSE(static_cast<bool>(fun));
631  }
632  TYPED_TEST_P(AnyInvTestCombinatoric, AssignNullMemberObjectPtrNonemptyLhs) {
633    using UnaryAnyInvType = typename TypeParam::UnaryAnyInvType;
634    using MemObjPtrType = typename TypeParam::MemObjPtrType;
635    const MemObjPtrType null_mem_obj_ptr = nullptr;
636    UnaryAnyInvType fun = &square_function;
637    fun = null_mem_obj_ptr;
638    EXPECT_FALSE(static_cast<bool>(fun));
639  }
640  TYPED_TEST_P(AnyInvTestCombinatoric, AssignMemberFunctionPtrNonemptyLhs) {
641    using AnyInvType = typename TypeParam::AnyInvType;
642    AnyInvType fun = &mult_function;
643    fun = &Int::MemberFunctionAdd;
644    EXPECT_TRUE(static_cast<bool>(fun));
645    EXPECT_EQ(24, TypeParam::ToThisParam(fun)(7, 8, 9).value);
646  }
647  TYPED_TEST_P(AnyInvTestCombinatoric, AssignMemberObjectPtrNonemptyLhs) {
648    using UnaryAnyInvType = typename TypeParam::UnaryAnyInvType;
649    UnaryAnyInvType fun = &square_function;
650    fun = &Int::value;
651    EXPECT_TRUE(static_cast<bool>(fun));
652    EXPECT_EQ(13, TypeParam::ToUnaryThisParam(fun)(13));
653  }
654  TYPED_TEST_P(AnyInvTestCombinatoric, AssignFunctionReferenceDecayNonemptyLhs) {
655    using AnyInvType = typename TypeParam::AnyInvType;
656    AnyInvType fun = &mult_function;
657    fun = add_function;
658    EXPECT_TRUE(static_cast<bool>(fun));
659    EXPECT_EQ(24, TypeParam::ToThisParam(fun)(7, 8, 9).value);
660  }
661  TYPED_TEST_P(AnyInvTestCombinatoric,
662               AssignCompatibleAnyInvocableNonemptyLhsEmptyRhs) {
663    using AnyInvType = typename TypeParam::AnyInvType;
664    using CompatibleAnyInvType = typename TypeParam::CompatibleAnyInvType;
665    CompatibleAnyInvType other;
666    AnyInvType fun = &mult_function;
667    fun = std::move(other);
668    EXPECT_FALSE(static_cast<bool>(other));  
669    EXPECT_EQ(other, nullptr);               
670    EXPECT_EQ(nullptr, other);               
671    EXPECT_FALSE(static_cast<bool>(fun));
672  }
673  TYPED_TEST_P(AnyInvTestCombinatoric,
674               AssignCompatibleAnyInvocableNonemptyLhsNonemptyRhs) {
675    using AnyInvType = typename TypeParam::AnyInvType;
676    using CompatibleAnyInvType = typename TypeParam::CompatibleAnyInvType;
677    CompatibleAnyInvType other = &add_function;
678    AnyInvType fun = &mult_function;
679    fun = std::move(other);
680    EXPECT_FALSE(static_cast<bool>(other));  
681    EXPECT_TRUE(static_cast<bool>(fun));
682    EXPECT_EQ(24, TypeParam::ToThisParam(fun)(7, 8, 9).value);
683  }
684  TYPED_TEST_P(AnyInvTestCombinatoric, SwapEmptyLhsEmptyRhs) {
685    using AnyInvType = typename TypeParam::AnyInvType;
686    {
687      AnyInvType fun;
688      AnyInvType other;
689      using std::swap;
690      swap(fun, other);
691      EXPECT_FALSE(static_cast<bool>(fun));
692      EXPECT_FALSE(static_cast<bool>(other));
693      EXPECT_TRUE(
694          absl::type_traits_internal::IsNothrowSwappable<AnyInvType>::value);
695    }
696    {
697      AnyInvType fun;
698      AnyInvType other;
699      fun.swap(other);
700      EXPECT_FALSE(static_cast<bool>(fun));
701      EXPECT_FALSE(static_cast<bool>(other));
702      EXPECT_TRUE(IsNothrowMemberSwappable<AnyInvType>::value);
703    }
704  }
705  TYPED_TEST_P(AnyInvTestCombinatoric, SwapEmptyLhsNonemptyRhs) {
706    using AnyInvType = typename TypeParam::AnyInvType;
707    using AddType = typename TypeParam::AddType;
708    {
709      AnyInvType fun;
710      AnyInvType other(absl::in_place_type<AddType>, 5);
711      using std::swap;
712      swap(fun, other);
713      EXPECT_TRUE(static_cast<bool>(fun));
714      EXPECT_FALSE(static_cast<bool>(other));
715      EXPECT_EQ(29, TypeParam::ToThisParam(fun)(7, 8, 9).value);
716      EXPECT_TRUE(
717          absl::type_traits_internal::IsNothrowSwappable<AnyInvType>::value);
718    }
719    {
720      AnyInvType fun;
721      AnyInvType other(absl::in_place_type<AddType>, 5);
722      fun.swap(other);
723      EXPECT_TRUE(static_cast<bool>(fun));
724      EXPECT_FALSE(static_cast<bool>(other));
725      EXPECT_EQ(29, TypeParam::ToThisParam(fun)(7, 8, 9).value);
726      EXPECT_TRUE(IsNothrowMemberSwappable<AnyInvType>::value);
727    }
728  }
729  TYPED_TEST_P(AnyInvTestCombinatoric, SwapNonemptyLhsEmptyRhs) {
730    using AnyInvType = typename TypeParam::AnyInvType;
731    using AddType = typename TypeParam::AddType;
732    {
733      AnyInvType fun(absl::in_place_type<AddType>, 5);
734      AnyInvType other;
735      using std::swap;
736      swap(fun, other);
737      EXPECT_FALSE(static_cast<bool>(fun));
738      EXPECT_TRUE(static_cast<bool>(other));
739      EXPECT_EQ(29, TypeParam::ToThisParam(other)(7, 8, 9).value);
740      EXPECT_TRUE(
741          absl::type_traits_internal::IsNothrowSwappable<AnyInvType>::value);
742    }
743    {
744      AnyInvType fun(absl::in_place_type<AddType>, 5);
745      AnyInvType other;
746      fun.swap(other);
747      EXPECT_FALSE(static_cast<bool>(fun));
748      EXPECT_TRUE(static_cast<bool>(other));
749      EXPECT_EQ(29, TypeParam::ToThisParam(other)(7, 8, 9).value);
750      EXPECT_TRUE(IsNothrowMemberSwappable<AnyInvType>::value);
751    }
752  }
753  TYPED_TEST_P(AnyInvTestCombinatoric, SwapNonemptyLhsNonemptyRhs) {
754    using AnyInvType = typename TypeParam::AnyInvType;
755    using AddType = typename TypeParam::AddType;
756    {
757      AnyInvType fun(absl::in_place_type<AddType>, 5);
758      AnyInvType other(absl::in_place_type<AddType>, 6);
759      using std::swap;
760      swap(fun, other);
761      EXPECT_TRUE(static_cast<bool>(fun));
762      EXPECT_TRUE(static_cast<bool>(other));
763      EXPECT_EQ(30, TypeParam::ToThisParam(fun)(7, 8, 9).value);
764      EXPECT_EQ(29, TypeParam::ToThisParam(other)(7, 8, 9).value);
765      EXPECT_TRUE(
766          absl::type_traits_internal::IsNothrowSwappable<AnyInvType>::value);
767    }
768    {
769      AnyInvType fun(absl::in_place_type<AddType>, 5);
770      AnyInvType other(absl::in_place_type<AddType>, 6);
771      fun.swap(other);
772      EXPECT_TRUE(static_cast<bool>(fun));
773      EXPECT_TRUE(static_cast<bool>(other));
774      EXPECT_EQ(30, TypeParam::ToThisParam(fun)(7, 8, 9).value);
775      EXPECT_EQ(29, TypeParam::ToThisParam(other)(7, 8, 9).value);
776      EXPECT_TRUE(IsNothrowMemberSwappable<AnyInvType>::value);
777    }
778  }
779  template <class T>
780  class AnyInvTestMovable : public ::testing::Test {};
781  TYPED_TEST_SUITE_P(AnyInvTestMovable);
782  TYPED_TEST_P(AnyInvTestMovable, ConversionConstructionUserDefinedType) {
783    using AnyInvType = typename TypeParam::AnyInvType;
784    using AddType = typename TypeParam::AddType;
785    AnyInvType fun(AddType(5));
786    EXPECT_TRUE(static_cast<bool>(fun));
787    EXPECT_EQ(29, TypeParam::ToThisParam(fun)(7, 8, 9).value);
788  }
789  TYPED_TEST_P(AnyInvTestMovable, ConversionConstructionVoidCovariance) {
790    using VoidAnyInvType = typename TypeParam::VoidAnyInvType;
791    using AddType = typename TypeParam::AddType;
792    VoidAnyInvType fun(AddType(5));
793    EXPECT_TRUE(static_cast<bool>(fun));
794  }
795  TYPED_TEST_P(AnyInvTestMovable, ConversionAssignUserDefinedTypeEmptyLhs) {
796    using AnyInvType = typename TypeParam::AnyInvType;
797    using AddType = typename TypeParam::AddType;
798    AnyInvType fun;
799    fun = AddType(5);
800    EXPECT_TRUE(static_cast<bool>(fun));
801    EXPECT_EQ(29, TypeParam::ToThisParam(fun)(7, 8, 9).value);
802  }
803  TYPED_TEST_P(AnyInvTestMovable, ConversionAssignUserDefinedTypeNonemptyLhs) {
804    using AnyInvType = typename TypeParam::AnyInvType;
805    using AddType = typename TypeParam::AddType;
806    AnyInvType fun = &add_function;
807    fun = AddType(5);
808    EXPECT_TRUE(static_cast<bool>(fun));
809    EXPECT_EQ(29, TypeParam::ToThisParam(fun)(7, 8, 9).value);
810  }
811  TYPED_TEST_P(AnyInvTestMovable, ConversionAssignVoidCovariance) {
812    using VoidAnyInvType = typename TypeParam::VoidAnyInvType;
813    using AddType = typename TypeParam::AddType;
814    VoidAnyInvType fun;
815    fun = AddType(5);
816    EXPECT_TRUE(static_cast<bool>(fun));
817  }
818  template <class T>
819  class AnyInvTestNoexceptFalse : public ::testing::Test {};
820  TYPED_TEST_SUITE_P(AnyInvTestNoexceptFalse);
821  TYPED_TEST_P(AnyInvTestNoexceptFalse, ConversionConstructionConstraints) {
822    using AnyInvType = typename TypeParam::AnyInvType;
823    EXPECT_TRUE((std::is_constructible<
824                 AnyInvType,
825                 typename TypeParam::AnyInvocableFunTypeNotNoexcept*>::value));
826    EXPECT_FALSE((
827        std::is_constructible<AnyInvType,
828                              typename TypeParam::IncompatibleInvocable>::value));
829  }
830  TYPED_TEST_P(AnyInvTestNoexceptFalse, ConversionAssignConstraints) {
831    using AnyInvType = typename TypeParam::AnyInvType;
832    EXPECT_TRUE((std::is_assignable<
833                 AnyInvType&,
834                 typename TypeParam::AnyInvocableFunTypeNotNoexcept*>::value));
835    EXPECT_FALSE(
836        (std::is_assignable<AnyInvType&,
837                            typename TypeParam::IncompatibleInvocable>::value));
838  }
839  template <class T>
840  class AnyInvTestNoexceptTrue : public ::testing::Test {};
841  TYPED_TEST_SUITE_P(AnyInvTestNoexceptTrue);
842  TYPED_TEST_P(AnyInvTestNoexceptTrue, ConversionConstructionConstraints) {
843  #if ABSL_INTERNAL_CPLUSPLUS_LANG < 201703L
844    GTEST_SKIP() << "Noexcept was not part of the type system before C++17.";
845  #else
846    using AnyInvType = typename TypeParam::AnyInvType;
847    EXPECT_FALSE((std::is_constructible<
848                  AnyInvType,
849                  typename TypeParam::AnyInvocableFunTypeNotNoexcept*>::value));
850    EXPECT_FALSE((
851        std::is_constructible<AnyInvType,
852                              typename TypeParam::IncompatibleInvocable>::value));
853  #endif
854  }
855  TYPED_TEST_P(AnyInvTestNoexceptTrue, ConversionAssignConstraints) {
856  #if ABSL_INTERNAL_CPLUSPLUS_LANG < 201703L
857    GTEST_SKIP() << "Noexcept was not part of the type system before C++17.";
858  #else
859    using AnyInvType = typename TypeParam::AnyInvType;
860    EXPECT_FALSE((std::is_assignable<
861                  AnyInvType&,
862                  typename TypeParam::AnyInvocableFunTypeNotNoexcept*>::value));
863    EXPECT_FALSE(
864        (std::is_assignable<AnyInvType&,
865                            typename TypeParam::IncompatibleInvocable>::value));
866  #endif
867  }
868  template <class T>
869  class AnyInvTestNonRvalue : public ::testing::Test {};
870  TYPED_TEST_SUITE_P(AnyInvTestNonRvalue);
871  TYPED_TEST_P(AnyInvTestNonRvalue, ConversionConstructionReferenceWrapper) {
872    using AnyInvType = typename TypeParam::AnyInvType;
873    using AddType = typename TypeParam::AddType;
874    AddType add(4);
875    AnyInvType fun = std::ref(add);
876    add.state = 5;
877    EXPECT_TRUE(static_cast<bool>(fun));
878    EXPECT_EQ(29, TypeParam::ToThisParam(fun)(7, 8, 9).value);
879    EXPECT_TRUE(static_cast<bool>(fun));
880    EXPECT_EQ(38, TypeParam::ToThisParam(fun)(10, 11, 12).value);
881  }
882  TYPED_TEST_P(AnyInvTestNonRvalue, NonMoveableResultType) {
883  #if ABSL_INTERNAL_CPLUSPLUS_LANG < 201703L
884    GTEST_SKIP() << "Copy/move elision was not standard before C++17";
885  #else
886    struct Result {
887      int x;
888      explicit Result(const int x_in) : x(x_in) {}
889      Result(Result&&) = delete;
890    };
891    static_assert(!std::is_move_constructible<Result>::value, "");
892    static_assert(!std::is_copy_constructible<Result>::value, "");
893    const auto return_17 = []() noexcept { return Result(17); };
894    EXPECT_EQ(17, return_17().x);
895    using UnqualifiedFun =
<span onclick='openModal()' class='match'>896        absl::conditional_t<TypeParam::kIsNoexcept, Result() noexcept, Result()>;
897    using Fun =
898        GiveQualifiersToFun<typename TypeParam::Qualifiers, UnqualifiedFun>;
899    AnyInvocable<Fun> any_inv(return_17);
</span>900    EXPECT_EQ(17, any_inv().x);
901  #endif
902  }
903  TYPED_TEST_P(AnyInvTestNonRvalue, ConversionAssignReferenceWrapperEmptyLhs) {
904    using AnyInvType = typename TypeParam::AnyInvType;
905    using AddType = typename TypeParam::AddType;
906    AddType add(4);
907    AnyInvType fun;
908    fun = std::ref(add);
909    add.state = 5;
910    EXPECT_TRUE(
911        (std::is_nothrow_assignable<AnyInvType&,
912                                    std::reference_wrapper<AddType>>::value));
913    EXPECT_TRUE(static_cast<bool>(fun));
914    EXPECT_EQ(29, TypeParam::ToThisParam(fun)(7, 8, 9).value);
915    EXPECT_TRUE(static_cast<bool>(fun));
916    EXPECT_EQ(38, TypeParam::ToThisParam(fun)(10, 11, 12).value);
917  }
918  TYPED_TEST_P(AnyInvTestNonRvalue, ConversionAssignReferenceWrapperNonemptyLhs) {
919    using AnyInvType = typename TypeParam::AnyInvType;
920    using AddType = typename TypeParam::AddType;
921    AddType add(4);
922    AnyInvType fun = &mult_function;
923    fun = std::ref(add);
924    add.state = 5;
925    EXPECT_TRUE(
926        (std::is_nothrow_assignable<AnyInvType&,
927                                    std::reference_wrapper<AddType>>::value));
928    EXPECT_TRUE(static_cast<bool>(fun));
929    EXPECT_EQ(29, TypeParam::ToThisParam(fun)(7, 8, 9).value);
930    EXPECT_TRUE(static_cast<bool>(fun));
931    EXPECT_EQ(38, TypeParam::ToThisParam(fun)(10, 11, 12).value);
932  }
933  template <class T>
934  class AnyInvTestRvalue : public ::testing::Test {};
935  TYPED_TEST_SUITE_P(AnyInvTestRvalue);
936  TYPED_TEST_P(AnyInvTestRvalue, ConversionConstructionReferenceWrapper) {
937    using AnyInvType = typename TypeParam::AnyInvType;
938    using AddType = typename TypeParam::AddType;
939    EXPECT_FALSE((
940        std::is_convertible<std::reference_wrapper<AddType>, AnyInvType>::value));
941  }
942  TYPED_TEST_P(AnyInvTestRvalue, NonMoveableResultType) {
943  #if ABSL_INTERNAL_CPLUSPLUS_LANG < 201703L
944    GTEST_SKIP() << "Copy/move elision was not standard before C++17";
945  #else
946    struct Result {
947      int x;
948      explicit Result(const int x_in) : x(x_in) {}
949      Result(Result&&) = delete;
950    };
951    static_assert(!std::is_move_constructible<Result>::value, "");
952    static_assert(!std::is_copy_constructible<Result>::value, "");
953    const auto return_17 = []() noexcept { return Result(17); };
954    EXPECT_EQ(17, return_17().x);
955    using UnqualifiedFun =
956        absl::conditional_t<TypeParam::kIsNoexcept, Result() noexcept, Result()>;
957    using Fun =
958        GiveQualifiersToFun<typename TypeParam::Qualifiers, UnqualifiedFun>;
959    EXPECT_EQ(17, AnyInvocable<Fun>(return_17)().x);
960  #endif
961  }
962  TYPED_TEST_P(AnyInvTestRvalue, ConversionAssignReferenceWrapper) {
963    using AnyInvType = typename TypeParam::AnyInvType;
964    using AddType = typename TypeParam::AddType;
965    EXPECT_FALSE((
966        std::is_assignable<AnyInvType&, std::reference_wrapper<AddType>>::value));
967  }
968  TYPED_TEST_P(AnyInvTestRvalue, NonConstCrashesOnSecondCall) {
969    using AnyInvType = typename TypeParam::AnyInvType;
970    using AddType = typename TypeParam::AddType;
971    AnyInvType fun(absl::in_place_type<AddType>, 5);
972    EXPECT_TRUE(static_cast<bool>(fun));
973    std::move(fun)(7, 8, 9);
974    EXPECT_TRUE(static_cast<bool>(fun));  
975  #if !defined(NDEBUG)
976    EXPECT_DEATH_IF_SUPPORTED(std::move(fun)(7, 8, 9), "");
977  #endif
978  }
979  TYPED_TEST_P(AnyInvTestRvalue, QualifierIndependentObjectLifetime) {
980    using AnyInvType = typename TypeParam::AnyInvType;
981    auto refs = std::make_shared<std::nullptr_t>();
982    {
983      AnyInvType fun([refs](auto&&...) noexcept { return 0; });
984      EXPECT_GT(refs.use_count(), 1);
985      std::move(fun)(7, 8, 9);
986      EXPECT_GT(refs.use_count(), 1);
987    }
988    EXPECT_EQ(refs.use_count(), 1);
989  }
990  template <Movable Mov, Destructible Dest, NothrowCall CallExceptionSpec,
991            ObjSize Size, ObjAlign Align>
992  using NonRvalueQualifiedTestParams = ::testing::Types<               
993      TestParams<Mov, Dest, _, CallExceptionSpec, Size, Align>,        
994      TestParams<Mov, Dest, const _, CallExceptionSpec, Size, Align>,  
995      TestParams<Mov, Dest, _&, CallExceptionSpec, Size, Align>,       
996      TestParams<Mov, Dest, const _&, CallExceptionSpec, Size, Align>>;
997  template <Movable Mov, Destructible Dest, NothrowCall CallExceptionSpec,
998            ObjSize Size, ObjAlign Align>
999  using RvalueQualifiedTestParams = ::testing::Types<
1000      TestParams<Mov, Dest, _&&, CallExceptionSpec, Size, Align>,       
1001      TestParams<Mov, Dest, const _&&, CallExceptionSpec, Size, Align>  
1002      >;
1003  using TestParameterListNonRvalueQualifiersNothrowCall =
1004      NonRvalueQualifiedTestParams<Movable::trivial, Destructible::trivial,
1005                                   NothrowCall::yes, ObjSize::small,
1006                                   ObjAlign::normal>;
1007  using TestParameterListRvalueQualifiersNothrowCall =
1008      RvalueQualifiedTestParams<Movable::trivial, Destructible::trivial,
1009                                NothrowCall::yes, ObjSize::small,
1010                                ObjAlign::normal>;
1011  using TestParameterListNonRvalueQualifiersCallMayThrow =
1012      NonRvalueQualifiedTestParams<Movable::trivial, Destructible::trivial,
1013                                   NothrowCall::no, ObjSize::small,
1014                                   ObjAlign::normal>;
1015  using TestParameterListRvalueQualifiersCallMayThrow =
1016      RvalueQualifiedTestParams<Movable::trivial, Destructible::trivial,
1017                                NothrowCall::no, ObjSize::small,
1018                                ObjAlign::normal>;
1019  using TestParameterListRemoteMovable = ::testing::Types<
1020      TestParams<Movable::trivial, Destructible::trivial, _, NothrowCall::no,
1021                 ObjSize::large, ObjAlign::normal>,  
1022      TestParams<Movable::nothrow, Destructible::trivial, _, NothrowCall::no,
1023                 ObjSize::large, ObjAlign::normal>,  
1024      TestParams<Movable::yes, Destructible::trivial, _, NothrowCall::no,
1025                 ObjSize::small, ObjAlign::normal>,  
1026      TestParams<Movable::yes, Destructible::trivial, _, NothrowCall::no,
1027                 ObjSize::large, ObjAlign::normal>,  
1028      TestParams<Movable::trivial, Destructible::nothrow, _, NothrowCall::no,
1029                 ObjSize::large, ObjAlign::normal>,  
1030      TestParams<Movable::nothrow, Destructible::nothrow, _, NothrowCall::no,
1031                 ObjSize::large, ObjAlign::normal>,  
1032      TestParams<Movable::yes, Destructible::nothrow, _, NothrowCall::no,
1033                 ObjSize::small, ObjAlign::normal>,  
1034      TestParams<Movable::yes, Destructible::nothrow, _, NothrowCall::no,
1035                 ObjSize::large, ObjAlign::normal>  
1036  #if ABSL_INTERNAL_CPLUSPLUS_LANG >= 201703L
1037      ,
1038      TestParams<Movable::trivial, Destructible::trivial, _, NothrowCall::no,
1039                 ObjSize::small, ObjAlign::large>,  
1040      TestParams<Movable::nothrow, Destructible::trivial, _, NothrowCall::no,
1041                 ObjSize::small, ObjAlign::large>,  
1042      TestParams<Movable::trivial, Destructible::nothrow, _, NothrowCall::no,
1043                 ObjSize::small, ObjAlign::large>,  
1044      TestParams<Movable::nothrow, Destructible::nothrow, _, NothrowCall::no,
1045                 ObjSize::small, ObjAlign::large>  
1046  #endif
1047      >;
1048  using TestParameterListRemoteNonMovable = ::testing::Types<
1049      TestParams<Movable::no, Destructible::trivial, _, NothrowCall::no,
1050                 ObjSize::small, ObjAlign::normal>,  
1051      TestParams<Movable::no, Destructible::trivial, _, NothrowCall::no,
1052                 ObjSize::large, ObjAlign::normal>,  
1053      TestParams<Movable::no, Destructible::nothrow, _, NothrowCall::no,
1054                 ObjSize::small, ObjAlign::normal>,  
1055      TestParams<Movable::no, Destructible::nothrow, _, NothrowCall::no,
1056                 ObjSize::large, ObjAlign::normal>  
1057      >;
1058  using TestParameterListLocal = ::testing::Types<
1059      TestParams<Movable::trivial, Destructible::trivial, _, NothrowCall::no,
1060                 ObjSize::small, ObjAlign::normal>,  
1061      TestParams<Movable::nothrow, Destructible::trivial, _, NothrowCall::no,
1062                 ObjSize::small, ObjAlign::normal>,  
1063      TestParams<Movable::trivial, Destructible::trivial, _, NothrowCall::no,
1064                 ObjSize::small, ObjAlign::normal>,  
1065      TestParams<Movable::nothrow, Destructible::trivial, _, NothrowCall::no,
1066                 ObjSize::small, ObjAlign::normal>  
1067      >;
1068  REGISTER_TYPED_TEST_SUITE_P(
1069      AnyInvTestBasic, DefaultConstruction, ConstructionNullptr,
1070      ConstructionNullFunctionPtr, ConstructionNullMemberFunctionPtr,
1071      ConstructionNullMemberObjectPtr, ConstructionMemberFunctionPtr,
1072      ConstructionMemberObjectPtr, ConstructionFunctionReferenceDecay,
1073      ConstructionCompatibleAnyInvocableEmpty,
1074      ConstructionCompatibleAnyInvocableNonempty, InPlaceConstruction,
1075      ConversionToBool, Invocation, InPlaceConstructionInitializerList,
1076      InPlaceNullFunPtrConstruction, InPlaceNullFunPtrConstructionValueInit,
1077      InPlaceNullMemFunPtrConstruction, InPlaceNullMemFunPtrConstructionValueInit,
1078      InPlaceNullMemObjPtrConstruction, InPlaceNullMemObjPtrConstructionValueInit,
1079      InPlaceVoidCovarianceConstruction, MoveConstructionFromEmpty,
1080      MoveConstructionFromNonEmpty, ComparisonWithNullptrEmpty,
1081      ComparisonWithNullptrNonempty, ResultType);
1082  INSTANTIATE_TYPED_TEST_SUITE_P(
1083      NonRvalueCallMayThrow, AnyInvTestBasic,
1084      TestParameterListNonRvalueQualifiersCallMayThrow);
1085  INSTANTIATE_TYPED_TEST_SUITE_P(RvalueCallMayThrow, AnyInvTestBasic,
1086                                 TestParameterListRvalueQualifiersCallMayThrow);
1087  INSTANTIATE_TYPED_TEST_SUITE_P(RemoteMovable, AnyInvTestBasic,
1088                                 TestParameterListRemoteMovable);
1089  INSTANTIATE_TYPED_TEST_SUITE_P(RemoteNonMovable, AnyInvTestBasic,
1090                                 TestParameterListRemoteNonMovable);
1091  INSTANTIATE_TYPED_TEST_SUITE_P(Local, AnyInvTestBasic, TestParameterListLocal);
1092  INSTANTIATE_TYPED_TEST_SUITE_P(NonRvalueCallNothrow, AnyInvTestBasic,
1093                                 TestParameterListNonRvalueQualifiersNothrowCall);
1094  INSTANTIATE_TYPED_TEST_SUITE_P(CallNothrowRvalue, AnyInvTestBasic,
1095                                 TestParameterListRvalueQualifiersNothrowCall);
1096  REGISTER_TYPED_TEST_SUITE_P(
1097      AnyInvTestCombinatoric, MoveAssignEmptyEmptyLhsRhs,
1098      MoveAssignEmptyLhsNonemptyRhs, MoveAssignNonemptyEmptyLhsRhs,
1099      MoveAssignNonemptyLhsNonemptyRhs, SelfMoveAssignEmpty,
1100      SelfMoveAssignNonempty, AssignNullptrEmptyLhs,
1101      AssignNullFunctionPtrEmptyLhs, AssignNullMemberFunctionPtrEmptyLhs,
1102      AssignNullMemberObjectPtrEmptyLhs, AssignMemberFunctionPtrEmptyLhs,
1103      AssignMemberObjectPtrEmptyLhs, AssignFunctionReferenceDecayEmptyLhs,
1104      AssignCompatibleAnyInvocableEmptyLhsEmptyRhs,
1105      AssignCompatibleAnyInvocableEmptyLhsNonemptyRhs, AssignNullptrNonemptyLhs,
1106      AssignNullFunctionPtrNonemptyLhs, AssignNullMemberFunctionPtrNonemptyLhs,
1107      AssignNullMemberObjectPtrNonemptyLhs, AssignMemberFunctionPtrNonemptyLhs,
1108      AssignMemberObjectPtrNonemptyLhs, AssignFunctionReferenceDecayNonemptyLhs,
1109      AssignCompatibleAnyInvocableNonemptyLhsEmptyRhs,
1110      AssignCompatibleAnyInvocableNonemptyLhsNonemptyRhs, SwapEmptyLhsEmptyRhs,
1111      SwapEmptyLhsNonemptyRhs, SwapNonemptyLhsEmptyRhs,
1112      SwapNonemptyLhsNonemptyRhs);
1113  INSTANTIATE_TYPED_TEST_SUITE_P(
1114      NonRvalueCallMayThrow, AnyInvTestCombinatoric,
1115      TestParameterListNonRvalueQualifiersCallMayThrow);
1116  INSTANTIATE_TYPED_TEST_SUITE_P(RvalueCallMayThrow, AnyInvTestCombinatoric,
1117                                 TestParameterListRvalueQualifiersCallMayThrow);
1118  INSTANTIATE_TYPED_TEST_SUITE_P(RemoteMovable, AnyInvTestCombinatoric,
1119                                 TestParameterListRemoteMovable);
1120  INSTANTIATE_TYPED_TEST_SUITE_P(RemoteNonMovable, AnyInvTestCombinatoric,
1121                                 TestParameterListRemoteNonMovable);
1122  INSTANTIATE_TYPED_TEST_SUITE_P(Local, AnyInvTestCombinatoric,
1123                                 TestParameterListLocal);
1124  INSTANTIATE_TYPED_TEST_SUITE_P(NonRvalueCallNothrow, AnyInvTestCombinatoric,
1125                                 TestParameterListNonRvalueQualifiersNothrowCall);
1126  INSTANTIATE_TYPED_TEST_SUITE_P(RvalueCallNothrow, AnyInvTestCombinatoric,
1127                                 TestParameterListRvalueQualifiersNothrowCall);
1128  REGISTER_TYPED_TEST_SUITE_P(AnyInvTestMovable,
1129                              ConversionConstructionUserDefinedType,
1130                              ConversionConstructionVoidCovariance,
1131                              ConversionAssignUserDefinedTypeEmptyLhs,
1132                              ConversionAssignUserDefinedTypeNonemptyLhs,
1133                              ConversionAssignVoidCovariance);
1134  INSTANTIATE_TYPED_TEST_SUITE_P(
1135      NonRvalueCallMayThrow, AnyInvTestMovable,
1136      TestParameterListNonRvalueQualifiersCallMayThrow);
1137  INSTANTIATE_TYPED_TEST_SUITE_P(RvalueCallMayThrow, AnyInvTestMovable,
1138                                 TestParameterListRvalueQualifiersCallMayThrow);
1139  INSTANTIATE_TYPED_TEST_SUITE_P(RemoteMovable, AnyInvTestMovable,
1140                                 TestParameterListRemoteMovable);
1141  INSTANTIATE_TYPED_TEST_SUITE_P(Local, AnyInvTestMovable,
1142                                 TestParameterListLocal);
1143  INSTANTIATE_TYPED_TEST_SUITE_P(NonRvalueCallNothrow, AnyInvTestMovable,
1144                                 TestParameterListNonRvalueQualifiersNothrowCall);
1145  INSTANTIATE_TYPED_TEST_SUITE_P(RvalueCallNothrow, AnyInvTestMovable,
1146                                 TestParameterListRvalueQualifiersNothrowCall);
1147  REGISTER_TYPED_TEST_SUITE_P(AnyInvTestNoexceptFalse,
1148                              ConversionConstructionConstraints,
1149                              ConversionAssignConstraints);
1150  INSTANTIATE_TYPED_TEST_SUITE_P(
1151      NonRvalueCallMayThrow, AnyInvTestNoexceptFalse,
1152      TestParameterListNonRvalueQualifiersCallMayThrow);
1153  INSTANTIATE_TYPED_TEST_SUITE_P(RvalueCallMayThrow, AnyInvTestNoexceptFalse,
1154                                 TestParameterListRvalueQualifiersCallMayThrow);
1155  INSTANTIATE_TYPED_TEST_SUITE_P(RemoteMovable, AnyInvTestNoexceptFalse,
1156                                 TestParameterListRemoteMovable);
1157  INSTANTIATE_TYPED_TEST_SUITE_P(RemoteNonMovable, AnyInvTestNoexceptFalse,
1158                                 TestParameterListRemoteNonMovable);
1159  INSTANTIATE_TYPED_TEST_SUITE_P(Local, AnyInvTestNoexceptFalse,
1160                                 TestParameterListLocal);
1161  REGISTER_TYPED_TEST_SUITE_P(AnyInvTestNoexceptTrue,
1162                              ConversionConstructionConstraints,
1163                              ConversionAssignConstraints);
1164  INSTANTIATE_TYPED_TEST_SUITE_P(NonRvalueCallNothrow, AnyInvTestNoexceptTrue,
1165                                 TestParameterListNonRvalueQualifiersNothrowCall);
1166  INSTANTIATE_TYPED_TEST_SUITE_P(RvalueCallNothrow, AnyInvTestNoexceptTrue,
1167                                 TestParameterListRvalueQualifiersNothrowCall);
1168  REGISTER_TYPED_TEST_SUITE_P(AnyInvTestNonRvalue,
1169                              ConversionConstructionReferenceWrapper,
1170                              NonMoveableResultType,
1171                              ConversionAssignReferenceWrapperEmptyLhs,
1172                              ConversionAssignReferenceWrapperNonemptyLhs);
1173  INSTANTIATE_TYPED_TEST_SUITE_P(
1174      NonRvalueCallMayThrow, AnyInvTestNonRvalue,
1175      TestParameterListNonRvalueQualifiersCallMayThrow);
1176  INSTANTIATE_TYPED_TEST_SUITE_P(RemoteMovable, AnyInvTestNonRvalue,
1177                                 TestParameterListRemoteMovable);
1178  INSTANTIATE_TYPED_TEST_SUITE_P(RemoteNonMovable, AnyInvTestNonRvalue,
1179                                 TestParameterListRemoteNonMovable);
1180  INSTANTIATE_TYPED_TEST_SUITE_P(Local, AnyInvTestNonRvalue,
1181                                 TestParameterListLocal);
1182  INSTANTIATE_TYPED_TEST_SUITE_P(NonRvalueCallNothrow, AnyInvTestNonRvalue,
1183                                 TestParameterListNonRvalueQualifiersNothrowCall);
1184  REGISTER_TYPED_TEST_SUITE_P(AnyInvTestRvalue,
1185                              ConversionConstructionReferenceWrapper,
1186                              NonMoveableResultType,
1187                              ConversionAssignReferenceWrapper,
1188                              NonConstCrashesOnSecondCall,
1189                              QualifierIndependentObjectLifetime);
1190  INSTANTIATE_TYPED_TEST_SUITE_P(RvalueCallMayThrow, AnyInvTestRvalue,
1191                                 TestParameterListRvalueQualifiersCallMayThrow);
1192  INSTANTIATE_TYPED_TEST_SUITE_P(CallNothrowRvalue, AnyInvTestRvalue,
1193                                 TestParameterListRvalueQualifiersNothrowCall);
1194  static_assert(
1195      std::is_convertible<void (*)(), absl::AnyInvocable<void() &&>>::value, "");
1196  static_assert(!std::is_convertible<void*, absl::AnyInvocable<void() &&>>::value,
1197                "");
1198  #undef ABSL_INTERNAL_NOEXCEPT_SPEC
1199  }  
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-any_invocable_test.cc</h3>
            <pre><code>1  #include "absl/functional/any_invocable.h"
2  #include <cstddef>
3  #include <initializer_list>
4  #include <memory>
5  #include <numeric>
6  #include <type_traits>
7  #include "gtest/gtest.h"
8  #include "absl/base/config.h"
9  #include "absl/meta/type_traits.h"
10  #include "absl/utility/utility.h"
11  static_assert(absl::internal_any_invocable::kStorageSize >= sizeof(void*),
12                "These tests assume that the small object storage is at least "
13                "the size of a pointer.");
14  namespace {
15  #if ABSL_INTERNAL_CPLUSPLUS_LANG >= 201703L
16  #define ABSL_INTERNAL_NOEXCEPT_SPEC(noex) noexcept(noex)
17  #else
18  #define ABSL_INTERNAL_NOEXCEPT_SPEC(noex)
19  #endif
20  struct _ {};
21  template <class T>
22  struct Wrapper {
23    template <class U,
24              class = absl::enable_if_t<std::is_convertible<U, T>::value>>
25    Wrapper(U&&);  
26  };
27  static_assert(std::is_constructible<Wrapper<absl::AnyInvocable<void()>>,
28                                      Wrapper<absl::AnyInvocable<void()>>>::value,
29                "");
30  template <class Qualifiers, class This>
31  struct QualifiersForThisImpl {
32    static_assert(std::is_object<This>::value, "");
33    using type =
34        absl::conditional_t<std::is_const<Qualifiers>::value, const This, This>&;
35  };
36  template <class Qualifiers, class This>
37  struct QualifiersForThisImpl<Qualifiers&, This>
38      : QualifiersForThisImpl<Qualifiers, This> {};
39  template <class Qualifiers, class This>
40  struct QualifiersForThisImpl<Qualifiers&&, This> {
41    static_assert(std::is_object<This>::value, "");
42    using type =
43        absl::conditional_t<std::is_const<Qualifiers>::value, const This, This>&&;
44  };
45  template <class Qualifiers, class This>
46  using QualifiersForThis =
47      typename QualifiersForThisImpl<Qualifiers, This>::type;
48  template <class T, class Fun>
49  struct GiveQualifiersToFunImpl;
50  template <class T, class R, class... P>
51  struct GiveQualifiersToFunImpl<T, R(P...)> {
52    using type =
53        absl::conditional_t<std::is_const<T>::value, R(P...) const, R(P...)>;
54  };
55  template <class T, class R, class... P>
56  struct GiveQualifiersToFunImpl<T&, R(P...)> {
57    using type =
58        absl::conditional_t<std::is_const<T>::value, R(P...) const&, R(P...)&>;
59  };
60  template <class T, class R, class... P>
61  struct GiveQualifiersToFunImpl<T&&, R(P...)> {
62    using type =
63        absl::conditional_t<std::is_const<T>::value, R(P...) const&&, R(P...) &&>;
64  };
65  #if defined(__cpp_noexcept_function_type)
66  template <class T, class R, class... P>
67  struct GiveQualifiersToFunImpl<T, R(P...) noexcept> {
68    using type = absl::conditional_t<std::is_const<T>::value,
69                                     R(P...) const noexcept, R(P...) noexcept>;
70  };
71  template <class T, class R, class... P>
72  struct GiveQualifiersToFunImpl<T&, R(P...) noexcept> {
73    using type =
74        absl::conditional_t<std::is_const<T>::value, R(P...) const & noexcept,
75                            R(P...) & noexcept>;
76  };
77  template <class T, class R, class... P>
78  struct GiveQualifiersToFunImpl<T&&, R(P...) noexcept> {
79    using type =
80        absl::conditional_t<std::is_const<T>::value, R(P...) const && noexcept,
81                            R(P...) && noexcept>;
82  };
83  #endif  
84  template <class T, class Fun>
85  using GiveQualifiersToFun = typename GiveQualifiersToFunImpl<T, Fun>::type;
86  enum class ObjSize { small, large };
87  template <ObjSize Size>
88  struct TypeErasedPadding;
89  template <>
90  struct TypeErasedPadding<ObjSize::small> {};
91  template <>
92  struct TypeErasedPadding<ObjSize::large> {
93    char dummy_data[absl::internal_any_invocable::kStorageSize + 1] = {};
94  };
95  struct Int {
96    Int(int v) noexcept : value(v) {}  
97  #ifndef _MSC_VER
98    Int(Int&&) noexcept {
99      std::abort();
100    }
101  #else
102    Int(Int&& v) noexcept = default;
103  #endif
104    operator int() && noexcept { return value; }  
105    int MemberFunctionAdd(int const& b, int c) noexcept {  
106      return value + b + c;
107    }
108    int value;
109  };
110  enum class Movable { no, yes, nothrow, trivial };
111  enum class NothrowCall { no, yes };
112  enum class Destructible { nothrow, trivial };
113  enum class ObjAlign : std::size_t {
114    normal = absl::internal_any_invocable::kAlignment,
115    large = absl::internal_any_invocable::kAlignment * 2,
116  };
117  template <Movable Movability, Destructible Destructibility, class Qual,
118            NothrowCall CallExceptionSpec, ObjSize Size, ObjAlign Alignment>
119  struct add;
120  #define ABSL_INTERNALS_ADD(qual)                                              \
121    template <NothrowCall CallExceptionSpec, ObjSize Size, ObjAlign Alignment>  \
122    struct alignas(static_cast<std::size_t>(Alignment))                         \
123        add<Movable::trivial, Destructible::trivial, _ qual, CallExceptionSpec, \
124            Size, Alignment> : TypeErasedPadding<Size> {                        \
125      explicit add(int state_init) : state(state_init) {}                       \
126      explicit add(std::initializer_list<int> state_init, int tail)             \
127          : state(std::accumulate(std::begin(state_init), std::end(state_init), \
128                                  0) +                                          \
129                  tail) {}                                                      \
130      add(add&& other) = default; &bsol;*NOLINT*/                                    \
131      Int operator()(int a, int b, int c) qual                                  \
132          ABSL_INTERNAL_NOEXCEPT_SPEC(CallExceptionSpec == NothrowCall::yes) {  \
133        return state + a + b + c;                                               \
134      }                                                                         \
135      int state;                                                                \
136    };                                                                          \
137                                                                                \
138    template <NothrowCall CallExceptionSpec, ObjSize Size, ObjAlign Alignment>  \
139    struct alignas(static_cast<std::size_t>(Alignment))                         \
140        add<Movable::trivial, Destructible::nothrow, _ qual, CallExceptionSpec, \
141            Size, Alignment> : TypeErasedPadding<Size> {                        \
142      explicit add(int state_init) : state(state_init) {}                       \
143      explicit add(std::initializer_list<int> state_init, int tail)             \
144          : state(std::accumulate(std::begin(state_init), std::end(state_init), \
145                                  0) +                                          \
146                  tail) {}                                                      \
147      ~add() noexcept {}                                                        \
148      add(add&& other) = default; &bsol;*NOLINT*/                                    \
149      Int operator()(int a, int b, int c) qual                                  \
150          ABSL_INTERNAL_NOEXCEPT_SPEC(CallExceptionSpec == NothrowCall::yes) {  \
151        return state + a + b + c;                                               \
152      }                                                                         \
153      int state;                                                                \
154    }
155  #define ABSL_INTERNALS_NOARG
156  ABSL_INTERNALS_ADD(ABSL_INTERNALS_NOARG);
157  #undef ABSL_INTERNALS_NOARG
158  ABSL_INTERNALS_ADD(const);
159  ABSL_INTERNALS_ADD(&);
160  ABSL_INTERNALS_ADD(const&);
161  ABSL_INTERNALS_ADD(&&);       
162  ABSL_INTERNALS_ADD(const&&);  
163  #undef ABSL_INTERNALS_ADD
164  template <Destructible Destructibility, class Qual,
165            NothrowCall CallExceptionSpec, ObjSize Size, ObjAlign Alignment>
166  struct add<Movable::no, Destructibility, Qual, CallExceptionSpec, Size,
167             Alignment> : private add<Movable::trivial, Destructibility, Qual,
168                                      CallExceptionSpec, Size, Alignment> {
169    using Base = add<Movable::trivial, Destructibility, Qual, CallExceptionSpec,
170                     Size, Alignment>;
171    explicit add(int state_init) : Base(state_init) {}
172    explicit add(std::initializer_list<int> state_init, int tail)
173        : Base(state_init, tail) {}
174    add(add&&) = delete;
175    using Base::operator();
176    using Base::state;
177  };
178  template <Destructible Destructibility, class Qual,
179            NothrowCall CallExceptionSpec, ObjSize Size, ObjAlign Alignment>
180  struct add<Movable::yes, Destructibility, Qual, CallExceptionSpec, Size,
181             Alignment> : private add<Movable::trivial, Destructibility, Qual,
182                                      CallExceptionSpec, Size, Alignment> {
183    using Base = add<Movable::trivial, Destructibility, Qual, CallExceptionSpec,
184                     Size, Alignment>;
185    explicit add(int state_init) : Base(state_init) {}
186    explicit add(std::initializer_list<int> state_init, int tail)
187        : Base(state_init, tail) {}
188    add(add&& other) noexcept(false) : Base(other.state) {}  
189    using Base::operator();
190    using Base::state;
191  };
192  template <Destructible Destructibility, class Qual,
193            NothrowCall CallExceptionSpec, ObjSize Size, ObjAlign Alignment>
194  struct add<Movable::nothrow, Destructibility, Qual, CallExceptionSpec, Size,
195             Alignment> : private add<Movable::trivial, Destructibility, Qual,
196                                      CallExceptionSpec, Size, Alignment> {
197    using Base = add<Movable::trivial, Destructibility, Qual, CallExceptionSpec,
198                     Size, Alignment>;
199    explicit add(int state_init) : Base(state_init) {}
200    explicit add(std::initializer_list<int> state_init, int tail)
201        : Base(state_init, tail) {}
202    add(add&& other) noexcept : Base(other.state) {}
203    using Base::operator();
204    using Base::state;
205  };
206  Int add_function(Int&& a, int b, int c) noexcept { return a.value + b + c; }
207  Int mult_function(Int&& a, int b, int c) noexcept { return a.value * b * c; }
208  Int square_function(Int const&& a) noexcept { return a.value * a.value; }
209  template <class Sig>
210  using AnyInvocable = absl::AnyInvocable<Sig>;
211  template <Movable Movability, Destructible Destructibility, class Qual,
212            NothrowCall CallExceptionSpec, ObjSize Size, ObjAlign Alignment>
213  struct TestParams {
214    static constexpr Movable kMovability = Movability;
215    static constexpr Destructible kDestructibility = Destructibility;
216    using Qualifiers = Qual;
217    static constexpr NothrowCall kCallExceptionSpec = CallExceptionSpec;
218    static constexpr bool kIsNoexcept = kCallExceptionSpec == NothrowCall::yes;
219    static constexpr bool kIsRvalueQualified =
220        std::is_rvalue_reference<Qual>::value;
221    static constexpr ObjSize kSize = Size;
222    static constexpr ObjAlign kAlignment = Alignment;
223    using UnqualifiedUnaryFunType = int(Int const&&)
224        ABSL_INTERNAL_NOEXCEPT_SPEC(CallExceptionSpec == NothrowCall::yes);
225    using UnaryFunType = GiveQualifiersToFun<Qualifiers, UnqualifiedUnaryFunType>;
226    using MemObjPtrType = int(Int::*);
227    using UnaryAnyInvType = AnyInvocable<UnaryFunType>;
228    using UnaryThisParamType = QualifiersForThis<Qualifiers, UnaryAnyInvType>;
229    template <class T>
230    static UnaryThisParamType ToUnaryThisParam(T&& fun) {
231      return static_cast<UnaryThisParamType>(fun);
232    }
233    using ResultType = Int;
234    using AnyInvocableFunTypeNotNoexcept = Int(Int, const int&, int);
235    using UnqualifiedFunType =
236        typename std::conditional<kIsNoexcept, Int(Int, const int&, int) noexcept,
237                                  Int(Int, const int&, int)>::type;
238    using FunType = GiveQualifiersToFun<Qualifiers, UnqualifiedFunType>;
239    using MemFunPtrType =
240        typename std::conditional<kIsNoexcept,
241                                  Int (Int::*)(const int&, int) noexcept,
242                                  Int (Int::*)(const int&, int)>::type;
243    using AnyInvType = AnyInvocable<FunType>;
244    using AddType = add<kMovability, kDestructibility, Qualifiers,
245                        kCallExceptionSpec, kSize, kAlignment>;
246    using ThisParamType = QualifiersForThis<Qualifiers, AnyInvType>;
247    template <class T>
248    static ThisParamType ToThisParam(T&& fun) {
249      return static_cast<ThisParamType>(fun);
250    }
251    using UnqualifiedVoidFunType =
252        typename std::conditional<kIsNoexcept,
253                                  void(Int, const int&, int) noexcept,
254                                  void(Int, const int&, int)>::type;
255    using VoidFunType = GiveQualifiersToFun<Qualifiers, UnqualifiedVoidFunType>;
256    using VoidAnyInvType = AnyInvocable<VoidFunType>;
257    using VoidThisParamType = QualifiersForThis<Qualifiers, VoidAnyInvType>;
258    template <class T>
259    static VoidThisParamType ToVoidThisParam(T&& fun) {
260      return static_cast<VoidThisParamType>(fun);
261    }
262    using CompatibleAnyInvocableFunType =
263        absl::conditional_t<std::is_rvalue_reference<Qual>::value,
264                            GiveQualifiersToFun<const _&&, UnqualifiedFunType>,
265                            GiveQualifiersToFun<const _&, UnqualifiedFunType>>;
266    using CompatibleAnyInvType = AnyInvocable<CompatibleAnyInvocableFunType>;
267    using IncompatibleInvocable =
268        absl::conditional_t<std::is_rvalue_reference<Qual>::value,
269                            GiveQualifiersToFun<_&, UnqualifiedFunType>(_::*),
270                            GiveQualifiersToFun<_&&, UnqualifiedFunType>(_::*)>;
271  };
272  template <class MemberPtrType>
273  struct MemberTypeOfImpl;
274  template <class Class, class T>
275  struct MemberTypeOfImpl<T(Class::*)> {
276    using type = T;
277  };
278  template <class MemberPtrType>
279  using MemberTypeOf = typename MemberTypeOfImpl<MemberPtrType>::type;
280  template <class T, class = void>
281  struct IsMemberSwappableImpl : std::false_type {
282    static constexpr bool kIsNothrow = false;
283  };
284  template <class T>
285  struct IsMemberSwappableImpl<
286      T, absl::void_t<decltype(std::declval<T&>().swap(std::declval<T&>()))>>
287      : std::true_type {
288    static constexpr bool kIsNothrow =
289        noexcept(std::declval<T&>().swap(std::declval<T&>()));
290  };
291  template <class T>
292  using IsMemberSwappable = IsMemberSwappableImpl<T>;
293  template <class T>
294  using IsNothrowMemberSwappable =
295      std::integral_constant<bool, IsMemberSwappableImpl<T>::kIsNothrow>;
296  template <class T>
297  class AnyInvTestBasic : public ::testing::Test {};
298  TYPED_TEST_SUITE_P(AnyInvTestBasic);
299  TYPED_TEST_P(AnyInvTestBasic, DefaultConstruction) {
300    using AnyInvType = typename TypeParam::AnyInvType;
301    AnyInvType fun;
302    EXPECT_FALSE(static_cast<bool>(fun));
303    EXPECT_TRUE(std::is_nothrow_default_constructible<AnyInvType>::value);
304  }
305  TYPED_TEST_P(AnyInvTestBasic, ConstructionNullptr) {
306    using AnyInvType = typename TypeParam::AnyInvType;
307    AnyInvType fun = nullptr;
308    EXPECT_FALSE(static_cast<bool>(fun));
309    EXPECT_TRUE(
310        (std::is_nothrow_constructible<AnyInvType, std::nullptr_t>::value));
311  }
312  TYPED_TEST_P(AnyInvTestBasic, ConstructionNullFunctionPtr) {
313    using AnyInvType = typename TypeParam::AnyInvType;
314    using UnqualifiedFunType = typename TypeParam::UnqualifiedFunType;
315    UnqualifiedFunType* const null_fun_ptr = nullptr;
316    AnyInvType fun = null_fun_ptr;
317    EXPECT_FALSE(static_cast<bool>(fun));
318  }
319  TYPED_TEST_P(AnyInvTestBasic, ConstructionNullMemberFunctionPtr) {
320    using AnyInvType = typename TypeParam::AnyInvType;
321    using MemFunPtrType = typename TypeParam::MemFunPtrType;
322    const MemFunPtrType null_mem_fun_ptr = nullptr;
323    AnyInvType fun = null_mem_fun_ptr;
324    EXPECT_FALSE(static_cast<bool>(fun));
325  }
326  TYPED_TEST_P(AnyInvTestBasic, ConstructionNullMemberObjectPtr) {
327    using UnaryAnyInvType = typename TypeParam::UnaryAnyInvType;
328    using MemObjPtrType = typename TypeParam::MemObjPtrType;
329    const MemObjPtrType null_mem_obj_ptr = nullptr;
330    UnaryAnyInvType fun = null_mem_obj_ptr;
331    EXPECT_FALSE(static_cast<bool>(fun));
332  }
333  TYPED_TEST_P(AnyInvTestBasic, ConstructionMemberFunctionPtr) {
334    using AnyInvType = typename TypeParam::AnyInvType;
335    AnyInvType fun = &Int::MemberFunctionAdd;
336    EXPECT_TRUE(static_cast<bool>(fun));
337    EXPECT_EQ(24, TypeParam::ToThisParam(fun)(7, 8, 9).value);
338  }
339  TYPED_TEST_P(AnyInvTestBasic, ConstructionMemberObjectPtr) {
340    using UnaryAnyInvType = typename TypeParam::UnaryAnyInvType;
341    UnaryAnyInvType fun = &Int::value;
342    EXPECT_TRUE(static_cast<bool>(fun));
343    EXPECT_EQ(13, TypeParam::ToUnaryThisParam(fun)(13));
344  }
345  TYPED_TEST_P(AnyInvTestBasic, ConstructionFunctionReferenceDecay) {
346    using AnyInvType = typename TypeParam::AnyInvType;
347    AnyInvType fun = add_function;
348    EXPECT_TRUE(static_cast<bool>(fun));
349    EXPECT_EQ(24, TypeParam::ToThisParam(fun)(7, 8, 9).value);
350  }
351  TYPED_TEST_P(AnyInvTestBasic, ConstructionCompatibleAnyInvocableEmpty) {
352    using AnyInvType = typename TypeParam::AnyInvType;
353    using CompatibleAnyInvType = typename TypeParam::CompatibleAnyInvType;
354    CompatibleAnyInvType other;
355    AnyInvType fun = std::move(other);
356    EXPECT_FALSE(static_cast<bool>(other));  
357    EXPECT_EQ(other, nullptr);               
358    EXPECT_EQ(nullptr, other);               
359    EXPECT_FALSE(static_cast<bool>(fun));
360  }
361  TYPED_TEST_P(AnyInvTestBasic, ConstructionCompatibleAnyInvocableNonempty) {
362    using AnyInvType = typename TypeParam::AnyInvType;
363    using CompatibleAnyInvType = typename TypeParam::CompatibleAnyInvType;
364    CompatibleAnyInvType other = &add_function;
365    AnyInvType fun = std::move(other);
366    EXPECT_FALSE(static_cast<bool>(other));  
367    EXPECT_EQ(other, nullptr);               
368    EXPECT_EQ(nullptr, other);               
369    EXPECT_TRUE(static_cast<bool>(fun));
370    EXPECT_EQ(24, TypeParam::ToThisParam(fun)(7, 8, 9).value);
371  }
372  TYPED_TEST_P(AnyInvTestBasic, ConversionToBool) {
373    using AnyInvType = typename TypeParam::AnyInvType;
374    {
375      AnyInvType fun;
376      EXPECT_FALSE(fun ? true : false);  
377      EXPECT_TRUE(
378          (std::is_nothrow_constructible<bool, const AnyInvType&>::value));
379      EXPECT_FALSE((std::is_convertible<const AnyInvType&, bool>::value));
380    }
381    {
382      AnyInvType fun = &add_function;
383      EXPECT_TRUE(fun ? true : false);  
384    }
385  }
386  TYPED_TEST_P(AnyInvTestBasic, Invocation) {
387    using AnyInvType = typename TypeParam::AnyInvType;
388    using FunType = typename TypeParam::FunType;
389    using AnyInvCallType = MemberTypeOf<decltype(&AnyInvType::operator())>;
390    EXPECT_TRUE((std::is_same<AnyInvCallType, FunType>::value));
391    AnyInvType fun = &add_function;
392    EXPECT_EQ(24, TypeParam::ToThisParam(fun)(7, 8, 9).value);
393  }
394  TYPED_TEST_P(AnyInvTestBasic, InPlaceConstruction) {
395    using AnyInvType = typename TypeParam::AnyInvType;
396    using AddType = typename TypeParam::AddType;
397    AnyInvType fun(absl::in_place_type<AddType>, 5);
398    EXPECT_TRUE(static_cast<bool>(fun));
399    EXPECT_EQ(29, TypeParam::ToThisParam(fun)(7, 8, 9).value);
400  }
401  TYPED_TEST_P(AnyInvTestBasic, InPlaceConstructionInitializerList) {
402    using AnyInvType = typename TypeParam::AnyInvType;
403    using AddType = typename TypeParam::AddType;
404    AnyInvType fun(absl::in_place_type<AddType>, {1, 2, 3, 4}, 5);
405    EXPECT_TRUE(static_cast<bool>(fun));
406    EXPECT_EQ(39, TypeParam::ToThisParam(fun)(7, 8, 9).value);
407  }
408  TYPED_TEST_P(AnyInvTestBasic, InPlaceNullFunPtrConstruction) {
409    using AnyInvType = typename TypeParam::AnyInvType;
410    using UnqualifiedFunType = typename TypeParam::UnqualifiedFunType;
411    AnyInvType fun(absl::in_place_type<UnqualifiedFunType*>, nullptr);
412    EXPECT_TRUE(static_cast<bool>(fun));
413  }
414  TYPED_TEST_P(AnyInvTestBasic, InPlaceNullFunPtrConstructionValueInit) {
415    using AnyInvType = typename TypeParam::AnyInvType;
416    using UnqualifiedFunType = typename TypeParam::UnqualifiedFunType;
417    AnyInvType fun(absl::in_place_type<UnqualifiedFunType*>);
418    EXPECT_TRUE(static_cast<bool>(fun));
419  }
420  TYPED_TEST_P(AnyInvTestBasic, InPlaceNullMemFunPtrConstruction) {
421    using AnyInvType = typename TypeParam::AnyInvType;
422    using MemFunPtrType = typename TypeParam::MemFunPtrType;
423    AnyInvType fun(absl::in_place_type<MemFunPtrType>, nullptr);
424    EXPECT_TRUE(static_cast<bool>(fun));
425  }
426  TYPED_TEST_P(AnyInvTestBasic, InPlaceNullMemFunPtrConstructionValueInit) {
427    using AnyInvType = typename TypeParam::AnyInvType;
428    using MemFunPtrType = typename TypeParam::MemFunPtrType;
429    AnyInvType fun(absl::in_place_type<MemFunPtrType>);
430    EXPECT_TRUE(static_cast<bool>(fun));
431  }
432  TYPED_TEST_P(AnyInvTestBasic, InPlaceNullMemObjPtrConstruction) {
433    using UnaryAnyInvType = typename TypeParam::UnaryAnyInvType;
434    using MemObjPtrType = typename TypeParam::MemObjPtrType;
435    UnaryAnyInvType fun(absl::in_place_type<MemObjPtrType>, nullptr);
436    EXPECT_TRUE(static_cast<bool>(fun));
437  }
438  TYPED_TEST_P(AnyInvTestBasic, InPlaceNullMemObjPtrConstructionValueInit) {
439    using UnaryAnyInvType = typename TypeParam::UnaryAnyInvType;
440    using MemObjPtrType = typename TypeParam::MemObjPtrType;
441    UnaryAnyInvType fun(absl::in_place_type<MemObjPtrType>);
442    EXPECT_TRUE(static_cast<bool>(fun));
443  }
444  TYPED_TEST_P(AnyInvTestBasic, InPlaceVoidCovarianceConstruction) {
445    using VoidAnyInvType = typename TypeParam::VoidAnyInvType;
446    using AddType = typename TypeParam::AddType;
447    VoidAnyInvType fun(absl::in_place_type<AddType>, 5);
448    EXPECT_TRUE(static_cast<bool>(fun));
449  }
450  TYPED_TEST_P(AnyInvTestBasic, MoveConstructionFromEmpty) {
451    using AnyInvType = typename TypeParam::AnyInvType;
452    AnyInvType source_fun;
453    AnyInvType fun(std::move(source_fun));
454    EXPECT_FALSE(static_cast<bool>(fun));
455    EXPECT_TRUE(std::is_nothrow_move_constructible<AnyInvType>::value);
456  }
457  TYPED_TEST_P(AnyInvTestBasic, MoveConstructionFromNonEmpty) {
458    using AnyInvType = typename TypeParam::AnyInvType;
459    using AddType = typename TypeParam::AddType;
460    AnyInvType source_fun(absl::in_place_type<AddType>, 5);
461    AnyInvType fun(std::move(source_fun));
462    EXPECT_TRUE(static_cast<bool>(fun));
463    EXPECT_EQ(29, TypeParam::ToThisParam(fun)(7, 8, 9).value);
464    EXPECT_TRUE(std::is_nothrow_move_constructible<AnyInvType>::value);
465  }
466  TYPED_TEST_P(AnyInvTestBasic, ComparisonWithNullptrEmpty) {
467    using AnyInvType = typename TypeParam::AnyInvType;
468    AnyInvType fun;
469    EXPECT_TRUE(fun == nullptr);
470    EXPECT_TRUE(nullptr == fun);
471    EXPECT_FALSE(fun != nullptr);
472    EXPECT_FALSE(nullptr != fun);
473  }
474  TYPED_TEST_P(AnyInvTestBasic, ComparisonWithNullptrNonempty) {
475    using AnyInvType = typename TypeParam::AnyInvType;
476    using AddType = typename TypeParam::AddType;
477    AnyInvType fun(absl::in_place_type<AddType>, 5);
478    EXPECT_FALSE(fun == nullptr);
479    EXPECT_FALSE(nullptr == fun);
480    EXPECT_TRUE(fun != nullptr);
481    EXPECT_TRUE(nullptr != fun);
482  }
483  TYPED_TEST_P(AnyInvTestBasic, ResultType) {
484    using AnyInvType = typename TypeParam::AnyInvType;
485    using ExpectedResultType = typename TypeParam::ResultType;
486    EXPECT_TRUE((std::is_same<typename AnyInvType::result_type,
487                              ExpectedResultType>::value));
488  }
489  template <class T>
490  class AnyInvTestCombinatoric : public ::testing::Test {};
491  TYPED_TEST_SUITE_P(AnyInvTestCombinatoric);
492  TYPED_TEST_P(AnyInvTestCombinatoric, MoveAssignEmptyEmptyLhsRhs) {
493    using AnyInvType = typename TypeParam::AnyInvType;
494    AnyInvType source_fun;
495    AnyInvType fun;
496    fun = std::move(source_fun);
497    EXPECT_FALSE(static_cast<bool>(fun));
498  }
499  TYPED_TEST_P(AnyInvTestCombinatoric, MoveAssignEmptyLhsNonemptyRhs) {
500    using AnyInvType = typename TypeParam::AnyInvType;
501    using AddType = typename TypeParam::AddType;
502    AnyInvType source_fun(absl::in_place_type<AddType>, 5);
503    AnyInvType fun;
504    fun = std::move(source_fun);
505    EXPECT_TRUE(static_cast<bool>(fun));
506    EXPECT_EQ(29, TypeParam::ToThisParam(fun)(7, 8, 9).value);
507  }
508  TYPED_TEST_P(AnyInvTestCombinatoric, MoveAssignNonemptyEmptyLhsRhs) {
509    using AnyInvType = typename TypeParam::AnyInvType;
510    using AddType = typename TypeParam::AddType;
511    AnyInvType source_fun;
512    AnyInvType fun(absl::in_place_type<AddType>, 5);
513    fun = std::move(source_fun);
514    EXPECT_FALSE(static_cast<bool>(fun));
515  }
516  TYPED_TEST_P(AnyInvTestCombinatoric, MoveAssignNonemptyLhsNonemptyRhs) {
517    using AnyInvType = typename TypeParam::AnyInvType;
518    using AddType = typename TypeParam::AddType;
519    AnyInvType source_fun(absl::in_place_type<AddType>, 5);
520    AnyInvType fun(absl::in_place_type<AddType>, 20);
521    fun = std::move(source_fun);
522    EXPECT_TRUE(static_cast<bool>(fun));
523    EXPECT_EQ(29, TypeParam::ToThisParam(fun)(7, 8, 9).value);
524  }
525  TYPED_TEST_P(AnyInvTestCombinatoric, SelfMoveAssignEmpty) {
526    using AnyInvType = typename TypeParam::AnyInvType;
527    AnyInvType source_fun;
528    source_fun = std::move(source_fun);
529  }
530  TYPED_TEST_P(AnyInvTestCombinatoric, SelfMoveAssignNonempty) {
531    using AnyInvType = typename TypeParam::AnyInvType;
532    using AddType = typename TypeParam::AddType;
533    AnyInvType source_fun(absl::in_place_type<AddType>, 5);
534    source_fun = std::move(source_fun);
535  }
536  TYPED_TEST_P(AnyInvTestCombinatoric, AssignNullptrEmptyLhs) {
537    using AnyInvType = typename TypeParam::AnyInvType;
538    AnyInvType fun;
539    fun = nullptr;
540    EXPECT_FALSE(static_cast<bool>(fun));
541  }
542  TYPED_TEST_P(AnyInvTestCombinatoric, AssignNullFunctionPtrEmptyLhs) {
543    using AnyInvType = typename TypeParam::AnyInvType;
544    using UnqualifiedFunType = typename TypeParam::UnqualifiedFunType;
545    UnqualifiedFunType* const null_fun_ptr = nullptr;
546    AnyInvType fun;
547    fun = null_fun_ptr;
548    EXPECT_FALSE(static_cast<bool>(fun));
549  }
550  TYPED_TEST_P(AnyInvTestCombinatoric, AssignNullMemberFunctionPtrEmptyLhs) {
551    using AnyInvType = typename TypeParam::AnyInvType;
552    using MemFunPtrType = typename TypeParam::MemFunPtrType;
553    const MemFunPtrType null_mem_fun_ptr = nullptr;
554    AnyInvType fun;
555    fun = null_mem_fun_ptr;
556    EXPECT_FALSE(static_cast<bool>(fun));
557  }
558  TYPED_TEST_P(AnyInvTestCombinatoric, AssignNullMemberObjectPtrEmptyLhs) {
559    using UnaryAnyInvType = typename TypeParam::UnaryAnyInvType;
560    using MemObjPtrType = typename TypeParam::MemObjPtrType;
561    const MemObjPtrType null_mem_obj_ptr = nullptr;
562    UnaryAnyInvType fun;
563    fun = null_mem_obj_ptr;
564    EXPECT_FALSE(static_cast<bool>(fun));
565  }
566  TYPED_TEST_P(AnyInvTestCombinatoric, AssignMemberFunctionPtrEmptyLhs) {
567    using AnyInvType = typename TypeParam::AnyInvType;
568    AnyInvType fun;
569    fun = &Int::MemberFunctionAdd;
570    EXPECT_TRUE(static_cast<bool>(fun));
571    EXPECT_EQ(24, TypeParam::ToThisParam(fun)(7, 8, 9).value);
572  }
573  TYPED_TEST_P(AnyInvTestCombinatoric, AssignMemberObjectPtrEmptyLhs) {
574    using UnaryAnyInvType = typename TypeParam::UnaryAnyInvType;
575    UnaryAnyInvType fun;
576    fun = &Int::value;
577    EXPECT_TRUE(static_cast<bool>(fun));
578    EXPECT_EQ(13, TypeParam::ToUnaryThisParam(fun)(13));
579  }
580  TYPED_TEST_P(AnyInvTestCombinatoric, AssignFunctionReferenceDecayEmptyLhs) {
581    using AnyInvType = typename TypeParam::AnyInvType;
582    AnyInvType fun;
583    fun = add_function;
584    EXPECT_TRUE(static_cast<bool>(fun));
585    EXPECT_EQ(24, TypeParam::ToThisParam(fun)(7, 8, 9).value);
586  }
587  TYPED_TEST_P(AnyInvTestCombinatoric,
588               AssignCompatibleAnyInvocableEmptyLhsEmptyRhs) {
589    using AnyInvType = typename TypeParam::AnyInvType;
590    using CompatibleAnyInvType = typename TypeParam::CompatibleAnyInvType;
591    CompatibleAnyInvType other;
592    AnyInvType fun;
593    fun = std::move(other);
594    EXPECT_FALSE(static_cast<bool>(other));  
595    EXPECT_EQ(other, nullptr);               
596    EXPECT_EQ(nullptr, other);               
597    EXPECT_FALSE(static_cast<bool>(fun));
598  }
599  TYPED_TEST_P(AnyInvTestCombinatoric,
600               AssignCompatibleAnyInvocableEmptyLhsNonemptyRhs) {
601    using AnyInvType = typename TypeParam::AnyInvType;
602    using CompatibleAnyInvType = typename TypeParam::CompatibleAnyInvType;
603    CompatibleAnyInvType other = &add_function;
604    AnyInvType fun;
605    fun = std::move(other);
606    EXPECT_FALSE(static_cast<bool>(other));  
607    EXPECT_TRUE(static_cast<bool>(fun));
608    EXPECT_EQ(24, TypeParam::ToThisParam(fun)(7, 8, 9).value);
609  }
610  TYPED_TEST_P(AnyInvTestCombinatoric, AssignNullptrNonemptyLhs) {
611    using AnyInvType = typename TypeParam::AnyInvType;
612    AnyInvType fun = &mult_function;
613    fun = nullptr;
614    EXPECT_FALSE(static_cast<bool>(fun));
615  }
616  TYPED_TEST_P(AnyInvTestCombinatoric, AssignNullFunctionPtrNonemptyLhs) {
617    using AnyInvType = typename TypeParam::AnyInvType;
618    using UnqualifiedFunType = typename TypeParam::UnqualifiedFunType;
619    UnqualifiedFunType* const null_fun_ptr = nullptr;
620    AnyInvType fun = &mult_function;
621    fun = null_fun_ptr;
622    EXPECT_FALSE(static_cast<bool>(fun));
623  }
624  TYPED_TEST_P(AnyInvTestCombinatoric, AssignNullMemberFunctionPtrNonemptyLhs) {
625    using AnyInvType = typename TypeParam::AnyInvType;
626    using MemFunPtrType = typename TypeParam::MemFunPtrType;
627    const MemFunPtrType null_mem_fun_ptr = nullptr;
628    AnyInvType fun = &mult_function;
629    fun = null_mem_fun_ptr;
630    EXPECT_FALSE(static_cast<bool>(fun));
631  }
632  TYPED_TEST_P(AnyInvTestCombinatoric, AssignNullMemberObjectPtrNonemptyLhs) {
633    using UnaryAnyInvType = typename TypeParam::UnaryAnyInvType;
634    using MemObjPtrType = typename TypeParam::MemObjPtrType;
635    const MemObjPtrType null_mem_obj_ptr = nullptr;
636    UnaryAnyInvType fun = &square_function;
637    fun = null_mem_obj_ptr;
638    EXPECT_FALSE(static_cast<bool>(fun));
639  }
640  TYPED_TEST_P(AnyInvTestCombinatoric, AssignMemberFunctionPtrNonemptyLhs) {
641    using AnyInvType = typename TypeParam::AnyInvType;
642    AnyInvType fun = &mult_function;
643    fun = &Int::MemberFunctionAdd;
644    EXPECT_TRUE(static_cast<bool>(fun));
645    EXPECT_EQ(24, TypeParam::ToThisParam(fun)(7, 8, 9).value);
646  }
647  TYPED_TEST_P(AnyInvTestCombinatoric, AssignMemberObjectPtrNonemptyLhs) {
648    using UnaryAnyInvType = typename TypeParam::UnaryAnyInvType;
649    UnaryAnyInvType fun = &square_function;
650    fun = &Int::value;
651    EXPECT_TRUE(static_cast<bool>(fun));
652    EXPECT_EQ(13, TypeParam::ToUnaryThisParam(fun)(13));
653  }
654  TYPED_TEST_P(AnyInvTestCombinatoric, AssignFunctionReferenceDecayNonemptyLhs) {
655    using AnyInvType = typename TypeParam::AnyInvType;
656    AnyInvType fun = &mult_function;
657    fun = add_function;
658    EXPECT_TRUE(static_cast<bool>(fun));
659    EXPECT_EQ(24, TypeParam::ToThisParam(fun)(7, 8, 9).value);
660  }
661  TYPED_TEST_P(AnyInvTestCombinatoric,
662               AssignCompatibleAnyInvocableNonemptyLhsEmptyRhs) {
663    using AnyInvType = typename TypeParam::AnyInvType;
664    using CompatibleAnyInvType = typename TypeParam::CompatibleAnyInvType;
665    CompatibleAnyInvType other;
666    AnyInvType fun = &mult_function;
667    fun = std::move(other);
668    EXPECT_FALSE(static_cast<bool>(other));  
669    EXPECT_EQ(other, nullptr);               
670    EXPECT_EQ(nullptr, other);               
671    EXPECT_FALSE(static_cast<bool>(fun));
672  }
673  TYPED_TEST_P(AnyInvTestCombinatoric,
674               AssignCompatibleAnyInvocableNonemptyLhsNonemptyRhs) {
675    using AnyInvType = typename TypeParam::AnyInvType;
676    using CompatibleAnyInvType = typename TypeParam::CompatibleAnyInvType;
677    CompatibleAnyInvType other = &add_function;
678    AnyInvType fun = &mult_function;
679    fun = std::move(other);
680    EXPECT_FALSE(static_cast<bool>(other));  
681    EXPECT_TRUE(static_cast<bool>(fun));
682    EXPECT_EQ(24, TypeParam::ToThisParam(fun)(7, 8, 9).value);
683  }
684  TYPED_TEST_P(AnyInvTestCombinatoric, SwapEmptyLhsEmptyRhs) {
685    using AnyInvType = typename TypeParam::AnyInvType;
686    {
687      AnyInvType fun;
688      AnyInvType other;
689      using std::swap;
690      swap(fun, other);
691      EXPECT_FALSE(static_cast<bool>(fun));
692      EXPECT_FALSE(static_cast<bool>(other));
693      EXPECT_TRUE(
694          absl::type_traits_internal::IsNothrowSwappable<AnyInvType>::value);
695    }
696    {
697      AnyInvType fun;
698      AnyInvType other;
699      fun.swap(other);
700      EXPECT_FALSE(static_cast<bool>(fun));
701      EXPECT_FALSE(static_cast<bool>(other));
702      EXPECT_TRUE(IsNothrowMemberSwappable<AnyInvType>::value);
703    }
704  }
705  TYPED_TEST_P(AnyInvTestCombinatoric, SwapEmptyLhsNonemptyRhs) {
706    using AnyInvType = typename TypeParam::AnyInvType;
707    using AddType = typename TypeParam::AddType;
708    {
709      AnyInvType fun;
710      AnyInvType other(absl::in_place_type<AddType>, 5);
711      using std::swap;
712      swap(fun, other);
713      EXPECT_TRUE(static_cast<bool>(fun));
714      EXPECT_FALSE(static_cast<bool>(other));
715      EXPECT_EQ(29, TypeParam::ToThisParam(fun)(7, 8, 9).value);
716      EXPECT_TRUE(
717          absl::type_traits_internal::IsNothrowSwappable<AnyInvType>::value);
718    }
719    {
720      AnyInvType fun;
721      AnyInvType other(absl::in_place_type<AddType>, 5);
722      fun.swap(other);
723      EXPECT_TRUE(static_cast<bool>(fun));
724      EXPECT_FALSE(static_cast<bool>(other));
725      EXPECT_EQ(29, TypeParam::ToThisParam(fun)(7, 8, 9).value);
726      EXPECT_TRUE(IsNothrowMemberSwappable<AnyInvType>::value);
727    }
728  }
729  TYPED_TEST_P(AnyInvTestCombinatoric, SwapNonemptyLhsEmptyRhs) {
730    using AnyInvType = typename TypeParam::AnyInvType;
731    using AddType = typename TypeParam::AddType;
732    {
733      AnyInvType fun(absl::in_place_type<AddType>, 5);
734      AnyInvType other;
735      using std::swap;
736      swap(fun, other);
737      EXPECT_FALSE(static_cast<bool>(fun));
738      EXPECT_TRUE(static_cast<bool>(other));
739      EXPECT_EQ(29, TypeParam::ToThisParam(other)(7, 8, 9).value);
740      EXPECT_TRUE(
741          absl::type_traits_internal::IsNothrowSwappable<AnyInvType>::value);
742    }
743    {
744      AnyInvType fun(absl::in_place_type<AddType>, 5);
745      AnyInvType other;
746      fun.swap(other);
747      EXPECT_FALSE(static_cast<bool>(fun));
748      EXPECT_TRUE(static_cast<bool>(other));
749      EXPECT_EQ(29, TypeParam::ToThisParam(other)(7, 8, 9).value);
750      EXPECT_TRUE(IsNothrowMemberSwappable<AnyInvType>::value);
751    }
752  }
753  TYPED_TEST_P(AnyInvTestCombinatoric, SwapNonemptyLhsNonemptyRhs) {
754    using AnyInvType = typename TypeParam::AnyInvType;
755    using AddType = typename TypeParam::AddType;
756    {
757      AnyInvType fun(absl::in_place_type<AddType>, 5);
758      AnyInvType other(absl::in_place_type<AddType>, 6);
759      using std::swap;
760      swap(fun, other);
761      EXPECT_TRUE(static_cast<bool>(fun));
762      EXPECT_TRUE(static_cast<bool>(other));
763      EXPECT_EQ(30, TypeParam::ToThisParam(fun)(7, 8, 9).value);
764      EXPECT_EQ(29, TypeParam::ToThisParam(other)(7, 8, 9).value);
765      EXPECT_TRUE(
766          absl::type_traits_internal::IsNothrowSwappable<AnyInvType>::value);
767    }
768    {
769      AnyInvType fun(absl::in_place_type<AddType>, 5);
770      AnyInvType other(absl::in_place_type<AddType>, 6);
771      fun.swap(other);
772      EXPECT_TRUE(static_cast<bool>(fun));
773      EXPECT_TRUE(static_cast<bool>(other));
774      EXPECT_EQ(30, TypeParam::ToThisParam(fun)(7, 8, 9).value);
775      EXPECT_EQ(29, TypeParam::ToThisParam(other)(7, 8, 9).value);
776      EXPECT_TRUE(IsNothrowMemberSwappable<AnyInvType>::value);
777    }
778  }
779  template <class T>
780  class AnyInvTestMovable : public ::testing::Test {};
781  TYPED_TEST_SUITE_P(AnyInvTestMovable);
782  TYPED_TEST_P(AnyInvTestMovable, ConversionConstructionUserDefinedType) {
783    using AnyInvType = typename TypeParam::AnyInvType;
784    using AddType = typename TypeParam::AddType;
785    AnyInvType fun(AddType(5));
786    EXPECT_TRUE(static_cast<bool>(fun));
787    EXPECT_EQ(29, TypeParam::ToThisParam(fun)(7, 8, 9).value);
788  }
789  TYPED_TEST_P(AnyInvTestMovable, ConversionConstructionVoidCovariance) {
790    using VoidAnyInvType = typename TypeParam::VoidAnyInvType;
791    using AddType = typename TypeParam::AddType;
792    VoidAnyInvType fun(AddType(5));
793    EXPECT_TRUE(static_cast<bool>(fun));
794  }
795  TYPED_TEST_P(AnyInvTestMovable, ConversionAssignUserDefinedTypeEmptyLhs) {
796    using AnyInvType = typename TypeParam::AnyInvType;
797    using AddType = typename TypeParam::AddType;
798    AnyInvType fun;
799    fun = AddType(5);
800    EXPECT_TRUE(static_cast<bool>(fun));
801    EXPECT_EQ(29, TypeParam::ToThisParam(fun)(7, 8, 9).value);
802  }
803  TYPED_TEST_P(AnyInvTestMovable, ConversionAssignUserDefinedTypeNonemptyLhs) {
804    using AnyInvType = typename TypeParam::AnyInvType;
805    using AddType = typename TypeParam::AddType;
806    AnyInvType fun = &add_function;
807    fun = AddType(5);
808    EXPECT_TRUE(static_cast<bool>(fun));
809    EXPECT_EQ(29, TypeParam::ToThisParam(fun)(7, 8, 9).value);
810  }
811  TYPED_TEST_P(AnyInvTestMovable, ConversionAssignVoidCovariance) {
812    using VoidAnyInvType = typename TypeParam::VoidAnyInvType;
813    using AddType = typename TypeParam::AddType;
814    VoidAnyInvType fun;
815    fun = AddType(5);
816    EXPECT_TRUE(static_cast<bool>(fun));
817  }
818  template <class T>
819  class AnyInvTestNoexceptFalse : public ::testing::Test {};
820  TYPED_TEST_SUITE_P(AnyInvTestNoexceptFalse);
821  TYPED_TEST_P(AnyInvTestNoexceptFalse, ConversionConstructionConstraints) {
822    using AnyInvType = typename TypeParam::AnyInvType;
823    EXPECT_TRUE((std::is_constructible<
824                 AnyInvType,
825                 typename TypeParam::AnyInvocableFunTypeNotNoexcept*>::value));
826    EXPECT_FALSE((
827        std::is_constructible<AnyInvType,
828                              typename TypeParam::IncompatibleInvocable>::value));
829  }
830  TYPED_TEST_P(AnyInvTestNoexceptFalse, ConversionAssignConstraints) {
831    using AnyInvType = typename TypeParam::AnyInvType;
832    EXPECT_TRUE((std::is_assignable<
833                 AnyInvType&,
834                 typename TypeParam::AnyInvocableFunTypeNotNoexcept*>::value));
835    EXPECT_FALSE(
836        (std::is_assignable<AnyInvType&,
837                            typename TypeParam::IncompatibleInvocable>::value));
838  }
839  template <class T>
840  class AnyInvTestNoexceptTrue : public ::testing::Test {};
841  TYPED_TEST_SUITE_P(AnyInvTestNoexceptTrue);
842  TYPED_TEST_P(AnyInvTestNoexceptTrue, ConversionConstructionConstraints) {
843  #if ABSL_INTERNAL_CPLUSPLUS_LANG < 201703L
844    GTEST_SKIP() << "Noexcept was not part of the type system before C++17.";
845  #else
846    using AnyInvType = typename TypeParam::AnyInvType;
847    EXPECT_FALSE((std::is_constructible<
848                  AnyInvType,
849                  typename TypeParam::AnyInvocableFunTypeNotNoexcept*>::value));
850    EXPECT_FALSE((
851        std::is_constructible<AnyInvType,
852                              typename TypeParam::IncompatibleInvocable>::value));
853  #endif
854  }
855  TYPED_TEST_P(AnyInvTestNoexceptTrue, ConversionAssignConstraints) {
856  #if ABSL_INTERNAL_CPLUSPLUS_LANG < 201703L
857    GTEST_SKIP() << "Noexcept was not part of the type system before C++17.";
858  #else
859    using AnyInvType = typename TypeParam::AnyInvType;
860    EXPECT_FALSE((std::is_assignable<
861                  AnyInvType&,
862                  typename TypeParam::AnyInvocableFunTypeNotNoexcept*>::value));
863    EXPECT_FALSE(
864        (std::is_assignable<AnyInvType&,
865                            typename TypeParam::IncompatibleInvocable>::value));
866  #endif
867  }
868  template <class T>
869  class AnyInvTestNonRvalue : public ::testing::Test {};
870  TYPED_TEST_SUITE_P(AnyInvTestNonRvalue);
871  TYPED_TEST_P(AnyInvTestNonRvalue, ConversionConstructionReferenceWrapper) {
872    using AnyInvType = typename TypeParam::AnyInvType;
873    using AddType = typename TypeParam::AddType;
874    AddType add(4);
875    AnyInvType fun = std::ref(add);
876    add.state = 5;
877    EXPECT_TRUE(static_cast<bool>(fun));
878    EXPECT_EQ(29, TypeParam::ToThisParam(fun)(7, 8, 9).value);
879    EXPECT_TRUE(static_cast<bool>(fun));
880    EXPECT_EQ(38, TypeParam::ToThisParam(fun)(10, 11, 12).value);
881  }
882  TYPED_TEST_P(AnyInvTestNonRvalue, NonMoveableResultType) {
883  #if ABSL_INTERNAL_CPLUSPLUS_LANG < 201703L
884    GTEST_SKIP() << "Copy/move elision was not standard before C++17";
885  #else
886    struct Result {
887      int x;
888      explicit Result(const int x_in) : x(x_in) {}
889      Result(Result&&) = delete;
890    };
891    static_assert(!std::is_move_constructible<Result>::value, "");
892    static_assert(!std::is_copy_constructible<Result>::value, "");
893    const auto return_17 = []() noexcept { return Result(17); };
894    EXPECT_EQ(17, return_17().x);
895    using UnqualifiedFun =
896        absl::conditional_t<TypeParam::kIsNoexcept, Result() noexcept, Result()>;
897    using Fun =
898        GiveQualifiersToFun<typename TypeParam::Qualifiers, UnqualifiedFun>;
899    AnyInvocable<Fun> any_inv(return_17);
900    EXPECT_EQ(17, any_inv().x);
901  #endif
902  }
903  TYPED_TEST_P(AnyInvTestNonRvalue, ConversionAssignReferenceWrapperEmptyLhs) {
904    using AnyInvType = typename TypeParam::AnyInvType;
905    using AddType = typename TypeParam::AddType;
906    AddType add(4);
907    AnyInvType fun;
908    fun = std::ref(add);
909    add.state = 5;
910    EXPECT_TRUE(
911        (std::is_nothrow_assignable<AnyInvType&,
912                                    std::reference_wrapper<AddType>>::value));
913    EXPECT_TRUE(static_cast<bool>(fun));
914    EXPECT_EQ(29, TypeParam::ToThisParam(fun)(7, 8, 9).value);
915    EXPECT_TRUE(static_cast<bool>(fun));
916    EXPECT_EQ(38, TypeParam::ToThisParam(fun)(10, 11, 12).value);
917  }
918  TYPED_TEST_P(AnyInvTestNonRvalue, ConversionAssignReferenceWrapperNonemptyLhs) {
919    using AnyInvType = typename TypeParam::AnyInvType;
920    using AddType = typename TypeParam::AddType;
921    AddType add(4);
922    AnyInvType fun = &mult_function;
923    fun = std::ref(add);
924    add.state = 5;
925    EXPECT_TRUE(
926        (std::is_nothrow_assignable<AnyInvType&,
927                                    std::reference_wrapper<AddType>>::value));
928    EXPECT_TRUE(static_cast<bool>(fun));
929    EXPECT_EQ(29, TypeParam::ToThisParam(fun)(7, 8, 9).value);
930    EXPECT_TRUE(static_cast<bool>(fun));
931    EXPECT_EQ(38, TypeParam::ToThisParam(fun)(10, 11, 12).value);
932  }
933  template <class T>
934  class AnyInvTestRvalue : public ::testing::Test {};
935  TYPED_TEST_SUITE_P(AnyInvTestRvalue);
936  TYPED_TEST_P(AnyInvTestRvalue, ConversionConstructionReferenceWrapper) {
937    using AnyInvType = typename TypeParam::AnyInvType;
938    using AddType = typename TypeParam::AddType;
939    EXPECT_FALSE((
940        std::is_convertible<std::reference_wrapper<AddType>, AnyInvType>::value));
941  }
942  TYPED_TEST_P(AnyInvTestRvalue, NonMoveableResultType) {
943  #if ABSL_INTERNAL_CPLUSPLUS_LANG < 201703L
944    GTEST_SKIP() << "Copy/move elision was not standard before C++17";
945  #else
946    struct Result {
947      int x;
948      explicit Result(const int x_in) : x(x_in) {}
949      Result(Result&&) = delete;
950    };
951    static_assert(!std::is_move_constructible<Result>::value, "");
952    static_assert(!std::is_copy_constructible<Result>::value, "");
953    const auto return_17 = []() noexcept { return Result(17); };
954    EXPECT_EQ(17, return_17().x);
955    using UnqualifiedFun =
<span onclick='openModal()' class='match'>956        absl::conditional_t<TypeParam::kIsNoexcept, Result() noexcept, Result()>;
957    using Fun =
958        GiveQualifiersToFun<typename TypeParam::Qualifiers, UnqualifiedFun>;
959    EXPECT_EQ(17, AnyInvocable<Fun>(return_17)().x);
</span>960  #endif
961  }
962  TYPED_TEST_P(AnyInvTestRvalue, ConversionAssignReferenceWrapper) {
963    using AnyInvType = typename TypeParam::AnyInvType;
964    using AddType = typename TypeParam::AddType;
965    EXPECT_FALSE((
966        std::is_assignable<AnyInvType&, std::reference_wrapper<AddType>>::value));
967  }
968  TYPED_TEST_P(AnyInvTestRvalue, NonConstCrashesOnSecondCall) {
969    using AnyInvType = typename TypeParam::AnyInvType;
970    using AddType = typename TypeParam::AddType;
971    AnyInvType fun(absl::in_place_type<AddType>, 5);
972    EXPECT_TRUE(static_cast<bool>(fun));
973    std::move(fun)(7, 8, 9);
974    EXPECT_TRUE(static_cast<bool>(fun));  
975  #if !defined(NDEBUG)
976    EXPECT_DEATH_IF_SUPPORTED(std::move(fun)(7, 8, 9), "");
977  #endif
978  }
979  TYPED_TEST_P(AnyInvTestRvalue, QualifierIndependentObjectLifetime) {
980    using AnyInvType = typename TypeParam::AnyInvType;
981    auto refs = std::make_shared<std::nullptr_t>();
982    {
983      AnyInvType fun([refs](auto&&...) noexcept { return 0; });
984      EXPECT_GT(refs.use_count(), 1);
985      std::move(fun)(7, 8, 9);
986      EXPECT_GT(refs.use_count(), 1);
987    }
988    EXPECT_EQ(refs.use_count(), 1);
989  }
990  template <Movable Mov, Destructible Dest, NothrowCall CallExceptionSpec,
991            ObjSize Size, ObjAlign Align>
992  using NonRvalueQualifiedTestParams = ::testing::Types<               
993      TestParams<Mov, Dest, _, CallExceptionSpec, Size, Align>,        
994      TestParams<Mov, Dest, const _, CallExceptionSpec, Size, Align>,  
995      TestParams<Mov, Dest, _&, CallExceptionSpec, Size, Align>,       
996      TestParams<Mov, Dest, const _&, CallExceptionSpec, Size, Align>>;
997  template <Movable Mov, Destructible Dest, NothrowCall CallExceptionSpec,
998            ObjSize Size, ObjAlign Align>
999  using RvalueQualifiedTestParams = ::testing::Types<
1000      TestParams<Mov, Dest, _&&, CallExceptionSpec, Size, Align>,       
1001      TestParams<Mov, Dest, const _&&, CallExceptionSpec, Size, Align>  
1002      >;
1003  using TestParameterListNonRvalueQualifiersNothrowCall =
1004      NonRvalueQualifiedTestParams<Movable::trivial, Destructible::trivial,
1005                                   NothrowCall::yes, ObjSize::small,
1006                                   ObjAlign::normal>;
1007  using TestParameterListRvalueQualifiersNothrowCall =
1008      RvalueQualifiedTestParams<Movable::trivial, Destructible::trivial,
1009                                NothrowCall::yes, ObjSize::small,
1010                                ObjAlign::normal>;
1011  using TestParameterListNonRvalueQualifiersCallMayThrow =
1012      NonRvalueQualifiedTestParams<Movable::trivial, Destructible::trivial,
1013                                   NothrowCall::no, ObjSize::small,
1014                                   ObjAlign::normal>;
1015  using TestParameterListRvalueQualifiersCallMayThrow =
1016      RvalueQualifiedTestParams<Movable::trivial, Destructible::trivial,
1017                                NothrowCall::no, ObjSize::small,
1018                                ObjAlign::normal>;
1019  using TestParameterListRemoteMovable = ::testing::Types<
1020      TestParams<Movable::trivial, Destructible::trivial, _, NothrowCall::no,
1021                 ObjSize::large, ObjAlign::normal>,  
1022      TestParams<Movable::nothrow, Destructible::trivial, _, NothrowCall::no,
1023                 ObjSize::large, ObjAlign::normal>,  
1024      TestParams<Movable::yes, Destructible::trivial, _, NothrowCall::no,
1025                 ObjSize::small, ObjAlign::normal>,  
1026      TestParams<Movable::yes, Destructible::trivial, _, NothrowCall::no,
1027                 ObjSize::large, ObjAlign::normal>,  
1028      TestParams<Movable::trivial, Destructible::nothrow, _, NothrowCall::no,
1029                 ObjSize::large, ObjAlign::normal>,  
1030      TestParams<Movable::nothrow, Destructible::nothrow, _, NothrowCall::no,
1031                 ObjSize::large, ObjAlign::normal>,  
1032      TestParams<Movable::yes, Destructible::nothrow, _, NothrowCall::no,
1033                 ObjSize::small, ObjAlign::normal>,  
1034      TestParams<Movable::yes, Destructible::nothrow, _, NothrowCall::no,
1035                 ObjSize::large, ObjAlign::normal>  
1036  #if ABSL_INTERNAL_CPLUSPLUS_LANG >= 201703L
1037      ,
1038      TestParams<Movable::trivial, Destructible::trivial, _, NothrowCall::no,
1039                 ObjSize::small, ObjAlign::large>,  
1040      TestParams<Movable::nothrow, Destructible::trivial, _, NothrowCall::no,
1041                 ObjSize::small, ObjAlign::large>,  
1042      TestParams<Movable::trivial, Destructible::nothrow, _, NothrowCall::no,
1043                 ObjSize::small, ObjAlign::large>,  
1044      TestParams<Movable::nothrow, Destructible::nothrow, _, NothrowCall::no,
1045                 ObjSize::small, ObjAlign::large>  
1046  #endif
1047      >;
1048  using TestParameterListRemoteNonMovable = ::testing::Types<
1049      TestParams<Movable::no, Destructible::trivial, _, NothrowCall::no,
1050                 ObjSize::small, ObjAlign::normal>,  
1051      TestParams<Movable::no, Destructible::trivial, _, NothrowCall::no,
1052                 ObjSize::large, ObjAlign::normal>,  
1053      TestParams<Movable::no, Destructible::nothrow, _, NothrowCall::no,
1054                 ObjSize::small, ObjAlign::normal>,  
1055      TestParams<Movable::no, Destructible::nothrow, _, NothrowCall::no,
1056                 ObjSize::large, ObjAlign::normal>  
1057      >;
1058  using TestParameterListLocal = ::testing::Types<
1059      TestParams<Movable::trivial, Destructible::trivial, _, NothrowCall::no,
1060                 ObjSize::small, ObjAlign::normal>,  
1061      TestParams<Movable::nothrow, Destructible::trivial, _, NothrowCall::no,
1062                 ObjSize::small, ObjAlign::normal>,  
1063      TestParams<Movable::trivial, Destructible::trivial, _, NothrowCall::no,
1064                 ObjSize::small, ObjAlign::normal>,  
1065      TestParams<Movable::nothrow, Destructible::trivial, _, NothrowCall::no,
1066                 ObjSize::small, ObjAlign::normal>  
1067      >;
1068  REGISTER_TYPED_TEST_SUITE_P(
1069      AnyInvTestBasic, DefaultConstruction, ConstructionNullptr,
1070      ConstructionNullFunctionPtr, ConstructionNullMemberFunctionPtr,
1071      ConstructionNullMemberObjectPtr, ConstructionMemberFunctionPtr,
1072      ConstructionMemberObjectPtr, ConstructionFunctionReferenceDecay,
1073      ConstructionCompatibleAnyInvocableEmpty,
1074      ConstructionCompatibleAnyInvocableNonempty, InPlaceConstruction,
1075      ConversionToBool, Invocation, InPlaceConstructionInitializerList,
1076      InPlaceNullFunPtrConstruction, InPlaceNullFunPtrConstructionValueInit,
1077      InPlaceNullMemFunPtrConstruction, InPlaceNullMemFunPtrConstructionValueInit,
1078      InPlaceNullMemObjPtrConstruction, InPlaceNullMemObjPtrConstructionValueInit,
1079      InPlaceVoidCovarianceConstruction, MoveConstructionFromEmpty,
1080      MoveConstructionFromNonEmpty, ComparisonWithNullptrEmpty,
1081      ComparisonWithNullptrNonempty, ResultType);
1082  INSTANTIATE_TYPED_TEST_SUITE_P(
1083      NonRvalueCallMayThrow, AnyInvTestBasic,
1084      TestParameterListNonRvalueQualifiersCallMayThrow);
1085  INSTANTIATE_TYPED_TEST_SUITE_P(RvalueCallMayThrow, AnyInvTestBasic,
1086                                 TestParameterListRvalueQualifiersCallMayThrow);
1087  INSTANTIATE_TYPED_TEST_SUITE_P(RemoteMovable, AnyInvTestBasic,
1088                                 TestParameterListRemoteMovable);
1089  INSTANTIATE_TYPED_TEST_SUITE_P(RemoteNonMovable, AnyInvTestBasic,
1090                                 TestParameterListRemoteNonMovable);
1091  INSTANTIATE_TYPED_TEST_SUITE_P(Local, AnyInvTestBasic, TestParameterListLocal);
1092  INSTANTIATE_TYPED_TEST_SUITE_P(NonRvalueCallNothrow, AnyInvTestBasic,
1093                                 TestParameterListNonRvalueQualifiersNothrowCall);
1094  INSTANTIATE_TYPED_TEST_SUITE_P(CallNothrowRvalue, AnyInvTestBasic,
1095                                 TestParameterListRvalueQualifiersNothrowCall);
1096  REGISTER_TYPED_TEST_SUITE_P(
1097      AnyInvTestCombinatoric, MoveAssignEmptyEmptyLhsRhs,
1098      MoveAssignEmptyLhsNonemptyRhs, MoveAssignNonemptyEmptyLhsRhs,
1099      MoveAssignNonemptyLhsNonemptyRhs, SelfMoveAssignEmpty,
1100      SelfMoveAssignNonempty, AssignNullptrEmptyLhs,
1101      AssignNullFunctionPtrEmptyLhs, AssignNullMemberFunctionPtrEmptyLhs,
1102      AssignNullMemberObjectPtrEmptyLhs, AssignMemberFunctionPtrEmptyLhs,
1103      AssignMemberObjectPtrEmptyLhs, AssignFunctionReferenceDecayEmptyLhs,
1104      AssignCompatibleAnyInvocableEmptyLhsEmptyRhs,
1105      AssignCompatibleAnyInvocableEmptyLhsNonemptyRhs, AssignNullptrNonemptyLhs,
1106      AssignNullFunctionPtrNonemptyLhs, AssignNullMemberFunctionPtrNonemptyLhs,
1107      AssignNullMemberObjectPtrNonemptyLhs, AssignMemberFunctionPtrNonemptyLhs,
1108      AssignMemberObjectPtrNonemptyLhs, AssignFunctionReferenceDecayNonemptyLhs,
1109      AssignCompatibleAnyInvocableNonemptyLhsEmptyRhs,
1110      AssignCompatibleAnyInvocableNonemptyLhsNonemptyRhs, SwapEmptyLhsEmptyRhs,
1111      SwapEmptyLhsNonemptyRhs, SwapNonemptyLhsEmptyRhs,
1112      SwapNonemptyLhsNonemptyRhs);
1113  INSTANTIATE_TYPED_TEST_SUITE_P(
1114      NonRvalueCallMayThrow, AnyInvTestCombinatoric,
1115      TestParameterListNonRvalueQualifiersCallMayThrow);
1116  INSTANTIATE_TYPED_TEST_SUITE_P(RvalueCallMayThrow, AnyInvTestCombinatoric,
1117                                 TestParameterListRvalueQualifiersCallMayThrow);
1118  INSTANTIATE_TYPED_TEST_SUITE_P(RemoteMovable, AnyInvTestCombinatoric,
1119                                 TestParameterListRemoteMovable);
1120  INSTANTIATE_TYPED_TEST_SUITE_P(RemoteNonMovable, AnyInvTestCombinatoric,
1121                                 TestParameterListRemoteNonMovable);
1122  INSTANTIATE_TYPED_TEST_SUITE_P(Local, AnyInvTestCombinatoric,
1123                                 TestParameterListLocal);
1124  INSTANTIATE_TYPED_TEST_SUITE_P(NonRvalueCallNothrow, AnyInvTestCombinatoric,
1125                                 TestParameterListNonRvalueQualifiersNothrowCall);
1126  INSTANTIATE_TYPED_TEST_SUITE_P(RvalueCallNothrow, AnyInvTestCombinatoric,
1127                                 TestParameterListRvalueQualifiersNothrowCall);
1128  REGISTER_TYPED_TEST_SUITE_P(AnyInvTestMovable,
1129                              ConversionConstructionUserDefinedType,
1130                              ConversionConstructionVoidCovariance,
1131                              ConversionAssignUserDefinedTypeEmptyLhs,
1132                              ConversionAssignUserDefinedTypeNonemptyLhs,
1133                              ConversionAssignVoidCovariance);
1134  INSTANTIATE_TYPED_TEST_SUITE_P(
1135      NonRvalueCallMayThrow, AnyInvTestMovable,
1136      TestParameterListNonRvalueQualifiersCallMayThrow);
1137  INSTANTIATE_TYPED_TEST_SUITE_P(RvalueCallMayThrow, AnyInvTestMovable,
1138                                 TestParameterListRvalueQualifiersCallMayThrow);
1139  INSTANTIATE_TYPED_TEST_SUITE_P(RemoteMovable, AnyInvTestMovable,
1140                                 TestParameterListRemoteMovable);
1141  INSTANTIATE_TYPED_TEST_SUITE_P(Local, AnyInvTestMovable,
1142                                 TestParameterListLocal);
1143  INSTANTIATE_TYPED_TEST_SUITE_P(NonRvalueCallNothrow, AnyInvTestMovable,
1144                                 TestParameterListNonRvalueQualifiersNothrowCall);
1145  INSTANTIATE_TYPED_TEST_SUITE_P(RvalueCallNothrow, AnyInvTestMovable,
1146                                 TestParameterListRvalueQualifiersNothrowCall);
1147  REGISTER_TYPED_TEST_SUITE_P(AnyInvTestNoexceptFalse,
1148                              ConversionConstructionConstraints,
1149                              ConversionAssignConstraints);
1150  INSTANTIATE_TYPED_TEST_SUITE_P(
1151      NonRvalueCallMayThrow, AnyInvTestNoexceptFalse,
1152      TestParameterListNonRvalueQualifiersCallMayThrow);
1153  INSTANTIATE_TYPED_TEST_SUITE_P(RvalueCallMayThrow, AnyInvTestNoexceptFalse,
1154                                 TestParameterListRvalueQualifiersCallMayThrow);
1155  INSTANTIATE_TYPED_TEST_SUITE_P(RemoteMovable, AnyInvTestNoexceptFalse,
1156                                 TestParameterListRemoteMovable);
1157  INSTANTIATE_TYPED_TEST_SUITE_P(RemoteNonMovable, AnyInvTestNoexceptFalse,
1158                                 TestParameterListRemoteNonMovable);
1159  INSTANTIATE_TYPED_TEST_SUITE_P(Local, AnyInvTestNoexceptFalse,
1160                                 TestParameterListLocal);
1161  REGISTER_TYPED_TEST_SUITE_P(AnyInvTestNoexceptTrue,
1162                              ConversionConstructionConstraints,
1163                              ConversionAssignConstraints);
1164  INSTANTIATE_TYPED_TEST_SUITE_P(NonRvalueCallNothrow, AnyInvTestNoexceptTrue,
1165                                 TestParameterListNonRvalueQualifiersNothrowCall);
1166  INSTANTIATE_TYPED_TEST_SUITE_P(RvalueCallNothrow, AnyInvTestNoexceptTrue,
1167                                 TestParameterListRvalueQualifiersNothrowCall);
1168  REGISTER_TYPED_TEST_SUITE_P(AnyInvTestNonRvalue,
1169                              ConversionConstructionReferenceWrapper,
1170                              NonMoveableResultType,
1171                              ConversionAssignReferenceWrapperEmptyLhs,
1172                              ConversionAssignReferenceWrapperNonemptyLhs);
1173  INSTANTIATE_TYPED_TEST_SUITE_P(
1174      NonRvalueCallMayThrow, AnyInvTestNonRvalue,
1175      TestParameterListNonRvalueQualifiersCallMayThrow);
1176  INSTANTIATE_TYPED_TEST_SUITE_P(RemoteMovable, AnyInvTestNonRvalue,
1177                                 TestParameterListRemoteMovable);
1178  INSTANTIATE_TYPED_TEST_SUITE_P(RemoteNonMovable, AnyInvTestNonRvalue,
1179                                 TestParameterListRemoteNonMovable);
1180  INSTANTIATE_TYPED_TEST_SUITE_P(Local, AnyInvTestNonRvalue,
1181                                 TestParameterListLocal);
1182  INSTANTIATE_TYPED_TEST_SUITE_P(NonRvalueCallNothrow, AnyInvTestNonRvalue,
1183                                 TestParameterListNonRvalueQualifiersNothrowCall);
1184  REGISTER_TYPED_TEST_SUITE_P(AnyInvTestRvalue,
1185                              ConversionConstructionReferenceWrapper,
1186                              NonMoveableResultType,
1187                              ConversionAssignReferenceWrapper,
1188                              NonConstCrashesOnSecondCall,
1189                              QualifierIndependentObjectLifetime);
1190  INSTANTIATE_TYPED_TEST_SUITE_P(RvalueCallMayThrow, AnyInvTestRvalue,
1191                                 TestParameterListRvalueQualifiersCallMayThrow);
1192  INSTANTIATE_TYPED_TEST_SUITE_P(CallNothrowRvalue, AnyInvTestRvalue,
1193                                 TestParameterListRvalueQualifiersNothrowCall);
1194  static_assert(
1195      std::is_convertible<void (*)(), absl::AnyInvocable<void() &&>>::value, "");
1196  static_assert(!std::is_convertible<void*, absl::AnyInvocable<void() &&>>::value,
1197                "");
1198  #undef ABSL_INTERNAL_NOEXCEPT_SPEC
1199  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-any_invocable_test.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-any_invocable_test.cc</div>
                </div>
                <div class="column column_space"><pre><code>896        absl::conditional_t<TypeParam::kIsNoexcept, Result() noexcept, Result()>;
897    using Fun =
898        GiveQualifiersToFun<typename TypeParam::Qualifiers, UnqualifiedFun>;
899    AnyInvocable<Fun> any_inv(return_17);
</pre></code></div>
                <div class="column column_space"><pre><code>956        absl::conditional_t<TypeParam::kIsNoexcept, Result() noexcept, Result()>;
957    using Fun =
958        GiveQualifiersToFun<typename TypeParam::Qualifiers, UnqualifiedFun>;
959    EXPECT_EQ(17, AnyInvocable<Fun>(return_17)().x);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    