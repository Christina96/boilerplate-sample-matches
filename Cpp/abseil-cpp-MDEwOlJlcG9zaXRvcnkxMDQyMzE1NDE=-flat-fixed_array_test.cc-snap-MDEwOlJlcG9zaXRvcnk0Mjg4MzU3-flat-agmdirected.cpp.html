
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 8.110599078341014%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-fixed_array_test.cc</h3>
            <pre><code>1  #include "absl/container/fixed_array.h"
2  #include <stdio.h>
3  #include <cstring>
4  #include <list>
5  #include <memory>
6  #include <numeric>
7  #include <scoped_allocator>
8  #include <stdexcept>
9  #include <string>
10  #include <vector>
11  #include "gmock/gmock.h"
12  #include "gtest/gtest.h"
13  #include "absl/base/config.h"
14  #include "absl/base/internal/exception_testing.h"
15  #include "absl/base/options.h"
16  #include "absl/container/internal/counting_allocator.h"
17  #include "absl/hash/hash_testing.h"
18  #include "absl/memory/memory.h"
19  using ::testing::ElementsAreArray;
20  namespace {
21  template <typename ArrayType>
22  static bool IsOnStack(const ArrayType& a) {
23    return a.size() <= ArrayType::inline_elements;
24  }
25  class ConstructionTester {
26   public:
27    ConstructionTester() : self_ptr_(this), value_(0) { constructions++; }
28    ~ConstructionTester() {
29      assert(self_ptr_ == this);
30      self_ptr_ = nullptr;
31      destructions++;
32    }
33    static int constructions;
34    static int destructions;
35    void CheckConstructed() { assert(self_ptr_ == this); }
36    void set(int value) { value_ = value; }
37    int get() { return value_; }
38   private:
39    ConstructionTester* self_ptr_;
40    int value_;
41  };
42  int ConstructionTester::constructions = 0;
43  int ConstructionTester::destructions = 0;
44  class ThreeInts {
45   public:
46    ThreeInts() {
47      x_ = counter;
48      y_ = counter;
49      z_ = counter;
50      ++counter;
51    }
52    static int counter;
53    int x_, y_, z_;
54  };
55  int ThreeInts::counter = 0;
56  TEST(FixedArrayTest, CopyCtor) {
57    absl::FixedArray<int, 10> on_stack(5);
58    std::iota(on_stack.begin(), on_stack.end(), 0);
59    absl::FixedArray<int, 10> stack_copy = on_stack;
60    EXPECT_THAT(stack_copy, ElementsAreArray(on_stack));
61    EXPECT_TRUE(IsOnStack(stack_copy));
62    absl::FixedArray<int, 10> allocated(15);
63    std::iota(allocated.begin(), allocated.end(), 0);
64    absl::FixedArray<int, 10> alloced_copy = allocated;
65    EXPECT_THAT(alloced_copy, ElementsAreArray(allocated));
66    EXPECT_FALSE(IsOnStack(alloced_copy));
67  }
68  TEST(FixedArrayTest, MoveCtor) {
69    absl::FixedArray<std::unique_ptr<int>, 10> on_stack(5);
70    for (int i = 0; i < 5; ++i) {
71      on_stack[i] = absl::make_unique<int>(i);
72    }
73    absl::FixedArray<std::unique_ptr<int>, 10> stack_copy = std::move(on_stack);
74    for (int i = 0; i < 5; ++i) EXPECT_EQ(*(stack_copy[i]), i);
75    EXPECT_EQ(stack_copy.size(), on_stack.size());
76    absl::FixedArray<std::unique_ptr<int>, 10> allocated(15);
77    for (int i = 0; i < 15; ++i) {
78      allocated[i] = absl::make_unique<int>(i);
79    }
80    absl::FixedArray<std::unique_ptr<int>, 10> alloced_copy =
81        std::move(allocated);
82    for (int i = 0; i < 15; ++i) EXPECT_EQ(*(alloced_copy[i]), i);
83    EXPECT_EQ(allocated.size(), alloced_copy.size());
84  }
85  TEST(FixedArrayTest, SmallObjects) {
86    {
87      absl::FixedArray<int> array(4);
88      EXPECT_TRUE(IsOnStack(array));
89    }
90    {
91      absl::FixedArray<int> array(1048576);
92      EXPECT_FALSE(IsOnStack(array));
93    }
94    {
95      absl::FixedArray<int, 100> array(100);
96      EXPECT_TRUE(IsOnStack(array));
97    }
98    {
99      absl::FixedArray<int, 100> array(101);
100      EXPECT_FALSE(IsOnStack(array));
101    }
102    {
103      absl::FixedArray<int> array1(0);
104      absl::FixedArray<char> array2(0);
105      EXPECT_LE(sizeof(array1), sizeof(array2) + 100);
106      EXPECT_LE(sizeof(array2), sizeof(array1) + 100);
107    }
108    {
109      absl::FixedArray<std::vector<int>> array(2);
110      EXPECT_EQ(0, array[0].size());
111      EXPECT_EQ(0, array[1].size());
112    }
113    {
114      ThreeInts::counter = 1;
115      absl::FixedArray<ThreeInts> array(2);
116      EXPECT_EQ(1, array[0].x_);
117      EXPECT_EQ(1, array[0].y_);
118      EXPECT_EQ(1, array[0].z_);
119      EXPECT_EQ(2, array[1].x_);
120      EXPECT_EQ(2, array[1].y_);
121      EXPECT_EQ(2, array[1].z_);
122    }
123  }
124  TEST(FixedArrayTest, AtThrows) {
125    absl::FixedArray<int> a = {1, 2, 3};
126    EXPECT_EQ(a.at(2), 3);
127    ABSL_BASE_INTERNAL_EXPECT_FAIL(a.at(3), std::out_of_range,
128                                   "failed bounds check");
129  }
130  TEST(FixedArrayTest, Hardened) {
131  #if !defined(NDEBUG) || ABSL_OPTION_HARDENED
132    absl::FixedArray<int> a = {1, 2, 3};
133    EXPECT_EQ(a[2], 3);
134    EXPECT_DEATH_IF_SUPPORTED(a[3], "");
135    EXPECT_DEATH_IF_SUPPORTED(a[-1], "");
136    absl::FixedArray<int> empty(0);
137    EXPECT_DEATH_IF_SUPPORTED(empty[0], "");
138    EXPECT_DEATH_IF_SUPPORTED(empty[-1], "");
139    EXPECT_DEATH_IF_SUPPORTED(empty.front(), "");
140    EXPECT_DEATH_IF_SUPPORTED(empty.back(), "");
141  #endif
142  }
143  TEST(FixedArrayRelationalsTest, EqualArrays) {
144    for (int i = 0; i < 10; ++i) {
145      absl::FixedArray<int, 5> a1(i);
146      std::iota(a1.begin(), a1.end(), 0);
147      absl::FixedArray<int, 5> a2(a1.begin(), a1.end());
148      EXPECT_TRUE(a1 == a2);
149      EXPECT_FALSE(a1 != a2);
150      EXPECT_TRUE(a2 == a1);
151      EXPECT_FALSE(a2 != a1);
152      EXPECT_FALSE(a1 < a2);
153      EXPECT_FALSE(a1 > a2);
154      EXPECT_FALSE(a2 < a1);
155      EXPECT_FALSE(a2 > a1);
156      EXPECT_TRUE(a1 <= a2);
157      EXPECT_TRUE(a1 >= a2);
158      EXPECT_TRUE(a2 <= a1);
159      EXPECT_TRUE(a2 >= a1);
<span onclick='openModal()' class='match'>160    }
161  }
162  TEST(FixedArrayRelationalsTest, UnequalArrays) {
163    for (int i = 1; i < 10; ++i) {
164      absl::FixedArray<int, 5> a1(i);
</span>165      std::iota(a1.begin(), a1.end(), 0);
166      absl::FixedArray<int, 5> a2(a1.begin(), a1.end());
167      --a2[i / 2];
168      EXPECT_FALSE(a1 == a2);
169      EXPECT_TRUE(a1 != a2);
170      EXPECT_FALSE(a2 == a1);
171      EXPECT_TRUE(a2 != a1);
172      EXPECT_FALSE(a1 < a2);
173      EXPECT_TRUE(a1 > a2);
174      EXPECT_TRUE(a2 < a1);
175      EXPECT_FALSE(a2 > a1);
176      EXPECT_FALSE(a1 <= a2);
177      EXPECT_TRUE(a1 >= a2);
178      EXPECT_TRUE(a2 <= a1);
179      EXPECT_FALSE(a2 >= a1);
180    }
181  }
182  template <int stack_elements>
183  static void TestArray(int n) {
184    SCOPED_TRACE(n);
185    SCOPED_TRACE(stack_elements);
186    ConstructionTester::constructions = 0;
187    ConstructionTester::destructions = 0;
188    {
189      absl::FixedArray<ConstructionTester, stack_elements> array(n);
190      EXPECT_THAT(array.size(), n);
191      EXPECT_THAT(array.memsize(), sizeof(ConstructionTester) * n);
192      EXPECT_THAT(array.begin() + n, array.end());
193      for (int i = 0; i < n; i++) {
194        array[i].CheckConstructed();
195      }
196      EXPECT_THAT(ConstructionTester::constructions, n);
197      for (int i = 0; i < n; i++) {
198        array[i].set(i);
199      }
200      for (int i = 0; i < n; i++) {
201        EXPECT_THAT(array[i].get(), i);
202        EXPECT_THAT(array.data()[i].get(), i);
203      }
204      for (int i = 0; i < n; i++) {
205        array.data()[i].set(i + 1);
206      }
207      for (int i = 0; i < n; i++) {
208        EXPECT_THAT(array[i].get(), i + 1);
209        EXPECT_THAT(array.data()[i].get(), i + 1);
210      }
211    }  
212    EXPECT_EQ(ConstructionTester::constructions,
213              ConstructionTester::destructions);
214  }
215  template <int elements_per_inner_array, int inline_elements>
216  static void TestArrayOfArrays(int n) {
217    SCOPED_TRACE(n);
218    SCOPED_TRACE(inline_elements);
219    SCOPED_TRACE(elements_per_inner_array);
220    ConstructionTester::constructions = 0;
221    ConstructionTester::destructions = 0;
222    {
223      using InnerArray = ConstructionTester[elements_per_inner_array];
224      auto array_ptr =
225          absl::make_unique<absl::FixedArray<InnerArray, inline_elements>>(n);
226      auto& array = *array_ptr;
227      ASSERT_EQ(array.size(), n);
228      ASSERT_EQ(array.memsize(),
229                sizeof(ConstructionTester) * elements_per_inner_array * n);
230      ASSERT_EQ(array.begin() + n, array.end());
231      for (int i = 0; i < n; i++) {
232        for (int j = 0; j < elements_per_inner_array; j++) {
233          (array[i])[j].CheckConstructed();
234        }
235      }
236      ASSERT_EQ(ConstructionTester::constructions, n * elements_per_inner_array);
237      for (int i = 0; i < n; i++) {
238        for (int j = 0; j < elements_per_inner_array; j++) {
239          (array[i])[j].set(i * elements_per_inner_array + j);
240        }
241      }
242      for (int i = 0; i < n; i++) {
243        for (int j = 0; j < elements_per_inner_array; j++) {
244          ASSERT_EQ((array[i])[j].get(), i * elements_per_inner_array + j);
245          ASSERT_EQ((array.data()[i])[j].get(), i * elements_per_inner_array + j);
246        }
247      }
248      for (int i = 0; i < n; i++) {
249        for (int j = 0; j < elements_per_inner_array; j++) {
250          (array.data()[i])[j].set((i + 1) * elements_per_inner_array + j);
251        }
252      }
253      for (int i = 0; i < n; i++) {
254        for (int j = 0; j < elements_per_inner_array; j++) {
255          ASSERT_EQ((array[i])[j].get(), (i + 1) * elements_per_inner_array + j);
256          ASSERT_EQ((array.data()[i])[j].get(),
257                    (i + 1) * elements_per_inner_array + j);
258        }
259      }
260    }  
261    EXPECT_EQ(ConstructionTester::constructions,
262              ConstructionTester::destructions);
263  }
264  TEST(IteratorConstructorTest, NonInline) {
265    int const kInput[] = {2, 3, 5, 7, 11, 13, 17};
266    absl::FixedArray<int, ABSL_ARRAYSIZE(kInput) - 1> const fixed(
267        kInput, kInput + ABSL_ARRAYSIZE(kInput));
268    ASSERT_EQ(ABSL_ARRAYSIZE(kInput), fixed.size());
269    for (size_t i = 0; i < ABSL_ARRAYSIZE(kInput); ++i) {
270      ASSERT_EQ(kInput[i], fixed[i]);
271    }
272  }
273  TEST(IteratorConstructorTest, Inline) {
274    int const kInput[] = {2, 3, 5, 7, 11, 13, 17};
275    absl::FixedArray<int, ABSL_ARRAYSIZE(kInput)> const fixed(
276        kInput, kInput + ABSL_ARRAYSIZE(kInput));
277    ASSERT_EQ(ABSL_ARRAYSIZE(kInput), fixed.size());
278    for (size_t i = 0; i < ABSL_ARRAYSIZE(kInput); ++i) {
279      ASSERT_EQ(kInput[i], fixed[i]);
280    }
281  }
282  TEST(IteratorConstructorTest, NonPod) {
283    char const* kInput[] = {"red",  "orange", "yellow", "green",
284                            "blue", "indigo", "violet"};
285    absl::FixedArray<std::string> const fixed(kInput,
286                                              kInput + ABSL_ARRAYSIZE(kInput));
287    ASSERT_EQ(ABSL_ARRAYSIZE(kInput), fixed.size());
288    for (size_t i = 0; i < ABSL_ARRAYSIZE(kInput); ++i) {
289      ASSERT_EQ(kInput[i], fixed[i]);
290    }
291  }
292  TEST(IteratorConstructorTest, FromEmptyVector) {
293    std::vector<int> const empty;
294    absl::FixedArray<int> const fixed(empty.begin(), empty.end());
295    EXPECT_EQ(0, fixed.size());
296    EXPECT_EQ(empty.size(), fixed.size());
297  }
298  TEST(IteratorConstructorTest, FromNonEmptyVector) {
299    int const kInput[] = {2, 3, 5, 7, 11, 13, 17};
300    std::vector<int> const items(kInput, kInput + ABSL_ARRAYSIZE(kInput));
301    absl::FixedArray<int> const fixed(items.begin(), items.end());
302    ASSERT_EQ(items.size(), fixed.size());
303    for (size_t i = 0; i < items.size(); ++i) {
304      ASSERT_EQ(items[i], fixed[i]);
305    }
306  }
307  TEST(IteratorConstructorTest, FromBidirectionalIteratorRange) {
308    int const kInput[] = {2, 3, 5, 7, 11, 13, 17};
309    std::list<int> const items(kInput, kInput + ABSL_ARRAYSIZE(kInput));
310    absl::FixedArray<int> const fixed(items.begin(), items.end());
311    EXPECT_THAT(fixed, testing::ElementsAreArray(kInput));
312  }
313  TEST(InitListConstructorTest, InitListConstruction) {
314    absl::FixedArray<int> fixed = {1, 2, 3};
315    EXPECT_THAT(fixed, testing::ElementsAreArray({1, 2, 3}));
316  }
317  TEST(FillConstructorTest, NonEmptyArrays) {
318    absl::FixedArray<int> stack_array(4, 1);
319    EXPECT_THAT(stack_array, testing::ElementsAreArray({1, 1, 1, 1}));
320    absl::FixedArray<int, 0> heap_array(4, 1);
321    EXPECT_THAT(stack_array, testing::ElementsAreArray({1, 1, 1, 1}));
322  }
323  TEST(FillConstructorTest, EmptyArray) {
324    absl::FixedArray<int> empty_fill(0, 1);
325    absl::FixedArray<int> empty_size(0);
326    EXPECT_EQ(empty_fill, empty_size);
327  }
328  TEST(FillConstructorTest, NotTriviallyCopyable) {
329    std::string str = "abcd";
330    absl::FixedArray<std::string> strings = {str, str, str, str};
331    absl::FixedArray<std::string> array(4, str);
332    EXPECT_EQ(array, strings);
333  }
334  TEST(FillConstructorTest, Disambiguation) {
335    absl::FixedArray<size_t> a(1, 2);
336    EXPECT_THAT(a, testing::ElementsAre(2));
337  }
338  TEST(FixedArrayTest, ManySizedArrays) {
339    std::vector<int> sizes;
340    for (int i = 1; i < 100; i++) sizes.push_back(i);
341    for (int i = 100; i <= 1000; i += 100) sizes.push_back(i);
342    for (int n : sizes) {
343      TestArray<0>(n);
344      TestArray<1>(n);
345      TestArray<64>(n);
346      TestArray<1000>(n);
347    }
348  }
349  TEST(FixedArrayTest, ManySizedArraysOfArraysOf1) {
350    for (int n = 1; n < 1000; n++) {
351      ASSERT_NO_FATAL_FAILURE((TestArrayOfArrays<1, 0>(n)));
352      ASSERT_NO_FATAL_FAILURE((TestArrayOfArrays<1, 1>(n)));
353      ASSERT_NO_FATAL_FAILURE((TestArrayOfArrays<1, 64>(n)));
354      ASSERT_NO_FATAL_FAILURE((TestArrayOfArrays<1, 1000>(n)));
355    }
356  }
357  TEST(FixedArrayTest, ManySizedArraysOfArraysOf2) {
358    for (int n = 1; n < 1000; n++) {
359      TestArrayOfArrays<2, 0>(n);
360      TestArrayOfArrays<2, 1>(n);
361      TestArrayOfArrays<2, 64>(n);
362      TestArrayOfArrays<2, 1000>(n);
363    }
364  }
365  TEST(FixedArrayTest, AvoidParanoidDiagnostics) {
366    absl::FixedArray<char, 32> buf(32);
367    sprintf(buf.data(), "foo");  
368  }
369  TEST(FixedArrayTest, TooBigInlinedSpace) {
370    struct TooBig {
371      char c[1 << 20];
372    };  
373    struct Data {
374      TooBig* p;
375      size_t size;
376    };
377    static_assert(sizeof(absl::FixedArray<TooBig, 0>) == sizeof(Data),
378                  "0-sized absl::FixedArray should have same size as Data.");
379    static_assert(alignof(absl::FixedArray<TooBig, 0>) == alignof(Data),
380                  "0-sized absl::FixedArray should have same alignment as Data.");
381    static_assert(sizeof(absl::FixedArray<TooBig>) == sizeof(Data),
382                  "default-sized absl::FixedArray should have same size as Data");
383    static_assert(
384        alignof(absl::FixedArray<TooBig>) == alignof(Data),
385        "default-sized absl::FixedArray should have same alignment as Data.");
386  }
387  struct PickyDelete {
388    PickyDelete() {}
389    ~PickyDelete() {}
390    void operator delete(void* p) {
391      EXPECT_TRUE(false) << __FUNCTION__;
392      ::operator delete(p);
393    }
394    void operator delete[](void* p) {
395      EXPECT_TRUE(false) << __FUNCTION__;
396      ::operator delete[](p);
397    }
398  };
399  TEST(FixedArrayTest, UsesGlobalAlloc) { absl::FixedArray<PickyDelete, 0> a(5); }
400  TEST(FixedArrayTest, Data) {
401    static const int kInput[] = {2, 3, 5, 7, 11, 13, 17};
402    absl::FixedArray<int> fa(std::begin(kInput), std::end(kInput));
403    EXPECT_EQ(fa.data(), &*fa.begin());
404    EXPECT_EQ(fa.data(), &fa[0]);
405    const absl::FixedArray<int>& cfa = fa;
406    EXPECT_EQ(cfa.data(), &*cfa.begin());
407    EXPECT_EQ(cfa.data(), &cfa[0]);
408  }
409  TEST(FixedArrayTest, Empty) {
410    absl::FixedArray<int> empty(0);
411    absl::FixedArray<int> inline_filled(1);
412    absl::FixedArray<int, 0> heap_filled(1);
413    EXPECT_TRUE(empty.empty());
414    EXPECT_FALSE(inline_filled.empty());
415    EXPECT_FALSE(heap_filled.empty());
416  }
417  TEST(FixedArrayTest, FrontAndBack) {
418    absl::FixedArray<int, 3 * sizeof(int)> inlined = {1, 2, 3};
419    EXPECT_EQ(inlined.front(), 1);
420    EXPECT_EQ(inlined.back(), 3);
421    absl::FixedArray<int, 0> allocated = {1, 2, 3};
422    EXPECT_EQ(allocated.front(), 1);
423    EXPECT_EQ(allocated.back(), 3);
424    absl::FixedArray<int> one_element = {1};
425    EXPECT_EQ(one_element.front(), one_element.back());
426  }
427  TEST(FixedArrayTest, ReverseIteratorInlined) {
428    absl::FixedArray<int, 5 * sizeof(int)> a = {0, 1, 2, 3, 4};
429    int counter = 5;
430    for (absl::FixedArray<int>::reverse_iterator iter = a.rbegin();
431         iter != a.rend(); ++iter) {
432      counter--;
433      EXPECT_EQ(counter, *iter);
434    }
435    EXPECT_EQ(counter, 0);
436    counter = 5;
437    for (absl::FixedArray<int>::const_reverse_iterator iter = a.rbegin();
438         iter != a.rend(); ++iter) {
439      counter--;
440      EXPECT_EQ(counter, *iter);
441    }
442    EXPECT_EQ(counter, 0);
443    counter = 5;
444    for (auto iter = a.crbegin(); iter != a.crend(); ++iter) {
445      counter--;
446      EXPECT_EQ(counter, *iter);
447    }
448    EXPECT_EQ(counter, 0);
449  }
450  TEST(FixedArrayTest, ReverseIteratorAllocated) {
451    absl::FixedArray<int, 0> a = {0, 1, 2, 3, 4};
452    int counter = 5;
453    for (absl::FixedArray<int>::reverse_iterator iter = a.rbegin();
454         iter != a.rend(); ++iter) {
455      counter--;
456      EXPECT_EQ(counter, *iter);
457    }
458    EXPECT_EQ(counter, 0);
459    counter = 5;
460    for (absl::FixedArray<int>::const_reverse_iterator iter = a.rbegin();
461         iter != a.rend(); ++iter) {
462      counter--;
463      EXPECT_EQ(counter, *iter);
464    }
465    EXPECT_EQ(counter, 0);
466    counter = 5;
467    for (auto iter = a.crbegin(); iter != a.crend(); ++iter) {
468      counter--;
469      EXPECT_EQ(counter, *iter);
470    }
471    EXPECT_EQ(counter, 0);
472  }
473  TEST(FixedArrayTest, Fill) {
474    absl::FixedArray<int, 5 * sizeof(int)> inlined(5);
475    int fill_val = 42;
476    inlined.fill(fill_val);
477    for (int i : inlined) EXPECT_EQ(i, fill_val);
478    absl::FixedArray<int, 0> allocated(5);
479    allocated.fill(fill_val);
480    for (int i : allocated) EXPECT_EQ(i, fill_val);
481    absl::FixedArray<int> empty(0);
482    empty.fill(fill_val);
483  }
484  #ifndef __GNUC__
485  TEST(FixedArrayTest, DefaultCtorDoesNotValueInit) {
486    using T = char;
487    constexpr auto capacity = 10;
488    using FixedArrType = absl::FixedArray<T, capacity>;
489    constexpr auto scrubbed_bits = 0x95;
490    constexpr auto length = capacity / 2;
491    alignas(FixedArrType) unsigned char buff[sizeof(FixedArrType)];
492    std::memset(std::addressof(buff), scrubbed_bits, sizeof(FixedArrType));
493    FixedArrType* arr =
494        ::new (static_cast<void*>(std::addressof(buff))) FixedArrType(length);
495    EXPECT_THAT(*arr, testing::Each(scrubbed_bits));
496    arr->~FixedArrType();
497  }
498  #endif  
499  TEST(AllocatorSupportTest, CountInlineAllocations) {
500    constexpr size_t inlined_size = 4;
501    using Alloc = absl::container_internal::CountingAllocator<int>;
502    using AllocFxdArr = absl::FixedArray<int, inlined_size, Alloc>;
503    int64_t allocated = 0;
504    int64_t active_instances = 0;
505    {
506      const int ia[] = {0, 1, 2, 3, 4, 5, 6, 7};
507      Alloc alloc(&allocated, &active_instances);
508      AllocFxdArr arr(ia, ia + inlined_size, alloc);
509      static_cast<void>(arr);
510    }
511    EXPECT_EQ(allocated, 0);
512    EXPECT_EQ(active_instances, 0);
513  }
514  TEST(AllocatorSupportTest, CountOutoflineAllocations) {
515    constexpr size_t inlined_size = 4;
516    using Alloc = absl::container_internal::CountingAllocator<int>;
517    using AllocFxdArr = absl::FixedArray<int, inlined_size, Alloc>;
518    int64_t allocated = 0;
519    int64_t active_instances = 0;
520    {
521      const int ia[] = {0, 1, 2, 3, 4, 5, 6, 7};
522      Alloc alloc(&allocated, &active_instances);
523      AllocFxdArr arr(ia, ia + ABSL_ARRAYSIZE(ia), alloc);
524      EXPECT_EQ(allocated, arr.size() * sizeof(int));
525      static_cast<void>(arr);
526    }
527    EXPECT_EQ(active_instances, 0);
528  }
529  TEST(AllocatorSupportTest, CountCopyInlineAllocations) {
530    constexpr size_t inlined_size = 4;
531    using Alloc = absl::container_internal::CountingAllocator<int>;
532    using AllocFxdArr = absl::FixedArray<int, inlined_size, Alloc>;
533    int64_t allocated1 = 0;
534    int64_t allocated2 = 0;
535    int64_t active_instances = 0;
536    Alloc alloc(&allocated1, &active_instances);
537    Alloc alloc2(&allocated2, &active_instances);
538    {
539      int initial_value = 1;
540      AllocFxdArr arr1(inlined_size / 2, initial_value, alloc);
541      EXPECT_EQ(allocated1, 0);
542      AllocFxdArr arr2(arr1, alloc2);
543      EXPECT_EQ(allocated2, 0);
544      static_cast<void>(arr1);
545      static_cast<void>(arr2);
546    }
547    EXPECT_EQ(active_instances, 0);
548  }
549  TEST(AllocatorSupportTest, CountCopyOutoflineAllocations) {
550    constexpr size_t inlined_size = 4;
551    using Alloc = absl::container_internal::CountingAllocator<int>;
552    using AllocFxdArr = absl::FixedArray<int, inlined_size, Alloc>;
553    int64_t allocated1 = 0;
554    int64_t allocated2 = 0;
555    int64_t active_instances = 0;
556    Alloc alloc(&allocated1, &active_instances);
557    Alloc alloc2(&allocated2, &active_instances);
558    {
559      int initial_value = 1;
560      AllocFxdArr arr1(inlined_size * 2, initial_value, alloc);
561      EXPECT_EQ(allocated1, arr1.size() * sizeof(int));
562      AllocFxdArr arr2(arr1, alloc2);
563      EXPECT_EQ(allocated2, inlined_size * 2 * sizeof(int));
564      static_cast<void>(arr1);
565      static_cast<void>(arr2);
566    }
567    EXPECT_EQ(active_instances, 0);
568  }
569  TEST(AllocatorSupportTest, SizeValAllocConstructor) {
570    using testing::AllOf;
571    using testing::Each;
572    using testing::SizeIs;
573    constexpr size_t inlined_size = 4;
574    using Alloc = absl::container_internal::CountingAllocator<int>;
575    using AllocFxdArr = absl::FixedArray<int, inlined_size, Alloc>;
576    {
577      auto len = inlined_size / 2;
578      auto val = 0;
579      int64_t allocated = 0;
580      AllocFxdArr arr(len, val, Alloc(&allocated));
581      EXPECT_EQ(allocated, 0);
582      EXPECT_THAT(arr, AllOf(SizeIs(len), Each(0)));
583    }
584    {
585      auto len = inlined_size * 2;
586      auto val = 0;
587      int64_t allocated = 0;
588      AllocFxdArr arr(len, val, Alloc(&allocated));
589      EXPECT_EQ(allocated, len * sizeof(int));
590      EXPECT_THAT(arr, AllOf(SizeIs(len), Each(0)));
591    }
592  }
593  TEST(AllocatorSupportTest, PropagatesStatefulAllocator) {
594    constexpr size_t inlined_size = 4;
595    using Alloc = absl::container_internal::CountingAllocator<int>;
596    using AllocFxdArr = absl::FixedArray<int, inlined_size, Alloc>;
597    auto len = inlined_size * 2;
598    auto val = 0;
599    int64_t allocated = 0;
600    AllocFxdArr arr(len, val, Alloc(&allocated));
601    EXPECT_EQ(allocated, len * sizeof(int));
602    AllocFxdArr copy = arr;
603    EXPECT_EQ(allocated, len * sizeof(int) * 2);
604  }
605  #ifdef ABSL_HAVE_ADDRESS_SANITIZER
606  TEST(FixedArrayTest, AddressSanitizerAnnotations1) {
607    absl::FixedArray<int, 32> a(10);
608    int* raw = a.data();
609    raw[0] = 0;
610    raw[9] = 0;
611    EXPECT_DEATH_IF_SUPPORTED(raw[-2] = 0, "container-overflow");
612    EXPECT_DEATH_IF_SUPPORTED(raw[-1] = 0, "container-overflow");
613    EXPECT_DEATH_IF_SUPPORTED(raw[10] = 0, "container-overflow");
614    EXPECT_DEATH_IF_SUPPORTED(raw[31] = 0, "container-overflow");
615  }
616  TEST(FixedArrayTest, AddressSanitizerAnnotations2) {
617    absl::FixedArray<char, 17> a(12);
618    char* raw = a.data();
619    raw[0] = 0;
620    raw[11] = 0;
621    EXPECT_DEATH_IF_SUPPORTED(raw[-7] = 0, "container-overflow");
622    EXPECT_DEATH_IF_SUPPORTED(raw[-1] = 0, "container-overflow");
623    EXPECT_DEATH_IF_SUPPORTED(raw[12] = 0, "container-overflow");
624    EXPECT_DEATH_IF_SUPPORTED(raw[17] = 0, "container-overflow");
625  }
626  TEST(FixedArrayTest, AddressSanitizerAnnotations3) {
627    absl::FixedArray<uint64_t, 20> a(20);
628    uint64_t* raw = a.data();
629    raw[0] = 0;
630    raw[19] = 0;
631    EXPECT_DEATH_IF_SUPPORTED(raw[-1] = 0, "container-overflow");
632    EXPECT_DEATH_IF_SUPPORTED(raw[20] = 0, "container-overflow");
633  }
634  TEST(FixedArrayTest, AddressSanitizerAnnotations4) {
635    absl::FixedArray<ThreeInts> a(10);
636    ThreeInts* raw = a.data();
637    raw[0] = ThreeInts();
638    raw[9] = ThreeInts();
639    EXPECT_DEATH_IF_SUPPORTED(raw[-1].z_ = 0, "container-overflow");
640    EXPECT_DEATH_IF_SUPPORTED(raw[10] = ThreeInts(), "container-overflow");
641    EXPECT_DEATH_IF_SUPPORTED(raw[21] = ThreeInts(), "container-overflow");
642  }
643  #endif  
644  TEST(FixedArrayTest, AbslHashValueWorks) {
645    using V = absl::FixedArray<int>;
646    std::vector<V> cases;
647    for (int i = 0; i < 10; ++i) {
648      V v(i);
649      for (int j = 0; j < i; ++j) {
650        v[j] = j;
651      }
652      cases.push_back(v);
653    }
654    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(cases));
655  }
656  }  
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-agmdirected.cpp</h3>
            <pre><code>1  #include "stdafx.h"
2  #include "agmfast.h"
3  #include "agmdirected.h"
4  #include "Snap.h"
5  #include "agm.h"
6  void TCoda::Save(TSOut& SOut) {
7    G->Save(SOut);
8    F.Save(SOut);
9    H.Save(SOut);
10    NIDV.Save(SOut);
11    RegCoef.Save(SOut);
12    SumFV.Save(SOut);
13    SumHV.Save(SOut);
14    NodesOk.Save(SOut);
15    MinVal.Save(SOut);
16    MaxVal.Save(SOut);
17    NegWgt.Save(SOut);
18    NumComs.Save(SOut);
19    HOVIDSV.Save(SOut);
20    PNoCom.Save(SOut);
21  }
22  void TCoda::Load(TSIn& SIn, const int& RndSeed) {
23    G->Load(SIn);
24    F.Load(SIn);
25    H.Load(SIn);
26    NIDV.Load(SIn);
27    RegCoef.Load(SIn);
28    SumFV.Load(SIn);
29    SumHV.Load(SIn);
30    NodesOk.Load(SIn);
31    MinVal.Load(SIn);
32    MaxVal.Load(SIn);
33    NegWgt.Load(SIn);
34    NumComs.Load(SIn);
35    HOVIDSV.Load(SIn);
36    PNoCom.Load(SIn);
37    Rnd.PutSeed(RndSeed);
38  }
39  void TCoda::RandomInit(const int InitComs) {
40    F.Gen(G->GetNodes());
41    H.Gen(G->GetNodes());
42    SumFV.Gen(InitComs);
43    SumHV.Gen(InitComs);
44    NumComs = InitComs;
45    for (int u = 0; u < F.Len(); u++) {
46      int Mem = G->GetNI(u).GetOutDeg();
47      if (Mem > 10) { Mem = 10; }
48      for (int c = 0; c < Mem; c++) {
49        int CID = Rnd.GetUniDevInt(InitComs);
50        AddComOut(u, CID, Rnd.GetUniDev());
51      }
52    }
53    for (int u = 0; u < H.Len(); u++) {
54      int Mem = G->GetNI(u).GetInDeg();
55      if (Mem > 10) { Mem = 10; }
56      for (int c = 0; c < Mem; c++) {
57        int CID = Rnd.GetUniDevInt(InitComs);
58        AddComIn(u, CID, Rnd.GetUniDev());
59      }
60    }
61    for (int c = 0; c < SumFV.Len(); c++) {
62      if (SumFV[c] == 0.0) {
63        int UID = Rnd.GetUniDevInt(G->GetNodes());
64        AddComOut(UID, c, Rnd.GetUniDev());
65      }
66    }
67    for (int c = 0; c < SumHV.Len(); c++) {
68      if (SumHV[c] == 0.0) {
69        int UID = Rnd.GetUniDevInt(G->GetNodes());
70        AddComIn(UID, c, Rnd.GetUniDev());
71      }
72    }
73  }
74  void TCoda::NeighborComInit(const int InitComs) {
75    TExeTm RunTm;
76    TFltIntPrV NIdPhiV(F.Len(), 0);
77    TAGMFastUtil::GetNIdPhiV<PNGraph>(G, NIdPhiV);
78    NeighborComInit(NIdPhiV, InitComs);
79  }
80  void TCoda::NeighborComInit(TFltIntPrV& NIdPhiV, const int InitComs) {
81    NIdPhiV.Sort(true);
82    F.Gen(G->GetNodes());
83    H.Gen(G->GetNodes());
84    SumFV.Gen(InitComs);
85    SumHV.Gen(InitComs);
86    NumComs = InitComs;
87    TIntSet InvalidNIDS(F.Len());
88    TIntV ChosenNIDV(InitComs, 0); 
89    int CurCID = 0;
90    for (int ui = 0; ui < NIdPhiV.Len(); ui++) {
91      int UID = NIdPhiV[ui].Val2;
92      fflush(stdout);
93      if (InvalidNIDS.IsKey(UID)) { continue; }
94      ChosenNIDV.Add(UID); 
95      TNGraph::TNodeI NI = G->GetNI(UID);
96      if (NI.GetOutDeg() > 0) { AddComOut(UID, CurCID, 1.0); }
97      if (NI.GetInDeg() > 0) { AddComIn(UID, CurCID, 1.0); }
98      fflush(stdout);
99      for (int e = 0; e < NI.GetDeg(); e++) {
100        int VID = NI.GetNbrNId(e);
101        TNGraph::TNodeI VI = G->GetNI(VID);
102        if (VI.GetOutDeg() > 0) { AddComOut(VID, CurCID, 1.0); }
103        if (VI.GetInDeg() > 0) { AddComIn(VID, CurCID, 1.0); }
104      }
105      for (int e = 0; e < NI.GetDeg(); e++) {
106        InvalidNIDS.AddKey(NI.GetNbrNId(e));
107      }
108      CurCID++;
109      fflush(stdout);
110      if (CurCID >= NumComs) { break;  }
111    }
112    if (NumComs > CurCID) {
113      printf("%d communities needed to fill randomly\n", NumComs - CurCID);
114    }
115    for (int c = 0; c < SumFV.Len(); c++) {
116      if (SumFV[c] == 0.0) {
117        int ComSz = 10;
118        for (int u = 0; u < ComSz; u++) {
119          int UID = Rnd.GetUniDevInt(G->GetNodes());
120          AddComOut(UID, c, Rnd.GetUniDev());
121        }
122      }
123    }
124    for (int c = 0; c < SumHV.Len(); c++) {
125      if (SumHV[c] == 0.0) {
126        int ComSz = 10;
127        for (int u = 0; u < ComSz; u++) {
128          int UID = Rnd.GetUniDevInt(G->GetNodes());
129          AddComIn(UID, c, Rnd.GetUniDev());
130        }
131      }
<span onclick='openModal()' class='match'>132    }
133  }
134  void TCoda::GetNonEdgePairScores(TFltIntIntTrV& ScoreV) {
135    ScoreV.Gen(G->GetNodes() * G->GetNodes(), 0);
136    TIntV NIDV;
137    G->GetNIdV(NIDV);
138    TIntSet Cuv;
139    for (int u = 0; u < NIDV.Len(); u++) {
140      int UID = NIDV[u];
</span>141      for (int v = 0; v < NIDV.Len(); v++) {
142        int VID = NIDV[v];
143        if (UID == VID) { continue; }
144        if (! G->IsEdge(UID, VID)) {
145          double Val = 1.0 - Prediction(UID, VID);
146          ScoreV.Add(TFltIntIntTr(Val, UID, VID));
147        }
148      }
149    }
150  }
151  void TCoda::SetCmtyVV(const TVec<TIntV>& CmtyVVOut, const TVec<TIntV>& CmtyVVIn) {
152    IAssert(CmtyVVOut.Len() == CmtyVVIn.Len());
153    F.Gen(G->GetNodes());
154    H.Gen(G->GetNodes());
155    SumFV.Gen(CmtyVVOut.Len());
156    SumHV.Gen(CmtyVVIn.Len());
157    NumComs = CmtyVVOut.Len();
158    TIntH NIDIdxH(NIDV.Len());
159    if (! NodesOk) {
160      for (int u = 0; u < NIDV.Len(); u++) {
161        NIDIdxH.AddDat(NIDV[u], u);
162      }
163    }
164    for (int c = 0; c < CmtyVVOut.Len(); c++) {
165      for (int u = 0; u < CmtyVVOut[c].Len(); u++) {
166        int UID = CmtyVVOut[c][u];
167        if (! NodesOk) { UID = NIDIdxH.GetDat(UID); }
168        if (G->IsNode(UID)) { 
169          AddComOut(UID, c, 1.0);
170        }
171      }
172    }
173    for (int c = 0; c < CmtyVVIn.Len(); c++) {
174      for (int u = 0; u < CmtyVVIn[c].Len(); u++) {
175        int UID = CmtyVVIn[c][u];
176        if (! NodesOk) { UID = NIDIdxH.GetDat(UID); }
177        if (G->IsNode(UID)) { 
178          AddComIn(UID, c, 1.0);
179        }
180      }
181    }
182  }
183  void TCoda::SetGraph(const PNGraph& GraphPt) {
184    G = GraphPt;
185    HOVIDSV.Gen(G->GetNodes());  
186    NodesOk = true;
187    GraphPt->GetNIdV(NIDV);
188    for (int nid = 0; nid < GraphPt->GetNodes(); nid++) {
189      if (! GraphPt->IsNode(nid)) { 
190        NodesOk = false; 
191        break; 
192      } 
193    }
194    if (! NodesOk) {
195      printf("rearrage nodes\n");
196      G = TSnap::GetSubGraph(GraphPt, NIDV, true);
197      for (int nid = 0; nid < G->GetNodes(); nid++) {
198        IAssert(G->IsNode(nid)); 
199      }
200    }
201    TSnap::DelSelfEdges(G);
202    PNoCom = 1.0 / (double) G->GetNodes();
203    DoParallel = false;
204    if (1.0 / PNoCom > sqrt(TFlt::Mx)) { PNoCom = 0.99 / sqrt(TFlt::Mx); } 
205    NegWgt = 1.0;
206  }
207  double TCoda::Likelihood(const bool _DoParallel) { 
208    TExeTm ExeTm;
209    double L = 0.0;
210    if (_DoParallel) {
211    #pragma omp parallel for 
212      for (int u = 0; u < F.Len(); u++) {
213        double LU = LikelihoodForNode(true, u);
214        #pragma omp atomic
215          L += LU;
216      }
217    }
218    else {
219      for (int u = 0; u < F.Len(); u++) {
220        double LU = LikelihoodForNode(true, u);
221          L += LU;
222      }
223    }
224    return L;
225  }
226  double TCoda::LikelihoodForNode(const bool IsRow, const int UID) {
227    if (IsRow) {
228      return LikelihoodForNode(IsRow, UID, F[UID]);
229    } else {
230      return LikelihoodForNode(IsRow, UID, H[UID]);
231    }
232  }
233  double TCoda::LikelihoodForNode(const bool IsRow, const int UID, const TIntFltH& FU) {
234    double L = 0.0;
235    TFltV HOSumHV; 
236    if (HOVIDSV[UID].Len() > 0) {
237      HOSumHV.Gen(NumComs);
238      for (int e = 0; e < HOVIDSV[UID].Len(); e++) {
239        for (int c = 0; c < SumHV.Len(); c++) {
240          HOSumHV[c] += GetCom(! IsRow, HOVIDSV[UID][e], c);
241        }
242      }
243    }
244    TNGraph::TNodeI NI = G->GetNI(UID);
245    const int Deg = IsRow ? NI.GetOutDeg(): NI.GetInDeg();
246    for (int e = 0; e < Deg; e++) {
247      const int v = IsRow ? NI.GetOutNId(e): NI.GetInNId(e);
248      if (v == UID) { continue; }
249      if (HOVIDSV[UID].IsKey(v)) { continue; }
250      if (IsRow) {
251        L += log (1.0 - Prediction(FU, H[v])) + NegWgt * DotProduct(FU, H[v]);
252      } else {
253        L += log (1.0 - Prediction(F[v], FU)) + NegWgt * DotProduct(F[v], FU);
254      }
255    }
256    for (TIntFltH::TIter HI = FU.BegI(); HI < FU.EndI(); HI++) {
257      double HOSum = HOVIDSV[UID].Len() > 0?  HOSumHV[HI.GetKey()].Val: 0.0;
258      L -= NegWgt * (GetSumVal(! IsRow, HI.GetKey()) - HOSum - GetCom(! IsRow, UID, HI.GetKey())) * HI.GetDat();
259    }
260    if (RegCoef > 0.0) { 
261      L -= RegCoef * Sum(FU);
262    }
263    if (RegCoef < 0.0) { 
264      L += RegCoef * Norm2(FU);
265    }
266    return L;
267  }
268  void TCoda::GradientForNode(const bool IsRow, const int UID, TIntFltH& GradU, const TIntSet& CIDSet) {
269    GradU.Gen(CIDSet.Len());
270    TFltV HOSumHV; 
271    if (HOVIDSV[UID].Len() > 0) {
272      HOSumHV.Gen(NumComs);
273      for (int e = 0; e < HOVIDSV[UID].Len(); e++) {
274        for (int c = 0; c < SumHV.Len(); c++) {
275          HOSumHV[c] += GetCom(! IsRow, HOVIDSV[UID][e], c);
276        }
277      }
278    }
279    TNGraph::TNodeI NI = G->GetNI(UID);
280    int Deg = IsRow ? NI.GetOutDeg(): NI.GetInDeg();
281    TFltV PredV(Deg), GradV(CIDSet.Len());
282    TIntV CIDV(CIDSet.Len());
283    for (int e = 0; e < Deg; e++) {
284      int VID = IsRow? NI.GetOutNId(e): NI.GetInNId(e);
285      if (VID == UID) { continue; }
286      if (HOVIDSV[UID].IsKey(VID)) { continue; }
287      PredV[e] = IsRow? Prediction(UID, VID): Prediction(VID, UID);
288    }
289    for (int c = 0; c < CIDSet.Len(); c++) {
290      int CID = CIDSet.GetKey(c);
291      double Val = 0.0;
292      for (int e = 0; e < Deg; e++) {
293        int VID = IsRow? NI.GetOutNId(e): NI.GetInNId(e);
294        if (VID == UID) { continue; }
295        if (HOVIDSV[UID].IsKey(VID)) { continue; }
296        Val += PredV[e] * GetCom(! IsRow, VID, CID) / (1.0 - PredV[e]) + NegWgt * GetCom(! IsRow, VID, CID);
297      }
298      double HOSum = HOVIDSV[UID].Len() > 0?  HOSumHV[CID].Val: 0.0;
299      Val -= NegWgt * (GetSumVal(! IsRow, CID) - HOSum - GetCom(! IsRow, UID, CID));
300      CIDV[c] = CID;
301      GradV[c] = Val;
302    }
303    if (RegCoef > 0.0) { 
304      for (int c = 0; c < GradV.Len(); c++) {
305        GradV[c] -= RegCoef; 
306      }
307    }
308    if (RegCoef < 0.0) { 
309      for (int c = 0; c < GradV.Len(); c++) {
310        GradV[c] += 2 * RegCoef * GetCom(IsRow, UID, CIDV[c]); 
311      }
312    }
313    for (int c = 0; c < GradV.Len(); c++) {
314      if (GetCom(IsRow, UID, CIDV[c]) == 0.0 && GradV[c] < 0.0) { continue; }
315      if (fabs(GradV[c]) < 0.0001) { continue; }
316      GradU.AddDat(CIDV[c], GradV[c]);
317    }
318    for (int c = 0; c < GradU.Len(); c++) {
319      if (GradU[c] >= 10) { GradU[c] = 10; }
320      if (GradU[c] <= -10) { GradU[c] = -10; }
321      IAssert(GradU[c] >= -10);
322    }
323  }
324  void TCoda::GetCmtyVV(const bool IsOut, TVec<TIntV>& CmtyVV) {
325    GetCmtyVV(IsOut, CmtyVV, sqrt(1.0 / G->GetNodes()), 3);
326  }
327  void TCoda::GetCommunity(TIntV& CmtyVIn, TIntV& CmtyVOut, const int CID, const double Thres) {
328    TIntFltH NIDFucH(F.Len() / 10), NIDHucH(F.Len() / 10);
329    for (int u = 0; u < NIDV.Len(); u++) {
330      int NID = u;
331      if (! NodesOk) { NID = NIDV[u]; }
332      if (GetCom(true, u, CID) >= Thres) { NIDFucH.AddDat(NID, GetCom(true, u, CID)); }
333      if (GetCom(false, u, CID) >= Thres) { NIDHucH.AddDat(NID, GetCom(false, u, CID)); }
334    }
335    NIDFucH.SortByDat(false);
336    NIDHucH.SortByDat(false);
337    NIDFucH.GetKeyV(CmtyVOut);
338    NIDHucH.GetKeyV(CmtyVIn);
339  }
340  void TCoda::GetTopCIDs(TIntV& CIdV, const int TopK, const int IsAverage, const int MinSz) {
341    TIntFltH CIdFHH;
342    for (int c = 0; c < GetNumComs(); c++) {
343      if (IsAverage == 1) {
344        TIntV CmtyVIn, CmtyVOut;
345        GetCommunity(CmtyVIn, CmtyVOut, c);
346        if (CmtyVIn.Len() == 0 || CmtyVOut.Len() == 0) { continue; }
347        if (CmtyVIn.Len() < MinSz || CmtyVOut.Len() < MinSz) { continue; }
348        CIdFHH.AddDat(c, GetSumVal(true, c) * GetSumVal(false, c) / (double) CmtyVIn.Len() / (double) CmtyVOut.Len());
349      } else {
350        CIdFHH.AddDat(c, GetSumVal(true, c) * GetSumVal(false, c));
351      }
352    }
353    CIdFHH.SortByDat(false);
354    CIdFHH.GetKeyV(CIdV);
355    if (TopK < CIdFHH.Len()) { CIdV.Trunc(TopK); }
356  }
357  void TCoda::GetCmtyVV(const bool IsOut, TVec<TIntV>& CmtyVV, const double Thres, const int MinSz) {
358    CmtyVV.Gen(NumComs, 0);
359    TIntFltH CIDSumFH(NumComs);
360    for (int c = 0; c < NumComs; c++) {
361      CIDSumFH.AddDat(c, GetSumVal(IsOut, c));
362    }
363    CIDSumFH.SortByDat(false);
364    for (int c = 0; c < NumComs; c++) {
365      int CID = CIDSumFH.GetKey(c);
366      TIntFltH NIDFucH, NIDHucH, NIDInOutH;
367      TIntV CmtyV;
368      GetNIDValH(NIDInOutH, NIDFucH, NIDHucH, CID, Thres);
369      if (IsOut) {
370        NIDFucH.GetKeyV(CmtyV);
371      } else {
372        NIDHucH.GetKeyV(CmtyV);
373      }
374      if (CmtyV.Len() >= MinSz) { CmtyVV.Add(CmtyV); }
375    }
376    if ( NumComs != CmtyVV.Len()) {
377      printf("Community vector generated. %d communities are ommitted\n", NumComs.Val - CmtyVV.Len());
378    }
379  }
380  void TCoda::GetCmtyVVUnSorted(const bool IsOut, TVec<TIntV>& CmtyVV, const double Thres, const int MinSz) {
381    CmtyVV.Gen(NumComs, 0);
382    for (int c = 0; c < NumComs; c++) {
383      TIntV CmtyV((int) (GetSumVal(IsOut, c) * 10), 0);
384      for (int u = 0; u < G->GetNodes(); u++) {
385        if (GetCom(IsOut, u, c) > Thres) { CmtyV.Add(NIDV[u]); }
386      }
387      if (CmtyV.Len() >= MinSz) { CmtyVV.Add(CmtyV); }
388    }
389    if ( NumComs != CmtyVV.Len()) {
390      printf("Community vector generated. %d communities are ommitted\n", NumComs.Val - CmtyVV.Len());
391    }
392  }
393  PNGraph TCoda::GetGraphRawNID() {
394    PNGraph NewG = TNGraph::New(G->GetNodes(), -1);
395    for (TNGraph::TNodeI NI = G->BegNI(); NI < G->EndNI(); NI++) {
396      int NIdx = NI.GetId();
397      int NID = NIDV[NIdx];
398      if (! NewG->IsNode(NID)) { NewG->AddNode(NID); }
399      for (int e = 0; e < NI.GetOutDeg(); e++) {
400        int OutNID = NIDV[NI.GetOutNId(e)];
401        if (! NewG->IsNode(OutNID)) { NewG->AddNode(OutNID); }
402        NewG->AddEdge(NID, OutNID);
403      }
404    }
405    IAssert(G->GetNodes() == NewG->GetNodes());
406    IAssert(G->GetEdges() == NewG->GetEdges());
407    return NewG;
408  }
409  void TCoda::GetNIDValH(TIntFltH& NIdValInOutH, TIntFltH& NIdValOutH, TIntFltH& NIdValInH, const int CID, const double Thres) {
410    NIdValOutH.Gen((int) GetSumVal(true, CID) + 1);
411    NIdValInH.Gen((int) GetSumVal(false, CID) + 1);
412    NIdValInOutH.Gen((int) GetSumVal(false, CID) + 1);
413    if (GetSumVal(true, CID) < Thres && GetSumVal(false, CID) < Thres) { return; }
414    for (int u = 0; u < NIDV.Len(); u++) {
415      if (GetCom(true, u, CID) >= Thres && GetCom(false, u, CID) >= Thres) {
416        NIdValInOutH.AddDat(NIDV[u], GetCom(true, u, CID) + GetCom(false, u, CID));
417      }
418      if (GetCom(true, u, CID) >= Thres) {
419        NIdValOutH.AddDat(NIDV[u], GetCom(true, u, CID));
420      }
421      if (GetCom(false, u, CID) >= Thres) {
422        NIdValInH.AddDat(NIDV[u], GetCom(false, u, CID));
423      }
424    }
425    NIdValInH.SortByDat(false);
426    NIdValOutH.SortByDat(false);
427    NIdValInOutH.SortByDat(false);
428  }
429  void TCoda::DumpMemberships(const TStr& OutFNm, const TStrHash<TInt>& NodeNameH, const double Thres) {
430    if (NodeNameH.Len() > 0) { IAssert(NodeNameH.Len() == G->GetNodes()); }
431    FILE* FId = fopen(OutFNm.CStr(), "wt");
432    TIntFltH CIDSumFH(NumComs);
433    for (int c = 0; c < NumComs; c++) {
434      CIDSumFH.AddDat(c, GetSumVal(true, c) * GetSumVal(false, c));
435    }
436    CIDSumFH.SortByDat(false);
437    for (int c = 0; c < NumComs; c++) {
438      int CID = CIDSumFH.GetKey(c);
439      TIntFltH NIDOutFH, NIDInFH, NIDInOutFH;
440      GetNIDValH(NIDInOutFH, NIDOutFH, NIDInFH, CID, Thres);
441      if (NIDOutFH.Len() == 0 || NIDInFH.Len() == 0) { continue; }
442      fprintf(FId, "%d\t%d\t%d\t%f\t%f\t%f\t", NIDInOutFH.Len(), NIDInFH.Len() - NIDInOutFH.Len(), NIDOutFH.Len() - NIDInOutFH.Len(), CIDSumFH.GetDat(CID).Val, GetSumVal(false, CID).Val, GetSumVal(true, CID).Val);
443      fprintf(FId, "InOut:\t");
444      for (int u = 0; u < NIDInOutFH.Len(); u++) {
445        int NIdx = NIDInOutFH.GetKey(u);
446        fprintf(FId, "%s (%f)\t", NodeNameH.GetKey(NIdx), NIDInOutFH[u].Val);
447      }
448      fprintf(FId, "In:\t");
449      for (int u = 0; u < NIDInFH.Len(); u++) {
450        int NIdx = NIDInFH.GetKey(u);
451        fprintf(FId, "%s (%f)\t", NodeNameH.GetKey(NIdx), NIDInFH[u].Val);
452      }
453      fprintf(FId, "Out:\t");
454      for (int u = 0; u < NIDOutFH.Len(); u++) {
455        int NIdx = NIDOutFH.GetKey(u);
456        fprintf(FId, "%s (%f)\t", NodeNameH.GetKey(NIdx), NIDOutFH[u].Val);
457      }
458      fprintf(FId, "\n");
459    }
460    fclose(FId);
461  }
462  void TCoda::DumpMemberships(const TStr& OutFNm, const double Thres) {
463    TStrHash<TInt> NodeNameH(G->GetNodes(), false);
464    for (int u = 0; u < NIDV.Len(); u++) { NodeNameH.AddKey(TStr::Fmt("%d", NIDV[u].Val)); }
465    DumpMemberships(OutFNm, NodeNameH, Thres);
466  }
467  void TCoda::GetCmtyS(TIntSet& CmtySOut, TIntSet& CmtySIn, const int CID, const double Thres) {
468    CmtySOut.Gen(G->GetNodes() / 10);
469    CmtySIn.Gen(G->GetNodes() / 10);
470    for (int u = 0; u < NIDV.Len(); u++) {
471      if (GetCom(true, u, CID) > Thres) {
472      }
473    }
474  }
475  void TCoda::GetCmtyVV(TVec<TIntV>& CmtyVVOut, TVec<TIntV>& CmtyVVIn, const int MinSz) {
476    GetCmtyVV(false, CmtyVVIn, sqrt(1.0 / G->GetNodes()), MinSz);
477    GetCmtyVV(true, CmtyVVOut, sqrt(1.0 / G->GetNodes()), MinSz);
478  }
479  void TCoda::GetCmtyVVUnSorted(TVec<TIntV>& CmtyVVOut, TVec<TIntV>& CmtyVVIn) {
480    GetCmtyVVUnSorted(false, CmtyVVIn, sqrt(1.0 / G->GetNodes()));
481    GetCmtyVVUnSorted(true, CmtyVVOut, sqrt(1.0 / G->GetNodes()));
482  }
483  void TCoda::GetCmtyVV(TVec<TIntV>& CmtyVVOut, TVec<TIntV>& CmtyVVIn, const double ThresOut, const double ThresIn, const int MinSz) {
484    GetCmtyVV(false, CmtyVVIn, ThresIn, MinSz);
485    GetCmtyVV(true, CmtyVVOut, ThresOut, MinSz);
486  }
487  int TCoda::FindComsByCV(const int NumThreads, const int MaxComs, const int MinComs, const int DivComs, const TStr OutFNm, const int EdgesForCV, const double StepAlpha, const double StepBeta) {
488      double ComsGap = exp(TMath::Log((double) MaxComs / (double) MinComs) / (double) DivComs);
489      TIntV ComsV;
490      ComsV.Add(MinComs);
491      while (ComsV.Len() < DivComs) {
492        int NewComs = int(ComsV.Last() * ComsGap);
493        if (NewComs == ComsV.Last().Val) { NewComs++; }
494        ComsV.Add(NewComs);
495      }
496      if (ComsV.Last() < MaxComs) { ComsV.Add(MaxComs); }
497      return FindComsByCV(ComsV, 0.1, NumThreads, OutFNm, EdgesForCV, StepAlpha, StepBeta);
498  }
499  int TCoda::FindComsByCV(TIntV& ComsV, const double HOFrac, const int NumThreads, const TStr PlotLFNm, const int EdgesForCV, const double StepAlpha, const double StepBeta) {
500    if (ComsV.Len() == 0) {
501      int MaxComs = G->GetNodes() / 5;
502      ComsV.Add(2);
503      while(ComsV.Last() < MaxComs) { ComsV.Add(ComsV.Last() * 2); }
504    }
505    int MaxIterCV = 3;
506    TVec<TVec<TIntSet> > HoldOutSets(MaxIterCV);
507    TFltIntPrV NIdPhiV;
508    TAGMFastUtil::GetNIdPhiV<PNGraph>(G, NIdPhiV);
509    if (G->GetEdges() > EdgesForCV) { 
510      printf("generating hold out set\n");
511      TIntV NIdV1, NIdV2;
512      G->GetNIdV(NIdV1);
513      G->GetNIdV(NIdV2);
514      for (int IterCV = 0; IterCV < MaxIterCV; IterCV++) {
515        TAGMFastUtil::GenHoldOutPairs(G, HoldOutSets[IterCV], HOFrac, Rnd);
516      }
517      printf("hold out set generated\n");
518    }
519    TFltV HOLV(ComsV.Len());
520    TIntFltPrV ComsLV;
521    for (int c = 0; c < ComsV.Len(); c++) {
522      const int Coms = ComsV[c];
523      printf("Try number of Coms:%d\n", Coms);
524      if (G->GetEdges() > EdgesForCV) { 
525        for (int IterCV = 0; IterCV < MaxIterCV; IterCV++) {
526          HOVIDSV = HoldOutSets[IterCV];
527          NeighborComInit(NIdPhiV, Coms);
528          printf("Initialized\n");
529          if (NumThreads == 1) {
530            printf("MLE without parallelization begins\n");
531            MLEGradAscent(0.05, 10 * G->GetNodes(), "", StepAlpha, StepBeta);
532          } else {
533            printf("MLE with parallelization begins\n");
534            MLEGradAscentParallel(0.05, 100, NumThreads, "", StepAlpha, StepBeta);
535          }
536          double HOL = LikelihoodHoldOut();
537          HOL = HOL < 0? HOL: TFlt::Mn;
538          HOLV[c] += HOL;
539        }
540      }
541      else {
542        HOVIDSV.Gen(G->GetNodes());
543        MLEGradAscent(0.0001, 100 * G->GetNodes(), "");
544        double BIC = 2 * Likelihood() - (double) G->GetNodes() * Coms * 2.0 * log ( (double) G->GetNodes());
545        HOLV[c] = BIC;
546      }
547    }
548    int EstComs = 2;
549    double MaxL = TFlt::Mn;
550    printf("\n");
551    for (int c = 0; c < ComsV.Len(); c++) {
552      ComsLV.Add(TIntFltPr(ComsV[c].Val, HOLV[c].Val));
553      printf("%d(%f)\t", ComsV[c].Val, HOLV[c].Val);
554      if (MaxL < HOLV[c]) {
555        MaxL = HOLV[c];
556        EstComs = ComsV[c];
557      }
558    }
559    printf("\n");
560    RandomInit(EstComs);
561    HOVIDSV.Gen(G->GetNodes());
562    if (! PlotLFNm.Empty()) {
563      TGnuPlot::PlotValV(ComsLV, PlotLFNm, "hold-out likelihood", "communities", "likelihood");
564    }
565    return EstComs;
566  }
567  double TCoda::LikelihoodHoldOut(const bool DoParallel) { 
568    double L = 0.0;
569    for (int u = 0; u < HOVIDSV.Len(); u++) {
570      for (int e = 0; e < HOVIDSV[u].Len(); e++) {
571        int VID = HOVIDSV[u][e];
572        if (VID == u) { continue; } 
573        double Pred = Prediction(u, VID);
574        if (G->IsEdge(u, VID)) {
575          L += log(1.0 - Pred);
576        }
577        else {
578          L += NegWgt * log(Pred);
579        }
580      }
581    }
582    return L;
583  }
584  double TCoda::GetStepSizeByLineSearch(const bool IsRow, const int UID, const TIntFltH& DeltaV, const TIntFltH& GradV, const double& Alpha, const double& Beta, const int MaxIter) {
585    double StepSize = 1.0;
586    double InitLikelihood = LikelihoodForNode(IsRow, UID);
587    TIntFltH NewVarV(DeltaV.Len());
588    for(int iter = 0; iter < MaxIter; iter++) {
589      for (int i = 0; i < DeltaV.Len(); i++){
590        int CID = DeltaV.GetKey(i);
591        double NewVal;
592        NewVal = GetCom(IsRow, UID, CID) + StepSize * DeltaV.GetDat(CID);
593        if (NewVal < MinVal) { NewVal = MinVal; }
594        if (NewVal > MaxVal) { NewVal = MaxVal; }
595        NewVarV.AddDat(CID, NewVal);
596      }
597      if (LikelihoodForNode(IsRow, UID, NewVarV) < InitLikelihood + Alpha * StepSize * DotProduct(GradV, DeltaV)) {
598        StepSize *= Beta;
599      } else {
600        break;
601      }
602      if (iter == MaxIter - 1) { 
603        StepSize = 0.0;
604        break;
605      }
606    }
607    return StepSize;
608  }
609  int TCoda::MLEGradAscent(const double& Thres, const int& MaxIter, const TStr PlotNm, const double StepAlpha, const double StepBeta) {
610    time_t InitTime = time(NULL);
611    TExeTm ExeTm, CheckTm;
612    int iter = 0, PrevIter = 0;
613    TIntFltPrV IterLV;
614    TNGraph::TNodeI UI;
615    double PrevL = TFlt::Mn, CurL = 0.0;
616    TIntV NIdxV(F.Len(), 0);
617    for (int i = 0; i < F.Len(); i++) { NIdxV.Add(i); }
618    IAssert(NIdxV.Len() == F.Len());
619    TIntFltH GradV;
620    while(iter < MaxIter) {
621      NIdxV.Shuffle(Rnd);
622      for (int ui = 0; ui < F.Len(); ui++, iter++) {
623        const bool IsRow = (ui % 2 == 0);
624        int u = NIdxV[ui]; 
625        UI = G->GetNI(u);
626        const int Deg = IsRow? UI.GetOutDeg(): UI.GetInDeg();
627        TIntSet CIDSet(5 * Deg);
628        for (int e = 0; e < Deg; e++) {
629          int VID = IsRow? UI.GetOutNId(e): UI.GetInNId(e);
630          if (HOVIDSV[u].IsKey(VID)) { continue; }
631          TIntFltH NbhCIDH = IsRow? H[VID]: F[VID];
632          for (TIntFltH::TIter CI = NbhCIDH.BegI(); CI < NbhCIDH.EndI(); CI++) {
633            CIDSet.AddKey(CI.GetKey());
634            IAssert(CI.GetKey() <= NumComs);
635          }
636        }
637        TIntFltH& CurMem = IsRow? F[u]: H[u];
638        for (TIntFltH::TIter CI = CurMem.BegI(); CI < CurMem.EndI(); CI++) { 
639          if (! CIDSet.IsKey(CI.GetKey())) {
640            DelCom(IsRow, u, CI.GetKey());
641          }
642        }
643        if (CIDSet.Empty()) { continue; }
644        GradientForNode(IsRow, u, GradV, CIDSet);
645        if (Norm2(GradV) < 1e-4) { continue; }
646        double LearnRate = GetStepSizeByLineSearch(IsRow, u, GradV, GradV, StepAlpha, StepBeta);
647        if (LearnRate == 0.0) { continue; }
648        for (int ci = 0; ci < GradV.Len(); ci++) {
649          int CID = GradV.GetKey(ci);
650          double Change = LearnRate * GradV.GetDat(CID);
651          double NewFuc = GetCom(IsRow, u, CID) + Change;
652          if (NewFuc <= 0.0) {
653            DelCom(IsRow, u, CID);
654          } else {
655            AddCom(IsRow, u, CID, NewFuc);
656          }
657        }
658        if (! PlotNm.Empty() && (iter + 1) % G->GetNodes() == 0) {
659          IterLV.Add(TIntFltPr(iter, Likelihood(false)));
660        }
661      }
662      printf("\r%d iterations (%f) [%lu sec]", iter, CurL, time(NULL) - InitTime);
663      fflush(stdout);
664      if (iter - PrevIter >= 2 * G->GetNodes() && iter > 10000) {
665        PrevIter = iter;
666        CurL = Likelihood();
667        if (PrevL > TFlt::Mn && ! PlotNm.Empty()) {
668          printf("\r%d iterations, Likelihood: %f, Diff: %f", iter, CurL,  CurL - PrevL);
669        }
670        fflush(stdout);
671        if (CurL - PrevL <= Thres * fabs(PrevL)) { break; }
672        else { PrevL = CurL; }
673      }
674    }
675    printf("\n");
676    printf("MLE for Lambda completed with %d iterations(%s)\n", iter, ExeTm.GetTmStr());
677    if (! PlotNm.Empty()) {
678      TGnuPlot::PlotValV(IterLV, PlotNm + ".likelihood_Q");
679    }
680    return iter;
681  }
682  int TCoda::MLEGradAscentParallel(const double& Thres, const int& MaxIter, const int ChunkNum, const int ChunkSize, const TStr PlotNm, const double StepAlpha, const double StepBeta) {
683    time_t InitTime = time(NULL);
684    TExeTm ExeTm, CheckTm;
685    double PrevL = Likelihood(true);
686    TIntFltPrV IterLV;
687    int PrevIter = 0;
688    int iter = 0;
689    TIntV NIdxV(F.Len(), 0);
690    for (int i = 0; i < F.Len(); i++) { NIdxV.Add(i); }
691    TIntV NIDOPTV(F.Len()); 
692    NIDOPTV.PutAll(0);
693    TVec<TIntFltH> NewF(ChunkNum * ChunkSize);
694    TIntV NewNIDV(ChunkNum * ChunkSize);
695    TBoolV IsRowV(ChunkNum * ChunkSize);
696    for (iter = 0; iter < MaxIter; iter++) {
697      NIdxV.Clr(false);
698      for (int i = 0; i < F.Len(); i++) { 
699        NIdxV.Add(i);
700      }
701      IAssert (NIdxV.Len() <= F.Len());
702      NIdxV.Shuffle(Rnd);
703  #pragma omp parallel for schedule(static, 1)
704      for (int TIdx = 0; TIdx < ChunkNum; TIdx++) {
705        TIntFltH GradV;
706        for (int ui = TIdx * ChunkSize; ui < (TIdx + 1) * ChunkSize; ui++) {
707          const bool IsRow = (ui % 2 == 0);
708          NewNIDV[ui] = -1;
709          if (ui > NIdxV.Len()) { continue; }
710          const int u = NIdxV[ui]; 
711          TNGraph::TNodeI UI = G->GetNI(u);
712          const int Deg = IsRow? UI.GetOutDeg(): UI.GetInDeg();
713          TIntSet CIDSet(5 * Deg);
714          TIntFltH CurFU = IsRow? F[u]: H[u];
715          for (int e = 0; e < Deg; e++) {
716            int VID = IsRow? UI.GetOutNId(e): UI.GetInNId(e);
717            if (HOVIDSV[u].IsKey(VID)) { continue; }
718            TIntFltH& NbhCIDH = IsRow? H[VID]: F[VID];
719            for (TIntFltH::TIter CI = NbhCIDH.BegI(); CI < NbhCIDH.EndI(); CI++) {
720              CIDSet.AddKey(CI.GetKey());
721            }
722          }
723          if (CIDSet.Empty()) { 
724            CurFU.Clr();
725          }
726          else {
727            for (TIntFltH::TIter CI = CurFU.BegI(); CI < CurFU.EndI(); CI++) { 
728              if (! CIDSet.IsKey(CI.GetKey())) {
729                CurFU.DelIfKey(CI.GetKey());
730              }
731            }
732            GradientForNode(IsRow, u, GradV, CIDSet);
733            if (Norm2(GradV) < 1e-4) { NIDOPTV[u] = 1; continue; }
734            double LearnRate = GetStepSizeByLineSearch(IsRow, u, GradV, GradV, StepAlpha, StepBeta);
735            if (LearnRate == 0.0) { NewNIDV[ui] = -2; continue; }
736            for (int ci = 0; ci < GradV.Len(); ci++) {
737              int CID = GradV.GetKey(ci);
738              double Change = LearnRate * GradV.GetDat(CID);
739              double NewFuc = CurFU.IsKey(CID)? CurFU.GetDat(CID) + Change : Change;
740              if (NewFuc <= 0.0) {
741                CurFU.DelIfKey(CID);
742              } else {
743                CurFU.AddDat(CID) = NewFuc;
744              }
745            }
746            CurFU.Defrag();
747          }
748          NewF[ui] = CurFU;
749          NewNIDV[ui] = u;
750          IsRowV[ui] = IsRow;
751        }
752      }
753      int NumNoChangeGrad = 0;
754      int NumNoChangeStepSize = 0;
755      for (int ui = 0; ui < NewNIDV.Len(); ui++) {
756        int NewNID = NewNIDV[ui];
757        if (NewNID == -1) { NumNoChangeGrad++; continue; }
758        if (NewNID == -2) { NumNoChangeStepSize++; continue; }
759        if (IsRowV[ui]) {
760          for (TIntFltH::TIter CI = F[NewNID].BegI(); CI < F[NewNID].EndI(); CI++) {
761            SumFV[CI.GetKey()] -= CI.GetDat();
762          }
763        } else {
764          for (TIntFltH::TIter CI = H[NewNID].BegI(); CI < H[NewNID].EndI(); CI++) {
765            SumHV[CI.GetKey()] -= CI.GetDat();
766          }
767        }
768      }
769  #pragma omp parallel for
770      for (int ui = 0; ui < NewNIDV.Len(); ui++) {
771        int NewNID = NewNIDV[ui];
772        if (NewNID < 0) { continue; }
773        if (IsRowV[ui]) {
774          F[NewNID] = NewF[ui];
775        } else {
776          H[NewNID] = NewF[ui];
777        }
778      }
779      for (int ui = 0; ui < NewNIDV.Len(); ui++) {
780        int NewNID = NewNIDV[ui];
781        if (NewNID < 0) { continue; }
782        if (IsRowV[ui]) {
783          for (TIntFltH::TIter CI = F[NewNID].BegI(); CI < F[NewNID].EndI(); CI++) {
784            SumFV[CI.GetKey()] += CI.GetDat();
785          }
786        } else {
787          for (TIntFltH::TIter CI = H[NewNID].BegI(); CI < H[NewNID].EndI(); CI++) {
788            SumHV[CI.GetKey()] += CI.GetDat();
789          }
790        }
791      }
792      for (int ui = 0; ui < NewNIDV.Len(); ui++) {
793        int NewNID = NewNIDV[ui];
794        if (NewNID < 0) { continue; }
795        TNGraph::TNodeI UI = G->GetNI(NewNID);
796        NIDOPTV[NewNID] = 0;
797        for (int e = 0; e < UI.GetDeg(); e++) {
798          NIDOPTV[UI.GetNbrNId(e)] = 0;
799        }
800      }
801      int OPTCnt = 0;
802      for (int i = 0; i < NIDOPTV.Len(); i++) { if (NIDOPTV[i] == 1) { OPTCnt++; } }
803      if ((iter - PrevIter) * ChunkSize * ChunkNum >= G->GetNodes()) {
804        PrevIter = iter;
805        double CurL = Likelihood(true);
806        IterLV.Add(TIntFltPr(iter * ChunkSize * ChunkNum, CurL));
807        printf("\r%d iterations, Likelihood: %f, Diff: %f [%lu secs]", iter, CurL,  CurL - PrevL, time(NULL) - InitTime);
808         fflush(stdout);
809        if (CurL - PrevL <= Thres * fabs(PrevL)) { 
810          break;
811        }
812        else {
813          PrevL = CurL;
814        }
815      }
816    }
817    if (! PlotNm.Empty()) {
818      printf("\nMLE completed with %d iterations(%lu secs)\n", iter, time(NULL) - InitTime);
819      TGnuPlot::PlotValV(IterLV, PlotNm + ".likelihood_Q");
820    } else {
821      printf("\rMLE completed with %d iterations(%lu secs)\n", iter, time(NULL) - InitTime);
822      fflush(stdout);
823    }
824    return iter;
825  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-fixed_array_test.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-agmdirected.cpp</div>
                </div>
                <div class="column column_space"><pre><code>160    }
161  }
162  TEST(FixedArrayRelationalsTest, UnequalArrays) {
163    for (int i = 1; i < 10; ++i) {
164      absl::FixedArray<int, 5> a1(i);
</pre></code></div>
                <div class="column column_space"><pre><code>132    }
133  }
134  void TCoda::GetNonEdgePairScores(TFltIntIntTrV& ScoreV) {
135    ScoreV.Gen(G->GetNodes() * G->GetNodes(), 0);
136    TIntV NIDV;
137    G->GetNIdV(NIDV);
138    TIntSet Cuv;
139    for (int u = 0; u < NIDV.Len(); u++) {
140      int UID = NIDV[u];
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    