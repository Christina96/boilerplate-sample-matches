
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 5.072463768115942%, Tokens: 10</h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-odbc.cpp</h3>
            <pre><code>1  #include "odbc.h"
2  #define ODBC_STR_LEN 254+1
3  TOdbcDb::TOdbcDb():
4    Ok(true), MsgStr("Ok"),
5    EnvHndP(false), EnvHnd(),
6    DbcHndP(false), DbcHnd(),
7    SchemaNmMapH(){
8    if (Ok){ 
9      OdbcAssert(SQLAllocHandle(SQL_HANDLE_ENV, SQL_NULL_HANDLE, &EnvHnd));
10      EnvHndP=true;}
11    if (Ok){ 
12      OdbcAssert(SQLSetEnvAttr(
13       EnvHnd, SQL_ATTR_ODBC_VERSION, (SQLPOINTER)SQL_OV_ODBC3, 0));}
14    if (Ok){ 
15      OdbcAssert(SQLAllocHandle(SQL_HANDLE_DBC, EnvHnd, &DbcHnd));
16      DbcHndP=true;}
17    if (Ok){ 
18      OdbcAssert(SQLSetConnectAttr(DbcHnd, SQL_LOGIN_TIMEOUT, (SQLPOINTER)5, 0));}
19  }
20  TOdbcDb::~TOdbcDb(){
21    if (DbcHndP){ 
22      SQLFreeHandle(SQL_HANDLE_DBC, DbcHnd);}
23    if (EnvHndP){ 
24      SQLFreeHandle(SQL_HANDLE_ENV, EnvHnd);}
25  }
26  void TOdbcDb::GetTbNmV(TStrV& TbNmV) const {
27    #define ODBC_STR_LEN 254+1
28    SQLCHAR       szCatalog[ODBC_STR_LEN], szSchema[ODBC_STR_LEN];
29    SQLCHAR       szTableName[ODBC_STR_LEN], szTableTypeName[ODBC_STR_LEN];
30    SQLCHAR       szRemarks[ODBC_STR_LEN];
31    SQLHSTMT      StmtHnd;
32    SQLAllocHandle(SQL_HANDLE_STMT, DbcHnd, &StmtHnd);
33    SQLLEN cbCatalog, cbSchema, cbTableName, cbTableTypeName, cbRemarks;
34    SQLRETURN RetCd=SQLTables(StmtHnd,
35     NULL, 0, &bsol;* All catalogs */
36     NULL, 0, &bsol;* All schemas */
37     NULL, 0, &bsol;* All tables */
38     NULL, 0); &bsol;* All table-typescolumns */
39    TbNmV.Clr();
40    if (RetCd == SQL_SUCCESS || RetCd == SQL_SUCCESS_WITH_INFO){
41      SQLBindCol(StmtHnd, 1, SQL_C_CHAR, szCatalog, ODBC_STR_LEN, &cbCatalog);
42      SQLBindCol(StmtHnd, 2, SQL_C_CHAR, szSchema, ODBC_STR_LEN, &cbSchema);
43      SQLBindCol(StmtHnd, 3, SQL_C_CHAR, szTableName, ODBC_STR_LEN, &cbTableName);
44      SQLBindCol(StmtHnd, 4, SQL_C_CHAR, szTableTypeName, ODBC_STR_LEN, &cbTableTypeName);
45      SQLBindCol(StmtHnd, 5, SQL_C_CHAR, szRemarks, ODBC_STR_LEN, &cbRemarks);
46      forever{
47        RetCd=SQLFetch(StmtHnd);
48        if (RetCd==SQL_SUCCESS || RetCd==SQL_SUCCESS_WITH_INFO){
49          TbNmV.Add((char*)szTableName);
50        } else {
51          break;
52        }
53      }
54    }
55    SQLFreeHandle(SQL_HANDLE_STMT, StmtHnd);
56  }
57  void TOdbcDb::GetColNmV(const TStr& TbNm, TStrV& ColNmV) const {
58    SQLCHAR       szCatalog[ODBC_STR_LEN], szSchema[ODBC_STR_LEN];
59    SQLCHAR       szTableName[ODBC_STR_LEN], szColumnName[ODBC_STR_LEN];
60    SQLCHAR       szTypeName[ODBC_STR_LEN], szRemarks[ODBC_STR_LEN];
61    SQLCHAR       szColumnDefault[ODBC_STR_LEN], szIsNullable[ODBC_STR_LEN];
62    SQLINTEGER    ColumnSize, BufferLength, CharOctetLength, OrdinalPosition;
63    SQLSMALLINT   DataType, DecimalDigits, NumPrecRadix, Nullable;
64    SQLSMALLINT   SQLDataType, DatetimeSubtypeCode;
65    SQLRETURN     RetCd;
66    SQLHSTMT      StmtHnd;
67    SQLAllocHandle(SQL_HANDLE_STMT, DbcHnd, &StmtHnd);
68    SQLLEN cbCatalog, cbSchema, cbTableName, cbColumnName;
69    SQLLEN cbDataType, cbTypeName, cbColumnSize, cbBufferLength;
70    SQLLEN cbDecimalDigits, cbNumPrecRadix, cbNullable, cbRemarks;
71    SQLLEN cbColumnDefault, cbSQLDataType, cbDatetimeSubtypeCode, cbCharOctetLength;
72    SQLLEN cbOrdinalPosition, cbIsNullable;
73    RetCd=SQLColumns(StmtHnd,
74     NULL, 0, &bsol;* All catalogs */
75     NULL, 0, &bsol;* All schemas */
76     (uchar*)TbNm.CStr(), SQL_NTS, &bsol;* table-name */
77     NULL, 0); &bsol;* All columns */
78    ColNmV.Clr();
79    if (RetCd == SQL_SUCCESS || RetCd == SQL_SUCCESS_WITH_INFO){
80      SQLBindCol(StmtHnd, 1, SQL_C_CHAR, szCatalog, ODBC_STR_LEN, &cbCatalog);
81      SQLBindCol(StmtHnd, 2, SQL_C_CHAR, szSchema, ODBC_STR_LEN, &cbSchema);
82      SQLBindCol(StmtHnd, 3, SQL_C_CHAR, szTableName, ODBC_STR_LEN, &cbTableName);
83      SQLBindCol(StmtHnd, 4, SQL_C_CHAR, szColumnName, ODBC_STR_LEN, &cbColumnName);
84      SQLBindCol(StmtHnd, 5, SQL_C_SSHORT, &DataType, 0, &cbDataType);
85      SQLBindCol(StmtHnd, 6, SQL_C_CHAR, szTypeName, ODBC_STR_LEN, &cbTypeName);
86      SQLBindCol(StmtHnd, 7, SQL_C_SLONG, &ColumnSize, 0, &cbColumnSize);
87      SQLBindCol(StmtHnd, 8, SQL_C_SLONG, &BufferLength, 0, &cbBufferLength);
88      SQLBindCol(StmtHnd, 9, SQL_C_SSHORT, &DecimalDigits, 0, &cbDecimalDigits);
89      SQLBindCol(StmtHnd, 10, SQL_C_SSHORT, &NumPrecRadix, 0, &cbNumPrecRadix);
90      SQLBindCol(StmtHnd, 11, SQL_C_SSHORT, &Nullable, 0, &cbNullable);
91      SQLBindCol(StmtHnd, 12, SQL_C_CHAR, szRemarks, ODBC_STR_LEN, &cbRemarks);
92      SQLBindCol(StmtHnd, 13, SQL_C_CHAR, szColumnDefault, ODBC_STR_LEN, &cbColumnDefault);
93      SQLBindCol(StmtHnd, 14, SQL_C_SSHORT, &SQLDataType, 0, &cbSQLDataType);
94      SQLBindCol(StmtHnd, 15, SQL_C_SSHORT, &DatetimeSubtypeCode, 0, &cbDatetimeSubtypeCode);
95      SQLBindCol(StmtHnd, 16, SQL_C_SLONG, &CharOctetLength, 0, &cbCharOctetLength);
96      SQLBindCol(StmtHnd, 17, SQL_C_SLONG, &OrdinalPosition, 0, &cbOrdinalPosition);
97      SQLBindCol(StmtHnd, 18, SQL_C_CHAR, szIsNullable, ODBC_STR_LEN, &cbIsNullable);
98      forever{
99        RetCd=SQLFetch(StmtHnd);
100        if (RetCd==SQL_SUCCESS || RetCd==SQL_SUCCESS_WITH_INFO){
101          ColNmV.Add((char*)szColumnName);
102        } else {
103          break;
104        }
105      }
106    }
107    SQLFreeHandle(SQL_HANDLE_STMT, StmtHnd);
108  }
109  void TOdbcDb::GetDataSourceNmV(TStrV& DataSourceNmV) const {
110    DataSourceNmV.Clr();
111    if (Ok){
112      SQLCHAR SrvNm[SQL_MAX_DSN_LENGTH+1];
113      SQLSMALLINT SrvNmLen;
114      SQLCHAR DescStr[SQL_MAX_DSN_LENGTH+1];
115      SQLSMALLINT DescStrLen;
116      SQLRETURN RetCd=SQLDataSources(EnvHnd, SQL_FETCH_FIRST,
117       SrvNm, SQL_MAX_DSN_LENGTH+1, &SrvNmLen,
118       DescStr, SQL_MAX_DSN_LENGTH+1, &DescStrLen);
119      while ((RetCd==SQL_SUCCESS)||(RetCd==SQL_SUCCESS_WITH_INFO)){
120        DataSourceNmV.Add((char*)SrvNm);
121        RetCd=SQLDataSources(EnvHnd, SQL_FETCH_NEXT,
122         SrvNm, SQL_MAX_DSN_LENGTH+1, &SrvNmLen,
123         DescStr, SQL_MAX_DSN_LENGTH+1, &DescStrLen);
124      }
125    }
126  }
127  bool TOdbcDb::Connect(
128   const TStr& SrvNm, const TStr& UsrNm, const TStr& PwdStr){
129    if (Ok){
130      OdbcAssert(SQLConnect(DbcHnd,
131       (SQLCHAR*)SrvNm.CStr(), SQL_NTS,
132       (SQLCHAR*)UsrNm.CStr(), SQL_NTS,
133       (SQLCHAR*)PwdStr.CStr(), SQL_NTS));
134    }
135    return Ok;
136  }
137  bool TOdbcDb::Disconnect(){
138    if (DbcHndP){ 
139      SQLFreeHandle(SQL_HANDLE_DBC, DbcHnd);
140      DbcHndP=false;
141    }
142    if (EnvHndP){ 
143      SQLFreeHandle(SQL_HANDLE_ENV, EnvHnd);
144      EnvHndP=false;
145    }
146    return true;
147  }
148  bool TOdbcDb::IsConnected(){
149    if (Ok){
150      SQLINTEGER ConnP;
151      OdbcAssert(SQLGetConnectAttr(DbcHnd,
152       SQL_ATTR_CONNECTION_DEAD, (SQLPOINTER)&ConnP, 0, NULL));
153      if (Ok){
154        return ConnP==SQL_CD_FALSE;
155      }
156    }
157    return Ok;
158  }
159  void TOdbcDb::OdbcAssert(const SQLRETURN& RetCd){
160    if ((RetCd==SQL_SUCCESS)||(RetCd==SQL_SUCCESS_WITH_INFO)){
161      Ok=true; MsgStr="Ok";
162    } else {
163      Ok=false; MsgStr=TStr::Fmt("Odbc-Db Error: %d", int(RetCd));
164    }
165  }
166  TStr TOdbcDb::GetOdbcMsgStr(
167   const SQLRETURN& RetCd, const SQLSMALLINT& HndType, const SQLHANDLE& Handle){
168    TChA MsgChA;
169    if ((RetCd==SQL_ERROR)||(RetCd==SQL_SUCCESS_WITH_INFO)){
170      SQLSMALLINT RecN=0;
171      SQLCHAR SqlState[6];
172      SQLINTEGER NativeError;
173      SQLCHAR MsgCStr[SQL_MAX_MESSAGE_LENGTH];
174      SQLSMALLINT MsgCStrLen;
175      SQLRETURN DiagRetCd;
176      do {
177        RecN++;
178        DiagRetCd=SQLGetDiagRec(
179         HndType, Handle, RecN, SqlState, &NativeError,
180         MsgCStr, sizeof(MsgCStr), &MsgCStrLen);
181        if (DiagRetCd==SQL_SUCCESS){
182          if (!MsgChA.Empty()){MsgChA+=' ';}
183          MsgChA+='['; MsgChA+=(char*)MsgCStr; MsgChA+=']';
184        }
185      } while (DiagRetCd!=SQL_NO_DATA);
186    }
187    if (MsgChA.Empty()){
188      MsgChA="Ok";}
189    return MsgChA;
190  }
191  const TStr TOdbcDb::NullStr="NULL";
192  TOdbcQuery::TOdbcQuery(const POdbcDb& _Db):
193    Ok(false), OpOk(false), MsgStr("NoOp"),
194    Db(_Db),
195    StmtHndP(false), StmtHnd(){
196    if (Db->IsOk()){ 
197      OpAssert(SQLAllocHandle(SQL_HANDLE_STMT, Db->DbcHnd, &StmtHnd));
198      if (OpOk){Ok=true; StmtHndP=true;} else {Ok=false;}
199    }
200  }
201  TOdbcQuery::~TOdbcQuery(){
202    if (StmtHndP){ 
203      SQLFreeHandle(SQL_HANDLE_STMT, StmtHnd);}
204  }
205  bool TOdbcQuery::ExeSql(const TStr& SqlStr, const TStrV& ParamStrV){
206    if (Ok){
207      OpAssert(SQLPrepare(StmtHnd, (SQLCHAR*)SqlStr.CStr(), SQL_NTS));
208      for (int ParamN=0; ParamN<ParamStrV.Len(); ParamN++){
209        TStr ParamStr=ParamStrV[ParamN];
210        if (OpOk){
211          if (ParamStr.Empty()){
212            SQLLEN StrLenOrInd=SQL_NULL_DATA;
213            OpAssert(SQLBindParameter(
214             StmtHnd, 1+ParamN, SQL_PARAM_INPUT,
215             SQL_C_CHAR, SQL_CHAR,
216             1, 0, NULL, 0, &StrLenOrInd));
<span onclick='openModal()' class='match'>217          } else
218          if (TTm::GetTmFromWebLogDateTimeStr(ParamStr).IsDef()){
219            SQLLEN StrLenOrInd=SQL_NTS;
220            OpAssert(SQLBindParameter(
221             StmtHnd, 1+ParamN, SQL_PARAM_INPUT,
222             SQL_C_CHAR, SQL_TYPE_TIMESTAMP,
223             (SQLLEN)ParamStr.Len(), 0,
224             (SQLCHAR*)ParamStr.CStr(),
225             (SQLLEN)ParamStr.Len(),
226             &StrLenOrInd));
227          } else {
228            SQLLEN StrLenOrInd=SQL_NTS;
229            OpAssert(SQLBindParameter(
230             StmtHnd, 1+ParamN, SQL_PARAM_INPUT,
231             SQL_C_CHAR, SQL_CHAR,
232             (SQLLEN)ParamStr.Len(), 0,
233             (SQLCHAR*)ParamStr.CStr(),
234             (SQLLEN)ParamStr.Len(),
235             &StrLenOrInd));
236          }
</span>237        }
238      }
239      if (OpOk){
240        OpAssert(SQLExecute(StmtHnd));
241      }
242      return OpOk;
243    } else {
244      OpOk=false;
245      return false;
246    }
247  }
248  bool TOdbcQuery::IsResultSet(){
249    if (Ok){
250      int ResultCols=GetCols();
251      if (OpOk){return ResultCols>0;} else {return false;}
252    } else {
253      OpOk=false;
254      return false;
255    }
256  }
257  int TOdbcQuery::GetCols(){
258    if (Ok){
259      SQLSMALLINT Cols;
260      OpAssert(SQLNumResultCols(StmtHnd, &Cols));
261      if (OpOk){return Cols;} else {return -1;}
262    } else {
263      OpOk=false;
264      return -1;
265    }
266  }
267  SQLLEN TOdbcQuery::GetRowsAffected(){
268    if (Ok){
269      SQLLEN RowCount;
270      OpAssert(SQLRowCount(StmtHnd, &RowCount));
271      if (OpOk){return RowCount;} else {return -1;}
272    } else {
273      OpOk=false;
274      return -1;
275    }
276  }
277  TStr TOdbcQuery::GetColNm(const int& ColN){
278    if (Ok){
279      SQLCHAR ColNm[SQL_MAX_COLUMN_NAME_LEN+1];
280      SQLSMALLINT ColNmLen;
281      SQLSMALLINT DataType;
282      SQLULEN ColumnSize;
283      SQLSMALLINT DecimalDigits;
284      SQLSMALLINT Nullable;
285      OpAssert(SQLDescribeCol(
286       StmtHnd, (SQLSMALLINT)(1+ColN),
287       ColNm, SQL_MAX_COLUMN_NAME_LEN+1, &ColNmLen,
288       &DataType, &ColumnSize, &DecimalDigits, &Nullable));
289      if (OpOk){
290        TStr Nm=(char*)ColNm;
291        if (Db->HasSchemaNmMap(Nm)){Nm=Db->MapSchemaNm(Nm);}
292        return Nm;
293      } else {return "";}
294    } else {
295      OpOk=false;
296      return "";
297    }
298  }
299  bool TOdbcQuery::NextRow(){
300    if (Ok){
301      SQLRETURN RetCd=SQLFetch(StmtHnd);
302      if ((RetCd==SQL_SUCCESS)||(RetCd==SQL_SUCCESS_WITH_INFO)){
303        OpOk=true;
304        return true;
305      } else
306      if (RetCd==SQL_NO_DATA){
307        OpOk=true;
308        return false;
309      } else {
310        OpOk=false;
311        MsgStr=TOdbcDb::GetOdbcMsgStr(RetCd, SQL_HANDLE_STMT, StmtHnd);
312        return false;
313      }
314    } else {
315      OpOk=false;
316      return false;
317    }
318  }
319  TStr TOdbcQuery::GetColVal(const int& ColN, const int& MxValStrLen){
320    if (Ok){
321      TChA ValChA(MxValStrLen);
322      SQLLEN StrLenOrInd;
323      SQLRETURN RetCd=SQLGetData(
324       StmtHnd, (SQLSMALLINT)(1+ColN),
325       SQL_C_CHAR, ValChA.CStr(), (SQLINTEGER)MxValStrLen, &StrLenOrInd);
326      if ((RetCd==SQL_SUCCESS)||(RetCd==SQL_SUCCESS_WITH_INFO)){
327        OpOk=true;
328        if (StrLenOrInd==SQL_NULL_DATA){
329          ValChA=TOdbcDb::NullStr;}
330        return ValChA;
331      } else
332      if (RetCd==SQL_NO_DATA){
333        OpOk=true;
334        return "";
335      } else {
336        OpOk=false;
337        MsgStr=TOdbcDb::GetOdbcMsgStr(RetCd, SQL_HANDLE_STMT, StmtHnd);
338        return "";
339      }
340    } else {
341      OpOk=false;
342      return "";
343    }
344  }
345  void TOdbcQuery::OpAssert(const SQLRETURN& RetCd){
346    if ((RetCd==SQL_SUCCESS)||(RetCd==SQL_SUCCESS_WITH_INFO)){
347      OpOk=true; MsgStr="Ok";
348    } else {
349      OpOk=false;
350      if (StmtHndP){
351        MsgStr=TOdbcDb::GetOdbcMsgStr(RetCd, SQL_HANDLE_STMT, StmtHnd);
352      } else {
353        MsgStr=TStr::Fmt("Odbc-Query Error: %d", int(RetCd));
354      }
355      SaveToErrLog(MsgStr.CStr());
356    }
357  }
358  TStr TOdbcQuery::GetSqlStr(const TStr& Str) {
359    TChA SqlChA; const int Chs = Str.Len();
360    for (int ChN = 0; ChN < Str.Len(); ChN++) {
361      const char Ch = Str[ChN];
362      switch (Ch) {
363        case '\'': 
364        case '"':
365        case '\\':
366        case '%':
367        case '_':
368          SqlChA += '\\';
369      }
370      SqlChA += Ch;
371    }
372    return SqlChA;
373  }
374  TOdbcTb::TOdbcTb(const POdbcQuery& Query):
375    Ok(false), MsgStr(), ColNmToNH(), UcColNmToNH(), ColNmV(), UcColNmV(), ValVV(){
376    GetData(Query);
377  }
378  void TOdbcTb::GetData(const POdbcQuery& Query){
379    Ok=false; MsgStr="NoOp";
380    ColNmV.Clr(); UcColNmV.Clr(); ColNmToNH.Clr(); UcColNmToNH.Clr(); ValVV.Clr();
381    if ((!Query.Empty())&&(Query->IsResultSet())){
382      if (!Query->IsOpOk()){MsgStr=Query->GetMsgStr(); return;}
383      int Cols=Query->GetCols();
384      if (!Query->IsOpOk()){MsgStr=Query->GetMsgStr(); return;}
385      ColNmV.Gen(Cols, 0); UcColNmV.Gen(Cols, 0);
386      for (int ColN=0; ColN<Cols; ColN++){
387        TStr ColNm=Query->GetColNm(ColN);
388        TStr UcColNm=ColNm.GetUc();
389        if (!Query->IsOpOk()){MsgStr=Query->GetMsgStr(); return;}
390        ColNmV.Add(ColNm); ColNmToNH.AddDat(ColNm, ColN);
391        UcColNmV.Add(ColNm); UcColNmToNH.AddDat(UcColNm, ColN);
392      }
393      int RowN=0;
394      while (Query->NextRow()){
395        if (!Query->IsOpOk()){MsgStr=Query->GetMsgStr(); return;}
396        ValVV.Add(); ValVV.Last().Gen(Cols, 0);
397        for (int ColN=0; ColN<Cols; ColN++){
398          TStr ColVal=Query->GetColVal(ColN);
399          if (!Query->IsOpOk()){MsgStr=Query->GetMsgStr(); return;}
400          if (ColVal!=TOdbcDb::NullStr){ValVV.Last().Add(ColVal);}
401          else {ValVV.Last().Add("");}
402        }
403        RowN++;
404      }
405      Ok=true;
406    }
407  }
408  int TOdbcTb::GetColN(const TStr& ColNm) const {
409    TInt ColN;
410    if (ColNmToNH.IsKeyGetDat(ColNm, ColN)){
411      return ColN;
412    } else {
413      return UcColNmToNH.GetDat(ColNm.GetUc());
414    }
415  }
416  TStr TOdbcTb::GetRowVal(const int& RowN, const int& ColN) const {
417    TStr ValStr=ValVV[RowN][ColN];
418    return ValStr;
419  }
420  TTm TOdbcTb::GetRowValTm(const int& RowN, const TStr& ColNm) const {
421    TStr TmStr=GetRowVal(RowN, GetColN(ColNm));
422    TTm Tm=TTm::GetTmFromWebLogDateTimeStr(TmStr);
423    return Tm;
424  }
425  void TOdbcTb::Dump() const {
426    if (Ok){
427      for (int ColN=0; ColN<GetCols(); ColN++){
428        printf("C%d:[%s]", ColN, GetColNm(ColN).CStr());}
429      printf("\n");
430      for (int RowN=0; RowN<GetRows(); RowN++){
431        printf("R%d:", RowN);
432        for (int ColN=0; ColN<GetCols(); ColN++){
433          TStr ColVal=GetRowVal(RowN, ColN);
434          printf(" C%d:[%s]", ColN, ColVal.CStr());
435        }
436        printf("\n");
437      }
438    } else {
439      printf("Error\n");
440    }
441  }
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-tospace.cpp</h3>
            <pre><code>1  #include "drawtord.h"
2  #include "statistc.h"
3  #include "textord.h"
4  #include "tovars.h"
5  #ifdef HAVE_CONFIG_H
6  #  include "config_auto.h"
7  #endif
8  #include <algorithm>
9  #include <cmath>
10  #include <memory>
11  #define MAXSPACING 128 &bsol;*max expected spacing in pix */
12  namespace tesseract {
13  void Textord::to_spacing(ICOORD page_tr,       
14                           TO_BLOCK_LIST *blocks 
15  ) {
16    TO_BLOCK_IT block_it; 
17    TO_BLOCK *block;      
18    TO_ROW *row;          
19    int block_index;      
20    int row_index;        
21    int16_t block_space_gap_width;
22    int16_t block_non_space_gap_width;
23    bool old_text_ord_proportional; 
24    block_it.set_to_list(blocks);
25    block_index = 1;
26    for (block_it.mark_cycle_pt(); !block_it.cycled_list(); block_it.forward()) {
27      block = block_it.data();
28      std::unique_ptr<GAPMAP> gapmap(new GAPMAP(block)); 
29      block_spacing_stats(block, gapmap.get(), old_text_ord_proportional, block_space_gap_width,
30                          block_non_space_gap_width);
31      if (tosp_old_to_method && tosp_old_to_constrain_sp_kn &&
32          block_non_space_gap_width > block_space_gap_width / 3) {
33        block_non_space_gap_width = block_space_gap_width / 3;
34      }
35      TO_ROW_IT row_it(block->get_rows());
36      row_index = 1;
37      for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
38        row = row_it.data();
39        if ((row->pitch_decision == PITCH_DEF_PROP) || (row->pitch_decision == PITCH_CORR_PROP)) {
40          if ((tosp_debug_level > 0) && !old_text_ord_proportional) {
41            tprintf("Block %d Row %d: Now Proportional\n", block_index, row_index);
42          }
43          row_spacing_stats(row, gapmap.get(), block_index, row_index, block_space_gap_width,
44                            block_non_space_gap_width);
45        } else {
46          if ((tosp_debug_level > 0) && old_text_ord_proportional) {
47            tprintf("Block %d Row %d: Now Fixed Pitch Decision:%d fp flag:%f\n", block_index,
48                    row_index, row->pitch_decision, row->fixed_pitch);
49          }
50        }
51  #ifndef GRAPHICS_DISABLED
52        if (textord_show_initial_words) {
53          plot_word_decisions(to_win, static_cast<int16_t>(row->fixed_pitch), row);
54        }
55  #endif
56        row_index++;
57      }
58      block_index++;
59    }
60  }
61  void Textord::block_spacing_stats(TO_BLOCK *block, GAPMAP *gapmap, bool &old_text_ord_proportional,
62                                    int16_t &block_space_gap_width,    
63                                    int16_t &block_non_space_gap_width 
64  ) {
65    TO_ROW *row;         
66    BLOBNBOX_IT blob_it; 
67    STATS centre_to_centre_stats(0, MAXSPACING - 1);
68    STATS all_gap_stats(0, MAXSPACING - 1);
69    STATS space_gap_stats(0, MAXSPACING - 1);
70    int16_t minwidth = MAXSPACING; 
71    TBOX blob_box;
72    TBOX prev_blob_box;
73    int16_t centre_to_centre;
74    int16_t gap_width;
75    float real_space_threshold;
76    float iqr_centre_to_centre; 
77    float iqr_all_gap_stats;    
78    int32_t end_of_row;
79    int32_t row_length;
80    TO_ROW_IT row_it(block->get_rows());
81    for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
82      row = row_it.data();
83      if (!row->blob_list()->empty() &&
84          (!tosp_only_use_prop_rows || (row->pitch_decision == PITCH_DEF_PROP) ||
85           (row->pitch_decision == PITCH_CORR_PROP))) {
86        blob_it.set_to_list(row->blob_list());
87        blob_it.mark_cycle_pt();
88        end_of_row = blob_it.data_relative(-1)->bounding_box().right();
89        if (tosp_use_pre_chopping) {
90          blob_box = box_next_pre_chopped(&blob_it);
<span onclick='openModal()' class='match'>91        } else if (tosp_stats_use_xht_gaps) {
92          blob_box = reduced_box_next(row, &blob_it);
93        } else {
94          blob_box = box_next(&blob_it);
95        }
</span>96        row_length = end_of_row - blob_box.left();
97        if (blob_box.width() < minwidth) {
98          minwidth = blob_box.width();
99        }
100        prev_blob_box = blob_box;
101        while (!blob_it.cycled_list()) {
102          if (tosp_use_pre_chopping) {
103            blob_box = box_next_pre_chopped(&blob_it);
104          } else if (tosp_stats_use_xht_gaps) {
105            blob_box = reduced_box_next(row, &blob_it);
106          } else {
107            blob_box = box_next(&blob_it);
108          }
109          if (blob_box.width() < minwidth) {
110            minwidth = blob_box.width();
111          }
112          int16_t left = prev_blob_box.right();
113          int16_t right = blob_box.left();
114          gap_width = right - left;
115          if (!ignore_big_gap(row, row_length, gapmap, left, right)) {
116            all_gap_stats.add(gap_width, 1);
117            centre_to_centre = (right + blob_box.right() - (prev_blob_box.left() + left)) / 2;
118            centre_to_centre_stats.add(centre_to_centre, 1);
119          }
120          prev_blob_box = blob_box;
121        }
122      }
123    }
124    if (all_gap_stats.get_total() <= 1) {
125      block_non_space_gap_width = minwidth;
126      block_space_gap_width = -1; 
127      old_text_ord_proportional = true;
128    } else {
129      iqr_centre_to_centre = centre_to_centre_stats.ile(0.75) - centre_to_centre_stats.ile(0.25);
130      iqr_all_gap_stats = all_gap_stats.ile(0.75) - all_gap_stats.ile(0.25);
131      old_text_ord_proportional = iqr_centre_to_centre * 2 > iqr_all_gap_stats;
132      block_non_space_gap_width = static_cast<int16_t>(floor(all_gap_stats.median()));
133      row_it.set_to_list(block->get_rows());
134      for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
135        row = row_it.data();
136        if (!row->blob_list()->empty() &&
137            (!tosp_only_use_prop_rows || (row->pitch_decision == PITCH_DEF_PROP) ||
138             (row->pitch_decision == PITCH_CORR_PROP))) {
139          real_space_threshold = std::max(tosp_init_guess_kn_mult * block_non_space_gap_width,
140                                          tosp_init_guess_xht_mult * row->xheight);
141          blob_it.set_to_list(row->blob_list());
142          blob_it.mark_cycle_pt();
143          end_of_row = blob_it.data_relative(-1)->bounding_box().right();
144          if (tosp_use_pre_chopping) {
145            blob_box = box_next_pre_chopped(&blob_it);
146          } else if (tosp_stats_use_xht_gaps) {
147            blob_box = reduced_box_next(row, &blob_it);
148          } else {
149            blob_box = box_next(&blob_it);
150          }
151          row_length = blob_box.left() - end_of_row;
152          prev_blob_box = blob_box;
153          while (!blob_it.cycled_list()) {
154            if (tosp_use_pre_chopping) {
155              blob_box = box_next_pre_chopped(&blob_it);
156            } else if (tosp_stats_use_xht_gaps) {
157              blob_box = reduced_box_next(row, &blob_it);
158            } else {
159              blob_box = box_next(&blob_it);
160            }
161            int16_t left = prev_blob_box.right();
162            int16_t right = blob_box.left();
163            gap_width = right - left;
164            if ((gap_width > real_space_threshold) &&
165                !ignore_big_gap(row, row_length, gapmap, left, right)) {
166              if (!tosp_block_use_cert_spaces ||
167                  (gap_width > tosp_fuzzy_space_factor2 * row->xheight) ||
168                  ((gap_width > tosp_fuzzy_space_factor1 * row->xheight) &&
169                   (!tosp_narrow_blobs_not_cert ||
170                    (!narrow_blob(row, prev_blob_box) && !narrow_blob(row, blob_box)))) ||
171                  (wide_blob(row, prev_blob_box) && wide_blob(row, blob_box))) {
172                space_gap_stats.add(gap_width, 1);
173              }
174            }
175            prev_blob_box = blob_box;
176          }
177        }
178      }
179      if (space_gap_stats.get_total() <= 2) {
180        block_space_gap_width = -1; 
181      } else {
182        block_space_gap_width = std::max(static_cast<int16_t>(floor(space_gap_stats.median())),
183                                         static_cast<int16_t>(3 * block_non_space_gap_width));
184      }
185    }
186  }
187  void Textord::row_spacing_stats(TO_ROW *row, GAPMAP *gapmap, int16_t block_idx, int16_t row_idx,
188                                  int16_t block_space_gap_width,    
189                                  int16_t block_non_space_gap_width 
190  ) {
191    BLOBNBOX_IT blob_it = row->blob_list();
192    STATS all_gap_stats(0, MAXSPACING - 1);
193    STATS cert_space_gap_stats(0, MAXSPACING - 1);
194    STATS all_space_gap_stats(0, MAXSPACING - 1);
195    STATS small_gap_stats(0, MAXSPACING - 1);
196    TBOX blob_box;
197    TBOX prev_blob_box;
198    int16_t gap_width;
199    int16_t real_space_threshold = 0;
200    int16_t max = 0;
201    int16_t index;
202    int16_t large_gap_count = 0;
203    bool suspected_table;
204    int32_t max_max_nonspace; 
205    bool good_block_space_estimate = block_space_gap_width > 0;
206    int32_t end_of_row;
207    int32_t row_length = 0;
208    float sane_space;
209    int32_t sane_threshold;
210    if (!good_block_space_estimate) {
211      block_space_gap_width = int16_t(std::floor(row->xheight / 2));
212    }
213    if (!row->blob_list()->empty()) {
214      if (tosp_threshold_bias1 > 0) {
215        real_space_threshold =
216            block_non_space_gap_width +
217            int16_t(floor(0.5 + tosp_threshold_bias1 *
218                                    (block_space_gap_width - block_non_space_gap_width)));
219      } else {
220        real_space_threshold = 
221            (block_space_gap_width + block_non_space_gap_width) / 2;
222      }
223      blob_it.set_to_list(row->blob_list());
224      blob_it.mark_cycle_pt();
225      end_of_row = blob_it.data_relative(-1)->bounding_box().right();
226      if (tosp_use_pre_chopping) {
227        blob_box = box_next_pre_chopped(&blob_it);
228      } else if (tosp_stats_use_xht_gaps) {
229        blob_box = reduced_box_next(row, &blob_it);
230      } else {
231        blob_box = box_next(&blob_it);
232      }
233      row_length = end_of_row - blob_box.left();
234      prev_blob_box = blob_box;
235      while (!blob_it.cycled_list()) {
236        if (tosp_use_pre_chopping) {
237          blob_box = box_next_pre_chopped(&blob_it);
238        } else if (tosp_stats_use_xht_gaps) {
239          blob_box = reduced_box_next(row, &blob_it);
240        } else {
241          blob_box = box_next(&blob_it);
242        }
243        int16_t left = prev_blob_box.right();
244        int16_t right = blob_box.left();
245        gap_width = right - left;
246        if (ignore_big_gap(row, row_length, gapmap, left, right)) {
247          large_gap_count++;
248        } else {
249          if (gap_width >= real_space_threshold) {
250            if (!tosp_row_use_cert_spaces || (gap_width > tosp_fuzzy_space_factor2 * row->xheight) ||
251                ((gap_width > tosp_fuzzy_space_factor1 * row->xheight) &&
252                 (!tosp_narrow_blobs_not_cert ||
253                  (!narrow_blob(row, prev_blob_box) && !narrow_blob(row, blob_box)))) ||
254                (wide_blob(row, prev_blob_box) && wide_blob(row, blob_box))) {
255              cert_space_gap_stats.add(gap_width, 1);
256            }
257            all_space_gap_stats.add(gap_width, 1);
258          } else {
259            small_gap_stats.add(gap_width, 1);
260          }
261          all_gap_stats.add(gap_width, 1);
262        }
263        prev_blob_box = blob_box;
264      }
265    }
266    suspected_table = (large_gap_count > 1) ||
267                      ((large_gap_count > 0) && (all_gap_stats.get_total() <= tosp_few_samples));
268    if ((cert_space_gap_stats.get_total() >= tosp_enough_space_samples_for_median) ||
269        ((suspected_table || all_gap_stats.get_total() <= tosp_short_row) &&
270         cert_space_gap_stats.get_total() > 0)) {
271      old_to_method(row, &all_gap_stats, &cert_space_gap_stats, &small_gap_stats,
272                    block_space_gap_width, block_non_space_gap_width);
273    } else {
274      if (!tosp_recovery_isolated_row_stats ||
275          !isolated_row_stats(row, gapmap, &all_gap_stats, suspected_table, block_idx, row_idx)) {
276        if (tosp_row_use_cert_spaces && (tosp_debug_level > 5)) {
277          tprintf("B:%d R:%d -- Inadequate certain spaces.\n", block_idx, row_idx);
278        }
279        if (tosp_row_use_cert_spaces1 && good_block_space_estimate) {
280          row->space_size = block_space_gap_width;
281          if (all_gap_stats.get_total() > tosp_redo_kern_limit) {
282            row->kern_size = all_gap_stats.median();
283          } else {
284            row->kern_size = block_non_space_gap_width;
285          }
286          row->space_threshold =
287              int32_t(floor((row->space_size + row->kern_size) / tosp_old_sp_kn_th_factor));
288        } else {
289          old_to_method(row, &all_gap_stats, &all_space_gap_stats, &small_gap_stats,
290                        block_space_gap_width, block_non_space_gap_width);
291        }
292      }
293    }
294    if (tosp_improve_thresh && !suspected_table) {
295      improve_row_threshold(row, &all_gap_stats);
296    }
297    if (tosp_sanity_method == 0) {
298      if (suspected_table && (row->space_size < tosp_table_kn_sp_ratio * row->kern_size)) {
299        if (tosp_debug_level > 5) {
300          tprintf("B:%d R:%d -- DON'T BELIEVE SPACE %3.2f %d %3.2f.\n", block_idx, row_idx,
301                  row->kern_size, row->space_threshold, row->space_size);
302        }
303        row->space_threshold = static_cast<int32_t>(tosp_table_kn_sp_ratio * row->kern_size);
304        row->space_size = std::max(row->space_threshold + 1.0f, row->xheight);
305      }
306    } else if (tosp_sanity_method == 1) {
307      sane_space = row->space_size;
308      if ((row->space_size < tosp_min_sane_kn_sp * std::max(row->kern_size, 2.5f)) ||
309          ((row->space_size - row->kern_size) < (tosp_silly_kn_sp_gap * row->xheight))) {
310        if (good_block_space_estimate &&
311            (block_space_gap_width >= tosp_min_sane_kn_sp * row->kern_size)) {
312          sane_space = block_space_gap_width;
313        } else {
314          sane_space =
315              std::max(static_cast<float>(tosp_min_sane_kn_sp) * std::max(row->kern_size, 2.5f),
316                       row->xheight / 2.0f);
317        }
318        if (tosp_debug_level > 5) {
319          tprintf("B:%d R:%d -- DON'T BELIEVE SPACE %3.2f %d %3.2f -> %3.2f.\n", block_idx, row_idx,
320                  row->kern_size, row->space_threshold, row->space_size, sane_space);
321        }
322        row->space_size = sane_space;
323        row->space_threshold =
324            int32_t(floor((row->space_size + row->kern_size) / tosp_old_sp_kn_th_factor));
325      }
326      sane_threshold = int32_t(floor(tosp_max_sane_kn_thresh * std::max(row->kern_size, 2.5f)));
327      if (row->space_threshold > sane_threshold) {
328        if (tosp_debug_level > 5) {
329          tprintf("B:%d R:%d -- DON'T BELIEVE THRESH %3.2f %d %3.2f->%d.\n", block_idx, row_idx,
330                  row->kern_size, row->space_threshold, row->space_size, sane_threshold);
331        }
332        row->space_threshold = sane_threshold;
333        if (row->space_size <= sane_threshold) {
334          row->space_size = row->space_threshold + 1.0f;
335        }
336      }
337      if (suspected_table) {
338        sane_space =
339            std::max(tosp_table_kn_sp_ratio * row->kern_size, tosp_table_xht_sp_ratio * row->xheight);
340        sane_threshold = int32_t(std::floor((sane_space + row->kern_size) / 2));
341        if ((row->space_size < sane_space) || (row->space_threshold < sane_threshold)) {
342          if (tosp_debug_level > 5) {
343            tprintf("B:%d R:%d -- SUSPECT NO SPACES %3.2f %d %3.2f.\n", block_idx, row_idx,
344                    row->kern_size, row->space_threshold, row->space_size);
345          }
346          row->space_threshold = static_cast<int32_t>(sane_space);
347          row->space_size = std::max(row->space_threshold + 1.0f, row->xheight);
348        }
349      }
350    }
351    if (tosp_old_to_method) {
352      row->max_nonspace = row->space_threshold;
353      row->min_space = row->space_threshold + 1;
354    } else {
355      row->min_space =
356          std::min(int32_t(ceil(tosp_fuzzy_space_factor * row->xheight)), int32_t(row->space_size));
357      if (row->min_space <= row->space_threshold) {
358        row->min_space = row->space_threshold + 1;
359      }
360      max_max_nonspace = int32_t((row->space_threshold + row->kern_size) / 2);
361      row->max_nonspace = max_max_nonspace;
362      for (index = 0; index <= max_max_nonspace; index++) {
363        if (all_gap_stats.pile_count(index) > max) {
364          max = all_gap_stats.pile_count(index);
365        }
366        if ((index > row->kern_size) && (all_gap_stats.pile_count(index) < 0.1 * max)) {
367          row->max_nonspace = index;
368          break;
369        }
370      }
371    }
372    if ((tosp_fuzzy_sp_fraction > 0) && (row->space_size > row->space_threshold)) {
373      row->min_space = std::max(
374          row->min_space, static_cast<int32_t>(ceil(row->space_threshold +
375                                                    tosp_fuzzy_sp_fraction *
376                                                        (row->space_size - row->space_threshold))));
377    }
378    if ((tosp_table_fuzzy_kn_sp_ratio > 0) && (suspected_table || tosp_fuzzy_limit_all)) {
379      row->min_space = std::max(
380          row->min_space, static_cast<int32_t>(ceil(tosp_table_fuzzy_kn_sp_ratio * row->kern_size)));
381    }
382    if ((tosp_fuzzy_kn_fraction > 0) && (row->kern_size < row->space_threshold)) {
383      row->max_nonspace = static_cast<int32_t>(floor(
384          0.5 + row->kern_size + tosp_fuzzy_kn_fraction * (row->space_threshold - row->kern_size)));
385    }
386    if (row->max_nonspace > row->space_threshold) {
387      row->max_nonspace = row->space_threshold;
388    }
389    if (tosp_debug_level > 5) {
390      tprintf(
391          "B:%d R:%d L:%d-- Kn:%d Sp:%d Thr:%d -- Kn:%3.2f (%d) Thr:%d (%d) "
392          "Sp:%3.2f\n",
393          block_idx, row_idx, row_length, block_non_space_gap_width, block_space_gap_width,
394          real_space_threshold, row->kern_size, row->max_nonspace, row->space_threshold,
395          row->min_space, row->space_size);
396    }
397    if (tosp_debug_level > 10) {
398      tprintf(
399          "row->kern_size = %3.2f, row->space_size = %3.2f, "
400          "row->space_threshold = %d\n",
401          row->kern_size, row->space_size, row->space_threshold);
402    }
403  }
404  void Textord::old_to_method(TO_ROW *row, STATS *all_gap_stats, STATS *space_gap_stats,
405                              STATS *small_gap_stats,
406                              int16_t block_space_gap_width,    
407                              int16_t block_non_space_gap_width 
408  ) {
409    if (space_gap_stats->get_total() >= tosp_enough_space_samples_for_median) {
410      row->space_size = space_gap_stats->median();
411      if (row->space_size > block_space_gap_width * 1.5) {
412        if (tosp_old_to_bug_fix) {
413          row->space_size = block_space_gap_width * 1.5;
414        } else {
415          row->space_size = block_space_gap_width;
416        }
417      }
418      if (row->space_size < (block_non_space_gap_width * 2) + 1) {
419        row->space_size = (block_non_space_gap_width * 2) + 1;
420      }
421    }
422    else if (space_gap_stats->get_total() >= 1) {
423      row->space_size = space_gap_stats->mean();
424      if (row->space_size > block_space_gap_width * 1.5) {
425        if (tosp_old_to_bug_fix) {
426          row->space_size = block_space_gap_width * 1.5;
427        } else {
428          row->space_size = block_space_gap_width;
429        }
430      }
431      if (row->space_size < (block_non_space_gap_width * 3) + 1) {
432        row->space_size = (block_non_space_gap_width * 3) + 1;
433      }
434    } else {
435      row->space_size = block_space_gap_width;
436    }
437    if ((tosp_only_small_gaps_for_kern) && (small_gap_stats->get_total() > tosp_redo_kern_limit)) {
438      row->kern_size = small_gap_stats->median();
439    } else if (all_gap_stats->get_total() > tosp_redo_kern_limit) {
440      row->kern_size = all_gap_stats->median();
441    } else { 
442      row->kern_size = block_non_space_gap_width;
443    }
444    if (tosp_threshold_bias2 > 0) {
445      row->space_threshold = int32_t(
446          floor(0.5 + row->kern_size + tosp_threshold_bias2 * (row->space_size - row->kern_size)));
447    } else {
448      row->space_threshold = int32_t(std::floor((row->space_size + row->kern_size) / 2));
449    }
450    if (tosp_old_to_constrain_sp_kn && tosp_sanity_method == 1 &&
451        ((row->space_size < tosp_min_sane_kn_sp * std::max(row->kern_size, 2.5f)) ||
452         ((row->space_size - row->kern_size) < tosp_silly_kn_sp_gap * row->xheight))) {
453      if (row->kern_size > 2.5) {
454        row->kern_size = row->space_size / tosp_min_sane_kn_sp;
455      }
456      row->space_threshold =
457          int32_t(floor((row->space_size + row->kern_size) / tosp_old_sp_kn_th_factor));
458    }
459  }
460  bool Textord::isolated_row_stats(TO_ROW *row, GAPMAP *gapmap, STATS *all_gap_stats,
461                                   bool suspected_table, int16_t block_idx, int16_t row_idx) {
462    float kern_estimate;
463    float crude_threshold_estimate;
464    int16_t small_gaps_count;
465    int16_t total;
466    BLOBNBOX_IT blob_it = row->blob_list();
467    STATS cert_space_gap_stats(0, MAXSPACING - 1);
468    STATS all_space_gap_stats(0, MAXSPACING - 1);
469    STATS small_gap_stats(0, MAXSPACING - 1);
470    TBOX blob_box;
471    TBOX prev_blob_box;
472    int16_t gap_width;
473    int32_t end_of_row;
474    int32_t row_length;
475    kern_estimate = all_gap_stats->median();
476    crude_threshold_estimate =
477        std::max(tosp_init_guess_kn_mult * kern_estimate, tosp_init_guess_xht_mult * row->xheight);
478    small_gaps_count =
479        stats_count_under(all_gap_stats, static_cast<int16_t>(std::ceil(crude_threshold_estimate)));
480    total = all_gap_stats->get_total();
481    if ((total <= tosp_redo_kern_limit) ||
482        ((small_gaps_count / static_cast<float>(total)) < tosp_enough_small_gaps) ||
483        (total - small_gaps_count < 1)) {
484      if (tosp_debug_level > 5) {
485        tprintf("B:%d R:%d -- Can't do isolated row stats.\n", block_idx, row_idx);
486      }
487      return false;
488    }
489    blob_it.set_to_list(row->blob_list());
490    blob_it.mark_cycle_pt();
491    end_of_row = blob_it.data_relative(-1)->bounding_box().right();
492    if (tosp_use_pre_chopping) {
493      blob_box = box_next_pre_chopped(&blob_it);
494    } else if (tosp_stats_use_xht_gaps) {
495      blob_box = reduced_box_next(row, &blob_it);
496    } else {
497      blob_box = box_next(&blob_it);
498    }
499    row_length = end_of_row - blob_box.left();
500    prev_blob_box = blob_box;
501    while (!blob_it.cycled_list()) {
502      if (tosp_use_pre_chopping) {
503        blob_box = box_next_pre_chopped(&blob_it);
504      } else if (tosp_stats_use_xht_gaps) {
505        blob_box = reduced_box_next(row, &blob_it);
506      } else {
507        blob_box = box_next(&blob_it);
508      }
509      int16_t left = prev_blob_box.right();
510      int16_t right = blob_box.left();
511      gap_width = right - left;
512      if (!ignore_big_gap(row, row_length, gapmap, left, right) &&
513          (gap_width > crude_threshold_estimate)) {
514        if ((gap_width > tosp_fuzzy_space_factor2 * row->xheight) ||
515            ((gap_width > tosp_fuzzy_space_factor1 * row->xheight) &&
516             (!tosp_narrow_blobs_not_cert ||
517              (!narrow_blob(row, prev_blob_box) && !narrow_blob(row, blob_box)))) ||
518            (wide_blob(row, prev_blob_box) && wide_blob(row, blob_box))) {
519          cert_space_gap_stats.add(gap_width, 1);
520        }
521        all_space_gap_stats.add(gap_width, 1);
522      }
523      if (gap_width < crude_threshold_estimate) {
524        small_gap_stats.add(gap_width, 1);
525      }
526      prev_blob_box = blob_box;
527    }
528    if (cert_space_gap_stats.get_total() >= tosp_enough_space_samples_for_median) {
529      row->space_size = cert_space_gap_stats.median();
530    } else if (suspected_table && (cert_space_gap_stats.get_total() > 0)) {
531      row->space_size = cert_space_gap_stats.mean();
532    } else if (all_space_gap_stats.get_total() >= tosp_enough_space_samples_for_median) {
533      row->space_size = all_space_gap_stats.median();
534    } else {
535      row->space_size = all_space_gap_stats.mean();
536    }
537    if (tosp_only_small_gaps_for_kern) {
538      row->kern_size = small_gap_stats.median();
539    } else {
540      row->kern_size = all_gap_stats->median();
541    }
542    row->space_threshold = int32_t(std::floor((row->space_size + row->kern_size) / 2));
543    if ((row->kern_size >= row->space_threshold) || (row->space_threshold >= row->space_size) ||
544        (row->space_threshold <= 0)) {
545      if (tosp_debug_level > 5) {
546        tprintf("B:%d R:%d -- Isolated row stats SANITY FAILURE: %f %d %f\n", block_idx, row_idx,
547                row->kern_size, row->space_threshold, row->space_size);
548      }
549      row->kern_size = 0.0f;
550      row->space_threshold = 0;
551      row->space_size = 0.0f;
552      return false;
553    }
554    if (tosp_debug_level > 5) {
555      tprintf("B:%d R:%d -- Isolated row stats: %f %d %f\n", block_idx, row_idx, row->kern_size,
556              row->space_threshold, row->space_size);
557    }
558    return true;
559  }
560  int16_t Textord::stats_count_under(STATS *stats, int16_t threshold) {
561    int16_t index;
562    int16_t total = 0;
563    for (index = 0; index < threshold; index++) {
564      total += stats->pile_count(index);
565    }
566    return total;
567  }
568  void Textord::improve_row_threshold(TO_ROW *row, STATS *all_gap_stats) {
569    float sp = row->space_size;
570    float kn = row->kern_size;
571    int16_t reqd_zero_width = 0;
572    int16_t zero_width = 0;
573    int16_t zero_start = 0;
574    int16_t index = 0;
575    if (tosp_debug_level > 10) {
576      tprintf("Improve row threshold 0");
577    }
578    if ((all_gap_stats->get_total() <= 25) || (sp <= 10) || (sp <= 3 * kn) ||
579        (stats_count_under(all_gap_stats, static_cast<int16_t>(ceil(kn + (sp - kn) / 3 + 0.5))) <
580         (0.75 * all_gap_stats->get_total()))) {
581      return;
582    }
583    if (tosp_debug_level > 10) {
584      tprintf(" 1");
585    }
586    reqd_zero_width = static_cast<int16_t>(floor((sp - kn) / 3 + 0.5));
587    if (reqd_zero_width < 3) {
588      reqd_zero_width = 3;
589    }
590    for (index = int16_t(std::ceil(kn)); index < int16_t(std::floor(sp)); index++) {
591      if (all_gap_stats->pile_count(index) == 0) {
592        if (zero_width == 0) {
593          zero_start = index;
594        }
595        zero_width++;
596      } else {
597        if (zero_width >= reqd_zero_width) {
598          break;
599        } else {
600          zero_width = 0;
601        }
602      }
603    }
604    index--;
605    if (tosp_debug_level > 10) {
606      tprintf(" reqd_z_width: %d found %d 0's, starting %d; thresh: %d/n", reqd_zero_width,
607              zero_width, zero_start, row->space_threshold);
608    }
609    if ((zero_width < reqd_zero_width) ||
610        ((row->space_threshold >= zero_start) && (row->space_threshold <= index))) {
611      return;
612    }
613    if (tosp_debug_level > 10) {
614      tprintf(" 2");
615    }
616    if (row->space_threshold < zero_start) {
617      if (tosp_debug_level > 5) {
618        tprintf("Improve row kn:%5.2f sp:%5.2f 0's: %d -> %d  thresh:%d -> %d\n", kn, sp, zero_start,
619                index, row->space_threshold, zero_start);
620      }
621      row->space_threshold = zero_start;
622    }
623    if (row->space_threshold > index) {
624      if (tosp_debug_level > 5) {
625        tprintf("Improve row kn:%5.2f sp:%5.2f 0's: %d -> %d  thresh:%d -> %d\n", kn, sp, zero_start,
626                index, row->space_threshold, index);
627      }
628      row->space_threshold = index;
629    }
630  }
631  ROW *Textord::make_prop_words(TO_ROW *row,    
632                                FCOORD rotation 
633  ) {
634    bool bol; 
635    bool prev_fuzzy_sp;     
636    bool prev_fuzzy_non;    
637    uint8_t prev_blanks;    
638    bool fuzzy_sp = false;  
639    bool fuzzy_non = false; 
640    uint8_t blanks = 0;     
641    bool prev_gap_was_a_space = false;
642    bool break_at_next_gap = false;
643    ROW *real_row; 
644    C_OUTLINE_IT cout_it;
645    C_BLOB_LIST cblobs;
646    C_BLOB_IT cblob_it = &cblobs;
647    WERD_LIST words;
648    WERD *word; 
649    int32_t next_rep_char_word_right = INT32_MAX;
650    float repetition_spacing; 
651    int32_t xstarts[2];       
652    int32_t prev_x;           
653    BLOBNBOX_IT box_it;       
654    TBOX prev_blob_box;
655    TBOX next_blob_box;
656    int16_t prev_gap = INT16_MAX;
657    int16_t current_gap = INT16_MAX;
658    int16_t next_gap = INT16_MAX;
659    int16_t prev_within_xht_gap = INT16_MAX;
660    int16_t current_within_xht_gap = INT16_MAX;
661    int16_t next_within_xht_gap = INT16_MAX;
662    int16_t word_count = 0;
663    WERD_IT rep_char_it(&(row->rep_words));
664    if (!rep_char_it.empty()) {
665      next_rep_char_word_right = rep_char_it.data()->bounding_box().right();
666    }
667    prev_x = -INT16_MAX;
668    cblob_it.set_to_list(&cblobs);
669    box_it.set_to_list(row->blob_list());
670    WERD_IT word_it(&words);
671    bol = true;
672    prev_blanks = 0;
673    prev_fuzzy_sp = false;
674    prev_fuzzy_non = false;
675    if (!box_it.empty()) {
676      xstarts[0] = box_it.data()->bounding_box().left();
677      if (xstarts[0] > next_rep_char_word_right) {
678        word = rep_char_it.extract();
679        word_it.add_after_then_move(word);
680        word->set_flag(W_BOL, true);
681        bol = false;
682        word->set_blanks(0);
683        word->set_flag(W_FUZZY_SP, false);
684        word->set_flag(W_FUZZY_NON, false);
685        xstarts[0] = word->bounding_box().left();
686        repetition_spacing = find_mean_blob_spacing(word);
687        current_gap = box_it.data()->bounding_box().left() - next_rep_char_word_right;
688        current_within_xht_gap = current_gap;
689        if (current_gap > tosp_rep_space * repetition_spacing) {
690          prev_blanks = static_cast<uint8_t>(std::floor(current_gap / row->space_size));
691          if (prev_blanks < 1) {
692            prev_blanks = 1;
693          }
694        } else {
695          prev_blanks = 0;
696        }
697        if (tosp_debug_level > 5) {
698          tprintf("Repch wd at BOL(%d, %d). rep spacing %5.2f;  Rgap:%d  ",
699                  box_it.data()->bounding_box().left(), box_it.data()->bounding_box().bottom(),
700                  repetition_spacing, current_gap);
701        }
702        prev_fuzzy_sp = false;
703        prev_fuzzy_non = false;
704        if (rep_char_it.empty()) {
705          next_rep_char_word_right = INT32_MAX;
706        } else {
707          rep_char_it.forward();
708          next_rep_char_word_right = rep_char_it.data()->bounding_box().right();
709        }
710      }
711      peek_at_next_gap(row, box_it, next_blob_box, next_gap, next_within_xht_gap);
712      do {
713        auto bblob = box_it.data();
714        auto blob_box = bblob->bounding_box();
715        if (bblob->joined_to_prev()) {
716          auto cblob = bblob->remove_cblob();
717          if (cblob != nullptr) {
718            cout_it.set_to_list(cblob_it.data()->out_list());
719            cout_it.move_to_last();
720            cout_it.add_list_after(cblob->out_list());
721            delete cblob;
722          }
723        } else {
724          auto cblob = bblob->cblob();
725          if (cblob != nullptr) {
726            bblob->set_owns_cblob(false);
727            cblob_it.add_after_then_move(cblob);
728          }
729          prev_x = blob_box.right();
730        }
731        box_it.forward(); 
732        bblob = box_it.data();
733        blob_box = bblob->bounding_box();
734        if (!bblob->joined_to_prev() && bblob->cblob() != nullptr) {
735          prev_gap = current_gap;
736          prev_within_xht_gap = current_within_xht_gap;
737          prev_blob_box = next_blob_box;
738          current_gap = next_gap;
739          current_within_xht_gap = next_within_xht_gap;
740          peek_at_next_gap(row, box_it, next_blob_box, next_gap, next_within_xht_gap);
741          int16_t prev_gap_arg = prev_gap;
742          int16_t next_gap_arg = next_gap;
743          if (tosp_only_use_xht_gaps) {
744            prev_gap_arg = prev_within_xht_gap;
745            next_gap_arg = next_within_xht_gap;
746          }
747          if (blob_box.left() > next_rep_char_word_right ||
748              make_a_word_break(row, blob_box, prev_gap_arg, prev_blob_box, current_gap,
749                                current_within_xht_gap, next_blob_box, next_gap_arg, blanks, fuzzy_sp,
750                                fuzzy_non, prev_gap_was_a_space, break_at_next_gap) ||
751              box_it.at_first()) {
752            word = new WERD(&cblobs, prev_blanks, nullptr);
753            word_count++;
754            word_it.add_after_then_move(word);
755            if (bol) {
756              word->set_flag(W_BOL, true);
757              bol = false;
758            }
759            if (prev_fuzzy_sp) {
760              word->set_flag(W_FUZZY_SP, true);
761            } else if (prev_fuzzy_non) {
762              word->set_flag(W_FUZZY_NON, true);
763            }
764            if (blob_box.left() > next_rep_char_word_right) {
765              word = rep_char_it.extract();
766              word_it.add_after_then_move(word);
767              repetition_spacing = find_mean_blob_spacing(word);
768              current_gap = word->bounding_box().left() - prev_x;
769              current_within_xht_gap = current_gap;
770              if (current_gap > tosp_rep_space * repetition_spacing) {
771                blanks = static_cast<uint8_t>(std::floor(current_gap / row->space_size));
772                if (blanks < 1) {
773                  blanks = 1;
774                }
775              } else {
776                blanks = 0;
777              }
778              if (tosp_debug_level > 5) {
779                tprintf("Repch wd (%d,%d) rep gap %5.2f;  Lgap:%d (%d blanks);",
780                        word->bounding_box().left(), word->bounding_box().bottom(),
781                        repetition_spacing, current_gap, blanks);
782              }
783              word->set_blanks(blanks);
784              word->set_flag(W_FUZZY_SP, false);
785              word->set_flag(W_FUZZY_NON, false);
786              current_gap = blob_box.left() - next_rep_char_word_right;
787              if (current_gap > tosp_rep_space * repetition_spacing) {
788                blanks = static_cast<uint8_t>(current_gap / row->space_size);
789                if (blanks < 1) {
790                  blanks = 1;
791                }
792              } else {
793                blanks = 0;
794              }
795              if (tosp_debug_level > 5) {
796                tprintf(" Rgap:%d (%d blanks)\n", current_gap, blanks);
797              }
798              fuzzy_sp = false;
799              fuzzy_non = false;
800              if (rep_char_it.empty()) {
801                next_rep_char_word_right = INT32_MAX;
802              } else {
803                rep_char_it.forward();
804                next_rep_char_word_right = rep_char_it.data()->bounding_box().right();
805              }
806            }
807            if (box_it.at_first() && rep_char_it.empty()) {
808              word->set_flag(W_EOL, true);
809              xstarts[1] = prev_x;
810            } else {
811              prev_blanks = blanks;
812              prev_fuzzy_sp = fuzzy_sp;
813              prev_fuzzy_non = fuzzy_non;
814            }
815          }
816        }
817      } while (!box_it.at_first()); 
818      while (!rep_char_it.empty()) {
819        word = rep_char_it.extract();
820        word_it.add_after_then_move(word);
821        repetition_spacing = find_mean_blob_spacing(word);
822        current_gap = word->bounding_box().left() - prev_x;
823        if (current_gap > tosp_rep_space * repetition_spacing) {
824          blanks = static_cast<uint8_t>(std::floor(current_gap / row->space_size));
825          if (blanks < 1) {
826            blanks = 1;
827          }
828        } else {
829          blanks = 0;
830        }
831        if (tosp_debug_level > 5) {
832          tprintf("Repch wd at EOL (%d,%d). rep spacing %5.2f; Lgap:%d (%d blanks)\n",
833                  word->bounding_box().left(), word->bounding_box().bottom(), repetition_spacing,
834                  current_gap, blanks);
835        }
836        word->set_blanks(blanks);
837        word->set_flag(W_FUZZY_SP, false);
838        word->set_flag(W_FUZZY_NON, false);
839        prev_x = word->bounding_box().right();
840        if (rep_char_it.empty()) {
841          word->set_flag(W_EOL, true);
842          xstarts[1] = prev_x;
843        } else {
844          rep_char_it.forward();
845        }
846      }
847      real_row =
848          new ROW(row, static_cast<int16_t>(row->kern_size), static_cast<int16_t>(row->space_size));
849      word_it.set_to_list(real_row->word_list());
850      word_it.add_list_after(&words);
851      real_row->recalc_bounding_box();
852      if (tosp_debug_level > 4) {
853        tprintf("Row: Made %d words in row ((%d,%d)(%d,%d))\n", word_count,
854                real_row->bounding_box().left(), real_row->bounding_box().bottom(),
855                real_row->bounding_box().right(), real_row->bounding_box().top());
856      }
857      return real_row;
858    }
859    return nullptr;
860  }
861  ROW *Textord::make_blob_words(TO_ROW *row,    
862                                FCOORD rotation 
863  ) {
864    bool bol;      
865    ROW *real_row; 
866    C_OUTLINE_IT cout_it;
867    C_BLOB_LIST cblobs;
868    C_BLOB_IT cblob_it = &cblobs;
869    WERD_LIST words;
870    WERD *word;         
871    BLOBNBOX_IT box_it; 
872    int16_t word_count = 0;
873    cblob_it.set_to_list(&cblobs);
874    box_it.set_to_list(row->blob_list());
875    WERD_IT word_it(&words);
876    bol = true;
877    if (!box_it.empty()) {
878      do {
879        auto bblob = box_it.data();
880        auto blob_box = bblob->bounding_box();
881        if (bblob->joined_to_prev()) {
882          auto cblob = bblob->remove_cblob();
883          if (cblob != nullptr) {
884            cout_it.set_to_list(cblob_it.data()->out_list());
885            cout_it.move_to_last();
886            cout_it.add_list_after(cblob->out_list());
887            delete cblob;
888          }
889        } else {
890          auto cblob = bblob->cblob();
891          if (cblob != nullptr) {
892            bblob->set_owns_cblob(false);
893            cblob_it.add_after_then_move(cblob);
894          }
895        }
896        box_it.forward(); 
897        bblob = box_it.data();
898        blob_box = bblob->bounding_box();
899        if (!bblob->joined_to_prev() && !cblobs.empty()) {
900          word = new WERD(&cblobs, 1, nullptr);
901          word_count++;
902          word_it.add_after_then_move(word);
903          if (bol) {
904            word->set_flag(W_BOL, true);
905            bol = false;
906          }
907          if (box_it.at_first()) { 
908            word->set_flag(W_EOL, true);
909          }
910        }
911      } while (!box_it.at_first()); 
912      real_row =
913          new ROW(row, static_cast<int16_t>(row->kern_size), static_cast<int16_t>(row->space_size));
914      word_it.set_to_list(real_row->word_list());
915      word_it.add_list_after(&words);
916      real_row->recalc_bounding_box();
917      if (tosp_debug_level > 4) {
918        tprintf("Row:Made %d words in row ((%d,%d)(%d,%d))\n", word_count,
919                real_row->bounding_box().left(), real_row->bounding_box().bottom(),
920                real_row->bounding_box().right(), real_row->bounding_box().top());
921      }
922      return real_row;
923    }
924    return nullptr;
925  }
926  bool Textord::make_a_word_break(TO_ROW *row,   
927                                  TBOX blob_box, 
928                                  int16_t prev_gap, TBOX prev_blob_box, int16_t real_current_gap,
929                                  int16_t within_xht_current_gap, TBOX next_blob_box,
930                                  int16_t next_gap, uint8_t &blanks, bool &fuzzy_sp, bool &fuzzy_non,
931                                  bool &prev_gap_was_a_space, bool &break_at_next_gap) {
932    bool space;
933    int16_t current_gap;
934    float fuzzy_sp_to_kn_limit;
935    if (break_at_next_gap) {
936      break_at_next_gap = false;
937      return true;
938    }
939    if ((row->kern_size > tosp_large_kerning * row->xheight) ||
940        ((tosp_dont_fool_with_small_kerns >= 0) &&
941         (real_current_gap < tosp_dont_fool_with_small_kerns * row->kern_size))) {
942      within_xht_current_gap = real_current_gap;
943    }
944    if (tosp_use_xht_gaps && tosp_only_use_xht_gaps) {
945      current_gap = within_xht_current_gap;
946    } else {
947      current_gap = real_current_gap;
948    }
949    if (tosp_old_to_method) {
950      space = current_gap > row->max_nonspace;
951      if (space && (current_gap < INT16_MAX)) {
952        if (current_gap < row->min_space) {
953          if (current_gap > row->space_threshold) {
954            blanks = 1;
955            fuzzy_sp = true;
956            fuzzy_non = false;
957          } else {
958            blanks = 0;
959            fuzzy_sp = false;
960            fuzzy_non = true;
961          }
962        } else {
963          if (row->space_size == 0.0f) {
964            blanks = 1;
965          } else {
966            blanks = static_cast<uint8_t>(current_gap / row->space_size);
967            if (blanks < 1) {
968              blanks = 1;
969            }
970          }
971          fuzzy_sp = false;
972          fuzzy_non = false;
973        }
974      }
975      return space;
976    } else {
977      if (prev_blob_box.null_box()) { 
978        prev_gap_was_a_space = true;
979      }
980      space = current_gap > row->space_threshold;
981      int num_blanks = current_gap;
982      if (row->space_size > 1.0f) {
983        num_blanks = IntCastRounded(current_gap / row->space_size);
984      }
985      blanks = static_cast<uint8_t>(ClipToRange<int>(num_blanks, 1, UINT8_MAX));
986      fuzzy_sp = false;
987      fuzzy_non = false;
988      if (tosp_use_xht_gaps && (real_current_gap <= row->max_nonspace) &&
989          (within_xht_current_gap > row->max_nonspace)) {
990        space = true;
991        fuzzy_non = true;
992  #ifndef GRAPHICS_DISABLED
993        mark_gap(blob_box, 20, prev_gap, prev_blob_box.width(), current_gap, next_blob_box.width(),
994                 next_gap);
995  #endif
996      } else if (tosp_use_xht_gaps && (real_current_gap <= row->space_threshold) &&
997                 (within_xht_current_gap > row->space_threshold)) {
998        space = true;
999        if (tosp_flip_fuzz_kn_to_sp) {
1000          fuzzy_sp = true;
1001        } else {
1002          fuzzy_non = true;
1003        }
1004  #ifndef GRAPHICS_DISABLED
1005        mark_gap(blob_box, 21, prev_gap, prev_blob_box.width(), current_gap, next_blob_box.width(),
1006                 next_gap);
1007  #endif
1008      } else if (tosp_use_xht_gaps && (real_current_gap < row->min_space) &&
1009                 (within_xht_current_gap >= row->min_space)) {
1010        space = true;
1011  #ifndef GRAPHICS_DISABLED
1012        mark_gap(blob_box, 22, prev_gap, prev_blob_box.width(), current_gap, next_blob_box.width(),
1013                 next_gap);
1014  #endif
1015      } else if (tosp_force_wordbreak_on_punct && !suspected_punct_blob(row, prev_blob_box) &&
1016                 suspected_punct_blob(row, blob_box)) {
1017        break_at_next_gap = true;
1018      }
1019      else if ((current_gap < row->min_space) && (current_gap > row->space_threshold)) {
1020        if (tosp_pass_wide_fuzz_sp_to_context > 0) {
1021          fuzzy_sp_to_kn_limit =
1022              row->kern_size + tosp_pass_wide_fuzz_sp_to_context * (row->space_size - row->kern_size);
1023        } else {
1024          fuzzy_sp_to_kn_limit = 99999.0f;
1025        }
1026        if ((prev_blob_box.width() > 0) && narrow_blob(row, prev_blob_box) && prev_gap_was_a_space &&
1027            (current_gap <= tosp_gap_factor * prev_gap)) {
1028          if ((tosp_all_flips_fuzzy) || (current_gap > fuzzy_sp_to_kn_limit)) {
1029            if (tosp_flip_fuzz_sp_to_kn) {
1030              fuzzy_non = true;
1031            } else {
1032              fuzzy_sp = true;
1033            }
1034          } else {
1035            space = false;
1036          }
1037  #ifndef GRAPHICS_DISABLED
1038          mark_gap(blob_box, 1, prev_gap, prev_blob_box.width(), current_gap, next_blob_box.width(),
1039                   next_gap);
1040  #endif
1041        }
1042        else if ((prev_blob_box.width() > 0) && narrow_blob(row, prev_blob_box) &&
1043                 !prev_gap_was_a_space && (current_gap * tosp_gap_factor <= prev_gap)) {
1044          if ((tosp_all_flips_fuzzy) || (current_gap > fuzzy_sp_to_kn_limit)) {
1045            if (tosp_flip_fuzz_sp_to_kn) {
1046              fuzzy_non = true;
1047            } else {
1048              fuzzy_sp = true;
1049            }
1050          } else {
1051            space = false;
1052          }
1053  #ifndef GRAPHICS_DISABLED
1054          mark_gap(blob_box, 2, prev_gap, prev_blob_box.width(), current_gap, next_blob_box.width(),
1055                   next_gap);
1056  #endif
1057        } else if ((next_blob_box.width() > 0) && narrow_blob(row, next_blob_box) &&
1058                   (next_gap > row->space_threshold) && (current_gap <= tosp_gap_factor * next_gap)) {
1059          if ((tosp_all_flips_fuzzy) || (current_gap > fuzzy_sp_to_kn_limit)) {
1060            if (tosp_flip_fuzz_sp_to_kn) {
1061              fuzzy_non = true;
1062            } else {
1063              fuzzy_sp = true;
1064            }
1065          } else {
1066            space = false;
1067          }
1068  #ifndef GRAPHICS_DISABLED
1069          mark_gap(blob_box, 3, prev_gap, prev_blob_box.width(), current_gap, next_blob_box.width(),
1070                   next_gap);
1071  #endif
1072        } else if ((next_blob_box.width() > 0) && narrow_blob(row, next_blob_box) &&
1073                   (next_gap <= row->space_threshold) &&
1074                   (current_gap * tosp_gap_factor <= next_gap)) {
1075          if ((tosp_all_flips_fuzzy) || (current_gap > fuzzy_sp_to_kn_limit)) {
1076            if (tosp_flip_fuzz_sp_to_kn) {
1077              fuzzy_non = true;
1078            } else {
1079              fuzzy_sp = true;
1080            }
1081          } else {
1082            space = false;
1083          }
1084  #ifndef GRAPHICS_DISABLED
1085          mark_gap(blob_box, 4, prev_gap, prev_blob_box.width(), current_gap, next_blob_box.width(),
1086                   next_gap);
1087  #endif
1088        } else if ((((next_blob_box.width() > 0) && narrow_blob(row, next_blob_box)) ||
1089                    ((prev_blob_box.width() > 0) && narrow_blob(row, prev_blob_box)))) {
1090          fuzzy_sp = true;
1091  #ifndef GRAPHICS_DISABLED
1092          mark_gap(blob_box, 6, prev_gap, prev_blob_box.width(), current_gap, next_blob_box.width(),
1093                   next_gap);
1094  #endif
1095        }
1096      } else if ((current_gap > row->max_nonspace) && (current_gap <= row->space_threshold)) {
1097        if ((prev_blob_box.width() > 0) && (next_blob_box.width() > 0) &&
1098            (current_gap >= tosp_kern_gap_factor1 * std::max(prev_gap, next_gap)) &&
1099            wide_blob(row, prev_blob_box) && wide_blob(row, next_blob_box)) {
1100          space = true;
1101          if ((tosp_flip_fuzz_kn_to_sp) &&
1102              ((tosp_flip_caution <= 0) || (tosp_flip_caution * row->kern_size > row->space_size))) {
1103            fuzzy_sp = true;
1104          } else {
1105            fuzzy_non = true;
1106          }
1107  #ifndef GRAPHICS_DISABLED
1108          mark_gap(blob_box, 7, prev_gap, prev_blob_box.width(), current_gap, next_blob_box.width(),
1109                   next_gap);
1110  #endif
1111        } else if (prev_blob_box.width() > 0 && next_blob_box.width() > 0 &&
1112                   current_gap > 5 && 
1113                   current_gap >= tosp_kern_gap_factor2 * std::max(prev_gap, next_gap) &&
1114                   !(narrow_blob(row, prev_blob_box) || suspected_punct_blob(row, prev_blob_box)) &&
1115                   !(narrow_blob(row, next_blob_box) || suspected_punct_blob(row, next_blob_box))) {
1116          space = true;
1117          fuzzy_non = true;
1118  #ifndef GRAPHICS_DISABLED
1119          mark_gap(blob_box, 8, prev_gap, prev_blob_box.width(), current_gap, next_blob_box.width(),
1120                   next_gap);
1121  #endif
1122        } else if ((tosp_kern_gap_factor3 > 0) && (prev_blob_box.width() > 0) &&
1123                   (next_blob_box.width() > 0) &&
1124                   (current_gap >= tosp_kern_gap_factor3 * std::max(prev_gap, next_gap)) &&
1125                   (!tosp_rule_9_test_punct || (!suspected_punct_blob(row, prev_blob_box) &&
1126                                                !suspected_punct_blob(row, next_blob_box)))) {
1127          space = true;
1128          fuzzy_non = true;
1129  #ifndef GRAPHICS_DISABLED
1130          mark_gap(blob_box, 9, prev_gap, prev_blob_box.width(), current_gap, next_blob_box.width(),
1131                   next_gap);
1132  #endif
1133        }
1134      }
1135      if (tosp_debug_level > 10) {
1136        tprintf(
1137            "word break = %d current_gap = %d, prev_gap = %d, "
1138            "next_gap = %d\n",
1139            space ? 1 : 0, current_gap, prev_gap, next_gap);
1140      }
1141      prev_gap_was_a_space = space && !(fuzzy_non);
1142      return space;
1143    }
1144  }
1145  bool Textord::narrow_blob(TO_ROW *row, TBOX blob_box) {
1146    bool result;
1147    result =
1148        ((blob_box.width() <= tosp_narrow_fraction * row->xheight) ||
1149         ((static_cast<float>(blob_box.width()) / blob_box.height()) <= tosp_narrow_aspect_ratio));
1150    return result;
1151  }
1152  bool Textord::wide_blob(TO_ROW *row, TBOX blob_box) {
1153    bool result;
1154    if (tosp_wide_fraction > 0) {
1155      if (tosp_wide_aspect_ratio > 0) {
1156        result =
1157            ((blob_box.width() >= tosp_wide_fraction * row->xheight) &&
1158             ((static_cast<float>(blob_box.width()) / blob_box.height()) > tosp_wide_aspect_ratio));
1159      } else {
1160        result = (blob_box.width() >= tosp_wide_fraction * row->xheight);
1161      }
1162    } else {
1163      result = !narrow_blob(row, blob_box);
1164    }
1165    return result;
1166  }
1167  bool Textord::suspected_punct_blob(TO_ROW *row, TBOX box) {
1168    bool result;
1169    float baseline;
1170    float blob_x_centre;
1171    blob_x_centre = (box.right() + box.left()) / 2.0;
1172    baseline = row->baseline.y(blob_x_centre);
1173    result = (box.height() <= 0.66 * row->xheight) || (box.top() < baseline + row->xheight / 2.0) ||
1174             (box.bottom() > baseline + row->xheight / 2.0);
1175    return result;
1176  }
1177  void Textord::peek_at_next_gap(TO_ROW *row, BLOBNBOX_IT box_it, TBOX &next_blob_box,
1178                                 int16_t &next_gap, int16_t &next_within_xht_gap) {
1179    TBOX next_reduced_blob_box;
1180    TBOX bit_beyond;
1181    BLOBNBOX_IT reduced_box_it = box_it;
1182    next_blob_box = box_next(&box_it);
1183    next_reduced_blob_box = reduced_box_next(row, &reduced_box_it);
1184    if (box_it.at_first()) {
1185      next_gap = INT16_MAX;
1186      next_within_xht_gap = INT16_MAX;
1187    } else {
1188      bit_beyond = box_it.data()->bounding_box();
1189      next_gap = bit_beyond.left() - next_blob_box.right();
1190      bit_beyond = reduced_box_next(row, &reduced_box_it);
1191      next_within_xht_gap = bit_beyond.left() - next_reduced_blob_box.right();
1192    }
1193  }
1194  #ifndef GRAPHICS_DISABLED
1195  void Textord::mark_gap(TBOX blob,    
1196                         int16_t rule, 
1197                         int16_t prev_gap, int16_t prev_blob_width, int16_t current_gap,
1198                         int16_t next_blob_width, int16_t next_gap) {
1199    ScrollView::Color col; 
1200    switch (rule) {
1201      case 1:
1202        col = ScrollView::RED;
1203        break;
1204      case 2:
1205        col = ScrollView::CYAN;
1206        break;
1207      case 3:
1208        col = ScrollView::GREEN;
1209        break;
1210      case 4:
1211        col = ScrollView::BLACK;
1212        break;
1213      case 5:
1214        col = ScrollView::MAGENTA;
1215        break;
1216      case 6:
1217        col = ScrollView::BLUE;
1218        break;
1219      case 7:
1220        col = ScrollView::WHITE;
1221        break;
1222      case 8:
1223        col = ScrollView::YELLOW;
1224        break;
1225      case 9:
1226        col = ScrollView::BLACK;
1227        break;
1228      case 20:
1229        col = ScrollView::CYAN;
1230        break;
1231      case 21:
1232        col = ScrollView::GREEN;
1233        break;
1234      case 22:
1235        col = ScrollView::MAGENTA;
1236        break;
1237      default:
1238        col = ScrollView::BLACK;
1239    }
1240    if (textord_show_initial_words) {
1241      to_win->Pen(col);
1242      to_win->Ellipse(current_gap / 2.0f,
1243                      blob.height() / 2.0f, 
1244                      blob.left() - current_gap / 2.0f,
1245                      blob.bottom() + blob.height() / 2.0f);
1246    }
1247    if (tosp_debug_level > 5) {
1248      tprintf("  (%d,%d) Sp<->Kn Rule %d %d %d %d %d %d\n", blob.left() - current_gap / 2,
1249              blob.bottom(), rule, prev_gap, prev_blob_width, current_gap, next_blob_width, next_gap);
1250    }
1251  }
1252  #endif
1253  float Textord::find_mean_blob_spacing(WERD *word) {
1254    C_BLOB_IT cblob_it;
1255    TBOX blob_box;
1256    int32_t gap_sum = 0;
1257    int16_t gap_count = 0;
1258    int16_t prev_right;
1259    cblob_it.set_to_list(word->cblob_list());
1260    if (!cblob_it.empty()) {
1261      cblob_it.mark_cycle_pt();
1262      prev_right = cblob_it.data()->bounding_box().right();
1263      cblob_it.forward();
1264      for (; !cblob_it.cycled_list(); cblob_it.forward()) {
1265        blob_box = cblob_it.data()->bounding_box();
1266        gap_sum += blob_box.left() - prev_right;
1267        gap_count++;
1268        prev_right = blob_box.right();
1269      }
1270    }
1271    if (gap_count > 0) {
1272      return (gap_sum / static_cast<float>(gap_count));
1273    } else {
1274      return 0.0f;
1275    }
1276  }
1277  bool Textord::ignore_big_gap(TO_ROW *row, int32_t row_length, GAPMAP *gapmap, int16_t left,
1278                               int16_t right) {
1279    int16_t gap = right - left + 1;
1280    if (tosp_ignore_big_gaps > 999) {
1281      return false; 
1282    }
1283    if (tosp_ignore_big_gaps > 0) {
1284      return (gap > tosp_ignore_big_gaps * row->xheight);
1285    }
1286    if (gap > tosp_ignore_very_big_gaps * row->xheight) {
1287      return true;
1288    }
1289    if (tosp_ignore_big_gaps == 0) {
1290      if ((gap > 2.1 * row->xheight) && (row_length > 20 * row->xheight)) {
1291        return true;
1292      }
1293      if ((gap > 1.75 * row->xheight) &&
1294          ((row_length > 35 * row->xheight) || gapmap->table_gap(left, right))) {
1295        return true;
1296      }
1297    } else {
1298      if ((gap > gapmap_big_gaps * row->xheight) && gapmap->table_gap(left, right)) {
1299        return true;
1300      }
1301    }
1302    return false;
1303  }
1304  TBOX Textord::reduced_box_next(TO_ROW *row,    
1305                                 BLOBNBOX_IT *it 
1306  ) {
1307    BLOBNBOX *blob;             
1308    BLOBNBOX *head_blob;        
1309    TBOX full_box;              
1310    TBOX reduced_box;           
1311    int16_t left_above_xht;     
1312    int16_t new_left_above_xht; 
1313    blob = it->data();
1314    if (blob->red_box_set()) {
1315      reduced_box = blob->reduced_box();
1316      do {
1317        it->forward();
1318        blob = it->data();
1319      } while (blob->cblob() == nullptr || blob->joined_to_prev());
1320      return reduced_box;
1321    }
1322    head_blob = blob;
1323    full_box = blob->bounding_box();
1324    reduced_box = reduced_box_for_blob(blob, row, &left_above_xht);
1325    do {
1326      it->forward();
1327      blob = it->data();
1328      if (blob->cblob() == nullptr) {
1329        full_box += blob->bounding_box();
1330      } else if (blob->joined_to_prev()) {
1331        reduced_box += reduced_box_for_blob(blob, row, &new_left_above_xht);
1332        left_above_xht = std::min(left_above_xht, new_left_above_xht);
1333      }
1334    }
1335    while (blob->cblob() == nullptr || blob->joined_to_prev());
1336    if ((reduced_box.width() > 0) &&
1337        ((reduced_box.left() + tosp_near_lh_edge * reduced_box.width()) < left_above_xht) &&
1338        (reduced_box.height() > 0.7 * row->xheight)) {
1339  #ifndef GRAPHICS_DISABLED
1340      if (textord_show_initial_words) {
1341        reduced_box.plot(to_win, ScrollView::YELLOW, ScrollView::YELLOW);
1342      }
1343  #endif
1344    } else {
1345      reduced_box = full_box;
1346    }
1347    head_blob->set_reduced_box(reduced_box);
1348    return reduced_box;
1349  }
1350  TBOX Textord::reduced_box_for_blob(BLOBNBOX *blob, TO_ROW *row, int16_t *left_above_xht) {
1351    float baseline;
1352    float blob_x_centre;
1353    float left_limit;
1354    float right_limit;
1355    float junk;
1356    TBOX blob_box;
1357    blob_box = blob->bounding_box();
1358    blob_x_centre = (blob_box.left() + blob_box.right()) / 2.0;
1359    baseline = row->baseline.y(blob_x_centre);
1360    left_limit = static_cast<float>(INT32_MAX);
1361    junk = static_cast<float>(-INT32_MAX);
1362    find_cblob_hlimits(blob->cblob(), (baseline + 1.1 * row->xheight), static_cast<float>(INT16_MAX),
1363                       left_limit, junk);
1364    if (left_limit > junk) {
1365      *left_above_xht = INT16_MAX; 
1366    } else {
1367      *left_above_xht = static_cast<int16_t>(std::floor(left_limit));
1368    }
1369    left_limit = static_cast<float>(INT32_MAX);
1370    junk = static_cast<float>(-INT32_MAX);
1371    find_cblob_hlimits(blob->cblob(), baseline, static_cast<float>(INT16_MAX), left_limit, junk);
1372    if (left_limit > junk) {
1373      return TBOX(); 
1374    }
1375    junk = static_cast<float>(INT32_MAX);
1376    right_limit = static_cast<float>(-INT32_MAX);
1377    find_cblob_hlimits(blob->cblob(), static_cast<float>(-INT16_MAX), (baseline + row->xheight), junk,
1378                       right_limit);
1379    if (junk > right_limit) {
1380      return TBOX(); 
1381    }
1382    return TBOX(ICOORD(static_cast<int16_t>(std::floor(left_limit)), blob_box.bottom()),
1383                ICOORD(static_cast<int16_t>(std::ceil(right_limit)), blob_box.top()));
1384  }
1385  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-odbc.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-tospace.cpp</div>
                </div>
                <div class="column column_space"><pre><code>217          } else
218          if (TTm::GetTmFromWebLogDateTimeStr(ParamStr).IsDef()){
219            SQLLEN StrLenOrInd=SQL_NTS;
220            OpAssert(SQLBindParameter(
221             StmtHnd, 1+ParamN, SQL_PARAM_INPUT,
222             SQL_C_CHAR, SQL_TYPE_TIMESTAMP,
223             (SQLLEN)ParamStr.Len(), 0,
224             (SQLCHAR*)ParamStr.CStr(),
225             (SQLLEN)ParamStr.Len(),
226             &StrLenOrInd));
227          } else {
228            SQLLEN StrLenOrInd=SQL_NTS;
229            OpAssert(SQLBindParameter(
230             StmtHnd, 1+ParamN, SQL_PARAM_INPUT,
231             SQL_C_CHAR, SQL_CHAR,
232             (SQLLEN)ParamStr.Len(), 0,
233             (SQLCHAR*)ParamStr.CStr(),
234             (SQLLEN)ParamStr.Len(),
235             &StrLenOrInd));
236          }
</pre></code></div>
                <div class="column column_space"><pre><code>91        } else if (tosp_stats_use_xht_gaps) {
92          blob_box = reduced_box_next(row, &blob_it);
93        } else {
94          blob_box = box_next(&blob_it);
95        }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    