<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for TestSinc.cpp & TestVarSet.cpp</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for TestSinc.cpp & TestVarSet.cpp
      </h3>
      <h1 align="center">
        8.3%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>TestSinc.cpp (17.80822%)<TH>TestVarSet.cpp (5.462185%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match1132-0.html#0',2,'match1132-1.html#0',3)" NAME="0">(55-61)<TD><A HREF="javascript:ZweiFrames('match1132-0.html#0',2,'match1132-1.html#0',3)" NAME="0">(191-197)</A><TD ALIGN=center><FONT COLOR="#ff0000">13</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>TestSinc.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* ============================================================================
 * I B E X - Operators Tests
 * ============================================================================
 * Copyright   : IMT Atlantique (FRANCE)
 * License     : This program can be distributed under the terms of the GNU LGPL.
 *               See the file COPYING.LESSER.
 *
 * Author(s)   : Gilles Chabert
 * Created     : Oct 7, 2018
 * ---------------------------------------------------------------------------- */

#include &quot;TestSinc.h&quot;
#include &quot;ibex_ExprOperators.h&quot;
#include &quot;ibex_Solver.h&quot;
#include &quot;ibex_SystemFactory.h&quot;
#include &quot;ibex_CtcFwdBwd.h&quot;
#include &quot;ibex_RoundRobin.h&quot;
#include &quot;ibex_CellStack.h&quot;

using namespace std;

namespace ibex {

void TestSinc::eval1() {
	Interval x(1,2);
	CPPUNIT_ASSERT(sinc(x)==(sin(x)/x));
}

void TestSinc::callbacks() {
	Domain a(Dim::scalar());
	a.i()=Interval(1,2);
	Domain b(Dim::scalar());
	b.i()=sinc(a.i());
  	const ExprSymbol&amp; x=ExprSymbol::new_(&quot;x&quot;);
	const ExprGenericUnaryOp&amp; y=ExprGenericUnaryOp::new_(&quot;sinc&quot;,x);

	CPPUNIT_ASSERT(y.size==2);
	CPPUNIT_ASSERT(y.dim.type()==Dim::SCALAR);
	CPPUNIT_ASSERT(y.eval(a)==b);
	CPPUNIT_ASSERT(sameExpr(y,&quot;sinc(x)&quot;));

	Interval a_save=a.i();
	y.bwd(b,a);
	CPPUNIT_ASSERT(a.i().is_subset(a_save));
	CPPUNIT_ASSERT(b.i().is_subset(sinc(a.i())));

	Domain g(Dim::scalar());
	g.i()=Interval::one();
	CPPUNIT_ASSERT(y.num_diff(a,g).i()==(a.i()*cos(a.i())-sin(a.i()))/sqr(a.i()));

	const ExprNode&amp; gnode=ExprConstant::new_scalar(Interval::one());
<A NAME="0"></A>	const ExprNode&amp; e=y.symb_diff(x,gnode);
	CPPUNIT_ASSERT(e.size == 9);
	cleanup(y,true);
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match1132-1.html#0',3,'match1132-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>}

void TestSinc::simplify() {
    Interval cst(2,2);
  	const ExprConstant&amp; x=ExprConstant::new_scalar(cst);
	const ExprNode&amp; y=ExprGenericUnaryOp::new_(&quot;sinc&quot;,x);
	const ExprNode&amp; z=y.simplify(ExprNode::default_simpl_level);</B></FONT>
	const ExprConstant* zz=dynamic_cast&lt;const ExprConstant*&gt;(&amp;z);
	CPPUNIT_ASSERT(zz!=NULL);
	CPPUNIT_ASSERT(zz-&gt;get_value()==sinc(Interval(2,2)));
	cleanup(z,true);
}

void TestSinc::gradient() {
    const ExprSymbol&amp; _x=ExprSymbol::new_(&quot;x&quot;);
	const ExprGenericUnaryOp&amp; y=ExprGenericUnaryOp::new_(&quot;sinc&quot;,_x);
    const ExprNode&amp; e=y*_x;
    Function f(_x,e);

    IntervalVector x(1,Interval(2,2));
    IntervalVector g=f.gradient(x);
    CPPUNIT_ASSERT(g[0]==x[0]*(x[0]*cos(x[0])-sin(x[0]))/sqr(x[0]) + sinc(x[0]));
}


void TestSinc::solve() {
    const ExprSymbol&amp; x=ExprSymbol::new_(&quot;x&quot;);
	const ExprNode&amp; y=ExprGenericUnaryOp::new_(&quot;sinc&quot;,x);

    SystemFactory fac;
    fac.add_var(x);
    fac.add_ctr(y=Interval(0.5,0.5));
    System sys(fac);

    CtcFwdBwd c(sys.f_ctrs[0]);
    RoundRobin rr(1e-7);
    CellStack stack;

	Solver solver(sys, c, rr, stack, Vector(1,1e-7), Vector(1,1e-7));
	solver.solve(IntervalVector(1,Interval(-100,100)));

    CPPUNIT_ASSERT(solver.get_data().nb_solution()==2);
    CPPUNIT_ASSERT(solver.get_data().nb_unknown()==1);
    Interval sol=solver.get_data().solution(1)[0];
    CPPUNIT_ASSERT(almost_eq(sin(sol),0.5*sol,1e-6));
}



} // end namespace
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>TestVarSet.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* ============================================================================
 * I B E X - VarSet Tests
 * ============================================================================
 * Copyright   : Ecole des Mines de Nantes (FRANCE)
 * License     : This program can be distributed under the terms of the GNU LGPL.
 *               See the file COPYING.LESSER.
 *
 * Author(s)   : Gilles Chabert
 * Created     : Sep 02, 2015
 * ---------------------------------------------------------------------------- */

#include &quot;TestVarSet.h&quot;
#include &quot;ibex_VarSet.h&quot;
#include &quot;ibex_Function.h&quot;

namespace ibex {


void TestVarSet::test01() {
	const ExprSymbol&amp; x=ExprSymbol::new_(&quot;x&quot;);
	const ExprSymbol&amp; y=ExprSymbol::new_(&quot;y&quot;);
	const ExprSymbol&amp; z=ExprSymbol::new_(&quot;z&quot;);
	Function f(x,y,z,x+y+z);

	IntervalVector y_box(1,Interval(1,2));
	VarSet set(f,x,z);

	CPPUNIT_ASSERT(set.is_var[0]);
	CPPUNIT_ASSERT(!set.is_var[1]);
	CPPUNIT_ASSERT(set.is_var[2]);
	CPPUNIT_ASSERT(set.nb_param==1);
	CPPUNIT_ASSERT(set.nb_var==2);
	CPPUNIT_ASSERT(set.var(0)==0);
	CPPUNIT_ASSERT(set.var(1)==2);
	CPPUNIT_ASSERT(set.param(0)==1);

	IntervalVector x_box(2,Interval(0,1));
	IntervalVector fullbox=set.full_box(x_box,y_box);
	double _fullbox[][2]={{0,1},{1,2},{0,1}};
	CPPUNIT_ASSERT(fullbox==IntervalVector(3,_fullbox));

}

void TestVarSet::test02() {
	const ExprSymbol&amp; x=ExprSymbol::new_(&quot;x&quot;,Dim::col_vec(3));
	const ExprSymbol&amp; y=ExprSymbol::new_(&quot;y&quot;,Dim::col_vec(3));
	const ExprSymbol&amp; z=ExprSymbol::new_(&quot;z&quot;);
	Function f(x,y,z,(x+y)[0]+z);

	IntervalVector y_box(3,Interval(1,2));
	VarSet set(f,x,z);

	CPPUNIT_ASSERT(set.is_var[0]);
	CPPUNIT_ASSERT(set.is_var[1]);
	CPPUNIT_ASSERT(set.is_var[2]);
	CPPUNIT_ASSERT(!set.is_var[3]);
	CPPUNIT_ASSERT(!set.is_var[4]);
	CPPUNIT_ASSERT(!set.is_var[5]);
	CPPUNIT_ASSERT(set.is_var[6]);
	CPPUNIT_ASSERT(set.nb_param==3);
	CPPUNIT_ASSERT(set.nb_var==4);
	CPPUNIT_ASSERT(set.var(0)==0);
	CPPUNIT_ASSERT(set.var(1)==1);
	CPPUNIT_ASSERT(set.var(2)==2);
	CPPUNIT_ASSERT(set.var(3)==6);
	CPPUNIT_ASSERT(set.param(0)==3);
	CPPUNIT_ASSERT(set.param(1)==4);
	CPPUNIT_ASSERT(set.param(2)==5);

	IntervalVector x_box(4,Interval(0,1));
	IntervalVector fullbox=set.full_box(x_box,y_box);

	double _fullbox[][2]={{0,1},{0,1},{0,1},
			         {1,2},{1,2},{1,2},
			         {0,1}};
	CPPUNIT_ASSERT(fullbox==IntervalVector(7,_fullbox));
}

void TestVarSet::test03() {
	const ExprSymbol&amp; x=ExprSymbol::new_(&quot;x&quot;,Dim::col_vec(3));
	const ExprSymbol&amp; y=ExprSymbol::new_(&quot;y&quot;,Dim::col_vec(3));
	const ExprSymbol&amp; z=ExprSymbol::new_(&quot;z&quot;);
	Function f(x,y,z,(x+y)[0]+z);

	IntervalVector y_box(3,Interval(1,2));
	VarSet set(f,x[0],x[2],y[0],y[1]);

	CPPUNIT_ASSERT(set.is_var[0]);
	CPPUNIT_ASSERT(!set.is_var[1]);
	CPPUNIT_ASSERT(set.is_var[2]);
	CPPUNIT_ASSERT(set.is_var[3]);
	CPPUNIT_ASSERT(set.is_var[4]);
	CPPUNIT_ASSERT(!set.is_var[5]);
	CPPUNIT_ASSERT(!set.is_var[6]);
	CPPUNIT_ASSERT(set.nb_param==3);
	CPPUNIT_ASSERT(set.nb_var==4);
	CPPUNIT_ASSERT(set.var(0)==0);
	CPPUNIT_ASSERT(set.var(1)==2);
	CPPUNIT_ASSERT(set.var(2)==3);
	CPPUNIT_ASSERT(set.var(3)==4);
	CPPUNIT_ASSERT(set.param(0)==1);
	CPPUNIT_ASSERT(set.param(1)==5);
	CPPUNIT_ASSERT(set.param(2)==6);

	IntervalVector x_box(4,Interval(0,1));
	IntervalVector fullbox=set.full_box(x_box,y_box);

	double _fullbox[][2]={{0,1},{1,2},{0,1},
			              {0,1},{0,1},{1,2},
			              {1,2}};
	CPPUNIT_ASSERT(fullbox==IntervalVector(7,_fullbox));
}

void TestVarSet::test04() {
	const ExprSymbol&amp; x=ExprSymbol::new_(&quot;x&quot;,Dim::col_vec(3));
	const ExprSymbol&amp; A=ExprSymbol::new_(&quot;A&quot;,Dim::matrix(2,3));
	const ExprSymbol&amp; y=ExprSymbol::new_(&quot;y&quot;,Dim::col_vec(2));

	Function f(x,A,y,A*x+y);

	IntervalVector y_box(7,Interval(1,2));
	VarSet set(f,x,y[1]);

	int i=0;
	for (; i&lt;3; i++) {
		CPPUNIT_ASSERT(set.is_var[i]);
		CPPUNIT_ASSERT(set.var(i)==i);
	}
	for (; i&lt;10; i++) {
		CPPUNIT_ASSERT(!set.is_var[i]);
		CPPUNIT_ASSERT(set.param(i-3)==i);

	}
	CPPUNIT_ASSERT(set.is_var[10]);
	CPPUNIT_ASSERT(set.var(3)==10);
	CPPUNIT_ASSERT(set.nb_var==4);
	CPPUNIT_ASSERT(set.nb_param==7);

	IntervalVector x_box(4,Interval(0,1));
	IntervalVector fullbox=set.full_box(x_box,y_box);

	double _fullbox[][2]={{0,1},{0,1},{0,1},
	                 {1,2},{1,2},{1,2},
	                 {1,2},{1,2},{1,2},
			         {1,2},{0,1}};

	CPPUNIT_ASSERT(fullbox==IntervalVector(11,_fullbox));
}

void TestVarSet::test05() {
	const ExprSymbol&amp; A=ExprSymbol::new_(&quot;A&quot;,Dim::matrix(2,3));
	const ExprSymbol&amp; B=ExprSymbol::new_(&quot;B&quot;,Dim::matrix(2,3));

	Function f(A,B,A+B);

	IntervalVector y_box(4,Interval(1,2));
	VarSet set(f,A[0],B[0][0],B[0][2],B[1]);

	int i=0;
	int v=0;
	int p=0;
	for (; i&lt;3; i++) {
		CPPUNIT_ASSERT(set.is_var[i]);
		CPPUNIT_ASSERT(set.var(v++)==i);
	}
	for (; i&lt;6; i++) {
		CPPUNIT_ASSERT(!set.is_var[i]);
		CPPUNIT_ASSERT(set.param(p++)==i);
	}
	CPPUNIT_ASSERT(set.is_var[6]);
	CPPUNIT_ASSERT(set.var(v++)==6);
	CPPUNIT_ASSERT(!set.is_var[7]);
	CPPUNIT_ASSERT(set.param(p++)==7);
	for (i=8; i&lt;11; i++) {
		CPPUNIT_ASSERT(set.is_var[i]);
		CPPUNIT_ASSERT(set.var(v++)==i);
	}

	CPPUNIT_ASSERT(set.nb_param==4);
	CPPUNIT_ASSERT(set.nb_var==8);

	IntervalVector x_box(8,Interval(0,1));
	IntervalVector fullbox=set.full_box(x_box,y_box);

	double _fullbox[][2]={{0,1},{0,1},{0,1},
	                 {1,2},{1,2},{1,2},
	                 {0,1},{1,2},{0,1},
<A NAME="0"></A>	                 {0,1},{0,1},{0,1}};

	CPPUNIT_ASSERT(fullbox==IntervalVector(12,_fullbox));
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1132-0.html#0',2,'match1132-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}


void TestVarSet::test06() {
	const ExprSymbol&amp; x=ExprSymbol::new_(&quot;x&quot;);
	const ExprSymbol&amp; y=ExprSymbol::new_(&quot;y&quot;);
	const ExprSymbol&amp; z=ExprSymbol::new_(&quot;z&quot;);</B></FONT>
	Function f(x,y,z,x+y+z);

	BitSet vars=BitSet::empty(3);
	vars.add(0);
	vars.add(2);
	VarSet set(3,vars);

	IntervalVector y_box(1,Interval(1,2));

	CPPUNIT_ASSERT(set.is_var[0]);
	CPPUNIT_ASSERT(set.var(0)==0);
	CPPUNIT_ASSERT(!set.is_var[1]);
	CPPUNIT_ASSERT(set.param(0)==1);
	CPPUNIT_ASSERT(set.is_var[2]);
	CPPUNIT_ASSERT(set.var(1)==2);

	CPPUNIT_ASSERT(set.nb_param==1);
	CPPUNIT_ASSERT(set.nb_var==2);

	IntervalVector x_box(2,Interval(0,1));
	IntervalVector fullbox=set.full_box(x_box,y_box);
	double _fullbox[][2]={{0,1},{1,2},{0,1}};
	CPPUNIT_ASSERT(fullbox==IntervalVector(3,_fullbox));

}

} // namespace ibex
</PRE>
</div>
  </div>
</body>
</html>
